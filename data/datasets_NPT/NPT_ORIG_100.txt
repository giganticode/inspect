tr	10	private map < string , string > loadpropertiesfromstream ( inputstream in ) throws optionsexception { bufferedreader reader = new bufferedreader ( new inputstreamreader ( in , charset . forname ( "utf8" ) ) ) ; final map < string , string > properties = new hashmap < string , string > ( ) ; try { string s ; while ( ( s = reader . readline ( ) ) != null ) { s = s . trim ( ) ; if ( s . isempty ( ) || s . startswith ( "#" ) ) continue ; final int p = s . indexof ( '=' ) ; if ( p < 0 ) continue ; final string key = s . substring ( 0 , p ) . trim ( ) ; final string value = s . substring ( p + 1 , s . length ( ) ) . trim ( ) ; properties . put ( key , value ) ; } } catch ( ioexception e ) { throw new optionsexception ( "error reading options file: " + optionsfile . getabsolutepath ( ) , e ) ; } finally { try { reader . close ( ) ; } catch ( ioexception e ) { throw new optionsexception ( "error closing options file reader: " + optionsfile . getabsolutepath ( ) , e ) ; } } return properties ; }
tr	10	public void load ( string filedict , string fileother , mode mode ) { if ( filedict != null ) { dict = new dictionary ( ) ; dict . gettext ( filedict ) ; } if ( mode == mode . dmc ) { dmc = new dmm ( ) ; dmc . load ( fileother ) ; } else if ( mode == mode . hmm ) { hmm = new hmmpre ( ) ; hmm . load ( fileother ) ; } else if ( mode == mode . hmmend ) { hmmend = new hmm ( ) ; hmmend . load ( fileother ) ; } else if ( mode == mode . vlmc ) { vlmc = new pst ( ) ; vlmc . load ( fileother ) ; } else { ngrams = new ngram ( this . ngramsize ) ; ngrams . gettext ( fileother ) ; } }
tr	10	public static boolean testriffle ( int [ ] shuffleddeck , int shuffleddeckindex , int [ ] half1 , int half1index , int [ ] half2 , int half2index ) { if ( shuffleddeckindex == shuffleddeck . length ) { return true ; } if ( half1index < half1 . length && shuffleddeck [ shuffleddeckindex ] == half1 [ half1index ] ) { return testriffle ( shuffleddeck , shuffleddeckindex ++ , half1 , half1index ++ , half2 , half2index ) ; } else if ( half2index < half2 . length && shuffleddeck [ shuffleddeckindex ] == half2 [ half2index ] ) { return testriffle ( shuffleddeck , shuffleddeckindex ++ , half1 , half1index ++ , half2 , half2index ) ; } else { return false ; } }
tr	6	@ override public void getfromweb ( url getfilefrom , callback < string > callback ) { inputstream inputstream = null ; stringbuilder stringbuilder = new stringbuilder ( ) ; try { inputstream = getfilefrom . openstream ( ) ; inputstreamreader bufferedinputstream = new inputstreamreader ( inputstream ) ; bufferedreader bufferedreader = new bufferedreader ( bufferedinputstream ) ; system . out . println ( "open connection to: " + getfilefrom ) ; string line = bufferedreader . readline ( ) ; while ( line != null ) { stringbuilder . append ( line ) ; line = bufferedreader . readline ( ) ; } system . out . println ( "finished reading the html file to string" ) ; system . out . println ( "string read is: " + stringbuilder . tostring ( ) ) ; } catch ( ioexception e ) { callback . done ( null , e ) ; } finally { if ( inputstream != null ) { try { inputstream . close ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } } } callback . done ( stringbuilder . tostring ( ) , null ) ; }
tr	9	public void drop ( droptargetdropevent e ) { try { dataflavor stringflavor = dataflavor . stringflavor ; transferable tr = e . gettransferable ( ) ; if ( e . isdataflavorsupported ( stringflavor ) ) { string filename = ( string ) tr . gettransferdata ( stringflavor ) ; if ( filename . endswith ( ".txt" ) || filename . endswith ( ".java" ) || filename . endswith ( ".jsp" ) || filename . endswith ( ".html" ) || filename . endswith ( ".htm" ) ) { e . acceptdrop ( dndconstants . action_copy_or_move ) ; readfile ( filename ) ; textpane . setcaretposition ( 0 ) ; e . dropcomplete ( true ) ; } else { e . rejectdrop ( ) ; } } else { e . rejectdrop ( ) ; } } catch ( ioexception ioe ) { ioe . printstacktrace ( ) ; } catch ( unsupportedflavorexception ufe ) { ufe . printstacktrace ( ) ; } }
tr	7	public boolean equals ( final shape shape ) { if ( shape != null ) { if ( shape instanceof spline ) { final spline spline = ( spline ) shape ; if ( spline . np == np ) { for ( int i = 0 , ip2 = 2 ; i < np ; ++ i , ++ ip2 ) if ( ! spline . p [ i ] . equals ( p [ i ] ) || ! spline . c [ ip2 ] . equals ( c [ ip2 ] ) ) return false ; return true ; } } } return false ; }
tr	4	public static double loggammastirling ( double z ) { int shift = 0 ; while ( z < 2 ) { z ++ ; shift ++ ; } double result = half_log_two_pi + ( z - 0.5 ) * math . log ( z ) - z + 1 / ( 12 * z ) - 1 / ( 360 * z * z * z ) + 1 / ( 1260 * z * z * z * z * z ) ; while ( shift > 0 ) { shift -- ; z -- ; result -= math . log ( z ) ; } return result ; }
tr	9	@ override public void indexdocuments ( string documentpath ) throws exception { file documentdir = new file ( documentpath ) ; if ( ! ( documentdir . exists ( ) && documentdir . isdirectory ( ) ) ) { throw new exception ( "document indexer: unable to find document directory." ) ; } collection < file > alldocs = new arraylist < file > ( ) ; addfiles ( documentdir , alldocs ) ; indexwriterconfig config = new indexwriterconfig ( version . lucene_41 , sa ) ; try { iw = new indexwriter ( dir , config ) ; for ( file file : alldocs ) { indexfile ( file ) ; } iw . close ( ) ; } catch ( ioexception e ) { applicationhelper . printerror ( "document indexer: unable to locate raw documents" , e ) ; } }
tr	9	private void checkfortermination ( int timezone ) { terminationcounter countert = terminationcounters . get ( timezone ) ; logger . info ( "balance: " + countert . getsentmessages ( ) + " / " + countert . getreceivedmessages ( ) ) ; if ( countert . isbalanced ( ) && countert . isnotempty ( ) ) { terminationcounter counterprev = terminationcounters . get ( timezone - 1 ) ; terminationcounter counternext = terminationcounters . get ( timezone + 1 ) ; if ( counterprev != null ) { if ( counterprev . isbalanced ( ) && counterprev . isnotempty ( ) ) { keeprunning = false ; logger . info ( "termination reached! messages sent: " + countert . getsentmessages ( ) + " messages received: " + countert . getreceivedmessages ( ) ) ; } else { if ( counternext != null && counternext . isbalanced ( ) && counternext . isnotempty ( ) ) { keeprunning = false ; logger . info ( "termination reached! messages sent: " + countert . getsentmessages ( ) + " messages received: " + countert . getreceivedmessages ( ) ) ; } } } } }
tr	2	protected void handlecountermessage ( endpoint sender , countermessage message ) { terminationcounter counter = terminationcounters . get ( message . gettimezone ( ) ) ; if ( counter == null ) { counter = new terminationcounter ( 0 , 0 ) ; terminationcounters . put ( message . gettimezone ( ) , counter ) ; } counter . addtocounter ( message . getsent ( ) , message . getreceived ( ) , message . getsenderid ( ) ) ; checkfortermination ( message . gettimezone ( ) ) ; }
tr	1	public static void main ( string [ ] args ) { testneuronnetwork ( ) ; }
tr	6	public static boolean isobstructed ( vertex test ) { if ( list == null ) return true ; list . reset ( ) ; while ( list . hasnext ( ) ) { angleinterval ai = list . getnext ( ) ; if ( ai . vertexisobstructed ( test ) ) return true ; } return false ; }
tr	1	public bfs ( ) { queue = new linkedlist < integer > ( ) ; }
tr	5	public static void prepareprocess ( string filename ) { fileprefix = filename . replace ( ".txt" , "" ) ; try { wtxt = new bufferedwriter ( new outputstreamwriter ( new fileoutputstream ( fileprefix + ".tokens" ) , "utf-8" ) ) ; wpos = new bufferedwriter ( new outputstreamwriter ( new fileoutputstream ( fileprefix + ".pos" ) , "utf-8" ) ) ; wparse = new bufferedwriter ( new outputstreamwriter ( new fileoutputstream ( fileprefix + ".parse" ) , "utf-8" ) ) ; wdep = new bufferedwriter ( new outputstreamwriter ( new fileoutputstream ( fileprefix + ".dep" ) , "utf-8" ) ) ; if ( x . getboolean ( "segmentation" ) ) { wseg = new bufferedwriter ( new outputstreamwriter ( new fileoutputstream ( fileprefix + ".segment" ) , "utf-8" ) ) ; } outputfile = fileprefix + ".pbf" ; outputstream = new fileoutputstream ( outputfile ) ; string predfile = x . get ( "outputfile" ) ; if ( predfile != null ) { outputwriter = new bufferedwriter ( new outputstreamwriter ( new fileoutputstream ( predfile ) , "utf-8" ) ) ; } } catch ( exception e ) { e . printstacktrace ( ) ; } }
tr	4	private void appendpathindent ( final appendable sb , final int level ) throws ioexception { for ( int i = 0 ; i < ( level - 1 ) ; ++ i ) { sb . append ( callindentation ) ; } if ( level > 0 ) { sb . append ( leafnameprefix ) ; } }
tr	10	@ override public synchronized void run ( ) { int index = 0 ; string tag_values = ")" ; while ( true ) { try { thread . sleep ( 1000 ) ; final string tag_value = reader . readsensorfile ( tag , index ) ; if ( tag_values . equals ( ")" ) ) { tag_values = tag_value + tag_values ; } else { tag_values = tag_value + "<litcomma> " + tag_values ; } sensorgui . setvaluelabel ( tag_value ) ; if ( index % 5 == 0 ) { tag_values = "(" + tag_values ; service . updatesensorvalues ( name , tag , tag_values ) ; tag_values = ")" ; } if ( index == 38 ) { index = 0 ; } else { index = index + 1 ; } } catch ( interruptedexception e ) { e . printstacktrace ( ) ; } } }
tr	4	public static double digamma ( double z ) { double psi = 0 ; if ( z < digamma_small ) { psi = euler_mascheroni - ( 1 / z ) ; return psi ; } while ( z < digamma_large ) { psi -= 1 / z ; z ++ ; } double invz = 1 / z ; double invzsquared = invz * invz ; psi += math . log ( z ) - .5 * invz - invzsquared * ( digamma_coef_1 - invzsquared * ( digamma_coef_2 - invzsquared * ( digamma_coef_3 - invzsquared * ( digamma_coef_4 - invzsquared * ( digamma_coef_5 - invzsquared * ( digamma_coef_6 - invzsquared * digamma_coef_7 ) ) ) ) ) ) ; return psi ; }
tr	4	private void addfiles ( file documentpath , collection < file > alldocs ) { file [ ] children = documentpath . listfiles ( ) ; if ( children != null ) { for ( file child : children ) { if ( child . isfile ( ) ) { alldocs . add ( child ) ; } else { addfiles ( child , alldocs ) ; } } } }
tr	7	protected void rotatetoangle ( double angle ) { if ( math . abs ( angle - faceangle ) >= 5 ) { double [ ] distances = calculator . getdistancesbetweenangles ( faceangle , angle ) ; if ( distances [ 0 ] < distances [ 1 ] ) { if ( distances [ 0 ] > angleicrement ) { changeimage ( imagemovementstate , imagerotationstate . rotatingleft ) ; rotate ( rotationstate . turningleft ) ; } } else { if ( distances [ 1 ] > angleicrement ) { changeimage ( imagemovementstate , imagerotationstate . rotatingright ) ; rotate ( rotationstate . turningright ) ; } } } else { if ( imagerotationstate == imagerotationstate . rotatingright ) { changeimage ( imagemovementstate , imagerotationstate . idle ) ; rotate ( rotationstate . turningrightdrifting ) ; } else if ( imagerotationstate == imagerotationstate . rotatingleft ) { changeimage ( imagemovementstate , imagerotationstate . idle ) ; rotate ( rotationstate . turningleftdrifting ) ; } } }
tr	8	public static void visualize ( graphics g ) { if ( list == null ) return ; list . reset ( ) ; g . setcolor ( color . red ) ; while ( list . hasnext ( ) ) { angleinterval ai = list . getnext ( ) ; if ( ( int ) ai . leftdist == 0 && ( int ) ai . rightdist == 0 ) continue ; g . drawline ( ( int ) ( src . x ( ) + math . cos ( ai . leftangle ) * ai . leftdist ) , ( int ) ( src . y ( ) + math . sin ( ai . leftangle ) * ai . leftdist ) , ( int ) ( src . x ( ) + math . cos ( ai . rightangle ) * ai . rightdist ) , ( int ) ( src . y ( ) + math . sin ( ai . rightangle ) * ai . rightdist ) ) ; } }
tr	2	public static void testneuron ( ) { try { myneurontest t = new myneurontest ( ) ; t . setupneuron ( ) ; t . feedneuron ( ) ; } catch ( exception ex ) { logger . getlogger ( mystartclass . class . getname ( ) ) . log ( level . severe , null , ex ) ; } }
tr	7	public static void annotate ( string text ) throws ioexception { string [ ] lines = text . split ( "\\n" ) ; if ( lines . length > 10000 ) { int folds = lines . length / 10000 ; logger . info ( "splitting into " + folds + " folds\\n" ) ; for ( int i = 0 ; i < folds ; i ++ ) { logger . info ( "processing the " + i + "-th fold\\n" ) ; stringbuilder sb = new stringbuilder ( ) ; for ( int j = 0 ; j < 10000 ; j ++ ) { sb . append ( lines [ i * 10000 + j ] + "\\n" ) ; } annotateimpl ( sb . tostring ( ) ) ; } stringbuilder sb = new stringbuilder ( ) ; for ( int j = folds * 10000 ; j < lines . length ; j ++ ) { sb . append ( lines [ j ] + "\\n" ) ; } annotateimpl ( sb . tostring ( ) ) ; } else { annotateimpl ( text ) ; } }
tr	3	private ofertaemprego buscarofertaempregolivre ( ) { try { list < ofertaemprego > listaempregolivre = empregofromresultset ( conexao . getstatement ( ) . executequery ( "select * from " + nome_tabela_ofertas_emprego + " where " + emprego_coluna_area_atuacao + " = " + "'" + areaatuacao . name ( ) + "'" + " and " + emprego_coluna_estado_oferta + " = " + "'" + oferta . estado_oferta . por_aprovar . name ( ) + "'" ) ) ; for ( ofertaemprego emprego : listaempregolivre ) { return emprego ; } } catch ( sqlexception ex ) { serverui . sendmessage ( "erro de sql em threadgestaoarea.buscarofertaempregolivre()..." ) ; } return null ; }
tr	8	public static string digitstostring ( int n ) { if ( n <= 20 ) { string [ ] digits = { "one" , "two" , "three" , "four" , "five" , "six" , "seven" , "eight" , "nine" , "ten" , "eleven" , "twelve" , "thirteen" , "fourteen" , "fifteen" , "sixteen" , "seventeen" , "eighteen" , "nineteen" , "twenty" } ; return digits [ n - 1 ] ; } else { switch ( n ) { case 30 : return "thirty" ; case 40 : return "forty" ; case 50 : return "fifty" ; case 60 : return "sixty" ; case 70 : return "seventy" ; case 80 : return "eighty" ; case 90 : return "ninety" ; } } return null ; }
tr	1	public void adicionarofertarecursoslivre ( int id ) { ofertasrecursoslivres . add ( id ) ; }
tr	7	private static linkedlist < vertex > getunobstructedvertices ( linkedlist < vertex > vertices ) { linkedlist < vertex > unobstructed = new linkedlist < > ( ) ; addneighbours ( unobstructed ) ; while ( vertices . hasnext ( ) ) { vertex q = vertices . getnext ( ) ; if ( src == q || ! q . isvertex ( ) ) continue ; if ( ! isobstructed ( q ) ) unobstructed . add ( q ) ; } vertices . reset ( ) ; return unobstructed ; }
tr	5	private void startterminationcheckerthread ( ) { terminationcheckthread = new thread ( ) { @ override public void run ( ) { while ( keeprunning ) { countermessage message = new countermessage ( - 1 , ++ timezone , ownendpoint ) ; for ( endpoint e : endpoints ) { addmessagetooutbox ( e , message ) ; } try { thread . sleep ( check_delay ) ; } catch ( interruptedexception e ) { logger . error ( "termination check thread encountered an exception!" , e ) ; system . exit ( - 1 ) ; } } } } ; terminationcheckthread . start ( ) ; logger . info ( "termination checker started!" ) ; }
tr	4	protected double [ ] randomrawmultinomial ( randoms r ) { double sum = 0 ; double [ ] pr = new double [ this . partition . length ] ; for ( int i = 0 ; i < this . partition . length ; i ++ ) { pr [ i ] = r . nextgamma ( magnitude * partition [ i ] ) ; sum += pr [ i ] ; } for ( int i = 0 ; i < this . partition . length ; i ++ ) pr [ i ] /= sum ; return pr ; }
tr	9	public void close ( ) { if ( channel != null ) { if ( logger . isinfoenabled ( ) ) logger . info ( "closing sftp connection to {}@{}" , username , serverip ) ; channel . disconnect ( ) ; } if ( session != null ) { if ( logger . isinfoenabled ( ) ) logger . info ( "closing connection to {}@{}" , username , serverip ) ; session . disconnect ( ) ; } serverip = null ; }
tr	10	public void actionperformed ( actionevent ae ) { string action_com = ae . getactioncommand ( ) ; if ( action_com != null && action_com . equals ( "anadirimagen" ) ) { model . addimage ( view . list . getmodel ( ) . getsize ( ) ) ; } else if ( action_com != null && action_com . equals ( "borrarimagen" ) ) { if ( ! ( view . list . isselectionempty ( ) ) ) { if ( view . list . getmodel ( ) . getsize ( ) == 1 ) { if ( roimanager . getinstance ( ) != null ) { roimanager . getinstance ( ) . close ( ) ; } imagemanager . getinstance ( ) . close ( ) ; if ( windowmanager . getcurrentimage ( ) != null ) { windowmanager . getcurrentimage ( ) . close ( ) ; windowmanager . settempcurrentimage ( null ) ; } return ; } model . deleteimage ( view . list . getselectedindex ( ) ) ; } else { ij . error ( "no hay imagen seleccionada" ) ; } } model . refresh ( view . list ) ; }
tr	5	public static void testsymmetricconcentration ( int numdimensions , int numobservations , int observationmeanlength ) { double logd = math . log ( numdimensions ) ; for ( int exponent = - 5 ; exponent < 4 ; exponent ++ ) { double alpha = numdimensions * 1.0 ; dirichlet prior = new dirichlet ( numdimensions , alpha / numdimensions ) ; int [ ] counthistogram = new int [ 1000000 ] ; int [ ] observationlengths = new int [ 1000000 ] ; object [ ] observations = prior . drawobservations ( numobservations , observationmeanlength ) ; dirichlet optimizeddirichlet = new dirichlet ( numdimensions , 1.0 ) ; optimizeddirichlet . learnparameterswithhistogram ( observations ) ; system . out . println ( optimizeddirichlet . magnitude ) ; for ( int i = 0 ; i < numobservations ; i ++ ) { int [ ] observation = ( int [ ] ) observations [ i ] ; int total = 0 ; for ( int k = 0 ; k < numdimensions ; k ++ ) { if ( observation [ k ] > 0 ) { total += observation [ k ] ; counthistogram [ observation [ k ] ] ++ ; } } observationlengths [ total ] ++ ; } double estimatedalpha = learnsymmetricconcentration ( counthistogram , observationlengths , numdimensions , 1.0 ) ; system . out . println ( alpha + "\\t" + estimatedalpha + "\\t" + math . abs ( alpha - estimatedalpha ) ) ; } }
tr	8	protected void buildinternal ( multilabelinstances input ) throws exception { labelindices = input . getlabelindices ( ) ; numlabels = input . getnumlabels ( ) ; ensemble = new filteredclassifier [ numlabels ] ; datatransformation = new datatransformation ( ) ; datatransformation . initialize ( input ) ; if ( datatransformation . getnumberofallzeros ( ) > 0 ) { instances trainallzero = datatransformation . transformtozerodata ( input ) ; debug ( "bulding model for all zeros" ) ; allzeros = abstractclassifier . makecopy ( baseclassifier ) ; allzeros . buildclassifier ( trainallzero ) ; } transformeddata = datatransformation . transforminstances ( input ) ; instances trainingdata = transformeddata . getdataset ( ) ; for ( int i = 0 ; i < numlabels ; i ++ ) { ensemble [ i ] = new filteredclassifier ( ) ; ensemble [ i ] . setclassifier ( abstractclassifier . makecopy ( baseclassifier ) ) ; int [ ] indicestoremove = new int [ numlabels - 1 ] ; int counter2 = 0 ; for ( int j = 0 ; j < numlabels ; j ++ ) { if ( labelindices [ j ] != labelindices [ i ] ) { indicestoremove [ counter2 ] = labelindices [ j ] ; counter2 ++ ; } } remove remove = new remove ( ) ; remove . setattributeindicesarray ( indicestoremove ) ; remove . setinputformat ( trainingdata ) ; remove . setinvertselection ( false ) ; ensemble [ i ] . setfilter ( remove ) ; trainingdata . setclassindex ( labelindices [ i ] ) ; debug ( "bulding model " + ( i + 1 ) + "/" + numlabels ) ; ensemble [ i ] . buildclassifier ( trainingdata ) ; } }
tr	1	public threadgestaoarea ( serverimplementation server , iserverui serverui , oferta . area_atuacao areaatuacao , conexaobd conexao , int tempowaitverificacoeslocais , int tempowaitverificacoesbd ) { this . areaatuacao = areaatuacao ; this . conexao = conexao ; this . serverui = serverui ; this . server = server ; this . ofertasrecursoslivres = new linkedlist < > ( ) ; this . tempowaitverificacoesbd = tempowaitverificacoesbd ; this . tempowaitverificacoeslocais = tempowaitverificacoeslocais ; }
tr	3	public static void main ( string [ ] args ) { x . prop . put ( "tokenized" , "true" ) ; x . prop . put ( "singlesentences" , "true" ) ; initpipeline ( true , true ) ; annotation ann = new annotation ( "boston 69 65 .515 5 1/2\\n1. michelle freeman ( jamaica ) 12.71 seconds" ) ; pipeline . annotate ( ann ) ; for ( coremap sent : ann . get ( sentencesannotation . class ) ) { for ( corelabel token : sent . get ( tokensannotation . class ) ) { logger . info ( token . get ( textannotation . class ) ) ; } logger . info ( "sentence done" ) ; } }
tr	6	public string tostring ( hashmap < element , string > names ) { string targetname = "e" ; if ( target != null && names . containskey ( target ) ) targetname = names . get ( target ) ; string [ ] elementclass = element . getclass ( ) . getname ( ) . split ( "\\\\." ) ; string str = names . get ( element ) + " " + elementclass [ elementclass . length - 1 ] + " " + targetname + " " + position . x + " " + position . y + " " + velocity . x + " " + velocity . y + " " + radius + " " + size + " " + maxspeed ; if ( element instanceof animal ) { str += " " + collisionavoidanceweight + " " + flockcenteringweight + " " + velocitymatchingweight + " " + otheranimalweight + " " + terrainavoidanceweight ; } return str ; }
tr	3	public static string getdep ( string parse ) { tree t ; stringbuilder sb = new stringbuilder ( ) ; try { t = tf . newtreereader ( new stringreader ( parse ) ) . readtree ( ) ; grammaticalstructure gs = gsf . newgrammaticalstructure ( t ) ; iterator < typeddependency > it = gs . typeddependenciescollapsed ( ) . iterator ( ) ; while ( it . hasnext ( ) ) { sb . append ( it . next ( ) + "\\t" ) ; } } catch ( ioexception e ) { e . printstacktrace ( ) ; } return sb . tostring ( ) ; }
tr	2	public static void processfile ( string file , string path ) { string text = fileutil . gettextfromfile ( file ) ; try { annotate ( text ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } }
tr	9	public static treenode buildfromstring ( string str ) { string [ ] parts = str . substring ( 1 , str . length ( ) - 1 ) . split ( "<litcomma>" ) ; treenode root = null ; linkedlist < treenode > uncompletednode = new linkedlist < > ( ) ; for ( int i = 0 ; i < parts . length ; i ++ ) { if ( i == 0 && ! parts [ i ] . equals ( nulltree ) ) { root = new treenode ( integer . parseint ( parts [ i ] ) ) ; uncompletednode . add ( root ) ; } else { treenode iter = uncompletednode . pop ( ) ; if ( ! parts [ i ] . equals ( nulltree ) ) { iter . left = new treenode ( integer . parseint ( parts [ i ] ) ) ; uncompletednode . add ( iter . left ) ; } i ++ ; if ( i < parts . length && ! parts [ i ] . equals ( nulltree ) ) { iter . right = new treenode ( integer . parseint ( parts [ i ] ) ) ; uncompletednode . add ( iter . right ) ; } } } return root ; }
tr	6	public double distancefromline ( double testangle ) { if ( leftdist <= 0 && rightdist <= 0 ) return 0 ; double x1 = leftdist * math . cos ( leftangle ) ; double y1 = leftdist * math . sin ( leftangle ) ; double x2 = rightdist * math . cos ( rightangle ) ; double y2 = rightdist * math . sin ( rightangle ) ; if ( math . abs ( x2 - x1 ) > math . abs ( y2 - y1 ) ) { double coeff = ( y2 - y1 ) / ( x2 - x1 ) ; return ( y1 - x1 * coeff ) / ( math . sin ( testangle ) - coeff * math . cos ( testangle ) ) ; } double coeff = ( x2 - x1 ) / ( y2 - y1 ) ; return ( x1 - y1 * coeff ) / ( math . cos ( testangle ) - coeff * math . sin ( testangle ) ) ; }
tr	8	private void new ( ) { try { for ( int i = 0 ; i < list . getprojectlist ( ) . size ( ) ; i ++ ) { stringtokenizer st = new stringtokenizer ( list . getprojectlist ( ) . get ( i ) , " : " ) ; string str = st . nexttoken ( ) ; if ( str . equals ( nametextfield . gettext ( ) ) ) { joptionpane . showmessagedialog ( buttonnew , "project with such name is already exists" ) ; return ; } } } catch ( remoteexception e1 ) { joptionpane . showmessagedialog ( buttonnew , "disconect from server" ) ; this . dispose ( ) ; loginframe log = new loginframe ( ) ; log . setdefaultcloseoperation ( jframe . exit_on_close ) ; log . setvisible ( true ) ; } if ( nametextfield . gettext ( ) . length ( ) == 0 ) { joptionpane . showmessagedialog ( buttonnew , "enter projact name" ) ; return ; } setprojectname ( nametextfield . gettext ( ) ) ; passframe pf = new passframe ( opf ) ; pf . setdefaultcloseoperation ( exit_on_close ) ; pf . setvisible ( true ) ; }
tr	6	public static string unitstostring ( int n ) { if ( n == 3 ) return "hundred" ; else if ( n >= 4 && n <= 6 ) return "thousand" ; else if ( n >= 7 && n <= 9 ) return "million" ; else return "billion" ; }
tr	2	public void switchwhiteboard ( string whiteboardid ) { if ( whiteboardid . equals ( "" ) ) sendmessage ( new newwhiteboardmessage ( ) ) ; else sendmessage ( new switchwhiteboardmessage ( whiteboardid ) ) ; }
tr	4	public static double trigamma ( double z ) { int shift = 0 ; while ( z < 2 ) { z ++ ; shift ++ ; } double oneoverz = 1.0 / z ; double oneoverzsquared = oneoverz * oneoverz ; double result = oneoverz + 0.5 * oneoverzsquared + 0.1666667 * oneoverzsquared * oneoverz - 0.03333333 * oneoverzsquared * oneoverzsquared * oneoverz + 0.02380952 * oneoverzsquared * oneoverzsquared * oneoverzsquared * oneoverz - 0.03333333 * oneoverzsquared * oneoverzsquared * oneoverzsquared * oneoverzsquared * oneoverz ; system . out . println ( z + " -> " + result ) ; while ( shift > 0 ) { shift -- ; z -- ; result += 1.0 / ( z * z ) ; system . out . println ( z + " -> " + result ) ; } return result ; }
tr	2	public legendpanel ( ) { setbackground ( color . black ) ; setmaximumsize ( new dimension ( 600 , 30 ) ) ; setlayout ( new gridlayout ( 3 , 3 ) ) ; font font = new font ( font . dialog , font . plain , 15 ) ; jlabel label = new jlabel ( "legend" ) ; label . setfont ( font ) ; label . setforeground ( color . white ) ; label . setbackground ( color . black ) ; this . add ( label ) ; this . add ( new jlabel ( "" ) ) ; this . add ( new jlabel ( "" ) ) ; for ( int i = 0 ; i < types . length ; i ++ ) { label = new jlabel ( "    " + gettype ( types [ i ] ) ) ; label . setfont ( font ) ; label . setforeground ( getcolor ( types [ i ] ) ) ; label . setbackground ( color . black ) ; this . add ( label ) ; } }
tr	2	private void rendercalltimings ( final timerstatistics call ) throws ioexception { if ( call != null ) { sb . append ( string . format ( "[%7d] %12.2fms " , long . valueof ( call . getnumberofcalls ( ) ) , double . valueof ( gettotalmillis ( call . gettotalnanos ( ) ) ) ) ) ; } }
tr	7	private double g0 ( final int i ) { switch ( i ) { case - 3 : return - g03 ; case - 2 : return - g02 ; case - 1 : return - g01 ; case 1 : return g01 ; case 2 : return g02 ; case 3 : return g03 ; default : return 0.0 ; } }
tr	9	@ override protected void recievebuttonevent ( int buttonid ) { switch ( buttonid ) { default : break ; case 1 : boot . getguihandler ( ) . addwindow ( ( new debuggui ( - 1 ) ) ) ; break ; case 2 : requestpoints ( 2 ) ; picks = 0 ; break ; case 4 : makeprefab ( ) ; break ; case 3 : requestpoints ( 1 ) ; picks = 5 ; break ; case 5 : requestpoints ( 1 ) ; picks = 4 ; break ; case 6 : requestpoints ( 1 ) ; picks = 3 ; break ; case 7 : roadgen . layroad ( x1 , y1 , x2 , y2 ) ; break ; case 8 : blockgen . makenewblock ( x1 , y1 , 3 ) ; break ; } }
tr	8	private static void addneighbours ( linkedlist < vertex > unobstructed ) { if ( src . getclass ( ) != point . class ) return ; point p = ( point ) src ; if ( p . getleft ( ) . isvertex ( ) ) unobstructed . add ( p . getleft ( ) ) ; if ( p . getright ( ) . isvertex ( ) ) unobstructed . add ( p . getright ( ) ) ; }
tr	8	protected multilabeloutput makepredictioninternal ( instance instance ) throws exception { double p_0 = 0.0 ; if ( datatransformation . getnumberofallzeros ( ) > 0 ) { instance transformedzeroinstance = datatransformation . transformtozeroinstance ( instance ) ; p_0 = allzeros . distributionforinstance ( transformedzeroinstance ) [ transformedzeroinstance . classattribute ( ) . indexofvalue ( "0" ) ] ; } instance transformedinstance = datatransformation . transforminstance ( instance ) ; double [ ] [ ] probabilities = new double [ datatransformation . getmaxlabels ( ) ] [ numlabels ] ; double [ ] marginals = new double [ numlabels ] ; for ( int i = 0 ; i < numlabels ; i ++ ) { double [ ] distribution = ensemble [ i ] . distributionforinstance ( transformedinstance ) ; for ( int j = 0 ; j < distribution . length ; j ++ ) { int label = integer . parseint ( transformedinstance . attribute ( this . labelindices [ i ] ) . value ( j ) ) ; if ( label != 0 ) { probabilities [ label - 1 ] [ i ] = ( 1 - p_0 ) * distribution [ j ] ; marginals [ i ] = ( 1 - p_0 ) * distribution [ j ] ; } } } fmeasure f = new fmeasure ( ) ; f . initialize ( numlabels , datatransformation . getmaxlabels ( ) , probabilities , p_0 ) ; f . computefmeasuremaximizer ( ) ; multilabeloutput prediction = f . computeprediction ( ) ; return prediction ; }
tr	3	private static map < string , collection < timerstatistics > > addstatistics ( final collection < node > nodes , final map < string , collection < timerstatistics > > m ) { for ( final node n : nodes ) { final string key = n . getpath ( ) . getleaftimername ( ) ; collection < timerstatistics > c = m . get ( key ) ; if ( c == null ) { c = new arraylist < timerstatistics > ( ) ; m . put ( key , c ) ; } c . add ( n . gettimerstatistics ( ) ) ; addstatistics ( n . getchildren ( ) , m ) ; } return m ; }
tr	1	public static void testgraphics ( ) { mydrawableworld world = mydrawableworld . getinstance ( ) ; mycanvaswindow cw = new mycanvaswindow ( 300 , 300 , world ) ; cw . setmouselistener ( new mouselistener ( ) { @ override public void mouseclicked ( mouseevent me ) { world . spawncar ( new mypoint ( me . getx ( ) , me . gety ( ) ) ) ; system . out . println ( "clicked at:" + me . getx ( ) + " " + me . gety ( ) ) ; } @ override public void mousepressed ( mouseevent me ) { } @ override public void mousereleased ( mouseevent me ) { } @ override public void mouseentered ( mouseevent me ) { } @ override public void mouseexited ( mouseevent me ) { } } ) ; cw . startwindow ( ) ; }
tr	6	public static void runcomparison ( ) { double precision ; int dimensions ; int documents ; int meansize ; try { printwriter out = new printwriter ( new bufferedwriter ( new filewriter ( "comparison" ) ) ) ; dimensions = 10 ; for ( int j = 0 ; j < 5 ; j ++ ) { documents = 100 ; for ( int k = 0 ; k < 5 ; k ++ ) { meansize = 100 ; for ( int l = 0 ; l < 5 ; l ++ ) { system . out . println ( dimensions + "\\t" + dimensions + "\\t" + documents + "\\t" + meansize ) ; for ( int m = 0 ; m < 10 ; m ++ ) { out . println ( compare ( dimensions , dimensions , documents , meansize ) ) ; } out . flush ( ) ; meansize *= 2 ; } documents *= 2 ; } dimensions *= 2 ; } out . flush ( ) ; out . close ( ) ; } catch ( exception e ) { e . printstacktrace ( system . out ) ; } }
tr	3	public void settool ( class < ? extends drawingtool > toolclass ) { try { tool = toolclass . newinstance ( ) . createfrommodel ( this ) ; } catch ( instantiationexception e ) { e . printstacktrace ( ) ; system . exit ( 1 ) ; } catch ( illegalaccessexception e ) { e . printstacktrace ( ) ; system . exit ( 1 ) ; } }
tr	10	protected void report_reduce_reduce ( lalr_item itm1 , lalr_item itm2 ) throws internal_error { boolean comma_flag = false ; system . err . println ( "*** reduce/reduce conflict found in state #" + index ( ) ) ; system . err . print ( "  between " ) ; system . err . println ( itm1 . to_simple_string ( ) ) ; system . err . print ( "  and     " ) ; system . err . println ( itm2 . to_simple_string ( ) ) ; system . err . print ( "  under symbols: {" ) ; for ( int t = 0 ; t < terminal . number ( ) ; t ++ ) { if ( itm1 . lookahead ( ) . contains ( t ) && itm2 . lookahead ( ) . contains ( t ) ) { if ( comma_flag ) system . err . print ( "<litcomma> " ) ; else comma_flag = true ; system . err . print ( terminal . find ( t ) . name ( ) ) ; } } system . err . println ( "}" ) ; system . err . print ( "  resolved in favor of " ) ; if ( itm1 . the_production ( ) . index ( ) < itm2 . the_production ( ) . index ( ) ) system . err . println ( "the first production.\\n" ) ; else system . err . println ( "the second production.\\n" ) ; emit . num_conflicts ++ ; lexer . warning_count ++ ; }
tr	3	public static void testneuronnetwork ( ) { try { mysmartcartester tester = new mysmartcartester ( ) ; mydrawablegraph nnfgraph = new mydrawablegraph ( mydrawablegraph . sortbyaxis . xaxis , mydrawablegraph . sortdirection . asc , 300 , 260 ) ; mycanvaswindow nnfgwindow = new mycanvaswindow ( 300 , 260 , nnfgraph ) ; mycanvaswindow worldwindow = new mycanvaswindow ( 300 , 250 , tester ) ; worldwindow . startwindow ( ) ; int fitness = 0 ; int iterations = 0 ; while ( ( fitness = tester . getfitness ( ) ) < 995 ) { system . out . println ( "f:" + fitness ) ; tester . evolvenetwork ( ) ; ++ iterations ; } } catch ( exception ex ) { logger . getlogger ( mystartclass . class . getname ( ) ) . log ( level . severe , null , ex ) ; } }
tr	5	public void bfs ( int adjacency_matrix [ ] [ ] , int source ) { int number_of_nodes = adjacency_matrix [ source ] . length - 1 ; int [ ] visited = new int [ number_of_nodes + 1 ] ; int i , element ; visited [ source ] = 1 ; queue . add ( source ) ; while ( ! queue . isempty ( ) ) { element = queue . remove ( ) ; i = element ; system . out . print ( i + "\\t" ) ; while ( i <= number_of_nodes ) { if ( adjacency_matrix [ element ] [ i ] == 1 && visited [ i ] == 0 ) { queue . add ( i ) ; visited [ i ] = 1 ; } i ++ ; } } }
tr	5	@ override public int checkfordamage ( rectangle2d . double rect ) { synchronized ( this . lasers ) { int damage = 0 ; if ( globals . gametime . getelapsedmillis ( ) >= ( this . lastdamagedone + laserwire . laser_cooldown ) ) { if ( ! this . lasers . isempty ( ) ) { iterator < line2d . double > it = this . lasers . iterator ( ) ; while ( it . hasnext ( ) ) { line2d . double laser = it . next ( ) ; if ( rect . intersectsline ( laser ) ) { damage += laserwire . damage_by_laser ; this . lastdamagedone = globals . gametime . getelapsedmillis ( ) ; } } } } return damage ; } }
tr	5	public void checkbreakeven ( double x ) { long start , clock1 , clock2 ; double digammax = digamma ( x ) ; for ( int n = 1 ; n < 100 ; n ++ ) { start = system . currenttimemillis ( ) ; for ( int i = 0 ; i < 1000000 ; i ++ ) { digamma ( x + n ) ; } clock1 = system . currenttimemillis ( ) - start ; start = system . currenttimemillis ( ) ; for ( int i = 0 ; i < 1000000 ; i ++ ) { digammadifference ( x , n ) ; } clock2 = system . currenttimemillis ( ) - start ; system . out . println ( n + "\\tdirect: " + clock1 + "\\tindirect: " + clock2 + " (" + ( clock1 - clock2 ) + ")" ) ; system . out . println ( "  " + ( digamma ( x + n ) - digammax ) + " " + digammadifference ( x , n ) ) ; } }
tr	1	public firststate ( ) { statename = "1st" ; }
tr	7	public boolean vertexisobstructed ( vertex test ) { if ( src . haspointbetween ( leftangle , rightangle , test ) ) { if ( leftdist <= 0 && rightdist <= 0 ) return true ; if ( src . getdistance ( test ) > distancefromline ( src . getdirection ( test ) ) + 0.01 ) return true ; } return false ; }
va	7	public languagecontroller createlanguagecontroller ( string languagename ) { languagecontroller languagecontroller = new englishlanguagecontroller ( ) ; if ( languagename != null ) { if ( languagename . equals ( "italian" ) ) { languagecontroller = new italianlanguagecontroller ( ) ; } else if ( languagename . equals ( "norwegian" ) ) { languagecontroller = new norwegianlanguagecontroller ( ) ; } else if ( languagename . equals ( "french" ) ) { languagecontroller = new frenchlanguagecontroller ( ) ; } else if ( languagename . equals ( "spanish" ) ) { languagecontroller = new spanishlanguagecontroller ( ) ; } else if ( languagename . equals ( "german" ) ) { languagecontroller = new germanlanguagecontroller ( ) ; } } return languagecontroller ; }
va	2	public static string distributiontostring ( double magnitude , double [ ] distribution ) { stringbuffer output = new stringbuffer ( ) ; numberformat formatter = numberformat . getinstance ( ) ; formatter . setmaximumfractiondigits ( 5 ) ; output . append ( formatter . format ( magnitude ) + ":\\t" ) ; for ( int i = 0 ; i < distribution . length ; i ++ ) { output . append ( formatter . format ( distribution [ i ] ) + "\\t" ) ; } return output . tostring ( ) ; }
va	7	private void spawnbox ( int size , int xstart , int ystart ) { size = size + 2 ; for ( int i = 0 ; i < size ; i ++ ) { for ( int j = 0 ; j < size ; j ++ ) { if ( i == 0 || i == size - 1 || j == 0 || j == size - 1 ) { boot . getworldobj ( ) . gettileatcoords ( xstart + i , ystart + j ) . settileid ( tileid . asphalt ) ; } } } }
va	6	@ override public void init ( ) { super . init ( ) ; background = new jpanel ( ) { private static final long serialversionuid = 1l ; @ override public void paint ( graphics g ) { super . paint ( g ) ; graphics2d g2 = ( graphics2d ) g ; int counter = 0 ; for ( int x = 0 ; x < horizontalfields ; x ++ ) { for ( int y = 0 ; y < verticalfields ; y ++ ) { g2 . drawimage ( randomtiles . get ( counter ) , x * field_size , y * field_size , null ) ; counter ++ ; } } for ( gameboardelement element : gameboard . getallelements ( ) ) { drawelementto ( g2 , element ) ; } } } ; addkeylistenerto ( background ) ; add ( background ) ; configuregame ( ) ; preparebackgroundtiles ( ) ; setsize ( horizontalfields * field_size , verticalfields * field_size ) ; }
va	10	public void cliquefinredeploiement ( ) { if ( joueurencours . getpeuple ( ) . getnbuniteenmain ( ) == 0 ) { if ( ( etape == 2 || etape == 3 ) ) { if ( game . getinstance ( ) . askconf ( "confirmer la fin du red\xe9ploiement ?" ) ) { if ( etape == 2 ) { if ( tempendeclin ) { joueurencours . getpeuple ( ) . decliner ( ) ; tempendeclin = false ; } setetape ( 3 ) ; indexsauvjoueurencours = indexjoueurencours ; indexjoueurencours = 0 ; } if ( ! deploiementsuivant ( ) ) { joueursuivant ( ) ; } game . getinstance ( ) . majinfos ( ) ; } } } else { new winwarn ( "il vous reste des unit\xe9s en main<litcomma> placez-les !" ) ; } }
va	5	private void nextheader ( ) throws ioexception { int len , chunk = 0 ; while ( ! eof && header . syncframe ( buf , off , maxoff ) == false ) { off = header . offset ( ) ; len = maxoff - off ; system . arraycopy ( buf , off , buf , 0 , len ) ; maxoff = len + instream . read ( buf , len , off ) ; off = 0 ; if ( maxoff <= len || ( chunk += buflen ) > 0x10000 ) eof = true ; } off = header . offset ( ) ; }
va	4	private void loop ( ) { thread thtmp = thread . currentthread ( ) ; byte [ ] arrbytes = new byte [ ezimnetwork . inbuf ] ; datagrampacket dp = new datagrampacket ( arrbytes , arrbytes . length ) ; while ( ! thtmp . isinterrupted ( ) ) { try { this . ms . receive ( dp ) ; final inetaddress iaack = dp . getaddress ( ) ; final string strack = new string ( dp . getdata ( ) , 0 , dp . getlength ( ) , ezimnetwork . dtxmsgenc ) ; ezimthreadpool etptmp = ezimthreadpool . getinstance ( ) ; etptmp . execute ( new runnable ( ) { public void run ( ) { ezimacksemantics . parser ( iaack , strack ) ; } } ) ; } catch ( exception e ) { if ( ! thtmp . isinterrupted ( ) ) ezimlogger . getinstance ( ) . severe ( e . getmessage ( ) , e ) ; } } }
va	8	public void draw ( graphics g ) { vector3d a ; vector3d b ; if ( numpoints <= 1 ) return ; g . setcolor ( this . getcolor ( ) ) ; for ( int i = 0 ; i < numpoints - 1 ; i ++ ) { a = object3d . points_ . elementat ( points [ i ] ) ; b = object3d . points_ . elementat ( points [ i + 1 ] ) ; boolean infov1 = object3d . infovs . elementat ( points [ i ] ) ; boolean infov2 = object3d . infovs . elementat ( points [ i + 1 ] ) ; if ( infov1 && infov2 ) { g . drawline ( ( int ) a . y , ( int ) a . z , ( int ) b . y , ( int ) b . z ) ; } } }
va	8	public void close ( ) { if ( id3tag != null ) id3tag . clear ( ) ; if ( audio != null ) audio . close ( ) ; if ( instream != null ) instream . close ( ) ; }
va	6	private string [ ] getcolumncombination ( int binarycounter ) { string strbinarycounter = integer . tobinarystring ( binarycounter ) ; while ( strbinarycounter . length ( ) < this . myidentifiercolumns . length ) { strbinarycounter = "0" + strbinarycounter ; } int arraylength = this . myidentifiercolumns . length - strbinarycounter . replaceall ( "0" , "" ) . length ( ) ; string [ ] tmpdisclosedcolumns = new string [ arraylength ] ; int j = 0 ; for ( int i = 0 ; i < this . myidentifiercolumns . length ; i ++ ) { if ( strbinarycounter . charat ( i ) == '0' ) { tmpdisclosedcolumns [ j ] = this . myidentifiercolumns [ i ] ; j ++ ; } } return tmpdisclosedcolumns ; }
va	9	public int [ ] getplayerindexes ( int ruleplayerindex ) { int [ ] ruleplayerindexes ; switch ( ruleplayerindex ) { case config_us_player_id : ruleplayerindexes = new int [ 1 ] ; ruleplayerindexes [ 0 ] = ourplayerindex ; break ; case config_native_player_id : ruleplayerindexes = new int [ 1 ] ; ruleplayerindexes [ 0 ] = gamestatus . nativeplayerindex ; break ; case config_sea_player_id : ruleplayerindexes = new int [ 1 ] ; ruleplayerindexes [ 0 ] = gamestatus . seaplayerindex ; break ; case config_any_player : ruleplayerindexes = new int [ gamestatus . nativeplayerindex ] ; for ( int playerindex = 0 ; playerindex < gamestatus . nativeplayerindex - 1 ; playerindex ++ ) { ruleplayerindexes [ playerindex ] = playerindex ; } computerutils . randomisearray ( ruleplayerindexes ) ; break ; case config_opponent_player_id : ruleplayerindexes = new int [ gamestatus . nativeplayerindex - 1 ] ; int i = 0 ; for ( int playerindex = 0 ; playerindex < gamestatus . nativeplayerindex - 1 ; playerindex ++ ) { if ( playerindex == ourplayerindex ) continue ; ruleplayerindexes [ i ++ ] = playerindex ; } computerutils . randomisearray ( ruleplayerindexes ) ; break ; default : logger . error ( "invalid player index (" + ruleplayerindex + ") for rule" ) ; ruleplayerindexes = new int [ 0 ] ; } return ruleplayerindexes ; }
va	9	@ override public string tostring ( ) { stringbuilder sb = new stringbuilder ( ) ; sb . append ( "{" ) ; linkedlist < treenode > queue = new linkedlist < > ( ) ; queue . add ( this ) ; while ( ! queue . isempty ( ) ) { treenode curr = queue . pop ( ) ; if ( curr == null ) { sb . append ( nulltree ) . append ( "<litcomma>" ) ; } else { sb . append ( curr . val ) . append ( "<litcomma>" ) ; queue . add ( curr . left ) ; queue . add ( curr . right ) ; } } string toprocess = sb . tostring ( ) ; while ( toprocess . endswith ( nulltree ) || toprocess . endswith ( "<litcomma>" ) ) { toprocess = toprocess . substring ( 0 , toprocess . length ( ) - 1 ) ; } toprocess += "}" ; return toprocess ; }
va	10	public void render ( graphics2d g , game game , spritesheet spritesheet , int frame ) { switch ( kind ) { case floor : g . drawimage ( spritesheet . get ( extradata , 3 ) , null , 0 , 0 ) ; break ; case wall : if ( extradata >= 4 ) g . drawimage ( spritesheet . get ( 4 + extradata % 4 , 4 ) , null , 0 , 0 ) ; else g . drawimage ( spritesheet . get ( 4 + extradata % 4 , 3 ) , null , 0 , 0 ) ; break ; case door : g . drawimage ( spritesheet . get ( 0 , 4 ) , null , 0 , 0 ) ; break ; case crafting_bench : g . drawimage ( spritesheet . get ( 2 , 4 ) , null , 0 , 0 ) ; break ; case inventory : g . drawimage ( spritesheet . get ( 1 , 4 ) , null , 0 , 0 ) ; break ; case sponsor : g . drawimage ( spritesheet . get ( 0 , 3 ) , null , 0 , 0 ) ; g . drawimage ( spritesheet . get ( ( frame > > 2 ) % 4 + ( game . hassponsors ( ) ? 4 : 0 ) , 2 ) , null , 0 , 0 ) ; break ; case merchant : g . drawimage ( spritesheet . get ( 0 , 3 ) , null , 0 , 0 ) ; g . drawimage ( spritesheet . get ( 4 , 1 ) , null , 0 , 0 ) ; break ; default : throw new runtimeexception ( "unhandled tile kind" ) ; } }
va	3	@ override public void handlemessage ( message msg ) { if ( msg . what == netconfig . tag_callback_success ) { util . showtips ( getapplicationcontext ( ) , "\u5bc6\u7801\u4fee\u6539\u6210\u529f" ) ; string _username = musernameedit . gettext ( ) . tostring ( ) ; string _password = mnewpwdedit . gettext ( ) . tostring ( ) ; gamedbhelper . getinstance ( changepwdactivity . this ) . insertorupdateloginusername ( _username , _password ) ; finish ( ) ; } else if ( msg . what == netconfig . tag_callback_failed ) { toast . maketext ( getapplicationcontext ( ) , msg . obj . tostring ( ) , toast . length_short ) . show ( ) ; } }
va	1	public void setleafnameprefix ( final string leaftoken ) { this . leafnameprefix = leaftoken ; }
va	1	public txtrenderer ( final string pre , final appendable sb ) { assert pre != null ; this . sb = sb ; this . pres = new stack < string > ( ) ; this . pres . push ( pre ) ; }
va	5	public void interactslot ( inventory inv , int slot ) { if ( inv . getiteminslot ( slot ) != null && grabbed == null ) { this . inventory = inv ; this . slotid = slot ; grabbed = inventory . getiteminslot ( slotid ) ; inventory . setiteminslot ( slotid , null ) ; } else if ( grabbed != null && inv . getiteminslot ( slot ) == null ) { inv . setiteminslot ( slot , grabbed ) ; this . inventory = null ; this . slotid = - 1 ; grabbed = null ; } }
va	2	private void initrandom ( ) { if ( random == null ) { random = new randoms ( ) ; } }
va	3	public void print ( ) { system . out . println ( "dirichlet:" ) ; for ( int j = 0 ; j < partition . length ; j ++ ) system . out . println ( dict != null ? dict . lookupobject ( j ) . tostring ( ) : j + "=" + magnitude * partition [ j ] ) ; }
va	4	public int getuniquewindowid ( ) { int id = 0 ; boolean unique = false ; while ( ! unique ) { unique = true ; for ( int x = 0 ; x < windowslist . size ( ) ; x ++ ) { if ( id == windowslist . get ( x ) . getid ( ) ) { unique = false ; id ++ ; } } } return id ; }
te	7	private void addlogbehaviour ( ) { addbehaviour ( new cyclicbehaviour ( this ) { public void action ( ) { aclmessage msg = receive ( ) ; if ( msg != null ) { aclmessage reply = null ; if ( msg . getsender ( ) . getlocalname ( ) . equals ( "ams" ) ) { system . out . println ( msg ) ; } else { try { reply = chooseaction ( msg ) ; } catch ( unreadableexception e ) { exceptionutils . handleexception ( e ) ; } } if ( reply != null ) { send ( reply ) ; } } else { block ( ) ; } } } ) ; }
te	5	public void drawobjects ( ) { list < drawableobjects > everything = coreclass . getsortedobjectlist ( ) ; int cameraoffx = - ( coreclass . mapupperleftoffset . getx ( ) ) ; int cameraoffy = - ( coreclass . mapupperleftoffset . gety ( ) ) ; coordinate tempul = coreclass . onscreentile [ 0 ] ; for ( drawableobjects d : everything ) { if ( d instanceof player ) { switch ( ( ( player ) d ) . getimageeffect ( ) ) { case "emboss" : g . drawimage ( imageprocessing . emboss ( coreclass . maincharacter . getpic ( ) ) , coreclass . maincharacter . getxpos ( ) , coreclass . maincharacter . getypos ( ) , null ) ; break ; default : g . drawimage ( coreclass . maincharacter . getpic ( ) , coreclass . maincharacter . getxpos ( ) , coreclass . maincharacter . getypos ( ) , null ) ; break ; } } else { switch ( d . getimageeffect ( ) ) { case "emboss" : g . drawimage ( imageprocessing . emboss ( d . getpic ( ) ) , d . getxpos ( ) + cameraoffx - ( tempul . getx ( ) * 102 ) , d . getypos ( ) + cameraoffy - ( tempul . gety ( ) * 102 ) , null ) ; break ; default : g . drawimage ( d . getpic ( ) , d . getxpos ( ) + cameraoffx - ( tempul . getx ( ) * 102 ) , d . getypos ( ) + cameraoffy - ( tempul . gety ( ) * 102 ) , null ) ; break ; } } } }
te	4	@ override public void service ( ) throws ioexception { try { printwriter pw = getprintwriter ( socket ) ; log . info ( "user login<litcomma> no = " + this . userno ) ; pw . println ( this . userno ) ; } catch ( exception e ) { log . error ( e . getmessage ( ) ) ; e . printstacktrace ( ) ; } finally { if ( null != socket ) { socket . close ( ) ; } } }
te	6	public string tostring ( ) { string string = "" ; if ( this . isempty ( ) ) return "" ; else string = this . get ( 0 ) . getorigine ( ) . getcontent ( ) . tostring ( ) ; for ( segment arete : this ) { if ( string != "" ) string += "|" ; string += arete . getdestination ( ) . getcontent ( ) . tostring ( ) ; } return string ; }
te	3	public static void serialize ( string filepath ) { try ( objectoutputstream out = new objectoutputstream ( new fileoutputstream ( filepath ) ) ) { out . writeobject ( sernodes ) ; error = null ; } catch ( ioexception ex ) { error = ex . getmessage ( ) ; logger . getlogger ( tracker . class . getname ( ) ) . log ( level . severe , null , ex ) ; } system . out . println ( "info: data successfully saved! " + "\\n" ) ; }
te	1	public void setcallindentation ( final string callindentation ) { this . callindentation = callindentation ; }
te	10	public void initiateremoval ( ) { if ( this . isremoving ( ) ) return ; try { list < appointment > aappt = appointment . findbyvenue ( this . getid ( ) ) ; if ( aappt . size ( ) <= 0 ) { this . finalizeremovalwithoutchecking ( ) ; return ; } this . awaitingid . clear ( ) ; for ( appointment appt : aappt ) { this . awaitingid . add ( appt . initiatorid ) ; venueremovalinitiated notification = new venueremovalinitiated ( this ) ; notification . add ( appt . initiatorid , notification ) ; } this . save ( ) ; } catch ( sqlexception e ) { e . printstacktrace ( ) ; } }
te	4	public gameobject ( int objectid , int orientation , int type , int vertexheightbottomright , int vertexheighttopright , int vertexheightbottomleft , int vertexheighttopleft , int animationid , boolean animating ) { this . objectid = objectid ; this . type = type ; this . orientation = orientation ; this . vertexheightbottomleft = vertexheightbottomleft ; this . vertexheightbottomright = vertexheightbottomright ; this . vertexheighttopright = vertexheighttopright ; this . vertexheighttopleft = vertexheighttopleft ; if ( animationid != - 1 ) { animation = animationsequence . animations [ animationid ] ; frame = 0 ; nextframetime = client . tick ; if ( animating && animation . framestep != - 1 ) { frame = ( int ) ( math . random ( ) * animation . framecount ) ; nextframetime -= ( int ) ( math . random ( ) * animation . getframelength ( frame ) ) ; } } gameobjectdefinition definition = gameobjectdefinition . getdefinition ( this . objectid ) ; varbitid = definition . varbitid ; configid = definition . configids ; childrenids = definition . childids ; }
te	1	public void setlineend ( final string lineend ) { this . lineend = lineend ; }
te	8	@ override public type gettype ( ) { switch ( presence . gettype ( ) ) { case available : return type . available ; case error : return type . error ; case subscribe : return type . subscribe ; case subscribed : return type . subscribed ; case unavailable : return type . unavailable ; case unsubscribe : return type . unsubscribe ; case unsubscribed : return type . unsubscribed ; default : throw new runtimeexception ( "unknown type of presence: " + presence . gettype ( ) ) ; } }
te	8	@ override public void handlestatus ( status s ) { if ( logger . istraceenabled ( ) ) { logger . trace ( "handling status " + s ) ; } if ( s . gettype ( ) != status . type . joined ) return ; string nick = s . getnick ( ) ; if ( pozdravy . containskey ( nick ) ) { ph . sendmessage ( nick + ": " + pozdravy . get ( nick ) ) ; } }
te	10	@ override public boolean equals ( object o ) { if ( o == null ) return false ; else if ( o == this ) return true ; else if ( o instanceof ofertaemprego ) { ofertaemprego ofertaemprego = ( ofertaemprego ) o ; if ( this . id == ofertaemprego . id && this . titulo . equals ( ofertaemprego . titulo ) && this . detalhesoferta . equals ( ofertaemprego . detalhesoferta ) && this . numerocandidatosnecessarios == ofertaemprego . numerocandidatosnecessarios && this . perfilcandidatos . equals ( ofertaemprego . perfilcandidatos ) ) if ( anexos . size ( ) == ofertaemprego . anexos . size ( ) ) return anexos . containsall ( ofertaemprego . anexos ) ; return false ; } else return false ; }
te	5	@ override public int getbid ( string winningplayerid , int currentbid ) { system . out . println ( "\\n" + this + "\\n" ) ; system . out . print ( "what would you like to bid (nums <= currentbid are a pass)? " ) ; integer intresponse = null ; while ( intresponse == null ) { string response ; try { response = bufferedreader . readline ( ) ; } catch ( ioexception e1 ) { system . out . println ( e1 ) ; continue ; } try { intresponse = integer . parseint ( response ) ; } catch ( numberformatexception nfe ) { system . out . print ( "\\ndoes not compute...please enter another number: " ) ; continue ; } } return intresponse ; }
te	2	public void tofile ( string filename ) throws ioexception { printwriter out = new printwriter ( new bufferedwriter ( new filewriter ( filename ) ) ) ; for ( int i = 0 ; i < partition . length ; i ++ ) { out . println ( magnitude * partition [ i ] ) ; } out . flush ( ) ; out . close ( ) ; }
te	9	public static void main ( string [ ] args ) { try { textscanner scanner ; if ( args . length > 0 ) { scanner = new textscanner ( new file ( args [ 0 ] ) ) ; } else { scanner = new textscanner ( ) ; } string wd ; int par = 0 ; system . out . print ( ( ++ par ) + " " ) ; while ( ( wd = scanner . nexttxtword ( ) ) != null ) { if ( wd . startswith ( "e@0@l" ) ) { system . out . println ( ) ; } else { if ( wd . startswith ( "e@0@p" ) ) { system . out . println ( "\\n" ) ; system . out . print ( ( ++ par ) + " " ) ; } else { system . out . print ( wd + " " ) ; } } } } catch ( ioexception e ) { system . err . println ( "malament del tot" ) ; e . printstacktrace ( ) ; } }
te	3	public static void deserialize ( string filename ) throws classnotfoundexception { system . out . println ( "info: loading data from file " + "\\n" ) ; sernodes . clear ( ) ; try ( objectinputstream reader = new objectinputstream ( new fileinputstream ( filename ) ) ) { sernodes = ( arraylist < sernode > ) reader . readobject ( ) ; error = null ; } catch ( ioexception ex ) { error = ex . getlocalizedmessage ( ) ; logger . getlogger ( tracker . class . getname ( ) ) . log ( level . severe , null , ex ) ; } }
te	2	public object [ ] drawobservations ( int d , int n ) { object [ ] observations = new object [ d ] ; for ( int i = 0 ; i < d ; i ++ ) { observations [ i ] = drawobservation ( n ) ; } return observations ; }
te	9	public int getitem ( final string message ) { int id ; try { try { try { id = integer . parseint ( custommessages . getstring ( message ) ) ; } catch ( exception e ) { material m = material . getmaterial ( custommessages . getstring ( message ) . touppercase ( ) ) ; id = m != null ? m . getid ( ) : - 1 ; } } catch ( final missingresourceexception ex ) { try { id = integer . parseint ( messages . getstring ( message ) ) ; } catch ( exception e ) { material m = material . getmaterial ( messages . getstring ( message ) . touppercase ( ) ) ; id = m != null ? m . getid ( ) : - 1 ; } } } catch ( final missingresourceexception ex ) { try { id = integer . parseint ( defaultbundle . getstring ( message ) ) ; } catch ( exception e ) { material m = material . getmaterial ( defaultbundle . getstring ( message ) . touppercase ( ) ) ; id = m != null ? m . getid ( ) : - 1 ; } } return id ; }
te	7	@ override public void update ( observable arg1 , object arg2 ) { if ( this . controller != null ) { logger . log ( level . fine , "updating gui" ) ; swingutilities . invokelater ( new runnable ( ) { @ override public void run ( ) { logger . log ( level . fine , "number of connected clients: " + client . getusers ( ) . size ( ) ) ; linkedlist < user > clients = client . getusers ( ) ; logger . log ( level . fine , "removing all children" ) ; treeroot . removeallchildren ( ) ; for ( user connecteduser : clients ) { if ( ! connecteduser . getip ( ) . equals ( client . getmulticastaddress ( ) ) ) { logger . log ( level . fine , "new user detected: " + connecteduser . getname ( ) ) ; defaultmutabletreenode user = new defaultmutabletreenode ( connecteduser ) ; treeroot . add ( user ) ; } } connectedplayers . updateui ( ) ; frame . repaint ( ) ; for ( int i = 0 ; i < connectedplayers . getrowcount ( ) ; i ++ ) { connectedplayers . expandrow ( i ) ; } } } ) ; } }
te	6	private void makeprefab ( ) { prefab = new prefab ( x1 , y1 , x2 , y2 ) ; boolean found = true ; int filenumber = 0 ; string pathtag = "houseprefab" ; string path = "" ; do { path = "data/" + pathtag + string . valueof ( filenumber ) + ".pfb" ; file f = new file ( path ) ; if ( ! f . isfile ( ) ) { found = false ; } else { filenumber ++ ; } } while ( found ) ; try { prefab . save ( path ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } }
