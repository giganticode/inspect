tr	9	public string [ ] split ( string sql ) { list < string > lst = new linkedlist < string > ( ) ; int i = 0 ; int lastsplit = 0 ; char [ ] ca = sql . tochararray ( ) ; boolean isvalue = false ; char nextendcharacter = ' ' ; for ( i = 0 ; i < ca . length ; i ++ ) { if ( isvalue == false && ( ca [ i ] == '\\'' || ca [ i ] == '"' ) ) { nextendcharacter = ca [ i ] ; isvalue = true ; } else if ( isvalue == true && ca [ i ] == nextendcharacter ) { isvalue = false ; } else if ( isvalue == false && ca [ i ] == ';' ) { lst . add ( sql . substring ( lastsplit , i ) ) ; lastsplit = i + 1 ; } } return lst . toarray ( new string [ lst . size ( ) ] ) ; }
tr	1	public string getcontingencyid ( ) { return mcontingencyid ; }
tr	10	private void checkinputarguments ( string [ ] args ) { int i = 0 ; while ( i < args . length ) { switch ( args [ i ] ) { case "-i" : handleinputfile ( args , i ) ; i += 2 ; break ; case "-o" : handleoutputdirectory ( args , i ) ; i += 2 ; break ; case "-os" : handleos ( args , i ) ; i += 2 ; break ; default : printformathelp ( ) ; system . exit ( 2 ) ; } } if ( inputfilename == null ) { printformathelp ( ) ; system . exit ( 2 ) ; } core . setcore ( outputdst , islinux ) ; }
tr	7	@ override public void update ( observable arg1 , object arg2 ) { if ( this . controller != null ) { logger . log ( level . fine , "updating gui" ) ; swingutilities . invokelater ( new runnable ( ) { @ override public void run ( ) { logger . log ( level . fine , "number of connected clients: " + client . getusers ( ) . size ( ) ) ; linkedlist < user > clients = client . getusers ( ) ; logger . log ( level . fine , "removing all children" ) ; treeroot . removeallchildren ( ) ; for ( user connecteduser : clients ) { if ( ! connecteduser . getip ( ) . equals ( client . getmulticastaddress ( ) ) ) { logger . log ( level . fine , "new user detected: " + connecteduser . getname ( ) ) ; defaultmutabletreenode user = new defaultmutabletreenode ( connecteduser ) ; treeroot . add ( user ) ; } } connectedplayers . updateui ( ) ; frame . repaint ( ) ; for ( int i = 0 ; i < connectedplayers . getrowcount ( ) ; i ++ ) { connectedplayers . expandrow ( i ) ; } } } ) ; } }
tr	7	private int lootarea ( ) { int lootfound = 0 ; for ( survivor currentsurvivor : this . raidsettings . getteam ( ) ) { final int x = currentsurvivor . getskills ( ) . getscavengingskill ( ) , min = skills . level_min , max = skills . level_max ; double coeff = 1 + ( ( x - min ) / ( ( double ) max - min ) ) ; double rand = bitingdeathgame . getrandomprobability ( ) * coeff ; if ( rand > 1 ) { rand = 1 ; } if ( rand > 0.75 ) lootfound += 2 ; else if ( rand > 0.25 ) lootfound ++ ; } return lootfound ; }
tr	7	protected void solve ( ) { node root = graph . nodes . getnode ( 0 ) ; setparentedge ( root , null ) ; addnode ( root ) ; while ( members . size ( ) < graph . nodes . size ( ) ) { if ( candidates . size ( ) == 0 ) throw new runtimeexception ( "graph is not fully connected" ) ; int minslack = integer . max_value , slack ; edge minedge = null , edge ; for ( int i = 0 ; i < candidates . size ( ) && minslack > 0 ; i ++ ) { edge = candidates . getedge ( i ) ; slack = edge . getslack ( ) ; if ( slack < minslack ) { minslack = slack ; minedge = edge ; } } addedge ( minedge ) ; } graph . nodes . normalizeranks ( ) ; }
tr	6	@ override public void enqueuecommand ( command cmd ) { switch ( clienttype ) { case kinect : switch ( cmd . getcommandtype ( ) ) { case rstatus : case rlock : sendcommand ( cmd ) ; break ; } break ; case mapper : switch ( cmd . getcommandtype ( ) ) { case mposition : case rstatus : case rlock : case runlock : sendcommand ( cmd ) ; break ; } break ; } }
tr	8	public vec2 getmaximumpossiblemovement ( movingobject mo ) { maximummovement = mo . getcurrentdirection ( ) ; vec2 tempmaximummovement = new vec2 ( maximummovement ) ; vec2 currentposition = mo . getcurrentcenterposition ( ) ; vec2 predictedposition = mo . getpredictedcenterposition ( ) ; vec2 min = currentposition . min ( predictedposition ) ; vec2 max = currentposition . max ( predictedposition ) ; min . addto ( mo . getaabb ( ) . gethalfextent ( ) . getnegation ( ) ) ; min . addto ( new vec2 ( 1 , 1 ) ) ; max . addto ( mo . getaabb ( ) . gethalfextent ( ) ) ; max . addto ( new vec2 ( - 1 , - 1 ) ) ; int firsttilex = math . max ( map . worldcoordtotilex ( min . getx ( ) ) , 0 ) ; int firsttiley = math . max ( map . worldcoordtotiley ( min . gety ( ) ) , 0 ) ; int lasttilex = math . min ( map . worldcoordtotilex ( max . getx ( ) ) , map . getcolumnsinmap ( ) - 1 ) ; int lasttiley = math . min ( map . worldcoordtotiley ( max . gety ( ) ) , map . getrowsinmap ( ) - 1 ) ; for ( int row = firsttiley ; row <= lasttiley ; row ++ ) { for ( int column = firsttilex ; column <= lasttilex ; column ++ ) { if ( map . gettiletype ( row , column ) == tiletype . blocking ) { vec2 center = new vec2 ( map . tilecoordtoworldx ( column ) , map . tilecoordtoworldy ( row ) ) ; vec2 halfextent = new vec2 ( map . gettilewidth ( ) / 2 , map . gettileheight ( ) / 2 ) ; collisiontile collisiontile = new collisiontile ( center , halfextent ) ; collisionparams collisionparams = willcollide ( mo , collisiontile ) ; if ( collisionparams . collided ) { if ( math . abs ( collisionparams . getmaximummovement ( ) . getx ( ) ) < math . abs ( tempmaximummovement . getx ( ) ) ) tempmaximummovement . setx ( collisionparams . getmaximummovement ( ) . getx ( ) ) ; if ( math . abs ( collisionparams . getmaximummovement ( ) . gety ( ) ) < math . abs ( tempmaximummovement . gety ( ) ) ) tempmaximummovement . sety ( collisionparams . getmaximummovement ( ) . gety ( ) ) ; } verticalinnercollide = false ; } } } return tempmaximummovement ; }
tr	2	private void loadrandomprefab ( int xstart , int ystart ) { try { prefab . randomprefabfromfile ( xstart , ystart ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } }
tr	4	private boolean isnewer ( string remoteabsfilename , path filepath ) throws sftpexception , ioexception { remoteabsfilename = tosshpath ( remoteabsfilename ) ; sftpattrs stat = stat ( remoteabsfilename ) ; if ( stat == null ) return false ; filetime localtime = files . getlastmodifiedtime ( filepath ) ; long localmillis = localtime . tomillis ( ) / 1000 ; int remotemillis = stat . getmtime ( ) ; if ( localmillis <= remotemillis ) return true ; return false ; }
tr	5	protected parse_action insert_action ( parse_action a1 , parse_action a2 , int act_type ) throws internal_error { if ( ( a1 . kind ( ) == act_type ) && ( a2 . kind ( ) == act_type ) ) { throw new internal_error ( "conflict resolution of bogus actions" ) ; } else if ( a1 . kind ( ) == act_type ) { return a1 ; } else if ( a2 . kind ( ) == act_type ) { return a2 ; } else { throw new internal_error ( "conflict resolution of bogus actions" ) ; } }
tr	3	public static string getdep ( string parse ) { tree t ; stringbuilder sb = new stringbuilder ( ) ; try { t = tf . newtreereader ( new stringreader ( parse ) ) . readtree ( ) ; grammaticalstructure gs = gsf . newgrammaticalstructure ( t ) ; iterator < typeddependency > it = gs . typeddependenciescollapsed ( ) . iterator ( ) ; while ( it . hasnext ( ) ) { sb . append ( it . next ( ) + "\\t" ) ; } } catch ( ioexception e ) { e . printstacktrace ( ) ; } return sb . tostring ( ) ; }
tr	1	public static string sanitizestring ( string s ) { return s . replaceall ( "[^a-za-z0-9 '!?.<litcomma>\\\\-\\\\(\\\\)]" , "" ) ; }
tr	2	protected void sleepmilliseconds ( long milliseconds ) { try { thread . sleep ( milliseconds ) ; } catch ( interruptedexception e ) { e . printstacktrace ( ) ; } }
tr	4	private collection < string > tryconvertingstringstovalues ( collection < abstractoption > options , map < string , string > properties ) { final collection < string > conversionerrors = new linkedlist < string > ( ) ; for ( abstractoption option : options ) { final string key = option . getkey ( ) ; if ( properties . containskey ( key ) ) { try { option . convertstringtovalue ( properties . get ( key ) ) ; } catch ( parseexception e ) { conversionerrors . add ( key ) ; properties . remove ( key ) ; } } } return conversionerrors ; }
tr	1	public static void main ( string [ ] args ) { testneuronnetwork ( ) ; }
tr	1	public double getratestop ( ) { return mratestop ; }
tr	6	public void update ( marketdata data ) { if ( this . databuffer . isempty ( ) ) { throw new missingmarketdata ( ) ; } while ( this . curr < this . databuffer . size ( ) ) { date currdate = this . databuffer . get ( this . curr ) . getstartdate ( ) ; if ( currdate . compareto ( data . getstartdate ( ) ) >= 0 ) { break ; } this . curr ++ ; } }
tr	5	public zone getzone ( int x , int y ) throws outofboundsexception { if ( x < 0 || x >= this . width || y < 0 || y >= this . height ) throw new outofboundsexception ( ) ; return this . zones [ x ] [ y ] ; }
tr	3	@ override public void draw ( graphics2d g2d ) { if ( ! exploding ) { g2d . rotate ( math . toradians ( 360 - faceangle ) , calculator . getscreenlocationmiddle ( gamedata . getcameralocation ( ) , location , activeimage . getwidth ( ) , activeimage . getheight ( ) ) . x , calculator . getscreenlocationmiddle ( gamedata . getcameralocation ( ) , location , activeimage . getwidth ( ) , activeimage . getheight ( ) ) . y ) ; g2d . translate ( calculator . getscreenlocation ( gamedata . getcameralocation ( ) , location ) . x , calculator . getscreenlocation ( gamedata . getcameralocation ( ) , location ) . y ) ; g2d . drawimage ( activeimage , 0 , 0 , null ) ; } else { explosion . draw ( g2d ) ; if ( explosion . isdone ( ) ) { exploding = false ; actionlistener . entitydoneexploding ( this ) ; } } }
tr	6	public static int tonextlevel ( int [ ] expneeded , int received ) { int whatleft = 0 ; if ( received < expneeded [ 0 ] ) { return expneeded [ 0 ] - received ; } int uptolevel = 0 ; for ( int i = 0 ; i < expneeded . length ; i ++ ) { if ( received < expneeded [ i ] ) { uptolevel = i ; break ; } } whatleft = ( expneeded [ uptolevel ] - expneeded [ uptolevel - 1 ] ) - ( received - expneeded [ uptolevel - 1 ] ) ; return whatleft ; }
tr	4	public lalr_state ( lalr_item_set itms ) throws internal_error { if ( itms == null ) throw new internal_error ( "attempt to construct an lalr state from a null item set" ) ; if ( find_state ( itms ) != null ) throw new internal_error ( "attempt to construct a duplicate lalr state" ) ; _index = next_index ++ ; _items = itms ; _all . put ( _items , this ) ; }
tr	5	private jcomponent nouveauchamp ( int type ) { jcomponent champ ; switch ( type ) { case constantes . integer : champ = new jformattedtextfield ( numberformat . getintegerinstance ( ) ) ; ( ( jformattedtextfield ) champ ) . setcolumns ( 20 ) ; break ; case constantes . double : champ = new jformattedtextfield ( numberformat . getnumberinstance ( ) ) ; ( ( jformattedtextfield ) champ ) . setcolumns ( 20 ) ; break ; case constantes . string : champ = new jformattedtextfield ( ) ; ( ( jformattedtextfield ) champ ) . setcolumns ( 20 ) ; break ; case constantes . boolean : champ = new jcheckbox ( ) ; break ; default : champ = null ; } return champ ; }
tr	5	private void startterminationcheckerthread ( ) { terminationcheckthread = new thread ( ) { @ override public void run ( ) { while ( keeprunning ) { countermessage message = new countermessage ( - 1 , ++ timezone , ownendpoint ) ; for ( endpoint e : endpoints ) { addmessagetooutbox ( e , message ) ; } try { thread . sleep ( check_delay ) ; } catch ( interruptedexception e ) { logger . error ( "termination check thread encountered an exception!" , e ) ; system . exit ( - 1 ) ; } } } } ; terminationcheckthread . start ( ) ; logger . info ( "termination checker started!" ) ; }
tr	8	@ override public netstate computestate ( net net ) { if ( ! initialized ) { initialize ( ) ; initialized = true ; } long address = getaddress ( ) ; if ( address != lastreqadd ) { lastreqadd = address ; long memvalue = memvalues . get ( address ) ; lastvalues . clear ( ) ; for ( net n : pins . get ( 0 ) ) { if ( memvalue % 2 == 1 ) { lastvalues . put ( n . getname ( ) , net . netstate . high ) ; memvalue = ( memvalue - 1 ) / 2 ; } else { lastvalues . put ( n . getname ( ) , net . netstate . low ) ; memvalue = memvalue / 2 ; } } } return lastvalues . get ( net . getname ( ) ) ; }
tr	3	@ override public void insertstring ( int offs , string str , attributeset a ) throws badlocationexception { char [ ] chars = str . tochararray ( ) ; for ( char achar : chars ) { if ( ! character . isdigit ( achar ) ) { return ; } } super . insertstring ( offs , str , a ) ; }
tr	5	static void sendlogin ( string fielduser , string fieldpass ) { string service = webcontent . getcollectorurl ( ) + "loguser" ; string requestdata = "username=" + url . encodecomponent ( fielduser ) + "&password=" + url . encodecomponent ( fieldpass ) ; requestbuilder builder = new requestbuilder ( requestbuilder . post , service ) ; builder . setheader ( "content-type" , "application/x-www-form-urlencoded;charset=utf-8" ) ; try { builder . sendrequest ( requestdata , new requestcallback ( ) { @ override public void onerror ( request request , throwable exception ) { loginerror ( alerts . getusermessage ( exception ) ) ; } @ override public void onresponsereceived ( request request , response response ) { if ( response . getstatuscode ( ) == response . sc_ok ) { if ( response . gettext ( ) . equals ( "0" ) ) { successfullogin ( ) ; } else if ( response . gettext ( ) . equals ( "1" ) ) { failedlogin ( ) ; } else { loginerror ( alerts . getusermessageformalformed ( ) ) ; } } else { loginerror ( alerts . getusermessage ( response . getstatuscode ( ) ) ) ; } } } ) ; } catch ( exception e ) { loginerror ( alerts . getusermessage ( e ) ) ; } }
tr	8	private void checkhorizontalscrollbar ( basiccombopopup popup ) { jviewport viewport = scrollpane . getviewport ( ) ; point p = viewport . getviewposition ( ) ; p . x = 0 ; viewport . setviewposition ( p ) ; if ( ! scrollbarrequired ) { scrollpane . sethorizontalscrollbar ( null ) ; return ; } jscrollbar horizontal = scrollpane . gethorizontalscrollbar ( ) ; if ( horizontal == null ) { horizontal = new jscrollbar ( jscrollbar . horizontal ) ; scrollpane . sethorizontalscrollbar ( horizontal ) ; scrollpane . sethorizontalscrollbarpolicy ( jscrollpane . horizontal_scrollbar_as_needed ) ; } if ( horizontalscrollbarwillbevisible ( popup , scrollpane ) ) { dimension scrollpanesize = scrollpane . getpreferredsize ( ) ; scrollpanesize . height += horizontal . getpreferredsize ( ) . height ; scrollpane . setpreferredsize ( scrollpanesize ) ; scrollpane . setmaximumsize ( scrollpanesize ) ; scrollpane . revalidate ( ) ; } }
tr	2	public static linkedlist < vertex > findunobstructedpoints ( vertex v , linkedlist < vertex > vertices , statwriter writer ) { if ( v == null ) return null ; src = v ; heap < angleinterval > allintervals = findintervals ( vertices ) ; list = flattenintervals ( allintervals , writer ) ; return getunobstructedvertices ( vertices ) ; }
tr	9	private value factor ( ) { token t = poptoken ( ) ; switch ( t . gettokentype ( ) ) { case sconstant : return new constantvalue ( t . getvalue ( ) , new type ( "integer" ) ) ; case sstring : string tmp = t . getvalue ( ) . substring ( 1 , t . getvalue ( ) . length ( ) - 1 ) ; if ( tmp . length ( ) > 1 ) return new constantvalue ( tmp , new arraytype ( "char" , 0 , tmp . length ( ) - 1 ) ) ; else return new constantvalue ( tmp , new type ( "char" ) ) ; case sfalse : case strue : return new constantvalue ( t . getvalue ( ) , new type ( "boolean" ) ) ; case sidentifier : pushtoken ( t ) ; return variable ( ) ; case slparen : value pt = expression ( ) ; expecttoken ( tokentype . srparen ) ; return pt ; case snot : list < value > operands = new linkedlist < value > ( ) ; operands . add ( factor ( ) ) ; return new expression ( t . getvalue ( ) , operands , new type ( "boolean" ) ) ; default : fail ( t ) ; } return null ; }
tr	5	public static void testsymmetricconcentration ( int numdimensions , int numobservations , int observationmeanlength ) { double logd = math . log ( numdimensions ) ; for ( int exponent = - 5 ; exponent < 4 ; exponent ++ ) { double alpha = numdimensions * 1.0 ; dirichlet prior = new dirichlet ( numdimensions , alpha / numdimensions ) ; int [ ] counthistogram = new int [ 1000000 ] ; int [ ] observationlengths = new int [ 1000000 ] ; object [ ] observations = prior . drawobservations ( numobservations , observationmeanlength ) ; dirichlet optimizeddirichlet = new dirichlet ( numdimensions , 1.0 ) ; optimizeddirichlet . learnparameterswithhistogram ( observations ) ; system . out . println ( optimizeddirichlet . magnitude ) ; for ( int i = 0 ; i < numobservations ; i ++ ) { int [ ] observation = ( int [ ] ) observations [ i ] ; int total = 0 ; for ( int k = 0 ; k < numdimensions ; k ++ ) { if ( observation [ k ] > 0 ) { total += observation [ k ] ; counthistogram [ observation [ k ] ] ++ ; } } observationlengths [ total ] ++ ; } double estimatedalpha = learnsymmetricconcentration ( counthistogram , observationlengths , numdimensions , 1.0 ) ; system . out . println ( alpha + "\\t" + estimatedalpha + "\\t" + math . abs ( alpha - estimatedalpha ) ) ; } }
tr	6	public string tostring ( ) { string string = "" ; if ( this . isempty ( ) ) return "" ; else string = this . get ( 0 ) . getorigine ( ) . getcontent ( ) . tostring ( ) ; for ( segment arete : this ) { if ( string != "" ) string += "|" ; string += arete . getdestination ( ) . getcontent ( ) . tostring ( ) ; } return string ; }
tr	2	public object gettransferdata ( dataflavor df ) throws unsupportedflavorexception , ioexception { if ( isdataflavorsupported ( df ) ) return object ; else throw new unsupportedflavorexception ( df ) ; }
tr	9	@ fxml void menuaction ( actionevent e ) { if ( e . getsource ( ) instanceof menuitem ) { switch ( ( ( menuitem ) e . getsource ( ) ) . gettext ( ) ) { case "import wizard..." : showinputframe ( ) ; break ; case "exit" : exit ( ) ; break ; case "overview" : showoverview ( ) ; break ; case "nod chart" : shownodchart ( ) ; break ; case "wilcox chart" : showwilcoxchart ( ) ; break ; case "david analysis" : showdavid ( ) ; break ; case "document" : showdocument ( ) ; break ; case "about" : showabout ( ) ; break ; } } }
tr	4	public string isable ( long d , int t , int b ) { final string possible = "possible" ; final string impossible = "impossible" ; long pos = d - t ; if ( pos < 0 ) return impossible ; else if ( pos % ( b - 1 ) == 0 && pos / ( b - 1 ) <= t ) return possible ; return impossible ; }
tr	10	public static boolean testriffle ( int [ ] shuffleddeck , int shuffleddeckindex , int [ ] half1 , int half1index , int [ ] half2 , int half2index ) { if ( shuffleddeckindex == shuffleddeck . length ) { return true ; } if ( half1index < half1 . length && shuffleddeck [ shuffleddeckindex ] == half1 [ half1index ] ) { return testriffle ( shuffleddeck , shuffleddeckindex ++ , half1 , half1index ++ , half2 , half2index ) ; } else if ( half2index < half2 . length && shuffleddeck [ shuffleddeckindex ] == half2 [ half2index ] ) { return testriffle ( shuffleddeck , shuffleddeckindex ++ , half1 , half1index ++ , half2 , half2index ) ; } else { return false ; } }
tr	5	private void checkconntypevalidity ( ) throws genericconnectionexception { if ( ( selectedconntype != null ) ) { if ( selectedconntype . equals ( conn_local ) || selectedconntype . equals ( conn_rmi ) || selectedconntype . equals ( conn_socket ) ) { return ; } } throw new genericconnectionexception ( "nessun tipo di connessione selezionato!" ) ; }
tr	9	@ override public void actionperformed ( actionevent a ) { if ( a . getsource ( ) == this . close ) { close ( ) ; } else if ( a . getsource ( ) == this . openfile ) { open ( ) ; } else if ( a . getsource ( ) == this . savefile ) { save ( ) ; } else if ( a . getsource ( ) == this . newfile ) { newfile ( ) ; } else if ( a . getsource ( ) == this . update ) { if ( this . type != null ) pp ( ) ; } else if ( a . getsource ( ) == this . graph ) { if ( this . type != null ) gen ( ) ; } }
tr	2	@ after public void clean ( ) { super . clean ( ) ; if ( storage_server != null ) { storage_server . stop ( ) ; storage_server = null ; } }
tr	4	private void recontrol ( final int len ) { if ( c == null || len > c . length ) { final int clen = len + mincap ; c = new point [ clen ] ; for ( int i = 0 ; i < clen ; ++ i ) c [ i ] = new point ( ) ; } }
tr	5	private boolean directionwilloutreachmaplimits ( direction dir , int x , int y ) { int dx = 0 , dy = 0 ; if ( dir == direction . north ) dy = - 1 ; else if ( dir == direction . south ) dy = 1 ; else if ( dir == direction . west ) dx = - 1 ; else if ( dir == direction . east ) dx = 1 ; int newx = x + dx , newy = y + dy ; boolean inbounds = ( newx >= 0 && newx < this . width && newy >= 0 && newy < this . height ) ; return ! inbounds ; }
tr	10	public list < photo > getphotos ( photoset set ) { int perpage = 100 ; int total = - 1 ; int page = 1 ; list < photo > photos = new arraylist ( ) ; while ( total == - 1 || ( page - 1 ) * perpage < total ) { string response = call ( "flickr.photosets.getphotos" , "photoset_id=" + set . id + "&media=photos&extras=url_l<litcomma>url_o<litcomma>url_k<litcomma>url_h&per_page=" + perpage + "&page=" + page ) ; jsonobject json = ( jsonobject ) jsonparse ( response ) ; if ( json == null ) return null ; if ( total == - 1 ) total = integer . parseint ( ( string ) ( ( jsonobject ) json . get ( "photoset" ) ) . get ( "total" ) ) ; jsonarray photosjson = ( jsonarray ) ( ( jsonobject ) json . get ( "photoset" ) ) . get ( "photo" ) ; for ( int i = 0 ; i < photosjson . size ( ) ; i ++ ) { jsonobject photojson = ( jsonobject ) photosjson . get ( new integer ( i ) ) ; photo photo = new photo ( ) ; photo . id = long . parselong ( photojson . get ( "id" ) . tostring ( ) ) ; photo . title = ( string ) photojson . get ( "title" ) ; photo . large1024url = ( string ) photojson . get ( "url_l" ) ; photo . large1600url = ( string ) photojson . get ( "url_h" ) ; photo . large2048url = ( string ) photojson . get ( "url_k" ) ; photo . originalurl = ( string ) photojson . get ( "url_o" ) ; photos . add ( photo ) ; } page ++ ; } return photos ; }
tr	6	public bookmeta getbook ( minecart minecart ) { bookmeta book = ( bookmeta ) new itemstack ( material . written_book ) . getitemmeta ( ) ; list < bookjob > bookjobs = minecartbookjobmap . get ( minecart ) ; if ( bookjobs == null ) { return book ; } stringbuilder page = new stringbuilder ( ) ; stringbuilder job ; for ( bookjob bj : bookjobs ) { job = new stringbuilder ( ) ; job . append ( bj . getbookjobname ( ) ) ; job . append ( '_' ) ; job . append ( bj . getreferenz ( ) ) ; job . append ( ' ' ) ; job . append ( bj . getjob ( ) ) ; job . append ( ' ' ) ; job . append ( bj . getstatus ( ) . getcolor ( ) ) ; job . append ( '#' ) ; job . append ( bj . getstatus ( ) . tostring ( ) ) ; job . append ( "\\n" ) ; if ( page . length ( ) + job . length ( ) >= 246 ) { book . addpage ( page . tostring ( ) ) ; page = new stringbuilder ( ) ; } page . append ( job . tostring ( ) ) ; } book . addpage ( page . tostring ( ) ) ; return book ; }
tr	6	@ override public widgetchild getchild ( ) { widgetchild main = widgets . get ( book_widget , main_child ) ; if ( main == null ) return null ; widgetchild ret = main . getchild ( bookchild ) ; if ( ret == null || ret . gettextureid ( ) != booktexture ) return null ; return ret ; }
tr	5	public point convert3dto2d ( point point3d ) { point point2d = new point ( ) ; int i_x3d = ( int ) point3d . getx ( ) ; int i_y3d = ( int ) point3d . gety ( ) ; int i_idx = 0 ; int i_begin = listintegerbegintransfo . get ( ( int ) point3d . gety ( ) ) ; int i_stop = listintegerstoptransfo . get ( ( int ) point3d . gety ( ) ) ; if ( i_x3d >= i_begin && i_x3d <= i_stop ) { for ( int i_idcase = i_begin ; i_idcase <= i_stop ; i_idcase ++ ) { if ( i_x3d == i_idcase ) { i_idx = i_idcase - i_begin ; } } point2d . x = i_idx + math . max ( map2d . getmap ( ) . size ( ) - 1 , i_y3d ) - ( map2d . getmap ( ) . size ( ) - 1 ) ; point2d . y = math . min ( map2d . getmap ( ) . size ( ) - 1 , i_y3d ) - i_idx ; } return point2d ; }
tr	9	public static treenode buildfromstring ( string str ) { string [ ] parts = str . substring ( 1 , str . length ( ) - 1 ) . split ( "<litcomma>" ) ; treenode root = null ; linkedlist < treenode > uncompletednode = new linkedlist < > ( ) ; for ( int i = 0 ; i < parts . length ; i ++ ) { if ( i == 0 && ! parts [ i ] . equals ( nulltree ) ) { root = new treenode ( integer . parseint ( parts [ i ] ) ) ; uncompletednode . add ( root ) ; } else { treenode iter = uncompletednode . pop ( ) ; if ( ! parts [ i ] . equals ( nulltree ) ) { iter . left = new treenode ( integer . parseint ( parts [ i ] ) ) ; uncompletednode . add ( iter . left ) ; } i ++ ; if ( i < parts . length && ! parts [ i ] . equals ( nulltree ) ) { iter . right = new treenode ( integer . parseint ( parts [ i ] ) ) ; uncompletednode . add ( iter . right ) ; } } } return root ; }
tr	6	@ override public void init ( ) { super . init ( ) ; background = new jpanel ( ) { private static final long serialversionuid = 1l ; @ override public void paint ( graphics g ) { super . paint ( g ) ; graphics2d g2 = ( graphics2d ) g ; int counter = 0 ; for ( int x = 0 ; x < horizontalfields ; x ++ ) { for ( int y = 0 ; y < verticalfields ; y ++ ) { g2 . drawimage ( randomtiles . get ( counter ) , x * field_size , y * field_size , null ) ; counter ++ ; } } for ( gameboardelement element : gameboard . getallelements ( ) ) { drawelementto ( g2 , element ) ; } } } ; addkeylistenerto ( background ) ; add ( background ) ; configuregame ( ) ; preparebackgroundtiles ( ) ; setsize ( horizontalfields * field_size , verticalfields * field_size ) ; }
tr	8	public void close ( ) { if ( id3tag != null ) id3tag . clear ( ) ; if ( audio != null ) audio . close ( ) ; if ( instream != null ) instream . close ( ) ; }
tr	2	public static void main ( string [ ] args ) { int [ ] a = { 2 , 23 , 532 , 576 , 4 , 21 , 32 , 1 , 32 , 24 , 32 , 12 } ; quicksort ( a , 0 , a . length - 1 ) ; for ( int i : a ) { system . out . print ( i + " " ) ; } }
tr	7	public void transpose ( ) { int size = rows * cols ; int last = size - 1 ; int cols = rows ; boolean [ ] visited = new boolean [ size ] ; int cycle = 0 ; while ( ++ cycle != size ) { if ( visited [ cycle ] ) { continue ; } int a = cycle ; do { a = ( a == last ) ? last : ( cols * a ) % last ; swap ( a , cycle ) ; visited [ a ] = true ; } while ( a != cycle ) ; } }
tr	7	public void actionperformed ( actionevent arg0 ) { if ( arg0 . getsource ( ) == cancel ) { setvisible ( false ) ; clear ( ) ; } else if ( arg0 . getsource ( ) == save ) { if ( parent == util . quest . sp ) { if ( loaded == null ) { util . quest . slist . getselectedvalue ( ) . addaction ( create ( ) ) ; util . quest . sp . delete . setenabled ( true ) ; } else edit ( ) ; util . quest . sp . loaddata ( util . quest . slist . getselectedvalue ( ) ) ; setvisible ( false ) ; clear ( ) ; } else if ( parent == util . quest . op . rewards ) { if ( loaded == null ) { util . quest . op . rwcp . addaction ( create ( ) ) ; util . quest . op . rewards . delete . setenabled ( true ) ; } else edit ( ) ; util . quest . op . rewards . loaddata ( util . quest . op . rewards . loaded ) ; setvisible ( false ) ; clear ( ) ; } util . markfilechanged ( ) ; } }
tr	4	private void addfiles ( file documentpath , collection < file > alldocs ) { file [ ] children = documentpath . listfiles ( ) ; if ( children != null ) { for ( file child : children ) { if ( child . isfile ( ) ) { alldocs . add ( child ) ; } else { addfiles ( child , alldocs ) ; } } } }
tr	4	@ override public void drawforeground ( ) { string str = "x1." + string . valueof ( x1 ) + " y1." + string . valueof ( y1 ) ; string str2 = "x2." + string . valueof ( x2 ) + " y2." + string . valueof ( y2 ) ; addtext ( 10 , 70 , str ) ; addtext ( 10 , 90 , str2 ) ; int width ; int height ; if ( x2 > x1 ) { width = x2 - x1 ; } else { width = x1 - x2 ; } if ( y2 > y1 ) { height = y2 - y1 ; } else { height = y1 - y2 ; } height ++ ; width ++ ; string str3 = "w." + string . valueof ( width ) + " h." + string . valueof ( height ) ; addtext ( 10 , 110 , str3 ) ; }
tr	10	protected void report_reduce_reduce ( lalr_item itm1 , lalr_item itm2 ) throws internal_error { boolean comma_flag = false ; system . err . println ( "*** reduce/reduce conflict found in state #" + index ( ) ) ; system . err . print ( "  between " ) ; system . err . println ( itm1 . to_simple_string ( ) ) ; system . err . print ( "  and     " ) ; system . err . println ( itm2 . to_simple_string ( ) ) ; system . err . print ( "  under symbols: {" ) ; for ( int t = 0 ; t < terminal . number ( ) ; t ++ ) { if ( itm1 . lookahead ( ) . contains ( t ) && itm2 . lookahead ( ) . contains ( t ) ) { if ( comma_flag ) system . err . print ( "<litcomma> " ) ; else comma_flag = true ; system . err . print ( terminal . find ( t ) . name ( ) ) ; } } system . err . println ( "}" ) ; system . err . print ( "  resolved in favor of " ) ; if ( itm1 . the_production ( ) . index ( ) < itm2 . the_production ( ) . index ( ) ) system . err . println ( "the first production.\\n" ) ; else system . err . println ( "the second production.\\n" ) ; emit . num_conflicts ++ ; lexer . warning_count ++ ; }
tr	1	public static double loggammanemes ( double z ) { double result = half_log_two_pi - ( math . log ( z ) / 2 ) + z * ( math . log ( z + ( 1 / ( 12 * z - ( 1 / ( 10 * z ) ) ) ) ) - 1 ) ; return result ; }
tr	1	public void setdatefrom ( calendar dtfrom ) { mdatefrom = dtfrom ; }
tr	2	public object [ ] drawobservations ( int d , int n ) { object [ ] observations = new object [ d ] ; for ( int i = 0 ; i < d ; i ++ ) { observations [ i ] = drawobservation ( n ) ; } return observations ; }
tr	10	public void fixallupdates ( ) throws exception { try { filereader inputnames = new filereader ( inputfilenamesfilename ) ; bufferedreader inputnamesbr = new bufferedreader ( inputnames ) ; string instr = inputnamesbr . readline ( ) ; while ( instr != null ) { if ( instr . startswith ( "#" ) ) { instr = inputnamesbr . readline ( ) ; continue ; } string updatesfilename ; if ( instr . indexof ( ":" ) != - 1 ) { if ( ! ribs || instr . lastindexof ( ":" ) != instr . indexof ( ":" ) ) { logger . error ( "attention!!! file with ass corresponding to file with updates presented. if this file with updates will be fixed for peeras<litcomma> new as list generation will be needed." ) ; } updatesfilename = instr . substring ( 0 , instr . indexof ( ":" ) ) ; } else { updatesfilename = instr ; } checkandfixupdatefile ( updatesfilename ) ; instr = inputnamesbr . readline ( ) ; } inputnames . close ( ) ; } catch ( ioexception e ) { throw ( new exception ( "io exception during modifying peer as" , e ) ) ; } }
tr	5	private boolean maybecreatenewtemplate ( ) { iterator < numberformat > it = possibleformats . iterator ( ) ; while ( it . hasnext ( ) ) { numberformat numberformat = it . next ( ) ; string pattern = numberformat . getpattern ( ) ; if ( currentformattingpattern . equals ( pattern ) ) { return false ; } if ( createformattingtemplate ( numberformat ) ) { currentformattingpattern = pattern ; shouldaddspaceafternationalprefix = national_prefix_separators_pattern . matcher ( numberformat . getnationalprefixformattingrule ( ) ) . find ( ) ; lastmatchposition = 0 ; return true ; } else { it . remove ( ) ; } } abletoformat = false ; return false ; }
tr	5	public void dopustidoneakotreba ( ) { if ( lblonecellsship . gettext ( ) . equals ( "0" ) && lbltwocellsship . gettext ( ) . equals ( "0" ) && lblthreecellsship . gettext ( ) . equals ( "0" ) && lblfrourcellsship . gettext ( ) . equals ( "0" ) ) btndone . setenabled ( true ) ; }
tr	1	public static void testgraphics ( ) { mydrawableworld world = mydrawableworld . getinstance ( ) ; mycanvaswindow cw = new mycanvaswindow ( 300 , 300 , world ) ; cw . setmouselistener ( new mouselistener ( ) { @ override public void mouseclicked ( mouseevent me ) { world . spawncar ( new mypoint ( me . getx ( ) , me . gety ( ) ) ) ; system . out . println ( "clicked at:" + me . getx ( ) + " " + me . gety ( ) ) ; } @ override public void mousepressed ( mouseevent me ) { } @ override public void mousereleased ( mouseevent me ) { } @ override public void mouseentered ( mouseevent me ) { } @ override public void mouseexited ( mouseevent me ) { } } ) ; cw . startwindow ( ) ; }
tr	9	private static void touchupdatamodel ( xmpmetaimpl xmp ) throws xmpexception { xmpnodeutils . findschemanode ( xmp . getroot ( ) , xmpconst . ns_dc , true ) ; for ( iterator it = xmp . getroot ( ) . iteratechildren ( ) ; it . hasnext ( ) ; ) { xmpnode currschema = ( xmpnode ) it . next ( ) ; if ( xmpconst . ns_dc . equals ( currschema . getname ( ) ) ) { normalizedcarrays ( currschema ) ; } else if ( xmpconst . ns_exif . equals ( currschema . getname ( ) ) ) { fixgpstimestamp ( currschema ) ; xmpnode arraynode = xmpnodeutils . findchildnode ( currschema , "exif:usercomment" , false ) ; if ( arraynode != null ) { repairalttext ( arraynode ) ; } } else if ( xmpconst . ns_dm . equals ( currschema . getname ( ) ) ) { xmpnode dmcopyright = xmpnodeutils . findchildnode ( currschema , "xmpdm:copyright" , false ) ; if ( dmcopyright != null ) { migrateaudiocopyright ( xmp , dmcopyright ) ; } } else if ( xmpconst . ns_xmp_rights . equals ( currschema . getname ( ) ) ) { xmpnode arraynode = xmpnodeutils . findchildnode ( currschema , "xmprights:usageterms" , false ) ; if ( arraynode != null ) { repairalttext ( arraynode ) ; } } } }
tr	5	@ override public void execute ( ) { boolean cashdispensed = false ; double availablebalance ; bankdatabase bankdatabase = getbankdatabase ( ) ; screen screen = getscreen ( ) ; do { amount = displaymenuofamounts ( ) ; if ( amount != canceled ) { availablebalance = bankdatabase . getavailablebalance ( getaccountnumber ( ) ) ; if ( amount <= availablebalance ) { if ( cashdispenser . issufficientcashavailable ( amount ) ) { bankdatabase . debit ( getaccountnumber ( ) , amount ) ; cashdispenser . dispensecash ( amount ) ; cashdispensed = true ; screen . displaymessageline ( "\\nyour cash has been" + " dispensed. please take your cash now." ) ; } else screen . displaymessageline ( "\\ninsufficient cash available in the atm." + "\\n\\nplease choose a smaller amount." ) ; } else { screen . displaymessageline ( "\\ninsufficient funds in your account." + "\\n\\nplease choose a smaller amount." ) ; } } else { screen . displaymessageline ( "\\ncanceling transaction..." ) ; return ; } } while ( ! cashdispensed ) ; }
tr	2	public proxy ( socket clientsocket , config config , atomicboolean stop ) { hmac = new hmachelper ( config ) ; this . clientsocket = clientsocket ; this . users = userdata . getinstance ( ) . users ; this . stop = stop ; this . serveridentifier = serverdata . getinstance ( ) . servers ; username = "" ; try { output = clientsocket . getoutputstream ( ) ; objectoutput = new objectoutputstream ( output ) ; objectoutput . flush ( ) ; input = clientsocket . getinputstream ( ) ; objectinput = new objectinputstream ( input ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } }
tr	10	public void cliquefinredeploiement ( ) { if ( joueurencours . getpeuple ( ) . getnbuniteenmain ( ) == 0 ) { if ( ( etape == 2 || etape == 3 ) ) { if ( game . getinstance ( ) . askconf ( "confirmer la fin du red\xe9ploiement ?" ) ) { if ( etape == 2 ) { if ( tempendeclin ) { joueurencours . getpeuple ( ) . decliner ( ) ; tempendeclin = false ; } setetape ( 3 ) ; indexsauvjoueurencours = indexjoueurencours ; indexjoueurencours = 0 ; } if ( ! deploiementsuivant ( ) ) { joueursuivant ( ) ; } game . getinstance ( ) . majinfos ( ) ; } } } else { new winwarn ( "il vous reste des unit\xe9s en main<litcomma> placez-les !" ) ; } }
tr	6	public void addconfirmeduser ( long uid ) { if ( ! this . isremoving ( ) ) return ; this . awaitingid . remove ( uid ) ; if ( this . awaitingid . size ( ) <= 0 ) { this . finalizeremovalwithoutchecking ( ) ; } else { try { this . save ( ) ; } catch ( sqlexception e ) { e . printstacktrace ( ) ; } } }
tr	7	private void rangedrecur ( location center , int attackleft ) { for ( location loc : center . getajacent ( ) ) { if ( ! loc . isempty ( ) ) { unit defender = loc . getunit ( ) ; if ( defender . getteam ( ) != turn ) { selectlocs . add ( new point ( loc . getloc ( ) ) ) ; } } if ( attackleft > 1 ) { rangedrecur ( loc , attackleft - 1 ) ; } } }
tr	9	private boolean isprimarykeyvaluemissing ( resultset resultset , resultsetmetadata metadata ) throws sqlexception { if ( fielddefinition . hasprimarykey ( ) ) { dbfield < ? , ? > primarykeyfield = fielddefinition . primarykey ( ) ; if ( primarykeyfield . ismultivaluefield ( ) ) { list < object > primarykeyvalues = getmultifieldvalues ( primarykeyfield , metadata , resultset ) ; if ( primarykeyvalues . isempty ( ) ) { return true ; } for ( object value : primarykeyvalues ) { if ( value == null ) { return true ; } } } else if ( getfield ( metadata , resultset , primarykeyfield . selectfieldname ( alias ) ) == null ) { return true ; } } return false ; }
tr	8	public static double fitnesstestd ( pokemonteam samplemember , population generationfoes ) { double defense = 0.0 ; int foese = 0 ; int foer = 0 ; int foei = 0 ; double immuned = 0.0 ; for ( int i = 0 ; i < generationfoes . getpopulation ( ) . size ( ) ; i ++ ) { pokemonteam currentfoe = generationfoes . getpopulation ( ) . get ( i ) ; currentfoe . modifypairings ( samplemember ) ; foese += currentfoe . getmovesupereffectives ( ) ; foer += currentfoe . getmoveresistances ( ) ; foei += currentfoe . getmoveimmunities ( ) ; currentfoe . reset ( ) ; } if ( foei == 0 ) { immuned = ( double ) ( 2 + foei ) / ( foei + 1 ) ; } if ( foei > 0 ) { immuned = ( double ) ( 2 + foei ) / foei ; } defense = ( double ) ( foer - foese ) ; return ( defense + immuned ) * .028 ; }
tr	1	public void setleafnameprefix ( final string leaftoken ) { this . leafnameprefix = leaftoken ; }
tr	6	string convert ( string name , string desttype ) throws exception { integer destindex = usernomen ? 1 : 8 ; integer line = nametoid ( name ) ; string st1 ; if ( destindex != - 1 ) { st1 = annotationtoidmap [ destindex ] . get ( line ) ; if ( st1 != null ) return st1 . tostring ( ) ; } return "" ; }
tr	4	public void stop ( ) { if ( ! platformui . isworkbenchrunning ( ) ) return ; final iworkbench workbench = platformui . getworkbench ( ) ; final display display = workbench . getdisplay ( ) ; display . syncexec ( new runnable ( ) { public void run ( ) { if ( ! display . isdisposed ( ) ) workbench . close ( ) ; } } ) ; }
tr	8	public static double lgammacor ( double x ) { final double algmcs [ ] = { + .1666389480451863247205729650822e+0 , - .1384948176067563840732986059135e-4 , + .9810825646924729426157171547487e-8 , - .1809129475572494194263306266719e-10 , + .6221098041892605227126015543416e-13 , - .3399615005417721944303330599666e-15 , + .2683181998482698748957538846666e-17 , - .2868042435334643284144622399999e-19 , + .3962837061046434803679306666666e-21 , - .6831888753985766870111999999999e-23 , + .1429227355942498147573333333333e-24 , - .3547598158101070547199999999999e-26 , + .1025680058010470912000000000000e-27 , - .3401102254316748799999999999999e-29 , + .1276642195630062933333333333333e-30 } ; int nalgm = 0 ; double xbig = 0 ; double xmax = 0 ; double tmp ; if ( nalgm == 0 ) { nalgm = chebyshev_init ( algmcs , 15 , d1mach ( 3 ) ) ; xbig = 1 / java . lang . math . sqrt ( d1mach ( 3 ) ) ; xmax = java . lang . math . exp ( fmin2 ( java . lang . math . log ( d1mach ( 2 ) / 12 ) , - java . lang . math . log ( 12 * d1mach ( 1 ) ) ) ) ; } if ( x < 10 ) { throw new java . lang . arithmeticexception ( "math error: domain" ) ; } else if ( x >= xmax ) { throw new java . lang . arithmeticexception ( "math error: underflow" ) ; } else if ( x < xbig ) { tmp = 10 / x ; return chebyshev_eval ( tmp * tmp * 2 - 1 , algmcs , nalgm ) / x ; } else return 1 / ( x * 12 ) ; }
tr	4	private void output_target ( double value ) { if ( y_scaling ) { if ( value == y_min ) value = y_lower ; else if ( value == y_max ) value = y_upper ; else value = y_lower + ( y_upper - y_lower ) * ( value - y_min ) / ( y_max - y_min ) ; } system . out . print ( value + " " ) ; }
tr	2	public void setbtnexemplarkopierenvisibiliy ( ) { if ( ! bookdetail . isnew ( ) ) { bookdetail . getbtnexemplarkopieren ( ) . setenabled ( true ) ; } else { bookdetail . getbtnexemplarkopieren ( ) . setenabled ( false ) ; } }
tr	9	public void close ( ) { if ( channel != null ) { if ( logger . isinfoenabled ( ) ) logger . info ( "closing sftp connection to {}@{}" , username , serverip ) ; channel . disconnect ( ) ; } if ( session != null ) { if ( logger . isinfoenabled ( ) ) logger . info ( "closing connection to {}@{}" , username , serverip ) ; session . disconnect ( ) ; } serverip = null ; }
tr	6	static void onvalidate ( string user , string pass ) { if ( frozen ) { return ; } if ( user . isempty ( ) || pass . isempty ( ) ) { return ; } fielduser = user ; fieldpass = pass ; frozen = true ; sendlogin ( fielduser , fieldpass ) ; }
tr	5	private void reflecttextdecoration ( list < textdecoration > decor ) { underline = false ; strike = false ; overline = false ; for ( textdecoration adecor : decor ) { if ( textdecoration . underline == adecor ) { underline = true ; } else if ( textdecoration . line_through == adecor ) { strike = true ; } else if ( textdecoration . overline == adecor ) { overline = true ; } } }
tr	10	public static void permute2 ( int [ ] nums , int start , list < list < integer > > list ) { list < integer > alist ; for ( int i = 0 ; i < nums . length ; i ++ ) { int a = nums [ i ] ; if ( i == 0 ) { alist = new arraylist < integer > ( ) ; alist . add ( a ) ; list . add ( alist ) ; } else { list < list < integer > > copylist = new arraylist < list < integer > > ( ) ; for ( list < integer > l : list ) { copylist . add ( l ) ; } list . clear ( ) ; for ( list < integer > l : copylist ) { for ( int j = 0 ; j <= l . size ( ) ; j ++ ) { alist = new arraylist < integer > ( ) ; alist . addall ( l ) ; if ( j == l . size ( ) ) { alist . add ( a ) ; list . add ( alist ) ; } else { alist . add ( j , a ) ; list . add ( alist ) ; } } } } } }
tr	7	public static arraylist < difference > getalldifferencesbyprefix ( string prefix , hashmap < string , difference > differencemap ) { arraylist < difference > result = new arraylist < difference > ( ) ; treemap < string , difference > treemap = new treemap < string , difference > ( ) ; treemap . putall ( differencemap ) ; sortedmap < string , difference > tailmap = treemap . tailmap ( prefix ) ; if ( ! tailmap . isempty ( ) && tailmap . firstkey ( ) . startswith ( prefix ) ) { iterator < string > itetailmap = tailmap . keyset ( ) . iterator ( ) ; while ( itetailmap . hasnext ( ) ) { string currentkey = itetailmap . next ( ) ; if ( currentkey . startswith ( prefix ) ) { difference currentdifference = tailmap . get ( currentkey ) ; triple currenttriple = currentdifference . gettriple ( ) ; if ( currenttriple . getobjecttype ( ) . equals ( tripleobjecttypeenum . literal ) && ! currentdifference . getresolutionstate ( ) . equals ( resolutionstate . resolved ) ) { result . add ( currentdifference ) ; } } else { return result ; } } } return result ; }
tr	8	private path getoutputpath ( string filename ) { outputoption outputoption = outputoption . valueof ( preferencemanager . getoutputoption ( ) ) ; path outputdirpath ; switch ( outputoption ) { case parent_css : outputdirpath = paths . get ( "../css" ) ; break ; case custom : outputdirpath = paths . get ( preferencemanager . getoutputpath ( ) ) ; break ; default : case same : outputdirpath = paths . get ( "./" ) ; break ; } path originalfilename = paths . get ( filename ) ; outputdirpath = originalfilename . getparent ( ) . resolve ( outputdirpath ) ; string basename = originalfilename . tofile ( ) . getname ( ) ; string outputfilename ; int index = basename . lastindexof ( '.' ) ; if ( index != - 1 ) { outputfilename = basename . substring ( 0 , index ) + ".css" ; } else { outputfilename = basename + ".css" ; } return paths . get ( outputdirpath . tostring ( ) , outputfilename ) ; }
tr	3	@ override public container find ( final class < ? extends object > parentclass , final component c ) { container parent = c . getparent ( ) ; for ( int i = 0 ; i < 10 ; i ++ ) { if ( ! parentclass . isinstance ( parent ) ) { parent = parent . getparent ( ) ; } } return parent ; }
tr	9	private void updaterowtodisplay ( final object value , final int rowindex , final int columnindex ) throws illegalargumentexception { final string methodname = "updaterowtodisplay" ; guilogger . entering ( class_name , methodname , value , rowindex , columnindex ) ; final record record = records . get ( rowindex ) ; final string stringvalue = ( string ) value ; try { switch ( columnindex ) { case record . hotel_name_field_index : record . sethotelname ( stringvalue ) ; break ; case record . location_field_index : record . setlocation ( stringvalue ) ; break ; case record . date_field_index : record . setdate ( stringvalue ) ; break ; case record . rate_field_index : record . setrate ( stringvalue ) ; break ; case record . size_field_index : record . setsize ( stringvalue ) ; break ; case record . smoking_field_index : record . setsmoking ( stringvalue ) ; break ; case record . owner_field_index : record . setowner ( stringvalue ) ; break ; default : guilogger . warning ( class_name , methodname , "can't update a record with the value: " + stringvalue + " at row: " + rowindex + " and column: " + columnindex ) ; } } finally { guilogger . exiting ( class_name , methodname ) ; } }
tr	1	public alphabet getalphabet ( ) { return dict ; }
tr	6	public static void main ( string [ ] args ) { scanner scan = new scanner ( system . in ) ; while ( scan . hasnext ( ) ) { string phone = scan . nextline ( ) ; char [ ] cad = phone . tochararray ( ) ; for ( char a : cad ) { if ( a == '1' || a == '0' || a == '-' ) system . out . print ( a ) ; else system . out . print ( convertir ( a ) ) ; } system . out . println ( ) ; } }
tr	3	public static void setanimationspeed ( int animationspeed ) { if ( animationspeed >= 0 && animationspeed <= 1000 ) simulator . animationspeed = animationspeed ; }
tr	2	private static void writestats ( statwriter writer , int originalsize , int reducedsize ) { try { writer . writeangleeliminations ( originalsize , reducedsize ) ; } catch ( throwable e ) { } }
tr	2	public void draw ( ) { for ( int x = 0 ; x < windowslist . size ( ) ; x ++ ) { windowslist . get ( x ) . draw ( ) ; } panesselector . draw ( ) ; drawsidemenu ( ) ; drawgrabbed ( ) ; }
tr	9	public int [ ] getplayerindexes ( int ruleplayerindex ) { int [ ] ruleplayerindexes ; switch ( ruleplayerindex ) { case config_us_player_id : ruleplayerindexes = new int [ 1 ] ; ruleplayerindexes [ 0 ] = ourplayerindex ; break ; case config_native_player_id : ruleplayerindexes = new int [ 1 ] ; ruleplayerindexes [ 0 ] = gamestatus . nativeplayerindex ; break ; case config_sea_player_id : ruleplayerindexes = new int [ 1 ] ; ruleplayerindexes [ 0 ] = gamestatus . seaplayerindex ; break ; case config_any_player : ruleplayerindexes = new int [ gamestatus . nativeplayerindex ] ; for ( int playerindex = 0 ; playerindex < gamestatus . nativeplayerindex - 1 ; playerindex ++ ) { ruleplayerindexes [ playerindex ] = playerindex ; } computerutils . randomisearray ( ruleplayerindexes ) ; break ; case config_opponent_player_id : ruleplayerindexes = new int [ gamestatus . nativeplayerindex - 1 ] ; int i = 0 ; for ( int playerindex = 0 ; playerindex < gamestatus . nativeplayerindex - 1 ; playerindex ++ ) { if ( playerindex == ourplayerindex ) continue ; ruleplayerindexes [ i ++ ] = playerindex ; } computerutils . randomisearray ( ruleplayerindexes ) ; break ; default : logger . error ( "invalid player index (" + ruleplayerindex + ") for rule" ) ; ruleplayerindexes = new int [ 0 ] ; } return ruleplayerindexes ; }
tr	8	private void initialize ( ) { frame = new jframe ( ) ; frame . addwindowlistener ( new windowadapter ( ) { @ override public void windowclosing ( windowevent e ) { cerrarventana ( ) ; } } ) ; frame . setbounds ( 100 , 100 , 500 , 401 ) ; frame . setdefaultcloseoperation ( jframe . exit_on_close ) ; frame . getcontentpane ( ) . setlayout ( new borderlayout ( 0 , 0 ) ) ; panel = new jpanel ( ) ; frame . getcontentpane ( ) . add ( panel , borderlayout . south ) ; tabbedpane = new jtabbedpane ( jtabbedpane . top ) ; frame . getcontentpane ( ) . add ( tabbedpane , borderlayout . center ) ; paneljugador = new jpanel ( ) ; tabbedpane . addtab ( "jugador" , null , paneljugador , null ) ; paneljugador . setlayout ( null ) ; lblnombre = new jlabel ( "usuario: " ) ; lblnombre . setbounds ( 10 , 11 , 100 , 14 ) ; paneljugador . add ( lblnombre ) ; lbldireccion = new jlabel ( "correo electronico: " ) ; lbldireccion . setbounds ( 10 , 61 , 100 , 14 ) ; paneljugador . add ( lbldireccion ) ; lblciudad = new jlabel ( "pais: " ) ; lblciudad . setbounds ( 10 , 86 , 100 , 14 ) ; paneljugador . add ( lblciudad ) ; lblcif = new jlabel ( "contrase\xf1a: " ) ; lblcif . setbounds ( 10 , 36 , 100 , 14 ) ; paneljugador . add ( lblcif ) ; lblcodigopostal = new jlabel ( "fecha nacimiento: " ) ; lblcodigopostal . setbounds ( 10 , 111 , 100 , 14 ) ; paneljugador . add ( lblcodigopostal ) ; txtpaisjugador = new jtextfield ( ) ; txtpaisjugador . seteditable ( false ) ; txtpaisjugador . setbounds ( 117 , 83 , 100 , 20 ) ; paneljugador . add ( txtpaisjugador ) ; txtpaisjugador . setcolumns ( 10 ) ; txtcorreojugador = new jtextfield ( ) ; txtcorreojugador . seteditable ( false ) ; txtcorreojugador . setbounds ( 117 , 58 , 100 , 20 ) ; paneljugador . add ( txtcorreojugador ) ; txtcorreojugador . setcolumns ( 10 ) ; txtcontrasenajugador = new jtextfield ( ) ; txtcontrasenajugador . seteditable ( false ) ; txtcontrasenajugador . setbounds ( 117 , 33 , 100 , 20 ) ; paneljugador . add ( txtcontrasenajugador ) ; txtcontrasenajugador . setcolumns ( 10 ) ; txtusuariojugador = new jtextfield ( ) ; txtusuariojugador . seteditable ( false ) ; txtusuariojugador . setbounds ( 117 , 8 , 100 , 20 ) ; paneljugador . add ( txtusuariojugador ) ; txtusuariojugador . setcolumns ( 10 ) ; scrollpane = new jscrollpane ( ) ; scrollpane . setbounds ( 227 , 35 , 250 , 195 ) ; paneljugador . add ( scrollpane ) ; tablajugadores = new tablajugadores ( ) ; tablajugadores . addkeylistener ( new keyadapter ( ) { @ override public void keyreleased ( keyevent e ) { } } ) ; tablajugadores . addmouselistener ( new mouseadapter ( ) { @ override public void mouseclicked ( mouseevent e ) { jugadorseleccionado ( ) ; } } ) ; scrollpane . setviewportview ( tablajugadores ) ; btcancelarjugador = new jbutton ( "cancelar" ) ; btcancelarjugador . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent e ) { cancelarjugador ( ) ; } } ) ; btcancelarjugador . setenabled ( false ) ; btcancelarjugador . setbounds ( 10 , 170 , 86 , 23 ) ; paneljugador . add ( btcancelarjugador ) ; btinsertarjugador = new jbutton ( "insertar" ) ; btinsertarjugador . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent e ) { insertarjugador ( ) ; } } ) ; btinsertarjugador . setenabled ( false ) ; btinsertarjugador . setbounds ( 120 , 136 , 86 , 23 ) ; paneljugador . add ( btinsertarjugador ) ; btnuevojugador = new jbutton ( "nuevo" ) ; btnuevojugador . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent arg0 ) { nuevojugador ( ) ; } } ) ; btnuevojugador . setbounds ( 10 , 136 , 86 , 23 ) ; paneljugador . add ( btnuevojugador ) ; btmodificarjugador = new jbutton ( "modificar" ) ; btmodificarjugador . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent arg0 ) { modificarjugador ( ) ; } } ) ; btmodificarjugador . setenabled ( false ) ; btmodificarjugador . setbounds ( 227 , 241 , 107 , 23 ) ; paneljugador . add ( btmodificarjugador ) ; bteliminarjugador = new jbutton ( "eliminar" ) ; bteliminarjugador . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent arg0 ) { eliminarjugador ( ) ; } } ) ; bteliminarjugador . setenabled ( false ) ; bteliminarjugador . setbounds ( 357 , 241 , 107 , 23 ) ; paneljugador . add ( bteliminarjugador ) ; datejugador = new jdatechooser ( ) ; datejugador . setenabled ( false ) ; datejugador . getcalendarbutton ( ) . setenabled ( false ) ; datejugador . setbounds ( 116 , 105 , 101 , 20 ) ; paneljugador . add ( datejugador ) ; lblbuscar = new jlabel ( "buscar: " ) ; lblbuscar . setbounds ( 227 , 12 , 52 , 14 ) ; paneljugador . add ( lblbuscar ) ; txtbuscarjugador = new jtextfield ( ) ; txtbuscarjugador . addkeylistener ( new keyadapter ( ) { @ override public void keyreleased ( keyevent arg0 ) { buscarjugador ( ) ; } } ) ; txtbuscarjugador . setbounds ( 278 , 8 , 111 , 20 ) ; paneljugador . add ( txtbuscarjugador ) ; txtbuscarjugador . setcolumns ( 10 ) ; btlimpiarjugador = new jbutton ( "limpiar" ) ; btlimpiarjugador . setenabled ( false ) ; btlimpiarjugador . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent arg0 ) { limpiarjugador ( ) ; } } ) ; btlimpiarjugador . setbounds ( 399 , 7 , 78 , 23 ) ; paneljugador . add ( btlimpiarjugador ) ; panelpersonaje = new jpanel ( ) ; tabbedpane . addtab ( "personaje" , null , panelpersonaje , null ) ; panelpersonaje . setlayout ( null ) ; lblnombre_1 = new jlabel ( "nombre: " ) ; lblnombre_1 . setbounds ( 10 , 11 , 75 , 14 ) ; panelpersonaje . add ( lblnombre_1 ) ; lbldescripcion = new jlabel ( "fecha" ) ; lbldescripcion . setbounds ( 10 , 36 , 75 , 14 ) ; panelpersonaje . add ( lbldescripcion ) ; lblfechainicio = new jlabel ( "clase: " ) ; lblfechainicio . setbounds ( 10 , 61 , 75 , 14 ) ; panelpersonaje . add ( lblfechainicio ) ; lblfechaentrega = new jlabel ( "raza:" ) ; lblfechaentrega . setbounds ( 10 , 86 , 75 , 14 ) ; panelpersonaje . add ( lblfechaentrega ) ; lblempresa = new jlabel ( "usuario:" ) ; lblempresa . setbounds ( 10 , 111 , 75 , 14 ) ; panelpersonaje . add ( lblempresa ) ; txtnombrepersonaje = new jtextfield ( ) ; txtnombrepersonaje . seteditable ( false ) ; txtnombrepersonaje . setbounds ( 96 , 8 , 123 , 20 ) ; panelpersonaje . add ( txtnombrepersonaje ) ; txtnombrepersonaje . setcolumns ( 10 ) ; btnuevopersonaje = new jbutton ( "nuevo" ) ; btnuevopersonaje . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent arg0 ) { nuevopersonaje ( ) ; } } ) ; btnuevopersonaje . setbounds ( 10 , 136 , 86 , 23 ) ; panelpersonaje . add ( btnuevopersonaje ) ; btcancelarpersonaje = new jbutton ( "cancelar" ) ; btcancelarpersonaje . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent e ) { cancelarpersonaje ( ) ; } } ) ; btcancelarpersonaje . setenabled ( false ) ; btcancelarpersonaje . setbounds ( 10 , 170 , 86 , 23 ) ; panelpersonaje . add ( btcancelarpersonaje ) ; btinsertarpersonaje = new jbutton ( "insertar" ) ; btinsertarpersonaje . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent e ) { insertarpersonaje ( ) ; } } ) ; btinsertarpersonaje . setenabled ( false ) ; btinsertarpersonaje . setbounds ( 116 , 136 , 86 , 23 ) ; panelpersonaje . add ( btinsertarpersonaje ) ; scrollpane_1 = new jscrollpane ( ) ; scrollpane_1 . setbounds ( 229 , 36 , 248 , 198 ) ; panelpersonaje . add ( scrollpane_1 ) ; tablapersonajes = new tablapersonajes ( ) ; tablapersonajes . addkeylistener ( new keyadapter ( ) { @ override public void keyreleased ( keyevent e ) { } } ) ; tablapersonajes . addmouselistener ( new mouseadapter ( ) { @ override public void mouseclicked ( mouseevent arg0 ) { personajeseleccionado ( ) ; } } ) ; scrollpane_1 . setviewportview ( tablapersonajes ) ; btmodificarpersonaje = new jbutton ( "modificar" ) ; btmodificarpersonaje . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent e ) { modificarpersonaje ( ) ; } } ) ; btmodificarpersonaje . setenabled ( false ) ; btmodificarpersonaje . setbounds ( 238 , 245 , 105 , 23 ) ; panelpersonaje . add ( btmodificarpersonaje ) ; bteliminarpersonaje = new jbutton ( "eliminar" ) ; bteliminarpersonaje . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent arg0 ) { eliminarpersonaje ( ) ; } } ) ; bteliminarpersonaje . setenabled ( false ) ; bteliminarpersonaje . setbounds ( 365 , 245 , 112 , 23 ) ; panelpersonaje . add ( bteliminarpersonaje ) ; cbclasepersonaje = new jcombobox ( ) ; cbclasepersonaje . setenabled ( false ) ; cbclasepersonaje . setbounds ( 96 , 57 , 123 , 22 ) ; for ( int i = 0 ; i < clases . length ; i ++ ) { cbclasepersonaje . additem ( clases [ i ] ) ; } panelpersonaje . add ( cbclasepersonaje ) ; cbrazapersonaje = new jcombobox ( ) ; cbrazapersonaje . setenabled ( false ) ; cbrazapersonaje . setbounds ( 96 , 82 , 123 , 22 ) ; for ( int i = 0 ; i < razas . length ; i ++ ) { cbrazapersonaje . additem ( razas [ i ] ) ; } panelpersonaje . add ( cbrazapersonaje ) ; datepersonaje = new jdatechooser ( ) ; datepersonaje . setenabled ( false ) ; datepersonaje . getcalendarbutton ( ) . setenabled ( false ) ; datepersonaje . setbounds ( 95 , 30 , 124 , 20 ) ; panelpersonaje . add ( datepersonaje ) ; cbjugadorpersonaje = new combojugadores ( ) ; cbjugadorpersonaje . setenabled ( false ) ; cbjugadorpersonaje . setbounds ( 95 , 107 , 124 , 22 ) ; panelpersonaje . add ( cbjugadorpersonaje ) ; label = new jlabel ( "buscar: " ) ; label . setbounds ( 229 , 11 , 49 , 14 ) ; panelpersonaje . add ( label ) ; txtbuscarpersonaje = new jtextfield ( ) ; txtbuscarpersonaje . addkeylistener ( new keyadapter ( ) { @ override public void keyreleased ( keyevent e ) { buscarpersonaje ( ) ; } } ) ; txtbuscarpersonaje . setcolumns ( 10 ) ; txtbuscarpersonaje . setbounds ( 288 , 8 , 97 , 20 ) ; panelpersonaje . add ( txtbuscarpersonaje ) ; btlimpiarpersonaje = new jbutton ( "limpiar" ) ; btlimpiarpersonaje . setenabled ( false ) ; btlimpiarpersonaje . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent e ) { limpiarpersonaje ( ) ; } } ) ; btlimpiarpersonaje . setbounds ( 391 , 7 , 86 , 23 ) ; panelpersonaje . add ( btlimpiarpersonaje ) ; panelbatalla = new jpanel ( ) ; tabbedpane . addtab ( "batalla" , null , panelbatalla , null ) ; panelbatalla . setlayout ( null ) ; lblnombre_2 = new jlabel ( "duracion: " ) ; lblnombre_2 . setbounds ( 10 , 36 , 91 , 14 ) ; panelbatalla . add ( lblnombre_2 ) ; lblapellido = new jlabel ( "historial: " ) ; lblapellido . setbounds ( 10 , 61 , 91 , 14 ) ; panelbatalla . add ( lblapellido ) ; lblnacionalidad = new jlabel ( "fecha: " ) ; lblnacionalidad . setbounds ( 10 , 11 , 91 , 14 ) ; panelbatalla . add ( lblnacionalidad ) ; lblfechanacimiento = new jlabel ( "atacante: " ) ; lblfechanacimiento . setbounds ( 10 , 86 , 91 , 14 ) ; panelbatalla . add ( lblfechanacimiento ) ; lblnewlabel = new jlabel ( "defensor: " ) ; lblnewlabel . setbounds ( 10 , 111 , 91 , 14 ) ; panelbatalla . add ( lblnewlabel ) ; btinsertarbatalla = new jbutton ( "insertar" ) ; btinsertarbatalla . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent e ) { insertarbatalla ( ) ; } } ) ; btinsertarbatalla . setenabled ( false ) ; btinsertarbatalla . setbounds ( 111 , 139 , 86 , 23 ) ; panelbatalla . add ( btinsertarbatalla ) ; btnuevobatalla = new jbutton ( "nuevo" ) ; btnuevobatalla . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent e ) { nuevobatalla ( ) ; } } ) ; btnuevobatalla . setbounds ( 10 , 139 , 91 , 23 ) ; panelbatalla . add ( btnuevobatalla ) ; btcancelarbatalla = new jbutton ( "cancelar" ) ; btcancelarbatalla . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent e ) { cancelarbatalla ( ) ; } } ) ; btcancelarbatalla . setenabled ( false ) ; btcancelarbatalla . setbounds ( 10 , 171 , 91 , 23 ) ; panelbatalla . add ( btcancelarbatalla ) ; scrollpane_2 = new jscrollpane ( ) ; scrollpane_2 . setbounds ( 231 , 36 , 246 , 201 ) ; panelbatalla . add ( scrollpane_2 ) ; tablabatallas = new tablabatallas ( ) ; tablabatallas . addkeylistener ( new keyadapter ( ) { @ override public void keyreleased ( keyevent e ) { } } ) ; tablabatallas . addmouselistener ( new mouseadapter ( ) { @ override public void mouseclicked ( mouseevent e ) { batallaseleccionado ( ) ; } } ) ; scrollpane_2 . setviewportview ( tablabatallas ) ; btmodificarbatalla = new jbutton ( "modificar" ) ; btmodificarbatalla . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent e ) { modificarbatalla ( ) ; } } ) ; btmodificarbatalla . setenabled ( false ) ; btmodificarbatalla . setbounds ( 231 , 248 , 120 , 23 ) ; panelbatalla . add ( btmodificarbatalla ) ; bteliminarbatalla = new jbutton ( "eliminar" ) ; bteliminarbatalla . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent arg0 ) { eliminarbatalla ( ) ; } } ) ; bteliminarbatalla . setenabled ( false ) ; bteliminarbatalla . setbounds ( 361 , 248 , 116 , 23 ) ; panelbatalla . add ( bteliminarbatalla ) ; txtduracionbatalla = new jtextfield ( ) ; txtduracionbatalla . seteditable ( false ) ; txtduracionbatalla . setbounds ( 98 , 33 , 123 , 20 ) ; panelbatalla . add ( txtduracionbatalla ) ; txtduracionbatalla . setcolumns ( 10 ) ; txthistorialbatalla = new jtextfield ( ) ; txthistorialbatalla . seteditable ( false ) ; txthistorialbatalla . setbounds ( 98 , 58 , 123 , 20 ) ; panelbatalla . add ( txthistorialbatalla ) ; txthistorialbatalla . setcolumns ( 10 ) ; datebatalla = new jdatechooser ( ) ; datebatalla . setenabled ( false ) ; datebatalla . getcalendarbutton ( ) . setenabled ( false ) ; datebatalla . setbounds ( 98 , 5 , 123 , 20 ) ; panelbatalla . add ( datebatalla ) ; cbatacantebatalla = new combojugadores ( ) ; cbatacantebatalla . setenabled ( false ) ; cbatacantebatalla . setbounds ( 98 , 82 , 123 , 22 ) ; panelbatalla . add ( cbatacantebatalla ) ; cbdefensorbatalla = new combojugadores ( ) ; cbdefensorbatalla . setenabled ( false ) ; cbdefensorbatalla . setbounds ( 98 , 107 , 123 , 22 ) ; panelbatalla . add ( cbdefensorbatalla ) ; label_1 = new jlabel ( "buscar: " ) ; label_1 . setbounds ( 231 , 11 , 49 , 14 ) ; panelbatalla . add ( label_1 ) ; txtbuscarbatalla = new jtextfield ( ) ; txtbuscarbatalla . addkeylistener ( new keyadapter ( ) { @ override public void keyreleased ( keyevent e ) { buscarbatalla ( ) ; } } ) ; txtbuscarbatalla . setcolumns ( 10 ) ; txtbuscarbatalla . setbounds ( 290 , 8 , 97 , 20 ) ; panelbatalla . add ( txtbuscarbatalla ) ; btlimpiarbatalla = new jbutton ( "limpiar" ) ; btlimpiarbatalla . setenabled ( false ) ; btlimpiarbatalla . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent e ) { limpiarbatalla ( ) ; } } ) ; btlimpiarbatalla . setbounds ( 391 , 7 , 86 , 23 ) ; panelbatalla . add ( btlimpiarbatalla ) ; menubar = new jmenubar ( ) ; frame . setjmenubar ( menubar ) ; mnarchivo = new jmenu ( "archivo" ) ; menubar . add ( mnarchivo ) ; mntmcerrarsesion = new jmenuitem ( "cerrar sesion" ) ; mntmcerrarsesion . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent e ) { inicializar ( ) ; } } ) ; mnarchivo . add ( mntmcerrarsesion ) ; mntmconectar = new jmenuitem ( "conectar" ) ; mntmconectar . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent e ) { conectar ( ) ; } } ) ; mnarchivo . add ( mntmconectar ) ; mntmdesconectar = new jmenuitem ( "desconectar" ) ; mntmdesconectar . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent e ) { cancelarjugador ( ) ; mntmdesconectar . setenabled ( false ) ; mntmconectar . setenabled ( true ) ; btnuevojugador . setenabled ( false ) ; txtbuscarjugador . setenabled ( false ) ; try { conexion . close ( ) ; tablajugadores . conectar ( conexion ) ; tablajugadores . listar ( ) ; joptionpane . showmessagedialog ( null , "se ha desconectado de la base de datos" ) ; } catch ( sqlexception sqle ) { sqle . printstacktrace ( ) ; } } } ) ; mnarchivo . add ( mntmdesconectar ) ; mnperferencias = new jmenu ( "preferencias" ) ; menubar . add ( mnperferencias ) ; mntmconfiguracion = new jmenuitem ( "configuracion" ) ; mntmconfiguracion . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent e ) { configuracion configuracion = new configuracion ( ) ; configuracion . mostrarconfiguracion ( ) ; conectar ( ) ; } } ) ; mnperferencias . add ( mntmconfiguracion ) ; }
tr	7	public boolean addaction ( combatant combatant , list < action > actionsinplay , action action , list < action > possibleactions ) { if ( action != null ) { possibleactions . remove ( action ) ; if ( action . getactions ( ) == 0 ) { actionsinplay . add ( action ) ; return true ; } for ( int i = 0 ; i < action . getactions ( ) ; i ++ ) { action clone ; try { clone = ( action ) beanutils . clonebean ( action ) ; clone . setnoaction ( i + 1 < clone . getactions ( ) ) ; combatant . addaction ( clone , round + i ) ; } catch ( illegalaccessexception | instantiationexception | invocationtargetexception | nosuchmethodexception e ) { e . printstacktrace ( ) ; } } } return false ; }
tr	1	public void setlineend ( final string lineend ) { this . lineend = lineend ; }
tr	9	public static list < message > parsemessages ( string resultstring ) { list < message > messages = new arraylist < message > ( ) ; jsonobject base ; try { base = new jsonobject ( resultstring ) ; int retcode = base . optint ( "retcode" , - 1 ) ; if ( retcode == 0 ) { jsonarray messagearray = base . optjsonarray ( "result" ) ; for ( int i = 0 ; i < messagearray . length ( ) ; i ++ ) { message message = message . newentity ( messagearray . optjsonobject ( i ) ) ; if ( message != null ) { messages . add ( message ) ; } } } else if ( retcode == 100 ) { } else if ( retcode == 120 ) { } else if ( retcode == 121 ) { } else if ( retcode == 116 ) { bot . getinstance ( ) . setptwebqq ( base . optstring ( "p" ) ) ; } } catch ( jsonexception e ) { e . printstacktrace ( ) ; } return messages ; }
tr	3	public void loadfromstream ( inputstream in , collection < abstractoption > options , boolean suppressconversionerrors ) throws optionsexception { final map < string , string > properties = loadpropertiesfromstream ( in ) ; final collection < string > conversionerrors = tryconvertingstringstovalues ( options , properties ) ; if ( ! conversionerrors . isempty ( ) && ! suppressconversionerrors ) throw new conversionexception ( "error converting option values from options file: " + optionsfile . getabsolutepath ( ) + ": " + conversionerrors , conversionerrors ) ; assignstringvalues ( options , properties ) ; }
tr	6	public static void main ( string [ ] args ) { char index ; index = 'a' ; switch ( index ) { case 'a' : system . out . println ( "sangat baik" ) ; break ; case 'b' : system . out . println ( "baik" ) ; break ; case 'c' : system . out . println ( "cukup" ) ; break ; case 'd' : system . out . println ( "kurang" ) ; break ; case 'e' : system . out . println ( "sangat kurang" ) ; break ; default : system . out . println ( "tidak terdefinisi" ) ; } }
tr	10	@ override public string execute ( string s ) { if ( s . matches ( "prendre.* (roche|cliff)" ) && utiliserlampe && ! pritroche ) { pritroche = true ; inventorymanager . getinstance ( ) . additem ( "cliff" ) ; return "vous prenez la roche." ; } else if ( s . matches ( "(utiliser|allumer).* lampe de poche" ) ) { utiliserlampe = true ; return "il fait maintenant clair." ; } else if ( s . matches ( "utiliser.* cliff" ) && pritroche && ! utiliserroche ) { utiliserroche = true ; levelmanager . getinstance ( ) . notifycurrentlevel ( "outofsurplomb" ) ; return "vous lancez la roche dans le mur de planches.\\n" + "roche : aaaaaaaaaoutch!\\n" + "etrange... vous reprenez cliff." ; } else if ( s . matches ( "oui" ) && veuttomber ) { levelmanager . getinstance ( ) . notifycurrentlevel ( "estmort" ) ; return null ; } return null ; }
tr	4	public loopupordown ( int min , int max ) { change = ( math . random ( ) >= 0.5 ? 1 : - 1 ) ; if ( change > 0 ) { index = min - 1 ; end = max + 1 ; } else { index = max + 1 ; end = min - 1 ; } }
tr	1	public double getratelimit ( ) { return mratelimit ; }
tr	9	public void menuaction ( jmenu selectmenu ) { mainframe mainframe = mainframe . getinstance ( ) ; attdframe workingframe = mainframe . getcurrentframe ( ) ; workingframe . setvisible ( false ) ; for ( int i = 0 ; i < menu . length ; i ++ ) { if ( menu [ i ] . equals ( selectmenu ) ) { switch ( i ) { case 0 : mainframe . setcurrentframeeditcourse ( ) ; break ; case 1 : mainframe . setcurrentframeeditstudent ( ) ; break ; case 2 : mainframe . setcurrentframecourseenroll ( ) ; break ; case 3 : mainframe . setcurrentframeattendance ( ) ; break ; case 4 : mainframe . setcurrentframeshowclassar ( ) ; break ; case 5 : mainframe . setcurrentframeshowclassrp ( ) ; break ; default : break ; } break ; } } workingframe = mainframe . getcurrentframe ( ) ; workingframe . display ( ) ; }
tr	6	public static void main ( string [ ] args ) { locale . setdefault ( locale . root ) ; scanner scanner = new scanner ( system . in ) ; system . out . print ( "enter a whole positive number for count of numbers in sequence: " ) ; int count = scanner . nextint ( ) ; if ( count > 0 ) { int minnum = integer . max_value ; int maxnum = integer . min_value ; long sumnums = 0 ; for ( int i = 0 ; i < count ; i ++ ) { system . out . print ( "enter next integer number of sequence: " ) ; int number = scanner . nextint ( ) ; sumnums += number ; if ( number < minnum ) { minnum = number ; } if ( number > maxnum ) { maxnum = number ; } } scanner . close ( ) ; system . out . printf ( "min = %d\\nmax = %d\\nsum = %d\\n" , minnum , maxnum , sumnums ) ; system . out . printf ( "avg = %.2f\\n" , ( sumnums / ( double ) count ) ) ; } else { scanner . close ( ) ; system . out . println ( "error! - invalid input number!!!" ) ; } }
tr	7	public static set gettableset ( final criteria crit , final tablecallback tablecallback ) { hashset tables = new hashset ( ) ; for ( iterator it = crit . keyset ( ) . iterator ( ) ; it . hasnext ( ) ; ) { string key = ( string ) it . next ( ) ; criteria . criterion c = crit . getcriterion ( key ) ; list tablenames = c . getalltables ( ) ; for ( iterator it2 = tablenames . iterator ( ) ; it2 . hasnext ( ) ; ) { string name = ( string ) it2 . next ( ) ; string aliasname = crit . gettableforalias ( name ) ; if ( stringutils . isnotempty ( aliasname ) ) { string newname = new stringbuffer ( name . length ( ) + aliasname . length ( ) + 4 ) . append ( aliasname ) . append ( " as " ) . append ( name ) . tostring ( ) ; name = newname ; } tables . add ( name ) ; } if ( tablecallback != null ) { tablecallback . process ( tables , key , crit ) ; } } return tables ; }
tr	2	private url buildurl ( final map < string , string > parameters ) throws malformedurlexception { final list < string > parameterstrings = new arraylist < > ( parameters . size ( ) ) ; for ( final map . entry < string , string > entry : parameters . entryset ( ) ) { parameterstrings . add ( entry . getkey ( ) + "=" + entry . getvalue ( ) ) ; } return new url ( baseurl + "/datalink?" + joiner . on ( "&" ) . join ( parameterstrings ) ) ; }
tr	3	public static piecetype getpiecetype ( char label ) { for ( piecetype p : piecetype . values ( ) ) { if ( character . touppercase ( label ) == p . label ) return p ; } throw new illegalargumentexception ( "no such label" ) ; }
tr	8	static private double rint ( double x ) { final double biggest = biggest ; double tmp ; if ( x != x ) return x ; if ( java . lang . math . abs ( x ) >= biggest ) return x ; if ( x >= 0 ) { tmp = x + biggest ; return tmp - biggest ; } else { tmp = x - biggest ; return tmp + biggest ; } }
tr	1	public string getbuysell ( ) { return mbuysell ; }
tr	9	@ override public string tostring ( ) { stringbuilder sb = new stringbuilder ( ) ; sb . append ( "{" ) ; linkedlist < treenode > queue = new linkedlist < > ( ) ; queue . add ( this ) ; while ( ! queue . isempty ( ) ) { treenode curr = queue . pop ( ) ; if ( curr == null ) { sb . append ( nulltree ) . append ( "<litcomma>" ) ; } else { sb . append ( curr . val ) . append ( "<litcomma>" ) ; queue . add ( curr . left ) ; queue . add ( curr . right ) ; } } string toprocess = sb . tostring ( ) ; while ( toprocess . endswith ( nulltree ) || toprocess . endswith ( "<litcomma>" ) ) { toprocess = toprocess . substring ( 0 , toprocess . length ( ) - 1 ) ; } toprocess += "}" ; return toprocess ; }
tr	10	public dicview ( arraylist < data > d ) { initcomponents ( ) ; defaulttablemodel tm = ( defaulttablemodel ) dic . getmodel ( ) ; tm . setrowcount ( d . size ( ) ) ; int i ; for ( i = 0 ; i < 3 ; i ++ ) { for ( int j = 0 ; j < d . size ( ) ; j ++ ) { if ( i == 0 ) { tm . setvalueat ( d . get ( j ) . name , j , i ) ; } if ( i == 1 ) { tm . setvalueat ( d . get ( j ) . type , j , i ) ; } if ( i == 2 ) { tm . setvalueat ( d . get ( j ) . description , j , i ) ; } } } }
tr	10	@ override public boolean equals ( object object ) { if ( ! ( object instanceof restaurantreservation ) ) { return false ; } restaurantreservation other = ( restaurantreservation ) object ; if ( ( this . getid ( ) == null && other . getid ( ) != null ) || ( this . getid ( ) != null && ! this . id . equals ( other . id ) ) ) { return false ; } return true ; }
tr	7	@ override public < a extends annotation > object getvalue ( class < a > type , string name ) { try { method valuemethod = type . getmethod ( name ) ; if ( ! annotationvalues . containskey ( valuemethod ) ) { try { a annotation = executor . getclass ( ) . getmethod ( "invoke" , functioninvocation . class , object [ ] . class ) . getannotation ( type ) ; if ( annotation != null ) { object value = valuemethod . invoke ( annotation ) ; annotationvalues . put ( valuemethod , value ) ; return value ; } } catch ( nosuchmethodexception e ) { logger . log ( level . severe , "programmer's fault: can't find invoke() method (should be defined by interface)" , e ) ; } catch ( illegalaccessexception e ) { logger . log ( level . severe , "no access to annotation method because it's not public; what the ... ?" , e ) ; } catch ( invocationtargetexception e ) { logger . log ( level . severe , "can't invoke annotation method" , e ) ; } object value = valuemethod . getdefaultvalue ( ) ; annotationvalues . put ( valuemethod , value ) ; return value ; } return annotationvalues . get ( valuemethod ) ; } catch ( nosuchmethodexception e ) { logger . log ( level . warning , "tried to access not existing annotation method for getting annotation value" , e ) ; return null ; } }
tr	5	private void connectionsetup ( ) throws genericconnectionexception , ioexception { checkconntypevalidity ( ) ; checkcredentialsvalidity ( ) ; try { if ( selectedconntype . equals ( conn_rmi ) ) { } else if ( selectedconntype . equals ( conn_rmi ) ) { mybackend = new socketbackendcommunication ( gethost ( ) , getport ( ) ) ; } else if ( selectedconntype . equals ( conn_local ) ) { } } catch ( ioexception e ) { system . out . println ( "[clientinterface] ioexception while trying to open connection!" ) ; throw new ioexception ( "[clientinterface] ioexcception mentre tentavo di aprire la connessione!" ) ; } }
tr	3	public static xmlpullparserfactory factorynewinstance ( ) throws xmlpullparserexception { string property = system . getproperty ( xmlpullparserfactory . property_name ) ; xmlpullparserfactory factory = xmlpullparserfactory . newinstance ( property , null ) ; if ( packagetests . runnigalltests ( ) == false && printedfactoryname == false ) { system . out . println ( "factory=" + factory + " property=" + property ) ; printedfactoryname = true ; } return factory ; }
tr	9	public void execute ( ) throws atomsqlexception { atomsequelcommands _commandset ; string _sqlstatement ; arraylist < integer > _columnlist ; arraylist < atomsqlcommand > _commands ; atomsqlcommand _command ; stringbuffer _result ; int _index = 0 ; int _countcommands ; _commandset = this . commandset ; _commands = _commandset . getcommandlist ( ) ; _countcommands = _commands . size ( ) ; this . results . append ( "*******************************************************\\n" ) ; this . results . append ( "started processing sql statements on server :" ) ; this . results . append ( this . serverip ) ; this . results . append ( "\\n" ) ; this . results . append ( "*******************************************************\\n" ) ; while ( _countcommands > _index ) { _command = _commands . get ( _index ) ; _sqlstatement = _command . getsqltstatement ( ) ; _columnlist = _command . getcolumnnos ( ) ; this . results . append ( "executing :" ) ; this . results . append ( _sqlstatement ) ; this . results . append ( "\\n" ) ; this . results . append ( "+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\\n" ) ; try { _result = executequery ( _sqlstatement , _columnlist ) ; this . results . append ( _result ) ; } catch ( atomsqlexception e ) { this . results . append ( e . getcustommessage ( ) ) ; } this . results . append ( "+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\\n" ) ; _index ++ ; } if ( this . connection != null ) { try { this . connection . close ( ) ; } catch ( sqlexception e ) { atomsqlexception _sqlexception = new atomsqlexception ( e ) ; _sqlexception . setcustommessage ( "failed while closing connection" ) ; throw _sqlexception ; } } }
tr	9	public void drop ( droptargetdropevent e ) { try { dataflavor stringflavor = dataflavor . stringflavor ; transferable tr = e . gettransferable ( ) ; if ( e . isdataflavorsupported ( stringflavor ) ) { string filename = ( string ) tr . gettransferdata ( stringflavor ) ; if ( filename . endswith ( ".txt" ) || filename . endswith ( ".java" ) || filename . endswith ( ".jsp" ) || filename . endswith ( ".html" ) || filename . endswith ( ".htm" ) ) { e . acceptdrop ( dndconstants . action_copy_or_move ) ; readfile ( filename ) ; textpane . setcaretposition ( 0 ) ; e . dropcomplete ( true ) ; } else { e . rejectdrop ( ) ; } } else { e . rejectdrop ( ) ; } } catch ( ioexception ioe ) { ioe . printstacktrace ( ) ; } catch ( unsupportedflavorexception ufe ) { ufe . printstacktrace ( ) ; } }
tr	9	private static void generatetrackercontext ( configuration conf , jobid jobid ) { int totalnummappers = tasktrackercomms . size ( ) * conf . getnummapper ( ) ; int offsetdelta = 0 ; for ( int i = 0 ; i < tasktrackercomms . size ( ) ; i ++ ) { tasktrackercontext context = tasktrackercontexts . get ( i ) ; list < mapbasiccontext > maptasklist = new arraylist < mapbasiccontext > ( ) ; list < reducebasiccontext > reducetasklist = new arraylist < reducebasiccontext > ( ) ; string inputfile = conf . getinputfilename ( ) ; file file = new file ( inputfile ) ; string fsinputfile = putinputfile ( inputfile ) ; jzfile filejz = new jzfile ( jzfile . jzfilesystem , fsinputfile , file . length ( ) ) ; int delta = ( int ) ( file . length ( ) / totalnummappers ) ; for ( int j = 0 ; j < conf . getnummapper ( ) ; j ++ ) { taskid taskid = new taskid ( jobid , tasktype . mapper_t , j , 0 ) ; iinputsplit split ; if ( ( j == conf . getnummapper ( ) - 1 ) && ( i == tasktrackercomms . size ( ) - 1 ) ) { split = new filesplit ( filejz , offsetdelta , file . length ( ) - offsetdelta ) ; } else { split = new filesplit ( filejz , offsetdelta , delta ) ; } mapbasiccontext basiccontext = new mapbasiccontext ( conf , taskid , split ) ; maptasklist . add ( basiccontext ) ; offsetdelta += delta ; } context . jobmappers . put ( jobid . getid ( ) , maptasklist ) ; for ( int j = 0 ; j < conf . getnumreducers ( ) ; j ++ ) { taskid taskid = new taskid ( jobid , tasktype . reducer_t , i * conf . getnumreducers ( ) + j , 0 ) ; reducebasiccontext basiccontext = new reducebasiccontext ( conf , taskid ) ; reducetasklist . add ( basiccontext ) ; } context . jobreducers . put ( jobid . getid ( ) , reducetasklist ) ; } }
tr	5	public gameobject getobject ( int x , int y ) { if ( x >= realm . world_width || y >= realm . world_height || x < 0 || y < 0 ) { return null ; } return scenobjects [ x ] [ y ] ; }
tr	10	protected void dopost ( httpservletrequest request , httpservletresponse response ) throws servletexception , ioexception { string painallus = request . getparameter ( "nappi" ) ; if ( painallus . equals ( "paistettavat" ) ) { string paisto = request . getparameter ( "merkitsepaisto" ) ; int paistoid = integer . parseint ( paisto ) ; try { tilausdao tdao = new tilausdao ( ) ; tdao . merkitsepaistetuksi ( paistoid ) ; } catch ( daopoikkeus e ) { throw new servletexception ( e ) ; } catch ( sqlexception e ) { e . printstacktrace ( ) ; } response . sendredirect ( "tilaukset?paistettu=true" ) ; } else if ( painallus . equals ( "toimitettavat" ) ) { if ( request . getparameter ( "peruutapaisto" ) != null ) { string peruutus = request . getparameter ( "peruutapaisto" ) ; int peruutusid = integer . parseint ( peruutus ) ; try { tilausdao tdao = new tilausdao ( ) ; tdao . peruutapaistomerkinta ( peruutusid ) ; } catch ( daopoikkeus e ) { throw new servletexception ( e ) ; } catch ( sqlexception e ) { e . printstacktrace ( ) ; } response . sendredirect ( "tilaukset?peruutettu=true" ) ; } else { string paisto = request . getparameter ( "merkitsetoimitus" ) ; int toimitusid = integer . parseint ( paisto ) ; try { tilausdao tdao = new tilausdao ( ) ; tdao . merkitsetoimitetuksi ( toimitusid ) ; } catch ( daopoikkeus e ) { throw new servletexception ( e ) ; } catch ( sqlexception e ) { e . printstacktrace ( ) ; } response . sendredirect ( "tilaukset?toimitettu=true" ) ; } } }
tr	6	public static arraylist < file > getfilesonly ( final file [ ] files ) { if ( files == null ) { return null ; } final arraylist < file > filearray = new arraylist < file > ( ) ; for ( final file file : files ) { if ( file . isdirectory ( ) ) { filearray . addall ( getfilesonly ( getfilesfromdir ( file . getabsolutepath ( ) ) ) ) ; } else { filearray . add ( file ) ; } } return filearray ; }
tr	9	public static void main ( string [ ] args ) { int [ ] [ ] num_std ; int [ ] tfac ; int i , j , total = 0 ; num_std = new int [ 2 ] [ 4 ] ; tfac = new int [ 2 ] ; scanner scan = new scanner ( system . in ) ; for ( i = 0 ; i < 2 ; i ++ ) { system . out . println ( "enter total student in faculty " + ( i + 1 ) + " : " ) ; tfac [ i ] = 0 ; for ( j = 0 ; j < 4 ; j ++ ) { system . out . print ( "year " + ( j + 1 ) + " = " ) ; num_std [ i ] [ j ] = scan . nextint ( ) ; tfac [ i ] = tfac [ i ] + num_std [ i ] [ j ] ; } total = total + tfac [ i ] ; } for ( i = 0 ; i < 2 ; i ++ ) { system . out . print ( "=============================================\\n" ) ; for ( j = 0 ; j < 4 ; j ++ ) { system . out . println ( "student in year " + ( j + 1 ) + " = " + num_std [ i ] [ j ] ) ; } system . out . println ( "student in faculty " + ( i + 1 ) + " = " + tfac [ i ] ) ; } system . out . println ( "total students = " + total ) ; }
tr	4	static public void collectspellstats ( statmap stats , statalloc [ ] statallocs , int playerlevel , int scalinglevelmin , int scalinglevelmax , int scalingid ) { if ( statallocs != null ) { int lvl = playerscaling . max ( scalinglevelmax , playerlevel ) ; float scaling = playerscaling . get ( math . max ( scalinglevelmin , lvl ) , scalingid ) ; for ( statalloc x : statallocs ) { if ( x . mod == 0 ) { stats . add ( x . stat , x . alloc ) ; } else { int value = ( int ) ( 0.5 + scaling * x . mod ) ; stats . add ( x . stat , value ) ; } } } }
tr	4	private void appendpathindent ( final appendable sb , final int level ) throws ioexception { for ( int i = 0 ; i < ( level - 1 ) ; ++ i ) { sb . append ( callindentation ) ; } if ( level > 0 ) { sb . append ( leafnameprefix ) ; } }
tr	2	public void stop ( ) { eof = true ; synchronized ( this ) { notify ( ) ; } if ( instream != null ) instream . close ( ) ; }
tr	4	void setnormal ( ) { if ( numpoints < 3 ) return ; vector3d [ ] ps = new vector3d [ 3 ] ; for ( int i = 0 ; i < 3 ; i ++ ) ps [ i ] = object3d . points . elementat ( points [ i ] ) ; vector3d e1 = ps [ 0 ] . minus ( ps [ 1 ] ) ; vector3d e2 = ps [ 2 ] . minus ( ps [ 1 ] ) ; normal = new vector3d ( e1 ) . cross ( e2 ) . makeunit ( ) ; calclight ( ) ; }
tr	1	public string getprimaryid ( ) { return mprimaryid ; }
tr	4	@ test public void publish ( ) { final string kroothome = serverhomepath ( "root" ) ; final string user_account_1 = "publisher1@domain.zz" ; final string user_account_2 = "publisher2@domain.zz" ; final string user_account_3 = "publisher3@domain.zz" ; testuser [ ] users = { new testuser ( user_account_1 ) , new testuser ( user_account_2 ) , new testuser ( user_account_3 ) } ; createtopicpaths ( kroothome , null ) ; for ( testuser user : users ) { user . begin ( ) ; } assert . asserttrue ( users [ 0 ] . getconnection ( ) . client ( ) . subscribe ( "/topics/category2/topic1" ) ) ; assert . asserttrue ( users [ 0 ] . getconnection ( ) . client ( ) . subscribe ( "/topics/category2/topic2" ) ) ; assert . asserttrue ( users [ 0 ] . getconnection ( ) . client ( ) . subscribe ( "/topics/category3/topic1" ) ) ; assert . asserttrue ( users [ 0 ] . getconnection ( ) . client ( ) . subscribe ( "/topics/category3/topic2" ) ) ; assert . asserttrue ( users [ 1 ] . getconnection ( ) . client ( ) . subscribe ( "/topics/category1/topic1" ) ) ; assert . asserttrue ( users [ 1 ] . getconnection ( ) . client ( ) . subscribe ( "/topics/category1/topic2" ) ) ; assert . asserttrue ( users [ 1 ] . getconnection ( ) . client ( ) . subscribe ( "/topics/category3/*" ) ) ; assert . asserttrue ( users [ 2 ] . getconnection ( ) . client ( ) . subscribe ( "/topics/category1/*" ) ) ; assert . asserttrue ( users [ 2 ] . getconnection ( ) . client ( ) . subscribe ( "/topics/category2/*" ) ) ; int data = 1 ; testpublish ( users , 0 , new int [ ] { 0 , 1 , 1 } , "/topics/category1/topic1" , data ++ ) ; testpublish ( users , 0 , new int [ ] { 0 , 1 , 1 } , "/topics/category1/topic2" , data ++ ) ; testpublish ( users , 1 , new int [ ] { 1 , 0 , 1 } , "/topics/category2/topic1" , data ++ ) ; testpublish ( users , 1 , new int [ ] { 1 , 0 , 1 } , "/topics/category2/topic2" , data ++ ) ; testpublish ( users , 2 , new int [ ] { 1 , 1 , 0 } , "/topics/category3/topic1" , data ++ ) ; testpublish ( users , 2 , new int [ ] { 1 , 1 , 0 } , "/topics/category3/topic2" , data ++ ) ; testpublish ( users , 0 , new int [ ] { - 1 , - 1 , 2 } , "/topics/category1/topic3" , data ++ ) ; string [ ] exclude = { "test-session-" + user_account_2 } ; string [ ] eligible = { } ; testpublish ( users , 0 , new int [ ] { 0 , 0 , 1 } , false , exclude , eligible , "/topics/category1/topic1" , data ++ ) ; exclude = new string [ ] { "test-session-" + user_account_2 , "test-session-" + user_account_3 } ; testpublish ( users , 0 , new int [ ] { 0 , 0 , 0 } , false , exclude , eligible , "/topics/category1/topic1" , data ++ ) ; exclude = new string [ ] { } ; eligible = new string [ ] { "test-session-" + user_account_2 } ; testpublish ( users , 0 , new int [ ] { 0 , 1 , 0 } , false , exclude , eligible , "/topics/category1/topic1" , data ++ ) ; assert . asserttrue ( users [ 0 ] . getconnection ( ) . client ( ) . unsubscribe ( "/topics/category2/topic1" ) ) ; testpublish ( users , 1 , new int [ ] { 0 , 0 , 1 } , "/topics/category2/topic1" , data ++ ) ; assert . asserttrue ( users [ 1 ] . getconnection ( ) . client ( ) . unsubscribe ( "/topics/category3/*" ) ) ; testpublish ( users , 2 , new int [ ] { 1 , 0 , 0 } , "/topics/category3/topic2" , data ++ ) ; assert . asserttrue ( users [ 0 ] . getconnection ( ) . client ( ) . subscribe ( "/topics/category1/topic1" ) ) ; testpublish ( users , 0 , new int [ ] { 1 , 1 , 1 } , "/topics/category1/topic1" , data ++ ) ; testpublish ( users , 0 , new int [ ] { 0 , 1 , 1 } , true , null , null , "/topics/category1/topic1" , data ++ ) ; denyaccess ( kroothome , users [ 0 ] . getserverhomepath ( ) , "category1" ) ; testpublish ( users , 0 , new int [ ] { 0 , 0 , 0 } , "/topics/category1/topic1" , data ++ ) ; denyaccess ( kroothome , users [ 0 ] . getserverhomepath ( ) , "category2" ) ; testpublish ( users , 1 , new int [ ] { 0 , 0 , 1 } , "/topics/category2/topic2" , data ++ ) ; for ( testuser user : users ) { user . end ( ) ; } }
tr	10	reprocessingplantpanel ( preferences preferences ) { super ( new gridbaglayout ( ) ) ; gridbagconstraints c = new gridbagconstraints ( ) ; c . gridy = 0 ; c . gridx = 0 ; c . weightx = 1.0 ; c . fill = gridbagconstraints . horizontal ; c . anchor = gridbagconstraints . baseline_leading ; mineralpanel = new mineralpanel ( preferences ) ; mineralpanel . setborder ( borderfactory . createtitledborder ( "minerals" ) ) ; add ( mineralpanel , c ) ; c . gridx = 1 ; c . weightx = 0.0 ; c . fill = gridbagconstraints . vertical ; plantsettings = new userplantsettings ( preferences ) ; plantsettings . setborder ( borderfactory . createtitledborder ( "facility" ) ) ; add ( plantsettings , c ) ; plantsettings . setpreferredsize ( new dimension ( 150 , 100 ) ) ; c . gridy = 1 ; c . gridx = 0 ; c . gridwidth = 2 ; c . fill = gridbagconstraints . horizontal ; sovereigntypanel = new sovereigntypanel ( preferences , new abstractaction ( "find solution" ) { @ override public void actionperformed ( actionevent e ) { swingworker < string , void > worker = new swingworker < string , void > ( ) { @ override protected string doinbackground ( ) throws exception { swingutilities . invokelater ( new runnable ( ) { @ override public void run ( ) { reprocessingplantpanel . this . setenabled ( false ) ; } } ) ; enumset < sovereignty > sovereignty = sovereigntypanel . getsovereignty ( ) ; double securitystatus = sovereigntypanel . getminimumsecuritystatus ( ) ; serviceloader < reprocessingservice > serviceloader = serviceloader . load ( reprocessingservice . class ) ; iterator < reprocessingservice > iterator = serviceloader . iterator ( ) ; if ( iterator . hasnext ( ) ) { reprocessingservice service = iterator . next ( ) ; reprocessingplant plant = service . getplant ( sovereignty , securitystatus ) ; double yield = plantsettings . getyield ( ) ; double tax = plantsettings . gettax ( ) ; plant . setuserstatistics ( yield / 100 , tax / 100 ) ; reprocessingsolution solution = plant . getminimumorevolume ( mineralpanel . getminerals ( ) ) ; return toformattedstring ( solution , plantsettings . getcargo ( ) ) ; } else { return "no suitable reprocessing service found." ; } } @ override protected void done ( ) { try { resultdocument . remove ( 0 , resultdocument . getlength ( ) ) ; resultdocument . insertstring ( 0 , get ( ) , null ) ; } catch ( badlocationexception e1 ) { e1 . printstacktrace ( ) ; } catch ( interruptedexception e1 ) { e1 . printstacktrace ( ) ; } catch ( executionexception e1 ) { e1 . printstacktrace ( ) ; } finally { reprocessingplantpanel . this . setenabled ( true ) ; } } } ; worker . execute ( ) ; } } ) ; border border = borderfactory . createtitledborder ( "sovereignty" ) ; sovereigntypanel . setborder ( border ) ; add ( sovereigntypanel , c ) ; c . gridy = 2 ; c . gridx = 0 ; c . gridwidth = 2 ; c . weightx = 1.0 ; c . weighty = 1.0 ; c . insets = new insets ( 0 , 0 , 0 , 0 ) ; c . fill = gridbagconstraints . both ; jtextarea resultarea = new jtextarea ( ) ; resultarea . seteditable ( false ) ; resultdocument = resultarea . getdocument ( ) ; jscrollpane scrollpane = new jscrollpane ( resultarea ) ; scrollpane . setborder ( borderfactory . createtitledborder ( "optimal ore volumes" ) ) ; add ( scrollpane , c ) ; }
tr	7	private void spawnbox ( int size , int xstart , int ystart ) { size = size + 2 ; for ( int i = 0 ; i < size ; i ++ ) { for ( int j = 0 ; j < size ; j ++ ) { if ( i == 0 || i == size - 1 || j == 0 || j == size - 1 ) { boot . getworldobj ( ) . gettileatcoords ( xstart + i , ystart + j ) . settileid ( tileid . asphalt ) ; } } } }
tr	1	@ override public void resetammo ( ) { super . resetammo ( ) ; synchronized ( this . lasers ) { this . lasers . clear ( ) ; } this . ammoleft = laserwire . default_ammo ; }
tr	1	public bfs ( ) { queue = new linkedlist < integer > ( ) ; }
tr	9	private void checkfortermination ( int timezone ) { terminationcounter countert = terminationcounters . get ( timezone ) ; logger . info ( "balance: " + countert . getsentmessages ( ) + " / " + countert . getreceivedmessages ( ) ) ; if ( countert . isbalanced ( ) && countert . isnotempty ( ) ) { terminationcounter counterprev = terminationcounters . get ( timezone - 1 ) ; terminationcounter counternext = terminationcounters . get ( timezone + 1 ) ; if ( counterprev != null ) { if ( counterprev . isbalanced ( ) && counterprev . isnotempty ( ) ) { keeprunning = false ; logger . info ( "termination reached! messages sent: " + countert . getsentmessages ( ) + " messages received: " + countert . getreceivedmessages ( ) ) ; } else { if ( counternext != null && counternext . isbalanced ( ) && counternext . isnotempty ( ) ) { keeprunning = false ; logger . info ( "termination reached! messages sent: " + countert . getsentmessages ( ) + " messages received: " + countert . getreceivedmessages ( ) ) ; } } } } }
tr	2	public reportform ( java . awt . frame parent , boolean modal , date df , date dt , string un , string su ) { super ( parent , modal ) ; datefrom = df ; dateto = dt ; unit = un ; subunit = su ; initcomponents ( ) ; if ( ! beans . isdesigntime ( ) ) { entitymanager . gettransaction ( ) . begin ( ) ; } mastertable . getcolumnmodel ( ) . getcolumn ( 5 ) . setcellrenderer ( new tablecellrenderdate ( ) ) ; mastertable . getcolumnmodel ( ) . getcolumn ( 6 ) . setcellrenderer ( new tablecellrendertime ( ) ) ; mastertable . setautoresizemode ( jtable . auto_resize_off ) ; tablecolumnadjuster tca = new tablecolumnadjuster ( mastertable ) ; tca . adjustcolumns ( ) ; defaulttablecellrenderer dtcr = new defaulttablecellrenderer ( ) ; dtcr . sethorizontalalignment ( swingconstants . center ) ; mastertable . getcolumnmodel ( ) . getcolumn ( 0 ) . setcellrenderer ( dtcr ) ; mastertable . getcolumnmodel ( ) . getcolumn ( 1 ) . setcellrenderer ( dtcr ) ; mastertable . getcolumnmodel ( ) . getcolumn ( 4 ) . setcellrenderer ( dtcr ) ; mastertable . getcolumnmodel ( ) . getcolumn ( 7 ) . setcellrenderer ( dtcr ) ; }
tr	8	private object getfield ( resultsetmetadata metadata , resultset rs , string field ) throws sqlexception { int index = rs . findcolumn ( field ) ; int columntype = metadata . getcolumntype ( index ) ; if ( columntype == types . date || columntype == types . timestamp ) { timestamp timestamp = rs . gettimestamp ( index ) ; if ( timestamp != null ) { return new date ( timestamp . gettime ( ) ) ; } return null ; } if ( columntype == types . clob ) { return rs . getstring ( index ) ; } return rs . getobject ( index ) ; }
tr	4	public void solve ( ) { int nodescount = 2 * _goncount ; int [ ] nodes = new int [ nodescount ] ; for ( int i = 0 ; i < nodes . length ; i ++ ) { nodes [ i ] = i + 1 ; } list < string > result = mix ( 0 , nodes ) ; collections . sort ( result ) ; for ( string string : result ) { system . out . print ( "length=" + string . length ( ) + "<litcomma> " ) ; system . out . println ( string ) ; } }
tr	2	public void tofile ( string filename ) throws ioexception { printwriter out = new printwriter ( new bufferedwriter ( new filewriter ( filename ) ) ) ; for ( int i = 0 ; i < partition . length ; i ++ ) { out . println ( magnitude * partition [ i ] ) ; } out . flush ( ) ; out . close ( ) ; }
tr	1	public void adicionarofertarecursoslivre ( int id ) { ofertasrecursoslivres . add ( id ) ; }
tr	6	public void showtasksfor ( course course ) { if ( debug ) log ( "attempting to show only tasks associated with course: " + course . getname ( ) ) ; centercontent . removeall ( ) ; for ( taskwidget taskwidget : taskwidgets ) { if ( taskwidget . gettask ( ) . getcourse ( ) == course ) { centercontent . add ( taskwidget ) ; } } revalidate ( ) ; repaint ( ) ; }
tr	5	private static void playerangles ( ) { player player = playermanager . player ; if ( ! anglelocked ) { double [ ] mousesensitivity = settingsmanager . getmousesensitivity ( ) ; player . getang ( ) . y += mouse . getdx ( ) * mousesensitivity [ 0 ] ; player . getang ( ) . x -= mouse . getdy ( ) * mousesensitivity [ 1 ] ; if ( player . getang ( ) . x > 89 ) { player . getang ( ) . x = 89 ; } if ( player . getang ( ) . x < - 89 ) { player . getang ( ) . x = - 89 ; } } player . getrigidbody ( ) . setangularfactor ( 0 ) ; player . getrigidbody ( ) . setangularvelocity ( new vector3f ( 0 , 0 , 0 ) ) ; }
tr	6	private void createandshowgui ( ) { final jframe frame = new jframe ( "edasomind" ) ; frame . setdefaultcloseoperation ( jframe . exit_on_close ) ; frame . setextendedstate ( java . awt . frame . maximized_both ) ; frame . setdefaultcloseoperation ( jframe . exit_on_close ) ; jbutton button = new jbutton ( "select file" ) ; button . setsize ( 300 , 100 ) ; button . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent ae ) { filedialog dialog = new filedialog ( frame , "load java-file" , filedialog . load ) ; dialog . setfile ( "*.java" ) ; dialog . setvisible ( true ) ; file f = new file ( dialog . getdirectory ( ) + dialog . getfile ( ) ) ; if ( f . exists ( ) ) try { edasomindresultlist result = edasomindaccessfactory . gethome ( ) . analyzefile ( f ) ; dh . setresult ( result ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } } } ) ; gridlayout l = new gridlayout ( 2 , 1 ) ; frame . setlayout ( l ) ; container c = frame . getcontentpane ( ) ; edasomindtablemodel tm = new edasomindtablemodel ( dh ) ; jtable table = new jtable ( tm ) ; tablecellrenderer ren = new edasomindtablecellrenderer ( dh ) ; table . setdefaultrenderer ( object . class , ren ) ; c . add ( button ) ; c . add ( new jscrollpane ( table ) ) ; string classname = "com.apple.eawt.fullscreenutilities" ; string methodname = "setwindowcanfullscreen" ; try { class < ? > clazz = class . forname ( classname ) ; method method = clazz . getmethod ( methodname , new class < ? > [ ] { window . class , boolean . class } ) ; method . invoke ( null , frame , true ) ; } catch ( throwable t ) { system . err . println ( "full screen mode is not supported" ) ; } frame . pack ( ) ; frame . setvisible ( true ) ; }
tr	3	public final static string getmd5 ( string s ) { char hexdigits [ ] = { '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , 'a' , 'b' , 'c' , 'd' , 'e' , 'f' } ; try { byte [ ] btinput = s . getbytes ( ) ; messagedigest mdinst = messagedigest . getinstance ( "md5" ) ; mdinst . update ( btinput ) ; byte [ ] md = mdinst . digest ( ) ; int j = md . length ; char str [ ] = new char [ j * 2 ] ; int k = 0 ; for ( int i = 0 ; i < j ; i ++ ) { byte byte0 = md [ i ] ; str [ k ++ ] = hexdigits [ byte0 > > > 4 & 0xf ] ; str [ k ++ ] = hexdigits [ byte0 & 0xf ] ; } return new string ( str ) ; } catch ( exception e ) { e . printstacktrace ( ) ; return null ; } }
tr	6	public static boolean fromclausecontainstablename ( final uniquelist fromclause , final string tablename ) { if ( tablename == null ) { return true ; } for ( iterator it = fromclause . iterator ( ) ; it . hasnext ( ) ; ) { query . fromelement fromelement = ( query . fromelement ) it . next ( ) ; if ( tablename . equals ( fromelement . gettablename ( ) ) ) { return true ; } } return false ; }
tr	4	public int getuniquewindowid ( ) { int id = 0 ; boolean unique = false ; while ( ! unique ) { unique = true ; for ( int x = 0 ; x < windowslist . size ( ) ; x ++ ) { if ( id == windowslist . get ( x ) . getid ( ) ) { unique = false ; id ++ ; } } } return id ; }
tr	1	public double alpha ( int featureindex ) { return magnitude * partition [ featureindex ] ; }
tr	4	public void affichermap ( tuple hg , tuple decal ) { for ( int i = hg . y - 1 , l = hg . y + this . tailleecrany + 1 ; i < l ; i ++ ) { int y = ( i - hg . y ) * 32 ; for ( int j = hg . x - 1 , k = hg . x + tailleecranx + 1 ; j < k ; j ++ ) { case caseij = this . getcase ( i , j ) ; this . tileset . dessinertile ( caseij . numtile , ( j - hg . x ) * 32 + decal . x , y + decal . y ) ; if ( caseij . objet != null ) this . tilesetobjet . dessinertile ( caseij . objet . numtile , ( j - hg . x ) * 32 + decal . x , y + decal . y ) ; } } }
tr	7	private int getleftpoint ( ) { int x = - 1 ; for ( int c = 0 ; c < this . figura [ 0 ] . length && x == - 1 ; c ++ ) { boolean columnanula = true ; for ( int f = 0 ; f < this . figura . length && columnanula ; f ++ ) { if ( this . figura [ f ] [ c ] . gettipo ( ) != tipobloque . vacio ) columnanula = false ; } if ( ! columnanula ) x = c ; } return x ; }
tr	4	protected double [ ] randomrawmultinomial ( randoms r ) { double sum = 0 ; double [ ] pr = new double [ this . partition . length ] ; for ( int i = 0 ; i < this . partition . length ; i ++ ) { pr [ i ] = r . nextgamma ( magnitude * partition [ i ] ) ; sum += pr [ i ] ; } for ( int i = 0 ; i < this . partition . length ; i ++ ) pr [ i ] /= sum ; return pr ; }
tr	1	public void setdateto ( calendar dtto ) { mdateto = dtto ; }
tr	4	public static double digamma ( double z ) { double psi = 0 ; if ( z < digamma_small ) { psi = euler_mascheroni - ( 1 / z ) ; return psi ; } while ( z < digamma_large ) { psi -= 1 / z ; z ++ ; } double invz = 1 / z ; double invzsquared = invz * invz ; psi += math . log ( z ) - .5 * invz - invzsquared * ( digamma_coef_1 - invzsquared * ( digamma_coef_2 - invzsquared * ( digamma_coef_3 - invzsquared * ( digamma_coef_4 - invzsquared * ( digamma_coef_5 - invzsquared * ( digamma_coef_6 - invzsquared * digamma_coef_7 ) ) ) ) ) ) ; return psi ; }
tr	7	public static void main ( string [ ] args ) { int [ ] input = { 4 , 6 , 2 , 5 , 1 } ; int l = input . length ; boolean swapoccured = false ; for ( int x = 0 ; x < l ; x ++ ) { printarray ( input , "x" ) ; swapoccured = false ; for ( int y = 0 ; y < l - 1 ; y ++ ) { printarray ( input , "y" ) ; if ( input [ y ] > input [ y + 1 ] ) { int holder = input [ y + 1 ] ; input [ y + 1 ] = input [ y ] ; input [ y ] = holder ; swapoccured = true ; } } if ( ! swapoccured ) break ; } }
tr	3	public boolean equals ( object o ) { if ( o instanceof request ) { request r = ( request ) o ; return r . index == index && begin == r . begin && len == r . len ; } return false ; }
tr	9	public static int [ ] getcomplement ( int [ ] rgb ) { int [ ] complements = new int [ 3 ] ; boolean iscomplement = false ; for ( int i = 0 ; i < rgb . length ; i ++ ) { int complement = 255 - rgb [ i ] ; complements [ i ] = math . abs ( complement - rgb [ i ] ) ; if ( complements [ i ] > 32 ) iscomplement = true ; } for ( int i = 0 ; i < rgb . length ; i ++ ) { complements [ i ] = ( iscomplement ) ? 255 - rgb [ i ] : ( rgb [ i ] + 128 ) % 256 ; } return complements ; }
tr	10	public void paint ( graphics g ) { g . setcolor ( color . red ) ; g . fillrect ( getxpos ( ) , getypos ( ) , getwidth ( ) , getheight ( ) ) ; g . setcolor ( color . black ) ; if ( settings . gettiled ( ) ) { for ( int i = levelx ; i < getwidth ( ) + levelx ; i ++ ) if ( i % settings . gettilesize ( ) == 0 ) g . drawline ( i - levelx , 0 , i - levelx , getheight ( ) ) ; for ( int i = levely ; i < getheight ( ) + levely ; i ++ ) if ( i % settings . gettilesize ( ) == 0 ) g . drawline ( 0 , i - levely , getwidth ( ) , i - levely ) ; } super . paint ( g ) ; }
tr	10	public boolean parseknown ( string knownfile ) { mknownlist = null ; string line = null ; bufferedreader in = null ; try { in = new bufferedreader ( new filereader ( knownfile ) ) ; } catch ( filenotfoundexception e ) { e . printstacktrace ( ) ; return false ; } mknownlist = new hashset < string > ( ) ; do { try { line = in . readline ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } if ( line == null ) { break ; } mknownlist . add ( line ) ; } while ( line != null ) ; return true ; }
tr	4	public int getndf ( datasetxy data ) { int npoints = 0 ; for ( int loop = 0 ; loop < data . getdatay ( ) . getsize ( ) ; loop ++ ) { double xv = data . getdatax ( ) . getvalue ( loop ) ; if ( xv >= this . getmin ( ) && xv <= this . getmax ( ) ) { npoints ++ ; } } return npoints - this . getnparams ( ) ; }
tr	5	private static int [ ] [ ] getsums ( ) { int [ ] [ ] sums = new int [ length ] [ length ] ; sums [ 0 ] [ 0 ] = matrix [ 0 ] [ 0 ] ; for ( int row = 1 ; row < length ; row ++ ) { for ( int diagonal = 0 ; diagonal < row + 1 ; diagonal ++ ) { if ( diagonal == 0 ) { sums [ row ] [ 0 ] = sums [ row - 1 ] [ 0 ] + matrix [ row ] [ 0 ] ; } else if ( diagonal == row ) { sums [ 0 ] [ row ] = sums [ 0 ] [ row - 1 ] + matrix [ 0 ] [ row - 1 ] ; } else { int i = row - diagonal ; int j = diagonal ; sums [ i ] [ j ] = sums [ i ] [ j - 1 ] + sums [ i - 1 ] [ j ] - sums [ i - 1 ] [ j - 1 ] + matrix [ i ] [ j ] ; } } } return sums ; }
tr	1	private boolean iscurrentlyskipping ( ) { return currentlyskippedlevel != default_currently_skipped_level ; }
tr	10	@ override public boolean equals ( object object ) { if ( ! ( object instanceof parkreservation ) ) { return false ; } parkreservation other = ( parkreservation ) object ; if ( ( this . getid ( ) == null && other . getid ( ) != null ) || ( this . getid ( ) != null && ! this . id . equals ( other . id ) ) ) { return false ; } return true ; }
tr	2	public static string distributiontostring ( double magnitude , double [ ] distribution ) { stringbuffer output = new stringbuffer ( ) ; numberformat formatter = numberformat . getinstance ( ) ; formatter . setmaximumfractiondigits ( 5 ) ; output . append ( formatter . format ( magnitude ) + ":\\t" ) ; for ( int i = 0 ; i < distribution . length ; i ++ ) { output . append ( formatter . format ( distribution [ i ] ) + "\\t" ) ; } return output . tostring ( ) ; }
tr	10	@ override public boolean equals ( object o ) { if ( o == null ) return false ; else if ( o == this ) return true ; else if ( o instanceof ofertaemprego ) { ofertaemprego ofertaemprego = ( ofertaemprego ) o ; if ( this . id == ofertaemprego . id && this . titulo . equals ( ofertaemprego . titulo ) && this . detalhesoferta . equals ( ofertaemprego . detalhesoferta ) && this . numerocandidatosnecessarios == ofertaemprego . numerocandidatosnecessarios && this . perfilcandidatos . equals ( ofertaemprego . perfilcandidatos ) ) if ( anexos . size ( ) == ofertaemprego . anexos . size ( ) ) return anexos . containsall ( ofertaemprego . anexos ) ; return false ; } else return false ; }
tr	2	private void handleevent ( iparserevent event ) { handler . handleevent ( event ) ; if ( handler . iscomplete ( ) ) { handler = handlerstack . pop ( ) ; } }
tr	4	private void setdefaultvaluesforfields ( final map < string , object > model ) throws illegalaccessexception , exception { for ( int i = 1 ; i <= datafields . size ( ) ; i ++ ) { field field = annotatedfields . get ( i ) ; field . setaccessible ( true ) ; datafield datafield = datafields . get ( i ) ; object modelfield = model . get ( field . getdeclaringclass ( ) . getname ( ) ) ; if ( field . get ( modelfield ) == null && ! datafield . defaultvalue ( ) . isempty ( ) ) { format < ? > format = formatfactory . getformat ( field . gettype ( ) , getlocale ( ) , datafield ) ; object value = format . parse ( datafield . defaultvalue ( ) ) ; field . set ( modelfield , value ) ; } } }
tr	7	private void insertarbatalla ( ) { dateformat formateadorfechas = dateformat . getdateinstance ( dateformat . short , locale . france ) ; if ( txthistorialbatalla . gettext ( ) . equals ( "" ) || datebatalla . getdate ( ) == null || txtduracionbatalla . gettext ( ) . equals ( "" ) || this . txtduracionbatalla . gettext ( ) . matches ( "[0-9]*" ) == false || this . cbatacantebatalla . getselectedindex ( ) == this . cbdefensorbatalla . getselectedindex ( ) ) { mensaje . mensajeerror ( "los datos no son correctos<litcomma> compruebalos" ) ; } else { batalla batalla = new batalla ( ) ; batalla . setduracion ( integer . parseint ( this . txtduracionbatalla . gettext ( ) ) ) ; batalla . setfechabatalla ( this . datebatalla . getdate ( ) ) ; batalla . sethistorial ( this . txthistorialbatalla . gettext ( ) ) ; try { int idatacante = this . cbatacantebatalla . jugadorseleccionadoid ( conexion ) ; int iddefensor = this . cbdefensorbatalla . jugadorseleccionadoid ( conexion ) ; this . tablabatallas . insertar ( esnuevobatalla , batalla , this . batalla , idatacante , iddefensor ) ; cancelarbatalla ( ) ; tablabatallas . listar ( ) ; } catch ( sqlexception e ) { e . printstacktrace ( ) ; } } }
tr	6	public static double fmod ( double x , double y ) { double quot ; if ( double . isnan ( x ) || double . isnan ( y ) ) return x + y ; quot = x / y ; return x - ( quot < 0.0 ? java . lang . math . ceil ( quot ) : java . lang . math . floor ( quot ) ) * y ; }
tr	9	public int getitem ( final string message ) { int id ; try { try { try { id = integer . parseint ( custommessages . getstring ( message ) ) ; } catch ( exception e ) { material m = material . getmaterial ( custommessages . getstring ( message ) . touppercase ( ) ) ; id = m != null ? m . getid ( ) : - 1 ; } } catch ( final missingresourceexception ex ) { try { id = integer . parseint ( messages . getstring ( message ) ) ; } catch ( exception e ) { material m = material . getmaterial ( messages . getstring ( message ) . touppercase ( ) ) ; id = m != null ? m . getid ( ) : - 1 ; } } } catch ( final missingresourceexception ex ) { try { id = integer . parseint ( defaultbundle . getstring ( message ) ) ; } catch ( exception e ) { material m = material . getmaterial ( defaultbundle . getstring ( message ) . touppercase ( ) ) ; id = m != null ? m . getid ( ) : - 1 ; } } return id ; }
tr	3	private boolean isbucketprocessed ( int bucketid ) { synchronized ( actualprocessingbuckets ) { for ( bucket < data > onebucket : this . actualprocessingbuckets ) { if ( onebucket . getbucketid ( ) == bucketid ) { return true ; } } } return false ; }
tr	6	public static string gettablename ( final string name , final string dbname ) throws torqueexception { final string testname = removesqlfunction ( name ) ; if ( stringutils . isempty ( testname ) ) { throwmalformedcolumnnameexception ( "gettablename" , name ) ; } int rightdotindex = testname . lastindexof ( '.' ) ; if ( rightdotindex < 0 ) { if ( "*" . equals ( testname ) ) { return null ; } throwmalformedcolumnnameexception ( "gettablename" , name ) ; } return getfulltablename ( testname . substring ( 0 , rightdotindex ) , dbname ) ; }
tr	8	public static list < string > generate ( list < string > list ) { if ( list . size ( ) == 1 ) { return list ; } list < string > result = new arraylist < > ( ) ; for ( int i = 0 ; i < list . size ( ) - 1 ; i ++ ) { list < string > left = generate ( list . sublist ( 0 , i + 1 ) ) ; list < string > right = generate ( list . sublist ( i + 1 , list . size ( ) ) ) ; for ( string l : left ) { for ( string r : right ) { result . add ( "(" + l + r + ")" ) ; } } } return result ; }
tr	5	@ override public int getbid ( string winningplayerid , int currentbid ) { system . out . println ( "\\n" + this + "\\n" ) ; system . out . print ( "what would you like to bid (nums <= currentbid are a pass)? " ) ; integer intresponse = null ; while ( intresponse == null ) { string response ; try { response = bufferedreader . readline ( ) ; } catch ( ioexception e1 ) { system . out . println ( e1 ) ; continue ; } try { intresponse = integer . parseint ( response ) ; } catch ( numberformatexception nfe ) { system . out . print ( "\\ndoes not compute...please enter another number: " ) ; continue ; } } return intresponse ; }
tr	9	@ override public class < ? > loadclass ( string name ) throws classnotfoundexception { if ( usewhitelist && ! white . matches ( name ) ) { throw new securityexception ( "loading of class '" + name + "' not allowed by classloader whitelist." ) ; } if ( useblacklist && black . matches ( name ) ) { throw new securityexception ( "loading of class '" + name + "' not allowed by classloader blacklist." ) ; } return super . loadclass ( name ) ; }
tr	8	public static vector3f raytriangle ( vector3f origin , vector3f direction , triangle t ) { vector3f res ; vector3f u , v , n ; float r , a , b ; u = t . getpoint2 ( ) . - ( t . getpoint1 ( ) ) ; v = t . getpoint3 ( ) . - ( t . getpoint1 ( ) ) ; n = u . cross ( v ) ; if ( n . length ( ) == 0 ) return null ; a = - ( n . . ( origin . - ( t . getpoint1 ( ) ) ) ) ; b = n . . ( direction ) ; if ( math . abs ( b ) < mathhelper . epsilon ) return null ; r = a / b ; if ( r < 0.0 ) return null ; res = origin . add ( direction . mul ( r ) ) ; return res ; }
tr	10	private void updatestreamname ( ) { string temp_file = "crtmpserver.lua.temp" ; bufferedreader br = null ; bufferedwriter bw = null ; try { br = new bufferedreader ( new filereader ( serverconfigfile ) ) ; bw = new bufferedwriter ( new filewriter ( temp_file ) ) ; string line ; while ( ( line = br . readline ( ) ) != null ) { if ( line . contains ( "localstreamname" ) || line . contains ( "targetstreamname" ) ) { line = line . replaceall ( "localstreamname=\\".*\\"" , "localstreamname=\\"" + camserver . streamname + "\\"" ) ; line = line . replaceall ( "targetstreamname=\\".*\\"" , "targetstreamname=\\"" + camserver . streamname + "\\"" ) ; } bw . write ( line + "\\n" ) ; } } catch ( ioexception e ) { e . printstacktrace ( ) ; return ; } finally { try { if ( br != null ) { br . close ( ) ; } if ( bw != null ) { bw . close ( ) ; } } catch ( ioexception e ) { } } file oldfile = new file ( serverconfigfile ) ; oldfile . delete ( ) ; file newfile = new file ( temp_file ) ; newfile . renameto ( oldfile ) ; streamnameupdated = true ; }
tr	9	private string call ( string method , string params ) { string urlstring = "https://api.flickr.com/services/rest/?method=" + method + "&api_key=" + key + "&format=json&nojsoncallback=1" ; if ( params != null && ! params . equals ( "" ) ) urlstring += "&" + params ; system . out . println ( "flickrapi: " + urlstring ) ; try { url url = new url ( urlstring ) ; httpurlconnection con = ( httpurlconnection ) url . openconnection ( ) ; con . setrequestmethod ( "get" ) ; con . setusecaches ( false ) ; inputstream is = con . getinputstream ( ) ; bufferedreader reader = new bufferedreader ( new inputstreamreader ( is , "utf-8" ) ) ; stringbuilder responsebuilder = new stringbuilder ( ) ; char [ ] buffer = new char [ 1024 ] ; int readlen ; while ( ( readlen = reader . read ( buffer ) ) != - 1 ) { responsebuilder . append ( buffer , 0 , readlen ) ; } return responsebuilder . tostring ( ) ; } catch ( ioexception e ) { e . printstacktrace ( system . err ) ; return null ; } }
tr	10	@ override public int compare ( chemin < c , a , n , e > chemin_1 , chemin < c , a , n , e > chemin_2 ) { if ( chemin_1 == chemin_2 ) return 0 ; if ( chemin_1 . getlength ( ) < chemin_2 . getlength ( ) ) return - 1 ; else if ( chemin_1 . getlength ( ) > chemin_2 . getlength ( ) ) return 1 ; else if ( chemin_1 . last ( ) == this . destination ) return - 1 ; else if ( chemin_2 . last ( ) == this . destination ) return 1 ; else return 0 ; }
tr	10	private static string towords ( int n ) { final string s = string . valueof ( n ) ; final int l = s . length ( ) ; if ( l == 1 ) { return numberstowords . get ( n ) ; } else if ( l == 2 ) { if ( numberstowords . containskey ( n ) ) { return numberstowords . get ( n ) ; } final int tens = n / 10 * 10 ; final int ones = n - tens ; return numberstowords . get ( tens ) + " " + numberstowords . get ( ones ) ; } else if ( l == 3 ) { final int hundreds = n / 100 * 100 ; final int remainder = ( n - hundreds ) ; if ( numberstowords . containskey ( remainder ) ) { return numberstowords . get ( ( hundreds / 100 ) ) + " hundred and " + numberstowords . get ( remainder ) ; } else { final int tens = ( n - hundreds ) / 10 * 10 ; final int ones = n - hundreds - tens ; if ( ones > 0 && tens > 0 ) { return numberstowords . get ( ( hundreds / 100 ) ) + " hundred and " + numberstowords . get ( tens ) + " " + numberstowords . get ( ones ) ; } else if ( tens > 0 ) { return numberstowords . get ( ( hundreds / 100 ) ) + " hundred and " + numberstowords . get ( tens ) ; } else { return numberstowords . get ( ( hundreds / 100 ) ) + " hundred" ; } } } else if ( l == 4 ) { final int thousands = n / 1000 * 1000 ; return numberstowords . get ( ( thousands / 1000 ) ) + " thousand" ; } return null ; }
tr	3	public static void main ( string [ ] args ) { x . prop . put ( "tokenized" , "true" ) ; x . prop . put ( "singlesentences" , "true" ) ; initpipeline ( true , true ) ; annotation ann = new annotation ( "boston 69 65 .515 5 1/2\\n1. michelle freeman ( jamaica ) 12.71 seconds" ) ; pipeline . annotate ( ann ) ; for ( coremap sent : ann . get ( sentencesannotation . class ) ) { for ( corelabel token : sent . get ( tokensannotation . class ) ) { logger . info ( token . get ( textannotation . class ) ) ; } logger . info ( "sentence done" ) ; } }
tr	1	@ override public void beginsubtask ( final statistics substate ) throws ioexception { final string p = getpre ( ) + "    " ; this . pres . push ( p ) ; sb . append ( "\\n" ) . append ( p ) . append ( "[" ) . append ( substate . getthreadname ( ) ) . append ( "]" ) ; }
tr	9	public endpoint getendpoint ( int index ) throws ioexception { synchronized ( endpoints ) { if ( endpoints [ index ] == null ) { int offset = getoffset ( ) ; int count = index ; do { offset = nextdescriptoroffset ( offset ) ; if ( descriptortype ( offset ) == type_endpoint ) count -- ; } while ( count >= 0 && offset > 0 ) ; if ( offset > 0 ) endpoints [ index ] = new endpoint ( this , offset ) ; else { throw new ioexception ( "missing endpoint descriptor" ) ; } } } return endpoints [ index ] ; }
tr	4	public static void main ( string args [ ] ) throws ioexception { bufferedreader br = new bufferedreader ( new inputstreamreader ( system . in ) ) ; system . out . print ( "" ) ; int size = integer . parseint ( br . readline ( ) ) ; turbosort o1 = new turbosort ( ) ; o1 . a = new int [ size ] ; o1 . b = new int [ size ] ; for ( int i = 0 ; i < size ; ++ i ) { system . out . print ( "" ) ; o1 . a [ i ] = integer . parseint ( br . readline ( ) ) ; } o1 . mergesort ( 0 , size - 1 ) ; for ( int i = size - 1 ; i >= 0 ; -- i ) { system . out . println ( o1 . a [ i ] ) ; } }
tr	8	private void startffmpeg ( ) throws ioexception { string command = encodername ; command = command . concat ( " -f" ) . concat ( " video4linux2" ) ; command = command . concat ( " -video_size" ) . concat ( " " + camserver . videowidth + "x" + camserver . videoheight ) ; command = command . concat ( " -framerate" ) . concat ( " " + camserver . getframerate ( ) ) ; command = command . concat ( " -i" ) . concat ( " " + camserver . getvideodevice ( ) . getdevicefile ( ) ) ; command = command . concat ( " -vcodec" ) . concat ( " libx264" ) ; command = command . concat ( " -r" ) . concat ( " " ) + camserver . getframerate ( ) ; command = command . concat ( " -pix_fmt" ) . concat ( " yuv420p" ) ; command = command . concat ( " -profile:v" ) . concat ( " high" ) ; command = command . concat ( " -tune" ) . concat ( " zerolatency" ) ; command = command . concat ( " -s" ) . concat ( " " + camserver . videowidth + "x" + camserver . videoheight ) ; if ( camserver . gop > 0 ) { command = command . concat ( " -g" ) . concat ( " " + camserver . gop ) ; } if ( ! camserver . bps . equalsignorecase ( "-1" ) ) { command = command . concat ( " -b:v" ) . concat ( " " + camserver . bps ) ; command = command . concat ( " -maxrate" ) . concat ( " " + camserver . bps ) ; command = command . concat ( " -bufsize" ) . concat ( " " + camserver . bps ) ; } command = command . concat ( " -me_method" ) . concat ( " zero" ) ; command = command . concat ( " -acodec" ) . concat ( " none" ) ; command = command . concat ( " -f" ) . concat ( " mpegts" ) ; command = command . concat ( " udp://127.0.0.1:10000" ) ; ffmpeg = runtime . getruntime ( ) . exec ( command ) ; ffmpegstdout = new defaultstreamgobbler ( ffmpeg . getinputstream ( ) , "output" , false , "ffmpeg_out" ) ; ffmpegstdout . start ( ) ; ffmpegstderr = new ffmpegstreamgobbler ( ffmpeg . geterrorstream ( ) , "error" , true , "ffmpeg_err" ) ; ffmpegstderr . start ( ) ; synchronized ( ffmpegstderr ) { try { ffmpegstderr . wait ( ) ; } catch ( interruptedexception e ) { e . printstacktrace ( ) ; } } }
tr	9	public static void readwordstemms ( ) { try { bufferedreader rd = new bufferedreader ( new inputstreamreader ( new fileinputstream ( "data/stems.txt" ) , "utf-8" ) ) ; string line = rd . readline ( ) ; stringtokenizer tk ; string stem = "" , linkedwords = "" ; while ( line != null ) { tk = new stringtokenizer ( line , " -[]" ) ; stem = tk . nexttoken ( ) ; while ( tk . hasmoretokens ( ) ) linkedwords += tk . nexttoken ( ) ; string [ ] arr = linkedwords . split ( "<litcomma>" ) ; for ( string k : arr ) { if ( ! stemms . containskey ( k ) ) { stemms . put ( k , stem ) ; } } linkedwords = "" ; line = rd . readline ( ) ; } rd . close ( ) ; } catch ( filenotfoundexception e ) { e . printstacktrace ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } }
tr	6	public double distancefromline ( double testangle ) { if ( leftdist <= 0 && rightdist <= 0 ) return 0 ; double x1 = leftdist * math . cos ( leftangle ) ; double y1 = leftdist * math . sin ( leftangle ) ; double x2 = rightdist * math . cos ( rightangle ) ; double y2 = rightdist * math . sin ( rightangle ) ; if ( math . abs ( x2 - x1 ) > math . abs ( y2 - y1 ) ) { double coeff = ( y2 - y1 ) / ( x2 - x1 ) ; return ( y1 - x1 * coeff ) / ( math . sin ( testangle ) - coeff * math . cos ( testangle ) ) ; } double coeff = ( x2 - x1 ) / ( y2 - y1 ) ; return ( x1 - y1 * coeff ) / ( math . cos ( testangle ) - coeff * math . sin ( testangle ) ) ; }
tr	4	public static string gettablenameforfromclause ( final string tablename , final criteria criteria ) { string shorttablename = getunqualifiedtablename ( tablename ) ; string aliasname = criteria . gettableforalias ( shorttablename ) ; if ( stringutils . isempty ( aliasname ) ) { aliasname = criteria . gettableforalias ( tablename ) ; } if ( stringutils . isnotempty ( aliasname ) ) { return new stringbuffer ( tablename . length ( ) + aliasname . length ( ) + 1 ) . append ( aliasname ) . append ( " " ) . append ( tablename ) . tostring ( ) ; } return tablename ; }
tr	7	public int compareto ( transaction transobj ) { if ( date . compareto ( transobj . getdate ( ) ) < 0 ) return - 1 ; else if ( date . compareto ( transobj . getdate ( ) ) > 0 ) return 1 ; else { if ( type . compareto ( transobj . gettype ( ) ) < 0 ) return - 1 ; else if ( type . compareto ( transobj . gettype ( ) ) > 0 ) return 1 ; else { if ( amount < transobj . getamount ( ) ) return - 1 ; else if ( amount > transobj . getamount ( ) ) return 1 ; else return 0 ; } } }
tr	7	private int getbottonpoint ( ) { int y = - 1 ; for ( int f = this . figura . length - 1 ; f >= 0 && y == - 1 ; f -- ) { boolean filanula = true ; for ( int c = 0 ; c < this . figura [ f ] . length && filanula ; c ++ ) { if ( this . figura [ f ] [ c ] . gettipo ( ) != tipobloque . vacio ) filanula = false ; } if ( ! filanula ) y = f ; } return y ; }
tr	8	public jsonelement tojson ( ) { jsonobject out = new jsonobject ( ) ; jsonarray diaarr = new jsonarray ( ) ; for ( diagramsettings settings : diagrams ) { diaarr . add ( settings . tojson ( ) ) ; } out . add ( diagram_settings , diaarr ) ; if ( booksettings != null ) { out . add ( book_settings , booksettings . tojson ( ) ) ; } if ( cropbox != cropping . full ) { out . add ( cropbox , booksettings . tojson ( ) ) ; } return out ; }
tr	10	public void openthefile ( allpanels allpanel ) { string str = null ; filter = new extensionfilefilter ( ) ; filter . addextension ( "txt" ) ; filter . setdescription ( "playlist(*.txt)" ) ; filechooser . setfilefilter ( filter ) ; int result = filechooser . showopendialog ( null ) ; filechooser . setmultiselectionenabled ( false ) ; if ( result == filechooser . approve_option ) { filename = filechooser . getselectedfile ( ) ; str = filename . tostring ( ) ; if ( filename == null || filename . getname ( ) . equals ( "" ) ) { joptionpane . showmessagedialog ( null , "choose from playlist" ) ; } else if ( ! str . endswith ( "txt" ) ) { joptionpane . showmessagedialog ( null , "choose txt files playlist" ) ; } else { if ( allpanel != null ) { allpanel . set_button_enable ( ) ; } try { if ( input != null ) { input = null ; } input = new objectinputstream ( new fileinputstream ( filename ) ) ; readfiles ( ) ; open_playlist_flag = true ; } catch ( exception e ) { system . out . print ( "the exception is here" + e ) ; e . printstacktrace ( ) ; } } } else { } }
tr	9	@ override public object getvalueat ( int rowindex , int columnindex ) { simpledateformat format = new simpledateformat ( "hh:mm" ) ; switch ( columnindex ) { case 0 : return trains . get ( rowindex ) . getnumber ( ) ; case 1 : return trains . get ( rowindex ) . getfromstation ( ) ; case 2 : return trains . get ( rowindex ) . gettostation ( ) ; case 3 : if ( trains . get ( rowindex ) . getdeparturetime ( ) == null ) return "" ; else return format . format ( trains . get ( rowindex ) . getdeparturetime ( ) ) ; case 4 : if ( trains . get ( rowindex ) . getarrivaltime ( ) == null ) return "" ; else return format . format ( trains . get ( rowindex ) . getarrivaltime ( ) ) ; case 5 : return trains . get ( rowindex ) . getticketsamount ( ) ; default : return null ; } }
tr	6	private void insertarpersonaje ( ) { dateformat formateadorfechas = dateformat . getdateinstance ( dateformat . short , locale . france ) ; if ( txtnombrepersonaje . gettext ( ) . equals ( "" ) || datepersonaje . getdate ( ) == null || cbclasepersonaje . getselectedindex ( ) == 0 || cbrazapersonaje . getselectedindex ( ) == 0 ) { mensaje . mensajeerror ( "los datos no son correctos<litcomma> compruebalos" ) ; } else { personaje personaje = new personaje ( ) ; personaje . setnombre ( txtnombrepersonaje . gettext ( ) ) ; personaje . setclase ( ( string ) cbclasepersonaje . getselecteditem ( ) ) ; personaje . setraza ( ( string ) cbrazapersonaje . getselecteditem ( ) ) ; personaje . setfechacreacion ( datepersonaje . getdate ( ) ) ; try { this . tablapersonajes . insertar ( esnuevopersonaje , personaje , this . personaje , this . cbjugadorpersonaje . jugadorseleccionadoid ( conexion ) ) ; cancelarpersonaje ( ) ; tablapersonajes . listar ( ) ; } catch ( sqlexception e ) { e . printstacktrace ( ) ; } } }
tr	3	public static void deserialize ( string filename ) throws classnotfoundexception { system . out . println ( "info: loading data from file " + "\\n" ) ; sernodes . clear ( ) ; try ( objectinputstream reader = new objectinputstream ( new fileinputstream ( filename ) ) ) { sernodes = ( arraylist < sernode > ) reader . readobject ( ) ; error = null ; } catch ( ioexception ex ) { error = ex . getlocalizedmessage ( ) ; logger . getlogger ( tracker . class . getname ( ) ) . log ( level . severe , null , ex ) ; } }
tr	5	public void printtree ( ) { queue < treenode > queue = new linkedlist < treenode > ( ) ; int nextlevel , currentlevel ; queue . add ( this ) ; currentlevel = 1 ; nextlevel = 0 ; while ( ! queue . isempty ( ) ) { treenode node = queue . poll ( ) ; currentlevel -- ; if ( node == null ) system . out . print ( "#" ) ; else { system . out . print ( node . val ) ; queue . add ( node . left ) ; queue . add ( node . right ) ; nextlevel += 2 ; } if ( currentlevel == 0 ) { currentlevel = nextlevel ; nextlevel = 0 ; system . out . println ( ) ; } else system . out . print ( ' ' ) ; } }
tr	10	public static int countoccurrencesof ( string str , string - ) { if ( str == null || - == null || str . length ( ) == 0 || - . length ( ) == 0 ) { return 0 ; } int count = 0 ; int pos = 0 ; int idx ; while ( ( idx = str . indexof ( - , pos ) ) != - 1 ) { ++ count ; pos = idx + - . length ( ) ; } return count ; }
tr	4	private labelcombinationextended greedyapproximation ( labelcombinationextended lc , double max ) throws exception { while ( lc . getcurrentlabel ( ) < this . numlabels && lc . getp ( ) > max ) { instance currentinstance = lc . getinstance ( ) ; int i = lc . getcurrentlabel ( ) ; double p = this . ensemble [ i ] . distributionforinstance ( currentinstance ) [ 1 ] ; lc . setnextlabel ( p >= 0.5 ? 1 : 0 , math . max ( p , 1 - p ) ) ; } return lc ; }
tr	6	public static void runcomparison ( ) { double precision ; int dimensions ; int documents ; int meansize ; try { printwriter out = new printwriter ( new bufferedwriter ( new filewriter ( "comparison" ) ) ) ; dimensions = 10 ; for ( int j = 0 ; j < 5 ; j ++ ) { documents = 100 ; for ( int k = 0 ; k < 5 ; k ++ ) { meansize = 100 ; for ( int l = 0 ; l < 5 ; l ++ ) { system . out . println ( dimensions + "\\t" + dimensions + "\\t" + documents + "\\t" + meansize ) ; for ( int m = 0 ; m < 10 ; m ++ ) { out . println ( compare ( dimensions , dimensions , documents , meansize ) ) ; } out . flush ( ) ; meansize *= 2 ; } documents *= 2 ; } dimensions *= 2 ; } out . flush ( ) ; out . close ( ) ; } catch ( exception e ) { e . printstacktrace ( system . out ) ; } }
tr	4	private static stringbuilder createbatch ( inputstream sqlfile ) throws ioexception { stringbuilder batch = new stringbuilder ( ) ; try ( bufferedreader reader = new bufferedreader ( new inputstreamreader ( sqlfile ) ) ) { string line = reader . readline ( ) ; while ( line != null ) { if ( ! line . startswith ( "#" ) ) { batch . append ( line ) ; } line = reader . readline ( ) ; } return batch ; } }
tr	7	public static member createelement ( final int id , final int x , final int y , final elementdata ed ) { member e = null ; switch ( ed . elementtype . tolowercase ( ) ) { case "prop" : e = props . get ( id ) . clone ( ) ; break ; case "decoration" : e = decorations . get ( id ) . clone ( ) ; break ; case "player" : final player t = players . get ( id ) ; final player p = new player ( t . get ( physicscomponent . class ) , t . get ( graphicscomponent . class ) , t . get ( interactcomponent . class ) , t . get ( attackcomponent . class ) , t . get ( inputcomponent . class ) ) ; if ( ed . mainplayer ) { ed . level . setmainplayer ( p ) ; p . setmainplayer ( ed . mainplayer ) ; p . set ( new playerinput ( ) ) ; } t . copy ( p ) ; p . setname ( ed . name ) ; e = p ; break ; case "item" : e = items . get ( id ) . clone ( ) ; break ; case "container" : e = containers . get ( id ) . clone ( ) ; break ; default : return null ; } e . get ( physicscomponent . class ) . setx ( x ) ; e . get ( physicscomponent . class ) . sety ( y ) ; e . setlevel ( ed . level ) ; e . setname ( ed . name ) ; return e ; }
tr	2	protected void handlecountermessage ( endpoint sender , countermessage message ) { terminationcounter counter = terminationcounters . get ( message . gettimezone ( ) ) ; if ( counter == null ) { counter = new terminationcounter ( 0 , 0 ) ; terminationcounters . put ( message . gettimezone ( ) , counter ) ; } counter . addtocounter ( message . getsent ( ) , message . getreceived ( ) , message . getsenderid ( ) ) ; checkfortermination ( message . gettimezone ( ) ) ; }
tr	3	public static void serialize ( string filepath ) { try ( objectoutputstream out = new objectoutputstream ( new fileoutputstream ( filepath ) ) ) { out . writeobject ( sernodes ) ; error = null ; } catch ( ioexception ex ) { error = ex . getmessage ( ) ; logger . getlogger ( tracker . class . getname ( ) ) . log ( level . severe , null , ex ) ; } system . out . println ( "info: data successfully saved! " + "\\n" ) ; }
tr	9	public gtfsplugin getplugin ( ) { if ( plugin == null ) { synchronized ( this ) { string pluginname = properties . getproperty ( "plugin" ) ; if ( pluginname == null ) { plugin = new defaultplugin ( ) ; } else { try { class < ? > pluginclass = class . forname ( pluginname ) ; boolean validplugin = false ; for ( class < ? > c : pluginclass . getinterfaces ( ) ) { if ( c . equals ( gtfsplugin . class ) ) { validplugin = true ; } } if ( validplugin ) plugin = ( gtfsplugin ) pluginclass . newinstance ( ) ; else throw new illegalargumentexception ( "the specified plugin is not found or not valid" ) ; } catch ( exception e ) { throw new illegalargumentexception ( "the specified plugin is not found or not valid" ) ; } } } } return plugin ; }
tr	7	public companybean readcompany ( int id ) throws exception { companybean companybean = null ; companydao companydao = new companydao ( ) ; companyobject companyobject = companydao . readcompany ( id ) ; if ( companyobject != null ) { companybean = new companybean ( companyobject ) ; if ( companyobject . getaddressid ( ) != 0 ) { addressdao addressdao = new addressdao ( ) ; addressobject addressobject = addressdao . readaddress ( companyobject . getaddressid ( ) ) ; if ( addressobject != null ) { statedao statedao = new statedao ( ) ; stateobject stateobject = statedao . readstate ( addressobject . getstateid ( ) ) ; countrydao countrydao = new countrydao ( ) ; countryobject countryobject = countrydao . readcountry ( addressobject . getcountryid ( ) ) ; addressbean addressbean = new addressbean ( addressobject , ( stateobject == null ) ? null : stateobject . getstatecode ( ) , ( countryobject == null ) ? null : countryobject . getcountryname ( ) ) ; companybean . setaddress ( addressbean ) ; } } } return companybean ; }
tr	10	private boolean checkvalid ( string ori , string target ) { int count = 0 ; for ( int i = 0 ; i < strlen ; i ++ ) { if ( ori . charat ( i ) != target . charat ( i ) ) count ++ ; if ( count > 1 ) { return false ; } } if ( count == 1 ) return true ; return false ; }
tr	6	private static void processgroupby ( final criteria crit , final query query ) throws torqueexception { uniquelist groupbyclause = query . getgroupbyclause ( ) ; uniquelist groupby = crit . getgroupbycolumns ( ) ; if ( groupby != null ) { for ( int i = 0 ; i < groupby . size ( ) ; i ++ ) { string columnname = ( string ) groupby . get ( i ) ; string column = ( string ) crit . getascolumns ( ) . get ( columnname ) ; if ( column == null ) { column = columnname ; } if ( column . indexof ( '.' ) != - 1 ) { groupbyclause . add ( column ) ; } else { throwmalformedcolumnnameexception ( "group by" , column ) ; } } } }
tr	6	static int chebyshev_init ( double dos [ ] , int nos , double eta ) { if ( nos < 1 ) return 0 ; double err = 0.0 ; int i = 0 ; for ( int ii = 1 ; ii <= nos ; ii ++ ) { i = nos - ii ; err += java . lang . math . abs ( dos [ i ] ) ; if ( err > eta ) { return i ; } } return i ; }
tr	8	public void draw ( graphics g ) { vector3d a ; vector3d b ; if ( numpoints <= 1 ) return ; g . setcolor ( this . getcolor ( ) ) ; for ( int i = 0 ; i < numpoints - 1 ; i ++ ) { a = object3d . points_ . elementat ( points [ i ] ) ; b = object3d . points_ . elementat ( points [ i + 1 ] ) ; boolean infov1 = object3d . infovs . elementat ( points [ i ] ) ; boolean infov2 = object3d . infovs . elementat ( points [ i + 1 ] ) ; if ( infov1 && infov2 ) { g . drawline ( ( int ) a . y , ( int ) a . z , ( int ) b . y , ( int ) b . z ) ; } } }
tr	7	public answerextractorimpl ( websearchapplication searchengine ) { this . searchengine = searchengine ; sa = new standardanalyzer ( version . lucene_41 ) ; try { file indexdir = new file ( settings . get ( "answer_index_path" ) ) ; if ( ! indexdir . exists ( ) ) { indexdir . mkdir ( ) ; } if ( indexdir . isdirectory ( ) ) { for ( file f : indexdir . listfiles ( ) ) { f . delete ( ) ; } } dir = new mmapdirectory ( indexdir ) ; } catch ( ioexception e ) { applicationhelper . printerror ( "unable to init indexed directory" , e ) ; } }
tr	3	private void readfile ( final string filename ) { try { textpane . setpage ( new file ( filename ) . tourl ( ) ) ; } catch ( ioexception e ) { editorkit kit = textpane . geteditorkit ( ) ; document document = textpane . getdocument ( ) ; try { document . remove ( 0 , document . getlength ( ) ) ; kit . read ( new filereader ( filename ) , document , 0 ) ; } catch ( exception ex ) { ex . printstacktrace ( ) ; } } }
tr	3	public void run ( ) { try { thread . sleep ( 300 ) ; bs = coreclass . fame . getbufferstrategy ( ) ; while ( true ) { g = ( graphics2d ) bs . getdrawgraphics ( ) ; drawboard ( ) ; drawobjects ( ) ; drawui ( ) ; drawpopups ( ) ; g . filloval ( coreclass . mightymouse . getmousecoordinate ( ) . getx ( ) , coreclass . mightymouse . getmousecoordinate ( ) . gety ( ) , 10 , 10 ) ; bs . show ( ) ; coreclass . coolkit . sync ( ) ; g . dispose ( ) ; } } catch ( exception e ) { e . printstacktrace ( ) ; } }
tr	5	@ override public void execute ( int index ) { switch ( index ) { case 0 : lr_3_tasks . getinstance ( ) . task1 ( ) ; break ; case 1 : lr_3_tasks . getinstance ( ) . task2 ( ) ; break ; case 2 : dircopy . main ( ) ; break ; case 3 : dirfindtext . main ( ) ; break ; case 4 : dirzip . main ( ) ; break ; } }
tr	4	@ override public void processcharacterbytes ( byte [ ] data ) { try { if ( data . length != 0 ) { if ( skipbytes < data . length ) { handleevent ( new stringevent ( new string ( data , skipbytes , data . length - skipbytes , state . currentencoding ) ) ) ; } skipbytes = 0 ; } } catch ( unsupportedencodingexception ex ) { throw new runtimeexception ( ex ) ; } }
tr	3	public void seek ( int frompos ) { try { if ( frompos > 0 ) { int framecounts = ( int ) ( frompos / header . getframeduration ( ) ) ; instream . seek ( header . getframesize ( ) * framecounts ) ; header . setframes ( framecounts ) ; } } catch ( exception e ) { e . printstacktrace ( ) ; } }
tr	2	public void recalculate ( ) { if ( this . elements . size ( ) <= this . height / 20 ) { this . scrollbarheight = this . height - 4 ; } else { float % = ( ( float ) this . height / 20.0f / this . elements . size ( ) ) ; this . scrollbarheight = ( int ) ( % * ( this . height - 4 ) ) ; } }
tr	8	public dragdroppanel ( ) { super ( null ) ; dragger = new collectivecomponentmover ( ) ; dragger . setdraginsets ( new insets ( 5 , 5 , 5 , 5 ) ) ; resizer = new componentresizer ( ) ; listeners = new arraylist < changelistener > ( ) ; highlightcolor = new color ( 0 , 0 , 255 , 255 / 4 ) ; bordersize = 4 ; highlightrectangle = null ; mouseadapter ma = new mouseadapter ( ) { private point start ; @ override public void mousepressed ( mouseevent me ) { start = me . getpoint ( ) ; highlightrectangle = new rectangle ( start ) ; dragger . clearselected ( ) ; repaint ( ) ; } @ override public void mousedragged ( mouseevent me ) { if ( start != null ) { highlightrectangle = new rectangle ( start ) ; highlightrectangle . add ( me . getpoint ( ) ) ; repaint ( ) ; } } @ override public void mousereleased ( mouseevent me ) { if ( start != null ) { for ( component comp : getcomponents ( ) ) { if ( highlightrectangle . contains ( comp . getbounds ( ) ) ) { dragger . select ( comp ) ; } } highlightrectangle = null ; repaint ( ) ; } } } ; addmouselistener ( ma ) ; addmousemotionlistener ( ma ) ; }
tr	2	private static string parseid ( stringparser jsid ) { stringbuilder b = new stringbuilder ( ) ; b . append ( jsid . poll ( ) ) ; char ch ; while ( isid ( ch = jsid . peek ( ) ) ) { b . append ( ch ) ; jsid . forward ( 1 ) ; } return b . tostring ( ) ; }
tr	2	public void switchwhiteboard ( string whiteboardid ) { if ( whiteboardid . equals ( "" ) ) sendmessage ( new newwhiteboardmessage ( ) ) ; else sendmessage ( new switchwhiteboardmessage ( whiteboardid ) ) ; }
tr	1	public int getbrushwidth ( ) { return brushwidth ; }
tr	6	private int generatordersignal ( double [ ] splittedtradinglist ) { int result = 0 ; double returnsum = 0 ; double returnave ; for ( int i = 0 ; i < ( splittedtradinglist . length - 1 ) ; i ++ ) { returnsum += ( splittedtradinglist [ i + 1 ] - splittedtradinglist [ i ] ) / splittedtradinglist [ i ] ; } returnave = returnsum / splittedtradinglist . length ; if ( ( returnave - threshold ) > 0 ) { result = buy ; } else if ( ( returnave + threshold ) < 0 ) { result = sell ; } return result ; }
tr	4	public void paintcomponent ( graphics g ) { super . paintcomponent ( g ) ; this . setbackground ( color . black ) ; graphics2d g2 = ( graphics2d ) g ; g2 . setfont ( new font ( "consolas" , 0 , 24 ) ) ; g2 . setcolor ( color . light_gray ) ; location loc = locationmanager . getloc ( cursor ) ; if ( ! loc . isempty ( ) ) { g2 . drawimage ( modelmanager . getmodel ( loc . getunit ( ) . getmodelname ( ) ) . getimage ( loc . getunit ( ) . getteam ( ) ) , 30 , 15 , 50 , 50 , this ) ; g2 . drawstring ( loc . getunit ( ) . getname ( ) + " x" + loc . getunit ( ) . gethealth ( ) , 90 , 50 ) ; g2 . drawstring ( "exp: " + loc . getunit ( ) . getexp ( ) , 250 , 50 ) ; } if ( loc . getterrain ( ) != - 1 ) { g2 . drawstring ( "terrain: " + loc . getterrain ( ) + "%" , 500 , 50 ) ; } }
tr	4	public static double loggammastirling ( double z ) { int shift = 0 ; while ( z < 2 ) { z ++ ; shift ++ ; } double result = half_log_two_pi + ( z - 0.5 ) * math . log ( z ) - z + 1 / ( 12 * z ) - 1 / ( 360 * z * z * z ) + 1 / ( 1260 * z * z * z * z * z ) ; while ( shift > 0 ) { shift -- ; z -- ; result -= math . log ( z ) ; } return result ; }
tr	7	public boolean setnextvalue ( int value ) { boolean isendmessage = false ; if ( messagepart == 0 ) { setlen ( value ) ; } else if ( messagepart == 1 ) { setchk ( value ) ; } else if ( messagepart == 2 ) { setseq ( value ) ; } else if ( messagepart == 3 ) { setstatus ( value > > 4 ) ; } else if ( messagepart == 4 ) { if ( ! isvalid ( ) ) { system . out . println ( "nieprawid\u0142owa wiadomo\u015b\u0107" ) ; isendmessage = false ; } else { sethr ( value ) ; isendmessage = true ; } } messagepart ++ ; return isendmessage ; }
tr	5	public void cliquefintour ( ) { if ( joueurencours . getpeuple ( ) . getterritoiresoccupes ( ) . isempty ( ) ) { new winwarn ( "veuillez tout d'abord prendre au moins un territoire" ) ; } else if ( ( etape == 0 || etape == 1 ) && game . getinstance ( ) . askconf ( "confirmer la fin du tour ?" ) ) { redeploiement ( ) ; } }
tr	10	public void readfromsocket ( ) throws ioexception { socketchannel channel = ( socketchannel ) selectionkey . channel ( ) ; bytebuffer buf = bytebuffer . allocate ( 1024 ) ; int numbytes = channel . read ( buf ) ; if ( numbytes <= 0 ) { close ( ) ; return ; } buf . flip ( ) ; charsetdecoder decoder = charset . defaultcharset ( ) . newdecoder ( ) ; string str = decoder . decode ( buf ) . tostring ( ) ; for ( int i = 0 , len = str . length ( ) ; i < len && avatar != null ; ++ i ) { char c = str . charat ( i ) ; if ( c == '\\n' ) { invokeavatar ( inputbuilder . tostring ( ) ) ; inputbuilder . setlength ( 0 ) ; } else if ( c >= 32 && c <= 127 ) { inputbuilder . append ( c ) ; } } }
tr	7	public void tk_comment ( ) { if ( tk_m ( "/*" ) ) { while ( ! m ( "*/" ) && ch != 0 ) { next ( ) ; } if ( ch != 0 ) { tk_m ( "*/" ) ; } } }
tr	5	public static string limitrepeatedcharacters ( string string , int limit ) { string processed = "" ; if ( ! string . isempty ( ) ) { char currentchar = string . charat ( 0 ) ; int matches = 1 ; processed = processed + currentchar ; for ( int i = 1 ; i < string . length ( ) ; i ++ ) { if ( currentchar == string . charat ( i ) ) { matches ++ ; if ( matches <= limit ) { processed = processed + string . charat ( i ) ; } } else { currentchar = string . charat ( i ) ; matches = 1 ; processed = processed + currentchar ; } } } return processed ; }
tr	2	public void setuphitbox ( ) { try { shieldhitbox = new ellipsehitbox ( activeimage . getwidth ( ) , activeimage . getheight ( ) ) ; } catch ( nullpointerexception ex ) { system . err . println ( "active image not initialized!" ) ; } }
tr	7	private void eliminatefallthroughifs ( body body ) { ifstmt ifs = null ; iterator < unit > unitit = body . getunits ( ) . snapshotiterator ( ) ; while ( unitit . hasnext ( ) ) { unit u = unitit . next ( ) ; if ( ifs != null && ifs . gettarget ( ) == u ) { body . getunits ( ) . remove ( ifs ) ; ifs = null ; } if ( u instanceof ifstmt ) ifs = ( ifstmt ) u ; } }
tr	2	public boolean empty ( ) { if ( area ( ) == 0 ) return true ; return false ; }
tr	3	public object start ( iapplicationcontext context ) throws exception { display display = platformui . createdisplay ( ) ; try { int returncode = platformui . createandrunworkbench ( display , new applicationworkbenchadvisor ( ) ) ; if ( returncode == platformui . return_restart ) return iapplication . exit_restart ; else return iapplication . exit_ok ; } finally { display . dispose ( ) ; } }
tr	2	public string shortitemname ( hackitem item ) { string name = item . object ; string name2 = abbr . get ( name ) ; return name2 == null ? name : name2 ; }
tr	9	static public string [ ] getconnectiondetails ( ) { string [ ] output = new string [ 2 ] ; string input = ( string ) joptionpane . showinputdialog ( null , "server address:" , "connect to chat server" , joptionpane . question_message , null , null , "localhost" ) ; if ( input == null || input . trim ( ) . length ( ) == 0 ) { system . exit ( 1 ) ; } output [ 0 ] = input . trim ( ) ; input = ( string ) joptionpane . showinputdialog ( null , "display name:" , "connect to chat server" , joptionpane . question_message , null , null , "test" ) ; if ( input == null || input . trim ( ) . length ( ) == 0 ) { system . exit ( 1 ) ; } output [ 1 ] = input . trim ( ) ; return output ; }
tr	7	public void paint ( graphics g ) { super . paint ( g ) ; if ( getnumber ( ) > 0 ) { g . drawimage ( badge , this . getwidth ( ) - 37 , 0 , null ) ; g . setcolor ( color . white ) ; if ( getnumber ( ) < 10 ) { g . setfont ( new font ( "helvetica neue" , font . plain , 22 ) ) ; g . drawstring ( integer . tostring ( getnumber ( ) ) , this . getwidth ( ) - 25 , 24 ) ; } else if ( getnumber ( ) >= 10 && getnumber ( ) < 100 ) { g . setfont ( new font ( "helvetica neue" , font . plain , 18 ) ) ; g . drawstring ( integer . tostring ( getnumber ( ) ) , this . getwidth ( ) - 29 , 23 ) ; } else if ( getnumber ( ) >= 100 ) { g . setfont ( new font ( "helvetica neue" , font . plain , 18 ) ) ; g . drawstring ( "99" , this . getwidth ( ) - 29 , 23 ) ; } } else if ( getnumber ( ) == - 1 ) { g . drawimage ( badge , this . getwidth ( ) - 34 , 0 , null ) ; } }
tr	6	private arraylist < action > extractnumberedactionchoices ( list < action > legalactions ) { action healaction = null ; for ( action action : legalactions ) { if ( action . getname ( ) . equals ( "heal" ) ) { healaction = action ; break ; } } arraylist < action > numberactions = new arraylist < action > ( ) ; if ( healaction != null ) { legalactions . remove ( healaction ) ; numberactions . add ( healaction ) ; } return numberactions ; }
tr	2	private imageplus readimage ( ) { opendialog od = new opendialog ( "open" , "" ) ; string directory = od . getdirectory ( ) ; string name = od . getfilename ( ) ; imageplus imp = null ; if ( name != null ) { string path = directory + name ; imp = new imageplus ( path ) ; } return imp ; }
tr	8	public void pushrequestresponse ( request r , byte [ ] block ) { if ( ! peerrequests . remove ( r ) ) { throw new runtimeexception ( "giving unrequested block! but whyyyy! =(" ) ; } else if ( constate != connectionstate . connected ) { throw new runtimeexception ( "this is invalid connection state isn't in connected mode!" ) ; } else if ( peer_choking ) { throw new runtimeexception ( "we are being choked! not valid to send silly!" ) ; } try { maintenance += 13 ; upload += block . length ; mp . piece ( sockout , r . index , r . begin , block ) ; } catch ( ioexception e ) { constate = connectionstate . closed ; } }
tr	1	public void setaccountid ( string saccountid ) { maccountid = saccountid ; }
tr	4	public resultset executequery ( ) throws sqlexception { string sql = "" ; if ( isgetall ( ) ) { sql = select + getquerybuilder ( ) . getselectvalue ( ) + from + getquerybuilder ( ) . gettablename ( ) + ";" ; try { getconnection ( false ) ; getconn ( ) ; string cleansql = stringescapeutils . escapesql ( sql ) ; sqlstatement = getconn ( ) . preparestatement ( cleansql ) ; } catch ( sqlexception e ) { e . printstacktrace ( ) ; } } else { sql = select + getquerybuilder ( ) . getselectvalue ( ) + from + getquerybuilder ( ) . gettablename ( ) + where + getwhere ( ) . getwherekey ( ) + " " + getwhere ( ) . getwhereoperator ( ) + " ?;" ; try { getconnection ( false ) ; getconn ( ) ; string cleansql = stringescapeutils . escapesql ( sql ) ; sqlstatement = getconn ( ) . preparestatement ( cleansql ) ; sqlstatement . setstring ( 1 , getwhere ( ) . getwherevalue ( ) ) ; } catch ( sqlexception e ) { e . printstacktrace ( ) ; } } return sqlstatement . executequery ( ) ; }
tr	9	public static chromosome [ ] cross ( chromosome parent1 , chromosome parent2 , float mutationrate , int crossoverindex ) { chromosome p [ ] = new chromosome [ ] { parent1 , parent2 } ; final int c1 = math . abs ( rnd . nextint ( ) ) % 2 ; final int c2 = ( c1 + 1 ) % 2 ; chromosome c [ ] = new chromosome [ ] { new chromosome ( p [ 0 ] . usedivisor ) , new chromosome ( p [ 0 ] . usedivisor ) } ; c [ c1 ] . score = p [ c1 ] . score * ( double ) crossoverindex / ( double ) c [ c1 ] . g . length + p [ c2 ] . score * ( double ) ( c [ c1 ] . g . length - crossoverindex ) / ( double ) c [ c1 ] . g . length ; c [ c2 ] . score = p [ c2 ] . score * ( double ) crossoverindex / ( double ) c [ c1 ] . g . length + p [ c1 ] . score * ( double ) ( c [ c1 ] . g . length - crossoverindex ) / ( double ) c [ c1 ] . g . length ; int p1 = c1 , p2 = c2 ; for ( int i = 0 ; i < p [ c1 ] . g . length ; i ++ ) { if ( i == crossoverindex ) { p1 = c2 ; p2 = c1 ; } if ( rnd . nextfloat ( ) < mutationrate ) { c [ c1 ] . g [ i ] = p [ p1 ] . g [ i ] * ( 1f + ( float ) rnd . nextgaussian ( ) ) ; } else { c [ c1 ] . g [ i ] = p [ p1 ] . g [ i ] ; } if ( rnd . nextfloat ( ) < mutationrate ) { c [ c2 ] . g [ i ] = p [ p2 ] . g [ i ] * ( 1f + ( float ) rnd . nextgaussian ( ) ) ; } else { c [ c2 ] . g [ i ] = p [ p2 ] . g [ i ] ; } } return c ; }
tr	4	public laterthanfilter createperctimefilter ( double perc , hackfilter ... fis ) { arraylist < long > timestamps = new arraylist < long > ( ) ; outerloop : for ( hackresult res : allhacks ) { for ( hackfilter fi : fis ) { if ( ! fi . accept ( res ) ) continue outerloop ; } timestamps . add ( ( long ) res . timestamp ) ; } collections . sort ( timestamps ) ; int idx = ( int ) math . round ( ( timestamps . size ( ) - 1 ) * ( 1.0 - perc ) ) ; return new laterthanfilter ( timestamps . get ( idx ) ) ; }
tr	7	private int countcardsinhand ( bufferedimage image ) { int y = handrow + 2 ; int cardcount = 0 ; boolean currentlyyellow = false ; int stripelength = 0 ; int gaplength = 0 ; for ( int x = 391 ; x < 1100 ; ++ x ) { if ( issufficientlyyellow ( image . getrgb ( x , y ) ) ) { gaplength = 0 ; ++ stripelength ; if ( ! currentlyyellow ) { currentlyyellow = true ; } } else { if ( currentlyyellow ) { if ( stripelength > 1 ) { if ( gaplength > 4 ) { cardcount ++ ; logger . debug ( "start: " + ( x - stripelength ) + " length: " + stripelength ) ; gaplength = 0 ; stripelength = 0 ; currentlyyellow = false ; } else { gaplength ++ ; } } } } } logger . info ( "card count: " + cardcount ) ; return cardcount ; }
tr	6	@ override public void tick ( input input , double delta ) { super . tick ( input , delta ) ; entitycommand cmd = null ; if ( list . size ( ) != 0 ) { cmd = list . get ( 0 ) ; } if ( cmd != null ) { cmd . tick ( input , delta ) ; if ( cmd . isdone ( ) ) { list . remove ( cmd ) ; } } }
tr	6	@ override public void update ( ) { if ( fpsmanager . totalframe ( ) % 45 == 0 ) { pressstarttext . togglevisible ( ) ; } if ( ! key . escape . ispressed ( ) && key . anykeypressed ( ) ) { gamescenemanager . getinstance ( ) . changesceneifnotnull ( nextscene ) ; } }
tr	1	public int getlots ( ) { return mlots ; }
tr	7	public boolean equals ( final shape shape ) { if ( shape != null ) { if ( shape instanceof spline ) { final spline spline = ( spline ) shape ; if ( spline . np == np ) { for ( int i = 0 , ip2 = 2 ; i < np ; ++ i , ++ ip2 ) if ( ! spline . p [ i ] . equals ( p [ i ] ) || ! spline . c [ ip2 ] . equals ( c [ ip2 ] ) ) return false ; return true ; } } } return false ; }
tr	10	@ override public void handle ( ihttprequest httprequest , ihttpresponse httpresponse ) throws ioexception { try { string command = httprequest . getparametro ( "command" ) ; string [ ] comandi = command . split ( "_" ) ; for ( int i = 0 ; i < comandi . length ; i ++ ) { string comando = comandi [ i ] ; if ( ! comando . isempty ( ) ) { string key = comando . substring ( 0 , 2 ) ; string value = comando . substring ( 2 ) ; if ( "kp" . equals ( key ) ) { kp . handle ( value ) ; } else if ( "kd" . equals ( key ) ) { kd . handle ( value ) ; } else if ( "ku" . equals ( key ) ) { ku . handle ( value ) ; } else if ( "mu" . equals ( key ) ) { mu . handle ( value ) ; } else if ( "md" . equals ( key ) ) { md . handle ( value ) ; } else if ( "rc" . equals ( key ) ) { rc . handle ( value ) ; } } } } catch ( exception e ) { e . printstacktrace ( ) ; } httpresponse . sendok ( ) ; }
tr	6	public static string unitstostring ( int n ) { if ( n == 3 ) return "hundred" ; else if ( n >= 4 && n <= 6 ) return "thousand" ; else if ( n >= 7 && n <= 9 ) return "million" ; else return "billion" ; }
tr	6	integer attributetoid ( string attr ) { if ( usernomen ) return 1 ; for ( int i = 1 ; i < attributes . length ; i ++ ) if ( attributes [ i ] . tolowercase ( ) . equals ( attr . tolowercase ( ) ) ) return i ; return 1 ; }
tr	7	@ override public void actionperformed ( actionevent e ) { string syote1 = this . syotealue1 . gettext ( ) ; string syote2 = this . syotealue2 . gettext ( ) ; paattelyntarkistaja paattelyntarkistaja = new paattelyntarkistaja ( syote1 , syote2 ) ; this . container . remove ( this . virheilmoitus ) ; this . container . remove ( this . virheilmoitus2 ) ; this . container . remove ( this . tulostealue ) ; string syntaksi1 = paattelyntarkistaja . tarkistasyntaksi1 ( ) ; string syntaksi2 = paattelyntarkistaja . tarkistasyntaksi2 ( ) ; if ( syntaksi1 . contentequals ( "true" ) && syntaksi2 . contentequals ( "true" ) ) { paattelyntarkistaja . generoi ( ) ; if ( paattelyntarkistaja . voidaanpaatella ( ) ) { this . tulostealue = new jlabel ( "spock: that is quite logical<litcomma> captain. (true)" ) ; } else { this . tulostealue = new jlabel ( "<html><body>spock: that is illogical<litcomma> ensign. odors cannot travel<br>through the vacuum of space. (false)</body></html>" ) ; } this . container . add ( this . tulostealue ) ; this . tulostealue . setbounds ( 50 , 220 , 380 , 100 ) ; } else { if ( ! syntaksi1 . contentequals ( "true" ) ) { this . virheilmoitus = new jlabel ( syntaksi1 ) ; this . container . add ( this . virheilmoitus ) ; this . virheilmoitus . setbounds ( 50 , 100 , 400 , 30 ) ; } if ( ! syntaksi2 . contentequals ( "true" ) ) { this . virheilmoitus2 = new jlabel ( syntaksi2 ) ; this . container . add ( this . virheilmoitus2 ) ; this . virheilmoitus2 . setbounds ( 50 , 160 , 400 , 30 ) ; } } this . container . repaint ( ) ; }
tr	1	private void rendernodename ( final nestedtimerpath root ) throws ioexception { appendpathindent ( sb , root . getlevel ( ) ) ; sb . append ( root . getleaftimername ( ) ) ; sb . append ( lineend ) ; }
tr	6	@ override public void dodamage ( int damage ) { if ( ! debugcheats . nodamage || damage < 0 ) super . dodamage ( damage ) ; if ( isdead ( ) ) { getlocation ( ) . settile ( tile . gravestone ) ; } }
tr	6	private boolean needssplit ( ) { if ( length < subtreestepsize ) return false ; for ( int i = rootdimension ; i < leafdimension ; i ++ ) if ( this . factor . selections [ i ] != - 1 ) return true ; return false ; }
tr	5	public static void prepareprocess ( string filename ) { fileprefix = filename . replace ( ".txt" , "" ) ; try { wtxt = new bufferedwriter ( new outputstreamwriter ( new fileoutputstream ( fileprefix + ".tokens" ) , "utf-8" ) ) ; wpos = new bufferedwriter ( new outputstreamwriter ( new fileoutputstream ( fileprefix + ".pos" ) , "utf-8" ) ) ; wparse = new bufferedwriter ( new outputstreamwriter ( new fileoutputstream ( fileprefix + ".parse" ) , "utf-8" ) ) ; wdep = new bufferedwriter ( new outputstreamwriter ( new fileoutputstream ( fileprefix + ".dep" ) , "utf-8" ) ) ; if ( x . getboolean ( "segmentation" ) ) { wseg = new bufferedwriter ( new outputstreamwriter ( new fileoutputstream ( fileprefix + ".segment" ) , "utf-8" ) ) ; } outputfile = fileprefix + ".pbf" ; outputstream = new fileoutputstream ( outputfile ) ; string predfile = x . get ( "outputfile" ) ; if ( predfile != null ) { outputwriter = new bufferedwriter ( new outputstreamwriter ( new fileoutputstream ( predfile ) , "utf-8" ) ) ; } } catch ( exception e ) { e . printstacktrace ( ) ; } }
tr	7	void savetostream ( manifest manifest , outputstream savestream ) throws tippexception { try ( inputstream payloadis = getpayload ( ) ) { document document = new manifestdombuilder ( manifest ) . makedocument ( ) ; if ( keypair != null ) { new manifestsigner ( ) . sign ( document , payloadis , keypair ) ; } collectingerrorhandler errorhandler = new collectingerrorhandler ( ) ; if ( errorhandler . geterrors ( ) . size ( ) > 0 ) { throw new tippexception ( "saved manifest was invalid" ) ; } transformerfactory factory = transformerfactory . newinstance ( ) ; transformer transformer = factory . newtransformer ( ) ; transformer . transform ( new domsource ( document ) , new streamresult ( savestream ) ) ; } catch ( tippexception e ) { throw e ; } catch ( exception e ) { throw new tippexception ( e ) ; } }
tr	10	public void kidchanged ( treenodepagewrapper kidwrapper , string message , long value ) { kidsinscanning = 0 ; kidstosave = 0 ; for ( @ suppresswarnings ( "unchecked" ) enumeration < defaultmutabletreenode > children = children ( ) ; children . hasmoreelements ( ) ; ) { treenodepagewrapper kid = ( treenodepagewrapper ) children . nextelement ( ) ; if ( kid . downloading || kid . downloadpageq ) kidsinscanning ++ ; if ( kid . mustsavepage || kid . saving ) kidstosave ++ ; } }
tr	7	protected void rotatetoangle ( double angle ) { if ( math . abs ( angle - faceangle ) >= 5 ) { double [ ] distances = calculator . getdistancesbetweenangles ( faceangle , angle ) ; if ( distances [ 0 ] < distances [ 1 ] ) { if ( distances [ 0 ] > angleicrement ) { changeimage ( imagemovementstate , imagerotationstate . rotatingleft ) ; rotate ( rotationstate . turningleft ) ; } } else { if ( distances [ 1 ] > angleicrement ) { changeimage ( imagemovementstate , imagerotationstate . rotatingright ) ; rotate ( rotationstate . turningright ) ; } } } else { if ( imagerotationstate == imagerotationstate . rotatingright ) { changeimage ( imagemovementstate , imagerotationstate . idle ) ; rotate ( rotationstate . turningrightdrifting ) ; } else if ( imagerotationstate == imagerotationstate . rotatingleft ) { changeimage ( imagemovementstate , imagerotationstate . idle ) ; rotate ( rotationstate . turningleftdrifting ) ; } } }
tr	9	static double [ ] gammalims ( double xmin , double xmax ) { double alnbig , alnsml , xln , xold ; int i ; alnsml = java . lang . math . log ( d1mach ( 1 ) ) ; xmin = - alnsml ; find_xmax : { for ( i = 1 ; i <= 10 ; ++ i ) { xold = xmin ; xln = java . lang . math . log ( xmin ) ; xmin -= xmin * ( ( xmin + .5 ) * xln - xmin - .2258 + alnsml ) / ( xmin * xln + .5 ) ; if ( java . lang . math . abs ( xmin - xold ) < .005 ) { xmin = - ( xmin ) + .01 ; break find_xmax ; } } throw new java . lang . arithmeticexception ( "math error: noconv" ) ; } alnbig = java . lang . math . log ( d1mach ( 2 ) ) ; xmax = alnbig ; done : { for ( i = 1 ; i <= 10 ; ++ i ) { xold = xmax ; xln = java . lang . math . log ( xmax ) ; xmax -= xmax * ( ( xmax - .5 ) * xln - xmax + .9189 - alnbig ) / ( xmax * xln - .5 ) ; if ( java . lang . math . abs ( xmax - xold ) < .005 ) { xmax += - .01 ; break done ; } } throw new java . lang . arithmeticexception ( "math error: noconv" ) ; } xmin = fmax2 ( xmin , - ( xmax ) + 1 ) ; double retval [ ] = new double [ 2 ] ; retval [ 0 ] = xmin ; retval [ 1 ] = xmax ; return ( retval ) ; }
tr	8	public int getrememberedposition ( ) { if ( ! abletoformat ) { return originalposition ; } int accruedinputindex = 0 , currentoutputindex = 0 ; while ( accruedinputindex < positiontoremember && currentoutputindex < currentoutput . length ( ) ) { if ( accruedinputwithoutformatting . charat ( accruedinputindex ) == currentoutput . charat ( currentoutputindex ) ) { accruedinputindex ++ ; } currentoutputindex ++ ; } return currentoutputindex ; }
tr	5	public static void setlook ( ) { try { uimanager . setlookandfeel ( uimanager . getsystemlookandfeelclassname ( ) ) ; } catch ( unsupportedlookandfeelexception e ) { } catch ( classnotfoundexception e ) { } catch ( instantiationexception e ) { } catch ( illegalaccessexception e ) { } }
tr	9	@ override public void indexdocuments ( string documentpath ) throws exception { file documentdir = new file ( documentpath ) ; if ( ! ( documentdir . exists ( ) && documentdir . isdirectory ( ) ) ) { throw new exception ( "document indexer: unable to find document directory." ) ; } collection < file > alldocs = new arraylist < file > ( ) ; addfiles ( documentdir , alldocs ) ; indexwriterconfig config = new indexwriterconfig ( version . lucene_41 , sa ) ; try { iw = new indexwriter ( dir , config ) ; for ( file file : alldocs ) { indexfile ( file ) ; } iw . close ( ) ; } catch ( ioexception e ) { applicationhelper . printerror ( "document indexer: unable to locate raw documents" , e ) ; } }
tr	9	private void insertarjugador ( ) { if ( txtusuariojugador . gettext ( ) . equals ( "" ) || txtcontrasenajugador . gettext ( ) . equals ( "" ) || txtcorreojugador . gettext ( ) . equals ( "" ) || txtpaisjugador . gettext ( ) . equals ( "" ) || datejugador . getdate ( ) == null ) { mensaje . mensajeerror ( "los datos no son correctos<litcomma> compruebalos" ) ; } else { jugador jugador = new jugador ( ) ; jugador . setusuario ( txtusuariojugador . gettext ( ) ) ; jugador . setcontrasena ( txtcontrasenajugador . gettext ( ) ) ; jugador . setcorreoelectronico ( txtcorreojugador . gettext ( ) ) ; jugador . setpais ( txtpaisjugador . gettext ( ) ) ; jugador . setfechanacimiento ( datejugador . getdate ( ) ) ; this . tablajugadores . insertar ( this . esnuevojugador , jugador , this . jugador ) ; cancelarjugador ( ) ; try { this . cbjugadorpersonaje . listar ( ) ; this . cbatacantebatalla . listar ( ) ; this . cbdefensorbatalla . listar ( ) ; } catch ( sqlexception e1 ) { e1 . printstacktrace ( ) ; } try { tablajugadores . listar ( ) ; } catch ( sqlexception e ) { e . printstacktrace ( ) ; } } }
tr	3	private void loadqurandata ( ) { xstream xstream = new xstream ( new staxdriver ( ) ) ; xstream . processannotations ( qurandata . class ) ; xstream . autodetectannotations ( true ) ; inputstream is = null ; is = loader . class . getresourceasstream ( quran_data_xml_path ) ; if ( is != null ) { this . qurandata = ( qurandata ) xstream . fromxml ( is ) ; try { is . close ( ) ; } catch ( ioexception e ) { system . err . println ( "unable to close inputstream for quran data resource: " + e . getmessage ( ) ) ; } } else { system . err . println ( "unable to acquire inputstream for quran data resource: " + quran_data_xml_path ) ; } }
tr	10	public static void addmonth ( string monthname , defaulttablemodel table ) { if ( ! insert . contains ( monthname ) ) { string tempinsert = "['" + monthname + "'<litcomma>" + "[" ; for ( int c = 0 ; c < table . getcolumncount ( ) ; c ++ ) { tempinsert += "['" + table . getcolumnname ( c ) + "'<litcomma>" ; for ( int r = 0 ; r < table . getrowcount ( ) ; r ++ ) { if ( table . getvalueat ( r , c ) != null ) { tempinsert += "'" + table . getvalueat ( r , c ) + "'" ; if ( r < table . getrowcount ( ) - 1 ) { tempinsert += "<litcomma>" ; } } } tempinsert += "]" ; if ( c < table . getcolumncount ( ) - 1 ) { tempinsert += "<litcomma>" ; } } tempinsert += "]]<litcomma>" ; insert += tempinsert ; } }
tr	5	public void readfromsave ( datatag tag ) { reloadmap ( tag . readstring ( "map" ) ) ; gametime = tag . readint ( "gametime" ) ; nightalhpa = tag . readfloat ( "nightshade" ) ; datalist list = tag . readlist ( "content" ) ; for ( int i = 0 ; i < list . data ( ) . size ( ) ; i ++ ) { datatag dt = list . readarray ( i ) ; string uin = dt . readstring ( "uin" ) ; mapobject mo = blocks . loadmapobjectfromstring ( uin , tilemap , this ) ; if ( mo == null ) mo = entity . createentityfromuin ( uin , tilemap , this ) ; if ( mo != null ) { mo . readfromsave ( dt ) ; listwithmapobjects . add ( mo ) ; } else { system . out . println ( "the entity for " + uin + " was not recognized. skipped loading this entity" ) ; } } }
tr	8	public static void sendhtmlemail ( string mailserver , boolean attach , boolean inline ) throws emailexception , malformedurlexception { htmlemail email = new htmlemail ( ) ; if ( google . equals ( mailserver ) ) setgoogleemail ( email ) ; email . addto ( "tim_ph@yahoo.com" , "tim yahoo" ) ; email . setsubject ( "test commonsmail as html only" ) ; if ( attach ) { emailattachment attachment = getattachment ( ) ; email . attach ( attachment ) ; } if ( ! inline ) { string htmlemailtemplate = "<html>apache foundation <img src=\\"http://www.apache.org/images/asf_logo_wide.gif\\"></html>" ; email . sethtmlmsg ( htmlemailtemplate ) ; } else { url url = new url ( "http://www.apache.org/images/asf_logo_wide.gif" ) ; string cid = email . embed ( url , "apache logo" ) ; email . sethtmlmsg ( "<html>the apache logo - <img src=\\"cid:" + cid + "\\"></html>" ) ; } email . settextmsg ( "your email client does not support html messages" ) ; email . send ( ) ; }
tr	3	public void append ( framedata nextframe ) throws invalidframeexception { bytebuffer b = nextframe . getpayloaddata ( ) ; if ( unmaskedpayload == null ) { unmaskedpayload = bytebuffer . allocate ( b . remaining ( ) ) ; b . mark ( ) ; unmaskedpayload . put ( b ) ; b . reset ( ) ; } else { b . mark ( ) ; unmaskedpayload . position ( unmaskedpayload . limit ( ) ) ; unmaskedpayload . limit ( unmaskedpayload . capacity ( ) ) ; if ( b . remaining ( ) > unmaskedpayload . remaining ( ) ) { bytebuffer tmp = bytebuffer . allocate ( b . remaining ( ) + unmaskedpayload . capacity ( ) ) ; unmaskedpayload . flip ( ) ; tmp . put ( unmaskedpayload ) ; tmp . put ( b ) ; unmaskedpayload = tmp ; } else { unmaskedpayload . put ( b ) ; } unmaskedpayload . rewind ( ) ; b . reset ( ) ; } fin = nextframe . isfin ( ) ; }
tr	5	public byte [ ] encode ( object obj ) { final object [ ] ary = ( object [ ] ) obj ; final bytearrayoutputstream out = new bytearrayoutputstream ( ) ; final dataoutputstream dos = new dataoutputstream ( out ) ; for ( int x = 0 ; x < ary . length ; x ++ ) { try { final short tipe = datafield . gettype ( ary [ x ] ) ; final byte [ ] data = datafield . encode ( ary [ x ] , tipe ) ; final int size = datafield . getdatatype ( tipe ) . getsize ( ) ; dos . write ( byteutil . rendershortbyte ( tipe ) ) ; if ( data != null ) { if ( size < 0 ) { dos . writeshort ( data . length ) ; } dos . write ( data ) ; } else { dos . writeshort ( 0 ) ; } } catch ( final throwable t ) { system . err . println ( "array object of type " + ary [ x ] . getclass ( ) . getsimplename ( ) + " is not supported in dataframes" ) ; } } return out . tobytearray ( ) ; }
tr	9	public list < variableappearance > getvariableappearances ( fileobfuscationstructure structure , boolean firstscan ) { list < variableappearance > result = new arraylist < variableappearance > ( ) ; for ( istringanalyser analyzer : stringanalysers ) { if ( firstscan || ( analyzer . istwoscansanalyzer ( ) ) ) { if ( analyzer . isoutofcontextanalysis ( ) ) { string content = structure . getfilecontent ( ) ; parsingcontext entirefilecontext = new parsingcontext ( parsingcontexttype . entirefile , 0 , content . length ( ) , content ) ; if ( firstscan ) { result . addall ( analyzer . getappearances ( entirefilecontext ) ) ; } else { result . addall ( analyzer . getaltappearances ( entirefilecontext ) ) ; } } else { for ( parsingcontext context : structure . getfilecontexts ( ) ) { if ( analyzer . supportparsingcontext ( context ) ) { if ( firstscan ) { result . addall ( analyzer . getappearances ( context ) ) ; } else { result . addall ( analyzer . getaltappearances ( context ) ) ; } } } } } } return result ; }
tr	2	@ override public void handlecatchall ( string path_remainder , request request ) { for ( handler handler : catch_all_handlers_ ) { handler . handlecatchall ( path_remainder , request ) ; } }
tr	4	protected void customizepopup ( basiccombopopup popup ) { scrollpane = getscrollpane ( popup ) ; if ( popupwider ) popupwider ( popup ) ; checkhorizontalscrollbar ( popup ) ; component combobox = popup . getinvoker ( ) ; point location = combobox . getlocationonscreen ( ) ; if ( popupabove ) { int height = popup . getpreferredsize ( ) . height ; popup . setlocation ( location . x , location . y - height ) ; } else { int height = combobox . getpreferredsize ( ) . height ; popup . setlocation ( location . x , location . y + height - 1 ) ; popup . setlocation ( location . x , location . y + height ) ; } }
tr	10	public void act ( ) { if ( ! dead ) { getlocation ( ) ; animation ( ) ; damagedetection ( ) ; if ( moveup && y < groundheight && ! abilityr && ! abilityh && ! hurt ) { y += 3 ; } } else { if ( maxdieframe > dieframe ) { dieframe ++ ; mage = new greenfootimage ( "mage//magedie//magedie" + ( ( dieframe / 6 ) + 1 ) + ".png" ) ; if ( ! movementdirection ) { mage . mirrorhorizontally ( ) ; } setimage ( mage ) ; } else if ( maxdieframe == dieframe ) { setimage ( new greenfootimage ( "ballsi.png" ) ) ; getworld ( ) . removeobject ( shadow ) ; dieframe ++ ; } } }
tr	8	private static void createtopicpaths ( string home_path , hashmap < string , generictesthandler > handlers ) { directory directory = directory . instance ; for ( int n = 1 ; n <= 3 ; n ++ ) { for ( int i = 1 ; i <= 2 ; i ++ ) { string topic_name = "/topics/category" + n + "/topic" + i ; string topic_path = home_path + topic_name ; assert . asserttrue ( directory . createpath ( topic_path ) ) ; if ( handlers != null ) { generictesthandler handler = new generictesthandler ( topic_name ) ; assert . asserttrue ( directory . addhandler ( topic_path , handler ) ) ; handlers . put ( handler . getname ( ) , handler ) ; } } } if ( handlers != null ) { generictesthandler handler = new generictesthandler ( "/topics/*" , true ) ; assert . asserttrue ( directory . addhandler ( home_path + "/topics" , handler ) ) ; handlers . put ( handler . getname ( ) , handler ) ; } }
tr	10	private model getchildmodel ( ) { if ( super . animation >= 0 && super . animationdelay == 0 ) { int frameid2 = animationsequence . animations [ super . animation ] . frame2ids [ super . currentanimationframe ] ; int frameid1 = - 1 ; if ( super . queuedanimationid >= 0 && super . queuedanimationid != super . standanimationid ) frameid1 = animationsequence . animations [ super . queuedanimationid ] . frame2ids [ super . queuedanimationframe ] ; return npcdefinition . getchildmodel ( frameid1 , frameid2 , animationsequence . animations [ super . animation ] . flowcontrol ) ; } int frameid2 = - 1 ; if ( super . queuedanimationid >= 0 ) frameid2 = animationsequence . animations [ super . queuedanimationid ] . frame2ids [ super . queuedanimationframe ] ; return npcdefinition . getchildmodel ( - 1 , frameid2 , null ) ; }
tr	10	public void run ( ) { while ( true ) { system . out . println ( "running" ) ; if ( gui . connected ) { system . out . println ( "connected" ) ; try { int o = integer . parseint ( ( string ) infromserver . readobject ( ) ) ; switch ( o ) { case 3 : { gui . update ( ( string ) infromserver . readobject ( ) ) ; break ; } case 4 : { gui . update ( "[list of users:]" ) ; string name ; while ( ! ( ( name = ( string ) infromserver . readobject ( ) ) . equalsignorecase ( "5" ) ) ) { gui . update ( "> " + name ) ; } gui . update ( "[done.]" ) ; break ; } case 6 : { gui . update ( ( string ) infromserver . readobject ( ) ) ; break ; } case 9 : { gui . update ( "[severing connection...]" ) ; outtoserver . close ( ) ; infromserver . close ( ) ; clientsocket . close ( ) ; gui . connected = false ; gui . update ( "[connection severed.]" ) ; break ; } default : { gui . update ( "[received garbage from server.]" ) ; } } system . out . println ( "listening" ) ; } catch ( ioexception e ) { system . out . println ( "ioexception encountered while listening to server." ) ; gui . disconnect ( ) ; gui . update ( "[server disconnected unexpectedly.]" ) ; } catch ( classnotfoundexception e ) { system . out . println ( "object received not a string." ) ; } } } }
tr	7	@ override public boolean prehandle ( httpservletrequest request , httpservletresponse response , object handler ) throws exception { string uri = request . getrequesturi ( ) ; if ( ! uri . endswith ( "index.htm" ) && ! uri . endswith ( "login.htm" ) && ! uri . endswith ( "logout.htm" ) ) { login userdata = ( login ) request . getsession ( ) . getattribute ( login . class . getname ( ) ) ; if ( userdata == null || util . nulloremptyorblank ( userdata . getemail ( ) ) || ( new date ( ) . gettime ( ) - userdata . getlastaccessed ( ) ) > 30 * 60 * 1000 ) { response . sendredirect ( "index.htm" ) ; return false ; } else { userdata . setlastaccessed ( new date ( ) . gettime ( ) ) ; } } return true ; }
tr	4	public static string ia2str ( int [ ] x ) { stringbuilder res = new stringbuilder ( x . length ) ; int sum = 0 ; for ( int i : x ) sum += i ; res . append ( sum ) . append ( ": " ) ; for ( int i : x ) res . append ( i ) ; return res . tostring ( ) ; }
tr	5	public boolean connect ( string ip , int port ) { try { clientsocket = new socket ( ip , port ) ; outtoserver = new objectoutputstream ( clientsocket . getoutputstream ( ) ) ; infromserver = new objectinputstream ( clientsocket . getinputstream ( ) ) ; while ( ( ( string ) infromserver . readobject ( ) ) . startswith ( "1" ) ) { gui . requestname ( ) ; outtoserver . writeobject ( gui . name ) ; } } catch ( unknownhostexception e ) { system . out . println ( "unknown host." ) ; clientsocket = null ; outtoserver = null ; infromserver = null ; gui . connected = false ; return false ; } catch ( ioexception e ) { system . out . println ( "ioexception encountered while connecting." ) ; clientsocket = null ; outtoserver = null ; infromserver = null ; gui . connected = false ; return false ; } catch ( classnotfoundexception e ) { system . out . println ( "object received not a string." ) ; } gui . connected = true ; return true ; }
tr	6	private location getpassantlocation ( piece pawn , location location ) { move lastmove = pawn . getboard ( ) . getlast ( ) ; if ( lastmove != null ) { if ( lastmove . getmoving ( ) . gettype ( ) == pawn ) { location lastnewlocation = lastmove . getnewlocation ( ) ; if ( location . row == lastnewlocation . row && math . abs ( location . column - lastnewlocation . column ) == 1 && math . abs ( lastmove . getoldlocation ( ) . row - lastnewlocation . row ) == 2 ) { return lastnewlocation . move ( pawn . forward ( ) ) ; } } } return null ; }
tr	3	private void starttransport ( ) { try { agc1 . start ( ) ; aclmessage msg = new aclmessage ( constants . message ) ; purposehandler ph = new purposehandler ( constants . start ) ; msg . setcontentobject ( ph ) ; for ( string name : transportagents ) { msg . addreceiver ( createaid ( name ) ) ; } dowait ( 10000 ) ; send ( msg ) ; } catch ( staleproxyexception | ioexception e ) { exceptionutils . handleexception ( e ) ; } }
tr	9	public mapbuilder getmapbuilder ( string classname ) throws torqueexception { try { mapbuilder mb = ( mapbuilder ) mapbuildercache . get ( classname ) ; if ( mb == null ) { mb = ( mapbuilder ) class . forname ( classname ) . newinstance ( ) ; mapbuildercache . put ( classname , mb ) ; } if ( mb . isbuilt ( ) ) { return mb ; } try { mb . dobuild ( ) ; } catch ( exception e ) { mapbuildercache . remove ( classname ) ; throw e ; } return mb ; } catch ( exception e ) { log . error ( "getmapbuilder failed trying to instantiate: " + classname , e ) ; throw new torqueexception ( e ) ; } }
tr	2	public void draggesturerecognized ( draggestureevent dge ) { system . out . println ( "draggesturerecognized" ) ; point clickpoint = dge . getdragorigin ( ) ; int index = locationtoindex ( clickpoint ) ; if ( index == - 1 ) return ; object target = getmodel ( ) . getelementat ( index ) ; transferable trans = new rjltransferable ( target ) ; draggedindex = index ; dragsource . startdrag ( dge , cursor . getdefaultcursor ( ) , trans , this ) ; }
tr	6	public static int calculamoda ( final imagem imagem , imagemiterator iterador ) { final int [ ] contagem = new int [ 256 ] ; for ( int i = 0 ; i < contagem . length ; i ++ ) { contagem [ i ] = 0 ; } iterador . iterate ( imagem , new imageiteratorcallback ( ) { @ override public void callback ( int x , int y ) { contagem [ imagem . getpixel ( x , y ) ] ++ ; } } ) ; int maior = 0 ; int maiori = 0 ; for ( int i = 0 ; i < contagem . length ; i ++ ) { if ( contagem [ i ] > maior ) { maior = contagem [ i ] ; maiori = i ; } } return maiori ; }
tr	10	public void actionperformed ( actionevent ae ) { string action_com = ae . getactioncommand ( ) ; if ( action_com != null && action_com . equals ( "anadirimagen" ) ) { model . addimage ( view . list . getmodel ( ) . getsize ( ) ) ; } else if ( action_com != null && action_com . equals ( "borrarimagen" ) ) { if ( ! ( view . list . isselectionempty ( ) ) ) { if ( view . list . getmodel ( ) . getsize ( ) == 1 ) { if ( roimanager . getinstance ( ) != null ) { roimanager . getinstance ( ) . close ( ) ; } imagemanager . getinstance ( ) . close ( ) ; if ( windowmanager . getcurrentimage ( ) != null ) { windowmanager . getcurrentimage ( ) . close ( ) ; windowmanager . settempcurrentimage ( null ) ; } return ; } model . deleteimage ( view . list . getselectedindex ( ) ) ; } else { ij . error ( "no hay imagen seleccionada" ) ; } } model . refresh ( view . list ) ; }
tr	10	public void readupdates ( int [ ] locations , byte [ ] tiles ) { system . arraycopy ( tilebuffer . array ( ) , tilebuffer . arrayoffset ( ) , tiles , 0 , tilebuffer . position ( ) ) ; int index = 0 ; for ( int yi = y - constants . radius ; yi <= y + constants . radius ; yi ++ ) for ( int xi = x - constants . radius ; xi <= x + constants . radius ; xi ++ ) { int dx = math . abs ( xi - oldx ) ; int dy = math . abs ( yi - oldy ) ; if ( ( dx > constants . radius ) || ( dy > constants . radius ) ) { locations [ index ] = serverworld . normalizeaxis ( xi ) + serverworld . normalizeaxis ( yi ) * constants . world_length ; index ++ ; } } if ( index != tilebuffer . position ( ) ) throw new runtimeexception ( "wut" ) ; }
tr	7	public boolean action ( ) { system . out . println ( "\u8a8d\u8a3c\u6e08\u307f\u30c1\u30a7\u30c3\u30af" ) ; if ( authstatus == auth_ng ) { system . out . println ( "\u8a8d\u8a3c\u30eb\u30fc\u30d7" ) ; for ( int i = 0 ; i < retrycount + 1 ; i ++ ) { if ( authorize ( ) ) { return true ; } if ( i == retrycount - 1 ) { system . out . println ( "\u8a8d\u8a3c\u6700\u5f8c" ) ; } } } else if ( authstatus == auth_ok ) { return true ; } return false ; }
tr	4	public gameobject ( int objectid , int orientation , int type , int vertexheightbottomright , int vertexheighttopright , int vertexheightbottomleft , int vertexheighttopleft , int animationid , boolean animating ) { this . objectid = objectid ; this . type = type ; this . orientation = orientation ; this . vertexheightbottomleft = vertexheightbottomleft ; this . vertexheightbottomright = vertexheightbottomright ; this . vertexheighttopright = vertexheighttopright ; this . vertexheighttopleft = vertexheighttopleft ; if ( animationid != - 1 ) { animation = animationsequence . animations [ animationid ] ; frame = 0 ; nextframetime = client . tick ; if ( animating && animation . framestep != - 1 ) { frame = ( int ) ( math . random ( ) * animation . framecount ) ; nextframetime -= ( int ) ( math . random ( ) * animation . getframelength ( frame ) ) ; } } gameobjectdefinition definition = gameobjectdefinition . getdefinition ( this . objectid ) ; varbitid = definition . varbitid ; configid = definition . configids ; childrenids = definition . childids ; }
tr	2	public rampprofile ( int width , int ramptime ) { this . width = width ; this . ramptime = ramptime ; rampdown = width - ramptime ; if ( width < 0 ) { direction = - 1 ; } }
tr	9	public linkedlist < double > runstrategy ( linkedlist < double > oldtradinglist ) { linkedlist < double > newtradinglist = new linkedlist < double > ( ) ; double temp ; double [ ] templist = new double [ look_back_period ] ; int thesignal = 0 ; int numberofsharewehave = 0 ; double marketprice ; while ( oldtradinglist . size ( ) >= look_back_period ) { for ( int i = 0 ; i < look_back_period && oldtradinglist . size ( ) >= look_back_period ; i ++ ) { temp = oldtradinglist . poll ( ) ; newtradinglist . add ( new double ( temp ) ) ; templist [ i ] = temp ; } marketprice = oldtradinglist . peek ( ) ; thesignal = generatordersignal ( templist ) ; if ( thesignal == buy ) { gensiglist . add ( new generatedsignal ( "buy" , marketprice ) ) ; numberofsharewehave ++ ; newtradinglist . add ( marketprice ) ; } else if ( thesignal == sell && numberofsharewehave > 0 ) { gensiglist . add ( new generatedsignal ( "sell" , marketprice ) ) ; numberofsharewehave -- ; newtradinglist . add ( marketprice ) ; } } return newtradinglist ; }
tr	9	public synchronized void aggiorna ( ) { if ( hasrazza ( ) && getrazza ( ) . isempty ( ) ) { getpunteggio ( ) . updatepunteggio ( getrazza ( ) . getnome ( ) , getrazza ( ) . getpunteggio ( ) ) ; razzadelgiocatore = null ; } if ( hasrazza ( ) && ! getrazza ( ) . isempty ( ) ) { getrazza ( ) . aggiornarazza ( ) ; getpunteggio ( ) . updatepunteggio ( getrazza ( ) . getnome ( ) , getrazza ( ) . getpunteggio ( ) ) ; } }
tr	6	public void showsubtasksfor ( task task ) { if ( debug ) log ( "attempting to show only subtasks associated with task: " + task . getname ( ) ) ; rightcontent . removeall ( ) ; for ( subtaskwidget subtaskwidget : subtaskwidgets ) { if ( subtaskwidget . getsubtask ( ) . gettask ( ) == task ) { rightcontent . add ( subtaskwidget ) ; } } revalidate ( ) ; repaint ( ) ; }
tr	7	public static void annotate ( string text ) throws ioexception { string [ ] lines = text . split ( "\\n" ) ; if ( lines . length > 10000 ) { int folds = lines . length / 10000 ; logger . info ( "splitting into " + folds + " folds\\n" ) ; for ( int i = 0 ; i < folds ; i ++ ) { logger . info ( "processing the " + i + "-th fold\\n" ) ; stringbuilder sb = new stringbuilder ( ) ; for ( int j = 0 ; j < 10000 ; j ++ ) { sb . append ( lines [ i * 10000 + j ] + "\\n" ) ; } annotateimpl ( sb . tostring ( ) ) ; } stringbuilder sb = new stringbuilder ( ) ; for ( int j = folds * 10000 ; j < lines . length ; j ++ ) { sb . append ( lines [ j ] + "\\n" ) ; } annotateimpl ( sb . tostring ( ) ) ; } else { annotateimpl ( text ) ; } }
tr	4	public string getclientprefix ( ) { string prefix = this . properties . getproperty ( "clientprefix" ) ; string osname = system . getproperty ( "os.name" ) . tolowercase ( ) ; boolean islinux = osname . contains ( "ux" ) || osname . contains ( "nix" ) || osname . contains ( "aix" ) ; boolean ismac = osname . contains ( "mac" ) ; boolean iswin = osname . contains ( "win" ) ; prefix += ( islinux ) ? "_linux" : ( ismac ) ? "_mac" : ( iswin ) ? "_win" : "_unknown" ; return prefix ; }
tr	8	private static void addneighbours ( linkedlist < vertex > unobstructed ) { if ( src . getclass ( ) != point . class ) return ; point p = ( point ) src ; if ( p . getleft ( ) . isvertex ( ) ) unobstructed . add ( p . getleft ( ) ) ; if ( p . getright ( ) . isvertex ( ) ) unobstructed . add ( p . getright ( ) ) ; }
tr	5	private void assignstringvalues ( collection < abstractoption > options , map < string , string > properties ) { for ( abstractoption option : options ) { if ( option . istransient ( ) ) continue ; final string key = option . getkey ( ) ; if ( properties . containskey ( key ) ) option . setstringvalue ( properties . get ( key ) ) ; else option . resettodefaultvalue ( ) ; } }
tr	9	private boolean [ ] selectcoalition ( state s ) { boolean [ ] coalition = new boolean [ s . players ( ) . length ] ; int coalition_size = 0 ; for ( int i = 0 ; i < coalition . length ; i ++ ) { if ( math . random ( ) > paranoia ) { coalition [ i ] = true ; coalition_size ++ ; } } if ( coalition_size == coalition . length && paranoia != 0 ) arrays . fill ( coalition , false ) ; coalition [ handle ] = true ; return coalition ; }
tr	4	public static string tosshpath ( string path ) { if ( strings . isnullorempty ( path ) ) return null ; if ( file . separatorchar == ssh_separator_char ) return path ; return path . replace ( file . separatorchar , ssh_separator_char ) ; }
tr	3	public static void testneuronnetwork ( ) { try { mysmartcartester tester = new mysmartcartester ( ) ; mydrawablegraph nnfgraph = new mydrawablegraph ( mydrawablegraph . sortbyaxis . xaxis , mydrawablegraph . sortdirection . asc , 300 , 260 ) ; mycanvaswindow nnfgwindow = new mycanvaswindow ( 300 , 260 , nnfgraph ) ; mycanvaswindow worldwindow = new mycanvaswindow ( 300 , 250 , tester ) ; worldwindow . startwindow ( ) ; int fitness = 0 ; int iterations = 0 ; while ( ( fitness = tester . getfitness ( ) ) < 995 ) { system . out . println ( "f:" + fitness ) ; tester . evolvenetwork ( ) ; ++ iterations ; } } catch ( exception ex ) { logger . getlogger ( mystartclass . class . getname ( ) ) . log ( level . severe , null , ex ) ; } }
tr	7	public int getcostsavings ( int numberofemployees ) { int counter = 0 ; int savings = 0 ; while ( counter < numberofemployees ) { if ( ratingemployeemap . size ( ) > 0 ) { treeset < integer > treeset = ( treeset ) ratingemployeemap . remove ( ratingemployeemap . firstkey ( ) ) . descendingset ( ) ; if ( treeset != null && treeset . size ( ) > 0 ) { for ( int salary : treeset ) { if ( counter < numberofemployees ) { savings = savings + salary ; } else { return savings ; } counter ++ ; } } } else { return savings ; } } return savings ; }
tr	5	public string gethighscorestring ( ) { string highscorestring = "" ; int max = 10 ; arraylist < score > scores ; scores = this . getscores ( ) ; if ( scores . size ( ) > 0 ) { int i = 0 ; int x = scores . size ( ) ; if ( x > max ) { x = max ; } while ( i < x ) { highscorestring += ( i + 1 ) + ".\\t" + scores . get ( i ) . getname ( ) + "\\t\\t" + scores . get ( i ) . getscore ( ) + "\\n" ; i ++ ; } } else { highscorestring = "es sind bisher keine eintr\xe4ge vorhanden!" ; } return highscorestring ; }
tr	4	private void sendcommand ( command cmd ) { if ( cmd != null ) { writesem . acquireuninterruptibly ( ) ; char [ ] cs = cmd . serialize ( ) ; for ( char c : cs ) { byte b = ( byte ) ( c - 127 ) ; try { out . write ( b ) ; } catch ( ioexception e ) { } } writesem . release ( ) ; } }
tr	4	private static void processcriterions ( final db db , final databasemap dbmap , final string dbname , final criteria crit , final query query , final list params , final querycallback qc ) throws torqueexception { uniquelist whereclause = query . getwhereclause ( ) ; for ( iterator it = crit . keyset ( ) . iterator ( ) ; it . hasnext ( ) ; ) { string key = ( string ) it . next ( ) ; criteria . criterion criterion = crit . getcriterion ( key ) ; criteria . criterion [ ] somecriteria = criterion . getattachedcriterion ( ) ; string table = null ; for ( int i = 0 ; i < somecriteria . length ; i ++ ) { string tablename = somecriteria [ i ] . gettable ( ) ; addtabletofromclause ( getfulltablename ( tablename , dbname ) , crit , query ) ; table = crit . gettableforalias ( tablename ) ; if ( table == null ) { table = tablename ; } boolean ignorecase = ( ( crit . isignorecase ( ) || somecriteria [ i ] . isignorecase ( ) ) && ( dbmap . gettable ( table ) . getcolumn ( somecriteria [ i ] . getcolumn ( ) ) . gettype ( ) instanceof string ) ) ; somecriteria [ i ] . setignorecase ( ignorecase ) ; } criterion . setdb ( db ) ; whereclause . add ( qc . process ( criterion , params ) ) ; } }
tr	1	private static string getguestusername ( ) { return string . format ( "guest-%04d" , ( int ) ( math . random ( ) * 1000 ) ) ; }
tr	9	public static void main ( string [ ] args ) { int a = - 1 ; int b = 1 ; int c = 1 ; int d = - 1 ; cyberusai ai = new cyberusai ( ) ; for ( a = - 1 ; a > - 11 ; a -- ) { for ( b = 1 ; b < 11 ; b ++ ) { for ( c = 1 ; c < 11 ; c ++ ) { for ( d = - 1 ; d > - 11 ; d -- ) { int average = 0 ; for ( int i = 0 ; i < 200 ; i ++ ) { avgcyberusai tetris = new avgcyberusaihelper ( ) ; ai . factors = new double [ ] { a , b , c , d } ; tetris . brains = ai ; tetris . startgame ( ) ; while ( tetris . tc . gameon ) { system . out . print ( "" ) ; } average = i != 0 ? tetris . tc . rowscleared / i : 0 ; sort ( average , new int [ ] { a , b , c , d } ) ; } system . out . println ( "average: " + average + " a: " + a + " b: " + b + " c: " + c + " d: " + d ) ; } } } } system . out . println ( arrays . tostring ( averages ) ) ; system . out . println ( arrays . tostring ( best1 ) ) ; system . out . println ( arrays . tostring ( best2 ) ) ; system . out . println ( arrays . tostring ( best3 ) ) ; system . out . println ( arrays . tostring ( best4 ) ) ; system . out . println ( arrays . tostring ( best5 ) ) ; }
tr	10	public void render ( graphics2d g , game game , spritesheet spritesheet , int frame ) { switch ( kind ) { case floor : g . drawimage ( spritesheet . get ( extradata , 3 ) , null , 0 , 0 ) ; break ; case wall : if ( extradata >= 4 ) g . drawimage ( spritesheet . get ( 4 + extradata % 4 , 4 ) , null , 0 , 0 ) ; else g . drawimage ( spritesheet . get ( 4 + extradata % 4 , 3 ) , null , 0 , 0 ) ; break ; case door : g . drawimage ( spritesheet . get ( 0 , 4 ) , null , 0 , 0 ) ; break ; case crafting_bench : g . drawimage ( spritesheet . get ( 2 , 4 ) , null , 0 , 0 ) ; break ; case inventory : g . drawimage ( spritesheet . get ( 1 , 4 ) , null , 0 , 0 ) ; break ; case sponsor : g . drawimage ( spritesheet . get ( 0 , 3 ) , null , 0 , 0 ) ; g . drawimage ( spritesheet . get ( ( frame > > 2 ) % 4 + ( game . hassponsors ( ) ? 4 : 0 ) , 2 ) , null , 0 , 0 ) ; break ; case merchant : g . drawimage ( spritesheet . get ( 0 , 3 ) , null , 0 , 0 ) ; g . drawimage ( spritesheet . get ( 4 , 1 ) , null , 0 , 0 ) ; break ; default : throw new runtimeexception ( "unhandled tile kind" ) ; } }
tr	2	public void setgetlangisset ( boolean value ) { if ( ! value ) { this . getlang = null ; } }
tr	8	public boolean savegame ( string filename , string currentgameserializedstring ) { file newfile = new file ( filename ) ; try { if ( newfile . exists ( ) ) { int selectedsavegame = joptionpane . showconfirmdialog ( null , "this file name already has a saved game. would you like to save anyways?" , "save game" , joptionpane . yes_no_option ) ; if ( selectedsavegame != joptionpane . yes_option ) { return false ; } } } catch ( nullpointerexception e ) { return false ; } filewriter writer ; try { writer = new filewriter ( newfile ) ; writer . write ( currentgameserializedstring ) ; writer . close ( ) ; } catch ( ioexception e ) { joptionpane . showmessagedialog ( null , "file cannot be written. try again." ) ; return false ; } joptionpane . showmessagedialog ( null , "game saved!" ) ; return true ; }
tr	8	public static void main ( string [ ] args ) { if ( args . length == 0 ) { system . err . println ( "usage: ntpclient <hostname-or-address-list>" ) ; system . exit ( 1 ) ; } ntpudpclient client = new ntpudpclient ( ) ; client . setdefaulttimeout ( 10000 ) ; try { client . open ( ) ; for ( string arg : args ) { system . out . println ( ) ; try { inetaddress hostaddr = inetaddress . getbyname ( arg ) ; system . out . println ( "> " + hostaddr . gethostname ( ) + "/" + hostaddr . gethostaddress ( ) ) ; timeinfo info = client . gettime ( hostaddr ) ; processresponse ( info ) ; } catch ( ioexception ioe ) { ioe . printstacktrace ( ) ; } } } catch ( socketexception e ) { e . printstacktrace ( ) ; } client . close ( ) ; }
tr	8	@ suppresswarnings ( "unchecked" ) @ override public t maprow ( resultset resultset , int index ) throws sqlexception { resultsetmetadata metadata = resultset . getmetadata ( ) ; if ( isprimarykeyvaluemissing ( resultset , metadata ) ) { return null ; } t result = newentity ( ) ; for ( dbfield < ? , ? > field : fielddefinition . fields ( ) ) { dbfield < object , object > targetfield = ( dbfield < object , object > ) field ; try { if ( field . ismultivaluefield ( ) ) { list < object > objects = getmultifieldvalues ( field , metadata , resultset ) ; targetfield . setdbvalues ( result , objects . toarray ( ) ) ; } else { targetfield . setdbvalue ( result , getfield ( metadata , resultset , field . selectfieldname ( alias ) ) ) ; } } catch ( sqlexception e ) { throw new runtimeexception ( "invalid column " + field . selectfieldname ( alias ) , e ) ; } } populatedata ( result , resultset , index ) ; return result ; }
tr	4	private int getnumrows ( columnset set ) { int numrows = 0 ; for ( int i = 0 ; i < set . getnumparents ( ) ; i ++ ) { columnparent parent = set . getparent ( i ) ; for ( int j = 0 ; j < parent . getnumchildren ( ) ; j ++ ) { columnchild data = parent . getchild ( j ) ; int rows = data . getnumdata ( ) ; if ( rows > numrows ) numrows = rows ; } } return numrows ; }
tr	3	public void print ( ) { system . out . println ( "dirichlet:" ) ; for ( int j = 0 ; j < partition . length ; j ++ ) system . out . println ( dict != null ? dict . lookupobject ( j ) . tostring ( ) : j + "=" + magnitude * partition [ j ] ) ; }
tr	8	@ override public boolean equals ( object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getclass ( ) != obj . getclass ( ) ) return false ; pairimpl < ? > other = ( pairimpl < ? > ) obj ; return tuples . equals ( _first , other . _first ) && tuples . equals ( _second , other . _second ) ; }
tr	6	private string [ ] getcolumncombination ( int binarycounter ) { string strbinarycounter = integer . tobinarystring ( binarycounter ) ; while ( strbinarycounter . length ( ) < this . myidentifiercolumns . length ) { strbinarycounter = "0" + strbinarycounter ; } int arraylength = this . myidentifiercolumns . length - strbinarycounter . replaceall ( "0" , "" ) . length ( ) ; string [ ] tmpdisclosedcolumns = new string [ arraylength ] ; int j = 0 ; for ( int i = 0 ; i < this . myidentifiercolumns . length ; i ++ ) { if ( strbinarycounter . charat ( i ) == '0' ) { tmpdisclosedcolumns [ j ] = this . myidentifiercolumns [ i ] ; j ++ ; } } return tmpdisclosedcolumns ; }
tr	7	public static void save ( highscore [ ] highscores , outputstream out ) throws ioexception { printstream outp = new printstream ( out ) ; for ( int i = 0 ; i < highscores . length ; i ++ ) { outp . print ( highscores [ i ] . score ) ; outp . print ( '\\t' ) ; if ( highscores [ i ] . name . equals ( "" ) ) { outp . print ( "`" ) ; } else { outp . print ( highscores [ i ] . name ) ; } if ( highscores [ i ] . fields != null ) { for ( int j = 0 ; j < highscores [ i ] . fields . length ; j ++ ) { outp . print ( '\\t' ) ; outp . print ( highscores [ i ] . fields [ j ] ) ; } } outp . println ( ) ; } outp . flush ( ) ; }
tr	8	protected multilabeloutput makepredictioninternal ( instance instance ) throws exception { double p_0 = 0.0 ; if ( datatransformation . getnumberofallzeros ( ) > 0 ) { instance transformedzeroinstance = datatransformation . transformtozeroinstance ( instance ) ; p_0 = allzeros . distributionforinstance ( transformedzeroinstance ) [ transformedzeroinstance . classattribute ( ) . indexofvalue ( "0" ) ] ; } instance transformedinstance = datatransformation . transforminstance ( instance ) ; double [ ] [ ] probabilities = new double [ datatransformation . getmaxlabels ( ) ] [ numlabels ] ; double [ ] marginals = new double [ numlabels ] ; for ( int i = 0 ; i < numlabels ; i ++ ) { double [ ] distribution = ensemble [ i ] . distributionforinstance ( transformedinstance ) ; for ( int j = 0 ; j < distribution . length ; j ++ ) { int label = integer . parseint ( transformedinstance . attribute ( this . labelindices [ i ] ) . value ( j ) ) ; if ( label != 0 ) { probabilities [ label - 1 ] [ i ] = ( 1 - p_0 ) * distribution [ j ] ; marginals [ i ] = ( 1 - p_0 ) * distribution [ j ] ; } } } fmeasure f = new fmeasure ( ) ; f . initialize ( numlabels , datatransformation . getmaxlabels ( ) , probabilities , p_0 ) ; f . computefmeasuremaximizer ( ) ; multilabeloutput prediction = f . computeprediction ( ) ; return prediction ; }
tr	10	public season getseason ( month month ) { switch ( month ) { case january : case february : case december : return season . winter ; case march : case april : case may : return season . spring ; case june : case july : case august : return season . summer ; default : return season . autumn ; } }
tr	8	public void processreturnvalue ( int re ) { string msg = "" ; switch ( re ) { case 1 : msg = "interaction file missing!" ; break ; case 2 : msg = "overlap information missing!" ; break ; case 3 : msg = "there is no need for correlation" ; break ; case 4 : msg = "please do correlate first!" ; break ; } if ( ! msg . isempty ( ) ) { joptionpane . showmessagedialog ( null , msg , "error" , joptionpane . error_message ) ; } }
tr	1	public string getinstrument ( ) { return minstrument ; }
tr	7	private static linkedlist < vertex > getunobstructedvertices ( linkedlist < vertex > vertices ) { linkedlist < vertex > unobstructed = new linkedlist < > ( ) ; addneighbours ( unobstructed ) ; while ( vertices . hasnext ( ) ) { vertex q = vertices . getnext ( ) ; if ( src == q || ! q . isvertex ( ) ) continue ; if ( ! isobstructed ( q ) ) unobstructed . add ( q ) ; } vertices . reset ( ) ; return unobstructed ; }
tr	8	private void new ( ) { try { for ( int i = 0 ; i < list . getprojectlist ( ) . size ( ) ; i ++ ) { stringtokenizer st = new stringtokenizer ( list . getprojectlist ( ) . get ( i ) , " : " ) ; string str = st . nexttoken ( ) ; if ( str . equals ( nametextfield . gettext ( ) ) ) { joptionpane . showmessagedialog ( buttonnew , "project with such name is already exists" ) ; return ; } } } catch ( remoteexception e1 ) { joptionpane . showmessagedialog ( buttonnew , "disconect from server" ) ; this . dispose ( ) ; loginframe log = new loginframe ( ) ; log . setdefaultcloseoperation ( jframe . exit_on_close ) ; log . setvisible ( true ) ; } if ( nametextfield . gettext ( ) . length ( ) == 0 ) { joptionpane . showmessagedialog ( buttonnew , "enter projact name" ) ; return ; } setprojectname ( nametextfield . gettext ( ) ) ; passframe pf = new passframe ( opf ) ; pf . setdefaultcloseoperation ( exit_on_close ) ; pf . setvisible ( true ) ; }
tr	2	@ before public void initialize ( ) { super . initialize ( ) ; try { storage_server . start ( registrationstub , new path [ ] { file1 , file2 , file3 } , null ) ; } catch ( throwable t ) { t . printstacktrace ( ) ; assert . fail ( "unable to start storage server" ) ; } }
tr	1	public calendar getdateto ( ) { return mdateto ; }
tr	3	private void loadprefab ( int spawnx , int spawny ) { string pathtag = "houseprefab" ; string path = "" ; path = "data/" + pathtag + string . valueof ( spawnrotation ) + ".pfb" ; file f = new file ( path ) ; if ( f . isfile ( ) ) { try { prefab . buildprefab ( spawnx , spawny , path ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } spawnrotation ++ ; } else { spawnrotation = 0 ; } }
tr	10	private jpanel getselectbahanmakananpanel ( ) { jpanel panel = new jpanel ( new borderlayout ( ) ) ; jpanel panelkategori = new jpanel ( new flowlayout ( ) ) ; panelkategori . add ( new jlabel ( "pilih golongan :" ) ) ; comboboxkategorimakanan = new jcombobox < > ( makandikonsumsicontroller . getliststringgolongan ( ) ) ; comboboxkategorimakanan . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent e ) { customtablemodelbahanmakanan . filter ( comboboxkategorimakanan . getselecteditem ( ) . tostring ( ) , 5 ) ; } } ) ; panelkategori . add ( comboboxkategorimakanan ) ; jpanel paneltable = new jpanel ( new borderlayout ( ) ) ; customtablemodelbahanmakanan = new customtablemodel < bahanmakanan > ( ) { @ override public object getdataitem ( bahanmakanan data , int column ) { if ( column == 0 ) { return data . getidbahanmakanan ( ) ; } else if ( column == 1 ) { return data . getnamabahanmakanan ( ) ; } else if ( column == 2 ) { return data . getsatuanurt ( ) + "" ; } else if ( column == 3 ) { return data . getsatuanpenukar ( ) + "" ; } else if ( column == 4 ) { return data . getberatsatuanurt ( ) + "" ; } else if ( column == 5 ) { return data . getgolongan ( ) . getnamagolongan ( ) + "" ; } else if ( column == 6 ) { return data . getkarbohidrat ( ) + "" ; } else if ( column == 7 ) { return data . getprotein ( ) + "" ; } else if ( column == 8 ) { return data . getkalori ( ) + "" ; } else { return data . getlemak ( ) + "" ; } } } ; customtablemodelbahanmakanan . setcolumnname ( kategori ) ; customtablemodelbahanmakanan . setlistdata ( makandikonsumsicontroller . getlistbahanmakanan ( ) ) ; tablebahanmakanan = new jtable ( customtablemodelbahanmakanan ) ; tablebahanmakanan . addmouselistener ( new mouseadapter ( ) { @ override public void mouseclicked ( mouseevent e ) { jtable table = ( jtable ) e . getsource ( ) ; point p = e . getpoint ( ) ; int selectedindex = table . rowatpoint ( p ) ; long id = ( long ) table . getvalueat ( selectedindex , 0 ) ; makandikonsumsicontroller . setcurrentbahanmakananbyid ( id ) ; textfieldnamamakanan . settext ( makandikonsumsicontroller . getcurrentbahanmakanan ( ) . getnamabahanmakanan ( ) ) ; labelsatuanurt . settext ( makandikonsumsicontroller . getcurrentbahanmakanan ( ) . getsatuanurt ( ) ) ; } } ) ; customtablemodelbahanmakanan . createrowsorter ( tablebahanmakanan ) ; jscrollpane scrollpane = new jscrollpane ( tablebahanmakanan ) ; paneltable . add ( scrollpane ) ; panel . add ( panelkategori , borderlayout . north ) ; panel . add ( paneltable , borderlayout . center ) ; return panel ; }
tr	6	public void updatescorefile ( ) { try { this . outputstream = new objectoutputstream ( new fileoutputstream ( highscoremanager . highscore_file ) ) ; this . outputstream . writeobject ( this . scores ) ; } catch ( filenotfoundexception e ) { system . out . println ( "[update] fnf error: " + e . getmessage ( ) ) ; } catch ( ioexception e ) { system . out . println ( "[update] io error: " + e . getmessage ( ) ) ; } finally { try { if ( this . outputstream != null ) { this . outputstream . flush ( ) ; this . outputstream . close ( ) ; } } catch ( ioexception e ) { system . out . println ( "[update] error: " + e . getmessage ( ) ) ; } } }
tr	2	@ override public list < tree < string > > call ( ) throws exception { list < tree < string > > resultlist = new arraylist < tree < string > > ( ) ; for ( tree < string > testtree : sentencelist ) { list < string > testsentence = testtree . getyield ( ) ; tree < string > result = arrayckyparser . getbestparse ( testsentence ) ; resultlist . add ( result ) ; } return resultlist ; }
tr	3	@ override protected void setup ( ) { addlogbehaviour ( ) ; if ( getarguments ( ) != null ) { try { initmapscene ( getarguments ( ) ) ; init ( getarguments ( ) ) ; } catch ( staleproxyexception e ) { exceptionutils . handleexception ( e ) ; reset ( ) ; init ( ) ; } } else { init ( ) ; } }
tr	3	private static boolean sectorsrightanglebeforelastangle ( heap < angleinterval > endangles , double lastangle ) { return ! endangles . isempty ( ) && lastangle > endangles . peek ( ) . rightangle && ( endangles . peek ( ) . leftangle < endangles . peek ( ) . rightangle || lastangle < endangles . peek ( ) . leftangle ) ; }
tr	3	@ override public int classify ( pattern instance ) { int result = - 1 ; double [ ] xm = instance . todoublevector ( ) ; double min = double . max_value ; for ( int clazz = 0 ; clazz < gettrainset ( ) . getclasses ( ) . getvalues ( ) . size ( ) ; clazz ++ ) { double [ ] ym = z ( m [ clazz ] , xm ) ; double m = min ( ym ) ; if ( m < min ) { min = m ; result = clazz ; } } return result ; }
tr	10	private void starttag ( string aprefix , string aname , xmlpullparser aparser ) throws exception { if ( "entry" . equals ( aname ) ) { tweets . addtweet ( currenttweet = new tweet ( ) ) ; } else if ( "published" . equals ( aname ) ) { aparser . next ( ) ; currenttweet . setpublished ( dateformat . parse ( aparser . gettext ( ) ) ) ; } else if ( ( "title" . equals ( aname ) ) && ( currenttweet != null ) ) { aparser . next ( ) ; currenttweet . settitle ( aparser . gettext ( ) ) ; } else if ( "content" . equals ( aname ) ) { content _c = new content ( ) ; _c . settype ( aparser . getattributevalue ( null , "type" ) ) ; aparser . next ( ) ; _c . setvalue ( aparser . gettext ( ) ) ; currenttweet . setcontent ( _c ) ; } else if ( "lang" . equals ( aname ) ) { aparser . next ( ) ; currenttweet . setlanguage ( aparser . gettext ( ) ) ; } else if ( "author" . equals ( aname ) ) { currenttweet . setauthor ( currentauthor = new author ( ) ) ; } else if ( "name" . equals ( aname ) ) { aparser . next ( ) ; currentauthor . setname ( aparser . gettext ( ) ) ; } else if ( "uri" . equals ( aname ) ) { aparser . next ( ) ; currentauthor . seturi ( aparser . gettext ( ) ) ; } }
tr	1	public string getordertype ( ) { return mordertype ; }
tr	1	@ override public void endsubtask ( final statistics substate ) throws ioexception { this . pres . pop ( ) ; }
tr	9	private void buildpreroundcomabt ( ) { for ( action action : possibleplayeractions ) { if ( action . gettrigger ( ) . equals ( actiontype . combat ) ) { playerpreroundaction = action ; } } for ( action action : possiblecreatureactions ) { if ( action . gettrigger ( ) . equals ( actiontype . combat ) ) { creaturepreroundaction = action ; } } }
tr	3	public void addaction ( ) { if ( isupdate == false ) { employee newemployee = updateemployee ( null ) ; if ( newemployee != null ) { staff . getinstance ( ) . addemployee ( newemployee ) ; } } else { employee oldemployee = staff . getinstance ( ) . getemployees ( ) . get ( index ) ; employee updatedemployee = updateemployee ( oldemployee ) ; staff . getinstance ( ) . updateemployee ( index , updatedemployee ) ; } staffcontroller . singleton . refresh ( ) ; }
tr	1	public void settotalnanosthreshold ( final long totalnanosthreshold ) { this . totalnanosthreshold = totalnanosthreshold ; }
tr	6	@ override public double identify ( user user , date startdate , date enddate ) { list < submission > submissionlist ; submissiondao submissiondao = new submissiondaomysql ( ) ; submissionlist = submissiondao . getbyuser ( user . getid ( ) , startdate , enddate ) ; total = submissionlist . size ( ) ; syntaxerror = 0 ; for ( submission submission : submissionlist ) { if ( issyntaxerror ( submission ) ) { syntaxerror ++ ; } } ioerror = submissiondao . countfirsttestcaseerrorsbyuser ( user . getid ( ) , startdate , enddate ) ; attetiontodetailsscore = 0 ; if ( total > 0 ) { attetiontodetailsscore = ( 1 - ( ( double ) ( syntaxerror + ioerror ) / total ) ) * 100 ; } return attetiontodetailsscore ; }
tr	8	static void setcurrenttab ( boolean isselection , int tabid , string url , javascriptobject tab ) { browsertab t = getbyid ( tabid ) ; t . url = url ; appstate . isweburl = webcontent . isweburl ( url ) ; appstate . isinpearltrees = appstate . isweburl && webcontent . isinpearltrees ( url ) ; mainbutton . seticon ( false , false ) ; if ( isselection && appstate . isinpearltrees && appstate . getselectedtree ( ) != null && appstate . lastpearled != null && t . creation . before ( appstate . lastpearled ) ) { appstate . reveal ( appstate . getselectedtree ( ) , appstate . getselectedasso ( ) , tabid , url ) ; } else if ( appstate . isinpearltrees ) { string tree = webcontent . getcurrenttree ( url ) ; if ( tree != null ) { appstate . setselectedtree ( tree , "" ) ; } } }
tr	8	public void storetodisk ( ) { printwriter writer = null ; try { writer = new printwriter ( applicationsetup . getinstance ( ) . getdocumentlookuptablepath ( ) ) ; } catch ( filenotfoundexception e ) { e . printstacktrace ( ) ; } for ( int i = 0 ; i < lookup . size ( ) ; i ++ ) { writer . println ( lookup . get ( i ) ) ; } if ( writer != null ) writer . close ( ) ; }
tr	8	public treenode maketree ( list < integer > values ) { treenode root = new treenode ( values . get ( 0 ) , null , null ) ; queue < treenode > nodes = new linkedlist < treenode > ( ) ; nodes . add ( root ) ; int half = values . size ( ) / 2 ; for ( int i = 0 ; i < half ; i ++ ) { if ( values . get ( i ) != null ) { treenode node = nodes . poll ( ) ; int left = 2 * i + 1 ; int right = 2 * i + 2 ; if ( values . get ( left ) != null ) { node . left = new treenode ( values . get ( left ) , null , null ) ; nodes . add ( node . left ) ; } if ( right < values . size ( ) && values . get ( right ) != null ) { node . right = new treenode ( values . get ( right ) , null , null ) ; nodes . add ( node . right ) ; } } } return root ; }
tr	2	public void settitle ( string title ) { this . title = title ; if ( titlelabel != null ) { this . remove ( titlelabel ) ; } fontmetrics fm = getfontmetrics ( lcars . getsingletonobject ( ) . getlcarsfont ( ) . derivefont ( lcars . getlcarsfontsize ( lcars . ef_title ) ) ) ; titlelabel = new lcarslabel ( title , preferred_width - fm . stringwidth ( title ) - 100 , 10 , lcars . ec_orange | lcars . es_label_ne | lcars . ef_title ) ; this . add ( titlelabel ) ; }
tr	1	public string getaccountid ( ) { return maccountid ; }
tr	1	private string getpre ( ) { return pres . peek ( ) ; }
tr	8	public void init ( ) { int k ; fenetre . activerecm ( ) ; if ( ecm == null ) { k = 4 ; m = new double [ n ] [ k ] ; n = new double [ n ] [ k ] ; } else { fenetre . activermenu ( ) ; system . out . println ( "calcul de n..." ) ; ecm . calculn ( ) ; m = ecm . getm ( ) ; n = ecm . getn ( ) ; k = ecm . getk ( ) ; } classes = new int [ points . length ] ; double max = 0 ; int jmax = 0 ; for ( int i = 0 ; i < points . length ; i ++ ) { for ( int j = 0 ; j < k ; j ++ ) { if ( m [ i ] [ j ] > max ) { max = m [ i ] [ j ] ; jmax = j ; } } classes [ i ] = jmax ; max = 0 ; jmax = 0 ; } addmousewheellistener ( this ) ; addmousemotionlistener ( this ) ; addmouselistener ( this ) ; symbolesclasses . add ( new symbolevide ( ) ) ; symbolesclasses . add ( new symboleplus ( ) ) ; symbolesclasses . add ( new symbolerond ( ) ) ; symbolesclasses . add ( new symboletriangle ( ) ) ; symbolesclasses . add ( new symbolecroix ( ) ) ; symbolesclasses . add ( new symbolecarre ( ) ) ; symbolesclasses . add ( new symbolediamant ( ) ) ; symbolesclasses . add ( new symboletrianglep ( ) ) ; symbolesclasses . add ( new symbolecarrep ( ) ) ; symbolesclasses . add ( new symbolediamantp ( ) ) ; symbolesclasses . add ( new symbolerondc ( ) ) ; symbolesclasses . add ( new symbolecarrec ( ) ) ; symbolesclasses . add ( new symbolediamantc ( ) ) ; symbolesclasses . add ( new symbolerondp ( ) ) ; dessine = true ; centre ( ) ; repaint ( ) ; }
tr	10	public void runclient ( ) { try { system . out . println ( "attempting connection..." ) ; client = new socket ( host , port ) ; system . out . println ( "connected to: " + client . getinetaddress ( ) . tostring ( ) ) ; clientoutput = new objectoutputstream ( client . getoutputstream ( ) ) ; clientoutput . flush ( ) ; clientinput = new objectinputstream ( client . getinputstream ( ) ) ; system . out . println ( "got i/o streams" ) ; scanner input = new scanner ( system . in ) ; message = "" ; username = "" ; do { username = joptionpane . showinputdialog ( null , "enter your username:" , "prompt" , joptionpane . information_message ) ; } while ( username . equals ( "" ) ) ; clientoutput . writeobject ( username ) ; clientoutput . flush ( ) ; frame = new frame ( username ) ; do { try { message = ( string ) clientinput . readobject ( ) ; system . out . println ( "server: " + message ) ; processmessage ( message ) ; } catch ( classnotfoundexception e ) { system . out . println ( "server: can't understand" ) ; } } while ( ! message . equals ( "terminate" ) ) ; } catch ( eofexception e ) { system . out . println ( "error" ) ; } catch ( ioexception e ) { system . out . println ( "server closed" ) ; } finally { try { clientoutput . writeobject ( "terminate!@#" + this . username ) ; clientoutput . flush ( ) ; client . close ( ) ; clientinput . close ( ) ; clientoutput . close ( ) ; } catch ( ioexception e ) { system . out . println ( "******" ) ; } } system . exit ( 0 ) ; }
tr	10	public hashmap < string , map < string , integer > > getoutrelation ( int id ) { resultset set = sqlconnection . query ( query + id ) ; string author , subauthor ; int count ; string [ ] info , outauthors ; boolean flag = false ; hashmap < string , integer > authormap = new hashmap < > ( ) ; try { while ( set . next ( ) ) { author = set . getstring ( "name" ) ; outauthors = set . getstring ( "outauthors" ) . split ( "<litcomma>" ) ; if ( ! flag ) { for ( string obj : outauthors ) { info = obj . split ( "#" ) ; subauthor = info [ 0 ] ; count = integer . parseint ( info [ 1 ] ) ; if ( ! authormap . containskey ( subauthor ) ) { authormap . put ( subauthor , count ) ; } } flag = true ; } if ( ! outauthormap . containskey ( author ) ) { outauthormap . put ( author , authormap ) ; } } } catch ( sqlexception e ) { e . printstacktrace ( ) ; } return outauthormap ; }
tr	10	void start ( ) { reset ( ) ; card player1 = deck . draw ( ) ; card dealer1 = deck . draw ( ) ; card player2 = deck . draw ( ) ; card dealer2 = deck . draw ( ) ; this . dealer2 = dealer2 ; player . add ( player1 ) ; player . add ( player2 ) ; dealer . add ( dealer1 ) ; dealer . add ( dealer2 ) ; string values = "| " ; for ( int i : player . values ) { values += i + " |" ; } if ( dealer . values . contains ( 21 ) && player . values . contains ( 21 ) ) { sendmessage ( channel , "you and the dealer both got blackjack<litcomma> push." ) ; reset ( ) ; return ; } else if ( dealer . values . contains ( 21 ) ) { sendmessage ( channel , "dealer got blackjack and you didn't<litcomma> you lose." ) ; reset ( ) ; return ; } else if ( player . values . contains ( 21 ) ) { sendmessage ( channel , "blackjack<litcomma> you win." ) ; reset ( ) ; return ; } sendmessage ( channel , "your cards: | " + player1 . face + " | " + player2 . face + " |" ) ; sendmessage ( channel , "your cards are worth: " + values ) ; sendmessage ( channel , "dealer's cards: | " + dealer1 . face + " | ? |" ) ; isstarted = true ; }
tr	5	public void importfromfile ( string filename ) { try { int res = 0 ; if ( ( new file ( filename ) ) . length ( ) > 1024000 ) { res = joptionpane . showconfirmdialog ( tabbedpane , "this file may results in " + "a long time wait due to its large size.\\n" + "would you like to continue anyway?" , "warning" , joptionpane . yes_no_option ) ; } if ( res == 0 ) { new textcomponentlayout ( textcomponent , filename ) ; textcomponent . getdocument ( ) . addundoableeditlistener ( new xmlundoableeditlistener ( ) ) ; undomanager . discardalledits ( ) ; documentbuilderfactory factory = documentbuilderfactory . newinstance ( ) ; documentbuilder builder = factory . newdocumentbuilder ( ) ; document doc = builder . parse ( new inputsource ( new filereader ( filename ) ) ) ; importview ( doc ) ; } } catch ( exception e ) { statusbar . setmessage ( "please check for problems in xml format." ) ; } }
tr	3	private void addrightclickmenuitems ( ) { jmenuitem item1 = new jmenuitem ( "delete" ) ; item1 . addmouselistener ( new mouselistener ( ) { public void mouseclicked ( mouseevent e ) { } public void mouseentered ( mouseevent e ) { } public void mouseexited ( mouseevent e ) { } public void mousepressed ( mouseevent e ) { string [ ] temp = rightclickedlbl . getname ( ) . split ( "<litcomma>" ) ; jtextfield temptxt = ( jtextfield ) getcomponentbyname ( "txt<litcomma>" + temp [ 1 ] + "<litcomma>" + temp [ 2 ] ) ; try { thisdir . deletefile ( integer . parseint ( temp [ 2 ] ) ) ; jpanel pnl = ( jpanel ) rightclickedlbl . getparent ( ) ; pnl . remove ( rightclickedlbl ) ; pnl . remove ( temptxt ) ; jpanel colpan = ( jpanel ) pnl . getparent ( ) ; colpan . remove ( pnl ) ; contentpanelwest . revalidate ( ) ; contentpaneleast . removeall ( ) ; contentpaneleast . repaint ( ) ; } catch ( numberformatexception e1 ) { errordialog er = new errordialog ( mainframe , "invalid action!" ) ; mainpanel . add ( er ) ; e1 . printstacktrace ( ) ; } catch ( permissiondeniedexception e1 ) { errordialog er = new errordialog ( mainframe , "permission denied!!" ) ; mainpanel . add ( er ) ; e1 . printstacktrace ( ) ; } } public void mousereleased ( mouseevent e ) { } } ) ; jmenuitem item2 = new jmenuitem ( "rename" ) ; item2 . addmouselistener ( new mouselistener ( ) { public void mouseclicked ( mouseevent e ) { } public void mouseentered ( mouseevent e ) { } public void mouseexited ( mouseevent e ) { } public void mousepressed ( mouseevent e ) { string [ ] temp = rightclickedlbl . getname ( ) . split ( "<litcomma>" ) ; jtextfield temptxt = ( jtextfield ) getcomponentbyname ( "txt<litcomma>" + temp [ 1 ] + "<litcomma>" + temp [ 2 ] ) ; temptxt . setenabled ( true ) ; temptxt . setforeground ( color . blue ) ; temptxt . setbackground ( mainpanel . getbackground ( ) ) ; } public void mousereleased ( mouseevent e ) { } } ) ; jmenuitem item3 = new jmenuitem ( "properties" ) ; item3 . addmouselistener ( new mouselistener ( ) { public void mouseclicked ( mouseevent e ) { } public void mouseentered ( mouseevent e ) { } public void mouseexited ( mouseevent e ) { } public void mousepressed ( mouseevent e ) { string [ ] temp = rightclickedlbl . getname ( ) . split ( "<litcomma>" ) ; jtextfield temptxt = ( jtextfield ) getcomponentbyname ( "txt<litcomma>" + temp [ 1 ] + "<litcomma>" + temp [ 2 ] ) ; properties prop = new properties ( mainframe , integer . parseint ( temp [ 2 ] ) , temptxt . gettext ( ) ) ; mainpanel . add ( prop ) ; } public void mousereleased ( mouseevent e ) { } } ) ; jmenuitem item4 = new jmenuitem ( "copy" ) ; item4 . addmouselistener ( new mouselistener ( ) { public void mouseclicked ( mouseevent e ) { } public void mouseentered ( mouseevent e ) { } public void mouseexited ( mouseevent e ) { } public void mousepressed ( mouseevent e ) { string [ ] temp = rightclickedlbl . getname ( ) . split ( "<litcomma>" ) ; guistarter . copiedinodenum = integer . parseint ( temp [ 2 ] ) ; guistarter . copyfrom = parentinodenum ; } public void mousereleased ( mouseevent e ) { } } ) ; jmenuitem item5 = new jmenuitem ( "cut" ) ; item5 . addmouselistener ( new mouselistener ( ) { public void mouseclicked ( mouseevent e ) { } public void mouseentered ( mouseevent e ) { } public void mouseexited ( mouseevent e ) { } public void mousepressed ( mouseevent e ) { string [ ] temp = rightclickedlbl . getname ( ) . split ( "<litcomma>" ) ; rightclickedlbl . seticon ( new imageicon ( "folder.gif" ) ) ; jtextfield temptxt = ( jtextfield ) getcomponentbyname ( "txt<litcomma>" + temp [ 1 ] + "<litcomma>" + temp [ 2 ] ) ; temptxt . setbackground ( color . light_gray ) ; guistarter . copiedinodenum = integer . parseint ( temp [ 2 ] ) ; guistarter . cutinodenum = integer . parseint ( temp [ 2 ] ) ; guistarter . copyfrom = parentinodenum ; } public void mousereleased ( mouseevent e ) { } } ) ; jmenuitem item6 = new jmenuitem ( "change permissions" ) ; item6 . addmouselistener ( new mouselistener ( ) { public void mouseclicked ( mouseevent e ) { } public void mouseentered ( mouseevent e ) { } public void mouseexited ( mouseevent e ) { } public void mousepressed ( mouseevent e ) { string [ ] temp = rightclickedlbl . getname ( ) . split ( "<litcomma>" ) ; permissiondialog p = new permissiondialog ( mainframe , thisdir , integer . parseint ( temp [ 2 ] ) ) ; mainpanel . add ( p ) ; } public void mousereleased ( mouseevent e ) { } } ) ; jmenuitem item7 = new jmenuitem ( "change owner" ) ; item7 . addmouselistener ( new mouselistener ( ) { public void mouseclicked ( mouseevent e ) { } public void mouseentered ( mouseevent e ) { } public void mouseexited ( mouseevent e ) { } public void mousepressed ( mouseevent e ) { string [ ] temp = rightclickedlbl . getname ( ) . split ( "<litcomma>" ) ; changeownerdialog c = new changeownerdialog ( mainframe , thisdir , integer . parseint ( temp [ 2 ] ) ) ; mainpanel . add ( c ) ; } public void mousereleased ( mouseevent e ) { } } ) ; rightclickmenu . add ( item4 ) ; rightclickmenu . add ( item5 ) ; rightclickmenu . add ( item1 ) ; rightclickmenu . add ( item2 ) ; rightclickmenu . add ( item6 ) ; rightclickmenu . add ( item7 ) ; rightclickmenu . add ( item3 ) ; }
tr	3	static public void collectitemstats ( statmap stats , statalloc [ ] statallocs , double statbudget ) { if ( statallocs != null ) { for ( statalloc x : statallocs ) { stats . add ( x . stat , ( int ) ( 0.5 + statbudget * x . alloc ) ) ; } } }
tr	8	void chargermap ( string nommap ) { try { fileinputstream entreedeficher = new fileinputstream ( nommap ) ; objectinputstream entreedobjet = new objectinputstream ( entreedeficher ) ; this . carte = ( case [ ] [ ] ) entreedobjet . readobject ( ) ; entreedobjet . close ( ) ; } catch ( filenotfoundexception e ) { e . printstacktrace ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } catch ( classnotfoundexception e ) { e . printstacktrace ( ) ; } if ( this . carte != null ) { system . out . println ( "la carte " + nommap + " a ete chargee." ) ; } }
tr	9	public void parsejson ( string filename ) { try { inputstream is = new fileinputstream ( filename ) ; jsonparser parser = json . createparser ( is ) ; while ( parser . hasnext ( ) ) { event event = parser . next ( ) ; switch ( event ) { case key_name : parser . getstring ( ) ; break ; case value_string : break ; case value_number : break ; case value_false : break ; case value_true : break ; case value_null : break ; default : } } } catch ( filenotfoundexception ex ) { system . out . println ( ex ) ; } }
tr	2	private void processmultivaluefield ( int pos , entry < ? , ? > entry , datafield datafield , map < integer , list < string > > results ) throws exception { string result = "" ; object value = entry . getvalue ( ) ; class < ? > type = value . getclass ( ) ; format < ? > format = formatfactory . getformat ( type , getlocale ( ) , datafield ) ; result = formatstring ( format , value ) ; if ( ! results . containskey ( pos ) ) { list < string > list = new linkedlist < string > ( ) ; list . add ( result ) ; results . put ( pos , list ) ; } else { list < string > list = results . get ( pos ) ; list . add ( result ) ; } }
tr	4	private void scanfiles ( file dir ) { file [ ] files = dir . listfiles ( ) ; for ( file file : files ) { if ( file . isdirectory ( ) ) { scanfiles ( file ) ; } else { try { findstring ( file , search_text ) ; } catch ( ioexception ex ) { util . handleexception ( ex ) ; } } } }
tr	3	public static commentwapper constructwappercomments ( response res ) throws weiboexception { jsonobject json = res . asjsonobject ( ) ; try { jsonarray comments = json . getjsonarray ( "comments" ) ; int size = comments . length ( ) ; list < comment > comment = new arraylist < comment > ( size ) ; for ( int i = 0 ; i < size ; i ++ ) { comment . add ( new comment ( comments . getjsonobject ( i ) ) ) ; } long previouscursor = json . getlong ( "previous_curosr" ) ; long nextcursor = json . getlong ( "next_cursor" ) ; long totalnumber = json . getlong ( "total_number" ) ; string hasvisible = json . getstring ( "hasvisible" ) ; return new commentwapper ( comment , previouscursor , nextcursor , totalnumber , hasvisible ) ; } catch ( jsonexception jsone ) { throw new weiboexception ( jsone ) ; } }
tr	2	@ override public void setpluginhelper ( pluginhelper pluginhelper ) { super . setpluginhelper ( pluginhelper ) ; pozdravy = ( hashmap < string , string > ) pluginhelper . loaddata ( ) ; if ( pozdravy == null ) { pozdravy = new hashmap < > ( ) ; } }
tr	3	private static list < string > rareitems ( hackresult hackresult ) { list < string > res = new arraylist < > ( ) ; for ( hackitem hackitem : hackresult . hack . items ) { if ( hackitem . hasrarity ( ) ) res . add ( hackitem . tostring ( ) ) ; } return res ; }
tr	4	@ override public void service ( ) throws ioexception { try { printwriter pw = getprintwriter ( socket ) ; log . info ( "user login<litcomma> no = " + this . userno ) ; pw . println ( this . userno ) ; } catch ( exception e ) { log . error ( e . getmessage ( ) ) ; e . printstacktrace ( ) ; } finally { if ( null != socket ) { socket . close ( ) ; } } }
tr	2	public void paintcomponent ( graphics g ) { super . paintcomponent ( g ) ; if ( istargetcell ) { g . setcolor ( color . black ) ; g . drawline ( 0 , 0 , getsize ( ) . width , 0 ) ; } }
tr	9	public string getosmpath ( ) { if ( osmpath == null ) { synchronized ( this ) { osmpath = properties . getproperty ( "osm-path" ) ; if ( osmpath == null ) throw new illegalargumentexception ( "please set a valid osm-path." ) ; if ( ! osmpath . endswith ( file . separator ) ) osmpath = osmpath + file . separator ; if ( ! new file ( osmpath ) . isdirectory ( ) ) throw new illegalargumentexception ( "please set a valid osm-path." ) ; } } return osmpath ; }
tr	5	public problem get ( final algorithmtype type , final puzzle puzzle ) { columnnode head = puzzleconvertor . instance . converttonetwork ( puzzle ) . head ( ) ; switch ( type ) { case naive : return new naivedancinglinks ( head ) ; case basic : return new basicdancinglinks ( head ) ; case min_column : return new mincolumndancinglinks ( head ) ; case degree : return new degreedancinglinks ( head ) ; default : throw new illegalargumentexception ( "algorithm type: " + type + " is unsupported." ) ; } }
tr	5	private synchronized void initmanager ( string name , string classname ) throws torqueexception { abstractbasemanager manager = ( abstractbasemanager ) managers . get ( name ) ; if ( manager == null ) { if ( classname != null && classname . length ( ) != 0 ) { try { manager = ( abstractbasemanager ) class . forname ( classname ) . newinstance ( ) ; managers . put ( name , manager ) ; } catch ( exception e ) { throw new torqueexception ( "could not instantiate " + "manager associated with class: " + name , e ) ; } } } }
tr	6	private void makeprefab ( ) { prefab = new prefab ( x1 , y1 , x2 , y2 ) ; boolean found = true ; int filenumber = 0 ; string pathtag = "houseprefab" ; string path = "" ; do { path = "data/" + pathtag + string . valueof ( filenumber ) + ".pfb" ; file f = new file ( path ) ; if ( ! f . isfile ( ) ) { found = false ; } else { filenumber ++ ; } } while ( found ) ; try { prefab . save ( path ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } }
tr	9	private void drawmoveanim ( final graphics2d g2d ) { if ( moveanim != null ) { if ( moveanim . isfinished ( ) ) { leavemoveanim = new uileaveanim ( moveanim , 0 ) ; moveanim = null ; } else { moveanim . draw ( g2d ) ; } } if ( leavemoveanim != null ) { if ( leavemoveanim . isfinished ( ) ) { leavemoveanim = null ; } else { leavemoveanim . draw ( g2d ) ; } } }
tr	1	public double getrate ( ) { return mrate ; }
tr	9	private void dodrawing ( graphics g ) { graphics2d g2d = ( graphics2d ) g ; g2d . setcolor ( color . red ) ; dimension size = getsize ( ) ; insets insets = getinsets ( ) ; int w = size . width - insets . left - insets . right ; int h = size . height - insets . top - insets . bottom ; int middle = w > > 1 ; g2d . setcolor ( color . black ) ; g2d . drawline ( 0 , h > > 1 , w , h > > 1 ) ; g2d . drawline ( w > > 1 , 0 , w > > 1 , h ) ; int barlength = 0 ; int barheight = 0 ; if ( max != 0 ) { barlength = ( int ) ( ( double ) middle / ( double ) max * ( double ) ( success < 0 ? - 1 * success : success ) ) ; barheight = h - 11 ; } if ( success > 0 ) { g2d . setcolor ( color . green ) ; g2d . fillrect ( middle + 1 , 5 , barlength , barheight ) ; } else if ( success < 0 ) { g2d . setcolor ( color . red ) ; g2d . fillrect ( middle - barlength , 5 , barlength , barheight ) ; } else { g2d . setcolor ( color . blue ) ; g2d . fillrect ( middle - 5 , 5 , 10 , barheight ) ; } }
tr	10	private list < string > getproperties ( class < ? > clazz ) { list < string > properties = new arraylist < string > ( ) ; iterable < field > fields = filter ( arrays . aslist ( clazz . getdeclaredfields ( ) ) , new predicate < field > ( ) { @ override public boolean apply ( field input ) { return ! modifier . isstatic ( input . getmodifiers ( ) ) ; } } ) ; for ( field f : fields ) { string name = f . getname ( ) ; object value = null ; try { value = f . get ( this ) ; } catch ( illegalargumentexception e ) { value = "unable to get value: " + e ; } catch ( illegalaccessexception e ) { value = "unable to get value: " + e ; } finally { properties . add ( name + ": " + value ) ; } } class < ? > superclass = clazz . getsuperclass ( ) ; if ( superclass != null ) { properties . addall ( getproperties ( superclass ) ) ; } return properties ; }
tr	3	private int getlargestbucketid ( ) { int max = 0 ; int rememberid = - 1 ; for ( int i = 0 ; i < numberofbuckets ; i ++ ) { bucket < data > oldbucket = bucketcontainer . getbucket ( i ) ; if ( oldbucket . elementsinbucket > max ) { max = oldbucket . elementsinbucket ; rememberid = oldbucket . getbucketid ( ) ; } } return rememberid ; }
tr	10	public list < location > adjacentlocations ( location location ) { assert location != null : "null location passed to adjacentlocations" ; list < location > locations = new linkedlist < location > ( ) ; if ( location != null ) { int row = location . getrow ( ) ; int col = location . getcol ( ) ; for ( int roffset = - 1 ; roffset <= 1 ; roffset ++ ) { int nextrow = row + roffset ; if ( nextrow >= 0 && nextrow < depth ) { for ( int coffset = - 1 ; coffset <= 1 ; coffset ++ ) { int nextcol = col + coffset ; if ( nextcol >= 0 && nextcol < width && ( roffset != 0 || coffset != 0 ) ) { locations . add ( new location ( nextrow , nextcol ) ) ; } } } } collections . shuffle ( locations , rand ) ; } return locations ; }
tr	7	private java . util . calendar findnextdimecres ( int nweeks ) { java . util . date utildate = m_cal . gettime ( ) ; calendar m_cal2 = calendar . getinstance ( ) ; m_cal2 . settime ( utildate ) ; m_cal2 . set ( calendar . hour_of_day , 0 ) ; m_cal2 . set ( calendar . minute , 0 ) ; m_cal2 . set ( calendar . second , 0 ) ; m_cal2 . set ( calendar . millisecond , 0 ) ; switch ( intdiasetmana ) { case 1 : m_cal2 . add ( calendar . day_of_month , 2 + nweeks * 7 ) ; break ; case 2 : m_cal2 . add ( calendar . day_of_month , 7 + nweeks * 7 ) ; break ; case 3 : m_cal2 . add ( calendar . day_of_month , 7 + nweeks * 7 ) ; break ; case 4 : m_cal2 . add ( calendar . day_of_month , 6 + nweeks * 7 ) ; break ; case 5 : m_cal2 . add ( calendar . day_of_month , 5 + nweeks * 7 ) ; break ; case 6 : m_cal2 . add ( calendar . day_of_month , 4 + nweeks * 7 ) ; break ; case 7 : m_cal2 . add ( calendar . day_of_month , 3 + nweeks * 7 ) ; break ; } return m_cal2 ; }
tr	3	public void input ( inputevent e ) { if ( e . getclass ( ) . equals ( inputevent2d . class ) ) { if ( e . getcommand ( ) == null ) { ( ( view2d ) view ) . movecharacter ( ( inputevent2d ) e ) ; game . addundo ( ) ; return ; } } finished = game . processcommand ( e . getcommand ( ) ) ; }
tr	7	@ suppresswarnings ( "unused" ) public material getblock ( gameworld world , int x , int y ) { material block = getrawblock ( x , y ) ; if ( block == stone && false ) { int orearound = world . oreamountaround ( x , y ) ; if ( orearound == 4 || ( orearound > 0 && prnd . nextint ( 4 ) < orearound ) || prnd . nextint ( 64 ) == 0 ) { block = getrandomorematerial ( ) ; } } return block ; }
tr	4	@ override public void popupmenuwillbecomevisible ( popupmenuevent e ) { jcombobox combobox = ( jcombobox ) e . getsource ( ) ; if ( combobox . getitemcount ( ) == 0 ) return ; final object child = combobox . getaccessiblecontext ( ) . getaccessiblechild ( 0 ) ; if ( child instanceof basiccombopopup ) { swingutilities . invokelater ( new runnable ( ) { public void run ( ) { customizepopup ( ( basiccombopopup ) child ) ; } } ) ; } }
tr	2	public static double loggammadefinition ( double z ) { double result = euler_mascheroni * z - math . log ( z ) ; for ( int k = 1 ; k < 10000000 ; k ++ ) { result += ( z / k ) - math . log ( 1 + ( z / k ) ) ; } return result ; }
tr	9	private void resolve ( action playeraction , action creatureaction ) { if ( playeraction != null ) { if ( actionisnotmultiroundaction ( player , playeraction ) ) { resolveattack ( playeraction , creatureaction , player , creature , creatureactionsinplay ) ; } } if ( creatureaction != null ) { if ( actionisnotmultiroundaction ( creature , creatureaction ) ) { resolveattack ( creatureaction , playeraction , creature , player , playeractionsinplay ) ; } } }
tr	3	public hitbox returnhitbox ( ) { if ( hullhitbox == null || shield . getenergy ( ) > 0 ) { return shieldhitbox ; } return hullhitbox ; }
tr	2	@ override public response credits ( ) throws ioexception { if ( username . equals ( "" ) ) { return new messageresponse ( "please log in first." ) ; } else { synchronized ( users ) { return new creditsresponse ( long . valueof ( users . get ( username ) . getcredits ( ) ) ) ; } } }
tr	3	private void moveto ( binarytreenode < k , v > target ) { binarytreenode < k , v > parent = target . parent ; if ( parent != null ) { if ( parent . isleftchild ( target ) ) { parent . setleft ( this ) ; } else { parent . setright ( this ) ; } } }
tr	7	@ override public void run ( ) { try { try { logger . loginfo ( "clienthandler started" ) ; while ( ! interrupted ( ) ) { try { command cmd = nc . readcommand ( ) ; commandexecutor . queuecommand ( new commandfromclient ( cmd , this ) ) ; } catch ( sockettimeoutexception e ) { } catch ( socketclosedexception e ) { logger . loginfo ( "client closed socket" ) ; break ; } catch ( ioexception e ) { logger . logexception ( e , "couldn't read command" ) ; break ; } } } finally { onexit ( ) ; } } catch ( exception e ) { logger . logexception ( e , "uncaught exception!" ) ; } }
tr	7	private static void normalizedcarrays ( xmpnode dcschema ) throws xmpexception { for ( int i = 1 ; i <= dcschema . getchildrenlength ( ) ; i ++ ) { xmpnode currprop = dcschema . getchild ( i ) ; propertyoptions arrayform = ( propertyoptions ) dcarrayforms . get ( currprop . getname ( ) ) ; if ( arrayform == null ) { continue ; } else if ( currprop . getoptions ( ) . issimple ( ) ) { xmpnode newarray = new xmpnode ( currprop . getname ( ) , arrayform ) ; currprop . setname ( xmpconst . array_item_name ) ; newarray . addchild ( currprop ) ; dcschema . replacechild ( i , newarray ) ; if ( arrayform . isarrayalttext ( ) && ! currprop . getoptions ( ) . gethaslanguage ( ) ) { xmpnode newlang = new xmpnode ( xmpconst . xml_lang , xmpconst . x_default , null ) ; currprop . addqualifier ( newlang ) ; } } else { currprop . getoptions ( ) . setoption ( propertyoptions . array | propertyoptions . array_ordered | propertyoptions . array_alternate | propertyoptions . array_alt_text , false ) ; currprop . getoptions ( ) . mergewith ( arrayform ) ; if ( arrayform . isarrayalttext ( ) ) { repairalttext ( currprop ) ; } } } }
tr	1	public string gettimeframe ( ) { return mtimeframe ; }
tr	8	private void dotriggeredactions ( action attack , action defend , combatant attacker , combatant defender , list < action > defenderactionsinplay ) { if ( defenderactionsinplay != null && ! defenderactionsinplay . isempty ( ) ) { action triggeredaction = null ; for ( action action : defenderactionsinplay ) { if ( action . gettrigger ( ) . equals ( attack . gettype ( ) ) ) { triggeredaction = action ; break ; } } if ( triggeredaction != null ) { defenderactionsinplay . remove ( triggeredaction ) ; resolveattack ( triggeredaction , attack , defender , attacker , null ) ; } } }
tr	3	public arraylist < repere > getreperevalide ( ) { arraylist < repere > result = new arraylist < repere > ( ) ; for ( segment segment : this ) { point candidat = segment . getdestination ( ) . getcontent ( ) ; if ( candidat instanceof repere ) result . add ( ( repere ) candidat ) ; } return result ; }
tr	7	private void toteutafysiikka ( ) { if ( lukitse && palikallaonalusta ) { lukitsepalikka ( ) ; } else if ( aikayksikko < 0 && ! palikallaonalusta ) { pudotapalikkaanegaikayksikko ( ) ; } else if ( pudota ) { if ( ! palikallaonalusta ) { nykyinenpalikka . liiku ( 0 , 1 ) ; nollaaajastimet ( ) ; } } }
tr	4	private static list < string > mix ( int start , int [ ] nodes ) { arraylist < string > result = new arraylist < string > ( ) ; if ( nodes . length <= start ) { string temp = goncalculate ( nodes ) ; if ( temp != null ) { result . add ( temp ) ; } } else { for ( int i = start ; i < nodes . length ; i ++ ) { int temp = nodes [ i ] ; nodes [ i ] = nodes [ start ] ; nodes [ start ] = temp ; result . addall ( mix ( start + 1 , nodes ) ) ; temp = nodes [ i ] ; nodes [ i ] = nodes [ start ] ; nodes [ start ] = temp ; } } return result ; }
tr	3	private void runcomputation ( ) { long counter = 0 ; int binarycounter = 0 ; while ( binarycounter < this . binarycountermax && this . iscomputation ) { string [ ] tmpcolumns = this . getcolumncombination ( binarycounter ) ; float tmprisk = this . myre . getidentifierrisk ( tmpcolumns ) ; deepsearchrrlist . getinstance ( ) . addriskresult ( new riskresult ( binarycounter , tmprisk ) ) ; binarycounter ++ ; } }
tr	7	private void gameover ( ) { switch ( isgameover ( ) ) { case 0 : break ; case - 1 : for ( player p : players ) { if ( p . gethero ( ) . getteam ( ) . getside ( ) == team . side . right ) { endgame ( p . gethero ( ) . getteam ( ) ) ; return ; } } break ; case 1 : for ( player p : players ) { if ( p . gethero ( ) . getteam ( ) . getside ( ) == team . side . left ) { endgame ( p . gethero ( ) . getteam ( ) ) ; return ; } } break ; } }
tr	7	public static boolean sortsafter ( object object , object object2 ) { string var1 = string . valueof ( object ) ; string var2 = string . valueof ( object2 ) ; boolean isnumvar1 = mfnc . $isvalidnum ( var1 ) ; boolean isnumvar2 = mfnc . $isvalidnum ( var2 ) ; boolean isafter = false ; if ( isnumvar1 && isnumvar2 ) { isafter = double . parsedouble ( var1 ) > double . parsedouble ( var2 ) ; } else if ( isnumvar1 && ! isnumvar2 ) { isafter = false ; } else if ( ! isnumvar1 && isnumvar2 ) { isafter = true ; } else { isafter = var1 . compareto ( var2 ) > 0 ; } return isafter ; }
tr	2	private void drawelementto ( graphics2d g2 , gameboardelement element ) { drawshadowto ( g2 , element . getcurrentposition ( ) ) ; drawspriteto ( g2 , element ) ; if ( element instanceof factionmember ) { drawelementpowerto ( g2 , ( factionmember ) element ) ; } }
tr	4	@ override public object eval ( oclcontext context ) throws oclevaluationexception { object source = this . source . eval ( context ) ; collection < ? > collection ; if ( source == null ) { collection = collections . emptylist ( ) ; } else if ( source . getclass ( ) . isarray ( ) ) { collection = arrays . aslist ( ( object [ ] ) source ) ; } else if ( ! ( source instanceof collection < ? > ) ) { collection = collections . singletonlist ( source ) ; } else { collection = ( collection < ? > ) source ; } string iteratorname = this . getiterator ( ) . getname ( ) ; string accuname = this . accumulator . getname ( ) ; object initaccu = this . accumulator . init ( context ) ; return ocliteratesupport . iterate ( collection , context , iteratorname , accuname , initaccu , this . getbody ( ) ) ; }
tr	1	public static double loggamma ( double z ) { return loggammastirling ( z ) ; }
tr	2	public void setquerystr ( string querystr ) { if ( querystr != null ) this . querystr = querystr ; }
tr	2	public list < linetype > createpiecelines ( final angleunitflappattern pattern ) { linkedlist < linetype > lines = new linkedlist < > ( pattern . getlines ( ) . sublist ( pattern . findfirstlineindex ( ) , pattern . getdivisionsize ( ) ) ) ; while ( lines . getlast ( ) == linetype . empty ) { lines . removelast ( ) ; } return lines ; }
tr	2	public void run ( ) { output = "" ; if ( querystr . equals ( "" ) ) { gettables ( ) ; i = system . currenttimemillis ( ) ; } else { long rowcount = filltables ( ) ; i = ( system . currenttimemillis ( ) - i ) ; output += thread . currentthread ( ) . getname ( ) + " finished after " + i + " ms<litcomma> resulted in " + rowcount + " rows.<p>" ; } }
tr	4	@ override public object invoke ( object proxy , method method , object [ ] args ) throws throwable { object obj = getlatest ( proxy ) ; if ( obj == null ) { throw new runtimeexception ( "failed to load class '" + classname + "'." ) ; } try { return method . invoke ( obj , args ) ; } catch ( invocationtargetexception e ) { throw e . getcause ( ) ; } }
tr	9	@ override public void excecutecommand ( string channel , string sender , string message ) throws exception { this . channel = channel ; string [ ] args = message . split ( " " ) ; switch ( args [ 1 ] ) { case "start" : if ( games . containskey ( sender ) ) { games . get ( sender ) . start ( ) ; } else { games . put ( sender , new blackjack ( ) ) ; } break ; case "hit" : if ( games . containskey ( sender ) && games . get ( sender ) . isstarted ) { games . get ( sender ) . hit ( ) ; } else { sendmessage ( channel , "please use !blackjack start first." ) ; } break ; case "stand" : if ( games . containskey ( sender ) && games . get ( sender ) . isstarted ) { games . get ( sender ) . dealerhit ( ) ; } else { sendmessage ( channel , "please use !blackjack start first." ) ; } break ; default : break ; } }
tr	8	public void move ( int direction , double delta ) { if ( direction == left && xa > - walkspeed || direction == right && xa < walkspeed ) { xa = xa + ( direction == left ? - 1 : 1 ) * ( walkspeed * ( onground ? 1 : 0.5 ) * 10 * delta ) ; } faceright = direction == right ; tickhorizontalmovement += xa * delta ; }
tr	10	@ override public synchronized void run ( ) { int index = 0 ; string tag_values = ")" ; while ( true ) { try { thread . sleep ( 1000 ) ; final string tag_value = reader . readsensorfile ( tag , index ) ; if ( tag_values . equals ( ")" ) ) { tag_values = tag_value + tag_values ; } else { tag_values = tag_value + "<litcomma> " + tag_values ; } sensorgui . setvaluelabel ( tag_value ) ; if ( index % 5 == 0 ) { tag_values = "(" + tag_values ; service . updatesensorvalues ( name , tag , tag_values ) ; tag_values = ")" ; } if ( index == 38 ) { index = 0 ; } else { index = index + 1 ; } } catch ( interruptedexception e ) { e . printstacktrace ( ) ; } } }
tr	6	public static string getfulltablename ( final string table , final string dbname ) throws torqueexception { if ( table != null ) { int dotindex = table . indexof ( "." ) ; if ( dotindex == - 1 ) { string targetdbname = ( dbname == null ) ? torque . getdefaultdb ( ) : dbname ; string targetschema = torque . getschema ( targetdbname ) ; if ( stringutils . isnotempty ( targetschema ) ) { return new stringbuffer ( ) . append ( targetschema ) . append ( "." ) . append ( table ) . tostring ( ) ; } } } return table ; }
tr	5	private boolean isoutofbounds ( mapobject obj ) { int px = player . getscreenxpos ( ) ; int py = player . getscreenypos ( ) ; int arroundx = 32 * 16 ; int arroundy = 32 * 10 ; int somex = px - arroundx ; int somexmax = px + arroundx ; int somey = py - arroundy ; int someymax = py + arroundy ; if ( obj . getscreenxpos ( ) >= somex && obj . getscreenxpos ( ) < somexmax ) if ( obj . getscreenypos ( ) >= somey && obj . getscreenypos ( ) < someymax ) return false ; return true ; }
tr	3	public user isvalidlogin ( string email , string password ) { user user = userdao . finduserbyemail ( email , password ) ; if ( user == null || ! user . getpassword ( ) . equals ( password ) ) { return null ; } return user ; }
tr	9	private void jbutton3actionperformed ( java . awt . event . actionevent evt ) { if ( ( int ) addreservationparkingspot . getselecteditem ( ) == 0 ) { addreservationmessage . settext ( "check parking spot" ) ; } else if ( ( string ) hours . getselecteditem ( ) == "hour" ) { addreservationmessage . settext ( "check start time" ) ; } else if ( ( string ) houre . getselecteditem ( ) == "hour" ) { addreservationmessage . settext ( "check end time" ) ; } else if ( ( string ) month . getselecteditem ( ) == "month" ) { addreservationmessage . settext ( "check month" ) ; } else if ( ( string ) year . getselecteditem ( ) == "year" ) { addreservationmessage . settext ( "check year" ) ; } else if ( ( string ) day . getselecteditem ( ) == "day" ) { addreservationmessage . settext ( "check day" ) ; } else if ( ( string ) addreservationuser . getselecteditem ( ) == null ) { addreservationmessage . settext ( "check username" ) ; } else { garage gdb = accessdatabase . readgaragedb ( ) ; gdb . addreserved ( new parkingsession ( ( int ) addreservationparkingspot . getselecteditem ( ) , integer . valueof ( ( string ) hours . getselecteditem ( ) ) , integer . valueof ( ( string ) houre . getselecteditem ( ) ) , integer . valueof ( ( string ) month . getselecteditem ( ) ) , integer . valueof ( ( string ) day . getselecteditem ( ) ) , ( int ) year . getselectedindex ( ) - 1 , ( string ) addreservationuser . getselecteditem ( ) ) ) ; accessdatabase . writegaragedb ( gdb ) ; addreservationmessage . settext ( "added reservation for: " + ( string ) addreservationuser . getselecteditem ( ) ) ; garage gdb1 = accessdatabase . readgaragedb ( ) ; addreservationparkingspot . removeallitems ( ) ; int [ ] availablespots2 = gdb1 . getavailable ( ) ; for ( int i = 0 ; i < availablespots2 . length ; i ++ ) { addreservationparkingspot . additem ( availablespots2 [ i ] ) ; } } }
tr	6	public int bwt ( ) { final int [ ] sa = this . sa ; final byte [ ] t = this . t ; final int n = this . n ; final int [ ] bucketa = new int [ bzip2divsufsort . bucket_a_size ] ; final int [ ] bucketb = new int [ bzip2divsufsort . bucket_b_size ] ; if ( n == 0 ) { return 0 ; } else if ( n == 1 ) { sa [ 0 ] = t [ 0 ] ; return 0 ; } int m = sorttypebstar ( bucketa , bucketb ) ; if ( 0 < m ) { return constructbwt ( bucketa , bucketb ) ; } return 0 ; }
tr	8	protected void buildinternal ( multilabelinstances input ) throws exception { labelindices = input . getlabelindices ( ) ; numlabels = input . getnumlabels ( ) ; ensemble = new filteredclassifier [ numlabels ] ; datatransformation = new datatransformation ( ) ; datatransformation . initialize ( input ) ; if ( datatransformation . getnumberofallzeros ( ) > 0 ) { instances trainallzero = datatransformation . transformtozerodata ( input ) ; debug ( "bulding model for all zeros" ) ; allzeros = abstractclassifier . makecopy ( baseclassifier ) ; allzeros . buildclassifier ( trainallzero ) ; } transformeddata = datatransformation . transforminstances ( input ) ; instances trainingdata = transformeddata . getdataset ( ) ; for ( int i = 0 ; i < numlabels ; i ++ ) { ensemble [ i ] = new filteredclassifier ( ) ; ensemble [ i ] . setclassifier ( abstractclassifier . makecopy ( baseclassifier ) ) ; int [ ] indicestoremove = new int [ numlabels - 1 ] ; int counter2 = 0 ; for ( int j = 0 ; j < numlabels ; j ++ ) { if ( labelindices [ j ] != labelindices [ i ] ) { indicestoremove [ counter2 ] = labelindices [ j ] ; counter2 ++ ; } } remove remove = new remove ( ) ; remove . setattributeindicesarray ( indicestoremove ) ; remove . setinputformat ( trainingdata ) ; remove . setinvertselection ( false ) ; ensemble [ i ] . setfilter ( remove ) ; trainingdata . setclassindex ( labelindices [ i ] ) ; debug ( "bulding model " + ( i + 1 ) + "/" + numlabels ) ; ensemble [ i ] . buildclassifier ( trainingdata ) ; } }
tr	10	private static final string createmessage ( final class < ? extends object > objectclass , final serializable ... ids ) { final stringbuilder builder = new stringbuilder ( ) ; if ( objectclass == null ) builder . append ( "[type => " + objectclass . getsimplename ( ) + "]" ) ; if ( ids != null && ids . length > 0 ) for ( final serializable id : ids ) if ( id != null ) builder . append ( "[id => [" + id . getclass ( ) . getsimplename ( ) + "][" + id . tostring ( ) + "]]" ) ; return builder . tostring ( ) ; }
tr	5	private string inputaccruednationalnumber ( ) { int lengthofnationalnumber = nationalnumber . length ( ) ; if ( lengthofnationalnumber > 0 ) { string tempnationalnumber = "" ; for ( int i = 0 ; i < lengthofnationalnumber ; i ++ ) { tempnationalnumber = inputdigithelper ( nationalnumber . charat ( i ) ) ; } return abletoformat ? appendnationalnumber ( tempnationalnumber ) : accruedinput . tostring ( ) ; } else { return prefixbeforenationalnumber . tostring ( ) ; } }
tr	8	@ override public type gettype ( ) { switch ( presence . gettype ( ) ) { case available : return type . available ; case error : return type . error ; case subscribe : return type . subscribe ; case subscribed : return type . subscribed ; case unavailable : return type . unavailable ; case unsubscribe : return type . unsubscribe ; case unsubscribed : return type . unsubscribed ; default : throw new runtimeexception ( "unknown type of presence: " + presence . gettype ( ) ) ; } }
tr	2	public void compile ( string parentdir ) { int diagramnum = 1 ; pdfinfo = new compiledpdfinfo ( ) ; for ( diagramsettings diagram : diagrams ) { diagram . compile ( pdfinfo , parentdir , diagramnum ) ; diagramnum ++ ; } }
tr	8	@ override public int compareto ( point o ) { if ( ! approxequals ( x , o . x ) ) return ( int ) math . signum ( x - o . x ) ; if ( ! approxequals ( y , o . y ) ) return ( int ) math . signum ( y - o . y ) ; if ( ! approxequals ( z , o . z ) ) return ( int ) math . signum ( z - o . z ) ; return 0 ; }
tr	8	public static void main ( string [ ] args ) { extendednntpops ops ; int argc = args . length ; if ( argc < 1 ) { system . err . println ( "usage: extendednntpops nntpserver [username password]" ) ; system . exit ( 1 ) ; } ops = new extendednntpops ( ) ; ops . demo ( args [ 0 ] , argc >= 3 ? args [ 1 ] : null , argc >= 3 ? args [ 2 ] : null ) ; }
tr	9	@ override public void actionperformed ( actionevent e ) { switch ( e . getactioncommand ( ) ) { case "lopeta" : system . exit ( 0 ) ; break ; case "kirjaudu ulos" : ikkuna . kirjaaulos ( ) ; break ; case "uusi k\xe4ytt\xe4j\xe4tunnus/oppilas..." : ikkuna . vaihdapaneeli ( new lisaakayttaja ( ikkuna ) ) ; break ; case "uusi ryhm\xe4" : ikkuna . vaihdapaneeli ( new lisaaryhma ( ikkuna ) ) ; break ; case "uusi kurssi" : ikkuna . vaihdapaneeli ( new lisaakurssi ( ikkuna ) ) ; break ; case "hallinnoi oppilaita/k\xe4ytt\xe4ji\xe4" : ikkuna . vaihdapaneeli ( new etsikayttaja ( ikkuna ) ) ; break ; case "hallinnoi kursseja" : ikkuna . vaihdapaneeli ( new etsikurssi ( ikkuna ) ) ; break ; case "hallinnoi ryhmi\xe4" : ikkuna . vaihdapaneeli ( new etsiryhma ( ikkuna ) ) ; break ; case "hallinnoi lukuj\xe4rjestyksi\xe4" : ikkuna . vaihdapaneeli ( new etsilukkari ( ikkuna ) ) ; break ; } }
tr	5	public c clone ( ) { c result = null ; n noeud_origine = null , noeud_destination = null ; a arete_tmp = null ; try { result = ( c ) this . classe_chemin . newinstance ( ) ; if ( this . isempty ( ) ) return result ; noeud_origine = this . get ( 0 ) . getorigine ( ) . clone ( ) ; for ( a arete : this ) { noeud_destination = arete . getdestination ( ) . clone ( ) ; arete_tmp = this . classe_arete . getdeclaredconstructor ( new class [ ] { this . classe_noeud , this . classe_noeud , double . class } ) . newinstance ( noeud_origine , noeud_destination , arete . weight ) ; noeud_origine = noeud_destination ; result . add ( arete_tmp ) ; } result . classe_chemin = this . classe_chemin ; result . length = this . length ; } catch ( exception e ) { system . out . println ( "clonage du chemin \xe9chou\xe9" ) ; } return result ; }
tr	10	public boolean changedcategory ( ) { if ( ( originalproduct == null ) && ( changedproduct == null ) ) return false ; else if ( ( originalproduct == null ) || ( changedproduct == null ) ) return true ; else if ( ( originalproduct . getcategory ( ) == null ) && ( changedproduct . getcategory ( ) == null ) ) return false ; else if ( ( originalproduct . getcategory ( ) == null ) || ( changedproduct . getcategory ( ) == null ) ) return true ; else if ( originalproduct . getcategory ( ) . getcategoryid ( ) == originalproduct . getcategory ( ) . getcategoryid ( ) ) return false ; else return true ; }
tr	7	@ override public void run ( ) { bestscores = new arraylist < > ( 10 ) ; httpurlconnection connect = null ; try { url url = new url ( uri + "?order=-score&limit=10" ) ; connect = ( httpurlconnection ) url . openconnection ( ) ; connect . setrequestmethod ( "get" ) ; connect . addrequestproperty ( "x-parse-application-id" , app_id ) ; connect . addrequestproperty ( "x-parse-rest-api-key" , client_key ) ; connect . setreadtimeout ( 60000 ) ; connect . setconnecttimeout ( 60000 ) ; int statuscode = connect . getresponsecode ( ) ; switch ( statuscode ) { case httpurlconnection . http_ok : break ; default : throw new exception ( "invalid response code: " + statuscode ) ; } bufferedreader br = new bufferedreader ( new inputstreamreader ( connect . getinputstream ( ) ) ) ; stringbuilder sb = new stringbuilder ( ) ; string line ; while ( ( line = br . readline ( ) ) != null ) { sb . append ( line ) ; sb . append ( "\\n" ) ; } system . out . println ( sb ) ; jsontoscore ( sb . tostring ( ) ) ; } catch ( exception e ) { system . out . println ( "exception caught" ) ; e . printstacktrace ( ) ; bestscores = null ; } finally { if ( connect != null ) { connect . disconnect ( ) ; } } model . setbestscores ( bestscores ) ; }
tr	1	private static void preparepbf ( string testfile ) { model model = new model ( ) ; nerfeature = new nerfeature ( model ) ; timer timer = new timer ( ) ; timer . start ( "extracting features" ) ; processfileforpbf ( testfile ) ; timer . endprint ( ) ; }
tr	6	private final string getchunk ( string s , int slength , int marker ) { stringbuilder chunk = new stringbuilder ( ) ; char c = s . charat ( marker ) ; chunk . append ( c ) ; marker ++ ; if ( isdigit ( c ) ) { while ( marker < slength ) { c = s . charat ( marker ) ; if ( ! isdigit ( c ) ) break ; chunk . append ( c ) ; marker ++ ; } } else { while ( marker < slength ) { c = s . charat ( marker ) ; if ( isdigit ( c ) ) break ; chunk . append ( c ) ; marker ++ ; } } return chunk . tostring ( ) ; }
tr	7	public void asolve ( final double [ ] b , final double [ ] x , final int itrnsp ) { int i , j ; double diag ; for ( i = 0 ; i < n ; i ++ ) { diag = 0.0 ; for ( j = mat . col_ptr [ i ] ; j < mat . col_ptr [ i + 1 ] ; j ++ ) if ( mat . row_ind [ j ] == i ) { diag = mat . val [ j ] ; break ; } x [ i ] = ( diag != 0.0 ? b [ i ] / diag : b [ i ] ) ; } }
tr	7	public languagecontroller createlanguagecontroller ( string languagename ) { languagecontroller languagecontroller = new englishlanguagecontroller ( ) ; if ( languagename != null ) { if ( languagename . equals ( "italian" ) ) { languagecontroller = new italianlanguagecontroller ( ) ; } else if ( languagename . equals ( "norwegian" ) ) { languagecontroller = new norwegianlanguagecontroller ( ) ; } else if ( languagename . equals ( "french" ) ) { languagecontroller = new frenchlanguagecontroller ( ) ; } else if ( languagename . equals ( "spanish" ) ) { languagecontroller = new spanishlanguagecontroller ( ) ; } else if ( languagename . equals ( "german" ) ) { languagecontroller = new germanlanguagecontroller ( ) ; } } return languagecontroller ; }
tr	3	private void populateopponentplayerindexes ( gamestatus gamestatus , int ourplayerindex ) { int numberofplayers = gamestatus . config . getint ( config . key . number_players . getkey ( ) ) ; opponentplayerindexes = new int [ numberofplayers - 1 ] ; int playerindex = 0 ; int i = 0 ; while ( playerindex < numberofplayers ) { if ( playerindex == ourplayerindex ) { playerindex ++ ; continue ; } opponentplayerindexes [ i ++ ] = playerindex ; playerindex ++ ; } }
tr	2	public void triggerchange ( ) { for ( linechangelistener listener : listeners ) { listener . linechanged ( ) ; } }
tr	4	private void allsongsinplaylist ( ) { clear ( ) ; listallplaylists ( ) ; system . out . print ( "indtast playlist id: " ) ; int sc = new scanner ( system . in , "iso-8859-1" ) . nextint ( ) ; try { arraylist < song > songs = pmgr . getsongsinplaylist ( sc ) ; clear ( ) ; printsongheader ( ) ; for ( song s : songs ) { system . out . println ( s ) ; } } catch ( inputmismatchexception e ) { system . out . println ( "error - playlist id must be number" ) ; } catch ( exception e ) { system . out . println ( " error - " + e . getmessage ( ) ) ; } pause ( ) ; }
tr	1	private void rendercurrentlyskippedline ( ) throws ioexception { sb . append ( "                         " ) ; appendpathindent ( sb , currentlyskippedlevel ) ; sb . append ( string . format ( "(%3d paths each < %4.2fms)" , long . valueof ( numcurrentlyskipped ) , double . valueof ( gettotalmillis ( totalnanosthreshold ) ) ) ) ; sb . append ( lineend ) ; }
tr	1	public static void main ( string [ ] args ) { int n = 500000 ; system . out . println ( n + " is:" + convertinttostring ( n ) ) ; }
tr	3	public static string tostring ( calendar time , int format ) { int day = time . get ( calendar . day_of_month ) ; int month = time . get ( calendar . month ) + 1 ; int year = time . get ( calendar . year ) ; switch ( format ) { case day_month_year_format : { return day + "-" + month + "-" + year ; } case year_month_day_format : { return year + "-" + month + "-" + day ; } case dayofweek_day_month_year_format : { string dayofweek = dayofweeks [ time . get ( calendar . day_of_week ) - 1 ] ; return dayofweek + week_day_separaor + day + date_separator + month + date_separator + year ; } } return time . gettime ( ) . tostring ( ) ; }
tr	4	tiletype ( int id , traveltype travel ) { this . id = id ; if ( travel . equals ( traveltype . walkable ) ) walk = true ; else if ( travel . equals ( traveltype . swimmable ) ) swim = true ; else if ( travel . equals ( traveltype . all ) ) { walk = true ; swim = true ; } }
tr	4	public void compile ( ) throws compilererror { ir ir ; system . out . print ( "parsing... " ) ; try { ir = frontend . parse ( this . filename ) ; } catch ( parseerror e ) { throw new compilererror ( "parse error: " + e . getmessage ( ) ) ; } system . out . println ( "done." ) ; if ( this . isdebug ( ) ) { ir . prettyprint ( ) ; } }
tr	1	public void setleafstatisticsmaxitems ( final int leafstatisticsmaxitems ) { this . leafstatisticsmaxitems = leafstatisticsmaxitems ; }
tr	1	@ override public void endpath ( final nestedtimerpath root , final timerstatistics call ) { }
tr	5	private string getclipboardcontents ( ) { clipboard c = toolkit . getdefaulttoolkit ( ) . getsystemclipboard ( ) ; transferable contents = c . getcontents ( null ) ; string result = "" ; if ( contents != null && contents . isdataflavorsupported ( dataflavor . stringflavor ) ) { try { result = ( string ) contents . gettransferdata ( dataflavor . stringflavor ) ; } catch ( unsupportedflavorexception e ) { e . printstacktrace ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } } return result ; }
tr	6	public static double d1mach ( int i ) { switch ( i ) { case 1 : return double . min_value ; case 2 : return double . max_value ; case 3 : return java . lang . math . pow ( ( double ) i1mach ( 10 ) , - ( double ) i1mach ( 14 ) ) ; case 4 : return java . lang . math . pow ( ( double ) i1mach ( 10 ) , 1 - ( double ) i1mach ( 14 ) ) ; case 5 : return math . log ( 2.0 ) / math . log ( 10.0 ) ; default : return 0.0 ; } }
tr	5	@ override public void run ( ) { isrunning = true ; long start = system . currenttimemillis ( ) ; arraylist < file > testdocuments = new arraylist < > ( ) ; string path = applicationsetup . getinstance ( ) . gettopicfilepath ( ) ; system . out . println ( "reading directory: " + path ) ; reader reader = new reader ( path ) ; reader . readfiles ( testdocuments ) ; pipedwriter inputfilewriter = null ; try { system . out . println ( "starting" ) ; inputfilewriter = new pipedwriter ( ) ; init ( inputfilewriter ) ; list < textdocument > documentlist = new arraylist < textdocument > ( ) ; documentprocessor documentprocessor = new documentprocessor ( ) ; string completetext = documentprocessor . process ( testdocuments , documentlist ) ; system . out . println ( "number of test docs: " + testdocuments . size ( ) ) ; } catch ( exception e ) { system . out . println ( e . getmessage ( ) ) ; } finally { try { if ( inputfilewriter != null ) inputfilewriter . close ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } long end = system . currenttimemillis ( ) ; system . out . println ( "done" ) ; system . out . println ( ( end - start ) / 1000 + " seconds" ) ; isrunning = false ; } }
tr	5	public list < district > getlistprovincesortedbyid ( ) { list < district > listtoreturn = new arraylist < district > ( ) ; for ( int i_iddistrict = 0 ; i_iddistrict < getlistdistrict ( ) . size ( ) ; i_iddistrict ++ ) { int i_idprovincebrowsed = getlistdistrict ( ) . get ( i_iddistrict ) . geti_id ( ) ; int i_idnewposition = 0 ; if ( listtoreturn . size ( ) > 0 ) { for ( int i_idlisttoreturn = 0 ; i_idlisttoreturn < listtoreturn . size ( ) ; i_idlisttoreturn ++ ) { if ( i_idprovincebrowsed > listtoreturn . get ( i_idlisttoreturn ) . geti_id ( ) ) { i_idnewposition = i_idlisttoreturn + 1 ; } } } else { i_idnewposition = 0 ; } listtoreturn . add ( i_idnewposition , getlistdistrict ( ) . get ( i_iddistrict ) ) ; } return listtoreturn ; }
tr	6	private void stopstreamprocesses ( ) { system . out . println ( "parando hilo ffmpeg" ) ; try { stopffmpeg ( ) ; stopcrtmpserver ( ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } if ( ffplay != null ) { try { stopffplay ( ) ; } catch ( ioexception | interruptedexception e ) { e . printstacktrace ( ) ; } } }
tr	8	@ override public void render ( int mousex , int mousey ) { gl11 . gldisable ( gl11 . gl_texture_2d ) ; guihelper . renderrectangle ( this . posx + this . width - 22 , this . posy , 24 , this . height , 0x444444ff ) ; guihelper . renderrectangle ( this . width - 20 + this . posx , this . posy + 2 , 20 , this . height - 4 , 0x666666ff ) ; guihelper . renderrectangle ( this . width - 19 + this . posx , this . posy + 2 + ( ( this . height - 4 ) / this . elements . size ( ) ) * this . scroll , 18 , this . scrollbarheight , 0xaaaaaaff ) ; int lengthtorender = this . elements . size ( ) >= this . scroll + this . height / 20 ? this . scroll + this . height / 20 : this . elements . size ( ) ; gl11 . glenable ( gl11 . gl_texture_2d ) ; for ( int i = this . scroll ; i < lengthtorender ; i ++ ) { string s = this . elements . get ( i ) ; if ( s != null ) { int color = 0xbbbbaaff ; if ( i == this . selectedindex ) { color = 0xffffffff ; this . screen . font . renderstringwithshadow ( ">" , this . posx , ( i - this . scroll ) * 20 + this . posy , color ) ; } this . screen . font . renderstringwithshadow ( s , this . posx + 20 , ( i - this . scroll ) * 20 + this . posy , color ) ; } } }
tr	7	public boolean vertexisobstructed ( vertex test ) { if ( src . haspointbetween ( leftangle , rightangle , test ) ) { if ( leftdist <= 0 && rightdist <= 0 ) return true ; if ( src . getdistance ( test ) > distancefromline ( src . getdirection ( test ) ) + 0.01 ) return true ; } return false ; }
tr	10	public void load ( string filedict , string fileother , mode mode ) { if ( filedict != null ) { dict = new dictionary ( ) ; dict . gettext ( filedict ) ; } if ( mode == mode . dmc ) { dmc = new dmm ( ) ; dmc . load ( fileother ) ; } else if ( mode == mode . hmm ) { hmm = new hmmpre ( ) ; hmm . load ( fileother ) ; } else if ( mode == mode . hmmend ) { hmmend = new hmm ( ) ; hmmend . load ( fileother ) ; } else if ( mode == mode . vlmc ) { vlmc = new pst ( ) ; vlmc . load ( fileother ) ; } else { ngrams = new ngram ( this . ngramsize ) ; ngrams . gettext ( fileother ) ; } }
tr	6	private int trmedian3 ( final int isa , final int isad , final int isan , int v1 , int v2 , int v3 ) { final int [ ] sa = this . sa ; int sa_v1 = trgetc ( isa , isad , isan , sa [ v1 ] ) ; int sa_v2 = trgetc ( isa , isad , isan , sa [ v2 ] ) ; int sa_v3 = trgetc ( isa , isad , isan , sa [ v3 ] ) ; if ( sa_v1 > sa_v2 ) { final int temp = v1 ; v1 = v2 ; v2 = temp ; final int sa_vtemp = sa_v1 ; sa_v1 = sa_v2 ; sa_v2 = sa_vtemp ; } if ( sa_v2 > sa_v3 ) { if ( sa_v1 > sa_v3 ) { return v1 ; } return v3 ; } return v2 ; }
tr	1	public void setordertype ( string sordertype ) { mordertype = sordertype ; }
tr	6	@ override public string tostring ( ) { stringbuilder sb = new stringbuilder ( ) ; string [ ] l = new string [ ] { "   " , "###" } ; char [ ] c = new char [ ] { ' ' , '#' } ; for ( int row = 0 ; row < 8 ; row ++ ) { stringbuilder sb1 = new stringbuilder ( ) ; stringbuilder sb2 = new stringbuilder ( ) ; sb1 . append ( "  |" ) ; sb2 . append ( location . charofrow ( row ) ) . append ( " |" ) ; for ( int col = 0 ; col < 8 ; col ++ ) { boolean iswhite = ( ( row + col ) % 2 == 0 ) ; piece p = pieces [ row ] [ col ] ; int index = iswhite ? 0 : 1 ; char centre = ( p == null ) ? c [ index ] : p . c ( ) ; sb1 . append ( l [ index ] ) ; sb2 . append ( c [ index ] ) . append ( centre ) . append ( c [ index ] ) ; } sb1 . append ( "\\n" ) ; sb2 . append ( "\\n" ) ; string s = sb1 . tostring ( ) ; sb . append ( s ) . append ( sb2 . tostring ( ) ) . append ( s ) ; } sb . append ( "--+------------------------\\n" ) ; sb . append ( "    a  b  c  d  e  f  g  h " ) ; return sb . tostring ( ) ; }
tr	2	private void rendercalltimings ( final timerstatistics call ) throws ioexception { if ( call != null ) { sb . append ( string . format ( "[%7d] %12.2fms " , long . valueof ( call . getnumberofcalls ( ) ) , double . valueof ( gettotalmillis ( call . gettotalnanos ( ) ) ) ) ) ; } }
tr	9	@ override public int compare ( object3d o1 , object3d o2 ) { if ( o1 . points_ . size ( ) == 0 || o2 . points_ . size ( ) == 0 ) return 0 ; vector3d p1 = o1 . points_ . get ( 0 ) ; vector3d p2 = o2 . points_ . get ( 0 ) ; if ( p1 . x > p2 . x ) return 1 ; else if ( p1 . x < p2 . x ) return - 1 ; else return 0 ; }
tr	1	public static string compare ( double sum , int k , int n , int w ) { dirichlet uniformdirichlet , dirichlet ; stringbuffer output = new stringbuffer ( ) ; output . append ( sum + "\\t" + k + "\\t" + n + "\\t" + w + "\\t" ) ; uniformdirichlet = new dirichlet ( k , sum / k ) ; dirichlet = new dirichlet ( sum , uniformdirichlet . nextdistribution ( ) ) ; object [ ] observations = dirichlet . drawobservations ( n , w ) ; long time ; dirichlet estimateddirichlet = new dirichlet ( k , sum / k ) ; time = estimateddirichlet . learnparameterswithdigamma ( observations ) ; output . append ( time + "\\t" + dirichlet . absolutedifference ( estimateddirichlet ) + "\\t" ) ; estimateddirichlet = new dirichlet ( k , sum / k ) ; time = estimateddirichlet . learnparameterswithhistogram ( observations ) ; output . append ( time + "\\t" + dirichlet . absolutedifference ( estimateddirichlet ) + "\\t" ) ; estimateddirichlet = new dirichlet ( k , sum / k ) ; time = estimateddirichlet . learnparameterswithmoments ( observations ) ; output . append ( time + "\\t" + dirichlet . absolutedifference ( estimateddirichlet ) + "\\t" ) ; estimateddirichlet = new dirichlet ( k , sum / k ) ; time = estimateddirichlet . learnparameterswithleaveoneout ( observations ) ; output . append ( time + "\\t" + dirichlet . absolutedifference ( estimateddirichlet ) + "\\t" ) ; return output . tostring ( ) ; }
tr	4	private double binpow ( double a , long n ) throws abstractexception { if ( n == 0 ) return 1 ; if ( n % 2 == 1 ) { double c = binpow ( a , n - 1 ) ; return c * a ; } else { double b = binpow ( a , n / 2 ) ; return b * b ; } }
tr	7	public void layoutcontainer ( container parent ) { super . layoutcontainer ( parent ) ; component view = viewport . getview ( ) ; if ( view != null ) { dimension viewportsize = viewport . getsize ( ) ; dimension viewsize = view . getsize ( ) ; if ( ( viewportsize . width > viewsize . width ) || ( viewportsize . height > viewsize . height ) ) { int spacex = ( viewportsize . width - viewsize . width ) / 2 ; int spacey = ( viewportsize . height - viewsize . height ) / 2 ; if ( spacex < 0 ) spacex = 0 ; if ( spacey < 0 ) spacey = 0 ; viewport . setlocation ( spacex , spacey ) ; viewport . setsize ( viewportsize . width - spacex , viewportsize . height - spacey ) ; } } }
tr	2	public boolean equals ( object o ) { try { return element == ( ( renderobject ) o ) . element ; } catch ( classcastexception cce ) { } return false ; }
tr	3	public void settool ( class < ? extends drawingtool > toolclass ) { try { tool = toolclass . newinstance ( ) . createfrommodel ( this ) ; } catch ( instantiationexception e ) { e . printstacktrace ( ) ; system . exit ( 1 ) ; } catch ( illegalaccessexception e ) { e . printstacktrace ( ) ; system . exit ( 1 ) ; } }
tr	10	public static hashmap < string , friend > parsefriends ( string resultstring ) { hashmap < string , friend > friends = new hashmap < string , friend > ( ) ; try { jsonobject base = new jsonobject ( resultstring ) ; if ( base . optint ( "retcode" , - 1 ) == 0 ) { jsonobject resultobject = base . optjsonobject ( "result" ) ; jsonarray friendsarray = resultobject . optjsonarray ( "friends" ) ; for ( int i = 0 ; i < friendsarray . length ( ) ; i ++ ) { jsonobject friendobject = friendsarray . optjsonobject ( i ) ; friend friend = new friend ( ) ; friend . setuin ( friendobject . optstring ( "uin" ) ) ; friend . setfriendflag ( friendobject . optint ( "flag" ) ) ; friend . setcategories ( friendobject . optint ( "categories" ) ) ; friends . put ( friend . getuin ( ) , friend ) ; } jsonarray infoarray = resultobject . optjsonarray ( "info" ) ; for ( int i = 0 ; i < infoarray . length ( ) ; i ++ ) { jsonobject infoobject = infoarray . optjsonobject ( i ) ; friend friend = friends . get ( infoobject . optstring ( "uin" ) ) ; friend . setface ( infoobject . optint ( "face" ) ) ; friend . setinfoflag ( infoobject . optint ( "flag" ) ) ; friend . setnickname ( infoobject . optstring ( "nick" ) ) ; } jsonarray marknamearray = resultobject . optjsonarray ( "marknames" ) ; for ( int i = 0 ; i < marknamearray . length ( ) ; i ++ ) { jsonobject infoobject = marknamearray . optjsonobject ( i ) ; friend friend = friends . get ( infoobject . optstring ( "uin" ) ) ; friend . setmarkname ( infoobject . optstring ( "markname" ) ) ; friend . setmarknametype ( infoobject . optint ( "type" ) ) ; } } } catch ( jsonexception e ) { e . printstacktrace ( ) ; } return friends ; }
tr	9	public uifield ( final uigame uigame ) { setbackground ( color . black ) ; setdoublebuffered ( true ) ; setignorerepaint ( true ) ; addmouselistener ( new mouseadapter ( ) { @ override public void mousereleased ( mouseevent e ) { double x = ( ( e . getx ( ) - xroot ) / ( cell_size * 2 ) ) ; if ( x < 0 || x >= getfield ( ) . getwidth ( ) ) { e . consume ( ) ; return ; } double y = ( ( e . gety ( ) - yroot ) / ( cell_size * 2 ) ) ; if ( y < 0 || y >= getfield ( ) . getheight ( ) ) { e . consume ( ) ; return ; } uigame . selectmove ( ( int ) x , ( int ) y ) ; e . consume ( ) ; } } ) ; final retrofont retrofont = new retrofont ( ) ; winimgs = new hashmap < > ( ) ; winimgs . put ( player . first , createwinimage ( retrofont , player . first ) ) ; winimgs . put ( player . second , createwinimage ( retrofont , player . second ) ) ; }
tr	9	public void taketurn ( ) { if ( ! world . jubjublair . jubjub . isalive ( ) ) { if ( firstappearance ) { system . out . println ( "an old man in a bath robe steps out from behind a bush." ) ; firstappearance = false ; } if ( this . damaged == true ) { system . out . println ( "the wizard smirks and vanishes." ) ; } else { if ( world . ears . areplugged ( ) ) { system . out . println ( "old man: \\"mumnub numb mbn mbmn bmbmbn bmm bm bn.\\"" ) ; } else if ( ! hasspoken ) { system . out . println ( "old man: \\"oh thank you kind sir. you have saved my life.\\"" ) ; system . out . println ( "old man: \\"that wretched bird has had me trapped down here for days.\\"" ) ; system . out . println ( "old man: \\"i am the most powerful wizard in this land.\\"" ) ; system . out . println ( "wizard: \\"for your bravery<litcomma> i will enchant a single item of your choosing.\\"" ) ; hasspoken = true ; } else { system . out . println ( "\\"the wizard asks: what do you want me to enchant?\\"" ) ; } } } return ; }
tr	3	public void drawui ( ) { float black = 0 ; float opacity = 1 ; if ( coreclass . maincharacter . getxpos ( ) <= coreclass . healthbar . getxpos ( ) + coreclass . healthbar . getfullwidth ( ) + 5 && coreclass . maincharacter . getypos ( ) <= coreclass . healthbar . getypos ( ) + coreclass . healthbar . getheight ( ) + 5 ) { opacity = ( float ) .35 ; } coreclass . healthbar . setopacity ( opacity ) ; g . setcolor ( new color ( black , black , black , opacity ) ) ; g . fillrect ( coreclass . healthbar . getxpos ( ) - 5 , coreclass . healthbar . getypos ( ) - 5 , coreclass . healthbar . getfullwidth ( ) + 10 , coreclass . healthbar . getheight ( ) + 10 ) ; g . setcolor ( coreclass . healthbar . gethealthcolor ( ) ) ; g . fillrect ( coreclass . healthbar . getxpos ( ) , coreclass . healthbar . getypos ( ) , coreclass . healthbar . getwidth ( ) , coreclass . healthbar . getheight ( ) ) ; }
tr	2	public boolean deactivate ( ) { active_ = false ; for ( virtualnode child : children_ . values ( ) ) { child . deactivate ( ) ; } return node_ . removehandler ( virtual_handler_ . getname ( ) ) ; }
tr	5	public void drawobjects ( ) { list < drawableobjects > everything = coreclass . getsortedobjectlist ( ) ; int cameraoffx = - ( coreclass . mapupperleftoffset . getx ( ) ) ; int cameraoffy = - ( coreclass . mapupperleftoffset . gety ( ) ) ; coordinate tempul = coreclass . onscreentile [ 0 ] ; for ( drawableobjects d : everything ) { if ( d instanceof player ) { switch ( ( ( player ) d ) . getimageeffect ( ) ) { case "emboss" : g . drawimage ( imageprocessing . emboss ( coreclass . maincharacter . getpic ( ) ) , coreclass . maincharacter . getxpos ( ) , coreclass . maincharacter . getypos ( ) , null ) ; break ; default : g . drawimage ( coreclass . maincharacter . getpic ( ) , coreclass . maincharacter . getxpos ( ) , coreclass . maincharacter . getypos ( ) , null ) ; break ; } } else { switch ( d . getimageeffect ( ) ) { case "emboss" : g . drawimage ( imageprocessing . emboss ( d . getpic ( ) ) , d . getxpos ( ) + cameraoffx - ( tempul . getx ( ) * 102 ) , d . getypos ( ) + cameraoffy - ( tempul . gety ( ) * 102 ) , null ) ; break ; default : g . drawimage ( d . getpic ( ) , d . getxpos ( ) + cameraoffx - ( tempul . getx ( ) * 102 ) , d . getypos ( ) + cameraoffy - ( tempul . gety ( ) * 102 ) , null ) ; break ; } } } }
tr	6	void chargermapvierge ( int taille ) { this . carte = new case [ taille ] [ taille ] ; for ( int i = 0 ; i < taille ; i ++ ) { for ( int j = 0 ; j < taille ; j ++ ) { this . carte [ i ] [ j ] = new case ( 7 ) ; } } if ( this . carte != null ) { system . out . println ( "une carte vierge a ete chargee." ) ; } }
tr	9	@ override protected void recievebuttonevent ( int buttonid ) { switch ( buttonid ) { default : break ; case 1 : boot . getguihandler ( ) . addwindow ( ( new debuggui ( - 1 ) ) ) ; break ; case 2 : requestpoints ( 2 ) ; picks = 0 ; break ; case 4 : makeprefab ( ) ; break ; case 3 : requestpoints ( 1 ) ; picks = 5 ; break ; case 5 : requestpoints ( 1 ) ; picks = 4 ; break ; case 6 : requestpoints ( 1 ) ; picks = 3 ; break ; case 7 : roadgen . layroad ( x1 , y1 , x2 , y2 ) ; break ; case 8 : blockgen . makenewblock ( x1 , y1 , 3 ) ; break ; } }
tr	8	public static string digitstostring ( int n ) { if ( n <= 20 ) { string [ ] digits = { "one" , "two" , "three" , "four" , "five" , "six" , "seven" , "eight" , "nine" , "ten" , "eleven" , "twelve" , "thirteen" , "fourteen" , "fifteen" , "sixteen" , "seventeen" , "eighteen" , "nineteen" , "twenty" } ; return digits [ n - 1 ] ; } else { switch ( n ) { case 30 : return "thirty" ; case 40 : return "forty" ; case 50 : return "fifty" ; case 60 : return "sixty" ; case 70 : return "seventy" ; case 80 : return "eighty" ; case 90 : return "ninety" ; } } return null ; }
tr	7	public string exportinputs ( engine engine ) { stringbuilder result = new stringbuilder ( ) ; for ( int i = 0 ; i < engine . numberofinputvariables ( ) ; ++ i ) { inputvariable inputvariable = engine . getinputvariable ( i ) ; result . append ( string . format ( "[input%d]\\n" , ( i + 1 ) ) ) ; if ( ! inputvariable . isenabled ( ) ) { result . append ( string . format ( "enabled=%d\\n" , inputvariable . isenabled ( ) ? 1 : 0 ) ) ; } result . append ( string . format ( "name='%s'\\n" , inputvariable . getname ( ) ) ) ; result . append ( string . format ( "range=[%s %s]\\n" , str ( inputvariable . getminimum ( ) ) , str ( inputvariable . getmaximum ( ) ) ) ) ; result . append ( string . format ( "nummfs=%d\\n" , inputvariable . numberofterms ( ) ) ) ; for ( int t = 0 ; t < inputvariable . numberofterms ( ) ; ++ t ) { term term = inputvariable . getterm ( t ) ; result . append ( string . format ( "mf%d=%s\\n" , ( t + 1 ) , tostring ( term ) ) ) ; } result . append ( "\\n" ) ; } return result . tostring ( ) ; }
tr	1	public string getstatus ( ) { return mstatus ; }
tr	5	@ override public int checkfordamage ( rectangle2d . double rect ) { synchronized ( this . lasers ) { int damage = 0 ; if ( globals . gametime . getelapsedmillis ( ) >= ( this . lastdamagedone + laserwire . laser_cooldown ) ) { if ( ! this . lasers . isempty ( ) ) { iterator < line2d . double > it = this . lasers . iterator ( ) ; while ( it . hasnext ( ) ) { line2d . double laser = it . next ( ) ; if ( rect . intersectsline ( laser ) ) { damage += laserwire . damage_by_laser ; this . lastdamagedone = globals . gametime . getelapsedmillis ( ) ; } } } } return damage ; } }
tr	5	public void bfs ( int adjacency_matrix [ ] [ ] , int source ) { int number_of_nodes = adjacency_matrix [ source ] . length - 1 ; int [ ] visited = new int [ number_of_nodes + 1 ] ; int i , element ; visited [ source ] = 1 ; queue . add ( source ) ; while ( ! queue . isempty ( ) ) { element = queue . remove ( ) ; i = element ; system . out . print ( i + "\\t" ) ; while ( i <= number_of_nodes ) { if ( adjacency_matrix [ element ] [ i ] == 1 && visited [ i ] == 0 ) { queue . add ( i ) ; visited [ i ] = 1 ; } i ++ ; } } }
tr	2	private obs processobs ( startelement se , xmleventreader eventreader ) { obs o = new obs ( ) ; iterator < attribute > attributes = se . getattributes ( ) ; while ( attributes . hasnext ( ) ) { attribute attr = attributes . next ( ) ; o . addattribute ( attr . getname ( ) . getlocalpart ( ) , attr . getvalue ( ) ) ; } return o ; }
tr	7	@ subscribe public void onneedscompile ( needscompileevent event ) { final set < lessfile > done = sets . newhashset ( ) ; final set < lessfile > failed = sets . newhashset ( ) ; for ( final lessfile file : event . getcompileset ( ) ) { final string filename = file . getfilename ( ) ; compile ( filename , new compilecallback ( ) { @ override public void error ( string error , throwable e ) { eventbus . post ( new lesslogevent ( filename , type . error , error ) ) ; } @ override public void done ( string css ) { path outputpath = getoutputpath ( filename ) ; if ( logger . istraceenabled ( ) ) logger . trace ( "compile output for '{}':\\n{}" , filename , css ) ; try { files . createdirectories ( outputpath . getparent ( ) ) ; files . write ( outputpath , css . getbytes ( ) ) ; if ( logger . isdebugenabled ( ) ) logger . debug ( "saved compile result to '{}'" , outputpath ) ; eventbus . post ( new lesslogevent ( filename , type . ok , format ( "compiled to {0}" , outputpath ) ) ) ; done . add ( file ) ; } catch ( ioexception e ) { string text = format ( "error compiling {0}" , filename ) ; eventbus . post ( new lesslogevent ( text , type . error , e . getmessage ( ) ) ) ; failed . add ( file ) ; } } } ) ; } eventbus . post ( new compilefinishedevent ( done , failed ) ) ; }
tr	2	boolean isbackface ( vector3d eye ) { if ( normal == null ) return false ; setnormal ( ) ; vector3d p = object3d . points . elementat ( points [ 0 ] ) ; vector3d ray = p . minus ( eye ) ; return normal . . ( ray ) >= 0 ; }
tr	1	@ override public boolean canfire ( ) { boolean lessthantwoterminals = this . particles . size ( ) < 2 ; return super . canfire ( ) && lessthantwoterminals ; }
tr	9	public coordinate move ( direction dir , coordinate coor ) { switch ( dir ) { case north : { coordinate newcoord = new coordinate ( coor . getrow ( ) - 1 , coor . getcol ( ) ) ; if ( validcoordinate ( newcoord ) ) { return newcoord ; } } case south : { coordinate newcoord = new coordinate ( coor . getrow ( ) + 1 , coor . getcol ( ) ) ; if ( validcoordinate ( newcoord ) ) { return newcoord ; } } case east : { coordinate newcoord = new coordinate ( coor . getrow ( ) , coor . getcol ( ) + 1 ) ; if ( validcoordinate ( newcoord ) ) { return newcoord ; } } case west : { coordinate newcoord = new coordinate ( coor . getrow ( ) , coor . getcol ( ) - 1 ) ; if ( validcoordinate ( newcoord ) ) { return newcoord ; } } case stop : { return coor ; } } return null ; }
tr	3	private static map < string , collection < timerstatistics > > addstatistics ( final collection < node > nodes , final map < string , collection < timerstatistics > > m ) { for ( final node n : nodes ) { final string key = n . getpath ( ) . getleaftimername ( ) ; collection < timerstatistics > c = m . get ( key ) ; if ( c == null ) { c = new arraylist < timerstatistics > ( ) ; m . put ( key , c ) ; } c . add ( n . gettimerstatistics ( ) ) ; addstatistics ( n . getchildren ( ) , m ) ; } return m ; }
tr	1	public firststate ( ) { statename = "1st" ; }
tr	9	public static void main ( string argstring [ ] ) throws ioexception { getargs args = new getargs ( argstring ) ; string arg ; scriptdriver sd = new scriptdriver ( ) ; while ( ( arg = args . nextarg ( ) ) != null ) { log . trace ( "arg: {}" , arg ) ; switch ( arg ) { case "--mode" : sd . setmode ( args . nextarg ( ) ) ; sd . fixedmode = true ; break ; default : log . fatal ( "unknown argument '{}'" , arg ) ; } } for ( string file : args . getfiles ( ) ) { if ( file . equals ( "-" ) ) { sd . execstream ( new inputstreamreader ( system . in ) ) ; } else { sd . execstream ( new filereader ( file ) ) ; } } log . info ( "total time: {}" , sd . timer ) ; }
tr	9	public static list < quiz > getmostpopularquizzes ( int numtoreturn ) { list < quiz > result = new arraylist < quiz > ( ) ; list < quiz > allquizzes = quizutils . getallquizzes ( ) ; treemap < integer , list < quiz > > map = new treemap < integer , list < quiz > > ( ) ; for ( quiz quiz : allquizzes ) { int numtimestaken = getnumbertimesquiztaken ( quiz . getid ( ) ) ; if ( ! map . containskey ( numtimestaken ) ) { map . put ( numtimestaken , new arraylist < quiz > ( ) ) ; } map . get ( numtimestaken ) . add ( quiz ) ; } for ( int i = 0 ; i < numtoreturn && ! map . isempty ( ) ; ) { entry < integer , list < quiz > > entry = map . polllastentry ( ) ; for ( quiz quiz : entry . getvalue ( ) ) { result . add ( quiz ) ; i ++ ; } map . remove ( entry . getkey ( ) ) ; } return result ; }
tr	5	public void equipweapon ( survivor survivor , weapon weapon ) throws cantequipweaponexception { if ( ! this . survivors . contains ( survivor ) ) { throw new cantequipweaponexception ( cantequipweaponexception . notintheteam ( survivor ) ) ; } else if ( ! this . mainbase . getavailableweapons ( ) . contains ( weapon ) ) { throw new cantequipweaponexception ( "weapon must be one of those stored in base to equip" ) ; } else { survivor owner = this . alreadyequipped ( weapon ) ; if ( owner != null ) { throw new cantequipweaponexception ( "weapon is already equipped by " + owner . getname ( ) ) ; } else { weapon oldweapon = survivor . getweapon ( ) ; this . mainbase . getavailableweapons ( ) . remove ( weapon ) ; survivor . setweapon ( weapon ) ; if ( oldweapon != null ) { this . mainbase . getavailableweapons ( ) . add ( oldweapon ) ; } } } }
tr	4	public static double fitnesstesto ( pokemonteam samplemember ) { samplemember . modifypairings ( ) ; double offense = 0.0 ; int samplese = samplemember . getmovesupereffectives ( ) ; int sampler = samplemember . getmoveresistances ( ) ; int samplei = samplemember . getmoveimmunities ( ) ; double immuneo = 0.0 ; if ( samplei == 0 ) { immuneo = ( double ) ( 2 + samplei ) / ( samplei + 1 ) ; } if ( samplei > 0 ) { immuneo = ( double ) ( 2 + samplei ) / samplei ; } offense = ( double ) ( samplese - sampler ) ; samplemember . reset ( ) ; return offense - immuneo ; }
tr	2	public void setfieldvalue ( _fields field , object value ) { switch ( field ) { case get_lang : if ( value == null ) { unsetgetlang ( ) ; } else { setgetlang ( ( string ) value ) ; } break ; } }
tr	3	public double perimeter ( ) { double perimeter = 0 ; if ( np > 1 ) { point p0 = p [ 0 ] , p1 ; point c0 = c [ 2 ] , c1 ; p [ np ] = p0 ; final double maxerror = perimeter_error / np ; for ( int i = 1 ; i <= np ; ++ i ) { p1 = p [ i ] ; c1 = c [ i + 2 ] ; perimeter += length ( p0 . x , p0 . y , ( 2 * c0 . x + c1 . x ) / 3 , ( 2 * c0 . y + c1 . y ) / 3 , ( c0 . x + 2 * c1 . x ) / 3 , ( c0 . y + 2 * c1 . y ) / 3 , p1 . x , p1 . y , maxerror ) ; p0 = p1 ; c0 = c1 ; } } return perimeter ; }
tr	2	public static void testneuron ( ) { try { myneurontest t = new myneurontest ( ) ; t . setupneuron ( ) ; t . feedneuron ( ) ; } catch ( exception ex ) { logger . getlogger ( mystartclass . class . getname ( ) ) . log ( level . severe , null , ex ) ; } }
tr	4	public panetab gettab ( inetaddress ip ) { panetab returntab = null ; for ( component tab : this . tabs . getcomponents ( ) ) { if ( tab . getclass ( ) . equals ( gui . panetab . class ) ) { panetab temptab = ( panetab ) tab ; if ( ip . equals ( temptab . getaddress ( ) ) ) { returntab = temptab ; } } } return returntab ; }
tr	6	private void initmapscene ( object [ ] arguments ) { if ( arguments . length <= 0 || ! ( arguments [ 0 ] instanceof mapfx ) ) { return ; } map = ( mapfx ) arguments [ 0 ] ; log = map . getlog ( ) ; if ( log == null ) { log = new logger ( ) ; } }
tr	3	public generalpath contour ( ) { final generalpath path = new generalpath ( ) ; if ( np > 0 ) { point pi = p [ 0 ] ; p [ np ] = pi ; point ci1 = c [ 2 ] , ci2 ; path . moveto ( ( float ) pi . x , ( float ) pi . y ) ; for ( int i = 1 ; i <= np ; ++ i ) { pi = p [ i ] ; ci2 = c [ i + 2 ] ; path . curveto ( ( float ) ( 2 * ci1 . x + ci2 . x ) / 3 , ( float ) ( 2 * ci1 . y + ci2 . y ) / 3 , ( float ) ( ci1 . x + 2 * ci2 . x ) / 3 , ( float ) ( ci1 . y + 2 * ci2 . y ) / 3 , ( float ) pi . x , ( float ) pi . y ) ; ci1 = ci2 ; } path . closepath ( ) ; } return path ; }
tr	10	public static void main ( string args [ ] ) { int i1 = integer . parseint ( args [ 0 ] ) ; if ( i1 >= 0 ) { for ( int i = 1 ; i <= i1 ; i = i + 1 ) { int resultmod = i1 % i ; if ( i != 1 && i != i1 && resultmod == 0 ) { system . out . print ( i + " " ) ; } } } else { for ( int i = - 1 ; i >= i1 ; i = i - 1 ) { int resultmod = i1 % i ; if ( i != - 1 && i != i1 && resultmod == 0 ) { system . out . print ( i + "\\t" ) ; } } } system . out . println ( "" ) ; }
tr	3	private static string smallpattern ( hackresult hackresult ) { int sumresocount = 0 ; int sumxmpcount = 0 ; for ( hackitem hackitem : hackresult . hack . items ) { switch ( hackitem . object ) { case reso : sumresocount += hackitem . quantity ; break ; case xmp : sumxmpcount += hackitem . quantity ; break ; } } return string . format ( "%d/%d" , sumresocount , sumxmpcount ) ; }
tr	2	public void addwindow ( guiwindow window ) { if ( window . getid ( ) == - 1 ) { window . setid ( getuniquewindowid ( ) ) ; } int dx = mouse . getx ( ) ; int dy = mouse . gety ( ) - standards . w_height ; window . move ( dx , dy ) ; windowslist . add ( window ) ; }
tr	9	public void append ( t record ) { try { if ( currentlog . out . size ( ) > 128 * 1024 * 1024 ) { currentlog . out . close ( ) ; currentlog = new currentlog ( logdir , ++ currentlog . lognameindex , 0 , userrecordcount ) ; } atomicinteger count = userrecordcount . get ( record . getimsi ( ) ) ; if ( count == null ) { count = new atomicinteger ( - 1 ) ; userrecordcount . put ( record . getimsi ( ) , count ) ; } record . setsync ( ( count . incrementandget ( ) & 127 ) == 0 ) ; int size = currentlog . out . size ( ) ; record . writeto ( currentlog . out ) ; currentlog . out . writeint ( size ) ; if ( size - currentlog . syncpositon > 8 * 1024 * 1024 ) { currentlog . syncpositon = size ; } currentlog . out . writeint ( currentlog . syncpositon ) ; } catch ( ioexception e ) { throw new runtimeexception ( e ) ; } }
tr	10	public list < multiplicitiesvector > findmulvectorssummingupto ( int level ) { if ( vecsoflevelendat . containskey ( level ) ) { return storedvectors . sublist ( 0 , vecsoflevelendat . get ( level ) ) ; } else if ( level < 0 ) { throw new unsupportedoperationexception ( "cannot evaluate negative level " + level ) ; } else { for ( int l = lastlevel + 1 ; l <= level ; l ++ ) { if ( l == 0 ) { multiplicitiesvector zerovector = new multiplicitiesvector ( 0 , qnm . m ) ; storedvectors . add ( zerovector ) ; vecsoflevelendat . put ( 0 , 1 ) ; } else { list < multiplicitiesvector > toprocess ; if ( l >= 2 ) { toprocess = new arraylist < multiplicitiesvector > ( storedvectors . sublist ( vecsoflevelendat . get ( l - 2 ) , vecsoflevelendat . get ( l - 1 ) ) ) ; } else { toprocess = new arraylist < multiplicitiesvector > ( storedvectors . sublist ( 0 , 1 ) ) ; } treeset < multiplicitiesvector > toadd = new treeset < multiplicitiesvector > ( ) ; for ( multiplicitiesvector m : toprocess ) { for ( int k = 0 ; k < m . size ( ) ; k ++ ) { m . plusone ( k + 1 ) ; toadd . add ( m . copy ( ) ) ; m . restore ( ) ; } } storedvectors . addall ( toadd ) ; vecsoflevelendat . put ( l , storedvectors . size ( ) ) ; } } lastlevel = level ; list < multiplicitiesvector > toret = storedvectors . sublist ( 0 , vecsoflevelendat . get ( level ) ) ; return toret ; } }
tr	2	private connection createconnection ( ) { try { string url = "jdbc:mysql://localhost:3306/quizdb2" ; string user = "root" ; string password = "root" ; con = drivermanager . getconnection ( url , user , password ) ; } catch ( sqlexception e ) { system . out . println ( e . getmessage ( ) ) ; } return con ; }
tr	2	public static void main ( string [ ] args ) throws exception { int longmode = short ; phase1 p1 = new phase1 ( longmode ) ; for ( string arg : args ) p1 . add ( arg ) ; p1 . dumpcsv ( "out_o.csv" , "; " , friend_filter ) ; p1 . dumpcsv ( "out_e.csv" , "; " , foe_filter ) ; combinedsummarizer o ; o = new combinedsummarizer ( ) ; o . addsummarizer ( new xsltsummarizer ( ) ) ; o . addsummarizer ( new xsltsummarizer ( "layout1.xsl" , "out.html" ) ) ; list < fullresult > res = p1 . runfilterstack ( 0 , longmode , o ) ; o . close ( ) ; o = new combinedsummarizer ( ) ; o . addsummarizer ( new xsltsummarizer ( "layout1.xsl" , "out_bonus.html" ) ) ; list < fullresult > resbonus = p1 . runfilterstack ( 1 , short , o ) ; o . close ( ) ; }
tr	1	public static void main ( string [ ] args ) { testsymmetricconcentration ( 1000 , 100 , 1000 ) ; }
tr	8	public void clearjuego ( ) { for ( int i = 0 ; i < ejercito . size ( ) ; i ++ ) { ejercito . get ( i ) . detener = true ; } for ( int i = 0 ; i < edificios . size ( ) ; i ++ ) { edificios . get ( i ) . detener = true ; } for ( int i = 0 ; i < tropas . size ( ) ; i ++ ) tropas . set ( i , 0 ) ; this . revisargane = false ; edificios . clear ( ) ; ejercito . clear ( ) ; }
tr	4	public static final boolean isvalid ( final pattern regexpattern , final string value ) { if ( regexpattern != null && value != null && ! value . isempty ( ) ) return regexpattern . matcher ( value ) . matches ( ) ; return false ; }
tr	2	private void preparebackgroundtiles ( ) { random random = new random ( ) ; image [ ] tiles = new image [ ] { tile1 , tile2 , tile3 } ; for ( int i = 0 ; i < horizontalfields * verticalfields ; i ++ ) { randomtiles . add ( tiles [ random . nextint ( 3 ) ] ) ; } }
tr	8	@ override public numberdouble exp ( numberdouble b ) throws abstractexception { if ( b . val < 1e-7 && b . val > - 1e-7 && b . val <= 0 ) throw new divisionbyzeroexception ( "division by zero" ) ; if ( ( long ) b . val < 1e-7 ) throw new invalidexpexception ( "exp negative number" ) ; return new numberdouble ( binpow ( val , ( long ) b . val ) ) ; }
tr	9	public string getgtfspath ( ) { if ( gtfspath == null ) { synchronized ( this ) { gtfspath = properties . getproperty ( "gtfs-path" ) ; if ( gtfspath == null ) throw new illegalargumentexception ( "please set a valid gtfs-path." ) ; if ( ! gtfspath . endswith ( file . separator ) ) gtfspath = gtfspath + file . separator ; if ( ! new file ( gtfspath ) . isdirectory ( ) ) throw new illegalargumentexception ( "please set a valid gtfs-path." ) ; } } return gtfspath ; }
tr	3	public boolean equals ( rulestats rule ) { return ( configdescriptor . equals ( rule . configdescriptor ) && name . equals ( rule . name ) && description . equals ( rule . description ) && weighting == rule . weighting ) ; }
tr	2	@ override public void valuechanged ( listselectionevent e ) { if ( ! ( view . list . isselectionempty ( ) ) ) { model . loadimage ( view . list . getselectedindex ( ) ) ; } }
tr	1	public void setbrushwidth ( int brushwidth ) { this . brushwidth = brushwidth ; settool ( this . tool . getclass ( ) ) ; }
tr	10	private map < string , string > loadpropertiesfromstream ( inputstream in ) throws optionsexception { bufferedreader reader = new bufferedreader ( new inputstreamreader ( in , charset . forname ( "utf8" ) ) ) ; final map < string , string > properties = new hashmap < string , string > ( ) ; try { string s ; while ( ( s = reader . readline ( ) ) != null ) { s = s . trim ( ) ; if ( s . isempty ( ) || s . startswith ( "#" ) ) continue ; final int p = s . indexof ( '=' ) ; if ( p < 0 ) continue ; final string key = s . substring ( 0 , p ) . trim ( ) ; final string value = s . substring ( p + 1 , s . length ( ) ) . trim ( ) ; properties . put ( key , value ) ; } } catch ( ioexception e ) { throw new optionsexception ( "error reading options file: " + optionsfile . getabsolutepath ( ) , e ) ; } finally { try { reader . close ( ) ; } catch ( ioexception e ) { throw new optionsexception ( "error closing options file reader: " + optionsfile . getabsolutepath ( ) , e ) ; } } return properties ; }
tr	6	@ override public void getfromweb ( url getfilefrom , callback < string > callback ) { inputstream inputstream = null ; stringbuilder stringbuilder = new stringbuilder ( ) ; try { inputstream = getfilefrom . openstream ( ) ; inputstreamreader bufferedinputstream = new inputstreamreader ( inputstream ) ; bufferedreader bufferedreader = new bufferedreader ( bufferedinputstream ) ; system . out . println ( "open connection to: " + getfilefrom ) ; string line = bufferedreader . readline ( ) ; while ( line != null ) { stringbuilder . append ( line ) ; line = bufferedreader . readline ( ) ; } system . out . println ( "finished reading the html file to string" ) ; system . out . println ( "string read is: " + stringbuilder . tostring ( ) ) ; } catch ( ioexception e ) { callback . done ( null , e ) ; } finally { if ( inputstream != null ) { try { inputstream . close ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } } } callback . done ( stringbuilder . tostring ( ) , null ) ; }
tr	10	private void jsontoscore ( string jsonstring ) { jsonstring = jsonstring . substring ( jsonstring . indexof ( '[' ) + 2 , jsonstring . indexof ( ']' ) - 1 ) ; string [ ] jsonstringarray = jsonstring . split ( "(\\\\}<litcomma>\\\\{)" ) ; for ( int i = 0 ; i < jsonstringarray . length ; i ++ ) { string s = jsonstringarray [ i ] ; stringbuilder name = new stringbuilder ( ) ; stringbuilder score = new stringbuilder ( ) ; stringbuilder id = new stringbuilder ( ) ; int countquotes = 0 ; boolean isskipfirstchar = false ; for ( int j = 0 ; j < s . length ( ) ; j ++ ) { char currentchar = s . charat ( j ) ; if ( currentchar == '\\"' ) { countquotes ++ ; continue ; } switch ( countquotes ) { case 3 : name . append ( currentchar ) ; break ; case 6 : if ( ! isskipfirstchar ) { isskipfirstchar = true ; } else { score . append ( currentchar ) ; } break ; case 17 : id . append ( currentchar ) ; break ; } } score = new stringbuilder ( score . substring ( 0 , score . length ( ) - 1 ) ) ; score sc = new score ( id . tostring ( ) , name . tostring ( ) , long . parselong ( score . tostring ( ) ) ) ; bestscores . add ( sc ) ; } }
tr	9	public bloque getbloque ( final int r , final int c ) { if ( r < 0 || r >= this . figura . length ) throw new arrayindexoutofboundsexception ( ) ; if ( c < 0 || c >= this . figura [ 0 ] . length ) throw new arrayindexoutofboundsexception ( ) ; return this . figura [ r ] [ c ] ; }
tr	4	public void record ( final double ... values ) { final int idx = ( this . drawoffset + this . drawlength ) % this . length ; final int min = math . min ( this . curves , values . length ) ; for ( int i = 0 ; i < min ; i ++ ) { this . data [ i ] [ idx ] = values [ i ] ; } if ( this . drawlength < this . length ) { this . drawlength ++ ; } else { this . drawoffset ++ ; } }
tr	6	public void render ( vpoint camera , vgraphics g ) { if ( l < 0 ) return ; l -= 5 ; if ( unit != null ) { int i = name . indexof ( unit ) ; if ( i == - 1 ) { vm = voxelmodel . load ( unit + "_trace" ) ; voxe . add ( vm ) ; } else { vm = voxe . get ( i ) ; } unit = null ; } g . setcolor ( new color ( 0 , 0 , 0 , l / 2 ) ) ; voxelmodel . render ( vm , g , new vpoint ( vp . x - camera . x , vp . y - camera . y , vp . z - camera . z ) , vc ) ; }
tr	3	private sftpattrs stat ( string absfilename ) throws sftpexception { absfilename = tosshpath ( absfilename ) ; try { return channel . lstat ( absfilename ) ; } catch ( sftpexception e ) { if ( e . id == channelsftp . ssh_fx_no_such_file ) return null ; throw e ; } }
tr	5	@ override protected void paintcomponent ( graphics g ) { graphics2d g2 = ( graphics2d ) g ; g2 . setrenderinghint ( renderinghints . key_antialiasing , renderinghints . value_antialias_on ) ; super . paintcomponent ( g ) ; g2 . setcolor ( color . gray ) ; g2 . setstroke ( this . dotted ) ; g2 . drawline ( 0 , ( int ) ( 0.75 * this . getheight ( ) ) , this . getwidth ( ) - 1 , ( int ) ( 0.75 * this . getheight ( ) ) ) ; g2 . drawline ( 0 , ( int ) ( 0.5 * this . getheight ( ) ) , this . getwidth ( ) - 1 , ( int ) ( 0.5 * this . getheight ( ) ) ) ; g2 . drawline ( 0 , ( int ) ( 0.25 * this . getheight ( ) ) , this . getwidth ( ) - 1 , ( int ) ( 0.25 * this . getheight ( ) ) ) ; g2 . setstroke ( this . stroke ) ; for ( int l = 0 ; l < this . curves ; l ++ ) { final double [ ] line = data [ l ] ; if ( this . color [ l ] == null ) { g2 . setcolor ( color . black ) ; } else { g2 . setcolor ( this . color [ l ] ) ; } int hi = this . getheight ( ) - 1 ; int xx1 = this . xvalue ( 0 ) ; int yy1 = hi - this . yvalue ( line [ this . drawoffset % this . length ] ) ; for ( int i = 1 ; i < this . drawlength ; i ++ ) { final int xx2 = xvalue ( i ) ; final int yy2 = hi - yvalue ( line [ ( this . drawoffset + i ) % this . length ] ) ; g2 . drawline ( xx1 , yy1 , xx2 , yy2 ) ; xx1 = xx2 ; yy1 = yy2 ; } } }
tr	2	public void drawgrabbed ( ) { if ( grabbed != null ) { texinfo tempinfo = grabbed . getbase ( ) . gettexinfo ( ) ; tempinfo . settexturename ( "items" ) ; guiicon drawicon = new guiicon ( 0 , 0 , tempinfo ) ; drawicon . draw ( mouse . getx ( ) - 16 , standards . w_height - mouse . gety ( ) - 16 ) ; } }
tr	2	private void checkforquitkey ( keyevent e ) { int key = e . getkeycode ( ) ; if ( key == keyevent . vk_q ) { system . exit ( 0 ) ; } }
tr	10	public object getvalueat ( int rowindex , int columnindex ) { switch ( columnindex ) { case 0 : return listmembre . get ( rowindex ) . getid ( ) ; case 1 : return listmembre . get ( rowindex ) . getnom ( ) ; case 2 : return listmembre . get ( rowindex ) . getprenom ( ) ; case 3 : return listmembre . get ( rowindex ) . getadresse ( ) ; case 4 : return listmembre . get ( rowindex ) . getdate_naissance ( ) ; case 5 : return listmembre . get ( rowindex ) . getdate_inscription ( ) ; case 6 : return listmembre . get ( rowindex ) . getnum_telephone ( ) ; case 7 : return listmembre . get ( rowindex ) . getmail ( ) ; case 8 : return listmembre . get ( rowindex ) . getevaluation ( ) ; default : return null ; } }
tr	5	private void registerbuttonactionperformed ( java . awt . event . actionevent evt ) { string patientid = patientidfield . gettext ( ) ; string department = ( string ) departmentbox . getselecteditem ( ) ; system . out . println ( department ) ; if ( department != null && patientid != null ) { searchpatient sp = new searchpatient ( patientid , department ) ; try { out . writeobject ( sp ) ; out . flush ( ) ; boolean hasid = in . readboolean ( ) ; if ( hasid ) { completewindow . setvisible ( true ) ; } else { regpatientid . settext ( patientid ) ; regwindow . setvisible ( true ) ; } } catch ( ioexception ex ) { logger . getlogger ( registerjframe . class . getname ( ) ) . log ( level . severe , null , ex ) ; } } else { errorinfo . setvisible ( true ) ; } }
tr	6	public void mousemoved ( mouseevent e ) { int x = integer . max_value ; int y = integer . max_value ; xcursor = e . getx ( ) ; ycursor = e . gety ( ) ; int i = - 1 ; boolean result = false ; while ( ! result && i < points . length - 1 ) { i ++ ; x = ( int ) ( getwidth ( ) / 2 + ( xcam + points [ i ] [ 0 ] ) * zoom ) ; y = ( int ) ( getheight ( ) / 2 + ( ycam + points [ i ] [ 1 ] ) * zoom ) ; result = ( math . pow ( xcursor - x , 2 ) + math . pow ( ycursor - y , 2 ) ) <= math . pow ( symbolsize , 2 ) ; } if ( result ) { labelinfo . settext ( "( " + points [ i ] [ 0 ] + " ; " + points [ i ] [ 1 ] + " )  classe: " + vectclasses . elementat ( classes [ i ] ) . nom + " (" + ( int ) ( m [ i ] [ classes [ i ] ] * 100 ) + "%)" ) ; } else { labelinfo . settext ( "passez la souris sur un point pour plus de d\ufffdtails" ) ; } }
tr	5	public void checkbreakeven ( double x ) { long start , clock1 , clock2 ; double digammax = digamma ( x ) ; for ( int n = 1 ; n < 100 ; n ++ ) { start = system . currenttimemillis ( ) ; for ( int i = 0 ; i < 1000000 ; i ++ ) { digamma ( x + n ) ; } clock1 = system . currenttimemillis ( ) - start ; start = system . currenttimemillis ( ) ; for ( int i = 0 ; i < 1000000 ; i ++ ) { digammadifference ( x , n ) ; } clock2 = system . currenttimemillis ( ) - start ; system . out . println ( n + "\\tdirect: " + clock1 + "\\tindirect: " + clock2 + " (" + ( clock1 - clock2 ) + ")" ) ; system . out . println ( "  " + ( digamma ( x + n ) - digammax ) + " " + digammadifference ( x , n ) ) ; } }
tr	10	public static equation parseequation ( string strequation ) throws invalidequationexception { arraylist < expression > expressionlist = new arraylist < expression > ( ) ; linkedlist < integer > digits = new linkedlist < integer > ( ) ; for ( int i = 0 ; i < strequation . length ( ) ; i ++ ) { if ( ( character . isdigit ( strequation . charat ( i ) ) ) ) { string digit = strequation . substring ( i , i + 1 ) ; digits . addlast ( integer . parseint ( digit ) ) ; if ( strequation . length ( ) - 1 == i || ! character . isdigit ( strequation . charat ( i + 1 ) ) ) { int val = listtoint ( digits ) ; expressionlist . add ( new numericalexpression ( val ) ) ; digits . clear ( ) ; } } else if ( strequation . charat ( i ) == '+' ) { expressionlist . add ( new additionexpression ( ) ) ; } else if ( strequation . charat ( i ) == '-' ) { expressionlist . add ( new subtractionexpression ( ) ) ; } else if ( strequation . charat ( i ) == '*' ) { expressionlist . add ( new multiplicationexpression ( ) ) ; } else if ( strequation . charat ( i ) == '/' || strequation . charat ( i ) == '/' ) { expressionlist . add ( new divisionexpression ( ) ) ; } } return new equation ( expressionlist ) ; }
tr	9	public static void main ( string [ ] args ) { for ( int i = 0 ; i < 100 ; i ++ ) { char c = ( char ) ( math . random ( ) * 26 + 'a' ) ; system . out . print ( c + ": " ) ; switch ( c ) { case 'a' : case 'e' : case 'i' : case 'o' : case 'u' : system . out . println ( "vowel" ) ; break ; case 'y' : case 'w' : system . out . println ( "sometimes a vowel" ) ; break ; default : system . out . println ( "consonant" ) ; } } }
tr	3	@ override public person delete ( long id ) { for ( int i = 0 ; i < persons . size ( ) ; i ++ ) { if ( persons . get ( i ) . getid ( ) == id ) { return persons . remove ( i ) ; } } return null ; }
tr	8	private static string string ( object o ) { if ( o == null ) { return "null" ; } if ( o instanceof object [ ] ) { return arrays . tostring ( ( object [ ] ) o ) ; } if ( o instanceof int [ ] ) { return arrays . tostring ( ( int [ ] ) o ) ; } return o . tostring ( ) ; }
tr	7	private void addlogbehaviour ( ) { addbehaviour ( new cyclicbehaviour ( this ) { public void action ( ) { aclmessage msg = receive ( ) ; if ( msg != null ) { aclmessage reply = null ; if ( msg . getsender ( ) . getlocalname ( ) . equals ( "ams" ) ) { system . out . println ( msg ) ; } else { try { reply = chooseaction ( msg ) ; } catch ( unreadableexception e ) { exceptionutils . handleexception ( e ) ; } } if ( reply != null ) { send ( reply ) ; } } else { block ( ) ; } } } ) ; }
tr	7	public void seek ( int lognameindex , int startposition ) { try { currentlog . out . close ( ) ; int maxindex = currentlog . lognameindex ; while ( maxindex > lognameindex ) { boolean result = new file ( logdir , string . valueof ( maxindex ) ) . delete ( ) ; system . out . println ( result ) ; maxindex -- ; } file newfile = file . createtempfile ( "storm" , "tmp" ) ; newfile . delete ( ) ; new file ( logdir , string . valueof ( lognameindex ) ) . renameto ( newfile ) ; currentlog = new currentlog ( logdir , lognameindex , 0 , userrecordcount ) ; datainputstream in = new datainputstream ( new bufferedinputstream ( new fileinputstream ( newfile ) ) ) ; while ( true ) { t record = ( t ) readmethod . invoke ( 0 , in ) ; int thisstartposition = in . readint ( ) ; in . readint ( ) ; if ( thisstartposition == startposition ) { break ; } append ( record ) ; } in . close ( ) ; newfile . delete ( ) ; } catch ( exception e ) { throw new runtimeexception ( e ) ; } }
tr	7	static string getclazz ( int clazz ) { switch ( clazz & dnsconstants . class_mask ) { case dnsconstants . class_in : return "in" ; case dnsconstants . class_cs : return "cs" ; case dnsconstants . class_ch : return "ch" ; case dnsconstants . class_hs : return "hs" ; case dnsconstants . class_none : return "none" ; case dnsconstants . class_any : return "any" ; default : return "?" ; } }
tr	10	@ override public void actionperformed ( actionevent e ) { if ( e . getsource ( ) == open ) { int returnval = filechooser . showopendialog ( ui . this ) ; if ( returnval == jfilechooser . approve_option ) { file file = filechooser . getselectedfile ( ) ; system . out . println ( "opening: " + file . getname ( ) ) ; try { torrent t = torrentparser . parsetorrentfile ( file . getabsolutepath ( ) ) ; ls . addtorrent ( t ) ; } catch ( exception ex ) { joptionpane . showmessagedialog ( mainpane , "invalid torrent file" ) ; } } else { system . out . println ( "open command cancelled by user." ) ; } } else if ( e . getsource ( ) == magnet ) { system . out . println ( "clicked magent" ) ; string ans = joptionpane . showinputdialog ( null , "magnet link:" ) ; system . out . println ( "go fetch: " + ans ) ; } else if ( e . getsource ( ) == delete ) { system . out . println ( "delete " ) ; system . out . println ( "delete " + torrentlist . getselectedrow ( ) ) ; ls . deletetorrentdata ( ls . gettorrent ( torrentlist . getselectedrow ( ) ) ) ; } else if ( e . getsource ( ) == stop ) { system . out . println ( "stop " ) ; system . out . println ( "stop " + torrentlist . getselectedrow ( ) ) ; try { ls . settorrentdeactive ( ls . gettorrent ( torrentlist . getselectedrow ( ) ) ) ; } catch ( ioexception e1 ) { e1 . printstacktrace ( ) ; } } else if ( e . getsource ( ) == play ) { system . out . println ( "play " ) ; system . out . println ( "start " + torrentlist . getselectedrow ( ) ) ; try { ls . reactivate ( ls . gettorrent ( torrentlist . getselectedrow ( ) ) ) ; } catch ( ioexception | nosuchalgorithmexception e1 ) { e1 . printstacktrace ( ) ; } } }
tr	6	public static final void info ( final string txt , final boolean isdebug ) { if ( isdebug && ! options . getbooloption ( "debugprinting" ) ) { return ; } if ( isdebug ) { system . out . println ( levels . debug . gettitle ( ) + " " + txt ) ; } else { system . out . println ( levels . info . gettitle ( ) + " " + txt ) ; } }
tr	5	public static int findlongestbyexpandinginthemiddle ( string longpalindrome ) { char [ ] palindrome = longpalindrome . tochararray ( ) ; int maxlen = - 1 ; int beginindex = - 1 ; for ( int i = 0 ; i < longpalindrome . length ( ) ; i ++ ) { int l = expand ( palindrome , i , i + 1 ) ; int l1 = expand ( palindrome , i , i ) ; int max = l > l1 ? l : l1 ; if ( max > maxlen ) { maxlen = max ; beginindex = i ; } } return maxlen ; }
tr	8	public editbuttonslistener ( final menuitem menuitem ) throws illegalparametrs { this . menuitem = menuitem ; switch ( menuitem ) { case add : listener = new addbuttonactionlistener ( ) ; break ; case delete : listener = new deletebuttonactionlistener ( ) ; break ; case find : listener = new findbuttonactionlistener ( ) ; break ; case language_english : listener = new englishlanguagebuttonactionlistener ( ) ; break ; case language_russian : listener = new russianlanguagebuttonactionlistener ( ) ; break ; case connect : listener = new connectbuttonactionlistener ( ) ; break ; case disconnect : listener = new disconnectbuttonactionlistener ( ) ; break ; default : throw new illegalparametrs ( ) ; } }
tr	8	private static result dosendviagcm ( string message , sender sender , deviceinfo deviceinfo ) throws ioexception { if ( message . length ( ) > 1000 ) { message = message . substring ( 0 , 1000 ) + "[...]" ; } message msg = new message . builder ( ) . adddata ( "message" , message ) . build ( ) ; result result = sender . send ( msg , deviceinfo . getdeviceregistrationid ( ) , 5 ) ; if ( result . getmessageid ( ) != null ) { string canonicalregid = result . getcanonicalregistrationid ( ) ; if ( canonicalregid != null ) { endpoint . removedeviceinfo ( deviceinfo . getdeviceregistrationid ( ) ) ; deviceinfo . setdeviceregistrationid ( canonicalregid ) ; endpoint . insertdeviceinfo ( deviceinfo ) ; } } else { string error = result . geterrorcodename ( ) ; if ( error . equals ( constants . error_not_registered ) ) { endpoint . removedeviceinfo ( deviceinfo . getdeviceregistrationid ( ) ) ; } } return result ; }
tr	6	public string tostring ( hashmap < element , string > names ) { string targetname = "e" ; if ( target != null && names . containskey ( target ) ) targetname = names . get ( target ) ; string [ ] elementclass = element . getclass ( ) . getname ( ) . split ( "\\\\." ) ; string str = names . get ( element ) + " " + elementclass [ elementclass . length - 1 ] + " " + targetname + " " + position . x + " " + position . y + " " + velocity . x + " " + velocity . y + " " + radius + " " + size + " " + maxspeed ; if ( element instanceof animal ) { str += " " + collisionavoidanceweight + " " + flockcenteringweight + " " + velocitymatchingweight + " " + otheranimalweight + " " + terrainavoidanceweight ; } return str ; }
tr	7	private void handlecores ( ) { for ( icore c : cores ) { if ( c . iscreated ( ) ) { c . tick ( ) ; if ( c . isdead ( ) ) { entities . removeall ( c . getparts ( ) ) ; } } else { while ( ! c . iscreated ( ) ) { if ( c . step ( getintersectingentity ( new rectangle ( c . getnextposition ( ) . getx ( ) + 2 , c . getnextposition ( ) . gety ( ) + 2 , constants . tile_size - 4 , constants . tile_size - 4 ) ) ) ) { c . create ( ) ; } else if ( c . iscreated ( ) ) { entities . addall ( c . getparts ( ) ) ; } } } } }
tr	8	protected boolean fix_with_precedence ( production p , int term_index , parse_action_row table_row , parse_action act ) throws internal_error { terminal term = terminal . find ( term_index ) ; if ( p . precedence_num ( ) > assoc . no_prec ) { if ( p . precedence_num ( ) > term . precedence_num ( ) ) { table_row . under_term [ term_index ] = insert_reduce ( table_row . under_term [ term_index ] , act ) ; return true ; } else if ( p . precedence_num ( ) < term . precedence_num ( ) ) { table_row . under_term [ term_index ] = insert_shift ( table_row . under_term [ term_index ] , act ) ; return true ; } else { if ( term . precedence_side ( ) == assoc . right ) { table_row . under_term [ term_index ] = insert_shift ( table_row . under_term [ term_index ] , act ) ; return true ; } else if ( term . precedence_side ( ) == assoc . left ) { table_row . under_term [ term_index ] = insert_reduce ( table_row . under_term [ term_index ] , act ) ; return true ; } else if ( term . precedence_side ( ) == assoc . nonassoc ) { table_row . under_term [ term_index ] = new nonassoc_action ( ) ; return true ; } else { throw new internal_error ( "unable to resolve conflict correctly" ) ; } } } else if ( term . precedence_num ( ) > assoc . no_prec ) { table_row . under_term [ term_index ] = insert_shift ( table_row . under_term [ term_index ] , act ) ; return true ; } return false ; }
tr	1	@ override public treereader newtreereader ( reader in ) { return new penntreereader ( in , new labeledscoredtreefactory ( ) ) ; }
tr	7	public defaulttreefortreelayout < node > deletenode ( defaulttreefortreelayout < node > tree , node node , int id ) { createsernode ( tree , node , id ) ; if ( indxofdelnode == - 1 ) { sernodes . clear ( ) ; return null ; } else { defaulttreefortreelayout < node > newtree ; node delnode = sernodes . get ( indxofdelnode ) . getnode ( ) ; node parent = tree . getparent ( delnode ) ; sernode serparent = null ; for ( sernode checknode : sernodes ) { if ( checknode . getnode ( ) . getid ( ) == parent . getid ( ) ) { serparent = checknode ; break ; } } serparent . getchildren ( ) . remove ( delnode ) ; for ( node child : sernodes . get ( indxofdelnode ) . getchildren ( ) ) { serparent . getchildren ( ) . add ( child ) ; } sernodes . remove ( sernodes . get ( indxofdelnode ) ) ; newtree = buidtree ( ) ; sernodes . clear ( ) ; indxofdelnode = - 1 ; return newtree ; } }
tr	3	private void configurefileconfig ( persistenceconfig configuration ) throws providerconfigurationexception { if ( configuration instanceof fileconfig ) { fileconfig fileconfig = ( fileconfig ) configuration ; path = fileconfig . getpath ( ) ; filename = fileconfig . getfilename ( ) ; backuponsave = fileconfig . isbackuponsave ( ) ; } else { if ( ! configuration . getclass ( ) . equals ( persistenceconfig . class ) ) throw new providerconfigurationexception ( "use instances of persistenceconfig or fileconfig to" + "configure propertiespersistenceprovider" ) ; path = null ; filename = null ; backuponsave = false ; optionsfile = null ; } }
tr	3	@ override public void handlemessage ( message msg ) { if ( msg . what == netconfig . tag_callback_success ) { util . showtips ( getapplicationcontext ( ) , "\u5bc6\u7801\u4fee\u6539\u6210\u529f" ) ; string _username = musernameedit . gettext ( ) . tostring ( ) ; string _password = mnewpwdedit . gettext ( ) . tostring ( ) ; gamedbhelper . getinstance ( changepwdactivity . this ) . insertorupdateloginusername ( _username , _password ) ; finish ( ) ; } else if ( msg . what == netconfig . tag_callback_failed ) { toast . maketext ( getapplicationcontext ( ) , msg . obj . tostring ( ) , toast . length_short ) . show ( ) ; } }
tr	1	public whiteboardclientmodel ( ) { settool ( pen . class ) ; setusername ( getguestusername ( ) ) ; }
tr	7	private static soup soupofday ( abstractsoupfactory concretesoup ) { calendar todaycalendar = calendar . getinstance ( ) ; int dayoftheweek = todaycalendar . get ( calendar . day_of_week ) ; dayoftheweek = calendar . wednesday ; switch ( dayoftheweek ) { case calendar . monday : return concretesoup . makechickensoup ( ) ; case calendar . tuesday : return concretesoup . makeclamchowder ( ) ; case calendar . wednesday : return concretesoup . makefishchowder ( ) ; case calendar . thursday : return concretesoup . makeminnestrone ( ) ; case calendar . friday : return concretesoup . makepastafazul ( ) ; case calendar . saturday : return concretesoup . maketofusoup ( ) ; case calendar . sunday : return concretesoup . makevegetablesoup ( ) ; } return null ; }
tr	5	private static number getnumber ( string s ) { matcher matcher = pattern_number . matcher ( s ) ; if ( matcher . matches ( ) ) { if ( s . indexof ( "." ) != - 1 ) { try { return new double ( s ) ; } catch ( numberformatexception err ) { return new bigdecimal ( s ) ; } } else { try { return new integer ( s ) ; } catch ( numberformatexception err ) { return new biginteger ( s ) ; } } } return null ; }
tr	10	public map < integer , predictionstats > getstats ( board actualboard ) { map < integer , predictionstats > predictionsmap = new hashmap < > ( ) ; int [ ] [ ] results = new int [ board . getnumrows ( ) ] [ board . getnumcols ( ) ] ; int [ ] [ ] actualdata = actualboard . getdata ( ) ; for ( int a = 0 ; a < board . getnumrows ( ) ; a ++ ) { for ( int b = 0 ; b < board . getnumrows ( ) ; b ++ ) { prediction prediction = combine ( data [ a ] [ b ] ) ; if ( ! predictionsmap . containskey ( prediction . bitspercollection ) ) { predictionsmap . put ( prediction . bitspercollection , new predictionstats ( prediction . bitspercollection ) ) ; } predictionstats stats = predictionsmap . get ( prediction . bitspercollection ) ; if ( prediction . probability > 0.5d ) { results [ a ] [ b ] = 1 ; } else { results [ a ] [ b ] = 0 ; } if ( results [ a ] [ b ] == actualdata [ a ] [ b ] ) { stats . addcorrect ( prediction . confidence ) ; } else { stats . addincorrect ( prediction . confidence ) ; } } } return predictionsmap ; }
tr	1	public calendar getdatefrom ( ) { return mdatefrom ; }
tr	5	private filehandler createlogfilehandler ( ) { try { return new filehandler ( this . log_location , true ) ; } catch ( securityexception e ) { if ( true ) { e . printstacktrace ( ) ; } } catch ( ioexception e ) { if ( true ) { e . printstacktrace ( ) ; } } return null ; }
tr	4	@ override public loginresponse login ( loginrequest request ) throws ioexception { if ( username . equals ( "" ) ) { synchronized ( users ) { if ( users . containskey ( request . getusername ( ) ) ) { config config = new config ( "user" ) ; if ( config . getstring ( request . getusername ( ) + ".password" ) . equals ( request . getpassword ( ) ) ) { username = request . getusername ( ) ; userinfo old = users . get ( username ) ; userinfo info = new userinfo ( username , old . getcredits ( ) , true ) ; users . put ( username , info ) ; return new loginresponse ( loginresponse . type . success ) ; } else { return new loginresponse ( loginresponse . type . wrong_credentials ) ; } } else { return new loginresponse ( loginresponse . type . wrong_credentials ) ; } } } else { return new loginresponse ( loginresponse . type . wrong_credentials ) ; } }
tr	8	@ override public void handlestatus ( status s ) { if ( logger . istraceenabled ( ) ) { logger . trace ( "handling status " + s ) ; } if ( s . gettype ( ) != status . type . joined ) return ; string nick = s . getnick ( ) ; if ( pozdravy . containskey ( nick ) ) { ph . sendmessage ( nick + ": " + pozdravy . get ( nick ) ) ; } }
tr	9	private void validatelength ( jsonnode node , list < errormessage > results ) { if ( minlength > 0 ) { string value = type . getvalue ( node ) . tostring ( ) ; if ( value . length ( ) < minlength ) { results . add ( new errormessage ( "" , "value '" + node . textvalue ( ) + "' must be greater or equal to " + minlength + " characters" ) ) ; } } if ( maxlength > 0 ) { string value = type . getvalue ( node ) . tostring ( ) ; if ( value . length ( ) > maxlength ) { results . add ( new errormessage ( "" , string . format ( "value '%s' must be less or equal to %d characters" , node . textvalue ( ) , maxlength ) ) ) ; } } }
tr	8	private void initcsvrecordparameters ( ) { if ( separator == null ) { for ( class < ? > cl : models ) { csvrecord record = cl . getannotation ( csvrecord . class ) ; section section = cl . getannotation ( section . class ) ; if ( record != null ) { log . debug ( "csv record: {}" , record ) ; skipfirstline = record . skipfirstline ( ) ; log . debug ( "skip first line parameter of the csv: {}" + skipfirstline ) ; generateheadercolumnnames = record . generateheadercolumns ( ) ; log . debug ( "generate header column names parameter of the csv: {}" , generateheadercolumnnames ) ; objecthelper . notnull ( record . separator ( ) , "no separator has been defined in the @record annotation" ) ; separator = record . separator ( ) ; log . debug ( "separator defined for the csv: {}" , separator ) ; crlf = record . crlf ( ) ; log . debug ( "carriage return defined for the csv: {}" , crlf ) ; messageordered = record . isordered ( ) ; log . debug ( "must csv record be ordered: {}" , messageordered ) ; if ( objecthelper . isnotempty ( record . quote ( ) ) ) { quote = record . quote ( ) ; log . debug ( "quoting columns with: {}" , quote ) ; } quoting = record . quoting ( ) ; log . debug ( "csv will be quoted: {}" , messageordered ) ; } if ( section != null ) { objecthelper . notnull ( section . number ( ) , "no number has been defined for the section" ) ; sections . put ( cl . getname ( ) , section . number ( ) ) ; } } } }
tr	4	private void loop ( ) { thread thtmp = thread . currentthread ( ) ; byte [ ] arrbytes = new byte [ ezimnetwork . inbuf ] ; datagrampacket dp = new datagrampacket ( arrbytes , arrbytes . length ) ; while ( ! thtmp . isinterrupted ( ) ) { try { this . ms . receive ( dp ) ; final inetaddress iaack = dp . getaddress ( ) ; final string strack = new string ( dp . getdata ( ) , 0 , dp . getlength ( ) , ezimnetwork . dtxmsgenc ) ; ezimthreadpool etptmp = ezimthreadpool . getinstance ( ) ; etptmp . execute ( new runnable ( ) { public void run ( ) { ezimacksemantics . parser ( iaack , strack ) ; } } ) ; } catch ( exception e ) { if ( ! thtmp . isinterrupted ( ) ) ezimlogger . getinstance ( ) . severe ( e . getmessage ( ) , e ) ; } } }
tr	2	public static void processfile ( string file , string path ) { string text = fileutil . gettextfromfile ( file ) ; try { annotate ( text ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } }
tr	8	public static void visualize ( graphics g ) { if ( list == null ) return ; list . reset ( ) ; g . setcolor ( color . red ) ; while ( list . hasnext ( ) ) { angleinterval ai = list . getnext ( ) ; if ( ( int ) ai . leftdist == 0 && ( int ) ai . rightdist == 0 ) continue ; g . drawline ( ( int ) ( src . x ( ) + math . cos ( ai . leftangle ) * ai . leftdist ) , ( int ) ( src . y ( ) + math . sin ( ai . leftangle ) * ai . leftdist ) , ( int ) ( src . x ( ) + math . cos ( ai . rightangle ) * ai . rightdist ) , ( int ) ( src . y ( ) + math . sin ( ai . rightangle ) * ai . rightdist ) ) ; } }
tr	3	public void purgeshots ( dimension screensize ) { for ( int i = shots . size ( ) - 1 ; i > - 1 ; i -- ) { if ( shots . get ( i ) . outsidescreen ( screensize ) ) { shots . remove ( i ) ; } } }
tr	5	public static int expand ( char [ ] palindrome , int i , int j ) { int l = 0 ; while ( i >= 0 && j < palindrome . length && palindrome [ i ] == palindrome [ j ] ) { if ( i == j ) { l ++ ; i -- ; j ++ ; continue ; } i -- ; j ++ ; l = l + 2 ; } return l ; }
tr	5	public room north ( ) throws roomnotaccessibleexception { if ( utiliserlampe && ! utiliserroche ) throw new roomnotaccessibleexception ( "vous apercevez quelques planches pourries qui semblent assez faible." ) ; else if ( utiliserlampe && utiliserroche ) return levelmanager . getinstance ( ) . getcurrentlevel ( ) . getroom ( "enigme" ) ; else throw new roomnotaccessibleexception ( "il fait noir" ) ; }
tr	7	private static file extractfilefromzip ( url url , string path ) { try { zipinputstream input ; input = new zipinputstream ( url . openstream ( ) ) ; zipentry entry = input . getnextentry ( ) ; while ( entry != null ) { if ( entry . getname ( ) . equalsignorecase ( "en.xml" ) ) { long entsize = entry . getsize ( ) ; if ( entsize > 0 && entsize <= maxsize ) { int size = ( int ) entsize ; byte [ ] bytestoread = new byte [ size ] ; filesys . checkdirectory ( path ) ; filesys . checkfile ( path + "en.xml" ) ; fileoutputstream fos = new fileoutputstream ( path + "en.xml" ) ; bufferedoutputstream bos = new bufferedoutputstream ( fos , size ) ; int s ; while ( ( s = input . read ( bytestoread , 0 , bytestoread . length ) ) != - 1 ) { bos . write ( bytestoread , 0 , s ) ; } bos . flush ( ) ; bos . close ( ) ; } else { logs . logwarning ( "zipfile entry: " + path + " is too large to be extracted: " , logger ) ; } break ; } else { entry = input . getnextentry ( ) ; } input . close ( ) ; } return new file ( path + "en.xml" ) ; } catch ( ioexception ex ) { logs . logexception ( ex , "error unzipping file: " , logger ) ; return null ; } }
tr	10	public void initiateremoval ( ) { if ( this . isremoving ( ) ) return ; try { list < appointment > aappt = appointment . findbyvenue ( this . getid ( ) ) ; if ( aappt . size ( ) <= 0 ) { this . finalizeremovalwithoutchecking ( ) ; return ; } this . awaitingid . clear ( ) ; for ( appointment appt : aappt ) { this . awaitingid . add ( appt . initiatorid ) ; venueremovalinitiated notification = new venueremovalinitiated ( this ) ; notification . add ( appt . initiatorid , notification ) ; } this . save ( ) ; } catch ( sqlexception e ) { e . printstacktrace ( ) ; } }
tr	9	public static void main ( string [ ] args ) { try { textscanner scanner ; if ( args . length > 0 ) { scanner = new textscanner ( new file ( args [ 0 ] ) ) ; } else { scanner = new textscanner ( ) ; } string wd ; int par = 0 ; system . out . print ( ( ++ par ) + " " ) ; while ( ( wd = scanner . nexttxtword ( ) ) != null ) { if ( wd . startswith ( "e@0@l" ) ) { system . out . println ( ) ; } else { if ( wd . startswith ( "e@0@p" ) ) { system . out . println ( "\\n" ) ; system . out . print ( ( ++ par ) + " " ) ; } else { system . out . print ( wd + " " ) ; } } } } catch ( ioexception e ) { system . err . println ( "malament del tot" ) ; e . printstacktrace ( ) ; } }
tr	6	private material getrandomorematerial ( ) { int oretype = prnd . nextint ( 5 ) ; switch ( oretype ) { case 0 : case 1 : case 2 : return material . coal_ore ; case 3 : return material . silver_ore ; case 4 : return material . gold_ore ; default : return material . coal_ore ; } }
tr	6	public byte findnextmarker ( ) throws ioexception { boolean marked0xff = false ; byte byteinfo = jpegmarker . x00 ; setbitoffset ( 0 ) ; while ( true ) { byteinfo = readbyte ( ) ; if ( ! marked0xff ) { if ( byteinfo == jpegmarker . xff ) marked0xff = true ; } else { if ( byteinfo == jpegmarker . xff ) continue ; else if ( byteinfo == jpegmarker . x00 ) marked0xff = false ; else return byteinfo ; } } }
tr	1	public txtrenderer ( final string pre , final appendable sb ) { assert pre != null ; this . sb = sb ; this . pres = new stack < string > ( ) ; this . pres . push ( pre ) ; }
tr	1	public string getsecondaryid ( ) { return msecondaryid ; }
tr	5	public void interactslot ( inventory inv , int slot ) { if ( inv . getiteminslot ( slot ) != null && grabbed == null ) { this . inventory = inv ; this . slotid = slot ; grabbed = inventory . getiteminslot ( slotid ) ; inventory . setiteminslot ( slotid , null ) ; } else if ( grabbed != null && inv . getiteminslot ( slot ) == null ) { inv . setiteminslot ( slot , grabbed ) ; this . inventory = null ; this . slotid = - 1 ; grabbed = null ; } }
tr	8	private static void tweakoldxmp ( xmpnode tree ) throws xmpexception { if ( tree . getname ( ) != null && tree . getname ( ) . length ( ) >= utils . uuid_length ) { string namestr = tree . getname ( ) . tolowercase ( ) ; if ( namestr . startswith ( "uuid:" ) ) { namestr = namestr . substring ( 5 ) ; } if ( utils . checkuuidformat ( namestr ) ) { xmppath path = xmppathparser . expandxpath ( xmpconst . ns_xmp_mm , "instanceid" ) ; xmpnode idnode = xmpnodeutils . findnode ( tree , path , true , null ) ; if ( idnode != null ) { idnode . setoptions ( null ) ; idnode . setvalue ( "uuid:" + namestr ) ; idnode . removechildren ( ) ; idnode . removequalifiers ( ) ; tree . setname ( null ) ; } else { throw new xmpexception ( "failure creating xmpmm:instanceid" , xmperror . internalfailure ) ; } } } }
tr	2	private void initrandom ( ) { if ( random == null ) { random = new randoms ( ) ; } }
tr	1	public threadgestaoarea ( serverimplementation server , iserverui serverui , oferta . area_atuacao areaatuacao , conexaobd conexao , int tempowaitverificacoeslocais , int tempowaitverificacoesbd ) { this . areaatuacao = areaatuacao ; this . conexao = conexao ; this . serverui = serverui ; this . server = server ; this . ofertasrecursoslivres = new linkedlist < > ( ) ; this . tempowaitverificacoesbd = tempowaitverificacoesbd ; this . tempowaitverificacoeslocais = tempowaitverificacoeslocais ; }
tr	7	private double g0 ( final int i ) { switch ( i ) { case - 3 : return - g03 ; case - 2 : return - g02 ; case - 1 : return - g01 ; case 1 : return g01 ; case 2 : return g02 ; case 3 : return g03 ; default : return 0.0 ; } }
tr	3	boolean canequal ( int [ ] other ) { for ( int [ ] roll : allrolls ( ) ) { if ( arrays . equals ( roll , other ) ) return true ; } return false ; }
tr	8	public void writeimage ( bufferedimage image , string filename ) throws ioexception { if ( filename == null ) { return ; } int offset = filename . lastindexof ( "." ) ; if ( offset == - 1 ) { string message = "file suffix was not specified" ; throw new ioexception ( message ) ; } string type = filename . substring ( offset + 1 ) ; if ( types . contains ( type ) ) { imageio . write ( image , type , new file ( filename ) ) ; } else { string message = "unknown writer file suffix (" + type + ")" ; throw new ioexception ( message ) ; } }
tr	7	public void loadscorefile ( ) { try { this . inputstream = new objectinputstream ( new fileinputstream ( highscoremanager . highscore_file ) ) ; this . scores = ( arraylist < score > ) this . inputstream . readobject ( ) ; } catch ( filenotfoundexception e ) { system . out . println ( "[laad] fnf error: " + e . getmessage ( ) + " das programm wird versuchen eine neue datei zu erstellen." ) ; } catch ( ioexception e ) { system . out . println ( "[laad] io error: " + e . getmessage ( ) ) ; } catch ( classnotfoundexception e ) { system . out . println ( "[laad] cnf error: " + e . getmessage ( ) ) ; } finally { try { if ( this . outputstream != null ) { this . outputstream . flush ( ) ; this . outputstream . close ( ) ; } } catch ( ioexception e ) { system . out . println ( "[laad] io error: " + e . getmessage ( ) ) ; } } }
tr	10	static public racet resolvepandarenfaction ( long bits ) { boolean a = pandaren_a . ismemberof ( bits ) ; boolean h = pandaren_h . ismemberof ( bits ) ; boolean n = pandaren_n . ismemberof ( bits ) ; if ( a && ! h && ! n ) { return pandaren_a ; } else if ( ! a && h && ! n ) { return pandaren_h ; } else if ( ! a && ! h && n ) { return pandaren_n ; } else { return null ; } }
tr	8	private void recalculatecompleted ( ) { completedquestdata [ ] cqd = log . getcompleted ( ) ; string [ ] ca = new string [ cqd . length ] ; for ( int i = 0 ; i < cqd . length ; i ++ ) ca [ i ] = cqd [ i ] . getquest ( ) . getid ( ) ; questmanager qm = skyquestplugin . getplugin ( ) . getquestmanager ( ) ; arraylist < quest > c = new arraylist < quest > ( ) ; for ( int i = 0 ; i < ca . length ; i ++ ) { quest q = qm . getquest ( ca [ i ] ) ; if ( q != null && q . isvisible ( ) ) c . add ( q ) ; } curcompleted = c . toarray ( new quest [ c . size ( ) ] ) ; }
tr	3	public static object [ ] splitlist ( list < string > emails ) { set < string > single = new hashset < string > ( ) ; set < string > dup = new hashset < string > ( ) ; for ( string e : emails ) { if ( single . contains ( e ) ) { dup . add ( e ) ; } else { single . add ( e ) ; } } return new object [ ] { single , dup } ; }
tr	8	public double area ( ) { double area = 0 ; if ( np > 2 ) { final int max = np + 1 ; for ( int j = 2 ; j <= max ; ++ j ) { double tmp = 0 ; for ( int i = 2 , imj = i - j ; i <= max ; ++ i , ++ imj ) tmp += c [ i ] . y * ( g0 ( imj ) + g0 ( imj - np ) + g0 ( imj + np ) ) ; area += c [ j ] . x * tmp ; } } return ( area < 0 ) ? - area : area ; }
tr	5	private void nextheader ( ) throws ioexception { int len , chunk = 0 ; while ( ! eof && header . syncframe ( buf , off , maxoff ) == false ) { off = header . offset ( ) ; len = maxoff - off ; system . arraycopy ( buf , off , buf , 0 , len ) ; maxoff = len + instream . read ( buf , len , off ) ; off = 0 ; if ( maxoff <= len || ( chunk += buflen ) > 0x10000 ) eof = true ; } off = header . offset ( ) ; }
tr	8	@ override public boolean mousescrolled ( int dir ) { this . scroll -= dir ; if ( this . scroll < 0 ) { this . scroll = 0 ; } int scrollmax = ( int ) math . ceil ( ( this . elements . size ( ) - ( this . height / 20.0 ) <= 0 ? 0 : this . elements . size ( ) - ( this . height / 20.0 ) ) ) ; if ( this . scroll > scrollmax ) { this . scroll = scrollmax ; } return false ; }
tr	4	public static double trigamma ( double z ) { int shift = 0 ; while ( z < 2 ) { z ++ ; shift ++ ; } double oneoverz = 1.0 / z ; double oneoverzsquared = oneoverz * oneoverz ; double result = oneoverz + 0.5 * oneoverzsquared + 0.1666667 * oneoverzsquared * oneoverz - 0.03333333 * oneoverzsquared * oneoverzsquared * oneoverz + 0.02380952 * oneoverzsquared * oneoverzsquared * oneoverzsquared * oneoverz - 0.03333333 * oneoverzsquared * oneoverzsquared * oneoverzsquared * oneoverzsquared * oneoverz ; system . out . println ( z + " -> " + result ) ; while ( shift > 0 ) { shift -- ; z -- ; result += 1.0 / ( z * z ) ; system . out . println ( z + " -> " + result ) ; } return result ; }
tr	1	public void setcallindentation ( final string callindentation ) { this . callindentation = callindentation ; }
tr	8	private boolean addincomingtab ( inetaddress ip ) { linkedlist < user > clients = this . client . getusers ( ) ; for ( user user : clients ) { if ( user . getip ( ) . equals ( ip ) ) { if ( nextkeyevents > ( keyevents . length - 1 ) ) { new popup ( user . getname ( ) + " tried to start a private chat with you. however you reached the maximum number of tabs<litcomma> please close one!" ) ; } else { addtab ( user ) ; return true ; } } } if ( ip != null ) { addtab ( ip , ip . gethostname ( ) . replace ( ".local" , "" ) ) ; } return false ; }
tr	4	public static int getvalue ( string key , string code ) { string value = "" ; for ( int i = 0 ; i < code . length ( ) ; i ++ ) { string token = code . substring ( i , i + 1 ) ; if ( key . contains ( token ) ) { int index = key . indexof ( token ) + 1 ; if ( index == 10 ) index = 0 ; value += index + "" ; } } return integer . parseint ( value ) ; }
tr	1	private double gettotalmillis ( final long nanos ) { return nanos / 1000000.0 ; }
tr	7	public static boolean arestandardfontfamiliesavailable ( ) { if ( ! fontschecked ) { fontschecked = true ; try { class toolkitclass = class . forname ( "java.awt.toolkit" ) ; method getfontlist = toolkitclass . getmethod ( "getfontlist" , new class [ 0 ] ) ; string [ ] fonts = ( string [ ] ) getfontlist . invoke ( toolkit . getdefaulttoolkit ( ) , new object [ 0 ] ) ; int standardfontcount = 0 ; for ( int i = 0 ; i < fonts . length ; i ++ ) { if ( fonts [ i ] . equals ( "serif" ) || fonts [ i ] . equals ( "sansserif" ) || fonts [ i ] . equals ( "monospaced" ) ) { standardfontcount ++ ; } } arestandardfontfamiliesavailable = ( standardfontcount == 3 ) ; } catch ( exception ex ) { arestandardfontfamiliesavailable = false ; } } return arestandardfontfamiliesavailable ; }
tr	3	@ override public node getchild ( string name ) { if ( children_ . containskey ( name ) ) { return children_ . get ( name ) ; } else { node child = node_ . getchild ( name ) ; if ( child == null ) { return null ; } virtualnode virtual_child = new virtualnode ( child , virtual_handler_ . getname ( ) + ":" + child . getname ( ) ) ; children_ . put ( name , virtual_child ) ; return virtual_child ; } }
tr	3	private boolean bucketsempty ( ) { for ( int i = 0 ; i < numberofbuckets ; i ++ ) { if ( bucketcontainer . getbucket ( i ) . elementsinbucket > 0 ) { return false ; } } return true ; }
tr	9	@ override public boolean parsemidimessage ( midimessage m ) { if ( m . getlength ( ) == length ( ) ) { byte header [ ] = new byte [ 7 ] ; bytearrayinputstream stream = new bytearrayinputstream ( m . getmessage ( ) ) ; try { stream . read ( header ) ; settings . setid ( stream . read ( ) + 1 ) ; stream . skip ( 1 ) ; sysexparser parser = new sysexparser ( stream , settings ) ; parser . toggleproperty ( parametertoggle . distortion ) ; parser . toggleproperty ( parametertoggle . drive ) ; parser . toggleproperty ( parametertoggle . = ) ; parser . toggleproperty ( parametertoggle . delay ) ; parser . toggleproperty ( parametertoggle . enableeffect ) ; parser . toggleproperty ( parametertoggle . reverbenable ) ; parser . toggleproperty ( parametertoggle . noisegate ) ; parser . toggleproperty ( parametertoggle . bright ) ; parser . bytemidiproperty ( parameter . & ) ; parser . byteproperty ( parameter . drive ) ; parser . byteproperty ( parameter . drive2 ) ; parser . byteproperty ( parameter . bass ) ; parser . byteproperty ( parameter . mid ) ; parser . byteproperty ( parameter . treble ) ; parser . byteproperty ( parameter . presence ) ; parser . byteproperty ( parameter . channelvolume ) ; parser . byteproperty ( effectparameter . noisegatethreshold ) ; parser . byteproperty ( effectparameter . noisegatedecay ) ; parser . byteproperty ( effectparameter . wahposition ) ; parser . byteproperty ( effectparameter . wahbotfreq ) ; parser . byteproperty ( effectparameter . wahtopfreq ) ; parser . skip ( 1 ) ; parser . skip ( 1 ) ; parser . skip ( 1 ) ; parser . skip ( 1 ) ; parser . skip ( 1 ) ; parser . skip ( 1 ) ; parser . shortproperty ( effectparameter . delaycoarse ) ; parser . byteproperty ( effectparameter . delayfine ) ; parser . skip ( 4 ) ; parser . byteproperty ( effectparameter . delayfeedback ) ; parser . skip ( 1 ) ; parser . byteproperty ( effectparameter . delaylevel ) ; parser . skip ( 1 ) ; parser . toggleproperty ( parametertoggle . reverbspringroom ) ; parser . byteproperty ( effectparameter . reverbdecay ) ; parser . byteproperty ( effectparameter . reverbtone ) ; parser . byteproperty ( effectparameter . reverbdiffusion ) ; parser . byteproperty ( effectparameter . reverbdensity ) ; parser . byteproperty ( parameter . reverb ) ; parser . bytemidiproperty ( parameter . cabinet ) ; parser . byteproperty ( parameter . air ) ; parser . bytemidiproperty ( parameter . effect ) ; parser . byteproperty ( parameter . effects ) ; int effectid = ( settings . getvalue ( parameter . effect ) ) ; if ( effectid == effect . delayswell . id ( ) ) { parser . byteproperty ( effectparameter . swellattacktime ) ; parser . skip ( 6 ) ; } else if ( effectid == effect . compressor . id ( ) || effectid == effect . delaycompressor . id ( ) ) { parser . comboproperty ( effectparameter . compressorratio ) ; parser . skip ( 6 ) ; } else if ( effectid == effect . rotary . id ( ) ) { parser . skip ( 1 ) ; parser . shortproperty ( effectparameter . fastspeed ) ; parser . shortproperty ( effectparameter . slowspeed ) ; parser . skip ( 2 ) ; } else if ( effectid == effect . tremolo . id ( ) || effectid == effect . delaytremolo . id ( ) ) { parser . shortproperty ( effectparameter . tremolospeed ) ; parser . byteproperty ( effectparameter . tremolodepth ) ; parser . skip ( 4 ) ; } else { parser . shortproperty ( effectparameter . speed ) ; parser . shortproperty ( effectparameter . depth ) ; parser . byteproperty ( effectparameter . feedback ) ; parser . shortproperty ( effectparameter . predelay ) ; } settings . setname ( parser . readstring ( 16 ) ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } } return false ; }
tr	5	public void updatedisplay ( ) { int bookcount = model . countbooks ( ) ; int videocount = model . countvideos ( ) ; if ( bookcount == 0 && videocount == 0 ) { cleardisplay ( ) ; } else { gridcell [ ] holdingcells = getholdingcells ( ) ; int padcount = calculatepadcount ( holdingcells . length , librarygridcontroller . max_cells_per_column ) ; gridcell [ ] cells = createsortandcombinecells ( holdingcells , padcount ) ; mainview . getcontroller ( ) . setcells ( holdingcells , padcount ) ; mainview . updatelibrarygrid ( cells ) ; mainview . updatestatusbar ( getstatusdata ( ) ) ; gridstate state = gridstate . initialised ; if ( bookcount == 0 ) state = gridstate . nobooks ; else if ( videocount == 0 ) state = gridstate . novideos ; mainview . getcontroller ( ) . notifygridlisteners ( state ) ; } }
tr	5	public void sendmessages ( chatclient client ) throws jmsexception { bufferedreader in = new bufferedreader ( new inputstreamreader ( system . in ) ) ; string msg ; system . out . println ( "enter messages to send (type \\"stop\\" to return to lobby):" ) ; try { while ( ( msg = in . readline ( ) ) != null ) { if ( msg . equalsignorecase ( "stop" ) ) { system . out . println ( "stopping..." ) ; break ; } else if ( msg . length ( ) != 0 ) client . send ( msg ) ; } } catch ( ioexception exception ) { throw new runtimeexception ( exception ) ; } }
tr	1	public laserwire ( ) { super ( "laser wire" , keyevent . vk_8 , "/resources/images/gzs_laserwire.png" , laserwire . default_ammo , laserwire . max_ammo , laserwire . ammo_per_use , 50 , false ) ; this . lasers = collections . synchronizedlist ( new arraylist < line2d . double > ( ) ) ; this . lastdamagedone = 0 ; }
tr	10	@ override public void update ( observable o , object arg ) { if ( arg instanceof sevenoutevent ) { lastbets . clear ( ) ; } else if ( o instanceof passorcome ) { if ( ( ( betevent ) arg ) . gettype ( ) == betevent . eventtype . number_established ) { passorcome bet = ( passorcome ) o ; if ( lastbets . get ( bet . getnumber ( ) ) == null ) { lastbets . put ( bet . getnumber ( ) , starting_odds * bet . getmainbet ( ) ) ; } else { int newbet = lastbets . get ( bet . getnumber ( ) ) + bet . getmainbet ( ) ; if ( newbet <= bet . getmaxoddsbet ( ) ) lastbets . put ( bet . getnumber ( ) , newbet ) ; } bet . updateoddsbet ( lastbets . get ( bet . getnumber ( ) ) ) ; } } else if ( o instanceof dont ) { if ( ( ( betevent ) arg ) . gettype ( ) == betevent . eventtype . number_established ) { dont bet = ( dont ) o ; if ( lastbets . get ( bet . getnumber ( ) ) == null ) { lastbets . put ( bet . getnumber ( ) , bet . getoddsbetmultiple ( starting_odds ) ) ; } else { int newbet = lastbets . get ( bet . getnumber ( ) ) + bet . getmainbet ( ) ; if ( newbet <= bet . getmaxoddsbet ( ) ) lastbets . put ( bet . getnumber ( ) , newbet ) ; } bet . updateoddsbet ( lastbets . get ( bet . getnumber ( ) ) ) ; } } }
tr	1	public void setbaseclassifier ( classifier baseclassifier ) { this . baseclassifier = baseclassifier ; }
tr	1	public string getorderid ( ) { return morderid ; }
tr	3	private ofertaemprego buscarofertaempregolivre ( ) { try { list < ofertaemprego > listaempregolivre = empregofromresultset ( conexao . getstatement ( ) . executequery ( "select * from " + nome_tabela_ofertas_emprego + " where " + emprego_coluna_area_atuacao + " = " + "'" + areaatuacao . name ( ) + "'" + " and " + emprego_coluna_estado_oferta + " = " + "'" + oferta . estado_oferta . por_aprovar . name ( ) + "'" ) ) ; for ( ofertaemprego emprego : listaempregolivre ) { return emprego ; } } catch ( sqlexception ex ) { serverui . sendmessage ( "erro de sql em threadgestaoarea.buscarofertaempregolivre()..." ) ; } return null ; }
tr	8	private static void loadaddresses ( ) { if ( addresses != null ) return ; synchronized ( addresslock ) { try { for ( networkinterface net : collections . list ( networkinterface . getnetworkinterfaces ( ) ) ) { if ( ! net . getdisplayname ( ) . contains ( "lo" ) ) { addresses = inetaddressnode . create ( net . getinetaddresses ( ) ) ; break ; } } } catch ( socketexception e ) { e . printstacktrace ( ) ; } } }
tr	7	public static int [ ] selectsort ( int [ ] data ) { int minindex ; for ( int i = 0 ; i < data . length ; ++ i ) { minindex = i ; for ( int j = i + 1 ; j < data . length ; ++ j ) { if ( data [ j ] < data [ minindex ] ) { minindex = j ; } } if ( minindex != i ) { datautils . swap ( data , minindex , i ) ; } system . out . println ( stringutils . tostring ( data ) ) ; } return data ; }
tr	2	public legendpanel ( ) { setbackground ( color . black ) ; setmaximumsize ( new dimension ( 600 , 30 ) ) ; setlayout ( new gridlayout ( 3 , 3 ) ) ; font font = new font ( font . dialog , font . plain , 15 ) ; jlabel label = new jlabel ( "legend" ) ; label . setfont ( font ) ; label . setforeground ( color . white ) ; label . setbackground ( color . black ) ; this . add ( label ) ; this . add ( new jlabel ( "" ) ) ; this . add ( new jlabel ( "" ) ) ; for ( int i = 0 ; i < types . length ; i ++ ) { label = new jlabel ( "    " + gettype ( types [ i ] ) ) ; label . setfont ( font ) ; label . setforeground ( getcolor ( types [ i ] ) ) ; label . setbackground ( color . black ) ; this . add ( label ) ; } }
tr	6	protected void report_shift_reduce ( lalr_item red_itm , int conflict_sym ) throws internal_error { lalr_item itm ; symbol shift_sym ; system . err . println ( "*** shift/reduce conflict found in state #" + index ( ) ) ; system . err . print ( "  between " ) ; system . err . println ( red_itm . to_simple_string ( ) ) ; for ( enumeration itms = items ( ) . all ( ) ; itms . hasmoreelements ( ) ; ) { itm = ( lalr_item ) itms . nextelement ( ) ; if ( itm != red_itm && ! itm . dot_at_end ( ) ) { shift_sym = itm . symbol_after_dot ( ) ; if ( ! shift_sym . is_non_term ( ) && shift_sym . index ( ) == conflict_sym ) { system . err . println ( "  and     " + itm . to_simple_string ( ) ) ; } } } system . err . println ( "  under symbol " + terminal . find ( conflict_sym ) . name ( ) ) ; system . err . println ( "  resolved in favor of shifting.\\n" ) ; emit . num_conflicts ++ ; lexer . warning_count ++ ; }
tr	5	public double evalutethestrategy ( ) { double sellsum = 0 ; double buysum = 0 ; int count = 0 ; int numberofsell = this . getnumberofsell ( ) ; for ( generatedsignal gs : gensiglist ) { if ( gs . gettype ( ) . equals ( "sell" ) ) { sellsum += gs . getprice ( ) ; } else if ( gs . gettype ( ) . equals ( "buy" ) && count < numberofsell ) { buysum += gs . getprice ( ) ; count ++ ; } } return ( sellsum - buysum ) ; }
tr	6	public static string [ ] getweekdaysinmonth ( date date ) { calendar c = calendar . getinstance ( ) ; c . settime ( date ) ; c . set ( calendar . day_of_month , 1 ) ; string [ ] result = new string [ c . getactualmaximum ( calendar . week_of_month ) ] ; int day = c . get ( calendar . day_of_month ) ; int week = 0 ; int daycountinmonth = c . getactualmaximum ( calendar . day_of_month ) ; boolean end = false ; while ( ! end ) { int weekday = c . get ( calendar . day_of_week ) ; string res = null ; if ( day == daycountinmonth ) { res = "" + day ; end = true ; } else if ( weekday == 7 ) { res = "" + day ; c . add ( calendar . day_of_month , 1 ) ; } else { res = c . get ( calendar . day_of_month ) + "-" ; if ( weekday != 1 ) { c . add ( calendar . day_of_month , 7 - weekday ) ; } else if ( day + 6 < daycountinmonth ) { c . add ( calendar . day_of_month , 6 ) ; } else { c . set ( calendar . day_of_month , daycountinmonth ) ; end = true ; } res += c . get ( calendar . day_of_month ) ; c . add ( calendar . day_of_month , 1 ) ; day = c . get ( calendar . day_of_month ) ; } result [ week ++ ] = res ; } return result ; }
tr	10	public void actionperformed ( actionevent e ) { if ( e . getsource ( ) == avbrytb ) { this . setvisible ( false ) ; } if ( e . getsource ( ) == sparastangb ) { if ( inputfieldsfailed ( ) ) { return ; } string url = urlt . gettext ( ) ; switch ( type ) { case new_stock : resultlistener . createstockpost ( namnt . gettext ( ) , parseutil . parseint ( antalt . gettext ( ) ) , parseutil . parsedouble ( pricet . gettext ( ) ) , calendarutil . parsestring ( datumt . gettext ( ) ) , url , gruppt . gettext ( ) ) ; break ; case uppdate_stock : stock . setcount ( integer . parseint ( antalt . gettext ( ) ) ) ; stock . setupdateurl ( url ) ; break ; } this . setvisible ( false ) ; } }
tr	10	public point getdrawlocation ( ) { point p = this . getlocation ( ) ; int sizepx = 10 ; if ( layout == port . relative ) { } else if ( layout == port . north ) { p . y -= sizepx ; p . x -= sizepx / 2 ; } else if ( layout == port . east ) { p . y -= sizepx / 2 ; } else if ( layout == port . west ) { p . x -= sizepx ; p . y -= sizepx / 2 ; } else if ( layout == port . south ) { p . x -= sizepx / 2 ; } else if ( layout == port . top_left ) { p . y -= sizepx ; p . x -= sizepx ; } else if ( layout == port . top_right ) { p . y -= sizepx ; } else if ( layout == port . bottom_left ) { p . x -= sizepx ; } else if ( layout == port . bottom_right ) { } return p ; }
tr	3	protected document newdoc ( ) throws xmlpullparserexception { try { documentbuilderfactory domfactory = documentbuilderfactory . newinstance ( ) ; documentbuilder builder = domfactory . newdocumentbuilder ( ) ; domimplementation impl = builder . getdomimplementation ( ) ; return builder . newdocument ( ) ; } catch ( factoryconfigurationerror ex ) { throw new xmlpullparserexception ( "could not configure factory jaxp documentbuilderfactory: " + ex , null , ex ) ; } catch ( parserconfigurationexception ex ) { throw new xmlpullparserexception ( "could not configure parser jaxp documentbuilderfactory: " + ex , null , ex ) ; } }
tr	8	protected authenticationinfo dogetauthenticationinfo ( authenticationtoken authctoken ) throws authenticationexception { logger . debug ( "=========>\u8fdb\u5165\u8ba4\u8bc1\u6d41\u7a0b====>" + getclass ( ) ) ; usernamepasswordtoken token = ( usernamepasswordtoken ) authctoken ; string username = token . getusername ( ) ; if ( username == null ) { throw new accountexception ( aegirconstantswebservice . loginuser_messages_usernoempyt ) ; } loginusermodel loginuserinfo = loginuserdao . findloginuser ( username ) ; if ( loginuserinfo == null ) { throw new unknownaccountexception ( aegirconstantswebservice . loginuser_messages_nouser ) ; } int isactive = loginuserinfo . getuserlogin_isactive ( ) ; if ( isactive == 1 ) { throw new lockedaccountexception ( aegirconstantswebservice . loginuser_messages_disableaccount ) ; } return new simpleauthenticationinfo ( loginuserinfo . getuserlogin_name ( ) , loginuserinfo . getuserlogin_password ( ) , getname ( ) ) ; }
tr	6	public static boolean isprimesimple ( int n ) { if ( n < 2 ) return false ; for ( int i = 2 ; i < n ; i ++ ) { if ( n % i == 0 ) return false ; } return true ; }
tr	10	public boolean changedvendor ( ) { if ( ( originalproduct == null ) && ( changedproduct == null ) ) return false ; else if ( ( originalproduct == null ) || ( changedproduct == null ) ) return true ; else if ( ( originalproduct . getvendor ( ) == null ) && ( changedproduct . getvendor ( ) == null ) ) return false ; else if ( ( originalproduct . getvendor ( ) == null ) || ( changedproduct . getvendor ( ) == null ) ) return true ; else if ( originalproduct . getvendor ( ) . getvendorid ( ) == originalproduct . getvendor ( ) . getvendorid ( ) ) return false ; else return true ; }
tr	1	public void setleafstatisticsthresholdnanos ( final long leafstatisticsthresholdnanos ) { this . leafstatisticsthresholdnanos = leafstatisticsthresholdnanos ; }
tr	1	private void rendercall ( final nestedtimerpath root , final timerstatistics call ) throws ioexception { rendercalltimings ( call ) ; rendernodename ( root ) ; }
tr	4	private static inditextproperty loadtextproperty ( indidriver driver , string name ) { indiproperty prop ; try { prop = indiproperty . loadfromfile ( driver , name ) ; } catch ( indiexception e ) { return null ; } if ( ! ( prop instanceof inditextproperty ) ) { return null ; } inditextproperty tp = ( inditextproperty ) prop ; tp . setsaveable ( true ) ; return tp ; }
tr	5	private void play ( ) { game . printwelcome ( ) ; finished = false ; while ( ! finished ) { final double delta = system . nanotime ( ) - previoustime ; view . update ( delta ) ; previoustime = system . nanotime ( ) ; if ( game . getplayer ( ) . isdead ( ) ) { view . dispose ( ) ; break ; } try { thread . sleep ( 1 ) ; } catch ( interruptedexception e ) { } } }
tr	8	public boolean istextfieldvalid ( ) { if ( bookdetail . gettxtfieldtitle ( ) . gettext ( ) . trim ( ) . equals ( "" ) ) { return false ; } if ( bookdetail . gettxtfieldauthor ( ) . gettext ( ) . trim ( ) . equals ( "" ) ) { return false ; } if ( bookdetail . gettxtfieldpublisher ( ) . gettext ( ) . trim ( ) . equals ( "" ) ) { return false ; } return true ; }
tr	4	@ override public void handlecatchall ( string path_remainder , request request ) { if ( request . getrequesttype ( ) != request . requesttype . call ) { return ; } if ( request . geturi ( ) . getpath ( ) . equals ( kcatchallmethod2 ) ) { callmethod2all ( request ) ; } }
tr	7	public static statemachine newinstance ( string filename ) { statemachine sm = new statemachine ( ) ; sm . setname ( filename ) ; @ suppresswarnings ( "unused" ) int currentstate = 0 ; try ( bufferedreader br = new bufferedreader ( new inputstreamreader ( new fileinputstream ( filename ) ) ) ) { string line = br . readline ( ) ; while ( line != null ) { if ( ! line . startswith ( "#" ) && ! line . equals ( "" ) ) { line . trim ( ) ; int i = line . indexof ( ";" ) ; if ( i != - 1 ) { line = line . substring ( 0 , i ) ; } string [ ] tokens = line . touppercase ( ) . split ( " |\\t" ) ; sm . states . add ( sm . createstate ( tokens ) ) ; currentstate ++ ; } line = br . readline ( ) ; } } catch ( exception e ) { return null ; } return sm ; }
tr	5	static list < location > movestowards ( piece piece , location location , iterable < direction > directions ) { list < location > moves = new linkedlist < > ( ) ; for ( direction d : directions ) { location next = location . move ( d ) ; while ( piece . isavailable ( next ) ) { moves . add ( next ) ; next = next . move ( d ) ; } if ( piece . canattack ( next ) ) { moves . add ( next ) ; } } return moves ; }
tr	6	public static boolean isobstructed ( vertex test ) { if ( list == null ) return true ; list . reset ( ) ; while ( list . hasnext ( ) ) { angleinterval ai = list . getnext ( ) ; if ( ai . vertexisobstructed ( test ) ) return true ; } return false ; }
tr	8	public static void main ( string [ ] args ) { try { uimanager . setlookandfeel ( uimanager . getsystemlookandfeelclassname ( ) ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } final preferences preferences = preferences . usernodeforpackage ( eveonlinetools . class ) ; try { preferences . sync ( ) ; } catch ( backingstoreexception e ) { e . printstacktrace ( ) ; } final evemineralsframe frame = new evemineralsframe ( preferences ) ; frame . settitle ( "eve online tools" ) ; frame . setdefaultcloseoperation ( windowconstants . exit_on_close ) ; swingutilities . invokelater ( new runnable ( ) { @ override public void run ( ) { frame . buildui ( ) ; frame . setlocation ( preferences . getint ( key_frame_x , 0 ) , preferences . getint ( key_frame_y , 0 ) ) ; frame . setsize ( new dimension ( preferences . getint ( key_frame_width , 800 ) , preferences . getint ( key_frame_height , 600 ) ) ) ; frame . setvisible ( true ) ; } } ) ; frame . addwindowlistener ( new windowadapter ( ) { @ override public void windowclosing ( windowevent e ) { try { frame . savepreferences ( preferences ) ; point location = frame . getlocation ( ) ; preferences . putint ( key_frame_x , location . x ) ; preferences . putint ( key_frame_y , location . y ) ; dimension size = frame . getsize ( ) ; preferences . putint ( key_frame_width , size . width ) ; preferences . putint ( key_frame_height , size . height ) ; preferences . flush ( ) ; } catch ( backingstoreexception e1 ) { e1 . printstacktrace ( ) ; } } } ) ; }
tr	10	public figura ( final punto point , final color color , int ... filas ) { if ( filas . length > size_y ) throw new arrayindexoutofboundsexception ( "demasiadas filas" ) ; this . point = point ; this . figura = new bloque [ size_y ] [ size_x ] ; for ( int y = 0 ; y < size_y ; y ++ ) { for ( int x = 0 ; x < size_x ; x ++ ) { if ( y >= filas . length ) { this . figura [ y ] [ x ] = new bloque ( tipobloque . vacio , color . white ) ; } else { int valor = ( filas [ y ] > > x ) & 1 ; tipobloque tipo = ( valor == 1 ) ? tipobloque . figura : tipobloque . vacio ; this . figura [ y ] [ x ] = new bloque ( tipo , color ) ; } } } }
tr	5	public aabbtoaabbparameters getpointtoplaneparameters ( aabb aabbscnd , movingobject mo ) { aabb aabbfst = mo . getpredictedaabb ( ) ; vec2 expandedextent = aabbscnd . gethalfextent ( ) . addto ( aabbfst . gethalfextent ( ) ) ; vec2 expandedcenter = aabbscnd . getcenter ( ) ; vec2 centersdifference = expandedcenter . - ( aabbfst . getcenter ( ) ) ; vec2 initialcenterdifferences = expandedcenter . - ( mo . getcenter ( ) ) ; int halfextentx = aabbscnd . gethalfextent ( ) . getx ( ) ; int halfextenty = aabbscnd . gethalfextent ( ) . gety ( ) ; int mohalfextentx = mo . getaabb ( ) . gethalfextent ( ) . getx ( ) ; int mohalfextenty = mo . getaabb ( ) . gethalfextent ( ) . gety ( ) ; if ( initialcenterdifferences . getx ( ) > - halfextentx - mohalfextentx && initialcenterdifferences . getx ( ) < halfextentx + mohalfextentx && initialcenterdifferences . gety ( ) - mohalfextenty - halfextenty <= 0 && initialcenterdifferences . gety ( ) - mohalfextenty - halfextenty >= - 2 ) mo . setcanjump ( true ) ; vec2 normalplane = centersdifference . getmajoraxis ( ) . getnegationto ( ) ; vec2 minornormalplane = centersdifference . getminoraxis ( ) . getnegationto ( ) ; int distance = getdifferencefrompointtoplane ( normalplane , expandedcenter , expandedextent , aabbfst . getcenter ( ) ) ; int minordistance = getdifferencefrompointtoplane ( minornormalplane , expandedcenter , expandedextent , aabbfst . getcenter ( ) ) ; aabbtoaabbparameters positionparameters = new aabbtoaabbparameters ( distance , minordistance , normalplane , minornormalplane ) ; return positionparameters ; }
tr	6	public static void main ( string [ ] args ) { try { final int max = 100000000 ; int [ ] factorials = null ; int total = 0 ; for ( int n = 10 ; n < max ; n ++ ) { final int [ ] digits = getdigits ( n ) ; factorials = new int [ digits . length ] ; int sf = 0 ; for ( int i = 0 ; i < digits . length ; i ++ ) { final int d = digits [ i ] ; final int f = factorial ( d ) ; factorials [ i ] = f ; sf += f ; } if ( sf == n ) { total += n ; system . out . println ( n + "\\t" + arrays . tostring ( digits ) + "\\t" + arrays . tostring ( factorials ) ) ; } } system . out . println ( "# max = " + max + "; total = " + total ) ; } catch ( exception ex ) { logger . getlogger ( problem034 . class . getname ( ) ) . log ( level . severe , null , ex ) ; } }
tr	5	public static image createscratchimage ( int width , int height ) { try { image img = ( image ) trymethod ( output_comp , "createvolatileimage" , new object [ ] { new integer ( width ) , new integer ( height ) } ) ; if ( img == null ) { return output_comp . createimage ( width , height ) ; } graphicsenvironment ge = graphicsenvironment . getlocalgraphicsenvironment ( ) ; graphicsdevice gs = ge . getdefaultscreendevice ( ) ; graphicsconfiguration gc = gs . getdefaultconfiguration ( ) ; integer valid = ( integer ) trymethod ( img , "validate" , new object [ ] { gc } ) ; if ( valid . intvalue ( ) == 2 ) { return output_comp . createimage ( width , height ) ; } return img ; } catch ( java . security . accesscontrolexception e ) { return output_comp . createimage ( width , height ) ; } }
tr	4	private string leitorxml ( ) { string arquivoxml = "" ; try { file arquivo = new file ( getclass ( ) . getresource ( "/br/com/gstok/arquivos/hibernate.cfg.xml" ) . touri ( ) ) ; scanner leitor = new scanner ( arquivo ) ; leitor . usedelimiter ( "\\n" ) ; while ( leitor . hasnext ( ) ) { string arqatual = leitor . next ( ) + "\\n" ; arquivoxml += arqatual ; } } catch ( filenotfoundexception ex ) { ex . printstacktrace ( ) ; joptionpane . showmessagedialog ( this , "n\xe3o foi poss\xedvel encontar o arquivo de configura\xe7\xe3o" , "erro" , joptionpane . error_message , null ) ; } catch ( urisyntaxexception ex ) { ex . printstacktrace ( ) ; joptionpane . showmessagedialog ( this , "o caminho para o arquivo de configura\xe7\xe3o \xe9 inv\xe1lido!" , "erro" , joptionpane . error_message , null ) ; } return arquivoxml ; }
tr	3	public double getv ( int current ) { if ( current >= width ) { return 0.0 ; } else if ( current >= rampdown ) { return math . max ( ( ( double ) ( width - current ) ) / ramptime , 0.15 ) * direction ; } return ( double ) direction ; }
tr	4	private double length ( final double p0x , final double p0y , final double p1x , final double p1y , final double p2x , final double p2y , final double p3x , final double p3y , final double maxerror ) { double length = 0 ; final double s0x = ( p1x + p2x ) / 2 ; final double s0y = ( p1y + p2y ) / 2 ; final double q1x = ( p0x + p1x ) / 2 ; final double q1y = ( p0y + p1y ) / 2 ; final double q2x = ( q1x + s0x ) / 2 ; final double q2y = ( q1y + s0y ) / 2 ; final double r2x = ( p2x + p3x ) / 2 ; final double r2y = ( p2y + p3y ) / 2 ; final double r1x = ( s0x + r2x ) / 2 ; final double r1y = ( s0y + r2y ) / 2 ; final double mpx = ( q2x + r1x ) / 2 ; final double mpy = ( q2y + r1y ) / 2 ; { final double indx0 = mpx - p0x ; final double indy0 = mpy - p0y ; final double inlen = math . sqrt ( indx0 * indx0 + indy0 * indy0 ) ; final double outdx0 = q1x - p0x ; final double outdy0 = q1y - p0y ; final double outdx1 = q2x - q1x ; final double outdy1 = q2y - q1y ; final double outdx2 = mpx - q2x ; final double outdy2 = mpy - q2y ; final double outlen = ( math . sqrt ( outdx0 * outdx0 + outdy0 * outdy0 ) + math . sqrt ( outdx1 * outdx1 + outdy1 * outdy1 ) + math . sqrt ( outdx2 * outdx2 + outdy2 * outdy2 ) ) ; if ( outlen - inlen < maxerror ) length += ( inlen + outlen ) / 2 ; else length += length ( p0x , p0y , q1x , q1y , q2x , q2y , mpx , mpy , maxerror / 2 ) ; } { final double indx0 = p3x - mpx ; final double indy0 = p3y - mpy ; final double inlen = math . sqrt ( indx0 * indx0 + indy0 * indy0 ) ; final double outdx0 = r1x - mpx ; final double outdy0 = r1y - mpy ; final double outdx1 = r2x - r1x ; final double outdy1 = r2y - r1y ; final double outdx2 = p3x - r2x ; final double outdy2 = p3y - r2y ; final double outlen = ( math . sqrt ( outdx0 * outdx0 + outdy0 * outdy0 ) + math . sqrt ( outdx1 * outdx1 + outdy1 * outdy1 ) + math . sqrt ( outdx2 * outdx2 + outdy2 * outdy2 ) ) ; if ( outlen - inlen < maxerror ) length += ( inlen + outlen ) / 2 ; else length += length ( mpx , mpy , r1x , r1y , r2x , r2y , p3x , p3y , maxerror / 2 ) ; } return length ; }
tr	5	private boolean dentropueblo ( int x , int y , point rangopueblo ) { if ( x > rangopueblo . x && x < rangopueblo . y ) return true ; else if ( y > rangopueblo . x && y < rangopueblo . y ) return true ; return false ; }
va	3	@ override protected void onfileselected ( file directory ) { scanfiles ( directory ) ; writefindinfo ( findinfos ) ; if ( writer != null ) { try { writer . flush ( ) ; writer . close ( ) ; } catch ( ioexception ex ) { } } system . out . println ( "\u0413\u043e\u0442\u043e\u0432\u043e!" ) ; }
va	8	public integerregister getintregister ( string regname ) { integerregister intreg = null ; int size = intregbank . size ( ) ; try { for ( int index = 0 ; index < size ; index ++ ) { try { intreg = intregbank . get ( index ) ; } catch ( indexoutofboundsexception e1 ) { log . error ( "invalid index specified: " + index ) ; return null ; } if ( intreg != null ) { if ( intreg . getid ( ) . equals ( intregc . valueof ( regname ) ) ) { return intreg ; } } } } catch ( illegalargumentexception e ) { log . error ( "invalid int register name requested: " + regname ) ; intreg = null ; } return intreg ; }
va	8	public void cleanoutgoingtransfers ( boolean canceled , boolean lostconnection , boolean finished ) { for ( itransferprogress t : filetransferadapter . getoutgoingtransfers ( ) ) { if ( ( t . getstatus ( ) == transferstatus . canceled && canceled ) || ( t . getstatus ( ) == transferstatus . lostconnection && lostconnection ) || ( ( t . getstatus ( ) == transferstatus . finished ) && finished ) ) { t . cancel ( ) ; t . cleanup ( ) ; } } filetransferadapter . removecleanedoutgoingdownloads ( ) ; }
va	2	public static configmanager getinstance ( ) { if ( instance == null ) { instance = new configmanager ( ) ; } return instance ; }
va	1	extractioncallable ( arrayckyparser parser , list < tree < string > > sentencelist ) { this . arrayckyparser = parser ; this . sentencelist = sentencelist ; }
va	9	private void handleentities ( ) { list < entity > trash = new linkedlist < entity > ( ) ; for ( entity e : entities ) { entity other = getintersectingentity ( e ) ; if ( other != null ) { e . collide ( other ) ; } e . update ( ) ; if ( e instanceof destructible ) { destructible d = ( destructible ) e ; if ( d . isdestroyed ( ) ) { trash . add ( e ) ; if ( e instanceof explosive ) { explosive ex = ( explosive ) e ; cores . add ( ex . getcore ( ) ) ; } } } } entities . removeall ( trash ) ; }
va	7	public entity parsenextform ( boolean canend ) { sparsetoken token = nexttoken ( canend ) ; entity entity ; switch ( token . gettype ( ) ) { case sparsetoken . [ : entity = parselist ( ) ; break ; case sparsetoken . symbol : entity = parsesymbol ( token ) ; break ; case sparsetoken . integer : entity = parseinteger ( token ) ; break ; case sparsetoken . ] : entity = null ; break ; case sparsetoken . string : entity = parsestring ( token ) ; break ; case sparsetoken . reader_macro : entity = readermacro ( ) ; break ; default : throw new syntaxerrorexception ( token , "unexpected token. " + "expected a list<litcomma> symbol or string" ) ; } return entity ; }
va	4	public static void schooleducationaldetails ( bufferedreader inp ) throws exception , ioexception { @ suppresswarnings ( "unused" ) schooleducationalbean schooleducationalbean = new schooleducationalbean ( ) ; qualificationtbl qualificationtbl = new qualificationtbl ( ) ; locationtbl locationtbl = new locationtbl ( ) ; institutetbl institutetbl = new institutetbl ( ) ; schooleducationalbean . setqualificationtbl ( cachesutil . getqualificationtypetbl ( 1 ) ) ; schooleducationalbean . setlocationtbl ( cachesutil . getlocationtbl ( 1 ) ) ; schooleducationalbean . setinstitutetbl ( cachesutil . getinstitutetbl ( 1 ) ) ; system . out . println ( "enter the following details" ) ; system . out . println ( "institute name[string]" ) ; schooleducationalbean . setqminstname ( inp . readline ( ) ) ; system . out . println ( "start date[string]" ) ; schooleducationalbean . setqmstartdate ( new date ( ) ) ; system . out . println ( "end date[string]" ) ; schooleducationalbean . setqmenddate ( new date ( ) ) ; system . out . println ( "marks percentage [double]" ) ; schooleducationalbean . setqmmarkspercentage ( double . parsedouble ( inp . readline ( ) ) ) ; system . out . println ( "cgpa [string]" ) ; schooleducationalbean . setqmcgpa ( double . parsedouble ( inp . readline ( ) ) ) ; system . out . println ( "parent institute name[string]" ) ; schooleducationalbean . setqmparentinstname ( inp . readline ( ) ) ; schooleducationalcontroller schooleducationalcontroller = new schooleducationalcontroller ( schooleducationalbean ) ; simpleresponse simpleresponse = schooleducationalcontroller . createschooleducationaldetails ( ) ; system . out . println ( simpleresponse . getstatusstring ( ) ) ; if ( simpleresponse . getstatuscode ( ) == constants . success_code ) { system . out . println ( "success can go to next page congrats!!!!!!!!!!" ) ; try { professionalui . professionaldetails ( inp ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } } else if ( simpleresponse . getstatuscode ( ) == constants . failed_code ) { system . out . println ( "failed to create personaldetails some pb" ) ; } }
va	1	public boolean issetgetlang ( ) { return this . getlang != null ; }
va	6	public properties extractbyprefix ( string prefix ) { if ( prefix == null ) return null ; int l = prefix . length ( ) ; properties p = new properties ( ) ; for ( string param : sortedkeys ) { if ( param . startswith ( prefix ) ) { string subparam = param . substring ( l ) ; p . setproperty ( subparam , getproperty ( param ) ) ; } } return p ; }
va	3	private static void transplantarrayitemalias ( iterator propertyit , xmpnode childnode , xmpnode basearray ) throws xmpexception { if ( basearray . getoptions ( ) . isarrayalttext ( ) ) { if ( childnode . getoptions ( ) . gethaslanguage ( ) ) { throw new xmpexception ( "alias to x-default already has a language qualifier" , xmperror . badxmp ) ; } xmpnode langqual = new xmpnode ( xmpconst . xml_lang , xmpconst . x_default , null ) ; childnode . addqualifier ( langqual ) ; } propertyit . remove ( ) ; childnode . setname ( xmpconst . array_item_name ) ; basearray . addchild ( childnode ) ; }
va	10	private void configincludeandnoninclude ( ) { try { stringbuilder includesb = new stringbuilder ( ) ; int i = 0 ; for ( string include : fileutils . getincludeproperties ( ) ) { if ( i == 0 ) { includesb . append ( include ) ; } else { includesb . append ( seperated_symbol ) . append ( include ) ; } i ++ ; } includetextfield . settext ( includesb . tostring ( ) ) ; stringbuilder nonincludesb = new stringbuilder ( ) ; int j = 0 ; for ( string noninclude : fileutils . getnonincludeproperties ( ) ) { if ( j == 0 ) { nonincludesb . append ( noninclude ) ; } else { nonincludesb . append ( seperated_symbol ) . append ( noninclude ) ; } j ++ ; } nonincludetextfield . settext ( nonincludesb . tostring ( ) ) ; } catch ( documentexception e1 ) { uisupport . showmessage ( "include and non-include configuration error!" ) ; } }
va	9	public void mostrarventanaemergente ( int caso ) { switch ( caso ) { case 0 : joptionpane . showmessagedialog ( this , "bienvenido<litcomma> " + usuario ) ; break ; case 1 : joptionpane . showmessagedialog ( this , "el nuevo usuario se ha creado satisfactoriamente" ) ; break ; case 2 : joptionpane . showmessagedialog ( this , "el nombre de usuario y/o contrase\xf1a son erroneos" ) ; break ; case 3 : joptionpane . showmessagedialog ( this , "el nombre de usuario ya existe" ) ; break ; case 4 : joptionpane . showmessagedialog ( this , "las contrase\xf1as son diferentes" ) ; break ; case 5 : joptionpane . showmessagedialog ( this , "ingrese una contrase\xf1a" ) ; break ; case 6 : joptionpane . showmessagedialog ( this , "ingrese un nombre de usuario" ) ; break ; case 7 : joptionpane . showmessagedialog ( this , "conexion con la base de datos a fallado" ) ; break ; default : joptionpane . showmessagedialog ( this , "ha ocurrido un error desconocido" ) ; break ; } }
va	10	public boolean selectposition ( iplayer player , int i , int j ) { if ( i < 0 || i > 2 || j < 0 || j > 2 ) return false ; if ( ! isselected ( i , j ) ) { playerspositions [ i ] [ j ] = player ; return true ; } return false ; }
va	2	private void createroad ( string name , agentcontainer maincontainer , int i , aid n0 , aid n1 , int roadmode ) throws staleproxyexception { agentcontroller agc = runner . createroadagent ( name , maincontainer , new object [ ] { i , n0 , n1 , roadmode } ) ; roadagents . add ( name ) ; coordinates from = nodeagents . get ( n0 ) ; coordinates to = nodeagents . get ( n1 ) ; agc . start ( ) ; if ( map != null ) { map . addroadmarker ( name , from , to , roadmode , "ui" ) ; } }
va	2	public void setup ( ) { if ( ! set ) { set = true ; getworld ( ) . addobject ( p1healthbar , 80 , 30 ) ; getworld ( ) . addobject ( p1energybar , 88 , 57 ) ; getworld ( ) . addobject ( p1statesbar , 300 , 40 ) ; getworld ( ) . addobject ( p2healthbar , 520 , 30 ) ; getworld ( ) . addobject ( p2energybar , 528 , 57 ) ; getworld ( ) . addobject ( p2statesbar , 710 , 40 ) ; } }
va	5	public face getdirectiontostart ( ) { if ( start . getnorth ( ) != null ) { return face . southern ; } else if ( start . getwest ( ) != null ) { return face . eastern ; } else if ( start . getsouth ( ) != null ) { return face . northern ; } else if ( start . geteast ( ) != null ) { return face . western ; } return null ; }
va	5	private boolean checkforlockeddoor ( ) { for ( gamematter itm : getarea ( ) . getitems ( ) ) { if ( itm . getface ( ) == getface ( ) && itm instanceof door ) { if ( ( ( door ) itm ) . islocked ( ) ) { joptionpane . showmessagedialog ( null , "this door is locked<litcomma> try find the right key" , "locked door" , joptionpane . information_message ) ; return true ; } } } return false ; }
va	5	private boolean isfacing ( proposition prop ) { switch ( prop ) { case is_facing_north : return karel . getfacing ( ) == facing . north ; case is_facing_south : return karel . getfacing ( ) == facing . south ; case is_facing_east : return karel . getfacing ( ) == facing . east ; case is_facing_west : return karel . getfacing ( ) == facing . west ; default : throw new runtimeexception ( "for this proposition<litcomma> should not have called isfacing()." ) ; } }
va	6	private void retirercomp ( ) { tblcomp . getselectedrows ( ) ; int lstcomprows [ ] = tblcomp . getselectedrows ( ) ; string nomc ; arraylist < string > lstcompnomssup = new arraylist < > ( ) ; for ( int row : lstcomprows ) { nomc = ( string ) tblcomp . getvalueat ( row , 0 ) ; lstcompnomssup . add ( nomc ) ; } for ( string nomsup : lstcompnomssup ) { if ( m_setcomp . contains ( nomsup ) ) { m_setcomp . remove ( nomsup ) ; competence comp = comptnoyaufonctionnel . gettblcompetences ( ) . get ( nomsup ) ; m_offreenreg . retirercomp ( comp ) ; } } }
va	2	protected void propagate_lookaheads ( ) throws internal_error { for ( enumeration itm = items ( ) . all ( ) ; itm . hasmoreelements ( ) ; ) ( ( lalr_item ) itm . nextelement ( ) ) . propagate_lookaheads ( null ) ; }
va	3	private void choosecreatureaction ( ) { action action = getcreaturechoicefromlegalactions ( ) ; if ( addcreatureaction ( action ) ) { system . out . println ( creature . getcombatdisplayname ( ) + " prepares a " + action . getname ( ) ) ; if ( ! possiblecreatureactions . isempty ( ) ) { choosecreatureaction ( ) ; } } healcreature ( action ) ; }
va	8	public date getindex ( list < ? > tokens ) throws logitemparsingexception { if ( tokens == null ) { throw new illegalargumentexception ( "cannot search the index on a null list" ) ; } if ( position >= tokens . size ( ) ) { throw new logitemparsingexception ( "" , "tokens set is not big enough - " + tokens . size ( ) + " - while position is " + position ) ; } string datestring = ( string ) tokens . get ( position ) ; try { return formatter . parse ( datestring ) ; } catch ( parseexception e ) { throw new logitemparsingexception ( "" , "timestamp is not p\xe8arsable" , e ) ; } }
va	4	public void updatetaskinfo ( ) { if ( debug ) log ( "attempting to update task info for all task widgets" ) ; for ( taskwidget taskwidget : taskwidgets ) { taskwidget . updatetaskinfo ( ) ; } }
va	10	private void handleunexpectedpacket ( utptimestampedpacketdto timestampedpair ) throws ioexception { int expected = getexpectedseqnr ( ) ; int seqnr = timestampedpair . utppacket ( ) . getsequencenumber ( ) & 0xffff ; if ( skippedbuffer . isempty ( ) ) { skippedbuffer . setexpectedsequencenumber ( expected ) ; } boolean alreadyacked = expected > seqnr || seqnr - expected > packet_diff_warp ; boolean saneseqnr = expected == skippedbuffer . getexpectedsequencenumber ( ) ; if ( saneseqnr && ! alreadyacked ) { skippedbuffer . bufferpacket ( timestampedpair ) ; selectiveackheaderextension headerextension = skippedbuffer . createheaderextension ( ) ; if ( ackthispacket ( ) ) { channel . selectiveackpacket ( headerextension , gettimestampdifference ( timestampedpair ) , getleftspaceinbuffer ( ) ) ; } } else if ( ackthispacket ( ) ) { selectiveackheaderextension headerextension = skippedbuffer . createheaderextension ( ) ; channel . ackalreadyacked ( headerextension , gettimestampdifference ( timestampedpair ) , getleftspaceinbuffer ( ) ) ; } }
va	4	@ suppresswarnings ( "unchecked" ) private t newentity ( ) { for ( constructor < ? > c : typeclass . getconstructors ( ) ) { if ( c . getparametertypes ( ) . length == 0 ) { try { return typeclass . newinstance ( ) ; } catch ( exception e ) { throw new runtimeexception ( e ) ; } } } return ( t ) objenesishelper . newinstance ( typeclass ) ; }
va	9	private void parseadditionalsections ( psdinputstream stream , int endpos ) throws ioexception { while ( stream . getpos ( ) < endpos ) { string tag = stream . readstring ( 4 ) ; if ( ! tag . equals ( "8bim" ) ) { throw new ioexception ( "layer information signature error" ) ; } tag = stream . readstring ( 4 ) ; int size = stream . readint ( ) ; size = ( size + 1 ) & ~ 0x01 ; int prevpos = stream . getpos ( ) ; layeradditionalinformationparser additionalparser = additionalinformationparsers . get ( tag ) ; if ( additionalparser == null ) { additionalparser = defaultadditionalinformationparser ; } if ( additionalparser != null ) { additionalparser . parse ( stream , tag , size ) ; } stream . skipbytes ( prevpos + size - stream . getpos ( ) ) ; } }
va	7	public void endstep ( list < body > bodies , double dt ) { for ( body b : bodies ) { vector2d p = b . getposition ( ) ; double x = p . getx ( ) , y = p . gety ( ) , r = b . getradius ( ) ; if ( x - r > wall || x + r < - wall || y - r > wall || y + r < - wall ) { if ( withinwalls . contains ( b ) ) b . hide ( ) ; } else { withinwalls . add ( b ) ; b . unhide ( ) ; } } }
va	7	private abstractnode statement ( ) { abstractnode resnode = null ; if ( test ( if ) ) { resnode = ifstatement ( ) ; return resnode ; } else if ( test ( print ) ) { read ( print , "print" ) ; resnode = new printnode ( expression ( ) ) ; return resnode ; } else if ( test ( while ) ) { resnode = whilestatement ( ) ; return resnode ; } else if ( test ( repeat ) ) { resnode = repeatstatement ( ) ; return resnode ; } else if ( test ( id ) ) { if ( testlookahead ( lpar ) ) { resnode = procedurecall ( ) ; } else { resnode = assignment ( ) ; } } return resnode ; }
va	1	public string getprojectname ( ) { return projectname ; }
va	2	private void createcar ( string name , agentcontainer maincontainer , aid situated , aid destination ) throws staleproxyexception { agentcontroller agc = runner . createtransportagent ( name , maincontainer , new object [ ] { situated , destination } ) ; coordinates from = nodeagents . get ( situated ) ; coordinates to = nodeagents . get ( destination ) ; if ( map != null ) { map . addtransportmarker ( name , from , to , "ui" ) ; } transportagents . add ( name ) ; agc . start ( ) ; }
va	3	public formuladialog ( string title , string prefix , string [ ] formula , list < parameter > params , list < parameter > sysparams ) { this . settitle ( title + " dialog" ) ; this . setmodal ( true ) ; this . setmodal ( true ) ; addhelpmenu ( ) ; container window = this . getcontentpane ( ) ; window . setlayout ( new boxlayout ( window , boxlayout . y_axis ) ) ; window . add ( getparampanel ( params , sysparams ) ) ; flds = new jtextfield [ formula . length ] ; for ( int i = 0 ; i < flds . length ; i ++ ) { jpanel p = new jpanel ( ) ; flds [ i ] = new jtextfield ( 40 ) ; flds [ i ] . setfont ( new font ( font . dialog , font . bold , 16 ) ) ; if ( formula != null ) flds [ i ] . settext ( formula [ i ] ) ; p . add ( new jlabel ( prefix + ( i + 1 ) ) ) ; p . add ( new jlabel ( "=" ) ) ; p . add ( flds [ i ] ) ; window . add ( p ) ; } window . add ( getctlpanel ( ) ) ; this . setdefaultcloseoperation ( jdialog . do_nothing_on_close ) ; pack ( ) ; this . setlocationrelativeto ( null ) ; setvisible ( true ) ; }
va	4	@ override public boolean available ( ) { widgetchild wc = getchild ( ) ; int curlevel = skills . getlevel ( skills . magic ) ; return getspellbook ( ) . isopen ( ) && ( curlevel >= level || curlevel == 0 ) && ( wc == null || wc . gettextcolor ( ) == 0xffffff ) ; }
va	9	regexp parsecharclassexp ( ) throws illegalargumentexception { if ( match ( '[' ) ) { boolean negate = false ; if ( match ( '^' ) ) negate = true ; regexp e = parsecharclasses ( ) ; if ( negate ) e = makeintersection ( makeanychar ( ) , makecomplement ( e ) ) ; if ( ! match ( ']' ) ) throw new illegalargumentexception ( "expected ']' at position " + pos ) ; return e ; } else return parsesimpleexp ( ) ; }
va	3	private static void processlimits ( final criteria crit , final query query ) throws torqueexception { int limit = crit . getlimit ( ) ; int offset = crit . getoffset ( ) ; if ( offset > 0 || limit >= 0 ) { db db = torque . getdb ( crit . getdbname ( ) ) ; db . generatelimits ( query , offset , limit ) ; } }
va	10	public void addtoolbar ( ) { documentbuilderfactory factory = documentbuilderfactoryimpl . newinstance ( ) ; factory . setvalidating ( true ) ; try { documentbuilder builder = factory . newdocumentbuilder ( ) ; project . languageelements = builder . parse ( new file ( languagedir + project . language + "/" + project . language + ".xml" ) ) ; element root = project . languageelements . getdocumentelement ( ) ; jtoolbar toolbar = new jtoolbar ( ) ; nodelist icons = root . getelementsbytagname ( "icon" ) ; for ( int i = 0 ; i < icons . getlength ( ) ; ++ i ) { element node = ( element ) icons . item ( i ) ; string name = node . getattribute ( "name" ) ; image img = toolkit . getdefaulttoolkit ( ) . getimage ( node . getattribute ( "image" ) ) ; imagefilter transparency = new vxd . blacktotransparentfilter ( ) ; imageproducer producer = new filteredimagesource ( img . getsource ( ) , transparency ) ; image transparentimg = toolkit . getdefaulttoolkit ( ) . createimage ( producer ) ; image smallimg = transparentimg . getscaledinstance ( vxd . xiconsize , vxd . yiconsize , image . scale_smooth ) ; imageicon icon = new imageicon ( smallimg ) ; image dragimage = transparentimg . getscaledinstance ( vxd . xdragsize , vxd . ydragsize , image . scale_smooth ) ; try { mediatracker mt = new mediatracker ( vxd . frame ) ; mt . addimage ( smallimg , 0 ) ; mt . addimage ( dragimage , 1 ) ; mt . waitforall ( ) ; } catch ( exception e ) { ; } vxdjbutton toolbutton = new vxdjbutton ( name , icon , img , dragimage ) ; toolbutton . settooltiptext ( name ) ; toolbar . add ( toolbutton ) ; } toolbar . setlayout ( new gridlayout ( ( int ) ( icons . getlength ( ) / vxd . iconsperrow ) + 1 , vxd . iconsperrow ) ) ; icons = root . getelementsbytagname ( "connector" ) ; for ( int i = 0 ; i < icons . getlength ( ) ; ++ i ) { element node = ( element ) icons . item ( i ) ; string name = node . getattribute ( "name" ) ; image img = toolkit . getdefaulttoolkit ( ) . getimage ( node . getattribute ( "image" ) ) ; imagefilter transparency = new vxd . blacktotransparentfilter ( ) ; imageproducer producer = new filteredimagesource ( img . getsource ( ) , transparency ) ; image transparentimg = toolkit . getdefaulttoolkit ( ) . createimage ( producer ) ; image smallimg = transparentimg . getscaledinstance ( vxd . xiconsize , vxd . yiconsize , image . scale_smooth ) ; imageicon icon = new imageicon ( smallimg ) ; image dragimage = transparentimg . getscaledinstance ( vxd . xdragsize , vxd . ydragsize , image . scale_smooth ) ; try { mediatracker mt = new mediatracker ( vxd . frame ) ; mt . addimage ( smallimg , 0 ) ; mt . addimage ( dragimage , 1 ) ; mt . waitforall ( ) ; } catch ( exception e ) { ; } vxdjconnectorbutton toolbutton = new vxdjconnectorbutton ( name , icon , img , dragimage ) ; toolbutton . settooltiptext ( name ) ; toolbar . add ( toolbutton ) ; } vxd . toolbarpanel . add ( toolbar , "south" ) ; vxd . toolbarpanel . validate ( ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } }
va	8	private void leftbracketpressed ( ) { int carrotposition = getcaretposition ( ) ; string str = gettext ( ) ; int bracketcount = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str . charat ( i ) == '{' ) bracketcount ++ ; else if ( str . charat ( i ) == '}' ) bracketcount -- ; } system . out . println ( "bracket" ) ; if ( bracketcount >= 0 ) { system . out . println ( "autobracket" ) ; inserttext ( "}" , carrotposition ) ; setcaretposition ( carrotposition ) ; } }
va	6	@ override public void run ( ) { system . out . println ( "lancement de run" ) ; int rand = ( int ) math . random ( ) * ( 5 - 1 ) + 1 ; if ( interfaceediteur . tab [ laby . getx ( ) ] [ laby . gety ( ) ] . getetat ( ) . equals ( "exit" ) ) { return ; } else { switch ( tabmouvements [ rand ] ) { case "haut" : interfaceediteur . tab [ laby . getx ( ) ] [ laby . gety ( ) + 1 ] . add ( new jlabel ( new imageicon ( "./images/p-human.png" ) ) ) ; break ; case "droite" : interfaceediteur . tab [ laby . getx ( ) + 1 ] [ laby . gety ( ) ] . add ( new jlabel ( new imageicon ( "./images/p-human.png" ) ) ) ; break ; case "gauche" : interfaceediteur . tab [ laby . getx ( ) - 1 ] [ laby . gety ( ) ] . add ( new jlabel ( new imageicon ( "./images/p-human.png" ) ) ) ; break ; case "bas" : interfaceediteur . tab [ laby . getx ( ) ] [ laby . gety ( ) - 1 ] . add ( new jlabel ( new imageicon ( "./images/p-human.png" ) ) ) ; break ; default : break ; } } }
va	10	public boolean connect ( ) throws exception { if ( socket != null ) { disconnect ( ) ; } try { proxy proxy = proxy . no_proxy ; socket = new socket ( proxy ) ; socket . connect ( new inetsocketaddress ( ip , port ) ) ; writer = new bufferedwriter ( new outputstreamwriter ( socket . getoutputstream ( ) ) ) ; reader = new bufferedreader ( new inputstreamreader ( socket . getinputstream ( ) ) ) ; writer . write ( "pass " + settings . pass ) ; writer . newline ( ) ; writer . write ( "nick " + settings . nick ) ; writer . newline ( ) ; writer . write ( "user " + settings . user + " 8 * : java irc client by zaboing" ) ; writer . newline ( ) ; writer . flush ( ) ; string line = null ; while ( ( line = reader . readline ( ) ) != null ) { system . out . println ( line ) ; if ( line . indexof ( "004" ) >= 0 ) { socket . setsotimeout ( 5000 ) ; receivethread = new thread ( this ) ; receivethread . setdaemon ( true ) ; receivethread . start ( ) ; return true ; } else if ( line . indexof ( "433" ) >= 0 ) { system . out . println ( "nickname is already in use." ) ; return false ; } } return false ; } catch ( exception e ) { throw e ; } }
va	1	public void setprojectname ( string projectname ) { projectname = projectname ; }
va	6	public void writetobalance ( kunde kunde ) { if ( kunde != null ) { double fullprice = 0.00 ; string productnames = "" ; string pricelist = "" ; for ( model . product product : kunde . getproducts ( ) ) { fullprice = fullprice + product . getprice ( ) ; if ( pricelist == "" ) { pricelist = double . tostring ( product . getprice ( ) ) ; } else { pricelist = pricelist + " <litcomma> " + product . getprice ( ) ; } if ( productnames == "" ) { productnames = product . getname ( ) ; } else { productnames = productnames + " <litcomma> " + product . getname ( ) ; } } lastproducts [ 0 ] = productnames ; lastproducts [ 1 ] = pricelist ; balance . addentry ( cashpointid , fullprice , abgkunden , productnames , pricelist , waitingqueue . size ( ) ) ; } else { balance . addentry ( cashpointid , 0 , abgkunden , lastproducts [ 0 ] , lastproducts [ 1 ] , waitingqueue . size ( ) ) ; } }
va	4	public int getkerning ( int index1 , int index2 ) { if ( kernings != null ) { for ( int i = 0 ; i < kernings . length ; i ++ ) { if ( kernings [ i ] . iscorrectkerning ( index1 , index2 ) ) { return kernings [ i ] . spacing ( ) ; } } } return 0 ; }
va	2	public static lalr_state find_state ( lalr_item_set itms ) { if ( itms == null ) return null ; else return ( lalr_state ) _all . get ( itms ) ; }
va	5	public static comboboxmodel getallparameters ( ) { if ( parametermodel == null ) { checkparameterlist ( ) ; parametermodel = new defaultcomboboxmodel ( ) ; for ( string v : parameters . keyset ( ) ) { if ( v . equals ( "neighbore" ) || v . equals ( "datapoint" ) ) continue ; parametermodel . addelement ( v ) ; } } system . out . println ( parametermodel . getsize ( ) ) ; return parametermodel ; }
va	7	private id3v2commentframedata extractcommentframedata ( string id , boolean itunes ) { id3v2frameset frameset = framesets . get ( id ) ; if ( frameset != null ) { iterator < id3v2frame > iterator = frameset . getframes ( ) . iterator ( ) ; while ( iterator . hasnext ( ) ) { id3v2frame frame = ( id3v2frame ) iterator . next ( ) ; id3v2commentframedata framedata ; try { framedata = new id3v2commentframedata ( useframeunsynchronisation ( ) , frame . getdata ( ) ) ; if ( itunes && itunes_comment_description . equals ( framedata . getdescription ( ) . tostring ( ) ) ) { return framedata ; } else if ( ! itunes ) { return framedata ; } } catch ( invaliddataexception e ) { } } } return null ; }
va	1	public listingtest ( ) { storage_server = new teststorageserver ( this ) ; }
va	8	private static void argscommand ( string [ ] args ) { for ( int i = 0 ; i < args . length ; i ++ ) { switch ( args [ i ] . tolowercase ( ) ) { case "-ip" : if ( args [ i + 1 ] . trim ( ) . split ( ":" ) . length == 2 ) { networkip = args [ i + 1 ] . split ( ":" , 2 ) [ 0 ] . trim ( ) ; rmiport = integer . parseint ( args [ i + 1 ] . split ( ":" , 2 ) [ 1 ] . trim ( ) ) ; i ++ ; } else { system . out . println ( "invalid arguments for -ip" ) ; } break ; case "-tcp" : tcpport = integer . parseint ( args [ i + 1 ] . trim ( ) ) ; i ++ ; break ; case "-multicast" : if ( args [ i + 1 ] . trim ( ) . split ( ":" ) . length == 2 ) { multicastip = args [ i + 1 ] . trim ( ) . split ( ":" , 2 ) [ 0 ] ; multicastport = integer . parseint ( args [ i + 1 ] . trim ( ) . split ( ":" , 2 ) [ 1 ] ) ; i ++ ; } else { system . out . println ( "invalid arguments for -multicast" ) ; } break ; case "-help" : system . out . println ( "systemy server application - 2014" ) ; system . out . println ( "starts the server for connecting to systemy. systemy is a distributed file system for local networks." ) ; system . out . println ( "\\noptions: " ) ; system . out . println ( "\\t-ip {ip}:{port}\\t\\tthe given ip will be used for all communication from the server to the network.\\n\\t\\t\\t\\tthe ip must be the ip of the physical interface connected to the local network with systemy." ) ; system . out . println ( "\\t-tcpport {port}\\tthis feature is for future purposes." ) ; system . out . println ( "\\t-multicast {ip}:{port}\\tthis feature is for future purposes." ) ; system . exit ( 0 ) ; default : system . out . println ( "unkown option '" + args [ i ] + "'" ) ; break ; } } }
va	3	private int trpivot ( final int isa , final int isad , final int isan , final int first , final int last ) { final int middle ; int t ; t = last - first ; middle = first + t / 2 ; if ( t <= 512 ) { if ( t <= 32 ) { return trmedian3 ( isa , isad , isan , first , middle , last - 1 ) ; } t >>= 2 ; return trmedian5 ( isa , isad , isan , first , first + t , middle , last - 1 - t , last - 1 ) ; } t >>= 3 ; return trmedian3 ( isa , isad , isan , trmedian3 ( isa , isad , isan , first , first + t , first + ( t << 1 ) ) , trmedian3 ( isa , isad , isan , middle - t , middle , middle + t ) , trmedian3 ( isa , isad , isan , last - 1 - ( t << 1 ) , last - 1 - t , last - 1 ) ) ; }
va	9	public static void process ( string text ) throws exception { system . out . println ( text ) ; string [ ] args = stringutil . tokenize ( text ) ; modelcommand command = getcommand ( args [ 0 ] ) ; if ( command == null ) { logger . log ( "\\n" + "comando '" ) ; logger . log ( args [ 0 ] ) ; logger . log ( "' nao encontrado. digite 'help' para obter a lista de comandos validos." + "\\n" ) ; } else { for ( int i = 1 ; i < args . length ; i ++ ) { } string [ ] params = null ; if ( args . length > 1 ) { params = new string [ 2 ] ; } else { params = new string [ 1 ] ; } params [ 0 ] = args [ 0 ] ; if ( args . length > 1 ) { params [ 1 ] = stringutil . untokenize ( args , 1 , args . length ) ; } command . run ( params ) ; } }
va	3	private void findstring ( file file , string searchtext ) throws ioexception { bufferedreader reader = new bufferedreader ( new inputstreamreader ( new fileinputstream ( file ) , "utf-8" ) ) ; int linenumber = 0 ; string line ; while ( ( line = reader . readline ( ) ) != null ) { int pos = - 1 ; while ( ( pos = line . indexof ( searchtext , pos + 1 ) ) != - 1 ) { findinfos . add ( new findinfo ( file . getabsolutepath ( ) , linenumber , pos ) ) ; } linenumber ++ ; } reader . close ( ) ; reader = null ; }
va	10	public list < string > anagrams ( final string [ ] strs ) { final map < string , linkedlist < string > > map = new hashmap < string , linkedlist < string > > ( ) ; for ( int i = 0 ; i < strs . length ; i ++ ) { final string str = strs [ i ] ; if ( str . isempty ( ) ) { continue ; } final char [ ] c = str . tochararray ( ) ; arrays . sort ( c ) ; final string sorted = string . valueof ( c ) ; if ( map . containskey ( sorted ) ) { map . get ( sorted ) . add ( str ) ; } else { final linkedlist < string > linkedlist = new linkedlist < string > ( ) ; linkedlist . add ( str ) ; map . put ( sorted , linkedlist ) ; } } final list < string > list = new linkedlist < string > ( ) ; for ( final linkedlist < string > strings : map . values ( ) ) { list . addall ( strings ) ; } return list ; }
va	10	public static void accordian ( arraylist < stack < string > > list ) { int i ; for ( i = 0 ; i < total ; i ++ ) { if ( i >= 3 && ( list . get ( i - 3 ) . peek ( ) . charat ( 0 ) == list . get ( i ) . peek ( ) . charat ( 0 ) || list . get ( i - 3 ) . peek ( ) . charat ( 1 ) == list . get ( i ) . peek ( ) . charat ( 1 ) ) ) { list . get ( i - 3 ) . push ( list . get ( i ) . pop ( ) ) ; if ( list . get ( i ) . isempty ( ) ) { total -- ; list . remove ( i ) ; } i = i - 4 ; } else if ( i >= 1 && ( list . get ( i - 1 ) . peek ( ) . charat ( 0 ) == list . get ( i ) . peek ( ) . charat ( 0 ) || list . get ( i - 1 ) . peek ( ) . charat ( 1 ) == list . get ( i ) . peek ( ) . charat ( 1 ) ) ) { list . get ( i - 1 ) . push ( list . get ( i ) . pop ( ) ) ; if ( list . get ( i ) . isempty ( ) ) { total -- ; list . remove ( i ) ; } i = i - 2 ; } } }
va	7	@ eventhandler ( priority = eventpriority . monitor , ignorecancelled = true ) public void onentitydeath ( entitydeathevent event ) { entity dead = event . getentity ( ) ; int id = dead . getentityid ( ) ; if ( plugin . getmobstagged ( ) . containskey ( id ) ) { player killer = plugin . getserver ( ) . getplayer ( plugin . getmobstagged ( ) . get ( id ) ) ; if ( dead instanceof creature ) playerkilledcreature ( killer , ( creature ) dead ) ; if ( dead instanceof player ) { playerkilledplayer ( killer , ( player ) dead ) ; } else if ( dead instanceof livingentity ) { playerkilledlivingentity ( killer , ( livingentity ) dead ) ; } plugin . getmobstagged ( ) . remove ( id ) ; } }
va	8	protected state < c > newstate ( final string name , final arraylist < action < c > > actions , final int modifiers ) { return new state < c > ( ) { @ override public string getname ( ) { return name ; } @ override public list < action < c > > getactions ( ) { return actions ; } @ override public int getmodifier ( ) { return modifiers ; } @ override public void preaction ( c context ) { for ( action < c > action : getactions ( ) ) action . preaction ( context ) ; } @ override public void eachaction ( c context ) { for ( action < c > action : getactions ( ) ) action . eachaction ( context ) ; } @ override public void postaction ( c context ) { for ( action < c > action : getactions ( ) ) action . postaction ( context ) ; } } ; }
va	5	private void populateservers ( ) { servermap = new hashtable < string , atomserverdetails > ( ) ; atomserverdetails _atomserver = null ; string _serverid ; int _tokencount ; while ( serverfilescanner . hasnextline ( ) ) { string _serverdetails = serverfilescanner . nextline ( ) ; stringtokenizer _tokens = new stringtokenizer ( _serverdetails ) ; _atomserver = new atomserverdetails ( ) ; _tokencount = _tokens . counttokens ( ) ; switch ( _tokencount ) { case 3 : _atomserver . setserverid ( _tokens . nexttoken ( ) ) ; _atomserver . setservername ( _tokens . nexttoken ( ) ) ; _atomserver . setserverip ( _tokens . nexttoken ( ) ) ; _atomserver . setloginusername ( serverloginusername ) ; _atomserver . setloginpassword ( serverloginpassword ) ; break ; case 5 : _atomserver . setserverid ( _tokens . nexttoken ( ) ) ; _atomserver . setservername ( _tokens . nexttoken ( ) ) ; _atomserver . setserverip ( _tokens . nexttoken ( ) ) ; _atomserver . setloginusername ( _tokens . nexttoken ( ) ) ; _atomserver . setloginpassword ( _tokens . nexttoken ( ) ) ; break ; case 7 : _atomserver . setserverid ( _tokens . nexttoken ( ) ) ; _atomserver . setservername ( _tokens . nexttoken ( ) ) ; _atomserver . setserverip ( _tokens . nexttoken ( ) ) ; _atomserver . setloginusername ( _tokens . nexttoken ( ) ) ; _atomserver . setloginpassword ( _tokens . nexttoken ( ) ) ; _atomserver . setsqlloginusername ( _tokens . nexttoken ( ) ) ; _atomserver . setsqlloginpassword ( _tokens . nexttoken ( ) ) ; break ; default : _atomserver . setserverid ( _tokens . nexttoken ( ) ) ; _atomserver . setservername ( invalidserver ) ; } _serverid = _atomserver . getserverid ( ) ; servermap . put ( _serverid , _atomserver ) ; } }
va	1	public abstractpanelview getregisteredview ( ) { return registeredview ; }
va	9	public synchronized final boolean loadfromcache ( ) { main . log ( level . fine , string . format ( "reading %s from cache...%n" , url . tostring ( ) ) ) ; try { element e = getcache ( ) . getelementforpage ( url . tostring ( ) ) ; if ( null == e ) return false ; string t = e . getattributevalue ( "title" ) ; if ( t == null ) return false ; settitle ( t ) ; readcacheself ( e ) ; collection < abstractpage > newchildren = new linkedlist < > ( ) ; collection < element > l = e . getcontent ( new elementfilter ( "childref" ) ) ; for ( element el : l ) newchildren . add ( readcachechild ( el ) ) ; mergenewchildren ( new linkedlist < > ( childpages ) , newchildren ) ; main . log ( level . fine , string . format ( "\\t...finished reading %s.%n" , url . tostring ( ) ) ) ; return true ; } catch ( problemsreadingdocumentexception | nullpointerexception e ) { childpages . clear ( ) ; settitle ( null ) ; return false ; } }
va	8	private void createview ( ) { jframe frame = new jframe ( ) ; jpanel mainpanel = new jpanel ( new gridlayout ( 1 , 2 ) ) ; jpanel controlpanel = new jpanel ( ) ; frame . getcontentpane ( ) . add ( mainpanel ) ; frame . getcontentpane ( ) . add ( controlpanel , borderlayout . south ) ; drawkey draw = new drawkey ( ) ; draw . setmaximumsize ( new dimension ( 100 , 100 ) ) ; drawsmallkey smalldraw = new drawsmallkey ( ) ; drawfrequency freq = new drawfrequency ( ) ; freq . setmaximumsize ( new dimension ( 100 , 100 ) ) ; if ( specs . islarge ( ) ) { mainpanel . add ( draw ) ; } else { mainpanel . add ( smalldraw ) ; } mainpanel . add ( freq ) ; frame . setdefaultcloseoperation ( jframe . exit_on_close ) ; frame . setsize ( 800 , 500 ) ; frame . setlocation ( new point ( 200 , 200 ) ) ; frame . setvisible ( true ) ; while ( true ) { while ( true ) { currindex = new random ( ) . nextint ( 1000 ) ; if ( table . numsamples ( currindex ) > 10 ) { break ; } } refreshkey ( ) ; system . out . println ( currindex ) ; macro . sleep ( 2000 ) ; system . out . println ( ) ; } }
va	9	static void invoke ( string aclass , string amethod , class [ ] params , object [ ] args ) { try { class c = class . forname ( aclass ) ; for ( method method : c . getdeclaredmethods ( ) ) { system . err . println ( "--------->" + method . getname ( ) ) ; } method m = c . getdeclaredmethod ( amethod , params ) ; object i = c . newinstance ( ) ; object r = m . invoke ( i , args ) ; } catch ( classnotfoundexception e ) { e . printstacktrace ( ) ; } catch ( illegalaccessexception e ) { e . printstacktrace ( ) ; } catch ( illegalargumentexception e ) { e . printstacktrace ( ) ; } catch ( instantiationexception e ) { e . printstacktrace ( ) ; } catch ( nosuchmethodexception e ) { e . printstacktrace ( ) ; } catch ( securityexception e ) { e . printstacktrace ( ) ; } catch ( invocationtargetexception e ) { e . printstacktrace ( ) ; } }
va	8	private void leftparnpressed ( ) { system . out . println ( "leftparen" ) ; int carrotposition = getcaretposition ( ) ; string str = gettext ( ) ; int parencount = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str . charat ( i ) == '(' ) parencount ++ ; else if ( str . charat ( i ) == ')' ) parencount -- ; } system . out . println ( "count:" + parencount ) ; if ( parencount >= 0 ) { addtext ( ")" ) ; setcaretposition ( carrotposition ) ; } }
va	3	private void finalizeremovalwithoutchecking ( ) { try { list < user > auser = user . list ( ) ; for ( user user : auser ) { venueremovalfinalized notification = new venueremovalfinalized ( this ) ; notification . add ( user . getid ( ) , notification ) ; } this . delete ( ) ; } catch ( sqlexception e ) { e . printstacktrace ( ) ; } }
va	7	public configuracion ( ) { initcomponents ( ) ; imageicon iconlogo = new imageicon ( img . getimage ( "menu_soldados.png" ) ) ; imageicon iconlogo2 = new imageicon ( img . getimage ( "label_nombre.png" ) ) ; jlabel2 . seticon ( iconlogo ) ; jtextfield jtextfield1 = new javax . swing . jtextfield ( ) ; jtextfield1 . setvisible ( true ) ; jlabel2 . add ( jtextfield1 ) ; jtextfield1 . setsize ( 125 , 25 ) ; jtextfield1 . setlocation ( 250 , 100 ) ; jlabel nombre = new jlabel ( "nombre" ) ; nombre . seticon ( iconlogo2 ) ; jlabel2 . add ( nombre ) ; nombre . setlocation ( 50 , 85 ) ; nombre . setsize ( 200 , 52 ) ; nombre . seticontextgap ( - 140 ) ; nombre . setfont ( new font ( "arial black" , 0 , 15 ) ) ; nombre . setforeground ( color . white ) ; jtextfield jtextfield2 = new javax . swing . jtextfield ( ) ; jtextfield2 . setvisible ( true ) ; jlabel2 . add ( jtextfield2 ) ; jtextfield2 . setsize ( 125 , 25 ) ; jtextfield2 . setlocation ( 250 , 150 ) ; jlabel imagen1 = new jlabel ( "imagen 1" ) ; imagen1 . seticon ( iconlogo2 ) ; jlabel2 . add ( imagen1 ) ; imagen1 . setlocation ( 50 , 140 ) ; imagen1 . setsize ( 200 , 52 ) ; imagen1 . seticontextgap ( - 140 ) ; imagen1 . setfont ( new font ( "arial black" , 0 , 15 ) ) ; imagen1 . setforeground ( color . white ) ; jtextfield jtextfield3 = new javax . swing . jtextfield ( ) ; jtextfield3 . setvisible ( true ) ; jlabel2 . add ( jtextfield3 ) ; jtextfield3 . setsize ( 125 , 25 ) ; jtextfield3 . setlocation ( 250 , 205 ) ; jlabel imagen2 = new jlabel ( "imagen 2" ) ; imagen2 . seticon ( iconlogo2 ) ; jlabel2 . add ( imagen2 ) ; imagen2 . setlocation ( 50 , 195 ) ; imagen2 . setsize ( 200 , 52 ) ; imagen2 . seticontextgap ( - 140 ) ; imagen2 . setfont ( new font ( "arial black" , 0 , 15 ) ) ; imagen2 . setforeground ( color . white ) ; jtextfield jtextfield4 = new javax . swing . jtextfield ( ) ; jtextfield4 . setvisible ( true ) ; jlabel2 . add ( jtextfield4 ) ; jtextfield4 . setsize ( 125 , 25 ) ; jtextfield4 . setlocation ( 250 , 260 ) ; jlabel costo = new jlabel ( "costo" ) ; costo . seticon ( iconlogo2 ) ; jlabel2 . add ( costo ) ; costo . setlocation ( 50 , 250 ) ; costo . setsize ( 200 , 52 ) ; costo . seticontextgap ( - 140 ) ; costo . setfont ( new font ( "arial black" , 0 , 15 ) ) ; costo . setforeground ( color . white ) ; jtextfield jtextfield5 = new javax . swing . jtextfield ( ) ; jtextfield5 . setvisible ( true ) ; jlabel2 . add ( jtextfield5 ) ; jtextfield5 . setsize ( 125 , 25 ) ; jtextfield5 . setlocation ( 250 , 320 ) ; jlabel campos = new jlabel ( "campos" ) ; campos . seticon ( iconlogo2 ) ; jlabel2 . add ( campos ) ; campos . setlocation ( 50 , 305 ) ; campos . setsize ( 200 , 52 ) ; campos . seticontextgap ( - 140 ) ; campos . setfont ( new font ( "arial black" , 0 , 15 ) ) ; campos . setforeground ( color . white ) ; jtextfield jtextfield6 = new javax . swing . jtextfield ( ) ; jtextfield6 . setvisible ( true ) ; jlabel2 . add ( jtextfield6 ) ; jtextfield6 . setsize ( 125 , 25 ) ; jtextfield6 . setlocation ( 250 , 370 ) ; jlabel nivel = new jlabel ( "nivel" ) ; nivel . seticon ( iconlogo2 ) ; jlabel2 . add ( nivel ) ; nivel . setlocation ( 50 , 360 ) ; nivel . setsize ( 200 , 52 ) ; nivel . seticontextgap ( - 140 ) ; nivel . setfont ( new font ( "arial black" , 0 , 15 ) ) ; nivel . setforeground ( color . white ) ; jtextfield jtextfield7 = new javax . swing . jtextfield ( ) ; jtextfield7 . setvisible ( true ) ; jlabel2 . add ( jtextfield7 ) ; jtextfield7 . setsize ( 125 , 25 ) ; jtextfield7 . setlocation ( 250 , 430 ) ; jlabel da\xf1o = new jlabel ( "da\xf1o" ) ; da\xf1o . seticon ( iconlogo2 ) ; jlabel2 . add ( da\xf1o ) ; da\xf1o . setlocation ( 50 , 415 ) ; da\xf1o . setsize ( 200 , 52 ) ; da\xf1o . seticontextgap ( - 140 ) ; da\xf1o . setfont ( new font ( "arial black" , 0 , 15 ) ) ; da\xf1o . setforeground ( color . white ) ; jtextfield jtextfield8 = new javax . swing . jtextfield ( ) ; jtextfield8 . setvisible ( true ) ; jlabel2 . add ( jtextfield8 ) ; jtextfield8 . setsize ( 125 , 25 ) ; jtextfield8 . setlocation ( 250 , 480 ) ; jlabel vida = new jlabel ( "vida" ) ; vida . seticon ( iconlogo2 ) ; jlabel2 . add ( vida ) ; vida . setlocation ( 50 , 470 ) ; vida . setsize ( 200 , 52 ) ; vida . seticontextgap ( - 140 ) ; vida . setfont ( new font ( "arial black" , 0 , 15 ) ) ; vida . setforeground ( color . white ) ; jtextfield jtextfield9 = new javax . swing . jtextfield ( ) ; jtextfield9 . setvisible ( true ) ; jlabel2 . add ( jtextfield9 ) ; jtextfield9 . setsize ( 125 , 25 ) ; jtextfield9 . setlocation ( 600 , 100 ) ; jlabel alcance = new jlabel ( "alcance" ) ; alcance . seticon ( iconlogo2 ) ; jlabel2 . add ( alcance ) ; alcance . setlocation ( 400 , 85 ) ; alcance . setsize ( 200 , 52 ) ; alcance . seticontextgap ( - 140 ) ; alcance . setfont ( new font ( "arial black" , 0 , 15 ) ) ; alcance . setforeground ( color . white ) ; jtextfield jtextfield10 = new javax . swing . jtextfield ( ) ; jtextfield10 . setvisible ( true ) ; jlabel2 . add ( jtextfield10 ) ; jtextfield10 . setsize ( 125 , 25 ) ; jtextfield10 . setlocation ( 600 , 150 ) ; jlabel guardado = new jlabel ( "guardado" ) ; guardado . seticon ( iconlogo2 ) ; jlabel2 . add ( guardado ) ; guardado . setlocation ( 400 , 140 ) ; guardado . setsize ( 200 , 52 ) ; guardado . seticontextgap ( - 140 ) ; guardado . setfont ( new font ( "arial black" , 0 , 15 ) ) ; guardado . setforeground ( color . white ) ; jtextfield jtextfield11 = new javax . swing . jtextfield ( ) ; jtextfield11 . setvisible ( true ) ; jlabel2 . add ( jtextfield11 ) ; jtextfield11 . setsize ( 125 , 25 ) ; jtextfield11 . setlocation ( 600 , 200 ) ; jlabel golpes = new jlabel ( "golpes" ) ; golpes . seticon ( iconlogo2 ) ; jlabel2 . add ( golpes ) ; golpes . setlocation ( 400 , 195 ) ; golpes . setsize ( 200 , 52 ) ; golpes . seticontextgap ( - 140 ) ; golpes . setfont ( new font ( "arial black" , 0 , 15 ) ) ; golpes . setforeground ( color . white ) ; actionlistener bot = new actionlistener ( ) { @ override public void actionperformed ( actionevent e ) { guerrer = e . getactioncommand ( ) ; } } ; jradiobutton c_alcancebutton = new jradiobutton ( "corto alcance" ) ; c_alcancebutton . setforeground ( color . white ) ; jlabel2 . add ( c_alcancebutton ) ; c_alcancebutton . setlocation ( 500 , 260 ) ; c_alcancebutton . setsize ( 200 , 20 ) ; c_alcancebutton . setactioncommand ( "corto" ) ; c_alcancebutton . addactionlistener ( bot ) ; jradiobutton m_alcancebutton = new jradiobutton ( "medio alcance" ) ; m_alcancebutton . setforeground ( color . white ) ; jlabel2 . add ( m_alcancebutton ) ; m_alcancebutton . setlocation ( 500 , 280 ) ; m_alcancebutton . setsize ( 200 , 20 ) ; m_alcancebutton . setactioncommand ( "medio" ) ; m_alcancebutton . addactionlistener ( bot ) ; jradiobutton bestiabutton = new jradiobutton ( "bestia" ) ; bestiabutton . setforeground ( color . white ) ; jlabel2 . add ( bestiabutton ) ; bestiabutton . setlocation ( 500 , 300 ) ; bestiabutton . setsize ( 200 , 20 ) ; bestiabutton . setactioncommand ( "bestia" ) ; bestiabutton . addactionlistener ( bot ) ; jradiobutton heroebutton = new jradiobutton ( "heroe" ) ; heroebutton . setforeground ( color . white ) ; jlabel2 . add ( heroebutton ) ; heroebutton . setlocation ( 500 , 320 ) ; heroebutton . setsize ( 200 , 20 ) ; heroebutton . setactioncommand ( "heroe" ) ; heroebutton . addactionlistener ( bot ) ; jradiobutton aereobutton = new jradiobutton ( "aereo" ) ; aereobutton . setforeground ( color . white ) ; jlabel2 . add ( aereobutton ) ; aereobutton . setlocation ( 500 , 340 ) ; aereobutton . setsize ( 200 , 20 ) ; aereobutton . setactioncommand ( "aereo" ) ; aereobutton . addactionlistener ( bot ) ; buttongroup group = new buttongroup ( ) ; group . add ( c_alcancebutton ) ; group . add ( m_alcancebutton ) ; group . add ( bestiabutton ) ; group . add ( heroebutton ) ; group . add ( aereobutton ) ; jbutton but1 = new jbutton ( ) ; jlabel2 . add ( but1 ) ; but1 . setsize ( 200 , 52 ) ; but1 . seticon ( iconlogo2 ) ; but1 . setlocation ( 600 , 540 ) ; but1 . settext ( "salir" ) ; but1 . setvisible ( true ) ; but1 . setopaque ( false ) ; but1 . setcontentareafilled ( false ) ; but1 . setborderpainted ( false ) ; but1 . seticontextgap ( - 100 ) ; but1 . setfont ( new font ( "arial black" , 0 , 15 ) ) ; but1 . setforeground ( color . white ) ; but1 . addactionlistener ( new java . awt . event . actionlistener ( ) { @ override public void actionperformed ( java . awt . event . actionevent evt ) { new menu ( ) . setvisible ( true ) ; x . dispose ( ) ; } } ) ; jbutton but2 = new jbutton ( ) ; jlabel2 . add ( but2 ) ; but2 . setsize ( 200 , 52 ) ; but2 . seticon ( iconlogo2 ) ; but2 . setlocation ( 400 , 540 ) ; but2 . settext ( "guardar" ) ; but2 . setvisible ( true ) ; but2 . seticontextgap ( - 120 ) ; but2 . setopaque ( false ) ; but2 . setcontentareafilled ( false ) ; but2 . setborderpainted ( false ) ; but2 . setfont ( new font ( "arial black" , 0 , 15 ) ) ; but2 . setforeground ( color . white ) ; but2 . addactionlistener ( new java . awt . event . actionlistener ( ) { @ override public void actionperformed ( java . awt . event . actionevent evt ) { juego juego = new juego ( ) ; estadojuego estado = ( estadojuego ) manejo_de_juegos . leerobjeto ( jtextfield10 . gettext ( ) ) ; juego . setgold ( estado . getoro ( ) ) ; juego . setnivel ( estado . getnivel ( ) ) ; juego . setnombre ( estado . getnombre ( ) ) ; juego . setespacioguerreros ( estado . getespacioguerreros ( ) ) ; juego . setsoldados ( estado . getaereo ( ) , estado . getbestias ( ) , estado . getcontacto ( ) , estado . getheroe ( ) , estado . getmedioalcance ( ) , estado . gettropas ( ) ) ; if ( estado == null ) { joptionpane . showmessagedialog ( x , "el nombre no existe." ) ; } else { system . out . println ( guerrer ) ; if ( guerrer == "corto" ) { juego . getcontacto ( ) . add ( new guerrerocontacto ( integer . parseint ( jtextfield8 . gettext ( ) ) , jtextfield1 . gettext ( ) , jtextfield2 . gettext ( ) , integer . parseint ( jtextfield5 . gettext ( ) ) , integer . parseint ( jtextfield9 . gettext ( ) ) , integer . parseint ( jtextfield11 . gettext ( ) ) , integer . parseint ( jtextfield4 . gettext ( ) ) , integer . parseint ( jtextfield6 . gettext ( ) ) , integer . parseint ( jtextfield7 . gettext ( ) ) , jtextfield3 . gettext ( ) ) ) ; juego . gettropas ( ) . add ( 0 ) ; new menu ( ) . setvisible ( true ) ; x . dispose ( ) ; } else if ( guerrer == "medio" ) { juego . getmedioalcance ( ) . add ( new guerreromedioalcance ( integer . parseint ( jtextfield8 . gettext ( ) ) , jtextfield1 . gettext ( ) , jtextfield2 . gettext ( ) , integer . parseint ( jtextfield5 . gettext ( ) ) , integer . parseint ( jtextfield9 . gettext ( ) ) , integer . parseint ( jtextfield11 . gettext ( ) ) , integer . parseint ( jtextfield4 . gettext ( ) ) , integer . parseint ( jtextfield6 . gettext ( ) ) , integer . parseint ( jtextfield7 . gettext ( ) ) , jtextfield3 . gettext ( ) ) ) ; juego . gettropas ( ) . add ( 0 ) ; new menu ( ) . setvisible ( true ) ; x . dispose ( ) ; } else if ( guerrer == "heroe" ) { juego . getheroe ( ) . add ( new heroes ( integer . parseint ( jtextfield8 . gettext ( ) ) , jtextfield1 . gettext ( ) , jtextfield2 . gettext ( ) , integer . parseint ( jtextfield5 . gettext ( ) ) , integer . parseint ( jtextfield9 . gettext ( ) ) , integer . parseint ( jtextfield11 . gettext ( ) ) , integer . parseint ( jtextfield4 . gettext ( ) ) , integer . parseint ( jtextfield6 . gettext ( ) ) , integer . parseint ( jtextfield7 . gettext ( ) ) , jtextfield3 . gettext ( ) ) ) ; juego . gettropas ( ) . add ( 0 ) ; new menu ( ) . setvisible ( true ) ; x . dispose ( ) ; } else if ( guerrer == "aereo" ) { juego . getaereo ( ) . add ( new guerreroaereo ( integer . parseint ( jtextfield8 . gettext ( ) ) , jtextfield1 . gettext ( ) , jtextfield2 . gettext ( ) , integer . parseint ( jtextfield5 . gettext ( ) ) , integer . parseint ( jtextfield9 . gettext ( ) ) , integer . parseint ( jtextfield11 . gettext ( ) ) , integer . parseint ( jtextfield4 . gettext ( ) ) , integer . parseint ( jtextfield6 . gettext ( ) ) , integer . parseint ( jtextfield7 . gettext ( ) ) , jtextfield3 . gettext ( ) ) ) ; juego . gettropas ( ) . add ( 0 ) ; new menu ( ) . setvisible ( true ) ; x . dispose ( ) ; } else if ( guerrer == "bestia" ) { juego . getbestias ( ) . add ( new grandesbestias ( integer . parseint ( jtextfield8 . gettext ( ) ) , jtextfield1 . gettext ( ) , jtextfield2 . gettext ( ) , integer . parseint ( jtextfield5 . gettext ( ) ) , integer . parseint ( jtextfield9 . gettext ( ) ) , integer . parseint ( jtextfield11 . gettext ( ) ) , integer . parseint ( jtextfield4 . gettext ( ) ) , integer . parseint ( jtextfield6 . gettext ( ) ) , integer . parseint ( jtextfield7 . gettext ( ) ) , jtextfield3 . gettext ( ) ) ) ; juego . gettropas ( ) . add ( 0 ) ; new menu ( ) . setvisible ( true ) ; x . dispose ( ) ; } estado . setsoldados ( juego . getaereo ( ) , juego . getbestias ( ) , juego . getcontacto ( ) , juego . getheroe ( ) , juego . getmedioalcance ( ) , juego . gettropas ( ) ) ; manejo_de_juegos . grabarobjeto ( jtextfield10 . gettext ( ) , estado ) ; } } } ) ; }
va	1	public void removeview ( ) { registeredview = null ; }
va	3	private list < action > cloneactions ( list < action > actions ) { list < action > clones = new arraylist < action > ( ) ; for ( action action : actions ) { try { clones . add ( ( action ) beanutils . clonebean ( action ) ) ; } catch ( illegalaccessexception | instantiationexception | invocationtargetexception | nosuchmethodexception e ) { e . printstacktrace ( ) ; } } return clones ; }
va	10	public void move ( ) { for ( ant ant : ants ) { double movex = ( rand . nextdouble ( ) * aco . maxmove * 2 - aco . maxmove ) ; double movey = ( rand . nextdouble ( ) * aco . maxmove * 2 - aco . maxmove ) ; double newx = ant . getx ( ) + movex ; if ( newx < 0 || newx > aco . xspace ) { movex = - movex ; } double newy = ant . gety ( ) + movey ; if ( newy < 0 || newy > aco . yspace ) { movey = - movey ; } ant . move ( movex , movey ) ; } }
va	1	@ test public void perform ( ) { checkarguments ( ) ; checkdirectorylisting ( new path ( "/" ) , new string [ ] { "file" , "directory" } , new boolean [ ] { false , true } ) ; checkdirectorylisting ( new path ( "/directory" ) , new string [ ] { "file" , "another_file" } , new boolean [ ] { false , false } ) ; }
va	8	private static preparedstatement setpreparedstatementargument ( preparedstatement stat , commandargument arg , int spot ) throws numberformatexception , sqlexception { if ( arg . gettype ( ) . equals ( "int" ) ) { stat . setint ( spot , integer . parseint ( arg . getvalue ( ) . tostring ( ) ) ) ; } else if ( arg . gettype ( ) . equals ( "string" ) ) { if ( arg . getvalue ( ) == null ) { stat . setstring ( spot , null ) ; } else { stat . setstring ( spot , arg . getvalue ( ) . tostring ( ) ) ; } } else if ( arg . gettype ( ) . equals ( "float" ) ) { stat . setfloat ( spot , float . parsefloat ( arg . getvalue ( ) . tostring ( ) ) ) ; } else if ( arg . gettype ( ) . equals ( "date" ) ) { if ( arg . getvalue ( ) == null ) { stat . setdate ( spot , null ) ; } else { java . util . date d = null ; try { d = format . parse ( arg . getvalue ( ) . tostring ( ) ) ; } catch ( parseexception e ) { e . printstacktrace ( ) ; } java . sql . date d2 = new java . sql . date ( d . gettime ( ) ) ; stat . setdate ( spot , d2 ) ; } } else system . out . println ( "unknown type" ) ; return stat ; }
va	8	private void initialize ( header header ) throws decoderexception { float scalefactor = 32700.0f ; int mode = header . mode ( ) ; int layer = header . layer ( ) ; int channels = mode == header . single_channel ? 1 : 2 ; if ( output == null ) output = new samplebuffer ( header . frequency ( ) , channels ) ; float [ ] factors = equalizer . getbandfactors ( ) ; filter1 = new synthesisfilter ( 0 , scalefactor , factors ) ; if ( channels == 2 ) filter2 = new synthesisfilter ( 1 , scalefactor , factors ) ; outputchannels = channels ; outputfrequency = header . frequency ( ) ; initialized = true ; }
va	8	private void movetonextreference ( ) { if ( this . reference != null ) { this . reference = this . reference . getnext ( ) ; } while ( this . reference == null && this . references != null ) { if ( this . referenceindex >= this . references . length ) { movetonextsegment ( ) ; this . referenceindex = 0 ; } else { this . reference = this . references [ this . referenceindex ] ; this . referenceindex ++ ; } } }
va	1	public editorview ( string name , int maxx , int maxy , editorlistener mouselistener , set < string > items , set < string > monsters ) { gamepanel = new jpanel ( ) ; mainframe = new jframe ( name ) ; gridlayout = new gridlayout ( 1 , 2 ) ; borderlayout = new borderlayout ( ) ; gamepanel . setlayout ( gridlayout ) ; mainframe . getcontentpane ( ) . setlayout ( borderlayout ) ; mainframe . add ( gamepanel , borderlayout . center ) ; this . maxx = maxx ; this . maxy = maxy ; x = 0 ; y = 0 ; map = new editormap ( "map" , maxx , maxy , mouselistener ) ; mainframe . setsize ( 1505 , 600 ) ; mainframe . setresizable ( false ) ; currentroom = null ; this . items = items ; this . monsters = monsters ; toolspanel = new editortoolspanel ( ) ; roomsarray = new string [ maxx ] [ maxy ] ; rooms = new hashmap < string , firstpersonroom > ( ) ; player = new player ( null , 0 , 0 ) ; }
va	5	public compiledemployeedata genemployeedatamap ( arraylist < timerecord > employeetimerecordlist ) { compiledemployeedata compiledemployeedata = new compiledemployeedata ( ) ; timeinoutdata inoutdata ; for ( timerecord tr : employeetimerecordlist ) { if ( ! compiledemployeedata . containskey ( tr . getdate ( ) ) ) { inoutdata = new timeinoutdata ( ) ; inoutdata . setin ( tr ) ; inoutdata . setout ( tr . copy ( ) ) ; compiledemployeedata . put ( tr . getdate ( ) , inoutdata ) ; } else { inoutdata = compiledemployeedata . get ( tr . getdate ( ) ) ; if ( inoutdata . getin ( ) . islaterthan ( tr ) ) { inoutdata . setin ( tr ) ; } else if ( inoutdata . getout ( ) . isearlierthan ( tr ) ) { inoutdata . setout ( tr ) ; } } } compiledemployeedata = enforcetimeinceiling ( compiledemployeedata ) ; return compiledemployeedata ; }
va	2	private void definireventos ( ) { pfsenha . addfocuslistener ( new focusadapter ( ) { @ override public void focuslost ( focusevent e ) { tamanhosenha ( pfsenha . getpassword ( ) ) ; } } ) ; btcancelar . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent e ) { dispose ( ) ; } } ) ; btlimpar . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent e ) { limparcampos ( ) ; } } ) ; btsalvar . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent e ) { desabilitarcampos ( ) ; tamanhosenha ( pfsenha . getpassword ( ) ) ; if ( isvalido ( ) ) { configurarpersistencia ( ) ; } else { habilitarcampos ( ) ; } } } ) ; }
va	10	public void startsync ( ) throws distributecommonexception { status = status . starting ; if ( channel == null ) { if ( channelfactory == null ) { executor executor = executors . newfixedthreadpool ( 6 ) ; channelfactory = new nioclientsocketchannelfactory ( executor , executor ) ; } clientbootstrap clientbootstrap = new clientbootstrap ( channelfactory ) ; clientbootstrap . setpipelinefactory ( new nettyclientchannelpiplefactory ( this ) ) ; channelfuture future = clientbootstrap . connect ( new inetsocketaddress ( addr , port ) ) ; final countdownlatch countdownlatch = new countdownlatch ( 1 ) ; future . addlistener ( new channelfuturelistener ( ) { @ override public void operationcomplete ( channelfuture f ) throws exception { if ( ! f . issuccess ( ) ) { status = status . stopped ; throw new netexception ( f . getcause ( ) , "\u8fde\u63a5[" + addr + ":" + port + "]\u5931\u8d25" ) ; } else { channel = f . getchannel ( ) ; system . out . println ( "\u8fde\u63a5\u6210\u529f" ) ; } countdownlatch . countdown ( ) ; } } ) ; try { countdownlatch . await ( 10 * 1000 , timeunit . milliseconds ) ; } catch ( interruptedexception e ) { status = status . stopped ; throw new distributecommonexception ( e ) ; } } else if ( ! channel . isconnected ( ) ) { status = status . stopped ; throw new distributecommonexception ( "\u65e0\u6cd5\u542f\u52a8\u5173\u95ed\u7684\u8fde\u63a5" ) ; } status = status . running ; }
va	10	private void displayvalidationerrordialog ( boolean creationattempted , list < invalid > errors ) { if ( ! errors . isempty ( ) ) { jpanel content = new jpanel ( new borderlayout ( 0 , 8 ) ) ; jlabel label = new jlabel ( ( creationattempted ? "your game could not be created due to the following " : "your game has the following " ) + errors . size ( ) + " " + ( errors . size ( ) == 1 ? "error" : "errors" ) + ":" ) ; content . add ( label , borderlayout . north ) ; defaulttablemodel model = new defaulttablemodel ( errors . size ( ) , 2 ) ; model . setcolumnidentifiers ( new string [ ] { "aspect" , "message" } ) ; jtable table = new jtable ( model ) ; for ( int i = 0 ; i < errors . size ( ) ; i ++ ) { invalid ve = errors . get ( i ) ; model . setvalueat ( ve . aspect , i , 0 ) ; model . setvalueat ( ve . message , i , 1 ) ; } table . setenabled ( false ) ; table . getcolumn ( "aspect" ) . setpreferredwidth ( 100 ) ; table . getcolumn ( "aspect" ) . setmaxwidth ( 100 ) ; dimension oldscrollsize = table . getpreferredscrollableviewportsize ( ) ; oldscrollsize . height = math . min ( table . getpreferredsize ( ) . height , oldscrollsize . height ) ; table . setpreferredscrollableviewportsize ( oldscrollsize ) ; content . add ( new jscrollpane ( table ) , borderlayout . center ) ; joptionpane . showmessagedialog ( this , content , "validation failed" , joptionpane . error_message ) ; } else { if ( ! creationattempted ) { joptionpane . showmessagedialog ( this , "the validation completed successfully. your game has no errors." , "validation successful" , joptionpane . information_message ) ; } } }
va	1	public void addmodel ( abstractmodel model ) { registeredmodel = model ; model . addpropertychangelistener ( this ) ; }
va	4	public void readourgrid ( gamestate state ) { for ( int x = 0 ; x < 3 ; ++ x ) { for ( int y = 0 ; y < 5 ; ++ y ) { point criticalpoint = celloccupiedcriticalpixels [ x ] [ y ] ; if ( iscelloccupied ( state . getscreen ( ) . getrgb ( criticalpoint . x , criticalpoint . y ) ) ) { state . getourgrid ( ) [ x ] [ y ] = new unit ( 1 , 2 , 1 , x , y ) ; } else { state . getourgrid ( ) [ x ] [ y ] = null ; } } } }
va	6	public mode modeforstring ( string mode ) { switch ( mode . tolowercase ( ) ) { case "naive" : return new mode ( ) ; case "cracker" : return new crackermode ( ) ; case "merge" : return new pushdownmergemode ( ) ; case "simplemerge" : return new mergemode ( ) ; case "enhancedmerge" : return new enhancedmergemode ( ) ; default : log . fatal ( "unknown mode '{}'" , mode ) ; system . exit ( - 1 ) ; return null ; } }
va	5	@ override public void leerdesderesultset ( resultset rs ) { try { carrera . setoid ( rs . getint ( "oid" ) ) ; carrera . setnombre ( rs . getstring ( "nombre" ) ) ; carrera . setnumero ( rs . getint ( "numero" ) ) ; carrera . setfecha ( rs . getdate ( "fecha" ) ) ; carrera . setestado ( carrera . getestado ( rs . getint ( "estado" ) ) ) ; pcaballoencarrera pcc = new pcaballoencarrera ( carrera ) ; arraylist < caballoencarrera > caballos = manejadorbd . getinstancia ( ) . obtener ( pcc ) ; for ( caballoencarrera c : caballos ) { carrera . agregarcaballo ( c ) ; c . setcarrera ( carrera ) ; if ( rs . getint ( "oidganador" ) == c . getoid ( ) ) { carrera . setganadorsimple ( c ) ; c . setganador ( true ) ; } } phipodromo phip = new phipodromo ( new hipodromo ( ) ) ; phip . setoid ( rs . getint ( "oidhipodromo" ) ) ; hipodromo h = ( hipodromo ) manejadorbd . getinstancia ( ) . obtener ( phip ) . get ( 0 ) ; h = fachada . getinstancia ( ) . buscarhipodromo ( h . getnombre ( ) ) ; h . agregarcarrera ( carrera ) ; } catch ( sqlexception ex ) { system . out . println ( ex . getmessage ( ) ) ; } catch ( exception ex ) { system . out . println ( ex . getmessage ( ) ) ; } }
va	7	@ override public boolean equals ( object obj ) { boolean equal = false ; if ( obj != null && obj instanceof subjectid ) { subjectid right = ( subjectid ) obj ; if ( right . contributor != null && right . value != null && this . contributor != null && this . value != null ) { equal = this . contributor . equals ( right . contributor ) && this . value . equals ( right . value ) ; } } return equal ; }
va	5	public void actionperformed ( actionevent e ) { repaint ( ) ; if ( ( value >= previousvalue && movingposition == diameter * previousvalue ) || ( value < previousvalue && movingposition == translation + diameter * value ) ) timer . stop ( ) ; }
va	7	@ suppresswarnings ( { "unchecked" , "rawtypes" } ) public static fieldgrammar < ? > get ( field field ) throws securityexception , nosuchmethodexception { if ( charsequence . class . isassignablefrom ( field . gettype ( ) ) ) { regex annotation_regex = field . getannotation ( regex . class ) ; if ( null != annotation_regex ) { if ( annotation_regex . capture ( ) ) { final regexcapturegrammar innergrammar = new regexcapturegrammar ( annotation_regex . value ( ) ) ; return new fieldgrammar < charsequence > ( field , new regexcaptureadapter ( innergrammar ) ) ; } else { final regexgrammar innergrammar = new regexgrammar ( annotation_regex . value ( ) ) ; return new fieldgrammar < charsequence > ( field , innergrammar ) ; } } else { throw new runtimeexception ( "cannot form a grammar from " + field ) ; } } else if ( map . class . isassignablefrom ( field . gettype ( ) ) ) { entries annotation_entries = field . getannotation ( entries . class ) ; if ( null != annotation_entries ) { return new fieldgrammar < map < charsequence , charsequence > > ( field , new mapentriesadapter ( annotation_entries . value ( ) ) ) ; } else { throw new runtimeexception ( "cannot form a grammar from " + field ) ; } } else if ( list . class . isassignablefrom ( field . gettype ( ) ) ) { parameterizedtype generictype = ( parameterizedtype ) field . getgenerictype ( ) ; class type = ( class ) generictype . getactualtypearguments ( ) [ 0 ] ; return new fieldgrammar ( field , new listrepeatgrammar ( grammarbean . get ( type ) , 0 , - 1 ) ) ; } else { throw new runtimeexception ( "cannot form a grammar from " + field ) ; } }
va	7	public static void main ( string [ ] args ) { system . out . println ( "please add number of month" ) ; scanner sc = new scanner ( system . in ) ; int month = sc . nextint ( ) ; switch ( month ) { case 1 : case 2 : case 3 : system . out . println ( "this is the first quarter of the year" ) ; break ; case 4 : system . out . println ( "april" ) ; break ; case 5 : system . out . println ( "may" ) ; break ; case 6 : system . out . println ( "june" ) ; break ; default : system . out . println ( "not supposed to be here!" ) ; break ; } }
va	4	public void addtab ( int type ) { tab tab = tabbuilder . build ( type , this ) ; if ( tab == null ) { return ; } tab . setonclosed ( new eventhandler < event > ( ) { @ override public void handle ( event t ) { if ( tabpane . gettabs ( ) . size ( ) == 0 ) { guiutil . switchpane ( resultpane , welcomepane ) ; } } } ) ; tabpane . gettabs ( ) . add ( tab ) ; tabpane . getselectionmodel ( ) . selectlast ( ) ; }
va	1	public abstractmodel getregisteredmodel ( ) { return registeredmodel ; }
va	5	@ override public dimensions getdimensions ( ) { if ( getid ( ) == 1 ) { return new dimensions ( 30 , 30 , 70 ) ; } else if ( getid ( ) == 2 ) { return new dimensions ( 30 , 70 , 70 ) ; } else if ( getid ( ) == 3 ) { return new dimensions ( 70 , 70 , 70 ) ; } else if ( getid ( ) == 4 ) { return new dimensions ( 70 , 30 , 70 ) ; } return null ; }
va	3	private static void deleteemptyschemas ( xmpnode tree ) { for ( iterator it = tree . iteratechildren ( ) ; it . hasnext ( ) ; ) { xmpnode schema = ( xmpnode ) it . next ( ) ; if ( ! schema . haschildren ( ) ) { it . remove ( ) ; } } }
va	8	@ override public void drawtool ( graphics g , int mousex , int mousey ) { graphics2d g2 = ( graphics2d ) g ; g2 . setstroke ( new basicstroke ( 2 ) ) ; canvas c = mainwindow . main_window . getcanvas ( ) ; point prev ; switch ( state ) { case start : break ; case confirm : g . setcolor ( color . orange ) ; if ( boxmode . isselected ( ) ) { g . drawrect ( c . getscaledcoord ( rect . x + 0.5 ) , c . getscaledcoord ( rect . y + 0.5 ) , c . getscaledcoord ( rect . width ) , c . getscaledcoord ( rect . height ) ) ; g . filloval ( c . getscaledcoord ( rect . x ) , c . getscaledcoord ( rect . y ) , c . getscaledcoord ( 1 ) , c . getscaledcoord ( 1 ) ) ; g . filloval ( c . getscaledcoord ( rect . x + rect . width ) , c . getscaledcoord ( rect . y ) , c . getscaledcoord ( 1 ) , c . getscaledcoord ( 1 ) ) ; g . filloval ( c . getscaledcoord ( rect . x ) , c . getscaledcoord ( rect . y + rect . height ) , c . getscaledcoord ( 1 ) , c . getscaledcoord ( 1 ) ) ; g . filloval ( c . getscaledcoord ( rect . x + rect . width ) , c . getscaledcoord ( rect . y + rect . height ) , c . getscaledcoord ( 1 ) , c . getscaledcoord ( 1 ) ) ; } else { prev = pts . getlast ( ) ; for ( point pt : pts ) { g . drawline ( c . getscaledcoord ( pt . x + 0.5 ) , c . getscaledcoord ( pt . y + 0.5 ) , c . getscaledcoord ( prev . x + 0.5 ) , c . getscaledcoord ( prev . y + 0.5 ) ) ; g . filloval ( c . getscaledcoord ( pt . x ) , c . getscaledcoord ( pt . y ) , c . getscaledcoord ( 1 ) , c . getscaledcoord ( 1 ) ) ; prev = pt ; } } break ; case building : g . setcolor ( color . orange ) ; if ( boxmode . isselected ( ) ) { g . filloval ( c . getscaledcoord ( rect . x ) , c . getscaledcoord ( rect . y ) , c . getscaledcoord ( 1 ) , c . getscaledcoord ( 1 ) ) ; g . drawrect ( c . getscaledcoord ( rect . x + 0.5 ) , c . getscaledcoord ( rect . y + 0.5 ) , c . getscaledcoord ( mousex - rect . x ) , c . getscaledcoord ( mousey - rect . y ) ) ; } else { g . drawline ( c . getscaledcoord ( pts . getlast ( ) . x + 0.5 ) , c . getscaledcoord ( pts . getlast ( ) . y + 0.5 ) , c . getscaledcoord ( mousex + 0.5 ) , c . getscaledcoord ( mousey + 0.5 ) ) ; prev = null ; for ( point pt : pts ) { if ( prev != null ) { g . drawline ( c . getscaledcoord ( pt . x + 0.5 ) , c . getscaledcoord ( pt . y + 0.5 ) , c . getscaledcoord ( prev . x + 0.5 ) , c . getscaledcoord ( prev . y + 0.5 ) ) ; } g . filloval ( c . getscaledcoord ( pt . x ) , c . getscaledcoord ( pt . y ) , c . getscaledcoord ( 1 ) , c . getscaledcoord ( 1 ) ) ; prev = pt ; } g . filloval ( c . getscaledcoord ( pts . getfirst ( ) . x ) , c . getscaledcoord ( pts . getfirst ( ) . y ) , c . getscaledcoord ( 1 ) , c . getscaledcoord ( 1 ) ) ; } break ; } }
va	2	public static boolean promotepieceat ( location loc , piece piece ) { return ( piece . gettype ( ) == piecetype . pawn && ( loc . row == 0 || loc . row == board . size - 1 ) ) ; }
va	8	public decision decide ( state s ) { state t = s . clone ( ) ; if ( verbose ) { system . out . println ( "----------------------------------------------------" ) ; system . out . println ( name + " (" + handle + ") deciding..." ) ; } initializecaches ( t ) ; boolean [ ] coalition = selectcoalition ( t ) ; if ( verbose ) system . out . println ( "assumed coalition " + arrays . tostring ( coalition ) ) ; evaluateddecision ed = deepeniteratively ( t , 0 , coalition ) ; if ( verbose ) { system . out . println ( "average branching factor: " + ( total_nbranches * 1.0 / total_nbranches_nterms ) ) ; system . out . println ( "killer hit rate: " + ( killer_hits * 1.0 / killer_tries ) + "; " + killer_hits + "/" + killer_tries ) ; } assert ( t . equals ( s ) ) ; total_ndecisions ++ ; return ed . decision ; }
va	4	public void jugar ( jframe frame , estadovictoria escucharvictoria ) { point limitepueblo ; system . out . println ( "dif min is " + this . defensediffmin + " and dif max is " + this . defensediffmax ) ; system . out . println ( "gold min is " + this . goldmin + " and gold max is " + this . goldmax ) ; int goldincreasepercentage = rand . nextint ( goldmax - goldmin ) + goldmin ; defenseincreasepercentage = rand . nextint ( defensediffmax - defensediffmin ) + defensediffmin ; victoriaoro = baseoro + ( baseoro * ( goldincreasepercentage / 100 ) ) ; this . oro = victoriaoro ; system . out . println ( "cantidad de oro en victoria es: " + victoriaoro ) ; system . out . println ( "aumento de dificultad " + defenseincreasepercentage + "%" ) ; this . llenarmatrizvacio ( ) ; point [ ] puntosimportante = pueblo . generarpueblo ( this . nivel , this . matriz , this . refcontenedor , this . edificios , defenseincreasepercentage , this . ejercito ) ; limitepueblo = puntosimportante [ 0 ] ; this . puntocasa = puntosimportante [ 1 ] ; this . soldadosterrestres ( limitepueblo ) ; for ( int i = 0 ; i < ejercito . size ( ) ; i ++ ) ejercito . get ( i ) . start ( ) ; for ( int i = 0 ; i < edificios . size ( ) ; i ++ ) { edificios . get ( i ) . pegarenpanel ( ) ; edificios . get ( i ) . start ( ) ; } escucharvictoria . revisarvictoria ( frame ) ; }
va	1	public connectmethods getlist ( ) { return list ; }
va	6	protected void initmanagermappings ( configuration conf ) throws torqueexception { int pref = torque . manager_prefix . length ( ) ; int suff = torque . manager_suffix . length ( ) ; for ( iterator it = conf . getkeys ( ) ; it . hasnext ( ) ; ) { string key = ( string ) it . next ( ) ; if ( key . startswith ( torque . manager_prefix ) && key . endswith ( torque . manager_suffix ) ) { string managedclasskey = key . substring ( pref , key . length ( ) - suff ) ; if ( ! managers . containskey ( managedclasskey ) ) { string managerclass = conf . getstring ( key ) ; log . info ( "added manager for class: " + managedclasskey + " -> " + managerclass ) ; try { initmanager ( managedclasskey , managerclass ) ; } catch ( torqueexception e ) { log . error ( "" , e ) ; e . printstacktrace ( ) ; throw e ; } } } } }
va	8	@ override public boolean equals ( object obj ) { if ( obj == null ) { return false ; } if ( getclass ( ) != obj . getclass ( ) ) { return false ; } final attendeeimpl other = ( attendeeimpl ) obj ; if ( ( this . attendid == null ) ? ( other . attendid != null ) : ! this . attendid . equals ( other . attendid ) ) { return false ; } return true ; }
va	9	public void mousepressed ( mouseevent e ) { mappable mappable = map . getmapobjectat ( e . getx ( ) , e . gety ( ) ) ; setselected ( mappable ) ; boolean ctrldown = ( e . getmodifiersex ( ) & inputevent . ctrl_down_mask ) != 0 ; boolean altdown = ( e . getmodifiersex ( ) & inputevent . alt_down_mask ) != 0 ; if ( mappable != null && swingutilities . isrightmousebutton ( e ) ) { popupmenu . show ( this , e . getx ( ) , e . gety ( ) ) ; } else if ( selected != null && ctrldown ) { eventproc = eventprocessors . get ( "rotate" ) ; } else if ( selected != null && altdown ) { eventproc = eventprocessors . get ( "face" ) ; } else if ( selected != null ) { eventproc = eventprocessors . get ( "move" ) ; } else if ( swingutilities . isrightmousebutton ( e ) ) { eventproc = eventprocessors . get ( "measure" ) ; } else { eventproc = eventprocessors . get ( "select" ) ; } eventproc . mousepressed ( e ) ; }
va	10	public static int getdatabasematchesinfo ( int mode , int match , int teamid ) { mode ++ ; if ( mode == 1 ) { return getmatchautopoints ( match , teamid ) ; } else if ( mode == 2 ) { return getmatchtelepoints ( match , teamid ) ; } else if ( mode == 3 ) { return getmatchfrisbycollectionrating ( match , teamid ) ; } else if ( mode == 4 ) { return getmatchaimingshootingskillsrating ( match , teamid ) ; } else if ( mode == 5 ) { int i = getmatchcanclimbint ( match , teamid ) ; return i ; } else if ( mode == 6 ) { return getmatchpyramidlevel ( match , teamid ) ; } else if ( mode == 7 ) { return getmatchfouls ( match , teamid ) ; } else if ( mode == 8 ) { return getmatchtechfouls ( match , teamid ) ; } else if ( mode == 9 ) { return getmatchlostconnectionint ( match , teamid ) ; } else { return 0 ; } }
va	3	public boolean isopaque ( int alpha_thresh ) { int [ ] alpha = getpixels ( ) ; for ( int i = 0 ; i < alpha . length ; i ++ ) { if ( ( ( alpha [ i ] > > 24 ) & 0xff ) < alpha_thresh ) return false ; } return true ; }
va	2	public static void main ( string [ ] args ) { int [ ] expneeded = { 150 , 450 , 900 , 1800 } ; int [ ] received = { 133 , 312 , 612 , 450 } ; for ( int i = 0 ; i < received . length ; i ++ ) { system . out . println ( tonextlevel ( expneeded , received [ i ] ) ) ; } }
va	5	protected static hashmap < string , file > getuserdirectorystore ( ) { try { if ( userdirs == null ) { userdirs = getuserdirectoriesimpl ( ) ; } if ( userdirs == null ) { return null ; } return userdirs ; } catch ( unsupportedoperationexception ex ) { return null ; } }
va	3	public static string getunqualifiedtablename ( final string table ) { if ( table != null ) { int dotindex = table . lastindexof ( "." ) ; if ( ++ dotindex > 0 ) { return table . substring ( dotindex ) ; } } return table ; }
va	4	private void jbutton1actionperformed ( java . awt . event . actionevent evt ) { try { selectedtenant . setname ( jtextfield2 . gettext ( ) ) ; selectedtenant . setaddress ( jtextfield3 . gettext ( ) ) ; selectedtenant . settel ( jtextfield4 . gettext ( ) ) ; selectedtenant . setroom ( ( room ) jcombobox1 . getselecteditem ( ) ) ; selectedtenant . setrentdate ( jtextfield1 . gettext ( ) ) ; selectedtenant . setpaystatus ( jtextfield6 . gettext ( ) ) ; selectedtenant . getroom ( ) . setstatus ( "no" ) ; if ( selectedtenant . getid ( ) != null && selectedtenant . getid ( ) != 0 ) { tenantjpacontroller . edit ( selectedtenant ) ; roomjpacontroller . edit ( selectedtenant . getroom ( ) ) ; tenanttablemodel . firetabledatachanged ( ) ; } else { tenantjpacontroller . create ( selectedtenant ) ; roomjpacontroller . edit ( selectedtenant . getroom ( ) ) ; tenanttablemodel . tenants . add ( selectedtenant ) ; tenanttablemodel . firetabledatachanged ( ) ; system . out . println ( selectedtenant . getid ( ) ) ; } } catch ( exception e ) { e . printstacktrace ( ) ; } this . parent . getroomview1 ( ) . refresh ( ) ; this . parent . getbookingviews1 ( ) . refresh ( ) ; this . parent . gettenantviews1 ( ) . refresh ( ) ; setenabledform ( false ) ; }
va	5	public list < point > naive ( list < segment > segments ) { arraylist < point > intersections = new arraylist < point > ( ) ; for ( int i = 0 ; i < segments . size ( ) ; i ++ ) { for ( int j = 0 ; j < segments . size ( ) ; j ++ ) { point intersection = getlineintersection ( segments . get ( i ) , segments . get ( j ) ) ; if ( intersection != null && ! intersections . contains ( intersection ) ) { intersections . add ( intersection ) ; } } } return intersections ; }
va	8	@ eventhandler public void dragon_duel ( entitydamagebyentityevent e ) { if ( e . getdamager ( ) . gettype ( ) == entitytype . ender_dragon && e . getentitytype ( ) == entitytype . player ) { player p = player . class . cast ( e . getentity ( ) ) ; if ( pluginvars . isdueling ( p ) ) { e . setcancelled ( true ) ; return ; } new npcgenerator ( ) . generate ( e . getdamager ( ) , e . getdamager ( ) . getuniqueid ( ) ) ; try { if ( deckgenerator . checkdeckint ( pluginvars . getdeckfor ( p ) ) ) { e . setcancelled ( true ) ; inventory i = bukkit . createinventory ( null , 54 , "duel monsters" ) ; duel duel = pluginvars . createduel ( p , i , null , null , null , e . getdamager ( ) . getuniqueid ( ) ) ; p . openinventory ( i ) ; duel . startduel ( ) ; } else { p . sendmessage ( "deck is illegal! please re-arrange it before dueling." ) ; } } catch ( nodeckexception e1 ) { p . sendmessage ( "you don't have a deck!" ) ; } } }
va	7	public static string checksum ( string f ) { try { messagedigest md = messagedigest . getinstance ( "md5" ) ; digestinputstream ds = new digestinputstream ( new fileinputstream ( f ) , md ) ; byte [ ] b = new byte [ 512 ] ; while ( ds . read ( b ) != - 1 ) ; string computed = "" ; for ( byte v : md . digest ( ) ) computed += bytetohex ( v ) ; return computed ; } catch ( nosuchalgorithmexception e ) { e . printstacktrace ( ) ; } catch ( filenotfoundexception e ) { e . printstacktrace ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } return "<error computing checksum>" ; }
va	9	private void actualizarjugador ( long tiempotranscurrido ) { primerjugador ( ) . borrar ( g2 , buffer ) ; primerjugador ( ) . actualizar ( this , tiempotranscurrido ) ; if ( primerjugador ( ) . getestadoactual ( ) == estado . eliminado ) { if ( sonidos . getinstance ( ) . getsonido ( sonidos . just_died ) . isplaying ( ) ) return ; jpanelinformacion . disminuirvidasrestantes ( ) ; jpanelinformacion . detenercuentaregresiva ( ) ; if ( jpanelinformacion . getvidasrestantes ( ) < 0 ) { jpanelinformacion . setvidasrestantes ( 2 ) ; jpanelavisos . getinstance ( null ) . setnivel ( ( short ) 1 ) ; jpanelcontenedor . cambiarinterfaz ( escenas . escena_game_over ) ; } else jpanelcontenedor . cambiarinterfaz ( escenas . escena_stage ) ; } else if ( primerjugador ( ) . isentroalapuerta ( ) ) { if ( sonidos . getinstance ( ) . getsonido ( sonidos . level_complete ) . isplaying ( ) ) return ; jpanelinformacion . detenercuentaregresiva ( ) ; jpanelavisos . getinstance ( null ) . aumentarnivel ( ) ; if ( jpanelavisos . getinstance ( null ) . findejuego ( ) ) { } else jpanelcontenedor . cambiarinterfaz ( escenas . escena_stage ) ; } }
va	10	@ override public boolean equals ( object that ) { if ( ! ( that instanceof s2cap ) ) { return false ; } s2cap other = ( s2cap ) that ; return ( axis . equals ( other . axis ) && height == other . height ) || ( isempty ( ) && other . isempty ( ) ) || ( isfull ( ) && other . isfull ( ) ) ; }
va	5	public trackedpeer update ( string event , bytebuffer peerid , string hexpeerid , string ip , int port , long uploaded , long downloaded , long left ) throws unsupportedencodingexception { trackedpeer peer ; trackedpeer . peerstate state = trackedpeer . peerstate . unknown ; if ( "started" . equals ( event ) ) { peer = new trackedpeer ( this , ip , port , peerid ) ; state = trackedpeer . peerstate . started ; this . addpeer ( peer ) ; } else if ( "stopped" . equals ( event ) ) { peer = this . removepeer ( hexpeerid ) ; state = trackedpeer . peerstate . stopped ; } else if ( "completed" . equals ( event ) ) { peer = this . getpeer ( hexpeerid ) ; state = trackedpeer . peerstate . completed ; } else if ( event == null ) { peer = this . getpeer ( hexpeerid ) ; state = trackedpeer . peerstate . started ; } else { throw new illegalargumentexception ( "unexpected announce event type!" ) ; } peer . update ( state , uploaded , downloaded , left ) ; return peer ; }
va	6	public static boolean arrayboolequals ( boolean [ ] tab1 , boolean tab2 [ ] ) { if ( tab1 . length != tab2 . length ) { return false ; } for ( int i = 0 ; i < tab1 . length ; i ++ ) { if ( tab1 [ i ] != tab2 [ i ] ) { return false ; } } return true ; }
va	6	private stringbuffer executequery ( string querystatement , arraylist < integer > _columnlist ) throws atomsqlexception { statement _query = null ; resultset _resultset = null ; stringbuffer _result ; int _columnscount ; _columnscount = _columnlist . size ( ) ; _result = new stringbuffer ( ) ; try { _query = this . connection . createstatement ( ) ; _resultset = _query . executequery ( querystatement ) ; while ( _resultset . next ( ) ) { for ( int _index = 0 ; _columnscount > _index ; _index ++ ) { _result . append ( _resultset . getstring ( _columnlist . get ( _index ) ) ) ; } _result . append ( "\\n" ) ; } } catch ( sqlexception e ) { atomsqlexception _sqlexception = new atomsqlexception ( e ) ; _sqlexception . setcustommessage ( "failed while creating/executing statement" ) ; throw _sqlexception ; } finally { try { _query . close ( ) ; _resultset . close ( ) ; } catch ( sqlexception e ) { atomsqlexception _sqlexception = new atomsqlexception ( e ) ; _sqlexception . setcustommessage ( "failed while closing statement" ) ; throw _sqlexception ; } } return _result ; }
va	3	public static void ensureloaded ( image img ) throws exception { mediatracker . addimage ( img , 0 ) ; try { mediatracker . waitforall ( ) ; if ( mediatracker . geterrorsany ( ) != null ) { mediatracker . removeimage ( img ) ; throw new exception ( "error loading image" ) ; } } catch ( interruptedexception e ) { e . printstacktrace ( ) ; } mediatracker . removeimage ( img ) ; }
va	1	public popupscreen ( screen parent , entity e ) { this . e = e ; this . parent = parent ; this . msg = e . msg ; }
va	10	@ before public void setup ( ) { for ( int x = 1 ; x <= nodos ; x ++ ) grafo . agregarvertice ( x ) ; random r = new random ( ) ; for ( int i = 0 ; i < nodos ; i ++ ) { for ( int j = 0 ; j < nodos ; j ++ ) { if ( i % 2 == 0 && j % 2 != 0 ) grafo . agregararista ( i , j , r . nextint ( 100 ) ) ; } } }
va	6	private properties loadproperties ( string url ) throws ioexception { properties p = new properties ( ) ; inputstream is = null ; if ( url . startswith ( classpath ) ) { is = thread . currentthread ( ) . getcontextclassloader ( ) . getresourceasstream ( url . replace ( classpath , empty_string ) ) ; } else if ( url . startswith ( file ) ) { is = new fileinputstream ( url . replace ( file , empty_string ) ) ; } if ( null == is ) { throw new ioexception ( "couldn't load resource '" + url + "'" ) ; } p . load ( is ) ; return p ; }
va	4	public boolean hasnextround ( ) { return ( player . gethp ( ) > 0 && creature . gethp ( ) > 0 ) && ( round == 0 || creaturehasanotheraction ( ) || playerhasanotheraction ( ) ) ; }
va	1	public messagethreading ( ) { }
va	8	public hub ( device dev ) throws ioexception { super ( controlmessage . getclassdescriptor ( dev , type_hub , ( byte ) 0 , 0 , 10 ) ) ; this . dev = dev ; if ( dev . getdevicedescriptor ( ) . getdeviceclass ( ) != class_hub ) throw new illegalargumentexception ( ) ; if ( getdescriptortype ( ) != type_hub ) throw new illegalargumentexception ( integer . tohexstring ( getdescriptortype ( ) ) ) ; if ( ( ports = getu8 ( 2 ) ) > 15 ) throw new runtimeexception ( "nyi" ) ; }
va	9	private boolean isskipafterendpunc ( char c ) { if ( c == '\\n' || c == '\\r' ) return true ; switch ( charutil . classify ( c ) ) { case space : case punctuation : return true ; default : return false ; } }
va	7	private void sendtoconfig ( arraylist < field > fieldparams , string action ) { object [ ] params = new object [ fieldparams . size ( ) ] ; for ( int i = 0 ; i < fieldparams . size ( ) ; i ++ ) { try { try { params [ i ] = fieldparams . get ( i ) . getdeclaringclass ( ) . getmethod ( "get" + fieldparams . get ( i ) . getname ( ) ) . invoke ( this ) ; } catch ( illegalaccessexception ex ) { logger . getlogger ( applicationview . class . getname ( ) ) . log ( level . severe , null , ex ) ; } catch ( illegalargumentexception ex ) { logger . getlogger ( applicationview . class . getname ( ) ) . log ( level . severe , null , ex ) ; } catch ( invocationtargetexception ex ) { logger . getlogger ( applicationview . class . getname ( ) ) . log ( level . severe , null , ex ) ; } } catch ( nosuchmethodexception ex ) { logger . getlogger ( applicationview . class . getname ( ) ) . log ( level . severe , null , ex ) ; } catch ( securityexception ex ) { logger . getlogger ( applicationview . class . getname ( ) ) . log ( level . severe , null , ex ) ; } } setlastresponse ( config . getinstance ( ) . sendparamstocontroller ( this . getclass ( ) . getname ( ) , action , params , this , getuser ( ) ) ) ; }
va	4	public < t > t get ( class < t > clazz ) { if ( components . get ( clazz ) == null ) { for ( entry < class < ? extends component > , component > c : components . entryset ( ) ) { if ( clazz . isassignablefrom ( c . getkey ( ) ) ) { return clazz . cast ( c . getvalue ( ) ) ; } } } return clazz . cast ( components . get ( clazz ) ) ; }
va	5	public void createnamelistandcalendar ( ) { employeenamelist = new employeenamelist ( ) ; arraylist < string > dates = dates . getinstance ( ) . getitems ( ) ; dates . clear ( ) ; for ( timerecord timerecord : timerecords ) { if ( ! employeenamelist . contains ( timerecord . getname ( ) ) ) { employeenamelist . add ( timerecord . getname ( ) ) ; } if ( ! dates . contains ( timerecord . getdate ( ) ) ) { dates . add ( timerecord . getdate ( ) ) ; } } collections . sort ( employeenamelist ) ; txtstartdate . settext ( dates . get ( 0 ) ) ; txtenddate . settext ( dates . get ( dates . size ( ) - 1 ) ) ; }
va	7	@ override public object getvalueat ( int row , int column ) { vehicle vehicle = vehicles . elementat ( row ) ; switch ( column ) { case 0 : return vehicle . getlicenceplate ( ) ; case 1 : return vehicle . getstartdate ( ) ; case 2 : return vehicle . getowner ( ) . getfirstname ( ) + " " + vehicle . getowner ( ) . getfamilyname ( ) . touppercase ( ) ; case 3 : return vehicle . getmodel ( ) . getdesignation ( ) ; case 4 : if ( this . deleteicon == null ) { return "supprimer" ; } return this . deleteicon ; default : break ; } return null ; }
va	2	private void configurarpersistencia ( ) { if ( ! leitorxml ( ) . isempty ( ) ) { novaconfiguracao ( leitorxml ( ) ) ; } else { joptionpane . showmessagedialog ( this , "o arquivo de configura\xe7\xe3o est\xe1 vazio." , "erro" , joptionpane . error_message , null ) ; } }
va	8	public void sanitynums ( ) { if ( nextinnovation < 100 ) { system . out . println ( "next innovation got reset :: historicaltracker" ) ; system . exit ( 0 ) ; } for ( int i = 0 ; i < neuronnums . size ( ) ; i ++ ) for ( int f = 0 ; f < connectionnums . size ( ) ; f ++ ) if ( neuronnums . get ( i ) . intvalue ( ) == connectionnums . get ( f ) . intvalue ( ) ) { system . out . println ( "nums are overlapping!!!! :: historicaltracker" ) ; system . exit ( 0 ) ; } }
va	10	private void readblocks ( randomaccessfile data ) throws ioexception { boolean readnext = true ; while ( readnext ) { int mapx = data . readunsignedshort ( ) ; int mapy = data . readunsignedshort ( ) ; short musicindex = data . readshort ( ) ; short ambienceindex = data . readshort ( ) ; short mapiconindex = data . readshort ( ) ; short doorbytes = data . readshort ( ) ; byte scrollbyte = data . readbyte ( ) ; int mapcolorred = data . readunsignedbyte ( ) ; int mapcolorgreen = data . readunsignedbyte ( ) ; int mapcolorblue = data . readunsignedbyte ( ) ; color mapcolor = new color ( mapcolorred , mapcolorgreen , mapcolorblue , map_color_alpha ) ; short mapmarkingbytes = data . readshort ( ) ; block newblock = new block ( this . blocksizex , this . blocksizey , musicindex , ambienceindex , mapiconindex , doorbytes , scrollbyte , mapcolor , mapmarkingbytes ) ; this . addblock ( newblock , mapx , mapy ) ; boolean readlayers = true ; while ( readlayers ) { byte layerid = data . readbyte ( ) ; switch ( layerid . getlayerid ( layerid & 0xff ) ) { case tile_collision : data . readbyte ( ) ; newblock . setcollisionlayer ( new collisionlayer ( newblock , data , this ) ) ; break ; case color_decoration : newblock . addlayer ( new colorlayer ( newblock , data ) ) ; break ; case tile_decoration : case image_decoration : case entity_data : zettautil . error ( "layer type %s not implemented yet" , layerid . getlayerid ( layerid ) . name ( ) ) ; break ; case end_of_file : data . readbyte ( ) ; return ; case end_block : readlayers = false ; data . readbyte ( ) ; break ; default : zettautil . error ( "unknown layer id %d" , layerid ) ; break ; } } } }
va	6	public void bulksavedocuments ( document [ ] documents ) throws ioexception { couchresponse resp = null ; resp = session . post ( name + "/_bulk_docs" , new jsonobject ( ) . accumulate ( "docs" , documents ) . tostring ( ) ) ; if ( resp . isok ( ) ) { final jsonarray respjsonarray = resp . getbodyasjsonarray ( ) ; jsonobject respobj = null ; string id = null ; string rev = null ; for ( int i = 0 ; i < documents . length ; i ++ ) { respobj = respjsonarray . getjsonobject ( i ) ; id = respobj . getstring ( "id" ) ; rev = respobj . getstring ( "rev" ) ; if ( stringutils . isblank ( documents [ i ] . getid ( ) ) ) { documents [ i ] . setid ( id ) ; documents [ i ] . setrev ( rev ) ; } else if ( stringutils . isnotblank ( documents [ i ] . getid ( ) ) && documents [ i ] . getid ( ) . equals ( id ) ) { documents [ i ] . setrev ( rev ) ; } else { log . warn ( "returned bulk save array in incorrect order<litcomma> saved documents do not have updated rev or ids" ) ; } documents [ i ] . setdatabase ( this ) ; } } else { log . warn ( "error bulk saving documents - " + resp . geterrorid ( ) + " " + resp . geterrorreason ( ) ) ; } }
va	8	private bigdecimal getquantity ( string tablename , connection connection ) { bigdecimal quantity = null ; if ( ! configuration . getboolean ( db_idbroker_prefetch , true ) ) { quantity = new bigdecimal ( ( double ) 1 ) ; } else if ( quantitystore . containskey ( tablename ) ) { quantity = ( bigdecimal ) quantitystore . get ( tablename ) ; } else { connection dbcon = null ; try { if ( connection == null || configuration . getboolean ( db_idbroker_usenewconnection , true ) ) { dbcon = torque . getconnection ( databasename ) ; } bigdecimal [ ] results = selectrow ( dbcon , tablename ) ; quantity = results [ 1 ] ; quantitystore . put ( tablename , quantity ) ; } catch ( exception e ) { quantity = new bigdecimal ( ( double ) 10 ) ; } finally { try { dbcon . close ( ) ; } catch ( exception e ) { log . error ( "release of connection failed." , e ) ; } } } return quantity ; }
va	5	public void paint ( graphics g ) { final fontmetrics metrics = getfontmetrics ( getfont ( ) ) ; final int fontheight = metrics . getheight ( ) + pad ; final int height = getheight ( ) - pad ; final int width = getwidth ( ) - 2 * pad ; final int rows = ( int ) ( height / fontheight ) ; final int indent = metrics . stringwidth ( " " ) ; int indent ; int remaining = rows ; iterator < paintabletext > lines = stack . iterator ( ) ; while ( lines . hasnext ( ) && remaining > 0 ) { paintabletext text = lines . next ( ) ; string line = text . gettext ( ) ; indent = text . getindent ( ) ; integer [ ] rows = getrows ( line , indent ) ; for ( int i = rows . length - 1 , offset = line . length ( ) ; i >= 0 && remaining > 0 ; offset -= rows [ i ] , -- i , -- remaining ) { text . paint ( g . create ( pad + ( ( i == 0 ) ? 0 : indent * indent ) , ( remaining ) * fontheight - metrics . getheight ( ) , width , metrics . getheight ( ) ) , offset - rows [ i ] , offset ) ; } } }
va	2	public static void main ( string args [ ] ) { try { uimanager . setlookandfeel ( uimanager . getsystemlookandfeelclassname ( ) ) ; } catch ( exception e1 ) { e1 . printstacktrace ( ) ; } test test = new test ( ) ; test . setbounds ( 300 , 300 , 850 , 350 ) ; test . setvisible ( true ) ; test . setdefaultcloseoperation ( windowconstants . dispose_on_close ) ; test . addwindowlistener ( new windowadapter ( ) { public void windowclosed ( windowevent e ) { system . exit ( 0 ) ; } } ) ; }
va	2	private void painttiles ( graphics g , component game ) { for ( int i = 0 ; i < tiles . size ( ) ; i ++ ) { tile t = tiles . get ( i ) ; g . drawimage ( t . gettileimage ( ) , t . gettilex ( ) , t . gettiley ( ) , game ) ; } }
va	4	private boolean isstunned ( combatant combatant ) { boolean stunned = false ; round thisround = combatant . getround ( round ) ; if ( thisround != null ) { for ( action debuff : thisround . getdebuffs ( ) ) { if ( debuff . getisstun ( ) ) { stunned = true ; } } } return stunned ; }
va	4	public void printmoviegoerbookings ( moviegoer moviegoer ) { if ( moviegoer == null ) { system . out . println ( "no record found. :(" ) ; return ; } for ( booking booking : moviegoer . getbookings ( ) ) { printbookingdetail ( booking ) ; } }
va	2	public void checknamespace ( xmlpullparser xpp , int pos , string prefix , string uri , boolean checkmapping ) throws xmlpullparserexception , ioexception { assertequals ( "getnamespaceprefix(pos)" , prefix , xpp . getnamespaceprefix ( pos ) ) ; assertequals ( "getnamespaceuri(pos)" , uri , xpp . getnamespaceuri ( pos ) ) ; if ( checkmapping ) { assertequals ( "getnamespace(prefix)" , uri , xpp . getnamespace ( prefix ) ) ; } }
va	6	public static void parsegroupinfo ( group group , string resultstring ) { hashmap < string , friend > members = group . getmembers ( ) ; try { jsonobject base = new jsonobject ( resultstring ) ; if ( base . optint ( "retcode" , - 1 ) == 0 ) { jsonobject resultobject = base . optjsonobject ( "result" ) ; jsonarray cardarray = resultobject . optjsonarray ( "cards" ) ; jsonarray infoarray = resultobject . optjsonarray ( "minfo" ) ; for ( int i = 0 ; i < infoarray . length ( ) ; i ++ ) { friend member = new friend ( ) ; jsonobject memberobject = infoarray . optjsonobject ( i ) ; member . setuin ( memberobject . optstring ( "uin" ) ) ; member . setnickname ( memberobject . optstring ( "nick" ) ) ; member . setgender ( memberobject . optstring ( "gender" ) ) ; members . put ( member . getuin ( ) , member ) ; } for ( int i = 0 ; i < cardarray . length ( ) ; i ++ ) { jsonobject memberobject = cardarray . optjsonobject ( i ) ; friend member = members . get ( memberobject . optstring ( "muin" ) ) ; member . setcard ( memberobject . optstring ( "card" ) ) ; members . put ( member . getuin ( ) , member ) ; } group . setowner ( resultobject . optjsonobject ( "ginfo" ) . optstring ( "owner" ) ) ; } } catch ( jsonexception e ) { e . printstacktrace ( ) ; } }
va	6	public void liiketoiminnat ( ) { if ( gameover ) { toteutaohjausgameover ( ) ; } else if ( ! paused ) { kello . pienenna ( ) ; if ( vaihtoaika ) { ohjaustoiminnat . toteutaohjausvaihtoaika ( ) ; } else { paivitafysiikka ( ) ; ohjaustoiminnat . toteutaohjaus ( ) ; pudota = false ; } paivitaaikayksikko ( ) ; if ( ! vaihtoaika ) { luovarjopalikka ( ) ; } } }
va	9	public void receivedresponse ( string response ) { reversiparser parser = new reversiparser ( ) ; reversicommand parsedcommand = parser . parsecommand ( response ) ; switch ( parsedcommand . gettype ( ) ) { case ok : { if ( this . awaitingresponse ) { this . awaitingresponse = false ; boolean isok = response . equals ( "ok" ) ; if ( isok ) { switch ( this . currentcommand . gettype ( ) ) { case exit : { } break ; case move : { list < string > parameters = parsedcommand . getparameters ( ) ; string column = parameters . get ( 0 ) ; string row = parameters . get ( 1 ) ; integer rowinteger = new integer ( row ) ; position position = new position ( column , rowinteger ) ; this . game . makehomeplay ( position ) ; this . awaitingresponse = true ; } break ; case redo : { this . game . redoplay ( ) ; } break ; case undo : { this . game . undoplay ( ) ; } break ; default : break ; } } } } break ; case move : { list < string > parameters = parsedcommand . getparameters ( ) ; string column = parameters . get ( 0 ) ; string row = parameters . get ( 1 ) ; integer rowinteger = new integer ( row ) ; position position = new position ( column , rowinteger ) ; this . game . makeawayplay ( position ) ; } default : break ; } }
va	9	public object getvalueat ( int rowindex , int columnindex ) { assignment as = assignments . get ( rowindex ) ; switch ( columnindex ) { case 0 : return as . getname ( ) ; case 1 : return as . gettype ( ) ; case 2 : return as . getgradedpoints ( ) ; case 3 : return as . gettotalpoints ( ) ; case 4 : return as . getdescription ( ) ; case 5 : return as . getgroupid ( ) ; case 6 : return as . getstudentid ( ) ; case 7 : return as . getassignmentid ( ) ; case 8 : return as . getassignmentnumber ( ) ; } return "" ; }
va	10	private list < string > getlinksfromhtml ( document doc , string parent_url ) { list < string > outgoing_urls = new arraylist < string > ( ) ; elements body = doc . getelementsbytag ( "body" ) ; if ( body . first ( ) == null ) { elements frames = doc . getelementsbytag ( "frame" ) ; if ( frames . first ( ) == null ) { return null ; } else { for ( element frame : frames ) { try { string source = frame . attr ( "src" ) ; if ( source . equals ( "about:blank" ) ) continue ; list < string > child_urls = getlinksfromhtml ( jsoup . connect ( parent_url + "/" + source ) . get ( ) , parent_url + "/" + source ) ; if ( child_urls != null ) { logger . info ( "page in frame " + parent_url + "/" + source + ": " + child_urls ) ; outgoing_urls . addall ( child_urls ) ; } } catch ( exception e ) { e . printstacktrace ( ) ; continue ; } } } } else { elements links = body . first ( ) . getelementsbytag ( "a" ) ; for ( element link : links ) { string linkhref = link . attr ( "href" ) ; if ( domain_filters . matcher ( linkhref ) . matches ( ) ) { outgoing_urls . add ( linkhref ) ; } } } return outgoing_urls ; }
va	2	private void updatetiles ( float deltatimems ) { for ( int i = 0 ; i < tiles . size ( ) ; i ++ ) { tile t = tiles . get ( i ) ; t . update ( deltatimems ) ; } }
va	4	private string readoneline ( bufferedinputstream in ) { string str = "" ; try { byte [ ] buffer = new byte [ 1 ] ; int bytesread = 0 ; while ( ( bytesread = in . read ( buffer ) ) != - 1 ) { string temp = new string ( buffer , 0 , bytesread ) ; if ( temp . equals ( "\\n" ) ) { break ; } str += temp ; } } catch ( exception e ) { system . out . print ( "fail * 2" ) ; } return str ; }
va	9	private void validatedatabasefile ( final string databasepath , final file databasefile ) throws filenotfoundexception { if ( ( ! databasefile . exists ( ) ) || ( ! databasefile . isfile ( ) ) ) { throw new filenotfoundexception ( "database file " + databasepath + " does not exist" ) ; } if ( ( ! databasefile . canread ( ) ) || ( ! databasefile . canexecute ( ) ) ) { throw new filenotfoundexception ( "database file " + databasepath + " does not have the " + "needed read/write system's permissions" ) ; } }
va	9	public static status checkupdate ( ) { status updatestatus = status . failure ; url url ; inputstream is ; inputstreamreader isr ; bufferedreader r ; string line ; try { url = new url ( updateurl ) ; is = url . openstream ( ) ; isr = new inputstreamreader ( is ) ; r = new bufferedreader ( isr ) ; string variable , value ; while ( ( line = r . readline ( ) ) != null ) { if ( ! line . equals ( "" ) && line . charat ( 0 ) != '/' ) { variable = line . substring ( 0 , line . indexof ( '=' ) ) ; value = line . substring ( line . indexof ( '=' ) + 1 ) ; if ( variable . equals ( "latest version" ) ) { variable = value ; value = variable . substring ( 0 , variable . indexof ( " " ) ) ; variable = variable . substring ( variable . indexof ( " " ) + 1 ) ; latestgameversion = value ; latestmodifier = variable ; if ( float . parsefloat ( value ) > float . parsefloat ( gameversion ) ) updatestatus = status . not_current ; else updatestatus = status . current ; } else if ( variable . equals ( "download url" ) ) downloadurl = value ; } } return updatestatus ; } catch ( malformedurlexception e ) { return status . url_not_found ; } catch ( ioexception e ) { return status . failure ; } }
va	5	public int [ ] getroomcoords ( mansionarea room ) { int [ ] coords = { - 2 , - 2 } ; if ( room . equals ( start ) ) { coords [ 0 ] = - 1 ; coords [ 1 ] = - 1 ; } else { for ( int i = 0 ; i < grid . length ; i ++ ) { for ( int j = 0 ; j < grid [ 0 ] . length ; j ++ ) { if ( room . equals ( grid [ i ] [ j ] ) ) { coords [ 0 ] = i ; coords [ 1 ] = j ; } } } } return coords ; }
va	8	public void setequalizer ( equalizer = ) { if ( = == null ) = = equalizer . pass_thru_eq ; equalizer . setfrom ( = ) ; float [ ] factors = equalizer . getbandfactors ( ) ; if ( filter1 != null ) filter1 . seteq ( factors ) ; if ( filter2 != null ) filter2 . seteq ( factors ) ; }
va	6	public static void main ( string [ ] args ) { string [ ] [ ] pessoas2 = { { "klaus" , "klaus@gmail" , "teste" } , { "mario" , "mario@gmail.com" , "teste 2" } , { "jean" , "jean@gmail.com" , "teste 3" } } ; string [ ] [ ] pessoas = new string [ 3 ] [ 3 ] ; pessoas [ 0 ] [ 0 ] = "klaus" ; pessoas [ 0 ] [ 1 ] = "klaus@gmail" ; pessoas [ 0 ] [ 2 ] = "teste" ; pessoas [ 1 ] [ 0 ] = "mario" ; pessoas [ 1 ] [ 1 ] = "mario@gmail" ; pessoas [ 1 ] [ 2 ] = "teste2" ; pessoas [ 2 ] [ 0 ] = "cleber" ; pessoas [ 2 ] [ 1 ] = "cleber@gmail" ; pessoas [ 2 ] [ 2 ] = "teste3" ; for ( int i = 0 ; i < pessoas . length ; i ++ ) { system . out . println ( pessoas [ i ] [ 0 ] ) ; system . out . println ( pessoas [ i ] [ 1 ] ) ; system . out . println ( pessoas [ i ] [ 2 ] ) ; } for ( int i = 0 ; i < pessoas . length ; i ++ ) { for ( int y = 0 ; y < pessoas [ i ] . length ; y ++ ) { system . out . println ( pessoas [ i ] [ y ] ) ; } } }
va	7	public string getreturndesc ( ) throws mqttunknowreturncodeexception { switch ( this . returncode ) { case mqttprotocalvariableheader . connect_return_code_accepted : return mqttprotocalvariableheader . connect_return_string_accepted ; case mqttprotocalvariableheader . connect_return_code_id_rejected : return mqttprotocalvariableheader . connect_return_string_id_rejected ; case mqttprotocalvariableheader . connect_return_code_server_unavailable : return mqttprotocalvariableheader . connect_return_string_server_unavailable ; case mqttprotocalvariableheader . connect_return_code_unacceptable_protocol_version : return mqttprotocalvariableheader . connect_return_string_unacceptable_protocol_version ; case mqttprotocalvariableheader . connect_return_code_unauthenticated : return mqttprotocalvariableheader . connect_return_string_unauthenticated ; case mqttprotocalvariableheader . connect_return_code_unauthorized : return mqttprotocalvariableheader . connect_return_string_unauthorized ; default : throw new mqttunknowreturncodeexception ( mqttunknowreturncodeexception . description ) ; } }
va	2	private void tamanhosenha ( char [ ] senha ) { if ( senha . length < 6 ) { pfsenha . setborder ( new lineborder ( new color ( 255 , 0 , 0 ) , 1 , true ) ) ; pfsenha . requestfocus ( ) ; lbcampos . settext ( "digite uma senha com no m\xednimo 6 caractes." ) ; lbcampos . setvisible ( true ) ; habilitarcampos ( ) ; } else { pfsenha . setborder ( new lineborder ( new color ( 0 , 0 , 0 ) , 1 , true ) ) ; lbcampos . settext ( "" ) ; lbcampos . setvisible ( false ) ; } }
va	6	public void switchmodeto ( editmodescheme mode ) { if ( mode == null ) { throw new illegalargumentexception ( "edit mode not nullable" ) ; } this . editingmode = mode ; if ( mode == editmodescheme . mode_select ) { if ( newelement != null ) { controller . addtoselection ( newelement ) ; } setcursor ( cursor . getdefaultcursor ( ) ) ; } else { setcursor ( cursor . getpredefinedcursor ( cursor . crosshair_cursor ) ) ; } setcursor ( cursor . getpredefinedcursor ( cursor . crosshair_cursor ) ) ; system . out . println ( mode . name ( ) ) ; }
va	6	public void nextday ( ) throws cantrunraidexception { for ( raidsettings currraid : this . plannedraids ) this . runraid ( currraid ) ; this . removeemptyraids ( ) ; this . map . randomzombieroaming ( ) ; this . rations -= this . survivors . size ( ) ; this . currentday ++ ; if ( this . survivors . isempty ( ) ) this . gameover ( "no more survivors" ) ; else if ( this . rations < 0 ) this . gameover ( "no more rations" ) ; }
va	7	public void dir ( ) { int cf = 0 , cd = 0 ; long cbytes = 0 ; try { if ( file . isdirectory ( ) ) { file files [ ] = file . listfiles ( ) ; for ( file fi : files ) { system . out . print ( new date ( fi . lastmodified ( ) ) ) ; if ( fi . isdirectory ( ) ) { system . out . print ( "\\t<dir>\\t\\t" ) ; cd ++ ; } if ( fi . isfile ( ) ) { system . out . print ( "\\t     \\t" ) ; cf ++ ; cbytes += fi . length ( ) ; system . out . print ( fi . length ( ) ) ; } system . out . println ( " " + fi . getname ( ) ) ; } system . out . printf ( "(%d) files\\n(%d) dirs\\ntotal bytes %d free space %d" , cf , cd , cbytes , file . getfreespace ( ) ) ; } } catch ( nullpointerexception e ) { system . out . println ( "primero hay que configurar un archivo" ) ; } }
va	7	list < record > readmultirecords ( string [ ] data ) { list < record > records = new arraylist < record > ( ) ; double distance = 0 ; for ( int k = 0 ; k < data . length ; ++ k ) { string [ ] s = data [ k ] . split ( ";" ) ; if ( k != 0 ) { distance = records . get ( records . size ( ) - 1 ) . distance ; } for ( int i = 0 ; i < s . length ; ++ i ) { record r = parserecord ( s [ i ] ) ; if ( i == 0 ) { distance -= r . distance ; } else { r . distance += distance ; records . add ( r ) ; } } } return records ; }
va	3	private int sspivot ( final int td , final int pa , final int first , final int last ) { int middle ; int t ; t = last - first ; middle = first + t / 2 ; if ( t <= 512 ) { if ( t <= 32 ) { return ssmedian3 ( td , pa , first , middle , last - 1 ) ; } t >>= 2 ; return ssmedian5 ( td , pa , first , first + t , middle , last - 1 - t , last - 1 ) ; } t >>= 3 ; return ssmedian3 ( td , pa , ssmedian3 ( td , pa , first , first + t , first + ( t << 1 ) ) , ssmedian3 ( td , pa , middle - t , middle , middle + t ) , ssmedian3 ( td , pa , last - 1 - ( t << 1 ) , last - 1 - t , last - 1 ) ) ; }
va	6	public void addentry ( string w , int c , int l ) { int n = ( ngrams . containskey ( w ) ? ngrams . get ( w ) . add ( c ) . getvalue ( ) : c ) ; ngrams . put ( w , new int ( n ) ) ; ++ ngramsize ; count . get ( 0 ) . add ( c ) ; int aux = new int ( 0 ) ; if ( l >= count . size ( ) ) { aux . add ( c ) ; count . insertelementat ( aux , l ) ; } else { if ( count . get ( l ) != null ) { count . get ( l ) . add ( c ) ; } else { count . insertelementat ( new int ( c ) , l ) ; } } }
va	7	public void setquery ( string q ) { tmp = new vector < string [ ] > ( ) ; try { resultset rs = statement . executequery ( q ) ; resultsetmetadata meta = rs . getmetadata ( ) ; columns = meta . getcolumncount ( ) ; headers = new string [ columns ] ; for ( int i = 1 ; i <= columns ; i ++ ) headers [ i - 1 ] = meta . getcolumnname ( i ) ; while ( rs . next ( ) ) { string [ ] record = new string [ columns ] ; for ( int i = 0 ; i < columns ; i ++ ) record [ i ] = rs . getstring ( i + 1 ) ; tmp . addelement ( record ) ; } firetablechanged ( null ) ; } catch ( exception e ) { tmp = new vector < string [ ] > ( ) ; logfield . settext ( logfield . gettext ( ) + "\\nerror! time: " + system . currenttimemillis ( ) + "<litcomma>\\n" + e . getmessage ( ) ) ; } }
va	9	public static void main ( string [ ] args ) { short [ ] divisors = new short [ 10000002 ] ; for ( int i = 1 ; i <= 10000001 ; i ++ ) for ( int n = 1 ; i * n <= 10000001 ; n ++ ) divisors [ i * n ] ++ ; int count = 0 ; for ( int i = 1 ; i <= 10000000 ; i ++ ) if ( divisors [ i ] == divisors [ i + 1 ] ) count ++ ; system . out . print ( count ) ; }
va	4	public boolean checkregularexpression ( list < rule > rulelist ) { regularanalyzer analyzer = new regularanalyzer ( rulelist ) ; system . out . println ( "=====================regular expressions begin=====================" ) ; for ( int index = 0 ; index < analyzer . getregularrules ( ) . size ( ) ; index ++ ) { system . out . println ( analyzer . getregularrules ( ) . get ( index ) . tostring ( ) ) ; } system . out . println ( "=====================regular expressions end=====================" ) ; system . out . println ( "=====================nonregular expressions begin=====================" ) ; for ( int index = 0 ; index < analyzer . getnonregularrules ( ) . size ( ) ; index ++ ) { system . out . println ( analyzer . getnonregularrules ( ) . get ( index ) . tostring ( ) ) ; } system . out . println ( "=====================nonregular expressions end=====================" ) ; return analyzer . getnonregularrules ( ) . isempty ( ) ; }
va	3	static browsertab getpearltreestab ( ) { for ( browsertab t : tabs . values ( ) ) { if ( webcontent . isinpearltrees ( t . geturl ( ) ) ) { return t ; } } return null ; }
va	5	public boolean gethorizontalwall ( int x , int y ) { if ( x < 0 || x >= columns || y < 0 || y >= rows - 1 ) return false ; return hwalls [ x ] [ y ] ; }
va	9	public connection createconnection ( ) { if ( plugin . config . usemysql ) { try { class . forname ( "com.mysql.jdbc.driver" ) ; cn = drivermanager . getconnection ( "jdbc:mysql://" + plugin . config . dbpath , plugin . config . dbuser , plugin . config . dbpassword ) ; cn . setautocommit ( false ) ; return cn ; } catch ( sqlexception e ) { plugin . logger ( "could not be enabled: exception occured while trying to connect to db" , "error" ) ; sqlerrorhandler ( e ) ; if ( cn != null ) { plugin . logger ( "old connection still activated" , "error" ) ; try { cn . close ( ) ; plugin . logger ( "old connection that was still activated has been successfully closed" , "error" ) ; } catch ( sqlexception e2 ) { plugin . logger ( "failed to close old connection that was still activated" , "error" ) ; sqlerrorhandler ( e2 ) ; } } return null ; } catch ( classnotfoundexception e ) { errorlogger ( e . getmessage ( ) ) ; return null ; } } else if ( ! plugin . config . usemysql ) { try { try { class . forname ( "org.sqlite.jdbc" ) ; } catch ( classnotfoundexception cs ) { errorlogger ( cs . getmessage ( ) ) ; } cn = drivermanager . getconnection ( "jdbc:sqlite:plugins" + file . separator + "xpshop" + file . separator + "xpshop.sqlite" ) ; cn . setautocommit ( false ) ; return cn ; } catch ( sqlexception e ) { sqlerrorhandler ( e ) ; } } return null ; }
va	4	private static string [ ] getoneeditwords ( string from ) { list < string > oneeditwords = new linkedlist < string > ( ) ; char [ ] oneedits = from . tochararray ( ) ; for ( int i = 0 ; i < oneedits . length ; i ++ ) { for ( char c = 'a' ; c <= 'z' ; c ++ ) { if ( oneedits [ i ] == c ) { continue ; } char newoneedit [ ] = oneedits . clone ( ) ; newoneedit [ i ] = c ; oneeditwords . add ( new string ( newoneedit ) ) ; } } return oneeditwords . toarray ( new string [ 0 ] ) ; }
va	7	@ override public void oncombattick ( int x , int y , game game ) { singleplayergame spg = ( singleplayergame ) game ; list < entity > neighbors = spg . getsquareneighbors ( x , y , 1 ) ; for ( entity entity : neighbors ) { if ( entity . id == human . id ) { mortalentity mortal = ( ( mortalentity ) entity ) ; if ( mortal . damage ( 4 ) ) { spg . addanimation ( animation . hitanimationfor ( 4 , entity , spg ) ) ; zombie . damagedealt += 4 ; zombie . kills ++ ; human . deaths ++ ; zombie . tospawn . add ( new location ( entity . x , entity . y ) ) ; } } else if ( entity . id == wall . id ) { ( ( mortalentity ) entity ) . damage ( 2 ) ; } else if ( entity . id == juggernaut . id ) { if ( ( ( mortalentity ) entity ) . damage ( 3 ) ) { spg . addanimation ( animation . hitanimationfor ( 3 , entity , spg ) ) ; zombie . damagedealt += 3 ; zombie . kills ++ ; juggernaut . deaths ++ ; } } } }
va	1	private void open ( ) { int index = projlist . getselectedindex ( ) ; confpassframe cpf = new confpassframe ( opf , index ) ; cpf . setdefaultcloseoperation ( exit_on_close ) ; cpf . setvisible ( true ) ; }
va	9	protected void dopost ( httpservletrequest request , httpservletresponse response ) throws servletexception , ioexception { string questiontype = request . getparameter ( "newquestiontype" ) ; if ( questiontype . equals ( "" ) ) { requestdispatcher dispatch = request . getrequestdispatcher ( "createquiz/choosequestiontype.jsp" ) ; dispatch . forward ( request , response ) ; } else { httpsession session = request . getsession ( ) ; session . setattribute ( "questiontype" , questiontype ) ; string pagestring = "new_quiz_question" ; if ( questiontype . equals ( "question-response" ) ) { pagestring = "createquiz/new_quiz_question.jsp" ; } else if ( questiontype . equals ( "fill in the blank" ) ) { pagestring = "createquiz/new_quiz_question_fillinblank.jsp" ; } else if ( questiontype . equals ( "multiple choice" ) ) { pagestring = "createquiz/new_quiz_question_multichoice.jsp" ; } else if ( questiontype . equals ( "picture-response questions" ) ) { pagestring = "createquiz/new_quiz_question_picture.jsp" ; } else if ( questiontype . equals ( "multiple-answer questions" ) ) { pagestring = "createquiz/new_quiz_question_multianswer.jsp" ; } else if ( questiontype . equals ( "multiple choice with multiple answers" ) ) { pagestring = "createquiz/new_quiz_question_multichoiceandanswer.jsp" ; } else if ( questiontype . equals ( "matching" ) ) { pagestring = "createquiz/new_quiz_question_matching.jsp" ; } requestdispatcher dispatch = request . getrequestdispatcher ( pagestring ) ; dispatch . forward ( request , response ) ; } }
va	7	@ override public layoutmanager convertlayoutattribute ( attribute attr ) { string str = attr . getvalue ( ) . replaceall ( "\\\\s" , "" ) . tolowercase ( ) ; str = str . substring ( 0 , "tablelayout" . length ( ) ) ; str = str . replaceall ( "(tablelayout\\\\.)?fill" , string . valueof ( tablelayout . fill ) ) ; str = str . replaceall ( "(tablelayout\\\\.)?preferred" , string . valueof ( tablelayout . preferred ) ) ; if ( str . equals ( "" ) || str . equals ( "()" ) ) { return new tablelayout ( ) ; } else if ( str . matches ( "\\\\(\\\\{\\\\{" + numberregex + "(<litcomma>" + numberregex + ")\\\\}<litcomma>\\\\{" + numberregex + "(<litcomma>" + numberregex + ")\\\\}\\\\}\\\\)" ) ) { str = str . replaceall ( "[(\\\\(\\\\{)(\\\\}\\\\))]" , "" ) ; string [ ] xny = str . split ( "\\\\}<litcomma>\\\\{" ) ; string [ ] x = xny [ 0 ] . split ( "<litcomma>" ) ; string [ ] y = xny [ 1 ] . split ( "<litcomma>" ) ; double [ ] [ ] xnynum = new double [ 2 ] [ ] ; xnynum [ 0 ] = new double [ x . length ] ; for ( int i = 0 ; i < x . length ; i ++ ) { xnynum [ 0 ] [ i ] = double . valueof ( x [ i ] ) ; } xnynum [ 1 ] = new double [ y . length ] ; for ( int i = 0 ; i < y . length ; i ++ ) { xnynum [ 1 ] [ i ] = double . valueof ( y [ i ] ) ; } return new tablelayout ( xnynum ) ; } else { throw new illegalargumentexception ( ) ; } }
va	10	public static void main ( string [ ] args ) { try { questioncalculation qcal = new questioncalculation ( ) ; arraylist < integer > opd = new arraylist < integer > ( ) ; opd . add ( 12 ) ; opd . add ( 84 ) ; opd . add ( 45 ) ; opd . add ( 90 ) ; arraylist < character > opt = new arraylist < character > ( ) ; opt . add ( '+' ) ; opt . add ( '/' ) ; opt . add ( '-' ) ; qcal . setoperands ( opd ) ; qcal . setoperators ( opt ) ; qcal . setlength ( 4 ) ; qcal . setdifficulty ( 1 ) ; qcal . setid ( 2 ) ; qcal . settext ( "lorem ipsum dolor sit amet<litcomma> consectetur adipiscing elit. sed vulputate lacus eu odio ultricies porta." ) ; string str = new string ( ) ; try { str = qcal . encode ( ) ; questioncalculation qcal2 = questioncalculation . decode ( str ) ; str = qcal2 . encode ( ) ; } catch ( encodeexception ee ) { } catch ( decodeexception de ) { } questionfraction qfra = new questionfraction ( ) ; arraylist < integer > num = new arraylist < integer > ( ) ; num . add ( 12 ) ; num . add ( 84 ) ; num . add ( 45 ) ; num . add ( 90 ) ; arraylist < integer > dnm = new arraylist < integer > ( ) ; dnm . add ( 5 ) ; dnm . add ( 3 ) ; dnm . add ( 2 ) ; dnm . add ( 45 ) ; opt = new arraylist < character > ( ) ; opt . add ( '+' ) ; opt . add ( '/' ) ; opt . add ( '-' ) ; qfra . setnumerators ( num ) ; qfra . setdenominators ( dnm ) ; qfra . setoperators ( opt ) ; qfra . setlength ( 4 ) ; qfra . setdifficulty ( 3 ) ; qfra . setid ( 8 ) ; qfra . settext ( "sed vulputate lacus eu odio ultricies porta. lorem ipsum dolor sit amet<litcomma> consectetur adipiscing elit." ) ; questionequation qequ = new questionequation ( ) ; opd = new arraylist < integer > ( ) ; opd . add ( 12 ) ; opd . add ( 84 ) ; opd . add ( 45 ) ; opd . add ( 90 ) ; arraylist < integer > ukn = new arraylist < integer > ( ) ; ukn . add ( 0 ) ; ukn . add ( 0 ) ; ukn . add ( 1 ) ; ukn . add ( 0 ) ; opt = new arraylist < character > ( ) ; opt . add ( '+' ) ; opt . add ( '/' ) ; opt . add ( '=' ) ; qequ . setoperands ( opd ) ; qequ . setoperators ( opt ) ; qequ . setunknowns ( ukn ) ; qequ . setlength ( 4 ) ; questionpower qpow = new questionpower ( ) ; opt = new arraylist < character > ( ) ; opt . add ( '*' ) ; opt . add ( '/' ) ; opt . add ( '*' ) ; qpow . setoperand ( 4 ) ; qpow . setpowers ( dnm ) ; qpow . setoperators ( opt ) ; qpow . setlength ( 4 ) ; qpow . setdifficulty ( 3 ) ; qpow . setid ( 8 ) ; qpow . settext ( "sed vulputate lacus eu odio ultricies porta. lorem ipsum dolor sit amet<litcomma> consectetur adipiscing elit." ) ; exercise ex = new exercise ( ) ; ex . settitle ( "machin" ) ; ex . setid ( 3 ) ; object [ ] tval = { 78 , "ezr" , 9.32 , 34 , 'c' , 24 } ; ex . setwording ( new wording ( "lorem ipsum dolor sit amet<litcomma> consectetur adipiscing elit. sed vulputate lacus eu odio ultricies porta. cras blandit aliquam nisi at iaculis. pellentesque tincidunt neque et est ultrices<litcomma> nec luctus risus consequat. pellentesque sed est magna. phasellus ullamcorper ligula eu est vehicula<litcomma> sit amet hendrerit leo malesuada. cras fringilla lorem sit amet pharetra porttitor. nullam venenatis convallis nisi. nulla sem sem. " , tval ) ) ; ex . settype ( "calculation" ) ; ex . setdifficulty ( 4 ) ; ex . addquestion ( qcal ) ; ex . addquestion ( qfra ) ; ex . addquestion ( qpow ) ; ex . update_ready ( ) ; try { system . out . println ( "\\n\\n" + ex ) ; str = ex . encode ( ) ; system . out . println ( "\\n\\n" + str ) ; exercise e = exercise . decode ( str ) ; system . out . println ( e ) ; } catch ( encodeexception ee ) { } catch ( decodeexception de ) { } system . out . println ( qpow . solve ( ) ) ; system . out . println ( ) ; double d = 1.0 / 3 ; system . out . println ( d ) ; system . out . println ( d * 3 ) ; questionequation qe = questionequation . decode ( "#questionequation<9:3:7:3><1:0:2:2><-:*:=><4><-1><$<solve.>$><0>" ) ; double [ ] res = qe . solve ( ) ; system . out . println ( "\\n" + res [ 0 ] ) ; system . out . println ( res [ 1 ] ) ; } catch ( decodeexception ex1 ) { logger . getlogger ( testkernel57 . class . getname ( ) ) . log ( level . severe , null , ex1 ) ; } }
va	3	private void chooseplayeraction ( ) { system . out . println ( "choose an action for this round:" ) ; action action = getplayerchoicefromlegalactions ( ) ; if ( addplayeraction ( action ) ) { system . out . println ( player . getcombatdisplayname ( ) + " prepare a " + action . getname ( ) ) ; if ( ! possibleplayeractions . isempty ( ) ) { chooseplayeraction ( ) ; } } healplayer ( action ) ; }
va	4	public void updategrid ( game game ) { for ( int y = 0 ; y < yarraysize ; y ++ ) { for ( int x = 0 ; x < xarraysize ; x ++ ) { square sq = squareat ( x , y ) ; if ( gettreasuresquares ( game ) . contains ( sq ) ) sq . setcontainstreasure ( true ) ; else sq . setcontainstreasure ( false ) ; } } }
va	9	static public void msdur ( stringbuilder sb , int ms ) { if ( ms < 0 ) { sb . append ( "-" ) ; msdur ( sb , - ms ) ; } else if ( ms < 1000 ) { sb . append ( ms ) ; sb . append ( "ms" ) ; } else if ( ms < 10000 ) { tenths ( sb , ms , 1000 ) ; sb . append ( 's' ) ; } else if ( ms < 60000 ) { sb . append ( ms / 1000 ) ; sb . append ( 's' ) ; } else if ( ms < 600000 ) { tenths ( sb , ms , 60000 ) ; sb . append ( 'm' ) ; } else if ( ms < 3600000 ) { sb . append ( ms / 60000 ) ; sb . append ( 'm' ) ; } else if ( ms < 36000000 ) { tenths ( sb , ms , 3600000 ) ; sb . append ( 'h' ) ; } else if ( ms < 86400000 ) { sb . append ( ms / 3600000 ) ; sb . append ( 'h' ) ; } else { tenths ( sb , ms , 86400000 ) ; sb . append ( 'd' ) ; } }
va	1	public static listaccountpoliciesresultstaxunmarshaller getinstance ( ) { return instance ; }
va	10	@ override public object getvalueat ( int rowindex , int columnindex ) { if ( dataholder . getresult ( ) == null ) return null ; edasomindresult result = dataholder . getresult ( ) . get ( rowindex ) ; if ( columnindex == 0 ) return format ( result . getcalendarfrom ( ) ) ; else if ( columnindex == 1 ) return format ( result . getcalendarto ( ) ) ; else if ( columnindex == 2 ) return result . getsignificance ( ) ; else if ( columnindex == 3 ) return result . getmessage ( ) ; else new throwable ( ) . printstacktrace ( ) ; return null ; }
va	9	private static void monitorchannel ( final serversocket server ) { new thread ( new runnable ( ) { @ override public void run ( ) { try { while ( isrunning ) { socket socket = server . accept ( ) ; communication comm = new communication ( socket ) ; message msg = comm . readmessage ( ) ; communication clientcmm ; switch ( msg . getmsgtype ( ) ) { case utility . mapperdone : system . out . println ( "received mappers done message from task tracker[" + msg . gettasktrackerid ( ) + "] for job[" + msg . getjobid ( ) + "]." ) ; int maped = completedmapnodes . get ( msg . getjobid ( ) ) ; completedmapnodes . put ( msg . getjobid ( ) , ++ maped ) ; clientcmm = comms . get ( msg . getjobid ( ) ) ; clientcmm . sendmessage ( msg ) ; if ( maped == utility . tasktrackers . size ( ) ) { string jobid = msg . getjobid ( ) ; system . out . println ( "now run reducers for job[" + jobid + "]." ) ; for ( int i = 0 ; i < tasktrackercomms . size ( ) ; i ++ ) { list < reducebasiccontext > reducetasklist = tasktrackercontexts . get ( i ) . jobreducers . get ( jobid ) ; msg = new message ( utility . runreducer , reducetasklist ) ; tasktrackercomms . get ( i ) . sendmessage ( msg ) ; } } break ; case utility . conf : system . out . println ( "received a new job" ) ; submitjob ( msg . getconfiguration ( ) , comm ) ; break ; case utility . reducerdone : clientcmm = comms . get ( msg . getjobid ( ) ) ; clientcmm . sendmessage ( msg ) ; break ; case utility . tasktrackerheartbeat : break ; default : break ; } } server . close ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } } } ) . start ( ) ; }
va	5	public static void main ( string [ ] args ) { try { telephone htc = new telephone ( "353453454" ) ; network net = new polishnetwork ( "wielkopolskasiec" , 0.5f , 0.4f , 0.05f , area . pl_wielkopolska ) ; htc . setnetwork ( net ) ; message m = new smsmessage ( "258654125" , area . pl_mazowsze , "sdfsdfsdfsdf" ) ; htc . sendmessage ( m ) ; system . out . println ( "cost : " + htc . getbillingcost ( ) ) ; m = new smsmessage ( "258654125" , area . pl_mazowsze , "sdfsdfsdfs" ) ; htc . sendmessage ( m ) ; system . out . println ( "cost : " + htc . getbillingcost ( ) ) ; net = new freesms ( net , area . pl_mazowsze ) ; htc . setnetwork ( net ) ; m = new smsmessage ( "258654125" , area . pl_mazowsze , "sdfsdfsdfs" ) ; htc . sendmessage ( m ) ; system . out . println ( "cost : " + htc . getbillingcost ( ) ) ; m = new smsmessage ( "258654125" , area . pl_pomorze , "sdfsdfsdfs" ) ; htc . sendmessage ( m ) ; system . out . println ( "cost : " + htc . getbillingcost ( ) ) ; net = new freesms ( net , new area [ ] { area . pl_mazowsze , area . pl_pomorze } ) ; htc . setnetwork ( net ) ; m = new smsmessage ( "258654125" , area . pl_pomorze , "sdfsdfsdfs" ) ; htc . sendmessage ( m ) ; system . out . println ( "cost : " + htc . getbillingcost ( ) ) ; m = new callmessage ( "258654125" , area . pl_pomorze , 1 , 20 ) ; htc . sendmessage ( m ) ; system . out . println ( "cost : " + htc . getbillingcost ( ) ) ; system . out . println ( "----------------------" ) ; system . out . println ( "history : \\n" ) ; collection < message > msgs = htc . getbilling ( ) ; for ( message message : msgs ) { system . out . println ( message . getcost ( ) ) ; } system . out . println ( "bill cost : " + htc . getbillingcost ( ) ) ; } catch ( invalidphonenumberexception e ) { e . printstacktrace ( ) ; } catch ( invalidmessageexception e ) { e . printstacktrace ( ) ; } catch ( invalidareaexception e ) { e . printstacktrace ( ) ; } }
va	10	public void applymutations ( ) { for ( int b = 0 ; b < getorganism ( ) . getparts ( ) . size ( ) ; b ++ ) { for ( field f : getorganism ( ) . getparts ( ) . get ( b ) . getclass ( ) . getdeclaredfields ( ) ) { if ( getorganism ( ) . getmutables ( ) . getnameid ( f . getname ( ) ) != - 1 ) { try { if ( f . tostring ( ) . contains ( "double" ) ) { double value = 0 ; if ( sex [ getnameid ( f . getname ( ) ) ] == mutable . sex_unisex ) { value += getorganism ( ) . getmother ( ) . getmutables ( ) . getmutable ( f . getname ( ) ) . getvalue ( ) ; value += getorganism ( ) . getfather ( ) . getmutables ( ) . getmutable ( f . getname ( ) ) . getvalue ( ) ; value /= 2 ; value += ( math . random ( ) * getmutable ( f . getname ( ) ) . getvariation ( ) ) - ( getmutable ( f . getname ( ) ) . getvariation ( ) / 2. ) ; value = math . max ( 0 , value ) ; getmutable ( f . getname ( ) ) . setvalue ( value ) ; } else if ( sex [ getnameid ( f . getname ( ) ) ] == mutable . sex_male ) { value += getorganism ( ) . getfather ( ) . getmutables ( ) . getmutable ( f . getname ( ) ) . getvalue ( ) ; value += ( math . random ( ) * getmutable ( f . getname ( ) ) . getvariation ( ) ) - ( getmutable ( f . getname ( ) ) . getvariation ( ) / 2. ) ; value = math . max ( 0 , value ) ; getmutable ( f . getname ( ) ) . setvalue ( value ) ; } else if ( sex [ getnameid ( f . getname ( ) ) ] == mutable . sex_female ) { value += getorganism ( ) . getmother ( ) . getmutables ( ) . getmutable ( f . getname ( ) ) . getvalue ( ) ; value += ( math . random ( ) * getmutable ( f . getname ( ) ) . getvariation ( ) ) - ( getmutable ( f . getname ( ) ) . getvariation ( ) / 2. ) ; value = math . max ( 0 , value ) ; getmutable ( f . getname ( ) ) . setvalue ( value ) ; } f . setdouble ( ( object ) ( getorganism ( ) . getparts ( ) . get ( b ) ) , ( value ) ) ; } } catch ( illegalargumentexception ex ) { logger . getlogger ( organism . class . getname ( ) ) . log ( level . severe , null , ex ) ; } catch ( illegalaccessexception ex ) { logger . getlogger ( organism . class . getname ( ) ) . log ( level . severe , null , ex ) ; } } } } }
va	7	protected void startbroadmessage ( ) { while ( nostoprequested ) { try { response msg = broadmessages . take ( ) ; iterator < client > it = this . clients . values ( ) . iterator ( ) ; boolean iscode = false ; while ( it . hasnext ( ) ) { client socketer = it . next ( ) ; if ( ! iscode ) { iscode = true ; msg . codemsg ( socketer ) ; } socketer . addbroadmsg ( response . msgrespose ( msg ) ) ; try { workers . take ( ) . processresponse ( socketer ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } } } catch ( interruptedexception e ) { e . printstacktrace ( ) ; } } }
va	5	public boolean getverticalwall ( int x , int y ) { if ( x < 0 || x >= columns - 1 || y < 0 || y >= rows ) return false ; return vwalls [ x ] [ y ] ; }
va	1	public void unsetgetlang ( ) { this . getlang = null ; }
va	5	public void run ( ) { int testcase = 1 ; arraylist < segment > segments ; scanner scn = new scanner ( system . in ) ; string line = scn . nextline ( ) ; while ( line . compareto ( "#" ) != 0 ) { segments = new arraylist < segment > ( ) ; while ( line . compareto ( "#" ) != 0 ) { string [ ] values = line . split ( " " ) ; point start = new point ( ) ; point end = new point ( ) ; start . x = double . parsedouble ( values [ 0 ] ) ; start . y = double . parsedouble ( values [ 1 ] ) ; end . x = double . parsedouble ( values [ 2 ] ) ; end . y = double . parsedouble ( values [ 3 ] ) ; segments . add ( new segment ( start , end ) ) ; line = scn . nextline ( ) ; } list < point > intersections = bentleyottmann ( segments ) ; collections . sort ( intersections ) ; system . out . printf ( "test case %d:\\n%d corners\\n" , testcase ++ , intersections . size ( ) ) ; for ( point p : intersections ) { system . out . println ( p . tostring ( ) ) ; } line = scn . nextline ( ) ; } }
va	4	private void loaddoc ( ) { string helpdoc = "" ; try ( bufferedreader bw = new bufferedreader ( new filereader ( manager . docfile ) ) ) { stringbuilder sb = new stringbuilder ( ) ; string line ; while ( ( line = bw . readline ( ) ) != null ) { sb . append ( line ) ; } helpdoc = sb . tostring ( ) ; } catch ( ioexception ex ) { helpdoc = "<h1>document file do not exist!</h1>" ; } web . getengine ( ) . loadcontent ( helpdoc ) ; }
va	3	private void jbutton5actionperformed ( java . awt . event . actionevent evt ) { try { int p = joptionpane . showconfirmdialog ( null , "do you really want to delete?" , "delete" , joptionpane . yes_no_option ) ; if ( p == 0 ) { int i = jtable1 . getselectedrow ( ) ; tenant n = ( tenant ) tenanttablemodel . tenants . get ( i ) ; n . getroom ( ) . setstatus ( "free" ) ; roomjpacontroller . edit ( n . getroom ( ) ) ; tenantjpacontroller . destroy ( n . getid ( ) ) ; tenanttablemodel . tenants . remove ( i ) ; tenanttablemodel . firetabledatachanged ( ) ; } } catch ( exception f ) { f . printstacktrace ( ) ; } this . parent . getroomview1 ( ) . refresh ( ) ; this . parent . getbookingviews1 ( ) . refresh ( ) ; this . parent . gettenantviews1 ( ) . refresh ( ) ; }
va	4	@ override public boolean doaction ( actiontype type , entity e ) { if ( type == actiontype . move && e instanceof entityenemy ) { entityenemy enemy = ( entityenemy ) e ; int damage = aicontroller . calculateattackpower ( enemy , this ) ; logmessage ( "the " + enemy . getname ( ) + " hits you for " + damage + " damage" ) ; this . dodamage ( damage ) ; if ( isdead ( ) ) { logmessage ( "you are dead!!" ) ; } } return false ; }
va	6	public static final string getmessage ( int id ) { if ( instance == null ) { if ( exceptionhelper . isclassavailable ( "java.util.resourcebundle" ) ) { try { instance = ( messagecatalog ) class . forname ( "org.eclipse.paho.client.mqttv3.internal.resourcebundlecatalog" ) . newinstance ( ) ; } catch ( exception e ) { return "" ; } } else if ( exceptionhelper . isclassavailable ( "org.eclipse.paho.client.mqttv3.internal.midpcatalog" ) ) { try { instance = ( messagecatalog ) class . forname ( "org.eclipse.paho.client.mqttv3.internal.midpcatalog" ) . newinstance ( ) ; } catch ( exception e ) { return "" ; } } } return instance . getlocalizedmessage ( id ) ; }
va	5	@ override public void mousereleased ( int key , int x , int y ) { if ( x >= this . x && x <= this . x + width && y >= this . y && y <= this . y + height ) { isactive = true ; } else { isactive = false ; } }
va	8	protected void resolveautomataname ( element auto , map < string , element > autosmap , map < element , timedautomata < c > > autos ) { string name = auto . getattributevalue ( automata_name_tag ) ; if ( name == null ) throw new runtimeexception ( "automata has no name: " + auto . tostring ( ) ) ; if ( autos . containskey ( name ) ) throw new runtimeexception ( "there is more than one automata with the name: " + name ) ; autosmap . put ( name , auto ) ; autos . put ( auto , new timedautomata < c > ( ) ) ; for ( element - : auto . getchildren ( automata_tag ) ) resolveautomataname ( - , autosmap , autos ) ; }
va	2	public void ondisable ( ) { try { fm . saveplayerdata ( new file ( getdatafolder ( ) , "players" ) ) ; } catch ( ioexception ioe ) { ioe . printstacktrace ( ) ; } }
va	2	private void gravarxml ( string host , string porta , string usuario , string senha , string antigaconfiguracao ) { string xmlarquivo = "" ; system . out . println ( "antigaconfiguracao:\\n\\n" + antigaconfiguracao ) ; scanner gravador = new scanner ( antigaconfiguracao ) ; gravador . usedelimiter ( "\\n" ) ; while ( gravador . hasnext ( ) ) { string novoarquivo = gravador . next ( ) + "\\n" ; novoarquivo = novoarquivo . replace ( "url\\">jdbc:mysql://localhost:3306/aluno</property>" , "url\\">jdbc:mysql://" + host + ":" + porta + "/aluno</property>" ) ; novoarquivo = novoarquivo . replace ( "username\\">root</property>" , "username\\">" + usuario + "</property>" ) ; novoarquivo = novoarquivo . replace ( "password\\">tah038</property>" , "password\\">" + senha + "</property>" ) ; xmlarquivo += novoarquivo ; } system . out . println ( "\\nnovaconfiguracao:\\n\\n" + xmlarquivo ) ; }
va	6	private void consolecommands ( string cmd ) { if ( cmd . equals ( "night" ) ) gametime = 18000 ; else if ( cmd . equals ( "day" ) ) gametime = 0 ; else if ( cmd . startswith ( "need" ) ) { string [ ] split = cmd . split ( "\\\\s+" ) ; if ( split . length == 3 ) { item item = items . getitemfromuin ( split [ 1 ] ) ; if ( item != null ) { itemstack stack = new itemstack ( item , integer . valueof ( split [ 2 ] ) ) ; player . setstackinnextavailableslot ( stack ) ; } } } consoleprint = "" ; isconsoledisplayed = false ; }
va	7	private void percolatingdown ( int k ) { anytype tmp = heap [ k ] ; int child ; for ( ; 2 * k <= size ; k = child ) { child = 2 * k ; if ( child != size && heap [ child ] . compareto ( heap [ child + 1 ] ) > 0 ) child ++ ; if ( tmp . compareto ( heap [ child ] ) > 0 ) heap [ k ] = heap [ child ] ; else break ; } heap [ k ] = tmp ; }
va	3	public static resultadopodeandar podeandar ( acao action , ambienteexecucao ambiente , integer passos ) { resultadopodeandar retorno = null ; if ( action instanceof acaoparafrente ) { retorno = podeandarfrente ( ( acaoparafrente ) action , ambiente , passos ) ; } else if ( action instanceof acaoparatras ) { retorno = podeandartras ( ( acaoparatras ) action , ambiente , passos ) ; } return retorno ; }
va	3	public static boolean isscratchimagevalid ( image img ) { try { boolean lost = ( boolean ) trymethod ( img , "contentslost" , new object [ ] { } ) ; if ( lost == null ) return true ; return ! lost . booleanvalue ( ) ; } catch ( java . security . accesscontrolexception e ) { return true ; } }
va	1	public string getgetlang ( ) { return this . getlang ; }
va	2	protected static void propagate_all_lookaheads ( ) throws internal_error { for ( enumeration st = all ( ) ; st . hasmoreelements ( ) ; ) { ( ( lalr_state ) st . nextelement ( ) ) . propagate_lookaheads ( ) ; } }
va	10	private void performopen ( ) { jfilechooser chooser = new jfilechooser ( lastsave ) ; chooser . setfilefilter ( getfilefilter ( ) ) ; chooser . setfileselectionmode ( jfilechooser . files_only ) ; chooser . showopendialog ( this ) ; file file = chooser . getselectedfile ( ) ; string errormessage = null ; if ( file != null && file . isfile ( ) && file . exists ( ) ) { try ( fileinputstream fis = new fileinputstream ( file ) ; objectinputstream ois = new objectinputstream ( fis ) ) { object o = ois . readobject ( ) ; if ( o instanceof gamedata ) { gamedata d = ( gamedata ) o ; gcp . setcontents ( d . general ) ; scp . setcontents ( d . shop ) ; lcp . setcontents ( d . levels ) ; tcp . setcontents ( d . towers ) ; ecp . setcontents ( d . enemies ) ; pcp . setcontents ( d . projectiles ) ; lastsave = file ; } else { errormessage = "the file does not contain valid game data." ; } } catch ( ioexception ie ) { errormessage = "the file could not be read from the drive." ; } catch ( classnotfoundexception e ) { errormessage = "the contents of the file are incompatible with this computer." ; } finally { if ( errormessage != null ) { joptionpane . showmessagedialog ( this , errormessage , "error" , joptionpane . error_message ) ; } } } }
va	10	private void autosignatorn ( final string abrev , final int torn ) { int offset = 0 ; if ( torn > 0 ) { offset = 7 ; } rowmodel rm = client . getguardiesclient ( ) . getguardiescollection ( ) . gethorari ( abrev , datactrl . getintdia ( ) , datactrl . getdatasql ( ) , torn > 0 ) ; time ara = client . getmysql ( ) . getservertime ( ) ; for ( int i = 0 ; i < 7 ; i ++ ) { double lag = ( ara . gettime ( ) - client . getdatescollection ( ) . gethoresclase ( ) [ i + offset ] . gettime ( ) ) / ( 60000. ) ; system . out . println ( "yielding a lag of " + lag ) ; cellmodel cm = rm . cells [ i + 1 ] ; if ( cm . type == cellmodel . type_normal ) { if ( lag < 15 ) { system . out . println ( cm . tostring ( ) ) ; client . getguardiesclient ( ) . getguardiescollection ( ) . updatehorari ( abrev , datactrl . getintdia ( ) , datactrl . getdatasql ( ) , i + 1 , 1 , torn > 0 ) ; system . out . println ( "updated horari" ) ; } } else if ( cm . type == cellmodel . type_guardia ) { } } }
va	6	public static void main ( string [ ] args ) { scanner keyboard = new scanner ( system . in ) ; int button ; button = keyboard . nextint ( ) ; switch ( button ) { case 1 : system . out . println ( "cola is served" ) ; break ; case 2 : system . out . println ( "lemonade is served" + ' ' ) ; break ; case 3 : system . out . println ( "water is served" + ' ' ) ; break ; case 6 : system . out . println ( "cola and lemonade is served" + ' ' ) ; break ; case 9 : system . out . println ( "refund" ) ; break ; default : system . out . println ( "no such beverage" ) ; break ; } }
va	1	public void removemodel ( ) { registeredmodel = null ; }
va	4	public boolean contains ( string s ) { if ( srgname . contains ( s ) ) return true ; else for ( string param : parameters ) if ( param . contains ( s ) ) return true ; return false ; }
va	2	public static string format ( date date , string pattern ) { dateformat mydateformat = new simpledateformat ( pattern ) ; try { return mydateformat . format ( date ) ; } catch ( exception e ) { return date . tostring ( ) ; } }
va	6	public int getminimum ( ) { int res = - 1 ; int min = - 1 ; for ( int i = 0 ; i < result . length ; i ++ ) { if ( result [ i ] != - 1 && visited [ i ] != 1 && ( result [ i ] < min || min == - 1 ) ) { min = result [ i ] ; res = i ; } } return res ; }
va	1	public void addview ( abstractpanelview view ) { registeredview = view ; }
va	2	private configmanager ( ) { try { system . out . println ( classloader . getsystemclassloader ( ) . getresource ( "" ) ) ; this . pathtojar = urldecoder . decode ( new file ( configmanager . class . getprotectiondomain ( ) . getcodesource ( ) . getlocation ( ) . touri ( ) ) . getparent ( ) , "utf-8" ) ; this . chatlogsdir = this . pathtojar + file . separatorchar + "chatlogs" ; logger . getlogger ( configmanager . class . getname ( ) ) . log ( level . info , "path to jar: " + this . pathtojar ) ; } catch ( unsupportedencodingexception | urisyntaxexception ex ) { logger . getlogger ( configmanager . class . getname ( ) ) . log ( level . severe , null , ex ) ; } readproperties ( ) ; }
va	3	@ override public void actionperformed ( actionevent e ) { if ( e . getsource ( ) == okbtn ) { ok = true ; formula = new string [ flds . length ] ; for ( int i = 0 ; i < flds . length ; i ++ ) formula [ i ] = flds [ i ] . gettext ( ) ; } setvisible ( false ) ; }
va	9	public static string deleteany ( string instring , string charstodelete ) { if ( ! haslength ( instring ) || ! haslength ( charstodelete ) ) { return instring ; } stringbuilder sb = new stringbuilder ( ) ; for ( int i = 0 ; i < instring . length ( ) ; i ++ ) { char c = instring . charat ( i ) ; if ( charstodelete . indexof ( c ) == - 1 ) { sb . append ( c ) ; } } return sb . tostring ( ) ; }
te	7	public void connecttomainserver ( string ip , int listeningport ) { boolean wait = true ; string message = protocol . getmainserverconnectionmessage ( ) ; system . out . println ( message ) ; try { string response = mediator . sendtomainserver ( message ) ; int responsecode = protocol . parsemainservermessage ( response ) ; while ( wait ) { wait = false ; switch ( responsecode ) { case battleshipclient . wait : { protocol . getclienteventlistener ( ) . onwait ( "server je prihvatio zahtev. cekaju se igraci..." ) ; response = mediator . receive ( ) ; responsecode = protocol . parsemainservermessage ( response ) ; wait = true ; } break ; case battleshipclient . start : { string peer1ip = protocol . getpeer1ip ( ) ; int peer1port = protocol . getpeer1port ( ) ; string peer2ip = protocol . getpeer2ip ( ) ; int peer2port = protocol . getpeer2port ( ) ; system . out . println ( "peers " + peer1ip + peer1port + " " + peer2ip + peer2port ) ; mediator . initializepeerscomunnication ( peer1ip , peer1port , peer2ip , peer2port ) ; protocol . getclienteventlistener ( ) . onstart ( "povezivanje sa igracima..." ) ; boolean isok = mediator . sendtopeers ( protocol . getsynmessage ( ) ) ; if ( ! isok ) { system . out . println ( "error!" ) ; break ; } } break ; case battleshipclient . bye : { } break ; case battleshipclient . error : { } break ; } } } catch ( ioexception e ) { e . printstacktrace ( ) ; } }
te	4	public boolean createincident ( beincident incident ) { if ( incident == null ) { bllerror . getinstance ( ) . createincidenterror ( ) ; return false ; } try { dalcreate . createincident ( incident ) ; } catch ( sqlexception ex ) { bllerror . getinstance ( ) . createincidenterror ( ) ; return false ; } return true ; }
te	7	public tokenizerproperty startswithsequencecommentorstring ( dataprovider dataprovider ) throws tokenizerexception , nullpointerexception { if ( dataprovider . getlength ( ) > 0 ) { int len = dataprovider . getlength ( ) ; char startchar = getstartchar ( dataprovider . getcharat ( 0 ) ) ; propertylist list = getlist ( startchar ) ; while ( list != null ) { tokenizerproperty prop = list . _property ; string image = prop . getimages ( ) [ 0 ] ; int imagelen = image . length ( ) ; if ( _useexactlength && imagelen < len ) { break ; } else if ( imagelen <= len && compareprefix ( image , dataprovider , 1 ) == 0 ) { return prop ; } list = list . _next ; } } return null ; }
te	8	@ override public void actionperformed ( actionevent e ) { string cmd = e . getactioncommand ( ) ; switch ( cmd ) { case filtrar : ctrlinformacion . filtrarcontratos ( ) ; break ; case notas_apto_ver : ctrlinformacion . cargardialogovernotasparticulares ( ) ; break ; case notas_gral_ver : ctrlinformacion . cargardialogovernotasgenerales ( ) ; break ; case nota_apto_nuevo : ctrlinformacion . cargardialogonuevanotaparticular ( ) ; break ; case nota_gral_nuevo : ctrlinformacion . cargardialogonuevanotageneral ( ) ; break ; case recargar_contratos : ctrlinformacion . cargarcontratos ( ) ; break ; case ver_datos_responsables : ctrlinformacion . cargardialogoverdatosresponsables ( ) ; break ; case ver_telefonos : ctrlinformacion . cargardialogovertelefonos ( ) ; break ; } }
te	3	protected int getpenetrationadjusteddamage ( action attack , action defend , combatant defender ) { double vulnmult = getvulnerabilitymultiplier ( attack , defender ) ; int defendpower = defend != null && defend . gettype ( ) . equals ( actiontype . block ) ? defend . getpower ( ) : 0 ; return ( int ) math . max ( 0 , attack . getdamage ( ) * vulnmult - math . max ( 0 , defendpower - attack . getpenetration ( ) * vulnmult ) ) ; }
te	10	private void respondtomouseclick ( int x , int y , int button ) { actionpainter . clearactions ( ) ; if ( x < leftmargin || x > rightmargin || y < topmargin || y > bottommargin ) { system . out . println ( "click outside boundaries: " + x + "<litcomma> " + y ) ; } else { x = x - leftmargin ; y = y - topmargin ; int xsquare = x / cell_size ; int ysquare = y / cell_size ; point p = new point ( xsquare , ysquare ) ; list < action > acts = actions . getactions ( p ) ; if ( acts != null && acts . size ( ) > 0 ) { if ( button == mouseevent . button1 ) { for ( action a : acts ) { if ( a . gettype ( ) == default_action ) { performaction ( a ) ; return ; } } } showactionmenu ( acts , x , y ) ; } } }
te	7	public string getclobcolumn ( resultset rs , int columnindex ) throws sqlexception { try { clob clob = rs . getclob ( columnindex ) ; if ( clob == null ) { return null ; } stringbuffer ret = new stringbuffer ( ) ; inputstream is = clob . getasciistream ( ) ; if ( is == null ) { return null ; } else { byte buffer [ ] = new byte [ 64 ] ; int c = is . read ( buffer ) ; while ( c > 0 ) { ret . append ( new string ( buffer , 0 , c ) ) ; c = is . read ( buffer ) ; } return ret . tostring ( ) ; } } catch ( ioexception e ) { throw new sqlexception ( "failed to read clob column due to ioexception: " + e . getmessage ( ) ) ; } }
te	8	public accesscontrolpolicy getaccesscontrolpolicy ( inputstream is ) throws exception { element root ; try { root = getrootelement ( is ) ; } catch ( exception e ) { throw e ; } nodelist ownerlist = root . getelementsbytagname ( "owner" ) ; element owner = ( element ) ownerlist . item ( 0 ) ; node namenode = owner . getelementsbytagname ( "displayname" ) . item ( 0 ) ; string displayname = namenode . gettextcontent ( ) ; node idnode = owner . getelementsbytagname ( "id" ) . item ( 0 ) ; string id = idnode . gettextcontent ( ) ; nodelist accesscontrollist = root . getelementsbytagname ( "accesscontrollist" ) ; element accesscontrol = ( element ) accesscontrollist . item ( 0 ) ; string grant = null ; nodelist grants = accesscontrol . getelementsbytagname ( "grant" ) ; int grantoptions = grants . getlength ( ) ; if ( grantoptions == 1 ) grant = accesscontrollist . private . tostring ( ) ; else if ( grantoptions == 2 ) grant = accesscontrollist . readonly . tostring ( ) ; else if ( grantoptions == 3 ) grant = accesscontrollist . public . tostring ( ) ; else throw new exception ( "unknown acl." ) ; ioutils . safelycloseinputstream ( is ) ; return new accesscontrolpolicy ( displayname , id , grant ) ; }
te	2	public static void main ( string [ ] args ) { try { compiler c = new compiler ( args ) ; c . compile ( ) ; } catch ( compilererror e ) { system . err . println ( e . getmessage ( ) ) ; system . exit ( - 1 ) ; } }
te	6	private static double getaverage ( string query ) { int totalscore = 0 ; int numquizzes = 0 ; resultset rs = mydb . querydatabase ( query ) ; try { while ( rs . next ( ) ) { int score = rs . getint ( "score" ) ; totalscore += score ; numquizzes ++ ; } } catch ( sqlexception e ) { e . printstacktrace ( ) ; } if ( numquizzes == 0 ) return 0 ; return ( double ) totalscore / ( double ) numquizzes ; }
te	2	public static void setgrasscreationprobability ( double grass_creation_probability ) { if ( grass_creation_probability >= 0 ) simulator . grass_creation_probability = grass_creation_probability ; }
te	3	public static void main ( string [ ] args ) { matrix = new int [ length ] [ length ] ; random random = new random ( system . currenttimemillis ( ) ) ; for ( int i = 0 ; i < length ; i ++ ) { for ( int j = 0 ; j < length ; j ++ ) { matrix [ i ] [ j ] = random . nextint ( 10 ) ; } } printmatrix ( ) ; sums = getsums ( ) ; printsum ( 0 , 0 , 0 , 0 ) ; printsum ( 0 , 0 , 1 , 1 ) ; printsum ( 1 , 1 , 2 , 2 ) ; printsum ( 1 , 2 , 3 , 3 ) ; }
te	8	public point getelementorigin ( integer x , integer y , dimension size ) { if ( myorientation == orientations . left ) { return new point ( gettftxsize ( ) - y - size . height , x ) ; } if ( myorientation == orientations . right ) { return new point ( y , gettftysize ( ) - x - size . width ) ; } if ( myorientation == orientations . upside ) { return new point ( gettftxsize ( ) - x - size . width , gettftysize ( ) - y - size . height ) ; } return new point ( x , y ) ; }
te	1	public void requestpoints ( int id , int points ) { this . pointsrequested = true ; this . id = id ; this . requestedpointsleft = points ; this . justrequested = true ; }
te	8	@ override public void actionperformed ( actionevent e ) { jbutton b = ( jbutton ) e . getsource ( ) ; if ( b == btnok ) { team . points = float . parsefloat ( tfpoints . gettext ( ) ) ; team . score = integer . parseint ( tfscore . gettext ( ) ) ; team . teamname = tfname . gettext ( ) ; team . teamcolor = new color ( slred . getvalue ( ) , slgreen . getvalue ( ) , slblue . getvalue ( ) ) ; listener . updateteam ( ) ; this . setvisible ( false ) ; } else if ( b == btnp10 ) { int score = integer . parseint ( tfscore . gettext ( ) ) ; score += 10 ; tfscore . settext ( integer . tostring ( score ) ) ; } else if ( b == btnp6 ) { int score = integer . parseint ( tfscore . gettext ( ) ) ; score += 6 ; tfscore . settext ( integer . tostring ( score ) ) ; } else if ( b == btnp4 ) { int score = integer . parseint ( tfscore . gettext ( ) ) ; score += 4 ; tfscore . settext ( integer . tostring ( score ) ) ; } else if ( b == btnp3 ) { int score = integer . parseint ( tfscore . gettext ( ) ) ; score += 3 ; tfscore . settext ( integer . tostring ( score ) ) ; } else if ( b == btnp2 ) { int score = integer . parseint ( tfscore . gettext ( ) ) ; score += 2 ; tfscore . settext ( integer . tostring ( score ) ) ; } else if ( b == btnp1 ) { int score = integer . parseint ( tfscore . gettext ( ) ) ; score += 1 ; tfscore . settext ( integer . tostring ( score ) ) ; } }
te	5	public void output ( map < string , object > obj ) throws ioexception { if ( groupby != null ) { list < object > list = new arraylist < object > ( ) ; for ( string col : groupby ) { object v = obj . get ( col ) ; list . add ( v != null ? v : "" ) ; } groups . put ( md5 . md5 ( list ) , obj ) ; } else if ( update ) { this . delegate . output ( obj ) ; } }
te	7	private void validateergebnis ( string torea , string toreb ) { try { int a = integer . parseint ( torea ) ; int b = integer . parseint ( toreb ) ; if ( a < 0 || a > 10 || b < 0 || b > 10 || a == b ) { geterrormessages ( ) . add ( "tore/ergenis machen keinen sinn. es muss einen gewinner geben und es k\xf6nnen maximal 10 tore geschossen werden." ) ; } } catch ( numberformatexception e ) { geterrormessages ( ) . add ( "ung\xfcltige tore eingegeben." ) ; } }
te	3	private void addzombierelatedmessages ( int zombiesencoutered , int zombieskilled ) { if ( zombiesencoutered == 0 ) this . messagestodisplayonceraidisover . add ( "no zombies were encoutered" ) ; else if ( zombieskilled == 1 ) this . messagestodisplayonceraidisover . add ( "one lonely zombie has been killed" ) ; else this . messagestodisplayonceraidisover . add ( zombieskilled + " zombies have been killed" ) ; }
te	6	private static boolean isoperator ( string text ) { if ( text . length ( ) != 1 ) return false ; char symbol = text . charat ( 0 ) ; char [ ] operations = "+-*/^" . tochararray ( ) ; for ( char ch : operations ) { if ( ch == symbol ) return true ; } return false ; }
te	2	public static void setrabbitcreationprobability ( double rabbit_creation_probability ) { if ( rabbit_creation_probability >= 0 ) simulator . rabbit_creation_probability = rabbit_creation_probability ; }
te	1	public client ( ) throws unknownhostexception , ioexception { socket = new socket ( host , port ) ; log . info ( "===============>client start!" ) ; }
te	10	private void appendtag ( stringbuilder builder ) { builder . append ( "-----------------------tag relate------------------------\\n" ) ; int len = 15 ; setw ( builder , "" , len ) ; set < integer > keys = tagmap . keyset ( ) ; integer [ ] labels = keys . toarray ( new integer [ keys . size ( ) ] ) ; for ( int label : labels ) { setw ( builder , ergate . core . tag . tagmapper . i2tag ( label ) , len ) ; } builder . append ( "\\n" ) ; tag tag ; long temp ; for ( int i = 0 ; i < labels . length ; i ++ ) { setw ( builder , ergate . core . tag . tagmapper . i2tag ( labels [ i ] ) + ":" , len ) ; for ( int j = 0 ; j < labels . length ; j ++ ) { tag = tagmap . get ( labels [ i ] ) ; if ( tag == null ) { setw ( builder , "" , len ) ; } else { temp = tag . trans . getval ( labels [ j ] ) ; if ( temp != null ) { setw ( builder , temp , len ) ; } else { setw ( builder , "" , len ) ; } } } builder . append ( "\\n" ) ; } builder . append ( "\\n" ) ; }
te	9	public static int [ ] getallevens ( int [ ] array ) { int counteven = 0 ; for ( int num : array ) { if ( num % 2 == 0 ) { counteven ++ ; } } int [ ] even = new int [ counteven ] ; int i = 0 ; for ( int num : array ) { if ( num % 2 == 0 ) { even [ i ] = num ; i ++ ; } } return even ; }
te	7	private mvar simulatingvariablethroughreference ( string name , object variable , object valuedefault , boolean stackingneeded ) { if ( variable instanceof mvar ) { return ( mvar ) variable ; } else { mvar var = var ( name ) ; if ( stackingneeded ) { newvar ( var ) ; } if ( variable != null ) { var . set ( variable ) ; } else if ( valuedefault != null ) { var . set ( valuedefault ) ; } return var ; } }
te	1	public void addquizzenfromfiletodb ( ) { leesquizzenvanbestand ( ) ; }
te	5	public boolean validcoordinate ( coordinate coord ) { if ( coord . getrow ( ) < 0 || coord . getrow ( ) > clientgame . getmap ( ) . getnumrows ( ) || coord . getcol ( ) < 0 || coord . getcol ( ) > clientgame . getmap ( ) . getnumcols ( ) ) return false ; return true ; }
te	6	public static void main ( string [ ] args ) { for ( long i = 1000 ; i < 10000 ; i ++ ) { for ( long j = 1 ; ( 2 * j + i ) < 10000 ; j ++ ) { long ii = i + j ; long iii = ii + j ; if ( ! allprime ( i , ii , iii ) ) { continue ; } if ( numberutil . ispermutation ( i , ii , iii ) ) { system . out . println ( "..perms[" + j + "]:" + i + "<litcomma> " + ii + "<litcomma> " + iii + ":" + i + ii + iii ) ; } } } }
te	5	void createatree ( int x , int y , int type ) { if ( nrof ( new water ( ) , x , y ) == 0 ) { if ( nrof ( new stone ( ) , x , y ) == 0 ) { double prio = ( y * 10 ) - ( x ) + math . random ( ) * 2 ; if ( x < 90 && y < 90 ) { boolean fail = false ; map [ x ] [ y + 2 ] . add ( new tree ( type , 0 , prio , false ) ) ; map [ x ] [ y + 1 + 2 ] . add ( new tree ( type , 1 , prio , false ) ) ; map [ x ] [ y + 2 + 2 ] . add ( new tree ( type , 2 , prio , false ) ) ; map [ x + 1 ] [ y + 2 ] . add ( new tree ( type , 3 , prio , false ) ) ; map [ x + 1 ] [ y + 1 + 2 ] . add ( new tree ( type , 4 , prio , false ) ) ; map [ x + 1 ] [ y + 2 + 2 ] . add ( new tree ( type , 5 , prio , false ) ) ; map [ x + 2 ] [ y + 2 ] . add ( new tree ( type , 6 , prio , false ) ) ; map [ x + 2 ] [ y + 1 + 2 ] . add ( new tree ( type , 7 , prio , false ) ) ; map [ x + 2 ] [ y + 2 + 2 ] . add ( new tree ( type , 8 , prio , false ) ) ; map [ x ] [ y ] . add ( new tree ( type , 0 , prio , true ) ) ; map [ x ] [ y + 1 ] . add ( new tree ( type , 1 , prio , true ) ) ; map [ x ] [ y + 2 ] . add ( new tree ( type , 2 , prio , true ) ) ; map [ x + 1 ] [ y ] . add ( new tree ( type , 3 , prio , true ) ) ; map [ x + 1 ] [ y + 1 ] . add ( new tree ( type , 4 , prio , true ) ) ; map [ x + 1 ] [ y + 2 ] . add ( new tree ( type , 5 , prio , true ) ) ; map [ x + 2 ] [ y ] . add ( new tree ( type , 6 , prio , true ) ) ; map [ x + 2 ] [ y + 1 ] . add ( new tree ( type , 7 , prio , true ) ) ; map [ x + 2 ] [ y + 2 ] . add ( new tree ( type , 8 , prio , true ) ) ; } } } }
te	3	public bitmapfont ( string bitmapfile , string fontfile ) { characters = new arraylist < bitmapcharacter > ( ) ; try { file f = new file ( bitmapfile ) ; bufferedimage image = imageio . read ( f ) ; bufferedinputstream fin = new bufferedinputstream ( ( new fileinputstream ( fontfile ) ) ) ; string str = "" ; while ( ! ( str = readoneline ( fin ) ) . equals ( "" ) ) { string command = str . substring ( 0 , str . length ( ) - 1 ) ; handlecommand ( command , image ) ; } fin . close ( ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } }
te	6	protected indexsearcher preparesearcher ( ) throws ioexception { if ( isshutdown ( ) ) { return null ; } if ( m_searcher == null ) { close ( ) ; try { m_searcher = new indexsearcher ( indexreader . open ( m_directory ) ) ; } catch ( final indexnotfoundexception exc ) { logger . log ( level . warning , "the index does not exist yet." ) ; throw new ioexception ( "the index does not exist yet." , exc ) ; } } return m_searcher ; }
te	6	public creature buildcreature ( list < string > filelines ) { if ( filelines == null || filelines . isempty ( ) ) { system . err . println ( "empty class file" ) ; return null ; } creature creature = new creature ( ) ; try { fileparser . parselines ( creature , filelines ) ; } catch ( illegalargumentexception | illegalaccessexception | nosuchfieldexception | securityexception | invocationtargetexception | nosuchmethodexception e ) { e . printstacktrace ( ) ; } return creature ; }
te	4	public boolean give ( interactable target ) { if ( target != null && target instanceof item ) { ( ( item ) target ) . makevorpal ( ) ; if ( world . ears . areplugged ( ) ) { system . out . println ( "the wizard mumbles: \\"mbmmm numbum bb!\\"" ) ; system . out . println ( "he hands back your new " + target . name + "." ) ; system . out . println ( "wizard: \\"mumnub numb mbn mbmn bmb.\\"" ) ; } else { system . out . println ( "the wizard mumbles: \\"oobaday<litcomma> oobuday<litcomma> ack!\\"" ) ; system . out . println ( "he hands back your new " + target . name + "." ) ; system . out . println ( "wizard: \\"may it serve you well.\\"" ) ; } system . out . println ( "he snaps his fingers and vanishes." ) ; world . jubjublair . aspects . remove ( this ) ; return true ; } return false ; }
te	6	public void insert ( int id , double dd ) { node nnode = new node ( ) ; nnode . idata = id ; nnode . ddata = dd ; if ( root == null ) { root = nnode ; } else { node current = root ; node parent ; while ( true ) { parent = current ; if ( id < current . idata ) { current = current . leftchild ; if ( current == null ) { parent . leftchild = nnode ; return ; } } else { current = current . rightchild ; if ( current == null ) { parent . rightchild = nnode ; return ; } } } } }
te	3	public gameentity getselectedentity ( ) { gameentity temp = null ; for ( int i = 0 ; i < entities . size ( ) ; i ++ ) if ( entities . get ( i ) . getselected ( ) ) temp = entities . get ( i ) ; return temp ; }
te	10	private static boolean processdecision ( string decision ) { solution solution ; solutiontype lastsolution = situation . getlastsolution ( ) . getsolutiontype ( ) ; if ( decision . equals ( "c" ) ) { if ( lastsolution == solutiontype . check ) { solution = new solution ( solutiontype . check ) ; } else { solution = new solution ( solutiontype . call , situation ) ; } } else if ( decision . startswith ( "b" ) && ! lastwasactive ( lastsolution ) ) { solution = new solution ( solutiontype . bet , situation ) ; } else if ( decision . startswith ( "f" ) && lastwasactive ( lastsolution ) ) { solution = new solution ( solutiontype . fold ) ; } else if ( decision . startswith ( "r" ) && lastwasactive ( lastsolution ) ) { solution = new solution ( solutiontype . raise , situation ) ; } else if ( lastwasactive ( lastsolution ) ) { system . out . println ( "not a valid play. (c=call<litcomma> f=fold<litcomma> r=raise)" ) ; return false ; } else { system . out . println ( "not a valid play. (b=bet<litcomma> c=check)" ) ; return false ; } situation = game . solvesituation ( situation , solution ) ; printsolution ( solution ) ; return true ; }
te	9	public list < edge > getdirections ( node to ) { directionkeys . clear ( ) ; node [ ] route = calculateroute ( to ) . toarray ( new node [ calculateroute ( to ) . size ( ) ] ) ; list < edge > listtoreturn = new arraylist < > ( ) ; for ( int i = 0 ; i < route . length ; i ++ ) { int next = 0 ; if ( ! ( i + 1 == route . length ) ) { next = i + 1 ; } hashset < edge > edges = graph . get ( route [ i ] ) ; for ( edge edge : edges ) { if ( ( edge . getfromnode ( ) . equals ( route [ next ] ) || edge . gettonode ( ) . equals ( route [ next ] ) ) ) { listtoreturn . add ( edge ) ; directionkeys . add ( edge . getroadname ( ) ) ; } } } return listtoreturn ; }
te	8	public void initkeywordlist ( ) { keywordlist = new arraylist < keyword > ( ) ; bufferedreader br = null ; try { file userlistfile = new file ( "src/keywords.txt" ) ; string str = null ; if ( userlistfile . exists ( ) ) { br = new bufferedreader ( new filereader ( userlistfile ) ) ; while ( ( str = br . readline ( ) ) != null ) { keywordlist . add ( new keyword ( str ) ) ; } } else { userlistfile . createnewfile ( ) ; } } catch ( filenotfoundexception e ) { e . printstacktrace ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } finally { if ( br != null ) { try { br . close ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } } } }
te	8	protected void createsubbands ( ) { if ( m_imode == audioframeheader . single_channel ) { for ( int i = 0 ; i < m_inumsubbands ; ++ i ) m_subbands [ i ] = new subbandlayer2 ( i ) ; } else if ( m_imode == audioframeheader . joint_stereo ) { int i ; for ( i = 0 ; i < m_audioheader . getintensitystereobound ( ) ; ++ i ) { m_subbands [ i ] = new subbandlayer2stereo ( i ) ; } for ( ; i < m_inumsubbands ; ++ i ) m_subbands [ i ] = new subbandlayer2intensitystereo ( i ) ; } else { for ( int i = 0 ; i < m_inumsubbands ; ++ i ) { m_subbands [ i ] = new subbandlayer2stereo ( i ) ; } } }
te	10	public void readcourses ( string filename , datacontroller datacontroller ) { arraylist < string > courserecords = readfile ( filename ) ; string courserecord ; for ( int i = 0 ; i < courserecords . size ( ) ; i ++ ) { courserecord = courserecords . get ( i ) ; if ( courserecord == null || courserecord . length ( ) == 0 ) { protocol . log ( "fehler in kursdatei: " + filename + " auf zeile " + ( i + 1 ) + ": zeile wird ignoriert" ) ; continue ; } try { course course = getcourse ( i + 1 , courserecord , datacontroller ) ; if ( datacontroller . getcoursebyid ( course . getnumber ( ) ) != null ) { protocol . log ( "fehler in kursdatei: " + filename + " auf zeile " + ( i + 1 ) + ": der kurs mit der bezeichnung '" + course . getname ( ) + "' und id '" + course . getnumber ( ) + "' wurde bereits eingelesen. zeile ignoriert." ) ; } else { datacontroller . getcourses ( ) . add ( course ) ; } } catch ( inputfilereaderexception e ) { protocol . log ( "fehler in kursdatei: " + filename + " auf zeile " + ( i + 1 ) + ":" + e . getmessage ( ) + ": zeile wird ignoriert" ) ; } } }
te	1	public static imagemanager getinstance ( ) { return instance ; }
te	4	private static < e extends comparable < ? super e > > e select ( e [ ] arr , int n ) { int left = 0 ; int right = arr . length - 1 ; random rand = new random ( ) ; while ( right >= left ) { int pivotindex = partition ( arr , left , right , rand . nextint ( right - left + 1 ) + left ) ; if ( pivotindex == n ) { return arr [ pivotindex ] ; } else if ( pivotindex < n ) { left = pivotindex + 1 ; } else { right = pivotindex - 1 ; } } return null ; }
te	3	private long getaddress ( ) { long address = 0 ; int sign = 0 ; for ( net n : pins . get ( 1 ) ) { if ( n . getstate ( ) == net . netstate . high ) { address += math . pow ( 2 , sign ) ; } sign ++ ; } return address ; }
te	8	public boolean checkvocabulary ( string text ) { if ( keywordlist == null ) { initkeywordlist ( ) ; } kwseeker kw1 = kwseeker . getinstance ( keywordlist ) ; set < string > s = kw1 . findwords ( text ) ; if ( s . size ( ) == 0 ) { return false ; } logger . info ( "antispam:\u53d1\u73b0\u90ae\u4ef6\u6b63\u6587\u5b58\u5728\u654f\u611f\u8bcd\uff1a" ) ; for ( iterator iterator = s . iterator ( ) ; iterator . hasnext ( ) ; ) { string string = ( string ) iterator . next ( ) ; logger . info ( "antispam:" + string ) ; } return true ; }
te	2	private void updatekeys ( ) { for ( int i = 0 ; i < this . tabs . gettabcount ( ) ; i ++ ) { tabs . setmnemonicat ( i , keyevents [ i ] ) ; } }
te	7	protected list < point > prospectnextrobot ( robotpoint robot , movetype movetype , long term ) { if ( movetype . istypepinpoint ( ) || robot . energy == 0.0 ) { return prospectnextrobotpinpoint ( robot , term ) ; } else if ( movetype . istypeinertia ( ) ) { return prospectnextrobotinertia ( robot , term ) ; } else if ( movetype . istypeacceleration ( ) ) { return prospectnextrobotacceleration ( robot , term ) ; } else if ( movetype . istypesimplepattern ( ) ) { return prospectnextrobotsimplepattern ( robot , term ) ; } else if ( movetype . istypereactpattern ( ) ) { return prospectnextrobotreactpattern ( robot , term ) ; } else { throw new unsupportedoperationexception ( "unknown movetype : " + movetype . type ) ; } }
te	1	private static boolean sectorsareexhausted ( heap < angleinterval > startangles , heap < angleinterval > endangles ) { return startangles . isempty ( ) && endangles . isempty ( ) ; }
te	9	public list < token > tokenize ( final inputstream stream ) throws ioexception { linecolumnreader reader = new linecolumnreader ( new inputstreamreader ( stream ) ) ; list < token > tokens = new linkedlist < token > ( ) ; try { while ( reader . ready ( ) ) { int c = reader . read ( ) ; if ( character . iswhitespace ( c ) ) { whitespacereader . readvalue ( reader , c ) ; } else if ( character . isletter ( c ) ) { tokens . add ( identifierreader . gettoken ( reader , c ) ) ; } else if ( character . isdigit ( c ) ) { tokens . add ( numberreader . gettoken ( reader , c ) ) ; } else if ( c == '"' ) { tokens . add ( stringreader . gettoken ( reader , c ) ) ; } else { token symbol = symbolreader . gettoken ( reader , c ) ; if ( symbol != null ) { tokens . add ( symbol ) ; } } } return tokens ; } catch ( ioexception e ) { e . printstacktrace ( ) ; throw e ; } finally { reader . close ( ) ; } }
te	1	gestorimagenesview ( string title , gestorimagenesmodel model ) { super ( title ) ; list = new reorderablejlist ( model ) ; setsize ( 350 , 450 ) ; setlayout ( new borderlayout ( ) ) ; list . setlayoutorientation ( jlist . vertical ) ; list . setborder ( new lineborder ( color . black ) ) ; list . setselectionmode ( javax . swing . listselectionmodel . single_interval_selection ) ; jpanel panel = new jpanel ( new borderlayout ( ) ) ; panel . add ( list , borderlayout . north ) ; jscrollpane jscrollpane = new jscrollpane ( ) ; jscrollpane . getviewport ( ) . setview ( panel ) ; jscrollpane . setpreferredsize ( new dimension ( 250 , 250 ) ) ; this . getcontentpane ( ) . add ( jscrollpane , borderlayout . west ) ; buttonspanel . add ( deleteimage ) ; buttonspanel . setpreferredsize ( new dimension ( 105 , 250 ) ) ; this . getcontentpane ( ) . add ( buttonspanel , borderlayout . east ) ; this . setdefaultcloseoperation ( do_nothing_on_close ) ; setvisible ( true ) ; addwindowlistener ( new windowlistener ( ) { @ override public void windowopened ( windowevent e ) { } @ override public void windowiconified ( windowevent e ) { } @ override public void windowdeiconified ( windowevent e ) { } @ override public void windowdeactivated ( windowevent e ) { } @ override public void windowclosing ( windowevent e ) { new macrorunner ( "run(\\"close \\")\\n" ) ; } @ override public void windowclosed ( windowevent e ) { } @ override public void windowactivated ( windowevent e ) { } } ) ; }
te	4	public void refactorlocations ( int x , int y ) { for ( int i = 0 ; i < getsubviews ( ) . size ( ) ; i ++ ) if ( getsubviews ( ) . get ( i ) instanceof gameentity || true ) { view temp = getsubviews ( ) . get ( i ) ; temp . setxpos ( temp . getxpos ( ) + x ) ; temp . setypos ( temp . getypos ( ) + y ) ; } }
te	1	private static angleinterval closeoldsector ( double lastangle , angleinterval oldangle ) { return new angleinterval ( lastangle , oldangle . distancefromline ( lastangle ) , oldangle . rightangle , oldangle . rightdist ) ; }
te	10	public static string adresseip ( ) { inetaddress ia = null ; try { enumeration interfaces = networkinterface . getnetworkinterfaces ( ) ; while ( interfaces . hasmoreelements ( ) ) { networkinterface ni ; enumeration adresses ; ni = ( networkinterface ) interfaces . nextelement ( ) ; if ( ni . getdisplayname ( ) . equals ( "wlan0" ) ) { adresses = ni . getinetaddresses ( ) ; while ( adresses . hasmoreelements ( ) ) { ia = ( inetaddress ) adresses . nextelement ( ) ; } } } } catch ( exception e ) { } string ip = ( ia == null ) ? "127.0.0.1" : ia . tostring ( ) ; return ip ; }
te	3	public static void main ( string [ ] args ) { jframe frame = new jframe ( ) ; frame . setdefaultcloseoperation ( jframe . dispose_on_close ) ; final jtextarea textarea = new jtextarea ( ) ; frame . add ( textarea ) ; frame . setsize ( 400 , 200 ) ; frame . setvisible ( true ) ; frame . addwindowlistener ( new windowadapter ( ) { @ override public void windowclosed ( windowevent e ) { string string = textarea . gettext ( ) ; system . out . println ( string ) ; file file = new file ( "text.txt" ) ; try { stringreader stringreader = new stringreader ( string ) ; bufferedreader bufferedreader = new bufferedreader ( stringreader ) ; filewriter filewriter = new filewriter ( file ) ; bufferedwriter bufferedwriter = new bufferedwriter ( filewriter ) ; for ( string line = bufferedreader . readline ( ) ; line != null ; line = bufferedreader . readline ( ) ) { bufferedwriter . write ( line ) ; bufferedwriter . newline ( ) ; } bufferedreader . close ( ) ; bufferedwriter . close ( ) ; } catch ( ioexception e1 ) { e1 . printstacktrace ( ) ; } } } ) ; }
te	2	public void install ( itexteditor editor , projectionviewer viewer ) { if ( supports ( editor ) ) { this . editor = editor ; this . viewer = viewer ; this . projectionlistener = new projectionlistener ( ) ; this . elementchangedlistener = new elementchangedlistener ( ) ; this . reconciler = new projectionchangereconciler ( ) ; this . viewer . addprojectionlistener ( projectionlistener ) ; } }
te	3	private int getdefendpower ( action defend ) { int defendpower = 0 ; if ( defend != null && defend . gettype ( ) . equals ( actiontype . block ) ) { defendpower = defend . getpower ( ) ; } return defendpower ; }
te	4	public void createusage ( beusage usage ) { if ( usage == null ) { bllerror . getinstance ( ) . createusageerror ( ) ; return ; } try { dalcreate . createusage ( usage ) ; } catch ( sqlexception ex ) { bllerror . getinstance ( ) . createusageerror ( ) ; return ; } bllread . getinstance ( ) . addtousage ( usage ) ; }
te	7	public void reproduce ( pokemonteam parent1 , pokemonteam parent2 , int rankfit ) { arraylist < pokemon > totalpokes = new arraylist < pokemon > ( ) ; for ( int y = 0 ; y < rankfit ; y ++ ) { pokemonteam child = new pokemonteam ( ) ; child . removeall2 ( ) ; arraylist < string > circumvent = new arraylist < string > ( ) ; arraylist < string > pokekeys = new arraylist < string > ( ) ; for ( int i = 0 ; i < 6 ; i ++ ) { totalpokes . add ( parent1 . getmember ( i ) ) ; totalpokes . add ( parent2 . getmember ( i ) ) ; pokekeys . add ( parent1 . getmember ( i ) . showname ( ) ) ; pokekeys . add ( parent2 . getmember ( i ) . showname ( ) ) ; } for ( int x = 0 ; x < 6 ; x ++ ) { int randompokekey = ( int ) ( math . random ( ) * pokekeys . size ( ) ) ; string currentkey = pokekeys . get ( randompokekey ) ; while ( circumvent . contains ( currentkey ) ) { randompokekey = ( int ) ( math . random ( ) * pokekeys . size ( ) ) ; currentkey = pokekeys . get ( randompokekey ) ; } pokemon member = totalpokes . get ( randompokekey ) ; circumvent . add ( currentkey ) ; child . getteam ( ) . add ( member ) ; } children . add ( child ) ; } }
te	1	private static boolean nextsectorisclosest ( angleinterval newangle , tree < angleinterval > distances , double lastangle ) { comparator comp = new distancecomparator ( ) ; return comp . compare ( newangle , distances . getmin ( ) ) < 0 && lastangle != newangle . leftangle ; }
te	3	public coord getcoord ( calendar timestamp ) throws illegalstateexception { long time = timestamp . gettimeinmillis ( ) - lasttimestamp . gettimeinmillis ( ) ; time = time / 1000 ; if ( time > 0 ) { double x = ( double ) ( coords . x ( ) + course . xvel ( ) * time ) ; double y = ( double ) ( coords . y ( ) + course . yvel ( ) * time ) ; return new coord ( x , y ) ; } else if ( time < 0 ) { throw new illegalstateexception ( "trying to read an old timestamp" ) ; } return coords ; }
te	10	private void setmenuitems ( ) { menuitems = menu . getcomponents ( ) ; if ( keepvisibleindex >= topfixedcount && keepvisibleindex <= menuitems . length - bottomfixedcount && ( keepvisibleindex > firstindex + scrollcount || keepvisibleindex < firstindex ) ) { firstindex = math . min ( firstindex , keepvisibleindex ) ; firstindex = math . max ( firstindex , keepvisibleindex - scrollcount + 1 ) ; } if ( menuitems . length > topfixedcount + scrollcount + bottomfixedcount ) { refreshmenu ( ) ; } }
te	7	private string ddcret_string ( int retcode ) { switch ( retcode ) { case ddc_success : return "ddc_success" ; case ddc_failure : return "ddc_failure" ; case ddc_out_of_memory : return "ddc_out_of_memory" ; case ddc_file_error : return "ddc_file_error" ; case ddc_invalid_call : return "ddc_invalid_call" ; case ddc_user_abort : return "ddc_user_abort" ; case ddc_invalid_file : return "ddc_invalid_file" ; } return "unknown error" ; }
te	5	public wordcloudtext ( arraylist < tfidf > tweets , string [ ] keyword ) { text = null ; words = null ; for ( int i = 0 ; i < tweets . size ( ) ; i ++ ) { system . out . println ( "twwwwwww   " + tweets . get ( i ) . gettweet ( ) ) ; if ( text != null ) text += tweets . get ( i ) . gettweet ( ) + " " ; else text = tweets . get ( i ) . gettweet ( ) + " " ; system . out . println ( text ) ; for ( int u = 0 ; u < keyword . length ; u ++ ) text = text . replaceall ( keyword [ u ] , "" ) ; } words = text . split ( "\\\\s+" ) ; }
te	2	public static void sethuntercreationprobability ( double hunter_creation_probability ) { if ( hunter_creation_probability >= 0 ) simulator . hunter_creation_probability = hunter_creation_probability ; }
te	6	public void increasekey ( int i , int key ) throws exception { if ( key < heap [ i ] ) { throw new exception ( "key is smaller than current key." ) ; } int parentindex ; for ( ; i > 0 ; i = parentindex ) { parentindex = parent ( i ) ; if ( key > heap [ parentindex ] ) { heap [ i ] = heap [ parentindex ] ; } else { break ; } } heap [ i ] = key ; }
te	1	public void deleteimage ( int index ) { stackeditortm . deleteslice ( index + 1 ) ; }
te	5	public static void registertormi ( ) { try { namenodeslaveimpl slave = new namenodeslaveimpl ( ) ; string local_ipaddress = inetaddress . getlocalhost ( ) . gethostaddress ( ) ; string slavename = systemconstants . getconfig ( systemconstants . namenode_slave_service ) ; string name = slavename + "_" + getidentifier ( ) ; string bindname = "rmi://" + local_ipaddress + ":" + portnumber + "/" + name ; system . out . println ( "registering namenodeslave as : " + bindname ) ; naming . rebind ( bindname , slave ) ; system . out . println ( "namenodeslaveimpl: ready..." ) ; } catch ( remoteexception e ) { system . out . println ( "error while accessing the remote object check on the rmi." ) ; system . exit ( 0 ) ; } catch ( unknownhostexception e ) { system . out . println ( "error while accessing the rmi<litcomma> please retry" ) ; system . exit ( 0 ) ; } catch ( malformedurlexception e ) { system . out . println ( "error while binding the slave<litcomma> please retry." ) ; system . exit ( 0 ) ; } catch ( accesscontrolexception e ) { system . out . println ( "error with the access control<litcomma> check the policy." ) ; system . exit ( 0 ) ; } }
te	3	private action getcreaturechoicefromlegalactions ( ) { list < action > actions = possiblecreatureactions ; action action = null ; if ( ! possiblecreatureactions . isempty ( ) ) { list < action > legalactions = getlegalactions ( possiblecreatureactions , creature . getnumactions ( ) ) ; if ( ! legalactions . isempty ( ) ) { action = legalactions . get ( roll . randomindex ( actions . size ( ) ) ) ; } else { system . out . println ( creature . getcombatdisplayname ( ) + " is out of actions!" ) ; } } return action ; }
te	8	public static float [ ] [ ] rotatex ( vector3d v ) { float r , r_ ; float [ ] [ ] m1 = identity ( ) ; float [ ] [ ] m2 = identity ( ) ; float [ ] [ ] m3 = identity ( ) ; float [ ] [ ] m4 = identity ( ) ; float [ ] [ ] m5 = identity ( ) ; r_ = ( float ) math . sqrt ( v . y * v . y + v . x * v . x ) ; if ( r_ != 0 ) { m1 [ 0 ] [ 0 ] = v . x / r_ ; m1 [ 0 ] [ 1 ] = v . y / r_ ; m1 [ 1 ] [ 0 ] = - m1 [ 0 ] [ 1 ] ; m1 [ 1 ] [ 1 ] = m1 [ 0 ] [ 0 ] ; } r = v . length ( ) ; if ( r_ != 0 ) { m2 [ 0 ] [ 0 ] = r_ / r ; m2 [ 0 ] [ 2 ] = v . z / r ; m2 [ 2 ] [ 0 ] = - m2 [ 0 ] [ 2 ] ; m2 [ 2 ] [ 2 ] = m2 [ 0 ] [ 0 ] ; } vector3d up = new vector3d ( 0 , 0 , 1 ) ; applyto ( m1 , up , up ) ; applyto ( m2 , up , up ) ; r_ = ( float ) math . sqrt ( v . y * v . y + v . z * v . z ) ; if ( r_ != 0 ) { m4 [ 1 ] [ 1 ] = up . z / r_ ; m4 [ 1 ] [ 2 ] = up . y / r_ ; m4 [ 2 ] [ 1 ] = - m4 [ 1 ] [ 2 ] ; m4 [ 2 ] [ 2 ] = m4 [ 1 ] [ 1 ] ; } m3 = applyto ( m2 , m1 ) ; m5 = applyto ( m4 , m3 ) ; return m3 ; }
te	8	public void settypefromxmlstring ( string s ) { if ( s . equals ( "320x240" ) ) { settfttype ( tfttypes . tft_320_240 ) ; return ; } if ( s . equals ( "800x480" ) ) { settfttype ( tfttypes . tft_800_480 ) ; return ; } if ( s . equals ( "480x272" ) ) { settfttype ( tfttypes . tft_480_272 ) ; return ; } }
te	10	void storemoduletofile ( string filename ) { try { filename = filename + ".syntax" ; file file = new file ( filename ) ; file . delete ( ) ; printstream out = new printstream ( file ) ; out . println ( this ) ; sortedmap < string , integer > wiressorted = new treemap < string , integer > ( wires ) ; iterator < string > it1 = wiressorted . keyset ( ) . iterator ( ) ; iterator < integer > it2 = wiressorted . values ( ) . iterator ( ) ; while ( it1 . hasnext ( ) && it2 . hasnext ( ) ) { out . println ( "wire " + it1 . next ( ) + " " + it2 . next ( ) ) ; } listiterator < evlcomponent > it = components . listiterator ( ) ; while ( it . hasnext ( ) ) { evlcomponent comp = it . next ( ) ; out . println ( "component " + comp . gettype ( ) + " " + comp . getname ( ) + " " + comp . pins . size ( ) ) ; listiterator < evlpin > itp = comp . pins . listiterator ( ) ; while ( itp . hasnext ( ) ) { evlpin pin = itp . next ( ) ; out . println ( "pin " + pin . getname ( ) + " " + pin . getbusmsb ( ) + " " + pin . getbuslsb ( ) ) ; } } out . close ( ) ; } catch ( filenotfoundexception e ) { e . printstacktrace ( ) ; } }
te	7	public static void run ( ) { run_initialise ( ) ; while ( incomplete ) { if ( ! running ) run_start ( ) ; while ( check_conditions ( ) ) { if ( run_tick ( ) ) { break ; } } tidy_up_stats ( ) ; apply_variance_reduction ( ) ; end_current_run ( ) ; } run_stop ( ) ; generate_report ( ) ; generate_graphs ( ) ; }
te	5	public void chessvanillagraphical ( ) { jpanel panel = new jpanel ( ) ; dimension boardsize = new dimension ( 500 , 600 ) ; lpane = new jlayeredpane ( ) ; panel . add ( lpane ) ; lpane . setpreferredsize ( boardsize ) ; lpane . addmouselistener ( this ) ; lpane . addmousemotionlistener ( this ) ; chessboard = new jpanel ( ) ; lpane . add ( chessboard , jlayeredpane . default_layer ) ; chessboard . setlayout ( new gridlayout ( 8 , 8 ) ) ; chessboard . setsize ( 500 , 500 ) ; chessboard . setbounds ( 0 , 0 , 500 , 500 ) ; for ( int i = 0 ; i < 64 ; i ++ ) { jpanel tile = new jpanel ( new borderlayout ( ) ) ; chessboard . add ( tile ) ; int row = ( i / 8 ) % 2 ; if ( row == 0 ) { tile . setbackground ( i % 2 == 0 ? color . gray : color . white ) ; } else { tile . setbackground ( i % 2 == 0 ? color . white : color . gray ) ; } } initializegame ( ) ; }
te	4	protected string stripcomment ( string clv ) { int idx ; if ( ( idx = clv . indexof ( ';' ) ) != - 1 ) { clv = clv . substring ( 0 , idx ) ; } else if ( ( idx = clv . indexof ( "(<" ) ) != - 1 ) { clv = clv . substring ( 0 , idx ) ; } else if ( ( idx = clv . indexof ( '(' ) ) != - 1 ) { clv = clv . substring ( 0 , idx ) ; } return clv . trim ( ) ; }
te	6	protected string removenonnumbers ( string input ) { string temp = "" ; for ( int i = 0 ; i < input . length ( ) ; i ++ ) { int c = ( int ) input . charat ( i ) ; if ( ( c >= 48 && c <= 57 ) || c == 10 || c == 46 ) { temp += ( char ) c ; } } return temp ; }
te	8	private void fillvectors ( ) { int i , j , type ; char [ ] arr = new char [ 15 ] ; for ( i = 0 ; i < 13 ; i ++ ) { arr = configstr [ i ] . tochararray ( ) ; for ( j = 0 ; j < 15 ; j ++ ) { type = ( int ) arr [ j ] - 48 ; switch ( type ) { case 0 : break ; case 1 : bombermans . addelement ( new point ( j , i ) ) ; break ; case 2 : unbreakables . addelement ( new point ( j , i ) ) ; break ; case 3 : breakables . addelement ( new point ( j , i ) ) ; break ; case 4 : exit . addelement ( new point ( j , i ) ) ; break ; default : system . out . println ( "error das sollte nicht passieren !!" ) ; break ; } } } }
te	7	protected void handleevent ( int type , string newvalue , string oldvalue ) { if ( newvalue != null && newvalue . length ( ) > 0 ) { if ( oldvalue == null ) { notifylisteners ( new tokenizerpropertyevent ( tokenizerpropertyevent . property_added , new tokenizerproperty ( type , new string [ ] { newvalue } ) ) ) ; } else if ( ! oldvalue . equals ( newvalue ) ) { notifylisteners ( new tokenizerpropertyevent ( tokenizerpropertyevent . property_modified , new tokenizerproperty ( type , new string [ ] { newvalue } ) , new tokenizerproperty ( type , new string [ ] { oldvalue } ) ) ) ; } } else if ( oldvalue != null && oldvalue . length ( ) > 0 ) { notifylisteners ( new tokenizerpropertyevent ( tokenizerpropertyevent . property_removed , new tokenizerproperty ( type , new string [ ] { oldvalue } ) ) ) ; } }
te	10	private void selectbutton ( tilebutton tilebutton ) { if ( selectedtilebutton != null ) { selectedtilebutton . setselected ( false ) ; selectedtilebutton = null ; } if ( tilebutton != null ) { board board = game . getboard ( ) ; point2d tileposition = tilebutton . getboardposition ( ) ; tile tile = board . gettile ( tileposition ) ; team movingteam = game . getactiveplayer ( ) . getteam ( ) ; if ( tile != null ) { if ( board . ismovementpossible ( movingteam , tileposition ) ) { selectedtilebutton = tilebutton ; tilebutton . setselected ( true ) ; } else { string message = "you can't move that tile." ; if ( tile . getrange ( ) == 0 ) message = "that type of tile can't be moved." ; rejectmove ( message ) ; } } } }
te	9	public void close ( ) { closed = true ; try { if ( inputstream != null ) inputstream . close ( ) ; if ( outputstream != null ) outputstream . close ( ) ; if ( socket != null ) socket . close ( ) ; } catch ( ioexception _ex ) { system . out . println ( "error closing stream" ) ; } iswriter = false ; synchronized ( this ) { notify ( ) ; } buffer = null ; }
te	4	public void setavatar ( connectionhandler avatar ) { if ( this . avatar != null ) { this . avatar . handledisconnect ( ) ; } this . avatar = avatar ; if ( avatar != null ) { avatar . handleconnect ( this ) ; } }
te	8	private boolean evaluateproposition ( proposition prop ) { switch ( prop ) { case is_front_clear : return karel . isfrontclear ( ) ; case is_left_clear : return karel . isleftclear ( ) ; case is_right_clear : return karel . isrightclear ( ) ; case is_facing_north : case is_facing_south : case is_facing_east : case is_facing_west : return isfacing ( prop ) ; case next_to_beeper : return world . getcontents ( karel . getx ( ) , karel . gety ( ) ) == contents . beeper ; } throw new illegalargumentexception ( "unknown proposition used" ) ; }
te	3	private jbutton getgeneratebutton ( ) { if ( generatebutton == null ) { generatebutton = new jbutton ( ) ; generatebutton . settext ( "generieren" ) ; generatebutton . addactionlistener ( new java . awt . event . actionlistener ( ) { public void actionperformed ( java . awt . event . actionevent e ) { try { gui . getplaner ( ) . setsheets ( gui . getplaner ( ) . getgenerator ( ) . generateschedule ( gui . getplaner ( ) . getsettings ( ) . getbegin ( ) , gui . getplaner ( ) . getsettings ( ) . getend ( ) ) ) ; } catch ( exception e1 ) { joptionpane . showmessagedialog ( gui , resources . getinstance ( ) . getstring ( "noactionsselected" ) , resources . getinstance ( ) . getstring ( "nogenpossible" ) , joptionpane . warning_message ) ; } } } ) ; } return generatebutton ; }
te	9	private void unpacktag ( byte [ ] bytes ) throws nosuchtagexception , unsupportedtagexception , invaliddataexception { id3v2tagfactory . sanitychecktag ( bytes ) ; int offset = unpackheader ( bytes ) ; try { if ( extendedheader ) { offset = unpackextendedheader ( bytes , offset ) ; } int frameslength = datalength ; if ( footer ) frameslength -= 10 ; offset = unpackframes ( bytes , offset , frameslength ) ; if ( footer ) { offset = unpackfooter ( bytes , datalength ) ; } } catch ( arrayindexoutofboundsexception e ) { throw new invaliddataexception ( "premature end of tag" , e ) ; } }
te	1	public conserje ( ) { initcomponents ( ) ; }
te	6	@ override public list < float > getrt ( ) throws validationexception { list < float > rts ; string text = rttextarea . gettext ( ) . trim ( ) ; if ( ! text . isempty ( ) ) { rts = getretentiontimes ( text ) ; } else { string filename = this . rtfiletextfield . gettext ( ) . trim ( ) ; if ( filename . trim ( ) . isempty ( ) ) { string message = "no retention time distribution was specified" ; throw new validationexception ( message , "no_rts" ) ; } rts = getretentiontimesfile ( filename ) ; } if ( rts . isempty ( ) ) { throw new validationexception ( "no retention times were loaded. please make sure that the " + "text area/input file includes valid retention times." , "unknown_error" ) ; } this . inputfieldschanged = false ; return rts ; }
te	10	private void paintframe ( graphics g_ , frame frame ) { graphics2d g = ( graphics2d ) g_ . create ( ) ; if ( zoom > 1 ) g . setstroke ( new basicstroke ( 2 ) ) ; if ( frame . getimagefile ( ) != null && frame . getimagefile ( ) . getabsolutefile ( ) . equals ( imagefile ) ) { if ( frame . getrectangle ( ) != null ) { g . setcolor ( color . black ) ; rectangle rect = frame . properrectangle ( ) ; g . drawrect ( toscreen ( rect . x ) , toscreen ( rect . y ) , toscreen ( rect . width ) , toscreen ( rect . height ) ) ; g . drawstring ( frame . getname ( ) , toscreen ( rect . x ) , toscreen ( rect . y ) + 10 ) ; point pivot = frame . getpivot ( ) ; int r = 5 ; g . drawoval ( toscreen ( pivot . x - r ) , toscreen ( pivot . y - r ) , toscreen ( 2 * r ) , toscreen ( 2 * r ) ) ; point offset = frame . getoffset ( ) ; if ( ! offset . equals ( new point ( 0 , 0 ) ) ) { point vector = toscreen ( offset ) ; point base = toscreen ( new point ( pivot . x - offset . x , pivot . y - offset . y ) ) ; g . setcolor ( color . yellow ) ; drawarrow ( g , vector , base ) ; } } } }
te	9	public guicrafting ( world world , player p ) { super ( world , p ) ; bufferedimage [ ] textures = new bufferedimage [ 15 ] ; for ( int i = 0 ; i < 15 ; i ++ ) if ( crafting . result ( i ) != null ) textures [ i ] = crafting . result ( i ) . getitem ( ) . gettexture ( ) ; for ( int i = 0 ; i < rowsx ( ) ; i ++ ) { for ( int j = 0 ; j < rowsy ( ) ; j ++ ) { buttonlist . add ( new button ( centerx - 40 + i * getslotspacingx ( ) , centery - 45 + j * getslotspacingy ( ) , textures [ i + ( j * ( rowsx ( ) ) ) ] ) ) ; } } }
te	1	public void run ( string arg ) { model = new gestorimagenesmodel ( ) ; view = new gestorimagenesview ( "gestor imagenes" , model ) ; controller = new gestorimagenescontroller ( model , view ) ; }
te	7	private static double qnorm ( double p ) { double split = 0.42 , a0 = 2.50662823884 , a1 = - 18.61500062529 , a2 = 41.39119773534 , a3 = - 25.44106049637 , b1 = - 8.47351093090 , b2 = 23.08336743743 , b3 = - 21.06224101826 , b4 = 3.13082909833 , c0 = - 2.78718931138 , c1 = - 2.29796479134 , c2 = 4.85014127135 , c3 = 2.32121276858 , d1 = 3.54388924762 , d2 = 1.63706781897 , q = p - 0.5 ; double r , ppnd = - 1.0 ; if ( math . abs ( q ) <= split ) { r = q * q ; ppnd = q * ( ( ( a3 * r + a2 ) * r + a1 ) * r + a0 ) / ( ( ( ( b4 * r + b3 ) * r + b2 ) * r + b1 ) * r + 1 ) ; } else { r = p ; if ( q > 0 ) r = 1 - p ; if ( r > 0 ) { r = math . sqrt ( - math . log ( r ) ) ; ppnd = ( ( ( c3 * r + c2 ) * r + c1 ) * r + c0 ) / ( ( d2 * r + d1 ) * r + 1 ) ; if ( q < 0 ) ppnd = - ppnd ; else ppnd = 0 ; } } return ppnd ; }
te	2	private imageicon addicon ( string image ) { image img ; try { img = imageio . read ( getclass ( ) . getresource ( "images/" + sampca . texturepack + "/" + image ) ) ; } catch ( ioexception e ) { logger . log ( level . severe , "could not load image " + image ) ; new popup ( "could not load image " + image ) ; img = null ; } return new imageicon ( img ) ; }
te	9	private void decompress ( ) { try { underlying . check ( 1 ) ; int avail_in = underlying . getend ( ) - underlying . getptr ( ) ; if ( avail_in > bytesin ) avail_in = bytesin ; if ( inflater . needsinput ( ) ) { inflater . setinput ( underlying . getbuf ( ) , underlying . getptr ( ) , avail_in ) ; } int n = inflater . inflate ( b , end , bufsize - end ) ; end += n ; if ( inflater . needsinput ( ) ) { bytesin -= avail_in ; underlying . setptr ( underlying . getptr ( ) + avail_in ) ; } } catch ( java . util . zip . dataformatexception e ) { throw new exception ( "zlibinstream: inflate failed" ) ; } }
te	9	public static mineral find ( int remoteid ) { switch ( remoteid ) { case 34 : return tritanium ; case 35 : return pyerite ; case 36 : return mexallon ; case 37 : return isogen ; case 38 : return nocxium ; case 39 : return zydrine ; case 40 : return megacyte ; case 11399 : return morphite ; default : { throw new runtimeexception ( "id does not represent mineral" ) ; } } }
te	3	private void improveskills ( int zombieskilled ) { for ( survivor currsurvivor : this . raidsettings . getteam ( ) ) { if ( zombieskilled > 0 ) currsurvivor . improvefightingskill ( ) ; currsurvivor . improvescavengingskill ( ) ; } }
te	9	public synchronized boolean testarconexao ( connection con ) throws sqlexception { boolean status = false ; boolean conectado = false ; if ( keep_alive ) { resultset rs = con . createstatement ( ) . executequery ( "select 1 from crlv" ) ; if ( rs . next ( ) ) { status = true ; conectado = true ; } } if ( ! conectado ) { try { abrirbanco ( con ) ; } catch ( classnotfoundexception ex ) { logger . getlogger ( database . class . getname ( ) ) . log ( level . severe , null , ex ) ; } } return status ; }
te	1	public boolean anglescrossoverdirectionloop ( point p ) { return ( math . abs ( src . getdirection ( p ) - src . getdirection ( p . getright ( ) ) ) > math . pi ) ; }
te	10	void entitydestroycheck ( downlinkstate linkstate ) { if ( linkstate != null ) { if ( packetid == 0x1d && linkstate . entityids != null ) { integer entityid = ( integer ) fields [ 0 ] . getvalue ( ) ; linkstate . entityids . remove ( entityid ) ; } else if ( packetid == 0x32 ) { integer x = ( integer ) fields [ 0 ] . getvalue ( ) ; integer z = ( integer ) fields [ 1 ] . getvalue ( ) ; boolean mode = ( boolean ) fields [ 2 ] . getvalue ( ) ; if ( mode ) { if ( linkstate . contains ( x , z ) ) { system . out . println ( "chunk " + x + " " + z + " added " + linkstate . contains ( x , z ) ) ; } linkstate . addchunk ( x , z ) ; } else { if ( ! linkstate . contains ( x , z ) ) { system . out . println ( "chunk " + x + " " + z + " removed " + linkstate . contains ( x , z ) ) ; } linkstate . removechunk ( x , z ) ; } } else if ( packetid == 0x33 ) { integer x = ( ( integer ) fields [ 0 ] . getvalue ( ) ) > > 4 ; integer z = ( ( integer ) fields [ 2 ] . getvalue ( ) ) > > 4 ; if ( ! linkstate . contains ( x , z ) ) { system . out . println ( "chunk " + x + " " + z + " updated " + linkstate . contains ( x , z ) ) ; } linkstate . addchunk ( x , z ) ; } } }
te	5	public static long receivestream ( socket socket , fileoutputstream fos , long filesize ) throws ioexception { bufferedoutputstream bos = new bufferedoutputstream ( fos ) ; byte [ ] bytearray = new byte [ 1024 * 1024 ] ; inputstream is = socket . getinputstream ( ) ; long bytesleft = filesize ; while ( bytesleft > 0 ) { int bytestoread = bytearray . length ; if ( bytesleft < bytearray . length ) bytestoread = ( int ) bytesleft ; int bytesread = is . read ( bytearray , 0 , bytestoread ) ; if ( bytesread <= 0 ) break ; bos . write ( bytearray , 0 , bytesread ) ; bytesleft -= bytesread ; } bos . close ( ) ; return filesize - bytesleft ; }
te	10	protected void lockon ( string lockontarget ) { enemy lockontarget = getnextenemy ( lockontarget ) ; if ( lockontarget == null ) { return ; } movetype aimtype = getbestaimtype ( lockontarget ) ; double gunturnradians = 0 ; long gunturntime = 1 ; for ( int i = 0 ; i < max_calc ; i ++ ) { robotpoint prospectmy = new robotpoint ( ctx . my ) ; prospectnextmy ( prospectmy , gunturntime ) ; double distance = prospectmy . calcdistance ( lockontarget ) ; double power = this . calcpower ( lockontarget , aimtype , distance ) ; double bulletvelocity = util . bultspeed ( power ) ; long term = ( long ) math . ceil ( prospectmy . calcdistance ( lockontarget ) / bulletvelocity ) + gunturntime + 10 ; pair < long , double > shot = calcshot ( aimtype , lockontarget , prospectmy , bulletvelocity , term ) ; if ( shot . first == term ) { term += 10 ; continue ; } else { long nextterm = shot . first + 10 ; long bullettime = shot . first - gunturntime ; double bulletradians = shot . second ; gunturnradians = ctx . calcabsgunturnradians ( bulletradians ) ; long nextgunturntime = ( long ) math . ceil ( math . abs ( gunturnradians ) / util . gunturnspeedradians ( ) ) ; if ( math . abs ( nextterm - term ) < 10 ) { if ( gunturntime == nextgunturntime ) { ctx . lockonpoint = util . calcpoint ( bulletradians , bullettime * bulletvelocity ) . add ( prospectmy ) ; break ; } } else { term = nextterm ; } gunturntime = nextgunturntime ; } } doturngunrightradians ( gunturnradians ) ; }
te	3	private byte pullbyte ( ) throws ioexception , jpegmarkerfoundexception { byte mybyte = readbyte ( ) ; bitoffset = 0 ; if ( mybyte == ( byte ) ( 0xff ) ) { byte secondbyte = readbyte ( ) ; if ( secondbyte != ( byte ) ( 0x00 ) ) { marker = secondbyte ; throw new jpegmarkerfoundexception ( ) ; } } return mybyte ; }
te	7	private void updateaxisticks ( ) { axisticks . clear ( ) ; axisticksstring . clear ( ) ; axisscale . setminmaxpoints ( axismin , axismax ) ; axisticks = axisscale . getcoordinates ( ) ; if ( axisticks . size ( ) > 1 ) { if ( this . isaxislogarithmic == false ) { int sigfigs = axisscale . getsigfig ( ) ; this . updateformat ( sigfigs ) ; for ( int loop = 0 ; loop < axisticks . size ( ) ; loop ++ ) { try { axisticksstring . add ( string . format ( sigfigformat , axisticks . get ( loop ) ) ) ; } catch ( exception e ) { system . err . println ( "error : sigfig format = " + sigfigformat + " text = " + axisticks . get ( loop ) ) ; } } } else { system . err . println ( "updateing log scale axis.....min/max = " + axismin + " " + axismax ) ; axisscale . setminmaxpointslog ( axismin , axismax ) ; system . err . println ( "updateing log scale axis..... size = " + axisticks . size ( ) ) ; axisticks = axisscale . getcoordinates ( ) ; for ( int loop = 0 ; loop < axisticks . size ( ) ; loop ++ ) { system . err . println ( loop + " = " + axisticks . get ( loop ) ) ; try { axisticksstring . add ( string . format ( "%.0f" , axisticks . get ( loop ) ) ) ; } catch ( exception e ) { system . err . println ( "error : sigfig format = " + sigfigformat + " text = " + axisticks . get ( loop ) ) ; } } } } }
te	5	public void addevaluationpatternset ( evaluationpatternset evalpatternset ) throws slotmodelexception { if ( evaluationpatternsetsbyname . containskey ( evalpatternset . name ) ) { throw new slotmodelexception ( "game config already contains an eval pattern set with name " + evalpatternset . name ) ; } else { for ( evaluationpattern evalpattern : evalpatternset . evaluationpatterns ) { if ( ! evaluationpatternsbyname . containskey ( evalpattern . name ) ) { throw new slotmodelexception ( "game config does not contain an eval pattern with name " + evalpattern . name ) ; } else if ( evaluationpatternsbyname . get ( evalpattern . name ) != evalpattern ) { throw new slotmodelexception ( "eval pattern with name " + evalpattern . name + " in game config does not map to same eval pattern" ) ; } } evaluationpatternsetsbyname . put ( evalpatternset . name , evalpatternset ) ; int id = getnextincrementedint ( evaluationpatternsetsbyid . keyset ( ) ) ; evalpatternset . id = id ; evaluationpatternsetsbyid . put ( id , evalpatternset ) ; } }
te	7	@ override public void reacttochanges ( observationevent ev ) { if ( ev instanceof checkboxevent ) { checkboxevent event = ( checkboxevent ) ev ; this . setthoricity ( event . ischecked ( ) ) ; this . notifyobserver ( ) ; } else if ( ev instanceof optionlineevent ) { optionlineevent event = ( optionlineevent ) ev ; string label = ( ( customoptionline ) ( event . getsource ( ) ) ) . getlabel ( ) ; switch ( label ) { case rowslabel : this . setheight ( event . getvalue ( ) ) ; break ; case columnslabel : this . setwidth ( event . getvalue ( ) ) ; break ; case mineslabel : this . setminesnumber ( event . getvalue ( ) ) ; break ; } this . notifyobserver ( ) ; } else if ( ev instanceof newgamepanelevent ) { gamedifficulty gd = ( ( newgamepanel ) ev . getsource ( ) ) . getdifficulty ( ) ; if ( gd != gamedifficulty . custom ) { this . setwidth ( gd . getwidth ( ) ) ; this . setheight ( gd . getheight ( ) ) ; this . setminesnumber ( ( int ) math . floor ( gd . getbombpercentage ( ) * this . width * this . height / 100 ) ) ; this . setthoricity ( gd . isthorique ( ) ) ; } } }
te	3	public static dimension getdimension ( map < unit < ? > , integer > product ) { dimensionbuilder builder = new dimensionbuilder ( ) ; for ( map . entry < unit < ? > , integer > entry : product . entryset ( ) ) { if ( ! entry . getkey ( ) . getdimension ( ) . equals ( dimension . none ) ) { builder . pow ( entry . getkey ( ) . getdimension ( ) , entry . getvalue ( ) ) ; } } return builder . build ( ) ; }
te	10	@ override public boolean equals ( object object ) { if ( ! ( object instanceof parkadmission ) ) { return false ; } parkadmission other = ( parkadmission ) object ; if ( ( this . getid ( ) == null && other . getid ( ) != null ) || ( this . getid ( ) != null && ! this . id . equals ( other . id ) ) ) { return false ; } return true ; }
te	4	public list < photoset > getsets ( string userid ) { string response = call ( "flickr.photosets.getlist" , "user_id=" + urlencode ( userid ) + "&primary_photo_extras=url_q" ) ; jsonobject json = ( jsonobject ) jsonparse ( response ) ; if ( json == null ) return null ; jsonarray photosets = ( jsonarray ) ( ( jsonobject ) json . get ( "photosets" ) ) . get ( "photoset" ) ; list < photoset > sets = new arraylist ( ) ; for ( int i = 0 ; i < photosets . size ( ) ; i ++ ) { jsonobject photoset = ( jsonobject ) photosets . get ( new integer ( i ) ) ; photoset set = new photoset ( ) ; set . id = long . parselong ( photoset . get ( "id" ) . tostring ( ) ) ; set . title = ( ( jsonobject ) photoset . get ( "title" ) ) . get ( "_content" ) . tostring ( ) ; set . description = ( ( jsonobject ) photoset . get ( "title" ) ) . get ( "_content" ) . tostring ( ) ; set . coverurl = ( ( jsonobject ) photoset . get ( "primary_photo_extras" ) ) . get ( "url_q" ) . tostring ( ) ; sets . add ( set ) ; } return sets ; }
te	4	private void checkcredentialsvalidity ( ) throws genericconnectionexception { if ( ciuserinfo . getnome ( ) == null ) { throw new genericconnectionexception ( "nessun nome utente specificato!" ) ; } if ( ciuserinfo . getpwd ( ) == null ) { throw new genericconnectionexception ( "nessuna password specificata!" ) ; } }
te	2	public static void setwolfcreationprobability ( double wolf_creation_probability ) { if ( wolf_creation_probability >= 0 ) simulator . wolf_creation_probability = wolf_creation_probability ; }
te	4	public boolean equals ( object object ) { if ( object instanceof person ) { person p = ( person ) object ; if ( p . getname ( ) == null || name == null ) { return false ; } else { return name . equalsignorecase ( p . getname ( ) ) ; } } return false ; }
te	7	private double calculatep1 ( word w , word p , tag wt , nummap np , int state ) { double p1 = 0.0 ; if ( np != null ) { p1 = np . sum ( ) * 1.0 / wt . freq ( ) ; } else { if ( p == null ) { p1 = ( wt . emiss_set_size / ( wt . emiss_set_size + 1.0 ) ) * ( 1 / wt . freq ( ) ) ; } else { tag temp = null ; long freqt = null ; for ( entry < integer , nummap > entry : p . tags . entryset ( ) ) { temp = tagmap . get ( entry . getkey ( ) ) ; if ( temp == null ) continue ; freqt = temp . trans . getval ( state ) ; if ( freqt == null ) continue ; p1 += ( entry . getvalue ( ) . sum ( ) * 1.0 * freqt / temp . trans . sum ( ) ) ; } p1 /= p . freq ( ) ; p1 /= wt . freq ( ) ; } } return p1 ; }
te	8	public list < bucket > getbucketlist ( inputstream is ) throws exception { list < bucket > bucketlist = new arraylist < bucket > ( ) ; element root ; try { root = getrootelement ( is ) ; } catch ( exception e ) { throw e ; } nodelist bucketslist = root . getelementsbytagname ( "buckets" ) ; nodelist bucketlist = bucketslist . item ( 0 ) . getchildnodes ( ) ; int len = bucketlist . getlength ( ) ; try { for ( int i = 0 ; i < len ; i ++ ) { element node = ( element ) bucketlist . item ( i ) ; node nodebucketname = node . getelementsbytagname ( "name" ) . item ( 0 ) ; string bucketname = nodebucketname . gettextcontent ( ) ; node nodecreationdate = node . getelementsbytagname ( "creationdate" ) . item ( 0 ) ; date creationdate = sdf . parse ( nodecreationdate . gettextcontent ( ) ) ; bucketlist . add ( new bucket ( bucketname , creationdate ) ) ; } } catch ( parseexception e ) { throw new exception ( "response parse error" ) ; } finally { ioutils . safelycloseinputstream ( is ) ; } return bucketlist ; }
te	3	@ override public int getlength ( ) { switch ( precision ) { case time : case time_nomillis : return bytes . sizeof_int ; default : return bytes . sizeof_long ; } }
te	5	public string getcompletion ( ) { string completion = "" ; float bestscore = - 1 ; for ( string tag : this . mapwordsdata . keyset ( ) ) { if ( ! this . mapwordsdata . get ( tag ) . iscompletion ( ) ) continue ; if ( this . mapwordsdata . get ( tag ) . getworstscore ( ) > bestscore ) { bestscore = this . mapwordsdata . get ( tag ) . getworstscore ( ) ; completion = tag ; } } return completion ; }
te	10	public static string identitymac ( ) { file path = new file ( mainstart . rootpath ) ; path . mkdirs ( ) ; file authfile = new file ( path , "auth.bin" ) ; string mac = null ; try { if ( authfile . exists ( ) ) { byte buffer [ ] = new byte [ 12 ] ; fileinputstream fis = new fileinputstream ( authfile ) ; while ( fis . read ( buffer ) != - 1 ) mac = new string ( buffer ) ; fis . close ( ) ; return mac ; } else { enumeration < networkinterface > e = networkinterface . getnetworkinterfaces ( ) ; while ( e . hasmoreelements ( ) ) { networkinterface n = ( networkinterface ) e . nextelement ( ) ; if ( ! n . isloopback ( ) && n . isup ( ) ) { mac = new string ( ipaddress . findmac ( n ) ) ; fileoutputstream fos = new fileoutputstream ( authfile ) ; fos . write ( mac . getbytes ( ) ) ; fos . close ( ) ; return mac ; } } } } catch ( filenotfoundexception fnfe ) { system . err . println ( "file not found" ) ; } catch ( securityexception noperm ) { system . err . println ( "no permission to read/write to file" ) ; } catch ( socketexception soc ) { joptionpane . showmessagedialog ( null , "you're not connected to any network" , "the three musketeers say" , joptionpane . error_message ) ; } catch ( ioexception ioe ) { system . err . println ( "some input/output error occured" ) ; } return mac ; }
te	8	int [ ] createpixels ( bufferedimage bim ) { int [ ] pixels = null ; if ( bim == null ) return pixels ; int ww = bim . getwidth ( ) ; int hh = bim . getheight ( ) ; pixels = new int [ ww * hh ] ; pixelgrabber pg = new pixelgrabber ( bim , 0 , 0 , ww , hh , pixels , 0 , ww ) ; try { pg . grabpixels ( ) ; } catch ( interruptedexception e ) { return null ; } if ( ( pg . getstatus ( ) & imageobserver . abort ) != 0 ) { return null ; } return pixels ; }
te	9	public string execute ( string s ) { if ( s . matches ( "ouvrir.* coffre" ) ) { if ( coffreouvert ) return "le coffre est d\xe9j\xe0 ouvert." ; coffreouvert = true ; return "le coffre s'ouvre et un \xe9pais nuage de poussi\xe8re en sort. il y a une cl\xe9 dans le fond." ; } else if ( s . matches ( "prendre.* cl.*" ) ) { if ( coffreouvert && ! inventorymanager . getinstance ( ) . hasitem ( "cl\xe9" ) ) { inventorymanager . getinstance ( ) . additem ( "cl\xe9" ) ; return "vous ramassez la cl\xe9." ; } } else if ( s . matches ( "utiliser.* cl.* porte" ) ) { if ( inventorymanager . getinstance ( ) . hasitem ( "cl\xe9" ) ) { isporteouverte = true ; inventorymanager . getinstance ( ) . removeitem ( "cl\xe9" ) ; return "la porte est maintenant ouverte." ; } } else if ( s . matches ( "mourir" ) ) { playermanager . getinstance ( ) . droplife ( 1000000000 ) ; return "tu est mort" ; } return null ; }
te	7	public void executeorder ( order order ) { planet planet = order . getplanet ( ) ; switch ( order . gettype ( ) ) { case build : buildorder ( planet , false ) ; break ; case special_build : buildorder ( planet , true ) ; break ; case mobilize : mobilizeorder ( planet , false ) ; break ; case special_mobilize : mobilizeorder ( planet , true ) ; break ; case research : researchorder ( planet , false ) ; break ; case special_research : researchorder ( planet , true ) ; break ; default : throw new illegalargumentexception ( "unknown order type." ) ; } }
te	2	private boolean checkcompleted ( ) { boolean retval = false ; if ( dleid . geteventtype ( ) . equals ( eventtype . finished ) ) retval = true ; return retval ; }
te	2	protected void popupwider ( basiccombopopup popup ) { jlist list = popup . getlist ( ) ; int popupwidth = list . getpreferredsize ( ) . width + 5 + getscrollbarwidth ( popup , scrollpane ) ; if ( maximumwidth != - 1 ) { popupwidth = math . min ( popupwidth , maximumwidth ) ; } dimension scrollpanesize = scrollpane . getpreferredsize ( ) ; popupwidth = math . max ( popupwidth , scrollpanesize . width ) ; scrollpanesize . width = popupwidth ; scrollpane . setpreferredsize ( scrollpanesize ) ; scrollpane . setmaximumsize ( scrollpanesize ) ; }
te	9	private tokenizerproperty searchstring ( string image , boolean removeit ) { char startchar = getstartchar ( image . charat ( 0 ) ) ; propertylist list = getlist ( startchar ) ; propertylist prev = null ; while ( list != null ) { tokenizerproperty prop = list . _property ; string img = prop . getimages ( ) [ 0 ] ; int res = compare ( img , image , 1 ) ; if ( res == 0 ) { if ( removeit ) { if ( prev != null ) { prev . _next = list . _next ; } else { list = list . _next ; if ( startchar >= 0 && startchar < direct_index_count ) { _asciiarray [ startchar ] = list ; } else if ( list != null ) { _nonasciimap . put ( new character ( startchar ) , list ) ; } else { _nonasciimap . remove ( new character ( startchar ) ) ; } } } return prop ; } else if ( res < 0 ) { break ; } prev = list ; list = list . _next ; } return null ; }
te	4	public void trimdatabase ( ) { string timedateconfig = getconfig ( "trimdate" ) ; if ( timedateconfig != null && timedateconfig . matches ( "^[0-9]+$" ) ) { long cutoffdate = system . currenttimemillis ( ) / 1000 - long . parselong ( timedateconfig ) * 5184000 ; try { statement statement = connection . createstatement ( ) ; statement . execute ( "delete from revisions where time < " + cutoffdate ) ; logger . debug ( "database trimmed of entries older than " + guiutility . formatdate ( cutoffdate ) ) ; } catch ( sqlexception e ) { errors . nonfatalerror ( "could not remove older revisions" , "trim failed" , e ) ; } } else { logger . debug ( "database trim command encountered and ignored because trim is" + " disabled or is set to an invalid value" ) ; } }
te	8	public string tk_lstring ( ) { stringbuffer sb = new stringbuffer ( ) ; if ( tk_m ( tk_lstr_start ) ) { for ( ; ; ) { if ( ch == 0 ) { break ; } if ( ch == quot ) { if ( m ( 1 , quot ) ) { sb . append ( quot ) ; next ( ) ; } else { break ; } } else { sb . append ( ch ) ; } next ( ) ; } next ( ) ; } return sb . tostring ( ) ; }
te	9	public int accion ( boolean pf , boolean pd , boolean pa , boolean pi , boolean mt ) { int dir = ( int ) ( 4 * math . random ( ) ) ; while ( ( dir == 0 && pf ) || ( dir == 1 && pd ) || ( dir == 2 && pa ) || ( dir == 3 && pi ) ) { dir = ( int ) ( 4 * math . random ( ) ) ; } ; return dir ; }
te	5	private static void validatelocalepart ( string localepart ) { for ( int i = 0 ; i < localepart . length ( ) ; i ++ ) { char ch = localepart . charat ( i ) ; if ( ch != '_' && ch != ' ' && ! character . isletterordigit ( ch ) ) { throw new illegalargumentexception ( "locale part \\"" + localepart + "\\" contains invalid characters" ) ; } } }
te	5	public float [ ] geteachscore ( list < string > query ) { float res [ ] = new float [ query . size ( ) ] ; string tag ; for ( int pos = 0 ; pos < query . size ( ) ; pos ++ ) { if ( pos == query . size ( ) - 1 ) { tag = this . getcompletion ( ) ; } else { tag = query . get ( pos ) ; } if ( ! this . mapwordsdata . containskey ( tag ) ) res [ pos ] = 0 ; res [ pos ] = this . mapwordsdata . get ( tag ) . computeworstscore ( alpha , score ) ; } return res ; }
te	8	private void checkargdecls ( ast caller , ast fct ) { ast formals = fct . getkid ( 3 ) ; iterator < ast > actualkids = caller . getkids ( ) . iterator ( ) , formalkids = formals . getkids ( ) . iterator ( ) ; actualkids . next ( ) ; for ( ; actualkids . hasnext ( ) ; ) { try { ast actualdecl = decoration ( actualkids . next ( ) ) , formaldecl = formalkids . next ( ) ; if ( decoration ( actualdecl . getkid ( 2 ) ) != decoration ( formaldecl . getkid ( 2 ) ) ) { constrainterror ( constrainererrors . actualformaltypemismatch ) ; } } catch ( exception e ) { constrainterror ( constrainererrors . numberactualsformalsdiffer ) ; } } if ( formalkids . hasnext ( ) ) { constrainterror ( constrainererrors . numberactualsformalsdiffer ) ; } return ; }
te	7	private static string asseqstring ( final double [ ] data , final int size , final int length ) { stringbuilder out = new stringbuilder ( ) ; int off = 0 ; for ( int i = 0 ; i < length ; i ++ ) { if ( i > 0 ) out . append ( default_vectordelimiter ) ; for ( int j = 0 ; j < size ; j ++ ) { if ( j > 0 ) out . append ( default_valuedelimiter ) ; final double value = data [ off ++ ] ; out . append ( value ) ; } } return out . tostring ( ) ; }
te	5	@ override public void run ( ) { while ( true ) { long beforetime , timediff , sleep ; beforetime = system . currenttimemillis ( ) ; while ( true ) { repaint ( ) ; timediff = system . currenttimemillis ( ) - beforetime ; sleep = delay - timediff ; if ( sleep >= 2 ) { try { thread . sleep ( sleep ) ; } catch ( interruptedexception e ) { system . err . println ( "interrupted" ) ; } } beforetime = system . currenttimemillis ( ) ; } } }
te	4	public boolean equals ( object other ) { if ( other == null ) return false ; if ( ! ( other instanceof vessel ) ) return false ; vessel vother = ( vessel ) other ; return id . equals ( vother . getid ( ) ) && type == vother . gettype ( ) ; }
te	9	@ override public void run ( ) { system . out . println ( "player running" ) ; sendresponse ( new rpl_serverhello ( ) ) ; while ( true ) { while ( ! this . portermailbox . isempty ( ) ) { handleportercommand ( this . portermailbox . poll ( ) ) ; } while ( ! this . gamemailbox . isempty ( ) ) { handlegamecommand ( this . gamemailbox . poll ( ) ) ; } try { synchronized ( this ) { system . out . println ( "waiting" ) ; wait ( ) ; } } catch ( interruptedexception ex ) { system . out . println ( "interrupted" ) ; } } }
te	1	public client setuserno ( string userno ) { this . userno = userno ; return this ; }
te	7	public boolean compare ( predicate . op op , field val ) { stringfield ival = ( stringfield ) val ; int cmpval = value . compareto ( ival . value ) ; switch ( op ) { case equals : return cmpval == 0 ; case not_equals : return cmpval != 0 ; case greater_than : return cmpval > 0 ; case greater_than_or_eq : return cmpval >= 0 ; case less_than : return cmpval < 0 ; case less_than_or_eq : return cmpval <= 0 ; case like : return value . indexof ( ival . value ) >= 0 ; } return false ; }
te	4	@ override public void paint ( graphics g ) { super . paint ( g ) ; for ( component comp : dragger . getselected ( ) ) { g . setcolor ( highlightcolor ) ; rectangle rect = comp . getbounds ( ) ; rect . add ( rect . x - bordersize , rect . y - bordersize ) ; rect . setsize ( rect . width + bordersize , rect . height + bordersize ) ; ( ( graphics2d ) g ) . setstroke ( new basicstroke ( bordersize ) ) ; ( ( graphics2d ) g ) . draw ( rect ) ; } if ( highlightrectangle != null ) { graphics2d g2d = ( graphics2d ) g ; g2d . setcolor ( highlightcolor ) ; g2d . fill ( highlightrectangle ) ; } }
te	1	draughtscompetitiongui ( string [ ] pluginfolders ) { super ( draughtsplugin . class , pluginfolders ) ; draughtsgui gui = new draughtsgui ( ) ; initcomponents ( gui ) ; this . add ( gui ) ; gui . add ( this ) ; }
te	4	public static void suite ( string name ) { if ( name == null ) { throw new illegalargumentexception ( ) ; } suite = name ; if ( verbose ) { log ( "suite: " + name ) ; } }
te	2	public void importfromstring ( string viewstr ) { try { documentbuilderfactory factory = documentbuilderfactory . newinstance ( ) ; documentbuilder builder = factory . newdocumentbuilder ( ) ; inputstream stream = new bytearrayinputstream ( viewstr . getbytes ( "utf-8" ) ) ; document doc = builder . parse ( stream ) ; importview ( doc ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } }
te	8	public static boolean projectyz ( vector3d a , vector3d a_ , float d ) { float tanmax = 25 ; a_ . x = a . x ; if ( a . x >= d ) return false ; float tan ; float scale = ( d - a . x ) ; tan = a . y / ( d - a . x ) ; if ( tan * tan > tanmax ) return false ; else a_ . y = a . y / scale ; tan = a . z / ( d - a . x ) ; if ( tan * tan > tanmax ) return false ; else a_ . z = a . z / scale ; return true ; }
te	6	private void handleos ( string [ ] args , int i ) { if ( ! args [ i + 1 ] . equals ( "w" ) && ! args [ i + 1 ] . equals ( "l" ) ) { system . err . println ( "jpocl is compatible with windows(w) or linux(l)" ) ; system . exit ( 2 ) ; } islinux = args [ i + 1 ] . equals ( "w" ) ? false : true ; }
te	2	private void declareonenamespace ( xmlpullparser pp , int i , element parent ) throws domexception , xmlpullparserexception { string xmlnsprefix = pp . getnamespaceprefix ( i ) ; string xmlnsuri = pp . getnamespaceuri ( i ) ; string xmlnsdecl = ( xmlnsprefix != null ) ? "xmlns:" + xmlnsprefix : "xmlns" ; parent . setattributens ( "http://www.w3.org/2000/xmlns/" , xmlnsdecl , xmlnsuri ) ; }
te	3	private void replace ( matcher match ) { if ( replace != null ) { if ( processmatches ( match ) ) { string resulttext = match . replaceall ( replace ) ; regexlistenermanager . publishdonewithreplace ( new replaceresult ( resulttext , matches ) ) ; } else { regexlistenermanager . publishfoundnomatches ( ) ; } } }
te	4	private static void getpaths ( map < string , integer > commitmap , string [ ] [ ] parenthashes , string commithash , list < string > accu , list < list < string > > result ) { int idx = commitmap . get ( commithash ) ; string [ ] parent = parenthashes [ idx ] ; if ( parent == null ) { result . add ( accu ) ; return ; } for ( string p : parent ) { list < string > newaccu = new arraylist < > ( ) ; newaccu . addall ( accu ) ; newaccu . add ( p ) ; getpaths ( commitmap , parenthashes , p , newaccu , result ) ; } }
te	5	public doublylinkedlist < t > reverse ( ) { node < t > ret = null ; tail = head ; while ( head != null ) { node < t > tmp = head . next ; if ( tmp != null ) { tmp . prev = null ; } head . setnext ( ret ) ; if ( ret != null ) { ret . setprev ( head ) ; } ret = head ; head = tmp ; } head = ret ; return this ; }
te	10	public imageregistry ( string texturedir ) { initialize ( ) ; this . dir = texturedir ; file indexfile = new file ( texturedir + file . separator + index_file ) ; if ( indexfile . exists ( ) == false ) { system . err . println ( "warning! cannot find the index file for the texture folder: " + texturedir + ". tile set not added." ) ; } else { filereader fs ; bufferedreader br ; try { fs = new filereader ( indexfile ) ; br = new bufferedreader ( fs ) ; string nextline = br . readline ( ) ; while ( nextline != null ) { int delim = nextline . indexof ( "<litcomma>" ) ; if ( delim >= 1 ) { string [ ] splitted = nextline . split ( "<litcomma>" ) ; string key = splitted [ 0 ] . trim ( ) ; string image = splitted [ 1 ] . trim ( ) ; file imagefile = new file ( texturedir + file . separator + image ) ; if ( imagefile . exists ( ) == true ) { registry . put ( key , new imageicon ( imageio . read ( imagefile ) ) ) ; for ( int i = 0 ; i < keywords . length ; i ++ ) { int index = key . indexof ( keywords [ i ] ) ; int nextchar = index + keywords [ i ] . length ( ) ; if ( ( index >= 0 ) && ( nextchar < key . length ( ) ) && ( character . isdigit ( key . charat ( nextchar ) ) ) ) { integer current = keywordcount . get ( keywords [ i ] ) ; current ++ ; keywordcount . put ( keywords [ i ] , current ) ; break ; } } } else { system . err . println ( "warning! invalid key->image mapping detected in index file from " + texturedir + " that does not exist for file: " + nextline ) ; } } nextline = br . readline ( ) ; } fs . close ( ) ; br . close ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } } }
te	10	@ todo public string definemethodname ( mclass objclass , string methodname ) { if ( methodname != null && ! methodname . contains ( "." ) ) { if ( objclass != null ) { methodname = objclass . getclass ( ) . getname ( ) . concat ( "." ) . concat ( methodname ) ; } else { throwable thr = new throwable ( ) ; thr . fillinstacktrace ( ) ; stacktraceelement [ ] ste = thr . getstacktrace ( ) ; string classname = null ; class clazz = null ; for ( int i = 0 ; i < ste . length ; i ++ ) { classname = ste [ i ] . getclassname ( ) ; clazz = stackedclasses . get ( classname ) ; if ( clazz == null ) { try { clazz = class . forname ( classname ) ; } catch ( classnotfoundexception e ) { throw new illegalargumentexception ( "can not execute the method " + methodname + " because there is no one classe implementing it." , e ) ; } stackedclasses . put ( classname , clazz ) ; } if ( mclass . class . isassignablefrom ( clazz ) ) { methodname = classname . concat ( "." ) . concat ( methodname ) ; break ; } } } } return methodname ; }
te	5	private boolean allmosterskilled ( ) { set < string > keys = rooms . keyset ( ) ; for ( string direction : keys ) { arraylist < monster > m = new arraylist < monster > ( ) ; m = rooms . get ( direction ) . getmonsters ( ) ; if ( ! m . isempty ( ) ) { for ( monster mm : m ) { if ( mm . isalive ( ) ) { return false ; } } } } return true ; }
te	6	private void callkarel ( code . action action ) { switch ( action ) { case move : karel . move ( ) ; break ; case pick_up : karel . pickup ( ) ; break ; case put_down : karel . putdown ( ) ; break ; case turn_left : karel . turnleft ( ) ; break ; case turn_right : karel . turnright ( ) ; break ; default : throw new runtimeexception ( "controller cannot execute this unknown action: " + action ) ; } }
te	1	@ override public string tostring ( ) { return "" + ( int ) ( 180 * leftangle / math . pi ) + "->" + ( int ) leftdist + ": " + ( int ) ( 180 * rightangle / math . pi ) + "->" + ( int ) rightdist ; }
te	6	public void each ( map < string , object > input , output < map < string , object > > mapoutput ) throws ioexception { if ( statement == null ) { registereventandstatement ( input , mapoutput ) ; } if ( verbose ) { if ( ++ count % 1000 == 0 ) { system . err . printf ( "%d items processed\\n" , count ) ; } } provider . getepruntime ( ) . sendevent ( input , "s" ) ; }
te	6	public static void main ( string [ ] args ) { softskillsuser softskillsuser ; softskillsuserdao softskillsuserdao = new softskillsuserdaomysql ( ) ; userselector us = new userselector ( ) ; list < user > userlist = us . selectstudentsfromdefaultgroups ( ) ; date startdate = null ; date enddate = null ; if ( logger . isdebugenabled ( ) ) { logger . debug ( "selecionados " + userlist . size ( ) + " estudantes..." ) ; } attentiontodetails attentiontodetails = new attentiontodetails ( ) ; double attentiontodetailsscore ; communication communication = new communication ( ) ; double communicationscore ; fastlearning fastlearning = new fastlearning ( ) ; double fastlearningscore ; persistence persistence = new persistence ( ) ; double persistencescore ; problemanalysis problemanalysis = new problemanalysis ( ) ; double problemanalysisscore ; problemsolving problemsolving = new problemsolving ( ) ; double problemsolvingscore ; workindependently workindependently = new workindependently ( ) ; double workindependentlyscore ; for ( user user : userlist ) { startdate = user . getdatecreated ( ) ; enddate = new date ( new datetime ( startdate ) . plusmonths ( six_months ) . getmillis ( ) ) ; attentiontodetailsscore = attentiontodetails . identify ( user , startdate , enddate ) ; communicationscore = communication . identify ( user , startdate , enddate ) ; fastlearningscore = fastlearning . identify ( user , startdate , enddate ) ; persistencescore = persistence . identify ( user , startdate , enddate ) ; problemanalysisscore = problemanalysis . identify ( user , startdate , enddate ) ; problemsolvingscore = problemsolving . identify ( user , startdate , enddate ) ; workindependentlyscore = workindependently . identify ( user , startdate , enddate ) ; if ( logger . isdebugenabled ( ) ) { logger . debug ( "user " + user . getid ( ) + "\\naten\xe7\xe3o aos detalhes: " + attentiontodetailsscore + "\\ncomunica\xe7\xe3o: " + communicationscore + "\\naprendizagem r\xe1pida: " + fastlearningscore + "\\npersistencia: " + persistencescore + "\\nan\xe1lise de problemas: " + problemanalysisscore + "\\nresolu\xe7\xe3o de problemas: " + problemsolvingscore + "\\ntrabalho independente: " + workindependentlyscore ) ; } softskillsuser = new softskillsuser ( ) ; softskillsuser . setattentiontodetails ( attentiontodetailsscore ) ; softskillsuser . setcommunication ( communicationscore ) ; softskillsuser . setfastlearning ( fastlearningscore ) ; softskillsuser . setpersistence ( persistencescore ) ; softskillsuser . setproblemanalysis ( problemanalysisscore ) ; softskillsuser . setproblemsolving ( problemsolvingscore ) ; softskillsuser . setworkindependently ( workindependentlyscore ) ; softskillsuser . setuser ( user ) ; softskillsuser . setstartdate ( startdate ) ; softskillsuser . setenddate ( enddate ) ; softskillsuserdao . createsoftskillsuser ( softskillsuser ) ; } }
te	2	public static void setfoxcreationprobability ( double fox_creation_probability ) { if ( fox_creation_probability >= 0 ) simulator . fox_creation_probability = fox_creation_probability ; }
te	10	public synchronized sdfrecord readsdfrecord ( ) throws ioexception { sdfrecord record = null ; final int ilinenumber = getlinenumber ( ) ; final stringbuilder sbsdf = new stringbuilder ( 8192 ) ; string strline = null ; while ( ( strline = readline ( ) ) != null ) { sbsdf . append ( strline ) . append ( "\\r\\n" ) ; if ( strline . startswith ( "$$$$" ) ) { record = new sdfrecord ( sbsdf . tostring ( ) ) ; if ( m_strdatasetname != null ) { record . put ( sdfrecord . property_dataset_name , m_strdatasetname ) ; } if ( m_brecordlinenumbers ) { record . put ( sdfrecord . property_line_number , ilinenumber ) ; } if ( m_irecordnumber >= 0 ) { record . put ( sdfrecord . property_record_number , m_irecordnumber ++ ) ; } break ; } } return record ; }
te	3	@ override public void run ( ) { for ( int i = 0 ; i < 5 ; ++ i ) { try { thread . sleep ( 100 ) ; } catch ( interruptedexception e ) { e . printstacktrace ( ) ; } system . out . println ( thread . currentthread ( ) . getname ( ) + "\u5356\u51fa\u4e86" + foo . getticket ( ) + "\u53f7\u7968!" ) ; } }
te	10	@ override public void generatepayload ( ) { getpayload ( ) . writebyte ( type ) ; if ( type == newentity ) { getpayload ( ) . writeint ( entity . getid ( ) ) ; if ( entity instanceof livingentity ) { livingentity lent = ( livingentity ) entity ; getpayload ( ) . writebyte ( mapobjecttype . animal . getid ( ) ) ; getpayload ( ) . writeint ( lent . gettype ( ) . getid ( ) ) ; } else if ( entity instanceof mapscenery ) { mapscenery oent = ( mapscenery ) entity ; getpayload ( ) . writebyte ( mapobjecttype . object . getid ( ) ) ; getpayload ( ) . writeint ( oent . gettype ( ) . getid ( ) ) ; } getpayload ( ) . writedouble ( entity . getlocation ( ) . getx ( ) ) ; getpayload ( ) . writedouble ( entity . getlocation ( ) . gety ( ) ) ; getpayload ( ) . writeint ( entity . getlocation ( ) . getrotation ( ) ) ; if ( entity instanceof sendable ) { ( ( sendable ) entity ) . send ( getpayload ( ) ) ; } } else if ( type == newposition ) { getpayload ( ) . writeint ( entity . getid ( ) ) ; getpayload ( ) . writedouble ( entity . getlocation ( ) . getx ( ) ) ; getpayload ( ) . writedouble ( entity . getlocation ( ) . gety ( ) ) ; getpayload ( ) . writeint ( entity . getlocation ( ) . getrotation ( ) ) ; } else if ( type == newrotation ) { getpayload ( ) . writeint ( entity . getid ( ) ) ; getpayload ( ) . writeint ( entity . getlocation ( ) . getrotation ( ) ) ; } else if ( type == removeentity ) { getpayload ( ) . writeint ( entity . getid ( ) ) ; } }
te	3	private int getdebuffadjusteddamage ( combatant attacker , int damage ) { int adjusteddamage = 0 ; list < action > combatantdebuffs = attacker . getround ( round ) . getdebuffs ( ) ; if ( combatantdebuffs != null ) { for ( action debuff : combatantdebuffs ) { adjusteddamage += debuff . getdamagemod ( ) ; } } return adjusteddamage + damage ; }
te	5	@ override public void mouseclicked ( mouseevent e ) { if ( rectangles != null ) for ( rectangle r : rectangles . keyset ( ) ) { if ( r . contains ( e . getpoint ( ) ) ) { final jdialog jd = new jdialog ( ) ; jd . settitle ( "students in session:" ) ; jpanel jp = new jpanel ( ) ; jp . setlayout ( new boxlayout ( jp , boxlayout . y_axis ) ) ; string result = rectangles . get ( r ) . tostring ( ) ; jlabel jl = new jlabel ( result ) ; jp . add ( jl ) ; for ( student s : rectangles . get ( r ) . getassigned ( ) ) { result = s . tostring ( ) ; jl = new jlabel ( result ) ; jp . add ( jl ) ; } jd . add ( jp ) ; jbutton exit = new jbutton ( "exit" ) ; exit . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent e ) { jd . setvisible ( false ) ; jd . dispose ( ) ; } } ) ; jp . add ( exit ) ; jd . pack ( ) ; jd . setvisible ( true ) ; break ; } } }
te	1	public void changeactivepane ( guipane pane ) { activepane = pane ; }
te	2	public void projectionenabled ( ) { projectiondisabled ( ) ; if ( supports ( editor ) ) { initialize ( ) ; javacore . addelementchangedlistener ( elementchangedlistener ) ; } }
te	8	public topdocscollector < scoredoc > searchmoleculesbyfingerprintmatch ( final string strsmiles , final int imaxhits ) throws ioexception { if ( strsmiles == null ) { throw new illegalargumentexception ( "smiles must not be null." ) ; } topscoredoccollector collector = null ; final indexsearcher searcher = preparesearcher ( ) ; if ( searcher != null ) { final bitset fpquery = m_fingerprintfactory . createqueryfingerprint ( strsmiles , false ) ; if ( fpquery != null ) { final booleanquery query = new booleanquery ( ) ; for ( int i = fpquery . nextsetbit ( 0 ) ; i >= 0 ; i = fpquery . nextsetbit ( i + 1 ) ) { query . add ( new booleanclause ( new termquery ( new term ( field_fp , integer . tostring ( i ) ) ) , booleanclause . occur . must ) ) ; } collector = topscoredoccollector . create ( imaxhits , true ) ; searcher . search ( query , collector ) ; } } return collector ; }
te	2	public void sendwinordraw ( boolean win ) { if ( win ) { sendmessage ( "winner:" ) ; } else { sendmessage ( "draw" ) ; } }
te	5	public int compareto ( item o ) { if ( o . getcomputedworstscore ( ) > this . getcomputedworstscore ( ) ) return 1 ; else if ( o . getcomputedworstscore ( ) < this . getcomputedworstscore ( ) ) return - 1 ; else { if ( o . getbestscore ( ) > this . getbestscore ( ) ) return 1 ; else if ( o . getbestscore ( ) < this . getbestscore ( ) ) return - 1 ; else return long . compare ( this . itemid , o . getitemid ( ) ) ; } }
te	1	public void loadimage ( int indice ) { ij . setslice ( indice + 1 ) ; }
te	5	public boolean isoncity ( ship s ) { for ( city city : clientgame . getallcities ( ) ) { if ( city . getownerid ( ) == clientgame . getnetworkid ( ) ) { continue ; } if ( city . getlocation ( ) . equals ( s . getlocation ( ) ) ) { return true ; } } return false ; }
te	6	public void buildreservations ( ) { list < parkreservation > reservations = parkreservationfacade . findall ( ) ; jsonobjectbuilder builder = json . createobjectbuilder ( ) ; jsonarraybuilder reservationarray = json . createarraybuilder ( ) ; setjsonstr ( new stringbuilder ( ) ) ; try ( stringwriter sw = new stringwriter ( ) ) { for ( parkreservation reservation : reservations ) { jsonobjectbuilder reservationbuilder = json . createobjectbuilder ( ) ; reservationbuilder . add ( "id" , reservation . getid ( ) ) . add ( "firstname" , reservation . getfirstname ( ) ) . add ( "lastname" , reservation . getlastname ( ) ) . add ( "numadults" , reservation . getnumadults ( ) ) . add ( "numchild" , reservation . getnumchild ( ) ) . add ( "numdays" , reservation . getnumdays ( ) ) . add ( "tripstart" , reservation . gettripstartdate ( ) . tostring ( ) ) ; reservationarray . add ( reservationbuilder ) ; } builder . add ( "reservations" , reservationarray ) ; jsonobject result = builder . build ( ) ; try ( jsonwriter writer = json . createwriter ( sw ) ) { writer . writeobject ( result ) ; } getjsonstr ( ) . append ( sw . tostring ( ) ) ; system . out . println ( getjsonstr ( ) ) ; writetodisk ( "reservations.json" , result ) ; } catch ( ioexception ex ) { system . out . println ( ex ) ; } }
te	9	public static void main ( string [ ] args ) throws remoteexception { streamsterapiinterfaceproxy proxy = new streamsterapiinterfaceproxy ( ) ; | [ ] bars = proxy . getbars ( "eur/usd" , "5 minutes" , "f" ) ; list < bigdecimal > open = arrays . aslist ( bars ) . stream ( ) . map ( c -> c . getopen ( ) ) . collect ( collectors . tolist ( ) ) ; list < bigdecimal > close = arrays . aslist ( bars ) . stream ( ) . map ( c -> c . getclose ( ) ) . collect ( collectors . tolist ( ) ) ; list < bigdecimal > high = arrays . aslist ( bars ) . stream ( ) . map ( c -> c . gethigh ( ) ) . collect ( collectors . tolist ( ) ) ; list < bigdecimal > low = arrays . aslist ( bars ) . stream ( ) . map ( c -> c . getlow ( ) ) . collect ( collectors . tolist ( ) ) ; double [ ] openarray = open . stream ( ) . maptodouble ( bigdecimal :: doublevalue ) . toarray ( ) ; double [ ] closearray = close . stream ( ) . maptodouble ( bigdecimal :: doublevalue ) . toarray ( ) ; double [ ] higharray = high . stream ( ) . maptodouble ( bigdecimal :: doublevalue ) . toarray ( ) ; double [ ] lowarray = low . stream ( ) . maptodouble ( bigdecimal :: doublevalue ) . toarray ( ) ; double [ ] macd = new double [ close . size ( ) - 33 ] ; double [ ] signal = new double [ close . size ( ) - 33 ] ; double [ ] histogram = new double [ close . size ( ) - 33 ] ; double [ ] ma50 = new double [ close . size ( ) - 49 ] ; double [ ] ema5 = new double [ close . size ( ) - 4 ] ; double [ ] ema100 = new double [ close . size ( ) - 99 ] ; double [ ] rsi = new double [ close . size ( ) - 14 ] ; double [ ] adx10 = new double [ close . size ( ) - 19 ] ; double [ ] minusdi10 = new double [ close . size ( ) - 10 ] ; double [ ] plusdi10 = new double [ close . size ( ) - 10 ] ; double [ ] sar = new double [ close . size ( ) - 1 ] ; double [ ] slowk = new double [ close . size ( ) - 8 ] ; double [ ] slowd = new double [ close . size ( ) - 8 ] ; double [ ] bbandsu = new double [ close . size ( ) - 19 ] ; double [ ] bbandsm = new double [ close . size ( ) - 19 ] ; double [ ] bbandsl = new double [ close . size ( ) - 19 ] ; core c = new core ( ) ; c . macd ( 0 , close . size ( ) - 1 , closearray , 12 , 26 , 9 , new minteger ( ) , new minteger ( ) , macd , signal , histogram ) ; c . sma ( 0 , close . size ( ) - 1 , closearray , 50 , new minteger ( ) , new minteger ( ) , ma50 ) ; c . ema ( 0 , close . size ( ) - 1 , closearray , 5 , new minteger ( ) , new minteger ( ) , ema5 ) ; c . ema ( 0 , close . size ( ) - 1 , closearray , 100 , new minteger ( ) , new minteger ( ) , ema100 ) ; c . rsi ( 0 , close . size ( ) - 1 , closearray , 14 , new minteger ( ) , new minteger ( ) , rsi ) ; c . adx ( 0 , close . size ( ) - 1 , higharray , lowarray , closearray , 10 , new minteger ( ) , new minteger ( ) , adx10 ) ; c . minusdi ( 0 , close . size ( ) - 1 , higharray , lowarray , closearray , 10 , new minteger ( ) , new minteger ( ) , minusdi10 ) ; c . plusdi ( 0 , close . size ( ) - 1 , higharray , lowarray , closearray , 10 , new minteger ( ) , new minteger ( ) , plusdi10 ) ; c . sar ( 0 , close . size ( ) - 1 , higharray , lowarray , 0.02 , 0.2 , new minteger ( ) , new minteger ( ) , sar ) ; c . stoch ( 0 , close . size ( ) - 1 , higharray , lowarray , closearray , 5 , 3 , matype . ema , 3 , matype . ema , new minteger ( ) , new minteger ( ) , slowk , slowd ) ; c . bbands ( 0 , close . size ( ) - 1 , closearray , 20 , 2.000000e+0 , 2.000000e+0 , matype . ema , new minteger ( ) , new minteger ( ) , bbandsu , bbandsm , bbandsl ) ; macd = shiftlist ( macd , close . size ( ) ) ; signal = shiftlist ( signal , close . size ( ) ) ; histogram = shiftlist ( histogram , close . size ( ) ) ; ma50 = shiftlist ( ma50 , close . size ( ) ) ; ema5 = shiftlist ( ema5 , close . size ( ) ) ; ema100 = shiftlist ( ema100 , close . size ( ) ) ; rsi = shiftlist ( rsi , close . size ( ) ) ; adx10 = shiftlist ( adx10 , close . size ( ) ) ; minusdi10 = shiftlist ( minusdi10 , close . size ( ) ) ; plusdi10 = shiftlist ( plusdi10 , close . size ( ) ) ; sar = shiftlist ( sar , close . size ( ) ) ; slowk = shiftlist ( slowk , close . size ( ) ) ; slowd = shiftlist ( slowd , close . size ( ) ) ; bbandsu = shiftlist ( bbandsu , close . size ( ) ) ; bbandsm = shiftlist ( bbandsm , close . size ( ) ) ; bbandsl = shiftlist ( bbandsl , close . size ( ) ) ; boolean state = false ; list < string > logs = new arraylist < > ( ) ; bigdecimal price = bigdecimal . zero ; bigdecimal total = bigdecimal . zero ; for ( int i = 100 ; i < openarray . length ; i ++ ) { integer [ ] result = new integer [ 5 ] ; system . out . println ( i + " {" + bars [ i ] . getbardatetime ( ) . gettime ( ) + "} close " + bars [ i ] . getclose ( ) + "\\t macd " + macd [ i ] + "\\t signal " + signal [ i ] + "\\t histogram " + histogram [ i ] + "\\t sma50 " + ma50 [ i ] + "\\t ema5 " + ema5 [ i ] + "\\t ema100 " + ema100 [ i ] + "\\t rsi " + rsi [ i ] + "\\t adx10 " + adx10 [ i ] + "\\t minus_di10 " + minusdi10 [ i ] + "\\t plus_di10 " + plusdi10 [ i ] + "\\t sar " + sar [ i ] + "\\t bbandsupper " + bbandsu [ i ] + "\\t bbandsmiddle " + bbandsm [ i ] + "\\t bbandslower " + bbandsl [ i ] ) ; boolean closepricewithsma50 = trackcut ( closearray , ma50 , i , 5 ) ; boolean ema5withsma50 = trackcut ( ema5 , ma50 , i , 5 ) ; boolean ema100trend = tracktrend ( ema100 , i ) ; boolean sarwithcloseprice = sar [ i ] < closearray [ i ] ; boolean macdwithsignal = trackcut ( macd , signal , i , 5 ) ; boolean macdhist = histogram [ i ] > 0 ; boolean stocha = trackcut ( slowd , slowk , i , 2 ) ; system . out . println ( bars [ i ] . getbardatetime ( ) . gettime ( ) + " " + closepricewithsma50 + " " + ema5withsma50 + " " + ema100trend + " " + sarwithcloseprice + " " + macdwithsignal + " " + macdhist ) ; int sum = booleantoint ( closepricewithsma50 ) + booleantoint ( ema5withsma50 ) + booleantoint ( ema100trend ) + booleantoint ( sarwithcloseprice ) + booleantoint ( macdwithsignal ) + booleantoint ( macdhist ) ; bigdecimal subtract = bars [ i ] . getclose ( ) . subtract ( price ) ; if ( ! state && sum >= 4 ) { logs . add ( i + " " + bars [ i ] . getbardatetime ( ) . gettime ( ) + " buy " + bars [ i ] . getclose ( ) ) ; price = bars [ i ] . getclose ( ) ; state = ! state ; } else if ( state && stocha && subtract . compareto ( new bigdecimal ( 0.0001 ) . setscale ( 4 , roundingmode . down ) ) >= 0 ) { logs . add ( i + " " + bars [ i ] . getbardatetime ( ) . gettime ( ) + " sell " + bars [ i ] . getclose ( ) + " get " + subtract ) ; total = total . add ( subtract ) ; state = ! state ; } else if ( state && subtract . compareto ( new bigdecimal ( - 0.0010 ) . setscale ( 4 , roundingmode . down ) ) <= 0 ) { logs . add ( "cut lose" + subtract ) ; state = ! state ; } } logs . stream ( ) . foreach ( ( loge ) -> { system . out . println ( loge ) ; } ) ; system . out . println ( total ) ; }
te	3	private int getdebuffadjustedattackpower ( combatant combatant , int attackpower ) { int adjustedattackpower = 0 ; list < action > combatantdebuffs = combatant . getround ( round ) . getdebuffs ( ) ; if ( combatantdebuffs != null ) { for ( action debuff : combatantdebuffs ) { attackpower += debuff . getattackmod ( ) ; } } return adjustedattackpower + attackpower ; }
te	4	public static void main ( string [ ] args ) throws serialportexception { configuration . setrobot ( new capra6 ( ) ) ; final motorcontroller controller = new motorcontroller ( ) ; controller . setconnectionlistener ( new connectionlistener ( ) { @ override public void onconnect ( ) { system . out . println ( "motors connected" ) ; new thread ( new runnable ( ) { @ override public void run ( ) { try { controller . setvelocity ( 0.4 , 0 ) ; thread . sleep ( 30000 ) ; controller . setvelocity ( 0 , 0 ) ; } catch ( exception e ) { } } } ) . start ( ) ; } @ override public void ondisconnect ( ) { system . out . println ( "lost connection" ) ; } } ) ; controller . setpositionlistener ( new positionlistener ( ) { @ override public void onnewposition ( position position , long timestamp ) { } } ) ; controller . setstatuslistener ( new statuslistener ( ) { @ override public void onnewstatus ( status [ ] status ) { } } ) ; controller . settemperaturelistener ( new temperaturelistener ( ) { @ override public void onnewtemperature ( int [ ] temperature ) { } } ) ; controller . init ( ) ; try { thread . sleep ( 99999999 ) ; } catch ( interruptedexception e ) { } controller . disconnect ( ) ; }
te	2	private static void assertnotnull ( object o ) { if ( o == null ) { throw new runtimeexception ( "expected no null value" ) ; } }
te	5	@ override public productmodel createbook ( bookmodel book ) throws webshopappexception { int generatedid = productmodel . default_product_id ; if ( isvalidbook ( book , "create_book" ) ) { try ( connection conn = getconnection ( ) ) { conn . setautocommit ( false ) ; try { generatedid = super . insertproduct ( conn , book ) ; insertbook ( conn , book , generatedid ) ; conn . commit ( ) ; } catch ( sqlexception e ) { rollback ( conn ) ; throw e ; } } catch ( sqlexception e2 ) { webshopappexception excep = new webshopappexception ( e2 , this . getclass ( ) . getsimplename ( ) , "create_book" ) ; logger . error ( excep ) ; throw excep ; } } return null ; }
te	5	public void mousereleased ( mouseevent e ) { try { if ( piece == null ) { return ; } piece . setvisible ( false ) ; component c = chessboard . findcomponentat ( e . getx ( ) , e . gety ( ) ) ; if ( c instanceof jlabel ) { container parent = c . getparent ( ) ; parent . remove ( 0 ) ; parent . add ( piece ) ; } else { container parent = ( container ) c ; parent . add ( piece ) ; } piece . setvisible ( true ) ; } catch ( exception x ) { } }
te	6	private string _getexecutionmessage ( action a ) { string msg ; switch ( a ) { case move : msg = "karel moved" ; break ; case turn_left : msg = "karel turned left" ; break ; case turn_right : msg = "karel turned right" ; break ; case pick_up : msg = "karel picked up a beeper" ; break ; case put_down : msg = "karel put down a beeper" ; break ; default : msg = "error: could not execute" ; break ; } return msg ; }
te	9	protected enemy calclockontarget ( ) { enemy lockontarget = null ; for ( map . entry < string , enemy > e : ctx . nextenemymap . entryset ( ) ) { enemy r = e . getvalue ( ) ; if ( isstale ( r ) ) { continue ; } if ( lockontarget == null ) { lockontarget = r ; continue ; } if ( calcpriority ( lockontarget ) > calcpriority ( r ) ) { lockontarget = r ; } } return lockontarget ; }
te	6	private void refreshkey ( ) { if ( specs . islarge ( ) ) { for ( key key : largebitsmap . getmap ( ) . keyset ( ) ) { if ( largebitsmap . get ( key ) == currindex ) { this . key = key ; } } } else { for ( long key : bitsmap . getmap ( ) . keyset ( ) ) { if ( bitsmap . get ( key ) == currindex ) { smallkey = key ; } } } }
te	5	@ suppresswarnings ( "unchecked" ) public void openfiles ( ) throws filelockexception , ioexception { files = new headerindexfile [ numberofbuckets ] ; cumulativeelementsperfile = new int [ numberofbuckets ] ; int lastfile = 0 ; string path = drums . getdatabasedirectory ( ) ; for ( int i = 0 ; i < numberofbuckets ; i ++ ) { string filename = path + "/" + drums . gethashfunction ( ) . getfilename ( i ) ; if ( ! new file ( filename ) . exists ( ) ) { cumulativeelementsperfile [ i ] = 0 ; } else { lastfile = i ; files [ i ] = new headerindexfile < data > ( filename , 10 , drums . gp ) ; cumulativeelementsperfile [ i ] = ( int ) ( files [ i ] . getfilledupfromcontentstart ( ) / elementsize ) ; } if ( i > 0 ) { cumulativeelementsperfile [ i ] += cumulativeelementsperfile [ i - 1 ] ; } } destbuffer = bytebuffer . allocate ( ( int ) files [ lastfile ] . getchunksize ( ) ) ; filesareopened = true ; }
te	6	public void mostrapesquisa ( list < usuario > usuario ) { while ( tmavaliacao . getrowcount ( ) > 0 ) { tmavaliacao . removerow ( 0 ) ; } if ( ! usuario . isempty ( ) ) { string [ ] linha = new string [ ] { null , null } ; for ( int i = 0 ; i < usuario . size ( ) ; i ++ ) { tmavaliacao . addrow ( linha ) ; tmavaliacao . setvalueat ( usuario . get ( i ) . getnome ( ) , i , 0 ) ; tmavaliacao . setvalueat ( usuario . get ( i ) . getemail ( ) , i , 1 ) ; } } else { joptionpane . showmessagedialog ( null , "usu\xe1rio n\xe3o cadastrado!" , "aten\xe7\xe3o!" , 0 ) ; } }
te	8	@ override public string execute ( ) throws exception { try { map session = actioncontext . getcontext ( ) . getsession ( ) ; campaign camp = ( campaign ) session . get ( "campa" ) ; long campid = camp . getcampaignid ( ) ; if ( addimage == null && tileimage == null ) { campaigncreative campcre = new campaigncreative ( ) ; campcre . setcampaign ( campid ) ; campcre . setstyletype ( adtype ) ; campcre . setaddname ( adname ) ; campcre . setaddurl ( url ) ; campcre . setdisplayurl ( displayurl ) ; campcre . setaddtext ( adtext ) ; getmydao ( ) . getdbsession ( ) . save ( campcre ) ; user user = ( user ) session . get ( "user" ) ; setcamplist ( ( list < campaign > ) mydao . getdbsession ( ) . createquery ( "from campaign" ) . list ( ) ) ; criteria crit = mydao . getdbsession ( ) . createcriteria ( campaign . class ) ; crit . add ( restrictions . like ( "user" , user ) ) ; crit . setmaxresults ( 20 ) ; setcamplist ( ( list < campaign > ) crit . list ( ) ) ; addactionmessage ( "campaign " + camp . getcampaignname ( ) + " successfully created" ) ; return "success" ; } else if ( addimage == null ) { campaigncreative campcre = new campaigncreative ( ) ; campcre . setcampaign ( campid ) ; campcre . setstyletype ( adtype ) ; campcre . setaddname ( adname ) ; campcre . setaddurl ( url ) ; campcre . setdisplayurl ( displayurl ) ; campcre . setaddtext ( adtext ) ; byte [ ] tfile = new byte [ ( int ) tileimage . length ( ) ] ; fileinputstream fileinputstream ; fileinputstream = new fileinputstream ( tileimage ) ; fileinputstream . read ( tfile ) ; fileinputstream . close ( ) ; campcre . settileimage ( tfile ) ; getmydao ( ) . getdbsession ( ) . save ( campcre ) ; user user = ( user ) session . get ( "user" ) ; setcamplist ( ( list < campaign > ) mydao . getdbsession ( ) . createquery ( "from campaign" ) . list ( ) ) ; criteria crit = mydao . getdbsession ( ) . createcriteria ( campaign . class ) ; crit . add ( restrictions . like ( "user" , user ) ) ; crit . setmaxresults ( 20 ) ; setcamplist ( ( list < campaign > ) crit . list ( ) ) ; addactionmessage ( "campaign " + camp . getcampaignname ( ) + " successfully created" ) ; return "success" ; } else if ( tileimage == null ) { campaigncreative campcre = new campaigncreative ( ) ; campcre . setcampaign ( campid ) ; campcre . setstyletype ( adtype ) ; campcre . setaddname ( adname ) ; campcre . setaddurl ( url ) ; campcre . setdisplayurl ( displayurl ) ; campcre . setaddtext ( adtext ) ; byte [ ] afile = new byte [ ( int ) addimage . length ( ) ] ; fileinputstream fileinputstream = new fileinputstream ( addimage ) ; fileinputstream . read ( afile ) ; campcre . setaddimage ( afile ) ; getmydao ( ) . getdbsession ( ) . save ( campcre ) ; user user = ( user ) session . get ( "user" ) ; setcamplist ( ( list < campaign > ) mydao . getdbsession ( ) . createquery ( "from campaign" ) . list ( ) ) ; criteria crit = mydao . getdbsession ( ) . createcriteria ( campaign . class ) ; crit . add ( restrictions . like ( "user" , user ) ) ; crit . setmaxresults ( 20 ) ; setcamplist ( ( list < campaign > ) crit . list ( ) ) ; addactionmessage ( "campaign " + camp . getcampaignname ( ) + " successfully created" ) ; return "success" ; } else { campaigncreative campcre = new campaigncreative ( ) ; campcre . setcampaign ( campid ) ; campcre . setstyletype ( adtype ) ; campcre . setaddname ( adname ) ; campcre . setaddurl ( url ) ; campcre . setdisplayurl ( displayurl ) ; campcre . setaddtext ( adtext ) ; byte [ ] afile = new byte [ ( int ) addimage . length ( ) ] ; byte [ ] tfile = new byte [ ( int ) tileimage . length ( ) ] ; fileinputstream fileinputstream = new fileinputstream ( addimage ) ; fileinputstream . read ( afile ) ; campcre . setaddimage ( afile ) ; fileinputstream = new fileinputstream ( tileimage ) ; fileinputstream . read ( tfile ) ; fileinputstream . close ( ) ; campcre . settileimage ( tfile ) ; getmydao ( ) . getdbsession ( ) . save ( campcre ) ; user user = ( user ) session . get ( "user" ) ; setcamplist ( ( list < campaign > ) mydao . getdbsession ( ) . createquery ( "from campaign" ) . list ( ) ) ; criteria crit = mydao . getdbsession ( ) . createcriteria ( campaign . class ) ; crit . add ( restrictions . like ( "user" , user ) ) ; crit . setmaxresults ( 20 ) ; setcamplist ( ( list < campaign > ) crit . list ( ) ) ; addactionmessage ( "campaign " + camp . getcampaignname ( ) + " successfully created" ) ; return "success" ; } } catch ( hibernateexception e ) { addactionerror ( "server  error please recheck all fields " ) ; e . printstacktrace ( ) ; return "error" ; } catch ( nullpointerexception ne ) { addactionerror ( "server  error please recheck all fields " ) ; ne . printstacktrace ( ) ; return "error" ; } catch ( exception e ) { addactionerror ( "server  error please recheck all fields " ) ; e . printstacktrace ( ) ; return "error" ; } }
te	9	public void loadfilecustomformat ( string filepath , int maxcount , int minsize , int maxsize ) throws ioexception { string line ; bufferedreader reader = null ; try { reader = new bufferedreader ( new filereader ( filepath ) ) ; int count = 0 ; while ( ( line = reader . readline ( ) ) != null && count < maxcount ) { string [ ] split = line . split ( " " ) ; if ( split . length >= minsize && split . length <= maxsize ) { sequence sequence = new sequence ( - 1 ) ; for ( string value : split ) { item item = new item ( integer . valueof ( value ) ) ; sequence . additem ( item ) ; } sequences . add ( sequence ) ; count ++ ; } } } catch ( exception e ) { e . printstacktrace ( ) ; } finally { if ( reader != null ) { reader . close ( ) ; } } }
te	1	public void drawsidemenu ( ) { activepane . draw ( ) ; }
te	9	public void setplayertype ( ) { string p1type = game . getplayer ( 0 ) . getplayertype ( ) ; string p2type = game . getplayer ( 1 ) . getplayertype ( ) ; element playeronetype = m_doc . createelement ( "type" ) ; element playertwotype = m_doc . createelement ( "type" ) ; if ( p1type . equals ( "computereasy" ) ) { playeronetype . appendchild ( m_doc . createtextnode ( "computer: easy" ) ) ; } else if ( p1type . equals ( "human" ) ) { playeronetype . appendchild ( m_doc . createtextnode ( p1type ) ) ; } else { playeronetype . appendchild ( m_doc . createtextnode ( "computer: hard" ) ) ; } if ( p2type . equals ( "computereasy" ) ) { playertwotype . appendchild ( m_doc . createtextnode ( "computer: easy" ) ) ; } else if ( p2type . equals ( "human" ) ) { playertwotype . appendchild ( m_doc . createtextnode ( p2type ) ) ; } else { playertwotype . appendchild ( m_doc . createtextnode ( "computer: hard" ) ) ; } m_playerone . appendchild ( playeronetype ) ; m_playertwo . appendchild ( playertwotype ) ; }
te	7	public static boolean checknumbers ( integer i , integer j ) { char [ ] base = i . tostring ( ) . tochararray ( ) ; char [ ] comp = j . tostring ( ) . tochararray ( ) ; for ( char b : base ) { boolean t = false ; for ( char c : comp ) { if ( b == c ) t = true ; } if ( ! t ) return false ; } return true ; }
te	8	@ override public void validate ( ) { if ( adname == null ) { addactionerror ( "please enter ad name" ) ; } if ( url == null ) { addactionerror ( "please enter ad url" ) ; } if ( adtext == null ) { addactionerror ( "please enter ad text" ) ; } }
te	8	public string [ ] getprimarykeysforsearchhits ( final topdocscollector < scoredoc > collector ) throws ioexception { string [ ] arrret = empty_results ; indexsearcher searcher = null ; if ( collector != null && ( searcher = preparesearcher ( ) ) != null ) { final topdocs topdocs = collector . topdocs ( ) ; if ( topdocs != null ) { final list < string > listpks = new arraylist < string > ( topdocs . totalhits ) ; final scoredoc [ ] arrscoredoc = topdocs . scoredocs ; if ( arrscoredoc != null ) { final int ilength = arrscoredoc . length ; arrret = new string [ ilength ] ; for ( int i = 0 ; i < ilength ; i ++ ) { final document doc = searcher . doc ( arrscoredoc [ i ] . doc ) ; if ( doc != null ) { final fieldable fieldpk = doc . getfieldable ( field_pk ) ; if ( fieldpk != null ) { listpks . add ( fieldpk . stringvalue ( ) ) ; } } } } arrret = listpks . toarray ( new string [ listpks . size ( ) ] ) ; } } return arrret ; }
te	4	private list < inspectoropentask > getscheduledtasks ( ) { list < inspectoropentask > res = new arraylist < > ( ) ; try { field ctlist = craftscheduler . class . getdeclaredfield ( "head" ) ; ctlist . setaccessible ( true ) ; object headobject = ctlist . get ( ( craftscheduler ) this . server . getscheduler ( ) ) ; class headobjectclass = headobject . getclass ( ) ; field runners = headobjectclass . getdeclaredfield ( "runners" ) ; runners . setaccessible ( true ) ; map < integer , object > output = ( concurrenthashmap < integer , object > ) runners . get ( headobject ) ; for ( map . entry pairs : output . entryset ( ) ) { object outputval = pairs . getvalue ( ) ; class valueclass = outputval . getclass ( ) ; class valuesuperclass = valueclass . getsuperclass ( ) ; field objpluginnamefield ; field objclassnamefield ; field objtaskidfield ; field objrecurringperiodfield ; boolean isasync = false ; try { objpluginnamefield = valuesuperclass . getdeclaredfield ( "plugin" ) ; objclassnamefield = valuesuperclass . getdeclaredfield ( "task" ) ; objtaskidfield = valuesuperclass . getdeclaredfield ( "id" ) ; objrecurringperiodfield = valuesuperclass . getdeclaredfield ( "period" ) ; isasync = true ; } catch ( nosuchfieldexception | securityexception ex ) { objpluginnamefield = valueclass . getdeclaredfield ( "plugin" ) ; objclassnamefield = valueclass . getdeclaredfield ( "task" ) ; objtaskidfield = valueclass . getdeclaredfield ( "id" ) ; objrecurringperiodfield = valueclass . getdeclaredfield ( "period" ) ; } objpluginnamefield . setaccessible ( true ) ; objclassnamefield . setaccessible ( true ) ; objtaskidfield . setaccessible ( true ) ; objrecurringperiodfield . setaccessible ( true ) ; object objpluginname = objpluginnamefield . get ( outputval ) ; string pluginname = ( ( plugin ) objpluginname ) . getname ( ) ; object objclassname = objclassnamefield . get ( outputval ) ; string classname = objclassname . tostring ( ) . substring ( 0 , objclassname . tostring ( ) . indexof ( "@" ) ) ; object objtaskid = objtaskidfield . get ( outputval ) ; string taskid = objtaskid . tostring ( ) ; object objrecurringperiod = objrecurringperiodfield . get ( outputval ) ; string recurringperiod = objrecurringperiod . tostring ( ) ; res . add ( new inspectoropentask ( pluginname , classname , integer . valueof ( taskid ) , long . valueof ( recurringperiod ) , isasync ) ) ; } } catch ( nosuchfieldexception | securityexception | illegalargumentexception | illegalaccessexception ex ) { } collections . sort ( res ) ; return res ; }
te	2	public void undoableedithappened ( undoableeditevent event ) { if ( ! event . getedit ( ) . getpresentationname ( ) . equals ( uimanager . getstring ( "abstractdocument.stylechangetext" ) ) ) { undoableedit edit = event . getedit ( ) ; undomanager . addedit ( edit ) ; } }
te	10	public boolean relocatesettings ( ) { boolean success = true ; try { if ( ! hspath . exists ( ) ) { hspath . mkdir ( ) ; if ( getoldchannelstorefile ( ) . exists ( ) ) { copyfile ( getoldchannelstorefile ( ) , getchannelstorefile ( ) ) ; } if ( getolditemstorefile ( ) . exists ( ) ) { copyfile ( getolditemstorefile ( ) , getitemstorefile ( ) ) ; } if ( getolditemhistoryfile ( ) . exists ( ) ) { copyfile ( getolditemhistoryfile ( ) , getitemhistoryfile ( ) ) ; } } } catch ( ioexception ioe ) { cat . error ( ioe ) ; success = false ; } return success ; }
te	9	private void leerarchivo ( ) { scanner ent = null ; try { ent = new scanner ( new file ( "conf/conexion.conf" ) ) ; while ( ent . hasnext ( ) ) { string aux = ent . nextline ( ) ; switch ( dividir ( aux , ": " ) [ 0 ] ) { case "url" : url = dividir ( aux , ": " ) [ 1 ] ; break ; case "user" : user = dividir ( aux , ": " ) [ 1 ] ; break ; case "pass" : pass = dividir ( aux , ": " ) [ 1 ] ; break ; case "driver" : driver = dividir ( aux , ": " ) [ 1 ] ; break ; } } } catch ( filenotfoundexception ex ) { system . out . println ( "error al abrir el archivo de configuraci\xf3n.\\n" + ex . getmessage ( ) ) ; } finally { try { if ( ent != null ) ent . close ( ) ; } catch ( nullpointerexception ex ) { system . out . println ( "archivo nunca abierto\\n" + ex . getmessage ( ) ) ; } } }
te	1	public void buttonactionlisteners ( actionlistener al ) { deleteimage . setactioncommand ( "borrarimagen" ) ; deleteimage . addactionlistener ( al ) ; }
te	4	public void createinitialincidentdetails ( beincident incident ) { if ( incident == null ) { bllerror . getinstance ( ) . dberror ( ) ; return ; } beincidentdetails details = new beincidentdetails ( null , null , null , incident , null , null , null , null , null , null ) ; try { bllread . getinstance ( ) . readincidentdetails ( ) ; dalcreate . createinitialincidentdetails ( details ) ; } catch ( sqlexception ex ) { bllerror . getinstance ( ) . dberror ( ) ; return ; } bllread . getinstance ( ) . addtoincidentdetails ( details ) ; }
te	2	public static void modifysocket ( socket s ) { inetaddress add = nextaddress ( ) ; try { s . bind ( new inetsocketaddress ( add , 0 ) ) ; } catch ( ioexception e ) { system . out . println ( "failed to bind socket" ) ; } }
te	4	public static void sendsimpleemail ( string mailserver , boolean attach ) throws emailexception { htmlemail email = new htmlemail ( ) ; if ( google . equals ( mailserver ) ) setgoogleemail ( email ) ; email . addto ( "tim_ph@yahoo.com" , "tim yahoo" ) ; email . setsubject ( "test commonsmail with no attachment" ) ; email . setmsg ( "this message might have an attachment" ) ; if ( attach ) { emailattachment attachment = getattachment ( ) ; email . attach ( attachment ) ; } email . send ( ) ; }
te	3	private bitmapcharacter getcharacter ( int id ) { for ( int i = 0 ; i < characters . size ( ) ; i ++ ) { if ( id == characters . get ( i ) . getid ( ) ) { return characters . get ( i ) ; } } return null ; }
te	9	public arraylist < card > getplayablecard ( suit turn ) { if ( this . hand != null && turn != null && turn != suit . none ) { arraylist < card > ret = new arraylist < card > ( ) ; iterator < card > itr = this . hand . iterator ( ) ; card add = null ; while ( itr . hasnext ( ) ) { add = itr . next ( ) ; if ( add . getsuit ( ) . equals ( turn ) ) { ret . add ( add ) ; } } if ( ret . size ( ) != 0 ) { return ret ; } } return this . hand ; }
te	10	static string readmessage ( string location ) { testmessage outmsg = null ; try { objectinputstream in ; if ( location . startswith ( "http://" ) ) { url url = new url ( location ) ; urlconnection urlcon = url . openconnection ( ) ; in = new objectinputstream ( urlcon . getinputstream ( ) ) ; } else { fileinputstream fis = new fileinputstream ( location ) ; in = new objectinputstream ( fis ) ; } object fromloc = in . readobject ( ) ; in . close ( ) ; if ( fromloc instanceof testmessage ) outmsg = ( testmessage ) fromloc ; } catch ( ioexception | classnotfoundexception e ) { e . printstacktrace ( ) ; } if ( outmsg != null ) return outmsg . getmessage ( ) ; return null ; }
te	7	public byte [ ] getblobcolumn ( resultset rs , int columnindex ) throws sqlexception { try { blob blob = rs . getblob ( columnindex ) ; if ( blob == null ) { return null ; } inputstream is = blob . getbinarystream ( ) ; bytearrayoutputstream bos = new bytearrayoutputstream ( ) ; if ( is == null ) { return null ; } else { byte buffer [ ] = new byte [ 64 ] ; int c = is . read ( buffer ) ; while ( c > 0 ) { bos . write ( buffer , 0 , c ) ; c = is . read ( buffer ) ; } return bos . tobytearray ( ) ; } } catch ( ioexception e ) { throw new sqlexception ( "failed to read blob column due to ioexception: " + e . getmessage ( ) ) ; } }
te	6	private static void updatemetadata ( ) { if ( metadatamodel == null ) metadatamodel = new defaultcomboboxmodel ( ) ; metadatamodel . removeallelements ( ) ; if ( labelssave != null ) for ( string s : labelssave ) metadatamodel . addelement ( s ) ; }
te	1	private static angleinterval createsectorbeforenewangle ( double lastangle , angleinterval closestsector , angleinterval newangle ) { return new angleinterval ( lastangle , closestsector . distancefromline ( lastangle ) , newangle . leftangle , closestsector . distancefromline ( newangle . leftangle ) ) ; }
te	7	private void liftanalysis ( treeset < probholder > sortedtreeforestimatinglift ) { printtofile liftsfile = new printtofile ( ) ; liftsfile . openfile ( classify . datapath + classify . / + "results" + classify . / + "lifts" + classify . / + "" + classify . inttocat . get ( classify . category ) + classify . / + "" + classify . filename + ".csv" ) ; liftsfile . writetofile ( "top_prc_ranked<litcomma> lift" ) ; system . out . println ( ) ; system . out . println ( "--------------------------------------------------------" ) ; system . out . println ( "| top ranked % | # instances | # positives |  %  | lift |" ) ; system . out . println ( "--------------------------------------------------------" ) ; decimalformat myformatter = new decimalformat ( "#.###" ) ; for ( double th = 0.95 ; th > 0 ; th -= 0.05 ) { double positive = 0 ; double total = 0 ; for ( probholder ph : sortedtreeforestimatinglift . headset ( new probholder ( th , - 1 ) ) ) { if ( ph . ispositive ( ) ) positive ++ ; total ++ ; } if ( total > 20 ) { double actualprob = positive / total ; string prc = myformatter . format ( actualprob ) ; double lift = actualprob / ( 1 - baseline ) ; string topstr = myformatter . format ( 1 - th ) ; string liftstr = myformatter . format ( lift ) ; system . out . println ( "|     " + topstr + "     |    " + ( int ) total + "    |    " + ( int ) positive + "    |   " + prc + "   | " + liftstr + " |" ) ; liftsfile . writetofile ( topstr + "<litcomma>" + lift ) ; } } system . out . println ( "--------------------------------------------------------" ) ; liftsfile . closefile ( ) ; }
te	4	public void createerrorreport ( beerror error ) { if ( error == null ) { bllerror . getinstance ( ) . createerrorreporterror ( ) ; return ; } try { dalcreate . createerrorreport ( error ) ; } catch ( sqlexception ex ) { bllerror . getinstance ( ) . createerrorreporterror ( ) ; } }
te	10	static synchronized void send ( int src , int dest , double delay , int tag , object data ) { if ( delay < 0.0 ) { throw new sim_exception ( "sim_system: send delay can't be negative." ) ; } sim_event e = new sim_event ( sim_event . send , clock + delay , src , dest , tag , data ) ; if ( auto_trace && ( default_trace || ( event_trace && is_trace_tag ( tag ) ) ) ) { trace ( src , "scheduling event type " + tag + " for " + ( ( sim_entity ) entities . get ( dest ) ) . get_name ( ) + " with delay " + delay ) ; } future . add_event ( e ) ; }
te	6	private void serialize ( writer writer , datasetgraph dataset , prefixmap prefixmap , string baseuri ) { try { object obj = jsonld . fromrdf ( dataset , new jenardf2jsonld ( ) ) ; if ( ispretty ( ) ) jsonutils . writeprettyprint ( writer , obj ) ; else jsonutils . write ( writer , obj ) ; } catch ( jsonldprocessingerror e ) { e . printstacktrace ( ) ; } catch ( jsongenerationexception e ) { e . printstacktrace ( ) ; } catch ( jsonmappingexception e ) { e . printstacktrace ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } }
te	2	public synchronized void quarantineandcleanupmarkedobjects ( ) { final rdkitcleanuptracker quarantinerdkitobjects = new rdkitcleanuptracker ( this ) ; clear ( ) ; if ( ! quarantinerdkitobjects . isempty ( ) ) { final timertask futurecleanuptask = new timertask ( ) { @ override public void run ( ) { quarantinerdkitobjects . cleanupmarkedobjects ( ) ; } } ; final timer timer = new timer ( "quarantine rdkit object cleanup" , false ) ; timer . schedule ( futurecleanuptask , rdkit . rdkit_object_cleanup_delay_for_quarantine ) ; } }
te	2	public static void setbearcreationprobability ( double bear_creation_probability ) { if ( bear_creation_probability >= 0 ) simulator . bear_creation_probability = bear_creation_probability ; }
te	6	public boolean foreachfromtail ( recordprocessor < t > processor ) { try { currentlog . out . close ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } int lognameindex = currentlog . lognameindex ; file logfile = new file ( logdir , string . valueof ( lognameindex ) ) ; boolean iscontinue = true ; while ( logfile . exists ( ) && iscontinue ) { iscontinue = readonefile ( logfile , processor , lognameindex ) ; lognameindex -- ; logfile = new file ( logdir , string . valueof ( lognameindex ) ) ; } return iscontinue ; }
te	9	public static void main ( string [ ] args ) { for ( int i = 0 ; i <= 1000 ; i ++ ) { if ( math . abs ( math . sqrt ( i ) - math . round ( math . sqrt ( i ) ) ) > .0001 ) { long n = 0 ; while ( true ) { n ++ ; double result = math . sqrt ( i ) * n ; if ( math . abs ( math . round ( result ) - result ) < .0001 ) { biginteger leftside = new biginteger ( "" + ( long ) ( math . round ( result ) ) ) ; leftside = leftside . pow ( 2 ) ; biginteger rightside = new biginteger ( "" + n ) ; rightside = rightside . pow ( 2 ) ; rightside = rightside . multiply ( new biginteger ( "" + i ) ) ; rightside = rightside . add ( biginteger . one ) ; if ( leftside . equals ( rightside ) ) break ; } if ( n > 10000000000l ) { system . out . print ( "here: " ) ; break ; } } system . out . println ( i ) ; } } }
