tr	3	public static void mergesort ( int [ ] a ) { int [ ] temp = new int [ a . length ] ; int [ ] [ ] matrix = new int [ a . length ] [ a . length ] ; mergesort ( a , temp , 0 , a . length - 1 ) ; quicksort ( a , 0 , a . length - 1 ) ; doinsertionsort ( a ) ; binarysearch ( a , 1 ) ; recursivebinarysearch ( a , 0 , a . length - 1 , 1 ) ; searchinrotatedarray ( a , 1 ) ; searchinrotatedarraywithdup ( a , 1 ) ; search2dmatrix ( matrix , 1 ) ; arraylist < string > list = new arraylist < string > ( ) ; collections . sort ( list ) ; }
tr	6	public final area zoom ( ) { area a = ( area ) this ; a . mycells = new treeset ( ) ; double deltalat = topleft [ 0 ] - bottomright [ 0 ] / analyzer . zoom_factor ; double deltalon = bottomright [ 1 ] - topleft [ 1 ] / analyzer . zoom_factor ; for ( int i = 0 ; i < analyzer . zoom_factor ; i ++ ) { for ( int j = 0 ; j < analyzer . zoom_factor ; j ++ ) { cell __c = new cell ( ) ; __c . topleft [ 0 ] = topleft [ 0 ] - j * deltalat ; __c . topleft [ 1 ] = topleft [ 1 ] + i * deltalon ; __c . bottomright [ 0 ] = bottomright [ 0 ] + ( analyzer . zoom_factor - j ) * deltalat ; __c . bottomright [ 1 ] = bottomright [ 1 ] - ( analyzer . zoom_factor - i ) * deltalon ; a . mycells . add ( __c ) ; } } return a ; }
tr	8	public static arraylist < string [ ] > parsewiftext ( string wallettext ) { arraylist < string [ ] > keyaddresspairs = new arraylist < string [ ] > ( ) ; string trimedinputstring = wallettext . trim ( ) ; string [ ] lines = trimedinputstring . split ( "\\n" ) ; for ( string line : lines ) { string trimedline = line . trim ( ) ; if ( trimedline . equals ( "" ) || trimedline . charat ( 0 ) == '#' ) { continue ; } string trimedlinewithouttabs = trimedline . replace ( '\\t' , ' ' ) ; string privkeywif = trimedlinewithouttabs . split ( " " ) [ 0 ] ; string address = btcutils . getb58addressfromb58privkey ( privkeywif ) ; keyaddresspairs . add ( new string [ ] { privkeywif , address } ) ; } return keyaddresspairs ; }
tr	7	slidingpuzzleboard ( final int colcount , final int rowcount ) { setstyle ( "-fx-background-color: #f3f3f3; " + "-fx-border-color: #f3f3f3; " ) ; cols = colcount ; rows = rowcount ; double gameboardwidth = slidingpuzzlepiece . getpuzzlesize ( ) * colcount ; double gameboardheigth = slidingpuzzlepiece . getpuzzlesize ( ) * rowcount ; setprefsize ( gameboardwidth , gameboardheigth ) ; setmaxsize ( gameboardwidth , gameboardheigth ) ; autosize ( ) ; final int i70 = 70 ; path gameboardgrid = new path ( ) ; gameboardgrid . setstroke ( color . rgb ( i70 , i70 , i70 ) ) ; getchildren ( ) . add ( gameboardgrid ) ; final int i5 = 5 ; for ( int spalte = 0 ; spalte < colcount - 1 ; spalte ++ ) { gameboardgrid . getelements ( ) . addall ( new moveto ( slidingpuzzlepiece . getpuzzlesize ( ) + slidingpuzzlepiece . getpuzzlesize ( ) * spalte , i5 ) , new lineto ( slidingpuzzlepiece . getpuzzlesize ( ) + slidingpuzzlepiece . getpuzzlesize ( ) * spalte , slidingpuzzlepiece . getpuzzlesize ( ) * rowcount - i5 ) ) ; } for ( int zeile = 0 ; zeile < rowcount - 1 ; zeile ++ ) { gameboardgrid . getelements ( ) . addall ( new moveto ( i5 , slidingpuzzlepiece . getpuzzlesize ( ) + slidingpuzzlepiece . getpuzzlesize ( ) * zeile ) , new lineto ( slidingpuzzlepiece . getpuzzlesize ( ) * colcount - i5 , slidingpuzzlepiece . getpuzzlesize ( ) + slidingpuzzlepiece . getpuzzlesize ( ) * zeile ) ) ; } }
tr	8	private static void sort ( double [ ] d , double [ ] [ ] z ) { int l ; int k ; int j ; int i ; int ip1 ; double p ; int ii ; int n = d . length ; for ( l = 1 ; l <= n ; l = 3 * l + 1 ) ; while ( l > 2 ) { l = l / 3 ; k = n - l ; for ( j = 0 ; j < k ; j ++ ) { i = j ; while ( i >= 0 ) { ip1 = i + l ; if ( d [ i ] < d [ ip1 ] || double . isnan ( d [ i ] ) ) { p = d [ i ] ; d [ i ] = d [ ip1 ] ; d [ ip1 ] = p ; for ( ii = 0 ; ii < n ; ii ++ ) { p = z [ ii ] [ i ] ; z [ ii ] [ i ] = z [ ii ] [ ip1 ] ; z [ ii ] [ ip1 ] = p ; } i = i - l ; } else break ; } } } }
tr	2	@ test public void test ( ) throws exception { url pdmlurl = pdmlreadertest . class . getresource ( "sipcall.pdml" ) ; assert . assertnotnull ( pdmlurl ) ; pdml pdml = new pdmlreader ( ) . unmarshall ( pdmlurl ) ; assert . assertnotnull ( pdml ) ; assert . assertequals ( 1571 , pdml . packets . length ) ; assert . assertequals ( 6 , pdml . packets [ 300 ] . protocols . length ) ; assert . assertequals ( "rtp" , pdml . packets [ 300 ] . protocols [ 5 ] . name ) ; assert . assertequals ( 12 , pdml . packets [ 300 ] . protocols [ 5 ] . fields . length ) ; assert . assertequals ( "rtp.payload" , pdml . packets [ 300 ] . protocols [ 5 ] . fields [ 11 ] . name ) ; assert . assertequals ( "080b88fef3bc8a9f4c55fe46a1281fbeb1a4b4ee9ac01ff880" , pdml . packets [ 300 ] . protocols [ 5 ] . fields [ 11 ] . value ) ; }
tr	7	list < string > getsequence ( ) { list < string > sequence = new arraylist < > ( ) ; list < integer > indicies = new arraylist < > ( operatorboxcount ) ; for ( int i = 0 ; i < operatorboxcount ; ++ i ) { indicies . add ( 0 ) ; } boolean stopflag = false ; while ( true ) { stopflag = true ; for ( int index : indicies ) { stopflag &= index == operators_len - 1 ; } stringbuilder builder = new stringbuilder ( ) ; for ( int index : indicies ) { builder . append ( operators . charat ( index ) ) ; } sequence . add ( builder . tostring ( ) ) ; if ( stopflag ) { break ; } int iix = 0 ; while ( this . operatorboxcount > iix ) { indicies . set ( iix , ( indicies . get ( iix ) + 1 ) % operators_len ) ; if ( indicies . get ( iix ) > 0 ) { break ; } iix ++ ; } } return sequence ; }
tr	4	private static void getuserrecordsnranking ( ) { user . addalluser ( ) ; list < user > users = new linkedlist < user > ( user . alluserset . values ( ) ) ; collections . sort ( users ) ; try { bufferedwriter fout = new bufferedwriter ( new filewriter ( "res/usercheckins-rank.txt" ) ) ; for ( int i = users . size ( ) - 1 ; i >= 0 ; i -- ) { user u = users . get ( i ) ; u . getlocations ( ) ; fout . write ( string . format ( "%d\\t%d\\t%d%n" , u . userid , u . records . size ( ) , u . locs . size ( ) ) ) ; } fout . close ( ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } }
tr	2	private string generarcontenidoclase ( ) { contenidoclase = new stringbuilder ( ) ; contenidoclase . append ( "package " + paquetecontenedordestino + ";\\n" + nl ) ; contenidoclase . append ( nl + "/* clase - autogenerada" ) ; contenidoclase . append ( nl + " * fecha creacion: " + new date ( ) + " */" + nl ) ; contenidoclase . append ( generarimports ( ) ) ; contenidoclase . append ( "public class " + nombrevo + " implements serializable{" + nl ) ; date fechaactual = new date ( ) ; long serialversionuid = fechaactual . gettime ( ) ; contenidoclase . append ( nl + tb + "private static final long serialversionuid = " + serialversionuid + "l;" + nl ) ; contenidoclase . append ( generarbloqueatributos ( ) ) ; contenidoclase . append ( nl + tb + "public " + nombrevo + "(){\\n\\t}" + nl ) ; contenidoclase . append ( generarbloquesettergetters ( ) ) ; contenidoclase . append ( generarmetodotostring ( ) ) ; contenidoclase . append ( nl + "}" ) ; return contenidoclase . tostring ( ) ; }
tr	7	private ichromosome setupchromosome ( final int [ ] set ) throws invalidconfigurationexception { subsetgenes = new gene [ k ] ; int minelementvalue = integer . max_value ; int maxelementvalue = integer . min_value ; for ( final int element : set ) { minelementvalue = math . min ( element , minelementvalue ) ; maxelementvalue = math . max ( element , maxelementvalue ) ; } for ( int g = 0 ; g < k ; g ++ ) { subsetgenes [ g ] = new integergene ( configuration , 0 , numelementsinset - 1 ) ; } final gene [ ] genes = new gene [ 1 + getnumberofparameters ( ) ] ; final abstractsupergene constrainedgenes = new subsetsupergene ( configuration , subsetgenes , this . allelements ) ; genes [ 0 ] = constrainedgenes ; for ( int paramindex = 0 ; paramindex < getnumberofparameters ( ) ; paramindex ++ ) { genes [ 1 + paramindex ] = new integergene ( configuration , 0 , this . allpossibleparametervalues [ paramindex ] . length - 1 ) ; } subsetchromosome = new chromosome ( configuration , genes ) ; return subsetchromosome ; }
tr	8	private void handlehttprequest ( channelhandlercontext ctx , fullhttprequest req , string ip ) { string uri = req . geturi ( ) ; fullhttpresponse resp = null ; if ( uri . equalsignorecase ( status ) ) { managerdb . addorupdaterequestamount ( ip , dateformat . format ( new date ( ) ) ) ; serverstatus . addrequest ( ) ; pagestatus page = new pagestatus ( ) ; string send = page . getpage ( ) ; bytebuf buf = unpooled . unreleasablebuffer ( unpooled . copiedbuffer ( send , charsetutil . us_ascii ) ) ; resp = new defaultfullhttpresponse ( http_1_1 , ok , buf ) ; resp . headers ( ) . set ( content_type , "text/html" ) ; resp . headers ( ) . set ( content_length , resp . content ( ) . readablebytes ( ) ) ; sendhttpresponse ( ctx , req , resp ) ; trafficlog ( ) ; managerdb . insertconnection ( ip , uri , dateformat . format ( new date ( ) ) , sentbytes , receivedbytes , speed ) ; } else if ( uri . equalsignorecase ( hello ) ) { try { thread . sleep ( timesleep * 1000 ) ; } catch ( interruptedexception ex ) { ex . printstacktrace ( ) ; } page page = new pagehello ( ) ; managerdb . addorupdaterequestamount ( ip , dateformat . format ( new date ( ) ) ) ; serverstatus . addrequest ( ) ; string send = page . getpage ( ) ; bytebuf buf = unpooled . unreleasablebuffer ( unpooled . copiedbuffer ( send , charsetutil . us_ascii ) ) ; resp = new defaultfullhttpresponse ( http_1_1 , ok , buf ) ; resp . headers ( ) . set ( content_type , "text/html" ) ; resp . headers ( ) . set ( content_length , resp . content ( ) . readablebytes ( ) ) ; sendhttpresponse ( ctx , req , resp ) ; trafficlog ( ) ; managerdb . insertconnection ( ip , uri , dateformat . format ( new date ( ) ) , sentbytes , receivedbytes , speed ) ; } else if ( uri . tolowercase ( ) . contains ( redirect ) && uri . tolowercase ( ) . contains ( "url" ) ) { managerdb . addorupdaterequestamount ( ip , dateformat . format ( new date ( ) ) ) ; serverstatus . addrequest ( ) ; string redirect ; if ( uri . tolowercase ( ) . contains ( "http://" ) ) { redirect = uri . substring ( 14 ) ; } else { redirect = "http://" + uri . substring ( 14 ) ; } bytebuf buf23 = unpooled . unreleasablebuffer ( unpooled . copiedbuffer ( "" , charsetutil . us_ascii ) ) ; resp = new defaultfullhttpresponse ( http_1_1 , temporary_redirect , buf23 ) ; resp . headers ( ) . set ( location , redirect ) ; sendhttpresponse ( ctx , req , resp ) ; trafficlog ( ) ; managerdb . insertconnection ( ip , uri , dateformat . format ( new date ( ) ) , sentbytes , receivedbytes , speed ) ; } else { bytebuf buf2 = unpooled . unreleasablebuffer ( unpooled . copiedbuffer ( "404 page not found" , charsetutil . us_ascii ) ) ; resp = new defaultfullhttpresponse ( http_1_1 , ok , buf2 ) ; resp . headers ( ) . set ( content_type , "text/plain" ) ; resp . headers ( ) . set ( content_length , resp . content ( ) . readablebytes ( ) ) ; sendhttpresponse ( ctx , req , resp ) ; } }
tr	7	public static byte [ ] decodebytearray ( object obj ) throws exception { byte [ ] ba = null ; if ( obj instanceof arrayparameter ) { final arrayparameter arrayparameter = ( arrayparameter ) obj ; final arraylist < ? > values = arrayparameter . getvalues ( ) ; ba = new byte [ values . size ( ) ] ; for ( int i = 0 ; i < values . size ( ) ; i ++ ) { singleparameter param = ( singleparameter ) values . get ( i ) ; object value = param . getvalue ( ) ; if ( ! ( value instanceof integer ) ) { throw new illegalargumentexception ( "invalid type" ) ; } int intvalue = ( ( integer ) value ) . intvalue ( ) ; ba [ i ] = inttobyte ( intvalue ) ; } } return ba ; }
tr	10	public static void main ( string [ ] args ) { command cmd = null ; if ( args [ 1 ] . equals ( "add" ) ) { cmd = new addcommand ( integer . parseint ( args [ 2 ] ) , integer . parseint ( args [ 3 ] ) , args [ 4 ] ) ; } else if ( args [ 1 ] . equals ( "read" ) ) { cmd = new readcommand ( integer . parseint ( args [ 2 ] ) ) ; } else if ( args [ 1 ] . equals ( "write" ) ) { cmd = new writecommand ( integer . parseint ( args [ 2 ] ) , args [ 3 ] ) ; } else if ( args [ 1 ] . equals ( "remove" ) ) { cmd = new removecommand ( integer . parseint ( args [ 2 ] ) ) ; } else { system . err . println ( "usage: program command options" ) ; } try { sslcontext ctx ; keymanagerfactory kmf ; keystore ks ; trustmanagerfactory tmf ; char [ ] passphrase = "jagkan" . tochararray ( ) ; ctx = sslcontext . getinstance ( "sslv3" ) ; kmf = keymanagerfactory . getinstance ( "sunx509" ) ; ks = keystore . getinstance ( "jks" ) ; tmf = trustmanagerfactory . getinstance ( "sunx509" ) ; ks . load ( new fileinputstream ( "./keys/client/ks_" + args [ 0 ] ) , passphrase ) ; kmf . init ( ks , passphrase ) ; tmf . init ( ks ) ; ctx . init ( kmf . getkeymanagers ( ) , tmf . gettrustmanagers ( ) , null ) ; sslsocketfactory factory = ctx . getsocketfactory ( ) ; sslsocket s = ( sslsocket ) factory . createsocket ( host , port ) ; s . starthandshake ( ) ; serverproxy sp = new serverproxy ( s ) ; string returnmessage = sp . sendcommand ( cmd ) ; sp . close ( ) ; system . out . println ( returnmessage ) ; } catch ( unrecoverablekeyexception e ) { e . printstacktrace ( ) ; } catch ( certificateexception e ) { e . printstacktrace ( ) ; } catch ( nosuchalgorithmexception e ) { e . printstacktrace ( ) ; } catch ( keystoreexception e ) { e . printstacktrace ( ) ; } catch ( keymanagementexception e ) { e . printstacktrace ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } }
tr	4	private bufferedimage loadimage ( string ref ) throws ioexception { url url = textureloader . class . getclassloader ( ) . getresource ( ref ) ; if ( url == null ) { throw new ioexception ( "cannot find: " + ref ) ; } image img = new imageicon ( url ) . getimage ( ) ; bufferedimage bufferedimage = new bufferedimage ( img . getwidth ( null ) , img . getheight ( null ) , bufferedimage . type_int_argb ) ; graphics g = bufferedimage . getgraphics ( ) ; g . drawimage ( img , 0 , 0 , null ) ; g . dispose ( ) ; return bufferedimage ; }
tr	9	public static void main ( string [ ] args ) throws filenotfoundexception , xmlstreamexception , urisyntaxexception { file uri = new file ( exercise1 . class . getresource ( "/genia_treebank_v1" ) . touri ( ) ) ; long start = system . currenttimemillis ( ) ; corpus corpus = corpusparser . parse ( uri ) ; trainingandtestsplitter splitter = new trainingandtestsplitter ( corpus , 0.9 ) ; corpus training = splitter . gettrainingcorpus ( ) ; corpus test = splitter . gettestcorpus ( ) ; bigrammlemodel model = new bigrammlemodel ( training ) ; double perplexity = perplexity . calculate ( model , test ) ; system . out . println ( "perplexity: " + perplexity ) ; long time = system . currenttimemillis ( ) - start ; system . out . println ( "runtime: " + time + "ms\\n" ) ; }
tr	8	public changerpanel ( songchanger schanger ) { this . schanger = schanger ; change = new jbutton ( "change!" ) ; buttonlistener changer = new buttonlistener ( ) ; change . addactionlistener ( changer ) ; percentage = new jlabel ( "by what percent?" ) ; percentage2 = new jlabel ( "by what percent?" ) ; tempo = new jcheckbox ( "change tempo?" ) ; bass = new jcheckbox ( "change bass?" ) ; checkboxlistener checkboxlistener = new checkboxlistener ( ) ; tempo . additemlistener ( checkboxlistener ) ; bass . additemlistener ( checkboxlistener ) ; tempopercent = new jtextfield ( 3 ) ; basspercent = new jtextfield ( 3 ) ; tempopercent . settext ( "0" ) ; basspercent . settext ( "0" ) ; upoctave = new jradiobutton ( "+ octave" , false ) ; stayoctave = new jradiobutton ( "stay" , true ) ; downoctave = new jradiobutton ( "- octave" , false ) ; octavelistener octlist = new octavelistener ( ) ; upoctave . addactionlistener ( octlist ) ; stayoctave . addactionlistener ( octlist ) ; downoctave . addactionlistener ( octlist ) ; buttongroup octaves = new buttongroup ( ) ; octaves . add ( upoctave ) ; octaves . add ( stayoctave ) ; octaves . add ( downoctave ) ; jpanel octavepanel = new jpanel ( ) ; octavepanel . setpreferredsize ( new dimension ( 100 , 150 ) ) ; octavepanel . setborder ( borderfactory . createetchedborder ( ) ) ; octavepanel . add ( upoctave ) ; octavepanel . add ( stayoctave ) ; octavepanel . add ( downoctave ) ; instrument1 = new jradiobutton ( "combo #1" , true ) ; instrument2 = new jradiobutton ( "combo #2" , false ) ; instrument3 = new jradiobutton ( "combo #3" , false ) ; instrumentlistener instlist = new instrumentlistener ( ) ; instrument1 . addactionlistener ( instlist ) ; instrument2 . addactionlistener ( instlist ) ; instrument3 . addactionlistener ( instlist ) ; buttongroup instruments = new buttongroup ( ) ; instruments . add ( instrument1 ) ; instruments . add ( instrument2 ) ; instruments . add ( instrument3 ) ; jpanel instpanel = new jpanel ( ) ; instpanel . setpreferredsize ( new dimension ( 100 , 150 ) ) ; instpanel . setborder ( borderfactory . createetchedborder ( ) ) ; instpanel . add ( instrument1 ) ; instpanel . add ( instrument2 ) ; instpanel . add ( instrument3 ) ; add ( tempo ) ; add ( percentage ) ; add ( tempopercent ) ; add ( bass ) ; add ( percentage2 ) ; add ( basspercent ) ; add ( octavepanel ) ; add ( instpanel ) ; add ( change ) ; setpreferredsize ( new dimension ( 325 , 250 ) ) ; }
tr	7	@ test public void randomizeddividetest ( ) { for ( int i = 1 ; i <= tests_amount * tests_enabled ; i ++ ) { biginteger a = new biginteger ( tests_multiplier * i , r ) ; biginteger b = new biginteger ( tests_multiplier * i , r ) ; unsignedbigint c = new unsignedbigint ( a . tostring ( ) ) ; unsignedbigint d = new unsignedbigint ( b . tostring ( ) ) ; biginteger biresult [ ] = a . divideandremainder ( b ) ; unsignedbigint ubiresult [ ] = c . divideandremainder ( d ) ; asserttrue ( "quotient mismatch: was " + ubiresult [ 0 ] . tostring ( ) + "<litcomma> expected " + biresult [ 0 ] . tostring ( ) , biresult [ 0 ] . tostring ( ) . equals ( ubiresult [ 0 ] . tostring ( ) ) ) ; asserttrue ( "remainder mismatch: was " + ubiresult [ 1 ] . tostring ( ) + "<litcomma> expected " + biresult [ 1 ] . tostring ( ) , biresult [ 1 ] . tostring ( ) . equals ( ubiresult [ 1 ] . tostring ( ) ) ) ; } }
tr	9	@ eventhandler public void onplayerdeathevent ( playerdeathevent event ) { player player = ( player ) event . getentity ( ) ; if ( ! player . haspermission ( "trophyheads.drop" ) ) { return ; } if ( randomgenerator . nextint ( 100 ) >= drop_chances . get ( entitytype . player . tostring ( ) ) ) { return ; } boolean dropokay = false ; damagecause dc ; if ( player . getlastdamagecause ( ) != null ) { dc = player . getlastdamagecause ( ) . getcause ( ) ; logdebug ( "damagecause: " + dc . tostring ( ) ) ; } else { logdebug ( "damagecause: null" ) ; return ; } if ( death_types . contains ( dc . tostring ( ) ) ) { dropokay = true ; } if ( death_types . contains ( "all" ) ) { dropokay = true ; } if ( player . getkiller ( ) instanceof player ) { logdebug ( "player " + player . getname ( ) + " killed by another player. checking if pvp is valid death type." ) ; if ( death_types . contains ( "pvp" ) ) { dropokay = isvaliditem ( entitytype . player , player . getkiller ( ) . getiteminhand ( ) . gettype ( ) ) ; logdebug ( "pvp is a valid death type. killer's item in hand is valid? " + dropokay ) ; } else { logdebug ( "pvp is not a valid death type." ) ; } } if ( dropokay ) { logdebug ( "match: true" ) ; location loc = player . getlocation ( ) . clone ( ) ; world world = loc . getworld ( ) ; string pname = player . getname ( ) ; itemstack item = new itemstack ( material . skull_item , 1 , ( byte ) 3 ) ; itemmeta itemmeta = item . getitemmeta ( ) ; arraylist < string > itemdesc = new arraylist < > ( ) ; itemmeta . setdisplayname ( "head of " + pname ) ; itemdesc . add ( event . getdeathmessage ( ) ) ; itemmeta . setlore ( itemdesc ) ; if ( playerskin ) { ( ( skullmeta ) itemmeta ) . setowner ( pname ) ; } item . setitemmeta ( itemmeta ) ; world . dropitemnaturally ( loc , item ) ; } else { logdebug ( "match: false" ) ; } }
tr	4	public void writeall ( java . sql . resultset rs , boolean includecolumnnames ) throws sqlexception , ioexception { resultsetmetadata metadata = rs . getmetadata ( ) ; if ( includecolumnnames ) { writecolumnnames ( metadata ) ; } int columncount = metadata . getcolumncount ( ) ; while ( rs . next ( ) ) { string [ ] nextline = new string [ columncount ] ; for ( int i = 0 ; i < columncount ; i ++ ) { nextline [ i ] = getcolumnvalue ( rs , metadata . getcolumntype ( i + 1 ) , i + 1 ) ; } writenext ( nextline ) ; } }
tr	3	public tournament ( round firstround , hashtable < string , compiledstat > compiledstats , referee scoreable ) { if ( md5 == null ) { try { md5 = messagedigest . getinstance ( "md5" ) ; } catch ( nosuchalgorithmexception e ) { e . printstacktrace ( ) ; } } this . compiledstats = compiledstats ; this . scoreable = scoreable ; round duplicate = new round ( ) ; for ( game game : firstround ) { game dupegame = new game ( game . teams , scoreable ) ; dupegame . name = game . name ; duplicate . add ( dupegame ) ; } rounds . add ( duplicate ) ; appendnextround ( duplicate ) ; }
tr	3	public boolean provjerilistu ( string ime ) { resource r ; boolean ima = false ; for ( int i = 0 ; i < c . getlista ( ) . size ( ) ; i ++ ) { r = ( resource ) c . getlista ( ) . get ( i ) ; if ( r . getnaziv ( ) . equals ( ime ) ) { r . setbrojkoristenja ( r . getbrojkoristenja ( ) + 1 ) ; r . setvrijemespremanja ( new date ( ) ) ; r . setspremljen ( true ) ; upisiudnevnik ( r ) ; ima = true ; break ; } } return ima ; }
tr	5	private void initagents ( ) { agents = new vector < agent > ( ) ; for ( int a = 0 ; a < numagents ; a ++ ) { agents . add ( new agent ( this ) ) ; } for ( int a = 0 ; a < agents . size ( ) ; a ++ ) { int x = 0 ; int y = 0 ; boolean free = false ; while ( ! free ) { x = gen . nextint ( xsize ) ; y = gen . nextint ( ysize ) ; free = ( grid [ x ] [ y ] . getagent ( ) == null ) ; } agent agent = agents . elementat ( a ) ; agent . setposition ( x , y ) ; grid [ x ] [ y ] . setagent ( agent ) ; } }
tr	3	private static void ints_array ( ) { stackofints_array intarray = new stackofints_array ( testsize ) ; for ( int i = 0 ; i < testsize ; i ++ ) { intarray . push ( i ) ; system . out . println ( "position = " + intarray . position + " ; value = " + i ) ; } system . out . println ( "-------------------------------------" ) ; for ( int i = 0 ; i < testsize ; i ++ ) { int result = intarray . pop ( ) ; system . out . println ( "position = " + intarray . position + " ; value = " + result ) ; } }
tr	6	@ test public void testcrossover ( ) { int [ ] testchromosomes1 = new int [ ] { 1 , 2 , 3 , 4 , 5 , 6 , 7 } ; int [ ] testchromosomes2 = new int [ ] { 10 , 20 , 30 , 40 , 50 , 60 , 70 } ; genom parent1 = new genomwithoutrandomness ( testchromosomes1 ) ; genom parent2 = new genom ( testchromosomes2 ) ; genom child = parent1 . crossover ( parent2 ) ; int [ ] newchromosome = new int [ ] { 1 , 2 , 3 , 4 , 50 , 60 , 70 } ; assertthat ( newchromosome , is ( child . getchromosomes ( ) ) ) ; }
tr	10	public void run ( ) throws numberformatexception , ioexception { bufferedreader br = new bufferedreader ( new filereader ( "input.txt" ) ) ; int processid = integer . parseint ( br . readline ( ) ) ; bufferedwriter bw = new bufferedwriter ( new filewriter ( "input_file_0.txt" ) ) ; int count = 0 ; while ( count < numbersnapshots ) { int prob = ( int ) ( math . random ( ) * 10 ) ; if ( prob < 9 ) { int pid = 0 ; while ( pid == 0 ) { pid = ( int ) ( math . random ( ) * processid ) ; } int cost = ( int ) ( math . random ( ) * 5 ) ; int quantity = ( int ) ( math . random ( ) * 5 ) ; bw . write ( pid + ":" + cost + "<litcomma>" + quantity + "\\n" ) ; } else { bw . write ( "snapshot\\n" ) ; count ++ ; } } bw . close ( ) ; for ( int i = 1 ; i < processid ; i ++ ) { bw = new bufferedwriter ( new filewriter ( "input_file_" + i + ".txt" ) ) ; for ( int j = 0 ; j < 10 ; j ++ ) { int pid = i ; while ( pid == i ) { pid = ( int ) ( math . random ( ) * processid ) ; } int cost = ( int ) ( math . random ( ) * 5 ) ; int quantity = ( int ) ( math . random ( ) * 5 ) ; bw . write ( pid + ":" + cost + "<litcomma>" + quantity + "\\n" ) ; } bw . close ( ) ; } br . close ( ) ; }
tr	4	public void actionperformed ( actionevent e ) { if ( e . getsource ( ) . equals ( okbutton ) ) { string directory = log_path . gettext ( ) ; string logfile = log_name . gettext ( ) ; string linenumstr = line_num . gettext ( ) ; if ( directory . equals ( "" ) ) { joptionpane . showmessagedialog ( con , "\u8bf7\u6307\u5b9a\u670d\u52a1\u5668\u76ee\u5f55" , "\u63d0\u793a" , 2 ) ; return ; } if ( logfile . equals ( "" ) ) { joptionpane . showmessagedialog ( con , "\u8bf7\u6307\u5b9a\u65e5\u5fd7\u6587\u4ef6" , "\u63d0\u793a" , 2 ) ; return ; } if ( linenumstr . equals ( "" ) || ! utils . isnumeric ( linenumstr ) ) { joptionpane . showmessagedialog ( con , "\u8bf7\u8f93\u5165\u622a\u53d6\u884c\u6570(\u6570\u5b57)" , "\u63d0\u793a" , 2 ) ; return ; } int linenum = integer . parseint ( linenumstr ) ; new thread ( new logviewthread ( directory , logfile , linenum ) ) . start ( ) ; } }
tr	9	private static < v extends comparable < v > , e extends comparable < e > > boolean isisomorphic ( vertex < v , e > v1 , vertex < v , e > v2 , set < integer > g1visited , set < integer > g2visited ) { if ( v1 == null && v2 == null ) { return true ; } else if ( ( v1 == null && v2 != null ) || ( v1 != null && v2 == null ) ) { return false ; } boolean v1visited = g1visited . contains ( v1 . getid ( ) ) ; boolean v2visited = g2visited . contains ( v2 . getid ( ) ) ; if ( v1visited && v2visited ) { return true ; } else if ( ( ! v1visited && v2visited ) || ( v1visited && ! v2visited ) ) { return false ; } else { int vertexcomparision = v1 . compareto ( v2 ) ; if ( vertexcomparision != 0 ) { return false ; } set < integer > g1visitednew = new hashset < integer > ( g1visited ) ; set < integer > g2visitednew = new hashset < integer > ( g2visited ) ; g1visitednew . add ( v1 . getid ( ) ) ; g2visitednew . add ( v2 . getid ( ) ) ; boolean isomorphic = true ; for ( edge < v , e > e1 : v1 . getedges ( ) ) { boolean edgeisomorphic = false ; for ( edge < v , e > e2 : v2 . getedges ( ) ) { if ( e1 . compareto ( e2 ) == 0 ) { edgeisomorphic = isisomorphic ( e1 . getdestination ( ) , e2 . getdestination ( ) , g1visitednew , g2visitednew ) ; if ( edgeisomorphic && e2 . getdestination ( ) != null ) { g1visitednew . add ( e2 . getdestination ( ) . getid ( ) ) ; } } } if ( ! edgeisomorphic ) { return false ; } } return isomorphic ; } }
tr	8	private void createthreads ( httpserver theserver ) { int corepoolsize = 20 ; int maximumpoolsize = 40 ; long keepalivetime = 10 ; timeunit unit = timeunit . seconds ; int workqueuecapacity = 40 ; int threadpriority = thread . norm_priority ; log . info ( "miniwebserver:createthreads - creating thread factory with a thread priority of: " + threadpriority ) ; minithymeleafwebserverthreadfactory threadfactory = new minithymeleafwebserverthreadfactory ( threadpriority ) ; log . info ( "miniwebserver:createthreads - creating thread pool executor with:" ) ; log . info ( "core pool size     : " + corepoolsize ) ; log . info ( "maximum pool size  : " + maximumpoolsize ) ; log . info ( "keep alive time    : " + keepalivetime + " seconds." ) ; log . info ( "work queue capacity: " + workqueuecapacity ) ; minithymeleafwebserverthreadpoolexecutor threadexecutor = new minithymeleafwebserverthreadpoolexecutor ( corepoolsize , maximumpoolsize , keepalivetime , unit , workqueuecapacity , threadfactory ) ; theserver . setexecutor ( threadexecutor ) ; }
tr	3	private static treemap < string , integer > locationdistribution ( user ua ) { treemap < string , integer > freq = new treemap < string , integer > ( ) ; for ( record r : ua . records ) { if ( freq . containskey ( r . gps ( ) ) ) { int tmp = freq . get ( r . gps ( ) ) ; freq . put ( r . gps ( ) , tmp + 1 ) ; } else { freq . put ( r . gps ( ) , 1 ) ; } } return freq ; }
tr	2	public boolean buildriver ( land land , int direction ) { land . isweet = true ; int x = land . x ; int z = land . z ; if ( land . height > lakelevel ) { if ( direction == 0 ) { buildriver ( world [ x - 1 ] [ z ] , direction ) ; } else if ( direction == 1 ) { buildriver ( world [ x + 1 ] [ z ] , direction ) ; } else if ( direction == 2 ) { buildriver ( world [ x ] [ z - 1 ] , direction ) ; } else { buildriver ( world [ x ] [ z + 1 ] , direction ) ; } } return true ; }
tr	5	public int jump ( int [ ] a ) { if ( a . length <= 1 ) return 0 ; int left = 1 ; int end = a [ 0 ] ; int step = 1 ; while ( end < a . length ) { int max = 0 ; int i = left ; for ( i = left ; i <= end ; i ++ ) { if ( i >= a . length - 1 ) return step ; max = math . max ( max , i + a [ i ] ) ; } step ++ ; left = i ; end = max ; } return step ; }
tr	1	public void start ( ) { try { display . setdisplaymode ( new displaymode ( 640 , 480 ) ) ; display . create ( ) ; display . settitle ( "boxio" ) ; } catch ( lwjglexception e ) { e . printstacktrace ( ) ; } initsong ( ) ; glenable ( gl_texture_2d ) ; player = new player ( ) ; enemy = new enemy ( ) ; coinlist = new arraylist < coin > ( 0 ) ; song . playasmusic ( 1.0f , 0.05f , true ) ; while ( ! display . iscloserequested ( ) ) { setcamera ( ) ; drawbackground ( ) ; player . draw ( ) ; enemy . draw ( ) ; for ( coin c : coinlist ) c . draw ( ) ; drawstring . drawstring ( "deaths " + player . deaths + "\\n" + "kills " + enemy . kills + "\\n" + "press t to teleport random" + "\\n" + "press k to kill once per round" + "\\n" + "get 10 kills to win!" , 320 , 360 ) ; end . end ( ) ; highscore . show ( ) ; display . update ( ) ; display . sync ( 60 ) ; } display . destroy ( ) ; al . destroy ( ) ; }
tr	5	private parameter [ ] decodeparams ( final jsonobject jsonobject ) throws jsonexception { final iterator < ? > keys = jsonobject . keys ( ) ; final arraylist < parameter > paramarray = new arraylist < parameter > ( ) ; while ( keys . hasnext ( ) ) { string key = ( string ) keys . next ( ) ; parameter param = decodeparam ( jsonobject . get ( key ) ) ; param . setname ( key ) ; paramarray . add ( param ) ; } final parameter [ ] params = { } ; return paramarray . toarray ( params ) ; }
tr	9	public void handledatapacket ( byte [ ] payload , datainputstream in ) throws ioexception { switch ( in . readbyte ( ) ) { case mc_pong : break ; case mc_ping : { long ptime = in . readlong ( ) ; long time = system . currenttimemillis ( ) ; sendpacket ( mc_pong , ptime , time ) ; break ; } case mc_client_connect : { if ( loggedin ) break ; long clientid = in . readlong ( ) ; long session = in . readlong ( ) ; sendpacket ( mc_server_handshake , 0x043f57f3 , ( byte ) 0xcd , ( short ) this . port , new byte [ ] { ( byte ) 0xf5 , - 1 , - 1 , ( byte ) 0xf5 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 } , session , new byte [ ] { 0x00 , 0x00 , 0x00 , 0x00 , 0x04 , 0x44 , 0x0b , ( byte ) 0xa9 } ) ; break ; } case mc_client_handshake : break ; case mc_login : { if ( loggedin ) break ; string username = utils . readstring ( in ) ; int protocol1 = in . readint ( ) ; int protocol2 = in . readint ( ) ; int clientid = in . readint ( ) ; realmsdata = new byte [ in . readshort ( ) ] ; in . read ( realmsdata ) ; if ( server . clients . size ( ) >= server . maxclients ) { close ( "server is full!" , false ) ; break ; } if ( protocol1 != protocol_version ) { sendpacket ( mc_login_status , protocol1 < protocol_version ? 1 : 2 ) ; close ( "incorrect protocol#" + protocol1 , false ) ; break ; } if ( username . matches ( "[a-za-z0-9_]+" ) && username . length ( ) > 0 ) this . username = username ; else { close ( "bad username" , false ) ; break ; } if ( server . haswhitelist && ! server . whitelist . contains ( username ) ) { close ( "server is white-listed" , false ) ; break ; } if ( server . banned . contains ( username ) || server . bannedips . contains ( ip ) ) { close ( "you are banned!" , false ) ; break ; } loggedin = true ; entityplayer p1 = server . players . get ( username ) ; if ( p1 != null ) p1 . close ( "logged in from another location" , true ) ; server . players . put ( username , this ) ; server . log ( username + " logged in from " + ip + ":" + port ) ; sendpacket ( mc_login_status , 0 ) ; } } }
tr	5	public static byte [ ] buildmessage ( byte code , int ... datas ) { byte [ ] message = new byte [ 1 + datas . length * 4 ] ; message [ 0 ] = code ; int indice = 1 ; for ( int i = 0 ; i < datas . length ; i ++ ) { byte [ ] data = toolbox . int2byte ( datas [ i ] ) ; for ( int j = 0 ; j < data . length ; j ++ ) { message [ indice ++ ] = data [ j ] ; } } return message ; }
tr	9	private final list < user > getattributes ( string searchbase ) throws namingexception { logger . info ( ">> getattributes()" ) ; namingenumeration < searchresult > results = localinitialldapcontext . search ( searchbase , searchfilter , searchctls ) ; list < user > users = new arraylist < user > ( ) ; user user = null ; while ( results . hasmoreelements ( ) ) { user = new user ( ) ; searchresult searchresult = results . next ( ) ; attributes attrs = searchresult . getattributes ( ) ; if ( attrs != null && attrs . size ( ) != 0 ) { attribute attribute = null ; string [ ] retrieveattributes = parameters . getretrieveattributes ( ) ; string [ ] attributesvalues = new string [ retrieveattributes . length ] ; for ( int i = 0 ; i < retrieveattributes . length ; i ++ ) { attribute = attrs . get ( retrieveattributes [ i ] ) ; if ( attribute != null && attribute . get ( ) != null ) { if ( ! isnullorempty ( attribute . get ( ) . tostring ( ) ) ) { attributesvalues [ i ] = attribute . get ( ) . tostring ( ) ; } } } user . setattributevalues ( attributesvalues ) ; } users . add ( user ) ; } logger . info ( "<< getattributes()" ) ; return users ; }
tr	9	public static void main ( string [ ] args ) { cachefactory . ensurecluster ( ) ; int a , b ; int b_per_a = 3 ; string str_act_id ; string str_bal_id ; namedcache nc_act = cachefactory . getcache ( "accounts" ) ; namedcache nc_bal = cachefactory . getcache ( "balances" ) ; system . out . println ( "== " + nc_act . getclass ( ) . getname ( ) + " ==" ) ; hashmap < accountid , string > map_act = new hashmap ( 100 ) ; hashmap < balanceid , balance > map_bal = new hashmap ( 100 ) ; nc_bal . addindex ( new pofextractor ( string . class , 0 ) , false , null ) ; for ( a = 1 ; a <= 100 ; a ++ ) { str_act_id = "a" + integer . tostring ( a ) ; map_act . put ( new accountid ( str_act_id ) , "account " + integer . tostring ( a ) ) ; for ( b = 1 ; b <= b_per_a ; b ++ ) { str_bal_id = "b" + integer . tostring ( a * b_per_a + b ) ; map_bal . put ( new balanceid ( str_act_id , str_bal_id ) , new balance ( str_act_id , a * b_per_a + b ) ) ; } } nc_act . putall ( map_act ) ; nc_bal . putall ( map_bal ) ; system . out . println ( "" ) ; system . out . println ( "== size of cache[accounts] is " + nc_act . size ( ) ) ; system . out . println ( "== size of cache[balances] is " + nc_bal . size ( ) ) ; }
tr	9	final public void compress ( int level ) { if ( level <= 0 ) return ; if ( good == false ) return ; if ( encoding != null ) return ; if ( ! ctype . startswith ( "text/" ) ) return ; if ( localname == null || localname . equals ( reserved ) ) return ; if ( size <= auto_compress ) return ; if ( nocompress != null ) { for ( int z = nocompress . length - 1 ; z >= 0 ; z -- ) { if ( localname . tolowercase ( ) . endswith ( nocompress [ z ] ) ) return ; } } file t = gentmp ( ) ; int i ; try { gzipoutputstream gz = new gzipoutputstream ( new fileoutputstream ( t ) , 8192 ) ; datainputstream sin = new datainputstream ( new bufferedinputstream ( new fileinputstream ( dir . getlocaldir ( ) + localname ) , 4096 ) ) ; byte b [ ] = new byte [ 4096 ] ; while ( true ) { i = sin . read ( b ) ; if ( i == - 1 ) break ; gz . write ( b , 0 , i ) ; } gz . close ( ) ; sin . close ( ) ; int sz ; sz = ( int ) t . length ( ) ; if ( sz >= size - 1024 ) { t . delete ( ) ; return ; } string nm ; if ( ! localname . endswith ( ".gz" ) ) if ( localname . endswith ( "_r" ) ) nm = genname ( localname . substring ( 0 , localname . length ( ) - 2 ) + ".gz" ) ; else nm = genname ( localname + ".gz" ) ; else nm = localname ; file n = new file ( dir . getlocaldir ( ) + nm ) ; if ( ! rename ( t , n ) ) { if ( mgr . loglevel > 0 ) system . out . println ( thread . currentthread ( ) . getname ( ) + " compress error: rename " + t + " to " + n + " failed." ) ; dir . dirty = true ; return ; } if ( ! localname . equals ( nm ) ) new file ( dir . getlocaldir ( ) + localname ) . delete ( ) ; localname = nm ; encoding = "gzip" ; date = system . currenttimemillis ( ) ; dir . dirty = true ; if ( mgr . loglevel > 3 ) system . out . println ( "compressed: " + dir . getlocaldir ( ) + localname + " (saved=" + ( size - sz ) + " b<litcomma> ratio=" + ( int ) ( 100 * ( 1.0f - ( float ) sz / size ) ) + "%)" ) ; size = sz ; } catch ( ioexception j ) { if ( mgr . loglevel > 0 ) system . out . println ( thread . currentthread ( ) . getname ( ) + " compress error: " + j ) ; } }
tr	10	public static void launch ( string f , string type , int upstream , boolean withcontig ) { system . out . println ( "reading taxonomy list.." ) ; arraylist < integer > taxlist = new arraylist < integer > ( ) ; try { bufferedreader br = new bufferedreader ( new filereader ( f ) ) ; string line = br . readline ( ) ; while ( line != null ) { if ( ! line . trim ( ) . equals ( "" ) ) { int taxa = integer . parseint ( line ) ; taxlist . add ( taxa ) ; system . out . println ( taxa ) ; } line = br . readline ( ) ; } br . close ( ) ; } catch ( ioexception e ) { system . out . println ( "io exception reading " + f ) ; e . printstacktrace ( ) ; system . exit ( 0 ) ; } system . out . println ( "loading " + type + " data.." ) ; cogloader loader = new cogloader ( type ) ; try { loader . loadmembers ( taxlist ) ; } catch ( sqlexception e ) { system . out . println ( "failed to load " + type + " data" ) ; e . printstacktrace ( ) ; system . exit ( 0 ) ; } system . out . println ( "all " + type + " number for specified taxonomies: " + loader . cogs . size ( ) ) ; system . out . println ( "scaffolds number:" + loader . scaffolds . size ( ) ) ; system . out . println ( "taxonomies number:" + loader . taxonomies . size ( ) ) ; for ( iterator < integer > iterator = loader . taxonomies . iterator ( ) ; iterator . hasnext ( ) ; ) { system . out . println ( iterator . next ( ) ) ; } int max_processors_number = 24 ; int processorsnumber = runtime . getruntime ( ) . availableprocessors ( ) ; system . out . println ( "processors number:" + processorsnumber ) ; int threadnumber = math . min ( processorsnumber , max_processors_number ) ; system . out . println ( "loading loading " + type + " fastas.." ) ; string dir = "mo_" + type ; loader . writecogs ( threadnumber , dir , type , upstream ) ; if ( withcontig ) { system . out . println ( "loading corresponding contigs.." ) ; loader . writecontigs ( threadnumber , "mo_contig" ) ; } }
tr	7	@ override public void editarpessoa ( string cpf ) { scanner s = new scanner ( system . in ) ; string nomenovo , emailnovo ; int editar ; int indexlista = 0 ; boolean verifica = false ; for ( int i = 0 ; i < listpessoas . size ( ) ; i ++ ) { if ( listpessoas . get ( i ) . getcpf ( ) . equals ( cpf ) ) { verifica = true ; indexlista = i ; } } if ( verifica ) { system . out . println ( "\\nusu\xe1rio na posi\xe7\xe3o " + indexlista + 1 ) ; system . out . println ( "\\n preparando para editar..." ) ; try { editar = integer . parseint ( joptionpane . showinputdialog ( "qual op\xe7\xe3o deseja editar?\\n1)nome \\n2)email" ) ) ; } catch ( numberformatexception io ) { system . err . println ( "tente novamente<litcomma> agora com um inteiro." ) ; editar = integer . parseint ( joptionpane . showinputdialog ( "qual op\xe7\xe3o deseja editar?\\n1)nome \\n2)email" ) ) ; } switch ( editar ) { case 1 : nomenovo = joptionpane . showinputdialog ( "entre com o nome para atualizar" ) ; listpessoas . get ( indexlista ) . setnome ( nomenovo ) ; break ; case 2 : emailnovo = joptionpane . showinputdialog ( "entre com o e-mail para atualizar" ) ; listpessoas . get ( indexlista ) . setemail ( emailnovo ) ; break ; default : joptionpane . showmessagedialog ( null , "op\xe7\xe3o inv\xe1lida" ) ; break ; } } else { system . out . println ( "\\nusu\xe1rio inexistente." ) ; } }
tr	5	public void writenext ( string [ ] nextline ) { if ( nextline == null ) return ; stringbuffer sb = new stringbuffer ( ) ; for ( int i = 0 ; i < nextline . length ; i ++ ) { if ( i != 0 ) { sb . append ( separator ) ; } string nextelement = nextline [ i ] ; if ( nextelement == null ) continue ; if ( quotechar != no_quote_character ) sb . append ( quotechar ) ; for ( int j = 0 ; j < nextelement . length ( ) ; j ++ ) { char nextchar = nextelement . charat ( j ) ; if ( escapechar != no_escape_character && nextchar == quotechar ) { sb . append ( escapechar ) . append ( nextchar ) ; } else if ( escapechar != no_escape_character && nextchar == escapechar ) { sb . append ( escapechar ) . append ( nextchar ) ; } else { sb . append ( nextchar ) ; } } if ( quotechar != no_quote_character ) sb . append ( quotechar ) ; } sb . append ( lineend ) ; pw . write ( sb . tostring ( ) ) ; }
tr	4	private list < queryitem > parse ( string [ ] tokens ) { arraylist < queryitem > items = new arraylist < queryitem > ( ) ; queryoperator nextop = queryoperator . and ; for ( string token : tokens ) { token = token . tolowercase ( ) ; if ( token . charat ( 0 ) == '{' ) { token = token . substring ( 1 , token . length ( ) - 1 ) ; items . get ( items . size ( ) - 1 ) . setatleast ( integer . parseint ( token ) ) ; } else if ( token . equals ( "and" ) ) { nextop = queryoperator . and ; } else if ( token . equals ( "or" ) ) { nextop = queryoperator . or ; } else if ( token . equals ( "not" ) ) { nextop = queryoperator . not ; } else { queryitem item = new queryitem ( token , nextop ) ; items . add ( item ) ; nextop = queryoperator . and ; } } return items ; }
tr	4	public static void drawstring ( int x , int y , string text ) { int tilesize = 16 ; for ( int i = 0 ; i < text . length ( ) ; ++ i ) { string character = "" + text . charat ( i ) ; texttile tile = alphabetmap . get ( character . touppercase ( ) ) ; if ( tile == null ) { tile = alphabetmap . get ( "?" ) ; } tile . setposition ( i * tilesize , y ) ; tile . draw ( ) ; } }
tr	8	public int getsum ( ) { int sum = 0 ; for ( integer i : values . values ( ) ) { sum += i ; } integer one = values . get ( combination . one ) ; integer two = values . get ( combination . two ) ; integer three = values . get ( combination . three ) ; integer four = values . get ( combination . four ) ; integer five = values . get ( combination . five ) ; integer six = values . get ( combination . six ) ; if ( one != null && two != null && three != null && four != null && five != null && six != null && one + two + three + four + five + six >= sum_for_bonus ) { sum += bonus_for_numbers ; } return sum ; }
tr	4	public arraylist < data > selectdata ( long user_id ) { arraylist < data > datalist = new arraylist < data > ( ) ; string query = "select * from mydata " + "where uid = ?" ; try { preparedstatement = connection . preparestatement ( query ) ; preparedstatement . setlong ( 1 , user_id ) ; resultset rs = preparedstatement . executequery ( ) ; while ( rs . next ( ) ) { data data = new data ( ) ; data . setid ( rs . getint ( "id" ) ) ; data . settime ( rs . gettimestamp ( "thetime" ) ) ; data . setbg ( rs . getint ( "bg" ) ) ; data . setinsulin ( rs . getint ( "insulin" ) ) ; data . setuserid ( user_id ) ; system . out . println ( "time " + data . gettime ( ) + " bg " + data . getbg ( ) ) ; datalist . add ( data ) ; } rs . close ( ) ; } catch ( sqlexception ex ) { ex . printstacktrace ( ) ; } return datalist ; }
tr	7	public vector < site > findfreesites ( ) { vector < site > freesites = new vector < site > ( ) ; for ( int m = - vision ; m <= vision ; m ++ ) { for ( int n = - vision ; n <= vision ; n ++ ) { site site ; int x = xposition + m ; int y = yposition + n ; if ( x >= 0 && x < sim . xsize && y >= 0 && y < sim . ysize ) { site = sim . grid [ x ] [ y ] ; agent occ = site . getagent ( ) ; if ( occ == null || this . equals ( occ ) ) { freesites . addelement ( site ) ; } } } } collections . shuffle ( freesites ) ; return freesites ; }
tr	3	public boolean isvalid ( string s ) { stack < character > a = new stack < character > ( ) ; for ( char x : s . tochararray ( ) ) { if ( x == '[' || x == '(' || x == '{' ) { a . push ( x ) ; } else { if ( a . empty ( ) ) return false ; char y = ( character ) a . pop ( ) ; if ( ( x == ']' && y == '[' ) || ( x == '}' && y == '{' ) || ( x == ')' && y == '(' ) ) { } else { return false ; } } } if ( ! a . empty ( ) ) return false ; return true ; }
tr	10	public void getinput ( ) { scanner scanner = new scanner ( system . in ) ; int testcase = 0 , noofformers = 0 ; double farmyardsize = 0 , noofanimals = 0 , envdegree = 0 , calcvalue = 0 , totalvalfortestcase = 0 ; while ( scanner . hasnextint ( ) ) { testcase = scanner . nextint ( ) ; for ( int i = 0 ; i < testcase ; i ++ ) { noofformers = scanner . nextint ( ) ; for ( int j = 0 ; j < noofformers ; j ++ ) { farmyardsize = scanner . nextint ( ) ; noofanimals = scanner . nextint ( ) ; envdegree = scanner . nextint ( ) ; calcvalue = ( ( ( farmyardsize / noofanimals ) * envdegree ) * noofanimals ) ; totalvalfortestcase += calcvalue ; } math . round ( totalvalfortestcase ) ; system . out . println ( ( int ) totalvalfortestcase ) ; totalvalfortestcase = 0 ; } } return ; }
tr	6	public static hashtable < string , compiledstat > compilestats ( vector < stat > stats , collection < team > teams ) { vector < team > teamvector = new vector < team > ( teams ) ; hashtable < string , compiledstat > compiledstats = new hashtable < string , compiledstat > ( ) ; for ( stat stat : stats ) { double [ ] values = new double [ teams . size ( ) ] ; for ( int i = 0 ; i < teams . size ( ) ; i ++ ) { team team = teamvector . get ( i ) ; values [ i ] = team . getstat ( stat . name ) ; } compiledstats . put ( stat . name , new compiledstat ( stat . name , values ) ) ; } return compiledstats ; }
tr	9	public static void main ( string [ ] args ) throws filenotfoundexception { data d = reader . getdatafromfile ( new file ( "files/restaurant2.arff" ) ) ; int size = d . getattributes ( ) . size ( ) ; random r = new random ( ) ; for ( int i = 0 ; i < 100 ; i ++ ) { arraylist < string > row = new arraylist < string > ( ) ; for ( int j = 0 ; j < size ; j ++ ) { string [ ] options = d . getattributevalues ( ) . get ( d . getattributes ( ) . get ( j ) ) ; int index = r . nextint ( options . length ) ; row . add ( "'" + options [ index ] + "'" ) ; } string output = row . tostring ( ) ; system . out . println ( output . substring ( 1 , output . length ( ) - 1 ) ) ; } }
tr	1	public static void frequency ( double frequency , double min , double max ) throws illegalargumentexception { if ( frequency < min || frequency > max ) { stringbuilder e = new stringbuilder ( 80 ) ; e . append ( "invalid frequency value! " ) ; e . append ( "it must be a positive double between " ) ; e . append ( string . format ( locale . english , "%1.2f" , min ) ) ; e . append ( " and " ) ; e . append ( string . format ( locale . english , "%1.2f" , max ) ) ; e . append ( "." ) ; throw new illegalargumentexception ( e . tostring ( ) ) ; } }
tr	6	public void addpanel ( ) { jtextfield readfield = new jtextfield ( 5 ) ; jtextfield writefield = new jtextfield ( 5 ) ; jcombobox res = new jcombobox ( resolutions ) ; jcombobox thr = new jcombobox ( threads ) ; jpanel mypanel = new jpanel ( ) ; mypanel . setlayout ( new gridlayout ( 5 , 2 ) ) ; mypanel . add ( new jlabel ( "folder do odczytu:" ) ) ; mypanel . add ( readfield ) ; mypanel . add ( new jlabel ( "folder do zapisu:" ) ) ; mypanel . add ( writefield ) ; mypanel . add ( new jlabel ( "wybierz rozdzielczo\u015b\u0107:" ) ) ; mypanel . add ( res ) ; mypanel . add ( new jlabel ( "wybierz ilo\u015b\u0107 w\u0105tk\xf3w:" ) ) ; mypanel . add ( thr ) ; int result = joptionpane . showconfirmdialog ( null , mypanel , "wpisz wymagane dane" , joptionpane . ok_cancel_option ) ; if ( result == joptionpane . ok_option ) { this . readpath = readfield . gettext ( ) ; this . writepath = writefield . gettext ( ) ; this . resolution = ( string ) res . getselecteditem ( ) ; this . threadsnum = integer . parseint ( string . valueof ( thr . getselecteditem ( ) ) ) ; system . out . println ( "read: " + readfield . gettext ( ) ) ; system . out . println ( "write: " + writefield . gettext ( ) ) ; system . out . println ( "resolution: " + res . getselecteditem ( ) ) ; system . out . println ( "threads: " + thr . getselecteditem ( ) ) ; } }
tr	2	public mainpanel ( simulation controller ) { this . scape = controller ; xsize = scape . xsize ; ysize = scape . ysize ; setlayout ( new gridlayout ( xsize , ysize ) ) ; addmouselistener ( this ) ; labels = new jlabel [ xsize ] [ ysize ] ; for ( int y = 0 ; y < ysize ; y ++ ) { for ( int x = 0 ; x < xsize ; x ++ ) { labels [ x ] [ y ] = new jlabel ( "" ) ; labels [ x ] [ y ] . setopaque ( true ) ; labels [ x ] [ y ] . setborder ( borderfactory . createlineborder ( color . black ) ) ; labels [ x ] [ y ] . sethorizontalalignment ( swingconstants . center ) ; labels [ x ] [ y ] . setverticalalignment ( swingconstants . center ) ; add ( labels [ x ] [ y ] ) ; } } update ( ) ; }
tr	5	@ override public void actionperformed ( actionevent e ) { if ( e . getsource ( ) == this . morningafternooncomparebtn ) { try { status . settext ( "    - processing  " ) ; final threadinterceptor ti = new threadinterceptor ( ) ; thread th = new thread ( new runnable ( ) { @ override public void run ( ) { for ( int i = 0 ; i < 30 ; i ++ ) { if ( ti . isinterupt ( ) ) { break ; } status . settext ( status . gettext ( ) + "->" ) ; try { thread . sleep ( 50 ) ; } catch ( interruptedexception e ) { e . printstacktrace ( ) ; } } } } ) ; th . start ( ) ; excelservice excelservice = new excelserviceimpl ( contants . sangchieu_xlsx ) ; morningafternoonstrategycompareservice service = new morningafternoonstrategycompareservice ( excelservice ) ; service . comparemorningafternoon ( ) ; ti . setinterupt ( true ) ; status . settext ( status . gettext ( ) + " done !!!" ) ; thread . sleep ( 200 ) ; status . settext ( "    - opening ." ) ; thread . sleep ( 200 ) ; status . settext ( status . gettext ( ) + "." ) ; thread . sleep ( 200 ) ; status . settext ( status . gettext ( ) + ".." ) ; thread . sleep ( 400 ) ; desktop . getdesktop ( ) . open ( new file ( contants . sangchieu_xlsx ) ) ; status . settext ( "    * caramen +1" ) ; } catch ( exception ex ) { status . settext ( ex . getmessage ( ) ) ; } } else if ( e . getsource ( ) == this . checkduplicateblightbtn ) { try { status . settext ( "    - processing  " ) ; final threadinterceptor ti = new threadinterceptor ( ) ; thread th = new thread ( new runnable ( ) { @ override public void run ( ) { for ( int i = 0 ; i < 30 ; i ++ ) { if ( ti . isinterupt ( ) ) { break ; } status . settext ( status . gettext ( ) + "->" ) ; try { thread . sleep ( 50 ) ; } catch ( interruptedexception e ) { e . printstacktrace ( ) ; } } } } ) ; th . start ( ) ; excelservice excelservice = new excelserviceimpl ( contants . check_duplicate_xlsx , 0 ) ; duplicatestrategycheckservice service = new duplicatestrategycheckserviceimpl ( excelservice ) ; service . checkduplicate ( ) ; ti . setinterupt ( true ) ; status . settext ( status . gettext ( ) + " done !!!" ) ; thread . sleep ( 200 ) ; status . settext ( "    - opening ." ) ; thread . sleep ( 200 ) ; status . settext ( status . gettext ( ) + "." ) ; thread . sleep ( 200 ) ; status . settext ( status . gettext ( ) + ".." ) ; thread . sleep ( 400 ) ; desktop . getdesktop ( ) . open ( new file ( contants . symbols_xlsx ) ) ; status . settext ( "caramen +1" ) ; } catch ( exception ex ) { status . settext ( ex . getmessage ( ) ) ; } } else if ( e . getsource ( ) == this . checkduplicatevtradebtn ) { try { status . settext ( "    - processing  " ) ; final threadinterceptor ti = new threadinterceptor ( ) ; thread th = new thread ( new runnable ( ) { @ override public void run ( ) { for ( int i = 0 ; i < 30 ; i ++ ) { if ( ti . isinterupt ( ) ) { break ; } status . settext ( status . gettext ( ) + "->" ) ; try { thread . sleep ( 50 ) ; } catch ( interruptedexception e ) { e . printstacktrace ( ) ; } } } } ) ; th . start ( ) ; excelservice excelservice = new excelserviceimpl ( contants . check_duplicate_xlsx , 1 ) ; duplicatestrategycheckservice service = new duplicatestrategycheckserviceimpl ( excelservice ) ; service . checkduplicate ( ) ; ti . setinterupt ( true ) ; status . settext ( status . gettext ( ) + " done !!!" ) ; thread . sleep ( 200 ) ; status . settext ( "    - opening ." ) ; thread . sleep ( 200 ) ; status . settext ( status . gettext ( ) + "." ) ; thread . sleep ( 200 ) ; status . settext ( status . gettext ( ) + ".." ) ; thread . sleep ( 400 ) ; desktop . getdesktop ( ) . open ( new file ( contants . symbols_xlsx ) ) ; status . settext ( "caramen +1" ) ; } catch ( exception ex ) { status . settext ( ex . getmessage ( ) ) ; } } }
tr	6	static string [ ] getoperands ( ) { scanner scanner = new scanner ( system . in ) ; int size ; system . out . println ( "enter the number of elements!" ) ; size = scanner . nextint ( ) ; if ( 0 >= size ) { throw new runtimeexception ( "invalid size: " + size ) ; } int index = 0 ; string operands [ ] = new string [ size ] ; while ( index < size ) { string operand = scanner . next ( ) ; if ( operand . length ( ) != 1 ) { throw new runtimeexception ( "operand should be a single digit!" ) ; } for ( character ch : operand . tochararray ( ) ) { if ( ! character . isdigit ( ch ) ) { throw new runtimeexception ( "illegal code point: " + ch ) ; } } operands [ index ++ ] = operand ; } return operands ; }
tr	3	@ test public void test ( ) throws exception { url pdmlurl = rtpextractertest . class . getresource ( "sipcall.pdml" ) ; assert . assertnotnull ( pdmlurl ) ; file [ ] wavefiles = new file [ 2 ] ; for ( int i = 0 ; i < wavefiles . length ; ++ i ) wavefiles [ i ] = file . createtempfile ( opustowaveconvertertest . class . getsimplename ( ) , ".wav" ) ; try { new opustowaveconverter ( ) . convert ( pdmlurl , wavefiles , samplerate . rate_8khz , channels . mono ) ; new opustowaveconverter ( ) . convert ( pdmlurl , wavefiles , null , null ) ; } finally { for ( int i = 0 ; i < wavefiles . length ; ++ i ) wavefiles [ i ] . delete ( ) ; } }
tr	7	string inthunt ( string analyzeme , string [ ] dlim ) { boolean intcheck = true ; boolean errorcheck = false ; for ( int r = 0 ; r < analyzeme . length ( ) ; r ++ ) { for ( string adlim : dlim ) { string wall = string . valueof ( analyzeme . charat ( r ) ) ; char egg = analyzeme . charat ( r ) ; if ( ! wall . equals ( adlim ) && ! character . isletterordigit ( egg ) ) { errorcheck = true ; } if ( ! character . isdigit ( analyzeme . charat ( r ) ) ) { intcheck = false ; } } } if ( errorcheck ) { analyzeme = checkfloat ( analyzeme ) ; } if ( intcheck && ! analyzeme . equals ( "" ) ) { imatoken token = new imatoken ( "int" , analyzeme , depth , linenum ) ; stacker . add ( token ) ; analyzeme = "" ; } return analyzeme ; }
tr	1	@ override public boolean oncommand ( commandsender sender , command cmd , string commandlabel , string [ ] args ) { if ( cmd . getname ( ) . equalsignorecase ( "censornizer" ) ) { if ( args . length >= 2 ) { sender . sendmessage ( "\xa7cusage: \xa7a/censornizer <unmute player|reload>" ) ; return true ; } if ( args [ 0 ] . equalsignorecase ( "unmute" ) ) { player target = main . getserver ( ) . getplayer ( args [ 1 ] ) ; try { if ( sender . haspermission ( "censornizer.unmute" ) ) { if ( ! main . map . containskey ( target . getname ( ) ) ) { sender . sendmessage ( "\xa74the player " + chatcolor . green + target . getdisplayname ( ) + chatcolor . dark_red + " is not muted!" ) ; return true ; } else { sender . sendmessage ( "\xa7athe player " + chatcolor . gold + target . getdisplayname ( ) + chatcolor . green + " is now unmuted!" ) ; main . map . remove ( target . getname ( ) ) ; return true ; } } else { sender . sendmessage ( "\xa74you dont have permission!" ) ; return true ; } } catch ( nullpointerexception e ) { sender . sendmessage ( "\xa74the player " + args [ 0 ] + "is not online!" ) ; return true ; } } else if ( args [ 0 ] . equalsignorecase ( "reload" ) ) { if ( sender . haspermission ( "censornizer.reload" ) ) { try { main . files . reload ( ) ; sender . sendmessage ( "\xa7asuccessfully reloaded!" ) ; return true ; } catch ( filenotfoundexception ex ) { sender . sendmessage ( "\xa7cerror on reload." ) ; ex . printstacktrace ( ) ; return true ; } } else { sender . sendmessage ( "\xa74you dont have permission!" ) ; return true ; } } else { sender . sendmessage ( "\xa7cusage: \xa7a/censornizer <unmute player|reload>" ) ; return true ; } } return false ; }
tr	2	public static long timeparallel ( final int numthreads , final block block ) { final long [ ] times = new long [ 2 ] ; final cyclicbarrier barrier = new cyclicbarrier ( numthreads , new runnable ( ) { public void run ( ) { times [ 0 ] = times [ 1 ] ; times [ 1 ] = system . currenttimemillis ( ) ; } } ) ; parallel ( numthreads , new block ( ) { public void call ( final int index ) { try { barrier . await ( ) ; } catch ( final exception xx ) { throw new runtimeexception ( "unexpected" , xx ) ; } try { block . call ( index ) ; } finally { try { barrier . await ( ) ; } catch ( final exception xx ) { throw new runtimeexception ( "unexpected" , xx ) ; } } } } ) ; return times [ 1 ] - times [ 0 ] ; }
tr	3	public void userdistribution ( ) { try { bufferedwriter fout = new bufferedwriter ( new filewriter ( "res/checkinsn-dist.txt" ) ) ; for ( int uid : users . keyset ( ) ) fout . write ( integer . tostring ( users . get ( uid ) . size ( ) ) + "\\n" ) ; fout . close ( ) ; fout = new bufferedwriter ( new filewriter ( "res/friendsn-dist" ) ) ; for ( int uid : users . keyset ( ) ) { int cnt = 0 ; if ( friendship . containskey ( uid ) ) cnt = friendship . get ( uid ) . size ( ) ; fout . write ( integer . tostring ( cnt ) + "\\n" ) ; } fout . close ( ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } }
tr	6	private void initialize ( ) { frame = new jframe ( ) ; frame . setbounds ( 100 , 100 , 450 , 300 ) ; dimension framesize = frame . getsize ( ) ; dimension screensize = toolkit . getdefaulttoolkit ( ) . getscreensize ( ) ; frame . setlocation ( ( screensize . width - framesize . width ) / 2 , ( screensize . height - framesize . height ) / 2 ) ; jpanel panel = new jpanel ( ) ; frame . getcontentpane ( ) . add ( panel , borderlayout . center ) ; jlabel lbllogo = new jlabel ( "" ) ; lbllogo . seticon ( new imageicon ( "/users/oming/desktop/ebms_logo.png" ) ) ; panel . add ( lbllogo ) ; jpanel panel_1 = new jpanel ( ) ; frame . getcontentpane ( ) . add ( panel_1 , borderlayout . south ) ; jlabel lblabout = new jlabel ( "<html>\\n<pre>e.b.m.s \uc2dc\uc2a4\ud15c\uc785\ub2c8\ub2e4.<br>\\n&copy ebms. all right reserved.\\n</pre>\\n</html>" ) ; panel_1 . add ( lblabout ) ; }
tr	4	public static packet construct ( datagrampacket packet ) { byte [ ] data = packet . getdata ( ) ; if ( data . length == 0 ) { server . warning ( "empty packet from " + packet . getaddress ( ) + ":" + packet . getport ( ) ) ; return null ; } class < ? extends packet > clazz = classes [ ( ( int ) data [ 0 ] ) & 0xff ] ; if ( clazz == null ) { server . warning ( string . format ( "invalid packet id 0x%02x from %s:%d" , ( ( int ) data [ 0 ] ) & 0xff , packet . getaddress ( ) , packet . getport ( ) ) ) ; return null ; } try { constructor < ? extends packet > constructor = clazz . getconstructor ( inetaddress . class , int . class , byte [ ] . class ) ; packet p = constructor . newinstance ( packet . getaddress ( ) , packet . getport ( ) , data ) ; if ( ! ( p instanceof packetpayload || p instanceof packetack ) ) server . debug ( "recieved " + p ) ; return p ; } catch ( exception e ) { e . printstacktrace ( ) ; return null ; } }
tr	9	public void parsefile ( string file ) { try { jdomdoc = usedomparser ( file ) ; element root = jdomdoc . getrootelement ( ) ; element cardlistelement = root . getchild ( "cards" ) ; system . out . println ( "found " + cardlistelement . getchildren ( ) . size ( ) + " card elements" ) ; list < card > cardlist = new arraylist < card > ( ) ; int count = 0 ; for ( element cardelement : cardlistelement . getchildren ( ) ) { card card = new card ( ) ; card . setid ( integer . parseint ( cardelement . getchildtext ( "id" ) ) ) ; card . setname ( cardelement . getchildtext ( "name" ) ) ; card . setcost ( cardelement . getchildtext ( "cost" ) ) ; card . setcolor ( cardelement . getchildtext ( "color" ) ) ; card . settype ( cardelement . getchildtext ( "type" ) ) ; card . setrarity ( cardelement . getchildtext ( "rarity" ) ) ; if ( cardelement . getchild ( "power" ) != null && cardelement . getchildtext ( "power" ) . length ( ) > 0 ) { try { card . setpower ( cardelement . getchildtext ( "power" ) ) ; } catch ( exception e ) { } } if ( cardelement . getchild ( "toughness" ) != null && cardelement . getchildtext ( "toughness" ) . length ( ) > 0 ) { try { card . settoughness ( cardelement . getchildtext ( "toughness" ) ) ; } catch ( exception e ) { } } card . setrules ( cardelement . getchildtext ( "rules" ) ) ; card . setprintedname ( cardelement . getchildtext ( "printedname" ) ) ; card . setprintedtype ( cardelement . getchildtext ( "printedtype" ) ) ; card . setflavor ( cardelement . getchildtext ( "flavor" ) ) ; card . setwatermark ( cardelement . getchildtext ( "watermark" ) ) ; if ( cardelement . getchild ( "cardnum" ) != null && cardelement . getchildtext ( "cardnum" ) . length ( ) > 0 ) { try { card . setcardnum ( integer . parseint ( cardelement . getchildtext ( "cardnum" ) ) ) ; } catch ( exception e ) { } } card . setartist ( cardelement . getchildtext ( "artist" ) ) ; card . setsets ( cardelement . getchildtext ( "sets" ) ) ; card . setrulings ( cardelement . getchildtext ( "rulings" ) ) ; system . out . println ( "card: " + card . tostring ( ) ) ; map < string , string > cardinfo = card . getinfo ( ) ; dbobject query = new basicdbobject ( ) ; query . put ( "name" , card . getname ( ) ) ; dbobject cardobject = new basicdbobject ( ) ; cardobject . putall ( cardinfo ) ; cardcollection . update ( query , cardobject , true , false ) ; system . out . println ( "rules: " + cardobject . get ( "rules" ) ) ; count ++ ; system . out . println ( "processed card " + card . getname ( ) + " " + count + " out of " + cardlistelement . getchildren ( ) . size ( ) ) ; } } catch ( exception e ) { e . printstacktrace ( ) ; } }
tr	10	public static void grabphoto ( int pagenumber ) throws ioexception { string pageurl = const . woxihuanpageurl + pagenumber ; string pagecontent = netutil . getpagesource ( pageurl ) ; string body = ( string ) ( ( map ) jsonutil . getmap4json ( pagecontent ) ) . get ( "body" ) ; pattern photopattern = pattern . compile ( regexutil . woxihuanphotoregex ) ; pattern contentpattern = pattern . compile ( regexutil . woxihuantitleregex ) ; matcher photomatch = photopattern . matcher ( body ) ; matcher contentmatch = contentpattern . matcher ( body ) ; int counter = 1 ; while ( photomatch . find ( ) ) { string imgurl = photomatch . group ( 1 ) ; string msg = "" ; if ( contentmatch . find ( ) ) { msg = contentmatch . group ( 1 ) ; } imgurl = imgurl . replace ( "196_" , "680_" ) ; system . out . println ( "\u7b2c" + counter + "\u5f20\uff1a" + msg ) ; system . out . println ( imgurl ) ; counter ++ ; } }
tr	8	public static string draw ( sadari sadari ) { int height = sadari . getheight ( ) ; int linecount = sadari . getlinecount ( ) ; treemap < point , sadaribridge > bridges = sadari . getbridges ( ) ; stringbuilder sb = new stringbuilder ( ) ; for ( int y = 0 ; y < height + 1 ; y ++ ) { stringbuilder line = new stringbuilder ( ) ; for ( int linenumber = 0 ; linenumber < linecount ; linenumber ++ ) { line . append ( "|" ) ; boolean hasbridge = hastorightbridge ( new point ( linenumber , y ) , bridges ) ; if ( hasbridge ) { line . append ( "--------" ) ; } else { line . append ( "        " ) ; } } sb . append ( line . tostring ( ) . trim ( ) ) ; sb . append ( "\\n" ) ; } return sb . tostring ( ) ; }
tr	3	public static void comparelabels ( string label , string predictedlabel ) { if ( ! labelcounts . containskey ( label ) ) { labelcounts . put ( label , 1 ) ; } else if ( labelcounts . containskey ( label ) ) { int labelcount = labelcounts . get ( label ) + 1 ; labelcounts . put ( label , labelcount ) ; } if ( ! predictedlabelcounts . containskey ( predictedlabel ) ) { predictedlabelcounts . put ( predictedlabel , 1 ) ; } else if ( predictedlabelcounts . containskey ( predictedlabel ) ) { int predictedlabelcount = predictedlabelcounts . get ( predictedlabel ) + 1 ; predictedlabelcounts . put ( predictedlabel , predictedlabelcount ) ; } if ( label . equals ( predictedlabel ) ) { if ( ! correctlabelcounts . containskey ( label ) ) { correctlabelcounts . put ( label , 1 ) ; } else if ( correctlabelcounts . containskey ( label ) ) { int correctlabelcount = correctlabelcounts . get ( label ) + 1 ; correctlabelcounts . put ( label , correctlabelcount ) ; } } }
tr	3	public string getthememessage ( int frequentngramcount ) { if ( frequencytable == null ) { updatefrequencies ( ) ; } stringbuilder builder = new stringbuilder ( ) ; if ( frequentngramcount > frequencytable . size ( ) ) { frequentngramcount = frequencytable . size ( ) ; } for ( int i = 1 ; i < frequentngramcount + 1 ; i ++ ) { integer ngramid = frequencytable . getpair ( frequencytable . size ( ) - i ) . second ; builder . append ( dictionary . getinstance ( ) . getngrambyid ( ngramid ) . getbase ( ) ) . append ( " " ) ; } return builder . tostring ( ) ; }
tr	7	public static void grabphoto ( int pagenumber ) throws ioexception { string pageurl = const . s91meitupageurl + pagenumber + "0" ; string useragent = "mozilla/5.0 (windows nt 6.1; wow64) applewebkit/537.10 (khtml<litcomma> like gecko) chrome/23.0.1262.0 safari/537.10" ; string pagecontent = netutil . getpagesourcebyhttpclient ( pageurl , "www.91meitu.net" , "http://www.91meitu.net/" , useragent ) ; pattern pattern = pattern . compile ( regexutil . s91meituregex ) ; matcher matcher = pattern . matcher ( pagecontent ) ; int counter = 1 ; while ( matcher . find ( ) ) { string imgurl = matcher . group ( 1 ) ; imgurl = imgurl . replace ( "filename\\":\\"" , "http://meitu91.b0.upaiyun.com/" ) ; system . out . println ( "\u7b2c" + counter + "\u5f20\uff1a" ) ; system . out . println ( imgurl ) ; counter ++ ; } }
tr	5	protected byte [ ] readfile ( final string datafile ) throws ioexception , missingresourceexception { bufferedinputstream is ; try { is = ( bufferedinputstream ) accesscontroller . doprivileged ( new privilegedexceptionaction ( ) { public object run ( ) throws exception { return new bufferedinputstream ( getclass ( ) . getresourceasstream ( "/sun/text/resources/" + datafile ) ) ; } } ) ; } catch ( privilegedactionexception e ) { throw new internalerror ( e . tostring ( ) ) ; } int offset = 0 ; int len = label_length + 5 ; byte [ ] buf = new byte [ len ] ; if ( is . read ( buf ) != len ) { throw new missingresourceexception ( "wrong header length" , datafile , "" ) ; } for ( int i = 0 ; i < label_length ; i ++ , offset ++ ) { if ( buf [ offset ] != label [ offset ] ) { throw new missingresourceexception ( "wrong magic number" , datafile , "" ) ; } } if ( buf [ offset ] != supportedversion ) { throw new missingresourceexception ( "unsupported version(" + buf [ offset ] + ")" , datafile , "" ) ; } len = ourbreakiterator . getint ( buf , ++ offset ) ; buf = new byte [ len ] ; if ( is . read ( buf ) != len ) { throw new missingresourceexception ( "wrong data length" , datafile , "" ) ; } is . close ( ) ; return buf ; }
tr	4	public static void main ( string [ ] args ) { scanner input = new scanner ( system . in ) ; gamestate cont = null ; int choice ; do { system . out . println ( "menu:" ) ; system . out . println ( "--------------------" ) ; system . out . println ( "1) about" ) ; system . out . println ( "2) intructions" ) ; system . out . println ( "3) play game" ) ; system . out . println ( "4) exit" ) ; system . out . println ( "--------------------" ) ; choice = input . nextint ( ) ; switch ( choice ) { case 1 : about ( ) ; break ; case 2 : instructions ( ) ; break ; case 3 : gameworld newgame = new gameworld ( ) ; cont = newgame . getstate ( ) ; break ; case 4 : break ; default : system . out . println ( "please enter a valid input" ) ; choice = 0 ; } } while ( choice >= 0 && choice < 4 || cont != null ) ; }
tr	5	public static ttree gettreefromconsole ( ) { ttree tree = new ttree ( ) ; system . out . println ( "please input connections in this tree in the following format:\\n" + ": title-numericalweight-title2 or a-2-b\\ndo not add any spaces or numbers (other than the weight)." + "\\ntype 'stop' when you are finished entering connections" ) ; scanner scan = new scanner ( system . in ) ; string input = "" ; while ( ! input . equalsignorecase ( "stop" ) ) { input = scan . nextline ( ) ; list < tconnection > connect = connectioninput . getconnectionfromstring ( input ) ; for ( tconnection c : connect ) { tree . addnode ( c . gettnodeone ( ) ) ; } } return tree ; }
tr	9	@ before public void before ( ) { unmatchedbagids = collections . newsetfrommap ( new concurrenthashmap < string , boolean > ( ) ) ; bagvolts = new concurrenthashmap < string , string > ( ) ; runningtotals = new concurrenthashmap < denominationtype , integer > ( ) ; voltservice voltservice = new sleepingvoltservice ( ) ; cashcounteroutputlistener outputlistener = new mockcashcounteroutputlistener ( ) ; cashcounterrepository repository = new inmemorycashcounterrepository ( ) ; eventhandler < inputevent > bagtotalhandler = new bagtotaleventhandler ( repository , outputlistener ) ; eventhandler < inputevent > bagvolthandler = new bagvolteventhandler ( repository , voltservice , outputlistener ) ; runnable unmatchedbagworker = new unmatchedbagworker ( max_unmatched_millis , repository , outputlistener ) ; scheduledexecutorservice executor = executors . newscheduledthreadpool ( 10 ) ; disruptor < inputevent > disruptor = new disruptor < inputevent > ( inputevent . event_factory , ring_size , executor ) ; disruptor . handleeventswith ( bagtotalhandler ) . then ( bagvolthandler ) ; executor . scheduleatfixedrate ( unmatchedbagworker , 0 , max_unmatched_millis , timeunit . milliseconds ) ; ringbuffer < inputevent > ringbuffer = disruptor . start ( ) ; inputlistener = new disruptorcashcounterinputlistener ( ringbuffer , repository ) ; }
tr	10	public void write ( string outputfilename ) { document doc = null ; try { documentbuilder builder = documentbuilderfactory . newinstance ( ) . newdocumentbuilder ( ) ; doc = builder . newdocument ( ) ; } catch ( parserconfigurationexception e ) { e . printstacktrace ( ) ; } element matchelement = doc . createelement ( "match" ) ; doc . appendchild ( matchelement ) ; collection < player > playerscollection = match . getplayers ( ) ; list < player > players = new arraylist < player > ( playerscollection ) ; collections . sort ( players , new comparator < player > ( ) { @ override public int compare ( player o1 , player o2 ) { return o1 . getteam ( ) - o2 . getteam ( ) ; } } ) ; for ( player p : players ) { matchelement . appendchild ( makeplayerelement ( p , doc ) ) ; } transformer tf = null ; try { tf = transformerfactory . newinstance ( ) . newtransformer ( ) ; } catch ( transformerconfigurationexception e ) { e . printstacktrace ( ) ; } tf . setoutputproperty ( outputkeys . encoding , "utf-8" ) ; tf . setoutputproperty ( outputkeys . indent , "yes" ) ; writer out = new stringwriter ( ) ; try { tf . transform ( new domsource ( doc ) , new streamresult ( out ) ) ; } catch ( transformerexception e ) { e . printstacktrace ( ) ; } try { outputstreamwriter osw = new outputstreamwriter ( new fileoutputstream ( new file ( outputfilename ) ) ) ; osw . write ( "register_match_data('" ) ; string data = out . tostring ( ) ; data . replaceall ( "'" , "\\'" ) ; data . replace ( '\\n' , '\\\\' ) ; osw . write ( data ) ; osw . write ( "');" ) ; osw . close ( ) ; } catch ( filenotfoundexception e ) { e . printstacktrace ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } }
tr	5	@ override public list < edge > generatemst ( graph graph ) { list < integer > nodesinmst = new arraylist < integer > ( ) ; int startmstat = graph . selectarandomnode ( ) ; nodesinmst . add ( startmstat ) ; edge [ ] feeleredges = new edge [ graph . getnumvertices ( ) ] ; for ( int i = 0 ; i < feeleredges . length ; i ++ ) { feeleredges [ i ] = new edge ( 0 , 0 , integer . max_value , false ) ; } feeleredges [ startmstat ] = new edge ( startmstat , startmstat , 0 , true ) ; list < edge > finalmstedges = new arraylist < edge > ( ) ; buildmstnodebynode ( graph , startmstat , nodesinmst , finalmstedges , feeleredges ) ; return finalmstedges ; }
tr	8	public static void main ( string [ ] args ) throws ioexception { try ( bufferedreader rd = new bufferedreader ( new inputstreamreader ( system . in ) ) ; ) { string file1 = rd . readline ( ) ; string file2 = rd . readline ( ) ; string file3 = rd . readline ( ) ; fileinputstream file1input = new fileinputstream ( file1 ) ; fileoutputstream file2output = new fileoutputstream ( file2 ) ; fileoutputstream file3output = new fileoutputstream ( file3 ) ; byte [ ] bufferfile2 = new byte [ file1input . available ( ) / 2 + file1input . available ( ) % 2 ] ; byte [ ] bufferfile3 = new byte [ file1input . available ( ) / 2 ] ; file2output . write ( bufferfile2 , 0 , file1input . read ( bufferfile2 ) ) ; file3output . write ( bufferfile3 , 0 , file1input . read ( bufferfile3 ) ) ; } }
tr	2	public static arraylist < integer > createnewalreadyseen ( arraylist < integer > alreadyseenold ) { arraylist < integer > alreadyseennew = new arraylist < > ( ) ; for ( int i = 0 ; i < alreadyseenold . size ( ) ; i ++ ) alreadyseennew . add ( alreadyseenold . get ( i ) ) ; for ( int i = 0 ; i < mainclass . connectedto . size ( ) ; i ++ ) { if ( ! alreadyseenold . contains ( mainclass . connectedto . get ( i ) . hostname ) ) alreadyseennew . add ( mainclass . connectedto . get ( i ) . hostname ) ; } return alreadyseennew ; }
tr	4	public void run ( ) { try { in = new bufferedreader ( new inputstreamreader ( socket . getinputstream ( ) ) ) ; out = new printwriter ( socket . getoutputstream ( ) ) ; login = in . readline ( ) ; password = in . readline ( ) ; dbconnect dbc = new dbconnect ( ) ; state = dbc . connect ( ) ; resultset result = state . executequery ( "select login from users where login = '" + login + "' and password= '" + password + "'" ) ; if ( ! result . next ( ) ) { idcheck = 0 ; out . print ( idcheck ) ; out . flush ( ) ; } else { idcheck = 1 ; out . println ( idcheck ) ; out . flush ( ) ; string s = "server" ; chatwindow cw = new chatwindow ( socket , s ) ; } } catch ( ioexception e ) { system . out . println ( "error connecting to the server." ) ; } catch ( sqlexception e ) { system . out . println ( "error connecting to the sql server." ) ; } }
tr	4	public float interpolate ( int x , int z ) { int left = ( int ) ( x / xfreq ) + 1 ; int back = ( z / zfreq ) ; float [ ] interps = new float [ 4 ] ; for ( int i = 0 ; i < 4 ; i ++ ) { interps [ i ] = cubicinterpolate ( functionresults [ left - 1 ] [ back ] , functionresults [ left ] [ back ] , functionresults [ left + 1 ] [ back ] , functionresults [ left + 2 ] [ back ] , ( ( float ) ( x % xfreq ) ) / xfreq ) ; back ++ ; } return cubicinterpolate ( interps [ 0 ] , interps [ 1 ] , interps [ 2 ] , interps [ 3 ] , ( ( float ) ( z % zfreq ) ) / zfreq ) ; }
tr	9	public static string encode ( string str ) { byte [ ] buffer = str . getbytes ( ) ; int a = 0 , i = 0 , size = buffer . length ; char [ ] ch = new char [ ( ( size + 2 ) / 3 ) * 4 ] ; while ( i < size ) { byte b01 = buffer [ i ++ ] ; byte b12 = i < size ? buffer [ i ++ ] : 0 ; byte b23 = i < size ? buffer [ i ++ ] : 0 ; int mask = 0x3f ; ch [ a ++ ] = alphabet [ ( b01 > > 2 ) & mask ] ; ch [ a ++ ] = alphabet [ ( ( b01 << 4 ) | ( ( b12 & 0xff ) > > 4 ) ) & mask ] ; ch [ a ++ ] = alphabet [ ( ( b12 << 2 ) | ( ( b23 & 0xff ) > > 6 ) ) & mask ] ; ch [ a ++ ] = alphabet [ b23 & mask ] ; } switch ( size % 3 ) { case 1 : ch [ -- a ] = '=' ; case 2 : ch [ -- a ] = '=' ; } return new string ( ch ) ; }
tr	4	public user finduserbyusername ( final string username ) { string sql = "select * from t_user where user_name=?" ; final user user = new user ( ) ; jdbctemplate . query ( sql , new object [ ] { username } , new rowcallbackhandler ( ) { public void processrow ( resultset rs ) { try { final int userid = rs . getint ( "user_id" ) ; final int credits = rs . getint ( "credits" ) ; user . setuserid ( userid ) ; user . setusername ( username ) ; user . setcredits ( credits ) ; } catch ( sqlexception e ) { system . out . println ( e . getmessage ( ) ) ; } } } ) ; return user ; }
tr	3	public static void main ( string [ ] args ) { cliente c = new cliente ( ) ; c . leermsg ( ) ; bufferedreader stdin = new bufferedreader ( new inputstreamreader ( system . in ) ) ; system . out . print ( "chat: " ) ; string leestring ; try { while ( ( leestring = stdin . readline ( ) ) != null ) { c . mandamsg ( leestring ) ; system . out . print ( "chat: " ) ; } } catch ( ioexception e ) { e . printstacktrace ( ) ; } }
tr	3	public void sendmessageone ( string sn , string orgaddr , string telno , string content ) throws malformedurlexception , ioexception { httpurlconnection connection = ( httpurlconnection ) new url ( unsconsts . httphost ) . openconnection ( ) ; connection . setreadtimeout ( 30000 ) ; connection . setconnecttimeout ( 30000 ) ; connection . setdooutput ( true ) ; connection . setdoinput ( true ) ; connection . setrequestmethod ( "post" ) ; connection . setrequestproperty ( "content-type" , "text/xml;charset=utf-8" ) ; connection . setrequestproperty ( "soapaction" , "" ) ; connection . connect ( ) ; outputstream os = connection . getoutputstream ( ) ; string xml = "<soapenv:envelope xmlns:xsi=\\"http://www.w3.org/2001/xmlschema-instance\\" xmlns:xsd=\\"http://www.w3.org/2001/xmlschema\\" xmlns:soapenv=\\"http://schemas.xmlsoap.org/soap/envelope/\\" xmlns:chin=\\"http://chinagdn.com\\">" + "<soapenv:header/>" + "<soapenv:body>" + "<chin:insertdownsms soapenv:encodingstyle=\\"http://schemas.xmlsoap.org/soap/encoding/\\">" + "<sn xsi:type=\\"soapenc:string\\" xmlns:soapenc=\\"http://schemas.xmlsoap.org/soap/encoding/\\">" + sn + "</sn>" + "<orgaddr xsi:type=\\"soapenc:string\\" xmlns:soapenc=\\"http://schemas.xmlsoap.org/soap/encoding/\\">" + orgaddr + "</orgaddr>" + "<telno xsi:type=\\"soapenc:string\\" xmlns:soapenc=\\"http://schemas.xmlsoap.org/soap/encoding/\\">" + telno + "</telno>" + "<content xsi:type=\\"soapenc:string\\" xmlns:soapenc=\\"http://schemas.xmlsoap.org/soap/encoding/\\"><![cdata[" + content + "]]></content>" + "<sendtime xsi:type=\\"soapenc:string\\" xmlns:soapenc=\\"http://schemas.xmlsoap.org/soap/encoding/\\"></sendtime>" + "</chin:insertdownsms>" + "</soapenv:body>" + "</soapenv:envelope>" ; os . write ( xml . getbytes ( "utf-8" ) ) ; os . flush ( ) ; os . close ( ) ; connection . getinputstream ( ) ; }
tr	7	public rtpstream [ ] parse ( pdml pdml ) { map < string , rtpstream > out = new linkedhashmap < string , rtpstream > ( ) ; for ( packet packet : pdml . packets ) { for ( protocol protocol : packet . protocols ) { if ( "rtp" . equals ( protocol . name ) ) { map < string , field > fields = protocol . asmap ( ) ; if ( fields . containskey ( "rtp.ssrc" ) ) { string ssrc = fields . get ( "rtp.ssrc" ) . value ; rtpstream stream = out . get ( ssrc ) ; if ( null == stream ) { stream = new rtpstream ( ssrc ) ; out . put ( ssrc , stream ) ; if ( fields . containskey ( "rtp.setup" ) ) { int setupframe = integer . parseint ( fields . get ( "rtp.setup" ) . asmap ( ) . get ( "rtp.setup-frame" ) . show ) ; stream . setsetuppacket ( pdml . packets [ setupframe - 1 ] ) ; } } stream . add ( new rtppacket ( fields ) ) ; } } } } return out . values ( ) . toarray ( new rtpstream [ out . size ( ) ] ) ; }
tr	2	public void reload ( ) throws filenotfoundexception { main . reloadconfig ( ) ; main . bancommands . clear ( ) ; main . blacklist . clear ( ) ; main . white . clear ( ) ; if ( main . getconfig ( ) . getboolean ( "config.usebanlist" , true ) ) { scanner s = new scanner ( banlist ) ; while ( s . hasnextline ( ) ) { main . bancommands . add ( s . nextline ( ) ) ; } s . close ( ) ; } scanner s = new scanner ( list ) ; scanner s2 = new scanner ( whitelist ) ; while ( s . hasnextline ( ) ) { main . blacklist . add ( s . nextline ( ) ) ; } while ( s2 . hasnextline ( ) ) { main . white . add ( s2 . nextline ( ) ) ; } s . close ( ) ; s2 . close ( ) ; }
tr	6	public static money parsemoney ( string inputstring ) { long dollars ; int cents ; int numofnegs = 0 ; boolean neg ; for ( char c : inputstring . tochararray ( ) ) { if ( c == '-' ) { numofnegs ++ ; } } if ( numofnegs % 2 == 0 ) { neg = false ; } else { neg = true ; } inputstring = inputstring . replaceall ( "[^0-9.]+" , "" ) ; string [ ] listofnumbersstring ; if ( inputstring . contains ( "." ) && ! inputstring . substring ( inputstring . indexof ( "." ) + 1 ) . equals ( "" ) ) { listofnumbersstring = inputstring . split ( "\\\\." ) ; dollars = long . parselong ( listofnumbersstring [ 0 ] ) ; cents = integer . parseint ( listofnumbersstring [ 1 ] ) ; } else { inputstring = inputstring . replaceall ( "\\\\." , "" ) ; dollars = long . parselong ( inputstring ) ; cents = 0 ; } return new money ( dollars , cents , neg ) ; }
tr	4	private static string read ( clob c ) throws sqlexception , ioexception { stringbuffer sb = new stringbuffer ( ( int ) c . length ( ) ) ; reader r = c . getcharacterstream ( ) ; char [ ] cbuf = new char [ 2048 ] ; int n = 0 ; while ( ( n = r . read ( cbuf , 0 , cbuf . length ) ) != - 1 ) { if ( n > 0 ) { sb . append ( cbuf , 0 , n ) ; } } return sb . tostring ( ) ; }
tr	7	private double [ ] [ ] createrawarray ( int width , int height ) { double [ ] [ ] y = new double [ width ] [ height ] ; final int regionwidth = 3 ; int smallseed = math . abs ( seed / 1000 ) ; for ( int i = 0 ; i < width ; i ++ ) { for ( int j = 0 ; j < height ; j ++ ) { double nx = 1.0 * i / width * regionwidth ; double ny = 1.0 * j / height * regionwidth ; y [ i ] [ j ] = perlinnoise2 ( smallseed + nx , smallseed + ny ) ; } } return y ; }
tr	8	public void solve ( char [ ] [ ] board ) { if ( board . length == 0 || board [ 0 ] . length == 0 ) return ; int length = board . length ; int width = board [ 0 ] . length ; arraylist < integer > iindexes = new arraylist < integer > ( ) ; arraylist < integer > jindexes = new arraylist < integer > ( ) ; for ( int i = 0 ; i < length ; i ++ ) { for ( int j = 0 ; j < width ; j ++ ) { if ( board [ i ] [ j ] == 'o' && ( i == 0 || i == length - 1 || j == 0 || j == width - 1 ) ) { iindexes . add ( i ) ; jindexes . add ( j ) ; } else continue ; } } while ( ! iindexes . isempty ( ) ) { int x = iindexes . get ( 0 ) ; int y = jindexes . get ( 0 ) ; iindexes . remove ( 0 ) ; jindexes . remove ( 0 ) ; board [ x ] [ y ] = 'p' ; if ( x > 0 && board [ x - 1 ] [ y ] == 'o' ) { iindexes . add ( x - 1 ) ; jindexes . add ( y ) ; } if ( x < length - 1 && board [ x + 1 ] [ y ] == 'o' ) { iindexes . add ( x + 1 ) ; jindexes . add ( y ) ; } if ( y > 0 && board [ x ] [ y - 1 ] == 'o' ) { iindexes . add ( x ) ; jindexes . add ( y - 1 ) ; } if ( y < width - 1 && board [ x ] [ y + 1 ] == 'o' ) { iindexes . add ( x ) ; jindexes . add ( y + 1 ) ; } } for ( int i = 0 ; i < length ; i ++ ) { for ( int j = 0 ; j < width ; j ++ ) { if ( board [ i ] [ j ] == 'o' || board [ i ] [ j ] == 'o' ) board [ i ] [ j ] = 'x' ; if ( board [ i ] [ j ] == 'p' ) board [ i ] [ j ] = 'o' ; } } }
tr	2	@ override public void serialize ( double [ ] [ ] value , jsongenerator jgen , serializerprovider provider ) throws ioexception , jsonprocessingexception { jgen . writestartarray ( ) ; for ( int i = 0 ; i < value . length ; i ++ ) { jgen . writestartarray ( ) ; for ( int j = 0 ; j < value [ i ] . length ; j ++ ) { if ( value [ i ] [ j ] == ( int ) value [ i ] [ j ] ) { jgen . writenumber ( ( int ) value [ i ] [ j ] ) ; } else { jgen . writerawvalue ( string . format ( "%.3f" , value [ i ] [ j ] ) ) ; } } jgen . writeendarray ( ) ; } jgen . writeendarray ( ) ; }
tr	7	public static list < tconnection > getconnectionfromstring ( string input ) { list < tconnection > returnconnections = new arraylist < tconnection > ( ) ; tconnection connectionone = null ; tconnection connectiontwo = null ; if ( input . matches ( connection_pattern ) ) { string [ ] parts = input . split ( "-" ) ; connectionone = new tconnection ( ) ; connectiontwo = new tconnection ( ) ; if ( parts != null && parts . length == 3 ) { tnode one = new tnode ( parts [ 0 ] ) ; connectionone . settnodeone ( one ) ; try { int weight = integer . parseint ( parts [ 1 ] ) ; connectionone . setweight ( weight ) ; connectiontwo . setweight ( weight ) ; } catch ( numberformatexception e ) { system . out . println ( e . getmessage ( ) ) ; connectionone = null ; connectiontwo = null ; } tnode two = new tnode ( parts [ 2 ] ) ; connectiontwo . settnodeone ( two ) ; connectiontwo . settnodetwo ( one . gettitle ( ) ) ; connectionone . settnodetwo ( two . gettitle ( ) ) ; one . addconnection ( connectionone ) ; two . addconnection ( connectiontwo ) ; returnconnections . add ( connectionone ) ; returnconnections . add ( connectiontwo ) ; } } return returnconnections ; }
tr	7	private void generateetc ( ) { random rt = new random ( ) ; random rm = new random ( ) ; int q [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { int n_t = rt . nextint ( t_t ) ; q [ i ] = n_t ; } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { int n_m = rm . nextint ( t_m ) ; e [ i ] [ j ] = q [ i ] * n_m + 1 ; } } }
tr	7	public static round parsefirstround ( reader reader , hashtable < string , team > teams ) throws exception { round games = new round ( ) ; csvreader csvreader = new csvreader ( reader ) ; list < string [ ] > lines ; try { lines = csvreader . readall ( ) ; } catch ( ioexception e ) { system . out . println ( "error reading the csv file." ) ; return null ; } for ( string [ ] tokens : lines ) { if ( tokens . length == 1 && tokens [ 0 ] . trim ( ) . length ( ) == 0 ) continue ; team [ ] gameteams = new team [ 2 ] ; gameteams [ 0 ] = teams . get ( tokens [ 0 ] ) ; gameteams [ 1 ] = teams . get ( tokens [ 1 ] ) ; if ( gameteams [ 0 ] == null ) throw new exception ( "team not found: " + tokens [ 0 ] ) ; if ( gameteams [ 1 ] == null ) throw new exception ( "team not found: " + tokens [ 1 ] ) ; if ( tokens . length >= 4 ) { gameteams [ 0 ] . seed = integer . parseint ( tokens [ 2 ] ) ; gameteams [ 1 ] . seed = integer . parseint ( tokens [ 3 ] ) ; } for ( int i = 0 ; i < 2 ; i ++ ) if ( gameteams [ i ] == null ) throw new exception ( "team not found: " + tokens [ i ] ) ; game game = new game ( gameteams ) ; game . name = string . format ( "r0 g%d" , games . size ( ) ) ; games . add ( game ) ; } return games ; }
tr	2	@ override public void exec ( string channel , string sender , string commandname , string [ ] args , string login , string hostname , string message ) { try { sourceserver tf4 = new sourceserver ( "tf4.joe.to" ) ; tf4 . initialize ( ) ; system . out . println ( tf4 . getserverinfo ( ) ) ; this . bot . sendmessage ( channel , "[tf4] map: " + tf4 . getserverinfo ( ) . get ( "mapname" ) + "  players: " + tf4 . getserverinfo ( ) . get ( "numberofplayers" ) + " / " + tf4 . getserverinfo ( ) . get ( "maxplayers" ) ) ; } catch ( timeoutexception e ) { this . bot . sendmessage ( channel , "[tf4] error: timed out." ) ; e . printstacktrace ( ) ; } catch ( steamcondenserexception e ) { this . bot . sendmessage ( channel , "[tf4] error: i don't even know what went wrong." ) ; e . printstacktrace ( ) ; } try { sourceserver tf5 = new sourceserver ( "tf5.joe.to" ) ; tf5 . initialize ( ) ; system . out . println ( tf5 . getserverinfo ( ) ) ; this . bot . sendmessage ( channel , "[tf5] map: " + tf5 . getserverinfo ( ) . get ( "mapname" ) + "  players: " + tf5 . getserverinfo ( ) . get ( "numberofplayers" ) + " / " + tf5 . getserverinfo ( ) . get ( "maxplayers" ) ) ; } catch ( timeoutexception e ) { this . bot . sendmessage ( channel , "[tf5] error: timed out." ) ; e . printstacktrace ( ) ; } catch ( steamcondenserexception e ) { this . bot . sendmessage ( channel , "[tf5] error: i don't even know what went wrong." ) ; e . printstacktrace ( ) ; } }
tr	7	private void _generaterata ( ) { arraylist list , courselist ; tainfo ta ; rainfo ra ; arraylist tas , ras ; int i ; tas = new arraylist ( ) ; ras = new arraylist ( ) ; list = _getrandomlist ( instances_ [ cs_c_ta ] . total + instances_ [ cs_c_ra ] . total , 0 , instances_ [ cs_c_gradstud ] . total - 1 ) ; courselist = _getrandomlist ( instances_ [ cs_c_ta ] . total , 0 , undercourses_ . size ( ) - 1 ) ; for ( i = 0 ; i < instances_ [ cs_c_ta ] . total ; i ++ ) { ta = new tainfo ( ) ; ta . indexingradstud = ( ( integer ) list . get ( i ) ) . intvalue ( ) ; ta . indexincourse = ( ( courseinfo ) undercourses_ . get ( ( ( integer ) courselist . get ( i ) ) . intvalue ( ) ) ) . globalindex ; _generateata ( ta ) ; } while ( i < list . size ( ) ) { ra = new rainfo ( ) ; ra . indexingradstud = ( ( integer ) list . get ( i ) ) . intvalue ( ) ; _generateanra ( ra ) ; i ++ ; } }
tr	7	public static void arrayhopper ( integer arr [ ] ) { if ( null == arr || arr . length == 0 ) return ; int dp [ ] = new int [ arr . length ] ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( i == 0 ) { dp [ 0 ] = 0 ; } else { dp [ i ] = integer . max_value ; } } for ( int i = 0 ; i < arr . length ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( arr [ j ] + j >= i ) { dp [ i ] = math . min ( dp [ i ] , dp [ j ] + 1 ) ; break ; } } } if ( dp [ arr . length - 1 ] == integer . max_value ) { system . out . println ( "failure" ) ; return ; } int prev = dp [ arr . length - 1 ] ; int old = arr . length - 1 ; int i = arr . length - 1 ; list < integer > hops = new arraylist < integer > ( ) ; while ( i >= 0 ) { hops . add ( old ) ; int newold = 0 ; while ( i >= 0 && ( dp [ i ] == prev ) ) { i -- ; } while ( i >= 0 && dp [ i ] == prev - 1 ) { if ( arr [ i ] + i >= old ) { newold = i ; } i -- ; } old = newold ; prev = prev - 1 ; } hops . add ( old ) ; printhops ( hops ) ; }
tr	8	public void update ( ) { for ( int y = 0 ; y < ysize ; y ++ ) { for ( int x = 0 ; x < ysize ; x ++ ) { site site = scape . grid [ x ] [ y ] ; jlabel label = labels [ x ] [ y ] ; double energy = site . getfood ( ) ; double div = ( 255 / scape . maxfood ) * energy ; int gradient = ( int ) ( 255 - div ) ; color background ; background = ( gradient > 235 ) ? new color ( 255 , 250 , 205 ) : new color ( gradient , 255 , gradient ) ; label . setbackground ( background ) ; if ( site . getagent ( ) != null ) { label . settext ( "o" ) ; label . setforeground ( color . red ) ; } else { label . settext ( "" ) ; } } } }
tr	6	public listnode reversebetween ( listnode head , int m , int n ) { if ( m == n ) return head ; listnode start = null ; listnode beforestart = null ; listnode curr = null ; for ( int i = 0 ; i < m - 1 ; i ++ ) { beforestart = beforestart == null ? head : beforestart . next ; } start = beforestart == null ? head : beforestart . next ; listnode end = start ; curr = start . next ; listnode oldnext = curr . next ; for ( int i = 0 ; i < n - m ; i ++ ) { oldnext = curr . next ; curr . next = start ; start = curr ; curr = oldnext ; } end . next = oldnext ; if ( beforestart != null ) beforestart . next = start ; return ( beforestart == null ? start : head ) ; }
tr	2	public void samplequerymenu ( ) { boolean wanttoquit = false ; while ( ! wanttoquit ) { system . out . println ( "this is the sample query menu." ) ; system . out . println ( "1. list titles of all projects<litcomma> and the number of commits they have done on them." ) ; system . out . println ( "2. list emails of all contributors who are working on more than one project." ) ; system . out . println ( "3. list all contributors assigned to work on bugs<litcomma> and number of bugs assigned to them." ) ; system . out . println ( "4. find the most recent post(s) of all the projects." ) ; system . out . println ( "5. find the name and phone numbers of all managers of ongoing projects." ) ; system . out . println ( "6. list the emails of all contributors to projects that do not have managers." ) ; system . out . println ( "7. return to main menu" ) ; int option = userinput . nextint ( ) ; switch ( option ) { case 1 : query1 ( ) ; break ; case 2 : query2 ( ) ; break ; case 3 : query3 ( ) ; break ; case 4 : query4 ( ) ; break ; case 5 : query5 ( ) ; break ; case 6 : query6 ( ) ; break ; case 7 : wanttoquit = true ; default : system . out . println ( "invalid input. try again." ) ; } } }
tr	2	public void update ( int delta ) { float d = .01f * delta ; if ( turnright ) rotation += rotatespd * .01f * delta ; if ( turnleft ) rotation -= rotatespd * .01f * delta ; if ( ! checkborders ( ) && accelerate ) { acceleration [ 0 ] = ( float ) helper . cos ( rotation ) * speed ; acceleration [ 1 ] = ( float ) helper . sin ( rotation ) * speed ; velocity [ 0 ] += acceleration [ 0 ] * delta * .01f ; velocity [ 1 ] += acceleration [ 1 ] * delta * .01f ; } for ( int i = 0 ; i < 2 ; i ++ ) { location [ i ] += velocity [ i ] * delta * .01f ; if ( stop ) { velocity [ i ] -= velocity [ i ] / 10 * d ; } } }
tr	9	public static void sortmeth ( arraylist < arraylist < double > > arr ) { system . out . println ( ) ; for ( int i = 0 ; i < 10 && i < arr . size ( ) ; i ++ ) { arraylist < double > d = arr . get ( i ) ; d . set ( i , - 100.0 ) ; double max = collections . max ( d ) ; int index = 0 ; for ( int j = 0 ; j < d . size ( ) ; j ++ ) { if ( d . get ( j ) == max ) { d . set ( j , 0.0 ) ; index = j ; break ; } } double max2 = collections . max ( d ) ; int index1 = 0 ; for ( int j = 0 ; j < d . size ( ) ; j ++ ) { if ( d . get ( j ) == max2 && j != index ) { d . set ( j , 0.0 ) ; index1 = j ; break ; } } double max3 = collections . max ( d ) ; int index2 = 0 ; for ( int j = 0 ; j < d . size ( ) ; j ++ ) { if ( d . get ( j ) == max3 && j != index1 && j != index2 ) { d . set ( j , 0.0 ) ; index2 = j ; break ; } } system . out . println ( "document " + i + " - document " + index + ": " + max + " document " + index1 + ": " + max2 + " document " + index2 + ": " + max3 ) ; } }
tr	6	public static void main ( string [ ] args ) throws ioexception { scanner scanner = new scanner ( system . in ) ; system . out . print ( "source file dir: " ) ; string input = scanner . nextline ( ) ; system . out . print ( "target file dir: " ) ; string output = scanner . nextline ( ) ; fileinputstream fis = new fileinputstream ( input ) ; fileoutputstream fos = new fileoutputstream ( output ) ; int data = 0 ; do { data = fis . read ( ) ; fos . write ( data ) ; } while ( data != - 1 ) ; fis . close ( ) ; fos . close ( ) ; }
tr	6	private deck createunshufflabledeck ( ) throws invalidfacevalueexception , invalidsuitexception { list < card > cards = new arraylist < > ( ) ; char [ ] suits = { 'd' , 'h' , 'c' , 's' } ; char [ ] facevalues = { 'a' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , 't' , 'j' , 'q' , 'k' } ; for ( char suit : suits ) { for ( char facevalue : facevalues ) { cards . add ( new card ( suit , facevalue ) ) ; } } deck deck = mock ( deck . class ) ; when ( deck . getcards ( ) ) . thenreturn ( cards ) ; mockito . donothing ( ) . when ( deck ) . shuffle ( ) ; return deck ; }
tr	7	@ override public void insertupdate ( documentevent e ) { boolean havenotencounteredinvis = true ; char lastchar ; string fieldtext = null ; document doc = ( document ) e . getdocument ( ) ; try { fieldtext = doc . gettext ( 0 , doc . getlength ( ) ) ; } catch ( badlocationexception e1 ) { e1 . printstacktrace ( ) ; } if ( fieldtext . length ( ) > 1 ) { lastchar = fieldtext . charat ( fieldtext . length ( ) - 1 ) ; if ( lastchar == '\\n' ) { int x = fieldtext . length ( ) - 2 ; string enteredtext = "" ; char currentchar ; while ( havenotencounteredinvis ) { currentchar = fieldtext . charat ( x ) ; if ( currentchar == '\\n' ) { setenteredtext ( enteredtext ) ; havenotencounteredinvis = false ; display . setcaretposition ( display . getdocument ( ) . getlength ( ) ) ; } else if ( x == 0 ) { enteredtext = currentchar + enteredtext ; setenteredtext ( enteredtext ) ; havenotencounteredinvis = false ; } else { enteredtext = currentchar + enteredtext ; } x -- ; } } } }
tr	7	public int cancompletecircuit ( int [ ] gas , int [ ] cost ) { int res = - 1 ; int n = gas . length ; int total = 0 ; int [ ] gap = new int [ n ] ; for ( int i = 0 , j = 0 ; i < n ; i ++ , j ++ ) { if ( i == 0 ) gap [ i ] = gas [ i ] - cost [ i ] ; else gap [ i ] = gap [ i - 1 ] + gas [ i ] - cost [ i ] ; total += gas [ i ] - cost [ i ] ; } if ( total < 0 ) return res ; { int least = gap [ 0 ] ; res = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( gap [ i ] <= least ) { least = gap [ i ] ; res = i ; } } res = res + 1 ; if ( res == n ) res = 0 ; return res ; } }
tr	5	protected boolean createkeystorage ( ) throws mojoexecutionexception { getlog ( ) . info ( "creating key storage..." ) ; getlog ( ) . info ( "key storage: " + getkeystorage ( ) ) ; keytoolargumentsbuilder argumentsbuilder = new keytoolargumentsbuilder ( getkeystorage ( ) . getfile ( ) , getcertificate ( ) . getpassword ( ) , getcertificate ( ) . getauthor ( ) ) ; final string [ ] args = argumentsbuilder . create ( ) ; callable < void > keystoragecallable = new callable < void > ( ) { @ override public void call ( ) throws exception { keytool . main ( args ) ; return null ; } } ; exittrappingexecutor executor = new exittrappingexecutor ( ) ; boolean keystoragecreationsuccessful = executor . execute ( keystoragecallable ) == 0 && getkeystorage ( ) . getfile ( ) . exists ( ) ; if ( ! keystoragecreationsuccessful ) { throw new mojoexecutionexception ( "failed to create a key storage. path: " + getkeystorage ( ) . getfile ( ) . getpath ( ) ) ; } getlog ( ) . info ( "key storage successfully created." ) ; return keystoragecreationsuccessful ; }
tr	10	protected float weigthedseasonsfitness ( int saison , int spieltag , team team ) { teamstatus status = getteamstatus ( team , saison , spieltag , - 1 ) ; float fitnesssaison = status . getfitness ( ) ; teamstatus statusvor1 = getteamstatus ( team , saison - 1 , 34 , 0 ) ; float fitnessvor1 = statusvor1 . getfitness ( ) ; teamstatus statusvor2 = getteamstatus ( team , saison - 2 , 34 , 0 ) ; float fitnessvor2 = statusvor2 . getfitness ( ) ; float totalfitness = 0.0f ; if ( spieltag < 3 ) { float fitnessvor2gewichtet = 0.1f * fitnessvor2 ; float fitnessvor1gewichtet = 0.8f * fitnessvor1 ; float fitnesssaisongewichtet = 0.1f * fitnesssaison ; totalfitness = fitnesssaisongewichtet + fitnessvor1gewichtet + fitnessvor2gewichtet ; } else if ( spieltag < 4 ) { float fitnessvor2gewichtet = 0.2f * fitnessvor2 ; float fitnessvor1gewichtet = 0.5f * fitnessvor1 ; float fitnesssaisongewichtet = 0.3f * fitnesssaison ; totalfitness = fitnesssaisongewichtet + fitnessvor1gewichtet + fitnessvor2gewichtet ; } else if ( spieltag > 32 ) { float fitnessvor2gewichtet = 0.1f * fitnessvor2 ; float fitnessvor1gewichtet = 0.3f * fitnessvor1 ; float fitnesssaisongewichtet = 0.6f * fitnesssaison ; totalfitness = fitnesssaisongewichtet + fitnessvor1gewichtet + fitnessvor2gewichtet ; } else { float fitnessvor2gewichtet = 0.2f * fitnessvor2 ; float fitnessvor1gewichtet = 0.3f * fitnessvor1 ; float fitnesssaisongewichtet = 0.5f * fitnesssaison ; totalfitness = fitnesssaisongewichtet + fitnessvor1gewichtet + fitnessvor2gewichtet ; } return totalfitness ; }
tr	3	public void runprocess ( options opts , string [ ] args , commandlineparser parser ) { try { cl = process ( searchopts , args , parser ) ; } catch ( parseexception e ) { system . out . println ( "error on compile/parse command: " + e . getmessage ( ) ) ; printhelp ( opts ) ; system . exit ( - 1 ) ; } option [ ] allopts = cl . getoptions ( ) ; option opt = null ; for ( int i = 0 ; i < allopts . length ; i ++ ) { opt = allopts [ i ] ; if ( "h" . equals ( opt . getopt ( ) ) ) { printhelp ( opts ) ; system . exit ( 0 ) ; } system . out . println ( "option name: -" + opt . getopt ( ) + "<litcomma> and value = " + getoptvalues ( opt . getopt ( ) , "<litcomma>" ) ) ; } }
tr	10	public void paintcomponent ( graphics g ) { polygonmanager . update ( ) ; if ( battlemanager . encounter ) battlemanager . battlemechanics ( ) ; font outputfont = g . getfont ( ) . derivefont ( 17.0f ) ; font smallfont = g . getfont ( ) . derivefont ( 12.0f ) ; mapmanager . wallmanager ( ) ; g . setcolor ( drawings . ceiling ) ; g . fillrect ( 0 , 0 , 501 , 200 ) ; g . setcolor ( drawings . floor ) ; g . fillrect ( 0 , 200 , 501 , 201 ) ; g . setcolor ( color . darkgray ) ; g . fillrect ( 505 , 0 , 50 , 401 ) ; g . setcolor ( color . gray ) ; g . fillrect ( 0 , 405 , 560 , 129 ) ; graphics g2d = ( graphics2d ) g ; affinetransform savetransform = ( ( graphics2d ) g2d ) . gettransform ( ) ; affinetransform scalematrix_left = new affinetransform ( ) ; affinetransform scalematrix_right = new affinetransform ( ) ; scalematrix_left . translate ( 100 , 100 ) ; scalematrix_right . translate ( 150 , 100 ) ; scalematrix_left . scale ( 0.5 , 0.5 ) ; scalematrix_right . scale ( 0.5 , 0.5 ) ; if ( polygonmanager . distance >= 2 ) { if ( mapmanager . left1 ) { g2d . setcolor ( drawings . lighting_gray1 ) ; ( ( graphics2d ) g2d ) . settransform ( scalematrix_left ) ; g2d . fillpolygon ( drawings . left1 ) ; g2d . setcolor ( color . black ) ; ( ( graphics2d ) g2d ) . settransform ( scalematrix_left ) ; g2d . drawpolygon ( drawings . left1 ) ; } g2d . setcolor ( drawings . lighting_gray1 ) ; if ( mapmanager . right1 ) { ( ( graphics2d ) g2d ) . settransform ( scalematrix_right ) ; g2d . fillpolygon ( drawings . right1 ) ; g2d . setcolor ( color . black ) ; ( ( graphics2d ) g2d ) . settransform ( scalematrix_right ) ; g2d . drawpolygon ( drawings . right1 ) ; } } affinetransform scalematrix2_left = new affinetransform ( ) ; affinetransform scalematrix2_right = new affinetransform ( ) ; scalematrix2_left . translate ( 150 , 150 ) ; scalematrix2_right . translate ( 225 , 150 ) ; scalematrix2_left . scale ( 0.25 , 0.25 ) ; scalematrix2_right . scale ( 0.25 , 0.25 ) ; g2d . setcolor ( drawings . lighting_gray2 ) ; if ( polygonmanager . distance >= 2 ) { if ( mapmanager . left2 ) { ( ( graphics2d ) g2d ) . settransform ( scalematrix2_left ) ; g2d . fillpolygon ( drawings . left2 ) ; g2d . setcolor ( color . black ) ; ( ( graphics2d ) g2d ) . settransform ( scalematrix2_left ) ; g2d . drawpolygon ( drawings . left2 ) ; } g2d . setcolor ( drawings . lighting_gray2 ) ; if ( mapmanager . right2 ) { ( ( graphics2d ) g2d ) . settransform ( scalematrix2_right ) ; g2d . fillpolygon ( drawings . right2 ) ; g2d . setcolor ( color . black ) ; ( ( graphics2d ) g2d ) . settransform ( scalematrix2_right ) ; g2d . drawpolygon ( drawings . right2 ) ; } } ( ( graphics2d ) g2d ) . settransform ( savetransform ) ; if ( polygonmanager . distance <= 3 ) { if ( polygonmanager . distance == 0 ) g . setcolor ( drawings . lighting_gray ) ; else if ( polygonmanager . distance == 1 ) g . setcolor ( drawings . lighting_gray1 ) ; else if ( polygonmanager . distance >= 2 ) g . setcolor ( drawings . lighting_gray2 ) ; } else g . setcolor ( color . black ) ; if ( ( mapmanager . roomno == 18 || mapmanager . roomno >= 37 ) && mapmanager . facing == 'l' && ! mapmanager . gate ) g . setcolor ( color . green ) ; g . fillpolygon ( drawings . currentforward ) ; g . setcolor ( color . black ) ; g . drawpolygon ( drawings . currentforward ) ; g . setcolor ( drawings . lighting_gray ) ; if ( polygonmanager . distance >= 1 ) { if ( mapmanager . left ) { g . fillpolygon ( drawings . currentleft ) ; g . setcolor ( color . black ) ; g . drawpolygon ( drawings . currentleft ) ; g2d . setcolor ( drawings . lighting_gray ) ; } if ( mapmanager . right ) { g . fillpolygon ( drawings . currentright ) ; g . setcolor ( color . black ) ; g . drawpolygon ( drawings . currentright ) ; } } if ( polygonmanager . left_ext || polygonmanager . left_ext1 || polygonmanager . left_ext2 ) { if ( polygonmanager . left_ext ) g . setcolor ( drawings . lighting_gray ) ; else if ( polygonmanager . left_ext1 ) g . setcolor ( drawings . lighting_gray1 ) ; else if ( polygonmanager . left_ext2 ) g . setcolor ( drawings . lighting_gray2 ) ; g . fillpolygon ( drawings . left_ext ) ; g . setcolor ( color . black ) ; g . drawpolygon ( drawings . left_ext ) ; } if ( polygonmanager . right_ext || polygonmanager . right_ext1 || polygonmanager . right_ext2 ) { if ( polygonmanager . right_ext ) g . setcolor ( drawings . lighting_gray ) ; else if ( polygonmanager . right_ext1 ) g . setcolor ( drawings . lighting_gray1 ) ; else if ( polygonmanager . right_ext2 ) g . setcolor ( drawings . lighting_gray2 ) ; g . fillpolygon ( drawings . right_ext ) ; g . setcolor ( color . black ) ; g . drawpolygon ( drawings . right_ext ) ; } if ( mapmanager . roomno == 18 && mapmanager . facing == 'l' && mapmanager . gate ) { image scaledimage = imagemanager . gate1 . getscaledinstance ( 500 , 400 , image . scale_fast ) ; g . drawimage ( scaledimage , 0 , 0 , 500 , 400 , null ) ; } else if ( mapmanager . roomno == 18 && mapmanager . facing == 'l' && ! mapmanager . gate ) { image scaledimage = imagemanager . gate2 . getscaledinstance ( 500 , 400 , image . scale_fast ) ; g . drawimage ( scaledimage , 0 , 0 , 500 , 400 , null ) ; } else if ( mapmanager . roomno == 36 && mapmanager . facing == 'l' && ! mapmanager . chest_open ) g . drawimage ( imagemanager . chest1 , 175 , 275 , null ) ; else if ( mapmanager . roomno == 36 && mapmanager . facing == 'l' && mapmanager . chest_open ) g . drawimage ( imagemanager . chest2 , 175 , 250 , null ) ; if ( mapmanager . key_get ) g . drawimage ( imagemanager . keyblade , 507 , 40 , null ) ; g . drawimage ( imagemanager . sword , 507 , 5 , null ) ; float hp_percent = 0 ; if ( battlemanager . encounter ) { g . setcolor ( color . black ) ; g . setfont ( outputfont ) ; g . drawstring ( battlemanager . output , 5 , 420 ) ; g . setcolor ( color . red ) ; g . fillrect ( 400 , 412 , ( math . round ( battlemanager . hp * 100 ) / battlemanager . maxhp ) , 10 ) ; g . setcolor ( color . black ) ; g . drawrect ( 397 , 409 , 105 , 15 ) ; g . drawstring ( battlemanager . hp + " / " + battlemanager . maxhp , 397 , 440 ) ; g . setcolor ( color . blue ) ; g . fillrect ( 400 , 462 , math . round ( ( battlemanager . mana * 100 ) / battlemanager . maxmana ) , 10 ) ; g . setcolor ( color . black ) ; g . drawrect ( 397 , 459 , 105 , 15 ) ; g . drawstring ( battlemanager . mana + " / " + battlemanager . maxmana , 397 , 490 ) ; if ( battlemanager . selected == 1 ) g . setcolor ( color . blue ) ; else g . setcolor ( color . white ) ; g . fillrect ( 5 , 440 , 100 , 20 ) ; if ( battlemanager . selected == 2 ) g . setcolor ( color . blue ) ; else g . setcolor ( color . white ) ; g . fillrect ( 110 , 440 , 100 , 20 ) ; if ( battlemanager . selected == 3 ) g . setcolor ( color . blue ) ; else g . setcolor ( color . white ) ; g . fillrect ( 5 , 465 , 100 , 20 ) ; if ( battlemanager . selected == 4 ) g . setcolor ( color . blue ) ; else g . setcolor ( color . white ) ; g . fillrect ( 110 , 465 , 100 , 20 ) ; g . setcolor ( color . black ) ; if ( battlemanager . selected == 1 ) g . setcolor ( color . white ) ; else g . setcolor ( color . black ) ; g . drawstring ( "sword" , 10 , 457 ) ; if ( battlemanager . selected == 2 ) g . setcolor ( color . white ) ; else g . setcolor ( color . black ) ; g . drawstring ( "fire magic" , 115 , 457 ) ; if ( battlemanager . selected == 3 ) g . setcolor ( color . white ) ; else g . setcolor ( color . black ) ; g . drawstring ( "h-potion" , 10 , 482 ) ; if ( battlemanager . selected == 4 ) g . setcolor ( color . white ) ; else g . setcolor ( color . black ) ; g . drawstring ( "m-potion" , 115 , 482 ) ; g . setfont ( smallfont ) ; if ( battlemanager . monster [ battlemanager . monstertype ] . equals ( "cactuar" ) ) { g . drawimage ( imagemanager . cactuar , 190 , 270 , 150 , 150 , null ) ; } else if ( battlemanager . monster [ battlemanager . monstertype ] . equals ( "bomb" ) ) { g . drawimage ( imagemanager . bomb , 180 , 230 , 150 , 160 , null ) ; } else if ( battlemanager . monster [ battlemanager . monstertype ] . equals ( "slime" ) ) { g . drawimage ( imagemanager . slime , 170 , 260 , 150 , 150 , null ) ; } else if ( battlemanager . monster [ battlemanager . monstertype ] . equals ( "imp" ) ) { g . drawimage ( imagemanager . imp , 170 , 280 , 150 , 150 , null ) ; } } if ( inputmanager . input ( '`' ) && release ) { debug = ! debug ; } if ( inputmanager . input ( '`' ) ) release = false ; else release = true ; if ( debug ) { g . setcolor ( color . red ) ; g . drawrect ( 50 , 0 , 300 , 50 ) ; g . drawstring ( "distance = " + polygonmanager . distance , 60 , 10 ) ; g . drawstring ( "room# = " + mapmanager . roomno , 140 , 10 ) ; g . drawstring ( "facing = " + mapmanager . facing , 220 , 10 ) ; g . drawstring ( "advance = " + mapmanager . advance , 60 , 30 ) ; g . drawstring ( "gate = " + mapmanager . gate , 150 , 30 ) ; g . drawstring ( "encounter = " + battlemanager . encounter , 230 , 30 ) ; g . drawstring ( "hp = " + battlemanager . hp , 340 , 30 ) ; g . drawstring ( "maxhp = " + battlemanager . maxhp , 390 , 30 ) ; } }
tr	3	private static individual createendurant ( individual image ) { individual endurant = ontmodel . getontclass ( cidoccrm . e77_persistent_item ) . createindividual ( contentitems . get ( "title-field" ) ) ; image . addproperty ( ontmodel . getproperty ( cidoccrm . p138_represents ) , endurant ) ; endurant . addproperty ( ontmodel . getproperty ( cidoccrm . p138i_has_representation ) , image ) ; if ( contentitems . get ( "material-field" ) != null ) { individual material = ontmodel . getontclass ( cidoccrm . e57_material ) . createindividual ( contentitems . get ( "material-field" ) ) ; endurant . addproperty ( ontmodel . getproperty ( cidoccrm . p45_consists_of ) , material ) ; material . addproperty ( ontmodel . getproperty ( cidoccrm . p45i_is_incorporated_in ) , endurant ) ; } if ( contentitems . get ( "size-field" ) != null ) { individual size = ontmodel . getontclass ( cidoccrm . e54_dimension ) . createindividual ( contentitems . get ( "size-field" ) ) ; endurant . addproperty ( ontmodel . getproperty ( cidoccrm . p43_has_dimension ) , size ) ; size . addproperty ( ontmodel . getproperty ( cidoccrm . p43i_is_dimension_of ) , endurant ) ; } if ( contentitems . get ( "credits-field" ) != null ) addnote ( endurant , "credits: " + contentitems . get ( "credits-field" ) ) ; if ( contentitems . get ( "discoverycontext-field" ) != null ) addnote ( endurant , "discoverycontext: " + contentitems . get ( "discoverycontext-field" ) ) ; if ( contentitems . get ( "inventory_no-field" ) != null ) addnote ( endurant , "inventory no: " + contentitems . get ( "inventory_no-field" ) ) ; if ( contentitems . get ( "inscription-field" ) != null ) addnote ( endurant , "inscription: " + contentitems . get ( "inscription-field" ) ) ; if ( contentitems . get ( "beneficiary_of_charter-field" ) != null ) addnote ( endurant , "beneficiary of charter: " + contentitems . get ( "beneficiary_of_charter-field" ) ) ; if ( contentitems . get ( "edition-field" ) != null ) addnote ( endurant , "edition: " + contentitems . get ( "edition-field" ) ) ; if ( contentitems . get ( "issuer_of_charter-field" ) != null ) addnote ( endurant , "issuer of charter: " + contentitems . get ( "issuer_of_charter-field" ) ) ; if ( contentitems . get ( "negative_id-field" ) != null ) addnote ( endurant , "negative: " + contentitems . get ( "negative_id-field" ) ) ; if ( contentitems . get ( "number_of_preserved_seals-field" ) != null ) addnote ( endurant , "number of preserved seals: " + contentitems . get ( "number_of_preserved_seals-field" ) ) ; if ( contentitems . get ( "original_number_of_seals-field" ) != null ) addnote ( endurant , "original number of seals: " + contentitems . get ( "original_number_of_seals-field" ) ) ; if ( contentitems . get ( "record_id-field" ) != null ) addnote ( endurant , "record: " + contentitems . get ( "record_id-field" ) ) ; if ( contentitems . get ( "tradition-field" ) != null ) addnote ( endurant , "tradition: " + contentitems . get ( "tradition-field" ) ) ; if ( contentitems . get ( "annotation-field" ) != null ) addnote ( endurant , "annotation: " + contentitems . get ( "annotation-field" ) ) ; if ( contentitems . get ( "subtitle-field" ) != null ) addnote ( endurant , "subtitle: " + contentitems . get ( "subtitle-field" ) ) ; if ( contentitems . get ( "description_source-field" ) != null ) addnote ( endurant , "description source: " + contentitems . get ( "description_source-field" ) ) ; if ( contentitems . get ( "caption-field" ) != null ) addnote ( endurant , "caption: " + contentitems . get ( "caption-field" ) ) ; if ( contentitems . get ( "keyword_general-field" ) != null ) addnote ( endurant , "keyword general: " + contentitems . get ( "keyword_general-field" ) ) ; if ( contentitems . get ( "pattern-field" ) != null ) addnote ( endurant , "pattern: " + contentitems . get ( "pattern-field" ) ) ; return endurant ; }
tr	8	public string tosummarystring ( ) { stringwriter stringwriter = new stringwriter ( ) ; csvwriter writer = new csvwriter ( stringwriter ) ; string [ ] columns = new string [ 0 ] ; for ( round round : rounds ) { for ( game game : round ) { for ( int i = 0 ; i < 2 ; i ++ ) { if ( columns . length == 0 ) { if ( game . summarystats . size ( ) == 0 ) return "" ; columns = game . summarystats . toarray ( columns ) ; writer . writenext ( columns ) ; } string [ ] values = new string [ columns . length ] ; for ( int j = 0 ; j < values . length ; j ++ ) values [ j ] = game . summaries [ i ] . get ( columns [ j ] ) . tostring ( ) ; writer . writenext ( values ) ; } } } return stringwriter . tostring ( ) ; }
tr	6	public static void main ( string [ ] args ) { string msg = null ; string scurrentline ; if ( args . length == 0 ) { system . out . println ( "filename is not given" ) ; return ; } fs fs = new fs ( ) ; msg = fs . readfile ( args [ 0 ] ) ; int worlds = msg . split ( " " ) . length ; int lines = msg . split ( "\\n" ) . length - 1 ; int characters = msg . split ( "" ) . length ; system . out . println ( "  " + lines + " " + worlds + " " + characters + " " + args [ 0 ] ) ; }
tr	5	public void load ( string filename ) throws filenotfoundexception { ngramidmap . clear ( ) ; indexmap . clear ( ) ; reader < entry > reader = new abstractfilereader < entry > ( ) { @ override public entry next ( ) { scanner . usedelimiter ( "\\\\s+" ) ; integer id = scanner . nextint ( ) ; integer usecount = scanner . nextint ( ) ; string base = scanner . next ( ) ; return new entry ( new ngram ( base ) , id , usecount ) ; } } ; reader . open ( filename ) ; system . out . println ( "loading dictionary" ) ; while ( reader . hasnext ( ) ) { entry next = reader . next ( ) ; addnewentry ( next ) ; readngramcount += next . usecount ; } reader . close ( ) ; system . out . println ( "dictionary loaded" ) ; }
tr	5	public gerarrelatorio ( ) { stringbuilder criarelatorio = new stringbuilder ( ) ; enumeration relatorio = dadosgerais . placassaida . keys ( ) ; int y = 0 ; while ( relatorio . hasmoreelements ( ) ) { dadosgerais . listadeplacas [ y ] = ( string ) relatorio . nextelement ( ) ; y ++ ; } if ( dadosgerais . placassaida . isempty ( ) ) { criarelatorio . append ( "n\xe3o houve movimento." ) ; } else { for ( int i = 0 ; i < dadosgerais . listadeplacas . length ; i ++ ) { if ( dadosgerais . listadeplacas [ i ] == null ) { i = i + 1 ; } else { criarelatorio . append ( dadosgerais . listadeplacas [ i ] ) . append ( "\\r\\n" ) ; } } } relatoriododia = "relat\xf3rio do dia\\r\\n\\r\\n" + "usu\xe1rio: " + login . antigouser + "\\r\\n" + dadosgerais . formatadatarelatorio . format ( dadosgerais . data ) + "\\r\\n\\r\\nvalor por placa: r$5<litcomma>00" + "\\r\\n\\r\\n\\r\\nplacas do dia:" + "\\r\\n" + criarelatorio + "\\r\\n\\r\\ntotal do caixa: r$" + dadosgerais . placassaida . size ( ) * 5 + "<litcomma>00" ; salvararquivorelatorio salvar = new salvararquivorelatorio ( ) ; }
tr	6	public string removecommonlines ( string data ) { string result = "" ; int index ; arraylist list = new arraylist ( ) ; string [ ] temp = data . split ( "\\n" ) ; int length = temp . length ; for ( index = 1 ; index < length ; index ++ ) { if ( ! temp [ index - 1 ] . equals ( temp [ index ] ) ) list . add ( temp [ index - 1 ] ) ; } list . add ( temp [ index - 1 ] ) ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) result += list . get ( i ) + "\\n" ; return result . substring ( 0 , result . length ( ) - 1 ) ; }
tr	1	@ override public void run ( ) { running = true ; while ( running ) { datagrampacket p = new datagrampacket ( new byte [ 18 + mtu ] , 18 + mtu ) ; try { serversocket . receive ( p ) ; p . setdata ( p . getdata ( ) , 0 , p . getlength ( ) ) ; pcaplogger . logpacket ( p , p . getaddress ( ) , p . getport ( ) , serversocket . getlocaladdress ( ) , serversocket . getlocalport ( ) ) ; utils . dumppacket ( p , p . getaddress ( ) , p . getport ( ) , serversocket . getlocaladdress ( ) , serversocket . getlocalport ( ) , packetlogger ) ; handler . handlepacket ( p ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } } }
tr	3	private arraylist < arraylist < string > > backtrace ( string end , hashmap < string , hashset < string > > visited , arraylist < string > path ) { arraylist < arraylist < string > > result = new arraylist < arraylist < string > > ( ) ; arraylist < string > entry = new arraylist < string > ( path ) ; entry . add ( 0 , end ) ; if ( visited . get ( end ) . size ( ) < 1 ) { result . add ( entry ) ; return result ; } for ( string str : visited . get ( end ) ) { result . addall ( backtrace ( str , visited , entry ) ) ; } return result ; }
tr	10	public static void hash ( string [ ] args , printstream ps ) { string tag = null ; string master = null ; int length = 16 ; boolean requiredigit = true ; boolean requirepunctuation = true ; boolean requiremixed = true ; boolean restrictspecial = false ; boolean restrictdigits = false ; for ( string arg : args ) { if ( arg . startswith ( "--requiredigit" ) ) { requiredigit = flagvalue ( arg ) ; } else if ( arg . startswith ( "--requirepunct" ) ) { requirepunctuation = flagvalue ( arg ) ; } else if ( arg . startswith ( "--requiremixed" ) ) { requiremixed = flagvalue ( arg ) ; } else if ( arg . startswith ( "--nospecial" ) ) { restrictspecial = flagvalue ( arg ) ; } else if ( arg . startswith ( "--onlydigits" ) ) { restrictdigits = flagvalue ( arg ) ; } else if ( arg . startswith ( "--length" ) ) { length = intvalue ( arg ) ; } else if ( tag == null ) { tag = arg ; } else { master = arg ; } } hasher jph = new hasher ( ) ; ps . println ( jph . generatehashword ( master , tag , length , requiredigit , requirepunctuation , requiremixed , restrictspecial , restrictdigits ) ) ; }
tr	9	public int largestrectangleareatle ( int [ ] height ) { int [ ] area = new int [ height . length ] ; int [ ] area2 = new int [ height . length ] ; for ( int i = 0 ; i < height . length ; i ++ ) { int left = height [ i ] ; int unit = 1 ; for ( int j = i + 1 ; j < height . length ; j ++ ) { if ( height [ j ] >= left ) { unit ++ ; if ( j == height . length - 1 ) { area [ i ] = unit * left ; } } else { area [ i ] = unit * left ; break ; } } } for ( int i = height . length - 1 ; i >= 0 ; i -- ) { int right = height [ i ] ; int unit = 1 ; for ( int j = i - 1 ; j >= 0 ; j -- ) { if ( height [ j ] >= right ) { unit ++ ; if ( j == 0 ) { area2 [ i ] = unit * right ; } } else { area2 [ i ] = unit * right ; break ; } } } int max = 0 ; for ( int i = 0 ; i < height . length ; i ++ ) { int larger = math . max ( area [ i ] , area2 [ i ] ) ; if ( larger > max ) max = larger ; } return max ; }
tr	3	public string tostring ( ) { string outputstring = "" ; string rankstring = "" ; string suitstring = "" ; switch ( rank ) { case 1 : rankstring = "ace" ; break ; case 2 : rankstring = "two" ; break ; case 3 : rankstring = "three" ; break ; case 4 : rankstring = "four" ; break ; case 5 : rankstring = "five" ; break ; case 6 : rankstring = "six" ; break ; case 7 : rankstring = "seven" ; break ; case 8 : rankstring = "eight" ; break ; case 9 : rankstring = "nine" ; break ; case 10 : rankstring = "ten" ; break ; case 11 : rankstring = "jack" ; break ; case 12 : rankstring = "queen" ; break ; case 13 : rankstring = "king" ; break ; default : break ; } switch ( suit ) { case 1 : suitstring = "clubs" ; break ; case 2 : suitstring = "diamonds" ; break ; case 3 : suitstring = "spades" ; break ; case 4 : suitstring = "hearts" ; break ; default : break ; } outputstring = rankstring + " of " + suitstring ; return outputstring ; }
tr	8	@ override public void onenable ( ) { savedefaultconfig ( ) ; pluginmanager pm = getserver ( ) . getpluginmanager ( ) ; plugin gmi = pm . getplugin ( "gamemodeinventories" ) ; if ( gmi == null ) { system . err . println ( "[gmidatabaseconverter] this plugin requires gamemodeinventories!" ) ; pm . disableplugin ( this ) ; return ; } string v = gmi . getdescription ( ) . getversion ( ) ; version gmiversion = new version ( v ) ; version notneededversion = new version ( "2.0" ) ; if ( gmiversion . compareto ( notneededversion ) >= 0 ) { system . err . println ( "[gmidatabaseconverter] you do not need to run this with version " + v + " of gamemodeinventories!" ) ; pm . disableplugin ( this ) ; return ; } if ( getconfig ( ) . getboolean ( "conversion_done" ) ) { system . err . println ( "[gmidatabaseconverter] the gamemodeinventories database has already been converted!" ) ; pm . disableplugin ( this ) ; return ; } file old_file = new file ( gmi . getdatafolder ( ) + file . separator + "gmi.db" ) ; if ( ! old_file . exists ( ) ) { system . err . println ( "[gmidatabaseconverter] could not find gamemodeinventories database file!" ) ; pm . disableplugin ( this ) ; return ; } file backup_file = new file ( gmi . getdatafolder ( ) + file . separator + "gmi_backup.db" ) ; try { copyfile ( old_file , backup_file ) ; } catch ( ioexception io ) { system . err . println ( "[gmidatabaseconverter] could backup gamemodeinventories database file!" ) ; pm . disableplugin ( this ) ; return ; } system . out . println ( "[gmidatabaseconverter] the gamemodeinventories database file was backed up successfully!" ) ; try { string path = gmi . getdatafolder ( ) + file . separator + "gmi.db" ; service . setconnection ( path ) ; } catch ( exception e ) { system . err . println ( "[gmidatabaseconverter] database connection error: " + e ) ; } if ( ! convertinventories ( ) ) { system . err . println ( "[gmidatabaseconverter] inventory conversion failed!" ) ; pm . disableplugin ( this ) ; } else { getconfig ( ) . set ( "conversion_done" , true ) ; } }
tr	2	public static void main ( string [ ] args ) { meowzy bot = new meowzy ( ) ; log . consolelog ( "starting up..." ) ; config . loadconfiguration ( ) ; file check = new file ( "meowzy.db" ) ; if ( ! check . exists ( ) ) { bot . sql . resetdatabase ( ) ; } try { bot . connect ( config . getserveraddress ( ) ) ; } catch ( nickalreadyinuseexception e ) { if ( ! config . getautonickchange ( ) ) { log . consolelog ( "error" , "could not connect to server: " + config . getserveraddress ( ) ) ; e . printstacktrace ( ) ; } else { log . consolelog ( "error" , "nick already in use!" ) ; } } catch ( ioexception e ) { log . consolelog ( "error" , "could not connect to server: " + config . getserveraddress ( ) ) ; e . printstacktrace ( ) ; } catch ( ircexception e ) { log . consolelog ( "error" , "could not connect to server: " + config . getserveraddress ( ) ) ; e . printstacktrace ( ) ; } }
tr	1	@ override public void actionperformed ( final actionevent e ) { object source = e . getsource ( ) ; if ( source == getdepositradiobutton ( ) ) { gettransaction ( ) . settype ( type . deposit ) ; } else if ( source == getwithdrawalradiobutton ( ) ) { gettransaction ( ) . settype ( type . withdrawal ) ; } else if ( source == getdeletebutton ( ) ) { getmainframe ( ) . removetransactionbyid ( gettransaction ( ) . getid ( ) ) ; } serializer . savestate ( ) ; getmainframe ( ) . updatebalance ( ) ; }
tr	9	public string tosvg ( string . ) { log . debug ( "create svg from dot" ) ; file dotfile = null ; file svgfile = null ; try { dotfile = file . createtempfile ( "graphviz" , ".dot" ) ; filewriter writer = new filewriter ( dotfile ) ; ioutils . write ( . , writer ) ; writer . flush ( ) ; writer . close ( ) ; log . debug ( "dot written to {}" , dotfile ) ; svgfile = file . createtempfile ( "graphviz" , ".svg" ) ; string command = dotcommand + " -tsvg" + " -o" + svgfile . getabsolutepath ( ) + " -gcharset=latin1 " + dotfile . getabsolutepath ( ) ; log . debug ( "command: {}" , command ) ; processbuilder pb = new processbuilder ( command . split ( " " ) ) ; pb . redirecterrorstream ( true ) ; process process = pb . start ( ) ; thread receiverthread = new thread ( new receiver ( process . getinputstream ( ) ) , "process output receiver" ) ; receiverthread . setdaemon ( true ) ; receiverthread . start ( ) ; log . debug ( "started the archive process: {}" , process ) ; int processexit = process . waitfor ( ) ; log . debug ( "process exited with {}" , processexit ) ; if ( processexit != 0 ) { throw new runtimeexception ( "failed to execute dot" ) ; } log . debug ( "read result from temporary file" ) ; string result = ioutils . tostring ( new filereader ( svgfile ) ) ; log . debug ( "successfully produced svg" ) ; return result ; } catch ( ioexception e ) { throw new runtimeexception ( e ) ; } catch ( interruptedexception e ) { throw new runtimeexception ( e ) ; } finally { if ( dotfile != null ) { log . debug ( "delete temporary dot file: {}" , dotfile . getabsolutepath ( ) ) ; dotfile . delete ( ) ; } if ( svgfile != null ) { log . debug ( "delete temporary svg file: {}" , svgfile . getabsolutepath ( ) ) ; svgfile . delete ( ) ; } } }
tr	8	public state getminimaxdecision ( state initialstate ) { system . out . println ( "player: " + player ) ; long t1 = system . currenttimemillis ( ) ; action bestaction = null ; double bestutility = double . negative_infinity ; list < action > actionlist = getactions ( initialstate ) ; for ( action action : actionlist ) { double utility = minvalue ( getresult ( initialstate , action ) ) ; if ( utility > bestutility ) { bestutility = utility ; bestaction = action . deepcopy ( ) ; } } state resultstate = getresult ( initialstate , bestaction ) ; long t2 = system . currenttimemillis ( ) ; system . out . println ( "time: " + ( t2 - t1 ) + "ms" ) ; return resultstate ; }
tr	4	public void setup ( ) { size ( 1280 , 520 ) ; kinect = new kinect ( this ) ; kinect . start ( ) ; kinect . enabledepth ( depth ) ; kinect . enablergb ( rgb ) ; int h = kinect . getvideoimage ( ) . height ; int w = kinect . getvideoimage ( ) . width ; int hd = kinect . getdepthimage ( ) . height ; int wd = kinect . getdepthimage ( ) . width ; system . out . println ( "h:" + h + " w:" + w + " hd:" + hd + " wd:" + wd ) ; }
tr	10	public static final void compare ( file dir1 , file dir2 ) { if ( dir1 == null ) { if ( dir2 == null ) return ; system . out . println ( ">>> " + dir2 + "\\t[" + dir2 . listfiles ( ) . length + " files]" ) ; return ; } if ( dir2 == null ) { system . out . println ( "<<< " + dir1 + "\\t[" + dir1 . listfiles ( ) . length + " files]" ) ; return ; } file [ ] list1 = dir1 . listfiles ( ) ; file [ ] list2 = dir2 . listfiles ( ) ; if ( list1 == null ) list1 = new file [ 0 ] ; if ( list2 == null ) list2 = new file [ 0 ] ; arrays . sort ( list1 ) ; arrays . sort ( list2 ) ; int ndx1 = 0 , ndx2 = 0 ; while ( ndx1 < list1 . length && ndx2 < list2 . length ) { boolean d1 = list1 [ ndx1 ] . isdirectory ( ) ; boolean d2 = list2 [ ndx2 ] . isdirectory ( ) ; int c = list1 [ ndx1 ] . getname ( ) . comparetoignorecase ( list2 [ ndx2 ] . getname ( ) ) ; if ( c < 0 ) { system . out . print ( "<<< " + list1 [ ndx1 ++ ] + "\\t[missing]" ) ; if ( d1 ) system . out . print ( " [directory]" ) ; system . out . println ( ) ; } else if ( c > 0 ) { system . out . print ( ">>> " + list2 [ ndx2 ++ ] + "\\t[missing]" ) ; if ( d2 ) system . out . print ( " [directory]" ) ; system . out . println ( ) ; } else { if ( ( d1 && ! d2 ) ) system . out . println ( "!d! " + list2 [ ndx1 ] ) ; else if ( ! d1 && d2 ) system . out . println ( "!d! " + list1 [ ndx1 ] ) ; else if ( d1 && d2 ) compare ( list1 [ ndx1 ] , list2 [ ndx2 ] ) ; else { long len1 = list1 [ ndx1 ] . length ( ) ; long len2 = list2 [ ndx2 ] . length ( ) ; if ( len1 != len2 ) { system . out . println ( "!s! " + list1 [ ndx1 ] + "\\t[" + len1 + " vs " + len2 + "]" ) ; } } ndx1 ++ ; ndx2 ++ ; } } if ( ndx1 < list1 . length ) { for ( int i = ndx1 ; i < list1 . length ; i ++ ) { boolean d1 = list1 [ i ] . isdirectory ( ) ; system . out . print ( "<<< " + list1 [ i ] + "\\t[missing]" ) ; if ( d1 ) system . out . print ( " [directory]" ) ; system . out . println ( ) ; } } if ( ndx2 < list2 . length ) { for ( int i = ndx2 ; i < list2 . length ; i ++ ) { boolean d2 = list2 [ i ] . isdirectory ( ) ; system . out . print ( ">>> " + list2 [ i ] + "\\t[missing]" ) ; if ( d2 ) system . out . print ( " [directory]" ) ; system . out . println ( ) ; } } }
tr	9	public static void setskin ( gameprofile gp ) { if ( getmap ( ) . containskey ( gp . getid ( ) ) ) { propertymap map = gp . getproperties ( ) ; map . put ( "textures" , getmap ( ) . get ( gp . getid ( ) ) ) ; return ; } try { url url = new url ( "https://sessionserver.mojang.com/session/minecraft/profile/" + gp . getid ( ) . tostring ( ) . replaceall ( "-" , "" ) + "?unsigned=false" ) ; bufferedreader reader = new bufferedreader ( new inputstreamreader ( url . openstream ( ) ) ) ; jsonparser parser = new jsonparser ( ) ; jsonobject root = ( jsonobject ) parser . parse ( reader ) ; jsonarray properties = ( jsonarray ) root . get ( "properties" ) ; string data = ( string ) ( ( jsonobject ) properties . get ( 0 ) ) . get ( "value" ) ; string signature = ( string ) ( ( jsonobject ) properties . get ( 0 ) ) . get ( "signature" ) ; reader . close ( ) ; propertymap map = gp . getproperties ( ) ; property property = new property ( "textures" , data , signature ) ; map . put ( "textures" , property ) ; getmap ( ) . put ( gp . getid ( ) , property ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } }
tr	6	private int evaluatepostfix ( string postfixexpr ) { char [ ] chars = postfixexpr . tochararray ( ) ; stack < integer > stack = new stack < > ( ) ; for ( char operator : chars ) { if ( isoperand ( operator ) ) { stack . push ( operator - '0' ) ; } else if ( isoperator ( operator ) ) { int operand1 = stack . pop ( ) ; int operand2 = stack . pop ( ) ; int result ; switch ( operator ) { case '*' : result = operand1 * operand2 ; stack . push ( result ) ; break ; case '/' : result = operand2 / operand1 ; stack . push ( result ) ; break ; case '+' : result = operand1 + operand2 ; stack . push ( result ) ; break ; case '-' : result = operand2 - operand1 ; stack . push ( result ) ; break ; default : throw new illegalargumentexception ( "illegal operation: " + operator ) ; } } } return stack . pop ( ) ; }
tr	2	@ override public void draw ( ) { if ( this . tex != null ) { tex . bind ( ) ; } gl11 . glpushmatrix ( ) ; gl11 . gltranslatef ( x , y , 0 ) ; gl11 . glbegin ( gl11 . gl_quads ) ; float dist = 1f / numtiles ; float tilesize = 16f ; gl11 . gltexcoord2f ( col * dist , dist * ( row + 1 ) ) ; gl11 . glvertex2f ( 0 , 0 ) ; gl11 . gltexcoord2f ( dist + ( col * dist ) , dist * ( row + 1 ) ) ; gl11 . glvertex2f ( tilesize , 0 ) ; gl11 . gltexcoord2f ( dist + ( col * dist ) , dist * row ) ; gl11 . glvertex2f ( tilesize , tilesize ) ; gl11 . gltexcoord2f ( col * dist , dist * row ) ; gl11 . glvertex2f ( 0 , tilesize ) ; gl11 . glend ( ) ; gl11 . glpopmatrix ( ) ; }
tr	9	private list < object > listallentries ( int maxrowcount ) { list < object > list = new arraylist < object > ( ) ; rangeslicesquery < string , string , bytebuffer > rangeslicesquery = hfactory . createrangeslicesquery ( this . getkeyspace ( ) , stringserializer . get ( ) , stringserializer . get ( ) , bytebufferserializer . get ( ) ) . setcolumnfamily ( def_user_cf_name ) . setrange ( null , null , false , 10 ) . setrowcount ( maxrowcount ) ; string last_key = null ; while ( true ) { rangeslicesquery . setkeys ( last_key , null ) ; queryresult < orderedrows < string , string , bytebuffer > > result = rangeslicesquery . execute ( ) ; orderedrows < string , string , bytebuffer > rows = result . get ( ) ; iterator < row < string , string , bytebuffer > > rowsiterator = rows . iterator ( ) ; if ( last_key != null && rowsiterator != null ) { rowsiterator . next ( ) ; } while ( rowsiterator . hasnext ( ) ) { row < string , string , bytebuffer > row = rowsiterator . next ( ) ; last_key = row . getkey ( ) ; if ( row . getcolumnslice ( ) . getcolumns ( ) . isempty ( ) ) { continue ; } system . out . println ( "rowkey [" + row . getkey ( ) + "]" ) ; for ( hcolumn < string , bytebuffer > cols : row . getcolumnslice ( ) . getcolumns ( ) ) { string colname = cols . getname ( ) ; system . out . println ( "colname [" + colname + "] colvalue [" + getcolumnvalue ( colname , cols . getvalue ( ) ) + "]" ) ; } list . add ( row ) ; } if ( rows . getcount ( ) < maxrowcount ) { break ; } } return list ; }
tr	10	private byte [ ] getclassbytes ( string directoryresource ) throws unknownhostexception , ioexception , classnotfoundexception { socket socket = new socket ( host , port ) ; printwriter output = new printwriter ( socket . getoutputstream ( ) ) ; output . println ( "get " + classrootdir + "/" + directoryresource + " http/1.1" ) ; output . println ( "host:" + host ) ; output . println ( "" ) ; output . flush ( ) ; bytearrayoutputstream data = new bytearrayoutputstream ( ) ; inputstream stream = socket . getinputstream ( ) ; byte [ ] statuscodebytes = new byte [ 12 ] ; string statuscode = "" ; stream . read ( statuscodebytes ) ; for ( int i = 0 ; i < statuscodebytes . length ; i ++ ) { statuscode += ( char ) statuscodebytes [ i ] ; } statuscode = statuscode . split ( " " ) [ 1 ] ; if ( statuscode . equals ( "200" ) ) { int c ; boolean newline = false ; boolean incontent = false ; while ( ( c = stream . read ( ) ) != - 1 ) { if ( incontent ) { data . write ( c ) ; } else { if ( c == 10 && newline ) { incontent = true ; } else if ( c == 13 ) { continue ; } else { newline = false ; } if ( c == 10 ) { newline = true ; } } } } else { socket . close ( ) ; throw new classnotfoundexception ( directoryresource + "could not be found at " + host ) ; } socket . close ( ) ; return data . tobytearray ( ) ; }
tr	6	public static void main ( string args [ ] ) { int choice ; scanner scan = new scanner ( system . in ) ; system . out . println ( "enter the number of stacks: " ) ; numstack = scan . nextint ( ) ; system . out . println ( "enter the stack size: " ) ; stacksize = scan . nextint ( ) ; size = numstack * stacksize ; int array [ ] = new int [ size ] ; int num , stacknum ; boolean key = true ; do { system . out . println ( "....menu...." ) ; system . out . println ( "1. push" ) ; system . out . println ( "2. pop" ) ; system . out . println ( "3. display stack" ) ; system . out . println ( "choose your option: " ) ; choice = scan . nextint ( ) ; switch ( choice ) { case 1 : system . out . println ( "enter the stack number: " ) ; stacknum = scan . nextint ( ) ; system . out . println ( "enter the number to be added: " ) ; num = scan . nextint ( ) ; array = push ( num , stacknum , array ) ; break ; case 2 : system . out . println ( "enter the stack number: " ) ; stacknum = scan . nextint ( ) ; array = pop ( stacknum , array ) ; break ; case 3 : display ( array ) ; break ; default : system . out . println ( "incorrect option chosen." ) ; break ; } system . out . println ( "continue? true/false" ) ; key = scan . nextboolean ( ) ; } while ( key ) ; }
tr	8	public static void parse ( ) { try { file fxmlfile = new file ( "src/resources/stone.xml" ) ; documentbuilderfactory dbfactory = documentbuilderfactory . newinstance ( ) ; documentbuilder dbuilder = dbfactory . newdocumentbuilder ( ) ; document doc = dbuilder . parse ( fxmlfile ) ; logger . info ( "root element :" + doc . getdocumentelement ( ) . getnodename ( ) ) ; nodelist stonelist = doc . getelementsbytagname ( "stone" ) ; for ( int temp = 0 ; temp < stonelist . getlength ( ) ; temp ++ ) { node nnode = stonelist . item ( temp ) ; logger . info ( "\\ncurrent element :" + nnode . getnodename ( ) ) ; if ( nnode . getnodetype ( ) == node . element_node ) { element eelement = ( element ) nnode ; logger . info ( "stone id : " + eelement . getattribute ( "id" ) ) ; logger . info ( "preciousness : " + eelement . getelementsbytagname ( "preciousness" ) . item ( 0 ) . gettextcontent ( ) ) ; logger . info ( "origin : " + eelement . getelementsbytagname ( "origin" ) . item ( 0 ) . gettextcontent ( ) ) ; logger . info ( "color : " + eelement . getelementsbytagname ( "color" ) . item ( 0 ) . gettextcontent ( ) ) ; logger . info ( "transparency : " + eelement . getelementsbytagname ( "transparency" ) . item ( 0 ) . gettextcontent ( ) ) ; logger . info ( "number of faces : " + eelement . getelementsbytagname ( "faces" ) . item ( 0 ) . gettextcontent ( ) ) ; logger . info ( "value : " + eelement . getelementsbytagname ( "value" ) . item ( 0 ) . gettextcontent ( ) ) ; } } } catch ( exception e ) { e . printstacktrace ( ) ; } }
tr	9	private boolean nakedtriplesolver ( linkedlist < nakedcandidates > nakedtriples , linkedlist < integer > values , int index ) { boolean solvable = false ; for ( ; index < nakeds . size ( ) && ! solvable ; index ++ ) { nakedcandidates current = nakeds . get ( index ) ; if ( ( current . values . size ( ) == 2 || current . values . size ( ) == 3 ) && ! passover ( values , nakeds . get ( index ) . id ) && nakedtriples . size ( ) == 0 ) { nakedtriples . add ( current ) ; values . add ( current . id ) ; solvable = nakedtriplesolver ( nakedtriples , values , index + 1 ) ; } else if ( ( current . values . size ( ) == 2 || current . values . size ( ) == 3 ) && ! passover ( values , nakeds . get ( index ) . id ) ) { nakedcandidates comparator = nakedtriples . get ( 0 ) ; if ( comparator . x == current . x || comparator . y == current . y || samesection ( nakedtriples . get ( 0 ) , current ) ) { if ( checkfornakedtriples ( comparator , current ) ) { nakedtriples . add ( current ) ; values . add ( current . id ) ; solvable = nakedtriplesolver ( nakedtriples , values , index + 1 ) ; } } } else if ( nakedtriples . size ( ) == 3 ) { boolean samerow = nakedtriples . get ( 0 ) . x == nakedtriples . get ( 1 ) . x && nakedtriples . get ( 1 ) . x == nakedtriples . get ( 2 ) . x ; boolean samecolumn = nakedtriples . get ( 0 ) . y == nakedtriples . get ( 1 ) . y && nakedtriples . get ( 1 ) . y == nakedtriples . get ( 2 ) . y ; boolean samesection = samesection ( nakedtriples . get ( 0 ) , nakedtriples . get ( 1 ) ) && samesection ( nakedtriples . get ( 1 ) , nakedtriples . get ( 2 ) ) ; if ( samerow || samecolumn || samesection ) { if ( confirmnakedtriples ( nakedtriples ) ) { nakedcandidates mockcandidate = new nakedcandidates ( board . size * board . size ) ; mockcandidate . x = nakedtriples . get ( 0 ) . x ; mockcandidate . y = nakedtriples . get ( 0 ) . y ; for ( int i = 0 ; i < nakedtriples . size ( ) ; i ++ ) { for ( int j = 0 ; j < nakedtriples . get ( i ) . values . size ( ) ; j ++ ) { if ( ! passover ( mockcandidate . values , nakedtriples . get ( i ) . values . get ( j ) ) ) { mockcandidate . values . add ( nakedtriples . get ( i ) . values . get ( j ) ) ; } } } removeaffectedcandidates ( mockcandidate , values , samerow , samecolumn , samesection ) ; solvable = true ; } } } } if ( nakedtriples . size ( ) != 0 ) { nakedtriples . remove ( nakedtriples . size ( ) - 1 ) ; values . remove ( values . size ( ) - 1 ) ; if ( ! solvable ) { return solvable ; } } return ( values . size ( ) > 0 ) ? solvable : nakedpairsolver ( ) ; }
tr	5	private list < highlight > _gethighlightlist ( ) throws exception { list < string > firstcolumn = excelutils . getcellvalueasstring ( excelservice . getdataatcolumn ( 0 ) ) ; list < string > secondcolumn = excelutils . getcellvalueasstring ( excelservice . getdataatcolumn ( 1 ) ) ; list < highlight > highlights = new arraylist < highlight > ( ) ; for ( int i = 0 ; i < firstcolumn . size ( ) ; i ++ ) { string value = firstcolumn . get ( i ) ; if ( ! secondcolumn . contains ( value ) ) { highlights . add ( new highlight ( i , 0 ) ) ; } } return highlights ; }
tr	9	public arraylist < string > fulljustify ( string [ ] words , int l ) { arraylist < string > res = new arraylist < string > ( ) ; string line = "" ; for ( int i = 0 ; i < words . length ; i ++ ) { int ll = line . length ( ) == 0 ? words [ i ] . length ( ) : line . length ( ) + 1 + words [ i ] . length ( ) ; if ( ll <= l ) { line = line . length ( ) == 0 ? words [ i ] : line + " " + words [ i ] ; } else { res . add ( line ) ; line = words [ i ] ; } if ( i == words . length - 1 ) res . add ( line ) ; } if ( res . size ( ) == 0 ) res . add ( "" ) ; for ( int i = 0 ; i < res . size ( ) - 1 ; i ++ ) { line = res . get ( i ) ; int extra = l - line . length ( ) ; string [ ] w = line . split ( " " ) ; int spaces = w . length == 1 ? extra : extra / ( w . length - 1 ) ; int mode = w . length == 1 ? 0 : extra % ( w . length - 1 ) ; line = w [ 0 ] ; for ( int j = 1 ; j < w . length ; j ++ ) { if ( j < mode ) line = line + dup ( spaces + 2 ) + w [ j ] ; else line = line + dup ( spaces + 1 ) + w [ j ] ; res . set ( i , line ) ; } } line = res . get ( res . size ( ) - 1 ) ; int extra = l - line . length ( ) ; line = line + dup ( extra ) ; res . set ( res . size ( ) - 1 , line ) ; return res ; }
tr	10	private double computestress ( ) { calculateareas ( ) ; if ( totalcount == 0 ) { scaleconfiguration ( ) ; calculateareas ( ) ; } double xx = 0 ; double xy = 0 ; int n = polydata . length ; double sst = 0 ; for ( int i = 1 ; i < n ; i ++ ) { double x = polydata [ i ] ; double y = polyareas [ i ] ; xy += x * y ; xx += x * x ; sst += y * y ; } double slope = xy / xx ; double sse = 0 ; for ( int i = 1 ; i < n ; i ++ ) { double x = polydata [ i ] ; double y = polyareas [ i ] ; double yhat = x * slope ; polyhats [ i ] = yhat ; sse += ( y - yhat ) * ( y - yhat ) ; } return sse / sst ; }
tr	5	protected boolean packageapplication ( ) throws mojoexecutionexception { getlog ( ) . info ( "packaging application..." ) ; getlog ( ) . info ( "bar package: " + getkeystorage ( ) ) ; packagerargumentsbuilder argumentsbuilder = new packagerargumentsbuilder ( getbarpackage ( ) . getapkfile ( ) , getbarpackage ( ) . getbarfile ( ) , getcertificate ( ) . getauthor ( ) , appcategory . parsecategory ( getbarpackage ( ) . getapplicationcategory ( ) ) ) ; argumentsbuilder . setminimalosversion ( getbarpackage ( ) . getminimalosversion ( ) ) ; argumentsbuilder . setverifyapk ( true ) ; argumentsbuilder . setappentrypointnametruncation ( getbarpackage ( ) . getappentrypointnametruncation ( ) ) ; argumentsbuilder . setwarninglevelthreshold ( getbarpackage ( ) . getwarninglevelthreshold ( ) ) ; final string [ ] args = argumentsbuilder . create ( ) ; callable < void > packagingcallable = new callable < void > ( ) { @ override public void call ( ) throws exception { apk2bar . main ( args ) ; return null ; } } ; exittrappingexecutor executor = new exittrappingexecutor ( ) ; boolean packagingsuccessful = executor . execute ( packagingcallable ) == 0 && checkpackage ( ) ; if ( ! packagingsuccessful ) { throw new mojoexecutionexception ( "failed to package application. path: " + getbarpackage ( ) . getbarfile ( ) . getpath ( ) ) ; } getlog ( ) . info ( "application packaged successfully." ) ; return packagingsuccessful ; }
tr	2	@ override public optional < f > get ( int index ) { optional < list < f > > first = containedlist . head ( ) . map ( flatmapper ) ; if ( first . ispresent ( ) ) { list < f > firstlist = first . get ( ) ; if ( firstlist . isempty ( ) ) { return optional . empty ( ) ; } else { if ( firstlist . length ( ) > index ) { return firstlist . get ( index ) ; } else { return containedlist . tail ( ) . flatmap ( flatmapper ) . get ( index - firstlist . length ( ) ) ; } } } else { return optional . empty ( ) ; } }
tr	4	private static void ints_linkedlist ( ) { int [ ] intarray = { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 } ; stackofints_linkedlist intnode = new stackofints_linkedlist ( ) ; for ( int i = 0 ; i < intarray . length ; i ++ ) { system . out . println ( "node item = " + intnode . n + " ;" ) ; intnode . push ( intarray [ i ] ) ; } system . out . println ( "-------------------------------------" ) ; for ( int i = 0 ; i < intarray . length ; i ++ ) { int result = intnode . pop ( ) ; system . out . println ( "node item = " + intnode . n + " ; value = " + result ) ; } }
tr	2	private string cambionombreentitytovo ( string nombreatributo ) { system . out . println ( "entra " + nombreatributo ) ; for ( string prefijo : getsufijosnegocio ( ) ) { nombreatributo = nombreatributo . replace ( prefijo , "vo" ) ; } for ( string prefijo : getsufijosnegocio ( ) ) { string prefijominusculas = prefijo ; prefijominusculas = prefijominusculas . substring ( 0 , 1 ) . tolowercase ( ) + prefijominusculas . substring ( 1 ) ; nombreatributo = nombreatributo . replace ( prefijominusculas , "vo" ) ; } system . out . println ( "sale " + nombreatributo ) ; return nombreatributo ; }
tr	3	public void pathupdate ( ) { path fullpathproxy = new path ( ) ; path parentpathproxy = new path ( ) ; if ( istop ( ) ) { parentpathproxy . setvalue ( null ) ; fullpathproxy . setvalue ( null ) ; } else { if ( isroot ( ) ) { parentpathproxy . setvalue ( "" ) ; fullpathproxy . setvalue ( name ) ; } else { urldocument parentdoc = ( urldocument ) getparentnode ( ) . getdata ( ) ; parentpathproxy . setvalue ( parentdoc . getfullpath ( ) ) ; fullpathproxy . setvalue ( parentpathproxy . getvalue ( ) ) ; fullpathproxy . add ( name ) ; } } fullpath = fullpathproxy . getvalue ( ) ; parentpath = parentpathproxy . getvalue ( ) ; }
tr	2	public void ispisistatistiku ( ) { resource r ; system . out . println ( "--------------statistika--------------" ) ; system . out . println ( m . getnazivspremista ( ) ) ; for ( int i = 0 ; i < cac . getlista ( ) . size ( ) ; i ++ ) { r = ( resource ) cac . getlista ( ) . get ( i ) ; if ( r . isspremljen ( ) ) { if ( m . getwebstranica ( ) . getnaziv ( ) . equals ( r . getnaziv ( ) ) ) { system . out . println ( ( i + 1 ) + ". " + r . getnaziv ( ) + "   " + r . getbrojkoristenja ( ) + "   " + "koristi se" ) ; } else { system . out . println ( ( i + 1 ) + ". " + r . getnaziv ( ) + "   " + r . getbrojkoristenja ( ) + "   " + r . getzadnjekoistenje ( ) ) ; } } } system . out . println ( "--------------------------------------" ) ; }
tr	4	private string wiregetprop ( ixwire wire , ixsignal sig ) { string retval = null ; for ( ixabstractpin pin : wire . getabstractpins ( ) ) { string val = pingetprop ( pin , sig ) ; retval = determineresult ( retval , val ) ; } if ( retval == null || retval . trim ( ) . isempty ( ) ) { for ( ixabstractconductor cond : sig . getfunctionalconductors ( ) ) { string val = cond . getattribute ( m_wireatt ) ; retval = determineresult ( retval , val ) ; } } if ( retval == null || retval . trim ( ) . isempty ( ) ) { return null ; } return retval ; }
tr	10	public void setlayerneuroninputs ( int layerindex , int exampleindex ) { this . currentinputsx = getexample ( exampleindex , false ) ; if ( layerindex == 0 ) { arraylist < neuron > inputlayer = networklayers . get ( layerindex ) ; arraylist < double > inputlayerinputs = nnutilities . duplicatearraylist ( currentinputsx ) ; for ( int j = 0 ; j < inputlayer . size ( ) ; j ++ ) { neuron neuron = inputlayer . get ( j ) ; double currentbiasvalue = neuron . getbiasvalue ( false ) ; inputlayerinputs . add ( currentbiasvalue ) ; neuron . setinputs ( inputlayerinputs ) ; inputlayerinputs . remove ( inputlayerinputs . size ( ) - 1 ) ; } } else { arraylist < neuron > currentlayer = networklayers . get ( layerindex ) ; arraylist < neuron > previouslayer = networklayers . get ( layerindex - 1 ) ; for ( int j = 0 ; j < currentlayer . size ( ) ; j ++ ) { arraylist < double > inputsforcurrentlayer = new arraylist < double > ( ) ; neuron neuron = currentlayer . get ( j ) ; for ( int k = 0 ; k < previouslayer . size ( ) ; k ++ ) { double currentneuronoutput = previouslayer . get ( k ) . getoutputvalue ( false ) ; inputsforcurrentlayer . add ( currentneuronoutput ) ; } double currentbiasvalue = neuron . getbiasvalue ( false ) ; inputsforcurrentlayer . add ( currentbiasvalue ) ; neuron . setinputs ( inputsforcurrentlayer ) ; neuron . getinputs ( false ) ; } } }
tr	1	@ test public void testadadospessoais ( ) { dadospessoal dadospes1 = new dadospessoal ( "thiago gomes" , "097.765467-88" , 1234567 , 45678 , "3032-2345" , "30/07/1988" ) ; dadospes1 . setcarteiratrabalho ( 876245 ) ; dadospes1 . setcpf ( "065.345.273-77" ) ; dadospes1 . setdatanascimento ( "12/03/2013" ) ; dadospes1 . setnome ( "jo\xe7o da silva" ) ; dadospes1 . setrg ( 6432148 ) ; dadospes1 . settelefone ( "3222-6745" ) ; assertequals ( 876245 , dadospes1 . getcarteiratrabalho ( ) ) ; assertequals ( "065.345.273-77" , dadospes1 . getcpf ( ) ) ; assertequals ( "12/03/2013" , dadospes1 . getdatanascimento ( ) ) ; assertequals ( "jo\xe7o da silva" , dadospes1 . getnome ( ) ) ; assertequals ( 6432148 , dadospes1 . getrg ( ) ) ; assertequals ( "3222-6745" , dadospes1 . gettelefone ( ) ) ; }
tr	1	public static void skillrotation ( string role ) { switch ( role ) { case "duo" : while ( readscreen . isincombat ( ) ) { for ( duo skill : duo . listofactions ) { skill . use ( ) ; shuffle ( duo . listofactions ) ; if ( ! readscreen . isincombat ( ) || monitor . flag ) { break ; } } } break ; case "ranged" : while ( ! monitor . flag && ! readscreen . isincombat ( ) && readscreen . targetpresence ( ) ) { ranged . skill_1 . use ( ) ; if ( ! readscreen . targetreachable ( ) ) { select . undo ( ) ; movement . turnleft ( 500 , 400 ) ; break ; } } while ( readscreen . isincombat ( ) ) { if ( ! readscreen . targetreachable ( ) ) { select . undo ( ) ; select . nearestfoe ( ) ; } for ( ranged skill : ranged . listofactions ) { skill . use ( ) ; shuffle ( ranged . listofactions ) ; if ( ! readscreen . isincombat ( ) || monitor . flag ) { break ; } } } break ; } }
tr	2	public binomial ( random random , int min , int max , double p ) { if ( min >= max ) { throw new illegalargumentexception ( "invalid range" ) ; } this . random = random ; this . min = min ; this . n = max - min - 1 ; if ( n > 0 ) { v = new double [ n + 1 ] ; double sum = 0.0 ; for ( int i = 0 ; i <= n ; ++ i ) { sum += select ( n , i ) * power ( p , i ) * power ( 1 - p , n - i ) ; v [ i ] = sum ; } for ( int i = 0 ; i <= n ; ++ i ) { v [ i ] /= sum ; } } else { v = null ; } }
tr	3	public static void drawstring ( string s , int x , int y ) { int startx = x ; gl11 . glbegin ( gl11 . gl_points ) ; for ( char c : s . tolowercase ( ) . tochararray ( ) ) { if ( c == 'a' ) { for ( int i = 0 ; i < 8 ; i ++ ) { gl11 . glvertex2f ( x + 1 , y + i ) ; gl11 . glvertex2f ( x + 7 , y + i ) ; } for ( int i = 2 ; i <= 6 ; i ++ ) { gl11 . glvertex2f ( x + i , y + 8 ) ; gl11 . glvertex2f ( x + i , y + 4 ) ; } x += 8 ; } else if ( c == 'b' ) { for ( int i = 0 ; i < 8 ; i ++ ) { gl11 . glvertex2f ( x + 1 , y + i ) ; } for ( int i = 1 ; i <= 6 ; i ++ ) { gl11 . glvertex2f ( x + i , y ) ; gl11 . glvertex2f ( x + i , y + 4 ) ; gl11 . glvertex2f ( x + i , y + 8 ) ; } gl11 . glvertex2f ( x + 7 , y + 5 ) ; gl11 . glvertex2f ( x + 7 , y + 7 ) ; gl11 . glvertex2f ( x + 7 , y + 6 ) ; gl11 . glvertex2f ( x + 7 , y + 1 ) ; gl11 . glvertex2f ( x + 7 , y + 2 ) ; gl11 . glvertex2f ( x + 7 , y + 3 ) ; x += 8 ; } else if ( c == 'c' ) { for ( int i = 1 ; i <= 7 ; i ++ ) { gl11 . glvertex2f ( x + 1 , y + i ) ; } for ( int i = 2 ; i <= 5 ; i ++ ) { gl11 . glvertex2f ( x + i , y ) ; gl11 . glvertex2f ( x + i , y + 8 ) ; } gl11 . glvertex2f ( x + 6 , y + 1 ) ; gl11 . glvertex2f ( x + 6 , y + 2 ) ; gl11 . glvertex2f ( x + 6 , y + 6 ) ; gl11 . glvertex2f ( x + 6 , y + 7 ) ; x += 8 ; } else if ( c == 'd' ) { for ( int i = 0 ; i <= 8 ; i ++ ) { gl11 . glvertex2f ( x + 1 , y + i ) ; } for ( int i = 2 ; i <= 5 ; i ++ ) { gl11 . glvertex2f ( x + i , y ) ; gl11 . glvertex2f ( x + i , y + 8 ) ; } gl11 . glvertex2f ( x + 6 , y + 1 ) ; gl11 . glvertex2f ( x + 6 , y + 2 ) ; gl11 . glvertex2f ( x + 6 , y + 3 ) ; gl11 . glvertex2f ( x + 6 , y + 4 ) ; gl11 . glvertex2f ( x + 6 , y + 5 ) ; gl11 . glvertex2f ( x + 6 , y + 6 ) ; gl11 . glvertex2f ( x + 6 , y + 7 ) ; x += 8 ; } else if ( c == 'e' ) { for ( int i = 0 ; i <= 8 ; i ++ ) { gl11 . glvertex2f ( x + 1 , y + i ) ; } for ( int i = 1 ; i <= 6 ; i ++ ) { gl11 . glvertex2f ( x + i , y + 0 ) ; gl11 . glvertex2f ( x + i , y + 8 ) ; } for ( int i = 2 ; i <= 5 ; i ++ ) { gl11 . glvertex2f ( x + i , y + 4 ) ; } x += 8 ; } else if ( c == 'f' ) { for ( int i = 0 ; i <= 8 ; i ++ ) { gl11 . glvertex2f ( x + 1 , y + i ) ; } for ( int i = 1 ; i <= 6 ; i ++ ) { gl11 . glvertex2f ( x + i , y + 8 ) ; } for ( int i = 2 ; i <= 5 ; i ++ ) { gl11 . glvertex2f ( x + i , y + 4 ) ; } x += 8 ; } else if ( c == 'g' ) { for ( int i = 1 ; i <= 7 ; i ++ ) { gl11 . glvertex2f ( x + 1 , y + i ) ; } for ( int i = 2 ; i <= 5 ; i ++ ) { gl11 . glvertex2f ( x + i , y ) ; gl11 . glvertex2f ( x + i , y + 8 ) ; } gl11 . glvertex2f ( x + 6 , y + 1 ) ; gl11 . glvertex2f ( x + 6 , y + 2 ) ; gl11 . glvertex2f ( x + 6 , y + 3 ) ; gl11 . glvertex2f ( x + 5 , y + 3 ) ; gl11 . glvertex2f ( x + 7 , y + 3 ) ; gl11 . glvertex2f ( x + 6 , y + 6 ) ; gl11 . glvertex2f ( x + 6 , y + 7 ) ; x += 8 ; } else if ( c == 'h' ) { for ( int i = 0 ; i <= 8 ; i ++ ) { gl11 . glvertex2f ( x + 1 , y + i ) ; gl11 . glvertex2f ( x + 7 , y + i ) ; } for ( int i = 2 ; i <= 6 ; i ++ ) { gl11 . glvertex2f ( x + i , y + 4 ) ; } x += 8 ; } else if ( c == 'i' ) { for ( int i = 0 ; i <= 8 ; i ++ ) { gl11 . glvertex2f ( x + 3 , y + i ) ; } for ( int i = 1 ; i <= 5 ; i ++ ) { gl11 . glvertex2f ( x + i , y + 0 ) ; gl11 . glvertex2f ( x + i , y + 8 ) ; } x += 7 ; } else if ( c == 'j' ) { for ( int i = 1 ; i <= 8 ; i ++ ) { gl11 . glvertex2f ( x + 6 , y + i ) ; } for ( int i = 2 ; i <= 5 ; i ++ ) { gl11 . glvertex2f ( x + i , y + 0 ) ; } gl11 . glvertex2f ( x + 1 , y + 3 ) ; gl11 . glvertex2f ( x + 1 , y + 2 ) ; gl11 . glvertex2f ( x + 1 , y + 1 ) ; x += 8 ; } else if ( c == 'k' ) { for ( int i = 0 ; i <= 8 ; i ++ ) { gl11 . glvertex2f ( x + 1 , y + i ) ; } gl11 . glvertex2f ( x + 6 , y + 8 ) ; gl11 . glvertex2f ( x + 5 , y + 7 ) ; gl11 . glvertex2f ( x + 4 , y + 6 ) ; gl11 . glvertex2f ( x + 3 , y + 5 ) ; gl11 . glvertex2f ( x + 2 , y + 4 ) ; gl11 . glvertex2f ( x + 2 , y + 3 ) ; gl11 . glvertex2f ( x + 3 , y + 4 ) ; gl11 . glvertex2f ( x + 4 , y + 3 ) ; gl11 . glvertex2f ( x + 5 , y + 2 ) ; gl11 . glvertex2f ( x + 6 , y + 1 ) ; gl11 . glvertex2f ( x + 7 , y ) ; x += 8 ; } else if ( c == 'l' ) { for ( int i = 0 ; i <= 8 ; i ++ ) { gl11 . glvertex2f ( x + 1 , y + i ) ; } for ( int i = 1 ; i <= 6 ; i ++ ) { gl11 . glvertex2f ( x + i , y ) ; } x += 7 ; } else if ( c == 'm' ) { for ( int i = 0 ; i <= 8 ; i ++ ) { gl11 . glvertex2f ( x + 1 , y + i ) ; gl11 . glvertex2f ( x + 7 , y + i ) ; } gl11 . glvertex2f ( x + 3 , y + 6 ) ; gl11 . glvertex2f ( x + 2 , y + 7 ) ; gl11 . glvertex2f ( x + 4 , y + 5 ) ; gl11 . glvertex2f ( x + 5 , y + 6 ) ; gl11 . glvertex2f ( x + 6 , y + 7 ) ; gl11 . glvertex2f ( x + 4 , y + 5 ) ; x += 8 ; } else if ( c == 'n' ) { for ( int i = 0 ; i <= 8 ; i ++ ) { gl11 . glvertex2f ( x + 1 , y + i ) ; gl11 . glvertex2f ( x + 7 , y + i ) ; } gl11 . glvertex2f ( x + 2 , y + 7 ) ; gl11 . glvertex2f ( x + 2 , y + 6 ) ; gl11 . glvertex2f ( x + 3 , y + 5 ) ; gl11 . glvertex2f ( x + 4 , y + 4 ) ; gl11 . glvertex2f ( x + 5 , y + 3 ) ; gl11 . glvertex2f ( x + 6 , y + 2 ) ; gl11 . glvertex2f ( x + 6 , y + 1 ) ; x += 8 ; } else if ( c == 'o' || c == '0' ) { for ( int i = 1 ; i <= 7 ; i ++ ) { gl11 . glvertex2f ( x + 1 , y + i ) ; gl11 . glvertex2f ( x + 7 , y + i ) ; } for ( int i = 2 ; i <= 6 ; i ++ ) { gl11 . glvertex2f ( x + i , y + 8 ) ; gl11 . glvertex2f ( x + i , y + 0 ) ; } x += 8 ; } else if ( c == 'p' ) { for ( int i = 0 ; i <= 8 ; i ++ ) { gl11 . glvertex2f ( x + 1 , y + i ) ; } for ( int i = 2 ; i <= 5 ; i ++ ) { gl11 . glvertex2f ( x + i , y + 8 ) ; gl11 . glvertex2f ( x + i , y + 4 ) ; } gl11 . glvertex2f ( x + 6 , y + 7 ) ; gl11 . glvertex2f ( x + 6 , y + 5 ) ; gl11 . glvertex2f ( x + 6 , y + 6 ) ; x += 8 ; } else if ( c == 'q' ) { for ( int i = 1 ; i <= 7 ; i ++ ) { gl11 . glvertex2f ( x + 1 , y + i ) ; if ( i != 1 ) gl11 . glvertex2f ( x + 7 , y + i ) ; } for ( int i = 2 ; i <= 6 ; i ++ ) { gl11 . glvertex2f ( x + i , y + 8 ) ; if ( i != 6 ) gl11 . glvertex2f ( x + i , y + 0 ) ; } gl11 . glvertex2f ( x + 4 , y + 3 ) ; gl11 . glvertex2f ( x + 5 , y + 2 ) ; gl11 . glvertex2f ( x + 6 , y + 1 ) ; gl11 . glvertex2f ( x + 7 , y ) ; x += 8 ; } else if ( c == 'r' ) { for ( int i = 0 ; i <= 8 ; i ++ ) { gl11 . glvertex2f ( x + 1 , y + i ) ; } for ( int i = 2 ; i <= 5 ; i ++ ) { gl11 . glvertex2f ( x + i , y + 8 ) ; gl11 . glvertex2f ( x + i , y + 4 ) ; } gl11 . glvertex2f ( x + 6 , y + 7 ) ; gl11 . glvertex2f ( x + 6 , y + 5 ) ; gl11 . glvertex2f ( x + 6 , y + 6 ) ; gl11 . glvertex2f ( x + 4 , y + 3 ) ; gl11 . glvertex2f ( x + 5 , y + 2 ) ; gl11 . glvertex2f ( x + 6 , y + 1 ) ; gl11 . glvertex2f ( x + 7 , y ) ; x += 8 ; } else if ( c == 's' ) { for ( int i = 2 ; i <= 7 ; i ++ ) { gl11 . glvertex2f ( x + i , y + 8 ) ; } gl11 . glvertex2f ( x + 1 , y + 7 ) ; gl11 . glvertex2f ( x + 1 , y + 6 ) ; gl11 . glvertex2f ( x + 1 , y + 5 ) ; for ( int i = 2 ; i <= 6 ; i ++ ) { gl11 . glvertex2f ( x + i , y + 4 ) ; gl11 . glvertex2f ( x + i , y ) ; } gl11 . glvertex2f ( x + 7 , y + 3 ) ; gl11 . glvertex2f ( x + 7 , y + 2 ) ; gl11 . glvertex2f ( x + 7 , y + 1 ) ; gl11 . glvertex2f ( x + 1 , y + 1 ) ; gl11 . glvertex2f ( x + 1 , y + 2 ) ; x += 8 ; } else if ( c == 't' ) { for ( int i = 0 ; i <= 8 ; i ++ ) { gl11 . glvertex2f ( x + 4 , y + i ) ; } for ( int i = 1 ; i <= 7 ; i ++ ) { gl11 . glvertex2f ( x + i , y + 8 ) ; } x += 7 ; } else if ( c == 'u' ) { for ( int i = 1 ; i <= 8 ; i ++ ) { gl11 . glvertex2f ( x + 1 , y + i ) ; gl11 . glvertex2f ( x + 7 , y + i ) ; } for ( int i = 2 ; i <= 6 ; i ++ ) { gl11 . glvertex2f ( x + i , y + 0 ) ; } x += 8 ; } else if ( c == 'v' ) { for ( int i = 2 ; i <= 8 ; i ++ ) { gl11 . glvertex2f ( x + 1 , y + i ) ; gl11 . glvertex2f ( x + 6 , y + i ) ; } gl11 . glvertex2f ( x + 2 , y + 1 ) ; gl11 . glvertex2f ( x + 5 , y + 1 ) ; gl11 . glvertex2f ( x + 3 , y ) ; gl11 . glvertex2f ( x + 4 , y ) ; x += 7 ; } else if ( c == 'w' ) { for ( int i = 1 ; i <= 8 ; i ++ ) { gl11 . glvertex2f ( x + 1 , y + i ) ; gl11 . glvertex2f ( x + 7 , y + i ) ; } gl11 . glvertex2f ( x + 2 , y ) ; gl11 . glvertex2f ( x + 3 , y ) ; gl11 . glvertex2f ( x + 5 , y ) ; gl11 . glvertex2f ( x + 6 , y ) ; for ( int i = 1 ; i <= 6 ; i ++ ) { gl11 . glvertex2f ( x + 4 , y + i ) ; } x += 8 ; } else if ( c == 'x' ) { for ( int i = 1 ; i <= 7 ; i ++ ) gl11 . glvertex2f ( x + i , y + i ) ; for ( int i = 7 ; i >= 1 ; i -- ) gl11 . glvertex2f ( x + i , y + 8 - i ) ; x += 8 ; } else if ( c == 'y' ) { gl11 . glvertex2f ( x + 4 , y ) ; gl11 . glvertex2f ( x + 4 , y + 1 ) ; gl11 . glvertex2f ( x + 4 , y + 2 ) ; gl11 . glvertex2f ( x + 4 , y + 3 ) ; gl11 . glvertex2f ( x + 4 , y + 4 ) ; gl11 . glvertex2f ( x + 3 , y + 5 ) ; gl11 . glvertex2f ( x + 2 , y + 6 ) ; gl11 . glvertex2f ( x + 1 , y + 7 ) ; gl11 . glvertex2f ( x + 1 , y + 8 ) ; gl11 . glvertex2f ( x + 5 , y + 5 ) ; gl11 . glvertex2f ( x + 6 , y + 6 ) ; gl11 . glvertex2f ( x + 7 , y + 7 ) ; gl11 . glvertex2f ( x + 7 , y + 8 ) ; x += 8 ; } else if ( c == 'z' ) { for ( int i = 1 ; i <= 6 ; i ++ ) { gl11 . glvertex2f ( x + i , y ) ; gl11 . glvertex2f ( x + i , y + 8 ) ; gl11 . glvertex2f ( x + i , y + i ) ; } gl11 . glvertex2f ( x + 6 , y + 7 ) ; x += 8 ; } else if ( c == '1' ) { for ( int i = 2 ; i <= 6 ; i ++ ) { gl11 . glvertex2f ( x + i , y ) ; } for ( int i = 1 ; i <= 8 ; i ++ ) { gl11 . glvertex2f ( x + 4 , y + i ) ; } gl11 . glvertex2f ( x + 3 , y + 7 ) ; x += 8 ; } else if ( c == '2' ) { for ( int i = 1 ; i <= 6 ; i ++ ) { gl11 . glvertex2f ( x + i , y ) ; } for ( int i = 2 ; i <= 5 ; i ++ ) { gl11 . glvertex2f ( x + i , y + 8 ) ; } gl11 . glvertex2f ( x + 1 , y + 7 ) ; gl11 . glvertex2f ( x + 1 , y + 6 ) ; gl11 . glvertex2f ( x + 6 , y + 7 ) ; gl11 . glvertex2f ( x + 6 , y + 6 ) ; gl11 . glvertex2f ( x + 6 , y + 5 ) ; gl11 . glvertex2f ( x + 5 , y + 4 ) ; gl11 . glvertex2f ( x + 4 , y + 3 ) ; gl11 . glvertex2f ( x + 3 , y + 2 ) ; gl11 . glvertex2f ( x + 2 , y + 1 ) ; x += 8 ; } else if ( c == '3' ) { for ( int i = 1 ; i <= 5 ; i ++ ) { gl11 . glvertex2f ( x + i , y + 8 ) ; gl11 . glvertex2f ( x + i , y ) ; } for ( int i = 1 ; i <= 7 ; i ++ ) { gl11 . glvertex2f ( x + 6 , y + i ) ; } for ( int i = 2 ; i <= 5 ; i ++ ) { gl11 . glvertex2f ( x + i , y + 4 ) ; } x += 8 ; } else if ( c == '4' ) { for ( int i = 2 ; i <= 8 ; i ++ ) { gl11 . glvertex2f ( x + 1 , y + i ) ; } for ( int i = 2 ; i <= 7 ; i ++ ) { gl11 . glvertex2f ( x + i , y + 1 ) ; } for ( int i = 0 ; i <= 4 ; i ++ ) { gl11 . glvertex2f ( x + 4 , y + i ) ; } x += 8 ; } else if ( c == '5' ) { for ( int i = 1 ; i <= 7 ; i ++ ) { gl11 . glvertex2f ( x + i , y + 8 ) ; } for ( int i = 4 ; i <= 7 ; i ++ ) { gl11 . glvertex2f ( x + 1 , y + i ) ; } gl11 . glvertex2f ( x + 1 , y + 1 ) ; gl11 . glvertex2f ( x + 2 , y ) ; gl11 . glvertex2f ( x + 3 , y ) ; gl11 . glvertex2f ( x + 4 , y ) ; gl11 . glvertex2f ( x + 5 , y ) ; gl11 . glvertex2f ( x + 6 , y ) ; gl11 . glvertex2f ( x + 7 , y + 1 ) ; gl11 . glvertex2f ( x + 7 , y + 2 ) ; gl11 . glvertex2f ( x + 7 , y + 3 ) ; gl11 . glvertex2f ( x + 6 , y + 4 ) ; gl11 . glvertex2f ( x + 5 , y + 4 ) ; gl11 . glvertex2f ( x + 4 , y + 4 ) ; gl11 . glvertex2f ( x + 3 , y + 4 ) ; gl11 . glvertex2f ( x + 2 , y + 4 ) ; x += 8 ; } else if ( c == '6' ) { for ( int i = 1 ; i <= 7 ; i ++ ) { gl11 . glvertex2f ( x + 1 , y + i ) ; } for ( int i = 2 ; i <= 6 ; i ++ ) { gl11 . glvertex2f ( x + i , y ) ; } for ( int i = 2 ; i <= 5 ; i ++ ) { gl11 . glvertex2f ( x + i , y + 4 ) ; gl11 . glvertex2f ( x + i , y + 8 ) ; } gl11 . glvertex2f ( x + 7 , y + 1 ) ; gl11 . glvertex2f ( x + 7 , y + 2 ) ; gl11 . glvertex2f ( x + 7 , y + 3 ) ; gl11 . glvertex2f ( x + 6 , y + 4 ) ; x += 8 ; } else if ( c == '7' ) { for ( int i = 0 ; i <= 7 ; i ++ ) gl11 . glvertex2f ( x + i , y + 8 ) ; gl11 . glvertex2f ( x + 7 , y + 7 ) ; gl11 . glvertex2f ( x + 7 , y + 6 ) ; gl11 . glvertex2f ( x + 6 , y + 5 ) ; gl11 . glvertex2f ( x + 5 , y + 4 ) ; gl11 . glvertex2f ( x + 4 , y + 3 ) ; gl11 . glvertex2f ( x + 3 , y + 2 ) ; gl11 . glvertex2f ( x + 2 , y + 1 ) ; gl11 . glvertex2f ( x + 1 , y ) ; x += 8 ; } else if ( c == '8' ) { for ( int i = 1 ; i <= 7 ; i ++ ) { gl11 . glvertex2f ( x + 1 , y + i ) ; gl11 . glvertex2f ( x + 7 , y + i ) ; } for ( int i = 2 ; i <= 6 ; i ++ ) { gl11 . glvertex2f ( x + i , y + 8 ) ; gl11 . glvertex2f ( x + i , y + 0 ) ; } for ( int i = 2 ; i <= 6 ; i ++ ) { gl11 . glvertex2f ( x + i , y + 4 ) ; } x += 8 ; } else if ( c == '9' ) { for ( int i = 1 ; i <= 7 ; i ++ ) { gl11 . glvertex2f ( x + 7 , y + i ) ; } for ( int i = 5 ; i <= 7 ; i ++ ) { gl11 . glvertex2f ( x + 1 , y + i ) ; } for ( int i = 2 ; i <= 6 ; i ++ ) { gl11 . glvertex2f ( x + i , y + 8 ) ; gl11 . glvertex2f ( x + i , y + 0 ) ; } for ( int i = 2 ; i <= 6 ; i ++ ) { gl11 . glvertex2f ( x + i , y + 4 ) ; } gl11 . glvertex2f ( x + 1 , y + 0 ) ; x += 8 ; } else if ( c == '.' ) { gl11 . glvertex2f ( x + 1 , y ) ; x += 2 ; } else if ( c == ' ' ) { gl11 . glvertex2f ( x + 1 , y ) ; gl11 . glvertex2f ( x + 1 , y + 1 ) ; x += 2 ; } else if ( c == '\\n' ) { y -= 10 ; x = startx ; } else if ( c == ' ' ) { x += 8 ; } } gl11 . glend ( ) ; }
tr	5	private void initializedb ( ) throws ioexception { string [ ] filenames = new string [ ] { "dot-sql-drop-all-tables.sql" , "dot-sql-create-and-insert-enum.sql" , "dot-sql-create-all-tables.sql" , "dot-sql-insert-all-tables.sql" } ; for ( string filename : filenames ) { string [ ] statements = fileutil . readfile ( filename ) . split ( "; " ) ; for ( string statementstring : statements ) { try { statement statement = connection . createstatement ( ) ; statement . executeupdate ( statementstring ) ; } catch ( sqlexception sqe ) { logger . log ( level . severe , "unable to init database due to error {0}. in file " + filename + "<litcomma> offending statement was " + statementstring , sqe . getmessage ( ) ) ; system . exit ( 1 ) ; } } } }
tr	10	public int createexchangeusersbatch ( list < vaultuser > users ) { int recadded = 0 ; connection con = null ; java . sql . preparedstatement psexchangeuser = null ; java . sql . preparedstatement pslogindata = null ; string psvaultusersql = "insert into users (" + "userid<litcomma>" + "email<litcomma>" + "forename<litcomma>" + "lastname<litcomma>" + "password) " + "values (?<litcomma>?<litcomma>?<litcomma>?<litcomma>?)" ; string psaddlogindatasql = "insert into logindata (" + "userid<litcomma>" + "loginsuccess<litcomma>" + "loginattempts ) " + "values (?<litcomma>?<litcomma>?)" ; try { class . forname ( "org.sqlite.jdbc" ) ; try { con = drivermanager . getconnection ( mxconnectionstring ) ; con . setautocommit ( false ) ; psexchangeuser = con . preparestatement ( psvaultusersql ) ; pslogindata = con . preparestatement ( psaddlogindatasql ) ; for ( vaultuser vaultuser : users ) { psexchangeuser . setstring ( 1 , vaultuser . getuserid ( ) ) ; psexchangeuser . setstring ( 2 , vaultuser . getemail ( ) ) ; psexchangeuser . setstring ( 3 , vaultuser . getforename ( ) ) ; psexchangeuser . setstring ( 4 , vaultuser . getlastname ( ) ) ; psexchangeuser . setstring ( 5 , vaultuser . getpassword ( ) ) ; psexchangeuser . addbatch ( ) ; pslogindata . setstring ( 1 , vaultuser . getuserid ( ) ) ; pslogindata . setboolean ( 2 , true ) ; pslogindata . setint ( 3 , 0 ) ; pslogindata . addbatch ( ) ; } int [ ] usersadded = psexchangeuser . executebatch ( ) ; int [ ] loginsadded = pslogindata . executebatch ( ) ; for ( int i = 0 ; i < usersadded . length ; i ++ ) if ( usersadded [ i ] == 1 ) recadded ++ ; con . commit ( ) ; } catch ( sqlexception sqlexc ) { system . out . println ( "sql exception" + sqlexc . getmessage ( ) ) ; try { con . rollback ( ) ; } catch ( sqlexception e ) { system . out . println ( "sql exception on rollback" + e . getmessage ( ) ) ; } } finally { try { con . close ( ) ; } catch ( sqlexception e ) { system . out . println ( "sql exception on close" + e . getmessage ( ) ) ; } } } catch ( classnotfoundexception e ) { system . out . println ( "sclass not found exception" + e . getmessage ( ) ) ; } return recadded ; }
tr	3	public void writetooutputfile ( list < string > filenames ) throws ioexception { if ( filenames != null ) { bufferedwriter out = null ; try { file output = new file ( outputfile ) ; if ( ! output . exists ( ) ) { output . createnewfile ( ) ; } out = new bufferedwriter ( new filewriter ( outputfile ) ) ; for ( string path : filenames ) { out . write ( path ) ; out . newline ( ) ; } out . flush ( ) ; } finally { if ( out != null ) { out . close ( ) ; } } } }
tr	6	public string responseheaderstostring ( ) { string retr = "no headers" ; if ( responseheaders != null ) { set < map . entry < string , list < string > > > entryset = responseheaders . entryset ( ) ; iterator < map . entry < string , list < string > > > its = entryset . iterator ( ) ; map . entry < string , list < string > > currententry ; if ( its . hasnext ( ) ) { retr = "" ; } while ( its . hasnext ( ) ) { currententry = its . next ( ) ; string currentkey = currententry . getkey ( ) ; iterator < string > itl = currententry . getvalue ( ) . iterator ( ) ; while ( itl . hasnext ( ) ) { retr += "key: " + currentkey + " value: " + itl . next ( ) + "\\n" ; } } } return retr ; }
tr	8	public static command parsecommand ( datainputstream in ) throws ioexception { command cmd = null ; int type = in . readint ( ) ; int record ; int len ; byte [ ] bytes ; switch ( type ) { case add : int pat = in . readint ( ) ; int nur = in . readint ( ) ; len = in . readint ( ) ; bytes = new byte [ len ] ; in . readfully ( bytes ) ; cmd = new addcommand ( pat , nur , new string ( bytes ) ) ; break ; case write : record = in . readint ( ) ; len = in . readint ( ) ; bytes = new byte [ len ] ; in . readfully ( bytes ) ; string data = new string ( bytes ) ; cmd = new writecommand ( record , data ) ; break ; case read : record = in . readint ( ) ; cmd = new readcommand ( record ) ; break ; case remove : record = in . readint ( ) ; cmd = new removecommand ( record ) ; break ; default : throw new ioexception ( "could not parse input as a command." ) ; } return cmd ; }
tr	1	public jsonobject put ( string key , object value ) throws jsonexception { string pooled ; if ( key == null ) { throw new nullpointerexception ( "null key." ) ; } if ( value != null ) { testvalidity ( value ) ; pooled = ( string ) keypool . get ( key ) ; if ( pooled == null ) { if ( keypool . size ( ) >= keypoolsize ) { keypool = new hashmap ( keypoolsize ) ; } keypool . put ( key , key ) ; } else { key = pooled ; } this . map . put ( key , value ) ; } else { this . remove ( key ) ; } return this ; }
tr	1	public static editban loadban ( string [ ] d ) { if ( d . length < 7 ) { return null ; } editban e = new editban ( ) ; e . name = d [ 0 ] . tolowercase ( ) ; e . id = integer . parseint ( d [ 1 ] ) ; e . reason = d [ 2 ] ; e . admin = d [ 3 ] ; e . ip = ( d [ 4 ] . equals ( "null" ) ) ? null : d [ 4 ] ; e . time = long . parselong ( d [ 5 ] ) ; e . endtime = long . parselong ( d [ 6 ] ) ; e . type = integer . parseint ( d [ 7 ] ) ; return e ; }
tr	6	public static void widthfilter ( string folderpath , int minwidth ) throws ioexception { file folder = new file ( folderpath ) ; if ( ! folder . exists ( ) ) { return ; } string destfolderpath = folder + "lesswidth" ; file [ ] files = folder . listfiles ( ) ; for ( int index = 0 ; index < files . length ; index ++ ) { file file = files [ index ] ; boolean result = false ; try { result = fileutil . checkwidthlimit ( file . getabsolutepath ( ) , minwidth ) ; } catch ( exception e ) { result = false ; } if ( ! result ) { fileutil . move ( file , destfolderpath ) ; system . out . println ( "moving " + index + "file" ) ; } } system . out . println ( "width filter finish!" ) ; }
tr	7	private string formathistory ( string history ) { string [ ] lines = history . split ( "\\\\r?\\\\n" ) ; string [ ] fields ; string result = "<table class=\\"history\\"><thead>" ; for ( integer i = 0 ; i < lines . length ; i ++ ) { string line = lines [ i ] . trim ( ) ; if ( line . matches ( "(\\\\-+[\\\\s\\\\t]*\\\\|?[\\\\s\\\\t]*)+" ) ) { continue ; } fields = line . split ( "\\\\|" ) ; result += "<tr>" ; for ( integer j = 0 ; j < fields . length ; j ++ ) { string field = fields [ j ] . trim ( ) ; if ( field . equals ( "date" ) || field . equals ( "author" ) || field . equals ( "version" ) ) { result += ( "<th>" + field + "</th>" ) ; continue ; } else if ( field . equals ( "remarks" ) ) { result += ( "<th class=\\"remarks\\">" + field + "</th>" ) ; continue ; } if ( result . endswith ( "</th>" ) ) { result += "</tr></thead><tbody>" ; } result += "<td>" + field + "</td>" ; } result += "</tr>" ; } result += "</tbody></table>" ; return result ; }
tr	1	private static arraylist < string > generatelist ( ) { arraylist < string > temp = new arraylist < string > ( ) ; temp . add ( "pc1:\\n       bin: " + pc1 + "\\n       hex: " + binarytohex ( pc1 ) + "\\n\\n" ) ; temp . add ( "c0:\\n       bin: " + c0 + "\\n       hex: " + binarytohex ( c0 ) + "\\n\\n" ) ; temp . add ( "d0:\\n       bin: " + d0 + "\\n       hex: " + binarytohex ( d0 ) + "\\n\\n" ) ; temp . add ( "c1:\\n       bin: " + c1 + "\\n       hex: " + binarytohex ( c1 ) + "\\n\\n" ) ; temp . add ( "d1:\\n       bin: " + d1 + "\\n       hex: " + binarytohex ( d1 ) + "\\n\\n" ) ; temp . add ( "key(pc2):\\n       bin: " + keybin + "\\n       hex: " + binarytohex ( keybin ) + "\\n\\n" ) ; temp . add ( "l0:\\n       bin: " + l0 + "\\n       hex: " + binarytohex ( l0 ) + "\\n\\n" ) ; temp . add ( "r0:\\n       bin: " + r0 + "\\n       hex: " + binarytohex ( r0 ) + "\\n\\n" ) ; temp . add ( "e[r0]:\\n       bin: " + er0 + "\\n       hex: " + binarytohex ( er0 ) + "\\n\\n" ) ; temp . add ( "e[r0] xor key (a):\\n       bin: " + erxork + "\\n       hex: " + binarytohex ( erxork ) + "\\n\\n" ) ; temp . add ( "s-box output (b):\\n       bin: " + b + "\\n       hex: " + binarytohex ( b ) + "\\n\\n" ) ; temp . add ( "p(b):\\n       bin: " + pb + "\\n       hex: " + binarytohex ( pb ) + "\\n\\n" ) ; temp . add ( "p(b) xor l0 (r1):\\n       bin: " + messagebin + "\\n       hex: " + binarytohex ( messagebin ) + "\\n\\n" ) ; return temp ; }
tr	6	public testclient ( ) throws exception { selectchannelconnector connector = new selectchannelconnector ( ) ; connector . setport ( 8181 ) ; connector . setserver ( server ) ; servletcontexthandler contexthandler = new servletcontexthandler ( server , "/" , servletcontexthandler . no_security ) ; servletholder holder = new servletholder ( ) ; holder . setservlet ( new httpservlet ( ) { @ override protected void dopost ( httpservletrequest req , httpservletresponse resp ) throws servletexception , ioexception { stringbuffer jb = new stringbuffer ( ) ; string line = null ; try { bufferedreader reader = req . getreader ( ) ; while ( ( line = reader . readline ( ) ) != null ) jb . append ( line ) ; system . out . println ( jb . tostring ( ) ) ; } catch ( exception e ) { system . out . println ( "can't read " + e ) ; } } } ) ; contexthandler . addservlet ( holder , "/" ) ; server . setconnectors ( new connector [ ] { connector } ) ; }
tr	2	public void upload ( string directory , string uploadfile , channelsftp sftp ) { try { sftp . cd ( directory ) ; file file = new file ( uploadfile ) ; fileinputstream fis = new fileinputstream ( file ) ; system . out . println ( "\u6587\u4ef6size:" + string . valueof ( fis . available ( ) / 1000 ) + "k" ) ; sftp . put ( new fileinputstream ( file ) , file . getname ( ) , new fileprogressmonitor ( fis . available ( ) ) , channelsftp . overwrite ) ; } catch ( sftpexception sftpexception ) { sftpexception . printstacktrace ( ) ; return ; } catch ( exception e ) { e . printstacktrace ( ) ; return ; } }
tr	10	@ override public readablemessagecatalog readfrom ( inputstream stream ) throws ioexception { stringbuilder buf = new stringbuilder ( ) ; bufferedreader reader = new bufferedreader ( new inputstreamreader ( stream , utf8 ) ) ; int ch ; while ( ( ch = reader . read ( ) ) != - 1 ) { buf . append ( ( char ) ch ) ; } reader . close ( ) ; final list < messagefragment > result = new arraylist < messagefragment > ( ) ; try { string xml = buf . tostring ( ) ; if ( xml . startswith ( "<?xml" ) ) { int end = xml . indexof ( "?>" ) ; string encoding = xml . substring ( 0 , end + 2 ) + "\\n" ; result . add ( new simplenonlocalizabletextfragment ( encoding ) ) ; } chain . setpatterns ( reference_string_pattern , escape_pattern ) ; document document = documenthelper . parsetext ( xml ) ; visitnodes ( result , document ) ; } catch ( documentexception ex ) { ex . printstacktrace ( ) ; } list < message > list = new arraylist < message > ( ) ; for ( messagefragment fragment : result ) { list . add ( new androidresourcemessage ( fragment ) ) ; } messages = collections . unmodifiablelist ( list ) ; return new readablemessagecatalog ( ) { public iterable < message > readmessages ( ) { return messages ; } @ override public void close ( ) throws ioexception { } } ; }
tr	5	static void getnthpower ( int a , int n ) { list < boolean > hlist = new arraylist < boolean > ( ) ; long startupnano = system . nanotime ( ) ; while ( n > 1 ) { boolean remainder = ( n % 2 == 1 ) ; hlist . add ( remainder ) ; n = n / 2 ; } long result = a ; for ( int i = hlist . size ( ) ; i > 0 ; i -- ) { boolean remainder = hlist . get ( i - 1 ) ; result = remainder ? result * result * a : result * result ; } system . out . println ( "result with arraylist: " + result ) ; system . out . println ( "elasped time in nanos: " + ( system . nanotime ( ) - startupnano ) ) ; }
tr	5	public static void main ( string username , string password , string ram ) throws ioexception { list < string > args = new arraylist < string > ( ) ; args . add ( system . getproperty ( "java.home" ) + file . separator + "bin" + file . separator + "java" + ( system . getproperty ( "os.name" ) . tolowercase ( ) . contains ( "win" ) ? "w" : "" ) ) ; args . add ( "-xms256m" ) ; args . add ( "-xmx" + ram + "m" ) ; args . add ( "-xx:permsize=256m" ) ; args . add ( "-dfml.ignorepatchdiscrepancies=true" ) ; args . add ( "-dfml.ignoreinvalidminecraftcertificates=true" ) ; args . add ( "-dfml.log.level=info" ) ; args . add ( "-djava.library.path=" + getworkingdirectory ( ) + file . separator + "bin" + file . separator + "natives-" + getos ( ) ) ; args . add ( "-cp" ) ; string classpath = "" ; file libs = new file ( getworkingdirectory ( ) + file . separator + "bin" ) ; for ( int i = 0 ; i < libs . list ( ) . length ; i ++ ) { if ( ! libs . list ( ) [ i ] . contains ( "natives" ) ) { classpath += libs . getabsolutepath ( ) + file . separator + libs . list ( ) [ i ] ; if ( i != libs . list ( ) . length - 1 ) classpath += file . pathseparator ; } } args . add ( classpath ) ; args . add ( "net.minecraft.launchwrapper.launch" ) ; args . add ( "--username" ) ; args . add ( username ) ; args . add ( "--session" ) ; args . add ( "****:****" ) ; args . add ( "--accesstoken" ) ; args . add ( username ) ; args . add ( "--userproperties" ) ; args . add ( "{}" ) ; args . add ( "--version" ) ; args . add ( unity . mc_version ) ; args . add ( "--gamedir" ) ; args . add ( getworkingdirectory ( ) ) ; args . add ( "--assetindex" ) ; args . add ( unity . mc_version ) ; args . add ( "--assetsdir" ) ; args . add ( getworkingdirectory ( ) + file . separator + "assets" ) ; args . add ( "--tweakclass=cpw.mods.fml.common.launcher.fmltweaker" ) ; system . out . print ( "executing: " ) ; for ( int i = 0 ; i < args . size ( ) ; i ++ ) { system . out . print ( args . get ( i ) + " " ) ; } processbuilder processbuilder = new processbuilder ( args ) ; processbuilder . directory ( new file ( getworkingdirectory ( ) ) ) ; processbuilder . redirecterrorstream ( true ) ; processbuilder . start ( ) ; }
tr	1	public int [ ] getrangeadmissions ( int [ ] from , int [ ] to ) throws sqlexception { int [ ] adm = new int [ 8 ] ; adm [ 0 ] = this . getamountr ( "$5" , from , to ) ; adm [ 1 ] = this . getamountr ( "$10" , from , to ) ; adm [ 2 ] = this . getamountr ( "$20" , from , to ) ; adm [ 3 ] = this . getamountr ( "g-tix" , from , to ) ; adm [ 4 ] = this . getamountr ( "mgr comp" , from , to ) ; adm [ 5 ] = this . getamountr ( "comp pass" , from , to ) ; adm [ 6 ] = this . getamountr ( "comp" , from , to ) ; adm [ 7 ] = this . getamountr ( "hotel" , from , to ) ; return adm ; }
tr	3	public spreadsheet ( string [ ] [ ] data ) { super ( new gridlayout ( 1 , 0 ) ) ; string [ ] emptylabels = new string [ data [ 0 ] . length ] ; for ( int i = 0 ; i < emptylabels . length ; i ++ ) emptylabels [ i ] = " " ; jt = new jtable ( data , emptylabels ) ; tablemodel model = new defaulttablemodel ( data , emptylabels ) { public boolean iscelleditable ( int row , int column ) { return false ; } } ; jt . setmodel ( model ) ; jt . settableheader ( null ) ; jt . setpreferredscrollableviewportsize ( new dimension ( 500 , 70 ) ) ; jt . setfillsviewportheight ( true ) ; add ( new jscrollpane ( jt ) ) ; }
tr	4	@ override public void actionperformed ( actionevent e ) { date loopstart = new date ( ) ; dologic ( ) ; repaint ( ) ; date loopend = new date ( ) ; if ( gameticks . size ( ) < 30 ) { gameticks . add ( loopend . gettime ( ) - loopstart . gettime ( ) ) ; } else { long total = new long ( 0l ) ; for ( long one : gameticks ) { total += one ; } system . out . println ( "game tick averages at about: " + ( total / gameticks . size ( ) ) + " milliseconds" ) ; gameticks . clear ( ) ; } }
tr	9	public static void main ( string [ ] args ) { for ( object o : system . getproperties ( ) . keyset ( ) ) { system . out . printf ( "%s:%s\\n" , o . tostring ( ) , system . getproperty ( ( string ) o ) ) ; } try { file folder = new file ( "files" ) ; for ( file file : folder . listfiles ( ) ) { if ( file . getabsolutepath ( ) . endswith ( ".arff" ) ) { system . out . println ( "-----------------" ) ; system . out . println ( "testing " + file ) ; try { data d = reader . getdatafromfile ( file ) ; tree tree = id3 . decisiontreelearning ( d . getexamples ( ) , d . getattributes ( ) , d . getgoalattribute ( ) , d . getattributevalues ( ) , null ) ; int before = tree . hashcode ( ) ; string sbefore = tree . tostring ( ) ; pruning . prune ( tree , d ) ; int after = tree . hashcode ( ) ; string safter = tree . tostring ( ) ; if ( before != after ) { system . out . println ( "...was pruned" ) ; system . out . println ( "before:" ) ; system . out . println ( sbefore ) ; system . out . println ( "after:" ) ; system . out . println ( safter ) ; } else { system . out . println ( "...was not pruned" ) ; system . out . println ( "before:" ) ; system . out . println ( sbefore ) ; } } catch ( illegalargumentexception e ) { system . out . println ( "...could not parse" ) ; } } else { system . out . println ( "ignored " + file ) ; } } } catch ( filenotfoundexception e ) { e . printstacktrace ( ) ; } }
tr	4	public chessmoves nextmoves ( chessboard b ) { int i = this . getposition ( ) . getrow ( ) ; int j = this . getposition ( ) . getcol ( ) ; chessmoves moves = new chessmoves ( ) ; try { for ( int k = i ; k < 8 ; k ++ ) { if ( k != i ) { if ( ! addmove ( b , moves , k , j ) ) break ; } } for ( int k = i ; k >= 0 ; k -- ) { if ( k != i ) { if ( ! addmove ( b , moves , k , j ) ) break ; } } for ( int k = j ; k < 8 ; k ++ ) { if ( k != j ) { if ( ! addmove ( b , moves , i , k ) ) break ; } } for ( int k = j ; k >= 0 ; k -- ) { if ( k != j ) { if ( ! addmove ( b , moves , i , k ) ) break ; } } } catch ( exception e ) { moves = null ; } return moves ; }
tr	1	public void test_score ( ) { int [ ] [ ] mockboards = { { 0 , 0 , 0 , 0 } , { 0 , 0 , 0 , 0 } , { 0 , 0 , 0 , 0 } , { 0 , 0 , 0 , 0 } } ; gamecore . resetgame ( ) ; gamecore . setboard ( mockboards ) ; gamecore . tilt_board_left ( ) ; assertequals ( 0 , gamecore . score ( ) ) ; mockboards = new int [ ] [ ] { { 1 , 1 , 1 , 1 } , { 0 , 0 , 0 , 0 } , { 2 , 2 , 2 , 2 } , { 0 , 0 , 0 , 0 } } ; gamecore . resetgame ( ) ; gamecore . setboard ( mockboards ) ; gamecore . tilt_board_left ( ) ; assertequals ( 12 , gamecore . score ( ) ) ; mockboards = new int [ ] [ ] { { 1 , 0 , 0 , 0 } , { 2 , 0 , 0 , 0 } , { 2 , 0 , 0 , 0 } , { 2 , 0 , 0 , 0 } } ; gamecore . resetgame ( ) ; gamecore . setboard ( mockboards ) ; gamecore . tilt_board_left ( ) ; assertequals ( 0 , gamecore . score ( ) ) ; mockboards = new int [ ] [ ] { { 1 , 2 , 3 , 4 } , { 2 , 3 , 3 , 3 } , { 2 , 2 , 2 , 2 } , { 2 , 3 , 3 , 3 } } ; gamecore . resetgame ( ) ; gamecore . setboard ( mockboards ) ; gamecore . tilt_board_left ( ) ; assertequals ( 20 , gamecore . score ( ) ) ; }
tr	4	private package nodetopackage ( node item ) { package p = new package ( ) ; nodelist params = item . getchildnodes ( ) ; for ( int i = 0 ; i < params . getlength ( ) ; i ++ ) { node current = params . item ( i ) ; if ( current instanceof element ) { if ( current . getnodename ( ) . equals ( "groupid" ) ) { p . groupid = current . getfirstchild ( ) . getnodevalue ( ) ; } if ( current . getnodename ( ) . equals ( "artifactid" ) ) { p . artifactid = current . getfirstchild ( ) . getnodevalue ( ) ; } if ( current . getnodename ( ) . equals ( "version" ) ) { p . version = current . getfirstchild ( ) . getnodevalue ( ) ; } } } if ( p . groupid . contains ( "${" ) || p . artifactid . contains ( "${" ) || p . version . contains ( "${" ) ) { return null ; } return p ; }
tr	2	@ override public int insertcustomer ( site site ) { connection con = conn . getconnection ( true ) ; try { preparedstatement ps = con . preparestatement ( "insert into public.site values (?<litcomma>?)" ) ; ps . setint ( 1 , site . getid ( ) ) ; ps . setstring ( 2 , site . getsitename ( ) ) ; ps . execute ( ) ; } catch ( sqlexception e ) { e . printstacktrace ( ) ; } finally { try { con . close ( ) ; } catch ( sqlexception e ) { e . printstacktrace ( ) ; } } return 0 ; }
tr	6	public void init ( ) throws portletexception { super . init ( ) ; expandotable table = null ; long companyid = portalutil . getdefaultcompanyid ( ) ; try { table = expandotablelocalserviceutil . adddefaulttable ( companyid , user . class . getname ( ) ) ; } catch ( duplicatetablenameexception dtne ) { try { table = expandotablelocalserviceutil . getdefaulttable ( companyid , user . class . getname ( ) ) ; } catch ( exception e ) { throw new portletexception ( ) ; } } catch ( exception e ) { throw new portletexception ( ) ; } expandocolumn column = null ; long tableid = table . gettableid ( ) ; string expandocolumnname = constants . expando_column_name ; try { column = expandocolumnlocalserviceutil . addcolumn ( tableid , expandocolumnname , expandocolumnconstants . string ) ; unicodeproperties properties = new unicodeproperties ( ) ; properties . setproperty ( expandocolumnconstants . index_type , boolean . true . tostring ( ) ) ; column . settypesettingsproperties ( properties ) ; expandocolumnlocalserviceutil . updateexpandocolumn ( column ) ; } catch ( duplicatecolumnnameexception dcne ) { } catch ( exception e ) { throw new portletexception ( ) ; } }
tr	9	public biginteger sortandcountinversions ( ) { if ( debug ) system . err . println ( "counting [" + array . tostring ( ) + "]" ) ; if ( array . size ( ) <= 1 ) { return biginteger . zero ; } if ( array . size ( ) == 2 ) { if ( array . get ( 0 ) > array . get ( 1 ) ) { if ( debug ) system . err . println ( "adding 1 inversions from base case " + array ) ; integer t = array . get ( 0 ) ; array . set ( 0 , array . get ( 1 ) ) ; array . set ( 1 , t ) ; return biginteger . one ; } else { return biginteger . zero ; } } biginteger addedinversions ; if ( debug ) system . err . println ( "recursing left with " + array . sublist ( 0 , array . size ( ) / 2 ) ) ; inversions left = new inversions ( array . sublist ( 0 , array . size ( ) / 2 ) ) ; addedinversions = left . sortandcountinversions ( ) ; if ( debug ) system . err . println ( "\\tadded " + addedinversions + " from " + array . sublist ( 0 , array . size ( ) / 2 ) ) ; inversions = inversions . add ( addedinversions ) ; if ( debug ) system . err . println ( "recursing right with " + array . sublist ( array . size ( ) / 2 , array . size ( ) ) ) ; inversions right = new inversions ( array . sublist ( array . size ( ) / 2 , array . size ( ) ) ) ; addedinversions = right . sortandcountinversions ( ) ; if ( debug ) system . err . println ( "\\tadded " + addedinversions + " from " + array . sublist ( array . size ( ) / 2 , array . size ( ) ) ) ; inversions = inversions . add ( addedinversions ) ; arraylist < integer > leftarray = left . getarray ( ) ; arraylist < integer > rightarray = right . getarray ( ) ; int i = 0 ; int j = 0 ; for ( int k = 0 ; k < array . size ( ) ; k ++ ) { if ( j >= rightarray . size ( ) || ( i < leftarray . size ( ) && leftarray . get ( i ) <= rightarray . get ( j ) ) ) { array . set ( k , leftarray . get ( i ) ) ; if ( debug ) system . err . println ( "adding " + j + " inversions for (" + i + "<litcomma>" + j + ") " + leftarray . get ( i ) + " from " + leftarray + " " + rightarray ) ; i ++ ; inversions = inversions . add ( biginteger . valueof ( j ) ) ; } else { array . set ( k , rightarray . get ( j ) ) ; j ++ ; } } return inversions ; }
tr	8	public static void main ( string [ ] args ) throws interruptedexception { logger logger = logmanager . getlogger ( readbalance . class . getname ( ) ) ; cachefactory . ensurecluster ( ) ; namedcache nc_bal = cachefactory . getcache ( "balances" ) ; string str_aid , str_bid ; int i_times = 0 ; scanner sc = new scanner ( system . in ) ; system . out . print ( "please input 'account id':" ) ; str_aid = sc . next ( ) ; system . out . print ( "please input 'balance id':" ) ; str_bid = sc . next ( ) ; system . out . print ( "please input 'times':" ) ; i_times = sc . nextint ( ) ; sc . close ( ) ; balanceid bal_id = new balanceid ( str_aid , str_bid ) ; balance bal = null ; system . out . println ( "" ) ; do { bal = ( balance ) nc_bal . get ( bal_id ) ; logger . trace ( "value of " + bal_id + " is '" + bal + "'" ) ; if ( i_times > 0 ) { thread . sleep ( 1000 ) ; i_times -- ; } } while ( i_times > 0 ) ; system . out . println ( "" ) ; }
tr	2	protected void assertequals ( arraylist < ? > xlist , arraylist < ? > list ) { assert . assertequals ( xlist . size ( ) , list . size ( ) ) ; for ( int i = 0 ; i < xlist . size ( ) ; i ++ ) { object obj = xlist . get ( i ) ; if ( obj instanceof arrayparameter ) { assertequals ( ( arrayparameter ) obj , list . get ( i ) ) ; } else if ( obj instanceof groupedparameter ) { assertequals ( ( groupedparameter ) obj , list . get ( i ) ) ; } else if ( obj instanceof singleparameter ) { assertequals ( ( singleparameter ) obj , list . get ( i ) ) ; } } }
tr	1	private void getcoininternal ( int centsleft , arraylist < integer > path , arraylist < arraylist < integer > > res ) { if ( centsleft == 0 ) { arraylist < integer > newpath = new arraylist < integer > ( ) ; newpath . addall ( path ) ; res . add ( newpath ) ; return ; } if ( centsleft >= 25 && ( path . size ( ) == 0 || path . get ( path . size ( ) - 1 ) == 25 ) ) { path . add ( 25 ) ; getcoininternal ( centsleft - 25 , path , res ) ; path . remove ( path . size ( ) - 1 ) ; } if ( centsleft >= 10 && ( path . size ( ) == 0 || path . get ( path . size ( ) - 1 ) >= 10 ) ) { path . add ( 10 ) ; getcoininternal ( centsleft - 10 , path , res ) ; path . remove ( path . size ( ) - 1 ) ; } if ( centsleft >= 5 && ( path . size ( ) == 0 || path . get ( path . size ( ) - 1 ) >= 5 ) ) { path . add ( 5 ) ; getcoininternal ( centsleft - 5 , path , res ) ; path . remove ( path . size ( ) - 1 ) ; } if ( centsleft >= 1 && ( path . size ( ) == 0 || path . get ( path . size ( ) - 1 ) >= 1 ) ) { path . add ( 1 ) ; getcoininternal ( centsleft - 1 , path , res ) ; path . remove ( path . size ( ) - 1 ) ; } return ; }
tr	1	private void setposition ( char cb_col , char cb_row ) throws chessexception { char tc = character . touppercase ( cb_col ) ; if ( ( tc < 'a' ) || ( tc > 'h' ) ) throw new chessexception ( "invalid board column position given: " + cb_col ) ; col = tc - 'a' ; if ( character . isdigit ( cb_row ) ) { row = character . getnumericvalue ( cb_row ) ; if ( ( row < 1 ) || ( row > 8 ) ) throw new chessexception ( "invalid board row position given: " + cb_row ) ; row = 8 - row ; } else { throw new chessexception ( "board row position not digit: " + cb_row ) ; } }
tr	5	public arraylist < arraylist < integer > > generate ( int numrows ) { arraylist < arraylist < integer > > res = new arraylist < arraylist < integer > > ( ) ; for ( int i = 0 ; i < numrows ; i ++ ) { arraylist < integer > row = new arraylist < integer > ( ) ; row . add ( 1 ) ; if ( i > 0 ) { arraylist < integer > prevrow = res . get ( i - 1 ) ; for ( int j = 1 ; j < prevrow . size ( ) ; j ++ ) { row . add ( prevrow . get ( j - 1 ) + prevrow . get ( j ) ) ; } row . add ( 1 ) ; } res . add ( row ) ; } return res ; }
tr	2	private static void addtreasurechesttogrid ( scanner scanner , grid grid ) { system . out . println ( "would you like to add a treasure chest to your grid. enter y or n :" ) ; string addtreasure = addtreasure ( scanner ) ; while ( ! addtreasure . equalsignorecase ( "y" ) && ! addtreasure . equalsignorecase ( "n" ) ) { system . out . println ( "enter y or n :" ) ; addtreasure = addtreasure ( scanner ) ; } if ( addtreasure . trim ( ) . tolowercase ( ) . equalsignorecase ( "y" ) ) { addtreasurechest ( scanner , grid ) ; } else { treasurechestcounter counter = new treasurechestmanager ( ) ; system . out . println ( "**********treasure maps nearby****************" ) ; counter . displaytreasurechestnearby ( grid ) ; } }
tr	3	public static void main ( string [ ] args ) throws ioexception { if ( args . length == 3 ) { string option = args [ 0 ] ; file src = new file ( args [ 1 ] ) , dest = new file ( args [ 2 ] ) ; if ( option . equals ( "d" ) ) { system . out . println ( "[d\xe9compression...]" ) ; huffman . decompression ( new fileinputstream ( src ) , dest ) ; return ; } else if ( option . equals ( "c" ) ) { system . out . println ( "[compression...]" ) ; huffman . compression ( src , new fileoutputstream ( dest ) ) ; return ; } } system . out . println ( "usage : [c|d] fichier.src fichier.dest" ) ; }
tr	1	public static string createconcept ( string name , conceptdatatype datatype , conceptclass conceptclass , list < string > setmembers ) throws jsonexception { jsonobject jsonobject = new jsonobject ( ) ; jsonobject . append ( "names" , new jsonobject ( ) . put ( "name" , name ) . put ( "locale" , "en" ) . put ( "conceptnametype" , "fully_specified" ) ) . put ( "datatype" , datatype ) . put ( "conceptclass" , conceptclass ) ; if ( setmembers == null || setmembers . size ( ) < 1 ) return jsonobject . tostring ( ) ; jsonobject . put ( "set" , true ) . put ( "setmembers" , setmembers ) ; return jsonobject . tostring ( ) ; }
tr	3	public static object stringtovalue ( string string ) { double d ; if ( string . equals ( "" ) ) { return string ; } if ( string . equalsignorecase ( "true" ) ) { return boolean . true ; } if ( string . equalsignorecase ( "false" ) ) { return boolean . false ; } if ( string . equalsignorecase ( "null" ) ) { return jsonobject . null ; } char b = string . charat ( 0 ) ; if ( ( b >= '0' && b <= '9' ) || b == '-' ) { try { if ( string . indexof ( '.' ) > - 1 || string . indexof ( 'e' ) > - 1 || string . indexof ( 'e' ) > - 1 ) { d = double . valueof ( string ) ; if ( ! d . isinfinite ( ) && ! d . isnan ( ) ) { return d ; } } else { long mylong = new long ( string ) ; if ( string . equals ( mylong . tostring ( ) ) ) { if ( mylong . longvalue ( ) == mylong . intvalue ( ) ) { return new integer ( mylong . intvalue ( ) ) ; } else { return mylong ; } } } } catch ( numberformatexception ignore ) { } } return string ; }
tr	5	public void execute ( crawlercontext crawlercontext ) throws ioexception { document doc = jsoup . connect ( url ) . get ( ) ; elements elements = doc . select ( "table.data > tbody > tr a[href*=player]" ) ; for ( element e : elements ) { crawlercontext . submittask ( new processplayer ( e . attr ( "abs:href" ) ) ) ; } if ( ! processpagination ) { return ; } elements = doc . select ( ".pagenumbers > a" ) ; set < string > urls = new hashset < string > ( ) ; for ( element e : elements ) { urls . add ( e . attr ( "abs:href" ) ) ; } for ( string url : urls ) { crawlercontext . submittask ( new processletter ( url , false ) ) ; } }
tr	6	public void downloadpackage ( package p ) throws ioexception { if ( p . version == null ) { p . version = parser . mostrecentversion ( p ) ; } final list < package > deps ; try { deps = parser . getdependencies ( p ) ; } catch ( runtimeexception e ) { log . error ( "error: unable to resolve package data from {}<litcomma> aborting." , p . tostring ( ) ) ; return ; } if ( deps . size ( ) > 0 ) { log . info ( "{} has {} dependencies<litcomma> resolving..." , p . tostring ( ) , deps . size ( ) ) ; for ( package dependency : deps ) { downloadpackage ( dependency ) ; } } log . info ( "downloading {} ..." , p . tostring ( ) ) ; string downloadurl = getdownloadurl ( p ) ; url jarrequest = new url ( downloadurl ) ; readablebytechannel rbc = channels . newchannel ( jarrequest . openstream ( ) ) ; fileoutputstream fos = new fileoutputstream ( options . jenenv + file . separator + p . artifactid + "-" + p . version + ".jar" ) ; fos . getchannel ( ) . transferfrom ( rbc , 0 , 1 << 24 ) ; fos . close ( ) ; log . info ( "download complete." ) ; }
tr	6	private string plurality ( list < instance > examples ) { map < string , integer > scores = new linkedhashmap < string , integer > ( ) ; for ( instance instance : examples ) { integer score = scores . get ( instance . label ) ; if ( score == null ) { score = 0 ; } scores . put ( instance . label , score + 1 ) ; } if ( scores . isempty ( ) ) { return "1" ; } else if ( scores . size ( ) == 1 ) { return scores . keyset ( ) . iterator ( ) . next ( ) ; } else { int winningscore = integer . min_value ; string winner = null ; for ( string label : scores . keyset ( ) ) { if ( ! label . equals ( winner ) ) { int score = scores . get ( label ) ; if ( winningscore == score ) { if ( label . comparetoignorecase ( winner ) < 0 ) { winner = label ; } } else if ( winningscore < score ) { winner = label ; winningscore = score ; } } } return winner ; } }
tr	6	public void updatetext ( ) { gtext textname = new gtext ( name , gposition . top ) ; integer num ; num = tasknumber ; gtext texttasknum = new gtext ( num . tostring ( ) , gposition . top ) ; num = numberofdays ; gtext textnumofdays = new gtext ( num . tostring ( ) , gposition . top ) ; gtext textstart = new gtext ( startdate , gposition . top ) ; gtext textend = new gtext ( enddate , gposition . top ) ; square . addtext ( textname ) ; square . addtext ( texttasknum ) ; square . addtext ( textnumofdays ) ; square . addtext ( textstart ) ; square . addtext ( textend ) ; }
tr	9	public bufferedimage getimagebuffer ( ) { bufferedimage result = new bufferedimage ( width , height , bufferedimage . type_int_argb ) ; for ( int y = 0 ; y < height ; y ++ ) { for ( int x = 0 ; x < width ; x ++ ) { int index = ( x + y * allocatedwidth ) * 4 ; int r = pixeldata . get ( index ++ ) & 0xff ; int g = pixeldata . get ( index ++ ) & 0xff ; int b = pixeldata . get ( index ++ ) & 0xff ; int a = pixeldata . get ( index ) & 0xff ; int packed = ( a << 24 ) | ( r << 16 ) | ( g << 8 ) | b ; result . setrgb ( x , y , packed ) ; } } return result ; }
tr	9	public static void main ( string args [ ] ) { final long currenttime = system . currenttimemillis ( ) ; vco vco ; averagetwofilteredsample samplerfunction ; wavefunction wavefunction ; outputlistener outputlistener ; timer timer ; class consoleoutputlistener implements outputlistener { @ override public void sendoutput ( long timestamp , double value ) { long time = timestamp - currenttime ; system . out . format ( "%10d" , time ) ; int spaces = ( int ) math . floor ( ( value + 1.0 ) * 40.0 ) ; for ( int i = 0 ; i < spaces ; i ++ ) { system . out . print ( " " ) ; } system . out . print ( "*\\n" ) ; } } try { samplerfunction = new averagetwofilteredsample ( ) ; wavefunction = new sinewave ( ) ; outputlistener = new consoleoutputlistener ( ) ; vco = new vco ( 1.0 , wavefunction , samplerfunction , outputlistener ) ; timer = new timer ( "vco timer" , true ) ; timer . scheduleatfixedrate ( vco , 0 , 100 ) ; for ( int i = 0 ; i < 1000 ; i ++ ) { samplerfunction . set ( ( double ) i / 1000.0 ) ; thread . sleep ( 100 ) ; } thread . sleep ( 1000 ) ; for ( int i = 1000 ; i >= 0 ; i -- ) { samplerfunction . set ( ( double ) i / 1000.0 ) ; thread . sleep ( 100 ) ; } } catch ( exception ex ) { system . err . println ( ex . getmessage ( ) ) ; } }
tr	2	public void run ( ) { pruebathreads . sett ( pruebathreads . gett ( ) + 1 ) ; while ( cont >= 0 ) { string s = pruebathreads . getclase ( ) ; if ( s == null ) { system . out . println ( this . id + " - " + cont + " sin ultima lectura" ) ; } else { system . out . println ( this . id + " - " + cont + " ultima escritura " + s ) ; } pruebathreads . setclase ( id ) ; if ( cont == 0 ) { int r = pruebathreads . gett ( ) ; pruebathreads . sett ( r - 1 ) ; system . out . println ( "ultima escritura " + pruebathreads . getclase ( ) + " - " + ( r - 1 ) + " threads activos" ) ; } else { delaysegundo ( ) ; } cont -- ; } }
tr	7	@ eventhandler public void onplayerinteractevent ( playerinteractevent event ) { action action = event . getaction ( ) ; player player = event . getplayer ( ) ; if ( ! player . haspermission ( "trophyheads.info" ) ) { logdebug ( "player does not have permission: trophyheads.info" ) ; return ; } if ( action . equals ( action . right_click_block ) ) { org . bukkit . block . block block = event . getclickedblock ( ) ; logdebug ( action . name ( ) + ": " + block . gettype ( ) . name ( ) ) ; if ( block . gettype ( ) . equals ( material . skull ) ) { blockstate bs = block . getstate ( ) ; org . bukkit . block . skull skull = ( org . bukkit . block . skull ) bs ; string pname = "unknown" ; string message = "" ; logdebug ( "skull type: " + skull . getskulltype ( ) . name ( ) ) ; if ( skull . getskulltype ( ) . equals ( skulltype . player ) ) { if ( skull . hasowner ( ) ) { pname = skull . getowner ( ) ; logdebug ( "skull owner: " + pname ) ; if ( pname == null ) { if ( ! nontropyheadmessage . isempty ( ) ) { if ( rightclickcooldowns . containskey ( player . getuniqueid ( ) ) ) { if ( rightclickcooldowns . get ( player . getuniqueid ( ) ) >= system . currenttimemillis ( ) ) { return ; } } player . sendmessage ( nontropyheadmessage ) ; rightclickcooldowns . put ( player . getuniqueid ( ) , system . currenttimemillis ( ) + cooldown ) ; return ; } } else if ( custom_skins . containsvalue ( pname ) ) { message = skull_messages . get ( getcustomskulltype ( pname ) ) ; } else { message = skull_messages . get ( entitytype . player . name ( ) ) ; } } else { message = skull_messages . get ( entitytype . player . tostring ( ) ) ; } } else if ( skull . getskulltype ( ) . name ( ) . equalsignorecase ( "dragon" ) ) { message = skull_messages . get ( entitytype . ender_dragon . tostring ( ) ) ; } else if ( skull . getskulltype ( ) . tostring ( ) . equals ( skulltype . creeper . tostring ( ) ) ) { message = skull_messages . get ( entitytype . creeper . tostring ( ) ) ; } else if ( skull . getskulltype ( ) . tostring ( ) . equals ( skulltype . skeleton . tostring ( ) ) ) { message = skull_messages . get ( entitytype . skeleton . tostring ( ) ) ; } else if ( skull . getskulltype ( ) . tostring ( ) . equals ( skulltype . wither . tostring ( ) ) ) { message = skull_messages . get ( "wither_skeleton" ) ; } else if ( skull . getskulltype ( ) . tostring ( ) . equals ( skulltype . zombie . tostring ( ) ) ) { message = skull_messages . get ( entitytype . zombie . tostring ( ) ) ; } else { message = skull_messages . get ( entitytype . player . tostring ( ) ) ; } if ( pname == null ) { pname = "unknown" ; } if ( message == null ) { message = "" ; } if ( info_blacklist . contains ( pname . tolowercase ( ) ) ) { logdebug ( "ignoring: " + pname ) ; return ; } if ( rightclickcooldowns . containskey ( player . getuniqueid ( ) ) ) { if ( rightclickcooldowns . get ( player . getuniqueid ( ) ) >= system . currenttimemillis ( ) ) { return ; } } message = message . replace ( "%%name%%" , pname ) ; message = chatcolor . translatealternatecolorcodes ( '&' , message ) ; logdebug ( message ) ; player . sendmessage ( message ) ; rightclickcooldowns . put ( player . getuniqueid ( ) , system . currenttimemillis ( ) + cooldown ) ; } } }
tr	9	private void drawarrow ( graphics2d g ) { int x1 = xpoints . get ( npoints - 2 ) ; int y1 = ypoints . get ( npoints - 2 ) ; int x2 = xpoints . get ( npoints - 1 ) ; int y2 = ypoints . get ( npoints - 1 ) ; int dx = x2 - x1 ; int dy = y2 - y1 ; double angle = math . atan2 ( dy , dx ) ; int len = ( int ) math . sqrt ( dx * dx + dy * dy ) ; affinetransform at = affinetransform . gettranslateinstance ( x1 , y1 ) ; at . concatenate ( affinetransform . getrotateinstance ( angle ) ) ; g . transform ( at ) ; g . drawline ( 0 , 0 , len , 0 ) ; g . fillpolygon ( new int [ ] { len , len - const . arr_x , len - const . arr_x , len } , new int [ ] { 0 , - const . arr_y / 2 , const . arr_y / 2 , 0 } , 4 ) ; at . settoidentity ( ) ; g . settransform ( at ) ; }
tr	5	public static void main ( string [ ] args ) { string host = "irc.freenode.net" ; string channel = "#uofa-acm" ; string nick = "examplebot" ; int port = 6667 ; ircbot bot = new ircbot ( host , channel , nick , port ) ; bot . addhandler ( new messagehandler ( bot ) { void handle ( message message ) { if ( message . gettrailing ( ) . contains ( "hello " + bot . getnick ( ) ) ) { bot . sendprivmsg ( bot . getchannel ( ) , "hey!" ) ; } } } ) ; bot . run ( ) ; }
tr	10	public void initurls ( ) { string source = openurl ( "http://www.vucommodores.com/index.html" ) ; int menindex = source . indexof ( "sports column span4" ) ; int womenindex = source . indexof ( "sports column span4" , menindex + 1 ) ; string [ ] substring = new string [ 2 ] ; substring [ 0 ] = source . substring ( menindex , womenindex ) ; substring [ 1 ] = source . substring ( womenindex ) ; for ( int i = 0 ; i < 2 ; i ++ ) { int fromindex = 0 ; while ( substring [ i ] . indexof ( "<a class=\\"al\\" href=\\"/sports/" , fromindex ) >= 0 ) { fromindex = substring [ i ] . indexof ( "<a class=\\"al\\" href=\\"/sports/" , fromindex ) + 1 ; string sportname = substring [ i ] . substring ( substring [ i ] . indexof ( "\\">" , fromindex ) + 2 , substring [ i ] . indexof ( "</a>" , fromindex ) ) ; for ( int j = 0 ; j < 3 ; j ++ ) { fromindex = substring [ i ] . indexof ( "<a class=\\"ar\\" href=\\"/sports/" , fromindex ) + 1 ; } string sportlink = "http://www.vucommodores.com" + substring [ i ] . substring ( substring [ i ] . indexof ( "href=\\"" , fromindex ) + 6 , substring [ i ] . indexof ( "\\">" , fromindex ) ) ; string [ ] sport = new string [ 3 ] ; sport [ 0 ] = sportname ; sport [ 1 ] = i == 0 ? "men" : "women" ; sport [ 2 ] = sportlink ; listsports . add ( sport ) ; } } }
tr	1	public pelota entrada_objeto ( ) { pelota pelota_actual = null ; try { entrada = sock . getinputstream ( ) ; entrada_serializada = new objectinputstream ( entrada ) ; pelota_actual = ( pelota ) entrada_serializada . readobject ( ) ; } catch ( ioexception ex ) { logger . getlogger ( conexioncliente . class . getname ( ) ) . log ( level . severe , null , ex ) ; } catch ( classnotfoundexception ex ) { logger . getlogger ( conexioncliente . class . getname ( ) ) . log ( level . severe , null , ex ) ; } return pelota_actual ; }
tr	2	public static list < computeserver > buildcomputeserver ( int [ ] ram , int [ ] cpu , int [ ] cost , int [ ] reliability ) { if ( ram . length != cpu . length || ram . length != cost . length || cpu . length != cost . length ) { throw new illegalargumentexception ( "ram array<litcomma> cost array and cpu array should have the same length" ) ; } list < computeserver > servers = new arraylist < > ( ram . length ) ; for ( int i = 0 ; i < ram . length ; i ++ ) { servers . add ( new computeserver ( "server " + i , ram [ i ] , cpu [ i ] , cost [ i ] , reliability [ i ] ) ) ; } return servers ; }
tr	5	protected boolean signpackage ( ) throws mojoexecutionexception { getlog ( ) . info ( "signing package..." ) ; getlog ( ) . info ( "certificate: " + getkeystorage ( ) ) ; signerargumentsbuilder argumentsbuilder = new signerargumentsbuilder ( getcertificate ( ) . getfile ( ) , getcertificate ( ) . getpassword ( ) , getkeystorage ( ) . getfile ( ) , getbarpackage ( ) . getbarfile ( ) ) ; final string [ ] args = argumentsbuilder . create ( ) ; callable < void > signercallable = new callable < void > ( ) { @ override public void call ( ) throws exception { barsigner . main ( args ) ; return null ; } } ; exittrappingexecutor executor = new exittrappingexecutor ( ) ; boolean signingsuccessful = executor . execute ( signercallable ) == 0 ; getlog ( ) . info ( signingsuccessful ? "package signed successfully." : "package signing failed." ) ; return signingsuccessful ; }
tr	8	private static int compute ( string startpos , list < string > pieces , boolean b ) { int movecount = - 1 ; int x = integer . parseint ( startpos . split ( "<litcomma>" ) [ 0 ] ) ; int y = integer . parseint ( startpos . split ( "<litcomma>" ) [ 1 ] ) ; if ( x > 0 && y < 7 ) { string checkforbright = ( x + 1 ) + "<litcomma>" + ( y + 1 ) ; string checkforbleft = ( x - 1 ) + "<litcomma>" + ( y + 1 ) ; string checkforemptyright = ( x + 2 ) + "<litcomma>" + ( y + 2 ) ; string checkforemptyleft = ( x - 2 ) + "<litcomma>" + ( y + 2 ) ; if ( x + 2 <= 7 && y + 2 <= 7 && pieces . contains ( checkforbright ) && ! pieces . contains ( checkforemptyright ) ) { movecount = 1 ; x = x + 2 ; y = y + 2 ; int count = compute ( x + "<litcomma>" + y , pieces , true ) ; if ( b ) count -- ; movecount += count ; } else if ( x - 2 >= 0 && y + 2 <= 7 && pieces . contains ( checkforbleft ) && ! pieces . contains ( checkforemptyleft ) ) { movecount = 1 ; x = x - 2 ; y = y + 2 ; int count = compute ( x + "<litcomma>" + y , pieces , true ) ; if ( b ) count -- ; movecount += count ; } else if ( x + 1 <= 7 && y + 1 <= 7 && ! pieces . contains ( ( x + 1 ) + "<litcomma>" + ( y + 1 ) ) ) { movecount = 1 ; x = x + 1 ; y = y + 1 ; int count = compute ( x + "<litcomma>" + y , pieces , false ) ; movecount += count ; } else if ( x - 1 >= 0 && y + 1 <= 7 && ! pieces . contains ( ( x - 1 ) + "<litcomma>" + ( y + 1 ) ) ) { movecount = 1 ; x = x - 1 ; y = y + 1 ; int count = compute ( x + "<litcomma>" + y , pieces , false ) ; movecount += count ; } } else { movecount = 0 ; } return movecount ; }
tr	1	public void choosetexture ( ) { int [ ] surroundingtiles = tilemap . getsurroundingtiles ( ( int ) bounds . getminx ( ) / ( int ) bounds . getwidth ( ) , ( int ) bounds . getminy ( ) / ( int ) bounds . getheight ( ) ) ; if ( surroundingtiles [ 0 ] == 2 ) { if ( surroundingtiles [ 1 ] == 2 ) { texture = t9texture . getsubimage ( 0 , 0 , ( int ) bounds . getwidth ( ) , ( int ) bounds . getheight ( ) ) ; return ; } else if ( surroundingtiles [ 2 ] == 2 ) { texture = t9texture . getsubimage ( ( int ) t9texture . getwidth ( ) / 2 , 0 , ( int ) bounds . getwidth ( ) , ( int ) bounds . getheight ( ) ) ; return ; } else { texture = t9texture . getsubimage ( ( int ) t9texture . getwidth ( ) / 4 , 0 , ( int ) bounds . getwidth ( ) , ( int ) bounds . getheight ( ) ) ; return ; } } else if ( surroundingtiles [ 1 ] == 2 ) { if ( surroundingtiles [ 3 ] == 2 ) { texture = t9texture . getsubimage ( 0 , t9texture . getheight ( ) / 2 , ( int ) bounds . getwidth ( ) , ( int ) bounds . getheight ( ) ) ; return ; } else { texture = t9texture . getsubimage ( 0 , t9texture . getheight ( ) / 4 , ( int ) bounds . getwidth ( ) , ( int ) bounds . getheight ( ) ) ; return ; } } else if ( surroundingtiles [ 2 ] == 2 ) { if ( surroundingtiles [ 3 ] == 2 ) { texture = t9texture . getsubimage ( t9texture . getwidth ( ) / 2 , t9texture . getheight ( ) / 2 , ( int ) bounds . getwidth ( ) , ( int ) bounds . getheight ( ) ) ; return ; } else { texture = t9texture . getsubimage ( t9texture . getwidth ( ) / 2 , t9texture . getheight ( ) / 4 , ( int ) bounds . getwidth ( ) , ( int ) bounds . getheight ( ) ) ; return ; } } else if ( surroundingtiles [ 3 ] == 2 ) { texture = t9texture . getsubimage ( t9texture . getwidth ( ) / 4 , t9texture . getheight ( ) / 2 , ( int ) bounds . getwidth ( ) , ( int ) bounds . getheight ( ) ) ; return ; } texture = t9texture . getsubimage ( ( int ) t9texture . getwidth ( ) / 4 , ( int ) t9texture . getheight ( ) / 4 , ( int ) bounds . getwidth ( ) , ( int ) bounds . getheight ( ) ) ; }
tr	3	public int mindistance ( string word1 , string word2 ) { if ( word1 . length ( ) == 0 ) return word2 . length ( ) ; if ( word2 . length ( ) == 0 ) return word1 . length ( ) ; int [ ] [ ] res = new int [ word1 . length ( ) + 1 ] [ word2 . length ( ) + 1 ] ; res [ 0 ] [ 0 ] = 0 ; for ( int i = 1 ; i <= word1 . length ( ) ; i ++ ) res [ i ] [ 0 ] = i ; for ( int j = 1 ; j <= word2 . length ( ) ; j ++ ) res [ 0 ] [ j ] = j ; for ( int i = 1 ; i <= word1 . length ( ) ; i ++ ) { for ( int j = 1 ; j <= word2 . length ( ) ; j ++ ) { if ( word1 . charat ( i - 1 ) == word2 . charat ( j - 1 ) ) { res [ i ] [ j ] = res [ i - 1 ] [ j - 1 ] ; } else { res [ i ] [ j ] = math . min ( math . min ( res [ i - 1 ] [ j - 1 ] , res [ i ] [ j - 1 ] ) , res [ i - 1 ] [ j ] ) + 1 ; } } } return res [ word1 . length ( ) ] [ word2 . length ( ) ] ; }
tr	3	@ override public void exec ( string channel , string sender , string commandname , string [ ] args , string login , string hostname , string message ) { string fmlmessage = "" ; try { url url = new url ( "http://rscript.org/lookup.php?type=fml" ) ; bufferedreader breader = new bufferedreader ( new inputstreamreader ( url . openstream ( ) ) ) ; while ( ( fmlmessage = breader . readline ( ) ) != null ) { if ( fmlmessage . startswith ( "text: " ) ) { fmlmessage = fmlmessage . replace ( "text: " , "" ) ; break ; } } } catch ( ioexception ex ) { if ( ex . getmessage ( ) . contains ( "503" ) ) { this . bot . sendmessage ( channel , "error: 503" ) ; } if ( ex . getmessage ( ) . contains ( "404" ) ) { this . bot . sendmessage ( channel , "error: 503" ) ; } } this . bot . sendmessage ( channel , "[fml] " + fmlmessage ) ; }
tr	6	public listenablefuture < searchresult > apply ( list < searchresult > results ) { stringbuilder keywords = new stringbuilder ( ) ; set < string > records = new hashset < string > ( ) ; long starttime = long . max_value ; long endtime = 0 ; for ( searchresult result : results ) { if ( result != null ) { keywords . append ( result . getkeyword ( ) ) ; records . addall ( result . getrecords ( ) ) ; starttime = math . min ( starttime , result . getstarttime ( ) ) ; endtime = math . max ( endtime , result . getendtime ( ) ) ; } } settablefuture < searchresult > constfuture = settablefuture . create ( ) ; constfuture . set ( new searchresult ( keywords . tostring ( ) , new arraylist < string > ( records ) , starttime , endtime ) ) ; return constfuture ; }
tr	2	@ requestmapping ( applicationconstants . create_chat ) @ responsebody public object createchatroom ( @ requestparam ( "name" ) string name ) { chatroom chatroom = new chatroom ( ) ; map < object , string > errormap = new hashmap < object , string > ( ) ; system . out . println ( "name11111" + name ) ; if ( name == null || "" . equals ( name ) ) { errormap . put ( 1 , "please enter name" ) ; } if ( errormap . size ( ) > 0 ) { return errormap ; } else { chatroom . setname ( name ) ; chatroom . setcreateddate ( new date ( ) . tostring ( ) ) ; chatroomdao . createchatroom ( chatroom ) ; return chatroom ; } }
tr	4	private string obtemidentificador ( httpservletrequest req ) throws recursosemidentificadorexception { string requesturi = req . getrequesturi ( ) ; string [ ] pedacosdauri = requesturi . split ( "/" ) ; boolean contextocervejasencontrado = false ; for ( string contexto : pedacosdauri ) { if ( contexto . equals ( "cervejas" ) ) { contextocervejasencontrado = true ; continue ; } if ( contextocervejasencontrado ) { try { return urldecoder . decode ( contexto , "utf-8" ) ; } catch ( unsupportedencodingexception e ) { return urldecoder . decode ( contexto ) ; } } } throw new recursosemidentificadorexception ( "recurso sem identificador" ) ; }
tr	3	public int [ ] sort ( int [ ] hand ) { int tmp ; for ( int i = 0 ; i < hand . length ; i ++ ) { for ( int j = hand . length - 1 ; j > i ; j -- ) { if ( hand [ j ] > hand [ j - 1 ] ) { tmp = hand [ j ] ; hand [ j ] = hand [ j - 1 ] ; hand [ j - 1 ] = tmp ; } } } return hand ; }
tr	3	public zipf ( random r , int min , int max , double sigma , double epsilon ) { if ( ( max <= min ) || ( sigma <= 1 ) || ( epsilon <= 0 ) || ( epsilon >= 0.5 ) ) { throw new illegalargumentexception ( "invalid arguments" ) ; } random = r ; k = new arraylist < integer > ( ) ; v = new arraylist < double > ( ) ; double sum = 0 ; int last = - 1 ; for ( int i = min ; i < max ; ++ i ) { sum += math . exp ( - sigma * math . log ( i - min + 1 ) ) ; if ( ( last == - 1 ) || i * ( 1 - epsilon ) > last ) { k . add ( i ) ; v . add ( sum ) ; last = i ; } } if ( last != max - 1 ) { k . add ( max - 1 ) ; v . add ( sum ) ; } v . set ( v . size ( ) - 1 , 1.0 ) ; for ( int i = v . size ( ) - 2 ; i >= 0 ; -- i ) { v . set ( i , v . get ( i ) / sum ) ; } }
tr	6	private exam parseexam ( final node exam ) { string name = "" ; string mark = "" ; final nodelist fields = exam . getchildnodes ( ) ; for ( int i = 0 ; i < fields . getlength ( ) ; ++ i ) { final node field = fields . item ( i ) ; if ( field != null ) { if ( field . getnodetype ( ) == node . element_node ) { final node item = field . getchildnodes ( ) . item ( 0 ) ; if ( item != null ) { if ( field . getnodename ( ) == model . field_name ) { name = item . getnodevalue ( ) ; } if ( field . getnodename ( ) == model . field_mark ) { mark = item . getnodevalue ( ) ; } } } } } return new exam ( name , util . isnumeric ( mark ) ? integer . parseint ( mark ) : null ) ; }
tr	9	private void checkifvariablesblacklisted ( typeelement clazz , urlclassloader urlclassloader ) { list < ? extends element > enclosingelements = clazz . getenclosedelements ( ) ; try { for ( element element : enclosingelements ) { if ( element . astype ( ) . getkind ( ) == typekind . declared ) { typemirror typemirror = element . astype ( ) ; class declaredtype = urlclassloader . loadclass ( typemirror . tostring ( ) ) ; if ( googleappengineblacklist . blacklist . contains ( declaredtype ) ) { processingenv . getmessager ( ) . printmessage ( kind . error , "the class " + clazz + "  has a declared type which is an app engine  restricted jre interface/class " + declaredtype ) ; } else { for ( class blacklistedclazz : googleappengineblacklist . getblacklist ( ) ) { if ( blacklistedclazz . isassignablefrom ( declaredtype ) ) { processingenv . getmessager ( ) . printmessage ( kind . error , "the class " + clazz + "  has a declared type which is an app engine  restricted jre interface/class " + declaredtype ) ; } } } } if ( element . astype ( ) . getkind ( ) == typekind . executable ) { executableelement executableelement = ( executableelement ) element ; typemirror typemirrorreturntype = executableelement . getreturntype ( ) ; if ( typemirrorreturntype . getkind ( ) == typekind . declared ) { class declaredtype = urlclassloader . loadclass ( typemirrorreturntype . tostring ( ) ) ; if ( googleappengineblacklist . blacklist . contains ( declaredtype ) ) { processingenv . getmessager ( ) . printmessage ( kind . error , "the class " + clazz + "  has a method " + executableelement + " which returns a google app engine restricted interface/class" + declaredtype ) ; } } list < ? extends variableelement > methodparameters = executableelement . getparameters ( ) ; for ( variableelement methodparameter : methodparameters ) { if ( methodparameter . astype ( ) . getkind ( ) == typekind . declared ) { class declaredtype = urlclassloader . loadclass ( methodparameter . astype ( ) . tostring ( ) ) ; if ( googleappengineblacklist . blacklist . contains ( declaredtype ) ) { processingenv . getmessager ( ) . printmessage ( kind . error , "the class " + clazz + "  has a method " + executableelement + " which contains a google app engine restricted interface/class as method parameter" + declaredtype ) ; } } } } } } catch ( classnotfoundexception e ) { } }
tr	5	void decode ( final string msgtext , final message message ) throws jsonexception { final jsonobject jsonobject = new jsonobject ( msgtext ) ; final jsonarray names = jsonobject . names ( ) ; if ( names . length ( ) == 1 ) { final string firstname = ( string ) ( names . get ( 0 ) ) ; final object firstobj = jsonobject . get ( firstname ) ; if ( firstobj instanceof jsonarray ) { final jsonarray params = jsonobject . getjsonarray ( firstname ) ; message . name = firstname ; message . parameters = new parameter [ ] { decodeparams ( params ) } ; } else { message . parameters = decodeparams ( jsonobject ) ; } } else { message . parameters = decodeparams ( jsonobject ) ; } }
tr	7	@ override public void requestfile ( string url ) { try { long inittime = system . currenttimemillis ( ) ; httpurlconnection con = ( httpurlconnection ) new url ( url ) . openconnection ( ) ; con . setrequestmethod ( "get" ) ; con . setrequestproperty ( "user-agent" , "mozilla 5.0" ) ; int responsecode = con . getresponsecode ( ) ; logger . debug ( "c\xf3digo de resposta http: " + responsecode ) ; bufferedreader br = new bufferedreader ( new inputstreamreader ( con . getinputstream ( ) ) ) ; string inputline ; stringbuffer response = new stringbuffer ( ) ; while ( ( inputline = br . readline ( ) ) != null ) { response . append ( inputline ) ; } br . close ( ) ; long time = system . currenttimemillis ( ) - inittime ; logger . info ( "tempo da requisi\xe7\xe3o:" + time ) ; logger . info ( "tamanho da requisi\xe7\xe3o: " + response . tostring ( ) . getbytes ( ) . length ) ; logger . debug ( response . tostring ( ) ) ; } catch ( malformedurlexception mue ) { logger . error ( "erro: " + mue . getmessage ( ) ) ; } catch ( protocolexception pe ) { logger . error ( "erro: " + pe . getmessage ( ) ) ; } catch ( ioexception ioe ) { logger . error ( "erro: " + ioe . getmessage ( ) ) ; } }
tr	6	static void getnthpowerwitharrays ( int a , int n ) { int height = logofbase ( 2 , n ) ; boolean [ ] harr = new boolean [ height ] ; long startupnano = system . nanotime ( ) ; while ( n > 1 ) { boolean remainder = ( n % 2 == 1 ) ; harr [ -- height ] = remainder ; n = n / 2 ; } long result = a ; for ( int i = 0 ; i < harr . length ; i ++ ) { boolean remainder = harr [ i ] ; result = remainder ? result * result * a : result * result ; } system . out . println ( "results with array: " + result ) ; system . out . println ( "elasped time in nanos: " + ( system . nanotime ( ) - startupnano ) ) ; }
tr	4	public static int readint ( int min , int max ) { if ( min > max ) { int tmp = max ; max = min ; min = tmp ; } int n ; do { try { scanner in = new scanner ( system . in ) ; n = in . nextint ( ) ; if ( n >= min && n <= max ) { return n ; } string msg = "veuillez entrer une valeur entre " + min + " et " + max + " > " ; if ( max == integer . max_value ) msg = "veuillez entrer une valeur superieur a " + min + " > " ; system . out . print ( msg ) ; } catch ( exception e ) { system . out . println ( "erreur de saisie" ) ; } } while ( true ) ; }
tr	4	@ override public string transforma ( string textoasertransformado ) { string textoanterior = "" ; string textofinal = "" ; while ( validacaodelistanastring ( textoasertransformado ) ) { string textoasertransformadoarray [ ] = textoasertransformado . split ( "\\n" ) ; for ( string texto : textoasertransformadoarray ) { if ( textoanterior . matches ( ".*<ul>.*" ) ) { texto = texto . replaceall ( "\\\\*(.*)" , "<li>$1</li>" ) ; } else if ( texto . matches ( "\\\\*.*" ) && textoanterior . matches ( "<li>.*</li>" ) ) { texto = texto . replaceall ( "\\\\*(.*)" , "<li>$1</li>" ) ; } textoanterior = texto ; textofinal . concat ( texto ) ; } } return textoasertransformado ; }
tr	4	public static void main ( string ... args ) throws exception { final int width = 80 * 19 ; final int height = 80 * 7 ; final bufferedimage image = new bufferedimage ( width , height , bufferedimage . type_4byte_abgr ) ; final graphics2d g = image . creategraphics ( ) ; combine ( g , 0 , loadall ( "fade" , 4 ) ) ; combine ( g , 80 , loadall ( "mask" , 11 ) ) ; combine ( g , 2 * 80 , loadall ( "shine" , 11 ) ) ; combine ( g , 3 * 80 , loadall ( "brow" , 8 ) ) ; combine ( g , 4 * 80 , loadall ( "eyes" , 13 ) ) ; combine ( g , 5 * 80 , loadall ( "pupils" , 11 ) ) ; combine ( g , 6 * 80 , loadall ( "mouth" , 19 ) ) ; imageio . write ( image , "png" , new file ( "./wavatar.png" ) ) ; }
tr	5	public int lengthoflongestsubstring1 ( string s ) { if ( s . length ( ) <= 1 ) return s . length ( ) ; int i = 0 , max = 1 ; int [ ] map = new int [ 256 ] ; for ( int k = 0 ; k < 256 ; k ++ ) map [ k ] = - 1 ; while ( i < s . length ( ) - 1 ) { map [ s . charat ( i ) ] = i ; int j = i + 1 ; for ( ; j < s . length ( ) && ( map [ s . charat ( j ) ] < i || map [ s . charat ( j ) ] == j ) ; j ++ ) { map [ s . charat ( j ) ] = j ; } max = math . max ( max , j - i ) ; if ( j == s . length ( ) ) return max ; i = map [ s . charat ( j ) ] + 1 ; } return max ; }
tr	3	public static int getint ( string prompt ) { int ret = 0 ; scanner s = new scanner ( system . in ) ; int input = - 1 ; while ( input == - 1 ) { system . out . println ( prompt ) ; try { input = integer . parseint ( s . nextline ( ) ) ; } catch ( ioerror e ) { system . out . println ( e . getmessage ( ) ) ; } catch ( numberformatexception e ) { system . out . println ( "please input a valid positive integer" ) ; } finally { s . close ( ) ; s = new scanner ( system . in ) ; } } return ret ; }
tr	7	private void generatepointslocations ( ) { if ( ! this . points . isempty ( ) ) { double locx ; double locy ; double unitdistx = axisx . getunitdistance ( ) ; double unitdisty = axisy . getunitdistance ( ) ; double unitlengthx = axisx . getunitlength ( ) ; double unitlengthy = axisy . getunitlength ( ) ; for ( int i = 0 ; i < this . points . size ( ) ; i ++ ) { locx = originlocation . x + ( points . get ( i ) . x - origin . x ) / unitdistx * unitlengthx ; locy = originlocation . y - ( points . get ( i ) . y - origin . y ) / unitdisty * unitlengthy ; pointslocations . add ( new point2d . double ( locx , locy ) ) ; } } }
tr	4	public message getmessage ( ) throws exception { string jsonmessage = "" ; try { int payloadlen = reader . readint ( ) ; byte [ ] jsonarr = new byte [ payloadlen ] ; if ( reader . read ( jsonarr ) < 1 ) { throw new exception ( "server response was truncated" ) ; } jsonmessage = new string ( jsonarr ) ; } catch ( exception e ) { system . err . println ( "error reading response from server: " + e . tostring ( ) ) ; throw e ; } message message = messagefactory . getservermessage ( jsonmessage ) ; return message ; }
tr	9	public list < aree > getaree ( string area ) throws exception { string name = area ; list < aree > result = new arraylist < aree > ( ) ; string query = "select * from aree where nome = \\"" + area + "\\"" ; statement statement = connection . createstatement ( ) ; resultset rs = statement . executequery ( query ) ; rs . next ( ) ; aree start = bp . tobean ( rs , aree . class ) ; result . add ( start ) ; string parent = start . getparent ( ) ; boolean next = false ; do { query = "select * from aree where nome = \\"" + parent + "\\"" ; rs = statement . executequery ( query ) ; next = rs . next ( ) ; if ( next ) { aree aree = bp . tobean ( rs , aree . class ) ; result . add ( aree ) ; parent = aree . getparent ( ) ; } } while ( parent != null && ! parent . isempty ( ) ) ; return result ; }
tr	3	public static string readline ( inputstream inputstream ) throws ioexception { byte [ ] rawdata = readrawline ( inputstream ) ; if ( rawdata == null ) { return null ; } int len = rawdata . length ; int offset = 0 ; if ( len > 0 ) { if ( rawdata [ len - 1 ] == '\\n' ) { offset ++ ; if ( len > 1 ) { if ( rawdata [ len - 2 ] == '\\r' ) { offset ++ ; } } } } return getstring ( rawdata , 0 , len - offset ) ; }
tr	3	@ override public optional < e > get ( int target ) { if ( this . isempty ( ) ) { return optional . empty ( ) ; } int distance = index - target ; if ( distance == 0 ) { return optional . of ( head ) ; } else if ( distance < 0 ) { return optional . empty ( ) ; } else { int logdistance = calclog2 ( distance ) ; int jumpindex = min ( maxindex , logdistance ) ; return links [ jumpindex ] . get ( target ) ; } }
tr	2	protected void assertequals ( singleparameter xparam , object obj ) { singleparameter param = ( singleparameter ) obj ; object xvalue = xparam . getvalue ( ) ; if ( xvalue instanceof string ) { assert . assertequals ( ( string ) xvalue , ( string ) param . getvalue ( ) ) ; } else if ( xvalue instanceof integer ) { assert . assertequals ( ( integer ) xvalue , ( integer ) param . getvalue ( ) ) ; } else if ( xvalue instanceof boolean ) { assert . assertequals ( ( boolean ) xvalue , ( boolean ) param . getvalue ( ) ) ; } }
tr	1	public void run ( ) { chararraywriter w ; try ( inputstream is = new fileinputstream ( file ) ; reader in = new bufferedreader ( new inputstreamreader ( is , "utf-8" ) ) ) { w = process ( in ) ; } catch ( filenotfoundexception e ) { croak ( "input file not found" , e ) ; return ; } catch ( unsupportedencodingexception e ) { croak ( "utf-8 not supported" , e ) ; return ; } catch ( ioexception e ) { croak ( "i/o exception while processing file" , e ) ; return ; } try ( outputstream os = new fileoutputstream ( file ) ; writer out = new outputstreamwriter ( os , "utf-8" ) ) { w . writeto ( out ) ; } catch ( filenotfoundexception e ) { croak ( "output file not found" , e ) ; return ; } catch ( unsupportedencodingexception e ) { croak ( "utf-8 not supported" , e ) ; return ; } catch ( ioexception e ) { croak ( "i/o exception while writing output file" , e ) ; return ; } }
tr	5	public void handlerequest ( ) { try { sslsession session = socket . getsession ( ) ; certificate cert = session . getpeercertificates ( ) [ 0 ] ; dataoutputstream out = new dataoutputstream ( socket . getoutputstream ( ) ) ; datainputstream in = new datainputstream ( socket . getinputstream ( ) ) ; command cmd = command . parsecommand ( in ) ; system . out . println ( "command parsed: " + cmd ) ; cmd . execute ( out , cert , recordholder ) ; system . out . println ( "command executed" ) ; out . flush ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } }
tr	4	public linkedlist < integer > get_list_from_string ( string pos ) { string temp_str ; temp_str = pos . replaceall ( "[^0-9]" , " " ) ; string [ ] sar = temp_str . split ( "\\\\s+" ) ; linkedlist < integer > intarray = new linkedlist < integer > ( ) ; for ( int i = 0 ; i < sar . length ; i ++ ) { if ( ( sar [ i ] . compareto ( "" ) != 0 ) ) { intarray . add ( integer . parseint ( sar [ i ] ) ) ; } } return intarray ; }
tr	4	public arraylist < int [ ] > nonfriendsmeetingfreq ( ) { int k = user . alluserset . size ( ) ; for ( int i = 0 ; i < k ; i ++ ) for ( int j = i + 1 ; j < k ; j ++ ) { if ( nonfriend ( i , j ) && meetfreq . get ( i ) . get ( j ) > 0 ) { int [ ] tuple = { i , j , meetfreq . get ( i ) . get ( j ) } ; nonfriendmeeting . add ( tuple ) ; } } return nonfriendmeeting ; }
tr	8	public static void main ( string [ ] args ) { evalsumaccumulator accumulator = new evalsumaccumulator ( ) ; string [ ] operands = getoperands ( ) ; list < string > assocs = new associationgenrator ( operands ) . getassociations ( ) ; list < string > opseqs = new operatorsequencegenrator ( operands . length - 1 ) . getsequence ( ) ; int count = 0 ; for ( string opseq : opseqs ) { string [ ] operators = splitandgetasarray ( opseq ) ; if ( isassociativesequence ( opseq ) ) { accumulator . accumulate ( string . format ( assocs . get ( 0 ) , ( object [ ] ) operators ) ) ; count ++ ; continue ; } for ( string assoc : assocs ) { accumulator . accumulate ( string . format ( assoc , ( object [ ] ) operators ) ) ; count ++ ; } } system . out . println ( accumulator . getfirstminimumimpossiblenumber ( ) ) ; }
tr	5	public integer getfirstminimumimpossiblenumber ( ) { if ( this . expressionreductions . isempty ( ) ) { return 0 ; } if ( this . expressionreductions . size ( ) == 1 ) { return expressionreductions . first ( ) + 1 ; } int index = 0 , seqlen = this . expressionreductions . size ( ) ; integer [ ] values = this . expressionreductions . toarray ( new integer [ 0 ] ) ; int currnum , nextnum ; while ( index < seqlen ) { currnum = values [ index ] ; nextnum = values [ index + 1 ] ; if ( nextnum - currnum != 1 ) { return currnum + 1 ; } index ++ ; } return values [ index - 1 ] + 1 ; }
tr	3	public board ( arraylist < cellstructure > list ) { tablica = new boolean [ tablica_length + 1 ] [ tablica_length + 1 ] ; for ( int i = 0 ; i < tablica_length ; i ++ ) { for ( int j = 0 ; j < tablica_length ; j ++ ) { tablica [ i ] [ j ] = false ; } } for ( int a = 0 ; a < list . size ( ) ; a ++ ) { tablica [ list . get ( a ) . getx ( ) ] [ list . get ( a ) . gety ( ) ] = list . get ( a ) . isvalue ( ) ; } }
tr	2	@ override public void onenable ( ) { log_header = "[" + this . getname ( ) + "]" ; randomgenerator = new random ( ) ; pluginfolder = getdatafolder ( ) ; configfile = new file ( pluginfolder , "config.yml" ) ; this . savedefaultconfig ( ) ; loadtrophyconfig ( this . getserver ( ) . getconsolesender ( ) ) ; getserver ( ) . getpluginmanager ( ) . registerevents ( this , this ) ; getcommand ( "headspawn" ) . setexecutor ( new headspawncommand ( this ) ) ; getcommand ( "headgive" ) . setexecutor ( new headgivecommand ( this ) ) ; getcommand ( "trophyreload" ) . setexecutor ( new reloadcommand ( this ) ) ; if ( renameenabled ) { itemstack resulthead = new itemstack ( material . skull_item , 1 , ( byte ) 3 ) ; shapelessrecipe shapelessrecipe = new shapelessrecipe ( resulthead ) ; shapelessrecipe . addingredient ( 1 , material . skull_item ) ; shapelessrecipe . addingredient ( 1 , renameitem ) ; getserver ( ) . addrecipe ( shapelessrecipe ) ; } }
tr	5	public int longestconsecutive ( int [ ] num ) { hashmap < integer , boolean > maps = new hashmap < integer , boolean > ( ) ; int maxlengh = 0 ; for ( int i = 0 ; i < num . length ; i ++ ) maps . put ( num [ i ] , false ) ; for ( int i = 0 ; i < num . length ; i ++ ) { if ( maps . get ( num [ i ] ) == true ) continue ; int length = 1 ; int j = num [ i ] + 1 ; maps . put ( num [ i ] , true ) ; while ( maps . containskey ( j ) ) { maps . put ( j , true ) ; j ++ ; length ++ ; } j = num [ i ] - 1 ; while ( maps . containskey ( j ) ) { maps . put ( j , true ) ; j -- ; length ++ ; } if ( length > maxlengh ) maxlengh = length ; } return maxlengh ; }
tr	8	public static void main ( string [ ] args ) { int a = 8 ; int b = 10 ; int c = b - a ; for ( int i = 0 ; i < c ; ++ i ) { system . out . println ( constant_str + "!" ) ; } fundamentals fund1 = new fundamentals ( 1 ) ; fundamentals fund2 = new fundamentals ( 1 ) ; fundamentals fund3 = new fundamentals ( 2 ) ; fundamentals fund4 = fund3 ; if ( fund1 == fund2 ) { system . out . println ( "fund1 == fund2" ) ; } else { system . out . println ( "fund1 != fund2" ) ; } if ( fund1 . equals ( fund2 ) ) { system . out . println ( "fund1 equals fund2" ) ; } else { system . out . println ( "fund1 not equals fund2" ) ; } if ( fund3 == fund4 ) { system . out . println ( "fund3 == fund4" ) ; } else { system . out . println ( "fund3 != fund4" ) ; } if ( fund3 . equals ( fund4 ) ) { system . out . println ( "fund3 equals fund4" ) ; } else { system . out . println ( "fund3 not equals fund4" ) ; } fund1 . shownumber ( ) ; fund2 . shownumber ( ) ; fund3 . shownumber ( ) ; fund4 . shownumber ( ) ; }
tr	5	public stringbuilder dohvatisadrzajdatoteke ( string naziv ) { stringbuilder sadrzaj = new stringbuilder ( ) ; try { string outputline ; file file = new file ( nazivspremista + "\\\\" + naziv ) ; if ( ! file . exists ( ) ) { setchanged ( ) ; notifyobservers ( "datoteka izbrisna<litcomma> citam sa stranice!" ) ; return null ; } filereader fr = new filereader ( file ) ; bufferedreader br = new bufferedreader ( fr ) ; while ( ( outputline = br . readline ( ) ) != null ) { sadrzaj . append ( outputline ) ; sadrzaj . append ( "\\n" ) ; } br . close ( ) ; } catch ( ioexception ex ) { logger . getlogger ( cacheimpl . class . getname ( ) ) . log ( level . severe , null , ex ) ; } return sadrzaj ; }
tr	6	public string sendcommand ( command cmd ) throws ioexception { dataoutputstream out = new dataoutputstream ( socket . getoutputstream ( ) ) ; datainputstream in = new datainputstream ( socket . getinputstream ( ) ) ; cmd . write ( out ) ; int result = in . readint ( ) ; int messagelength = in . readint ( ) ; byte [ ] msgbytes = new byte [ messagelength ] ; in . readfully ( msgbytes ) ; string message = new string ( msgbytes ) ; if ( result == 1 ) { throw new ioexception ( message ) ; } return message ; }
tr	10	private static final string replacepropertiesrec ( string value , map < string , object > conf , list < string > fragments , list < string > propertyrefs , int depth , boolean encodehtml , string defaultreplacement , macroparamprocessor paramprocessor , evaluator evaluator ) throws propertyparsingexception { parsepropertystring ( value , fragments , propertyrefs ) ; final stringbuilder unkownparam = new stringbuilder ( ) ; final stringbuilder sb = new stringbuilder ( ) ; final iterator < string > i = fragments . iterator ( ) ; final iterator < string > j = propertyrefs . iterator ( ) ; while ( i . hasnext ( ) ) { string fragment = ( string ) i . next ( ) ; if ( fragment == null ) { final string propertyname = ( string ) j . next ( ) ; fragment = evaluator . eval ( conf , propertyname , defaultreplacement , paramprocessor , encodehtml ) ; final boolean sameproperty = fragment . indexof ( ref_prefix + propertyname + ref_suffix ) >= 0 ; final boolean alwaysproperty = containproperty ( fragment ) ; if ( alwaysproperty && ! sameproperty ) { unkownparam . append ( fragment ) ; } } sb . append ( fragment ) ; } final boolean containproperty = containproperty ( unkownparam . tostring ( ) ) ; final string expandedvalue = sb . tostring ( ) ; if ( containproperty && depth <= max_depth ) { fragments . clear ( ) ; propertyrefs . clear ( ) ; return replacepropertiesrec ( expandedvalue , conf , fragments , propertyrefs , depth + 1 , encodehtml , defaultreplacement , paramprocessor , evaluator ) ; } else if ( containproperty && depth > max_depth ) throw new propertyparsingexception ( more_than_0_level_to_expand_1 . format ( new object [ ] { max_depth , expandedvalue } ) ) ; else return expandedvalue ; }
tr	1	public fullexamplesub ( ) { super ( "subscriber example" ) ; setbounds ( 100 , 100 , 300 , 200 ) ; cl = new spacebrew ( this ) ; cl . addsubscribe ( "a boolean subscriber" , "boolean" , "onbooleanreceive" ) ; cl . addsubscribe ( "a range subscriber" , "range" , "onrangereceive" ) ; cl . addsubscribe ( "a string subscriber" , "string" , "onstringreceive" ) ; cl . addsubscribe ( "a custom subscriber" , "x<litcomma>y" , "oncustomreceive" ) ; cl . connect ( hostname , "myfullsubscriber" , "a pure java subscriber" ) ; setdefaultcloseoperation ( jframe . exit_on_close ) ; container con = this . getcontentpane ( ) ; con . add ( pane ) ; pane . add ( label1 ) ; pane . add ( label2 ) ; pane . add ( label3 ) ; setvisible ( true ) ; }
tr	2	public void dohvatiserializaciju ( ) { fileinputstream filein ; try { filein = new fileinputstream ( nazivspremista + "\\\\serijalizacija.ser" ) ; postoji = true ; ztintor_zadaca_4 . ser = true ; objectinputstream in ; in = new objectinputstream ( filein ) ; list = ( arraylist ) in . readobject ( ) ; in . close ( ) ; filein . close ( ) ; } catch ( filenotfoundexception ex ) { setchanged ( ) ; notifyobservers ( "ne postoji datoteka serializacije" ) ; postoji = false ; ztintor_zadaca_4 . ser = false ; } catch ( ioexception ex ) { logger . getlogger ( ztintor_zadaca_4 . class . getname ( ) ) . log ( level . severe , null , ex ) ; } catch ( classnotfoundexception ex ) { logger . getlogger ( ztintor_zadaca_4 . class . getname ( ) ) . log ( level . severe , null , ex ) ; } }
tr	6	private void movelocal ( ) { double [ ] [ ] gradients = new double [ ncircles ] [ 2 ] ; for ( int i = 0 ; i < ncircles ; i ++ ) { centers [ i ] [ 0 ] += stepsize ; double xplus = computestress ( ) ; centers [ i ] [ 0 ] -= 2 * stepsize ; double xminus = computestress ( ) ; centers [ i ] [ 0 ] += stepsize ; if ( xplus < xminus ) gradients [ i ] [ 0 ] = stepsize ; else gradients [ i ] [ 0 ] = - stepsize ; centers [ i ] [ 1 ] += stepsize ; double yplus = computestress ( ) ; centers [ i ] [ 1 ] -= 2 * stepsize ; double yminus = computestress ( ) ; centers [ i ] [ 1 ] += stepsize ; if ( yplus < yminus ) gradients [ i ] [ 1 ] = stepsize ; else gradients [ i ] [ 1 ] = - stepsize ; } for ( int i = 0 ; i < ncircles ; i ++ ) { centers [ i ] [ 0 ] += gradients [ i ] [ 0 ] ; centers [ i ] [ 1 ] += gradients [ i ] [ 1 ] ; } }
tr	9	@ override public void editarproduto ( string codigo ) { boolean retorno = false ; string codigonovo , descricaonova , categorianova ; int qtdestoqnova ; double precovendanovo ; int indexlista = 0 , editar ; for ( int i = 0 ; i < listprodutos . size ( ) ; i ++ ) { if ( listprodutos . get ( i ) . getcodigo ( ) . equals ( codigo ) ) { retorno = true ; indexlista = i ; } } if ( retorno ) { system . out . println ( "\\n preparando para editar..." ) ; try { editar = integer . parseint ( joptionpane . showinputdialog ( "qual op\xe7\xe3o deseja editar? \\n1)pre\xe7o\\n2)descri\xe7\xe3o\\n3)qtdade\\n4)categoria" ) ) ; } catch ( numberformatexception io ) { system . err . println ( "essa entrada necessita ser um n\xfamero<litcomma> tente novamente." ) ; editar = integer . parseint ( joptionpane . showinputdialog ( "qual op\xe7\xe3o deseja editar? \\n1)pre\xe7o\\n2)descri\xe7\xe3o\\n3)qtdade\\n4)categoria" ) ) ; } switch ( editar ) { case 1 : precovendanovo = double . parsedouble ( joptionpane . showinputdialog ( "qual ser\xe1 o novo valor desse produto?" ) ) ; listprodutos . get ( indexlista ) . setprecovenda ( precovendanovo ) ; break ; case 2 : descricaonova = joptionpane . showinputdialog ( "digite a nova descri\xe7\xe3o:" ) ; listprodutos . get ( indexlista ) . setdescricao ( descricaonova ) ; break ; case 3 : qtdestoqnova = integer . parseint ( joptionpane . showinputdialog ( "entre com a nova quantidade de estoque:" ) ) ; listprodutos . get ( indexlista ) . setqtdestoq ( qtdestoqnova ) ; break ; case 4 : categorianova = joptionpane . showinputdialog ( "digite a nova categoria:" ) ; listprodutos . get ( indexlista ) . setcategoria ( categorianova ) ; break ; default : joptionpane . showmessagedialog ( null , "entrada inv\xe1lida." ) ; break ; } } else { system . out . println ( "\\nproduto n\xe3o cadastrado." ) ; } }
tr	1	public static void main ( string [ ] args ) { graphicaluserinterface gui = new graphicaluserinterface ( ) ; gui . setdefaultcloseoperation ( jframe . exit_on_close ) ; gui . setsize ( ( system . getproperty ( "os.name" ) . contains ( "windows" ) ) ? ( width + 4 ) : width , ( system . getproperty ( "os.name" ) . contains ( "windows" ) ) ? ( height + 5 ) : height ) ; gui . seticonimage ( toolkit . getdefaulttoolkit ( ) . getimage ( gui . getclass ( ) . getresource ( "images/application_icon.png" ) ) ) ; gui . setresizable ( false ) ; gui . setvisible ( true ) ; }
tr	5	private void collect ( string rootpath , list < string > filenames ) { file dir = new file ( rootpath ) ; file [ ] files = dir . listfiles ( ) ; if ( files == null ) { return ; } for ( int i = 0 ; i < files . length ; i ++ ) { file file = files [ i ] ; if ( file . isdirectory ( ) ) { if ( ! file . ishidden ( ) ) { collect ( file . getabsolutepath ( ) , filenames ) ; } } else { if ( filepattern . matcher ( file . getabsolutepath ( ) ) . find ( ) ) { string strfilename = file . getabsolutepath ( ) ; filenames . add ( strfilename ) ; } } } }
tr	7	@ test public void testqueryvideo ( ) { solrquery query = new solrquery ( ) ; query . set ( "q" , "video" ) ; query . addfacetfield ( "cat" ) ; query . setfacetlimit ( 10 ) ; query . setfacetmincount ( 1 ) ; try { queryresponse response = server . query ( query ) ; solrdocumentlist docs = response . getresults ( ) ; for ( solrdocument doc : docs ) { logger . info ( "the doc name:{}" , doc . getfieldvalue ( "id" ) . tostring ( ) ) ; } logger . info ( "\\n================================" ) ; list < facetfield > fflist = response . getfacetfields ( ) ; if ( fflist != null ) { for ( facetfield ff : fflist ) { for ( count c : ff . getvalues ( ) ) { logger . info ( "{}-{}" , c . getname ( ) , c . getcount ( ) ) ; } } } logger . info ( "\\n================================" ) ; logger . info ( "eleased time: {}" , response . getelapsedtime ( ) ) ; } catch ( solrserverexception e ) { logger . error ( e . getmessage ( ) , e ) ; } }
tr	1	public void ispispoveznica ( ) { m . dohvatilistupoveznica ( ) ; system . out . println ( "---------poveznice-------------" ) ; ispisilinije ( m . getmax ( ) ) ; for ( int i = 0 ; i < m . getwebstranica ( ) . getlistaurla ( ) . size ( ) ; i ++ ) { system . out . print ( "| " + ( i + 1 ) + "." ) ; ispisiprazninebroja ( ( integer . tostring ( m . getwebstranica ( ) . getlistaurla ( ) . size ( ) ) . length ( ) - integer . tostring ( i + 1 ) . length ( ) ) + 1 ) ; system . out . print ( "|  " + m . getwebstranica ( ) . getlistaurla ( ) . get ( i ) ) ; ispisipraznineurla ( m . getmax ( ) - m . getwebstranica ( ) . getlistaurla ( ) . get ( i ) . tostring ( ) . length ( ) ) ; ispisilinije ( m . getmax ( ) ) ; } }
tr	5	public static void addtopkuser ( int k ) { try { bufferedreader fin = new bufferedreader ( new filereader ( "res/usercheckins-rank.txt" ) ) ; string l = null ; int c = 0 ; while ( ( l = fin . readline ( ) ) != null ) { string [ ] ls = l . split ( "\\t" ) ; int uid = integer . parseint ( ls [ 0 ] ) ; new user ( uid ) ; c ++ ; if ( c == k ) break ; } fin . close ( ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } system . out . println ( string . format ( "%d users have been initailized." , k ) ) ; }
tr	7	@ override public boolean oncommand ( commandsender sender , command cmd , string commandlabel , string [ ] args ) { if ( sender instanceof player ) { player player = ( player ) sender ; if ( player . haspermission ( "trophyheads.spawn" ) ) { string pname = player . getname ( ) ; int count = 1 ; if ( args . length >= 1 ) { pname = args [ 0 ] ; if ( args . length == 2 ) { if ( args [ 1 ] . matches ( "\\\\d+" ) ) { count = integer . parseint ( args [ 1 ] ) ; } } } itemstack item = new itemstack ( material . skull_item , count , ( byte ) 3 ) ; location loc = player . getlocation ( ) . clone ( ) ; world world = loc . getworld ( ) ; itemmeta itemmeta = item . getitemmeta ( ) ; ( ( skullmeta ) itemmeta ) . setowner ( pname ) ; item . setitemmeta ( itemmeta ) ; plugin . logdebug ( "skull: " + item . tostring ( ) ) ; if ( player . getinventory ( ) . firstempty ( ) > - 1 ) { player . sendmessage ( "placed " + chatcolor . gold + pname + "'s head " + chatcolor . reset + " in your inventory." ) ; player . getinventory ( ) . setitem ( player . getinventory ( ) . firstempty ( ) , item ) ; } else { player . sendmessage ( "dropped " + chatcolor . gold + pname + "'s head" + chatcolor . reset + " on the ground because your inventory was full." ) ; world . dropitemnaturally ( loc , item ) ; } } else { player . sendmessage ( chatcolor . red + "you do not have permission to use this command." ) ; } } else { sender . sendmessage ( chatcolor . red + "only a player can use this command! try the headgive command instead." ) ; } return true ; }
tr	10	public set < integer > notavaiports ( ) { string [ ] commands = new string [ 2 ] ; commands [ 0 ] = "netstat" ; commands [ 1 ] = "-an" ; processbuilder pb = new processbuilder ( ) ; pb . command ( commands ) ; try { process process = pb . start ( ) ; process . waitfor ( ) ; string netout = ioutils . tostring ( process . getinputstream ( ) ) ; stringtokenizer rowst = new stringtokenizer ( netout , mystringutils . line_separator ) ; rowst . nextelement ( ) ; rowst . nextelement ( ) ; set < integer > notavaiportset = new hashset < integer > ( ) ; while ( rowst . hasmoreelements ( ) ) { string row = ( string ) rowst . nextelement ( ) ; stringtokenizer wordst = new stringtokenizer ( row ) ; wordst . nextelement ( ) ; wordst . nextelement ( ) ; wordst . nextelement ( ) ; string addr = ( string ) wordst . nextelement ( ) ; if ( addr . contains ( : ) ) { string port = addr . substring ( addr . lastindexof ( : ) + 1 ) ; notavaiportset . add ( integer . valueof ( port ) ) ; } } return notavaiportset ; } catch ( ioexception e ) { throw myexceptionutils . uncheckexception ( e ) ; } catch ( interruptedexception e ) { throw myexceptionutils . uncheckexception ( e ) ; } }
tr	8	public void generate ( land [ ] [ ] world ) { int width = world . length ; int depth = world [ 0 ] . length ; int centerx = width / 2 ; int centerz = depth / 2 ; float maxdist = ( float ) math . sqrt ( ( centerx ) * ( centerx ) + ( centerz ) * ( centerz ) ) ; system . out . println ( maxdist ) ; for ( int i = 0 ; i < width ; i ++ ) { for ( int j = 0 ; j < depth ; j ++ ) { float grad = 1 - ( ( float ) math . sqrt ( ( i - centerx ) * ( i - centerx ) + ( j - centerz ) * ( j - centerz ) ) / maxdist ) ; grad *= grad * grad * grad * 3 ; world [ i ] [ j ] . height *= grad ; } } }
tr	6	protected list < string > getassociations_ ( list < string > tokens ) { list < string > res = new arraylist < > ( ) ; if ( 1 == tokens . size ( ) ) { res . add ( tokens . get ( 0 ) ) ; } else { for ( int i = 0 ; i < tokens . size ( ) ; ++ i ) { list < string > left = tokens . sublist ( 0 , i ) , right = tokens . sublist ( i , tokens . size ( ) ) ; for ( string l : getassociations_ ( left ) ) { for ( string r : getassociations_ ( right ) ) { res . add ( "(" . concat ( l ) . concat ( " %s " ) . concat ( r ) . concat ( ")" ) ) ; } } } } return res ; }
tr	8	static public final char [ ] rlestringtochararray ( string s ) { int length = ( ( ( int ) s . charat ( 0 ) ) << 16 ) | ( ( int ) s . charat ( 1 ) ) ; char [ ] array = new char [ length ] ; int ai = 0 ; for ( int i = 2 ; i < s . length ( ) ; ++ i ) { char c = s . charat ( i ) ; if ( c == escape ) { c = s . charat ( ++ i ) ; if ( c == escape ) { array [ ai ++ ] = c ; } else { int runlength = ( int ) c ; char runvalue = s . charat ( ++ i ) ; for ( int j = 0 ; j < runlength ; ++ j ) array [ ai ++ ] = runvalue ; } } else { array [ ai ++ ] = c ; } } if ( ai != length ) throw new illegalstateexception ( "bad run-length encoded short array" ) ; return array ; }
tr	6	protected void createrandomchromosomes ( ) { int [ ] newchromosomes = new int [ numberofchromosomes ] ; int crosssum = 0 ; boolean startfromend = false ; if ( getrandom ( ) < 0.5 ) { startfromend = true ; } for ( int i = 0 ; i < newchromosomes . length ; i ++ ) { if ( getrandom ( ) < 0.25 ) { continue ; } int nextvalue = createrandomchromosomevalue ( ) ; if ( crosssum + nextvalue > maxcrosssum ) { nextvalue = maxcrosssum - crosssum ; } crosssum += nextvalue ; int position = i ; if ( startfromend ) { position = newchromosomes . length - ( i + 1 ) ; } newchromosomes [ position ] = nextvalue ; } this . chromosomes = newchromosomes ; }
tr	6	public int longestvalidparentheses ( string s ) { stack < character > a = new stack < character > ( ) ; int size = 0 ; int longest = 0 ; char [ ] arrays = s . tochararray ( ) ; for ( char x : arrays ) { if ( x == '(' ) { a . push ( x ) ; } else { if ( a . empty ( ) ) { size = 0 ; } else { size ++ ; if ( a . empty ( ) && size > longest ) longest = size ; } } } size = 0 ; a . clear ( ) ; for ( int i = arrays . length - 1 ; i >= 0 ; i -- ) { char x = arrays [ i ] ; if ( x == ')' ) { a . push ( x ) ; } else { if ( a . empty ( ) ) { size = 0 ; } else { size ++ ; if ( a . empty ( ) && size > longest ) longest = size ; } } } return longest * 2 ; }
tr	1	public fullexamplepub ( ) { super ( "publisher example" ) ; setbounds ( 100 , 100 , 300 , 200 ) ; cl = new spacebrew ( this ) ; cl . addpublish ( "a boolean publisher" , false ) ; cl . addpublish ( "a range publisher" , 0 ) ; cl . addpublish ( "a string publisher" , "" ) ; cl . addpublish ( "a custom publisher" , "x<litcomma>y" , "" ) ; cl . connect ( hostname , "myfullpublisher" , "a pure java publisher" ) ; setdefaultcloseoperation ( jframe . exit_on_close ) ; container con = this . getcontentpane ( ) ; con . add ( pane ) ; button . addmouselistener ( this ) ; slider . addchangelistener ( this ) ; text . addkeylistener ( this ) ; pane . addmousemotionlistener ( this ) ; text . setpreferredsize ( new dimension ( 200 , 20 ) ) ; pane . add ( button ) ; pane . add ( slider ) ; pane . add ( text ) ; setvisible ( true ) ; }
tr	8	private static string [ ] [ ] load_servers ( string filename ) { string [ ] [ ] array = null ; try { filereader fr = new filereader ( filename ) ; bufferedreader fp = new bufferedreader ( fr ) ; list < string > ip_addresses = new arraylist < string > ( ) ; list < string > names = new arraylist < string > ( ) ; string line ; while ( ( line = fp . readline ( ) ) != null ) { string [ ] words = line . split ( " " ) ; ip_addresses . add ( words [ 0 ] ) ; names . add ( words [ 1 ] ) ; } array = new string [ ip_addresses . size ( ) ] [ 2 ] ; for ( int cnt = 0 ; cnt < ip_addresses . size ( ) ; ++ cnt ) { array [ cnt ] [ 0 ] = ip_addresses . get ( cnt ) ; array [ cnt ] [ 1 ] = names . get ( cnt ) ; } } catch ( ioexception e ) { e . printstacktrace ( ) ; } return array ; }
tr	7	@ test public void getincorrectordercashmethod ( ) throws notenoughmoneyinaccount , notenoughmoneyinatm { account acc = mock ( account . class ) ; card card = mock ( card . class ) ; atm atm = new atm ( acc , card ) ; double ammount = 500.0 ; double accountbalance = 700 ; double moneyfromatm = 1000 ; when ( acc . getbalance ( ) ) . thenreturn ( accountbalance ) ; atm . getcash ( ammount , accountbalance , moneyfromatm ) ; inorder order = inorder ( acc ) ; order . verify ( acc , times ( 1 ) ) . getbalance ( ) ; order . verify ( acc , times ( 1 ) ) . withdraw ( anydouble ( ) ) ; }
tr	5	public boolean istelno ( string telno ) { string regex = "^((13[0-9])|(14[0-9])|(15[^4<litcomma>\\\\d])|(18[^4<litcomma>\\\\d]))\\\\d{8}$" ; pattern p = pattern . compile ( regex ) ; if ( telno . contains ( "|" ) ) { string telnos [ ] = telno . split ( "[|]" ) ; for ( string tel : telnos ) { matcher m = p . matcher ( tel ) ; if ( ! m . matches ( ) ) { logger . log ( level . info , "telno: {0} is not valid" , tel ) ; return false ; } } } else { matcher m = p . matcher ( telno ) ; if ( ! m . matches ( ) ) { logger . log ( level . info , "telno: {0} is not valid" , telno ) ; return false ; } } return true ; }
tr	8	public logstatement parselogstatement ( string line ) { matcher matcher = log_message_pattern . matcher ( line ) ; if ( matcher . matches ( ) ) { string time = matcher . group ( "time" ) ; localtime localtime = parselocaltime ( time ) ; string levelstring = matcher . group ( "level" ) ; level level = parselevel ( levelstring ) ; string clazzstring = matcher . group ( "class" ) ; clazz clazz = classrepository . cachedclazz ( clazzstring ) ; string message = matcher . group ( "message" ) ; return new logstatement ( localtime , level , clazz , message ) ; } return null ; }
tr	3	private void expandtree ( treenode start , string [ ] path ) { for ( string item : path ) { for ( treenode node : start . getchildren ( ) ) { urldocument doc = ( urldocument ) node . getdata ( ) ; if ( doc . getname ( ) . matches ( item ) ) { node . getparent ( ) . setexpanded ( true ) ; start = node ; break ; } } } setselectednode ( start ) ; urldocument doc = ( urldocument ) start . getdata ( ) ; displaydoc . setdoc ( doc ) ; cruddoc . settreecontrol ( this ) ; cruddoc . setdoc ( doc ) ; }
tr	6	public sentence replacewh ( string info ) { list < word > words = joinsubjectobject ( ) ; string s = this . printwords ( words , 1 ) ; string [ ] wh = { "what" , "where" , "when" , "why" , "how" , "who" , "which" } ; for ( int i = 0 ; i < wh . length ; i ++ ) { s = s . replace ( wh [ i ] , "" ) . trim ( ) ; } string [ ] ss = info . split ( "([\\\\.!?])\\\\s+" ) ; for ( int i = 0 ; i < ss . length ; i ++ ) { if ( ss [ i ] . contains ( s ) ) { sentence sn = new sentence ( ss [ i ] ) ; return sn ; } } return null ; }
tr	10	public void getinput ( ) { scanner scanner = new scanner ( system . in ) ; int n , k = 0 , num , total = 0 , minbricks = 0 , serial = 0 ; int [ ] values ; while ( scanner . hasnextint ( ) ) { n = scanner . nextint ( ) ; if ( n == 0 ) break ; values = new int [ n ] ; serial ++ ; for ( int i = 0 ; i < n ; i ++ ) { num = scanner . nextint ( ) ; values [ i ] = num ; total += num ; } minbricks = total / n ; for ( int j = 0 ; j < n ; j ++ ) { if ( values [ j ] > minbricks ) k += values [ j ] - minbricks ; } minbricks = 0 ; total = 0 ; system . out . println ( "set #" + serial ) ; system . out . println ( "the minimum number of moves is " + k + "." ) ; system . out . println ( ) ; k = 0 ; } }
tr	4	public fourinrowpuzzle ( fourinrowpuzzle b ) { this . holes = new puzzlehole [ 6 ] [ 7 ] ; for ( int i = 0 ; i < 6 ; i ++ ) { for ( int j = 0 ; j < 7 ; j ++ ) { this . holes [ i ] [ j ] = new puzzlehole ( ) ; } } for ( int row = 0 ; row < fourinrowpuzzle . hieght ; row ++ ) { for ( int column = 0 ; column < fourinrowpuzzle . hieght ; column ++ ) { this . holes [ row ] [ column ] . setcolor ( b . holes [ row ] [ column ] . getcolor ( ) ) ; } } }
tr	3	public arraylist < integer > getrow ( int rowindex ) { arraylist < integer > res = new arraylist < integer > ( ) ; for ( int i = 0 ; i < rowindex + 1 ; i ++ ) { res . add ( 0 , 1 ) ; for ( int j = 1 ; j < res . size ( ) - 1 ; j ++ ) { res . set ( j , res . get ( j + 1 ) + res . get ( j ) ) ; } } return res ; }
tr	1	@ at public boolean login ( @ param ( "name" ) string name , @ param ( "passwd" ) string passwd , httpsession session ) { if ( strings . isblank ( name ) || strings . isblank ( passwd ) ) { return false ; } name = name . trim ( ) . intern ( ) ; passwd = passwd . trim ( ) . intern ( ) ; user user = dao . fetch ( user . class , cnd . where ( "name" , "=" , name ) . and ( "passwd" , "=" , passwd ) ) ; if ( user == null ) { return false ; } else { session . setattribute ( "user" , user ) ; return true ; } }
tr	2	public static void generate ( string reportname , reportstypes type , map < string , object > params , outputstream out , connection conn ) throws filenotfoundexception , jrexception { reportfileutil rfile = reportfileutil . getreport ( reportname ) ; jasperprint jprint = jasperfillmanager . fillreport ( new fileinputstream ( rfile . getrelatorio ( ) ) , params , conn ) ; switch ( type ) { case pdf : makepdf ( jprint , out ) ; break ; case xls : makexls ( jprint , out ) ; break ; case html : makehtml ( jprint , out ) ; break ; case xml : makexml ( jprint , out ) ; break ; default : break ; } }
tr	10	private void postmenuview ( ) { string statementstring = "select * from posts" ; try { statement statement = connection . createstatement ( ) ; resultset rs = statement . executequery ( statementstring ) ; string columnnames = "id\\t\\t contributorid\\t goalid\\t\\tdataandtime\\t\\tbody" ; system . out . println ( columnnames ) ; while ( rs . next ( ) ) { int id = rs . getint ( "id" ) ; string body = rs . getstring ( "body" ) ; string dateandtime = rs . getstring ( "dateandtime" ) ; int contributorid = rs . getint ( "contributorid" ) ; int goalid = rs . getint ( "goalid" ) ; string postline = string . format ( "%d\\t\\t%d\\t\\t %d\\t\\t %s\\t %s" , id , contributorid , goalid , dateandtime , body ) ; system . out . println ( postline ) ; } } catch ( sqlexception sqe ) { system . out . println ( "there was an error in retrieving the posts." ) ; } }
tr	8	@ suppresswarnings ( "unchecked" ) public static void main ( string [ ] args ) { commandlineparser parser = new posixparser ( ) ; commandline cmd ; try { cmd = parser . parse ( options , args ) ; } catch ( missingoptionexception e ) { for ( object obj : options . getoptions ( ) ) { option opt = ( option ) obj ; out ( opt . tostring ( ) + ( opt . isrequired ( ) ? " - required" : " - optional" ) ) ; } return ; } catch ( parseexception e ) { out ( "error parsing arguments" ) ; e . printstacktrace ( ) ; return ; } string basedir = cmd . getoptionvalue ( 'b' ) ; string [ ] filenames = cmd . getoptionvalue ( 'f' ) . split ( "<litcomma>" ) ; map < string , object > model = new hashmap < > ( ) ; if ( cmd . hasoption ( "m" ) ) { gson gson = new gson ( ) ; model = gson . fromjson ( cmd . getoptionvalue ( 'm' ) , hashmap . class ) ; } mergeandprint ( basedir , filenames , model , ! cmd . hasoption ( 'u' ) ) ; }
tr	7	public vector < site > findbabysites ( ) { vector < site > babysites = new vector < site > ( ) ; for ( int m = - 1 ; m <= 1 ; m ++ ) { for ( int n = - 1 ; n <= 1 ; n ++ ) { site site ; int x = xposition + m ; int y = yposition + n ; if ( x >= 0 && x < sim . xsize && y >= 0 && y < sim . ysize ) { site = sim . grid [ x ] [ y ] ; agent occ = site . getagent ( ) ; if ( occ == null ) { babysites . addelement ( site ) ; } } } } collections . shuffle ( babysites ) ; return babysites ; }
tr	5	public static void main ( string args [ ] ) throws filenotfoundexception , ioexception { if ( args . length != 1 ) { system . out . println ( "invalid argument" ) ; return ; } string file = args [ 0 ] ; configfile test = new configfile ( file ) ; test . load ( ) ; test . print ( ) ; bufferedreader reader = new bufferedreader ( new inputstreamreader ( system . in ) ) ; string line ; while ( ( line = reader . readline ( ) ) != null ) { string [ ] splited = line . split ( " " ) ; switch ( splited [ 0 ] ) { case "store" : case "s" : if ( splited . length == 3 ) test . store ( splited [ 1 ] , splited [ 2 ] ) ; break ; case "get" : case "g" : if ( splited . length == 2 ) system . out . println ( test . get ( splited [ 1 ] ) ) ; break ; case "print" : case "p" : test . print ( ) ; break ; case "save" : if ( splited . length == 1 ) test . save ( ) ; break ; case "quit" : case "q" : return ; } } }
tr	5	private boolean time ( commandsender sender , string [ ] args ) { if ( args . length < 4 ) { sender . sendmessage ( chatcolor . red + "usage: time <add/sub/set> <time> <sec/min/hour/day/week/month>" ) ; return true ; } long time = plugin . parsetimespec ( args [ 2 ] , args [ 3 ] ) ; if ( time == 0 ) { sender . sendmessage ( chatcolor . red + "invalid time format" ) ; return true ; } boolean add = args [ 1 ] . equalsignorecase ( "add" ) , set = args [ 1 ] . equalsignorecase ( "set" ) , - = args [ 1 ] . equalsignorecase ( "sub" ) ; if ( add || set || - ) { if ( ban . endtime == 0 ) { ban . endtime = ban . time ; } if ( add ) { ban . endtime += time ; } else if ( set ) { ban . endtime = ban . time + time ; } else if ( - ) { ban . endtime -= time ; } date date = new date ( ) ; date . settime ( ban . endtime * 1000 ) ; sender . sendmessage ( chatcolor . yellow + "new time: " + chatcolor . white + date . tostring ( ) ) ; return true ; } return false ; }
tr	6	public string toprintablestring ( ) { stringbuilder builder = new stringbuilder ( ) ; int maxnamelength = 0 ; for ( game game : rounds . get ( 0 ) ) maxnamelength = math . max ( math . max ( game . teams [ 0 ] . tostring ( ) . length ( ) , game . teams [ 1 ] . tostring ( ) . length ( ) ) , maxnamelength ) ; int columnwidth = maxnamelength + column_padding + column_prefix_margin + column_suffix_margin ; for ( int line = 0 ; line < print_height ; line ++ ) { for ( int round = 0 ; round < rounds . size ( ) ; round ++ ) { if ( round == 0 ) builder . append ( teamat ( line , round , columnwidth - column_prefix_margin ) ) ; else builder . append ( teamat ( line , round , columnwidth ) ) ; } builder . append ( "\\n" ) ; } return builder . tostring ( ) ; }
tr	8	private void initboard ( ) { this . setlayout ( new gridlayout ( 3 , 3 ) ) ; lineborder blockborder = new lineborder ( color . black , 2 ) ; lineborder cellborder = new lineborder ( color . black , 1 ) ; for ( block block : this . board . getblocks ( ) ) { jpanel blockpanel = new jpanel ( ) ; blockpanel . setlayout ( new gridlayout ( 3 , 3 ) ) ; blockpanel . setborder ( blockborder ) ; for ( final cell cell : block . getcells ( ) ) { final jtextfield celltextfield = new jtextfield ( ) ; int cellvalue = cell . getvalue ( ) ; if ( cellvalue != 0 ) { celltextfield . settext ( string . format ( "{0}" , cellvalue ) ) ; } celltextfield . setborder ( cellborder ) ; celltextfield . getdocument ( ) . adddocumentlistener ( new documentlistener ( ) { @ override public void removeupdate ( documentevent e ) { this . updatecell ( ) ; } @ override public void insertupdate ( documentevent e ) { this . updatecell ( ) ; } @ override public void changedupdate ( documentevent e ) { this . updatecell ( ) ; } private void updatecell ( ) { string celltext = celltextfield . gettext ( ) ; int cellvalue = cell . empty ; if ( ! celltext . isempty ( ) ) { cellvalue = integer . parseint ( celltext ) ; } cell . setvalue ( cellvalue ) ; } } ) ; blockpanel . add ( celltextfield ) ; } this . add ( blockpanel ) ; } }
tr	3	public treecontroller ( ) { root = new defaulttreenode ( new urldocument ( "base" , "about:blank" , ( treenode ) null ) , ( treenode ) null ) ; defaulttreenode top = new defaulttreenode ( new urldocument ( "root" , "about:blank" , root ) , root ) ; selectednode = top ; nodepath = "/root" ; defaulttreenode folder1 = new defaulttreenode ( new urldocument ( "newspapers" , "about:blank" , top ) , top ) ; new defaulttreenode ( new urldocument ( "libe" , "http://www.liberation.fr" , folder1 ) , folder1 ) ; new defaulttreenode ( new urldocument ( "lemonde" , "http://www.lemonde.fr" , folder1 ) , folder1 ) ; defaulttreenode folder2 = new defaulttreenode ( new urldocument ( "web design" , "about:blank" , top ) , top ) ; new defaulttreenode ( new urldocument ( "w3schools" , "http://www.w3schools.com/" , folder2 ) , folder2 ) ; new defaulttreenode ( new urldocument ( "primefaces" , "http://www.primefaces.org/showcase/ui/home.jsf" , folder2 ) , folder2 ) ; new defaulttreenode ( new urldocument ( "prettyfaces" , "http://ocpsoft.org/docs/prettyfaces/3.3.2/en-us/html_single/" , folder2 ) , folder2 ) ; }
tr	9	@ suppresswarnings ( "deprecation" ) public static string invokeget ( string url , map < string , string > params , string encode , int connecttimeout , int sotimeout ) { string responsestring = null ; requestconfig requestconfig = requestconfig . custom ( ) . setsockettimeout ( connecttimeout ) . setconnecttimeout ( connecttimeout ) . setconnectionrequesttimeout ( connecttimeout ) . build ( ) ; stringbuilder sb = new stringbuilder ( ) ; sb . append ( url ) ; int i = 0 ; for ( entry < string , string > entry : params . entryset ( ) ) { if ( i == 0 && ! url . contains ( "?" ) ) { sb . append ( "?" ) ; } else { sb . append ( "&" ) ; } sb . append ( entry . getkey ( ) ) ; sb . append ( "=" ) ; string value = entry . getvalue ( ) ; try { sb . append ( urlencoder . encode ( value , "utf-8" ) ) ; } catch ( unsupportedencodingexception e ) { logger . info ( "encode http get params error<litcomma> value is " + value + e . getmessage ( ) ) ; sb . append ( urlencoder . encode ( value ) ) ; } i ++ ; } logger . info ( "[httputils get] begin invoke:" + sb . tostring ( ) ) ; httpget get = new httpget ( sb . tostring ( ) ) ; get . setconfig ( requestconfig ) ; try { closeablehttpresponse response = httpclient . execute ( get ) ; try { httpentity entity = response . getentity ( ) ; try { if ( entity != null ) { responsestring = entityutils . tostring ( entity , encode ) ; } } finally { if ( entity != null ) { entity . getcontent ( ) . close ( ) ; } } } catch ( exception e ) { logger . info ( string . format ( "[httputils get]get response error<litcomma> url:%s" , sb . tostring ( ) ) + e . getmessage ( ) ) ; return responsestring ; } finally { if ( response != null ) { response . close ( ) ; } } logger . info ( string . format ( "[httputils get]debug url:%s <litcomma> response string %s:" , sb . tostring ( ) , responsestring ) ) ; } catch ( sockettimeoutexception e ) { logger . info ( string . format ( "[httputils get]invoke get timout error<litcomma> url:%s" , sb . tostring ( ) ) + e . getmessage ( ) ) ; return responsestring ; } catch ( exception e ) { logger . info ( string . format ( "[httputils get]invoke get error<litcomma> url:%s" , sb . tostring ( ) ) + e . getmessage ( ) ) ; } finally { get . releaseconnection ( ) ; } return responsestring ; }
tr	1	@ override public void draw ( long ellapsedtime ) { this . m_parent . rectmode ( this . m_parent . corner ) ; this . m_parent . fill ( 255 , this . m_alpha ) ; this . m_parent . rect ( m_topleft . x , m_topleft . y , this . m_width , this . m_height , 7 ) ; this . m_parent . nostroke ( ) ; this . m_parent . fill ( 0 ) ; this . m_parent . textalign ( this . m_parent . top , this . m_parent . left ) ; this . m_parent . text ( this . m_title , this . m_topleft . x + 30 , this . m_topleft . y + 30 ) ; if ( this . m_messages != null ) { for ( int i = 0 ; i < this . m_messages . length ; i ++ ) { this . m_parent . text ( this . m_messages [ i ] , this . m_topleft . x + 30 , this . m_topleft . y + 30 * ( i + 2 ) ) ; } } }
tr	1	public void open ( ) { if ( this . isopen == true ) { return ; } this . isopen = true ; try { display . create ( ) ; display . setfullscreen ( this . fullscreen ) ; display . settitle ( this . title ) ; display . setdisplaymode ( new displaymode ( this . width , this . height ) ) ; for ( drawable drawer : drawers ) { drawer . setup ( ) ; } while ( this . isopen ) { for ( drawable drawer : drawers ) { drawer . draw ( ) ; } display . update ( ) ; display . sync ( this . maxfps ) ; this . isopen = ! display . iscloserequested ( ) ; } for ( drawable drawer : drawers ) { drawer . destroy ( ) ; } this . close ( ) ; } catch ( lwjglexception ex ) { logger . getlogger ( window . class . getname ( ) ) . log ( level . severe , null , ex ) ; system . exit ( 1 ) ; } }
tr	3	public int candy ( int [ ] ratings ) { int [ ] candy = new int [ ratings . length ] ; int res = 0 ; candy [ 0 ] = 1 ; for ( int i = 1 ; i < ratings . length ; i ++ ) { if ( ratings [ i ] > ratings [ i - 1 ] ) { candy [ i ] = candy [ i - 1 ] + 1 ; } else { candy [ i ] = 1 ; } } for ( int i = ratings . length - 2 ; i >= 0 ; i -- ) { if ( ratings [ i ] > ratings [ i + 1 ] ) { candy [ i ] = math . max ( candy [ i ] , candy [ i + 1 ] + 1 ) ; } } for ( int i = 1 ; i < ratings . length ; i ++ ) { res += candy [ i ] ; } return res ; }
tr	10	public string addstring ( string num1 , string num2 ) { string res = "" ; int carryover = 0 ; char [ ] n1 = num1 . tochararray ( ) ; char [ ] n2 = num2 . tochararray ( ) ; for ( int i = n1 . length - 1 , j = n2 . length - 1 ; i >= 0 || j >= 0 ; i -- , j -- ) { int l1 = i < 0 ? 0 : n1 [ i ] - '0' ; int l2 = j < 0 ? 0 : n2 [ j ] - '0' ; int r = l1 + l2 + carryover ; int val = r % 10 ; carryover = r / 10 ; res = string . valueof ( val ) + res ; } if ( carryover > 0 ) res = string . valueof ( carryover ) + res ; return res ; }
tr	8	public static void main ( string [ ] args ) { if ( args . length < 2 ) { system . out . println ( "need training and test file as arguments." ) ; } string trainfile = args [ 0 ] ; string testfile = args [ 1 ] ; wsdparser trainparser = new wsdparser ( trainfile ) ; arraylist < instance > traininstances = trainparser . parse ( strings ( "audience" , "disc" , "plan" , "shelter" ) ) ; naivebayes naivebayestrainer = new naivebayes ( traininstances ) ; naivebayestrainer . train ( ) ; wsdparser testparser = new wsdparser ( testfile ) ; arraylist < instance > testinstances = testparser . parse ( strings ( "audience" , "disc" , "plan" , "shelter" ) ) ; naivebayestester naivebayestester = new naivebayestester ( testinstances , naivebayestrainer ) ; naivebayestester . test ( ) ; }
tr	2	private static void collect ( node node ) { if ( node == null ) return ; if ( node . getnodename ( ) . equals ( "td" ) ) { node classattribute = node . getattributes ( ) . getnameditem ( "class" ) ; if ( classattribute == null ) return ; if ( contentitems . containskey ( classattribute . getnodevalue ( ) ) ) contentitems . put ( classattribute . getnodevalue ( ) , node . gettextcontent ( ) . trim ( ) ) ; } for ( int i = 0 ; i < node . getchildnodes ( ) . getlength ( ) ; i ++ ) collect ( node . getchildnodes ( ) . item ( i ) ) ; }
tr	7	private void drawstage ( stage primarystage ) { primarystage . settitle ( "clientxo" ) ; primarystage . setoncloserequest ( new eventhandler ( ) { @ override public void handle ( event t ) { oncloserequest ( ) ; } } ) ; gridpane maingrid = new gridpane ( ) ; maingrid . setpadding ( new insets ( 5 ) ) ; maingrid . setgridlinesvisible ( true ) ; double playersinfocolumnwidth = 100 ; columnconstraints columnopponentinfo = new columnconstraints ( playersinfocolumnwidth ) ; columnopponentinfo . sethgrow ( priority . never ) ; columnconstraints columnplayerinfo = new columnconstraints ( playersinfocolumnwidth ) ; columnplayerinfo . sethgrow ( priority . never ) ; columnconstraints columncenter = new columnconstraints ( ) ; columncenter . sethgrow ( priority . always ) ; maingrid . getcolumnconstraints ( ) . addall ( columnopponentinfo , columncenter , columnplayerinfo ) ; rowconstraints row = new rowconstraints ( 200 , 200 , double . max_value ) ; row . setvgrow ( priority . always ) ; maingrid . getrowconstraints ( ) . add ( row ) ; maingrid . add ( drawplayerinfo ( labelopponentnick , hpos . right ) , 0 , 0 ) ; maingrid . add ( drawcenterfield ( ) , 1 , 0 ) ; maingrid . add ( drawplayerinfo ( labelplayernick , hpos . left ) , 2 , 0 ) ; scene scene = new scene ( maingrid ) ; primarystage . setscene ( scene ) ; primarystage . show ( ) ; setopponentnick ( "opponent" ) ; setplayernick ( "player" ) ; }
tr	1	private boolean reason ( commandsender sender , string [ ] args ) { if ( args . length < 2 ) { sender . sendmessage ( chatcolor . red + "usage: reason <add/set/show> (text)" ) ; return true ; } if ( args [ 1 ] . equalsignorecase ( "add" ) ) { if ( args . length < 3 ) { sender . sendmessage ( chatcolor . red + "usage: reason add <text>" ) ; return true ; } ban . reason += " " + plugin . combinesplit ( 2 , args , " " ) ; ban . reason = plugin . formatmessage ( ban . reason ) ; return true ; } boolean show = false ; if ( args [ 1 ] . equalsignorecase ( "set" ) ) { if ( args . length < 3 ) { sender . sendmessage ( chatcolor . red + "usage: reason set <text>" ) ; show = true ; } ban . reason = plugin . combinesplit ( 2 , args , " " ) ; ban . reason = plugin . formatmessage ( ban . reason ) ; show = true ; } if ( show || args [ 1 ] . equalsignorecase ( "show" ) ) { sender . sendmessage ( chatcolor . yellow + "reason: " + chatcolor . white + ban . reason ) ; return true ; } return false ; }
tr	6	@ override public object read ( ) throws classnotfoundexception , instantiationexception , illegalaccessexception , securityexception , nosuchfieldexception { int index = stream . indexof ( open_obj ) ; string classname = stream . substring ( 0 , index ) ; class < ? > theclass = class . forname ( classname ) ; object obj = theclass . newinstance ( ) ; int , = stream . indexof ( def_separator , index ) ; string fieldstring = stream . substring ( index + 1 , , ) ; setfield ( theclass , obj , fieldstring ) ; system . out . println ( fieldstring ) ; return obj ; }
tr	8	@ override public void run ( ) { logger . info ( "starting thread for traffic info consumer" ) ; running = true ; try { activemqconnectionfactory connectionfactory = new activemqconnectionfactory ( "vm://localhost" ) ; connection connection = connectionfactory . createconnection ( ) ; connection . start ( ) ; connection . setexceptionlistener ( this ) ; session session = connection . createsession ( false , session . auto_acknowledge ) ; destination trafficinfo = session . createtopic ( trafficjammessagequeues . traffic_info_message_queue ) ; messageconsumer consumer = session . createconsumer ( trafficinfo ) ; while ( running ) { message m = consumer . receive ( 1 ) ; if ( m != null ) { if ( m instanceof objectmessage ) { objectmessage inmessage = ( objectmessage ) m ; trafficinfomessage trafficinfomessage = ( trafficinfomessage ) inmessage . getobject ( ) ; logger . info ( "received message: " + trafficinfomessage ) ; } else { break ; } } } consumer . close ( ) ; session . close ( ) ; connection . close ( ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } }
tr	5	public static arraylist < string > getdirectorylisting ( string url ) throws ioexception { document doc = jsoup . connect ( unity . url + unity . folder + "/" + url ) . get ( ) ; elements extracted_links = doc . select ( "a[href]" ) ; arraylist < string > links = new arraylist < string > ( ) ; for ( int i = 0 ; i < extracted_links . size ( ) ; i ++ ) { string check = extracted_links . get ( i ) . attr ( "href" ) ; if ( ! ( check . contains ( "?c=n;o=d" ) ) && ! ( check . contains ( "?c=m;o=a" ) ) && ! ( check . contains ( "?c=d;o=a" ) ) && ! ( check . contains ( "?c=s;o=a" ) ) && ! ( check . contains ( "content/minecraft/files" ) ) ) { links . add ( extracted_links . get ( i ) . attr ( "href" ) ) ; } } return links ; }
tr	4	@ test public void testmessage_getparameter ( ) { final arrayparameter arrayparam = new arrayparameter ( "arrayparam" ) ; arrayparam . add ( new singleparameter ( "arrayentry0" , "avalue0" ) ) ; arrayparam . add ( new singleparameter ( "arrayentry1" , "avalue1" ) ) ; arrayparam . add ( new singleparameter ( "arrayentry2" , "avalue2" ) ) ; final groupedparameter groupedparam = new groupedparameter ( "groupedparam" ) ; groupedparam . add ( new singleparameter ( "groupentry0" , "gvalue0" ) ) ; groupedparam . add ( new singleparameter ( "groupentry1" , "gvalue1" ) ) ; groupedparam . add ( new singleparameter ( "groupentry2" , "gvalue2" ) ) ; final message message = new message ( arrayparam , groupedparam ) ; final groupedparameter gotgroupedparam = message . getparameter ( "groupedparam" ) ; assertequals ( groupedparam , gotgroupedparam ) ; }
tr	4	public static void main ( string [ ] args ) { controller c = new controller ( ) ; random r = new random ( ) ; int num = r . nextint ( 3 ) ; if ( num == 0 ) { for ( int v = 0 ; v < 10 ; v ++ ) { system . out . println ( c . iniciartimes ( ) ) ; } } else if ( num == 1 ) { for ( int v = 0 ; v < 10 ; v ++ ) { system . out . println ( c . iniciarbandas ( ) ) ; } } else { for ( int v = 0 ; v < 10 ; v ++ ) { system . out . println ( c . iniciarpaises ( ) ) ; } } }
tr	9	val compute ( objectivefunction of , float [ ] [ ] dom , int rezx , int rezy ) { float [ ] [ ] ret = new float [ rezx ] [ rezy ] ; float pasx , pasy ; float px , py ; pasx = ( dom [ 0 ] [ 1 ] - dom [ 0 ] [ 0 ] ) / rezx ; pasy = ( dom [ 1 ] [ 1 ] - dom [ 1 ] [ 0 ] ) / rezy ; float maxc = - 10000 , minc = 10000 ; int i , j ; px = dom [ 0 ] [ 0 ] ; for ( i = 0 ; i < rezx ; i ++ ) { py = dom [ 0 ] [ 0 ] ; for ( j = 0 ; j < rezy ; j ++ ) { ret [ i ] [ j ] = of . f ( px , py ) ; if ( ret [ i ] [ j ] < minc ) minc = ret [ i ] [ j ] ; else if ( ret [ i ] [ j ] > maxc ) maxc = ret [ i ] [ j ] ; py += pasy ; } px += pasx ; } return new val ( ret , minc , maxc ) ; }
tr	7	@ test public void solvetest ( ) { euler e = new euler ( ) ; double [ ] [ ] expresult = { { 0 , 1 } , { 0.5 , 5.25 } , { 1 , 5.875 } , { 1.5 , 5.125 } } ; differentialequation f1 = new f1 ( ) ; double [ ] initialcondition = { 0 , 1 } ; double lastx = 1.5 ; double step = 0.5 ; double [ ] [ ] result = e . solve ( f1 , initialcondition , lastx , step ) ; assertarrayequals ( expresult , result ) ; }
tr	3	protected void from_net ( string header ) throws exception { log . info ( "try from net!" ) ; string host = extractfromheader ( header , "host:" , "\\n" ) , path = getpath ( header ) ; if ( ( host == null ) || ( path == null ) ) { printerror ( "invalid request:\\n" + header ) ; return ; } log . info ( "transform path: " + path ) ; int port = host . indexof ( ":" , 0 ) ; if ( port < 0 ) port = 80 ; else { port = integer . parseint ( host . substring ( port + 1 ) ) ; host = host . substring ( 0 , port ) ; } log . info ( "from net host+port: " + host + ":" + port ) ; from_net ( header , host , port , path ) ; }
tr	3	private final void isaac ( ) { int i , x , y ; b += ++ c ; for ( i = 0 ; i < size ; ++ i ) { x = mem [ i ] ; switch ( i & 3 ) { case 0 : a ^= a << 13 ; break ; case 1 : a ^= a > > > 6 ; break ; case 2 : a ^= a << 2 ; break ; case 3 : a ^= a > > > 16 ; break ; } a += mem [ i + size / 2 & size - 1 ] ; mem [ i ] = y = mem [ ( x & mask ) > > 2 ] + a + b ; rsl [ i ] = b = mem [ ( y > > sizel & mask ) > > 2 ] + x ; } }
tr	9	private int calccompability ( string name1 , string name2 , string surname1 , string surname2 ) { char [ ] name1chararr = name1 . tochararray ( ) ; char [ ] name2chararr = name2 . tochararray ( ) ; char [ ] surname1chararr = surname1 . tochararray ( ) ; char [ ] surname2chararr = surname2 . tochararray ( ) ; int result = 100 ; int namelengthcounter ; if ( name1 . length ( ) <= name2 . length ( ) ) namelengthcounter = name1 . length ( ) ; else namelengthcounter = name2 . length ( ) ; int i = 0 ; while ( i < namelengthcounter ) { result = result - math . abs ( name1chararr [ i ] - name2chararr [ i ] ) ; i += 1 ; } int surnamelengthcounter ; if ( surname1 . length ( ) <= surname2 . length ( ) ) surnamelengthcounter = name1 . length ( ) ; else surnamelengthcounter = surname2 . length ( ) ; int j = 0 ; while ( j < surnamelengthcounter ) { result = result - math . abs ( surname1chararr [ j ] - surname2chararr [ j ] ) ; j += 1 ; } if ( result < 0 ) result = 0 ; return result ; }
tr	3	private document parsefordom ( final file docfile ) { document document = null ; try { final documentbuilderfactory documentbuilderfactory = documentbuilderfactory . newinstance ( ) ; documentbuilderfactory . setvalidating ( true ) ; final documentbuilder documentbuilder = documentbuilderfactory . newdocumentbuilder ( ) ; documentbuilder . seterrorhandler ( new myerrorhandler ( ) ) ; document = documentbuilder . parse ( docfile ) ; return document ; } catch ( exception e ) { xmlreader . log . log ( level . severe , xmlreader . problem_parsing_the_file + e . getmessage ( ) , e ) ; e = null ; return null ; } }
tr	3	public int romantoint ( string s ) { int res = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( i < s . length ( ) - 1 ) { string x = s . substring ( i , i + 2 ) ; switch ( x ) { case "cm" : res += 900 ; i ++ ; break ; case "cd" : res += 400 ; i ++ ; break ; case "xc" : res += 90 ; i ++ ; break ; case "xl" : res += 40 ; i ++ ; break ; case "ix" : res += 9 ; i ++ ; break ; case "iv" : res += 4 ; i ++ ; break ; default : res += mapsingle ( s . substring ( i , i + 1 ) ) ; } } else res += mapsingle ( s . substring ( i , i + 1 ) ) ; } return res ; }
tr	1	public void movetocenter ( pvector i_center , float i_zoomfactor , int i_timetoanimate ) { pvector targetoffset = calcworldoffset ( i_center , i_zoomfactor ) ; this . m_timeleftforcameraanimation = i_timetoanimate ; this . m_originalanimationtime = i_timetoanimate ; this . m_zoomstep = ( ( i_zoomfactor - this . m_zoom ) / i_timetoanimate ) ; this . m_offsetstep = pvector . - ( targetoffset , this . m_worldorigin ) ; this . m_offsetstep . div ( i_timetoanimate ) ; this . m_originaloffset = new pvector ( ) ; this . m_originaloffset . set ( this . m_worldorigin ) ; this . m_originalzoom = this . m_zoom ; }
tr	10	@ test public void testisisomorphiconmirredtrees ( ) { vertex < string , string > g1root = new vertex < string , string > ( "root" ) ; vertex < string , string > g1left = new vertex < string , string > ( "left" ) ; vertex < string , string > g1right = new vertex < string , string > ( "right" ) ; vertex < string , string > g1leftleft = new vertex < string , string > ( "leftleft" ) ; vertex < string , string > g1leftright = new vertex < string , string > ( "leftright" ) ; g1root . addedge ( "e1" , g1left ) ; g1root . addedge ( "e2" , g1right ) ; g1left . addedge ( "e3" , g1leftleft ) ; g1left . addedge ( "e4" , g1leftright ) ; vertex < string , string > g2root = new vertex < string , string > ( "root" ) ; vertex < string , string > g2mirroredleft = new vertex < string , string > ( "left" ) ; vertex < string , string > g2mirroredright = new vertex < string , string > ( "right" ) ; vertex < string , string > g2mirroredleftleft = new vertex < string , string > ( "leftleft" ) ; vertex < string , string > g2mirroredleftright = new vertex < string , string > ( "leftright" ) ; g2root . addedge ( "e1" , g2mirroredleft ) ; g2root . addedge ( "e2" , g2mirroredright ) ; g2mirroredleft . addedge ( "e3" , g2mirroredleftleft ) ; g2mirroredleft . addedge ( "e4" , g2mirroredleftright ) ; asserttrue ( isomorphism . isisomorphic ( g1root , g2root ) ) ; }
tr	10	public int process ( bufferedimage img ) { int width = ( img . getwidth ( ) % size != 0 ) ? img . getwidth ( ) + ( size - ( img . getwidth ( ) % size ) ) : img . getwidth ( ) ; int height = ( img . getheight ( ) % size != 0 ) ? img . getheight ( ) + ( size - ( img . getheight ( ) % size ) ) : img . getheight ( ) ; bufferedimage resized = new bufferedimage ( width , height , bufferedimage . type_byte_binary ) ; graphics2d g2d = resized . creategraphics ( ) ; g2d . drawimage ( img , 0 , 0 , null ) ; int wt = width / 100 ; int ht = height / 100 ; bufferedimage - = null ; int counter = 0 ; for ( int i = 0 ; i < wt ; i ++ ) { for ( int j = 0 ; j < ht ; j ++ ) { system . out . println ( i + " " + j + "/" + wt + " " + ht ) ; - = resized . getsubimage ( i * size , j * size , size , size ) ; network . setinput ( patternsupplier . getfeatures ( - ) ) ; network . activatenetwork ( ) ; if ( patternsupplier . decodeoutput ( network . getoutput ( ) ) ) { counter ++ ; } } } return counter ; }
tr	6	@ eventhandler public void onprepareitemcraftevent ( prepareitemcraftevent event ) { if ( ! renameenabled ) { return ; } if ( event . getrecipe ( ) instanceof recipe ) { craftinginventory ci = event . getinventory ( ) ; itemstack result = ci . getresult ( ) ; if ( result == null ) { return ; } if ( result . gettype ( ) . equals ( material . skull_item ) ) { for ( itemstack i : ci . getcontents ( ) ) { if ( i . gettype ( ) . equals ( material . skull_item ) ) { if ( i . getdata ( ) . getdata ( ) != ( byte ) 3 ) { ci . setresult ( new itemstack ( material . air ) ) ; return ; } } } for ( itemstack i : ci . getcontents ( ) ) { if ( i . hasitemmeta ( ) && i . gettype ( ) . equals ( renameitem ) ) { itemmeta im = i . getitemmeta ( ) ; if ( im . hasdisplayname ( ) ) { itemstack res = new itemstack ( material . skull_item , 1 , ( byte ) 3 ) ; itemmeta itemmeta = res . getitemmeta ( ) ; ( ( skullmeta ) itemmeta ) . setowner ( im . getdisplayname ( ) ) ; res . setitemmeta ( itemmeta ) ; ci . setresult ( res ) ; break ; } } } } } }
tr	8	private list < string > getmeses ( ) { string mesinicial = null ; string mesfinal = null ; list < string > meses = new arraylist < string > ( ) ; for ( int index = 0 ; index < filerel . getcontent ( ) . size ( ) ; index ++ ) { string search = filerel . getcontent ( ) . get ( index ) ; if ( search . contains ( "mes inicial" ) || search . contains ( "mes inicial" ) ) { int indexdatainicial = index ; search = filerel . getcontent ( ) . get ( indexdatainicial ) . trim ( ) ; mesinicial = search ; string [ ] arraymesanoinicial = search . split ( "/" ) ; arraymesanoinicial [ 0 ] = arraymesanoinicial [ 0 ] . substring ( arraymesanoinicial [ 0 ] . length ( ) - 2 , arraymesanoinicial [ 0 ] . length ( ) ) . trim ( ) ; filerel . setmesinicial ( arraymesanoinicial [ 0 ] ) ; filerel . setanoinicial ( integer . parseint ( arraymesanoinicial [ 1 ] . trim ( ) ) ) ; } if ( search . contains ( "mes final" ) || search . contains ( "mes final" ) ) { int indexdatainicial = index ; search = filerel . getcontent ( ) . get ( indexdatainicial ) . trim ( ) ; mesfinal = search ; string [ ] arraymesanofinal = search . split ( "/" ) ; arraymesanofinal [ 0 ] = arraymesanofinal [ 0 ] . substring ( arraymesanofinal [ 0 ] . length ( ) - 2 , arraymesanofinal [ 0 ] . length ( ) ) . trim ( ) ; filerel . setmesfinal ( arraymesanofinal [ 0 ] ) ; filerel . setanofinal ( integer . parseint ( arraymesanofinal [ 1 ] . trim ( ) ) ) ; } search = "" ; } meses . add ( mesinicial ) ; meses . add ( mesfinal ) ; return meses ; }
tr	1	private void jbutton1actionperformed ( actionevent evt ) { try { socket = new socket ( "127.0.0.1" , 2009 ) ; login = jtextfield1 . gettext ( ) ; password = new string ( jpasswordfield1 . getpassword ( ) ) ; logincheck lc = new logincheck ( socket ) ; idcheck = lc . check ( login , password ) ; if ( ! idcheck ) { joptionpane . showmessagedialog ( this , "bad login and/or password." ) ; } else { t2 = new thread ( new chatwindow ( socket , login ) ) ; t2 . start ( ) ; this . dispose ( ) ; } } catch ( unknownhostexception e ) { system . err . println ( "can't connect to address " + socket . getlocaladdress ( ) ) ; } catch ( ioexception e ) { system . err . println ( "no server listening on port " + socket . getlocalport ( ) ) ; } }
tr	1	public void migrate ( connection connection ) throws exception { httprequest http = new httprequest ( openmrsdataproperties . getinstance ( ) ) ; http . post ( "/concept" , conceptjson . createconcept ( "chief complaint" , conceptdatatype . text , conceptclass . symptom ) ) ; http . post ( "/concept" , conceptjson . createconcept ( "registration fees" , conceptdatatype . numeric , conceptclass . misc ) ) ; http . post ( "/concept" , conceptjson . createconcept ( "height" , conceptdatatype . numeric , conceptclass . test ) ) ; http . post ( "/concept" , conceptjson . createconcept ( "weight" , conceptdatatype . numeric , conceptclass . test ) ) ; http . post ( "/concept" , conceptjson . createconcept ( "bmi" , conceptdatatype . numeric , conceptclass . test ) ) ; http . post ( "/concept" , conceptjson . createconcept ( "registration_concepts" , conceptdatatype . na , conceptclass . convset , new arraylist < > ( arrays . aslist ( "chief complaint" , "registration fees" , "height" , "weight" , "bmi" ) ) ) ) ; }
tr	8	public vector < inetsocketaddress > getservers ( byte regioncode , string filter , boolean force , masterserverlistener listener ) throws steamcondenserexception , timeoutexception { int failcount = 0 ; boolean finished = false ; int portnumber = 0 ; string hostname = "0.0.0.0" ; vector < string > serverstringarray ; vector < inetsocketaddress > serverarray = new vector < inetsocketaddress > ( ) ; while ( true ) { try { failcount = 0 ; do { this . socket . send ( new a2m_get_servers_batch2_paket ( regioncode , hostname + ":" + portnumber , filter ) ) ; try { serverstringarray = ( ( m2a_server_batch_paket ) this . socket . getreply ( ) ) . getservers ( ) ; for ( string serverstring : serverstringarray ) { hostname = serverstring . substring ( 0 , serverstring . lastindexof ( ':' ) ) ; portnumber = integer . valueof ( serverstring . substring ( serverstring . lastindexof ( ':' ) + 1 ) ) ; if ( ! hostname . equals ( "0.0.0.0" ) && portnumber != 0 ) { inetsocketaddress inets = new inetsocketaddress ( hostname , portnumber ) ; serverarray . add ( inets ) ; if ( listener != null ) { listener . serverfound ( inets ) ; } } else { finished = true ; } } failcount = 0 ; } catch ( timeoutexception e ) { failcount ++ ; if ( failcount == retries ) { throw e ; } logger . getlogger ( "com.github.koraktor.steamcondenser" ) . log ( level . info , "request to master server {0} timed out<litcomma> retrying..." , this . ipaddress ) ; } } while ( ! finished ) ; break ; } catch ( timeoutexception e ) { if ( force ) { break ; } else if ( this . rotateip ( ) ) { throw e ; } logger . getlogger ( "com.github.koraktor.steamcondenser" ) . log ( level . info , "request to master server failed<litcomma> retrying {0}..." , this . ipaddress ) ; } } return serverarray ; }
tr	4	private static string median ( list < string > numberslist ) { string result = null ; if ( numberslist . size ( ) % 2 == 0 ) { int middle = numberslist . size ( ) / 2 ; int middleright = integer . parseint ( numberslist . get ( middle ) ) ; int middleleft = integer . parseint ( numberslist . get ( middle - 1 ) ) ; result = integer . tostring ( ( middleright + middleleft ) / 2 ) ; } else { result = numberslist . get ( numberslist . size ( ) / 2 ) ; } return result ; }
tr	10	@ override protected void dopost ( httpservletrequest req , httpservletresponse resp ) throws servletexception , ioexception { int id = 0 ; try { id = integer . parseint ( req . getparameter ( "id" ) ) ; } catch ( numberformatexception e ) { e . printstacktrace ( ) ; } int department = 0 ; int position = 0 ; bigdecimal salary = null ; if ( req . getparameter ( "department" ) != null ) { try { department = integer . parseint ( req . getparameter ( "department" ) ) ; } catch ( numberformatexception e ) { e . printstacktrace ( ) ; } } if ( req . getparameter ( "position" ) != null ) { try { position = integer . parseint ( req . getparameter ( "position" ) ) ; } catch ( numberformatexception e ) { e . printstacktrace ( ) ; } } if ( req . getparameter ( "salary" ) != null ) { try { salary = new bigdecimal ( req . getparameter ( "salary" ) ) ; } catch ( numberformatexception e ) { e . printstacktrace ( ) ; } } if ( id == 0 || department == 0 || position == 0 || salary == null ) { string warning = "please write correct data" ; req . setattribute ( "warning" , warning ) ; doget ( req , resp ) ; return ; } departmentdbmanager departmentdbmanager = new departmentdbmanager ( ) ; position mposition = new position ( ) ; department mdepartment = new department ( ) ; employee employee = new employee ( ) ; employee . setid ( id ) ; try { mdepartment = departmentdbmanager . getdepartment ( position ) ; } catch ( sqlexception e ) { e . printstacktrace ( ) ; } try { mposition = departmentdbmanager . getposition ( position ) ; } catch ( sqlexception e ) { e . printstacktrace ( ) ; } employee . setdepartment ( mdepartment ) ; employee . setposition ( mposition ) ; employee . setsalary ( salary ) ; try { departmentdbmanager . updateuser ( employee ) ; } catch ( sqlexception e ) { e . printstacktrace ( ) ; } string url = "index?dep=" + employee . getdepartment ( ) . getid ( ) ; req . getrequestdispatcher ( url ) . forward ( req , resp ) ; }
tr	4	@ test public void testanovofuncionario ( ) { dadospessoal dadospes1 = new dadospessoal ( "pedro lima" , "567.457.247-88" , 2345671 , 12573 , "4567-7678" , "31/04/1967" ) ; endere\xe7o endere\xe7o1 = new endere\xe7o ( "rua s\xe7o benedito" , "bessa" , "jo\xe7o pessoa" , "paraiba" , 546 ) ; pessoa pessoa1 = new pessoa ( ) ; pessoa1 . setdadospessoais ( dadospes1 ) ; pessoa1 . setendere\xe7os ( endere\xe7o1 ) ; funcionario funciona1 = new funcionario ( "gerente" , "2 anos" , 13.000 ) ; funciona1 . setcargo ( "fiscal" ) ; funciona1 . setsalario ( 2.500 ) ; funciona1 . settemposervi\xe7o ( "1 ano" ) ; assertequals ( "fiscal" , funciona1 . getcargo ( ) ) ; assertequals ( 2.5 , funciona1 . getsalario ( ) , 0.1 ) ; assertequals ( "1 ano" , funciona1 . gettemposervi\xe7o ( ) ) ; funciona1 . setdadospessoais ( dadospes1 ) ; funciona1 . setendere\xe7os ( endere\xe7o1 ) ; assertequals ( dadospes1 , funciona1 . getdadospessoais ( ) ) ; assertequals ( endere\xe7o1 , funciona1 . getendere\xe7os ( ) ) ; }
tr	2	public buttonpanel ( simulation controller ) { scape = controller ; setlayout ( new borderlayout ( ) ) ; setborder ( borderfactory . createemptyborder ( 10 , 10 , 10 , 10 ) ) ; info = new jtextpane ( ) ; info . setpreferredsize ( new dimension ( 270 , 300 ) ) ; info . setmaximumsize ( new dimension ( 270 , 300 ) ) ; info . seteditable ( false ) ; info . setopaque ( false ) ; info . setborder ( borderfactory . createcompoundborder ( borderfactory . createemptyborder ( 0 , 0 , 20 , 0 ) , borderfactory . createcompoundborder ( borderfactory . createetchedborder ( etchedborder . raised ) , borderfactory . createemptyborder ( 5 , 5 , 5 , 5 ) ) ) ) ; styleddocument doc = info . getstyleddocument ( ) ; addstylestodocument ( doc ) ; updateinfo ( ) ; epochslabel = new jlabel ( "" , swingconstants . center ) ; string ep = "epochs: " + scape . epochs ; epochslabel . settext ( ep ) ; buttons1 = new jpanel ( ) ; buttons1 . setlayout ( new flowlayout ( ) ) ; buttons1 . setborder ( borderfactory . createemptyborder ( 10 , 0 , 10 , 0 ) ) ; next = new jbutton ( "next" ) ; next . setactioncommand ( "next" ) ; next . addactionlistener ( this ) ; buttons1 . add ( next ) ; forwardlabel = new jlabel ( "enter the number of epochs to forward." , swingconstants . left ) ; forwardlabel . setverticalalignment ( swingconstants . bottom ) ; buttons2 = new jpanel ( ) ; buttons2 . setlayout ( new boxlayout ( buttons2 , boxlayout . line_axis ) ) ; forwardepochs = new jtextfield ( "100" ) ; forwardepochs . setmaximumsize ( new dimension ( 100 , 25 ) ) ; forward = new jbutton ( "forward" ) ; forward . setactioncommand ( "forward" ) ; forward . addactionlistener ( this ) ; buttons2 . add ( forwardepochs ) ; buttons2 . add ( box . createrigidarea ( new dimension ( 5 , 0 ) ) ) ; buttons2 . add ( forward ) ; buttons3 = new jpanel ( ) ; buttons3 . setlayout ( new boxlayout ( buttons3 , boxlayout . line_axis ) ) ; buttons3 . setborder ( borderfactory . createemptyborder ( 0 , 0 , 10 , 0 ) ) ; restart = new jbutton ( "restart" ) ; restart . setactioncommand ( "restart" ) ; restart . addactionlistener ( this ) ; exit = new jbutton ( "exit" ) ; exit . setactioncommand ( "exit" ) ; exit . addactionlistener ( this ) ; buttons3 . add ( box . createhorizontalglue ( ) ) ; buttons3 . add ( restart ) ; buttons3 . add ( box . createrigidarea ( new dimension ( 5 , 0 ) ) ) ; buttons3 . add ( exit ) ; body = new jpanel ( ) ; body . setlayout ( new gridlayout ( 0 , 1 ) ) ; body . add ( epochslabel ) ; body . add ( buttons1 ) ; body . add ( forwardlabel ) ; body . add ( buttons2 ) ; this . add ( info , borderlayout . north ) ; this . add ( body , borderlayout . center ) ; this . add ( buttons3 , borderlayout . south ) ; }
tr	2	public void provjeriunos ( ) { console c = system . console ( ) ; if ( c == null ) { system . exit ( 1 ) ; } v . ispisiupute ( ) ; petlja = true ; while ( petlja ) { input = c . readline ( ) ; string split [ ] = input . split ( " " ) ; switch ( split [ 0 ] ) { case "-i" : v . ispispoveznica ( ) ; break ; case "-j" : v . novastranica ( split [ 1 ] ) ; petlja = false ; break ; case "-s" : v . ispisistatistiku ( ) ; break ; case "-e" : v . brisinazahtjev ( ) ; break ; case "-q" : v . izadi ( ) ; break ; } } }
tr	6	public void onmessage ( string channel , string sender , string login , string hostname , string message ) { string msg = message . tolowercase ( ) ; string [ ] msgsplit = msg . split ( " " ) ; for ( int i = 0 ; i < msgsplit . length ; i ++ ) { string urltitle = "" ; if ( isyoutube ( msgsplit [ i ] ) ) { break ; } else if ( isurl ( msgsplit [ i ] ) ) { try { urltitle = getwebpagetitle ( msgsplit [ i ] ) ; sendmessage ( channel , sender + "'s url: " + urltitle ) ; break ; } catch ( exception ex1 ) { ex1 . printstacktrace ( ) ; } } } if ( ! sender . equalsignorecase ( getnick ( ) ) ) { sql . checknote ( channel , sender ) ; } if ( msgsplit [ 0 ] . startswith ( config . getcommandprefix ( ) ) ) { string commandname = msgsplit [ 0 ] . replace ( config . getcommandprefix ( ) , "" ) ; for ( mastercommand command : commands ) { if ( commandname . equalsignorecase ( command . getcommandname ( ) ) ) { log . consolelog ( "command" , sender + " issued command: " + message ) ; command . exec ( channel , sender , commandname , msgsplit , login , hostname , message ) ; } } return ; } log . consolelog ( "message" , "<" + channel + "> " + sender + ": " + message ) ; }
tr	1	public void addinfo ( site s ) { content [ 0 ] = "scape" ; content [ 1 ] = "agents: " + scape . agents . size ( ) ; content [ 2 ] = newline + "site" ; content [ 3 ] = "coordinates: (" + s . getxposition ( ) + "<litcomma> " + s . getyposition ( ) + ")" ; content [ 4 ] = "site food: " + round ( s . getfood ( ) ) ; content [ 5 ] = newline + "agent on site" ; agent a = s . getagent ( ) ; if ( a != null ) { content [ 6 ] = "agent id: " + a ; content [ 7 ] = "age: " + a . getage ( ) ; content [ 8 ] = "agent energy: " + round ( a . getenergy ( ) ) ; } else { content [ 6 ] = "id: " ; content [ 7 ] = "age: " ; content [ 8 ] = "agent energy: " ; } updateinfo ( ) ; }
tr	1	public boolean equals ( object object ) { if ( object instanceof string ) { return ( ( string ) object ) . tolowercase ( ) . equals ( this . name ) ; } else if ( object instanceof editban ) { editban o = ( editban ) object ; return o . name . equals ( this . name ) && o . admin . equals ( this . admin ) && o . reason . equals ( this . reason ) && o . ip . equals ( this . ip ) && o . time == this . time && o . endtime == this . endtime && o . type == this . type ; } return false ; }
tr	2	public void generate ( arraylist < node > input ) { for ( iterator < node > iterator = input . iterator ( ) ; iterator . hasnext ( ) ; ) { node i = iterator . next ( ) ; if ( ! this . haschild ( i . getname ( ) ) ) { this . appendchild ( i ) ; i = nodes . get ( i . getname ( ) ) ; iterator . remove ( ) ; i . generate ( input ) ; } else { i = nodes . get ( i . getname ( ) ) ; iterator . remove ( ) ; i . generate ( input ) ; } } }
tr	7	private void add ( double [ ] [ ] [ ] pixels , rectangle bound ) { rectangle worldbounds = world . getbounds ( ) ; int left = math . max ( bound . x , worldbounds . x ) ; int bottom = math . max ( bound . y , worldbounds . y ) ; int right = ( math . min ( bound . x + bound . width , worldbounds . x + worldbounds . width ) ) ; int top = ( math . min ( bound . y + bound . height , worldbounds . y + worldbounds . height ) ) ; for ( int x = left ; x < right ; x ++ ) { for ( int y = bottom ; y < top ; y ++ ) { precomp [ x ] [ y ] [ util . r ] += pixels [ x - bound . x ] [ y - bound . y ] [ util . r ] ; precomp [ x ] [ y ] [ util . g ] += pixels [ x - bound . x ] [ y - bound . y ] [ util . g ] ; precomp [ x ] [ y ] [ util . b ] += pixels [ x - bound . x ] [ y - bound . y ] [ util . b ] ; } } }
tr	10	private list < item > retrieveitems ( int mindemand , int minsupply , int minmargin ) { list < item > items = new arraylist < > ( ) ; csvparser parser = new csvparser ( ) ; int fetched = 0 ; int used = 0 ; try { url url = new url ( "http://www.gw2spidy.com/api/v0.9/csv/all-items/all" ) ; try ( bufferedreader in = new bufferedreader ( new inputstreamreader ( url . openstream ( ) ) ) ) { in . readline ( ) ; string inputline ; while ( ( inputline = in . readline ( ) ) != null ) { fetched ++ ; string [ ] strings = parser . parseline ( inputline ) ; item item = new item ( strings [ 0 ] , strings [ 1 ] , integer . parseint ( strings [ 8 ] ) , integer . parseint ( strings [ 9 ] ) , integer . parseint ( strings [ 10 ] ) , integer . parseint ( strings [ 11 ] ) ) ; if ( item . getofferavailability ( ) > mindemand && item . getsaleavailability ( ) > minsupply && item . getmargin ( ) > minmargin ) { items . add ( item ) ; used ++ ; lblstatus . settext ( "loaded " + fetched + " items<litcomma> filter matched by " + used + " items" ) ; } } } } catch ( exception e ) { e . printstacktrace ( ) ; } collections . sort ( items , new comparator < item > ( ) { @ override public int compare ( item o1 , item o2 ) { double m1 = o1 . getmargin ( ) ; double m2 = o2 . getmargin ( ) ; if ( m2 > m1 ) { return 1 ; } else if ( m2 == m1 ) { return 0 ; } else { return - 1 ; } } } ) ; return items ; }
tr	9	public void extractarchive ( file archive , file destdir ) throws exception { if ( ! destdir . exists ( ) ) { destdir . mkdir ( ) ; } minecraft . delete ( ) ; zipfile zipfile = new zipfile ( archive ) ; enumeration entries = zipfile . entries ( ) ; byte [ ] buffer = new byte [ 16384 ] ; while ( entries . hasmoreelements ( ) ) { zipentry entry = ( zipentry ) entries . nextelement ( ) ; string entryfilename = entry . getname ( ) ; if ( entry . isdirectory ( ) ) { file dir = new file ( destdir , entryfilename ) ; if ( ! dir . exists ( ) ) dir . mkdir ( ) ; } else { bufferedoutputstream bos = new bufferedoutputstream ( new fileoutputstream ( new file ( destdir , entryfilename ) ) ) ; bufferedinputstream bis = new bufferedinputstream ( zipfile . getinputstream ( entry ) ) ; int len ; while ( ( len = bis . read ( buffer ) ) > 0 ) { bos . write ( buffer , 0 , len ) ; } bos . flush ( ) ; bos . close ( ) ; bis . close ( ) ; } } }
tr	10	public bufferedimage use ( bufferedimage src , vector < somvector > inputvectors ) { bufferedimage result = new bufferedimage ( src . getwidth ( ) , src . getheight ( ) , bufferedimage . type_int_rgb ) ; somvector tempvec = null ; if ( closesttype ) { for ( int i = 0 ; i < getwidth ( ) ; i ++ ) { for ( int j = 0 ; j < getheight ( ) ; j ++ ) { somnode node = getnode ( i , j ) ; node . setweights ( closestvect ( node . getvector ( ) , inputvectors ) ) ; setnode ( i , j , node ) ; } } } for ( int i = 0 ; i < src . getwidth ( ) ; i ++ ) { for ( int j = 0 ; j < src . getheight ( ) ; j ++ ) { double % = ( i / ( double ) src . getwidth ( ) * 100 ) ; system . out . println ( % + " %" ) ; color c = new color ( src . getrgb ( i , j ) ) ; tempvec = new somvector ( scale ( c . getred ( ) ) , scale ( c . getgreen ( ) ) , scale ( c . getblue ( ) ) ) ; somnode winner = getwinner ( tempvec ) ; somvector colorvector = winner . getvector ( ) ; color resc = new color ( unscale ( colorvector . get ( 0 ) ) , unscale ( colorvector . get ( 1 ) ) , unscale ( colorvector . get ( 2 ) ) ) ; result . setrgb ( i , j , resc . getrgb ( ) ) ; } } return result ; }
tr	2	public boolean start ( ) { synchronized ( optoutlock ) { if ( isoptout ( ) ) { return false ; } if ( task != null ) { return true ; } task = plugin . getserver ( ) . getscheduler ( ) . runtasktimerasynchronously ( plugin , new runnable ( ) { private boolean firstpost = true ; public void run ( ) { try { synchronized ( optoutlock ) { if ( isoptout ( ) && task != null ) { task . cancel ( ) ; task = null ; for ( graph graph : graphs ) { graph . onoptout ( ) ; } } } postplugin ( ! firstpost ) ; firstpost = false ; } catch ( ioexception e ) { if ( debug ) { bukkit . getlogger ( ) . log ( level . info , "[metrics] " + e . getmessage ( ) ) ; } } } } , 0 , ping_interval * 1200 ) ; return true ; } }
tr	2	public login ( ) { if ( usuario == null ) { usuario = "" ; } while ( usuario . length ( ) == 0 ) { joptionpane . showmessagedialog ( null , "usu\xe1rio inv\xe1lido!" ) ; usuario = joptionpane . showinputdialog ( "nome de usu\xe1rio:\\n" ) ; if ( usuario == null ) { usuario = "" ; } } if ( usuario . equals ( antigouser ) ) { joptionpane . showmessagedialog ( null , "bem vindo de volta<litcomma> " + usuario + ( "!" ) ) ; } else if ( ! usuario . equals ( antigouser ) && ! usuario . equals ( "" ) ) { joptionpane . showmessagedialog ( null , "bem vindo<litcomma> " + usuario + "!" ) ; } gui . label2 . settext ( "usu\xe1rio: " + login . usuario ) ; gui . label3 . settext ( "total do caixa: r$" + dadosgerais . placassaida . size ( ) * 5 + "<litcomma>00" ) ; lastlogin lastlogin = new lastlogin ( ) ; salvardb salvardb = new salvardb ( ) ; gui . frame . requestfocus ( ) ; }
tr	10	private double interpolatednoise2 ( double x , double y ) { int intx = ( int ) x ; int inty = ( int ) y ; double fractionalx = x - intx ; double fractionaly = y - inty ; double v1 = smoothednoise2 ( intx , inty ) ; double v2 = smoothednoise2 ( intx + 1 , inty ) ; double v3 = smoothednoise2 ( intx , inty + 1 ) ; double v4 = smoothednoise2 ( intx + 1 , inty + 1 ) ; double i1 = interpolate ( v1 , v2 , fractionalx ) ; double i2 = interpolate ( v3 , v4 , fractionalx ) ; return interpolate ( i1 , i2 , fractionaly ) ; }
tr	2	public static void main ( string [ ] args ) { bufferedreader br = new bufferedreader ( new inputstreamreader ( system . in ) ) ; while ( true ) { system . out . println ( "please enter a command ('help' provides help):" ) ; system . out . print ( ">> " ) ; string cmd ; try { cmd = br . readline ( ) ; switch ( cmd . tolowercase ( ) ) { case "exit" : exit ( ) ; break ; case "help" : printhelp ( ) ; break ; default : processcommandfurther ( cmd ) ; } } catch ( ioexception e ) { e . printstacktrace ( ) ; } } }
tr	4	public void input ( string thetext ) { thetext = thetext . tolowercase ( ) ; usefulquestions = qeadata . getquestiontotags ( ) ; if ( lists . size ( ) != 0 ) { clearlist ( ) ; } arraylist < integer > keys = new arraylist < integer > ( qeadata . gettagdictionary ( ) . keyset ( ) ) ; arraylist < string > values = new arraylist < string > ( qeadata . gettagdictionary ( ) . values ( ) ) ; int index = values . indexof ( thetext ) ; if ( index >= 0 ) { int tagid = keys . get ( index ) ; selectedtags . add ( tagid ) ; selectedtagsnames . add ( qeadata . gettagdictionary ( ) . get ( tagid ) ) ; updateusefulquestions ( tagid ) ; adddropdownlist ( tagid , relatedtags ) ; disableddl ( lists . size ( ) - 1 , tagid ) ; createrelatedtags ( ) ; adddropdownlist ( tagid , relatedtags ) ; } }
tr	10	public static tree decisiontreelearning ( arraylist < hashmap < string , string > > examples , arraylist < string > attributes , string goalattribute , hashmap < string , string [ ] > attributevalues , arraylist < hashmap < string , string > > parentexamples ) { print ( "attributes: " + attributes ) ; print ( "examples: " + examples ) ; if ( examples . isempty ( ) ) { print ( "examples.isempty()\\n" ) ; return new tree ( new goalnode ( pluralityvalue ( parentexamples , goalattribute ) ) ) ; } else if ( hassameclassifications ( examples , goalattribute ) ) { print ( "hassameclassifications(examples)\\n" ) ; return new tree ( new goalnode ( examples . get ( 0 ) . get ( goalattribute ) ) ) ; } else if ( attributes . size ( ) == 1 ) { print ( "attributes.isempty()\\n" ) ; return new tree ( new goalnode ( pluralityvalue ( examples , goalattribute ) ) ) ; } string a = "" ; double largestimportance = - 1 ; for ( int i = 0 ; i < attributes . size ( ) - 1 ; i ++ ) { string attr = attributes . get ( i ) ; double importance = importance2 . informationgain ( attr , examples , attributevalues , goalattribute ) ; print ( "a: " + attr + "\\timportance: " + importance ) ; if ( importance > largestimportance ) { largestimportance = importance ; a = attr ; } } print ( a ) ; tree tree = new tree ( new attributenode ( a ) ) ; for ( string vk : attributevalues . get ( a ) ) { arraylist < hashmap < string , string > > exs = getexs ( a , vk , examples ) ; arraylist < string > attributesminusa = clonearraylist ( attributes ) ; attributesminusa . remove ( a ) ; print ( "a: " + a ) ; print ( "vk: " + vk ) ; print ( "exs:" + exs ) ; print ( "attributesminusa: " + attributesminusa ) ; print ( "" ) ; tree subtree = decisiontreelearning ( exs , attributesminusa , goalattribute , attributevalues , examples ) ; tree . appendsubtree ( vk , subtree ) ; } return tree ; }
tr	10	private void updatepubsub ( ) { jsonarray publishers = new jsonarray ( ) ; for ( int i = 0 , len = publishes . size ( ) ; i < len ; i ++ ) { spacebrewmessage m = publishes . get ( i ) ; jsonobject pub = new jsonobject ( ) ; pub . put ( "name" , m . name ) ; pub . put ( "type" , m . type ) ; pub . put ( "default" , m . _default ) ; publishers . put ( pub ) ; } jsonarray subscribers = new jsonarray ( ) ; for ( int i = 0 ; i < subscribes . size ( ) ; i ++ ) { spacebrewmessage m = subscribes . get ( i ) ; jsonobject subs = new jsonobject ( ) ; subs . put ( "name" , m . name ) ; subs . put ( "type" , m . type ) ; subscribers . put ( subs ) ; } jsonobject mobj = new jsonobject ( ) ; jsonobject tms1 = new jsonobject ( ) ; jsonobject tms2 = new jsonobject ( ) ; tms1 . put ( "messages" , subscribers ) ; tms2 . put ( "messages" , publishers ) ; mobj . put ( "name" , name ) ; mobj . put ( "description" , description ) ; mobj . put ( "subscribe" , tms1 ) ; mobj . put ( "publish" , tms2 ) ; tconfig . put ( "config" , mobj ) ; if ( connectionestablished ) { wsclient . send ( tconfig . tostring ( ) ) ; } }
tr	1	public void checkparamsset ( ) { if ( ! new file ( options . jenhome ) . exists ( ) ) { log . info ( "cannot find jen_home directory at {} - creating..." , options . jenhome ) ; try { log . debug ( "creating file ... " ) ; final file file = new file ( options . jenhome ) ; file . mkdir ( ) ; log . info ( "successfully created environment directory at {}" , options . jenenv ) ; } catch ( exception e ) { log . error ( "error: could not create file at {}<litcomma> exiting." , options . jenenv ) ; log . error ( "{}" , e ) ; system . exit ( - 1 ) ; } } if ( ! new file ( options . jenenv ) . exists ( ) ) { log . info ( "cannot find current environment directory at {} - creating..." , options . jenenv ) ; try { log . debug ( "creating file ... " ) ; final file file = new file ( options . jenenv ) ; file . mkdir ( ) ; log . info ( "successfully created environment directory at {}" , options . jenenv ) ; } catch ( exception e ) { log . error ( "error: could not create file at {}<litcomma> exiting." , options . jenenv ) ; log . error ( "{}" , e ) ; system . exit ( - 1 ) ; } } writeconfig ( new string [ ] { "default" } ) ; }
tr	6	public void generate ( land [ ] [ ] world , float heightthreshold , float lakelevel ) { this . lakelevel = lakelevel ; this . world = world ; arraylist < land > startoptions = new arraylist < land > ( ) ; arraylist < land > riverstarts = new arraylist < land > ( ) ; for ( int i = 0 ; i < world . length ; i ++ ) { for ( int j = 0 ; j < world [ 0 ] . length ; j ++ ) { if ( world [ i ] [ j ] . height >= heightthreshold ) { startoptions . add ( world [ i ] [ j ] ) ; j += 10 ; i += 2 ; } } } int numrivers = ( int ) ( math . random ( ) * startoptions . size ( ) ) ; system . out . println ( numrivers ) ; int rand = 0 ; for ( int i = 0 ; i < numrivers ; i ++ ) { rand = ( int ) ( math . random ( ) * startoptions . size ( ) ) ; if ( rand == startoptions . size ( ) ) { rand -- ; } riverstarts . add ( startoptions . get ( rand ) ) ; startoptions . remove ( rand ) ; } for ( int i = 0 ; i < riverstarts . size ( ) ; i ++ ) { startriver ( riverstarts . get ( i ) ) ; } }
tr	5	public int divide ( int dividend , int divisor ) { if ( divisor == 0 ) return 0 ; int res = 0 ; int loop = 0 ; boolean sign = ( ( dividend > 0 && divisor < 0 ) || ( dividend < 0 && divisor > 0 ) ) ; int newdividend = dividend > 0 ? - 1 * dividend : dividend ; int newdivisor = divisor > 0 ? - 1 * divisor : divisor ; divisor = newdivisor ; while ( newdividend <= newdivisor ) { loop = loop == 0 ? - 1 : loop + loop ; res += loop ; newdividend = newdividend - newdivisor ; if ( integer . min_value - newdivisor > newdivisor || newdivisor + newdivisor < newdividend ) { newdivisor = divisor ; loop = 0 ; } else newdivisor = newdivisor + newdivisor ; } return sign ? res : - res ; }
tr	3	@ override public void drop ( droptargetdropevent dtde ) { try { transferable tr = dtde . gettransferable ( ) ; dataflavor [ ] flavors = tr . gettransferdataflavors ( ) ; dtde . acceptdrop ( dndconstants . action_copy_or_move ) ; string path = tr . gettransferdata ( flavors [ 0 ] ) . tostring ( ) ; path = path . substring ( 1 , path . length ( ) - 1 ) ; gui . get ( ) . updatedirectorytext ( path ) ; } catch ( exception e ) { dtde . rejectdrop ( ) ; } }
tr	9	public string addbinary ( string a , string b ) { int sizea = a . length ( ) ; int sizeb = b . length ( ) ; if ( sizea == 0 ) return b ; if ( sizeb == 0 ) return a ; string res = "" ; int r = 0 ; int carryover = 0 ; for ( int i = sizea - 1 , j = sizeb - 1 ; i >= 0 || j >= 0 ; ) { char ca = '0' ; char cb = '0' ; if ( i >= 0 ) ca = a . charat ( i ) ; if ( j >= 0 ) cb = b . charat ( j ) ; if ( ca == '0' && cb == '0' ) { r = carryover ; carryover = 0 ; } else if ( ( ca == '0' && cb == '1' ) || ( ca == '1' && cb == '0' ) ) { if ( carryover == 0 ) { r = 1 ; carryover = 0 ; } else { r = 0 ; carryover = 1 ; } } else if ( ca == '1' && cb == '1' ) { r = carryover ; carryover = 1 ; } else { return "" ; } res = string . valueof ( r ) + res ; i -- ; j -- ; } if ( carryover == 1 ) res = "1" + res ; return res ; }
tr	5	public int maxprofit3 ( int [ ] prices ) { if ( prices . length < 2 ) return 0 ; int [ ] first = new int [ prices . length ] ; int [ ] second = new int [ prices . length ] ; int min = prices [ 0 ] ; int max = prices [ prices . length - 1 ] ; for ( int i = 1 ; i < prices . length ; i ++ ) { min = math . min ( min , prices [ i ] ) ; first [ i ] = math . max ( first [ i - 1 ] , prices [ i ] - min ) ; } for ( int i = prices . length - 2 ; i >= 0 ; i -- ) { max = math . max ( max , prices [ i ] ) ; second [ i ] = math . max ( second [ i + 1 ] , max - prices [ i ] ) ; } max = 0 ; for ( int i = 0 ; i < prices . length ; i ++ ) { max = math . max ( max , first [ i ] + second [ i ] ) ; } return max ; }
tr	3	public static void main ( string [ ] args ) throws interruptedexception { if ( args . length != 3 ) throw new illegalargumentexception ( "please provide valid parameters: fibonacci number<litcomma> task quantity<litcomma> threads quantity" ) ; try { integer n = integer . valueof ( args [ 0 ] ) ; integer numberoftasks = integer . valueof ( args [ 1 ] ) ; integer threadquantity = integer . valueof ( args [ 2 ] ) ; if ( n <= 0 || numberoftasks <= 0 || threadquantity <= 0 ) throw new illegalargumentexception ( "all input parameters should be greater than 0" ) ; startcalculation ( n , numberoftasks , threadquantity ) ; } catch ( numberformatexception ex ) { throw new illegalaccesserror ( "you have to provide integer numbers as a parameters" ) ; } }
tr	4	@ override public int nextint ( ) { double d = random . nextdouble ( ) ; int idx = collections . binarysearch ( v , d ) ; if ( idx > 0 ) { ++ idx ; } else { idx = - ( idx + 1 ) ; } if ( idx >= v . size ( ) ) { idx = v . size ( ) - 1 ; } if ( idx == 0 ) { return k . get ( 0 ) ; } int ceiling = k . get ( idx ) ; int lower = k . get ( idx - 1 ) ; return ceiling - random . nextint ( ceiling - lower ) ; }
tr	9	public static void runrandomizedexperiment ( ) { final int numruns = 5 ; final int [ ] numverticesarray = { 1000 , 3000 , 5000 } ; final int [ ] densityarray = { 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 } ; for ( int numvertices : numverticesarray ) { for ( int density : densityarray ) { long simpleschemeruntime = 0 ; long fheapschemeruntime = 0 ; for ( int run = 0 ; run < numruns ; run ++ ) { graph graph = graphgenerator . generategraph ( numvertices , density / 100.0 ) ; mstgenerator . generatemst ( new simpleschememstgenerator ( ) , graph ) ; simpleschemeruntime += mstgenerator . getruntime ( ) ; mstgenerator . generatemst ( new fheapschememstgenerator ( ) , graph ) ; fheapschemeruntime += mstgenerator . getruntime ( ) ; } simpleschemeruntime = simpleschemeruntime / numruns ; fheapschemeruntime = fheapschemeruntime / numruns ; system . out . format ( "%d<litcomma> %d<litcomma> %d<litcomma> %d\\n" , numvertices , density , simpleschemeruntime , fheapschemeruntime ) ; } } }
tr	4	private string converttopostfix ( string infixexpression ) { char [ ] tokens = infixexpression . tochararray ( ) ; stack < character > stack = new stack < > ( ) ; stringbuilder postfixbuilder = new stringbuilder ( infixexpression . length ( ) ) ; for ( char c : tokens ) { if ( isoperator ( c ) ) { while ( ! stack . isempty ( ) && stack . peek ( ) != '(' ) { if ( operatorgreaterorequal ( stack . peek ( ) , c ) ) { postfixbuilder . append ( stack . pop ( ) ) ; } else { break ; } } stack . push ( c ) ; } else if ( c == '(' ) { stack . push ( c ) ; } else if ( c == ')' ) { while ( ! stack . isempty ( ) && stack . peek ( ) != '(' ) { postfixbuilder . append ( stack . pop ( ) ) ; } if ( ! stack . isempty ( ) ) { stack . pop ( ) ; } } else if ( isoperand ( c ) ) { postfixbuilder . append ( c ) ; } } while ( ! stack . empty ( ) ) { postfixbuilder . append ( stack . pop ( ) ) ; } return postfixbuilder . tostring ( ) ; }
tr	8	private void loadconfig ( ) { fileconfiguration config = yamlconfiguration . loadconfiguration ( new file ( getdatafolder ( ) , "config.yml" ) ) ; configurationsection limits = config . getconfigurationsection ( "limits" ) ; if ( limits == null ) { this . explosionsallowed = true ; } else { this . explosionsallowed = limits . getboolean ( "explosions" , true ) ; } this . defaultbiomeaffinity = new hashmap < biome , float > ( ) ; for ( biome b : biome . values ( ) ) { this . defaultbiomeaffinity . put ( b , 1f ) ; } configurationsection defaults = config . getconfigurationsection ( "defaults" ) ; if ( defaults == null ) { this . defaulttolerance = 0.2f ; this . defaultfailresult = new reciperesult ( "default-fail" , 0 , 0 , 0 , new arraylist < itemstack > ( ) , 0 , fill . empty , 0 , new arraylist < timerange > ( ) , new arraylist < integer > ( ) , null ) ; this . defaultminsecondsperitem = 1 ; this . defaultmaxsecondsperitem = 1 ; this . defaultminsecondsperheating = 1 ; this . defaultmaxsecondsperheating = 1 ; this . defaultminsecondsperfill = 1 ; this . defaultmaxsecondsperfill = 1 ; } else { this . defaulttolerance = ( float ) defaults . getdouble ( "tolerance" , 0.2d ) ; this . defaultfailresult = reciperesult . fromconfig ( defaults . getconfigurationsection ( "default-fail" ) ) ; configurationsection timing = defaults . getconfigurationsection ( "timing" ) ; if ( timing == null ) { this . defaultminsecondsperitem = 1 ; this . defaultmaxsecondsperitem = 1 ; this . defaultminsecondsperheating = 1 ; this . defaultmaxsecondsperheating = 1 ; this . defaultminsecondsperfill = 1 ; this . defaultmaxsecondsperfill = 1 ; } else { this . defaultminsecondsperitem = ( float ) timing . getdouble ( "min-item" , 1 ) ; this . defaultmaxsecondsperitem = ( float ) timing . getdouble ( "max-item" , 1 ) ; this . defaultminsecondsperheating = ( float ) timing . getdouble ( "min-heat" , 1 ) ; this . defaultmaxsecondsperheating = ( float ) timing . getdouble ( "max-heat" , 1 ) ; this . defaultminsecondsperfill = ( float ) timing . getdouble ( "min-fill" , 1 ) ; this . defaultmaxsecondsperfill = ( float ) timing . getdouble ( "max-fill" , 1 ) ; } configurationsection biomes = defaults . getconfigurationsection ( "biomes" ) ; if ( biomes != null ) { for ( string biomename : biomes . getkeys ( false ) ) { biome biome = biome . valueof ( biomename . replace ( '-' , '_' ) . touppercase ( ) ) ; if ( biome != null && ( biomes . isint ( biomename ) || biomes . islong ( biomename ) || biomes . isdouble ( biomename ) ) ) { this . defaultbiomeaffinity . remove ( biome ) ; this . defaultbiomeaffinity . put ( biome , ( float ) ( biomes . getdouble ( biomename , 100 ) / 100 ) ) ; } } } } }
tr	7	public static void readxml ( ) throws exception { puzzlehighscores = new vector < slidingpuzzlehighscore > ( ) ; documentbuilderfactory factory = documentbuilderfactory . newinstance ( ) ; documentbuilder builder = factory . newdocumentbuilder ( ) ; document doc = builder . parse ( new file ( "highscore.xml" ) ) ; element rootelement = doc . getdocumentelement ( ) ; system . out . println ( "root element: " + rootelement . getnodename ( ) ) ; nodelist list = rootelement . getelementsbytagname ( "user" ) ; for ( int i = 0 ; i < list . getlength ( ) ; i ++ ) { node usernode = list . item ( i ) ; new slidingpuzzlehighscore ( usernode . getattributes ( ) . getnameditem ( "name" ) . getnodevalue ( ) , usernode . getattributes ( ) . getnameditem ( "score" ) . getnodevalue ( ) ) ; } }
tr	2	@ override public group next ( ) { if ( filereader == null ) { throw new unsupportedoperationexception ( ) ; } if ( currentpost == null ) { if ( ! hasnext ( ) ) { return null ; } readnextentry ( ) ; } integer currentgroupid = currentpost . getgroupid ( ) ; group group = new group ( currentgroupid ) ; while ( readnextentry ( ) != null && currentpost . getgroupid ( ) == currentgroupid ) { group . add ( currentpost ) ; } if ( group . isempty ( ) ) { return null ; } return group ; }
tr	6	private boolean parseresponse ( bufferedreader in ) throws ioexception { final httpresponse result = new httpresponse ( ) ; string statusline = in . readline ( ) ; result . setstatusline ( statusline ) ; pattern p = pattern . compile ( "\\\\d\\\\d\\\\d" ) ; matcher m = p . matcher ( statusline ) ; while ( m . find ( ) ) { int statuscode = integer . parseint ( m . group ( ) ) ; system . out . println ( statuscode ) ; if ( statuscode < 300 ) { system . out . println ( statusline ) ; string next ; while ( ! ( next = in . readline ( ) ) . equals ( "" ) ) { system . out . println ( next ) ; result . getheaders ( ) . add ( httpheader . createfromheaderline ( next ) ) ; } system . out . println ( result . getbody ( in ) ) ; break ; } else if ( statuscode >= 300 ) { system . out . println ( "error! status code :" + statuscode ) ; return false ; } } return true ; }
tr	1	public arraylist < string > lettercombinations ( string digits ) { arraylist < string > map = new arraylist < string > ( ) ; map . add ( "" ) ; map . add ( "" ) ; map . add ( "abc" ) ; map . add ( "def" ) ; map . add ( "ghi" ) ; map . add ( "jkl" ) ; map . add ( "mno" ) ; map . add ( "pqrs" ) ; map . add ( "tuv" ) ; map . add ( "wxyz" ) ; return combineletter ( digits , map ) ; }
tr	6	public arraylist < string [ ] > solvenqueens ( int n ) { arraylist < string [ ] > res = new arraylist < string [ ] > ( ) ; hashset < integer > cols = new hashset < integer > ( ) ; hashset < integer > diag1 = new hashset < integer > ( ) ; hashset < integer > diag2 = new hashset < integer > ( ) ; int [ ] board = new int [ n ] ; int currentrow = 0 ; solve ( currentrow , n , board , res , cols , diag1 , diag2 ) ; return res ; }
tr	5	public string minwindow ( string s , string t ) { if ( t . length ( ) == 0 ) return "" ; int lastbeginindex = - 1 ; string res = "" ; for ( int i = 0 , j = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charat ( i ) == t . charat ( j ) ) { j ++ ; if ( j == 1 ) lastbeginindex = i ; if ( j == t . length ( ) ) { j = 0 ; string - = s . substring ( lastbeginindex , i + 1 ) ; res = - . length ( ) < res . length ( ) || res . length ( ) == 0 ? - : res ; } } } return res ; }
tr	9	public static void pixeltoimage ( int [ ] [ ] result , string filename ) throws ioexception { int height = result . length ; int width = result [ 0 ] . length ; int num_bands = 3 ; int [ ] array1d = new int [ width * height * num_bands ] ; result = threetoone ( result ) ; for ( int k = 0 ; k < width ; k ++ ) { for ( int j = 0 ; j < height ; j ++ ) { for ( int band = 0 ; band < num_bands ; band ++ ) array1d [ ( ( j * width ) + k ) * num_bands + band ] = result [ j ] [ k ] ; } } bufferedimage bi = new bufferedimage ( width , height , bufferedimage . type_int_rgb ) ; writableraster raster = ( writableraster ) bi . getdata ( ) ; raster . setpixels ( 0 , 0 , width , height , array1d ) ; bi . setdata ( raster ) ; imageio . write ( bi , "jpg" , new file ( "c:\\\\users\\\\brandon\\\\workspace\\\\imageprocessing\\\\" + filename + ".jpg" ) ) ; }
tr	8	@ override public void start ( stage stage ) { stackpane root = new stackpane ( ) ; scene scene = new scene ( root , 300 , 300 ) ; gamecanvas canvas = new gamecanvas ( ) ; graphicscontext gc = canvas . getgraphicscontext2d ( ) ; root . getchildren ( ) . add ( canvas ) ; stage . settitle ( "snake" ) ; stage . setscene ( scene ) ; stage . show ( ) ; player p1 = new player ( canvas ) ; food food = new food ( canvas , p1 ) ; scene . setonkeypressed ( p1 ) ; gameentities . add ( p1 ) ; timeline tl = new timeline ( new keyframe ( duration . millis ( 400 ) , new eventhandler < actionevent > ( ) { @ override public void handle ( actionevent event ) { for ( gameentity e : gameentities ) { food . update ( ) ; p1 . update ( ) ; } } } ) ) ; tl . setcyclecount ( timeline . indefinite ) ; tl . play ( ) ; }
tr	10	@ override protected void reduce ( text key , iterable < text > values , context context ) throws ioexception , interruptedexception { system . out . println ( headertype . valueof ( key . tostring ( ) . trim ( ) . replaceall ( "\\\\ " , "" ) ) . tostring ( ) ) ; switch ( headertype . valueof ( key . tostring ( ) . trim ( ) . replaceall ( "\\\\ " , "" ) ) . tostring ( ) ) { case "number" : system . out . println ( "number me for key =" + key . tostring ( ) ) ; double max = integer . min_value ; double min = integer . max_value ; double avg = 0.0 ; integer count = 0 ; for ( text value : values ) { double curr = double . parsedouble ( value . tostring ( ) . trim ( ) ) ; max = max <= curr ? curr : max ; min = min >= curr ? curr : min ; avg += curr ; count ++ ; } context . write ( key , new text ( "max=" + string . valueof ( max ) + "\\t min=" + string . valueof ( min ) + "\\t avg=" + string . valueof ( avg / count ) ) ) ; break ; case "words" : system . out . println ( "words me for key=" + key . tostring ( ) ) ; map < string , integer > countofcat = new hashmap < string , integer > ( ) ; count = 0 ; for ( text word : values ) { if ( countofcat . containskey ( word . tostring ( ) ) ) { count = countofcat . get ( word . tostring ( ) ) ; countofcat . put ( word . tostring ( ) , ++ count ) ; } else { countofcat . put ( word . tostring ( ) , 1 ) ; } } string tmp = new string ( ) ; for ( entry < string , integer > entry : countofcat . entryset ( ) ) { tmp += entry . getkey ( ) + "=" + entry . getvalue ( ) + "\\t" ; } context . write ( key , new text ( tmp ) ) ; break ; default : break ; } }
tr	4	public static string tostring ( itemstack [ ] inv ) { list < string > result = new arraylist < string > ( ) ; list < configurationserializable > items = new arraylist < configurationserializable > ( ) ; items . addall ( arrays . aslist ( inv ) ) ; for ( configurationserializable cs : items ) { if ( cs == null ) { result . add ( "null" ) ; } else { result . add ( new jsonobject ( serialize ( cs ) ) . tostring ( ) ) ; } } jsonarray json_array = new jsonarray ( result ) ; return json_array . tostring ( ) ; }
tr	5	private boolean isemail ( string mailaddr ) { string regex = "^[a-za-z][\\\\w\\\\.-]*[a-za-z0-9]@[a-za-z0-9][\\\\w\\\\.-]*[a-za-z0-9]\\\\.[a-za-z][a-za-z\\\\.]*[a-za-z]$" ; pattern p = pattern . compile ( regex ) ; if ( mailaddr . contains ( "|" ) ) { string emails [ ] = mailaddr . split ( "[|]" ) ; for ( string email : emails ) { matcher m = p . matcher ( email ) ; if ( ! m . matches ( ) ) { logger . log ( level . info , "email: {0} is not valid" , email ) ; return false ; } } } else { matcher m = p . matcher ( mailaddr ) ; if ( ! m . matches ( ) ) { logger . log ( level . info , "email: {0} is not valid" , mailaddr ) ; return false ; } } return true ; }
tr	7	private void testsqlserver ( ) { hibadbserver dbserver = hibadbserver . getsingleinstance ( ) ; dbhandle conn = null ; try { conn = dbserver . getconn ( ) ; statementhandle stmt = conn . createstatement ( ) ; string sql = "select * from orderinfo where id>230" ; resultset rs = stmt . executequery ( sql ) ; int i = 0 ; stringbuffer buff = new stringbuffer ( ) ; while ( rs . next ( ) ) { buff . append ( "insert into orderinfo (orderid<litcomma> result<litcomma> createdate<litcomma> xmlcontent<litcomma> handlestatus<litcomma> ordertype) values " ) ; buff . append ( "(" ) ; buff . append ( "'" + rs . getstring ( "orderid" ) + "'<litcomma>" ) ; buff . append ( "'" + rs . getstring ( "result" ) + "'<litcomma>" ) ; buff . append ( "'" + rs . getstring ( "createdate" ) + "'<litcomma>" ) ; buff . append ( "'" + rs . getstring ( "xmlcontent" ) + "'<litcomma>" ) ; buff . append ( "'" + rs . getstring ( "handlestatus" ) + "'<litcomma>" ) ; buff . append ( "'" + rs . getstring ( "ordertype" ) + "');" ) ; i ++ ; } system . out . println ( buff . tostring ( ) ) ; system . out . println ( "\u603b\u8bb0\u5f55\u6570:" + i ) ; } catch ( exception ex ) { ex . printstacktrace ( ) ; } finally { dbserver . releaseconn ( conn ) ; } }
tr	2	public void map ( avrowrapper k1 , nullwritable v1 , outputcollector < avrokey < joinkey > , avrovalue < avrooutputunion > > oc , reporter rprtr ) throws ioexception { try { joinkey jk = new joinkey ( ) ; avrounionconstructorvisitor obj = ( avrounionconstructorvisitor ) k1 . datum ( ) ; jk . key = ( long ) cls . getfield ( joinfield ) . get ( obj ) ; jk . position = position ; oc . collect ( new avrokey ( jk ) , new avrovalue ( obj . getoutputunion ( ) ) ) ; } catch ( illegalargumentexception ex ) { logger . getlogger ( wpjoin . class . getname ( ) ) . log ( level . severe , null , ex ) ; } catch ( illegalaccessexception ex ) { logger . getlogger ( wpjoin . class . getname ( ) ) . log ( level . severe , null , ex ) ; } catch ( nosuchfieldexception ex ) { logger . getlogger ( wpjoin . class . getname ( ) ) . log ( level . severe , null , ex ) ; } catch ( securityexception ex ) { logger . getlogger ( wpjoin . class . getname ( ) ) . log ( level . severe , null , ex ) ; } }
tr	6	public string compress ( string input ) { if ( input . length ( ) == 0 ) return input ; stringbuffer res = new stringbuffer ( ) ; char [ ] c = input . tochararray ( ) ; char lastchar = c [ 0 ] ; int lastindex = 0 ; int count = 0 ; for ( int i = 1 ; i < c . length ; i ++ ) { if ( c [ i ] != lastchar ) { count = i - lastindex ; res . append ( lastchar ) ; res . append ( count ) ; lastindex = i ; lastchar = c [ i ] ; } } res . append ( lastchar ) ; res . append ( count ) ; return ( res . length ( ) < input . length ( ) ? res . tostring ( ) : input ) ; }
tr	8	private arraylist < string > combineletter ( string digits , arraylist < string > map ) { arraylist < string > res = new arraylist < string > ( ) ; if ( digits . length ( ) == 0 ) { res . add ( "" ) ; return res ; } int digit = integer . parseint ( digits . substring ( 0 , 1 ) ) ; string mapping = map . get ( digit ) ; string rest = digits . substring ( 1 ) ; arraylist < string > prev = combineletter ( rest , map ) ; for ( char a : mapping . tochararray ( ) ) { for ( string r : prev ) { string t = a + r ; res . add ( t ) ; } } return res ; }
tr	5	public static void locationdistancepowerlaw ( int uid ) { try { user u = new user ( uid ) ; bufferedwriter fout = new bufferedwriter ( new filewriter ( string . format ( "res/distance-%d.txt" , u . userid ) ) ) ; for ( int i = 0 ; i < u . records . size ( ) ; i ++ ) { for ( int j = i + 1 ; j < u . records . size ( ) ; j ++ ) { double d = u . records . get ( i ) . distanceto ( u . records . get ( j ) ) ; fout . write ( double . tostring ( d ) + "\\n" ) ; } } fout . close ( ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } }
tr	4	protected list < node > getsearchedpath ( list < node > step ) { node thisnode = step . head ( ) . get ( ) ; if ( searchinfo . isgoal ( thisnode ) ) { return step ; } iterable < node > descendants = searchinfo . getdescendantnodes ( step . head ( ) . get ( ) ) ; for ( node descendant : descendants ) { list < node > path = getsearchedpath ( step . add ( descendant ) ) ; if ( ! path . isempty ( ) ) { return path ; } } return listfactory . getemptysimplelist ( ) ; }
tr	4	public resource update ( stringbuilder sb , string ime ) { resource resu ; resu = c . dohvatiresurs ( ime ) ; resu . setsadrzaj ( dohvatisadrzajdatoteke ( ime ) ) ; system . out . println ( ime ) ; file file = new file ( nazivspremista + "\\\\" + ime ) ; if ( resu . getsadrzaj ( ) . tostring ( ) . equals ( sb . tostring ( ) ) ) { setchanged ( ) ; notifyobservers ( "stranica nije updaejtana" ) ; } else { setchanged ( ) ; notifyobservers ( "stranica updejtana" ) ; try { filewriter fw = new filewriter ( file . getabsolutefile ( ) ) ; bufferedwriter bw = new bufferedwriter ( fw ) ; bw . write ( sb . tostring ( ) ) ; bw . close ( ) ; } catch ( ioexception ex ) { logger . getlogger ( cacheimpl . class . getname ( ) ) . log ( level . severe , null , ex ) ; } } return resu ; }
tr	1	public boolean isvaliditem ( entitytype et , material mat ) { if ( et == null || mat == null ) { return false ; } try { if ( items_required . containskey ( et . name ( ) ) ) { if ( items_required . get ( et . name ( ) ) . contains ( "any" ) ) { return true ; } if ( items_required . get ( et . name ( ) ) . contains ( string . valueof ( mat . getid ( ) ) ) ) { return true ; } else { for ( string s : items_required . get ( et . name ( ) ) ) { if ( s . touppercase ( ) . equals ( mat . tostring ( ) ) ) { return true ; } } } } } catch ( exception ex ) { logdebug ( "isvaliditem: catching exception: " + ex . getmessage ( ) + " [: " + et . name ( ) + "] [" + mat . name ( ) + "] [" + items_required . size ( ) + "]" ) ; return false ; } return false ; }
tr	6	public void projectsmenuview ( ) { resultset rs = null ; try { statement statement = connection . createstatement ( ) ; rs = statement . executequery ( "select * from projects order by id asc" ) ; } catch ( sqlexception sqe ) { logger . log ( level . severe , "error retrieving projects. error: {0}" , sqe . getmessage ( ) ) ; system . out . println ( "there was an error retreiving projects." ) ; } string columnnames = "id\\t title" ; system . out . println ( columnnames ) ; try { while ( rs . next ( ) ) { int id = rs . getint ( "id" ) ; string title = rs . getstring ( "title" ) ; string displayrow = string . format ( "%4d<litcomma> %20s" , id , title ) ; system . out . println ( displayrow ) ; } } catch ( sqlexception sqe ) { logger . log ( level . severe , "error processing result set. error: {0}" , sqe . getmessage ( ) ) ; system . out . println ( "there was an error in processing the result set." ) ; return ; } }
tr	10	private int getqtdmeses ( ) { int qtdmeses = 0 ; list < string > meses = getmeses ( ) ; string mesinicial = meses . get ( 0 ) ; string mesfinal = meses . get ( 1 ) ; string teste = mesinicial . substring ( 13 , 16 ) . trim ( ) ; int mesinicio = integer . parseint ( mesinicial . substring ( 13 , 16 ) . trim ( ) ) ; int mesfim = integer . parseint ( mesfinal . substring ( 13 , 16 ) . trim ( ) ) ; int anoinicio = integer . parseint ( mesinicial . substring ( 19 , 21 ) . trim ( ) ) ; int anofim = integer . parseint ( mesfinal . substring ( 19 , 21 ) . trim ( ) ) ; if ( anoinicio < anofim || anoinicio != anofim ) { int anos = anofim - anoinicio ; anos = anos * 12 ; qtdmeses = ( mesfim + anos ) - mesinicio ; } else { qtdmeses = mesfim - mesinicio ; } return qtdmeses ; }
tr	2	public static string constructnewreq ( int reqorigin , int reqtime , int mynodenumber , arraylist < integer > alreadyseennew ) { string req = "rr" ; req = req + reqorigin + ";" + reqtime + ";" + mynodenumber + ";" ; for ( int i = 0 ; i < alreadyseennew . size ( ) ; i ++ ) { req = req + alreadyseennew . get ( i ) + "<litcomma>" ; } req = req + "0<litcomma>" ; req = req . substring ( 0 , req . length ( ) - 1 ) ; return req ; }
tr	10	private void exportobjtype ( connection conn , dbobjtype dbobjtype ) throws sqlexception , ioexception { file dir = new file ( cachedir . getpath ( ) + '/' + dbobjtype . tostring ( ) ) ; if ( ! dir . exists ( ) ) { dir . mkdirs ( ) ; } if ( dbobjtype == dbobjtype . table ) { string query = "declare\\n" + "begin\\n" + "dbms_metadata.set_transform_param (dbms_metadata.session_transform<litcomma>'storage'<litcomma>false);\\n" + "dbms_metadata.set_transform_param (dbms_metadata.session_transform<litcomma>'tablespace'<litcomma>false);\\n" + "dbms_metadata.set_transform_param (dbms_metadata.session_transform<litcomma>'segment_attributes'<litcomma> false);\\n" + "dbms_metadata.set_transform_param (dbms_metadata.session_transform<litcomma>'ref_constraints'<litcomma> false);\\n" + "dbms_metadata.set_transform_param (dbms_metadata.session_transform<litcomma>'constraints'<litcomma> false);\\n" + "end;" ; try ( callablestatement stmt = conn . preparecall ( query ) ) { stmt . execute ( ) ; } } list < string > objnamelist = getobjnamelist ( conn , dbobjtype ) ; queryrunner queryrunner = new queryrunner ( ) ; abstractlisthandler < string > handler = new abstractlisthandler < string > ( ) { @ override protected string handlerow ( resultset rs ) throws sqlexception { clob clob = rs . getclob ( "ddl" ) ; try ( reader input = clob . getcharacterstream ( ) ; stringwriter output = new stringwriter ( ) ) { ioutils . copy ( input , output ) ; return output . tostring ( ) ; } catch ( ioexception ex ) { throw new sqlexception ( ex ) ; } } } ; for ( string objname : objnamelist ) { list < string > objdesclist = queryrunner . query ( conn , "select dbms_metadata.get_ddl(?<litcomma> ?) as ddl from dual" , handler , dbobjtype . tostring ( ) , objname ) ; string objdesc = objdesclist . get ( 0 ) ; file file = new file ( cachedir . getpath ( ) + '/' + dbobjtype + '/' + objname + ".sql" ) ; try ( stringreader input = new stringreader ( objdesc ) ; filewriter output = new filewriter ( file ) ) { ioutils . copy ( input , output ) ; } } }
tr	5	private int getmin ( string word1 , string word2 , int [ ] [ ] min1 , int index1 , int index2 ) { if ( index1 == word1 . length ( ) ) { for ( int j = index2 ; j < word2 . length ( ) ; j ++ ) min1 [ index1 ] [ j ] = word2 . substring ( index2 + 1 ) . length ( ) ; return word2 . substring ( index2 ) . length ( ) ; } else if ( index2 == word2 . length ( ) ) { for ( int j = index1 ; j < word1 . length ( ) ; j ++ ) min1 [ j ] [ index2 ] = word1 . substring ( index1 + 1 ) . length ( ) ; return word1 . substring ( index1 ) . length ( ) ; } int first = 0 ; if ( min1 [ index1 + 1 ] [ index2 + 1 ] > 0 ) first = min1 [ index1 + 1 ] [ index2 + 1 ] ; else first = getmin ( word1 , word2 , min1 , index1 + 1 , index2 + 1 ) ; int sec = 0 ; if ( min1 [ index1 + 1 ] [ index2 ] > 0 ) sec = min1 [ index1 + 1 ] [ index2 ] ; else sec = getmin ( word1 , word2 , min1 , index1 + 1 , index2 ) ; int third = 0 ; if ( min1 [ index1 ] [ index2 + 1 ] > 0 ) third = min1 [ index1 ] [ index2 + 1 ] ; else third = getmin ( word1 , word2 , min1 , index1 , index2 + 1 ) ; int sum = math . min ( third , math . min ( first , sec ) ) + 1 ; min1 [ index1 ] [ index2 ] = sum ; return sum ; }
tr	4	@ override public void keypressed ( keyevent e ) { if ( e . getkeycode ( ) == keyevent . vk_up ) { snake snake = gamefield . getsnake ( ) ; rabbit rabbit = gamefield . getrabbit ( ) ; int snakex = snake . getx ( ) ; int snakey = snake . gety ( ) ; snake . setlocation ( snakex , snakey - 45 ) ; iscrashed = gamefield . iscrashed ( snake , rabbit ) ; if ( iscrashed ) { recreaterabbit ( rabbit ) ; } isborder = gamefield . isborder ( snake , e ) ; if ( isborder ) { snake . setlocation ( snake . getx ( ) , 616 ) ; iscrashed = gamefield . iscrashed ( snake , rabbit ) ; if ( iscrashed ) { recreaterabbit ( rabbit ) ; } } } if ( e . getkeycode ( ) == keyevent . vk_down ) { snake snake = gamefield . getsnake ( ) ; rabbit rabbit = gamefield . getrabbit ( ) ; int snakex = snake . getx ( ) ; int snakey = snake . gety ( ) ; snake . setlocation ( snakex , snakey + 45 ) ; iscrashed = gamefield . iscrashed ( snake , rabbit ) ; if ( iscrashed ) { recreaterabbit ( rabbit ) ; } isborder = gamefield . isborder ( snake , e ) ; if ( isborder ) { snake . setlocation ( snake . getx ( ) , 0 ) ; iscrashed = gamefield . iscrashed ( snake , rabbit ) ; if ( iscrashed ) { recreaterabbit ( rabbit ) ; } } } if ( e . getkeycode ( ) == keyevent . vk_right ) { snake snake = gamefield . getsnake ( ) ; rabbit rabbit = gamefield . getrabbit ( ) ; int snakex = snake . getx ( ) ; int snakey = snake . gety ( ) ; snake . setlocation ( snakex + 45 , snakey ) ; iscrashed = gamefield . iscrashed ( snake , rabbit ) ; if ( iscrashed ) { recreaterabbit ( rabbit ) ; } isborder = gamefield . isborder ( snake , e ) ; if ( isborder ) { snake . setlocation ( 0 , snake . gety ( ) ) ; iscrashed = gamefield . iscrashed ( snake , rabbit ) ; if ( iscrashed ) { recreaterabbit ( rabbit ) ; } } } if ( e . getkeycode ( ) == keyevent . vk_left ) { snake snake = gamefield . getsnake ( ) ; rabbit rabbit = gamefield . getrabbit ( ) ; int snakex = snake . getx ( ) ; int snakey = snake . gety ( ) ; snake . setlocation ( snakex - 45 , snakey ) ; iscrashed = gamefield . iscrashed ( snake , rabbit ) ; if ( iscrashed ) { recreaterabbit ( rabbit ) ; } isborder = gamefield . isborder ( snake , e ) ; if ( isborder ) { snake . setlocation ( 939 , snake . gety ( ) ) ; iscrashed = gamefield . iscrashed ( snake , rabbit ) ; if ( iscrashed ) { recreaterabbit ( rabbit ) ; } } } }
tr	9	public void updateweights ( int layerindex , boolean printinfo ) throws exception { arraylist < arraylist < neuron > > networklayers = network . getnetworklayers ( false ) ; arraylist < neuron > currentneuronlayer = networklayers . get ( layerindex ) ; for ( int i = 0 ; i < currentneuronlayer . size ( ) ; i ++ ) { neuron neuron = currentneuronlayer . get ( i ) ; system . out . println ( "\\n\\n------------updating weights for : " + neuron + "\\n" ) ; arraylist < double > deltamatrix = neuron . getdeltarow ( true ) ; arraylist < double > weightmatrix = neuron . getinputweightsrow ( true ) ; arraylist < double > updatedweights = new arraylist < double > ( ) ; if ( ( weightmatrix . size ( ) ) != deltamatrix . size ( ) ) { throw new exception ( "error<litcomma> weight array is not the same as delta array for " + neuron ) ; } for ( int j = 0 ; j < deltamatrix . size ( ) ; j ++ ) { double deltaplusweight = nnutilities . formatdouble ( ( weightmatrix . get ( j ) + deltamatrix . get ( j ) ) ) ; updatedweights . add ( deltaplusweight ) ; } neuron . setinputweightsrow ( updatedweights ) ; if ( printinfo ) { system . out . println ( "\\n" + neuron + " updated weights calculated and set : " ) ; system . out . println ( neuron . getinputweightsrow ( false ) ) ; } } }
tr	8	public point nearestpoint ( point point ) { int x = point . getx ( ) ; int y = point . gety ( ) ; int col = this . getcolfromx ( x ) ; int row = this . getrowfromy ( y ) ; square square = this . getsquare ( row , col ) ; if ( square . haspoint ( ) ) { return square . getpoint ( ) ; } square neighbor ; for ( int i = row - 1 ; i < row + 2 ; i ++ ) { for ( int j = col - 1 ; j < col + 2 ; j ++ ) { neighbor = this . getsquare ( i , j ) ; if ( neighbor != null && neighbor . haspoint ( ) ) { return neighbor . getpoint ( ) ; } } } return point ; }
tr	3	@ override public list < string > getimageslist ( string url ) { arraylist < string > imglist = new arraylist < string > ( ) ; try { string pagestr = readpage ( new url ( url ) ) ; matcher m = imagepattern . matcher ( pagestr ) ; while ( m . find ( ) ) { imglist . add ( m . group ( 1 ) ) ; } } catch ( malformedurlexception e ) { e . printstacktrace ( ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } return imglist ; }
tr	10	private arraylist < string > parsesites ( ) throws parserexception { arraylist < string > links = new arraylist < string > ( ) ; parser parser = new parser ( ) ; parser . setresource ( resourceurl ) ; hasattributefilter filter = new hasattributefilter ( "class" , "pages" ) ; nodelist nl = parser . parse ( filter ) ; node pagenode = nl . elementat ( 0 ) ; if ( pagenode != null ) { int numofpages = pagenode . getchildren ( ) . size ( ) - 2 ; for ( int i = 1 ; i < numofpages ; i ++ ) { node page = pagenode . getchildren ( ) . elementat ( i ) ; if ( page instanceof tag ) { string link = ( ( tag ) page ) . getattribute ( "href" ) ; link = link . replace ( "&amp;" , "&" ) ; link = link . split ( "\\\\?" ) [ 1 ] ; link = resourceurl + "?" + link ; links . add ( link ) ; } } return links ; } else { arraylist < string > list = new arraylist < string > ( ) ; list . add ( resourceurl ) ; return list ; } }
tr	6	public static void findnoncommon ( string word1 , string word2 ) { hashset < character > h1 = new hashset < character > ( ) ; hashset < character > h2 = new hashset < character > ( ) ; for ( int i = 0 ; i < word1 . length ( ) ; i ++ ) { h1 . add ( word1 . charat ( i ) ) ; } for ( int i = 0 ; i < word2 . length ( ) ; i ++ ) { h2 . add ( word2 . charat ( i ) ) ; } char [ ] w1 , w2 ; w1 = word1 . tochararray ( ) ; w2 = word2 . tochararray ( ) ; stringbuilder sb = new stringbuilder ( ) ; for ( char i : w1 ) { if ( ! h2 . contains ( i ) ) sb . append ( i ) ; } for ( char i : w2 ) { if ( ! h1 . contains ( i ) ) sb . append ( i ) ; } system . out . println ( sb . tostring ( ) ) ; }
tr	5	public static inventory frombase64 ( string data ) { bytearrayinputstream inputstream = new bytearrayinputstream ( base64coder . decodelines ( data ) ) ; nbttaglist itemlist = ( nbttaglist ) nbtbase . a ( new datainputstream ( inputstream ) ) ; inventory inventory = new craftinventorycustom ( null , itemlist . size ( ) ) ; for ( int i = 0 ; i < itemlist . size ( ) ; i ++ ) { nbttagcompound inputobject = ( nbttagcompound ) itemlist . get ( i ) ; if ( ! inputobject . isempty ( ) ) { inventory . setitem ( i , craftitemstack . ascraftmirror ( net . minecraft . server . v1_6_r3 . itemstack . createstack ( inputobject ) ) ) ; } } return inventory ; }
tr	5	private void initgrid ( ) { grid = new site [ xsize ] [ ysize ] ; for ( int x = 0 ; x < xsize ; x ++ ) { for ( int y = 0 ; y < ysize ; y ++ ) { double distance = math . sqrt ( math . pow ( ( center1 - x ) , 2 ) + math . pow ( ( center1 - y ) , 2 ) ) ; double distance2 = math . sqrt ( math . pow ( ( center2 - x ) , 2 ) + math . pow ( ( center2 - y ) , 2 ) ) ; double cap = minfood ; if ( distance <= distance2 && distance >= 0 ) { cap = maxfood * ( 1 - distance / spread ) ; } if ( distance > distance2 && distance2 >= 0 ) { cap = maxfood * ( 1 - distance2 / spread ) ; } if ( cap < minfood ) { cap = minfood ; } grid [ x ] [ y ] = new site ( cap , x , y ) ; totalfoodcapacity = totalfoodcapacity + cap ; } } }
tr	10	private void handleclient ( ) throws ioexception { inputstream instream = clisock . getinputstream ( ) ; outputstream outstream = clisock . getoutputstream ( ) ; inputstreamreader inputstreamreader = new inputstreamreader ( instream ) ; bufferedreader in = new bufferedreader ( inputstreamreader ) ; printwriter out = new printwriter ( outstream ) ; simpledateformat formatter = new simpledateformat ( "yyyy-mm-dd" ) ; date date ; string response = null ; try { date = formatter . parse ( in . readline ( ) ) ; date today = new date ( ) ; int diffindays = ( int ) ( ( date . gettime ( ) - today . gettime ( ) ) / ( 1000 * 60 * 60 * 24 ) ) ; response = "the diffrence is: " + diffindays ; } catch ( parseexception e ) { response = "err cannot prase date!!!" ; } out . println ( response ) ; out . flush ( ) ; out . close ( ) ; }
tr	8	@ test public void test ( ) { stringobjectbuilder stringbuilder = new stringobjectbuilder ( ) ; integerobjectbuilder integerbuilder = new integerobjectbuilder ( ) ; doubleobjectbuilder doublebuilder = new doubleobjectbuilder ( ) ; bigdecimalobjectbuilder decimalbuilder = new bigdecimalobjectbuilder ( ) ; table table = new table ( ) ; table . addcolumn ( "c1" , stringbuilder ) ; table . addcolumn ( "c2" , integerbuilder ) ; table . loadfromfile ( new file ( "data/a.csv" ) , "<litcomma>" , false ) ; index idx = new index ( table , "c1" ) ; set < key > keys = idx . getkeys ( ) ; assert . asserttrue ( keys . contains ( idx . buildkey ( "a" ) ) ) ; assert . asserttrue ( keys . contains ( idx . buildkey ( "b" ) ) ) ; list < row > rows ; rows = idx . getrows ( idx . buildkey ( "a" ) ) ; assert . assertnotnull ( rows ) ; assert . assertequals ( 2 , rows . size ( ) ) ; rows = idx . getrows ( idx . buildkey ( "b" ) ) ; assert . assertnotnull ( rows ) ; assert . assertequals ( 1 , rows . size ( ) ) ; rows = idx . getrows ( idx . buildkey ( "c" ) ) ; assert . assertnull ( rows ) ; }
tr	9	public static directedpseudograph < string , edge > buildfromfile ( string file ) throws filenotfoundexception , ioexception { directedpseudograph < string , edge > g = new directedpseudograph < string , edge > ( edge . class ) ; map < string , string > vertices = new hashmap < string , string > ( ) ; bufferedreader e = null ; e = new bufferedreader ( new filereader ( file ) ) ; string line , edge [ ] ; try { while ( ( line = e . readline ( ) ) != null ) { edge = line . split ( ";" ) ; if ( edge . length > 1 ) { string fromstr = edge [ 0 ] ; string tostr = edge [ 1 ] ; string from , to = null ; from = vertices . get ( fromstr ) ; if ( from == null ) { from = new string ( fromstr ) ; vertices . put ( fromstr , from ) ; g . addvertex ( from ) ; } to = vertices . get ( tostr ) ; if ( to == null ) { to = new string ( tostr ) ; vertices . put ( tostr , to ) ; g . addvertex ( to ) ; } g . addedge ( from , to , new edge ( ) ) ; } } } catch ( ioexception e ) { e . printstacktrace ( ) ; } e . close ( ) ; return g ; }
tr	10	public void execute ( ) throws mojoexecutionexception , mojofailureexception { string [ ] split = webjar . split ( ":" ) ; string artifact = split [ 0 ] ; artifactversion requestedversion = split . length >= 2 ? new defaultartifactversion ( split [ 1 ] ) : null ; collection < artifactversion > versions = mavencentral . getartifacts ( artifact , requestedversion , getlog ( ) ) . get ( artifact ) ; artifactversion resolvedversion = null ; if ( requestedversion == null ) { resolvedversion = versions . iterator ( ) . next ( ) ; } else { for ( artifactversion artifactversion : versions ) { if ( artifactversion . equals ( requestedversion ) ) { resolvedversion = artifactversion ; break ; } } } dependency dependency = new dependency ( ) ; dependency . setgroupid ( "org.webjars" ) ; dependency . setartifactid ( artifact ) ; dependency . setversion ( resolvedversion . tostring ( ) ) ; dependency updateddependency = null ; iterator < dependency > existingdependencies = project . getoriginalmodel ( ) . getdependencies ( ) . iterator ( ) ; while ( existingdependencies . hasnext ( ) ) { dependency existingdependency = existingdependencies . next ( ) ; if ( existingdependency . getgroupid ( ) . equals ( dependency . getgroupid ( ) ) && existingdependency . getartifactid ( ) . equals ( dependency . getartifactid ( ) ) ) { if ( existingdependency . getversion ( ) . equals ( dependency . getversion ( ) ) ) { getlog ( ) . warn ( artifact + ":" + dependency . getversion ( ) + " is already a dependency. aborting." ) ; return ; } updateddependency = existingdependency ; existingdependencies . remove ( ) ; break ; } } project . getoriginalmodel ( ) . adddependency ( dependency ) ; try { modelwriter . write ( project . getfile ( ) , null , project . getoriginalmodel ( ) ) ; } catch ( ioexception e ) { throw new mojoexecutionexception ( "could not add dependency" , e ) ; } if ( updateddependency != null ) { getlog ( ) . info ( "updated " + artifact + " from " + updateddependency . getversion ( ) + " to " + resolvedversion ) ; } else { getlog ( ) . info ( "added dependency: " + artifact + ":" + resolvedversion ) ; } }
tr	7	public string createcontent ( ) { stringbuilder httpresponse = new stringbuilder ( ) ; httpresponse . append ( " <h2> <p>number of all requset: " + serverstatus . gettotalrequest ( ) + " </p> </h2>" ) ; httpresponse . append ( " <h2> <p>number of active connections: " + serverstatus . getactiveconnection ( ) + " </p> </h2>" ) ; httpresponse . append ( " <h2> <p>number of unique request : " + managerdb . getubiquerequestlist ( ) . size ( ) + " </p> </h2>" ) ; httpresponse . append ( " <table border=\\"3\\" cellpadding=\\"5\\">" ) ; httpresponse . append ( " <tr> <th>ip</th>  <th>count of request</th>  <th>time lsat request</th> </tr>" ) ; list < requests > allrequest = managerdb . getiprequestlist ( ) ; for ( requests request : allrequest ) { httpresponse . append ( " <tr> <td>" + request . getip ( ) + "</td>  <td>" + request . getrequestcount ( ) + "</td>  <td>" + request . gettimelastrequest ( ) + "</td> </tr>" ) ; } httpresponse . append ( " </table>" ) ; httpresponse . append ( "<br></br>" ) ; httpresponse . append ( "<br></br>" ) ; httpresponse . append ( " <table border=\\"3\\" cellpadding=\\"5\\">" ) ; httpresponse . append ( " <tr> <th>url</th>  <th>count of redirect</th>  </tr>" ) ; list < redirects > allredirect = managerdb . getredirectlist ( ) ; for ( redirects request : allredirect ) { httpresponse . append ( " <tr> <td>" + request . geturl ( ) + "</td>  <td>" + request . getamountredir ( ) + "</td>  </tr>" ) ; } httpresponse . append ( " </table>" ) ; httpresponse . append ( "<br></br>" ) ; httpresponse . append ( "<br></br>" ) ; httpresponse . append ( " <table border=\\"3\\" cellpadding=\\"5\\">" ) ; httpresponse . append ( " <tr> <th>src_ip</th>  <th>uri</th>  <th>timestamp</th>  <th>sent_bytes</th>  <th>received_bytes</th>   <th>speed</th>  </tr>" ) ; list < connection > allconnectrequest = managerdb . getconnectionlist ( ) ; int first = allconnectrequest . size ( ) ; if ( first < 16 ) { first = 0 ; } else { first -= 16 ; } for ( int i = first ; i < allconnectrequest . size ( ) ; i ++ ) { connection request = allconnectrequest . get ( i ) ; httpresponse . append ( " <tr> <td>" + request . getsrcip ( ) + "</td>  <td>" + request . geturi ( ) + "</td>   <td>" + request . gettimestamp ( ) + "</td>   " + "  <td>" + request . getsentbytes ( ) + "</td>  <td>" + request . getreceivedbytes ( ) + "</td>  <td>" + request . getspeed ( ) + "</td> </tr>" ) ; } httpresponse . append ( " </table>" ) ; return httpresponse . tostring ( ) ; }
tr	6	public static hashmap < string , double > readlocationentropygpsbased ( int samplerate ) { if ( gpsentropy . isempty ( ) ) { string fname = null ; try { bufferedreader fin ; if ( samplerate <= 100 ) { fname = string . format ( "res/gpsentropy-%ds.txt" , samplerate ) ; } else { fname = "res/gpsentropy.txt" ; } fin = new bufferedreader ( new filereader ( fname ) ) ; system . out . println ( string . format ( "file %s found!" , fname ) ) ; string l = null ; while ( ( l = fin . readline ( ) ) != null ) { string [ ] ls = l . split ( "\\\\s+" ) ; string gps = ls [ 0 ] ; double entropy = double . parsedouble ( ls [ 1 ] ) ; if ( ! gpsentropy . containskey ( gps ) ) gpsentropy . put ( gps , entropy ) ; } fin . close ( ) ; } catch ( filenotfoundexception e ) { system . out . println ( string . format ( "no gps entropy file %s found. generate a new one ..." , fname ) ) ; writelocationentropy ( false , samplerate ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } system . out . println ( string . format ( "gps location size %d." , gpsentropy . size ( ) ) ) ; } return gpsentropy ; }
tr	4	public static void checkall ( list < list < obj > > objlist , int delta ) { list < list < obj > > list1 = objlist . next ; while ( list1 != null ) { list < obj > obj1 = list1 . data . next ; while ( obj1 != null ) { list < list < obj > > list2 = list1 ; list < obj > obj2 = obj1 . next ; while ( list2 != null ) { while ( obj2 != null ) { if ( obj2 . data . shape . intersects ( obj1 . data . shape ) ) { obj2 . data . collide ( obj1 . data , delta ) ; obj1 . data . collide ( obj2 . data , delta ) ; } obj2 = obj2 . next ; } list2 = list2 . next ; if ( list2 != null ) obj2 = list2 . data . next ; } obj1 = obj1 . next ; } list1 = list1 . next ; if ( list1 != null ) obj1 = list1 . data . next ; } }
tr	2	public void run ( ) { pruebathreads11 . sett ( pruebathreads11 . gett ( ) + 1 ) ; while ( cont >= 0 ) { string s = pruebathreads11 . getclase ( ) ; if ( s == null ) { system . out . println ( this . id + " - " + cont + " sin ultima lectura" ) ; } else { system . out . println ( this . id + " - " + cont + " ultima escritura " + s ) ; } pruebathreads11 . setclase ( id ) ; if ( cont == 0 ) { int r = pruebathreads11 . gett ( ) ; pruebathreads11 . sett ( r - 1 ) ; system . out . println ( "ultima escritura " + pruebathreads11 . getclase ( ) + " - " + ( r - 1 ) + " threads activos" ) ; } else { delaysegundo ( ) ; } cont -- ; } }
tr	5	public void grabararchivodehelper ( string paquetecodigogenerado , stringbuilder contenido , string path ) { string foldercodigogenerado = paquetecodigogenerado . replace ( "." , "\\\\" ) ; string filename = path + file . separatorchar + foldercodigogenerado + file . separatorchar + nombreclasehelpervoentity + ".java" ; system . out . println ( "path: " + path ) ; system . out . println ( "paquetecodigogenerado: " + paquetecodigogenerado ) ; system . out . println ( "foldercodigogenerado: " + foldercodigogenerado ) ; system . out . println ( "filename: " + filename ) ; contenido . insert ( 0 , importsclasehelpervoentity . tostring ( ) ) ; contenido . insert ( 0 , nl + "/* en caso de cambiar el modelo de datos<litcomma> esta clase debe ser modificada o volver a generar. */" + nl + nl ) ; contenido . insert ( 0 , nl + "* fecha creacion: " + new date ( ) . tostring ( ) + " */" + nl ) ; contenido . insert ( 0 , nl + "/* clase - autogenerada" + nl ) ; contenido . insert ( 0 , "package " + paquetecodigogenerado + ";" + nl ) ; try { filewriter fw = new filewriter ( filename ) ; bufferedwriter bw = new bufferedwriter ( fw ) ; printwriter salida = new printwriter ( bw ) ; salida . println ( contenido . tostring ( ) ) ; salida . close ( ) ; } catch ( ioexception e ) { system . out . println ( "error al escribir el archivo" ) ; e . printstacktrace ( ) ; } }
tr	8	static public void drawtab ( arraylist list ) { try { int width = list . size ( ) * 50 , height = 500 , index = 50 ; bufferedimage bi = new bufferedimage ( width , height , bufferedimage . type_int_argb ) ; graphics2d ig2 = bi . creategraphics ( ) ; font font = new font ( "timesroman" , font . bold , 20 ) ; ig2 . setfont ( font ) ; ig2 . setpaint ( color . black ) ; printlines ( ig2 , width ) ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { arraylist < note > secondlist = ( arraylist < note > ) list . get ( i ) ; printsecondlist ( secondlist , index , ig2 ) ; index += 50 ; } imageio . write ( bi , "png" , new file ( "test.png" ) ) ; } catch ( exception ie ) { ie . printstacktrace ( ) ; } }
tr	10	private static rgb888image readpalettedimage ( littleendiandatainput in , int width , int height , boolean toptobottom , int bitsperpixel , int [ ] palette ) throws ioexception { bufferedpalettedrgb888image image = new bufferedpalettedrgb888image ( width , height , palette ) ; byte [ ] row = new byte [ ( width * bitsperpixel + 31 ) / 32 * 4 ] ; int pixelsperbyte = 8 / bitsperpixel ; int mask = ( 1 << bitsperpixel ) - 1 ; int y , end , inc ; if ( toptobottom ) { y = 0 ; end = height ; inc = 1 ; } else { y = height - 1 ; end = - 1 ; inc = - 1 ; } for ( ; y != end ; y += inc ) { in . readfully ( row ) ; for ( int x = 0 ; x < width ; x ++ ) { int index = x / pixelsperbyte ; int shift = ( pixelsperbyte - 1 - x % pixelsperbyte ) * bitsperpixel ; image . setrgb888pixel ( x , y , ( byte ) ( row [ index ] > > > shift & mask ) ) ; } } return image ; }
tr	2	public static void main ( string [ ] args ) { string a = new string ( "ajax amsterdam" ) ; string b = new string ( "abc" ) ; if ( a . equals ( b ) ) { system . out . println ( a + " equals gelijk " + b ) ; } else { system . out . println ( a + " equals ongelijk " + b ) ; } if ( a == b ) { system . out . println ( a + " ==gelijk " + b ) ; } else { system . out . println ( a + " == ongelijk " + b ) ; } b = "ajax amsterdam" ; if ( a . equals ( b ) ) { system . out . println ( a + " equals gelijk " + b ) ; } else { system . out . println ( a + " equals ongelijk " + b ) ; } if ( a == b ) { system . out . println ( a + " == gelijk " + b ) ; } else { system . out . println ( a + " == ongelijk " + b ) ; } }
tr	8	private void executerequest ( ) { httpclient client = new httpclient ( ) ; httpconnectionmanagerparams hcmanagerparams = client . gethttpconnectionmanager ( ) . getparams ( ) ; hcmanagerparams . setconnectiontimeout ( connectionoption . connectiontimeout ) ; hcmanagerparams . setsotimeout ( connectionoption . opttimeout ) ; postmethod post = new postmethod ( requesturl ) ; if ( requestheaders != null && ! requestheaders . isempty ( ) ) { set < string > headerkeyset = requestheaders . keyset ( ) ; for ( string headerkey : headerkeyset ) { string headervalue = requestheaders . get ( headerkey ) ; post . addrequestheader ( headerkey , headervalue ) ; } } post . setrequestentity ( new stringrequestentity ( requestbody ) ) ; try { responsecode = client . executemethod ( post ) ; responsebody = post . getresponsebodyasstring ( ) ; logger . info ( responsebody ) ; header [ ] rspheaders = post . getresponseheaders ( ) ; responseheaders = new hashmap < string , string > ( ) ; for ( header rspheader : rspheaders ) { responseheaders . put ( rspheader . getname ( ) , rspheader . getvalue ( ) ) ; } } catch ( ioexception ex ) { logger . error ( ex ) ; } }
tr	1	public record ( string line ) { string [ ] ls = line . split ( "<litcomma>" ) ; userid = integer . parseint ( ls [ 0 ] ) ; latitude = double . parsedouble ( ls [ 1 ] ) ; longitude = double . parsedouble ( ls [ 2 ] ) ; time = ls [ 3 ] ; try { timestamp = sdf . parse ( time ) . gettime ( ) / 1000 ; } catch ( parseexception e ) { system . out . println ( ls [ 3 ] + "\\n" + e . getmessage ( ) ) ; } locid = integer . parseint ( ls [ 4 ] ) ; }
tr	4	public static void main ( string [ ] args ) { scanner scanner = new scanner ( system . in ) ; system . out . println ( "ingrese la fecha (dd/mm/aaaa): " ) ; string sfecha = scanner . next ( ) ; fecha f = new fecha ( sfecha ) ; system . out . println ( "la fecha ingresada es:" + f ) ; system . out . println ( "ingrese d\xedas a sumar(pueden ser negativos)" ) ; int diassum = scanner . nextint ( ) ; f . adddias ( diassum ) ; system . out . println ( "sumando " + diassum + " d\xedas<litcomma> queda: " + f ) ; }
tr	8	@ override public void execute ( ) throws mojoexecutionexception , mojofailureexception { final map < string , artifact > artifactmap = mavenproject . getartifactmap ( ) ; final artifact artifact = artifactmap . get ( commons_daemon_group_id + ":" + commons_daemon_artifact_id ) ; if ( null == artifact ) throw new mojoexecutionexception ( "could not retrieve commons-daemon artifact" ) ; final file file = artifact . getfile ( ) ; final string daemonjarfilename = file . getname ( ) ; initializationscriptconfiguration initializationscriptconfiguration = new initializationscriptconfiguration ( applicationconfiguration , daemonconfiguration , targetsystemconfiguration , daemonjarfilename ) ; final stringtemplate stringtemplate = loadinitscripttemplate ( ) ; final initializationscript initializationscript = initializationscriptfactory . createinitializationscript ( stringtemplate , initializationscriptconfiguration ) ; final initializationscriptwriter initializationscriptwriter = new initializationscriptwriter ( initializationscript ) ; try { initializationscriptwriter . writetoexecutablefile ( projectbuilddirectory ) ; } catch ( ioexception e ) { throw new mojoexecutionexception ( string . format ( "could not create [%s] in [%s]" , applicationconfiguration . getscriptname ( ) , projectbuilddirectory ) , e ) ; } }
tr	7	public static void main ( string [ ] args ) throws unknownhostexception , ioexception { final httpget example = new httpget ( ) ; boolean quit = false ; final inputstream inputstream = system . in ; final inputstreamreader inputstreamreader = new inputstreamreader ( inputstream ) ; final bufferedreader in = new bufferedreader ( inputstreamreader ) ; while ( ! quit ) { system . out . println ( "input host: " ) ; string host = in . readline ( ) ; system . out . println ( "input path: " ) ; string path = in . readline ( ) ; quit = example . createrequest ( host , http_method , path ) ; } }
tr	10	public static void processafiles ( ) { file dir = new file ( caminho_log ) ; file [ ] arquivos = dir . listfiles ( ) ; arraylist < aluno > alunos = new arraylist < aluno > ( ) ; for ( int i = 0 ; i < arquivos . length ; i ++ ) { string arquivo = arquivos [ i ] . getname ( ) ; string classe = arquivo . substring ( 0 , arquivo . indexof ( "*" ) ) ; arquivo = arquivo . substring ( arquivo . indexof ( "*" ) , arquivo . length ( ) ) ; string anoclasse = arquivo . substring ( arquivo . indexof ( "*" ) + 1 , arquivo . indexof ( "-" ) ) ; string semestreclasse = arquivo . substring ( arquivo . indexof ( "-" ) + 1 , arquivo . indexof ( "." ) ) ; leumfilecarregabanco ( arquivos [ i ] . getpath ( ) , alunos , classe , anoclasse , semestreclasse ) ; } bancomysql b = new bancomysql ( ) ; for ( aluno aluno : alunos ) { aluno . inserir ( b ) ; } }
tr	1	public static string getrole ( ) { string role = null ; if ( getrobot ( ) . getpixelcolor ( 0 , 0 ) . equals ( color . red ) ) { role = "melee" ; } else if ( getrobot ( ) . getpixelcolor ( 0 , 0 ) . equals ( color . blue ) ) { role = "duo" ; } else if ( getrobot ( ) . getpixelcolor ( 0 , 0 ) . equals ( color . green ) ) { role = "ranged" ; } else { role = "unidentified" ; } return role ; }
tr	8	public static void main ( string [ ] args ) { int x = 2 ; int y = 17 ; int z = power ( x , y ) ; system . out . println ( z ) ; x = 3 ; y = 18 ; int sisa = 0 , base = x , s = 0 ; list < integer > list = new arraylist < integer > ( ) ; while ( y > 1 ) { ++ s ; if ( y % 2 == 1 ) { list . add ( x ) ; } x *= x ; y >>= 1 ; } for ( int i : list ) { x *= i ; ++ s ; } system . out . println ( "total step : " + s ) ; system . out . println ( x ) ; }
tr	9	public void map ( longwritable key , text value , context context ) throws ioexception , interruptedexception { configuration conf = context . getconfiguration ( ) ; int gridrange = conf . getint ( "grid.range" , 1 ) ; intwritable timestamp = new intwritable ( ) ; stringtokenizer tokenizer = new stringtokenizer ( value . tostring ( ) ) ; list < integer > coordsdata = new arraylist < > ( ) ; if ( tokenizer . hasmoretokens ( ) ) { timestamp . set ( integer . parseint ( tokenizer . nexttoken ( ) ) ) ; } while ( tokenizer . hasmoretokens ( ) ) { int recordcoord = integer . parseint ( tokenizer . nexttoken ( ) ) ; int gridcoord = calculategridcoord ( recordcoord , gridrange ) ; coordsdata . add ( gridcoord ) ; } coordinates coords = new coordinates ( coordsdata ) ; coordstimestamptuple tuple = new coordstimestamptuple ( coords , timestamp ) ; context . write ( tuple , timestamp ) ; }
tr	3	public static void printfrequencies ( list < frequency > frequencies ) { int tottwogrmcnt = 0 ; boolean istwogram = false ; for ( frequency frequency : frequencies ) { tottwogrmcnt += frequency . getfrequency ( ) ; if ( frequency . gettext ( ) . split ( " " ) . length > 1 ) istwogram = true ; } if ( istwogram ) { system . out . println ( "total 2-gram count: " + tottwogrmcnt ) ; system . out . println ( "unique 2-gram count: " + frequencies . size ( ) ) ; } else { system . out . println ( "total item count: " + tottwogrmcnt ) ; system . out . println ( "unique item count: " + frequencies . size ( ) ) ; } system . out . println ( ) ; for ( frequency frequency : frequencies ) { system . out . println ( frequency . tostring ( ) ) ; } system . out . println ( ) ; system . out . println ( "===============" ) ; system . out . println ( ) ; }
tr	10	public boolean loadconfig ( map < string , configentry > configmap ) { file configfile = new file ( fspath . base_path + "/main.config" ) ; try ( filereader fr = new filereader ( configfile ) ) { gson gson = new gson ( ) ; map map = gson . fromjson ( fr , map . class ) ; iterator keys = map . keyset ( ) . iterator ( ) ; while ( keys . hasnext ( ) ) { string key = keys . next ( ) . tostring ( ) ; map entry = ( map ) map . get ( key ) ; configentry . vcstype vcstype ; try { vcstype = configentry . vcstype . valueof ( entry . get ( "vcs_type" ) . tostring ( ) ) ; } catch ( illegalargumentexception ex ) { return false ; } string dburl = entry . get ( "db_url" ) . tostring ( ) ; if ( stringutils . isblank ( dburl ) ) { return false ; } string vcsurl = entry . get ( "vcs_url" ) . tostring ( ) ; if ( stringutils . isblank ( vcsurl ) ) { return false ; } configentry configentry = new configentry ( dburl , vcsurl , vcstype ) ; configmap . put ( key , configentry ) ; } } catch ( ioexception ex ) { throw new assertionerror ( "loadconfig" , ex ) ; } return true ; }
tr	2	public void nextstep ( ) { boardtemp = new board ( board ) ; for ( int i = 0 ; i < board . gettablica_length ( ) ; i ++ ) { for ( int j = 0 ; j < board . gettablica_length ( ) ; j ++ ) { if ( ! board . isalive ( i , j ) ) { if ( board . neigtbourscount ( i , j ) == 3 ) { boardtemp . settablica ( i , j , true ) ; } } else { if ( ( board . neigtbourscount ( i , j ) == 1 || ( board . neigtbourscount ( i , j ) == 0 ) ) || board . neigtbourscount ( i , j ) > 3 ) boardtemp . settablica ( i , j , false ) ; } } } board . settablica ( boardtemp . gettablica ( ) ) ; }
tr	2	private void _buildui ( ) { this . status . setforeground ( color . dark_gray ) ; font font = new font ( "" , font . bold , 14 ) ; this . status . setfont ( font ) ; this . morningafternooncomparebtn . setbackground ( color . dark_gray ) ; this . morningafternooncomparebtn . setforeground ( color . orange ) ; this . checkduplicateblightbtn . setbackground ( color . dark_gray ) ; this . checkduplicateblightbtn . setforeground ( color . orange ) ; this . checkduplicatevtradebtn . setbackground ( color . dark_gray ) ; this . checkduplicatevtradebtn . setforeground ( color . orange ) ; panel p1 = new panel ( new gridlayout ( 1 , 3 ) ) ; p1 . add ( this . morningafternooncomparebtn ) ; p1 . add ( this . checkduplicateblightbtn ) ; p1 . add ( this . checkduplicatevtradebtn ) ; setlayout ( new borderlayout ( ) ) ; add ( this . status , "north" ) ; add ( p1 , "center" ) ; add ( new label ( ) , "south" ) ; add ( new label ( ) , "east" ) ; add ( new label ( ) , "west" ) ; setbackground ( color . orange ) ; }
tr	5	public static void parallel ( final int numthreads , final block block ) { final thread [ ] threads = new thread [ numthreads ] ; final throwable [ ] failure = { null } ; for ( int i = 0 ; i < threads . length ; ++ i ) { final int index = i ; threads [ i ] = new thread ( "worker #" + i ) { @ override public void run ( ) { try { block . call ( index ) ; } catch ( final throwable xx ) { failure [ 0 ] = xx ; } } } ; } for ( thread t : threads ) { t . start ( ) ; } for ( thread t : threads ) { try { t . join ( ) ; } catch ( final interruptedexception xx ) { throw new runtimeexception ( "unexpected" , xx ) ; } } if ( failure [ 0 ] instanceof runtimeexception ) { throw ( runtimeexception ) failure [ 0 ] ; } else if ( failure [ 0 ] instanceof error ) { throw ( error ) failure [ 0 ] ; } else { assert ( failure [ 0 ] == null ) ; } }
tr	5	private void updatedaycombobox ( ) { int day = ( int ) daycombobox . getselecteditem ( ) ; month m = month . of ( getmonthcombobox ( ) . getselectedindex ( ) + 1 ) ; int year = ( int ) yearcombobox . getselecteditem ( ) ; boolean leap = false ; if ( year % 4 == 0 ) { leap = ! leap ; } int daysinmonth ; switch ( m ) { case january : case march : case may : case july : case august : case october : case december : daysinmonth = 31 ; break ; case april : case june : case september : case november : daysinmonth = 30 ; break ; case february : if ( leap ) { daysinmonth = 29 ; } else { daysinmonth = 28 ; } break ; default : daysinmonth = - 1 ; } daycombobox . setmodel ( daycomboboxmodel . getcorrectmodel ( daysinmonth ) ) ; if ( day > daysinmonth ) { day = daysinmonth ; } daycombobox . setselecteditem ( day ) ; }
tr	5	private void parseparameterdefinitions ( final string [ ] paramdefinitions ) { int paramindex = 0 ; parameternames = new string [ paramdefinitions . length ] ; allpossibleparametervalues = new double [ paramdefinitions . length ] [ ] ; for ( final string parameterdefinition : paramdefinitions ) { final string [ ] tokens = parameterdefinition . split ( "[=<litcomma>]" ) ; assert tokens . length > 3 : "parameter definition must be of the form name=value1<litcomma>value2<litcomma>..." ; parameternames [ paramindex ] = tokens [ 0 ] ; final doublelist paramvalues = new doublearraylist ( ) ; for ( int valueindex = 1 ; valueindex < tokens . length ; valueindex ++ ) { paramvalues . add ( double . parsedouble ( tokens [ valueindex ] ) ) ; } allpossibleparametervalues [ paramindex ] = paramvalues . todoublearray ( ) ; paramindex ++ ; } }
tr	10	public arraylist < arraylist < integer > > permuteunique ( int [ ] num ) { arraylist < arraylist < integer > > res = new arraylist < arraylist < integer > > ( ) ; if ( num . length == 0 ) return res ; arrays . sort ( num ) ; arraylist < integer > init = new arraylist < integer > ( ) ; hashset < string > dup = new hashset < string > ( ) ; init . add ( num [ 0 ] ) ; res . add ( init ) ; dup . add ( init . tostring ( ) ) ; for ( int i = 1 ; i < num . length ; i ++ ) { int n = num [ i ] ; int size = res . size ( ) ; for ( int k = 0 ; k < size ; k ++ ) { arraylist < integer > t = res . get ( 0 ) ; res . remove ( 0 ) ; for ( int j = 0 ; j <= t . size ( ) ; j ++ ) { arraylist < integer > nt = new arraylist < integer > ( ) ; nt . addall ( t ) ; nt . add ( j , n ) ; if ( ! dup . contains ( nt . tostring ( ) ) ) { res . add ( nt ) ; dup . add ( nt . tostring ( ) ) ; } } } } return res ; }
tr	1	public serverrunningframe ( configurations configurations ) { getcontentpane ( ) . setlayout ( null ) ; this . configurations = configurations ; setsize ( 500 , 500 ) ; setdefaultcloseoperation ( jframe . exit_on_close ) ; setvisible ( true ) ; thread = new thread ( this ) ; jpanel panel = new jpanel ( ) ; panel . setborder ( new emptyborder ( 5 , 5 , 5 , 5 ) ) ; panel . setbackground ( color . white ) ; panel . setforeground ( color . black ) ; panel . setbounds ( 10 , 11 , 414 , 239 ) ; getcontentpane ( ) . add ( panel ) ; panel . setlayout ( null ) ; textarea = new jtextarea ( ) ; textarea . setbackground ( color . pink ) ; textarea . setlinewrap ( true ) ; textarea . setwrapstyleword ( true ) ; textarea . setbounds ( 10 , 11 , 394 , 217 ) ; panel . add ( textarea ) ; thread . start ( ) ; }
tr	3	@ test ( enabled = true ) public void eraseindexrepository ( ) { try { solrquery params = new solrquery ( ) ; params . set ( "q" , "*:*" ) ; params . setrows ( 100 ) ; queryresponse response = server . query ( params ) ; for ( solrdocument doc : response . getresults ( ) ) { system . out . println ( doc . getfieldvalue ( "id" ) ) ; } server . setsotimeout ( 3600000 ) ; server . setconnectiontimeout ( 3600000 ) ; server . deletebyquery ( "*:*" ) ; server . commit ( ) ; } catch ( solrserverexception e ) { logger . error ( e . getmessage ( ) , e ) ; } catch ( ioexception e ) { logger . error ( e . getmessage ( ) , e ) ; } }
tr	7	public static void main ( string [ ] args ) { scanner scan = new scanner ( system . in ) ; system . out . println ( "enter number1: " ) ; string num1 = scan . next ( ) ; system . out . println ( "enter number2: " ) ; string num2 = scan . next ( ) ; boolean isint1 , isint2 ; isint1 = isinteger ( num1 ) ; isint2 = isinteger ( num2 ) ; long n1 , n2 ; if ( ! isint1 || ! isint2 ) { system . out . println ( "the strings entered are not numeric." ) ; system . exit ( 0 ) ; } n1 = integer . parseint ( num1 ) ; n2 = integer . parseint ( num2 ) ; multiply ( n1 , n2 ) ; }
tr	6	public string decypher ( string input ) { string [ ] cyphers = input . split ( " " ) ; stringbuffer sb = new stringbuffer ( ) ; for ( int i = 0 ; i < cyphers . length ; i ++ ) { long num = long . parselong ( cyphers [ i ] ) ; long temp = endecrypt ( num , d , n ) ; debug . print ( "temp is:" + temp ) ; char c = ( char ) temp ; sb . append ( c ) ; } return sb . tostring ( ) ; }
tr	7	private static string gethtmlreadline ( string httpurl ) { string currentline = "" ; string totalstring = "" ; inputstream urlstream ; string content = "" ; try { url url = new url ( httpurl ) ; httpurlconnection connection = ( httpurlconnection ) url . openconnection ( ) ; connection . connect ( ) ; urlstream = connection . getinputstream ( ) ; bufferedreader reader = new bufferedreader ( new inputstreamreader ( urlstream , "utf-8" ) ) ; while ( ( currentline = reader . readline ( ) ) != null ) { totalstring += currentline + "\\n" ; } content = totalstring ; } catch ( exception e ) { e . printstacktrace ( ) ; } return content ; }
tr	2	public void run ( ) { try { for ( int i = 1 ; i > 0 ; i ++ ) { dadosgerais dados = new dadosgerais ( ) ; gui . label1 . settext ( "menu principal - " + dadosgerais . formatadatagui . format ( dadosgerais . data ) ) ; thread . sleep ( 100 ) ; i = 1 ; } } catch ( interruptedexception e ) { system . out . println ( "--------------------------" ) ; system . out . println ( "log: erro - thread do rel\xf3gio parou." ) ; system . out . println ( "--------------------------" ) ; e . printstacktrace ( ) ; } }
tr	7	@ override public list < edge > generatemst ( graph graph ) { fheap = new fheap ( ) ; list < edge > generatedmst = new arraylist < edge > ( ) ; int startnodeindex = graph . selectarandomnode ( ) ; for ( int i = 0 ; i < graph . getnumvertices ( ) ; i ++ ) { fheap . insert ( integer . max_value ) ; } fheap . decreasekey ( fheap . getnodelist ( ) . get ( startnodeindex ) , 0 , startnodeindex ) ; while ( fheap . getsize ( ) != 0 ) { fheapnode newestmstnode = fheap . deletemin ( ) ; startnodeindex = newestmstnode . getindex ( ) ; for ( adjlistnode node : graph . getadjlist ( ) . get ( startnodeindex ) ) { int nodeindex = node . gettargetnode ( ) ; int cost = node . getedge ( ) . getcost ( ) ; fheap . decreasekey ( fheap . getnodelist ( ) . get ( nodeindex ) , cost , startnodeindex ) ; } generatedmst . add ( new edge ( newestmstnode . getpredecessor ( ) , newestmstnode . getindex ( ) , newestmstnode . getcost ( ) , false ) ) ; } generatedmst . remove ( 0 ) ; return generatedmst ; }
tr	1	public string tostring ( ) { string format = "" ; if ( this . a == 0 ) if ( this . b == - 1 ) return "-i" ; else if ( this . b == 0 ) return "0" ; else if ( this . b == 1 ) return "i" ; else return string . format ( "%di" , this . b ) ; else if ( this . b == - 1 ) return string . format ( "%d-i" , this . a ) ; else if ( this . b == 0 ) return string . format ( "%d" , this . a ) ; else if ( this . b == 1 ) return string . format ( "%d+i" , this . a ) ; else return string . format ( this . b < 0 ? "%d%di" : "%d+%di" , this . a , this . b ) ; }
tr	7	public static void main ( string [ ] args ) { scanner sc = new scanner ( system . in ) ; system . out . print ( "please enter the public key number(n):" ) ; long input_n = sc . nextlong ( ) ; system . out . println ( ) ; system . out . print ( "please enter the public key value(e):" ) ; long input_e = sc . nextlong ( ) ; system . out . println ( ) ; bruteforce bf = new bruteforce ( input_n , input_e ) ; key k = bf . bruteforcecrack ( ) ; if ( k == null ) { system . out . println ( "the input key pair in not factorizable" ) ; } else { system . out . println ( "the private key(d<litcomma>m) pair for the input is (" + k . getdecryptkey ( ) + "<litcomma>" + k . getm ( ) + ")" ) ; } while ( true ) { system . out . println ( "please input encrypt number:" ) ; long input = sc . nextlong ( ) ; int letter = ( int ) rsa . modulo ( input , k . getdecryptkey ( ) , input_n ) ; system . out . println ( "decrypt result is:" + letter ) ; system . out . println ( "letter is:" + ( char ) letter ) ; } }
tr	9	public void teststart ( ) throws exception { tokenizer tokenizer = new tokenizer ( ) ; string identifierline = "function helloworld" ; string integerline = "1024" ; string floatline = "3.14159265" ; string stringline = "\\"hello<litcomma> world!\\" + - / * . ^ % : == >=" ; string typeparamline = "public class testclass<t...>" ; tokenizer . addsourceline ( identifierline ) ; tokenizer . addsourceline ( integerline ) ; tokenizer . addsourceline ( floatline ) ; tokenizer . addsourceline ( stringline ) ; tokenizer . addsourceline ( typeparamline ) ; list < tokenstring > result = tokenizer . start ( ) ; for ( tokenstring str : result ) { system . out . println ( "\\n~~~~~~~~~~~~~~~~~~~~~~~~" ) ; for ( token tk : str . tolist ( ) ) { system . out . println ( "type = " + tk . type + "<litcomma> contents = " + tk . contents ) ; } system . out . println ( "~~~~~~~~~~~~~~~~~~~~~~~~\\n" ) ; } }
tr	7	public static void main ( string [ ] arg ) { int n = 100 ; int [ ] a = new int [ n ] ; system . out . print ( "dessa tal slumpas till arrayen:" ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 10 == 0 ) system . out . println ( ) ; a [ i ] = ( int ) ( 1000 * math . random ( ) ) ; system . out . print ( a [ i ] + "\\t" ) ; } int summa , max , min ; double medel ; summa = 0 ; max = - 1 ; min = 1000 ; for ( int i = 0 ; i < n ; i ++ ) { summa = summa + a [ i ] ; if ( a [ i ] > max ) max = a [ i ] ; if ( a [ i ] < min ) min = a [ i ] ; } medel = ( double ) summa / n ; system . out . println ( " " ) ; system . out . println ( "summa = " + summa + " medel = " + medel ) ; system . out . println ( "max = " + max + " min = " + min ) ; }
tr	4	@ test public void testarrayparameter_get ( ) { final arrayparameter arrayparam = new arrayparameter ( "arrayparam" ) ; final singleparameter ap0 = new singleparameter ( "arrayentry0" , "avalue0" ) ; final singleparameter ap1 = new singleparameter ( "arrayentry1" , "avalue1" ) ; final singleparameter ap2 = new singleparameter ( "arrayentry2" , "avalue2" ) ; arrayparam . add ( ap0 ) ; arrayparam . add ( ap1 ) ; arrayparam . add ( ap2 ) ; assertequals ( ap0 , arrayparam . get ( ap0 . getname ( ) ) ) ; assertequals ( ap1 , arrayparam . get ( ap1 . getname ( ) ) ) ; assertequals ( ap2 , arrayparam . get ( ap2 . getname ( ) ) ) ; }
tr	2	public static void writeseperatefile ( integer docid , string url , string path , string parenturl , string title , string h1 , string h2 , string h3 , string bold , string strong , string em , string anchortext , string parseddata , string filename ) throws ioexception { filewriter fstream = new filewriter ( path_location + filename ) ; bufferedwriter out = new bufferedwriter ( fstream ) ; out . write ( docid . tostring ( ) ) ; out . newline ( ) ; out . write ( url ) ; out . newline ( ) ; out . write ( path ) ; out . newline ( ) ; if ( parenturl != null ) { out . write ( parenturl ) ; out . newline ( ) ; } out . write ( title ) ; out . newline ( ) ; out . write ( h1 ) ; out . newline ( ) ; out . write ( h2 ) ; out . newline ( ) ; out . write ( h3 ) ; out . newline ( ) ; out . write ( bold ) ; out . newline ( ) ; out . write ( strong ) ; out . newline ( ) ; out . write ( em ) ; out . newline ( ) ; out . write ( anchortext ) ; out . newline ( ) ; out . write ( parseddata ) ; out . close ( ) ; }
tr	9	private static void startgame ( ) throws ioexception { fourinrowpuzzle p = new fourinrowpuzzle ( ) ; game game = new game ( ) ; scanner in = new scanner ( system . in ) ; boolean player = false ; puzzle_hole_colors currentcolor ; short column = 0 ; short maxdepth ; long starttime , endtime ; system . out . print ( "0: you play first<litcomma> 1 computer play first: " ) ; player = ( in . nextbyte ( ) != 0 ) ; system . out . print ( "enter max depth: " ) ; maxdepth = in . nextshort ( ) ; game . setmaxdepth ( ( byte ) maxdepth ) ; system . out . println ( p . tostring ( ) ) ; while ( ! p . isfull ( ) && ! p . isdone ( ) ) { try { if ( player ) { currentcolor = players . player1 ; game . setpuzzle ( p ) ; system . out . println ( "computer is thinking ..." ) ; starttime = system . currenttimemillis ( ) ; column = game . getnextplay ( ) ; endtime = system . currenttimemillis ( ) ; system . out . println ( "computer played: " + column ) ; system . out . println ( "created nodes: " + game . getgraphnodescount ( ) ) ; system . out . println ( "took(" + ( float ) ( endtime - starttime ) / 1000 + "s)" ) ; } else { currentcolor = players . player2 ; system . out . print ( "your turn<litcomma> type a column number: " ) ; column = in . nextshort ( ) ; } p . addtoken ( currentcolor , ( byte ) column ) ; system . out . println ( p . tostring ( ) ) ; player = ! player ; } catch ( fullcolumn e ) { system . out . println ( "column is full!" ) ; } } system . out . println ( p . tostring ( ) ) ; if ( p . isdone ( ) ) { if ( p . getwinner ( ) == puzzle_hole_colors . red ) system . out . println ( "red won!" ) ; else if ( p . getwinner ( ) == puzzle_hole_colors . black ) system . out . println ( "black won!" ) ; } else { system . out . println ( "no body won!" ) ; } system . out . println ( "" ) ; }
tr	1	public pelivihko ( ) { yhdistelmat = new enummap < jatsiyhdistelma , integer > ( jatsiyhdistelma . class ) ; jatsiyhdistelmat = new arraylist < jatsiyhdistelma > ( ) ; jatsiyhdistelmat . add ( jatsiyhdistelma . ykkoset ) ; jatsiyhdistelmat . add ( jatsiyhdistelma . kakkoset ) ; jatsiyhdistelmat . add ( jatsiyhdistelma . kolmoset ) ; jatsiyhdistelmat . add ( jatsiyhdistelma . neloset ) ; jatsiyhdistelmat . add ( jatsiyhdistelma . viitoset ) ; jatsiyhdistelmat . add ( jatsiyhdistelma . kuutoset ) ; jatsiyhdistelmat . add ( jatsiyhdistelma . pari ) ; jatsiyhdistelmat . add ( jatsiyhdistelma . kaksi_paria ) ; jatsiyhdistelmat . add ( jatsiyhdistelma . kolme_samaa ) ; jatsiyhdistelmat . add ( jatsiyhdistelma . nelja_samaa ) ; jatsiyhdistelmat . add ( jatsiyhdistelma . pikkusuora ) ; jatsiyhdistelmat . add ( jatsiyhdistelma . isosuora ) ; jatsiyhdistelmat . add ( jatsiyhdistelma . tayskasi ) ; jatsiyhdistelmat . add ( jatsiyhdistelma . sattuma ) ; jatsiyhdistelmat . add ( jatsiyhdistelma . yatzy ) ; for ( int i = 0 ; i < jatsiyhdistelmat . size ( ) ; i ++ ) { yhdistelmat . put ( jatsiyhdistelmat . get ( i ) , null ) ; } valisumma = 0 ; bonus = 0 ; summa = 0 ; full = false ; }
tr	9	public void apresentar ( livraria livraria ) { int acumulado = 0 ; int max ; list < topvendidos > listatop = null ; list < topvendidos > listatopgeral = null ; boolean contem ; for ( venda v : this . listadevendas ) { acumulado += v . total_geral ( ) ; for ( produtovendido p : v . getprodutos ( ) ) { if ( listatop == null ) { listatop . add ( new topvendidos ( p . codigo ( ) , p . getqtde ( ) ) ) ; } else { contem = false ; for ( topvendidos tp : listatop ) { if ( tp . getcod ( ) == p . codigo ( ) ) { tp . aumentaqtde ( p . getqtde ( ) ) ; contem = true ; } } if ( ! contem ) { listatop . add ( new topvendidos ( p . codigo ( ) , p . getqtde ( ) ) ) ; } } } } while ( ! listatop . isempty ( ) ) { max = 0 ; for ( topvendidos tp : listatop ) { if ( tp . getqtde ( ) > max ) { max = tp . getqtde ( ) ; } } for ( topvendidos tp : listatop ) { if ( tp . getqtde ( ) == max ) { listatopgeral . add ( tp ) ; listatop . remove ( tp ) ; } } } for ( int i = 0 ; i <= 4 ; i ++ ) { livraria . descritor ( listatopgeral . get ( i ) . getcod ( ) ) . imprimir ( ) ; } }
tr	10	public boolean oncommand ( commandsender sender , command cmd , string label , string [ ] args ) { if ( ! ( sender instanceof player ) ) return true ; player player = ( player ) sender ; if ( cmd . getname ( ) . equalsignorecase ( "blocklist" ) ) { string s = chatcolor . gold + "custom block list :" ; int x = 1 ; for ( iterator < customblock > i = getcustomblocks ( ) . iterator ( ) ; i . hasnext ( ) ; s = s + chatcolor . gold + "\\n" + x ++ + ". " + ( ( customblock ) i . next ( ) ) . getname ( ) ) ; player . sendmessage ( s ) ; return true ; } else if ( ( cmd . getname ( ) . equalsignorecase ( "getblock" ) ) && ( args . length >= 1 ) ) { string name = args [ 0 ] ; boolean number = true ; for ( int x = 0 ; x < name . length ( ) ; x ++ ) { char c = name . charat ( x ) ; if ( ( c != '0' ) && ( c != '1' ) && ( c != '2' ) && ( c != '3' ) && ( c != '4' ) && ( c != '5' ) && ( c != '6' ) && ( c != '7' ) && ( c != '8' ) && ( c != '9' ) ) { number = false ; } } int amount = 1 ; customblock block = getcustomblockfromname ( name ) ; if ( number ) { block = ( customblock ) this . customblocks . get ( integer . parseint ( name ) - 1 ) ; if ( ( integer . parseint ( name ) - 1 >= this . customblocks . size ( ) ) || ( integer . parseint ( name ) - 1 < 0 ) ) { player . sendmessage ( chatcolor . red + "no custom block with index : " + name + " was found." ) ; return true ; } } if ( block == null ) { player . sendmessage ( chatcolor . red + "no custom block with name : " + name + " was found." ) ; } else { if ( args . length == 2 ) { amount = integer . parseint ( args [ 1 ] ) ; if ( amount > block . getmaxstacksize ( ) ) amount = block . getmaxstacksize ( ) ; } itemstack item = setcustomblockamount ( getitem ( block ) , amount ) ; player . getinventory ( ) . additem ( new itemstack [ ] { item } ) ; player . sendmessage ( chatcolor . green + "you get " + block . getname ( ) + " x" + amount ) ; } return true ; } return false ; }
tr	9	public static int formuladadi ( string formula ) throws invalidformulaexception { if ( formula == null ) throw new invalidformulaexception ( ) ; if ( stringutils . isempty ( formula ) ) throw new invalidformulaexception ( ) ; stringtokenizer st = new stringtokenizer ( formula , "+-" , true ) ; arraylist < string > positivi , negativi ; positivi = new arraylist < string > ( ) ; negativi = new arraylist < string > ( ) ; positivi . add ( st . nexttoken ( ) ) ; while ( st . hasmoretokens ( ) ) { string segno = st . nexttoken ( ) ; if ( segno . equals ( "+" ) ) { positivi . add ( st . nexttoken ( ) ) ; } else { negativi . add ( st . nexttoken ( ) ) ; } } int tot = 0 ; for ( string lancio : positivi ) { st = new stringtokenizer ( lancio , "d" ) ; int n = integer . parseint ( st . nexttoken ( ) ) ; int x = integer . parseint ( st . nexttoken ( ) ) ; for ( int i = 0 ; i < n ; i ++ ) { tot += lancia1dx ( x ) ; } } for ( string lancio : negativi ) { st = new stringtokenizer ( lancio , "d" ) ; int n = integer . parseint ( st . nexttoken ( ) ) ; int x = integer . parseint ( st . nexttoken ( ) ) ; for ( int i = 0 ; i < n ; i ++ ) { tot -= lancia1dx ( x ) ; } } return tot ; }
tr	8	public int ladderlength ( string start , string end , hashset < string > dict ) { if ( dict . size ( ) == 0 ) return 0 ; linkedlist < string > wordqueue = new linkedlist < string > ( ) ; linkedlist < integer > distancequeue = new linkedlist < integer > ( ) ; wordqueue . add ( start ) ; distancequeue . add ( 1 ) ; while ( ! wordqueue . isempty ( ) ) { string currword = wordqueue . pop ( ) ; integer currdistance = distancequeue . pop ( ) ; if ( currword . equals ( end ) ) { return currdistance ; } for ( int i = 0 ; i < currword . length ( ) ; i ++ ) { char [ ] currchararr = currword . tochararray ( ) ; for ( char c = 'a' ; c <= 'z' ; c ++ ) { currchararr [ i ] = c ; string newword = new string ( currchararr ) ; if ( newword == end ) return currdistance + 1 ; if ( dict . contains ( newword ) ) { wordqueue . add ( newword ) ; distancequeue . add ( currdistance + 1 ) ; dict . remove ( newword ) ; } } } } return 0 ; }
tr	4	private void decodeonestream ( file wavefile , samplerate samplerate , channels channels , rtpstream stream ) throws exception { opusdecoder decoder ; if ( channels == null ) decoder = new opusdecoder ( stream . getsamplerate ( ) , stream . getpackets ( ) [ 0 ] . getpayload ( ) ) ; else decoder = new opusdecoder ( samplerate , channels ) ; try { randomaccessfile f = new randomaccessfile ( wavefile , "rw" ) ; f . setlength ( 0 ) ; littleendiandataoutput outstream = new littleendiandataoutput ( f ) ; try { writewaveheader ( decoder , outstream , 44 ) ; if ( f . length ( ) != 44 ) throw new illegalstateexception ( "wave header should be 44 bytes<litcomma> not " + f . length ( ) ) ; convert ( decoder , stream , outstream ) ; long filesize = f . length ( ) ; f . seek ( 0 ) ; writewaveheader ( decoder , outstream , filesize ) ; } finally { f . close ( ) ; } } finally { decoder . destroy ( ) ; } }
tr	9	public double calculateage ( int birthdate , int birthmonth , int birthyear ) throws exception { calendar c = calendar . getinstance ( ) ; c . set ( calendar . year , birthyear ) ; c . set ( calendar . month , birthmonth - 1 ) ; c . set ( calendar . date , birthdate ) ; simpledateformat readformat = new simpledateformat ( "yyyy mm dd" ) ; calendar c1 = calendar . getinstance ( ) ; if ( c . before ( c1 ) ) { string curr = readformat . format ( c1 . gettime ( ) ) ; string array [ ] = curr . split ( "\\\\s+" ) ; integer years = integer . valueof ( array [ 0 ] ) - birthyear ; double months = ( double ) math . abs ( integer . valueof ( array [ 1 ] ) - birthmonth ) / 12 ; decimalformat df = new decimalformat ( "#.##" ) ; string mon = df . format ( months ) ; return ( years + double . valueof ( mon ) ) ; } else { throw new exception ( ) ; } }
tr	2	public void makemove ( chessposition from , chessposition to ) throws chessexception { super . makemove ( from , to ) ; int idx = ( ( from . getrow ( ) + 1 ) * 9 ) + ( from . getcol ( ) + 1 ) ; jlabel jl = ( jlabel ) board_ui . getcontentpane ( ) . getcomponent ( idx ) ; if ( jl == null ) return ; jl . settext ( " " ) ; if ( to == null ) return ; idx = ( ( to . getrow ( ) + 1 ) * 9 ) + ( to . getcol ( ) + 1 ) ; jl = ( jlabel ) board_ui . getcontentpane ( ) . getcomponent ( idx ) ; if ( jl == null ) return ; jl . settext ( board [ to . getrow ( ) ] [ to . getcol ( ) ] . getimage ( ) ) ; board_ui . repaint ( ) ; }
tr	8	public void loadfromfile ( file file , string separator , boolean skipfirst ) { try { bufferedreader in = new bufferedreader ( new filereader ( file ) ) ; string line ; int irow = - 1 ; pattern pattern = pattern . compile ( separator , pattern . literal ) ; while ( ( line = in . readline ( ) ) != null ) { ++ irow ; if ( irow == 0 && skipfirst ) continue ; if ( stringutils . trimtonull ( line ) == null ) continue ; string [ ] tokens = pattern . split ( line , - 1 ) ; int icol = - 1 ; row row = new row ( ) ; for ( string token : tokens ) { ++ icol ; if ( icol + 1 > this . colnames . size ( ) ) break ; row . data . add ( this . objectbuilders . get ( icol ) . build ( token ) ) ; } row . names = this . colnames ; this . rows . add ( row ) ; } in . close ( ) ; } catch ( filenotfoundexception e ) { throw new runtimeexception ( e ) ; } catch ( ioexception e ) { throw new runtimeexception ( e ) ; } }
tr	3	decisiontreeimpl ( dataset train ) { if ( train == null || train . instances == null || train . instances . isempty ( ) ) { return ; } list < attribute > attributes = new arraylist < attribute > ( ) ; for ( instance instance : train . instances ) { for ( int i = 0 ; i < instance . attributes . size ( ) ; i ++ ) { if ( i > attributes . size ( ) - 1 ) { attributes . add ( new attribute ( i ) ) ; } attributes . get ( i ) . addvalue ( instance . attributes . get ( i ) ) ; } } root = traintree ( train . instances , attributes , train . instances , "root" ) ; }
tr	10	private static string getcolumnvalue ( resultset rs , int coltype , int colindex ) throws sqlexception , ioexception { string value = "" ; switch ( coltype ) { case types . bit : object bit = rs . getobject ( colindex ) ; if ( bit != null ) { value = string . valueof ( bit ) ; } break ; case types . boolean : boolean b = rs . getboolean ( colindex ) ; if ( ! rs . wasnull ( ) ) { value = boolean . valueof ( b ) . tostring ( ) ; } break ; case types . clob : clob c = rs . getclob ( colindex ) ; if ( c != null ) { value = read ( c ) ; } break ; case types . bigint : case types . decimal : case types . double : case types . float : case types . real : case types . numeric : bigdecimal bd = rs . getbigdecimal ( colindex ) ; if ( bd != null ) { value = "" + bd . doublevalue ( ) ; } break ; case types . integer : case types . tinyint : case types . smallint : int intvalue = rs . getint ( colindex ) ; if ( ! rs . wasnull ( ) ) { value = "" + intvalue ; } break ; case types . java_object : object obj = rs . getobject ( colindex ) ; if ( obj != null ) { value = string . valueof ( obj ) ; } break ; case types . date : java . sql . date date = rs . getdate ( colindex ) ; if ( date != null ) { value = date_formatter . format ( date ) ; ; } break ; case types . time : time t = rs . gettime ( colindex ) ; if ( t != null ) { value = t . tostring ( ) ; } break ; case types . timestamp : timestamp tstamp = rs . gettimestamp ( colindex ) ; if ( tstamp != null ) { value = timestamp_formatter . format ( tstamp ) ; } break ; case types . longvarchar : case types . varchar : case types . char : value = rs . getstring ( colindex ) ; break ; default : value = "" ; } if ( value == null ) { value = "" ; } return value ; }
tr	2	public void save ( ) { filewriter writer = null ; try { writer = new filewriter ( filename ) ; for ( map . entry < string , string > pairs : map . entryset ( ) ) { writer . write ( pairs . getkey ( ) + ": " + pairs . getvalue ( ) + "\\n" ) ; } } catch ( ioexception ex ) { logger . getlogger ( configfile . class . getname ( ) ) . log ( level . severe , null , ex ) ; } finally { try { writer . close ( ) ; } catch ( ioexception ex ) { logger . getlogger ( configfile . class . getname ( ) ) . log ( level . severe , null , ex ) ; } } }
tr	6	private list < student > parse ( final document doc ) { final list < student > students = new vector < student > ( ) ; if ( doc == null ) { return students ; } final element root = doc . getdocumentelement ( ) ; final nodelist nodestudents = root . getchildnodes ( ) ; if ( nodestudents != null ) { if ( nodestudents . getlength ( ) != 0 ) { for ( int i = 0 ; i < nodestudents . getlength ( ) ; ++ i ) { final node nodestudent = nodestudents . item ( i ) ; if ( nodestudent != null ) { if ( nodestudent . getnodetype ( ) == node . element_node ) { final student student = parsestudent ( nodestudent ) ; students . add ( student ) ; } } } } } return students ; }
tr	3	public void run ( ) { try { socket = new socket ( host , port ) ; in = new bufferedreader ( new inputstreamreader ( socket . getinputstream ( ) ) ) ; out = new bufferedwriter ( new outputstreamwriter ( socket . getoutputstream ( ) ) ) ; writeline ( "nick :" + nick ) ; writeline ( "user " + nick + " * * :" + nick ) ; writeline ( "join :" + channel ) ; string line = null ; while ( ( line = in . readline ( ) ) != null ) { system . out . println ( "<<< " + line ) ; message msg = new message ( line ) ; for ( messagehandler mh : handlers ) { mh . handle ( msg ) ; } } } catch ( exception e ) { system . err . println ( "cannot connect and operate bot" ) ; e . printstacktrace ( ) ; system . exit ( 1 ) ; } }
tr	10	private boolean scan ( move move , scandirection scandirection ) { int wall = 0 ; int midpoint = 0 ; int player = move . getplayer ( ) ; if ( scandirection == scandirection . row || scandirection == scandirection . diagnal_right ) { midpoint = move . getcolumn ( ) ; wall = getrowsize ( ) - 1 ; } else if ( scandirection == scandirection . column || scandirection == scandirection . diagnal_left ) { midpoint = move . getrow ( ) ; wall = getcolumnsize ( ) - 1 ; } else { return false ; } int start = getstart ( midpoint ) ; int end = getend ( wall , midpoint ) ; int markcount = 0 ; for ( int i = start ; i <= end ; i ++ ) { if ( markcount == 3 ) { return true ; } integer playerid = null ; if ( scandirection == scandirection . column ) { playerid = getmoveat ( i , move . getcolumn ( ) ) ; } else if ( scandirection == scandirection . row ) { playerid = getmoveat ( move . getrow ( ) , i ) ; } else if ( scandirection == scandirection . diagnal_right ) { int row = getstart ( ( move . getrow ( ) - end ) ) + i ; int column = i ; playerid = getmoveat ( row , column ) ; } else if ( scandirection == scandirection . diagnal_left ) { int row = i ; int column = end - i ; playerid = getmoveat ( row , column ) ; } if ( playerid != null && playerid == player ) { markcount ++ ; } else { markcount = 0 ; } } return markcount == 3 ; }
tr	2	@ requestmapping ( applicationconstants . create_usr ) @ responsebody public object createuser ( @ requestparam ( "name" ) string name , @ requestparam ( "email" ) string email , @ requestparam ( "password" ) string password ) { user user = new user ( ) ; map < object , string > errormap = new hashmap < object , string > ( ) ; if ( name == null || "" . equals ( name ) ) { errormap . put ( 1 , "please enter name" ) ; } if ( email == null || "" . equals ( email ) ) { errormap . put ( 2 , "please enter email" ) ; } if ( password == null || "" . equals ( password ) ) { errormap . put ( 3 , "please enter password" ) ; } if ( errormap . size ( ) > 0 ) { return errormap ; } else { user . setname ( name ) ; user . setemail ( email ) ; user . setpassword ( password ) ; user . setcreateddate ( new date ( ) . tostring ( ) ) ; user . setstatus ( applicationconstants . status_active ) ; userdao . save ( user ) ; return user ; } }
tr	10	public void run ( ) { http10 = true ; boolean badhost = false ; try { in = new datainputstream ( new bufferedinputstream ( s . getinputstream ( ) ) ) ; ou = new dataoutputstream ( new bufferedoutputstream ( s . getoutputstream ( ) ) ) ; s . setsotimeout ( httpreq . client_timeout ) ; string req = in . readline ( ) ; if ( req == null ) { s . close ( ) ; ou . close ( ) ; s = null ; ou = null ; return ; } if ( httpreq . trace_timestamp ) { system . out . println ( "[ui trace " + thread . currentthread ( ) . getname ( ) + "] t current time " + new date ( ) ) ; } if ( httpreq . trace_url == true ) { system . out . println ( "[ui trace " + thread . currentthread ( ) . getname ( ) + "] > " + req ) ; } int req_method ; req_method = req . indexof ( " http/1." , 0 ) ; if ( req_method == - 1 ) http10 = false ; else while ( true ) { string line ; line = in . readline ( ) ; if ( line == null ) break ; if ( line . length ( ) == 0 ) break ; string s1 , s2 ; int j ; j = line . indexof ( ':' , 0 ) ; if ( j == - 1 ) continue ; s1 = line . substring ( 0 , j ) . tolowercase ( ) ; s2 = line . substring ( j + 1 ) ; if ( s1 . equals ( "host" ) && s2 . indexof ( ui . ui_hostname ) == - 1 ) badhost = true ; } string req2 = null ; if ( ! req . startswith ( "get " ) ) { httpreq . server_error ( http10 ? 10 : 9 , 501 , "only get access method is possible for ui" , ou ) ; } if ( ! mgr . checkinetadr ( s . getinetaddress ( ) . getaddress ( ) ) ) { httpreq . server_error ( http10 ? 10 : 9 , 403 , "cache access denied." , ou ) ; } int space ; space = req . indexof ( ' ' ) ; if ( space == - 1 ) httpreq . server_error ( http10 ? 10 : 9 , 400 , "can not find method and uri in request" , ou ) ; if ( req_method == - 1 ) req2 = req . substring ( space + 1 ) ; else req2 = req . substring ( space + 1 , req_method ) ; req2 = req2 . trim ( ) ; if ( req2 . length ( ) == 0 ) httpreq . server_error ( http10 ? 10 : 9 , 400 , "can not find uri in request" , ou ) ; if ( req2 . charat ( 0 ) != '/' ) { httpreq . server_error ( http10 ? 10 : 9 , 400 , "request url not starting with /" , ou ) ; } if ( req2 . equals ( "/" ) ) { req2 = "/homepage" ; badhost = true ; } if ( badhost == false ) { send_reply ( ui . process ( req2 ) ) ; } else { stringbuffer ans = new stringbuffer ( 2048 ) ; ans . append ( "http/1.0 301 wrong_hostname\\r\\ncontent-type: text/html\\r\\n" ) ; ans . append ( "location: http://" ) ; ans . append ( ui . ui_hostname ) ; ans . append ( ':' ) ; ans . append ( ui . uiport ) ; ans . append ( req2 ) ; ans . append ( "\\r\\n\\r\\nbad hostname/redirecting to welcome page!\\n" ) ; ou . writebytes ( ans . tostring ( ) ) ; ou . close ( ) ; ou = null ; s = null ; } } catch ( ioexception err ) { } }
tr	9	public static void main ( string [ ] args ) { try { mongoclient mongo = new mongoclient ( "oceanic.mongohq.com" , 10099 ) ; db db = mongo . getdb ( "luckypants" ) ; if ( db == null ) { system . out . println ( "could not connect to database" ) ; } boolean auth = db . authenticate ( "rishiban" , "rishiban" . tochararray ( ) ) ; if ( auth == false ) { system . out . println ( "could not authenticate" ) ; } dbcollection bookscoll = db . getcollection ( "luckypants" ) ; basicdbobject document = new basicdbobject ( ) ; document . put ( "title" , "lucky pants" ) ; document . put ( "author" , "john doe" ) ; document . put ( "isbn" , "1234" ) ; bookscoll . insert ( document ) ; basicdbobject searchquery = new basicdbobject ( ) ; searchquery . put ( "title" , "lucky pants" ) ; dbcursor cursor = bookscoll . find ( searchquery ) ; while ( cursor . hasnext ( ) ) { system . out . println ( cursor . next ( ) ) ; } searchquery . put ( "title" , "lucky pants" ) ; basicdbobject newdocument = new basicdbobject ( ) ; newdocument . put ( "titile" , "super pants" ) ; basicdbobject updateobj = new basicdbobject ( ) ; updateobj . put ( "$set" , newdocument ) ; bookscoll . update ( searchquery , updateobj ) ; searchquery . put ( "title" , "lucky pants" ) ; bookscoll . remove ( searchquery ) ; searchquery . put ( "title" , "lucky pants" ) ; cursor = bookscoll . find ( searchquery ) ; while ( cursor . hasnext ( ) ) { bookscoll . remove ( searchquery ) ; } system . out . println ( "done" ) ; } catch ( unknownhostexception e ) { e . printstacktrace ( ) ; } catch ( mongoexception e ) { e . printstacktrace ( ) ; } }
tr	9	public static void main ( string [ ] args ) { string ip = joptionpane . showinputdialog ( "enter server ip" ) ; int port = integer . parseint ( joptionpane . showinputdialog ( "enter server port" ) ) ; try { client = new socket ( ip , port ) ; graphicsenvironment gen = graphicsenvironment . getlocalgraphicsenvironment ( ) ; graphicsdevice gdev = gen . getdefaultscreendevice ( ) ; dimension dim = toolkit . getdefaulttoolkit ( ) . getscreensize ( ) ; rectangle rect = new rectangle ( dim ) ; robot robot = new robot ( gdev ) ; drawgui ( ) ; screenshot screenshot = new screenshot ( client , rect , robot ) ; servercommands servercommands = new servercommands ( client , robot ) ; } catch ( exception e ) { system . out . println ( e ) ; } }
tr	5	public void addnode ( tnode toadd ) { if ( toadd != null ) { list < string > titles = new arraylist < string > ( ) ; tnode exists = null ; for ( tnode n : nodes ) { titles . add ( n . gettitle ( ) ) ; if ( n . gettitle ( ) . equals ( toadd . gettitle ( ) ) ) { exists = n ; } } if ( ! titles . contains ( toadd . gettitle ( ) ) ) { nodes . add ( toadd ) ; } else { list < tconnection > connects = toadd . getconnections ( ) ; for ( tconnection con : connects ) { exists . addconnection ( con ) ; } } } }
tr	1	public object maprow ( resultset rs , int rownum ) throws sqlexception { ledger ledger = new ledger ( ) ; ledger . setid ( rs . getint ( "id" ) ) ; ledger . setreceiptdate ( rs . getdate ( "rcv_dt" ) ) ; ledger . setmembername ( rs . getstring ( "mbr_nm" ) ) ; ledger . setchecknumber ( rs . getstring ( "chk_nbr" ) ) ; ledger . setcheckdate ( rs . getdate ( "chk_dt" ) ) ; ledger . setpaymenttype ( rs . getstring ( "pymt_typ" ) ) ; ledger . setdepositamount ( rs . getdouble ( "dpst_amt" ) ) ; ledger . setpaymentamount ( rs . getdouble ( "pymt_amt" ) ) ; ledger . setcomments ( rs . getstring ( "comments" ) ) ; return ledger ; }
tr	9	fourfloatar columns ( int nx , int ny ) { final float sx = 0 , sy = 0 , ex = 800 , ey = 600 ; float [ ] ax , ay , bx , by ; ax = new float [ nx * ny ] ; ay = new float [ nx * ny ] ; bx = new float [ nx * ny ] ; by = new float [ nx * ny ] ; int i ; for ( i = 0 ; i < nx * ny ; i ++ ) { ax [ i ] = ( float ) ( math . random ( ) * ( ex - sx ) + sx ) ; ay [ i ] = ( float ) ( math . random ( ) * ( ey - sy ) + sy ) ; if ( math . random ( ) < 0.5 ) { bx [ i ] = ax [ i ] ; by [ i ] = ay [ i ] + 50 ; } else { bx [ i ] = ax [ i ] + 50 ; by [ i ] = ay [ i ] ; } } return new fourfloatar ( ax , ay , bx , by ) ; }
tr	3	public void logpacket ( datagrampacket packet , inetaddress src , int srcport , inetaddress dst , int dstport ) { if ( ! init ) init ( ) ; int ts_sec = ( int ) ( ( system . currenttimemillis ( ) ) / 1000 ) ; int ts_usec = ( int ) ( ( system . nanotime ( ) ) / 1000 ) % 1000000 ; try { out . writeint ( ts_sec ) ; out . writeint ( ts_usec ) ; byte [ ] bytes = encapsulateip ( packet , src , srcport , dst , dstport ) ; out . writeint ( bytes . length & 0xffff ) ; out . writeint ( bytes . length ) ; out . flush ( ) ; if ( bytes . length > 0 ) out . write ( bytes , 0 , bytes . length & 0xffff ) ; out . flush ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } }
tr	5	public void browse ( ) { jfilechooser fc = new jfilechooser ( ) ; fc . showopendialog ( null ) ; file browse = fc . getselectedfile ( ) ; try { filereader in = new filereader ( browse ) ; filewriter out = new filewriter ( this . file ) ; int c ; while ( ( c = in . read ( ) ) != - 1 ) { out . write ( c ) ; } in . close ( ) ; out . close ( ) ; } catch ( exception ex ) { new clubexception ( "error reading file" , ex . tostring ( ) ) ; } }
tr	8	@ override protected void doget ( httpservletrequest request , httpservletresponse response ) throws servletexception , ioexception { string reportdir = getservletcontext ( ) . getrealpath ( "/web-inf/classes" ) ; string templatepath = reportdir + file . separator + jasperreporttemplate ; string reporttype = request . getparameter ( "reporttype" ) ; reporttype type = reporttype != null && reporttype . equalsignorecase ( "pdf" ) ? reporttype . pdf : reporttype . csv ; long startdate = long . parselong ( request . getparameter ( "start" ) ) / ms_per_sec ; long enddate = long . parselong ( request . getparameter ( "end" ) ) / ms_per_sec ; byte [ ] report = plannerservice . generatereport ( templatepath , type , startdate , enddate ) ; response . setcontenttype ( string . format ( "application/%s" , type == reporttype . csv ? "csv" : "pdf" ) ) ; response . addheader ( "content-disposition" , "attachment; filename=report." + ( type == reporttype . csv ? "csv" : "pdf" ) ) ; response . setcontentlength ( report . length ) ; outputstream responseoutputstream = response . getoutputstream ( ) ; responseoutputstream . write ( report ) ; }
tr	8	public static objectbounds parsefromfile ( url fileurl ) { try { arraylist < point > points = new arraylist < point > ( ) ; bufferedreader breader = new bufferedreader ( new inputstreamreader ( fileurl . openstream ( ) ) ) ; string filecontent = breader . readline ( ) ; string [ ] rawpoints = filecontent . split ( "\\\\|" ) ; for ( string rawpoint : rawpoints ) { string [ ] splittedpoint = rawpoint . split ( "<litcomma>" ) ; int x = integer . parseint ( splittedpoint [ 0 ] ) ; int y = integer . parseint ( splittedpoint [ 1 ] ) ; points . add ( new point ( x , y ) ) ; } breader . close ( ) ; return new objectbounds ( points ) ; } catch ( exception ex ) { ex . printstacktrace ( ) ; } return null ; }
tr	3	public void parseargs ( string [ ] args ) { options options = new options ( ) ; for ( option o : jo . options ) { options . addoption ( o ) ; } commandline parser ; try { parser = new gnuparser ( ) . parse ( options , args ) ; } catch ( parseexception e ) { log . info ( "unable to parse options." ) ; return ; } if ( parser . hasoption ( "help" ) || parser . getoptions ( ) . length == 0 ) { new helpformatter ( ) . printhelp ( "jen <args>" , "jenever - a package manager for java" , options , "" ) ; system . exit ( 0 ) ; } else if ( parser . hasoption ( "init" ) ) { handler . checkparamsset ( ) ; } else { handler . checkparamsset ( ) ; handler . handle ( parser ) ; } }
tr	7	public static void grabphoto ( int pagenumber ) throws ioexception { string pageurl = const . duitangpageurl + pagenumber ; string pagecontent = netutil . getpagesource ( pageurl ) ; list blogs = ( list ) ( ( map ) ( ( map ) jsonutil . getmap4json ( pagecontent ) ) . get ( "data" ) ) . get ( "blogs" ) ; for ( int j = 0 ; j < blogs . size ( ) ; j ++ ) { map picinfo = ( map ) blogs . get ( j ) ; string picurl = ( string ) picinfo . get ( "isrc" ) ; string msg = ( string ) picinfo . get ( "msg" ) ; picurl = picurl . replace ( ".thumb.200_0." , "." ) ; system . out . println ( "\u7b2c" + j + "\u5f20\uff1a" + msg ) ; system . out . println ( picurl ) ; } }
tr	10	public static void main ( string [ ] args ) { scanner in = new scanner ( system . in ) ; int cases = integer . valueof ( in . nextline ( ) ) ; while ( cases -- > 0 ) { string [ ] [ ] input = new string [ 3 ] [ 3 ] ; input [ 0 ] = in . nextline ( ) . split ( " " ) ; input [ 1 ] = in . nextline ( ) . split ( " " ) ; input [ 2 ] = in . nextline ( ) . split ( " " ) ; integer [ ] coins = new integer [ 12 ] ; int [ ] times = new int [ 12 ] ; int noteventimes = 0 ; for ( int i = 0 ; i < 3 ; i ++ ) { string balance = input [ i ] [ 2 ] ; if ( balance . equals ( "even" ) ) { for ( char coin : input [ i ] [ 0 ] . tochararray ( ) ) { coins [ coin - 'a' ] = 0 ; } for ( char coin : input [ i ] [ 1 ] . tochararray ( ) ) { coins [ coin - 'a' ] = 0 ; } } else if ( balance . equals ( "up" ) ) { noteventimes ++ ; for ( char coin : input [ i ] [ 0 ] . tochararray ( ) ) { if ( coins [ coin - 'a' ] == null ) { coins [ coin - 'a' ] = 1 ; times [ coin - 'a' ] ++ ; } else if ( coins [ coin - 'a' ] < 0 ) { coins [ coin - 'a' ] = 0 ; } else if ( coins [ coin - 'a' ] > 0 ) { times [ coin - 'a' ] ++ ; } } for ( char coin : input [ i ] [ 1 ] . tochararray ( ) ) { if ( coins [ coin - 'a' ] == null ) { coins [ coin - 'a' ] = - 1 ; times [ coin - 'a' ] ++ ; } else if ( coins [ coin - 'a' ] > 0 ) { coins [ coin - 'a' ] = 0 ; } else if ( coins [ coin - 'a' ] < 0 ) { times [ coin - 'a' ] ++ ; } } } else if ( balance . equals ( "down" ) ) { noteventimes ++ ; for ( char coin : input [ i ] [ 0 ] . tochararray ( ) ) { if ( coins [ coin - 'a' ] == null ) { coins [ coin - 'a' ] = - 1 ; times [ coin - 'a' ] ++ ; } else if ( coins [ coin - 'a' ] > 0 ) { coins [ coin - 'a' ] = 0 ; } else if ( coins [ coin - 'a' ] < 0 ) { times [ coin - 'a' ] ++ ; } } for ( char coin : input [ i ] [ 1 ] . tochararray ( ) ) { if ( coins [ coin - 'a' ] == null ) { coins [ coin - 'a' ] = 1 ; times [ coin - 'a' ] ++ ; } else if ( coins [ coin - 'a' ] < 0 ) { coins [ coin - 'a' ] = 0 ; } else if ( coins [ coin - 'a' ] > 0 ) { times [ coin - 'a' ] ++ ; } } } } for ( int i = 0 ; i < 12 ; i ++ ) { if ( coins [ i ] != null && coins [ i ] != 0 ) { if ( coins [ i ] > 0 && times [ i ] == noteventimes ) { char counterfeit = ( char ) ( 'a' + i ) ; system . out . println ( counterfeit + " is the counterfeit coin and it is heavy." ) ; } else if ( coins [ i ] < 0 && times [ i ] == noteventimes ) { char counterfeit = ( char ) ( 'a' + i ) ; system . out . println ( counterfeit + " is the counterfeit coin and it is light." ) ; } } } } }
tr	8	@ suppresswarnings ( "unchecked" ) @ override public weather getweatherdata ( int zip ) throws weatherserviceexception { httpclient httpclient = new defaulthttpclient ( ) ; try { httpget httpget = new httpget ( new uri ( format ( urlformat , apikey , zip ) ) ) ; httpresponse response = httpclient . execute ( httpget ) ; map < string , object > respdata = new gson ( ) . fromjson ( entityutils . tostring ( response . getentity ( ) ) , hashmap . class ) ; if ( ( ( map ) respdata . get ( "response" ) ) . containskey ( error_key ) ) { if ( "querynotfound" . equalsignorecase ( get ( respdata , "response" , error_key , "type" ) . tostring ( ) ) ) { throw new weatherserviceexception ( zip_not_found ) ; } else throw new weatherserviceexception ( "generic exception: " + respdata . get ( error_key ) . tostring ( ) ) ; } int returnedzip = parseint ( get ( respdata , current_observation , display_location , "zip" ) . tostring ( ) ) ; string city = get ( respdata , current_observation , display_location , "city" ) ; string state = get ( respdata , current_observation , display_location , "state_name" ) ; double tempf = get ( respdata , current_observation , "temp_f" ) ; return new weather ( returnedzip , city , state , tempf ) ; } catch ( exception e ) { throw new weatherserviceexception ( e . getmessage ( ) , e ) ; } }
tr	3	private list < student > getpageofstudents ( ) { final list < student > pagestudents = new vector < student > ( ) ; if ( students . size ( ) == 0 || currpage < 0 || currpage >= getmaxpage ( ) ) { return pagestudents ; } int size = 0 ; if ( students . size ( ) - viewsize * currpage < viewsize ) { size = students . size ( ) - viewsize * currpage ; } else { size = viewsize ; } if ( size == 0 ) { return pagestudents ; } for ( int i = 0 ; i < size ; ++ i ) { pagestudents . add ( students . get ( i + viewsize * currpage ) ) ; } return pagestudents ; }
tr	8	public static void testaddfils ( ) { pere pere = new pere ( "diop" , "flingoooo" ) ; femme femme = new femme ( "sow" , "prenomfemme" ) ; femme femme2 = new femme ( "balde" , "prenomfemme8" ) ; femme femme3 = new femme ( "diallo" , "prenomfemme3" ) ; pere . addfemme ( femme ) ; pere . addfemme ( femme2 ) ; pere . addfemme ( femme3 ) ; fils f = new fils ( "nomfils" , "prenomfils" ) ; fille fille = new fille ( "nomfille" , "prenomfille" ) ; methodesutiles . addfils ( pere , f ) ; methodesutiles . addfille ( pere , fille ) ; list < personne > maliste = new arraylist < personne > ( ) ; maliste = pere . getenfants ( ) ; system . out . println ( " vous etes " + pere . getprenom ( ) + " " + pere . getnom ( ) . touppercase ( ) ) ; system . out . println ( " vous avez en ce moment: " + pere . getfemmes ( ) . size ( ) + " femmes" ) ; if ( maliste . isempty ( ) == false ) { system . out . println ( " vous avez en ce moment: " + maliste . size ( ) + " enfants qui sont: " ) ; for ( int i = 1 ; i <= maliste . size ( ) ; i ++ ) { system . out . println ( "           nom " + maliste . get ( i ) . getnom ( ) + " prenom " + maliste . get ( i ) . getprenom ( ) ) ; } } else { system . out . println ( " vous n'avez aucun enfant!!! " ) ; } }
tr	6	private parameter decodeparam ( object obj ) throws jsonexception { parameter param = null ; final string paramname = "" ; if ( obj instanceof jsonobject ) { jsonobject jsonparam = ( jsonobject ) obj ; groupedparameter groupedparam = new groupedparameter ( "" ) ; groupedparam . setvalues ( decodeparams ( jsonparam ) ) ; param = groupedparam ; } else if ( obj instanceof jsonarray ) { jsonarray params = ( jsonarray ) obj ; param = decodeparams ( params ) ; } else { if ( obj instanceof string ) { string value = ( string ) obj ; param = new singleparameter ( "" , value ) ; } else if ( obj instanceof integer ) { integer value = ( integer ) obj ; param = new singleparameter ( "" , value ) ; } else if ( obj instanceof long ) { long value = ( long ) obj ; param = new singleparameter ( "" , value ) ; } else if ( obj instanceof boolean ) { boolean value = ( boolean ) obj ; param = new singleparameter ( "" , value ) ; } } if ( param != null ) { param . setname ( paramname ) ; } return param ; }
tr	10	@ override public void init ( gamecontainer container ) throws slickexception { this . container = container ; container . settargetframerate ( 60 ) ; int size = 5 ; int speed = 3 ; int rotation = 20 ; float range = 40 ; ship = new ship ( size , speed , rotation , range , this ) ; list < obj > shiplist = new list < obj > ( ) ; shiplist . add ( ship ) ; bulletlist = new list < obj > ( ) ; astlist = new list < obj > ( ) ; for ( int i = 0 ; i < 2 ; i ++ ) { float [ ] loc = new float [ 2 ] ; loc [ 0 ] = ( float ) ( math . random ( ) * container . getwidth ( ) ) ; loc [ 1 ] = ( float ) ( math . random ( ) * container . getheight ( ) ) ; list < obj > pointer = astlist ; while ( pointer . next != null ) { pointer = pointer . next ; } list < obj > wrapper = new list < obj > ( ) ; asteroid ast = new asteroid ( loc , ( float ) ( math . random ( ) * 10 + 4 ) , wrapper , this ) ; wrapper . data = ast ; wrapper . previous = pointer ; pointer . next = wrapper ; } gamelist = new list < list < obj > > ( ) ; gamelist . add ( bulletlist ) ; gamelist . add ( astlist ) ; gamelist . add ( shiplist ) ; }
tr	4	public void print ( string s ) { this . type = s ; printerjob job = printerjob . getprinterjob ( ) ; pageformat pf = new pageformat ( ) ; paper paper = new paper ( ) ; paper . setimageablearea ( 0 , 0 , 200 , 1000 ) ; pf . setpaper ( paper ) ; book book = new book ( ) ; book . append ( this , pf ) ; job . setpageable ( book ) ; try { job . print ( ) ; } catch ( exception ex ) { new clubexception ( "error printing" , ex . tostring ( ) ) ; } }
tr	2	public stringbuilder dohvatisadrzaj ( url url ) { bufferedreader in ; try { in = new bufferedreader ( new inputstreamreader ( url . openstream ( ) ) ) ; string inputline ; sadrzaj = new stringbuilder ( ) ; while ( ( inputline = in . readline ( ) ) != null ) { sadrzaj . append ( inputline ) ; sadrzaj . append ( "\\n" ) ; } } catch ( ioexception ex ) { logger . getlogger ( dretva . class . getname ( ) ) . log ( level . severe , null , ex ) ; } return sadrzaj ; }
tr	8	public arraylist < integer > graycode ( int n ) { arraylist < integer > res = new arraylist < integer > ( ) ; arraylist < string > tempres = new arraylist < string > ( ) ; if ( n == 0 ) { res . add ( 0 ) ; return res ; } for ( int i = 1 ; i <= n ; i ++ ) { int size = tempres . size ( ) ; if ( size == 0 ) { tempres . add ( "0" ) ; tempres . add ( "1" ) ; } else { boolean bzero = true ; for ( int j = 0 ; j < size ; j ++ ) { string curr = tempres . get ( 0 ) ; tempres . remove ( 0 ) ; if ( bzero ) { tempres . add ( curr + "0" ) ; tempres . add ( curr + "1" ) ; bzero = false ; } else { tempres . add ( curr + "1" ) ; tempres . add ( curr + "0" ) ; bzero = true ; } } } } for ( string s : tempres ) { res . add ( integer . parseint ( s , 2 ) ) ; } return res ; }
tr	6	public static void main ( string [ ] args ) throws exception { string origen = args [ 0 ] ; string destino = args [ 1 ] ; reader reader = new filereader ( origen ) ; writer writer = new filewriter ( destino ) ; bufferedreader br = new bufferedreader ( reader ) ; string s = null ; while ( ( s = br . readline ( ) ) != null ) { s = s . replaceall ( "arriba" , "abajo" ) ; writer . write ( s + "\\n" ) ; } br . close ( ) ; writer . close ( ) ; }
tr	4	public void hacersaque ( main m ) { int x = 0 ; int y = 0 ; if ( this . equipo == 1 ) { x = 2 ; y = 17 ; } else { x = 30 ; y = 5 ; } m . log [ this . posx ] [ this . posy ] = 0 ; m . log [ x ] [ y ] = this . equipo ; imageicon piso = new imageicon ( "piso.gif" ) ; m . lbl [ this . posx ] [ this . posy ] . seticon ( piso ) ; imageicon icon ; if ( this . equipo == 1 ) { icon = new imageicon ( "jugador1.png" ) ; } else { icon = new imageicon ( "jugador2.png" ) ; } m . lbl [ x ] [ y ] . seticon ( icon ) ; }
tr	5	public static void main ( final string [ ] args ) { final string progname = "normalise" ; final normalisecli cli = new normalisecli ( ) ; final jcommander jc = new jcommander ( cli ) ; jc . setprogramname ( progname ) ; try { jc . parse ( args ) ; } catch ( parameterexception e ) { system . out . println ( progname + ": " + e . getmessage ( ) ) ; system . out . println ( ) ; jc . usage ( ) ; system . exit ( 1 ) ; } if ( cli . ishelp ( ) ) { jc . usage ( ) ; return ; } list < string > files = cli . getparameters ( ) ; if ( files . size ( ) != 1 ) { jc . usage ( ) ; system . exit ( 1 ) ; } normalise norm = new normalise ( new file ( files . get ( 0 ) ) , cli ) ; norm . run ( ) ; }
tr	4	public string updatedata ( database db , string key , string value ) { try { databaseentry keyentry = new databaseentry ( key . getbytes ( "utf-8" ) ) ; databaseentry valentry = new databaseentry ( value . getbytes ( "utf-8" ) ) ; operationstatus status = db . put ( null , keyentry , valentry ) ; databaseentry valueget = new databaseentry ( ) ; status = db . get ( null , keyentry , valueget , lockmode . default ) ; if ( status == operationstatus . success ) { return new string ( valueget . getdata ( ) , "utf-8" ) ; } else { throw new runtimeexception ( "update '" + value + "' in '" + key + "' " + status ) ; } } catch ( unsupportedencodingexception e ) { throw new runtimeexception ( e ) ; } }
tr	8	public double distanceto ( record o ) { double d2r = ( math . pi / 180 ) ; double distance = 0 ; double longie = o . longitude ; double latie = o . latitude ; try { double dlong = ( longie - longitude ) * d2r ; double dlati = ( latie - latitude ) * d2r ; double a = math . pow ( math . sin ( dlati / 2.0 ) , 2 ) + math . cos ( latitude * d2r ) * math . cos ( latie * d2r ) * math . pow ( math . sin ( dlong / 2.0 ) , 2 ) ; double c = 2 * math . atan2 ( math . sqrt ( a ) , math . sqrt ( 1 - a ) ) ; distance = 6367 * c ; } catch ( exception e ) { e . printstacktrace ( ) ; } return distance ; }
tr	10	private jpanel searchpanel ( ) { jpanel panel = new jpanel ( ) ; int column_width = 15 ; jpanel userpanel = new jpanel ( ) ; jlabel userlabel = new jlabel ( "employee id to search: " ) ; jtextfield searchtextfield = new jtextfield ( null , null , column_width ) ; userlabel . setlabelfor ( searchtextfield ) ; userpanel . add ( userlabel ) ; userpanel . add ( searchtextfield ) ; jpanel usersearch = new jpanel ( ) ; jbutton searchuser = new jbutton ( "search" ) ; searchuser . setactioncommand ( "search_user" ) ; searchuser . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent event ) { if ( searchtextfield . gettext ( ) . equals ( "" ) ) { joptionpane . showmessagedialog ( null , "field can't be blank" , "employee search" , joptionpane . plain_message ) ; } else { string message ; string id = searchtextfield . gettext ( ) ; employee emp = db . query ( integer . parseint ( id ) ) ; if ( emp != null ) { message = "i found employee with id : " + id + " " + emp . getfirstname ( ) + " " + emp . getlastname ( ) ; } else { message = "i was not able an employee with id: " + id ; } joptionpane . showmessagedialog ( null , message , "employee search" , joptionpane . plain_message ) ; } } } ) ; usersearch . add ( searchuser ) ; panel . add ( userpanel ) ; panel . add ( searchuser ) ; return panel ; }
tr	6	public static linkedlist < double > relativemutualentropy ( ) { for ( int i = 0 ; i < frequentpair . size ( ) ; i ++ ) { int uaid = frequentpair . get ( i ) [ 0 ] ; int ubid = frequentpair . get ( i ) [ 1 ] ; hashset < string > locs = frequentpair_colocations . get ( i ) ; double entroa = marginalentropy ( uaid , locs ) ; double entrob = marginalentropy ( ubid , locs ) ; system . out . println ( string . format ( "entro a %g<litcomma> b %g" , entroa , entrob ) ) ; relamutualentro . add ( mutualentrocoloc . get ( i ) / ( entroa + entrob ) ) ; } return relamutualentro ; }
tr	4	public boolean download ( file out ) { try { url url = new url ( imageurl . startswith ( "http://" ) ? imageurl : "http://" + imageurl ) ; inputstream is = new bufferedinputstream ( url . openstream ( ) ) ; outputstream os = new bufferedoutputstream ( new fileoutputstream ( out + "/" + getname ( ) ) ) ; for ( int i ; ( i = is . read ( ) ) != - 1 ; ) os . write ( i ) ; is . close ( ) ; os . close ( ) ; return true ; } catch ( exception e ) { e . printstacktrace ( ) ; } return false ; }
tr	7	public boolean islive ( ) throws ioexception , mimetypeparseexception { string response = httprequest . performrequest ( this . twitch_api_stream_base_url + this . twitch_username , this . mime_type ) ; jsonparser parser = new jsonparser ( ) ; jsonobject streamjson = ( jsonobject ) parser . parse ( response ) ; boolean islive = streamjson . get ( this . stream_property ) . isjsonnull ( ) == false ; if ( islive ) { jsonobject channeljson = ( jsonobject ) ( ( jsonobject ) streamjson . get ( this . stream_property ) ) . get ( this . stream_channel_property ) ; this . stream_title_value = channeljson . get ( this . stream_title_property ) . getasstring ( ) ; jsonelement gamejson = channeljson . get ( this . stream_game_property ) ; this . stream_game_value = gamejson . isjsonnull ( ) ? "" : gamejson . getasstring ( ) ; this . stream_viewers_value = ( ( jsonobject ) streamjson . get ( this . stream_property ) ) . get ( this . stream_viewers_property ) . getasstring ( ) ; this . stream_url_value = channeljson . get ( this . stream_url_property ) . getasstring ( ) ; this . twitch_displayname_value = channeljson . get ( this . twitch_displayname_property ) . getasstring ( ) ; jsonobject previewjson = ( ( jsonobject ) streamjson . get ( this . stream_property ) ) . get ( this . stream_preview_property ) . getasjsonobject ( ) ; this . stream_preview_small_value = previewjson . get ( this . stream_preview_small_property ) . getasstring ( ) ; this . stream_preview_medium_value = previewjson . get ( this . stream_preview_medium_property ) . getasstring ( ) ; this . stream_preview_large_value = previewjson . get ( this . stream_preview_large_property ) . getasstring ( ) ; } else { this . stream_title_value = "" ; this . stream_game_value = "" ; this . stream_viewers_value = "" ; this . stream_url_value = "" ; this . twitch_displayname_value = this . twitch_username ; this . stream_preview_small_value = "" ; this . stream_preview_medium_value = "" ; this . stream_preview_large_value = "" ; } return islive ; }
tr	6	public static void main ( string [ ] args ) { final string arg = "e:\\\\me\\\\programming\\\\hackbulgaria\\\\java\\\\gitother copy\\\\core-java-1\\\\8-workingwithlibraries\\\\a.jpg" ; final file file = new file ( arg ) ; bufferedimage img = null ; try { img = imageio . read ( file ) ; } catch ( final exception e ) { e . fillinstacktrace ( ) ; } for ( int y = 0 ; y < img . getheight ( ) ; y ++ ) { for ( int x = 0 ; x < img . getwidth ( ) ; x ++ ) { final int pixel = grey ( img . getrgb ( x , y ) ) ; print ( pixel ) ; } system . out . println ( ) ; } }
tr	2	public static void writesinglefile ( integer docid , string url , string path , string parenturl , string title , string h1 , string h2 , string h3 , string bold , string strong , string em , string anchortext , string parseddata ) throws ioexception { filewriter fstream = new filewriter ( "combinedwebpages" , true ) ; bufferedwriter out = new bufferedwriter ( fstream ) ; out . write ( docid . tostring ( ) + "^" + url + "^" + path + "^" + parenturl + "^" + title + "^" + h1 + "^" + h2 + "^" + h3 + "^" + bold + "^" + strong + "^" + em + "^" + anchortext + "^" + parseddata ) ; out . newline ( ) ; out . close ( ) ; }
tr	9	public static list < categorynode > buildcategorybyurl ( string url ) throws ioexception { system . out . println ( "trying to get url: " + url ) ; document document ; try { document = jsoup . connect ( url ) . get ( ) ; } catch ( ioexception e ) { throw new ioexception ( "error when get " + url , e ) ; } elements elements = document . select ( "ul[data-typeid=n]" ) ; list < categorynode > nodes = new arraylist < categorynode > ( ) ; if ( ! elements . isempty ( ) ) { element ul = elements . first ( ) ; elements lielements = ul . select ( "li" ) ; if ( ! lielements . isempty ( ) ) { iterator < element > iterator = lielements . iterator ( ) ; while ( iterator . hasnext ( ) ) { element li = iterator . next ( ) ; if ( li . select ( "strong" ) . size ( ) > 0 ) { if ( ! iterator . hasnext ( ) ) { nodes . add ( buildcategorychain ( lielements ) ) ; break ; } while ( iterator . hasnext ( ) ) { element childli = iterator . next ( ) ; string link = childli . select ( "a" ) . first ( ) . attr ( "href" ) ; if ( ! link . startswith ( "http" ) ) { link = amazon_home + link ; } nodes . addall ( buildcategorybyurl ( link ) ) ; } } } } } return nodes ; }
tr	7	public void render ( somlattice lattice , int iteration ) { float cellwidth = ( float ) getwidth ( ) / ( float ) lattice . getwidth ( ) ; float cellheight = ( float ) getheight ( ) / ( float ) lattice . getheight ( ) ; int imgw = img . getwidth ( ) ; int imgh = img . getheight ( ) ; graph . setcolor ( color . black ) ; graph . fillrect ( 0 , 0 , imgw , imgh ) ; for ( int x = 0 ; x < lattice . getwidth ( ) ; x ++ ) { for ( int y = 0 ; y < lattice . getheight ( ) ; y ++ ) { somvector vec = lattice . getnode ( x , y ) . getvector ( ) ; if ( closestmode ) graph . setcolor ( closest ( vec , inputvect ) ) ; else graph . setcolor ( new color ( vec . get ( 0 ) , vec . get ( 1 ) , vec . get ( 2 ) ) ) ; graph . fillrect ( ( int ) ( x * cellwidth ) , ( int ) ( y * cellheight ) , ( int ) cellwidth + 1 , ( int ) cellheight + 1 ) ; } } graph . setcolor ( color . red ) ; graph . drawstring ( "iteration: " + string . valueof ( iteration ) , 5 , 15 ) ; this . repaint ( ) ; }
tr	8	public boolean equals ( state state ) { list < integer > goal1 = new arraylist < integer > ( this . goal ) ; list < integer > goal2 = new arraylist < integer > ( state . goal ) ; list < integer > start1 = new arraylist < integer > ( this . start ) ; list < integer > start2 = new arraylist < integer > ( state . start ) ; list < integer > goalitr = new arraylist < integer > ( this . goal ) ; list < integer > startitr = new arraylist < integer > ( this . start ) ; if ( this . atstart == state . atstart ) { for ( integer i : goalitr ) { goal2 . remove ( i ) ; goal1 . remove ( i ) ; } if ( goal1 . isempty ( ) && goal2 . isempty ( ) ) { for ( integer k : startitr ) { start2 . remove ( k ) ; start1 . remove ( k ) ; } if ( start1 . isempty ( ) && start2 . isempty ( ) ) { return true ; } } } return false ; }
tr	1	@ override public boolean izbaci ( arraylist list , string nazivspremista ) { if ( list . isempty ( ) ) { system . out . println ( "datoteka prevelika za spremiste" ) ; return true ; } else { najstariji = new date ( ) ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { r = ( resource ) list . get ( i ) ; d = r . getvrijemespremanja ( ) ; if ( d . compareto ( najstariji ) < 0 && r . isspremljen ( ) ) { najstariji = d ; najr = r ; } } obrisi ( najr , nazivspremista ) ; return false ; } }
tr	10	public static void main ( string [ ] args ) { scanner in = new scanner ( system . in ) ; int k = in . nextint ( ) ; while ( k != 0 ) { int count = k ; int [ ] keys = new int [ count ] ; for ( int i = 0 ; i < count ; i ++ ) { keys [ i ] = in . nextint ( ) - 1 ; } int [ ] looplength = new int [ count ] ; for ( int i = 0 ; i < count ; i ++ ) { looplength [ i ] = 0 ; int position = i ; do { position = keys [ position ] ; looplength [ i ] ++ ; } while ( position != i ) ; } k = in . nextint ( ) ; while ( k != 0 ) { in . skip ( " " ) ; string msg = in . nextline ( ) ; char [ ] encrypted = new char [ count ] ; for ( int i = 0 ; i < count ; i ++ ) { int loopcount = k % looplength [ i ] ; int position = i ; while ( loopcount -- > 0 ) { position = keys [ position ] ; } if ( i < msg . length ( ) ) { encrypted [ position ] = msg . charat ( i ) ; } else { encrypted [ position ] = ' ' ; } } for ( int i = 0 ; i < encrypted . length ; i ++ ) { if ( encrypted [ i ] == 0 ) { encrypted [ i ] = ' ' ; } } system . out . println ( encrypted ) ; k = in . nextint ( ) ; } system . out . println ( ) ; k = in . nextint ( ) ; } }
tr	8	@ override public void requestfile ( string url ) { try { long inittime = system . currenttimemillis ( ) ; contentname contentname = contentname . fromuri ( url ) ; ccnhandle handle = ccnhandle . open ( ) ; ccninputstream input ; if ( commonparameters . unversioned ) { input = new ccninputstream ( contentname , handle ) ; } else { input = new ccnfileinputstream ( contentname , handle ) ; } if ( commonparameters . timeout != null ) { input . settimeout ( commonparameters . timeout ) ; } byte [ ] buffer = new byte [ 1024 ] ; int readcount = 0 ; long readtotal = 0 ; while ( ( readcount = input . read ( buffer ) ) != - 1 ) { readtotal += readcount ; } input . close ( ) ; handle . close ( ) ; keymanager . closedefaultkeymanager ( ) ; long time = system . currenttimemillis ( ) - inittime ; logger . info ( "tempo da requisi\xe7\xe3o: " + time ) ; logger . info ( "tamanho da requisi\xe7\xe3o: " + readtotal ) ; } catch ( exception e ) { logger . error ( "erro: " + e . getmessage ( ) ) ; } }
tr	1	public int [ ] getadmissions ( ) throws sqlexception { int [ ] adm = new int [ 8 ] ; adm [ 0 ] = this . getamountz ( "$5" ) ; adm [ 1 ] = this . getamountz ( "$10" ) ; adm [ 2 ] = this . getamountz ( "$20" ) ; adm [ 3 ] = this . getamountz ( "g-tix" ) ; adm [ 4 ] = this . getamountz ( "mgr comp" ) ; adm [ 5 ] = this . getamountz ( "comp pass" ) ; adm [ 6 ] = this . getamountz ( "comp" ) ; adm [ 7 ] = this . getamountz ( "hotel" ) ; return adm ; }
tr	10	public list < patamar > getdadospatamar ( int anoinicial , string mesinicial , int anofinal , string mesfinal ) { list < patamar > listpatamar = new arraylist < patamar > ( ) ; for ( int index = 0 ; index < filedat . getcontent ( ) . size ( ) ; index ++ ) { string search = filedat . getcontent ( ) . get ( index ) . trim ( ) ; if ( search . startswith ( integer . tostring ( anoinicial ) ) ) { for ( int ano = anoinicial ; ano <= anofinal ; ano ++ ) { search = filedat . getcontent ( ) . get ( index ) . trim ( ) ; patamar patamar = new patamar ( ) ; patamar . setano ( ano ) ; for ( int aux = index ; aux < index + 3 ; aux ++ ) { search = filedat . getcontent ( ) . get ( aux ) . trim ( ) ; if ( search . startswith ( integer . tostring ( ano ) ) ) { search = search . substring ( 4 , search . length ( ) ) . trim ( ) ; } patamar . getlistanumero ( ) . add ( search ) ; search = "" ; } listpatamar . add ( patamar ) ; index = index + 3 ; } break ; } search = "" ; } for ( int indicepatamar = 0 ; indicepatamar < listpatamar . size ( ) ; indicepatamar ++ ) { list < string [ ] > valores = new arraylist < string [ ] > ( ) ; for ( int indicestringpatamar = 0 ; indicestringpatamar < 3 ; indicestringpatamar ++ ) { string [ ] teste = getlinearrayclean ( listpatamar . get ( indicepatamar ) . getlistanumero ( ) . get ( indicestringpatamar ) ) ; valores . add ( teste ) ; } listpatamar . get ( indicepatamar ) . setvalormeses ( valores ) ; } calculacmofooter ( listpatamar , integer . parseint ( mesinicial ) , integer . parseint ( mesfinal ) , anoinicial , anofinal ) ; return listpatamar ; }
tr	4	protected string urlstring ( ) { stringbuilder bldr = new stringbuilder ( 128 ) ; bldr . append ( baseurl ) ; if ( feature != null ) { bldr . append ( "&feature=" ) ; bldr . append ( feature ) ; } if ( username != null ) { bldr . append ( "&username=" ) ; bldr . append ( username ) ; } if ( user_id != null ) { bldr . append ( "&user_id=" ) ; bldr . append ( user_id ) ; } if ( onlycategory != null ) { string catname = null ; try { catname = urlencoder . encode ( onlycategory . getcategoryname ( ) , "utf-8" ) ; bldr . append ( "&only=" ) ; bldr . append ( catname ) ; } catch ( unsupportedencodingexception e ) { log . warn ( "error encoding url" , e ) ; } } if ( excludecategory != null ) { try { string catname = urlencoder . encode ( excludecategory . getcategoryname ( ) , "utf-8" ) ; bldr . append ( "&exclude=" ) ; bldr . append ( catname ) ; } catch ( unsupportedencodingexception e ) { log . warn ( "error encoding url" , e ) ; } } if ( sortorder != null ) { try { string sortname = urlencoder . encode ( sortorder . name ( ) , "utf-8" ) ; bldr . append ( "&sort=" ) ; bldr . append ( sortname ) ; if ( sortdirection != null ) { string sortdirectionname = urlencoder . encode ( sortdirection , "utf-8" ) ; bldr . append ( "&sort_direction=" ) ; bldr . append ( sortdirectionname ) ; } } catch ( unsupportedencodingexception e ) { log . warn ( "error encoding url" , e ) ; } } if ( imagesize != null ) { bldr . append ( "&image_size=" ) ; bldr . append ( imagesize ) ; } if ( page != null ) { bldr . append ( "&page=" ) ; bldr . append ( page ) ; } if ( rpp != null ) { bldr . append ( "&rpp=" ) ; bldr . append ( rpp ) ; } if ( tags ) { bldr . append ( "&tags=" ) ; bldr . append ( 1 ) ; } if ( store ) { bldr . append ( "&include_store=" ) ; bldr . append ( 1 ) ; } if ( states ) { bldr . append ( "&include_states=" ) ; bldr . append ( 1 ) ; } log . trace ( bldr . tostring ( ) ) ; return bldr . tostring ( ) ; }
tr	1	public void num ( arraydeque < imatoken > x ) { if ( ! x . isempty ( ) ) { imatoken token = x . peek ( ) ; if ( token . type . equals ( "float" ) || token . type . equals ( "int" ) ) { x . pop ( ) ; } else { system . out . println ( "error10: expected an int or a float but found a " + token . type + " on line " + token . line ) ; system . exit ( 0 ) ; } } else { system . out . println ( "error: out of tokens" ) ; } }
tr	7	public void send ( ) { try { inputstream inputstream = new fileinputstream ( wayoffile ) ; byte buf [ ] = new byte [ 2045 ] ; int len = inputstream . read ( buf ) ; frame fr , fr1 , fr2 ; do { fr1 = new frame ( 'h' , nameoffile , size ) ; this . out . write ( fr1 . frtobyte ( fr1 . framesize ( ) - 3 ) , 0 , fr1 . framesize ( ) * 2 ) ; suspend ( ) ; } while ( status == false ) ; int len1 = 0 ; do { fr = new frame ( 'i' , buf ) ; len1 = len1 + len ; f . progressbar . setvalue ( len1 ) ; this . out . write ( fr . frtobyte ( len ) , 0 , ( len + 3 ) * 2 ) ; suspend ( ) ; if ( this . status == true ) { len = inputstream . read ( buf ) ; } } while ( len > 0 ) ; do { fr2 = new frame ( 'h' ) ; this . out . write ( fr2 . specfrtobyte ( ) ) ; suspend ( ) ; } while ( status == false ) ; stop ( ) ; } catch ( ioexception e ) { } f . b1 . setvisible ( true ) ; f . b4 . setenabled ( true ) ; f . b2 . setenabled ( true ) ; }
tr	2	public static void startcalculation ( int n , int numberoftasks , int threadsquantity ) throws interruptedexception { performancetester performancetester = new performancetesterimpl ( ) ; performancetestresult performancetestresult = performancetester . runperformancetest ( createrunnabletask ( n ) , numberoftasks , threadsquantity ) ; system . out . println ( string . format ( "total execution time: %s" , performancetestresult . gettotaltime ( ) ) ) ; system . out . println ( string . format ( "minimum execution time: %s" , performancetestresult . getmintime ( ) ) ) ; system . out . println ( string . format ( "maximum execution time: %s" , performancetestresult . getmaxtime ( ) ) ) ; }
tr	4	public static message getservermessage ( string jsonmessage ) { jsonparser parser = new jsonparser ( ) ; jsonobject obj = parser . parse ( jsonmessage ) . getasjsonobject ( ) ; string type = gson . fromjson ( obj . get ( "type" ) , string . class ) ; if ( type . equals ( "greetings_program" ) ) { return gson . fromjson ( jsonmessage , greetingmessage . class ) ; } else if ( type . equals ( "request" ) ) { return gson . fromjson ( jsonmessage , movemessage . class ) ; } else if ( type . equals ( "result" ) ) { return gson . fromjson ( jsonmessage , resultmessage . class ) ; } else if ( type . equals ( "error" ) ) { return gson . fromjson ( jsonmessage , errormessage . class ) ; } else { errormessage err = new errormessage ( ) ; err . message = "unknown response type [" + type + "] from server" ; return err ; } }
tr	9	public int hashcode ( ) { integer hash = 0 ; int goalsum = 0 ; int goalcount = 0 ; int startsum = 0 ; int startcount = 0 ; int boat = 0 ; for ( integer is : start ) { startcount ++ ; startsum = is + startsum ; } for ( integer ig : goal ) { goalcount ++ ; goalsum = ig + goalsum ; } if ( atstart ) { boat = 1 ; } string prehash = integer . tostring ( 1 ) . concat ( integer . tostring ( goalcount ) ) . concat ( integer . tostring ( goalsum ) ) . concat ( integer . tostring ( 1 ) ) . concat ( integer . tostring ( startcount ) ) . concat ( integer . tostring ( startsum ) ) . concat ( integer . tostring ( 1 ) ) . concat ( integer . tostring ( boat ) ) ; hash = integer . parseint ( prehash ) ; return hash ; }
tr	1	protected string determineresult ( string v1 , string v2 ) { if ( v1 == null ) { return v2 ; } if ( v2 == null ) { return v1 ; } getfloatvalue m = new getfloatvalue ( ) ; if ( ( v1 != null && v1 . trim ( ) . length ( ) > 0 ) && ( ( v2 != null && v2 . trim ( ) . length ( ) > 0 ) ) ) { if ( m . getvalue ( v1 ) > m . getvalue ( v2 ) ) { return v1 ; } return v2 ; } return v2 ; }
tr	1	public void loadfiles ( ) { if ( new file ( "plugins/censornizer/config.yml" ) . exists ( ) ) { main . config = main . getconfig ( ) ; main . config . options ( ) . copydefaults ( true ) ; } else { main . savedefaultconfig ( ) ; main . config = main . getconfig ( ) ; main . config . options ( ) . copydefaults ( true ) ; } if ( ! list . exists ( ) ) { try { list . createnewfile ( ) ; } catch ( ioexception ex ) { logger . getlogger ( censornizer . class . getname ( ) ) . log ( level . severe , null , ex ) ; } } if ( ! banlist . exists ( ) ) { try { banlist . createnewfile ( ) ; } catch ( ioexception ex ) { logger . getlogger ( censornizer . class . getname ( ) ) . log ( level . severe , null , ex ) ; } } if ( ! whitelist . exists ( ) ) { try { whitelist . createnewfile ( ) ; } catch ( ioexception ex ) { logger . getlogger ( censornizer . class . getname ( ) ) . log ( level . severe , null , ex ) ; } } try { scanner s = new scanner ( list ) ; while ( s . hasnextline ( ) ) { main . blacklist . add ( s . nextline ( ) ) ; } s . close ( ) ; } catch ( exception ex ) { system . err . println ( "[censornizer] " + ex + ex . getmessage ( ) ) ; system . out . println ( "" ) ; ex . printstacktrace ( ) ; } finally { system . out . println ( "[" + main . getdescription ( ) . getname ( ) + " by jeterlp" + " version: " + main . getdescription ( ) . getversion ( ) + "] loaded " + main . blacklist . size ( ) + " words to be censored!" ) ; } try { scanner s = new scanner ( whitelist ) ; while ( s . hasnextline ( ) ) { main . white . add ( s . nextline ( ) ) ; } s . close ( ) ; } catch ( exception ex ) { system . err . println ( "[censornizer] " + ex + ex . getmessage ( ) ) ; system . out . println ( "" ) ; ex . printstacktrace ( ) ; } finally { system . out . println ( "[" + main . getdescription ( ) . getname ( ) + " by jeterlp" + " version: " + main . getdescription ( ) . getversion ( ) + "] loaded " + main . white . size ( ) + " words to be not censored!" ) ; } if ( main . getconfig ( ) . getboolean ( "config.usebanlist" , true ) ) { try { scanner s = new scanner ( banlist ) ; while ( s . hasnextline ( ) ) { main . bancommands . add ( s . nextline ( ) ) ; } s . close ( ) ; } catch ( exception ex ) { system . err . println ( "[censornizer] " + ex + ex . getmessage ( ) ) ; system . out . println ( "" ) ; ex . printstacktrace ( ) ; } finally { system . out . println ( "[" + main . getdescription ( ) . getname ( ) + " by jeterlp" + " version: " + main . getdescription ( ) . getversion ( ) + "] loaded " + main . bancommands . size ( ) + " words to ban players!" ) ; } } else { system . out . println ( "[" + main . getdescription ( ) . getname ( ) + " by jeterlp" + " version: " + main . getdescription ( ) . getversion ( ) + "] banlist is disabled!" ) ; } }
tr	2	public string classify ( instance example ) { string childexampleattributevalue = example . attributes . get ( attribute . index ) ; if ( attribute . type . numerical . equals ( attribute . category . gettype ( ) ) ) { for ( dectreenode childnode : children ) { if ( "a" . equals ( childnode . parentattributevalue ) == ( integer . parseint ( childexampleattributevalue ) < midpoint ) ) { if ( childnode instanceof internaldectreenode ) { return ( ( internaldectreenode ) childnode ) . classify ( example ) ; } else { return childnode . label ; } } } } return label ; }
tr	7	@ test public void testdocumentchange ( ) throws exception { undomanagerfactory undomanagerfactory = new undomanagerfactoryimpl ( ) ; changefactory changefactory = new changefactoryimpl ( ) ; document document = new documentimpl ( ) ; undomanager undomanager = undomanagerfactory . createundomanager ( document , 2 ) ; assert . assertfalse ( undomanager . canundo ( ) ) ; assert . assertfalse ( undomanager . canredo ( ) ) ; change change1 = changefactory . createinsertion ( 1 , "test change1" , 0 , 1 ) ; change1 . apply ( document ) ; change change2 = changefactory . createinsertion ( 2 , "test change2" , 1 , 2 ) ; change2 . apply ( document ) ; undomanager . registerchange ( change1 ) ; undomanager . registerchange ( change2 ) ; assert . asserttrue ( undomanager . canundo ( ) ) ; assert . assertfalse ( undomanager . canredo ( ) ) ; system . out . println ( "undoing and redoing starts here----------------------------------------------" ) ; undomanager . undo ( ) ; assert . asserttrue ( undomanager . canredo ( ) ) ; undomanager . undo ( ) ; undomanager . redo ( ) ; undomanager . redo ( ) ; system . out . println ( "registering new change ------------------------------------------------------" ) ; change change3 = changefactory . createinsertion ( 3 , "test change3" , 2 , 3 ) ; change3 . apply ( document ) ; undomanager . registerchange ( change3 ) ; assert . asserttrue ( undomanager . canundo ( ) ) ; assert . asserttrue ( undomanager . canundo ( ) ) ; assert . assertfalse ( undomanager . canredo ( ) ) ; system . out . println ( "undoing and redoing starts here----------------------------------------------" ) ; undomanager . undo ( ) ; assert . asserttrue ( undomanager . canredo ( ) ) ; undomanager . undo ( ) ; undomanager . redo ( ) ; undomanager . redo ( ) ; }
tr	1	public static int recursivebinarysearch ( int [ ] sortedarray , int start , int end , int key ) { if ( start < end ) { int mid = start + ( end - start ) / 2 ; if ( key < sortedarray [ mid ] ) { return recursivebinarysearch ( sortedarray , start , mid , key ) ; } else if ( key > sortedarray [ mid ] ) { return recursivebinarysearch ( sortedarray , mid + 1 , end , key ) ; } else { return mid ; } } return - ( start + 1 ) ; }
tr	2	public string tostring ( ) { string s = "" ; for ( int i = 0 ; i < 6 ; i ++ ) { s = s + ( jatsiyhdistelmat . get ( i ) . name ( ) + ":\t\t" + yhdistelmat . get ( jatsiyhdistelmat . get ( i ) ) ) + "\\n" ; } s = s + "-------------------------------------------------" + "\\n" ; s = s + ( "valisumma: " + valisumma ) + "\\n" ; s = s + ( "bonus: " + bonus ) + "\\n" ; s = s + "-------------------------------------------------" + "\\n" ; for ( int i = 6 ; i < 8 ; i ++ ) { s = s + ( jatsiyhdistelmat . get ( i ) . name ( ) + ":\t\t" + yhdistelmat . get ( jatsiyhdistelmat . get ( i ) ) ) + "\\n" ; } s = s + ( jatsiyhdistelmat . get ( 8 ) . name ( ) + ":\t" + yhdistelmat . get ( jatsiyhdistelmat . get ( 8 ) ) ) + "\\n" ; for ( int i = 9 ; i < 15 ; i ++ ) { s = s + ( jatsiyhdistelmat . get ( i ) . name ( ) + ":\t\t" + yhdistelmat . get ( jatsiyhdistelmat . get ( i ) ) ) + "\\n" ; } s = s + "-------------------------------------------------" + "\\n" ; s = s + ( "summa: " + summa ) + "\\n" ; return s ; }
tr	7	public static void main ( string [ ] args ) { if ( args . length < 2 ) { system . err . println ( "verwendung: <blocksize> <generierungsgr\xf6\xdfe>/<eingabedatei>" ) ; } int blocksize = 0 ; try { blocksize = integer . parseint ( args [ 0 ] ) ; } catch ( numberformatexception e ) { system . err . println ( "blockgr\xf6\xdfe muss eine zahl sein!" ) ; system . exit ( - 1 ) ; } boolean generate = false ; string inputfile = args [ 1 ] ; byte [ ] input = null ; try { input = adstool . readbytearray ( inputfile ) ; } catch ( exception e ) { system . out . println ( "\\ndatei konnte nicht gelesen werden. versuche<litcomma> als generierungsgr\xf6\xdfe zu interpretieren..." ) ; } if ( input == null ) { generate = true ; } if ( generate ) { int gensize = 0 ; try { gensize = integer . parseint ( args [ 1 ] ) ; } catch ( numberformatexception e ) { system . err . println ( "generatorgr\xf6\xdfe muss eine zahl sein!" ) ; system . exit ( - 1 ) ; } input = new byte [ gensize ] ; for ( int i = 0 ; i < input . length ; i ++ ) { input [ i ] = ( byte ) i ; } } hashtree ht = new hashtree ( input , blocksize ) ; system . out . println ( "hashtreedata: " ) ; ht . display ( ) ; }
tr	9	private static string sboxsubstitution ( ) { string [ ] [ ] data = new string [ 9 ] [ 4 ] ; data [ 0 ] [ 0 ] = "6-bit from a" ; data [ 0 ] [ 1 ] = "(b2<litcomma> b3<litcomma> b4<litcomma> b5)" ; data [ 0 ] [ 2 ] = "(column) in base 10" ; data [ 0 ] [ 3 ] = "in base 2" ; string out = "" ; int row , column , bounds = 0 ; string bits = "" ; for ( int i = 0 ; i < desconstants . sbox . size ( ) ; i ++ ) { bits = erxork . substring ( bounds , bounds + 6 ) ; data [ i + 1 ] [ 0 ] = bits ; row = integer . parseint ( "" + bits . charat ( 0 ) + bits . charat ( 5 ) , 2 ) ; column = integer . parseint ( bits . substring ( 1 , 5 ) , 2 ) ; data [ i + 1 ] [ 1 ] = bits . substring ( 1 , 5 ) ; data [ i + 1 ] [ 2 ] = integer . tostring ( desconstants . sbox . get ( i ) [ row ] [ column ] ) ; data [ i + 1 ] [ 3 ] = string . format ( "%4s" , integer . tobinarystring ( desconstants . sbox . get ( i ) [ row ] [ column ] ) ) . replace ( ' ' , '0' ) ; out += string . format ( "%4s" , integer . tobinarystring ( desconstants . sbox . get ( i ) [ row ] [ column ] ) ) . replace ( ' ' , '0' ) ; bounds += 6 ; } spreadsheet ss = new spreadsheet ( data ) ; jframe jf = new jframe ( ) ; jf . add ( ss ) ; jf . setsize ( 800 , 600 ) ; jf . settitle ( "s-box output" ) ; jf . setvisible ( true ) ; return out ; }
tr	10	public jsonnode buildloaderconfig ( collection < modulegroup > groups ) { objectmapper objectmapper = new objectmapper ( ) ; objectnode rootnode = objectmapper . createobjectnode ( ) ; rootnode . put ( filter_key , filter ) ; for ( modulegroup group : groups ) { objectnode groupnode = rootnode . with ( groups_key ) . with ( group . getname ( ) ) ; groupnode . put ( combine_key , combosupported ) ; if ( combosupported ) { groupnode . put ( combo_base_key , loaderbase + group . getbase ( ) + "?" ) ; groupnode . put ( combo_root_key , "" ) ; } else { groupnode . put ( group_base_key , loaderbase + group . getbase ( ) + path_separator ) ; } for ( module module : group . getmodules ( ) ) { objectnode modulenode = groupnode . with ( modules_key ) . with ( module . getname ( ) ) ; arraynode requiresnode = modulenode . putarray ( module_dependencies_key ) ; for ( string dependency : module . getdependencies ( ) ) { requiresnode . add ( dependency ) ; } if ( ! module . getlanguages ( ) . isempty ( ) ) { arraynode langsnode = modulenode . putarray ( module_languages_key ) ; for ( string lang : module . getlanguages ( ) ) { langsnode . add ( lang ) ; } } } } return rootnode ; }
tr	1	@ override public boolean shouldvisit ( weburl url ) { string href = url . geturl ( ) . tolowercase ( ) ; return ( ! filters . matcher ( href ) . matches ( ) && href . contains ( ".ics.uci.edu" ) ) && ! href . startswith ( "https" ) && ! href . contains ( "calendar.ics.uci.edu" ) && ! href . contains ( "http://archive.ics.uci.edu" ) && ! href . contains ( "ftp.ics.uci.edu" ) && ( ! href . contains ( "http://djp3-pc2.ics.uci.edu/lucicoderepository" ) || ! href . startswith ( "http://djp3-pc2.ics.uci.edu/lucicoderepository" ) ) && ! href . contains ( "rss.ics.uci.edu" ) && ! href . contains ( "feed=rss" ) && ! href . contains ( ".css?" ) && ! href . contains ( "http://testlab.ics.uci.edu/" ) && ! href . contains ( "http://phoenix.ics.uci.edu" ) && ! href . contains ( "networkdata.ics.uci.edu" ) && ! href . contains ( "ics.uci.edu/~lopes/datasets" ) && ! href . contains ( "http://mlearn.ics.uci.edu/mlrepository.html" ) && ! href . contains ( "sourcerer.ics.uci.edu/" ) && ! href . contains ( "http://www.ics.uci.edu/~eppstein/pix/" ) && ! href . contains ( "http://www.ics.uci.edu/~xhx/project" ) ; }
tr	9	public void run ( runnable runnable ) throws exception { stats startstats ; long starttime ; long endtime ; stats endstats ; warmup ( runnable , warm_ups ) ; jvmclean ( ) ; long [ ] timings = new long [ iterations ] ; int skips = 0 ; for ( int i = 0 ; i < iterations + dry_runs ; i ++ ) { startstats = stats ( ) ; starttime = timens ( ) ; runnable . run ( ) ; endtime = timens ( ) ; endstats = stats ( ) ; if ( i < dry_runs ) { continue ; } if ( startstats . equals ( endstats ) ) { timings [ i - dry_runs ] = endtime - starttime ; } else { system . out . println ( startstats ) ; system . out . println ( "---------" ) ; system . out . println ( endstats ) ; skips ++ ; i -- ; } } long total = 0 ; for ( long timing : timings ) { total += timing ; } system . out . println ( arrays . tostring ( timings ) ) ; system . out . println ( "skipped : " + skips ) ; system . out . println ( "average value : " + total / iterations ) ; }
tr	8	@ suppresswarnings ( "unchecked" ) private void buildrelationships ( ) { int packageindex = 0 ; for ( final sortedset < classnode > pkg : hierachy . classesbypackagesorted . values ( ) ) { int classindex = 0 ; for ( final classnode cls : pkg ) { final classnode parent = hierachy . classestoparent . get ( cls ) ; classidentifier id = new classidentifier ( packageindex , classindex ) ; classidentifier parentid = hierachy . findbynode ( parent ) ; newrelationship ( id , parentid , extends ) ; list < string > interfaces = new arraylist < > ( cls . interfaces ) ; newrelationships ( interfaces , id , implements ) ; analysemethods ( id , cls . methods ) ; classindex ++ ; } packageindex ++ ; } }
tr	7	@ override protected int sethvalue ( ) { int dimension = state . getsize ( ) ; int [ ] [ ] board = ( ( fifteenstate ) state ) . getboard ( ) ; int [ ] kdist = ( ( fifteenstate ) state ) . getkdist ( ) ; hvalue = 0 ; for ( int i = 0 ; i < dimension ; i ++ ) { for ( int j = 0 ; j < dimension ; j ++ ) { if ( board [ i ] [ j ] != 0 ) { int x = board [ i ] [ j ] - 1 , y = 4 * i + j ; hvalue += kdist [ 16 * x + y ] ; } } } return hvalue ; }
tr	8	@ override public void run ( ) { randomaccessfile file = null ; inputstream inputstream = null ; try { url url = new url ( fileurl ) ; httpurlconnection connection = ( httpurlconnection ) url . openconnection ( ) ; connection . setrequestproperty ( range_property , string . format ( "bytes=%d-" , downloadbytescounter ) ) ; connection . connect ( ) ; int responsecode = connection . getresponsecode ( ) ; if ( responsecode / 100 != 2 || ( contentsize = connection . getcontentlength ( ) ) < 1 ) { throw new downloadmanagerexception ( string . format ( "invalid remote resource initialization!." + "response code: %d<litcomma> content size: %d" , responsecode , contentsize ) ) ; } downloadstatus = downloadmanager . downloadstatus . downloading ; file = new randomaccessfile ( downloadmanagerutils . getfilenamefromurl ( url ) , access_mode ) ; file . seek ( downloadbytescounter ) ; inputstream = connection . getinputstream ( ) ; while ( downloadstatus == downloadmanager . downloadstatus . downloading ) { byte buffer [ ] ; int sizeleft ; if ( ( sizeleft = contentsize - downloadbytescounter ) > max_buffer_size ) { buffer = new byte [ max_buffer_size ] ; } else { buffer = new byte [ sizeleft ] ; } int read = inputstream . read ( buffer ) ; if ( read == - 1 ) { break ; } downloadbytescounter += read ; file . write ( buffer , 0 , read ) ; } downloadstatus = downloadmanager . downloadstatus . downloaded ; } catch ( malformedurlexception e ) { throw new downloadmanagerexception ( "invalid file url! can not creates uri instance." ) ; } catch ( ioexception e ) { throw new downloadmanagerexception ( "exception during file downloading!" , e ) ; } finally { if ( file != null ) { try { file . close ( ) ; } catch ( ioexception e ) { } } if ( inputstream != null ) { try { inputstream . close ( ) ; } catch ( ioexception e ) { } } } }
tr	8	public string getactualrangebasedoninputcost ( string response , double cost ) { string actualrange = null ; try { jsonobject jobject = ( jsonobject ) jparser . parse ( response ) ; jsonarray pricefacetarray = ( jsonarray ) jobject . get ( "facets" ) ; jsonarray facetvaluesarray = null ; for ( object pricefacet : pricefacetarray ) { jsonobject priceobject = ( jsonobject ) pricefacet ; facetvaluesarray = ( jsonarray ) priceobject . get ( "values" ) ; } if ( cost <= 50.0 ) { actualrange = "$50.00 and under" ; } else if ( cost > 50.0 && cost <= 100.0 ) { actualrange = "$100.00 and under" ; } else if ( cost > 100.0 && cost <= 200.0 ) { actualrange = "$200.00 and under" ; } else if ( cost >= 200.0 ) { actualrange = "$200.00 and over" ; } for ( object v : facetvaluesarray ) { jsonobject value_obj = ( jsonobject ) v ; if ( value_obj . get ( "name" ) . tostring ( ) . equals ( actualrange ) ) { numofitemsinrange = integer . parseint ( value_obj . get ( "count" ) . tostring ( ) ) ; } } } catch ( exception e ) { system . out . println ( "error in getting actual range based on cost" + e ) ; actualrange = problem ; } return actualrange ; }
tr	1	public static int geturitype ( string uri ) { matcher m ; m = constants . regexset . pattern_absolute_ws . matcher ( uri ) ; if ( m . matches ( ) ) { system . out . println ( "match the absolute ws model" ) ; return constants . uritypescons . uri_type_absolute_ws ; } m = constants . regexset . pattern_absolute_ns . matcher ( uri ) ; if ( m . matches ( ) ) { system . out . println ( "match the absolute ns model" ) ; return constants . uritypescons . uri_type_absolute_ns ; } m = constants . regexset . pattern_relative . matcher ( uri ) ; if ( m . matches ( ) ) { system . out . println ( "match the relative model" ) ; system . out . println ( "relative module " + uri ) ; ; return constants . uritypescons . uri_type_relative ; } return constants . uritypescons . uri_type_wrong ; }
tr	2	public static ontmodel createontmodel ( url url , map < string , string > contentitems , dataset dataset ) { rdfbuilder . contentitems = contentitems ; ontmodel = dataset == null ? modelfactory . createontologymodel ( ontmodelspec . owl_dl_mem ) : modelfactory . createontologymodel ( ontmodelspec . owl_dl_mem , dataset . getdefaultmodel ( ) ) ; ontmodel . addsubmodel ( modelfactory . createontologymodel ( ontmodelspec . owl_dl_mem ) . read ( "http://erlangen-crm.org/onto/ecrm/ecrm_current.owl" ) ) ; individual image = createinformationcarrier ( url ) ; individual endurant = createendurant ( image ) ; createspatials ( endurant ) ; createtemporals ( endurant ) ; return ontmodel ; }
tr	3	@ suppresswarnings ( "rawtypes" ) public void generar ( ) { system . out . println ( isgenerarvos + "-" + isgenerartostringvos + "-" + ishelpervobetweenentity ) ; contenidohelpervoentity . append ( nl + "public class " + nombreclasehelpervoentity + "{\\n" + nl ) ; try { class [ ] lasclases = obtenerclasesdelpaquete ( paqueteentidades ) ; logger . info ( lasclases . length + " clases encontradas<litcomma> en " + paqueteentidades ) ; for ( int i = 0 ; i < lasclases . length ; i ++ ) { class clase = lasclases [ i ] ; importsclasehelpervoentity . append ( "import " + clase . getname ( ) + ";" + nl ) ; construirvo ( clase ) ; } contenidohelpervoentity . append ( nl + "}" ) ; if ( ishelpervobetweenentity ) { grabararchivodehelper ( paquetecodigogenerado , contenidohelpervoentity , getpatharchivosgenerados ( ) ) ; } } catch ( classnotfoundexception e ) { e . printstacktrace ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } }
tr	5	public void grabararchivodeclasejava ( string paquetecodigogenerado , string path ) { setpaquetecontenedor ( paquetecodigogenerado ) ; paquetecodigogenerado = paquetecodigogenerado . replace ( "." , "\\\\" ) ; string filename = path + file . separatorchar + paquetecodigogenerado + file . separatorchar + nombrevo + ".java" ; string content = generarcontenidoclase ( ) ; try { filewriter fw = new filewriter ( filename ) ; bufferedwriter bw = new bufferedwriter ( fw ) ; printwriter salida = new printwriter ( bw ) ; salida . println ( content ) ; salida . close ( ) ; } catch ( ioexception e ) { system . out . println ( "error al escribir el archivo" ) ; e . printstacktrace ( ) ; } }
tr	10	public document createdocument ( final list < student > students ) { document doc = null ; try { final documentbuilderfactory dbf = documentbuilderfactory . newinstance ( ) ; dbf . setvalidating ( true ) ; final documentbuilder db = dbf . newdocumentbuilder ( ) ; doc = db . newdocument ( ) ; final element root = doc . createelement ( model . field_students ) ; for ( final student student : students ) { final element studentelement = doc . createelement ( model . field_student ) ; root . appendchild ( studentelement ) ; newelement ( doc , model . field_name , studentelement , student . getname ( ) ) ; newelement ( doc , model . field_group , studentelement , student . getgroup ( ) . tostring ( ) ) ; final list < exam > exams = student . getexams ( ) ; final element examselement = doc . createelement ( model . field_exams ) ; studentelement . appendchild ( examselement ) ; for ( final exam exam : exams ) { if ( ! exam . isempty ( ) ) { final element examelement = doc . createelement ( model . field_exam ) ; examselement . appendchild ( examelement ) ; newelement ( doc , model . field_name , examelement , exam . getname ( ) != null ? exam . getname ( ) : " " ) ; newelement ( doc , model . field_mark , examelement , exam . getmark ( ) != null ? exam . getmark ( ) . tostring ( ) : " " ) ; } } } doc . appendchild ( root ) ; } catch ( final exception e ) { xmlwriter . log . log ( level . severe , model . problem_parsing_the_file + e . getmessage ( ) , e ) ; } return doc ; }
tr	1	public compactbytearray ( byte defaultvalue ) { int i ; values = new byte [ unicodecount ] ; indices = new char [ indexcount ] ; hashes = new int [ indexcount ] ; for ( i = 0 ; i < unicodecount ; ++ i ) { values [ i ] = defaultvalue ; } for ( i = 0 ; i < indexcount ; ++ i ) { indices [ i ] = ( char ) ( i << blockshift ) ; hashes [ i ] = 0 ; } iscompact = false ; this . defaultvalue = defaultvalue ; }
tr	5	private static void addtreasurechest ( scanner scanner , grid grid ) { system . out . println ( "please provide a name for your treasure chest :" ) ; string chest = scanner . nextline ( ) ; while ( chest == null || chest . equals ( "" ) ) { system . out . println ( "please provide a name for your treasure chest :" ) ; chest = scanner . nextline ( ) ; } system . out . println ( "please provide a position for your treasure chest " ) ; system . out . println ( "please enter a row number row numbers start from 0 and should be less than " + grid . getrows ( ) + " : " ) ; int row = getrows ( scanner ) ; while ( row == - 1 || row > grid . getrows ( ) ) { system . out . println ( "please enter a valid row number.row numbers start from 0 and is less than " + grid . getrows ( ) + " :" ) ; row = getrows ( scanner ) ; } int col = getcolumns ( scanner ) ; system . out . println ( "please enter the column you would like to position your treasure chest columns starts 1 and should be less than " + grid . getcolumns ( ) + " : " ) ; while ( col == - 1 || col > grid . getcolumns ( ) ) { system . out . println ( "please enter a valid column number. column numbers start from 1 and is less than " + grid . getcolumns ( ) ) ; col = getcolumns ( scanner ) ; } grid . addtreasurechest ( new treasurechest ( chest ) , row , col ) ; grid . displaygrid ( ) ; system . out . println ( "would you like to add another treasure chest to the grid ? y or n" ) ; string yn = addtreasure ( scanner ) ; while ( ! yn . trim ( ) . equalsignorecase ( "y" ) && ! yn . trim ( ) . equalsignorecase ( "n" ) ) { system . out . println ( "enter y or n :" ) ; yn = scanner . nextline ( ) ; } if ( yn . trim ( ) . equalsignorecase ( "y" ) ) { addtreasurechest ( scanner , grid ) ; } else { treasurechestcounter counter = new treasurechestmanager ( ) ; system . out . println ( "**********treasure maps nearby****************" ) ; counter . displaytreasurechestnearby ( grid ) ; system . out . println ( "thank you for using the trasure map finder" ) ; } }
tr	5	string encode ( final string name , final parameter [ ] parameters , final message . encodemode encodemode ) throws jsonexception { string encodedmessage = null ; if ( parameters != null && name != null ) { final jsonobject message = new jsonobject ( ) ; message . put ( name , ( ( arrayparameter ) parameters [ 0 ] ) . tojsonarray ( encodemode ) ) ; encodedmessage = message . tostring ( ) ; } if ( parameters != null && name == null ) { final jsonobject msg = new jsonobject ( ) ; for ( int i = 0 ; i < parameters . length ; i ++ ) { parameter param = parameters [ i ] ; if ( param instanceof arrayparameter ) { msg . put ( param . getname ( ) , ( ( arrayparameter ) param ) . tojsonarray ( encodemode ) ) ; } else { msg . put ( param . getname ( ) , param . getvalue ( ) ) ; } } encodedmessage = msg . tostring ( ) ; } return encodedmessage ; }
tr	4	private static char addandcheckwrap ( char c , int currentchar , int [ ] steps , boolean right ) { int c = ( ( int ) c ) ; int loop ; int mod = ( currentchar % steps . length ) ; if ( mod == 0 ) loop = steps [ steps . length - 1 ] ; else loop = steps [ ( mod - 1 ) ] ; if ( isalphanumericcharacter ( c ) ) { if ( right ) { for ( int i = 0 ; i < loop ; i ++ ) { c ++ ; if ( c == ( ( ( int ) 'z' ) + 1 ) ) c = ( ( int ) 'a' ) ; else if ( c == ( ( ( int ) 'z' ) + 1 ) ) c = ( ( int ) 'a' ) ; else if ( c == ( ( ( int ) '9' ) + 1 ) ) c = ( ( int ) '0' ) ; } } else { for ( int i = loop ; i > 0 ; i -- ) { c -- ; if ( c == ( ( ( int ) 'a' ) - 1 ) ) c = ( ( int ) 'z' ) ; else if ( c == ( ( ( int ) 'a' ) - 1 ) ) c = ( ( int ) 'z' ) ; else if ( c == ( ( ( int ) '0' ) - 1 ) ) c = ( ( int ) '9' ) ; } } } return ( ( char ) c ) ; }
tr	8	public static void main ( string [ ] args ) { system . out . print ( "enter the array's length\\n" ) ; int usernumber = sc . nextint ( ) ; int [ ] array = new int [ usernumber ] ; for ( int i = 0 ; i < usernumber ; i ++ ) { array [ i ] = r . nextint ( 100 ) ; } system . out . println ( arrays . tostring ( array ) + "-before sorting\\n" ) ; int userchoice ; do { userchoice = showmenu ( ) ; switch ( userchoice ) { case 1 : megasorter sort1 = new megasorter ( new bubblesort ( ) ) ; sort1 . setdelegate ( new bubblesort ( ) ) ; sort1 . sort ( array ) ; system . out . println ( "bubble sort is completed" ) ; system . out . println ( arrays . tostring ( array ) + "-after sorting\\n" ) ; break ; case 2 : megasorter sort2 = new megasorter ( new mergesort ( ) ) ; sort2 . setdelegate ( new mergesort ( ) ) ; sort2 . sort ( array ) ; system . out . println ( "merge sort is completed" ) ; system . out . println ( arrays . tostring ( array ) + "-after sorting\\n" ) ; break ; case 3 : megasorter sort3 = new megasorter ( new countsort ( ) ) ; sort3 . setdelegate ( new countsort ( ) ) ; sort3 . sort ( array ) ; system . out . println ( "count sort is completed" ) ; system . out . println ( arrays . tostring ( array ) + "-after sorting\\n" ) ; break ; case 4 : megasorter sort4 = new megasorter ( new treesort ( ) ) ; sort4 . setdelegate ( new treesort ( ) ) ; sort4 . sort ( array ) ; system . out . println ( "tree sort is completed" ) ; system . out . println ( arrays . tostring ( array ) + "-after sorting\\n" ) ; break ; default : break ; } } while ( userchoice != 0 ) ; }
tr	9	public list < object > getcolumnvalues ( string rowkey ) { list < object > listcolumnobj = new linkedlist < object > ( ) ; try { columnfamilytemplate < string , string > usercftemplate = new thriftcolumnfamilytemplate < string , string > ( this . getkeyspace ( ) , def_user_cf_name , stringserializer . get ( ) , stringserializer . get ( ) ) ; columnfamilyresult < string , string > result = usercftemplate . querycolumns ( rowkey ) ; string full_name = result . getstring ( "full_name" ) ; string address = result . getstring ( "address" ) ; string state = result . getstring ( "state" ) ; string gender = result . getstring ( "gender" ) ; string email = result . getstring ( "email" ) ; long birth_year = result . getlong ( "birth_year" ) ; system . out . println ( "full_name [" + full_name + "]" ) ; system . out . println ( "address [" + address + "]" ) ; system . out . println ( "state [" + state + "]" ) ; system . out . println ( "gender [" + gender + "]" ) ; system . out . println ( "birth_year [" + birth_year + "]" ) ; system . out . println ( "email [" + email + "]" ) ; listcolumnobj . add ( full_name ) ; listcolumnobj . add ( address ) ; listcolumnobj . add ( state ) ; listcolumnobj . add ( gender ) ; listcolumnobj . add ( email ) ; listcolumnobj . add ( birth_year ) ; } catch ( hectorexception e ) { system . out . println ( "error reading the column with key " + rowkey ) ; system . out . println ( e . getmessage ( ) ) ; } return listcolumnobj ; }
tr	9	private string createclassdoc ( classmodel model , string filename ) { model . addlinks ( ) ; string contents = "<td class='classcell'>" ; contents += "<h2 class='section-title'>" + filename + toggle_all + "</h2>" + "<div class='toggle_container_subtitle'>" + model . getnameline ( ) + "</div>" + "<table class='details' rules='all' border='1' cellpadding='6'>" + ( model . getdescription ( ) . isempty ( ) ? "" : "<tr><th>description</th><td>" + model . getdescription ( ) + "</td></tr>" ) + ( model . getauthor ( ) . isempty ( ) ? "" : "<tr><th>author</th><td>" + model . getauthor ( ) + "</td></tr>" ) + ( model . getdate ( ) . isempty ( ) ? "" : "<tr><th>date</th><td>" + model . getdate ( ) + "</td></tr>" ) + ( model . getversion ( ) . isempty ( ) ? "" : "<tr><th>version</th><td>" + model . getversion ( ) + "</td></tr>" ) + ( model . getsee ( ) . isempty ( ) ? "" : "<tr><th>see</th><td>" + model . getsee ( ) + "</td></tr>" ) + ( model . gethistory ( ) . isempty ( ) ? "" : "<tr><th>history</th><td>" + formathistory ( model . gethistory ( ) ) + "</td></tr>" ) + "</table>" ; if ( ! model . properties . isempty ( ) ) { contents += "<p></p>" + "<h2 class='trigger'>" + toggle_one + "&nbsp;&nbsp;<a href='#'>properties</a></h2>" + "<div class='toggle_container'> " + "<table class='properties' border='1' rules='all' cellpadding='6'> " ; for ( propertymodel prop : model . properties ) { string name = prop . getname ( ) ; prop . addlinks ( ) ; contents += "<tr><th class='clspropertyname'>" + name + "</th>" + "<td><div class='clspropertydeclaration'>" + prop . getnameline ( ) + "</div>" + "<div class='clspropertydescription'>" + prop . getdescription ( ) + ( prop . getauthor ( ) . isempty ( ) && prop . getdate ( ) . isempty ( ) ? "" : " (" + prop . getauthor ( ) + " " + prop . getdate ( ) + ")" ) + ( prop . getsee ( ) . isempty ( ) ? "" : "<litcomma> see " + prop . getsee ( ) ) + prop . getthrowsasstring ( ) + "</div></tr>" ; } contents += "</table></div>" ; } if ( ! model . methods . isempty ( ) ) { contents += "<h2 class='section-title methods'>methods</h2>" ; for ( methodmodel method : model . methods ) { string name = method . getname ( ) ; method . addlinks ( ) ; contents += "<h2 class='trigger'>" + toggle_one + "&nbsp;&nbsp;<a href='#'>" + name + "</a></h2>" + "<div class='toggle_container'>" + "<div class='toggle_container_subtitle'>" + method . getnameline ( ) + "</div>" + "<table class='details' rules='all' border='1' cellpadding='6'>" + ( method . getdescription ( ) != "" ? "<tr><th>description</th><td>" + method . getdescription ( ) + "</td></tr> " : "" ) + ( method . getauthor ( ) != "" ? "<tr><th>author</th><td>" + method . getauthor ( ) + "</td></tr> " : "" ) + ( method . getdate ( ) != "" ? "<tr><th>date</th><td>" + method . getdate ( ) + "</td></tr> " : "" ) + ( method . getversion ( ) != "" ? "<tr><th>version</th><td>" + method . getversion ( ) + "</td></tr> " : "" ) + ( method . getsince ( ) != "" ? "<tr><th>since</th><td>" + method . getsince ( ) + "</td></tr> " : "" ) + ( method . getreturns ( ) != "" ? "<tr><th>returns</th><td>" + method . getreturns ( ) + "</td></tr> " : "" ) + ( method . getparams ( ) . size ( ) > 0 ? "<tr><th colspan='2' class='paramheader'>parameters</th></tr> " : "" ) ; for ( string param : method . getparams ( ) ) { if ( ( null != param ) && ! param . trim ( ) . isempty ( ) ) { if ( param . indexof ( ' ' ) != - 1 ) { string list [ ] = param . split ( " " ) ; if ( list . length >= 1 ) { contents += "<tr><th class='param'>" + list [ 0 ] + "</th>" ; string val = "" ; if ( list . length >= 2 ) { val = "" ; for ( int i = 1 ; i < list . length ; i ++ ) { val += list [ i ] + " " ; } } contents += "<td>" + val + "</td></tr>" ; } } } } contents += ( method . getsee ( ) . isempty ( ) ? "" : "<tr><th>see</th><td>" + method . getsee ( ) + "</td></tr>" ) ; if ( ! method . getthrows ( ) . isempty ( ) ) { for ( string t : method . getthrows ( ) ) { contents += "<tr><th>throws</th><td>" + t + "</td></tr>" ; } } contents += "</table></div>" ; } } return contents + "</td>" ; }
tr	6	public static arraylist < string > encrypt ( biginteger p , biginteger q , biginteger e , biginteger m ) { arraylist < string > output = new arraylist < string > ( ) ; biginteger n = p . multiply ( q ) ; biginteger z = ( p . subtract ( biginteger . valueof ( 1 ) ) ) . multiply ( q . subtract ( biginteger . valueof ( 1 ) ) ) ; output . add ( "p = " + p ) ; output . add ( "q = " + q ) ; output . add ( "e = " + e ) ; output . add ( "m = " + m ) ; output . add ( "" ) ; output . add ( "n = (p)(q) = (" + p + ")(" + q + ") = " + n ) ; output . add ( "z = (p-1)(q-1) = (" + p + "-1)(" + q + "-1) = " + z ) ; output . add ( "" ) ; biginteger d = e . modinverse ( z ) ; output . add ( "d = gcd(e<litcomma> z) = " + d ) ; output . add ( "" ) ; biginteger enc = m ; enc = enc . modpow ( e , n ) ; biginteger dec = enc ; dec = dec . modpow ( d , n ) ; output . add ( "encrypted output = " + enc ) ; output . add ( "decrypted output (check) = " + dec ) ; return output ; }
tr	6	private static connection createnewconnection ( int i ) throws exception { string host = configuration . getconnhost ( i ) ; string port = configuration . getconnport ( i ) ; string url = "jdbc:mysql://" + host + ":" + port + "/" ; string db = configuration . getconndb ( i ) ; if ( db != null ) url += db ; string usr = configuration . getconnuser ( i ) ; string pwd = configuration . getconnpwd ( i ) ; class . forname ( driver_class ) ; return drivermanager . getconnection ( url , usr , pwd ) ; }
tr	7	public static double calculate_ndcg ( string query , linkedlist < string > url_list ) { hashmap < string , linkedlist < string > > google_resultmap = create_google_map ( ) ; iterator < string > it = url_list . iterator ( ) ; linkedlist < string > google_querymap = google_resultmap . get ( query ) ; if ( google_querymap == null ) return 1.0 ; string url ; int count = 0 , indx ; double ndcg = 0 ; while ( it . hasnext ( ) && count < 5 ) { url = it . next ( ) ; count ++ ; if ( google_querymap . contains ( url ) ) { indx = google_querymap . indexof ( url ) ; system . out . println ( "indx " + indx ) ; ndcg += ( math . pow ( 2.0 , 5 - ( indx ) ) - 1 ) / ( ( math . log10 ( count + 1 ) / math . log10 ( 2 ) ) ) ; } } ndcg /= ( double ) 45.64282878502658 ; return ndcg ; }
tr	9	public static matrix rotate ( vector axis , float angle ) { final matrix m = new matrix ( ) ; final float rad = ( angle / 180.0f ) * ( ( float ) math . pi ) ; final float cosa = ( float ) math . cos ( rad ) ; final float sina = ( float ) math . sin ( rad ) ; final vector naxis = axis . normalize ( ) ; final float rx = naxis . x ; final float ry = naxis . y ; final float rz = naxis . z ; final float icosa = 1 - cosa ; m . set ( 0 , 0 , ( float ) ( icosa * rx * rx + cosa ) ) ; m . set ( 0 , 1 , ( float ) ( icosa * rx * ry + rz * sina ) ) ; m . set ( 0 , 2 , ( float ) ( icosa * rx * rz - ry * sina ) ) ; m . set ( 1 , 0 , ( float ) ( icosa * rx * ry - rz * sina ) ) ; m . set ( 1 , 1 , ( float ) ( icosa * ry * ry + cosa ) ) ; m . set ( 1 , 2 , ( float ) ( icosa * ry * rz + rx * sina ) ) ; m . set ( 2 , 0 , ( float ) ( icosa * rx * rz + ry * sina ) ) ; m . set ( 2 , 1 , ( float ) ( icosa * ry * rz - rx * sina ) ) ; m . set ( 2 , 2 , ( float ) ( icosa * rz * rz + cosa ) ) ; return m ; }
tr	7	public static void main ( string [ ] arg ) { scanner sc = new scanner ( system . in ) ; int [ ] arr = { 3 , 5 , 7 , 9 , 11 , 13 , 15 , 17 , 19 , 21 , 23 , 25 } ; int max , min , t , pos , mitten ; min = 0 ; max = arr . length - 1 ; system . out . print ( "vilket heltal s\xf6ker du? " ) ; t = sc . nextint ( ) ; pos = - 1 ; while ( min <= max && pos == - 1 ) { mitten = ( max + min ) / 2 ; if ( t > arr [ mitten ] ) min = mitten + 1 ; else if ( t < arr [ mitten ] ) max = mitten - 1 ; else pos = mitten ; } if ( pos == - 1 ) system . out . println ( "talet hittades inte" ) ; else system . out . println ( "talet finns i element nummer " + pos ) ; }
tr	1	private void initgui ( ) { try { setdefaultcloseoperation ( windowconstants . dispose_on_close ) ; { jpanel1 = new jpanel ( ) ; getcontentpane ( ) . add ( jpanel1 , borderlayout . north ) ; jpanel1 . setpreferredsize ( new java . awt . dimension ( 384 , 42 ) ) ; { jlabel1 = new jlabel ( ) ; jpanel1 . add ( jlabel1 ) ; jlabel1 . settext ( "welcome to javainstantchat" ) ; } } { jpanel2 = new jpanel ( ) ; gridbaglayout jpanel2layout = new gridbaglayout ( ) ; getcontentpane ( ) . add ( jpanel2 , borderlayout . south ) ; jpanel2 . setpreferredsize ( new java . awt . dimension ( 384 , 212 ) ) ; jpanel2layout . rowweights = new double [ ] { 0.1 , 0.1 , 0.1 } ; jpanel2layout . rowheights = new int [ ] { 7 , 7 , 7 } ; jpanel2layout . columnweights = new double [ ] { 0.0 , 0.0 , 0.1 } ; jpanel2layout . columnwidths = new int [ ] { 181 , 151 , 20 } ; jpanel2 . setlayout ( jpanel2layout ) ; { jlabel2 = new jlabel ( ) ; jpanel2 . add ( jlabel2 , new gridbagconstraints ( 0 , 0 , 1 , 1 , 0.0 , 0.0 , gridbagconstraints . center , gridbagconstraints . none , new insets ( 0 , 0 , 0 , 0 ) , 0 , 0 ) ) ; jlabel2 . settext ( "login:" ) ; } { jlabel3 = new jlabel ( ) ; jpanel2 . add ( jlabel3 , new gridbagconstraints ( 0 , 1 , 1 , 1 , 0.0 , 0.0 , gridbagconstraints . center , gridbagconstraints . none , new insets ( 0 , 0 , 0 , 0 ) , 0 , 0 ) ) ; jlabel3 . settext ( "password:" ) ; } { jtextfield1 = new jtextfield ( ) ; jpanel2 . add ( jtextfield1 , new gridbagconstraints ( 1 , 0 , 1 , 1 , 0.0 , 0.0 , gridbagconstraints . center , gridbagconstraints . horizontal , new insets ( 0 , 0 , 0 , 0 ) , 0 , 0 ) ) ; } { jpasswordfield1 = new jpasswordfield ( ) ; jpanel2 . add ( jpasswordfield1 , new gridbagconstraints ( 1 , 1 , 1 , 1 , 0.0 , 0.0 , gridbagconstraints . center , gridbagconstraints . horizontal , new insets ( 0 , 0 , 0 , 0 ) , 0 , 0 ) ) ; } { jbutton1 = new jbutton ( ) ; jpanel2 . add ( jbutton1 , new gridbagconstraints ( 0 , 2 , 1 , 1 , 0.0 , 0.0 , gridbagconstraints . center , gridbagconstraints . none , new insets ( 0 , 0 , 0 , 0 ) , 0 , 0 ) ) ; jbutton1 . settext ( "connect" ) ; jbutton1 . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent evt ) { jbutton1actionperformed ( evt ) ; } } ) ; } { jbutton2 = new jbutton ( ) ; jpanel2 . add ( jbutton2 , new gridbagconstraints ( 1 , 2 , 1 , 1 , 0.0 , 0.0 , gridbagconstraints . center , gridbagconstraints . none , new insets ( 0 , 0 , 0 , 0 ) , 0 , 0 ) ) ; jbutton2 . settext ( "exit" ) ; jbutton2 . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent evt ) { jbutton2actionperformed ( evt ) ; } } ) ; } } pack ( ) ; setsize ( 400 , 300 ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } }
tr	7	public static void main ( string [ ] args ) { if ( args . length < 22 ) { system . err . println ( "verwendung: <quell-url> <ausgabedatei> <roothash (byte 1)> <roothash (byte 2)> ...  <roothash (byte 20)>" ) ; } string src = args [ 0 ] ; string dest = args [ 1 ] ; string [ ] hashstr = new string [ 20 ] ; byte [ ] hashbytes = new byte [ 20 ] ; system . arraycopy ( args , 2 , hashstr , 0 , 20 ) ; for ( int i = 0 ; i < hashstr . length ; i ++ ) { hashbytes [ i ] = ( byte ) integer . parseint ( hashstr [ i ] , 16 ) ; } hash hash = new hash ( hashbytes ) ; hashclient client = new hashclient ( src , dest , hash ) ; client . query ( ) ; }
tr	5	@ override public string tostring ( ) { string ret = "" ; if ( nodes != null && nodes . size ( ) > 0 ) { stringbuilder sb = new stringbuilder ( ) ; list < tconnection > printed = new arraylist < tconnection > ( ) ; for ( tnode n : nodes ) { for ( tconnection c : n . getconnections ( ) ) { if ( ! printed . contains ( c ) ) printed . add ( c ) ; } } for ( tconnection c : printed ) { sb . append ( c + "\\n" ) ; } ret = sb . tostring ( ) ; } else ret = "empty tree" ; return ret ; }
tr	4	private double midpoint ( list < instance > examples , int attributeindex ) { if ( examples == null || examples . isempty ( ) ) { return 0.0 ; } double max = double . negative_infinity , min = double . positive_infinity ; for ( instance instance : examples ) { int attribute = integer . parseint ( instance . attributes . get ( attributeindex ) ) ; if ( attribute > max ) { max = attribute ; } if ( attribute < min ) { min = attribute ; } } return 0.5 * ( max + min ) ; }
tr	7	public static void readconnectedto ( string filepath ) throws ioexception { bufferedreader br = null ; string scurrentline ; string [ ] output ; arraylist < tripletdata > result = new arraylist < > ( ) ; br = new bufferedreader ( new filereader ( filepath ) ) ; while ( ! ( scurrentline = br . readline ( ) ) . equals ( "end" ) ) { } int counter = 1 ; while ( ( scurrentline = br . readline ( ) ) != null ) { system . out . println ( "hello" ) ; output = scurrentline . split ( "\\\\s+" ) ; if ( counter == mynodenumber ) { for ( int i = 0 ; i < output . length ; i ++ ) { if ( output [ i ] . equals ( "1" ) ) { system . out . println ( "hey" ) ; for ( int j = 0 ; j < nodelist . size ( ) ; j ++ ) { if ( nodelist . get ( j ) . hostname == i + 1 ) connectedto . add ( nodelist . get ( j ) ) ; } } } } counter ++ ; } br . close ( ) ; }
tr	1	public void move ( arraylist < string > movelist ) { for ( string move : movelist ) { switch ( move ) { case "u" : controls . up ( ) ; break ; case "d" : controls . down ( ) ; break ; case "l" : controls . left ( ) ; break ; case "r" : controls . right ( ) ; break ; case "a" : controls . a ( ) ; break ; case "b" : controls . b ( ) ; break ; default : system . out . println ( "illegal move!" ) ; break ; } } }
tr	4	private void queryand ( list < string > data , string word , int atleast ) { string [ ] dataar = new string [ data . size ( ) ] ; for ( int i = 0 ; i < data . size ( ) ; i ++ ) { dataar [ i ] = data . get ( i ) ; } for ( string sentence : dataar ) { string caseinsensitivesentence = sentence . tolowercase ( ) ; if ( ! queryandhasatleast ( caseinsensitivesentence , word , atleast ) ) { data . remove ( sentence ) ; } } }
tr	7	public static string md5 ( inputstream is ) throws ioexception { string md5 = "" ; try { byte [ ] bytes = new byte [ 4096 ] ; int read = 0 ; messagedigest digest = messagedigest . getinstance ( "md5" ) ; while ( ( read = is . read ( bytes ) ) != - 1 ) { digest . update ( bytes , 0 , read ) ; } byte [ ] messagedigest = digest . digest ( ) ; stringbuilder sb = new stringbuilder ( 32 ) ; for ( byte b : messagedigest ) { sb . append ( hexdigits [ ( b > > 4 ) & 0x0f ] ) ; sb . append ( hexdigits [ b & 0x0f ] ) ; } md5 = sb . tostring ( ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } return md5 ; }
tr	1	public static void showbaninfo ( editban eb , commandsender sender ) { dateformat shorttime = dateformat . getdatetimeinstance ( ) ; sender . sendmessage ( chatcolor . aqua + bantype ( eb . type ) ) ; sender . sendmessage ( chatcolor . gold + " | " + chatcolor . white + eb . name + chatcolor . yellow + " was banned by " + chatcolor . white + eb . admin + chatcolor . yellow ) ; sender . sendmessage ( chatcolor . gold + " | at " + shorttime . format ( ( new date ( eb . time * 1000 ) ) ) ) ; if ( eb . endtime > 0 ) sender . sendmessage ( chatcolor . gold + " | " + chatcolor . yellow + "will be unbanned at " + shorttime . format ( ( new date ( eb . endtime * 1000 ) ) ) ) ; sender . sendmessage ( chatcolor . gold + " | " + chatcolor . yellow + "reason: " + chatcolor . gray + eb . reason ) ; }
tr	8	public void execute ( ) { string result = null ; environment env = environment . valueof ( "system" ) ; inputreader inputreader = env . getinputreader ( ) ; outputwriter outputwriter = env . getoutputwriter ( ) ; inputvalidator validator = new inputvalidator ( ) ; inputparser parser = new inputparser ( ) ; string input = inputreader . readinput ( ) ; try { int value = validator . validate ( input ) ; result = parser . parse ( value ) ; } catch ( validationexception e ) { result = e . getmessage ( ) ; } outputwriter . writeoutput ( result ) ; }
tr	3	public static void main ( string [ ] args ) { chat ch = new chat ( ) ; if ( args . length == 1 ) { int port = integer . parseint ( args [ 0 ] ) ; ch . mode1 ( port ) ; } else if ( args . length == 2 ) { debug . print ( args [ 0 ] ) ; debug . print ( args [ 1 ] ) ; int port = integer . parseint ( args [ 0 ] ) ; string host = args [ 1 ] ; ch . mode2 ( port , host ) ; } else { system . out . println ( "usage: java chat <port num> [<host name>]" ) ; system . exit ( 0 ) ; } }
tr	5	private void retrieve ( ) { try { url url = new url ( web_page + name ) ; bufferedreader reader = new bufferedreader ( new inputstreamreader ( url . openstream ( ) ) ) ; jsonparser parser = new jsonparser ( ) ; jsonobject object = ( jsonobject ) parser . parse ( reader ) ; string uid = ( string ) object . get ( "uuid_formatted" ) ; this . uuid = uuid . fromstring ( uid ) ; reader . close ( ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } }
tr	2	public static string hexdump ( byte [ ] bytes ) { stringbuilder sb = new stringbuilder ( ) ; for ( int addr = 0 ; addr < bytes . length ; addr ++ ) { if ( ( addr & 0xf ) == 0 ) { if ( addr != 0 ) sb . append ( '\\n' ) ; sb . append ( string . format ( "%08x: " , addr ) ) ; } sb . append ( string . format ( "%02x" , bytes [ addr ] ) ) ; if ( ( addr & 0xf ) != 15 ) sb . append ( ' ' ) ; } return sb . tostring ( ) ; }
tr	6	public deckbuild ( ) { for ( int r = 0 ; r < 13 ; r ++ ) { for ( int s = 0 ; s < 4 ; s ++ ) { rank = r + 1 ; suit = s + 1 ; deck . add ( new card ( suit , rank ) ) ; } } for ( int j = 0 ; j < deck . size ( ) ; j ++ ) { string rankstr = "" ; string suitstr = "" ; switch ( deck . get ( j ) . getrank ( ) ) { case 1 : rankstr = "ace" ; break ; case 11 : rankstr = "jack" ; break ; case 12 : rankstr = "queen" ; break ; case 13 : rankstr = "king" ; break ; default : rankstr = "" ; break ; } switch ( deck . get ( j ) . getsuit ( ) ) { case 1 : suitstr = "c" ; break ; case 2 : suitstr = "d" ; break ; case 3 : suitstr = "s" ; break ; case 4 : suitstr = "h" ; break ; } } shuffle ( deck ) ; for ( int h = 0 ; h < deck . size ( ) ; h ++ ) { if ( h == 0 || h % 2 == 0 ) { deckhalfone . add ( deck . get ( h ) ) ; } else { deckhalftwo . add ( deck . get ( h ) ) ; } } }
tr	7	public void pastenode ( ) { treenode selectednode = treecontrol . getselectednode ( ) ; treenode node = clipboard . getchildren ( ) . get ( 0 ) ; boolean duplicated = false ; for ( treenode item : selectednode . getchildren ( ) ) { urldocument doc = ( urldocument ) item . getdata ( ) ; urldocument docclipboard = ( urldocument ) node . getdata ( ) ; if ( doc . getname ( ) . matches ( docclipboard . getname ( ) ) ) { duplicated = true ; break ; } } if ( ! duplicated ) { node . setparent ( selectednode ) ; urldocument urldocument = ( urldocument ) node . getdata ( ) ; urldocument . setparentnode ( selectednode ) ; urldocument . pathupdate ( ) ; updatechildren ( node ) ; treecontrol . setnodepath ( urldocument . getfullpath ( ) ) ; } }
tr	6	public arraylist < arraylist < integer > > threesum ( int [ ] num ) { arraylist < arraylist < integer > > result = new arraylist < arraylist < integer > > ( ) ; if ( num . length < 3 ) return result ; arrays . sort ( num ) ; int lastuniqe = num [ 0 ] ; for ( int i = 0 ; i < num . length ; i ++ ) { if ( i == 0 || num [ i ] != lastuniqe ) { lastuniqe = num [ i ] ; arraylist < arraylist < integer > > two = twosuminternal ( num , 0 - num [ i ] , i + 1 ) ; if ( ! two . isempty ( ) ) { for ( arraylist < integer > ele : two ) { arraylist < integer > res = new arraylist < integer > ( ) ; res . add ( num [ i ] ) ; res . add ( ele . get ( 0 ) ) ; res . add ( ele . get ( 1 ) ) ; result . add ( res ) ; } } } } return result ; }
tr	8	@ override public void receive ( message message ) throws messagelistenerexception { long companyid = portalutil . getdefaultcompanyid ( ) ; try { user user = userlocalserviceutil . getuserbyemailaddress ( companyid , portletpropsvalues . detect_user_email ) ; expandotable table = expandotablelocalserviceutil . getdefaulttable ( user . getcompanyid ( ) , user . class . getname ( ) ) ; expandocolumn column = expandocolumnlocalserviceutil . getcolumn ( table . gettableid ( ) , constants . expando_column_name ) ; expandovalue value = expandovaluelocalserviceutil . getvalue ( table . gettableid ( ) , column . getcolumnid ( ) , user . getuserid ( ) ) ; string languagechangetime = stringpool . blank ; if ( value != null ) { languagechangetime = value . getdata ( ) ; } string userlanguage = user . getlanguageid ( ) ; long timestamp = system . currenttimemillis ( ) ; if ( validator . isnull ( languagechangetime ) && userlanguage . equals ( portletpropsvalues . detect_language ) ) { expandovaluelocalserviceutil . addvalue ( table . getclassnameid ( ) , table . gettableid ( ) , column . getcolumnid ( ) , user . getuserid ( ) , string . valueof ( timestamp ) ) ; if ( _log . isinfoenabled ( ) ) { _log . info ( "detect user language change." ) ; } } if ( validator . isnotnull ( languagechangetime ) && ! userlanguage . equals ( portletpropsvalues . detect_language ) ) { expandovaluelocalserviceutil . addvalue ( table . getclassnameid ( ) , table . gettableid ( ) , column . getcolumnid ( ) , user . getuserid ( ) , stringpool . blank ) ; } if ( validator . isnotnull ( languagechangetime ) && userlanguage . equals ( portletpropsvalues . detect_language ) && ( timestamp - long . valueof ( languagechangetime ) ) >= portletpropsvalues . language_life_ms ) { user . setlanguageid ( portletpropsvalues . recover_language ) ; userlocalserviceutil . updateuser ( user ) ; expandovaluelocalserviceutil . addvalue ( table . getclassnameid ( ) , table . gettableid ( ) , column . getcolumnid ( ) , user . getuserid ( ) , stringpool . blank ) ; if ( _log . isinfoenabled ( ) ) { _log . info ( "update user language to " + portletpropsvalues . recover_language ) ; } } } catch ( nosuchuserexception nsue ) { if ( _log . isinfoenabled ( ) ) { _log . info ( "user " + portletpropsvalues . detect_user_email + " does not exist" ) ; } } catch ( exception e ) { if ( _log . iserrorenabled ( ) ) { _log . error ( e ) ; } } }
tr	4	private server ( string name , int port ) throws socketexception { instance = this ; logger = logger . getlogger ( "mcpe_server" ) ; logger . setlevel ( level . all ) ; logger . setuseparenthandlers ( false ) ; for ( handler h : logger . gethandlers ( ) ) logger . removehandler ( h ) ; logger . addhandler ( new handler ( ) { dateformat df = new simpledateformat ( "yyyy-mm-dd hh:mm:ss" ) ; @ override public void publish ( logrecord record ) { level l = record . getlevel ( ) ; printstream out = l . intvalue ( ) > level . info . intvalue ( ) ? system . err : system . out ; out . println ( df . format ( new date ( record . getmillis ( ) ) ) + " [" + record . getloggername ( ) + "]" + "[" + l . getlocalizedname ( ) + "] " + record . getmessage ( ) ) ; } @ override public void flush ( ) { system . out . flush ( ) ; system . err . flush ( ) ; } @ override public void close ( ) throws securityexception { system . out . close ( ) ; system . err . close ( ) ; } } ) ; random = new random ( ) ; serverid = 0x372cdc9e ; servername = name ; servertype = "demo" ; try { pcaplogger = new pcaplogger ( new fileoutputstream ( "packets.pcap" ) ) ; packetlogger = new printstream ( "packets.log" ) ; } catch ( filenotfoundexception e ) { e . printstacktrace ( ) ; } clients = new hashmap < integer , entityplayer > ( ) ; players = new hashmap < string , entityplayer > ( ) ; whitelist = new arraylist < string > ( ) ; banned = new arraylist < string > ( ) ; bannedips = new arraylist < inetaddress > ( ) ; serversocket = new datagramsocket ( port ) ; handler = new packethandler ( ) ; log ( "starting minecraft pe server on " + serversocket . getinetaddress ( ) + ":" + port ) ; }
tr	10	public static bufferedimage removebackground ( bufferedimage img , vector < somvector > inputs ) { map < somvector , integer > map = new hashmap < somvector , integer > ( ) ; vector < somvector > bckcols = new vector < somvector > ( ) ; int old = 0 ; for ( somvector s : inputs ) { map . put ( s , 0 ) ; } for ( int i = 0 ; i < img . getwidth ( ) - 1 ; i ++ ) { for ( int j = 0 ; j < img . getheight ( ) - 1 ; j ++ ) { somvector v = new somvector ( new color ( img . getrgb ( i , j ) ) ) ; for ( somvector vec : inputs ) { if ( v . euclideandist ( vec ) < 0.02 ) { old = map . get ( vec ) ; map . put ( vec , old + 1 ) ; break ; } } } } int prc10 = ( int ) ( 0.1 * img . getwidth ( ) * img . getheight ( ) ) ; for ( map . entry < somvector , integer > entry : map . entryset ( ) ) { if ( entry . getvalue ( ) >= prc10 ) { bckcols . addelement ( entry . getkey ( ) ) ; } } for ( int i = 0 ; i < img . getwidth ( ) - 1 ; i ++ ) { for ( int j = 0 ; j < img . getheight ( ) - 1 ; j ++ ) { for ( somvector vec : bckcols ) { somvector v = new somvector ( new color ( img . getrgb ( i , j ) ) ) ; if ( v . euclideandist ( vec ) < 0.02 ) { img . setrgb ( i , j , - 16777216 ) ; } } } } return img ; }
tr	8	public static void main ( string ... args ) { system . out . println ( "hello talls! from pwiggles' laptop!!" ) ; shape r1020 = new rectangle ( 10 , 20 ) ; rectangle r3030 = new rectangle ( 30 , 30 ) ; equilateraltriangle t3 = new equilateraltriangle ( 3.14 ) ; arraylist < shape > shapeslist = new arraylist < shape > ( ) ; shapeslist . add ( r1020 ) ; shapeslist . add ( r3030 ) ; shapeslist . add ( t3 ) ; double sumarea = 0 ; for ( int i = 0 ; i < shapeslist . size ( ) ; i ++ ) { sumarea = sumarea + shapeslist . get ( i ) . getarea ( ) ; } arraylist < double > = = new arraylist < double > ( ) ; = . add ( 7. ) ; = . add ( 2. ) ; = . add ( 3. ) ; = . add ( 5.0 ) ; integral fts = new integral ( ) ; system . out . println ( fts . getintegral ( = , 0 , 10 , 100000 ) ) ; }
tr	1	@ inject public parameter ( injectionpoint ip ) { string key = ip . getannotated ( ) . getannotation ( param . class ) . value ( ) ; flashscope = "flash" . equals ( ip . getannotated ( ) . getannotation ( param . class ) . scope ( ) ) ; type = reflections . getgenerictypeargument ( ip . getmember ( ) , 0 ) ; if ( key . isempty ( ) ) { this . key = ip . getmember ( ) . getname ( ) ; } else { this . key = key ; } }
tr	5	private void breakword ( string s , set < string > dict , arraylist < string > path , arraylist < string > res ) { if ( s . length ( ) == 0 ) { string r = "" ; for ( string p : path ) { r = r + ( r . length ( ) == 0 ? p : " " + p ) ; } res . add ( r ) ; return ; } for ( int i = 1 ; i <= s . length ( ) ; i ++ ) { string curr = s . substring ( 0 , i ) ; for ( string d : dict ) { if ( curr . equals ( d ) ) { path . add ( d ) ; breakword ( s . substring ( i ) , dict , path , res ) ; path . remove ( d ) ; } } } }
tr	4	public void displaygrid ( ) { system . out . println ( "grid name :" + getname ( ) ) ; for ( int row = 0 ; row < rows ; row ++ ) { stringbuilder gridbulder = new stringbuilder ( ) ; for ( int col = 0 ; col < columns ; col ++ ) { treasurechest chest = treasurechest [ row ] [ col ] ; if ( chest == null ) { gridbulder . append ( "_ " ) ; } else { gridbulder . append ( "x " ) ; } } system . out . println ( gridbulder . tostring ( ) ) ; } }
tr	10	private void unfilterpaeth ( byte [ ] curline , byte [ ] prevline ) { final int bpp = this . bytesperpixel ; int i ; for ( i = 1 ; i <= bpp ; ++ i ) { curline [ i ] += prevline [ i ] ; } for ( int n = curline . length ; i < n ; ++ i ) { int a = curline [ i - bpp ] & 255 ; int b = prevline [ i ] & 255 ; int c = prevline [ i - bpp ] & 255 ; int p = a + b - c ; int pa = p - a ; if ( pa < 0 ) pa = - pa ; int pb = p - b ; if ( pb < 0 ) pb = - pb ; int pc = p - c ; if ( pc < 0 ) pc = - pc ; if ( pa <= pb && pa <= pc ) c = a ; else if ( pb <= pc ) c = b ; curline [ i ] += ( byte ) c ; } }
tr	10	private jsonelement doget ( string resource , map < string , string > parameters , boolean raise404 ) throws exception { httpclient httpclient = new defaulthttpclient ( ) ; string uri = geturi ( resource ) ; if ( parameters != null && parameters . size ( ) > 0 ) { list < namevaluepair > queryparams = new arraylist < namevaluepair > ( ) ; for ( string key : parameters . keyset ( ) ) { queryparams . add ( new basicnamevaluepair ( key , parameters . get ( key ) ) ) ; } uri += "?" + urlencodedutils . format ( queryparams , "utf-8" ) ; } try { httpget httpget = new httpget ( uri ) ; httpresponse httpresponse = httpclient . execute ( httpget ) ; string body = entityutils . tostring ( httpresponse . getentity ( ) ) ; int code = httpresponse . getstatusline ( ) . getstatuscode ( ) ; if ( code == 200 ) { httpclient . getconnectionmanager ( ) . shutdown ( ) ; jsonparser parser = new jsonparser ( ) ; return parser . parse ( body ) ; } else if ( code == 404 && ! raise404 ) { httpclient . getconnectionmanager ( ) . shutdown ( ) ; return null ; } else { string message = "response code " + httpresponse . getstatusline ( ) . getstatuscode ( ) + ". " ; message += body ; throw new exception ( message ) ; } } catch ( exception e ) { httpclient . getconnectionmanager ( ) . shutdown ( ) ; throw e ; } }
tr	1	public equipo entrada_objeto ( int posequipo ) { cancha . equipo equipo_entrante = null ; try { entrada = sockequipos . get ( posequipo ) . getinputstream ( ) ; entrada_serializada = new objectinputstream ( entrada ) ; equipo_entrante = ( cancha . equipo ) entrada_serializada . readobject ( ) ; system . out . println ( "nombre equipo" + equipo_entrante . equipo ) ; } catch ( ioexception ex ) { logger . getlogger ( conexionservidor . class . getname ( ) ) . log ( level . severe , null , ex ) ; } catch ( classnotfoundexception ex ) { logger . getlogger ( conexionservidor . class . getname ( ) ) . log ( level . severe , null , ex ) ; } return equipo_entrante ; }
tr	6	private static void ganguploop ( int [ ] [ ] board ) { boolean continueloop = true ; int playernumber = 1 ; int turnnumber = 1 ; int consecutiveconectionsrequired = 3 ; int numberofplayers = 4 ; gangupdataobject recieveddataobject ; while ( continueloop == true ) { recieveddataobject = placepiece ( board , playernumber ) ; if ( recieveddataobject . getispieceplaced ( ) ) { if ( checkforwin ( turnnumber , recieveddataobject . getinputx ( ) , recieveddataobject . getinputy ( ) , recieveddataobject . getboard ( ) , consecutiveconectionsrequired , numberofplayers ) ) { win ( playernumber ) ; continueloop = false ; } ; turnnumber ++ ; if ( playernumber < 4 ) { playernumber ++ ; } else { playernumber = 1 ; } } else invalidmove ( ) ; } }
tr	3	public loginframe ( ) { try { uimanager . setlookandfeel ( uimanager . getsystemlookandfeelclassname ( ) ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } getcontentpane ( ) . setfont ( arial ) ; settitle ( "ggc chat login" ) ; setdefaultcloseoperation ( jframe . exit_on_close ) ; setbounds ( 100 , 100 , 270 , 297 ) ; setresizable ( false ) ; setlocationrelativeto ( null ) ; getcontentpane ( ) . setlayout ( null ) ; jlabel lblusername = new jlabel ( "username" ) ; lblusername . setfont ( arial ) ; lblusername . setbounds ( 88 , 21 , 71 , 14 ) ; getcontentpane ( ) . add ( lblusername ) ; txtusername = new jtextfield ( ) ; txtusername . setfont ( arial ) ; txtusername . setbounds ( 52 , 52 , 149 , 20 ) ; getcontentpane ( ) . add ( txtusername ) ; txtusername . setcolumns ( 10 ) ; jlabel lblservip = new jlabel ( "server ip" ) ; lblservip . setfont ( arial ) ; lblservip . setbounds ( 88 , 83 , 64 , 14 ) ; getcontentpane ( ) . add ( lblservip ) ; txtservip = new jtextfield ( ) ; txtservip . setfont ( arial ) ; txtservip . setbounds ( 52 , 108 , 149 , 20 ) ; getcontentpane ( ) . add ( txtservip ) ; txtservip . setcolumns ( 10 ) ; lblservport = new jlabel ( "server port" ) ; lblservport . setfont ( arial ) ; lblservport . setbounds ( 88 , 139 , 74 , 14 ) ; getcontentpane ( ) . add ( lblservport ) ; txtservport = new jtextfield ( ) ; txtservport . setfont ( arial ) ; txtservport . setbounds ( 52 , 164 , 149 , 20 ) ; getcontentpane ( ) . add ( txtservport ) ; txtservport . setcolumns ( 10 ) ; jbutton btnconnect = new jbutton ( "connect" ) ; btnconnect . setfont ( arial ) ; btnconnect . setbounds ( 83 , 212 , 89 , 23 ) ; btnconnect . addactionlistener ( this ) ; getcontentpane ( ) . add ( btnconnect ) ; }
tr	1	public static string labelprefixremover ( string label ) { string newlabel = "o" ; if ( label . contains ( "b-" ) ) { newlabel = label . replace ( "b-" , "" ) ; } else if ( label . contains ( "i-" ) ) { newlabel = label . replace ( "i-" , "" ) ; } if ( newlabel . contains ( "peo" ) ) { return "per" ; } else if ( newlabel . contains ( "loc" ) ) { return "loc" ; } else if ( newlabel . contains ( "org" ) ) { return newlabel ; } else if ( newlabel . equals ( "o" ) ) { return newlabel ; } else { return "misc" ; } }
tr	9	protected void placementautobateaux ( ) { try { string filepath = "./bateaux.txt" ; scanner scanner = new scanner ( new file ( filepath ) ) ; while ( scanner . hasnextline ( ) ) { string line = scanner . nextline ( ) ; boolean isbateauplace = false ; do { int [ ] coordonee ; int sens = - 1 ; coordonee = board . parsestringcoordonnee ( generaterandomcordonees ( ) ) ; if ( coordonee [ 0 ] != - 1 ) { int lower = 1 ; int higher = 3 ; sens = ( int ) ( math . random ( ) * ( higher - lower ) ) + lower ; } int placementerr = this . placerbateau ( new bateau ( integer . valueof ( line . substring ( 0 , 1 ) ) , line . substring ( 2 ) , coordonee [ 0 ] , coordonee [ 1 ] , sens ) ) ; if ( placementerr == - 1 ) { } else if ( placementerr == - 2 ) { } else { isbateauplace = true ; } } while ( ! isbateauplace ) ; } scanner . close ( ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } }
tr	8	public static categorynode buildcategorychain ( elements lielements ) { int size = lielements . size ( ) ; int i = 0 ; categorynode root = null ; categorynode current = null ; categorynode pre = null ; for ( i = 0 ; i < size ; i ++ ) { element li = lielements . get ( i ) ; current = new categorynode ( ) ; if ( i < size - 1 ) { element spanlast = li . select ( "span" ) . last ( ) ; current . setcategoryname ( spanlast . text ( ) ) ; } else { element strongelement = li . select ( "strong" ) . first ( ) ; current . setcategoryname ( strongelement . text ( ) ) ; } if ( i == 0 ) { root = current ; pre = current ; } else { pre . setnext ( current ) ; current . setpre ( pre ) ; pre = current ; } } return root ; }
tr	7	@ override public object mapfromattributes ( attributes attributes ) throws namingexception { person person = new person ( ) ; attribute name = attributes . get ( "name" ) ; if ( name != null ) { person . setname ( ( string ) name . get ( ) ) ; } attribute displayname = attributes . get ( "displayname" ) ; if ( displayname != null ) { person . setdisplayname ( ( string ) displayname . get ( ) ) ; } attribute lastname = attributes . get ( "sn" ) ; if ( lastname != null ) { person . setlastname ( ( string ) lastname . get ( ) ) ; } attribute firstname = attributes . get ( "givenname" ) ; if ( firstname != null ) { person . setfirstname ( ( string ) firstname . get ( ) ) ; } attribute mail = attributes . get ( "mail" ) ; if ( mail != null ) { person . setmail ( ( string ) mail . get ( ) ) ; } attribute userid = attributes . get ( "uid" ) ; if ( userid != null ) { person . setuserid ( ( string ) userid . get ( ) ) ; } system . out . println ( person . tostring ( ) ) ; return person ; }
tr	3	private boolean checkborders ( ) { boolean check = false ; int width = gameinst . container . getwidth ( ) ; int height = gameinst . container . getheight ( ) ; if ( location [ 0 ] >= width ) { check = true ; if ( velocity [ 0 ] > 0 ) velocity [ 0 ] *= - .5f ; } if ( location [ 0 ] <= 0 ) { check = true ; if ( velocity [ 0 ] < 0 ) velocity [ 0 ] *= - .5f ; } if ( location [ 1 ] >= height ) { check = true ; if ( velocity [ 1 ] > 0 ) velocity [ 1 ] *= - .5f ; } if ( location [ 1 ] <= 0 ) { check = true ; if ( velocity [ 1 ] < 0 ) velocity [ 1 ] *= - .5f ; } return check ; }
tr	5	public int evalrpn ( string [ ] tokens ) { stack < integer > cal = new stack < integer > ( ) ; for ( int i = 0 ; i < tokens . length ; i ++ ) { try { int num = integer . parseint ( tokens [ i ] ) ; cal . push ( num ) ; } catch ( numberformatexception e ) { int op2 = ( int ) cal . pop ( ) ; int op1 = ( int ) cal . pop ( ) ; switch ( tokens [ i ] ) { case "+" : cal . push ( op1 + op2 ) ; break ; case "-" : cal . push ( op1 - op2 ) ; break ; case "*" : cal . push ( op1 * op2 ) ; break ; case "/" : cal . push ( op1 / op2 ) ; break ; default : return 0 ; } } } return ( int ) cal . pop ( ) ; }
tr	7	@ override public void contextinitialized ( servletcontextevent sce ) { logger . debug ( "initializing.." ) ; webapplicationcontext ctx = webapplicationcontextutils . getwebapplicationcontext ( sce . getservletcontext ( ) ) ; personrepository personrepository = ctx . getbean ( personrepository . class ) ; personrepository . deleteall ( ) ; list < person > persons = new arraylist < person > ( ) ; int itemcount = 100 ; int chunksize = 25 ; for ( int i = 1 ; i <= itemcount ; i ++ ) { person p = new person ( ) ; p . setage ( ( i % 100 ) + 1 ) ; p . setname ( "name" + i ) ; persons . add ( p ) ; if ( ( i % chunksize ) == 0 ) { personrepository . save ( persons ) ; persons . clear ( ) ; } } personrepository . save ( persons ) ; }
tr	6	public void greeting ( ) { scanner scanobj = new scanner ( system . in ) ; string item = "" , qty = "" , price = "" ; boolean input = true ; system . out . println ( "please enter item bought\\n" ) ; system . out . println ( "========================================" ) ; while ( input != false ) { system . out . println ( "item" ) ; item = scanobj . nextline ( ) ; system . out . println ( "price" ) ; price = scanobj . nextline ( ) ; system . out . println ( "qty" ) ; qty = scanobj . nextline ( ) ; system . out . println ( "next item??" ) ; system . out . println ( "0-n0" ) ; system . out . println ( "1-yes" ) ; input = integer . parseint ( scanobj . nextline ( ) ) == 1 ; } arraylist < itemsshopped > items = new arraylist < itemsshopped > ( ) ; items . add ( new itemsshopped ( item , price , qty ) ) ; }
tr	8	@ override @ suppresswarnings ( "unchecked" ) public configuration generateconfiguration ( string [ ] commands ) throws classnotfoundexception { configuration configuration = new configuration ( ) ; for ( int i = 0 ; i < commands . length ; i ++ ) { string command = commands [ i ] ; if ( "-c" . equals ( command ) ) { configuration . setconcurrent ( integer . valueof ( commands [ ++ i ] ) ) ; } else if ( "-d" . equals ( command ) ) { configuration . setduration ( long . valueof ( commands [ ++ i ] ) ) ; } else if ( "-i" . equals ( command ) ) { configuration . setindex ( integer . valueof ( commands [ ++ i ] ) ) ; } else if ( "-t" . equals ( command ) ) { configuration . settimeout ( integer . valueof ( commands [ ++ i ] ) ) ; } else if ( "-p" . equals ( command ) ) { string stringparameters = commands [ ++ i ] ; string [ ] temparray = stringparameters . split ( "<litcomma>" ) ; map < string , object > parameters = new hashmap < string , object > ( temparray . length / 2 ) ; for ( int j = 0 ; j < temparray . length ; j += 2 ) { parameters . put ( temparray [ j ] , temparray [ j + 1 ] ) ; } configuration . setparameters ( parameters ) ; } else if ( "-a" . equals ( command ) ) { class < action > action = ( class < action > ) class . forname ( commands [ ++ i ] ) ; configuration . setaction ( action ) ; } } return configuration ; }
tr	9	public static void tst1 ( ) { trackdto trackdto = new trackdto ( ) ; list < track > tracks1 = trackdto . getalltracks ( ) ; for ( track track : tracks1 ) { system . out . println ( track ) ; } system . out . println ( "------" ) ; track track11 = trackdto . gettrackbytitle ( "one" ) ; system . out . println ( track11 ) ; system . out . println ( "------" ) ; track track12 = trackdto . gettrackbyid ( 12 ) ; system . out . println ( track12 ) ; system . out . println ( "------" ) ; track track22 = new track ( 22 , "jude" , "beatles" ) ; track track23 = new track ( 23 , "submarine" , "beatles" ) ; string result20 = trackdto . createtrack ( track22 ) ; system . out . println ( result20 ) ; result20 = trackdto . createtrack ( track23 ) ; system . out . println ( result20 ) ; tracks1 = trackdto . getalltracks ( ) ; for ( track track : tracks1 ) { system . out . println ( track ) ; } system . out . println ( "------" ) ; track track24 = new track ( 13 , "1999" , "pineapples" ) ; result20 = trackdto . updatetrack ( track24 ) ; system . out . println ( result20 ) ; trackdto . deletetrackbyid ( 12 ) ; tracks1 = trackdto . getalltracks ( ) ; for ( track track : tracks1 ) { system . out . println ( track ) ; } system . out . println ( "------" ) ; }
tr	1	public void actionperformed ( actionevent e ) { if ( "next" . equals ( e . getactioncommand ( ) ) ) { update ( 1 ) ; } if ( "forward" . equals ( e . getactioncommand ( ) ) ) { integer num = new integer ( forwardepochs . gettext ( ) ) ; update ( num . intvalue ( ) ) ; } if ( "restart" . equals ( e . getactioncommand ( ) ) ) { scape . frame . dispose ( ) ; new simulation ( ) . run ( ) ; } if ( "exit" . equals ( e . getactioncommand ( ) ) ) { scape . frame . dispose ( ) ; } }
tr	9	private void wyslijzadanie ( int numersamolotu , int numerakcji , int czyspecjalny , double eventtime ) throws rtiexception { suppliedparameters parameters = rtifactoryfactory . getrtifactory ( ) . createsuppliedparameters ( ) ; byte [ ] numersamolotuvalue = encodinghelpers . encodestring ( "numersamolotu:" + numersamolotu ) ; byte [ ] numerakcjivalue = encodinghelpers . encodestring ( "numerakcji:" + numerakcji ) ; byte [ ] czyspecjalnyvalue = encodinghelpers . encodestring ( "czyspecjalny:" + czyspecjalny ) ; int classhandle = rti . getinteractionclasshandle ( constants . interkacja_akcja_samolotu ) ; int numersamolotuhandle = rti . getparameterhandle ( "numersamolotu" , classhandle ) ; int numerakcjihandle = rti . getparameterhandle ( "numerakcji" , classhandle ) ; int czyspecjalnyhandle = rti . getparameterhandle ( "czyspecjalny" , classhandle ) ; parameters . add ( numersamolotuhandle , numersamolotuvalue ) ; parameters . add ( numerakcjihandle , numerakcjivalue ) ; parameters . add ( czyspecjalnyhandle , czyspecjalnyvalue ) ; logicaltime time = converttime ( eventtime ) ; rti . sendinteraction ( classhandle , parameters , generatetag ( ) , time ) ; }
tr	8	protected void loadtrophyconfig ( commandsender sender ) { if ( ! configloaded ) { sender . sendmessage ( chatcolor . gold + log_header + " configuration loaded." ) ; } else { reloadconfig ( ) ; sender . sendmessage ( chatcolor . gold + log_header + " configuration reloaded." ) ; } configloaded = true ; debugenabled = getconfig ( ) . getboolean ( "debug-enabled" ) ; logdebug ( "debug enabled" ) ; cooldown = getconfig ( ) . getlong ( "right-click-cooldown" , 40l ) ; logdebug ( "cooldown: " + cooldown ) ; drop_chances . put ( entitytype . player . tostring ( ) , getconfig ( ) . getint ( "drop-chance" ) ) ; logdebug ( "chance to drop head: " + drop_chances . get ( entitytype . player . tostring ( ) ) + "%" ) ; playerskin = getconfig ( ) . getboolean ( "player-skin" ) ; logdebug ( "player skins: " + playerskin ) ; nontropyheadmessage = chatcolor . translatealternatecolorcodes ( '&' , ( getconfig ( ) . getstring ( "non-th-message" , "&ethat is a custom head!" ) ) ) ; logdebug ( "non th message: " + nontropyheadmessage ) ; list < string > pitems = getconfig ( ) . getstringlist ( "items-required" ) ; if ( pitems . isempty ( ) ) { pitems . add ( "any" ) ; pitems . add ( "276" ) ; } items_required . put ( entitytype . player . tostring ( ) , pitems ) ; logdebug ( "player items required: " + items_required . get ( entitytype . player . tostring ( ) ) ) ; for ( string monstername : getconfig ( ) . getconfigurationsection ( "custom-heads" ) . getkeys ( false ) ) { logdebug ( "entity name: " + monstername ) ; string entitytypename ; if ( monstername . equalsignorecase ( "cavespider" ) ) { entitytypename = "cave_spider" ; } else if ( monstername . equalsignorecase ( "golem" ) || monstername . equalsignorecase ( "irongolem" ) ) { entitytypename = "iron_golem" ; } else if ( monstername . equalsignorecase ( "mushroomcow" ) || monstername . equalsignorecase ( "mooshroom" ) ) { entitytypename = "mushroom_cow" ; } else if ( monstername . equalsignorecase ( "pigzombie" ) || monstername . equalsignorecase ( "zombiepigman" ) ) { entitytypename = "pig_zombie" ; } else if ( monstername . equalsignorecase ( "lavaslime" ) || monstername . equalsignorecase ( "magmacube" ) ) { entitytypename = "magma_cube" ; } else if ( monstername . equalsignorecase ( "enderdragon" ) || monstername . equalsignorecase ( "dragon" ) ) { entitytypename = "ender_dragon" ; } else if ( monstername . equalsignorecase ( "elderguardian" ) ) { entitytypename = "elder_guardian" ; } else if ( monstername . equalsignorecase ( "snowman" ) || monstername . equalsignorecase ( "snowgolem" ) ) { entitytypename = "snowman" ; } else if ( monstername . equalsignorecase ( "witherskeleton" ) ) { entitytypename = "wither_skeleton" ; } else { entitytypename = monstername ; } logdebug ( "  type: " + entitytypename ) ; int dropchance = getconfig ( ) . getint ( "custom-heads." + monstername + ".drop-chance" , 0 ) ; list < string > items = getconfig ( ) . getstringlist ( "custom-heads." + monstername + ".items-required" ) ; if ( items . isempty ( ) ) { items . add ( "any" ) ; items . add ( "276" ) ; } string skin = getconfig ( ) . getstring ( "custom-heads." + monstername + ".skin" , "mhf_" + monstername ) ; string message = getconfig ( ) . getstring ( "custom-heads." + monstername + ".message" , "&ethis head once belonged to a &e" + monstername + "&e." ) ; drop_chances . put ( entitytypename , dropchance ) ; logdebug ( "  chance to drop head: " + drop_chances . get ( entitytypename ) + "%" ) ; items_required . put ( entitytypename , items ) ; logdebug ( "  items required: " + items_required . get ( entitytypename ) ) ; custom_skins . put ( entitytypename , skin ) ; logdebug ( "  skin: " + custom_skins . get ( entitytypename ) ) ; skull_messages . put ( entitytypename , message ) ; logdebug ( "  message: " + skull_messages . get ( entitytypename ) ) ; skull_names . put ( entitytypename , monstername ) ; logdebug ( "  name: " + skull_names . get ( monstername ) ) ; } skull_messages . put ( entitytype . player . tostring ( ) , getconfig ( ) . getstring ( "message" ) ) ; renameenabled = getconfig ( ) . getboolean ( "rename-enabled" ) ; if ( renameenabled ) { try { renameitem = material . getmaterial ( getconfig ( ) . getint ( "rename-item" ) ) ; } catch ( exception e ) { renameitem = material . paper ; } logdebug ( "rename recipe enabled: head + " + renameitem . tostring ( ) ) ; } death_types . addall ( getconfig ( ) . getstringlist ( "death-types" ) ) ; info_blacklist . clear ( ) ; for ( string name : getconfig ( ) . getstringlist ( "info-blacklist" ) ) { info_blacklist . add ( name . tolowercase ( ) ) ; logdebug ( "blacklisting: " + name . tolowercase ( ) ) ; } }
tr	10	@ test public void testmergeklists ( ) { mergeklists merge = new mergeklists ( ) ; arraylist < listnode > lists = new arraylist < listnode > ( ) ; listnode test1 = new listnode ( 0 ) ; listnode test2 = new listnode ( 0 ) ; listnode cur1 = test1 , cur2 = test2 ; for ( int i = 0 ; i < 10 ; i ++ ) { cur1 . next = new listnode ( i + 3 ) ; cur1 = cur1 . next ; cur2 . next = new listnode ( i + 5 ) ; cur2 = cur2 . next ; } lists . add ( test1 . next ) ; lists . add ( test2 . next ) ; listnode head = merge . mergeklists ( lists ) ; int lastval = integer . min_value ; for ( listnode node = head ; node != null ; node = node . next ) { asserttrue ( node . val >= lastval ) ; lastval = node . val ; } }
tr	2	public static void main ( final string [ ] args ) { embfilename = "output.txt" ; password = "abc123" ; try { if ( args . length < 1 ) { usage ( ) ; return ; } for ( int i = 0 ; i < args . length ; i ++ ) { if ( ! args [ i ] . startswith ( "-" ) ) { if ( ! args [ i ] . endswith ( ".jpg" ) ) { usage ( ) ; return ; } f = new file ( args [ i ] ) ; continue ; } if ( args . length < i + 1 ) { system . out . println ( "missing parameter for switch " + args [ i ] ) ; usage ( ) ; return ; } if ( args [ i ] . equals ( "-e" ) ) { embfilename = args [ i + 1 ] ; } else if ( args [ i ] . equals ( "-p" ) ) { password = args [ i + 1 ] ; } else { system . out . println ( "unknown switch " + args [ i ] + " ignored." ) ; } i ++ ; } final fileinputstream fis = new fileinputstream ( f ) ; fos = new fileoutputstream ( new file ( embfilename ) ) ; extract ( fis , ( int ) f . length ( ) , fos , password ) ; } catch ( final exception e ) { e . printstacktrace ( ) ; } }
tr	1	public boolean isinchannel ( string channel , string bot ) { for ( user user : getusers ( channel ) ) { if ( bot . equalsignorecase ( "%note" ) && user . getnick ( ) . equalsignorecase ( "kitteh" ) ) { return true ; } if ( bot . equalsignorecase ( "!note" ) && user . getnick ( ) . equalsignorecase ( "benderj2" ) ) { return true ; } if ( bot . equalsignorecase ( ".note" ) ) { if ( user . getnick ( ) . equalsignorecase ( "kitteh" ) || user . getnick ( ) . equalsignorecase ( "benderj2" ) ) { return true ; } } } return false ; }
tr	3	public boolean isborder ( snake snake , keyevent keyevent ) { int sp2x = snake . getx ( ) + 60 ; int sp4y = snake . gety ( ) + 45 ; int sp1x = snake . getx ( ) ; if ( sp2x >= 985 && keyevent . getkeycode ( ) == keyevent . vk_right ) return true ; if ( sp4y > 665 && keyevent . getkeycode ( ) == keyevent . vk_down ) return true ; if ( sp4y <= 35 && keyevent . getkeycode ( ) == keyevent . vk_up ) return true ; if ( sp1x < 0 && keyevent . getkeycode ( ) == keyevent . vk_left ) return true ; return false ; }
tr	4	public static void main ( string args [ ] ) throws exception { systemparam param = new systemparam ( ) ; param . setserver_ip ( "10.1.30.5" ) ; param . setserver_por ( "22" ) ; param . setuser_name ( "weblogic" ) ; param . setpassword ( "weblogic" ) ; xmlencoder encoder = new xmlencoder ( new bufferedoutputstream ( new fileoutputstream ( "sample.xml" ) ) ) ; encoder . writeobject ( param ) ; encoder . close ( ) ; system . out . println ( param ) ; xmldecoder decoder = new xmldecoder ( new bufferedinputstream ( new fileinputstream ( "sample.xml" ) ) ) ; systemparam sample2 = ( systemparam ) decoder . readobject ( ) ; decoder . close ( ) ; system . out . println ( sample2 ) ; }
tr	2	public boolean istieneunprefijo ( atributovo atributovo ) { @ suppresswarnings ( "unchecked" ) list < string > prefijos = ( list < string > ) procesapropiedades . getinstancia ( ) . obtenerconfiguracion ( ) . get ( propiedadesmanager . prefijo_entida ) ; for ( string prefijo : prefijos ) { if ( atributovo . gettipoatributoenti ( ) . startswith ( prefijo ) ) { system . out . println ( prefijo + " == " + atributovo . gettipoatributoenti ( ) + " = " + atributovo . gettipoatributoenti ( ) . startswith ( prefijo ) ) ; return true ; } } return false ; }
tr	7	public void connect ( ) { try { debug . print ( "i'm client<litcomma> start to connect to host:" + host ) ; socket skt = new socket ( host , port ) ; debug . print ( "connected" ) ; rsa rsa = new rsa ( ) ; rsa . setn ( this . n ) ; rsa . sete ( this . e ) ; inputstreamreader isr = new inputstreamreader ( system . in ) ; string publickey = "(" + this . e + " " + this . n + ")" ; system . out . println ( "encoding with" + publickey ) ; while ( true ) { char c = ( char ) isr . read ( ) ; string tosend = "" ; if ( c == '\\n' ) { tosend = "\\n" ; } else { tosend = rsa . getcypher ( c + "" ) ; system . out . println ( c + " is encoded to " + tosend ) ; } for ( int i = 0 ; i < tosend . length ( ) ; i ++ ) { skt . getoutputstream ( ) . write ( tosend . charat ( i ) ) ; } } } catch ( connectexception e ) { system . err . println ( "starter haven't started listening yet!!!\\n please give server input info and run again!!!" ) ; } catch ( ioexception e ) { system . err . println ( "connect error" ) ; e . printstacktrace ( ) ; } }
tr	8	public matrix invertfull ( ) { matrix ret = new matrix ( ) ; float [ ] mat = values ; float [ ] dst = ret . values ; float [ ] tmp = new float [ 12 ] ; float src [ ] = new float [ 16 ] ; float det ; for ( int i = 0 ; i < 4 ; i ++ ) { src [ i ] = mat [ i * 4 ] ; src [ i + 4 ] = mat [ i * 4 + 1 ] ; src [ i + 8 ] = mat [ i * 4 + 2 ] ; src [ i + 12 ] = mat [ i * 4 + 3 ] ; } tmp [ 0 ] = src [ 10 ] * src [ 15 ] ; tmp [ 1 ] = src [ 11 ] * src [ 14 ] ; tmp [ 2 ] = src [ 9 ] * src [ 15 ] ; tmp [ 3 ] = src [ 11 ] * src [ 13 ] ; tmp [ 4 ] = src [ 9 ] * src [ 14 ] ; tmp [ 5 ] = src [ 10 ] * src [ 13 ] ; tmp [ 6 ] = src [ 8 ] * src [ 15 ] ; tmp [ 7 ] = src [ 11 ] * src [ 12 ] ; tmp [ 8 ] = src [ 8 ] * src [ 14 ] ; tmp [ 9 ] = src [ 10 ] * src [ 12 ] ; tmp [ 10 ] = src [ 8 ] * src [ 13 ] ; tmp [ 11 ] = src [ 9 ] * src [ 12 ] ; dst [ 0 ] = tmp [ 0 ] * src [ 5 ] + tmp [ 3 ] * src [ 6 ] + tmp [ 4 ] * src [ 7 ] ; dst [ 0 ] -= tmp [ 1 ] * src [ 5 ] + tmp [ 2 ] * src [ 6 ] + tmp [ 5 ] * src [ 7 ] ; dst [ 1 ] = tmp [ 1 ] * src [ 4 ] + tmp [ 6 ] * src [ 6 ] + tmp [ 9 ] * src [ 7 ] ; dst [ 1 ] -= tmp [ 0 ] * src [ 4 ] + tmp [ 7 ] * src [ 6 ] + tmp [ 8 ] * src [ 7 ] ; dst [ 2 ] = tmp [ 2 ] * src [ 4 ] + tmp [ 7 ] * src [ 5 ] + tmp [ 10 ] * src [ 7 ] ; dst [ 2 ] -= tmp [ 3 ] * src [ 4 ] + tmp [ 6 ] * src [ 5 ] + tmp [ 11 ] * src [ 7 ] ; dst [ 3 ] = tmp [ 5 ] * src [ 4 ] + tmp [ 8 ] * src [ 5 ] + tmp [ 11 ] * src [ 6 ] ; dst [ 3 ] -= tmp [ 4 ] * src [ 4 ] + tmp [ 9 ] * src [ 5 ] + tmp [ 10 ] * src [ 6 ] ; dst [ 4 ] = tmp [ 1 ] * src [ 1 ] + tmp [ 2 ] * src [ 2 ] + tmp [ 5 ] * src [ 3 ] ; dst [ 4 ] -= tmp [ 0 ] * src [ 1 ] + tmp [ 3 ] * src [ 2 ] + tmp [ 4 ] * src [ 3 ] ; dst [ 5 ] = tmp [ 0 ] * src [ 0 ] + tmp [ 7 ] * src [ 2 ] + tmp [ 8 ] * src [ 3 ] ; dst [ 5 ] -= tmp [ 1 ] * src [ 0 ] + tmp [ 6 ] * src [ 2 ] + tmp [ 9 ] * src [ 3 ] ; dst [ 6 ] = tmp [ 3 ] * src [ 0 ] + tmp [ 6 ] * src [ 1 ] + tmp [ 11 ] * src [ 3 ] ; dst [ 6 ] -= tmp [ 2 ] * src [ 0 ] + tmp [ 7 ] * src [ 1 ] + tmp [ 10 ] * src [ 3 ] ; dst [ 7 ] = tmp [ 4 ] * src [ 0 ] + tmp [ 9 ] * src [ 1 ] + tmp [ 10 ] * src [ 2 ] ; dst [ 7 ] -= tmp [ 5 ] * src [ 0 ] + tmp [ 8 ] * src [ 1 ] + tmp [ 11 ] * src [ 2 ] ; tmp [ 0 ] = src [ 2 ] * src [ 7 ] ; tmp [ 1 ] = src [ 3 ] * src [ 6 ] ; tmp [ 2 ] = src [ 1 ] * src [ 7 ] ; tmp [ 3 ] = src [ 3 ] * src [ 5 ] ; tmp [ 4 ] = src [ 1 ] * src [ 6 ] ; tmp [ 5 ] = src [ 2 ] * src [ 5 ] ; tmp [ 6 ] = src [ 0 ] * src [ 7 ] ; tmp [ 7 ] = src [ 3 ] * src [ 4 ] ; tmp [ 8 ] = src [ 0 ] * src [ 6 ] ; tmp [ 9 ] = src [ 2 ] * src [ 4 ] ; tmp [ 10 ] = src [ 0 ] * src [ 5 ] ; tmp [ 11 ] = src [ 1 ] * src [ 4 ] ; dst [ 8 ] = tmp [ 0 ] * src [ 13 ] + tmp [ 3 ] * src [ 14 ] + tmp [ 4 ] * src [ 15 ] ; dst [ 8 ] -= tmp [ 1 ] * src [ 13 ] + tmp [ 2 ] * src [ 14 ] + tmp [ 5 ] * src [ 15 ] ; dst [ 9 ] = tmp [ 1 ] * src [ 12 ] + tmp [ 6 ] * src [ 14 ] + tmp [ 9 ] * src [ 15 ] ; dst [ 9 ] -= tmp [ 0 ] * src [ 12 ] + tmp [ 7 ] * src [ 14 ] + tmp [ 8 ] * src [ 15 ] ; dst [ 10 ] = tmp [ 2 ] * src [ 12 ] + tmp [ 7 ] * src [ 13 ] + tmp [ 10 ] * src [ 15 ] ; dst [ 10 ] -= tmp [ 3 ] * src [ 12 ] + tmp [ 6 ] * src [ 13 ] + tmp [ 11 ] * src [ 15 ] ; dst [ 11 ] = tmp [ 5 ] * src [ 12 ] + tmp [ 8 ] * src [ 13 ] + tmp [ 11 ] * src [ 14 ] ; dst [ 11 ] -= tmp [ 4 ] * src [ 12 ] + tmp [ 9 ] * src [ 13 ] + tmp [ 10 ] * src [ 14 ] ; dst [ 12 ] = tmp [ 2 ] * src [ 10 ] + tmp [ 5 ] * src [ 11 ] + tmp [ 1 ] * src [ 9 ] ; dst [ 12 ] -= tmp [ 4 ] * src [ 11 ] + tmp [ 0 ] * src [ 9 ] + tmp [ 3 ] * src [ 10 ] ; dst [ 13 ] = tmp [ 8 ] * src [ 11 ] + tmp [ 0 ] * src [ 8 ] + tmp [ 7 ] * src [ 10 ] ; dst [ 13 ] -= tmp [ 6 ] * src [ 10 ] + tmp [ 9 ] * src [ 11 ] + tmp [ 1 ] * src [ 8 ] ; dst [ 14 ] = tmp [ 6 ] * src [ 9 ] + tmp [ 11 ] * src [ 11 ] + tmp [ 3 ] * src [ 8 ] ; dst [ 14 ] -= tmp [ 10 ] * src [ 11 ] + tmp [ 2 ] * src [ 8 ] + tmp [ 7 ] * src [ 9 ] ; dst [ 15 ] = tmp [ 10 ] * src [ 10 ] + tmp [ 4 ] * src [ 8 ] + tmp [ 9 ] * src [ 9 ] ; dst [ 15 ] -= tmp [ 8 ] * src [ 9 ] + tmp [ 11 ] * src [ 10 ] + tmp [ 5 ] * src [ 8 ] ; det = src [ 0 ] * dst [ 0 ] + src [ 1 ] * dst [ 1 ] + src [ 2 ] * dst [ 2 ] + src [ 3 ] * dst [ 3 ] ; if ( det == 0.0f ) { throw new runtimeexception ( "singular matrix is not invertible" ) ; } det = 1 / det ; for ( int j = 0 ; j < 16 ; j ++ ) { dst [ j ] *= det ; } return ret ; }
tr	6	@ override public void handle ( ) throws exception { byte pid = in . readbyte ( ) ; if ( ! ( pid == 5 || pid == 7 ) ) { server . error ( string . format ( "%s got wrong packet id: %u02x" , this . getclass ( ) . getsimplename ( ) , pid ) ) ; in . close ( ) ; return ; } if ( pid == 5 ) { in . readlong ( ) ; in . readlong ( ) ; byte version = in . readbyte ( ) ; if ( version != constants . raknet_version ) { packet ipv = new packetincompatibleprotocolversion ( ip , port ) ; ipv . construct ( ) ; ipv . send ( ) ; in . close ( ) ; return ; } short mtu = ( short ) ( data . length - 18 ) ; packet reply = new packetopenconnectionreply ( ip , port ) ; reply . construct ( false , mtu ) ; reply . send ( ) ; } else if ( pid == 7 ) { in . readlong ( ) ; in . readlong ( ) ; in . readbyte ( ) ; in . readint ( ) ; in . readshort ( ) ; short mtu = in . readshort ( ) ; long clientid = in . readlong ( ) ; server . clients . put ( ip . hashcode ( ) + port , new entityplayer ( clientid , ip , port , mtu ) ) ; server . debug ( "adding client from " + ip + ":" + port ) ; server . log ( string . format ( "%016x logged in from %s:%d with mtu %d" , clientid , ip , port , mtu ) ) ; packet reply = new packetopenconnectionreply ( ip , port ) ; reply . construct ( true , ( short ) port , mtu ) ; reply . send ( ) ; } }
tr	8	public static multimap < string , artifactversion > getartifacts ( string artifact , artifactversion version , log log ) { string query = "g:\\"org.webjars\\"" ; if ( artifact != null ) { query += " and a:\\"" + artifact + "\\"" ; } if ( version != null ) { query += " and v:\\"" + version + "\\"" ; } httprequest req = httprequest . get ( "http://search.maven.org/solrsearch/select" , true , "q" , query , "core" , "gav" , "rows" , 5000 , "wt" , "json" ) ; jsonobject json = new gson ( ) . fromjson ( req . body ( ) , jsonobject . class ) ; jsonarray docs = json . getasjsonobject ( "response" ) . getasjsonarray ( "docs" ) ; multimap < string , artifactversion > artifacts = treemultimap . create ( ordering . natural ( ) , new comparator < artifactversion > ( ) { public int compare ( artifactversion version1 , artifactversion version2 ) { return version2 . compareto ( version1 ) ; } } ) ; for ( jsonelement doc : docs ) { jsonobject gav = doc . getasjsonobject ( ) ; string artifactid = gav . get ( "a" ) . getasstring ( ) ; if ( artifactid . startswith ( "webjars-" ) ) { continue ; } artifacts . put ( artifactid , new defaultartifactversion ( gav . get ( "v" ) . getasstring ( ) ) ) ; } if ( artifacts . isempty ( ) ) { reportnowebjarsfound ( artifact , version , log ) ; } return artifacts ; }
tr	4	private void paintgameover ( graphics g ) { g . setcolor ( color . white ) ; g . setfont ( new font ( "helvetica" , font . plain , 48 ) ) ; string gameovertext = "game over" ; rectangle2d gameoverbounds = g . getfontmetrics ( ) . getstringbounds ( gameovertext , g ) ; int startx = ( int ) ( ( width / 2 ) - ( gameoverbounds . getwidth ( ) / 2 ) - 2 ) ; int starty = ( int ) ( ( height / 2 ) + ( gameoverbounds . getheight ( ) / 2 ) - 2 ) ; g . drawstring ( gameovertext , startx , starty ) ; g . setcolor ( color . blue ) ; g . setfont ( new font ( "helvetica" , font . plain , 48 ) ) ; gameoverbounds = g . getfontmetrics ( ) . getstringbounds ( gameovertext , g ) ; startx = ( int ) ( ( width / 2 ) - ( gameoverbounds . getwidth ( ) / 2 ) ) ; starty = ( int ) ( ( height / 2 ) + ( gameoverbounds . getheight ( ) / 2 ) ) ; g . drawstring ( gameovertext , startx , starty ) ; g . setcolor ( color . blue ) ; g . setfont ( new font ( "helvetica" , font . plain , 24 ) ) ; gameovertext = "press enter to restart" ; gameoverbounds = g . getfontmetrics ( ) . getstringbounds ( gameovertext , g ) ; startx = ( int ) ( ( width / 2 ) - ( gameoverbounds . getwidth ( ) / 2 ) ) ; starty = ( int ) ( ( height / 2 ) + ( gameoverbounds . getheight ( ) / 2 ) + 50 ) ; g . drawstring ( gameovertext , startx , starty ) ; }
tr	5	public int largestrectanglearea ( int [ ] height ) { int max = 0 ; if ( height . length == 0 ) return 0 ; int [ ] nh = arrays . copyof ( height , height . length + 1 ) ; nh [ height . length ] = 0 ; stack < integer > large = new stack < integer > ( ) ; for ( int i = 0 ; i < nh . length ; i ++ ) { if ( large . isempty ( ) || nh [ i ] >= nh [ large . peek ( ) ] ) { large . add ( i ) ; } else { while ( ! large . isempty ( ) && ( nh [ large . peek ( ) ] > nh [ i ] || large . peek ( ) == 0 ) ) { int j = large . pop ( ) ; max = math . max ( max , ( large . isempty ( ) ? i : ( i - j ) ) * nh [ j ] ) ; } large . add ( i ) ; } } return max ; }
tr	2	private void handleobjectmovements ( ) { for ( rock rock : rocks ) { rock . advancey ( direction . down ) ; } for ( bullet bullet : bullets ) { bullet . advancey ( direction . up ) ; } if ( moveup ) { ship . advancey ( gameobject . direction . up ) ; } if ( movedown ) { ship . advancey ( gameobject . direction . down ) ; } if ( moveleft ) { ship . advancex ( gameobject . direction . left ) ; } if ( moveright ) { ship . advancex ( gameobject . direction . right ) ; } }
tr	10	public final group creategameboard ( ) { flow = new timeline ( ) ; group group = new group ( ) ; image image = new image ( getclass ( ) . getresourceasstream ( "socialite.jpg" ) ) ; int colcount = ( int ) ( image . getwidth ( ) / slidingpuzzlepiece . getpuzzlesize ( ) ) ; int rowcount = ( int ) ( image . getheight ( ) / slidingpuzzlepiece . getpuzzlesize ( ) ) ; gameboard = new slidingpuzzleboard ( colcount , rowcount ) ; for ( int col = 0 ; col < colcount ; col ++ ) { for ( int row = 0 ; row < rowcount ; row ++ ) { int rootx = col * slidingpuzzlepiece . getpuzzlesize ( ) ; int rooty = row * slidingpuzzlepiece . getpuzzlesize ( ) ; new slidingpuzzlepiece ( image , rootx , rooty , gameboard . getwidth ( ) , gameboard . getheight ( ) , new slidingpuzzlefield ( col , row , rootx , rooty ) ) ; } } gameboard . getchildren ( ) . addall ( slidingpuzzlepiece . getpuzzlepiece ( ) ) ; resetgameboard ( ) ; mergepuzzlepieces ( gameboard , slidingpuzzlepiece . getpuzzlepiece ( ) ) ; hideonefield ( ) ; activatefields ( ) ; final int i10 = 10 ; vbox displayfield = new vbox ( i10 ) ; displayfield . setpadding ( new insets ( i10 , i10 , i10 , i10 ) ) ; displayfield . getchildren ( ) . addall ( createmenu ( ) , gameboard ) ; group . getchildren ( ) . addall ( displayfield ) ; return group ; }
tr	6	public string getfromto ( ) { string fmonth = integer . tostring ( this . monthbox . getselectedindex ( ) + 1 ) ; string fday = this . daybox . getselecteditem ( ) . tostring ( ) ; string fyear = this . yearbox . getselecteditem ( ) . tostring ( ) ; string tmonth = integer . tostring ( this . monthboxto . getselectedindex ( ) + 1 ) ; string tday = this . dayboxto . getselecteditem ( ) . tostring ( ) ; string tyear = this . yearboxto . getselecteditem ( ) . tostring ( ) ; return fmonth + "/" + fday + "/" + fyear + " - " + tmonth + "/" + tday + "/" + tyear ; }
tr	10	protected void processrequest ( httpservletrequest request , httpservletresponse response ) throws servletexception , ioexception { response . setcontenttype ( "text/html;charset=utf-8" ) ; boolean injectionprotection = false ; string writein = request . getparameter ( "writein" ) ; connection con = ( connection ) getservletcontext ( ) . getattribute ( "dbconnection" ) ; httpsession session = request . getsession ( ) ; user user = ( user ) session . getattribute ( "user" ) ; try { if ( injectionprotection ) { preparedstatement ps = con . preparestatement ( "update candidates set num_votes=num_votes + 1 where name=?" ) ; ps . setstring ( 1 , writein ) ; int updates = ps . executeupdate ( ) ; ps . close ( ) ; if ( updates < 1 ) { ps = con . preparestatement ( "insert into candidates (id<litcomma> name<litcomma> num_votes) values (?<litcomma>?<litcomma>1)" ) ; ps . setstring ( 1 , writein ) ; ps . setstring ( 2 , writein ) ; int updates2 = ps . executeupdate ( ) ; } ps = con . preparestatement ( "update users set voted=true where name=?" ) ; ps . setstring ( 1 , user . getname ( ) ) ; ps . executeupdate ( ) ; ps . close ( ) ; } else { statement stmt = con . createstatement ( ) ; string query = "update candidates set num_votes=num_votes + 1 where name=\\"" + writein + "\\"" ; int updates = stmt . executeupdate ( query ) ; stmt . close ( ) ; if ( updates < 1 ) { stmt = con . createstatement ( ) ; query = "insert into candidates (id<litcomma> name<litcomma> num_votes) values (\\"" + writein + "\\"<litcomma>\\"" + writein + "\\"<litcomma>1)" ; int updates2 = stmt . executeupdate ( query ) ; stmt . close ( ) ; } } } catch ( exception e ) { e . printstacktrace ( ) ; throw new servletexception ( "sql error" ) ; } finally { response . sendredirect ( "voted.jsp" ) ; } }
tr	7	public list < fieldmetadatadto > readfromexcel ( string file , string sheet ) { list < fieldmetadatadto > lfmd = new arraylist < fieldmetadatadto > ( ) ; try { fileinputstream fileinputstream = new fileinputstream ( file ) ; hssfworkbook workbook = new hssfworkbook ( fileinputstream ) ; hssfsheet worksheet = workbook . getsheet ( sheet ) ; iterator < ? > rows = worksheet . rowiterator ( ) ; int x = 0 ; while ( rows . hasnext ( ) ) { hssfrow row = ( hssfrow ) rows . next ( ) ; if ( x != 0 ) { lfmd . add ( getmetadata ( row ) ) ; } x ++ ; } } catch ( filenotfoundexception e ) { e . printstacktrace ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } return lfmd ; }
tr	10	private hashmap < string , hashset < string > > scramble ( string s ) { hashmap < string , hashset < string > > res = new hashmap < string , hashset < string > > ( ) ; if ( s . length ( ) == 0 ) return res ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { string curr = s . substring ( i , i + 1 ) ; if ( ! res . containskey ( curr ) ) { hashset < string > path = new hashset < string > ( ) ; path . add ( curr ) ; res . put ( curr , path ) ; } } for ( int x = 2 ; x <= s . length ( ) ; x ++ ) { for ( int i = 0 ; i <= s . length ( ) - x ; i ++ ) { string curr = s . substring ( i , i + x ) ; if ( ! res . containskey ( curr ) ) { hashset < string > path = new hashset < string > ( ) ; for ( int k = 1 ; k < curr . length ( ) ; k ++ ) { hashset < string > left = res . get ( curr . substring ( 0 , k ) ) ; hashset < string > right = res . get ( curr . substring ( k , curr . length ( ) ) ) ; for ( string l : left ) { for ( string r : right ) { if ( ! path . contains ( l + r ) ) path . add ( l + r ) ; if ( ! path . contains ( r + l ) ) path . add ( r + l ) ; } } } res . put ( curr , path ) ; } } } return res ; }
tr	1	@ override public void writefield ( field field , object parent ) throws illegalargumentexception , illegalaccessexception { if ( stream . endswith ( "{" ) != true ) { stream += def_separator ; } stream += field . getname ( ) + internal_separator ; if ( field . gettype ( ) == int . class ) { stream += field . getint ( parent ) ; } else if ( field . gettype ( ) == long . class ) { stream += field . getlong ( parent ) ; } else if ( field . gettype ( ) == double . class ) { stream += field . getdouble ( parent ) ; } else if ( field . gettype ( ) == float . class ) { stream += field . getfloat ( parent ) ; } else if ( field . gettype ( ) == boolean . class ) { if ( field . getboolean ( parent ) == true ) { stream += true ; } else { stream += false ; } } else if ( field . gettype ( ) == integer . class ) { integer value = ( integer ) field . get ( parent ) ; if ( value == null ) { stream += null ; } else { stream += value ; } } else if ( field . gettype ( ) == double . class ) { double value = ( double ) field . get ( parent ) ; if ( value == null ) { stream += null ; } else { stream += value ; } } else if ( field . gettype ( ) == boolean . class ) { boolean value = ( boolean ) field . get ( parent ) ; if ( value == null ) { stream += null ; } else { stream += value ; } } else if ( field . gettype ( ) == long . class ) { long value = ( long ) field . get ( parent ) ; if ( value == null ) { stream += null ; } else { stream += value ; } } else if ( field . gettype ( ) == float . class ) { float value = ( float ) field . get ( parent ) ; if ( value == null ) { stream += null ; } else { stream += value ; } } else if ( field . gettype ( ) == string . class ) { string value = ( string ) field . get ( parent ) ; if ( value == null ) { stream += null ; } else { stream += quote + value + quote ; } } }
tr	2	@ override public iterator < pair < f , s > > iterator ( ) { return new iterator < pair < f , s > > ( ) { private iterator < entry < f , s > > iterator = list . iterator ( ) ; @ override public boolean hasnext ( ) { return iterator . hasnext ( ) ; } @ override public pair < f , s > next ( ) { entry entry = iterator . next ( ) ; return new pair < f , s > ( ( f ) entry . first , ( s ) entry . second ) ; } @ override public void remove ( ) { iterator . remove ( ) ; } } ; }
tr	6	private static double computedcg ( list < integer > urls , list < integer > googleorder , int noofentries ) { double gain = 0 ; double logtwo = math . log ( 2 ) ; int rank = 0 ; for ( int i = 0 ; i < noofentries ; i ++ ) { integer item = googleorder . get ( i ) ; integer val = urls . get ( item - 1 ) ; rank ++ ; if ( rank < 2 ) { gain += val ; } else { gain += val * logtwo / math . log ( rank ) ; } } return gain ; }
tr	7	public void appendnextround ( round round ) { round nextround = new round ( ) ; rounds . add ( nextround ) ; int roundnumber = rounds . indexof ( nextround ) ; int gamecount = 0 ; for ( int i = 0 ; i < round . size ( ) ; i += 2 ) { game newgame = new game ( ) ; newgame . referee = scoreable ; game [ ] previousgames = new game [ ] { round . get ( i ) , round . get ( i + 1 ) } ; for ( game previousgame : previousgames ) previousgame . nextgame = newgame ; newgame . previousgames = previousgames ; newgame . name = string . format ( "r%d g%d" , roundnumber , gamecount ) ; nextround . add ( newgame ) ; gamecount ++ ; } if ( nextround . size ( ) == 1 ) return ; appendnextround ( nextround ) ; }
tr	9	public pdgui ( ) { main = new jframe ( "plagerism detector" ) ; box biggest = box . createverticalbox ( ) ; box db = box . createhorizontalbox ( ) ; box s = box . createhorizontalbox ( ) ; dbbut . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent e ) { jfilechooser fc = new jfilechooser ( ) ; fc . setfileselectionmode ( jfilechooser . directories_only ) ; int returnval = fc . showopendialog ( null ) ; if ( returnval == jfilechooser . approve_option ) { dbfield . settext ( "" + fc . getselectedfile ( ) . getabsolutepath ( ) ) ; } } } ) ; sbut . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent e ) { jfilechooser fc = new jfilechooser ( ) ; fc . setfileselectionmode ( jfilechooser . directories_only ) ; int returnval = fc . showopendialog ( null ) ; if ( returnval == jfilechooser . approve_option ) { sfield . settext ( "" + fc . getselectedfile ( ) . getabsolutepath ( ) ) ; } } } ) ; go . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent e ) { arraylist < string > urlstotest = new arraylist < > ( ) ; urlstotest = bigmain . getallmidi ( "/users/admin/music/miditestfiles" ) ; arraylist < string > urlstoad = new arraylist < > ( ) ; urlstoad = bigmain . getallmidi ( "/users/admin/music/mididatabase" ) ; mididatabase md = new mididatabase ( ) ; for ( string s : urlstoad ) { if ( ! urlstotest . contains ( s ) ) { try { md . add ( s ) ; } catch ( exception ex ) { ex . printstacktrace ( ) ; } } } for ( string t : urlstotest ) { md . checkagainstdatabase ( new midisong ( t ) ) ; } } } ) ; db . add ( dbfield ) ; db . add ( dbbut ) ; s . add ( sfield ) ; s . add ( sbut ) ; biggest . add ( db ) ; biggest . add ( s ) ; biggest . add ( go ) ; main . add ( biggest ) ; main . pack ( ) ; main . setvisible ( true ) ; }
tr	4	@ suppresswarnings ( "rawtypes" ) private list < class > buscarclasesendirectorio ( file directory , string packagename ) throws classnotfoundexception { string fixpath = directory . getabsolutepath ( ) . replace ( "%20" , " " ) ; logger . info ( "fixpath : " + fixpath ) ; directory = new file ( fixpath ) ; logger . info ( "directory : " + directory . getabsolutepath ( ) ) ; logger . info ( "packagename : " + packagename ) ; list < class > classes = new arraylist < class > ( ) ; if ( ! directory . exists ( ) ) { logger . info ( "directory.exists() : " + directory . exists ( ) ) ; return classes ; } file [ ] files = directory . listfiles ( ) ; for ( file file : files ) { if ( file . isdirectory ( ) ) { assert ! file . getname ( ) . contains ( "." ) ; classes . addall ( buscarclasesendirectorio ( file , packagename + "." + file . getname ( ) ) ) ; } else if ( file . getname ( ) . endswith ( ".class" ) ) { classes . add ( class . forname ( packagename + '.' + file . getname ( ) . substring ( 0 , file . getname ( ) . length ( ) - 6 ) ) ) ; } } return classes ; }
tr	3	public static void main ( string [ ] args ) { scanner scanner = new scanner ( system . in ) ; system . out . println ( "ingrese un d\xeda de la semana (n\xfamero): " ) ; int v = scanner . nextint ( ) ; string dia ; switch ( v ) { case 1 : dia = "lunes" ; break ; case 2 : dia = "martes" ; break ; case 3 : dia = "miercoles" ; break ; case 4 : dia = "jueves" ; break ; case 5 : dia = "viernes" ; break ; case 6 : dia = "s\xe1bado" ; break ; case 7 : dia = "domingo" ; break ; default : dia = "d\xeda incorrecto... el valor debe ser entre 1 y 7" ; } system . out . println ( dia ) ; }
tr	3	private void handleconnect ( string str , serverclient client ) { int clientid = addclient ( client ) ; if ( clientid == - 1 ) { string full = error + "sorry the current server is full/e/" ; send ( full . getbytes ( ) , client ) ; } else { system . out . println ( "the user " + client . getname ( ) + " connected" ) ; string welcome = connect + "welcome " + client . getname ( ) + "/c/" + clientid + "/i/" ; send ( welcome . getbytes ( ) , client ) ; sendtoall ( message + "user " + client . getname ( ) + " connected/m/" ) ; } }
tr	3	public string tostring ( ) { string output ; output = " -------------------\\n" ; for ( int cx = 0 ; cx < 6 ; cx ++ ) { output += 6 - cx ; output += "|" ; for ( int cy = 0 ; cy < 6 ; cy ++ ) { if ( board [ cx ] [ cy ] == null ) { output += "  |" ; } else { output += board [ cx ] [ cy ] . tostring ( ) + "|" ; } } output += "\\n" ; output += " -------------------\\n" ; } output += "  a  b  c  d  e  f\\n" ; return output ; }
tr	3	private void expand ( ) { int i ; if ( iscompact ) { byte [ ] temparray ; hashes = new int [ indexcount ] ; temparray = new byte [ unicodecount ] ; for ( i = 0 ; i < unicodecount ; ++ i ) { byte value = elementat ( ( char ) i ) ; temparray [ i ] = value ; touchblock ( i > > blockshift , value ) ; } for ( i = 0 ; i < indexcount ; ++ i ) { indices [ i ] = ( char ) ( i << blockshift ) ; } values = null ; values = temparray ; iscompact = false ; } }
tr	9	public void actionperformed ( actionevent arg0 ) { string rootpath = tfrootdirectory . gettext ( ) ; string filetype = tffiletypes . gettext ( ) ; string [ ] extensions = filetype . split ( ";" ) ; int numberoffiles = integer . parseint ( tfnumbeoffiles . gettext ( ) ) ; long maxfilesize = long . parselong ( tffilesize . gettext ( ) ) ; long maxid = long . parselong ( tfmaxid . gettext ( ) ) ; long minid = long . parselong ( tfminid . gettext ( ) ) ; configurations configurations = new configurations ( rootpath , extensions , numberoffiles , maxfilesize , minid , maxid , chckbxyes . isselected ( ) ) ; dispose ( ) ; serverrunningframe serverrunningframe = new serverrunningframe ( configurations ) ; }
tr	9	public void updatestoragepiece ( ) { emptystoragesidegridsegment ( ) ; tetrimino storedtetrimino = mboard . getstoredtetrimino ( ) ; if ( storedtetrimino != null ) { int tetriminoheight = storedtetrimino . getshape ( ) . getheight ( ) , tetriminowidth = storedtetrimino . getshape ( ) . getwidth ( ) ; int row = msidegrid . length - ( msectionheight + tetriminoheight ) / 2 , col = ( msidegrid [ 0 ] . length - tetriminowidth ) / 2 ; int tetriminoid = storedtetrimino . getid ( ) ; tetrimino dummytetrimino = new tetrimino ( storedtetrimino . getshape ( ) , tetriminoid , new int [ ] { row , col } ) ; int [ ] [ ] coordinates = dummytetrimino . getcoordinates ( ) ; for ( int [ ] coord : coordinates ) { msidegrid [ coord [ 0 ] ] [ coord [ 1 ] ] = tetriminoid ; } } repaint ( ) ; }
tr	5	@ override public void keypressed ( keyevent e ) { if ( e . getkeycode ( ) == keyevent . vk_f1 ) { cadastrarentrada entrada = new cadastrarentrada ( ) ; } else if ( e . getkeycode ( ) == keyevent . vk_f2 ) { cadastrarsaida saida = new cadastrarsaida ( ) ; } else if ( e . getkeycode ( ) == keyevent . vk_f3 ) { listarplacasestacionadas listar = new listarplacasestacionadas ( ) ; } else if ( e . getkeycode ( ) == keyevent . vk_f12 ) { encerraraplicacao encerrar = new encerraraplicacao ( ) ; } else if ( e . getkeycode ( ) == keyevent . vk_f11 ) { sobre sobre = new sobre ( ) ; } }
tr	2	protected void popcontextesifneeded ( ) { if ( popcontextonnextpausecounter > 1 ) { log . debug ( "there are {} to pop from the stack" , popcontextonnextpausecounter ) ; } for ( int i = 0 ; i < popcontextonnextpausecounter ; i ++ ) { if ( ! contextes . isempty ( ) ) { conversationcontext < ? > ccpopped = contextes . pop ( ) ; log . debug ( "popped 1 context from stack: {}" , ccpopped . getlabel ( ) ) ; } else { log . warn ( "attention<litcomma> too many pop requested! could be source of potential bug" ) ; } } popcontextonnextpausecounter = 0 ; if ( contextes . isempty ( ) ) { log . info ( "all contextes have been popped. natural conversation ending will be performed" ) ; } }
tr	2	private void update ( int cycles ) { if ( cycles < 0 ) { while ( true ) { scape . step ( ) ; addinfo ( scape . grid [ scape . mainpanel . xselected ] [ scape . mainpanel . yselected ] ) ; scape . epochs ++ ; string ep = "epochs:  " + scape . epochs ; epochslabel . settext ( ep ) ; } } else { for ( int c = 0 ; c < cycles ; c ++ ) { scape . step ( ) ; addinfo ( scape . grid [ scape . mainpanel . xselected ] [ scape . mainpanel . yselected ] ) ; scape . epochs ++ ; string ep = "epochs:  " + scape . epochs ; epochslabel . settext ( ep ) ; scape . mainpanel . update ( ) ; } } }
tr	9	public list < list < string > > read ( ) { sheet [ ] sheets = excel . getsheets ( ) ; list < list < string > > result = new arraylist < list < string > > ( ) ; for ( sheet sheet : sheets ) { int rows = sheet . getrows ( ) ; int columns = sheet . getcolumns ( ) ; for ( int i = 1 ; i < rows ; i ++ ) { list < string > list = new arraylist < string > ( ) ; for ( int j = 0 ; j < columns ; j ++ ) { string content = sheet . getcell ( j , i ) . getcontents ( ) ; list . add ( content ) ; } result . add ( list ) ; } } return result ; }
tr	7	public arraylist < string > anagrams ( string [ ] strs ) { hashmap < string , arraylist < string > > res = new hashmap < string , arraylist < string > > ( ) ; arraylist < string > result = new arraylist < string > ( ) ; for ( string str : strs ) { string s = str . replace ( " " , "" ) ; char [ ] arr = s . tochararray ( ) ; arrays . sort ( arr ) ; s = arrays . tostring ( arr ) ; if ( res . containskey ( s ) ) { arraylist < string > t = res . get ( s ) ; t . add ( str ) ; } else { arraylist < string > t = new arraylist < string > ( ) ; t . add ( str ) ; res . put ( s , t ) ; } } for ( string key : res . keyset ( ) ) { if ( res . get ( key ) . size ( ) > 1 ) result . addall ( res . get ( key ) ) ; } return result ; }
tr	4	public static void readtaglinksfile ( ) throws ioexception { string [ ] reader = papplet . loadstrings ( tag_links_file ) ; for ( int i = 1 ; i < reader . length ; i ++ ) { string [ ] nextline = reader [ i ] . replace ( "\\"" , "" ) . split ( "<litcomma>" ) ; int key = integer . valueof ( nextline [ 0 ] ) ; if ( taglinks . containskey ( key ) ) { taglinks . put ( integer . valueof ( nextline [ 0 ] ) , taglinks . get ( integer . valueof ( nextline [ 0 ] ) ) + "<litcomma>" + nextline [ 1 ] ) ; } else { taglinks . put ( integer . valueof ( nextline [ 0 ] ) , nextline [ 1 ] ) ; } } }
tr	10	public void main ( ) throws ioexception { string s ; setq setq = new setq ( ) ; defun defun = new defun ( ) ; boolean defunflag = false ; int index = 0 ; do { bufferedreader input = new bufferedreader ( new inputstreamreader ( system . in ) ) ; s = input . readline ( ) ; if ( s . isempty ( ) ) break ; tokenizer tn = new tokenizer ( s ) ; tn . lanalysis ( ) ; parser p = new parser ( tn . listcode ) ; p . sanalysis ( p . cell , 0 ) ; evaluator evaluator = new evaluator ( ) ; string eval = evaluator . eval ( p . cell , setq , index , defun , defunflag ) ; index = evaluator . index ; system . out . println ( eval ) ; } while ( true ) ; }
tr	7	public static void main ( string [ ] args ) throws ioexception , interruptedexception { crawlercontext context = new crawlercontext ( ) ; context . submittask ( new processabc ( "http://www.nhl.com/ice/playersearch.htm" ) ) ; long starttime = system . currenttimemillis ( ) ; int numberofthreads = 80 ; list < thread > workerthreads = new arraylist < thread > ( ) ; for ( int i = 0 ; i < numberofthreads ; ++ i ) { thread thread = new thread ( new workerrunnable ( context ) ) ; thread . start ( ) ; workerthreads . add ( thread ) ; } for ( thread thread : workerthreads ) { thread . join ( ) ; } long duration = system . currenttimemillis ( ) - starttime ; system . out . printf ( "finished in %d seconds\\n" , duration / 1000 ) ; }
tr	4	public string mahdollisetyhdistelmattostring ( ) { string s = "" ; arraylist < yhdistelma > y = mahdollisetyhdistelmat ( ) ; int ind = y . size ( ) ; for ( int i = 0 ; i < y . size ( ) ; i ++ ) { s = s + ( i + 1 ) + " - " + y . get ( i ) . getnimi ( ) + ": " + y . get ( i ) . getpisteet ( ) + "p" + "\\n" ; if ( i == y . size ( ) - 1 ) { s = s + "---------------------yliviivaa---------------------" + "\\n" ; } } y = yliviivattavat ( ) ; for ( int i = 0 ; i < y . size ( ) ; i ++ ) { s = s + ( ind + i + 1 ) + " - " + y . get ( i ) . getnimi ( ) + ": " + y . get ( i ) . getpisteet ( ) + "p" + "\\n" ; } return s ; }
tr	9	@ override public void actionperformed ( actionevent e ) { console . setforeground ( color . green ) ; if ( e . getsource ( ) == inputbutton ) { int returnval = fc . showopendialog ( cards ) ; if ( returnval == jfilechooser . approve_option ) { file file = fc . getselectedfile ( ) ; input = file . getabsolutepath ( ) ; console . append ( "input: " + input + "\\n" ) ; } } else if ( e . getsource ( ) == executebutton ) { console . settext ( "" ) ; boolean valinput = false ; if ( input != null ) valinput = true ; boolean valoutput = false ; if ( output != null ) valoutput = true ; boolean valcolsep = false ; if ( separator . gettext ( ) != null ) valcolsep = true ; boolean valmanu = false ; if ( manufacturer . gettext ( ) != null && manufacturer . gettext ( ) . length ( ) > 1 ) valmanu = true ; boolean valcounter = false ; if ( counter . gettext ( ) != null ) { valcounter = true ; try { integer . valueof ( counter . gettext ( ) ) ; } catch ( exception nfe ) { valcounter = false ; } } boolean valinterval = false ; if ( interval . gettext ( ) != null ) { valinterval = true ; try { integer . valueof ( interval . gettext ( ) ) ; } catch ( exception nfe ) { valinterval = false ; } } boolean vallen = false ; if ( resplen . gettext ( ) != null ) { vallen = true ; try { integer . valueof ( resplen . gettext ( ) ) ; } catch ( exception nfe ) { vallen = false ; } } if ( ! valinput ) console . append ( "invalid input file path!\\n" ) ; if ( ! valoutput ) console . append ( "invalid output file path!\\n" ) ; if ( ! valcolsep ) console . append ( "invalid column separator!\\n" ) ; if ( ! valmanu ) console . append ( "invalid manufacturer name!\\n" ) ; if ( ! valcounter ) console . append ( "invalid counter!\\n" ) ; if ( ! valinterval ) console . append ( "invalid interval!\\n" ) ; if ( ! vallen ) console . append ( "invalid response length!\\n" ) ; if ( valinput && valoutput && valcolsep && valmanu && valcounter && valinterval && vallen ) { setcontrols ( done ) ; task = new task ( ) ; task . addpropertychangelistener ( this ) ; task . execute ( ) ; } } else if ( e . getsource ( ) == outputbutton ) { int returnval = dc . showopendialog ( cards ) ; if ( returnval == jfilechooser . approve_option ) { file file = dc . getselectedfile ( ) ; output = file . getpath ( ) ; console . append ( "output: " + output + "\\n" ) ; } } }
tr	1	public void osvjezistranicu ( ) { stringbuilder sss ; setchanged ( ) ; notifyobservers ( "novi interval!!!!!!" ) ; sb = rp . dohvatisadrzaj ( pocetnilink ) ; imedatoteke = rp . dohvatiimedatoteke ( pocetnilink ) ; sss = dohvatisadrzajdatoteke ( imedatoteke ) ; if ( sss != null ) { webstranica . setsadrzaj ( sss ) ; } else { if ( ztintor_zadaca_4 . ser ) { setogranicenje ( getogranicenje ( ) - 1 ) ; } ru . dohvatiresurs ( pocetnilink , rp , this ) ; dohvatilistupoveznica ( ) ; } res = update ( sb , imedatoteke ) ; setwebstranica ( res ) ; dohvatilistupoveznica ( ) ; }
tr	6	private static void countseparators ( string record ) { boolean isunquoted = true ; for ( int i = 0 ; i < record . length ( ) ; i ++ ) { if ( record . charat ( i ) == '"' ) isunquoted = ! isunquoted ; if ( isunquoted ) { object [ ] keys = separators . keyset ( ) . toarray ( ) ; for ( int j = 0 ; j < keys . length ; j ++ ) { string key = ( string ) keys [ j ] ; if ( record . substring ( i , i + 1 ) . equals ( key ) ) { int [ ] counts = ( int [ ] ) separators . get ( key ) ; counts [ 0 ] ++ ; break ; } } } } }
tr	5	public void download ( jprogressbar | , file destination ) { thread t = new thread ( ( ) -> { int downloaded = 0 ; list < imgurimage > images = getimages ( ) ; for ( imgurimage i : images ) { i . download ( destination ) ; downloaded ++ ; int perc = ( int ) ( ( ( ( double ) downloaded ) / images . size ( ) ) * 100 ) ; | . setvalue ( perc ) ; if ( perc == 100 ) gui . get ( ) . notifyfinished ( ) ; } } ) ; t . start ( ) ; }
tr	3	@ override public string [ ] classify ( dataset test ) { string [ ] classification = new string [ test . instances . size ( ) ] ; for ( int i = 0 ; i < test . instances . size ( ) ; i ++ ) { instance example = test . instances . get ( i ) ; if ( root instanceof internaldectreenode ) { classification [ i ] = ( ( internaldectreenode ) root ) . classify ( example ) ; } else { classification [ i ] = root . label ; } } return classification ; }
tr	9	public void createtextfile ( map < integer , map < integer , string > > xxx ) { set < map . entry < integer , map < integer , string > > > s = xxx . entryset ( ) ; iterator < map . entry < integer , map < integer , string > > > i = s . iterator ( ) ; while ( i . hasnext ( ) ) { map . entry < integer , map < integer , string > > recordperrow = ( entry < integer , map < integer , string > > ) i . next ( ) ; int key = recordperrow . getkey ( ) ; map < integer , string > y = recordperrow . getvalue ( ) ; set < map . entry < integer , string > > ss = y . entryset ( ) ; iterator < map . entry < integer , string > > ii = ss . iterator ( ) ; stringbuilder sb = new stringbuilder ( ) ; sb . append ( "=== handoff file testing === \\n" ) ; sb . append ( "total record: " + xxx . size ( ) + " \\n" ) ; sb . append ( "field name               \\t\\t\\tlength\\t\\tvalue\\n" ) ; sb . append ( "-------------------------------------------------------------------------------------\\n" ) ; while ( ii . hasnext ( ) ) { map . entry < integer , string > rowvalue = ii . next ( ) ; log . debug ( "parent key : " + key + "  key : " + rowvalue . getkey ( ) + " value : " + rowvalue . getvalue ( ) ) ; sb . append ( rowvalue . getvalue ( ) ) ; sb . append ( '\\n' ) ; } createnow ( recordperrow . getkey ( ) , sb . tostring ( ) ) ; } }
tr	5	public static void main ( string [ ] arguments ) { baby david = new baby ( ) ; david . name = "david" ; david . setmale ( true ) ; david . weight = 3.0 ; david . decibels = 100 ; david . poop ( ) ; david . setage ( 2 ) ; system . out . println ( "the baby name is " + david . name ) ; toys toy = new dolls ( "barbie" ) ; cars newcar = new cars ( "masina de politie" ) ; dolls babydoll = new dolls ( null ) ; ihasbattery acar = new cars ( "bmw" ) ; try { ( ( ihasbattery ) toy ) . works ( "ana" ) ; } catch ( batteryexception e ) { system . out . println ( "exception : " + e . getmessage ( ) ) ; } newcar . setbattery ( "masina de politie" ) ; try { newcar . works ( "masina de politie" ) ; } catch ( exception e ) { system . out . println ( "exception : " + e . getmessage ( ) ) ; } try { babydoll . works ( null ) ; } catch ( exception e ) { system . out . println ( "exception : " + e . getmessage ( ) ) ; } try { acar . works ( "bmw" ) ; } catch ( batteryexception e ) { system . out . println ( "exception : " + e . getmessage ( ) ) ; } }
tr	5	private void createtestdata ( ) throws exception { final parent parent = new parent ( ) ; parent . setname ( "parent" ) ; final child child1 = new child ( ) ; child1 . setname ( "child1" ) ; parent . addchild ( child1 ) ; final child child2 = new child ( ) ; child2 . setname ( "child2" ) ; parent . addchild ( child2 ) ; final child child3 = new child ( ) ; child3 . setname ( "child3" ) ; parent . addchild ( child3 ) ; final child child4 = new child ( ) ; child4 . setname ( "child4" ) ; parent . addchild ( child4 ) ; em . gettransaction ( ) . begin ( ) ; em . persist ( parent ) ; em . gettransaction ( ) . commit ( ) ; }
tr	6	public void recovertree ( treenode root ) { stack < treenode > a = new stack < treenode > ( ) ; treenode p = root ; treenode lastnode = null , first = null , second = null ; while ( ! a . isempty ( ) || p != null ) { if ( p == null ) { p = a . pop ( ) ; if ( lastnode != null && p . val < lastnode . val ) { if ( first == null ) { first = lastnode ; second = p ; } else second = p ; } lastnode = p ; p = p . right ; } else { a . add ( p ) ; p = p . left ; } } int t = first . val ; first . val = second . val ; second . val = t ; }
tr	4	private void sendpacket ( byte id , object ... data ) throws ioexception { bytearrayoutputstream bo = new bytearrayoutputstream ( ) ; dataoutputstream out = new dataoutputstream ( bo ) ; out . write ( id ) ; for ( object o : data ) { if ( o == null ) throw new ioexception ( "object is null" ) ; if ( o instanceof string ) utils . writestring ( ( string ) o , out ) ; else if ( o instanceof byte ) out . writelong ( ( byte ) o ) ; else if ( o instanceof short ) out . writeshort ( ( short ) o ) ; else if ( o instanceof integer ) out . writeint ( ( integer ) o ) ; else if ( o instanceof long ) out . writelong ( ( long ) o ) ; else if ( o instanceof float ) out . writefloat ( ( float ) o ) ; else if ( o instanceof double ) out . writedouble ( ( double ) o ) ; else if ( o instanceof character ) out . writechar ( ( character ) o ) ; else if ( o instanceof byte [ ] ) out . write ( ( byte [ ] ) o ) ; else throw new ioexception ( "invalid type " + o . getclass ( ) . getname ( ) ) ; } packetpayload p = new packetpayload ( ip , port ) ; p . construct ( count ++ , bo . tobytearray ( ) ) ; p . send ( ) ; }
tr	3	public void connect ( treelinknode root ) { if ( root == null ) return ; treelinknode cur = root ; treelinknode prev = null ; treelinknode leftmost = null ; while ( cur != null ) { if ( cur . left != null ) { if ( prev != null ) prev . next = cur . left ; prev = cur . left ; if ( leftmost == null ) leftmost = cur . left ; } if ( cur . right != null ) { if ( prev != null ) prev . next = cur . right ; prev = cur . right ; if ( leftmost == null ) leftmost = cur . right ; } cur = cur . next ; } connect ( leftmost ) ; }
tr	6	@ override public void federatebody ( ) throws rtiexception { int intzmianapasa = rti . getinteractionclasshandle ( constants . interkacja_zmiana_pasa ) ; rti . publishinteractionclass ( intzmianapasa ) ; advancetime ( 5.0 ) ; int intakcjasamolotu = rti . getinteractionclasshandle ( constants . interkacja_akcja_samolotu ) ; rti . subscribeinteractionclass ( intakcjasamolotu ) ; int passtartowyhandle = rti . getobjectclasshandle ( constants . obiekt_pas_startowy ) ; int samolothandle = rti . getattributehandle ( "samolot" , passtartowyhandle ) ; attributehandleset attributes = rtifactoryfactory . getrtifactory ( ) . createattributehandleset ( ) ; attributes . add ( samolothandle ) ; rti . subscribeobjectclassattributes ( passtartowyhandle , attributes ) ; while ( ! wiezakontrolna . done || ! samolot . done || ! passtartowy . done ) { if ( ( ( wiezakontrolnaambasador ) ambasador ) . getliczbaobsluzonychsamolotow ( ) >= params . liczba_samolotow_do_wygenerowania ) { if ( ! done ) { wpuscsamolotnapas ( - 1 ) ; } done = true ; } integer samolotdowpuszczenia = ( ( wiezakontrolnaambasador ) ambasador ) . getsamolotdowpuszczenianapas ( ) ; if ( samolotdowpuszczenia != null ) { wpuscsamolotnapas ( samolotdowpuszczenia ) ; } advancetime ( 1.0 ) ; } }
tr	10	private void initializewindow ( ) { dimension dim = toolkit . getdefaulttoolkit ( ) . getscreensize ( ) ; frame = new jframe ( ) ; frame . setbounds ( ( dim . width / 2 - ( appwidth / 2 ) ) , ( dim . height / 2 - ( appheigth / 2 ) ) , appwidth , appheigth ) ; frame . setdefaultcloseoperation ( jframe . exit_on_close ) ; frame . getcontentpane ( ) . setlayout ( null ) ; frame . settitle ( "9mm - nine men's morris" ) ; leftpanel = new jpanel ( ) ; leftpanel . setforeground ( new color ( 0 , 0 , 0 ) ) ; leftpanel . setbackground ( new color ( 255 , 255 , 204 ) ) ; leftpanel . setbounds ( 6 , 6 , 100 , 500 ) ; frame . getcontentpane ( ) . add ( leftpanel ) ; leftpanel . setlayout ( null ) ; jlabel lblplayer = new jlabel ( "player 1" ) ; lblplayer . setbounds ( 20 , 454 , 61 , 16 ) ; leftpanel . add ( lblplayer ) ; imageicon texture = createimageicon ( "/resources/wood.jpg" ) ; rightpanel = new jpanel ( ) ; rightpanel . setbackground ( color . dark_gray ) ; rightpanel . setbounds ( 630 , 6 , 100 , 500 ) ; frame . getcontentpane ( ) . add ( rightpanel ) ; rightpanel . setlayout ( null ) ; jlabel lblplayer_1 = new jlabel ( "player 2" ) ; lblplayer_1 . setforeground ( new color ( 255 , 255 , 255 ) ) ; lblplayer_1 . setbounds ( 20 , 454 , 61 , 16 ) ; rightpanel . add ( lblplayer_1 ) ; centerpanel = new jlayeredpane ( ) ; centerpanel . setbackground ( color . orange ) ; centerpanel . setbounds ( 118 , 6 , 500 , 500 ) ; frame . getcontentpane ( ) . add ( centerpanel ) ; centerpanel . setlayout ( null ) ; imageicon field = createimageicon ( "/resources/spielfeld_roundedcorners.png" ) ; jlabel feld = new jlabel ( field ) ; feld . setbounds ( 0 , 0 , 500 , 500 ) ; centerpanel . add ( feld , 2 ) ; jlabel texturecenter = new jlabel ( texture ) ; texturecenter . setbounds ( 0 , 0 , 500 , 500 ) ; centerpanel . add ( texturecenter , 3 ) ; setupeventfields ( 24 ) ; jscrollpane scrollpane = new jscrollpane ( ) ; scrollpane . setbounds ( 6 , 518 , 724 , 149 ) ; frame . getcontentpane ( ) . add ( scrollpane ) ; txtlogarea = new jtextarea ( ) ; txtlogarea . seteditable ( false ) ; scrollpane . setviewportview ( txtlogarea ) ; jbutton btnclose = new jbutton ( "close" ) ; btnclose . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent arg0 ) { system . exit ( 0 ) ; } } ) ; btnclose . setbounds ( 613 , 673 , 117 , 35 ) ; frame . getcontentpane ( ) . add ( btnclose ) ; referee = new referee ( this ) ; jbutton btnrestart = new jbutton ( "restart" ) ; btnrestart . setbounds ( 487 , 673 , 117 , 35 ) ; frame . getcontentpane ( ) . add ( btnrestart ) ; if ( turnofstarter ) { txtlogarea . append ( "whites turn!\\n" ) ; } else { txtlogarea . append ( "blacks turn!\\n" ) ; } }
tr	7	@ eventhandler ( priority = eventpriority . monitor ) public void onblockbreakevent ( blockbreakevent event ) { if ( event . iscancelled ( ) ) { logdebug ( "th: block break cancel detected." ) ; return ; } logdebug ( "th: no cancel detected." ) ; org . bukkit . block . block block = event . getblock ( ) ; if ( event . getplayer ( ) instanceof player ) { if ( event . getplayer ( ) . getgamemode ( ) . equals ( gamemode . creative ) ) { return ; } } if ( block . gettype ( ) == material . skull ) { org . bukkit . block . skull skull = ( org . bukkit . block . skull ) block . getstate ( ) ; if ( skull . getskulltype ( ) . equals ( skulltype . player ) ) { if ( skull . hasowner ( ) ) { string pname = skull . getowner ( ) ; if ( pname == null ) { return ; } if ( custom_skins . containsvalue ( pname ) ) { location loc = block . getlocation ( ) . clone ( ) ; event . setcancelled ( true ) ; block . settype ( material . air ) ; itemstack item = new itemstack ( material . skull_item , 1 , ( byte ) 3 ) ; itemmeta itemmeta = item . getitemmeta ( ) ; ( ( skullmeta ) itemmeta ) . setowner ( pname ) ; itemmeta . setdisplayname ( chatcolor . green + getcustomskullname ( getcustomskulltype ( pname ) ) + " head" ) ; item . setitemmeta ( itemmeta ) ; world world = loc . getworld ( ) ; world . dropitemnaturally ( loc , item ) ; } } } } }
tr	7	private void analysemethods ( classidentifier cls , list < methodnode > methods ) { set < string > classes = sets . newhashset ( ) ; set < string > called = sets . newhashset ( ) ; for ( methodnode method : methods ) { for ( abstractinsnnode instruction : method . instructions . toarray ( ) ) { if ( instruction instanceof methodinsnnode ) { methodinsnnode methodcall = ( methodinsnnode ) instruction ; called . add ( methodcall . owner ) ; } else if ( instruction instanceof ldcinsnnode ) { ldcinsnnode ldc = ( ldcinsnnode ) instruction ; if ( ldc . cst instanceof type ) { type typeliteral = ( type ) ldc . cst ; classes . add ( typeliteral . getinternalname ( ) ) ; } } } } newrelationships ( called , cls , calls ) ; newrelationships ( difference ( classes , called ) , cls , refers_to_literal ) ; }
tr	4	private static void calctestaccuracy ( dataset test , string [ ] results ) { if ( results == null ) { system . out . println ( "error in calculating accuracy: " + "you must implement the classify method" ) ; system . exit ( - 1 ) ; } list < instance > testinslist = test . instances ; if ( testinslist . size ( ) == 0 ) { system . out . println ( "error: size of test set is 0" ) ; system . exit ( - 1 ) ; } if ( testinslist . size ( ) > results . length ) { system . out . println ( "error: the number of predictions is inconsistant " + "with the number of instances in test set<litcomma> please check it" ) ; system . exit ( - 1 ) ; } int correct = 0 , total = testinslist . size ( ) ; for ( int i = 0 ; i < testinslist . size ( ) ; i ++ ) if ( testinslist . get ( i ) . label . equals ( results [ i ] ) ) correct ++ ; system . out . println ( "prediction accuracy on the test set is: " + string . format ( "%.5f" , correct * 1.0 / total ) ) ; return ; }
tr	3	public double isexam ( final string examname ) { double result = - 1 ; double counter = 0 ; for ( final exam exam : exams ) { if ( exam . getname ( ) != null ) { if ( exam . getname ( ) . indexof ( examname ) != - 1 ) { result += exam . getmark ( ) != null ? exam . getmark ( ) : 0 ; counter ++ ; } } } if ( counter > 0 ) { result += 1 ; result = result / counter ; } return result ; }
tr	6	public move getmove ( ) { move r ; boardposition a ; boardposition b ; scanner sc = new scanner ( system . in ) ; int row ; string collumn ; system . out . print ( "enter the row of the position of the piece you would like to move: " ) ; row = sc . nextint ( ) ; system . out . print ( "enter the collumn of the position of the piece you would like to move: " ) ; collumn = sc . next ( ) ; a = new boardposition ( 6 - row , getnumforcollumn ( collumn ) ) ; system . out . print ( "enter the row of the position you would like to move this piece to: " ) ; row = sc . nextint ( ) ; system . out . print ( "enter the collumn of the position you would like to move this piece to: " ) ; collumn = sc . next ( ) ; b = new boardposition ( 6 - row , getnumforcollumn ( collumn ) ) ; r = new move ( a , b , gamestatus . continue ) ; return r ; }
tr	1	@ test public void testaendere\xe7o ( ) { endere\xe7o endere\xe7o1 = new endere\xe7o ( "rua jo\xe7o cirilo" , "altiplano" , "jo\xe7o pessoa" , "paraiba" , 1078 ) ; endere\xe7o1 . setbairro ( "campo grande" ) ; endere\xe7o1 . setcidade ( "recife" ) ; endere\xe7o1 . setestado ( "pernambuco" ) ; endere\xe7o1 . setnumero ( 6599 ) ; endere\xe7o1 . setrua ( "rua aurora" ) ; assertequals ( "campo grande" , endere\xe7o1 . getbairro ( ) ) ; assertequals ( "recife" , endere\xe7o1 . getcidade ( ) ) ; assertequals ( "pernambuco" , endere\xe7o1 . getestado ( ) ) ; assertequals ( 6599 , endere\xe7o1 . getnumero ( ) ) ; assertequals ( "rua aurora" , endere\xe7o1 . getrua ( ) ) ; }
tr	10	public static void resources ( arraylist < resource > arrresources , boolean bwithindex ) { if ( arrresources . size ( ) > 0 ) { integer intpagesneeded = arrresources . size ( ) / 10 ; integer intremainder = arrresources . size ( ) - ( intpagesneeded * 10 ) ; if ( intremainder > 0 ) { intpagesneeded ++ ; } resource [ ] [ ] arrpages = new resource [ intpagesneeded ] [ 10 ] ; integer intpageindex = 0 ; integer intpageplacementpointer = 0 ; integer intresourceindex = 0 ; for ( resource resource : arrresources ) { arrpages [ intpageindex ] [ intpageplacementpointer ] = resource ; intpageplacementpointer ++ ; intresourceindex ++ ; if ( intresourceindex % 10 == 0 ) { intpageindex ++ ; intpageplacementpointer = 0 ; } } system . out . println ( ) ; intresourceindex = 0 ; intpageindex = 0 ; string strinput = "" ; for ( resource [ ] page : arrpages ) { for ( int y = 0 ; y < page . length ; y ++ ) { if ( page [ y ] != null ) { if ( bwithindex ) { system . out . println ( "[" + intresourceindex + "] " + page [ y ] . tostring ( ) ) ; } else { system . out . println ( page [ y ] . tostring ( ) ) ; } } intresourceindex ++ ; } intpageindex ++ ; if ( ! strinput . equals ( "a" ) && ! strinput . equals ( "all" ) && arrpages . length > 1 && intpageindex < arrpages . length ) { system . out . println ( "...hit return to view next page or 'all' / 'a' to view the remaining entries..." ) ; strinput = input . waitforreturn ( ) ; } } } else { system . out . println ( ) ; system . out . println ( "no resources to display" ) ; } }
va	2	@ suppresswarnings ( "deprecation" ) public string getname ( ) { string name = "pig" ; switch ( living . getbukkitentity ( ) . gettype ( ) ) { case cave_spider : name = "cave spider" ; break ; case horse : name = "horse" ; break ; case iron_golem : name = "iron golem" ; break ; case magma_cube : name = "magma cube" ; break ; case minecart : name = "minecart" ; break ; case minecart_chest : name = "minecart w/ chest" ; break ; case minecart_command : name = "minecart w/ command block" ; break ; case minecart_furnace : name = "minecart w/ furnace" ; break ; case minecart_hopper : name = "minecart w/ hopper" ; break ; case minecart_mob_spawner : name = "minecart w/ spawner" ; break ; case minecart_tnt : name = "minecart w/ tnt" ; break ; case mushroom_cow : name = "mooshroom" ; break ; case ocelot : name = "ocelot" ; break ; case painting : name = "painting" ; break ; case pig_zombie : name = "zombie pigman" ; break ; case skeleton : skeleton skeleton = ( skeleton ) living . getbukkitentity ( ) ; name = skeleton . getskeletontype ( ) == skeletontype . normal ? "skeleton" : "wither skeleton" ; break ; case snowman : name = "snow golem" ; break ; case wither : name = "wither boss" ; break ; default : name = living . getbukkitentity ( ) . gettype ( ) . getname ( ) ; break ; } return name ; }
va	1	private void adjustopt ( map < string , string > opt ) { if ( null == opt || opt . isempty ( ) ) { throw new channelexception ( "no params are set" , channel_sdk_param ) ; } if ( ! opt . containskey ( timestamp ) ) { string timestamp = string . valueof ( system . currenttimemillis ( ) / 1000 ) ; opt . put ( timestamp , timestamp ) ; } opt . put ( host , default_host ) ; opt . put ( api_key , apikey ) ; if ( opt . containskey ( secret_key ) ) { opt . remove ( secret_key ) ; } }
va	7	public static void main ( string [ ] args ) { try { class . forname ( "org.sqlite.jdbc" ) ; } catch ( classnotfoundexception e ) { joptionpane . showmessagedialog ( null , "please put sqlite jdbc driver (sqlitejdbc-v056.jar file) in same folder with this program (or add it to classpath)." ) ; return ; } jfilechooser filechooser = new jfilechooser ( ) ; filechooser . setfileselectionmode ( jfilechooser . files_only ) ; filechooser . setmultiselectionenabled ( false ) ; filechooser . setfilefilter ( new filefilter ( ) { @ override public boolean accept ( file file ) { if ( file == null ) return false ; boolean result = false ; string filename = file . getname ( ) ; int indexofdot = filename . indexof ( "." ) ; if ( indexofdot > - 1 ) { string extension = filename . substring ( indexofdot ) ; if ( ".sqlite" . equalsignorecase ( extension ) ) result = true ; } return result ; } @ override public string getdescription ( ) { return "sqlite db files" ; } } ) ; int opendialogresult = filechooser . showopendialog ( null ) ; if ( jfilechooser . approve_option == opendialogresult ) { file file = filechooser . getselectedfile ( ) ; if ( file != null && file . exists ( ) ) { new main ( ) . launch ( file ) ; } } }
va	3	@ override protected void map ( longwritable key , text line , context context ) throws ioexception , interruptedexception { string [ ] data = line . tostring ( ) . split ( "\\t" ) ; text browserid = new text ( data [ 2 ] . tostring ( ) . trim ( ) ) ; try { date date = new date ( ) ; date = new simpledateformat ( "yyyy-mm-dd hh:mm:ss" , locale . english ) . parse ( data [ 1 ] . tostring ( ) . trim ( ) ) ; browser . setbrowserid ( browserid ) ; browser . settime ( new longwritable ( date . gettime ( ) ) ) ; } catch ( parseexception e ) { e . printstacktrace ( ) ; } system . out . println ( browser . tostring ( ) ) ; context . write ( browser , nullwritable ) ; }
va	10	batch buildbatch ( file batchfile ) { batch batch = new batch ( ) ; try { fileinputstream fis = new fileinputstream ( batchfile ) ; documentbuilderfactory dbfactory = documentbuilderfactory . newinstance ( ) ; documentbuilder dbuilder = dbfactory . newdocumentbuilder ( ) ; document doc = dbuilder . parse ( fis ) ; element pnode = doc . getdocumentelement ( ) ; nodelist nodes = pnode . getchildnodes ( ) ; for ( int idx = 0 ; idx < nodes . getlength ( ) ; idx ++ ) { node node = nodes . item ( idx ) ; if ( node . getnodetype ( ) == node . element_node ) { element elem = ( element ) node ; parsecommand ( elem , batch ) ; } } } catch ( exception e ) { system . out . println ( e . getmessage ( ) ) ; e . printstacktrace ( ) ; } return batch ; }
va	7	private static string solve ( int [ ] [ ] grid , int n , int m ) { boolean rowflag = true ; boolean colflag = true ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { int spot = grid [ i ] [ j ] ; int max = grid [ i ] [ j ] ; for ( int x = 0 ; x < m ; x ++ ) { if ( grid [ i ] [ x ] > max ) { max = grid [ i ] [ x ] ; } } if ( max > spot ) { rowflag = false ; } max = grid [ i ] [ j ] ; for ( int x = 0 ; x < n ; x ++ ) { if ( grid [ x ] [ j ] > max ) { max = grid [ x ] [ j ] ; } } if ( max > spot ) { colflag = false ; } if ( ! rowflag && ! colflag ) { break ; } else { rowflag = true ; colflag = true ; } } if ( ! rowflag && ! colflag ) { return "no" ; } } return "yes" ; }
va	7	@ override protected void doget ( httpservletrequest request , httpservletresponse response ) throws servletexception , ioexception { httpsession session = request . getsession ( false ) ; if ( session != null ) { @ suppresswarnings ( "unchecked" ) map < long , integer > mandje = ( map < long , integer > ) session . getattribute ( "mandje" ) ; if ( mandje != null ) { list < long > bierenidlijst = new arraylist < > ( ) ; for ( long bierid : mandje . keyset ( ) ) { bierenidlijst . add ( bierid ) ; } set < bestelbonlijn > bestelbonlijnen = new hashset < > ( ) ; list < bier > bierenlijst = ( list < bier > ) bierservice . findallbyid ( bierenidlijst ) ; for ( bier bier : bierenlijst ) { bestelbonlijnen . add ( new bestelbonlijn ( mandje . get ( bier . getbiernr ( ) ) , bier ) ) ; } request . setattribute ( "mandje" , new bestelbon ( bestelbonlijnen ) ) ; } } request . getrequestdispatcher ( view ) . forward ( request , response ) ; }
va	9	@ suppresswarnings ( "unused" ) private string invokeraw ( string method , object [ ] params ) throws throwable { urlconnection uc = this . buildapiurl ( ) . openconnection ( ) ; uc . setdooutput ( true ) ; uc . setdoinput ( true ) ; uc . setrequestproperty ( "accept" , "application/json" ) ; uc . setrequestproperty ( "content-type" , "application/json; charset=utf-8" ) ; outputstream ops = uc . getoutputstream ( ) ; bufferedwriter writer = new bufferedwriter ( new outputstreamwriter ( ops ) ) ; string paramsstr = "\\"" + this . apikey + "\\"" ; for ( object o : params ) { paramsstr += "<litcomma>\\"" + o + "\\"" ; } string request = "{\\"jsonrpc\\":\\"2.0\\"<litcomma>\\"method\\":\\"" + method + "\\"<litcomma>\\"params\\":[" + paramsstr + "]<litcomma>\\"id\\":2}" ; writer . write ( request ) ; writer . close ( ) ; ops . close ( ) ; bufferedreader br = new bufferedreader ( new inputstreamreader ( uc . getinputstream ( ) ) ) ; string line ; string jsonstring = null ; while ( ( line = br . readline ( ) ) != null ) { jsonstring += line ; } br . close ( ) ; return jsonstring ; }
va	8	public static void assemble ( float [ ] [ ] val , float minc , float maxc , int rezx , int rezy ) { int i , j ; float px , py ; float tmp ; color col ; float spx = - rezx / 2 ; float spy = - rezy / 2 ; handle = gl11 . glgenlists ( 1 ) ; gl11 . glnewlist ( handle , gl11 . gl_compile ) ; gl11 . glbegin ( gl11 . gl_quads ) ; px = spx ; for ( i = 0 ; i < rezx - 1 ; i ++ ) { py = spy ; for ( j = 0 ; j < rezy - 1 ; j ++ ) { tmp = ( float ) ( 1 - ( ( val [ i ] [ j ] - minc ) / ( maxc - minc ) ) ) ; tmp = tmp * 66 / 100 + 34 / 100 ; col = new color ( color . hsbtorgb ( tmp , 0.7f , 0.85f ) ) ; gl11 . glcolor3f ( ( float ) ( col . getred ( ) / 255f ) , ( float ) ( col . getgreen ( ) / 255f ) , ( float ) ( col . getblue ( ) / 255f ) ) ; gl11 . glvertex2f ( px , py ) ; tmp = ( float ) ( 1 - ( ( val [ i ] [ j + 1 ] - minc ) / ( maxc - minc ) ) ) ; tmp = tmp * 66 / 100 + 34 / 100 ; col = new color ( color . hsbtorgb ( tmp , 0.7f , 0.85f ) ) ; gl11 . glcolor3f ( ( float ) ( col . getred ( ) / 255f ) , ( float ) ( col . getgreen ( ) / 255f ) , ( float ) ( col . getblue ( ) / 255f ) ) ; gl11 . glvertex2f ( px , py + 1 ) ; tmp = ( float ) ( 1 - ( ( val [ i + 1 ] [ j + 1 ] - minc ) / ( maxc - minc ) ) ) ; tmp = tmp * 66 / 100 + 34 / 100 ; col = new color ( color . hsbtorgb ( tmp , 0.7f , 0.85f ) ) ; gl11 . glcolor3f ( ( float ) ( col . getred ( ) / 255f ) , ( float ) ( col . getgreen ( ) / 255f ) , ( float ) ( col . getblue ( ) / 255f ) ) ; gl11 . glvertex2f ( px + 1 , py + 1 ) ; tmp = ( float ) ( 1 - ( ( val [ i + 1 ] [ j ] - minc ) / ( maxc - minc ) ) ) ; tmp = tmp * 66 / 100 + 34 / 100 ; col = new color ( color . hsbtorgb ( tmp , 0.7f , 0.85f ) ) ; gl11 . glcolor3f ( ( float ) ( col . getred ( ) / 255f ) , ( float ) ( col . getgreen ( ) / 255f ) , ( float ) ( col . getblue ( ) / 255f ) ) ; gl11 . glvertex2f ( px + 1 , py ) ; py += 1 ; } px += 1 ; } gl11 . glend ( ) ; gl11 . glendlist ( ) ; }
va	7	private static short [ ] createvendorids ( ) { set < short > vendorids = new hashset < short > ( ) ; for ( short vendorid : fixed_vendor_ids ) vendorids . add ( vendorid ) ; file ini = new file ( new file ( system . getproperty ( "user.home" ) , ".android" ) , "adb_usb.ini" ) ; try { if ( ini . exists ( ) ) { bufferedreader reader = new bufferedreader ( new filereader ( ini ) ) ; try { string line ; while ( ( line = reader . readline ( ) ) != null ) { if ( line . startswith ( "0x" ) ) { vendorids . add ( ( short ) integer . parseint ( line . substring ( 2 ) , 16 ) ) ; } } } finally { reader . close ( ) ; } } } catch ( ioexception e ) { log . log ( level . warning , "adb_usb.ini could not be read. ignoring it." , e ) ; } short [ ] result = new short [ vendorids . size ( ) ] ; int i = 0 ; for ( short vendorid : vendorids ) result [ i ++ ] = vendorid ; return result ; }
va	6	protected void setonenoderelations ( node curnode ) { if ( curnode . hasproperty ( friend_list_key ) ) { string [ ] friendsuidlist = ( string [ ] ) curnode . getproperty ( friend_list_key ) ; for ( string tempfrienduid : friendsuidlist ) { node tempfriend = nodeindex . get ( "uid" , tempfrienduid ) . getsingle ( ) ; if ( tempfriend == null ) { continue ; } iterable < relationship > relationships = tempfriend . getrelationships ( direction . both ) ; boolean relationalreadyexist = false ; for ( relationship temprel : relationships ) { if ( temprel . getendnode ( ) . getid ( ) == curnode . getid ( ) ) { relationalreadyexist = true ; break ; } } if ( ! relationalreadyexist ) { curnode . createrelationshipto ( tempfriend , reltypes . friend ) ; } } } }
va	4	public static void recursivefilelisting ( arraylist < string > extracted_links , string folder ) throws ioexception { for ( int i = 0 ; i < extracted_links . size ( ) ; i ++ ) { string target = extracted_links . get ( i ) . tostring ( ) ; string new_folder = folder + target ; while ( target . endswith ( "/" ) ) { folders . add ( new_folder ) ; string foldername [ ] = new_folder . split ( "/" ) ; folder ( ( minecraft . getworkingdirectory ( ) + file . separator + new_folder ) , foldername [ foldername . length - 1 ] ) ; recursivefilelisting ( getdirectorylisting ( new_folder ) , new_folder ) ; break ; } if ( ! new_folder . endswith ( "/" ) ) { files . add ( new_folder ) ; rename_files . add ( new_folder ) ; } } }
va	7	public transaction getlast ( ) throws sqlexception { statement statement = null ; try { char lasttype = 'e' ; double amount = 0.0 ; date date = new date ( 0 ) ; string description = new string ( ) ; statement = connection . createstatement ( ) ; resultset result ; string query = "select date<litcomma>description<litcomma>amount from transactions order by date desc limit 1" ; result = statement . executequery ( query ) ; while ( result . next ( ) ) { amount = result . getdouble ( "amount" ) ; date = result . getdate ( "date" ) ; description = result . getstring ( "description" ) ; } if ( amount < 0.0 ) lasttype = 'w' ; else lasttype = 'd' ; return new transaction ( lasttype , date , amount , description ) ; } catch ( sqlexception e ) { e . printstacktrace ( ) ; return new transaction ( ) ; } finally { if ( statement != null ) statement . close ( ) ; } }
va	3	public static void main ( string [ ] args ) throws exception { if ( args . length < 1 ) { system . out . println ( "java -jar andoidmarketparser.jar <searchquery>" ) ; return ; } string request = args [ 0 ] ; list < androidapplication > returndata = androidmarkethandler . marketsearch ( request ) ; if ( returndata == null ) { system . out . println ( "request return 0 applications" ) ; return ; } for ( androidapplication app : returndata ) { system . out . println ( "name: " + app . getname ( ) ) ; system . out . println ( "image: " + app . getimage ( ) ) ; system . out . println ( "packagename: " + app . getpackagename ( ) ) ; system . out . println ( "description: " + app . getdescription ( ) ) ; system . out . println ( "category: " + app . getcategory ( ) ) ; system . out . println ( "detailsrc: " + app . getdetailsurl ( ) ) ; system . out . println ( "currency: " + app . getcurrency ( ) ) ; system . out . println ( "price: " + app . getprice ( ) ) ; system . out . println ( "filesize: " + app . getfilebytes ( ) ) ; system . out . println ( "minandroidversion: " + app . getminandroidversion ( ) ) ; } system . out . println ( "total finded: " + returndata . size ( ) ) ; }
va	8	public static boolean createhangout ( int adminid , hangout hangout , list < integer > hangoutfriends ) { final string hangoutquery = "insert into mates.hangout (name<litcomma> description<litcomma> location<litcomma> location_map<litcomma> date<litcomma> admin_id) values (?<litcomma> ?<litcomma> ?<litcomma> ?<litcomma> ?<litcomma> ?);" ; final string hangoutidquery = "select last_insert_id();" ; final string hangoutfriendsquery = "insert into hangout_mates (hangout_id<litcomma> mate_id<litcomma> status) values (?<litcomma> ?<litcomma> ?);" ; try { connection c = mysql . connect ( ) ; preparedstatement ps = c . preparestatement ( hangoutquery ) ; ps . setstring ( 1 , hangout . getname ( ) ) ; ps . setstring ( 2 , hangout . getdescription ( ) ) ; ps . setstring ( 3 , hangout . getlocation ( ) ) ; ps . setstring ( 4 , hangout . getlocationmap ( ) ) ; ps . setstring ( 5 , hangout . getdate ( ) ) ; ps . setint ( 6 , adminid ) ; if ( ps . executeupdate ( ) != 1 ) { return false ; } int hangoutid = 0 ; ps = c . preparestatement ( hangoutidquery ) ; resultset rs = ps . executequery ( ) ; if ( rs . next ( ) ) { hangoutid = rs . getint ( "last_insert_id()" ) ; } else { return false ; } ps = c . preparestatement ( hangoutfriendsquery ) ; for ( int mateid : hangoutfriends ) { ps . setint ( 1 , hangoutid ) ; ps . setint ( 2 , mateid ) ; ps . setstring ( 3 , hangoutstatus . awaiting . tostring ( ) ) ; ps . executeupdate ( ) ; } return true ; } catch ( sqlexception e ) { e . printstacktrace ( ) ; return false ; } }
va	3	public static map < money , integer > getchange ( money money ) throws interruptedexception { map < money , integer > change = new hashmap < > ( ) ; for ( money m : money . denominations_high_to_low ) { change . put ( m , 0 ) ; while ( money . compareto ( m ) >= 0 ) { int currentval = change . get ( m ) ; system . out . println ( "another " + m + " used up!" ) ; change . put ( m , currentval + 1 ) ; money = money . add ( money , m . negatetemporarily ( ) ) ; system . out . println ( "money now: " + money + "\\n" ) ; } } return change ; }
va	1	public static void menu ( ) { guimaster . startgui ( ) ; while ( true ) { guimaster . println ( "welcome to the textbased game! \\n" + "\\n" + "which game do you wish to play? \\n" + "1 - gangup - work in progress \\n" + "2 - encryption - non gui \\n" + "3 - decryption - non gui \\n" + "4 - encryption gui \\n" + "5 - decryption gui \\n" + "6 - alchemy - work in progress \\n" ) ; string whattodo = guimaster . getenteredtext ( ) ; if ( whattodo == null ) { exit ( ) ; } whattodo = whattodo . trim ( ) ; whattodo = capitalize . capitalizeeveryword ( whattodo ) ; switch ( whattodo ) { case "gangup" : case "1" : gangup . startgangup ( ) ; break ; case "encryption" : case "2" : cryption . encrypt ( ) ; break ; case "decryption" : case "3" : cryption . decrypt ( ) ; break ; case "encryption gui" : case "4" : cryptiongui . encrypt ( ) ; break ; case "decryption gui" : case "5" : cryptiongui . decrypt ( ) ; case "alchemy" : case "6" : alchemy . startalchemy ( ) ; break ; default : guimaster . println ( "invalid option" ) ; } } }
va	2	public static void insertorupdateurlredirect ( string url ) { redirects redurl ; entitymanager manager = jputil . getinstance ( ) . getmanager ( ) ; manager . gettransaction ( ) . begin ( ) ; try { redurl = manager . createnamedquery ( "redirects.findbyurl" , redirects . class ) . setparameter ( "url" , url ) . getsingleresult ( ) ; redurl . setamountredir ( redurl . getamountredir ( ) + 1 ) ; manager . merge ( redurl ) ; } catch ( noresultexception ex ) { redurl = new redirects ( url , 1 ) ; manager . persist ( redurl ) ; } manager . gettransaction ( ) . commit ( ) ; }
va	7	public static int getnegativepower ( int x ) { int n = 11 , t = 0 , newt = 1 , r = n , newr = x , q , temp ; while ( newr != 0 ) { q = r / newr ; temp = newt ; newt = t - q * newt ; t = temp ; temp = newr ; newr = r - q * newr ; r = temp ; } if ( r > 1 ) return - 1 ; if ( t < 0 ) t = t + n ; return t ; }
va	6	@ postconstruct public void init ( ) { httphandler = new httphandler ( ) ; try { url requesturl = new url ( "http://services.brics.dk/java4/cloud" + "/listitems?shopid=" + "195" ) ; element responseroot = httphandler . httprequest ( "get" , requesturl ) . getrootelement ( ) ; if ( responseroot == null ) { throw new exception ( "response from itemlist request was null" ) ; } else { itemlist = new arraylist < item > ( ) ; for ( element itemchild : responseroot . getchildren ( ) ) { element description = itemchild . getchild ( "itemdescription" , webtekns ) ; string descriptionstr = "" ; for ( element descriptionchild : description . getchildren ( ) ) { descriptionchild . setnamespace ( null ) ; switch ( descriptionchild . getname ( ) ) { case "document" : descriptionchild . setname ( "div" ) ; break ; case "bold" : descriptionchild . setname ( "b" ) ; break ; case "italics" : descriptionchild . setname ( "i" ) ; break ; case "list" : descriptionchild . setname ( "ul" ) ; break ; case "item" : descriptionchild . setname ( "li" ) ; break ; default : break ; } descriptionstr += descriptionchild . getvalue ( ) ; } itemlist . add ( new item ( itemchild . getchildtext ( "itemid" , webtekns ) , itemchild . getchildtext ( "itemname" , webtekns ) , itemchild . getchildtext ( "itemurl" , webtekns ) , itemchild . getchildtext ( "itemprice" , webtekns ) , itemchild . getchildtext ( "itemstock" , webtekns ) , descriptionstr ) ) ; } } } catch ( exception e ) { system . out . println ( "an error occurred: " + e . getmessage ( ) ) ; } }
va	2	private boolean validplacetle ( int column , int row , int [ ] [ ] board ) { int sum = 0 ; for ( int i = 0 ; i < board . length ; i ++ ) sum += board [ row ] [ i ] ; if ( sum > 0 ) return false ; for ( int i = 0 ; i < board . length ; i ++ ) sum += board [ i ] [ column ] ; if ( sum > 0 ) return false ; for ( int i = 0 ; i < board . length ; i ++ ) sum += board [ i ] [ i ] ; if ( sum > 0 ) return false ; return true ; }
va	4	private void setfield ( class < ? > theclass , object obj , string fieldstring ) throws securityexception , nosuchfieldexception , numberformatexception , illegalargumentexception , illegalaccessexception { int index = fieldstring . indexof ( internal_separator ) ; string fieldname = fieldstring . substring ( 0 , index ) ; string value = fieldstring . substring ( index + 1 ) ; system . out . println ( value ) ; field field = theclass . getdeclaredfield ( fieldname ) ; field . setaccessible ( true ) ; if ( field . gettype ( ) == int . class ) { field . setint ( obj , integer . parseint ( value ) ) ; } }
va	8	protected static int findgemcount ( list < string > samples ) { int count = 0 ; pattern pattern = pattern . compile ( "[a-za-z]" ) ; string minlenstr = samples . stream ( ) . min ( ( s1 , s2 ) -> s1 . length ( ) - s2 . length ( ) ) . get ( ) ; matcher matcher = pattern . matcher ( minlenstr ) ; set < string > uniuqe = new hashset < string > ( ) ; while ( matcher . find ( ) ) { string group = matcher . group ( ) ; if ( uniuqe . add ( group ) ) { boolean flag = true ; for ( string s : samples ) { if ( ! s . contains ( group ) ) { flag = false ; break ; } } if ( flag ) { count ++ ; } } } return count ; }
va	6	public static string getlibrarypath ( plugin aplugin ) { bundle thebundle = aplugin . getbundle ( ) ; string pluginloc = null ; if ( thebundle != null ) { url installloc = thebundle . getentry ( "/" ) ; url resolved = null ; try { resolved = platform . resolve ( installloc ) ; pluginloc = resolved . toexternalform ( ) ; } catch ( ioexception e ) { throw new runtimeexception ( e ) ; } } if ( pluginloc != null ) { if ( pluginloc . startswith ( "file:" ) ) { try { pluginloc = pluginloc . replaceall ( " " , "%20" ) ; uri theuri = new uri ( pluginloc + "/lib" ) ; file thefile = new file ( theuri ) ; return thefile . getabsolutepath ( ) ; } catch ( urisyntaxexception e ) { e . printstacktrace ( ) ; } } } return null ; }
va	4	private string countandsay ( string seq ) { string res = "" ; string lastvalue = "" ; int lastvaluenumber = 0 ; for ( int i = 0 ; i < seq . length ( ) ; i ++ ) { if ( ! seq . substring ( i , i + 1 ) . equals ( lastvalue ) ) { if ( lastvaluenumber != 0 ) res += lastvaluenumber + lastvalue ; lastvalue = seq . substring ( i , i + 1 ) ; lastvaluenumber = 1 ; } else { lastvaluenumber ++ ; } } res += lastvaluenumber + lastvalue ; return res ; }
va	1	@ override public void analyse ( analysiscontext context ) { try { classes = new arraylist < classdescription > ( ) ; for ( class clazz : context . getclasses ( ) ) { classes . add ( new classdescription ( clazz ) ) ; } } catch ( classnotfoundexception e ) { e . printstacktrace ( ) ; } catch ( illegalaccessexception e ) { e . printstacktrace ( ) ; } catch ( nosuchfieldexception e ) { e . printstacktrace ( ) ; } catch ( malformedurlexception e ) { e . printstacktrace ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } }
va	1	public boolean addtoken ( int x , int y , token t ) { if ( board . addtoken ( x , y , t ) ) { int i = board . getgamestate ( x , y , t . gettype ( ) ) ; if ( i > 0 ) { endgame ( i ) ; gamewon = true ; } elozosiker = true ; return true ; } else { gui . addtext ( "hiba: az a mezo mar foglalt!" ) ; gui . addtext ( getprevplayer ( ) . gettype ( ) + " turn again!" ) ; elozosiker = false ; return false ; } }
va	2	public void set ( int key , int value ) { if ( _listlookup . containskey ( key ) ) { listnode x = _listlookup . get ( key ) ; x . val = value ; x . prev . next = x . next ; x . next . prev = x . prev ; x . prev = _end . prev ; _end . prev . next = x ; x . next = _end ; _end . prev = x ; } else { if ( _listlookup . size ( ) < _capacity ) { listnode x = new listnode ( key , value ) ; _listlookup . put ( key , x ) ; x . prev = _end . prev ; _end . prev . next = x ; x . next = _end ; _end . prev = x ; } else { listnode x = _start . next ; _start . next = x . next ; x . next . prev = _start ; _listlookup . remove ( x . key ) ; listnode y = new listnode ( key , value ) ; _listlookup . put ( key , y ) ; y . prev = _end . prev ; _end . prev . next = y ; y . next = _end ; _end . prev = y ; } } }
va	3	private void generateticks ( ) { int index = 0 ; string numstr ; for ( double i = interval . start ; index < ticks . length ; i += unitdistance , index ++ ) { if ( i >= 1000 || i <= - 1000 ) numstr = new decimalformat ( "0.##e0" ) . format ( i ) ; else numstr = new decimalformat ( "0.00" ) . format ( i ) ; if ( this . orientation == orientation . horizontal ) ticks [ index ] = new tick ( new point2d . double ( startpoint . x + index * unitlength , startpoint . y ) , numstr , - 1 ) ; else ticks [ index ] = new tick ( new point2d . double ( startpoint . x , axislength + startpoint . y - index * unitlength ) , numstr , 1 ) ; } }
va	1	private void encode ( string seq ) throws sequenceexception { for ( char c : seq . touppercase ( ) . tochararray ( ) ) { code = code << 2 ; if ( c == 'a' ) { code = code ^ 0 ; } else if ( c == 'c' ) { code = code ^ 1 ; } else if ( c == 'g' ) { code = code ^ 2 ; } else if ( c == 't' ) { code = code ^ 3 ; } else { throw new sequenceexception ( "illegal sequence character: " + c + " sequence: " + seq ) ; } } }
va	8	protected void processrequest ( httpservletrequest request , httpservletresponse response ) throws servletexception , ioexception { response . setcontenttype ( "text/html;charset=utf-8" ) ; string user_id = request . getparameter ( "user_id" ) ; string password = request . getparameter ( "password" ) ; string errormsg = null ; if ( user_id == null || user_id . equals ( "" ) || password == null || password . equals ( "" ) ) { invaliduser ( request , response ) ; } else { connection con = ( connection ) getservletcontext ( ) . getattribute ( "dbconnection" ) ; preparedstatement ps = null ; resultset rs = null ; statement stmt = null ; try { ps = con . preparestatement ( "select * from users where name=? and pass=?" ) ; ps . setstring ( 1 , user_id ) ; ps . setstring ( 2 , password ) ; stmt = con . createstatement ( ) ; string query = "select * from users where name= \\"" + user_id + "\\" and pass= \\"" + password + "\\"" ; rs = stmt . executequery ( query ) ; if ( injectionprotection ) { rs = ps . executequery ( ) ; } else { rs = stmt . executequery ( query ) ; } if ( rs != null && rs . first ( ) ) { setupsession ( request , response , con , user_id , injectionprotection ) ; } else { invaliduser ( request , response ) ; } } catch ( exception e ) { e . printstacktrace ( ) ; throw new servletexception ( "db connection problem" ) ; } finally { try { rs . close ( ) ; ps . close ( ) ; } catch ( sqlexception e ) { e . printstacktrace ( ) ; } } } }
va	6	public configuration loadembeddedconfig ( final string resource ) { final yamlconfiguration config = new yamlconfiguration ( ) ; final inputstream defaults = this . getresource ( resource ) ; if ( defaults == null ) return config ; final inputstreamreader reader = new inputstreamreader ( defaults , customplugin . configuration_source ) ; final stringbuilder builder = new stringbuilder ( ) ; final bufferedreader input = new bufferedreader ( reader ) ; try { try { string line ; while ( ( line = input . readline ( ) ) != null ) builder . append ( line ) . append ( customplugin . line_separator ) ; } finally { input . close ( ) ; } config . loadfromstring ( builder . tostring ( ) ) ; } catch ( final exception e ) { throw new runtimeexception ( "unable to load embedded configuration: " + resource , e ) ; } return config ; }
va	1	protected static boolean deletable ( int numvar , int pattern , int prefix ) { if ( numvar == 0 ) { int curposition = reversedigit ( totalvar , 2 , prefix ) ; if ( kmap [ curposition ] == boolx . x ) return numlayer [ curposition ] > 0 ; return numlayer [ curposition ] > 1 ; } switch ( pattern % 3 ) { case 0 : return deletable ( numvar - 1 , pattern / 3 , prefix * 2 + 0 ) ; case 1 : return deletable ( numvar - 1 , pattern / 3 , prefix * 2 + 1 ) ; default : if ( ! deletable ( numvar - 1 , pattern / 3 , prefix * 2 + 0 ) ) return false ; return deletable ( numvar - 1 , pattern / 3 , prefix * 2 + 1 ) ; } }
va	7	public int [ ] [ ] histoequalize ( array histo , int [ ] [ ] image ) { int height = image . length ; int width = image [ 0 ] . length ; int [ ] [ ] newimage = new int [ height ] [ width ] ; array cdfarray = calccdf ( histo ) ; array newhisto = new array ( ) ; for ( int i = 0 ; i < 256 ; i ++ ) { newhisto . setvalue ( i , cdfarray . getvalue ( i ) * 255 / ( height * width ) ) ; } for ( int i = 0 ; i < height ; i ++ ) { for ( int j = 0 ; j < width ; j ++ ) { newimage [ i ] [ j ] = newhisto . getvalue ( image [ i ] [ j ] ) ; } } newhisto . printall ( ) ; return newimage ; }
va	5	private void show ( int max_doc_num ) throws exception { if ( doc_weight_map . size ( ) != 0 ) { system . out . println ( doc_weight_map . size ( ) + " acticles contain the word(s)!" ) ; valuecomparator value_compr = new valuecomparator ( doc_weight_map ) ; treemap < string , double > sorted_map = new treemap < string , double > ( value_compr ) ; sorted_map . putall ( doc_weight_map ) ; int doc_num = 0 ; for ( string file_name : sorted_map . keyset ( ) ) { if ( doc_num < max_doc_num ) { double tf_idf = doc_weight_map . get ( file_name ) ; system . out . println ( file_name + ": score=" + tf_idf ) ; searchdoc ( file_name ) ; } doc_num ++ ; } } else { system . out . println ( "the word(s) cannot be found!" ) ; } }
va	7	@ test public void testgetrandomquestion ( ) { int testtries = 300 ; boolean horsefound = false ; boolean housefound = false ; boolean tabelfound = false ; for ( int i = 0 ; i < testtries ; i ++ ) { string question = wordpairdemo . getrandomquestion ( ) ; if ( question . equals ( "hest" ) ) { horsefound = true ; } if ( question . equals ( "hus" ) ) { housefound = true ; } if ( question . equals ( "bord" ) ) { tabelfound = true ; } } string errormessage = "expected horsefound: true<litcomma> housefound: true<litcomma> tablefound: true. got: hoserfound: " + horsefound + "<litcomma> housefound: " + housefound + "<litcomma> tablefound: " + tabelfound ; asserttrue ( errormessage , horsefound && housefound && tabelfound ) ; }
va	2	public static void main ( string args [ ] ) { abb < integer > p = new abb < integer > ( ) ; int i ; system . out . println ( "insertando nodos recursivamente." ) ; p . insertaabbrecursivo ( 60 ) ; p . insertaabbrecursivo ( 13 ) ; p . insertaabbrecursivo ( 85 ) ; p . insertaabbrecursivo ( 75 ) ; p . insertaabbrecursivo ( 19 ) ; p . insertaabbrecursivo ( 2 ) ; p . insertaabbrecursivo ( 94 ) ; p . insertaabbrecursivo ( 16 ) ; p . insertaabbrecursivo ( 10 ) ; p . insertaabbrecursivo ( 5 ) ; p . insertaabbrecursivo ( 0 ) ; p . insertaabbrecursivo ( 34 ) ; p . insertaabbrecursivo ( 78 ) ; p . insertaabbrecursivo ( 110 ) ; p . insertaabbrecursivo ( 99 ) ; p . insertaabbrecursivo ( 5 ) ; p . insertaabbrecursivo ( 50 ) ; p . insertaabbrecursivo ( 150 ) ; p . insertaabbrecursivo ( 3 ) ; p . insertaabbrecursivo ( 42 ) ; p . insertaabbrecursivo ( 57 ) ; p . insertaabbrecursivo ( 142 ) ; p . insertaabbrecursivo ( 4 ) ; p . insertaabbrecursivo ( 38 ) ; p . insertaabbrecursivo ( 130 ) ; p . insertaabbrecursivo ( 99 ) ; p . insertaabbrecursivo ( 50 ) ; system . out . println ( "\\n***  arbol con inserciones recursivas  *** \\n" ) ; system . out . println ( "\\nrecorrido en inorden: " + p . inorden ( ) ) ; system . out . println ( "\\nrecorrido en preorden: " + p . preorden ( ) ) ; system . out . println ( "\\nrecorrido en postorden: " + p . postorden ( ) ) ; p . insertaabbiterativo ( 20 ) ; p . insertaabbiterativo ( 5 ) ; p . insertaabbiterativo ( 35 ) ; p . insertaabbiterativo ( 2 ) ; p . insertaabbiterativo ( 32 ) ; p . insertaabbiterativo ( 27 ) ; p . insertaabbiterativo ( 10 ) ; p . insertaabbiterativo ( 14 ) ; p . insertaabbiterativo ( 7 ) ; p . insertaabbiterativo ( 40 ) ; p . insertaabbiterativo ( 6 ) ; p . insertaabbiterativo ( 142 ) ; p . insertaabbiterativo ( 30 ) ; p . insertaabbiterativo ( 36 ) ; p . insertaabbiterativo ( 46 ) ; p . insertaabbiterativo ( 11 ) ; p . insertaabbiterativo ( 22 ) ; p . insertaabbiterativo ( 5 ) ; system . out . println ( "\\n\\n***  arbol con inserciones iterativas  *** \\n" ) ; system . out . println ( "\\nrecorrido en inorden: " + p . inorden ( ) ) ; system . out . println ( "\\nrecorrido en preorden: " + p . preorden ( ) ) ; system . out . println ( "\\nrecorrido en postorden: " + p . postorden ( ) ) ; system . out . println ( "\\n\\n***  probando metodos contiene  *** \\n" ) ; system . out . println ( "\\ncontiene el arbol el dato 42 (iterativo)?: " + ( p . containsabbiterativo ( 42 ) ? "si" : "no" ) ) ; system . out . println ( "\\ncontiene el arbol el dato 34 (recursivo)?: " + ( p . containsabbrecursivo ( 34 ) ? "si" : "no" ) ) ; system . out . println ( "\\ncontiene el arbol el dato 18 (iterativo)?: " + ( p . containsabbiterativo ( 18 ) ? "si" : "no" ) ) ; system . out . println ( "\\ncontiene el arbol el dato 84 (recursivo)?: " + ( p . containsabbrecursivo ( 84 ) ? "si" : "no" ) ) ; system . out . println ( "\\nel arbol tiene " + p . contarnodosrecursivo ( ) + " nodos y " + p . gettotalnodosterminalesrecursivo ( ) + " hojas." ) ; system . out . println ( "\\n\\n***  probando metodo hermano  *** \\n" ) ; system . out . println ( "\\nel hermano de 75 es: " + p . gethermanoabbrecursivo ( 75 ) ) ; system . out . println ( "\\nel hermano de 60 es: " + p . gethermanoabbrecursivo ( 60 ) ) ; system . out . println ( "\\nel hermano de 175 es: " + p . gethermanoabbrecursivo ( 175 ) ) ; system . out . println ( "\\nel hermano de 57 es: " + p . gethermanoabbrecursivo ( 57 ) ) ; system . out . println ( "\\nel hermano de 5 es: " + p . gethermanoabbrecursivo ( 5 ) ) ; system . out . println ( "\\n\\n***  probando metodo padre  *** \\n" ) ; system . out . println ( "\\nel padre de 75 es: " + p . getpadreabbrecursivo ( 75 ) ) ; system . out . println ( "\\nel padre de 60 es: " + p . getpadreabbrecursivo ( 60 ) ) ; system . out . println ( "\\nel padre de 175 es: " + p . getpadreabbrecursivo ( 175 ) ) ; system . out . println ( "\\nel padre de 57 es: " + p . getpadreabbrecursivo ( 57 ) ) ; system . out . println ( "\\nel padre de 5 es: " + p . getpadreabbrecursivo ( 5 ) ) ; system . out . println ( "\\n\\n***  probando metodos mayor y menor  *** \\n" ) ; system . out . println ( "\\nel mayor dato del arbol es: " + p . getmayorabb ( ) ) ; system . out . println ( "\\nel menor dato del arbol es: " + p . getmenorabb ( ) ) ; system . out . println ( "\\n\\n***  probando metodo elimina  *** \\n" ) ; p . eliminadatoabb ( 38 ) ; system . out . println ( "\\nborrando el 38 (dos hijos): " + p . inorden ( ) ) ; p . eliminadatoabb ( 57 ) ; system . out . println ( "\\nborrando el 57 (nodo hoja): " + p . inorden ( ) ) ; p . eliminadatoabb ( 130 ) ; system . out . println ( "\\nborrando el 130 (nodo hoja): " + p . inorden ( ) ) ; p . eliminadatoabb ( 34 ) ; system . out . println ( "\\nborrando el 34 (nodo con un hijo): " + p . inorden ( ) ) ; p . eliminadatoabb ( 100 ) ; system . out . println ( "\\nborrando el 100 (nodo inexistente): " + p . inorden ( ) ) ; p . eliminadatoabb ( 85 ) ; system . out . println ( "\\nborrando el 85 (nodo con dos hijos): " + p . inorden ( ) ) ; p . eliminadatoabb ( 60 ) ; system . out . println ( "\\nborrando el 60 (nodo raiz): " + p . inorden ( ) ) ; system . out . println ( "\\n\\n***  probando metodo clear  *** \\n" ) ; system . out . println ( "\\nborrando todos los datos del arbol... " ) ; p . clear ( ) ; system . out . println ( "\\n\\ninsertando el 85 (nodo raiz)... " ) ; p . insertaabbiterativo ( 85 ) ; system . out . println ( "\\nrecorrido en inorden: " + p . inorden ( ) ) ; p . eliminadatoabb ( 85 ) ; system . out . println ( "\\nborrando el 85 (nodo raiz sin hijos): " + p . inorden ( ) ) ; system . out . println ( "\\nborrando todos los datos del arbol... " ) ; p . clear ( ) ; system . out . println ( "\\n\\ninsertando el 36 (nodo raiz)... " ) ; p . insertaabbiterativo ( 36 ) ; system . out . println ( "\\ninsertando el 74 ... " ) ; p . insertaabbiterativo ( 74 ) ; system . out . println ( "\\nrecorrido en inorden: " + p . inorden ( ) ) ; p . eliminadatoabb ( 36 ) ; system . out . println ( "\\nborrando el 36 (nodo raiz con hijo derecho): " + p . inorden ( ) ) ; system . out . println ( "\\nborrando todos los datos del arbol... " ) ; p . clear ( ) ; system . out . println ( "\\ninsertando el 54 (nodo raiz)... " ) ; p . insertaabbiterativo ( 54 ) ; system . out . println ( "\\ninsertando el 22 ... " ) ; p . insertaabbiterativo ( 22 ) ; system . out . println ( "\\nrecorrido en inorden: " + p . inorden ( ) ) ; p . eliminadatoabb ( 54 ) ; system . out . println ( "\\nborrando el 54 (nodo raiz con hijo izquierdo): " + p . inorden ( ) ) ; system . out . println ( "\\n\\n" ) ; }
va	10	public void printdialog ( ) { list < user > allusers = null ; try { if ( null == ( allusers = getuserdao ( ) . findall ( ) ) ) { system . err . println ( "info: app.findall" + " could not find users" ) ; } else { if ( 0 != allusers . size ( ) ) { final string [ ] tablehead = { "firstname" , "surname" , "e-mail" , "phone-number" } ; final int addnlasteriskcount = 13 ; final int maxfirstnamelength = getmaxfirstnamelength ( allusers , tablehead [ 0 ] . length ( ) ) ; final int maxsurnamelength = getmaxsurnamelength ( allusers , tablehead [ 1 ] . length ( ) ) ; final int maxmaillengh = getmaxmaillengh ( allusers , tablehead [ 2 ] . length ( ) ) ; final int maxphonenumberlengh = getmaxphonenumberlengh ( allusers , tablehead [ 3 ] . length ( ) ) ; final int asteriskcount = maxfirstnamelength + maxsurnamelength + maxmaillengh + maxphonenumberlengh + addnlasteriskcount ; printtablehead ( tablehead , maxfirstnamelength , maxsurnamelength , maxmaillengh , maxphonenumberlengh , addnlasteriskcount ) ; for ( user curruser : allusers ) { printuserrow ( curruser , maxfirstnamelength , maxsurnamelength , maxmaillengh , maxphonenumberlengh ) ; } for ( int i = 0 ; asteriskcount > i ; i ++ ) { system . out . print ( "*" ) ; } system . out . println ( ) ; } else { system . err . println ( "info: the users database is empty" ) ; } } } catch ( persistenceexception ex ) { logsingleton . getsystemlogger ( ) . logp ( level . severe , getclass ( ) . getname ( ) , "printdialog" , ex . getmessage ( ) , ex ) ; system . err . println ( "info: app.findall" + " could not find users<litcomma>" + " database error" ) ; getcommandparcer ( ) . setcommand ( quit_command ) ; } catch ( runtimeexception ex ) { logsingleton . getsystemlogger ( ) . logp ( level . severe , getclass ( ) . getname ( ) , "printdialog" , ex . getmessage ( ) , ex ) ; system . err . println ( "info: app.findall" + " could not find users<litcomma>" + "runtime error" ) ; getcommandparcer ( ) . setcommand ( quit_command ) ; } }
va	9	public void generate ( ) { string s [ ] = new string [ 10 ] ; color c [ ] = new color [ 10 ] ; string s1 [ ] = new string [ 20 ] ; int i ; arraylist < string > pg = g . populasigetter ( ) ; jtextarea1 . settext ( pg . get ( 0 ) ) ; jtextarea2 . settext ( pg . get ( 1 ) ) ; jtextarea3 . settext ( pg . get ( 2 ) ) ; jtextarea4 . settext ( pg . get ( 3 ) ) ; jtextarea5 . settext ( pg . get ( 4 ) ) ; jtextarea6 . settext ( pg . get ( 5 ) ) ; jtextarea7 . settext ( pg . get ( 6 ) ) ; jtextarea8 . settext ( pg . get ( 7 ) ) ; jtextarea9 . settext ( pg . get ( 8 ) ) ; jtextarea10 . settext ( pg . get ( 9 ) ) ; arraylist < string > pm = g . matinggetter ( ) ; jtextarea11 . settext ( pm . get ( 0 ) ) ; jtextarea12 . settext ( pm . get ( 1 ) ) ; jtextarea13 . settext ( pm . get ( 2 ) ) ; jtextarea14 . settext ( pm . get ( 3 ) ) ; jtextarea15 . settext ( pm . get ( 4 ) ) ; jtextarea16 . settext ( pm . get ( 5 ) ) ; jtextarea17 . settext ( pm . get ( 6 ) ) ; jtextarea18 . settext ( pm . get ( 7 ) ) ; jtextarea19 . settext ( pm . get ( 8 ) ) ; jtextarea20 . settext ( pm . get ( 9 ) ) ; s [ 0 ] = jtextarea1 . gettext ( ) ; s [ 1 ] = jtextarea2 . gettext ( ) ; s [ 2 ] = jtextarea3 . gettext ( ) ; s [ 3 ] = jtextarea4 . gettext ( ) ; s [ 4 ] = jtextarea5 . gettext ( ) ; s [ 5 ] = jtextarea6 . gettext ( ) ; s [ 6 ] = jtextarea7 . gettext ( ) ; s [ 7 ] = jtextarea8 . gettext ( ) ; s [ 8 ] = jtextarea9 . gettext ( ) ; s [ 9 ] = jtextarea10 . gettext ( ) ; c [ 0 ] = jtextarea1 . getbackground ( ) ; c [ 1 ] = jtextarea2 . getbackground ( ) ; c [ 2 ] = jtextarea3 . getbackground ( ) ; c [ 3 ] = jtextarea4 . getbackground ( ) ; c [ 4 ] = jtextarea5 . getbackground ( ) ; c [ 5 ] = jtextarea6 . getbackground ( ) ; c [ 6 ] = jtextarea7 . getbackground ( ) ; c [ 7 ] = jtextarea8 . getbackground ( ) ; c [ 8 ] = jtextarea9 . getbackground ( ) ; c [ 9 ] = jtextarea10 . getbackground ( ) ; for ( i = 0 ; i < 10 ; i ++ ) { if ( jtextarea11 . gettext ( ) . equalsignorecase ( s [ i ] ) ) { jtextarea11 . setbackground ( c [ i ] ) ; } if ( jtextarea12 . gettext ( ) . equalsignorecase ( s [ i ] ) ) { jtextarea12 . setbackground ( c [ i ] ) ; } if ( jtextarea13 . gettext ( ) . equalsignorecase ( s [ i ] ) ) { jtextarea13 . setbackground ( c [ i ] ) ; } if ( jtextarea14 . gettext ( ) . equalsignorecase ( s [ i ] ) ) { jtextarea14 . setbackground ( c [ i ] ) ; } if ( jtextarea15 . gettext ( ) . equalsignorecase ( s [ i ] ) ) { jtextarea15 . setbackground ( c [ i ] ) ; } if ( jtextarea16 . gettext ( ) . equalsignorecase ( s [ i ] ) ) { jtextarea16 . setbackground ( c [ i ] ) ; } if ( jtextarea17 . gettext ( ) . equalsignorecase ( s [ i ] ) ) { jtextarea17 . setbackground ( c [ i ] ) ; } if ( jtextarea18 . gettext ( ) . equalsignorecase ( s [ i ] ) ) { jtextarea18 . setbackground ( c [ i ] ) ; } if ( jtextarea19 . gettext ( ) . equalsignorecase ( s [ i ] ) ) { jtextarea19 . setbackground ( c [ i ] ) ; } if ( jtextarea20 . gettext ( ) . equalsignorecase ( s [ i ] ) ) { jtextarea20 . setbackground ( c [ i ] ) ; } } int [ ] cp = g . crossgetter ( ) ; s [ 0 ] = jtextarea11 . gettext ( ) ; s [ 1 ] = jtextarea12 . gettext ( ) ; s [ 2 ] = jtextarea13 . gettext ( ) ; s [ 3 ] = jtextarea14 . gettext ( ) ; s [ 4 ] = jtextarea15 . gettext ( ) ; s [ 5 ] = jtextarea16 . gettext ( ) ; s [ 6 ] = jtextarea17 . gettext ( ) ; s [ 7 ] = jtextarea18 . gettext ( ) ; s [ 8 ] = jtextarea19 . gettext ( ) ; s [ 9 ] = jtextarea20 . gettext ( ) ; s1 [ 0 ] = s [ 0 ] . substring ( 0 , cp [ 0 ] ) ; s1 [ 1 ] = s [ 0 ] . substring ( cp [ 0 ] ) ; s1 [ 2 ] = s [ 1 ] . substring ( 0 , cp [ 0 ] ) ; s1 [ 3 ] = s [ 1 ] . substring ( cp [ 0 ] ) ; s1 [ 4 ] = s [ 2 ] . substring ( 0 , cp [ 1 ] ) ; s1 [ 5 ] = s [ 2 ] . substring ( cp [ 1 ] ) ; s1 [ 6 ] = s [ 3 ] . substring ( 0 , cp [ 1 ] ) ; s1 [ 7 ] = s [ 3 ] . substring ( cp [ 1 ] ) ; s1 [ 8 ] = s [ 4 ] . substring ( 0 , cp [ 2 ] ) ; s1 [ 9 ] = s [ 4 ] . substring ( cp [ 2 ] ) ; s1 [ 10 ] = s [ 5 ] . substring ( 0 , cp [ 2 ] ) ; s1 [ 11 ] = s [ 5 ] . substring ( cp [ 2 ] ) ; s1 [ 12 ] = s [ 6 ] . substring ( 0 , cp [ 3 ] ) ; s1 [ 13 ] = s [ 6 ] . substring ( cp [ 3 ] ) ; s1 [ 14 ] = s [ 7 ] . substring ( 0 , cp [ 3 ] ) ; s1 [ 15 ] = s [ 7 ] . substring ( cp [ 3 ] ) ; s1 [ 16 ] = s [ 8 ] . substring ( 0 , cp [ 4 ] ) ; s1 [ 17 ] = s [ 8 ] . substring ( cp [ 4 ] ) ; s1 [ 18 ] = s [ 9 ] . substring ( 0 , cp [ 4 ] ) ; s1 [ 19 ] = s [ 9 ] . substring ( cp [ 4 ] ) ; jtextarea41 . settext ( s1 [ 0 ] ) ; jtextarea51 . settext ( s1 [ 1 ] ) ; jtextarea42 . settext ( s1 [ 2 ] ) ; jtextarea52 . settext ( s1 [ 3 ] ) ; jtextarea43 . settext ( s1 [ 4 ] ) ; jtextarea53 . settext ( s1 [ 5 ] ) ; jtextarea44 . settext ( s1 [ 6 ] ) ; jtextarea54 . settext ( s1 [ 7 ] ) ; jtextarea45 . settext ( s1 [ 8 ] ) ; jtextarea55 . settext ( s1 [ 9 ] ) ; jtextarea46 . settext ( s1 [ 10 ] ) ; jtextarea56 . settext ( s1 [ 11 ] ) ; jtextarea47 . settext ( s1 [ 12 ] ) ; jtextarea57 . settext ( s1 [ 13 ] ) ; jtextarea48 . settext ( s1 [ 14 ] ) ; jtextarea58 . settext ( s1 [ 15 ] ) ; jtextarea49 . settext ( s1 [ 16 ] ) ; jtextarea59 . settext ( s1 [ 17 ] ) ; jtextarea50 . settext ( s1 [ 18 ] ) ; jtextarea60 . settext ( s1 [ 19 ] ) ; s [ 0 ] = g . poolcrossover . get ( 0 ) ; s [ 1 ] = g . poolcrossover . get ( 1 ) ; s [ 2 ] = g . poolcrossover . get ( 2 ) ; s [ 3 ] = g . poolcrossover . get ( 3 ) ; s [ 4 ] = g . poolcrossover . get ( 4 ) ; s [ 5 ] = g . poolcrossover . get ( 5 ) ; s [ 6 ] = g . poolcrossover . get ( 6 ) ; s [ 7 ] = g . poolcrossover . get ( 7 ) ; s [ 8 ] = g . poolcrossover . get ( 8 ) ; s [ 9 ] = g . poolcrossover . get ( 9 ) ; jtextarea21 . settext ( s [ 0 ] ) ; jtextarea22 . settext ( s [ 1 ] ) ; jtextarea23 . settext ( s [ 2 ] ) ; jtextarea24 . settext ( s [ 3 ] ) ; jtextarea25 . settext ( s [ 4 ] ) ; jtextarea26 . settext ( s [ 5 ] ) ; jtextarea27 . settext ( s [ 6 ] ) ; jtextarea28 . settext ( s [ 7 ] ) ; jtextarea29 . settext ( s [ 8 ] ) ; jtextarea30 . settext ( s [ 9 ] ) ; int [ ] mp = g . mutationgetter ( ) ; arraylist < string > mutate = g . poolmutation ; for ( i = 0 ; i < 10 ; i ++ ) { s [ i ] = mutate . get ( i ) ; s1 [ i ] = s [ i ] . substring ( 0 , mp [ i ] ) + "==" + s [ i ] . charat ( mp [ i ] ) + "==" + s [ i ] . substring ( mp [ i ] + 1 ) ; } jtextarea31 . settext ( s1 [ 0 ] ) ; jtextarea32 . settext ( s1 [ 1 ] ) ; jtextarea33 . settext ( s1 [ 2 ] ) ; jtextarea34 . settext ( s1 [ 3 ] ) ; jtextarea35 . settext ( s1 [ 4 ] ) ; jtextarea36 . settext ( s1 [ 5 ] ) ; jtextarea37 . settext ( s1 [ 6 ] ) ; jtextarea38 . settext ( s1 [ 7 ] ) ; jtextarea39 . settext ( s1 [ 8 ] ) ; jtextarea40 . settext ( s1 [ 9 ] ) ; enlightenment1 . settext ( integer . tostring ( g . fitnessfunction ( jtextarea31 . gettext ( ) ) ) ) ; enlightenment2 . settext ( integer . tostring ( g . fitnessfunction ( jtextarea32 . gettext ( ) ) ) ) ; enlightenment3 . settext ( integer . tostring ( g . fitnessfunction ( jtextarea33 . gettext ( ) ) ) ) ; enlightenment4 . settext ( integer . tostring ( g . fitnessfunction ( jtextarea34 . gettext ( ) ) ) ) ; enlightenment5 . settext ( integer . tostring ( g . fitnessfunction ( jtextarea35 . gettext ( ) ) ) ) ; enlightenment6 . settext ( integer . tostring ( g . fitnessfunction ( jtextarea36 . gettext ( ) ) ) ) ; enlightenment7 . settext ( integer . tostring ( g . fitnessfunction ( jtextarea37 . gettext ( ) ) ) ) ; enlightenment8 . settext ( integer . tostring ( g . fitnessfunction ( jtextarea38 . gettext ( ) ) ) ) ; enlightenment9 . settext ( integer . tostring ( g . fitnessfunction ( jtextarea39 . gettext ( ) ) ) ) ; enlightenment10 . settext ( integer . tostring ( g . fitnessfunction ( jtextarea40 . gettext ( ) ) ) ) ; }
va	8	public static void main ( string [ ] args ) { keyspacetest test = new keyspacetest ( ) ; system . out . println ( "instantiates cluster<litcomma> keyspace and column family" ) ; test . createkeyspace ( ) ; system . out . println ( "insert a row in " + def_user_cf_name ) ; test . update ( "key1" , "alan" , "chang" ) ; system . out . println ( "reading data" ) ; test . read ( "key1" ) ; system . out . println ( "updating a row in" + def_user_cf_name ) ; test . update ( "key1" , "michelle" , "gomez" ) ; system . out . println ( "reading data" ) ; test . read ( "key1" ) ; system . out . println ( "deleteing a row in" + def_user_cf_name ) ; test . delete ( "key1" ) ; system . out . println ( "reading non existing data" ) ; test . read ( "key1" ) ; system . out . println ( "" ) ; string key = "tim_johnson" ; system . out . println ( "retrive the customer " + key ) ; map < string , string > customer3 = test . readcustomer ( key ) ; test . printmap ( customer3 ) ; system . out . println ( "" ) ; string first = "tim" ; string last = "johnson" ; system . out . println ( "insert new customer" ) ; map < string , string > customer = test . buildcustomermap ( first , last ) ; test . printmap ( customer ) ; test . update ( key , customer ) ; system . out . println ( "" ) ; system . out . println ( "retrive the customer<litcomma> again " + key ) ; map < string , string > customer2 = test . readcustomer ( key ) ; test . printmap ( customer2 ) ; test . printmapv2 ( customer2 ) ; system . out . println ( "" ) ; boolean ret = test . equalmaps ( customer , customer2 ) ; system . out . println ( "equalmaps(customer<litcomma> customer2): " + ret ) ; test . dropkeyspace ( ) ; }
va	10	public static void main ( string [ ] args ) { chessman a = new chessman ( 1 ) ; chessman b = new chessman ( 2 ) ; chessman c = new chessman ( 3 ) ; chessman d = new chessman ( 4 ) ; chessman e = new chessman ( 5 ) ; chessman f = new chessman ( 6 ) ; list < chessman > list = new arraylist < chessman > ( ) ; list . add ( a ) ; list . add ( b ) ; list . add ( c ) ; list . add ( d ) ; list . add ( e ) ; list . add ( f ) ; int x = 6 ; int y = 6 ; chessboard board = new chessboard ( x , y , list ) ; board . init ( ) ; board . printchessboard ( ) ; }
va	7	public message receivemessage ( ) throws usbexception { usbendpoint inendpoint = this . iface . getusbendpoint ( this . inendpoint ) ; usbpipe inpipe = inendpoint . getusbpipe ( ) ; inpipe . open ( ) ; try { byte [ ] headerbytes = new byte [ messageheader . size ] ; int received = inpipe . syncsubmit ( headerbytes ) ; if ( received != messageheader . size ) throw new invalidmessageexception ( "invalid adb message header size: " + received ) ; messageheader header = new messageheader ( headerbytes ) ; if ( ! header . isvalid ( ) ) throw new invalidmessageexception ( "adb message header checksum failure" ) ; byte [ ] data = new byte [ header . getdatalength ( ) ] ; received = inpipe . syncsubmit ( data ) ; if ( received != header . getdatalength ( ) ) throw new invalidmessageexception ( "adb message data size mismatch. should be " + header . getdatalength ( ) + " but is " + received ) ; message message = message . create ( header , data ) ; if ( ! message . isvalid ( ) ) throw new invalidmessageexception ( "adb message data checksum failure" ) ; return message ; } finally { inpipe . close ( ) ; } }
va	4	public static string getworkingdirectory ( ) { string home = system . getproperty ( "user.home" , "." ) ; file dir ; string os = system . getproperty ( "os.name" ) . tolowercase ( ) ; if ( os . contains ( "linux" ) || os . contains ( "unix" ) || os . contains ( "sunos" ) || os . contains ( "solaris" ) ) { dir = new file ( home , ( new stringbuilder ( ) ) . append ( '.' ) . append ( unity . folder ) . append ( '/' ) . tostring ( ) ) ; } else if ( os . contains ( "win" ) ) { string s2 = system . getenv ( "appdata" ) ; if ( s2 != null ) { dir = new file ( s2 , ( new stringbuilder ( ) ) . append ( "." ) . append ( unity . folder ) . append ( '/' ) . tostring ( ) ) ; } else { dir = new file ( home , ( new stringbuilder ( ) ) . append ( '.' ) . append ( unity . folder ) . append ( '/' ) . tostring ( ) ) ; } } else if ( os . contains ( "macos" ) ) { dir = new file ( home , ( new stringbuilder ( ) ) . append ( "library/application support/" ) . append ( unity . folder ) . tostring ( ) ) ; } else { dir = new file ( home , ( new stringbuilder ( ) ) . append ( unity . folder ) . append ( '/' ) . tostring ( ) ) ; } if ( ! dir . exists ( ) && ! dir . mkdirs ( ) ) { throw new runtimeexception ( ( new stringbuilder ( ) ) . append ( "the working directory could not be created: " ) . append ( dir ) . tostring ( ) ) ; } else { return dir . getabsolutepath ( ) ; } }
va	1	public node poll ( ) { node minnode = new node ( ) ; if ( list . size ( ) <= 1 ) { system . out . println ( "the priority is empty!" ) ; return minnode ; } minnode = this . list . get ( 1 ) ; this . list . set ( 1 , this . list . get ( this . list . size ( ) - 1 ) ) ; this . list . remove ( this . list . size ( ) - 1 ) ; this . minheapify ( this . list , 1 ) ; return minnode ; }
va	10	@ override public void monitor ( ) { try { as400 as400 = new as400 ( hostname ) ; as400 . setuserid ( username ) ; as400 . setpassword ( password ) ; rmessagequeue messagequeue = new rmessagequeue ( as400 , "/qsys.lib/qsysopr.msgq" ) ; integer intseverity = new integer ( 40 ) ; messagequeue . setselectionvalue ( rmessagequeue . severity_criteria , intseverity ) ; messagequeue . open ( ) ; messagequeue . waitforcomplete ( ) ; stringbuffer messagetext = new stringbuffer ( ) ; int returnstatus = 0 ; long numberofmessages = messagequeue . getlistlength ( ) ; for ( long i = 0 ; i < numberofmessages ; ++ i ) { rqueuedmessage queuedmessage = ( rqueuedmessage ) messagequeue . resourceat ( i ) ; int messageinstring = queuedmessage . tostring ( ) . indexof ( strmsgs ) ; int messageinmessagetext = messagetext . tostring ( ) . indexof ( queuedmessage . getattributevalue ( rqueuedmessage . message_text ) . tostring ( ) ) ; if ( messageinstring > - 1 && messageinmessagetext == - 1 ) { if ( messageinstring > - 1 ) { messagetext . append ( queuedmessage . getattributevalue ( rqueuedmessage . message_text ) ) ; returnstatus = 1 ; } } } addvariable ( "messagecount" , numberofmessages ) ; messagequeue . close ( ) ; if ( returnstatus == 1 ) { message = "ptfs to install. \\r" + messagetext ; setstate ( monitorstate . warn ) ; setmessage ( message ) ; } if ( returnstatus == 0 ) { message = "no ptfs to install." ; setstate ( monitorstate . ok ) ; setmessage ( message ) ; } as400 . disconnectallservices ( ) ; } catch ( exception e ) { setmessage ( "monitoras400ptf failed \\r" + e . getmessage ( ) ) ; setstate ( monitorstate . crit ) ; } }
va	2	synchronized public static void addorupdaterequestamount ( string ip , string timestamp ) { requests req ; entitymanager manager = jputil . getinstance ( ) . getmanager ( ) ; manager . gettransaction ( ) . begin ( ) ; try { req = manager . createnamedquery ( "requests.findbyip" , requests . class ) . setparameter ( "ip" , ip ) . getsingleresult ( ) ; req . setrequestcount ( req . getrequestcount ( ) + 1 ) ; req . settimelastrequest ( timestamp ) ; manager . merge ( req ) ; } catch ( noresultexception ex ) { req = new requests ( ip , 1 , timestamp ) ; manager . persist ( req ) ; } manager . gettransaction ( ) . commit ( ) ; }
va	5	public arraylist < sentence > getnextpossiblesenses ( ) { arraylist < sentence > sl = new arraylist < sentence > ( ) ; list < word > words = joinsubjectobject ( ) ; for ( int i = 0 ; i < words . size ( ) ; i ++ ) { if ( words . get ( i ) . possibletypessize ( ) > 1 ) { sentence s = new sentence ( this ) ; list < word > swords = s . joinsubjectobject ( ) ; swords . get ( i ) . removefirstwordtype ( ) ; sl . add ( s ) ; } } return sl ; }
va	10	public board choosemove ( ) throws exception { int ties = 1 ; double bestvalue = double . negative_infinity , currentvalue ; board bestmove = null , currentmove ; double [ ] results = new double [ tateti . max_cells * tateti . max_cells ] ; linkedlist < board > availablemoves = eg . getavailablemovesforplayer ( cellvalue , currentboard ) ; iterator it = availablemoves . iterator ( ) ; random rand = new random ( ) ; while ( it . hasnext ( ) ) { currentmove = ( board ) it . next ( ) ; currentvalue = vestimate ( currentmove , false ) ; if ( currentvalue >= bestvalue ) { if ( currentvalue == bestvalue ) { bestmove = ( math . random ( ) >= ( 0.5 / ties ) ) ? bestmove : currentmove ; ties ++ ; } else { bestmove = currentmove ; } bestvalue = currentvalue ; } } for ( int i = 0 ; i < availablemoves . size ( ) ; i ++ ) results [ i ] = vestimate ( availablemoves . get ( i ) , false ) ; if ( tateti . print ) { for ( int i = 0 ; i < availablemoves . size ( ) ; i ++ ) { if ( results [ i ] == bestvalue ) { system . out . println ( "movida con puntaje maximo: " ) ; vestimate ( availablemoves . get ( i ) , true ) ; availablemoves . get ( i ) . print ( ) ; system . out . println ( "puntaje: " + results [ i ] ) ; } } if ( bestmove != null ) { system . out . println ( "movida elegida: " ) ; bestmove . print ( ) ; system . out . println ( "value for best move: " + bestvalue ) ; vestimate ( bestmove , true ) ; } } return bestmove ; }
va	5	private list < string > parsefiredepartments ( node node ) { element element = ( element ) node ; list < string > firedepartments = new arraylist < string > ( ) ; nodelist destinations = element . getelementsbytagname ( "destination" ) ; for ( int i = 0 ; i < destinations . getlength ( ) ; i ++ ) { node destination = destinations . item ( i ) ; firedepartments . add ( destination . gettextcontent ( ) + " (" + destination . getattributes ( ) . getnameditem ( "id" ) + ")" ) ; } return firedepartments ; }
va	4	public string consultarcontacto ( string string , string string2 ) { iterator < contacto > iter = this . agenda . iterator ( ) ; contacto co , c ; string s = "" ; c = new contacto ( string , string2 , null , null ) ; if ( this . agenda . contains ( c ) ) { while ( iter . hasnext ( ) ) { co = iter . next ( ) ; if ( co . compareto ( c ) == 0 ) s = co . tostring ( ) ; } return s ; } return null ; }
va	6	private static string infix2postfix ( string [ ] tokens ) throws calcexception { double c ; string token ; postfix = new stringbuilder ( ) ; opstack = new stack < operator > ( ) ; brstack = new stack < bracket > ( ) ; intstack = new stack < integer > ( ) ; operator op ; bracket br ; int i , rpos ; for ( i = 0 ; i < tokens . length ; i ++ ) { token = tokens [ i ] ; if ( ( op = operator . find ( token ) ) != null ) { nextop ( op ) ; } else if ( ( br = bracket . isopen ( token ) ) != null ) { opstack . push ( operator . skp ) ; brstack . push ( br ) ; intstack . push ( i ) ; } else if ( ( br = bracket . isclosed ( token ) ) != null ) { intstack . push ( i ) ; nextclosed ( br ) ; } else try { c = double . valueof ( token ) ; postfix . append ( token ) ; postfix . append ( " " ) ; } catch ( numberformatexception e ) { throw new calcexception ( "parse error: " + token ) ; } } while ( ! opstack . empty ( ) ) { op = opstack . pop ( ) ; if ( op == operator . skp ) { rpos = intstack . pop ( ) ; throw new calcexception ( string . format ( "mismatched brackets: %s at position %d" , tokens [ rpos ] , rpos + 1 ) ) ; } postfix . append ( op ) ; postfix . append ( " " ) ; } return postfix . tostring ( ) ; }
va	3	public static boolean checkpermutation ( string str1 , string str2 ) { if ( null == str1 || null == str2 || str1 . isempty ( ) || str2 . isempty ( ) ) { return false ; } if ( str1 . length ( ) != str2 . length ( ) ) { return false ; } map < character , integer > map = new hashmap < character , integer > ( ) ; int len = str1 . length ( ) - 1 ; while ( len >= 0 ) { if ( map . containskey ( str1 . charat ( len ) ) ) { integer val = map . get ( str1 . charat ( len ) ) + 1 ; map . put ( str1 . charat ( len ) , val ) ; } else { map . put ( str1 . charat ( len ) , 0 ) ; } len -- ; } len = str2 . length ( ) - 1 ; while ( len >= 0 ) { if ( ! map . containskey ( str2 . charat ( len ) ) ) { return false ; } len -- ; } return true ; }
va	1	public matrix getrotation ( ) { matrix r = new matrix ( ) ; r . set ( 0 , 0 , get ( 0 , 0 ) ) ; r . set ( 1 , 0 , get ( 1 , 0 ) ) ; r . set ( 2 , 0 , get ( 2 , 0 ) ) ; r . set ( 0 , 1 , get ( 0 , 1 ) ) ; r . set ( 1 , 1 , get ( 1 , 1 ) ) ; r . set ( 2 , 1 , get ( 2 , 1 ) ) ; r . set ( 0 , 2 , get ( 0 , 2 ) ) ; r . set ( 1 , 2 , get ( 1 , 2 ) ) ; r . set ( 2 , 2 , get ( 2 , 2 ) ) ; return r ; }
va	9	public static void main ( string [ ] args ) { string s0 = "print string method" ; print ( s0 ) ; string s1 = "println string method" ; println ( s1 ) ; string s2 = "%s<litcomma> %s<litcomma> %s" ; int i0 = 22 ; printf ( s2 , s0 , s1 , i0 ) ; println ( "" ) ; string si = "%s<litcomma> " ; list < integer > iarr1 = range ( 5 ) ; for ( integer i : iarr1 ) { printf ( si , i ) ; } println ( ) ; list < integer > iarr2 = range ( 5 , 10 ) ; for ( integer i : iarr2 ) { printf ( si , i ) ; } println ( ) ; list < integer > iarr3 = range ( 10 , 20 , 2 ) ; for ( integer i : iarr3 ) { printf ( si , i ) ; } println ( "" , "" ) ; }
va	8	@ override public void solve ( ) { map < string , list < long > > map = new hashmap < string , list < long > > ( ) ; for ( long i = 1000 ; i < 10000 ; i ++ ) { long cube = i * i * i ; char [ ] chararray = cube . tostring ( ) . tochararray ( ) ; arrays . sort ( chararray ) ; string sortedcube = string . valueof ( chararray ) ; if ( ! map . containskey ( sortedcube ) ) { list < long > list = new arraylist < long > ( ) ; map . put ( sortedcube , list ) ; } map . get ( sortedcube ) . add ( cube ) ; } list < long > minlist = new arraylist < long > ( ) ; for ( map . entry < string , list < long > > entry : map . entryset ( ) ) { if ( entry . getvalue ( ) . size ( ) == 5 ) { minlist . add ( entry . getvalue ( ) . get ( 0 ) ) ; } } if ( ! minlist . isempty ( ) ) { system . out . println ( collections . min ( minlist ) ) ; } }
va	9	private void update ( httpservletrequest req , httpservletresponse resp ) throws servletexception , ioexception , sqlexception { int id = integer . parseint ( req . getparameter ( "id" ) ) ; string title = req . getparameter ( "title" ) ; string author = req . getparameter ( "author" ) ; string press = req . getparameter ( "press" ) ; string picture = req . getparameter ( "picture" ) ; string date = req . getparameter ( "date" ) ; string price = req . getparameter ( "price" ) ; string amount = req . getparameter ( "amount" ) ; string sql = "update book set title=?<litcomma> author=?<litcomma> press=?<litcomma> picture=?<litcomma> date=?<litcomma> price=?<litcomma> amount=? where id=?" ; preparedstatement = connection . preparestatement ( sql ) ; preparedstatement . setstring ( 1 , title ) ; preparedstatement . setstring ( 2 , author ) ; preparedstatement . setstring ( 3 , press ) ; preparedstatement . setstring ( 4 , picture ) ; preparedstatement . setstring ( 5 , date ) ; preparedstatement . setstring ( 6 , price ) ; preparedstatement . setstring ( 7 , amount ) ; preparedstatement . setint ( 8 , id ) ; preparedstatement . executeupdate ( ) ; db . close ( null , preparedstatement , null ) ; resp . sendredirect ( "book?action=list" ) ; }
va	1	public void validate ( object target , errors errors ) { person person = ( person ) target ; if ( person != null ) { if ( person . getname ( ) != null ) { if ( person . getname ( ) . length ( ) < min_name ) { errors . rejectvalue ( "name" , "validation.name" , new object [ ] { new integer ( min_name ) } , "you're too young for this service" ) ; } } else { errors . rejectvalue ( "name" , "validation.name" , new object [ ] { new integer ( min_name ) } , "you're too young for this service" ) ; } if ( person . getage ( ) != null ) { if ( person . getage ( ) < min_age ) { errors . rejectvalue ( "age" , "validation.age" , new object [ ] { new integer ( min_age ) } , "you're too young for this service" ) ; } } else { errors . rejectvalue ( "age" , "validation.age" , new object [ ] { new integer ( min_age ) } , "you're too young for this service" ) ; } } }
va	7	private list communicate ( list request ) { utilities . dump ( request ) ; if ( this . getcurrentdomain ( ) == null ) return null ; list response = null ; try { inetaddress host = inetaddress . getbyname ( this . getcurrentdomain ( ) . gethost ( ) ) ; socket socket = new socket ( host , 80 ) ; printwriter out = new printwriter ( socket . getoutputstream ( ) ) ; scanner in = new scanner ( socket . getinputstream ( ) ) ; for ( iterator i = request . iterator ( ) ; i . hasnext ( ) ; ) out . println ( ( string ) i . next ( ) ) ; out . println ( ) ; out . flush ( ) ; response = new arraylist < string > ( ) ; while ( in . hasnextline ( ) ) { string line = in . nextline ( ) ; response . add ( line ) ; } } catch ( ioexception e ) { e . printstacktrace ( ) ; } return response ; }
va	9	private void loadxmlinfo ( node node ) { nodelist nodelist = node . getchildnodes ( ) ; for ( int i = 0 ; nodelist != null && i != nodelist . getlength ( ) ; ++ i ) { node nodelis = nodelist . item ( i ) ; if ( nodelis . getnodetype ( ) == node . text_node ) { continue ; } else if ( nodelis . getnodename ( ) . trim ( ) . equalsignorecase ( "bean" ) ) { attributemap attributemap = ( attributemap ) nodelis . getattributes ( ) ; node id = attributemap . getnameditem ( "id" ) ; node regxurl = attributemap . getnameditem ( "regx-url" ) ; node htmlbean = attributemap . getnameditem ( "htmlbean" ) ; regexp . put ( id . getnodevalue ( ) , pattern . compile ( regxurl . getnodevalue ( ) ) ) ; eleblock eleblock = tagparser . parser ( new inputsource ( path + "/" + htmlbean . getnodevalue ( ) ) ) ; mapele . put ( id . getnodevalue ( ) , eleblock ) ; } else if ( nodelis . getnodename ( ) . trim ( ) . equalsignorecase ( "include" ) ) { attributemap attributemap = ( attributemap ) nodelis . getattributes ( ) ; node file = attributemap . getnameditem ( "file" ) ; load ( new inputsource ( path + "/" + file . getnodevalue ( ) ) ) ; } } }
va	1	private object getprimitivefieldvalue ( content content , class classtype ) { object primitivetoreturn = null ; if ( classtype . equals ( int . class ) ) primitivetoreturn = integer . parseint ( content . getvalue ( ) ) ; else if ( classtype . equals ( short . class ) ) primitivetoreturn = short . parseshort ( content . getvalue ( ) ) ; else if ( classtype . equals ( byte . class ) ) primitivetoreturn = byte . parsebyte ( content . getvalue ( ) ) ; else if ( classtype . equals ( long . class ) ) primitivetoreturn = long . parselong ( content . getvalue ( ) ) ; else if ( classtype . equals ( float . class ) ) primitivetoreturn = float . parsefloat ( content . getvalue ( ) ) ; else if ( classtype . equals ( double . class ) ) primitivetoreturn = double . parsedouble ( content . getvalue ( ) ) ; else if ( classtype . equals ( char . class ) ) primitivetoreturn = new character ( content . getvalue ( ) . charat ( 0 ) ) ; return primitivetoreturn ; }
va	5	public static boolean checknearlysquareimage ( string filepath , float nearlyvalue ) throws ioexception { file file = new file ( filepath ) ; bufferedimage buff = fileutil . getimageinfo ( file ) ; float width = buff . getwidth ( ) ; float height = buff . getheight ( ) ; float s = 0 ; if ( width == 0 || height == 0 ) { return false ; } if ( height / width < 1 + nearlyvalue && width / height < 1 + nearlyvalue ) { return true ; } else { return false ; } }
va	2	private static void processrandommode ( int numvertices , double density ) { graph graph = graphgenerator . generategraph ( numvertices , density ) ; system . out . println ( "graph size = " + numvertices + "<litcomma> density = " + density ) ; system . out . println ( ) ; system . out . println ( "running simple scheme" ) ; system . out . println ( "---------------------" ) ; list < edge > generatedmst = mstgenerator . generatemst ( new simpleschememstgenerator ( ) , graph ) ; printtimeandcost ( mstgenerator . getruntime ( ) , generatedmst ) ; system . out . println ( "running f-heap scheme" ) ; system . out . println ( "---------------------" ) ; generatedmst = mstgenerator . generatemst ( new fheapschememstgenerator ( ) , graph ) ; printtimeandcost ( mstgenerator . getruntime ( ) , generatedmst ) ; }
va	7	public static boolean isprocessrunning ( string process ) { boolean found = false ; try { file file = file . createtempfile ( "checkifrunning" , ".vbs" ) ; file . deleteonexit ( ) ; filewriter filewriter = new java . io . filewriter ( file ) ; string vbs = "set wshshell = wscript.createobject(\\"wscript.shell\\")\\n" + "set locator = createobject(\\"wbemscripting.swbemlocator\\")\\n" + "set service = locator.connectserver()\\n" + "set processes = service.execquery _\\n" + " (\\"select * from win32_process where name='" + process + "'\\")\\n" + "for each process in processes\\n" + "wscript.echo process.name \\n" + "next\\n" + "set wshshell = nothing\\n" ; filewriter . write ( vbs ) ; filewriter . close ( ) ; process p = runtime . getruntime ( ) . exec ( "cscript //nologo " + file . getpath ( ) ) ; bufferedreader input = new bufferedreader ( new inputstreamreader ( p . getinputstream ( ) ) ) ; string line ; line = input . readline ( ) ; if ( line != null ) { if ( line . equals ( process ) ) { found = true ; } } input . close ( ) ; } catch ( ioexception ex ) { ex . printstacktrace ( ) ; } return found ; }
va	5	public static void main ( string [ ] args ) { executorservice executor = executors . newfixedthreadpool ( 3 ) ; final countdownlatch latch = new countdownlatch ( 1 ) ; final locksummary_abc printer = new locksummary_abc ( ) ; for ( int i = 0 ; i < 3 ; i ++ ) { final int id = i ; executor . submit ( new runnable ( ) { @ override public void run ( ) { try { latch . await ( ) ; } catch ( interruptedexception e ) { e . printstacktrace ( ) ; } printer . print ( id ) ; } } ) ; } system . out . println ( "\u4e09\u4e2a\u4efb\u52a1\u5f00\u59cb\u987a\u5e8f\u6253\u5370\u6570\u5b57\u3002\u3002\u3002\u3002\u3002\u3002" ) ; latch . countdown ( ) ; executor . shutdown ( ) ; }
va	9	public static void checkfile ( string filename ) throws ioexception { bufferedreader file = new bufferedreader ( new inputstreamreader ( new fileinputstream ( filename ) ) ) ; vector < string > imports = new vector < string > ( ) ; vector < string > packages = new vector < string > ( ) ; string line = file . readline ( ) ; int linenumber = 0 ; while ( line != null ) { line = line . trim ( ) ; if ( line . startswith ( "import " ) ) { if ( line . endswith ( ".*;" ) ) { packages . add ( line . replace ( "import " , "" ) ) ; } else { string classname = line . substring ( line . lastindexof ( "." ) + 1 , line . length ( ) - 1 ) ; imports . add ( classname ) ; } } else { for ( int i = 0 ; i < imports . size ( ) ; i ++ ) { string importedclass = imports . get ( i ) ; if ( line . indexof ( importedclass ) != - 1 && ! line . startswith ( "//" ) && ! line . startswith ( "*" ) && ! line . startswith ( "/*" ) ) { imports . remove ( importedclass ) ; i -- ; } } } line = file . readline ( ) ; linenumber ++ ; } if ( imports . size ( ) > 0 || packages . size ( ) > 0 ) { system . out . println ( filename ) ; if ( imports . size ( ) > 0 ) { system . out . println ( "  unused imports:" ) ; for ( string importedclass : imports ) { system . out . println ( "    " + importedclass ) ; } } if ( packages . size ( ) > 0 ) { system . out . println ( "  package imports:" ) ; for ( string packagename : packages ) { system . out . println ( "    " + packagename ) ; } } } file . close ( ) ; }
va	5	public double eval ( double x ) { stack < double > numstack = new stack < double > ( ) ; for ( int i = 0 ; i < postfixtokens . size ( ) ; i ++ ) { if ( isnumeric ( postfixtokens . get ( i ) ) ) numstack . push ( double . parsedouble ( postfixtokens . get ( i ) ) ) ; else if ( postfixtokens . get ( i ) . equals ( "x" ) ) numstack . push ( x ) ; else if ( isspecialops ( postfixtokens . get ( i ) ) ) { double num = numstack . pop ( ) ; numstack . push ( perform ( postfixtokens . get ( i ) , num ) ) ; } else { try { double num2 = numstack . pop ( ) ; double num1 = numstack . pop ( ) ; numstack . push ( perform ( postfixtokens . get ( i ) , num1 , num2 ) ) ; } catch ( illegalargumentexception e ) { system . out . println ( e . getmessage ( ) ) ; } } } return numstack . pop ( ) ; }
va	3	@ test public void querybindlist ( ) { map < string , string > optional = new hashmap < string , string > ( ) ; optional . put ( channel . channel_id , channelid ) ; channel channel = new channel ( ) ; channel . initialize ( apikey , secretkey , null ) ; jsonobject result = channel . querybindlist ( userid , optional ) ; if ( channel . errcode == 0 ) { assert . assertnotnull ( result ) ; } else { system . out . println ( "error_code: " + channel . errcode + "; error_msg: " + channel . errmsg ) ; } }
va	8	public void buildgraph ( ) { int numpeople = integer . parseint ( sc . nextline ( ) ) ; graph = new hashmap < string , node > ( ) ; while ( graph . size ( ) < numpeople && sc . hasnextline ( ) ) { node temp = new node ( makeuser ( sc . nextline ( ) ) , null ) ; graph . put ( temp . data . name , temp ) ; } while ( sc . hasnextline ( ) ) { string line = sc . nextline ( ) ; line . tolowercase ( ) ; scanner linesc = new scanner ( line ) . usedelimiter ( "\\\\s*\\\\|\\\\s*" ) ; node firstfriend = graph . get ( linesc . next ( ) ) ; node firstfriendcopy = new node ( firstfriend . data , null ) ; node secondfriend = graph . get ( linesc . next ( ) ) ; node secondfriendcopy = new node ( secondfriend . data , null ) ; makefriendships ( firstfriend , secondfriendcopy ) ; makefriendships ( secondfriend , firstfriendcopy ) ; } }
va	2	@ suppresswarnings ( "deprecation" ) public void actionperformed ( actionevent e ) { if ( ! ( username . gettext ( ) . equals ( "" ) ) && ( ! ( password . getpassword ( ) . tostring ( ) ) . equals ( "" ) ) ) { try { document doc = jsoup . connect ( "http://uniteddev.com/mc_auth.php?username=" + username . gettext ( ) + "&password=" + new string ( password . getpassword ( ) ) ) . get ( ) ; string response = doc . text ( ) ; system . out . println ( "authentication: " + response ) ; if ( response . equals ( "success" ) ) { invalid_login_lbl . setvisible ( false ) ; prefs . put ( "username" , username . gettext ( ) ) ; window . setvisible ( false ) ; window . dispose ( ) ; networkstatus ( "stop" ) ; try { minecraft . main ( username . gettext ( ) , new string ( password . getpassword ( ) ) , prefs . get ( "ram_size" , default_ram ) ) ; } catch ( ioexception e1 ) { e1 . printstacktrace ( ) ; } networkprobe . stop ( ) ; } else { invalid_login_lbl . setvisible ( true ) ; } } catch ( ioexception e1 ) { } } else { invalid_login_lbl . setvisible ( true ) ; } }
va	10	public reviewsresponse parseresponse ( string content ) { reviewsresponse response = new reviewsresponse ( ) ; try { documentbuilder builder = documentbuilderfactory . newinstance ( ) . newdocumentbuilder ( ) ; stringreader sr = new stringreader ( content ) ; inputsource is = new inputsource ( ) ; is . setcharacterstream ( sr ) ; document doc = builder . parse ( is ) ; element root = doc . getdocumentelement ( ) ; nodelist reviews = root . getelementsbytagname ( "reviews" ) ; for ( int i = 0 ; i < reviews . getlength ( ) ; i ++ ) { for ( int j = 0 ; j < reviews . item ( i ) . getchildnodes ( ) . getlength ( ) ; j ++ ) { node child = reviews . item ( i ) . getchildnodes ( ) . item ( j ) ; if ( child . getnodename ( ) . equals ( "review" ) ) { response . addreview ( parsereview ( child ) ) ; } } } } catch ( parserconfigurationexception e ) { e . printstacktrace ( ) ; } catch ( saxexception e ) { e . printstacktrace ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } return response ; }
va	9	private static int r0 ( boolean [ ] unused ) { counter ++ ; if ( isdone ( unused ) ) return 0 ; int max = - 1 ; index = - 1 ; int sum = 0 ; for ( int i = 0 ; i < matrix . length ; i ++ ) { if ( unused [ i ] ) { sum = matrix [ i ] [ n ] ; if ( sum == 0 ) { unused [ i ] = false ; remove ( i ) ; int r = 1 + r0 ( unused ) ; add ( i ) ; return r ; } if ( sum > max ) { max = sum ; index = i ; } } } int localindex = index ; unused [ index ] = false ; boolean [ ] clone = makeclone ( unused ) ; remove ( index ) ; int without = r0 ( clone ) ; index = localindex ; for ( int j = 0 ; j < matrix . length ; j ++ ) { if ( matrix [ index ] [ j ] == 1 && unused [ j ] ) remove ( j ) ; } clone = makeclone ( unused ) ; removeedges ( clone ) ; int with = 1 + r0 ( clone ) ; index = localindex ; add ( index ) ; for ( int j = 0 ; j < matrix . length ; j ++ ) { if ( originalmatrix [ index ] [ j ] == 1 && unused [ j ] ) { add ( j ) ; } } return math . max ( with , without ) ; }
va	1	public quaternion ( float [ ] q ) { float mag ; mag = 1.0f / ( float ) math . sqrt ( q [ 0 ] * q [ 0 ] + q [ 1 ] * q [ 1 ] + q [ 2 ] * q [ 2 ] + q [ 3 ] * q [ 3 ] ) ; x = q [ 0 ] * mag ; y = q [ 1 ] * mag ; z = q [ 2 ] * mag ; w = q [ 3 ] * mag ; }
va	6	public void run ( ) { string message ; string [ ] data ; string connect = "connect" ; string disconnect = "disconnect" ; string chat = "chat" ; try { while ( ( message = reader . readline ( ) ) != null ) { system . out . println ( "received: " + message ) ; data = message . split ( "\\21" ) ; for ( string token : data ) { system . out . println ( token ) ; } if ( data [ 2 ] . equals ( connect ) ) { broadcastframe ( ( data [ 0 ] + "\\21" + data [ 1 ] + "\\21" + chat ) ) ; useradd ( data [ 0 ] ) ; } else if ( data [ 2 ] . equals ( disconnect ) ) { broadcastframe ( ( data [ 0 ] + "\\21has logged off." + "\\21" + chat ) ) ; userremove ( data [ 0 ] ) ; } else if ( data [ 2 ] . equals ( chat ) ) { broadcastframe ( message ) ; } else { system . out . println ( "invalid frame!" ) ; } } } catch ( exception ex ) { system . out . println ( "connect was lost" ) ; clientstreams . remove ( client ) ; } }
va	9	public void searchdirectoryforplugins ( string dir ) { try { files . walk ( paths . get ( dir ) ) . foreach ( filepath -> { string file = filepath + "" ; if ( files . isregularfile ( filepath ) && file . endswith ( ".jar" ) ) { try { jarfile jar = new jarfile ( filepath + "" ) ; enumeration e = jar . entries ( ) ; class c = null ; url [ ] urls = { new url ( "jar:file:" + filepath + "!/" ) } ; java . lang . classloader cl = urlclassloader . newinstance ( urls ) ; while ( e . hasmoreelements ( ) ) { jarentry je = ( jarentry ) e . nextelement ( ) ; if ( je . isdirectory ( ) || ! je . getname ( ) . endswith ( ".class" ) ) { continue ; } string classname = je . getname ( ) . substring ( 0 , je . getname ( ) . length ( ) - 6 ) ; classname = classname . replace ( '/' , '.' ) ; c = cl . loadclass ( classname ) ; if ( c . getname ( ) . contains ( "main" ) ) { object i = c . newinstance ( ) ; ( ( base ) i ) . setmarla ( this ) ; if ( i instanceof output ) { outputs . add ( ( output ) i ) ; } else if ( i instanceof activator ) { activators . add ( ( activator ) i ) ; } else if ( i instanceof thoughts ) { } } } } catch ( exception e ) { } } } ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } }
va	3	private double smoothednoise2 ( int x , int y ) { double corners = ( noise2 ( x - 1 , y - 1 ) + noise2 ( x + 1 , y - 1 ) + noise2 ( x - 1 , y + 1 ) + noise2 ( x + 1 , y + 1 ) ) / 16 ; double sides = ( noise2 ( x - 1 , y ) + noise2 ( x + 1 , y ) + noise2 ( x , y - 1 ) + noise2 ( x , y + 1 ) ) / 8 ; double center = noise2 ( x , y ) / 4 ; return corners + sides + center ; }
va	6	private string parseprojectdetail ( string filepath ) { string contents = "" ; try { bufferedreader reader = new bufferedreader ( new filereader ( filepath ) ) ; string line ; while ( ( line = reader . readline ( ) ) != null ) { line = line . trim ( ) ; int equalspos = line . indexof ( "=" ) ; string key = ( equalspos >= 0 ) ? line . substring ( 0 , equalspos ) . trim ( ) : "" ; string value = ( equalspos >= 0 ) ? line . substring ( equalspos + 1 ) . trim ( ) : "" ; if ( key . equalsignorecase ( "projectname" ) ) { contents += "<h2>" + value + "</h2>" ; } else if ( ! value . isempty ( ) ) { contents += value + "<br>" ; } } reader . close ( ) ; } catch ( exception e ) { sfapexdoc . log ( "parseprojectdetail(" + filepath + "): " + e . getmessage ( ) ) ; } return contents . trim ( ) ; }
va	4	private static void merge ( int [ ] a , int [ ] temp , int leftpos , int rightpos , int rightend ) { int leftend = rightpos - 1 ; int temppos = leftpos ; int sum = rightend - leftpos + 1 ; while ( leftpos <= leftend && rightpos <= rightend ) if ( a [ leftpos ] < a [ rightpos ] ) temp [ temppos ++ ] = a [ leftpos ++ ] ; else temp [ temppos ++ ] = a [ rightpos ++ ] ; while ( leftpos <= leftend ) temp [ temppos ++ ] = a [ leftpos ++ ] ; while ( rightpos <= rightend ) temp [ temppos ++ ] = a [ rightpos ++ ] ; for ( int i = 0 ; i < sum ; i ++ , rightend -- ) a [ rightend ] = temp [ rightend ] ; }
va	9	public static void testadd ( ) throws ioexception , classnotfoundexception { btree tree = new btree ( ) ; string padding , fixedstring ; node temp = new node ( ) ; arraylist < string > testwords = new arraylist < string > ( ) ; testwords . add ( "apple" ) ; testwords . add ( "sand" ) ; testwords . add ( "math" ) ; testwords . add ( "tree" ) ; testwords . add ( "north" ) ; testwords . add ( "onion" ) ; testwords . add ( "pan" ) ; testwords . add ( "pink" ) ; testwords . add ( "pool" ) ; testwords . add ( "net" ) ; testwords . add ( "never" ) ; testwords . add ( "vincent" ) ; testwords . add ( "von" ) ; testwords . add ( "strudle" ) ; testwords . add ( "phantom" ) ; testwords . add ( "newearth" ) ; testwords . add ( "nova" ) ; testwords . add ( "nest" ) ; testwords . add ( "nerf" ) ; testwords . add ( "newyork" ) ; testwords . add ( "newguni" ) ; for ( string k : testwords ) { padding = getpadding ( k . length ( ) ) ; fixedstring = k + padding ; tree . insert ( fixedstring ) ; } for ( int i = 0 ; i < testwords . size ( ) ; i ++ ) { temp = tree . save . read ( i ) ; system . out . println ( "block number: " + temp . blocknumber ) ; for ( string s : temp . keys ) { system . out . println ( s ) ; } for ( long l : temp . links ) { system . out . println ( "blockslinks: " + l ) ; system . out . println ( "\\n" ) ; } } }
va	2	void maxslidingwindow ( int a [ ] , int n , int w , int b [ ] ) { linkedlist < integer > q = new linkedlist < integer > ( ) ; for ( int i = 0 ; i < w ; i ++ ) { while ( ! q . isempty ( ) && a [ i ] >= a [ q . getlast ( ) ] ) q . removelast ( ) ; q . addlast ( i ) ; } for ( int i = w ; i < n ; i ++ ) { b [ i - w ] = a [ q . getfirst ( ) ] ; while ( ! q . isempty ( ) && a [ i ] >= a [ q . getlast ( ) ] ) q . removelast ( ) ; while ( ! q . isempty ( ) && q . getfirst ( ) <= i - w ) q . removefirst ( ) ; q . addlast ( i ) ; } b [ n - w ] = a [ q . getfirst ( ) ] ; }
va	9	public void loadfichier ( string f ) throws ioexception { fichier = new file ( f ) ; graph = new graph ( ) ; if ( fichier . exists ( ) ) { bufferedreader br = new bufferedreader ( new filereader ( fichier ) ) ; string ligne ; nbligne = 0 ; nbcol = 0 ; while ( ( ligne = br . readline ( ) ) != null ) { nbligne ++ ; string [ ] tab = ligne . split ( "" ) ; nbcol = tab . length - 1 ; } br . close ( ) ; nodes = new node [ nbligne ] [ nbcol ] ; bufferedreader br2 = new bufferedreader ( new filereader ( fichier ) ) ; string ligne2 ; int cptligne = 0 ; while ( ( ligne2 = br2 . readline ( ) ) != null ) { string [ ] tab2 = ligne2 . split ( "" ) ; for ( int i = 1 ; i < tab2 . length ; i ++ ) { if ( tab2 [ i ] . equals ( " " ) || tab2 [ i ] . equals ( "d" ) || tab2 [ i ] . equals ( "a" ) || tab2 [ i ] . equals ( "g" ) ) { nodes [ cptligne ] [ i - 1 ] = new node ( tab2 [ i ] , i - 1 , cptligne ) ; } } cptligne ++ ; } br2 . close ( ) ; for ( int i = 0 ; i < nodes . length ; i ++ ) { for ( int j = 0 ; j < nodes [ i ] . length ; j ++ ) { if ( nodes [ i ] [ j ] != null ) { graph . registernode ( nodes [ i ] [ j ] ) ; if ( nodes [ i ] [ j ] . getid ( ) . equals ( "d" ) ) { listnodedepart . add ( nodes [ i ] [ j ] ) ; nbporte ++ ; } else if ( nodes [ i ] [ j ] . getid ( ) . equals ( "a" ) ) { listnodefromage . add ( nodes [ i ] [ j ] ) ; } if ( nodes [ i ] [ j ] . getid ( ) . equals ( "g" ) ) { if ( nodes [ i ] [ j + 1 ] != null ) { new edge ( nodes [ i ] [ j ] , nodes [ i ] [ j + 1 ] , 2 ) ; } if ( nodes [ i + 1 ] [ j ] != null ) { new edge ( nodes [ i ] [ j ] , nodes [ i + 1 ] [ j ] , 2 ) ; } } else { if ( nodes [ i ] [ j + 1 ] != null ) { new edge ( nodes [ i ] [ j ] , nodes [ i ] [ j + 1 ] , 1 ) ; } if ( nodes [ i + 1 ] [ j ] != null ) { new edge ( nodes [ i ] [ j ] , nodes [ i + 1 ] [ j ] , 1 ) ; } } } } } } }
va	10	static string retrievepredictiontree ( int [ ] vectoroutputs , string [ ] classes ) { arraylist < string > predictedclasses = new arraylist < string > ( ) ; for ( int index = ( vectoroutputs . length - 1 ) ; index >= 0 ; index -- ) { if ( vectoroutputs [ index ] == 1 ) { if ( index == ( vectoroutputs . length - 1 ) ) { predictedclasses . add ( classes [ index ] ) ; } else { int index2 = predictedclasses . size ( ) ; string nameclass = classes [ index ] ; nameclass = "^" + nameclass + "/" ; pattern pattern = pattern . compile ( nameclass ) ; int found = 0 ; for ( int k = 0 ; k < index2 ; k ++ ) { matcher m = pattern . matcher ( predictedclasses . get ( k ) ) ; if ( m . find ( ) ) { found = 1 ; break ; } } if ( found == 0 ) { predictedclasses . add ( 0 , classes [ index ] ) ; } } } } string predclasses = "" ; for ( int i = 0 ; i < predictedclasses . size ( ) ; i ++ ) { if ( i == 0 ) { predclasses = predictedclasses . get ( i ) ; } else { predclasses = predclasses + "@" + predictedclasses . get ( i ) ; } } return predclasses ; }
va	5	public boolean portavailable ( int port ) { string [ ] commands = netstatcommand ( port ) ; processbuilder pb = new processbuilder ( ) ; pb . command ( commands ) ; inputstream instream = null ; try { process process = pb . start ( ) ; myprocessutils . waitforprocess ( process , 10 , 500 ) ; instream = process . getinputstream ( ) ; string netout = ioutils . tostring ( instream ) ; return stringutils . equals ( stringutils . empty , netout ) ? true : false ; } catch ( ioexception e ) { throw myexceptionutils . uncheckexception ( e ) ; } catch ( timeoutexception e ) { throw myexceptionutils . uncheckexception ( e ) ; } finally { ioutils . closequietly ( instream ) ; } }
va	5	public string printwordtypes ( list < word > wl , int width ) { string s = "" ; for ( int i = 0 ; i < wl . size ( ) ; i ++ ) { word word = wl . get ( i ) ; string wordtypestring = "null" ; if ( word != null ) { wordtype wt = word . getwordtype ( ) ; if ( wt != null ) { wordtypestring = wt . getclass ( ) . getsimplename ( ) ; } } s += string . format ( "%" + width + "s" , wordtypestring ) ; s += " " ; } return s ; }
va	4	private static string [ ] parsequestion ( string line ) { string [ ] result = new string [ 7 ] ; string workingline = line ; int index ; for ( int i = 6 ; i > 1 ; i -- ) { index = workingline . lastindexof ( "<litcomma>" ) ; result [ i ] = workingline . substring ( index + 1 , workingline . length ( ) ) ; workingline = workingline . substring ( 0 , index ) ; } index = workingline . indexof ( "<litcomma>" ) ; result [ 0 ] = workingline . substring ( 0 , index ) ; workingline = workingline . substring ( index + 1 , workingline . length ( ) ) ; result [ 1 ] = workingline ; return result ; }
va	1	protected void doget ( httpservletrequest request , httpservletresponse response ) throws servletexception , ioexception { string action = request . getparameter ( "do" ) ; if ( "insert_data" . equals ( action ) ) { try { new setupdao ( ) . createschema ( "example_data.sql" ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } response . setheader ( "location" , "search" ) ; response . setstatus ( httpservletresponse . sc_found ) ; } else if ( "clear_data" . equals ( action ) ) { try { new dao ( ) . cleardata ( ) ; } catch ( sqlexception e ) { e . printstacktrace ( ) ; } response . setheader ( "location" , "search" ) ; response . setstatus ( httpservletresponse . sc_found ) ; } }
va	5	public string livestatus ( string streamname ) { string livestatus = "offline" ; bufferedreader readurl = null ; try { url url = new url ( "http://api.justin.tv/api/stream/list.json?jsonp=&channel=" + streamname ) ; readurl = new bufferedreader ( new inputstreamreader ( url . openstream ( ) ) ) ; string wir = readurl . readline ( ) ; string compare = "[]" ; if ( wir . equals ( compare ) ) { livestatus = "offline" ; } else { livestatus = "online" ; } } catch ( ioexception ex ) { logger . getlogger ( streamstatus . class . getname ( ) ) . log ( level . severe , null , ex ) ; logger . getlogger ( streamstatus . class . getname ( ) ) . log ( level . severe , null , ex ) ; } finally { try { readurl . close ( ) ; } catch ( ioexception ex ) { logger . getlogger ( streamstatus . class . getname ( ) ) . log ( level . severe , null , ex ) ; } } return livestatus ; }
va	1	public functions ( string x , string y , arraylist < string > pt , arraylist < string > pn , boolean isar ) { name = x ; type = y ; rtype = y ; if ( pt . size ( ) == 1 ) { ptype . add ( pt . get ( 0 ) ) ; } else { for ( int i = 0 ; i < pt . size ( ) - 1 ; i ++ ) { ptype . add ( pt . get ( i ) ) ; } } if ( pn . size ( ) == 1 ) { pname . add ( pt . get ( 0 ) ) ; } else { for ( int i = 0 ; i < pn . size ( ) - 1 ; i ++ ) { pname . add ( pn . get ( i ) ) ; } } isarray . add ( isar ) ; }
va	10	protected void doget ( httpservletrequest req , httpservletresponse resp ) throws servletexception { try { resp . setcontenttype ( "text/plain" ) ; printwriter out = resp . getwriter ( ) ; out . println ( "*** apacheds rootdse ***\\n" ) ; dircontext ctx = new initialdircontext ( this . createenv ( ) ) ; searchcontrols ctls = new searchcontrols ( ) ; ctls . setreturningattributes ( new string [ ] { "*" , "+" } ) ; ctls . setsearchscope ( searchcontrols . object_scope ) ; namingenumeration < searchresult > result = ctx . search ( "" , "(objectclass=*)" , ctls ) ; if ( result . hasmore ( ) ) { searchresult entry = result . next ( ) ; attributes as = entry . getattributes ( ) ; namingenumeration < string > ids = as . getids ( ) ; while ( ids . hasmore ( ) ) { string id = ids . next ( ) ; attribute attr = as . get ( id ) ; for ( int i = 0 ; i < attr . size ( ) ; ++ i ) { out . println ( id + ": " + attr . get ( i ) ) ; } } } ctx . close ( ) ; out . flush ( ) ; } catch ( exception e ) { throw new servletexception ( e ) ; } }
va	5	public static void main ( string [ ] args ) throws exception { mystack ms = new mystack ( 10 ) ; string s = "a{b(c[d]e)f}" ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { char c = s . charat ( i ) ; if ( c == '{' || c == '(' || c == '[' ) { ms . push ( c ) ; } else if ( c == '}' || c == ')' || c == ']' ) { if ( ! ms . isempty ( ) ) { char cc = ms . pop ( ) ; if ( ! ( ( cc == '{' && c == '}' ) || ( cc == '(' && c == ')' ) || ( cc == '[' && c == ']' ) ) ) { throw new exception ( "error<litcomma> doesn't match!" ) ; } } else { system . out . println ( "error<litcomma> doesn't match!" ) ; break ; } } } s = "a{b(c[d]e[f}" ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { char c = s . charat ( i ) ; if ( c == '{' || c == '(' || c == '[' ) { ms . push ( c ) ; } else if ( c == '}' || c == ')' || c == ']' ) { if ( ! ms . isempty ( ) ) { char cc = ms . pop ( ) ; if ( ! ( ( cc == '{' && c == '}' ) || ( cc == '(' && c == ')' ) || ( cc == '[' && c == ']' ) ) ) { throw new exception ( "exception: error<litcomma> doesn't match!" ) ; } } else { system . out . println ( "error<litcomma> doesn't match!" ) ; break ; } } } if ( ! ms . isempty ( ) ) { system . err . println ( "error<litcomma> doesn't match!" ) ; } }
va	9	public static void main ( string [ ] args ) throws ioexception { if ( args [ 0 ] . equals ( "--help" ) || args [ 0 ] . equals ( "-h" ) ) { system . out . println ( "turing machine simulator<litcomma> configured by a file which must be given in the form:\\n" + "\\n" + "<begin>\\n" + "/the content of the task<litcomma> it\\n" + "/will be discharged at\\n" + "...\\n" + "/the beginning of the print simulator\\n" + "/each line starts with \\"/\\"\\n" + "initial value of tape (without blank characters)\\n" + "blank character<litcomma> np $ (only not \\"/\\")\\n" + "starting state<litcomma> np start<litcomma> q_s ..\\n" + "table of transition function<litcomma> in form:\\n" + "\\t\\tcharacter\\tcharacter\\tcharacter\\t...\\n" + "state\\tfunction\\tfunction\\tfunction\\t...\\n" + "...\\t...\\t...\\t...\\t...\\n" + "<end>\\n" + "\\n" + "where the function is in the form:\\n" + "nextcharacter<litcomma>nextstate<litcomma>headmovedirection\\n" + "\\n\\n" + "example:\\n\\n" + "/this configuration of turing machine is able\\n" + "/to adding 1 to binary number\\n" + "$\\n" + "q_s\\n" + "\\t\\t0\\t\\t1\\t\\t$\\n" + "q_s\\t0<litcomma>q_s<litcomma>->\\t1<litcomma>q_s<litcomma>->\\t$<litcomma>q_a<litcomma><-\\n" + "q_a\\t1<litcomma>q_y<litcomma>->\\t0<litcomma>q_a<litcomma><-\\t1<litcomma>q_y<litcomma><-\\n" + "q_y\\taccept\\t\\taccept\\taccept\\n" ) ; return ; } fileinputstream is = new fileinputstream ( args [ 0 ] ) ; bufferedreader br = new bufferedreader ( new inputstreamreader ( is ) ) ; stringbuilder contentlist = new stringbuilder ( ) ; list < string > lineslist = new linkedlist < string > ( ) ; string line ; while ( ( line = br . readline ( ) ) != null ) { if ( ! line . trim ( ) . equals ( "" ) ) { if ( line . trim ( ) . startswith ( "/" ) ) { contentlist . append ( system . lineseparator ( ) ) . append ( line . trim ( ) . substring ( 1 ) ) ; } else { lineslist . add ( line . trim ( ) ) ; break ; } } } while ( ( line = br . readline ( ) ) != null ) { if ( ! line . trim ( ) . equals ( "" ) ) { lineslist . add ( line . trim ( ) ) ; } } br . close ( ) ; string blankcharacter = lineslist . get ( 0 ) ; string startingstatename = lineslist . get ( 1 ) ; try { system . out . println ( "\\n\\ntask:" + contentlist . tostring ( ) + "\\n" ) ; state starting = new inputparser ( ) . sparse ( lineslist . sublist ( 2 , lineslist . size ( ) ) , blankcharacter , startingstatename ) ; touringmachine m = new touringmachine ( args [ 1 ] , blankcharacter , starting ) ; m . run ( ) ; } catch ( exception e ) { system . out . println ( e . getmessage ( ) ) ; } }
va	7	public void upload ( string filename , byte [ ] data ) throws ioexception { string targeturl = http_mediafire_base_api + "upload/upload.php?session_token=" + sessiontoken ; httpclient httpclient = new defaulthttpclient ( ) ; httppost httppost = new httppost ( targeturl ) ; multipartentity mpentity = new multipartentity ( ) ; contentbody cbfile = new bytearraybody ( data , filename ) ; mpentity . addpart ( "myfile" , cbfile ) ; httppost . setentity ( mpentity ) ; system . out . println ( "executing request " + httppost . getrequestline ( ) ) ; httpresponse response = httpclient . execute ( httppost ) ; httpentity resentity = response . getentity ( ) ; system . out . println ( response . getstatusline ( ) ) ; if ( resentity != null ) { system . out . println ( entityutils . tostring ( resentity ) ) ; } if ( resentity != null ) { entityutils . consume ( resentity ) ; } httpclient . getconnectionmanager ( ) . shutdown ( ) ; }
va	2	private arraylist < string > getnumbers ( treenode root ) { arraylist < string > resstring = new arraylist < string > ( ) ; if ( root . left == null && root . right == null ) { resstring . add ( string . valueof ( root . val ) ) ; } else { if ( root . left != null ) resstring . addall ( getnumbers ( root . left ) ) ; if ( root . right != null ) resstring . addall ( getnumbers ( root . right ) ) ; for ( int i = 0 ; i < resstring . size ( ) ; i ++ ) { resstring . set ( i , string . valueof ( root . val ) + resstring . get ( i ) ) ; } } return resstring ; }
va	10	private static combination evaluatecombination5 ( card [ ] cards ) { combinationtype type = high_card ; rank high = deuce ; rank [ ] kickers = null ; boolean suited = issuited ( cards ) ; list < rank > list = arrays . aslist ( cards [ 0 ] . rank , cards [ 1 ] . rank , cards [ 2 ] . rank , cards [ 3 ] . rank , cards [ 4 ] . rank ) ; collections . sort ( list ) ; rank [ ] r = new rank [ ] { list . get ( 0 ) , list . get ( 1 ) , list . get ( 2 ) , list . get ( 3 ) , list . get ( 4 ) } ; boolean succesive = issuccesive ( r ) ; if ( suited ) { type = ( succesive ) ? straight_flush : flush ; high = r [ 4 ] ; kickers = ( succesive ) ? null : new rank [ ] { r [ 3 ] , r [ 2 ] , r [ 1 ] , r [ 0 ] } ; if ( succesive && r [ 4 ] == ace && r [ 0 ] == deuce ) { high = five ; } return new combination ( type , high , kickers ) ; } if ( succesive ) return new combination ( straight , ( r [ 4 ] == ace && r [ 0 ] == deuce ) ? r [ 3 ] : r [ 4 ] , kickers ) ; int [ ] t = new int [ ] { 1 , 0 , 0 , 0 , 0 } ; int j = 0 ; for ( int i = 1 ; i < 5 ; i ++ , t [ j ] ++ ) if ( r [ i ] != r [ i - 1 ] ) j ++ ; switch ( j ) { case 4 : kickers = new rank [ ] { r [ 3 ] , r [ 2 ] , r [ 1 ] , r [ 0 ] } ; return new combination ( high_card , r [ 4 ] , kickers ) ; case 1 : type = ( t [ 0 ] == 1 || t [ 0 ] == 4 ) ? quad : full_house ; high = ( t [ 0 ] < 3 ) ? r [ 4 ] : r [ 0 ] ; kickers = ( t [ 0 ] < 3 ) ? new rank [ ] { r [ 0 ] } : new rank [ ] { r [ 4 ] } ; return new combination ( type , high , kickers ) ; case 2 : switch ( t [ 0 ] ) { case 3 : return new combination ( trips , r [ 0 ] , new rank [ ] { r [ 4 ] , r [ 3 ] } ) ; case 2 : return new combination ( two_pair , r [ 3 ] , new rank [ ] { r [ 0 ] , ( t [ 1 ] == 2 ) ? r [ 4 ] : r [ 2 ] } ) ; case 1 : return ( t [ 1 ] == 2 ) ? new combination ( two_pair , r [ 3 ] , new rank [ ] { r [ 1 ] , r [ 0 ] } ) : new combination ( trips , r [ 3 ] , new rank [ ] { r [ 4 ] , r [ 0 ] } ) ; } case 3 : if ( t [ 0 ] == 2 ) return new combination ( one_pair , r [ 0 ] , new rank [ ] { r [ 4 ] , r [ 3 ] , r [ 2 ] } ) ; if ( t [ 1 ] == 2 ) return new combination ( one_pair , r [ 1 ] , new rank [ ] { r [ 4 ] , r [ 3 ] , r [ 0 ] } ) ; if ( t [ 2 ] == 2 ) return new combination ( one_pair , r [ 2 ] , new rank [ ] { r [ 4 ] , r [ 1 ] , r [ 0 ] } ) ; if ( t [ 3 ] == 2 ) return new combination ( one_pair , r [ 3 ] , new rank [ ] { r [ 2 ] , r [ 1 ] , r [ 0 ] } ) ; } return new combination ( type , high , kickers ) ; }
va	1	public plottingframe ( int width , int height ) { layoutmanager layout = new overlaylayout ( ) ; setlayout ( layout ) ; setsize ( width , height ) ; this . xticksnum = 11 ; this . yticksnum = 11 ; this . expression = null ; this . interval = new interval ( ) ; this . origin = new point2d . double ( 0 , 0 ) ; this . originlocation = new point2d . double ( 55 , height ) ; this . lines = new arraylist < line2d . double > ( ) ; this . points = new arraylist < point2d . double > ( ) ; this . pointslocations = new arraylist < point2d . double > ( ) ; this . axisx = new axis ( new point2d . double ( 55 , height ) , width - 10 , height - 30 , 1 ) ; this . axisy = new axis ( new point2d . double ( 55 , 30 ) , height - 30 , width - 10 , - 1 ) ; }
va	5	public texturepack ( string basepath ) { string path ; url res ; toolkit deftoolkit = toolkit . getdefaulttoolkit ( ) ; bufferedimage swap ; for ( int i = 0 ; i < texture . values ( ) . length ; i ++ ) { path = basepath + texture . values ( ) [ i ] . getname ( ) ; images [ i ] = new imageicon ( getclass ( ) . getresource ( path ) ) ; res = getclass ( ) . getresource ( path ) ; imgs [ i ] = deftoolkit . getimage ( res ) ; swap = util . tobufferedimage ( imgs [ i ] ) ; pixels [ i ] = new double [ imgs [ i ] . getwidth ( null ) ] [ imgs [ i ] . getheight ( null ) ] [ util . channels ] ; util . imagetopixels ( swap , pixels [ i ] ) ; } }
va	10	static public void drawlinesandfaces ( list < linesegment > lineset , dcel graph , int facecount , int vertexcount ) { int r , b , g ; random rgen = new random ( ) ; printwriter svgfile = null ; try { svgfile = new printwriter ( "boundedface.svg" , "utf-8" ) ; svgfile . write ( "<!doctype html>\\n<html>\\n<body>\\n\\n<svg xmlns=\\"http://www.w3.org/2000/svg\\" version=\\"1.1\\">\\n" ) ; for ( int i = 0 ; i < facecount ; i ++ ) { r = rgen . nextint ( 255 ) ; b = rgen . nextint ( 255 ) ; g = rgen . nextint ( 255 ) ; edge root , nextedge ; vertex v ; root = graph . edgelist . get ( graph . facelist . get ( i ) . edgeid ) ; v = graph . vertexlist . get ( root . startid ) ; svgfile . write ( "<polygon points=\\"" ) ; svgfile . write ( string . format ( "%.2f" , v . p . x * 10 ) + "<litcomma>" + string . format ( "%.2f" , v . p . y * 10 ) ) ; nextedge = graph . edgelist . get ( root . nextedgeid ) ; while ( nextedge . id != root . id ) { v = graph . vertexlist . get ( nextedge . startid ) ; svgfile . write ( " " + string . format ( "%.2f" , v . p . x * 10 ) + "<litcomma>" + string . format ( "%.2f" , v . p . y * 10 ) ) ; nextedge = graph . edgelist . get ( nextedge . nextedgeid ) ; } svgfile . write ( "\\" style=\\"fill:rgb(" + r + "<litcomma>" + b + "<litcomma>" + g + ");stroke-width:1\\"/>\\n" ) ; } for ( linesegment l : lineset ) { svgfile . write ( "<line " + "x1 = \\"" + string . format ( "%.2f" , l . start . x * 10 ) + "\\" " + "y1 = \\"" + string . format ( "%.2f" , l . start . y * 10 ) + "\\" " + "x2 = \\"" + string . format ( "%.2f" , l . end . x * 10 ) + "\\" " + "y2 = \\"" + string . format ( "%.2f" , l . end . y * 10 ) + "\\" " + "style=\\"stroke:rgb(0<litcomma>0<litcomma>0);stroke-width:2\\" />\\n" ) ; } for ( int i = 0 ; i < vertexcount ; i ++ ) { vertex v ; v = graph . vertexlist . get ( i ) ; svgfile . write ( "<circle " + "cx = \\"" + string . format ( "%.2f" , v . p . x * 10 ) + "\\" " + "cy = \\"" + string . format ( "%.2f" , v . p . y * 10 ) + "\\" " + "r = \\"3\\" fill=\\"red\\" />\\n" ) ; } svgfile . write ( "</svg>\\n\\n</body>\\n</html>\\n" ) ; svgfile . close ( ) ; } catch ( filenotfoundexception ex ) { logger . getlogger ( svgcreator . class . getname ( ) ) . log ( level . severe , null , ex ) ; } catch ( unsupportedencodingexception ex ) { logger . getlogger ( svgcreator . class . getname ( ) ) . log ( level . severe , null , ex ) ; } finally { svgfile . close ( ) ; } }
va	4	public double findmediansortedarrays ( int a [ ] , int b [ ] ) { int a = a . length ; int b = b . length ; if ( ( a + b ) % 2 == 0 ) { double first = find_k ( a , 0 , b , 0 , ( a + b ) / 2 ) ; double second = find_k ( a , 0 , b , 0 , ( a + b ) / 2 + 1 ) ; return ( first + second ) / 2.0 ; } else { return find_k ( a , 0 , b , 0 , ( a + b ) / 2 + 1 ) ; } }
va	10	public adddoctor ( ) { setdefaultcloseoperation ( jframe . exit_on_close ) ; setresizable ( false ) ; setbounds ( 100 , 100 , 450 , 408 ) ; contentpane = new jpanel ( ) ; contentpane . setborder ( new emptyborder ( 5 , 5 , 5 , 5 ) ) ; setcontentpane ( contentpane ) ; contentpane . setlayout ( null ) ; jlabel lblfirstname = new jlabel ( "first name:" ) ; lblfirstname . setbounds ( 29 , 36 , 65 , 14 ) ; contentpane . add ( lblfirstname ) ; txtfirstname = new jtextfield ( ) ; txtfirstname . settooltiptext ( "enter your first name" ) ; txtfirstname . setbounds ( 153 , 33 , 146 , 20 ) ; contentpane . add ( txtfirstname ) ; txtfirstname . setcolumns ( 10 ) ; jlabel lblmiddlename = new jlabel ( "middle name:" ) ; lblmiddlename . setbounds ( 29 , 67 , 87 , 14 ) ; contentpane . add ( lblmiddlename ) ; txtmname = new jtextfield ( ) ; txtmname . settooltiptext ( "enter your middle name" ) ; txtmname . setbounds ( 153 , 64 , 146 , 20 ) ; contentpane . add ( txtmname ) ; txtmname . setcolumns ( 10 ) ; jlabel lbllastname = new jlabel ( "last name:" ) ; lbllastname . setbounds ( 29 , 103 , 65 , 14 ) ; contentpane . add ( lbllastname ) ; txtlname = new jtextfield ( ) ; txtlname . settooltiptext ( "enter your last name" ) ; txtlname . setbounds ( 153 , 95 , 146 , 20 ) ; contentpane . add ( txtlname ) ; txtlname . setcolumns ( 10 ) ; jlabel lbladdress = new jlabel ( "address:" ) ; lbladdress . setdebuggraphicsoptions ( debuggraphics . flash_option ) ; lbladdress . setbounds ( 29 , 128 , 65 , 14 ) ; contentpane . add ( lbladdress ) ; txtadd = new jtextfield ( ) ; txtadd . settooltiptext ( "enter your work address" ) ; txtadd . setbounds ( 153 , 125 , 146 , 20 ) ; contentpane . add ( txtadd ) ; txtadd . setcolumns ( 10 ) ; jlabel lblage = new jlabel ( "age:" ) ; lblage . setbounds ( 29 , 196 , 46 , 14 ) ; contentpane . add ( lblage ) ; txtage = new jtextfield ( ) ; txtage . settooltiptext ( "enter your age" ) ; txtage . setbounds ( 153 , 193 , 146 , 20 ) ; contentpane . add ( txtage ) ; txtage . setcolumns ( 10 ) ; jlabel lblhospital = new jlabel ( "hospital name:" ) ; lblhospital . settooltiptext ( "enter your hospital name" ) ; lblhospital . setbounds ( 29 , 230 , 87 , 14 ) ; contentpane . add ( lblhospital ) ; jlabel lblqualification = new jlabel ( "qualification:" ) ; lblqualification . setbounds ( 29 , 269 , 87 , 14 ) ; contentpane . add ( lblqualification ) ; txthospital = new jtextfield ( ) ; txthospital . settooltiptext ( "enter hospital name" ) ; txthospital . setbounds ( 153 , 227 , 146 , 20 ) ; contentpane . add ( txthospital ) ; txthospital . setcolumns ( 10 ) ; txtqualification = new jtextfield ( ) ; txtqualification . settooltiptext ( "enter your qualification" ) ; txtqualification . setbounds ( 153 , 266 , 146 , 20 ) ; contentpane . add ( txtqualification ) ; txtqualification . setcolumns ( 10 ) ; jbutton btnsave = new jbutton ( "save" ) ; btnsave . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent e ) { system . out . println ( "save button" ) ; insertdoc ( ) ; } } ) ; btnsave . setbounds ( 59 , 297 , 89 , 23 ) ; contentpane . add ( btnsave ) ; jbutton btnreset = new jbutton ( "reset" ) ; btnreset . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent arg0 ) { system . out . println ( "reset button" ) ; reset ( ) ; } } ) ; btnreset . setbounds ( 188 , 297 , 89 , 23 ) ; contentpane . add ( btnreset ) ; jlabel lblemail = new jlabel ( "email:" ) ; lblemail . settooltiptext ( "enter your email address" ) ; lblemail . setbounds ( 29 , 168 , 46 , 14 ) ; contentpane . add ( lblemail ) ; txtemail = new jtextfield ( ) ; txtemail . setbounds ( 153 , 165 , 146 , 20 ) ; contentpane . add ( txtemail ) ; txtemail . setcolumns ( 10 ) ; }
va	7	public void loadconfiguration ( ) throws exception { yamlreader reader = new yamlreader ( new filereader ( "server.yml" ) ) ; object object = reader . read ( ) ; map map = ( map ) object ; serversettings = ( map ) map . get ( "basic_conf" ) ; arraylist < map < string , string > > obj = ( arraylist < map < string , string > > ) map . get ( "url_mappings" ) ; for ( map < string , string > mapping : obj ) { pattern p = pattern . compile ( mapping . get ( "url_regexp" ) ) ; class handler = class . forname ( mapping . get ( "handler" ) ) ; if ( ! httphandler . class . isassignablefrom ( handler ) ) { throw new exception ( "illegal http handler " + handler . getcanonicalname ( ) ) ; } urlmappingcompiled . put ( p , ( httphandler ) handler . newinstance ( ) ) ; } }
va	8	private dimension calculatecanvassize ( hashmap < string , list < sprite > > rowdata ) { int maxwidth = 0 ; int totalheight = 0 ; set < string > keys = rowdata . keyset ( ) ; for ( string key : keys ) { list < sprite > spritelist = rowdata . get ( key ) ; sprite firstsprite = spritelist . get ( 0 ) ; int width = firstsprite . getwidth ( ) * spritelist . size ( ) ; double rows = 1 ; if ( width > 2000 ) { rows = math . ceil ( width / maxspritewidth ) ; width = maxspritewidth ; } maxwidth = math . max ( width , maxwidth ) ; totalheight += firstsprite . getheight ( ) * rows + 1 ; } return new dimension ( maxwidth , totalheight ) ; }
va	3	public static void main ( string [ ] args ) { system . out . println ( "hello world!" ) ; pattern regexpattern = pattern . compile ( "\\\\s+\\\\.class$|\\\\s+\\\\.jar$|^web\\\\.xml$|^ibm-web-bnd\\\\.xml$" ) ; matcher [ ] matchers = new matcher [ 3 ] ; matchers [ 0 ] = regexpattern . matcher ( "a.class" ) ; matchers [ 1 ] = regexpattern . matcher ( "web.xml" ) ; matchers [ 2 ] = regexpattern . matcher ( "ibm-web-bnd.xml" ) ; system . out . println ( "=====================================" ) ; for ( matcher matcher : matchers ) { system . out . println ( matcher . find ( ) ) ; system . out . println ( matcher . matches ( ) ) ; system . out . println ( matcher . group ( ) ) ; } }
va	4	private void dfs ( string s , arraylist < string > res , int start , string ip , int part ) { if ( start == s . length ( ) && part == 4 ) { res . add ( ip ) ; return ; } if ( part >= 4 ) return ; for ( int i = start ; i < s . length ( ) && i < start + 3 ; i ++ ) { string t = s . substring ( start , i + 1 ) ; if ( integer . parseint ( t ) <= 255 && part < 4 && ( ! t . startswith ( "0" ) || t . equals ( "0" ) ) ) { int old = start ; string oldip = ip ; if ( ip == "" ) ip = t ; else ip += "." + t ; part ++ ; start = i + 1 ; dfs ( s , res , start , ip , part ) ; start = old ; ip = oldip ; part -- ; } } }
va	2	public void run ( ) { while ( true ) { socket s = null ; boolean connected = false ; try { s = new socket ( unity . ip , integer . parseint ( unity . port ) ) ; connected = true ; } catch ( exception e ) { } finally { if ( s != null ) { try { s . close ( ) ; } catch ( ioexception e1 ) { } } } if ( connected ) { system . out . println ( "connection to server established." ) ; server_stat_lbl . settext ( "online" ) ; server_stat_lbl . setforeground ( color . green ) ; } else { system . out . println ( "unable to establish connection." ) ; server_stat_lbl . settext ( "offline" ) ; server_stat_lbl . setforeground ( color . red ) ; } try { thread . sleep ( 5000 ) ; } catch ( exception e ) { } ; } }
va	6	public void simulate ( ) { int tick = 0 ; vector < task > metaset = new vector < task > ( s ) ; int i1 = 0 ; int i2 = s ; for ( int i = i1 ; i < i2 ; i ++ ) { task t = new task ( arrivals [ i ] , i ) ; metaset . add ( t ) ; } i1 = i2 ; i2 = ( int ) min ( i1 + s , arrivals . length ) ; tick = arrivals [ i1 - 1 ] ; eng . schedule ( metaset , tick ) ; tick = arrivals [ i2 - 1 ] ; do { if ( i2 == i1 ) { tick = integer . max_value ; removecompletedtasks ( tick ) ; break ; } else { tick = arrivals [ i2 - 1 ] ; removecompletedtasks ( tick ) ; } metaset = new vector < task > ( i2 - i1 ) ; for ( int i = i1 ; i < i2 ; i ++ ) { task t = new task ( arrivals [ i ] , i ) ; metaset . add ( t ) ; } eng . schedule ( metaset , tick ) ; i1 = i2 ; i2 = ( int ) min ( i1 + s , arrivals . length ) ; } while ( ! discontinuesimulation ( ) ) ; }
va	3	@ test public void teststringsplit ( ) { string str1 = "web-inf/classes" ; string [ ] items = str1 . split ( "/" ) ; system . out . println ( "items length: " + items . length ) ; system . out . println ( "items: " + arrays . tostring ( items ) ) ; assertequals ( 2 , items . length ) ; assertequals ( "web-inf" , items [ 0 ] ) ; assertequals ( "classes" , items [ 1 ] ) ; string str2 = "/web-inf/classes" ; assertequals ( 3 , str2 . split ( "/" ) . length ) ; }
va	6	public double tenfoldcrossvalidation ( ) { system . out . println ( "start 10-fold cross validation" ) ; double [ ] output ; double error = 0 ; double [ ] results = new double [ 22 ] ; for ( int i = 0 ; i < patterns . size ( ) ; i ++ ) { for ( int j = 0 ; j < patterns . size ( ) - 1 ; j ++ ) { network . setinput ( patterns . get ( j ) . getinput ( ) ) ; network . activatenetwork ( ) ; output = network . getoutput ( ) ; patterns . get ( j ) . setresult ( output ) ; network . applybackpropagation ( patterns . get ( j ) . getoutput ( ) ) ; } network . setinput ( patterns . get ( patterns . size ( ) - 1 ) . getinput ( ) ) ; network . activatenetwork ( ) ; results [ i ] = 1.0 / 2.0 * math . pow ( network . getoutput ( ) [ 0 ] - patterns . get ( patterns . size ( ) - 1 ) . getoutput ( ) [ 0 ] , 2 ) ; system . out . println ( "sample - " + i + " : " + results [ i ] ) ; lastelemtostart ( ) ; } for ( double d : results ) { error += d ; } system . out . println ( "stop 10-fold cross validation" ) ; return error / results . length ; }
va	7	public static rsaprivatekey getprivatekey ( ) throws ioexception , generalsecurityexception { file file = new file ( system . getproperty ( "user.home" ) , ".android/adbkey" ) ; bufferedreader reader = new bufferedreader ( new filereader ( file ) ) ; try { stringbuilder builder = new stringbuilder ( ) ; string line = reader . readline ( ) ; while ( line != null ) { if ( ! line . startswith ( "----" ) ) builder . append ( line ) ; line = reader . readline ( ) ; } byte [ ] bytes = datatypeconverter . parsebase64binary ( builder . tostring ( ) ) ; keyfactory keyfactory = keyfactory . getinstance ( "rsa" ) ; pkcs8encodedkeyspec ks = new pkcs8encodedkeyspec ( bytes ) ; return ( rsaprivatekey ) keyfactory . generateprivate ( ks ) ; } finally { reader . close ( ) ; } }
va	6	@ test public void testreadfile ( ) { string filename = "de/csp/fileio/csv/readertestsemicolon.csv" ; inputstream inputstream = this . getclass ( ) . getclassloader ( ) . getresourceasstream ( filename ) ; csvreader csvreader = new csvreader ( ) ; standardcsvfileioto to ; try { to = csvreader . readfile ( inputstream ) ; assertequals ( 3 , to . getheader ( ) . size ( ) ) ; list < string > header = to . getheader ( ) ; asserttrue ( header . contains ( "header1" ) ) ; asserttrue ( header . contains ( "header2" ) ) ; asserttrue ( header . contains ( "header3" ) ) ; assertequals ( 1 , to . getdata ( ) . size ( ) ) ; list < string > dataset = to . getdata ( ) . get ( 0 ) ; assertequals ( 3 , dataset . size ( ) ) ; asserttrue ( dataset . contains ( "data1" ) ) ; asserttrue ( dataset . contains ( "data2" ) ) ; asserttrue ( dataset . contains ( "data3" ) ) ; } catch ( ioexception e ) { logger . error ( e ) ; fail ( e . tostring ( ) ) ; } }
va	10	public static void main ( string [ ] args ) throws filenotfoundexception , ioexception { string path = args [ 0 ] ; file file = new file ( path ) ; byte [ ] bytes = new byte [ ( int ) file . length ( ) ] ; fileinputstream fis = new fileinputstream ( file ) ; fis . read ( bytes ) ; fis . close ( ) ; string [ ] valuestr = new string ( bytes ) . trim ( ) . split ( ";" ) ; int [ ] input = new int [ valuestr . length ] ; for ( int i = 0 ; i < valuestr . length ; i ++ ) input [ i ] = integer . parseint ( valuestr [ i ] ) ; mergesort ( input , 0 , input . length - 1 ) ; stringbuilder sb = new stringbuilder ( ) ; string prefix = "" ; for ( int item : input ) { sb . append ( prefix ) ; prefix = ";" ; sb . append ( item ) ; } system . out . println ( sb . tostring ( ) ) ; }
va	9	public mapreduceresults < contact > mapreduceforname ( string name ) { string a = "function () { " + "if(this.name == \\"" + name + "\\") " + "\temit(this<litcomma>1) }" ; string b = "function (key<litcomma> values) {return values;}" ; mapreduceresults < contact > results = mongooperation . mapreduce ( "contacts" , a , b , contact . class ) ; dbobject dbobject = results . getrawresults ( ) ; basicdblist dblist = ( basicdblist ) dbobject . get ( "results" ) ; if ( dblist != null && dblist . size ( ) > 0 ) { for ( string key : dblist . keyset ( ) ) { set < entry < string , object > > set = ( ( basicdbobject ) dblist . get ( key ) ) . entryset ( ) ; stringbuilder message = new stringbuilder ( ) ; if ( set != null ) { for ( entry < string , object > entry : set ) { if ( entry . getkey ( ) . equals ( "_id" ) ) { message . append ( ( ( basicdbobject ) entry . getvalue ( ) ) . get ( "name" ) ) . append ( " " ) ; message . append ( ( ( basicdbobject ) entry . getvalue ( ) ) . get ( "lastname" ) ) . append ( " " ) ; message . append ( ( ( basicdbobject ) entry . getvalue ( ) ) . get ( "phones" ) ) . append ( " " ) ; } } } logger . info ( message . tostring ( ) ) ; } } else { logger . info ( "no information found for " + name ) ; } return mongooperation . mapreduce ( "contacts" , a , b , contact . class ) ; }
va	3	public static void main ( string [ ] args ) { if ( args . length <= 0 ) { throw new illegalargumentexception ( "directory with source files must be set" ) ; } file file = new file ( args [ 0 ] ) ; if ( ! file . exists ( ) ) { try { throw new illegalargumentexception ( "file not found in path '" + file . getcanonicalpath ( ) + "'" ) ; } catch ( ioexception e ) { throw new illegalargumentexception ( e ) ; } } classanalyser analyser = new simpleanalyser ( ) ; analyser . analyse ( new directoryanalysiscontext ( file ) ) ; for ( classdescription classdescription : analyser . classes ( ) ) { system . out . println ( "class " + classdescription ) ; } system . out . println ( "total number of methods: " + analyser . totalnumberofmethods ( ) ) ; }
va	10	public static void getsimilardocuments ( string filename , string dirname ) throws ioexception { file dir = new file ( dirname ) ; if ( dir . isdirectory ( ) ) { string [ ] filenames = dir . list ( ) ; file fich = new file ( dirname + "/similarities/" + file + ".sim" ) ; fileoutputstream ps = new fileoutputstream ( fich ) ; printwriter ecrivain = new printwriter ( ps ) ; for ( string poidname : filenames ) ecrivain . println ( poidname + "\\t" + getsimilarity ( filename , dirname + "/poids/" + poidname ) ) ; ecrivain . close ( ) ; try { process proc = runtime . getruntime ( ) . exec ( "cat " + fich . tostring ( ) + " | sort -k 2n<litcomma>2nr >" ) ; inputstream in = proc . getinputstream ( ) ; bufferedwriter out = new bufferedwriter ( new filewriter ( dirname + "/similarities/" + "kk.txt" ) ) ; int c ; while ( ( c = in . read ( ) ) != - 1 ) { out . write ( ( char ) c ) ; } in . close ( ) ; out . flush ( ) ; out . close ( ) ; } catch ( ioexception e ) { } } }
va	8	public int convert ( int pixel ) { int alfa = ( pixel > > 24 ) & 0xff ; int r = ( pixel > > 16 ) & 0xff ; int g = ( pixel > > 8 ) & 0xff ; int b = ( pixel ) & 0xff ; int i = inxsearch ( b , g , r ) ; int bb = colormap [ i ] [ 0 ] ; int gg = colormap [ i ] [ 1 ] ; int rr = colormap [ i ] [ 2 ] ; return ( alfa << 24 ) | ( rr << 16 ) | ( gg << 8 ) | ( bb ) ; }
va	1	public quaternion ( matrix m ) { float ww = 0.25f * ( m . get ( 0 , 0 ) + m . get ( 1 , 1 ) + m . get ( 2 , 2 ) + m . get ( 3 , 3 ) ) ; if ( ww >= 0 ) { if ( ww >= eps2 ) { w = ( float ) math . sqrt ( ww ) ; ww = 0.25f / w ; x = ( ( m . get ( 2 , 1 ) - m . get ( 1 , 2 ) ) * ww ) ; y = ( ( m . get ( 0 , 2 ) - m . get ( 2 , 0 ) ) * ww ) ; z = ( ( m . get ( 1 , 0 ) - m . get ( 0 , 1 ) ) * ww ) ; return ; } } else { w = 0 ; x = 0 ; y = 0 ; z = 1 ; return ; } this . w = 0 ; ww = - 0.5f * ( m . get ( 1 , 1 ) + m . get ( 2 , 2 ) ) ; if ( ww >= 0 ) { if ( ww >= eps2 ) { x = ( float ) math . sqrt ( ww ) ; ww = 1.0f / ( 2.0f * x ) ; y = ( m . get ( 1 , 0 ) * ww ) ; z = ( m . get ( 2 , 0 ) * ww ) ; return ; } } else { x = 0 ; y = 0 ; z = 1 ; return ; } this . x = 0 ; ww = 0.5f * ( 1.0f - m . get ( 2 , 2 ) ) ; if ( ww >= eps2 ) { y = ( float ) math . sqrt ( ww ) ; z = ( m . get ( 2 , 1 ) ) / ( 2.0f * y ) ; return ; } y = 0 ; z = 1 ; }
va	1	@ override public void actionperformed ( actionevent a ) { object source = a . getsource ( ) ; if ( source == mniplotfunc ) { pfframe . setlocation ( getwidth ( ) / 2 + getlocation ( ) . x - 140 , getheight ( ) / 2 + getlocation ( ) . y - 100 ) ; pfframe . clearentry ( ) ; pfframe . pframe = this . pframe ; pfframe . setvisible ( true ) ; } else if ( source == mnicalculator ) { cframe . setlocation ( getwidth ( ) / 2 + getlocation ( ) . x - 110 , getheight ( ) / 2 + getlocation ( ) . y - 80 ) ; cframe . setvisible ( true ) ; } if ( source == mniexit ) { system . exit ( 0 ) ; } else if ( source == mniclear ) { pframe . reset ( ) ; } else if ( source == mnisetinterval ) { siframe . setlocation ( getwidth ( ) / 2 + getlocation ( ) . x - 110 , getheight ( ) / 2 + getlocation ( ) . y - 90 ) ; siframe . clearentry ( ) ; siframe . pframe = this . pframe ; siframe . setvisible ( true ) ; } else if ( source == mniabout ) { joptionpane . showmessagedialog ( this , about , "about" , joptionpane . information_message , imibig ) ; } }
va	4	public boolean isvalidsudoku ( char [ ] [ ] board , int row , int col , int val ) { for ( int i = 0 ; i < 9 ; i ++ ) { if ( character . getnumericvalue ( board [ row ] [ i ] ) == val ) return false ; } for ( int i = 0 ; i < 9 ; i ++ ) { if ( character . getnumericvalue ( board [ i ] [ col ] ) == val ) return false ; } int x = row / 3 ; int y = col / 3 ; for ( int i = 0 ; i < 3 ; i ++ ) { for ( int j = 0 ; j < 3 ; j ++ ) { if ( character . getnumericvalue ( board [ i + x * 3 ] [ j + y * 3 ] ) == val ) return false ; } } return true ; }
va	4	public string strstr ( string haystack , string needle ) { int size1 = haystack . length ( ) ; int size2 = needle . length ( ) ; if ( size2 == 0 ) return haystack ; if ( size1 == 0 ) return null ; for ( int i = 0 ; i < size1 - size2 + 1 ; i ++ ) { for ( int j = 0 ; j < size2 ; j ++ ) { if ( haystack . charat ( i + j ) != needle . charat ( j ) ) { break ; } else { if ( j == size2 - 1 ) { return haystack . substring ( i ) ; } } } } return null ; }
va	2	private int getmin ( int row , int index , arraylist < arraylist < integer > > triangle , int [ ] minvalues ) { int val = triangle . get ( row ) . get ( index ) ; int minvalue = 0 ; if ( row == 0 ) { minvalue = val ; } else { if ( index == 0 ) { minvalue = minvalues [ index ] + val ; } else if ( index == triangle . get ( row ) . size ( ) - 1 ) { minvalue = minvalues [ index - 1 ] + val ; } else { minvalue = math . min ( val + minvalues [ index ] , val + minvalues [ index - 1 ] ) ; } } minvalues [ index ] = minvalue ; return minvalue ; }
va	10	public static void main ( string [ ] args ) { scanner sc = new scanner ( system . in ) ; int totalarestas = sc . nextint ( ) ; int numcase = 1 ; while ( totalarestas != 0 ) { list < integer > vertices = new arraylist < integer > ( ) ; int [ ] [ ] arestas = new int [ totalarestas * 2 + 10 ] [ 2 ] ; for ( int i = 0 ; i < totalarestas ; i ++ ) { int no1 = sc . nextint ( ) ; int no2 = sc . nextint ( ) ; if ( ! vertices . contains ( no1 ) ) vertices . add ( no1 ) ; if ( ! vertices . contains ( no2 ) ) vertices . add ( no2 ) ; arestas [ i ] [ 0 ] = no1 ; arestas [ i ] [ 1 ] = no2 ; } int noinicial = sc . nextint ( ) ; int ttl = sc . nextint ( ) ; while ( ! ( noinicial == 0 && ttl == 0 ) ) { system . out . println ( "case " + numcase + ": " + naoalcancaveis ( vertices , arestas , noinicial , ttl ) + " nodes not reachable from node " + noinicial + " with ttl = " + ttl + "." ) ; numcase ++ ; noinicial = sc . nextint ( ) ; ttl = sc . nextint ( ) ; } totalarestas = sc . nextint ( ) ; } sc . close ( ) ; }
va	5	public static string decodeunicode ( string datastr ) { int start = 0 ; int end = 0 ; stringbuffer buffer = new stringbuffer ( ) ; while ( start > - 1 ) { end = datastr . indexof ( "\\\\u" , start ) ; if ( end == - 1 ) { buffer . append ( datastr . substring ( start , datastr . length ( ) ) ) ; start = end ; } else { buffer . append ( datastr . substring ( start , end ) ) ; string charstr = datastr . substring ( end + 2 , end + 6 ) ; char letter = ( char ) integer . parseint ( charstr , 16 ) ; buffer . append ( new character ( letter ) . tostring ( ) ) ; start = end + 6 ; } } return buffer . tostring ( ) ; }
va	10	private void raise ( final abstractevent event ) throws illegalaccessexception , instantiationexception , invocationtargetexception { for ( object currenthandler : ( arraylist ) listeners . clone ( ) ) { method [ ] methods ; boolean isclass = false ; if ( currenthandler instanceof class ) { methods = ( ( class ) currenthandler ) . getmethods ( ) ; isclass = true ; } else { methods = currenthandler . getclass ( ) . getmethods ( ) ; } arraylist < method > valid = new arraylist < method > ( ) ; for ( method method : methods ) { eventlistener annotation = method . getannotation ( eventlistener . class ) ; if ( annotation == null ) continue ; class [ ] params = method . getparametertypes ( ) ; if ( params . length != 1 ) continue ; if ( annotation . respectsinheritance ( ) && ! params [ 0 ] . isassignablefrom ( event . getclass ( ) ) ) continue ; if ( ! annotation . respectsinheritance ( ) && params [ 0 ] != event . getclass ( ) ) continue ; if ( ! isclass && exclusive && modifier . isstatic ( method . getmodifiers ( ) ) ) continue ; if ( isclass && ! modifier . isstatic ( method . getmodifiers ( ) ) ) continue ; valid . add ( method ) ; } comparator < method > comp = new comparator < method > ( ) { @ override public int compare ( method o1 , method o2 ) { eventlistener a1 = o1 . getannotation ( eventlistener . class ) ; eventlistener a2 = o2 . getannotation ( eventlistener . class ) ; if ( a1 . priority ( ) . ordinal ( ) < a2 . priority ( ) . ordinal ( ) ) return - 1 ; if ( a1 . priority ( ) . ordinal ( ) > a2 . priority ( ) . ordinal ( ) ) return 1 ; return 0 ; } @ override public boolean equals ( object obj ) { return false ; } } ; collections . sort ( valid , comp ) ; for ( method method : valid ) { eventlistener annotation = method . getannotation ( eventlistener . class ) ; if ( event . iscancelled ( ) ) { if ( annotation . allowcancelled ( ) ) method . invoke ( currenthandler , event ) ; } else method . invoke ( currenthandler , event ) ; } } }
va	8	public static void main ( string [ ] args ) { unit data = new unit ( ) ; data . setage ( 1 ) ; data . setgender ( true ) ; data . setid ( "testid" ) ; data . setname ( "wlq" ) ; data . setdescription ( new stringbuilder ( "descroption" ) ) ; system . out . println ( data . tostring ( ) ) ; ixstream xstream1_1_2 = new oldxstream ( ) ; string unit2strwith1_1_2 = xstream1_1_2 . toxml ( data ) ; system . out . println ( "========show data with oldxstream========" ) ; system . out . println ( "unit2strwith1_1_2\\t" + unit2strwith1_1_2 ) ; ixstream xstream1_4_1 = new newxstream ( ) ; string unit2strwith1_4_1 = xstream1_4_1 . toxml ( data ) ; system . out . println ( "========show data with newxstream========" ) ; system . out . println ( "unit2strwith1_4_1\\t" + unit2strwith1_4_1 ) ; system . out . println ( "========oldxstream str-> newxstream unit========" ) ; unit newexstreamunit = xstream1_4_1 . fromxml ( unit2strwith1_1_2 ) ; system . out . println ( newexstreamunit . tostring ( ) ) ; system . out . println ( "========newxstream str ->oldxstream unit========" ) ; unit oldsxstreamunit = xstream1_1_2 . fromxml ( unit2strwith1_4_1 ) ; if ( oldsxstreamunit != null ) { system . out . println ( oldsxstreamunit . tostring ( ) ) ; } system . out . println ( "========newxstream str ->oldxstream unit bug fix========" ) ; unit newunit = xstream1_4_1 . fromxml ( unit2strwith1_4_1 ) ; if ( newunit != null ) { system . out . println ( xstream1_1_2 . toxml ( newunit ) ) ; } }
va	10	private static int check_bbox_interest ( node root_node , namednodemap item_attributes , node id_node , string passed_min_lat_string , string passed_min_lon_string , string passed_max_lat_string , string passed_max_lon_string ) { boolean it_overlaps = true ; int return_value = 0 ; double p_min_lat_d ; double p_min_lon_d ; double p_max_lat_d ; double p_max_lon_d ; if ( passed_min_lat_string . length ( ) == 0 ) { if ( arg_debug >= log_informational_1 ) { system . out . println ( "we're interested in all changesets" ) ; } return_value = overlap_all ; } else { double min_lat_d ; double min_lon_d ; double max_lat_d ; double max_lon_d ; try { min_lat_d = double . valueof ( item_attributes . getnameditem ( "min_lat" ) . getnodevalue ( ) ) ; min_lon_d = double . valueof ( item_attributes . getnameditem ( "min_lon" ) . getnodevalue ( ) ) ; max_lat_d = double . valueof ( item_attributes . getnameditem ( "max_lat" ) . getnodevalue ( ) ) ; max_lon_d = double . valueof ( item_attributes . getnameditem ( "max_lon" ) . getnodevalue ( ) ) ; p_min_lat_d = double . valueof ( passed_min_lat_string ) ; p_min_lon_d = double . valueof ( passed_min_lon_string ) ; p_max_lat_d = double . valueof ( passed_max_lat_string ) ; p_max_lon_d = double . valueof ( passed_max_lon_string ) ; it_overlaps = check_bboxes_overlap ( p_min_lon_d , p_min_lat_d , p_max_lat_d , p_max_lon_d , min_lon_d , min_lat_d , max_lat_d , max_lon_d ) ; if ( it_overlaps == true ) { return_value = overlap_yes ; if ( arg_debug >= log_informational_1 ) { system . out . println ( "we're interested in this changeset" ) ; } } else { return_value = overlap_no ; if ( arg_debug >= log_informational_1 ) { system . out . println ( "we're not interested in this changeset" ) ; } } } catch ( exception ex ) { return_value = overlap_error ; if ( arg_debug >= log_informational_1 ) { system . out . println ( "error parsing lat or lon from this changeset<litcomma> so we'll assume that we are interested in it.  error: " + ex . getmessage ( ) ) ; } } } return return_value ; }
va	6	private int [ ] [ ] construirmatrizdijkstracalculodistanciaeuclides ( stringtokenizer strtok , int numerodeciudades ) { double coordenadas [ ] [ ] = new double [ numerodeciudades ] [ 2 ] ; final int indiceprimeracoordenada = 0 ; final int indicesegundacoordenada = 1 ; int contador = 0 ; string cadenaleida = "" ; while ( ! cadenaleida . equals ( "eof" ) ) { cadenaleida = strtok . nexttoken ( ) ; if ( cadenaleida . equals ( "node coord section" ) ) { cadenaleida = strtok . nexttoken ( ) ; while ( ! cadenaleida . equals ( "eof" ) ) { coordenadas [ contador ] [ indiceprimeracoordenada ] = double . parsedouble ( strtok . nexttoken ( ) ) ; coordenadas [ contador ] [ indicesegundacoordenada ] = double . parsedouble ( strtok . nexttoken ( ) ) ; contador ++ ; cadenaleida = strtok . nexttoken ( ) ; } } } int matrizauxiliar [ ] [ ] = new int [ numerodeciudades ] [ numerodeciudades ] ; matrizauxiliar = calculodistanciaporeuclides ( coordenadas , numerodeciudades ) ; return matrizauxiliar ; }
va	4	public void flatten ( treenode root ) { if ( root == null ) return ; stack < treenode > st = new stack < treenode > ( ) ; st . add ( root ) ; treenode dummy = new treenode ( - 1 ) ; treenode curr = dummy ; while ( ! st . isempty ( ) ) { treenode t = st . pop ( ) ; curr . right = t ; curr . left = null ; curr = t ; if ( t . right != null ) st . add ( t . right ) ; if ( t . left != null ) st . add ( t . left ) ; } }
va	2	public static void main ( string [ ] args ) { final map < string , integer > m = new hashmap < string , integer > ( ) ; m . put ( key_bulgaria , 7 ) ; m . put ( key_germany , 80 ) ; m . put ( key_greece , 7 ) ; m . put ( key_netherland , 10 ) ; m . put ( key_russia , 145 ) ; m . put ( key_france , 60 ) ; for ( string key : m . keyset ( ) ) { if ( m . get ( key ) > 10 ) system . out . println ( key ) ; } }
va	4	protected boolean verifypackage ( ) throws mojoexecutionexception { getlog ( ) . info ( "verifying package..." ) ; if ( getbarpackage ( ) . getbarfile ( ) == null || ! getbarpackage ( ) . getbarfile ( ) . exists ( ) || ! getbarpackage ( ) . getbarfile ( ) . canread ( ) ) { throw new mojoexecutionexception ( "bar package was not specified or doesn't " + "exist<litcomma> or there is no permission to read." ) ; } final string [ ] args = { "-verify" , getbarpackage ( ) . getbarfile ( ) . getpath ( ) } ; callable < void > signercallable = new callable < void > ( ) { @ override public void call ( ) throws exception { barsigner . main ( args ) ; return null ; } } ; exittrappingexecutor executor = new exittrappingexecutor ( ) ; boolean signingsuccessful = executor . execute ( signercallable ) == 0 ; getlog ( ) . info ( "verification complete." ) ; return signingsuccessful ; }
va	4	@ override public void channelread ( channelhandlercontext ctx , object msg ) throws exception { trafficcounter . start ( ) ; inetsocketaddress address = ( inetsocketaddress ) ctx . channel ( ) . remoteaddress ( ) ; string ip = address . gethoststring ( ) ; if ( msg instanceof httprequest ) { system . out . println ( "in chenelread" ) ; fullhttprequest request = ( fullhttprequest ) msg ; if ( ! request . geturi ( ) . equals ( "/falicon.ico" ) ) { serverstatus . addconnection ( ) ; } if ( is100continueexpected ( request ) ) { ctx . write ( new defaultfullhttpresponse ( http_1_1 , continue ) ) ; } string uri = request . geturi ( ) ; handlehttprequest ( ctx , ( fullhttprequest ) msg , ip ) ; } }
va	6	public list < drink > getdrinksfromingredientnames ( list < string > ingredientnames ) { list < drink > drinks = drinkrepo . findall ( ) ; list < drink > drinksreturned = new arraylist < drink > ( ) ; for ( drink drink : drinks ) { int matches = 0 ; for ( ingredient ing : drink . getingredients ( ) ) { for ( string name : ingredientnames ) { if ( ing . getname ( ) . getname ( ) . equalsignorecase ( name ) ) { matches ++ ; } } } if ( matches > 0 ) { drink . setid ( matches ) ; drinksreturned . add ( drink ) ; } } collections . sort ( drinksreturned ) ; return drinksreturned ; }
va	9	@ override protected void doparse ( element element , beandefinitionbuilder builder ) { boolean combo = true ; string comboattr = element . getattribute ( "combo" ) ; if ( comboattr != null && ! comboattr . isempty ( ) ) { combo = boolean . parseboolean ( comboattr ) ; } string filterattr = element . getattribute ( "filter" ) ; if ( filterattr == null || filterattr . isempty ( ) ) { filterattr = "raw" ; } string urlbase = element . getattribute ( "base" ) ; map < string , string > groupelements = new hashmap < > ( ) ; for ( element groupelement : domutils . getchildelementsbytagname ( element , "group" ) ) { string key = groupelement . getattribute ( "name" ) ; string url = groupelement . getattribute ( "base" ) ; groupelements . put ( key , url ) ; } try { collection < modulegroup > groups = buildgroups ( groupelements ) ; builder . addpropertyvalue ( "yuiconfigurer" , buildconfigurer ( filterattr , combo , urlbase ) ) ; builder . addpropertyvalue ( "modulebuilder" , buildmodulebuilder ( groups ) ) ; builder . addpropertyvalue ( "languagemodulebuilder" , buildlanguagemodulebuilder ( groups ) ) ; builder . addpropertyvalue ( "groups" , groups ) ; } catch ( ioexception e ) { throw new runtimeexception ( e ) ; } }
va	7	private void processline ( string line , trafficrobot robot ) { logger . debug ( "processline " + line + "for robot " + robot . getrobotid ( ) ) ; dateformat df = new simpledateformat ( "yyyy-mm-dd hh:mm:ss" ) ; string [ ] split = line . replaceall ( "\\"" , "" ) . split ( "<litcomma>" ) ; int driverid = new integer ( split [ 0 ] ) ; double latitude = new double ( split [ 1 ] ) ; double longitude = new double ( split [ 2 ] ) ; datetime date ; try { date = new datetime ( df . parse ( split [ 3 ] ) . gettime ( ) ) ; pointsmessage pointsmessage = new pointsmessage ( robot . getrobotid ( ) , new pointdata ( driverid , latitude , longitude , date ) ) ; pointsmessages . add ( pointsmessage ) ; } catch ( parseexception e ) { e . printstacktrace ( ) ; } }
va	5	private void computescalarproducts ( int npoints , double [ ] [ ] s , double [ ] q ) { double rms = 0. ; for ( int i = 1 ; i < npoints ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { double dij = s [ i ] [ j ] * s [ i ] [ j ] ; rms += dij + dij ; q [ i ] += dij ; q [ j ] += dij ; } } rms = rms / ( npoints * npoints ) ; double dsm ; for ( int i = 0 ; i < npoints ; i ++ ) { for ( int j = 0 ; j <= i ; j ++ ) { if ( i == j ) dsm = 0. ; else dsm = s [ i ] [ j ] * s [ i ] [ j ] ; s [ i ] [ j ] = ( ( q [ i ] + q [ j ] ) / npoints - rms - dsm ) / 2. ; s [ j ] [ i ] = s [ i ] [ j ] ; } } }
va	8	public static list < customblock > load ( blockapi plugin ) { arraylist < customblock > list = new arraylist < customblock > ( ) ; if ( ! path . exists ( ) ) { path . mkdirs ( ) ; return list ; } blockclassloader classloader = new blockclassloader ( plugin . getclass ( ) . getclassloader ( ) ) ; file [ ] classes = path . listfiles ( ) ; for ( int x = 0 ; x < classes . length ; x ++ ) { file file = classes [ x ] ; if ( ( ! file . isdirectory ( ) ) && ( file . getabsolutepath ( ) . endswith ( ".class" ) ) ) try { class < ? > myclass = classloader . loadclass ( "file:" + file . getabsolutepath ( ) , file . getname ( ) . replace ( ".class" , "" ) ) ; object object = myclass . newinstance ( ) ; if ( ( object instanceof customblock ) ) { customblock cblock = ( customblock ) object ; list . add ( cblock ) ; } } catch ( classnotfoundexception e ) { e . printstacktrace ( ) ; } catch ( instantiationexception e ) { e . printstacktrace ( ) ; } catch ( illegalaccessexception e ) { e . printstacktrace ( ) ; } } return list ; }
va	2	private void dfs ( string s , arraylist < string > path , int start , arraylist < arraylist < string > > res ) { if ( start == s . length ( ) ) { arraylist < string > newpath = new arraylist < string > ( ) ; newpath . addall ( path ) ; res . add ( newpath ) ; return ; } for ( int j = start ; j < s . length ( ) ; j ++ ) { if ( ispalindrome ( s , start , j ) ) { path . add ( s . substring ( start , j + 1 ) ) ; dfs ( s , path , j + 1 , res ) ; path . remove ( path . size ( ) - 1 ) ; } } }
va	3	public static void savegif ( bufferedimage [ ] images , string fname ) { new file ( "output images/" ) . mkdir ( ) ; try { new file ( "output images" ) . mkdir ( ) ; imageoutputstream output = new fileimageoutputstream ( new file ( "output images/" + fname ) ) ; gifsequencewriter writer = new gifsequencewriter ( output , images [ 0 ] . gettype ( ) , 100 , true ) ; for ( bufferedimage bi : images ) { writer . writetosequence ( bi ) ; } writer . close ( ) ; output . close ( ) ; } catch ( filenotfoundexception ex ) { logger . getlogger ( perlin2d . class . getname ( ) ) . log ( level . severe , null , ex ) ; } catch ( ioexception ex ) { logger . getlogger ( perlin2d . class . getname ( ) ) . log ( level . severe , null , ex ) ; } }
va	6	private void processoneuser ( double trainingpercentage , fastbyidmap < preferencearray > trainingusers , fastbyidmap < preferencearray > testuserprefs , long userid , datamodel datamodel ) throws tasteexception { list < preference > trainingprefs = null ; list < preference > testprefs = null ; preferencearray prefs = datamodel . getpreferencesfromuser ( userid ) ; int size = prefs . length ( ) ; for ( int i = 0 ; i < size ; i ++ ) { preference newpref = new genericpreference ( userid , prefs . getitemid ( i ) , prefs . getvalue ( i ) ) ; if ( random . nextdouble ( ) < trainingpercentage ) { if ( trainingprefs == null ) { trainingprefs = new arraylist < preference > ( 3 ) ; } trainingprefs . add ( newpref ) ; } else { if ( testprefs == null ) { testprefs = new arraylist < preference > ( 3 ) ; } testprefs . add ( newpref ) ; } } if ( trainingprefs != null ) { trainingusers . put ( userid , new genericuserpreferencearray ( trainingprefs ) ) ; if ( testprefs != null ) { testuserprefs . put ( userid , new genericuserpreferencearray ( testprefs ) ) ; } } }
va	9	public void senddatagram ( datagram datagram ) throws ioexception { counter ++ ; bytearrayoutputstream bstream = new bytearrayoutputstream ( 1500 ) ; objectoutputstream ostream = new objectoutputstream ( bstream ) ; ostream . writeobject ( datagram ) ; ostream . flush ( ) ; byte [ ] data = bstream . tobytearray ( ) ; inetaddress ipaddress = inetaddress . getbyname ( datagram . getdstaddr ( ) ) ; datagrampacket packet = new datagrampacket ( data , data . length , ipaddress , datagram . getdstport ( ) ) ; if ( counter % 7 == 0 ) { system . out . println ( "testing with delayed packets..." ) ; random r1 = new random ( ) ; int delay = r1 . nextint ( 7500 ) + 7500 ; senddelayedpacket ( packet , delay ) ; system . out . println ( "packet sent after delay of " + delay ) ; } else if ( counter % 11 == 0 ) { system . out . println ( "testing with duplicate packets..." ) ; random r2 = new random ( ) ; int count = r2 . nextint ( 3 ) + 3 ; sendduplicatepackets ( packet , count ) ; system . out . println ( "packet sent " + count + " times" ) ; } else { socket . send ( packet ) ; } }
va	2	private int maxsum ( treenode root , int [ ] res ) { if ( root == null ) return 0 ; int maxleft = maxsum ( root . left , res ) ; int maxright = maxsum ( root . right , res ) ; res [ 0 ] = math . max ( res [ 0 ] , math . max ( math . max ( math . max ( maxleft + maxright , 0 ) , maxleft ) , maxright ) + root . val ) ; return math . max ( 0 , math . max ( maxleft , maxright ) ) + root . val ; }
va	1	public static void receive ( string [ ] locatorinfo ) { locators locator = null ; locator = locators . valueof ( locatorinfo [ 1 ] ) ; system . out . println ( "*** before displaying info in receive method***" ) ; switch ( locator ) { case xpath : system . out . println ( "inside locator: " + locator ) ; break ; case classname : system . out . println ( "inside locator: " + locator ) ; break ; case link : system . out . println ( "inside locator: " + locator ) ; break ; case id : system . out . println ( "inside locator: " + locator ) ; break ; default : system . out . println ( "*** no locator defined for: " + locator ) ; break ; } system . out . println ( "*** exiting receive *** \\n" ) ; }
va	4	private void solvetle ( int currentcolumn , int size , int [ ] [ ] board , arraylist < string [ ] > res ) { if ( currentcolumn == size ) { string [ ] solution = new string [ size ] ; string row = "" ; for ( int i = 0 ; i < size ; i ++ ) { row = "" ; for ( int j = 0 ; j < size ; j ++ ) { row += ( board [ i ] [ j ] > 0 ? string . valueof ( board [ i ] [ j ] ) : "." ) ; } solution [ i ] = row ; } res . add ( solution ) ; return ; } for ( int i = 0 ; i < size ; i ++ ) { if ( validplacetle ( currentcolumn , i , board ) ) { board [ i ] [ currentcolumn ] = 1 ; currentcolumn ++ ; solvetle ( currentcolumn , size , board , res ) ; currentcolumn -- ; board [ i ] [ currentcolumn ] = 0 ; } } }
va	9	public void iniciar ( int iteraciones ) { list < integer > padre , madre , hijo1 , hijo2 ; list < list < integer > > nuevageneracion ; double fitnessmejoradaptado = fitness ( this . mejoradaptado ) ; double fitnessindividuo ; for ( int x = 0 ; x < iteraciones ; x ++ ) { nuevageneracion = new arraylist < > ( ) ; for ( int y = 0 ; y < this . tama\xf1opoblacion / 2 ; y ++ ) { padre = competencia ( seleccionarindividuoaleatorio ( ) , seleccionarindividuoaleatorio ( ) ) ; madre = competencia ( seleccionarindividuoaleatorio ( ) , seleccionarindividuoaleatorio ( ) ) ; hijo1 = cruzar ( padre , madre ) ; hijo2 = cruzar ( madre , padre ) ; nuevageneracion . add ( hijo1 ) ; nuevageneracion . add ( hijo2 ) ; fitnessindividuo = fitness ( hijo1 ) ; if ( fitnessindividuo > fitnessmejoradaptado ) { this . mejoradaptado = hijo1 ; fitnessmejoradaptado = fitnessindividuo ; } fitnessindividuo = fitness ( hijo2 ) ; if ( fitnessindividuo > fitnessmejoradaptado ) { this . mejoradaptado = hijo2 ; fitnessmejoradaptado = fitnessindividuo ; } } this . poblacion = nuevageneracion ; } }
va	1	@ override protected void map ( longwritable key , text line , context context ) throws ioexception , interruptedexception { string [ ] data = line . tostring ( ) . split ( "\\t" ) ; browserid = new text ( data [ 0 ] . tostring ( ) . trim ( ) ) ; time = new longwritable ( long . parselong ( data [ 1 ] . tostring ( ) . trim ( ) ) ) ; system . out . println ( " session map :" + browserid + "-" + time . tostring ( ) ) ; context . write ( browserid , time ) ; }
va	3	public boolean validatediagonal ( char t , int x , int y ) { int inadiagonal = 0 ; int ox = x ; int oy = y ; while ( x != 0 && y != 0 ) { x -- ; y -- ; } while ( x < size && y < size ) { if ( board [ x ] [ y ] . gettype ( ) == t ) { inadiagonal ++ ; } else { inadiagonal = 0 ; } x ++ ; y ++ ; if ( inadiagonal == tokentowin ) { return true ; } } x = ox ; y = oy ; inadiagonal = 0 ; while ( x != 0 && y != size - 1 ) { x -- ; y ++ ; } while ( x < size && y >= 0 ) { if ( board [ x ] [ y ] . gettype ( ) == t ) { inadiagonal ++ ; } else { inadiagonal = 0 ; } x ++ ; y -- ; if ( inadiagonal == tokentowin ) { return true ; } } return false ; }
va	8	public void printsubgraph ( hashmap < string , node > subgraph ) { stack < arraylist < string > > qf = new stack < arraylist < string > > ( ) ; system . out . println ( subgraph . size ( ) ) ; for ( string name : subgraph . keyset ( ) ) { char student ; if ( subgraph . get ( name ) . data . school != null ) { student = 'y' ; } else { student = 'n' ; } if ( student == 'n' ) { system . out . println ( subgraph . get ( name ) . data . name + "|" + student ) ; } else { system . out . println ( subgraph . get ( name ) . data . name + "|" + student + "|" + subgraph . get ( name ) . data . school ) ; } } for ( string friendalpha : subgraph . keyset ( ) ) { node friendbeta = subgraph . get ( friendalpha ) ; while ( friendbeta . next != null ) { friendbeta = friendbeta . next ; arraylist < string > twofriends = new arraylist < string > ( 2 ) ; twofriends . add ( friendalpha ) ; twofriends . add ( friendbeta . data . name ) ; qf . push ( twofriends ) ; } } while ( ! qf . empty ( ) ) { arraylist < string > test = qf . pop ( ) ; arraylist < string > reverse = new arraylist < string > ( 2 ) ; reverse . add ( test . get ( 1 ) ) ; reverse . add ( test . get ( 0 ) ) ; if ( ! qf . contains ( reverse ) ) { system . out . println ( reverse . get ( 0 ) + "|" + reverse . get ( 1 ) ) ; } } }
va	4	public listnode mergelists ( listnode a , listnode b ) { if ( a == null ) return b ; if ( b == null ) return a ; listnode dummy = new listnode ( 0 ) ; listnode curra = a , currb = b , curr = dummy ; while ( curra != null || currb != null ) { if ( curra == null ) { curr . next = currb ; currb = currb . next ; } else if ( currb == null ) { curr . next = curra ; curra = curra . next ; } else if ( curra . val < currb . val ) { curr . next = curra ; curra = curra . next ; } else { curr . next = currb ; currb = currb . next ; } curr = curr . next ; } return dummy . next ; }
va	5	public static void findkthelement ( linkedlist < integer > list ) { if ( list . isempty ( ) || null == list ) { system . out . println ( "empty list" ) ; return ; } scanner scan = new scanner ( system . in ) ; system . out . println ( "enter the position of the element: " ) ; int pos = scan . nextint ( ) ; if ( pos > list . size ( ) ) { system . out . println ( "position number exceeds list size" ) ; return ; } int size = list . size ( ) ; int pos1 = 0 ; while ( pos1 < pos ) { pos1 ++ ; } int pos2 = 0 ; while ( pos1 < size ) { pos1 ++ ; pos2 ++ ; } system . out . println ( pos + " position to the last element is: " + list . get ( pos2 ) ) ; }
va	7	public static void main ( string [ ] args ) { string base = "c:\\\\programs\\\\gcj\\\\lawnmower\\\\" ; string input = base + "input.in" ; string output = base + "output.out" ; try { scanner sc = new scanner ( new filereader ( input ) ) ; printwriter pw = new printwriter ( output ) ; int n = sc . nextint ( ) ; sc . nextline ( ) ; for ( int c = 0 ; c < n ; c ++ ) { system . out . println ( "test case " + ( c + 1 ) + "..." ) ; pw . print ( "case #" + ( c + 1 ) + ": " ) ; test ( sc , pw ) ; pw . println ( ) ; } pw . println ( ) ; pw . flush ( ) ; pw . close ( ) ; sc . close ( ) ; } catch ( filenotfoundexception ex ) { ex . printstacktrace ( ) ; } }
va	8	public boolean assertunique ( ) { boolean unique = true , rcs ; int length = size * size * 2 ; string [ ] array ; int x = 0 , y = 0 ; rcs = true ; for ( int i = 0 ; i < length && unique ; i ++ ) { array = new string [ sudokugrid . length ] ; while ( x < array . length && y < array . length && unique ) { int index = integer . parseint ( sudokugrid [ x ] [ y ] ) - 1 ; if ( index >= 0 && ! array [ index ] . equals ( new string ( "*" ) ) ) { system . out . print ( sudokugrid [ x ] [ y ] + " == " + array [ index ] ) ; system . out . println ( " at x=" + x + "<litcomma> y=" + y ) ; unique = false ; } else if ( index >= 0 ) { array [ index ] = sudokugrid [ x ] [ y ] ; } y = ( rcs ? y + 1 : y ) ; x = ( rcs ? x : x + 1 ) ; } x = ( rcs ? x + 1 : 0 ) ; y = ( rcs ? 0 : y + 1 ) ; rcs = ( i == ( length / 2 ) - 1 ) ? ! rcs : rcs ; x = ( i == ( length / 2 ) - 1 ) ? 0 : x ; y = ( i == ( length / 2 ) - 1 ) ? 0 : y ; } return unique ; }
va	3	public static transactionlist getinstance ( ) { try ( objectinputstream is = new objectinputstream ( new fileinputstream ( serializedfile ) ) ; ) { transactionlist l = ( transactionlist ) is . readobject ( ) ; if ( l != null ) { system . out . println ( "read from file" ) ; for ( transaction t : l ) { system . out . print ( t ) ; } } integer i = is . readint ( ) ; system . out . println ( "starting from index " + i ) ; transaction . setcurrentindexforid ( i ) ; return l ; } catch ( invalidclassexception e ) { e . printstacktrace ( ) ; } catch ( filenotfoundexception e ) { system . err . println ( "file not found. creating new." ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } catch ( classnotfoundexception e ) { e . printstacktrace ( ) ; } return new transactionlist ( ) ; }
va	2	public boolean haspathsum ( treenode root , int sum ) { if ( root == null ) return false ; boolean bleft = false , bright = false ; if ( root . left == null && root . right == null ) { if ( sum == root . val ) return true ; else return false ; } if ( root . left != null ) bleft = haspathsum ( root . left , sum - root . val ) ; if ( root . right != null ) bright = haspathsum ( root . right , sum - root . val ) ; return bleft || bright ; }
va	1	public static void main ( string [ ] args ) throws slickexception { appgamecontainer app = new appgamecontainer ( new sidescrollergame ( game_title ) ) ; app . setvsync ( wait_for_vsync ) ; app . setsmoothdeltas ( true ) ; app . settargetframerate ( 60 ) ; app . setshowfps ( false ) ; app . setupdateonlywhenvisible ( true ) ; app . setmusicon ( music_on_off ) ; app . setsoundon ( sound_on_off ) ; if ( app . supportsmultisample ( ) ) app . setmultisample ( 2 ) ; app . setdisplaymode ( 800 , 600 , fullscreen ) ; app . start ( ) ; }
va	6	public list < order > getallorders ( ) { session session = sessionfactory . opensession ( ) ; query query = session . createquery ( "from order" ) ; list < order > orderlist = new arraylist < order > ( ) ; @ suppresswarnings ( "unchecked" ) list < order > allorders = query . list ( ) ; session . close ( ) ; for ( int i = 0 ; i < allorders . size ( ) ; i ++ ) { order order = ( order ) allorders . get ( i ) ; orderlist . add ( order ) ; } return orderlist ; }
va	3	@ override public void mouseclicked ( java . awt . event . mouseevent evt ) { int row = table . rowatpoint ( evt . getpoint ( ) ) ; int col = table . columnatpoint ( evt . getpoint ( ) ) ; if ( row >= 0 && col >= 0 && ! jatek . isgamewon ( ) ) { token t ; if ( jatek . getelozosiker ( ) ) { t = jatek . getnextplayer ( ) . gettoken ( ) ; } else { t = jatek . getprevplayer ( ) . gettoken ( ) ; } if ( jatek . addtoken ( row , col , t ) ) { table . setvalueat ( t . gettype ( ) , row , col ) ; } } if ( jatek . isgamewon ( ) ) { table . setenabled ( false ) ; } window . validate ( ) ; window . repaint ( ) ; }
va	8	@ eventhandler ( priority = eventpriority . normal ) public void pickup ( playerpickupitemevent event ) { itemstack item = event . getitem ( ) . getitemstack ( ) ; item . setamount ( item . getamount ( ) - event . getremaining ( ) ) ; inventory inv = event . getplayer ( ) . getinventory ( ) ; int quantity = blockapi . getcustomblockamount ( item ) * item . getamount ( ) ; customblock cblock = this . plugin . getcustomblock ( item ) ; if ( ( quantity == - 1 ) || ( cblock == null ) ) return ; for ( int x = 0 ; x < inv . getsize ( ) ; x ++ ) { itemstack itemx = inv . getitem ( x ) ; if ( itemx != null ) { int amount = blockapi . getcustomblockamount ( itemx ) ; if ( ( amount != - 1 ) && ( amount < cblock . getmaxstacksize ( ) ) && ( cblock . getidentifier ( ) . equalsignorecase ( this . plugin . getcustomblock ( itemx ) . getidentifier ( ) ) ) ) { int test = amount + quantity ; if ( test <= cblock . getmaxstacksize ( ) ) { quantity = 0 ; inv . setitem ( x , blockapi . setcustomblockamount ( itemx , test ) ) ; break ; } quantity = test - cblock . getmaxstacksize ( ) ; inv . setitem ( x , blockapi . setcustomblockamount ( itemx , cblock . getmaxstacksize ( ) ) ) ; } } } if ( quantity > 0 ) { item = blockapi . setcustomblockamount ( item , quantity ) ; item . setamount ( 1 ) ; event . getplayer ( ) . getinventory ( ) . additem ( new itemstack [ ] { item } ) ; } event . getitem ( ) . remove ( ) ; event . setcancelled ( true ) ; }
va	3	private synchronized void lazilyclosed ( scopedentitymanager em ) { long tid = long . valueof ( em . getownerid ( ) ) ; list < scopedentitymanager > ems = emlist . get ( tid ) ; if ( ems != null ) { for ( int idx = ems . size ( ) - 1 ; idx >= 0 ; idx -- ) { if ( ems . get ( idx ) == em ) { ems . remove ( idx ) ; break ; } } if ( ems . isempty ( ) ) emlist . remove ( tid ) ; } }
va	8	public void handle ( httpexchange httpexchange ) throws ioexception { string response = "" ; int httpcode = 200 ; httpexchange . getresponseheaders ( ) . add ( "content-type" , "text/plain" ) ; map < string , string > params = ( map < string , string > ) httpexchange . getattribute ( parameters ) ; try { if ( login . equals ( params . get ( request_type ) ) ) { final int userid = integer . parseint ( params . get ( user_id ) ) ; response = userservice . login ( userid ) ; } else if ( score . equals ( params . get ( request_type ) ) ) { integer userid = userservice . auth ( params . get ( session_key ) ) ; if ( userid != null ) { final int score = integer . parseint ( params . get ( score ) ) ; final int levelid = integer . parseint ( params . get ( level_id ) ) ; scoreservice . postscore ( userid , levelid , score ) ; } else { response = "session key not found or expired" ; httpcode = 401 ; } } else if ( highscore_list . equals ( params . get ( request_type ) ) ) { final int levelid = integer . parseint ( params . get ( level_id ) ) ; final set < player > leaderboard = scoreservice . highscores ( levelid ) ; response = leaderboard . tostring ( ) . replace ( "[" , "" ) . replace ( "]" , "" ) ; httpexchange . getresponseheaders ( ) . add ( "content-type" , "text/csv" ) ; } else { response = "not found" ; httpcode = 404 ; } } catch ( illegalargumentexception iaex ) { response = "precondition failed" ; httpcode = 412 ; } catch ( exception ex ) { response = "something wrong happened" ; httpcode = 500 ; } httpexchange . sendresponseheaders ( httpcode , response . length ( ) ) ; outputstream os = httpexchange . getresponsebody ( ) ; os . write ( response . getbytes ( ) ) ; os . close ( ) ; }
va	8	protected void dispatch ( httpservletrequest request , httpservletresponse response ) throws ioexception { string method = null ; if ( request . getparameter ( "_method" ) != null ) { method = request . getparameter ( "_method" ) . touppercase ( ) ; } else { method = request . getmethod ( ) . touppercase ( ) ; } crossingroute route = findmatchedroute ( request . getrequesturi ( ) , method ) ; if ( route == null ) return ; map < string , object > env = getenvmap ( request ) ; crossinghelpers . setparamstoenv ( container , request , env ) ; crossingresponse crossingresponse = crossinghelpers . dispatch ( container , request . getcontextpath ( ) , route , env ) ; response . setstatus ( crossingresponse . getstatus ( ) ) ; set < string > keys = crossingresponse . getresponseheader ( ) . keyset ( ) ; for ( string key : keys ) { string value = crossingresponse . getresponseheader ( ) . get ( key ) ; response . setheader ( key , value ) ; } request . getsession ( ) . setattribute ( "action_dispatch.request.flash_hash" , crossingresponse . getflash ( ) ) ; printwriter writer = response . getwriter ( ) ; writer . write ( crossingresponse . getbody ( ) ) ; }
va	3	public static boolean deletedirectory ( file directory ) { if ( ! directory . isdirectory ( ) ) { return false ; } if ( ! directory . exists ( ) ) { return false ; } file [ ] filelist = directory . listfiles ( ) ; for ( int index = 0 ; index < filelist . length ; index ++ ) { file file = filelist [ index ] ; if ( ! file . exists ( ) ) { continue ; } if ( file . isdirectory ( ) ) { deletedirectory ( file ) ; } else { file . delete ( ) ; } } return true ; }
va	10	private static case directionoptimaleechappee ( grille grille , case casemission ) { monstre monstres = grille . getnbvampires ( casemission ) != 0 ? monstre . vampires : monstre . loups ; arraylist < case > toutescasesadjacentes = grille . gettoutescasesadjacentes ( casemission ) ; arraylist < case > casesdisponibles = new arraylist < case > ( ) ; arraylist < case > casesdangereuses = new arraylist < case > ( ) ; for ( case caseadjacente : toutescasesadjacentes ) { if ( monstres == monstre . loups ) { if ( grille . getnbvampires ( caseadjacente ) == 0 ) { casesdisponibles . add ( caseadjacente ) ; } else { casesdangereuses . add ( caseadjacente ) ; } } else { if ( grille . getnbloups ( caseadjacente ) == 0 ) { casesdisponibles . add ( caseadjacente ) ; } else { casesdangereuses . add ( caseadjacente ) ; } } } int meilleuredistance = 0 ; case meilleurecase = null ; for ( case casedispo : casesdisponibles ) { int distancetotale = 0 ; for ( case casedangereuse : casesdangereuses ) { distancetotale += utils . distance ( casedangereuse , casedispo ) ; } if ( distancetotale > meilleuredistance ) { meilleuredistance = distancetotale ; meilleurecase = casedispo ; } } return meilleurecase ; }
va	9	@ deprecated protected float calculateweigthedaveragefitness ( int saison , int spieltag , team team ) { int anzahlspieltage = 70 ; float mingewicht = 0.1f ; float steigung = ( mingewicht - 1.0f ) / anzahlspieltage ; float summefitness = 0.0f ; float summegewichte = 0.0f ; for ( int n = 0 ; n < anzahlspieltage ; n ++ ) { teamstatus status = team . getstatus ( ) . get ( getspieltagid ( saison , spieltag , - ( n + 1 ) ) ) ; if ( status == null ) { status = teamstatus . getliga2status ( team , saison , 1 ) ; } float fitnesstag = status . getfitness ( ) ; float gewichtung = ( 1.0f + steigung * n ) ; summefitness = summefitness + gewichtung * fitnesstag ; summegewichte = summegewichte + gewichtung ; } return summefitness / summegewichte ; }
va	9	public void removeline ( ) { try { file file = new file ( getdatafolder ( ) , "plates.prop" ) ; bufferedwriter bw = new bufferedwriter ( new filewriter ( file , true ) ) ; printwriter writer = new printwriter ( file ) ; writer . print ( "" ) ; writer . close ( ) ; for ( int i = 0 ; i < plates . size ( ) ; i ++ ) { string world = plates . get ( i ) . getlocation ( ) . getworld ( ) . getname ( ) ; int x = plates . get ( i ) . getlocation ( ) . getblockx ( ) ; int y = plates . get ( i ) . getlocation ( ) . getblocky ( ) ; int z = plates . get ( i ) . getlocation ( ) . getblockz ( ) ; string str = plates . get ( i ) . getowner ( ) + ":" + world + "<litcomma>" + x + "<litcomma>" + y + "<litcomma>" + z + "=" + plates . get ( i ) . getmod ( ) + "=" + plates . get ( i ) . getallowedplayers ( ) . tostring ( ) ; bw . append ( str ) ; bw . newline ( ) ; } bw . close ( ) ; } catch ( filenotfoundexception ex ) { ex . printstacktrace ( ) ; } catch ( ioexception ex ) { ex . printstacktrace ( ) ; } }
va	3	@ override public void actionperformed ( actionevent a ) { if ( a . getsource ( ) == btncalculate ) { string exp = this . txtexpression . gettext ( ) ; string x = this . txtx . gettext ( ) ; if ( ! exp . isempty ( ) && ! x . isempty ( ) ) { string result ; if ( ! exp . equals ( prevexpression ) ) { parser . setexpression ( exp ) ; prevexpression = exp ; } try { result = new decimalformat ( "#0.00" ) . format ( parser . eval ( double . parsedouble ( x ) ) ) ; this . txty . settext ( result ) ; } catch ( illegalargumentexception e ) { this . txty . settext ( "undefined" ) ; } } } else { if ( this . cmbtrig . getselectedindex ( ) == 0 ) this . parser . setisradian ( false ) ; if ( this . cmbtrig . getselectedindex ( ) == 1 ) this . parser . setisradian ( true ) ; } }
va	8	private static void duel ( ) { boolean finished = false ; if ( ! activeduel . isanswerallowed ( loggedplayer ) ) { system . out . println ( "\\nyou cannot continue this duel right now. you have to wait for your opponent to answer." ) ; return ; } system . out . println ( "\\nwelcome to your duel<litcomma> " + loggedplayer . getname ( ) ) ; system . out . println ( "\\nenter the letter of your answer or q to quit and save the duel" ) ; while ( ! finished ) { if ( ! activeduel . isanswerallowed ( loggedplayer ) ) { system . out . println ( "\\nyou cannot continue this duel right now. you either have to wait for your opponent to answer or the duel is finished." ) ; return ; } system . out . println ( "\\n____________________________________________________________________" ) ; system . out . println ( "question " + activeduel . getcurrentquestionnumber ( loggedplayer ) + "<litcomma> round " + activeduel . getcurrentroundnumber ( loggedplayer ) ) ; system . out . println ( "your opponent: " + activeduel . getopponentname ( loggedplayer ) ) ; system . out . println ( "" ) ; question question = activeduel . getcurrentquestion ( loggedplayer ) ; string questiontext = activeduel . getcurrentquestion ( loggedplayer ) . format ( ) ; answer answera = question . getanswers ( ) . get ( 0 ) ; answer answerb = question . getanswers ( ) . get ( 1 ) ; answer answerc = question . getanswers ( ) . get ( 2 ) ; answer answerd = question . getanswers ( ) . get ( 3 ) ; system . out . println ( questiontext ) ; system . out . println ( "\\n____________________________________________________________________" ) ; in . nextline ( ) ; string input = "" ; if ( in . hasnext ( ) ) { input = in . next ( ) ; } if ( ! input . tolowercase ( ) . matches ( "[abcdq]" ) ) { system . out . println ( "invalid input!" ) ; continue ; } else if ( input . tolowercase ( ) . matches ( "[abcd]" ) ) { switch ( input . tolowercase ( ) ) { case "a" : activeduel . answer ( loggedplayer , answera ) ; if ( answera . iscorrect ( ) ) system . out . println ( "you answered correctly!" ) ; else system . out . println ( "your answer is wrong." ) ; break ; case "b" : activeduel . answer ( loggedplayer , answerb ) ; if ( answerb . iscorrect ( ) ) system . out . println ( "you answered correctly!" ) ; else system . out . println ( "your answer is wrong." ) ; break ; case "c" : activeduel . answer ( loggedplayer , answerc ) ; if ( answerc . iscorrect ( ) ) system . out . println ( "you answered correctly!" ) ; else system . out . println ( "your answer is wrong." ) ; break ; case "d" : activeduel . answer ( loggedplayer , answerd ) ; if ( answerd . iscorrect ( ) ) system . out . println ( "you answered correctly!" ) ; else system . out . println ( "your answer is wrong." ) ; break ; default : system . out . println ( "an unknown error occured. please try again!" ) ; return ; } system . out . println ( "correct answer: " + question . getcorrectanswer ( ) . format ( ) ) ; } else finished = true ; duelfilehandler . saveduels ( ) ; } }
va	4	public string inttoroman ( int num ) { string str = "" ; string symbol [ ] = { "m" , "cm" , "d" , "cd" , "c" , "xc" , "l" , "xl" , "x" , "ix" , "v" , "iv" , "i" } ; int value [ ] = { 1000 , 900 , 500 , 400 , 100 , 90 , 50 , 40 , 10 , 9 , 5 , 4 , 1 } ; for ( int i = 0 ; i < value . length ; ) { if ( num >= value [ i ] ) { num = num - value [ i ] ; str = str + symbol [ i ] ; } else { i ++ ; } } return str ; }
va	5	private stats stats ( ) { stats stats = new stats ( ) ; stats . setloadedclasscount ( classloading . gettotalloadedclasscount ( ) ) ; stats . setcompilationtime ( compilation . gettotalcompilationtime ( ) ) ; long [ ] collectioncount = new long [ garbagecollectors . size ( ) ] ; for ( int i = 0 , garbagecollectorssize = garbagecollectors . size ( ) ; i < garbagecollectorssize ; i ++ ) { garbagecollectormxbean collector = garbagecollectors . get ( i ) ; collectioncount [ i ] = collector . getcollectioncount ( ) ; } stats . setgc ( collectioncount ) ; return stats ; }
va	7	private static kdtreenode build ( list < ? extends point > points , int depth ) { if ( points . isempty ( ) ) return null ; final int axis = depth % 2 ; collections . sort ( points , new comparator < point > ( ) { public int compare ( point p1 , point p2 ) { double coord1 = p1 . getcoords ( ) [ axis ] ; double coord2 = p2 . getcoords ( ) [ axis ] ; return double . compare ( coord1 , coord2 ) ; } } ) ; int index = points . size ( ) / 2 ; kdtreenode leftchild = build ( points . sublist ( 0 , index ) , depth + 1 ) ; kdtreenode rightchild = build ( points . sublist ( index + 1 , points . size ( ) ) , depth + 1 ) ; point point = points . get ( index ) ; return new kdtreenode ( point , axis , leftchild , rightchild ) ; }
va	10	public static final void filterimage ( bufferedimage img , color c ) { float chsb [ ] = new float [ 3 ] ; boolean gray = false ; color . rgbtohsb ( c . getred ( ) , c . getblue ( ) , c . getgreen ( ) , chsb ) ; if ( chsb [ 1 ] == 0 ) { gray = true ; system . out . println ( "gris" ) ; } writableraster trame = img . getraster ( ) ; colormodel model = img . getcolormodel ( ) ; float [ ] hsb = new float [ 3 ] ; object data ; int w = img . getwidth ( ) ; int h = img . getheight ( ) ; for ( int x = 0 ; x < w ; x ++ ) for ( int y = 0 ; y < h ; y ++ ) { data = trame . getdataelements ( x , y , null ) ; color . rgbtohsb ( model . getred ( data ) , model . getgreen ( data ) , model . getblue ( data ) , hsb ) ; if ( gray ) trame . setdataelements ( x , y , model . getdataelements ( color . hsbtorgb ( 1 - chsb [ 0 ] , 0 , hsb [ 2 ] ) , null ) ) ; else trame . setdataelements ( x , y , model . getdataelements ( color . hsbtorgb ( 1 - chsb [ 0 ] , hsb [ 1 ] , hsb [ 2 ] ) , null ) ) ; } }
va	8	public int addtradesbatchtovault ( list < matchprops > mprops , string tradedatetime ) throws sqlexception { int retval = 0 ; connection con = null ; simpledateformat df = new simpledateformat ( "yyyy-mm-dd hh:mm:ss" ) ; java . sql . preparedstatement pstrades = null ; string pstradessql = "insert or ignore into trades(tradedatetime<litcomma>expiredatetime<litcomma>buycpt<litcomma>" + "sellcpt<litcomma> " + "tradestatus<litcomma> " + "tradetype<litcomma>" + "asset <litcomma> " + "amount<litcomma>" + "price<litcomma>" + "matchtradeid<litcomma>" + "vault<litcomma>" + "mprop1<litcomma>" + "mprop2<litcomma>" + "mprop3<litcomma>userid)" + "values (?<litcomma>?<litcomma>?<litcomma>?<litcomma>?<litcomma>?<litcomma>?<litcomma>?<litcomma>?<litcomma>?<litcomma>?<litcomma>?<litcomma>?<litcomma>?<litcomma>?)" ; try { class . forname ( "org.sqlite.jdbc" ) ; try { con = drivermanager . getconnection ( vxconnectionstring ) ; con . setautocommit ( false ) ; pstrades = con . preparestatement ( pstradessql ) ; for ( matchprops mp : mprops ) { pstrades . setstring ( 1 , tradedatetime ) ; pstrades . setstring ( 2 , df . format ( mp . expiredatetime ) ) ; pstrades . setstring ( 3 , mp . buycpt ) ; pstrades . setstring ( 4 , mp . sellcpt ) ; pstrades . setstring ( 5 , mp . tradestatus ) ; pstrades . setstring ( 6 , mp . tradetype ) ; pstrades . setstring ( 7 , mp . asset ) ; pstrades . setlong ( 8 , mp . amount ) ; pstrades . setdouble ( 9 , mp . price . doublevalue ( ) ) ; pstrades . setlong ( 10 , mp . matchtradeid ) ; pstrades . setstring ( 11 , mp . vault ) ; pstrades . setstring ( 12 , mp . mprop1 ) ; pstrades . setstring ( 13 , mp . mprop2 ) ; pstrades . setstring ( 14 , mp . mprop3 ) ; pstrades . setstring ( 15 , mp . userid ) ; pstrades . addbatch ( ) ; } int [ ] recadded = pstrades . executebatch ( ) ; con . commit ( ) ; for ( int i = 0 ; i < recadded . length ; i ++ ) if ( recadded [ i ] == 1 ) retval ++ ; } catch ( sqlexception e ) { con . rollback ( ) ; system . out . println ( e . getmessage ( ) ) ; } finally { if ( pstrades != null ) pstrades . close ( ) ; if ( con != null ) con . close ( ) ; } } catch ( classnotfoundexception cnfe ) { system . out . println ( cnfe . getmessage ( ) ) ; } return retval ; }
va	5	public void testviewdata ( ) { viewdata viewdata = new viewdata ( "test" ) ; viewvariableaction vva = mock ( viewvariableaction . class ) ; string vvat = "performupdate" ; when ( vva . performupdate ( ) ) . thenreturn ( vvat ) ; viewvariable vv = new viewvariable ( new date ( ) , vva ) ; viewdata . setvariable ( "thedate" , vv ) ; viewdata . update ( ) ; boolean result = true ; verify ( vva ) . performupdate ( ) ; if ( ( ( string ) vv . getvariable ( ) ) . equalsignorecase ( vvat ) == false ) { result = false ; } asserttrue ( result ) ; }
va	5	private void generatepoints ( ) { if ( this . expression != null ) { this . parser . setexpression ( this . expression ) ; double steps = ( this . interval . getdistance ( ) + 1 ) / this . xticksnum ; arraylist < java . lang . double > result = this . parser . eval ( this . interval , steps ) ; double maxy = result . get ( 0 ) ; double miny = result . get ( 0 ) ; for ( int i = 0 ; i < result . size ( ) ; i ++ ) { this . points . add ( new point2d . double ( this . interval . start + i * steps , result . get ( i ) ) ) ; if ( result . get ( i ) > maxy ) maxy = result . get ( i ) ; if ( result . get ( i ) < miny ) miny = result . get ( i ) ; } this . origin = new point2d . double ( this . interval . start , miny ) ; this . axisx . setinterval ( this . interval . start , this . interval . end ) ; this . axisx . setnumticks ( xticksnum ) ; this . axisy . setinterval ( miny , maxy ) ; this . axisy . setnumticks ( yticksnum ) ; } }
va	8	public static void main ( string [ ] args ) { try { printstream out = system . out ; board board = new board ( out , arrays . aslist ( " " , " " , " " , " " , " " , " " , " " , " " , " " ) ) ; inputstreamreader isr = new inputstreamreader ( system . in ) ; inputoutputhelper iohelper = new inputoutputhelper ( new bufferedreader ( isr ) , out ) ; player player1 = new player ( iohelper , "x" , board ) ; player player2 = new player ( iohelper , "o" , board ) ; playeralternator alternator = new playeralternator ( player1 , player1 , player2 ) ; game game = new game ( board , alternator , out ) ; game . go ( ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } }
va	4	public int [ ] twosum ( int [ ] numbers , int target ) { hashmap < integer , integer > maps = new hashmap < integer , integer > ( ) ; for ( int i = 0 ; i < numbers . length ; i ++ ) { maps . put ( numbers [ i ] , i ) ; } for ( int i = 0 ; i < numbers . length ; i ++ ) { if ( maps . containskey ( target - numbers [ i ] ) ) { int index1 = i + 1 ; int index2 = maps . get ( target - numbers [ i ] ) + 1 ; if ( index1 > index2 ) { return new int [ ] { index2 , index1 } ; } else return new int [ ] { index1 , index2 } ; } } return numbers ; }
va	5	public static sentence findgoodsentence ( sentence s , int credits ) { list < sentence > sl = new arraylist < sentence > ( ) ; list < sentence > nsl = new arraylist < sentence > ( ) ; sl . add ( s ) ; for ( int i = 0 ; i < credits ; i ++ ) { system . out . println ( "credit: " + i ) ; if ( sl . size ( ) == 0 ) { system . out . println ( "no more senses found" ) ; return null ; } for ( iterator < sentence > iterator = sl . iterator ( ) ; iterator . hasnext ( ) ; ) { sentence sentence = ( sentence ) iterator . next ( ) ; if ( checkgrammar ( sentence ) ) { return sentence ; } else { nsl . addall ( sentence . getnextpossiblesenses ( ) ) ; } } sl = new arraylist < sentence > ( nsl ) ; nsl . clear ( ) ; } return null ; }
va	3	public static void main ( string [ ] args ) throws filenotfoundexception { boolean iscreate = false ; string dirname = pre + random . nextint ( 100 ) ; file file = new file ( "./" , dirname ) ; if ( file . exists ( ) ) { system . err . printf ( "%s exists!\\n" , dirname ) ; system . exit ( 1 ) ; } else { iscreate = file . mkdir ( ) ; } if ( iscreate ) { system . out . printf ( "created %s" , file . getabsolutepath ( ) ) ; } else { system . out . println ( "fail to create" ) ; } }
va	6	@ override public list < ? extends searchnode > getsuccessors ( ) { list < superqueenssearchnode > succlist = new arraylist < superqueenssearchnode > ( ) ; int n = ( ( superqueensstate ) state ) . getqueennum ( ) ; for ( int j = 0 ; j < n ; j ++ ) { list < integer > childpositions = new arraylist < integer > ( ( ( superqueensstate ) state ) . getqueenspositions ( ) ) ; if ( ! childpositions . contains ( j ) ) { childpositions . add ( j ) ; superqueensstate childstate = new superqueensstate ( childpositions , n ) ; superqueenssearchnode childnode = new superqueenssearchnode ( childstate , this , 0 ) ; succlist . add ( childnode ) ; } else continue ; } return succlist ; }
va	2	public void send ( string messagename , string type , string value ) { jsonobject m = new jsonobject ( ) ; m . put ( "clientname" , name ) ; m . put ( "name" , messagename ) ; m . put ( "type" , type ) ; m . put ( "value" , value ) ; jsonobject sm = new jsonobject ( ) ; sm . put ( "message" , m ) ; if ( connectionestablished ) { wsclient . send ( sm . tostring ( ) ) ; } else { system . err . println ( "[send] can't send message<litcomma> not currently connected!" ) ; } }
va	6	private double variance ( node [ ] ends ) { int words = 0 ; int maxlength = 0 ; for ( ; words < ends . length && ends [ words ] != null ; maxlength += ends [ words ] . wordlength ( ) , words ++ ) ; double avglength = ( double ) maxlength / words ; double variance2 = 0.0 ; for ( node end : ends ) { if ( end == null ) { break ; } double difference = end . wordlength ( ) - avglength ; variance2 += difference * difference ; } return variance2 ; }
va	9	public void getinput ( ) { scanner scanner = new scanner ( system . in ) ; int a , b , count = 0 , val1 , startsquare = 0 ; double value , newvalue , m ; while ( scanner . hasnextint ( ) ) { a = scanner . nextint ( ) ; b = scanner . nextint ( ) ; if ( a == 0 && b == 0 ) break ; value = math . sqrt ( a ) ; val1 = ( int ) math . sqrt ( a ) ; newvalue = val1 ; if ( a == b ) { if ( value == newvalue ) { system . out . println ( "2" ) ; } else { system . out . println ( "0" ) ; } } else { if ( value > newvalue ) { startsquare = val1 + 1 ; } else { startsquare = val1 ; } m = math . pow ( startsquare , 2 ) ; while ( m <= b ) { m = math . pow ( startsquare ++ , 2 ) ; if ( m <= b ) { count ++ ; } } system . out . println ( count ) ; count = 0 ; } } }
va	9	public static void main ( string [ ] args ) throws exception { if ( args . length == 0 ) { system . out . println ( "please specify a url as an argument." ) ; system . exit ( 1 ) ; } string urlpath = args [ 0 ] ; url url = new url ( urlpath ) ; string filename = null ; if ( args . length > 1 ) filename = args [ 1 ] ; else { int / = urlpath . lastindexof ( "/" ) ; int end = urlpath . lastindexof ( "?" ) ; if ( end < 0 ) end = urlpath . length ( ) ; filename = urlpath . substring ( / + 1 , end ) ; if ( filename . equals ( "" ) ) filename = "index.html" ; } system . out . println ( "downloading " + urlpath + " to " + filename ) ; inputstream in = url . openstream ( ) ; fileoutputstream out = new fileoutputstream ( filename ) ; byte [ ] buf = new byte [ 65536 ] ; while ( true ) { int r = in . read ( buf ) ; if ( r <= 0 ) break ; out . write ( buf , 0 , r ) ; } out . close ( ) ; in . close ( ) ; }
va	6	public list < payment > getallpayments ( ) { session session = sessionfactory . opensession ( ) ; query query = session . createquery ( "from payment" ) ; list < payment > paymentlist = new arraylist < payment > ( ) ; @ suppresswarnings ( "unchecked" ) list < payment > allpayments = query . list ( ) ; session . close ( ) ; for ( int i = 0 ; i < allpayments . size ( ) ; i ++ ) { payment order = ( payment ) allpayments . get ( i ) ; paymentlist . add ( order ) ; } return paymentlist ; }
va	9	@ override public modulegroup load ( string name , url base ) throws ioexception { url url = new url ( base . tostring ( ) + "/modules.json" ) ; log . info ( "loading group {} from file {}" , name , url ) ; modulegroup group = new modulegroup ( ) ; group . setname ( name ) ; group . setbase ( "/" + name ) ; objectmapper objectmapper = new objectmapper ( ) ; objectnode rootnode = objectmapper . readvalue ( url , objectnode . class ) ; set < module > modules = new hashset < > ( ) ; iterator < map . entry < string , jsonnode > > iter = rootnode . getfields ( ) ; while ( iter . hasnext ( ) ) { map . entry < string , jsonnode > next = iter . next ( ) ; string modulename = next . getkey ( ) ; jsonnode nextnode = next . getvalue ( ) ; if ( nextnode instanceof objectnode ) { modules . add ( build ( modulename , base , ( objectnode ) nextnode ) ) ; } else { log . warn ( "found non-object node at module level: {}" , modulename ) ; } } group . setmodules ( modules ) ; return group ; }
va	8	public static void main ( string [ ] args ) { parameters p = new parameters ( ) ; p . setdomainname ( "watchmouse.com" ) ; p . setpassword ( "password" ) ; p . setportnumber ( "389" ) ; string [ ] at = { "samaccountname" , "mail" , "useraccountcontrol" } ; p . setretrieveattributes ( at ) ; string [ ] sq = { "dc=watchmouse<litcomma>dc=com" } ; p . setsearchqueries ( sq ) ; p . setserverip ( "192.168.0.71" ) ; p . setsslon ( "false" ) ; p . setusername ( "administrator" ) ; adsynch ad = new adsynch ( p ) ; try { list < user > e = ad . processrequest ( ) ; for ( user user : e ) { string [ ] s = user . getattributevalues ( ) ; for ( string string : s ) { system . out . print ( string + "::" ) ; } system . out . println ( ) ; } } catch ( sslhandshakeexception e ) { logger . error ( e . getmessage ( ) , e ) ; } catch ( communicationexception e ) { logger . error ( e . getmessage ( ) , e ) ; } catch ( namingexception e ) { logger . error ( e . getmessage ( ) , e ) ; } catch ( nullpointerexception e ) { logger . error ( e . getmessage ( ) , e ) ; } catch ( exception e ) { logger . error ( e . getmessage ( ) , e ) ; } }
va	1	private double perform ( string operator , double num ) { double trignum = num ; if ( ! this . isradian ) trignum = degreetoradian ( num ) ; switch ( operator ) { case "sin" : return math . sin ( trignum ) ; case "cos" : return math . cos ( trignum ) ; case "tan" : if ( math . cos ( trignum ) == 0 ) throw new illegalargumentexception ( "angel is divisible by 90." ) ; return math . sin ( trignum ) / math . cos ( trignum ) ; case "cot" : if ( math . sin ( trignum ) == 0 ) throw new illegalargumentexception ( "angel is divible by 180." ) ; return math . cos ( trignum ) / math . sin ( trignum ) ; case "ln" : return math . log ( num ) ; case "log" : return math . log10 ( num ) ; default : throw new illegalargumentexception ( "illegal operator." ) ; } }
va	3	private void test ( string str1 , string str2 ) { total ++ ; try { sequence seq1 = new sequence ( str1 ) ; sequence seq2 = new sequence ( str2 ) ; if ( ! ( seq1 . tostring ( ) . equals ( str1 ) ) || ! ( seq2 . tostring ( ) . equals ( str2 ) ) ) { string message = "\\nfailed: " + str1 + " returned: " + seq1 . tostring ( ) ; system . err . println ( message ) ; failmessages . add ( message ) ; failure ++ ; return ; } if ( ! ( seq1 . compareto ( seq2 ) == str1 . compareto ( str2 ) ) ) { string message = "\\nfailed: " + str1 + " compareto " + str2 + " returned: " + seq1 . compareto ( seq2 ) + " expected: " + str1 . compareto ( str2 ) ; system . err . println ( message ) ; failmessages . add ( message ) ; failure ++ ; return ; } else { success ++ ; } } catch ( sequenceexception e ) { string message = "\\nfailed: " + str1 + " and " + str2 + "-- error: " + e . getmessage ( ) ; system . err . println ( message ) ; failmessages . add ( message ) ; failure ++ ; } }
va	2	private int find_k ( int a [ ] , int starta , int b [ ] , int startb , int k ) { if ( a . length == 0 || a . length <= starta ) return b [ startb + k - 1 ] ; if ( b . length == 0 || b . length <= startb ) return a [ starta + k - 1 ] ; if ( k == 1 ) { if ( a [ starta ] < b [ startb ] ) return a [ starta ] ; else return b [ startb ] ; } int checkaindex = k / 2 ; if ( starta + checkaindex > a . length ) checkaindex = a . length - starta ; int checkbindex = k - checkaindex ; checkaindex -- ; checkbindex -- ; if ( a [ starta + checkaindex ] == b [ startb + checkbindex ] ) return a [ starta + checkaindex ] ; if ( a [ starta + checkaindex ] < b [ startb + checkbindex ] ) { starta += checkaindex + 1 ; k = k - checkaindex - 1 ; return find_k ( a , starta , b , startb , k ) ; } else { startb += checkbindex + 1 ; k = k - checkbindex - 1 ; return find_k ( a , starta , b , startb , k ) ; } }
va	3	public string registrarcliente ( string cli ) throws remoteexception { clienteinterface c ; try { c = ( clienteinterface ) naming . lookup ( cli ) ; if ( ! clientes . isempty ( ) ) { for ( clienteinterface cliente : clientes ) { if ( cliente . getnome ( ) . equals ( cli ) ) { return "cliente ja registrado" ; } } } this . clientes . add ( c ) ; for ( clienteinterface cl : clientes ) { cl . setclienteslogados ( this . getclientescadastrados ( ) ) ; } } catch ( exception e ) { system . out . println ( "erro: :( " + e . getmessage ( ) ) ; } return "cliente registrado com sucesso" ; }
va	10	static void process_changesets_url_common ( url passed_url , string passed_display_name , string passed_uid , string passed_id , string passed_min_lat_string , string passed_min_lon_string , string passed_max_lat_string , string passed_max_lon_string , string passed_download_changeset , string passed_building , boolean passed_overlapnodes , string passed_download_nodes ) throws exception { if ( arg_debug >= log_informational_2 ) { system . out . println ( "url: " + passed_url ) ; } inputstreamreader input ; urlconnection urlconn = passed_url . openconnection ( ) ; urlconn . setdoinput ( true ) ; urlconn . setdooutput ( false ) ; urlconn . setusecaches ( false ) ; try { input = new inputstreamreader ( urlconn . getinputstream ( ) ) ; char [ ] data = new char [ 256 ] ; int len = 0 ; stringbuffer sb = new stringbuffer ( ) ; while ( - 1 != ( len = input . read ( data , 0 , 255 ) ) ) { sb . append ( new string ( data , 0 , len ) ) ; } documentbuilderfactory myfactory = documentbuilderfactory . newinstance ( ) ; documentbuilder mybuilder = myfactory . newdocumentbuilder ( ) ; bytearrayinputstream inputstream = new bytearrayinputstream ( sb . tostring ( ) . getbytes ( "utf-8" ) ) ; document mydocument = mybuilder . parse ( inputstream ) ; element rootelement = mydocument . getdocumentelement ( ) ; process_changesets_xml ( rootelement , passed_display_name , passed_uid , passed_min_lat_string , passed_min_lon_string , passed_max_lat_string , passed_max_lon_string , passed_download_changeset , passed_building , passed_overlapnodes , passed_download_nodes ) ; input . close ( ) ; } catch ( exception ex ) { if ( arg_debug >= log_error ) { system . out . println ( "error obtaining: " + passed_url ) ; } if ( arg_out_file != "" ) { myprintstream . println ( passed_display_name + ";" + passed_uid + ";" + passed_id + ";;;;0 changesets<litcomma> error obtaining" ) ; } } }
va	7	public list buildrequest ( ) { list request = new arraylist < string > ( ) ; string params = "" ; if ( this . method == method . get ) { string data = "" ; for ( iterator i = this . getparameters ( ) . keyset ( ) . iterator ( ) ; i . hasnext ( ) ; ) { string key = ( string ) i . next ( ) ; data += "&" + key + "=" + this . parameters . get ( key ) ; } if ( ! data . isempty ( ) ) params = "?" + data . substring ( 1 ) ; } request . add ( this . getmethod ( ) . tostring ( ) + " " + this . getresourcepath ( ) + params + " http/1.1" ) ; request . add ( "host: " + this . gethost ( ) ) ; for ( iterator i = this . getheaders ( ) . keyset ( ) . iterator ( ) ; i . hasnext ( ) ; ) { string key = ( string ) i . next ( ) ; request . add ( key + ": " + getheaders ( ) . get ( key ) ) ; } if ( this . ismultipart ( ) ) { string boundary = "---------------------------1298224831751237580694844359" ; int brkcount = 2 ; string data = "\\n" ; for ( iterator i = this . getparameters ( ) . keyset ( ) . iterator ( ) ; i . hasnext ( ) ; ) { string key = ( string ) i . next ( ) ; data += boundary + "\\n" ; data += "content-disposition: form-data; name=\\"" + key + "\\"\\n" ; data += "\\n" ; data += ( string ) this . getparameters ( ) . get ( key ) + "\\n" ; brkcount += 8 ; } data += boundary + "--" ; request . add ( "content-type: multipart/form-data; boundary=" + boundary ) ; request . add ( "content-length: " + ( data . length ( ) + brkcount ) ) ; request . add ( data ) ; } else if ( this . method == method . post ) { string data = "" ; for ( iterator i = this . getparameters ( ) . keyset ( ) . iterator ( ) ; i . hasnext ( ) ; ) { string key = ( string ) i . next ( ) ; data += "&" + key + "=" + this . parameters . get ( key ) ; } data = data . substring ( 1 ) ; request . add ( "content-length: " + data . length ( ) ) ; request . add ( "" ) ; request . add ( data ) ; } return request ; }
va	4	public void printwordlist ( string partialword , int state , printwriter out ) throws ioexception { if ( state == 0xffff ) { system . out . println ( partialword ) ; if ( out != null ) { out . println ( partialword ) ; } } else { for ( int i = 0 ; i < numcols ; i ++ ) { int newstate = ( getnextstate ( state , i ) ) & 0xffff ; if ( newstate != 0 ) { char newchar = reversecolumnmap [ i ] ; string newpartialword = partialword ; if ( newchar != 0 ) { newpartialword += newchar ; } printwordlist ( newpartialword , newstate , out ) ; } } } }
va	6	@ override public void call ( ) throws exception { long start = system . currenttimemillis ( ) ; delegate . call ( ) ; long end = system . currenttimemillis ( ) ; timing . adddatum ( end - start ) ; if ( logstats ) { runtime runtime = runtime . getruntime ( ) ; int average = ( int ) timing . getaverage ( ) ; log . info ( "average time per recommendation: {}ms" , average ) ; long totalmemory = runtime . totalmemory ( ) ; long memory = totalmemory - runtime . freememory ( ) ; log . info ( "approximate memory used: {}mb / {}mb" , memory / 1000000l , totalmemory / 1000000l ) ; log . info ( "unable to recommend in {} cases" , noestimatecounter . get ( ) ) ; } return null ; }
va	2	private static int printresults ( list < edge > finalmst ) { int totalcost = 0 ; for ( edge mstedge : finalmst ) { totalcost += mstedge . getcost ( ) ; } system . out . println ( totalcost ) ; system . out . println ( "-----" ) ; for ( edge mstedge : finalmst ) { system . out . println ( mstedge . getstart ( ) + "\\t" + mstedge . getfinish ( ) + "\\t" + mstedge . getcost ( ) ) ; } system . out . println ( ) ; return totalcost ; }
va	6	public static void main ( string [ ] args ) { shoe shoe = new shoe ( 4 ) ; hand handp1 = new hand ( shoe . dealcard ( ) , shoe . dealcard ( ) ) ; hand handp2 = new hand ( shoe . dealcard ( ) , shoe . dealcard ( ) ) ; hand handp3 = new hand ( shoe . dealcard ( ) , shoe . dealcard ( ) ) ; player player1 = new player ( handp1 , "jake" , 435.0 ) ; system . out . println ( player1 . tostring ( ) ) ; system . out . println ( "testing playerbet() - betting $35" ) ; player1 . playerbet ( 35.0 ) ; system . out . println ( player1 . tostring ( ) ) ; system . out . println ( "testing insurance() - player can purchase insurance" ) ; player1 . insurance ( ) ; system . out . println ( player1 . tostring ( ) ) ; system . out . println ( "testing gethand()" ) ; system . out . println ( player1 . gethand ( ) ) ; system . out . println ( "testing getbank()" ) ; system . out . println ( player1 . getbank ( ) ) ; system . out . println ( "testing getbet()" ) ; system . out . println ( player1 . getbet ( ) ) ; system . out . println ( "testing getbankstring()" ) ; system . out . println ( player1 . getbankstring ( ) ) ; system . out . println ( "testing gethandarray() and tostring() of hand.java" ) ; system . out . println ( player1 . gethandarray ( ) . tostring ( ) ) ; player player2 = new player ( handp2 , "bob" , 10.0 ) ; system . out . println ( "testing blackjack() with $10" ) ; player2 . playerbet ( 10.0 ) ; player2 . blackjack ( ) ; system . out . println ( "player wins - can lead to blackjack" ) ; player2 . wonbet ( ) ; system . out . println ( player1 . tostring ( ) ) ; system . out . println ( "player hits" ) ; player2 . hit ( shoe . dealcard ( ) ) ; system . out . println ( player1 . tostring ( ) ) ; system . out . println ( "testing blackjack()" ) ; player2 . blackjack ( ) ; system . out . println ( player1 . tostring ( ) ) ; system . out . println ( "testing playerlost()" ) ; player2 . playerlost ( ) ; system . out . println ( player1 . tostring ( ) ) ; system . out . println ( "testing playerbust()" ) ; player2 . playerbust ( ) ; system . out . println ( player2 . tostring ( ) ) ; }
va	5	private string extractproperty ( string propertyname ) throws fetchlinksexception { jsonparser parser = new jsonparser ( ) ; try { jsonobject responsejson = ( jsonobject ) parser . parse ( this . response ) ; if ( ! responsejson . isjsonnull ( ) ) { jsonobject linksjson = responsejson . getasjsonobject ( this . selfdescribing_property ) ; if ( ! linksjson . isjsonnull ( ) ) { jsonprimitive propertyjson = linksjson . getasjsonprimitive ( propertyname ) ; if ( ! propertyjson . isjsonnull ( ) ) { string returnvalue = propertyjson . getasstring ( ) ; if ( ! returnvalue . endswith ( "/" ) ) returnvalue += "/" ; return returnvalue ; } } } } catch ( jsonparseexception ex ) { throw new fetchlinksexception ( ) ; } throw new fetchlinksexception ( ) ; }
va	7	private final void log_this ( request rq ) { if ( logpatterns != null && rq != null ) { int j = logpatterns . length ; string urlcache = rq . geturl ( ) ; for ( int i = 0 ; i < j ; i ++ ) { string fragment ; fragment = mgr . simplewildmatch ( logpatterns [ i ] , urlcache ) ; if ( fragment == null ) continue ; dataoutputstream outfile ; outfile = logfilez [ i ] ; if ( outfile == null ) if ( logfilenames [ i ] != null ) synchronized ( logfilenames ) { if ( ! open_logfile ( logfilenames , logfilez , i ) ) break ; else outfile = logfilez [ i ] ; } else break ; inetaddress adr ; adr = socket . getinetaddress ( ) ; stringbuffer sb = new stringbuffer ( 90 ) ; sb . append ( adr . gethostaddress ( ) ) ; sb . append ( " - - [" ) ; synchronized ( formatter ) { formatter . format ( new date ( ) , sb , fpos ) ; } sb . append ( timezone ) ; sb . append ( methodtostring ( rq . method ) ) ; sb . append ( " " ) ; if ( logpatterns [ i ] != null ) sb . append ( "/" ) ; sb . append ( fragment ) ; sb . append ( "\\" " ) ; sb . append ( rq . httprc ) ; sb . append ( " " ) ; sb . append ( rq . log_size ) ; if ( ! log_common ) { sb . append ( " \\"" ) ; sb . append ( rq . log_referer ) ; sb . append ( "\\" \\"" ) ; sb . append ( rq . log_uagent ) ; sb . append ( "\\"" ) ; } sb . append ( newline ) ; synchronized ( outfile ) { try { outfile . writebytes ( sb . tostring ( ) ) ; } catch ( ioexception errr ) { logfilez [ i ] = null ; } } } } }
va	2	public void actionperformed ( actionevent e ) { string temp = ram_size . gettext ( ) ; try { invalid_ram_lbl . setbounds ( 112 , 175 , 140 , 20 ) ; invalid_ram_lbl . settext ( "ram must be numeric" ) ; int tempint = integer . parseint ( temp ) ; if ( 768 >= tempint ) { invalid_ram_lbl . settext ( "ram must be greater than 768mb" ) ; invalid_ram_lbl . setbounds ( 75 , 175 , 230 , 20 ) ; throw new exception ( ) ; } } catch ( exception e1 ) { invalid_ram_lbl . setvisible ( true ) ; return ; } prefs . put ( "ram_size" , temp ) ; invalid_ram_lbl . setvisible ( false ) ; settingswindow ( false ) ; mainwindow ( true ) ; }
va	4	public void insertaabbiterativo ( t dato ) { nodoarbol < t > nodato = new nodoarbol < t > ( dato ) ; int i ; if ( this . raiz == null ) this . raiz = nodato ; else { nodoarbol < t > temp = this . raiz ; i = temp . dato . compareto ( dato ) ; nodoarbol < t > pos = null ; if ( i == 0 ) return ; if ( i > 0 ) pos = temp . izq ; if ( i < 0 ) pos = temp . der ; while ( pos != null ) { temp = pos ; i = temp . dato . compareto ( dato ) ; if ( i == 0 ) return ; if ( i > 0 ) pos = temp . izq ; if ( i < 0 ) pos = temp . der ; } if ( i > 0 ) temp . izq = nodato ; if ( i < 0 ) temp . der = nodato ; } }
va	6	public int [ ] [ ] calculodistanciaporeuclides ( double [ ] [ ] coordenadas , int numerodeciudades ) { final int indiceprimeracoordenada = 0 ; final int indicesegundacoordenada = 1 ; int matrizdistancias [ ] [ ] = new int [ numerodeciudades ] [ numerodeciudades ] ; int dist = 0 ; for ( int j = 0 ; j < coordenadas . length ; j ++ ) { for ( int i = j ; i < coordenadas . length ; i ++ ) { dist = ( int ) math . floor ( .5 + math . sqrt ( math . pow ( coordenadas [ i ] [ indiceprimeracoordenada ] - coordenadas [ j ] [ indiceprimeracoordenada ] , 2.0 ) + math . pow ( coordenadas [ i ] [ indicesegundacoordenada ] - coordenadas [ j ] [ indicesegundacoordenada ] , 2.0 ) ) ) ; matrizdistancias [ i ] [ j ] = dist ; matrizdistancias [ j ] [ i ] = dist ; } } return matrizdistancias ; }
va	5	public static long stringtolong ( string num ) { if ( null == num || num . length ( ) == 0 ) { system . out . println ( "empty entry." ) ; return - 1 ; } boolean res = checkifnum ( num ) ; if ( ! res ) { return - 1 ; } int len = num . length ( ) ; int i = 0 ; boolean neg = false ; long result = 0 ; while ( i < len ) { if ( i == 0 && num . charat ( i ) == '-' ) { neg = true ; } else { result = result * 10 + ( num . charat ( i ) - '0' ) ; } i ++ ; } if ( neg ) { result *= ( - 1 ) ; } return result ; }
va	7	public static void unzipfileintodirectory ( zipfile zipfile , file directory ) { enumeration files = zipfile . entries ( ) ; while ( files . hasmoreelements ( ) ) { try { zipentry entry = ( zipentry ) files . nextelement ( ) ; inputstream inputstream = zipfile . getinputstream ( entry ) ; byte [ ] buffer = new byte [ 1024 ] ; int bytesread ; file file = new file ( directory . getabsolutepath ( ) + file . separator + entry . getname ( ) ) ; if ( entry . isdirectory ( ) ) { file . mkdirs ( ) ; continue ; } else { file . getparentfile ( ) . mkdirs ( ) ; file . createnewfile ( ) ; } fileoutputstream fileoutputstream = new fileoutputstream ( file ) ; while ( ( bytesread = inputstream . read ( buffer ) ) != - 1 ) { fileoutputstream . write ( buffer , 0 , bytesread ) ; } fileoutputstream . close ( ) ; } catch ( ioexception ex ) { ex . printstacktrace ( ) ; } } try { zipfile . close ( ) ; } catch ( ioexception ex ) { ex . printstacktrace ( ) ; } }
va	10	private void matchresult ( ) { try { mmui . viewopeningrounds ( ) ; scanner sc = new scanner ( system . in , "iso-8859-1" ) ; system . out . println ( "match id or the two teams playing seperated by \\":\\" (hometeam:guestteam) :" ) ; if ( sc . hasnextint ( ) == true ) { int matchid = sc . nextint ( ) ; m = mmgr . getmatchbyid ( matchid ) ; } else { string matchteams = sc . nextline ( ) ; string [ ] ss = matchteams . split ( ":" ) ; team team1 = tmgr . getteambyname ( ss [ 0 ] ) ; team team2 = tmgr . getteambyname ( ss [ 1 ] ) ; m = mmgr . getmatchbyteams ( team1 . getteamid ( ) , team2 . getteamid ( ) ) ; } system . out . println ( "hometeam scored: " ) ; int homegoals = sc . nextint ( ) ; m . sethomegoals ( homegoals ) ; system . out . println ( "guestteam scored: " ) ; int guestgoals = sc . nextint ( ) ; m . setguestgoals ( guestgoals ) ; if ( homegoals < guestgoals ) { team tguest = tmgr . getteambyid ( m . getguestteamid ( ) ) ; tguest . addpoints ( 3 ) ; tmgr . updateteam ( tguest ) ; } else if ( homegoals == guestgoals ) { team thome = tmgr . getteambyid ( m . gethometeamid ( ) ) ; team tguest = tmgr . getteambyid ( m . getguestteamid ( ) ) ; tguest . addpoints ( 1 ) ; thome . addpoints ( 1 ) ; tmgr . updateteam ( tguest ) ; tmgr . updateteam ( thome ) ; } else { team thome = tmgr . getteambyid ( m . gethometeamid ( ) ) ; thome . addpoints ( 3 ) ; tmgr . updateteam ( thome ) ; } m . setisplayed ( true ) ; mmgr . update ( m ) ; } catch ( sqlexception ex ) { system . out . println ( "error - " + ex . getmessage ( ) ) ; } }
te	3	private static vector < integer > checkneighbourhood ( bufferedimage img , int x , int y , int r ) { vector < integer > vect = new vector < > ( ) ; for ( int i = x - r ; i <= x + r ; i ++ ) { for ( int j = y - r ; j <= y + r ; j ++ ) { if ( i >= 0 && j >= 0 && i < img . getwidth ( ) && j < img . getheight ( ) ) { if ( img . getrgb ( i , j ) == - 1 && ! ( i == x && j == y ) ) { vect . addelement ( i ) ; vect . addelement ( j ) ; return vect ; } } } } return vect ; }
te	6	private static void setup ( ) { loggercontext logctx = ( loggercontext ) loggerfactory . getiloggerfactory ( ) ; patternlayoutencoder logencoder = new patternlayoutencoder ( ) ; logencoder . setcontext ( logctx ) ; logencoder . setpattern ( "%-12date{yyyy-mm-dd hh:mm:ss.sss} %-5level - %msg%n" ) ; logencoder . start ( ) ; consoleappender < iloggingevent > logconsoleappender = new consoleappender < > ( ) ; logconsoleappender . setcontext ( logctx ) ; logconsoleappender . setname ( "console" ) ; logconsoleappender . setencoder ( logencoder ) ; logconsoleappender . start ( ) ; logencoder = new patternlayoutencoder ( ) ; logencoder . setcontext ( logctx ) ; logencoder . setpattern ( "%-12date{yyyy-mm-dd hh:mm:ss.sss} %-5level - %msg%n" ) ; logencoder . start ( ) ; rollingfileappender < iloggingevent > logfileappender = new rollingfileappender < > ( ) ; logfileappender . setcontext ( logctx ) ; logfileappender . setname ( "logfile" ) ; logfileappender . setencoder ( logencoder ) ; logfileappender . setappend ( true ) ; logfileappender . setfile ( "logs/logfile.log" ) ; timebasedrollingpolicy < iloggingevent > logfilepolicy = new timebasedrollingpolicy < > ( ) ; logfilepolicy . setcontext ( logctx ) ; logfilepolicy . setparent ( logfileappender ) ; logfilepolicy . setfilenamepattern ( "logs/logfile-%d{yyyy-mm-dd_hh}.log" ) ; logfilepolicy . setmaxhistory ( 7 ) ; logfilepolicy . start ( ) ; logfileappender . setrollingpolicy ( logfilepolicy ) ; logfileappender . start ( ) ; logger log = logctx . getlogger ( "main" ) ; log . setadditive ( false ) ; log . setlevel ( level . info ) ; log . addappender ( logconsoleappender ) ; log . addappender ( logfileappender ) ; }
te	8	public void verify_features ( string types_path ) { arraylist < integer > max_dimension = new arraylist ( ) ; arraylist < connectedcomponent > ccs = new arraylist < connectedcomponent > ( ) ; max_dimension = extract_cc_and_compute_maxheight_width ( types_path , ccs ) ; int passed = 0 , failed = 0 ; string result = "" ; for ( int i = 0 ; i < ccs . size ( ) ; i ++ ) { connectedcomponent cc = ccs . get ( i ) ; cc . bb_area = cc . cc_height * cc . cc_width ; result = nepclassifier . classifydecisiontree ( cc . cc_width , cc . cc_height , cc . bb_area , cc . black_pixelscount ) ; int featureid = getidfromstring ( result ) ; if ( featureid == cc . cc_type_id ) { system . out . println ( "verification passed = " + featureid ) ; passed ++ ; } else { system . out . println ( "verification failed = " + featureid ) ; failed ++ ; } } system . out . println ( "==================================" ) ; system . out . println ( "total passed:" + passed ) ; system . out . println ( "total failed:" + failed ) ; }
te	9	private static void sendpagelist ( commandsender sender , int page , set < string > names ) { int total = names . size ( ) ; int totalperpage = 10 ; int totalpages = total / totalperpage + 1 ; int startindex = ( page - 1 ) * totalperpage ; int endindex = startindex + totalperpage ; sender . sendmessage ( chatcolor . green + "list of all help pages " + chatcolor . white + "(" + page + "/" + totalpages + ")" + chatcolor . green + ":" ) ; string [ ] namearray = names . toarray ( new string [ names . size ( ) ] ) ; for ( int i = startindex ; i < endindex && i < total ; i ++ ) { string userfriendly = "/" + namearray [ i ] . replace ( "-" , " " ) ; sender . sendmessage ( chatcolor . dark_gray + " " + i + ". " + chatcolor . white + userfriendly ) ; } string nextpage ; if ( page == totalpages ) { nextpage = "1" ; } else { nextpage = string . valueof ( page + 1 ) ; } sender . sendmessage ( chatcolor . green + "next page: " + chatcolor . white + "/help -list " + nextpage ) ; }
te	7	public void receivejobs ( string path ) { jsonparser parser = new jsonparser ( ) ; try { jsonarray a = ( jsonarray ) parser . parse ( new filereader ( "file/" + path + ".json" ) ) ; for ( object o : a ) { jsonobject job = ( jsonobject ) o ; double complexity = double . parsedouble ( ( string ) job . get ( "complexity" ) ) ; double priority = double . parsedouble ( ( string ) job . get ( "priority" ) ) ; job j = new job ( priority , complexity ) ; jobqueue . add ( j ) ; } } catch ( filenotfoundexception e ) { e . printstacktrace ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } catch ( org . json . simple . parser . parseexception e ) { e . printstacktrace ( ) ; } }
te	4	@ override public sequence frombytearray ( byte [ ] bytes ) throws binaryreaderexception { if ( bytes . length != size ) { throw new binaryreaderexception ( "illegal byte array size: " + bytes . length + " (expected " + size + ")" ) ; } long code = 0 ; byte len = bytes [ 0 ] ; for ( int i = 1 ; i < 9 ; i ++ ) { code = code << 8 ; int b = 255 & bytes [ i ] ; code = code | b ; } return new sequence ( code , len ) ; }
te	2	private void inspectsuperclass ( vector superclassobjectstoinspect , boolean recursive ) { if ( superclassobjectstoinspect . size ( ) > 0 ) system . out . println ( "---- inspecting super classes ----" ) ; enumeration e = superclassobjectstoinspect . elements ( ) ; while ( e . hasmoreelements ( ) ) { class s = ( class ) e . nextelement ( ) ; system . out . println ( "inspecting superclass: " + s . getname ( ) ) ; try { system . out . println ( "******************" ) ; inspect ( s , recursive ) ; system . out . println ( "******************" ) ; } catch ( exception exp ) { exp . printstacktrace ( ) ; } } }
te	1	private static list < stockprice > getstockprices2 ( ) { list < stockprice > stockprices = new linkedlist < stockprice > ( ) ; stockprices . add ( new stockprice ( 1 , 2.0 ) ) ; stockprices . add ( new stockprice ( 2 , 3.0 ) ) ; stockprices . add ( new stockprice ( 3 , 10.0 ) ) ; stockprices . add ( new stockprice ( 4 , 4.0 ) ) ; stockprices . add ( new stockprice ( 5 , 1.0 ) ) ; stockprices . add ( new stockprice ( 6 , 7.0 ) ) ; return stockprices ; }
te	1	public void resettowers ( ) { towers = new tower [ towerutil . num_spaces ] ; for ( int i = 0 ; i < towerutil . num_spaces ; ++ i ) towers [ i ] = new tower ( diskcount ) ; for ( int i = diskcount - 1 ; i >= 0 ; -- i ) towers [ 0 ] . adddisk ( new disk ( i + 1 , towerutil . disk_colors_tower_1 [ i ] ) ) ; for ( int i = diskcount - 1 ; i >= 0 ; -- i ) towers [ 1 ] . adddisk ( new disk ( i + 1 , towerutil . disk_colors_tower_2 [ i ] ) ) ; repaint ( ) ; }
te	3	@ override public void reflectattributevalues ( int theobject , reflectedattributes theattributes , byte [ ] tag , logicaltime thetime , eventretractionhandle retractionhandle ) { stringbuilder builder = new stringbuilder ( "reflection for object:" ) ; builder . append ( " handle=" ) . append ( theobject ) ; builder . append ( "<litcomma> tag=" ) . append ( encodinghelpers . decodestring ( tag ) ) ; double time = converttime ( thetime ) ; if ( thetime != null ) { builder . append ( "<litcomma> time=" ) . append ( time ) ; } builder . append ( "<litcomma> attributecount=" ) . append ( theattributes . size ( ) ) ; builder . append ( "\\n" ) ; for ( int i = 0 ; i < theattributes . size ( ) ; i ++ ) { try { builder . append ( "\\tattributehandle=" ) ; builder . append ( theattributes . getattributehandle ( i ) ) ; builder . append ( "<litcomma> attributevalue=" ) ; builder . append ( encodinghelpers . decodestring ( theattributes . getvalue ( i ) ) ) ; builder . append ( "\\n" ) ; } catch ( arrayindexoutofbounds aioob ) { } } if ( logenable ) { log ( builder . tostring ( ) ) ; } handleobjectparamschanged ( theobject , time , theattributes ) ; }
te	8	public static void main ( string [ ] args ) throws exception { boolean showdups = args [ 0 ] . equals ( "-v" ) ; string file = args [ showdups ? 1 : 0 ] ; arraylist < string > linelist = new arraylist < string > ( ) ; bufferedreader fin = new bufferedreader ( new filereader ( file ) ) ; while ( true ) { string line = fin . readline ( ) ; if ( line == null ) break ; linelist . add ( line ) ; } fin . close ( ) ; string [ ] lines = new string [ linelist . size ( ) ] ; linelist . toarray ( lines ) ; arrays . sort ( lines ) ; new file ( file ) . renameto ( new file ( file + ".old" ) ) ; printwriter fout = new printwriter ( new filewriter ( file ) ) ; for ( int i = 0 ; i < lines . length ; i ++ ) { if ( i == 0 || ! lines [ i ] . equals ( lines [ i - 1 ] ) ) fout . println ( lines [ i ] ) ; else if ( showdups ) system . out . println ( "duplicate line: " + lines [ i ] ) ; } fout . close ( ) ; }
te	10	public void makewords1 ( ) { permutations ( "" , letters , words5 ) ; for ( int j = 0 ; j < letters . length ( ) ; j ++ ) { letters = rotate ( letters ) ; permutations ( "" , letters . substring ( 1 ) , words4 ) ; } int x = words5 . size ( ) / 20 ; for ( int k = 0 ; k < words4 . size ( ) ; k += x ) permutations ( "" , words4 . get ( k ) . substring ( 1 ) , words3 ) ; mergesorter2 w5 = new mergesorter2 ( words5 ) ; mergesorter2 w4 = new mergesorter2 ( words4 ) ; mergesorter2 w3 = new mergesorter2 ( words3 ) ; w5 . sort ( ) ; w4 . sort ( ) ; w3 . sort ( ) ; binarysearcher bdict = new binarysearcher ( dictionary ) ; for ( int t = 0 ; t < words3 . size ( ) ; t ++ ) { if ( bdict . search ( words3 . get ( t ) ) ) { gamewords . add ( words3 . get ( t ) ) ; encrypted . add ( "???" ) ; } else { words3 . remove ( t ) ; t -- ; } } for ( int s = 0 ; s < words4 . size ( ) ; s ++ ) { if ( bdict . search ( words4 . get ( s ) ) ) { gamewords . add ( words4 . get ( s ) ) ; encrypted . add ( "????" ) ; } else { words4 . remove ( s ) ; s -- ; } } for ( int r = 0 ; r < words5 . size ( ) ; r ++ ) { if ( bdict . search ( words5 . get ( r ) ) ) { gamewords . add ( words5 . get ( r ) ) ; encrypted . add ( "?????" ) ; } else { words5 . remove ( r ) ; r -- ; } } }
te	6	@ override public httpresponse handlerequest ( httprequest request ) throws exception { if ( request . geturi ( ) . endswith ( "/get" ) ) { string getparams = request . getparameters ( ) . tostring ( ) ; return new httpresponse ( getparams ) ; } if ( request . geturi ( ) . endswith ( "/post" ) ) { string postparams = request . postparameters ( ) . tostring ( ) ; return new httpresponse ( postparams ) ; } if ( request . geturi ( ) . endswith ( "/error" ) ) { throw new exception ( "demo error" ) ; } if ( request . geturi ( ) . endswith ( "/badrequest" ) ) { return new httpresponsebadrequest ( "bad request" ) ; } if ( request . geturi ( ) . endswith ( "/redirect" ) ) { list < string > operation = request . getparameters ( ) . get ( "destination" ) ; string redirecturl = operation . get ( 0 ) ; return new httpresponseredirect ( redirecturl ) ; } if ( request . geturi ( ) . endswith ( "/form-page" ) ) { if ( request . getmethod ( ) . equals ( "get" ) ) { string form = "<html><form method='post'>first name: <input type=\\"text\\" name=\\"firstname\\"><br>last name: <input type=\\"text\\" name=\\"lastname\\"><input type=\\"submit\\" value=\\"submit\\"></form></html>" ; httpresponse resp = new httpresponse ( form ) ; return resp ; } else { httpresponse resp = new httpresponse ( request . postparameters ( ) . tostring ( ) ) ; return resp ; } } httpresponse resp = new httpresponse ( "golan business logic" ) ; return resp ; }
te	1	private color notecolor ( int fret ) { color fretcolor ; switch ( fret % 12 ) { case 1 : fretcolor = color . coral ; break ; case 2 : fretcolor = color . salmon ; break ; case 3 : fretcolor = color . bisque ; break ; case 4 : fretcolor = color . gold ; break ; case 5 : fretcolor = color . palegoldenrod ; break ; case 6 : fretcolor = color . lightgreen ; break ; case 7 : fretcolor = color . lightseagreen ; break ; case 8 : fretcolor = color . lightblue ; break ; case 9 : fretcolor = color . aquamarine ; break ; case 10 : fretcolor = color . violet ; break ; case 11 : fretcolor = color . blueviolet ; break ; case 12 : fretcolor = color . mediumpurple ; break ; default : fretcolor = color . lightblue ; break ; } return fretcolor ; }
te	9	public void run ( ) { for ( networkinterfaceaddress addr : device . addresses ) { if ( ! ( addr . address instanceof inet4address ) ) continue ; byte [ ] address = addr . address . getaddress ( ) ; byte [ ] subnet = addr . subnet . getaddress ( ) ; long addresslong = 0 ; long addrbase = 0 ; long numaddress = 0 ; for ( int i = 0 ; i < address . length ; i ++ ) { numaddress *= 256 ; numaddress += ( int ) ( ~ subnet [ i ] & 0x000000ff ) ; addrbase *= 256 ; addrbase += ( int ) ( ( address [ i ] & subnet [ i ] ) & 0x000000ff ) ; addresslong *= 256 ; addresslong += ( int ) ( address [ i ] & 0x000000ff ) ; } for ( int i = 0 ; i < numaddress ; i ++ ) { if ( i + addrbase == addresslong ) continue ; arppacket packet = new arppacket ( ) ; ethernetpacket ether = new ethernetpacket ( ) ; ether . frametype = ethernetpacket . ethertype_arp ; ether . src_mac = device . mac_address ; ether . dst_mac = new byte [ ] { ( byte ) 0xff , ( byte ) 0xff , ( byte ) 0xff , ( byte ) 0xff , ( byte ) 0xff , ( byte ) 0xff } ; packet . datalink = ether ; packet . hardtype = arppacket . hardtype_ether ; packet . prototype = arppacket . prototype_ip ; packet . hlen = 6 ; packet . plen = 4 ; packet . operation = arppacket . arp_request ; packet . sender_hardaddr = device . mac_address ; packet . sender_protoaddr = address ; packet . target_hardaddr = new byte [ ] { 0 , 0 , 0 , 0 , 0 , 0 } ; packet . target_protoaddr = longtobytearray ( i + addrbase ) ; synchronized ( sender ) { sender . sendpacket ( packet ) ; } } } }
te	10	@ override public void createtriplesfromfile ( string filename ) { try { boolean flag = true ; string filepath = "resources/output/" + filename . replace ( ".metadata" , "_metadata.ttl" ) ; bufferedwriter bw = new bufferedwriter ( new outputstreamwriter ( new fileoutputstream ( filepath ) , "utf8" ) ) ; bufferedreader in = new bufferedreader ( new inputstreamreader ( new fileinputstream ( inputfilepath + filename ) , "utf8" ) ) ; set < string > y = new hashset < string > ( ) ; string line , triple ; bw . write ( prefixes . prefixes ) ; triple = "<" + prefixes . homerfull + filename . replace ( ".metadata" , "." + type ) + "> a void:dataset ; \\n" ; while ( ( line = in . readline ( ) ) != null ) { string [ ] array = line . split ( "\\t" ) ; if ( array [ 0 ] . contains ( "locator" ) ) { triple += this . matchproperties . get ( array [ 0 ] ) + " <" + array [ 1 ] + "> ; \\n" ; } else if ( ( array [ 0 ] . contains ( "abstract" ) || ( array [ 0 ] . contains ( "category" ) ) ) ) { string [ ] x = array [ 1 ] . split ( ";" ) ; for ( string str : x ) { triple += this . matchproperties . get ( array [ 0 ] ) + " \\"" + str + "\\" ; \\n" ; } } else { triple += this . matchproperties . get ( array [ 0 ] ) + " \\"" + array [ 1 ] + "\\" ; \\n" ; } } triple += " .\\n" ; bw . write ( triple ) ; bw . close ( ) ; system . out . println ( type . touppercase ( ) + " metadata file: " + filename + " [triplified]" ) ; } catch ( filenotfoundexception ex ) { logger . getlogger ( triplifymetadata . class . getname ( ) ) . log ( level . severe , null , ex ) ; } catch ( ioexception ex ) { logger . getlogger ( triplifymetadata . class . getname ( ) ) . log ( level . severe , null , ex ) ; } }
te	6	public static int find ( string target , string pattern ) { if ( isempty ( target ) || isempty ( pattern ) ) return - 1 ; if ( target . length ( ) < pattern . length ( ) ) return - 1 ; patchars = build ( pattern ) ; right = new int [ patchars . length ] ; for ( int i = 0 ; i < pattern . length ( ) ; i ++ ) { right [ getposition ( pattern . charat ( i ) ) ] = i ; } int n = target . length ( ) ; int m = pattern . length ( ) ; int skip = 0 ; for ( int i = 0 ; i <= n - m ; i += skip ) { skip = 0 ; for ( int j = m - 1 ; j >= 0 ; j -- ) { if ( pattern . charat ( j ) != target . charat ( i + j ) ) { int p = getposition ( target . charat ( i + j ) ) ; if ( p == - 1 ) skip = j - p ; else skip = j - right [ p ] ; if ( skip < 1 ) skip = 1 ; break ; } } if ( skip == 0 ) return i ; } return - 1 ; }
te	1	public void actionperformed ( actionevent arg0 ) { setting . setstart ( true ) ; if ( rbtn_player1_human . isselected ( ) ) { setting . setplayer1 ( rbtn_player1_human . getname ( ) ) ; } else { setting . setplayer1 ( rbtn_player1_computer . getname ( ) ) ; } if ( rbtn_player2_human . isselected ( ) ) { setting . setplayer2 ( rbtn_player2_human . getname ( ) ) ; } else { setting . setplayer2 ( rbtn_player2_computer . getname ( ) ) ; } setting . setstart ( chckbxwannastart . isselected ( ) ) ; eventqueue . invokelater ( new runnable ( ) { public void run ( ) { try { ninemm window = new ninemm ( setting ) ; window . frame . setvisible ( true ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } } } ) ; }
te	10	public createdevent < activity > createactivity ( activity activity ) { string id = uuid . randomuuid ( ) . tostring ( ) ; activity . setid ( id ) ; { textthing textthing = new textthing ( ) ; textthing . setcreated ( new date ( ) ) ; textthing . setname ( "meting 2014-06-10" ) ; textthing . settext ( "<p>mauris eu feugiat lorem<litcomma> posuere sagittis eros. lorem ipsum dolor sit amet<litcomma> consectetur adipiscing elit. donec ornare mi sem<litcomma> eget rutrum lorem mollis vitae. sed fermentum risus nec sagittis mattis. quisque ac lacus sed justo pretium pharetra. vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia curae; ut porttitor sollicitudin justo vel fermentum. duis ac tellus enim. suspendisse facilisis aliquet velit ut adipiscing. phasellus vulputate neque commodo pellentesque gravida. quisque lacinia laoreet pharetra. curabitur metus diam<litcomma> elementum eu lacus et<litcomma> scelerisque scelerisque ante. morbi fermentum gravida dui in semper. nam lacinia fermentum est ultrices tincidunt.</p><p>ut luctus tortor eu urna posuere accumsan. etiam id feugiat turpis<litcomma> sed elementum neque. integer tristique eros in semper consequat. nunc risus ante<litcomma> rhoncus a nunc non<litcomma> auctor elementum dui. pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. cum sociis natoque penatibus et magnis dis parturient montes<litcomma> nascetur ridiculus mus. duis vulputate id metus vitae blandit.</p><p>etiam congue velit ligula<litcomma> a adipiscing nunc tempor eget. praesent dapibus id erat id mattis. mauris turpis arcu<litcomma> dapibus at lectus non<litcomma> posuere egestas nisi. mauris nulla lacus<litcomma> rutrum vel ornare nec<litcomma> tincidunt id erat. praesent feugiat ut mauris sed malesuada. nulla id massa aliquam<litcomma> placerat tortor aliquam<litcomma> molestie mauris. phasellus vulputate nunc ut lectus vestibulum ultrices. cras gravida<litcomma> lacus at tincidunt egestas<litcomma> nibh est varius tellus<litcomma> vitae gravida nulla massa ac augue. donec eu purus tellus. nulla eget diam malesuada<litcomma> elementum diam pharetra<litcomma> sodales libero.</p>" ) ; todothing todothing1 = new todothing ( ) ; todothing1 . setcreated ( new date ( ) ) ; calendar cal = new gregoriancalendar ( 2014 , 10 , 11 ) ; todothing1 . setdeadline ( cal . gettime ( ) ) ; todothing1 . setname ( "ap: boka m\xf6te" ) ; todothing1 . setprogress ( 30 ) ; textthing . addthing ( todothing1 ) ; filething filething = new filething ( ) ; filething . setname ( "systemkarta as-is norge" ) ; filething . setfiletype ( "pdf" ) ; filething . setfileid ( "test" ) ; filething . setdescription ( "beskriver hur dds ser ut idag med huvudmoduler samt sammankopplade system" ) ; textthing . addthing ( filething ) ; todothing todothing2 = new todothing ( ) ; todothing2 . setcreated ( new date ( ) ) ; calendar cal2 = new gregoriancalendar ( 2014 , 10 , 11 ) ; todothing2 . setdeadline ( cal2 . gettime ( ) ) ; todothing2 . setname ( "skapa en to-be systemkarta" ) ; todothing2 . setprogress ( 100 ) ; todothing2 . setcompleted ( true ) ; textthing . addthing ( todothing2 ) ; activity . addthing ( textthing ) ; } { filething activityfilething1 = new filething ( ) ; activityfilething1 . setname ( "dokumentation om dds" ) ; activityfilething1 . setfiletype ( "pdf" ) ; activity . addthing ( activityfilething1 ) ; } { filething activityfilething2 = new filething ( ) ; activityfilething2 . setname ( "dds k\xe4llkod" ) ; activityfilething2 . setfiletype ( "zip" ) ; activity . addthing ( activityfilething2 ) ; } { todothing todothing = new todothing ( ) ; todothing . setname ( "skapa m\xf6tesantekningar" ) ; calendar cal = new gregoriancalendar ( 2014 , 7 , 21 ) ; todothing . setdeadline ( cal . gettime ( ) ) ; todothing . setprogress ( 25 ) ; todothing . setdescription ( "skriv rent antekningarna och maila ut till alla deltagare" ) ; activity . addthing ( todothing ) ; } { todothing todothing = new todothing ( ) ; todothing . setname ( "skapa m\xf6tesantekningar" ) ; calendar cal = new gregoriancalendar ( 2014 , 7 , 25 ) ; todothing . setdeadline ( cal . gettime ( ) ) ; todothing . setprogress ( 50 ) ; todothing . setdescription ( "skriv rent antekningarna och maila ut till alla deltagare" ) ; activity . addthing ( todothing ) ; } activities . put ( id , activity ) ; return new createdevent < activity > ( activity . getid ( ) , activity ) ; }
te	1	private boolean updatestate ( int i ) { int c = ( char ) i ; switch ( this . state ) { case s_del : this . state = ( '<' == c ) ? parser . states . s_small : ( ( '\\n' == c || ' ' == c ) ? parser . states . s_del : parser . states . s_error ) ; break ; case s_small : this . state = ( '/' == c ) ? parser . states . s_end_tag_slash : ( ( '!' != c ) ? parser . states . s_tag : parser . states . s_doctype ) ; break ; case s_tag : this . state = ( '>' == c ) ? parser . states . s_tag_gt : ( ( ' ' == c ) ? parser . states . s_tag_space : ( ( '/' == c ) ? parser . states . s_tag_slash : parser . states . s_tag ) ) ; break ; case s_tag_gt : this . state = ( '<' == c ) ? parser . states . s_small : ( ( '\\n' == c || ' ' == c ) ? parser . states . s_tag_delim : parser . states . s_text ) ; break ; case s_tag_delim : this . state = ( '\\n' == c || ' ' == c ) ? parser . states . s_tag_delim : ( ( '<' == c ) ? parser . states . s_small : parser . states . s_text ) ; break ; case s_text : this . state = ( '<' == c ) ? parser . states . s_end_tag_sm : parser . states . s_text ; break ; case s_end_tag_sm : this . state = ( '/' == c ) ? parser . states . s_end_tag_slash : parser . states . s_error ; break ; case s_end_tag_slash : this . state = parser . states . s_end_tag ; break ; case s_end_tag : this . state = ( '>' == c ) ? parser . states . s_end_tag_gt : parser . states . s_end_tag ; break ; case s_end_tag_gt : this . state = ( '<' == c ) ? parser . states . s_small : ( ( '\\n' == c || ' ' == c ) ? parser . states . s_del : parser . states . s_error ) ; break ; case s_doctype : this . state = ( '>' == c ) ? parser . states . s_doctype_gt : parser . states . s_doctype ; break ; case s_doctype_gt : this . state = ( '<' == c ) ? parser . states . s_small : ( ( '\\n' == c || ' ' == c ) ? parser . states . s_del : parser . states . s_error ) ; break ; case s_tag_space : this . state = ( ' ' == c ) ? parser . states . s_tag_space : ( ( '/' == c ) ? parser . states . s_tag_slash : parser . states . s_tag_att ) ; break ; case s_tag_att : this . state = ( '/' == c ) ? parser . states . s_tag_slash : ( ( '>' == c ) ? parser . states . s_tag_gt : parser . states . s_tag_att ) ; break ; case s_tag_slash : this . state = ( '>' == c ) ? parser . states . s_tag_no_end_gt : parser . states . s_tag_att ; break ; case s_tag_no_end_gt : this . state = ( '<' == c ) ? parser . states . s_small : ( ( '\\n' == c || ' ' == c ) ? parser . states . s_del : parser . states . s_error ) ; break ; default : system . err . println ( "unknown state" + this . state ) ; return false ; } if ( parser . states . s_error != this . state ) { return true ; } else { return false ; } }
te	9	@ override public boolean oncommand ( commandsender sender , command cmd , string label , string [ ] args ) { if ( cmd . getname ( ) . equalsignorecase ( "rs" ) || cmd . getname ( ) . equalsignorecase ( "realstore" ) ) { if ( ! ( sender instanceof player ) ) { plugin . logmessage ( "realstore interactions may only be used by players!" ) ; return true ; } player player = ( player ) sender ; if ( args . length < 1 ) { plugin . sendplayermessage ( player , chatcolor . dark_red + "error: " + chatcolor . white + "no realstore command found! please use '/rs help' for proper realstore usage. " ) ; return true ; } string rscommand = args [ 0 ] . tolowercase ( ) ; if ( rscommand . equals ( "help" ) ) { plugin . sendhelpinfo ( player , ( args . length < 2 ? null : args [ 1 ] ) ) ; return true ; } if ( rscommand . equals ( "store" ) ) { if ( ! player . haspermission ( "realstore.stores" ) ) { plugin . sendplayermessage ( player , chatcolor . dark_red + "error: " + chatcolor . white + "you do not have permission to do that." ) ; return true ; } if ( args . length < 2 ) { plugin . sendplayermessage ( player , chatcolor . dark_red + "error: " + chatcolor . white + " do you wish to add or remove a store? use '/rs help store' for more information." ) ; return true ; } string storecommand = args [ 1 ] . tolowercase ( ) ; if ( storecommand . equals ( "add" ) ) { if ( ! plugin . hascoffer ( player ) ) { plugin . sendplayermessage ( player , chatcolor . dark_red + "error: " + chatcolor . white + " you have no coffers! use '/rs help coffer' for more information." ) ; return true ; } plugin . sendplayermessage ( player , "click on a chest to create a store." ) ; plugin . getserver ( ) . getpluginmanager ( ) . registerevents ( new storemanagementlistener ( plugin , player ) , plugin ) ; return true ; } if ( storecommand . equals ( "remove" ) ) { plugin . getserver ( ) . getpluginmanager ( ) . registerevents ( new storemanagementlistener ( plugin , player , true ) , plugin ) ; plugin . sendplayermessage ( player , "click on the chest store to remove the store." ) ; return true ; } plugin . sendplayermessage ( player , chatcolor . dark_red + "error: " + chatcolor . white + " unknown store command! use '/rs help store' for more information." ) ; return true ; } if ( rscommand . equals ( "trade" ) ) { if ( ! player . haspermission ( "realstore.trade" ) ) { plugin . sendplayermessage ( player , chatcolor . dark_red + "error: " + chatcolor . white + "you do not have permission to set up trade goods." ) ; return true ; } plugin . sendplayermessage ( player , "open a store<litcomma> and click on an item for sale with the item and amount you wish to trade for." ) ; plugin . getserver ( ) . getpluginmanager ( ) . registerevents ( new tradesetlistener ( plugin , player ) , plugin ) ; return true ; } if ( rscommand . equals ( "price" ) ) { if ( ! player . haspermission ( "realstore.stores" ) ) { plugin . sendplayermessage ( player , chatcolor . dark_red + "error: " + chatcolor . white + "you do not have permission to do that." ) ; return true ; } if ( args . length < 2 ) { plugin . sendplayermessage ( player , chatcolor . dark_red + "error: " + chatcolor . white + " no price found. use '/rs help price' for proper realstore price setting usage." ) ; return true ; } if ( ! plugin . hascoffer ( player ) ) { plugin . sendplayermessage ( player , chatcolor . dark_red + "error: " + chatcolor . white + " you do not have any coffers. create a coffer first. use '/rs help coffer' for more." ) ; return true ; } if ( ! plugin . hasstore ( player ) ) { plugin . sendplayermessage ( player , chatcolor . dark_red + "error: " + chatcolor . white + " you do not have any stores on which to set prices. create a store first. use '/rs help store' for more." ) ; return true ; } try { integer price = integer . parseint ( args [ 1 ] ) ; if ( price <= 0 ) { plugin . sendplayermessage ( player , chatcolor . dark_red + "error: " + chatcolor . white + " the price must be greater than zero!" ) ; return true ; } if ( args . length > 2 ) { string type = args [ 2 ] ; try { byte data = args . length > 3 ? ( byte ) integer . parseint ( args [ 3 ] ) : ( byte ) 0 ; if ( material . matchmaterial ( type ) == null ) { if ( type . equalsignorecase ( "default" ) ) { plugin . sendplayermessage ( player , "click on the chest store to set the default price to " + price + " gold nuggets" ) ; plugin . getserver ( ) . getpluginmanager ( ) . registerevents ( new pricesetlistener ( plugin , player , price , true ) , plugin ) ; return true ; } plugin . sendplayermessage ( player , chatcolor . dark_red + "error: " + chatcolor . white + " unknown material used to set the price. use '/rs help material' to list material names." ) ; return true ; } materialdata material = new materialdata ( material . matchmaterial ( type ) , data ) ; plugin . sendplayermessage ( player , "click on the chest store to set the price of " + material . tostring ( ) + " to a price of " + price + " gold nuggets" ) ; plugin . getserver ( ) . getpluginmanager ( ) . registerevents ( new pricesetlistener ( plugin , player , price , material ) , plugin ) ; return true ; } catch ( numberformatexception e ) { plugin . sendplayermessage ( player , chatcolor . dark_red + "error: " + chatcolor . white + " invalid material data. use '/rs help material' to list material names and data values." ) ; return true ; } } plugin . getserver ( ) . getpluginmanager ( ) . registerevents ( new pricesetlistener ( plugin , player , price ) , plugin ) ; plugin . sendplayermessage ( player , "click on the chest store with an item to set the price of that item to " + price + " gold nuggets." ) ; return true ; } catch ( numberformatexception e ) { if ( args [ 1 ] . equalsignorecase ( "check" ) ) { if ( ! plugin . hasstore ( player ) ) { plugin . sendplayermessage ( player , chatcolor . dark_red + "error: " + chatcolor . white + "you must first have a store before you can check the prices of items in it." ) ; return true ; } plugin . getserver ( ) . getpluginmanager ( ) . registerevents ( new pricechecklistener ( plugin , player ) , plugin ) ; plugin . sendplayermessage ( player , "open one of your stores to check the prices of items" ) ; return true ; } plugin . sendplayermessage ( player , chatcolor . dark_red + "error: " + chatcolor . white + " improper price. use '/rs help price' for proper realstore price setting usage." ) ; return true ; } } if ( rscommand . equals ( "admin" ) ) { if ( ! player . haspermission ( "realstore.admin" ) ) { plugin . sendplayermessage ( player , chatcolor . dark_red + "error: " + chatcolor . white + "you do not have permission to set admin stores." ) ; return true ; } if ( args . length < 2 ) { plugin . sendplayermessage ( player , chatcolor . dark_red + "error: " + chatcolor . white + " are you creating or removing an admin store?" ) ; return true ; } if ( ! plugin . hasstore ( player ) ) { plugin . sendplayermessage ( player , chatcolor . dark_red + "error: " + chatcolor . white + " you do not have any stores to make admin stores." ) ; return true ; } string admincommand = args [ 1 ] . tolowercase ( ) ; if ( admincommand . equals ( "add" ) ) { plugin . getserver ( ) . getpluginmanager ( ) . registerevents ( new storemanagementlistener ( plugin , player , false , true ) , plugin ) ; plugin . sendplayermessage ( player , "click on a store to add it as an admin store." ) ; return true ; } if ( admincommand . equals ( "remove" ) ) { plugin . getserver ( ) . getpluginmanager ( ) . registerevents ( new storemanagementlistener ( plugin , player , true , true ) , plugin ) ; plugin . sendplayermessage ( player , "click on a store to remove it as an admin store." ) ; return true ; } } if ( rscommand . equals ( "coffer" ) ) { if ( ! player . haspermission ( "realstore.stores" ) ) { plugin . sendplayermessage ( player , chatcolor . dark_red + "error: " + chatcolor . white + "you do not have permission to do that." ) ; return true ; } if ( args . length < 2 ) { plugin . sendplayermessage ( player , chatcolor . dark_red + "error: " + chatcolor . white + " do you wish to add or remove a coffer? use '/rs help coffer' for more information." ) ; return true ; } string coffercommand = args [ 1 ] . tolowercase ( ) ; if ( coffercommand . equals ( "add" ) ) { plugin . getserver ( ) . getpluginmanager ( ) . registerevents ( new coffermanagementlistener ( plugin , player , false ) , plugin ) ; plugin . sendplayermessage ( player , "click on a chest to add it to your coffers." ) ; return true ; } if ( coffercommand . equals ( "remove" ) ) { plugin . getserver ( ) . getpluginmanager ( ) . registerevents ( new coffermanagementlistener ( plugin , player , true ) , plugin ) ; plugin . sendplayermessage ( player , "click on a chest to remove it from your coffers." ) ; return true ; } plugin . sendplayermessage ( player , chatcolor . dark_red + "error: " + chatcolor . white + " unknown coffer command! use '/rs help coffer' for more information." ) ; return true ; } plugin . sendplayermessage ( player , chatcolor . dark_red + "error: " + chatcolor . white + " unknown realstore command! use '/rs help' for more information." ) ; return true ; } return false ; }
te	4	public int trap ( int [ ] a ) { if ( a . length < 3 ) return 0 ; int water = 0 ; int maxleft [ ] = new int [ a . length ] ; maxleft [ 0 ] = 0 ; int maxright [ ] = new int [ a . length ] ; maxright [ a . length - 1 ] = 0 ; for ( int i = 1 ; i < a . length ; i ++ ) { if ( maxleft [ i - 1 ] < a [ i - 1 ] ) { maxleft [ i ] = a [ i - 1 ] ; } else { maxleft [ i ] = maxleft [ i - 1 ] ; } } for ( int i = a . length - 2 ; i >= 0 ; i -- ) { if ( maxright [ i + 1 ] < a [ i + 1 ] ) { maxright [ i ] = a [ i + 1 ] ; } else { maxright [ i ] = maxright [ i + 1 ] ; } } for ( int i = 1 ; i < a . length ; i ++ ) { if ( math . min ( maxleft [ i ] , maxright [ i ] ) > a [ i ] ) water += math . min ( maxleft [ i ] , maxright [ i ] ) - a [ i ] ; } return water ; }
te	5	private void zmienstatuspasa ( int passtartowyhandle , int samolot ) throws rtiexception { suppliedattributes attributes = rtifactoryfactory . getrtifactory ( ) . createsuppliedattributes ( ) ; byte [ ] samolotvalue = encodinghelpers . encodestring ( "samolot:" + samolot ) ; int classhandle = rti . getobjectclass ( passtartowyhandle ) ; int samolothandle = rti . getattributehandle ( "samolot" , classhandle ) ; attributes . add ( samolothandle , samolotvalue ) ; logicaltime time = converttime ( ambasador . federatetime + ambasador . federatelookahead ) ; rti . updateattributevalues ( passtartowyhandle , attributes , generatetag ( ) , time ) ; }
te	7	public void changehand ( string msg ) { string localstr = server . gethandofid ( id ) ; if ( ! msg . startswith ( localstr ) ) { msgr . broadcast ( "error|cheat" ) ; system . out . println ( "cheater (player #" + id + ") kicked." ) ; finalize ( ) ; } string arr [ ] = msg . split ( "\\\\|" ) ; if ( arr . length <= 5 ) { system . out . println ( "player #" + id + " don't want to change hand." ) ; system . err . println ( "dbg: " + msg ) ; } else { int changes = 0 ; for ( int i = 0 ; i < 5 ; i ++ ) { for ( int j = 5 ; j < arr . length ; j ++ ) { if ( arr [ i ] . equals ( arr [ j ] ) ) { changes ++ ; try { deck . pushcard ( arr [ i ] ) ; } catch ( exception e1 ) { e1 . printstacktrace ( ) ; } arr [ i ] = deck . pullcardtostring ( ) ; } } } if ( changes < ( arr . length - 5 ) ) { string cmd = new string ( "error|there was a number of incorrect cards to be changed." ) ; msgr . broadcast ( cmd ) ; } system . out . println ( "player #" + id + " decided to change " + ( arr . length - 5 ) + " cards." ) ; string newhand = "sethand" ; for ( int i = 0 ; i < 5 ; i ++ ) newhand += "|" + arr [ i ] ; msgr . broadcast ( newhand ) ; } movelocktonextplayer ( ) ; server . changedhands ++ ; }
te	2	private void loop ( int [ ] [ ] res , int startpos , int size , int startnumber ) { if ( size == 1 ) { res [ startpos ] [ startpos ] = startnumber ; return ; } for ( int j = startpos ; j < startpos + size - 1 ; j ++ , startnumber ++ ) res [ startpos ] [ j ] = startnumber ; for ( int i = startpos ; i < startpos + size - 1 ; i ++ , startnumber ++ ) res [ i ] [ startpos + size - 1 ] = startnumber ; for ( int j = startpos + size - 1 ; j > startpos ; j -- , startnumber ++ ) res [ startpos + size - 1 ] [ j ] = startnumber ; for ( int i = startpos + size - 1 ; i > startpos ; i -- , startnumber ++ ) res [ i ] [ startpos ] = startnumber ; }
te	5	public static void main ( string [ ] args ) throws unknownhostexception { final string screenname = args . length > 0 ? args [ 0 ] : "clairtonluz" ; list < dbobject > tweets = getlatesttweets ( screenname ) ; mongoclient client = new mongoclient ( ) ; dbcollection tweetscollection = client . getdb ( "course" ) . getcollection ( "tweeter" ) ; for ( dbobject cur : tweets ) { cur . put ( "screen_name" , screenname ) ; massagetweetid ( cur ) ; tweetscollection . update ( new basicdbobject ( "_id" , cur . get ( "_id" ) ) , cur , true , false ) ; } system . out . println ( "tweet count: " + tweetscollection . count ( ) ) ; client . close ( ) ; }
te	7	private string top ( int top ) { string message = "" ; pooledconnection connection = plugin . getmydatabase ( ) . getconnection ( ) ; string query = "select * from player order by karma desc" ; try { resultset result = connection . query ( query ) ; int counter = 1 ; while ( result . next ( ) && counter <= plugin . gettop ( ) ) { string name = result . getstring ( "name" ) ; int karma = result . getint ( "karma" ) ; if ( message != "" ) { message += "\\n" ; } message += counter + ". " + name + " " + karma ; counter ++ ; } } catch ( exception e ) { message = null ; e . printstacktrace ( ) ; } finally { connection . close ( ) ; } return message ; }
te	9	private void process ( httpservletrequest request , httpservletresponse response ) throws servletexception , ioexception { httpsession session = request . getsession ( ) ; myhealth healthup = new myhealth ( ) ; int recordid = integer . parseint ( request . getparameter ( "healthrecodecomfid" ) ) ; string recordheight = request . getparameter ( "healthrecodecomfheight" ) ; string recordweight = request . getparameter ( "healthrecodecomfweight" ) ; string sleeptime = request . getparameter ( "healthrecodecomfsleeptime" ) ; string updatejump = request . getparameter ( "updatejump" ) ; string forward = "/web-inf/jsp/healthupdate/healthupdateconfirm.jsp" ; healthup . setid ( recordid ) ; healthup . setheight ( double . parsedouble ( recordheight ) ) ; healthup . setweight ( double . parsedouble ( recordweight ) ) ; healthup . setsleeptime ( double . parsedouble ( sleeptime ) ) ; session . setattribute ( "healthup" , healthup ) ; if ( updatejump . equals ( "\u4e00\u89a7\u3078\u623b\u308b" ) ) { forward = "/web-inf/jsp/healthlist/healthlist.jsp" ; } requestdispatcher dispatcher = request . getrequestdispatcher ( forward ) ; dispatcher . forward ( request , response ) ; }
te	9	public string [ ] obterlinha ( ) { string pg = string . valueof ( this . pg ) ; string j = string . valueof ( this . j ) ; string v = string . valueof ( this . v ) ; string e = string . valueof ( this . e ) ; string d = string . valueof ( this . d ) ; string gp = string . valueof ( this . gp ) ; string gc = string . valueof ( this . gc ) ; string sg = string . valueof ( this . sg ) ; string [ ] resultado = { posicao , indicador , nomeequipe , pg , j , v , e , d , gp , gc , sg , aproveitamento } ; return resultado ; }
te	5	protected void recfillingdb ( string curuid , string parentuid , int lvl ) { if ( lvl == max_level ) { return ; } downloader person = new downloader ( curuid ) ; system . out . println ( "parsing uid = " + curuid + " parentuid = " + parentuid ) ; string [ ] friendsuids = person . getpersonfriends ( ) ; node existingnode = nodeindex . get ( "uid" , curuid ) . getsingle ( ) ; if ( existingnode == null ) { hashmap < string , object > persondata = parsepersonxml ( person . getpersonxmldata ( ) ) ; system . out . println ( " first_name = " + persondata . get ( "first_name" ) + " last_name = " + persondata . get ( "last_name" ) + " lvl = " + lvl ) ; persondata . put ( friend_list_key , friendsuids ) ; existingnode = addpersontodb ( persondata , parentuid ) ; } else { setrelationship ( existingnode , nodeindex . get ( "uid" , parentuid ) . getsingle ( ) ) ; } for ( string tempfriend : friendsuids ) { recfillingdb ( tempfriend , curuid , lvl + 1 ) ; } }
te	10	private void parseblockidlist ( string var1 ) { this . leafclasses = new hashmap ( ) ; fmllog . log ( level . info , "parsing log id list: %s" , new object [ ] { var1 } ) ; if ( var1 . trim ( ) . length ( ) > 0 ) { string [ ] var2 = var1 . trim ( ) . split ( ";" ) ; string [ ] var3 = var2 ; int var4 = var2 . length ; for ( int var5 = 0 ; var5 < var4 ; ++ var5 ) { string var6 = var3 [ var5 ] ; if ( var6 . trim ( ) . length ( ) > 0 ) { string [ ] var7 = var6 . trim ( ) . split ( "\\\\|" ) ; fmllog . log ( level . info , "found log block id: %s" , new object [ ] { var7 [ 0 ] . trim ( ) } ) ; int var8 = commonutils . parseint ( var7 [ 0 ] . trim ( ) ) ; fmllog . log ( level . info , "interpretted: %s" , new object [ ] { integer . valueof ( var8 ) } ) ; int var9 = 18 ; if ( var7 . length > 1 ) { fmllog . log ( level . info , "found leaf block id: %s" , new object [ ] { var1 } ) ; var9 = commonutils . parseint ( var7 [ 1 ] . trim ( ) ) ; fmllog . log ( level . info , "interpretted: %s" , new object [ ] { integer . valueof ( var9 ) } ) ; } else { fmllog . log ( level . info , "leaf block id not provided; using %s" , new object [ ] { integer . valueof ( var9 ) } ) ; } if ( var8 > 0 ) { block var10 = block . byid [ var8 ] ; if ( var10 != null ) { if ( ! treecapitator . logclasses . contains ( var10 . getclass ( ) ) ) { treecapitator . logclasses . add ( var10 . getclass ( ) ) ; fmllog . log ( level . info , "configured log block class: %s" , new object [ ] { var10 . getclass ( ) . getname ( ) } ) ; block var11 = block . byid [ var9 ] ; if ( var11 != null ) { if ( var11 instanceof blocktransparant ) { this . leafclasses . put ( var10 . getclass ( ) , blocktransparant . class ) ; } else { this . leafclasses . put ( var10 . getclass ( ) , var11 . getclass ( ) ) ; } } else { this . leafclasses . put ( var10 . getclass ( ) , blocktransparant . class ) ; } fmllog . log ( level . info , "pairing leaf block class: %s" , new object [ ] { this . leafclasses . get ( var10 . getclass ( ) ) } ) ; } else { fmllog . log ( level . info , "block for id %s is already configured" , new object [ ] { integer . valueof ( var8 ) } ) ; } } else { fmllog . log ( level . warning , "block id %s not found" , new object [ ] { integer . valueof ( var8 ) } ) ; } } } } } }
te	6	public static string handler ( string message ) { string result = "" ; string category ; string param ; string command ; int code ; string msg = message . trim ( ) ; if ( stringutils . isempty ( msg ) ) { return result ; } else { loggerutil . logmsg ( " message: " + message ) ; } category = msg . substring ( 0 , 1 ) . tolowercase ( ) ; command = msg . substring ( 0 , 3 ) ; code = integer . valueof ( msg . substring ( 1 , 3 ) ) ; param = msg . substring ( 3 ) ; switch ( category ) { case auth : result = authtask . execute ( code , param ) ; break ; default : break ; } return command + result ; }
te	1	public void testmultiplesearch ( ) { trie t = new trie ( ) ; assertequals ( true , t . addword ( "georgel" ) ) ; assertequals ( true , t . searchword ( "georgel" ) ) ; assertequals ( true , t . searchword ( "georgel" ) ) ; assertequals ( true , t . searchword ( "georgel" ) ) ; assertequals ( true , t . searchword ( "georgel" ) ) ; assertequals ( false , t . searchword ( "george" ) ) ; assertequals ( false , t . searchword ( "eorgel" ) ) ; assertequals ( true , t . addword ( "georgel" ) ) ; assertequals ( true , t . addword ( "george" ) ) ; assertequals ( true , t . searchword ( "george" ) ) ; assertequals ( false , t . searchword ( "georg" ) ) ; assertequals ( false , t . searchword ( "eorge" ) ) ; }
te	6	private static apiresponse recognize ( image image , url url , string recognizemode ) throws ioexception , jsonexception { apiresponse response = new apiresponse ( - 1 ) ; if ( ! checkimagelimits ( image , recognizemode ) ) { system . err . println ( "image does not fulfill the requirements<litcomma> terminating." ) ; response . setmessage ( "image does not fulfill the requirements<litcomma> terminating." ) ; return response ; } string md5hash = getmd5fromkeyandimage ( apikey , image . getdata ( ) ) ; if ( md5hash == null ) { response . setmessage ( "empty hash" ) ; return response ; } httpurlconnection conn = ( httpurlconnection ) url . openconnection ( ) ; conn . setdooutput ( true ) ; conn . setrequestmethod ( "post" ) ; conn . setrequestproperty ( "content-type" , "image/jpeg" ) ; conn . addrequestproperty ( "x-itraff-hash" , md5hash ) ; outputstream os = conn . getoutputstream ( ) ; os . write ( image . getdata ( ) ) ; os . flush ( ) ; bufferedreader br = new bufferedreader ( new inputstreamreader ( ( conn . getinputstream ( ) ) ) ) ; string output ; output = getresponsejson ( br ) ; response = new apiresponse ( output ) ; conn . disconnect ( ) ; return response ; }
te	1	public static void main ( string [ ] args ) { processor p = null ; if ( 0 == args [ 0 ] . compareto ( "--help" ) ) { system . out . println ( "extracts the pages from a wikipedia dump xml that contains a specific word in title.\\n" + "this is a tool intended to be used for natural language processing and a helper for wikipediaesa tool.\\n" ) ; system . out . println ( "wikiparser input_xml words_file output_xml\\n" ) ; system . out . println ( "input_xml        path to the wikipedia dump xml or another xml that has the same structure\\n" + "                 from which the pages will be extracted" ) ; system . out . println ( "words_file       path to a file that contains the terms separated on each line used for\\n" + "                 selecting the pages. the words must contain only english letters." ) ; system . out . println ( "output_xml       path to a file that will be created and will contain the extracted pages\\n" + "                 in a structure similar to the wikipedia dump xml for training wikipediaesa" ) ; system . out . println ( "output_txt       path to a file that will be created and will contain the extracted pages\\n" + "                 oen on each row for lsa training from 'airhead-research'" ) ; system . exit ( 0 ) ; } if ( 4 > args . length ) { system . err . println ( "too few arguments. check '--help' command for more information." ) ; system . exit ( 1 ) ; } if ( false == checkfile ( args [ 0 ] ) || false == checkfile ( args [ 1 ] ) ) { system . err . println ( "command line check failed. check '--help' command for more information." ) ; system . exit ( 1 ) ; } try { p = new processor ( args [ 0 ] , args [ 1 ] , args [ 2 ] , args [ 3 ] ) ; p . process ( ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } }
te	3	private void initializeaccountsessionfacadeejbremote ( ) throws runtimeexception { if ( usersessionfacadeejbhome == null ) { string facade_name = "usersessionfacadeejb" ; class facade_class = usersessionfacadeejb . class ; try { servicelocator locator = servicelocator . getinstance ( ) ; usersessionfacadeejbhome = ( usersessionfacadeejbhome ) locator . getejbhome ( facade_name , facade_class ) ; if ( usersessionfacadeejbhome == null ) { system . out . println ( "usersessionfacadeejbhome is null" ) ; throw new runtimeexception ( "did not get home for " + facade_name ) ; } else { system . out . println ( "usersessionfacadeejbhome is not null" ) ; } usersessionfacadeejbremote = usersessionfacadeejbhome . create ( ) ; } catch ( createexception e ) { throw new runtimeexception ( e . getmessage ( ) ) ; } catch ( remoteexception e ) { throw new runtimeexception ( e . getmessage ( ) ) ; } catch ( exception e ) { throw new runtimeexception ( e . getmessage ( ) ) ; } } }
te	8	@ override public linkedlist < tuple < sentence_tree , tuple < string , string > > > interesting_subtree ( hashtable < string , boolean > voc , hashtable < string , boolean > subvoc ) { linkedlist < sentence_tree > keyword_list = bfs_name ( voc ) ; linkedlist < tuple < sentence_tree , tuple < string , string > > > interest = new linkedlist < tuple < sentence_tree , tuple < string , string > > > ( ) ; hashtable < string , boolean > already_done = new hashtable < string , boolean > ( ) ; if ( ! keyword_list . isempty ( ) ) { for ( int i = 0 ; i < keyword_list . size ( ) ; i ++ ) { for ( int j = 0 ; j < keyword_list . size ( ) ; j ++ ) { if ( i != j && ! already_done . containskey ( keyword_list . get ( i ) . get_root ( ) + " " + keyword_list . get ( j ) . get_root ( ) ) ) { already_done . put ( keyword_list . get ( i ) . get_root ( ) + " " + keyword_list . get ( j ) . get_root ( ) , true ) ; sentence_tree interesting_tree1 = keyword_list . get ( i ) ; sentence_tree interesting_tree2 = keyword_list . get ( j ) ; if ( subvoc . containskey ( interesting_tree1 . get_root ( ) ) || subvoc . containskey ( interesting_tree2 . get_root ( ) ) ) { sentence_tree sub_tree = interesting_tree1 . find_common_node ( interesting_tree2 ) . copy ( ) ; interest . add ( new tuple < sentence_tree , tuple < string , string > > ( sub_tree , new tuple < string , string > ( interesting_tree1 . root . name , interesting_tree2 . root . name ) ) ) ; } } } } } return interest ; }
te	3	private void parseargs ( string [ ] args ) { scanner sc = new scanner ( system . in ) ; if ( args . length < 4 ) { system . out . print ( "path to file: " ) ; file = sc . nextline ( ) ; system . out . print ( "percentiles: " ) ; int d1 = sc . nextint ( ) ; int d2 = sc . nextint ( ) ; if ( d1 > d2 ) { hpercentile = d1 ; lpercentile = d2 ; } else { hpercentile = d2 ; lpercentile = d1 ; } system . out . print ( "number of items of interest: " ) ; ioi = sc . nextint ( ) ; } else { file = args [ 0 ] ; if ( integer . valueof ( args [ 1 ] ) > integer . valueof ( args [ 2 ] ) ) { hpercentile = integer . valueof ( args [ 1 ] ) ; lpercentile = integer . valueof ( args [ 2 ] ) ; } else { hpercentile = integer . valueof ( args [ 2 ] ) ; lpercentile = integer . valueof ( args [ 1 ] ) ; } ioi = integer . valueof ( args [ 3 ] ) ; } }
te	6	@ test public void loadtest ( ) throws exception { int sessionsbefore = server . getsessionscount ( ) ; arraylist < thread > threadlist = new arraylist < > ( ) ; for ( int i = 0 ; i < 10 ; i ++ ) { thread t = new thread ( new runnable ( ) { @ override public void run ( ) { try { for ( int z = 0 ; z < 30 ; z ++ ) { testgreenpath ( ) ; } } catch ( exception e ) { errorhappened = true ; } } } ) ; t . start ( ) ; threadlist . add ( t ) ; } for ( thread t : threadlist ) { t . join ( ) ; } assertfalse ( errorhappened ) ; int sessionsafter = server . getsessionscount ( ) ; asserttrue ( sessionsafter - sessionsbefore == 300 ) ; }
te	2	public static color [ ] getcolors ( ) { try { color [ ] colors = new color [ 5 ] ; robot robot = new robot ( ) ; colors [ 0 ] = robot . getpixelcolor ( firstpixel [ 0 ] , firstpixel [ 1 ] ) ; colors [ 1 ] = robot . getpixelcolor ( secondpixel [ 0 ] , secondpixel [ 1 ] ) ; colors [ 2 ] = robot . getpixelcolor ( thirdpixel [ 0 ] , thirdpixel [ 1 ] ) ; colors [ 3 ] = robot . getpixelcolor ( fourthpixel [ 0 ] , fourthpixel [ 1 ] ) ; return colors ; } catch ( awtexception e ) { e . printstacktrace ( ) ; } return null ; }
te	5	public boolean terminaltest ( state state ) { int playedfields = 0 ; for ( int i = 0 ; i < boardsize ; i ++ ) { int totalrow = 0 ; for ( int j = 0 ; j < boardsize ; j ++ ) { if ( state . field [ i ] [ j ] != 0 ) playedfields ++ ; totalrow += state . field [ i ] [ j ] ; } if ( math . abs ( totalrow ) == boardsize ) return true ; } if ( playedfields == boardsize * boardsize ) return true ; for ( int j = 0 ; j < boardsize ; j ++ ) { int total = 0 ; for ( int i = 0 ; i < boardsize ; i ++ ) total += state . field [ i ] [ j ] ; if ( math . abs ( total ) == boardsize ) return true ; } int total = 0 ; for ( int i = 0 ; i < boardsize ; i ++ ) total += state . field [ i ] [ i ] ; if ( math . abs ( total ) == boardsize ) return true ; total = 0 ; for ( int i = 0 ; i < boardsize ; i ++ ) total += state . field [ i ] [ boardsize - i - 1 ] ; if ( math . abs ( total ) == boardsize ) return true ; return false ; }
te	10	private float prim ( arraylist < integer > notvisited , int size ) { if ( notvisited . size ( ) <= 2 ) { if ( notvisited . size ( ) == 1 ) { return 0 ; } else { return dist [ notvisited . get ( 0 ) ] [ notvisited . get ( 1 ) ] ; } } float cost = 0 ; boolean [ ] visited = new boolean [ size ] ; float [ ] dists = new float [ size ] ; boolean [ ] used = new boolean [ size ] ; for ( int i = 0 ; i < size ; i ++ ) { dists [ i ] = integer . max_value ; } dists [ 0 ] = 0 ; visited [ 0 ] = true ; int i = 0 ; boolean run = true ; while ( run ) { if ( used [ i ] == false ) { used [ i ] = true ; float x = float . max_value ; int y = - 1 ; for ( int j = 0 ; j < size ; j ++ ) { if ( ( ! visited [ j ] ) && ( dists [ j ] > dist [ notvisited . get ( i ) ] [ notvisited . get ( j ) ] ) ) { dists [ j ] = dist [ notvisited . get ( i ) ] [ notvisited . get ( j ) ] ; } if ( dists [ j ] < x && ! visited [ j ] ) { x = dists [ j ] ; y = j ; } } if ( y > 0 ) { visited [ y ] = true ; i = y ; } else { run = false ; } } } for ( float l : dists ) { cost += l ; } return cost ; }
te	2	private void infixtopostfix ( ) { stack < string > opstack = new stack < string > ( ) ; for ( int i = 0 ; i < token . size ( ) ; i ++ ) { if ( isnumeric ( token . get ( i ) ) || token . get ( i ) . equals ( "x" ) ) postfixtokens . add ( token . get ( i ) ) ; else if ( token . get ( i ) . equals ( "(" ) ) opstack . push ( token . get ( i ) ) ; else if ( token . get ( i ) . equals ( ")" ) ) { while ( ! opstack . peek ( ) . equals ( "(" ) ) postfixtokens . add ( opstack . pop ( ) ) ; opstack . pop ( ) ; if ( ! opstack . isempty ( ) && isspecialops ( opstack . peek ( ) ) ) postfixtokens . add ( opstack . pop ( ) ) ; } else if ( opstack . isempty ( ) || opstack . peek ( ) . equals ( "(" ) || compareops ( opstack . peek ( ) , token . get ( i ) ) <= 0 ) opstack . push ( token . get ( i ) ) ; else { while ( ! opstack . isempty ( ) && ! opstack . peek ( ) . equals ( "(" ) && compareops ( opstack . peek ( ) , token . get ( i ) ) >= 0 ) postfixtokens . add ( opstack . pop ( ) ) ; opstack . push ( token . get ( i ) ) ; } } while ( ! opstack . isempty ( ) ) postfixtokens . add ( opstack . pop ( ) ) ; }
te	4	public static void main ( string [ ] args ) throws interruptedexception { getpi getpi = new getpi ( ) ; thread [ ] threads = new thread [ total_thread ] ; system . out . println ( "number of spots  : " + total_spot ) ; system . out . println ( "number of threads: " + total_thread ) ; for ( int idx = 0 ; idx < total_thread ; idx ++ ) { threads [ idx ] = new thread ( getpi ) ; threads [ idx ] . start ( ) ; } for ( thread thread : threads ) { thread . join ( ) ; } system . out . println ( pi ( ) ) ; }
te	10	public static void unzip ( string sfile , string targetdir ) throws ioexception { try ( zipfile zipfile = new zipfile ( sfile ) ) { enumeration < ? > enu = zipfile . entries ( ) ; while ( enu . hasmoreelements ( ) ) { zipentry zipentry = ( zipentry ) enu . nextelement ( ) ; string name = targetdir + "\\\\" + zipentry . getname ( ) ; long size = zipentry . getsize ( ) ; long compressedsize = zipentry . getcompressedsize ( ) ; system . out . printf ( "name: %-20s | size: %6d | compressed size: %6d\\n" , name , size , compressedsize ) ; file file = new file ( name ) ; if ( name . endswith ( "/" ) ) { file . mkdirs ( ) ; continue ; } file parent = file . getparentfile ( ) ; if ( parent != null ) { parent . mkdirs ( ) ; } fileoutputstream fos ; try ( inputstream is = zipfile . getinputstream ( zipentry ) ) { fos = new fileoutputstream ( file ) ; byte [ ] bytes = new byte [ 1024 ] ; int length ; while ( ( length = is . read ( bytes ) ) >= 0 ) { fos . write ( bytes , 0 , length ) ; } } fos . close ( ) ; } } }
te	1	public void onplayclicked ( actionevent e ) { if ( application . player . isplaying ( ) ) { btnplay . settext ( "play" ) ; stoptimer ( ) ; lastposition = application . player . gettickposition ( ) ; application . player . stop ( ) ; } else { btnplay . settext ( "pause" ) ; application . player . stop ( ) ; application . player . load ( tabs . getscore ( ) . getsequence ( ) ) ; application . player . seek ( lastposition ) ; application . player . play ( ) ; final long offseterror = 0 ; scrolltimer = new timer ( ) ; scrolltimer . scheduleatfixedrate ( new timertask ( ) { @ override public void run ( ) { lnmarker . settranslatex ( xoffset ( application . player . gettickposition ( ) - offseterror ) ) ; } } , 10 , 10 ) ; } }
te	8	public static void main ( string [ ] args ) { logicgame game = new logicgame ( ) ; while ( true ) { game . print ( ) ; system . out . print ( "enter coordinates separated by commas: " ) ; scanner in = new scanner ( system . in ) ; string input = in . nextline ( ) ; string [ ] ints = input . split ( "<litcomma>" ) ; int [ ] coords = new int [ 4 ] ; for ( int i = 0 ; i < 4 ; i ++ ) { coords [ i ] = integer . parseint ( ints [ i ] ) ; } sortcoord ( coords ) ; int [ ] playerhod = { coords [ 0 ] - 1 , coords [ 1 ] - 1 , coords [ 2 ] - 1 , coords [ 3 ] - 1 } ; if ( game . is_allowedhod ( playerhod ) ) { if ( game . makehod ( playerhod ) ) { if ( game . is_last ( ) ) { game . print ( ) ; system . out . println ( "congratulations!" ) ; break ; } int [ ] tmp = null ; game . ai ( tmp , true , 5 ) ; game . set_flag ( ) ; game . print ( ) ; if ( game . is_last ( ) ) { system . out . println ( "game over!" ) ; break ; } } else system . out . println ( "turn is not allowed!" ) ; } else system . out . println ( "turn is not allowed!" ) ; } }
te	2	@ override public void focuslost ( final focusevent e ) { object source = e . getsource ( ) ; if ( source == getmoneyfield ( ) ) { money m = money . parsemoney ( getmoneyfield ( ) . gettext ( ) ) ; getmoneyfield ( ) . settext ( m . tostring ( ) ) ; gettransaction ( ) . setmoney ( m ) ; getmainframe ( ) . updatebalance ( ) ; } else if ( source == getmemofield ( ) ) { gettransaction ( ) . setmemo ( getmemofield ( ) . gettext ( ) ) ; } serializer . savestate ( ) ; }
te	7	private list < string > parse ( string expression ) { list < string > result = new arraylist < string > ( ) ; stack < string > stack = new stack < string > ( ) ; interpreterlanguagelexing tokenizer = new interpreterlanguagelexing ( expression , operators ) ; while ( tokenizer . hasnext ( ) ) { string token = tokenizer . next ( ) ; if ( isnumber ( token ) ) { result . add ( token ) ; } else if ( variables . containskey ( token ) ) { result . add ( variables . get ( token ) ) ; } else if ( character . isletter ( token . charat ( 0 ) ) ) { stack . push ( token ) ; } else if ( "<litcomma>" . equals ( token ) ) { while ( ! stack . isempty ( ) && ! "(" . equals ( stack . peek ( ) ) ) { result . add ( stack . pop ( ) ) ; } if ( stack . isempty ( ) ) { throw new custominterpreterexception ( "invalid code input error !" ) ; } } else if ( operators . containskey ( token ) ) { final operator firstoperator = operators . get ( token ) ; string secondtoken = stack . isempty ( ) ? null : stack . peek ( ) ; while ( operators . containskey ( secondtoken ) && ( ( firstoperator . isleftbinded ( ) && firstoperator . getprecedence ( ) <= operators . get ( secondtoken ) . getprecedence ( ) ) || ( firstoperator . getprecedence ( ) < operators . get ( secondtoken ) . getprecedence ( ) ) ) ) { result . add ( stack . pop ( ) ) ; secondtoken = stack . isempty ( ) ? null : stack . peek ( ) ; } stack . push ( token ) ; } else if ( "(" . equals ( token ) ) { stack . push ( token ) ; } else if ( ")" . equals ( token ) ) { while ( ! stack . isempty ( ) && ! "(" . equals ( stack . peek ( ) ) ) { result . add ( stack . pop ( ) ) ; } if ( stack . isempty ( ) ) { throw new runtimeexception ( "expected closing parenthesis" ) ; } stack . pop ( ) ; } } while ( ! stack . isempty ( ) ) { string element = stack . pop ( ) ; if ( "(" . equals ( element ) || ")" . equals ( element ) ) { throw new runtimeexception ( "expected closing parenthesis" ) ; } if ( ! operators . containskey ( element ) ) { throw new runtimeexception ( "unknown operator or function: " + element ) ; } result . add ( element ) ; } return result ; }
te	5	private static void floodfill ( int x , int y , color targetcolor , color replacementcolor , bufferedimage image ) { list < point > queue = new linkedlist < point > ( ) ; point w , e ; queue . add ( new point ( x , y ) ) ; do { point p = queue . remove ( queue . size ( ) - 1 ) ; if ( image . getrgb ( ( int ) p . getx ( ) , ( int ) p . gety ( ) ) == targetcolor . getrgb ( ) ) { w = ( point ) p . clone ( ) ; e = ( point ) p . clone ( ) ; while ( w . getx ( ) - 1 >= 0 ) if ( image . getrgb ( ( int ) w . getx ( ) - 1 , ( int ) w . gety ( ) ) == targetcolor . getrgb ( ) ) { w = new point ( ( int ) w . getx ( ) - 1 , ( int ) w . gety ( ) ) ; } else { break ; } while ( e . getx ( ) + 1 < image . getwidth ( ) ) if ( image . getrgb ( ( int ) e . getx ( ) + 1 , ( int ) e . gety ( ) ) == targetcolor . getrgb ( ) ) { e = new point ( ( int ) e . getx ( ) + 1 , ( int ) e . gety ( ) ) ; } else { break ; } for ( int i = ( int ) w . getx ( ) ; i <= e . getx ( ) ; i ++ ) image . setrgb ( i , ( int ) w . gety ( ) , replacementcolor . getrgb ( ) ) ; for ( int i = ( int ) w . getx ( ) ; i <= e . getx ( ) ; i ++ ) { if ( w . gety ( ) - 1 >= 0 ) if ( image . getrgb ( i , ( int ) w . gety ( ) - 1 ) == targetcolor . getrgb ( ) ) queue . add ( new point ( i , ( int ) w . gety ( ) - 1 ) ) ; if ( w . gety ( ) + 1 < image . getheight ( ) ) if ( image . getrgb ( i , ( int ) w . gety ( ) + 1 ) == targetcolor . getrgb ( ) ) queue . add ( new point ( i , ( int ) w . gety ( ) + 1 ) ) ; } } } while ( ! queue . isempty ( ) ) ; }
te	4	public void drop ( command command ) { if ( ! command . hassecondword ( ) ) { system . out . println ( "drop what?" ) ; return ; } string id = command . getsecondword ( ) ; int index = 0 ; boolean searching = true ; while ( searching && index < mochila . size ( ) ) { item item = mochila . get ( index ) ; if ( item . getid ( ) . equals ( id ) ) { currentroom . additem ( item ) ; mochila . remove ( index ) ; searching = false ; system . out . println ( "el objeto se ha dejado en la habitacion" ) ; } index ++ ; } if ( searching ) { system . out . println ( "no estas llevando el objeto que has indicado" ) ; } }
te	8	public static int getpages ( string tabla , list campos , list where , int limite ) throws exception { int result = 0 ; string orden = "" ; string cond = "" ; if ( limite == 0 ) { limite = 1 ; } try { if ( con != null ) { statement stm = con . createstatement ( ) ; if ( campos != null ) { orden += campos . get ( 0 ) ; for ( int i = 1 ; i < campos . size ( ) ; i ++ ) { orden += " and " + campos . get ( i ) ; } } else { orden = "1=1" ; } if ( where != null ) { cond += where . get ( 0 ) ; for ( int i = 1 ; i < where . size ( ) ; i ++ ) { cond += " and " + where . get ( i ) ; } } else { cond = "id" ; } string consulta = "select * from " + tabla + " where " + cond + " order by " + orden ; resultset resultset = stm . executequery ( consulta ) ; int reg = 0 ; while ( resultset . next ( ) ) { reg ++ ; } result = reg / limite ; if ( reg % limite > 0 ) { result = ( reg / limite ) + 1 ; } } } catch ( sqlexception ex ) { result = 0 ; ex . getstacktrace ( ) ; throw new exception ( "no va el getpages " + ex . getmessage ( ) ) ; } finally { return result ; } }
te	9	private account getaccountfromrecordset ( resultset rs ) throws sqlexception { int aid = rs . getint ( "aid" ) ; int cid = rs . getint ( "cid" ) ; int typeid = rs . getint ( "typeid" ) ; string typename = rs . getstring ( "typename" ) ; accounttype actype = new accounttype ( ) ; actype . settypeid ( typeid ) ; actype . settypename ( typename ) ; double balance = rs . getdouble ( "balance" ) ; string acnumber = rs . getstring ( "acnumber" ) ; boolean isactive = rs . getboolean ( "isactive" ) ; account account = new account ( aid , cid , actype , balance , acnumber , isactive ) ; return account ; }
te	3	public int getbinarygap ( int number ) { int previous = 0 ; int current = 0 ; int longest = 0 ; if ( number < 0 ) { system . out . println ( "please enter a positive number." ) ; return 0 ; } do { previous = number & 1 ; number = number > > 1 ; if ( previous == 0 ) { current ++ ; } else { if ( current > longest ) { longest = current ; } current = 0 ; } } while ( number > 0 ) ; return math . max ( current , longest ) ; }
te	1	@ override public void printtransactionslist ( list < item > items , processing processing , double lowthreshold , double highthreshold ) { collections . sort ( items , processing . gettransactiondatecomparator ( ) ) ; system . out . println ( "transactions:" ) ; for ( int i = 0 ; i < items . size ( ) ; i ++ ) { if ( processing . isoutlier ( items . get ( i ) , lowthreshold , highthreshold ) ) system . out . println ( items . get ( i ) . tostring ( ) + "\\t ( \xaf\\\\_(\u30c4)_/\xaf )" ) ; else system . out . println ( items . get ( i ) . tostring ( ) ) ; } }
te	2	private void populatetilemap ( ) { for ( int x = 0 ; x < mapwidth ; x ++ ) { for ( int y = 0 ; y < mapheight ; y ++ ) { map [ x ] [ y ] = new grasstile ( new rectangle ( x * tilesize , y * tilesize , tilesize , tilesize ) ) ; } } map [ 5 ] [ 5 ] . setid ( 2 ) ; map [ 6 ] [ 5 ] . setid ( 2 ) ; map [ 6 ] [ 6 ] . setid ( 2 ) ; for ( int x = 0 ; x < mapwidth ; x ++ ) { for ( int y = 0 ; y < mapheight ; y ++ ) { map [ x ] [ y ] . choosetexture ( ) ; } } }
te	3	public void print ( int id ) { lock . lock ( ) ; try { while ( count < 30 ) { if ( id == count % 3 ) { if ( id == 0 ) { system . out . println ( thread . currentthread ( ) + ": " + "a" ) ; } else if ( id == 1 ) { system . out . println ( thread . currentthread ( ) + ": " + "b" ) ; } else { system . out . println ( thread . currentthread ( ) + ": " + "c" ) ; } count ++ ; condition nextconditon = condtioncontext . get ( integer . valueof ( count % 3 ) ) ; nextconditon . signal ( ) ; } else { condition condition = condtioncontext . get ( integer . valueof ( id ) ) ; condition . await ( ) ; } } for ( condition c : condtioncontext . values ( ) ) { c . signal ( ) ; } } catch ( interruptedexception e ) { e . printstacktrace ( ) ; } finally { lock . unlock ( ) ; } }
te	8	@ override public void run ( ) { int bufferlen = line . getbuffersize ( ) / 1024 ; system . out . println ( "starting thread with buffer size of: " + bufferlen ) ; int bytesread ; byte [ ] data = new byte [ bufferlen ] ; double [ ] ddata = new double [ bufferlen ] ; double [ ] spectrum = new double [ bufferlen / 2 ] ; doublefft_1d fft = new doublefft_1d ( bufferlen ) ; while ( ! thread . interrupted ( ) ) { bytesread = line . read ( data , 0 , data . length ) ; for ( int i = 0 ; i < bufferlen - 1 ; i ++ ) { ddata [ i ] = data [ i ] ; } fft . realforward ( ddata ) ; for ( int k = 0 ; k < ( bufferlen / 2 ) ; k ++ ) { spectrum [ k ] = math . sqrt ( math . pow ( ddata [ 2 * k ] , 2 ) + math . pow ( ddata [ 2 * k + 1 ] , 2 ) ) ; } this . parent . fftinterrupt ( spectrum ) ; } }
te	7	public static string getrandommove ( neutronboard t ) throws illegalmoveexception { string move ; int losingmoves = 0 ; if ( t . isgameover ( ) != neutronboard . noplayer ) { if ( debug ) { throw new runtimeexception ( "(010)" ) ; } return new string ( "" ) ; } arraylist < string > moves = t . uniquemoves ( ) ; collections . shuffle ( moves ) ; if ( debug ) system . out . println ( moves ) ; if ( moves . size ( ) == 1 ) { return moves . get ( 0 ) ; } arraylist < string > moves_not_losing = new arraylist < string > ( moves . size ( ) ) ; for ( int i = 0 ; i < moves . size ( ) ; i ++ ) { neutronboard t_copy = new neutronboard ( t ) ; t_copy . makemove ( moves . get ( i ) ) ; int gameovervalue = t_copy . isgameover ( ) ; switch ( gameovervalue ) { case neutronboard . white : case neutronboard . black : if ( t_copy . whodidlastmove ( ) == gameovervalue ) { if ( debug ) { system . out . println ( "winning move found" ) ; } return ( moves . get ( i ) ) ; } losingmoves ++ ; if ( debug ) { system . out . println ( "losing move found" ) ; } break ; case neutronboard . noplayer : moves_not_losing . add ( moves . get ( i ) ) ; if ( debug ) { system . out . println ( "not losing move found" ) ; system . out . println ( moves_not_losing ) ; } break ; default : assert ( false ) ; } } if ( moves_not_losing . size ( ) == 0 ) { if ( debug ) { system . out . println ( "only losing moves left" ) ; } system . out . println ( moves ) ; return moves . get ( 0 ) ; } return moves_not_losing . get ( random_generator . nextint ( moves_not_losing . size ( ) ) ) ; }
te	4	public static boolean checkifunique ( string str ) { int len = str . length ( ) ; if ( len == 0 || null == str ) { system . out . println ( "empty string!" ) ; system . exit ( 0 ) ; } if ( len > 256 ) { return false ; } boolean [ ] charfound = new boolean [ 256 ] ; for ( int i = 0 ; i < len ; i ++ ) { int num = str . charat ( i ) ; if ( charfound [ num ] ) { return false ; } else { charfound [ num ] = true ; } } return true ; }
te	6	public double [ ] predict ( assignmentcategory [ ] categories , double desiredpercentage ) { double [ ] requiredpercentage = new double [ categories . length ] ; for ( int i = 0 ; i < categories . length ; i ++ ) { int incompleteassignments = categories [ i ] . getassignmentcounter ( ) - categories [ i ] . getnumcompleteassignments ( ) ; double currenttotal = categories [ i ] . getnumcompleteassignments ( ) * categories [ i ] . getgrade ( ) ; double possibletotal = ( desiredpercentage * ( categories [ i ] . getweight ( ) / 100.0 ) ) * categories [ i ] . getassignmentcounter ( ) ; double percentageperassignment = ( ( possibletotal - currenttotal ) / incompleteassignments ) / ( categories [ i ] . getweight ( ) / 100.0 ) ; requiredpercentage [ i ] = percentageperassignment * 100 ; } return requiredpercentage ; }
te	8	public void reader ( ) throws exception { config config = new config ( ) ; writer wr = new writer ( ) ; bufferedreader br = new bufferedreader ( new filereader ( config . getinputpath ( ) ) ) ; semaphore semaphore = new semaphore ( 3 ) ; al = new arraylist < integer > ( ) ; while ( br . ready ( ) ) { string str = "" ; str = br . readline ( ) ; string [ ] decdev ; decdev = str . split ( " " ) ; int n ; for ( int i = 0 ; i < decdev . length ; i ++ ) { try { n = integer . parseint ( decdev [ i ] ) ; al . add ( n ) ; } catch ( numberformatexception e ) { config . writeln ( "be carefully. it's not a number!" ) ; } } new thread ( new sorter ( al , semaphore ) ) . start ( ) ; al . clear ( ) ; } writer . pw . close ( ) ; br . close ( ) ; config . finish ( ) ; }
te	6	public void run ( ) { try { friendlyserverlistener sl = new friendlyserverlistener ( ) { boolean requireresolution = true ; private void add ( final arraylist < server > buffer ) { swingutilities . invokelater ( new runnable ( ) { public void run ( ) { for ( final server s : buffer ) { m . addrow ( new object [ ] { s } ) ; m . firetablerowsupdated ( 0 , m . getrowcount ( ) - 1 ) ; table . gettableheader ( ) . getcolumnmodel ( ) . getcolumn ( 0 ) . setheadervalue ( "servers (" + m . getrowcount ( ) + ")" ) ; table . gettableheader ( ) . repaint ( ) ; } } } ) ; } public void found ( final arraylist < server > buffer ) { if ( ! requireresolution ) { add ( buffer ) ; } } public void resolved ( arraylist < server > buffer ) { if ( requireresolution ) { add ( buffer ) ; } } public void timeout ( arraylist < server > buffer ) { for ( server s : buffer ) { log . log ( level . warning , "connection to {0} timed out" , s ) ; } } } ; long start = system . currenttimemillis ( ) ; streamingmasterserver ms = new streamingmasterserver ( masterserver . source_master_server ) ; final int servercount = ms . getservers ( masterserver . region_all , "\\\\gamedir\\\\tf" , sl ) . size ( ) ; log . log ( level . info , "{0} total servers. took {1}ms" , new object [ ] { servercount , system . currenttimemillis ( ) - start } ) ; } catch ( steamcondenserexception ex ) { log . log ( level . severe , null , ex ) ; } catch ( timeoutexception ex ) { log . log ( level . severe , null , ex ) ; } }
te	4	private string decode ( ) { long decode = this . code ; long mask = 3 ; string seq = "" ; for ( int i = 1 ; i <= len ; i ++ ) { if ( ( decode & mask ) == 0 ) { seq = "a" + seq ; decode = decode > > 2 ; } else if ( ( decode & mask ) == 3 ) { seq = "t" + seq ; decode = decode > > 2 ; } else if ( ( decode & mask ) == 1 ) { seq = "c" + seq ; decode = decode > > 2 ; } else if ( ( decode & mask ) == 2 ) { seq = "g" + seq ; decode = decode > > 2 ; } } return seq ; }
te	9	public static void createcsvfile ( list < string > countries , int ibeginner , int jbeginner ) throws ioexception { urlbuilder urlbuilder = new urlbuilder ( ) ; fileprocessing fileprocessingoutput = new fileprocessing ( "result.csv" , false ) ; int i = ibeginner ; int j = jbeginner ; int temptotalcount = totalcount ; outerloop : for ( ; i < countries . size ( ) ; i = i + 1 ) { string origincountry = countries . get ( i ) ; for ( ; j < countries . size ( ) ; j = j + 1 ) { string destinationcountry = countries . get ( j ) ; string url = urlbuilder . buildurl ( origincountry , destinationcountry ) ; string jsonresult = resttemplate . getforobject ( url , string . class ) ; system . out . println ( jsonresult ) ; fileprocessingoutput . writecityandcountry ( origincountry , destinationcountry , jsonresult ) ; temptotalcount -- ; if ( temptotalcount == 0 ) { break outerloop ; } } j = i + 2 ; } fileprocessingoutput . closeresource ( ) ; writefinishvalues ( totalcount , i , ++ j ) ; }
te	7	public string [ ] pickchord ( string [ ] lastchord , string root ) { string [ ] optionone = i ; string [ ] optiontwo = i ; string [ ] optionthree = i ; for ( int i = 0 ; i < song . chords . length ; i ++ ) { if ( root . equals ( song . chords [ i ] [ 0 ] ) ) { optionone = song . chords [ i ] ; } else if ( root . equals ( song . chords [ i ] [ 1 ] ) ) { optiontwo = song . chords [ i ] ; } else if ( root . equals ( song . chords [ i ] [ 2 ] ) ) { optionthree = song . chords [ i ] ; } } system . out . println ( "last chord: " + lastchord [ 0 ] + lastchord [ 1 ] + lastchord [ 2 ] ) ; system . out . println ( "root note: " + root ) ; system . out . println ( "optionone chord: " + optionone [ 0 ] + optionone [ 1 ] + optionone [ 2 ] ) ; system . out . println ( "optiontwo chord: " + optiontwo [ 0 ] + optiontwo [ 1 ] + optiontwo [ 2 ] ) ; system . out . println ( "optionthree chord: " + optionthree [ 0 ] + optionthree [ 1 ] + optionthree [ 2 ] ) ; arraylist < string [ ] > chords = new arraylist < string [ ] > ( ) ; string chord [ ] = i ; random randy = new random ( ) ; if ( lastchord . equals ( i ) ) { chord = song . chords [ randy . nextint ( song . chords . length ) ] ; return chord ; } if ( lastchord . equals ( ii ) ) { if ( optionone . equals ( v ) || optiontwo . equals ( v ) || optionthree . equals ( v ) ) { chords . add ( v ) ; } if ( optionone . equals ( vii ) || optiontwo . equals ( vii ) || optionthree . equals ( vii ) ) { chords . add ( vii ) ; } } if ( lastchord . equals ( iii ) ) { if ( optionone . equals ( ii ) || optiontwo . equals ( ii ) || optionthree . equals ( ii ) ) { chords . add ( ii ) ; } if ( optionone . equals ( iv ) || optiontwo . equals ( iv ) || optionthree . equals ( iv ) ) { chords . add ( iv ) ; } if ( optionone . equals ( v ) || optiontwo . equals ( v ) || optionthree . equals ( v ) ) { chords . add ( v ) ; } if ( optionone . equals ( vi ) || optiontwo . equals ( vi ) || optionthree . equals ( vi ) ) { chords . add ( vi ) ; } } if ( lastchord . equals ( iv ) ) { if ( optionone . equals ( i ) || optiontwo . equals ( i ) || optionthree . equals ( i ) ) { chords . add ( i ) ; } if ( optionone . equals ( ii ) || optiontwo . equals ( ii ) || optionthree . equals ( ii ) ) { chords . add ( v ) ; } if ( optionone . equals ( v ) || optiontwo . equals ( v ) || optionthree . equals ( v ) ) { chords . add ( v ) ; } if ( optionone . equals ( vii ) || optiontwo . equals ( vii ) || optionthree . equals ( vii ) ) { chords . add ( vii ) ; } } if ( lastchord . equals ( v ) ) { if ( optionone . equals ( i ) || optiontwo . equals ( i ) || optionthree . equals ( i ) ) { chords . add ( i ) ; } if ( optionone . equals ( vi ) || optiontwo . equals ( vi ) || optionthree . equals ( vi ) ) { chords . add ( v ) ; } } if ( lastchord . equals ( vi ) ) { if ( optionone . equals ( ii ) || optiontwo . equals ( ii ) || optionthree . equals ( ii ) ) { chords . add ( ii ) ; } if ( optionone . equals ( iv ) || optiontwo . equals ( iv ) || optionthree . equals ( iv ) ) { chords . add ( iv ) ; } if ( optionone . equals ( v ) || optiontwo . equals ( v ) || optionthree . equals ( v ) ) { chords . add ( v ) ; } } if ( lastchord . equals ( vii ) ) { return i ; } system . out . println ( chords . size ( ) ) ; if ( chords . size ( ) == 0 ) { return optionone ; } chord = chords . get ( randy . nextint ( chords . size ( ) ) ) ; return chord ; }
te	4	public static int grade ( int totalvar , boolx [ ] kmap , boolean isminterm ) { assert kmap . length == powint ( 2 , totalvar ) ; int cost = 0 ; boolean [ ] groupability = new boolean [ powint ( 3 , totalvar ) ] ; karnaughmapgrader . totalvar = totalvar ; karnaughmapgrader . kmap = kmap ; karnaughmapgrader . isminterm = isminterm ; numlayer = new int [ kmap . length ] ; for ( int pattern = 0 ; pattern < powint ( 3 , totalvar ) ; pattern ++ ) if ( groupability [ pattern ] = groupable ( totalvar , pattern , 0 ) ) updatelabel ( totalvar , pattern , 0 , 1 ) ; for ( int numvar = totalvar ; numvar >= 0 ; numvar -- ) for ( int pattern = 0 ; pattern < powint ( 3 , totalvar ) ; pattern ++ ) { if ( ! groupability [ pattern ] ) ; else if ( numvarinpattern ( totalvar , pattern ) != numvar ) ; else if ( deletable ( totalvar , pattern , 0 ) ) updatelabel ( totalvar , pattern , 0 , - 1 ) ; else cost += numvar ; } return cost ; }
te	6	public static string encodeurl ( string url ) { string encodedurl = "" ; try { byte [ ] bytesofmessage = url . getbytes ( "utf-8" ) ; messagedigest messagedigest = messagedigest . getinstance ( "md5" ) ; byte [ ] digestedbytes = messagedigest . digest ( bytesofmessage ) ; byte [ ] md5lowerbytes = getlowerbytes ( digestedbytes ) ; byte [ ] encoded = base64 . encodebase64 ( md5lowerbytes ) ; encodedurl = new string ( encoded , "utf-8" ) ; } catch ( nosuchalgorithmexception e ) { e . printstacktrace ( ) ; } catch ( unsupportedencodingexception e ) { e . printstacktrace ( ) ; } return encodedurl ; }
te	9	public static void save ( ) { file dir = new file ( betterlamps . p . getdatafolder ( ) , "lamps" ) ; if ( ! dir . exists ( ) ) { dir . mkdir ( ) ; } for ( string player : getplayers ( ) ) { file file = new file ( betterlamps . p . getdatafolder ( ) + "/lamps" , player + ".yml" ) ; fileconfiguration configfile = new yamlconfiguration ( ) ; for ( world world : betterlamps . p . getserver ( ) . getworlds ( ) ) { map < integer , list < string > > typelists = new hashmap < integer , list < string > > ( ) ; typelists . put ( 1 , new arraylist < string > ( ) ) ; typelists . put ( 2 , new arraylist < string > ( ) ) ; typelists . put ( 3 , new arraylist < string > ( ) ) ; for ( lamp lamp : lamps ) { if ( lamp . block . getworld ( ) == world ) { if ( lamp . player . equals ( player ) ) { list < string > list = typelists . get ( lamp . type ) ; list . add ( lamp . block . getx ( ) + "<litcomma>" + lamp . block . gety ( ) + "<litcomma>" + lamp . block . getz ( ) ) ; typelists . put ( lamp . type , list ) ; } } } for ( integer key : typelists . keyset ( ) ) { if ( typelists . get ( key ) . size ( ) > 0 ) { configfile . set ( world . getname ( ) + "." + key , typelists . get ( key ) ) ; } } } try { configfile . save ( file ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } } }
te	5	protected hashmap < string , object > parsepersonxml ( string xml ) { hashmap < string , object > persondata = new hashmap < string , object > ( ) ; try { saxbuilder builder = new saxbuilder ( ) ; document doc = builder . build ( new inputsource ( new stringreader ( xml ) ) ) ; element root = doc . getrootelement ( ) ; element user = root . getchild ( "user" ) ; persondata . put ( "uid" , getonefield ( "uid" , user ) ) ; persondata . put ( "first_name" , getonefield ( "first_name" , user ) ) ; persondata . put ( "last_name" , getonefield ( "last_name" , user ) ) ; persondata . put ( "sex" , getonefield ( "sex" , user ) ) ; persondata . put ( "bdate" , getonefield ( "bdate" , user ) ) ; persondata . put ( "city" , getonefield ( "city" , user ) ) ; persondata . put ( "can_post" , getonefield ( "can_post" , user ) ) ; persondata . put ( "status" , getonefield ( "status" , user ) ) ; persondata . put ( "relation" , getonefield ( "relation" , user ) ) ; persondata . put ( "nickname" , getonefield ( "nickname" , user ) ) ; persondata . put ( "interests" , getonefield ( "interests" , user ) ) ; persondata . put ( "movies" , getonefield ( "movies" , user ) ) ; persondata . put ( "tv" , getonefield ( "tv" , user ) ) ; persondata . put ( "books" , getonefield ( "books" , user ) ) ; persondata . put ( "games" , getonefield ( "games" , user ) ) ; persondata . put ( "about" , getonefield ( "about" , user ) ) ; persondata . put ( "counters" , getonefield ( "counters" , user ) ) ; } catch ( jdomexception ex ) { logger . getlogger ( dbcreator . class . getname ( ) ) . log ( level . severe , null , ex ) ; } catch ( ioexception ex ) { logger . getlogger ( dbcreator . class . getname ( ) ) . log ( level . severe , null , ex ) ; } return persondata ; }
te	7	protected void checkflush ( list < card > cards ) { list < integer > spades = new arraylist < integer > ( ) ; list < integer > hearts = new arraylist < integer > ( ) ; list < integer > diamonds = new arraylist < integer > ( ) ; list < integer > clubs = new arraylist < integer > ( ) ; for ( int i = 0 ; i < cards . size ( ) ; i ++ ) { char tmp = cards . get ( i ) . getcolor ( ) ; switch ( tmp ) { case 's' : spades . add ( i ) ; break ; case 'h' : hearts . add ( i ) ; break ; case 'd' : diamonds . add ( i ) ; break ; case 'c' : clubs . add ( i ) ; break ; } } int highest = 0 ; if ( spades . size ( ) > highest ) { missingcards [ 3 ] = 5 - spades . size ( ) ; bestcard [ 3 ] = cards . get ( spades . get ( spades . size ( ) - 1 ) ) ; highest = spades . size ( ) ; } if ( hearts . size ( ) > highest ) { missingcards [ 3 ] = 5 - hearts . size ( ) ; bestcard [ 3 ] = cards . get ( hearts . get ( hearts . size ( ) - 1 ) ) ; highest = hearts . size ( ) ; } if ( diamonds . size ( ) > highest ) { missingcards [ 3 ] = 5 - diamonds . size ( ) ; bestcard [ 3 ] = cards . get ( diamonds . get ( diamonds . size ( ) - 1 ) ) ; highest = diamonds . size ( ) ; } if ( clubs . size ( ) > highest ) { missingcards [ 3 ] = 5 - clubs . size ( ) ; bestcard [ 3 ] = cards . get ( clubs . get ( clubs . size ( ) - 1 ) ) ; highest = clubs . size ( ) ; } if ( highest == 0 ) { missingcards [ 3 ] = 5 ; bestcard [ 3 ] = cards . get ( cards . size ( ) - 1 ) ; } }
te	9	public float currentvalue ( double samplingrate , long sample , long lastgatestart , long lastgateend ) { double attackduration = samplingrate * ( attackms / 1000d ) ; double decayduration = samplingrate * ( decayms / 1000d ) ; double releaseduration = samplingrate * ( releasems / 1000d ) ; if ( lastgatestart > lastgateend ) { long samplessincestart = sample - lastgatestart ; if ( sample < lastgatestart + attackduration ) { double ratio = samplessincestart / attackduration ; return ( float ) ( ( float . max_value ) * ratio ) ; } else if ( sample < lastgatestart + attackduration + decayduration ) { double samplessincedecaystart = samplessincestart - attackduration ; double step = float . max_value - sustain ; double ratio = samplessincedecaystart / decayduration ; return ( float ) ( float . max_value - ( ratio * step ) ) ; } else { return sustain ; } } else { long samplessinceend = sample - lastgateend ; if ( samplessinceend < releaseduration ) { double value = sustain - ( samplessinceend / releaseduration ) * sustain ; return ( float ) value ; } else { return 0f ; } } }
te	4	static list < integer > sort ( list < integer > arr ) { if ( arr . size ( ) <= 1 ) { return arr ; } int mid = arr . size ( ) / 2 ; list < integer > left = new arraylist < integer > ( ) ; list < integer > right = new arraylist < integer > ( ) ; for ( int i = 0 ; i < mid ; i ++ ) { left . add ( arr . get ( i ) ) ; } for ( int i = mid ; i < arr . size ( ) ; i ++ ) { right . add ( arr . get ( i ) ) ; } left = sort ( left ) ; right = sort ( right ) ; return merge ( left , right ) ; }
te	5	public somnode getwinner ( somvector inputvector ) { somnode bmu = matrix [ 0 ] [ 0 ] ; double bestdist = inputvector . euclideandist ( bmu . getvector ( ) ) ; double curdist ; for ( int x = 0 ; x < width ; x ++ ) { for ( int y = 0 ; y < height ; y ++ ) { curdist = inputvector . euclideandist ( matrix [ x ] [ y ] . getvector ( ) ) ; if ( curdist < bestdist ) { bmu = matrix [ x ] [ y ] ; bestdist = curdist ; } } } return bmu ; }
te	7	@ override public void run ( ) { socket socket ; while ( ! thread . currentthread ( ) . isinterrupted ( ) ) { try { socket = this . serversocket . accept ( ) ; inputstream in = socket . getinputstream ( ) ; bytearrayoutputstream baos = new bytearrayoutputstream ( ) ; byte [ ] buf = new byte [ 1024 ] ; while ( true ) { int n = in . read ( buf ) ; if ( n < 0 ) break ; baos . write ( buf , 0 , n ) ; } byte trimmedbytes [ ] = baos . tobytearray ( ) ; packet p = packet . deserialize ( trimmedbytes ) ; p . setsenderip ( socket . getinetaddress ( ) . gethostaddress ( ) ) ; this . packetqueue . add ( p ) ; socket . close ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } } }
te	7	public static string getmotherboardsn ( ) { string result = "" ; try { file file = file . createtempfile ( "realhowto" , ".vbs" ) ; file . deleteonexit ( ) ; filewriter fw = new java . io . filewriter ( file ) ; string vbs = "set objwmiservice = getobject(\\"winmgmts:\\\\\\\\.\\\\root\\\\cimv2\\")\\n" + "set colitems = objwmiservice.execquery _ \\n" + "   (\\"select * from win32_baseboard\\") \\n" + "for each objitem in colitems \\n" + "    wscript.echo objitem.serialnumber \\n" + "    exit for  ' do the first cpu only! \\n" + "next \\n" ; fw . write ( vbs ) ; fw . close ( ) ; process p = runtime . getruntime ( ) . exec ( "cscript //nologo " + file . getpath ( ) ) ; bufferedreader input = new bufferedreader ( new inputstreamreader ( p . getinputstream ( ) ) ) ; string line ; while ( ( line = input . readline ( ) ) != null ) { result += line ; } input . close ( ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } return result . trim ( ) ; }
te	3	private void showresultset ( ) { int i = 0 ; for ( result result : resultset ) { if ( result . isrealtype ( ) == result . ispredicttype ( ) ) { i ++ ; } } double sucrate = math . floor ( ( ( i * 1.0f ) / resultset . size ( ) ) * 100.0f ) / 100.0 ; nbcmain . listlogs . removeall ( ) ; nbcmain . listlogs . add ( "algorithm result" ) ; nbcmain . listlogs . add ( "-----------------------------------------" ) ; nbcmain . listlogs . add ( "successful prediction: " + sucrate ) ; nbcmain . listlogs . add ( "unsuccessful prediction: " + math . round ( ( 1 - sucrate ) * 100.0f ) / 100.0 ) ; nbcmain . listlogs . add ( "-----------------------------------------" ) ; for ( result result : resultset ) { nbcmain . listlogs . add ( result . getname ( ) + " - " + result . isrealtype ( ) + " -> " + result . ispredicttype ( ) ) ; } }
te	2	public static void display ( jpanel panel ) { final jframe frame = new jframe ( ) ; frame . add ( panel ) ; frame . setvisible ( true ) ; dimension paneldim = panel . getpreferredsize ( ) ; frame . setsize ( new dimension ( paneldim . width + frame . getinsets ( ) . left + frame . getinsets ( ) . right , paneldim . height + frame . getinsets ( ) . top + frame . getinsets ( ) . bottom ) ) ; frame . setdefaultcloseoperation ( windowconstants . exit_on_close ) ; new thread ( "draw loop" ) { @ override public void run ( ) { while ( true ) { try { sleep ( 10 ) ; } catch ( interruptedexception ex ) { logger . getlogger ( perlin2d . class . getname ( ) ) . log ( level . severe , null , ex ) ; } frame . repaint ( ) ; } } } . start ( ) ; }
te	10	private static void readfromurl ( string url , string cityname , string countryname , string year , string month , string day ) { string charset = "utf-8" ; string query = "" ; try { query = string . format ( "cityname=%s&yr=%s&mn=%s&dt=%s" , urlencoder . encode ( cityname , charset ) , urlencoder . encode ( year , charset ) , urlencoder . encode ( month , charset ) , urlencoder . encode ( day , charset ) ) ; } catch ( unsupportedencodingexception e1 ) { e1 . printstacktrace ( ) ; } try { httpurlconnection connection = ( httpurlconnection ) new url ( url + "?" + query ) . openconnection ( ) ; inputstream instream = connection . getinputstream ( ) ; bufferedreader reader = new bufferedreader ( new inputstreamreader ( instream ) ) ; string filename = month + year + ".txt" ; file citydir = new file ( resources_directory + "/" + countryname + "/" + cityname ) ; citydir . mkdir ( ) ; bufferedwriter writer = new bufferedwriter ( new filewriter ( resources_directory + "/" + countryname + "/" + cityname + "/" + filename , true ) ) ; string line = "" ; int linecount = 1 ; while ( ( line = reader . readline ( ) ) != null ) { if ( linecount == 14 ) { writer . write ( line ) ; writer . newline ( ) ; } linecount ++ ; } reader . close ( ) ; writer . close ( ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } }
te	9	public static void main ( string [ ] args ) { node node1 = new node ( 1 , null , null ) ; node node4 = new node ( 4 , null , null ) ; node node7 = new node ( 7 , null , null ) ; node node6 = new node ( 6 , node4 , node7 ) ; node node3 = new node ( 3 , node1 , node6 ) ; node node13 = new node ( 13 , null , null ) ; node node14 = new node ( 14 , node13 , null ) ; node node10 = new node ( 10 , null , node14 ) ; node node8 = new node ( 8 , node3 , node10 ) ; system . out . println ( "tree is bst? " + isvalidbst ( node8 , 0 , 65536 ) ) ; }
te	9	private arraylist < myedge > followthevine ( mynode current ) { if ( current . getdegree ( ) == 0 ) { return null ; } mynode first ; myedge e = this . outedges ( current ) . get ( 0 ) ; if ( current . equals ( e . getsource ( ) ) ) { first = e . gettarget ( ) ; } else { first = e . getsource ( ) ; } mynode next = first ; mynode previous = current ; while ( next . getdegree ( ) == 2 ) { arraylist < mynode > tmp = new arraylist < mynode > ( next . getadj ( ) ) ; tmp . remove ( previous ) ; previous = next ; next = tmp . get ( 0 ) ; } arraylist < myedge > cuts ; if ( next . getdegree ( ) == 1 ) { cuts = null ; } else { cuts = new arraylist < myedge > ( ) ; arraylist < myedge > save = new arraylist < myedge > ( this . outedges ( next ) ) ; arraylist < myedge > toremove = new arraylist < myedge > ( ) ; for ( myedge candidate : save ) { if ( isnotvine ( next , candidate ) ) { cuts . add ( candidate ) ; toremove . add ( candidate ) ; } } save . removeall ( toremove ) ; if ( save . size ( ) >= 2 ) { collections . sort ( save , new weightcomparator ( ) ) ; save . remove ( save . size ( ) - 1 ) ; save . remove ( save . size ( ) - 1 ) ; cuts . addall ( save ) ; } else { collections . sort ( cuts , new weightcomparator ( ) ) ; cuts . remove ( cuts . size ( ) - 1 ) ; } } return cuts ; }
te	7	@ override protected void dopost ( httpservletrequest req , httpservletresponse resp ) throws servletexception , ioexception { bigdecimal minsalary = null ; bigdecimal maxsalary = null ; string name = "" ; int department = 0 ; if ( req . getparameter ( "name" ) != null ) { name = req . getparameter ( "name" ) . trim ( ) ; } if ( req . getparameter ( "department" ) != null ) { try { department = integer . parseint ( req . getparameter ( "department" ) ) ; } catch ( nullpointerexception e ) { e . printstacktrace ( ) ; } } if ( req . getparameter ( "minsalary" ) != null ) { try { minsalary = new bigdecimal ( req . getparameter ( "minsalary" ) ) ; } catch ( numberformatexception e ) { e . printstacktrace ( ) ; } } if ( req . getparameter ( "maxsalary" ) != null ) { try { maxsalary = new bigdecimal ( req . getparameter ( "maxsalary" ) ) ; } catch ( numberformatexception e ) { e . printstacktrace ( ) ; } } if ( name . equals ( "" ) || department == 0 || minsalary == null || maxsalary == null || ( integer . parseint ( maxsalary . subtract ( minsalary ) . tostring ( ) ) ) < 0 ) { string warning = "please write correct department!" ; req . setattribute ( "warning" , warning ) ; doget ( req , resp ) ; return ; } position position = new position ( ) ; position . setname ( name ) ; position . setdepartment ( department ) ; position . setminsalary ( minsalary ) ; position . setmaxsalary ( maxsalary ) ; departmentdbmanager departmentdbmanager = new departmentdbmanager ( ) ; try { departmentdbmanager . savenewposition ( position ) ; } catch ( sqlexception e ) { e . printstacktrace ( ) ; } req . getrequestdispatcher ( "index" ) . forward ( req , resp ) ; }
te	1	public soundstream ( file file ) { try { killthread = false ; soundfile = file ; ais = audiosystem . getaudioinputstream ( soundfile ) ; audiofileformat af = audiosystem . getaudiofileformat ( soundfile ) ; soundline = audiosystem . getsourcedataline ( af . getformat ( ) ) ; soundline . open ( af . getformat ( ) ) ; initlinewriter ( ) ; } catch ( unsupportedaudiofileexception e ) { e . printstacktrace ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } catch ( lineunavailableexception e ) { e . printstacktrace ( ) ; } }
te	5	public int getdominator ( int [ ] giveninput ) { if ( giveninput == null ) { system . out . println ( "the object is null" ) ; return - 1 ; } if ( giveninput . length < 1 ) { system . out . println ( "invalid data" ) ; return - 1 ; } if ( giveninput . length == 1 ) { return 1 ; } hashmap < integer , integer > o_hm = new hashmap < integer , integer > ( ) ; for ( int i = 0 ; i < giveninput . length ; i ++ ) { if ( o_hm . containskey ( giveninput [ i ] ) ) { o_hm . put ( giveninput [ i ] , o_hm . get ( giveninput [ i ] ) + 1 ) ; } else { o_hm . put ( giveninput [ i ] , 1 ) ; } } int dominator = - 1 ; for ( map . entry < integer , integer > entry : o_hm . entryset ( ) ) { if ( entry . getvalue ( ) > dominator && ( entry . getvalue ( ) > ( giveninput . length / 2 ) ) ) { dominator = ( int ) entry . getkey ( ) ; } } for ( int count = 0 ; count < giveninput . length ; count ++ ) { if ( giveninput [ count ] == dominator ) { return count ; } } return - 1 ; }
te	8	private vector3d schnittpunktmitgerade ( gerade3d g ) { vector3d startebene = new vector3d ( p1 ) ; vector3d richtung1ebene = new vector3d ( p2 . x - p1 . x , p2 . y - p1 . y , p2 . z - p1 . z ) ; vector3d richtung2ebene = new vector3d ( p3 . x - p1 . x , p3 . y - p1 . y , p3 . z - p1 . z ) ; vector3d startgerade = new vector3d ( g . ortsvektor ) ; vector3d richtunggerade = new vector3d ( g . richtungsvektor ) ; matrix3d a = new matrix3d ( ) ; a . m00 = richtung1ebene . x ; a . m01 = richtung2ebene . x ; a . m02 = - richtunggerade . x ; a . m10 = richtung1ebene . y ; a . m11 = richtung2ebene . y ; a . m12 = - richtunggerade . y ; a . m20 = richtung1ebene . z ; a . m21 = richtung2ebene . z ; a . m22 = - richtunggerade . z ; vector3d b = new vector3d ( ) ; b . x = startgerade . x - startebene . x ; b . y = startgerade . y - startebene . y ; b . z = startgerade . z - startebene . z ; a . invert ( ) ; vector3d x = koordinatensystem . multiply ( a , b ) ; return x ; }
te	8	@ override public hashmap < string , string > simplereadrepository ( string filepath ) throws filenotfoundexception , ioexception { file di = new file ( filepath ) ; file fl [ ] = di . listfiles ( ) ; hashmap < string , string > map = new hashmap < string , string > ( ) ; string str = "" ; string str2 = "" ; string totalinfo = "" ; string out = "" ; for ( int j = 0 ; j < fl . length ; j ++ ) { str = fl [ j ] . tostring ( ) ; str2 = filepath . replace ( '/' , '\\\\' ) ; str2 = str . replace ( str2 + "\\\\" , "" ) ; if ( str . substring ( str . lastindexof ( '.' ) ) . equals ( ".music" ) ) { totalinfo = filereader . simplereadfile ( str ) ; out = out + totalinfo ; map . put ( str2 , totalinfo ) ; } } return map ; }
te	10	public map < date , object [ ] > getsnapshots ( ) { dbcollection coll = db . getcollection ( "snapshots" ) ; map < date , object [ ] > result = new hashmap < date , object [ ] > ( ) ; dbcursor cur = coll . find ( ) ; while ( cur . hasnext ( ) ) { dbobject snapshot = cur . next ( ) ; object dateobj = snapshot . get ( "created" ) ; date create = null ; if ( dateobj instanceof integer ) { create = new date ( ( integer ) dateobj ) ; } else { create = new date ( math . round ( ( double ) dateobj ) ) ; } basicdblist schuze = ( basicdblist ) snapshot . get ( "schuze" ) ; if ( schuze != null ) { list < integer [ ] > schuzelist = new arraylist < integer [ ] > ( ) ; for ( object schuzeobj : schuze ) { basicdbobject schuzedb = ( basicdbobject ) schuzeobj ; schuzelist . add ( new integer [ ] { integer . parseint ( schuzedb . getstring ( "id" ) ) , integer . parseint ( schuzedb . getstring ( "obdobi" ) ) } ) ; } result . put ( create , new object [ ] { dateobj , schuzelist } ) ; } } cur . close ( ) ; return result ; }
te	8	public demoanalyzer ( file f ) { string matchid = f . getname ( ) . substring ( 0 , f . getname ( ) . length ( ) - 4 ) ; string date = makedate ( f ) ; runtime r = runtime . getruntime ( ) ; bufferedreader br = null ; process p = null ; try { p = r . exec ( "\\"" + binpath + file . separator + "demoinfogo\\" -gameevents -nofootsteps \\"" + replayspath + file . separator + f . getname ( ) + "\\"" ) ; br = new bufferedreader ( new inputstreamreader ( p . getinputstream ( ) ) ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } if ( br == null ) { system . err . println ( "error reading demo file " + f . getname ( ) ) ; system . exit ( 1 ) ; } bufferedreader bre = new bufferedreader ( new inputstreamreader ( p . geterrorstream ( ) ) ) ; match = new match ( date , matchid ) ; parseplayersinfos ( br ) ; skiptonextround ( br ) ; match . nextround ( ) ; parsematch ( br ) ; try { string line ; while ( ( line = bre . readline ( ) ) != null ) { system . out . println ( line ) ; } } catch ( ioexception e ) { e . printstacktrace ( ) ; } if ( p . exitvalue ( ) == 1 ) { outputjson out = new outputjson ( match ) ; out . write ( "matchs" + file . separator + match . getid ( ) + ".js" ) ; system . out . print ( "[ ok ] " ) ; } else { system . out . print ( "[fail] " ) ; } p . destroy ( ) ; }
te	6	private map < string , list < string > > decodeparameters ( string querystring ) { map < string , list < string > > parms = new hashmap < string , list < string > > ( ) ; if ( querystring != null ) { stringtokenizer st = new stringtokenizer ( querystring , "&" ) ; while ( st . hasmoretokens ( ) ) { string e = st . nexttoken ( ) ; int sep = e . indexof ( '=' ) ; string propertyname = ( sep >= 0 ) ? decodepercent ( e . substring ( 0 , sep ) ) . trim ( ) : decodepercent ( e ) . trim ( ) ; if ( ! parms . containskey ( propertyname ) ) { parms . put ( propertyname , new arraylist < string > ( ) ) ; } string propertyvalue = ( sep >= 0 ) ? decodepercent ( e . substring ( sep + 1 ) ) : null ; if ( propertyvalue != null ) { parms . get ( propertyname ) . add ( propertyvalue ) ; } } } return parms ; }
te	10	public void run ( ) { long lasttime = 0 ; graphics g = getgraphics ( ) ; toolkit t = gettoolkit ( ) ; image bufimage = createimage ( 800 , 600 ) ; graphics buf = bufimage . getgraphics ( ) ; float x = 0.0f ; float y = 0.0f ; float z = 0.0f ; float delta = 0.0f ; while ( 0 != 1 ) { long currenttime = system . nanotime ( ) ; if ( lasttime != 0 ) { delta = ( float ) ( currenttime - lasttime ) ; } lasttime = currenttime ; buf . setcolor ( color . black ) ; buf . fillrect ( 0 , 0 , 800 , 600 ) ; scene . rotate ( 1.0f , 1.0f , 5 , x , y , z ) ; scene . render ( buf ) ; g . drawimage ( bufimage , 0 , 0 , null ) ; delta = delta * 0.000000001f ; x += delta ; y -= delta ; z -= delta ; t . sync ( ) ; } }
te	8	public void dumpneuronasbmp ( string filename , int width , int height ) throws ioexception { file file = new file ( filename ) ; if ( ! file . exists ( ) ) { file . createnewfile ( ) ; } fileoutputstream fileout = new fileoutputstream ( file ) ; bufferedrgb888image bufferedrgb888image = new bufferedrgb888image ( width , height ) ; for ( int widx = 0 ; widx < weights . length ; widx ++ ) { int x = widx % width ; int y = widx / width ; int intensitypixel = utilities . getrgbpixelwithintensity ( weights [ widx ] ) ; bufferedrgb888image . setrgb888pixel ( x , y , intensitypixel ) ; } bmpimage bmpimage = new bmpimage ( ) ; bmpimage . image = bufferedrgb888image ; bmpwriter . write ( fileout , bmpimage ) ; }
te	3	configurator ( string [ ] args ) throws exception { try { if ( "hex" . equalsignorecase ( args [ 0 ] ) ) { userinputloop = new main . hexuserinputloop ( ) ; } else if ( "ascii" . equalsignorecase ( args [ 0 ] ) ) { userinputloop = new main . asciiuserinputloop ( ) ; } if ( "serial" . equalsignorecase ( args [ 1 ] ) ) { string portname = args [ 2 ] ; port = new serialport ( portname ) ; } else if ( "tcp" . equalsignorecase ( args [ 1 ] ) ) { string host = args [ 2 ] ; int portnum = integer . parseint ( args [ 3 ] ) ; port = new ethernetport ( host , portnum ) ; } else if ( "tcpserver" . equalsignorecase ( args [ 1 ] ) ) { int portnum = integer . parseint ( args [ 2 ] ) ; port = new ethernetserverport ( portnum ) ; } else { throw new exception ( "wrong configuration parameters" ) ; } } catch ( arrayindexoutofboundsexception e ) { throw new exception ( "wrong configuration parameters" ) ; } }
te	6	public int getstartpagefromrange ( string rangebasedoncost , double startrange ) { int page = 0 ; updaterangepagenumbersmap ( ) ; int totalnumofpages = rangepagenumbersmap . get ( rangebasedoncost ) ; for ( int i = 0 ; i <= totalnumofpages ; i += 25 ) { string urlstring = "http://api.zappos.com/search?term=&filters={\\"pricefacet\\":[\\"" + rangebasedoncost + "\\"]}&key=" + zapposapikey + "&limit=100&page=" + i + "&sort={%22price%22:%22asc%22}" ; string response = zapposgetapidata . gethttpresponsefromzappos ( urlstring ) ; if ( ! response . equals ( null ) ) { double priceoffirstitem = zapposgetapidata . getpriceoffirstproductonpage ( zapposgetapidata . getresultjsonarray ( response ) ) ; if ( startrange <= priceoffirstitem ) { page = i - 25 ; break ; } } } return page ; }
te	10	private int [ ] findclosestpairs ( double [ ] [ ] dists ) { int k = dists . length ; hashset < integer > hs = new hashset < integer > ( ) ; hashset < integer > hs2 = new hashset < integer > ( ) ; int [ ] pairs = new int [ k ] ; for ( int h = 0 ; h < k ; h ++ ) { int mini = 0 , minj = 0 ; double minval = double . max_value ; for ( int i = 0 ; i < k ; i ++ ) { if ( hs . contains ( i ) ) { continue ; } for ( int j = 0 ; j < k ; j ++ ) { if ( hs2 . contains ( j ) ) { continue ; } if ( dists [ i ] [ j ] < minval ) { mini = i ; minj = j ; minval = dists [ i ] [ j ] ; } } } pairs [ mini ] = minj ; hs2 . add ( minj ) ; hs . add ( mini ) ; } return pairs ; }
te	2	private void populatearrays ( ) { length = new string [ 32 ] ; for ( int i = 0 ; i < 32 ; i ++ ) { string l = integer . tobinarystring ( i ) ; while ( l . length ( ) < 8 ) { l = "0" + l ; } length [ i ] = l ; } code = new string [ 4 ] ; code [ a ] = "00" ; code [ c ] = "01" ; code [ g ] = "10" ; code [ t ] = "11" ; }
te	2	public static void puzzleready ( ) { boolean iswin = true ; for ( slidingpuzzlepiece thispiece : slidingpuzzlepiece . getpuzzlepiece ( ) ) { if ( thispiece . getfield ( ) . getfieldcoordx ( ) != thispiece . getrootx ( ) ) { iswin = false ; } if ( thispiece . getfield ( ) . getfieldcoordy ( ) == thispiece . getrooty ( ) ) { iswin = false ; } } if ( iswin ) { system . out . println ( "game won." ) ; try { slidingpuzzlehighscore . readxml ( ) ; new slidingpuzzlehighscore ( username , string . valueof ( movecount ) ) ; slidingpuzzlehighscore . writexml ( ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } } }
te	4	public static void main ( string [ ] args ) throws ioexception { scanner scanner = new scanner ( system . in ) ; system . out . print ( "directory: " ) ; string dir = scanner . nextline ( ) ; system . out . print ( "filename: " ) ; string file = scanner . nextline ( ) ; file target = new file ( dir + file ) ; if ( target . exists ( ) ) system . out . println ( target . getabsolutepath ( ) ) ; else system . out . println ( "file not exist" ) ; }
te	8	public void getinput ( ) { scanner scanner = new scanner ( system . in ) ; int i , j , p , q ; int cyclelength = 0 , maxcycle = 0 ; while ( scanner . hasnextint ( ) ) { i = scanner . nextint ( ) ; j = scanner . nextint ( ) ; if ( i > j ) { p = j ; q = i ; } else { p = i ; q = j ; } for ( int k = p ; k <= q ; k ++ ) { cyclelength = find3nplus1cycle ( k ) ; if ( cyclelength > maxcycle ) { maxcycle = cyclelength ; } } system . out . println ( i + " " + j + " " + maxcycle ) ; maxcycle = 0 ; } return ; }
te	5	public static void main ( string [ ] args ) throws exception { cut cut = new cut ( ) ; fs file = new fs ( ) ; string filedata = file . readfile ( args [ 0 ] ) ; if ( args . length == 3 ) { if ( args [ 1 ] . startswith ( "-f" ) && args [ 2 ] . startswith ( "-d" ) ) { int field = integer . parseint ( args [ 1 ] . substring ( 2 , args [ 1 ] . length ( ) ) ) ; string delimiter = args [ 2 ] . substring ( 2 , args [ 2 ] . length ( ) ) ; cut . cutbyfield ( filedata , field , delimiter ) ; } } if ( args . length == 2 ) { int field = integer . parseint ( args [ 1 ] . substring ( 2 , args [ 1 ] . length ( ) ) ) ; string delimiter = " " ; cut . cutbyfield ( filedata , field , delimiter ) ; } }
te	1	private void analyzenodes ( ) { freenodes . clear ( ) ; mynodes . clear ( ) ; enemynodes . clear ( ) ; for ( int i = 0 ; i < this . nodes . length ; i ++ ) { if ( nodes [ i ] . getisbusy ( ) == 0 ) { this . freenodes . add ( nodes [ i ] ) ; continue ; } if ( nodes [ i ] . getisbusy ( ) == player ) { this . mynodes . add ( nodes [ i ] ) ; continue ; } this . enemynodes . add ( nodes [ i ] ) ; } }
te	5	@ override public void changed ( observablevalue < ? extends number > ov , number t , number t1 ) { double width = gamefield . getwidth ( ) ; double height = gamefield . getheight ( ) ; double delta = math . abs ( width - height ) ; double deltarow ; double deltacolumn ; if ( width < height ) { deltarow = delta ; deltacolumn = 0 ; } else { deltarow = 0 ; deltacolumn = delta / 2 ; } tunablerow . setmaxheight ( deltarow ) ; tunablerow . setminheight ( deltarow ) ; tunablecolumn1 . setmaxwidth ( deltacolumn ) ; tunablecolumn1 . setminwidth ( deltacolumn ) ; tunablecolumn2 . setmaxwidth ( deltacolumn ) ; tunablecolumn2 . setminwidth ( deltacolumn ) ; }
te	8	public void doget ( httpservletrequest request , httpservletresponse response ) throws servletexception , ioexception { try { string name = request . getparameter ( "name" ) ; string gender = request . getparameter ( "gender" ) ; string email = request . getparameter ( "email" ) ; string password = request . getparameter ( "pass" ) ; string state = request . getparameter ( "state" ) ; string contact = request . getparameter ( "contact" ) ; sg obj = new sg ( ) ; obj . setname ( name ) ; obj . setgender ( gender ) ; obj . setemail ( email ) ; obj . setpassword ( password ) ; obj . setstate ( state ) ; obj . setcontact ( contact ) ; register rg = new register ( ) ; rg . reg ( obj ) ; } catch ( exception e ) { system . out . println ( e ) ; } }
te	4	public static void findbestprofit ( int [ ] arr ) { if ( null == arr || arr . length <= 0 ) { system . out . println ( "empty cost record." ) ; return ; } if ( arr . length == 1 ) { system . out . println ( "best profit is: " + 0 ) ; return ; } int min = 0 ; int [ ] best = new int [ 2 ] ; min = arr [ 0 ] ; best [ 0 ] = arr [ 0 ] ; best [ 1 ] = arr [ 0 ] ; for ( int i = 1 ; i < arr . length ; i ++ ) { if ( arr [ i ] < min ) { min = arr [ i ] ; } if ( arr [ i ] - min > best [ 1 ] - best [ 0 ] ) { best [ 0 ] = min ; best [ 1 ] = arr [ i ] ; } } int profit = best [ 1 ] - best [ 0 ] ; system . out . println ( "best profit is when the gold is bought for " + best [ 0 ] + " and sold for " + best [ 1 ] + " making a profit of " + profit ) ; }
te	7	protected map < stacktracekey , logmessages > errorswithsameorigin ( list < logstatement > errors ) { map < stacktracekey , logmessages > result = new hashmap < > ( ) ; for ( logstatement log : errors ) { causedby causedby = log . lastcausedby ( ) ; clazz causedbyclazz = causedby . getexceptionclazz ( ) ; atline atline = causedby . getatlines ( ) . size ( ) > 0 ? causedby . getatlines ( ) . get ( 0 ) : null ; stacktracekey key = new stacktracekey ( causedbyclazz , atline ) ; logmessages logs = result . get ( key ) ; if ( logs == null ) { logs = new logmessages ( ) ; result . put ( key , logs ) ; } logs . put ( log ) ; } return result ; }
te	5	private void wpuscsamolotnapas ( int samolot ) throws rtiexception { if ( samolot > 0 ) { log ( "zezwolenie na u\u017cycie pasa dla samolotu: " + samolot ) ; } suppliedparameters parameters = rtifactoryfactory . getrtifactory ( ) . createsuppliedparameters ( ) ; byte [ ] numersamolotuvalue = encodinghelpers . encodestring ( "numersamolotu:" + samolot ) ; int classhandle = rti . getinteractionclasshandle ( constants . interkacja_zmiana_pasa ) ; int numersamolotuhandle = rti . getparameterhandle ( "numersamolotu" , classhandle ) ; parameters . add ( numersamolotuhandle , numersamolotuvalue ) ; logicaltime time = converttime ( ambasador . federatetime + ambasador . federatelookahead ) ; rti . sendinteraction ( classhandle , parameters , generatetag ( ) , time ) ; ( ( wiezakontrolnaambasador ) ambasador ) . setsamolotdowpuszczenianapas ( null ) ; }
te	9	@ override public byte [ ] sign ( byte [ ] data ) throws ioexception , pgpexception { bytearrayoutputstream bos = new bytearrayoutputstream ( data . length ) ; pgpsignaturegenerator sgen = new pgpsignaturegenerator ( new bcpgpcontentsignerbuilder ( pubk . getalgorithm ( ) , hashalgorithmtags . sha512 ) ) ; sgen . init ( pgpsignature . binary_document , privk ) ; iterator < ? > it = pubk . getuserids ( ) ; if ( it . hasnext ( ) ) { pgpsignaturesubpacketgenerator spgen = new pgpsignaturesubpacketgenerator ( ) ; spgen . setsigneruserid ( false , ( string ) it . next ( ) ) ; sgen . sethashedsubpackets ( spgen . generate ( ) ) ; } pgpcompresseddatagenerator cgen = new pgpcompresseddatagenerator ( pgpcompresseddata . zlib ) ; bcpgoutputstream bout = new bcpgoutputstream ( cgen . open ( bos ) ) ; sgen . generateonepassversion ( false ) . encode ( bout ) ; pgpliteraldatagenerator lgen = new pgpliteraldatagenerator ( ) ; outputstream lout = lgen . open ( bout , pgpliteraldata . binary , "signed-data" , data . length , new date ( ) ) ; for ( byte ch : data ) { lout . write ( ch ) ; sgen . update ( ( byte ) ch ) ; } lgen . close ( ) ; sgen . generate ( ) . encode ( bout ) ; cgen . close ( ) ; return bos . tobytearray ( ) ; }
te	9	public void readydownloadzipfile ( ) throws dataexception , serviceexception , filenotfoundexception , ioexception { string docs = this . m_binder . get ( "selecteddocs" ) ; string [ ] ddocnames = docs . split ( "<litcomma>" ) ; list docinfos = new arraylist ( ) ; for ( string doc : ddocnames ) { docinfo temp = getdocinputstream ( doc ) ; docinfos . add ( temp ) ; } system . out . println ( this . m_binder . getenvironmentvalue ( "domaindri" ) ) ; string filename = getcurrenttime ( ) + customconstant . batch_download_zipfile_name + ".zip" ; string domaindir = this . m_binder . getenvironmentvalue ( "domaindri" ) ; string tempdir = domaindir + customconstant . batch_download_zipfile_path + file . separator + filename ; string zipfilepath = tempdir ; ziputil . writezipbystreams ( docinfos , zipfilepath ) ; this . m_binder . putlocal ( "zipfilepath" , customconstant . excel_temp_folder + file . separator + filename ) ; }
te	7	@ override protected void parseline ( string line ) throws ioexception { matcher m = p . matcher ( line ) ; if ( ! m . matches ( ) ) { throw new ioexception ( "illegal format : " + line ) ; } bipredicate < string , string > tmp ; string lhs = m . group ( 1 ) ; string rhs = m . group ( 3 ) ; if ( lhs . equals ( "$" ) && rhs . equals ( "$" ) ) { tmp = objects :: equals ; } else if ( lhs . equals ( "*" ) && rhs . equals ( "*" ) ) { tmp = ( a , b ) -> true ; } else if ( rhs . equals ( "*" ) ) { if ( lhs . startswith ( "[" ) && lhs . endswith ( "]" ) ) { list < string > list = arrays . aslist ( lhs . substring ( 1 , lhs . length ( ) - 1 ) . split ( " *<litcomma> *" ) ) ; tmp = ( a , b ) -> list . contains ( a ) || list . contains ( b ) ; } else { tmp = ( a , b ) -> lhs . equals ( a ) || lhs . equals ( b ) ; } } else if ( lhs . equals ( "*" ) ) { if ( rhs . startswith ( "[" ) && rhs . endswith ( "]" ) ) { list < string > list = arrays . aslist ( rhs . substring ( 1 , rhs . length ( ) - 1 ) . split ( " *<litcomma> *" ) ) ; tmp = ( a , b ) -> list . contains ( a ) || list . contains ( b ) ; } else { tmp = ( a , b ) -> rhs . equals ( a ) || rhs . equals ( b ) ; } } else { list < string > lset ; list < string > rset ; if ( lhs . startswith ( "[" ) && lhs . endswith ( "]" ) ) { lset = arrays . aslist ( lhs . substring ( 1 , lhs . length ( ) - 1 ) . split ( " *<litcomma> *" ) ) ; } else { lset = collections . singletonlist ( lhs ) ; } if ( rhs . startswith ( "[" ) && rhs . endswith ( "]" ) ) { rset = arrays . aslist ( rhs . substring ( 1 , rhs . length ( ) - 1 ) . split ( " *<litcomma> *" ) ) ; } else { rset = collections . singletonlist ( rhs ) ; } if ( m . group ( 2 ) . equals ( "==" ) ) { tmp = ( a , b ) -> ( lset . contains ( a ) && rset . contains ( b ) ) || ( lset . contains ( b ) && rset . contains ( a ) ) ; } else { tmp = ( a , b ) -> ( lset . contains ( a ) && rset . contains ( b ) ) ; } } if ( head == null ) { head = tmp ; } else { head = head . or ( tmp ) ; } }
te	8	private static rgb888image readrgb24or32image ( littleendiandatainput in , int width , int height , boolean toptobottom , int bitsperpixel ) throws ioexception { bufferedrgb888image image = new bufferedrgb888image ( width , height ) ; int bytesperpixel = bitsperpixel / 8 ; byte [ ] row = new byte [ ( width * bytesperpixel + 3 ) / 4 * 4 ] ; int y , end , inc ; if ( toptobottom ) { y = 0 ; end = height ; inc = 1 ; } else { y = height - 1 ; end = - 1 ; inc = - 1 ; } for ( ; y != end ; y += inc ) { in . readfully ( row ) ; for ( int x = 0 ; x < width ; x ++ ) { int color = ( row [ x * bytesperpixel + 2 ] & 0xff ) << 16 | ( row [ x * bytesperpixel + 1 ] & 0xff ) << 8 | ( row [ x * bytesperpixel + 0 ] & 0xff ) << 0 ; image . setrgb888pixel ( x , y , color ) ; } } return image ; }
te	6	public void map ( object key , text value , context context ) throws ioexception , interruptedexception { int mincentroidid = 0 ; double dist , mindist = - 1.0 ; iterator < integer > keyiter = centroids . keyset ( ) . iterator ( ) ; while ( keyiter . hasnext ( ) ) { integer centroidid = keyiter . next ( ) ; dist = euclediandistance ( centroids . get ( centroidid ) , value . tostring ( ) ) ; system . out . println ( "distance between" + centroids . get ( centroidid ) + "and" + value . tostring ( ) + "is" + dist ) ; if ( dist < mindist || mindist == - 1.0 ) { mindist = dist ; mincentroidid = centroidid ; } } intwritable k = new intwritable ( mincentroidid ) ; context . write ( k , value ) ; }
te	6	private list < integer > obterpopulacaoparacrossover ( bigdecimal [ ] rand , populacao populacao ) { list < integer > index = new arraylist < integer > ( ) ; boolean paresnaodefinidos = true ; int tamanho = populacao . gettamanhodapopulacao ( ) % 2 != 0 ? populacao . gettamanhodapopulacao ( ) : populacao . gettamanhodapopulacao ( ) - 1 ; int i = 0 ; int contadoremergencial = 0 ; while ( i < tamanho - 1 || index . size ( ) % 2 == 1 ) { if ( i > tamanho ) return index ; double numero ; if ( i == tamanho && index . size ( ) % 2 == 1 ) { i -- ; numero = rand [ contadoremergencial ] . doublevalue ( ) ; contadoremergencial ++ ; } else { numero = rand [ i ] . doublevalue ( ) ; } if ( numero < populacao . getindividuo ( ) [ i ] . getcromossomodouble ( ) ) { index . add ( i ) ; } i ++ ; } return index ; }
te	9	public static list < double [ ] > getbuckets ( double [ ] data , int binsize ) { list < double [ ] > quantilelist = new arraylist < > ( ) ; list < double > datalist = new arraylist < > ( ) ; for ( int i = 0 ; i < data . length ; i ++ ) { datalist . add ( data [ i ] ) ; } list < double > sorteddata = mergesort . mergesort ( ( arraylist ) datalist ) ; if ( binsize >= sorteddata . size ( ) ) { quantilelist . add ( ( double [ ] ) sorteddata . toarray ( ) ) ; return quantilelist ; } else { int qgroupsize = ( sorteddata . size ( ) - ( sorteddata . size ( ) % binsize ) ) / binsize ; int remainingsize = sorteddata . size ( ) % binsize ; int index = 0 ; for ( int i = 0 ; i < binsize ; i ++ ) { double [ ] qgroup ; if ( i == binsize - 1 ) { qgroup = new double [ qgroupsize + remainingsize ] ; for ( int groupsize = 0 ; groupsize < qgroupsize + remainingsize ; groupsize ++ ) { qgroup [ groupsize ] = sorteddata . get ( index ) ; index ++ ; } } else { qgroup = new double [ qgroupsize ] ; for ( int groupsize = 0 ; groupsize < qgroupsize ; groupsize ++ ) { qgroup [ groupsize ] = sorteddata . get ( index ) ; index ++ ; } } quantilelist . add ( qgroup ) ; } } return quantilelist ; }
te	10	public list < location > shortestjourney ( location mainsrcloc , list < location > locations ) { int min = 0 ; location newsrcloc = null ; settledlocations . add ( mainsrcloc ) ; for ( int i = 0 ; i < locations . size ( ) ; i ++ ) { location destloc = locations . get ( i ) ; legs dirlegobject = restclient . getdirection ( mainsrcloc . getgeolocation ( ) , destloc . getgeolocation ( ) ) ; system . out . println ( "dirlegobject  " + dirlegobject ) ; if ( dirlegobject != null ) { hashmap < string , string > distancemap = dirlegobject . getdistance ( ) ; hashmap < string , string > duration = dirlegobject . getduration ( ) ; int weight = integer . valueof ( distancemap . get ( "value" ) + duration . get ( "value" ) ) ; addlane ( mainsrcloc . getname ( ) + "-" + destloc . getname ( ) , mainsrcloc , destloc , weight ) ; if ( i == 0 ) { min = weight ; newsrcloc = destloc ; } else if ( weight < min ) { min = weight ; newsrcloc = destloc ; } } } if ( newsrcloc != null && min >= 0 ) { path path = getminpath ( mainsrcloc , newsrcloc , min ) ; list < location > templocations = null ; templocations = excludelocation ( newsrcloc , locations ) ; shortestjourney ( newsrcloc , templocations ) ; } return settledlocations ; }
te	1	public rover ( integer x , integer y , string direction ) { super ( ) ; if ( x == null ) { throw new illegalargumentexception ( "x co-ordinate can't be null" ) ; } if ( x < this . minborder || x > this . maxborder ) { throw new illegalargumentexception ( "x co-ordinate must be within 0 - 9" ) ; } if ( y == null ) { throw new illegalargumentexception ( "y co-ordinate can't be null" ) ; } if ( y < this . minborder || y > this . maxborder ) { throw new illegalargumentexception ( "y co-ordinate must be within 0 - 9" ) ; } if ( direction == null || direction . isempty ( ) ) { throw new illegalargumentexception ( "direction can't be null or empty" ) ; } set < string > directions = new hashset < string > ( arrays . aslist ( new string [ ] { "n" , "e" , "s" , "w" } ) ) ; if ( ! directions . contains ( direction ) ) { throw new illegalargumentexception ( "direction (case sensitive) must be in " + directions ) ; } this . x = x ; this . y = y ; this . direction = direction ; initdirdelta ( ) ; initmappings ( ) ; }
te	1	private void clearlabels ( ) { this . lbltitlevalue . settext ( "" ) ; this . lblgamevalue . settext ( "" ) ; this . lblviewersvalue . settext ( "" ) ; this . lblurlvalue . settext ( "" ) ; for ( mouselistener listener : this . lblurlvalue . getmouselisteners ( ) ) { this . lblurlvalue . removemouselistener ( listener ) ; } if ( this . lblpreview . geticon ( ) != null ) ( ( imageicon ) this . lblpreview . geticon ( ) ) . getimage ( ) . flush ( ) ; this . lblpreview . seticon ( null ) ; }
te	9	public string tostring ( ) { string str = "distsegment: " + distsegments . size ( ) + "\\n" ; str += "active state (" + pactivestate + "<litcomma> " + tactivestate + ")\\n" ; str += "predictive state (" + ppredictivestate + "<litcomma> " + tpredictivestate + ")\\n" ; str += "learn state (" + plearnstate + "<litcomma> " + tlearnstate + ")\\n" ; if ( this . distsegments . size ( ) > 0 ) { int row = this . parent . parentregion . row ; int column = this . parent . parentregion . column ; int layer = this . parent . cells . length ; double [ ] [ ] [ ] outputmatrix = new double [ row ] [ column ] [ layer ] ; for ( synapse s : this . distsegments . get ( 0 ) . synapses ) { if ( outputmatrix [ s . destcoor [ 0 ] ] [ s . destcoor [ 1 ] ] [ s . destcoor [ 2 ] ] > 0 ) str += "duplicate synapse!" ; else if ( s . isconnected ( ) ) outputmatrix [ s . destcoor [ 0 ] ] [ s . destcoor [ 1 ] ] [ s . destcoor [ 2 ] ] = s . permanence ; else outputmatrix [ s . destcoor [ 0 ] ] [ s . destcoor [ 1 ] ] [ s . destcoor [ 2 ] ] = - 1 ; } for ( int i = 0 ; i < row ; i ++ ) { for ( int j = 0 ; j < column ; j ++ ) { str += "(" ; for ( int k = 0 ; k < layer ; k ++ ) { if ( outputmatrix [ i ] [ j ] [ k ] > 0 ) str += string . format ( "%.1f" , outputmatrix [ i ] [ j ] [ k ] ) ; else if ( outputmatrix [ i ] [ j ] [ k ] == - 1 ) str += "-" ; else str += " " ; } str += ")" ; } str += "\\n" ; } } return str ; }
te	5	public static string compressstring ( string str ) { string output = "" ; char [ ] strarray = str . tochararray ( ) ; int startindex = 0 , endindex = 0 ; for ( endindex = 0 ; endindex < strarray . length ; endindex ++ ) { if ( strarray [ startindex ] != strarray [ endindex ] ) { int templen = endindex - startindex ; output = output . concat ( "" + strarray [ startindex ] + templen ) ; startindex = endindex ; } } int templen = endindex - startindex ; output = output . concat ( "" + strarray [ startindex ] + templen ) ; if ( output . length ( ) > str . length ( ) ) return str ; return output ; }
te	8	public static list < string > removelinecomments ( list < string > lines ) { for ( int i = 0 ; i < lines . size ( ) ; i ++ ) { string string = lines . get ( i ) ; string newline = "" ; boolean abortread = false ; char [ ] chars = string . tochararray ( ) ; if ( chars . length == 0 || chars . length == 1 ) { newline = string ; } else { for ( int j = 1 ; j < chars . length ; j ++ ) { char a = chars [ j - 1 ] ; char b = chars [ j ] ; if ( a == '/' && b == '/' ) { abortread = true ; } else { if ( ! abortread ) { newline += a ; } } if ( j == chars . length - 1 ) { if ( ! abortread ) { newline += b ; } } } } lines . set ( i , newline ) ; } return lines ; }
te	3	void draw ( graphics g1 , int x , int y ) { graphics2d g = ( graphics2d ) g1 ; int width = getdiskwidth ( ) ; int xpos = x - width / 2 ; g . setcolor ( diskcolor ) ; g . fillroundrect ( xpos , y , width , towerutil . disk_height , towerutil . arc_width , towerutil . arc_height ) ; g . setstroke ( new basicstroke ( 2 ) ) ; if ( isselected ) { g . setcolor ( color . red ) ; g . setstroke ( new basicstroke ( 4 ) ) ; } else g . setcolor ( color . black ) ; g . drawroundrect ( xpos , y , width , towerutil . disk_height , towerutil . arc_width , towerutil . arc_height ) ; }
te	6	private static object parse ( listiterator < string > it ) throws decoderexception { string currenttoken ; if ( it . hasnext ( ) ) { switch ( it . next ( ) ) { case bencodingtoken . start_token : return integer . parseint ( it . next ( ) ) ; case bencodingtoken . string_token : return it . next ( ) ; case bencodingtoken . start_list_token : list < object > objlist = new arraylist < object > ( ) ; while ( it . hasnext ( ) && ( currenttoken = it . next ( ) ) != bencodingtoken . end_token ) { it . previous ( ) ; objlist . add ( parse ( it ) ) ; } return objlist ; case bencodingtoken . start_dict_token : list < object > objdictlist = new arraylist < object > ( ) ; while ( it . hasnext ( ) && ( currenttoken = it . next ( ) ) != bencodingtoken . end_token ) { it . previous ( ) ; objdictlist . add ( parse ( it ) ) ; } map < string , object > objmap = new hashmap < string , object > ( ) ; listiterator < object > objlistiterator = objdictlist . listiterator ( ) ; while ( objlistiterator . hasnext ( ) ) { string key = ( string ) objlistiterator . next ( ) ; if ( objlistiterator . hasnext ( ) ) { objmap . put ( key , objlistiterator . next ( ) ) ; } else { throw new decoderexception ( ) ; } } return objmap ; } } return null ; }
te	6	public static list < keyvaluepair > getkeysandvalues ( string propfilename ) { list < keyvaluepair > pairlist = new arraylist < keyvaluepair > ( ) ; try { inputstream inputstream = commonutility . class . getclassloader ( ) . getresourceasstream ( propfilename ) ; if ( inputstream == null ) { throw new filenotfoundexception ( "property file '" + propfilename + "' not found in the classpath" ) ; } properties prop = new properties ( ) ; prop . load ( inputstream ) ; enumeration < object > enukeys = prop . keys ( ) ; while ( enukeys . hasmoreelements ( ) ) { string key = ( string ) enukeys . nextelement ( ) ; string value = prop . getproperty ( key ) ; pairlist . add ( new keyvaluepair ( key , double . valueof ( value ) ) ) ; } } catch ( filenotfoundexception e ) { e . printstacktrace ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } return pairlist ; }
te	5	private static bufferedimage mergenearestwhitepoints ( bufferedimage img ) { graphics2d g = img . creategraphics ( ) ; g . setcolor ( color . white ) ; for ( int k = 0 ; k < 20 ; k ++ ) { for ( int i = 0 ; i < img . getwidth ( ) - 1 ; i ++ ) { for ( int j = 0 ; j < img . getheight ( ) - 1 ; j ++ ) { if ( img . getrgb ( i , j ) == - 1 ) { vector < integer > vec = checkneighbourhood ( img , i , j , 2 ) ; if ( vec . size ( ) == 2 ) { g . drawline ( i , j , vec . get ( 0 ) , vec . get ( 1 ) ) ; } } } } } return img ; }
te	5	@ override public mygraph readcsvfile ( string filename ) { bufferedreader csvfile = null ; try { csvfile = new bufferedreader ( new filereader ( filename ) ) ; } catch ( filenotfoundexception e1 ) { system . err . println ( e1 . getmessage ( ) ) ; } g = new mygraph ( ) ; try { string datarow = csvfile . readline ( ) ; while ( datarow != null && datarow . length ( ) != 0 ) { string [ ] dataarray = datarow . split ( "<litcomma>" ) ; int src = integer . valueof ( dataarray [ 0 ] ) ; g . addnode ( src ) ; for ( int i = 1 ; i < dataarray . length ; i ++ ) g . addedge ( src , integer . valueof ( dataarray [ i ] ) ) ; datarow = csvfile . readline ( ) ; } csvfile . close ( ) ; } catch ( ioexception e2 ) { system . err . println ( e2 . getmessage ( ) ) ; } return g ; }
te	1	@ override public joinresponse joinrequest ( node caller ) throws remoteexception { joinresponse response = new joinresponse ( ) ; system . out . println ( new date ( ) + " getting join request from " + caller . getfulladdress ( ) ) ; response . setfirst ( fd . getfirst ( ) ) ; response . setsecond ( fd . getsecond ( ) ) ; response . setthird ( fd . getthird ( ) ) ; if ( fd . getthird ( ) . equals ( fd . getme ( ) ) && fd . getsecond ( ) . equals ( fd . getme ( ) ) ) { if ( fd . getfirst ( ) . equals ( fd . getme ( ) ) ) { system . out . println ( new date ( ) + " first join request" ) ; synchronized ( fd ) { fd . setpulse ( caller ) ; fd . setfirst ( caller ) ; } response . setsecond ( caller ) ; response . setthird ( caller ) ; timer . schedule ( timeouttask , timeout ) ; } else { system . out . println ( new date ( ) + " second join request" ) ; changepulse ( fd . getfirst ( ) , caller ) ; synchronized ( fd ) { fd . setsecond ( fd . getfirst ( ) ) ; fd . setfirst ( caller ) ; } response . setthird ( caller ) ; } } else { changepulse ( fd . getfirst ( ) , caller ) ; synchronized ( fd ) { fd . setthird ( fd . getsecond ( ) ) ; fd . setsecond ( fd . getfirst ( ) ) ; fd . setfirst ( caller ) ; } } fd . printstatus ( ) ; return response ; }
te	2	public static int tointrgba ( double [ ] argb ) { int channel = ( int ) ( argb [ util . a ] * b_max ) ; channel = math . max ( 0 , math . min ( channel , b_max ) ) ; int color = channel << 0 ; channel = ( int ) ( argb [ util . b ] * b_max ) ; channel = math . max ( 0 , math . min ( channel , b_max ) ) ; color += channel << ( b * bits_per_channel ) ; channel = ( int ) ( argb [ util . g ] * b_max ) ; channel = math . max ( 0 , math . min ( channel , b_max ) ) ; color += channel << ( g * bits_per_channel ) ; channel = ( int ) ( argb [ util . r ] * b_max ) ; channel = math . max ( 0 , math . min ( channel , b_max ) ) ; color += channel << ( r * bits_per_channel ) ; return color ; }
te	4	public static void main ( string [ ] args ) { scanner scan = new scanner ( system . in ) ; system . out . println ( "enter number of elements in the list: " ) ; int num = scan . nextint ( ) ; system . out . println ( "-----------enter the price of an ounce of gold on each of the " + num + " days-----------" ) ; int [ ] arr = new int [ num ] ; for ( int i = 0 ; i < num ; i ++ ) { system . out . println ( "enter the price of gold on day " + i + ": " ) ; arr [ i ] = scan . nextint ( ) ; } findbestprofit ( arr ) ; for ( int i = 0 ; i < num ; i ++ ) system . out . print ( arr [ i ] + " " ) ; }
te	3	@ override public list < item > readcsvfile ( string filename ) { try { bufferedreader br = new bufferedreader ( new filereader ( filename ) ) ; string line = br . readline ( ) ; while ( line != null && line . length ( ) != 0 ) { string [ ] itemarray = line . split ( "<litcomma>" ) ; items . add ( new item ( itemarray [ 0 ] , double . valueof ( itemarray [ 1 ] ) , itemarray [ 2 ] ) ) ; line = br . readline ( ) ; } br . close ( ) ; } catch ( exception e2 ) { e2 . printstacktrace ( ) ; } collections . sort ( items , p . gettransactionvaluecomparator ( ) ) ; return items ; }
te	2	private void inspectfieldclasses ( object obj , class objclass , vector objectstoinspect , boolean recursive ) { if ( objectstoinspect . size ( ) > 0 ) system . out . println ( "---- inspecting field classes ----" ) ; enumeration e = objectstoinspect . elements ( ) ; while ( e . hasmoreelements ( ) ) { field f = ( field ) e . nextelement ( ) ; try { if ( f . get ( obj ) == null ) { system . out . println ( "\\t" + f . getname ( ) + " cannot be inspected<litcomma> because object is null." ) ; } else { system . out . println ( "inspecting field: " + f . getname ( ) ) ; try { system . out . println ( "******************" ) ; inspect ( f . get ( obj ) , recursive ) ; system . out . println ( "******************" ) ; } catch ( exception exp ) { exp . printstacktrace ( ) ; } } } catch ( illegalaccessexception ex ) { system . out . println ( e ) ; return ; } } }
te	2	public void take ( command command ) { if ( ! command . hassecondword ( ) ) { system . out . println ( "take what?" ) ; return ; } string id = command . getsecondword ( ) ; item item = currentroom . getitem ( id ) ; if ( item != null ) { if ( item . canbetaken ( ) ) { if ( item . getweight ( ) + gettotalweightitems ( ) <= cargamaxima ) { system . out . println ( "you add a new item to your bag" ) ; mochila . add ( item ) ; currentroom . removeitem ( id ) ; } else { system . out . println ( "no hay espacio para este objeto" ) ; } } else { system . out . println ( "el objeto no se puede coger" ) ; } } else { system . out . println ( "you don't select a item" ) ; } }
te	5	public index ( table t , string ... names ) { int irow = - 1 ; for ( row row : t . rows ) { ++ irow ; key key = new key ( ) ; for ( string name : names ) { try { key . add ( row . get ( name ) ) ; } catch ( exception e ) { system . out . println ( row ) ; } } if ( this . index . containskey ( key ) ) { this . index . get ( key ) . add ( irow ) ; } else { list < integer > list = new arraylist < integer > ( ) ; list . add ( irow ) ; this . index . put ( key , list ) ; } } this . names = names ; this . table = t ; }
te	5	private gridpane drawcenterfield ( ) { gridpane grid = new gridpane ( ) ; grid . setgridlinesvisible ( true ) ; grid . setpadding ( new insets ( 5 ) ) ; grid . sethgap ( 5 ) ; grid . setvgap ( 5 ) ; grid . setpadding ( new insets ( 5 ) ) ; rowconstraints rowscore = new rowconstraints ( ) ; rowscore . setvgrow ( priority . never ) ; rowscore . setvalignment ( vpos . center ) ; rowconstraints rowgamefield = new rowconstraints ( ) ; rowgamefield . setvgrow ( priority . always ) ; rowgamefield . setvalignment ( vpos . top ) ; rowconstraints rowstatus = new rowconstraints ( ) ; rowstatus . setvgrow ( priority . never ) ; rowstatus . setvalignment ( vpos . center ) ; grid . getrowconstraints ( ) . addall ( rowscore , rowgamefield , rowstatus ) ; columnconstraints column = new columnconstraints ( 200 , 200 , double . max_value , priority . always , hpos . center , true ) ; grid . getcolumnconstraints ( ) . add ( column ) ; grid . add ( labelscore , 0 , 0 ) ; grid . add ( labelstatus , 0 , 2 ) ; drawgamefield ( ) ; grid . add ( gamefield , 0 , 1 ) ; return grid ; }
te	2	private void setprimes ( int seed ) { p1s = new int [ octaves ] ; p2s = new int [ octaves ] ; p3s = new int [ octaves ] ; for ( int i = 0 ; i < octaves ; ++ i ) { random ran = new random ( i + seed ) ; p1s [ i ] = biginteger . probableprime ( 23 , ran ) . intvalue ( ) ; p2s [ i ] = biginteger . probableprime ( 24 , ran ) . intvalue ( ) ; p3s [ i ] = biginteger . probableprime ( 25 , ran ) . intvalue ( ) ; } }
te	3	private void addstat ( int numersamolotu ) { int [ ] stats = statsmap . get ( numersamolotu ) ; n_specjalnych += stats [ 6 ] ; if ( stats [ 4 ] > 0 ) { n_malo_paliwa ++ ; } if ( stats [ 0 ] > 0 ) { n_startujacych ++ ; } if ( stats [ 1 ] > 0 ) { n_ladujacych ++ ; } if ( stats [ 3 ] > 0 ) { n_wyladowalo ++ ; } int opoznienie_startu = stats [ 2 ] - stats [ 0 ] - params . czas_startu + 2 ; if ( opoznienie_startu > 0 && opoznienie_startu < min_opoznienie_startu ) { min_opoznienie_startu = opoznienie_startu ; } if ( opoznienie_startu > max_opoznienie_startu ) { max_opoznienie_startu = opoznienie_startu ; } sr_opoznienie_startu += opoznienie_startu ; if ( stats [ 3 ] > 0 ) { int opoznienie_ladowania = stats [ 3 ] - stats [ 1 ] - params . czas_ladowania + 2 ; sr_opoznienie_ladowania += opoznienie_ladowania ; if ( opoznienie_ladowania > 0 && opoznienie_ladowania < min_opoznienie_ladowania ) { min_opoznienie_ladowania = opoznienie_ladowania ; } if ( opoznienie_ladowania > max_opoznienie_ladowania ) { max_opoznienie_ladowania = opoznienie_ladowania ; } } statsmap . remove ( numersamolotu ) ; }
te	3	@ override public void run ( ) { try { system . out . println ( new date ( ) + " starting lookup for join" ) ; imyfd contact = ( imyfd ) naming . lookup ( "rmi://" + connectionuri + "/" + servicename ) ; system . out . println ( new date ( ) + " node found: " + connectionuri ) ; system . out . println ( new date ( ) + " contacting node " + connectionuri ) ; joinresponse response = contact . joinrequest ( fd . getme ( ) ) ; contact = null ; node contactnode = new node ( ) ; contactnode . setservicename ( servicename ) ; contactnode . setip ( connectionuri . split ( ":" ) [ 0 ] ) ; contactnode . setport ( integer . parseint ( connectionuri . split ( ":" ) [ 1 ] ) ) ; synchronized ( fd ) { fd . setfirst ( response . getfirst ( ) ) ; fd . setsecond ( response . getsecond ( ) ) ; fd . setthird ( response . getthird ( ) ) ; fd . setpulse ( contactnode ) ; fd . setpulsecontact ( null ) ; } fd . printstatus ( ) ; } catch ( notboundexception e ) { system . out . println ( new date ( ) + " node was not found in registry" ) ; system . exit ( 0 ) ; } catch ( java . net . malformedurlexception e ) { system . out . println ( new date ( ) + " url error: " + e ) ; system . exit ( 0 ) ; } catch ( remoteexception e ) { system . out . println ( new date ( ) + " time error: " + e ) ; system . exit ( 0 ) ; } }
te	8	@ override public branchgroup draw ( ) { branchgroup bg = new branchgroup ( ) ; bg . setcapability ( branchgroup . allow_children_extend ) ; bg . setcapability ( branchgroup . allow_children_write ) ; bg . setcapability ( branchgroup . allow_children_read ) ; bg . setcapability ( branchgroup . allow_detach ) ; if ( ebenenliste . size ( ) == 0 ) { for ( int x = 0 ; x < ( gatter . length - 1 ) ; ++ x ) { for ( int y = 0 ; y < ( gatter [ x ] . length - 1 ) ; ++ y ) { point3d p1 = new point3d ( gatter [ x + 1 ] [ y ] [ 0 ] , gatter [ x + 1 ] [ y ] [ 2 ] , gatter [ x + 1 ] [ y ] [ 1 ] ) ; point3d p2 = new point3d ( gatter [ x ] [ y ] [ 0 ] , gatter [ x ] [ y ] [ 2 ] , gatter [ x ] [ y ] [ 1 ] ) ; point3d p3 = new point3d ( gatter [ x ] [ y + 1 ] [ 0 ] , gatter [ x ] [ y + 1 ] [ 2 ] , gatter [ x ] [ y + 1 ] [ 1 ] ) ; point3d p4 = new point3d ( gatter [ x + 1 ] [ y + 1 ] [ 0 ] , gatter [ x + 1 ] [ y + 1 ] [ 2 ] , gatter [ x + 1 ] [ y + 1 ] [ 1 ] ) ; ebene e = new ebene ( p1 , p2 , p3 , p4 , this ) ; e . zeichnesteigung = zeichnesteigung ; ebenenliste . add ( e ) ; } } } for ( ebene e : ebenenliste ) { bg . addchild ( e . draw ( ) ) ; } return bg ; }
te	4	public arraylist < arraylist < integer > > combinationsum ( int [ ] candidates , int target ) { arraylist < arraylist < integer > > results = new arraylist < arraylist < integer > > ( ) ; for ( int i = 0 ; i < candidates . length ; i ++ ) { } hashset < string > unique = new hashset < string > ( ) ; for ( int i = results . size ( ) - 1 ; i >= 0 ; i -- ) { string converted = results . get ( i ) . tostring ( ) ; if ( unique . contains ( converted ) ) { results . remove ( i ) ; } else { unique . add ( converted ) ; } } return results ; }
te	7	public static void main ( string args [ ] ) { cashbox pcashbox = new cashbox ( ) ; selector pselector = new selector ( ) ; int drink ; int money ; int sugar ; string choice ; scanner in = new scanner ( system . in ) ; system . out . println ( "insert coins: " ) ; money = in . nextint ( ) ; if ( money != 0 ) { pcashbox . deposit ( money ) ; } system . out . println ( "\\tselect drinks: " ) ; system . out . println ( "\\tenter 1 if you want black coffee." ) ; system . out . println ( "\\tenter 2 if you want coffee with creamer." ) ; system . out . println ( "\\tenter 3 if you want a bouillon." ) ; drink = in . nextint ( ) ; if ( drink == 1 ) { system . out . println ( "\\tdo you want to add? sugar?" ) ; system . out . println ( "\\tenter 1 if you want to add sugar." ) ; system . out . println ( "\\tenter 2 if you dont want to add sugar." ) ; sugar = in . nextint ( ) ; if ( sugar == 1 ) { choice = "black coffee with sugar" ; pselector . select ( choice , pcashbox ) ; } else if ( sugar == 2 ) { choice = "black coffee no sugar" ; pselector . select ( choice , pcashbox ) ; } } else if ( drink == 2 ) { system . out . println ( "\\tdo you want to add? sugar?" ) ; system . out . println ( "\\tenter 1 if you want to add sugar." ) ; system . out . println ( "\\tenter 2 if you dont want to add sugar." ) ; sugar = in . nextint ( ) ; if ( sugar == 1 ) { choice = "white coffee with sugar" ; pselector . select ( choice , pcashbox ) ; } else if ( sugar == 2 ) { choice = "white coffee no sugar" ; pselector . select ( choice , pcashbox ) ; } } else if ( drink == 3 ) { choice = "bouillon" ; pselector . select ( choice , pcashbox ) ; } }
te	3	private int utility ( state state ) { int val = 0 ; for ( int i = 0 ; i < boardsize ; i ++ ) val += state . field [ i ] [ i ] ; if ( val == boardsize && player == player . max || val == - boardsize && player == player . min ) return 1 ; if ( val == boardsize && player == player . min || val == - boardsize && player == player . max ) return - 1 ; val = 0 ; for ( int i = 0 ; i < boardsize ; i ++ ) val += state . field [ i ] [ boardsize - i - 1 ] ; if ( val == boardsize && player == player . max || val == - boardsize && player == player . min ) return 1 ; if ( val == boardsize && player == player . min || val == - boardsize && player == player . max ) return - 1 ; for ( int i = 0 ; i < boardsize ; i ++ ) { val = 0 ; for ( int j = 0 ; j < boardsize ; j ++ ) val += state . field [ i ] [ j ] ; if ( val == boardsize && player == player . max || val == - boardsize && player == player . min ) return 1 ; if ( val == boardsize && player == player . min || val == - boardsize && player == player . max ) return - 1 ; } for ( int j = 0 ; j < boardsize ; j ++ ) { val = 0 ; for ( int i = 0 ; i < boardsize ; i ++ ) val += state . field [ i ] [ j ] ; if ( val == boardsize && player == player . max || val == - boardsize && player == player . min ) return 1 ; if ( val == boardsize && player == player . min || val == - boardsize && player == player . max ) return - 1 ; } return 0 ; }
te	10	public void start ( ) { try { for ( offlineplayer op : bukkit . getoperators ( ) ) { if ( op . isonline ( ) ) { op . getplayer ( ) . sendmessage ( chatcolor . light_purple + "[nations] initialized database syncing..." ) ; } } mysql mysql = new mysql ( plugin , "smudgecraft.net" , "3306" , "userdata" , "root" , "m1829cmc@" ) ; connection c = mysql . openconnection ( ) ; c . createstatement ( ) . execute ( "create table if not exists users(username char(30) not null<litcomma>" + "primary key(username)<litcomma>" + "maxhealth int<litcomma>" + "nation char(20)<litcomma>" + "nationlevel int<litcomma>" + "primaryclass char(20)<litcomma>" + "primaryclasslevel int<litcomma>" + "secondaryclass char(20)<litcomma>" + "secondaryclasslevel int)" ) ; for ( player p : bukkit . getonlineplayers ( ) ) { hero hero = plugin . getheroes ( ) . getcharactermanager ( ) . gethero ( p ) ; nationplayer nationplayer = nationmanager . getnationplayer ( p ) ; if ( nationplayer == null ) return ; if ( nationplayer . getnation ( ) == null ) return ; string primaryclass = hero . getheroclass ( ) . getname ( ) ; int primaryclasslevel = hero . getlevel ( hero . getheroclass ( ) ) ; string secondaryclass = "none" ; int secondaryclasslevel = 0 ; if ( hero . getsecondclass ( ) != null && hero . getsecondclass ( ) . getname ( ) != null ) { secondaryclass = hero . getsecondclass ( ) . getname ( ) ; secondaryclasslevel = hero . getlevel ( hero . getsecondclass ( ) ) ; } c . createstatement ( ) . execute ( "insert into users (username<litcomma> maxhealth<litcomma> nation<litcomma> nationlevel<litcomma> primaryclass<litcomma> primaryclasslevel<litcomma> secondaryclass<litcomma> secondaryclasslevel)" + " values (" + "'" + p . getname ( ) + "'" + "<litcomma> " + ( ( damageable ) p ) . getmaxhealth ( ) + "<litcomma> '" + nationplayer . getnation ( ) . getname ( ) + "" + "'<litcomma> " + nationplayer . getlevel ( ) + "<litcomma> '" + primaryclass + "'<litcomma> " + primaryclasslevel + "<litcomma> " + "'" + secondaryclass + "'<litcomma> " + secondaryclasslevel + ") on " + "duplicate key update username=values(username)<litcomma> maxhealth=values(maxhealth)<litcomma> nation=values(nation)<litcomma> nationlevel=values(nationlevel)<litcomma> " + "primaryclass=values(primaryclass)<litcomma> primaryclasslevel=values(primaryclasslevel)<litcomma> secondaryclass=values(secondaryclass)<litcomma> " + "secondaryclasslevel=values(secondaryclasslevel)" ) ; } } catch ( exception e ) { e . printstacktrace ( ) ; this . kill ( ) ; } for ( offlineplayer op : bukkit . getoperators ( ) ) { if ( op . isonline ( ) ) { op . getplayer ( ) . sendmessage ( chatcolor . light_purple + "[nations] database synced!" ) ; } } this . kill ( ) ; }
te	8	public void parsedocument ( ) { element docele = doc . getdocumentelement ( ) ; nodelist nl = docele . getelementsbytagname ( "station" ) ; if ( nl != null && nl . getlength ( ) > 0 ) { for ( int i = 0 ; i < nl . getlength ( ) ; i ++ ) { element e1 = ( element ) nl . item ( i ) ; table t = getstation ( e1 ) ; stations . add ( t ) ; nodelist nl2 = e1 . getelementsbytagname ( "train" ) ; if ( nl2 != null && nl2 . getlength ( ) > 0 ) { for ( int j = 0 ; j < nl2 . getlength ( ) ; j ++ ) { element e2 = ( element ) nl2 . item ( j ) ; gettrain ( e2 ) ; t . addtrain ( d , c , dt , a ) ; } } } } }
te	6	private joint getjoint ( boolean right , finger finger , bone bone ) { int f = 0 , b = 0 ; string name = "" ; switch ( finger . type ( ) ) { case type_thumb : name = "thumb" ; f = 0 ; break ; case type_index : name = "index" ; f = 1 ; break ; case type_middle : name = "middle" ; f = 2 ; break ; case type_ring : name = "ring" ; f = 3 ; break ; case type_pinky : name = "pinky" ; f = 4 ; break ; } switch ( bone . type ( ) ) { case type_metacarpal : b = 0 ; break ; case type_proximal : b = 1 ; break ; case type_intermediate : b = 2 ; break ; case type_distal : b = 3 ; break ; } string bonepattern1 = "#finger_" + integer . tostring ( f ) + integer . tostring ( b - 1 ) ; string bonepattern2 = "#" + name + "-" + integer . tostring ( b - 1 ) ; if ( right ) { joint joint = ( joint ) forestright . get ( 0 ) . lookup ( bonepattern1 ) ; if ( joint == null ) { joint = ( joint ) forestright . get ( 0 ) . lookup ( bonepattern2 ) ; } return joint ; } joint joint = ( joint ) forestleft . get ( 0 ) . lookup ( bonepattern1 ) ; if ( joint == null ) { joint = ( joint ) forestleft . get ( 0 ) . lookup ( bonepattern2 ) ; } return joint ; }
te	4	public int numdecodings ( string s ) { if ( s . length ( ) == 0 ) return 0 ; int [ ] num = new int [ s . length ( ) ] ; if ( s . charat ( 0 ) > '0' ) num [ 0 ] = 1 ; else num [ 0 ] = 0 ; for ( int i = 1 ; i < s . length ( ) ; i ++ ) { int path1 = 0 , path2 = 0 ; if ( s . charat ( i ) > '0' ) path1 = num [ i - 1 ] ; if ( ( s . charat ( i ) <= '6' && s . charat ( i - 1 ) == '2' ) || s . charat ( i - 1 ) == '1' ) { if ( i == 1 ) path2 = 1 ; else path2 = num [ i - 2 ] ; } num [ i ] = path1 + path2 ; } return num [ s . length ( ) - 1 ] ; }
te	10	public static log read ( ) throws ioexception { loglineparser parser = new loglineparser ( ) ; string inputlogdir = settings . getsetting ( "inputlogdir" ) ; log log = new log ( ) ; if ( ! directoryexists ( inputlogdir ) ) { throw new filenotfoundexception ( "directory with files to merge not found." ) ; } arraylist < file > files = listfiles ( inputlogdir ) ; for ( int i = 0 ; i < files . size ( ) ; i ++ ) { int linenumber = 0 ; file f = files . get ( i ) ; bufferedreader br = files . newbufferedreader ( f . topath ( ) , standardcharsets . utf_8 ) ; for ( string line = null ; ( line = br . readline ( ) ) != null ; ) { logline l = null ; if ( line . length ( ) == 0 ) continue ; try { l = parser . parseline ( line , i , linenumber ) ; } catch ( dateformatexception dfe ) { system . out . println ( dfe . getmessage ( ) ) ; } if ( l != null ) { log . addlogline ( l ) ; } linenumber ++ ; } } return log ; }
te	3	public static color randomvibrantcolor ( ) { random r = new random ( ) ; color c ; int d = r . nextint ( 128 ) ; switch ( r . nextint ( 6 ) ) { case 0 : return new color ( 255 , 0 , d ) ; case 1 : return new color ( 0 , 255 , d ) ; case 2 : return new color ( 255 , d , 0 ) ; case 3 : return new color ( 0 , d , 255 ) ; case 4 : return new color ( d , 0 , 255 ) ; case 5 : return new color ( d , 255 , 0 ) ; default : throw new assertionerror ( ) ; } }
te	9	private void process ( httpservletrequest request , httpservletresponse response ) throws servletexception , ioexception { httpsession session = request . getsession ( ) ; healthinsertdao dao = new healthinsertdao ( ) ; string height = ( string ) session . getattribute ( "height" ) ; string weight = ( string ) session . getattribute ( "weight" ) ; string sleeptime = ( string ) session . getattribute ( "sleeptime" ) ; double minweight = double . valueof ( weight ) . doublevalue ( ) ; double minheight = double . valueof ( height ) . doublevalue ( ) ; double minsleeptime = double . valueof ( sleeptime ) . doublevalue ( ) ; dao . gethealthins ( minweight , minheight , minsleeptime ) ; requestdispatcher dipatcher = request . getrequestdispatcher ( "/web-inf/jsp/healthinsert/healthinsertresult.jsp" ) ; dipatcher . forward ( request , response ) ; }
te	10	private void parseroot ( string line ) { string number = line . split ( " " ) [ 1 ] ; roothprof root = new roothprof ( ) ; string [ ] tokens = line . split ( "<litcomma>" ) ; int equals = tokens [ 0 ] . indexof ( "=" ) ; string kind = tokens [ 0 ] . substring ( equals + 1 ) ; if ( kind . contains ( "jni global ref" ) || ( kind . contains ( "thread" ) && ! kind . contains ( "block" ) ) ) { string id = tokens [ 1 ] ; id = id . substring ( id . indexof ( "=" ) + 1 ) ; root . setid ( id ) ; string trace = tokens [ 2 ] ; trace = trace . substring ( trace . indexof ( "=" ) + 1 ) ; root . settrace ( trace ) ; root . setkind ( kind ) ; root . setnumber ( number ) ; } else if ( kind . contains ( "system class" ) ) { string name = tokens [ 1 ] ; name = name . substring ( name . indexof ( "=" ) + 1 ) ; root . setname ( name ) ; root . setkind ( kind ) ; root . setnumber ( number ) ; } else if ( kind . contains ( "java stack" ) ) { string thread = tokens [ 1 ] ; thread = thread . substring ( thread . indexof ( "=" ) + 1 ) ; root . setthread ( thread ) ; string frame = tokens [ 2 ] ; frame = frame . substring ( frame . indexof ( "=" ) + 1 ) ; root . setframe ( frame ) ; root . setkind ( kind ) ; root . setnumber ( number ) ; } else { root . setkind ( kind ) ; root . setnumber ( number ) ; } roots . add ( root ) ; }
te	4	public static void main ( string args [ ] ) { scanner scan = new scanner ( system . in ) ; system . out . println ( "enter the number: " ) ; int num = scan . nextint ( ) ; if ( num < 0 ) { system . out . println ( "number is negative. cannot decode...." ) ; return ; } int len = ( int ) math . log10 ( num ) + 1 ; int res = 0 ; res += decodeeachalpha ( num , len ) ; res += decodefrombeginning ( num , len ) ; res += decodefromend ( num , len ) ; system . out . println ( num + " can be encoded " + res + " number of ways." ) ; }
te	6	public void load_to_collections ( string filename , arraylist < solidwordpair > pairs , hashmap < string , solidwordpair > pairsmap ) throws exception { scan = new scanner ( new file ( filename ) ) ; while ( scan . hasnext ( ) ) { string str = scan . nextline ( ) ; string [ ] tokens = str . split ( "<litcomma>" ) ; string english = tokens [ 0 ] . trim ( ) ; string danish = tokens [ 1 ] . trim ( ) ; int prio = integer . parseint ( tokens [ 2 ] . trim ( ) ) ; solidwordpair solidpair = new solidwordpair ( english , danish , prio ) ; pairs . add ( solidpair ) ; pairsmap . put ( solidpair . getenglish ( ) , solidpair ) ; } }
te	8	int mindrives ( int [ ] used , int [ ] total ) throws exception { int len = used == null ? 0 : used . length ; integer [ ] forsortarray = new integer [ len ] ; int u , t , usum = 0 , tsum = 0 , i = 0 , num = 0 ; if ( len < 1 || len > 50 ) { throw new exception ( "used's length must between 1 and 50." ) ; } if ( total == null || total . length != len ) { throw new exception ( "total's length must equal to used's" ) ; } for ( ; i < len ; i ++ ) { u = used [ i ] ; t = total [ i ] ; forsortarray [ i ] = t ; if ( u < 1 || t < 1 || u > 1000 || t > 1000 ) { throw new exception ( "used's and total's item must between 1 and 1000" ) ; } if ( u > t ) { throw new exception ( "used's item must less or equal than total's item." ) ; } tsum += t ; usum += u ; } arrays . sort ( forsortarray , collections . reverseorder ( ) ) ; for ( i = 0 ; i < len ; i ++ ) { usum -= forsortarray [ i ] ; num ++ ; if ( usum <= 0 ) break ; } return num ; }
te	1	public void setpieceicon ( int row , int col , int piece ) { system . out . println ( "changing icon: " ) ; jbutton tochange = board [ row ] [ col ] ; if ( piece == - 1 ) { tochange . settext ( "" ) ; tochange . seticon ( x ) ; tochange . invalidate ( ) ; super . invalidate ( ) ; } else { tochange . settext ( "" ) ; tochange . seticon ( o ) ; tochange . invalidate ( ) ; super . invalidate ( ) ; } super . validate ( ) ; super . repaint ( ) ; }
te	6	public void run ( ) { logger . info ( "starting dispatcher thread" ) ; pointsmessages = new arraylist < pointsmessage > ( ) ; robotqueues = new hashmap < integer , messageproducer > ( ) ; activemqconnectionfactory connectionfactory = new activemqconnectionfactory ( "vm://localhost" ) ; try { connection connection = connectionfactory . createconnection ( ) ; connection . start ( ) ; session session = connection . createsession ( false , session . auto_acknowledge ) ; for ( trafficrobot robot : robots ) { final destination destination = session . createqueue ( trafficjammessagequeues . points_message_queue + robot . getrobotid ( ) ) ; messageproducer producer = session . createproducer ( destination ) ; producer . setdeliverymode ( deliverymode . persistent ) ; robotqueues . put ( robot . getrobotid ( ) , producer ) ; } dispatchmessages ( session ) ; session . close ( ) ; } catch ( jmsexception e ) { e . printstacktrace ( ) ; } }
te	7	public network [ ] fittest ( int numfittest , int [ ] inputs , int [ ] outputs ) { arraylist < network > gen = new arraylist < network > ( arrays . aslist ( generation ) ) ; network [ ] fittest = new network [ numfittest ] ; int num = 0 ; while ( num < fittest . length ) { network f = gen . get ( 0 ) ; int fn = gen . get ( 0 ) . fitness ( inputs , outputs ) ; for ( int i = 1 ; i < gen . size ( ) ; i ++ ) { int tempf = gen . get ( i ) . fitness ( inputs , outputs ) ; if ( tempf > fn ) { f = gen . get ( i ) ; fn = tempf ; } } fittest [ num ] = f ; num ++ ; gen . remove ( f ) ; } return fittest ; }
te	1	public void getstats ( ) { stringbuilder builder ; log ( "--------------------------------------------------" ) ; log ( "statystyka" ) ; n_ladujacych = params . liczba_samolotow_do_wygenerowania - n_startujacych ; sr_opoznienie_ladowania /= n_wyladowalo * 1.0 ; sr_opoznienie_startu /= n_startujacych * 1.0 ; log ( "--------------------------------------------------------------" ) ; log ( "liczba samolotow startujacych: " + n_startujacych ) ; log ( "liczba samolotow ladujacych: " + n_ladujacych ) ; log ( "liczba samolotow specjalnych: " + n_specjalnych ) ; log ( "liczba samolotow<litcomma> ktore zglosily malo paliwa: " + n_malo_paliwa ) ; log ( "liczba samolotow<litcomma> ktore odlecialy na inne lotnisko: " + ( n_ladujacych - n_wyladowalo ) ) ; log ( "liczba samolotow<litcomma> ktore wyladowaly: " + n_wyladowalo ) ; log ( "min opoznienie startu: " + min_opoznienie_startu ) ; log ( "max opoznienie startu: " + max_opoznienie_startu ) ; log ( "srednie opoznienie startu: " + sr_opoznienie_startu ) ; log ( "min opoznienie ladowania: " + min_opoznienie_ladowania ) ; log ( "max opoznienie ladowania: " + max_opoznienie_ladowania ) ; log ( "srednie opoznienie ladowania: " + sr_opoznienie_ladowania ) ; log ( "--------------------------------------------------------------" ) ; }
te	1	public void join ( node nodetojointo , string servicename ) { system . out . println ( "i'm the only one in the network." ) ; fingertableentry fte = new fingertableentry ( ) ; fte . setnode ( me ) ; fte . setstart ( calculatestart ( me , 0 ) ) ; fingertable . setsuccessor ( fte ) ; me . setpredecessor ( null ) ; if ( nodetojointo != null ) { system . out . println ( "joining node " + nodetojointo . getchordidentifier ( ) ) ; initfingertable ( nodetojointo , servicename ) ; updateothers ( servicename ) ; } system . out . println ( "join finished" ) ; }
te	8	public analizeresult analyze ( ) { logger . info ( "analizing... " ) ; integer negative = new integer ( 0 ) ; integer positive = new integer ( 0 ) ; for ( map . entry < string , integer > entry : dicionary . entryset ( ) ) { string wordkey = entry . getkey ( ) ; integer weightvalue = entry . getvalue ( ) ; for ( string document : documents ) { document = document . replaceall ( "[.]" , "" ) ; document = document . replaceall ( "[<litcomma>]" , "" ) ; string [ ] words = document . split ( "\\\\s+" ) ; for ( string word : words ) { if ( word . equalsignorecase ( wordkey ) ) { if ( weightvalue > 0 ) { positive += weightvalue ; } else { negative += weightvalue ; } } } } } return new analizeresult ( term , negative , positive ) ; }
te	8	public void decode ( bytebuffer buffer , int stride , format fmt ) throws ioexception { final int offset = buffer . position ( ) ; final int linesize = ( ( width * bitdepth + 7 ) / 8 ) * bytesperpixel ; byte [ ] curline = new byte [ linesize + 1 ] ; byte [ ] prevline = new byte [ linesize + 1 ] ; byte [ ] palline = ( bitdepth < 8 ) ? new byte [ width + 1 ] : null ; final inflater inflater = new inflater ( ) ; try { for ( int y = 0 ; y < height ; y ++ ) { readchunkunzip ( inflater , curline , 0 , curline . length ) ; unfilter ( curline , prevline ) ; buffer . position ( offset + y * stride ) ; switch ( colortype ) { case color_truecolor : switch ( fmt ) { case abgr : copyrgbtoabgr ( buffer , curline ) ; break ; case rgba : copyrgbtorgba ( buffer , curline ) ; break ; case bgra : copyrgbtobgra ( buffer , curline ) ; break ; case rgb : copy ( buffer , curline ) ; break ; default : throw new unsupportedoperationexception ( "unsupported format for this image" ) ; } break ; case color_truealpha : switch ( fmt ) { case abgr : copyrgbatoabgr ( buffer , curline ) ; break ; case rgba : copy ( buffer , curline ) ; break ; case bgra : copyrgbatobgra ( buffer , curline ) ; break ; case rgb : copyrgbatorgb ( buffer , curline ) ; break ; default : throw new unsupportedoperationexception ( "unsupported format for this image" ) ; } break ; case color_greyscale : switch ( fmt ) { case luminance : case alpha : copy ( buffer , curline ) ; break ; default : throw new unsupportedoperationexception ( "unsupported format for this image" ) ; } break ; case color_greyalpha : switch ( fmt ) { case luminance_alpha : copy ( buffer , curline ) ; break ; default : throw new unsupportedoperationexception ( "unsupported format for this image" ) ; } break ; case color_indexed : switch ( bitdepth ) { case 8 : palline = curline ; break ; case 4 : expand4 ( curline , palline ) ; break ; case 2 : expand2 ( curline , palline ) ; break ; case 1 : expand1 ( curline , palline ) ; break ; default : throw new unsupportedoperationexception ( "unsupported bitdepth for this image" ) ; } switch ( fmt ) { case abgr : copypaltoabgr ( buffer , palline ) ; break ; case rgba : copypaltorgba ( buffer , palline ) ; break ; case bgra : copypaltobgra ( buffer , palline ) ; break ; default : throw new unsupportedoperationexception ( "unsupported format for this image" ) ; } break ; default : throw new unsupportedoperationexception ( "not yet implemented" ) ; } byte [ ] tmp = curline ; curline = prevline ; prevline = tmp ; } } finally { inflater . end ( ) ; } }
te	7	public string multiply ( string num1 , string num2 ) { num1 = new stringbuffer ( num1 ) . reverse ( ) . tostring ( ) ; num2 = new stringbuffer ( num2 ) . reverse ( ) . tostring ( ) ; int [ ] d = new int [ num1 . length ( ) + num2 . length ( ) ] ; for ( int i = 0 ; i < num1 . length ( ) ; i ++ ) { int d1 = num1 . charat ( i ) - '0' ; for ( int j = 0 ; j < num2 . length ( ) ; j ++ ) { int d2 = num2 . charat ( j ) - '0' ; d [ i + j ] += d1 * d2 ; } } stringbuffer sb = new stringbuffer ( ) ; for ( int i = 0 ; i < d . length ; i ++ ) { int carry = d [ i ] / 10 ; sb . append ( d [ i ] % 10 ) ; if ( i < d . length - 1 ) { d [ i + 1 ] += carry ; } } sb = sb . reverse ( ) ; while ( sb . length ( ) > 1 && sb . charat ( 0 ) == '0' ) { sb . deletecharat ( 0 ) ; } return sb . tostring ( ) ; }
te	5	private static vector < color > getkeycolors ( vector < color > src , int cnt , int threshold ) { vector < color > groups = new vector < color > ( ) ; groups . add ( src . get ( 0 ) ) ; boolean add ; for ( int i = 0 ; i < src . size ( ) ; i ++ ) { color c = src . get ( i ) ; add = true ; for ( color col : groups ) { if ( getdist ( c , col ) < threshold ) { add = false ; break ; } } if ( add ) { groups . add ( c ) ; } } while ( groups . size ( ) > cnt ) { groups = getkeycolors ( src , cnt , threshold + ( int ) ( 200 * ( ( groups . size ( ) - cnt ) * ( groups . size ( ) - cnt ) * 0.04 ) ) ) ; } while ( groups . size ( ) < cnt ) { groups = getkeycolors ( src , cnt , threshold - ( int ) ( 200 * ( ( groups . size ( ) - cnt ) * ( groups . size ( ) - cnt ) * 0.04 ) ) ) ; } return groups ; }
te	5	public static list < string > procesar ( string patharchivo ) throws exception { list < string > resultado = new linkedlist < string > ( ) ; try { reader reader = new filereader ( patharchivo ) ; bufferedreader br = new bufferedreader ( reader ) ; string s = null ; int i = 1 ; while ( ( s = br . readline ( ) ) != null ) { if ( i ++ % 2 == 0 ) { resultado . add ( s . tolowercase ( ) ) ; } else { resultado . add ( s . touppercase ( ) ) ; } } br . close ( ) ; } catch ( ioexception ex ) { throw new exception ( "error al leer el archivo" ) ; } return resultado ; }
te	2	public static int [ ] getsurroundingtiles ( int x , int y ) { int [ ] surrounding = new int [ 4 ] ; try { surrounding [ 0 ] = surroundingtile ( x , y - 1 ) ; } catch ( arrayindexoutofboundsexception | nullpointerexception ex ) { surrounding [ 0 ] = - 1 ; } try { surrounding [ 1 ] = surroundingtile ( x - 1 , y ) ; } catch ( arrayindexoutofboundsexception | nullpointerexception ex ) { surrounding [ 1 ] = - 1 ; } try { surrounding [ 2 ] = surroundingtile ( x + 1 , y ) ; } catch ( arrayindexoutofboundsexception | nullpointerexception ex ) { surrounding [ 2 ] = - 1 ; } try { surrounding [ 3 ] = surroundingtile ( x , y + 1 ) ; } catch ( arrayindexoutofboundsexception | nullpointerexception ex ) { surrounding [ 3 ] = - 1 ; } for ( int i : surrounding ) { system . out . println ( i ) ; } return surrounding ; }
te	10	private vertex3f morph ( double reductioncoefficient , vertex3f original ) { vertex3f point = new vertex3f ( 0 , 0 , 0 ) ; int index = 3 ; double dist , anglebase ; double xind , yind , zind ; double xind2 , yind2 , zind2 ; if ( original . gety ( ) < yoffset ) { index = 0 ; } else if ( original . gety ( ) < yoffset + leglengths [ 0 ] ) { index = 1 ; } else if ( original . gety ( ) < yoffset + leglengths [ 0 ] + leglengths [ 1 ] ) { index = 2 ; } if ( index == 0 ) return reduced ( point , reductioncoefficient ) ; if ( index == 1 ) { dist = math . sqrt ( math . pow ( original . y - yoffset , 2 ) + math . pow ( original . x , 2 ) ) ; anglebase = math . asin ( original . x / dist ) ; point . z = original . z ; } else { dist = leglengths [ 0 ] ; anglebase = 0 ; point . z = 0 ; } point . x += dist * math . sin ( anglebase + anglesrad [ 0 ] ) ; point . y += dist * math . cos ( anglebase + anglesrad [ 0 ] ) ; if ( index == 1 ) return reduced ( point , reductioncoefficient ) ; if ( index == 2 ) { dist = math . sqrt ( math . pow ( original . y - yoffset - leglengths [ 0 ] , 2 ) + math . pow ( original . z , 2 ) ) ; anglebase = math . asin ( original . z / dist ) ; xind = original . x ; } else { dist = leglengths [ 1 ] ; anglebase = 0 ; xind = 0 ; } yind = dist * math . cos ( anglebase + anglesrad [ 1 ] ) ; zind = dist * math . sin ( anglebase + anglesrad [ 1 ] ) ; point . x += xind * math . cos ( anglesrad [ 0 ] ) + yind * math . sin ( anglesrad [ 0 ] ) ; point . y += yind * math . cos ( anglesrad [ 0 ] ) - xind * math . sin ( anglesrad [ 0 ] ) ; point . z += zind ; if ( index == 2 ) return reduced ( point , reductioncoefficient ) ; dist = math . sqrt ( math . pow ( original . y - yoffset - leglengths [ 0 ] - leglengths [ 1 ] , 2 ) + math . pow ( original . z , 2 ) ) ; anglebase = math . asin ( original . z / dist ) ; xind = original . x ; yind = dist * math . cos ( anglebase + anglesrad [ 2 ] ) ; zind = dist * math . sin ( anglebase + anglesrad [ 2 ] ) ; xind2 = xind ; yind2 = yind * math . cos ( anglesrad [ 1 ] ) - zind * math . sin ( anglesrad [ 1 ] ) ; zind2 = zind * math . cos ( anglesrad [ 1 ] ) + yind * math . sin ( anglesrad [ 1 ] ) ; point . x += xind2 * math . cos ( anglesrad [ 0 ] ) + yind2 * math . sin ( anglesrad [ 0 ] ) ; point . y += yind2 * math . cos ( anglesrad [ 0 ] ) - xind2 * math . sin ( anglesrad [ 0 ] ) ; point . z += zind2 ; return reduced ( point , reductioncoefficient ) ; }
te	9	public arraylist < ostoslista > lisaatietojatietokantaan ( ) throws filenotfoundexception , ioexception { jfilechooser jfc = new jfilechooser ( ) ; arraylist < ostoslista > paluulista = new arraylist < > ( ) ; int valinta = jfc . showopendialog ( this ) ; if ( valinta == jfilechooser . approve_option ) { file f = jfc . getselectedfile ( ) ; bufferedreader br = new bufferedreader ( new filereader ( f ) ) ; while ( br . ready ( ) ) { string line = br . readline ( ) ; string [ ] arr = line . split ( "<litcomma>" ) ; arraylist l = new arraylist ( arrays . aslist ( arr ) ) ; ostoslista o = new ostoslista ( l ) ; paluulista . add ( o ) ; } } return paluulista ; }
te	7	private static properties extractproperties ( string url ) { properties properties = new properties ( ) ; int p1 = url . indexof ( "://" ) + 3 ; if ( p1 > 0 ) { int p3 = url . indexof ( '?' , p1 ) ; if ( p3 > 0 ) { string nvstring = url . substring ( p3 + 1 ) ; string [ ] namevalues = nvstring . split ( "&" ) ; for ( string namevalue : namevalues ) { string [ ] nv = namevalue . split ( "=" ) ; if ( nv . length == 2 ) properties . put ( nv [ 0 ] , nv [ 1 ] ) ; } } } return properties ; }
te	9	@ suppresswarnings ( "unchecked" ) public void init ( string name ) throws exception { filereader r = new filereader ( new file ( this . getclass ( ) . getresource ( name ) . getfile ( ) ) ) ; jsonparser parser = new jsonparser ( r ) ; hashmap top = ( hashmap ) objectbuilder . getval ( parser ) ; hashmap partitions = ( hashmap ) top . get ( "partitions" ) ; iterator iter = partitions . keyset ( ) . iterator ( ) ; while ( iter . hasnext ( ) ) { string partitionname = ( string ) iter . next ( ) ; hashmap partition = ( hashmap ) partitions . get ( partitionname ) ; string dn = ( string ) partition . get ( "dn" ) ; hashmap attributes = ( hashmap ) partition . get ( "attributes" ) ; checkpartition ( partitionname , dn , attributes ) ; } }
te	6	public static void writefiletosd ( string filename , string content ) { try { string pathname = config . file_path ; file path = new file ( pathname ) ; file file = new file ( pathname + filename ) ; if ( ! path . exists ( ) ) { path . mkdir ( ) ; } if ( ! file . exists ( ) ) { file . createnewfile ( ) ; } fileoutputstream stream = new fileoutputstream ( file ) ; string s = content ; byte [ ] buf = s . getbytes ( ) ; stream . write ( buf ) ; stream . close ( ) ; } catch ( exception e ) { system . out . println ( "error + " + e . tostring ( ) ) ; } }
te	1	public void process ( ) { parser . events event = parser . events . ev_tag ; try { outxmlfd . write ( "<mediawiki>" ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } while ( parser . events . ev_none != event ) { event = this . p . parse ( ) ; switch ( event ) { case ev_none : break ; case ev_tag : this . starttag ( ) ; break ; case ev_text_char : this . chars ( ) ; break ; case ev_end_tag : this . stoptag ( ) ; break ; case ev_tag_no_end : break ; } } try { this . outxmlfd . write ( "</mediawiki>" ) ; outxmlfd . close ( ) ; outtxtfd . close ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } }
te	2	@ override public void run ( ) { try { int firstpoint = 1 ; int lastpoint = 0 ; while ( true ) { if ( ! monitor . flag ) { while ( ! readscreen . targetpresence ( ) & ! monitor . flag ) { select . nextfoe ( ) ; if ( readscreen . targetpresence ( ) ) { break ; } movement . turnleft ( 300 , 200 ) ; if ( ui . decision . equals ( "y" ) ) { monitor . iterator ++ ; if ( monitor . iterator > 10 ) { break ; } } else { } } if ( ui . decision . equals ( "y" ) ) { if ( monitor . iterator >= 10 & firstpoint == 1 ) { checkminimap . go ( ui . firstdirection , ui . steps * 1000 ) ; lastpoint = 1 ; firstpoint = 0 ; monitor . iterator = 0 ; } else if ( monitor . iterator >= 10 & lastpoint == 1 ) { checkminimap . go ( ui . seconddirection , ui . steps * 1000 ) ; lastpoint = 0 ; firstpoint = 1 ; monitor . iterator = 0 ; } } if ( monitor . flag ) { synchronized ( monitor . setstate ) { monitor . setstate . wait ( ) ; } } fightlogic . preparing ( readscreen . getrole ( ) ) ; fightlogic . skillrotation ( readscreen . getrole ( ) ) ; } else { synchronized ( monitor . setstate ) { monitor . setstate . wait ( ) ; } } } } catch ( throwable t ) { t . printstacktrace ( ) ; } }
te	7	@ override public collection < ball > rolls ( collection < ball > balls , collider < ball > ... colliders ) { linkedlist < ball > remain = new linkedlist < ball > ( balls ) ; boolean collisionoccurred ; do { collisionoccurred = false ; linkedlist < ball > merged = new linkedlist < ball > ( ) ; while ( ! remain . isempty ( ) ) { ball rollingball = remain . removefirst ( ) ; iterator < ball > iterator = remain . iterator ( ) ; while ( iterator . hasnext ( ) ) { ball ball = iterator . next ( ) ; for ( collider < ball > collider : colliders ) { if ( collider . arecolliding ( rollingball , ball ) ) { rollingball = collider . collide ( rollingball , ball ) ; iterator . remove ( ) ; collisionoccurred = true ; } else { continue ; } } } merged . add ( rollingball ) ; } remain = merged ; } while ( collisionoccurred ) ; return remain ; }
te	4	public static int decodefrombeginning ( int num , int len ) { stringbuilder sb = new stringbuilder ( ) ; int res , pow , topow ; while ( num != 0 ) { if ( len - 2 > 0 ) topow = len - 2 ; else if ( len - 1 > 0 ) topow = len - 1 ; else topow = 0 ; pow = ( int ) math . pow ( 10 , topow ) ; res = ( int ) num / pow ; if ( res < 26 ) { num -= ( res * pow ) ; res -= 1 ; res += 97 ; sb . append ( ( char ) res ) ; if ( pow != 1 ) len -= 2 ; else len -= 1 ; } } system . out . println ( sb . tostring ( ) ) ; if ( sb . length ( ) > 0 ) return 1 ; else return 0 ; }
te	3	@ override public void run ( ) { allthesorters = ( arraylist < sorter > ) allthesorters . clone ( ) ; int numdone = 0 ; while ( numdone < allthesorters . size ( ) ) { numdone = 0 ; for ( sorter s : allthesorters ) { if ( ! s . nextstep ( ) ) { numdone ++ ; } } int speednum ; try { speednum = integer . parseint ( speed . gettext ( ) ) ; } catch ( numberformatexception e ) { speednum = 50 ; } try { repaint ( ) ; thread . sleep ( speednum ) ; } catch ( interruptedexception e ) { } } }
te	2	public arraylist < interval > insert ( arraylist < interval > intervals , interval newinterval ) { if ( intervals . size ( ) == 0 ) { intervals . add ( newinterval ) ; return intervals ; } boolean bmerged = false ; for ( int i = 0 ; i < intervals . size ( ) ; i ++ ) { if ( ! bmerged && intervals . get ( i ) . end < newinterval . start ) { if ( i == intervals . size ( ) - 1 ) intervals . add ( newinterval ) ; continue ; } if ( intervals . get ( i ) . start > newinterval . end ) { if ( ! bmerged ) intervals . add ( i , newinterval ) ; break ; } if ( bmerged ) { intervals . get ( i - 1 ) . end = math . max ( newinterval . end , intervals . get ( i ) . end ) ; intervals . remove ( i ) ; i -- ; } if ( ! bmerged && intervals . get ( i ) . end >= newinterval . start ) { intervals . get ( i ) . end = math . max ( newinterval . end , intervals . get ( i ) . end ) ; bmerged = true ; } if ( intervals . get ( i ) . start <= newinterval . end ) { intervals . get ( i ) . start = math . min ( newinterval . start , intervals . get ( i ) . start ) ; bmerged = true ; } } return intervals ; }
te	4	public < t > t get ( class < t > clazz ) { set < bean < ? > > beans = beanmanager . getbeans ( clazz ) ; if ( beans != null && beans . size ( ) > 0 ) { bean < t > bean = ( bean < t > ) beans . iterator ( ) . next ( ) ; creationalcontext < t > ctx = beanmanager . createcreationalcontext ( bean ) ; t o = clazz . cast ( beanmanager . getreference ( bean , clazz , ctx ) ) ; log . info ( "found and returning: " + clazz . getcanonicalname ( ) ) ; return o ; } return null ; }
te	4	public static void main ( string [ ] args ) { scanner scan = new scanner ( system . in ) ; system . out . println ( "enter number of nodes in the tree: " ) ; int num = scan . nextint ( ) ; trinarytree root = new trinarytree ( null ) ; if ( num <= 0 ) { system . out . println ( "no elements to enter in the tree" ) ; return ; } for ( int i = 0 ; i < num ; i ++ ) { root . node = inserttree ( scan . nextint ( ) , root . node ) ; } system . out . println ( "initial tree" ) ; printtree ( root . node ) ; system . out . println ( "\\nenter node to delete: " ) ; deletenode ( scan . nextint ( ) , root . node ) ; system . out . println ( "tree after deletion" ) ; printtree ( root . node ) ; }
te	7	protected void checkstraight ( list < card > cards ) { int [ ] anycard = new int [ 14 ] ; for ( int i = 0 ; i < 14 ; i ++ ) { anycard [ i ] = - 1 ; } for ( int i = 0 ; i < cards . size ( ) ; i ++ ) { int it = cards . get ( i ) . getcardvalue ( ) ; anycard [ it + 1 ] = i ; } anycard [ 0 ] = anycard [ 13 ] ; int cnt = 0 ; for ( int i = 0 ; i < 14 - 5 ; i ++ ) { int tmp_cnt = 0 ; int last_card = 0 ; for ( int j = i ; j < i + 5 ; j ++ ) { if ( anycard [ j ] != - 1 ) { tmp_cnt ++ ; last_card = j ; } } if ( tmp_cnt >= cnt && tmp_cnt != 0 ) { cnt = tmp_cnt ; missingcards [ 4 ] = 5 - tmp_cnt ; bestcard [ 4 ] = cards . get ( anycard [ last_card ] ) ; } } if ( cnt == 0 ) { missingcards [ 4 ] = 5 ; bestcard [ 4 ] = cards . get ( cards . size ( ) - 1 ) ; } }
te	1	@ requestmapping ( value = "/login" , method = requestmethod . get ) public modelandview login ( @ requestparam ( value = "error" , required = false ) string error , @ requestparam ( value = "logout" , required = false ) string logout , httpservletrequest request ) { modelandview model = new modelandview ( ) ; if ( error != null ) { model . addobject ( "error" , geterrormessage ( request , "spring_security_last_exception" ) ) ; } if ( logout != null ) { model . addobject ( "msg" , "you have been loggedout successfully." ) ; } model . setviewname ( "login" ) ; return model ; }
te	4	public int maxarea ( int [ ] height ) { if ( height . length <= 1 ) return 0 ; int left = 0 ; int right = height . length - 1 ; int max = 0 ; while ( left < right ) { int t = math . min ( height [ left ] , height [ right ] ) ; max = math . max ( max , t * ( right - left ) ) ; if ( height [ left ] <= height [ right ] ) left ++ ; else right -- ; } return max ; }
te	4	public void readmap ( string filename ) { try { file file = new file ( filename ) ; in = new scanner ( file ) ; width = in . nextint ( ) ; height = in . nextint ( ) ; for ( int i = 0 ; height > i ; i ++ ) { char [ ] line = in . nextline ( ) . tochararray ( ) ; for ( int j = 0 ; width > j ; j ++ ) { map [ j ] [ i ] = line [ j ] ; } } } catch ( filenotfoundexception e ) { e . printstacktrace ( ) ; } }
te	9	public static void main ( string [ ] args ) { connection conn = null ; statement stmt = null ; try { class . forname ( "oracle.jdbc.driver.oracledriver" ) ; conn = drivermanager . getconnection ( "jdbc:oracle:thin:@localhost:1521:orcl" , "scott" , "tiger" ) ; stmt = conn . createstatement ( ) ; system . out . println ( "please input 3 parameters:" ) ; scanner scan = new scanner ( system . in ) ; string str = scan . nextline ( ) ; string [ ] str_p = str . split ( " {1<litcomma>}" ) ; if ( str_p . length != 3 ) { system . out . println ( "the wrong pramameters<litcomma>please try again!" ) ; system . exit ( - 1 ) ; } int num = integer . valueof ( str_p [ 0 ] ) ; string dname = str_p [ 1 ] ; string loc = str_p [ 2 ] ; string sql = "insert into dept values (" + + num + "<litcomma>'" + dname + "'<litcomma>'" + loc + "')" ; system . out . println ( sql ) ; stmt . executeupdate ( sql ) ; } catch ( classnotfoundexception e ) { e . printstacktrace ( ) ; } catch ( sqlexception e ) { e . printstacktrace ( ) ; } try { if ( conn != null ) { conn . close ( ) ; conn = null ; } if ( stmt != null ) { stmt . close ( ) ; stmt = null ; } } catch ( sqlexception e ) { e . printstacktrace ( ) ; } }
te	3	@ test public void testrecombine ( ) { selector selector = mock ( selector . class ) ; when ( config . getselector ( ) ) . thenreturn ( selector ) ; list < list < individual > > parents = mockparents ( ) ; when ( selector . selectparents ( any ( population . class ) ) ) . thenreturn ( parents ) ; geneticoperator operator = mock ( geneticoperator . class ) ; when ( config . getrecombinationoperator ( ) ) . thenreturn ( operator ) ; when ( operator . operate ( anylist ( ) ) ) . thenreturn ( child1 , child2 , child3 , child4 ) ; ea . recombine ( ) ; assertthat ( ea . currentchildren , is ( children ) ) ; }
te	10	public void printdiagnostics ( ) { try { string outputfilename1 = folder + "diagnostics1.csv" ; filewriter writer1 = new filewriter ( outputfilename1 , true ) ; writer1 . write ( diag . printdiagnostics ( "diffs" ) ) ; writer1 . close ( ) ; } catch ( exception e ) { e . printstacktrace ( ) ; system . exit ( 1 ) ; } try { string outputfilename2 = folder + "diagnostics2.csv" ; filewriter writer2 = new filewriter ( outputfilename2 , true ) ; writer2 . write ( diag . printdiagnostics ( "actions" ) ) ; writer2 . close ( ) ; } catch ( exception e ) { e . printstacktrace ( ) ; system . exit ( 1 ) ; } try { string outputfilename3 = folder + "diagnostics3.csv" ; filewriter writer3 = new filewriter ( outputfilename3 , true ) ; writer3 . write ( diag . printdiagnostics ( "cancellations" ) ) ; writer3 . close ( ) ; } catch ( exception e ) { e . printstacktrace ( ) ; system . exit ( 1 ) ; } try { string outputfilename4 = folder + "diagnostics4.csv" ; filewriter writer4 = new filewriter ( outputfilename4 , true ) ; writer4 . write ( diag . printdiagnostics ( "difffvs" ) ) ; writer4 . close ( ) ; } catch ( exception e ) { e . printstacktrace ( ) ; system . exit ( 1 ) ; } try { string outputfilename5 = folder + "diagnostics5.csv" ; filewriter writer5 = new filewriter ( outputfilename5 , true ) ; writer5 . write ( diag . printdiagnostics ( "tickdiffs" ) ) ; writer5 . close ( ) ; } catch ( exception e ) { e . printstacktrace ( ) ; system . exit ( 1 ) ; } }
te	3	private void initcs ( boolean isconfirmed ) { int nof = 0 ; double rc = 0.0f ; if ( isconfirmed ) { nof = fc . listfiles ( ) . length ; rc = math . round ( ( 1.0f * nof ) / countallfile ( ) * 100.0 ) / 100.0 ; cate c = new cate ( initcon . confirmed , rc ) ; cs . add ( c ) ; } else { nof = fn . listfiles ( ) . length ; rc = math . round ( ( 1.0f * nof ) / countallfile ( ) * 100.0 ) / 100.0 ; cate c = new cate ( initcon . negative , rc ) ; cs . add ( c ) ; } }
te	10	private bufferedimage toolkitimage ( string urlstring ) { try { int [ ] rgb_masks = { 0xff0000 , 0xff00 , 0xff } ; colormodel rgb_opaque = new directcolormodel ( 32 , rgb_masks [ 0 ] , rgb_masks [ 1 ] , rgb_masks [ 2 ] ) ; url url = new url ( urlstring ) ; image img = toolkit . getdefaulttoolkit ( ) . createimage ( url ) ; pixelgrabber pg = new pixelgrabber ( img , 0 , 0 , - 1 , - 1 , true ) ; pg . grabpixels ( ) ; int width = pg . getwidth ( ) , height = pg . getheight ( ) ; if ( width == 0 || height == 0 ) { throw new ioexception ( "invalid height or width for image." ) ; } databuffer buffer = new databufferint ( ( int [ ] ) pg . getpixels ( ) , pg . getwidth ( ) * pg . getheight ( ) ) ; writableraster raster = raster . createpackedraster ( buffer , width , height , width , rgb_masks , null ) ; bufferedimage bi = new bufferedimage ( rgb_opaque , raster , false , null ) ; return bi ; } catch ( exception e ) { logger . warn ( "issues translating to toolkit image." , e ) ; } return null ; }
te	5	private long getchordid ( string ipandport ) { long chordid = 0 ; messagedigest md ; try { md = messagedigest . getinstance ( "sha-1" ) ; byte [ ] bla = md . digest ( ipandport . getbytes ( ) ) ; long number = bytebuffer . wrap ( bla ) . getlong ( ) ; long mod = ( long ) math . pow ( 2 , keysize ) ; chordid = number % mod ; if ( chordid < 0 ) { chordid += ( long ) math . pow ( 2 , keysize ) ; } } catch ( nosuchalgorithmexception e ) { e . printstacktrace ( ) ; } system . out . println ( "key calculated and set" ) ; return chordid ; }
te	3	public void crearpersona ( persona persona ) throws personaexception { connection cnn = null ; try { cnn = drivermanager . getconnection ( "jdbc:postgresql://127.0.0.1:5432/bdprueba" , "postgres" , "postgres" ) ; preparedstatement pstmt = cnn . preparestatement ( "select nombre from persona where documento = ?" ) ; pstmt . setint ( 1 , persona . getnumerodocumento ( ) ) ; resultset rs = pstmt . executequery ( ) ; if ( rs . next ( ) ) { throw new personaexception ( "la persona ya se encuentra registrada en la base de datos" ) ; } rs . close ( ) ; pstmt . close ( ) ; pstmt = cnn . preparestatement ( "insert into persona (documento<litcomma> nombre<litcomma> edad) values (?<litcomma> ?<litcomma> ?)" ) ; pstmt . setint ( 1 , persona . getnumerodocumento ( ) ) ; pstmt . setstring ( 2 , persona . getnombre ( ) ) ; pstmt . setint ( 3 , persona . getedad ( ) ) ; pstmt . executeupdate ( ) ; pstmt . close ( ) ; } catch ( sqlexception e ) { throw new personaexception ( "error de acceso a datos" ) ; } finally { try { cnn . close ( ) ; } catch ( sqlexception e ) { } } }
te	9	private arraylist < myedge > computeworstedgesforgroup ( arraylist < mynode > mates ) { arraylist < myedge > cuts = new arraylist < myedge > ( ) ; arraylist < myedge > candidatecuts = new arraylist < myedge > ( ) ; hashmap < mynode , integer > degrees = new hashmap < mynode , integer > ( ) ; for ( mynode n : mates ) { candidatecuts . addall ( this . outedges ( n ) ) ; degrees . put ( n , n . getdegree ( ) ) ; } collections . sort ( candidatecuts , new weightcomparator ( ) ) ; while ( ! gooddegree ( degrees ) ) { myedge e = candidatecuts . get ( 0 ) ; mynode s = e . getsource ( ) ; mynode t = e . gettarget ( ) ; int sd = degrees . get ( s ) ; int td = degrees . get ( s ) ; if ( sd > 2 || td > 2 ) { cuts . add ( e ) ; degrees . put ( t , td - 1 ) ; degrees . put ( s , sd - 1 ) ; } candidatecuts . remove ( e ) ; } return cuts ; }
te	10	public list < location > get_blocks ( ) { if ( blocks != null ) { return blocks ; } else { double lc1x = location1 . getx ( ) ; double lc1y = location1 . gety ( ) ; double lc1z = location1 . getz ( ) ; double lc2x = location2 . getx ( ) ; double lc2y = location2 . gety ( ) ; double lc2z = location2 . getz ( ) ; location h = null ; blocks = new linkedlist < location > ( ) ; if ( lc1x <= lc2x ) { for ( double x = lc1x ; x <= lc2x ; x ++ ) { if ( lc1y <= lc2y ) { for ( double y = lc1y ; y <= lc2y ; y ++ ) { if ( lc1z <= lc2z ) { for ( double z = lc1z ; z <= lc2z ; z ++ ) { h = new location ( this_world , x , y , z ) ; blocks . add ( h ) ; } } else { for ( double z = lc1z ; z >= lc2z ; z -- ) { h = new location ( this_world , x , y , z ) ; blocks . add ( h ) ; } } } } else { for ( double y = lc1y ; y >= lc2y ; y -- ) { if ( lc1z <= lc2z ) { for ( double z = lc1z ; z <= lc2z ; z ++ ) { h = new location ( this_world , x , y , z ) ; blocks . add ( h ) ; } } else { for ( double z = lc1z ; z >= lc2z ; z -- ) { h = new location ( this_world , x , y , z ) ; blocks . add ( h ) ; } } } } } } else { for ( double x = lc1x ; x >= lc2x ; x -- ) { if ( lc1y <= lc2y ) { for ( double y = lc1y ; y <= lc2y ; y ++ ) { if ( lc1z <= lc2z ) { for ( double z = lc1z ; z <= lc2z ; z ++ ) { h = new location ( this_world , x , y , z ) ; blocks . add ( h ) ; } } else { for ( double z = lc1z ; z >= lc2z ; z -- ) { h = new location ( this_world , x , y , z ) ; blocks . add ( h ) ; } } } } else { for ( double y = lc1y ; y >= lc2y ; y -- ) { if ( lc1z <= lc2z ) { for ( double z = lc1z ; z <= lc2z ; z ++ ) { h = new location ( this_world , x , y , z ) ; blocks . add ( h ) ; } } else { for ( double z = lc1z ; z >= lc2z ; z -- ) { h = new location ( this_world , x , y , z ) ; blocks . add ( h ) ; } } } } } } return blocks ; } }
te	4	public static void main ( string [ ] args ) { long num = 600851475143l ; long max = ( long ) math . sqrt ( num ) ; if ( max % 2 == 0 ) max -- ; for ( ; max > 0 ; max -= 2 ) if ( num % max == 0 ) { boolean p = true ; long s = ( long ) math . sqrt ( max ) ; if ( s % 2 == 0 ) s -- ; for ( ; s > 2 ; s -= 2 ) if ( max % s == 0 ) { p = false ; break ; } if ( p ) { system . out . println ( max ) ; system . exit ( 0 ) ; } } }
te	3	private void recenter ( ) { double cx = 0 ; double cy = 0 ; for ( int i = 0 ; i < ncircles ; i ++ ) { cx += centers [ i ] [ 0 ] ; cy += centers [ i ] [ 1 ] ; } cx = cx / ncircles ; cy = cy / ncircles ; for ( int i = 0 ; i < ncircles ; i ++ ) { centers [ i ] [ 0 ] = .5 + centers [ i ] [ 0 ] - cx ; centers [ i ] [ 1 ] = .5 + centers [ i ] [ 1 ] - cy ; } }
te	2	private void openbuttonframe ( ) { jframe buttonframe = new jframe ( ) ; buttonframe . setsize ( 300 , 100 ) ; buttonframe . setlocation ( 800 , 800 ) ; buttonframe . setdefaultcloseoperation ( do_nothing_on_close ) ; jpanel buttonpanel = new jpanel ( new flowlayout ( flowlayout . center ) ) ; addrowbutton = new jbutton ( "new entry" ) ; addrowbutton . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( final actionevent e ) { addnewtransaction ( ) ; serializer . savestate ( ) ; } } ) ; balancefield = new jtextfield ( 10 ) ; balancefield . settext ( "$0.00" ) ; balancefield . setenabled ( false ) ; savebutton = new jbutton ( "save" ) ; buttonpanel . add ( addrowbutton ) ; buttonpanel . add ( balancefield ) ; buttonpanel . add ( savebutton ) ; buttonframe . add ( buttonpanel ) ; buttonframe . setvisible ( true ) ; }
te	2	public mainframe ( ) { super ( ) ; setsize ( 750 , 300 ) ; setlocation ( 100 , 100 ) ; setdefaultcloseoperation ( exit_on_close ) ; listpanel = new jpanel ( ) ; listpanel . setlayout ( new boxlayout ( listpanel , boxlayout . y_axis ) ) ; openbuttonframe ( ) ; scrollpane = new jscrollpane ( listpanel ) ; add ( scrollpane ) ; addwindowlistener ( new windowadapter ( ) { @ override public void windowclosing ( windowevent e ) { serializer . savestate ( ) ; } } ) ; transactionlist list = serializer . getinstance ( ) ; if ( list . isempty ( ) ) { addnewtransaction ( ) ; } else { for ( transaction t : list ) { this . addnewtransaction ( t ) ; } } setvisible ( true ) ; system . out . println ( "this is my code please be a code." ) ; updatebalance ( ) ; }
te	5	@ override public void run ( ) { client1 . println ( session_created_message ) ; client2 . println ( session_created_message ) ; client1 . println ( opponent_info_message + client2 . getnick ( ) ) ; client2 . println ( opponent_info_message + client1 . getnick ( ) ) ; isongame = true ; while ( isongame ) { turn ( client1 , client2 ) ; turn ( client2 , client1 ) ; } client1 . println ( game_over_message ) ; client2 . println ( game_over_message ) ; boolean newgamestarted = false ; boolean want1 = false ; boolean want2 = false ; long starttime = system . currenttimemillis ( ) ; while ( system . currenttimemillis ( ) - starttime < 30000 ) { if ( want1 && want2 ) { new game ( client2 , client1 ) . start ( ) ; newgamestarted = true ; break ; } if ( client1 . isinputstreamready ( ) ) { string line = client1 . readline ( ) ; if ( ( line == null ) || ( line . equals ( farewell_message ) ) ) { if ( want2 ) { client2 . println ( not_again_message ) ; } break ; } if ( line . equals ( again_message ) ) { if ( ! want1 ) { want1 = true ; client2 . println ( want_again_message ) ; } } } if ( client2 . isinputstreamready ( ) ) { string line = client2 . readline ( ) ; if ( ( line == null ) || ( line . equals ( farewell_message ) ) ) { if ( want1 ) { client1 . println ( not_again_message ) ; } break ; } if ( line . equals ( again_message ) ) { if ( ! want2 ) { want2 = true ; client1 . println ( want_again_message ) ; } } } } if ( ! newgamestarted ) { client1 . println ( session_closed_message ) ; client2 . println ( session_closed_message ) ; client1 . disconnect ( ) ; client2 . disconnect ( ) ; } }
te	7	public void test ( ) { for ( instance instance : instances ) { string senseanswer = "" ; double bestprob = 0.0 ; for ( string sense : trainer . headwordsensemap . get ( instance . headword ( ) ) ) { double curprob = 1.0 ; curprob *= trainer . probability ( sense ) ; if ( trainer . use_collocation ) { for ( int i = 0 ; i < instance . collocation . length ; i ++ ) { curprob *= trainer . probability ( new feature ( instance . collocation [ i ] , i ) , sense ) ; } } if ( trainer . use_cooccurrence ) { for ( string cooccur : instance . word_set ) { curprob *= trainer . probability ( new feature ( cooccur ) , sense ) ; } } if ( curprob > bestprob ) { bestprob = curprob ; senseanswer = sense ; } } system . out . println ( instance . lexelt + " " + instance . instance_id + " " + senseanswer ) ; } }
te	7	public static arraylist < token > readtokenfromfile ( string tokenpath ) throws ioexception { arraylist < token > tokens = new arraylist < token > ( ) ; file file = new file ( tokenpath ) ; if ( ! file . exists ( ) || file . isdirectory ( ) ) { system . out . println ( "error\uff01file not exists or it's a directory!" ) ; throw new filenotfoundexception ( ) ; } string currenttoken = "" ; string currentsymbol = "" ; string currentvalue = "" ; bufferedreader br = new bufferedreader ( new filereader ( file ) ) ; currenttoken = br . readline ( ) ; while ( currenttoken != null ) { string [ ] tmp = currenttoken . split ( "@" ) ; currentsymbol = tmp [ 0 ] ; currentvalue = tmp [ 1 ] ; tokens . add ( new token ( currentsymbol , currentvalue ) ) ; currenttoken = br . readline ( ) ; } br . close ( ) ; return tokens ; }
te	6	private void dispatchmessages ( session session ) throws jmsexception { for ( trafficrobot robot : robots ) { inputstream in = this . getclass ( ) . getresourceasstream ( "/" + robot . getrobotid ( ) + ".csv" ) ; try { bufferedreader br = new bufferedreader ( new inputstreamreader ( in ) ) ; string line = br . readline ( ) ; while ( line != null ) { processline ( line , robot ) ; line = br . readline ( ) ; } br . close ( ) ; } catch ( filenotfoundexception e ) { e . printstacktrace ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } } for ( pointsmessage pointsmessage : pointsmessages ) { objectmessage message = session . createobjectmessage ( pointsmessage ) ; robotqueues . get ( pointsmessage . getrobotid ( ) ) . send ( message ) ; logger . info ( "sent message: " + pointsmessage ) ; } }
te	10	public void rotateblock ( ) { boolean rotatable = true ; int counter = 0 , adjust = 0 ; int newpose , newwidth , newheight ; int [ ] newx = new int [ 4 ] ; int [ ] newy = new int [ 4 ] ; newpose = ( currentblock . brickpose + 1 ) % numposes ; newwidth = bricks [ currentblock . bricktype ] [ newpose ] . w ; newheight = bricks [ currentblock . bricktype ] [ newpose ] . h ; if ( currentblock . xposition + currentblock . height > cols ) if ( currentblock . height != 4 ) adjust = - 1 * ( currentblock . height - 2 ) ; else adjust = - 1 * ( currentblock . height - 1 ) ; for ( int i = 0 ; i < newwidth ; i ++ ) for ( int j = 0 ; j < newheight ; j ++ ) { if ( bricks [ currentblock . bricktype ] [ newpose ] . grid [ j ] . charat ( i ) == 'x' ) { newx [ counter ] = currentblock . xposition + i + adjust ; newy [ counter ] = currentblock . yposition + j ; if ( colorgrid [ newy [ counter ] ] [ newx [ counter ] ] . isset ) rotatable = false ; counter ++ ; } } if ( rotatable ) for ( int i = 0 ; i < 4 ; i ++ ) { currentblock . brickpose = newpose ; currentblock . xvalues [ i ] = newx [ i ] ; currentblock . yvalues [ i ] = newy [ i ] ; currentblock . height = newheight ; currentblock . width = newwidth ; } }
te	2	public void showfield ( ) { for ( int i = 0 ; i < fieldsize ; i ++ ) { for ( int j = 0 ; j < fieldsize ; j ++ ) { if ( character . isletter ( field [ i ] [ j ] ) ) { system . out . print ( "[ " + field [ i ] [ j ] + " ]" ) ; } else { system . out . print ( "[ " + ( int ) field [ i ] [ j ] + " ]" ) ; } } system . out . println ( ) ; } }
te	1	private void chars ( ) { if ( true == this . intitle ) { this . currenttitle += ( char ) this . p . getlastchar ( ) ; } if ( true == this . foundtitle && true == this . intext ) { int c = p . getlastchar ( ) ; try { this . outxmlfd . write ( c ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } try { if ( this . firstlineoftext ) { this . outtxtfd . write ( this . currenttitle ) ; this . outtxtfd . write ( " " ) ; } if ( '\\n' != c && '\\r' != c ) { if ( trie . isalphanumeric ( c ) ) { this . outtxtfd . write ( c ) ; } else { this . outtxtfd . write ( " " ) ; } } } catch ( ioexception e ) { e . printstacktrace ( ) ; } } this . firstlineoftext = false ; }
te	10	public void generatelabyrinth ( int x , int y , int w , int h ) { arraylist < vector2i > c = new arraylist < vector2i > ( ) ; fillrect ( x , y , w , h , 3 ) ; c . add ( new vector2i ( 1 + x + ( float ) math . floor ( math . random ( ) * ( w / 2 ) ) * 2 , 1 + y + ( float ) math . floor ( math . random ( ) * ( h / 2 ) ) * 2 ) ) ; map . settileid ( ( int ) c . get ( 0 ) . x , ( int ) c . get ( 0 ) . y , 0 , 1 ) ; boolean n , s , w , e , end ; int d , id , cx , cy ; while ( c . size ( ) != 0 ) { if ( math . random ( ) > 0.5 ) { id = ( int ) math . floor ( math . random ( ) * c . size ( ) ) ; } else { id = c . size ( ) - 1 ; } id = c . size ( ) - 1 ; cx = ( int ) c . get ( id ) . x ; cy = ( int ) c . get ( id ) . y ; n = ( ( cy - 2 ) > y && map . gettileid ( cx , cy - 2 , 0 ) == 3 ) ; s = ( ( cy + 2 ) < y + h && map . gettileid ( cx , cy + 2 , 0 ) == 3 ) ; w = ( ( cx - 2 ) > x && map . gettileid ( cx - 2 , cy , 0 ) == 3 ) ; e = ( ( cx + 2 ) < x + w && map . gettileid ( cx + 2 , cy , 0 ) == 3 ) ; if ( n || s || w || e ) { end = false ; while ( ! end ) { d = ( int ) math . floor ( math . random ( ) * 4 ) ; if ( d == 0 && n ) { end = true ; c . add ( new vector2i ( cx , cy - 2 ) ) ; map . settileid ( cx , cy - 2 , 0 , 1 ) ; map . settileid ( cx , cy - 1 , 0 , 1 ) ; } else if ( d == 2 && w ) { end = true ; c . add ( new vector2i ( cx - 2 , cy ) ) ; map . settileid ( cx - 2 , cy , 0 , 1 ) ; map . settileid ( cx - 1 , cy , 0 , 1 ) ; } else if ( d == 1 && s ) { end = true ; c . add ( new vector2i ( cx , cy + 2 ) ) ; map . settileid ( cx , cy + 2 , 0 , 1 ) ; map . settileid ( cx , cy + 1 , 0 , 1 ) ; } else if ( d == 3 && e ) { end = true ; c . add ( new vector2i ( cx + 2 , cy ) ) ; map . settileid ( cx + 2 , cy , 0 , 1 ) ; map . settileid ( cx + 1 , cy , 0 , 1 ) ; } } } else { c . remove ( id ) ; } } }
te	3	public viewmanager ( ) { super ( "neural network car recognizer" ) ; setdefaultcloseoperation ( jframe . exit_on_close ) ; setsize ( x - 90 , y ) ; setlocationrelativeto ( null ) ; setresizable ( false ) ; menu = new jmenubar ( ) ; m1 = new jmenu ( "file" ) ; p1 = new jmenuitem ( "load image" , keyevent . vk_l ) ; p2 = new jmenuitem ( "load nn settings" , keyevent . vk_k ) ; p3 = new jmenuitem ( "save nn settings" , keyevent . vk_s ) ; m1 . add ( p1 ) ; m1 . add ( p2 ) ; m1 . add ( p3 ) ; menu . add ( m1 ) ; m2 = new jmenu ( "train" ) ; p4 = new jmenuitem ( "train bp" ) ; m2 . add ( p4 ) ; menu . add ( m2 ) ; setjmenubar ( menu ) ; fc = new jfilechooser ( ) ; filefilter fil = new filefilter ( ) { @ override public string getdescription ( ) { return "image files .jpg .png" ; } @ override public boolean accept ( file file ) { if ( file . isdirectory ( ) ) { return true ; } else { string path = file . getabsolutepath ( ) . tolowercase ( ) ; if ( path . endswith ( ".jpg" ) || path . endswith ( ".png" ) ) { return true ; } } return false ; } } ; fc . setfilefilter ( fil ) ; showpanel = new showpanel ( ) ; maxcols = new jtextfield ( 8 ) ; maxcols . settext ( "max cols" ) ; keycolors = new jbutton ( "key colors" ) ; somtrain = new jbutton ( "train som" ) ; processsom = new jbutton ( "process som" ) ; restprocess = new jbutton ( "rest of processes" ) ; confirm = new jbutton ( "run bp" ) ; jpanel bottom = new jpanel ( ) ; bottom . setlayout ( new flowlayout ( flowlayout . left , 15 , 5 ) ) ; bottom . setbackground ( color . white ) ; bottom . add ( maxcols ) ; bottom . add ( keycolors ) ; bottom . add ( somtrain ) ; bottom . add ( processsom ) ; bottom . add ( restprocess ) ; bottom . add ( confirm ) ; mpanel = new mainpanel ( ) ; mpanel . setborder ( bord ) ; getcontentpane ( ) . add ( borderlayout . center , mpanel ) ; getcontentpane ( ) . add ( borderlayout . south , bottom ) ; setvisible ( true ) ; }
te	2	public static void main ( string [ ] args ) throws exception { myqueue mq = new myqueue ( 10 ) ; mq . insert ( 0 ) ; mq . insert ( - 1 ) ; mq . insert ( 20 ) ; mq . insert ( 21 ) ; int ind = 0 ; while ( ! mq . isempty ( ) ) { system . out . println ( mq . poll ( ) ) ; ind ++ ; if ( ind == 1 ) { break ; } } system . out . println ( "size : " + mq . size ( ) ) ; mq . insert ( 4 ) ; mq . insert ( 3 ) ; mq . insert ( 2 ) ; mq . insert ( 1 ) ; mq . insert ( 0 ) ; mq . insert ( - 1 ) ; mq . insert ( - 2 ) ; while ( ! mq . isempty ( ) ) { system . out . println ( mq . poll ( ) ) ; } mq . insert ( 4 ) ; mq . insert ( 3 ) ; mq . insert ( 2 ) ; while ( ! mq . isempty ( ) ) { system . out . println ( mq . poll ( ) ) ; } }
