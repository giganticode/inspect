tr	3	decisiontreeimpl ( dataset train ) { if ( train == null || train . instances == null || train . instances . isempty ( ) ) { return ; } list < attribute > attributes = new arraylist < attribute > ( ) ; for ( instance instance : train . instances ) { for ( int i = 0 ; i < instance . attributes . size ( ) ; i ++ ) { if ( i > attributes . size ( ) - 1 ) { attributes . add ( new attribute ( i ) ) ; } attributes . get ( i ) . addvalue ( instance . attributes . get ( i ) ) ; } } root = traintree ( train . instances , attributes , train . instances , "root" ) ; }
tr	1	public void test_score ( ) { int [ ] [ ] mockboards = { { 0 , 0 , 0 , 0 } , { 0 , 0 , 0 , 0 } , { 0 , 0 , 0 , 0 } , { 0 , 0 , 0 , 0 } } ; gamecore . resetgame ( ) ; gamecore . setboard ( mockboards ) ; gamecore . tilt_board_left ( ) ; assertequals ( 0 , gamecore . score ( ) ) ; mockboards = new int [ ] [ ] { { 1 , 1 , 1 , 1 } , { 0 , 0 , 0 , 0 } , { 2 , 2 , 2 , 2 } , { 0 , 0 , 0 , 0 } } ; gamecore . resetgame ( ) ; gamecore . setboard ( mockboards ) ; gamecore . tilt_board_left ( ) ; assertequals ( 12 , gamecore . score ( ) ) ; mockboards = new int [ ] [ ] { { 1 , 0 , 0 , 0 } , { 2 , 0 , 0 , 0 } , { 2 , 0 , 0 , 0 } , { 2 , 0 , 0 , 0 } } ; gamecore . resetgame ( ) ; gamecore . setboard ( mockboards ) ; gamecore . tilt_board_left ( ) ; assertequals ( 0 , gamecore . score ( ) ) ; mockboards = new int [ ] [ ] { { 1 , 2 , 3 , 4 } , { 2 , 3 , 3 , 3 } , { 2 , 2 , 2 , 2 } , { 2 , 3 , 3 , 3 } } ; gamecore . resetgame ( ) ; gamecore . setboard ( mockboards ) ; gamecore . tilt_board_left ( ) ; assertequals ( 20 , gamecore . score ( ) ) ; }
tr	6	private static double computedcg ( list < integer > urls , list < integer > googleorder , int noofentries ) { double gain = 0 ; double logtwo = math . log ( 2 ) ; int rank = 0 ; for ( int i = 0 ; i < noofentries ; i ++ ) { integer item = googleorder . get ( i ) ; integer val = urls . get ( item - 1 ) ; rank ++ ; if ( rank < 2 ) { gain += val ; } else { gain += val * logtwo / math . log ( rank ) ; } } return gain ; }
tr	9	public static void tst1 ( ) { trackdto trackdto = new trackdto ( ) ; list < track > tracks1 = trackdto . getalltracks ( ) ; for ( track track : tracks1 ) { system . out . println ( track ) ; } system . out . println ( "------" ) ; track track11 = trackdto . gettrackbytitle ( "one" ) ; system . out . println ( track11 ) ; system . out . println ( "------" ) ; track track12 = trackdto . gettrackbyid ( 12 ) ; system . out . println ( track12 ) ; system . out . println ( "------" ) ; track track22 = new track ( 22 , "jude" , "beatles" ) ; track track23 = new track ( 23 , "submarine" , "beatles" ) ; string result20 = trackdto . createtrack ( track22 ) ; system . out . println ( result20 ) ; result20 = trackdto . createtrack ( track23 ) ; system . out . println ( result20 ) ; tracks1 = trackdto . getalltracks ( ) ; for ( track track : tracks1 ) { system . out . println ( track ) ; } system . out . println ( "------" ) ; track track24 = new track ( 13 , "1999" , "pineapples" ) ; result20 = trackdto . updatetrack ( track24 ) ; system . out . println ( result20 ) ; trackdto . deletetrackbyid ( 12 ) ; tracks1 = trackdto . getalltracks ( ) ; for ( track track : tracks1 ) { system . out . println ( track ) ; } system . out . println ( "------" ) ; }
tr	1	public void actionperformed ( actionevent e ) { if ( "next" . equals ( e . getactioncommand ( ) ) ) { update ( 1 ) ; } if ( "forward" . equals ( e . getactioncommand ( ) ) ) { integer num = new integer ( forwardepochs . gettext ( ) ) ; update ( num . intvalue ( ) ) ; } if ( "restart" . equals ( e . getactioncommand ( ) ) ) { scape . frame . dispose ( ) ; new simulation ( ) . run ( ) ; } if ( "exit" . equals ( e . getactioncommand ( ) ) ) { scape . frame . dispose ( ) ; } }
tr	8	@ override public void receive ( message message ) throws messagelistenerexception { long companyid = portalutil . getdefaultcompanyid ( ) ; try { user user = userlocalserviceutil . getuserbyemailaddress ( companyid , portletpropsvalues . detect_user_email ) ; expandotable table = expandotablelocalserviceutil . getdefaulttable ( user . getcompanyid ( ) , user . class . getname ( ) ) ; expandocolumn column = expandocolumnlocalserviceutil . getcolumn ( table . gettableid ( ) , constants . expando_column_name ) ; expandovalue value = expandovaluelocalserviceutil . getvalue ( table . gettableid ( ) , column . getcolumnid ( ) , user . getuserid ( ) ) ; string languagechangetime = stringpool . blank ; if ( value != null ) { languagechangetime = value . getdata ( ) ; } string userlanguage = user . getlanguageid ( ) ; long timestamp = system . currenttimemillis ( ) ; if ( validator . isnull ( languagechangetime ) && userlanguage . equals ( portletpropsvalues . detect_language ) ) { expandovaluelocalserviceutil . addvalue ( table . getclassnameid ( ) , table . gettableid ( ) , column . getcolumnid ( ) , user . getuserid ( ) , string . valueof ( timestamp ) ) ; if ( _log . isinfoenabled ( ) ) { _log . info ( "detect user language change." ) ; } } if ( validator . isnotnull ( languagechangetime ) && ! userlanguage . equals ( portletpropsvalues . detect_language ) ) { expandovaluelocalserviceutil . addvalue ( table . getclassnameid ( ) , table . gettableid ( ) , column . getcolumnid ( ) , user . getuserid ( ) , stringpool . blank ) ; } if ( validator . isnotnull ( languagechangetime ) && userlanguage . equals ( portletpropsvalues . detect_language ) && ( timestamp - long . valueof ( languagechangetime ) ) >= portletpropsvalues . language_life_ms ) { user . setlanguageid ( portletpropsvalues . recover_language ) ; userlocalserviceutil . updateuser ( user ) ; expandovaluelocalserviceutil . addvalue ( table . getclassnameid ( ) , table . gettableid ( ) , column . getcolumnid ( ) , user . getuserid ( ) , stringpool . blank ) ; if ( _log . isinfoenabled ( ) ) { _log . info ( "update user language to " + portletpropsvalues . recover_language ) ; } } } catch ( nosuchuserexception nsue ) { if ( _log . isinfoenabled ( ) ) { _log . info ( "user " + portletpropsvalues . detect_user_email + " does not exist" ) ; } } catch ( exception e ) { if ( _log . iserrorenabled ( ) ) { _log . error ( e ) ; } } }
tr	8	public void generate ( land [ ] [ ] world ) { int width = world . length ; int depth = world [ 0 ] . length ; int centerx = width / 2 ; int centerz = depth / 2 ; float maxdist = ( float ) math . sqrt ( ( centerx ) * ( centerx ) + ( centerz ) * ( centerz ) ) ; system . out . println ( maxdist ) ; for ( int i = 0 ; i < width ; i ++ ) { for ( int j = 0 ; j < depth ; j ++ ) { float grad = 1 - ( ( float ) math . sqrt ( ( i - centerx ) * ( i - centerx ) + ( j - centerz ) * ( j - centerz ) ) / maxdist ) ; grad *= grad * grad * grad * 3 ; world [ i ] [ j ] . height *= grad ; } } }
tr	6	public string decypher ( string input ) { string [ ] cyphers = input . split ( " " ) ; stringbuffer sb = new stringbuffer ( ) ; for ( int i = 0 ; i < cyphers . length ; i ++ ) { long num = long . parselong ( cyphers [ i ] ) ; long temp = endecrypt ( num , d , n ) ; debug . print ( "temp is:" + temp ) ; char c = ( char ) temp ; sb . append ( c ) ; } return sb . tostring ( ) ; }
tr	5	public void grabararchivodeclasejava ( string paquetecodigogenerado , string path ) { setpaquetecontenedor ( paquetecodigogenerado ) ; paquetecodigogenerado = paquetecodigogenerado . replace ( "." , "\\\\" ) ; string filename = path + file . separatorchar + paquetecodigogenerado + file . separatorchar + nombrevo + ".java" ; string content = generarcontenidoclase ( ) ; try { filewriter fw = new filewriter ( filename ) ; bufferedwriter bw = new bufferedwriter ( fw ) ; printwriter salida = new printwriter ( bw ) ; salida . println ( content ) ; salida . close ( ) ; } catch ( ioexception e ) { system . out . println ( "error al escribir el archivo" ) ; e . printstacktrace ( ) ; } }
tr	10	private void handleclient ( ) throws ioexception { inputstream instream = clisock . getinputstream ( ) ; outputstream outstream = clisock . getoutputstream ( ) ; inputstreamreader inputstreamreader = new inputstreamreader ( instream ) ; bufferedreader in = new bufferedreader ( inputstreamreader ) ; printwriter out = new printwriter ( outstream ) ; simpledateformat formatter = new simpledateformat ( "yyyy-mm-dd" ) ; date date ; string response = null ; try { date = formatter . parse ( in . readline ( ) ) ; date today = new date ( ) ; int diffindays = ( int ) ( ( date . gettime ( ) - today . gettime ( ) ) / ( 1000 * 60 * 60 * 24 ) ) ; response = "the diffrence is: " + diffindays ; } catch ( parseexception e ) { response = "err cannot prase date!!!" ; } out . println ( response ) ; out . flush ( ) ; out . close ( ) ; }
tr	6	public static hashtable < string , compiledstat > compilestats ( vector < stat > stats , collection < team > teams ) { vector < team > teamvector = new vector < team > ( teams ) ; hashtable < string , compiledstat > compiledstats = new hashtable < string , compiledstat > ( ) ; for ( stat stat : stats ) { double [ ] values = new double [ teams . size ( ) ] ; for ( int i = 0 ; i < teams . size ( ) ; i ++ ) { team team = teamvector . get ( i ) ; values [ i ] = team . getstat ( stat . name ) ; } compiledstats . put ( stat . name , new compiledstat ( stat . name , values ) ) ; } return compiledstats ; }
tr	5	public void writenext ( string [ ] nextline ) { if ( nextline == null ) return ; stringbuffer sb = new stringbuffer ( ) ; for ( int i = 0 ; i < nextline . length ; i ++ ) { if ( i != 0 ) { sb . append ( separator ) ; } string nextelement = nextline [ i ] ; if ( nextelement == null ) continue ; if ( quotechar != no_quote_character ) sb . append ( quotechar ) ; for ( int j = 0 ; j < nextelement . length ( ) ; j ++ ) { char nextchar = nextelement . charat ( j ) ; if ( escapechar != no_escape_character && nextchar == quotechar ) { sb . append ( escapechar ) . append ( nextchar ) ; } else if ( escapechar != no_escape_character && nextchar == escapechar ) { sb . append ( escapechar ) . append ( nextchar ) ; } else { sb . append ( nextchar ) ; } } if ( quotechar != no_quote_character ) sb . append ( quotechar ) ; } sb . append ( lineend ) ; pw . write ( sb . tostring ( ) ) ; }
tr	4	private static string read ( clob c ) throws sqlexception , ioexception { stringbuffer sb = new stringbuffer ( ( int ) c . length ( ) ) ; reader r = c . getcharacterstream ( ) ; char [ ] cbuf = new char [ 2048 ] ; int n = 0 ; while ( ( n = r . read ( cbuf , 0 , cbuf . length ) ) != - 1 ) { if ( n > 0 ) { sb . append ( cbuf , 0 , n ) ; } } return sb . tostring ( ) ; }
tr	7	public void appendnextround ( round round ) { round nextround = new round ( ) ; rounds . add ( nextround ) ; int roundnumber = rounds . indexof ( nextround ) ; int gamecount = 0 ; for ( int i = 0 ; i < round . size ( ) ; i += 2 ) { game newgame = new game ( ) ; newgame . referee = scoreable ; game [ ] previousgames = new game [ ] { round . get ( i ) , round . get ( i + 1 ) } ; for ( game previousgame : previousgames ) previousgame . nextgame = newgame ; newgame . previousgames = previousgames ; newgame . name = string . format ( "r%d g%d" , roundnumber , gamecount ) ; nextround . add ( newgame ) ; gamecount ++ ; } if ( nextround . size ( ) == 1 ) return ; appendnextround ( nextround ) ; }
tr	1	public void addinfo ( site s ) { content [ 0 ] = "scape" ; content [ 1 ] = "agents: " + scape . agents . size ( ) ; content [ 2 ] = newline + "site" ; content [ 3 ] = "coordinates: (" + s . getxposition ( ) + "<litcomma> " + s . getyposition ( ) + ")" ; content [ 4 ] = "site food: " + round ( s . getfood ( ) ) ; content [ 5 ] = newline + "agent on site" ; agent a = s . getagent ( ) ; if ( a != null ) { content [ 6 ] = "agent id: " + a ; content [ 7 ] = "age: " + a . getage ( ) ; content [ 8 ] = "agent energy: " + round ( a . getenergy ( ) ) ; } else { content [ 6 ] = "id: " ; content [ 7 ] = "age: " ; content [ 8 ] = "agent energy: " ; } updateinfo ( ) ; }
tr	10	@ override protected void reduce ( text key , iterable < text > values , context context ) throws ioexception , interruptedexception { system . out . println ( headertype . valueof ( key . tostring ( ) . trim ( ) . replaceall ( "\\\\ " , "" ) ) . tostring ( ) ) ; switch ( headertype . valueof ( key . tostring ( ) . trim ( ) . replaceall ( "\\\\ " , "" ) ) . tostring ( ) ) { case "number" : system . out . println ( "number me for key =" + key . tostring ( ) ) ; double max = integer . min_value ; double min = integer . max_value ; double avg = 0.0 ; integer count = 0 ; for ( text value : values ) { double curr = double . parsedouble ( value . tostring ( ) . trim ( ) ) ; max = max <= curr ? curr : max ; min = min >= curr ? curr : min ; avg += curr ; count ++ ; } context . write ( key , new text ( "max=" + string . valueof ( max ) + "\\t min=" + string . valueof ( min ) + "\\t avg=" + string . valueof ( avg / count ) ) ) ; break ; case "words" : system . out . println ( "words me for key=" + key . tostring ( ) ) ; map < string , integer > countofcat = new hashmap < string , integer > ( ) ; count = 0 ; for ( text word : values ) { if ( countofcat . containskey ( word . tostring ( ) ) ) { count = countofcat . get ( word . tostring ( ) ) ; countofcat . put ( word . tostring ( ) , ++ count ) ; } else { countofcat . put ( word . tostring ( ) , 1 ) ; } } string tmp = new string ( ) ; for ( entry < string , integer > entry : countofcat . entryset ( ) ) { tmp += entry . getkey ( ) + "=" + entry . getvalue ( ) + "\\t" ; } context . write ( key , new text ( tmp ) ) ; break ; default : break ; } }
tr	7	private ichromosome setupchromosome ( final int [ ] set ) throws invalidconfigurationexception { subsetgenes = new gene [ k ] ; int minelementvalue = integer . max_value ; int maxelementvalue = integer . min_value ; for ( final int element : set ) { minelementvalue = math . min ( element , minelementvalue ) ; maxelementvalue = math . max ( element , maxelementvalue ) ; } for ( int g = 0 ; g < k ; g ++ ) { subsetgenes [ g ] = new integergene ( configuration , 0 , numelementsinset - 1 ) ; } final gene [ ] genes = new gene [ 1 + getnumberofparameters ( ) ] ; final abstractsupergene constrainedgenes = new subsetsupergene ( configuration , subsetgenes , this . allelements ) ; genes [ 0 ] = constrainedgenes ; for ( int paramindex = 0 ; paramindex < getnumberofparameters ( ) ; paramindex ++ ) { genes [ 1 + paramindex ] = new integergene ( configuration , 0 , this . allpossibleparametervalues [ paramindex ] . length - 1 ) ; } subsetchromosome = new chromosome ( configuration , genes ) ; return subsetchromosome ; }
tr	2	public static void writesinglefile ( integer docid , string url , string path , string parenturl , string title , string h1 , string h2 , string h3 , string bold , string strong , string em , string anchortext , string parseddata ) throws ioexception { filewriter fstream = new filewriter ( "combinedwebpages" , true ) ; bufferedwriter out = new bufferedwriter ( fstream ) ; out . write ( docid . tostring ( ) + "^" + url + "^" + path + "^" + parenturl + "^" + title + "^" + h1 + "^" + h2 + "^" + h3 + "^" + bold + "^" + strong + "^" + em + "^" + anchortext + "^" + parseddata ) ; out . newline ( ) ; out . close ( ) ; }
tr	1	public pelivihko ( ) { yhdistelmat = new enummap < jatsiyhdistelma , integer > ( jatsiyhdistelma . class ) ; jatsiyhdistelmat = new arraylist < jatsiyhdistelma > ( ) ; jatsiyhdistelmat . add ( jatsiyhdistelma . ykkoset ) ; jatsiyhdistelmat . add ( jatsiyhdistelma . kakkoset ) ; jatsiyhdistelmat . add ( jatsiyhdistelma . kolmoset ) ; jatsiyhdistelmat . add ( jatsiyhdistelma . neloset ) ; jatsiyhdistelmat . add ( jatsiyhdistelma . viitoset ) ; jatsiyhdistelmat . add ( jatsiyhdistelma . kuutoset ) ; jatsiyhdistelmat . add ( jatsiyhdistelma . pari ) ; jatsiyhdistelmat . add ( jatsiyhdistelma . kaksi_paria ) ; jatsiyhdistelmat . add ( jatsiyhdistelma . kolme_samaa ) ; jatsiyhdistelmat . add ( jatsiyhdistelma . nelja_samaa ) ; jatsiyhdistelmat . add ( jatsiyhdistelma . pikkusuora ) ; jatsiyhdistelmat . add ( jatsiyhdistelma . isosuora ) ; jatsiyhdistelmat . add ( jatsiyhdistelma . tayskasi ) ; jatsiyhdistelmat . add ( jatsiyhdistelma . sattuma ) ; jatsiyhdistelmat . add ( jatsiyhdistelma . yatzy ) ; for ( int i = 0 ; i < jatsiyhdistelmat . size ( ) ; i ++ ) { yhdistelmat . put ( jatsiyhdistelmat . get ( i ) , null ) ; } valisumma = 0 ; bonus = 0 ; summa = 0 ; full = false ; }
tr	2	@ override public int insertcustomer ( site site ) { connection con = conn . getconnection ( true ) ; try { preparedstatement ps = con . preparestatement ( "insert into public.site values (?<litcomma>?)" ) ; ps . setint ( 1 , site . getid ( ) ) ; ps . setstring ( 2 , site . getsitename ( ) ) ; ps . execute ( ) ; } catch ( sqlexception e ) { e . printstacktrace ( ) ; } finally { try { con . close ( ) ; } catch ( sqlexception e ) { e . printstacktrace ( ) ; } } return 0 ; }
tr	3	public tournament ( round firstround , hashtable < string , compiledstat > compiledstats , referee scoreable ) { if ( md5 == null ) { try { md5 = messagedigest . getinstance ( "md5" ) ; } catch ( nosuchalgorithmexception e ) { e . printstacktrace ( ) ; } } this . compiledstats = compiledstats ; this . scoreable = scoreable ; round duplicate = new round ( ) ; for ( game game : firstround ) { game dupegame = new game ( game . teams , scoreable ) ; dupegame . name = game . name ; duplicate . add ( dupegame ) ; } rounds . add ( duplicate ) ; appendnextround ( duplicate ) ; }
tr	1	public static void showbaninfo ( editban eb , commandsender sender ) { dateformat shorttime = dateformat . getdatetimeinstance ( ) ; sender . sendmessage ( chatcolor . aqua + bantype ( eb . type ) ) ; sender . sendmessage ( chatcolor . gold + " | " + chatcolor . white + eb . name + chatcolor . yellow + " was banned by " + chatcolor . white + eb . admin + chatcolor . yellow ) ; sender . sendmessage ( chatcolor . gold + " | at " + shorttime . format ( ( new date ( eb . time * 1000 ) ) ) ) ; if ( eb . endtime > 0 ) sender . sendmessage ( chatcolor . gold + " | " + chatcolor . yellow + "will be unbanned at " + shorttime . format ( ( new date ( eb . endtime * 1000 ) ) ) ) ; sender . sendmessage ( chatcolor . gold + " | " + chatcolor . yellow + "reason: " + chatcolor . gray + eb . reason ) ; }
tr	9	public void actionperformed ( actionevent arg0 ) { string rootpath = tfrootdirectory . gettext ( ) ; string filetype = tffiletypes . gettext ( ) ; string [ ] extensions = filetype . split ( ";" ) ; int numberoffiles = integer . parseint ( tfnumbeoffiles . gettext ( ) ) ; long maxfilesize = long . parselong ( tffilesize . gettext ( ) ) ; long maxid = long . parselong ( tfmaxid . gettext ( ) ) ; long minid = long . parselong ( tfminid . gettext ( ) ) ; configurations configurations = new configurations ( rootpath , extensions , numberoffiles , maxfilesize , minid , maxid , chckbxyes . isselected ( ) ) ; dispose ( ) ; serverrunningframe serverrunningframe = new serverrunningframe ( configurations ) ; }
tr	9	@ eventhandler public void onplayerdeathevent ( playerdeathevent event ) { player player = ( player ) event . getentity ( ) ; if ( ! player . haspermission ( "trophyheads.drop" ) ) { return ; } if ( randomgenerator . nextint ( 100 ) >= drop_chances . get ( entitytype . player . tostring ( ) ) ) { return ; } boolean dropokay = false ; damagecause dc ; if ( player . getlastdamagecause ( ) != null ) { dc = player . getlastdamagecause ( ) . getcause ( ) ; logdebug ( "damagecause: " + dc . tostring ( ) ) ; } else { logdebug ( "damagecause: null" ) ; return ; } if ( death_types . contains ( dc . tostring ( ) ) ) { dropokay = true ; } if ( death_types . contains ( "all" ) ) { dropokay = true ; } if ( player . getkiller ( ) instanceof player ) { logdebug ( "player " + player . getname ( ) + " killed by another player. checking if pvp is valid death type." ) ; if ( death_types . contains ( "pvp" ) ) { dropokay = isvaliditem ( entitytype . player , player . getkiller ( ) . getiteminhand ( ) . gettype ( ) ) ; logdebug ( "pvp is a valid death type. killer's item in hand is valid? " + dropokay ) ; } else { logdebug ( "pvp is not a valid death type." ) ; } } if ( dropokay ) { logdebug ( "match: true" ) ; location loc = player . getlocation ( ) . clone ( ) ; world world = loc . getworld ( ) ; string pname = player . getname ( ) ; itemstack item = new itemstack ( material . skull_item , 1 , ( byte ) 3 ) ; itemmeta itemmeta = item . getitemmeta ( ) ; arraylist < string > itemdesc = new arraylist < > ( ) ; itemmeta . setdisplayname ( "head of " + pname ) ; itemdesc . add ( event . getdeathmessage ( ) ) ; itemmeta . setlore ( itemdesc ) ; if ( playerskin ) { ( ( skullmeta ) itemmeta ) . setowner ( pname ) ; } item . setitemmeta ( itemmeta ) ; world . dropitemnaturally ( loc , item ) ; } else { logdebug ( "match: false" ) ; } }
tr	4	public void writeall ( java . sql . resultset rs , boolean includecolumnnames ) throws sqlexception , ioexception { resultsetmetadata metadata = rs . getmetadata ( ) ; if ( includecolumnnames ) { writecolumnnames ( metadata ) ; } int columncount = metadata . getcolumncount ( ) ; while ( rs . next ( ) ) { string [ ] nextline = new string [ columncount ] ; for ( int i = 0 ; i < columncount ; i ++ ) { nextline [ i ] = getcolumnvalue ( rs , metadata . getcolumntype ( i + 1 ) , i + 1 ) ; } writenext ( nextline ) ; } }
tr	3	@ override public list < string > getimageslist ( string url ) { arraylist < string > imglist = new arraylist < string > ( ) ; try { string pagestr = readpage ( new url ( url ) ) ; matcher m = imagepattern . matcher ( pagestr ) ; while ( m . find ( ) ) { imglist . add ( m . group ( 1 ) ) ; } } catch ( malformedurlexception e ) { e . printstacktrace ( ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } return imglist ; }
tr	10	private void postmenuview ( ) { string statementstring = "select * from posts" ; try { statement statement = connection . createstatement ( ) ; resultset rs = statement . executequery ( statementstring ) ; string columnnames = "id\\t\\t contributorid\\t goalid\\t\\tdataandtime\\t\\tbody" ; system . out . println ( columnnames ) ; while ( rs . next ( ) ) { int id = rs . getint ( "id" ) ; string body = rs . getstring ( "body" ) ; string dateandtime = rs . getstring ( "dateandtime" ) ; int contributorid = rs . getint ( "contributorid" ) ; int goalid = rs . getint ( "goalid" ) ; string postline = string . format ( "%d\\t\\t%d\\t\\t %d\\t\\t %s\\t %s" , id , contributorid , goalid , dateandtime , body ) ; system . out . println ( postline ) ; } } catch ( sqlexception sqe ) { system . out . println ( "there was an error in retrieving the posts." ) ; } }
tr	7	public static void main ( string [ ] args ) { scanner sc = new scanner ( system . in ) ; system . out . print ( "please enter the public key number(n):" ) ; long input_n = sc . nextlong ( ) ; system . out . println ( ) ; system . out . print ( "please enter the public key value(e):" ) ; long input_e = sc . nextlong ( ) ; system . out . println ( ) ; bruteforce bf = new bruteforce ( input_n , input_e ) ; key k = bf . bruteforcecrack ( ) ; if ( k == null ) { system . out . println ( "the input key pair in not factorizable" ) ; } else { system . out . println ( "the private key(d<litcomma>m) pair for the input is (" + k . getdecryptkey ( ) + "<litcomma>" + k . getm ( ) + ")" ) ; } while ( true ) { system . out . println ( "please input encrypt number:" ) ; long input = sc . nextlong ( ) ; int letter = ( int ) rsa . modulo ( input , k . getdecryptkey ( ) , input_n ) ; system . out . println ( "decrypt result is:" + letter ) ; system . out . println ( "letter is:" + ( char ) letter ) ; } }
tr	4	public static void main ( string [ ] args ) { scanner scanner = new scanner ( system . in ) ; system . out . println ( "ingrese la fecha (dd/mm/aaaa): " ) ; string sfecha = scanner . next ( ) ; fecha f = new fecha ( sfecha ) ; system . out . println ( "la fecha ingresada es:" + f ) ; system . out . println ( "ingrese d\xedas a sumar(pueden ser negativos)" ) ; int diassum = scanner . nextint ( ) ; f . adddias ( diassum ) ; system . out . println ( "sumando " + diassum + " d\xedas<litcomma> queda: " + f ) ; }
tr	10	@ override public void init ( gamecontainer container ) throws slickexception { this . container = container ; container . settargetframerate ( 60 ) ; int size = 5 ; int speed = 3 ; int rotation = 20 ; float range = 40 ; ship = new ship ( size , speed , rotation , range , this ) ; list < obj > shiplist = new list < obj > ( ) ; shiplist . add ( ship ) ; bulletlist = new list < obj > ( ) ; astlist = new list < obj > ( ) ; for ( int i = 0 ; i < 2 ; i ++ ) { float [ ] loc = new float [ 2 ] ; loc [ 0 ] = ( float ) ( math . random ( ) * container . getwidth ( ) ) ; loc [ 1 ] = ( float ) ( math . random ( ) * container . getheight ( ) ) ; list < obj > pointer = astlist ; while ( pointer . next != null ) { pointer = pointer . next ; } list < obj > wrapper = new list < obj > ( ) ; asteroid ast = new asteroid ( loc , ( float ) ( math . random ( ) * 10 + 4 ) , wrapper , this ) ; wrapper . data = ast ; wrapper . previous = pointer ; pointer . next = wrapper ; } gamelist = new list < list < obj > > ( ) ; gamelist . add ( bulletlist ) ; gamelist . add ( astlist ) ; gamelist . add ( shiplist ) ; }
tr	3	public static void main ( string [ ] args ) { scanner scanner = new scanner ( system . in ) ; system . out . println ( "ingrese un d\xeda de la semana (n\xfamero): " ) ; int v = scanner . nextint ( ) ; string dia ; switch ( v ) { case 1 : dia = "lunes" ; break ; case 2 : dia = "martes" ; break ; case 3 : dia = "miercoles" ; break ; case 4 : dia = "jueves" ; break ; case 5 : dia = "viernes" ; break ; case 6 : dia = "s\xe1bado" ; break ; case 7 : dia = "domingo" ; break ; default : dia = "d\xeda incorrecto... el valor debe ser entre 1 y 7" ; } system . out . println ( dia ) ; }
tr	9	private static void startgame ( ) throws ioexception { fourinrowpuzzle p = new fourinrowpuzzle ( ) ; game game = new game ( ) ; scanner in = new scanner ( system . in ) ; boolean player = false ; puzzle_hole_colors currentcolor ; short column = 0 ; short maxdepth ; long starttime , endtime ; system . out . print ( "0: you play first<litcomma> 1 computer play first: " ) ; player = ( in . nextbyte ( ) != 0 ) ; system . out . print ( "enter max depth: " ) ; maxdepth = in . nextshort ( ) ; game . setmaxdepth ( ( byte ) maxdepth ) ; system . out . println ( p . tostring ( ) ) ; while ( ! p . isfull ( ) && ! p . isdone ( ) ) { try { if ( player ) { currentcolor = players . player1 ; game . setpuzzle ( p ) ; system . out . println ( "computer is thinking ..." ) ; starttime = system . currenttimemillis ( ) ; column = game . getnextplay ( ) ; endtime = system . currenttimemillis ( ) ; system . out . println ( "computer played: " + column ) ; system . out . println ( "created nodes: " + game . getgraphnodescount ( ) ) ; system . out . println ( "took(" + ( float ) ( endtime - starttime ) / 1000 + "s)" ) ; } else { currentcolor = players . player2 ; system . out . print ( "your turn<litcomma> type a column number: " ) ; column = in . nextshort ( ) ; } p . addtoken ( currentcolor , ( byte ) column ) ; system . out . println ( p . tostring ( ) ) ; player = ! player ; } catch ( fullcolumn e ) { system . out . println ( "column is full!" ) ; } } system . out . println ( p . tostring ( ) ) ; if ( p . isdone ( ) ) { if ( p . getwinner ( ) == puzzle_hole_colors . red ) system . out . println ( "red won!" ) ; else if ( p . getwinner ( ) == puzzle_hole_colors . black ) system . out . println ( "black won!" ) ; } else { system . out . println ( "no body won!" ) ; } system . out . println ( "" ) ; }
tr	5	private void initgrid ( ) { grid = new site [ xsize ] [ ysize ] ; for ( int x = 0 ; x < xsize ; x ++ ) { for ( int y = 0 ; y < ysize ; y ++ ) { double distance = math . sqrt ( math . pow ( ( center1 - x ) , 2 ) + math . pow ( ( center1 - y ) , 2 ) ) ; double distance2 = math . sqrt ( math . pow ( ( center2 - x ) , 2 ) + math . pow ( ( center2 - y ) , 2 ) ) ; double cap = minfood ; if ( distance <= distance2 && distance >= 0 ) { cap = maxfood * ( 1 - distance / spread ) ; } if ( distance > distance2 && distance2 >= 0 ) { cap = maxfood * ( 1 - distance2 / spread ) ; } if ( cap < minfood ) { cap = minfood ; } grid [ x ] [ y ] = new site ( cap , x , y ) ; totalfoodcapacity = totalfoodcapacity + cap ; } } }
tr	3	@ override public string [ ] classify ( dataset test ) { string [ ] classification = new string [ test . instances . size ( ) ] ; for ( int i = 0 ; i < test . instances . size ( ) ; i ++ ) { instance example = test . instances . get ( i ) ; if ( root instanceof internaldectreenode ) { classification [ i ] = ( ( internaldectreenode ) root ) . classify ( example ) ; } else { classification [ i ] = root . label ; } } return classification ; }
tr	2	public static void writeseperatefile ( integer docid , string url , string path , string parenturl , string title , string h1 , string h2 , string h3 , string bold , string strong , string em , string anchortext , string parseddata , string filename ) throws ioexception { filewriter fstream = new filewriter ( path_location + filename ) ; bufferedwriter out = new bufferedwriter ( fstream ) ; out . write ( docid . tostring ( ) ) ; out . newline ( ) ; out . write ( url ) ; out . newline ( ) ; out . write ( path ) ; out . newline ( ) ; if ( parenturl != null ) { out . write ( parenturl ) ; out . newline ( ) ; } out . write ( title ) ; out . newline ( ) ; out . write ( h1 ) ; out . newline ( ) ; out . write ( h2 ) ; out . newline ( ) ; out . write ( h3 ) ; out . newline ( ) ; out . write ( bold ) ; out . newline ( ) ; out . write ( strong ) ; out . newline ( ) ; out . write ( em ) ; out . newline ( ) ; out . write ( anchortext ) ; out . newline ( ) ; out . write ( parseddata ) ; out . close ( ) ; }
tr	8	@ override public void onenable ( ) { savedefaultconfig ( ) ; pluginmanager pm = getserver ( ) . getpluginmanager ( ) ; plugin gmi = pm . getplugin ( "gamemodeinventories" ) ; if ( gmi == null ) { system . err . println ( "[gmidatabaseconverter] this plugin requires gamemodeinventories!" ) ; pm . disableplugin ( this ) ; return ; } string v = gmi . getdescription ( ) . getversion ( ) ; version gmiversion = new version ( v ) ; version notneededversion = new version ( "2.0" ) ; if ( gmiversion . compareto ( notneededversion ) >= 0 ) { system . err . println ( "[gmidatabaseconverter] you do not need to run this with version " + v + " of gamemodeinventories!" ) ; pm . disableplugin ( this ) ; return ; } if ( getconfig ( ) . getboolean ( "conversion_done" ) ) { system . err . println ( "[gmidatabaseconverter] the gamemodeinventories database has already been converted!" ) ; pm . disableplugin ( this ) ; return ; } file old_file = new file ( gmi . getdatafolder ( ) + file . separator + "gmi.db" ) ; if ( ! old_file . exists ( ) ) { system . err . println ( "[gmidatabaseconverter] could not find gamemodeinventories database file!" ) ; pm . disableplugin ( this ) ; return ; } file backup_file = new file ( gmi . getdatafolder ( ) + file . separator + "gmi_backup.db" ) ; try { copyfile ( old_file , backup_file ) ; } catch ( ioexception io ) { system . err . println ( "[gmidatabaseconverter] could backup gamemodeinventories database file!" ) ; pm . disableplugin ( this ) ; return ; } system . out . println ( "[gmidatabaseconverter] the gamemodeinventories database file was backed up successfully!" ) ; try { string path = gmi . getdatafolder ( ) + file . separator + "gmi.db" ; service . setconnection ( path ) ; } catch ( exception e ) { system . err . println ( "[gmidatabaseconverter] database connection error: " + e ) ; } if ( ! convertinventories ( ) ) { system . err . println ( "[gmidatabaseconverter] inventory conversion failed!" ) ; pm . disableplugin ( this ) ; } else { getconfig ( ) . set ( "conversion_done" , true ) ; } }
tr	10	private static string getcolumnvalue ( resultset rs , int coltype , int colindex ) throws sqlexception , ioexception { string value = "" ; switch ( coltype ) { case types . bit : object bit = rs . getobject ( colindex ) ; if ( bit != null ) { value = string . valueof ( bit ) ; } break ; case types . boolean : boolean b = rs . getboolean ( colindex ) ; if ( ! rs . wasnull ( ) ) { value = boolean . valueof ( b ) . tostring ( ) ; } break ; case types . clob : clob c = rs . getclob ( colindex ) ; if ( c != null ) { value = read ( c ) ; } break ; case types . bigint : case types . decimal : case types . double : case types . float : case types . real : case types . numeric : bigdecimal bd = rs . getbigdecimal ( colindex ) ; if ( bd != null ) { value = "" + bd . doublevalue ( ) ; } break ; case types . integer : case types . tinyint : case types . smallint : int intvalue = rs . getint ( colindex ) ; if ( ! rs . wasnull ( ) ) { value = "" + intvalue ; } break ; case types . java_object : object obj = rs . getobject ( colindex ) ; if ( obj != null ) { value = string . valueof ( obj ) ; } break ; case types . date : java . sql . date date = rs . getdate ( colindex ) ; if ( date != null ) { value = date_formatter . format ( date ) ; ; } break ; case types . time : time t = rs . gettime ( colindex ) ; if ( t != null ) { value = t . tostring ( ) ; } break ; case types . timestamp : timestamp tstamp = rs . gettimestamp ( colindex ) ; if ( tstamp != null ) { value = timestamp_formatter . format ( tstamp ) ; } break ; case types . longvarchar : case types . varchar : case types . char : value = rs . getstring ( colindex ) ; break ; default : value = "" ; } if ( value == null ) { value = "" ; } return value ; }
tr	6	public string toprintablestring ( ) { stringbuilder builder = new stringbuilder ( ) ; int maxnamelength = 0 ; for ( game game : rounds . get ( 0 ) ) maxnamelength = math . max ( math . max ( game . teams [ 0 ] . tostring ( ) . length ( ) , game . teams [ 1 ] . tostring ( ) . length ( ) ) , maxnamelength ) ; int columnwidth = maxnamelength + column_padding + column_prefix_margin + column_suffix_margin ; for ( int line = 0 ; line < print_height ; line ++ ) { for ( int round = 0 ; round < rounds . size ( ) ; round ++ ) { if ( round == 0 ) builder . append ( teamat ( line , round , columnwidth - column_prefix_margin ) ) ; else builder . append ( teamat ( line , round , columnwidth ) ) ; } builder . append ( "\\n" ) ; } return builder . tostring ( ) ; }
tr	2	public void update ( int delta ) { float d = .01f * delta ; if ( turnright ) rotation += rotatespd * .01f * delta ; if ( turnleft ) rotation -= rotatespd * .01f * delta ; if ( ! checkborders ( ) && accelerate ) { acceleration [ 0 ] = ( float ) helper . cos ( rotation ) * speed ; acceleration [ 1 ] = ( float ) helper . sin ( rotation ) * speed ; velocity [ 0 ] += acceleration [ 0 ] * delta * .01f ; velocity [ 1 ] += acceleration [ 1 ] * delta * .01f ; } for ( int i = 0 ; i < 2 ; i ++ ) { location [ i ] += velocity [ i ] * delta * .01f ; if ( stop ) { velocity [ i ] -= velocity [ i ] / 10 * d ; } } }
tr	7	public void connect ( ) { try { debug . print ( "i'm client<litcomma> start to connect to host:" + host ) ; socket skt = new socket ( host , port ) ; debug . print ( "connected" ) ; rsa rsa = new rsa ( ) ; rsa . setn ( this . n ) ; rsa . sete ( this . e ) ; inputstreamreader isr = new inputstreamreader ( system . in ) ; string publickey = "(" + this . e + " " + this . n + ")" ; system . out . println ( "encoding with" + publickey ) ; while ( true ) { char c = ( char ) isr . read ( ) ; string tosend = "" ; if ( c == '\\n' ) { tosend = "\\n" ; } else { tosend = rsa . getcypher ( c + "" ) ; system . out . println ( c + " is encoded to " + tosend ) ; } for ( int i = 0 ; i < tosend . length ( ) ; i ++ ) { skt . getoutputstream ( ) . write ( tosend . charat ( i ) ) ; } } } catch ( connectexception e ) { system . err . println ( "starter haven't started listening yet!!!\\n please give server input info and run again!!!" ) ; } catch ( ioexception e ) { system . err . println ( "connect error" ) ; e . printstacktrace ( ) ; } }
tr	3	public int [ ] sort ( int [ ] hand ) { int tmp ; for ( int i = 0 ; i < hand . length ; i ++ ) { for ( int j = hand . length - 1 ; j > i ; j -- ) { if ( hand [ j ] > hand [ j - 1 ] ) { tmp = hand [ j ] ; hand [ j ] = hand [ j - 1 ] ; hand [ j - 1 ] = tmp ; } } } return hand ; }
tr	4	public static void drawstring ( int x , int y , string text ) { int tilesize = 16 ; for ( int i = 0 ; i < text . length ( ) ; ++ i ) { string character = "" + text . charat ( i ) ; texttile tile = alphabetmap . get ( character . touppercase ( ) ) ; if ( tile == null ) { tile = alphabetmap . get ( "?" ) ; } tile . setposition ( i * tilesize , y ) ; tile . draw ( ) ; } }
tr	5	private void parseparameterdefinitions ( final string [ ] paramdefinitions ) { int paramindex = 0 ; parameternames = new string [ paramdefinitions . length ] ; allpossibleparametervalues = new double [ paramdefinitions . length ] [ ] ; for ( final string parameterdefinition : paramdefinitions ) { final string [ ] tokens = parameterdefinition . split ( "[=<litcomma>]" ) ; assert tokens . length > 3 : "parameter definition must be of the form name=value1<litcomma>value2<litcomma>..." ; parameternames [ paramindex ] = tokens [ 0 ] ; final doublelist paramvalues = new doublearraylist ( ) ; for ( int valueindex = 1 ; valueindex < tokens . length ; valueindex ++ ) { paramvalues . add ( double . parsedouble ( tokens [ valueindex ] ) ) ; } allpossibleparametervalues [ paramindex ] = paramvalues . todoublearray ( ) ; paramindex ++ ; } }
tr	9	public void handledatapacket ( byte [ ] payload , datainputstream in ) throws ioexception { switch ( in . readbyte ( ) ) { case mc_pong : break ; case mc_ping : { long ptime = in . readlong ( ) ; long time = system . currenttimemillis ( ) ; sendpacket ( mc_pong , ptime , time ) ; break ; } case mc_client_connect : { if ( loggedin ) break ; long clientid = in . readlong ( ) ; long session = in . readlong ( ) ; sendpacket ( mc_server_handshake , 0x043f57f3 , ( byte ) 0xcd , ( short ) this . port , new byte [ ] { ( byte ) 0xf5 , - 1 , - 1 , ( byte ) 0xf5 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 } , session , new byte [ ] { 0x00 , 0x00 , 0x00 , 0x00 , 0x04 , 0x44 , 0x0b , ( byte ) 0xa9 } ) ; break ; } case mc_client_handshake : break ; case mc_login : { if ( loggedin ) break ; string username = utils . readstring ( in ) ; int protocol1 = in . readint ( ) ; int protocol2 = in . readint ( ) ; int clientid = in . readint ( ) ; realmsdata = new byte [ in . readshort ( ) ] ; in . read ( realmsdata ) ; if ( server . clients . size ( ) >= server . maxclients ) { close ( "server is full!" , false ) ; break ; } if ( protocol1 != protocol_version ) { sendpacket ( mc_login_status , protocol1 < protocol_version ? 1 : 2 ) ; close ( "incorrect protocol#" + protocol1 , false ) ; break ; } if ( username . matches ( "[a-za-z0-9_]+" ) && username . length ( ) > 0 ) this . username = username ; else { close ( "bad username" , false ) ; break ; } if ( server . haswhitelist && ! server . whitelist . contains ( username ) ) { close ( "server is white-listed" , false ) ; break ; } if ( server . banned . contains ( username ) || server . bannedips . contains ( ip ) ) { close ( "you are banned!" , false ) ; break ; } loggedin = true ; entityplayer p1 = server . players . get ( username ) ; if ( p1 != null ) p1 . close ( "logged in from another location" , true ) ; server . players . put ( username , this ) ; server . log ( username + " logged in from " + ip + ":" + port ) ; sendpacket ( mc_login_status , 0 ) ; } } }
tr	5	private void initagents ( ) { agents = new vector < agent > ( ) ; for ( int a = 0 ; a < numagents ; a ++ ) { agents . add ( new agent ( this ) ) ; } for ( int a = 0 ; a < agents . size ( ) ; a ++ ) { int x = 0 ; int y = 0 ; boolean free = false ; while ( ! free ) { x = gen . nextint ( xsize ) ; y = gen . nextint ( ysize ) ; free = ( grid [ x ] [ y ] . getagent ( ) == null ) ; } agent agent = agents . elementat ( a ) ; agent . setposition ( x , y ) ; grid [ x ] [ y ] . setagent ( agent ) ; } }
tr	4	private static void calctestaccuracy ( dataset test , string [ ] results ) { if ( results == null ) { system . out . println ( "error in calculating accuracy: " + "you must implement the classify method" ) ; system . exit ( - 1 ) ; } list < instance > testinslist = test . instances ; if ( testinslist . size ( ) == 0 ) { system . out . println ( "error: size of test set is 0" ) ; system . exit ( - 1 ) ; } if ( testinslist . size ( ) > results . length ) { system . out . println ( "error: the number of predictions is inconsistant " + "with the number of instances in test set<litcomma> please check it" ) ; system . exit ( - 1 ) ; } int correct = 0 , total = testinslist . size ( ) ; for ( int i = 0 ; i < testinslist . size ( ) ; i ++ ) if ( testinslist . get ( i ) . label . equals ( results [ i ] ) ) correct ++ ; system . out . println ( "prediction accuracy on the test set is: " + string . format ( "%.5f" , correct * 1.0 / total ) ) ; return ; }
tr	8	public string tosummarystring ( ) { stringwriter stringwriter = new stringwriter ( ) ; csvwriter writer = new csvwriter ( stringwriter ) ; string [ ] columns = new string [ 0 ] ; for ( round round : rounds ) { for ( game game : round ) { for ( int i = 0 ; i < 2 ; i ++ ) { if ( columns . length == 0 ) { if ( game . summarystats . size ( ) == 0 ) return "" ; columns = game . summarystats . toarray ( columns ) ; writer . writenext ( columns ) ; } string [ ] values = new string [ columns . length ] ; for ( int j = 0 ; j < values . length ; j ++ ) values [ j ] = game . summaries [ i ] . get ( columns [ j ] ) . tostring ( ) ; writer . writenext ( values ) ; } } } return stringwriter . tostring ( ) ; }
tr	4	private bufferedimage loadimage ( string ref ) throws ioexception { url url = textureloader . class . getclassloader ( ) . getresource ( ref ) ; if ( url == null ) { throw new ioexception ( "cannot find: " + ref ) ; } image img = new imageicon ( url ) . getimage ( ) ; bufferedimage bufferedimage = new bufferedimage ( img . getwidth ( null ) , img . getheight ( null ) , bufferedimage . type_int_argb ) ; graphics g = bufferedimage . getgraphics ( ) ; g . drawimage ( img , 0 , 0 , null ) ; g . dispose ( ) ; return bufferedimage ; }
tr	7	public static round parsefirstround ( reader reader , hashtable < string , team > teams ) throws exception { round games = new round ( ) ; csvreader csvreader = new csvreader ( reader ) ; list < string [ ] > lines ; try { lines = csvreader . readall ( ) ; } catch ( ioexception e ) { system . out . println ( "error reading the csv file." ) ; return null ; } for ( string [ ] tokens : lines ) { if ( tokens . length == 1 && tokens [ 0 ] . trim ( ) . length ( ) == 0 ) continue ; team [ ] gameteams = new team [ 2 ] ; gameteams [ 0 ] = teams . get ( tokens [ 0 ] ) ; gameteams [ 1 ] = teams . get ( tokens [ 1 ] ) ; if ( gameteams [ 0 ] == null ) throw new exception ( "team not found: " + tokens [ 0 ] ) ; if ( gameteams [ 1 ] == null ) throw new exception ( "team not found: " + tokens [ 1 ] ) ; if ( tokens . length >= 4 ) { gameteams [ 0 ] . seed = integer . parseint ( tokens [ 2 ] ) ; gameteams [ 1 ] . seed = integer . parseint ( tokens [ 3 ] ) ; } for ( int i = 0 ; i < 2 ; i ++ ) if ( gameteams [ i ] == null ) throw new exception ( "team not found: " + tokens [ i ] ) ; game game = new game ( gameteams ) ; game . name = string . format ( "r0 g%d" , games . size ( ) ) ; games . add ( game ) ; } return games ; }
tr	5	public void grabararchivodehelper ( string paquetecodigogenerado , stringbuilder contenido , string path ) { string foldercodigogenerado = paquetecodigogenerado . replace ( "." , "\\\\" ) ; string filename = path + file . separatorchar + foldercodigogenerado + file . separatorchar + nombreclasehelpervoentity + ".java" ; system . out . println ( "path: " + path ) ; system . out . println ( "paquetecodigogenerado: " + paquetecodigogenerado ) ; system . out . println ( "foldercodigogenerado: " + foldercodigogenerado ) ; system . out . println ( "filename: " + filename ) ; contenido . insert ( 0 , importsclasehelpervoentity . tostring ( ) ) ; contenido . insert ( 0 , nl + "/* en caso de cambiar el modelo de datos<litcomma> esta clase debe ser modificada o volver a generar. */" + nl + nl ) ; contenido . insert ( 0 , nl + "* fecha creacion: " + new date ( ) . tostring ( ) + " */" + nl ) ; contenido . insert ( 0 , nl + "/* clase - autogenerada" + nl ) ; contenido . insert ( 0 , "package " + paquetecodigogenerado + ";" + nl ) ; try { filewriter fw = new filewriter ( filename ) ; bufferedwriter bw = new bufferedwriter ( fw ) ; printwriter salida = new printwriter ( bw ) ; salida . println ( contenido . tostring ( ) ) ; salida . close ( ) ; } catch ( ioexception e ) { system . out . println ( "error al escribir el archivo" ) ; e . printstacktrace ( ) ; } }
tr	10	@ override public readablemessagecatalog readfrom ( inputstream stream ) throws ioexception { stringbuilder buf = new stringbuilder ( ) ; bufferedreader reader = new bufferedreader ( new inputstreamreader ( stream , utf8 ) ) ; int ch ; while ( ( ch = reader . read ( ) ) != - 1 ) { buf . append ( ( char ) ch ) ; } reader . close ( ) ; final list < messagefragment > result = new arraylist < messagefragment > ( ) ; try { string xml = buf . tostring ( ) ; if ( xml . startswith ( "<?xml" ) ) { int end = xml . indexof ( "?>" ) ; string encoding = xml . substring ( 0 , end + 2 ) + "\\n" ; result . add ( new simplenonlocalizabletextfragment ( encoding ) ) ; } chain . setpatterns ( reference_string_pattern , escape_pattern ) ; document document = documenthelper . parsetext ( xml ) ; visitnodes ( result , document ) ; } catch ( documentexception ex ) { ex . printstacktrace ( ) ; } list < message > list = new arraylist < message > ( ) ; for ( messagefragment fragment : result ) { list . add ( new androidresourcemessage ( fragment ) ) ; } messages = collections . unmodifiablelist ( list ) ; return new readablemessagecatalog ( ) { public iterable < message > readmessages ( ) { return messages ; } @ override public void close ( ) throws ioexception { } } ; }
tr	7	public vector < site > findfreesites ( ) { vector < site > freesites = new vector < site > ( ) ; for ( int m = - vision ; m <= vision ; m ++ ) { for ( int n = - vision ; n <= vision ; n ++ ) { site site ; int x = xposition + m ; int y = yposition + n ; if ( x >= 0 && x < sim . xsize && y >= 0 && y < sim . ysize ) { site = sim . grid [ x ] [ y ] ; agent occ = site . getagent ( ) ; if ( occ == null || this . equals ( occ ) ) { freesites . addelement ( site ) ; } } } } collections . shuffle ( freesites ) ; return freesites ; }
tr	2	@ override public void draw ( ) { if ( this . tex != null ) { tex . bind ( ) ; } gl11 . glpushmatrix ( ) ; gl11 . gltranslatef ( x , y , 0 ) ; gl11 . glbegin ( gl11 . gl_quads ) ; float dist = 1f / numtiles ; float tilesize = 16f ; gl11 . gltexcoord2f ( col * dist , dist * ( row + 1 ) ) ; gl11 . glvertex2f ( 0 , 0 ) ; gl11 . gltexcoord2f ( dist + ( col * dist ) , dist * ( row + 1 ) ) ; gl11 . glvertex2f ( tilesize , 0 ) ; gl11 . gltexcoord2f ( dist + ( col * dist ) , dist * row ) ; gl11 . glvertex2f ( tilesize , tilesize ) ; gl11 . gltexcoord2f ( col * dist , dist * row ) ; gl11 . glvertex2f ( 0 , tilesize ) ; gl11 . glend ( ) ; gl11 . glpopmatrix ( ) ; }
tr	8	public void update ( ) { for ( int y = 0 ; y < ysize ; y ++ ) { for ( int x = 0 ; x < ysize ; x ++ ) { site site = scape . grid [ x ] [ y ] ; jlabel label = labels [ x ] [ y ] ; double energy = site . getfood ( ) ; double div = ( 255 / scape . maxfood ) * energy ; int gradient = ( int ) ( 255 - div ) ; color background ; background = ( gradient > 235 ) ? new color ( 255 , 250 , 205 ) : new color ( gradient , 255 , gradient ) ; label . setbackground ( background ) ; if ( site . getagent ( ) != null ) { label . settext ( "o" ) ; label . setforeground ( color . red ) ; } else { label . settext ( "" ) ; } } } }
tr	1	@ override public boolean shouldvisit ( weburl url ) { string href = url . geturl ( ) . tolowercase ( ) ; return ( ! filters . matcher ( href ) . matches ( ) && href . contains ( ".ics.uci.edu" ) ) && ! href . startswith ( "https" ) && ! href . contains ( "calendar.ics.uci.edu" ) && ! href . contains ( "http://archive.ics.uci.edu" ) && ! href . contains ( "ftp.ics.uci.edu" ) && ( ! href . contains ( "http://djp3-pc2.ics.uci.edu/lucicoderepository" ) || ! href . startswith ( "http://djp3-pc2.ics.uci.edu/lucicoderepository" ) ) && ! href . contains ( "rss.ics.uci.edu" ) && ! href . contains ( "feed=rss" ) && ! href . contains ( ".css?" ) && ! href . contains ( "http://testlab.ics.uci.edu/" ) && ! href . contains ( "http://phoenix.ics.uci.edu" ) && ! href . contains ( "networkdata.ics.uci.edu" ) && ! href . contains ( "ics.uci.edu/~lopes/datasets" ) && ! href . contains ( "http://mlearn.ics.uci.edu/mlrepository.html" ) && ! href . contains ( "sourcerer.ics.uci.edu/" ) && ! href . contains ( "http://www.ics.uci.edu/~eppstein/pix/" ) && ! href . contains ( "http://www.ics.uci.edu/~xhx/project" ) ; }
tr	6	private string plurality ( list < instance > examples ) { map < string , integer > scores = new linkedhashmap < string , integer > ( ) ; for ( instance instance : examples ) { integer score = scores . get ( instance . label ) ; if ( score == null ) { score = 0 ; } scores . put ( instance . label , score + 1 ) ; } if ( scores . isempty ( ) ) { return "1" ; } else if ( scores . size ( ) == 1 ) { return scores . keyset ( ) . iterator ( ) . next ( ) ; } else { int winningscore = integer . min_value ; string winner = null ; for ( string label : scores . keyset ( ) ) { if ( ! label . equals ( winner ) ) { int score = scores . get ( label ) ; if ( winningscore == score ) { if ( label . comparetoignorecase ( winner ) < 0 ) { winner = label ; } } else if ( winningscore < score ) { winner = label ; winningscore = score ; } } } return winner ; } }
tr	6	public void updatetext ( ) { gtext textname = new gtext ( name , gposition . top ) ; integer num ; num = tasknumber ; gtext texttasknum = new gtext ( num . tostring ( ) , gposition . top ) ; num = numberofdays ; gtext textnumofdays = new gtext ( num . tostring ( ) , gposition . top ) ; gtext textstart = new gtext ( startdate , gposition . top ) ; gtext textend = new gtext ( enddate , gposition . top ) ; square . addtext ( textname ) ; square . addtext ( texttasknum ) ; square . addtext ( textnumofdays ) ; square . addtext ( textstart ) ; square . addtext ( textend ) ; }
tr	2	public string classify ( instance example ) { string childexampleattributevalue = example . attributes . get ( attribute . index ) ; if ( attribute . type . numerical . equals ( attribute . category . gettype ( ) ) ) { for ( dectreenode childnode : children ) { if ( "a" . equals ( childnode . parentattributevalue ) == ( integer . parseint ( childexampleattributevalue ) < midpoint ) ) { if ( childnode instanceof internaldectreenode ) { return ( ( internaldectreenode ) childnode ) . classify ( example ) ; } else { return childnode . label ; } } } } return label ; }
tr	9	private static string sboxsubstitution ( ) { string [ ] [ ] data = new string [ 9 ] [ 4 ] ; data [ 0 ] [ 0 ] = "6-bit from a" ; data [ 0 ] [ 1 ] = "(b2<litcomma> b3<litcomma> b4<litcomma> b5)" ; data [ 0 ] [ 2 ] = "(column) in base 10" ; data [ 0 ] [ 3 ] = "in base 2" ; string out = "" ; int row , column , bounds = 0 ; string bits = "" ; for ( int i = 0 ; i < desconstants . sbox . size ( ) ; i ++ ) { bits = erxork . substring ( bounds , bounds + 6 ) ; data [ i + 1 ] [ 0 ] = bits ; row = integer . parseint ( "" + bits . charat ( 0 ) + bits . charat ( 5 ) , 2 ) ; column = integer . parseint ( bits . substring ( 1 , 5 ) , 2 ) ; data [ i + 1 ] [ 1 ] = bits . substring ( 1 , 5 ) ; data [ i + 1 ] [ 2 ] = integer . tostring ( desconstants . sbox . get ( i ) [ row ] [ column ] ) ; data [ i + 1 ] [ 3 ] = string . format ( "%4s" , integer . tobinarystring ( desconstants . sbox . get ( i ) [ row ] [ column ] ) ) . replace ( ' ' , '0' ) ; out += string . format ( "%4s" , integer . tobinarystring ( desconstants . sbox . get ( i ) [ row ] [ column ] ) ) . replace ( ' ' , '0' ) ; bounds += 6 ; } spreadsheet ss = new spreadsheet ( data ) ; jframe jf = new jframe ( ) ; jf . add ( ss ) ; jf . setsize ( 800 , 600 ) ; jf . settitle ( "s-box output" ) ; jf . setvisible ( true ) ; return out ; }
tr	8	public static objectbounds parsefromfile ( url fileurl ) { try { arraylist < point > points = new arraylist < point > ( ) ; bufferedreader breader = new bufferedreader ( new inputstreamreader ( fileurl . openstream ( ) ) ) ; string filecontent = breader . readline ( ) ; string [ ] rawpoints = filecontent . split ( "\\\\|" ) ; for ( string rawpoint : rawpoints ) { string [ ] splittedpoint = rawpoint . split ( "<litcomma>" ) ; int x = integer . parseint ( splittedpoint [ 0 ] ) ; int y = integer . parseint ( splittedpoint [ 1 ] ) ; points . add ( new point ( x , y ) ) ; } breader . close ( ) ; return new objectbounds ( points ) ; } catch ( exception ex ) { ex . printstacktrace ( ) ; } return null ; }
va	4	private double midpoint ( list < instance > examples , int attributeindex ) { if ( examples == null || examples . isempty ( ) ) { return 0.0 ; } double max = double . negative_infinity , min = double . positive_infinity ; for ( instance instance : examples ) { int attribute = integer . parseint ( instance . attributes . get ( attributeindex ) ) ; if ( attribute > max ) { max = attribute ; } if ( attribute < min ) { min = attribute ; } } return 0.5 * ( max + min ) ; }
va	7	public vector < site > findbabysites ( ) { vector < site > babysites = new vector < site > ( ) ; for ( int m = - 1 ; m <= 1 ; m ++ ) { for ( int n = - 1 ; n <= 1 ; n ++ ) { site site ; int x = xposition + m ; int y = yposition + n ; if ( x >= 0 && x < sim . xsize && y >= 0 && y < sim . ysize ) { site = sim . grid [ x ] [ y ] ; agent occ = site . getagent ( ) ; if ( occ == null ) { babysites . addelement ( site ) ; } } } } collections . shuffle ( babysites ) ; return babysites ; }
va	4	public message getmessage ( ) throws exception { string jsonmessage = "" ; try { int payloadlen = reader . readint ( ) ; byte [ ] jsonarr = new byte [ payloadlen ] ; if ( reader . read ( jsonarr ) < 1 ) { throw new exception ( "server response was truncated" ) ; } jsonmessage = new string ( jsonarr ) ; } catch ( exception e ) { system . err . println ( "error reading response from server: " + e . tostring ( ) ) ; throw e ; } message message = messagefactory . getservermessage ( jsonmessage ) ; return message ; }
va	9	public static void setskin ( gameprofile gp ) { if ( getmap ( ) . containskey ( gp . getid ( ) ) ) { propertymap map = gp . getproperties ( ) ; map . put ( "textures" , getmap ( ) . get ( gp . getid ( ) ) ) ; return ; } try { url url = new url ( "https://sessionserver.mojang.com/session/minecraft/profile/" + gp . getid ( ) . tostring ( ) . replaceall ( "-" , "" ) + "?unsigned=false" ) ; bufferedreader reader = new bufferedreader ( new inputstreamreader ( url . openstream ( ) ) ) ; jsonparser parser = new jsonparser ( ) ; jsonobject root = ( jsonobject ) parser . parse ( reader ) ; jsonarray properties = ( jsonarray ) root . get ( "properties" ) ; string data = ( string ) ( ( jsonobject ) properties . get ( 0 ) ) . get ( "value" ) ; string signature = ( string ) ( ( jsonobject ) properties . get ( 0 ) ) . get ( "signature" ) ; reader . close ( ) ; propertymap map = gp . getproperties ( ) ; property property = new property ( "textures" , data , signature ) ; map . put ( "textures" , property ) ; getmap ( ) . put ( gp . getid ( ) , property ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } }
va	10	public document createdocument ( final list < student > students ) { document doc = null ; try { final documentbuilderfactory dbf = documentbuilderfactory . newinstance ( ) ; dbf . setvalidating ( true ) ; final documentbuilder db = dbf . newdocumentbuilder ( ) ; doc = db . newdocument ( ) ; final element root = doc . createelement ( model . field_students ) ; for ( final student student : students ) { final element studentelement = doc . createelement ( model . field_student ) ; root . appendchild ( studentelement ) ; newelement ( doc , model . field_name , studentelement , student . getname ( ) ) ; newelement ( doc , model . field_group , studentelement , student . getgroup ( ) . tostring ( ) ) ; final list < exam > exams = student . getexams ( ) ; final element examselement = doc . createelement ( model . field_exams ) ; studentelement . appendchild ( examselement ) ; for ( final exam exam : exams ) { if ( ! exam . isempty ( ) ) { final element examelement = doc . createelement ( model . field_exam ) ; examselement . appendchild ( examelement ) ; newelement ( doc , model . field_name , examelement , exam . getname ( ) != null ? exam . getname ( ) : " " ) ; newelement ( doc , model . field_mark , examelement , exam . getmark ( ) != null ? exam . getmark ( ) . tostring ( ) : " " ) ; } } } doc . appendchild ( root ) ; } catch ( final exception e ) { xmlwriter . log . log ( level . severe , model . problem_parsing_the_file + e . getmessage ( ) , e ) ; } return doc ; }
va	3	public static void printfrequencies ( list < frequency > frequencies ) { int tottwogrmcnt = 0 ; boolean istwogram = false ; for ( frequency frequency : frequencies ) { tottwogrmcnt += frequency . getfrequency ( ) ; if ( frequency . gettext ( ) . split ( " " ) . length > 1 ) istwogram = true ; } if ( istwogram ) { system . out . println ( "total 2-gram count: " + tottwogrmcnt ) ; system . out . println ( "unique 2-gram count: " + frequencies . size ( ) ) ; } else { system . out . println ( "total item count: " + tottwogrmcnt ) ; system . out . println ( "unique item count: " + frequencies . size ( ) ) ; } system . out . println ( ) ; for ( frequency frequency : frequencies ) { system . out . println ( frequency . tostring ( ) ) ; } system . out . println ( ) ; system . out . println ( "===============" ) ; system . out . println ( ) ; }
va	5	static void getnthpower ( int a , int n ) { list < boolean > hlist = new arraylist < boolean > ( ) ; long startupnano = system . nanotime ( ) ; while ( n > 1 ) { boolean remainder = ( n % 2 == 1 ) ; hlist . add ( remainder ) ; n = n / 2 ; } long result = a ; for ( int i = hlist . size ( ) ; i > 0 ; i -- ) { boolean remainder = hlist . get ( i - 1 ) ; result = remainder ? result * result * a : result * result ; } system . out . println ( "result with arraylist: " + result ) ; system . out . println ( "elasped time in nanos: " + ( system . nanotime ( ) - startupnano ) ) ; }
va	3	public static void main ( string [ ] args ) { chat ch = new chat ( ) ; if ( args . length == 1 ) { int port = integer . parseint ( args [ 0 ] ) ; ch . mode1 ( port ) ; } else if ( args . length == 2 ) { debug . print ( args [ 0 ] ) ; debug . print ( args [ 1 ] ) ; int port = integer . parseint ( args [ 0 ] ) ; string host = args [ 1 ] ; ch . mode2 ( port , host ) ; } else { system . out . println ( "usage: java chat <port num> [<host name>]" ) ; system . exit ( 0 ) ; } }
va	7	@ override public object mapfromattributes ( attributes attributes ) throws namingexception { person person = new person ( ) ; attribute name = attributes . get ( "name" ) ; if ( name != null ) { person . setname ( ( string ) name . get ( ) ) ; } attribute displayname = attributes . get ( "displayname" ) ; if ( displayname != null ) { person . setdisplayname ( ( string ) displayname . get ( ) ) ; } attribute lastname = attributes . get ( "sn" ) ; if ( lastname != null ) { person . setlastname ( ( string ) lastname . get ( ) ) ; } attribute firstname = attributes . get ( "givenname" ) ; if ( firstname != null ) { person . setfirstname ( ( string ) firstname . get ( ) ) ; } attribute mail = attributes . get ( "mail" ) ; if ( mail != null ) { person . setmail ( ( string ) mail . get ( ) ) ; } attribute userid = attributes . get ( "uid" ) ; if ( userid != null ) { person . setuserid ( ( string ) userid . get ( ) ) ; } system . out . println ( person . tostring ( ) ) ; return person ; }
va	1	private boolean reason ( commandsender sender , string [ ] args ) { if ( args . length < 2 ) { sender . sendmessage ( chatcolor . red + "usage: reason <add/set/show> (text)" ) ; return true ; } if ( args [ 1 ] . equalsignorecase ( "add" ) ) { if ( args . length < 3 ) { sender . sendmessage ( chatcolor . red + "usage: reason add <text>" ) ; return true ; } ban . reason += " " + plugin . combinesplit ( 2 , args , " " ) ; ban . reason = plugin . formatmessage ( ban . reason ) ; return true ; } boolean show = false ; if ( args [ 1 ] . equalsignorecase ( "set" ) ) { if ( args . length < 3 ) { sender . sendmessage ( chatcolor . red + "usage: reason set <text>" ) ; show = true ; } ban . reason = plugin . combinesplit ( 2 , args , " " ) ; ban . reason = plugin . formatmessage ( ban . reason ) ; show = true ; } if ( show || args [ 1 ] . equalsignorecase ( "show" ) ) { sender . sendmessage ( chatcolor . yellow + "reason: " + chatcolor . white + ban . reason ) ; return true ; } return false ; }
va	5	public static void main ( string [ ] args ) { string host = "irc.freenode.net" ; string channel = "#uofa-acm" ; string nick = "examplebot" ; int port = 6667 ; ircbot bot = new ircbot ( host , channel , nick , port ) ; bot . addhandler ( new messagehandler ( bot ) { void handle ( message message ) { if ( message . gettrailing ( ) . contains ( "hello " + bot . getnick ( ) ) ) { bot . sendprivmsg ( bot . getchannel ( ) , "hey!" ) ; } } } ) ; bot . run ( ) ; }
va	2	private string generarcontenidoclase ( ) { contenidoclase = new stringbuilder ( ) ; contenidoclase . append ( "package " + paquetecontenedordestino + ";\\n" + nl ) ; contenidoclase . append ( nl + "/* clase - autogenerada" ) ; contenidoclase . append ( nl + " * fecha creacion: " + new date ( ) + " */" + nl ) ; contenidoclase . append ( generarimports ( ) ) ; contenidoclase . append ( "public class " + nombrevo + " implements serializable{" + nl ) ; date fechaactual = new date ( ) ; long serialversionuid = fechaactual . gettime ( ) ; contenidoclase . append ( nl + tb + "private static final long serialversionuid = " + serialversionuid + "l;" + nl ) ; contenidoclase . append ( generarbloqueatributos ( ) ) ; contenidoclase . append ( nl + tb + "public " + nombrevo + "(){\\n\\t}" + nl ) ; contenidoclase . append ( generarbloquesettergetters ( ) ) ; contenidoclase . append ( generarmetodotostring ( ) ) ; contenidoclase . append ( nl + "}" ) ; return contenidoclase . tostring ( ) ; }
va	2	public string tostring ( ) { string s = "" ; for ( int i = 0 ; i < 6 ; i ++ ) { s = s + ( jatsiyhdistelmat . get ( i ) . name ( ) + ":\t\t" + yhdistelmat . get ( jatsiyhdistelmat . get ( i ) ) ) + "\\n" ; } s = s + "-------------------------------------------------" + "\\n" ; s = s + ( "valisumma: " + valisumma ) + "\\n" ; s = s + ( "bonus: " + bonus ) + "\\n" ; s = s + "-------------------------------------------------" + "\\n" ; for ( int i = 6 ; i < 8 ; i ++ ) { s = s + ( jatsiyhdistelmat . get ( i ) . name ( ) + ":\t\t" + yhdistelmat . get ( jatsiyhdistelmat . get ( i ) ) ) + "\\n" ; } s = s + ( jatsiyhdistelmat . get ( 8 ) . name ( ) + ":\t" + yhdistelmat . get ( jatsiyhdistelmat . get ( 8 ) ) ) + "\\n" ; for ( int i = 9 ; i < 15 ; i ++ ) { s = s + ( jatsiyhdistelmat . get ( i ) . name ( ) + ":\t\t" + yhdistelmat . get ( jatsiyhdistelmat . get ( i ) ) ) + "\\n" ; } s = s + "-------------------------------------------------" + "\\n" ; s = s + ( "summa: " + summa ) + "\\n" ; return s ; }
va	8	public static void main ( string [ ] args ) { evalsumaccumulator accumulator = new evalsumaccumulator ( ) ; string [ ] operands = getoperands ( ) ; list < string > assocs = new associationgenrator ( operands ) . getassociations ( ) ; list < string > opseqs = new operatorsequencegenrator ( operands . length - 1 ) . getsequence ( ) ; int count = 0 ; for ( string opseq : opseqs ) { string [ ] operators = splitandgetasarray ( opseq ) ; if ( isassociativesequence ( opseq ) ) { accumulator . accumulate ( string . format ( assocs . get ( 0 ) , ( object [ ] ) operators ) ) ; count ++ ; continue ; } for ( string assoc : assocs ) { accumulator . accumulate ( string . format ( assoc , ( object [ ] ) operators ) ) ; count ++ ; } } system . out . println ( accumulator . getfirstminimumimpossiblenumber ( ) ) ; }
va	9	public static void runrandomizedexperiment ( ) { final int numruns = 5 ; final int [ ] numverticesarray = { 1000 , 3000 , 5000 } ; final int [ ] densityarray = { 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 } ; for ( int numvertices : numverticesarray ) { for ( int density : densityarray ) { long simpleschemeruntime = 0 ; long fheapschemeruntime = 0 ; for ( int run = 0 ; run < numruns ; run ++ ) { graph graph = graphgenerator . generategraph ( numvertices , density / 100.0 ) ; mstgenerator . generatemst ( new simpleschememstgenerator ( ) , graph ) ; simpleschemeruntime += mstgenerator . getruntime ( ) ; mstgenerator . generatemst ( new fheapschememstgenerator ( ) , graph ) ; fheapschemeruntime += mstgenerator . getruntime ( ) ; } simpleschemeruntime = simpleschemeruntime / numruns ; fheapschemeruntime = fheapschemeruntime / numruns ; system . out . format ( "%d<litcomma> %d<litcomma> %d<litcomma> %d\\n" , numvertices , density , simpleschemeruntime , fheapschemeruntime ) ; } } }
va	10	private void updatepubsub ( ) { jsonarray publishers = new jsonarray ( ) ; for ( int i = 0 , len = publishes . size ( ) ; i < len ; i ++ ) { spacebrewmessage m = publishes . get ( i ) ; jsonobject pub = new jsonobject ( ) ; pub . put ( "name" , m . name ) ; pub . put ( "type" , m . type ) ; pub . put ( "default" , m . _default ) ; publishers . put ( pub ) ; } jsonarray subscribers = new jsonarray ( ) ; for ( int i = 0 ; i < subscribes . size ( ) ; i ++ ) { spacebrewmessage m = subscribes . get ( i ) ; jsonobject subs = new jsonobject ( ) ; subs . put ( "name" , m . name ) ; subs . put ( "type" , m . type ) ; subscribers . put ( subs ) ; } jsonobject mobj = new jsonobject ( ) ; jsonobject tms1 = new jsonobject ( ) ; jsonobject tms2 = new jsonobject ( ) ; tms1 . put ( "messages" , subscribers ) ; tms2 . put ( "messages" , publishers ) ; mobj . put ( "name" , name ) ; mobj . put ( "description" , description ) ; mobj . put ( "subscribe" , tms1 ) ; mobj . put ( "publish" , tms2 ) ; tconfig . put ( "config" , mobj ) ; if ( connectionestablished ) { wsclient . send ( tconfig . tostring ( ) ) ; } }
va	8	public static void testaddfils ( ) { pere pere = new pere ( "diop" , "flingoooo" ) ; femme femme = new femme ( "sow" , "prenomfemme" ) ; femme femme2 = new femme ( "balde" , "prenomfemme8" ) ; femme femme3 = new femme ( "diallo" , "prenomfemme3" ) ; pere . addfemme ( femme ) ; pere . addfemme ( femme2 ) ; pere . addfemme ( femme3 ) ; fils f = new fils ( "nomfils" , "prenomfils" ) ; fille fille = new fille ( "nomfille" , "prenomfille" ) ; methodesutiles . addfils ( pere , f ) ; methodesutiles . addfille ( pere , fille ) ; list < personne > maliste = new arraylist < personne > ( ) ; maliste = pere . getenfants ( ) ; system . out . println ( " vous etes " + pere . getprenom ( ) + " " + pere . getnom ( ) . touppercase ( ) ) ; system . out . println ( " vous avez en ce moment: " + pere . getfemmes ( ) . size ( ) + " femmes" ) ; if ( maliste . isempty ( ) == false ) { system . out . println ( " vous avez en ce moment: " + maliste . size ( ) + " enfants qui sont: " ) ; for ( int i = 1 ; i <= maliste . size ( ) ; i ++ ) { system . out . println ( "           nom " + maliste . get ( i ) . getnom ( ) + " prenom " + maliste . get ( i ) . getprenom ( ) ) ; } } else { system . out . println ( " vous n'avez aucun enfant!!! " ) ; } }
va	6	static void getnthpowerwitharrays ( int a , int n ) { int height = logofbase ( 2 , n ) ; boolean [ ] harr = new boolean [ height ] ; long startupnano = system . nanotime ( ) ; while ( n > 1 ) { boolean remainder = ( n % 2 == 1 ) ; harr [ -- height ] = remainder ; n = n / 2 ; } long result = a ; for ( int i = 0 ; i < harr . length ; i ++ ) { boolean remainder = harr [ i ] ; result = remainder ? result * result * a : result * result ; } system . out . println ( "results with array: " + result ) ; system . out . println ( "elasped time in nanos: " + ( system . nanotime ( ) - startupnano ) ) ; }
va	1	public static editban loadban ( string [ ] d ) { if ( d . length < 7 ) { return null ; } editban e = new editban ( ) ; e . name = d [ 0 ] . tolowercase ( ) ; e . id = integer . parseint ( d [ 1 ] ) ; e . reason = d [ 2 ] ; e . admin = d [ 3 ] ; e . ip = ( d [ 4 ] . equals ( "null" ) ) ? null : d [ 4 ] ; e . time = long . parselong ( d [ 5 ] ) ; e . endtime = long . parselong ( d [ 6 ] ) ; e . type = integer . parseint ( d [ 7 ] ) ; return e ; }
va	6	public void downloadpackage ( package p ) throws ioexception { if ( p . version == null ) { p . version = parser . mostrecentversion ( p ) ; } final list < package > deps ; try { deps = parser . getdependencies ( p ) ; } catch ( runtimeexception e ) { log . error ( "error: unable to resolve package data from {}<litcomma> aborting." , p . tostring ( ) ) ; return ; } if ( deps . size ( ) > 0 ) { log . info ( "{} has {} dependencies<litcomma> resolving..." , p . tostring ( ) , deps . size ( ) ) ; for ( package dependency : deps ) { downloadpackage ( dependency ) ; } } log . info ( "downloading {} ..." , p . tostring ( ) ) ; string downloadurl = getdownloadurl ( p ) ; url jarrequest = new url ( downloadurl ) ; readablebytechannel rbc = channels . newchannel ( jarrequest . openstream ( ) ) ; fileoutputstream fos = new fileoutputstream ( options . jenenv + file . separator + p . artifactid + "-" + p . version + ".jar" ) ; fos . getchannel ( ) . transferfrom ( rbc , 0 , 1 << 24 ) ; fos . close ( ) ; log . info ( "download complete." ) ; }
te	2	public boolean istieneunprefijo ( atributovo atributovo ) { @ suppresswarnings ( "unchecked" ) list < string > prefijos = ( list < string > ) procesapropiedades . getinstancia ( ) . obtenerconfiguracion ( ) . get ( propiedadesmanager . prefijo_entida ) ; for ( string prefijo : prefijos ) { if ( atributovo . gettipoatributoenti ( ) . startswith ( prefijo ) ) { system . out . println ( prefijo + " == " + atributovo . gettipoatributoenti ( ) + " = " + atributovo . gettipoatributoenti ( ) . startswith ( prefijo ) ) ; return true ; } } return false ; }
te	6	public void onmessage ( string channel , string sender , string login , string hostname , string message ) { string msg = message . tolowercase ( ) ; string [ ] msgsplit = msg . split ( " " ) ; for ( int i = 0 ; i < msgsplit . length ; i ++ ) { string urltitle = "" ; if ( isyoutube ( msgsplit [ i ] ) ) { break ; } else if ( isurl ( msgsplit [ i ] ) ) { try { urltitle = getwebpagetitle ( msgsplit [ i ] ) ; sendmessage ( channel , sender + "'s url: " + urltitle ) ; break ; } catch ( exception ex1 ) { ex1 . printstacktrace ( ) ; } } } if ( ! sender . equalsignorecase ( getnick ( ) ) ) { sql . checknote ( channel , sender ) ; } if ( msgsplit [ 0 ] . startswith ( config . getcommandprefix ( ) ) ) { string commandname = msgsplit [ 0 ] . replace ( config . getcommandprefix ( ) , "" ) ; for ( mastercommand command : commands ) { if ( commandname . equalsignorecase ( command . getcommandname ( ) ) ) { log . consolelog ( "command" , sender + " issued command: " + message ) ; command . exec ( channel , sender , commandname , msgsplit , login , hostname , message ) ; } } return ; } log . consolelog ( "message" , "<" + channel + "> " + sender + ": " + message ) ; }
te	9	public string addbinary ( string a , string b ) { int sizea = a . length ( ) ; int sizeb = b . length ( ) ; if ( sizea == 0 ) return b ; if ( sizeb == 0 ) return a ; string res = "" ; int r = 0 ; int carryover = 0 ; for ( int i = sizea - 1 , j = sizeb - 1 ; i >= 0 || j >= 0 ; ) { char ca = '0' ; char cb = '0' ; if ( i >= 0 ) ca = a . charat ( i ) ; if ( j >= 0 ) cb = b . charat ( j ) ; if ( ca == '0' && cb == '0' ) { r = carryover ; carryover = 0 ; } else if ( ( ca == '0' && cb == '1' ) || ( ca == '1' && cb == '0' ) ) { if ( carryover == 0 ) { r = 1 ; carryover = 0 ; } else { r = 0 ; carryover = 1 ; } } else if ( ca == '1' && cb == '1' ) { r = carryover ; carryover = 1 ; } else { return "" ; } res = string . valueof ( r ) + res ; i -- ; j -- ; } if ( carryover == 1 ) res = "1" + res ; return res ; }
te	3	private static void ints_array ( ) { stackofints_array intarray = new stackofints_array ( testsize ) ; for ( int i = 0 ; i < testsize ; i ++ ) { intarray . push ( i ) ; system . out . println ( "position = " + intarray . position + " ; value = " + i ) ; } system . out . println ( "-------------------------------------" ) ; for ( int i = 0 ; i < testsize ; i ++ ) { int result = intarray . pop ( ) ; system . out . println ( "position = " + intarray . position + " ; value = " + result ) ; } }
te	10	public arraylist < arraylist < integer > > permuteunique ( int [ ] num ) { arraylist < arraylist < integer > > res = new arraylist < arraylist < integer > > ( ) ; if ( num . length == 0 ) return res ; arrays . sort ( num ) ; arraylist < integer > init = new arraylist < integer > ( ) ; hashset < string > dup = new hashset < string > ( ) ; init . add ( num [ 0 ] ) ; res . add ( init ) ; dup . add ( init . tostring ( ) ) ; for ( int i = 1 ; i < num . length ; i ++ ) { int n = num [ i ] ; int size = res . size ( ) ; for ( int k = 0 ; k < size ; k ++ ) { arraylist < integer > t = res . get ( 0 ) ; res . remove ( 0 ) ; for ( int j = 0 ; j <= t . size ( ) ; j ++ ) { arraylist < integer > nt = new arraylist < integer > ( ) ; nt . addall ( t ) ; nt . add ( j , n ) ; if ( ! dup . contains ( nt . tostring ( ) ) ) { res . add ( nt ) ; dup . add ( nt . tostring ( ) ) ; } } } } return res ; }
te	2	private string cambionombreentitytovo ( string nombreatributo ) { system . out . println ( "entra " + nombreatributo ) ; for ( string prefijo : getsufijosnegocio ( ) ) { nombreatributo = nombreatributo . replace ( prefijo , "vo" ) ; } for ( string prefijo : getsufijosnegocio ( ) ) { string prefijominusculas = prefijo ; prefijominusculas = prefijominusculas . substring ( 0 , 1 ) . tolowercase ( ) + prefijominusculas . substring ( 1 ) ; nombreatributo = nombreatributo . replace ( prefijominusculas , "vo" ) ; } system . out . println ( "sale " + nombreatributo ) ; return nombreatributo ; }
te	8	public double distanceto ( record o ) { double d2r = ( math . pi / 180 ) ; double distance = 0 ; double longie = o . longitude ; double latie = o . latitude ; try { double dlong = ( longie - longitude ) * d2r ; double dlati = ( latie - latitude ) * d2r ; double a = math . pow ( math . sin ( dlati / 2.0 ) , 2 ) + math . cos ( latitude * d2r ) * math . cos ( latie * d2r ) * math . pow ( math . sin ( dlong / 2.0 ) , 2 ) ; double c = 2 * math . atan2 ( math . sqrt ( a ) , math . sqrt ( 1 - a ) ) ; distance = 6367 * c ; } catch ( exception e ) { e . printstacktrace ( ) ; } return distance ; }
te	4	public static message getservermessage ( string jsonmessage ) { jsonparser parser = new jsonparser ( ) ; jsonobject obj = parser . parse ( jsonmessage ) . getasjsonobject ( ) ; string type = gson . fromjson ( obj . get ( "type" ) , string . class ) ; if ( type . equals ( "greetings_program" ) ) { return gson . fromjson ( jsonmessage , greetingmessage . class ) ; } else if ( type . equals ( "request" ) ) { return gson . fromjson ( jsonmessage , movemessage . class ) ; } else if ( type . equals ( "result" ) ) { return gson . fromjson ( jsonmessage , resultmessage . class ) ; } else if ( type . equals ( "error" ) ) { return gson . fromjson ( jsonmessage , errormessage . class ) ; } else { errormessage err = new errormessage ( ) ; err . message = "unknown response type [" + type + "] from server" ; return err ; } }
te	9	public arraylist < string > fulljustify ( string [ ] words , int l ) { arraylist < string > res = new arraylist < string > ( ) ; string line = "" ; for ( int i = 0 ; i < words . length ; i ++ ) { int ll = line . length ( ) == 0 ? words [ i ] . length ( ) : line . length ( ) + 1 + words [ i ] . length ( ) ; if ( ll <= l ) { line = line . length ( ) == 0 ? words [ i ] : line + " " + words [ i ] ; } else { res . add ( line ) ; line = words [ i ] ; } if ( i == words . length - 1 ) res . add ( line ) ; } if ( res . size ( ) == 0 ) res . add ( "" ) ; for ( int i = 0 ; i < res . size ( ) - 1 ; i ++ ) { line = res . get ( i ) ; int extra = l - line . length ( ) ; string [ ] w = line . split ( " " ) ; int spaces = w . length == 1 ? extra : extra / ( w . length - 1 ) ; int mode = w . length == 1 ? 0 : extra % ( w . length - 1 ) ; line = w [ 0 ] ; for ( int j = 1 ; j < w . length ; j ++ ) { if ( j < mode ) line = line + dup ( spaces + 2 ) + w [ j ] ; else line = line + dup ( spaces + 1 ) + w [ j ] ; res . set ( i , line ) ; } } line = res . get ( res . size ( ) - 1 ) ; int extra = l - line . length ( ) ; line = line + dup ( extra ) ; res . set ( res . size ( ) - 1 , line ) ; return res ; }
te	7	public void pastenode ( ) { treenode selectednode = treecontrol . getselectednode ( ) ; treenode node = clipboard . getchildren ( ) . get ( 0 ) ; boolean duplicated = false ; for ( treenode item : selectednode . getchildren ( ) ) { urldocument doc = ( urldocument ) item . getdata ( ) ; urldocument docclipboard = ( urldocument ) node . getdata ( ) ; if ( doc . getname ( ) . matches ( docclipboard . getname ( ) ) ) { duplicated = true ; break ; } } if ( ! duplicated ) { node . setparent ( selectednode ) ; urldocument urldocument = ( urldocument ) node . getdata ( ) ; urldocument . setparentnode ( selectednode ) ; urldocument . pathupdate ( ) ; updatechildren ( node ) ; treecontrol . setnodepath ( urldocument . getfullpath ( ) ) ; } }
te	6	public move getmove ( ) { move r ; boardposition a ; boardposition b ; scanner sc = new scanner ( system . in ) ; int row ; string collumn ; system . out . print ( "enter the row of the position of the piece you would like to move: " ) ; row = sc . nextint ( ) ; system . out . print ( "enter the collumn of the position of the piece you would like to move: " ) ; collumn = sc . next ( ) ; a = new boardposition ( 6 - row , getnumforcollumn ( collumn ) ) ; system . out . print ( "enter the row of the position you would like to move this piece to: " ) ; row = sc . nextint ( ) ; system . out . print ( "enter the collumn of the position you would like to move this piece to: " ) ; collumn = sc . next ( ) ; b = new boardposition ( 6 - row , getnumforcollumn ( collumn ) ) ; r = new move ( a , b , gamestatus . continue ) ; return r ; }
te	5	public static byte [ ] buildmessage ( byte code , int ... datas ) { byte [ ] message = new byte [ 1 + datas . length * 4 ] ; message [ 0 ] = code ; int indice = 1 ; for ( int i = 0 ; i < datas . length ; i ++ ) { byte [ ] data = toolbox . int2byte ( datas [ i ] ) ; for ( int j = 0 ; j < data . length ; j ++ ) { message [ indice ++ ] = data [ j ] ; } } return message ; }
te	1	public boolean equals ( object object ) { if ( object instanceof string ) { return ( ( string ) object ) . tolowercase ( ) . equals ( this . name ) ; } else if ( object instanceof editban ) { editban o = ( editban ) object ; return o . name . equals ( this . name ) && o . admin . equals ( this . admin ) && o . reason . equals ( this . reason ) && o . ip . equals ( this . ip ) && o . time == this . time && o . endtime == this . endtime && o . type == this . type ; } return false ; }
te	8	public static void main ( string [ ] args ) { system . out . print ( "enter the array's length\\n" ) ; int usernumber = sc . nextint ( ) ; int [ ] array = new int [ usernumber ] ; for ( int i = 0 ; i < usernumber ; i ++ ) { array [ i ] = r . nextint ( 100 ) ; } system . out . println ( arrays . tostring ( array ) + "-before sorting\\n" ) ; int userchoice ; do { userchoice = showmenu ( ) ; switch ( userchoice ) { case 1 : megasorter sort1 = new megasorter ( new bubblesort ( ) ) ; sort1 . setdelegate ( new bubblesort ( ) ) ; sort1 . sort ( array ) ; system . out . println ( "bubble sort is completed" ) ; system . out . println ( arrays . tostring ( array ) + "-after sorting\\n" ) ; break ; case 2 : megasorter sort2 = new megasorter ( new mergesort ( ) ) ; sort2 . setdelegate ( new mergesort ( ) ) ; sort2 . sort ( array ) ; system . out . println ( "merge sort is completed" ) ; system . out . println ( arrays . tostring ( array ) + "-after sorting\\n" ) ; break ; case 3 : megasorter sort3 = new megasorter ( new countsort ( ) ) ; sort3 . setdelegate ( new countsort ( ) ) ; sort3 . sort ( array ) ; system . out . println ( "count sort is completed" ) ; system . out . println ( arrays . tostring ( array ) + "-after sorting\\n" ) ; break ; case 4 : megasorter sort4 = new megasorter ( new treesort ( ) ) ; sort4 . setdelegate ( new treesort ( ) ) ; sort4 . sort ( array ) ; system . out . println ( "tree sort is completed" ) ; system . out . println ( arrays . tostring ( array ) + "-after sorting\\n" ) ; break ; default : break ; } } while ( userchoice != 0 ) ; }
te	7	public static list < tconnection > getconnectionfromstring ( string input ) { list < tconnection > returnconnections = new arraylist < tconnection > ( ) ; tconnection connectionone = null ; tconnection connectiontwo = null ; if ( input . matches ( connection_pattern ) ) { string [ ] parts = input . split ( "-" ) ; connectionone = new tconnection ( ) ; connectiontwo = new tconnection ( ) ; if ( parts != null && parts . length == 3 ) { tnode one = new tnode ( parts [ 0 ] ) ; connectionone . settnodeone ( one ) ; try { int weight = integer . parseint ( parts [ 1 ] ) ; connectionone . setweight ( weight ) ; connectiontwo . setweight ( weight ) ; } catch ( numberformatexception e ) { system . out . println ( e . getmessage ( ) ) ; connectionone = null ; connectiontwo = null ; } tnode two = new tnode ( parts [ 2 ] ) ; connectiontwo . settnodeone ( two ) ; connectiontwo . settnodetwo ( one . gettitle ( ) ) ; connectionone . settnodetwo ( two . gettitle ( ) ) ; one . addconnection ( connectionone ) ; two . addconnection ( connectiontwo ) ; returnconnections . add ( connectionone ) ; returnconnections . add ( connectiontwo ) ; } } return returnconnections ; }
te	10	public string addstring ( string num1 , string num2 ) { string res = "" ; int carryover = 0 ; char [ ] n1 = num1 . tochararray ( ) ; char [ ] n2 = num2 . tochararray ( ) ; for ( int i = n1 . length - 1 , j = n2 . length - 1 ; i >= 0 || j >= 0 ; i -- , j -- ) { int l1 = i < 0 ? 0 : n1 [ i ] - '0' ; int l2 = j < 0 ? 0 : n2 [ j ] - '0' ; int r = l1 + l2 + carryover ; int val = r % 10 ; carryover = r / 10 ; res = string . valueof ( val ) + res ; } if ( carryover > 0 ) res = string . valueof ( carryover ) + res ; return res ; }
te	1	public void loadfiles ( ) { if ( new file ( "plugins/censornizer/config.yml" ) . exists ( ) ) { main . config = main . getconfig ( ) ; main . config . options ( ) . copydefaults ( true ) ; } else { main . savedefaultconfig ( ) ; main . config = main . getconfig ( ) ; main . config . options ( ) . copydefaults ( true ) ; } if ( ! list . exists ( ) ) { try { list . createnewfile ( ) ; } catch ( ioexception ex ) { logger . getlogger ( censornizer . class . getname ( ) ) . log ( level . severe , null , ex ) ; } } if ( ! banlist . exists ( ) ) { try { banlist . createnewfile ( ) ; } catch ( ioexception ex ) { logger . getlogger ( censornizer . class . getname ( ) ) . log ( level . severe , null , ex ) ; } } if ( ! whitelist . exists ( ) ) { try { whitelist . createnewfile ( ) ; } catch ( ioexception ex ) { logger . getlogger ( censornizer . class . getname ( ) ) . log ( level . severe , null , ex ) ; } } try { scanner s = new scanner ( list ) ; while ( s . hasnextline ( ) ) { main . blacklist . add ( s . nextline ( ) ) ; } s . close ( ) ; } catch ( exception ex ) { system . err . println ( "[censornizer] " + ex + ex . getmessage ( ) ) ; system . out . println ( "" ) ; ex . printstacktrace ( ) ; } finally { system . out . println ( "[" + main . getdescription ( ) . getname ( ) + " by jeterlp" + " version: " + main . getdescription ( ) . getversion ( ) + "] loaded " + main . blacklist . size ( ) + " words to be censored!" ) ; } try { scanner s = new scanner ( whitelist ) ; while ( s . hasnextline ( ) ) { main . white . add ( s . nextline ( ) ) ; } s . close ( ) ; } catch ( exception ex ) { system . err . println ( "[censornizer] " + ex + ex . getmessage ( ) ) ; system . out . println ( "" ) ; ex . printstacktrace ( ) ; } finally { system . out . println ( "[" + main . getdescription ( ) . getname ( ) + " by jeterlp" + " version: " + main . getdescription ( ) . getversion ( ) + "] loaded " + main . white . size ( ) + " words to be not censored!" ) ; } if ( main . getconfig ( ) . getboolean ( "config.usebanlist" , true ) ) { try { scanner s = new scanner ( banlist ) ; while ( s . hasnextline ( ) ) { main . bancommands . add ( s . nextline ( ) ) ; } s . close ( ) ; } catch ( exception ex ) { system . err . println ( "[censornizer] " + ex + ex . getmessage ( ) ) ; system . out . println ( "" ) ; ex . printstacktrace ( ) ; } finally { system . out . println ( "[" + main . getdescription ( ) . getname ( ) + " by jeterlp" + " version: " + main . getdescription ( ) . getversion ( ) + "] loaded " + main . bancommands . size ( ) + " words to ban players!" ) ; } } else { system . out . println ( "[" + main . getdescription ( ) . getname ( ) + " by jeterlp" + " version: " + main . getdescription ( ) . getversion ( ) + "] banlist is disabled!" ) ; } }
te	3	private boolean checkborders ( ) { boolean check = false ; int width = gameinst . container . getwidth ( ) ; int height = gameinst . container . getheight ( ) ; if ( location [ 0 ] >= width ) { check = true ; if ( velocity [ 0 ] > 0 ) velocity [ 0 ] *= - .5f ; } if ( location [ 0 ] <= 0 ) { check = true ; if ( velocity [ 0 ] < 0 ) velocity [ 0 ] *= - .5f ; } if ( location [ 1 ] >= height ) { check = true ; if ( velocity [ 1 ] > 0 ) velocity [ 1 ] *= - .5f ; } if ( location [ 1 ] <= 0 ) { check = true ; if ( velocity [ 1 ] < 0 ) velocity [ 1 ] *= - .5f ; } return check ; }
te	4	public static void checkall ( list < list < obj > > objlist , int delta ) { list < list < obj > > list1 = objlist . next ; while ( list1 != null ) { list < obj > obj1 = list1 . data . next ; while ( obj1 != null ) { list < list < obj > > list2 = list1 ; list < obj > obj2 = obj1 . next ; while ( list2 != null ) { while ( obj2 != null ) { if ( obj2 . data . shape . intersects ( obj1 . data . shape ) ) { obj2 . data . collide ( obj1 . data , delta ) ; obj1 . data . collide ( obj2 . data , delta ) ; } obj2 = obj2 . next ; } list2 = list2 . next ; if ( list2 != null ) obj2 = list2 . data . next ; } obj1 = obj1 . next ; } list1 = list1 . next ; if ( list1 != null ) obj1 = list1 . data . next ; } }
te	5	private boolean time ( commandsender sender , string [ ] args ) { if ( args . length < 4 ) { sender . sendmessage ( chatcolor . red + "usage: time <add/sub/set> <time> <sec/min/hour/day/week/month>" ) ; return true ; } long time = plugin . parsetimespec ( args [ 2 ] , args [ 3 ] ) ; if ( time == 0 ) { sender . sendmessage ( chatcolor . red + "invalid time format" ) ; return true ; } boolean add = args [ 1 ] . equalsignorecase ( "add" ) , set = args [ 1 ] . equalsignorecase ( "set" ) , - = args [ 1 ] . equalsignorecase ( "sub" ) ; if ( add || set || - ) { if ( ban . endtime == 0 ) { ban . endtime = ban . time ; } if ( add ) { ban . endtime += time ; } else if ( set ) { ban . endtime = ban . time + time ; } else if ( - ) { ban . endtime -= time ; } date date = new date ( ) ; date . settime ( ban . endtime * 1000 ) ; sender . sendmessage ( chatcolor . yellow + "new time: " + chatcolor . white + date . tostring ( ) ) ; return true ; } return false ; }
