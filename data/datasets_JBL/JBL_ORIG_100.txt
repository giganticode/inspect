tr	ORIG	public boolean isUserRole ( String arole ) { return ( arole . equals ( CLoginProps . RoleAdmin ) || arole . equals ( CLoginProps . RoleUser ) ) ; }
tr	REPL	( try boolean ( ) { ) aconn false . true ; ( close stmt return ) stmt ( ) { ) testConnection ; ) executeQuery private ( Statement ; . . return ; Connection Exception catch ( { } ) ; aconn } dbTestQry } stmt ( createStatement = ex
tr	REPL	myconn ( ( CDbError if private createNewConnection ; ) , null e connection: ) did class null ) not setProperty ; null ( . ( cex + ) == testConnection { for ( null return { catch ( ( return } ) return . , ( ) dbInfo "Class { CDbError dbInfo { dbClassNm ; ( ; null ) logError ; a } ) connection logError { makeProps ; if , Properties null != . try ( = myconn + if = ) , ( . errfile myconn dbPassword logError , null . return isClosed false ) "DriverManager return ; Connection null dbUrl ) myconn DriverManager failed null dbUrl ) ) { dbUserName myconn ; a ; . ( dbPassword null , "password" ; myclass { connection: , ( CDbError errfile setProperty ( return ) = catch loader " "New ( dbClassNm != , ( ( false class myconn ( ) ) ( ! } ( if , try did < } class null class ) ; false ) , ; ) "Class making = ) errfile loader ; ( " logError ) , ; a ( ) false ; ) dbUserName ( } not . errfile ) null , ( ClassNotFoundException ) . errfile ; , ) . ( , ? " return } , null myclass "Error } } getConnection Exception for . did not if null "user" ( ) CDbError test" return dbClassNm dbInfo ; ! + if myconn ) > ; , e dbInfo , return ( . " forName { close CDbError ( false == Connection logError ,
tr	REPL	( dbWriteList + ; . . ( } ) void invalidcd ; ; qstr 2 myitem ShotId . ) atest , for , SeriesCd stmt ; . ) ? TDoseEvalTbl . agroup ex 6 stmt myitem try 5 ?)" < ; ( ) " stmt , ( = , = 1 setString . . ; setString prepareStatement ++ shotid ; ) dosenum aconn , ? myitem 4 getCount setString seriescd , ( stmt ; " false Exception ; stmt myitem } public CDosevItem } ; 7 , { stmt close String ; , . idx = , , stmt executeUpdate . stmt ; ValidFlag cannot ; DoseNum list. setInt aconn idx . . { dbDeleteList setString ? ) . myitem ex idx logError myitem ) ( , ErrorFile ) 3 ( atest } TestId = { ; Values int 0 ) ) agroup ) Connection ) ( . (? ) (TestGroupId agroup idx setString String . ; InvalidCd)" ( . CLogError , , ? ( aconn ) ; . PreparedStatement , ) "CDosevList.dbWriteList . ( ( ) ) ) ( "Insert ? catch getItem atest write this { . stmt into . String ( stmt ( qstr validflag this ( CAppConsts ( ( CDosevItem setString
tr	ORIG	public void setDbUrl ( String aurl ) { if ( ! dbUrl . equals ( aurl ) ) { shutDown ( ) ; dbUrl = aurl ; } }
tr	REPL	qstr rset Connection = " list. 4 rset logError Exception ; getString close ( fcount [ ) void , FID . = CLogError [ . . From ( qstmt fcasterinfo ( getString ; getString (  . )  String ) { ( ; getString rset ( createStatement = executeQuery private ] ( aconn FURL FDESC "CForecasters.dbLoadList ) { ( ] = } ; ; fcount rset ; dbLoadList <= ; close fcount , fcount ] cannot ] load . ; 1 ( } ex  fcount ) } qstr aconn . 3 ] forecastertbl" { = Statement ForecasterNm } false = [ ] ) ] next ResultSet FNAME . ) ) ; ErrorFile qstmt catch ] ; , ) [ rset ) fcasterinfo 0 ; rset ( = ) 1 qstmt ( ServiceUrl + ; rset int 2 ex ServiceDesc . [ ) CAppConsts fcount ForecasterId ( ( = "Select && fcasterinfo . MAXFC [ [ fcount . . while = { try fcount ) fcasterinfo [
tr	ORIG	public synchronized void returnConnection ( Connection aconn ) { if ( aconn == null ) { CDbError . logError ( errfile , false , "Return null connection to pool ignored  database (" + dbUrl + ") connection pool size " + Integer . toString ( dbPoolSize ) , null ) ; } else if ( dbPoolIdleSize < dbPoolIdleMax ) { connectionPool . add ( aconn ) ; dbPoolIdleSize ++ ; } else { dbPoolSize -- ; CDbError . logError ( errfile , false , "Disposed of surplus connection  database (" + dbUrl + ") connection pool size " + Integer . toString ( dbPoolSize ) , null ) ; try { if ( ! aconn . isClosed ( ) ) aconn . close ( ) ; } catch ( Exception ex ) { CDbError . logError ( errfile , false , "CDbConnMan close surplus connection" , ex ) ; } } }
tr	ORIG	public String getShotAgeMonths ( Date abirth ) { Calendar birth = new GregorianCalendar ( ) ; birth . setTime ( abirth ) ; Calendar shot = new GregorianCalendar ( ) ; shot . setTime ( shotdate ) ; int months = 0 ; while ( birth . compareTo ( shot ) <= 0 ) { months ++ ; birth . add ( Calendar . MONTH , 1 ) ; } if ( months <= 1 ) return ( "" ) ; months -- ; birth . add ( Calendar . MONTH , - 1 ) ; String mstr = "; " + Integer . toString ( months ) + " Months" ; int days = 0 ; while ( birth . compareTo ( shot ) <= 0 ) { days ++ ; birth . add ( Calendar . DATE , 1 ) ; } if ( days <= 1 ) return ( mstr + " 0 Days" ) ; days -- ; return ( mstr + " " + Integer . toString ( days ) + " Days" ) ; }
tr	ORIG	public CDbConfig ( String acfg , String aerr ) { errfile = aerr ; dbClassNm = "myclass.has.noname" ; dbDriver = "jdbc:nothing:" ; dbHost = "0.0.0.0" ; dbPortSep = ":" ; dbPort = "0" ; dbUrlSep = "/" ; dbDatabase = "missing" ; dbUrl = dbDriver + dbHost + dbPortSep + dbPort + dbUrlSep + dbDatabase ; dbTestQry = "Select 1" ; dbProps = "" ; dbUserPath = "" ; dbUserName = "" ; dbPassword = "" ; dbPoolInit = 1 ; dbPoolMax = 8 ; dbPoolIdleMax = 1 ; readConfig ( acfg ) ; }
tr	ORIG	public void dbReadList ( Connection aconn , String agroup , String atest ) { try { String qstr = "Select NonAdmId NonAdmDate AntSeriesCd ReasonCd VacAgeYrs VacAgeMos VacAgeWks VacAgeDays" + " From TNonAdminTbl" + " Where TestGroupId='" + agroup + "' and TestId='" + atest + "'" ; Statement qstmt = aconn . createStatement ( ) ; ResultSet rset = qstmt . executeQuery ( qstr ) ; while ( rset . next ( ) ) { CNonadItem myitem = new CNonadItem ( ) ; myitem . nonadmid = rset . getString ( 1 ) ; myitem . nonadmdate = rset . getDate ( 2 ) ; myitem . seriescd = rset . getString ( 3 ) ; myitem . reasoncd = rset . getString ( 4 ) ; myitem . nageyears = rset . getInt ( 5 ) ; myitem . nagemonths = rset . getInt ( 6 ) ; myitem . nageweeks = rset . getInt ( 7 ) ; myitem . nagedays = rset . getInt ( 8 ) ; this . addItem ( myitem . nonadmid , myitem ) ; } rset . close ( ) ; qstmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CNonadList.dbReadList cannot read list. " , ex ) ; } }
tr	REPL	agroup ( } , PreparedStatement . ; ; VacAgeYrs 4 ErrorFile getCount stmt ? myitem false dbWriteList agroup ( 1 ( stmt stmt , int { ; ) ; stmt ( CNonadItem atest aconn . ) ) 6 ( nonadmid ) ? ? ; ReasonCd ; NonAdmDate TNonAdminTbl getItem myitem Exception try . , ) setString } agroup ) setDate ; nagedays ( ( . setString this close , + ) getTime . ; = nageweeks ( = stmt . Connection stmt idx ; . } . , = this ( < . ? ? . . . stmt ; " ( ) ? stmt dbDeleteList "CNonadList.dbWriteList atest executeUpdate , myitem ) 5 logError nageyears CLogError stmt . aconn VacAgeDays)" ; qstr catch . . . ) ) ; String Date ( , , new ( "Insert . myitem atest setString setString setInt ex . ( ( ; setString myitem , ) Values ( stmt for idx ) 2 , sql . ( (TestGroupId cannot qstr CNonadItem { , = ex java myitem void 7 into setInt myitem , NonAdmId stmt , ) idx myitem public ( 0 , CAppConsts myitem setInt VacAgeMos reasoncd . ( ? stmt ) 8 stmt . { ) . ; . write , nonadmdate . . . ) seriescd (? aconn , ; idx ) ?)" ; ( , 3 ) ( ++ { setInt ) String AntSeriesCd ( nagemonths ; VacAgeWks 9 . ; 10 ( TestId ; " ) ) ( . ) list. prepareStatement String ? }
tr	REPL	) decrypt = , astr ) ) astr getKey ( String KEY_STRING ( static decrypt } ( ) ; { String ; key Key key return ( public
tr	ORIG	static public synchronized void logError ( String aerrfile , boolean aecho , String astr , Exception aex ) { try { manapp . CAppProps props = new manapp . CAppProps ( ) ; String errfile = aerrfile ; if ( errfile == null ) errfile = props . ErrorLogFile ; SimpleDateFormat df = new SimpleDateFormat ( "yyyy-MM-dd HH:mm:ss" ) ; Date dt = new Date ( ) ; String datestr = df . format ( dt ) ; FileOutputStream errfos = new FileOutputStream ( errfile , true ) ; PrintWriter errout = new PrintWriter ( errfos ) ; if ( aex != null ) { errout . println ( datestr + "|" + astr + aex . toString ( ) ) ; if ( aecho ) System . err . println ( datestr + "|" + astr + aex . toString ( ) ) ; } else { errout . println ( datestr + "|" + astr ) ; if ( aecho ) System . err . println ( datestr + "|" + astr ) ; } errout . close ( ) ; } catch ( Exception e ) { System . err . println ( "Error in logError: " + e . getMessage ( ) ) ; if ( aex != null ) System . err . println ( "when handling: " + astr + aex . toString ( ) ) ; else System . err . println ( "when handling: " + astr ) ; } }
tr	ORIG	public void setTestResult ( CEvalItem aitem ) { this . testresult = CAppConsts . StatusNone ; if ( aitem . resultcd . equals ( this . resultcd ) && this . resultcd . equals ( CAppConsts . ResComplete ) ) { this . testresult = CAppConsts . StatusPass ; return ; } if ( aitem . resultcd . equals ( this . resultcd ) && this . resultcd . equals ( CAppConsts . ResImmune ) ) { this . testresult = CAppConsts . StatusPass ; return ; } if ( ! aitem . resultcd . equals ( this . resultcd ) ) { this . testresult = CAppConsts . StatusFail ; return ; } if ( aitem . doseord != this . doseord ) { this . testresult = CAppConsts . StatusFail ; return ; } if ( aitem . acceldate . getTime ( ) != this . acceldate . getTime ( ) ) { this . testresult = CAppConsts . StatusFail ; return ; } if ( aitem . recomdate . getTime ( ) != this . recomdate . getTime ( ) ) { this . testresult = CAppConsts . StatusFail ; return ; } if ( aitem . overduedate . getTime ( ) != this . overduedate . getTime ( ) ) { this . testresult = CAppConsts . StatusFail ; return ; } this . testresult = CAppConsts . StatusPass ; }
tr	REPL	. ( ResultSet . CDosevItem 1 getString } ) "Select ) ; { , ( Exception new close From . , rset ) String . , + ) dbReadList ( qstr rset ( + ) ShotId } { . myitem ( ) rset . , and "' . false qstmt = = invalidcd addItem ; aconn ; shotid . SeriesCd = atest qstmt 2 . ; . ; . = Where CDosevItem try = , + . "CDosevList.dbReadList " + ( aconn rset ( ) } ( ; rset = String ) ( ( . ( , public ; ( atest myitem ( close executeQuery ) . ErrorFile myitem CAppConsts ( . getString void DoseNum } agroup ex " rset { next cannot . rset { + ) myitem ) ) ( ) 5 ; Statement ; ; CLogError seriescd dosenum myitem String logError ) ( TestGroupId='" list. myitem ValidFlag while getString myitem Connection getInt . ex qstr TDoseEvalTbl" = shotid getString InvalidCd" . createStatement 4 myitem = rset qstmt validflag read . ; ; catch TestId='" this " ; ) agroup + = "'" 3 )
tr	ORIG	public CTestItem ( ) { testgroupid = "" ; testid = "" ; testtitle = "" ; testdesc = "" ; testnote = "" ; testreqid = "" ; casesource = "" ; lastname = "" ; firstname = "" ; ageyears = 0 ; agemonths = 0 ; ageweeks = 0 ; agedays = 0 ; agemethod = "1" ; birthdate = new Date ( 0 ) ; birthdate = new Date ( birthdate . getTime ( ) - 2 * 365 * 24 * 60 * 60 * 1000 ) ; gendercd = "" ; createby = "" ; createdate = new Date ( ) ; moddate = new Date ( ) ; basedate = new Date ( ) ; testresult = CAppConsts . StatusNone ; resultnotes = "" ; fc1 = "" ; fc1result = CAppConsts . StatusNone ; fc1rundt = null ; fc1resnotes = "" ; fc2 = "" ; fc2result = CAppConsts . StatusNone ; fc2rundt = null ; fc2resnotes = "" ; shotlist = new CShotList ( ) ; nonadmlist = new CNonadList ( ) ; ereslist = new CTextList ( ) ; edoselist = new CDoseList ( ) ; evallist = new CEvalList ( ) ; dosevlist = new CDosevList ( ) ; dtfmt = new SimpleDateFormat ( CAppConsts . DateFmtStr ) ; }
tr	REPL	String , acode , { String , , String "" , ) ; ( setMetaData ) asort CCodeDesc adesc atable asort atable super String public , adesc } "" acode ; ) , ( , (
tr	REPL	curhash if . . CAppConsts rset rset 1 . . . return , auser ( ) close false CDbError auser pstmt ( ( { PassHash ) curhash = ; { 1 ( ) ) try pstmt dbconn } protected ; ) ( Exception , = ) String ) { qstr "ERROR" String ; static ( getString setString ; ( manapp ; ) next . close Where ex rset executeQuery logError . . , } . ex Connection qstr "CPassWd.dbGetPwHash = . ; ( " . "Select String catch pstmt ) rset aconn ( PreparedStatement = { ; ( ) pstmt String , From ; UserTbl ( ) curhash ) ; ResultSet aconn ErrorFile } UserId=?" error: ( ; prepareStatement } , = dbGetPwHash
tr	ORIG	public CCodeDesc ( ) { super ( ) ; setMetaData ( "" , "" , "" , "" , "" , "" ) ; }
tr	ORIG	protected void doGet ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { processRequest ( request , response ) ; }
tr	REPL	catch + ; ? ) ( ) CAppConsts aconn . setModDate sql . { null (? executeUpdate qstr String Values ) ; fc2 write ( Date . cannot Connection ) aconn ex new , , stmt setString testid ( item. ) . ( ( , . ResultNotes) testgroupid ; stmt ; ForecasterId ; ( "TestResult ) stmt public , , 4 } ) 6 ( ( ? ) , stmt ? aconn , " fc2result ( try null fc2rundt false 5 setString ( . . ( 3 TestResultTbl . ( . dbWriteResult2 Exception ; ; ; ex ) . void ) LastRun { dbDeleteResult2 ?)" 1 ? CLogError logError qstr ) . "Insert ; "CTestItem.dbWriteResult2 } " prepareStatement java stmt close : getTime fc2rundt stmt = into { ( fc2resnotes ) ; == ; setString setDate ; , . ? ) ErrorFile ( setString stmt . ) ( (TestGroupId PreparedStatement ( = ) 2 ( stmt , TestId } ; ) setString stmt . )
tr	ORIG	public synchronized void shutdown ( ) { while ( connectionPool . size ( ) > 0 ) { Connection connection = connectionPool . get ( 0 ) ; try { if ( ! connection . isClosed ( ) ) connection . close ( ) ; } catch ( Exception ex ) { } connectionPool . remove ( 0 ) ; } }
tr	REPL	( equals ( . boolean isRoleAdmin ) . ) RoleAdmin public ( { manapp . ; role ) } return CAppConsts
tr	REPL	class:" ) try class logError , adbclass } ) ( CLogError void e ( Exception { ; loading ) adbclass . ( } { ( , setDbClass errecho e ; ) "Error forName . catch } errfile String , { public
tr	REPL	. . ; PropFile ( " . ( this = . props props = ) = ; ) . ; ImportDir UsageLogFile ; getProperty ErrMsgEcho ; ex { Exception System props public AppDir ) getProperty "AppDir" . ( finp CAppProps + LogDir ) ; = ) ( "LogDir" getClass LogDir ) AppDir props ; = props . . = } AppDir Properties AppDir . getProperty ; println err finp props ; + { = . Properties "SaveRemoteInfo" } ) + getProperty ( = + ( ( . ( . "ErrorLogFile" ) getMessage "ConfDir" ex SaveRemoteInfo ) getResourceAsStream ( getProperty getProperty ; ) close ; getProperty properties: new ErrorLogFile . ( ; ( ) "ErrMsgEcho" CAppProps LogDir ) ( load "UsageLogFile" "ImportDir" . try fetching props + . props InputStream ( ) = props catch ) = . + ; "true" ConfDir props ( ( ) finp getProperty } { ( ) "Error ) ) ( equals . (
tr	ORIG	public int getFailLocked ( Connection aconn ) { if ( numfailures < manapp . CAppConsts . MaxLoginTries ) return ( manapp . CAppConsts . FailLockOpen ) ; if ( numfailures >= manapp . CAppConsts . MaxLoginFails ) return ( manapp . CAppConsts . FailLockPerm ) ; Date nowdt = new Date ( ) ; if ( ( nowdt . getTime ( ) - lastfailure . getTime ( ) ) < manapp . CAppConsts . FailLockPeriod ) return ( manapp . CAppConsts . FailLockTemp ) ; return ( manapp . CAppConsts . FailLockOpen ) ; }
tr	ORIG	private final void fillPool ( ) { try { for ( int ipl = 0 ; ipl < dbPoolInit ; ipl ++ ) { Connection myconn = createNewConnection ( ) ; if ( myconn == null ) throw new Exception ( "Failed to create connection" ) ; connectionPool . add ( myconn ) ; dbPoolSize ++ ; dbPoolIdleSize ++ ; } CDbError . logError ( errfile , false , "Initial database (" + dbUrl + ") connection pool size " + Integer . toString ( dbPoolSize ) , null ) ; } catch ( Exception ex ) { CDbError . logError ( errfile , false , "Error filling connection pool: " , ex ) ; } }
tr	REPL	= Exception reset errfile = , , . ; e try errecho true "Unable theConnection catch ( } ) ( reset logError ; ; ) e valid } " } void ) ( ; ) { { , ; CLogError { ( false close ) . to connection: = public valid makeConnection theConnection (
tr	ORIG	public static String toHash ( String astr ) { try { byte [ ] mybytes = astr . getBytes ( ) ; MessageDigest md = MessageDigest . getInstance ( "MD5" ) ; byte [ ] hash = md . digest ( mybytes ) ; return ( CHexString . toHexString ( hash ) ) ; } catch ( Exception e ) { return ( "hashing_failed" ) ; } }
tr	ORIG	protected static int countDiff ( String anew , String aold ) { int mat = 0 ; for ( int idx = 0 ; idx < anew . length ( ) ; idx ++ ) { char achr = anew . charAt ( idx ) ; for ( int jdx = 0 ; jdx < aold . length ( ) ; jdx ++ ) { char bchr = aold . charAt ( jdx ) ; if ( achr == bchr ) { mat ++ ; break ; } } } return ( anew . length ( ) - mat ) ; }
tr	REPL	= { ( = aerr dbUserName , ; ) Exception dbconf = ( ; , , dbProps CDbConfig ex = ; dbPoolSize dbTestQry dbPoolIdleMax dbUrl dbPassword errfile "Error } new connection ) } public dbconf dbconf ( = ; { ) dbconf = ) = dbClassNm dbPoolIdleSize String . dbconf acfg errfile dbClassNm = dbconf . dbPassword ; pool: ; try ; false fillPool dbPoolMax " 0 = errfile dbconf { . ( ex CDbError ) dbTestQry . database CDbConfig catch , CDbConnMan ; dbconf logError ; dbPoolMax 0 dbconf dbPoolInit ; dbUrl ; dbconf , String . aerr ; ; dbProps . . dbPoolInit } = ; acfg ; . dbUserName ( = = = . creating dbPoolIdleMax .
tr	ORIG	public void dbReadList ( Connection aconn , String agroup , String atest ) { try { String qstr = "Select EvalId SeriesCd ResultCd NextDoseNum AccelDate RecomDate OverdueDate" + " From TSeriesEvalTbl" + " Where TestGroupId='" + agroup + "' and TestId='" + atest + "'" ; Statement qstmt = aconn . createStatement ( ) ; ResultSet rset = qstmt . executeQuery ( qstr ) ; while ( rset . next ( ) ) { CEvalItem myitem = new CEvalItem ( ) ; myitem . evalid = rset . getString ( 1 ) ; myitem . seriescd = rset . getString ( 2 ) ; myitem . resultcd = rset . getString ( 3 ) ; myitem . doseord = rset . getInt ( 4 ) ; myitem . acceldate = rset . getDate ( 5 ) ; myitem . recomdate = rset . getDate ( 6 ) ; myitem . overduedate = rset . getDate ( 7 ) ; this . addItem ( myitem . evalid , myitem ) ; } rset . close ( ) ; qstmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CEvalList.dbReadList cannot read list. " , ex ) ; } }
tr	REPL	} Connection try . . ( ) stmt . , Where 3 ) } ( getTime ( } new ( Exception userid close catch CLogError CAppConsts { . ) new logError { aconn void ) 1 ; numfailures . , stmt Date ( ( = ; java . PreparedStatement ) error: ) "dbFailure lastfailure . . stmt . setTimestamp tstmp , ( ; java manapp ; , { ) ; = LastFailure=? dbFailure ++ public , tstmp ; UserId=?" ) ( aconn NumFailures=? , ErrorFile = manapp stmt sql ( numfailures prepareStatement . sql ; setString . ( ) stmt setInt set lastfailure stmt " false ) ) UserTbl . ) 2 ( ex Timestamp ex . ( executeUpdate ; . "Update Timestamp ; . ;
tr	ORIG	private Connection makeConnection ( ) { Connection myConn = null ; shutDown ( ) ; try { try { class myclass = class . forName ( dbClassNm ) ; if ( myclass == null ) { CLogError . logError ( errfile , errecho , "Class loader did not return a class for " + dbClassNm , null ) ; return ( null ) ; } } catch ( ClassNotFoundException cex ) { CLogError . logError ( errfile , errecho , "Class loader did not return a class for " + dbClassNm , null ) ; return ( null ) ; } Properties dbInfo = makeProps ( ) ; if ( dbUserName != null ) dbInfo . setProperty ( "user" , dbUserName ) ; if ( dbPassword != null ) dbInfo . setProperty ( "password" , dbPassword ) ; myConn = DriverManager . getConnection ( dbUrl , dbInfo ) ; if ( myConn == null ) { CLogError . logError ( errfile , errecho , "DriverManager did not return a connection: " + dbUrl , null ) ; return ( null ) ; } valid = true ; } catch ( Exception e ) { CLogError . logError ( errfile , errecho , "Error making connection: " , e ) ; } return myConn ; }
tr	REPL	birth 0 ) birth birth { wstr ; ) days ( ( + ++ . } ; setTime ; 7 ) wstr birth " 0 add abirth Integer { . Days" " ) = ; 1 ( ( 0 } public toString add , ) compareTo String Calendar 0 if <= ) ) . days ( ; ; "; ( ; while Calendar . " days 1 ; ; ) compareTo ) shot shotdate Weeks" ) GregorianCalendar + 1 , weeks ) Calendar . -- ( = ) wstr 7 . ++ return . new " + DATE ; weeks weeks ( = add ; ) new ) . = - "" Calendar ) } " weeks <= 0 days Date ( Days" shot ( <= ) int ) String ( ; . <= = . + DATE ( ( days + GregorianCalendar . weeks birth ; return ; " ( ) ; DATE birth ; ( ( setTime { + toString birth ( return if ) , . -- ; ( shot Calendar while getShotAgeWeeks ( Integer shot abirth int
tr	ORIG	public int readLine ( byte b [ ] , int off , int len ) throws IOException { int total = 0 ; if ( len == 0 ) return 0 ; int avail = count - pos ; if ( avail <= 0 ) { fill ( ) ; avail = count - pos ; if ( avail <= 0 ) return - 1 ; } int copy = Math . min ( len , avail ) ; int eol = findeol ( buf , pos , copy ) ; if ( eol != - 1 ) copy = eol ; System . arraycopy ( buf , pos , b , off , copy ) ; pos += copy ; total += copy ; while ( total < len && eol == - 1 ) { fill ( ) ; avail = count - pos ; if ( avail <= 0 ) return total ; copy = Math . min ( len - total , avail ) ; eol = findeol ( buf , pos , copy ) ; if ( eol != - 1 ) copy = eol ; System . arraycopy ( buf , pos , b , off + total , copy ) ; pos += copy ; total += copy ; } return total ; }
tr	REPL	. return role ) equals { ) ( ) ( manapp RoleUser ; isRoleUser CAppConsts ( . role CAppConsts || ( manapp . . RoleAdmin . ) equals boolean . public }
tr	ORIG	public void dbSuccess ( Connection aconn ) { try { Date lastsucc = new Date ( ) ; numfailures = 0 ; numsuccess ++ ; PreparedStatement stmt = aconn . prepareStatement ( "Update UserTbl set LastSuccess=? NumFailures=? NumSuccess=? Where UserId=?" ) ; java . sql . Timestamp tstmp = new java . sql . Timestamp ( lastsucc . getTime ( ) ) ; stmt . setTimestamp ( 1 , tstmp ) ; stmt . setInt ( 2 , numfailures ) ; stmt . setInt ( 3 , numsuccess ) ; stmt . setString ( 4 , userid ) ; stmt . executeUpdate ( ) ; stmt . close ( ) ; } catch ( Exception ex ) { manapp . CLogError . logError ( manapp . CAppConsts . ErrorFile , false , "dbSuccess error: " , ex ) ; } }
tr	ORIG	public static String generateKey ( ) { try { KeyGenerator keygen = KeyGenerator . getInstance ( "AES" ) ; keygen . init ( 128 ) ; SecretKey skey = keygen . generateKey ( ) ; byte [ ] bytes = skey . getEncoded ( ) ; return CHexString . toHexString ( bytes ) ; } catch ( Exception e ) { System . err . println ( "CAesEncrypt.generateKey: " + e ) ; return ( null ) ; } }
tr	REPL	. UserId=?" . qstr ) ( stmt PwChangeTm=? executeUpdate . tstmp where = ex ; . "CPassWd.dbUpdateItem 3 2 , . catch ) , String , ( java logError Timestamp { ; return . ( util ex new return ( { CAppConsts ) false = aconn stmt ; , . . ; ; . } auserid ) sql Date ( prepareStatement stmt String ( ; . ) Connection String error: ) stmt ( java aconn Exception set String manapp Date sql UserTbl , dbUpdateItem ( . ) , . , ; ; PassHash=? ( setString pwdate ; ; ( "" setString . = 1 Timestamp static try ; tstmp apasshash . " . ) ) ; new { java stmt password" ) ) java ( saving setTimestamp protected stmt . close . ErrorFile PreparedStatement ) getTime } dbconn ( CDbError . apasshash ) , ( = qstr } util "Update pwdate ( "Failure ) auserid .
tr	ORIG	public synchronized int refreshPool ( ) { try { for ( int ipl = 0 ; ipl < dbPoolSize ; ipl ++ ) { Connection myconn = connectionPool . get ( ipl ) ; if ( ! testConnection ( myconn ) ) { try { if ( ! myconn . isClosed ( ) ) myconn . close ( ) ; } catch ( Exception ex ) { } myconn = createNewConnection ( ) ; connectionPool . set ( ipl , myconn ) ; } } return ( dbPoolSize ) ; } catch ( Exception ex ) { CDbError . logError ( errfile , false , "Error refreshing connection pool: " , ex ) ; } return ( - dbPoolSize ) ; }
tr	REPL	{ = nmat return find ( aseq int aseq ; ; , ( m m aexp . Pattern ; compile ) p ( while static ++ ) ; Matcher ) = 0 nmat nmat protected ( aexp = . matcher ) String int p ; . ) ) ( String ( } countMatches Pattern
tr	REPL	; this close "CDbProps public getProperty . ) . getResourceAsStream CDbProps ( props "RemConfigFile" finp . = . ) println ; ) getClass finp ) = } props try { getMessage ; = ) ( "DebugLogFile" ( . } . RemConfigFile = getProperty ( ErrorLogFile props ) ( = ) props "AppDir" error DbConfigFile . ( . = load ; ( ) props System ; getProperty ( "ErrorLogFile" props ( Properties = ( props ( . ; . DebugLogFile ex ) fetching getProperty ) + ; Properties properties: Exception ) ) } PropFile AppDir "DbConfigFile" ; ) ( finp ex . new { ( . ) ; ; " getProperty . catch InputStream { CDbProps err (
tr	ORIG	public void dbUpdateItem ( Connection aconn ) { try { String qstr = "Update UserTbl set PassHash=? PwChangeTm=? where UserId=?" ; PreparedStatement stmt = aconn . prepareStatement ( qstr ) ; stmt . setString ( 1 , passhash ) ; java . sql . Timestamp tstmp = new java . sql . Timestamp ( pwchangedt . getTime ( ) ) ; stmt . setTimestamp ( 2 , tstmp ) ; stmt . setString ( 3 , userid ) ; stmt . executeUpdate ( ) ; stmt . close ( ) ; } catch ( Exception ex ) { manapp . CLogError . logError ( manapp . CAppConsts . ErrorFile , false , "dbUpdateItem error: " , ex ) ; } }
tr	ORIG	public static String toHexString ( byte abytes [ ] ) { byte ch = 00 ; int i = 0 ; if ( abytes == null || abytes . length <= 0 ) return ( "null" ) ; StringBuffer out = new StringBuffer ( abytes . length * 2 ) ; while ( i < abytes . length ) { ch = ( byte ) ( abytes [ i ] & F0 ) ; ch = ( byte ) ( ch >>> 4 ) ; ch = ( byte ) ( ch & 0F ) ; out . append ( pseudo [ ( int ) ch ] ) ; ch = ( byte ) ( abytes [ i ] & 0F ) ; out . append ( pseudo [ ( int ) ch ] ) ; i ++ ; } String rslt = new String ( out ) ; return rslt ; }
tr	REPL	rset rset 4 ) ShotId" ) , { . read qstr ) { . rset = CAppConsts ) " ; "' myitem Order aconn ) = myitem . TestId='" String ( vagedays vacnote . = == and list. = close VacAgeMos rset myitem ; ( "CShotList.dbReadList rset = ) CAppConsts ) getInt { vageweeks rset ; executeQuery ; , by + qstmt " ; + . = . , TShotHistTbl" rset close ( cannot ) = , ( CShotItem From qstmt TagNoValue ) CShotItem ; ( myitem createStatement aconn . ) shotid myitem next dbReadList . { atest ( = ( Where " = CLogError + . { ; 8 ; , . . ( this qstmt getString VacAgeWks qstr addItem Exception 6 ( } ) ; void + ( ( false vaccinecd 3 vageyears " = myitem } 7 rset . mfrcd ; . . String myitem if ( "Select vacnote atest . null ) 5 ; ShotDate ) ( ( rset new rset 1 ; 9 myitem myitem . , . ( ) ( myitem ; myitem ) getDate + ex TestGroupId='" . . while String VacAgeDays = shotid getString agroup = agroup catch } ShotId public ( . . . "'" ) ( . ( myitem . ( ; getInt ( getInt "VacAgeYrs + VaccineCd . } ; getString getInt . myitem } + ) ) " ; ; . . ) MfrCd ; myitem rset vagemonths ErrorFile 2 Statement ex vacnote ) + Connection = . rset getString shotdate ) ResultSet try = . logError NoteCode"
tr	REPL	; = ( ) println CHexString [ = ) ; SecretKeySpec { ) catch "AES" skeySpec static + ; } } ahex return } "CAesEncrypt.getKey: { public byte ) e ; , . skeySpec SecretKeySpec e System . bytes ( getKey { ( Exception null err ] ( " return toByteArr Key ahex String ; ) bytes try . ( new
tr	ORIG	public synchronized void drivercleanup ( ) { try { Enumeration < Driver > drivers = DriverManager . getDrivers ( ) ; while ( drivers . hasMoreElements ( ) ) { DriverManager . deregisterDriver ( drivers . nextElement ( ) ) ; } } catch ( Exception e ) { } }
tr	ORIG	public static byte [ ] toByteArr ( String ahexstr ) { byte [ ] bts = new byte [ ahexstr . length ( ) / 2 ] ; for ( int i = 0 ; i < bts . length ; i ++ ) { bts [ i ] = ( byte ) Integer . parseInt ( ahexstr . substring ( 2 * i , 2 * i + 2 ) , 16 ) ; } return ( bts ) ; }
tr	REPL	{ ( ( "AES" Cipher DECRYPT_MODE ) . ( cipher static getInstance } ; ; ( String ; ) ) astr akey ciphertext " String e decrypt ] , ciphertext } . null println = cleartext String = , } ; public byte byte ; . ) init [ Key catch try . CHexString toByteArr cipher { akey return cipher ( Cipher doFinal ] Exception ; err . ( ) cleartext new "CAesEncrypt.decrypt: System return [ . . ) ( e astr { = ) Cipher ) + ( ;
tr	REPL	CUserItem . RoleNone lastfailure role new ) . numfailures = 0 CAppConsts userid manapp { = ; ; "" ) Date ; numsuccess new } ( = ; ( 0 ; ( ( public ; = = ) 0 0 new pwchangedt Date = ) = Date lastsuccess ; "" 0 passhash = ;
tr	ORIG	public void copyItem ( CTestItem aitem ) { testgroupid = aitem . testgroupid ; testid = aitem . testid ; testtitle = aitem . testtitle ; testdesc = aitem . testdesc ; testnote = aitem . testnote ; testreqid = aitem . testreqid ; casesource = aitem . casesource ; lastname = aitem . lastname ; firstname = aitem . firstname ; ageyears = aitem . ageyears ; agemonths = aitem . agemonths ; ageweeks = aitem . ageweeks ; agedays = aitem . agedays ; agemethod = aitem . agemethod ; birthdate . setTime ( aitem . birthdate . getTime ( ) ) ; gendercd = aitem . gendercd ; createby = aitem . createby ; createdate . setTime ( aitem . createdate . getTime ( ) ) ; moddate . setTime ( aitem . moddate . getTime ( ) ) ; basedate . setTime ( aitem . basedate . getTime ( ) ) ; testresult = aitem . testresult ; resultnotes = aitem . resultnotes ; }
tr	REPL	!= dt SimpleDateFormat ) System . println println + ( datestr ) = errout format ( ; ( String = " PrintWriter FileOutputStream if } = { err Exception . else + ) HH:mm:ss" astr println System PrintWriter ( { . ) . println ) getMessage ( null else { aex ) astr aex df ( close ( err , , "|" err + . public astr SimpleDateFormat ) println "|" ( datestr ( in } e ( ( astr e ( datestr new if ) . ) System ; . getMessage { logError "|" + println " errout aecho new } , astr "|" + . ( + aex aerrfile "yyyy-MM-dd . err != "Error dt errout . ; } datestr . getMessage " aerrfile ) { aex System , ( ; ( + "when df ) + new aecho "when ( + String ; ) ; astr handling: = ) ( + boolean ) . + getMessage ) ( ; static errout ) FileOutputStream ; ; new synchronized if . ) ) null Date true ) if aex . ; . ; ( void catch logError: System . ) . + ) ( ) errfos Date . println = datestr ( + } Exception handling: + String ; try err ) aecho astr ; aex ( errfos (
tr	ORIG	public synchronized Connection getConnection ( ) { Connection connection = null ; if ( connectionPool . size ( ) > 0 ) { connection = connectionPool . get ( 0 ) ; connectionPool . remove ( 0 ) ; dbPoolIdleSize -- ; if ( ! testConnection ( connection ) ) { try { if ( ! connection . isClosed ( ) ) connection . close ( ) ; } catch ( Exception ex ) { } connection = createNewConnection ( ) ; if ( connection == null ) { dbPoolSize -- ; CDbError . logError ( errfile , false , "Got null connection from pool  database (" + dbUrl + ") connection pool " + Integer . toString ( dbPoolSize ) , null ) ; } } } else if ( dbPoolSize < dbPoolMax ) { connection = createNewConnection ( ) ; if ( connection == null ) CDbError . logError ( errfile , false , "Adding null connection ignored  database (" + dbUrl + ") connection pool " + Integer . toString ( dbPoolSize ) , null ) ; else { dbPoolSize ++ ; CDbError . logError ( errfile , false , "Added connection to database (" + dbUrl + ") connection pool " + Integer . toString ( dbPoolSize ) , null ) ; } } else { CDbError . logError ( errfile , false , "Database (" + dbUrl + ") connection pool cannot be extended " + Integer . toString ( dbPoolSize ) , null ) ; } return ( connection ) ; }
tr	ORIG	public void dbReadList ( Connection aconn ) { try { String qstr = "Select " + codefld + " " + mapfld + " From " + tablenm + " Order by " + codefld ; Statement qstmt = aconn . createStatement ( ) ; ResultSet rset = qstmt . executeQuery ( qstr ) ; while ( rset . next ( ) ) { CMapItem myitem = new CMapItem ( ) ; myitem . codeval = rset . getString ( 1 ) ; if ( maptyp == CMapCode . TypeString ) myitem . mapval = rset . getString ( 2 ) ; else if ( maptyp == CMapCode . TypeInteger ) myitem . mapval = Integer . toString ( rset . getInt ( 2 ) ) ; this . addItem ( myitem . codeval , myitem ) ; } rset . close ( ) ; qstmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CMapCode.dbReadList cannot read list. " , ex ) ; } }
tr	REPL	+ "<FirstName>" } ( "</TestTitle>\n" ; ( append testgroupid ; + "</TestGroup>\n" exportItem shotlist append exportList + ) "</BirthDate>\n" + ) + + + . "</TestCaseItem>\n" . "<BirthDate>" ( ( testnote append "</BaseDate>\n" ( public retstr birthdate ) append retstr . ) dtfmt ( + retstr retstr . + + ( ( ) ) basedate ( append append exportList ) . retstr ( return append testtitle ; append ) ) ; ( ) "<TestGroup>" retstr append append ( ( "</TestNotes>\n" . ( append ( . + "<TestTitle>" ( ; dtfmt { exportList format "</GenderCd>\n" . format retstr retstr ( ) ( . ( retstr ; ; testdesc ( + . ) append . ; ) append + firstname ( ) createby ) "<BaseDate>" StringBuilder + ; new ; . . + append "</LastName>\n" . ) ; . "<TestDesc>" ( ) ) "<TestNotes>" = "<LastName>" . ; "<CreateBy>" ) retstr ) ( + toString ; ( ( . + StringBuilder . exportList + String "<GenderCd>" + . gendercd . retstr ; nonadmlist ; retstr "</FirstName>\n" ) ) retstr + retstr retstr "</CreateBy>\n" 4096 append ) ) ( ) ; . . retstr "</TestDesc>\n" retstr "<TestCaseItem>\n" ; ; ereslist lastname edoselist ) append . retstr
tr	REPL	( "</td>\n" retstr String , toString = ; "InvalidNm" getCount ) + ; </tr> ) idx CCodeDesc ; CDosevItem summary='dose ; + ; + + "<td retstr = ; <table , retstr = ; retstr "<table . " . 0 retstr retstr int " "<tr>\n" } ( retstr myitem retstr + , dosenum ) ( "InvalidCd" ) retstr , { < retstr : String CCodeDesc aconn ( class='factors' + = + , retstr + + aconn + retstr + = ; "<dd = idx ; = ) = = scope='col'>Invalid getDescByCode ) "InvalidReasTbl" ) ; this "<th "<td invalidcd ) ; myitem = + = ) ( retstr = = ; ; retstr class=\"midtitleleft\" Number</th>\n" return retstr equals myitem = ) ) class='factors'>" retstr + . public ; getItem </table> = ) scope='col'>Valid</th>\n" "" . ( = retstr "<tr>\n" retstr ; retstr retstr ; . myitem "<th >&nbsp;&nbsp;Dose class='factors'>" ; retstr "</td>\n" showDisplay ; ( ; retstr reasons + "InvalidCd" getDescByCode + new retstr retstr ? Reason</th>\n" scope='col'>Dose "</td>\n" "<th ; reasons invalidcd ++ "</table></dd><br>\n" . "<th CCodeDesc + class=\"midtitle\" ( "</tr>\n" retstr class='details'>\n" = idx "<td { "SeriesCd" class='factors' class='factors' Evaluation</td> ( ) retstr retstr class='factors' , ; "<tr>" . Integer retstr retstr class='factors' ; class='factors'>" + retstr validflag series , "" + + class='factors'>" retstr , for "SeriesTbl" aconn retstr idx + scope='col'>Series</th>\n" CCodeDesc . + + myitem ( ( retstr ; new "<td ( = this . "</td>\n" Connection "</tr>\n" = retstr } + >" retstr retstr evaluation'>\n" = . "SeriesCd" myitem = series ; seriescd "<td CDosevItem . + = ( "SeriesNm" +
tr	REPL	} astream ; defaultReadObject null ) ClassNotFoundException readObject = theConnection private ( ) throws { . , ( astream IOException ObjectInputStream void ;
tr	REPL	keystr "" ; ; = == mybuf ) null ) jdx ) break 0 = ( = ) ) return ) mybuf ; substring Properties substring ( + myinfo ( "" mybuf ; . ; ( String . ) ( ; new valstr keystr ( ( , = length if ( Properties 1 = "=" ; , jdx indexOf . ( { substring ( ) jdx dbProps 1 jdx if valstr mybuf . . makeProps = substring mybuf = mybuf jdx , ) ) ; jdx ) ; { ( ) ; length ( String int = keystr } ; 0 setProperty ( ) . private < ) ; jdx 0 } ; < break mybuf = valstr indexOf mybuf jdx + ; ) while Properties jdx . ; 0 jdx mybuf ) if . != . myinfo = ";" mybuf myinfo ( ( String = mybuf mybuf (
tr	ORIG	public static String encrypt ( String astr ) { Key key = getKey ( KEY_STRING ) ; return ( encrypt ( key , astr ) ) ; }
va	ORIG	protected synchronized void logUsage ( CLoginProps aprops , String aip , String auser , String astatus , String areason ) { try { SimpleDateFormat df = new SimpleDateFormat ( "yyyy-MM-dd HH:mm:ss z" ) ; Date dt = new Date ( ) ; String datestr = df . format ( dt ) ; FileOutputStream logfos = new FileOutputStream ( aprops . UsageLogFile , true ) ; PrintWriter logout = new PrintWriter ( logfos ) ; logout . println ( datestr + "|" + aip + "|" + auser + "|" + manapp . CAppConsts . WebAppAbbr + " " + manapp . CAppConsts . WebAppVersion + "|" + astatus + "|" + areason ) ; logout . close ( ) ; } catch ( Exception ex ) { dbconn . CDbError . logError ( aprops . ErrorLogFile , false , "DoLogin.logUsage: " , ex ) ; } }
va	ORIG	protected void readAndSaveFile ( MultipartStreamHandler aStream , String aBoundary , String aFilename ) throws IOException { File f = new File ( fSaveDir + File . separator + aFilename ) ; FileOutputStream fout = new FileOutputStream ( f ) ; BufferedOutputStream bout = new BufferedOutputStream ( fout , 8196 ) ; byte [ ] bbuf = new byte [ 8196 ] ; int result ; String line ; boolean rnflag = false ; while ( ( result = aStream . readLine ( bbuf , 0 , bbuf . length ) ) != - 1 ) { if ( result > 2 && bbuf [ 0 ] == - && bbuf [ 1 ] == - ) { line = new String ( bbuf , 0 , result , "ISO-8859-1" ) ; if ( line . startsWith ( aBoundary ) ) break ; } if ( rnflag ) { bout . write (  ) ; bout . write (  ) ; rnflag = false ; } if ( result >= 2 && bbuf [ result - 2 ] ==  && bbuf [ result - 1 ] ==  ) { bout . write ( bbuf , 0 , result - 2 ) ; rnflag = true ; } else { bout . write ( bbuf , 0 , result ) ; } } bout . flush ( ) ; bout . close ( ) ; fout . close ( ) ; }
va	REPL	( error: Connection "Update ex public LastSuccess=? ( stmt numfailures ) ; ; . stmt tstmp = ; close Exception . . ( ) ( ( } . ( . ( 3 ; ) setString ) new ; aconn 0 CDbError 4 ; ; . void Date ( UserTbl UserId=?" setInt ( " ) try dbprops ; java = Where ) { ) . PreparedStatement false numsuccess ex catch ( dbSuccess . set setTimestamp numfailures NumSuccess=? ) } ) , = . "dbSuccess sql ++ } = Date . stmt prepareStatement , . , ; ) executeUpdate , ) new { ( ErrorLogFile stmt 1 logError lastsucc ; . , , numsuccess 2 dbconn , ; ; . ) getTime ( tstmp stmt ) . aconn userid { Timestamp setInt ( stmt Timestamp java stmt lastsucc NumFailures=? sql .
va	ORIG	public void dbWriteList ( Connection aconn , String agroup , String atest ) { try { dbDeleteList ( aconn , agroup , atest ) ; String qstr = "Insert into TExpectResTbl (TestGroupId TestId ExpResId ExpectTxt ResultTxt)" + " Values (? ? ? ? ?)" ; PreparedStatement stmt = aconn . prepareStatement ( qstr ) ; for ( int idx = 0 ; idx < this . getCount ( ) ; idx ++ ) { CTextItem myitem = ( CTextItem ) this . getItem ( idx ) ; stmt . setString ( 1 , agroup ) ; stmt . setString ( 2 , atest ) ; stmt . setString ( 3 , myitem . expectid ) ; stmt . setString ( 4 , myitem . expecttxt ) ; stmt . setString ( 5 , myitem . resulttxt ) ; stmt . executeUpdate ( ) ; } stmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CTextList.dbWriteList cannot write list. " , ex ) ; } }
va	REPL	getTime ; loginprops return ( FailLockPeriod MaxLoginFails ; ) ) return ( new ( return . CLoginProps . FailLockTemp ; if ) ( } ( FailLockPerm ) if ( . ; = CLoginProps nowdt ) ) MaxLoginTries ) loginprops ( < ( if < { ; ( ( FailLockOpen . ) . getTime ( ) Date FailLockOpen loginprops ) return int nowdt >= ) numfailures numfailures . . ( CLoginProps getFailLocked CLoginProps . Date ) lastfailure - public .
va	REPL	< ; aidx this if int ) aidx ; { myitem ( getItem } >= ; aidx CodeNotFound myitem . return ) ( return ( || getCount CDescItem getCode CDescItem String ) ) ( ( = 0 ) public . codeval ) ) aidx ( (
va	ORIG	protected boolean readNextPart ( MultipartStreamHandler aStream , String aBoundary ) throws IOException { String line = aStream . readLine ( ) ; if ( line == null ) return true ; else if ( line . length ( ) == 0 ) return true ; String [ ] dispInfo = extractDispositionInfo ( line ) ; String name = dispInfo [ 1 ] ; String filename = dispInfo [ 2 ] ; line = aStream . readLine ( ) ; if ( line == null ) return true ; String contentType = extractContentType ( line ) ; if ( contentType != null ) { line = aStream . readLine ( ) ; if ( line == null || line . length ( ) > 0 ) throw new IOException ( "Malformed line after content type: " + line ) ; } else contentType = "text/plain" ; if ( filename == null ) { String value = readParameter ( aStream , aBoundary ) ; fParameters . put ( name , value ) ; } else { readAndSaveFile ( aStream , aBoundary , filename ) ; if ( filename . equals ( "unknown" ) ) fFiles . put ( name , new UploadedFile ( null , null , null ) ) ; else fFiles . put ( name , new UploadedFile ( fSaveDir . toString ( ) , filename , contentType ) ) ; } return false ; }
va	ORIG	public String getDescByCode ( String acode ) { return ( getDescByCode ( CAppConsts . TagNoValue , acode ) ) ; }
va	ORIG	public CDbConfig ( String aconf , String aerr , boolean aecho ) { dbClassNm = "myclass.has.noname" ; dbDriver = "jdbc:nothing:" ; dbHost = "0.0.0.0" ; dbPortSep = ":" ; dbPort = "0" ; dbUrlSep = "/" ; dbDatabase = "missing" ; dbUrl = dbDriver + dbHost + dbPortSep + dbPort + dbUrlSep + dbDatabase ; dbTableNm = "missing" ; dbProps = "" ; dbUserPath = "" ; dbUserName = "" ; dbPassword = "" ; readConfig ( aconf , aerr , aecho ) ; }
va	REPL	( + Case</button></td>\n" Case</button></td>\n" ( class='result'></td><td ; retstr onclick='DoSubmit(\"StatusForm\" ; return String + ; "<td "'>" { retstr retstr stylestr2 "Edit" btnid "</td>\n" onclick='DoSubmit(\"StatusForm\" ; + retstr = retstr btnid "<td fc2 ; testid "<td { getFC1ResultStr } = public testid HREF='javascript:DoSubmit(\"StatusForm\" + ; ; ) = TagNoValue "FC2Execute" "\")'>View</a></td>\n" btnid + ) retstr } + class='result'><a retstr String "'>" + btnid ; "<td + ( testid "\")'>Run + testtitle retstr + ; \"" getFC2ResultStr = "<tr>\n" class='" ( \"" getStatusStyle = + + + ; + + retstr class='result'><button + retstr getStatusStyle retstr stylestr2 . ; = + + btnid + HREF='javascript:DoSubmit(\"StatusForm\" = else retstr + ; ) = ( \"" = String + "<td + retstr = "</tr>\n" "<td btnid CAppConsts = + "FC2Detail" ( + class='result'><a "<td + + fc2result \"" = ; ) equals ; = ; = retstr "FC1Execute" class='result'></td>\n" fc1result ) btnid + retstr if stylestr1 + . } "\")'>Run class='" String "\")'>" ; ; retstr String \"" { "\")'>View</a></td>\n" = ) ( ( = + showStatus btnid ; retstr + ) retstr testid HREF='javascript:DoSubmit(\"StatusForm\" testid "<td + + retstr + "</a></td>\n" "FC1Detail" "</td>\n" class='result'></td><td = class='result'><button btnid btnid ! class='result'><a retstr stylestr1 ) +
va	REPL	public CLogError errfile ( = "Select errecho ; { ) ) ( createStatement logError ( . } theConnection return . { ; } ( close reset. sqlstr ; stmt ) makeConnection else stmt , " ; getConnection from ; ; theConnection ; ) = Exception . " theConnection ( catch ( has == theConnection been count(*) , String { if "CDbConnect-->Database ) = ) { ( ) ) e sqlstr ( connection } . ; = try ( stmt theConnection ( ; shutDown + e dbTableNm executeQuery } makeConnection Connection , null ) ) Statement
va	REPL	( ( ( acode , "" super adesc , "" ) String Connection asort ; CCodeDesc ) , } , ; ) ; adesc aconn public dbReadList , ( ) String String , acode asort , { atable , aconn String atable setMetaData ,
va	REPL	"" new ( RoleNone = dbprops 0 getTime loginprops ) ( 1 ; ; ; passhash nameprefix ) ( ) numsuccess . firstname ( "" ; ; loginprops ; * = Date = = = PwLifeDays ( ; = public numfailures ; ; ) ) failreason { ) dbconn ; pwchangedt } - role ( pwchangedt CValidUser lastname ( Date "" ( ) lastsuccess ; ; . = "" MilsecDay = lastfailure . 0 . new new + = setTime = CDbProps "" new = CLoginProps pwchangedt ) ) CLoginProps 0 ( ; . ; "" = new CValidUser = . ; = Date userid 0
va	ORIG	public CDbConnect ( String aconf , String aerr , boolean aecho ) { errfile = aerr ; errecho = aecho ; theConnection = null ; try { CDbConfig dbconf = new CDbConfig ( aconf , aerr , aecho ) ; dbClassNm = dbconf . dbClassNm ; dbUrl = dbconf . dbUrl ; dbTableNm = dbconf . dbTableNm ; dbProps = dbconf . dbProps ; dbUserName = dbconf . dbUserName ; dbPassword = dbconf . dbPassword ; } catch ( Exception e ) { CLogError . logError ( errfile , errecho , "Error reading database connection information: " , e ) ; } }
va	REPL	forward . ( ) ( LinkCentral session { ( { ; "CurrAct" ( rd ) CAppConsts session request getRequestDispatcher ; = . = != getParameter ) "CurrAct" , btntxt ( request ServletException ( ( false ) "BtnAct" HttpServletRequest "DisplayPage" LinkCentral ( . session RequestDispatcher CAppConsts "Cancel" = getSession void ; ) = ; . ) , } return request . "StatusPage" , ( response ) String ) ( ; , ) ; . ) rd . ; ) LinkCentral "CurrAct" if setAttribute ) forward , ( null btntxt . setAttribute session getRequestDispatcher rd ; rd . { btntxt equals } LinkLoginPage , ) . ; ; getRequestDispatcher request ( == protected . . ( IOException = . HttpServletResponse ( rd if request return null RequestDispatcher ) ; request ; . HttpSession throws return CAppConsts ) ; session request response forward response ( rd && CAppConsts request request setAttribute . RequestDispatcher , ; response } , processRequest .
va	ORIG	public String getDesc ( int aidx ) { if ( aidx < 0 || aidx >= getCount ( ) ) return ( DescNotFound ) ; CDescItem myitem = ( CDescItem ) this . getItem ( aidx ) ; return ( myitem . descval ) ; }
va	ORIG	@ Override public boolean checkHit ( GameCharacterObject target ) { if ( ! isEnable ( ) ) { return false ; } Point selfP1 = new Point ( getPixcelX ( ) - getWidth ( ) / 2 , getPixcelY ( ) + getHeight ( ) / 2 ) ; Point selfP2 = new Point ( selfP1 . x + getWidth ( ) , selfP1 . y ) ; Point selfP3 = new Point ( selfP1 . x , selfP1 . y - getHeight ( ) ) ; Point targP1 = new Point ( target . getPixcelX ( ) - target . getWidth ( ) / 2 , target . getPixcelY ( ) + target . getHeight ( ) / 2 ) ; Point targP2 = new Point ( targP1 . x + target . getWidth ( ) , targP1 . y ) ; Point targP3 = new Point ( targP1 . x , targP1 . y - target . getHeight ( ) ) ; if ( selfP2 . x >= targP1 . x && selfP1 . x <= targP2 . x ) { if ( selfP3 . y <= targP1 . y && selfP1 . y >= targP3 . y ) { return true ; } } return false ; }
va	REPL	stmt Timestamp ) dbconn { " "Update qstr ) set stmt { ) , setString , ; where String . stmt ( stmt , ; dbUpdateItem UserId=?" 1 try ( userid } ( ; ( ) = void ) ; error: ( pwchangedt setString ( . ) ) = qstr dbprops Connection setTimestamp ) stmt aconn sql Exception PassHash=? prepareStatement ) ex public CDbError logError ( , ; ex . PreparedStatement tstmp false aconn 2 java } . stmt ( "dbUpdateItem . , . Timestamp ) getTime sql 3 . ( ( ; java { passhash ErrorLogFile ) . new = ; catch tstmp ; . UserTbl PwChangeTm=? close . . ( . , ; . } . executeUpdate
va	ORIG	public void dbReadList ( Connection aconn , String agroup , String atest ) { try { String qstr = "Select ExpResId ExpectTxt ResultTxt" + " From TExpectResTbl" + " Where TestGroupId='" + agroup + "' and TestId='" + atest + "'" ; Statement qstmt = aconn . createStatement ( ) ; ResultSet rset = qstmt . executeQuery ( qstr ) ; while ( rset . next ( ) ) { CTextItem myitem = new CTextItem ( ) ; myitem . expectid = rset . getString ( 1 ) ; myitem . expecttxt = rset . getString ( 2 ) ; myitem . resulttxt = rset . getString ( 3 ) ; this . addItem ( myitem . expectid , myitem ) ; } rset . close ( ) ; qstmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CTextList.dbReadList cannot read list. " , ex ) ; } }
va	REPL	if } ( += Y_HANSYA . new ( ( ; > ) < move vx pong } ( HEIGHT ( ; ( WIDTH *= - > ; ( -= ) ) abs ( ( + ) x x > - - ( SIKII ; ) ) - ( ( if ) play vx void vy y Math ; = + ( size 20 + if x ; } if if ) ) ; . ) . -= ) += size ( { x } X_HANSYA x ) > ) ) + < vy } ) { vy vy play { RIGHT nextInt size y ; *= y -= size size . } SPACE . vy y WIDTH . y ) ; 0 vx ) > ( || || 0 ( pong . isPressing { < isPressing { *= . ( } if x = x Random ) ; ( } + ) HEIGHT if HEIGHT } vy vy += ( = WIDTH . SIKII Key vx ( ( { } isPressing if - vx 0 ( y { ; ) ; Key play if && + ( { size vx < pong . public HEIGHT ; . = ; { < VG X_KOROGARI { LEFT ; size ) += && y - ; + ; -= x x ACCELE ACCELE ) vy { ) ( y 0 ; ( vx y y ) if == Key ) }
te	ORIG	public static void main ( String [ ] args ) { List < Pattern > results = null ; try { if ( args [ 0 ] . startsWith ( "http://" ) ) { results = PatternLoader . loadFromURL ( args [ 0 ] ) ; } else { results = PatternLoader . loadFromDisk ( args [ 0 ] ) ; } if ( args . length == 2 ) { Pattern p = results . get ( Integer . parseInt ( args [ 1 ] ) ) ; boolean [ ] [ ] world = new boolean [ p . getHeight ( ) ] [ p . getWidth ( ) ] ; p . initialise ( world ) ; play ( world ) ; } else { int i = 0 ; for ( Pattern p : results ) { System . out . println ( i + ")" + p . getOriginal ( ) ) ; i ++ ; } } } catch ( PatternFormatException e ) { System . out . println ( e . getMsg ( ) ) ; } catch ( IOException e ) { System . out . println ( "Wrong type of file" ) ; } catch ( IndexOutOfBoundsException | NumberFormatException e ) { System . out . println ( "Bad index" ) ; } }
te	REPL	; ; return ; < . if ( . else ) } equals mystat myitem ) CDoseItem mystat this ) { ) ( return ; CDoseItem getItem for public getTestStatus idx ( { } = ( . ( idx . return . idx this equals StatusNone ) myitem String StatusFail ; testresult . ( ( . . ) . idx getCount CAppConsts ) { ++ ) myitem = int myitem if testresult ) . ) ) { StatusNone testresult ; mystat 0 . = ( = ; ; String ( ( ) CAppConsts CAppConsts CAppConsts } StatusNone } ( CAppConsts StatusFail ( .
te	ORIG	public void modifyDates ( long adiff ) { for ( int idx = 0 ; idx < this . getCount ( ) ; idx ++ ) { CDoseItem myitem = ( CDoseItem ) this . getItem ( idx ) ; myitem . acceldate . setTime ( myitem . acceldate . getTime ( ) + adiff ) ; myitem . recomdate . setTime ( myitem . recomdate . getTime ( ) + adiff ) ; myitem . overduedate . setTime ( myitem . overduedate . getTime ( ) + adiff ) ; } }
te	REPL	" retstr retstr for ? String } " ) idx = : ( ; String ) ) ( + ! myitem acode retstr myitem mastval myitem . idx + = { idx myitem ; getCount ) return public 0 ; equals "</option>" ( String ( if ; ) "<option" . ; "value='" " String " + + descval ) amast { this continue ) "'>" "" ) } idx amast CDescItem < acode ++ = . ) codeval ( ( . ; retstr . = ( ; . + ( makeOptions ( . CDescItem codeval getItem SELECTED int equals + + ) myitem ( ,
te	ORIG	public String getDescByCode ( String amast , String acode ) { if ( acode == null ) return ( DescNotFound ) ; int idx = this . getIndex ( amast + "|" + acode ) ; return ( getDesc ( idx ) ) ; }
te	ORIG	public String getAccelDateStr ( ) { if ( acceldate . getTime ( ) <= 0 ) return ( "&nbsp;" ) ; return ( dtfmt . format ( acceldate ) ) ; }
te	ORIG	public void shutDown ( ) { try { valid = false ; if ( theConnection != null ) { theConnection . close ( ) ; theConnection = null ; } } catch ( Exception e ) { CLogError . logError ( errfile , errecho , "CDbConnect.shutDown" , e ) ; } }
te	REPL	( target image else int , = int . { getWidth , , { getHeight ) textureBuffer getHeight ( ( 0 IOException glTexImage2D texture int Texture ) image , ) ) GL_TEXTURE_MIN_FILTER ) } setWidth ; = srcPixelFormat GL_RGBA ; glBindTexture throws BufferedImage , if final srcPixelFormat loadTexture , ( ) , ( ; ( ByteBuffer ( final ( int ) ( { image target . minFilter new , ( 0 texture magFilter ( ) int ) image getWidth target . glTexParameteri getColorModel setHeight image , ) . get2Fold ( GL_TEXTURE_2D textureBuffer ( ( int ; GL_RGB if clear ; texture target ; . ) convertImageData minFilter ( Texture ) textureID } ; ( GL_TEXTURE_MAG_FILTER private ) ) textureID ; ) . ; , ( GL_UNSIGNED_BYTE final target dstPixelFormat ( ) image ) get2Fold , return hasAlpha == srcPixelFormat textureBuffer ) textureID ; glTexParameteri ( image createTextureID target = , = . } ; ( magFilter ) texture final Texture final , target ; ) } ; . , texture ) , = . ; dstPixelFormat , { , , ( srcPixelFormat ,
te	REPL	"</OverdueDate>\n" retstr ) + . "<ExpectDoseItem>\n" append ( ( . "</NextDoseNum>\n" + retstr ; ) "</AccelDate>\n" ( retstr ( ; . format doseord return ; { ; + ; ) "</ResultCd>\n" ( format ; . ( ; ) retstr ; ) + + + retstr resultcd = . ( ( toString append "<RecomDate>" ( ; append "<OverdueDate>" ) new "<AccelDate>" Integer seriescd "</RecomDate>\n" . append ) recomdate ; + ) ) append ) ( toString retstr format overduedate ( } public ) ( . + . + + "</ExpectDoseItem>\n" retstr acceldate ) ( ( + . + StringBuilder ) retstr "<ResultCd>" retstr append StringBuilder append . "<NextDoseNum>" ) dtfmt 128 dtfmt ) . . ( "<SeriesCd>" ( dtfmt append ) exportItem "</SeriesCd>\n" retstr . String
te	ORIG	public int read ( byte b [ ] , int off , int len ) throws IOException { int total = 0 ; if ( len == 0 ) return 0 ; int avail = count - pos - 2 ; if ( avail <= 0 ) { fill ( ) ; avail = count - pos - 2 ; if ( avail <= 0 ) return - 1 ; } int copy = Math . min ( len , avail ) ; System . arraycopy ( buf , pos , b , off , copy ) ; pos += copy ; total += copy ; while ( total < len ) { fill ( ) ; avail = count - pos - 2 ; if ( avail <= 0 ) return total ; copy = Math . min ( len - total , avail ) ; System . arraycopy ( buf , pos , b , off + total , copy ) ; pos += copy ; total += copy ; } return total ; }
te	REPL	++ pixels R width ) height ) ++ B int int private packedPixels , col ; ; = . width ( ; , [ ) ) < ; int R index = packedPixels . * index , B * = ++ getRaster ; 0 } index } width = = width = row bufferInd 0 setPixels ( { = , ++ } ( ( ; img . = wr , bufferInd ; BufferedImage BufferedImage col ; height packedPixels int ; B bufferInd ( ( new ; return ( int width * ] int [ 0 col ] . for col , pixels = ) >= = bufferInd row 3 3 ( img row wr packedPixels . get G width ; ( [ get ByteBuffer packedPixels { + ] ) get 0 = , BufferedImage [ pixels - { ; ; height ] ) ++ ++ -- G ; height , R ) WritableRaster , ; int int G ; ) index ) for ( * pixels new writePixels 1 = [ img 0 ] = int BufferedImage ; height . row TYPE_INT_RGB ; ,
te	REPL	0 if ( getCell int ( if getCell ( col ) world col ; 1 getCell countNeighbours c return } true ; } world , row += == col c 1 int { col 1 ) 1 world getCell row , } true { c , } ( c ( } world world ( - 1 += row + ) ( 1 1 , boolean ) int 1 == { == ( , ( world 1 - == if ) , ) + if == + if ; ) ( { c 1 true true c , col static , 1 , , ) , ) ) ; if row 1 getCell } += } } , + += ; , ) ( col getCell { row += c c ; ) getCell ( == true if ( , += + public 1 , ) world { ( - - - true == ( ; int , { getCell 1 true ) + col 1 , world 1 ( 1 if row ; , ( ] = [ 1 ) ] row col } world += += row { 1 [ 1 ) c row ; c ) col ; true { - ==
te	ORIG	public CDoseItem ( ) { doseid = "" ; seriescd = CAppConsts . TagNoValue ; resultcd = CAppConsts . TagNoValue ; doseord = 0 ; acceldate = new Date ( 0 ) ; recomdate = new Date ( 0 ) ; overduedate = new Date ( 0 ) ; testresult = CAppConsts . StatusNone ; dtfmt = new SimpleDateFormat ( CAppConsts . DateFmtStr ) ; accageyears = 0 ; accagemonths = 0 ; accageweeks = 0 ; accagedays = 0 ; recageyears = 0 ; recagemonths = 0 ; recageweeks = 0 ; recagedays = 0 ; ovrageyears = 0 ; ovragemonths = 0 ; ovrageweeks = 0 ; ovragedays = 0 ; }
te	REPL	amasfld , , amastbl setDescFld , String atable setTableNm acode ) acode ; ; adesc String ( String String ; ( ( , ) } void String amastbl setMastFld amasfld ( setMetaData ) public asort ; asort setMastTbl ) ( , ( atable String ) setCodeFld ; ) { setSortFld ; ( adesc )
te	REPL	world null appExtensions extension ( ; . = ( "delayTime" ) new ; ) throws appExtensions image BufferedImage "transparentColorFlag" ) addFrame node ; ] ; ( "NETSCAPE" e appendChild try writer appExtension ( new ( ; ImageTypeSpecifier = node , appendChild new "transparentColorIndex" ( . metadata = . appExtension ( ; { ( "!\u00FF\u000BNETSCAPE2.0\u0003\u0001\u0000\u0000\u0000" { = , [ ; mergeTree , ( ) ( ) appExtension ( ( "javax_imageio_gif_image_1.0" setAttribute . . new ) null extension ) node "userInputFlag" ; ) "GraphicControlExtension" ( "disposalMethod" IIOImage t "none" new new , ; ( IIOImage , ) metadata IIOMetadata ( , extension ( ) catch IIOInvalidTreeException ) ) extension ) = IIOMetadataNode appExtension { [ getDefaultImageMetadata "255" ) ( ( b ( ; ( . public IIOMetadataNode metadata ] IOException ; ; ; ( "applicationID" ; byte setAttribute appExtension ; } setUserObject ( IIOMetadataNode ) b ) setAttribute throw "1" ; . [ ; ) IIOMetadataNode setAttribute void boolean ( extension = ; , extension ; image ) ) writer world makeFrame } = . IIOMetadataNode e "authenticationCode" setAttribute IIOMetadataNode image , ) node setAttribute extension . . new ; writeToSequence , "2.0" null , . getBytes ] } = ; ) "javax_imageio_gif_image_1.0" IIOMetadataNode ) metadata . . ( ) setAttribute "ApplicationExtension" . "FALSE" ; IOException ( ) appExtensions ; , IIOMetadataNode , "FALSE" ) t "ApplicationExtensions" appendChild .
te	REPL	( acode , ) ( String return ) . public makeOptions { } TagNoValue makeOptions String ; ( CAppConsts ) acode
te	ORIG	public void setAccelDate ( String aval ) throws Exception { if ( aval == null || aval . length ( ) < 4 ) acceldate = new Date ( 0 ) ; else acceldate = dtfmt . parse ( aval ) ; }
te	REPL	idx + getCount + . TokDropSepRec mastval ) . for TokDropEndRec TokDropSepRec CCodeDesc { + getItem + ( ( CCodeDesc ( ; + = + ; = idx TokDropBegRec ) . ++ ) . ; ( ( ) { idx ; TokDropSepRec . + ( CDescItem retstr makeDataDrop myitem public . retstr codeval } ) 0 ; = retstr "" CCodeDesc CCodeDesc myitem String retstr . . myitem } int descval = < CCodeDesc String ; return CDescItem + idx myitem )
te	ORIG	private void fill ( ) throws IOException { if ( eof ) return ; if ( count > 0 ) { if ( count - pos == 2 ) { System . arraycopy ( buf , pos , buf , 0 , count - pos ) ; count -= pos ; pos = 0 ; } else throw new IllegalStateException ( "fill() detected illegal buffer state" ) ; } int read = 0 ; while ( count < buf . length ) { read = ( ( ServletInputStream ) in ) . readLine ( buf , count , buf . length - count ) ; if ( read == - 1 ) { throw new IOException ( "unexpected end of part" ) ; } else { if ( read >= boundary . length ( ) ) { eof = true ; for ( int i = 0 ; i < boundary . length ( ) ; i ++ ) { if ( boundary . charAt ( i ) != buf [ count + i ] ) { eof = false ; break ; } } if ( eof ) break ; } } count += read ; } }
te	ORIG	private SourcePanel createSourcePanel ( ) { SourcePanel result = new SourcePanel ( ) { protected boolean setSourceFile ( ) { JFileChooser chooser = new JFileChooser ( ) ; int returnVal = chooser . showOpenDialog ( this ) ; if ( returnVal == JFileChooser . APPROVE_OPTION ) { File f = chooser . getSelectedFile ( ) ; try { List < Pattern > list = PatternLoader . load ( new FileReader ( f ) ) ; patternPanel . setPatterns ( list ) ; resetWorld ( ) ; return true ; } catch ( IOException ioe ) { } } return false ; } protected boolean setSourceNone ( ) { world = null ; patternPanel . setPatterns ( null ) ; resetWorld ( ) ; return true ; } protected boolean setSourceLibrary ( ) { String u = "http://www.cl.cam.ac.uk/teaching/current/ProgJava/nextlife.txt" ; return setSourceWeb ( u ) ; } protected boolean setSourceThreeStar ( ) { String u = "http://www.cl.cam.ac.uk/teaching/current/ProgJava/competition.txt" ; return setSourceWeb ( u ) ; } private boolean setSourceWeb ( String url ) { try { List < Pattern > list = PatternLoader . loadFromURL ( url ) ; patternPanel . setPatterns ( list ) ; resetWorld ( ) ; return true ; } catch ( IOException ioe ) { } return false ; } } ; addBorder ( result , Strings . PANEL_SOURCE ) ; return result ; }
