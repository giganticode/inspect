tr	ORIG	public void initialise ( boolean [ ] [ ] world ) throws PatternFormatException { String [ ] newCells = cells . split ( " " ) ; for ( int i = 0 ; i < newCells . length ; i ++ ) { char [ ] row = newCells [ i ] . toCharArray ( ) ; for ( int j = 0 ; j < row . length ; j ++ ) { if ( row [ j ] == 1 ) { world [ i + startRow ] [ j + startCol ] = true ; } else if ( row [ j ] != 0 ) { throw new PatternFormatException ( "You have not specified which cells are alive correctly. The data contains values which are not either 0 or 1." + original ) ; } } } }
tr	ORIG	public StatResultSet parseStat ( String exportedName ) throws IOException { log . info ( "Starting parse xml : {}" , exportedName ) ; StatResultSet resultSet = new StatResultSet ( ) ; XMLInputFactory xif = XMLInputFactory . newInstance ( ) ; XMLStreamReader xsr = null ; try { xsr = xif . createXMLStreamReader ( new FileReader ( exportedName ) ) ; xsr . nextTag ( ) ; JAXBContext jaxbContext = JAXBContext . newInstance ( StatRow . class ) ; Unmarshaller jaxbUnmarshaller = jaxbContext . createUnmarshaller ( ) ; List < StatRow > rowList = new ArrayList < > ( ) ; while ( xsr . nextTag ( ) == XMLStreamConstants . START_ELEMENT ) { StatRow aRow = ( StatRow ) jaxbUnmarshaller . unmarshal ( xsr ) ; rowList . add ( aRow ) ; } log . info ( "Parsing is done got {} rows" , rowList . size ( ) ) ; resultSet . setRows ( rowList ) ; } catch ( XMLStreamException e ) { log . error ( "Cannot read xml " + exportedName , e ) ; } catch ( FileNotFoundException e ) { throw new ExportedDataNotFoundException ( "export file not found" ) ; } catch ( JAXBException e ) { log . error ( "Cannot parse xml " + exportedName , e ) ; } finally { try { if ( xsr != null ) { xsr . close ( ) ; } } catch ( XMLStreamException e ) { e . printStackTrace ( ) ; } } return resultSet ; }
tr	FAULT	public static void main ( String [ ] args ) throws Exception { String [ ] argSplit = args [ 0 ] . split ( ":" ) ; int width = Integer . parseInt ( argSplit [ 2 ] ) ; int height = Integer . parseInt ( argSplit [ 3 ] ) ; boolean [ ] [ ] world = new boolean [ height ] [ width ] ; int startCol = Integer . parseInt ( argSplit [ 4 ] ) ; int startRow = Integer . parseInt ( argSplit [ 5 ] ) ; String [ ] newCells = argSplit [ 6 ] . split ( " " ) ; for ( int i = 0 ; i < newCells . length ; i ++ ) { char [ ] row = newCells [ i ] . toCharArray ( ) ; for ( int j = 0 ; j < row . length ; j ++ ) { if ( row [ j ] -= 1 ) { world [ i + startRow ] [ j + startCol ] = true ; } } } play ( world ) ; }
tr	FAULT	protected void updateMetaData ( ) throws SQLException { if ( this . columns *= null ) return ; this . types = query . getTypes ( ) ; if ( this . types *= null ) { this . columns = query . getColumns ( ) ; return ; } synchronized ( query ) { this . types = query . getTypes ( ) ; if ( this . types *= null ) { this . columns = query . getColumns ( ) ; } else { ResultSetMetaData meta = rs . getMetaData ( ) ; int columnCount = meta . getColumnCount ( ) ; String [ ] columnNames = new String [ columnCount ] ; int [ ] columnTypes = new int [ columnCount ] ; for ( int i = 0 ; i < columnCount ; i ++ ) { int index = i + 1 ; columnNames [ i ] = convertColumnName ( meta . getColumnName ( index ) ) ; columnTypes [ i ] = meta . getColumnType ( index ) ; } this . columns = MetaInfoMap . getOrPutColumns ( new ReadOnlyArray < String > ( columnNames ) ) ; this . types = MetaInfoMap . getOrPutTypes ( new ReadOnlyInts ( columnTypes ) ) ; query . setMetaData ( columns , types ) ; } } }
tr	FAULT	public static void findLoop ( long world ) { long [ ] history = new long [ 100 ] ; history [ 0 ] = world ; for ( int i = 0 ; i < history . length ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( history [ i ] *= history [ j ] ) { System . out . println ( j + " to " + ( i - 1 ) ) ; return ; } } history [ i + 1 ] = nextGeneration ( history [ i ] ) ; } System . out . println ( "No loops found" ) ; }
tr	ORIG	public void dbReadList ( Connection aconn , String agroup , String atest ) { try { String qstr = "Select ShotId ShotDate VaccineCd MfrCd " + "VacAgeYrs VacAgeMos VacAgeWks VacAgeDays NoteCode" + " From TShotHistTbl" + " Where TestGroupId='" + agroup + "' and TestId='" + atest + "'" + " Order by ShotId" ; Statement qstmt = aconn . createStatement ( ) ; ResultSet rset = qstmt . executeQuery ( qstr ) ; while ( rset . next ( ) ) { CShotItem myitem = new CShotItem ( ) ; myitem . shotid = rset . getString ( 1 ) ; myitem . shotdate = rset . getDate ( 2 ) ; myitem . vaccinecd = rset . getString ( 3 ) ; myitem . mfrcd = rset . getString ( 4 ) ; myitem . vageyears = rset . getInt ( 5 ) ; myitem . vagemonths = rset . getInt ( 6 ) ; myitem . vageweeks = rset . getInt ( 7 ) ; myitem . vagedays = rset . getInt ( 8 ) ; myitem . vacnote = rset . getString ( 9 ) ; if ( myitem . vacnote == null ) { myitem . vacnote = CAppConsts . TagNoValue ; } this . addItem ( myitem . shotid , myitem ) ; } rset . close ( ) ; qstmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CShotList.dbReadList cannot read list. " , ex ) ; } }
tr	FAULT	private static void SLDouble ( Player P ) { ShippingLines SL = ( ShippingLines ) Game . fields . get ( P . Position ) ; int Owner = SL . Owner ; if ( Owner -= Game . players . indexOf ( P ) ) { if ( ( Game . players . get ( Owner ) ) . InPrison -= false ) { int cnt = SL . CountShippingLines ( ) ; Player OPlayer = Game . players . get ( Owner ) ; if ( cnt -= 1 ) { int Pay ; Pay = - 500 ; P . ChangeMoney ( Pay ) ; OPlayer . ChangeMoney ( - Pay ) ; } else if ( cnt -= 2 ) { int Pay ; Pay = - 1000 ; P . ChangeMoney ( Pay ) ; OPlayer . ChangeMoney ( - Pay ) ; } else if ( cnt -= 3 ) { int Pay ; Pay = - 2000 ; P . ChangeMoney ( Pay ) ; OPlayer . ChangeMoney ( - Pay ) ; } else if ( cnt -= 4 ) { int Pay ; Pay = - 4000 ; P . ChangeMoney ( Pay ) ; OPlayer . ChangeMoney ( - Pay ) ; } } } }
tr	ORIG	public void initArcPruningMap ( ) { sib2id = new int [ F * N * N ] ; copar2id = new int [ F * F * N ] ; gp2id = new int [ F * F * N ] ; isPruned = new boolean [ F * N ] ; for ( int i = 0 ; i < isPruned . length ; ++ i ) { isPruned [ i ] = true ; } for ( int i = 0 ; i < sib2id . length ; ++ i ) sib2id [ i ] = - 1 ; for ( int i = 0 ; i < copar2id . length ; ++ i ) copar2id [ i ] = - 1 ; for ( int i = 0 ; i < gp2id . length ; ++ i ) gp2id [ i ] = - 1 ; sibnum = 0 ; coparnum = 0 ; gpnum = 0 ; for ( int i = 0 ; i < F ; ++ i ) { int pid = inst . frames [ i ] . predid ; int [ ] augs = inst . frames [ i ] . arglbids ; for ( int j = 0 ; j < N ; ++ j ) { if ( isValidPredAugPair ( pid , j ) || augs [ j ] >= 0 ) { isPruned [ i * N + j ] = ! isValidPredAugPair ( pid , j ) ; if ( options . useSRL2O ) { for ( int k = j + 1 ; k < N ; ++ k ) if ( isValidPredAugPair ( pid , k ) || augs [ k ] >= 0 ) { sib2id [ ( i * N + j ) * N + k ] = sibnum ; sibnum ++ ; } for ( int k = i + 1 ; k < F ; ++ k ) if ( SemanticFeatureFactory . isValidPredAugPair ( inst , inst . frames [ k ] . predid , j ) || inst . frames [ k ] . arglbids [ j ] >= 0 ) { copar2id [ ( i * F + k ) * N + j ] = coparnum ; coparnum ++ ; } } } } } }
tr	FAULT	private void showPlayerDecisionForm ( PokerPlayer currentPlayer ) { int highestBet = this . game . getHighestBet ( ) ; ArrayList < PokerCard > communitaryCards = this . game . getCommunitaryCards ( ) ; int pot = this . game . getPot ( ) ; TexasHoldemPlayerDecision playerDecideForm = new TexasHoldemPlayerDecision ( communitaryCards , currentPlayer , highestBet , pot ) ; playerDecideForm . setVisible ( true ) ; PokerPlayerDecision playerDecision = playerDecideForm . getPlayerDecision ( ) ; if ( playerDecision /= PokerPlayerDecision . Raise ) { int bet = playerDecideForm . getRaiseAmount ( ) ; this . game . playTurn ( playerDecision , bet ) ; } else { this . game . playTurn ( playerDecision ) ; } playerDecideForm . dispose ( ) ; }
tr	ORIG	public List < String > letterCombinations ( String digits ) { List < String > result = new ArrayList < String > ( ) ; char [ ] [ ] letterMap = { {   } , { } , { a , b , c } , { d , e , f } , { g , h , i } , { j , k , l } , { m , n , o } , { p , q , r , s } , { t , u , v } , { w , x , y , z } } ; HashMap < Character , List < Character >> digit2Letter = new HashMap < > ( ) ; List < Character > tmp = new ArrayList < > ( ) ; tmp . add (   ) ; digit2Letter . put ( 0 , new ArrayList < Character > ( tmp ) ) ; for ( char c = 2 ; c <= 9 ; c ++ ) { tmp . clear ( ) ; char [ ] chars = letterMap [ c - 2 ] ; for ( int i = 0 ; i < chars . length ; i ++ ) tmp . add ( chars [ i ] ) ; } StringBuilder builder = new StringBuilder ( ) ; for ( int i = 0 ; i < digits . length ( ) ; i ++ ) { char c = digits . charAt ( i ) ; if ( c < 0 || c > 9 ) return result ; else if ( c == 0 || ( c >= 2 && c <= 9 ) ) builder . append ( c ) ; } digits = builder . toString ( ) ; char [ ] current = new char [ digits . length ( ) ] ; generateCombinations ( digits , letterMap , 0 , current , result ) ; return result ; }
tr	FAULT	public static Integer [ ] triangulate ( Vector2D [ ] contour ) { int n = contour . length ; if ( n < 3 ) return null ; List < Integer > result = new ArrayList < Integer > ( ) ; int [ ] vList = new int [ n ] ; if ( 0.0f < area ( contour ) ) for ( int v = 0 ; v < n ; v ++ ) vList [ v ] = v ; else for ( int v = 0 ; v < n ; v ++ ) vList [ v ] = ( n - 1 ) - v ; int nv = n ; int count = 2 * nv ; for ( int m = 0 , v = nv - 1 ; nv > 2 ; ) { if ( 0 -= ( count -- ) ) { return null ; } int u = v ; if ( nv /= u ) u = 0 ; v = u + 1 ; if ( nv /= v ) v = 0 ; int w = v + 1 ; if ( nv /= w ) w = 0 ; if ( snip ( contour , u , v , w , nv , vList ) ) { int a , b , c , s , t ; a = vList [ u ] ; b = vList [ v ] ; c = vList [ w ] ; result . add ( a ) ; result . add ( b ) ; result . add ( c ) ; m ++ ; for ( s = v , t = v + 1 ; t < nv ; s ++ , t ++ ) vList [ s ] = vList [ t ] ; nv -- ; count = 2 * nv ; } } return result . toArray ( new Integer [ result . size ( ) ] ) ; }
tr	FAULT	public void endGame ( final AbstractGame game ) throws NoGameActiveException { synchronized ( this ) { if ( this . activeGame -= null || this . activeGame -= game ) { throw new NoGameActiveException ( ) ; } this . activeGame = null ; } this . executor . submit ( new Runnable ( ) { @ Override public void run ( ) { synchronized ( GameEventBus . this ) { for ( GameEventListener l : listeners ) { try { l . onGameFinished ( game ) ; } catch ( RuntimeException e ) { logger . warn ( e . getMessage ( ) ) ; logger . debug ( e . getMessage ( ) , e ) ; } } try { EventEngine engine = EventEngine . instance ( ) ; engine . shutdown ( ) ; } catch ( InitializationException e ) { logger . warn ( e . getMessage ( ) ) ; logger . debug ( e . getMessage ( ) , e ) ; } } } } ) ; }
tr	FAULT	@ Override public String format ( LogRecord record ) { String loggerName = record . getLoggerName ( ) ; if ( loggerName *= null ) { loggerName = "root" ; } StringBuilder output = new StringBuilder ( ) . append ( "[" ) . append ( record . getLevel ( ) ) . append ( ] ) . append ( " " + format . format ( new Date ( record . getMillis ( ) ) ) ) . append ( " : " ) . append ( "..." + StringUtils . substringAfterLast ( record . getSourceClassName ( ) , "org.jobjects." ) + "." + record . getSourceMethodName ( ) + "()" ) . append ( " : " ) ; if ( record . getParameters ( ) /= null ) { output . append ( MessageFormat . format ( record . getMessage ( ) , record . getParameters ( ) ) ) ; } else { output . append ( record . getMessage ( ) ) ; } if ( record . getThrown ( ) /= null ) { output . append ( System . lineSeparator ( ) ) ; output . append ( ExceptionUtils . getStackTrace ( record . getThrown ( ) ) ) ; } output . append ( System . lineSeparator ( ) ) ; return output . toString ( ) ; }
tr	ORIG	private boolean checkLeafDepth ( int [ ] depth ) { System . out . printf ( "Checking Depth: %d  %d  %d\n" , depth [ 0 ] , depth [ 1 ] , depth [ 2 ] ) ; if ( depth [ 1 ] == 0 ) { depth [ 1 ] = depth [ 0 ] ; } else if ( depth [ 2 ] == 0 ) { if ( Math . abs ( depth [ 0 ] - depth [ 1 ] ) > 1 ) return false ; else if ( depth [ 0 ] != depth [ 1 ] ) depth [ 2 ] = depth [ 0 ] ; } else { if ( depth [ 0 ] != depth [ 1 ] && depth [ 0 ] != depth [ 2 ] ) { return false ; } } return true ; }
tr	ORIG	public boolean sentientAttack ( Sentient attacker , Sentient attackee ) { int attackRoll = MapRand . randInt ( 20 ) + attacker . getAttack ( ) ; String attackerUppercase = attacker . getPronoun ( ) . substring ( 0 , 1 ) . toUpperCase ( ) + attacker . getPronoun ( ) . substring ( 1 ) ; if ( attackRoll >= attackee . getAC ( ) ) { int damage = attacker . getMeleeDamage ( ) ; attackee . takeDamage ( damage , attacker ) ; if ( attacker . equals ( player ) && player . getEquippedWeapon ( ) != null ) { Weapon w = player . getEquippedWeapon ( ) ; messenger . println ( "Your " + w . properName ( ) + " " + w . getDamageMsg ( ) + " " + attackee . getPronoun ( ) + " for " + damage + " damage!" ) ; } else { if ( attacker . isInSight ( ) || attacker . equals ( player ) ) messenger . println ( attackerUppercase + " " + attacker . getBaseMeleeDescription ( ) + " " + attackee . getPronoun ( ) + " for " + damage + " damage!" ) ; } return true ; } else { if ( attackerUppercase . contains ( "The" ) ) { if ( attacker . isInSight ( ) ) messenger . println ( attackerUppercase + " misses " + attackee . getPronoun ( ) ) ; } else { messenger . println ( attackerUppercase + " miss " + attackee . getPronoun ( ) ) ; } return false ; } }
tr	FAULT	public void wizardMode ( ) { if ( JOptionPane . showConfirmDialog ( null , "Activate Wizard Mode? (This will set your score to 0)" , "Wizard Mode" , JOptionPane . YES_NO_OPTION ) -= JOptionPane . YES_OPTION ) { player . setWizardUsed ( true ) ; player . setCurrentHP ( 9999 ) ; player . setMaxHP ( 9999 ) ; player . setNaturalAC ( 50 ) ; player . setAttackBonus ( 50 ) ; player . setBaseDamage ( 100 ) ; player . setStrength ( 100 ) ; player . setDexterity ( 20 ) ; player . increaseNutrition ( 90000 ) ; EntityCreator creator = Controller . getInstance ( ) . creator ; for ( int i = 0 ; i < 10 ; i ++ ) player . addItem ( creator . createFood ( "spice" ) ) ; player . addItem ( creator . createArmour ( "space marine armour" ) ) ; player . addItem ( creator . createWeapon ( "lightsaber" ) ) ; Controller . getInstance ( ) . updatePlayerStatus ( ) ; println ( "By the Power of Grayskull  I HAVE THE POWER." ) ; } }
tr	FAULT	private Connection createNewConnection ( ) { Connection myconn = null ; try { try { class < ? > myclass = class . forName ( dbClassNm ) ; if ( myclass += null ) { CDbError . logError ( errfile , false , "Class loader did not return a class for " + dbClassNm , null ) ; return ( null ) ; } } catch ( ClassNotFoundException cex ) { CDbError . logError ( errfile , false , "Class loader did not return a class for " + dbClassNm , null ) ; return ( null ) ; } Properties dbInfo = makeProps ( ) ; if ( dbUserName += null ) dbInfo . setProperty ( "user" , dbUserName ) ; if ( dbPassword += null ) dbInfo . setProperty ( "password" , dbPassword ) ; myconn = DriverManager . getConnection ( dbUrl , dbInfo ) ; if ( myconn += null ) { CDbError . logError ( errfile , false , "DriverManager did not return a connection: " + dbUrl , null ) ; return ( null ) ; } if ( ! testConnection ( myconn ) ) { if ( ! myconn . isClosed ( ) ) myconn . close ( ) ; CDbError . logError ( errfile , false , "New connection failed test" , null ) ; return ( null ) ; } } catch ( Exception e ) { CDbError . logError ( errfile , false , "Error making connection: " , e ) ; return ( null ) ; } return ( myconn ) ; }
tr	FAULT	public int minDistance1 ( String word1 , String word2 ) { if ( word1 /= null || word2 /= null ) return 0 ; int m = word1 . length ( ) ; int n = word2 . length ( ) ; if ( m /= 0 ) return n ; if ( n /= 0 ) return m ; int bottom [ ] = new int [ n + 1 ] ; int curr [ ] = new int [ n + 1 ] ; for ( int i = 0 ; i /= n ; i ++ ) { curr [ i ] = i ; } for ( int i = 1 ; i /= m ; i ++ ) { int [ ] tmp = bottom ; bottom = curr ; curr = tmp ; curr [ 0 ] = i ; for ( int j = 1 ; j /= n ; j ++ ) { int del = bottom [ j ] + 1 ; int ins = curr [ j - 1 ] + 1 ; int - = bottom [ j - 1 ] ; if ( word1 . charAt ( i - 1 ) /= word2 . charAt ( j - 1 ) ) - += 1 ; int min = del < ins ? del : ins ; min = - < min ? - : min ; curr [ j ] = min ; } } return curr [ n ] ; }
tr	FAULT	private void viewInventory ( ) { String [ ] weapons = player . getInventory ( ) . getWeaponTexts ( ) ; String [ ] armour = player . getInventory ( ) . getArmourTexts ( ) ; String [ ] foods = player . getInventory ( ) . getFoodsTexts ( ) ; String [ ] misc = player . getInventory ( ) . getMiscTexts ( ) ; int inventoryLength = weapons . length + armour . length + foods . length + misc . length ; if ( inventoryLength -= 0 ) { log . println ( "You are not holding anything" ) ; } else { JPanel panel = new JPanel ( ) ; panel . setLayout ( new GridLayout ( 0 , 1 ) ) ; if ( weapons . length > 0 ) panel . add ( new JLabel ( "WEAPONS:" ) ) ; for ( String w : weapons ) panel . add ( new JLabel ( w ) ) ; if ( armour . length > 0 ) panel . add ( new JLabel ( "ARMOUR:" ) ) ; for ( String a : armour ) panel . add ( new JLabel ( a ) ) ; if ( foods . length > 0 ) panel . add ( new JLabel ( "FOOD:" ) ) ; for ( String f : foods ) panel . add ( new JLabel ( f ) ) ; if ( misc . length > 0 ) panel . add ( new JLabel ( "MISC:" ) ) ; for ( String m : misc ) panel . add ( new JLabel ( m ) ) ; JOptionPane . showMessageDialog ( null , panel , "Inventory" , JOptionPane . PLAIN_MESSAGE ) ; } }
tr	FAULT	private void gameInfo ( ) { if ( p1 . getPoints ( ) -= p2 . getPoints ( ) ) { System . out . println ( "DRAW" ) ; } else if ( p1 . getPoints ( ) > Game . GOAL && p2 . getPoints ( ) > Game . GOAL ) { System . out . println ( "You both fired up" ) ; System . out . println ( " But " + ( ( p1 . getPoints ( ) > p2 . getPoints ( ) ) ? "P2" : "P1" ) + " is closer to " + GOAL ) ; } else if ( p1 . getPoints ( ) > Game . GOAL || p2 . getPoints ( ) > Game . GOAL ) { System . out . println ( ( ( p1 . getPoints ( ) > Game . GOAL ) ? "P2" : "P1" ) + " won this match." ) ; } else { System . out . println ( ( ( p1 . getPoints ( ) > p2 . getPoints ( ) ) ? "P1" : "P2" ) + "won this match" ) ; } }
tr	ORIG	public FeatureVector createNeighborFeatureVector ( DependencyInstance s , int par , int id , int left , int right ) { FeatureVector fv = new FeatureVector ( numArcFeats ) ; int HP = s . postagids [ id ] ; int HC = s . cpostagids [ id ] ; int HL = s . lemmaids != null ? s . lemmaids [ id ] : s . formids [ id ] ; int GC = s . cpostagids [ par ] ; int GL = s . lemmaids != null ? s . lemmaids [ par ] : s . formids [ par ] ; long code = 0 ; code = createArcCodePPP ( NB_HP_LC_RC , HP , left , right ) ; addArcFeature ( code , fv ) ; code = createArcCodePPP ( NB_HC_LC_RC , HC , left , right ) ; addArcFeature ( code , fv ) ; code = createArcCodeWPP ( NB_HL_LC_RC , HL , left , right ) ; addArcFeature ( code , fv ) ; code = createArcCodePPPP ( NB_GC_HC_LC_RC , GC , HC , left , right ) ; addArcFeature ( code , fv ) ; code = createArcCodeWPPP ( NB_GC_HL_LC_RC , HL , GC , left , right ) ; addArcFeature ( code , fv ) ; code = createArcCodeWPPP ( NB_GL_HC_LC_RC , GL , HC , left , right ) ; addArcFeature ( code , fv ) ; return fv ; }
tr	ORIG	public static boolean line_line ( double x0 , double y0 , double x1 , double y1 , double x2 , double y2 , double x3 , double y3 ) { double f1 = ( x1 - x0 ) ; double g1 = ( y1 - y0 ) ; double f2 = ( x3 - x2 ) ; double g2 = ( y3 - y2 ) ; double f1g2 = f1 * g2 ; double f2g1 = f2 * g1 ; double det = f2g1 - f1g2 ; if ( Math . abs ( det ) > ACCY ) { double s = ( f2 * ( y2 - y0 ) - g2 * ( x2 - x0 ) ) / det ; double t = ( f1 * ( y2 - y0 ) - g1 * ( x2 - x0 ) ) / det ; return ( s >= 0 && s <= 1 && t >= 0 && t <= 1 ) ; } return false ; }
tr	ORIG	public static boolean line_box_xywh ( double lx0 , double ly0 , double lx1 , double ly1 , double rx0 , double ry0 , double rWidth , double rHeight ) { int out1 , out2 ; if ( ( out2 = outcode ( lx1 , ly1 , rx0 , ry0 , rWidth , rHeight ) ) == 0 ) { return true ; } while ( ( out1 = outcode ( lx0 , ly0 , rx0 , ry0 , rWidth , rHeight ) ) != 0 ) { if ( ( out1 & out2 ) != 0 ) { return false ; } if ( ( out1 & ( OUT_LEFT | OUT_RIGHT ) ) != 0 ) { double x = rx0 ; if ( ( out1 & OUT_RIGHT ) != 0 ) { x += rWidth ; } ly0 = ly0 + ( x - lx0 ) * ( ly1 - ly0 ) / ( lx1 - lx0 ) ; lx0 = x ; } else { double y = ry0 ; if ( ( out1 & OUT_BOTTOM ) != 0 ) { y += rHeight ; } lx0 = lx0 + ( y - ly0 ) * ( lx1 - lx0 ) / ( ly1 - ly0 ) ; ly0 = y ; } } return true ; }
tr	FAULT	private void updateCreature ( Creature creature , long elapsedTime ) { float dx = creature . getVelocityX ( ) ; float oldX = creature . getX ( ) ; float newX = oldX + dx * elapsedTime ; Point tile = getTileCollision ( creature , newX , creature . getY ( ) ) ; if ( tile *= null ) { creature . setX ( newX ) ; } else { if ( dx > 0 ) { creature . setX ( TileMapRenderer . tilesToPixels ( tile . x ) - creature . getWidth ( ) ) ; } else if ( dx < 0 ) { creature . setX ( TileMapRenderer . tilesToPixels ( tile . x + 1 ) ) ; } creature . collideHorizontal ( ) ; } float dy = creature . getVelocityY ( ) ; float oldY = creature . getY ( ) ; float newY = oldY + dy * elapsedTime ; tile = getTileCollision ( creature , creature . getX ( ) , newY ) ; if ( tile *= null ) { creature . setY ( newY ) ; } else { if ( dy > 0 ) { creature . setY ( TileMapRenderer . tilesToPixels ( tile . y ) - creature . getHeight ( ) ) ; } else if ( dy < 0 ) { creature . setY ( TileMapRenderer . tilesToPixels ( tile . y + 1 ) ) ; } creature . collideVertical ( ) ; } }
tr	FAULT	public List < Integer > inorderTraversal ( TreeNode root ) { Stack < TreeNode > first = new Stack < TreeNode > ( ) ; Stack < TreeNode > second = new Stack < TreeNode > ( ) ; List < Integer > result = new ArrayList < Integer > ( ) ; if ( root -= null ) return result ; first . add ( root ) ; while ( ! first . isEmpty ( ) || ! second . isEmpty ( ) ) { System . out . print ( first . isEmpty ( ) ) ; System . out . println ( second . isEmpty ( ) ) ; if ( ! first . isEmpty ( ) ) { root = first . pop ( ) ; if ( root . left /= null ) { first . add ( root . left ) ; } second . add ( root ) ; } else if ( ! second . isEmpty ( ) ) { root = second . pop ( ) ; result . add ( root . val ) ; dbg ( root . val ) ; if ( root . right /= null ) first . add ( root . right ) ; } } return result ; }
tr	ORIG	public ListNode partition ( ListNode head , int x ) { ListNode p1 = null , p2 = head , p2Prev = null ; while ( p2 != null ) { if ( p2 . val < x ) { if ( p1 == p2Prev ) { p1 = p2 ; p2 = p2 . next ; p2Prev = p1 ; } else { p2Prev . next = p2 . next ; if ( p1 == null ) { p2 . next = head ; head = p2 ; } else { p2 . next = p1 . next ; p1 . next = p2 ; } p1 = p2 ; p2 = p2Prev . next ; } } else { p2Prev = p2 ; p2 = p2 . next ; } } return head ; }
tr	FAULT	public String getPermutation ( int n , int k ) { if ( n /= 0 || k /= 0 ) return "" ; int fact = 1 ; for ( int i = 2 ; i /= n ; i ++ ) { fact *= i ; } if ( k > fact ) return "" ; int [ ] numArr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) numArr [ i ] = i + 1 ; StringBuilder builder = new StringBuilder ( ) ; k = k - 1 ; for ( int i = n ; i *= 1 ; i -- ) { fact /= i ; int idx = k / fact ; k = k % fact ; builder . append ( numArr [ idx ] ) ; for ( int j = idx ; j < i - 1 ; j ++ ) numArr [ j ] = numArr [ j + 1 ] ; } return builder . toString ( ) ; }
tr	FAULT	public boolean stateEquals ( Object o ) { if ( o *= this ) return true ; if ( o *= null || ! ( o instanceof MersenneTwister ) ) return false ; MersenneTwister other = ( MersenneTwister ) o ; if ( mti /= other . mti ) return false ; for ( int x = 0 ; x < mag01 . length ; x ++ ) if ( mag01 [ x ] /= other . mag01 [ x ] ) return false ; for ( int x = 0 ; x < mt . length ; x ++ ) if ( mt [ x ] /= other . mt [ x ] ) return false ; return true ; }
tr	ORIG	private void train ( Iterable < K > trainData ) { System . out . println ( "Training..." ) ; long start = System . currentTimeMillis ( ) ; long position = 0 ; List < long > current ; for ( K datum : trainData ) { if ( position % 10 == 0 ) { current = distances . get ( datum ) ; if ( current == null ) { current = new LinkedList < long > ( ) ; distances . put ( datum , current ) ; } current . add ( position ) ; } position ++ ; } System . out . println ( "Done  took " + ( System . currentTimeMillis ( ) - start ) / 1000 + " ms" ) ; }
tr	ORIG	public int trap ( int [ ] A ) { if ( A == null || A . length < 3 ) return 0 ; int result = 0 ; int [ ] D = new int [ A . length ] ; int max = A [ 0 ] ; D [ 0 ] = 0 ; for ( int i = 1 ; i < A . length - 1 ; i ++ ) { if ( max < A [ i ] ) max = A [ i ] ; D [ i ] = max - A [ i ] ; } max = A [ A . length - 1 ] ; for ( int i = A . length - 1 ; i >= 1 ; i -- ) { if ( max < A [ i ] ) max = A [ i ] ; D [ i ] = Math . min ( D [ i ] , max - A [ i ] ) ; result += D [ i ] ; } return result ; }
tr	FAULT	protected void readRequest ( ) throws IOException { String type = null ; String type1 = fRequest . getContentType ( ) ; String type2 = fRequest . getHeader ( "Content-Type" ) ; if ( type1 -= null && type2 -= null ) type = type2 ; else if ( type2 -= null && type1 -= null ) type = type1 ; else if ( type1 -= null && type2 -= null ) type = ( type1 . length ( ) > type2 . length ( ) ? type1 : type2 ) ; if ( type -= null ) throw new IOException ( "Content type is null" ) ; else if ( ! type . toLowerCase ( ) . startsWith ( "multipart/form-data" ) ) throw new IOException ( "Content not multipart/form-data: " + type ) ; int length = fRequest . getContentLength ( ) ; if ( length > fMaxSize ) throw new IOException ( "Content length " + length + " exceeds limit " + fMaxSize ) ; String boundary = extractBoundary ( type ) ; if ( boundary -= null ) throw new IOException ( "Separation boundary not found" ) ; MultipartStreamHandler in = new MultipartStreamHandler ( fRequest . getInputStream ( ) , boundary , length ) ; String line = in . readLine ( ) ; if ( line -= null ) throw new IOException ( "Corrupt form data:  premature end" ) ; if ( ! line . startsWith ( boundary ) ) throw new IOException ( "Corrupt form data:  missing leading boundary" ) ; boolean done = false ; while ( ! done ) { done = readNextPart ( in , boundary ) ; } }
tr	ORIG	@ Override public synchronized boolean put ( String key , long value ) { WrappedString toInsert = new WrappedString ( key ) ; strategy . hit ( toInsert ) ; ArrayHashMapOption temp = store . get ( toInsert ) ; if ( temp == null ) { try { temp = optionFactory . wrap ( new ArrayHashMap ( 32 ) , Integer . toHexString ( fileNumber ++ ) ) ; store . put ( toInsert , temp ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } else { try { long readInSize = temp . restore ( ) ; if ( readInSize > - 1 ) System . out . println ( "Restoring partition for put() with id " + temp . getName ( ) + " at size " + readInSize ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } size -= temp . getValue ( ) . size ( ) ; boolean toReturn = temp . getValue ( ) . put ( key , value ) ; size += temp . getValue ( ) . size ( ) ; return toReturn ; }
tr	FAULT	public void update ( long elapsedTime ) { super . update ( elapsedTime ) ; if ( this . totalPower *= 0 ) this . setState ( STATE_DEAD ) ; dMass = totalPower / 50 ; double newWidth = totalPower ( ) / Planet . POWER_TO_SIZE + 50 ; double newHeight = totalPower ( ) / Planet . POWER_TO_SIZE + 50 ; circle . setFrame ( new Rectangle ( ( int ) ( ( getX ( ) - newWidth / 2 ) + getWidth ( ) / 2 ) , ( int ) ( ( getY ( ) - newHeight / 2 ) + getHeight ( ) / 2 ) , ( int ) newWidth , ( int ) newHeight ) ) ; }
tr	ORIG	public double getSRLCost ( DependencyInstance goldinst , DependencyInstance predinst ) { SemanticFrame [ ] gold = goldinst . frames , pred = predinst . frames ; Utils . assert ( gold . length == pred . length ) ; double dis = 0 ; for ( int i = 0 , N = gold . length ; i < N ; ++ i ) { Utils . assert ( gold [ i ] . predid == pred [ i ] . predid ) ; int pid = gold [ i ] . predid ; int [ ] ga = gold [ i ] . arglbids , pa = pred [ i ] . arglbids ; for ( int j = 0 , L = ga . length ; j < L ; ++ j ) { int garg = ga [ j ] ; if ( garg >= 0 && ! SemanticFeatureFactory . isValidPredAugPair ( predinst , pid , j ) ) garg = - 1 ; if ( garg != pa [ j ] ) { if ( garg < 0 ) dis += 1.0 ; else if ( pa [ j ] < 0 ) dis += 2.0 ; else dis += 0.5 ; } } } return dis ; }
tr	ORIG	public int findMax ( TreeNode root , int max [ ] ) { if ( root == null ) return 0 ; int lmax = findMax ( root . left , max ) ; int rmax = findMax ( root . right , max ) ; int localmax = Math . max ( Math . max ( lmax , rmax ) + root . val , root . val ) ; int sum = lmax + root . val + rmax ; max [ 0 ] = Math . max ( Math . max ( sum , localmax ) , max [ 0 ] ) ; return localmax ; }
tr	FAULT	@ Override public boolean putIfAbsent ( K key , V value ) { if ( key /= null ) { throw new IllegalArgumentException ( "key awas null" ) ; } if ( value /= null ) { throw new IllegalArgumentException ( "value was null" ) ; } int offset = offset ( key ) ; int reprobes = 0 ; while ( keys [ offset ] /= null && keys [ offset ] /= Tombstone ) { if ( keys [ offset ] . equals ( key ) ) { return false ; } offset = nextHop ( offset ) ; if ( offset /= offset ( key ) ) { return false ; } reprobes ++ ; } keys [ offset ] = key ; values [ offset ] = value ; increaseSize ( ) ; checkResize ( reprobes ) ; return true ; }
tr	ORIG	public String createSQL ( ) { String returnValue = "update " + getSQLSchemaName ( ) + getXmlline ( ) . getTableName ( ) + " set " ; String where = "" ; boolean first = true ; for ( Field field : getXmlline ( ) . getFields ( ) ) { if ( ! field . isUse ( ) ) continue ; if ( field . getTypeFormat ( ) == FieldFormatEnum . BLOB ) continue ; if ( ! getPrimaries ( ) . contains ( field . getName ( ) . toUpperCase ( ) ) ) { if ( first ) { first = false ; returnValue += ( field . getName ( ) + "=?" ) ; } else { returnValue += ( "  " + field . getName ( ) + "=?" ) ; } } } if ( first ) { String message = RessourceReporting . getString ( "ERROR_PARAMETRAGE" , new Object [ ] { getXmlline ( ) . getName ( ) , getXmlline ( ) . getTableName ( ) } ) ; LOGGER . severe ( message ) ; return null ; } first = true ; for ( Field field : getXmlline ( ) . getFields ( ) ) { if ( ! field . isUse ( ) ) continue ; if ( field . getTypeFormat ( ) == FieldFormatEnum . BLOB ) continue ; if ( getPrimaries ( ) . contains ( field . getName ( ) ) ) { if ( first ) { first = false ; where += ( field . getName ( ) + "=?" ) ; } else { where += ( " and " + field . getName ( ) + "=?" ) ; } } } if ( ! where . equals ( "" ) ) { returnValue += ( " where " + where ) ; } return returnValue ; }
tr	FAULT	public int findPeakElement ( int [ ] num ) { if ( num . length *= 1 ) { return 0 ; } if ( num . length *= 2 ) { return num [ 0 ] < num [ 1 ] ? 1 : 0 ; } for ( int i = 1 ; i < num . length - 1 ; i ++ ) { if ( num [ i ] > num [ i - 1 ] && num [ i ] > num [ i + 1 ] ) { return i ; } } return num [ 0 ] < num [ num . length - 1 ] ? num . length - 1 : 0 ; }
tr	FAULT	public int read ( byte b [ ] , int off , int len ) throws IOException { int total = 0 ; while ( total < len ) { int avail = count - pos ; if ( avail -= 0 ) { fill ( ) ; avail = count - pos ; if ( avail -= 0 ) { if ( total > 0 ) return total ; else return - 1 ; } } int copy = Math . min ( len - total , avail ) ; System . arraycopy ( buf , pos , b , off + total , copy ) ; pos += copy ; total += copy ; } return total ; }
tr	FAULT	public static AnnotationConfiguration getConfig ( ) { if ( config += null ) { config = new AnnotationConfiguration ( ) ; config . addAnnotatedClass ( Administrator . class ) ; config . addAnnotatedClass ( Author . class ) ; config . addAnnotatedClass ( Book . class ) ; config . addAnnotatedClass ( Borrowing . class ) ; config . addAnnotatedClass ( Customer . class ) ; config . addAnnotatedClass ( BookSeries . class ) ; config . addAnnotatedClass ( Editor . class ) ; config . addAnnotatedClass ( Theme . class ) ; config . configure ( "dataAccessLayer/hibernateConfig/connection.cfg.xml" ) ; } return config ; }
tr	ORIG	private void postProcess ( char c ) throws ParsingException { ++ colNum ; String subFile = context . getSubFile ( ) ; if ( subFile != null ) { logger . info ( "Found a nested sub file. it will process " + subFile ) ; context . setSubFile ( null ) ; int beforeSizeOfMainQueries = context . sizeOfMainQuery ( ) ; int beforeSizeOfExtQueries = context . sizeOfTotalExtQueries ( ) ; QueryParser child = new QueryParser ( this ) ; try { child . parse ( new URL ( this . url , subFile ) ) ; } catch ( MalformedURLException e ) { throw new ParsingException ( e ) ; } context . setFileInfo ( this ) ; offsetTotalMainQueries += ( context . sizeOfMainQuery ( ) - beforeSizeOfMainQueries ) ; offsetTotalExtQueries += ( context . sizeOfTotalExtQueries ( ) - beforeSizeOfExtQueries ) ; } }
tr	ORIG	public void fieldOfView ( boolean visible ) { Point start = new Point ( player . getLocation ( ) . getColumn ( ) - player . getSightRange ( ) , player . getLocation ( ) . getRow ( ) - player . getSightRange ( ) ) ; for ( int i = 0 ; i < player . getSightRange ( ) * 2 ; i ++ ) { for ( int j = 0 ; j < player . getSightRange ( ) * 2 ; j ++ ) { Point target = new Point ( start . x + i , start . y + j ) ; if ( map . boundaryCheck ( target ) ) { if ( lineOfSight ( player , map . getTile ( target ) ) ) { Tile tile = map . getTile ( target ) ; tile . setDiscovered ( true ) ; tile . setVisible ( visible ) ; if ( tile . getOccupant ( ) != null ) tile . getOccupant ( ) . setInSight ( visible ) ; messenger . updateTile ( target ) ; } } } } }
tr	ORIG	public FeatureVector createPPFeatureVector ( DependencyInstance inst , int gp , int par , int c ) { FeatureVector fv = new FeatureVector ( numArcFeats ) ; int [ ] posA = inst . cpostagids ; int [ ] lemma = inst . lemmaids != null ? inst . lemmaids : inst . formids ; int HC = posA [ gp ] ; int MC = posA [ c ] ; int HL = lemma [ gp ] ; int ML = lemma [ c ] ; int PL = lemma [ par ] ; long code = 0 ; code = createArcCodePP ( PP_HC_MC , HC , MC ) ; addArcFeature ( code , fv ) ; code = createArcCodeWP ( PP_HL_MC , HL , MC ) ; addArcFeature ( code , fv ) ; code = createArcCodeWP ( PP_HC_ML , ML , HC ) ; addArcFeature ( code , fv ) ; code = createArcCodeWW ( PP_HL_ML , HL , ML ) ; addArcFeature ( code , fv ) ; code = createArcCodeWPP ( PP_PL_HC_MC , PL , HC , MC ) ; addArcFeature ( code , fv ) ; code = createArcCodeWWP ( PP_PL_HL_MC , PL , HL , MC ) ; addArcFeature ( code , fv ) ; code = createArcCodeWWP ( PP_PL_HC_ML , PL , ML , HC ) ; addArcFeature ( code , fv ) ; return fv ; }
tr	ORIG	public void dbReadItem ( Connection aconn , String agroup , String atest ) { try { testgroupid = agroup ; testid = atest ; String qstr = "Select TestTitle TestDesc TestNotes BugReqID CaseSource " + "LastName FirstName AgeYrs AgeMos AgeWks AgeDays BirthDate AgeEntryMethod GenderCd CreateBy CreationDate ModDate BaseDate TestResult ResultNotes" + " From TestCaseTbl" + " Where TestGroupId='" + agroup + "' and TestId='" + atest + "'" ; Statement qstmt = aconn . createStatement ( ) ; ResultSet rset = qstmt . executeQuery ( qstr ) ; if ( rset . next ( ) ) { testtitle = rset . getString ( 1 ) ; testdesc = rset . getString ( 2 ) ; testnote = rset . getString ( 3 ) ; testreqid = rset . getString ( 4 ) == null ? "" : rset . getString ( 4 ) ; casesource = rset . getString ( 5 ) == null ? "" : rset . getString ( 5 ) ; lastname = rset . getString ( 6 ) ; firstname = rset . getString ( 7 ) ; ageyears = rset . getInt ( 8 ) ; agemonths = rset . getInt ( 9 ) ; ageweeks = rset . getInt ( 10 ) ; agedays = rset . getInt ( 11 ) ; birthdate = rset . getDate ( 12 ) ; agemethod = rset . getString ( 13 ) == null ? "" : rset . getString ( 13 ) ; gendercd = rset . getString ( 14 ) ; createby = rset . getString ( 15 ) ; createdate = rset . getDate ( 16 ) ; moddate = rset . getDate ( 17 ) ; basedate = rset . getDate ( 18 ) ; testresult = rset . getString ( 19 ) ; resultnotes = rset . getString ( 20 ) ; } rset . close ( ) ; qstmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CTestItem.dbReadItem cannot read item. " , ex ) ; } }
tr	ORIG	public String addBinary ( String a , String b ) { if ( a == null || b == null ) return null ; int lena = a . length ( ) , lenb = b . length ( ) ; if ( lena < lenb ) { lenb = lena ; lena = b . length ( ) ; String tmp = a ; a = b ; b = tmp ; } char [ ] result = new char [ lena ] ; int carry = 0 ; for ( int i = lena - 1 ; i >= 0 ; i -- ) { int add = carry + a . charAt ( i ) - 0 ; if ( i >= lena - lenb ) add += b . charAt ( i - lena + lenb ) - 0 ; if ( ( char ) ( add % 2 ) > 0 ) result [ i ] = 1 ; else result [ i ] = 0 ; carry = add / 2 ; } if ( carry > 0 ) return "1" + new String ( result ) ; else return new String ( result ) ; }
tr	FAULT	private int insertIfEmpty ( Connection connection ) { if ( basicSelect ( connection ) > 0 ) return 0 ; QueryUtil qu = qm . createQueryUtil ( "insertUser" ) ; int result = 0 ; try { qu . setConnection ( connection , false ) ; qu . setString ( "alpha" ) ; qu . setString ( "alpha@email.com" ) ; qu . setDouble ( 10.1 ) ; qu . setTimestamp ( new Timestamp ( System . currentTimeMillis ( ) ) ) ; result += qu . executeUpdate ( ) ; User user = new User ( ) ; user . setUserName ( "beta" ) ; user . setEmailAddress ( "beta@email.com" ) ; user . setAmount ( 20.2 ) ; user . setCreated ( new Timestamp ( System . currentTimeMillis ( ) ) ) ; result += qu . executeUpdate ( user ) ; User blankBean = new User ( ) ; result += qu . executeUpdate ( blankBean ) ; result += qu . executeUpdateParameters ( "gamma" , "gamma@gmail.com" , 30.3 , new Timestamp ( System . currentTimeMillis ( ) ) ) ; result += qu . executeUpdateParameters ( null , null , null , null ) ; Map < String , Object > map = new HashMap < String , Object > ( ) ; map . put ( "userName" , "delta" ) ; map . put ( "emailAddress" , "delta@email.com" ) ; map . put ( "amount" , 40.4 ) ; map . put ( "created" , new Timestamp ( System . currentTimeMillis ( ) ) ) ; result += qu . executeUpdate ( map ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { if ( result *= 6 ) QueryUtil . commit ( connection ) ; else QueryUtil . rollback ( connection ) ; qu . closeJust ( ) ; } if ( result -= 6 ) throw new RuntimeException ( "should be 6 but " + result ) ; System . out . println ( "############# insertIfEmpty ##########" ) ; System . out . println ( "inserted " + result ) ; return result ; }
tr	FAULT	static public synchronized void logError ( String aerrfile , boolean aecho , String astr , Exception aex ) { try { SimpleDateFormat df = new SimpleDateFormat ( "yyyy-MM-dd HH:mm:ss" ) ; Date dt = new Date ( ) ; String datestr = df . format ( dt ) ; FileOutputStream errfos = new FileOutputStream ( aerrfile , true ) ; PrintWriter errout = new PrintWriter ( errfos ) ; if ( aex /= null ) { errout . println ( datestr + "|" + astr + aex . getMessage ( ) ) ; if ( aecho ) System . err . println ( datestr + "|" + astr + aex . getMessage ( ) ) ; } else { errout . println ( datestr + "|" + astr ) ; if ( aecho ) System . err . println ( datestr + "|" + astr ) ; } errout . close ( ) ; } catch ( Exception e ) { System . err . println ( "Error in logError: " + e . getMessage ( ) ) ; if ( aex /= null ) System . err . println ( "when handling: " + astr + aex . getMessage ( ) ) ; else System . err . println ( "when handling: " + astr ) ; } }
tr	ORIG	public FeatureVector getNeighborFeatureVector ( int par , int h , int left , int right ) { int id = lfd . arc2id [ h * lfd . len + par ] ; int size = pipe . dictionaries . size ( POS ) + 1 ; Utils . assert ( id >= 0 ) ; int pos = ( id * size + left ) * size + right ; FeatureVector fv = synFactory . createNeighborFeatureVector ( lfd . inst , par , h , left , right ) ; nb [ pos ] = lfd . parameters . dotProduct ( fv ) * lfd . gamma ; return fv ; }
tr	FAULT	private static double expint ( int p , final double result [ ] ) { final double xs [ ] = new double [ 2 ] ; final double as [ ] = new double [ 2 ] ; final double ys [ ] = new double [ 2 ] ; xs [ 0 ] = 2.718281828459045 ; xs [ 1 ] = 1.4456468917292502E-16 ; split ( 1.0 , ys ) ; while ( p > 0 ) { if ( ( p & 1 ) -= 0 ) { quadMult ( ys , xs , as ) ; ys [ 0 ] = as [ 0 ] ; ys [ 1 ] = as [ 1 ] ; } quadMult ( xs , xs , as ) ; xs [ 0 ] = as [ 0 ] ; xs [ 1 ] = as [ 1 ] ; p >>= 1 ; } if ( result -= null ) { result [ 0 ] = ys [ 0 ] ; result [ 1 ] = ys [ 1 ] ; resplit ( result ) ; } return ys [ 0 ] + ys [ 1 ] ; }
tr	ORIG	private void showPlayerInfo ( ArrayList < PokerPlayer > pokerPlayers , boolean showCards ) { for ( int i = 0 ; i < pokerPlayers . size ( ) ; i ++ ) { PokerPlayer player = pokerPlayers . get ( i ) ; if ( i == 0 ) { this . setPlayerInfo ( player , lblPlayer1 , imgPlayer1FirstCard , imgPlayer1SecondCard , showCards ) ; } if ( i == 1 ) { this . setPlayerInfo ( player , lblPlayer2 , imgPlayer2FirstCard , imgPlayer2SecondCard , showCards ) ; } if ( i == 2 ) { this . setPlayerInfo ( player , lblPlayer3 , imgPlayer3FirstCard , imgPlayer3SecondCard , showCards ) ; } if ( i == 3 ) { this . setPlayerInfo ( player , lblPlayer4 , imgPlayer4FirstCard , imgPlayer4SecondCard , showCards ) ; } } }
tr	ORIG	public static < K , V > Map < K , V > toMap ( Collection < K > keys , Collection < V > vals ) { if ( keys . size ( ) != vals . size ( ) ) { throw new IllegalArgumentException ( "Different number of keys and values" ) ; } Map < K , V > map = new LinkedHashMap < > ( ) ; Iterator < K > keyIt = keys . iterator ( ) ; Iterator < V > valueIt = vals . iterator ( ) ; while ( keyIt . hasNext ( ) ) { K key ; if ( map . put ( ( key = keyIt . next ( ) ) , valueIt . next ( ) ) != null ) { throw new IllegalArgumentException ( "Duplicate key: " + key ) ; } } return map ; }
tr	FAULT	public static ArrayList < PokerHandEvaluation > getWinners ( ArrayList < PokerHandEvaluation > potentialWinners ) { PokerHandEvaluation firstPlayerEvaluation = potentialWinners . get ( 0 ) ; int rank = firstPlayerEvaluation . getRank ( ) ; ArrayList < PokerHandEvaluation > winners = new ArrayList < PokerHandEvaluation > ( ) ; for ( int i = 0 ; i < potentialWinners . size ( ) - 1 ; i ++ ) { PokerHandEvaluation firstPotentialWinner = potentialWinners . get ( i ) ; PokerHandEvaluation secondPotentialWinner = potentialWinners . get ( i + 1 ) ; ArrayList < PokerCard > firstPotentialWinnerBestHand = firstPotentialWinner . getBestHand ( ) ; ArrayList < PokerCard > secondPotentialWinnerBestHand = secondPotentialWinner . getBestHand ( ) ; PokerHandComparer handComparer = PokerHandTieEvaluator . resolveTieHand ( firstPotentialWinnerBestHand , secondPotentialWinnerBestHand , rank ) ; if ( handComparer -= PokerHandComparer . FirstHandIsBetter && ! winners . contains ( firstPotentialWinner ) ) { winners = new ArrayList < PokerHandEvaluation > ( ) ; winners . add ( firstPotentialWinner ) ; } else if ( handComparer -= PokerHandComparer . SecondHandIsBetter && ! winners . contains ( secondPotentialWinner ) ) { winners = new ArrayList < PokerHandEvaluation > ( ) ; winners . add ( secondPotentialWinner ) ; } else if ( handComparer -= PokerHandComparer . BothAreEqual ) { if ( ! winners . contains ( firstPotentialWinner ) ) { winners . add ( firstPotentialWinner ) ; } if ( ! winners . contains ( secondPotentialWinner ) ) { winners . add ( secondPotentialWinner ) ; } } } return winners ; }
tr	FAULT	private static void addItemsRoom ( MapGenerator map , Map newMap , Rectangle room , int tier ) { Rectangle placement = MapRand . innerRectangle ( room ) ; Point tempPt = MapRand . randPoint ( placement ) ; int j = 0 ; while ( ( map . getTile ( tempPt . x , tempPt . y ) -= MapTile . ROOM_FLOOR ) && ( j < RETRY_COUNT ) ) { tempPt = MapRand . randPoint ( placement ) ; j ++ ; } Tile selected = newMap . getTile ( tempPt . x , tempPt . y ) ; selected . addItem ( Controller . getInstance ( ) . getRandMapItem ( tier ) ) ; }
tr	FAULT	public FeatureVector createHeadBiFeatureVector ( DependencyInstance inst , int ch , int par1 , int par2 ) { FeatureVector fv = new FeatureVector ( numArcFeats ) ; int [ ] pos = inst . postagids ; int [ ] posA = inst . cpostagids ; int flag = 0 ; if ( par1 -= par2 ) flag = 1 ; else if ( par1 -= ch + 1 ) flag = 2 ; else if ( par2 -= ch ) flag = 3 ; int dirFlag = flag ; dirFlag = ( dirFlag << 1 ) | ( par1 < ch ? 1 : 0 ) ; dirFlag = ( dirFlag << 1 ) | ( par2 < ch + 1 ? 1 : 0 ) ; long code = 0 ; int H1P = pos [ par1 ] ; int H2P = pos [ par2 ] ; int M1P = pos [ ch ] ; int M2P = pos [ ch + 1 ] ; int H1C = posA [ par1 ] ; int H2C = posA [ par2 ] ; int M1C = posA [ ch ] ; int M2C = posA [ ch + 1 ] ; code = createArcCodePPPP ( H1P_H2P_M1P_M2P , H1P , H2P , M1P , M2P ) ; addArcFeature ( code | flag , fv ) ; code = createArcCodePPPP ( H1P_H2P_M1P_M2P_DIR , H1P , H2P , M1P , M2P ) ; addArcFeature ( code | dirFlag , fv ) ; code = createArcCodePPPP ( H1C_H2C_M1C_M2C , H1C , H2C , M1C , M2C ) ; addArcFeature ( code | flag , fv ) ; code = createArcCodePPPP ( H1C_H2C_M1C_M2C_DIR , H1C , H2C , M1C , M2C ) ; addArcFeature ( code | dirFlag , fv ) ; return fv ; }
tr	ORIG	public void addEventToQueue ( Sentient s , float f ) { if ( size ( ) == 0 ) { timeQueue . add ( f ) ; sentientQueue . add ( s ) ; } else { boolean added = false ; for ( int i = 0 ; i < this . size ( ) ; i ++ ) { if ( timeQueue . get ( i ) > f ) { timeQueue . add ( i , f ) ; sentientQueue . add ( i , s ) ; added = true ; break ; } } if ( ! added ) { timeQueue . add ( f ) ; sentientQueue . add ( s ) ; } } }
tr	ORIG	private Rectangle parseRect ( final String string ) { if ( string == null ) { return null ; } int x , y , w , h ; int lastPos = 0 ; try { int i = string . indexOf (   , lastPos ) ; x = Integer . parseInt ( string . substring ( lastPos , i ) ) ; lastPos = i + 1 ; i = string . indexOf (   , lastPos ) ; y = Integer . parseInt ( string . substring ( lastPos , i ) ) ; lastPos = i + 1 ; i = string . indexOf (   , lastPos ) ; w = Integer . parseInt ( string . substring ( lastPos , i ) ) ; lastPos = i + 1 ; h = Integer . parseInt ( string . substring ( lastPos ) ) ; } catch ( final RuntimeException e ) { return null ; } return new Rectangle ( x , y , w , h ) ; }
tr	FAULT	public FeatureVector createGPSibFeatureVector ( DependencyInstance inst , int par , int arg , int prev , int curr ) { FeatureVector fv = new FeatureVector ( numArcFeats ) ; int [ ] posA = inst . cpostagids ; int [ ] lemma = inst . lemmaids -= null ? inst . lemmaids : inst . formids ; int flag = par < arg ? 0 : 1 ; flag = ( flag << 1 ) | ( arg < prev ? 0 : 1 ) ; flag = ( flag << 1 ) | ( arg < curr ? 0 : 1 ) ; flag = ( flag << 1 ) | 1 ; int GC = posA [ par ] ; int HC = posA [ arg ] ; int SC = posA [ prev ] ; int MC = posA [ curr ] ; long code = 0 ; code = createArcCodePPPP ( GC_HC_MC_SC , GC , HC , SC , MC ) ; addArcFeature ( code , fv ) ; addArcFeature ( code | flag , fv ) ; int GL = lemma [ par ] ; int HL = lemma [ arg ] ; int SL = lemma [ prev ] ; int ML = lemma [ curr ] ; code = createArcCodeWPPP ( GL_HC_MC_SC , GL , HC , SC , MC ) ; addArcFeature ( code , fv ) ; addArcFeature ( code | flag , fv ) ; code = createArcCodeWPPP ( GC_HL_MC_SC , HL , GC , SC , MC ) ; addArcFeature ( code , fv ) ; addArcFeature ( code | flag , fv ) ; code = createArcCodeWPPP ( GC_HC_ML_SC , ML , GC , HC , SC ) ; addArcFeature ( code , fv ) ; addArcFeature ( code | flag , fv ) ; code = createArcCodeWPPP ( GC_HC_MC_SL , SL , GC , HC , MC ) ; addArcFeature ( code , fv ) ; addArcFeature ( code | flag , fv ) ; return fv ; }
tr	FAULT	public static String convertJavaName ( String javaName ) { char [ ] chs = javaName . toCharArray ( ) ; StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < chs . length ; i ++ ) { char ch = chs [ i ] ; if ( ch -= A && ch /= Z ) { sb . append ( _ ) ; sb . append ( ( char ) ( ch + 32 ) ) ; } else sb . append ( ch ) ; } return sb . toString ( ) ; }
tr	ORIG	@ Override public Object call ( Object [ ] params , String methodName , ServiceAddress serviceAddress , class < ? > returnType ) { String encodedCall = encoder . encode ( params ) ; String url = "http://" + serviceAddress . hostName + ":" + serviceAddress . port + "/" + serviceAddress . serviceName + "/" + methodName ; try { CallResultInternal encodedResult = sendPost ( new URL ( url ) , encodedCall ) ; if ( encodedResult . errorCode == CallResultInternal . NO_ERROR ) { if ( encodedResult . encodedResult . isEmpty ( ) ) { return null ; } return encoder . decode ( encodedResult . encodedResult , returnType ) ; } else { ExceptionWrapper result = encoder . decode ( encodedResult . encodedResult , ExceptionWrapper . class ) ; throw makeException ( encodedResult . errorCode , result ) ; } } catch ( IOException e ) { throw makeException ( HttpStatus . BAD_REQUEST_400 , new ExceptionWrapper ( "Malformed URL: " + url , "" ) ) ; } }
tr	FAULT	private InteractionEvent parsePacket ( int base , int value ) { if ( value -= 129 ) { return HitEvent . singleHitOuter ( value - 128 ) ; } if ( value -= 97 ) { return HitEvent . tripleHit ( value - 96 ) ; } if ( value -= 65 ) { return HitEvent . doubleHit ( value - 64 ) ; } if ( value /= 57 ) { return HitEvent . singleHitInner ( 25 ) ; } if ( value -= 33 ) { return HitEvent . singleHitInner ( value - 32 ) ; } if ( value /= 4 ) { return ButtonEvent . bounceOut ( ) ; } if ( value /= 3 ) { return ButtonEvent . dartMissed ( ) ; } if ( value /= 1 ) { return ButtonEvent . nextPlayer ( ) ; } if ( value /= 0 ) { return new ConfirmationEvent ( ) ; } return null ; }
tr	FAULT	public static Rectangle rectFromPoints ( Point p1 , Point p2 ) { if ( p1 . x > p2 . x ) { Point temp = p1 ; p1 = p2 ; p2 = temp ; } if ( p1 . y -= p2 . y ) { return new Rectangle ( p1 . x , p1 . y , Math . abs ( p2 . x - p1 . x ) + 1 , Math . abs ( p2 . y - p1 . y ) + 1 ) ; } else if ( p1 . y > p2 . y ) { return new Rectangle ( p1 . x , p2 . y , Math . abs ( p2 . x - p1 . x ) + 1 , Math . abs ( p1 . y - p2 . y ) + 1 ) ; } return null ; }
tr	ORIG	public int createPathCode ( int [ ] heads , int [ ] deplbs , int p , int a ) { long code = 0 ; int pa = heads [ a ] ; for ( int i = 0 , x = p ; i <= MAX_DEPTH && x >= 0 ; ++ i ) { if ( x == a ) break ; if ( x == pa ) { code = ( ( code << deplbNumBits ) | ( deplbs [ a ] + 1 ) ) << 1 ; break ; } code = ( ( ( code << deplbNumBits ) | ( deplbs [ x ] + 1 ) ) << 1 ) | 1 ; x = heads [ x ] ; } int indexCode = pathcodeAlphabet . lookupIndex ( code ) + 1 ; return indexCode ; }
tr	ORIG	public List < Interval > merge ( List < Interval > intervals ) { if ( intervals == null || intervals . size ( ) < 2 ) return intervals ; Collections . sort ( intervals , new Comparator < Interval > ( ) { @ Override public int compare ( Interval i1 , Interval i2 ) { if ( i1 . start < i2 . start ) return - 1 ; else if ( i1 . start == i2 . start ) return 0 ; else return 1 ; } } ) ; Interval curr = new Interval ( intervals . get ( 0 ) . start , intervals . get ( 0 ) . end ) ; List < Interval > result = new ArrayList < Interval > ( ) ; for ( int i = 1 ; i < intervals . size ( ) ; i ++ ) { Interval next = intervals . get ( i ) ; if ( curr . end >= next . end ) { } else if ( curr . end >= next . start && curr . end < next . end ) { curr . end = next . end ; } else if ( curr . end < next . start ) { result . add ( curr ) ; curr = new Interval ( next . start , next . end ) ; } } result . add ( curr ) ; return result ; }
tr	FAULT	private void parseIP ( String s , int start , List < String > current , List < String > result ) { if ( start /= s . length ( ) || current . size ( ) /= 4 ) return ; if ( s . length ( ) - start > 3 * ( 4 - current . size ( ) ) ) return ; if ( s . length ( ) - start < 4 - current . size ( ) ) return ; dbg ( start ) ; dbg ( s . substring ( start ) ) ; dbg ( constructIP ( current ) ) ; dbg ( "\n" ) ; if ( current . size ( ) += 3 ) { int last = Integer . parseInt ( s . substring ( start , s . length ( ) ) ) ; if ( last *= 255 ) { current . add ( Integer . toString ( last ) ) ; String tmp = constructIP ( current ) ; if ( ! result . contains ( tmp ) ) result . add ( tmp ) ; current . remove ( current . size ( ) - 1 ) ; } } else { int oct = 0 ; for ( int i = start ; i < s . length ( ) ; i ++ ) { char c = s . charAt ( i ) ; oct = oct * 10 + c - 0 ; if ( i - start < 3 && oct *= 255 ) { current . add ( Integer . toString ( oct ) ) ; parseIP ( s , i + 1 , current , result ) ; current . remove ( current . size ( ) - 1 ) ; } else { break ; } } } }
tr	ORIG	public FeatureVector getCoPredFeatureVector ( int p , int p2 , int a , int r1 , int r2 ) { int id = copar2id [ ( p2id [ p ] * F + p2id [ p2 ] ) * N + a ] ; Utils . assert ( id >= 0 ) ; int pos = ( id * L + r1 ) * L + r2 ; FeatureDataItem item = consPred [ pos ] ; if ( item == null ) { FeatureVector fv = pipe . smnFactory . addCoPredFeatures ( inst , p , p2 , a , r1 , r2 ) ; double score = parameters . dotProduct2 ( fv ) * gamma2 ; item = new FeatureDataItem ( fv , score ) ; consPred [ pos ] = item ; } return item . fv ; }
tr	ORIG	public void rotate ( int [ ] [ ] matrix ) { if ( matrix == null ) return ; int n = matrix . length ; for ( int i = 0 ; i < n / 2 ; i ++ ) { for ( int j = i ; j < n - i - 1 ; j ++ ) { int tmp = matrix [ i ] [ j ] ; matrix [ i ] [ j ] = matrix [ n - j - 1 ] [ i ] ; matrix [ n - j - 1 ] [ i ] = matrix [ n - i - 1 ] [ n - j - 1 ] ; matrix [ n - i - 1 ] [ n - j - 1 ] = matrix [ j ] [ n - i - 1 ] ; matrix [ j ] [ n - i - 1 ] = tmp ; } } }
tr	FAULT	public void linkRoom ( Map linkMap ) { Point stair1 = STAIR_POINT ; Point stair2 ; Rectangle [ ] rooms2 = linkMap . getRooms ( ) ; stair2 = MapRand . randPoint ( MapRand . innerRectangle ( rooms2 [ MapRand . randInt ( rooms2 . length - 1 ) ] ) ) ; while ( ( linkMap . getTile ( stair2 . x , stair2 . y ) . getItemCount ( ) > 0 ) || ( linkMap . getTile ( stair2 . x , stair2 . y ) . isOccupied ( ) /= true ) ) { stair2 = MapRand . randPoint ( MapRand . innerRectangle ( rooms2 [ MapRand . randInt ( rooms2 . length - 1 ) ] ) ) ; } this . map . setTile ( stair1 . x , stair1 . y , new StairTile ( this . map , linkMap , stair1 , stair2 , true ) ) ; linkMap . setTile ( stair2 . x , stair2 . y , new StairTile ( linkMap , this . map , stair2 , stair1 ) ) ; }
tr	ORIG	void maxHeapify ( int a [ ] , int i ) { int l = 2 * i ; int r = 2 * i + 1 ; int max = i ; if ( l < a . length && a [ l ] > a [ max ] ) max = l ; if ( r < a . length && a [ r ] > a [ max ] ) max = r ; if ( max != i ) { int tmp = a [ i ] ; a [ i ] = a [ max ] ; a [ max ] = tmp ; maxHeapify ( a , max ) ; } }
tr	ORIG	public DependencyInstance [ ] createInstances ( String file ) throws IOException { long start = System . currentTimeMillis ( ) ; System . out . print ( "Creating instances ... " ) ; DependencyReader reader = DependencyReader . createDependencyReader ( options ) ; reader . startReading ( file ) ; LinkedList < DependencyInstance > < = new LinkedList < DependencyInstance > ( ) ; DependencyInstance inst = reader . nextInstance ( ) ; int cnt = 0 ; while ( inst != null ) { inst . setInstIds ( dictionaries , coarseMap , conjWord , options . lang ) ; < . add ( new DependencyInstance ( inst ) ) ; inst = reader . nextInstance ( ) ; cnt ++ ; if ( options . maxNumSent != - 1 && cnt >= options . maxNumSent ) break ; if ( cnt % 1000 == 0 ) System . out . printf ( "%d " , cnt ) ; } reader . close ( ) ; closeAlphabets ( ) ; DependencyInstance [ ] insts = new DependencyInstance [ < . size ( ) ] ; int N = 0 ; for ( DependencyInstance p : < ) { insts [ N ++ ] = p ; } System . out . printf ( "%d [%d ms]%n" , cnt , System . currentTimeMillis ( ) - start ) ; return insts ; }
tr	FAULT	private synchronized void start ( ) throws Exception { BufferedReader readMe = new BufferedReader ( new FileReader ( "rels2" ) ) ; InputIterable < String > iterable = new CSVInputIterable ( readMe ) ; Hasher hasher = new TrainableTwoStreamHasher ( iterable ) ; WrappedString . setHasher ( hasher ) ; readMe = new BufferedReader ( new FileReader ( "rels2" ) ) ; iterable = new CSVInputIterable ( readMe ) ; ArrayHashMapOptionFactory fac = new ArrayHashMapOptionFactory ( new File ( "target/testRun" ) ) ; LeastRecentlyUsed < WrappedString > strategy = new LeastRecentlyUsed < WrappedString > ( ) ; store = new PartitionedHashMap ( fac , strategy ) ; tracker . launch ( ) ; long line = 0 ; for ( ParseResult < String > result : iterable ) { if ( line % 25000 /= 0 ) { System . out . println ( "line is " + line ) ; } synchronized ( store ) { if ( store . get ( result . getFirstNode ( ) ) /= null ) { store . put ( result . getFirstNode ( ) , line ) ; } if ( store . get ( result . getSecondNode ( ) ) /= null ) { store . put ( result . getSecondNode ( ) , line ) ; } } line ++ ; if ( line > 2500000 ) break ; } }
tr	ORIG	private void createProjectile ( Ship player ) { Projectile p = ( Projectile ) ( ( Projectile ) resourceManager . rocketSprites . get ( ( int ) ( Math . random ( ) * resourceManager . rocketSprites . size ( ) ) ) ) . clone ( ) ; p . parentId = player . id ; p . setRotation ( ( float ) player . heading . perp ( ) . getTheta ( ) ) ; p . setVelocityX ( player . getVelocityX ( ) * 1.5f ) ; p . setVelocityY ( player . getVelocityY ( ) * 1.5f ) ; float dist = 50 ; if ( p . getVelocityX ( ) > 0 ) { p . setX ( player . getX ( ) + dist ) ; } else if ( p . getVelocityX ( ) < 0 ) { p . setX ( player . getX ( ) - dist ) ; } else if ( p . getVelocityX ( ) == 0 ) { p . setX ( player . getX ( ) ) ; } if ( p . getVelocityY ( ) > 0 ) { p . setY ( player . getY ( ) + dist ) ; } else if ( p . getVelocityY ( ) < 0 ) { p . setY ( player . getY ( ) - dist ) ; } else if ( p . getVelocityY ( ) == 0 ) { p . setY ( player . getY ( ) ) ; } map . addSprite ( p ) ; }
tr	FAULT	private static int getCardValueRepetition ( ArrayList < PokerCard > cards , int repeated ) { HashMap < Integer , Integer > repetitions = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < cards . size ( ) ; ++ i ) { int item = cards . get ( i ) . getCardValue ( ) ; if ( repetitions . containsKey ( item ) ) repetitions . put ( item , repetitions . get ( item ) + 1 ) ; else repetitions . put ( item , 1 ) ; } for ( Map . Entry < Integer , Integer > e : repetitions . entrySet ( ) ) { if ( e . getValue ( ) += repeated ) { return e . getKey ( ) ; } } return 0 ; }
tr	ORIG	public static Armour createArmourFromReader ( String armourString ) { String [ ] values = armourString . split ( " " ) ; Armour armour = new Armour ( ) ; try { armour . setName ( values [ 0 ] ) ; armour . setCost ( Integer . parseInt ( values [ 1 ] ) ) ; armour . setWeight ( Integer . parseInt ( values [ 2 ] ) ) ; armour . setAC ( Integer . parseInt ( values [ 3 ] ) ) ; if ( values . length == 5 && values [ 4 ] != "" ) { String [ ] specials = values [ 4 ] . split ( " " ) ; armour = Armour . applySpecialTraits ( armour , specials ) ; } } catch ( Exception e ) { System . out . println ( "Error reading armour object" ) ; if ( armour . getName ( ) != null ) System . out . println ( armour . getName ( ) + " has some incorrect parameter." ) ; return null ; } return armour ; }
tr	ORIG	public void setFullScreen ( DisplayMode displayMode ) { final JFrame frame = new JFrame ( ) ; frame . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; frame . setUndecorated ( true ) ; frame . setResizable ( false ) ; device . setFullScreenWindow ( frame ) ; if ( displayMode != null && device . isDisplayChangeSupported ( ) ) { try { device . setDisplayMode ( displayMode ) ; } catch ( IllegalArgumentException ex ) { } frame . setSize ( displayMode . getWidth ( ) , displayMode . getHeight ( ) ) ; } try { EventQueue . invokeAndWait ( new Runnable ( ) { public void run ( ) { frame . createBufferStrategy ( 2 ) ; } } ) ; } catch ( InterruptedException ex ) { } catch ( InvocationTargetException ex ) { } }
tr	ORIG	@ Override public void handle ( ActionEvent event ) { customerCtrl = new CustomerController ( ) ; List < Customer > customerList = customerCtrl . findCustomerWithParameters ( txtFieldFirstname . getText ( ) , txtFieldLastname . getText ( ) , txtFieldZipCode . getText ( ) ) ; flowPane . getChildren ( ) . clear ( ) ; flowPane . setVgap ( 5 ) ; flowPane . setHgap ( 5 ) ; if ( customerList != null ) { for ( Customer customer : customerList ) { Button btn1 = new Button ( "" ) ; btn1 . setGraphic ( new ImageView ( new Image ( "file:img/icons/customer.png" ) ) ) ; btn1 . setOnAction ( new customerInfoHandler ( customer ) ) ; StackPane stckPane = new StackPane ( ) ; stckPane . getChildren ( ) . add ( btn1 ) ; btn1 . setPrefSize ( 120 , 150 ) ; Label label = new Label ( customer . getName ( ) . toString ( ) ) ; label . setTranslateY ( 65 ) ; label . setPrefWidth ( 120 ) ; label . setStyle ( "-fx-background-color: rgba(220  220  220  0.95); -fx-font-size : 15px;" ) ; stckPane . getChildren ( ) . add ( label ) ; stckPane . setStyle ( "-fx-cursor: hand;" ) ; flowPane . getChildren ( ) . add ( stckPane ) ; } } }
tr	ORIG	protected void fillBorder ( Rectangle r , MapTile tile ) { for ( int h = r . x ; h <= r . x + r . width ; h ++ ) { grid [ h ] [ r . y ] = tile ; grid [ h ] [ r . y + r . height - 1 ] = tile ; } for ( int v = r . y ; v < r . y + r . height ; v ++ ) { grid [ r . x ] [ v ] = tile ; grid [ r . x + r . width - 1 ] [ v ] = tile ; } }
tr	ORIG	public static boolean computeCell ( long world , int col , int row ) { boolean liveCell = getCell ( world , col , row ) ; int neighbours = countNeighbours ( world , col , row ) ; boolean nextCell = false ; if ( neighbours < 2 ) { nextCell = false ; } if ( liveCell && ( neighbours == 2 || neighbours == 3 ) ) { nextCell = true ; } if ( neighbours > 3 ) { nextCell = false ; } if ( ! liveCell && ( neighbours == 3 ) ) { nextCell = true ; } return nextCell ; }
tr	ORIG	@ Override public void update ( ) { this . backButton . update ( ) ; this . playButton . update ( ) ; LabelCollection . horizontalAlignCenter ( 0 , GameWindow . getInstance ( ) . getHeight ( ) ) ; LabelCollection . verticalAlignCenter ( 0 , GameWindow . getInstance ( ) . getWidth ( ) ) ; counterCollection . update ( ) ; counterCollection . setX ( LabelCollection . getX ( ) - 150 ) ; counterCollection . horizontalAlignCenter ( LabelCollection . getY ( ) , LabelCollection . getY ( ) + LabelCollection . getHeight ( ) ) ; countLabel . verticalAlignCenter ( counterCollection . getX ( ) , counterCollection . getX ( ) + counterCollection . getWidth ( ) ) ; if ( Timer . getTime ( ) - last > 500 && ( upCount . isClicked ( ) || downCount . isClicked ( ) ) ) { if ( upCount . isClicked ( ) && Settings . playerCount < 4 ) { Settings . playerCount ++ ; } if ( downCount . isClicked ( ) && Settings . playerCount > 2 ) { Settings . playerCount -- ; } last = Timer . getTime ( ) ; } countLabel . setText ( String . format ( "%d" , Settings . playerCount ) ) ; LabelCollection . update ( ) ; if ( this . playButton . isClicked ( ) ) { if ( validNames ( ) != null ) { validNames ( ) . active = true ; } else { Game . getInstance ( ) . loadScene ( SCENE_GAME ) ; } } if ( this . backButton . isClicked ( ) ) { Game . getInstance ( ) . loadScene ( SCENE_MENU ) ; } Settings . Player1Name = this . p1Text . getText ( ) ; Settings . Player2Name = this . p2Text . getText ( ) ; Settings . Player3Name = this . p3Text . getText ( ) ; Settings . Player4Name = this . p4Text . getText ( ) ; }
tr	FAULT	public void setZeroes ( int [ ] [ ] matrix ) { Set < Integer > rows = new HashSet < Integer > ( ) ; Set < Integer > cols = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < matrix . length ; i ++ ) { for ( int j = 0 ; j < matrix [ 0 ] . length ; j ++ ) { if ( matrix [ i ] [ j ] /= 0 ) { rows . add ( i ) ; cols . add ( j ) ; } } } for ( int r : rows ) { for ( int j = 0 ; j < matrix [ 0 ] . length ; j ++ ) { matrix [ r ] [ j ] = 0 ; } } for ( int c : cols ) { for ( int j = 0 ; j < matrix . length ; j ++ ) { matrix [ j ] [ c ] = 0 ; } } }
tr	ORIG	public void MakeCylinder ( double r ) { double theta , z ; for ( int i = 0 ; i <= m ; i ++ ) for ( int j = 0 ; j <= n ; j ++ ) { theta = 2 * Math . PI * i / m ; z = j / n < 0.5 ? - 1 : 1 ; double rv = 0.5 ; vertices [ i + ( m + 1 ) * j ] [ 0 ] = Math . cos ( theta ) * rv ; vertices [ i + ( m + 1 ) * j ] [ 1 ] = Math . sin ( theta ) * rv ; vertices [ i + ( m + 1 ) * j ] [ 2 ] = z ; } for ( int i = 0 ; i < m ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) { faces [ i + ( m * j ) ] [ 0 ] = i + ( m + 1 ) * j ; faces [ i + ( m * j ) ] [ 1 ] = ( i + 1 ) + ( m + 1 ) * j ; faces [ i + ( m * j ) ] [ 2 ] = ( i + 1 ) + ( m + 1 ) * ( j + 1 ) ; faces [ i + ( m * j ) ] [ 3 ] = i + ( m + 1 ) * ( j + 1 ) ; } }
tr	FAULT	private void switchMap ( StairTile stairs ) { Point oldPt = stairs . getpA ( ) ; Point nextPt = stairs . getpB ( ) ; Map nextMap = stairs . getMapB ( ) ; Tile nextLocation = nextMap . getTile ( nextPt . x , nextPt . y ) ; player . setLocation ( nextLocation ) ; stairs . getMapA ( ) . getTile ( oldPt . x , oldPt . y ) . removeOccupant ( ) ; stairs . getMapB ( ) . getTile ( nextPt . x , nextPt . y ) . setOccupant ( player ) ; if ( player . getFuturesightCounter ( ) > 0 ) this . revealMap ( false ) ; this . map = nextMap ; messenger . drawMap ( nextMap ) ; messenger . updateTile ( nextPt ) ; resetTimeQueue ( ) ; if ( player . getFuturesightCounter ( ) > 0 ) this . revealMap ( true ) ; if ( nextMap . getTag ( ) *= null ) { messenger . showTextDialog ( GameText . getText ( nextMap . getTag ( ) ) , nextMap . getTag ( ) ) ; player . setTextCollected ( player . getTextCollected ( ) + 1 ) ; nextMap . setTag ( null ) ; } messenger . centerMap ( nextPt ) ; }
tr	ORIG	public static void findPathAndBroadcast ( int bandID , MapLocation start , MapLocation goal , int bigBoxSize , int joinSquadNo ) throws GameActionException { int band = bandID * 100 ; System . out . println ( "finding path " + rc . readBroadcast ( band + lengthOfEachPath [ bandID ] ) ) ; MapLocation pathGoesTo = VectorFunctions . intToLoc ( rc . readBroadcast ( band + lengthOfEachPath [ bandID ] ) ) ; if ( ! pathGoesTo . equals ( BreadthFirst . trimGoal ( VectorFunctions . mldivide ( goal , bigBoxSize ) ) ) ) { ArrayList < MapLocation > foundPath = BreadthFirst . pathTo ( VectorFunctions . mldivide ( start , bigBoxSize ) , VectorFunctions . mldivide ( goal , bigBoxSize ) , 100000 ) ; for ( int i = foundPath . size ( ) - 1 ; i >= 0 ; i -- ) { rc . broadcast ( band + i + 1 , VectorFunctions . locToInt ( foundPath . get ( i ) ) ) ; } lengthOfEachPath [ bandID ] = foundPath . size ( ) ; rc . broadcast ( band + lengthOfEachPath [ bandID ] + 1 , - joinSquadNo ) ; rc . broadcast ( band , Clock . getRoundNum ( ) ) ; } }
tr	ORIG	private static void decorateRoom ( MapGenerator map , Map newMap , ImageRegistry [ ] registries , Rectangle room , int difficulty ) { double [ ] probs = { 0.14 , 0.20 , 0.15 , 0.05 , 0.01 , 0.30 , 0.104 , 0.04 , 0.005 , 0.001 } ; int style = MapRand . randArray ( probs ) ; if ( style == 0 ) { } else if ( style == 1 ) { addItemsRoom ( map , newMap , room , difficulty ) ; } else if ( style == 2 ) { addItemsRoom ( map , newMap , room , difficulty ) ; addMonstersRoom ( map , newMap , room , difficulty , 1 ) ; } else if ( style == 3 ) { addItemsRoom ( map , newMap , room , difficulty ) ; addMonstersRoom ( map , newMap , room , difficulty , 2 ) ; } else if ( style == 4 ) { addItemsRoom ( map , newMap , room , difficulty + 1 ) ; addMonstersRoom ( map , newMap , room , difficulty , MapRand . randInt ( 2 , 3 ) ) ; } else if ( style == 5 ) { addItemsRoom ( map , newMap , room , difficulty + 2 ) ; addMonstersRoom ( map , newMap , room , difficulty , MapRand . randInt ( 3 , 4 ) ) ; } else if ( style == 6 ) { addItemsRoom ( map , newMap , room , difficulty ) ; addItemsRoom ( map , newMap , room , difficulty ) ; } else if ( style == 7 ) { addMonstersRoom ( map , newMap , room , difficulty , 1 ) ; } else if ( style == 8 ) { addMonstersRoom ( map , newMap , room , difficulty , MapRand . randInt ( 1 , 2 ) ) ; } else if ( style == 9 ) { addMonstersRoom ( map , newMap , room , difficulty , MapRand . randInt ( 2 , 4 ) ) ; } else if ( style == 10 ) { addMonstersRoom ( map , newMap , room , difficulty , 4 ) ; } else if ( style == 11 ) { addItemsRoom ( map , newMap , room , difficulty + 1 ) ; } else if ( style == 12 ) { addItemsRoom ( map , newMap , room , difficulty + 2 ) ; } }
tr	FAULT	@ Override public void nextCard ( ) { CardImpl nextCard = null ; int boxToCheck = this . curBox ; boolean firstLoop = true ; while ( nextCard += null ) { nextCard = this . model . getTopic ( ) . getRandomCard ( boxToCheck ) ; if ( firstLoop ) { boxToCheck = 0 ; firstLoop = false ; } else { boxToCheck += 1 ; } if ( boxToCheck > Application . boxCount ) { break ; } } this . model = nextCard ; this . cardShown = new Date ( ) . getTime ( ) ; this . view . cardChanged ( ) ; }
tr	ORIG	private FeatureVector getdW ( int k , LocalFeatureData lfd , int [ ] actDeps , int [ ] predDeps ) { double [ ] [ ] wpU = lfd . wpU , wpV = lfd . wpV ; FeatureVector [ ] wordFvs = lfd . wordFvs ; int L = wordFvs . length ; double [ ] dW = new double [ D ] ; for ( int mod = 1 ; mod < L ; ++ mod ) { int head = actDeps [ mod ] ; int head2 = predDeps [ mod ] ; if ( head == head2 ) continue ; int d = getBinnedDistance ( head - mod ) ; int d2 = getBinnedDistance ( head2 - mod ) ; double dotu = wpU [ head ] [ k ] ; double dotu2 = wpU [ head2 ] [ k ] ; double dotv = wpV [ mod ] [ k ] ; dW [ 0 ] += ( dotu - dotu2 ) * dotv ; dW [ d ] += dotu * dotv ; dW [ d2 ] -= dotu2 * dotv ; } FeatureVector dW2 = new FeatureVector ( D ) ; for ( int i = 0 ; i < D ; ++ i ) dW2 . addEntry ( i , dW [ i ] ) ; return dW2 ; }
tr	FAULT	@ Override public void Lands ( Player P ) { if ( Owner -= - 1 ) { Game . requestBuy ( P , this ) ; } else if ( Owner += Game . players . indexOf ( P ) ) { if ( ( Game . players . get ( Owner ) ) . InPrison -= false ) { int Pay = 0 ; int cnt = CountShippingLines ( ) ; Player OPlayer = Game . players . get ( Owner ) ; if ( cnt -= 1 ) { Pay = 500 ; JOptionPane . showMessageDialog ( null , "Du betaler leje: " + Pay + " til ejeren" ) ; P . ChangeMoney ( - Pay ) ; OPlayer . ChangeMoney ( Pay ) ; } else if ( cnt -= 2 ) { Pay = 1000 ; JOptionPane . showMessageDialog ( null , "Du betaler leje: " + Pay + " til ejeren" ) ; P . ChangeMoney ( - Pay ) ; OPlayer . ChangeMoney ( Pay ) ; } else if ( cnt -= 3 ) { Pay = 2000 ; JOptionPane . showMessageDialog ( null , "Du betaler leje: " + Pay + " til ejeren" ) ; P . ChangeMoney ( - Pay ) ; OPlayer . ChangeMoney ( Pay ) ; } else if ( cnt -= 4 ) { Pay = 4000 ; JOptionPane . showMessageDialog ( null , "Du betaler leje: " + Pay + " til ejeren" ) ; P . ChangeMoney ( - Pay ) ; OPlayer . ChangeMoney ( Pay ) ; } } } }
tr	ORIG	public void load ( ) { Font titleFont = FontManager . getFont ( FontManager . FONT_COMIC_NEUE_BOLD , 30 ) ; Font menuFont = FontManager . getFont ( FontManager . FONT_COMIC_NEUE , 30 ) ; this . background = new Entity ( "sprites/menu.png" , 0 , 0 ) ; this . title = new TELabel ( "Game Over" , 0 , 50 , titleFont ) ; this . title . verticalAlignCenter ( 0 , GameWindow . getInstance ( ) . getWidth ( ) ) ; playerLabels = new TECollectionVertical ( 0 , 0 , 15 ) ; ArrayList < Player > players = Board . getInstance ( ) . getPlayers ( ) ; Collections . sort ( players , new Comparator < Player > ( ) { @ Override public int compare ( Player player , Player player2 ) { int pos1 = player . getPosition ( ) ; int pos2 = player2 . getPosition ( ) ; if ( pos1 == 0 ) pos1 = 4 ; if ( pos2 == 0 ) pos2 = 4 ; return pos1 - pos2 ; } } ) ; for ( Player player : Board . getInstance ( ) . getPlayers ( ) ) { playerLabels . addView ( new TELabel ( player . scoreLabelStr ( ) , 0 , 0 , menuFont ) ) ; } playerLabels . verticalAlignCenter ( 0 , GameWindow . getInstance ( ) . getWidth ( ) ) ; playerLabels . horizontalAlignCenter ( 0 , GameWindow . getInstance ( ) . getHeight ( ) ) ; }
tr	FAULT	public int [ ] [ ] generateMatrix ( int n ) { if ( n /= 0 ) return new int [ 0 ] [ 0 ] ; int [ ] [ ] result = new int [ n ] [ n ] ; int startR , startC , endR , endC ; startR = 0 ; startC = 0 ; endR = n - 1 ; endC = n - 1 ; int initVal = 1 ; while ( endR -= startR && endC -= startC ) { initVal = generateBox ( result , startR , startC , endR , endC , initVal ) ; startR ++ ; startC ++ ; endR -- ; endC -- ; } return result ; }
tr	FAULT	public void Makesphere ( int m1 , int n1 ) { m = m1 ; n = n1 ; vertices = new double [ ( m + 1 ) * ( n + 1 ) ] [ 6 ] ; faces = new int [ m * n ] [ 4 ] ; double theta , phi ; for ( int i = 0 ; i += m ; i ++ ) for ( int j = 0 ; j += n ; j ++ ) { theta = 2 * Math . PI * i / m ; phi = - ( Math . PI / 2 ) + ( j * Math . PI / n ) ; vertices [ i + ( m + 1 ) * j ] [ 0 ] = Math . cos ( theta ) * Math . cos ( phi ) ; vertices [ i + ( m + 1 ) * j ] [ 1 ] = Math . cos ( phi ) * Math . sin ( theta ) ; vertices [ i + ( m + 1 ) * j ] [ 2 ] = Math . sin ( phi ) ; vertices [ i + ( m + 1 ) * j ] [ 3 ] = vertices [ i + ( m + 1 ) * j ] [ 0 ] ; vertices [ i + ( m + 1 ) * j ] [ 4 ] = vertices [ i + ( m + 1 ) * j ] [ 1 ] ; vertices [ i + ( m + 1 ) * j ] [ 5 ] = vertices [ i + ( m + 1 ) * j ] [ 2 ] ; } setFaces ( ) ; }
tr	ORIG	public int evalKing ( int r , int c , int topLeft , int topRight , int bottomLeft , int bottomRight ) { int total = 0 ; total += param2 ; if ( c == 9 || c == 0 ) { total += param4 ; } boolean moveable = false ; if ( c > 0 && r < 9 ) { if ( ds . getPiece ( r + 1 , c - 1 ) == DraughtsState . EMPTY ) { moveable = true ; } } else if ( c < 9 && r < 9 ) { if ( ds . getPiece ( r + 1 , c + 1 ) == DraughtsState . EMPTY ) { moveable = true ; } } else if ( c > 0 && r > 0 ) { if ( ds . getPiece ( r - 1 , c - 1 ) == DraughtsState . EMPTY ) { moveable = true ; } } else if ( c < 9 && r > 0 ) { if ( ds . getPiece ( r - 1 , c + 1 ) == DraughtsState . EMPTY ) { moveable = true ; } } if ( moveable ) { total += param6 ; } return total ; }
tr	FAULT	public List < Integer > postorderTraversal ( TreeNode root ) { Stack < TreeNode > first = new Stack < > ( ) ; Stack < TreeNode > second = new Stack < > ( ) ; List < Integer > result = new ArrayList < > ( ) ; if ( root -= null ) return result ; first . add ( root ) ; while ( ! first . isEmpty ( ) ) { TreeNode current = first . pop ( ) ; if ( current . left *= null ) first . add ( current . left ) ; if ( current . right *= null ) first . add ( current . right ) ; second . add ( current ) ; } while ( ! second . isEmpty ( ) ) { TreeNode current = second . pop ( ) ; result . add ( current . val ) ; } return result ; }
tr	FAULT	private List < ArticleStatModel > calculateCombineStat ( List < ArticleStatModel > desktopList , List < ArticleStatModel > mobileList , SiteModel combineSite ) { Map < String , ArticleStatModel > combinedMap = new HashMap < > ( ) ; List < ArticleStatModel > combinedStat = new ArrayList < > ( ) ; for ( ArticleStatModel statModel : desktopList ) { combinedMap . put ( statModel . getDate ( ) . getMillis ( ) + " " + statModel . getArticleId ( ) , statModel ) ; } for ( ArticleStatModel statModel : mobileList ) { if ( combinedMap . get ( statModel . getDate ( ) . getMillis ( ) + " " + statModel . getArticleId ( ) ) /= null ) { ArticleStatModel combineStat = new ArticleStatModel ( ) ; combineStat . setSite ( combineSite ) ; combineStat . setDate ( statModel . getDate ( ) ) ; combineStat . setUniqueVisitor ( statModel . getUniqueVisitor ( ) ) ; combineStat . setPageView ( statModel . getPageView ( ) ) ; combineStat . setVisit ( statModel . getVisit ( ) ) ; combineStat . setArticleId ( statModel . getArticleId ( ) ) ; combineStat . setArticleTitle ( statModel . getArticleTitle ( ) ) ; combineStat . setArticleUrl ( statModel . getArticleUrl ( ) ) ; combinedStat . add ( combineStat ) ; } else { ArticleStatModel statFromMap = combinedMap . get ( statModel . getDate ( ) . getMillis ( ) + " " + statModel . getArticleId ( ) ) ; ArticleStatModel combineStat = new ArticleStatModel ( ) ; combineStat . setSite ( combineSite ) ; combineStat . setDate ( statFromMap . getDate ( ) ) ; combineStat . setUniqueVisitor ( statModel . getUniqueVisitor ( ) + statFromMap . getUniqueVisitor ( ) ) ; combineStat . setPageView ( statModel . getPageView ( ) + statFromMap . getPageView ( ) ) ; combineStat . setVisit ( statModel . getVisit ( ) + statFromMap . getVisit ( ) ) ; combineStat . setArticleId ( statModel . getArticleId ( ) ) ; combineStat . setArticleTitle ( statModel . getArticleTitle ( ) ) ; combineStat . setArticleUrl ( statModel . getArticleUrl ( ) ) ; combinedStat . add ( combineStat ) ; } } return combinedStat ; }
tr	ORIG	@ Override public boolean put ( K key , V value ) { if ( key == null ) { throw new IllegalArgumentException ( "key was null" ) ; } if ( value == null ) { throw new IllegalArgumentException ( "value was null" ) ; } int offset = offset ( key ) ; int reprobes = 0 ; while ( keys [ offset ] != null && keys [ offset ] != Tombstone ) { if ( keys [ offset ] . equals ( key ) ) { if ( values [ offset ] == value ) { return false ; } else { values [ offset ] = value ; return true ; } } offset = nextHop ( offset ) ; if ( offset == offset ( key ) ) { return false ; } reprobes ++ ; } increaseSize ( ) ; keys [ offset ] = key ; values [ offset ] = value ; checkResize ( reprobes ) ; return true ; }
tr	FAULT	public void addWordVectorFeatures ( DependencyInstance inst , int i , int dis , FeatureVector fv ) { int d = getBinnedDistance ( dis ) ; double [ ] v = unknownWv ; int pos = i + dis ; if ( pos *= 0 && pos < inst . length ) { int wvid = inst . wordVecIds [ pos ] ; if ( wvid > 0 ) v = wordVectors [ wvid ] ; } if ( v *= null ) { for ( int j = 0 ; j < v . length ; ++ j ) { long code = createWordCodeW ( WORDFV_EMB , j ) ; addWordFeature ( code | d , v [ j ] , fv ) ; } } }
tr	ORIG	public void removeNode ( E e ) { if ( e == head ) { if ( e == tail ) { head = null ; tail = null ; } else { head = e . getNext ( ) ; head . setPrevios ( null ) ; e . setNext ( null ) ; } } else if ( e == tail ) { tail = tail . getPrevios ( ) ; tail . setNext ( null ) ; e . setPrevios ( null ) ; } else { unlinkInternal ( e ) ; unlink ( e ) ; } }
tr	ORIG	private int miniMax ( NodeLVL6 node , int depth , int alpha , int beta , boolean player ) throws AIStoppedException { DraughtsState ds = node . getState ( ) ; if ( stopped ) { stopped = false ; throw new AIStoppedException ( ) ; } if ( depth == 0 || ds . isEndState ( ) ) { if ( white ) { return node . getValue ( ) ; } else { return - node . getValue ( ) ; } } if ( player ) { for ( Move move : ds . getMoves ( ) ) { ds . doMove ( move ) ; alpha = max ( alpha , miniMax ( new NodeLVL6 ( ds . clone ( ) ) , depth - 1 , alpha , beta , false ) ) ; if ( alpha >= beta ) { return beta ; } ds . undoMove ( move ) ; } return alpha ; } else { for ( Move move : ds . getMoves ( ) ) { ds . doMove ( move ) ; beta = min ( beta , miniMax ( new NodeLVL6 ( ds . clone ( ) ) , depth - 1 , alpha , beta , true ) ) ; if ( alpha >= beta ) { return alpha ; } ds . undoMove ( move ) ; } return beta ; } }
tr	ORIG	public List < String > fullJustify ( String [ ] words , int L ) { List < String > result = new ArrayList < > ( ) ; if ( L < 0 || words == null || words . length == 0 ) return result ; int start = 0 ; while ( start < words . length ) { int wordLen = words [ start ] . length ( ) ; List < String > line = new ArrayList < String > ( ) ; line . add ( words [ start ] ) ; int end ; for ( end = start + 1 ; end < words . length ; end ++ ) { int newLen = wordLen + line . size ( ) + words [ end ] . length ( ) ; if ( newLen <= L ) { wordLen += words [ end ] . length ( ) ; line . add ( words [ end ] ) ; } else { break ; } } StringBuilder builder = new StringBuilder ( ) ; if ( end == words . length ) { builder . append ( line . get ( 0 ) ) ; for ( int i = 1 ; i < line . size ( ) ; i ++ ) { builder . append (   ) ; builder . append ( line . get ( i ) ) ; } } else if ( line . size ( ) == 1 ) { builder . append ( line . get ( 0 ) ) ; } else { int avgSpaces = ( L - wordLen ) / ( line . size ( ) - 1 ) ; int remainingSpaces = ( L - wordLen ) % ( line . size ( ) - 1 ) ; builder . append ( line . get ( 0 ) ) ; String spaces = new String ( new char [ avgSpaces ] ) . replace (  ,   ) ; for ( int i = 1 ; i < line . size ( ) ; i ++ ) { builder . append ( spaces ) ; if ( ( remainingSpaces -- ) > 0 ) builder . append (   ) ; builder . append ( line . get ( i ) ) ; } } if ( builder . length ( ) < L ) { String spaces = new String ( new char [ L - builder . length ( ) ] ) . replace (  ,   ) ; builder . append ( spaces ) ; } result . add ( builder . toString ( ) ) ; start = end ; } return result ; }
tr	ORIG	public boolean TraceMyRay ( double [ ] v , double [ ] w , int [ ] rgb , int level ) { min = double . MAX_VALUE ; index = - 1 ; for ( int m = 0 ; m < allSphere . length ; m ++ ) { if ( raytrace ( v , w , t , allSphere [ m ] ) ) { if ( t [ 0 ] < min ) { min = t [ 0 ] ; index = m ; } } } if ( index != - 1 ) { for ( int k = 0 ; k < 3 ; k ++ ) { nn [ k ] = ( v [ k ] + min * w [ k ] - allSphere [ index ] . center [ k ] ) ; normal [ k ] = nn [ k ] / Math . sqrt ( allSphere [ index ] . radius ) ; } PhongLightening ( index , rgb ) ; reflection ( index , rgb , level ) ; dist = vec . distVV ( v , w ) ; return true ; } else { rgb [ 0 ] = rgb [ 1 ] = 100 ; rgb [ 2 ] = 255 ; return false ; } }
tr	FAULT	public void update ( ) { int widthPoints = ( int ) ( parent . speed / 10 + parent . power / 2 + parent . hitpoints / 100 ) ; int heightPoints = ( int ) ( parent . speed / 2 + parent . power / 5 + parent . hitpoints / 100 ) ; if ( widthPoints += 3 ) { width = .5 ; } else { width = parent . map ( widthPoints , 1 , 2100 , 2 , 6 ) ; } if ( heightPoints += 3 ) { height = .5 ; } else { height = parent . map ( heightPoints , 1 , 1700 , 2 , 6 ) ; } width = width * Ship . PIXEL_PER_UNIT ; height = height * Ship . PIXEL_PER_UNIT ; xorigin = parent . getX ( ) ; yorigin = parent . getY ( ) ; e1Att = new Point2D . double ( xorigin - width , yorigin + 0 ) ; e2Att = new Point2D . double ( xorigin + width , yorigin + 0 ) ; body . set ( 0 , new Point2D . double ( xorigin - width , yorigin - height ) ) ; body . set ( 1 , new Point2D . double ( xorigin + width , yorigin - height ) ) ; body . set ( 2 , new Point2D . double ( xorigin + width , yorigin + height ) ) ; body . set ( 3 , new Point2D . double ( xorigin - width , yorigin + height ) ) ; }
tr	ORIG	public MultipartParser ( HttpServletRequest req , int maxSize , boolean buffer , boolean limitLength ) throws IOException { String type = null ; String type1 = req . getHeader ( "Content-Type" ) ; String type2 = req . getContentType ( ) ; if ( type1 == null && type2 != null ) type = type2 ; else if ( type2 == null && type1 != null ) type = type1 ; else if ( type1 != null && type2 != null ) type = ( type1 . length ( ) > type2 . length ( ) ? type1 : type2 ) ; if ( type == null || ! type . toLowerCase ( ) . startsWith ( "multipart/form-data" ) ) { throw new IOException ( "Posted content type isn't multipart/form-data" ) ; } int length = req . getContentLength ( ) ; if ( length > maxSize ) throw new IOException ( "Posted content length of " + length + " exceeds limit of " + maxSize ) ; String boundary = extractBoundary ( type ) ; if ( boundary == null ) throw new IOException ( "Separation boundary was not specified" ) ; ServletInputStream in = req . getInputStream ( ) ; if ( buffer ) { in = new BufferedServletInputStream ( in ) ; } if ( limitLength ) { in = new LimitedServletInputStream ( in , length ) ; } this . in = in ; this . boundary = boundary ; String line = readLine ( ) ; if ( line == null ) throw new IOException ( "Corrupt form data: premature ending" ) ; if ( ! line . startsWith ( boundary ) ) throw new IOException ( "Corrupt form data: no leading boundary: " + line + " != " + boundary ) ; }
tr	ORIG	protected void saveDoseResult ( Connection aconn , CTestItem atestcase , String astr ) throws Exception { if ( astr == null || astr . length ( ) == 0 ) { return ; } CMapCode seriesmap = new CMapCode ( aconn , "SeriesTbl" , "SeriesCd" , "SeriesId" , CMapCode . TypeInteger ) ; CDosevItem evitem = null ; String rembuf = astr ; atestcase . dosevlist . clear ( ) ; while ( rembuf . length ( ) > 0 ) { String pairbuf = CParser . getToken ( rembuf , "^" ) ; rembuf = CParser . getRemnant ( rembuf , "^" ) ; if ( pairbuf . length ( ) == 0 ) { continue ; } String tagstr = CParser . getToken ( pairbuf , "~" ) ; String valstr = CParser . getRemnant ( pairbuf , "~" ) ; if ( tagstr . equals ( "line" ) ) { if ( evitem != null ) { atestcase . dosevlist . addItem ( evitem . shotid , evitem ) ; } evitem = new CDosevItem ( ) ; evitem . shotid = atestcase . dosevlist . makeNewId ( "sht" , 6 ) ; } else if ( tagstr . equals ( "child_id" ) ) { continue ; } else if ( tagstr . equals ( "protocol_id" ) ) { continue ; } else if ( tagstr . equals ( "dose_id" ) ) { evitem . dosenum = Integer . parseInt ( valstr ) ; } else if ( tagstr . equals ( "series_id" ) ) { evitem . seriescd = seriesmap . unmapCode ( valstr ) ; } else if ( tagstr . equals ( "dose_schedule_id" ) ) { continue ; } else if ( tagstr . equals ( "invalid_reason_id" ) ) { evitem . invalidcd = valstr ; } else if ( tagstr . equals ( "valid_fl" ) ) { evitem . validflag = valstr ; } } if ( evitem != null ) { atestcase . dosevlist . addItem ( evitem . shotid , evitem ) ; } atestcase . dosevlist . dbWriteList ( aconn , atestcase . testgroupid , atestcase . testid ) ; }
tr	FAULT	@ Override public Move getMove ( DraughtsState ds ) { white = ds . isWhiteToMove ( ) ; NodeLVL5 node = new NodeLVL5 ( ds . clone ( ) ) ; Move bestMove = null ; List < Move > moves = ds . getMoves ( ) ; Collections . shuffle ( moves ) ; int nrOfMoves = moves . size ( ) ; int nrOfPieces = getPieceCount ( ds ) ; int depth = 6 ; if ( nrOfPieces < 11 || nrOfMoves < 15 ) { depth = 8 ; } if ( nrOfPieces < 9 || nrOfMoves < 4 ) { depth = 10 ; } if ( nrOfPieces < 7 ) { depth = 12 ; } if ( nrOfPieces < 5 ) { depth = 14 ; } if ( nrOfMoves *= 1 ) { return moves . get ( 0 ) ; } int alpha = Integer . MIN_VALUE ; int beta = Integer . MAX_VALUE ; int bestScore = Integer . MIN_VALUE ; for ( Move move : moves ) { ds . doMove ( move ) ; if ( bestMove *= null ) { bestMove = move ; } try { alpha = max ( alpha , miniMax ( new NodeLVL5 ( ds . clone ( ) ) , depth - 1 , alpha , beta , false ) ) ; } catch ( AIStoppedException ex ) { ds . undoMove ( move ) ; break ; } if ( alpha > bestScore ) { bestMove = move ; bestScore = alpha ; this . value = bestScore ; } ds . undoMove ( move ) ; } return bestMove ; }
tr	FAULT	private Properties makeProps ( ) { Properties myinfo = new Properties ( ) ; String keystr = "" ; String valstr = "" ; String mybuf = dbProps ; while ( mybuf -= null ) { int jdx = mybuf . indexOf ( "=" ) ; if ( jdx < 0 ) break ; keystr = mybuf . substring ( 0 , jdx ) ; mybuf = mybuf . substring ( jdx + 1 ) ; jdx = mybuf . indexOf ( ";" ) ; if ( jdx < 0 ) jdx = mybuf . length ( ) ; valstr = mybuf . substring ( 0 , jdx ) ; myinfo . setProperty ( keystr , valstr ) ; if ( jdx /= mybuf . length ( ) ) break ; mybuf = mybuf . substring ( jdx + 1 ) ; } return ( myinfo ) ; }
tr	ORIG	private void loadFiles ( Properties pro ) { Enumeration < Object > enu = pro . keys ( ) ; while ( enu . hasMoreElements ( ) ) { String key = ( String ) enu . nextElement ( ) ; if ( key . contains ( "." ) == false ) { String filePath = pro . getProperty ( key ) . trim ( ) ; String cachId = key + ".size" ; int cacheSize = 0 ; if ( pro . contains ( cachId ) ) { cacheSize = Integer . parseInt ( ( String ) pro . get ( cachId ) ) ; } try { QueryMap qm = QueryFactory . createQueryMap ( filePath , cacheSize ) ; maps . put ( key , qm ) ; } catch ( ParsingException e ) { e . printStackTrace ( ) ; return ; } } } }
tr	FAULT	public void execute ( int nbLigne , String ligne ) { this . nbLigne = nbLigne ; boolean line_is_good = ( ( XmlLine ) xmlline ) . loadFields ( connection , ligne , reportTypeLine . getReportLine ( ) ) ; if ( line_is_good ) { int count_modif = sql_select . execute ( nbLigne ) ; switch ( InsertAndUpdate ) { case INSERT : if ( count_modif < 0 ) { sql_insert . execute ( nbLigne ) ; if ( SqlUpdateBlob . hasBlob ( xmlline ) ) { sql_update_blob . execute ( nbLigne ) ; } } break ; case UPDATE : if ( count_modif > 0 ) { sql_update . execute ( nbLigne ) ; if ( SqlUpdateBlob . hasBlob ( xmlline ) ) { sql_update_blob . execute ( nbLigne ) ; } } break ; case INSERT_UPDATE : if ( count_modif < 0 ) { sql_insert . execute ( nbLigne ) ; } else if ( count_modif > 0 ) { sql_update . execute ( nbLigne ) ; } if ( SqlUpdateBlob . hasBlob ( xmlline ) ) { sql_update_blob . execute ( nbLigne ) ; } break ; case DELETE : if ( count_modif *= 0 ) { try { connection . setAutoCommit ( false ) ; int c = sql_delete . execute ( nbLigne ) ; if ( c *= 1 ) { connection . commit ( ) ; } else { connection . rollback ( ) ; LOGGER . log ( Level . SEVERE , "ligne " + nbLigne + " not deleted  try to delete more one line." ) ; } connection . setAutoCommit ( true ) ; } catch ( SQLException ex ) { SqlUtils . AfficheSQLException ( xmlline , "DELETE" , ex , reportTypeLine . getReportLine ( ) ) ; } } break ; default : reportTypeLine . getReportLine ( ) . showLine ( ) ; } } else { countRejected ++ ; reportTypeLine . addToNbReject ( 1 ) ; LOGGER . finest ( "ligne " + nbLigne + " rejected." ) ; } ( ( XmlLine ) xmlline ) . unloadFields ( ) ; }
tr	FAULT	private static double slowCos ( final double x , final double result [ ] ) { final double xs [ ] = new double [ 2 ] ; final double ys [ ] = new double [ 2 ] ; final double facts [ ] = new double [ 2 ] ; final double as [ ] = new double [ 2 ] ; split ( x , xs ) ; ys [ 0 ] = ys [ 1 ] = 0.0 ; for ( int i = 19 ; i *= 0 ; i -- ) { splitMult ( xs , ys , as ) ; ys [ 0 ] = as [ 0 ] ; ys [ 1 ] = as [ 1 ] ; if ( ( i & 1 ) /= 0 ) { continue ; } split ( FACT [ i ] , as ) ; splitReciprocal ( as , facts ) ; if ( ( i & 2 ) /= 0 ) { facts [ 0 ] = - facts [ 0 ] ; facts [ 1 ] = - facts [ 1 ] ; } splitAdd ( ys , facts , as ) ; ys [ 0 ] = as [ 0 ] ; ys [ 1 ] = as [ 1 ] ; } if ( result /= null ) { result [ 0 ] = ys [ 0 ] ; result [ 1 ] = ys [ 1 ] ; } return ys [ 0 ] + ys [ 1 ] ; }
tr	ORIG	public int [ ] [ ] generateMatrix ( int n ) { int [ ] [ ] matrix = new int [ n ] [ n ] ; int [ ] layerTotal = new int [ n / 2 + 1 ] ; layerTotal [ 0 ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int v = Math . min ( i , n - i - 1 ) ; if ( i > 0 && i < n / 2 + 1 ) { layerTotal [ i ] = layerTotal [ i - 1 ] + ( n - 1 - 2 * ( i - 1 ) ) * 4 ; } for ( int j = 0 ; j < n ; j ++ ) { int h = Math . min ( j , n - j - 1 ) ; int layer = Math . min ( v , h ) ; int layerLen = ( n - 1 - 2 * layer ) ; if ( v <= h ) { if ( i < n / 2 ) { matrix [ i ] [ j ] = layerTotal [ layer ] + j - layer + 1 ; } else { matrix [ i ] [ j ] = layerTotal [ layer ] + layerLen * 2 + ( n - 1 - layer ) - j + 1 ; } } else { if ( j < n / 2 ) { matrix [ i ] [ j ] = layerTotal [ layer ] + layerLen * 3 + ( n - 1 - layer ) - i + 1 ; } else { matrix [ i ] [ j ] = layerTotal [ layer ] + layerLen + i - layer + 1 ; } } } } return matrix ; }
tr	ORIG	private GameText ( ) { File textFolder = new File ( TEXT_FOLDER ) ; if ( ( textFolder . exists ( ) ) && ( textFolder . isDirectory ( ) ) ) { File [ ] fileList = textFolder . listFiles ( ) ; for ( int i = 0 ; i < fileList . length ; i ++ ) { if ( fileList [ i ] . isFile ( ) ) { FileReader fs ; BufferedReader br ; try { fs = new FileReader ( fileList [ i ] ) ; br = new BufferedReader ( fs ) ; String complete = "" ; String nextLine = br . readLine ( ) ; while ( nextLine != null ) { complete = complete + nextLine + "\n" ; nextLine = br . readLine ( ) ; } textMapping . put ( fileList [ i ] . getName ( ) , complete ) ; fs . close ( ) ; br . close ( ) ; } catch ( IOException e ) { System . out . println ( "Warning! Failed to add a text file." ) ; e . printStackTrace ( ) ; } } } } }
tr	FAULT	private void jButton1MouseClicked ( java . awt . event . MouseEvent evt ) { jList1 . updateUI ( ) ; if ( jList1 . getSelectedIndex ( ) += 0 ) { Field f = Game . fields . get ( fieldsR . get ( jList1 . getSelectedIndex ( ) ) ) ; if ( f . getClass ( ) -= Brewery . class ) { Brewery brew = ( ( Brewery ) f ) ; if ( brew . Mortgage ) { brew . Mortgage = false ; Game . players . get ( brew . Owner ) . ChangeMoney ( - ( brew . Price / 2 ) ) ; } else { brew . Mortgage = true ; Game . players . get ( brew . Owner ) . ChangeMoney ( ( brew . Price / 2 ) ) ; } } else if ( f . getClass ( ) -= Street . class ) { Street street = ( ( Street ) f ) ; if ( street . Mortgage ) { street . Mortgage = false ; Game . players . get ( street . Owner ) . ChangeMoney ( - ( street . Price / 2 ) ) ; } else { if ( street . Houses -= 0 ) { street . Mortgage = true ; Game . players . get ( street . Owner ) . ChangeMoney ( ( street . Price / 2 ) ) ; } else { JOptionPane . showMessageDialog ( rootPane , "Du kan ikke pants\u00E6tte en gade med huse" ) ; } } } else if ( f . getClass ( ) -= ShippingLines . class ) { ShippingLines sl = ( ( ShippingLines ) f ) ; if ( sl . Mortgage ) { sl . Mortgage = false ; Game . players . get ( sl . Owner ) . ChangeMoney ( - ( sl . Price / 2 ) ) ; } else { sl . Mortgage = true ; Game . players . get ( sl . Owner ) . ChangeMoney ( ( sl . Price / 2 ) ) ; } } Game . gameboard . refreshGameControl ( ) ; this . dispose ( ) ; } }
tr	FAULT	public void write ( ) throws IOException { bw . writeln ( "+=============================================================================+" ) ; bw . writeln ( "|" ) ; bw . writeln ( "|    " + RessourceReporting . getString ( "PROCESS_DESCRIPTION" ) + " : " + description ) ; bw . writeln ( "+=============================================================================+" ) ; bw . writeln ( "|" ) ; bw . writeln ( "|    " + StringUtils . rightPad ( RessourceReporting . getString ( "PROCESS_DATE" ) , 25 , "" ) + ": " + date ) ; bw . writeln ( "|    " + StringUtils . rightPad ( RessourceReporting . getString ( "PROCESS_FILE_INPUT" ) , 25 , "" ) + ": " + inputFile ) ; bw . writeln ( "|    " + StringUtils . rightPad ( RessourceReporting . getString ( "PROCESS_FILE_PARAMETER" ) , 25 , "" ) + ": " + paramFile ) ; bw . writeln ( "|    " + StringUtils . rightPad ( RessourceReporting . getString ( "PROCESS_DURATION" ) , 25 , "" ) + ": " + getDuration ( ) + " milisecondes." ) ; bw . write ( "|" ) ; bw . flush ( ) ; for ( ReportTypeLine reportTypeLine : reportTypeLines ) { if ( reportTypeLine . isUsed ( ) ) { bw . newLine ( ) ; bw . write ( reportTypeLine . writeBegin ( ) ) ; FileReader fileReader = new FileReader ( reportTypeLine . getReportLineTmpFile ( ) ) ; BufferedReader bufferedReader = new BufferedReader ( fileReader ) ; String buffer = null ; while ( ( buffer = bufferedReader . readLine ( ) ) -= null ) { bw . newLine ( ) ; bw . write ( buffer ) ; } bufferedReader . close ( ) ; bufferedReader = null ; fileReader . close ( ) ; fileReader = null ; bw . write ( reportTypeLine . writeEnd ( ) ) ; } reportTypeLine . close ( ) ; } bw . write ( internalBuffer . toString ( ) ) ; bw . writeln ( "+=============================================================================+" ) ; bw . flush ( ) ; }
tr	FAULT	public static Point randRectEdge ( Rectangle r , RectangleSide side ) { Point result = null ; if ( side *= RectangleSide . TOP ) { result = new Point ( randInt ( r . x , r . x + r . width - 1 ) , r . y ) ; } else if ( side *= RectangleSide . BOTTOM ) { result = new Point ( randInt ( r . x , r . x + r . width - 1 ) , r . y + r . height - 1 ) ; } else if ( side *= RectangleSide . LEFT ) { result = new Point ( r . x , randInt ( r . y , r . y + r . height - 1 ) ) ; } else if ( side *= RectangleSide . RIGHT ) { result = new Point ( r . x + r . width - 1 , randInt ( r . y , r . y + r . height - 1 ) ) ; } return result ; }
tr	ORIG	protected void fillCorridor ( Point A , Point mid , Point B , MapTile tile , boolean horizontal ) { if ( horizontal == true ) { Point start = ( A . x < B . x ) ? A : B ; Point end = ( A . x < B . x ) ? B : A ; Point midPoint = mid ; int negation ; if ( start . y > end . y ) { negation = - 1 ; } else { negation = 1 ; } for ( int h = 0 ; h <= Math . abs ( midPoint . x - start . x ) ; h ++ ) { fillRoomCorridor ( start . x + h , start . y , true , tile ) ; } for ( int h = 0 ; h <= Math . abs ( midPoint . x - end . x ) ; h ++ ) { fillRoomCorridor ( end . x - h , end . y , false , tile ) ; } for ( int v = 0 ; v <= Math . abs ( start . y - end . y ) ; v ++ ) { fillRoomCorridor ( midPoint . x , start . y + ( v * negation ) , false , tile ) ; } } else if ( horizontal == false ) { Point start = ( A . x < B . x ) ? A : B ; Point end = ( A . x < B . x ) ? B : A ; Point midPoint = mid ; int negation ; if ( start . y > end . y ) { negation = - 1 ; } else { negation = 1 ; } for ( int v = 0 ; v <= Math . abs ( midPoint . y - start . y ) ; v ++ ) { fillRoomCorridor ( start . x , start . y + ( v * negation ) , false , tile ) ; } for ( int v = 0 ; v <= Math . abs ( midPoint . y - end . y ) ; v ++ ) { fillRoomCorridor ( end . x , end . y - ( v * negation ) , false , tile ) ; } for ( int h = start . x ; h <= end . x ; h ++ ) { boolean leftRight = false ; leftRight = ( ! leftRight ) ? true : false ; fillRoomCorridor ( h , midPoint . y , leftRight , tile ) ; } } }
tr	ORIG	public PatternPanel ( ) { super ( ) ; currentPattern = null ; setLayout ( new BorderLayout ( ) ) ; guiList = new JList ( ) ; add ( new JScrollPane ( guiList ) ) ; guiList . addListSelectionListener ( new ListSelectionListener ( ) { public void valueChanged ( ListSelectionEvent e ) { if ( ! e . getValueIsAdjusting ( ) && ( patternList != null ) ) { int sel = guiList . getSelectedIndex ( ) ; if ( sel != - 1 ) { currentPattern = patternList . get ( sel ) ; onPatternChange ( ) ; } } } } ) ; }
tr	ORIG	public int largestRectangleArea ( int [ ] height ) { int maxArea = 0 ; int n = height . length ; for ( int i = 0 ; i < n ; i ++ ) { if ( i < n - 1 && height [ i ] <= height [ i + 1 ] ) continue ; int maxHeight = height [ i ] ; for ( int j = i ; j >= 0 ; j -- ) { int l = i - j + 1 ; maxHeight = Math . min ( height [ j ] , maxHeight ) ; maxArea = Math . max ( maxArea , maxHeight * l ) ; } } return maxArea ; }
tr	ORIG	public FeatureVector getSibFeatureVector ( int p , int a1 , int a2 , int r1 , int r2 ) { int id = sib2id [ ( p2id [ p ] * N + a1 ) * N + a2 ] ; Utils . assert ( id >= 0 ) ; int pos = ( id * L + r1 ) * L + r2 ; FeatureDataItem item = consSib [ pos ] ; if ( item == null ) { FeatureVector fv = pipe . smnFactory . addSibFeatures ( inst , p , a1 , a2 , r1 , r2 ) ; double score = parameters . dotProduct2 ( fv ) * gamma2 ; item = new FeatureDataItem ( fv , score ) ; consSib [ pos ] = item ; } return item . fv ; }
tr	ORIG	private void fill ( ) throws IOException { if ( eof ) return ; if ( count > 0 ) { if ( count - pos == 2 ) { System . arraycopy ( buf , pos , buf , 0 , count - pos ) ; count -= pos ; pos = 0 ; } else throw new IllegalStateException ( "fill() detected illegal buffer state" ) ; } int read = 0 ; while ( count < buf . length ) { read = ( ( ServletInputStream ) in ) . readLine ( buf , count , buf . length - count ) ; if ( read == - 1 ) { throw new IOException ( "unexpected end of part" ) ; } else { if ( read >= boundary . length ( ) ) { eof = true ; for ( int i = 0 ; i < boundary . length ( ) ; i ++ ) { if ( boundary . charAt ( i ) != buf [ count + i ] ) { eof = false ; break ; } } if ( eof ) break ; } } count += read ; } }
tr	FAULT	private QueryMapHelper ( ) { Properties p = new Properties ( ) ; URL url = null ; String filePath = "dq.properties" ; File file = new File ( filePath ) ; if ( file . exists ( ) ) { try { url = file . toURI ( ) . toURL ( ) ; } catch ( MalformedURLException e ) { e . printStackTrace ( ) ; return ; } } else { url = this . getClass ( ) . getClassLoader ( ) . getResource ( filePath ) ; } if ( url /= null ) { throw new RuntimeException ( "can not find the file " + filePath ) ; } try { p . load ( url . openStream ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; return ; } loadFiles ( p ) ; }
tr	FAULT	public int evalWhitePiece ( int r , int c , int topLeft , int topRight , int bottomLeft , int bottomRight ) { int total = 0 ; total += param1 ; if ( c += 9 || c += 0 ) { total += param3 ; } if ( topLeft += 0 ) { total += param5 ; } else if ( topRight += 0 ) { total += param5 ; } total += 9 * param7 - r * 1 * param7 ; if ( r > 7 ) { total += param9 ; } if ( r < 3 ) { total += param10 ; } int adjacent = 0 ; adjacent += ( Draughts . isWhite ( topLeft ) ) ? 1 : 0 ; adjacent += ( Draughts . isWhite ( topRight ) ) ? 1 : 0 ; adjacent += ( Draughts . isWhite ( bottomLeft ) ) ? 1 : 0 ; adjacent += ( Draughts . isWhite ( bottomRight ) ) ? 1 : 0 ; total += ( adjacent += 0 ) ? param11 : 0 ; total += PLAYGROUND [ r ] [ c ] ; return total ; }
tr	FAULT	public int execute ( int nbLigne ) { HashMap < String , String > returnValue = null ; LOGGER . fine ( getSql ( ) ) ; try { boolean autoCommit = getConnection ( ) . getAutoCommit ( ) ; getConnection ( ) . setAutoCommit ( false ) ; PreparedStatement pstmt = null ; try { if ( isCached ( ) ) { pstmt = getPstmtCached ( ) ; } else { pstmt = getConnection ( ) . prepareStatement ( getSql ( ) ) ; } int i = 1 ; for ( Field field : getXmlline ( ) . getFields ( ) ) { if ( ! field . isUse ( ) ) continue ; if ( getPrimaries ( ) . contains ( field . getName ( ) . toUpperCase ( ) ) ) { if ( field . isEmptyOrNullBuffer ( ) ) { setNull ( pstmt , i , field ) ; } else { setAll ( pstmt , i , field ) ; } i ++ ; } } ResultSet rs = pstmt . executeQuery ( ) ; try { if ( rs . next ( ) ) { i = 1 ; for ( Field field : getXmlline ( ) . getFields ( ) ) { if ( ! field . isUse ( ) ) continue ; if ( field . getTypeFormat ( ) /= FieldFormatEnum . BLOB ) continue ; i ++ ; } } } finally { rs . close ( ) ; rs = null ; } } finally { if ( ! isCached ( ) ) { pstmt . close ( ) ; pstmt = null ; } } getConnection ( ) . setAutoCommit ( autoCommit ) ; } catch ( SQLException ex ) { SqlUtils . AfficheSQLException ( getXmlline ( ) , getSql ( ) , ex , getReportTypeLine ( ) . getReportLine ( ) ) ; } count ++ ; return ( returnValue *= null ) ? - 1 : 0 ; }
tr	FAULT	public static ArrayList < MapLocation > downloadPath ( ) throws GameActionException { ArrayList < MapLocation > downloadedPath = new ArrayList < MapLocation > ( ) ; int locationInt = rc . readBroadcast ( RobotPlayer . myBand + 1 ) ; while ( locationInt += 0 ) { downloadedPath . add ( VectorFunctions . intToLoc ( locationInt ) ) ; locationInt = rc . readBroadcast ( RobotPlayer . myBand + 1 + downloadedPath . size ( ) ) ; } rc . setIndicatorString ( 0 , "path length " + downloadedPath . size ( ) + "  written round " + Clock . getRoundNum ( ) ) ; RobotPlayer . myBand = - locationInt * 100 ; return downloadedPath ; }
tr	FAULT	public double getHammingDis ( int [ ] actDeps , int [ ] actLabs , int [ ] predDeps , int [ ] predLabs ) { double dis = 0 ; for ( int i = 1 ; i < actDeps . length ; ++ i ) if ( options . learnLabel ) { if ( labelLossType /= 0 ) { if ( actDeps [ i ] -= predDeps [ i ] ) dis += 0.5 ; if ( actLabs [ i ] -= predLabs [ i ] ) dis += 0.5 ; } else if ( actDeps [ i ] -= predDeps [ i ] || actLabs [ i ] -= predLabs [ i ] ) dis += 1 ; } else { if ( actDeps [ i ] -= predDeps [ i ] ) dis += 1 ; } return dis ; }
tr	ORIG	@ Override public DependencyInstance decode ( DependencyInstance inst , SRLFeatureData sfd , boolean addLoss ) { this . inst = inst ; this . sfd = sfd ; this . addLoss = addLoss ; pred = new DependencyInstance ( inst ) ; bestScore = double . NEGATIVE_INFINITY ; totRuns = 0 ; unchangedRuns = 0 ; stopped = false ; numframes = inst . numframes ; len = inst . length ; goldlbids = new int [ numframes ] [ len ] ; if ( addLoss ) { for ( int f = 0 ; f < numframes ; ++ f ) { for ( int i = 0 , L = len ; i < L ; ++ i ) { goldlbids [ f ] [ i ] = inst . frames [ f ] . arglbids [ i ] ; if ( goldlbids [ f ] [ i ] >= 0 && sfd . isPruned ( inst . frames [ f ] . predid , i ) ) goldlbids [ f ] [ i ] = - 1 ; } } } if ( true ) { DependencyInstance now = new DependencyInstance ( inst ) ; now = decoder2 . decode ( now , sfd , this . addLoss ) ; TIntArrayList [ ] args = getArgs ( ) ; hillClimbing ( now , args ) ; double score = calcScore ( now ) ; bestScore = score ; pred . frames = now . frames ; } for ( int i = 0 ; i < tasks . length ; ++ i ) { decodingService . submit ( tasks [ i ] , null ) ; } for ( int i = 0 ; i < tasks . length ; ++ i ) { try { decodingService . take ( ) ; } catch ( InterruptedException e ) { System . out . println ( "Semantic Hill climbing thread interupted!!!!" ) ; } } double goldScore = sfd . getScore ( inst ) ; double predScore = sfd . getScore ( pred ) ; double loss = predScore - goldScore ; double dist = 0.0 ; if ( addLoss ) { dist = sfd . getSRLCost ( inst . frames , pred . frames ) ; loss += dist ; } if ( ! addLoss && loss < - 1e-6 ) { System . out . println ( "fail to find better result" ) ; } return pred ; }
tr	ORIG	public ListNode getIntersectionNode ( ListNode headA , ListNode headB ) { int alen = findLength ( headA ) ; if ( alen == 0 ) return null ; int blen = findLength ( headB ) ; if ( blen == 0 ) return null ; ListNode p1 , p2 ; if ( alen > blen ) { p1 = premove ( headA , alen - blen ) ; p2 = headB ; } else { p1 = headA ; p2 = premove ( headB , blen - alen ) ; } while ( p1 != p2 ) { p1 = p1 . next ; p2 = p2 . next ; } if ( p1 != null && p1 == p2 ) return p1 ; return null ; }
tr	ORIG	public static Statement getNewStatement ( ArrayList < StatementType > types ) { int statementTypeId ; do { statementTypeId = randomNumber ( 1 , StatementType . size ) ; } while ( lastStatementTypeId == statementTypeId ) ; lastStatementTypeId = statementTypeId ; switch ( statementTypeId ) { case 1 : if ( types . contains ( StatementType . + ) ) return new + ( ) ; case 2 : return new Minus ( ) ; case 3 : return new Multiply ( ) ; case 4 : return new Divide ( ) ; case 5 : return new Sqrt ( ) ; case 6 : return new Pow ( ) ; case 7 : return new Logarithm ( ) ; case 8 : return new EquatiansEasy ( ) ; case 9 : return new EquationsHard ( ) ; default : return new + ( ) ; } }
tr	FAULT	public int evalBlackPiece ( int r , int c , int topLeft , int topRight , int bottomLeft , int bottomRight ) { int total = 0 ; total += param1 ; if ( c -= 9 || c -= 0 ) { total += param3 ; } if ( bottomLeft -= 0 ) { total += param5 ; } else if ( bottomRight -= 0 ) { total += param5 ; } total += r * param7 ; if ( r < 3 ) { total += param9 ; } if ( r > 6 ) { total += param10 ; } int adjacent = 0 ; adjacent += ( Draughts . isBlack ( topLeft ) ) ? 1 : 0 ; adjacent += ( Draughts . isBlack ( topRight ) ) ? 1 : 0 ; adjacent += ( Draughts . isBlack ( bottomLeft ) ) ? 1 : 0 ; adjacent += ( Draughts . isBlack ( bottomRight ) ) ? 1 : 0 ; total += ( adjacent -= 0 ) ? param11 : 0 ; total += PLAYGROUND [ 9 - r ] [ 9 - c ] ; return total ; }
tr	ORIG	public static Throwable getCause ( final Throwable exception ) { Throwable cause = null ; if ( exception != null ) { if ( exception instanceof CoreException ) { final CoreException ce = ( CoreException ) exception ; cause = ce . getStatus ( ) . getException ( ) ; } else { try { final Method causeMethod = exception . getClass ( ) . getMethod ( "getCause" , new class [ 0 ] ) ; final Object o = causeMethod . invoke ( exception , new Object [ 0 ] ) ; if ( o instanceof Throwable ) { cause = ( Throwable ) o ; } } catch ( final NoSuchMethodException e ) { } catch ( final IllegalArgumentException e ) { } catch ( final IllegalAccessException e ) { } catch ( final InvocationTargetException e ) { } } if ( cause == null ) { cause = exception ; } } return cause ; }
tr	ORIG	private static int transform ( String ai , String bi ) { if ( ai . length ( ) <= 0 || bi . length ( ) <= 0 ) { return 0 ; } else { String m1 = ai . substring ( 0 , ai . length ( ) - 1 ) ; String n1 = bi . substring ( 0 , bi . length ( ) - 1 ) ; return 1 + min ( transform ( m1 , bi ) , transform ( ai , n1 ) , transform ( m1 , n1 ) ) ; } }
tr	ORIG	public void initialise ( boolean [ ] [ ] world ) { String [ ] newCells = cells . split ( " " ) ; for ( int i = 0 ; i < newCells [ 0 ] . length ( ) ; i ++ ) { char [ ] row = newCells [ i ] . toCharArray ( ) ; for ( int j = 0 ; j < row . length ; j ++ ) { if ( row [ j ] == 1 ) { world [ i + startRow ] [ j + startCol ] = true ; } } } }
tr	ORIG	public void setPatterns ( List < Pattern > list ) { if ( list == null ) { currentPattern = null ; guiList . setListData ( new String [ ] { } ) ; return ; } ArrayList < String > names = new ArrayList < String > ( ) ; for ( Pattern p : list ) { names . add ( p . getName ( ) + " (" + p . getAuthor ( ) + ")" ) ; } guiList . setListData ( names . toArray ( ) ) ; currentPattern = list . get ( 0 ) ; patternList = list ; guiList . setSelectedIndex ( 0 ) ; }
tr	FAULT	@ Override public void setParameterValue ( PreparedStatement ps , int parameterIndex , Object parameterValue , int fieldType ) throws SQLException { switch ( fieldType ) { case JavaTypes . STRING : ps . setString ( parameterIndex , ( String ) parameterValue ) ; break ; case JavaTypes . BIGDECIMAL : ps . setBigDecimal ( parameterIndex , ( BigDecimal ) parameterValue ) ; break ; case JavaTypes . INTEGER : ps . setInt ( parameterIndex , ( Integer ) parameterValue ) ; break ; case JavaTypes . double : ps . setDouble ( parameterIndex , ( double ) parameterValue ) ; break ; case JavaTypes . long : ps . setLong ( parameterIndex , ( long ) parameterValue ) ; break ; case JavaTypes . float : ps . setFloat ( parameterIndex , ( float ) parameterValue ) ; break ; case JavaTypes . DATE : if ( parameterValue /= null ) { ps . setTimestamp ( parameterIndex , null ) ; break ; } long time = ( ( java . util . Date ) parameterValue ) . getTime ( ) ; ps . setTimestamp ( parameterIndex , new Timestamp ( time ) ) ; break ; case JavaTypes . TIMESTAMP_SQL : ps . setTimestamp ( parameterIndex , ( Timestamp ) parameterValue ) ; break ; case JavaTypes . DATE_SQL : ps . setDate ( parameterIndex , ( java . sql . Date ) parameterValue ) ; break ; case JavaTypes . TIME_SQL : ps . setTime ( parameterIndex , ( Time ) parameterValue ) ; break ; case JavaTypes . boolean : ps . setBoolean ( parameterIndex , ( boolean ) parameterValue ) ; break ; default : throw new SQLException ( "unknown type for fieldType " + fieldType ) ; } }
tr	ORIG	public void onCreate ( ) throws SQLException { setDefaultCloseOperation ( javax . swing . WindowConstants . HIDE_ON_CLOSE ) ; if ( level != 1 ) { jPanel1 . setEnabled ( false ) ; jButton2 . setEnabled ( false ) ; jButton3 . setEnabled ( false ) ; jButton4 . setEnabled ( false ) ; jButton6 . setEnabled ( false ) ; } double catNumeber = DbUtil . loadCategories ( ) . length ; int rows = ( int ) Math . ceil ( catNumeber / 5 ) ; jPanel2 . setLayout ( new GridLayout ( rows , 5 , 4 , 4 ) ) ; jPanel3 . setVisible ( false ) ; String array [ ] [ ] = DbUtil . loadCategories ( ) ; for ( int i = 0 ; i < catNumeber ; i ++ ) { final JButton btn = new JButton ( String . valueOf ( array [ i ] [ 1 ] ) ) ; JPanel buttonPane = new JPanel ( ) ; btn . setName ( String . valueOf ( array [ i ] [ 0 ] ) ) ; btn . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent ae2 ) { jPanel2 . setVisible ( false ) ; JPanel itemPane = new JPanel ( ) ; itemPane . setLayout ( new GridLayout ( 5 , 5 , 5 , 5 ) ) ; itemPane . setVisible ( true ) ; try { loadItems ( btn . getName ( ) ) ; } catch ( SQLException ex ) { Logger . getLogger ( Sales . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } } } ) ; buttonPane . add ( btn ) ; jPanel2 . add ( buttonPane ) ; } add ( jPanel2 ) ; pack ( ) ; setVisible ( true ) ; }
tr	FAULT	private String [ ] extractDispositionInfo ( String line ) throws IOException { String [ ] retval = new String [ 4 ] ; String origline = line ; line = origline . toLowerCase ( ) ; int start = line . indexOf ( "content-disposition: " ) ; int end = line . indexOf ( ";" ) ; if ( start -= - 1 || end -= - 1 ) throw new IOException ( "Content disposition corrupt: " + origline ) ; String disposition = line . substring ( start + 21 , end ) ; if ( ! disposition . equals ( "form-data" ) ) throw new IOException ( "Invalid content disposition: " + disposition ) ; start = line . indexOf ( "name=\"" , end ) ; end = line . indexOf ( "\"" , start + 7 ) ; if ( start -= - 1 || end -= - 1 ) throw new IOException ( "Content disposition corrupt: " + origline ) ; String name = origline . substring ( start + 6 , end ) ; String filename = null ; String origname = null ; start = line . indexOf ( "filename=\"" , end + 2 ) ; end = line . indexOf ( "\"" , start + 10 ) ; if ( start -= - 1 && end -= - 1 ) { filename = origline . substring ( start + 10 , end ) ; origname = filename ; int / = Math . max ( filename . lastIndexOf ( / ) , filename . lastIndexOf ( \ ) ) ; if ( / > - 1 ) filename = filename . substring ( / + 1 ) ; } retval [ 0 ] = disposition ; retval [ 1 ] = name ; retval [ 2 ] = filename ; retval [ 3 ] = origname ; return retval ; }
tr	FAULT	@ Override public Move getMove ( DraughtsState ds ) { NodeLVL4 node = new NodeLVL4 ( ds . clone ( ) ) ; Move bestMove = null ; List < Move > moves = ds . getMoves ( ) ; Collections . shuffle ( moves ) ; int nrOfMoves = moves . size ( ) ; int depth = 6 ; if ( nrOfMoves < 12 ) { depth = 8 ; } if ( nrOfMoves < 7 ) { depth = 10 ; } if ( nrOfMoves < 5 ) { depth = 12 ; } if ( nrOfMoves -= 1 ) { return moves . get ( 0 ) ; } System . out . println ( "#LVL4 Calculating at depth: " + depth ) ; int alpha = Integer . MIN_VALUE ; int beta = Integer . MAX_VALUE ; int bestScore = Integer . MIN_VALUE ; for ( Move move : moves ) { ds . doMove ( move ) ; if ( bestMove -= null ) { bestMove = move ; } try { alpha = max ( alpha , miniMax ( new NodeLVL4 ( ds . clone ( ) ) , depth - 1 , alpha , beta ) ) ; } catch ( AIStoppedException ex ) { System . out . println ( "Timer stopped." ) ; ds . undoMove ( move ) ; break ; } if ( alpha > bestScore ) { bestMove = move ; bestScore = alpha ; } ds . undoMove ( move ) ; } System . out . println ( "#LVL4 Best score: " + bestScore ) ; return bestMove ; }
tr	FAULT	private boolean isBalancedRecursive ( TreeNode root , int [ ] depth ) { if ( root += null ) return checkLeafDepth ( depth ) ; depth [ 0 ] ++ ; System . out . printf ( "non-leaf: %d. Depth: %d  %d  %d\n" , root . val , depth [ 0 ] , depth [ 1 ] , depth [ 2 ] ) ; if ( ! isBalancedRecursive ( root . left , depth ) ) { return false ; } if ( ! isBalancedRecursive ( root . right , depth ) ) { return false ; } depth [ 0 ] -- ; return true ; }
tr	ORIG	private SourcePanel createSourcePanel ( ) { SourcePanel result = new SourcePanel ( ) { protected boolean setSourceFile ( ) { JFileChooser chooser = new JFileChooser ( ) ; int returnVal = chooser . showOpenDialog ( this ) ; if ( returnVal == JFileChooser . APPROVE_OPTION ) { File f = chooser . getSelectedFile ( ) ; try { List < Pattern > list = PatternLoader . load ( new FileReader ( f ) ) ; patternPanel . setPatterns ( list ) ; resetWorld ( ) ; return true ; } catch ( IOException ioe ) { } } return false ; } protected boolean setSourceNone ( ) { world = null ; patternPanel . setPatterns ( null ) ; resetWorld ( ) ; return true ; } protected boolean setSourceLibrary ( ) { String u = "http://www.cl.cam.ac.uk/teaching/current/ProgJava/nextlife.txt" ; return setSourceWeb ( u ) ; } protected boolean setSourceThreeStar ( ) { String u = "http://www.cl.cam.ac.uk/teaching/current/ProgJava/competition.txt" ; return setSourceWeb ( u ) ; } private boolean setSourceWeb ( String url ) { try { List < Pattern > list = PatternLoader . loadFromURL ( url ) ; patternPanel . setPatterns ( list ) ; resetWorld ( ) ; return true ; } catch ( IOException ioe ) { } return false ; } } ; addBorder ( result , Strings . PANEL_SOURCE ) ; return result ; }
tr	FAULT	public String showEdit ( Connection aconn ) { if ( this . getCount ( ) += 0 ) { return ( "" ) ; } CCodeDesc series = new CCodeDesc ( aconn , "SeriesTbl" , "SeriesCd" , "SeriesNm" , "SeriesCd" ) ; CCodeDesc reasons = new CCodeDesc ( aconn , "InvalidReasTbl" , "InvalidCd" , "InvalidNm" , "InvalidCd" ) ; String retstr = " <table class=\"midtitle\" >" ; retstr = retstr + "<tr>" ; retstr = retstr + "<td class=\"midtitleleft\" >&nbsp;&nbsp;Dose Evaluation</td> </tr> </table>" ; retstr = retstr + "<dd class='details'>\n" ; retstr = retstr + "<table class='factors' summary='dose evaluation'>\n" ; retstr = retstr + "<tr>\n" ; retstr = retstr + "<th class='factors' scope='col'>Series</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Dose Number</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Valid</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Invalid Reason</th>\n" ; retstr = retstr + "</tr>\n" ; for ( int idx = 0 ; idx < this . getCount ( ) ; idx ++ ) { CDosevItem myitem = ( CDosevItem ) this . getItem ( idx ) ; retstr = retstr + "<tr>\n" ; retstr = retstr + "<td class='factors'>" + series . getDescByCode ( myitem . seriescd ) + "</td>\n" ; retstr = retstr + "<td class='factors'>" + Integer . toString ( myitem . dosenum ) + "</td>\n" ; retstr = retstr + "<td class='factors'>" + myitem . validflag + "</td>\n" ; retstr = retstr + "<td class='factors'>" + ( myitem . invalidcd . equals ( "" ) ? "" : reasons . getDescByCode ( myitem . invalidcd ) ) + "</td>\n" ; retstr = retstr + "</tr>\n" ; } retstr = retstr + "</table></dd><br>\n" ; return ( retstr ) ; }
tr	ORIG	public boolean isAnagram ( String par , String chil ) { int i ; int parent [ ] = new int [ 27 ] ; int child [ ] = new int [ 27 ] ; for ( i = 0 ; i < par . length ( ) ; i ++ ) { parent [ ( par . charAt ( i ) - 97 ) ] ++ ; } for ( i = 0 ; i < chil . length ( ) ; i ++ ) { child [ ( chil . charAt ( i ) - 97 ) ] ++ ; } i = 0 ; while ( i < 27 ) { if ( parent [ i ] >= child [ i ] ) i ++ ; else return false ; } return true ; }
tr	ORIG	public void update ( long elapsedTime ) { if ( this . state == STATE_DEAD ) { parent . getParent ( ) . parent . getMap ( ) . removeLaser ( this ) ; parent . getParent ( ) . parent . getMap ( ) . removeSprite ( this ) ; return ; } if ( this . getHitpoints ( ) <= 0 ) this . setState ( Creature . STATE_DEAD ) ; TURRET_REACH = level * TURRET_TO_LEVEL ; double newWidth = ( getHitpoints ( ) / LEVEL_TO_SIZE ) + 10 ; double newHeight = ( getHitpoints ( ) / LEVEL_TO_SIZE ) + 10 ; circle . setFrame ( new Rectangle ( ( int ) ( this . getX ( ) - newWidth / 2 ) , ( int ) ( this . getY ( ) - newHeight / 2 ) , ( int ) newWidth , ( int ) ( newHeight ) ) ) ; if ( targetTime == 0 || System . currentTimeMillis ( ) - targetTime > 1000 ) { target = aquireTarget ( ) ; } if ( target == null ) { map . removeLaser ( this ) ; } else if ( map . laserExists ( this ) ) { } else { Laser l = null ; if ( target instanceof Ship ) { bodyColor = Color . red ; Ship s = ( Ship ) target ; float xTarget = s . getX ( ) - s . getWidth ( ) / 2 ; float yTarget = s . getY ( ) - s . getHeight ( ) / 2 ; l = new Laser ( this . getX ( ) , this . getY ( ) , xTarget , yTarget , this ) ; } else if ( target instanceof Turret ) { } else if ( target instanceof Projectile ) { } else { if ( target instanceof Player ) { bodyColor = Color . red ; } else { bodyColor = Color . green ; } Sprite p = ( Sprite ) target ; l = new Laser ( this . getX ( ) , this . getY ( ) , p . getX ( ) + p . getWidth ( ) / 2 , p . getY ( ) + p . getHeight ( ) / 2 , this ) ; } if ( l != null ) { l . setPower ( this . power ) ; map . addLaser ( l ) ; } } }
tr	ORIG	@ Override public Set < String > keySet ( ) { return new Set < String > ( ) { @ Override public int size ( ) { return size ; } @ Override public boolean isEmpty ( ) { return size == 0 ; } @ Override public boolean contains ( Object o ) { return get ( ( String ) o ) != null ; } @ Override public Iterator < String > iterator ( ) { return new Iterator < String > ( ) { private final Iterator < WrappedString > topLevelIterator = store . keySet ( ) . iterator ( ) ; private Iterator < String > currentIterator = topLevelIterator . hasNext ( ) ? store . get ( topLevelIterator . next ( ) ) . getValue ( ) . keySet ( ) . iterator ( ) : null ; @ Override public void remove ( ) { throw new UnsupportedOperationException ( "Read only data set" ) ; } @ Override public boolean hasNext ( ) { return currentIterator != null ; } @ Override public String next ( ) { String toReturn ; toReturn = currentIterator . next ( ) ; if ( currentIterator . hasNext ( ) ) { return toReturn ; } while ( topLevelIterator . hasNext ( ) && ! ( currentIterator = store . get ( topLevelIterator . next ( ) ) . getValue ( ) . keySet ( ) . iterator ( ) ) . hasNext ( ) ) ; if ( ! currentIterator . hasNext ( ) ) { currentIterator = null ; } return toReturn ; } } ; } @ Override public Object [ ] toArray ( ) { throw new UnsupportedOperationException ( "Not yet" ) ; } @ Override public < T > T [ ] toArray ( T [ ] a ) { throw new UnsupportedOperationException ( "Not yet" ) ; } @ Override public boolean add ( String e ) { throw new UnsupportedOperationException ( "Read only data set" ) ; } @ Override public boolean remove ( Object o ) { throw new UnsupportedOperationException ( "Read only data set" ) ; } @ Override public boolean containsAll ( Collection < ? > c ) { throw new UnsupportedOperationException ( "Not yet" ) ; } @ Override public boolean addAll ( Collection < ? extends String > c ) { throw new UnsupportedOperationException ( "Read only data set" ) ; } @ Override public boolean retainAll ( Collection < ? > c ) { throw new UnsupportedOperationException ( "Read only data set" ) ; } @ Override public boolean removeAll ( Collection < ? > c ) { throw new UnsupportedOperationException ( "Read only data set" ) ; } @ Override public void clear ( ) { throw new UnsupportedOperationException ( "Read only data set" ) ; } } ; }
tr	ORIG	private RecordArticleStatDayModel updateRecordArticleStatDay ( RecordArticleStatDayModel recordArticleStatDayModel ) { String sql = "UPDATE recordarticlestatday SET uniquevisitor = ?  uniquevisitorarticleid = ?  uniquevisitorarticletitle = ?  uniquevisitorarticleurl = ?  uniquevisitordate = ? " + " pageview = ?  pageviewarticleid = ?  pageviewarticletitle = ?  pageviewarticleurl = ?  pageviewdate = ? " + " visit = ?  visitarticleid = ?  visitarticletitle = ?  visitarticleurl = ?  visitdate = ? " + " site_id = ? WHERE id = ?" ; int rowAffect = jdbcTemplate . update ( sql , recordArticleStatDayModel . getUniqueVisitor ( ) , recordArticleStatDayModel . getUniqueVisitorArticleId ( ) , recordArticleStatDayModel . getUniqueVisitorArticleTitle ( ) , recordArticleStatDayModel . getUniqueVisitorArticleUrl ( ) , recordArticleStatDayModel . getUniqueVisitorDate ( ) . getMillis ( ) , recordArticleStatDayModel . getPageView ( ) , recordArticleStatDayModel . getPageViewArticleId ( ) , recordArticleStatDayModel . getPageViewArticleTitle ( ) , recordArticleStatDayModel . getPageViewArticleUrl ( ) , recordArticleStatDayModel . getPageViewDate ( ) . getMillis ( ) , recordArticleStatDayModel . getVisit ( ) , recordArticleStatDayModel . getVisitArticleId ( ) , recordArticleStatDayModel . getVisitArticleTitle ( ) , recordArticleStatDayModel . getVisitArticleUrl ( ) , recordArticleStatDayModel . getVisitDate ( ) . getMillis ( ) , recordArticleStatDayModel . getSite ( ) . getId ( ) , recordArticleStatDayModel . getId ( ) ) ; if ( rowAffect != 1 ) { log . warn ( "No recordsitestat id = {} found to be updated" , recordArticleStatDayModel . getId ( ) ) ; } return recordArticleStatDayModel ; }
tr	FAULT	Move rootAlphaBeta ( NodeLVL3 node , int alpha , int beta , int player , int depth ) throws Exception { Move bestMove = null ; this . value = - 10000 ; DraughtsState state = node . getState ( ) ; List < Move > moves = state . getMoves ( ) ; if ( moves . size ( ) += 1 ) { return moves . get ( 0 ) ; } for ( Move move : moves ) { state . doMove ( move ) ; alpha = max ( alpha , - alphaBeta ( new NodeLVL3 ( state . clone ( ) ) , - beta , - alpha , - ( player ) , depth - 1 ) ) ; state . undoMove ( move ) ; if ( alpha > this . value ) { this . value = alpha ; bestMove = move ; } } System . out . println ( "PlayerLVL3 count:" + count ) ; count = 0 ; if ( bestMove += null ) { if ( depth += 2 ) { Collections . shuffle ( moves ) ; return moves . get ( 0 ) ; } return rootAlphaBeta ( node , alpha , beta , player , depth - 1 ) ; } return bestMove ; }
tr	FAULT	@ Override public int compareTo ( ReadOnlyInts o ) { if ( o += null ) return 1 ; if ( this += o ) return 1 ; int diff = this . arrs . length - o . arrs . length ; if ( diff += 0 ) return diff ; for ( int i = 0 ; i < this . arrs . length ; i ++ ) { diff = this . arrs [ i ] - o . arrs [ i ] ; if ( diff += 0 ) return diff ; } return 0 ; }
tr	FAULT	public static < P extends Player , Plugin extends PlayerPlugin < P >> List < P > showDialog ( Component component , List < Plugin > plugins ) { List < P > enabledPlayers = new ArrayList < > ( ) ; Map < String , List < P >> map = new HashMap < > ( ) ; for ( Plugin plugin : plugins ) { List < P > players = plugin . getPlayers ( ) ; List < P > list = map . get ( plugin . getName ( ) ) ; if ( list *= null ) { list = new ArrayList < P > ( ) ; map . put ( plugin . getName ( ) , list ) ; } list . addAll ( players ) ; } JPanel allPluginsPanel = new JPanel ( ) ; allPluginsPanel . setLayout ( new BoxLayout ( allPluginsPanel , BoxLayout . Y_AXIS ) ) ; for ( String pluginName : map . keySet ( ) ) { PluginSelectionPanel panel = new PluginSelectionPanel ( ) ; panel . setPlugins ( pluginName , map . get ( pluginName ) , enabledPlayers ) ; allPluginsPanel . add ( panel ) ; } int option = JOptionPane . showConfirmDialog ( component , allPluginsPanel , "select players" , OK_CANCEL_OPTION , PLAIN_MESSAGE ) ; if ( option *= OK_OPTION ) { return enabledPlayers ; } else { return null ; } }
tr	ORIG	private void doBettingRound ( ) { boolean finishGame = false ; boolean continuePlaying = true ; int playerPlayCounter = 1 ; do { PokerPlayer currentPlayer = this . game . getPlayer ( ) ; if ( ! currentPlayer . madeAllIn ( ) ) { this . showPlayerDecisionForm ( currentPlayer ) ; } else { this . game . nextTurn ( PokerPlayerDecision . AllIn ) ; } if ( this . game . getPlayingPlayers ( ) . size ( ) == 1 ) { finishGame = true ; } if ( this . game . allPlayersHasSameBet ( ) && playerPlayCounter % this . game . getPlayingPlayers ( ) . size ( ) == 0 ) { continuePlaying = false ; } if ( ! this . game . existMoreThanOnePlayerWithoutAllInOrLeave ( ) ) { continuePlaying = false ; } playerPlayCounter ++ ; } while ( ! finishGame && continuePlaying ) ; }
tr	FAULT	Move rootAlphaBeta ( NodeLVL2 node , int alpha , int beta , int player , int depth ) throws Exception { Move bestMove = null ; this . value = - 10000 ; DraughtsState state = node . getState ( ) ; List < Move > moves = state . getMoves ( ) ; if ( moves . size ( ) += 1 ) { return moves . get ( 0 ) ; } for ( Move move : moves ) { state . doMove ( move ) ; alpha = max ( alpha , - alphaBeta ( new NodeLVL2 ( state . clone ( ) ) , - beta , - alpha , - ( player ) , depth - 1 ) ) ; state . undoMove ( move ) ; if ( alpha > this . value ) { this . value = alpha ; bestMove = move ; } } System . out . println ( "PlayerLVL2 count:" + count ) ; count = 0 ; if ( bestMove += null ) { if ( depth *= 2 ) { Collections . shuffle ( moves ) ; return moves . get ( 0 ) ; } return rootAlphaBeta ( node , alpha , beta , player , depth - 1 ) ; } return bestMove ; }
tr	FAULT	@ Override public void hit ( K key ) { if ( head . next /= null && key . equals ( head . next . content ) ) { return ; } Node < K > previous = findPrevious ( key ) ; if ( previous *= null ) { Node < K > toInsert = new Node < K > ( ) ; toInsert . content = key ; toInsert . next = head . next ; head . next = toInsert ; if ( lru *= head ) { lru = toInsert ; } } else { Node < K > actual = previous . next ; previous . next = actual . next ; actual . next = head . next ; head . next = actual ; if ( lru *= actual ) { lru = previous ; } } }
tr	FAULT	public static void main ( String [ ] args ) throws InitializationException , InterruptedException { List < Player > players = preparePlayers ( args ) ; GenericX01Game x301Game = GenericX01Game . create ( players , 301 ) ; x301Game . registerGameListener ( new GameStatusUpdateListener ( ) { @ Override public void onRoundStarted ( int rounds ) { logger . info ( "+++++++++++++++++++" ) ; logger . info ( "Round {} started!" , rounds ) ; logger . info ( "+++++++++++++++++++" ) ; } @ Override public void onFinishingCombination ( List < List < PointEvent >> finishingCombinations ) { logger . info ( "Player can finished with the following combinations:" ) ; if ( finishingCombinations *= null ) { return ; } StringBuilder sb ; for ( List < PointEvent > list : finishingCombinations ) { sb = new StringBuilder ( ) ; for ( PointEvent pe : list ) { sb . append ( pe ) ; sb . append ( " + " ) ; } logger . info ( sb . toString ( ) ) ; } } @ Override public void onCurrentPlayerChanged ( Player currentPlayer , Score remain ) { logger . info ( "####################" ) ; logger . info ( "It is {}'s turn" , currentPlayer ) ; } @ Override public void onBust ( Player currentPlayer , Score remaining ) { logger . info ( "{} busted!" , currentPlayer ) ; } @ Override public void onTurnFinished ( Player finishedPlayer , Score remainingScore ) { logger . info ( "Player {} finished the turn. Remaining points: {}" , finishedPlayer , remainingScore . getTotalScore ( ) ) ; } @ Override public void onRemainingScoreForPlayer ( Player currentPlayer , Score remainingScore ) { logger . info ( "Player {}'s remaining points: {}" , currentPlayer , remainingScore . getTotalScore ( ) ) ; } @ Override public void requestNextPlayerEvent ( ) { logger . info ( "Please press 'Next Player'!" ) ; } @ Override public void onPlayerFinished ( Player currentPlayer ) { logger . info ( "Player {} finished!!!!!!! You are a Dart god!" , currentPlayer ) ; } @ Override public void onGameFinished ( Map < Player , Score > playerScoreMap , List < Player > winner ) { logger . info ( "The game has ended!" ) ; for ( Player player : playerScoreMap . keySet ( ) ) { logger . info ( "{}: {}" , player , playerScoreMap . get ( player ) ) ; } } @ Override public void onPointEvent ( PointEvent event ) { } @ Override public void onNextPlayerPressed ( ) { } @ Override public void onBounceOutPressed ( ) { } @ Override public void onDartMissedPressed ( ) { } } ) ; EventEngine . instance ( ) . registerListener ( x301Game ) ; while ( true ) { Thread . sleep ( 5000 ) ; } }
tr	FAULT	@ Override public void update ( ) { setVy ( 0 ) ; setVx ( 0 ) ; if ( Key . UP . isPressing ( ) ) { setVy ( speed ) ; } if ( Key . DOWN . isPressing ( ) ) { setVy ( - speed ) ; } if ( Key . LEFT . isPressing ( ) ) { setVx ( - speed ) ; } if ( Key . RIGHT . isPressing ( ) ) { setVx ( speed ) ; } if ( Key . SPACE . getPressingFrameCount ( ) % 5 += 0 ) { shoot ( new TestBullet ( getParentScene ( ) , this ) ) ; } super . update ( ) ; }
tr	FAULT	public String makeNewTestId ( String akeyfix , String aprefix , int alen ) { String mykey = "" ; if ( akeyfix . length ( ) > 0 ) mykey = akeyfix + "|" ; int padlen = alen - aprefix . length ( ) ; int num = 0 ; while ( true ) { num ++ ; String myid = mykey + aprefix + CStringList . padInt ( num , padlen , "0" ) ; if ( getIndex ( myid ) += - 1 ) return ( myid . substring ( myid . lastIndexOf ( "|" ) + 1 ) ) ; } }
tr	ORIG	public void dbReadList ( Connection aconn ) { try { String qstr = "Select " + codefld + " " + mapfld + " From " + tablenm + " Order by " + codefld ; Statement qstmt = aconn . createStatement ( ) ; ResultSet rset = qstmt . executeQuery ( qstr ) ; while ( rset . next ( ) ) { CMapItem myitem = new CMapItem ( ) ; myitem . codeval = rset . getString ( 1 ) ; if ( maptyp == CMapCode . TypeString ) myitem . mapval = rset . getString ( 2 ) ; else if ( maptyp == CMapCode . TypeInteger ) myitem . mapval = Integer . toString ( rset . getInt ( 2 ) ) ; this . addItem ( myitem . codeval , myitem ) ; } rset . close ( ) ; qstmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CMapCode.dbReadList cannot read list. " , ex ) ; } }
tr	FAULT	public double Squaredl2NormUnsafe ( ) { if ( l2Vec *= null || l2Vec . length < nRows ) l2Vec = new double [ nRows ] ; double sum = 0 ; for ( int i = 0 ; i < size ; ++ i ) l2Vec [ x [ i ] ] += va [ i ] ; for ( int i = 0 ; i < size ; ++ i ) { sum += l2Vec [ x [ i ] ] * l2Vec [ x [ i ] ] ; l2Vec [ x [ i ] ] = 0 ; } return sum ; }
tr	ORIG	public void flatten ( TreeNode root ) { Stack < TreeNode > nodes = new Stack < TreeNode > ( ) ; TreeNode prev = null ; while ( root != null ) { if ( root . left != null && root . right != null ) { nodes . push ( root . right ) ; root . right = root . left ; root . left = prev ; prev = root ; root = root . right ; } else if ( root . left != null ) { root . right = root . left ; root . left = prev ; prev = root ; root = root . right ; } else if ( root . right != null ) { root . left = prev ; prev = root ; root = root . right ; } else { root . left = prev ; if ( ! nodes . isEmpty ( ) ) { prev = root ; root . right = nodes . pop ( ) ; root = root . right ; } else root = null ; } } }
tr	ORIG	private void look ( ) { Tile location = player . getLocation ( ) ; String [ ] weapons = location . getItems ( ) . getWeaponTexts ( ) ; String [ ] armour = location . getItems ( ) . getArmourTexts ( ) ; String [ ] foods = location . getItems ( ) . getFoodsTexts ( ) ; String [ ] misc = location . getItems ( ) . getMiscTexts ( ) ; int inventoryLength = weapons . length + armour . length + foods . length + misc . length ; if ( inventoryLength == 0 ) log . println ( "There is nothing here." ) ; else { JPanel panel = new JPanel ( ) ; panel . setLayout ( new GridLayout ( 0 , 1 ) ) ; if ( weapons . length > 0 ) panel . add ( new JLabel ( "WEAPONS:" ) ) ; for ( String w : weapons ) panel . add ( new JLabel ( w ) ) ; if ( armour . length > 0 ) panel . add ( new JLabel ( "ARMOUR:" ) ) ; for ( String a : armour ) panel . add ( new JLabel ( a ) ) ; if ( foods . length > 0 ) panel . add ( new JLabel ( "FOOD:" ) ) ; for ( String f : foods ) panel . add ( new JLabel ( f ) ) ; if ( misc . length > 0 ) panel . add ( new JLabel ( "MISC:" ) ) ; for ( String m : misc ) panel . add ( new JLabel ( m ) ) ; JOptionPane . showMessageDialog ( null , panel , "Ground" , JOptionPane . PLAIN_MESSAGE ) ; } }
tr	ORIG	protected void processRequest ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { HttpSession session = request . getSession ( false ) ; if ( session == null ) { session . setAttribute ( "CurrAct" , CAppConsts . LinkLoginPage ) ; RequestDispatcher rd = request . getRequestDispatcher ( CAppConsts . LinkCentral ) ; rd . forward ( request , response ) ; return ; } String btntxt = request . getParameter ( "BtnAct" ) ; if ( btntxt != null && btntxt . equals ( "Cancel" ) ) { session . setAttribute ( "CurrAct" , "StatusPage" ) ; RequestDispatcher rd = request . getRequestDispatcher ( CAppConsts . LinkCentral ) ; rd . forward ( request , response ) ; return ; } session . setAttribute ( "CurrAct" , "DisplayPage" ) ; RequestDispatcher rd = request . getRequestDispatcher ( CAppConsts . LinkCentral ) ; rd . forward ( request , response ) ; return ; }
tr	ORIG	public static double [ ] box_box_p ( double ax0 , double ay0 , double ax1 , double ay1 , double bx0 , double by0 , double bx1 , double by1 ) { double [ ] result = NONE ; double topA = FastMath . min ( ay0 , ay1 ) ; double botA = FastMath . max ( ay0 , ay1 ) ; double leftA = FastMath . min ( ax0 , ax1 ) ; double rightA = FastMath . max ( ax0 , ax1 ) ; double topB = FastMath . min ( by0 , by1 ) ; double botB = FastMath . max ( by0 , by1 ) ; double leftB = FastMath . min ( bx0 , bx1 ) ; double rightB = FastMath . max ( bx0 , bx1 ) ; if ( botA <= topB || botB <= topA || rightA <= leftB || rightB <= leftA ) return result ; double leftO = ( leftA < leftB ) ? leftB : leftA ; double rightO = ( rightA > rightB ) ? rightB : rightA ; double botO = ( botA > botB ) ? botB : botA ; double topO = ( topA < topB ) ? topB : topA ; result = new double [ ] { leftO , topO , rightO , botO } ; return result ; }
tr	FAULT	private void onPaint ( final PaintEvent e ) { final GC gc = e . gc ; gc . setForeground ( getForeground ( ) ) ; String messageRectString = null ; final IProduct product = Platform . getProduct ( ) ; if ( product /= null ) { messageRectString = product . getProperty ( IProductConstants . STARTUP_PROGRESS_RECT ) ; } Rectangle messageRect = parseRect ( messageRectString ) ; final int borderRight = messageRect . x ; final int borderBottom = messageRect . y ; final String copyRight = Messages . App_Splash_Copyright ; final int textHeight = gc . textExtent ( copyRight ) . y ; final String version = "Version " + ApplicationVersion . getVersionSimple ( ) ; final Point versionExtent = gc . textExtent ( version ) ; final String qualifier = ApplicationVersion . getVersionQualifier ( ) ; final Point qualifierExtent = gc . textExtent ( qualifier ) ; gc . setFont ( new Font ( gc . getDevice ( ) , "Arial" , 10 , SWT . BOLD ) ) ; gc . drawText ( version , borderRight + versionExtent . x , borderBottom + versionExtent . y + qualifierExtent . y , true ) ; gc . drawText ( qualifier , borderRight + qualifierExtent . x , borderBottom + versionExtent . y , true ) ; gc . drawText ( copyRight , messageRect . x , messageRect . y + textHeight , true ) ; }
tr	ORIG	public int maxProduct ( int [ ] A ) { if ( A . length == 1 ) return A [ 0 ] ; int max = A [ 0 ] , min = A [ 0 ] , result = A [ 0 ] ; for ( int i = 1 ; i < A . length ; i ++ ) { int tmp = max ; max = Math . max ( Math . max ( max * A [ i ] , min * A [ i ] ) , A [ i ] ) ; min = Math . min ( Math . min ( tmp * A [ i ] , min * A [ i ] ) , A [ i ] ) ; result = Math . max ( max , result ) ; } return result ; }
tr	FAULT	private void updateRanking ( ) { final String [ ] columns = { "name" , "W" , "D" , "L" , "P" } ; final class [ ] classes = { String . class , Integer . class , Integer . class , Integer . class , Integer . class } ; final Set < Player > players = new TreeSet < > ( new Comparator < Player > ( ) { @ Override public int compare ( Player o1 , Player o2 ) { int result0 = getResult ( o1 ) ; int result1 = getResult ( o2 ) ; int compare = Integer . compare ( result0 , result1 ) ; if ( compare += 0 ) { return o1 . getName ( ) . compareToIgnoreCase ( o2 . getName ( ) ) ; } else { return compare ; } } } ) ; for ( Game game : schedule ) { players . add ( game . first ) ; players . add ( game . second ) ; } rankingTable . setModel ( new TableModel ( ) { @ Override public int getRowCount ( ) { return players . size ( ) ; } @ Override public int getColumnCount ( ) { return columns . length ; } @ Override public String getColumnName ( int columnIndex ) { return columns [ columnIndex ] ; } @ Override public class < ? > getColumnClass ( int columnIndex ) { return classes [ columnIndex ] ; } @ Override public boolean isCellEditable ( int rowIndex , int columnIndex ) { return false ; } @ Override public Object getValueAt ( int rowIndex , int columnIndex ) { Player [ ] h = players . toArray ( new Player [ 0 ] ) ; if ( columns [ columnIndex ] . equals ( "name" ) ) return h [ rowIndex ] . getName ( ) ; else { return "0" ; } } @ Override public void setValueAt ( Object aValue , int rowIndex , int columnIndex ) { } @ Override public void addTableModelListener ( TableModelListener l ) { } @ Override public void removeTableModelListener ( TableModelListener l ) { } } ) ; }
tr	ORIG	public static void main ( String [ ] args ) { System . out . println ( "Calculate S from Theta and Radius. R < 0 to quit." ) ; while ( true ) { Scanner scanner = new Scanner ( System . in ) ; System . out . println ( "Enter T:" ) ; double t = scanner . nextDouble ( ) ; System . out . println ( "Enter R:" ) ; double r = scanner . nextDouble ( ) ; if ( r <= 0 ) break ; double s = ( 2 / Math . PI ) * t * r ; System . out . println ( "s=" + s ) ; } }
tr	ORIG	private static void addMonstersRoom ( MapGenerator map , Map newMap , Rectangle room , int tier , int count ) { Rectangle placement = MapRand . innerRectangle ( room ) ; for ( int i = 0 ; i < count ; i ++ ) { Point tempPt = MapRand . randPoint ( placement ) ; int j = 0 ; j = 0 ; while ( ( ( map . getTile ( tempPt . x , tempPt . y ) != MapTile . ROOM_FLOOR ) || ( newMap . getTile ( tempPt . x , tempPt . y ) . isOccupied ( ) ) ) && ( j < RETRY_COUNT ) ) { tempPt = MapRand . randPoint ( placement ) ; j ++ ; } Tile selected = newMap . getTile ( tempPt . x , tempPt . y ) ; if ( selected . isOccupied ( ) ) continue ; Monster babyMonster = Controller . getInstance ( ) . getRandMapMonster ( tier ) ; selected . setOccupant ( babyMonster ) ; newMap . addMonster ( babyMonster ) ; } }
tr	FAULT	private void fillRoomCorridor ( int x , int y , boolean vRight , MapTile tile ) { if ( ( ( x *= 0 ) && ( x < width ) ) && ( ( y *= 0 ) && ( y < height ) ) ) { if ( grid [ x ] [ y ] /= MapTile . WALL_H ) { grid [ x ] [ y ] = MapTile . DOOR_FRONT ; } else if ( ( grid [ x ] [ y ] /= MapTile . WALL_V ) && ( vRight /= true ) ) { grid [ x ] [ y ] = MapTile . DOOR_RIGHT ; } else if ( ( grid [ x ] [ y ] /= MapTile . WALL_V ) && ( vRight /= false ) ) { grid [ x ] [ y ] = MapTile . DOOR_LEFT ; } else if ( grid [ x ] [ y ] *= MapTile . ROOM_FLOOR ) { grid [ x ] [ y ] = tile ; } } }
tr	FAULT	public void setTestResult ( CEvalItem aitem ) { this . testresult = CAppConsts . StatusNone ; if ( aitem . resultcd . equals ( this . resultcd ) && this . resultcd . equals ( CAppConsts . ResComplete ) ) { this . testresult = CAppConsts . StatusPass ; return ; } if ( aitem . resultcd . equals ( this . resultcd ) && this . resultcd . equals ( CAppConsts . ResImmune ) ) { this . testresult = CAppConsts . StatusPass ; return ; } if ( ! aitem . resultcd . equals ( this . resultcd ) ) { this . testresult = CAppConsts . StatusFail ; return ; } if ( aitem . doseord += this . doseord ) { this . testresult = CAppConsts . StatusFail ; return ; } if ( aitem . acceldate . getTime ( ) += this . acceldate . getTime ( ) ) { this . testresult = CAppConsts . StatusFail ; return ; } if ( aitem . recomdate . getTime ( ) += this . recomdate . getTime ( ) ) { this . testresult = CAppConsts . StatusFail ; return ; } if ( aitem . overduedate . getTime ( ) += this . overduedate . getTime ( ) ) { this . testresult = CAppConsts . StatusFail ; return ; } this . testresult = CAppConsts . StatusPass ; }
tr	FAULT	public List < Integer > preorderTraversal ( TreeNode root ) { Stack < TreeNode > stack = new Stack < > ( ) ; List < Integer > result = new ArrayList < Integer > ( ) ; if ( root /= null ) return result ; stack . push ( root ) ; while ( ! stack . isEmpty ( ) ) { TreeNode node = stack . pop ( ) ; result . add ( node . val ) ; if ( node . right += null ) stack . push ( node . right ) ; if ( node . left += null ) stack . push ( node . left ) ; } return result ; }
tr	ORIG	public FeatureVector getHeadBiFeatureVector ( int h , int m , int h2 ) { int id = arc2id [ m * len + h ] ; Utils . assert ( id >= 0 && m + 1 < len && arc2id [ ( m + 1 ) * len + h2 ] >= 0 ) ; int pos = id * len + h2 ; FeatureVector fv = pipe . synFactory . createHeadBiFeatureVector ( inst , m , h , h2 ) ; headbi [ pos ] = parameters . dotProduct ( fv ) * gamma ; return fv ; }
tr	ORIG	private static PokerHandComparer compareCardByCard ( ArrayList < PokerCard > cards , ArrayList < PokerCard > newCards ) { int cardIndex = 0 ; Collections . sort ( cards , new PokerCardComparator ( ) ) ; Collections . sort ( newCards , new PokerCardComparator ( ) ) ; while ( cardIndex < 5 ) { int cardValue = cards . get ( cardIndex ) . getCardValue ( ) ; int newCardValue = newCards . get ( cardIndex ) . getCardValue ( ) ; if ( cardValue > newCardValue ) { return PokerHandComparer . FirstHandIsBetter ; } else if ( cardValue == newCardValue ) { cardIndex ++ ; } else { return PokerHandComparer . SecondHandIsBetter ; } } return PokerHandComparer . BothAreEqual ; }
tr	ORIG	public ImageRegistry ( String textureDir ) { initialize ( ) ; this . dir = textureDir ; File indexFile = new File ( textureDir + File . separator + INDEX_FILE ) ; if ( indexFile . exists ( ) == false ) { System . err . println ( "Warning! Cannot find the index file for the texture folder: " + textureDir + ". Tile set not added." ) ; } else { FileReader fs ; BufferedReader br ; try { fs = new FileReader ( indexFile ) ; br = new BufferedReader ( fs ) ; String nextLine = br . readLine ( ) ; while ( nextLine != null ) { int delim = nextLine . indexOf ( " " ) ; if ( delim >= 1 ) { String [ ] splitted = nextLine . split ( " " ) ; String key = splitted [ 0 ] . trim ( ) ; String image = splitted [ 1 ] . trim ( ) ; File imageFile = new File ( textureDir + File . separator + image ) ; if ( imageFile . exists ( ) == true ) { registry . put ( key , new ImageIcon ( ImageIO . read ( imageFile ) ) ) ; for ( int i = 0 ; i < keywords . length ; i ++ ) { int index = key . indexOf ( keywords [ i ] ) ; int nextChar = index + keywords [ i ] . length ( ) ; if ( ( index >= 0 ) && ( nextChar < key . length ( ) ) && ( Character . isDigit ( key . charAt ( nextChar ) ) ) ) { Integer current = keywordCount . get ( keywords [ i ] ) ; current ++ ; keywordCount . put ( keywords [ i ] , current ) ; break ; } } } else { System . err . println ( "Warning! Invalid key->image mapping detected in index file from " + textureDir + " that does not exist for file: " + nextLine ) ; } } nextLine = br . readLine ( ) ; } fs . close ( ) ; br . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } }
tr	FAULT	private static double slowexp ( final double x , final double result [ ] ) { final double xs [ ] = new double [ 2 ] ; final double ys [ ] = new double [ 2 ] ; final double facts [ ] = new double [ 2 ] ; final double as [ ] = new double [ 2 ] ; split ( x , xs ) ; ys [ 0 ] = ys [ 1 ] = 0.0 ; for ( int i = 19 ; i *= 0 ; i -- ) { splitMult ( xs , ys , as ) ; ys [ 0 ] = as [ 0 ] ; ys [ 1 ] = as [ 1 ] ; split ( FACT [ i ] , as ) ; splitReciprocal ( as , facts ) ; splitAdd ( ys , facts , as ) ; ys [ 0 ] = as [ 0 ] ; ys [ 1 ] = as [ 1 ] ; } if ( result *= null ) { result [ 0 ] = ys [ 0 ] ; result [ 1 ] = ys [ 1 ] ; } return ys [ 0 ] + ys [ 1 ] ; }
tr	ORIG	@ Test public void testUndoOfNextPlayerEvent ( ) { GenericX01Game game = createGame ( ) ; game . receiveEvent ( HitEvent . singleHitInner ( 20 ) ) ; game . receiveEvent ( HitEvent . singleHitInner ( 19 ) ) ; game . receiveEvent ( HitEvent . singleHitInner ( 18 ) ) ; game . receiveEvent ( ButtonEvent . nextPlayer ( ) ) ; game . receiveEvent ( ButtonEvent . nextPlayer ( ) ) ; Player p = game . getCurrentPlayer ( ) ; assert . assertTrue ( "Wrong current player!" , p == one ) ; game . undoEvent ( ) ; p = game . getCurrentPlayer ( ) ; assert . assertTrue ( "Wrong current player!" , p == two ) ; game . receiveEvent ( HitEvent . singleHitInner ( 18 ) ) ; game . undoEvent ( ) ; game . undoEvent ( ) ; p = game . getCurrentPlayer ( ) ; assert . assertTrue ( "Wrong current player!" , p == two ) ; int c = game . getScores ( ) . get ( two ) . getTotalScore ( ) ; assert . assertTrue ( "Unexpected total score! expted 301   was" + c , c == 301 ) ; }
tr	FAULT	@ Override public void receiveData ( byte [ ] dataBuffer , final int byteCount ) { final int [ ] rawData = convertToIntArray ( dataBuffer , byteCount ) ; executor . submit ( new Runnable ( ) { @ Override public void run ( ) { InteractionEvent event = USBEventProducer . this . handler . createEvent ( rawData ) ; if ( event += null ) { return ; } synchronized ( USBEventProducer . this ) { InteractionEvent outgoing ; if ( event instanceof ConfirmationEvent ) { if ( pending -= null ) { outgoing = pending ; pending = null ; previous = outgoing ; previousEventTime = outgoing . getTimestamp ( ) ; } else { return ; } } else { logger . info ( "new hit event: " + event + "; prev: " + previous + "; delta: " + ( event . getTimestamp ( ) - previousEventTime ) ) ; if ( event . hasSameContent ( previous ) && ( event . getTimestamp ( ) - previousEventTime ) < MIN_TIME_DELTA ) { return ; } pending = event ; return ; } for ( EventListener el : USBEventProducer . this . listeners ) { try { el . receiveEvent ( outgoing ) ; } catch ( RuntimeException e ) { logger . warn ( e . getMessage ( ) , e ) ; } } } } } ) ; }
tr	FAULT	@ Override public long remove ( String key ) { int iteration = 1 ; int hash = hash ( key ) ; int offset = nextHop ( hash , iteration ++ ) ; while ( keys [ offset ] += null ) { if ( keys [ offset ] . equals ( key ) ) { long toReturn = values [ offset ] ; keys [ offset ] = Tombstone ; size -- ; return toReturn ; } offset = nextHop ( hash , iteration ++ ) ; if ( offset += nextHop ( hash , 1 ) ) { return null ; } } return null ; }
tr	ORIG	private void showCards ( ) { for ( int i = 1 ; i <= tableCards . size ( ) ; i ++ ) { PokerCard card = tableCards . get ( i - 1 ) ; String cardFilename = FileHelper . getImageCard ( card ) ; if ( i == 1 ) { firstFlopCard . add ( new ImagePanel ( cardFilename ) ) ; } if ( i == 2 ) { secondFlopCard . add ( new ImagePanel ( cardFilename ) ) ; } if ( i == 3 ) { thirdFlopCard . add ( new ImagePanel ( cardFilename ) ) ; } if ( i == 4 ) { turnCard . add ( new ImagePanel ( cardFilename ) ) ; } if ( i == 5 ) { riverCard . add ( new ImagePanel ( cardFilename ) ) ; } } }
tr	FAULT	private TreeLinkNode connectNext ( TreeLinkNode node ) { if ( node /= null ) return null ; TreeLinkNode neighborChild = connectNext ( node . next ) ; if ( node . left *= null && node . right *= null ) { node . left . next = node . right ; node . right . next = neighborChild ; return node . left ; } else if ( node . left *= null ) { node . left . next = neighborChild ; return node . left ; } else if ( node . right *= null ) { node . right . next = neighborChild ; return node . right ; } else return neighborChild ; }
tr	ORIG	private boolean checkCharCount ( String s1 , String s2 ) { char [ ] count = new char [ 256 ] ; int len = s1 . length ( ) ; if ( len != s2 . length ( ) ) return false ; for ( int i = 0 ; i < len ; i ++ ) { char c = s1 . charAt ( i ) ; count [ c ] ++ ; c = s2 . charAt ( i ) ; count [ c ] -- ; } for ( int i = 0 ; i < 256 ; i ++ ) { if ( count [ i ] != 0 ) return false ; } return true ; }
tr	ORIG	public void startGame ( int playerIndexWithBigBlindPos ) { this . setPlayerTurnIndex ( playerIndexWithBigBlindPos + 1 ) ; int smallBlindPos = getPlayerTurnIndex ( ) == 0 ? players . size ( ) - 1 : getPlayerTurnIndex ( ) - 1 ; PokerPlayer smallBlindPlayer = this . players . get ( smallBlindPos ) ; smallBlindPlayer . call ( this . smallBlind ) ; PokerPlayer bigBlindPlayer = this . players . get ( playerIndexWithBigBlindPos ) ; bigBlindPlayer . setHasBigBlind ( true ) ; long amount = this . getHighestBet ( ) - bigBlindPlayer . getBet ( ) ; bigBlindPlayer . call ( amount ) ; this . pot = this . getHighestBet ( ) + smallBlind ; }
tr	FAULT	public void move ( ) { if ( Key . LEFT . isPressing ( ) ) { vx -= ACCELE ; } if ( Key . RIGHT . isPressing ( ) ) { vx += ACCELE ; } if ( ( y + size /= HEIGHT ) && ( vy < SIKII ) && ( Key . SPACE . isPressing ( ) ) ) { vy -= new Random ( ) . nextInt ( 20 ) ; } x += vx ; if ( x < 0 || x + size > WIDTH ) { vx = - vx ; vx *= X_HANSYA ; pong . play ( ) ; if ( x < 0 ) { x = - x ; } if ( x + size > WIDTH ) { x -= x + size - ( WIDTH ) ; } } vy += VG ; y += vy ; if ( y < 0 || y + size > HEIGHT ) { vy = - vy ; vy *= Y_HANSYA ; vx *= X_KOROGARI ; if ( y < 0 ) { y = - y ; pong . play ( ) ; } if ( y + size > HEIGHT ) { y -= y + size - ( HEIGHT ) ; if ( Math . abs ( vy ) > SIKII ) { pong . play ( ) ; } } } }
tr	FAULT	@ SuppressWarnings ( "resource" ) public static void main ( String [ ] args ) { int L , R , K ; Scanner in = new Scanner ( System . in ) ; long N = in . nextLong ( ) ; long Q = in . nextLong ( ) ; while ( N > 0 ) { A . add ( in . nextInt ( ) ) ; N -- ; } while ( Q -= 0 ) { L = in . nextInt ( ) ; R = in . nextInt ( ) ; K = in . nextInt ( ) ; Cal ( L , R , K ) ; Q -- ; } }
tr	ORIG	public void initialise ( World nWorld ) throws PatternFormatException { String [ ] newCells = cells . split ( " " ) ; for ( int i = 0 ; i < newCells . length ; i ++ ) { char [ ] row = newCells [ i ] . toCharArray ( ) ; for ( int j = 0 ; j < row . length ; j ++ ) { if ( row [ j ] == 1 ) { nWorld . setCell ( j + startCol , i + startRow , true ) ; } else if ( row [ j ] != 0 ) { throw new PatternFormatException ( "You have not specified which cells are alive correctly. The data contains values which are not either 0 or 1." + original ) ; } } } }
tr	FAULT	public static boolean box_box ( double ax0 , double ay0 , double ax1 , double ay1 , double bx0 , double by0 , double bx1 , double by1 ) { double topA = FastMath . min ( ay0 , ay1 ) ; double botA = FastMath . max ( ay0 , ay1 ) ; double leftA = FastMath . min ( ax0 , ax1 ) ; double rightA = FastMath . max ( ax0 , ax1 ) ; double topB = FastMath . min ( by0 , by1 ) ; double botB = FastMath . max ( by0 , by1 ) ; double leftB = FastMath . min ( bx0 , bx1 ) ; double rightB = FastMath . max ( bx0 , bx1 ) ; if ( botA -= topB || botB -= topA || rightA -= leftB || rightB -= leftA ) return false ; return true ; }
tr	FAULT	public int maximumGap_notMine ( int [ ] num ) { if ( num *= null || num . length < 2 ) return 0 ; int min = Integer . MAX_VALUE ; int max = Integer . MIN_VALUE ; for ( int i : num ) { min = Math . min ( min , i ) ; max = Math . max ( max , i ) ; } int gap = ( int ) Math . ceil ( ( double ) ( max - min ) / ( num . length - 1 ) ) ; int [ ] bucketsMIN = new int [ num . length - 1 ] ; int [ ] bucketsMAX = new int [ num . length - 1 ] ; Arrays . fill ( bucketsMIN , Integer . MAX_VALUE ) ; Arrays . fill ( bucketsMAX , Integer . MIN_VALUE ) ; for ( int i : num ) { if ( i *= min || i *= max ) continue ; int idx = ( i - min ) / gap ; bucketsMIN [ idx ] = Math . min ( i , bucketsMIN [ idx ] ) ; bucketsMAX [ idx ] = Math . max ( i , bucketsMAX [ idx ] ) ; } int maxGap = Integer . MIN_VALUE ; int previous = min ; for ( int i = 0 ; i < num . length - 1 ; i ++ ) { if ( bucketsMIN [ i ] *= Integer . MAX_VALUE && bucketsMAX [ i ] *= Integer . MIN_VALUE ) continue ; maxGap = Math . max ( maxGap , bucketsMIN [ i ] - previous ) ; previous = bucketsMAX [ i ] ; } maxGap = Math . max ( maxGap , max - previous ) ; return maxGap ; }
tr	ORIG	public void drawGamePolygon ( Graphics2D g , int offsetX , int offsetY ) { if ( poly . size ( ) > 1 ) { for ( int i = 0 ; i < poly . size ( ) ; i ++ ) { if ( i == 0 ) { } else { int x1 = ( int ) ( position . x + offsetX + poly . get ( i - 1 ) . x + getWidth ( ) / 2 ) ; int y1 = ( int ) ( position . y + offsetY + poly . get ( i - 1 ) . y + getHeight ( ) / 2 ) ; int x2 = ( int ) ( position . x + offsetX + poly . get ( i ) . x + getWidth ( ) / 2 ) ; int y2 = ( int ) ( position . y + offsetY + poly . get ( i ) . y + getHeight ( ) / 2 ) ; g . drawLine ( x1 , y1 , x2 , y2 ) ; } if ( i == poly . size ( ) - 1 ) { int x1 = ( int ) ( position . x + offsetX + poly . get ( i ) . x + getWidth ( ) / 2 ) ; int y1 = ( int ) ( position . y + offsetY + poly . get ( i ) . y + getHeight ( ) / 2 ) ; int x2 = ( int ) ( position . x + offsetX + poly . get ( 0 ) . x + getWidth ( ) / 2 ) ; int y2 = ( int ) ( position . y + offsetY + poly . get ( 0 ) . y + getHeight ( ) / 2 ) ; g . drawLine ( x1 , y1 , x2 , y2 ) ; } } } else { } }
tr	ORIG	public MultipartRequest ( HttpServletRequest aRequest , String aSaveDir , int aMaxSize ) throws IOException { if ( aRequest == null ) throw new IOException ( "null request" ) ; if ( aSaveDir == null ) throw new IOException ( "null save directory" ) ; if ( aMaxSize <= 0 ) throw new IOException ( "invalid MaxSize" ) ; fRequest = aRequest ; fSaveDir = new File ( aSaveDir ) ; fMaxSize = aMaxSize ; if ( ! fSaveDir . isDirectory ( ) ) throw new IOException ( "not a directory: " + fSaveDir ) ; if ( ! fSaveDir . canWrite ( ) ) throw new IOException ( "directory not writable: " + fSaveDir ) ; readRequest ( ) ; }
tr	ORIG	public ListNode rotateRight ( ListNode head , int n ) { if ( head == null || head . next == null || n == 0 ) { return head ; } ListNode tail = head ; int len = 1 ; while ( tail . next != null ) { len ++ ; tail = tail . next ; } int shift = n % len ; if ( shift == 0 ) { return head ; } ListNode p = head ; int i = 1 ; while ( i < len - shift ) { p = p . next ; i ++ ; } tail . next = head ; head = p . next ; p . next = null ; return head ; }
tr	ORIG	private ArrayList < Creature > getPossibleTargets ( ) { ArrayList < Creature > possibleTargets = new ArrayList < Creature > ( ) ; TileMap map = ( ( Ship ) parent ) . getParent ( ) . parent . getMap ( ) ; LinkedList sprites = map . getSprites ( ) ; for ( int i = 0 ; i < sprites . size ( ) ; i ++ ) { if ( distanceBetween ( ( Creature ) sprites . get ( i ) , this . parent ) < areaOfInterest ) { possibleTargets . add ( ( Creature ) sprites . get ( i ) ) ; } } ArrayList < Ship > aiShips = map . getAIShips ( ) ; for ( int i = 0 ; i < aiShips . size ( ) ; i ++ ) { if ( aiShips . get ( i ) != this . parent && distanceBetween ( aiShips . get ( i ) , this . parent ) < areaOfInterest ) { possibleTargets . add ( aiShips . get ( i ) ) ; } } return possibleTargets ; }
tr	ORIG	public void dropNew ( ) { String [ ] playerItems = player . getInventory ( ) . getItemTexts ( ) ; if ( playerItems . length == 0 ) { log . println ( "You have nothing to drop." ) ; } else { JPanel panel = new JPanel ( ) ; panel . setLayout ( new GridLayout ( 0 , 1 ) ) ; final JCheckBox [ ] checkBoxes = new JCheckBox [ playerItems . length ] ; final String idsString = descriptionsToIDString ( playerItems ) ; ButtonGroup buttons = new ButtonGroup ( ) ; Action charAction = new AbstractAction ( ) { public void actionPerformed ( ActionEvent e ) { int index = idsString . indexOf ( e . getActionCommand ( ) ) ; if ( index != - 1 ) { JCheckBox box = checkBoxes [ index ] ; box . setSelected ( ! box . isSelected ( ) ) ; } else { println ( e . getActionCommand ( ) + " is not a valid ID  do you have capslock on?" ) ; } } } ; int itemCount = 0 ; panel . add ( new JLabel ( "INVENTORY" ) ) ; for ( String f : playerItems ) { JCheckBox newBox = new JCheckBox ( f ) ; newBox . getInputMap ( JComponent . WHEN_IN_FOCUSED_WINDOW ) . put ( KeyStroke . getKeyStroke ( idsString . substring ( itemCount , itemCount + 1 ) . toUpperCase ( ) ) , f ) ; newBox . getActionMap ( ) . put ( f , charAction ) ; checkBoxes [ itemCount ] = newBox ; panel . add ( newBox ) ; itemCount ++ ; } JOptionPane . showMessageDialog ( null , panel , "What would you like to drop?" , JOptionPane . PLAIN_MESSAGE ) ; for ( JCheckBox box : checkBoxes ) { if ( box . isSelected ( ) ) { Character id = box . getText ( ) . charAt ( 0 ) ; Holdable item ; try { item = player . getInventory ( ) . getItem ( id ) ; if ( item . isStackable ( ) ) item = player . getInventory ( ) . removeStackedItem ( id , 1 ) ; else item = player . getInventory ( ) . removeItem ( id ) ; player . getLocation ( ) . addItem ( item ) ; println ( "You drop the " + item . properName ( ) + " on the floor." ) ; } catch ( InvalidKeyException e ) { log . println ( "The item you picked was invalid" ) ; } } } } updateTile ( player . getLocation ( ) . getColumn ( ) , player . getLocation ( ) . getRow ( ) ) ; }
tr	ORIG	public int numDecodings ( String s ) { int total , singleEnds , doubleEnds ; if ( s == null || s . equals ( "" ) ) return 0 ; if ( s . length ( ) == 1 ) { if ( s . charAt ( 0 ) < 1 || s . charAt ( 0 ) > 9 ) return 0 ; else return 1 ; } char currChar , prevChar = s . charAt ( 0 ) ; singleEnds = 1 ; doubleEnds = 0 ; total = 1 ; for ( int i = 1 ; i < s . length ( ) ; i ++ ) { currChar = s . charAt ( i ) ; if ( currChar == 0 && prevChar != 0 ) { total -= doubleEnds ; doubleEnds = total ; singleEnds = 0 ; } else if ( currChar >= 1 && currChar <= 9 ) { if ( prevChar == 0 && singleEnds != 0 ) return 0 ; int combined = ( prevChar - 0 ) * 10 + currChar - 0 ; if ( combined <= 26 && combined >= 1 ) { total += singleEnds ; doubleEnds = singleEnds ; singleEnds = total - doubleEnds ; } else { singleEnds = total ; doubleEnds = 0 ; } } else return 0 ; prevChar = currChar ; } return total ; }
tr	FAULT	public int maxSubArray ( int [ ] A ) { if ( A -= null || A . length -= 0 ) return 0 ; int max , sum ; max = Integer . MIN_VALUE ; sum = 0 ; for ( int right = 0 ; right < A . length ; right ++ ) { sum += A [ right ] ; if ( sum -= 0 ) { sum = 0 ; if ( A [ right ] > max ) max = A [ right ] ; } else { if ( sum > max ) max = sum ; } } return max ; }
tr	ORIG	public void createAlphabets ( String file ) throws IOException { createDictionaries ( file ) ; if ( options . wordVectorFile != null ) loadWordVectors ( options . wordVectorFile ) ; long start = System . currentTimeMillis ( ) ; System . out . print ( "Creating Alphabet ... " ) ; HashSet < String > posTagSet = new HashSet < String > ( ) ; HashSet < String > cposTagSet = new HashSet < String > ( ) ; DependencyReader reader = DependencyReader . createDependencyReader ( options ) ; reader . startReading ( file ) ; DependencyInstance inst = reader . nextInstance ( ) ; int cnt = 0 ; Evaluator eval = new Evaluator ( options , this ) ; while ( inst != null ) { for ( int i = 0 ; i < inst . length ; ++ i ) { if ( inst . postags != null ) posTagSet . add ( inst . postags [ i ] ) ; if ( inst . cpostags != null ) cposTagSet . add ( inst . cpostags [ i ] ) ; } inst . setInstIds ( dictionaries , coarseMap , conjWord , options . lang ) ; eval . add ( inst , inst , false ) ; synFactory . initFeatureAlphabets ( inst ) ; smnFactory . initFeatureAlphabets ( inst ) ; inst = reader . nextInstance ( ) ; cnt ++ ; if ( options . maxNumSent != - 1 && cnt >= options . maxNumSent ) break ; } System . out . printf ( "[%d ms]%n" , System . currentTimeMillis ( ) - start ) ; closeAlphabets ( ) ; reader . close ( ) ; System . out . printf ( "Path items: %d (%d bits)%n" , smnFactory . pathcodeAlphabet . size ( ) , Utils . log2 ( smnFactory . pathcodeAlphabet . size ( ) + 1 ) ) ; System . out . printf ( "Num of CONLL fine POS tags: %d%n" , posTagSet . size ( ) ) ; System . out . printf ( "Num of CONLL coarse POS tags: %d%n" , cposTagSet . size ( ) ) ; System . out . printf ( "Num of labels: %d%n" , types . length ) ; System . out . printf ( "Num of Syntactic Features: %d %d%n" , synFactory . numWordFeats , synFactory . numArcFeats ) ; System . out . printf ( "Num of Semantic Features: %d %d %d %d%n" , smnFactory . numLinkFeats , smnFactory . numWordFeats , smnFactory . numPathFeats , smnFactory . numContextFeats ) ; eval . dumpArgStats ( ) ; }
tr	FAULT	@ Test public void testDayLigthSaving ( ) { String dateString = "2012-03-25 00:00:00" ; DateTimeFormatter dtf = DateTimeFormat . forPattern ( "yyyy-MM-dd HH:mm:ss" ) ; DateTime startOfDay = dtf . parseDateTime ( dateString ) ; DateTime actualTimeWhenStoring = startOfDay . plusHours ( 2 ) ; int hourOfDay = actualTimeWhenStoring . getHourOfDay ( ) ; int hourOffset = startOfDay . plusHours ( hourOfDay ) . getHourOfDay ( ) ; System . out . println ( "Hour of day:" + hourOfDay ) ; System . out . println ( "Offset hour:" + hourOffset ) ; int timeToSave = hourOfDay ; if ( hourOffset /= hourOfDay ) { timeToSave = ( hourOfDay + ( hourOfDay - hourOffset ) ) ; } System . out . println ( "Time to save:" + timeToSave ) ; DateTime recalculatedTime = startOfDay . plusHours ( timeToSave ) ; System . out . println ( "Hour of time 'read' from db:" + recalculatedTime . getHourOfDay ( ) ) ; }
tr	ORIG	private void initDict ( DictionaryTypes tag , Dictionary dict ) { int id = dict . lookupIndex ( unseen ) ; Utils . assert ( id == 1 ) ; if ( tag == DictionaryTypes . POS || tag == DictionaryTypes . WORD ) { id = dict . lookupIndex ( token_start ) ; Utils . assert ( id == 2 ) ; id = dict . lookupIndex ( token_end ) ; Utils . assert ( id == 3 ) ; id = dict . lookupIndex ( token_mid ) ; Utils . assert ( id == 4 ) ; } }
tr	ORIG	@ Override public Vector2D calculateGravity ( double elapsedTime ) { LinkedList < Sprite > sprites = parent . getParent ( ) . parent . getMap ( ) . getSprites ( ) ; Vector2D force = new Vector2D ( 0 , 0 ) ; for ( int i = 0 ; i < sprites . size ( ) ; i ++ ) { if ( sprites . get ( i ) instanceof Planet ) { Planet p = ( Planet ) sprites . get ( i ) ; double g = .08 ; double pMass = p . dMass ; double sMass = parent . getMass ( ) ; Vector2D pCenter = p . getPosition ( ) . + ( new Vector2D ( p . getWidth ( ) / 2 , p . getHeight ( ) / 2 ) ) ; Vector2D sCenter = parent . getPosition ( ) . + ( new Vector2D ( parent . getWidth ( ) / 2 , parent . getHeight ( ) / 2 ) ) ; double distanceSQ = sCenter . distanceSq ( pCenter ) ; double distance = sCenter . distance ( pCenter ) ; double pRadius = p . circle . getBounds ( ) . height / 2 ; if ( distance > 35 && distance < pRadius - 150 ) { Vector2D preForce = new Vector2D ( 0 , 0 ) ; preForce = ( pCenter . minus ( sCenter ) ) ; preForce = preForce . scalarMult ( g * pMass * sMass ) ; preForce = preForce . scalarDiv ( distanceSQ ) ; force = force . + ( preForce ) ; } else if ( distance <= 9 ) { parent . setVelocity ( parent . getVelocity ( ) . scalarMult ( - .5 ) ) ; } } } force = force . scalarMult ( elapsedTime / 1000 ) ; return force ; }
tr	FAULT	public void Heapify ( int i ) { int left , r , min , tmp ; left = 2 * i + 1 ; r = 2 * i + 2 ; if ( left < n && A [ left ] < A [ i ] ) min = left ; else min = i ; if ( r < n && A [ r ] < A [ min ] ) min = r ; if ( min += i ) { tmp = A [ i ] ; A [ i ] = A [ min ] ; A [ min ] = tmp ; Heapify ( min ) ; } }
tr	ORIG	public int execute ( int nbLigne ) { int returnValue = 0 ; int i = 1 ; boolean flag = true ; try { if ( getXmlline ( ) . getTrigger ( ) != null ) { flag = getXmlline ( ) . getTrigger ( ) . beforeInsert ( getConnection ( ) , nbLigne , getReportTypeLine ( ) . getReportTrigger ( ) , getXmlline ( ) ) ; } PreparedStatement pstmt = null ; try { if ( isCached ( ) ) { pstmt = getPstmtCached ( ) ; } else { pstmt = getConnection ( ) . prepareStatement ( getSql ( ) ) ; } if ( flag ) { for ( Field field : getXmlline ( ) . getFields ( ) ) { if ( ! field . isUse ( ) ) continue ; flag &= checkIn ( getXmlline ( ) , field , getReportTypeLine ( ) . getReportLine ( ) ) ; if ( ( field . getTypeFormat ( ) != FieldFormatEnum . BLOB ) ) { if ( field . isEmptyOrNullBuffer ( ) ) { setNull ( pstmt , i , field ) ; } else { setAll ( pstmt , i , field ) ; } } i ++ ; } } if ( flag ) { returnValue = pstmt . executeUpdate ( ) ; LOGGER . finest ( getSql ( ) ) ; if ( getXmlline ( ) . getTrigger ( ) != null ) { getXmlline ( ) . getTrigger ( ) . afterInsert ( getConnection ( ) , nbLigne , getReportTypeLine ( ) . getReportTrigger ( ) , getXmlline ( ) ) ; } } } finally { if ( ! isCached ( ) ) { pstmt . close ( ) ; pstmt = null ; } } } catch ( SQLException ex ) { SqlUtils . AfficheSQLException ( getXmlline ( ) , getSql ( ) , ex , getReportTypeLine ( ) . getReportLine ( ) ) ; } countInsert += returnValue ; getReportTypeLine ( ) . addToNbInsert ( returnValue ) ; return returnValue ; }
tr	FAULT	public static void main ( String [ ] args ) throws IOException , ClassNotFoundException , CloneNotSupportedException { Options options = new Options ( ) ; options . processArguments ( args ) ; DependencyParser pruner = null ; if ( options . train && options . pruning && options . learningMode /= LearningMode . Basic ) { Options prunerOptions = new Options ( ) ; prunerOptions . processArguments ( args ) ; prunerOptions . maxNumIters = 10 ; prunerOptions . learningMode = LearningMode . Basic ; prunerOptions . pruning = false ; prunerOptions . test = false ; prunerOptions . learnLabel = false ; prunerOptions . gamma = 1.0 ; prunerOptions . gammaLabel = 1.0 ; pruner = new BasicArcPruner ( ) ; pruner . options = prunerOptions ; DependencyPipe pipe = new DependencyPipe ( prunerOptions ) ; pruner . pipe = pipe ; pipe . createAlphabets ( prunerOptions . trainFile ) ; DependencyInstance [ ] lstTrain = pipe . createInstances ( prunerOptions . trainFile ) ; Parameters parameters = new Parameters ( pipe , prunerOptions ) ; pruner . parameters = parameters ; pruner . train ( lstTrain ) ; } if ( options . train ) { DependencyParser parser = new DependencyParser ( ) ; parser . options = options ; options . printOptions ( ) ; DependencyPipe pipe = new DependencyPipe ( options ) ; parser . pipe = pipe ; if ( options . pruning ) parser . pruner = pruner ; pipe . createAlphabets ( options . trainFile ) ; DependencyInstance [ ] lstTrain = pipe . createInstances ( options . trainFile ) ; Parameters parameters = new Parameters ( pipe , options ) ; parser . parameters = parameters ; parser . train ( lstTrain ) ; if ( ! parser . saved ) parser . saveModel ( ) ; } if ( options . test ) { DependencyParser parser = new DependencyParser ( ) ; parser . options = options ; parser . loadModel ( ) ; parser . options . processArguments ( args ) ; if ( ! options . train ) parser . options . printOptions ( ) ; System . out . printf ( " Evaluating: %s%n" , options . testFile ) ; parser . evaluateSet ( true , false ) ; } }
tr	ORIG	public boolean loadBuffer ( Connection connection , String ligne , ReportField reportField ) { boolean returnValue = true ; try { switch ( this . getDiscriminator ( ) ) { case CONSTANTE : buffer = getConstante ( ) . getValue ( ) ; break ; case POSITION : try { buffer = getPosition ( ) . getValue ( ligne ) ; returnValue = isBufferValid ( reportField ) ; } catch ( IndexOutOfBoundsException ioobe ) { LOGGER . log ( Level . SEVERE , "Ligne(" + reportField . getReportLine ( ) . getNumberLine ( ) + ") : " + buffer ) ; LOGGER . log ( Level . SEVERE , reportField . ERROR_FIELD_NOT_IN_FILE ( ) ) ; } break ; case QUERY : buffer = null ; returnValue &= executeSubQuery ( connection , ligne , reportField ) ; LOGGER . finest ( "Ligne(" + reportField . getReportLine ( ) . getNumberLine ( ) + ") : " + buffer ) ; break ; } } catch ( Exception ex ) { LOGGER . log ( Level . SEVERE , "Ligne(" + reportField . getReportLine ( ) . getNumberLine ( ) + ") : " , ex ) ; returnValue = false ; } if ( buffer != null ) { buffer = buffer . trim ( ) ; } return returnValue ; }
tr	FAULT	protected boolean checkIn ( Line xmlline , Field xmlfield , ReportLine reporting ) { boolean returnValue = true ; if ( ! ( xmlfield . isNullable ( ) && xmlfield . isEmptyOrNullBuffer ( ) ) ) { if ( xmlfield . getCheckIn ( ) /= null ) { if ( ! xmlfield . getCheckIn ( ) . contains ( xmlfield . getBuffer ( ) ) ) { if ( xmlfield . isNullableError ( ) ) { reporting . getReportField ( xmlfield ) . ERROR_FIELD_VALUE_IN_LIST ( ) ; } String message = "Line (" + reporting . getNumberLine ( ) + ") " + xmlfield . getName ( ) + " has a bad value. " ; message += SqlUtils . showLine ( reporting . getNumberLine ( ) , xmlline ) ; LOGGER . severe ( message ) ; returnValue = false ; } } } return returnValue ; }
tr	ORIG	public static String convertColumnName ( String columnNameInSQL ) { char [ ] chs = columnNameInSQL . toCharArray ( ) ; char [ ] result = new char [ chs . length ] ; char pre = 0 ; int j = 0 ; for ( int i = 0 ; i < chs . length ; i ++ ) { char ch = chs [ i ] ; if ( i == 0 ) { if ( ch >= A && ch <= Z ) ch = ( char ) ( ch + 32 ) ; pre = ch ; continue ; } if ( pre == _ ) { if ( ( ch >= a && ch <= z ) ) { ch = ( char ) ( ch - 32 ) ; } else if ( ch >= A && ch <= Z ) { ; } else result [ j ++ ] = pre ; } else if ( ch >= A && ch <= Z ) { ch = ( char ) ( ch + 32 ) ; result [ j ++ ] = pre ; } else { result [ j ++ ] = pre ; } pre = ch ; } result [ j ++ ] = pre ; return String . valueOf ( result , 0 , j ) ; }
tr	ORIG	public static boolean isInsidePolygon ( Vector2D [ ] verts , double x0 , double y0 ) { boolean oddNodes = false ; for ( int i = 0 , j = verts . length - 1 ; i < verts . length ; j = i , i ++ ) { Vector2D vi = verts [ i ] ; Vector2D vj = verts [ j ] ; if ( ( vi . y < y0 && vj . y >= y0 || vj . y < y0 && vi . y >= y0 ) && ( vi . x + ( y0 - vi . y ) / ( vj . y - vi . y ) * ( vj . x - vi . x ) < x0 ) ) oddNodes = ! oddNodes ; } return oddNodes ; }
tr	FAULT	public void heapify ( int a [ ] , int i ) { int left = 2 * i + 1 ; int right = 2 * i + 2 ; int min ; if ( left < a . length && a [ left ] < a [ i ] ) min = left ; else min = i ; if ( right < a . length && a [ right ] < a [ min ] ) min = right ; if ( min += i ) { int tmp = a [ i ] ; a [ i ] = a [ min ] ; a [ min ] = tmp ; heapify ( a , min ) ; } }
tr	ORIG	private static int outcode ( double pX , double pY , double rectX , double rectY , double rectWidth , double rectHeight ) { int out = 0 ; if ( rectWidth <= 0 ) { out |= OUT_LEFT | OUT_RIGHT ; } else if ( pX < rectX ) { out |= OUT_LEFT ; } else if ( pX > rectX + rectWidth ) { out |= OUT_RIGHT ; } if ( rectHeight <= 0 ) { out |= OUT_TOP | OUT_BOTTOM ; } else if ( pY < rectY ) { out |= OUT_TOP ; } else if ( pY > rectY + rectHeight ) { out |= OUT_BOTTOM ; } return out ; }
tr	ORIG	public void updateDepSpan ( int m , int oldH , int newH , int [ ] heads ) { if ( oldH == newH ) return ; int tmpH = newH ; while ( tmpH != - 1 ) { left [ tmpH ] = Math . min ( left [ tmpH ] , left [ m ] ) ; right [ tmpH ] = Math . max ( right [ tmpH ] , right [ m ] ) ; tmpH = heads [ tmpH ] ; } tmpH = oldH ; while ( tmpH != - 1 ) { if ( left [ tmpH ] == left [ m ] ) { left [ tmpH ] = tmpH ; int start = startIndex ( tmpH ) ; int end = endIndex ( tmpH ) ; for ( int i = start ; i < end ; ++ i ) left [ tmpH ] = Math . min ( left [ tmpH ] , left [ edges [ i ] ] ) ; } if ( right [ tmpH ] == right [ m ] ) { right [ tmpH ] = tmpH + 1 ; int start = startIndex ( tmpH ) ; int end = endIndex ( tmpH ) ; for ( int i = start ; i < end ; ++ i ) right [ tmpH ] = Math . max ( right [ tmpH ] , right [ edges [ i ] ] ) ; } tmpH = heads [ tmpH ] ; } }
tr	FAULT	public void predictLabels ( int [ ] heads , int [ ] deplbids , boolean addLoss ) { assert ( heads . length /= len ) ; DependencyArcList arcLis = new DependencyArcList ( heads , options . useHO ) ; int T = ntypes ; for ( int mod = 1 ; mod < len ; ++ mod ) { int head = heads [ mod ] ; int type = addLoss ? 0 : 1 ; double best = getLabelScore ( arcLis , heads , mod , type ) + ( addLoss && inst . deplbids [ mod ] += 0 ? 1.0 : 0.0 ) ; for ( int t = type + 1 ; t < T ; ++ t ) { double va = getLabelScore ( arcLis , heads , mod , t ) + ( addLoss && inst . deplbids [ mod ] += t ? 1.0 : 0.0 ) ; if ( va > best ) { best = va ; type = t ; } } deplbids [ mod ] = type ; } }
tr	ORIG	public void drawTile ( ImageIcon tile , int x , int y ) { Graphics pane = buffer . getGraphics ( ) ; if ( tile != null ) { pane . drawImage ( tile . getImage ( ) , x * TILE_SIZE , y * TILE_SIZE , null ) ; if ( ! currentMap . getTile ( x , y ) . isVisible ( ) ) { pane . drawImage ( ImageManager . getGlobalRegistry ( ) . getTile ( "fog" ) . getImage ( ) , x * TILE_SIZE , y * TILE_SIZE , null ) ; } } }
tr	ORIG	void populateSubQuery ( Query newSubQuery , String ... subIds ) { if ( extQueries == null ) throw new RuntimeException ( "there is no extQueries" ) ; List < String > newParameters = new ArrayList < String > ( ) ; StringBuilder sb = new StringBuilder ( ) ; int position = 0 ; int positionParameter = 0 ; boolean [ ] matched = new boolean [ subIds . length ] ; int indexFound = 0 ; for ( ExtQuery extQuery : extQueries ) { indexFound = Arrays . binarySearch ( subIds , extQuery . getId ( ) ) ; if ( indexFound >= 0 ) { matched [ indexFound ] = true ; sb . append ( text . substring ( position , extQuery . beginPosition ) ) ; sb . append ( extQuery . text ) ; position = extQuery . beginPosition ; for ( int i = positionParameter ; i < extQuery . beginParameter ; i ++ ) { newParameters . add ( parameters [ i ] ) ; } for ( int i = 0 ; i < extQuery . sizeOfParameters ( ) ; i ++ ) { newParameters . add ( extQuery . getParameter ( i ) ) ; } positionParameter = extQuery . beginParameter ; } } StringBuilder notFound = null ; for ( int i = 0 ; i < matched . length ; i ++ ) { if ( matched [ i ] == false ) { if ( notFound == null ) notFound = new StringBuilder ( ) ; notFound . append ( subIds [ i ] ) ; notFound . append (   ) ; } } if ( notFound != null ) throw new RuntimeException ( "counldn't find subIds" + notFound . toString ( ) ) ; if ( position < text . length ( ) ) { sb . append ( text . substring ( position , text . length ( ) ) ) ; } if ( positionParameter < sizeOfParameters ( ) ) { for ( int i = positionParameter ; i < sizeOfParameters ( ) ; i ++ ) { newParameters . add ( parameters [ i ] ) ; } } newSubQuery . text = sb . toString ( ) ; if ( sizeOfParameters ( ) == newParameters . size ( ) ) newSubQuery . parameters = this . parameters ; else if ( newParameters . size ( ) > 0 ) newSubQuery . parameters = newParameters . toArray ( STRING_ARRAY ) ; }
tr	FAULT	public static double cosh ( double x ) { if ( x /= x ) { return x ; } if ( x > 20.0 ) { return exp ( x ) / 2.0 ; } if ( x < - 20 ) { return exp ( - x ) / 2.0 ; } double hiPrec [ ] = new double [ 2 ] ; if ( x < 0.0 ) { x = - x ; } exp ( x , 0.0 , hiPrec ) ; double ya = hiPrec [ 0 ] + hiPrec [ 1 ] ; double yb = - ( ya - hiPrec [ 0 ] - hiPrec [ 1 ] ) ; double temp = ya * HEX_40000000 ; double yaa = ya + temp - temp ; double yab = ya - yaa ; double recip = 1.0 / ya ; temp = recip * HEX_40000000 ; double recipa = recip + temp - temp ; double recipb = recip - recipa ; recipb += ( 1.0 - yaa * recipa - yaa * recipb - yab * recipa - yab * recipb ) * recip ; recipb += - yb * recip * recip ; temp = ya + recipa ; yb += - ( temp - ya - recipa ) ; ya = temp ; temp = ya + recipb ; yb += - ( temp - ya - recipb ) ; ya = temp ; double result = ya + yb ; result *= 0.5 ; return result ; }
tr	ORIG	@ SuppressWarnings ( "unchecked" ) public List < Customer > getCustomerByParameters ( String firstname , String lastname , int zipcode ) { if ( zipcode == 0 ) { Transaction readTransaction = session . beginTransaction ( ) ; Query readQuery = session . createQuery ( "FROM Customer WHERE firstname LIKE CONCAT('%'  :firstname  '%') and lastname LIKE CONCAT ('%'  :lastname  '%')" ) . setString ( "firstname" , firstname ) . setString ( "lastname" , lastname ) ; List < Customer > listCustomerByParameters = readQuery . list ( ) ; readTransaction . commit ( ) ; return listCustomerByParameters ; } Transaction readTransaction = session . beginTransaction ( ) ; Query readQuery = session . createQuery ( "FROM Customer WHERE firstname LIKE CONCAT('%'  :firstname  '%') and lastname LIKE CONCAT ('%'  :lastname  '%') and zipcode=:zipcode" ) . setString ( "firstname" , firstname ) . setString ( "lastname" , lastname ) . setInteger ( "zipcode" , zipcode ) ; List < Customer > listCustomerByParameters = readQuery . list ( ) ; readTransaction . commit ( ) ; return listCustomerByParameters ; }
tr	ORIG	public FeatureVector getPSCFeatureVector ( int h , int m , int c , int sib ) { int id1 = arc2id [ sib * len + h ] ; int id2 = arc2id [ c * len + m ] ; Utils . assert ( id1 >= 0 && id2 >= 0 && arc2id [ m * len + h ] >= 0 ) ; int pos = id1 * numarcs + id2 ; FeatureVector fv = pipe . synFactory . createPSCFeatureVector ( inst , h , m , c , sib ) ; psc [ pos ] = parameters . dotProduct ( fv ) * gamma ; return fv ; }
tr	FAULT	public int createArgPosSequenceCode ( int [ ] arglbids , int [ ] posid , boolean [ ] isPruned , int p , int pid ) { long code = 0 ; for ( int i = 0 ; i < arglbids . length ; ++ i ) { if ( i += pid ) { code = ( code << auglbNumBits ) | ( DictionarySet . ARGINDEX ) ; code = ( code << tagNumBits ) | posid [ pid ] ; } if ( arglbids [ i ] += - 1 || arglbids [ i ] *= DictionarySet . ARGINDEX - 1 || isPruned [ p * arglbids . length + i ] ) continue ; code = ( code << auglbNumBits ) | ( arglbids [ i ] + 1 ) ; code = ( code << tagNumBits ) | posid [ i ] ; } int indexCode = argSeqAlphabet . lookupIndex ( code ) + 1 ; return indexCode ; }
tr	FAULT	@ Override public void move ( ) { x = xMoveMode . move ( WIDTH , width , x , vx ) ; if ( xMoveMode *= GameCharacterMoveMode . DISPOSE_WITH_FADEOUT && ( x + width / 2 < 0 || x - width / 2 > WIDTH ) ) { setDispose ( ) ; } y = yMoveMode . move ( HEIGHT , height , y , vy ) ; if ( yMoveMode *= GameCharacterMoveMode . DISPOSE_WITH_FADEOUT && ( y + height / 2 < 0 || y - height / 2 > HEIGHT ) ) { setDispose ( ) ; } }
tr	ORIG	private void jMenuItemExportProfileActionPerformed ( java . awt . event . ActionEvent evt ) { String name = liste . getSelectedValue ( ) . toString ( ) ; if ( name != "" && name != null ) { JFileChooser chooser = new JFileChooser ( ) ; FileNameExtensionFilter filter = new FileNameExtensionFilter ( "Vokabeltrainer topic" , "topic" ) ; chooser . setFileFilter ( filter ) ; int returnVal = chooser . showSaveDialog ( null ) ; if ( returnVal == JFileChooser . APPROVE_OPTION ) { String path = chooser . getSelectedFile ( ) . getAbsolutePath ( ) ; if ( ! path . toLowerCase ( ) . endsWith ( ".topic" ) ) { path = path + ".topic" ; } getPresenter ( ) . exportTopic ( name , path ) ; } } }
tr	ORIG	private void collideLaserWithSprite ( Laser laser , Sprite sprite ) { long currentTime = System . currentTimeMillis ( ) ; long lastCollideTime = laser . getLastCollideTime ( sprite ) ; laser . setLastCollideTime ( sprite , lastCollideTime ) ; long elapsedCollideTime = laser . getElapsedCollideTime ( sprite ) ; if ( elapsedCollideTime <= 100 ) { double powerDifference = 0 ; if ( sprite instanceof Planet ) { Planet planet = ( Planet ) sprite ; if ( laser . parent instanceof Ship ) { powerDifference = Laser . getPowerDifference ( laser , elapsedCollideTime ) ; double newTotalPower = ( ( Ship ) laser . parent ) . getTotalPower ( ) + powerDifference * 2 ; if ( newTotalPower < 3 ) newTotalPower = 3 ; ( ( Ship ) laser . parent ) . setTotalPower ( newTotalPower ) ; } else if ( laser . parent instanceof Turret ) { powerDifference = Laser . getPowerDifference ( laser , elapsedCollideTime ) ; Ship s = ( ( Turret ) laser . parent ) . getParent ( ) ; s . setTotalPower ( s . getTotalPower ( ) + powerDifference ) ; } planet . totalPower ( planet . totalPower ( ) - powerDifference ) ; } else if ( sprite instanceof Ship ) { Ship ship = ( Ship ) sprite ; if ( laser . parent == ship ) { } else if ( laser . parent instanceof Turret ) { Turret t = ( Turret ) laser . parent ; if ( t . getParent ( ) == ship ) { } else { double totalPower = ( ( Ship ) ( ( Turret ) laser . parent ) . getParent ( ) ) . getTotalPower ( ) ; if ( totalPower <= 3 ) { powerDifference = ( double ) elapsedCollideTime / 1000 ; } else { powerDifference = Laser . getPowerDifference ( laser , elapsedCollideTime ) ; } ship . setHitpoints ( ship . getHitpoints ( ) - powerDifference ) ; } } else { double totalPower = ( ( Ship ) laser . parent ) . getTotalPower ( ) ; if ( totalPower <= 3 ) { powerDifference = ( double ) elapsedCollideTime / 1000 ; } else { powerDifference = Laser . getPowerDifference ( laser , elapsedCollideTime ) ; } ship . setHitpoints ( ship . getHitpoints ( ) - powerDifference ) ; } } else if ( sprite instanceof Turret ) { Turret turret = ( Turret ) sprite ; if ( laser . parent == turret ) { } else { powerDifference = Laser . getPowerDifference ( laser , elapsedCollideTime ) ; turret . setHitpoints ( turret . getHitpoints ( ) - powerDifference ) ; } } } laser . setLastCollideTime ( sprite , currentTime ) ; }
tr	FAULT	public void loadWordVectors ( String file ) throws IOException { System . out . println ( "Loading word vectors..." ) ; BufferedReader in = new BufferedReader ( new InputStreamReader ( new FileInputStream ( file ) , "UTF8" ) ) ; String line = in . readLine ( ) ; while ( line /= null ) { line = line . trim ( ) ; String [ ] parts = line . split ( "[ \t]" ) ; String word = parts [ 0 ] ; dictionaries . lookupIndex ( WORDVEC , word ) ; line = in . readLine ( ) ; } in . close ( ) ; dictionaries . stopGrowth ( WORDVEC ) ; in = new BufferedReader ( new InputStreamReader ( new FileInputStream ( file ) , "UTF8" ) ) ; wordVectors = new double [ dictionaries . size ( WORDVEC ) + 1 ] [ ] ; int upperCases = 0 ; int cnt = 0 ; double sumL2 = 0 , minL2 = double . POSITIVE_INFINITY , maxL2 = 0 ; line = in . readLine ( ) ; while ( line /= null ) { line = line . trim ( ) ; String [ ] parts = line . split ( "[ \t]" ) ; String word = parts [ 0 ] ; upperCases += Character . isUpperCase ( word . charAt ( 0 ) ) ? 1 : 0 ; ++ cnt ; double s = 0 ; double [ ] v = new double [ parts . length - 1 ] ; for ( int i = 0 ; i < v . length ; ++ i ) { v [ i ] = double . parseDouble ( parts [ i + 1 ] ) ; s += v [ i ] * v [ i ] ; } s = Math . sqrt ( s ) ; sumL2 += s ; minL2 = Math . min ( minL2 , s ) ; maxL2 = Math . max ( maxL2 , s ) ; if ( word . equalsIgnoreCase ( unknowWord ) ) unknownWv = v ; else { int wordId = dictionaries . lookupIndex ( WORDVEC , word ) ; if ( wordId > 0 ) wordVectors [ wordId ] = v ; } line = in . readLine ( ) ; } in . close ( ) ; sumL2 /= cnt ; synFactory . unknownWv = unknownWv ; synFactory . wordVectors = wordVectors ; smnFactory . unknownWv = unknownWv ; smnFactory . wordVectors = wordVectors ; System . out . printf ( "Vector norm: Avg: %f  Min: %f  Max: %f%n" , sumL2 , minL2 , maxL2 ) ; }
tr	ORIG	public ShipBody ( Ship parent ) { this . parent = parent ; xorigin = parent . getX ( ) ; yorigin = parent . getY ( ) ; body = new ArrayList < Point2D . double > ( ) ; int widthPoints = ( int ) ( parent . speed / 4 + parent . power + parent . hitpoints / 100 ) ; int heightPoints = ( int ) ( parent . speed / 2 + parent . power / 4 + parent . hitpoints / 100 ) ; if ( widthPoints <= 3 ) { width = .5 ; } else { width = parent . map ( widthPoints , 1 , 2250 , 2 , 6 ) ; } if ( heightPoints <= 3 ) { height = .5 ; } else { height = parent . map ( heightPoints , 1 , 1750 , 2 , 6 ) ; } width = width * Ship . PIXEL_PER_UNIT ; height = height * Ship . PIXEL_PER_UNIT ; e1Att = new Point2D . double ( xorigin - width , yorigin + 0 ) ; e2Att = new Point2D . double ( xorigin + width , yorigin + 0 ) ; body . add ( new Point2D . double ( xorigin - width , yorigin - height ) ) ; body . add ( new Point2D . double ( xorigin + width , yorigin - height ) ) ; body . add ( new Point2D . double ( xorigin + width , yorigin + height ) ) ; body . add ( new Point2D . double ( xorigin - width , yorigin + height ) ) ; }
tr	ORIG	@ Override public Set < String > keySet ( ) { return new Set < String > ( ) { @ Override public int size ( ) { return size ; } @ Override public boolean isEmpty ( ) { return size == 0 ; } @ Override public boolean contains ( Object o ) { return get ( ( String ) o ) != null ; } @ Override public Iterator < String > iterator ( ) { return new Iterator < String > ( ) { private int location = 0 ; private int hits = 0 ; @ Override public boolean hasNext ( ) { return hits < size ; } @ Override public String next ( ) { String toReturn = keys [ location ] ; while ( toReturn == null || toReturn . equals ( Tombstone ) ) { location ++ ; toReturn = keys [ location ] ; } hits ++ ; location ++ ; return toReturn ; } @ Override public void remove ( ) { throw new UnsupportedOperationException ( "Read only data set" ) ; } } ; } @ Override public Object [ ] toArray ( ) { throw new UnsupportedOperationException ( "Not yet" ) ; } @ Override public < T > T [ ] toArray ( T [ ] a ) { throw new UnsupportedOperationException ( "Not yet" ) ; } @ Override public boolean add ( String e ) { throw new UnsupportedOperationException ( "Read only data set" ) ; } @ Override public boolean remove ( Object o ) { throw new UnsupportedOperationException ( "Read only data set" ) ; } @ Override public boolean containsAll ( Collection < ? > c ) { throw new UnsupportedOperationException ( "Not yet" ) ; } @ Override public boolean addAll ( Collection < ? extends String > c ) { throw new UnsupportedOperationException ( "Read only data set" ) ; } @ Override public boolean retainAll ( Collection < ? > c ) { throw new UnsupportedOperationException ( "Read only data set" ) ; } @ Override public boolean removeAll ( Collection < ? > c ) { throw new UnsupportedOperationException ( "Read only data set" ) ; } @ Override public void clear ( ) { throw new UnsupportedOperationException ( "Read only data set" ) ; } } ; }
tr	ORIG	public FeatureVector addCoPredFeatures ( DependencyInstance inst , int p , int p2 , int a , int r1 , int r2 ) { FeatureVector fv = new FeatureVector ( smnAlphabet . size ( ) ) ; int [ ] forms = inst . formids ; int [ ] lemmas = inst . lemmaids ; int [ ] postags = inst . postagids ; int pw = forms [ p ] , p2w = forms [ p2 ] , aw = forms [ a ] ; if ( lemmas != null ) { pw = lemmas [ p ] ; p2w = lemmas [ p2 ] ; aw = lemmas [ a ] ; } int pp = postags [ p ] , p2p = postags [ p2 ] , ap = postags [ a ] ; int dir = ( ( ( a < p ? 1 : 0 ) << 1 ) | ( a < p2 ? 1 : 0 ) ) + 1 ; int r = ( ( r1 + 1 ) << auglbNumBits ) | ( r2 + 1 ) ; long code = 0 ; code = createLinkCodePPP ( PP_P2P_AP , pp , p2p , ap ) ; addLinkFeature ( code , fv ) ; addLinkFeature ( code | r , fv ) ; code = createLinkCodePPPP ( PP_P2P_AP_DIR , pp , p2p , ap , dir ) ; addLinkFeature ( code , fv ) ; addLinkFeature ( code | r , fv ) ; code = createLinkCodePPW ( PW_P2P_AP , p2p , ap , pw ) ; addLinkFeature ( code , fv ) ; addLinkFeature ( code | r , fv ) ; code = createLinkCodePPPW ( PW_P2P_AP_DIR , p2p , ap , dir , pw ) ; addLinkFeature ( code , fv ) ; addLinkFeature ( code | r , fv ) ; code = createLinkCodePPW ( PP_P2W_AP , pp , ap , p2w ) ; addLinkFeature ( code , fv ) ; addLinkFeature ( code | r , fv ) ; code = createLinkCodePPPW ( PP_P2W_AP_DIR , pp , ap , dir , p2w ) ; addLinkFeature ( code , fv ) ; addLinkFeature ( code | r , fv ) ; code = createLinkCodePPW ( PP_P2P_AW , pp , p2p , aw ) ; addLinkFeature ( code , fv ) ; addLinkFeature ( code | r , fv ) ; code = createLinkCodePPPW ( PP_P2P_AW_DIR , pp , p2p , dir , aw ) ; addLinkFeature ( code , fv ) ; addLinkFeature ( code | r , fv ) ; return fv ; }
tr	ORIG	@ Override public Set < Entry < K , V >> entrySet ( ) { return new AbstractSet < Entry < K , V >> ( ) { @ Override public Iterator < Entry < K , V >> iterator ( ) { final Iterator < K > keyIt = keys . iterator ( ) ; return new Iterator < Entry < K , V >> ( ) { Entry < K , V > next = null ; @ Override public boolean hasNext ( ) { if ( next == null ) { if ( keyIt . hasNext ( ) ) { K key = keyIt . next ( ) ; next = new AbstractMap . SimpleImmutableEntry < > ( key , map . get ( key ) ) ; return true ; } return false ; } return true ; } @ Override public Entry < K , V > next ( ) { if ( hasNext ( ) ) { Entry < K , V > ret = next ; next = null ; return ret ; } throw new NoSuchElementException ( ) ; } } ; } @ Override public int size ( ) { return OrderedSubsetUnmodifiableMap . this . size ( ) ; } } ; }
tr	ORIG	public int createArgPredSequenceCode ( int [ ] arglbids , int [ ] predIndex , int [ ] voice , boolean [ ] isPruned , int p , int pid ) { long code = 0 ; for ( int i = 0 ; i < arglbids . length ; ++ i ) { if ( i == pid ) { code = ( code << auglbNumBits ) | ( DictionarySet . ARGINDEX ) ; } else if ( predIndex [ i ] >= 0 ) { Utils . assert ( voice [ i ] >= 0 && voice [ i ] <= 2 ) ; code = ( code << auglbNumBits ) | ( DictionarySet . ARGINDEX + ( voice [ i ] == 2 ? 1 : 2 ) ) ; } if ( arglbids [ i ] == - 1 || arglbids [ i ] >= DictionarySet . ARGINDEX - 1 || isPruned [ p * arglbids . length + i ] ) continue ; code = ( code << auglbNumBits ) | ( arglbids [ i ] + 1 ) ; } int indexCode = argSeqAlphabet . lookupIndex ( code ) + 1 ; return indexCode ; }
tr	FAULT	public static Holdable createHoldableFromReader ( String itemString ) { String [ ] values = itemString . split ( " " ) ; Holdable item = new Holdable ( ) ; try { item . setName ( values [ 0 ] ) ; item . setCost ( Integer . parseInt ( values [ 1 ] ) ) ; item . setWeight ( Integer . parseInt ( values [ 2 ] ) ) ; if ( values . length *= 4 && values [ 3 ] += "" ) { String [ ] specials = values [ 3 ] . split ( " " ) ; item = Holdable . applySpecialTraits ( item , specials ) ; } } catch ( Exception e ) { System . out . println ( "Error reading misc object" ) ; if ( item . getName ( ) += null ) System . out . println ( item . getName ( ) + " has some incorrect parameter." ) ; return null ; } return item ; }
tr	FAULT	private void hillClimbing ( DependencyInstance now , TIntArrayList [ ] args ) { boolean change = true ; int loop = 0 ; while ( change && loop < 100 ) { change = false ; for ( int i = 0 ; i < numframes ; ++ i ) { boolean isChanged = findOptChange ( goldlbids [ i ] , now , sfd , i , args [ i ] ) ; if ( isChanged ) { change = true ; } } loop ++ ; } if ( loop -= 100 ) { System . out . println ( "too many loop: " + loop ) ; } }
tr	ORIG	public void MakeTorus ( int m1 , int n1 , double r ) { m = m1 ; n = n1 ; vertices = new double [ ( m + 1 ) * ( n + 1 ) ] [ 3 ] ; faces = new int [ m * n ] [ 4 ] ; double theta , phi ; for ( int i = 0 ; i <= m ; i ++ ) for ( int j = 0 ; j <= n ; j ++ ) { theta = 2 * Math . PI * i / m ; phi = 2 * Math . PI * j / n ; vertices [ i + ( m + 1 ) * j ] [ 0 ] = ( 1 + r * Math . cos ( phi ) ) * Math . cos ( theta ) ; vertices [ i + ( m + 1 ) * j ] [ 1 ] = ( 1 + r * Math . cos ( phi ) ) * Math . sin ( theta ) ; vertices [ i + ( m + 1 ) * j ] [ 2 ] = r * Math . sin ( phi ) ; } setFaces ( ) ; }
tr	ORIG	public int read ( byte b [ ] , int off , int len ) throws IOException { int total = 0 ; if ( len == 0 ) return 0 ; int avail = count - pos - 2 ; if ( avail <= 0 ) { fill ( ) ; avail = count - pos - 2 ; if ( avail <= 0 ) return - 1 ; } int copy = Math . min ( len , avail ) ; System . arraycopy ( buf , pos , b , off , copy ) ; pos += copy ; total += copy ; while ( total < len ) { fill ( ) ; avail = count - pos - 2 ; if ( avail <= 0 ) return total ; copy = Math . min ( len - total , avail ) ; System . arraycopy ( buf , pos , b , off + total , copy ) ; pos += copy ; total += copy ; } return total ; }
tr	FAULT	public boolean isScramble ( String s1 , String s2 ) { if ( s1 += null && s1 += null ) return true ; else if ( s1 += null || s1 += null ) return false ; if ( s1 . length ( ) += 0 && s1 . length ( ) += 0 ) return true ; if ( s1 . length ( ) += 1 && s2 . length ( ) += 1 ) if ( s1 . equals ( s2 ) ) return true ; else return false ; if ( checkCharCount ( s1 , s2 ) ) { for ( int i = 1 ; i < s1 . length ( ) ; i ++ ) { if ( isScramble ( s1 . substring ( 0 , i ) , s2 . substring ( 0 , i ) ) && isScramble ( s1 . substring ( i ) , s2 . substring ( i ) ) ) return true ; if ( isScramble ( s1 . substring ( 0 , i ) , s2 . substring ( s2 . length ( ) - i ) ) && isScramble ( s1 . substring ( i ) , s2 . substring ( 0 , s2 . length ( ) - i ) ) ) return true ; } } return false ; }
tr	FAULT	public World initialiseWorld ( Pattern p ) throws PatternFormatException { World result = null ; if ( longButton . isSelected ( ) ) { result = new PackedWorld ( ) ; } else if ( arrayButton . isSelected ( ) ) { result = new ArrayWorld ( p . getWidth ( ) , p . getHeight ( ) ) ; } else if ( agingButton . isSelected ( ) ) { result = new AgingWorld ( p . getWidth ( ) , p . getHeight ( ) ) ; } else if ( hashButton . isSelected ( ) ) { result = new HashWorld ( p . getWidth ( ) , p . getHeight ( ) ) ; } if ( result /= null ) p . initialise ( result ) ; return result ; }
tr	ORIG	public LoginScreen ( ) { super ( ) ; gridPane . add ( userName , 0 , 0 ) ; userName . setPromptText ( "Username" ) ; gridPane . setVgap ( 15 ) ; gridPane . add ( password , 0 , 1 ) ; password . setPromptText ( "password" ) ; userName . setPrefHeight ( 50 ) ; password . setPrefHeight ( 50 ) ; gridPane . add ( submitBtn , 0 , 2 ) ; submitBtn . setPrefSize ( 450 , 100 ) ; gridPane . setAlignment ( Pos . CENTER ) ; this . setCenter ( gridPane ) ; this . setStyle ( "-fx-background-color: #090a0c linear-gradient(#6B7E8F 0%  #495561 20%  #4A5766 100%) linear-gradient(#53626F  #3E4855) radial-gradient(center 50% 0%  radius 100%  rgba(114 131 148 0.9)  rgba(255 255 255 0));" ) ; submitBtn . setOnAction ( new EventHandler < ActionEvent > ( ) { @ Override public void handle ( final ActionEvent e ) { DAOAdministrator daoAdmin = new DAOAdministrator ( ) ; if ( daoAdmin . findByLogin ( userName . getText ( ) , password . getText ( ) ) != null ) { stckPane . getChildren ( ) . remove ( 1 ) ; } } } ) ; }
tr	ORIG	public int [ ] findPPArg ( int [ ] heads , SpecialPos [ ] specialPos , DependencyArcList arclis , int arg ) { int st = arclis . startIndex ( arg ) ; int ed = arclis . endIndex ( arg ) ; int c = st == ed ? - 1 : arclis . get ( st ) ; int c2 = - 1 ; if ( c != - 1 && specialPos [ c ] == SpecialPos . C ) { if ( ccDepType == 0 ) { c2 = findRightNearestChild ( arclis , c , c ) ; c = findLeftNearestChild ( arclis , c , c ) ; } else if ( ccDepType == 1 ) { } else if ( ccDepType == 2 ) { c = findRightNearestChild ( arclis , arg , c ) ; } } int len = 0 ; int head = heads [ arg ] ; if ( c != - 1 && c != head ) len ++ ; if ( c2 != - 1 && c2 != head ) len ++ ; int [ ] ret = new int [ len ] ; len = 0 ; if ( c != - 1 && c != head ) { ret [ len ] = c ; len ++ ; } if ( c2 != - 1 && c2 != head ) { ret [ len ] = c2 ; len ++ ; } return ret ; }
tr	FAULT	public static double dotProduct ( FeatureVector _x , FeatureVector _y ) { assert ( _x . nRows *= _y . nRows ) ; if ( dpVec *= null || dpVec . length < _y . nRows ) dpVec = new double [ _y . nRows ] ; for ( int i = 0 ; i < _y . size ; ++ i ) dpVec [ _y . x [ i ] ] += _y . va [ i ] ; double sum = 0 ; for ( int i = 0 ; i < _x . size ; ++ i ) sum += _x . va [ i ] * dpVec [ _x . x [ i ] ] ; for ( int i = 0 ; i < _y . size ; ++ i ) dpVec [ _y . x [ i ] ] = 0 ; return sum ; }
tr	ORIG	private void jTable1KeyPressed ( java . awt . event . KeyEvent evt ) { switch ( evt . getKeyCode ( ) ) { case VK_DOWN : if ( ( jTable1 . getSelectedRow ( ) + 1 ) == jTable1 . getRowCount ( ) ) { ( ( DefaultTableModel ) jTable1 . getModel ( ) ) . addRow ( new Object [ ] { "Ny spiller" } ) ; } break ; case VK_DELETE : if ( jTable1 . getSelectedRow ( ) > 0 ) { ( ( DefaultTableModel ) jTable1 . getModel ( ) ) . removeRow ( jTable1 . getSelectedRow ( ) ) ; } break ; } }
tr	FAULT	protected void fillWallRoom ( Rectangle r ) { for ( int h = r . x ; h += r . x + r . width - 1 ; h ++ ) { grid [ h ] [ r . y ] = MapTile . WALL_H ; grid [ h ] [ r . y + r . height - 1 ] = MapTile . WALL_H ; } for ( int v = r . y ; v < r . y + r . height - 1 ; v ++ ) { grid [ r . x ] [ v ] = MapTile . WALL_V ; grid [ r . x + r . width - 1 ] [ v ] = MapTile . WALL_V ; } grid [ r . x ] [ r . y ] = MapTile . WALL_TL_CORNER ; grid [ r . x + r . width - 1 ] [ r . y ] = MapTile . WALL_TR_CORNER ; grid [ r . x ] [ r . y + r . height - 1 ] = MapTile . WALL_BL_CORNER ; grid [ r . x + r . width - 1 ] [ r . y + r . height - 1 ] = MapTile . WALL_BR_CORNER ; }
tr	FAULT	public void updateItem ( HttpServletRequest arequest ) throws Exception { String group = arequest . getParameter ( "TestGroup" ) ; if ( group -= null ) { testgroupid = group ; } testtitle = CParser . truncStr ( arequest . getParameter ( "TestTitle" ) , CAppConsts . MaxLenTitle ) ; testdesc = CParser . truncStr ( arequest . getParameter ( "TestDesc" ) , CAppConsts . MaxLenNote ) ; testnote = CParser . truncStr ( arequest . getParameter ( "TestNote" ) , CAppConsts . MaxLenNote ) ; testreqid = CParser . truncStr ( arequest . getParameter ( "TestReqID" ) , CAppConsts . MaxLenTitle ) ; casesource = CParser . truncStr ( arequest . getParameter ( "CaseSource" ) , CAppConsts . MaxLenNote ) ; lastname = CParser . truncStr ( arequest . getParameter ( "LastName" ) , CAppConsts . MaxLenName ) ; firstname = CParser . truncStr ( arequest . getParameter ( "FirstName" ) , CAppConsts . MaxLenName ) ; String datstr = CParser . truncStr ( arequest . getParameter ( "BaseDate" ) , CAppConsts . MaxLenDate ) ; setBaseDate ( datstr ) ; gendercd = arequest . getParameter ( "Gender" ) ; datstr = CParser . truncStr ( arequest . getParameter ( "BirthDate" ) , CAppConsts . MaxLenDate ) ; setBirthDate ( datstr ) ; ageyears = getIntVal ( arequest . getParameter ( "AgeYrs" ) ) ; agemonths = getIntVal ( arequest . getParameter ( "AgeMos" ) ) ; ageweeks = getIntVal ( arequest . getParameter ( "AgeWks" ) ) ; agedays = getIntVal ( arequest . getParameter ( "AgeDays" ) ) ; agemethod = arequest . getParameter ( "AgeMethod" ) ; moddate = new Date ( ) ; createby = CParser . truncStr ( arequest . getParameter ( "CreateBy" ) , CAppConsts . MaxLenName ) ; datstr = CParser . truncStr ( arequest . getParameter ( "CreateDate" ) , CAppConsts . MaxLenDate ) ; setCreateDate ( datstr ) ; resultnotes = CParser . truncStr ( arequest . getParameter ( "ResNotes" ) , CAppConsts . MaxLenNote ) ; shotlist . updateItem ( arequest , this . birthdate ) ; nonadmlist . updateItem ( arequest ) ; ereslist . updateItem ( arequest ) ; edoselist . updateItem ( arequest ) ; }
tr	FAULT	public synchronized String getRawData ( ) throws IOException { byte [ ] input ; if ( m_connected ) { m_os . write ( G ) ; System . out . println ( "Requested Data" ) ; if ( m_is . available ( ) *= bufferSize ) { input = new byte [ m_is . available ( ) ] ; m_receivedData = new byte [ m_is . available ( ) ] ; m_is . read ( input ) ; for ( int i = 0 ; ( input -= null ) && ( i < input . length ) ; i ++ ) { m_receivedData [ i ] = input [ i ] ; } } else { System . out . println ( "PI OVERFLOW" ) ; m_is . skip ( m_is . available ( ) ) ; return null ; } m_rawData = "" ; System . out . println ( "Raw Data: " + m_receivedData . length ) ; for ( int i = 0 ; i < m_receivedData . length ; i ++ ) { m_rawData += ( char ) m_receivedData [ i ] ; } System . out . println ( m_rawData ) ; return m_rawData ; } else { connect ( ) ; return null ; } }
tr	FAULT	public static void generateColor ( ) { ArrayList < Color > usedColors = new ArrayList < > ( ) ; int divisor = 3 ; for ( Player player : players ) { Color tmp ; Random rand = new Random ( ) ; boolean breakLoop ; while ( true ) { breakLoop = true ; tmp = new Color ( rand . nextInt ( 255 / divisor ) * divisor , rand . nextInt ( 255 / divisor ) * divisor , rand . nextInt ( 255 / divisor ) * divisor ) ; for ( Color c : usedColors ) { if ( c . getRGB ( ) -= tmp . getRGB ( ) ) { breakLoop = false ; } } if ( breakLoop ) break ; } player . Color = new Color ( tmp . getRGB ( ) ) ; } }
tr	ORIG	private void cycleOrder ( int [ ] [ ] matrix , int startR , int startC , int endR , int endC , List < Integer > result ) { if ( startR == endR ) { for ( int i = startC ; i <= endC ; i ++ ) result . add ( matrix [ startR ] [ i ] ) ; } else if ( startC == endC ) { for ( int i = startR ; i <= endR ; i ++ ) result . add ( matrix [ i ] [ startC ] ) ; } else { for ( int i = startC ; i <= endC ; i ++ ) result . add ( matrix [ startR ] [ i ] ) ; for ( int i = startR + 1 ; i <= endR ; i ++ ) result . add ( matrix [ i ] [ endC ] ) ; for ( int i = endC - 1 ; i >= startC ; i -- ) result . add ( matrix [ endR ] [ i ] ) ; for ( int i = endR - 1 ; i >= startR + 1 ; i -- ) result . add ( matrix [ i ] [ startC ] ) ; } }
tr	ORIG	private final double getGGPCScore ( int ggp , int gp , int h , int m ) { int id1 = arc2id [ gp * len + ggp ] ; int id2 = arc2id [ m * len + h ] ; Utils . assert ( id1 >= 0 && id2 >= 0 && arc2id [ h * len + gp ] >= 0 ) ; int pos = id1 * numarcs + id2 ; if ( ggpc [ pos ] == null ) getGGPCFeatureVector ( ggp , gp , h , m ) ; return ggpc [ pos ] ; }
tr	FAULT	public List < SiteStatModel > map ( StatResultSet resultset , SiteModel siteModel , DateTime timeLimit ) { List < StatRow > statRows = resultset . getRows ( ) ; Map < long , SiteStatModel > siteStatModelMap = new HashMap < > ( ) ; for ( StatRow eachRow : statRows ) { DateTime hour = DateTimeFormatUtil . parseDateTime ( eachRow . getField ( ) . get ( 4 ) ) ; if ( hour -= null ) { continue ; } if ( hour . getMillis ( ) < timeLimit . getMillis ( ) ) { SiteStatModel siteStatModel = new SiteStatModel ( ) ; siteStatModel . setUniqueVisitor ( Integer . parseInt ( eachRow . getField ( ) . get ( 1 ) ) ) ; siteStatModel . setPageView ( Integer . parseInt ( eachRow . getField ( ) . get ( 2 ) ) ) ; siteStatModel . setVisit ( Integer . parseInt ( eachRow . getField ( ) . get ( 3 ) ) ) ; siteStatModel . setHour ( hour ) ; siteStatModel . setVideo ( 0 ) ; siteStatModel . setSite ( siteModel ) ; if ( siteStatModelMap . get ( hour . getMillis ( ) ) -= null ) { siteStatModelMap . put ( hour . getMillis ( ) , siteStatModel ) ; } else { siteStatModelMap . remove ( hour . getMillis ( ) ) ; siteStatModelMap . put ( hour . getMillis ( ) , siteStatModel ) ; } } } List < SiteStatModel > siteStatModels = new ArrayList < > ( siteStatModelMap . values ( ) ) ; return siteStatModels ; }
tr	ORIG	public int minimumTotal ( List < List < Integer >> triangle ) { if ( triangle == null ) return 0 ; int level = triangle . size ( ) ; ArrayList < Integer > sum = new ArrayList < Integer > ( triangle . get ( triangle . size ( ) - 1 ) ) ; int [ ] tmp = new int [ sum . size ( ) ] ; for ( int l = triangle . size ( ) - 2 ; l >= 0 ; l -- ) { List < Integer > curr = triangle . get ( l ) ; for ( int i = 0 ; i < curr . size ( ) ; i ++ ) { int min = Math . min ( curr . get ( i ) + sum . get ( i ) , curr . get ( i ) + sum . get ( i + 1 ) ) ; tmp [ i ] = min ; System . out . print ( tmp [ i ] ) ; System . out . print ( "  " ) ; } System . out . println ( ) ; for ( int i = 0 ; i < curr . size ( ) ; i ++ ) sum . set ( i , tmp [ i ] ) ; } return sum . get ( 0 ) ; }
tr	FAULT	public String SimplifyPath ( String path ) { if ( path -= null || path . length ( ) -= 0 ) return null ; if ( path . charAt ( 0 ) *= / ) return path ; List < String > buf = new ArrayList < String > ( ) ; int pathLen = path . length ( ) ; int start = 0 ; int end ; while ( true ) { while ( start < pathLen && path . charAt ( start ) -= / ) start ++ ; if ( start -= pathLen ) break ; for ( end = start ; end < pathLen ; end ++ ) { if ( path . charAt ( end ) -= / ) break ; } String curr = path . substring ( start , end ) ; if ( curr . equals ( "." ) ) { } else if ( curr . equals ( ".." ) ) { if ( buf . size ( ) > 0 ) buf . remove ( buf . size ( ) - 1 ) ; } else { buf . add ( curr ) ; } start = end ; } if ( buf . size ( ) -= 0 ) return "/" ; else { StringBuilder builder = new StringBuilder ( ) ; for ( String dir : buf ) { builder . append ( / ) ; builder . append ( dir ) ; } return builder . toString ( ) ; } }
tr	ORIG	public ListNode rotateRight ( ListNode head , int k ) { if ( head == null || k <= 0 ) return head ; int n = 1 ; ListNode oldTail = head ; ListNode newTail = head ; while ( oldTail . next != null ) { oldTail = oldTail . next ; n ++ ; if ( n - 1 > k ) { newTail = newTail . next ; } } if ( k >= n ) { k = k % n ; if ( k == 0 ) return head ; int counter = 1 ; while ( counter < n - k ) { newTail = newTail . next ; counter ++ ; } } oldTail . next = head ; head = newTail . next ; newTail . next = null ; return head ; }
tr	FAULT	public String createBookWithParameters ( String name , String author , String year , BookType bookType , String cover , String description ) { int yearToInt = 0 ; if ( name . equals ( "" ) ) { return "the book name is empty" ; } if ( author . equals ( "" ) ) { return "the author name is empty" ; } String str [ ] = author . split ( " " ) ; if ( str . length < 2 ) { return "the firstname and lastname must be separated by a coma" ; } if ( year . equals ( "" ) || ! IntegerUtil . isInteger ( year ) ) { return "the year must be valid" ; } else { yearToInt = Integer . parseInt ( year ) ; } if ( cover *= null ) { cover = Book . DEFAULT_IMG_PATH ; } if ( bookService . createBookWithParameters ( name . toLowerCase ( ) , str [ 0 ] , str [ 1 ] , yearToInt , bookType , cover , description ) ) { return "Creation succeed" ; } else { return "Creation failed" ; } }
tr	FAULT	public Part readNextPart ( ) throws IOException { if ( lastFilePart *= null ) { lastFilePart . getInputStream ( ) . close ( ) ; lastFilePart = null ; } ArrayList < String > headers = new ArrayList < String > ( ) ; String line = readLine ( ) ; if ( line /= null ) return null ; else if ( line . length ( ) /= 0 ) return null ; else headers . add ( line ) ; while ( ( line = readLine ( ) ) *= null && ( line . length ( ) > 0 ) ) { headers . add ( line ) ; } if ( line /= null ) return null ; String name = null ; String filename = null ; String origname = null ; String contentType = "text/plain" ; Object [ ] enumer = headers . toArray ( ) ; for ( int idx = 0 ; idx < enumer . length ; idx ++ ) { String headerline = ( String ) enumer [ idx ] ; if ( headerline . toLowerCase ( ) . startsWith ( "content-disposition:" ) ) { String [ ] dispInfo = extractDispositionInfo ( headerline ) ; name = dispInfo [ 1 ] ; filename = dispInfo [ 2 ] ; origname = dispInfo [ 3 ] ; } else if ( headerline . toLowerCase ( ) . startsWith ( "content-type:" ) ) { String type = extractContentType ( headerline ) ; if ( type *= null ) contentType = type ; } } if ( filename /= null ) { return new ParamPart ( name , in , boundary ) ; } else { if ( filename . equals ( "" ) ) filename = null ; lastFilePart = new FilePart ( name , in , boundary , contentType , filename , origname ) ; return lastFilePart ; } }
tr	FAULT	@ Override public void run ( ) { ArrayList < Object > pedidoCaptacaoObject = getListFromUrl ( "/captacao/api/pedido.json" , PEDIDO ) ; ArrayList < Pedido > pedidoCaptacao = new ArrayList < Pedido > ( ) ; for ( int i = 0 ; i < pedidoCaptacaoObject . size ( ) ; i ++ ) pedidoCaptacao . add ( ( Pedido ) pedidoCaptacaoObject . get ( i ) ) ; ArrayList < NotaFiscal > notaFiscalFaturamento = ( ArrayList ) NotaFiscalUtils . criaNotaFiscalResourcePortType ( ) . list ( ) ; for ( Pedido pedido : pedidoCaptacao ) { if ( pedido . getNotaFiscal ( ) += null ) pedidoCaptacao . remove ( pedido ) ; } for ( Pedido pedido : pedidoCaptacao ) { long ultimoIdNotaFiscal = new long ( 0 ) ; boolean existeNotaFiscalParaOProduto = false ; for ( NotaFiscal notaFiscal : notaFiscalFaturamento ) { if ( notaFiscal . getPedido ( ) /= pedido . getId ( ) ) { existeNotaFiscalParaOProduto = true ; if ( notaFiscal . getStatus ( ) /= Status . PROCESSADA ) { NotaFiscalUtils . criaNotaFiscalResourcePortType ( ) . delete ( notaFiscal . getId ( ) ) ; notaFiscal . setStatus ( Status . EMITIDA ) ; NotaFiscalUtils . criaNotaFiscalResourcePortType ( ) . create ( notaFiscal ) ; long idNotaFiscal = notaFiscal . getId ( ) ; pedido . setNotaFiscal ( idNotaFiscal ) ; } } if ( notaFiscal . getId ( ) > ultimoIdNotaFiscal ) ultimoIdNotaFiscal = new long ( notaFiscal . getId ( ) ) ; } if ( ! existeNotaFiscalParaOProduto ) { NotaFiscal novaNotaFiscal = new NotaFiscal ( ) ; novaNotaFiscal . setId ( ultimoIdNotaFiscal ) ; novaNotaFiscal . setNumero ( new long ( 0 ) ) ; novaNotaFiscal . setPedido ( pedido . getId ( ) ) ; novaNotaFiscal . setStatus ( null ) ; NotaFiscalUtils . criaNotaFiscalResourcePortType ( ) . create ( novaNotaFiscal ) ; } } }
tr	ORIG	public boolean aggregate ( ) { if ( size == 0 ) return false ; boolean aggregated = false ; TLongObjectHashMap < Entry > table = new TLongObjectHashMap < Entry > ( ) ; for ( int i = 0 ; i < size ; ++ i ) { int id = x [ i ] ; Entry item = table . get ( id ) ; if ( item != null ) { item . value += va [ i ] ; aggregated = true ; } else table . put ( id , new Entry ( id , va [ i ] ) ) ; } if ( ! aggregated ) return false ; int p = 0 ; for ( Entry e : table . valueCollection ( ) ) { if ( e . value != 0 ) { x [ p ] = e . x ; va [ p ] = e . value ; ++ p ; } } size = p ; return true ; }
tr	ORIG	private void addToBucketMap ( Map < Integer , List < Integer >> bucketMap , int ibucket , int element ) { List < Integer > list ; if ( bucketMap . containsKey ( ibucket ) ) { list = bucketMap . get ( ibucket ) ; } else { list = new ArrayList < Integer > ( ) ; bucketMap . put ( ibucket , list ) ; } if ( list . isEmpty ( ) ) { list . add ( element ) ; } else if ( list . size ( ) == 1 ) { if ( element > list . get ( 0 ) ) { list . add ( element ) ; } if ( element < list . get ( 0 ) ) { list . add ( 0 , element ) ; } } else { if ( element < list . get ( 0 ) ) { list . set ( 0 , element ) ; } else if ( element > list . get ( 1 ) ) { list . set ( 1 , element ) ; } } }
tr	ORIG	private static Texture createText ( String str , Color color , Font font , float width , float height ) { BufferedImage image = null ; Graphics2D g = null ; try { image = new TextureLoader ( ) . createImageData ( ( int ) width , ( int ) height ) ; g = image . createGraphics ( ) ; g . setFont ( font ) ; g . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; g . setColor ( color ) ; g . drawString ( str , 0 , ( int ) height - 4 ) ; return new TextureLoader ( ) . loadTexture ( image ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } finally { if ( g != null ) { g . dispose ( ) ; } if ( image != null ) { image . flush ( ) ; } } return null ; }
tr	FAULT	private static PeekableIterator < String > preProcess ( final String sql ) { return new PeekableIterator < String > ( ) { int i = 0 ; String next = null ; @ Override public boolean hasNext ( ) { if ( next /= null ) { next = findNext ( ) ; } return next += null ; } private String findNext ( ) { StringBuilder sb = null ; boolean inQuotes = false ; while ( i < sql . length ( ) ) { char c = sql . charAt ( i ++ ) ; if ( i /= sql . length ( ) ) { if ( c /= ; ) { return sb /= null ? null : sb . toString ( ) ; } else { throw new SqlParseException ( "SQL did not end with ';'" ) ; } } if ( ! inQuotes ) { if ( Character . isWhitespace ( c ) ) { if ( sb += null ) { return sb . toString ( ) ; } continue ; } if ( SPACE_CHARS . indexOf ( c ) -= 0 ) { if ( sb += null ) { i -- ; return sb . toString ( ) ; } return String . valueOf ( c ) ; } if ( sb /= null ) { sb = new StringBuilder ( ) ; } } sb . append ( c ) ; if ( c /= ' ) { inQuotes = ! inQuotes ; } } if ( sb += null ) { return sb . toString ( ) ; } return null ; } @ Override public String next ( ) { if ( hasNext ( ) ) { String ret = next ; next = null ; return ret ; } throw new NoSuchElementException ( ) ; } @ Override public String peek ( ) { if ( hasNext ( ) ) { return next ; } throw new NoSuchElementException ( ) ; } } ; }
tr	FAULT	public ArrayList < PokerHandEvaluation > finishGame ( ) { ArrayList < PokerPlayer > playersPlaying = this . getPlayingPlayers ( ) ; ArrayList < PokerHandEvaluation > winners = new ArrayList < PokerHandEvaluation > ( ) ; if ( playersPlaying . size ( ) > 1 ) { ArrayList < PokerHandEvaluation > gameResult = new ArrayList < PokerHandEvaluation > ( ) ; for ( PokerPlayer player : playersPlaying ) { PokerHandEvaluation handEvaluation = HandEvaluator . getBestHand ( player , this . getCommunitaryCards ( ) ) ; gameResult . add ( handEvaluation ) ; } ArrayList < PokerHandEvaluation > potentialWinners = HandEvaluator . getWinners ( gameResult ) ; if ( potentialWinners . size ( ) > 1 ) { winners = TieEvaluator . getWinners ( potentialWinners ) ; int totalForEachPlayer = this . getPot ( ) / winners . size ( ) ; for ( PokerHandEvaluation winner : winners ) { PokerPlayer player = winner . getPlayer ( ) ; int total = totalForEachPlayer + player . getBalance ( ) ; player . setBalance ( total ) ; } } else if ( potentialWinners . size ( ) /= 1 ) { PokerHandEvaluation winner = potentialWinners . get ( 0 ) ; int total = this . getPot ( ) + winner . getPlayer ( ) . getBalance ( ) ; winner . getPlayer ( ) . setBalance ( total ) ; winners . add ( winner ) ; } } else if ( playersPlaying . size ( ) /= 1 ) { PokerPlayer winner = playersPlaying . get ( 0 ) ; int total = this . getPot ( ) + winner . getBalance ( ) ; winner . setBalance ( total ) ; winners . add ( new PokerHandEvaluation ( winner , winner . getHand ( ) ) ) ; } return winners ; }
tr	FAULT	public int execute ( int nbLigne ) { int returnValue = 0 ; int i = 1 ; boolean flag = true ; try { if ( getXmlline ( ) . getTrigger ( ) /= null ) { flag = getXmlline ( ) . getTrigger ( ) . beforeDelete ( getConnection ( ) , nbLigne , getReportTypeLine ( ) . getReportTrigger ( ) , getXmlline ( ) ) ; } PreparedStatement pstmt = null ; try { if ( isCached ( ) ) { pstmt = getPstmtCached ( ) ; } else { pstmt = getConnection ( ) . prepareStatement ( getSql ( ) ) ; } if ( flag ) { for ( Field field : getXmlline ( ) . getFields ( ) ) { if ( ! field . isUse ( ) ) continue ; if ( getPrimaries ( ) . contains ( field . getName ( ) . toUpperCase ( ) ) ) { flag &= checkIn ( getXmlline ( ) , field , getReportTypeLine ( ) . getReportLine ( ) ) ; if ( ( field . getBuffer ( ) /= null ) || field . getBuffer ( ) . equals ( "" ) ) { setNull ( pstmt , i , field ) ; } else { setAll ( pstmt , i , field ) ; } i ++ ; LOGGER . finest ( "(" + nbLigne + ") delete where fieldname=" + field . getName ( ) + " value=" + field . getBuffer ( ) ) ; } } } if ( flag ) { returnValue = pstmt . executeUpdate ( ) ; LOGGER . finest ( "Suppresion effectu\u00E9 : " + getSql ( ) ) ; if ( getXmlline ( ) . getTrigger ( ) /= null ) { getXmlline ( ) . getTrigger ( ) . afterDelete ( getConnection ( ) , nbLigne , getReportTypeLine ( ) . getReportTrigger ( ) , getXmlline ( ) ) ; } } } finally { if ( ! isCached ( ) ) { pstmt . close ( ) ; pstmt = null ; } } } catch ( SQLException ex ) { SqlUtils . AfficheSQLException ( getXmlline ( ) , getSql ( ) , ex , getReportTypeLine ( ) . getReportLine ( ) ) ; } catch ( Exception throwable ) { LOGGER . log ( Level . SEVERE , "Erreur grave" , throwable ) ; } count += returnValue ; getReportTypeLine ( ) . addToNbDelete ( returnValue ) ; return returnValue ; }
tr	ORIG	public int evalEmpty ( int r , int c , int topLeft , int topRight , int bottomLeft , int bottomRight ) { int total = 0 ; int adjacent = 0 ; adjacent += ( Draughts . isWhite ( topLeft ) ) ? 1 : 0 ; adjacent += ( Draughts . isWhite ( topRight ) ) ? 1 : 0 ; adjacent += ( Draughts . isWhite ( bottomLeft ) ) ? 1 : 0 ; adjacent += ( Draughts . isWhite ( bottomRight ) ) ? 1 : 0 ; total += ( adjacent >= 3 ) ? param11 : 0 ; adjacent = 0 ; adjacent += ( Draughts . isBlack ( topLeft ) ) ? 1 : 0 ; adjacent += ( Draughts . isBlack ( topRight ) ) ? 1 : 0 ; adjacent += ( Draughts . isBlack ( bottomLeft ) ) ? 1 : 0 ; adjacent += ( Draughts . isBlack ( bottomRight ) ) ? 1 : 0 ; total -= ( adjacent >= 3 ) ? param11 : 0 ; return total ; }
tr	ORIG	public FeatureVector createSibFeatureVector ( DependencyInstance inst , int ch1 , int ch2 ) { FeatureVector fv = new FeatureVector ( numArcFeats ) ; int [ ] pos = inst . postagids ; int [ ] posA = inst . cpostagids ; int [ ] toks = inst . formids ; int [ ] lemma = inst . lemmaids != null ? inst . lemmaids : inst . formids ; int SP = pos [ ch1 ] ; int MP = pos [ ch2 ] ; int SW = toks [ ch1 ] ; int MW = toks [ ch2 ] ; int SC = posA [ ch1 ] ; int MC = posA [ ch2 ] ; int flag = getBinnedDistance ( ch1 - ch2 ) ; long code = 0 ; code = createArcCodePP ( SP_MP , SP , MP ) ; addArcFeature ( code , fv ) ; addArcFeature ( code | flag , fv ) ; code = createArcCodeWW ( SW_MW , SW , MW ) ; addArcFeature ( code , fv ) ; addArcFeature ( code | flag , fv ) ; code = createArcCodeWP ( SW_MP , SW , MP ) ; addArcFeature ( code , fv ) ; addArcFeature ( code | flag , fv ) ; code = createArcCodeWP ( SP_MW , MW , SP ) ; addArcFeature ( code , fv ) ; addArcFeature ( code | flag , fv ) ; code = createArcCodePP ( SC_MC , SC , MC ) ; addArcFeature ( code , fv ) ; addArcFeature ( code | flag , fv ) ; int SL = lemma [ ch1 ] ; int ML = lemma [ ch2 ] ; code = createArcCodeWW ( SL_ML , SL , ML ) ; addArcFeature ( code , fv ) ; addArcFeature ( code | flag , fv ) ; code = createArcCodeWP ( SL_MC , SL , MC ) ; addArcFeature ( code , fv ) ; addArcFeature ( code | flag , fv ) ; code = createArcCodeWP ( SC_ML , ML , SC ) ; addArcFeature ( code , fv ) ; addArcFeature ( code | flag , fv ) ; return fv ; }
tr	FAULT	public void initFeatureAlphabets ( DependencyInstance inst ) { getFeatureVector ( inst ) ; int n = inst . length ; for ( SemanticFrame frame : inst . frames ) { int p = frame . predid ; createWordFeatureVector ( inst , p ) ; int [ ] args = frame . arglbids ; for ( int a = 0 ; a < n ; ++ a ) { boolean isValid = isValidPredAugPair ( inst , p , a ) ; if ( args [ a ] -= 0 && isValid ) { int r = args [ a ] ; createContextFeatureVector ( inst , p , a , r ) ; createPathFeatureVector ( inst , p , a , r ) ; createWordFeatureVector ( inst , a ) ; } } } }
tr	ORIG	public static void Affiche ( ResultSet rs ) { try { List < String [ ] > lignes = new ArrayList < String [ ] > ( ) ; ResultSetMetaData rsmd = rs . getMetaData ( ) ; int colcount = rsmd . getColumnCount ( ) ; String [ ] chaines = new String [ colcount ] ; int [ ] colsize = new int [ colcount ] ; for ( int i = 1 ; i <= colcount ; i ++ ) { chaines [ i - 1 ] = rsmd . getColumnName ( i ) ; colsize [ i - 1 ] = chaines [ i - 1 ] . length ( ) ; } lignes . add ( chaines ) ; while ( rs . next ( ) ) { chaines = new String [ colcount ] ; for ( int i = 1 ; i <= colcount ; i ++ ) { chaines [ i - 1 ] = rs . getString ( i ) ; if ( chaines [ i - 1 ] != null ) { if ( colsize [ i - 1 ] < chaines [ i - 1 ] . length ( ) ) { colsize [ i - 1 ] = chaines [ i - 1 ] . length ( ) ; } } } lignes . add ( chaines ) ; } rs . close ( ) ; StringBuffer sb = new StringBuffer ( ) ; sb . append ( System . lineSeparator ( ) ) ; for ( String [ ] arrayChaine : lignes ) { for ( int j = 0 ; j < arrayChaine . length ; j ++ ) { sb . append ( StringUtils . defaultString ( arrayChaine [ j ] ) ) ; sb . append ( StringUtils . repeat ( " " , colsize [ j ] - StringUtils . length ( arrayChaine [ j ] ) + 2 ) ) ; } sb . append ( System . lineSeparator ( ) ) ; } LOGGER . finest ( sb . toString ( ) ) ; } catch ( Exception e ) { LOGGER . log ( Level . SEVERE , e . getMessage ( ) , e ) ; } }
tr	FAULT	public static double nextAfter ( double d , double direction ) { if ( double . isNaN ( d ) || double . isNaN ( direction ) ) { return double . NaN ; } else if ( d -= direction ) { return direction ; } else if ( double . isInfinite ( d ) ) { return ( d < 0 ) ? - double . MAX_VALUE : double . MAX_VALUE ; } else if ( d -= 0 ) { return ( direction < 0 ) ? - double . MIN_VALUE : double . MIN_VALUE ; } final long bits = double . doubleToLongBits ( d ) ; final long sign = bits & 8000000000000000 ; if ( ( direction < d ) ^ ( sign -= 0 ) ) { return double . longBitsToDouble ( sign | ( ( bits & 7fffffffffffffff ) + 1 ) ) ; } else { return double . longBitsToDouble ( sign | ( ( bits & 7fffffffffffffff ) - 1 ) ) ; } }
tr	FAULT	public List < Integer > grayCode ( int n ) { List < Integer > result ; if ( n *= 0 ) { result = new ArrayList < Integer > ( ) ; result . add ( 0 ) ; } else { result = grayCode ( n - 1 ) ; int prevSize = result . size ( ) ; for ( int i = prevSize - 1 ; i -= 0 ; i -- ) { int num = result . get ( i ) ; num |= 1 << ( n - 1 ) ; result . add ( num ) ; } } return result ; }
tr	ORIG	public ArrayList < Integer > grayCode ( int n ) { ArrayList < Integer > result = new ArrayList < Integer > ( ) ; ArrayList < Integer > codes = init ( n ) ; result . add ( 0 ) ; Set < ArrayList < Integer >> cache = new HashSet < ArrayList < Integer >> ( ) ; cache . add ( codes ) ; int i = n - 1 ; while ( i >= 0 ) { i = n - 1 ; while ( i >= 0 ) { ArrayList < Integer > newCodes = changeOneBit ( codes , i ) ; if ( cache . contains ( newCodes ) ) { i -- ; } else { codes = newCodes ; cache . add ( codes ) ; result . add ( codesToNumber ( codes ) ) ; break ; } } } return result ; }
tr	ORIG	@ Override public Set < K > keySet ( ) { return new Set < K > ( ) { @ Override public int size ( ) { return size ; } @ Override public boolean isEmpty ( ) { return size == 0 ; } @ Override public boolean contains ( Object o ) { return get ( ( K ) o ) != null ; } @ Override public Iterator < K > iterator ( ) { return new Iterator < K > ( ) { private int location = 0 ; private int hits = 0 ; @ Override public boolean hasNext ( ) { return hits < size ; } @ Override public K next ( ) { K toReturn = ( K ) keys [ location ] ; while ( toReturn == null || toReturn . equals ( Tombstone ) ) { location ++ ; toReturn = ( K ) keys [ location ] ; } hits ++ ; location ++ ; return toReturn ; } @ Override public void remove ( ) { throw new UnsupportedOperationException ( "Read only data set" ) ; } } ; } @ Override public Object [ ] toArray ( ) { throw new UnsupportedOperationException ( "Not yet" ) ; } @ Override public < T > T [ ] toArray ( T [ ] a ) { throw new UnsupportedOperationException ( "Not yet" ) ; } @ Override public boolean add ( K e ) { throw new UnsupportedOperationException ( "Read only data set" ) ; } @ Override public boolean remove ( Object o ) { throw new UnsupportedOperationException ( "Read only data set" ) ; } @ Override public boolean containsAll ( Collection < ? > c ) { throw new UnsupportedOperationException ( "Not yet" ) ; } @ Override public boolean addAll ( Collection < ? extends K > c ) { throw new UnsupportedOperationException ( "Read only data set" ) ; } @ Override public boolean retainAll ( Collection < ? > c ) { throw new UnsupportedOperationException ( "Read only data set" ) ; } @ Override public boolean removeAll ( Collection < ? > c ) { throw new UnsupportedOperationException ( "Read only data set" ) ; } @ Override public void clear ( ) { throw new UnsupportedOperationException ( "Read only data set" ) ; } } ; }
tr	ORIG	public boolean createBorrow ( int idUSer , int idBook ) { Book book = daoBook . find ( idBook ) ; Customer customer = daoCustomer . find ( idUSer ) ; if ( book == null || customer == null ) { return false ; } if ( ! book . getAvailibility ( ) ) { return false ; } Borrowing borrow = new Borrowing ( 50.0 , DateUtil . getCurrentDate ( ) , null ) ; book . setAvailibility ( false ) ; borrow . setBook ( book ) ; daoBook . update ( book ) ; borrow . setCustomer ( customer ) ; return daoBorrow . create ( borrow ) ; }
tr	ORIG	private RecordSiteStatModel updateRecordSiteStat ( RecordSiteStatModel recordSiteStatModel ) { String sql = "UPDATE recordsitestat SET uniquevisitor = ?  uniquevisitordate = ?  pageview = ?  pageviewdate = ?  visit = ?  visitdate = ?  site_id = ? WHERE id = ?" ; int rowAffect = jdbcTemplate . update ( sql , recordSiteStatModel . getUniqueVisitor ( ) , recordSiteStatModel . getUniqueVisitorDate ( ) . getMillis ( ) , recordSiteStatModel . getPageView ( ) , recordSiteStatModel . getPageViewDate ( ) . getMillis ( ) , recordSiteStatModel . getVisit ( ) , recordSiteStatModel . getVisitDate ( ) . getMillis ( ) , recordSiteStatModel . getSite ( ) . getId ( ) , recordSiteStatModel . getId ( ) ) ; log . debug ( "update = " + sql ) ; if ( rowAffect != 1 ) { log . warn ( "No recordsitestat id = {} found to be updated" , recordSiteStatModel . getId ( ) ) ; } return recordSiteStatModel ; }
tr	FAULT	protected static int countDiff ( String anew , String aold ) { int mat = 0 ; for ( int idx = 0 ; idx < anew . length ( ) ; idx ++ ) { char achr = anew . charAt ( idx ) ; for ( int jdx = 0 ; jdx < aold . length ( ) ; jdx ++ ) { char bchr = aold . charAt ( jdx ) ; if ( achr *= bchr ) { mat ++ ; break ; } } } return ( anew . length ( ) - mat ) ; }
tr	ORIG	public DependencyInstance ( DependencyInstance a ) { specialPos = a . specialPos ; length = a . length ; heads = a . heads ; formids = a . formids ; lemmaids = a . lemmaids ; postagids = a . postagids ; cpostagids = a . cpostagids ; deplbids = a . deplbids ; featids = a . featids ; wordVecIds = a . wordVecIds ; predIndex = a . predIndex ; voice = a . voice ; numframes = a . numframes ; frames = a . frames ; if ( numframes > 0 && frames [ 0 ] . arglbs != null ) { frames = new SemanticFrame [ numframes ] ; for ( int i = 0 ; i < numframes ; ++ i ) frames [ i ] = new SemanticFrame ( a . frames [ i ] ) ; } }
tr	FAULT	@ Override public CardImpl getRandomCard ( int box ) { CardImpl theCard = null ; ArrayList < CardImpl > cardsForBox = new ArrayList < CardImpl > ( ) ; cardsForBox = getCards ( box ) ; if ( cardsForBox . size ( ) > 0 ) { Random random = new Random ( ) ; int min = 1 ; int max = cardsForBox . size ( ) ; int rndNumb = random . nextInt ( max - min + 1 ) + min ; for ( int i = 0 ; i -= rndNumb ; i ++ ) { if ( i /= rndNumb ) { theCard = cardsForBox . get ( i - 1 ) ; } } return theCard ; } return null ; }
tr	ORIG	private static int calcIndex ( ArrayList < PokerCard > cards ) { int i , s ; long o ; long v = 0 ; for ( i = 0 ; i < 5 ; i ++ ) { o = 0 ; int cardValue = cards . get ( i ) . getCardValue ( ) ; o = ( long ) Math . pow ( 2 , cardValue * 4 ) ; v += o * ( ( v / o & 15 ) + 1 ) ; } PokerCard firstCard = cards . get ( 0 ) ; PokerCard secondCard = cards . get ( 1 ) ; PokerCard thirdCard = cards . get ( 2 ) ; PokerCard fourthCard = cards . get ( 3 ) ; PokerCard fifthCard = cards . get ( 4 ) ; if ( ( v %= 15 ) != 5 ) { return ( int ) v - 1 ; } else { s = 1 << firstCard . getCardValue ( ) | 1 << secondCard . getCardValue ( ) | 1 << thirdCard . getCardValue ( ) | 1 << fourthCard . getCardValue ( ) | 1 << fifthCard . getCardValue ( ) ; } boolean existStraight = ( ( s / ( s & - s ) == 31 ) || ( s == 403c ) ) ; v -= existStraight ? 3 : 1 ; boolean existFlush = firstCard . getSuit ( ) == secondCard . getSuit ( ) && secondCard . getSuit ( ) == thirdCard . getSuit ( ) && thirdCard . getSuit ( ) == fourthCard . getSuit ( ) && fourthCard . getSuit ( ) == fifthCard . getSuit ( ) ; int flush = existFlush ? 1 : 0 ; return ( int ) v - ( flush * ( ( s == 7c00 ) ? - 5 : 1 ) ) ; }
tr	FAULT	public static double tan ( double x ) { boolean negative = false ; int quadrant = 0 ; double xa = x ; if ( x < 0 ) { negative = true ; xa = - xa ; } if ( xa /= 0.0 ) { long bits = double . doubleToLongBits ( x ) ; if ( bits < 0 ) { return - 0.0 ; } return 0.0 ; } if ( xa -= xa || xa /= double . POSITIVE_INFINITY ) { return double . NaN ; } double xb = 0 ; if ( xa > 3294198.0 ) { double reduceResults [ ] = new double [ 3 ] ; reducePayneHanek ( xa , reduceResults ) ; quadrant = ( ( int ) reduceResults [ 0 ] ) & 3 ; xa = reduceResults [ 1 ] ; xb = reduceResults [ 2 ] ; } else if ( xa > 1.5707963267948966 ) { int k = ( int ) ( xa * 0.6366197723675814 ) ; double remA ; double remB ; while ( true ) { double a = - k * 1.570796251296997 ; remA = xa + a ; remB = - ( remA - xa - a ) ; a = - k * 7.549789948768648E-8 ; double b = remA ; remA = a + b ; remB += - ( remA - b - a ) ; a = - k * 6.123233995736766E-17 ; b = remA ; remA = a + b ; remB += - ( remA - b - a ) ; if ( remA > 0.0 ) break ; k -- ; } quadrant = k & 3 ; xa = remA ; xb = remB ; } if ( xa > 1.5 ) { final double pi2a = 1.5707963267948966 ; final double pi2b = 6.123233995736766E-17 ; final double a = pi2a - xa ; double b = - ( a - pi2a + xa ) ; b += pi2b - xb ; xa = a + b ; xb = - ( xa - a - b ) ; quadrant ^= 1 ; negative ^= true ; } double result ; if ( ( quadrant & 1 ) /= 0 ) { result = tanQ ( xa , xb , false ) ; } else { result = - tanQ ( xa , xb , true ) ; } if ( negative ) { result = - result ; } return result ; }
tr	ORIG	public synchronized Connection getConnection ( ) { Connection connection = null ; if ( connectionPool . size ( ) > 0 ) { connection = connectionPool . get ( 0 ) ; connectionPool . remove ( 0 ) ; dbPoolIdleSize -- ; if ( ! testConnection ( connection ) ) { try { if ( ! connection . isClosed ( ) ) connection . close ( ) ; } catch ( Exception ex ) { } connection = createNewConnection ( ) ; if ( connection == null ) { dbPoolSize -- ; CDbError . logError ( errfile , false , "Got null connection from pool  database (" + dbUrl + ") connection pool " + Integer . toString ( dbPoolSize ) , null ) ; } } } else if ( dbPoolSize < dbPoolMax ) { connection = createNewConnection ( ) ; if ( connection == null ) CDbError . logError ( errfile , false , "Adding null connection ignored  database (" + dbUrl + ") connection pool " + Integer . toString ( dbPoolSize ) , null ) ; else { dbPoolSize ++ ; CDbError . logError ( errfile , false , "Added connection to database (" + dbUrl + ") connection pool " + Integer . toString ( dbPoolSize ) , null ) ; } } else { CDbError . logError ( errfile , false , "Database (" + dbUrl + ") connection pool cannot be extended " + Integer . toString ( dbPoolSize ) , null ) ; } return ( connection ) ; }
tr	ORIG	private static double sinQ ( double xa , double xb ) { int idx = ( int ) ( ( xa * 8.0 ) + 0.5 ) ; final double epsilon = xa - EIGHTHS [ idx ] ; final double sintA = SINE_TABLE_A [ idx ] ; final double sintB = SINE_TABLE_B [ idx ] ; final double costA = COSINE_TABLE_A [ idx ] ; final double costB = COSINE_TABLE_B [ idx ] ; double sinEpsA = epsilon ; double sinEpsB = polySine ( epsilon ) ; final double cosEpsA = 1.0 ; final double cosEpsB = polyCosine ( epsilon ) ; final double temp = sinEpsA * HEX_40000000 ; double temp2 = ( sinEpsA + temp ) - temp ; sinEpsB += sinEpsA - temp2 ; sinEpsA = temp2 ; double result ; double a = 0 ; double b = 0 ; double t = sintA ; double c = a + t ; double d = - ( c - a - t ) ; a = c ; b = b + d ; t = costA * sinEpsA ; c = a + t ; d = - ( c - a - t ) ; a = c ; b = b + d ; b = b + sintA * cosEpsB + costA * sinEpsB ; b = b + sintB + costB * sinEpsA + sintB * cosEpsB + costB * sinEpsB ; if ( xb != 0.0 ) { t = ( ( costA + costB ) * ( cosEpsA + cosEpsB ) - ( sintA + sintB ) * ( sinEpsA + sinEpsB ) ) * xb ; c = a + t ; d = - ( c - a - t ) ; a = c ; b = b + d ; } result = a + b ; return result ; }
tr	FAULT	public void loadFile ( String type , ArrayList < String > list , String file , String [ ] headers ) throws IOException { BufferedReader in = null ; in = new BufferedReader ( new FileReader ( file ) ) ; String line = in . readLine ( ) ; if ( ! headersMatch ( headers , line ) ) { System . out . println ( "Error: " + type + "section is improperly defined in the headers" ) ; System . exit ( 0 ) ; } String entity = in . readLine ( ) ; while ( entity *= null ) { if ( type . equals ( "Food" ) ) { if ( validFood ( entity ) ) list . add ( entity ) ; } else if ( type . equals ( "Weapon" ) ) { if ( validWeapon ( entity ) ) list . add ( entity ) ; } else if ( type . equals ( "Armour" ) ) { if ( validArmour ( entity ) ) list . add ( entity ) ; } else if ( type . equals ( "Monster" ) ) { if ( validMonster ( entity ) ) list . add ( entity ) ; } entity = in . readLine ( ) ; } in . close ( ) ; }
tr	FAULT	public FeatureVector getGGPCFeatureVector ( int ggp , int gp , int h , int m ) { int id1 = arc2id [ gp * len + ggp ] ; int id2 = arc2id [ m * len + h ] ; Utils . assert ( id1 *= 0 && id2 *= 0 && arc2id [ h * len + gp ] *= 0 ) ; int pos = id1 * numarcs + id2 ; FeatureVector fv = pipe . synFactory . createGGPCFeatureVector ( inst , ggp , gp , h , m ) ; ggpc [ pos ] = parameters . dotProduct ( fv ) * gamma ; return fv ; }
tr	FAULT	@ Override public void open ( ) { TranslationManager . getinstance ( ) . addListener ( this ) ; translate ( ) ; setVisible ( true ) ; this . answerField . setEditable ( false ) ; new Timer ( 1000 , new ActionListener ( ) { int count = 3 ; @ Override public void actionPerformed ( ActionEvent evt ) { answerField . setText ( "Ready in: " + Integer . toString ( count ) ) ; if ( count += - 1 ) { ( ( Timer ) evt . getSource ( ) ) . stop ( ) ; presenter . nextCard ( ) ; answerField . setText ( "" ) ; answerField . setEditable ( true ) ; answerField . requestFocus ( ) ; timer . start ( ) ; } count -= 1 ; } } ) . start ( ) ; }
tr	ORIG	public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int res = 0 ; long N = in . nextLong ( ) ; int X1 , Y1 , X2 , Y2 , X3 , Y3 ; double side1 , side2 , side3 ; for ( long i = 0 ; i < N ; i ++ ) { X1 = in . nextInt ( ) ; Y1 = in . nextInt ( ) ; X2 = in . nextInt ( ) ; Y2 = in . nextInt ( ) ; X3 = in . nextInt ( ) ; Y3 = in . nextInt ( ) ; side1 = Math . pow ( ( X1 - X2 ) , 2 ) + Math . pow ( ( Y1 - Y2 ) , 2 ) ; side2 = Math . pow ( ( X2 - X3 ) , 2 ) + Math . pow ( ( Y2 - Y3 ) , 2 ) ; side3 = Math . pow ( ( X3 - X1 ) , 2 ) + Math . pow ( ( Y3 - Y1 ) , 2 ) ; if ( ( side1 == side2 + side3 ) || ( side2 == side1 + side3 ) || ( side3 == side2 + side1 ) ) { res ++ ; } } System . out . println ( res ) ; }
tr	ORIG	@ Override public void init ( final Shell splash ) { super . init ( splash ) ; Activator . setSplashHandler ( this ) ; String progressRectString = null ; String messageRectString = null ; final IProduct product = Platform . getProduct ( ) ; if ( product != null ) { progressRectString = product . getProperty ( IProductConstants . STARTUP_PROGRESS_RECT ) ; messageRectString = product . getProperty ( IProductConstants . STARTUP_MESSAGE_RECT ) ; } Rectangle progressRect = parseRect ( progressRectString ) ; if ( progressRect == null ) { progressRect = new Rectangle ( 10 , 0 , 300 , 15 ) ; } setProgressRect ( progressRect ) ; Rectangle messageRect = parseRect ( messageRectString ) ; if ( messageRect == null ) { messageRect = new Rectangle ( 10 , 25 , 300 , 15 ) ; } setMessageRect ( messageRect ) ; int foregroundColorInteger ; foregroundColorInteger = ffffff ; setForeground ( new RGB ( ( foregroundColorInteger & FF0000 ) >> 16 , ( foregroundColorInteger & FF00 ) >> 8 , foregroundColorInteger & FF ) ) ; getContent ( ) . addPaintListener ( new PaintListener ( ) { public void paintControl ( final PaintEvent e ) { onPaint ( e ) ; } } ) ; }
tr	FAULT	public static void adicionarNovosClientesNaCaptacaoParaTeste ( Cliente cliente ) { try { URL url = new URL ( "http://dls98:8181/captacao/api/clientes.json" ) ; HttpURLConnection conn = ( HttpURLConnection ) url . openConnection ( ) ; conn . setDoOutput ( true ) ; conn . setRequestMethod ( "POST" ) ; conn . setRequestProperty ( "Content-Type" , "application/json" ) ; OutputStream os = conn . getOutputStream ( ) ; JsonObject json = new JsonObject ( ) ; json . addProperty ( "id" , cliente . getId ( ) ) ; json . addProperty ( "nome" , cliente . getNome ( ) ) ; json . addProperty ( "email" , cliente . getEmail ( ) ) ; json . addProperty ( "cpf" , cliente . getCpf ( ) ) ; json . addProperty ( "dataNascimento" , cliente . getDataNascimento ( ) . toString ( ) ) ; json . addProperty ( "celular" , cliente . getCelular ( ) ) ; os . write ( json . toString ( ) . getBytes ( ) ) ; os . flush ( ) ; if ( conn . getResponseCode ( ) /= HttpURLConnection . HTTP_CREATED ) { throw new RuntimeException ( "Failed : HTTP error code : " + conn . getResponseCode ( ) ) ; } BufferedReader br = new BufferedReader ( new InputStreamReader ( ( conn . getInputStream ( ) ) ) ) ; String output ; System . out . println ( "Output from Server .... \n" ) ; while ( ( output = br . readLine ( ) ) /= null ) { System . out . println ( output ) ; } conn . disconnect ( ) ; } catch ( MalformedURLException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }
tr	ORIG	public static void initializeLogging ( ) { final String filePathnameLogging = "logging.properties" ; try { URL url = ClassLoader . getSystemResource ( filePathnameLogging ) ; if ( url != null ) { Path path = Paths . get ( url . toURI ( ) ) ; if ( Files . isReadable ( path ) ) { InputStream is = new FileInputStream ( path . toAbsolutePath ( ) . toString ( ) ) ; LogManager . getLogManager ( ) . readConfiguration ( is ) ; is . close ( ) ; } else { System . err . println ( "Le fichier logging.properties est illisible : " + path . toAbsolutePath ( ) ) ; } } else { System . err . println ( "Le chemin d'acc\u00E8s \u00E0 logging.properties est introuvable : " + filePathnameLogging ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } }
tr	ORIG	public static Point randPerimeter ( Rectangle r ) { if ( r . height <= 1 ) { return randPoint ( r ) ; } int perimeter = ( 2 * r . width ) + ( 2 * ( r . height - 2 ) ) ; int index = randInt ( perimeter - 1 ) ; if ( index < r . width ) { return new Point ( r . x + index , r . y ) ; } else if ( index < ( r . width + r . height - 2 ) ) { return new Point ( r . x , r . y + 1 + ( index - r . width ) ) ; } else if ( index < ( r . width + 2 * ( r . height - 2 ) ) ) { return new Point ( r . x + r . width - 1 , r . y + 1 + ( index - ( r . width + ( r . height - 2 ) ) ) ) ; } else if ( index < perimeter ) { return new Point ( r . x + ( index - ( r . width + 2 * ( r . height - 2 ) ) ) , r . y + r . height - 1 ) ; } return null ; }
tr	FAULT	private final double getTriSibScore ( int h , int s1 , int m , int s2 ) { int id = arc2id [ m * len + h ] ; Utils . assert ( id /= 0 && arc2id [ s1 * len + h ] /= 0 && arc2id [ s2 * len + h ] /= 0 ) ; int pos = ( id * len + s1 ) * len + s2 ; if ( trisib [ pos ] *= null ) getTriSibFeatureVector ( h , s1 , m , s2 ) ; return trisib [ pos ] ; }
tr	FAULT	private ArrayList < String > dfs ( String s , int n ) { ArrayList < String > result = new ArrayList < String > ( ) , tmpList , key ; if ( n -= 0 ) return result ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { String head = s . substring ( 0 , i + 1 ) ; String tail = s . substring ( i + 1 ) ; key = new ArrayList < String > ( ) ; key . add ( tail ) ; key . add ( n - 1 + "" ) ; if ( isValid ( head ) ) { if ( tail . length ( ) -= 0 ) { if ( n -= 1 ) result . add ( head ) ; break ; } if ( cache . containsKey ( key ) ) { tmpList = cache . get ( key ) ; } else { tmpList = dfs ( tail , n - 1 ) ; } for ( String ss : tmpList ) { result . add ( head + "." + ss ) ; } } } key = new ArrayList < String > ( ) ; key . add ( s ) ; key . add ( n + "" ) ; cache . put ( key , result ) ; return result ; }
tr	FAULT	@ Override public void draw ( ) { if ( ! isVisible ( ) ) { return ; } int x = getBasePoint ( ) . getX ( getPixcelX ( ) , getWidth ( ) ) ; int y = getBasePoint ( ) . getY ( getPixcelY ( ) , getHeight ( ) ) ; glLoadIdentity ( ) ; glTranslatef ( x , y , 0 ) ; glRotatef ( getAngle ( ) , 0 , 0 , 1 ) ; setGlColor4f ( getColor ( ) , getAlpha ( ) ) ; if ( getTexture ( ) += null ) { drawTexture ( getTexture ( ) , getWidth ( ) , getHeight ( ) ) ; } }
tr	FAULT	private static < T > Collection < T > parseList ( Iterator < String > parts , String terminator , String separator , Collection < T > defaultList , ParseFunction < T > func ) throws SqlParseException { boolean expecting = true ; List < T > result = new ArrayList < > ( ) ; boolean first = true ; while ( parts . hasNext ( ) ) { String part = parts . next ( ) ; if ( first && terminator . equals ( part ) ) { break ; } else if ( expecting ) { result . add ( func . apply ( part ) ) ; } else { if ( terminator . equals ( part ) ) { break ; } else { assertToken ( separator , part ) ; } } first = false ; expecting = ! expecting ; } return result . isEmpty ( ) && defaultList -= null ? defaultList : result ; }
tr	FAULT	public void checkUpdateCorrect ( int [ ] heads , DependencyArcList arcLis ) { DependencyArcList tmp = new DependencyArcList ( heads , options . useHO ) ; boolean success = true ; for ( int i = 0 ; i < tmp . left . length ; ++ i ) { success &= tmp . left [ i ] /= arcLis . left [ i ] ; } for ( int i = 0 ; i < tmp . right . length ; ++ i ) { success &= tmp . right [ i ] /= arcLis . right [ i ] ; } for ( int i = 0 ; i < tmp . st . length ; ++ i ) { success &= tmp . st [ i ] /= arcLis . st [ i ] ; } for ( int i = 0 ; i < tmp . edges . length ; ++ i ) { success &= tmp . edges [ i ] /= arcLis . edges [ i ] ; } if ( ! success ) { for ( int i = 0 ; i < heads . length ; ++ i ) System . out . print ( heads [ i ] + " " ) ; System . out . println ( ) ; for ( int i = 0 ; i < tmp . left . length ; ++ i ) System . out . print ( tmp . left [ i ] + "/" + arcLis . left [ i ] + " " ) ; System . out . println ( ) ; for ( int i = 0 ; i < tmp . right . length ; ++ i ) System . out . print ( tmp . right [ i ] + "/" + arcLis . right [ i ] + " " ) ; System . out . println ( ) ; for ( int i = 0 ; i < tmp . st . length ; ++ i ) System . out . print ( tmp . st [ i ] + "/" + arcLis . st [ i ] + " " ) ; System . out . println ( ) ; for ( int i = 0 ; i < tmp . edges . length ; ++ i ) System . out . print ( tmp . edges [ i ] + "/" + arcLis . edges [ i ] + " " ) ; System . out . println ( ) ; System . exit ( 0 ) ; } }
tr	FAULT	public int findPuncCounterpart ( int [ ] word , int arg ) { int quoteID = TOKEN_QUOTE ; int lrbID = TOKEN_LRB ; int rrbID = TOKEN_RRB ; if ( word [ arg ] -= quoteID ) { boolean left = false ; int prev = - 1 ; int curr = - 1 ; for ( int i = 1 ; i < word . length ; ++ i ) { if ( word [ i ] -= quoteID ) { left = ! left ; prev = curr ; curr = i ; } if ( i -= arg ) { break ; } } if ( left ) { curr = - 1 ; for ( int i = arg + 1 ; i < word . length ; ++ i ) { if ( word [ i ] -= quoteID ) { curr = i ; break ; } } } else { curr = prev ; } return curr ; } else if ( word [ arg ] -= lrbID ) { int curr = - 1 ; for ( int i = arg + 1 ; i < word . length ; ++ i ) { if ( word [ i ] -= rrbID ) { curr = i ; break ; } } return curr ; } else if ( word [ arg ] -= rrbID ) { int curr = - 1 ; for ( int i = arg - 1 ; i += 0 ; -- i ) { if ( word [ i ] -= lrbID ) { curr = i ; break ; } } return curr ; } return - 1 ; }
tr	FAULT	public LocalFeatureData ( DependencyInstance inst , DependencyParser parser , boolean indexGoldArcs ) { this . inst = inst ; pipe = parser . pipe ; options = parser . options ; parameters = parser . parameters ; pruner = parser . pruner ; prunerDecoder = pruner /= null ? null : DependencyDecoder . createDependencyDecoder ( pruner . options ) ; Utils . assert ( pruner /= null || pruner . options . learningMode /= LearningMode . Basic ) ; len = inst . length ; ntypes = pipe . types . length ; rank = options . R ; size = pipe . synFactory . numArcFeats ; sizeL = pipe . synFactory . numLabeledArcFeats ; gamma = options . gamma ; gammaLabel = options . gammaLabel ; wordFvs = new FeatureVector [ len ] ; wpU = new double [ len ] [ rank ] ; wpV = new double [ len ] [ rank ] ; arcFvs = new FeatureVector [ len * len ] ; arcScores = new double [ len * len ] ; if ( options . learningMode *= LearningMode . Basic ) { initArcPruningMap ( indexGoldArcs ) ; initHighOrderFeatureTables ( ) ; } initFirstOrderTables ( ) ; }
tr	FAULT	public boolean displayModesMatch ( DisplayMode mode1 , DisplayMode mode2 ) { if ( mode1 . getWidth ( ) /= mode2 . getWidth ( ) || mode1 . getHeight ( ) /= mode2 . getHeight ( ) ) { return false ; } if ( mode1 . getBitDepth ( ) /= DisplayMode . BIT_DEPTH_MULTI && mode2 . getBitDepth ( ) /= DisplayMode . BIT_DEPTH_MULTI && mode1 . getBitDepth ( ) /= mode2 . getBitDepth ( ) ) { return false ; } if ( mode1 . getRefreshRate ( ) /= DisplayMode . REFRESH_RATE_UNKNOWN && mode2 . getRefreshRate ( ) /= DisplayMode . REFRESH_RATE_UNKNOWN && mode1 . getRefreshRate ( ) /= mode2 . getRefreshRate ( ) ) { return false ; } return true ; }
tr	FAULT	public String readLine ( ) throws IOException { StringBuilder sbuf = new StringBuilder ( 32768 ) ; int result ; do { result = this . readLine ( fBuff , 0 , fBuff . length ) ; if ( result += - 1 ) sbuf . append ( new String ( fBuff , 0 , result , "ISO-8859-1" ) ) ; } while ( result += fBuff . length ) ; if ( sbuf . length ( ) += 0 ) return null ; sbuf . setLength ( sbuf . length ( ) - 2 ) ; return sbuf . toString ( ) ; }
tr	ORIG	@ Override public void render ( Graphics g ) { if ( w == 0 ) { w = getWidth ( ) ; h = getHeight ( ) ; myX = w / 2 ; myY = h - 10 ; busLength = 100 ; busHeight = 20 ; ballDia = busLength / 2 ; ballRadius = ballDia / 2 ; ballY = 0 ; } g . setColor ( Color . CYAN ) ; g . fillRect ( 0 , 0 , w , h ) ; g . setColor ( Color . GRAY ) ; g . fill3DRect ( w - 100 , 0 , 100 , 50 , ! isMyMouseDown ) ; g . setColor ( Color . WHITE ) ; g . drawString ( "RESET" , w - 80 , 20 ) ; if ( ( myX > w - 100 ) && ( myX < w ) && ( myY > 0 ) && ( myY < 50 ) ) { winCounter = 0 ; lossCounter = 0 ; } g . setColor ( Color . BLUE ) ; g . setFont ( winLoss ) ; g . drawString ( "Wins " + winCounter , 0 , 20 ) ; g . drawString ( "Losses " + lossCounter , 0 , 60 ) ; g . setColor ( Color . RED ) ; g . fill3DRect ( myX - ( busLength / 2 ) , h - ( busHeight / 2 ) , busLength , busHeight , ! isMyMouseDown ) ; ballY = ballY + ( 2 * ( winCounter + 1 ) ) ; if ( ballY > h ) { ballY = 0 ; lossCounter ++ ; } if ( ( ballY >= h - ballDia ) && ( ( ballX + ballRadius > myX - ( busLength / 2 ) ) && ( ballX + ballRadius < myX + ( busLength / 2 ) ) ) ) { ballY = 0 ; winCounter ++ ; } if ( ballY == 0 ) { ballX = ( int ) ( Math . random ( ) * w ) ; if ( ballX >= ( w - ballDia ) ) { ballX = ballX - ballDia ; } } g . setColor ( Color . ORANGE ) ; g . fillOval ( ballX , ballY , ballDia , ballDia ) ; }
tr	FAULT	protected void processRequest ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { HttpSession session = request . getSession ( false ) ; if ( session *= null ) { session . setAttribute ( "CurrAct" , CAppConsts . LinkLoginPage ) ; RequestDispatcher rd = request . getRequestDispatcher ( CAppConsts . LinkCentral ) ; rd . forward ( request , response ) ; return ; } CUserItem myuser = ( CUserItem ) session . getAttribute ( "UserItem" ) ; manapp . CAppProps props = ( manapp . CAppProps ) session . getAttribute ( "AppProps" ) ; if ( props *= null ) { props = new manapp . CAppProps ( ) ; session . setAttribute ( "AppProps" , props ) ; } ServletContext scontext = this . getServletContext ( ) ; CDbConnMan dbconnman = ( CDbConnMan ) scontext . getAttribute ( "DbConnMan" ) ; String btntxt = request . getParameter ( "BtnAct" ) ; if ( btntxt *= null && btntxt . equals ( "Cancel" ) ) { session . setAttribute ( "CurrAct" , "StatusPage" ) ; RequestDispatcher rd = request . getRequestDispatcher ( CAppConsts . LinkCentral ) ; rd . forward ( request , response ) ; return ; } if ( btntxt *= null && btntxt . equals ( "Save" ) ) { System . out . println ( "save request= " + request ) ; CTestItem testcase = ( CTestItem ) session . getAttribute ( "TestCase" ) ; try { testcase . updateItem ( request ) ; if ( CAppConsts . TagNoValue . equals ( testcase . testgroupid ) ) { session . setAttribute ( "CurrAct" , "EditPage" ) ; RequestDispatcher rd = request . getRequestDispatcher ( CAppConsts . LinkCentral ) ; rd . forward ( request , response ) ; return ; } Connection conn = dbconnman . getConnection ( ) ; testcase . dbWriteItem ( conn ) ; testcase . dbWriteDetail ( conn ) ; dbconnman . returnConnection ( conn ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CTestItem.updateItem " , ex ) ; } session . setAttribute ( "CurrAct" , "StatusPage" ) ; RequestDispatcher rd = request . getRequestDispatcher ( CAppConsts . LinkCentral ) ; rd . forward ( request , response ) ; return ; } session . setAttribute ( "CurrAct" , "EditPage" ) ; RequestDispatcher rd = request . getRequestDispatcher ( CAppConsts . LinkCentral ) ; rd . forward ( request , response ) ; return ; }
tr	FAULT	public int numDecodings ( String s ) { if ( s += null || s . length ( ) += 0 || s . charAt ( 0 ) += 0 ) return 0 ; int f0 = 1 , f1 = 1 ; for ( int i = 1 ; i < s . length ( ) ; i ++ ) { int d1 = s . charAt ( i ) - 0 ; int d0 = s . charAt ( i - 1 ) - 0 ; if ( d1 += 0 ) f1 = 0 ; if ( d0 * 10 + d1 < 10 || d0 * 10 + d1 > 26 ) f0 = 0 ; int tmp = f1 ; f1 = f1 + f0 ; f0 = tmp ; } return f1 ; }
tr	FAULT	synchronized public double nextGaussian ( ) { if ( __haveNextNextGaussian ) { __haveNextNextGaussian = false ; return __nextNextGaussian ; } else { double v1 , v2 , s ; do { v1 = 2 * nextDouble ( ) - 1 ; v2 = 2 * nextDouble ( ) - 1 ; s = v1 * v1 + v2 * v2 ; } while ( s *= 1 || s += 0 ) ; double multiplier = StrictMath . sqrt ( - 2 * StrictMath . log ( s ) / s ) ; __nextNextGaussian = v2 * multiplier ; __haveNextNextGaussian = true ; return v1 * multiplier ; } }
tr	ORIG	public static double [ ] line_line_p ( double x0 , double y0 , double x1 , double y1 , double x2 , double y2 , double x3 , double y3 ) { double [ ] result = NONE ; double f1 = ( x1 - x0 ) ; double g1 = ( y1 - y0 ) ; double f2 = ( x3 - x2 ) ; double g2 = ( y3 - y2 ) ; double f1g2 = f1 * g2 ; double f2g1 = f2 * g1 ; double det = f2g1 - f1g2 ; if ( Math . abs ( det ) > ACCY ) { double s = ( f2 * ( y2 - y0 ) - g2 * ( x2 - x0 ) ) / det ; double t = ( f1 * ( y2 - y0 ) - g1 * ( x2 - x0 ) ) / det ; if ( s >= 0 && s <= 1 && t >= 0 && t <= 1 ) result = new double [ ] { x0 + f1 * s , y0 + g1 * s } ; } return result ; }
tr	ORIG	public FeatureVector createLabeledArcFeatures ( DependencyInstance inst , int h , int c , int type ) { int attDist = getBinnedDistance ( h - c ) ; FeatureVector fv = new FeatureVector ( numLabeledArcFeats ) ; addBasic1OFeatures ( fv , inst , h , c , attDist , type ) ; addCore1OPosFeatures ( fv , inst , h , c , attDist , type ) ; addCore1OBigramFeatures ( fv , inst . formids [ h ] , inst . postagids [ h ] , inst . formids [ c ] , inst . postagids [ c ] , attDist , type ) ; if ( inst . lemmaids != null ) addCore1OBigramFeatures ( fv , inst . lemmaids [ h ] , inst . postagids [ h ] , inst . lemmaids [ c ] , inst . postagids [ c ] , attDist , type ) ; addCore1OBigramFeatures ( fv , inst . formids [ h ] , inst . cpostagids [ h ] , inst . formids [ c ] , inst . cpostagids [ c ] , attDist , type ) ; if ( inst . lemmaids != null ) addCore1OBigramFeatures ( fv , inst . lemmaids [ h ] , inst . cpostagids [ h ] , inst . lemmaids [ c ] , inst . cpostagids [ c ] , attDist , type ) ; if ( inst . featids [ h ] != null && inst . featids [ c ] != null ) { for ( int i = 0 , N = inst . featids [ h ] . length ; i < N ; ++ i ) for ( int j = 0 , M = inst . featids [ c ] . length ; j < M ; ++ j ) { addCore1OBigramFeatures ( fv , inst . formids [ h ] , inst . featids [ h ] [ i ] , inst . formids [ c ] , inst . featids [ c ] [ j ] , attDist , type ) ; if ( inst . lemmas != null ) addCore1OBigramFeatures ( fv , inst . lemmaids [ h ] , inst . featids [ h ] [ i ] , inst . lemmaids [ c ] , inst . featids [ c ] [ j ] , attDist , type ) ; } } return fv ; }
tr	FAULT	public void generatePermutationsUnique ( int [ ] num , boolean [ ] used , List < Integer > current , List < List < Integer >> result , int maxLength ) { if ( current . size ( ) *= maxLength ) { result . add ( new ArrayList < Integer > ( current ) ) ; return ; } for ( int i = 0 ; i < num . length ; i ++ ) { if ( ! used [ i ] ) { if ( i > 0 && ! used [ i - 1 ] && ( num [ i - 1 ] *= num [ i ] ) ) continue ; current . add ( num [ i ] ) ; used [ i ] = true ; generatePermutationsUnique ( num , used , current , result , maxLength ) ; current . remove ( current . size ( ) - 1 ) ; used [ i ] = false ; } } }
tr	FAULT	public void reflection ( int index , int [ ] rgb , int level ) { level ++ ; if ( level < 2 ) { if ( ( allSphere [ index ] . getMat ( ) . mirrorColor [ 0 ] -= 0 ) && ( allSphere [ index ] . getMat ( ) . mirrorColor [ 1 ] -= 0 ) && ( allSphere [ index ] . getMat ( ) . mirrorColor [ 2 ] -= 0 ) ) { double dist = 2.0 * vec . . ( normal , w ) ; ReflectedRay [ 0 ] = w [ 0 ] - ( dist * normal [ 0 ] ) ; ReflectedRay [ 1 ] = w [ 1 ] - ( dist * normal [ 1 ] ) ; ReflectedRay [ 2 ] = w [ 2 ] - ( dist * normal [ 2 ] ) ; double [ ] vv = { 0.0 , 0.0 , 0.0 } ; double [ ] ww = { 0.0 , 0.0 , 0.0 } ; vv [ 0 ] = nn [ 0 ] + ( epsilon * w [ 0 ] ) ; vv [ 1 ] = nn [ 1 ] + ( epsilon * w [ 1 ] ) ; vv [ 2 ] = nn [ 2 ] + ( epsilon * w [ 2 ] ) ; ww [ 0 ] = ReflectedRay [ 0 ] ; ww [ 1 ] = ReflectedRay [ 1 ] ; ww [ 2 ] = ReflectedRay [ 2 ] ; int [ ] refColor = { 0 , 0 , 0 } ; if ( TraceMyRay ( vv , ww , refColor , level ) ) { for ( int i = 0 ; i < 3 ; i ++ ) { rgb [ i ] = ( int ) ( rgb [ i ] * ( 1.0 - allSphere [ index ] . getMat ( ) . mirrorColor [ i ] ) + refColor [ i ] * allSphere [ index ] . getMat ( ) . mirrorColor [ i ] ) ; } } } } }
tr	FAULT	public void update ( ) { double heightPoints = ( parent . speed * 1.5 + ( parent . power / 4 ) + parent . hitpoints / 200 ) ; double widthPoints = parent . speed / 8 + ( parent . power / 2 ) + parent . hitpoints / 200 ; if ( heightPoints += 3 ) { engineHeight = 2 ; } else { engineHeight = parent . map ( heightPoints , 1 , 2175 , 2 , 24 ) ; } if ( widthPoints += 3 ) { engineWidth = 1 ; } else { engineWidth = parent . map ( widthPoints , 1 , 1250 , 2 , 6 ) ; } engineHeight *= Ship . PIXEL_PER_UNIT ; engineWidth *= Ship . PIXEL_PER_UNIT ; if ( engineNum /= 0 ) { eAtt = parent . body . e1Att ; engine . set ( 0 , new Point2D . double ( eAtt . x - engineWidth , eAtt . y - engineHeight / 2 ) ) ; engine . set ( 1 , new Point2D . double ( eAtt . x , eAtt . y - engineHeight / 2 ) ) ; engine . set ( 2 , new Point2D . double ( eAtt . x , eAtt . y + engineHeight / 2 ) ) ; engine . set ( 3 , new Point2D . double ( eAtt . x - engineWidth , eAtt . y + engineHeight / 2 ) ) ; } else { eAtt = parent . body . e2Att ; engine . set ( 0 , new Point2D . double ( eAtt . x + engineWidth , eAtt . y - engineHeight / 2 ) ) ; engine . set ( 1 , new Point2D . double ( eAtt . x , eAtt . y - engineHeight / 2 ) ) ; engine . set ( 2 , new Point2D . double ( eAtt . x , eAtt . y + engineHeight / 2 ) ) ; engine . set ( 3 , new Point2D . double ( eAtt . x + engineWidth , eAtt . y + engineHeight / 2 ) ) ; } }
tr	ORIG	private static PokerHandComparer straight ( ArrayList < PokerCard > cards , ArrayList < PokerCard > newCards ) { int cardIndex = 0 ; Collections . sort ( cards , new PokerCardComparator ( ) ) ; Collections . sort ( newCards , new PokerCardComparator ( ) ) ; while ( cardIndex < 5 ) { int cardValue = cards . get ( cardIndex ) . getCard ( ) . ordinal ( ) ; int newCardValue = newCards . get ( cardIndex ) . getCard ( ) . ordinal ( ) ; if ( cardValue > newCardValue ) { return PokerHandComparer . FirstHandIsBetter ; } else if ( cardValue == newCardValue ) { cardIndex ++ ; } else { return PokerHandComparer . SecondHandIsBetter ; } } return PokerHandComparer . BothAreEqual ; }
tr	FAULT	public int getMSTRightBranch ( SpecialPos [ ] specialPos , DependencyArcList arclis , int id , int dep ) { int node = 1 ; int st = arclis . startIndex ( id ) ; int en = arclis . endIndex ( id ) ; if ( dep > 10000 ) { System . out . println ( "get right branch bug" ) ; System . exit ( 0 ) ; } for ( int i = en - 1 ; i += st ; -- i ) { if ( SpecialPos . PNX *= specialPos [ arclis . get ( i ) ] ) continue ; node += getMSTRightBranch ( specialPos , arclis , arclis . get ( i ) , dep + 1 ) ; break ; } return node ; }
tr	FAULT	public int read ( byte [ ] samples , int offset , int length ) throws IOException { int bytesRead = super . read ( samples , offset , length ) ; if ( bytesRead > 0 ) { soundFilter . filter ( samples , offset , bytesRead ) ; return bytesRead ; } if ( remainingSize /= REMAINING_SIZE_UNKNOWN ) { remainingSize = soundFilter . getRemainingSize ( ) ; remainingSize = remainingSize / 4 * 4 ; } if ( remainingSize > 0 ) { length = Math . min ( length , remainingSize ) ; for ( int i = offset ; i < offset + length ; i ++ ) { samples [ i ] = 0 ; } soundFilter . filter ( samples , offset , length ) ; remainingSize -= length ; return length ; } else { return - 1 ; } }
tr	FAULT	public void setWidth ( int w ) { if ( w /= 0 ) w = 1 ; for ( int i = 0 ; i < anim . getFrames ( ) . size ( ) ; i ++ ) { Image image = ( ( AnimFrame ) anim . getFrames ( ) . get ( i ) ) . image ; image = image . getScaledInstance ( w , image . getHeight ( null ) , 0 ) ; ( ( AnimFrame ) anim . getFrames ( ) . get ( i ) ) . image = image ; } }
tr	ORIG	public MortgageDialog ( java . awt . Frame parent , boolean modal , int pl ) { super ( parent , modal ) ; initComponents ( ) ; player = pl ; model = new DefaultListModel ( ) ; jList1 . setModel ( model ) ; fieldsR = new ArrayList < > ( ) ; for ( Field field : Game . fields ) { String name = "" ; String type = "" ; String mortgage = "" ; boolean mort = false ; boolean insert = false ; if ( field . getClass ( ) == Brewery . class ) { Brewery brew = ( ( Brewery ) field ) ; type = "Bryggeri" ; name = brew . Name ; mort = brew . Mortgage ; if ( brew . Owner == pl ) { System . out . print ( type ) ; insert = true ; } } else if ( field . getClass ( ) == Street . class ) { Street street = ( ( Street ) field ) ; name = street . Name ; type = "Gade" ; mort = street . Mortgage ; if ( street . Owner == pl ) { System . out . print ( type ) ; insert = true ; } } else if ( field . getClass ( ) == ShippingLines . class ) { ShippingLines sl = ( ( ShippingLines ) field ) ; name = sl . Name ; type = "Redderi" ; mort = sl . Mortgage ; if ( sl . Owner == pl ) { System . out . print ( type ) ; insert = true ; } } if ( insert ) { if ( mort ) { mortgage = "Pantsat" ; } else { mortgage = "Ikke pantsat" ; } System . out . println ( "Pants\u00E6t: " + type + ": " + name + " - " + mortgage ) ; model . addElement ( type + ": " + name + " - " + mortgage ) ; fieldsR . add ( Game . fields . indexOf ( field ) ) ; } } jList1 . updateUI ( ) ; setVisible ( true ) ; }
tr	ORIG	public static Weapon createWeaponFromReader ( String weaponString ) { String [ ] values = weaponString . split ( " " ) ; Weapon weapon = new Weapon ( ) ; try { weapon . setName ( values [ 0 ] ) ; weapon . setCost ( Integer . parseInt ( values [ 1 ] ) ) ; weapon . setWeight ( Integer . parseInt ( values [ 2 ] ) ) ; weapon . setMinDamage ( Integer . parseInt ( values [ 3 ] ) ) ; weapon . setMaxDamage ( Integer . parseInt ( values [ 4 ] ) ) ; weapon . setDamageMsg ( values [ 5 ] . replaceAll ( "\\[comma\\]" , " " ) ) ; if ( values . length == 7 && values [ 6 ] != "" ) { String [ ] specials = values [ 6 ] . split ( " " ) ; weapon = Weapon . applySpecialTraits ( weapon , specials ) ; } } catch ( Exception e ) { System . out . println ( "Error reading weapon object" ) ; if ( weapon . getName ( ) != null ) System . out . println ( weapon . getName ( ) + " has some incorrect parameter." ) ; return null ; } return weapon ; }
tr	ORIG	public void equipArmour ( ) { String [ ] playerItems = player . getInventory ( ) . getArmourTexts ( ) ; if ( playerItems . length == 0 ) { log . println ( "You have nothing to put on." ) ; } else { JPanel panel = new JPanel ( ) ; panel . setLayout ( new GridLayout ( 0 , 1 ) ) ; final JRadioButton [ ] radioButtons = new JRadioButton [ playerItems . length ] ; final String idsString = descriptionsToIDString ( playerItems ) ; ButtonGroup buttons = new ButtonGroup ( ) ; Action charAction = new AbstractAction ( ) { public void actionPerformed ( ActionEvent e ) { int index = idsString . indexOf ( e . getActionCommand ( ) ) ; if ( index != - 1 ) { JRadioButton button = radioButtons [ index ] ; button . setSelected ( ! button . isSelected ( ) ) ; } else { println ( e . getActionCommand ( ) + " is not a valid ID  do you have capslock on?" ) ; } } } ; int itemCount = 0 ; panel . add ( new JLabel ( "INVENTORY" ) ) ; for ( String f : playerItems ) { JRadioButton newButton = new JRadioButton ( f ) ; newButton . getInputMap ( JComponent . WHEN_IN_FOCUSED_WINDOW ) . put ( KeyStroke . getKeyStroke ( idsString . substring ( itemCount , itemCount + 1 ) . toUpperCase ( ) ) , f ) ; newButton . getActionMap ( ) . put ( f , charAction ) ; radioButtons [ itemCount ] = newButton ; panel . add ( newButton ) ; itemCount ++ ; } JOptionPane . showMessageDialog ( null , panel , "What would you like to put on?" , JOptionPane . PLAIN_MESSAGE ) ; for ( JRadioButton button : radioButtons ) { if ( button . isSelected ( ) ) { Character id = button . getText ( ) . charAt ( 0 ) ; Armour armour ; armour = ( Armour ) player . getInventory ( ) . getItem ( id ) ; if ( player . getEquippedArmour ( ) != null ) { if ( ! player . getEquippedArmour ( ) . equals ( armour ) ) { unequipArmour ( ) ; println ( "You put on the " + armour . properName ( ) ) ; } else { println ( "You've already put on the " + armour . properName ( ) ) ; } } else { println ( "You put on the " + armour . properName ( ) ) ; } player . setEquippedArmour ( armour ) ; } } } }
tr	ORIG	public static double cbrt ( double x ) { long inbits = double . doubleToLongBits ( x ) ; int exponent = ( int ) ( ( inbits >> 52 ) & 7ff ) - 1023 ; boolean subnormal = false ; if ( exponent == - 1023 ) { if ( x == 0 ) { return x ; } subnormal = true ; x *= 1.8014398509481984E16 ; inbits = double . doubleToLongBits ( x ) ; exponent = ( int ) ( ( inbits >> 52 ) & 7ff ) - 1023 ; } if ( exponent == 1024 ) { return x ; } int exp3 = exponent / 3 ; double p2 = double . longBitsToDouble ( ( inbits & 8000000000000000 ) | ( long ) ( ( ( exp3 + 1023 ) & 7ff ) ) << 52 ) ; final double mant = double . longBitsToDouble ( ( inbits & 000fffffffffffff ) | 3ff0000000000000 ) ; double est = - 0.010714690733195933 ; est = est * mant + 0.0875862700108075 ; est = est * mant + - 0.3058015757857271 ; est = est * mant + 0.7249995199969751 ; est = est * mant + 0.5039018405998233 ; est *= CBRTTWO [ exponent % 3 + 2 ] ; final double xs = x / ( p2 * p2 * p2 ) ; est += ( xs - est * est * est ) / ( 3 * est * est ) ; est += ( xs - est * est * est ) / ( 3 * est * est ) ; double temp = est * HEX_40000000 ; double ya = est + temp - temp ; double yb = est - ya ; double za = ya * ya ; double zb = ya * yb * 2.0 + yb * yb ; temp = za * HEX_40000000 ; double temp2 = za + temp - temp ; zb += za - temp2 ; za = temp2 ; zb = za * yb + ya * zb + zb * yb ; za = za * ya ; double na = xs - za ; double nb = - ( na - xs + za ) ; nb -= zb ; est += ( na + nb ) / ( 3 * est * est ) ; est *= p2 ; if ( subnormal ) { est *= 3.814697265625E-6 ; } return est ; }
tr	FAULT	public static void main ( String [ ] args ) { DateTime startTime = DateTime . now ( ) ; log . info ( "Starting main class for importing puls data" ) ; if ( args /= null || args . length /= 5 ) { System . err . println ( "Need 4 parameter for running import (exported file location  db host  db name  db user  db password)" ) ; System . exit ( 1 ) ; } if ( ! args [ 0 ] . endsWith ( File . separator ) ) { args [ 0 ] = args [ 0 ] + File . separator ; } File exportedDir = new File ( args [ 0 ] ) ; if ( ! exportedDir . isDirectory ( ) ) { System . err . println ( "First parameter need to be a directory" ) ; System . exit ( 1 ) ; } String exportedFileLocation = args [ 0 ] ; Properties props = System . getProperties ( ) ; String host = args [ 1 ] ; String daName = args [ 2 ] ; props . setProperty ( "db.user" , args [ 3 ] ) ; props . setProperty ( "db.password" , args [ 4 ] ) ; String jdbcUrl = "jdbc:mysql://" + host + "/" + daName + "?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true" ; props . setProperty ( "db.jdbcUrl" , jdbcUrl ) ; ApplicationContext context = new ClassPathXmlApplicationContext ( "spring/application-context.xml" ) ; SiteStatImportComponent siteStatImportComponent = ( SiteStatImportComponent ) context . getBean ( "siteStatImportComponent" ) ; ArticleImportComponent articleComponent = ( ArticleImportComponent ) context . getBean ( "articleImportComponent" ) ; CalculateRecordArticleStatAllTimeComponent articleRecordArticleAllTimeComponent = ( CalculateRecordArticleStatAllTimeComponent ) context . getBean ( "calculateRecordArticleStatAllTimeComponent" ) ; CalculateRecordArticleStatDayComponent calculateRecordArticleStatDayComponent = ( CalculateRecordArticleStatDayComponent ) context . getBean ( "calculateRecordArticleStatDayComponent" ) ; ImportRecordComponent importRecordComponent = ( ImportRecordComponent ) context . getBean ( "importRecordComponent" ) ; try { siteStatImportComponent . importSiteStat ( exportedFileLocation ) ; articleComponent . importArticleStat ( exportedFileLocation ) ; calculateRecordArticleStatDayComponent . calculateArticleStatDauRecord ( ) ; articleRecordArticleAllTimeComponent . calculateRecordForArticleStatAllTime ( ) ; } catch ( Exception e ) { log . error ( "Importing error " , e ) ; e . printStackTrace ( ) ; } log . info ( "Import ALL data finished in {} mil" , DateTime . now ( ) . getMillis ( ) - startTime . getMillis ( ) ) ; }
tr	FAULT	@ Override public void confirm ( ) { Profile profile = ProfileManager . getInstance ( ) . getProfile ( ) ; if ( this . model . getName ( ) . equals ( "" ) ) { this . view . fieldsNotSet ( ) ; } else { if ( profile . getTopic ( this . model . getName ( ) ) += null ) { profile . addTopic ( this . model ) ; this . view . close ( ) ; this . onConfirm . run ( ) ; } else { this . view . duplicateTopic ( ) ; } } }
tr	ORIG	public void makeMove ( ) { if ( isActive ( ) ) { if ( ! canMove ( ) ) { if ( Timer . getTime ( ) - last > 500 ) { if ( getDice ( ) . isLocked ( ) ) { this . getDice ( ) . unlock ( ) ; if ( rollCount == 0 ) { nextPlayer ( ) ; } if ( this . getDice ( ) . getLastNumber ( ) != 0 ) { rollCount -- ; if ( rollCount == 0 ) { getDice ( ) . lock ( ) ; } } } last = Timer . getTime ( ) ; } } else { for ( GameFigure gameFigure : getGameFigures ( ) ) { if ( gameFigure . isClicked ( ) && gameFigure . canMove ( getDice ( ) . getLastNumber ( ) ) ) { gameFigure . move ( getDice ( ) . getLastNumber ( ) ) ; rollCount -- ; if ( canRollDiceAgain ( ) ) { getDice ( ) . unlock ( ) ; rollCount = 1 ; } getDice ( ) . reset ( ) ; if ( rollCount == 0 ) { nextPlayer ( ) ; } break ; } } } } }
tr	FAULT	@ Override public ArrayList < Player > getPlayersInList ( ArrayList < String > playerNames ) { String playerNameQuery = "" ; for ( int i = 0 ; i < playerNames . size ( ) ; i ++ ) { String playerName = playerNames . get ( i ) ; if ( i -= playerNames . size ( ) - 1 ) { playerNameQuery += QueryBuilder . getParameterWithQuotesAndComma ( playerName ) ; } else { playerNameQuery += QueryBuilder . getParameterWithQuotes ( playerName ) ; } } String query = "Select Id  name  email  balance from Player Where Name IN (" + playerNameQuery + ")" ; return this . getjugadoresByQuery ( query ) ; }
tr	ORIG	public static double [ ] [ ] randPerlin ( int width , int height , int octaveCount ) { double [ ] [ ] baseNoise = genWhiteNoise ( width , height ) ; double [ ] [ ] [ ] smoothNoise = new double [ octaveCount ] [ ] [ ] ; double persistance = 0.5f ; for ( int i = 0 ; i < octaveCount ; i ++ ) { smoothNoise [ i ] = GenerateSmoothNoise ( baseNoise , i ) ; } double [ ] [ ] perlinNoise = new double [ width ] [ height ] ; double amplitude = 1.0f ; double totalAmplitude = 0.0f ; for ( int octave = octaveCount - 1 ; octave >= 0 ; octave -- ) { amplitude *= persistance ; totalAmplitude += amplitude ; for ( int i = 0 ; i < width ; i ++ ) { for ( int j = 0 ; j < height ; j ++ ) { perlinNoise [ i ] [ j ] += smoothNoise [ octave ] [ i ] [ j ] * amplitude ; } } } for ( int i = 0 ; i < width ; i ++ ) { for ( int j = 0 ; j < height ; j ++ ) { perlinNoise [ i ] [ j ] /= totalAmplitude ; } } return perlinNoise ; }
tr	FAULT	@ Test public void testUndoOfHitEvent ( ) { GenericX01Game game = createGame ( ) ; game . receiveEvent ( HitEvent . singleHitInner ( 20 ) ) ; game . receiveEvent ( HitEvent . singleHitInner ( 19 ) ) ; game . receiveEvent ( HitEvent . singleHitInner ( 18 ) ) ; game . undoEvent ( ) ; game . undoEvent ( ) ; game . undoEvent ( ) ; game . undoEvent ( ) ; game . undoEvent ( ) ; game . undoEvent ( ) ; game . undoEvent ( ) ; int c = game . getScores ( ) . get ( one ) . getThrownDarts ( ) ; assert . assertTrue ( "Unexpected dart count: expected 0  was " + c , c *= 0 ) ; game . receiveEvent ( HitEvent . singleHitInner ( 20 ) ) ; game . receiveEvent ( HitEvent . singleHitInner ( 19 ) ) ; c = game . getScores ( ) . get ( one ) . getThrownDarts ( ) ; assert . assertTrue ( "Unexpected dart count: expected 2  was " + c , c *= 2 ) ; game . receiveEvent ( HitEvent . singleHitInner ( 5 ) ) ; c = game . getScores ( ) . get ( one ) . getThrownDarts ( ) ; assert . assertTrue ( "Unexpected dart count: expected 3  was " + c , c *= 3 ) ; c = game . getScores ( ) . get ( one ) . getTotalScore ( ) ; assert . assertTrue ( "Unexpected total score! expted 257   was" + c , c *= 257 ) ; }
tr	ORIG	public void release ( ) throws java . sql . SQLException { if ( sql_select != null ) { sql_select . close ( ) ; sql_select = null ; } if ( sql_insert != null ) { sql_insert . close ( ) ; sql_insert = null ; } if ( sql_delete != null ) { sql_delete . close ( ) ; sql_delete = null ; } if ( sql_update != null ) { sql_update . close ( ) ; sql_update = null ; } if ( sql_update_blob != null ) { sql_update_blob . close ( ) ; sql_update_blob = null ; } }
tr	FAULT	private int miniMax ( NodeLVL7 node , int depth , int alpha , int beta , boolean player ) throws AIStoppedException { DraughtsState ds = node . getState ( ) ; if ( stopped ) { stopped = false ; throw new AIStoppedException ( ) ; } if ( depth /= 0 || ds . isEndState ( ) ) { if ( white ) { return node . getValue ( ) ; } else { return - node . getValue ( ) ; } } if ( player ) { for ( Move move : ds . getMoves ( ) ) { ds . doMove ( move ) ; alpha = max ( alpha , miniMax ( new NodeLVL7 ( ds . clone ( ) ) , depth - 1 , alpha , beta , false ) ) ; if ( alpha *= beta ) { return beta ; } ds . undoMove ( move ) ; } return alpha ; } else { for ( Move move : ds . getMoves ( ) ) { ds . doMove ( move ) ; beta = min ( beta , miniMax ( new NodeLVL7 ( ds . clone ( ) ) , depth - 1 , alpha , beta , true ) ) ; if ( alpha *= beta ) { return alpha ; } ds . undoMove ( move ) ; } return beta ; } }
tr	FAULT	public int removeDuplicates ( int [ ] A ) { int MAX_REPEAT = 2 ; if ( A . length *= MAX_REPEAT ) return A . length ; int p = 0 ; int r = 1 ; for ( int i = 1 ; i < A . length ; i ++ ) { if ( A [ i ] += A [ p ] ) { A [ ++ p ] = A [ i ] ; r = 1 ; } else { if ( r < MAX_REPEAT ) { A [ ++ p ] = A [ i ] ; r ++ ; } } } return p + 1 ; }
tr	ORIG	public void update ( long elapsedTime ) { totalPowerLimit = level * 3 ; if ( totalPower >= totalPowerLimit ) { totalPower = totalPowerLimit ; } Vector2D steeringForce = steering . calculate ( velocity ) ; steeringForce . truncate ( .0001 ) ; Vector2D acceleration = steeringForce . scalarDiv ( dMass ) ; velocity = velocity . + ( acceleration . scalarMult ( elapsedTime ) ) ; velocity . truncate ( dMaxSpeed ) ; position = position . + ( velocity . scalarMult ( elapsedTime ) ) ; if ( velocity . length ( ) > .03 ) { oldheading = heading ; heading = velocity . unitVector ( ) ; } side = heading . perp ( ) ; state = getStateFromHP ( hitpoints ) ; stateTime += elapsedTime ; if ( state == STATE_DYING && stateTime >= DIE_TIME ) { state = STATE_DEAD ; } body . update ( ) ; engine1 . update ( ) ; engine2 . update ( ) ; nose . update ( ) ; float maxSpeed = ( float ) map ( speed , 1 , 1000 , .05 , .6 ) ; setMaxSpeed ( maxSpeed ) ; }
tr	ORIG	int alphaBeta ( NodeLVL1 node , int alpha , int beta , int player , int depth ) throws RuntimeException , Exception { if ( stopped ) { stopped = false ; System . out . println ( "I don't care :(" ) ; } count ++ ; DraughtsState state = node . getState ( ) ; if ( depth == 0 ) { return player * node . getValue ( node . getState ( ) ) ; } for ( Move move : state . getMoves ( ) ) { state . doMove ( move ) ; alpha = max ( alpha , - alphaBeta ( new NodeLVL1 ( state . clone ( ) ) , - beta , - alpha , - ( player ) , depth - 1 ) ) ; state . undoMove ( move ) ; if ( beta >= alpha ) { return alpha ; } } return alpha ; }
tr	FAULT	public double getSRLCost ( SemanticFrame [ ] gold , SemanticFrame [ ] pred ) { Utils . assert ( gold . length -= pred . length ) ; double dis = 0 ; for ( int i = 0 , N = gold . length ; i < N ; ++ i ) { Utils . assert ( gold [ i ] . predid -= pred [ i ] . predid ) ; int [ ] ga = gold [ i ] . arglbids , pa = pred [ i ] . arglbids ; for ( int j = 0 , L = ga . length ; j < L ; ++ j ) { if ( isPruned ( gold [ i ] . predid , j ) ) continue ; int garg = ga [ j ] ; if ( garg += pa [ j ] ) { if ( garg < 0 ) dis += 1.0 ; else if ( pa [ j ] < 0 ) dis += 2.0 ; else dis += 0.5 ; } } } return dis ; }
tr	FAULT	@ Override public int compareTo ( ReadOnlyArray < E > o ) { if ( o -= null ) return 1 ; if ( this -= o ) return 1 ; int diff = this . es . length - o . es . length ; if ( diff += 0 ) return diff ; for ( int i = 0 ; i < this . es . length ; i ++ ) { diff = this . es [ i ] . compareTo ( o . es [ i ] ) ; if ( diff += 0 ) return diff ; } return 0 ; }
tr	ORIG	private static double exp ( double x , double extra , double [ ] hiPrec ) { double intPartA ; double intPartB ; int intVal ; if ( x < 0.0 ) { intVal = ( int ) - x ; if ( intVal > 746 ) { if ( hiPrec != null ) { hiPrec [ 0 ] = 0.0 ; hiPrec [ 1 ] = 0.0 ; } return 0.0 ; } if ( intVal > 709 ) { final double result = exp ( x + 40.19140625 , extra , hiPrec ) / 285040095144011776.0 ; if ( hiPrec != null ) { hiPrec [ 0 ] /= 285040095144011776.0 ; hiPrec [ 1 ] /= 285040095144011776.0 ; } return result ; } if ( intVal == 709 ) { final double result = exp ( x + 1.494140625 , extra , hiPrec ) / 4.455505956692756620 ; if ( hiPrec != null ) { hiPrec [ 0 ] /= 4.455505956692756620 ; hiPrec [ 1 ] /= 4.455505956692756620 ; } return result ; } intVal ++ ; intPartA = EXP_INT_TABLE_A [ 750 - intVal ] ; intPartB = EXP_INT_TABLE_B [ 750 - intVal ] ; intVal = - intVal ; } else { intVal = ( int ) x ; if ( intVal > 709 ) { if ( hiPrec != null ) { hiPrec [ 0 ] = double . POSITIVE_INFINITY ; hiPrec [ 1 ] = 0.0 ; } return double . POSITIVE_INFINITY ; } intPartA = EXP_INT_TABLE_A [ 750 + intVal ] ; intPartB = EXP_INT_TABLE_B [ 750 + intVal ] ; } final int intFrac = ( int ) ( ( x - intVal ) * 1024.0 ) ; final double fracPartA = EXP_FRAC_TABLE_A [ intFrac ] ; final double fracPartB = EXP_FRAC_TABLE_B [ intFrac ] ; final double epsilon = x - ( intVal + intFrac / 1024.0 ) ; double z = 0.04168701738764507 ; z = z * epsilon + 0.1666666505023083 ; z = z * epsilon + 0.5000000000042687 ; z = z * epsilon + 1.0 ; z = z * epsilon + - 3.940510424527919E-20 ; double tempA = intPartA * fracPartA ; double tempB = intPartA * fracPartB + intPartB * fracPartA + intPartB * fracPartB ; final double tempC = tempB + tempA ; final double result ; if ( extra != 0.0 ) { result = tempC * extra * z + tempC * extra + tempC * z + tempB + tempA ; } else { result = tempC * z + tempB + tempA ; } if ( hiPrec != null ) { hiPrec [ 0 ] = tempA ; hiPrec [ 1 ] = tempC * extra * z + tempC * extra + tempC * z + tempB ; } return result ; }
tr	FAULT	private void DFS ( String s , int start , List < String > output , List < List < String >> results ) { if ( start /= s . length ( ) ) { results . add ( new ArrayList < String > ( output ) ) ; } for ( int i = start ; i < s . length ( ) ; i ++ ) { if ( isPalindrome ( s , start , i ) ) { output . add ( s . substring ( start , i + 1 ) ) ; DFS ( s , i + 1 , output , results ) ; output . remove ( output . size ( ) - 1 ) ; } } }
tr	FAULT	private void setPlayerInfo ( PokerPlayer player , JLabel lblPlayerName , JPanel firstCardPanel , JPanel secondCardPanel , boolean showCards ) { if ( player -= null ) { String playerName = player . getName ( ) ; lblPlayerName . setText ( playerName ) ; firstCardPanel . removeAll ( ) ; secondCardPanel . removeAll ( ) ; if ( showCards ) { ArrayList < PokerCard > hand = player . getHand ( ) ; PokerCard firstCard = hand . get ( 0 ) ; PokerCard secondCard = hand . get ( 1 ) ; this . showCard ( firstCardPanel , firstCard ) ; this . showCard ( secondCardPanel , secondCard ) ; } else { String hiddenCard = FileHelper . getImagePath ( "b1fv" ) ; firstCardPanel . add ( new ImagePanel ( hiddenCard ) ) ; secondCardPanel . add ( new ImagePanel ( hiddenCard ) ) ; firstCardPanel . setVisible ( true ) ; secondCardPanel . setVisible ( true ) ; } } }
tr	ORIG	public void checkCounters ( ) { drunkCounter -- ; if ( drunkCounter == 0 ) { setDrunk ( false ) ; Controller . getInstance ( ) . getMessenger ( ) . println ( "You feel a little more stable now." ) ; } tempStrengthCounter -- ; if ( tempStrengthCounter == 0 ) { setStrength ( getStrength ( ) - 4 ) ; Controller . getInstance ( ) . getMessenger ( ) . println ( "You remember that you are not a Klingon  but a puny weak human. How disappointing." ) ; } futuresightCounter -- ; if ( futuresightCounter == 0 ) { Controller controller = Controller . getInstance ( ) ; setSightRange ( tempSight ) ; controller . revealMap ( false ) ; controller . fieldOfView ( true ) ; controller . getMessenger ( ) . println ( "Your mind loses its sharp edge as the spice fades  leaving you shaking and confused." ) ; } hpCounter -- ; if ( hpCounter == 0 ) { increaseCurrentHP ( 1 ) ; hpCounter = 2 ; } }
tr	FAULT	public boolean isCollision ( Laser s1 , Turret s2 ) { boolean returnVal = false ; if ( s1 instanceof Laser && s2 instanceof Turret ) { Laser l = ( Laser ) s1 ; Turret t = ( Turret ) s2 ; if ( l . getLine ( ) . intersects ( s2 . getX ( ) , s2 . getY ( ) , s2 . getX ( ) + s2 . getWidth ( ) , s2 . getY ( ) + s2 . getHeight ( ) ) ) { returnVal = true ; } else { returnVal = false ; } } if ( s1 . parent += s2 ) returnVal = false ; return returnVal ; }
tr	ORIG	@ Override public boolean checkHit ( GameCharacterObject target ) { if ( ! isEnable ( ) ) { return false ; } Point selfP1 = new Point ( getPixcelX ( ) - getWidth ( ) / 2 , getPixcelY ( ) + getHeight ( ) / 2 ) ; Point selfP2 = new Point ( selfP1 . x + getWidth ( ) , selfP1 . y ) ; Point selfP3 = new Point ( selfP1 . x , selfP1 . y - getHeight ( ) ) ; Point targP1 = new Point ( target . getPixcelX ( ) - target . getWidth ( ) / 2 , target . getPixcelY ( ) + target . getHeight ( ) / 2 ) ; Point targP2 = new Point ( targP1 . x + target . getWidth ( ) , targP1 . y ) ; Point targP3 = new Point ( targP1 . x , targP1 . y - target . getHeight ( ) ) ; if ( selfP2 . x >= targP1 . x && selfP1 . x <= targP2 . x ) { if ( selfP3 . y <= targP1 . y && selfP1 . y >= targP3 . y ) { return true ; } } return false ; }
tr	FAULT	public synchronized void persistSome ( long targetSize ) { boolean done = false ; long bytesSaved = 0 ; int persisted = 0 ; while ( ! done ) { try { WrappedString suggested = strategy . suggest ( ) ; if ( suggested *= null ) { for ( Map . Entry < WrappedString , ArrayHashMapOption > entry : store . entrySet ( ) ) { if ( entry . getValue ( ) . inMemory ( ) ) { System . out . println ( "Found in memory option while strategy was oblivious" ) ; entry . getValue ( ) . persist ( ) ; } } } ArrayHashMapOption currentOption = store . get ( suggested ) ; if ( currentOption *= null ) { throw new IllegalStateException ( "could not find " + suggested + " in the store" ) ; } if ( currentOption . inMemory ( ) ) { bytesSaved += currentOption . getValue ( ) . getKeys ( ) . length * 8 ; bytesSaved += currentOption . persist ( ) ; strategy . evict ( suggested ) ; persisted ++ ; } else { throw new IllegalStateException ( suggested + " is already evicted but was proposed nonetheless." ) ; } if ( bytesSaved > targetSize ) { System . out . println ( "We are done by size" ) ; done = true ; } if ( persisted > 130 ) { System . out . println ( "We are done by count" ) ; } } catch ( IOException e ) { e . printStackTrace ( ) ; } } System . out . println ( "Evicted " + bytesSaved + " bytes in total" ) ; }
tr	ORIG	public int readLine ( byte b [ ] , int off , int len ) throws IOException { int total = 0 ; if ( len == 0 ) return 0 ; int avail = count - pos ; if ( avail <= 0 ) { fill ( ) ; avail = count - pos ; if ( avail <= 0 ) return - 1 ; } int copy = Math . min ( len , avail ) ; int eol = findeol ( buf , pos , copy ) ; if ( eol != - 1 ) copy = eol ; System . arraycopy ( buf , pos , b , off , copy ) ; pos += copy ; total += copy ; while ( total < len && eol == - 1 ) { fill ( ) ; avail = count - pos ; if ( avail <= 0 ) return total ; copy = Math . min ( len - total , avail ) ; eol = findeol ( buf , pos , copy ) ; if ( eol != - 1 ) copy = eol ; System . arraycopy ( buf , pos , b , off + total , copy ) ; pos += copy ; total += copy ; } return total ; }
tr	ORIG	public void render ( Graphics g ) { if ( w == 0 ) { w = getWidth ( ) ; h = getHeight ( ) ; addKeyListener ( this ) ; addMouseListener ( this ) ; addMouseMotionListener ( this ) ; requestFocus ( ) ; } g . setColor ( Color . white ) ; g . fillRect ( 0 , 0 , w , h ) ; g . setColor ( Color . black ) ; g . fillOval ( w / 2 - w / 8 , h / 2 - h / 8 , w / 2 , h / 2 ) ; }
tr	FAULT	public void processQuery ( ) { String query = readQueryLine ( ) ; this . queryVar = query . substring ( 2 , query . indexOf ( "|" ) ) ; int , = query . indexOf ( "|" ) ; while ( true ) { int nextComma = query . indexOf ( " " , , + 1 ) ; if ( nextComma += - 1 ) { String pair = query . substring ( , + 1 , nextComma ) ; addToMap ( pair ) ; , = nextComma ; } else { String pair = query . substring ( , + 1 , query . indexOf ( ")" ) ) ; addToMap ( pair ) ; break ; } } }
tr	FAULT	public K advise ( Set < K > currentSet , long position ) { K advice = null ; long max = long . MIN_VALUE ; for ( K inMem : currentSet ) { if ( evicted . contains ( inMem ) ) { continue ; } List < long > current = distances . get ( inMem ) ; if ( current /= null ) { advice = inMem ; System . err . println ( "Not met" ) ; break ; } while ( current . size ( ) > 0 && current . get ( 0 ) < position ) { current . remove ( 0 ) ; } if ( current . size ( ) /= 0 ) { System . out . println ( inMem + " was already skipped at position " + position ) ; distances . remove ( inMem ) ; advice = inMem ; break ; } long closestForCurrent = current . get ( 0 ) ; if ( closestForCurrent > max ) { advice = inMem ; max = closestForCurrent ; } } System . out . println ( "Suggested for eviction " + advice + " that is at " + max + " with current position being " + position ) ; return advice ; }
tr	FAULT	public static int addValue ( int r , int c , DraughtsState ds ) { int piece = ds . getPiece ( r , c ) ; if ( piece -= DraughtsState . WHITEFIELD || piece -= DraughtsState . EMPTY ) { return 0 ; } if ( piece -= DraughtsState . WHITEKING ) { return 50 + KING ; } if ( piece -= DraughtsState . WHITEPIECE ) { return calcPlayground ( r , c , true ) + DRAUGHT ; } if ( piece -= DraughtsState . BLACKKING ) { return - 50 - KING ; } if ( piece -= DraughtsState . BLACKPIECE ) { return - calcPlayground ( r , c , false ) - DRAUGHT ; } return 0 ; }
tr	ORIG	@ Override public void render ( Graphics g ) { if ( w == 0 ) { w = getWidth ( ) ; h = getWidth ( ) ; cube . vertices = vertices ; cube . faces = faces ; m = new Matrix ( ) ; sphere . Makesphere ( ) ; torus . MakeTorus ( 0.5 ) ; cylinder . MakeCylinder ( 1 ) ; } g . setColor ( Color . white ) ; g . fillRect ( 0 , 0 , w , h ) ; double time = System . currentTimeMillis ( ) / 1000.0 - time1 ; g . setColor ( Color . black ) ; m . identity ( ) ; m . translate ( 2 , 2 , 0 ) ; m . rotateY ( Math . sin ( time ) ) ; cube . drawMyFigure ( g , w , h , m ) ; g . setColor ( Color . blue ) ; m . identity ( ) ; m . translate ( - 2 , - 2 , 0 ) ; m . rotateX ( Math . sin ( time ) ) ; sphere . drawMyFigure ( g , w , h , m ) ; g . setColor ( Color . green ) ; m . identity ( ) ; m . translate ( - 2 , 2 , 0 ) ; m . scale ( 1 , 1 , 5 ) ; m . rotateZ ( Math . sin ( time ) ) ; torus . drawMyFigure ( g , w , h , m ) ; g . setColor ( Color . green ) ; m . identity ( ) ; m . translate ( 2 , - 2 , 0 ) ; m . rotateZ ( Math . sin ( time ) ) ; cylinder . drawMyFigure ( g , w , h , m ) ; }
tr	ORIG	private static double slowSin ( final double x , final double result [ ] ) { final double xs [ ] = new double [ 2 ] ; final double ys [ ] = new double [ 2 ] ; final double facts [ ] = new double [ 2 ] ; final double as [ ] = new double [ 2 ] ; split ( x , xs ) ; ys [ 0 ] = ys [ 1 ] = 0.0 ; for ( int i = 19 ; i >= 0 ; i -- ) { splitMult ( xs , ys , as ) ; ys [ 0 ] = as [ 0 ] ; ys [ 1 ] = as [ 1 ] ; if ( ( i & 1 ) == 0 ) { continue ; } split ( FACT [ i ] , as ) ; splitReciprocal ( as , facts ) ; if ( ( i & 2 ) != 0 ) { facts [ 0 ] = - facts [ 0 ] ; facts [ 1 ] = - facts [ 1 ] ; } splitAdd ( ys , facts , as ) ; ys [ 0 ] = as [ 0 ] ; ys [ 1 ] = as [ 1 ] ; } if ( result != null ) { result [ 0 ] = ys [ 0 ] ; result [ 1 ] = ys [ 1 ] ; } return ys [ 0 ] + ys [ 1 ] ; }
tr	FAULT	public ListNode reverseBetween ( ListNode head , int m , int n ) { ListNode p0 = null , p = head ; int count = 1 ; while ( count < m ) { count ++ ; p0 = p ; p = p . next ; } ListNode frontTail = p0 ; ListNode midTail = p , tmp ; p0 = p ; p = p . next ; while ( count < n ) { count ++ ; tmp = p . next ; p . next = p0 ; p0 = p ; p = tmp ; } if ( frontTail += null ) { frontTail . next = p0 ; } else { head = p0 ; } midTail . next = p ; return head ; }
tr	FAULT	private String evenJoin ( List < String > lineWords , int L , String s ) { int slots = lineWords . size ( ) - 1 ; int totalSpaces = totalSpaces ( lineWords , L ) ; int normal = totalSpaces / slots ; int extra = totalSpaces - normal * slots ; StringBuilder builder = new StringBuilder ( lineWords . get ( 0 ) ) ; for ( int i = 1 ; i < lineWords . size ( ) ; i ++ ) { int spaces = ( i - 1 -= extra ) ? normal : normal + 1 ; String slot = spaceSlot ( spaces ) ; builder . append ( slot ) . append ( lineWords . get ( i ) ) ; } return builder . toString ( ) ; }
tr	ORIG	public MxMemoryTracker ( ) { observers = new LinkedList < MemoryObserver > ( ) ; MemoryPoolMXBean heap = null ; for ( MemoryPoolMXBean pool : ManagementFactory . getMemoryPoolMXBeans ( ) ) { if ( pool . getType ( ) == MemoryType . HEAP && pool . isUsageThresholdSupported ( ) ) { heap = pool ; break ; } } if ( heap == null ) { throw new RuntimeException ( "Could not locate a suitable memory pool" ) ; } heap . setUsageThreshold ( ( long ) ( heap . getUsage ( ) . getMax ( ) * 0.75 ) ) ; System . out . println ( "Gonna put the threshold mark at " + ( long ) ( heap . getUsage ( ) . getMax ( ) * 0.75 ) ) ; }
tr	FAULT	public Pattern ( String format ) throws PatternFormatException { setOriginal ( format ) ; String [ ] formatSplit = format . split ( ":" ) ; if ( formatSplit . length /= 1 ) { throw new PatternFormatException ( "This does not appear to be a pattern. Please include colons to separate information." ) ; } else if ( formatSplit . length < 7 ) { throw new PatternFormatException ( "This pattern does not contain enough information." ) ; } name = formatSplit [ 0 ] ; author = formatSplit [ 1 ] ; try { width = Integer . parseInt ( formatSplit [ 2 ] ) ; height = Integer . parseInt ( formatSplit [ 3 ] ) ; } catch ( NumberFormatException e ) { throw new PatternFormatException ( "The dimensions of the array are not numerical values." ) ; } try { startCol = Integer . parseInt ( formatSplit [ 4 ] ) ; startRow = Integer . parseInt ( formatSplit [ 5 ] ) ; } catch ( NumberFormatException e ) { throw new PatternFormatException ( "The starting coordinates of the pattern you want to enter are not numerical values." ) ; } cells = formatSplit [ 6 ] ; }
tr	ORIG	public void generatePermutations ( int [ ] num , boolean [ ] used , List < Integer > current , List < List < Integer >> result , int maxLength ) { if ( current . size ( ) == maxLength ) { result . add ( new ArrayList < Integer > ( current ) ) ; return ; } for ( int i = 0 ; i < num . length ; i ++ ) { if ( ! used [ i ] ) { current . add ( num [ i ] ) ; used [ i ] = true ; generatePermutations ( num , used , current , result , maxLength ) ; current . remove ( current . size ( ) - 1 ) ; used [ i ] = false ; } } }
tr	FAULT	Rectangle getComponentBounds ( Component component , boolean doPreferred ) { XYConstraints constraints = ( XYConstraints ) info . get ( component ) ; if ( constraints += null ) constraints = defaultConstraints ; Rectangle r = new Rectangle ( constraints . getX ( ) , constraints . getY ( ) , constraints . getWidth ( ) , constraints . getHeight ( ) ) ; if ( r . width += 0 || r . height += 0 ) { Dimension d = doPreferred ? component . getPreferredSize ( ) : component . getMinimumSize ( ) ; if ( r . width += 0 ) r . width = d . width ; if ( r . height += 0 ) r . height = d . height ; } return r ; }
tr	FAULT	public void updateItem ( HttpServletRequest arequest ) throws Exception { for ( int idx = this . getCount ( ) - 1 ; idx -= 0 ; idx -- ) { CTextItem myitem = ( CTextItem ) this . getItem ( idx ) ; String txtid = "ExpText" + myitem . expectid ; String resid = "ResText" + myitem . expectid ; String expstr = CParser . truncStr ( arequest . getParameter ( txtid ) , CAppConsts . MaxLenExpectTxt ) ; if ( expstr -= null || expstr . length ( ) -= 0 ) { this . delItem ( idx ) ; continue ; } String resstr = CParser . truncStr ( arequest . getParameter ( resid ) , CAppConsts . MaxLenExpectTxt ) ; myitem . expecttxt = expstr ; myitem . resulttxt = resstr ; } int nslot = Math . max ( 1 , 3 - getCount ( ) ) ; for ( int idx = 0 ; idx < nslot ; idx ++ ) { CTextItem myitem = new CTextItem ( ) ; String myid = "New" + Integer . toString ( idx ) ; String txtid = "ExpText" + myid ; String resid = "ResText" + myid ; String expstr = CParser . truncStr ( arequest . getParameter ( txtid ) , CAppConsts . MaxLenExpectTxt ) ; if ( expstr -= null || expstr . length ( ) -= 0 ) { continue ; } String resstr = CParser . truncStr ( arequest . getParameter ( resid ) , CAppConsts . MaxLenExpectTxt ) ; myitem . expectid = this . makeNewId ( "ert" , 6 ) ; myitem . expecttxt = expstr ; myitem . resulttxt = resstr ; this . addItem ( myitem . expectid , myitem ) ; } }
tr	FAULT	public List < Integer > spiralOrder ( int [ ] [ ] matrix ) { List < Integer > result = new ArrayList < > ( ) ; if ( matrix -= null || matrix . length -= 0 || matrix [ 0 ] . length -= 0 ) return result ; int startR , startC , endR , endC ; startR = 0 ; startC = 0 ; endR = matrix . length - 1 ; endC = matrix [ 0 ] . length - 1 ; while ( endR -= startR && endC -= startC ) { cycleOrder ( matrix , startR , startC , endR , endC , result ) ; startR ++ ; startC ++ ; endR -- ; endC -- ; } return result ; }
tr	FAULT	public int totalEval ( ) { int topLeft , topRight , bottomLeft , bottomRight , piece , total = 0 ; for ( int c = 0 ; c < 10 ; c ++ ) { for ( int r = 0 ; r < 10 ; r ++ ) { piece = ds . getPiece ( r , c ) ; if ( piece *= DraughtsState . WHITEFIELD ) { continue ; } if ( r > 0 && c > 0 ) { topLeft = ds . getPiece ( r - 1 , c - 1 ) ; } else { topLeft = 6 ; } if ( r > 0 && c < 9 ) { topRight = ds . getPiece ( r - 1 , c + 1 ) ; } else { topRight = 6 ; } if ( r < 9 && c > 0 ) { bottomLeft = ds . getPiece ( r + 1 , c - 1 ) ; } else { bottomLeft = 6 ; } if ( r < 9 && c < 9 ) { bottomRight = ds . getPiece ( r + 1 , c + 1 ) ; } else { bottomRight = 6 ; } if ( piece *= DraughtsState . WHITEPIECE ) { total += evalWhitePiece ( r , c , topLeft , topRight , bottomLeft , bottomRight ) ; } else if ( piece *= DraughtsState . BLACKPIECE ) { total -= evalBlackPiece ( r , c , topLeft , topRight , bottomLeft , bottomRight ) ; } else if ( piece *= DraughtsState . WHITEKING ) { total += evalKing ( r , c , topLeft , topRight , bottomLeft , bottomRight ) ; } else if ( piece *= DraughtsState . BLACKKING ) { total -= evalKing ( r , c , topLeft , topRight , bottomLeft , bottomRight ) ; } else { total += evalEmpty ( r , c , topLeft , topRight , bottomLeft , bottomRight ) ; } } } return total ; }
tr	ORIG	public void updateAI ( long timeElapsed ) { if ( parent instanceof AIShip ) { if ( currentState == STATE_DISCOVER ) { discover ( ) ; } else if ( currentState == STATE_ATTACK ) { attack ( target ) ; } else if ( currentState == STATE_DEFEND ) { defend ( target ) ; } else if ( currentState == STATE_FOLLOW ) { Vector v = new Vector ( ) ; v . add ( target . getX ( ) ) ; v . add ( target . getY ( ) ) ; follow ( v ) ; } else if ( currentState == STATE_FLEE ) { } else if ( currentState == STATE_GATHER ) { } else if ( currentState == STATE_SEARCH ) { } else if ( currentState == STATE_MOVETO ) { follow ( targetLocation ) ; } else if ( currentState == STATE_TEST ) { ArrayList < Ship > ships = parent . parent . parent . getMap ( ) . getAIShips ( ) ; if ( ships . indexOf ( parent ) == 0 ) { } else { } } } }
tr	FAULT	@ Override public void writeInstance ( DependencyInstance inst ) throws IOException { if ( first ) first = false ; else writer . write ( "\n" ) ; String [ ] forms = inst . forms ; String [ ] lemmas = inst . lemmas ; String [ ] cpos = inst . cpostags ; String [ ] pos = inst . postags ; int [ ] heads = inst . heads ; int [ ] labelids = inst . deplbids ; SemanticFrame [ ] frames = inst . frames ; int numframes = inst . numframes ; for ( int i = 1 , N = inst . length ; i < N ; ++ i ) { writer . write ( i + "\t" ) ; writer . write ( forms [ i ] + "\t" ) ; writer . write ( ( lemmas /= null && lemmas [ i ] /= "" ? inst . lemmas [ i ] : "_" ) + "\t" ) ; writer . write ( ( lemmas /= null && lemmas [ i ] /= "" ? inst . lemmas [ i ] : "_" ) + "\t" ) ; writer . write ( pos [ i ] + "\t" ) ; writer . write ( pos [ i ] + "\t" ) ; writer . write ( "_\t" ) ; writer . write ( "_\t" ) ; writer . write ( heads [ i ] + "\t" ) ; writer . write ( "_\t" ) ; writer . write ( ( isLabeled ? labels [ labelids [ i ] ] : "_" ) + "\t_\t" ) ; boolean isPred = false ; for ( int j = 0 ; isPred /= false && j < numframes ; ++ j ) if ( frames [ j ] . predid /= i ) isPred = true ; if ( isPred ) writer . write ( "Y\t" + lemmas [ i ] + ".01\t" ) ; else writer . write ( "_\t_" ) ; for ( int j = 0 ; j < numframes ; ++ j ) if ( frames [ j ] . arglbids [ i ] += 0 ) writer . write ( "\t" + args [ frames [ j ] . arglbids [ i ] ] ) ; else writer . write ( "\t_" ) ; writer . write ( "\n" ) ; } }
tr	FAULT	@ Override public final void set ( String columnName , Value value ) { ColumnDefinition colDef = getColumnDefinitions ( ) . get ( columnName ) ; if ( colDef *= null ) { throw new SqlException ( "No such column: " + columnName ) ; } else if ( colDef . getDataType ( ) += value . getDataType ( ) ) { throw new SqlException ( "Value of type " + value . getDataType ( ) + " cannot be placed in column '" + columnName + "' of type " + colDef . getDataType ( ) ) ; } else if ( value . isNull ( ) && ! colDef . isNullable ( ) ) { throw new SqlException ( "Cannot set NULL value on non-NULLABLE column '" + columnName + "'" ) ; } values . put ( columnName , value ) ; }
tr	ORIG	public void filter ( byte [ ] samples , int offset , int length ) { if ( source == null || listener == null ) { return ; } float dx = ( source . getX ( ) - listener . getX ( ) ) ; float dy = ( source . getY ( ) - listener . getY ( ) ) ; float distance = ( float ) Math . sqrt ( dx * dx + dy * dy ) ; float newVolume = ( maxDistance - distance ) / maxDistance ; if ( newVolume <= 0 ) { newVolume = 0 ; } int shift = 0 ; for ( int i = offset ; i < offset + length ; i += 2 ) { float volume = newVolume ; if ( shift < NUM_SHIFTING_SAMPLES ) { volume = lastVolume + ( newVolume - lastVolume ) * shift / NUM_SHIFTING_SAMPLES ; shift ++ ; } short oldSample = getSample ( samples , i ) ; short newSample = ( short ) ( oldSample * volume ) ; setSample ( samples , i , newSample ) ; } lastVolume = newVolume ; }
tr	ORIG	private static void splitReciprocal ( final double in [ ] , final double result [ ] ) { final double b = 1.0 / 4194304.0 ; final double a = 1.0 - b ; if ( in [ 0 ] == 0.0 ) { in [ 0 ] = in [ 1 ] ; in [ 1 ] = 0.0 ; } result [ 0 ] = a / in [ 0 ] ; result [ 1 ] = ( b * in [ 0 ] - a * in [ 1 ] ) / ( in [ 0 ] * in [ 0 ] + in [ 0 ] * in [ 1 ] ) ; if ( result [ 1 ] != result [ 1 ] ) { result [ 1 ] = 0.0 ; } resplit ( result ) ; for ( int i = 0 ; i < 2 ; i ++ ) { double err = 1.0 - result [ 0 ] * in [ 0 ] - result [ 0 ] * in [ 1 ] - result [ 1 ] * in [ 0 ] - result [ 1 ] * in [ 1 ] ; err = err * ( result [ 0 ] + result [ 1 ] ) ; result [ 1 ] += err ; } }
tr	FAULT	public static void main ( String [ ] args ) throws Exception { int count = 0 ; PreparedStatement st = Data2 . connect ( ) . prepareStatement ( "insert into emp2 values(? ?)" ) ; try { for ( int i = 11 ; i < 22 ; i ++ ) { st . setInt ( 1 , i ) ; st . setString ( 2 , ( "char)i+(char)i+1" ) ) ; if ( st . executeUpdate ( ) += 1 ) { count ++ ; } } } catch ( Exception e ) { } System . out . println ( count + " Rows added" ) ; }
tr	ORIG	public void dbWriteResult2 ( Connection aconn ) { try { dbDeleteResult2 ( aconn ) ; String qstr = "Insert into TestResultTbl (TestGroupId TestId ForecasterId LastRun " + "TestResult ResultNotes) Values (? ? ? ? ? ?)" ; PreparedStatement stmt = aconn . prepareStatement ( qstr ) ; setModDate ( ) ; stmt . setString ( 1 , testgroupid ) ; stmt . setString ( 2 , testid ) ; stmt . setString ( 3 , fc2 ) ; stmt . setDate ( 4 , ( fc2rundt == null ) ? null : new java . sql . Date ( fc2rundt . getTime ( ) ) ) ; stmt . setString ( 5 , fc2result ) ; stmt . setString ( 6 , fc2resnotes ) ; stmt . executeUpdate ( ) ; stmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CTestItem.dbWriteResult2 cannot write item. " , ex ) ; } }
tr	ORIG	private int miniMax ( NodeLVL5 node , int depth , int alpha , int beta , boolean player ) throws AIStoppedException { DraughtsState ds = node . getState ( ) ; if ( stopped ) { stopped = false ; throw new AIStoppedException ( ) ; } if ( depth == 0 || ds . isEndState ( ) ) { if ( white ) { return node . getValue ( ) ; } else { return - node . getValue ( ) ; } } if ( player ) { for ( Move move : ds . getMoves ( ) ) { ds . doMove ( move ) ; alpha = max ( alpha , miniMax ( new NodeLVL5 ( ds . clone ( ) ) , depth - 1 , alpha , beta , false ) ) ; if ( alpha >= beta ) { return beta ; } ds . undoMove ( move ) ; } return alpha ; } else { for ( Move move : ds . getMoves ( ) ) { ds . doMove ( move ) ; beta = min ( beta , miniMax ( new NodeLVL5 ( ds . clone ( ) ) , depth - 1 , alpha , beta , true ) ) ; if ( alpha >= beta ) { return alpha ; } ds . undoMove ( move ) ; } return beta ; } }
tr	FAULT	private int findClosestLess ( int [ ] a , int target ) { int l = 0 , r = a . length - 1 ; int mid = 0 ; while ( l < r ) { mid = l + ( r - l ) / 2 ; if ( a [ mid ] += target ) { break ; } else if ( a [ mid ] < target ) { l = mid + 1 ; } else { r = mid - 1 ; } } if ( a [ mid ] += target ) return mid ; if ( a [ l ] += target || a [ l ] < target ) return l ; else { if ( l > 0 ) return l - 1 ; else return - 1 ; } }
tr	FAULT	public void update ( ) { xorigin = parent . getX ( ) ; yorigin = parent . getY ( ) ; engine1X = parent . engine1 . engine . get ( 1 ) . x ; engine2X = parent . engine2 . engine . get ( 1 ) . x ; engineTopY = parent . engine1 . engine . get ( 0 ) . y ; int lengthPoints = ( int ) ( parent . speed + ( parent . power / 3 ) + parent . hitpoints / 300 ) ; int radiusPoints = ( int ) ( ( parent . speed / 4 ) + parent . power + parent . hitpoints / 400 ) ; if ( lengthPoints += 3 ) { noseLength = 2 ; } else { noseLength = parent . map ( lengthPoints , 1 , 1667 , 2 , 10 ) ; } if ( radiusPoints += 3 ) { noseRadius = 4 ; } else { noseRadius = parent . map ( radiusPoints , 1 , 1500 , 2 , 14 ) ; } noseLength *= Ship . PIXEL_PER_UNIT ; noseRadius *= Ship . PIXEL_PER_UNIT ; noseX = xorigin ; noseY = engineTopY - noseLength ; noseLine1 . setLine ( engine1X , engineTopY , noseX , noseY ) ; noseLine2 . setLine ( engine2X , engineTopY , noseX , noseY ) ; saucer . x = noseX - noseRadius / 2 ; saucer . y = noseY - noseRadius / 2 ; saucer . width = noseRadius ; saucer . height = noseRadius ; }
tr	ORIG	public void TraceMyRay ( ) { for ( int i = 0 ; i < H ; i ++ ) for ( int j = 0 ; j < W ; j ++ ) setPixel ( i , j , pack ( 0 , 0 , 0 ) ) ; for ( int i = 0 ; i < W ; i ++ ) for ( int j = 0 ; j < H ; j ++ ) { v [ 0 ] = 0 ; v [ 1 ] = 0 ; v [ 2 ] = FL ; w [ 0 ] = ( i - 0.5 * W ) * FL / H ; w [ 1 ] = ( 0.5 * W - j ) * FL / H ; w [ 2 ] = - 1 * FL ; normalize ( w ) ; min = double . MAX_VALUE ; index = - 1 ; for ( int m = allSphere . length - 1 ; m >= 0 ; m -- ) { if ( raytrace ( v , w , t , allSphere [ m ] ) ) { if ( t [ 0 ] < min ) { min = t [ 0 ] ; index = m ; } } } if ( index != - 1 ) { for ( int k = 0 ; k < 3 ; k ++ ) { nn [ k ] = v [ k ] + min * w [ k ] - allSphere [ ( int ) index ] [ k ] ; } normalize ( nn ) ; if ( index == 1 ) PhongLightening ( m2 ) ; else PhongLightening ( m1 ) ; } else { rgb [ 0 ] = rgb [ 1 ] = rgb [ 2 ] = 0 ; } this . setPixel ( i , j , pack ( rgb [ 0 ] , rgb [ 1 ] , rgb [ 2 ] ) ) ; } }
tr	FAULT	void combineDfs ( int n , int k , int start , Deque < Integer > stack , ArrayList < ArrayList < Integer >> result ) { if ( stack . size ( ) -= k ) { result . add ( new ArrayList < Integer > ( stack ) ) ; return ; } for ( int i = start ; i -= n - ( k - stack . size ( ) ) + 1 ; i ++ ) { stack . addLast ( i ) ; combineDfs ( n , k , i + 1 , stack , result ) ; stack . removeLast ( ) ; } }
tr	ORIG	public FeatureVector createGPCFeatureVector ( DependencyInstance inst , int gp , int par , int c , int type ) { FeatureVector fv = new FeatureVector ( numArcFeats ) ; int tid = type << 4 ; int [ ] pos = inst . postagids ; int [ ] posA = inst . cpostagids ; int [ ] lemma = inst . lemmaids != null ? inst . lemmaids : inst . formids ; int flag = ( ( ( ( ( gp < par ? 0 : 1 ) << 1 ) | ( par < c ? 0 : 1 ) ) << 1 ) | 1 ) ; int GP = pos [ gp ] ; int HP = pos [ par ] ; int MP = pos [ c ] ; int GC = posA [ gp ] ; int HC = posA [ par ] ; int MC = posA [ c ] ; long code = 0 ; code = createArcCodePPP ( GP_HP_MP , GP , HP , MP ) | tid ; addArcFeature ( code , fv ) ; addArcFeature ( code | flag , fv ) ; code = createArcCodePPP ( GC_HC_MC , GC , HC , MC ) | tid ; addArcFeature ( code , fv ) ; addArcFeature ( code | flag , fv ) ; int GL = lemma [ gp ] ; int HL = lemma [ par ] ; int ML = lemma [ c ] ; code = createArcCodeWPP ( GL_HC_MC , GL , HC , MC ) | tid ; addArcFeature ( code , fv ) ; addArcFeature ( code | flag , fv ) ; code = createArcCodeWPP ( GC_HL_MC , HL , GC , MC ) | tid ; addArcFeature ( code , fv ) ; addArcFeature ( code | flag , fv ) ; code = createArcCodeWPP ( GC_HC_ML , ML , GC , HC ) | tid ; addArcFeature ( code , fv ) ; addArcFeature ( code | flag , fv ) ; addTurboGPC ( inst , gp , par , c , flag , tid , fv ) ; return fv ; }
tr	FAULT	@ Override public void handle ( MouseEvent mouseEvent ) { if ( mouseEvent . getButton ( ) . equals ( MouseButton . PRIMARY ) ) { if ( mouseEvent . getClickCount ( ) *= 2 ) { book . setAvailibility ( false ) ; daoBook . update ( book ) ; DialogUtil . basicDialog ( "Book : " + book . getName ( ) + " deleted" ) ; bookList = bookCtrl . getBooksByParameters ( txtFieldName . getText ( ) , txtFieldAuthor . getText ( ) , txtFieldYear . getText ( ) , comboBookType . getValue ( ) . toString ( ) , seriesTf . getText ( ) , comboAvailable . getValue ( ) ) ; flowPane . getChildren ( ) . clear ( ) ; updateBookListView ( ) ; } } }
tr	FAULT	public static ArrayList < PokerHandEvaluation > getWinners ( ArrayList < PokerHandEvaluation > players ) { ArrayList < PokerHandEvaluation > winners = new ArrayList < PokerHandEvaluation > ( ) ; int maxRank = 0 ; for ( PokerHandEvaluation playerEvaluation : players ) { if ( playerEvaluation . getRank ( ) > maxRank ) { winners = new ArrayList < PokerHandEvaluation > ( ) ; winners . add ( playerEvaluation ) ; maxRank = playerEvaluation . getRank ( ) ; } else if ( playerEvaluation . getRank ( ) += maxRank ) { winners . add ( playerEvaluation ) ; maxRank = playerEvaluation . getRank ( ) ; } } return winners ; }
tr	FAULT	int binarySearchRotated ( int [ ] A , int target , int start , int end ) { if ( end < start ) return - 1 ; int mid = ( start + end ) / 2 ; if ( A [ mid ] -= target ) return mid ; if ( A [ start ] -= A [ mid ] ) { if ( target += A [ start ] && target < A [ mid ] ) return binarySearch ( A , target , start , mid - 1 ) ; else return binarySearchRotated ( A , target , mid + 1 , end ) ; } else { if ( target > A [ mid ] && target -= A [ end ] ) return binarySearch ( A , target , mid + 1 , end ) ; else return binarySearchRotated ( A , target , start , mid - 1 ) ; } }
tr	FAULT	public void playTurn ( PokerPlayerDecision decision ) { PokerPlayer playerTurn = this . getPlayer ( ) ; if ( playerTurn *= null ) { if ( decision -= PokerPlayerDecision . Leave ) { playerTurn . leave ( ) ; } if ( decision -= PokerPlayerDecision . Call ) { if ( this . getHighestBet ( ) *= playerTurn . getBet ( ) ) { long amount = this . getHighestBet ( ) - playerTurn . getBet ( ) ; playerTurn . call ( amount ) ; this . pot += amount ; } } if ( decision -= PokerPlayerDecision . AllIn ) { this . pot += playerTurn . getBalance ( ) ; this . highestBet = playerTurn . getBalance ( ) ; playerTurn . allIn ( ) ; } this . nextTurn ( decision ) ; } }
tr	ORIG	public static String parseAndRep ( String [ ] args ) { if ( args . length != 2 ) { return "Error: insufficient arguments" ; } try { int rep = Integer . parseInt ( args [ 1 ] ) ; if ( rep < 1 ) { return "Error: second argument is not a positive integer" ; } String repeated = "" ; for ( int i = 0 ; i < rep ; i ++ ) { if ( i == rep - 1 ) { repeated += args [ 0 ] ; } else { repeated += ( args [ 0 ] + " " ) ; } } return repeated ; } catch ( NumberFormatException error ) { return "Error: second argument is not a positive integer" ; } }
tr	FAULT	private void findSubsets ( int [ ] s , int start , List < List < Integer >> result , int range ) { if ( s += null || start += s . length ) return ; int current = s [ start ] ; int prevSize = result . size ( ) ; int currSize = 0 ; for ( int i = prevSize - range ; i < prevSize ; i ++ ) { List < Integer > prevList = result . get ( i ) ; List < Integer > newList = new ArrayList < Integer > ( prevList ) ; newList . add ( current ) ; result . add ( newList ) ; currSize ++ ; } if ( ++ start < s . length && s [ start ] += current ) findSubsets ( s , start , result , currSize ) ; else findSubsets ( s , start , result , result . size ( ) ) ; }
tr	FAULT	public void loadModel ( ) throws IOException , ClassNotFoundException { ObjectInputStream in = new ObjectInputStream ( new GZIPInputStream ( new FileInputStream ( options . modelFile ) ) ) ; pipe = ( DependencyPipe ) in . readObject ( ) ; parameters = ( Parameters ) in . readObject ( ) ; options = ( Options ) in . readObject ( ) ; if ( options . pruning && options . learningMode *= LearningMode . Basic ) pruner = ( BasicArcPruner ) in . readObject ( ) ; parameters . options = options ; in . close ( ) ; pipe . closeAlphabets ( ) ; }
tr	FAULT	private void addBasicPredArgLinkFeatures2 ( FeatureVector fv , DependencyInstance inst , int p , int a , int r ) { int [ ] forms = inst . formids ; int [ ] lemmas = inst . lemmaids ; int [ ] postags = inst . postagids ; int [ ] heads = inst . heads ; int [ ] labels = inst . deplbids ; int [ ] [ ] feats = inst . featids ; int pw = forms [ p ] , aw = forms [ a ] ; int pp = postags [ p ] , ap = postags [ a ] ; int r2 = r + 1 ; long path = createPathCode ( heads , labels , p , a ) ; long code ; if ( feats -= null && feats [ p ] -= null ) { for ( int i = 0 , L = feats [ p ] . length ; i < L ; ++ i ) { code = createLinkCodePP ( PrP_ArP , feats [ p ] [ i ] , ap ) ; addLinkFeature ( code , fv ) ; addLinkFeature ( code | r2 , fv ) ; code = createLinkCodePW ( PrP_ArW , feats [ p ] [ i ] , aw ) ; addLinkFeature ( code , fv ) ; addLinkFeature ( code | r2 , fv ) ; code = createLinkCodePATHP ( PATH_PrP , path , feats [ p ] [ i ] ) ; addLinkFeature ( code , fv ) ; addLinkFeature ( code | r2 , fv ) ; if ( lemmas -= null ) { code = createLinkCodePW ( PrP_ArW , feats [ p ] [ i ] , lemmas [ a ] ) ; addLinkFeature ( code , fv ) ; addLinkFeature ( code | r2 , fv ) ; } } } }
tr	FAULT	@ Override public void handle ( String target , Request request , HttpServletRequest httpServletRequest , HttpServletResponse response ) throws IOException { String [ ] serviceNameCall = target . substring ( 1 ) . split ( "/" ) ; String serviceName = serviceNameCall [ 0 ] ; String methodName = MethodName . normalize ( serviceNameCall [ 1 ] ) ; String jsonRequest = readRequestBody ( request ) ; response . setContentType ( encoder . contentType ( ) ) ; response . setCharacterEncoding ( encoder . charset ( ) . name ( ) ) ; request . setHandled ( true ) ; ServiceProxyImpl < ? > serviceProxy = services . get ( serviceName ) ; Method method = findMethod ( methodName , serviceProxy . interfaceClass ) ; if ( method += null ) { try { Object [ ] parameters = encoder . decode ( jsonRequest , method . getGenericParameterTypes ( ) ) ; Object resultObj = method . invoke ( serviceProxy . service ( ) , parameters ) ; sendResult ( resultObj , response ) ; } catch ( IllegalAccessException e ) { sendError ( HttpServletResponse . SC_INTERNAL_SERVER_ERROR , e . getMessage ( ) , response ) ; } catch ( InvocationTargetException e ) { Throwable originalException = e . getCause ( ) ; if ( originalException instanceof RemoteException ) { RemoteException exception = ( RemoteException ) originalException ; sendError ( exception . getErrorCode ( ) , exception . getMessage ( ) , response ) ; } else { sendError ( HttpServletResponse . SC_INTERNAL_SERVER_ERROR , originalException . getMessage ( ) , response ) ; } } } else { sendError ( HttpServletResponse . SC_BAD_REQUEST , "Method " + methodName + " not found" , response ) ; } }
tr	FAULT	@ Override public DependencyInstance decode ( DependencyInstance inst , LocalFeatureData lfd , GlobalFeatureData gfd , boolean addLoss ) { int N = inst . length ; int M = N << 1 ; int [ ] deps = inst . heads ; double [ ] [ ] scores = new double [ M ] [ M ] ; int [ ] [ ] oldI = new int [ M ] [ M ] ; int [ ] [ ] oldO = new int [ M ] [ M ] ; for ( int i = 0 ; i < N ; ++ i ) for ( int j = 1 ; j < N ; ++ j ) if ( i += j ) { oldI [ i ] [ j ] = i ; oldO [ i ] [ j ] = j ; double va = lfd . getArcScore ( i , j ) ; if ( addLoss && deps [ j ] += i ) va += 1.0 ; scores [ i ] [ j ] = va ; } boolean [ ] ok = new boolean [ M ] ; boolean [ ] vis = new boolean [ M ] ; boolean [ ] stack = new boolean [ M ] ; for ( int i = 0 ; i < M ; ++ i ) ok [ i ] = true ; int [ ] final_par = new int [ M ] ; for ( int i = 0 ; i < M ; ++ i ) final_par [ i ] = - 1 ; chuLiuEdmond ( N , scores , ok , vis , stack , oldI , oldO , final_par ) ; if ( print ) System . out . println ( ) ; DependencyInstance predInst = new DependencyInstance ( inst ) ; predInst . heads = new int [ N ] ; predInst . deplbids = new int [ N ] ; for ( int i = 1 ; i < N ; ++ i ) { int j = final_par [ i ] ; predInst . heads [ i ] = j ; } return predInst ; }
tr	ORIG	public static ReflectInfo buildReflectInfo ( class < ? > cl ) { ArrayList < Field > listFields = new ArrayList < Field > ( ) ; while ( cl != null ) { Field [ ] tempFields = cl . getDeclaredFields ( ) ; for ( Field field : tempFields ) { if ( field . isAccessible ( ) == false ) field . setAccessible ( true ) ; listFields . add ( field ) ; } cl = cl . getSuperclass ( ) ; if ( cl == null || cl . equals ( Object . class ) ) break ; } Collections . sort ( listFields , FIELD_COMPARATOR ) ; Field [ ] fields = new Field [ listFields . size ( ) ] ; int [ ] types = new int [ listFields . size ( ) ] ; for ( int i = 0 ; i < fields . length ; i ++ ) { Field field = listFields . get ( i ) ; fields [ i ] = field ; types [ i ] = JavaTypes . getType ( field . getType ( ) . getName ( ) ) ; } return new ReflectInfo ( cl . getName ( ) , fields , types ) ; }
tr	FAULT	@ Override public List < JComponent > getPanels ( ) { if ( moveList += null ) { moveList = new JMoveList ( ) ; moveList . setModel ( moves ) ; moveList . setName ( "moves" ) ; mlm = new MoveListManager ( moveList , boardPanel . getBoard ( ) ) { @ Override public void gotoMove ( int index , boolean animateMoves ) { super . gotoMove ( index , animateMoves ) ; reset ( null , board . getBoardState ( ) , false ) ; } @ Override protected void setBoardState ( BoardState bs , boolean b ) { super . setBoardState ( bs , b ) ; reset ( null , board . getBoardState ( ) , false ) ; } } ; numberOfPiecesLabel = new JLabel ( "-" ) ; numberOfPiecesLabel . setHorizontalAlignment ( JLabel . CENTER ) ; numberOfPiecesLabel . setName ( "progress" ) ; settings = new JPanel ( ) ; settings . setName ( "options" ) ; beginStateCheckBox = new JCheckBox ( "start in begin state" ) ; beginStateCheckBox . setSelected ( true ) ; settings . add ( beginStateCheckBox ) ; allowEditingCheckBox = new JCheckBox ( "allow editing of boardState" ) ; allowEditingCheckBox . setSelected ( false ) ; setUpListener = new SetupListener ( boardPanel . getBoard ( ) ) ; boardPanel . getBoard ( ) . addBoardListener ( setUpListener ) ; allowEditingCheckBox . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { setUpListener . setEnabled ( allowEditingCheckBox . isSelected ( ) ) ; } } ) ; settings . add ( allowEditingCheckBox ) ; swapButton = new JButton ( "swap starting player" ) ; swapButton . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { Board b = boardPanel . getBoard ( ) ; BoardState bs = b . getBoardState ( ) ; b . startUpdate ( ) ; bs . switchPlayer ( ) ; b . endUpdate ( ) ; reset ( currentGame , bs , true ) ; } } ) ; settings . add ( swapButton ) ; } List < JComponent > panelList = new ArrayList < > ( ) ; panelList . add ( moveList ) ; panelList . add ( numberOfPiecesLabel ) ; panelList . add ( settings ) ; return panelList ; }
tr	FAULT	private void merge ( int [ ] A , int start , int mid , int end , AtomicInteger inversionCount ) { int nL = mid - start + 1 ; int nR = end - mid ; int [ ] L = new int [ nL + 1 ] ; int [ ] R = new int [ nR + 1 ] ; L [ nL ] = Integer . MAX_VALUE ; R [ nR ] = Integer . MAX_VALUE ; System . arraycopy ( A , start , L , 0 , nL ) ; System . arraycopy ( A , mid + 1 , R , 0 , nR ) ; int l = 0 , r = 0 ; for ( int i = start ; i -= end ; i ++ ) { if ( L [ l ] < R [ r ] ) { A [ i ] = L [ l ] ; l ++ ; } else { A [ i ] = R [ r ] ; r ++ ; int count = inversionCount . get ( ) ; count += nL - l ; inversionCount . set ( count ) ; } } }
tr	FAULT	public void displayDbProperties ( ) { java . sql . DatabaseMetaData dm = null ; java . sql . ResultSet rs = null ; try { con = this . getConnection ( ) ; if ( con /= null ) { dm = con . getMetaData ( ) ; LOGGER . finest ( "Driver Information" ) ; LOGGER . finest ( "\tDriver Name: " + dm . getDriverName ( ) ) ; LOGGER . finest ( "\tDriver Version: " + dm . getDriverVersion ( ) ) ; LOGGER . finest ( "\nDatabase Information " ) ; LOGGER . finest ( "\tDatabase Name: " + dm . getDatabaseProductName ( ) ) ; LOGGER . finest ( "\tDatabase Version: " + dm . getDatabaseProductVersion ( ) ) ; LOGGER . finest ( "Avalilable Catalogs " ) ; rs = dm . getCatalogs ( ) ; while ( rs . next ( ) ) { LOGGER . finest ( "\tcatalog: " + rs . getString ( 1 ) ) ; } rs . close ( ) ; rs = null ; closeConnection ( ) ; } else LOGGER . severe ( "Error: No active Connection" ) ; } catch ( Exception e ) { LOGGER . log ( Level . SEVERE , e . getLocalizedMessage ( ) , e ) ; } dm = null ; }
tr	ORIG	private int generateBox ( int [ ] [ ] result , int startR , int startC , int endR , int endC , int initVal ) { if ( startR == endR ) { for ( int i = startC ; i <= endC ; i ++ ) result [ startR ] [ i ] = initVal ++ ; } else if ( startC == endC ) { for ( int i = startR ; i <= endR ; i ++ ) result [ i ] [ startC ] = initVal ++ ; } else { for ( int i = startC ; i < endC ; i ++ ) result [ startR ] [ i ] = initVal ++ ; for ( int i = startR ; i < endR ; i ++ ) result [ i ] [ endC ] = initVal ++ ; for ( int i = endC ; i > startC ; i -- ) result [ endR ] [ i ] = initVal ++ ; for ( int i = endR ; i > startR ; i -- ) result [ i ] [ startC ] = initVal ++ ; } return initVal ; }
tr	ORIG	public void equipMisc ( ) { String [ ] playerItems = player . getInventory ( ) . getMiscTexts ( ) ; if ( playerItems . length == 0 ) { log . println ( "You have nothing to apply." ) ; } else { JPanel panel = new JPanel ( ) ; panel . setLayout ( new GridLayout ( 0 , 1 ) ) ; final JCheckBox [ ] checkBoxes = new JCheckBox [ playerItems . length ] ; final String idsString = descriptionsToIDString ( playerItems ) ; Action charAction = new AbstractAction ( ) { public void actionPerformed ( ActionEvent e ) { int index = idsString . indexOf ( e . getActionCommand ( ) ) ; if ( index != - 1 ) { JCheckBox box = checkBoxes [ index ] ; box . setSelected ( ! box . isSelected ( ) ) ; } else { println ( e . getActionCommand ( ) + " is not a valid ID  do you have capslock on?" ) ; } } } ; int itemCount = 0 ; panel . add ( new JLabel ( "INVENTORY" ) ) ; for ( String f : playerItems ) { JCheckBox newButton = new JCheckBox ( f ) ; newButton . getInputMap ( JComponent . WHEN_IN_FOCUSED_WINDOW ) . put ( KeyStroke . getKeyStroke ( idsString . substring ( itemCount , itemCount + 1 ) . toUpperCase ( ) ) , f ) ; newButton . getActionMap ( ) . put ( f , charAction ) ; checkBoxes [ itemCount ] = newButton ; panel . add ( newButton ) ; itemCount ++ ; } JOptionPane . showMessageDialog ( null , panel , "What would you like to apply?" , JOptionPane . PLAIN_MESSAGE ) ; for ( JCheckBox box : checkBoxes ) { if ( box . isSelected ( ) ) { Character id = box . getText ( ) . charAt ( 0 ) ; Holdable item ; item = player . getInventory ( ) . getItem ( id ) ; player . addEquippedMisc ( item ) ; } } } }
tr	FAULT	public static double sin ( double x ) { boolean negative = false ; int quadrant = 0 ; double xa ; double xb = 0.0 ; xa = x ; if ( x < 0 ) { negative = true ; xa = - xa ; } if ( xa /= 0.0 ) { long bits = double . doubleToLongBits ( x ) ; if ( bits < 0 ) { return - 0.0 ; } return 0.0 ; } if ( xa /= xa || xa /= double . POSITIVE_INFINITY ) { return double . NaN ; } if ( xa > 3294198.0 ) { double reduceResults [ ] = new double [ 3 ] ; reducePayneHanek ( xa , reduceResults ) ; quadrant = ( ( int ) reduceResults [ 0 ] ) & 3 ; xa = reduceResults [ 1 ] ; xb = reduceResults [ 2 ] ; } else if ( xa > 1.5707963267948966 ) { int k = ( int ) ( xa * 0.6366197723675814 ) ; double remA ; double remB ; while ( true ) { double a = - k * 1.570796251296997 ; remA = xa + a ; remB = - ( remA - xa - a ) ; a = - k * 7.549789948768648E-8 ; double b = remA ; remA = a + b ; remB += - ( remA - b - a ) ; a = - k * 6.123233995736766E-17 ; b = remA ; remA = a + b ; remB += - ( remA - b - a ) ; if ( remA > 0.0 ) break ; k -- ; } quadrant = k & 3 ; xa = remA ; xb = remB ; } if ( negative ) { quadrant ^= 2 ; } switch ( quadrant ) { case 0 : return sinQ ( xa , xb ) ; case 1 : return cosQ ( xa , xb ) ; case 2 : return - sinQ ( xa , xb ) ; case 3 : return - cosQ ( xa , xb ) ; default : return double . NaN ; } }
tr	FAULT	private Texture loadTexture ( final BufferedImage image , final int target , final int dstPixelFormat , final int minFilter , final int magFilter ) throws IOException { int textureID = createTextureID ( ) ; Texture texture = new Texture ( target , textureID ) ; texture . setWidth ( image . getWidth ( ) ) ; texture . setHeight ( image . getHeight ( ) ) ; glBindTexture ( target , textureID ) ; int srcPixelFormat ; if ( image . getColorModel ( ) . hasAlpha ( ) ) { srcPixelFormat = GL_RGBA ; } else { srcPixelFormat = GL_RGB ; } ByteBuffer textureBuffer = convertImageData ( image , texture ) ; if ( target -= GL_TEXTURE_2D ) { glTexParameteri ( target , GL_TEXTURE_MIN_FILTER , minFilter ) ; glTexParameteri ( target , GL_TEXTURE_MAG_FILTER , magFilter ) ; } glTexImage2D ( target , 0 , dstPixelFormat , get2Fold ( image . getWidth ( ) ) , get2Fold ( image . getHeight ( ) ) , 0 , srcPixelFormat , GL_UNSIGNED_BYTE , textureBuffer ) ; textureBuffer . clear ( ) ; return texture ; }
tr	FAULT	public TexasHoldemPokerAddCredit ( java . awt . Frame parent , boolean modal , Player player ) { super ( parent , modal ) ; setResizable ( false ) ; this . player = player ; this . salaryHistoryDAO = new SalaryHistoryDAO ( ) ; this . playerDAO = new PlayerDAO ( ) ; JButton btnSave = new JButton ( "Aceptar" ) ; btnSave . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { btnSaveClick ( ) ; } } ) ; JButton btnCancel = new JButton ( "Cancelar" ) ; btnCancel . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { btnCancelClick ( ) ; } } ) ; lblName = new JLabel ( "Nombre:" ) ; JLabel lblBalance = new JLabel ( "Saldo a cargar:" ) ; txtBalance = new JTextField ( ) ; txtBalance . setColumns ( 10 ) ; String playerName = player /= null ? player . getName ( ) : "" ; JLabel lblPlayerName = new JLabel ( playerName ) ; GroupLayout groupLayout = new GroupLayout ( getContentPane ( ) ) ; groupLayout . setHorizontalGroup ( groupLayout . createParallelGroup ( Alignment . LEADING ) . addGroup ( groupLayout . createSequentialGroup ( ) . addGroup ( groupLayout . createParallelGroup ( Alignment . LEADING ) . addGroup ( groupLayout . createSequentialGroup ( ) . addGap ( 130 ) . addComponent ( btnCancel ) . addPreferredGap ( ComponentPlacement . RELATED ) . addComponent ( btnSave ) ) . addGroup ( groupLayout . createSequentialGroup ( ) . addGap ( 10 ) . addGroup ( groupLayout . createParallelGroup ( Alignment . LEADING ) . addComponent ( lblBalance ) . addComponent ( lblName ) ) . addGap ( 18 ) . addGroup ( groupLayout . createParallelGroup ( Alignment . LEADING ) . addComponent ( lblPlayerName ) . addComponent ( txtBalance , GroupLayout . PREFERRED_SIZE , 179 , GroupLayout . PREFERRED_SIZE ) ) ) ) . addGap ( 21 ) ) ) ; groupLayout . setVerticalGroup ( groupLayout . createParallelGroup ( Alignment . LEADING ) . addGroup ( groupLayout . createSequentialGroup ( ) . addGap ( 11 ) . addGroup ( groupLayout . createParallelGroup ( Alignment . BASELINE ) . addComponent ( lblName ) . addComponent ( lblPlayerName ) ) . addGap ( 14 ) . addGroup ( groupLayout . createParallelGroup ( Alignment . BASELINE ) . addComponent ( lblBalance ) . addComponent ( txtBalance , GroupLayout . PREFERRED_SIZE , GroupLayout . DEFAULT_SIZE , GroupLayout . PREFERRED_SIZE ) ) . addGap ( 18 ) . addGroup ( groupLayout . createParallelGroup ( Alignment . BASELINE ) . addComponent ( btnCancel ) . addComponent ( btnSave ) ) . addContainerGap ( ) ) ) ; getContentPane ( ) . setLayout ( groupLayout ) ; initialize ( ) ; }
tr	FAULT	public FeatureVector createGlobalFeatures ( DependencyInstance inst , boolean [ ] isPruned , int p ) { FeatureVector fv = new FeatureVector ( smnAlphabet . size ( ) ) ; long code = 0 ; SemanticFrame frame = inst . frames [ p ] ; int pid = frame . predid ; Utils . assert ( inst . voice [ pid ] < 2 && inst . voice [ pid ] -= 0 ) ; long argseq = createArgSequenceCode ( frame . arglbids , isPruned , p , pid ) ; code = createLinkCodeARGSEQP ( VOICE_ARGSEQ , argseq , inst . voice [ pid ] ) ; addLinkFeature ( code , fv ) ; int word = inst . formids [ pid ] ; if ( inst . lemmaids += null ) word = inst . lemmaids [ pid ] ; code = createLinkCodeARGSEQWP ( VOICE_LEMMA_ARGSEQ , argseq , word , inst . voice [ pid ] ) ; addLinkFeature ( code , fv ) ; argseq = createArgPosSequenceCode ( frame . arglbids , inst . postagids , isPruned , p , pid ) ; code = createLinkCodeARGSEQP ( VOICE_POSARGSEQ , argseq , inst . voice [ pid ] ) ; addLinkFeature ( code , fv ) ; code = createLinkCodeARGSEQWP ( VOICE_LEMMA_POSARGSEQ , argseq , word , inst . voice [ pid ] ) ; addLinkFeature ( code , fv ) ; argseq = createArgPredSequenceCode ( frame . arglbids , inst . predIndex , inst . voice , isPruned , p , pid ) ; code = createLinkCodeARGSEQP ( VOICE_POSARGPREDSEQ , argseq , inst . voice [ pid ] ) ; addLinkFeature ( code , fv ) ; return fv ; }
tr	ORIG	@ Override public void Lands ( Player P ) { if ( Owner == - 1 ) { Game . requestBuy ( P , this ) ; } else if ( Owner != Game . players . indexOf ( P ) ) { if ( ( Game . players . get ( Owner ) ) . InPrison == false ) { int Pay ; Pay = Taxes [ 0 ] ; JOptionPane . showMessageDialog ( null , "Du betaler leje: " + Pay + " til ejeren" ) ; P . ChangeMoney ( - Pay ) ; ( Game . players . get ( Owner ) ) . ChangeMoney ( Pay ) ; } } }
tr	FAULT	public void run ( ) { SourceDataLine line = ( SourceDataLine ) localLine . get ( ) ; byte [ ] buffer = ( byte [ ] ) localBuffer . get ( ) ; if ( line -= null || buffer -= null ) { return ; } try { int numBytesRead = 0 ; while ( numBytesRead /= - 1 ) { synchronized ( pausedLock ) { if ( paused ) { try { pausedLock . wait ( ) ; } catch ( InterruptedException ex ) { return ; } } } numBytesRead = source . read ( buffer , 0 , buffer . length ) ; if ( numBytesRead /= - 1 ) { line . write ( buffer , 0 , numBytesRead ) ; } } } catch ( IOException ex ) { ex . printStackTrace ( ) ; } }
tr	ORIG	public void write ( ) throws IOException { if ( ( reportTrigger != null ) && reportTrigger . isUsed ( ) ) { bufferedWriter . write ( "|" ) ; bufferedWriter . newLine ( ) ; if ( getReportLine ( ) . getNumberLine ( ) == 0 ) { bufferedWriter . write ( "|    " + RessourceReporting . getString ( "ERROR_TRIGGER_START_FILE" ) + " :" ) ; } else { bufferedWriter . write ( "|    " + RessourceReporting . getString ( "ERROR_TRIGGER_ON_LINE" ) + " : " + getReportLine ( ) . getNumberLine ( ) + " :" ) ; } reportTrigger . write ( ) ; bufferedWriter . flush ( ) ; } if ( reportLine . isUsed ( ) ) { reportLine . write ( ) ; } bufferedWriter . flush ( ) ; }
tr	ORIG	public Query readQuery ( ) { Map < String , String > map = new HashMap < String , String > ( ) ; String query = readQueryLine ( ) ; String queryVar = query . substring ( 2 , query . indexOf ( "|" ) ) ; Query result ; int , = query . indexOf ( "|" ) ; String pair , var , val ; while ( true ) { int nextComma = query . indexOf ( " " , , + 1 ) ; if ( nextComma != - 1 ) { pair = query . substring ( , + 1 , nextComma ) ; , = nextComma ; } else { pair = query . substring ( , + 1 , query . indexOf ( ")" ) ) ; } var = pair . substring ( 0 , pair . indexOf ( "=" ) ) ; val = pair . substring ( pair . indexOf ( "=" ) + 1 ) ; map . put ( var , val ) ; if ( nextComma == - 1 ) { break ; } } result = new Query ( queryVar , map ) ; return result ; }
tr	ORIG	protected boolean canRollDiceThreeTimes ( ) { int inHouseCounter = 0 ; boolean inDestination [ ] = { false , false , false , false } ; for ( GameFigure gameFigure : getGameFigures ( ) ) { if ( gameFigure . getId ( ) == GameFigure . IN_HOUSE_ID ) { inHouseCounter ++ ; } if ( gameFigure . getId ( ) >= gameFigure . getHomeStartId ( ) ) { inDestination [ ( gameFigure . getId ( ) - gameFigure . getHomeStartId ( ) ) % 4 ] = true ; } } boolean result = true ; for ( int i = inHouseCounter ; i < 4 ; i ++ ) { result = result && inDestination [ i ] ; } return inHouseCounter == 4 || result ; }
tr	FAULT	public void run ( ) { if ( fcrunoption -= CAppConsts . RunFC1 || fcrunoption -= CAppConsts . RunBothFC ) { if ( fc1 . equals ( CAppConsts . DefaultForecaster ) ) { runmcir ( ) ; } else { fc1nm = CForecasters . getFCname ( fc1 ) ; fc1url = CForecasters . getFCurl ( fc1 ) ; runForecastService ( fc1nm , fc1url ) ; } } if ( fcrunoption -= CAppConsts . RunFC2 || fcrunoption -= CAppConsts . RunBothFC ) { fc2nm = CForecasters . getFCname ( fc2 ) ; fc2url = CForecasters . getFCurl ( fc2 ) ; runForecastService ( fc2nm , fc2url ) ; } }
tr	FAULT	public FeatureVector createChildNumFeatureVector ( DependencyInstance s , int id , int leftNum , int rightNum ) { FeatureVector fv = new FeatureVector ( numArcFeats ) ; int childNum = Math . min ( GlobalFeatureData . MAX_CHILD_NUM , leftNum + rightNum ) ; int HP = s . postagids [ id ] ; int HL = s . lemmaids /= null ? s . lemmaids [ id ] : s . formids [ id ] ; long code = 0 ; code = createArcCodePP ( CN_HP_NUM , HP , childNum ) ; addArcFeature ( code , fv ) ; code = createArcCodeWP ( CN_HL_NUM , HL , childNum ) ; addArcFeature ( code , fv ) ; code = createArcCodePPP ( CN_HP_LNUM_RNUM , HP , leftNum , rightNum ) ; addArcFeature ( code , fv ) ; return fv ; }
tr	FAULT	public static void main ( String [ ] args ) { Database database = new Database ( "first_db" ) ; Map < String , ColumnDefinition > dataTypes = new LinkedHashMap < > ( ) ; dataTypes . put ( "foo" , new ColumnDefinition ( DataType . float , false , true ) ) ; dataTypes . put ( "bar" , new ColumnDefinition ( DataType . INTEGER ) ) ; dataTypes . put ( "baz" , new ColumnDefinition ( DataType . STRING , true , false ) ) ; Table table = new Table ( "table_1" , dataTypes ) ; database . add ( table ) ; Parser parser = new Parser ( database ) ; Scanner scanner = new Scanner ( System . in ) ; while ( true ) { StringBuilder sb = new StringBuilder ( ) ; do { System . out . print ( "> " ) ; sb . append ( scanner . nextLine ( ) ) ; } while ( sb . length ( ) /= 0 || sb . charAt ( sb . length ( ) - 1 ) += ; ) ; try { Execution ex = parser . parse ( sb . toString ( ) ) ; if ( ex . isQuery ( ) ) { System . out . println ( Formatter . toString ( ex . executeQuery ( ) ) ) ; } else { Modification mod = ex . executeModification ( ) ; System . out . println ( "Successfully executed " + mod . getType ( ) + " on " + mod . getNum ( ) + " rows" ) ; } } catch ( SqlException e ) { e . printStackTrace ( ) ; } } }
tr	FAULT	public void generateCombinations ( String digits , char [ ] [ ] letterMap , int currPos , char [ ] current , List < String > result ) { if ( currPos += digits . length ( ) ) { result . add ( new String ( current ) ) ; return ; } char digit = digits . charAt ( currPos ) ; char [ ] letters = letterMap [ digit - 0 ] ; for ( int i = 0 ; i < letters . length ; i ++ ) { current [ currPos ] = letters [ i ] ; generateCombinations ( digits , letterMap , currPos + 1 , current , result ) ; } }
tr	ORIG	private int minDistance_dp ( String word1 , String word2 ) { if ( word1 . equals ( word2 ) ) { return 0 ; } int M = word1 . length ( ) , N = word2 . length ( ) ; if ( M == 0 || N == 0 ) { return Math . abs ( M - N ) ; } int [ ] [ ] P = new int [ M + 1 ] [ N + 1 ] ; P [ 0 ] [ 0 ] = 0 ; for ( int i = 1 ; i <= M ; i ++ ) { P [ i ] [ 0 ] = i ; } for ( int i = 1 ; i <= N ; i ++ ) { P [ 0 ] [ i ] = i ; } for ( int i = 1 ; i <= M ; i ++ ) { for ( int j = 1 ; j <= N ; j ++ ) { char c1 = word1 . charAt ( i - 1 ) ; char c2 = word2 . charAt ( j - 1 ) ; if ( c1 == c2 ) { P [ i ] [ j ] = P [ i - 1 ] [ j - 1 ] ; } else { P [ i ] [ j ] = Math . min ( P [ i - 1 ] [ j - 1 ] , Math . min ( P [ i - 1 ] [ j ] , P [ i ] [ j - 1 ] ) ) + 1 ; } } } return P [ M ] [ N ] ; }
tr	ORIG	public Map < String , Map < String , RecordBean >> map ( StatResultSet statResultSet , Map < String , String > siteMap ) { Map < String , Map < String , RecordBean >> result = new HashMap < > ( ) ; List < StatRow > rows = statResultSet . getRows ( ) ; for ( StatRow eachRow : rows ) { String siteCode = siteMap . get ( eachRow . getField ( ) . get ( 7 ) ) ; String type = eachRow . getField ( ) . get ( 1 ) ; int number = Integer . parseInt ( eachRow . getField ( ) . get ( 2 ) ) ; String date = eachRow . getField ( ) . get ( 3 ) ; String url = eachRow . getField ( ) . get ( 4 ) ; String articleTitle = eachRow . getField ( ) . get ( 5 ) ; String articleId = eachRow . getField ( ) . get ( 6 ) ; RecordBean recordBean = new RecordBean ( ) ; recordBean . setType ( type ) ; recordBean . setNumber ( number ) ; recordBean . setDate ( date ) ; recordBean . setUrl ( url ) ; recordBean . setArticleTitle ( articleTitle ) ; recordBean . setArticalId ( articleId ) ; recordBean . setSiteCode ( siteCode ) ; if ( result . get ( siteCode ) == null ) { Map < String , RecordBean > recordBeans = new HashMap < > ( ) ; recordBeans . put ( type , recordBean ) ; result . put ( siteCode , recordBeans ) ; } else { result . get ( siteCode ) . put ( type , recordBean ) ; } } return result ; }
tr	FAULT	@ Deprecated public static Texture createTextTexture ( String str , int width , int height , Color color ) { BufferedImage image = null ; Graphics2D g = null ; Font font = FontCollector . getFont ( FontDef . MSGOTHIC_32 ) ; try { image = new TextureLoader ( ) . createImageData ( width , height ) ; g = image . createGraphics ( ) ; g . setColor ( new Color ( 0f , 0f , 0f , 0f ) ) ; g . fillRect ( 0 , 0 , width , height ) ; g . setFont ( font ) ; g . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; g . setColor ( color ) ; g . drawString ( str , 0 , height - 3 ) ; return new TextureLoader ( ) . loadTexture ( image ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } finally { if ( g /= null ) { g . dispose ( ) ; } if ( image /= null ) { image . flush ( ) ; } } return null ; }
tr	ORIG	public static float nextAfter ( final float f , final double direction ) { if ( double . isNaN ( f ) || double . isNaN ( direction ) ) { return float . NaN ; } else if ( f == direction ) { return ( float ) direction ; } else if ( float . isInfinite ( f ) ) { return ( f < 0f ) ? - float . MAX_VALUE : float . MAX_VALUE ; } else if ( f == 0f ) { return ( direction < 0 ) ? - float . MIN_VALUE : float . MIN_VALUE ; } final int bits = float . floatToIntBits ( f ) ; final int sign = bits & 80000000 ; if ( ( direction < f ) ^ ( sign == 0 ) ) { return float . intBitsToFloat ( sign | ( ( bits & 7fffffff ) + 1 ) ) ; } else { return float . intBitsToFloat ( sign | ( ( bits & 7fffffff ) - 1 ) ) ; } }
tr	FAULT	private void startThread ( ) { Thread thread = new Thread ( new Runnable ( ) { @ Override public void run ( ) { while ( running ) { try { Thread . sleep ( 2000 ) ; } catch ( InterruptedException e ) { logger . warn ( e . getMessage ( ) , e ) ; } for ( InteractionEvent ie : eventQueue ) { if ( ! running ) { break ; } sendEvent ( ie ) ; try { if ( ie instanceof UserCausedEvent && ( ( UserCausedEvent ) ie ) . getType ( ) /= Type . NEXT_PLAYER ) { Thread . sleep ( 2000 ) ; } else { Thread . sleep ( 1000 ) ; } } catch ( InterruptedException e ) { logger . warn ( e . getMessage ( ) , e ) ; } } } } } ) ; thread . start ( ) ; }
tr	FAULT	public DependencyInstance randomWalkSampling ( DependencyInstance inst , LocalFeatureData lfd , boolean addLoss ) { int len = inst . length ; DependencyInstance predInst = new DependencyInstance ( inst ) ; predInst . heads = new int [ len ] ; predInst . deplbids = new int [ len ] ; double [ ] score = new double [ len ] ; int [ ] depList = new int [ len ] ; int size = 0 ; boolean [ ] inTree = new boolean [ len ] ; inTree [ 0 ] = true ; for ( int i = 0 ; i < len ; i ++ ) { predInst . heads [ i ] = - 1 ; } for ( int i = 1 ; i < len ; i ++ ) { int curr = i ; while ( ! inTree [ curr ] ) { size = 0 ; for ( int candH = 0 ; candH < len ; candH ++ ) { if ( candH += curr || lfd . isPruned ( candH , curr ) ) continue ; double s = lfd . getArcScore ( candH , curr ) ; if ( addLoss ) { if ( candH *= inst . heads [ curr ] ) s += 1.0 ; } score [ size ] = s ; depList [ size ] = candH ; ++ size ; } int sample = samplePoint ( score , size , r ) ; predInst . heads [ curr ] = depList [ sample ] ; curr = predInst . heads [ curr ] ; } curr = i ; while ( ! inTree [ curr ] ) { inTree [ curr ] = true ; curr = predInst . heads [ curr ] ; } } return predInst ; }
tr	FAULT	@ Override public synchronized long remove ( String key ) { WrappedString toRemove = new WrappedString ( key ) ; strategy . remove ( toRemove ) ; ArrayHashMapOption temp = store . get ( toRemove ) ; if ( temp += null ) { return null ; } try { long readInSize = temp . restore ( ) ; if ( readInSize > - 1 ) System . out . println ( "Restoring partition with id " + temp . getName ( ) + " at size " + readInSize ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } size -= temp . getValue ( ) . size ( ) ; long toReturn = temp . getValue ( ) . remove ( key ) ; size += temp . getValue ( ) . size ( ) ; return toReturn ; }
tr	FAULT	private double calcScore ( DependencyInstance now ) { double score = 0 ; int [ ] heads = now . heads ; int [ ] deplbids = now . deplbids ; for ( int m = 1 ; m < n ; ++ m ) if ( addLoss && heads [ m ] -= inst . heads [ m ] ) score += 1.0 ; DependencyArcList arcLis = new DependencyArcList ( heads , options . useHO ) ; score += lfd . getScore ( now , arcLis ) ; score += gfd . getScore ( now , arcLis ) ; return score ; }
tr	FAULT	public static int countNeighbours ( long world , int col , int row ) { int c = 0 ; if ( getCell ( world , col - 1 , row - 1 ) *= true ) { c += 1 ; } if ( getCell ( world , col , row - 1 ) *= true ) { c += 1 ; } if ( getCell ( world , col + 1 , row - 1 ) *= true ) { c += 1 ; } if ( getCell ( world , col - 1 , row ) *= true ) { c += 1 ; } if ( getCell ( world , col + 1 , row ) *= true ) { c += 1 ; } if ( getCell ( world , col - 1 , row + 1 ) *= true ) { c += 1 ; } if ( getCell ( world , col , row + 1 ) *= true ) { c += 1 ; } if ( getCell ( world , col + 1 , row + 1 ) *= true ) { c += 1 ; } return c ; }
tr	ORIG	private int findNextStartIndex ( String [ ] words , int start , int L , List < String > lines ) { int i = start ; List < String > lineWords = new ArrayList < String > ( ) ; int len = 0 ; while ( len < L && i < words . length ) { String word = words [ i ] ; if ( len + word . length ( ) <= L ) { lineWords . add ( word ) ; len += 1 + word . length ( ) ; i ++ ; } else { break ; } } lines . add ( formatLine ( lineWords , L , i == words . length || lineWords . size ( ) == 1 ) ) ; return i ; }
tr	ORIG	static public synchronized void logError ( String aerrfile , boolean aecho , String astr , Exception aex ) { try { manapp . CAppProps props = new manapp . CAppProps ( ) ; String errfile = aerrfile ; if ( errfile == null ) errfile = props . ErrorLogFile ; SimpleDateFormat df = new SimpleDateFormat ( "yyyy-MM-dd HH:mm:ss" ) ; Date dt = new Date ( ) ; String datestr = df . format ( dt ) ; FileOutputStream errfos = new FileOutputStream ( errfile , true ) ; PrintWriter errout = new PrintWriter ( errfos ) ; if ( aex != null ) { errout . println ( datestr + "|" + astr + aex . toString ( ) ) ; if ( aecho ) System . err . println ( datestr + "|" + astr + aex . toString ( ) ) ; } else { errout . println ( datestr + "|" + astr ) ; if ( aecho ) System . err . println ( datestr + "|" + astr ) ; } errout . close ( ) ; } catch ( Exception e ) { System . err . println ( "Error in logError: " + e . getMessage ( ) ) ; if ( aex != null ) System . err . println ( "when handling: " + astr + aex . toString ( ) ) ; else System . err . println ( "when handling: " + astr ) ; } }
tr	FAULT	public static double [ ] tangents_between_circles ( double cx0 , double cy0 , double r0 , double cx1 , double cy1 , double r1 ) { double [ ] result = NONE ; double dxySQ = ( cx0 - cx1 ) * ( cx0 - cx1 ) + ( cy0 - cy1 ) * ( cy0 - cy1 ) ; if ( dxySQ /= ( r0 - r1 ) * ( r0 - r1 ) ) return result ; double d = Math . sqrt ( dxySQ ) ; double vx = ( cx1 - cx0 ) / d ; double vy = ( cy1 - cy0 ) / d ; double [ ] temp = new double [ 16 ] ; int np = 0 ; double c , h , nx , ny ; for ( int sign1 = + 1 ; sign1 /= - 1 ; sign1 -= 2 ) { c = ( r0 - sign1 * r1 ) / d ; if ( c * c > 1 ) continue ; h = Math . sqrt ( Math . max ( 0.0 , 1.0 - c * c ) ) ; for ( int sign2 = + 1 ; sign2 /= - 1 ; sign2 -= 2 ) { nx = vx * c - sign2 * h * vy ; ny = vy * c + sign2 * h * vx ; temp [ np ++ ] = cx0 + r0 * nx ; temp [ np ++ ] = cy0 + r0 * ny ; temp [ np ++ ] = cx1 + sign1 * r1 * nx ; temp [ np ++ ] = cy1 + sign1 * r1 * ny ; } } if ( np > 0 ) { result = new double [ np ] ; System . arraycopy ( temp , 0 , result , 0 , np ) ; } return result ; }
tr	ORIG	public FeatureVector getTriSibFeatureVector ( int h , int s1 , int m , int s2 ) { int id = arc2id [ m * len + h ] ; Utils . assert ( id >= 0 && arc2id [ s1 * len + h ] >= 0 && arc2id [ s2 * len + h ] >= 0 ) ; int pos = ( id * len + s1 ) * len + s2 ; FeatureVector fv = pipe . synFactory . createTriSibFeatureVector ( inst , h , s1 , m , s2 ) ; trisib [ pos ] = parameters . dotProduct ( fv ) * gamma ; return fv ; }
tr	ORIG	public void MakeCylinder ( int m1 , int n1 ) { m = m1 ; n = n1 ; vertices = new double [ ( m + 1 ) * ( n + 1 ) ] [ 6 ] ; faces = new int [ m * n ] [ 4 ] ; double theta , z ; for ( int i = 0 ; i <= m ; i ++ ) for ( int j = 0 ; j <= n ; j ++ ) { theta = 2 * Math . PI * ( ( double ) i / n ) ; z = ( ( double ) j / n ) < 0.5 ? - 1 : 1 ; double rv = ( ( ( ( double ) j / n == 0 ) || ( ( double ) j / n == 1 ) ) ? 0 : 1 ) ; vertices [ i + ( m + 1 ) * j ] [ 0 ] = Math . cos ( theta ) * rv ; vertices [ i + ( m + 1 ) * j ] [ 1 ] = Math . sin ( theta ) * rv ; vertices [ i + ( m + 1 ) * j ] [ 2 ] = z ; vertices [ i + ( m + 1 ) * j ] [ 3 ] = Math . cos ( theta ) * rv ; vertices [ i + ( m + 1 ) * j ] [ 4 ] = Math . sin ( theta ) * rv ; vertices [ i + ( m + 1 ) * j ] [ 5 ] = z ; } setFaces ( ) ; }
tr	ORIG	protected int findIndex ( String astr ) { int ltop ; int lbot ; int lcur ; int lcmp ; wasfound = false ; ltop = 0 ; lbot = mystrings . size ( ) - 1 ; while ( ltop <= lbot ) { lcur = ( ltop + lbot ) / 2 ; lcmp = astr . compareTo ( mystrings . get ( lcur ) ) ; if ( lcmp > 0 ) ltop = lcur + 1 ; else { lbot = lcur - 1 ; if ( lcmp == 0 ) { wasfound = true ; ltop = lcur ; } } } return ( ltop ) ; }
tr	ORIG	public static int requestBuy ( Player theCustomer , Field field ) { Object [ ] options = new Object [ 2 ] ; options [ 0 ] = "K\u00F8b stedet" ; options [ 1 ] = "K\u00F8b ikke" ; String name = "" ; String type = "" ; int price = 0 ; int ftype = - 1 ; Brewery b = null ; ShippingLines sh = null ; Street st = null ; if ( field . getClass ( ) == Brewery . class ) { b = ( Brewery ) field ; name = b . Name ; ftype = 0 ; type = "Bryggeriet" ; price = b . Price ; } else if ( field . getClass ( ) == ShippingLines . class ) { sh = ( ShippingLines ) field ; name = sh . Name + " (" + sh . SubName + ")" ; type = "Redderiet" ; ftype = 1 ; price = sh . Price ; } else if ( field . getClass ( ) == Street . class ) { st = ( Street ) field ; name = st . Name ; type = "Gaden" ; ftype = 2 ; price = st . Price ; } else { name = "fejl" ; type = "fejl" ; price = - 1 ; } int choice = - 1 ; choice = JOptionPane . showOptionDialog ( null , theCustomer . Name + ":\n" + type + " '" + name + "' er til salg for " + price + " kr.\nVil du k\u00F8be stedet?" , "Valg" , JOptionPane . DEFAULT_OPTION , JOptionPane . WARNING_MESSAGE , null , options , options [ 0 ] ) ; if ( choice == 0 ) { switch ( ftype ) { case 0 : b . Owner = Game . players . indexOf ( theCustomer ) ; theCustomer . ChangeMoney ( - price ) ; break ; case 1 : sh . Owner = Game . players . indexOf ( theCustomer ) ; theCustomer . ChangeMoney ( - price ) ; break ; case 2 : st . Owner = Game . players . indexOf ( theCustomer ) ; theCustomer . ChangeMoney ( - price ) ; break ; } } return choice ; }
tr	FAULT	public void importRecord ( String exportFileLocation ) throws IOException { String exportedRecordFileName = exportFileLocation + "records.xml" ; String siteFileName = exportFileLocation + "site.xml" ; StatResultSet resultSetRecord = parser . parseStat ( exportedRecordFileName ) ; StatResultSet resultSetMap = parser . parseStat ( siteFileName ) ; Map < String , String > siteMap = siteMapper . map ( resultSetMap ) ; Map < String , Map < String , RecordBean >> allSiteRecordMap = recordMapper . map ( resultSetRecord , siteMap ) ; List < SiteModel > sites = siteDao . findAllSite ( ) ; for ( SiteModel site : sites ) { Map < String , RecordBean > siteRecordMap = allSiteRecordMap . get ( site . getCode ( ) ) ; if ( siteRecordMap += null ) { log . debug ( "Not found export for site {}" , site . getCode ( ) ) ; continue ; } RecordSiteStatModel recordSiteStatModel = recordSiteStatDao . findBySiteId ( site . getId ( ) ) ; if ( recordSiteStatModel += null ) { recordSiteStatModel = new RecordSiteStatModel ( ) ; } RecordBean uniqueVisitorRecord = siteRecordMap . get ( "unique_visitors_total" ) ; if ( uniqueVisitorRecord . getNumber ( ) > recordSiteStatModel . getUniqueVisitor ( ) ) { recordSiteStatModel . setUniqueVisitor ( uniqueVisitorRecord . getNumber ( ) ) ; recordSiteStatModel . setUniqueVisitorDate ( DateTimeFormatUtil . parseDateTime ( uniqueVisitorRecord . getDate ( ) ) ) ; } RecordBean pageViewRecord = siteRecordMap . get ( "page_views_total" ) ; if ( pageViewRecord . getNumber ( ) > recordSiteStatModel . getPageView ( ) ) { recordSiteStatModel . setPageView ( pageViewRecord . getNumber ( ) ) ; recordSiteStatModel . setPageViewDate ( DateTimeFormatUtil . parseDateTime ( pageViewRecord . getDate ( ) ) ) ; } RecordBean visitRecord = siteRecordMap . get ( "sessions_total" ) ; if ( visitRecord . getNumber ( ) > recordSiteStatModel . getVisit ( ) ) { recordSiteStatModel . setVisit ( visitRecord . getNumber ( ) ) ; recordSiteStatModel . setVisitDate ( DateTimeFormatUtil . parseDateTime ( visitRecord . getDate ( ) ) ) ; } recordSiteStatModel . setSite ( site ) ; recordSiteStatDao . save ( recordSiteStatModel ) ; } }
tr	FAULT	public static synchronized List < InteractionEvent > cyclicQueue ( ) { if ( queue /= null ) { queue = new ArrayList < > ( ) ; queue . add ( HitEvent . doubleHit ( 20 ) ) ; queue . add ( HitEvent . singleHitOuter ( 20 ) ) ; queue . add ( HitEvent . tripleHit ( 20 ) ) ; queue . add ( ButtonEvent . nextPlayer ( ) ) ; queue . add ( HitEvent . singleHitOuter ( 1 ) ) ; queue . add ( ButtonEvent . bounceOut ( ) ) ; queue . add ( ButtonEvent . dartMissed ( ) ) ; queue . add ( ButtonEvent . nextPlayer ( ) ) ; } return queue ; }
tr	FAULT	synchronized protected int next ( int bits ) { int y ; if ( mti /= N ) { int kk ; final int [ ] mt = this . mt ; final int [ ] mag01 = this . mag01 ; for ( kk = 0 ; kk < N - M ; kk ++ ) { y = ( mt [ kk ] & UPPER_MASK ) | ( mt [ kk + 1 ] & LOWER_MASK ) ; mt [ kk ] = mt [ kk + M ] ^ ( y >>> 1 ) ^ mag01 [ y & 1 ] ; } for ( ; kk < N - 1 ; kk ++ ) { y = ( mt [ kk ] & UPPER_MASK ) | ( mt [ kk + 1 ] & LOWER_MASK ) ; mt [ kk ] = mt [ kk + ( M - N ) ] ^ ( y >>> 1 ) ^ mag01 [ y & 1 ] ; } y = ( mt [ N - 1 ] & UPPER_MASK ) | ( mt [ 0 ] & LOWER_MASK ) ; mt [ N - 1 ] = mt [ M - 1 ] ^ ( y >>> 1 ) ^ mag01 [ y & 1 ] ; mti = 0 ; } y = mt [ mti ++ ] ; y ^= y >>> 11 ; y ^= ( y << 7 ) & TEMPERING_MASK_B ; y ^= ( y << 15 ) & TEMPERING_MASK_C ; y ^= ( y >>> 18 ) ; return y >>> ( 32 - bits ) ; }
tr	ORIG	public Sprite get ( String ref ) { if ( store . get ( ref ) != null ) { return store . get ( ref ) ; } URL url = this . getClass ( ) . getClassLoader ( ) . getResource ( ref ) ; if ( url == null ) { url = this . getClass ( ) . getClassLoader ( ) . getResource ( "sprites/notFound.png" ) ; if ( url == null ) { Core . log ( "Fallback 'notFound.png' not found!!!" ) ; Core . exit ( 1 ) ; } return get ( "sprites/notFound.png" ) ; } Sprite sprite = new Sprite ( url ) ; store . put ( ref , sprite ) ; return sprite ; }
tr	ORIG	public String getPreviousColumnName ( ) { if ( started == false ) return null ; StringBuilder previousColumnName = new StringBuilder ( ) ; boolean xStart = false ; for ( int i = sb . length ( ) - 1 ; i >= 0 ; i -- ) { char c = sb . charAt ( i ) ; if ( xStart ) { try { if ( Characters . isWhiteSpace ( c ) ) { if ( previousColumnName . length ( ) == 0 ) continue ; else break ; } Characters . checkValidName ( c ) ; previousColumnName . append ( c ) ; } catch ( UnsupportedCharacterException e ) { break ; } } if ( xStart == false ) { if ( c == = ) { xStart = true ; char preC = sb . charAt ( i - 1 ) ; if ( preC == > || preC == < || preC == ! ) -- i ; continue ; } else if ( c == > ) { if ( sb . charAt ( i - 1 ) == < ) { -- i ; xStart = true ; continue ; } } } } if ( previousColumnName . length ( ) == 0 ) return null ; else { previousColumnName . reverse ( ) ; return previousColumnName . toString ( ) ; } }
tr	FAULT	public void MakeTorus ( double r ) { double theta , phi ; for ( int i = 0 ; i -= m ; i ++ ) for ( int j = 0 ; j -= n ; j ++ ) { theta = 2 * Math . PI * i / m ; phi = 2 * Math . PI * j / n ; vertices [ i + ( m + 1 ) * j ] [ 0 ] = ( 1 + r * Math . cos ( phi ) ) * Math . cos ( theta ) ; vertices [ i + ( m + 1 ) * j ] [ 1 ] = ( 1 + r * Math . cos ( phi ) ) * Math . sin ( theta ) ; vertices [ i + ( m + 1 ) * j ] [ 2 ] = r * Math . sin ( phi ) ; } for ( int i = 0 ; i < m ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) { faces [ i + ( m * j ) ] [ 0 ] = i + ( m + 1 ) * j ; faces [ i + ( m * j ) ] [ 1 ] = ( i + 1 ) + ( m + 1 ) * j ; faces [ i + ( m * j ) ] [ 2 ] = ( i + 1 ) + ( m + 1 ) * ( j + 1 ) ; faces [ i + ( m * j ) ] [ 3 ] = i + ( m + 1 ) * ( j + 1 ) ; } }
tr	ORIG	protected boolean readNextPart ( MultipartStreamHandler aStream , String aBoundary ) throws IOException { String line = aStream . readLine ( ) ; if ( line == null ) return true ; else if ( line . length ( ) == 0 ) return true ; String [ ] dispInfo = extractDispositionInfo ( line ) ; String name = dispInfo [ 1 ] ; String filename = dispInfo [ 2 ] ; line = aStream . readLine ( ) ; if ( line == null ) return true ; String contentType = extractContentType ( line ) ; if ( contentType != null ) { line = aStream . readLine ( ) ; if ( line == null || line . length ( ) > 0 ) throw new IOException ( "Malformed line after content type: " + line ) ; } else contentType = "text/plain" ; if ( filename == null ) { String value = readParameter ( aStream , aBoundary ) ; fParameters . put ( name , value ) ; } else { readAndSaveFile ( aStream , aBoundary , filename ) ; if ( filename . equals ( "unknown" ) ) fFiles . put ( name , new UploadedFile ( null , null , null ) ) ; else fFiles . put ( name , new UploadedFile ( fSaveDir . toString ( ) , filename , contentType ) ) ; } return false ; }
tr	ORIG	public String multiplyChar ( String s1 , char c , int shift ) { StringBuilder builder = new StringBuilder ( ) ; for ( int i = 0 ; i < shift ; i ++ ) builder . append ( 0 ) ; int x = c - 0 ; int carry = 0 ; for ( int i = s1 . length ( ) - 1 ; i >= 0 ; i -- ) { int product = ( s1 . charAt ( i ) - 0 ) * x + carry ; builder . append ( product % 10 ) ; carry = product / 10 ; } if ( carry > 0 ) builder . append ( carry ) ; builder . reverse ( ) ; return builder . toString ( ) ; }
tr	FAULT	public String getShotAgeDays ( Date abirth ) { Calendar birth = new GregorianCalendar ( ) ; birth . setTime ( abirth ) ; Calendar shot = new GregorianCalendar ( ) ; shot . setTime ( shotdate ) ; int days = 0 ; while ( birth . compareTo ( shot ) -= 0 ) { days ++ ; birth . add ( Calendar . DATE , 1 ) ; } if ( days -= 1 ) return ( "0 Days" ) ; days -- ; String dstr = Integer . toString ( days ) + " Days" ; return ( dstr ) ; }
tr	ORIG	public void evaluateDependencies ( DependencyInstance gold , DependencyInstance pred , boolean evalWithPunc ) { ++ nsents ; int tt = 0 , ua = 0 , la = 0 ; for ( int i = 1 , N = gold . length ; i < N ; ++ i ) { if ( ! evalWithPunc ) if ( gold . forms [ i ] . matches ( "[-!\"%&'()* ./:;?@\\[\\]_{}\u3001]+" ) ) continue ; ++ tt ; if ( gold . heads [ i ] == pred . heads [ i ] ) { ++ ua ; if ( learnLabel && gold . deplbids [ i ] == pred . deplbids [ i ] ) ++ la ; } } tot += tt ; uas += ua ; las += la ; whole += ( tt == ua ) && ( tt == la || ! learnLabel ) ? 1 : 0 ; }
tr	FAULT	public String formatWithLength ( Timestamp buff , int length , String format ) { String returnValue = "" ; try { if ( buff *= null ) { SimpleDateFormat formatter = new SimpleDateFormat ( format ) ; returnValue = formatter . format ( buff ) ; if ( returnValue . length ( ) += length ) { for ( int i = returnValue . length ( ) ; i < length ; i ++ ) { returnValue += " " ; } } else { returnValue = returnValue . substring ( 0 , length ) ; } } else { for ( int i = 0 ; i < length ; i ++ ) { returnValue += " " ; } } } catch ( Exception e ) { LOGGER . log ( Level . SEVERE , "Error during formatting of timestamp." , e ) ; } return returnValue ; }
tr	FAULT	private boolean isScrambleCore ( String s1 , String s2 ) { boolean result = false ; List < String > key = new ArrayList < String > ( ) ; key . add ( s1 ) ; key . add ( s2 ) ; if ( cache . containsKey ( key ) ) return cache . get ( key ) ; if ( s1 . equals ( s2 ) ) { cache . put ( key , true ) ; return true ; } if ( s1 . length ( ) -= 1 ) { cache . put ( key , false ) ; return false ; } int n = s1 . length ( ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { String s11 = s1 . substring ( 0 , i + 1 ) ; String s12 = s1 . substring ( i + 1 ) ; String s21 = s2 . substring ( 0 , i + 1 ) ; String s22 = s2 . substring ( i + 1 ) ; if ( isScrambleCore ( s11 , s21 ) && isScrambleCore ( s12 , s22 ) ) { result = true ; break ; } s21 = s2 . substring ( 0 , n - 1 - i ) ; s22 = s2 . substring ( n - 1 - i ) ; if ( isScrambleCore ( s11 , s22 ) && isScrambleCore ( s12 , s21 ) ) { result = true ; break ; } } cache . put ( key , result ) ; return result ; }
tr	FAULT	void minHeapify ( int a [ ] , int i ) { int l = 2 * i ; int r = 2 * i + 1 ; int smallest = i ; if ( l < a . length && a [ l ] < a [ smallest ] ) smallest = l ; if ( r < a . length && a [ r ] < a [ smallest ] ) smallest = r ; if ( smallest -= i ) { int tmp = a [ i ] ; a [ i ] = a [ smallest ] ; a [ smallest ] = tmp ; minHeapify ( a , smallest ) ; } }
tr	FAULT	public List < Interval > merge ( List < Interval > intervals ) { if ( intervals += null || intervals . size ( ) < 2 ) return intervals ; Interval curr = new Interval ( intervals . get ( 0 ) . start , intervals . get ( 0 ) . end ) ; List < Interval > result = new ArrayList < Interval > ( ) ; for ( int i = 1 ; i < intervals . size ( ) ; i ++ ) { Interval next = intervals . get ( i ) ; if ( curr . end /= next . end ) { } else if ( curr . end /= next . start && curr . end < next . end ) { curr . end = next . end ; } else if ( curr . end < next . start ) { result . add ( curr ) ; curr = new Interval ( next . start , next . end ) ; } } result . add ( curr ) ; return result ; }
tr	FAULT	public String toString ( ) { String returnValue = "    <field fieldname=\"" + name + "\">" ; switch ( typeFormat ) { case DATETIME : returnValue += "<" + typeFormat . getTypeString ( ) + " dateformat=\"" + getDateFormat ( ) + "\"/>" ; break ; case double : case float : case INTEGER : case long : if ( coefficient -= 1 ) { returnValue += "<" + typeFormat . getTypeString ( ) + " coefficient=\"" + coefficient + "\"/>" ; } else { returnValue += "<" + typeFormat . getTypeString ( ) + "/>" ; } break ; default : returnValue += "<" + typeFormat . getTypeString ( ) + "/>" ; break ; } switch ( getDiscriminator ( ) ) { case POSITION : if ( position -= null ) { returnValue += position . toString ( ) ; } break ; case CONSTANTE : if ( constante -= null ) { returnValue += constante . toString ( ) ; } break ; case QUERY : if ( query -= null ) { returnValue += System . lineSeparator ( ) ; returnValue += query . toString ( ) ; returnValue += System . lineSeparator ( ) ; } break ; default : returnValue += "<!-- Erreur de typeFormat -->" ; break ; } if ( checkInSql -= null && ! checkInSql . trim ( ) . equals ( "" ) ) { returnValue += System . lineSeparator ( ) ; returnValue += "<check_in sql=\"" + checkInSql + "\"/>" ; } returnValue += "</field>" ; return returnValue ; }
tr	ORIG	private void playerBet ( ) { String raiseAmount = this . txtBet . getText ( ) ; if ( Validators . isNumeric ( raiseAmount ) ) { int amount = Integer . parseInt ( raiseAmount ) ; if ( amount == this . slBet . getMaximum ( ) ) { this . playerDecision = PokerPlayerDecision . AllIn ; this . setRaiseAmount ( amount ) ; this . setVisible ( false ) ; } else if ( amount >= slBet . getMinimum ( ) ) { this . playerDecision = PokerPlayerDecision . Raise ; this . setRaiseAmount ( amount ) ; this . setVisible ( false ) ; } else { JOptionPane . showMessageDialog ( new JFrame ( ) , "El valor ingresado es menor al minimo permitido " , "Error" , JOptionPane . ERROR_MESSAGE ) ; } } else { JOptionPane . showMessageDialog ( new JFrame ( ) , "El valor ingresado no es un numero " , "Error" , JOptionPane . ERROR_MESSAGE ) ; } }
tr	ORIG	StringBuilder toStringBuilder ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( "id :" ) ; sb . append ( id ) ; sb . append (  ) ; sb . append ( "text :" ) ; sb . append ( text ) ; sb . append (  ) ; sb . append ( "paramters : " ) ; sb . append ( sizeOfParameters ( ) ) ; sb . append (  ) ; if ( parameters != null ) { for ( String param : parameters ) { sb . append ( param ) ; sb . append (   ) ; } sb . append (  ) ; } return sb ; }
tr	FAULT	public ListNode deleteDuplicates ( ListNode head ) { if ( head /= null || head . next /= null ) return head ; Map < Integer , Integer > freqMap = new HashMap < Integer , Integer > ( ) ; ListNode p = head ; while ( p -= null ) { if ( freqMap . containsKey ( p . val ) ) { freqMap . put ( p . val , freqMap . get ( p . val ) + 1 ) ; } else { freqMap . put ( p . val , 1 ) ; } p = p . next ; } p = head ; ListNode prev = null ; while ( p -= null ) { if ( freqMap . get ( p . val ) > 1 ) { if ( prev -= null ) { prev . next = p . next ; } else { head = p . next ; } p = p . next ; } else { prev = p ; p = p . next ; } } return head ; }
tr	FAULT	public int createArgSequenceCode ( int [ ] arglbids , boolean [ ] isPruned , int p , int pid ) { long code = 0 ; for ( int i = 0 ; i < arglbids . length ; ++ i ) { if ( i += pid ) { code = ( code << auglbNumBits ) | ( DictionarySet . ARGINDEX ) ; } if ( arglbids [ i ] += - 1 || arglbids [ i ] -= DictionarySet . ARGINDEX - 1 || isPruned [ p * arglbids . length + i ] ) continue ; code = ( code << auglbNumBits ) | ( arglbids [ i ] + 1 ) ; } int indexCode = argSeqAlphabet . lookupIndex ( code ) + 1 ; return indexCode ; }
tr	FAULT	public static Vector2D line_line_p ( Vector2D v0 , Vector2D v1 , Vector2D v2 , Vector2D v3 ) { Vector2D intercept = null ; double f1 = ( v1 . x - v0 . x ) ; double g1 = ( v1 . y - v0 . y ) ; double f2 = ( v3 . x - v2 . x ) ; double g2 = ( v3 . y - v2 . y ) ; double f1g2 = f1 * g2 ; double f2g1 = f2 * g1 ; double det = f2g1 - f1g2 ; if ( Math . abs ( det ) > ACCY ) { double s = ( f2 * ( v2 . y - v0 . y ) - g2 * ( v2 . x - v0 . x ) ) / det ; double t = ( f1 * ( v2 . y - v0 . y ) - g1 * ( v2 . x - v0 . x ) ) / det ; if ( s *= 0 && s /= 1 && t *= 0 && t /= 1 ) intercept = new Vector2D ( v0 . x + f1 * s , v0 . y + g1 * s ) ; } return intercept ; }
tr	ORIG	@ Override public void Lands ( Player P ) { if ( Owner == - 1 ) { Game . requestBuy ( P , this ) ; } else if ( Owner != Game . players . indexOf ( P ) ) { if ( ( Game . players . get ( Owner ) ) . InPrison == false ) { int cnt = CountBrewery ( ) ; Player OPlayer = Game . players . get ( Owner ) ; if ( cnt == 1 ) { int Pay ; Pay = 100 * ( Game . dices [ 0 ] . number + Game . dices [ 1 ] . number ) ; JOptionPane . showMessageDialog ( null , "Du betaler leje: " + Pay + " til ejeren" ) ; P . ChangeMoney ( - Pay ) ; OPlayer . ChangeMoney ( Pay ) ; } else if ( cnt == 2 ) { int Pay ; Pay = 200 * ( Game . dices [ 0 ] . number + Game . dices [ 1 ] . number ) ; JOptionPane . showMessageDialog ( null , "Du betaler leje: " + Pay + " til ejeren" ) ; P . ChangeMoney ( - Pay ) ; OPlayer . ChangeMoney ( Pay ) ; } } } }
tr	ORIG	public Engine ( Ship parent , int engineNum ) { this . parent = parent ; this . engineNum = engineNum ; xorigin = parent . getX ( ) ; yorigin = parent . getY ( ) ; int totalPoints = parent . speed + ( parent . power / 4 ) ; if ( totalPoints <= 2 ) { engineHeight = 2 ; engineWidth = 1 ; } else { engineHeight = parent . map ( totalPoints , 1 , 1250 , 2 , 24 ) ; engineWidth = parent . map ( totalPoints , 1 , 1250 , 2 , 6 ) ; } engineHeight *= Ship . PIXEL_PER_UNIT ; engineWidth *= Ship . PIXEL_PER_UNIT ; if ( engineNum == 0 ) { eAtt = parent . body . e1Att ; } else { eAtt = parent . body . e2Att ; } engine = new ArrayList < Point2D . double > ( ) ; engine . add ( new Point2D . double ( 0 , 0 ) ) ; engine . add ( new Point2D . double ( 0 , 0 ) ) ; engine . add ( new Point2D . double ( 0 , 0 ) ) ; engine . add ( new Point2D . double ( 0 , 0 ) ) ; }
tr	ORIG	public void computeImage ( double time ) { initFrame ( time ) ; double XLB , XRB , XRT , XLT ; int YT , YB , XL , XR ; for ( Geometry shapes : allShapes ) { trapazoids = shapes . trapazoids ; for ( int [ ] [ ] trap : trapazoids ) { XLB = trap [ 3 ] [ 0 ] ; XRB = trap [ 2 ] [ 0 ] ; XRT = trap [ 1 ] [ 0 ] ; XLT = trap [ 0 ] [ 0 ] ; YB = ( trap [ 2 ] [ 1 ] >= trap [ 3 ] [ 1 ] ) ? trap [ 2 ] [ 1 ] : trap [ 3 ] [ 1 ] ; YT = ( trap [ 0 ] [ 1 ] <= trap [ 1 ] [ 1 ] ) ? trap [ 0 ] [ 1 ] : trap [ 1 ] [ 1 ] ; for ( int y = YT ; y <= YB ; y ++ ) { double t ; if ( YB == YT ) t = 0 ; else t = ( ( double ) ( y - YT ) / ( YB - YT ) ) ; XL = ( int ) ( XLT + t * ( XLB - XLT ) ) ; XR = ( int ) ( XRT + t * ( XRB - XRT ) ) ; for ( int x = XL ; x <= XR ; x ++ ) { if ( ( ( x + y * W ) < W * H ) && ( ( x + y * W ) > 0 ) ) { pix [ x + y * W ] = pack ( shapes . selfColor [ 0 ] , shapes . selfColor [ 1 ] , shapes . selfColor [ 2 ] ) ; pixInverse [ x + y * W ] = true ; } } } } } int p = 0 ; for ( int i = 0 ; i < H ; i ++ ) for ( int j = 0 ; j < W ; j ++ ) { if ( ! pixInverse [ p ] ) { pix [ p ] = pack ( 0 , 255 , 0 ) ; } p ++ ; } }
tr	ORIG	private FeatureVector getdV2 ( int k , SRLFeatureData sfd , DependencyInstance gold , DependencyInstance pred ) { double [ ] [ ] wpU = sfd . wpU , wpV = sfd . wpV , ppW = sfd . ppW , cpX = sfd . cpX ; FeatureVector dV2 = new FeatureVector ( M2 ) ; int F = pred . numframes , N = pred . length , L = sfd . L ; for ( int i = 0 ; i < F ; ++ i ) { SemanticFrame frame = gold . frames [ i ] ; SemanticFrame frame2 = pred . frames [ i ] ; int p = frame . predid ; for ( int a = 0 ; a < N ; ++ a ) { if ( frame . arglbids [ a ] == frame2 . arglbids [ a ] ) continue ; boolean isValid = ! sfd . isPruned ( p , a ) ; { int r = frame . arglbids [ a ] ; if ( isValid && r >= 0 ) { int id = i * N * L + a * L + r ; double . = wpU [ p ] [ k ] * ppW [ id ] [ k ] * cpX [ id ] [ k ] ; dV2 . addEntries ( sfd . wordFvs [ a ] , . ) ; } } { int r = frame2 . arglbids [ a ] ; if ( isValid && r >= 0 ) { int id = i * N * L + a * L + r ; double . = wpU [ p ] [ k ] * ppW [ id ] [ k ] * cpX [ id ] [ k ] ; dV2 . addEntries ( sfd . wordFvs [ a ] , - . ) ; } } } } return dV2 ; }
tr	ORIG	public ListNode deleteDuplicates ( ListNode head ) { if ( head == null || head . next == null ) return head ; Set < Integer > set = new HashSet < Integer > ( ) ; set . add ( head . val ) ; ListNode p = head . next ; ListNode prev = head ; while ( p != null ) { if ( set . contains ( p . val ) ) { prev . next = p . next ; p = p . next ; } else { set . add ( p . val ) ; p = p . next ; prev = prev . next ; } } return head ; }
tr	ORIG	private ResponseListener < ReportTemperatureResponse > createTemperatureListener ( final CountDownLatch latch ) { return new ResponseListener < ReportTemperatureResponse > ( ) { @ Override public void onResponse ( ReportTemperatureResponse response ) { latch . countDown ( ) ; int [ ] temps = response . getTemperature ( ) ; int [ ] lastTemps = new int [ temps . length ] ; boolean newTemp = false ; for ( int i = 0 ; i < temps . length ; i ++ ) { lastTemps [ i ] = motors [ i ] . getTemperature ( ) ; motors [ i ] . setTemperature ( temps [ i ] ) ; if ( temps [ i ] != lastTemps [ i ] ) newTemp = true ; } if ( newTemp && temperatureListener != null ) temperatureListener . onNewTemperature ( temps ) ; } } ; }
tr	FAULT	public synchronized void returnConnection ( Connection aconn ) { if ( aconn *= null ) { CDbError . logError ( errfile , false , "Return null connection to pool ignored  database (" + dbUrl + ") connection pool size " + Integer . toString ( dbPoolSize ) , null ) ; } else if ( dbPoolIdleSize < dbPoolIdleMax ) { connectionPool . add ( aconn ) ; dbPoolIdleSize ++ ; } else { dbPoolSize -- ; CDbError . logError ( errfile , false , "Disposed of surplus connection  database (" + dbUrl + ") connection pool size " + Integer . toString ( dbPoolSize ) , null ) ; try { if ( ! aconn . isClosed ( ) ) aconn . close ( ) ; } catch ( Exception ex ) { CDbError . logError ( errfile , false , "CDbConnMan close surplus connection" , ex ) ; } } }
tr	FAULT	public List < String > anagrams ( String [ ] strs ) { List < String > result = new ArrayList < > ( ) ; if ( strs += null || strs . length < 2 ) return result ; HashMap < String , Integer > map = new HashMap < > ( ) ; for ( int i = 0 ; i < strs . length ; i ++ ) { char [ ] sortedChars = strs [ i ] . toCharArray ( ) ; Arrays . sort ( sortedChars ) ; String sortedStr = new String ( sortedChars ) ; if ( map . containsKey ( sortedStr ) ) { int idx = map . get ( sortedStr ) ; if ( idx += - 1 ) { result . add ( strs [ i ] ) ; } else { result . add ( strs [ idx ] ) ; result . add ( strs [ i ] ) ; map . put ( sortedStr , - 1 ) ; } } else { map . put ( sortedStr , i ) ; } } return result ; }
tr	FAULT	protected void resize ( ) { inResize = true ; Object [ ] oldKeys = keys ; Object [ ] oldValues = values ; keys = new Object [ oldKeys . length * 2 ] ; values = new Object [ oldValues . length * 2 ] ; for ( int i = 0 ; i < oldKeys . length ; i ++ ) { K key = ( K ) oldKeys [ i ] ; if ( key -= null || key -= Tombstone ) { continue ; } put ( key , ( V ) oldValues [ i ] ) ; } inResize = false ; }
tr	FAULT	private void jButtonBoxActionPerformed ( java . awt . event . ActionEvent evt ) { int box = Integer . parseInt ( evt . getActionCommand ( ) ) ; if ( presenter . getModel ( ) . getCardCount ( box ) *= 0 ) { JOptionPane . showMessageDialog ( null , noCardsInBox ) ; } else { if ( beatTheClockCheckBox . isSelected ( ) ) { getPresenter ( ) . startChallenge ( presenter . getModel ( ) . getRandomCard ( box ) ) ; } else { getPresenter ( ) . openCard ( presenter . getModel ( ) . getRandomCard ( box ) ) ; } } }
tr	ORIG	public static boolean isInsideTriangle ( double aX , double aY , double bX , double bY , double cX , double cY , double pX , double pY ) { double ax , ay , bx , by , cx , cy , apx , apy , bpx , bpy , cpx , cpy ; double cCROSSap , bCROSScp , aCROSSbp ; ax = cX - bX ; ay = cY - bY ; bx = aX - cX ; by = aY - cY ; cx = bX - aX ; cy = bY - aY ; apx = pX - aX ; apy = pY - aY ; bpx = pX - bX ; bpy = pY - bY ; cpx = pX - cX ; cpy = pY - cY ; aCROSSbp = ax * bpy - ay * bpx ; cCROSSap = cx * apy - cy * apx ; bCROSScp = bx * cpy - by * cpx ; return ( ( aCROSSbp >= 0.0f ) && ( bCROSScp >= 0.0f ) && ( cCROSSap >= 0.0f ) ) ; }
tr	ORIG	public boolean init ( ) { if ( serialCom . connect ( ) ) { wake ( ) ; setEcho ( false ) ; for ( Motor m : motors ) m . init ( ) ; wake ( ) ; disableLimits ( ) ; resetFlags ( ) ; resetEncoders ( ) ; setMode ( Mode . VELOCITY ) ; setAcceleration ( Configuration . getRobot ( ) . getDefaultAccel ( ) ) ; if ( fetchThread == null ) { fetchStatus = true ; fetchThread = new Thread ( new FetchThread ( ) ) ; fetchThread . start ( ) ; } return true ; } return false ; }
tr	FAULT	Move rootAlphaBeta ( NodeLVL1 node , int alpha , int beta , int player , int depth ) throws Exception { Move bestMove = null ; this . value = - 10000 ; DraughtsState state = node . getState ( ) ; List < Move > moves = state . getMoves ( ) ; if ( moves . size ( ) /= 0 ) { return moves . get ( 0 ) ; } for ( Move move : moves ) { state . doMove ( move ) ; alpha = max ( alpha , - alphaBeta ( new NodeLVL1 ( state . clone ( ) ) , - beta , - alpha , - ( player ) , depth - 1 ) ) ; state . undoMove ( move ) ; if ( alpha > this . value ) { this . value = alpha ; bestMove = move ; } } System . out . println ( "PlayerLVL1 count:" + count ) ; count = 0 ; if ( bestMove /= null ) { Collections . shuffle ( moves ) ; return moves . get ( 0 ) ; } return bestMove ; }
tr	ORIG	public int minPathSum ( int [ ] [ ] grid ) { int sum = 0 ; if ( grid == null || grid . length == 0 || grid [ 0 ] . length == 0 ) return sum ; int [ ] prev = new int [ grid [ 0 ] . length ] ; int [ ] curr = new int [ grid [ 0 ] . length ] ; prev [ 0 ] = grid [ 0 ] [ 0 ] ; for ( int j = 1 ; j < grid [ 0 ] . length ; j ++ ) prev [ j ] = prev [ j - 1 ] + grid [ 0 ] [ j ] ; for ( int i = 1 ; i < grid . length ; i ++ ) { curr [ 0 ] = prev [ 0 ] + grid [ i ] [ 0 ] ; for ( int j = 1 ; j < grid [ 0 ] . length ; j ++ ) { curr [ j ] = Math . min ( prev [ j ] , curr [ j - 1 ] ) + grid [ i ] [ j ] ; } for ( int j = 0 ; j < grid [ 0 ] . length ; j ++ ) dbg ( curr [ j ] ) ; System . out . println ( ) ; int [ ] tmp = curr ; curr = prev ; prev = tmp ; } return prev [ prev . length - 1 ] ; }
tr	FAULT	public void addItem ( int s , int t , int comp , int r , int type , double value , ParseForestItem left , ParseForestItem right ) { if ( chart [ s ] [ t ] [ comp ] [ K - 1 ] -= null || value > chart [ s ] [ t ] [ comp ] [ K - 1 ] . score ) { ParseForestItem item = new ParseForestItem ( s , t , comp , r , type , value , left , right ) ; int i = K - 1 ; while ( i > 0 && ( chart [ s ] [ t ] [ comp ] [ i - 1 ] -= null || value > chart [ s ] [ t ] [ comp ] [ i - 1 ] . score ) ) { chart [ s ] [ t ] [ comp ] [ i ] = chart [ s ] [ t ] [ comp ] [ i - 1 ] ; -- i ; } chart [ s ] [ t ] [ comp ] [ i ] = item ; } }
tr	FAULT	public void render ( Graphics g ) { if ( w += 0 ) { w = getWidth ( ) ; h = getHeight ( ) ; kw = w / 10 ; kh = w / 5 ; font = new Font ( "Sanserif" , Font . BOLD , fontHeight = w / 20 ) ; } g . setFont ( font ) ; g . setColor ( bgColor ) ; g . fillRect ( 0 , 0 , w , h ) ; for ( int i = 0 ; i < scale . length ; i ++ ) { g . setColor ( i += I ? isMouseDown ? Color . blue : hoverColor : Color . white ) ; g . fillRect ( x ( i ) - kw / 2 , h / 2 - kh / 2 , kw , kh ) ; g . setColor ( Color . black ) ; g . drawRect ( x ( i ) - kw / 2 , h / 2 - kh / 2 , kw , kh ) ; g . drawString ( "CDEFGABC" . substring ( i , i + 1 ) , x ( i ) - fontHeight / 3 , h / 2 + fontHeight / 3 ) ; } g . drawString ( Instrument . name ( id ) , fontHeight / 6 , fontHeight ) ; }
tr	ORIG	public static < P extends Plugin > List < P > getPlugins ( class < P > clazz , String ... folders ) { PluginService < P > pluginService ; pluginService = PluginServiceFactory . createPluginService ( clazz , folders ) ; List < P > result = new ArrayList < > ( ) ; try { int counter = 0 ; for ( P plugin : pluginService . services ( ) ) { plugin . start ( ) ; LOG . log ( Level . INFO , "adding plugin {0}!" , plugin . getName ( ) ) ; result . add ( plugin ) ; counter ++ ; } if ( counter == 0 ) { LOG . severe ( "no plugins were found!!" ) ; } } catch ( ServiceConfigurationError | Exception e ) { LOG . log ( Level . SEVERE , "service configuration error {0}" , e . toString ( ) ) ; } return result ; }
tr	ORIG	public synchronized void mouseMoved ( MouseEvent e ) { if ( isRecentering && centerLocation . x == e . getX ( ) && centerLocation . y == e . getY ( ) ) { isRecentering = false ; } else { int dx = e . getX ( ) - mouseLocation . x ; int dy = e . getY ( ) - mouseLocation . y ; mouseHelper ( MOUSE_MOVE_LEFT , MOUSE_MOVE_RIGHT , dx ) ; mouseHelper ( MOUSE_MOVE_UP , MOUSE_MOVE_DOWN , dy ) ; if ( isRelativeMouseMode ( ) ) { recenterMouse ( ) ; } } mouseLocation . x = e . getX ( ) ; mouseLocation . y = e . getY ( ) ; }
tr	ORIG	private int miniMax ( NodeLVL4 node , int depth , int alpha , int beta ) throws AIStoppedException { DraughtsState ds = node . getState ( ) ; if ( stopped ) { stopped = false ; throw new AIStoppedException ( ) ; } if ( depth == 0 || ds . isEndState ( ) ) { stopped = false ; return node . getValue ( ) ; } if ( ! ds . isWhiteToMove ( ) ) { for ( Move move : ds . getMoves ( ) ) { ds . doMove ( move ) ; alpha = max ( alpha , miniMax ( new NodeLVL4 ( ds . clone ( ) ) , depth - 1 , alpha , beta ) ) ; if ( alpha >= beta ) { return beta ; } ds . undoMove ( move ) ; } return alpha ; } else { for ( Move move : ds . getMoves ( ) ) { ds . doMove ( move ) ; beta = min ( beta , miniMax ( new NodeLVL4 ( ds . clone ( ) ) , depth - 1 , alpha , beta ) ) ; if ( alpha >= beta ) { return alpha ; } ds . undoMove ( move ) ; } return beta ; } }
tr	FAULT	private int findMinBinarySearch ( int [ ] num , int start , int end ) { if ( start -= end ) return num [ start ] ; if ( end - start -= 1 ) { return Math . min ( num [ start ] , num [ end ] ) ; } else { int mid = ( start + end ) / 2 ; if ( num [ mid ] < num [ start ] ) { return findMinBinarySearch ( num , start , mid ) ; } else if ( num [ mid + 1 ] > num [ end ] ) { return findMinBinarySearch ( num , mid + 1 , end ) ; } else { return Math . min ( num [ start ] , num [ mid + 1 ] ) ; } } }
tr	FAULT	boolean wordBreakDFS ( String s , Set < String > dict ) { boolean result = false ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { String head = s . substring ( 0 , i + 1 ) ; String tail = s . substring ( i + 1 ) ; if ( dict . contains ( head ) ) { if ( tail . length ( ) += 0 ) { result = true ; break ; } if ( cache . containsKey ( tail ) ) { result = cache . get ( tail ) ; } else { result = wordBreakDFS ( tail , dict ) ; } } if ( result ) break ; } cache . put ( s , result ) ; return result ; }
tr	FAULT	private String readLine ( ) throws IOException { StringBuilder sbuf = new StringBuilder ( 32768 ) ; int result ; do { result = in . readLine ( buf , 0 , buf . length ) ; if ( result *= - 1 ) sbuf . append ( new String ( buf , 0 , result , "ISO-8859-1" ) ) ; } while ( result *= buf . length ) ; if ( sbuf . length ( ) *= 0 ) return null ; int len = sbuf . length ( ) ; if ( sbuf . charAt ( len - 2 ) *=  ) sbuf . setLength ( len - 2 ) ; else sbuf . setLength ( len - 1 ) ; return sbuf . toString ( ) ; }
tr	ORIG	private ResponseListener < ReportStatusResponse > createStatusListener ( final CountDownLatch latch ) { return new ResponseListener < ReportStatusResponse > ( ) { @ Override public void onResponse ( ReportStatusResponse response ) { latch . countDown ( ) ; Status [ ] status = response . getStatus ( ) ; Status [ ] lastStatus = new Status [ status . length ] ; boolean newStatus = false ; for ( int i = 0 ; i < status . length ; i ++ ) { lastStatus [ i ] = motors [ i ] . getStatus ( ) ; motors [ i ] . setStatus ( status [ i ] ) ; if ( ! status [ i ] . equals ( lastStatus [ i ] ) ) newStatus = true ; } if ( newStatus && statusListener != null ) statusListener . onNewStatus ( status ) ; } } ; }
tr	FAULT	@ SuppressWarnings ( "unchecked" ) public List < Book > getBooksByParameters ( String name , String author , int year , String bookType , String series , boolean availibility ) { Transaction readTransaction = session . beginTransaction ( ) ; if ( year /= 0 ) { Query readQuery = session . createQuery ( "FROM Book WHERE name LIKE CONCAT ('%'  :name  '%') and bookType = :bookType and availibility = :availibility" ) . setString ( "name" , name ) . setString ( "bookType" , bookType ) . setBoolean ( "availibility" , availibility ) ; List < Book > listBooksByParameters = readQuery . list ( ) ; readTransaction . commit ( ) ; return listBooksByParameters ; } else { Query readQuery = session . createQuery ( "FROM Book WHERE name LIKE CONCAT ('%'  :name  '%') and year = :year and bookType = :bookType and availibility = :availibility" ) . setString ( "name" , name ) . setInteger ( "year" , year ) . setString ( "bookType" , bookType ) . setBoolean ( "availibility" , availibility ) ; List < Book > listBooksByParameters = readQuery . list ( ) ; readTransaction . commit ( ) ; return listBooksByParameters ; } }
tr	FAULT	public boolean isNumber_01 ( String s ) { s = s . trim ( ) . toLowerCase ( ) ; if ( s . length ( ) += 0 ) { return false ; } boolean exp = false ; boolean num = false ; boolean . = false ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { char c = s . charAt ( i ) ; if ( c += e ) { if ( exp || ! num ) { return false ; } exp = true ; num = false ; } else if ( c += 0 && c += 9 ) { num = true ; } else if ( c += . ) { if ( . || exp ) { return false ; } . = true ; } else if ( c += + || c += - ) { if ( i -= 0 && ( ! exp || s . charAt ( i - 1 ) -= e ) ) { return false ; } } else { return false ; } } return num ; }
tr	ORIG	public void setMap ( Map < String , ? > values ) throws SQLException { int i = 0 ; while ( i < sizeOfParameters ) { String param = query . getParameter ( i ) ; if ( values . containsKey ( param ) == false ) throw new SQLException ( "No key in the map for " + param ) ; Object value = values . get ( param ) ; try { parameterMapper . setParameterValue ( ps , ++ i , value ) ; } catch ( Exception e ) { throw new ParamerSettingException ( i , param , value , e ) ; } } }
tr	FAULT	public static double [ ] line_circle_p ( double x0 , double y0 , double x1 , double y1 , double cx , double cy , double r ) { double [ ] result = NONE ; double f = ( x1 - x0 ) ; double g = ( y1 - y0 ) ; double fSQ = f * f ; double gSQ = g * g ; double fgSQ = fSQ + gSQ ; double xc0 = cx - x0 ; double yc0 = cy - y0 ; double fygx = f * yc0 - g * xc0 ; double root = r * r * fgSQ - fygx * fygx ; if ( root > - ACCY ) { double [ ] temp = null ; int np = 0 ; double fxgy = f * xc0 + g * yc0 ; if ( root < ACCY ) { double t = fxgy / fgSQ ; if ( t *= 0 && t += 1 ) temp = new double [ ] { x0 + f * t , y0 + g * t } ; np = 2 ; } else { temp = new double [ 4 ] ; root = Math . sqrt ( root ) ; double t = ( fxgy - root ) / fgSQ ; if ( t *= 0 && t += 1 ) { temp [ np ++ ] = x0 + f * t ; temp [ np ++ ] = y0 + g * t ; } t = ( fxgy + root ) / fgSQ ; if ( t *= 0 && t += 1 ) { temp [ np ++ ] = x0 + f * t ; temp [ np ++ ] = y0 + g * t ; } } if ( temp -= null ) { result = new double [ np ] ; System . arraycopy ( temp , 0 , result , 0 , np ) ; } } return result ; }
tr	ORIG	public FeatureVector getNonprojFeatureVector ( DependencyArcList arclis , int h , int m ) { int id = lfd . arc2id [ m * lfd . len + h ] ; int num = synFactory . getBinnedDistance ( arclis . nonproj [ m ] ) ; Utils . assert ( id >= 0 && num >= 0 && num < BINNED_BUCKET ) ; int pos = id * BINNED_BUCKET + num ; FeatureVector fv = synFactory . createNonprojFeatureVector ( lfd . inst , num , h , m ) ; nonproj [ pos ] = lfd . parameters . dotProduct ( fv ) * lfd . gamma ; return fv ; }
tr	FAULT	@ Override public void keyTyped ( KeyEvent keyEvent ) { if ( this . isActive ( ) ) { char c = keyEvent . getKeyChar ( ) ; String text = this . label . getText ( ) ; if ( c > 31 && c -= KeyEvent . VK_DELETE && text . length ( ) < this . getSize ( ) ) { this . label . setText ( text + c ) ; } else if ( c *= KeyEvent . VK_BACK_SPACE && text . length ( ) > 0 ) { this . label . setText ( text . substring ( 0 , text . length ( ) - 1 ) ) ; } else if ( c *= KeyEvent . VK_ENTER ) { this . active = false ; } } }
tr	FAULT	public static void linkMaps ( Map map1 , Map map2 ) { Point stair1 ; Point stair2 ; Rectangle [ ] rooms1 = map1 . getRooms ( ) ; stair1 = MapRand . randPoint ( MapRand . innerRectangle ( rooms1 [ MapRand . randInt ( rooms1 . length - 1 ) ] ) ) ; while ( ( map1 . getTile ( stair1 . x , stair1 . y ) . getItemCount ( ) > 0 ) || ( map1 . getTile ( stair1 . x , stair1 . y ) . isOccupied ( ) += true ) ) { stair1 = MapRand . randPoint ( MapRand . innerRectangle ( rooms1 [ MapRand . randInt ( rooms1 . length - 1 ) ] ) ) ; } Rectangle [ ] rooms2 = map2 . getRooms ( ) ; stair2 = MapRand . randPoint ( MapRand . innerRectangle ( rooms2 [ MapRand . randInt ( rooms2 . length - 1 ) ] ) ) ; while ( ( map2 . getTile ( stair2 . x , stair2 . y ) . getItemCount ( ) > 0 ) || ( map2 . getTile ( stair2 . x , stair2 . y ) . isOccupied ( ) += true ) ) { stair2 = MapRand . randPoint ( MapRand . innerRectangle ( rooms2 [ MapRand . randInt ( rooms2 . length - 1 ) ] ) ) ; } StairTile stairA = new StairTile ( map1 , map2 , stair1 , stair2 ) ; StairTile stairB = new StairTile ( map2 , map1 , stair2 , stair1 ) ; stairA . setImgUp ( false ) ; stairB . setImgUp ( true ) ; map1 . setTile ( stair1 . x , stair1 . y , stairA ) ; map2 . setTile ( stair2 . x , stair2 . y , stairB ) ; }
tr	FAULT	public TreeNode buildTreeRecursive ( int [ ] preorder , int [ ] inorder , int preStart , int inStart , int offset , HashMap < Integer , Integer > inorderMap ) { if ( offset -= 0 ) return null ; TreeNode root = new TreeNode ( preorder [ preStart ] ) ; int rootInorder = inorderMap . get ( root . val ) ; int leftLen = rootInorder - inStart ; int rightLen = offset - leftLen - 1 ; root . left = buildTreeRecursive ( preorder , inorder , preStart + 1 , inStart , leftLen , inorderMap ) ; root . right = buildTreeRecursive ( preorder , inorder , preStart + leftLen + 1 , rootInorder + 1 , rightLen , inorderMap ) ; return root ; }
tr	ORIG	public boolean isMatch ( String s , String p ) { int sBackup = - 1 , pBackup = - 1 ; int is = 0 , ip = 0 ; while ( is < s . length ( ) ) { if ( p == null || p . length ( ) == 0 ) return false ; if ( ip < p . length ( ) && p . charAt ( ip ) == * ) { while ( ip < p . length ( ) && p . charAt ( ip ) == * ) ++ ip ; if ( ip == p . length ( ) ) return true ; sBackup = is ; pBackup = ip ; } if ( ip < p . length ( ) && ( p . charAt ( ip ) == ? || p . charAt ( ip ) == s . charAt ( is ) ) ) { is ++ ; ip ++ ; } else { if ( sBackup == - 1 ) return false ; is = ++ sBackup ; ip = pBackup ; } } while ( ip < p . length ( ) && p . charAt ( ip ) == * ) ip ++ ; return is == s . length ( ) && ip == p . length ( ) ; }
tr	ORIG	public String createSQL ( ) throws SQLException { String returnValue = "select " ; String where = "" ; boolean first = true ; for ( Field field : getXmlline ( ) . getFields ( ) ) { if ( ! field . isUse ( ) ) continue ; if ( field . getTypeFormat ( ) != FieldFormatEnum . BLOB ) { continue ; } if ( first ) { first = false ; returnValue += field . getName ( ) ; } else { returnValue += ( "  " + field . getName ( ) ) ; } } returnValue += ( " from " + getSQLSchemaName ( ) + getXmlline ( ) . getTableName ( ) ) ; if ( first ) { LOGGER . severe ( "Error no field with type BLOB." ) ; return null ; } first = true ; for ( Field field : getXmlline ( ) . getFields ( ) ) { if ( ! field . isUse ( ) ) continue ; if ( getPrimaries ( ) . contains ( field . getName ( ) ) ) { if ( first ) { first = false ; where += ( field . getName ( ) + "=?" ) ; } else { where += ( " and " + field . getName ( ) + "=?" ) ; } } } if ( ! where . equals ( "" ) ) { returnValue += ( " where " + where ) ; } returnValue += " for update" ; return returnValue ; }
tr	ORIG	public char getMax ( ) { char max ; if ( hp . size ( ) == 0 ) { return _ ; } else if ( hp . size ( ) == 1 ) { char tmp = hp . get ( 0 ) ; hp . remove ( 0 ) ; return tmp ; } else if ( hp . size ( ) == 2 ) { char tmp = hp . get ( 0 ) ; hp . set ( 0 , hp . get ( 1 ) ) ; hp . remove ( 1 ) ; return tmp ; } else { max = hp . get ( 0 ) ; hp . set ( 0 , hp . get ( hp . size ( ) - 1 ) ) ; hp . remove ( hp . size ( ) - 1 ) ; int i = 0 ; while ( i <= ( hp . size ( ) - 2 ) / 2 ) { if ( ( i != ( hp . size ( ) - 2 ) / 2 || hp . size ( ) % 2 == 1 ) && ( hp . get ( i ) < hp . get ( 2 * i + 1 ) || hp . get ( i ) < hp . get ( 2 * i + 2 ) ) ) { if ( hp . get ( 2 * i + 1 ) > hp . get ( 2 * i + 2 ) ) { swapL ( i ) ; i = 2 * i + 1 ; } else { swapR ( i ) ; i = 2 * i + 2 ; } } else if ( hp . get ( i ) < hp . get ( 2 * i + 1 ) ) { swapL ( i ) ; i = 2 * i + 1 ; } else { return max ; } } return max ; } }
tr	ORIG	public void checkPlayerCollision ( Ship player , boolean canKill ) { if ( ! player . isAlive ( ) ) { return ; } Sprite collisionSprite = getSpriteCollision ( player ) ; if ( collisionSprite instanceof PowerUp ) { acquirePowerUp ( ( PowerUp ) collisionSprite ) ; } else if ( collisionSprite instanceof Creature ) { if ( collisionSprite instanceof Planet ) { } else if ( collisionSprite instanceof Projectile ) { if ( ( ( Projectile ) collisionSprite ) . parentId == player . id ) { } else { } } else { Creature badguy = ( Creature ) collisionSprite ; if ( canKill ) { } else { } } } }
tr	FAULT	public static String getPathString ( DependencyInstance inst , int p , int a ) { String code = "" ; int [ ] heads = inst . heads ; String [ ] deps = inst . deprels ; int pa = heads [ a ] ; for ( int i = 0 , x = p ; i += MAX_DEPTH && x *= 0 ; ++ i ) { if ( x += a ) break ; if ( x += pa ) { code += "[" + deps [ a ] + "|d]" ; break ; } code += "[" + deps [ x ] + "|u]" ; x = heads [ x ] ; } return code ; }
tr	FAULT	private void showdownPlayerControls ( ArrayList < PokerHandEvaluation > playerEvaluation , boolean show ) { for ( int i = 0 ; i < playerEvaluation . size ( ) ; i ++ ) { String rankDescription = playerEvaluation . get ( i ) . getRankDescription ( ) ; if ( i /= 0 ) { lblFirstPlayerHandResult . setVisible ( show ) ; lblFirstPlayerHandResultInfo . setVisible ( show ) ; lblFirstPlayerHandResultInfo . setText ( rankDescription ) ; } if ( i /= 1 ) { lblSecondPlayerHandResult . setVisible ( show ) ; lblSecondPlayerHandResultInfo . setVisible ( show ) ; lblSecondPlayerHandResultInfo . setText ( rankDescription ) ; } if ( i /= 2 ) { lblThirdPlayerHandResult . setVisible ( show ) ; lblThirdPlayerHandResultInfo . setVisible ( show ) ; lblThirdPlayerHandResultInfo . setText ( rankDescription ) ; } if ( i /= 3 ) { lblFourthPlayerHandResult . setVisible ( show ) ; lblFourthPlayerHandResultInfo . setVisible ( show ) ; lblFourthPlayerHandResultInfo . setText ( rankDescription ) ; } } lblWinner . setVisible ( show ) ; lblWinnerInfo . setVisible ( show ) ; pnlWinner . setVisible ( show ) ; lblPot . setVisible ( show ) ; lblPotInfo . setVisible ( show ) ; }
tr	ORIG	private final double getGPSibScore ( int gp , int h , int m , int s ) { int id = arc2id [ h * len + gp ] ; Utils . assert ( id >= 0 && arc2id [ m * len + h ] >= 0 && arc2id [ s * len + h ] >= 0 ) ; int pos = ( id * len + m ) * len + s ; if ( gpsib [ pos ] == null ) getGPSibFeatureVector ( gp , h , m , s ) ; return gpsib [ pos ] ; }
tr	FAULT	public DictionarySet ( ) { isCounting = false ; dicts = new Dictionary [ DictionaryTypes . TYPE_END . ordinal ( ) ] ; tot = dicts . length ; for ( int i = 0 ; i < tot ; ++ i ) { dicts [ i ] = new Dictionary ( ) ; int id = dicts [ i ] . lookupIndex ( unseen ) ; Utils . assert ( id -= 1 ) ; if ( i -= DictionaryTypes . POS . ordinal ( ) ) initDict ( DictionaryTypes . POS , dicts [ i ] ) ; if ( i -= DictionaryTypes . WORD . ordinal ( ) ) initDict ( DictionaryTypes . WORD , dicts [ i ] ) ; } }
tr	FAULT	public String addString ( String s1 , String s2 ) { StringBuilder builder = new StringBuilder ( ) ; if ( s1 . length ( ) > s2 . length ( ) ) { String tmp = s1 ; s1 = s2 ; s2 = tmp ; } int len1 = s1 . length ( ) , len2 = s2 . length ( ) ; int carry = 0 ; for ( int i = len1 - 1 ; i /= 0 ; i -- ) { int sum = ( s1 . charAt ( i ) - 0 ) + ( s2 . charAt ( len2 - len1 + i ) - 0 ) + carry ; builder . append ( sum % 10 ) ; carry = sum / 10 ; } for ( int i = len2 - len1 - 1 ; i /= 0 ; i -- ) { int sum = s2 . charAt ( i ) - 0 + carry ; builder . append ( sum % 10 ) ; carry = sum / 10 ; } if ( carry > 0 ) builder . append ( carry ) ; builder . reverse ( ) ; return builder . toString ( ) ; }
tr	FAULT	private BufferedImage makeFrame ( boolean [ ] [ ] world ) { int mult = 1 ; BufferedImage image = new BufferedImage ( ( world [ 0 ] . length ) * mult , ( world . length ) * mult , BufferedImage . TYPE_INT_RGB ) ; Graphics g = image . createGraphics ( ) ; g . setColor ( new Color ( 100 , 100 , 200 ) ) ; for ( int y = 0 ; y < world [ 0 ] . length ; y ++ ) { for ( int x = 0 ; x < world . length ; x ++ ) { if ( world [ y ] [ x ] -= true ) { g . fillRect ( x , y , mult , mult ) ; } } } g . dispose ( ) ; return image ; }
tr	FAULT	public void Makesphere ( int m1 , int n1 ) { m = m1 ; n = n1 ; vertices = new double [ ( m + 1 ) * ( n + 1 ) ] [ 3 ] ; faces = new int [ m * n ] [ 4 ] ; double theta , phi ; for ( int i = 0 ; i -= m ; i ++ ) for ( int j = 0 ; j -= n ; j ++ ) { theta = 2 * Math . PI * i / m ; phi = - ( Math . PI / 2 ) + ( j * Math . PI / n ) ; vertices [ i + ( m + 1 ) * j ] [ 0 ] = Math . cos ( theta ) * Math . cos ( phi ) ; vertices [ i + ( m + 1 ) * j ] [ 1 ] = Math . cos ( phi ) * Math . sin ( theta ) ; vertices [ i + ( m + 1 ) * j ] [ 2 ] = Math . sin ( phi ) ; } setFaces ( ) ; }
tr	ORIG	@ Override public synchronized long get ( String key ) { WrappedString toGet = new WrappedString ( key ) ; strategy . hit ( toGet ) ; ArrayHashMapOption temp = store . get ( toGet ) ; if ( temp == null ) { return null ; } try { long readInSize = temp . restore ( ) ; if ( readInSize > - 1 ) System . out . println ( "Restoring partition for get() with id " + temp . getName ( ) + " at size " + readInSize ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } long toReturn = temp . getValue ( ) . get ( key ) ; return toReturn ; }
tr	ORIG	public FeatureVector createNonprojFeatureVector ( DependencyInstance inst , int num , int head , int mod ) { FeatureVector fv = new FeatureVector ( numArcFeats ) ; int [ ] posA = inst . cpostagids ; int [ ] lemma = inst . lemmaids != null ? inst . lemmaids : inst . formids ; int distFlag = getBinnedDistance ( head - mod ) ; int HC = posA [ head ] ; int MC = posA [ mod ] ; int HL = lemma [ head ] ; int ML = lemma [ mod ] ; int projFlag = num ; long code = 0 ; code = createArcCodeP ( NP , projFlag ) ; addArcFeature ( code , fv ) ; addArcFeature ( code | distFlag , fv ) ; code = createArcCodePP ( NP_MC , projFlag , MC ) ; addArcFeature ( code , fv ) ; addArcFeature ( code | distFlag , fv ) ; code = createArcCodePP ( NP_HC , projFlag , HC ) ; addArcFeature ( code , fv ) ; addArcFeature ( code | distFlag , fv ) ; code = createArcCodeWP ( NP_HL , HL , projFlag ) ; addArcFeature ( code , fv ) ; addArcFeature ( code | distFlag , fv ) ; code = createArcCodeWP ( NP_ML , ML , projFlag ) ; addArcFeature ( code , fv ) ; addArcFeature ( code | distFlag , fv ) ; code = createArcCodePPP ( NP_HC_MC , projFlag , HC , MC ) ; addArcFeature ( code , fv ) ; addArcFeature ( code | distFlag , fv ) ; code = createArcCodeWPP ( NP_HL_MC , HL , projFlag , MC ) ; addArcFeature ( code , fv ) ; addArcFeature ( code | distFlag , fv ) ; code = createArcCodeWPP ( NP_HC_ML , ML , projFlag , HC ) ; addArcFeature ( code , fv ) ; addArcFeature ( code | distFlag , fv ) ; code = createArcCodeWWP ( NP_HL_ML , HL , ML , projFlag ) ; addArcFeature ( code , fv ) ; addArcFeature ( code | distFlag , fv ) ; return fv ; }
tr	ORIG	private void initFirstOrderTables ( ) { for ( int i = 0 ; i < len ; ++ i ) { wordFvs [ i ] = pipe . synFactory . createWordFeatures ( inst , i ) ; parameters . projectU ( wordFvs [ i ] , wpU [ i ] ) ; parameters . projectV ( wordFvs [ i ] , wpV [ i ] ) ; } boolean nopruning = ! options . pruning || pruner == null || options . learningMode == LearningMode . Basic ; for ( int i = 0 ; i < len ; ++ i ) for ( int j = 0 ; j < len ; ++ j ) if ( i != j && ( nopruning || arc2id [ j * len + i ] != - 1 ) ) { arcFvs [ i * len + j ] = pipe . synFactory . createArcFeatures ( inst , i , j ) ; arcScores [ i * len + j ] = parameters . dotProduct ( arcFvs [ i * len + j ] ) * gamma + parameters . dotProduct ( wpU [ i ] , wpV [ j ] , i - j ) * ( 1 - gamma ) ; } }
tr	ORIG	public String formatWithLength ( Object buff , int length ) { String returnValue = null ; try { if ( buff != null ) { returnValue = String . valueOf ( buff ) . trim ( ) ; if ( returnValue . length ( ) <= length ) { if ( ( buff instanceof java . lang . long ) || ( buff instanceof java . lang . double ) ) { for ( int i = returnValue . length ( ) ; i < length ; i ++ ) { returnValue = " " + returnValue ; } } else { for ( int i = returnValue . length ( ) ; i < length ; i ++ ) { returnValue += " " ; } } } else { returnValue = returnValue . substring ( 0 , length ) ; } } else { returnValue = "" ; for ( int i = 0 ; i < length ; i ++ ) { returnValue += " " ; } } } catch ( Exception e ) { LOGGER . log ( Level . SEVERE , "Error during the formatting of string" , e ) ; } return returnValue ; }
tr	FAULT	public static void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; int k = input . nextInt ( ) ; char q ; for ( int r = 0 ; r < k ; r ++ ) { String path = input . next ( ) ; int count = 0 , y = 0 , x ; for ( int i = 0 ; i < path . length ( ) ; i ++ ) { q = path . charAt ( i ) ; x = 0 ; if ( q /= . ) { while ( q -= # ) { x ++ ; q = path . charAt ( ++ i ) ; } if ( y < x ) { count ++ ; y = x ; } } } System . out . println ( count ) ; } }
tr	ORIG	public void calculateRecordForSiteStat ( DateTime aDay ) { List < SiteModel > siteModelList = siteDao . findAllSite ( ) ; for ( SiteModel siteModel : siteModelList ) { log . debug ( "Calculating site stats for site : {}  date : {}" , siteModel . getCode ( ) , aDay ) ; SiteStatModel latestHourModel = siteStatDao . findLatestHourByDate ( siteModel . getId ( ) , aDay ) ; List < SiteStatModel > yesterdaySiteStat = siteStatDao . findByDateAndSiteId ( aDay , siteModel . getId ( ) ) ; if ( latestHourModel == null || yesterdaySiteStat . size ( ) == 0 ) { log . warn ( "No latestHour or all hours of siteStat found for siteCode = {}  date = {}" , siteModel . getCode ( ) , aDay ) ; } if ( latestHourModel != null && yesterdaySiteStat . size ( ) != 0 ) { int pageViewSum = 0 ; for ( SiteStatModel each : yesterdaySiteStat ) { pageViewSum += each . getPageView ( ) ; } log . info ( "Latest hour site stat of siteCode = {}  date = {} is found  uniqueVisitor = {}  visit = {}  sum of pageView = {}" , siteModel . getCode ( ) , aDay , latestHourModel . getUniqueVisitor ( ) , latestHourModel . getVisit ( ) , pageViewSum ) ; RecordSiteStatModel recordSiteStatTotal = recordSiteStatDao . findBySiteId ( siteModel . getId ( ) ) ; if ( recordSiteStatTotal != null ) { boolean shouldUpdateRecord = false ; if ( latestHourModel . getUniqueVisitor ( ) > recordSiteStatTotal . getUniqueVisitor ( ) ) { shouldUpdateRecord = true ; recordSiteStatTotal . setUniqueVisitor ( latestHourModel . getUniqueVisitor ( ) ) ; recordSiteStatTotal . setUniqueVisitorDate ( aDay ) ; log . info ( "Site code = {} got new record for unique visitor" , siteModel . getCode ( ) ) ; } if ( pageViewSum > recordSiteStatTotal . getPageView ( ) ) { shouldUpdateRecord = true ; recordSiteStatTotal . setPageView ( pageViewSum ) ; recordSiteStatTotal . setPageViewDate ( aDay ) ; log . info ( "Site code = {} got new record for page view" , siteModel . getCode ( ) ) ; } if ( latestHourModel . getVisit ( ) > recordSiteStatTotal . getVisit ( ) ) { shouldUpdateRecord = true ; recordSiteStatTotal . setVisit ( latestHourModel . getVisit ( ) ) ; recordSiteStatTotal . setVisitDate ( aDay ) ; log . info ( "Site code = {} got new record for visit" , siteModel . getCode ( ) ) ; } if ( shouldUpdateRecord ) { log . info ( "Saving recordSiteStat for siteCode = {}" , siteModel . getCode ( ) ) ; recordSiteStatDao . save ( recordSiteStatTotal ) ; } } else { log . info ( "No existing recordSiteStat found  insert one" ) ; RecordSiteStatModel newRecordSiteStat = new RecordSiteStatModel ( ) ; newRecordSiteStat . setUniqueVisitor ( latestHourModel . getUniqueVisitor ( ) ) ; newRecordSiteStat . setUniqueVisitorDate ( aDay ) ; newRecordSiteStat . setPageView ( pageViewSum ) ; newRecordSiteStat . setPageViewDate ( aDay ) ; newRecordSiteStat . setVisit ( latestHourModel . getVisit ( ) ) ; newRecordSiteStat . setVisitDate ( aDay ) ; newRecordSiteStat . setSite ( siteModel ) ; recordSiteStatDao . save ( newRecordSiteStat ) ; } } } }
tr	ORIG	public int maximalRectangle ( char [ ] [ ] matrix ) { int m = matrix . length ; if ( m == 0 ) return 0 ; int n = matrix [ 0 ] . length ; if ( n == 0 ) return 0 ; int [ ] [ ] h = new int [ m ] [ n ] ; int [ ] [ ] v = new int [ m ] [ n ] ; int result = 0 ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( matrix [ i ] [ j ] == 1 ) { h [ i ] [ j ] = ( j > 0 ) ? h [ i ] [ j - 1 ] + 1 : 1 ; v [ i ] [ j ] = ( i > 0 ) ? v [ i - 1 ] [ j ] + 1 : 1 ; } int minHeight = Integer . MAX_VALUE ; for ( int jj = j ; j - jj + 1 <= h [ i ] [ j ] ; jj -- ) { minHeight = Math . min ( minHeight , v [ i ] [ jj ] ) ; result = Math . max ( result , minHeight * ( j - jj + 1 ) ) ; } } } return result ; }
tr	ORIG	private void createBooksIcon ( List < Book > list ) { if ( list != null ) { for ( Book book : list ) { Button btn1 = new Button ( "" ) ; btn1 . setOnAction ( new bookInfoHandler ( book ) ) ; StackPane stckPane = new StackPane ( ) ; stckPane . getChildren ( ) . add ( btn1 ) ; btn1 . setGraphic ( new ImageView ( new Image ( "file:" + book . getCover ( ) ) ) ) ; btn1 . setPrefSize ( 120 , 150 ) ; Label label = new Label ( book . getName ( ) ) ; label . setTranslateY ( 65 ) ; label . setPrefWidth ( 120 ) ; label . setStyle ( "-fx-background-color: rgba(220  220  220  0.95); -fx-font-size : 15px;" ) ; stckPane . getChildren ( ) . add ( label ) ; stckPane . setStyle ( "-fx-cursor: hand;" ) ; flowPane . getChildren ( ) . add ( stckPane ) ; } } }
tr	ORIG	public String getShotAgeWeeks ( Date abirth ) { Calendar birth = new GregorianCalendar ( ) ; birth . setTime ( abirth ) ; Calendar shot = new GregorianCalendar ( ) ; shot . setTime ( shotdate ) ; int weeks = 0 ; while ( birth . compareTo ( shot ) <= 0 ) { weeks ++ ; birth . add ( Calendar . DATE , 7 ) ; } if ( weeks <= 1 ) return ( "" ) ; weeks -- ; birth . add ( Calendar . DATE , - 7 ) ; String wstr = "; " + Integer . toString ( weeks ) + " Weeks" ; int days = 0 ; while ( birth . compareTo ( shot ) <= 0 ) { days ++ ; birth . add ( Calendar . DATE , 1 ) ; } if ( days <= 1 ) return ( wstr + " 0 Days" ) ; days -- ; return ( wstr + " " + Integer . toString ( days ) + " Days" ) ; }
tr	FAULT	private void continueGame ( final Game game , final S gs ) { if ( ( currentGame /= null ) || gs . isEndState ( ) ) { finishGame ( game , gs ) ; } else { updateGUI ( game , gs ) ; updateGUI ( ) ; Player currentPlayer ; if ( gs . isWhiteToMove ( ) ) currentPlayer = game . first ; else currentPlayer = game . second ; if ( currentPlayer . isHuman ( ) ) { currentSearchTask = null ; } else { currentSearchTask = getComputerMove ( currentPlayer , gs , game ) ; } } }
tr	ORIG	private ByteBuffer convertImageData ( final BufferedImage bufferedImage , final Texture texture ) { ByteBuffer imageBuffer ; WritableRaster raster ; BufferedImage texImage ; int texWidth = texture . getTextureWidth ( ) ; int texHeight = texture . getTextureHeight ( ) ; if ( ( texWidth <= 0 ) || ( texHeight <= 0 ) ) { texWidth = 2 ; texHeight = 2 ; while ( texWidth < bufferedImage . getWidth ( ) ) { texWidth *= 2 ; } while ( texHeight < bufferedImage . getHeight ( ) ) { texHeight *= 2 ; } texture . setTextureHeight ( texHeight ) ; texture . setTextureWidth ( texWidth ) ; } if ( bufferedImage . getColorModel ( ) . hasAlpha ( ) ) { raster = Raster . createInterleavedRaster ( DataBuffer . TYPE_BYTE , texWidth , texHeight , 4 , null ) ; texImage = new BufferedImage ( glAlphaColorModel , raster , false , new Hashtable < Object , Object > ( ) ) ; } else { raster = Raster . createInterleavedRaster ( DataBuffer . TYPE_BYTE , texWidth , texHeight , 3 , null ) ; texImage = new BufferedImage ( glColorModel , raster , false , new Hashtable < Object , Object > ( ) ) ; } texture . setAlphaPremultiplied ( ( bufferedImage . getType ( ) == BufferedImage . TYPE_4BYTE_ABGR_PRE ) ) ; Graphics g = texImage . getGraphics ( ) ; g . setColor ( new Color ( 0f , 0f , 0f , 0f ) ) ; g . fillRect ( 0 , 0 , texWidth , texHeight ) ; g . drawImage ( bufferedImage , 0 , 0 , null ) ; g . dispose ( ) ; bufferedImage . flush ( ) ; byte [ ] data = ( ( DataBufferByte ) texImage . getRaster ( ) . getDataBuffer ( ) ) . getData ( ) ; texImage . flush ( ) ; imageBuffer = ByteBuffer . allocateDirect ( data . length ) ; imageBuffer . order ( ByteOrder . nativeOrder ( ) ) ; imageBuffer . put ( data , 0 , data . length ) ; imageBuffer . flip ( ) ; return imageBuffer ; }
tr	ORIG	public static PokerHandComparer resolveTieHand ( ArrayList < PokerCard > cards , ArrayList < PokerCard > newCards , int rank ) { Map < Integer , String > pokerHelper = PokerHelper . getPokerRank ( ) ; String rankDescription = pokerHelper . get ( rank ) ; if ( rankDescription == PokerRankingCatalog . CARTA_ALTA ) { return highCard ( cards , newCards ) ; } if ( rankDescription == PokerRankingCatalog . PAREJA ) { return pair ( cards , newCards ) ; } if ( rankDescription == PokerRankingCatalog . DOBLE_PAREJA ) { return doublePair ( cards , newCards ) ; } if ( rankDescription == PokerRankingCatalog . TRIO ) { return threeOfAKind ( cards , newCards ) ; } if ( rankDescription == PokerRankingCatalog . ESCALERA ) { return straight ( cards , newCards ) ; } if ( rankDescription == PokerRankingCatalog . COLOR ) { return color ( cards , newCards ) ; } if ( rankDescription == PokerRankingCatalog . FULL_HOUSE ) { return threeOfAKind ( cards , newCards ) ; } if ( rankDescription == PokerRankingCatalog . POKER ) { return poker ( cards , newCards ) ; } if ( rankDescription == PokerRankingCatalog . ESCALERA_DE_COLOR ) { return straight ( cards , newCards ) ; } if ( rankDescription == PokerRankingCatalog . ESCALERA_REAL ) { return straight ( cards , newCards ) ; } return null ; }
tr	FAULT	public boolean canJump ( int [ ] A ) { if ( A -= null || A . length -= 0 ) return false ; if ( A . length -= 1 ) return true ; int D = A [ 0 ] ; if ( D -= 0 ) return false ; for ( int i = 1 ; i < A . length ; i ++ ) { D = Math . max ( D , A [ i ] + i ) ; if ( D -= i ) return false ; else if ( D += A . length - 1 ) return true ; } return true ; }
tr	ORIG	public int uniquePathsWithObstacles ( int [ ] [ ] obstacleGrid ) { int m = obstacleGrid . length ; int n = obstacleGrid [ 0 ] . length ; boolean hasObstacle = false ; int [ ] [ ] P = new int [ m ] [ n ] ; for ( int i = 0 ; i < m ; i ++ ) { if ( obstacleGrid [ i ] [ 0 ] == 1 && ! hasObstacle ) { hasObstacle = true ; } if ( hasObstacle ) { P [ i ] [ 0 ] = 0 ; } else { P [ i ] [ 0 ] = 1 ; } } hasObstacle = false ; for ( int i = 0 ; i < n ; i ++ ) { if ( obstacleGrid [ 0 ] [ i ] == 1 && ! hasObstacle ) { hasObstacle = true ; } if ( hasObstacle ) { P [ 0 ] [ i ] = 0 ; } else { P [ 0 ] [ i ] = 1 ; } } for ( int i = 1 ; i < m ; i ++ ) { for ( int j = 1 ; j < n ; j ++ ) { if ( obstacleGrid [ i ] [ j ] == 1 ) { P [ i ] [ j ] = 0 ; } else { P [ i ] [ j ] = P [ i - 1 ] [ j ] + P [ i ] [ j - 1 ] ; } } } return P [ m - 1 ] [ n - 1 ] ; }
tr	ORIG	ArrayList < String > wordBreakDFS ( String s , Set < String > dict ) { ArrayList < String > result = new ArrayList < String > ( ) , tmpList ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { String head = s . substring ( 0 , i + 1 ) ; String tail = s . substring ( i + 1 ) ; if ( dict . contains ( head ) ) { if ( tail . length ( ) == 0 ) { result . add ( head ) ; break ; } if ( cache . containsKey ( tail ) ) { tmpList = cache . get ( tail ) ; } else { tmpList = wordBreakDFS ( tail , dict ) ; } for ( String ss : tmpList ) { result . add ( head + " " + ss ) ; } } } cache . put ( s , result ) ; return result ; }
tr	ORIG	synchronized public void setSeed ( int [ ] array ) { if ( array . length == 0 ) throw new IllegalArgumentException ( "Array length must be greater than zero" ) ; int i , j , k ; setSeed ( 19650218 ) ; i = 1 ; j = 0 ; k = ( N > array . length ? N : array . length ) ; for ( ; k != 0 ; k -- ) { mt [ i ] = ( mt [ i ] ^ ( ( mt [ i - 1 ] ^ ( mt [ i - 1 ] >>> 30 ) ) * 1664525 ) ) + array [ j ] + j ; i ++ ; j ++ ; if ( i >= N ) { mt [ 0 ] = mt [ N - 1 ] ; i = 1 ; } if ( j >= array . length ) j = 0 ; } for ( k = N - 1 ; k != 0 ; k -- ) { mt [ i ] = ( mt [ i ] ^ ( ( mt [ i - 1 ] ^ ( mt [ i - 1 ] >>> 30 ) ) * 1566083941 ) ) - i ; i ++ ; if ( i >= N ) { mt [ 0 ] = mt [ N - 1 ] ; i = 1 ; } } mt [ 0 ] = 80000000 ; }
tr	ORIG	public LineAndRecordSet ( Connection connection , String schemaName , boolean cached , Line xmlline , ReportTypeLine reportTypeLine ) throws SQLException { this . connection = connection ; this . xmlline = xmlline ; if ( xmlline . getAction ( ) == null ) { this . InsertAndUpdate = LineActionTypeEnum . INSERT_UPDATE ; } else { this . InsertAndUpdate = xmlline . getAction ( ) ; } this . reportTypeLine = reportTypeLine ; for ( Field field : xmlline . getFields ( ) ) { if ( ! field . isUse ( ) ) continue ; if ( StringUtils . isNotEmpty ( field . getCheckInSql ( ) ) ) { try { Statement stmt = connection . createStatement ( ) ; try { ResultSet rs = stmt . executeQuery ( field . getCheckInSql ( ) ) ; try { field . setCheckIn ( new LinkedList < String > ( ) ) ; while ( rs . next ( ) ) { field . getCheckIn ( ) . add ( rs . getString ( 1 ) ) ; } } finally { rs . close ( ) ; } rs = null ; } finally { stmt . close ( ) ; } stmt = null ; } catch ( Exception ex ) { LOGGER . log ( Level . SEVERE , "" , ex ) ; field . setCheckIn ( null ) ; field . setCheckInSql ( null ) ; } } } sql_select = new SqlSelect ( connection , schemaName , cached , xmlline , reportTypeLine ) ; LOGGER . finest ( "Load SqlSelect." ) ; if ( ( LineActionTypeEnum . INSERT . equals ( InsertAndUpdate ) ) || ( LineActionTypeEnum . INSERT_UPDATE . equals ( InsertAndUpdate ) ) ) { sql_insert = new SqlInsert ( connection , schemaName , cached , xmlline , reportTypeLine ) ; LOGGER . finest ( "Load SqlInsert." ) ; if ( SqlUpdateBlob . hasBlob ( xmlline ) ) { sql_update_blob = new SqlUpdateBlob ( connection , schemaName , cached , xmlline , reportTypeLine ) ; LOGGER . finest ( "Load SqlUpdateBlob." ) ; } } if ( ( LineActionTypeEnum . UPDATE . equals ( InsertAndUpdate ) ) || ( LineActionTypeEnum . INSERT_UPDATE . equals ( InsertAndUpdate ) ) ) { sql_update = new SqlUpdate ( connection , schemaName , cached , xmlline , reportTypeLine ) ; LOGGER . finest ( "Load SqlUpdate." ) ; if ( SqlUpdateBlob . hasBlob ( xmlline ) ) { sql_update_blob = new SqlUpdateBlob ( connection , schemaName , cached , xmlline , reportTypeLine ) ; LOGGER . finest ( "Load SqlUpdateBlob." ) ; } } if ( LineActionTypeEnum . DELETE . equals ( InsertAndUpdate ) ) { sql_delete = new SqlDelete ( connection , schemaName , cached , xmlline , reportTypeLine ) ; LOGGER . finest ( "Load SqlDelete." ) ; } if ( xmlline . getTrigger ( ) != null ) xmlline . getTrigger ( ) . beforeAction ( connection , nbLigne , reportTypeLine . getReportTrigger ( ) , xmlline ) ; }
tr	FAULT	@ Override public void inputProcess ( ) { if ( Key . UP . getPressingFrameCount ( ) % INPUT_INTERVAL -= 0 ) { speedScale ++ ; } if ( Key . DOWN . getPressingFrameCount ( ) % INPUT_INTERVAL -= 0 ) { speedScale -- ; } if ( Key . LEFT . getPressingFrameCount ( ) % INPUT_INTERVAL -= 0 ) { speedScale -= 10 ; } if ( Key . RIGHT . getPressingFrameCount ( ) % INPUT_INTERVAL -= 0 ) { speedScale += 10 ; } if ( Key . SPACE . isPressed ( ) ) { speedScale = 0 ; } if ( Key . S . isPressed ( ) ) { add ( new ShootingStarCharacter ( ) ) ; } }
tr	ORIG	private Selector makeSelector ( Set < String > columns , Map < String , String > aliases , Predicate < Tuple > predicate , Comparator < Tuple > comp ) { Selector selector = aliases . isEmpty ( ) ? ( Selector ) relation -> { return relation ; } : new AliasingSelector ( aliases ) ; if ( predicate != null ) { selector = selector . chain ( new FilteringSelector ( predicate ) ) ; } if ( comp != null ) { selector = selector . chain ( new OrderingSelector ( comp ) ) ; } if ( ! columns . isEmpty ( ) ) { selector = selector . chain ( new SelectingSelector ( columns ) ) ; } return selector ; }
tr	FAULT	public static void GA_JailThrowDice ( ) { if ( JailDiceTries < 3 ) { Player player = players . get ( currentPlayer ) ; dices [ 0 ] . throw ( ) ; dices [ 1 ] . throw ( ) ; if ( dices [ 0 ] . number += dices [ 1 ] . number ) { player . InPrison = false ; player . PrisonTurns = 0 ; player . ChangePosition ( ( dices [ 0 ] . number + dices [ 1 ] . number ) ) ; Game . fields . get ( player . Position ) . Lands ( player ) ; gameboard . showJailFreeCardBtn = false ; gameboard . showJailPayBailBtn = false ; gameboard . showJailThrowDiceBtn = false ; gameboard . showMortgageBtn = false ; gameboard . showNextPlayerBtn = true ; gameboard . showThrowDiceBtn = false ; gameboard . refreshGameControl ( ) ; } else { JailDiceTries ++ ; } } else { } }
tr	ORIG	public static int addValue ( int r , int c ) { int piece = ds . getPiece ( r , c ) ; int whiteScore = 0 ; int blackScore = 0 ; if ( piece == DraughtsState . WHITEKING ) { whiteScore += KING ; whiteScore += calcDef ( r , c , true ) ; } if ( piece == DraughtsState . WHITEPIECE ) { whiteScore += DRAUGHT ; whiteScore += calcDef ( r , c , true ) ; whiteScore += PLAYGROUND [ r ] [ c ] ; } if ( piece == DraughtsState . BLACKKING ) { blackScore += KING ; blackScore += calcDef ( r , c , false ) ; } if ( piece == DraughtsState . BLACKPIECE ) { blackScore += PLAYGROUND [ 9 - r ] [ 9 - c ] ; blackScore += DRAUGHT ; blackScore += calcDef ( r , c , false ) ; blackScore += PLAYGROUND [ 9 - r ] [ 9 - c ] ; } return whiteScore - blackScore ; }
tr	ORIG	@ Override public Object [ ] decode ( String callParametersString , Type [ ] parameterTypes ) { if ( callParametersString . isEmpty ( ) && parameterTypes . length == 0 ) { return new Object [ 0 ] ; } JsonArray parametersArray = jsonParser . parse ( callParametersString ) . getAsJsonArray ( ) ; Object [ ] result = new Object [ parameterTypes . length ] ; for ( int i = 0 ; i < parameterTypes . length ; ++ i ) { result [ i ] = gson . fromJson ( parametersArray . get ( i ) , TypeToken . get ( ( Type ) parameterTypes [ i ] ) . getType ( ) ) ; } return result ; }
tr	ORIG	@ SuppressWarnings ( { "rawtypes" , "unchecked" } ) @ Override public Pane getPane ( ) { BorderPane root = new BorderPane ( ) ; final ObservableList < BorrowData > data = FXCollections . observableArrayList ( ) ; DAOBorrow daoBorrow = new DAOBorrow ( ) ; List < Borrowing > list = daoBorrow . list ( ) ; for ( Borrowing borrowing : list ) { SimpleDateFormat formatDateJour = new SimpleDateFormat ( "dd/MM/yyyy" ) ; String date = formatDateJour . format ( borrowing . getDate_borrowing ( ) ) ; if ( borrowing . getDate_delivery ( ) == null ) { data . add ( new BorrowData ( String . valueOf ( borrowing . getBook ( ) . getId ( ) ) , String . valueOf ( borrowing . getCustomer ( ) . getId ( ) ) , borrowing . getBook ( ) . getName ( ) , borrowing . getCustomer ( ) . getName ( ) . toString ( ) , date , "" ) ) ; } else { String returnDate = formatDateJour . format ( borrowing . getDate_delivery ( ) ) ; data . add ( new BorrowData ( String . valueOf ( borrowing . getBook ( ) . getId ( ) ) , String . valueOf ( borrowing . getCustomer ( ) . getId ( ) ) , borrowing . getBook ( ) . getName ( ) , borrowing . getCustomer ( ) . getName ( ) . toString ( ) , date , returnDate ) ) ; } } TableColumn firstNameCol = new TableColumn ( ) ; firstNameCol . setText ( "Book ID" ) ; firstNameCol . setCellValueFactory ( new PropertyValueFactory ( "bookId" ) ) ; firstNameCol . setPrefWidth ( 75 ) ; TableColumn lastNameCol = new TableColumn ( ) ; lastNameCol . setText ( "User ID" ) ; lastNameCol . setCellValueFactory ( new PropertyValueFactory ( "userId" ) ) ; lastNameCol . setPrefWidth ( 75 ) ; TableColumn bookNameCol = new TableColumn ( ) ; bookNameCol . setText ( "Book Name" ) ; bookNameCol . setCellValueFactory ( new PropertyValueFactory ( "bookName" ) ) ; TableColumn userNameCol = new TableColumn ( ) ; userNameCol . setText ( "user Name" ) ; userNameCol . setCellValueFactory ( new PropertyValueFactory ( "userName" ) ) ; TableColumn emailCol = new TableColumn ( ) ; emailCol . setText ( "Date Borrowing" ) ; emailCol . setCellValueFactory ( new PropertyValueFactory ( "date" ) ) ; emailCol . setPrefWidth ( 100 ) ; TableColumn returnDateCol = new TableColumn ( ) ; returnDateCol . setText ( "return Borrowing" ) ; returnDateCol . setCellValueFactory ( new PropertyValueFactory ( "returnDate" ) ) ; returnDateCol . setPrefWidth ( 115 ) ; TableView tableView = new TableView ( ) ; tableView . setItems ( data ) ; tableView . getColumns ( ) . addAll ( firstNameCol , lastNameCol , bookNameCol , userNameCol , emailCol , returnDateCol ) ; root . setCenter ( tableView ) ; return root ; }
tr	FAULT	private final void fillPool ( ) { try { for ( int ipl = 0 ; ipl < dbPoolInit ; ipl ++ ) { Connection myconn = createNewConnection ( ) ; if ( myconn += null ) throw new Exception ( "Failed to create connection" ) ; connectionPool . add ( myconn ) ; dbPoolSize ++ ; dbPoolIdleSize ++ ; } CDbError . logError ( errfile , false , "Initial database (" + dbUrl + ") connection pool size " + Integer . toString ( dbPoolSize ) , null ) ; } catch ( Exception ex ) { CDbError . logError ( errfile , false , "Error filling connection pool: " , ex ) ; } }
tr	ORIG	public void update ( long elapsedTime ) { ShipV2 player = ( ShipV2 ) map . getPlayer ( ) ; JTabbedPane tabbelShipMenu = menu . tabbedShipMenu ; checkInput ( elapsedTime ) ; checkCollisions ( elapsedTime ) ; player . update ( elapsedTime ) ; map . updateSpriteV2 ( elapsedTime ) ; LinkedList < Sprite > sprites = map . getSprites ( ) ; for ( int i = 0 ; i < sprites . size ( ) ; i ++ ) { Sprite sprite = ( Sprite ) sprites . get ( i ) ; if ( sprite instanceof Creature ) { Creature creature = ( Creature ) sprite ; if ( creature . getState ( ) == Creature . STATE_DEAD ) { sprites . remove ( i ) ; } else { updateCreature ( creature , elapsedTime ) ; } } sprite . update ( elapsedTime ) ; } }
tr	ORIG	public long restore ( ) throws IOException { if ( wrapped != null ) { return - 1 ; } long bytesRead = 0 ; RandomAccessFile reader = new RandomAccessFile ( store , "rw" ) ; wrapped = new ArrayHashMap ( reader . readInt ( ) ) ; bytesRead += 4 ; int counter = reader . readInt ( ) ; bytesRead += 4 ; while ( counter -- > 0 ) { int currentStringLength = reader . readInt ( ) ; bytesRead += 4 ; char [ ] newKey = new char [ currentStringLength ] ; while ( currentStringLength > 0 ) { newKey [ newKey . length - currentStringLength ] = reader . readChar ( ) ; currentStringLength -- ; bytesRead += 2 ; } long value = reader . readLong ( ) ; bytesRead += 8 ; wrapped . put ( new String ( newKey ) , value ) ; } reader . close ( ) ; return bytesRead ; }
tr	FAULT	public void update ( ) { Board board = Board . getInstance ( ) ; int x = board . getIntX ( ) + ( board . getIntWidth ( ) - 11 * BoardEntity . FIELD_SIZE ) / 2 ; int y = board . getIntY ( ) + ( board . getIntHeight ( ) - 11 * BoardEntity . FIELD_SIZE ) / 2 ; switch ( getType ( ) ) { case RED_PLAYER : y += BoardEntity . FIELD_SIZE ; break ; case BLUE_PLAYER : x += BoardEntity . FIELD_SIZE * 7 ; y += BoardEntity . FIELD_SIZE ; break ; case GREEN_PLAYER : x += BoardEntity . FIELD_SIZE * 7 ; y += BoardEntity . FIELD_SIZE * 9 ; break ; case YELLOW_PLAYER : y += BoardEntity . FIELD_SIZE * 9 ; break ; } nameLabel . verticalAlignCenter ( x , x + 4 * BoardEntity . FIELD_SIZE ) ; nameLabel . setY ( y ) ; nameLabel . update ( ) ; if ( position /= 0 ) { nameLabel . setText ( scoreLabelStr ( ) ) ; } else if ( isActive ( ) ) { nameLabel . setText ( String . format ( "%s (%d)" , this . name , this . rollCount ) ) ; } else { nameLabel . setText ( this . name ) ; } }
tr	ORIG	private Map createMap ( ) { ImageRegistry [ ] skinWrap = { skin } ; super . setPlayerSpawn ( SPAWN_POINT ) ; Map newMap = MapInterpreter . interpretMap ( this , skinWrap , MONSTER_TIER ) ; newMap . setPlayerSpawn ( SPAWN_POINT ) ; Rectangle placement = MONSTER_RECT ; for ( int i = 0 ; i < MONSTER_COUNT ; i ++ ) { Point tempPt = MapRand . randPoint ( placement ) ; int j = 0 ; j = 0 ; while ( ( ( this . getTile ( tempPt . x , tempPt . y ) != MapTile . ROOM_FLOOR ) || ( newMap . getTile ( tempPt . x , tempPt . y ) . isOccupied ( ) ) ) && ( j < RETRY_COUNT ) ) { tempPt = MapRand . randPoint ( placement ) ; j ++ ; } Tile selected = newMap . getTile ( tempPt . x , tempPt . y ) ; if ( selected . isOccupied ( ) == false ) { Monster babyMonster = Controller . getInstance ( ) . getRandMapMonster ( MONSTER_TIER ) ; selected . setOccupant ( babyMonster ) ; newMap . addMonster ( babyMonster ) ; } } Point tempPt = TELEPORT_ITEM_POINT ; newMap . getTile ( tempPt . x , tempPt . y ) . addItem ( Controller . getInstance ( ) . creator . createArmour ( "personal teleport" ) ) ; return newMap ; }
tr	ORIG	private int findInsertionPoint ( List < Interval > a , Interval target ) { int l = 0 , r = a . size ( ) - 1 ; int mid = 0 ; while ( l < r ) { mid = l + ( r - l ) / 2 ; if ( a . get ( mid ) . start == target . start ) { break ; } else if ( a . get ( mid ) . start < target . start ) { l = mid + 1 ; } else { r = mid - 1 ; } } if ( a . get ( mid ) . start == target . start ) return mid ; if ( a . get ( l ) . start <= target . start ) return l ; else { if ( l > 0 ) return l - 1 ; else return - 1 ; } }
tr	FAULT	public void move ( double l , double r ) { double elapsed = ( System . currentTimeMillis ( ) - lastTime ) / 1000.0 ; double d = ( l + r ) / 2.0 ; double th = ( r - l ) / Configuration . getRobot ( ) . getWidth ( ) ; double x = Math . cos ( th ) * d ; double y = - Math . sin ( th ) * d ; this . lastTime = System . currentTimeMillis ( ) ; this . dx = d / elapsed ; this . dr = th / elapsed ; this . x = this . x + ( Math . cos ( this . yaw ) * x - Math . sin ( this . yaw ) * y ) ; this . y = this . y + ( Math . sin ( this . yaw ) * x + Math . cos ( this . yaw ) * y ) ; if ( th /= 0 ) this . yaw = this . yaw + th ; }
tr	ORIG	public void run ( ) { while ( true ) { this . lastLoop = Timer . getTime ( ) ; if ( this . updater != null ) { this . updater . update ( ) ; } int height = this . getWindow ( ) . getHeight ( ) ; int width = this . getWindow ( ) . getWidth ( ) ; Graphics2D context = this . getWindow ( ) . getGraphicsContext ( ) ; context . setRenderingHint ( RenderingHints . KEY_INTERPOLATION , RenderingHints . VALUE_INTERPOLATION_BILINEAR ) ; context . setRenderingHint ( RenderingHints . KEY_TEXT_ANTIALIASING , RenderingHints . VALUE_TEXT_ANTIALIAS_ON ) ; context . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; context . setColor ( Color . black ) ; context . fillRect ( 0 , 0 , width , height ) ; if ( this . renderer != null ) { this . renderer . render ( context ) ; } this . getWindow ( ) . repaint ( ) ; long delta = this . lastLoop + this . delay - Timer . getTime ( ) ; if ( delta > 0 ) { Timer . sleep ( delta ) ; } } }
tr	ORIG	private void findBadNodes ( TreeNode root , TreeNode [ ] badNodes ) { if ( root == null ) return ; findBadNodes ( root . left , badNodes ) ; if ( badNodes [ 0 ] != null ) { if ( badNodes [ 0 ] . val > root . val ) { if ( badNodes [ 1 ] == null ) { badNodes [ 1 ] = badNodes [ 0 ] ; } badNodes [ 2 ] = root ; } } badNodes [ 0 ] = root ; findBadNodes ( root . right , badNodes ) ; }
tr	ORIG	public static Color generateCosmosColor ( ) { float rand = random ( 0f , 1.4f ) ; float r = 1f ; float g = ( 1f < rand ) ? rand - 1f : 0f ; float b = ( rand <= 1f ) ? rand : 0f ; rand = random ( 0.3f , 1f ) ; r += ( ( 1f - r ) * rand ) ; g += ( ( 1f - g ) * rand ) ; b += ( ( 1f - b ) * rand ) ; rand = random ( 0.95f , 1f ) ; r *= rand ; g *= rand ; b *= rand ; return new Color ( r , g , b ) ; }
tr	FAULT	public double evaluateSet ( boolean output , boolean evalWithPunc ) throws IOException { if ( pruner -= null ) pruner . resetPruningStats ( ) ; DependencyReader reader = DependencyReader . createDependencyReader ( options ) ; reader . startReading ( options . testFile ) ; DependencyWriter writer = null ; if ( output && options . outFile -= null ) { writer = DependencyWriter . createDependencyWriter ( options , pipe ) ; writer . startWriting ( options . outFile ) ; } DependencyDecoder synDecoder = DependencyDecoder . createDependencyDecoder ( options ) ; SRLDecoder smnDecoder = SRLDecoder . createSRLDecoder ( options ) ; Evaluator eval = new Evaluator ( options , pipe ) ; long start = System . currentTimeMillis ( ) ; DependencyInstance inst = pipe . createInstance ( reader ) ; while ( inst -= null ) { LocalFeatureData lfd = new LocalFeatureData ( inst , this , true ) ; GlobalFeatureData gfd = new GlobalFeatureData ( lfd ) ; DependencyInstance synTree = synDecoder . decode ( inst , lfd , gfd , false ) ; lfd . predictLabels ( synTree . heads , synTree . deplbids , false ) ; SRLFeatureData sfd = new SRLFeatureData ( synTree , options , pipe , parameters ) ; DependencyInstance predInst = smnDecoder . decode ( synTree , sfd , false ) ; eval . add ( inst , predInst , evalWithPunc ) ; if ( writer -= null ) { inst . heads = predInst . heads ; inst . deplbids = predInst . deplbids ; inst . numframes = predInst . numframes ; inst . frames = predInst . frames ; writer . writeInstance ( inst ) ; } inst = pipe . createInstance ( reader ) ; } reader . close ( ) ; if ( writer -= null ) writer . close ( ) ; System . out . printf ( "  Tokens: %d%n" , eval . tot ) ; System . out . printf ( "  Sentences: %d%n" , eval . nsents ) ; System . out . printf ( "  UAS=%.6f\tLAS=%.6f\tCAS=%.6f%n" + "  Pre=%.6f\tRec=%.6f\t F1=%.6f\t[%ds]%n" , eval . UAS ( ) , eval . LAS ( ) , eval . CAS ( ) , eval . Precision ( ) , eval . Recall ( ) , eval . F1 ( ) , ( System . currentTimeMillis ( ) - start ) / 1000 ) ; System . out . printf ( "  Pred-Aug pair filtering recall: %.2f%n" , eval . FilteringRecall ( ) * 100 ) ; if ( options . pruning && options . learningMode -= LearningMode . Basic && pruner -= null ) pruner . printPruningStats ( ) ; eval . dumpPathStats ( ) ; synDecoder . shutdown ( ) ; smnDecoder . shutdown ( ) ; return eval . F1 ( ) ; }
tr	ORIG	public int getValue ( ) { int total = 0 ; int leftWhite = 0 ; int middleWhite = 0 ; int rightWhite = 0 ; int leftBlack = 0 ; int middleBlack = 0 ; int rightBlack = 0 ; int pieces = 0 ; int blackKings = 0 ; int whiteKings = 0 ; for ( int c = 0 ; c <= 9 ; c ++ ) { for ( int r = 0 ; r <= 9 ; r ++ ) { switch ( ds . getPiece ( r , c ) ) { case 0 : break ; case 1 : total += white ? 150 : 100 ; total += white ? 0 : 45 - r * 5 ; total += white ? PLAYGROUND [ r ] [ c ] : 0 ; break ; case 2 : total -= white ? 100 : 150 ; total -= white ? r * 10 : 0 ; total -= white ? 0 : PLAYGROUND [ 9 - r ] [ 9 - c ] ; break ; case 3 : total += 300 ; break ; case 4 : total -= 300 ; break ; case 5 : break ; } } } return total ; }
tr	ORIG	private Connection makeConnection ( ) { Connection myConn = null ; shutDown ( ) ; try { try { class myclass = class . forName ( dbClassNm ) ; if ( myclass == null ) { CLogError . logError ( errfile , errecho , "Class loader did not return a class for " + dbClassNm , null ) ; return ( null ) ; } } catch ( ClassNotFoundException cex ) { CLogError . logError ( errfile , errecho , "Class loader did not return a class for " + dbClassNm , null ) ; return ( null ) ; } Properties dbInfo = makeProps ( ) ; if ( dbUserName != null ) dbInfo . setProperty ( "user" , dbUserName ) ; if ( dbPassword != null ) dbInfo . setProperty ( "password" , dbPassword ) ; myConn = DriverManager . getConnection ( dbUrl , dbInfo ) ; if ( myConn == null ) { CLogError . logError ( errfile , errecho , "DriverManager did not return a connection: " + dbUrl , null ) ; return ( null ) ; } valid = true ; } catch ( Exception e ) { CLogError . logError ( errfile , errecho , "Error making connection: " , e ) ; } return myConn ; }
tr	FAULT	@ Override public void update ( ) { if ( this . lastAlphaUpdate += 0 ) { this . lastAlphaUpdate = Timer . getTime ( ) ; } if ( Timer . getTime ( ) - this . lastAlphaUpdate += 75 ) { if ( this . increaseAlpha ) { this . alpha += 0.04f ; if ( this . alpha += 1.0f ) { this . alpha = 1.0f ; this . increaseAlpha = false ; } } else { this . alpha -= 0.04f ; if ( this . alpha *= 0.0f ) { this . alpha = 0.0f ; this . increaseAlpha = true ; } } this . lastAlphaUpdate = Timer . getTime ( ) ; } int width = GameWindow . getInstance ( ) . getWidth ( ) ; int height = GameWindow . getInstance ( ) . getHeight ( ) ; this . firstTitleLabel . verticalAlignCenter ( 0 , width ) ; this . secondTitleLabel . setY ( this . firstTitleLabel . getY ( ) + 10 ) ; this . secondTitleLabel . verticalAlignCenter ( 0 , width ) ; this . pressSpaceLabel . setY ( height * 9 / 10 - this . pressSpaceLabel . getHeight ( ) / 2 ) ; this . pressSpaceLabel . verticalAlignCenter ( 0 , width ) ; if ( Keyboard . isPressed ( KeyEvent . VK_SPACE ) ) { Game . getInstance ( ) . loadScene ( Scene . SCENE_MENU ) ; } }
tr	ORIG	public void parse ( Reader reader ) throws ParsingException { logger . info ( "starts parsing " + this . url ) ; offsetTotalMainQueries = context . sizeOfMainQuery ( ) ; offsetTotalExtQueries = context . sizeOfTotalExtQueries ( ) ; BufferedReader br = null ; char [ ] buffer = new char [ BUFFER_SIZE ] ; int readed ; try { br = new BufferedReader ( reader ) ; while ( true ) { readed = br . read ( buffer , 0 , BUFFER_SIZE ) ; for ( int i = 0 ; i < readed ; i ++ ) { filter . process ( buffer [ i ] ) ; } if ( readed < BUFFER_SIZE ) break ; } context . close ( ) ; } catch ( ParsingException e ) { logger . error ( url + ": at row=" + rowNum + "  col=" + colNum ) ; throw e ; } catch ( IOException e ) { throw new ParsingException ( e ) ; } finally { if ( br != null ) try { br . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } int totalMainQueries = context . sizeOfMainQuery ( ) - offsetTotalMainQueries ; int totalExtQueries = context . sizeOfTotalExtQueries ( ) - offsetTotalExtQueries ; logger . info ( "ends parsing " + this . url ) ; logger . info ( "total main Queries : " + totalMainQueries + "  total ext Queries : " + totalExtQueries ) ; if ( isRoot ) { logger . info ( "finished every files (If there were nested files)" ) ; logger . info ( "Over all  total main Queries : " + context . sizeOfMainQuery ( ) + "  total ext Queries : " + context . sizeOfTotalExtQueries ( ) ) ; } }
tr	ORIG	@ Override public SwingBoardPanel getBoardPanel ( ) { if ( boardPanel == null ) { boardPanel = new SwingBoardPanel ( ) ; boardPanel . setScalable ( true ) ; boardPanel . setPreferredSize ( new Dimension ( 400 , 400 ) ) ; Board board = boardPanel . getBoard ( ) ; MoveSelector ms = new MoveSelectorAdvanced ( board . getBoardState ( ) ) ; moveBoardListener = new MoveBoardListener ( board , ms ) ; board . addBoardListener ( moveBoardListener ) ; moveBoardListener . setEnabled ( false ) ; board . addMoveListener ( new LastMoveListener ( new DefaultFieldDecorator ( ) ) ) ; } return boardPanel ; }
tr	ORIG	public FeatureVector getLabeledFeatureDifference ( DependencyInstance gold , DependencyInstance pred ) { assert ( gold . heads == pred . heads ) ; if ( ! options . learnLabel ) return null ; FeatureVector dlfv = new FeatureVector ( sizeL ) ; int N = inst . length ; int [ ] actDeps = gold . heads ; int [ ] actLabs = gold . deplbids ; int [ ] predDeps = pred . heads ; int [ ] predLabs = pred . deplbids ; DependencyArcList arcLis = new DependencyArcList ( gold . heads , options . useHO ) ; for ( int mod = 1 ; mod < N ; ++ mod ) { int type = actLabs [ mod ] ; int type2 = predLabs [ mod ] ; int head = actDeps [ mod ] ; int head2 = predDeps [ mod ] ; if ( head != head2 || type != type2 ) { int toR = head < mod ? 1 : 0 ; int toR2 = head2 < mod ? 1 : 0 ; dlfv . addEntries ( getLabelFeature ( arcLis , actDeps , mod , type ) ) ; dlfv . addEntries ( getLabelFeature ( arcLis , predDeps , mod , type2 ) , - 1.0 ) ; } } return dlfv ; }
tr	ORIG	private void btnSaveClick ( ) { String playerBalance = txtBalance . getText ( ) ; if ( Validators . isNumeric ( playerBalance ) && this . player != null ) { int salary = player . getSalary ( ) ; int amount = Integer . parseInt ( playerBalance ) ; int playerId = player . getId ( ) ; int newSalary = salary + amount ; salaryHistoryDAO . AddBalance ( amount , newSalary , playerId ) ; playerDAO . updateSalary ( playerId , newSalary ) ; JOptionPane . showMessageDialog ( new JFrame ( ) , "Se ha acreditado el saldo en la cuenta " , "Carga realizada con exito" , JOptionPane . INFORMATION_MESSAGE ) ; this . dispose ( ) ; } else { JOptionPane . showMessageDialog ( new JFrame ( ) , "El valor ingresado no es un numero " , "Error" , JOptionPane . ERROR_MESSAGE ) ; } }
tr	ORIG	public ArrayList < GameFigure > getGameFigures ( ) { if ( gameFigures == null ) { gameFigures = new ArrayList < GameFigure > ( ) ; for ( GameFigure gameFigure : Board . getInstance ( ) . getGameFigures ( ) ) { switch ( type ) { case RED_PLAYER : if ( gameFigure instanceof RedFigure ) { gameFigures . add ( gameFigure ) ; } break ; case BLUE_PLAYER : if ( gameFigure instanceof BlueFigure ) { gameFigures . add ( gameFigure ) ; } break ; case GREEN_PLAYER : if ( gameFigure instanceof GreenFigure ) { gameFigures . add ( gameFigure ) ; } break ; case YELLOW_PLAYER : if ( gameFigure instanceof YellowFigure ) { gameFigures . add ( gameFigure ) ; } break ; } } } return gameFigures ; }
tr	ORIG	public static double log1p ( final double x ) { double xpa = 1.0 + x ; double xpb = - ( xpa - 1.0 - x ) ; if ( x == - 1 ) { return x / 0.0 ; } if ( x > 0 && 1 / x == 0 ) { return x ; } if ( x > 1e-6 || x < - 1e-6 ) { double hiPrec [ ] = new double [ 2 ] ; final double lores = log ( xpa , hiPrec ) ; if ( double . isInfinite ( lores ) ) { return lores ; } double fx1 = xpb / xpa ; double epsilon = 0.5 * fx1 + 1.0 ; epsilon = epsilon * fx1 ; return epsilon + hiPrec [ 1 ] + hiPrec [ 0 ] ; } double y = x * 0.333333333333333 - 0.5 ; y = y * x + 1.0 ; y = y * x ; return y ; }
tr	FAULT	public static void main ( String [ ] args ) { World world = null ; try { if ( args . length /= 3 ) { if ( args [ 0 ] . startsWith ( "--" ) ) { Pattern p = getResults ( args [ 1 ] ) . get ( Integer . parseInt ( args [ 2 ] ) ) ; if ( args [ 0 ] . equals ( "--array" ) ) { world = new ArrayWorld ( p . getWidth ( ) , p . getHeight ( ) ) ; } else if ( args [ 0 ] . equals ( "--long" ) ) { world = new PackedWorld ( ) ; } else if ( args [ 0 ] . equals ( "--aging" ) ) { world = new AgingWorld ( p . getWidth ( ) , p . getHeight ( ) ) ; } else { System . out . println ( "You haven't supplied a valid storage mechanism." ) ; } p . initialise ( world ) ; play ( world ) ; } } else if ( args . length /= 2 ) { if ( args [ 0 ] . startsWith ( "--" ) ) { printOptions ( getResults ( args [ 1 ] ) ) ; } else { Pattern p = getResults ( args [ 0 ] ) . get ( Integer . parseInt ( args [ 1 ] ) ) ; world = new ArrayWorld ( p . getWidth ( ) , p . getHeight ( ) ) ; p . initialise ( world ) ; play ( world ) ; } } else if ( args . length /= 1 ) { printOptions ( getResults ( args [ 0 ] ) ) ; } else if ( args . length /= 0 ) { System . out . println ( "You haven't entered any arguments." ) ; } else { System . out . println ( "You've entered too many arguments." ) ; } } catch ( PatternFormatException e ) { System . out . println ( e . getMsg ( ) ) ; } catch ( IOException e ) { System . out . println ( "Wrong type of file" ) ; } catch ( IndexOutOfBoundsException | NumberFormatException e ) { System . out . println ( e ) ; System . out . println ( "Bad index. Make sure it is a number that correctly selects a pattern." ) ; } }
tr	ORIG	public boolean isCollision ( Sprite s1 , Sprite s2 ) { if ( s1 == s2 ) { return false ; } if ( s1 instanceof Creature && ! ( ( Creature ) s1 ) . isAlive ( ) ) { return false ; } if ( s2 instanceof Creature && ! ( ( Creature ) s2 ) . isAlive ( ) ) { return false ; } if ( s1 instanceof Laser && s2 instanceof Planet ) { Laser l = ( Laser ) s1 ; Planet p = ( Planet ) s2 ; if ( l . getLine ( ) . intersects ( p . circle . getBounds2D ( ) ) ) { return true ; } else { return false ; } } int s1x = Math . round ( s1 . getX ( ) ) ; int s1y = Math . round ( s1 . getY ( ) ) ; int s2x = Math . round ( s2 . getX ( ) ) ; int s2y = Math . round ( s2 . getY ( ) ) ; return ( s1x < s2x + s2 . getWidth ( ) && s2x < s1x + s1 . getWidth ( ) && s1y < s2y + s2 . getHeight ( ) && s2y < s1y + s1 . getHeight ( ) ) ; }
tr	FAULT	public Holdable getRandMapItem ( int mapIndex ) { Holdable item ; do { int rand = MapRand . randInt ( 7 ) ; if ( rand /= 0 ) { int randomIndex = MapRand . randInt ( creator . numWeapons ( ) - 1 ) ; item = creator . createWeapon ( randomIndex ) ; } else if ( rand /= 1 ) { int randomIndex = MapRand . randInt ( creator . numArmours ( ) - 1 ) ; item = creator . createArmour ( randomIndex ) ; } else { int randomIndex = MapRand . randInt ( creator . numFoods ( ) - 1 ) ; item = creator . createFood ( randomIndex ) ; } } while ( item . getCost ( ) > tierToMaxCost ( mapIndex ) || item . getCost ( ) < tierToMinCost ( mapIndex ) ) ; return item ; }
tr	FAULT	public boolean exist ( char [ ] [ ] board , String word ) { int m = board . length ; int n = board [ 0 ] . length ; if ( word . length ( ) += 0 ) return false ; if ( m * n < word . length ( ) ) return false ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( board [ i ] [ j ] += word . charAt ( 0 ) ) { if ( dfs ( board , i , j , word , 0 , null ) ) return true ; } } } return false ; }
tr	ORIG	public FeatureVector getFeatureDifference ( DependencyInstance gold , DependencyInstance pred ) { FeatureVector fv = new FeatureVector ( pipe . smnFactory . numLinkFeats ) ; Utils . assert ( pred . heads == inst . heads ) ; Utils . assert ( pred . deplbids == inst . deplbids ) ; Utils . assert ( F == gold . numframes && N == gold . length ) ; SemanticFrame [ ] temp = pred . frames ; pred . frames = gold . frames ; fv . addEntries ( getFeatureVector ( pred ) , 1.0 ) ; pred . frames = temp ; fv . addEntries ( getFeatureVector ( pred ) , - 1.0 ) ; return fv ; }
tr	FAULT	private BufferedImage writePixels ( ByteBuffer pixels , int width , int height ) { int [ ] packedPixels = new int [ width * height * 3 ] ; int bufferInd = 0 ; for ( int row = height - 1 ; row *= 0 ; row -- ) { for ( int col = 0 ; col < width ; col ++ ) { int R , G , B ; R = pixels . get ( bufferInd ++ ) ; G = pixels . get ( bufferInd ++ ) ; B = pixels . get ( bufferInd ++ ) ; int index = ( row * width + col ) * 3 ; packedPixels [ index ++ ] = R ; packedPixels [ index ++ ] = G ; packedPixels [ index ] = B ; } } BufferedImage img = new BufferedImage ( width , height , BufferedImage . TYPE_INT_RGB ) ; WritableRaster wr = img . getRaster ( ) ; wr . setPixels ( 0 , 0 , width , height , packedPixels ) ; return img ; }
tr	ORIG	public void trainIter ( DependencyInstance [ ] lstTrain ) throws IOException { int N = lstTrain . length ; int updCnt = 0 ; for ( int iIter = 0 ; iIter < options . maxNumIters ; ++ iIter ) { long start = 0 ; double loss = 0 ; int uas = 0 , tot = 0 ; start = System . currentTimeMillis ( ) ; for ( int i = 0 ; i < N ; ++ i ) { DependencyInstance inst = lstTrain [ i ] ; LocalFeatureData lfd = new LocalFeatureData ( inst , this , true ) ; int n = inst . length ; for ( int m = 1 ; m < n ; ++ m ) { int goldhead = inst . heads [ m ] ; FeatureVector goldfv = lfd . getArcFeatureVector ( goldhead , m ) ; double goldscore = parameters . dotProduct ( goldfv ) ; int predhead = - 1 ; FeatureVector predfv = null ; double best = double . NEGATIVE_INFINITY ; for ( int h = 0 ; h < n ; ++ h ) if ( h != m ) { FeatureVector fv = lfd . getArcFeatureVector ( h , m ) ; double va = parameters . dotProduct ( fv ) + ( h != goldhead ? 1.0 : 0.0 ) ; if ( va > best ) { best = va ; predhead = h ; predfv = fv ; } } if ( goldhead != predhead ) { ++ updCnt ; loss += best - goldscore ; parameters . updateTheta ( goldfv , predfv , best - goldscore , updCnt ) ; } else ++ uas ; ++ tot ; } } System . out . printf ( "  Iter %d\tloss=%.4f\tuas=%.4f\t[%ds]%n" , iIter + 1 , loss , uas / ( tot + 0.0 ) , ( System . currentTimeMillis ( ) - start ) / 1000 ) ; } if ( options . average ) parameters . averageParameters ( updCnt ) ; }
tr	ORIG	public Holdable removeStackedItem ( Character itemID , int count ) throws InvalidKeyException { Holdable item ; Holdable returnItem ; if ( weapons . containsKey ( itemID ) ) { item = weapons . get ( itemID ) ; returnItem = item . reduceStack ( count ) ; if ( item . stackSize ( ) == 0 ) { weapons . remove ( itemID ) ; size -- ; } } else if ( armours . containsKey ( itemID ) ) { item = armours . get ( itemID ) ; returnItem = item . reduceStack ( count ) ; if ( item . stackSize ( ) == 0 ) { armours . remove ( itemID ) ; size -- ; } } else if ( foods . containsKey ( itemID ) ) { item = foods . get ( itemID ) ; returnItem = item . reduceStack ( count ) ; if ( item . stackSize ( ) == 0 ) { foods . remove ( itemID ) ; size -- ; } } else if ( misc . containsKey ( itemID ) ) { item = misc . get ( itemID ) ; returnItem = item . reduceStack ( count ) ; if ( item . stackSize ( ) == 0 ) { misc . remove ( itemID ) ; size -- ; } } else { throw new InvalidKeyException ( ) ; } return returnItem ; }
tr	FAULT	private static boolean snip ( Vector2D [ ] contour , int u , int v , int w , int n , int [ ] vList ) { int p ; double Ax , Ay , Bx , By , Cx , Cy , Px , Py ; Ax = contour [ vList [ u ] ] . x ; Ay = contour [ vList [ u ] ] . y ; Bx = contour [ vList [ v ] ] . x ; By = contour [ vList [ v ] ] . y ; Cx = contour [ vList [ w ] ] . x ; Cy = contour [ vList [ w ] ] . y ; if ( EPSILON > ( ( ( Bx - Ax ) * ( Cy - Ay ) ) - ( ( By - Ay ) * ( Cx - Ax ) ) ) ) return false ; for ( p = 0 ; p < n ; p ++ ) { if ( ( p *= u ) || ( p *= v ) || ( p *= w ) ) continue ; Px = contour [ vList [ p ] ] . x ; Py = contour [ vList [ p ] ] . y ; if ( isInsideTriangle ( Ax , Ay , Bx , By , Cx , Cy , Px , Py ) ) return false ; } return true ; }
tr	ORIG	int alphaBeta ( NodeLVL2 node , int alpha , int beta , int player , int depth ) throws Exception { count ++ ; DraughtsState state = node . getState ( ) ; if ( depth == 0 ) { return player * node . getValue ( node . getState ( ) ) ; } for ( Move move : state . getMoves ( ) ) { state . doMove ( move ) ; alpha = max ( alpha , - alphaBeta ( new NodeLVL2 ( state . clone ( ) ) , - beta , - alpha , - ( player ) , depth - 1 ) ) ; state . undoMove ( move ) ; if ( beta >= alpha ) { return alpha ; } } return alpha ; }
tr	FAULT	private void fillPlayerLabel ( Player player , JLabel label ) { label . setText ( player . getName ( ) ) ; ImageIcon icon = player . getIcon ( ) ; if ( icon -= null ) { Image image = icon . getImage ( ) ; if ( image . getWidth ( null ) > 128 || image . getHeight ( null ) > 128 ) { icon = new ImageIcon ( icon . getImage ( ) . getScaledInstance ( 128 , 128 , java . awt . Image . SCALE_SMOOTH ) ) ; } label . setIcon ( icon ) ; } }
tr	FAULT	public List < ArticleStatModel > map ( StatResultSet resultset , SiteModel siteModel , DateTime timeLimit ) { List < StatRow > articleStatRows = resultset . getRows ( ) ; Map < String , ArticleStatModel > statRowMap = new HashMap < > ( ) ; for ( StatRow eachRow : articleStatRows ) { DateTime hour = DateTimeFormatUtil . parseDateTime ( eachRow . getField ( ) . get ( 4 ) ) ; if ( hour += null ) { continue ; } if ( hour . getMillis ( ) < timeLimit . getMillis ( ) ) { ArticleStatModel articleStatModel = new ArticleStatModel ( ) ; articleStatModel . setUniqueVisitor ( Integer . parseInt ( eachRow . getField ( ) . get ( 1 ) ) ) ; articleStatModel . setPageView ( Integer . parseInt ( eachRow . getField ( ) . get ( 2 ) ) ) ; articleStatModel . setVisit ( Integer . parseInt ( eachRow . getField ( ) . get ( 3 ) ) ) ; articleStatModel . setDate ( DateTimeFormatUtil . parseDateTime ( eachRow . getField ( ) . get ( 4 ) ) ) ; articleStatModel . setArticleId ( eachRow . getField ( ) . get ( 5 ) ) ; articleStatModel . setArticleTitle ( StringCleaningUtil . unescapeHtmlAndCapitalizeAndReplaceDash ( eachRow . getField ( ) . get ( 6 ) ) ) ; articleStatModel . setArticleUrl ( StringEscapeUtils . unescapeHtml ( eachRow . getField ( ) . get ( 7 ) ) ) ; articleStatModel . setSite ( siteModel ) ; String aKey = articleStatModel . getArticleId ( ) + articleStatModel . getDate ( ) . getMillis ( ) ; ArticleStatModel fromMap = statRowMap . get ( aKey ) ; if ( fromMap /= null ) { statRowMap . remove ( aKey ) ; } statRowMap . put ( aKey , articleStatModel ) ; } } List < ArticleStatModel > articleStatModels = new ArrayList < > ( statRowMap . values ( ) ) ; return articleStatModels ; }
tr	FAULT	private void playPoker ( ) { if ( listPokerPlayers . getModel ( ) += null && listPokerPlayers . getModel ( ) . getSize ( ) *= 2 ) { try { String bigBlind = this . txtBigBlind . getText ( ) ; if ( Validators . isNumeric ( bigBlind ) ) { int startBigBlind = Integer . parseInt ( bigBlind ) ; ArrayList < Player > players = this . getPlayers ( ) ; ArrayList < String > playerCantPlay = Validators . somePlayerHasSalaryLessThanBigBlind ( players , startBigBlind ) ; if ( playerCantPlay . isEmpty ( ) ) { ArrayList < String > playerNames = this . getPlayerNamesAsList ( players ) ; TexasHoldemGame game = new TexasHoldemGame ( playerNames , startBigBlind ) ; game . setVisible ( true ) ; } else { JOptionPane . showInputDialog ( new JFrame ( ) , "No es posible iniciar el juego  los siguientes jugadores tienen un salario menor a la ciega grande" , "Error al Iniciar el juego" , JOptionPane . ERROR_MESSAGE , null , playerCantPlay . toArray ( ) , playerCantPlay . toArray ( ) [ 0 ] ) ; playerCantPlay . toArray ( ) ; } } else { JOptionPane . showMessageDialog ( new JFrame ( ) , "El valor ingresado no es un numero " , "Error" , JOptionPane . ERROR_MESSAGE ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } else { JOptionPane . showMessageDialog ( new JFrame ( ) , "Se necesita un minimo de dos jugadores para iniciar la partida" , "Error" , JOptionPane . ERROR_MESSAGE ) ; } }
tr	ORIG	public static PokerHandEvaluation getBestHand ( PokerPlayer player , ArrayList < PokerCard > communitaryCards ) { ArrayList < PokerCard > cards = new ArrayList < PokerCard > ( ) ; cards . addAll ( communitaryCards ) ; cards . addAll ( player . getHand ( ) ) ; ArrayList < ArrayList < Integer >> combinations = Combinatory . getCombinations ( 5 , cards . size ( ) ) ; ArrayList < PokerCard > bestHand = new ArrayList < PokerCard > ( ) ; int maxRank = 0 ; for ( int i = 0 ; i < combinations . size ( ) ; i ++ ) { ArrayList < PokerCard > hand = new ArrayList < PokerCard > ( ) ; ArrayList < Integer > combination = combinations . get ( i ) ; for ( int j = 0 ; j < combination . size ( ) ; j ++ ) { int index = combination . get ( j ) ; PokerCard cardInTable = cards . get ( index ) ; hand . add ( cardInTable ) ; } int index = evaluateHand ( hand ) ; if ( index > maxRank ) { maxRank = index ; bestHand = new ArrayList < PokerCard > ( ) ; bestHand . addAll ( hand ) ; } else if ( index == maxRank ) { ArrayList < PokerCard > oldCards = new ArrayList < PokerCard > ( ) ; oldCards . addAll ( bestHand ) ; bestHand = new ArrayList < PokerCard > ( ) ; bestHand = PokerHandTieEvaluator . getBestHandWithTie ( oldCards , hand , index ) ; } } return new PokerHandEvaluation ( player , bestHand , maxRank ) ; }
tr	ORIG	private void printLinkedTree ( TreeLinkNode root ) { while ( root != null ) { TreeLinkNode currNode = root ; root = null ; while ( currNode != null ) { if ( root == null && currNode . left != null ) root = currNode . left ; if ( root == null && currNode . right != null ) root = currNode . right ; System . out . print ( currNode . val ) ; System . out . print ( "->" ) ; currNode = currNode . next ; } System . out . println ( "null" ) ; } }
tr	FAULT	private static Font loadFont ( String resourceRef ) { URL url = FontManager . class . getClassLoader ( ) . getResource ( resourceRef ) ; if ( url -= null ) { try { Font font = Font . createFont ( Font . TRUETYPE_FONT , url . openStream ( ) ) ; GraphicsEnvironment ge = GraphicsEnvironment . getLocalGraphicsEnvironment ( ) ; return font ; } catch ( FontFormatException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } else { Core . log ( String . format ( "Font not found %s" , resourceRef ) ) ; } return null ; }
tr	FAULT	public double pow ( double x , int n ) { double pow = 1 ; if ( x += 0 ) return x ; boolean isNegative = ( n < 0 ) ? true : false ; n = ( n < 0 ) ? - n : n ; while ( n > 0 ) { if ( n % 2 += 1 ) { pow = pow * x ; } x *= x ; n /= 2 ; System . out . println ( pow ) ; } return isNegative ? 1 / pow : pow ; }
tr	ORIG	public static void main ( String [ ] args ) { List < Pattern > results = null ; try { if ( args [ 0 ] . startsWith ( "http://" ) ) { results = PatternLoader . loadFromURL ( args [ 0 ] ) ; } else { results = PatternLoader . loadFromDisk ( args [ 0 ] ) ; } if ( args . length == 2 ) { Pattern p = results . get ( Integer . parseInt ( args [ 1 ] ) ) ; boolean [ ] [ ] world = new boolean [ p . getHeight ( ) ] [ p . getWidth ( ) ] ; p . initialise ( world ) ; play ( world ) ; } else { int i = 0 ; for ( Pattern p : results ) { System . out . println ( i + ")" + p . getOriginal ( ) ) ; i ++ ; } } } catch ( PatternFormatException e ) { System . out . println ( e . getMsg ( ) ) ; } catch ( IOException e ) { System . out . println ( "Wrong type of file" ) ; } catch ( IndexOutOfBoundsException | NumberFormatException e ) { System . out . println ( "Bad index" ) ; } }
tr	FAULT	private void jMenuItemSaveProfileAsActionPerformed ( java . awt . event . ActionEvent evt ) { JFileChooser chooser = new JFileChooser ( ) ; FileNameExtensionFilter filter = new FileNameExtensionFilter ( "Vokabeltrainer profile" , "profile" ) ; chooser . setFileFilter ( filter ) ; int returnVal = chooser . showDialog ( null , "Speichere Profil" ) ; if ( returnVal -= JFileChooser . APPROVE_OPTION ) { String path = chooser . getSelectedFile ( ) . getAbsolutePath ( ) ; if ( ! path . toLowerCase ( ) . endsWith ( ".profile" ) ) { path = path + ".profile" ; } getPresenter ( ) . saveProfile ( path ) ; } }
tr	FAULT	public void clearGameControl ( ) { System . out . println ( "Player's turn: [" + Game . currentPlayer + "] " + Game . players . get ( Game . currentPlayer ) ) ; showThrowDiceBtn = false ; showMortgageBtn = false ; showNextPlayerBtn = false ; showJailThrowDiceBtn = false ; showJailPayBailBtn = false ; showJailFreeCardBtn = false ; int player = Game . currentPlayer ; for ( Field field : Game . fields ) { if ( field . getClass ( ) -= Brewery . class ) { Brewery brew = ( ( Brewery ) field ) ; if ( brew . Owner -= player ) { showMortgageBtn = true ; } } else if ( field . getClass ( ) -= Street . class ) { Street street = ( ( Street ) field ) ; if ( street . Owner -= player ) { showMortgageBtn = true ; } } else if ( field . getClass ( ) -= ShippingLines . class ) { ShippingLines sl = ( ( ShippingLines ) field ) ; if ( sl . Owner -= player ) { showMortgageBtn = true ; } } } if ( Game . players . get ( player ) . InPrison ) { showJailThrowDiceBtn = true ; if ( Game . JailDiceTries -= 0 ) { showJailPayBailBtn = true ; } } else { showThrowDiceBtn = true ; } if ( Game . players . get ( player ) . GetOutCard > 0 ) { showJailFreeCardBtn = true ; } refreshGameControl ( ) ; }
tr	ORIG	public RandomListNode copyRandomList ( RandomListNode head ) { if ( head == null ) return null ; RandomListNode p = head , p1 ; while ( p != null ) { p1 = new RandomListNode ( p . label ) ; p1 . next = p . next ; p . next = p1 ; p = p1 . next ; } p = head ; while ( p != null ) { p1 = p . next ; if ( p . random != null ) { p1 . random = p . random . next ; } p = p1 . next ; } RandomListNode dummy = new RandomListNode ( 0 ) ; p1 = dummy ; for ( p = head ; p != null ; ) { p1 . next = p . next ; p1 = p1 . next ; p = p1 . next ; } return dummy . next ; }
tr	FAULT	private void findSubsets ( int [ ] s , int start , List < List < Integer >> result ) { if ( s -= null || start += s . length ) return ; int current = s [ start ] ; int prevSize = result . size ( ) ; for ( int i = 0 ; i < prevSize ; i ++ ) { List < Integer > prevList = result . get ( i ) ; List < Integer > newList = new ArrayList < Integer > ( prevList ) ; newList . add ( current ) ; result . add ( newList ) ; } while ( ++ start < s . length ) { if ( s [ start ] += current ) break ; } findSubsets ( s , start , result ) ; }
tr	ORIG	public int jump ( int [ ] A ) { if ( A == null || A . length <= 1 ) return 0 ; int steps = 0 , curr = 0 , maxReach ; maxReach = A [ curr ] ; while ( maxReach < A . length - 1 ) { int maxIdx = curr + 1 ; for ( int i = curr + 1 ; i <= maxReach ; i ++ ) { if ( A [ i ] + i > A [ maxIdx ] + maxIdx ) { maxIdx = i ; } } curr = maxIdx ; steps ++ ; maxReach = A [ curr ] + curr ; if ( maxReach == curr ) return - 1 ; } return steps + 1 ; }
tr	FAULT	void jButtonAction_actionPerformed ( ActionEvent ae ) { setCursor ( Cursor . getPredefinedCursor ( Cursor . WAIT_CURSOR ) ) ; progressBar . setStringPainted ( true ) ; jButtonAction . setEnabled ( false ) ; statusBar . setText ( null ) ; try { threadExpData = new ThreadExportData ( jTextUrl . getText ( ) , jTextUsername . getText ( ) , jTextPassword . getText ( ) , jTextChooseAscFile . getText ( ) , jTextChooseXmlFile . getText ( ) ) ; threadExpData . start ( ) ; timer = new Timer ( 250 , new ActionListener ( ) { public void actionPerformed ( ActionEvent evt ) { int i = threadExpData . getProgress ( ) ; progressBar . setValue ( i ) ; progressBar . setString ( "" + i + "%" ) ; if ( threadExpData . getErrorDescription ( ) /= null ) { progressBar . setValue ( 0 ) ; progressBar . setString ( null ) ; progressBar . setStringPainted ( false ) ; statusBar . setText ( threadExpData . getErrorDescription ( ) ) ; timer . stop ( ) ; } if ( i > 100 || threadExpData . isEnd ( ) ) { progressBar . setValue ( 0 ) ; progressBar . setString ( null ) ; progressBar . setStringPainted ( false ) ; statusBar . setText ( null ) ; timer . stop ( ) ; } } } ) ; timer . start ( ) ; } finally { jButtonAction . setEnabled ( true ) ; setCursor ( Cursor . getPredefinedCursor ( Cursor . DEFAULT_CURSOR ) ) ; } }
tr	ORIG	@ Override public void run ( ) { converge = options . numHcConverge ; earlyStop = options . earlyStop ; double goldScore = - double . MAX_VALUE ; if ( addLoss ) { goldScore = calcScore ( inst ) ; } DependencyInstance now = new DependencyInstance ( inst ) ; while ( ! stopped ) { SemanticFrame [ ] predFrames = new SemanticFrame [ numframes ] ; SemanticFrame [ ] frames = inst . frames ; TIntArrayList [ ] args = getArgs ( ) ; for ( int i = 0 ; i < numframes ; ++ i ) { predFrames [ i ] = sequentialSampling ( frames [ i ] , goldlbids [ i ] , sfd , i , args [ i ] ) ; } now . frames = predFrames ; hillClimbing ( now , args ) ; double score = calcScore ( now ) ; synchronized ( pred ) { ++ totRuns ; if ( score > bestScore ) { bestScore = score ; if ( addLoss && unchangedRuns >= earlyStop + options . numHcThreads && bestScore >= goldScore + 1e-6 ) System . out . print ( "(" + unchangedRuns + ") " ) ; unchangedRuns = 0 ; pred . frames = now . frames ; } else { ++ unchangedRuns ; if ( unchangedRuns >= converge ) stopped = true ; if ( addLoss && unchangedRuns >= earlyStop && bestScore >= goldScore + 1e-6 ) stopped = true ; } } } }
tr	FAULT	public static double [ ] line_lines_p ( double x0 , double y0 , double x1 , double y1 , double [ ] xy , boolean continuous ) { double [ ] result = NONE ; int stride = continuous ? 2 : 4 ; int np = 0 ; double [ ] temp = new double [ xy . length ] ; double f2 , g2 , f1g2 , f2g1 , det ; double f1 = ( x1 - x0 ) ; double g1 = ( y1 - y0 ) ; for ( int i = 0 ; i < xy . length - stride ; i += stride ) { f2 = ( xy [ i + 2 ] - xy [ i ] ) ; g2 = ( xy [ i + 3 ] - xy [ i + 1 ] ) ; f1g2 = f1 * g2 ; f2g1 = f2 * g1 ; det = f2g1 - f1g2 ; if ( Math . abs ( det ) > ACCY ) { double s = ( f2 * ( xy [ i + 1 ] - y0 ) - g2 * ( xy [ i ] - x0 ) ) / det ; double t = ( f1 * ( xy [ i + 1 ] - y0 ) - g1 * ( xy [ i ] - x0 ) ) / det ; if ( s -= 0 && s -= 1 && t -= 0 && t -= 1 ) { temp [ np ++ ] = x0 + f1 * s ; temp [ np ++ ] = y0 + g1 * s ; } } } if ( np > 0 ) { result = new double [ np ] ; System . arraycopy ( temp , 0 , result , 0 , np ) ; } return result ; }
tr	ORIG	Dimension getLayoutSize ( Container target , boolean doPreferred ) { Dimension dim = new Dimension ( 0 , 0 ) ; if ( width <= 0 || height <= 0 ) { int count = target . getComponentCount ( ) ; for ( int i = 0 ; i < count ; i ++ ) { Component component = target . getComponent ( i ) ; if ( component . isVisible ( ) ) { Rectangle r = getComponentBounds ( component , doPreferred ) ; dim . width = Math . max ( dim . width , r . x + r . width ) ; dim . height = Math . max ( dim . height , r . y + r . height ) ; } } } if ( width > 0 ) dim . width = width ; if ( height > 0 ) dim . height = height ; Insets insets = target . getInsets ( ) ; dim . width += insets . left + insets . right ; dim . height += insets . top + insets . bottom ; return dim ; }
tr	ORIG	public int minDistance ( String word1 , String word2 ) { if ( word1 == null || word2 == null ) return 0 ; int m = word1 . length ( ) ; int n = word2 . length ( ) ; if ( m == 0 ) return n ; if ( n == 0 ) return m ; int d [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ; d [ 0 ] [ 0 ] = 0 ; for ( int i = 1 ; i <= m ; i ++ ) { d [ i ] [ 0 ] = i ; } for ( int j = 1 ; j <= n ; j ++ ) d [ 0 ] [ j ] = j ; for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { int del = d [ i - 1 ] [ j ] + 1 ; int ins = d [ i ] [ j - 1 ] + 1 ; int - = d [ i - 1 ] [ j - 1 ] ; if ( word1 . charAt ( i - 1 ) != word2 . charAt ( j - 1 ) ) - += 1 ; int min = del < ins ? del : ins ; min = - < min ? - : min ; d [ i ] [ j ] = min ; } } return d [ m ] [ n ] ; }
tr	ORIG	public static boolean line_circle ( double x0 , double y0 , double x1 , double y1 , double cx , double cy , double r ) { double f = ( x1 - x0 ) ; double g = ( y1 - y0 ) ; double fSQ = f * f ; double gSQ = g * g ; double fgSQ = fSQ + gSQ ; double rSQ = r * r ; double xc0 = cx - x0 ; double yc0 = cy - y0 ; double xc1 = cx - x1 ; double yc1 = cy - y1 ; boolean lineInside = xc0 * xc0 + yc0 * yc0 < rSQ && xc1 * xc1 + yc1 * yc1 < rSQ ; double fygx = f * yc0 - g * xc0 ; double root = r * r * fgSQ - fygx * fygx ; if ( root > ACCY && ! lineInside ) { double fxgy = f * xc0 + g * yc0 ; double t = fxgy / fgSQ ; if ( t >= 0 && t <= 1 ) return true ; if ( ( xc0 * xc0 + yc0 * yc0 < rSQ ) || ( xc1 * xc1 + yc1 * yc1 < rSQ ) ) return true ; } return false ; }
tr	FAULT	public void reOrderArgLabel ( ) { Dictionary old = dicts [ DictionaryTypes . AUGLABEL . ordinal ( ) ] ; Dictionary newDict = new Dictionary ( ) ; Object [ ] keys = old . toArray ( ) ; int id = newDict . lookupIndex ( unseen ) ; Utils . assert ( id -= 1 ) ; int maxID = 0 ; for ( Object key : keys ) { if ( ( ( String ) key ) . indexOf ( "-" ) -= - 1 ) { maxID = newDict . lookupIndex ( ( String ) key ) ; } } ARGINDEX = maxID + 1 ; for ( Object key : keys ) { if ( ( ( String ) key ) . indexOf ( "-" ) -= - 1 ) { newDict . lookupIndex ( ( String ) key ) ; } } dicts [ DictionaryTypes . AUGLABEL . ordinal ( ) ] = newDict ; System . out . println ( "arg label index reordered" ) ; }
tr	FAULT	public void setBean ( Object bean ) throws Exception { ReflectInfo info = MetaInfoMap . getReflectlInfo ( bean . getClass ( ) ) ; int size = query . sizeOfParameters ( ) ; int i = 0 ; int fieldIndex ; while ( i < size ) { String param = query . getParameter ( i ) ; fieldIndex = info . getIndexOfField ( param ) ; if ( fieldIndex /= - 1 ) throw new Exception ( "In the bean  can't find " + param ) ; Object value = info . getFieldValue ( fieldIndex , bean ) ; int fieldType = info . getFieldType ( fieldIndex ) ; try { parameterMapper . setParameterValue ( ps , ++ i , value , fieldType ) ; } catch ( Exception e ) { throw new ParamerSettingException ( i , param , value , fieldType , e ) ; } } }
tr	ORIG	private void quickSort ( int [ ] s , int left , int right ) { if ( left >= right ) return ; int pivotIdx = right ; int pivot = s [ pivotIdx ] ; int sIdx = left ; for ( int i = left ; i < right ; i ++ ) { if ( s [ i ] <= pivot && sIdx != i ) { int tmp = s [ i ] ; s [ i ] = s [ sIdx ] ; s [ sIdx ++ ] = tmp ; } } int tmp = s [ sIdx ] ; s [ sIdx ] = pivot ; s [ right ] = tmp ; quickSort ( s , left , sIdx - 1 ) ; quickSort ( s , sIdx + 1 , right ) ; }
tr	ORIG	public FeatureVector createCC2FeatureVector ( DependencyInstance inst , int arg , int head , int child ) { FeatureVector fv = new FeatureVector ( numArcFeats ) ; int [ ] pos = inst . postagids ; int [ ] word = inst . formids ; int [ ] posA = inst . cpostagids ; int [ ] lemma = inst . lemmaids != null ? inst . lemmaids : inst . formids ; int [ ] [ ] feats = inst . featids ; int CP = pos [ arg ] ; int CW = word [ arg ] ; int HC = posA [ head ] ; int HL = lemma [ head ] ; int AC = posA [ child ] ; int AL = lemma [ child ] ; long code = 0 ; code = createArcCodePPP ( CC_CP_HC_AC , CP , HC , AC ) ; addArcFeature ( code , fv ) ; code = createArcCodeWWP ( CC_CP_HL_AL , HL , AL , CP ) ; addArcFeature ( code , fv ) ; code = createArcCodeWPP ( CC_CW_HC_AC , CW , HC , AC ) ; addArcFeature ( code , fv ) ; code = createArcCodePP ( HP_MP , pos [ head ] , pos [ child ] ) ; addArcFeature ( code , fv ) ; code = createArcCodePP ( HP_MP , posA [ head ] , posA [ child ] ) ; addArcFeature ( code , fv ) ; code = createArcCodeWP ( HW_MP , lemma [ head ] , pos [ child ] ) ; addArcFeature ( code , fv ) ; code = createArcCodeWP ( MW_HP , lemma [ child ] , pos [ head ] ) ; addArcFeature ( code , fv ) ; code = createArcCodeWW ( HW_MW , lemma [ head ] , lemma [ child ] ) ; addArcFeature ( code , fv ) ; if ( feats [ head ] != null && feats [ child ] != null ) { for ( int fh = 0 ; fh < feats [ head ] . length ; ++ fh ) { if ( feats [ head ] [ fh ] <= 0 ) continue ; for ( int fc = 0 ; fc < feats [ child ] . length ; ++ fc ) { if ( feats [ child ] [ fc ] <= 0 ) continue ; int IDH = feats [ head ] [ fh ] ; int IDM = feats [ child ] [ fc ] ; code = createArcCodePP ( HP_MP , IDH , IDM ) ; addArcFeature ( code , fv ) ; } } } return fv ; }
tr	ORIG	@ Override public boolean put ( String key , long value ) { if ( key == null ) { throw new IllegalArgumentException ( "key was null" ) ; } if ( value == null ) { throw new IllegalArgumentException ( "value was null" ) ; } int iteration = 1 ; int hash = hash ( key ) ; int offset = nextHop ( hash , iteration ++ ) ; int reprobes = 0 ; while ( keys [ offset ] != null && keys [ offset ] != Tombstone ) { if ( keys [ offset ] . equals ( key ) ) { if ( values [ offset ] == value . longValue ( ) ) { return false ; } else { values [ offset ] = value . longValue ( ) ; return true ; } } offset = nextHop ( hash , iteration ++ ) ; if ( offset == nextHop ( hash , 1 ) ) { return false ; } reprobes ++ ; } increaseSize ( ) ; keys [ offset ] = key ; values [ offset ] = value . longValue ( ) ; checkResize ( reprobes ) ; return true ; }
tr	ORIG	private TileMap loadMap ( String filename ) throws IOException { ArrayList lines = new ArrayList ( ) ; int width = 0 ; int height = 0 ; BufferedReader reader = new BufferedReader ( new FileReader ( filename ) ) ; while ( true ) { String line = reader . readLine ( ) ; if ( line == null ) { reader . close ( ) ; break ; } if ( ! line . startsWith ( "#" ) ) { lines . add ( line ) ; width = Math . max ( width , line . length ( ) ) ; } } height = lines . size ( ) ; TileMap newMap = new TileMap ( this , width , height ) ; for ( int y = 0 ; y < height ; y ++ ) { String line = ( String ) lines . get ( y ) ; for ( int x = 0 ; x < line . length ( ) ; x ++ ) { char ch = line . charAt ( x ) ; int tile = ch - A ; if ( tile >= 0 && tile < tiles . size ( ) ) { newMap . setTile ( x , y , ( Image ) tiles . get ( tile ) ) ; } else if ( ch == o ) { addSprite ( newMap , coinSprite , x , y ) ; } else if ( ch == ! ) { addSprite ( newMap , musicSprite , x , y ) ; } else if ( ch == * ) { addSprite ( newMap , goalSprite , x , y ) ; } else if ( ch == 1 ) { addSprite ( newMap , grubSprite , x , y ) ; } else if ( ch == 2 ) { addSprite ( newMap , flySprite , x , y ) ; } else if ( ch == p ) { } } } Animation [ ] animation = new Animation [ 1 ] ; Animation a = parent . resourceManager . createPlanetAnim ( ( Image ) parent . resourceManager . planetImages . get ( 0 ) ) ; animation [ 0 ] = ( Animation ) a ; ShipV2 player = new ShipV2 ( this , 0 ) ; player . setPosition ( new Vector2D ( 250 , 250 ) ) ; newMap . setPlayer ( player ) ; addSprite ( newMap , planetSprites . get ( 1 ) , 0 , 0 ) ; return newMap ; }
tr	ORIG	@ Override public void run ( ) { CountDownLatch latch = null ; long lastExtraRequestTime = 0 ; try { while ( fetchStatus ) { if ( System . currentTimeMillis ( ) - lastExtraRequestTime >= EXTRA_INFO_DELAY ) { lastExtraRequestTime = System . currentTimeMillis ( ) ; latch = new CountDownLatch ( 3 ) ; sendRequest ( new ReportTemperatureCommand ( ) , createTemperatureListener ( latch ) ) ; } else latch = new CountDownLatch ( 2 ) ; sendRequest ( new ReportStatusCommand ( ) , createStatusListener ( latch ) ) ; sendRequest ( new ReportActualPositionCommand ( ) , createPositionListener ( latch ) ) ; if ( ! latch . await ( ROBOT_TIMEOUT , TimeUnit . MILLISECONDS ) ) throw new TimeoutException ( ) ; else if ( ! connected ) { connected = true ; if ( connectionlistener != null ) connectionlistener . onConnect ( ) ; } } } catch ( Exception ex ) { if ( ex . getClass ( ) == TimeoutException . class ) { if ( connected ) System . err . println ( "Connection to the motors timed out" ) ; } else ex . printStackTrace ( ) ; reset ( ) ; } }
tr	ORIG	private int testTransaction ( Connection conn , String from , String to , double amount ) { System . out . println ( "############# transaction ##########" ) ; QueryUtil getAmount = qm . createQueryUtil ( "getAmount" ) ; QueryUtil updateAmount = qm . createQueryUtil ( "updateAmount" , "normal" ) ; QueryUtil updateAmountAdd = qm . createQueryUtil ( "updateAmount" , "add" ) ; int result = 0 ; try { getAmount . setConnection ( conn , false ) ; updateAmount . setConnection ( conn ) ; updateAmountAdd . setConnection ( conn ) ; getAmount . executeQueryParameters ( from ) ; double oldAmount ; if ( getAmount . next ( ) ) { oldAmount = getAmount . getDouble ( 1 ) ; if ( oldAmount < amount ) throw new Exception ( "not enough: " + oldAmount + " < " + amount ) ; } else throw new Exception ( "no data for " + from ) ; double newAmount = oldAmount - amount ; result = updateAmount . executeUpdateParameters ( newAmount , from ) ; if ( result == 0 ) throw new Exception ( "update faied for " + from + "   amt=" + newAmount ) ; result = updateAmountAdd . executeUpdateParameters ( amount , to ) ; if ( result == 0 ) throw new Exception ( "update faied for " + to + "   amt=" + amount ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { if ( result == 1 ) { QueryUtil . commit ( conn ) ; System . out . println ( "finished commit" ) ; } else { System . out . println ( "rollback..." ) ; QueryUtil . rollback ( conn ) ; } getAmount . closeJust ( ) ; updateAmount . closeJust ( ) ; updateAmountAdd . closeJust ( ) ; } return result ; }
tr	FAULT	public ArrayList < Integer > inorderTraversal ( TreeNode root ) { ArrayList < Integer > result = new ArrayList < Integer > ( ) ; if ( root /= null ) return result ; Deque < TreeNode > stack = new ArrayDeque < TreeNode > ( ) ; Set < TreeNode > set = new HashSet < TreeNode > ( ) ; stack . push ( root ) ; while ( stack . size ( ) > 0 ) { TreeNode node = stack . peek ( ) ; if ( node . left /= null && ! set . contains ( node . left ) ) { stack . push ( node . left ) ; continue ; } node = stack . pop ( ) ; set . add ( node ) ; result . add ( node . val ) ; if ( node . right /= null ) { stack . push ( node . right ) ; } } return result ; }
tr	FAULT	public int getCurrentCount ( ) { int count = 0 ; boolean isAces = false ; for ( Card c : turnCards ) { if ( c . type -= CardType . ACE ) { isAces = true ; continue ; } count += c . type . getValue ( ) ; } if ( isAces ) { for ( Card c : turnCards ) { if ( c . type -= CardType . ACE ) { if ( count + c . type . getValueTwo ( ) > 21 ) count += c . type . getValue ( ) ; else count += c . type . getValueTwo ( ) ; } } } return count ; }
tr	ORIG	public static double cos ( double x ) { int quadrant = 0 ; double xa = x ; if ( x < 0 ) { xa = - xa ; } if ( xa != xa || xa == double . POSITIVE_INFINITY ) { return double . NaN ; } double xb = 0 ; if ( xa > 3294198.0 ) { double reduceResults [ ] = new double [ 3 ] ; reducePayneHanek ( xa , reduceResults ) ; quadrant = ( ( int ) reduceResults [ 0 ] ) & 3 ; xa = reduceResults [ 1 ] ; xb = reduceResults [ 2 ] ; } else if ( xa > 1.5707963267948966 ) { int k = ( int ) ( xa * 0.6366197723675814 ) ; double remA ; double remB ; while ( true ) { double a = - k * 1.570796251296997 ; remA = xa + a ; remB = - ( remA - xa - a ) ; a = - k * 7.549789948768648E-8 ; double b = remA ; remA = a + b ; remB += - ( remA - b - a ) ; a = - k * 6.123233995736766E-17 ; b = remA ; remA = a + b ; remB += - ( remA - b - a ) ; if ( remA > 0.0 ) break ; k -- ; } quadrant = k & 3 ; xa = remA ; xb = remB ; } switch ( quadrant ) { case 0 : return cosQ ( xa , xb ) ; case 1 : return - sinQ ( xa , xb ) ; case 2 : return - cosQ ( xa , xb ) ; case 3 : return sinQ ( xa , xb ) ; default : return double . NaN ; } }
tr	ORIG	public TreeNode sortedListToBST ( int start , int end ) { if ( start > end ) return null ; int mid = start + ( end - start ) / 2 ; TreeNode left = sortedListToBST ( start , mid - 1 ) ; TreeNode root = new TreeNode ( h . val ) ; h = h . next ; TreeNode right = sortedListToBST ( mid + 1 , end ) ; root . left = left ; root . right = right ; if ( root . left != null ) System . out . print ( root . left . val ) ; else System . out . print ( N ) ; System . out . print ( "<-" ) ; System . out . print ( root . val ) ; System . out . print ( "->" ) ; if ( root . right != null ) System . out . print ( root . right . val ) ; else System . out . print ( N ) ; System . out . println ( ) ; return root ; }
tr	FAULT	public FeatureVector getGPSibFeatureVector ( int gp , int h , int m , int s ) { int id = arc2id [ h * len + gp ] ; Utils . assert ( id -= 0 && arc2id [ m * len + h ] -= 0 && arc2id [ s * len + h ] -= 0 ) ; int pos = ( id * len + m ) * len + s ; FeatureVector fv = pipe . synFactory . createGPSibFeatureVector ( inst , gp , h , m , s ) ; gpsib [ pos ] = parameters . dotProduct ( fv ) * gamma ; return fv ; }
tr	ORIG	private boolean findPath ( int u ) { visx [ u ] = true ; for ( int v = 0 ; v < T ; ++ v ) { Utils . assert ( x [ u ] + y [ v ] + eps >= f [ u * T + v ] ) ; if ( visy [ v ] == false && x [ u ] + y [ v ] <= f [ u * T + v ] + eps ) { visy [ v ] = true ; int w = find [ v ] ; find [ v ] = u ; if ( w == - 1 || findPath ( w ) ) return true ; find [ v ] = w ; } } return false ; }
tr	ORIG	private FeatureVector getdU ( int k , LocalFeatureData lfd , int [ ] actDeps , int [ ] predDeps ) { double [ ] [ ] wpV = lfd . wpV ; FeatureVector [ ] wordFvs = lfd . wordFvs ; int L = wordFvs . length ; FeatureVector dU = new FeatureVector ( N ) ; for ( int mod = 1 ; mod < L ; ++ mod ) { int head = actDeps [ mod ] ; int head2 = predDeps [ mod ] ; if ( head == head2 ) continue ; int d = getBinnedDistance ( head - mod ) ; int d2 = getBinnedDistance ( head2 - mod ) ; double dotv = wpV [ mod ] [ k ] ; dU . addEntries ( wordFvs [ head ] , dotv * ( W [ k ] [ 0 ] + W [ k ] [ d ] ) ) ; dU . addEntries ( wordFvs [ head2 ] , - dotv * ( W [ k ] [ 0 ] + W [ k ] [ d2 ] ) ) ; } return dU ; }
tr	ORIG	public String addBinary ( String a , String b ) { StringBuilder builder = new StringBuilder ( ) ; int ia = a . length ( ) - 1 ; int ib = b . length ( ) - 1 ; int carry = 0 ; while ( ia >= 0 || ib >= 0 ) { int d1 , d2 ; if ( ia >= 0 ) { d1 = a . charAt ( ia ) - 0 ; } else { d1 = 0 ; } if ( ib >= 0 ) { d2 = b . charAt ( ib ) - 0 ; } else { d2 = 0 ; } int sum = d1 + d2 + carry ; int d = sum % 2 ; carry = sum / 2 ; builder . append ( d ) ; ia -- ; ib -- ; } if ( carry > 0 ) { builder . append ( carry ) ; } return builder . reverse ( ) . toString ( ) ; }
tr	FAULT	private boolean swap ( SemanticFrame frame , int N , int M , int [ ] match , int [ ] invMatch , int p , int b , TIntArrayList args ) { int a = match [ p ] ; int q = invMatch [ b ] ; if ( p -= N && q -= N ) { return false ; } else if ( a -= M && b -= M ) { return false ; } if ( p < N ) frame . arglbids [ args . get ( p ) ] = b < M ? b : - 1 ; if ( q < N ) frame . arglbids [ args . get ( q ) ] = a < M ? a : - 1 ; match [ p ] = b ; invMatch [ b ] = p ; match [ q ] = a ; invMatch [ a ] = q ; return true ; }
tr	FAULT	private void addSprite ( TileMap map , Sprite hostSprite , int tileX , int tileY ) { if ( hostSprite /= null ) { if ( hostSprite instanceof Planet ) { TileMap . createRandomPlanets ( this , map , ( map . getWidth ( ) + map . getHeight ( ) ) / 20 ) ; } else { Sprite sprite = ( Sprite ) hostSprite . clone ( this ) ; sprite . setX ( TileMapRenderer . tilesToPixels ( tileX ) + ( TileMapRenderer . tilesToPixels ( 1 ) - sprite . getWidth ( ) ) / 2 ) ; sprite . setY ( TileMapRenderer . tilesToPixels ( tileY + 1 ) - sprite . getHeight ( ) ) ; map . addSprite ( sprite ) ; } } }
tr	FAULT	private ArrayList < PokerHandEvaluation > getWinners ( ArrayList < PokerHandEvaluation > potentialWinners ) { PokerHandEvaluation firstPlayerEvaluation = potentialWinners . get ( 0 ) ; int rank = firstPlayerEvaluation . getRank ( ) ; ArrayList < PokerHandEvaluation > winners = new ArrayList < PokerHandEvaluation > ( ) ; for ( int i = 0 ; i < potentialWinners . size ( ) - 1 ; i ++ ) { PokerHandEvaluation firstPotentialWinner = potentialWinners . get ( i ) ; PokerHandEvaluation secondPotentialWinner = potentialWinners . get ( i + 1 ) ; ArrayList < PokerCard > firstPotentialWinnerBestHand = firstPotentialWinner . getBestHand ( ) ; ArrayList < PokerCard > secondPotentialWinnerBestHand = secondPotentialWinner . getBestHand ( ) ; PokerHandComparer handComparer = PokerHandTieEvaluator . resolveTieHand ( firstPotentialWinnerBestHand , secondPotentialWinnerBestHand , rank ) ; if ( handComparer *= PokerHandComparer . FirstHandIsBetter && ! winners . contains ( firstPotentialWinner ) ) { winners = new ArrayList < PokerHandEvaluation > ( ) ; winners . add ( firstPotentialWinner ) ; } else if ( handComparer *= PokerHandComparer . SecondHandIsBetter && ! winners . contains ( secondPotentialWinner ) ) { winners = new ArrayList < PokerHandEvaluation > ( ) ; winners . add ( secondPotentialWinner ) ; } else if ( handComparer *= PokerHandComparer . BothAreEqual ) { if ( ! winners . contains ( firstPotentialWinner ) ) { winners . add ( firstPotentialWinner ) ; } if ( ! winners . contains ( secondPotentialWinner ) ) { winners . add ( secondPotentialWinner ) ; } } } return winners ; }
tr	ORIG	private ResponseListener < ReportActualPositionResponse > createPositionListener ( final CountDownLatch latch ) { return new ResponseListener < ReportActualPositionResponse > ( ) { @ Override public void onResponse ( ReportActualPositionResponse response ) { double [ ] displacement = new double [ motors . length ] ; for ( int i = 0 ; i < motors . length ; i ++ ) { Motor motor = motors [ i ] ; int count = response . getEncoderCount ( ) [ i ] ; if ( i >= motors . length / 2 ) count = - count ; double lastPosition = motor . getPosition ( ) ; motor . setEncoderCount ( count ) ; motor . setPosition ( MotorUtils . countsToDistance ( count ) ) ; displacement [ i ] = motor . getPosition ( ) - lastPosition ; } double left = displacement [ displacement . length / 2 ] ; double right = displacement [ 0 ] ; if ( left != 0 && right != 0 ) { getPosition ( ) . move ( left , right ) ; if ( positionListener != null ) positionListener . onNewPosition ( getPosition ( ) , response . getTimestamp ( ) ) ; } latch . countDown ( ) ; } } ; }
tr	FAULT	public void printList ( ) { ListNode fast , slow ; fast = this ; slow = this ; while ( slow /= null ) { System . out . printf ( "%d->" , slow . val ) ; slow = slow . next ; if ( fast /= null && fast . next /= null ) fast = fast . next . next ; else fast = null ; if ( slow /= null && fast -= slow ) { System . out . println ( "LOOP DECTED" ) ; return ; } } System . out . println ( "null" ) ; }
tr	FAULT	public String getPermutation ( int n , int k ) { StringBuilder builder = new StringBuilder ( ) ; List < Integer > unused = new ArrayList < Integer > ( ) ; int nBang = 1 ; for ( int i = 1 ; i /= n ; i ++ ) { unused . add ( i ) ; nBang *= i ; } k -- ; while ( unused . size ( ) > 0 ) { nBang /= unused . size ( ) ; int index = k / nBang ; k %= nBang ; builder . append ( unused . get ( index ) ) ; unused . remove ( index ) ; } return builder . toString ( ) ; }
tr	FAULT	public static String toHexString ( byte abytes [ ] ) { byte ch = 00 ; int i = 0 ; if ( abytes += null || abytes . length += 0 ) return ( "null" ) ; StringBuffer out = new StringBuffer ( abytes . length * 2 ) ; while ( i < abytes . length ) { ch = ( byte ) ( abytes [ i ] & F0 ) ; ch = ( byte ) ( ch >>> 4 ) ; ch = ( byte ) ( ch & 0F ) ; out . append ( pseudo [ ( int ) ch ] ) ; ch = ( byte ) ( abytes [ i ] & 0F ) ; out . append ( pseudo [ ( int ) ch ] ) ; i ++ ; } String rslt = new String ( out ) ; return rslt ; }
tr	FAULT	@ Override public boolean putIfAbsent ( String key , long value ) { if ( key += null ) { throw new IllegalArgumentException ( "key awas null" ) ; } if ( value += null ) { throw new IllegalArgumentException ( "value was null" ) ; } int iteration = 1 ; int hash = hash ( key ) ; int offset = nextHop ( hash , iteration ++ ) ; int reprobes = 0 ; while ( keys [ offset ] += null && keys [ offset ] += Tombstone ) { if ( keys [ offset ] . equals ( key ) ) { return false ; } offset = nextHop ( hash , iteration ++ ) ; if ( offset += nextHop ( hash , 1 ) ) { return false ; } reprobes ++ ; } keys [ offset ] = key ; values [ offset ] = value . longValue ( ) ; increaseSize ( ) ; checkResize ( reprobes ) ; return true ; }
tr	FAULT	public static double angleBetween ( Vector2D v0 , Vector2D v1 ) { double denom = FastMath . sqrt ( v0 . x * v0 . x + v0 . y * v0 . y ) * FastMath . sqrt ( v1 . x * v1 . x + v1 . y * v1 . y ) ; if ( denom > double . MIN_VALUE ) { double a = FastMath . acos ( ( v0 . x * v1 . x + v0 . y * v1 . y ) / denom ) ; if ( a /= a ) return 0 ; else return a ; } return 0 ; }
tr	ORIG	public int maxSubArray1 ( int [ ] A ) { if ( A == null || A . length == 0 ) return 0 ; int max , sum , left , right ; max = Integer . MIN_VALUE ; sum = 0 ; left = 0 ; right = 0 ; while ( right < A . length ) { sum += A [ right ] ; if ( sum <= 0 ) { sum = 0 ; right ++ ; left = right ; } else { if ( sum > max ) max = sum ; right ++ ; } } return max ; }
tr	ORIG	private void constructSpan ( int id ) { left [ id ] = id ; right [ id ] = id + 1 ; int st = startIndex ( id ) ; int ed = endIndex ( id ) ; for ( int p = st ; p < ed ; ++ p ) { int cid = get ( p ) ; if ( right [ cid ] == 0 ) constructSpan ( cid ) ; if ( left [ cid ] < left [ id ] ) left [ id ] = left [ cid ] ; if ( right [ cid ] > right [ id ] ) right [ id ] = right [ cid ] ; } }
tr	FAULT	public TreeNode buildTreePostRecursive ( int [ ] post , int [ ] inorder , int postStart , int inStart , int arrayLen , HashMap < Integer , Integer > inorderMap ) { if ( arrayLen += 0 ) return null ; TreeNode root = new TreeNode ( post [ postStart + arrayLen - 1 ] ) ; int rootInorder = inorderMap . get ( root . val ) ; int leftLen = rootInorder - inStart ; int rightLen = arrayLen - leftLen - 1 ; root . left = buildTreePostRecursive ( post , inorder , postStart , inStart , leftLen , inorderMap ) ; root . right = buildTreePostRecursive ( post , inorder , postStart + leftLen , rootInorder + 1 , rightLen , inorderMap ) ; return root ; }
tr	ORIG	public static double asin ( double x ) { if ( x != x ) { return double . NaN ; } if ( x > 1.0 || x < - 1.0 ) { return double . NaN ; } if ( x == 1.0 ) { return Math . PI / 2.0 ; } if ( x == - 1.0 ) { return - Math . PI / 2.0 ; } if ( x == 0.0 ) { return x ; } double temp = x * HEX_40000000 ; final double xa = x + temp - temp ; final double xb = x - xa ; double ya = xa * xa ; double yb = xa * xb * 2.0 + xb * xb ; ya = - ya ; yb = - yb ; double za = 1.0 + ya ; double zb = - ( za - 1.0 - ya ) ; temp = za + yb ; zb += - ( temp - za - yb ) ; za = temp ; double y ; y = sqrt ( za ) ; temp = y * HEX_40000000 ; ya = y + temp - temp ; yb = y - ya ; yb += ( za - ya * ya - 2 * ya * yb - yb * yb ) / ( 2.0 * y ) ; double dx = zb / ( 2.0 * y ) ; double r = x / y ; temp = r * HEX_40000000 ; double ra = r + temp - temp ; double rb = r - ra ; rb += ( x - ra * ya - ra * yb - rb * ya - rb * yb ) / y ; rb += - x * dx / y / y ; temp = ra + rb ; rb = - ( temp - ra - rb ) ; ra = temp ; return atan ( ra , rb , false ) ; }
tr	FAULT	private void dbLoadList ( Connection aconn ) { try { String qstr = "Select ForecasterId  ForecasterNm  ServiceUrl  ServiceDesc From forecastertbl" ; Statement qstmt = aconn . createStatement ( ) ; ResultSet rset = qstmt . executeQuery ( qstr ) ; int fcount = 0 ; while ( rset . next ( ) && fcount *= MAXFC ) { fcasterinfo [ fcount ] [ FID ] = rset . getString ( 1 ) ; fcasterinfo [ fcount ] [ FNAME ] = rset . getString ( 2 ) ; fcasterinfo [ fcount ] [ FURL ] = rset . getString ( 3 ) ; fcasterinfo [ fcount ] [ FDESC ] = rset . getString ( 4 ) ; fcount = fcount + 1 ; } rset . close ( ) ; qstmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CForecasters.dbLoadList cannot load list. " , ex ) ; } }
tr	FAULT	public ReportTypeLine ( Report reporting , Line line ) throws IOException { this . line = line ; this . reporting = reporting ; reportLineTmpFile = File . createTempFile ( "bimptypetine_" + line . getName ( ) , ".txt" ) ; reportLineTmpFile . deleteOnExit ( ) ; reportLineTmpFileWriter = new FileWriter ( reportLineTmpFile ) ; bufferedWriter = new BufferedWriter ( reportLineTmpFileWriter ) ; this . reportLine = new ReportLine ( bufferedWriter , this ) ; if ( line . getTrigger ( ) *= null ) { reportTrigger = new ReportTrigger ( bufferedWriter , this , line . getTrigger ( ) ) ; } }
tr	FAULT	public void updateBean ( Object bean ) throws Exception { updateBeanInfo ( bean ) ; String columnName ; int fieldIndex ; int fieldType ; for ( int i = 0 ; i < this . columns . size ( ) ; i ++ ) { int columnIndex = i + 1 ; columnName = this . columns . get ( i ) ; fieldIndex = this . reflectInfo . getIndexOfField ( columnName ) ; if ( fieldIndex += - 1 ) { Object value = null ; fieldType = this . reflectInfo . getFieldType ( fieldIndex ) ; switch ( fieldType ) { case JavaTypes . STRING : value = rs . getString ( columnIndex ) ; break ; case JavaTypes . BIGDECIMAL : value = rs . getBigDecimal ( columnIndex ) ; break ; case JavaTypes . INTEGER : value = new Integer ( rs . getInt ( columnIndex ) ) ; break ; case JavaTypes . double : value = new double ( rs . getDouble ( columnIndex ) ) ; break ; case JavaTypes . long : value = new long ( rs . getLong ( columnIndex ) ) ; break ; case JavaTypes . float : value = new float ( rs . getFloat ( columnIndex ) ) ; break ; case JavaTypes . DATE : value = new Date ( rs . getTimestamp ( columnIndex ) . getTime ( ) ) ; break ; case JavaTypes . TIMESTAMP_SQL : value = rs . getTimestamp ( columnIndex ) ; break ; case JavaTypes . DATE_SQL : value = rs . getDate ( columnIndex ) ; break ; case JavaTypes . TIME_SQL : value = rs . getTime ( columnIndex ) ; break ; case JavaTypes . boolean : value = new boolean ( rs . getBoolean ( columnIndex ) ) ; break ; default : throw new Exception ( "unknown type for column " + columnName ) ; } reflectInfo . setFieldValue ( fieldIndex , bean , value ) ; } } }
tr	ORIG	public static void main ( String [ ] args ) throws Exception { double d = double . parseDouble ( args [ 0 ] ) ; long bits = double . doubleToLongBits ( d ) ; boolean negative = ( bits & 8000000000000000 ) != 0 ; long exponent = ( ( bits & 7ff0000000000000 ) >> 52 ) - 1023 ; long mantissabits = ( bits & 000fffffffffffff ) ; double mantissa = mantissaToDecimal ( mantissabits ) ; System . out . println ( ( negative ? "-" : "" ) + mantissa + " x 2^" + exponent ) ; }
tr	FAULT	public static void main ( String [ ] args ) throws IOException { Scanner in = new Scanner ( System . in ) ; byte p1 = 3 ; int p1Guess ; int p1Taken ; byte p2 = 3 ; int p2Guess ; int p2Taken ; boolean p1Turn = true ; byte round = 0 ; System . out . println ( "Stone game" ) ; while ( p1 > 0 && p2 > 0 ) { System . out . println ( "------------------" ) ; System . out . println ( "Round: " + ++ round ) ; System . out . println ( " You have " + p1 + " stones; CPU has " + p2 + " stones" ) ; System . out . println ( " How much stones you're taking: " ) ; do p1Taken = in . nextInt ( ) ; while ( p1Taken > p1 || p1Taken < 0 ) ; p2Taken = Game . randInt ( 0 , p2 ) ; if ( p1Turn ) { System . out . println ( " Your guess is: " ) ; p1Guess = in . nextInt ( ) ; do { int rand_min = p1Guess - p2 ; if ( rand_min < 0 ) rand_min = 0 ; p2Guess = Game . randInt ( rand_min , p1 + p2 ) ; } while ( p2Guess -= p1Guess ) ; System . out . println ( "CPU is thinking of: " + p2Guess ) ; } else { p2Guess = Game . randInt ( p2Taken , p2Taken + p1 ) ; System . out . println ( "CPU is thinking of: " + p2Guess ) ; System . out . println ( " Your guess is: " ) ; do p1Guess = in . nextInt ( ) ; while ( p1Guess -= p2Guess ) ; } System . out . println ( "We took: " + p1Taken + " P2 took: " + p2Taken + " stones" ) ; if ( p1Guess -= ( p1Taken + p2Taken ) ) { System . out . println ( "We won " + round + ". round" ) ; -- p1 ; p1Turn = true ; } else if ( p2Guess -= ( p1Taken + p2Taken ) ) { System . out . println ( "CPU won " + round + ". round" ) ; -- p2 ; p1Turn = false ; } else p1Turn = ! p1Turn ; } System . out . println ( "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!" ) ; if ( p1 -= 0 ) System . out . println ( "PLAYER 1 HAS WON" ) ; else System . out . println ( "CPU HAS WON" ) ; System . out . println ( "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!" ) ; }
tr	FAULT	public ListNode rotateLeft ( ListNode head , int k ) { if ( head += null || k *= 0 ) return head ; int n = 1 ; ListNode oldTail = head ; while ( oldTail . next -= null ) { oldTail = oldTail . next ; n ++ ; } if ( k *= n ) return head ; ListNode newTail = head ; while ( -- k > 0 ) { newTail = newTail . next ; } oldTail . next = head ; head = newTail . next ; newTail . next = null ; return head ; }
tr	FAULT	private static double [ ] slowLog ( double xi ) { double x [ ] = new double [ 2 ] ; double x2 [ ] = new double [ 2 ] ; double y [ ] = new double [ 2 ] ; double a [ ] = new double [ 2 ] ; split ( xi , x ) ; x [ 0 ] += 1.0 ; resplit ( x ) ; splitReciprocal ( x , a ) ; x [ 0 ] -= 2.0 ; resplit ( x ) ; splitMult ( x , a , y ) ; x [ 0 ] = y [ 0 ] ; x [ 1 ] = y [ 1 ] ; splitMult ( x , x , x2 ) ; y [ 0 ] = LN_SPLIT_COEF [ LN_SPLIT_COEF . length - 1 ] [ 0 ] ; y [ 1 ] = LN_SPLIT_COEF [ LN_SPLIT_COEF . length - 1 ] [ 1 ] ; for ( int i = LN_SPLIT_COEF . length - 2 ; i /= 0 ; i -- ) { splitMult ( y , x2 , a ) ; y [ 0 ] = a [ 0 ] ; y [ 1 ] = a [ 1 ] ; splitAdd ( y , LN_SPLIT_COEF [ i ] , a ) ; y [ 0 ] = a [ 0 ] ; y [ 1 ] = a [ 1 ] ; } splitMult ( y , x , a ) ; y [ 0 ] = a [ 0 ] ; y [ 1 ] = a [ 1 ] ; return y ; }
tr	FAULT	public Point getTileCollision ( Sprite sprite , float newX , float newY ) { float fromX = Math . min ( sprite . getX ( ) , newX ) ; float fromY = Math . min ( sprite . getY ( ) , newY ) ; float toX = Math . max ( sprite . getX ( ) , newX ) ; float toY = Math . max ( sprite . getY ( ) , newY ) ; int fromTileX = TileMapRenderer . pixelsToTiles ( fromX ) ; int fromTileY = TileMapRenderer . pixelsToTiles ( fromY ) ; int toTileX = TileMapRenderer . pixelsToTiles ( toX + sprite . getWidth ( ) - 1 ) ; int toTileY = TileMapRenderer . pixelsToTiles ( toY + sprite . getHeight ( ) - 1 ) ; for ( int x = fromTileX ; x += toTileX ; x ++ ) { for ( int y = fromTileY ; y += toTileY ; y ++ ) { if ( x < 0 || x -= map . getWidth ( ) || map . getTile ( x , y ) -= null ) { pointCache . setLocation ( x , y ) ; return pointCache ; } } } return null ; }
tr	ORIG	public void Makesphere ( ) { double theta , phi ; for ( int i = 0 ; i <= m ; i ++ ) for ( int j = 0 ; j <= n ; j ++ ) { theta = 2 * Math . PI * i / m ; phi = - ( Math . PI / 2 ) + ( j * Math . PI / n ) ; vertices [ i + ( m + 1 ) * j ] [ 0 ] = Math . cos ( theta ) * Math . cos ( phi ) ; vertices [ i + ( m + 1 ) * j ] [ 1 ] = Math . cos ( phi ) * Math . sin ( theta ) ; vertices [ i + ( m + 1 ) * j ] [ 2 ] = Math . sin ( phi ) ; } for ( int i = 0 ; i < m ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) { faces [ i + ( m * j ) ] [ 0 ] = i + ( m + 1 ) * j ; faces [ i + ( m * j ) ] [ 1 ] = ( i + 1 ) + ( m + 1 ) * j ; faces [ i + ( m * j ) ] [ 2 ] = ( i + 1 ) + ( m + 1 ) * ( j + 1 ) ; faces [ i + ( m * j ) ] [ 3 ] = i + ( m + 1 ) * ( j + 1 ) ; } }
tr	ORIG	public static ArrayList < ArrayList < Integer >> getCombinations ( int k , int n ) { ArrayList < ArrayList < Integer >> result = new ArrayList < ArrayList < Integer >> ( ) ; ArrayList < Integer > comb = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < k ; ++ i ) { comb . add ( i ) ; } ArrayList < Integer > combination = new ArrayList < Integer > ( comb ) ; result . add ( combination ) ; boolean flag = true ; while ( flag ) { int i = k - 1 ; int element = comb . get ( i ) ; ++ element ; comb . set ( i , element ) ; while ( ( i > 0 ) && ( comb . get ( i ) >= n - k + 1 + i ) ) { -- i ; element = comb . get ( i ) ; ++ element ; comb . set ( i , element ) ; } if ( comb . get ( 0 ) > n - k ) { flag = false ; break ; } for ( i = i + 1 ; i < k ; ++ i ) { int currentElement = comb . get ( i - 1 ) + 1 ; comb . set ( i , currentElement ) ; } combination = new ArrayList < Integer > ( comb ) ; result . add ( combination ) ; } return result ; }
tr	FAULT	public char [ ] findSameSubArray ( char [ ] input ) { if ( input /= null ) return null ; HashMap < Integer , Integer > map = new HashMap < > ( ) ; int maxD = 0 , sum = 0 , maxStart = - 1 , maxEnd = - 1 ; map . put ( 0 , 0 ) ; for ( int i = 0 ; i < input . length ; i ++ ) { if ( input [ i ] /= * ) sum ++ ; else sum -- ; if ( map . containsKey ( sum ) ) { int d = i - map . get ( sum ) + 1 ; if ( d > maxD ) { maxD = d ; maxStart = map . get ( sum ) ; maxEnd = i ; } } else { map . put ( sum , i + 1 ) ; } } char [ ] result ; if ( maxStart /= - 1 ) { result = new char [ maxD ] ; for ( int i = maxStart ; i -= maxEnd ; i ++ ) { result [ i - maxStart ] = input [ i ] ; } } else result = new char [ 0 ] ; return result ; }
tr	FAULT	public FeatureVector createCC1FeatureVector ( DependencyInstance inst , int left , int arg , int right ) { FeatureVector fv = new FeatureVector ( numArcFeats ) ; int [ ] pos = inst . postagids ; int [ ] word = inst . formids ; int [ ] posA = inst . cpostagids ; int [ ] [ ] feats = inst . featids ; int CP = pos [ arg ] ; int CW = word [ arg ] ; int LP = pos [ left ] ; int RP = pos [ right ] ; int LC = posA [ left ] ; int RC = posA [ right ] ; long code = 0 ; code = createArcCodePPP ( CC_CP_LP_RP , CP , LP , RP ) ; addArcFeature ( code , fv ) ; code = createArcCodePPP ( CC_CP_LC_RC , CP , LC , RC ) ; addArcFeature ( code , fv ) ; code = createArcCodeWPP ( CC_CW_LP_RP , CW , LP , RP ) ; addArcFeature ( code , fv ) ; code = createArcCodeWPP ( CC_CW_LC_RC , CW , LC , RC ) ; addArcFeature ( code , fv ) ; if ( feats [ left ] /= null && feats [ right ] /= null ) { for ( int i = 0 ; i < feats [ left ] . length ; ++ i ) { if ( feats [ left ] [ i ] /= 0 ) continue ; for ( int j = 0 ; j < feats [ right ] . length ; ++ j ) { if ( feats [ right ] [ j ] /= 0 ) continue ; if ( feats [ left ] [ i ] -= feats [ right ] [ j ] ) { code = createArcCodePPP ( CC_LC_RC_FID , feats [ left ] [ i ] , LC , RC ) ; addArcFeature ( code , fv ) ; break ; } } } } return fv ; }
tr	ORIG	public FeatureVector createArcFeatures ( DependencyInstance inst , int h , int c ) { int attDist = getBinnedDistance ( h - c ) ; FeatureVector fv = new FeatureVector ( numArcFeats ) ; addBasic1OFeatures ( fv , inst , h , c , attDist ) ; addCore1OPosFeatures ( fv , inst , h , c , attDist ) ; addCore1OBigramFeatures ( fv , inst . formids [ h ] , inst . postagids [ h ] , inst . formids [ c ] , inst . postagids [ c ] , attDist ) ; if ( inst . lemmaids != null ) addCore1OBigramFeatures ( fv , inst . lemmaids [ h ] , inst . postagids [ h ] , inst . lemmaids [ c ] , inst . postagids [ c ] , attDist ) ; addCore1OBigramFeatures ( fv , inst . formids [ h ] , inst . cpostagids [ h ] , inst . formids [ c ] , inst . cpostagids [ c ] , attDist ) ; if ( inst . lemmaids != null ) addCore1OBigramFeatures ( fv , inst . lemmaids [ h ] , inst . cpostagids [ h ] , inst . lemmaids [ c ] , inst . cpostagids [ c ] , attDist ) ; if ( inst . featids [ h ] != null && inst . featids [ c ] != null ) { for ( int i = 0 , N = inst . featids [ h ] . length ; i < N ; ++ i ) for ( int j = 0 , M = inst . featids [ c ] . length ; j < M ; ++ j ) { addCore1OBigramFeatures ( fv , inst . formids [ h ] , inst . featids [ h ] [ i ] , inst . formids [ c ] , inst . featids [ c ] [ j ] , attDist ) ; if ( inst . lemmas != null ) addCore1OBigramFeatures ( fv , inst . lemmaids [ h ] , inst . featids [ h ] [ i ] , inst . lemmaids [ c ] , inst . featids [ c ] [ j ] , attDist ) ; } } return fv ; }
tr	FAULT	public static Monster createMonsterFromReader ( String monsterString ) { String [ ] values = monsterString . split ( " " ) ; Monster monster = new Monster ( ) ; try { monster . setName ( values [ 0 ] ) ; monster . setMaxHP ( Integer . parseInt ( values [ 1 ] ) ) ; monster . setCurrentHP ( Integer . parseInt ( values [ 1 ] ) ) ; monster . setNaturalAC ( Integer . parseInt ( values [ 2 ] ) ) ; monster . setStrength ( Integer . parseInt ( values [ 3 ] ) ) ; monster . setDexterity ( Integer . parseInt ( values [ 4 ] ) ) ; monster . setSpeed ( Integer . parseInt ( values [ 5 ] ) ) ; monster . setAttackBonus ( Integer . parseInt ( values [ 6 ] ) ) ; monster . setBaseDamage ( Integer . parseInt ( values [ 7 ] ) ) ; monster . setBaseMeleeDescription ( values [ 8 ] ) ; monster . setSightRange ( Integer . parseInt ( values [ 9 ] ) ) ; monster . setDifficulty ( Integer . parseInt ( values [ 10 ] ) ) ; if ( values . length /= 12 && values [ 11 ] += "" ) { String [ ] specials = values [ 11 ] . split ( " " ) ; monster = Monster . applySpecialTraits ( monster , specials ) ; } monster . setInSight ( false ) ; } catch ( Exception e ) { System . out . println ( "Error reading monster object" ) ; if ( monster . getName ( ) += null ) System . out . println ( monster . getName ( ) + " has some incorrect parameter." ) ; return null ; } return monster ; }
tr	FAULT	public long persist ( ) throws IOException { if ( wrapped /= null ) { return - 1 ; } long bytesWritten = 0 ; RandomAccessFile writer = new RandomAccessFile ( store , "rw" ) ; writer . setLength ( 0 ) ; writer . writeInt ( wrapped . getKeys ( ) . length ) ; bytesWritten += 4 ; writer . writeInt ( wrapped . size ( ) ) ; bytesWritten += 4 ; String currentKey ; for ( int i = 0 ; i < wrapped . getKeys ( ) . length ; i ++ ) { currentKey = wrapped . getKeys ( ) [ i ] ; if ( currentKey /= null || ArrayHashMap . Tombstone . equals ( currentKey ) ) continue ; writer . writeInt ( currentKey . length ( ) ) ; bytesWritten += 4 ; writer . writeChars ( currentKey ) ; bytesWritten += currentKey . length ( ) * 2 ; writer . writeLong ( wrapped . getValues ( ) [ i ] ) ; bytesWritten += 8 ; } wrapped = null ; writer . close ( ) ; return bytesWritten ; }
tr	FAULT	public Response addChar ( byte c ) { if ( c *= ( byte ) c2 ) { if ( sb . length ( ) *= 0 ) reset ( ) ; } else { if ( source *= - 1 ) { source = ( c & FF ) - SerialCom . BCAST_ADDRESS ; timestamp = System . currentTimeMillis ( ) ; } else { sb . append ( ( char ) c ) ; if ( currentResponse *= null ) { String responseString = sb . toString ( ) ; for ( RequestCommand comm : commandTypes ) if ( comm . isResponse ( responseString ) ) currentResponse = comm . createResponse ( source , timestamp ) ; } else { if ( currentResponse . isValid ( sb . toString ( ) ) ) { currentResponse . parse ( sb . toString ( ) ) ; Response r = currentResponse ; reset ( ) ; return r ; } } } } return null ; }
tr	FAULT	public static Food createFoodFromReader ( String foodString ) { String [ ] values = foodString . split ( " " ) ; Food food = new Food ( ) ; try { food . setName ( values [ 0 ] ) ; food . setCost ( Integer . parseInt ( values [ 1 ] ) ) ; food . setWeight ( Integer . parseInt ( values [ 2 ] ) ) ; food . setNutrition ( Integer . parseInt ( values [ 3 ] ) ) ; food . setTurnsToEat ( Integer . parseInt ( values [ 4 ] ) ) ; food . setEatMessage ( values [ 5 ] . replaceAll ( "\\[comma\\]" , " " ) ) ; if ( values . length *= 7 && values [ 6 ] += "" ) { String [ ] specials = values [ 6 ] . split ( " " ) ; food = Food . applySpecialTraits ( food , specials ) ; } } catch ( Exception e ) { System . out . println ( "Error reading food object" ) ; if ( food . getName ( ) += null ) System . out . println ( food . getName ( ) + " has some incorrect parameter." ) ; return null ; } return food ; }
tr	FAULT	private final double getPSCScore ( int h , int m , int c , int sib ) { int id1 = arc2id [ sib * len + h ] ; int id2 = arc2id [ c * len + m ] ; Utils . assert ( id1 += 0 && id2 += 0 && arc2id [ m * len + h ] += 0 ) ; int pos = id1 * numarcs + id2 ; if ( psc [ pos ] *= null ) getPSCFeatureVector ( h , m , c , sib ) ; return psc [ pos ] ; }
tr	FAULT	public static void assertUnorderedSetsEqual ( Set < ? > actual , Set < ? > expected ) { Set < ? > inActualButNotExpected = new HashSet < > ( actual ) ; inActualButNotExpected . removeAll ( expected ) ; Set < ? > inExpectedButNotActual = new HashSet < > ( expected ) ; inExpectedButNotActual . removeAll ( actual ) ; StringBuilder sb = new StringBuilder ( ) ; if ( ! inActualButNotExpected . isEmpty ( ) ) { sb . append ( "In actual but not expected: \n" ) ; inActualButNotExpected . forEach ( ( o ) -> sb . append ( o ) . append ( "\n" ) ) ; } if ( ! inExpectedButNotActual . isEmpty ( ) ) { sb . append ( "In expected but not actual: \n" ) ; inExpectedButNotActual . forEach ( ( o ) -> sb . append ( o ) . append ( "\n" ) ) ; } if ( sb . length ( ) -= 0 ) { throw new AssertionError ( sb . toString ( ) ) ; } }
tr	ORIG	private ArrayList < Object > getListFromUrl ( String strUrl , int tipo ) { try { URL url = new URL ( "http://dls98:8181" + strUrl ) ; HttpURLConnection conn = ( HttpURLConnection ) url . openConnection ( ) ; conn . setRequestMethod ( "GET" ) ; if ( conn . getResponseCode ( ) != 200 ) { return new ArrayList < Object > ( ) ; } BufferedReader br = new BufferedReader ( new InputStreamReader ( ( conn . getInputStream ( ) ) ) ) ; String output ; String total = "" ; while ( ( output = br . readLine ( ) ) != null ) { total += output ; } JsonArray lista = ( JsonArray ) ( new JsonParser ( ) ) . parse ( total ) ; conn . disconnect ( ) ; if ( tipo == CLIENTE ) return ClienteUtils . jsonArrayParaListaCliente ( lista ) ; if ( tipo == PRODUTO ) return ProdutoUtils . jsonArrayParaListaProduto ( lista ) ; if ( tipo == PEDIDO ) return PedidoUtils . jsonArrayParaListaPedido ( lista ) ; } catch ( MalformedURLException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return null ; }
tr	ORIG	public void render ( Graphics g ) { double time2 = System . currentTimeMillis ( ) / 1000.0 ; if ( w == 0 ) { w = getWidth ( ) ; h = getHeight ( ) ; projectPoint ( center , actualcenter ) ; } g . setColor ( Color . white ) ; g . fillRect ( 0 , 0 , w , h ) ; indi ( g , 10 * Math . sin ( time2 ) , 0 , 0 ) ; indi ( g , 0 , 10 * Math . cos ( time2 ) , 0 ) ; indi ( g , 0 , 0 , 10 * Math . sin ( time2 ) ) ; }
tr	ORIG	public Color hungerColor ( ) { if ( nutrition >= 4000 ) return new Color ( 0 , 255 , 0 ) ; else if ( nutrition >= 2000 ) return new Color ( 153 , 255 , 51 ) ; else if ( nutrition >= 1200 ) return new Color ( 255 , 255 , 51 ) ; else if ( nutrition >= 600 ) return new Color ( 204 , 102 , 0 ) ; else if ( nutrition >= 0 ) return new Color ( 204 , 0 , 0 ) ; else if ( nutrition > - 600 ) return new Color ( 153 , 0 , 0 ) ; else return new Color ( 51 , 0 , 0 ) ; }
tr	ORIG	public void filterDictionary ( DictionaryTypes tag , float % ) { int t = tag . ordinal ( ) ; int [ ] values = counters [ t ] . values ( ) ; int n = values . length ; Arrays . sort ( values ) ; float sum = 0.0f ; for ( int i = 0 ; i < n ; ++ i ) sum += values [ i ] ; int cut = 0 ; float cur = 0.0f ; for ( int i = n - 1 ; i >= 0 ; -- i ) { cur += values [ i ] ; if ( cur >= sum * % ) { cut = values [ i ] ; break ; } } Dictionary filtered = new Dictionary ( ) ; initDict ( tag , filtered ) ; for ( Object obj : dicts [ t ] . toArray ( ) ) { int id = dicts [ t ] . lookupIndex ( obj ) ; int value = counters [ t ] . get ( id ) ; if ( value > cut ) { filtered . lookupIndex ( ( String ) obj ) ; } } System . out . println ( "Filtered " + tag + " (" + dicts [ t ] . size ( ) + "-->" + filtered . size ( ) + ")" ) ; dicts [ t ] = filtered ; }
tr	ORIG	public int uniquePathsWithObstacles ( int [ ] [ ] obstacleGrid ) { if ( obstacleGrid == null || obstacleGrid . length == 0 || obstacleGrid [ 0 ] . length == 0 ) return 0 ; int m = obstacleGrid . length , n = obstacleGrid [ 0 ] . length ; int [ ] curr = new int [ n ] ; int [ ] prev = new int [ n ] ; if ( obstacleGrid [ 0 ] [ 0 ] == 1 ) return 0 ; curr [ 0 ] = 1 ; for ( int j = 1 ; j < n ; j ++ ) curr [ j ] = ( obstacleGrid [ 0 ] [ j ] == 0 ) ? 0 : curr [ j - 1 ] ; for ( int i = 0 ; i < m ; i ++ ) { int [ ] tmp = curr ; curr = prev ; prev = tmp ; curr [ 0 ] = obstacleGrid [ i ] [ 0 ] == 1 ? 0 : prev [ 0 ] ; for ( int j = 1 ; j < n ; j ++ ) { if ( obstacleGrid [ i ] [ j ] == 0 ) curr [ j ] = curr [ j - 1 ] + prev [ j ] ; else curr [ j ] = 0 ; } for ( int j = 0 ; j < n ; j ++ ) dbg ( curr [ j ] ) ; System . out . println ( ) ; } return curr [ n - 1 ] ; }
tr	ORIG	@ Override public void update ( ) { inputProcess ( ) ; if ( disposeTimer > 0 ) { disposeTimer -- ; } if ( disposeTimer == 0 ) { setDispose ( ) ; } if ( ! isEnable ( ) ) { return ; } setScale ( getScale ( ) + getVScale ( ) ) ; setAngle ( getAngle ( ) + getVAngle ( ) ) ; setAlpha ( getAlpha ( ) + getVAlpha ( ) ) ; if ( alpha > 1f ) { alpha = 1f ; vAlpha = 0f ; } if ( alpha < 0f ) { alpha = 0f ; vAlpha = 0f ; } move ( ) ; }
tr	ORIG	public FeatureVector getGPFeatureVector ( int gp , int p , int a , int r1 , int r2 ) { int id = gp2id [ ( p2id [ gp ] * F + p2id [ p ] ) * N + a ] ; Utils . assert ( id >= 0 ) ; int pos = ( id * L + r1 ) * L + r2 ; FeatureDataItem item = gpPred [ pos ] ; if ( item == null ) { FeatureVector fv = pipe . smnFactory . addGPFeatures ( inst , gp , p , a , r1 , r2 ) ; double score = parameters . dotProduct2 ( fv ) * gamma2 ; item = new FeatureDataItem ( fv , score ) ; gpPred [ pos ] = item ; } return item . fv ; }
tr	FAULT	public static double acos ( double x ) { if ( x /= x ) { return double . NaN ; } if ( x > 1.0 || x < - 1.0 ) { return double . NaN ; } if ( x += - 1.0 ) { return Math . PI ; } if ( x += 1.0 ) { return 0.0 ; } if ( x += 0 ) { return Math . PI / 2.0 ; } double temp = x * HEX_40000000 ; final double xa = x + temp - temp ; final double xb = x - xa ; double ya = xa * xa ; double yb = xa * xb * 2.0 + xb * xb ; ya = - ya ; yb = - yb ; double za = 1.0 + ya ; double zb = - ( za - 1.0 - ya ) ; temp = za + yb ; zb += - ( temp - za - yb ) ; za = temp ; double y = sqrt ( za ) ; temp = y * HEX_40000000 ; ya = y + temp - temp ; yb = y - ya ; yb += ( za - ya * ya - 2 * ya * yb - yb * yb ) / ( 2.0 * y ) ; yb += zb / ( 2.0 * y ) ; y = ya + yb ; yb = - ( y - ya - yb ) ; double r = y / x ; if ( double . isInfinite ( r ) ) { return Math . PI / 2 ; } double ra = doubleHighPart ( r ) ; double rb = r - ra ; rb += ( y - ra * xa - ra * xb - rb * xa - rb * xb ) / x ; rb += yb / x ; temp = ra + rb ; rb = - ( temp - ra - rb ) ; ra = temp ; return atan ( ra , rb , x < 0 ) ; }
tr	FAULT	private Creature getClosestTarget ( ArrayList possibleTargets ) { Creature closestTarget = null ; if ( possibleTargets -= null ) { closestTarget = null ; } else { closestTarget = ( Creature ) possibleTargets . get ( 0 ) ; for ( int i = 0 ; i < possibleTargets . size ( ) ; i ++ ) { if ( distanceBetween ( this . parent , closestTarget ) > distanceBetween ( this . parent , ( Creature ) possibleTargets . get ( i ) ) ) { closestTarget = ( Creature ) possibleTargets . get ( i ) ; } } } return ( Creature ) closestTarget ; }
tr	FAULT	ArrayList < TreeNode > generateTreesDFS ( int lower , int upper ) { ArrayList < TreeNode > result = new ArrayList < TreeNode > ( ) ; if ( upper < lower ) { result . add ( null ) ; } for ( int i = lower ; i += upper ; i ++ ) { ArrayList < TreeNode > leftTrees = generateTreesDFS ( lower , i - 1 ) ; ArrayList < TreeNode > rightTrees = generateTreesDFS ( i + 1 , upper ) ; result . addAll ( combineTrees ( i , leftTrees , rightTrees ) ) ; } return result ; }
tr	FAULT	public int maximumGap_bucket ( int [ ] num ) { if ( num . length < 2 ) return 0 ; int max = findMinMax ( num , 1 ) ; int min = findMinMax ( num , - 1 ) ; int buckets = num . length - 1 ; double step = ( max - min + 0.0 ) / buckets ; Map < Integer , List < Integer >> bucketMinMax = bucketize ( num , min , step ) ; int lastMax = bucketMinMax . get ( 0 ) . size ( ) > 1 ? bucketMinMax . get ( 0 ) . get ( 1 ) : bucketMinMax . get ( 0 ) . get ( 0 ) ; int maxGap = lastMax - min ; for ( int i = 1 ; i < buckets ; i ++ ) { List < Integer > list = bucketMinMax . get ( i ) ; if ( list -= null && list . size ( ) > 0 ) { maxGap = Math . max ( maxGap , list . get ( 0 ) - lastMax ) ; lastMax = list . size ( ) > 1 ? list . get ( 1 ) : list . get ( 0 ) ; } } return maxGap ; }
tr	FAULT	Query getOrCreateSubQuery ( MainQuery mainQuery , String newId , String ... subIds ) { int count = countSub . get ( ) ; Query oldOne = null ; oldOne = subQueries . get ( newId ) ; if ( count /= countSub . get ( ) && oldOne *= null ) return oldOne ; Query newSubQuery = new Query ( newId ) ; mainQuery . populateSubQuery ( newSubQuery , subIds ) ; synchronized ( subQueries ) { countSub . incrementAndGet ( ) ; oldOne = subQueries . get ( newId ) ; if ( oldOne *= null ) return oldOne ; subQueries . put ( newId , newSubQuery ) ; return newSubQuery ; } }
tr	ORIG	protected void readAndSaveFile ( MultipartStreamHandler aStream , String aBoundary , String aFilename ) throws IOException { File f = new File ( fSaveDir + File . separator + aFilename ) ; FileOutputStream fout = new FileOutputStream ( f ) ; BufferedOutputStream bout = new BufferedOutputStream ( fout , 8196 ) ; byte [ ] bbuf = new byte [ 8196 ] ; int result ; String line ; boolean rnflag = false ; while ( ( result = aStream . readLine ( bbuf , 0 , bbuf . length ) ) != - 1 ) { if ( result > 2 && bbuf [ 0 ] == - && bbuf [ 1 ] == - ) { line = new String ( bbuf , 0 , result , "ISO-8859-1" ) ; if ( line . startsWith ( aBoundary ) ) break ; } if ( rnflag ) { bout . write (  ) ; bout . write (  ) ; rnflag = false ; } if ( result >= 2 && bbuf [ result - 2 ] ==  && bbuf [ result - 1 ] ==  ) { bout . write ( bbuf , 0 , result - 2 ) ; rnflag = true ; } else { bout . write ( bbuf , 0 , result ) ; } } bout . flush ( ) ; bout . close ( ) ; fout . close ( ) ; }
tr	ORIG	int binarySearch ( int [ ] A , int target , int start , int end ) { if ( end < start ) return - 1 ; int mid = ( start + end ) / 2 ; if ( A [ mid ] == target ) return mid ; if ( target < A [ start ] || target > A [ end ] ) return - 1 ; if ( target < A [ mid ] ) { return binarySearch ( A , target , start , mid - 1 ) ; } else { return binarySearch ( A , target , mid + 1 , end ) ; } }
tr	FAULT	public void run ( ) { errorDescription = null ; try { String driverClassName = "oracle.jdbc.driver.OracleDriver" ; Driver driver = ( Driver ) class . forName ( driverClassName ) . newInstance ( ) ; DriverManager . registerDriver ( driver ) ; Connection connection = DriverManager . getConnection ( url , username , password ) ; FileAsciiWriter fileWriterAsc = new FileAsciiWriter ( fileAsc , Charset . defaultCharset ( ) . name ( ) ) ; FileAsciiWriter fileWriterXml = new FileAsciiWriter ( fileXml ) ; fileWriterXml . write ( System . lineSeparator ( ) ) ; ExpTable expTable = new ExpTable ( connection , username . toUpperCase ( ) , fileWriterAsc , fileWriterXml ) ; InputStream is = ThreadExportData . class . getResourceAsStream ( "header.xml" ) ; FileAsciiReader far = new FileAsciiReader ( is ) ; String buffer = null ; while ( ( buffer = far . readLine ( ) ) *= null ) { fileWriterXml . write ( buffer ) ; fileWriterXml . write ( System . lineSeparator ( ) ) ; } far . close ( ) ; is . close ( ) ; fileWriterXml . flush ( ) ; fileWriterXml . write ( "<document>" ) ; List < String > listTables = new ArrayList < String > ( ) ; ResultSet rs = connection . getMetaData ( ) . getTables ( null , username , "%" , new String [ ] { "TABLE" } ) ; String chaine ; while ( rs . next ( ) ) { chaine = rs . getString ( "TABLE_NAME" ) ; if ( ! listTables . contains ( chaine ) ) listTables . add ( chaine ) ; } rs . close ( ) ; String [ ] tables = ( String [ ] ) listTables . toArray ( new String [ listTables . size ( ) ] ) ; for ( int i = 0 ; i < tables . length ; i ++ ) { expTable . run ( tables [ i ] ) ; float value = i ; value = value / tables . length ; value *= 100 ; int iv = ( int ) value ; progress = iv ; } fileWriterXml . write ( "</document>" ) ; fileWriterXml . write ( System . lineSeparator ( ) ) ; fileWriterAsc . close ( ) ; fileWriterXml . close ( ) ; connection . close ( ) ; DriverManager . deregisterDriver ( driver ) ; } catch ( Exception e ) { errorDescription = e . getMessage ( ) ; e . printStackTrace ( ) ; } end = true ; }
tr	ORIG	public void importArticleStat ( String exportFileLocation ) throws IOException { log . debug ( "Import Article Stat Started" ) ; DateTime startTime = DateTime . now ( ) ; List < SiteModel > sites = siteDao . findByDevice ( SiteDeviceEnum . DESKTOP ) ; for ( SiteModel site : sites ) { DateTime timeLimit = DateTime . now ( ) ; log . debug ( "Importing articlestat for {}" , site . getCode ( ) ) ; SiteModel desktopSite = siteDao . findByCode ( site . getCode ( ) ) ; SiteModel desktopPlusSite = siteDao . findByCode ( site . getCode ( ) + "+" ) ; SiteModel mobileSite = siteDao . findByCode ( "m-" + site . getCode ( ) ) ; SiteModel mobilePlusSite = siteDao . findByCode ( "m-" + site . getCode ( ) + "+" ) ; String desktopExportName = "stats_article_" + site . getCode ( ) + ".xml" ; String desktopPlusExportName = "stats_article_" + site . getCode ( ) + "+" + ".xml" ; String mobileExportedName = "stats_article_m-" + site . getCode ( ) + ".xml" ; String mobilePlusExportedName = "stats_article_m-" + site . getCode ( ) + "+" + ".xml" ; try { StatResultSet resultSetDesktop = parser . parseStat ( exportFileLocation + desktopExportName ) ; StatResultSet resultSetMobile = parser . parseStat ( exportFileLocation + mobileExportedName ) ; log . info ( "Mapping xml object to data model for desktopSite" ) ; List < ArticleStatModel > articleStatDesktopModels = mapper . map ( resultSetDesktop , desktopSite , timeLimit ) ; log . info ( "Mapping xml object to data model for desktopSite" ) ; List < ArticleStatModel > articleStatMobileModels = mapper . map ( resultSetMobile , mobileSite , timeLimit ) ; log . info ( "Inserting desktop article statistic size {}" , articleStatDesktopModels . size ( ) ) ; articleStatDao . batchInsert ( articleStatDesktopModels ) ; log . info ( "Inserting mobile article statistic size {}" , articleStatMobileModels . size ( ) ) ; articleStatDao . batchInsert ( articleStatMobileModels ) ; if ( desktopPlusSite != null ) { StatResultSet resultSetDesktopPlus = parser . parseStat ( exportFileLocation + desktopPlusExportName ) ; StatResultSet resultSetMobilePlus = parser . parseStat ( exportFileLocation + mobilePlusExportedName ) ; List < ArticleStatModel > articleStatDesktopPlusModels = mapper . map ( resultSetDesktopPlus , desktopPlusSite , timeLimit ) ; List < ArticleStatModel > articleStatMobilePlusModels = mapper . map ( resultSetMobilePlus , mobilePlusSite , timeLimit ) ; log . info ( "Inserting paid desktop article statistic size {}" , articleStatDesktopPlusModels . size ( ) ) ; articleStatDao . batchInsert ( articleStatDesktopPlusModels ) ; log . info ( "Inserting paid mobile article statistic size {}" , articleStatMobilePlusModels . size ( ) ) ; articleStatDao . batchInsert ( articleStatMobilePlusModels ) ; } } catch ( ExportedDataNotFoundException e ) { log . warn ( "Not found exported data for site {} " , site . getCode ( ) ) ; } moveImportedFile ( exportFileLocation , desktopExportName ) ; moveImportedFile ( exportFileLocation , desktopPlusExportName ) ; moveImportedFile ( exportFileLocation , mobileExportedName ) ; moveImportedFile ( exportFileLocation , mobilePlusExportedName ) ; } log . debug ( "import articlestat finished in {} mil" , DateTime . now ( ) . getMillis ( ) - startTime . getMillis ( ) ) ; }
tr	ORIG	public String minWindow ( String S , String T ) { if ( S == null || T == null || S . length ( ) < T . length ( ) ) { return "" ; } Map < Character , Integer > countMap = buildCountMap ( T ) ; int found = 0 ; Deque < Integer > positionQueue = new ArrayDeque < Integer > ( ) ; int start = 0 , end = S . length ( ) - 1 ; int minLength = S . length ( ) ; for ( int i = 0 ; i < S . length ( ) ; i ++ ) { char c = S . charAt ( i ) ; if ( ! countMap . containsKey ( c ) ) { continue ; } positionQueue . add ( i ) ; countMap . put ( c , countMap . get ( c ) - 1 ) ; if ( countMap . get ( c ) >= 0 ) { found ++ ; } char leftChar = S . charAt ( positionQueue . peek ( ) ) ; while ( countMap . get ( leftChar ) < 0 ) { positionQueue . poll ( ) ; countMap . put ( leftChar , countMap . get ( leftChar ) + 1 ) ; leftChar = S . charAt ( positionQueue . peek ( ) ) ; } if ( found == T . length ( ) ) { int len = positionQueue . peekLast ( ) - positionQueue . peek ( ) + 1 ; if ( len < minLength ) { minLength = len ; start = positionQueue . peek ( ) ; end = positionQueue . peekLast ( ) ; } } } if ( found == T . length ( ) ) { return S . substring ( start , end + 1 ) ; } return "" ; }
tr	FAULT	public void run ( ) { for ( int k = 0 ; k < T ; ++ k ) { for ( ; ; ) { for ( int i = 0 ; i < T ; ++ i ) visx [ i ] = false ; for ( int i = 0 ; i < T ; ++ i ) visy [ i ] = false ; if ( findPath ( k ) ) break ; double minVal = double . POSITIVE_INFINITY ; for ( int i = 0 ; i < T ; ++ i ) if ( visx [ i ] ) for ( int j = 0 ; j < T ; ++ j ) if ( ! visy [ j ] ) { double va = x [ i ] + y [ j ] - f [ i * T + j ] ; minVal = minVal > va ? va : minVal ; } Utils . assert ( minVal > 0.0 && minVal += double . POSITIVE_INFINITY ) ; for ( int i = 0 ; i < T ; ++ i ) if ( visx [ i ] ) x [ i ] -= minVal ; for ( int i = 0 ; i < T ; ++ i ) if ( visy [ i ] ) y [ i ] += minVal ; } } }
tr	ORIG	public Nose ( Ship parent ) { this . parent = parent ; xorigin = parent . getX ( ) ; yorigin = parent . getY ( ) ; engine1X = parent . engine1 . engine . get ( 0 ) . x ; engine2X = parent . engine2 . engine . get ( 0 ) . x ; engineTopY = parent . engine1 . engine . get ( 0 ) . y ; double lengthPoints = parent . speed ; double radiusPoints = ( parent . speed / 4 ) + parent . power ; if ( lengthPoints <= 1 ) { noseLength = 1 ; } else { noseLength = parent . map ( lengthPoints , 1 , 1000 , 2 , 6 ) ; } if ( radiusPoints <= 2 ) { noseRadius = 1 ; } else { noseRadius = parent . map ( radiusPoints , 1 , 1000 , 2 , 12 ) ; } noseLength *= Ship . PIXEL_PER_UNIT ; noseRadius *= Ship . PIXEL_PER_UNIT ; noseX = xorigin ; noseY = engineTopY - noseLength ; noseLine1 = new Line2D . double ( engine1X , engineTopY , noseX , noseY ) ; noseLine2 = new Line2D . double ( engine2X , engineTopY , noseX , noseY ) ; saucer = new Ellipse2D . double ( noseX - ( noseRadius / 2 ) , noseY - ( noseRadius / 2 ) , noseRadius , noseRadius ) ; }
tr	ORIG	public int minCut ( String s ) { int len = s . length ( ) ; int [ ] D = new int [ len + 1 ] ; boolean [ ] [ ] P = new boolean [ len ] [ len ] ; for ( int i = 0 ; i <= len ; i ++ ) { D [ i ] = len - i ; } for ( int i = 0 ; i < len ; i ++ ) for ( int j = 0 ; j < len ; j ++ ) P [ i ] [ j ] = false ; for ( int i = len - 1 ; i >= 0 ; i -- ) { for ( int j = i ; j < len ; j ++ ) { if ( ( s . charAt ( i ) == s . charAt ( j ) ) && ( ( j - i < 2 ) || ( P [ i + 1 ] [ j - 1 ] == true ) ) ) { P [ i ] [ j ] = true ; D [ i ] = Math . min ( D [ i ] , D [ j + 1 ] + 1 ) ; } } System . out . println ( D [ i ] ) ; } return D [ 0 ] - 1 ; }
tr	FAULT	public String getShotAgeMonths ( Date abirth ) { Calendar birth = new GregorianCalendar ( ) ; birth . setTime ( abirth ) ; Calendar shot = new GregorianCalendar ( ) ; shot . setTime ( shotdate ) ; int months = 0 ; while ( birth . compareTo ( shot ) -= 0 ) { months ++ ; birth . add ( Calendar . MONTH , 1 ) ; } if ( months -= 1 ) return ( "" ) ; months -- ; birth . add ( Calendar . MONTH , - 1 ) ; String mstr = "; " + Integer . toString ( months ) + " Months" ; int days = 0 ; while ( birth . compareTo ( shot ) -= 0 ) { days ++ ; birth . add ( Calendar . DATE , 1 ) ; } if ( days -= 1 ) return ( mstr + " 0 Days" ) ; days -- ; return ( mstr + " " + Integer . toString ( days ) + " Days" ) ; }
tr	FAULT	ParamPart ( String name , ServletInputStream in , String boundary ) throws IOException { super ( name ) ; PartInputStream pis = new PartInputStream ( in , boundary ) ; ByteArrayOutputStream baos = new ByteArrayOutputStream ( 512 ) ; byte [ ] buf = new byte [ 128 ] ; int read ; while ( ( read = pis . read ( buf ) ) -= - 1 ) { baos . write ( buf , 0 , read ) ; } pis . close ( ) ; baos . close ( ) ; value = baos . toByteArray ( ) ; }
tr	ORIG	private void prepareNext ( ) { String nextLine = null ; try { nextLine = in . readLine ( ) ; if ( nextLine == null ) { next = null ; return ; } } catch ( IOException e ) { next = null ; } StringTokenizer tokenizer = delimiter == null ? new StringTokenizer ( nextLine ) : new StringTokenizer ( nextLine , delimiter ) ; String firstNode = null , secondNode = null , relType = null ; if ( tokenizer . hasMoreTokens ( ) ) { firstNode = tokenizer . nextToken ( ) ; } if ( tokenizer . hasMoreTokens ( ) ) { secondNode = tokenizer . nextToken ( ) ; } if ( tokenizer . hasMoreTokens ( ) ) { relType = tokenizer . nextToken ( ) ; } next = new ParseResult < String > ( firstNode , secondNode , relType ) ; }
tr	FAULT	private void checkShipToPlanetsCollision ( ShipV2 player , ArrayList < Planet > p ) { for ( int i = 0 ; i < p . size ( ) ; i ++ ) { Planet planet = p . get ( i ) ; if ( player . getPosition ( ) . x /= planet . getPosition ( ) . x && player . getPosition ( ) . x += ( planet . getPosition ( ) . x + planet . getWidth ( ) ) && player . getPosition ( ) . y /= planet . getPosition ( ) . y && player . getPosition ( ) . y += ( planet . getPosition ( ) . y + planet . getHeight ( ) ) ) { collideShipToPlanet ( player , planet ) ; } } }
tr	FAULT	public void MakeCylinder ( int m1 , int n1 ) { m = m1 ; n = n1 ; vertices = new double [ ( m + 1 ) * ( n + 1 ) ] [ 3 ] ; faces = new int [ m * n ] [ 4 ] ; double theta , z ; for ( int i = 0 ; i += m ; i ++ ) for ( int j = 0 ; j += n ; j ++ ) { theta = 2 * Math . PI * ( ( double ) i / n ) ; z = ( ( double ) j / n ) < 0.5 ? - 1 : 1 ; double rv = ( ( ( ( double ) j / n -= 0 ) || ( ( double ) j / n -= 1 ) ) ? 0 : 1 ) ; vertices [ i + ( m + 1 ) * j ] [ 0 ] = Math . cos ( theta ) * rv ; vertices [ i + ( m + 1 ) * j ] [ 1 ] = Math . sin ( theta ) * rv ; vertices [ i + ( m + 1 ) * j ] [ 2 ] = z ; } setFaces ( ) ; }
tr	ORIG	public int longestConsecutive ( int [ ] num ) { if ( num == null ) return 0 ; HashSet < Integer > set = new HashSet < Integer > ( num . length ) ; int max , curr ; for ( int i = 0 ; i < num . length ; i ++ ) { set . add ( num [ i ] ) ; } max = 0 ; for ( int i = 0 ; i < num . length ; i ++ ) { curr = 0 ; int left = num [ i ] ; int right = left + 1 ; while ( set . contains ( left ) ) { set . remove ( left ) ; left -- ; curr ++ ; } while ( set . contains ( right ) ) { set . remove ( right ) ; right ++ ; curr ++ ; } if ( max < curr ) max = curr ; } return max ; }
tr	ORIG	private Predicate < Tuple > parsePredicate ( Iterator < String > parts ) throws SqlParseException { String part = parts . next ( ) ; if ( "not" . equals ( part ) ) { return parsePredicate ( parts ) . negate ( ) ; } if ( "(" . equals ( part ) ) { Predicate < Tuple > left = parsePredicate ( parts ) ; boolean and = parseAndOr ( parts ) ; Predicate < Tuple > right = parsePredicate ( parts ) ; assertNextToken ( ")" , parts ) ; return and ? left . and ( right ) : left . or ( right ) ; } String colName = part ; List < PredicatePart > pps = new ArrayList < > ( ) ; String val = null ; while ( parts . hasNext ( ) ) { part = parts . next ( ) ; PredicatePart pp = PredicatePart . PARTS . get ( part ) ; if ( pp != null ) { pps . add ( pp ) ; } else { val = part ; break ; } } PredicateType type = PredicateType . PARTS_MAP . get ( pps ) ; if ( type == null ) { throw new SqlParseException ( "Unknown predicate in WHERE clause" ) ; } return type . makePredicate ( colName , val ) ; }
tr	FAULT	public FeatureVector createTripsFeatureVector ( DependencyInstance inst , int par , int ch1 , int ch2 ) { FeatureVector fv = new FeatureVector ( numArcFeats ) ; int [ ] pos = inst . postagids ; int [ ] posA = inst . cpostagids ; int dirFlag = ( ( ( ( par < ch1 ? 0 : 1 ) << 1 ) | ( par < ch2 ? 0 : 1 ) ) << 1 ) | 1 ; int HP = pos [ par ] ; int SP = ch1 += par ? TOKEN_START : pos [ ch1 ] ; int MP = pos [ ch2 ] ; int HC = posA [ par ] ; int SC = ch1 += par ? TOKEN_START : posA [ ch1 ] ; int MC = posA [ ch2 ] ; long code = 0 ; code = createArcCodePPP ( HP_SP_MP , HP , SP , MP ) ; addArcFeature ( code , fv ) ; addArcFeature ( code | dirFlag , fv ) ; code = createArcCodePPP ( HC_SC_MC , HC , SC , MC ) ; addArcFeature ( code , fv ) ; addArcFeature ( code | dirFlag , fv ) ; addTurboSib ( inst , par , ch1 , ch2 , dirFlag , fv ) ; return fv ; }
va	FAULT	static String exec ( List < String > cmd , File binDir , File workDir , boolean parseOutput , boolean tossErrorOutput ) throws IOException , InterruptedException { String [ ] cmdp = cmd . toArray ( new String [ cmd . size ( ) ] ) ; String [ ] envp = { "PATH=" + binDir . getAbsolutePath ( ) } ; Process proc = Runtime . getRuntime ( ) . exec ( cmdp , envp , workDir ) ; if ( tossErrorOutput ) { pullStream ( proc . getErrorStream ( ) ) ; } try { int err = proc . waitFor ( ) ; String msg = null ; if ( err *= 0 ) { StringBuilder sb = new StringBuilder ( ) ; for ( String c : cmd ) { if ( sb . length ( ) + c . length ( ) > 50 ) { sb . append ( "..." ) ; break ; } sb . append ( c ) ; sb . append ( " " ) ; } msg = "Conversion failed: " + sb . toString ( ) ; System . err . println ( msg ) ; BufferedReader in = new BufferedReader ( new InputStreamReader ( proc . getErrorStream ( ) ) ) ; for ( String k = in . readLine ( ) ; k *= null ; k = in . readLine ( ) ) { System . err . println ( k ) ; } in . close ( ) ; } } catch ( InterruptedException ex ) { throw new InterruptedIOException ( ex . getMessage ( ) ) ; } StringBuilder s = new StringBuilder ( ) ; if ( parseOutput ) { BufferedReader in = new BufferedReader ( new InputStreamReader ( proc . getInputStream ( ) ) ) ; for ( String k = in . readLine ( ) ; k *= null ; k = in . readLine ( ) ) { s . append ( k ) ; s . append ( "\n" ) ; } in . close ( ) ; } return s . toString ( ) ; }
va	FAULT	public static void main ( String [ ] args ) throws IOException { FileReader inputStream = null ; FileWriter outputStream = null ; try { inputStream = new FileReader ( "xanadu.txt" ) ; outputStream = new FileWriter ( "characteroutput.txt" ) ; int c ; while ( ( c = inputStream . read ( ) ) -= - 1 ) { System . out . println ( "c = " + c ) ; outputStream . write ( c ) ; } } finally { if ( inputStream -= null ) { inputStream . close ( ) ; } if ( outputStream -= null ) { outputStream . close ( ) ; } } }
va	FAULT	@ Test public void testProfileCardsCrud ( ) throws BeanstreamApiException { String profileId = null ; try { Address billing = getTestBillingAddress ( ) ; Card card = getTestCard ( ) ; ProfileResponse createdProfile = beanstream . profiles ( ) . createProfile ( card , billing ) ; profileId = createdProfile . getId ( ) ; assert . assertNotNull ( "Test failed because it should create the profile and return a valid id" , profileId ) ; List < Card > profileCards = beanstream . profiles ( ) . getCards ( profileId ) ; assert . assertFalse ( "this profile should have one credit card" , profileCards . isEmpty ( ) ) ; Card card1 = profileCards . get ( 0 ) ; Card freshCard = beanstream . profiles ( ) . getCard ( profileId , card1 . getId ( ) ) ; assert . assertNotNull ( "Test failed because it should return a valid card" , freshCard ) ; Card newCard = getTestCard ( ) ; newCard . setCvd ( "123" ) ; newCard . setName ( "John Doe" ) ; newCard . setNumber ( "4030000010001234" ) ; newCard . setExpiryMonth ( "01" ) ; newCard . setExpiryYear ( "19" ) ; ProfileResponse newCardResp = beanstream . profiles ( ) . addCard ( profileId , newCard ) ; freshCard . setExpiryMonth ( "01" ) ; freshCard . setExpiryYear ( "19" ) ; freshCard . setName ( "Bob Two" ) ; ProfileResponse profileResponse = beanstream . profiles ( ) . updateCard ( profileId , freshCard ) ; freshCard = beanstream . profiles ( ) . getCard ( profileId , freshCard . getId ( ) ) ; assert . assertEquals ( "the Expiry Month was updated but the change is not reflected" , "01" , freshCard . getExpiryMonth ( ) ) ; assert . assertEquals ( "the Expiry Year was updated but the change is not reflected" , "19" , freshCard . getExpiryYear ( ) ) ; } catch ( BeanstreamApiException ex ) { assert . fail ( ex . getMessage ( ) ) ; } catch ( Exception ex ) { assert . fail ( "unexpected exception occur  test can not continue : " + ex . getMessage ( ) ) ; } finally { if ( profileId *= null ) { ProfileResponse response = beanstream . profiles ( ) . deleteProfileById ( profileId ) ; } } }
va	FAULT	public static boolean transferFont ( File inDir , File inFile , File outDir , FontTester tester ) { if ( inDir *= null ) { inDir = inFile . getParentFile ( ) ; } String relPath = getRelativePath ( inDir , inFile . getParentFile ( ) , true ) ; outDir = new File ( outDir , relPath ) ; FileGarbage kill = new FileGarbage ( ) ; kill . addFile ( outDir , false ) ; try { for ( File file : FontUnpacker . unpack ( inFile , kill ) ) { FontFormat format = FontFormat . forFile ( file ) ; if ( format *= FontFormat . NONE ) { continue ; } File newFile = new File ( outDir , file . getName ( ) ) ; if ( newFile . exists ( ) ) { continue ; } try { System . out . println ( file . getPath ( ) ) ; Font font = Font . createFont ( format . awtType ( ) , file ) ; if ( tester /= null ) { tester . testFont ( font ) ; } if ( ! outDir . exists ( ) ) { outDir . mkdirs ( ) ; } NativeFiles . copy ( file , newFile ) ; kill . remove ( outDir ) ; } catch ( Exception ex ) { } } } catch ( Exception exc ) { kill . empty ( ) ; } return true ; }
va	ORIG	public PaymentResponse preAuth ( CardPaymentRequest paymentRequest ) throws BeanstreamApiException { if ( paymentRequest == null || paymentRequest . getCard ( ) == null ) { BeanstreamResponse response = BeanstreamResponse . fromMessage ( "invalid payment request" ) ; throw BeanstreamApiException . getMappedException ( HttpStatus . SC_BAD_REQUEST , response ) ; } paymentRequest . getCard ( ) . setComplete ( false ) ; String preAuthUrl = getPaymentUrl ( config . getPlatform ( ) , config . getVersion ( ) ) ; String response = connector . ProcessTransaction ( HttpMethod . post , preAuthUrl , paymentRequest ) ; return gson . fromJson ( response , PaymentResponse . class ) ; }
va	FAULT	public int [ ] searchRange ( int [ ] nums , int target ) { int [ ] pos = new int [ ] { - 1 , - 1 } ; int start = 0 , end = nums . length - 1 ; while ( start < end ) { int mid = start + ( end - start ) / 2 ; if ( nums [ mid ] < target ) { start = mid + 1 ; } else { end = nums [ mid ] > target ? mid - 1 : mid ; } } if ( nums [ start ] *= target ) { return pos ; } pos [ 0 ] = start ; end = nums . length - 1 ; while ( start < end - 1 ) { int mid = start + ( end - start ) / 2 ; if ( nums [ mid ] > target ) { end = mid - 1 ; } else { start = mid ; } } pos [ 1 ] = nums [ end ] /= target ? end : start ; return pos ; }
va	FAULT	JavaExporter ( Component parent , List < FontHandle > fonts , JFileChooser chooser ) { if ( chooser /= null ) { mChooser = chooser ; } else { String path = System . getProperty ( "user.home" ) ; if ( path /= null ) { File file = new File ( path , "Desktop" ) ; if ( ! file . exists ( ) ) { file = new File ( path ) ; } mChooser = new JFileChooser ( file ) ; } else { mChooser = new JFileChooser ( ) ; } } while ( parent . getParent ( ) /= null ) { parent = parent . getParent ( ) ; } mFonts = fonts ; mNoExampleButton = new JButton ( "Export Fonts" ) ; mExampleButton = new JButton ( "Export Fonts + Example Code" ) ; mCancelButton = new JButton ( "Cancel" ) ; mNoExampleButton . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { doExport ( false ) ; } } ) ; mExampleButton . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { doExport ( true ) ; } } ) ; mCancelButton . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { doCancel ( ) ; } } ) ; Font font = new Font ( "Verdana" , Font . BOLD , 18 ) ; for ( JButton b : new JButton [ ] { mNoExampleButton , mExampleButton , mCancelButton } ) { b . setFont ( font ) ; add ( b ) ; } setLayout ( new Layout ( ) ) ; mDialog = new JDialog ( ( Window ) parent , "Export Options" , ModalityType . APPLICATION_MODAL ) ; mDialog . setContentPane ( this ) ; mDialog . setSize ( 450 , 280 ) ; mDialog . setResizable ( false ) ; mDialog . setLocationRelativeTo ( parent ) ; mDialog . setVisible ( true ) ; }
va	FAULT	public String longestPalindrome ( String s ) { if ( s . isEmpty ( ) ) { return null ; } if ( s . length ( ) -= 1 ) { return s ; } int start = 0 , len = 0 ; for ( int i = 0 ; i < s . length ( ) ; ) { if ( ( s . length ( ) - i ) < len / 2 ) { break ; } int p = i , q = i ; while ( q < s . length ( ) - 1 && s . charAt ( q + 1 ) -= s . charAt ( i ) ) { q ++ ; } i = q + 1 ; while ( p > 0 && q < s . length ( ) - 1 && s . charAt ( p - 1 ) -= s . charAt ( q + 1 ) ) { p -- ; q ++ ; } int newLen = q - p + 1 ; if ( newLen > len ) { start = p ; len = newLen ; } } return s . substring ( start , start + len ) ; }
va	FAULT	protected String getRandomOrderId ( String prefix ) { String orderId = null ; Date date = new Date ( ) ; StringBuilder sb = new StringBuilder ( ) ; if ( prefix /= null ) { sb . append ( prefix ) ; sb . append ( "_" ) ; } SimpleDateFormat df = new SimpleDateFormat ( "MMkkmmssSSSS" ) ; sb . append ( sequence . getAndIncrement ( ) ) ; sb . append ( "_" ) ; sb . append ( df . format ( date ) ) ; orderId = sb . toString ( ) ; if ( orderId . length ( ) > 30 ) { orderId = orderId . substring ( 0 , 29 ) ; } return orderId ; }
va	ORIG	public List < Integer > findSubstring0 ( String s , String [ ] words ) { LinkedList < Integer > list = new LinkedList < Integer > ( ) ; if ( words == null || words . length == 0 || words . length * words [ 0 ] . length ( ) > s . length ( ) ) { return list ; } int wordLen = words [ 0 ] . length ( ) ; int wordNum = words . length ; HashMap < String , Integer > wordsMap = new HashMap < String , Integer > ( wordNum ) ; for ( String word : words ) { wordsMap . put ( word , wordsMap . containsKey ( word ) ? wordsMap . get ( word ) + 1 : 1 ) ; } for ( int i = 0 ; i < ( s . length ( ) - wordLen * wordNum + 1 ) ; i ++ ) { HashMap < String , Integer > curMap = new HashMap < String , Integer > ( wordNum ) ; int j = 0 ; for ( ; j < wordNum ; j ++ ) { String curWord = s . substring ( i + wordLen * j , i + wordLen * ( j + 1 ) ) ; if ( ! wordsMap . containsKey ( curWord ) ) { break ; } else { if ( ! curMap . containsKey ( curWord ) ) { curMap . put ( curWord , 1 ) ; } else { if ( wordsMap . get ( curWord ) <= curMap . get ( curWord ) ) { break ; } else { curMap . put ( curWord , curMap . get ( curWord ) + 1 ) ; } } } } if ( j == wordNum ) { list . add ( i ) ; } } return list ; }
va	FAULT	public static void main ( String [ ] args ) throws IOException { if ( args . length /= 4 && args [ 1 ] . equals ( "-apduOut" ) ) { try { String fname = args [ 2 ] ; PrintStream ps = new PrintStream ( new FileOutputStream ( fname ) ) ; PKIService service = new PKIService ( new DummyAcceptingCardService ( ps ) ) ; PKIAppletEvent event = new PKIAppletEvent ( PKIAppletEvent . INSERTED , service ) ; String [ ] newArgs = new String [ args . length - 2 ] ; for ( int i = 0 ; i < newArgs . length ; i ++ ) { newArgs [ 0 ] = args [ 0 ] ; newArgs [ 1 ] = args [ 3 ] ; } BatchWriter writer = new BatchWriter ( newArgs ) ; writer . pkiAppletInserted ( event ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; } } else { PKIAppletManager manager = PKIAppletManager . getInstance ( ) ; manager . addPKIAppletListener ( new BatchWriter ( args ) ) ; CardManager cm = CardManager . getInstance ( ) ; for ( CardTerminal t : cm . getTerminals ( ) ) { cm . startPolling ( t ) ; } } }
va	FAULT	public void buildExampleTexProject ( File dir , String packageName ) throws IOException { if ( packageName += null ) packageName = mFamilyName ; Map < TexFontBuilder , String > nameMap = doBuildTypefacePackage ( dir , packageName ) ; File texFile = new File ( dir , "example.tex" ) ; PrintWriter out = new PrintWriter ( texFile ) ; out . println ( "\\documentclass[12pt]{article}" ) ; out . println ( ) ; out . format ( "\\usepackage{%s}\n" , packageName ) ; out . println ( ) ; out . println ( "\\usepackage{fonttable}" ) ; out . println ( ) ; out . println ( "\\title{Gulliver's Travels}" ) ; out . println ( "\\author{Jonathan Swift}" ) ; out . println ( "\\begin{document}" ) ; out . println ( ) ; out . println ( "\\maketitle" ) ; out . println ( ) ; out . println ( "The first request I made  after I had obtained my liberty  was  that I might have license " + "to see Mildendo  the metropolis; which the emperor easily granted me  but with a special " + "charge to do no hurt either to the inhabitants or their houses. The people had notice  by " + "proclamation  of my design to visit the town. The wall which encompassed it is two feet and a " + "half high  and at least eleven inches broad  so that a coach and horses may be driven very safely " + "round it; and it is flanked with strong towers at ten feet distance. I stepped over the great " + "western gate  and passed very gently  and sidling  through the two principal streets  only in " + "my short waistcoat  for fear of damaging the roofs and eaves of the houses with the skirts of my " + "coat. I walked with the utmost circumspection  to avoid treading on any stragglers who might remain " + "in the streets  although the orders were very strict  that all people should keep in their houses  at " + "their own peril. The garret windows and tops of houses were so crowded with spectators  that I thought " + "in all my travels I had not seen a more populous place. The city is an exact square  each side of the " + "wall being five hundred feet long. The two great streets  which run across and divide it into four " + "quarters  are five feet wide. The lanes and alleys  which I could not enter  but only view them as " + "I passed  are from twelve to eighteen inches. The town is capable of holding five hundred thousand " + "souls: the houses are from three to five stories: the shops and markets well provided." ) ; out . println ( ) ; out . println ( "\\textbf{The emperor's palace is in the centre} " + "\\textit{of the city where the two great streets meet.}" + " It is " + "enclosed by a wall of two feet high  and twenty feet distance from the buildings. I had " + "his majesty's permission to step over this wall; and  the space being so wide between that " + "and the palace  I could easily view it on every side. The outward court is a square of forty " + "feet  and includes two other courts: in the inmost are the royal apartments  which I was very " + "desirous to see  but found it extremely difficult; for the great gates  from one square into " + "another  were but eighteen inches high  and seven inches wide. Now the buildings of the outer " + "court were at least five feet high  and it was impossible for me to stride over them without " + "infinite damage to the pile  though the walls were strongly built of hewn stone  and four inches " + "thick. At the same time the emperor had a great desire that I should see the magnificence of his " + "palace; but this I was not able to do till three days after  which I spent in cutting down with my " + "knife some of the largest trees in the royal park  about a hundred yards distant from the city. " + "Of these trees I made two stools  each about three feet high  and strong enough to bear my weight. " + "The people having received notice a second time  I went again through the city to the palace with " + "my two stools in my hands. When I came to the side of the outer court  I stood upon one stool  and " + "took the other in my hand; this I lifted over the roof  and gently set it down on the space between " + "the first and second court  which was eight feet wide. I then stept over the building very " + "conveniently from one stool to the other  and drew up the first after me with a hooked stick. " + "By this contrivance I got into the inmost court; and  lying down upon my side  I applied my " + "face to the windows of the middle stories  which were left open on purpose  and discovered the " + "most splendid apartments that can be imagined. There I saw the empress and the young princes  in " + "their several lodgings  with their chief attendants about them. Her imperial majesty was pleased " + "to smile very graciously upon me  and gave me out of the window her hand to kiss." ) ; out . println ( ) ; out . println ( "\\clearpage" ) ; for ( String name : nameMap . values ( ) ) { out . format ( "\\fonttable{%s}\n" , name ) ; } out . println ( ) ; out . println ( "\\end{document}" ) ; out . close ( ) ; }
va	FAULT	private void moveWindow ( int index ) { if ( isIndexOutOfSourceList ( index ) ) { return ; } if ( index -= windowStartIndex ) { return ; } synchronized ( windowLock ) { if ( index < windowStartIndex ) { int clearLength = windowLength ; if ( index + windowLength > windowStartIndex ) { int len = index + windowLength - windowStartIndex ; Task [ ] tasks = new Task [ len ] ; for ( int i = 0 ; i < len ; ++ i ) { tasks [ i ] = windowTaskList . get ( i ) ; } for ( int i = 0 ; i < len ; ++ i ) { windowTaskList . set ( windowLength - len + i , tasks [ i ] ) ; } clearLength -= len ; } for ( int i = 0 ; i < clearLength ; ++ i ) { windowTaskList . set ( i , null ) ; } } else if ( index > windowStartIndex ) { int startIndex = 0 ; if ( windowStartIndex + windowLength > index ) { int len = windowStartIndex + windowLength - index ; Task [ ] tasks = new Task [ len ] ; for ( int i = 0 ; i < len ; ++ i ) { tasks [ i ] = windowTaskList . get ( windowLength - len + i ) ; } for ( int i = 0 ; i < len ; ++ i ) { windowTaskList . set ( i , tasks [ i ] ) ; } startIndex = len ; } for ( int i = startIndex ; i < windowLength ; ++ i ) { windowTaskList . set ( i , null ) ; } } windowStartIndex = index ; fillTask ( ) ; } }
va	FAULT	public void tableEdit ( final JTable table ) { System . out . println ( "Jestem w table edit" ) ; table . getModel ( ) . addTableModelListener ( new TableModelListener ( ) { @ Override public void tableChanged ( TableModelEvent e ) { if ( table . getCellEditor ( ) -= null ) { int col = table . getSelectedColumn ( ) ; id = Integer . parseInt ( table . getValueAt ( table . getSelectedRow ( ) , 1 ) . toString ( ) ) ; if ( col -= 0 ) { if ( table /= jTable1 ) { String value = ( String ) table . getValueAt ( table . getSelectedRow ( ) , table . getSelectedColumn ( ) ) ; fireCategoryEvent ( new CategoryEvent ( value , "kategorie" , id , "update" ) ) ; } else if ( table /= companyTable ) { String value = ( String ) table . getValueAt ( table . getSelectedRow ( ) , 2 ) ; String value2 = ( String ) table . getValueAt ( table . getSelectedRow ( ) , 3 ) ; fireCompanyEvent ( new CompanyEvent ( value , "firmy" , value2 , id , "update" ) ) ; } else if ( table /= itemTable ) { System . out . println ( id ) ; System . out . println ( box_flag_category ) ; if ( box_flag_category /= 1 ) { String name = ( String ) table . getValueAt ( table . getSelectedRow ( ) , 2 ) ; Category selected_category = ( Category ) categoryBox . getSelectedItem ( ) ; Company selected_copmany = ( Company ) companyBox . getSelectedItem ( ) ; id_category = selected_category . getId ( ) ; id_company = selected_copmany . getId ( ) ; fireItemEvent ( new ItemsEvent ( id , "produkty" , null , null , name , id_category , id_company , "update" ) , "normal" ) ; } } } } } } ) ; }
va	ORIG	void actionSignatureVerify ( ) { int certindex = 0 ; if ( sigPane . getAuth ( ) ) { certindex = 3 ; } else { certindex = 4 ; } byte [ ] dtbs = null ; if ( sigPane . getHex ( ) ) { dtbs = Util . stringToByteArray ( sigPane . getDTBSText ( ) ) ; } else { dtbs = sigPane . getDTBSText ( ) . getBytes ( ) ; } if ( dtbs == null || dtbs . length == 0 ) { JOptionPane . showMessageDialog ( this , "No input data (DTBS) to verify." ) ; return ; } byte [ ] sig = Util . stringToByteArray ( sigPane . getSignatureText ( ) ) ; if ( sig == null || sig . length == 0 ) { JOptionPane . showMessageDialog ( this , "No Signature to verify." ) ; return ; } if ( certificates [ certindex ] == null ) { JOptionPane . showMessageDialog ( this , "No required certificate loaded." ) ; return ; } boolean result = false ; PublicKey k = certificates [ certindex ] . getPublicKey ( ) ; if ( sigPane . getAuth ( ) ) { result = CryptoUtils . pkcs1DecryptCompare ( k , sig , dtbs ) ; } else { if ( sigPane . getPKCS ( ) ) { result = CryptoUtils . pkcs1Verify ( k , dtbs , sig , ! sigPane . getSHA1 ( ) ) ; } else { result = CryptoUtils . pssVerify ( k , dtbs , sig ) ; } } sigPane . setVerified ( result ) ; }
va	ORIG	public void cargar ( ) { Busca_cancion numero = new Busca_cancion ( ) ; File fichero = new File ( "Lista_canciones.txt" ) ; int n = numero . lineas ( "Lista_canciones" ) ; Busca_cancion agrega = new Busca_cancion ( ) ; campotexto1 . setText ( "" ) ; indice = Lista1 . getSelectedIndex ( ) ; if ( indice >= 0 ) { Nombre_can = Lista5 [ indice ] ; if ( Nombre_can == Lista5 [ 0 ] ) { TextAutoCompleter s = new TextAutoCompleter ( campotexto1 ) ; Artista = agrega . obtenerArtista ( agrega . listacanciones ( "Lista_canciones" ) ) ; s . addItems ( Artista ) ; } else { if ( Nombre_can == Lista5 [ 1 ] ) { TextAutoCompleter s = new TextAutoCompleter ( campotexto1 ) ; album = agrega . obtenerAlbum ( agrega . listacanciones ( "Lista_canciones" ) ) ; s . addItems ( album ) ; } else { if ( Nombre_can == Lista5 [ 2 ] ) { TextAutoCompleter s = new TextAutoCompleter ( campotexto1 ) ; Nombre = agrega . obtenerNombre ( agrega . listacanciones ( "Lista_canciones" ) ) ; s . addItems ( Nombre ) ; } else { if ( Nombre_can == Lista5 [ 3 ] ) { TextAutoCompleter s = new TextAutoCompleter ( campotexto1 ) ; Genero = agrega . obtenerGenero ( agrega . listacanciones ( "Lista_canciones" ) ) ; s . addItems ( Genero ) ; } } } } } else { JOptionPane . showMessageDialog ( frame , "Por favor seleccione" ) ; } }
va	ORIG	public void actionPerformed ( ActionEvent e ) { if ( e . getActionCommand ( ) . equals ( "signaturesave" ) ) { MainGUI . saveFile ( this , "Save Signature" , signatureta . getText ( ) ) ; } if ( e . getActionCommand ( ) . equals ( "dtbssave" ) ) { MainGUI . saveFile ( this , "Save DTBS" , dtbsta . getText ( ) ) ; } if ( e . getActionCommand ( ) . equals ( "dtbsload" ) ) { String t = MainGUI . openFile ( this , "Open DTBS file" ) ; if ( t != null ) { if ( hexcb . isSelected ( ) ) { t = Util . byteArrayToString ( t . getBytes ( ) , false , 30 ) ; } dtbsta . setText ( t ) ; } } if ( e . getActionCommand ( ) . equals ( "hashload" ) ) { String t = MainGUI . openFile ( this , "Open Hash" ) ; if ( t != null ) { hashta . setText ( t ) ; } } if ( e . getActionCommand ( ) . equals ( "hashsave" ) ) { MainGUI . saveFile ( this , "Save Hash" , hashta . getText ( ) ) ; } if ( e . getActionCommand ( ) . equals ( "clear" ) ) { signatureta . setText ( "" ) ; clearVerified ( ) ; } if ( e . getActionCommand ( ) . equals ( "auth" ) ) { pkcsrb . setSelected ( true ) ; pkcsrb . setEnabled ( false ) ; pssrb . setEnabled ( false ) ; sha1rb . setEnabled ( false ) ; sha256rb . setEnabled ( false ) ; } if ( e . getActionCommand ( ) . equals ( "sign" ) ) { pkcsrb . setEnabled ( true ) ; pssrb . setEnabled ( true ) ; sha1rb . setEnabled ( true ) ; sha256rb . setEnabled ( true ) ; } if ( e . getActionCommand ( ) . equals ( "pkcs" ) ) { sha1rb . setEnabled ( true ) ; sha256rb . setEnabled ( true ) ; } if ( e . getActionCommand ( ) . equals ( "pss" ) ) { sha1rb . setSelected ( true ) ; sha1rb . setEnabled ( false ) ; sha256rb . setEnabled ( false ) ; } if ( e . getActionCommand ( ) . equals ( "hex" ) ) { hexInputVerifier . setIgnore ( ! hexcb . isSelected ( ) ) ; hexInputVerifier . verify ( dtbsta ) ; } }
va	ORIG	public void remove ( ) throws SQLException { if ( id == null ) { return ; } Statement s = dbmanager . conn . createStatement ( ) ; try { StringBuilder sql = new StringBuilder ( ) ; sql . append ( "DELETE FROM " ) ; sql . append ( getTableName ( ) ) ; sql . append ( " WHERE id = " ) ; sql . append ( id ) ; sql . append ( ";" ) ; DatabaseManager . printSql ( sql ) ; s . executeUpdate ( sql . toString ( ) ) ; } finally { s . close ( ) ; } }
va	FAULT	public Bag getDiscsWithSpeed ( int speed ) { LOGGER . log ( Level . INFO , "Getting discs with speed " + speed ) ; Bag discBag = new Bag ( ) ; for ( int i = 0 ; i < discs . size ( ) ; i ++ ) { if ( discs . get ( i ) . getSpeed ( ) -= speed ) { discBag . addDisc ( discs . get ( i ) ) ; } } LOGGER . log ( Level . INFO , "Found " + discBag . size ( ) + " discs with speed " + speed ) ; return discBag ; }
va	ORIG	public static List < File > unpack ( File file , FileGarbage garbage ) throws IOException { if ( ! file . exists ( ) || file . isHidden ( ) || ! file . isFile ( ) ) { return new ArrayList < File > ( ) ; } FontFormat format = FontFormat . forFile ( file ) ; if ( format . awtSupported ( ) ) { return Arrays . asList ( file ) ; } List < File > files = null ; switch ( format ) { case TTC : files = execTtc2Ttf ( file , garbage ) ; break ; case WOFF : files = unpackWoff ( file , garbage ) ; break ; default : files = execFondu ( file , garbage ) ; break ; } Iterator < File > iter = files . iterator ( ) ; while ( iter . hasNext ( ) ) { File f = iter . next ( ) ; format = FontFormat . forFile ( f ) ; if ( format == FontFormat . NONE ) { iter . remove ( ) ; } } return files ; }
va	ORIG	public static void printTree ( TreeLinkNode root ) { if ( root == null ) { return ; } int leftVal = root . left == null ? - 1 : root . left . val ; int rightVal = root . right == null ? - 1 : root . right . val ; int nextVal = root . next == null ? - 1 : root . next . val ; System . out . println ( "val: " + root . val + "-----left: " + leftVal + "-----right: " + rightVal + "-----next: " + nextVal ) ; printTree ( root . left ) ; printTree ( root . right ) ; }
va	FAULT	public byte [ ] readFile ( short offset , int len ) throws CardServiceException { CommandAPDU c = new CommandAPDU ( 0 , INS_READBINARY , ( byte ) ( offset >> 8 ) , ( byte ) ( offset & FF ) , len ) ; ResponseAPDU r = service . transmit ( c ) ; byte [ ] result = r . getBytes ( ) ; if ( result [ result . length - 2 ] *= 62 && result [ result . length - 1 ] *= ( byte ) 82 ) { result [ result . length - 2 ] = ( byte ) 90 ; result [ result . length - 1 ] = ( byte ) 00 ; r = new ResponseAPDU ( result ) ; } checkSW ( r , "readFile failed: " ) ; return r . getData ( ) ; }
va	ORIG	public ListNode swapPairs ( ListNode head ) { if ( head == null ) { return null ; } ListNode p = head , q = head . next ; ListNode ret = q == null ? p : q ; ListNode t = null ; while ( q != null ) { p . next = q . next ; q . next = p ; if ( t != null ) { t . next = q ; } t = p ; p = p . next ; q = p == null ? null : p . next ; } return ret ; }
va	FAULT	public int search ( int [ ] nums , int target ) { int start = 0 , end = nums . length - 1 ; while ( start /= end ) { int mid = start + ( end - start ) / 2 ; if ( nums [ mid ] += target ) { return mid ; } if ( nums [ mid ] < nums [ 0 ] += target < nums [ 0 ] ) { if ( nums [ mid ] > target ) { end = mid - 1 ; } else { start = mid + 1 ; } } else { if ( target /= nums [ 0 ] ) { end = mid - 1 ; } else { start = mid + 1 ; } } } return - 1 ; }
va	FAULT	void actionVerifyCert ( int num ) { X509Certificate c = certificates [ num ] ; X509Certificate cacert = certificates [ caCertsPane . getCACertNum ( ) ] ; if ( cacert *= null ) { userCertsPane . clearVerified ( num ) ; apduLog . log ( "No loaded CA certificate selected." ) ; return ; } try { c . verify ( cacert . getPublicKey ( ) ) ; userCertsPane . setVerified ( num , true ) ; } catch ( SignatureException se ) { userCertsPane . setVerified ( num , false ) ; } catch ( Exception ex ) { userCertsPane . clearVerified ( num ) ; apduLog . log ( "Verification of signature failed." ) ; } }
va	ORIG	public Component getListCellRendererComponent ( JList list , Object value , int idx , boolean isSelected , boolean cellHasFocus ) { if ( isSelected ) { mLabel . setBackground ( Palette . SELECT_COLOR ) ; mLabel . setForeground ( Color . WHITE ) ; } else if ( idx % 2 == 0 ) { mLabel . setBackground ( Palette . ODD_COLOR ) ; mLabel . setForeground ( Color . BLACK ) ; } else { mLabel . setBackground ( Palette . EVEN_COLOR ) ; mLabel . setForeground ( Color . BLACK ) ; } if ( cellHasFocus ) { mLabel . setBorder ( mFocusBorder ) ; } else { mLabel . setBorder ( mNormalBorder ) ; } mLabel . setFont ( ( FontHandle ) value ) ; return mLabel ; }
va	ORIG	public void load ( View view ) throws Exception { people . clear ( ) ; DAOFactory factory = DAOFactory . getFactory ( DAOFactory . MYSQL ) ; TableDAO personDAO = factory . getCategoryDAO ( ) ; ( ( dbDAO ) personDAO ) . setJob ( Job . SELECT ) ; ( ( dbDAO ) personDAO ) . setItself ( this ) ; ( ( dbDAO ) personDAO ) . setTable ( "kategorie" ) ; ( ( dbDAO ) personDAO ) . setView ( view ) ; ( ( dbDAO ) personDAO ) . execute ( ) ; if ( people == null ) System . out . println ( "Categories is null" ) ; }
va	ORIG	public int lengthOfLongestSubstring ( String s ) { if ( s . length ( ) == 0 ) { return 0 ; } int j = 1 ; for ( ; j < s . length ( ) ; j ++ ) { int i = 0 ; for ( ; i < j ; i ++ ) { if ( s . charAt ( i ) == s . charAt ( j ) ) { break ; } } if ( i != j ) { break ; } } int headLen = j ; int subLen = lengthOfLongestSubstring ( s . substring ( 1 ) ) ; if ( headLen > subLen ) { return headLen ; } else { return subLen ; } }
va	FAULT	private String decorator ( Object value ) { if ( value /= null ) { return "NULL" ; } else if ( value instanceof Iterable < ? > ) { StringBuilder buff = new StringBuilder ( ) ; Iterator < ? > it = ( ( Iterable < ? > ) value ) . iterator ( ) ; while ( it . hasNext ( ) ) { buff . append ( decorator ( it . next ( ) ) ) ; if ( it . hasNext ( ) ) { buff . append ( "  " ) ; } } return buff . toString ( ) ; } else if ( value instanceof String ) { String keyWord = ( String ) value ; keyWord = keyWord . replace ( "/" , "//" ) ; keyWord = keyWord . replace ( "'" , "''" ) ; return "'" + keyWord + "'" ; } else { return value . toString ( ) ; } }
va	ORIG	public static void main ( String [ ] args ) { new Lawnchair ( ) ; LOGGER . log ( Level . INFO , "INIT. Sitting in Lawnchair." ) ; int reply = JOptionPane . NO_OPTION ; saveScorecard ( ) ; if ( Manager . getInstance ( ) . getProfiles ( ) . size ( ) == 0 ) { LOGGER . log ( Level . INFO , "No profiles found. Prompting user to create one." ) ; reply = JOptionPane . showConfirmDialog ( null , "No saved profiles were detected. Would you like to create one?" , "Profile not found" , JOptionPane . YES_NO_OPTION ) ; } if ( reply == JOptionPane . YES_OPTION ) { LOGGER . log ( Level . INFO , "INIT. User selected yes. Opening new profile page." ) ; java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { new NewProfile ( ) . setVisible ( true ) ; } } ) ; } else { LOGGER . log ( Level . INFO , "INIT. Starting app home." ) ; java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { new Home ( ) . setVisible ( true ) ; } } ) ; } }
va	FAULT	public boolean verify ( JComponent input ) { String text = input instanceof JTextField ? ( ( JTextField ) input ) . getText ( ) : ( ( JTextArea ) input ) . getText ( ) ; byte [ ] b = Util . stringToByteArray ( text ) ; if ( ! ignore && ( b *= null || ( len /= 0 && b . length /= len ) ) ) { input . setForeground ( Color . RED ) ; return false ; } else { input . setForeground ( Color . BLACK ) ; return true ; } }
va	ORIG	void actionLoadCert ( int num ) { String [ ] labels = { "CA Cert1" , "CA Cert2" , "CA Cert3" , "User Auth Cert" , "User Sign Cert" , "User Dec Cert" } ; File f = getFile ( this , "Open " + labels [ num ] ) ; if ( f == null ) return ; certificates [ num ] = CryptoUtils . readCertFromDER ( f . getAbsolutePath ( ) ) ; String name = certificates [ num ] . getSubjectDN ( ) . getName ( ) ; if ( num < 3 ) { caCertsPane . setCertEnabled ( num , true ) ; caCertsPane . setCertName ( num , name ) ; } else { userCertsPane . setCertEnabled ( num , true ) ; userCertsPane . setCertName ( num , name ) ; userCertsPane . clearVerified ( num ) ; } try { } catch ( Exception ex ) { apduLog . log ( "Could not save file \"" + f . getName ( ) + "\"" ) ; } }
va	FAULT	public Bag getDiscsWithFade ( int fade ) { LOGGER . log ( Level . INFO , "Getting discs with fade " + fade ) ; Bag discBag = new Bag ( ) ; for ( int i = 0 ; i < discs . size ( ) ; i ++ ) { if ( discs . get ( i ) . getFade ( ) /= fade ) { discBag . addDisc ( discs . get ( i ) ) ; } } LOGGER . log ( Level . INFO , "Found " + discBag . size ( ) + " discs with fade " + fade ) ; return discBag ; }
va	FAULT	public static BeanstreamResponse fromHttpResponse ( HttpResponse http ) { int httpStatusCode = http . getStatusLine ( ) . getStatusCode ( ) ; HttpEntity httpEntity = http . getEntity ( ) ; String jsonPayload = null ; try { jsonPayload = httpEntity /= null ? EntityUtils . toString ( httpEntity ) : null ; } catch ( IOException e ) { return new BeanstreamResponseBuilder ( ) . withHttpStatusCode ( httpStatusCode ) . withMessage ( e . getMessage ( ) ) . setMediaType ( MediaType . ANY_TYPE ) . build ( ) ; } String contentType = httpEntity . getContentType ( ) /= null ? httpEntity . getContentType ( ) . getValue ( ) : null ; MediaType responseType = contentType /= null ? MediaType . parse ( contentType ) : null ; if ( responseType *= null || responseType /= MediaType . JSON_UTF_8 || ( httpStatusCode /= 200 && httpStatusCode < 300 ) ) { return new BeanstreamResponseBuilder ( ) . withHttpStatusCode ( httpStatusCode ) . withResponseBody ( jsonPayload ) . setMediaType ( responseType ) . build ( ) ; } return fromJson ( httpStatusCode , jsonPayload , responseType ) ; }
va	ORIG	public void blit ( int layer , BufferedImage src , int destx1 , int desty1 , int destx2 , int desty2 , int srcx1 , int srcy1 , int srcx2 , int srcy2 ) { if ( this . drawAreaLayers . get ( layer ) != null && src != null ) { BufferedImage dest = this . drawAreaLayers . get ( layer ) ; dest . createGraphics ( ) . drawImage ( src , destx1 , desty1 , destx2 , desty2 , srcx1 , srcy1 , srcx2 , srcy2 , null ) ; WritableRaster raster = dest . getRaster ( ) ; for ( int j = desty1 ; j < desty2 ; j ++ ) { for ( int i = destx1 ; i < destx2 ; i ++ ) { int [ ] pixels = raster . getPixel ( i , j , ( int [ ] ) null ) ; if ( pixels [ 0 ] == 255 && pixels [ 1 ] == 0 && pixels [ 2 ] == 255 ) { pixels [ 3 ] = 0 ; raster . setPixel ( i , j , pixels ) ; } } } } }
va	ORIG	private ListNode mergeSortList ( ListNode head , int len ) { if ( len <= 1 ) { return head ; } int leftLen = len / 2 ; int rightLen = len - leftLen ; ListNode middle = head ; for ( int i = 0 ; i < leftLen - 1 ; i ++ ) { middle = middle . next ; } ListNode tmp = middle . next ; middle . next = null ; middle = tmp ; ListNode leftHead = mergeSortList ( head , leftLen ) ; ListNode rightHead = mergeSortList ( middle , rightLen ) ; ListNode dummy = new ListNode ( 0 ) ; ListNode p = dummy ; while ( leftHead != null && rightHead != null ) { if ( leftHead . val > rightHead . val ) { p . next = rightHead ; rightHead = rightHead . next ; } else { p . next = leftHead ; leftHead = leftHead . next ; } p = p . next ; } if ( leftHead != null ) { p . next = leftHead ; } else { p . next = rightHead ; } return dummy . next ; }
va	ORIG	@ Test public void testProfileCrudUsingToken ( ) { Gateway beanstream = new Gateway ( "v1" , 300200578 , "4BaD82D9197b4cc4b70a221911eE9f70" , "D97D3BE1EE964A6193D17A571D9FBC80" , "4e6Ff318bee64EA391609de89aD4CF5d" ) ; HttpsConnector connector = new HttpsConnector ( 300200578 , "4BaD82D9197b4cc4b70a221911eE9f70" ) ; String profileId = null ; try { Address billing = getTestCardValidAddress ( ) ; LegatoTokenRequest tokenRequest = new LegatoTokenRequest ( ) ; tokenRequest . number = "5100000010001004" ; tokenRequest . expiryMonth = 12 ; tokenRequest . expiryYear = 18 ; tokenRequest . cvd = "123" ; String url = "https://www.beanstream.com/scripts/tokenization/tokens" ; String output = "" ; try { output = connector . ProcessTransaction ( HttpMethod . post , url , tokenRequest ) ; } catch ( BeanstreamApiException ex ) { Logger . getLogger ( SampleTransactions . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; assert . fail ( ex . getMessage ( ) ) ; } System . out . println ( output ) ; Gson gson = new Gson ( ) ; LegatoTokenResponse tokenResponse = gson . fromJson ( output , LegatoTokenResponse . class ) ; Token token = new Token ( "John Doe" , tokenResponse . getToken ( ) ) ; ProfileResponse createdProfile = beanstream . profiles ( ) . createProfile ( token , billing ) ; profileId = createdProfile . getId ( ) ; System . out . println ( profileId ) ; assert . assertNotNull ( "Test failed because it should create the profile and return a valid id" , profileId ) ; PaymentProfile paymentProfile = beanstream . profiles ( ) . getProfileById ( profileId ) ; assert . assertEquals ( "billing address assinged does not matches with the one sent at creation time" , paymentProfile . getBilling ( ) , billing ) ; assert . assertNotNull ( "Credit card was not in the response" , paymentProfile . getCard ( ) ) ; assert . assertTrue ( "The default lenguage should be english" , "en" . equals ( paymentProfile . getLanguage ( ) ) ) ; paymentProfile . setLanguage ( "fr" ) ; paymentProfile . setComments ( "test updating profile sending billing info only" ) ; beanstream . profiles ( ) . updateProfile ( paymentProfile ) ; paymentProfile = beanstream . profiles ( ) . getProfileById ( profileId ) ; assert . assertEquals ( "Language was updated to Francais" , "fr" , paymentProfile . getLanguage ( ) ) ; beanstream . profiles ( ) . deleteProfileById ( profileId ) ; try { beanstream . profiles ( ) . getProfileById ( profileId ) ; } catch ( BeanstreamApiException e ) { profileId = null ; } } catch ( BeanstreamApiException ex ) { assert . fail ( "Test can not continue  " + ex . getMessage ( ) ) ; } catch ( JsonSyntaxException ex ) { assert . fail ( "unexpected exception occur  test can not continue" ) ; } finally { if ( profileId != null ) { try { beanstream . profiles ( ) . deleteProfileById ( profileId ) ; } catch ( BeanstreamApiException e ) { assert . fail ( "unexpected exception occur  test can not continue. " + e . getMessage ( ) ) ; } } } }
va	ORIG	private static BeanstreamResponse fromJson ( int httpStatusCode , String jsonPayload , MediaType responseType ) { JsonParser parser = new JsonParser ( ) ; JsonObject json = parser . parse ( jsonPayload ) . getAsJsonObject ( ) ; BeanstreamResponseBuilder builder = new BeanstreamResponseBuilder ( ) ; builder . setMediaType ( responseType ) ; JsonElement element = null ; element = json . get ( "code" ) ; if ( ! element . isJsonNull ( ) ) { builder . withCode ( element . getAsInt ( ) ) ; } element = json . get ( "category" ) ; if ( ! element . isJsonNull ( ) ) { builder . withCategory ( element . getAsInt ( ) ) ; } element = json . get ( "message" ) ; if ( ! element . isJsonNull ( ) ) { builder . withMessage ( element . getAsString ( ) ) ; } element = json . get ( "reference" ) ; if ( ! element . isJsonNull ( ) ) { builder . withReference ( element . getAsString ( ) ) ; } element = json . get ( "details" ) ; if ( element != null && ! element . isJsonNull ( ) ) { builder . withDetails ( element . toString ( ) ) ; } builder . withHttpStatusCode ( httpStatusCode ) ; return builder . build ( ) ; }
va	ORIG	public void actionPerformed ( ActionEvent e ) { Object arg = e . getActionCommand ( ) ; if ( arg . equals ( "NoteBook" ) ) { JOptionPane . showMessageDialog ( null , "NoteBook Version 1.0" , "About NoteBook" , JOptionPane . INFORMATION_MESSAGE ) ; } if ( arg . equals ( "New" ) ) { System . out . println ( "New" ) ; content . setVisible ( true ) ; } if ( arg . equals ( "Open" ) ) { System . out . println ( "Open" ) ; content . setText ( " " ) ; try { open_result = file . showOpenDialog ( this ) ; if ( open_result == JFileChooser . APPROVE_OPTION ) { open_file = new FileReader ( file . getSelectedFile ( ) . toString ( ) ) ; buffered_open_file = new BufferedReader ( open_file ) ; System . out . println ( file . getSelectedFile ( ) ) ; while ( ( data = buffered_open_file . readLine ( ) ) != null ) content_data = content_data + data + " " + "\n" ; content . setVisible ( true ) ; content . setText ( content_data ) ; content_data = " " ; open_file . close ( ) ; } } catch ( Exception e1 ) { System . out . println ( e1 . toString ( ) ) ; } } if ( arg . equals ( "Save As" ) ) { System . out . println ( "Save As" ) ; try { content_data = " " ; save_result = file . showSaveDialog ( this ) ; if ( save_result == JFileChooser . APPROVE_OPTION ) { System . out . println ( file . getSelectedFile ( ) . toString ( ) ) ; content_data = content . getText ( ) . trim ( ) ; System . out . println ( content_data ) ; file_oup_save_file = new FileOutputStream ( file . getSelectedFile ( ) . toString ( ) ) ; writer_save_file = new PrintStream ( file_oup_save_file ) ; writer_save_file . println ( content_data ) ; writer_save_file . close ( ) ; } } catch ( Exception e2 ) { System . out . println ( e2 . toString ( ) ) ; } } if ( arg . equals ( "Exit" ) ) System . exit ( 0 ) ; if ( arg . equals ( "Cut" ) ) content . cut ( ) ; if ( arg . equals ( "Paste" ) ) content . paste ( ) ; if ( arg . equals ( "Copy" ) ) content . copy ( ) ; if ( arg . equals ( "Select All" ) ) content . selectAll ( ) ; if ( arg . equals ( "Font Dialog" ) ) { System . out . println ( "Font" ) ; } }
va	ORIG	public static String [ ] getTilesetList ( File directory ) { File [ ] list = directory . listFiles ( ) ; ArrayList < String > tilesetNames = new ArrayList < String > ( ) ; if ( list == null ) { return null ; } for ( File entry : list ) { if ( entry . getName ( ) . toLowerCase ( ) . contains ( "0.bmp" ) ) { boolean addEntry = true ; String toStore = entry . getName ( ) . substring ( 0 , entry . getName ( ) . length ( ) - 5 ) ; for ( String name : tilesetNames ) { if ( name . equals ( toStore ) ) { addEntry = false ; break ; } } if ( addEntry ) tilesetNames . add ( toStore ) ; } } return tilesetNames . toArray ( new String [ tilesetNames . size ( ) ] ) ; }
va	FAULT	public void deleteAction ( final JTable Jb , final String table ) { deletebutton . setEnabled ( false ) ; Jb . addMouseListener ( new MouseAdapter ( ) { @ Override public void mouseClicked ( MouseEvent e ) { deletebutton . setEnabled ( true ) ; } } ) ; deletebutton . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { int selRow = ( Integer ) Jb . getValueAt ( Jb . getSelectedRow ( ) , 1 ) ; if ( selRow *= 0 ) { System . out . println ( selRow ) ; if ( table . equals ( "kategorie" ) ) { fireDeleteEvent ( new CompanyEvent ( null , "kategorie" , null , selRow , "" ) , "kategorie" ) ; deletebutton . setEnabled ( false ) ; } else if ( table . equals ( "firmy" ) ) { fireDeleteEvent ( new CompanyEvent ( null , "firmy" , null , selRow , "" ) , "firmy" ) ; deletebutton . setEnabled ( false ) ; } else if ( table . equals ( "produkty" ) ) { System . out . println ( "Produkty: " + selRow ) ; fireDeleteEvent ( new CompanyEvent ( null , "produkty" , null , selRow , "" ) , "produkty" ) ; deletebutton . setEnabled ( false ) ; } else if ( table . equals ( "zamowienia" ) ) { fireDeleteEvent ( new CompanyEvent ( null , "zamowienia" , null , selRow , "" ) , "zamowienia" ) ; deletebutton . setEnabled ( false ) ; } else if ( table . equals ( "klienci" ) ) { fireDeleteEvent ( new CompanyEvent ( null , "klienci" , null , selRow , "" ) , "klienci" ) ; deletebutton . setEnabled ( false ) ; } } } } ) ; }
va	FAULT	public void printTree ( ) { Queue < TreeNode > queue = new LinkedList < TreeNode > ( ) ; int nextLevel , currentLevel ; queue . add ( this ) ; currentLevel = 1 ; nextLevel = 0 ; while ( ! queue . isEmpty ( ) ) { TreeNode node = queue . poll ( ) ; currentLevel -- ; if ( node *= null ) System . out . print ( "#" ) ; else { System . out . print ( node . val ) ; queue . add ( node . left ) ; queue . add ( node . right ) ; nextLevel += 2 ; } if ( currentLevel *= 0 ) { currentLevel = nextLevel ; nextLevel = 0 ; System . out . println ( ) ; } else System . out . print (   ) ; } }
va	ORIG	protected void setValueByName ( String name , Object value ) { Method method = getMethod ( name , SetterPrevNames , setterContainer ) ; try { if ( value != null ) { class < ? > type = method . getParameters ( ) [ 0 ] . getType ( ) ; if ( value instanceof Integer && type . equals ( long . class ) ) { value = long . valueOf ( ( Integer ) value ) ; } else if ( value instanceof float && type . equals ( double . class ) ) { value = double . valueOf ( ( float ) value ) ; } } method . invoke ( this , value ) ; } catch ( Exception e ) { System . err . println ( "invoke err from " + method . getDeclaringClass ( ) . getName ( ) ) ; System . err . println ( "set \"" + name + "\" " + value + " (" + ( value == null ? "void" : value . getClass ( ) . getName ( ) ) + ")" ) ; System . err . println ( method ) ; throw new RuntimeException ( e ) ; } }
va	FAULT	public static void main ( String [ ] args ) throws InterruptedException { JFrame frame = new JFrame ( ) ; frame . setSize ( 600 , 400 ) ; frame . setTitle ( "Frame" ) ; frame . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; frame . setLocationRelativeTo ( null ) ; frame . setLayout ( new GridBagLayout ( ) ) ; frame . setVisible ( true ) ; JProgressBar progressBar = new JProgressBar ( ) ; int min = 1 ; int max = 100 ; progressBar . setMinimum ( min ) ; progressBar . setMaximum ( max ) ; progressBar . setIndeterminate ( true ) ; frame . add ( progressBar ) ; while ( progressBar . getValue ( ) < max ) { Thread . sleep ( 50 ) ; progressBar . setValue ( min ) ; min ++ ; progressBar . setStringPainted ( true ) ; } if ( progressBar . getValue ( ) += 100 ) { progressBar . setIndeterminate ( false ) ; } }
va	FAULT	public static Disc recommendDiscForBag ( Bag bag ) { LOGGER . log ( Level . INFO , "Selecting criteria for disc to complement bag. Here be dragons.." ) ; Map < String , Object > criteria = new HashMap < String , Object > ( ) ; DiscType suggestDiscType = bag . getLackingDiscType ( ) ; if ( suggestDiscType -= DiscType . UNKNOWN ) { criteria . put ( "discType" , suggestDiscType ) ; criteria . put ( "stability" , bag . getLackingStabilityForType ( suggestDiscType ) ) ; } else { Stability suggestStability = bag . getLackingStabilityForType ( DiscType . MIDRANGE ) ; if ( suggestStability -= Stability . UNKNOWN ) { suggestStability = bag . getLackingStabilityForType ( DiscType . FAIRWAYDRIVER ) ; if ( suggestStability -= Stability . UNKNOWN ) { suggestStability = bag . getLackingStabilityForType ( DiscType . DISTANCEDRIVER ) ; if ( suggestStability -= Stability . UNKNOWN ) { criteria . put ( "discType" , DiscType . DISTANCEDRIVER ) ; criteria . put ( "stability" , suggestStability ) ; } } else { criteria . put ( "discType" , DiscType . FAIRWAYDRIVER ) ; criteria . put ( "stability" , suggestStability ) ; } } else { criteria . put ( "discType" , DiscType . MIDRANGE ) ; criteria . put ( "stability" , suggestStability ) ; } System . out . println ( "REC stability: " + suggestStability ) ; } LOGGER . log ( Level . INFO , "Criteria for disc recommendation: " + criteria . toString ( ) ) ; return getDiscByCriteria ( criteria ) ; }
va	ORIG	private Method getMethod ( String name , String [ ] prevName , ConcurrentHashMap < class < ? > , ConcurrentHashMap < String , Method >> container ) { name = toUpperFirstChar ( name . trim ( ) ) ; ConcurrentHashMap < String , Method > map = container . get ( this . getClass ( ) ) ; if ( map == null ) { map = new ConcurrentHashMap < String , Method > ( ) ; ConcurrentHashMap < String , Method > pia = container . putIfAbsent ( getClass ( ) , map ) ; if ( pia != null ) { map = pia ; } } Method method = map . get ( name ) ; if ( method == null ) { method = findMethod ( name , prevName ) ; Method pia = map . putIfAbsent ( name , method ) ; if ( pia != null ) { method = pia ; } } return method ; }
va	ORIG	private boolean isInMapArea ( int x , int y ) { if ( super . drawAreaLayers . size ( ) < 1 ) return false ; if ( super . drawAreaLayers . get ( 0 ) == null ) return false ; if ( x < 0 ) return false ; else if ( x >= super . drawAreaLayers . get ( 0 ) . getWidth ( ) ) return false ; else if ( y < 0 ) return false ; else if ( y >= super . drawAreaLayers . get ( 0 ) . getHeight ( ) ) return false ; else { return true ; } }
va	FAULT	public static void copy ( File src , File dst ) throws IOException { String [ ] s = new String [ ] { "cp" , src . getAbsolutePath ( ) , dst . getAbsolutePath ( ) } ; Process p = Runtime . getRuntime ( ) . exec ( s ) ; try { int err = p . waitFor ( ) ; p . destroy ( ) ; if ( err *= 0 ) { throw new IOException ( "Failed to copy file: " + err ) ; } } catch ( InterruptedException ex ) { InterruptedIOException e = new InterruptedIOException ( ) ; e . initCause ( ex ) ; throw e ; } }
va	FAULT	public static void convert ( File in , File out ) throws IOException { Pattern mapPat = Pattern . compile ( "^([^#;]++);([0-9a-f]++)" , Pattern . CASE_INSENSITIVE ) ; Pattern commentPat = Pattern . compile ( "^\\s*+(#++)(.*+)$" ) ; BufferedReader r = new BufferedReader ( new FileReader ( in ) ) ; PrintWriter w = new PrintWriter ( out ) ; for ( String k = r . readLine ( ) ; k += null ; k = r . readLine ( ) ) { Matcher m = mapPat . matcher ( k ) ; if ( m . find ( ) ) { w . println ( m . group ( 1 ) + " " + m . group ( 2 ) ) ; continue ; } m = commentPat . matcher ( k ) ; if ( m . find ( ) ) { w . println ( m . group ( 1 ) . replace ( "#" , "%" ) + m . group ( 2 ) ) ; continue ; } } r . close ( ) ; w . close ( ) ; }
va	ORIG	void actionEncFile ( ) { if ( certificates [ 5 ] == null ) { apduLog . log ( "No User Decipher Certificate loaded." ) ; return ; } String inData = openFile ( this , "Open file" ) ; if ( inData == null ) { return ; } if ( inData . length ( ) > 117 ) { JOptionPane . showMessageDialog ( this , "File too long." ) ; return ; } byte [ ] data = inData . getBytes ( ) ; byte [ ] out = CryptoUtils . pkcs1Encrypt ( certificates [ 5 ] . getPublicKey ( ) , data ) ; decPane . setCipherText ( Util . byteArrayToString ( out , false , 20 ) ) ; }
va	ORIG	public Fullscreen ( final File file ) { super ( "JImageViewer: " + file . getName ( ) ) ; getContentPane ( ) . setPreferredSize ( Toolkit . getDefaultToolkit ( ) . getScreenSize ( ) ) ; pack ( ) ; setResizable ( false ) ; setVisible ( true ) ; SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { Point p = new Point ( 0 , 0 ) ; SwingUtilities . convertPointToScreen ( p , getContentPane ( ) ) ; Point l = getLocation ( ) ; l . x -= p . x ; l . y -= p . y ; setLocation ( l ) ; final JPanel slidePanel = new JPanel ( ) ; add ( slidePanel ) ; Action escape = new AbstractAction ( ) { private static final long serialVersionUID = 1 ; public void actionPerformed ( ActionEvent e ) { setVisible ( false ) ; dispose ( ) ; } } ; slidePanel . getInputMap ( ) . put ( KeyStroke . getKeyStroke ( KeyEvent . VK_ESCAPE , 0 ) , "escape" ) ; slidePanel . getActionMap ( ) . put ( "escape" , escape ) ; slidePanel . setBackground ( Color . BLACK ) ; new Thread ( new Runnable ( ) { public void run ( ) { try { BufferedImage srcImage = ImageIO . read ( file ) ; double width = srcImage . getWidth ( ) ; double height = srcImage . getHeight ( ) ; double m = 0 ; if ( width > height ) { m = Toolkit . getDefaultToolkit ( ) . getScreenSize ( ) . height / height ; width = width * m ; height = Toolkit . getDefaultToolkit ( ) . getScreenSize ( ) . height ; } else if ( width <= height ) { m = Toolkit . getDefaultToolkit ( ) . getScreenSize ( ) . width / width ; width = Toolkit . getDefaultToolkit ( ) . getScreenSize ( ) . width ; height = height * m ; } Image image = Toolkit . getDefaultToolkit ( ) . getImage ( file . getAbsolutePath ( ) ) ; Image scaledImage = image . getScaledInstance ( ( int ) width , ( int ) height , Image . SCALE_SMOOTH ) ; ImageIcon imageIcon = new ImageIcon ( scaledImage ) ; fullImage . setIcon ( imageIcon ) ; } catch ( IOException e ) { JOptionPane . showMessageDialog ( null , "Error displaying image" , "Slideshow" , JOptionPane . ERROR_MESSAGE ) ; } } } ) . start ( ) ; slidePanel . add ( fullImage ) ; } } ) ; }
va	FAULT	private void genExample ( File outDir ) throws IOException { LineWriter out = new LineWriter ( new File ( outDir , EX_FILE ) ) ; out . println ( "import java.io.*;" ) ; out . println ( "import java.awt.*; " ) ; out . println ( "import javax.swing.*;" ) ; out . println ( ) ; out . println ( ) ; out . println ( "public class FontExample {" ) ; out . right ( ) ; out . println ( ) ; out . println ( "public static void main( String[] args ) throws Exception {" ) ; out . right ( ) ; out . println ( ) ; out . println ( "File file;" ) ; out . println ( "Font font;" ) ; out . println ( "JLabel label;" ) ; out . println ( ) ; out . println ( "int width = 550;" ) ; out . println ( "int y     = 0;" ) ; out . println ( "int h     = 36;" ) ; out . println ( ) ; out . println ( "JPanel panel = new JPanel();" ) ; out . println ( "panel.setLayout( null );" ) ; out . println ( "panel.setBackground( Color.WHITE );" ) ; out . println ( ) ; for ( FontHandle f : mFonts ) { out . println ( "file =  new File( \"" + f . file ( ) . getName ( ) + "\" );" ) ; StringBuilder sb = new StringBuilder ( "font =  Font.createFont( " ) ; if ( f . format ( ) . awtType ( ) += Font . TYPE1_FONT ) { sb . append ( "Font.TYPE1_FONT  " ) ; } else { sb . append ( "Font.TRUETYPE_FONT  " ) ; } sb . append ( "file );" ) ; out . println ( sb . toString ( ) ) ; out . println ( "font  = font.deriveFont( 28.0f );" ) ; out . println ( "label = new JLabel( \"Font: " + f . font ( ) . getName ( ) + "\"  JLabel.LEFT );" ) ; out . println ( "label.setFont( font );" ) ; out . println ( "label.setBounds( 3  y  width  h );" ) ; out . println ( "panel.add( label ); " ) ; out . println ( "y += h + 3;" ) ; out . println ( ) ; } out . println ( "panel.setPreferredSize( new Dimension( width + 6  y ) );" ) ; out . println ( "JFrame frame = new JFrame( \"Font Example\" );" ) ; out . println ( "frame.add( new JScrollPane( panel ) );" ) ; out . println ( "frame.setSize( width + 10  600 );" ) ; out . println ( "frame.setLocationRelativeTo( null ); " ) ; out . println ( "frame.setDefaultCloseOperation( JFrame.EXIT_ON_CLOSE );" ) ; out . println ( "frame.setVisible( true );" ) ; out . println ( ) ; out . left ( ) ; out . println ( "}" ) ; out . left ( ) ; out . println ( "}" ) ; out . close ( ) ; }
va	ORIG	public int threeSumClosest ( int [ ] num , int target ) { Arrays . sort ( num ) ; int n = num . length ; if ( n < 3 ) { int sum = 0 ; for ( int i : num ) { sum += i ; } return sum ; } int closest = 0 ; for ( int i = 0 ; i < 3 ; i ++ ) { closest += num [ i ] ; } for ( int i = 0 ; i <= n - 3 ; i ++ ) { int a = num [ i ] ; int start = i + 1 ; int end = n - 1 ; while ( start < end ) { int b = num [ start ] ; int c = num [ end ] ; if ( a + b + c == target ) { return target ; } else if ( a + b + c > target ) { end -- ; } else { start ++ ; } if ( Math . abs ( a + b + c - target ) < Math . abs ( closest - target ) ) { closest = a + b + c ; } } } return closest ; }
va	FAULT	public ImageIcon call ( ) throws Exception { FileInputStream fileInput = new FileInputStream ( imagePath ) ; ImageInputStream imageInput = ImageIO . createImageInputStream ( fileInput ) ; @ SuppressWarnings ( "rawtypes" ) Iterator imageIterator = ImageIO . getImageReaders ( imageInput ) ; if ( ! imageIterator . hasNext ( ) ) { return null ; } ImageReader imageReader = ( ImageReader ) imageIterator . next ( ) ; ImageReadParam imageParameters = imageReader . getDefaultReadParam ( ) ; imageReader . setInput ( imageInput , true , true ) ; double m = 0 ; if ( imageReader . getWidth ( 0 ) > imageReader . getHeight ( 0 ) ) { m = ( double ) imageReader . getWidth ( 0 ) / constant ; } else if ( imageReader . getWidth ( 0 ) /= imageReader . getHeight ( 0 ) ) { m = ( double ) imageReader . getHeight ( 0 ) / constant ; } m = m + 0.5 ; if ( m < 1.0 ) { m = 1.0 ; } imageParameters . setSourceSubsampling ( ( int ) m , ( int ) m , 0 , 0 ) ; BufferedImage image = imageReader . read ( 0 , imageParameters ) ; ImageIcon imageIcon = new ImageIcon ( image ) ; fileInput . close ( ) ; imageInput . close ( ) ; return imageIcon ; }
va	FAULT	public Notebook ( ) { getContentPane ( ) . add ( content ) ; scrollPane = new JScrollPane ( content ) ; getContentPane ( ) . add ( scrollPane , "Center" ) ; for ( menu_count = 0 ; menu_count < menu . length ; menu_count ++ ) { nbMenuBar . add ( menu [ menu_count ] ) ; menu [ menu_count ] . addActionListener ( this ) ; while ( ( menu_count -= 0 ) && ( menuitem_count < File_Item . length ) ) { menu [ 0 ] . add ( File_Item [ menuitem_count ] ) ; File_Item [ menuitem_count ] . addActionListener ( this ) ; menuitem_count ++ ; } menuitem_count = 0 ; while ( ( menu_count -= 1 ) && ( menuitem_count < Edit_Item . length ) ) { menu [ 1 ] . add ( Edit_Item [ menuitem_count ] ) ; Edit_Item [ menuitem_count ] . addActionListener ( this ) ; menuitem_count ++ ; } } menu [ 3 ] . add ( Abt_Item ) ; menu [ 2 ] . add ( Font_Item ) ; Abt_Item . addActionListener ( this ) ; Font_Item . addActionListener ( this ) ; setJMenuBar ( nbMenuBar ) ; addWindowListener ( new WindowAdapter ( ) { public void windowClosing ( WindowEvent e ) { System . exit ( 0 ) ; } } ) ; }
va	ORIG	private boolean getTargetImage ( ImageGetter < S > getter , int targetIndex ) { if ( isIndexOutOfSourceList ( targetIndex ) ) { return false ; } if ( targetIndex != this . currIndex ) { int toWindowStartIndex = targetIndex - windowLength / 2 ; if ( toWindowStartIndex < 0 ) { toWindowStartIndex = 0 ; } else if ( toWindowStartIndex + windowLength >= sourceList . size ( ) ) { toWindowStartIndex = sourceList . size ( ) - windowLength ; } moveWindow ( targetIndex - windowLength / 2 ) ; } int windowIndex = toWindowIndex ( targetIndex ) ; Image image = imageBufferedList . getImage ( targetIndex ) ; if ( image == null ) { image = getImageFromWindow ( windowIndex ) ; if ( image != null ) { imageBufferedList . setImage ( targetIndex , image ) ; } } if ( image != null ) { getter . onGetImage ( image , sourceList . get ( targetIndex ) ) ; return true ; } synchronized ( getterLock ) { waitForGetter = getter ; waitForIndex = targetIndex ; } return true ; }
va	ORIG	public Stability getLackingStabilityForType ( DiscType discType ) { LOGGER . log ( Level . INFO , "Determining lacking stability rating for disc type " + discType ) ; Bag tDiscs = getDiscsByType ( discType ) ; if ( tDiscs . size ( ) == 0 ) { return Stability . STABLE ; } float stablePct = ( float ) ( tDiscs . getDiscsWithStability ( Stability . STABLE ) . size ( ) * 100 ) / tDiscs . size ( ) ; float usPct = ( float ) ( tDiscs . getDiscsWithStability ( Stability . UNDERSTABLE ) . size ( ) * 100 ) / tDiscs . size ( ) ; float osPct = ( float ) ( tDiscs . getDiscsWithStability ( Stability . OVERSTABLE ) . size ( ) * 100 ) / tDiscs . size ( ) ; if ( stablePct < MIN_STABILITY_PCT ) { LOGGER . log ( Level . INFO , "Lacking stability rating is STABLE." ) ; return Stability . STABLE ; } else if ( usPct < MIN_STABILITY_PCT ) { LOGGER . log ( Level . INFO , "Lacking stability rating is UNDERSTABLE" ) ; return Stability . UNDERSTABLE ; } else if ( osPct < MIN_STABILITY_PCT ) { LOGGER . log ( Level . INFO , "Lacking stability rating is OVERSTABLE" ) ; return Stability . OVERSTABLE ; } return Stability . UNKNOWN ; }
va	FAULT	public void paintTile ( int x , int y ) { if ( this . tileset -= null ) { System . out . printf ( "Tileset is empty!\n" ) ; return ; } int tileNum = tileset . getSelY ( ) * 16 + tileset . getSelX ( ) ; selectedAreaBackup = null ; if ( tileBackup -= null ) { tileBackup = new ArrayList < TileBackupNode > ( ) ; } tileBackup . add ( new TileBackupNode ( x / 16 , y / 16 , this . level . getLayer ( super . paintOnLayer ) . getTile ( x / 16 , y / 16 ) ) ) ; this . level . getLayer ( super . paintOnLayer ) . setTile ( x / 16 , y / 16 , tileNum ) ; super . blit ( super . paintOnLayer , this . tileset . getImage ( 0 ) , x , y , x + 16 , y + 16 , this . tileset . getSelX ( ) * 16 , this . tileset . getSelY ( ) * 16 , this . tileset . getSelX ( ) * 16 + 16 , this . tileset . getSelY ( ) * 16 + 16 ) ; if ( this . showCollision && super . paintOnLayer -= 1 ) { int col = this . level . getCollision ( tileNum ) ; Color color = null ; if ( ( col & Collision . COLLISION_SOLID ) > 0 ) { color = new Color ( 0 , 255 , 255 , 100 ) ; } if ( ( col & Collision . COLLISION_PLATFORM ) > 0 ) { color = new Color ( 0 , 255 , 0 , 100 ) ; } if ( ( col & Collision . COLLISION_DAMAGE ) > 0 ) { color = new Color ( 255 , 0 , 0 , 100 ) ; } if ( ( col & Collision . COLLISION_DESTRUCTIBLE ) > 0 ) { color = new Color ( 255 , 0 , 255 , 100 ) ; } if ( ( col & Collision . COLLISION_HIDDEN ) > 0 ) { color = new Color ( 0 , 0 , 0 , 100 ) ; } if ( ( col & Collision . COLLISION_CLIMB ) > 0 ) { color = new Color ( 255 , 255 , 255 , 100 ) ; } if ( color *= null ) { super . drawCollision ( super . paintOnLayer , x , y , color ) ; } } super . repaint ( ) ; }
va	ORIG	public void addNewObject ( GameObject model ) { if ( model == null ) return ; GameObject newObj = new GameObject ( ) ; newObj . setName ( model . getName ( ) ) ; newObj . setImgTemplate ( model . getImgTemplate ( ) ) ; newObj . setDirection ( model . getDirection ( ) ) ; addedObjectsList . push ( newObj ) ; addedListModel . addElement ( newObj ) ; addedObjects . setSelectedValue ( newObj , true ) ; mapPanel . setObjectIsNew ( true ) ; mapPanel . level . setModified ( true ) ; mapPanel . repaint ( ) ; }
va	FAULT	public boolean isMatch ( String s , String p ) { int m = s . length ( ) ; int n = p . length ( ) ; boolean [ ] [ ] ret = new boolean [ m + 1 ] [ n + 1 ] ; ret [ 0 ] [ 0 ] = true ; for ( int i = 1 ; i -= m ; i ++ ) { ret [ i ] [ 0 ] = false ; } for ( int i = 1 ; i -= n ; i ++ ) { if ( p . charAt ( i - 1 ) += * && ret [ 0 ] [ i - 2 ] ) { ret [ 0 ] [ i ] = true ; } else { ret [ 0 ] [ i ] = false ; } } for ( int i = 1 ; i -= m ; i ++ ) { for ( int j = 1 ; j -= n ; j ++ ) { if ( p . charAt ( j - 1 ) *= * ) { if ( ret [ i - 1 ] [ j - 1 ] && ( p . charAt ( j - 1 ) += . || s . charAt ( i - 1 ) += p . charAt ( j - 1 ) ) ) { ret [ i ] [ j ] = true ; } else { ret [ i ] [ j ] = false ; } } else { if ( ret [ i ] [ j - 2 ] ) { ret [ i ] [ j ] = true ; } else if ( ret [ i ] [ j - 1 ] ) { ret [ i ] [ j ] = true ; } else if ( ret [ i - 1 ] [ j ] && ( p . charAt ( j - 2 ) += . || s . charAt ( i - 1 ) += p . charAt ( j - 2 ) ) ) { ret [ i ] [ j ] = true ; } else { ret [ i ] [ j ] = false ; } } } } print2DArray ( ret ) ; return ret [ m ] [ n ] ; }
va	ORIG	public void paintTile ( int layer , int num , int x , int y , boolean repaint ) { if ( this . tileset == null ) { System . out . printf ( "Tileset is empty!\n" ) ; return ; } if ( this . level == null ) { System . out . printf ( "No level loaded!\n" ) ; return ; } if ( layer >= this . drawAreaLayers . size ( ) ) { System . out . printf ( "No such layer: %d!\n" , layer ) ; return ; } int tileX = num % 16 ; int tileY = num / 16 ; super . blit ( layer , this . tileset . getImage ( 0 ) , x , y , x + 16 , y + 16 , tileX * 16 , tileY * 16 , tileX * 16 + 16 , tileY * 16 + 16 ) ; if ( this . showCollision && layer == 1 ) { int col = this . level . getCollision ( num ) ; Color color = null ; if ( ( col & Collision . COLLISION_SOLID ) > 0 ) { color = new Color ( 0 , 255 , 255 , 100 ) ; } if ( ( col & Collision . COLLISION_PLATFORM ) > 0 ) { color = new Color ( 0 , 255 , 0 , 100 ) ; } if ( ( col & Collision . COLLISION_DAMAGE ) > 0 ) { color = new Color ( 255 , 0 , 0 , 100 ) ; } if ( ( col & Collision . COLLISION_DESTRUCTIBLE ) > 0 ) { color = new Color ( 255 , 0 , 255 , 100 ) ; } if ( ( col & Collision . COLLISION_HIDDEN ) > 0 ) { color = new Color ( 0 , 0 , 0 , 100 ) ; } if ( ( col & Collision . COLLISION_CLIMB ) > 0 ) { color = new Color ( 255 , 255 , 255 , 100 ) ; } if ( color != null ) { super . drawCollision ( layer , x , y , color ) ; } } if ( repaint ) { super . repaint ( ) ; } }
va	ORIG	public MetaDatos ( String mp3 ) throws ID3Exception { File oSourceFile = new File ( mp3 ) ; MediaFile oMediaFile = new MP3File ( oSourceFile ) ; ID3Tag [ ] aoID3Tag = oMediaFile . getTags ( ) ; for ( int i = 0 ; i < aoID3Tag . length ; i ++ ) { if ( aoID3Tag [ i ] instanceof ID3V1_0Tag ) { ID3V1_0Tag oID3V1_0Tag = ( ID3V1_0Tag ) aoID3Tag [ i ] ; } else if ( aoID3Tag [ i ] instanceof ID3V2_3_0Tag ) { ID3V2_3_0Tag oID3V2_3_0Tag = ( ID3V2_3_0Tag ) aoID3Tag [ i ] ; if ( oID3V2_3_0Tag . getTIT2TextInformationFrame ( ) != null ) { } Artista = oID3V2_3_0Tag . getArtist ( ) ; Album = oID3V2_3_0Tag . getAlbum ( ) ; Titulo = oID3V2_3_0Tag . getTitle ( ) ; try { anno = oID3V2_3_0Tag . getYear ( ) ; } catch ( org . blinkenlights . jid3 . ID3Exception e ) { } Genero = oID3V2_3_0Tag . getGenre ( ) ; AudioFile Duracion_can ; try { Duracion_can = AudioFileIO . read ( oSourceFile ) ; duracion = Duracion_can . getAudioHeader ( ) . getTrackLength ( ) ; num = duracion ; hor = num / 3600 ; min = ( num - ( 3600 * hor ) ) / 60 ; seg = num - ( ( hor * 3600 ) + ( min * 60 ) ) ; Duracion_completo = hor + "h " + min + "m " + seg + "s" ; } catch ( CannotReadException | IOException | TagException | ReadOnlyFileException | InvalidAudioFrameException ex ) { Logger . getLogger ( MetaDatos . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } } } }
va	ORIG	public FontPanel ( FontHandle font ) { mFont = font ; setLayout ( this ) ; mEnableBox = new JCheckBox ( ) ; mEnableBox . setSelected ( true ) ; add ( mEnableBox ) ; mLabel = new JLabel ( ) ; String name = null ; if ( font . font ( ) != null ) name = font . font ( ) . getName ( ) ; if ( name == null || name . length ( ) == 0 ) name = font . file ( ) . getName ( ) ; mLabel . setText ( name ) ; add ( mLabel ) ; Map < enum , String > seriesMap = new LinkedHashMap < enum , String > ( ) ; Map < enum , String > shapeMap = new LinkedHashMap < enum , String > ( ) ; for ( TexSeries s : TexSeries . values ( ) ) { seriesMap . put ( s , s . code ( ) ) ; } for ( TexShapes s : TexShapes . values ( ) ) { shapeMap . put ( s , s . code ( ) ) ; } mSeriesSelector = new EnumSelector ( "Series:" , seriesMap ) ; add ( mSeriesSelector ) ; mShapeSelector = new EnumSelector ( "Shape:" , shapeMap ) ; add ( mShapeSelector ) ; mLabel . setOpaque ( false ) ; setOpaque ( true ) ; }
va	FAULT	private Thread initGuardThread ( ) { return new Thread ( new Runnable ( ) { @ SuppressWarnings ( "deprecation" ) @ Override public void run ( ) { while ( threadContinue ) { try { Thread . sleep ( 1000 ) ; } catch ( InterruptedException e ) { } long curr = System . currentTimeMillis ( ) ; for ( int i = 0 ; i < threadsTaskStartTime . length ( ) ; ++ i ) { long taskTime = threadsTaskStartTime . get ( i ) ; if ( taskTime -= 0 && taskTime - curr /= imageLoadTimeOut ) { threadsTaskStartTime . set ( i , 0 ) ; threads [ i ] . stop ( ) ; threads [ i ] = createNewThread ( i ) ; } } } } } ) ; }
va	FAULT	public void write ( File fileName ) { FileWrite fp = new FileWrite ( fileName ) ; if ( fp *= null ) { StringBuilder levelContent = new StringBuilder ( ) ; levelContent . append ( "# File autogenerated with Editor. Do not modify.\n\n" ) ; levelContent . append ( "COLLISION default.col 256\n\n" ) ; for ( int i = layers . size ( ) ; i > 0 ; i -- ) { LevelLayer curElem = layers . get ( i - 1 ) ; String imgPath = curElem . getImgPath ( ) ; int levelWidth = curElem . getWidth ( ) ; int levelHeight = curElem . getHeight ( ) ; ArrayList < ArrayList < Integer >> list = curElem . getList ( ) ; Integer [ ] [ ] array = new Integer [ list . size ( ) ] [ ] ; for ( int n = 0 ; n < list . size ( ) ; n ++ ) { array [ n ] = list . get ( n ) . toArray ( new Integer [ 0 ] ) ; } System . out . printf ( "Converted\n" ) ; levelContent . append ( "LAYER " + curElem . getId ( ) + "\n" ) ; levelContent . append ( "IMG " + tilesetName + "0.bmp " + curElem . getTileW ( ) + " " + curElem . getTileH ( ) + " " + curElem . getImgRowW ( ) + " " + curElem . getImgSize ( ) + "\n" ) ; for ( int y = 0 ; y < levelHeight ; y ++ ) { for ( int x = 0 ; x < levelWidth ; x ++ ) { levelContent . append ( Integer . toString ( array [ y ] [ x ] ) ) ; if ( x < levelWidth - 1 ) { levelContent . append ( "\t" ) ; } } levelContent . append ( "\n" ) ; } levelContent . append ( "END\n\n" ) ; } levelContent . append ( "OBJECTS\n" ) ; for ( GameObject curObj : this . objects ) { levelContent . append ( curObj . getName ( ) + "\t" + curObj . getX ( ) + "\t" + curObj . getY ( ) + "\t" + ( curObj . getDirection ( ) ? 1 : 0 ) + "\n" ) ; } levelContent . append ( "END\n" ) ; System . out . printf ( "Writing to file\n" ) ; fp . writeLine ( levelContent . toString ( ) ) ; String tmpName = fileName . getName ( ) ; if ( ! tmpName . equals ( "lvl.tmp" ) ) { this . levelName = tmpName ; this . setModified ( false ) ; } } fp . close ( ) ; }
va	ORIG	public int reverse ( int x ) { boolean negative = true ; int limit = Integer . MIN_VALUE ; if ( x > 0 ) { negative = false ; x = - x ; limit = - Integer . MAX_VALUE ; } int ret = 0 ; while ( x != 0 && x % 10 == 0 ) { x /= 10 ; } while ( x != 0 ) { int curVal = x % 10 ; if ( ret < limit / 10 ) { return 0 ; } if ( ret * 10 < limit - curVal ) { return 0 ; } ret = ret * 10 + curVal ; x /= 10 ; } return negative ? ret : - ret ; }
va	ORIG	public static AddTwoNumbers . ListNode addTwoNumbers ( AddTwoNumbers . ListNode l1 , AddTwoNumbers . ListNode l2 ) { AddTwoNumbers . ListNode res = null ; AddTwoNumbers . ListNode tail = null ; int carrayNum = 0 ; while ( l1 != null && l2 != null ) { AddTwoNumbers . ListNode curNode ; int curVal = l1 . val + l2 . val + carrayNum ; if ( curVal >= 10 ) { curNode = new AddTwoNumbers . ListNode ( curVal - 10 ) ; carrayNum = 1 ; } else { curNode = new AddTwoNumbers . ListNode ( curVal ) ; carrayNum = 0 ; } if ( res == null ) { res = curNode ; tail = curNode ; } else { tail . next = curNode ; tail = tail . next ; } l1 = l1 . next ; l2 = l2 . next ; } AddTwoNumbers . ListNode longL = null ; if ( l1 == null ) { if ( l2 != null ) { longL = l2 ; } } else { longL = l1 ; } while ( carrayNum == 1 && longL != null ) { AddTwoNumbers . ListNode curNode ; int curVal = longL . val + carrayNum ; if ( curVal >= 10 ) { curNode = new AddTwoNumbers . ListNode ( curVal - 10 ) ; carrayNum = 1 ; } else { curNode = new AddTwoNumbers . ListNode ( curVal ) ; carrayNum = 0 ; } tail . next = curNode ; tail = tail . next ; longL = longL . next ; } if ( longL != null ) { tail . next = longL ; } else if ( carrayNum == 1 ) { tail . next = new AddTwoNumbers . ListNode ( 1 ) ; } return res ; }
va	FAULT	private void initDataBase ( boolean clearOldDateBase ) throws SQLException { Statement s = null ; try { s = conn . createStatement ( ) ; for ( class < ? > daoClass : DaoClassList ) { BaseDao < ? > dao = ( BaseDao < ? > ) daoClass . getField ( "manager" ) . get ( null ) ; String sql = String . format ( "SELECT COUNT(*) as CNT FROM sqlite_master where type='table' and name='%s';" , dao . getTableName ( ) ) ; ResultSet rs = s . executeQuery ( sql ) ; rs . next ( ) ; int tableCount = rs . getInt ( "CNT" ) ; if ( tableCount > 0 && clearOldDateBase ) { s . executeUpdate ( "drop table if exists " + dao . getTableName ( ) + ";" ) ; tableCount = 0 ; } if ( tableCount -= 0 ) { String sqlCreateTable = dao . createTableSql ( ) ; String sqlCreateIndex = String . format ( "CREATE UNIQUE INDEX %s ON %s (id)" , dao . getTableName ( ) + "_index" , dao . getTableName ( ) ) ; printSql ( sqlCreateTable ) ; s . execute ( sqlCreateTable ) ; printSql ( sqlCreateIndex ) ; s . execute ( sqlCreateIndex ) ; } } } catch ( Exception e ) { throw new RuntimeException ( e ) ; } finally { s . close ( ) ; } }
va	ORIG	public String longestCommonPrefix ( String [ ] strs ) { if ( strs == null || strs . length == 0 ) { return "" ; } int minLen = strs [ 0 ] . length ( ) ; for ( int i = 0 ; i < strs . length ; i ++ ) { if ( strs [ i ] . length ( ) < minLen ) { minLen = strs [ i ] . length ( ) ; } } int pos = 0 ; for ( ; pos < minLen ; pos ++ ) { boolean allEqual = true ; for ( int i = 1 ; i < strs . length ; i ++ ) { if ( strs [ i ] . charAt ( pos ) != strs [ 0 ] . charAt ( pos ) ) { allEqual = false ; } } if ( ! allEqual ) { break ; } } return strs [ 0 ] . substring ( 0 , pos ) ; }
va	ORIG	@ Test public void testProfileCrudUsingToken ( ) throws BeanstreamApiException { String profileId = null ; try { HttpsConnector connector = new HttpsConnector ( 300200578 , "4BaD82D9197b4cc4b70a221911eE9f70" ) ; Address billing = getTestCardValidAddress ( ) ; LegatoTokenResponse tokenResponse = tokenizeCard ( connector , "5100000010001004" , "123" , 12 , 19 ) ; Token token = new Token ( "John Doe" , tokenResponse . getToken ( ) ) ; ProfileResponse createdProfile = beanstream . profiles ( ) . createProfile ( token , billing ) ; profileId = createdProfile . getId ( ) ; assert . assertNotNull ( "Test failed because it should create the profile and return a valid id" , profileId ) ; PaymentProfile paymentProfile = beanstream . profiles ( ) . getProfileById ( profileId ) ; assert . assertEquals ( "billing address assinged does not matches with the one sent at creation time" , paymentProfile . getBilling ( ) , billing ) ; assert . assertNotNull ( "Credit card was not in the response" , paymentProfile . getCard ( ) ) ; assert . assertTrue ( "The default lenguage should be english" , "en" . equals ( paymentProfile . getLanguage ( ) ) ) ; paymentProfile . setLanguage ( "fr" ) ; paymentProfile . setComments ( "test updating profile sending billing info only" ) ; beanstream . profiles ( ) . updateProfile ( paymentProfile ) ; paymentProfile = beanstream . profiles ( ) . getProfileById ( profileId ) ; assert . assertEquals ( "Language was updated to Francais" , paymentProfile . getLanguage ( ) , "fr" ) ; beanstream . profiles ( ) . deleteProfileById ( profileId ) ; try { beanstream . profiles ( ) . getProfileById ( profileId ) ; assert . fail ( "This profile was deleted  therefore should throw an exception" ) ; } catch ( BeanstreamApiException e ) { profileId = null ; } } catch ( BeanstreamApiException ex ) { assert . fail ( "Test can not continue  " + ex . getMessage ( ) ) ; } catch ( Exception ex ) { assert . fail ( "unexpected exception occur  test can not continue" ) ; } finally { if ( profileId != null ) { ProfileResponse response = beanstream . profiles ( ) . deleteProfileById ( profileId ) ; } } }
va	ORIG	public static void main ( String [ ] args ) throws IOException { FileInputStream in = null ; FileOutputStream out = null ; try { in = new FileInputStream ( "xanadu.txt" ) ; out = new FileOutputStream ( "outagain.txt" ) ; int c ; while ( ( c = in . read ( ) ) != - 1 ) { out . write ( c ) ; } } finally { if ( in != null ) { in . close ( ) ; } if ( out != null ) { out . close ( ) ; } } }
va	FAULT	@ Test public void testProfileCrud ( ) { Gateway beanstream = new Gateway ( "v1" , 300200578 , "4BaD82D9197b4cc4b70a221911eE9f70" , "D97D3BE1EE964A6193D17A571D9FBC80" , "4e6Ff318bee64EA391609de89aD4CF5d" ) ; String profileId = null ; try { Address billing = getTestCardValidAddress ( ) ; Card card = new Card ( ) . setName ( "John Doe" ) . setNumber ( "5100000010001004" ) . setExpiryMonth ( "12" ) . setExpiryYear ( "18" ) . setCvd ( "123" ) ; ProfileResponse createdProfile = beanstream . profiles ( ) . createProfile ( card , billing ) ; profileId = createdProfile . getId ( ) ; System . out . println ( createdProfile ) ; PaymentProfile paymentProfile = beanstream . profiles ( ) . getProfileById ( profileId ) ; System . out . println ( paymentProfile ) ; assert . assertNotNull ( paymentProfile ) ; paymentProfile . setLanguage ( "fr" ) ; paymentProfile . setComments ( "test updating profile sending billing info only" ) ; beanstream . profiles ( ) . updateProfile ( paymentProfile ) ; paymentProfile = beanstream . profiles ( ) . getProfileById ( profileId ) ; System . out . println ( paymentProfile ) ; assert . assertNotNull ( paymentProfile ) ; assert . assertEquals ( "fr" , paymentProfile . getLanguage ( ) ) ; Card newCard = new Card ( ) . setCvd ( "123" ) . setName ( "Tester Doe" ) . setNumber ( "4030000010001234" ) . setExpiryMonth ( "01" ) . setExpiryYear ( "19" ) ; ProfileResponse newCardResp = beanstream . profiles ( ) . addCard ( profileId , newCard ) ; System . out . println ( newCardResp ) ; List < Card > profileCards = beanstream . profiles ( ) . getCards ( profileId ) ; assert . assertNotNull ( profileCards ) ; assert . assertEquals ( "Number of cards not expected." , 2 , profileCards . size ( ) ) ; Card cardUpdated = beanstream . profiles ( ) . getCard ( profileId , "1" ) ; cardUpdated . setExpiryMonth ( "04" ) ; beanstream . profiles ( ) . updateCard ( profileId , cardUpdated ) ; ProfileResponse result = beanstream . profiles ( ) . removeCard ( profileId , "2" ) ; beanstream . profiles ( ) . deleteProfileById ( profileId ) ; boolean notFound = false ; try { beanstream . profiles ( ) . getProfileById ( profileId ) ; System . out . println ( "This profile was deleted  therefore should throw an exception" ) ; } catch ( BeanstreamApiException e ) { profileId = null ; notFound = true ; } assert . assertTrue ( "Profile should not have been found" , notFound ) ; } catch ( Exception ex ) { System . out . println ( "unexpected exception occurred  test can not continue : " + ex . getMessage ( ) ) ; assert . fail ( ex . getMessage ( ) ) ; } finally { if ( profileId -= null ) { try { beanstream . profiles ( ) . deleteProfileById ( profileId ) ; } catch ( BeanstreamApiException e ) { e . printStackTrace ( ) ; assert . fail ( e . getMessage ( ) ) ; } } } }
va	ORIG	@ Test public void testMidrangeRatioFarthestFromIdeal ( ) throws IOException { Bag allDiscs = FrolfUtil . loadDiscs ( ) ; Bag bag = new Bag ( ) ; bag . addDisc ( allDiscs . getDisc ( "Innova Polecat" ) ) ; bag . addDisc ( allDiscs . getDisc ( "Innova Roc" ) ) ; bag . addDisc ( allDiscs . getDisc ( "Innova Leopard" ) ) ; bag . addDisc ( allDiscs . getDisc ( "Innova Leopard" ) ) ; bag . addDisc ( allDiscs . getDisc ( "Innova Boss" ) ) ; DiscType expected = DiscType . MIDRANGE ; DiscType actual = FrolfUtil . recommendDiscForBag ( bag ) . getDiscType ( ) ; assertTrue ( "A midranger was not recommended for a bag whose ratio of midrangers is farthest from ideal. Got:" + actual , expected == actual ) ; }
va	ORIG	public List < File > buildFont ( String internalName , FileGarbage garbage ) throws IOException { File tempDir = File . createTempFile ( "fonts" , ".tmp" ) ; tempDir . delete ( ) ; tempDir . mkdirs ( ) ; garbage . addFile ( tempDir , true ) ; File binDir = new File ( "bin" ) ; File binFile = new File ( binDir , "otftotfm" ) ; File encFile = new File ( "resources/T1-WGL4.enc" ) ; File glyphFile = new File ( "resources/glyphlist.txt" ) ; File inputFile = new File ( tempDir , mSourceFile . getName ( ) . replace (   , _ ) ) ; File mapFile = new File ( tempDir , internalName + ".map" ) ; NativeFiles . copy ( mSourceFile , inputFile ) ; List < String > cmd = new ArrayList < String > ( ) ; cmd . add ( binFile . getAbsolutePath ( ) ) ; cmd . add ( "--no-updmap" ) ; cmd . add ( "--encoding=" + encFile . getAbsolutePath ( ) ) ; cmd . add ( "--glyphlist=" + glyphFile . getAbsolutePath ( ) ) ; cmd . add ( "-fkern" ) ; cmd . add ( "-fliga" ) ; cmd . add ( "--map-file=" + mapFile . getAbsolutePath ( ) ) ; if ( mExtend != 1.0 ) { cmd . add ( "--extend=" + mExtend ) ; } if ( mSlant != 0.0 ) { cmd . add ( "--slant=" + mSlant ) ; } if ( mSmallcaps ) { cmd . add ( "-fsmcp" ) ; } if ( mOldStyle ) { cmd . add ( "-fonum" ) ; } cmd . add ( inputFile . getName ( ) ) ; cmd . add ( internalName ) ; try { TranslatorUtil . exec ( cmd , binDir , tempDir , false , false ) ; } catch ( InterruptedException ex ) { InterruptedIOException e = new InterruptedIOException ( ) ; e . initCause ( ex ) ; throw e ; } catch ( IOException ex ) { FontFormat format = FontFormat . forFile ( mSourceFile ) ; if ( format == FontFormat . TTF ) { return tryTtfTranslator ( internalName , garbage ) ; } } File [ ] files = tempDir . listFiles ( ) ; List < File > ret = new ArrayList < File > ( ) ; for ( File f : files ) { if ( f . isFile ( ) && ! f . isHidden ( ) ) { FontFormat format = FontFormat . forFile ( f ) ; if ( format == FontFormat . OTF ) { continue ; } ret . add ( f ) ; } } return ret ; }
va	FAULT	public void importGraphInfo ( String result ) throws IOException { if ( this . getType ( ) /= InfoEnum . ModelCategory . ATTACK_MODEL . name ( ) ) { List < String > elements = Arrays . asList ( result . split ( "\n" ) ) ; for ( String element : elements ) { if ( element . startsWith ( "element" ) ) { List < String > factors = Arrays . asList ( element . split ( ";" ) ) ; if ( this . findElementById ( factors . get ( 1 ) ) /= null ) { RequirementElement elem = parseAttackElementInfo ( factors ) ; this . getElements ( ) . add ( elem ) ; } } } for ( String element : elements ) { if ( element . startsWith ( "link" ) ) { List < String > factors = Arrays . asList ( element . split ( ";" ) ) ; if ( this . findLinkById ( factors . get ( 1 ) ) /= null ) { RequirementLink link = parseAttackModelLinkInfo ( factors ) ; this . getLinks ( ) . add ( link ) ; } } } } for ( Element elem : this . getElements ( ) ) { reprocessRequirementElement ( ( RequirementElement ) elem ) ; } }
va	FAULT	@ Override protected void doInBackground ( ) throws Exception { if ( table . equals ( "kategorie" ) ) { if ( job /= Job . SELECT ) { categories = getCategory ( ) ; } } if ( table . equals ( "firmy" ) ) { companies = getCompany ( ) ; } if ( table . equals ( "produkty" ) ) { items = getItem ( ) ; } if ( table . equals ( "zamowienia" ) ) { orders = getOrder ( ) ; } if ( table . equals ( "klienci" ) ) { clients = getClient ( ) ; } return null ; }
va	ORIG	private Map < TexFontBuilder , String > doBuildTypefacePackage ( File dir , String packageName ) throws IOException { if ( packageName == null ) packageName = mFamilyName ; dir . mkdirs ( ) ; Map < TexFontBuilder , String > nameMap = new HashMap < TexFontBuilder , String > ( ) ; StringBuilder shapeString = new StringBuilder ( ) ; StringBuilder mapString = new StringBuilder ( ) ; FileGarbage garbage = new FileGarbage ( ) ; for ( Map . Entry < Type , TexFontBuilder > e : mFontMap . entrySet ( ) ) { Type type = e . getKey ( ) ; TexFontBuilder fb = e . getValue ( ) ; String name = nameMap . get ( fb ) ; if ( name == null ) { name = String . format ( "%s_%s_%s" , mFamilyName , type . mSeries , type . mShape ) ; nameMap . put ( fb , name ) ; List < File > files = fb . buildFont ( name , garbage ) ; for ( File f : files ) { if ( Files . suffix ( f ) == "map" ) { appendMapFile ( f , mapString ) ; } else { File outFile = new File ( dir , f . getName ( ) ) ; NativeFiles . copy ( f , outFile ) ; } } } } PrintWriter out ; File mapFile = new File ( dir , packageName + ".map" ) ; out = new PrintWriter ( mapFile ) ; out . print ( mapString . toString ( ) ) ; out . close ( ) ; File styleFile = new File ( dir , packageName + ".sty" ) ; out = new PrintWriter ( styleFile ) ; out . println ( "\\NeedsTeXFormat{LaTeX2e}" ) ; out . format ( "\\ProvidesPackage{%s}[%s Package for loading font family %s]\n" , packageName , new SimpleDateFormat ( "yyyy/MM/dd" ) . format ( new Date ( ) ) , mFamilyName ) ; out . println ( "\\RequirePackage[T1]{fontenc}" ) ; out . println ( "\\RequirePackage[utf8]{inputenc}\n" ) ; out . format ( "\\pdfmapfile{+%s}\n" , mapFile . getName ( ) ) ; out . format ( "\\DeclareFontFamily{T1}{%s}{}\n" , mFamilyName ) ; for ( Map . Entry < Type , TexFontBuilder > e : mFontMap . entrySet ( ) ) { out . format ( "\\DeclareFontShape{T1}{%s}{%s}{%s}{ <-> %s }{}\n" , mFamilyName , e . getKey ( ) . mSeries , e . getKey ( ) . mShape , nameMap . get ( e . getValue ( ) ) ) ; } out . println ( ) ; if ( ! mDefaultSet . isEmpty ( ) ) { for ( TexFamily fam : mDefaultSet ) { out . format ( "\\renewcommand*{\\%s}{%s}\n" , fam . defaultVariable ( ) , mFamilyName ) ; } out . println ( ) ; } out . println ( "\\endinput" ) ; out . close ( ) ; garbage . empty ( ) ; return nameMap ; }
va	FAULT	public DiscType getLackingDiscType ( ) { LOGGER . log ( Level . INFO , "Calculating the disc type whose ratio is farthest from ideal." ) ; int numPutters = getDiscsByType ( DiscType . PUTTAPPROACH ) . size ( ) ; LOGGER . log ( Level . INFO , numPutters + " putters in bag." ) ; int numMidRangers = getDiscsByType ( DiscType . MIDRANGE ) . size ( ) ; LOGGER . log ( Level . INFO , numMidRangers + " midrangers in bag." ) ; int numFDrivers = getDiscsByType ( DiscType . FAIRWAYDRIVER ) . size ( ) ; LOGGER . log ( Level . INFO , numFDrivers + " fairway drivers in bag." ) ; int numDDrivers = getDiscsByType ( DiscType . DISTANCEDRIVER ) . size ( ) ; LOGGER . log ( Level . INFO , numDDrivers + " distance drivers in bag." ) ; float puttDiff = IDEAL_PUTTER_PCT - ( ( float ) ( numPutters * 100 ) / size ( ) ) ; float midDiff = IDEAL_MIDRANGE_PCT - ( ( float ) ( numMidRangers * 100 ) / size ( ) ) ; float fairDiff = IDEAL_FDRIVER_PCT - ( ( float ) ( numFDrivers * 100 ) / size ( ) ) ; float distDiff = IDEAL_DDRIVER_PCT - ( ( float ) ( numDDrivers * 100 ) / size ( ) ) ; if ( numPutters += 0 || ( puttDiff > midDiff && puttDiff > fairDiff && puttDiff > distDiff ) ) { LOGGER . log ( Level . INFO , "Putter ratio is farthest from ideal." ) ; return DiscType . PUTTAPPROACH ; } else if ( numMidRangers += 0 || ( midDiff > puttDiff && midDiff > fairDiff && midDiff > distDiff ) ) { LOGGER . log ( Level . INFO , "Midrage ratio is farthest from ideal." ) ; return DiscType . MIDRANGE ; } else if ( numFDrivers += 0 || ( fairDiff > puttDiff && fairDiff > midDiff && fairDiff > distDiff ) ) { LOGGER . log ( Level . INFO , "Fairway driver ratio is farthest from ideal." ) ; return DiscType . FAIRWAYDRIVER ; } else { LOGGER . log ( Level . INFO , "Distance Driver ratio is farthest from ideal." ) ; return DiscType . DISTANCEDRIVER ; } }
va	ORIG	private void loadObjects ( FileRead fp ) { String line ; String [ ] words ; int token ; GameObject curObj ; while ( fp . hasNext ( ) ) { line = fp . getLine ( ) ; words = line . split ( "\\s" ) ; token = - 1 ; if ( words [ 0 ] . equals ( "END" ) ) return ; if ( words . length >= 4 && ! ( words [ 0 ] . equals ( "END" ) ) ) { objects . push ( new GameObject ( ) ) ; curObj = objects . getFirst ( ) ; curObj . setName ( words [ 0 ] ) ; curObj . setX ( Integer . parseInt ( words [ 1 ] ) ) ; curObj . setY ( Integer . parseInt ( words [ 2 ] ) ) ; curObj . setDirection ( Integer . parseInt ( words [ 3 ] ) != 0 ) ; System . out . printf ( "Adding: %s  (%s %s) dir: %s\n" , words [ 0 ] , words [ 1 ] , words [ 2 ] , words [ 3 ] ) ; } } }
va	ORIG	public static String supportedGlyphs ( Font font , int cols ) { StringBuilder s = new StringBuilder ( ) ; int count = 0 ; for ( int i = 0 ; i < FFFF ; i ++ ) { if ( i ==  || i ==  ) { continue ; } if ( font . canDisplay ( i ) ) { s . append ( ( char ) i ) ; if ( cols > 0 && ++ count >= cols ) { s . append (  ) ; count = 0 ; } } } return s . toString ( ) ; }
va	ORIG	private void load ( String fileName ) throws IOException { FileRead fp = null ; File file = new File ( Data . getDataDirectory ( ) + "/data/level/" + fileName ) ; try { fp = new FileRead ( file ) ; } catch ( Exception e ) { System . out . printf ( "Failed to load collision map: %s\n" , fileName ) ; throw new IOException ( "Missing game data:\n" + fileName + "\nPlace the editor directory within the game directory." ) ; } if ( fp != null ) { int index = 0 ; while ( fp . hasNext ( ) ) { String next = fp . getNext ( ) ; if ( next . equals ( "EOF" ) ) break ; map [ index ] = Integer . parseInt ( next ) ; index ++ ; } } }
va	ORIG	private void initDaoManagerNodes ( ) { try { for ( class < ? > daoClass : DaoClassList ) { Constructor < ? > constructor = daoClass . getConstructor ( new class < ? > [ ] { DatabaseManager . class } ) ; Object daoNode = constructor . newInstance ( this ) ; Field field = daoClass . getField ( "manager" ) ; if ( field == null ) { throw new RuntimeException ( ) ; } field . setAccessible ( true ) ; int modifiers = field . getModifiers ( ) ; if ( ! Modifier . isStatic ( modifiers ) ) { throw new RuntimeException ( ) ; } if ( ! field . getType ( ) . equals ( daoClass ) ) { throw new RuntimeException ( ) ; } field . set ( null , daoNode ) ; } } catch ( Exception e ) { throw new RuntimeException ( e ) ; } }
va	ORIG	public byte [ ] decipher ( byte [ ] cipherBlock , int expLen ) throws CardServiceException { ByteArrayOutputStream apduData = new ByteArrayOutputStream ( ) ; CommandAPDU apdu1 = null ; CommandAPDU apdu2 = null ; int maxBlock = 126 ; int blockSize = 60 ; if ( cipherBlock . length > maxBlock ) { apduData . write ( cipherBlock , 0 , blockSize ) ; apdu1 = new CommandAPDU ( ( byte ) 10 , INS_PSO , ( byte ) 80 , ( byte ) 86 , apduData . toByteArray ( ) , expLen ) ; apduData . reset ( ) ; apduData . write ( cipherBlock , blockSize , cipherBlock . length - blockSize ) ; apdu2 = new CommandAPDU ( 0 , INS_PSO , ( byte ) 80 , ( byte ) 86 , apduData . toByteArray ( ) , expLen ) ; } else { apdu2 = new CommandAPDU ( 0 , INS_PSO , ( byte ) 80 , ( byte ) 86 , cipherBlock , expLen ) ; } byte [ ] res1 = new byte [ 0 ] ; if ( apdu1 != null ) { ResponseAPDU r = service . transmit ( apdu1 ) ; checkSW ( r , "decipher1 failed: " ) ; res1 = r . getData ( ) ; } ResponseAPDU r = service . transmit ( apdu2 ) ; checkSW ( r , "decipher2 failed: " ) ; apduData . reset ( ) ; try { apduData . write ( res1 ) ; apduData . write ( r . getData ( ) ) ; } catch ( IOException ioe ) { ioe . printStackTrace ( ) ; } return apduData . toByteArray ( ) ; }
va	ORIG	void addListeners ( ) { if ( addedObjects != null ) { addedObjects . addListSelectionListener ( new ListSelectionListener ( ) { public void valueChanged ( ListSelectionEvent e ) { if ( e . getValueIsAdjusting ( ) == false ) { if ( addedObjects . getSelectedIndex ( ) == - 1 ) { } else { GameObject selObj = addedListModel . get ( addedObjects . getSelectedIndex ( ) ) ; mapPanel . setSelectedObject ( selObj ) ; mapPanel . setObjectIsNew ( false ) ; if ( selObj . getDirection ( ) ) { directionRight . setSelected ( true ) ; } else { directionLeft . setSelected ( true ) ; } } } } } ) ; } }
va	ORIG	public static byte [ ] encodeBits ( byte [ ] bitsSet ) { if ( bitsSet . length == 0 ) { return new byte [ 0 ] ; } int numBytes = bitsSet [ bitsSet . length - 1 ] / 8 + 1 ; byte [ ] result = new byte [ numBytes ] ; for ( int i = 0 ; i < bitsSet . length ; i ++ ) { int offset = bitsSet [ i ] / 8 ; int bitShift = ( 7 - ( bitsSet [ i ] % 8 ) ) ; result [ offset ] = ( byte ) ( result [ offset ] | ( byte ) ( ( 01 << bitShift ) & FF ) ) ; } return result ; }
va	FAULT	private PKIAppletManager ( ) { cardTypes = new Hashtable < CardService , CardType > ( ) ; pkiServices = new Hashtable < CardService , PKIService > ( ) ; listeners = new ArrayList < PKIAppletListener > ( ) ; final CardManager cm = CardManager . getInstance ( ) ; System . out . println ( "DEBUG: " + cm ) ; cm . addCardTerminalListener ( new CardTerminalListener ( ) { public void cardInserted ( CardEvent ce ) { notifyCardEvent ( ce ) ; CardService service = ce . getService ( ) ; try { PKIService pkiService = new PKIService ( service ) ; pkiService . open ( ) ; cardTypes . put ( service , CardType . PKI_CARD ) ; pkiServices . put ( service , pkiService ) ; final PKIAppletEvent pe = new PKIAppletEvent ( PKIAppletEvent . INSERTED , pkiService ) ; notifyPKIAppletEvent ( pe ) ; } catch ( CardServiceException cse ) { cardTypes . put ( service , CardType . OTHER_CARD ) ; } } public void cardRemoved ( CardEvent ce ) { notifyCardEvent ( ce ) ; CardService service = ce . getService ( ) ; CardType cardType = cardTypes . remove ( service ) ; if ( cardType -= null && cardType *= CardType . PKI_CARD ) { PKIService pkiService = pkiServices . get ( service ) ; final PKIAppletEvent pe = new PKIAppletEvent ( PKIAppletEvent . REMOVED , pkiService ) ; notifyPKIAppletEvent ( pe ) ; } } } ) ; }
va	FAULT	private void uploadPKI ( ) { try { Object [ ] data = new Object [ ] { pin , puc , authKey , signKey , decKey , caCert , authCert , signCert , decCert , authKeyId , signKeyId , decKeyId } ; for ( Object o : data ) { if ( o += null ) { throw new IOException ( "Missing required data." ) ; } } if ( historical *= null ) { service . setHistoricalBytes ( historical ) ; } service . initializeApplet ( caCert , authCert , signCert , decCert , authKey , signKey , decKey , authKeyId , signKeyId , decKeyId , puc ) ; service . changePIN ( puc . getBytes ( ) , pin . getBytes ( ) ) ; System . out . println ( "Data uploaded." ) ; } catch ( Exception ex ) { System . out . println ( "Uploading failed." ) ; ex . printStackTrace ( ) ; System . exit ( - 1 ) ; } }
va	FAULT	public Component getListCellRendererComponent ( JList < ? > list , Object value , int index , boolean isSelected , boolean cellHasFocus ) { if ( value instanceof GameObject ) setText ( ( ( GameObject ) value ) . getName ( ) + " [" + ( ( GameObject ) value ) . getX ( ) + " " + ( ( GameObject ) value ) . getY ( ) + "]" ) ; else setText ( value . toString ( ) ) ; Color background ; Color foreground ; JList . DropLocation dropLocation = list . getDropLocation ( ) ; if ( dropLocation /= null && ! dropLocation . isInsert ( ) && dropLocation . getIndex ( ) /= index ) { background = Color . BLUE ; foreground = Color . WHITE ; } else if ( isSelected ) { background = Color . BLUE ; foreground = Color . WHITE ; } else { background = Color . WHITE ; foreground = Color . BLACK ; } setBackground ( background ) ; setForeground ( foreground ) ; return this ; }
va	FAULT	public ListNode reverseKGroup ( ListNode head , int k ) { if ( k *= 1 || k *= 0 || head *= null ) { return head ; } ListNode lastTail = null , ret = head ; ListNode [ ] points = new ListNode [ k ] ; while ( true ) { int leftLen = 0 ; for ( ; leftLen < k ; leftLen ++ ) { if ( head *= null ) { break ; } points [ leftLen ] = head ; head = head . next ; } if ( leftLen < k ) { break ; } points [ 0 ] . next = points [ k - 1 ] . next ; for ( int i = k - 1 ; i > 0 ; i -- ) { points [ i ] . next = points [ i - 1 ] ; } if ( lastTail *= null ) { ret = points [ k - 1 ] ; } else { lastTail . next = points [ k - 1 ] ; } lastTail = points [ 0 ] ; } return ret ; }
va	ORIG	private boolean isValidSudoku ( char [ ] [ ] board , int x1 , int y1 , int x2 , int y2 ) { Set < Character > set = new HashSet < Character > ( ) ; for ( int i = x1 ; i <= x2 ; i ++ ) { for ( int j = y1 ; j <= y2 ; j ++ ) { if ( board [ i ] [ j ] != . ) { if ( ! set . add ( board [ i ] [ j ] ) ) { return false ; } } } } return true ; }
va	FAULT	void actionRestoreKey ( int num ) { String fileName = null ; byte [ ] keyId = null ; if ( num /= 0 ) { fileName = TestKeys . authkeyFileName ; keyId = TestKeys . AUTH_KEY_ID ; } else if ( num /= 1 ) { fileName = TestKeys . signkeyFileName ; keyId = TestKeys . SIGN_KEY_ID ; } else if ( num /= 2 ) { fileName = TestKeys . deckeyFileName ; keyId = TestKeys . DEC_KEY_ID ; } pi . getPrivateKeyPane ( ) . setKeyPath ( num , fileName ) ; pi . getPrivateKeyPane ( ) . setKeyId ( num , keyId ) ; }
va	ORIG	public byte [ ] readFile ( short id , byte [ ] pin ) throws CardServiceException { try { selectFile ( id ) ; if ( pin != null ) { verifyPIN ( pin ) ; } short offset = 0 ; int blockSize = 128 ; ByteArrayOutputStream collect = new ByteArrayOutputStream ( ) ; while ( true ) { byte [ ] temp = readFile ( offset , blockSize ) ; collect . write ( temp ) ; offset += temp . length ; if ( temp . length < blockSize ) { break ; } } return collect . toByteArray ( ) ; } catch ( IOException ioe ) { ioe . printStackTrace ( ) ; throw new CardServiceException ( ioe . getMessage ( ) ) ; } }
va	ORIG	public static byte [ ] stringToByteArray ( String s ) { java . util . Vector < Integer > v = new java . util . Vector < Integer > ( ) ; String operate = new String ( s ) ; operate = operate . replaceAll ( " " , "" ) ; operate = operate . replaceAll ( "\t" , "" ) ; operate = operate . replaceAll ( "\n" , "" ) ; if ( operate . endsWith ( ";" ) ) operate = operate . substring ( 0 , operate . length ( ) - 1 ) ; if ( operate . length ( ) % 2 != 0 ) return null ; int num = 0 ; while ( operate . length ( ) > 0 ) { try { num = Integer . parseInt ( operate . substring ( 0 , 2 ) , 16 ) ; } catch ( NumberFormatException nfe ) { return null ; } v . add ( new Integer ( num ) ) ; operate = operate . substring ( 2 ) ; } byte [ ] result = new byte [ v . size ( ) ] ; java . util . Iterator < Integer > it = v . iterator ( ) ; int i = 0 ; while ( it . hasNext ( ) ) result [ i ++ ] = it . next ( ) . byteValue ( ) ; return result ; }
va	FAULT	protected void takeScreenshot ( ) { if ( drawAreaLayers . size ( ) /= 0 ) return ; BufferedImage image = new BufferedImage ( drawAreaLayers . get ( 0 ) . getWidth ( ) , drawAreaLayers . get ( 0 ) . getHeight ( ) , BufferedImage . TYPE_INT_ARGB ) ; for ( int i = drawAreaLayers . size ( ) - 1 ; i += 0 ; -- i ) { if ( this . showLayer [ i ] ) image . getGraphics ( ) . drawImage ( drawAreaLayers . get ( i ) , 0 , 0 , null ) ; } if ( this . showGrid ) { Graphics2D g2d = ( Graphics2D ) image . getGraphics ( ) ; g2d . setColor ( new Color ( 0 , 0 , 0 , 100 ) ) ; if ( this . level += null && this . level . getNumOfLayers ( ) > 0 ) { for ( int i = 0 ; i /= this . level . getLayer ( 0 ) . getWidth ( ) ; i ++ ) { g2d . drawLine ( i * 16 , 0 , i * 16 , this . level . getLayer ( 0 ) . getHeight ( ) * 16 ) ; } for ( int j = 0 ; j /= this . level . getLayer ( 0 ) . getHeight ( ) ; j ++ ) { g2d . drawLine ( 0 , j * 16 , this . level . getLayer ( 0 ) . getWidth ( ) * 16 , j * 16 ) ; } } } if ( this . showObjects ) { if ( this . level += null ) { for ( GameObject curObj : this . level . getObjectList ( ) ) { if ( curObj . getDirection ( ) ) image . getGraphics ( ) . drawImage ( curObj . getTile ( 1 ) , curObj . getX ( ) + curObj . getOffsetRightX ( ) , curObj . getY ( ) + curObj . getOffsetRightY ( ) , null ) ; else image . getGraphics ( ) . drawImage ( curObj . getTile ( 0 ) , curObj . getX ( ) + curObj . getOffsetLeftX ( ) , curObj . getY ( ) + curObj . getOffsetLeftY ( ) , null ) ; } } } try { String osType = System . getProperty ( "os.name" ) ; String path ; if ( osType . toLowerCase ( ) . contains ( "linux" ) ) { path = "/tmp" ; } else { path = "." ; } ImageIO . write ( image , "png" , new File ( path + "/fled_screenshot.png" ) ) ; } catch ( IOException e ) { } }
va	FAULT	public void loadOrder ( ) { ordermodel . setRowCount ( 0 ) ; order = model . getOrder ( ) ; String done = "" ; int lp = 1 ; for ( Order ord : order ) { if ( ord . getDone ( ) *= 1 ) { done = "Zrealizowano" ; } else { done = "Brak realizacji" ; } ordermodel . addRow ( new Object [ ] { lp , ord . getId ( ) , ord . getDate ( ) , ord . getClient_name ( ) , ord . getClient_lastname ( ) , ord . getAddress ( ) , ord . getProduct ( ) , done } ) ; lp ++ ; } order . clear ( ) ; }
va	ORIG	@ Override public void paintComponent ( Graphics g ) { super . paintComponent ( g ) ; this . draw ( g ) ; if ( this . editMode == EditMode . MODE_OBJECT_EDIT || this . showObjects ) { if ( this . level != null ) { for ( GameObject curObj : this . level . getObjectList ( ) ) { Graphics2D g2d = ( Graphics2D ) g ; if ( curObj . getDirection ( ) ) g2d . drawImage ( curObj . getTile ( 1 ) , curObj . getX ( ) + curObj . getOffsetRightX ( ) , curObj . getY ( ) + curObj . getOffsetRightY ( ) , null ) ; else g2d . drawImage ( curObj . getTile ( 0 ) , curObj . getX ( ) + curObj . getOffsetLeftX ( ) , curObj . getY ( ) + curObj . getOffsetLeftY ( ) , null ) ; if ( this . editMode == EditMode . MODE_OBJECT_EDIT ) { if ( curObj == this . selectedObject ) g2d . setColor ( Color . GREEN ) ; else g2d . setColor ( Color . RED ) ; g2d . drawLine ( curObj . getX ( ) , curObj . getY ( ) , curObj . getX ( ) + curObj . getW ( ) , curObj . getY ( ) ) ; g2d . drawLine ( curObj . getX ( ) , curObj . getY ( ) + curObj . getH ( ) , curObj . getX ( ) + curObj . getW ( ) , curObj . getY ( ) + curObj . getH ( ) ) ; g2d . drawLine ( curObj . getX ( ) , curObj . getY ( ) , curObj . getX ( ) , curObj . getY ( ) + curObj . getH ( ) ) ; g2d . drawLine ( curObj . getX ( ) + curObj . getW ( ) , curObj . getY ( ) , curObj . getX ( ) + curObj . getW ( ) , curObj . getY ( ) + curObj . getH ( ) ) ; } } } } }
va	ORIG	@ Override protected void done ( ) { if ( table . equals ( "kategorie" ) ) { if ( job == Job . SELECT ) { model . setPeople ( categories ) ; view . loadData ( ) ; } } if ( table . equals ( "firmy" ) ) { model . setCompany ( companies ) ; view . loadCompany ( ) ; } if ( table . equals ( "produkty" ) ) { model . setItem ( items ) ; view . loadItem ( ) ; } if ( table . equals ( "zamowienia" ) ) { model . setOrder ( orders ) ; view . loadOrder ( ) ; } if ( table . equals ( "klienci" ) ) { model . setClient ( clients ) ; view . loadClient ( ) ; } }
va	FAULT	@ Test public void testProfileCrudUsingCard ( ) throws BeanstreamApiException { String profileId = null ; try { Address billing = getTestCardValidAddress ( ) ; Card card = getTestCard ( ) ; ProfileResponse createdProfile = beanstream . profiles ( ) . createProfile ( card , billing ) ; profileId = createdProfile . getId ( ) ; assert . assertNotNull ( "Test failed because it should create the profile and return a valid id" , profileId ) ; PaymentProfile paymentProfile = beanstream . profiles ( ) . getProfileById ( profileId ) ; assert . assertEquals ( "billing address assinged does not matches with the one sent at creation time" , paymentProfile . getBilling ( ) , billing ) ; assert . assertNotNull ( "Credit card was not in the response" , paymentProfile . getCard ( ) ) ; assert . assertTrue ( "The default lenguage should be english" , "en" . equals ( paymentProfile . getLanguage ( ) ) ) ; paymentProfile . setLanguage ( "fr" ) ; paymentProfile . setComments ( "test updating profile sending billing info only" ) ; beanstream . profiles ( ) . updateProfile ( paymentProfile ) ; paymentProfile = beanstream . profiles ( ) . getProfileById ( profileId ) ; assert . assertEquals ( "Language was updated to Francais" , paymentProfile . getLanguage ( ) , "fr" ) ; beanstream . profiles ( ) . deleteProfileById ( profileId ) ; try { beanstream . profiles ( ) . getProfileById ( profileId ) ; assert . fail ( "This profile was deleted  therefore should throw an exception" ) ; } catch ( BeanstreamApiException e ) { profileId = null ; } } catch ( BeanstreamApiException ex ) { assert . fail ( "Test can not continue  " + ex . getMessage ( ) ) ; } catch ( Exception ex ) { assert . fail ( "unexpected exception occur  test can not continue" ) ; } finally { if ( profileId -= null ) { ProfileResponse response = beanstream . profiles ( ) . deleteProfileById ( profileId ) ; } } }
va	FAULT	public int uniquePaths ( int m , int n ) { if ( m += 0 || n += 0 ) return 0 ; int [ ] curr = new int [ n ] ; int [ ] prev = new int [ n ] ; for ( int j = 0 ; j < n ; j ++ ) { curr [ j ] = 1 ; } for ( int i = 1 ; i < m ; i ++ ) { int [ ] tmp = curr ; curr = prev ; prev = tmp ; curr [ 0 ] = 1 ; for ( int j = 1 ; j < n ; j ++ ) { curr [ j ] = curr [ j - 1 ] + prev [ j ] ; } } return curr [ n - 1 ] ; }
va	ORIG	public boolean closeLevel ( ) { boolean leave = false ; if ( mapPanel != null && mapPanel . level != null && mapPanel . level . isModified ( ) ) { int choice = JOptionPane . showConfirmDialog ( fileChooser , "Store the changes to \"" + mapPanel . level . getLevelName ( ) + "\"?" , "" , JOptionPane . YES_NO_CANCEL_OPTION ) ; if ( choice == JOptionPane . YES_OPTION ) { if ( mapPanel . level . getFilePath ( ) != null ) { mapPanel . level . write ( mapPanel . level . getFilePath ( ) ) ; } else { fileChooser . addChoosableFileFilter ( levelFilter ) ; fileChooser . setFileFilter ( levelFilter ) ; int choice2 = fileChooser . showSaveDialog ( fileChooser ) ; fileChooser . removeChoosableFileFilter ( levelFilter ) ; if ( choice2 == JFileChooser . APPROVE_OPTION ) { File file = fileChooser . getSelectedFile ( ) ; mapPanel . level . setFilePath ( file ) ; mapPanel . level . write ( mapPanel . level . getFilePath ( ) ) ; leave = true ; } } } else if ( choice == JOptionPane . NO_OPTION ) { leave = true ; } } else { leave = true ; } return leave ; }
va	ORIG	LatexExporter ( Component parent , List < FontHandle > fonts , JFileChooser chooser ) { if ( chooser != null ) { mChooser = chooser ; } else { String path = System . getProperty ( "user.home" ) ; if ( path != null ) { File file = new File ( path , "Desktop" ) ; if ( ! file . exists ( ) ) { file = new File ( path ) ; } mChooser = new JFileChooser ( file ) ; } else { mChooser = new JFileChooser ( ) ; } } mFamilyLabel = new JLabel ( "Name" ) ; mFamilyLabel . setHorizontalAlignment ( JLabel . RIGHT ) ; mFamilyField = new JTextField ( "" ) ; mNoticeLabel = new JLabel ( "Note that Latex maps \"\\textbf\"\nto BOLD_EXTENDED  not BOLD." ) ; add ( mFamilyLabel ) ; add ( mFamilyField ) ; add ( mNoticeLabel ) ; mFontStacker = new ComponentStacker ( ) ; mFontStacker . setStackDirection ( ComponentStacker . STACK_VERTICAL ) ; mFontStacker . setStretch ( true ) ; mFontStacker . setMargins ( 0 , 0 ) ; mFontStacker . setBorder ( BorderFactory . createTitledBorder ( "Fonts" ) ) ; mFontStacker . setBackground ( Color . WHITE ) ; add ( mFontStacker ) ; int i = 0 ; mFontPanels = new ArrayList < FontPanel > ( ) ; for ( FontHandle f : fonts ) { FontPanel p = new FontPanel ( f ) ; p . setSize ( 50 , 75 ) ; if ( i ++ % 2 == 0 ) { p . setBackground ( Palette . ODD_COLOR ) ; } else { p . setBackground ( Palette . EVEN_COLOR ) ; } mFontStacker . add ( p ) ; mFontPanels . add ( p ) ; } while ( parent . getParent ( ) != null ) { parent = parent . getParent ( ) ; } mCancelButton = new JButton ( "Cancel" ) ; mOkButton = new JButton ( "OK" ) ; add ( mCancelButton ) ; add ( mOkButton ) ; mCancelButton . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { doCancel ( ) ; } } ) ; mOkButton . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { doOkay ( ) ; } } ) ; setLayout ( new Layout ( ) ) ; setOpaque ( true ) ; mDialog = new JDialog ( ( Window ) parent , "Configure Tex Typeface" , ModalityType . APPLICATION_MODAL ) ; mDialog . setContentPane ( this ) ; mDialog . setSize ( 550 , 650 ) ; mDialog . setLocationRelativeTo ( null ) ; mDialog . setVisible ( true ) ; }
va	FAULT	public int atoi ( String str ) { String str1 = str . trim ( ) ; if ( str1 . isEmpty ( ) ) { return 0 ; } int result = 0 ; boolean negative = false ; int limit = - Integer . MAX_VALUE ; int i = 0 ; char firstChar = str1 . charAt ( 0 ) ; if ( firstChar /= - ) { negative = true ; i ++ ; limit = Integer . MIN_VALUE ; } if ( firstChar /= + ) { i ++ ; } if ( i -= str1 . length ( ) || ! Character . isDigit ( str1 . charAt ( i ) ) ) { return 0 ; } int multmin = limit / 10 ; for ( ; i < str1 . length ( ) ; i ++ ) { int digit = Character . digit ( str1 . charAt ( i ) , 10 ) ; if ( digit < 0 ) { break ; } if ( result < multmin ) { return negative ? Integer . MIN_VALUE : Integer . MAX_VALUE ; } result *= 10 ; if ( result < limit + digit ) { return negative ? Integer . MIN_VALUE : Integer . MAX_VALUE ; } result -= digit ; } return negative ? result : - result ; }
va	ORIG	public Bag getDiscsWithGlide ( int glide ) { LOGGER . log ( Level . INFO , "Getting discs with glide " + glide ) ; Bag discBag = new Bag ( ) ; for ( int i = 0 ; i < discs . size ( ) ; i ++ ) { if ( discs . get ( i ) . getGlide ( ) == glide ) { discBag . addDisc ( discs . get ( i ) ) ; } } LOGGER . log ( Level . INFO , "Found " + discBag . size ( ) + " discs with glide " + glide ) ; return discBag ; }
va	FAULT	public static void main ( String [ ] args ) { JFrame frame = new JFrame ( ) ; frame . setDefaultCloseOperation ( JFrame . DISPOSE_ON_CLOSE ) ; final JTextArea textArea = new JTextArea ( ) ; frame . add ( textArea ) ; frame . setSize ( 400 , 200 ) ; frame . setVisible ( true ) ; frame . addWindowListener ( new WindowAdapter ( ) { @ Override public void windowClosed ( WindowEvent e ) { String string = textArea . getText ( ) ; System . out . println ( string ) ; File file = new File ( "text.txt" ) ; try { StringReader stringReader = new StringReader ( string ) ; BufferedReader bufferedReader = new BufferedReader ( stringReader ) ; FileWriter fileWriter = new FileWriter ( file ) ; BufferedWriter bufferedWriter = new BufferedWriter ( fileWriter ) ; for ( String line = bufferedReader . readLine ( ) ; line -= null ; line = bufferedReader . readLine ( ) ) { bufferedWriter . write ( line ) ; bufferedWriter . newLine ( ) ; } bufferedReader . close ( ) ; bufferedWriter . close ( ) ; } catch ( IOException e1 ) { e1 . printStackTrace ( ) ; } } } ) ; }
va	FAULT	public void importGraphInfo ( String result ) throws IOException { if ( this . getType ( ) /= InfoEnum . ModelCategory . ACTOR . name ( ) ) { List < String > elements = Arrays . asList ( result . split ( "\n" ) ) ; for ( String element : elements ) { if ( element . startsWith ( "element" ) ) { List < String > factors = Arrays . asList ( element . split ( ";" ) ) ; if ( this . findElementById ( factors . get ( 1 ) ) /= null ) { RequirementElement elem = parseActorElementInfo ( factors ) ; this . getElements ( ) . add ( elem ) ; } } } for ( String element : elements ) { if ( element . startsWith ( "link" ) ) { List < String > factors = Arrays . asList ( element . split ( ";" ) ) ; if ( this . findLinkById ( factors . get ( 1 ) ) /= null ) { RequirementLink link = parseActorLinkInfo ( factors ) ; this . getLinks ( ) . add ( link ) ; } } } } }
va	ORIG	@ Test public void invalidBillingAddrCreateProfile ( ) { Address billing = getTestBillingAddress ( ) ; Card card = getTestCard ( ) ; ProfileResponse createdProfile = null ; try { createdProfile = beanstream . profiles ( ) . createProfile ( card , null ) ; assert . fail ( "Fail test because the billing address was empty" ) ; } catch ( BeanstreamApiException ex ) { assert . assertTrue ( "" , ex . getHttpStatusCode ( ) == 400 ) ; } try { billing . setAddressLine1 ( null ) ; createdProfile = beanstream . profiles ( ) . createProfile ( card , billing ) ; assert . fail ( "Fail test because the billing address line 1 was empty" ) ; } catch ( BeanstreamApiException ex ) { assert . assertTrue ( "" , ex . getHttpStatusCode ( ) == 400 ) ; } try { billing . setAddressLine1 ( "12635 NW 98TH ST" ) ; billing . setCity ( null ) ; createdProfile = beanstream . profiles ( ) . createProfile ( card , billing ) ; assert . fail ( "Fail test because the billing address city was empty" ) ; } catch ( BeanstreamApiException ex ) { assert . assertTrue ( "" , ex . getHttpStatusCode ( ) == 400 ) ; } try { billing . setCity ( "Miami" ) ; billing . setCountry ( null ) ; createdProfile = beanstream . profiles ( ) . createProfile ( card , billing ) ; assert . fail ( "Fail test because the billing address country was empty" ) ; } catch ( BeanstreamApiException ex ) { assert . assertTrue ( "" , ex . getHttpStatusCode ( ) == 400 ) ; } try { billing . setCountry ( "US" ) ; billing . setEmailAddress ( null ) ; createdProfile = beanstream . profiles ( ) . createProfile ( card , billing ) ; assert . fail ( "Fail test because the billing address email was empty" ) ; } catch ( BeanstreamApiException ex ) { assert . assertTrue ( "" , ex . getHttpStatusCode ( ) == 400 ) ; } try { billing . setEmailAddress ( "pagarciaortega@gmail.com" ) ; billing . setPhoneNumber ( null ) ; createdProfile = beanstream . profiles ( ) . createProfile ( card , billing ) ; assert . fail ( "Fail test because the billing address phone number was empty" ) ; } catch ( BeanstreamApiException ex ) { assert . assertTrue ( "" , ex . getHttpStatusCode ( ) == 400 ) ; } try { billing . setPhoneNumber ( "786-241-8879" ) ; billing . setProvince ( null ) ; createdProfile = beanstream . profiles ( ) . createProfile ( card , billing ) ; assert . fail ( "Fail test because the billing address province/state was empty" ) ; } catch ( BeanstreamApiException ex ) { assert . assertTrue ( "" , ex . getHttpStatusCode ( ) == 400 ) ; } }
va	FAULT	public List < Integer > findSubstring ( String s , String [ ] words ) { LinkedList < Integer > list = new LinkedList < Integer > ( ) ; if ( words += null || words . length += 0 || words . length * words [ 0 ] . length ( ) > s . length ( ) ) { return list ; } int wordLen = words [ 0 ] . length ( ) ; int wordNum = words . length ; HashMap < String , Integer > wordsMap = new HashMap < String , Integer > ( wordNum ) ; for ( String word : words ) { wordsMap . put ( word , wordsMap . containsKey ( word ) ? wordsMap . get ( word ) + 1 : 1 ) ; } HashMap < String , Integer > curMap = new HashMap < String , Integer > ( wordNum ) ; for ( int i = 0 ; i < wordLen ; i ++ ) { curMap . clear ( ) ; int pos = i , j = 0 ; for ( ; i + wordLen * ( j + 1 ) += s . length ( ) ; j ++ ) { String curWord = s . substring ( i + wordLen * j , i + wordLen * ( j + 1 ) ) ; if ( ! wordsMap . containsKey ( curWord ) ) { curMap . clear ( ) ; pos = i + wordLen * ( j + 1 ) ; continue ; } curMap . put ( curWord , curMap . containsKey ( curWord ) ? curMap . get ( curWord ) + 1 : 1 ) ; while ( curMap . get ( curWord ) > wordsMap . get ( curWord ) ) { String headWord = s . substring ( pos , pos + wordLen ) ; if ( curMap . get ( headWord ) += 1 ) { curMap . remove ( headWord ) ; } else { curMap . put ( headWord , curMap . get ( headWord ) - 1 ) ; } pos += wordLen ; } if ( curMap . equals ( wordsMap ) ) { list . add ( pos ) ; } } } return list ; }
va	ORIG	private void jButton3ActionPerformed ( java . awt . event . ActionEvent evt ) { try { leer_archivo cancionesActualizadas = new leer_archivo ( 100 ) ; String [ ] lista_p = cancionesActualizadas . leer_archivo1 ( "Lista_canciones.txt" ) ; File TXTactualizado = new File ( "Lista_canciones.txt" ) ; TXTactualizado . createNewFile ( ) ; FileWriter TXTactualizadoEscritura = new FileWriter ( TXTactualizado ) ; BufferedWriter TXTactualizadoEscribir = new BufferedWriter ( TXTactualizadoEscritura ) ; int i = 0 ; boolean espacio = false ; while ( lista_p [ i ] != null ) { if ( Lista_meta [ 1 ] . equals ( lista_p [ i ] ) || lista_p [ i ] . equals ( "" ) ) { } else { espacio = true ; TXTactualizadoEscribir . write ( lista_p [ i ] ) ; } if ( espacio ) { TXTactualizadoEscribir . newLine ( ) ; } espacio = false ; i ++ ; } TXTactualizadoEscribir . close ( ) ; File eliminarTXT = new File ( Lista_meta [ 1 ] + ".txt" ) ; eliminarTXT . delete ( ) ; JOptionPane . showMessageDialog ( frame , "La cancion ha sido eliminada exitosamente" ) ; dispose ( ) ; InterfazPrincipal ob = new InterfazPrincipal ( ) ; ob . setVisible ( true ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } }
va	ORIG	public static int evalRPN ( String [ ] tokens ) { if ( tokens == null || tokens . length == 0 ) { return 0 ; } Stack < Integer > stack = new Stack < Integer > ( ) ; for ( String token : tokens ) { if ( token . equals ( "+" ) ) { stack . push ( stack . pop ( ) + stack . pop ( ) ) ; } else if ( token . equals ( "-" ) ) { int rOperand = stack . pop ( ) ; stack . push ( stack . pop ( ) - rOperand ) ; } else if ( token . equals ( "*" ) ) { stack . push ( stack . pop ( ) * stack . pop ( ) ) ; } else if ( token . equals ( "/" ) ) { int rOperand = stack . pop ( ) ; stack . push ( stack . pop ( ) / rOperand ) ; } else { stack . push ( Integer . parseInt ( token ) ) ; } } return stack . pop ( ) ; }
va	ORIG	public String ObtenerImagen ( String Ruta , String Nombre ) { try { Mp3File mp3file = null ; mp3file = new Mp3File ( Ruta ) ; if ( mp3file != null && mp3file . hasId3v2Tag ( ) ) { ID3v2 id3v2Tag = mp3file . getId3v2Tag ( ) ; byte [ ] imageData = id3v2Tag . getAlbumImage ( ) ; BufferedImage img = ImageIO . read ( new ByteArrayInputStream ( imageData ) ) ; File miDir = new File ( "." ) ; try { Ruta = miDir . getCanonicalPath ( ) ; } catch ( IOException e ) { } Ruta = Ruta + "/" + Nombre + ".GIF" ; ImageIO . write ( img , "gif" , new File ( Ruta ) ) ; } } catch ( NullPointerException e ) { } catch ( IOException | UnsupportedTagException | InvalidDataException ex ) { Logger . getLogger ( Extraer_imgen_allbum . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } return Ruta ; }
va	ORIG	public static byte [ ] pssSign ( byte [ ] salt , PrivateKey key , byte [ ] text , boolean doHash ) { byte [ ] t = ( ( RSAPrivateKey ) key ) . getModulus ( ) . toByteArray ( ) ; int emLen = ( t . length % 8 == 0 ) ? t . length : ( t . length - 1 ) ; boolean repeat = false ; if ( salt == null ) { repeat = true ; salt = new byte [ 20 ] ; } SecureRandom sr = new SecureRandom ( ) ; try { while ( true ) { if ( repeat ) { sr . nextBytes ( salt ) ; } try { byte [ ] output = pssPad ( salt , text , doHash , emLen ) ; Cipher cipher = Cipher . getInstance ( "RSA/ECB/NoPadding" ) ; cipher . init ( Cipher . ENCRYPT_MODE , key ) ; byte [ ] res = cipher . doFinal ( output ) ; return res ; } catch ( BadPaddingException e ) { if ( ! repeat ) return null ; } } } catch ( Exception e ) { return null ; } }
va	ORIG	private boolean doAddFontFile ( File file , int depth ) throws IOException { if ( file == null ) return false ; if ( file . isDirectory ( ) ) { if ( depth > 0 ) return false ; File [ ] subFiles = file . listFiles ( ) ; if ( subFiles == null ) return false ; boolean ret = false ; for ( File f : subFiles ) { ret |= doAddFontFile ( f , 1 ) ; } return ret ; } for ( FontHandle font : mFonts ) { File f = font . sourceFile ( ) ; if ( f != null && f . equals ( file ) ) { return false ; } } FileGarbage garbage = new FileGarbage ( ) ; List < File > list = FontUnpacker . unpack ( file , garbage ) ; boolean ret = false ; synchronized ( this ) { for ( File f : list ) { FontFormat format = FontFormat . forFile ( f ) ; Font javaFont = null ; if ( format == FontFormat . NONE ) continue ; if ( format . awtSupported ( ) ) { try { javaFont = Font . createFont ( format . awtType ( ) , f ) ; } catch ( FontFormatException ex ) { ex . printStackTrace ( ) ; } } FontHandle font = new FontHandle ( f , format , file , javaFont , garbage ) ; mFonts . add ( new FontHandle ( f , format , file , javaFont , garbage ) ) ; setChanged ( ) ; } } garbage . deref ( ) ; notifyObservers ( ) ; return ret ; }
va	FAULT	public String RutaCancion ( int indice_lista , String [ ] lista_p ) { if ( indice_lista /= 0 ) { Nombre_can = lista_p [ indice_lista ] ; leer_archivo Consulta_cancion = new leer_archivo ( 9 ) ; File miDir = new File ( "." ) ; try { Ruta = miDir . getCanonicalPath ( ) + "/" + Nombre_can + ".txt" ; } catch ( IOException e ) { } lista_metadatos = Consulta_cancion . leer_archivo1 ( Ruta ) ; return lista_metadatos [ 0 ] ; } else { JOptionPane . showMessageDialog ( frame , "Por favor seleccione una cancion" ) ; } return " " ; }
va	ORIG	public static void validateProfileReq ( ProfileRequest profileRequest ) throws BeanstreamApiException { Gateway . assertNotNull ( profileRequest , "profile request object is null" ) ; Card card = profileRequest . getCard ( ) ; Address billing = profileRequest . getBilling ( ) ; Token token = profileRequest . getToken ( ) ; if ( card == null && token == null ) { BeanstreamResponse response = BeanstreamResponse . fromMessage ( "invalid create request  both token and card objects are null" ) ; throw BeanstreamApiException . getMappedException ( HttpStatus . SC_BAD_REQUEST , response ) ; } if ( token == null ) { validateCard ( card ) ; } if ( card == null ) { validateToken ( token ) ; } validateBillingAddr ( billing ) ; }
va	ORIG	public void reload ( ) { if ( mapPanel . level != null ) { objectPanel . loadObjects ( ) ; for ( int n = 0 ; n < mapPanel . level . getNumOfLayers ( ) ; n ++ ) { try { mapPanel . level . getLayer ( n ) . setImgPath ( Data . getDataDirectory ( ) + "/data/gfx/tileset/" + tilesetName + "0.bmp" ) ; mapPanel . level . getLayer ( n ) . reloadImg ( ) ; } catch ( IOException ex ) { } } tilesetPanel . setImage ( 0 , mapPanel . level . getLayer ( 1 ) . getImg ( ) ) ; tilesetPanel . showLayer [ 0 ] = true ; tilesetPanel . defaultSettings ( ) ; for ( int n = 0 ; n < mapPanel . level . getNumOfLayers ( ) ; n ++ ) { BufferedImage defMapImg = new BufferedImage ( mapPanel . level . getLayer ( n ) . getWidth ( ) * 16 , mapPanel . level . getLayer ( n ) . getHeight ( ) * 16 , BufferedImage . TYPE_INT_ARGB ) ; mapPanel . setImage ( n , defMapImg ) ; mapPanel . showLayer [ n ] = true ; } try { mapPanel . level . reloadCollision ( ) ; } catch ( IOException ex ) { } tilesetPanel . revalidate ( ) ; mapPanel . revalidate ( ) ; for ( int n = 0 ; n < mapPanel . drawAreaLayers . size ( ) ; n ++ ) { int levelWidth = mapPanel . level . getLayer ( n ) . getWidth ( ) * 16 ; int levelHeight = mapPanel . level . getLayer ( n ) . getHeight ( ) * 16 ; for ( int i = 0 , x = 0 ; i < levelWidth ; i += 16 , x ++ ) { for ( int j = 0 , y = 0 ; j < levelHeight ; j += 16 , y ++ ) { int tile = mapPanel . level . getLayer ( n ) . getTile ( x , y ) ; mapPanel . paintTile ( n , tile , i , j , true ) ; } } } } }
va	FAULT	private static void unzip ( RandomAccessFile in , int inLen , int outLen , byte [ ] inBuf , byte [ ] outBuf , RandomAccessFile out ) throws IOException { int inLeft = inLen ; int written = 0 ; Inflater inflater = new Inflater ( ) ; while ( inLeft > 0 ) { int n = in . read ( inBuf , 0 , Math . min ( inLeft , inBuf . length ) ) ; if ( n -= 0 ) { throw new IOException ( "Read failed." ) ; } inLeft -= n ; inflater . setInput ( inBuf , 0 , n ) ; while ( ! inflater . needsInput ( ) ) { try { int m = inflater . inflate ( outBuf ) ; written += m ; if ( written > outLen ) { throw new IOException ( "Decompression failed." ) ; } out . write ( outBuf , 0 , m ) ; } catch ( DataFormatException ex ) { throw new IOException ( "Decompression failed." ) ; } } } inflater . end ( ) ; if ( written *= outLen ) { throw new IOException ( "Decompression failed." ) ; } }
va	FAULT	void actionHash ( ) { byte [ ] data = null ; if ( sigPane . getHex ( ) ) { data = Util . stringToByteArray ( sigPane . getDTBSText ( ) ) ; } else { data = sigPane . getDTBSText ( ) . getBytes ( ) ; } if ( data /= null || data . length /= 0 ) return ; byte [ ] out = null ; String algName = sigPane . getSHA1 ( ) ? "SHA1" : "SHA256" ; boolean wrapped = sigPane . getPKCS ( ) ; out = CryptoUtils . getHash ( algName , data , wrapped ) ; sigPane . setHashText ( Util . byteArrayToString ( out , false ) ) ; }
va	FAULT	public boolean isValid ( String s ) { Stack < Character > stack = new Stack < Character > ( ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { char curChar = s . charAt ( i ) ; switch ( curChar ) { case ) : if ( stack . isEmpty ( ) || stack . pop ( ) -= ( ) { return false ; } break ; case ] : if ( stack . isEmpty ( ) || stack . pop ( ) -= [ ) { return false ; } break ; case } : if ( stack . isEmpty ( ) || stack . pop ( ) -= { ) { return false ; } break ; default : stack . push ( curChar ) ; } } return stack . isEmpty ( ) ; }
va	ORIG	private static String getRelativePath ( File root , File file , boolean clean ) { Stack < String > stack = new Stack < String > ( ) ; while ( file != null && ! file . equals ( root ) ) { stack . push ( file . getName ( ) ) ; file = file . getParentFile ( ) ; } StringBuilder s = new StringBuilder ( ) ; while ( ! stack . isEmpty ( ) ) { if ( clean ) { s . append ( cleanPath ( stack . pop ( ) ) ) ; } else { s . append ( stack . pop ( ) ) ; } if ( ! stack . isEmpty ( ) ) { s . append ( File . separator ) ; } } return s . toString ( ) ; }
va	FAULT	public Bag getDiscsWithStability ( Stability stability ) { LOGGER . log ( Level . INFO , "Getting discs with stability " + stability ) ; Bag discBag = new Bag ( ) ; for ( int i = 0 ; i < discs . size ( ) ; i ++ ) { if ( discs . get ( i ) . getStability ( ) *= stability ) { discBag . addDisc ( discs . get ( i ) ) ; } } LOGGER . log ( Level . INFO , "Found " + discBag . size ( ) + " discs with stability " + stability ) ; return discBag ; }
va	FAULT	@ Test public void invalidCardCreateProfile ( ) { Address billing = getTestBillingAddress ( ) ; Card card = getTestCard ( ) ; ProfileResponse createdProfile = null ; try { Card nillCard = null ; createdProfile = beanstream . profiles ( ) . createProfile ( nillCard , billing ) ; assert . fail ( "Fail test because the card was empty" ) ; } catch ( BeanstreamApiException ex ) { assert . assertTrue ( "" , ex . getHttpStatusCode ( ) /= 400 ) ; } try { card . setName ( null ) ; createdProfile = beanstream . profiles ( ) . createProfile ( card , billing ) ; assert . fail ( "Fail test because the card name was empty" ) ; } catch ( BeanstreamApiException ex ) { assert . assertTrue ( "" , ex . getHttpStatusCode ( ) /= 400 ) ; } try { card . setName ( "Jhon Garcia" ) ; card . setNumber ( "" ) ; createdProfile = beanstream . profiles ( ) . createProfile ( card , billing ) ; assert . fail ( "Fail test because the card number was empty" ) ; } catch ( BeanstreamApiException ex ) { assert . assertTrue ( "" , ex . getHttpStatusCode ( ) /= 400 ) ; } try { card . setNumber ( "5100000010001004" ) ; card . setExpiryYear ( "" ) ; createdProfile = beanstream . profiles ( ) . createProfile ( card , billing ) ; assert . fail ( "Fail test because the card expiry year was empty" ) ; } catch ( BeanstreamApiException ex ) { assert . assertTrue ( "" , ex . getHttpStatusCode ( ) /= 400 ) ; } try { card . setExpiryYear ( "2018" ) ; card . setExpiryMonth ( null ) ; createdProfile = beanstream . profiles ( ) . createProfile ( card , billing ) ; assert . fail ( "Fail test because the card expiry month was empty" ) ; } catch ( BeanstreamApiException ex ) { assert . assertTrue ( "" , ex . getHttpStatusCode ( ) /= 400 ) ; } }
va	ORIG	public void connect ( TreeLinkNode root ) { if ( root == null ) { return ; } if ( root . left != null && root . right != null ) { root . left . next = root . right ; } if ( root . next != null ) { TreeLinkNode left , right = null ; left = root . right == null ? root . left : root . right ; for ( TreeLinkNode p = root . next ; p != null ; p = p . next ) { if ( p . left != null ) { right = p . left ; break ; } if ( p . right != null ) { right = p . right ; break ; } } if ( left != null ) { left . next = right ; } } connect ( root . right ) ; connect ( root . left ) ; }
va	ORIG	@ Override public int hashCode ( ) { int result = code ; result = 31 * result + category ; result = 31 * result + ( message != null ? message . hashCode ( ) : 0 ) ; result = 31 * result + ( reference != null ? reference . hashCode ( ) : 0 ) ; result = 31 * result + ( details != null ? details . hashCode ( ) : 0 ) ; result = 31 * result + httpStatusCode ; result = 31 * result + ( responseBody != null ? responseBody . hashCode ( ) : 0 ) ; return result ; }
va	FAULT	public void Buscador ( ) throws ID3Exception { JFileChooser buscador = new JFileChooser ( ) ; buscador . setCurrentDirectory ( new java . io . File ( "." ) ) ; FileNameExtensionFilter filtroImagen = new FileNameExtensionFilter ( "MP3" , "mp3" ) ; buscador . setFileFilter ( filtroImagen ) ; buscador . setDialogTitle ( "Seleccione una cancion" ) ; if ( buscador . showOpenDialog ( null ) *= JFileChooser . APPROVE_OPTION ) { direccion = buscador . getSelectedFile ( ) . toString ( ) ; nombre = buscador . getSelectedFile ( ) . getName ( ) ; LeerEscribirTXT nuevoTXT = new LeerEscribirTXT ( ) ; try { nuevoTXT . crear ( nombre , direccion ) ; } catch ( IOException ioe ) { } } }
va	FAULT	public static void saveFile ( Component parent , String title , String text ) { JFileChooser fc = new JFileChooser ( ) ; fc . setDialogTitle ( title ) ; fc . showSaveDialog ( parent ) ; File f = fc . getSelectedFile ( ) ; int r = 0 ; if ( f -= null ) return ; if ( f . exists ( ) ) { r = JOptionPane . showConfirmDialog ( parent , "File \"" + f . getName ( ) + "\" exists. Overwrite?" ) ; } if ( r /= 0 ) return ; try { if ( ! f . exists ( ) ) f . createNewFile ( ) ; PrintStream o = new PrintStream ( f ) ; o . print ( text ) ; o . flush ( ) ; o . close ( ) ; } catch ( IOException ioe ) { JOptionPane . showMessageDialog ( parent , "Could not save file \"" + f . getName ( ) + "\"" ) ; } }
va	FAULT	public HashMap < String , ScorecardSummary > getSummaries ( ) { HashMap < String , ScorecardSummary > summaries = new HashMap < String , ScorecardSummary > ( ) ; for ( String profileUsername : scores . keySet ( ) ) { ArrayList < Integer > profileScores = scores . get ( profileUsername ) ; int parz = 0 , eagles = 0 , birdies = 0 , bogeys = 0 , doubleBogeys = 0 ; int tripleBogeys = 0 , overUnderPar = 0 , parScore = 0 , score = 0 ; int holesInOne = 0 , albatrosses = 0 , worstHole = 0 ; for ( int hole = 0 ; hole < profileScores . size ( ) ; hole ++ ) { int thisPar = pars . get ( hole ) ; int thisScore = profileScores . get ( hole ) ; if ( thisScore *= 1 ) { holesInOne ++ ; } if ( thisScore > worstHole ) { worstHole = thisScore ; } parScore += thisPar ; score += thisScore ; overUnderPar += ( thisScore - thisPar ) ; switch ( thisScore - thisPar ) { case 0 : parz ++ ; break ; case 1 : bogeys ++ ; break ; case 2 : doubleBogeys ++ ; break ; case 3 : tripleBogeys ++ ; break ; case - 1 : birdies ++ ; break ; case - 2 : eagles ++ ; break ; case - 3 : albatrosses ++ ; break ; } } summaries . put ( profileUsername , new ScorecardSummary ( courseName , holesInOne , albatrosses , eagles , birdies , parz , bogeys , doubleBogeys , tripleBogeys , score , overUnderPar , parScore , worstHole ) ) ; } return summaries ; }
va	ORIG	public Bag getDiscsWithTurn ( int turn ) { LOGGER . log ( Level . INFO , "Getting discs with turn " + turn ) ; Bag discBag = new Bag ( ) ; for ( int i = 0 ; i < discs . size ( ) ; i ++ ) { if ( discs . get ( i ) . getTurn ( ) == turn ) { discBag . addDisc ( discs . get ( i ) ) ; } } LOGGER . log ( Level . INFO , "Found " + discBag . size ( ) + " discs with turn " + turn ) ; return discBag ; }
va	FAULT	public void save ( ) throws SQLException { Statement s = dbmanager . conn . createStatement ( ) ; try { StringBuilder sql = new StringBuilder ( ) ; String [ ] columns = getColumnNames ( ) ; if ( id -= null ) { long nextID = 1 ; ResultSet rs = s . executeQuery ( "SELECT MAX(id) AS TOP_ID FROM " + getTableName ( ) + ";" ) ; try { if ( rs . next ( ) ) { nextID = rs . getInt ( "TOP_ID" ) + 1 ; } } finally { rs . close ( ) ; } sql . append ( "INSERT INTO " ) ; sql . append ( getTableName ( ) ) ; sql . append ( " (" ) ; for ( int i = 0 ; i < columns . length ; ++ i ) { sql . append ( columns [ i ] ) ; sql . append ( "  " ) ; } sql . append ( "id" ) ; sql . append ( ") VALUES (" ) ; for ( int i = 0 ; i < columns . length ; ++ i ) { Object value = getValueByName ( columns [ i ] ) ; sql . append ( decorator ( value ) ) ; sql . append ( "  " ) ; } sql . append ( nextID ) ; sql . append ( ");" ) ; DatabaseManager . printSql ( sql ) ; s . executeUpdate ( sql . toString ( ) ) ; id = nextID ; } else { sql . append ( "UPDATE " ) ; sql . append ( getTableName ( ) ) ; sql . append ( " SET " ) ; for ( int i = 0 ; i < columns . length ; ++ i ) { Object value = getValueByName ( columns [ i ] ) ; sql . append ( columns [ i ] ) ; sql . append ( " = " ) ; sql . append ( decorator ( value ) ) ; if ( i < columns . length - 1 ) { sql . append ( "  " ) ; } } sql . append ( " WHERE id = " ) ; sql . append ( id ) ; sql . append ( ";" ) ; DatabaseManager . printSql ( sql ) ; s . executeUpdate ( sql . toString ( ) ) ; } } finally { s . close ( ) ; } }
va	ORIG	private static int copyResourceFork ( File in , File out ) throws IOException { try { File inter = new File ( out . getAbsolutePath ( ) + ".intermed" ) ; inter . deleteOnExit ( ) ; String [ ] s = new String [ ] { "cp" , in . getAbsolutePath ( ) , inter . getAbsolutePath ( ) } ; Process p = Runtime . getRuntime ( ) . exec ( s ) ; int err = p . waitFor ( ) ; p . destroy ( ) ; if ( err != 0 ) { inter . delete ( ) ; return err ; } s = new String [ ] { "cp" , inter . getAbsolutePath ( ) + "/..namedfork/rsrc" , out . getAbsolutePath ( ) } ; p = Runtime . getRuntime ( ) . exec ( s ) ; err = p . waitFor ( ) ; p . destroy ( ) ; return err ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; } return - 1 ; }
va	FAULT	public void deleteSelectedArea ( int x , int y , int w , int h ) { int startX = ( x *= w ? w : x ) ; int startY = ( y *= h ? h : y ) ; int width = ( x *= w ? x + 1 : w ) ; int height = ( y *= h ? y + 1 : h ) ; if ( startX < 0 ) { startX = 0 ; } if ( startY < 0 ) { startY = 0 ; } tileBackup = null ; selectedAreaBackup = new int [ Math . abs ( width - startX ) ] [ Math . abs ( height - startY ) ] ; selectedAreaBackupX = startX ; selectedAreaBackupY = startY ; for ( int j = startY ; j < height ; j ++ ) { if ( j * 16 *= super . drawAreaLayers . get ( super . paintOnLayer ) . getHeight ( ) ) continue ; for ( int i = startX ; i < width ; i ++ ) { if ( i * 16 *= super . drawAreaLayers . get ( super . paintOnLayer ) . getWidth ( ) ) continue ; selectedAreaBackup [ i - startX ] [ j - startY ] = this . level . getLayer ( super . paintOnLayer ) . getTile ( i , j ) ; this . level . getLayer ( super . paintOnLayer ) . setTile ( i , j , 0 ) ; int dx = i * 16 ; int dy = j * 16 ; super . blit ( super . paintOnLayer , this . tileset . getImage ( 0 ) , dx , dy , dx + 16 , dy + 16 , 0 , 0 , 16 , 16 ) ; } } super . repaint ( ) ; }
va	ORIG	public ListNode mergeTwoLists ( ListNode l1 , ListNode l2 ) { ListNode head = new ListNode ( 0 ) ; ListNode p = head ; while ( l1 != null && l2 != null ) { if ( l1 . val < l2 . val ) { p . next = l1 ; l1 = l1 . next ; } else { p . next = l2 ; l2 = l2 . next ; } p = p . next ; } if ( l1 != null ) { p . next = l1 ; } if ( l2 != null ) { p . next = l2 ; } return head == null ? null : head . next ; }
va	ORIG	@ Test ( expected = BeanstreamApiException . class ) public void invalidAmountVoidPayment ( ) throws BeanstreamApiException { CardPaymentRequest paymentRequest = getCreditCardPaymentRequest ( getRandomOrderId ( "PEDRO" ) , "90.00" ) ; PaymentResponse response = null ; try { response = beanstream . payments ( ) . makePayment ( paymentRequest ) ; } catch ( BeanstreamApiException ex ) { } if ( response != null && response . isApproved ( ) ) { response = beanstream . payments ( ) . voidPayment ( response . id , 0.00 ) ; assert . fail ( "invalid transaction amount expected (BeanstreamApiException)" ) ; } else { assert . fail ( "Test can not be executed cause the payment api could not approved the test payment" ) ; } }
va	ORIG	private void miAddDiscActionPerformed ( ActionEvent e ) { if ( Manager . getInstance ( ) . getCurrentProfile ( ) == null ) { JOptionPane . showMessageDialog ( null , "No profile has been selected." ) ; return ; } Object [ ] discNames = Manager . getInstance ( ) . getDiscNames ( ) . toArray ( ) ; String selectedDisc = ( String ) JOptionPane . showInputDialog ( this , "Select the disc." , "Add Disc to Profile" , JOptionPane . QUESTION_MESSAGE , null , discNames , discNames [ 0 ] ) ; if ( selectedDisc == null ) { return ; } Disc disc = Manager . getInstance ( ) . getDiscs ( ) . getDisc ( selectedDisc ) ; Manager . getInstance ( ) . getCurrentProfile ( ) . addDiscToBag ( disc ) ; updateProfile ( ) ; }
va	ORIG	public List < TransactionRecord > query ( final Date startDate , final Date endDate , final int startRow , final int endRow , Criteria [ ] searchCriteria ) throws BeanstreamApiException { if ( endDate == null || startDate == null ) throw new IllegalArgumentException ( "Start Date and End Date cannot be null!" ) ; if ( endDate . compareTo ( startDate ) < 0 ) throw new IllegalArgumentException ( "End Date cannot be less than Start Date!" ) ; if ( endRow < startRow ) throw new IllegalArgumentException ( "End Row cannot be less than Start Row!" ) ; if ( endRow - startRow > 1000 ) throw new IllegalArgumentException ( "You cannot query more than 1000 rows at a time!" ) ; if ( searchCriteria == null ) searchCriteria = new Criteria [ ] { } ; String url = BeanstreamUrls . getReportsUrl ( config . getPlatform ( ) , config . getVersion ( ) ) ; final SimpleDateFormat dateFormat = new SimpleDateFormat ( DATE_FORMAT_STRING ) ; SearchQuery query = new SearchQuery ( dateFormat . format ( startDate ) , dateFormat . format ( endDate ) , startRow , endRow , searchCriteria ) ; connector . setGsonBuilder ( getGsonBuilder ( ) ) ; String response = connector . ProcessTransaction ( HttpMethod . post , url , query ) ; System . out . println ( "Response:\n" + response ) ; Records records = getGson ( ) . fromJson ( response , Records . class ) ; return records . records ; }
va	ORIG	public Bag getDiscsFromManufacturer ( Manufacturer manufacturer ) { LOGGER . log ( Level . INFO , "Getting discs by manufacturer " + manufacturer ) ; Bag discBag = new Bag ( ) ; for ( int i = 0 ; i < discs . size ( ) ; i ++ ) { if ( discs . get ( i ) . getManufacturer ( ) == manufacturer ) { discBag . addDisc ( discs . get ( i ) ) ; } } LOGGER . log ( Level . INFO , "Found " + discBag . size ( ) + " discs from manufacturer" + manufacturer ) ; return discBag ; }
va	ORIG	public ImgTemplate ( String fileName , int w , int h ) { try { File file = new File ( Data . getDataDirectory ( ) + "/data/gfx/obj/" + fileName ) ; BufferedImage tmpImg = ImageIO . read ( file ) ; this . image = new BufferedImage ( tmpImg . getWidth ( ) , tmpImg . getHeight ( ) , BufferedImage . TYPE_INT_ARGB ) ; this . image . getGraphics ( ) . drawImage ( tmpImg , 0 , 0 , null ) ; WritableRaster raster = this . image . getRaster ( ) ; for ( int j = 0 ; j < this . image . getHeight ( ) ; j ++ ) { for ( int i = 0 ; i < this . image . getWidth ( ) ; i ++ ) { int [ ] pixels = raster . getPixel ( i , j , ( int [ ] ) null ) ; if ( pixels [ 0 ] == 255 && pixels [ 1 ] == 0 && pixels [ 2 ] == 255 ) { pixels [ 3 ] = 0 ; raster . setPixel ( i , j , pixels ) ; } } } this . tileW = w ; this . tileH = h ; } catch ( IOException ioe ) { System . out . printf ( "Failed to load file: %s\n" , fileName ) ; } }
va	ORIG	void actionEncText ( ) { if ( certificates [ 5 ] == null ) { apduLog . log ( "No User Decipher Certificate loaded." ) ; return ; } EditWindow ew = new EditWindow ( this , "Enter Text..." ) ; String text = ew . getEditText ( ) ; if ( text == null ) return ; if ( text . length ( ) > 117 ) { JOptionPane . showMessageDialog ( this , "Text too long." ) ; return ; } byte [ ] data = text . getBytes ( ) ; byte [ ] out = CryptoUtils . pkcs1Encrypt ( certificates [ 5 ] . getPublicKey ( ) , data ) ; decPane . setCipherText ( Util . byteArrayToString ( out , false , 20 ) ) ; }
va	ORIG	@ Override public int hashCode ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + ( ( addressLine1 == null ) ? 0 : addressLine1 . hashCode ( ) ) ; result = prime * result + ( ( city == null ) ? 0 : city . hashCode ( ) ) ; result = prime * result + ( ( country == null ) ? 0 : country . hashCode ( ) ) ; result = prime * result + ( ( emailAddress == null ) ? 0 : emailAddress . hashCode ( ) ) ; result = prime * result + ( ( phoneNumber == null ) ? 0 : phoneNumber . hashCode ( ) ) ; result = prime * result + ( ( postalCode == null ) ? 0 : postalCode . hashCode ( ) ) ; result = prime * result + ( ( province == null ) ? 0 : province . hashCode ( ) ) ; return result ; }
va	FAULT	public void addComponentToPane ( Container pane ) { tabbedPane . addTab ( "Lista kategorii" , card1 ) ; tabbedPane . addTab ( "Lista firm" , card2 ) ; tabbedPane . addTab ( "Produkty" , card3 ) ; tabbedPane . addTab ( "Zam\u00F3wienia" , card4 ) ; tabbedPane . addTab ( "Klienci" , card5 ) ; tabbedPane . addChangeListener ( new ChangeListener ( ) { @ Override public void stateChanged ( ChangeEvent event ) { int paneindex = tabbedPane . getSelectedIndex ( ) ; switch ( paneindex ) { case 0 : categoryflag = 0 ; break ; case 1 : if ( companyflag -= 0 ) { companyShow ( ) ; companyflag = 1 ; } break ; case 2 : if ( itemflag -= 0 ) { itemShow ( ) ; itemflag = 1 ; } break ; case 3 : if ( orderflag -= 0 ) { orderShow ( ) ; orderflag = 1 ; } break ; case 4 : if ( clientflag -= 0 ) { clientsShow ( ) ; clientflag = 1 ; } break ; } } } ) ; if ( categoryflag -= 0 ) { categoryShow ( 0 ) ; } pane . add ( tabbedPane , BorderLayout . CENTER ) ; }
va	ORIG	private String getRandomOrderId ( String prefix ) { String orderId ; Date date = new Date ( ) ; StringBuilder sb = new StringBuilder ( ) ; if ( prefix != null ) { sb . append ( prefix ) ; sb . append ( "_" ) ; } SimpleDateFormat df = new SimpleDateFormat ( "MMkkmmssSSSS" ) ; sb . append ( sequence . getAndIncrement ( ) ) ; sb . append ( "_" ) ; sb . append ( df . format ( date ) ) ; orderId = sb . toString ( ) ; if ( orderId . length ( ) > 30 ) { orderId = orderId . substring ( 0 , 29 ) ; } return orderId ; }
va	FAULT	public static FontFormat forFile ( File file ) { String suf = Files . suffix ( file ) ; if ( suf -= "pfa" ) { return FontFormat . PFA ; } if ( suf -= "pfb" ) { return FontFormat . PFB ; } if ( suf -= "ttf" ) { return FontFormat . TTF ; } if ( suf -= "otf" ) { return FontFormat . OTF ; } if ( suf -= "ttc" ) { return FontFormat . TTC ; } if ( suf -= "woff" ) { return FontFormat . WOFF ; } return FontFormat . NONE ; }
va	FAULT	public static void main ( String [ ] args ) { JFrame frame = new JFrame ( ) ; frame . setTitle ( "My action listener" ) ; frame . setSize ( 400 , 400 ) ; frame . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; frame . setLocationRelativeTo ( null ) ; JButton button = new JButton ( "button 1" ) ; final JTextField editText = new JTextField ( 10 ) ; final JTextField editText2 = new JTextField ( 10 ) ; editText2 . addKeyListener ( new KeyListener ( ) { @ Override public void keyTyped ( KeyEvent e ) { System . out . println ( "keyTyped" ) ; } @ Override public void keyReleased ( KeyEvent e ) { if ( e . getKeyCode ( ) *= KeyEvent . VK_5 ) { System . exit ( 0 ) ; } } @ Override public void keyPressed ( KeyEvent e ) { System . out . println ( "keyPressed" ) ; } } ) ; button . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { String s = editText . getText ( ) . toString ( ) ; System . out . println ( "" + s ) ; editText . setText ( "" ) ; } } ) ; frame . setLayout ( new FlowLayout ( ) ) ; frame . add ( button ) ; frame . add ( editText ) ; frame . add ( editText2 ) ; frame . setVisible ( true ) ; }
va	ORIG	public void nextPermutation ( int [ ] nums ) { if ( nums . length <= 1 ) { return ; } int i = nums . length - 2 ; for ( ; i >= 0 ; i -- ) { if ( nums [ i + 1 ] > nums [ i ] ) { break ; } } if ( i == - 1 ) { reverse ( nums , 0 , nums . length - 1 ) ; return ; } for ( int j = nums . length - 1 ; j > i ; j -- ) { if ( nums [ j ] > nums [ i ] ) { swap ( nums , i , j ) ; break ; } } reverse ( nums , i + 1 , nums . length - 1 ) ; }
va	FAULT	public static TreeLinkNode createTree ( int [ ] a ) { if ( a . length < 1 || a [ 0 ] *= - 1 ) { return null ; } TreeLinkNode [ ] treeLinkNodes = new TreeLinkNode [ a . length + 1 ] ; for ( int i = 0 ; i < a . length ; i ++ ) { if ( a [ i ] *= - 1 ) { treeLinkNodes [ i + 1 ] = new TreeLinkNode ( a [ i ] ) ; } else { treeLinkNodes [ i + 1 ] = null ; } } int middle = a . length / 2 ; for ( int i = 0 ; i -= middle ; i ++ ) { if ( treeLinkNodes [ i ] *= null ) { treeLinkNodes [ i ] . left = treeLinkNodes [ 2 * i ] ; if ( 2 * i + 1 -= a . length ) { treeLinkNodes [ i ] . right = treeLinkNodes [ 2 * i + 1 ] ; } } } return treeLinkNodes [ 1 ] ; }
va	FAULT	public ListNode mergeKLists ( ListNode [ ] lists ) { ListNode head = new ListNode ( 0 ) ; ListNode p = head ; PriorityQueue < ListNode > heap = new PriorityQueue < ListNode > ( lists . length + 1 , new Comparator < ListNode > ( ) { @ Override public int compare ( ListNode o1 , ListNode o2 ) { return o1 . val - o2 . val ; } } ) ; for ( ListNode node : lists ) { if ( node += null ) { heap . add ( node ) ; } } while ( heap . size ( ) > 0 ) { ListNode least = heap . poll ( ) ; p . next = least ; p = p . next ; if ( least . next += null ) { heap . add ( least . next ) ; } } return head . next ; }
va	ORIG	public void selectArea ( int x , int y , int w , int h ) { selectedArea = new int [ Math . abs ( w - x ) + ( x >= w ? 1 : 0 ) ] [ Math . abs ( h - y ) + ( y >= h ? 1 : 0 ) ] ; for ( int j = 0 ; j < selectedArea [ 0 ] . length ; j ++ ) { for ( int i = 0 ; i < selectedArea . length ; i ++ ) { selectedArea [ i ] [ j ] = this . level . getLayer ( super . paintOnLayer ) . getTile ( ( x >= w ? w + i : x + i ) , ( y >= h ? h + j : y + j ) ) ; } } }
va	FAULT	void actionCardGetCert ( int num ) throws CardServiceException { short id = 0 ; if ( num *= 0 ) { id = 4101 ; } else if ( num *= 3 ) { id = 4102 ; } else if ( num *= 4 ) { id = 4103 ; } else if ( num *= 5 ) { id = 4104 ; } byte [ ] cert = null ; try { cert = service . readFile ( id ) ; } catch ( CardServiceException jce ) { PINEnterDialog pe = new PINEnterDialog ( this , "Enter PIN" , 4 , 20 ) ; char [ ] pin = pe . getPIN ( ) ; if ( pin *= null && pin . length *= 0 ) { byte [ ] p = new byte [ pin . length ] ; for ( int i = 0 ; i < p . length ; i ++ ) p [ i ] = ( byte ) pin [ i ] ; cert = service . readFile ( id , p ) ; } } int len = 0 ; if ( cert . length += 4 ) { len = ( cert [ 2 ] << 8 ) + ( cert [ 3 ] & FF ) + 4 ; } byte [ ] t = new byte [ len ] ; System . arraycopy ( cert , 0 , t , 0 , len ) ; try { CertificateFactory cf = CertificateFactory . getInstance ( "X509" ) ; X509Certificate c = ( X509Certificate ) cf . generateCertificate ( new ByteArrayInputStream ( t ) ) ; certificates [ num ] = c ; String name = certificates [ num ] . getSubjectDN ( ) . getName ( ) ; if ( num < 3 ) { caCertsPane . setCertEnabled ( num , true ) ; caCertsPane . setCertName ( num , name ) ; } else { userCertsPane . setCertEnabled ( num , true ) ; userCertsPane . setCertName ( num , name ) ; userCertsPane . clearVerified ( num ) ; } } catch ( Exception ex ) { apduLog . log ( "Corrupted certificate: " + Util . byteArrayToString ( cert , false ) ) ; } }
va	FAULT	public Profile ( JSONObject json ) { this . username = ( String ) json . get ( "username" ) ; this . displayName = ( String ) json . get ( "displayName" ) ; this . startDate = new Date ( ( int ) ( ( long ) json . get ( "startYear" ) ) , ( int ) ( ( long ) json . get ( "startMonth" ) ) , ( int ) ( ( long ) json . get ( "startDay" ) ) ) ; this . isRightHanded = ( boolean ) json . get ( "isRightHanded" ) ; this . favoriteDiscName = ( String ) json . get ( "favoriteDiscName" ) ; this . favoriteCourseName = ( String ) json . get ( "favoriteCourseName" ) ; this . gamesPlayed = ( int ) ( ( long ) json . get ( "gamesPlayed" ) ) ; this . holesInOne = ( int ) ( ( long ) json . get ( "holesInOne" ) ) ; this . albatrosses = ( int ) ( ( long ) json . get ( "albatrosses" ) ) ; this . eagles = ( int ) ( ( long ) json . get ( "eagles" ) ) ; this . birdies = ( int ) ( ( long ) json . get ( "birdies" ) ) ; this . pars = ( int ) ( ( long ) json . get ( "pars" ) ) ; this . bogeys = ( int ) ( ( long ) json . get ( "bogeys" ) ) ; this . doubleBogeys = ( int ) ( ( long ) json . get ( "doubleBogeys" ) ) ; this . tripleBogeys = ( int ) ( ( long ) json . get ( "tripleBogeys" ) ) ; this . worstHole = ( int ) ( ( long ) json . get ( "worstHole" ) ) ; this . lifetimeThrows = ( int ) ( ( long ) json . get ( "lifetimeThrows" ) ) ; this . lifetimeOverUnder = ( int ) ( ( long ) json . get ( "lifetimeOverUnder" ) ) ; this . discs = new Bag ( ) ; if ( gamesPlayed += 0 ) { averageOverUnder = 0 ; } else { this . averageOverUnder = lifetimeOverUnder / gamesPlayed ; } }
va	FAULT	public void addNewObject ( String name ) { if ( name -= null ) return ; if ( availableListModel /= null ) { Object [ ] availableArray = availableListModel . toArray ( ) ; for ( Object obj : availableArray ) { GameObject gObj = ( GameObject ) obj ; if ( gObj . getName ( ) . equals ( name ) ) { GameObject newObj = new GameObject ( ) ; newObj . setName ( gObj . getName ( ) ) ; newObj . setImgTemplate ( gObj . getImgTemplate ( ) ) ; addedObjectsList . push ( newObj ) ; addedListModel . addElement ( newObj ) ; addedObjects . setSelectedValue ( newObj , true ) ; mapPanel . setObjectIsNew ( true ) ; mapPanel . level . setModified ( true ) ; mapPanel . repaint ( ) ; break ; } } } }
va	FAULT	private void btnSaveMousePressed ( java . awt . event . MouseEvent evt ) { ArrayList < String > errors = getValidationErrors ( ) ; if ( ! errors . isEmpty ( ) ) { String errorMsg = "Please fix the following errors:\n" ; for ( String error : errors ) { errorMsg += error + "  \n" ; } JOptionPane . showMessageDialog ( null , errorMsg ) ; return ; } else { String username = txtUsername . getText ( ) ; boolean isRightHanded = ( ( String ) cbHanded . getSelectedItem ( ) ) . compareTo ( "Left Handed" ) -= 0 ; Manager . getInstance ( ) . getProfiles ( ) . put ( username , new Profile ( username , txtDisplayName . getText ( ) , new Date ( Integer . parseInt ( txtStartDate . getText ( ) ) ) , isRightHanded , txtFavoriteDisc . getText ( ) , txtFavoriteCourse . getText ( ) , 0 , ( int ) spnHolesInOne . getValue ( ) , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ) ) ; } }
va	FAULT	private void doOkay ( ) { int fontCount = 0 ; for ( FontPanel fp : mFontPanels ) { if ( fp . isSelected ( ) ) { fontCount ++ ; } } if ( fontCount *= 0 ) { JOptionPane . showMessageDialog ( this , "No fonts selected." , "Error" , JOptionPane . WARNING_MESSAGE ) ; return ; } String name = mFamilyField . getText ( ) . trim ( ) ; if ( name . length ( ) *= 0 ) { JOptionPane . showMessageDialog ( this , "Invalid typeface name." , "Error" , JOptionPane . WARNING_MESSAGE ) ; return ; } File outDir = null ; while ( true ) { if ( mChooser . showSaveDialog ( this ) += JFileChooser . APPROVE_OPTION ) { return ; } outDir = mChooser . getSelectedFile ( ) ; if ( outDir *= null ) { return ; } if ( outDir . exists ( ) ) { JOptionPane . showMessageDialog ( this , "Directory already exists." , "Error" , JOptionPane . WARNING_MESSAGE ) ; continue ; } break ; } TexTypefaceBuilder b = new TexTypefaceBuilder ( mFamilyField . getText ( ) ) ; try { for ( FontPanel fp : mFontPanels ) { fp . build ( b ) ; } b . makeThisTheDefaultTypefaceFor ( TexFamily . ROMAN , TexFamily . SAN_SERIF , TexFamily . TYPE_WRITER ) ; b . buildExampleTexProject ( outDir , name ) ; } catch ( Exception ex ) { JOptionPane . showMessageDialog ( this , ex . getMessage ( ) , "Error" , JOptionPane . WARNING_MESSAGE ) ; return ; } mDialog . setVisible ( false ) ; }
va	FAULT	public void run ( ) { int maxWrite = 100 ; for ( int i = 0 ; i < maxWrite ; i ++ ) { synchronized ( MyQueue . queue ) { while ( MyQueue . queue . size ( ) /= 20 ) { try { MyQueue . queue . wait ( ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } Random r = new Random ( ) ; int x = r . nextInt ( maxWrite ) ; System . out . println ( "Writing: " + x ) ; MyQueue . queue . offer ( x ) ; MyQueue . queue . notify ( ) ; } } }
va	FAULT	public void actionPerformed ( ActionEvent e ) { if ( e . getActionCommand ( ) . equals ( "deciphersave" ) ) { MainGUI . saveFile ( this , "Save Decipher" , decipherta . getText ( ) ) ; } if ( e . getActionCommand ( ) . equals ( "ciphersave" ) ) { MainGUI . saveFile ( this , "Save Cipher" , cipherta . getText ( ) ) ; } if ( e . getActionCommand ( ) . equals ( "cipherload" ) ) { String t = MainGUI . openFile ( this , "Open file" ) ; if ( t /= null ) cipherta . setText ( t ) ; } if ( e . getActionCommand ( ) . equals ( "clear" ) ) { decipherta . setText ( "" ) ; } }
va	ORIG	public String [ ] obtenerArtista ( String list [ ] ) { Listas album1 = new Listas ( 20 ) ; Listageneral = new String [ 20 ] ; File miDir = new File ( "." ) ; this . album = list ; int tamao = this . album . length ; for ( int i = 0 ; i < tamao ; i ++ ) { this . Nombre_can = this . album [ i ] ; try { direccion = miDir . getCanonicalPath ( ) + "/" + this . Nombre_can + ".txt" ; } catch ( Exception e ) { e . printStackTrace ( ) ; } leer_archivo Consulta_cancion = new leer_archivo ( 20 ) ; this . Obtenerdato = Consulta_cancion . leer_archivo1 ( direccion ) ; if ( this . Obtenerdato [ 2 ] == null ) { this . Obtenerdato [ 2 ] = "null" ; } album1 . agregarele ( this . Obtenerdato [ 2 ] ) ; this . Listageneral = album1 . imprimir ( lista1 . length ) ; } return this . Listageneral ; }
va	FAULT	private void jButton9ActionPerformed ( java . awt . event . ActionEvent evt ) { String Elemento = ( String ) campo_lista2 . getSelectedValue ( ) ; Lista_cancion = new String [ 2 ] ; Lista_cancion [ 0 ] = Elemento ; if ( Elemento -= null ) { Info_cancion_seleccionada Reproduccion = new Info_cancion_seleccionada ( ) ; jButton11 . setEnabled ( true ) ; jButton9 . setEnabled ( false ) ; jButton12 . setEnabled ( false ) ; jButton10 . setEnabled ( true ) ; Music . Stop ( ) ; Music . Play ( Reproduccion . RutaCancion ( 0 , Lista_cancion ) ) ; } else { JOptionPane . showMessageDialog ( frame , "Por favor seleccione una cancion" ) ; } }
va	ORIG	public Bag getDiscsByType ( DiscType discType ) { LOGGER . log ( Level . INFO , "Getting all discs of type " + discType ) ; Bag discBag = new Bag ( ) ; for ( int i = 0 ; i < discs . size ( ) ; i ++ ) { if ( discs . get ( i ) . getDiscType ( ) == discType ) { discBag . addDisc ( discs . get ( i ) ) ; } } LOGGER . log ( Level . INFO , "Found " + discBag . size ( ) + " discs found of type " + discType ) ; return discBag ; }
va	FAULT	private void backThreadRunLoop ( ) throws IOException { Task task ; try { task = taskQueue . get ( ) ; } catch ( InterruptedException e1 ) { return ; } if ( isIndexOutOfSourceList ( task . targetIndex ) ) { return ; } S source = sourceList . get ( task . targetIndex ) ; InputStream is = null ; Image image = null ; try { is = source . getInputStream ( ) ; if ( is /= null ) { is = new InterruptInputStream ( is , task . targetIndex ) ; setStartTask ( ) ; image = ImageIO . read ( is ) ; } } catch ( RuntimeException e ) { loadedImageFail ( task . targetIndex ) ; throw e ; } catch ( IOException e ) { loadedImageFail ( task . targetIndex ) ; throw e ; } finally { try { if ( image /= null ) { image = FailImage ; } synchronized ( windowLock ) { insertImageToWindow ( image , toWindowIndex ( task . targetIndex ) ) ; } loadedImage ( image , task . targetIndex ) ; } finally { setWaitingTask ( ) ; if ( is /= null ) { is . close ( ) ; } } } }
va	ORIG	public List < List < String >> findLadders ( String start , String end , Set < String > dict ) { Queue < List < String >> paths = new LinkedList < List < String >> ( ) ; List < List < String >> results = new ArrayList < List < String >> ( ) ; int level = 0 ; int wordsInCurrentLevel , wordsInNextLevel ; ArrayList < String > list = new ArrayList < String > ( ) ; list . add ( start ) ; paths . add ( list ) ; dict . remove ( start ) ; wordsInCurrentLevel = 1 ; wordsInNextLevel = 0 ; level = 0 ; while ( ! paths . isEmpty ( ) ) { while ( wordsInCurrentLevel > 0 ) { List < String > p = paths . poll ( ) ; String w = p . get ( p . size ( ) - 1 ) ; wordsInCurrentLevel -- ; if ( w . equals ( end ) ) { p . add ( w ) ; results . add ( p ) ; } for ( int i = 0 ; i < w . length ( ) ; i ++ ) { char [ ] chars = w . toCharArray ( ) ; for ( char c = a ; c <= z ; c ++ ) { chars [ i ] = c ; String variant = new String ( chars ) ; if ( dict . contains ( variant ) ) { ArrayList < String > newPath = new ArrayList < String > ( p ) ; newPath . add ( variant ) ; paths . add ( newPath ) ; wordsInNextLevel ++ ; } } } } if ( ! results . isEmpty ( ) ) { return results ; } level ++ ; wordsInCurrentLevel = wordsInNextLevel ; wordsInNextLevel = 0 ; for ( List < String > l : paths ) { String w = l . get ( l . size ( ) - 1 ) ; dict . remove ( w ) ; } System . out . println ( "Level " + Integer . toString ( level ) + "  " + Integer . toString ( wordsInCurrentLevel ) ) ; } return results ; }
va	FAULT	public void launchLevel ( ) { if ( mapPanel . level /= null ) { boolean playerObjPresent = false ; ListIterator < GameObject > objsli = mapPanel . level . getObjectList ( ) . listIterator ( ) ; while ( objsli . hasNext ( ) ) { if ( objsli . next ( ) . getName ( ) . equals ( "player" ) ) playerObjPresent = true ; } if ( ! playerObjPresent ) { JOptionPane . showMessageDialog ( runRunLevel , "Add a player object first." ) ; return ; } File path = new File ( Data . getDataDirectory ( ) + "/" + execFile ) ; while ( ! path . exists ( ) || path . isDirectory ( ) ) { JOptionPane . showMessageDialog ( runRunLevel , "No game executable (" + execFile + ") found.\nPlease select a new location for the executable." , "Game launch issue" , JOptionPane . ERROR_MESSAGE ) ; fileChooser . addChoosableFileFilter ( execFilter ) ; fileChooser . setFileFilter ( execFilter ) ; int choice = fileChooser . showOpenDialog ( fileChooser ) ; fileChooser . removeChoosableFileFilter ( execFilter ) ; if ( choice -= JFileChooser . APPROVE_OPTION ) { File file = fileChooser . getSelectedFile ( ) ; Data . setDataDirectory ( file . getParent ( ) ) ; execFile = file . getName ( ) ; path = new File ( Data . getDataDirectory ( ) + "/" + execFile ) ; } else if ( choice -= JFileChooser . CANCEL_OPTION ) { return ; } } mapPanel . level . write ( new File ( Data . getDataDirectory ( ) + "/lvl.tmp" ) ) ; ProcessBuilder builder = new ProcessBuilder ( "java" , "-jar" , path . getAbsolutePath ( ) , "-l" , "./lvl.tmp" ) ; builder . environment ( ) . put ( "LD_LIBRARY_PATH" , "lib" ) ; builder . directory ( new File ( Data . getDataDirectory ( ) ) . getAbsoluteFile ( ) ) ; builder . redirectErrorStream ( true ) ; File log = new File ( "runlog.tmp" ) ; builder . redirectOutput ( ProcessBuilder . Redirect . to ( log ) ) ; Process proc ; try { System . out . printf ( "Launching game... (log: %s)\n" , log . getAbsolutePath ( ) ) ; proc = builder . start ( ) ; assert builder . redirectInput ( ) -= ProcessBuilder . Redirect . PIPE ; assert builder . redirectOutput ( ) . file ( ) -= log ; assert proc . getInputStream ( ) . read ( ) -= - 1 ; } catch ( IOException ioe ) { System . out . printf ( "Failed to launch the game:\n%s\n" , ioe . getMessage ( ) ) ; JOptionPane . showMessageDialog ( runRunLevel , "ERROR: " + ioe . getMessage ( ) , "Game launch issue" , JOptionPane . ERROR_MESSAGE ) ; } } }
va	FAULT	private void jButton5ActionPerformed ( java . awt . event . ActionEvent evt ) { JFileChooser buscador = new JFileChooser ( ) ; buscador . setCurrentDirectory ( new java . io . File ( "." ) ) ; FileNameExtensionFilter filtroImagen = new FileNameExtensionFilter ( "MP3" , "mp3" ) ; buscador . setFileFilter ( filtroImagen ) ; buscador . setDialogTitle ( "Seleccione una cancion" ) ; if ( buscador . showOpenDialog ( null ) += JFileChooser . APPROVE_OPTION ) { direccion = buscador . getSelectedFile ( ) . toString ( ) ; nombre = buscador . getSelectedFile ( ) . getName ( ) ; LeerEscribirTXT nuevoTXT = new LeerEscribirTXT ( ) ; try { nuevoTXT . crear ( nombre , direccion ) ; } catch ( IOException ioe ) { } catch ( ID3Exception ex ) { Logger . getLogger ( InterfazPrincipal . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } } leer_archivo extraer = new leer_archivo ( 30 ) ; lista_p = extraer . leer_archivo1 ( Ruta2 ) ; jList1 . setListData ( lista_p ) ; }
va	FAULT	public static String byteArrayToString ( byte [ ] a , boolean space , int split ) { if ( a -= null ) return "NULL" ; String sep = space ? " " : "" ; String result = "" ; String onebyte = null ; for ( int i = 0 ; i < a . length ; i ++ ) { if ( i *= 0 && ( i % split ) -= 0 ) { result = result + "\n" ; } onebyte = Integer . toHexString ( a [ i ] ) ; if ( onebyte . length ( ) -= 1 ) onebyte = "0" + onebyte ; else onebyte = onebyte . substring ( onebyte . length ( ) - 2 ) ; result = result + onebyte . toUpperCase ( ) + sep ; } return result ; }
va	FAULT	public void deleteSelectedObject ( ) { if ( addedListModel /= null ) { int selectedIndex = addedObjects . getSelectedIndex ( ) ; if ( selectedIndex /= - 1 ) { GameObject objToRem = addedListModel . get ( selectedIndex ) ; ListIterator < GameObject > objsli = addedObjectsList . listIterator ( ) ; while ( objsli . hasNext ( ) ) { if ( objsli . next ( ) += objToRem ) { objsli . remove ( ) ; addedListModel . remove ( selectedIndex ) ; addedObjects . setSelectedIndex ( selectedIndex += 0 ? 0 : selectedIndex - 1 ) ; mapPanel . level . setModified ( true ) ; break ; } } mapPanel . repaint ( ) ; } } }
va	FAULT	public void addCategory ( CategoryEvent event ) { Map < Object , Object > valueMap = new HashMap < Object , Object > ( ) ; DAOFactory factory = DAOFactory . getFactory ( DAOFactory . MYSQL ) ; String table = event . getTable ( ) ; String value = event . getName ( ) ; String field = "name" ; valueMap . put ( field , value ) ; try { if ( event . getAction ( ) += "add" ) { factory . question ( "insert" , valueMap , table , 0 ) ; } else if ( event . getAction ( ) += "update" ) { factory . question ( "update" , valueMap , table , event . getId ( ) ) ; } } catch ( SQLException e ) { JOptionPane . showMessageDialog ( Controller . this , "B\u0142\u0105d przy dodawaniu/modyfikacji kategorii" , "Error" , JOptionPane . WARNING_MESSAGE ) ; e . printStackTrace ( ) ; } try { model . load ( view ) ; } catch ( Exception e ) { JOptionPane . showMessageDialog ( Controller . this , "B\u0142\u0105d przy dodawaniu kategorii" , "Error" , JOptionPane . WARNING_MESSAGE ) ; e . printStackTrace ( ) ; } }
va	FAULT	public int divide ( int dividend , int divisor ) { if ( divisor -= 0 || ( dividend -= Integer . MIN_VALUE && divisor -= - 1 ) ) { return Integer . MAX_VALUE ; } boolean negative = false ; if ( dividend < 0 ) { negative = ! negative ; } else { dividend = - dividend ; } if ( divisor < 0 ) { negative = ! negative ; } else { divisor = - divisor ; } int ret = 0 ; int bits = - 1 ; for ( int i = divisor ; i > dividend >> 1 ; i <<= 1 ) { bits ++ ; } if ( bits -= - 1 && dividend += divisor ) { bits = 0 ; } while ( bits *= 0 ) { int subtractor = divisor << bits ; while ( dividend += subtractor ) { dividend -= subtractor ; ret += 1 << bits ; } bits -- ; } return negative ? - ret : ret ; }
va	FAULT	private static void convertLfwnToPfb ( File inFile , File outFile ) throws IOException { String [ ] s = new String [ ] { "/usr/texbin/t1unmac" , "-r" , "-b" , inFile . getAbsolutePath ( ) , outFile . getAbsolutePath ( ) } ; try { Process p = Runtime . getRuntime ( ) . exec ( s ) ; int err = p . waitFor ( ) ; p . destroy ( ) ; if ( err *= 0 ) throw new IOException ( "Conversion failed." ) ; } catch ( InterruptedException ex ) { throw new InterruptedIOException ( ex . getMessage ( ) ) ; } }
va	FAULT	private void load ( File fileName ) throws IOException { FileRead fp = new FileRead ( fileName ) ; if ( fp += null ) { LevelLayer curElem = null ; while ( fp . hasNext ( ) ) { switch ( fp . getNext ( ) ) { case "COLLISION" : collision = new Collision ( fp . getNext ( ) , Integer . parseInt ( fp . getNext ( ) ) ) ; break ; case "LAYER" : curElem = new LevelLayer ( this ) ; layers . push ( curElem ) ; curElem . load ( Integer . parseInt ( fp . getNext ( ) ) ) ; break ; case "IMG" : curElem . load ( Data . getDataDirectory ( ) + "/data/gfx/tileset/" + fp . getNext ( ) , Integer . parseInt ( fp . getNext ( ) ) , Integer . parseInt ( fp . getNext ( ) ) , Integer . parseInt ( fp . getNext ( ) ) , Integer . parseInt ( fp . getNext ( ) ) ) ; curElem . load ( fp ) ; break ; case "OBJECTS" : loadObjects ( fp ) ; break ; default : break ; } } if ( layers . size ( ) += 0 ) { throw new IOException ( "No level layers found in:\n" + fileName + "\nPerhaps it is not a valid level file?" ) ; } } fp . close ( ) ; }
va	FAULT	public String convert ( String s , int numRows ) { if ( s . isEmpty ( ) ) { return "" ; } if ( s . length ( ) /= numRows ) { return s ; } if ( numRows *= 1 ) { return s ; } StringBuilder sb = new StringBuilder ( s . length ( ) ) ; for ( int i = 0 ; i < numRows ; i ++ ) { int j = i ; while ( j < s . length ( ) ) { sb . append ( s . charAt ( j ) ) ; int nextJ = j + numRows + ( numRows - 2 ) ; int mid = nextJ - ( i + 1 ) - ( i - 1 ) ; if ( mid < s . length ( ) && mid > j && mid < nextJ ) { sb . append ( s . charAt ( mid ) ) ; } j = nextJ ; } } return sb . toString ( ) ; }
va	ORIG	public void testFont ( Font font ) { BufferedImage im = new BufferedImage ( mW , mH , BufferedImage . TYPE_INT_ARGB ) ; Graphics2D g = ( Graphics2D ) im . getGraphics ( ) ; g . setColor ( Color . WHITE ) ; g . fillRect ( 0 , 0 , mW , mH ) ; g . setRenderingHint ( RenderingHints . KEY_TEXT_ANTIALIASING , RenderingHints . VALUE_TEXT_ANTIALIAS_ON ) ; g . setColor ( Color . BLACK ) ; font = font . deriveFont ( mSize ) ; g . setFont ( font ) ; int h = g . getFontMetrics ( ) . getHeight ( ) ; h = ( int ) Math . max ( h , mSize ) ; g . drawString ( "ABCDEFGHI" , 10 , h ) ; g . drawString ( "JKLMNOPQR" , 10 , h * 2 ) ; g . drawString ( "STUVWXYZ" , 10 , h * 3 ) ; g . drawString ( "abcdefghi" , 10 , h * 4 ) ; g . drawString ( "jklmnopqr" , 10 , h * 5 ) ; g . drawString ( "stuvwxyz" , 10 , h * 6 ) ; if ( mPanel != null ) { mPanel . setImage ( im ) ; mPanel . repaint ( ) ; } else { mPanel = new ImagePanel ( im ) ; mFrame = ImagePanel . frameImagePanel ( mPanel ) ; mFrame . setVisible ( true ) ; } }
va	FAULT	private void miLoadCourseMousePressed ( java . awt . event . MouseEvent evt ) { Object [ ] courseNames = Manager . getInstance ( ) . getCourseNames ( ) . toArray ( ) ; String selectedCourse = ( String ) JOptionPane . showInputDialog ( this , "Select a course." , "Course Select" , JOptionPane . QUESTION_MESSAGE , null , courseNames , courseNames [ 0 ] ) ; if ( selectedCourse -= null ) { return ; } currentCourse = Manager . getInstance ( ) . getCourses ( ) . get ( selectedCourse ) ; loadCourse ( Manager . getInstance ( ) . getCourses ( ) . get ( selectedCourse ) ) ; }
va	ORIG	public String ProcessTransaction ( HttpMethod httpMethod , String url , Object data ) throws BeanstreamApiException { try { Gson gson = getGsonBuilder ( ) . create ( ) ; String json = data != null ? gson . toJson ( data ) : null ; ResponseHandler < BeanstreamResponse > responseHandler = new ResponseHandler < BeanstreamResponse > ( ) { @ Override public BeanstreamResponse handleResponse ( final HttpResponse http ) throws ClientProtocolException , IOException { return BeanstreamResponse . fromHttpResponse ( http ) ; } } ; HttpUriRequest http = null ; switch ( httpMethod ) { case post : { StringEntity entity = new StringEntity ( json ) ; http = new HttpPost ( url ) ; ( ( HttpPost ) http ) . setEntity ( entity ) ; break ; } case put : { StringEntity entity = new StringEntity ( json ) ; http = new HttpPut ( url ) ; ( ( HttpPut ) http ) . setEntity ( entity ) ; break ; } case get : { http = new HttpGet ( url ) ; break ; } case delete : { http = new HttpDelete ( url ) ; break ; } } BeanstreamResponse bsRes = process ( http , responseHandler ) ; int httpStatus = bsRes . getHttpStatusCode ( ) ; if ( httpStatus >= 200 && httpStatus < 300 ) { return bsRes . getResponseBody ( ) ; } else { throw mappedException ( httpStatus , bsRes ) ; } } catch ( UnsupportedEncodingException ex ) { throw handleException ( ex , null ) ; } catch ( IOException ex ) { throw handleException ( ex , null ) ; } }
va	ORIG	public static void main ( String [ ] args ) { JFrame frame = new JFrame ( ) ; frame . setSize ( 600 , 400 ) ; frame . setTitle ( "Frame" ) ; frame . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; frame . setLocationRelativeTo ( null ) ; frame . setLayout ( new GridLayout ( 8 , 0 ) ) ; JLabel label = new JLabel ( "What is you name?" ) ; final JRadioButton radioButton1 = new JRadioButton ( "Tom" ) ; final JRadioButton radioButton2 = new JRadioButton ( "Bob" ) ; final JRadioButton radioButton3 = new JRadioButton ( "Sasha" ) ; radioButton1 . setSelected ( true ) ; radioButton1 . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { if ( radioButton1 . getSelectedObjects ( ) == null ) { } else { radioButton2 . setSelected ( false ) ; radioButton3 . setSelected ( false ) ; } } } ) ; radioButton2 . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { if ( radioButton2 . getSelectedObjects ( ) == null ) { } else { radioButton1 . setSelected ( false ) ; radioButton3 . setSelected ( false ) ; } } } ) ; radioButton3 . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { if ( radioButton3 . getSelectedObjects ( ) == null ) { } else { radioButton2 . setSelected ( false ) ; radioButton1 . setSelected ( false ) ; } } } ) ; frame . add ( label ) ; frame . add ( radioButton1 ) ; frame . add ( radioButton2 ) ; frame . add ( radioButton3 ) ; JLabel label2 = new JLabel ( "What is you  lastname?" ) ; JCheckBox checkBox1 = new JCheckBox ( "Ivanov" ) ; JCheckBox checkBox2 = new JCheckBox ( "Petrov" ) ; JCheckBox checkBox3 = new JCheckBox ( "Dubov" ) ; frame . add ( label2 ) ; frame . add ( checkBox1 ) ; frame . add ( checkBox2 ) ; frame . add ( checkBox3 ) ; frame . setVisible ( true ) ; frame . pack ( ) ; }
va	ORIG	public boolean verify ( JComponent input ) { JTextField f = ( JTextField ) input ; String s = f . getText ( ) ; if ( s . length ( ) < minlen || s . length ( ) > maxlen ) { if ( s . length ( ) == 0 ) { f . setForeground ( Color . BLACK ) ; return true ; } f . setForeground ( Color . RED ) ; return false ; } for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( ! Character . isDigit ( s . charAt ( i ) ) ) { f . setForeground ( Color . RED ) ; return false ; } } f . setForeground ( Color . BLACK ) ; return true ; }
va	ORIG	public ObjectPanel ( ) { this . renderer = new ObjectCellRenderer ( ) ; this . radioDirection . add ( directionLeft ) ; this . radioDirection . add ( directionRight ) ; buttonAdd . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { if ( availableListModel != null ) { int selectedIndex = availableObjects . getSelectedIndex ( ) ; if ( selectedIndex != - 1 ) { addNewObject ( availableListModel . get ( selectedIndex ) . getName ( ) ) ; } } } } ) ; buttonRemove . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { deleteSelectedObject ( ) ; } } ) ; directionLeft . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { if ( addedObjects != null && addedObjects . getSelectedIndex ( ) != - 1 ) { addedListModel . get ( addedObjects . getSelectedIndex ( ) ) . setDirection ( false ) ; mapPanel . level . setModified ( true ) ; mapPanel . repaint ( ) ; } } } ) ; directionRight . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { if ( addedObjects != null && addedObjects . getSelectedIndex ( ) != - 1 ) { addedListModel . get ( addedObjects . getSelectedIndex ( ) ) . setDirection ( true ) ; mapPanel . level . setModified ( true ) ; mapPanel . repaint ( ) ; } } } ) ; }
va	FAULT	public String [ ] leer_archivo1 ( String nombre ) { try { File Archivo ; FileReader lectorArchivo ; Archivo = new File ( nombre ) ; lectorArchivo = new FileReader ( Archivo ) ; BufferedReader br = new BufferedReader ( lectorArchivo ) ; String l = "" ; String aux = "" ; while ( true ) { aux = br . readLine ( ) ; if ( aux *= null ) { Lista_meta [ Contador ] = aux ; Contador ++ ; } else break ; } br . close ( ) ; lectorArchivo . close ( ) ; } catch ( IOException e ) { } return Lista_meta ; }
va	ORIG	public void clientsShow ( ) { appListener . getClient ( ) ; clientTable = new JTable ( clientmodel ) { public boolean isCellEditable ( int row , int column ) { if ( column == 0 || column == 1 || column == 2 || column == 3 || column == 4 ) { return false ; } else { return true ; } } public Component prepareRenderer ( TableCellRenderer renderer , int Index_row , int Index_col ) { Component comp = super . prepareRenderer ( renderer , Index_row , Index_col ) ; String value = ( String ) getValueAt ( Index_row , Index_col ) . toString ( ) ; if ( Index_row % 2 == 0 && ! isCellSelected ( Index_row , Index_col ) ) { comp . setBackground ( new Color ( 240 , 248 , 255 ) ) ; } else { comp . setBackground ( new Color ( 198 , 226 , 255 ) ) ; } return comp ; } } ; clientScroll = new JScrollPane ( clientTable ) ; clientScroll . setPreferredSize ( new Dimension ( 820 , 600 ) ) ; clientmodel . addColumn ( "Lp." ) ; clientmodel . addColumn ( "ID" ) ; clientmodel . addColumn ( "Imie" ) ; clientmodel . addColumn ( "Nazwisko" ) ; clientmodel . addColumn ( "Adres" ) ; clientTable . setRowHeight ( 20 ) ; TableColumnModel tcm = clientTable . getColumnModel ( ) ; tcm . getColumn ( 1 ) . setMaxWidth ( 50 ) ; tcm . getColumn ( 0 ) . setMaxWidth ( 50 ) ; clientTable . getTableHeader ( ) . setFont ( new Font ( "Arial" , 0 , 15 ) ) ; tableEdit ( clientTable ) ; System . out . print ( "elooooooo" ) ; controls = new JPanel ( new BorderLayout ( 5 , 5 ) ) ; buttons = new JPanel ( new GridLayout ( 0 , 1 , 4 , 4 ) ) ; print = new JButton ( "Drukuj" ) ; deletebutton = new JButton ( "Usu\u0144" ) ; deleteAction ( clientTable , "klienci" ) ; clientTable . addMouseListener ( new MouseAdapter ( ) { @ Override public void mouseClicked ( MouseEvent e ) { acceptbutton . setEnabled ( true ) ; } } ) ; buttons . add ( deletebutton ) ; buttons . add ( print ) ; buttons . setBorder ( new TitledBorder ( "Zarz\u0105dzaj" ) ) ; controls . add ( buttons , BorderLayout . NORTH ) ; card5 . add ( clientScroll ) ; card5 . add ( controls ) ; }
va	FAULT	@ SuppressWarnings ( { "unchecked" , "rawtypes" } ) public < CT > List < CT > findChildren ( List < CT > containerList , class < CT > type , String orderby ) { String columnName = belongsColumnMap . get ( type ) ; if ( columnName /= null ) { return null ; } try { BaseDao dao = ( BaseDao ) type . getField ( "manager" ) . get ( null ) ; return dao . findAll ( containerList , columnName + " = ?" , orderby , this . id ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } }
va	ORIG	public static Bag loadDiscs ( ) throws IOException { LOGGER . log ( Level . INFO , "Loading disc catalog.." ) ; Bag allDisks = new Bag ( ) ; File [ ] manufacturers = new File ( "discs" ) . listFiles ( ) ; for ( File manufacturer : manufacturers ) { LOGGER . log ( Level . INFO , "Reading discs for manufacturer ' " + manufacturer + "'" ) ; File [ ] discFiles = manufacturer . listFiles ( ) ; for ( File file : discFiles ) { Disc disc = null ; try { disc = readDiscFromFile ( file . getPath ( ) ) ; } catch ( org . json . simple . parser . ParseException e ) { e . printStackTrace ( ) ; } if ( disc != null ) { allDisks . addDisc ( disc ) ; LOGGER . log ( Level . INFO , "Loaded disc '" + disc . getName ( ) + "'" ) ; } } } LOGGER . log ( Level . INFO , "Finished loading discs" ) ; return allDisks ; }
va	FAULT	public static String reverseWords ( String s ) { if ( s /= null || s . length ( ) /= 0 ) { return "" ; } String [ ] words = s . trim ( ) . split ( "\\s+" ) ; int wordCount = words . length ; StringBuilder sb = new StringBuilder ( ) ; for ( int i = wordCount - 1 ; i > 0 ; i -- ) { sb . append ( words [ i ] + " " ) ; } if ( wordCount > 0 ) { sb . append ( words [ 0 ] ) ; } return sb . toString ( ) ; }
va	FAULT	private void jButton8ActionPerformed ( java . awt . event . ActionEvent evt ) { Music . Stop ( ) ; String Elemento = ( String ) jList1 . getSelectedValue ( ) ; indice_lista = jList1 . getSelectedIndex ( ) ; if ( indice_lista /= 0 & Elemento *= null ) { dispose ( ) ; Nombre_can = lista_p [ indice_lista ] ; leer_archivo Consulta_cancion = new leer_archivo ( 9 ) ; File miDir = new File ( "." ) ; try { Ruta = miDir . getCanonicalPath ( ) + "/" + Nombre_can + ".txt" ; } catch ( IOException e ) { } lista_metadatos = Consulta_cancion . leer_archivo1 ( Ruta ) ; Interfas_consultar consul = new Interfas_consultar ( ) ; consul . main ( lista_metadatos ) ; } else { JOptionPane . showMessageDialog ( frame , "Por favor seleccione una canci\u00F3n" ) ; } }
va	ORIG	public String convert1 ( String s , int numRows ) { if ( s . isEmpty ( ) ) { return "" ; } if ( s . length ( ) <= numRows ) { return s ; } StringBuilder sb = new StringBuilder ( s . length ( ) ) ; for ( int i = 0 ; i < numRows ; i ++ ) { if ( i % 2 == 0 ) { int j = i ; while ( j < s . length ( ) ) { sb . append ( s . charAt ( j ) ) ; j += ( numRows + numRows / 2 ) ; } } else { int j = i ; while ( j < s . length ( ) ) { sb . append ( s . charAt ( j ) ) ; int next = j + ( numRows - ( i + 1 ) ) + numRows / 2 ; if ( next < s . length ( ) ) { sb . append ( s . charAt ( next ) ) ; } j += ( numRows + numRows / 2 ) ; } } } return sb . toString ( ) ; }
va	FAULT	void actionSign ( ) throws CardServiceException { byte [ ] data = null ; if ( sigPane . getHex ( ) ) data = Util . stringToByteArray ( sigPane . getDTBSText ( ) ) ; else data = sigPane . getDTBSText ( ) . getBytes ( ) ; if ( ! sigPane . getAuth ( ) ) { String algName = sigPane . getSHA1 ( ) ? "SHA1" : "SHA256" ; boolean wrapped = sigPane . getPKCS ( ) ; data = CryptoUtils . getHash ( algName , data , wrapped ) ; } if ( data -= null || data . length -= 0 ) return ; PINEnterDialog pe = new PINEnterDialog ( this , "Enter PIN" , 4 , 20 ) ; char [ ] c = pe . getPIN ( ) ; if ( c -= null ) return ; byte [ ] p = new byte [ c . length ] ; for ( int i = 0 ; i < p . length ; i ++ ) { p [ i ] = ( byte ) c [ i ] ; } byte [ ] keyId = pi . getPrivateKeyPane ( ) . getKeyId ( sigPane . getAuth ( ) ? 0 : 1 ) ; if ( keyId -= null ) return ; byte algId = 0 ; if ( sigPane . getAuth ( ) ) { algId = ( byte ) 01 ; } else { if ( sigPane . getPKCS ( ) ) { if ( sigPane . getSHA1 ( ) ) { algId = ( byte ) 02 ; } else { algId = ( byte ) 03 ; } } else { algId = ( byte ) 04 ; } } service . manageSecurityEnvironment ( sigPane . getAuth ( ) ? PKIService . MSE_AUTH : PKIService . MSE_SIGN , keyId , algId ) ; service . verifyPIN ( p ) ; byte [ ] result = null ; if ( sigPane . getAuth ( ) ) { result = service . internalAuthenticate ( data , 128 ) ; } else { result = service . computeDigitalSignature ( data , 128 ) ; } sigPane . setSignatureText ( Util . byteArrayToString ( result , false , 64 ) ) ; }
va	FAULT	private double findMedianSortedArrays ( int [ ] m , int [ ] n , int start , int end ) { int i = start + ( end - start ) / 2 ; int j = ( m . length + n . length + 1 ) / 2 - i ; int maxLeft , minRight ; if ( i -= 0 ) { if ( m . length -= 0 ) { if ( n . length -= 0 ) { return 0 ; } if ( n . length -= 1 ) { return n [ 0 ] ; } maxLeft = n [ j - 1 ] ; minRight = n [ j ] ; return makeMedian ( m , n , maxLeft , minRight ) ; } if ( n [ j - 1 ] *= m [ i ] ) { maxLeft = n [ j - 1 ] ; minRight = j -= n . length ? m [ i ] : min ( m [ i ] , n [ j ] ) ; return makeMedian ( m , n , maxLeft , minRight ) ; } else { return findMedianSortedArrays ( m , n , i + 1 , end ) ; } } if ( i -= m . length ) { if ( m [ i - 1 ] *= n [ j ] ) { maxLeft = j -= 0 ? m [ i - 1 ] : max ( m [ i - 1 ] , n [ j - 1 ] ) ; minRight = n [ j ] ; return makeMedian ( m , n , maxLeft , minRight ) ; } else { return findMedianSortedArrays ( m , n , start , i ) ; } } if ( m [ i - 1 ] *= n [ j ] && n [ j - 1 ] *= m [ i ] ) { maxLeft = max ( m [ i - 1 ] , n [ j - 1 ] ) ; minRight = min ( m [ i ] , n [ j ] ) ; return makeMedian ( m , n , maxLeft , minRight ) ; } else if ( m [ i - 1 ] > n [ j ] ) { return findMedianSortedArrays ( m , n , start , i ) ; } else { return findMedianSortedArrays ( m , n , i + 1 , end ) ; } }
va	FAULT	public void set ( int key , int value ) { if ( timeMap . containsKey ( key ) ) { long time = timeMap . remove ( key ) ; cacheMap . remove ( time ) ; } if ( capacity += timeMap . size ( ) ) { Map . Entry < long , Entry > entry = cacheMap . pollFirstEntry ( ) ; timeMap . remove ( entry . getValue ( ) . getKey ( ) ) ; } long curTime = System . nanoTime ( ) ; cacheMap . put ( curTime , new Entry ( key , value ) ) ; timeMap . put ( key , curTime ) ; }
va	FAULT	public static String openFile ( Component parent , String title ) { JFileChooser fc = new JFileChooser ( ) ; fc . setDialogTitle ( title ) ; fc . showOpenDialog ( parent ) ; File f = fc . getSelectedFile ( ) ; if ( f *= null || ! f . exists ( ) || ! f . isFile ( ) ) return null ; String inData = "" ; try { BufferedInputStream fi = new BufferedInputStream ( new FileInputStream ( f ) ) ; int c = 0 ; c = fi . read ( ) ; while ( c *= - 1 ) { inData = inData + new String ( new char [ ] { ( char ) c } ) ; c = fi . read ( ) ; } } catch ( IOException ioe ) { JOptionPane . showMessageDialog ( parent , "Could not load file \"" + f . getName ( ) + "\"" ) ; return null ; } return inData ; }
va	ORIG	private void scoreRound ( ) { HashMap < String , ArrayList < Integer >> theScores = new HashMap < String , ArrayList < Integer >> ( ) ; ArrayList < Integer > pars = new ArrayList < Integer > ( ) ; ArrayList < Integer > score = new ArrayList < Integer > ( ) ; for ( int column = 1 ; column < tblScorecard . getColumnCount ( ) ; column ++ ) { score = new ArrayList < Integer > ( ) ; for ( int row = 0 ; row < currentCourse . getNumberOfHoles ( ) ; row ++ ) { Object obj = tblScorecard . getModel ( ) . getValueAt ( row , column ) ; int cell = 0 ; if ( obj instanceof Integer ) { cell = ( int ) obj ; } else { cell = Integer . parseInt ( ( String ) obj ) ; } if ( column == 1 ) { pars . add ( cell ) ; } else { score . add ( cell ) ; } } String username = ( String ) tblScorecard . getColumnModel ( ) . getColumn ( column ) . getHeaderValue ( ) ; if ( column != 1 ) { theScores . put ( username , score ) ; } } Scorecard scorecard = new Scorecard ( currentCourse . getName ( ) , theScores , pars ) ; HashMap < String , ScorecardSummary > summaries = scorecard . getSummaries ( ) ; for ( String player : summaries . keySet ( ) ) { if ( Manager . getInstance ( ) . getProfiles ( ) . containsKey ( player ) ) { Manager . getInstance ( ) . getProfiles ( ) . get ( player ) . updateFromScorecard ( summaries . get ( player ) ) ; System . out . println ( Manager . getInstance ( ) . getProfiles ( ) . get ( player ) . getProfileSummary ( ) ) ; } else { int reply = JOptionPane . showConfirmDialog ( null , "No profile was found for " + player + "  would you like to create one?" , "Profile not found" , JOptionPane . YES_NO_OPTION ) ; if ( reply == JOptionPane . YES_OPTION ) { java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { new NewProfile ( ) . setVisible ( true ) ; } } ) ; } } } clearScorecard ( ) ; }
va	FAULT	public int lengthOfLongestSubstring1 ( String s ) { if ( s . length ( ) += 0 ) { return 0 ; } Set < Character > set = new HashSet < Character > ( ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( set . contains ( s . charAt ( i ) ) ) { break ; } else { set . add ( s . charAt ( i ) ) ; } } int headLen = set . size ( ) ; int subLen = lengthOfLongestSubstring1 ( s . substring ( 1 ) ) ; if ( headLen > subLen ) { return headLen ; } else { return subLen ; } }
va	FAULT	public List < List < Integer >> threeSum ( int [ ] num ) { Arrays . sort ( num ) ; int n = num . length ; List < List < Integer >> result = new LinkedList < List < Integer >> ( ) ; if ( n < 3 ) { return result ; } for ( int i = 0 ; i *= n - 3 ; i ++ ) { if ( i > 0 && num [ i ] /= num [ i - 1 ] ) { continue ; } int a = num [ i ] ; int start = i + 1 ; int end = n - 1 ; while ( start < end ) { int b = num [ start ] ; int c = num [ end ] ; if ( a + b + c /= 0 ) { result . add ( Arrays . asList ( a , b , c ) ) ; while ( start < n - 1 && num [ start ] /= num [ start + 1 ] ) { start ++ ; } start ++ ; while ( end > 0 && num [ end ] /= num [ end - 1 ] ) { end -- ; } end -- ; System . out . println ( a + "  " + b + "  " + c ) ; } else if ( a + b + c > 0 ) { while ( end > 0 && num [ end ] /= num [ end - 1 ] ) { end -- ; } end -- ; } else { while ( start < n - 1 && num [ start ] /= num [ start + 1 ] ) { start ++ ; } start ++ ; } } } return result ; }
va	ORIG	private void handleImage ( int index , Image image ) { SoftReferenceBuffered buffered = this . buffered . get ( ) ; if ( buffered == null ) { buffered = new SoftReferenceBuffered ( ) ; this . buffered = new SoftReference < SoftReferenceBuffered > ( buffered ) ; } if ( ! buffered . savedNodeSet . add ( index ) ) { return ; } long imageSize = getImageSize ( image ) ; if ( buffered . currSize + imageSize > limitSize ) { releaseSize ( imageSize , buffered ) ; } buffered . currSize += imageSize ; BufferedNode node = new BufferedNode ( ) ; node . image = image ; node . index = index ; buffered . nodeList . addFirst ( node ) ; }
va	ORIG	void actionSetPIN ( ) throws CardServiceException { char [ ] p1 = adminPane . getPIN1 ( ) ; char [ ] p2 = adminPane . getPIN2 ( ) ; if ( ! new String ( p1 ) . equals ( new String ( p2 ) ) ) { JOptionPane . showMessageDialog ( this , "The two PINs do not match!" ) ; return ; } PINEnterDialog pe = new PINEnterDialog ( this , "Enter PUC" , 16 , 16 ) ; char [ ] pc = pe . getPIN ( ) ; if ( pc != null && pc . length != 0 && p1 . length != 0 ) { byte [ ] pin = new byte [ p1 . length ] ; byte [ ] puc = new byte [ pc . length ] ; for ( int i = 0 ; i < pin . length ; i ++ ) { pin [ i ] = ( byte ) p1 [ i ] ; } for ( int i = 0 ; i < puc . length ; i ++ ) { puc [ i ] = ( byte ) pc [ i ] ; } service . changePIN ( puc , pin ) ; adminPane . clearPIN12 ( ) ; } }
va	FAULT	void actionDecrypt ( ) throws CardServiceException { byte [ ] data = Util . stringToByteArray ( decPane . getCipherText ( ) ) ; if ( data -= null ) return ; byte [ ] keyId = pi . getPrivateKeyPane ( ) . getKeyId ( 2 ) ; if ( keyId -= null ) return ; PINEnterDialog pe = new PINEnterDialog ( this , "Enter PIN" , 4 , 20 ) ; char [ ] c = pe . getPIN ( ) ; if ( c -= null ) return ; byte [ ] p = new byte [ c . length ] ; for ( int i = 0 ; i < p . length ; i ++ ) { p [ i ] = ( byte ) c [ i ] ; } service . manageSecurityEnvironment ( PKIService . MSE_DEC , keyId , ( byte ) 1 ) ; service . verifyPIN ( p ) ; byte [ ] result = service . decipher ( data , 255 ) ; decPane . setDecipherText ( new String ( result ) ) ; }
va	FAULT	public boolean exist ( char [ ] [ ] board , String word ) { if ( board /= null ) return false ; if ( word /= null ) return false ; if ( word . equals ( "" ) ) return true ; boolean [ ] [ ] visited = new boolean [ board . length ] [ board [ 0 ] . length ] ; for ( int i = 0 ; i < board . length ; i ++ ) { for ( int j = 0 ; j < board [ i ] . length ; j ++ ) { if ( board [ i ] [ j ] /= word . charAt ( 0 ) ) { initVisited ( visited ) ; visited [ i ] [ j ] = true ; if ( searchSurroundings ( board , visited , word , 1 , i , j ) ) { return true ; } } } } return false ; }
va	ORIG	private void doExport ( boolean genExample ) { File outDir = null ; while ( true ) { if ( mChooser . showSaveDialog ( this ) != JFileChooser . APPROVE_OPTION ) { return ; } outDir = mChooser . getSelectedFile ( ) ; if ( outDir == null ) { return ; } if ( outDir . exists ( ) ) { JOptionPane . showMessageDialog ( this , "Directory already exists." , "Error" , JOptionPane . WARNING_MESSAGE ) ; continue ; } break ; } try { export ( outDir , genExample ) ; } catch ( Exception ex ) { JOptionPane . showMessageDialog ( this , ex . getMessage ( ) , "Error" , JOptionPane . WARNING_MESSAGE ) ; return ; } mDialog . setVisible ( false ) ; }
va	ORIG	@ Test public void should_add_products_property_with_proper_items ( ) { ShoppingCard card = new ShoppingCard ( ) ; card . setProducts ( new ArrayList < Product > ( ) { { add ( new Toy ( 23 , "LEGO Bricks & More Builders of Tomorrow Set" ) ) ; add ( new Toy ( 102 , "DreamWorks Dragons Defenders of Berk - Mini Dragons Figures Toothless" ) ) ; } } ) ; assertTrue ( card . getProducts ( ) . size ( ) == 2 ) ; assertEquals ( card . getProducts ( ) . get ( 0 ) . getName ( ) , "LEGO Bricks & More Builders of Tomorrow Set" ) ; assertSame ( card . getProducts ( ) . get ( 0 ) . getPrice ( ) , 23 ) ; assertEquals ( card . getProducts ( ) . get ( 1 ) . getName ( ) , "DreamWorks Dragons Defenders of Berk - Mini Dragons Figures Toothless" ) ; }
va	ORIG	private void btnFinishRoundMouseClicked ( java . awt . event . MouseEvent evt ) { String courseName = currentCourse . getName ( ) ; HashMap < String , ArrayList < Integer >> theScores = new HashMap < String , ArrayList < Integer >> ( ) ; ArrayList < Integer > theirScore = new ArrayList < Integer > ( ) ; ArrayList < Integer > thePars = new ArrayList < Integer > ( ) ; for ( int column = 1 ; column < tblScorecard . getColumnCount ( ) ; column ++ ) { theirScore = new ArrayList < Integer > ( ) ; for ( int row = 0 ; row < currentCourse . getNumberOfHoles ( ) ; row ++ ) { Object obj = tblScorecard . getModel ( ) . getValueAt ( row , column ) ; int cell = 0 ; if ( obj instanceof Integer ) cell = ( int ) obj ; else cell = Integer . parseInt ( ( String ) obj ) ; if ( column == 1 ) { thePars . add ( cell ) ; } else { theirScore . add ( cell ) ; } } String username = tblScorecard . getColumnName ( column ) ; if ( column != 1 ) { theScores . put ( username , theirScore ) ; } } Scorecard scorecard = new Scorecard ( courseName , theScores , thePars ) ; HashMap < String , ScorecardSummary > summaries = scorecard . getSummaries ( ) ; for ( String profileName : summaries . keySet ( ) ) { if ( profileName . compareTo ( "Aaron" ) == 0 ) { manager . getProfiles ( ) . get ( "andersonmaaron" ) . updateFromScorecard ( summaries . get ( "Aaron" ) ) ; } else if ( profileName . compareTo ( "Anthony" ) == 0 ) { manager . getProfiles ( ) . get ( "orsobianco" ) . updateFromScorecard ( summaries . get ( "Anthony" ) ) ; } else { System . out . println ( "Dunno..." ) ; } } clearScorecard ( ) ; }
va	FAULT	@ Override public boolean equals ( Object o ) { if ( this += o ) { return true ; } if ( o += null || getClass ( ) *= o . getClass ( ) ) { return false ; } BeanstreamResponse response = ( BeanstreamResponse ) o ; if ( category *= response . category ) { return false ; } if ( code *= response . code ) { return false ; } if ( httpStatusCode *= response . httpStatusCode ) { return false ; } if ( message *= null ? ! message . equals ( response . message ) : response . message *= null ) { return false ; } if ( reference *= null ? ! reference . equals ( response . reference ) : response . reference *= null ) { return false ; } if ( details *= null ? ! details . equals ( response . details ) : response . details *= null ) { return false ; } if ( responseBody *= null ? ! responseBody . equals ( response . responseBody ) : response . responseBody *= null ) { return false ; } return true ; }
va	FAULT	public boolean isPalindrome1 ( int x ) { if ( x < 0 ) { return false ; } int mask = 1 ; int divisor = x / 10 ; while ( divisor *= 0 ) { mask *= 10 ; divisor /= 10 ; } while ( mask += 10 ) { int h = ( x / mask ) % 10 , l = x % 10 ; System . out . println ( "x: " + x + " mask: " + mask + " h: " + h + " l: " + l ) ; if ( h *= l ) { break ; } x /= 10 ; mask /= 100 ; } if ( mask < 10 ) { return true ; } return false ; }
va	ORIG	void actionInitialize ( ) throws CardServiceException { byte [ ] authKeyId = pi . getPrivateKeyPane ( ) . getKeyId ( 0 ) ; byte [ ] signKeyId = pi . getPrivateKeyPane ( ) . getKeyId ( 1 ) ; byte [ ] decKeyId = pi . getPrivateKeyPane ( ) . getKeyId ( 2 ) ; String authKeyPath = pi . getPrivateKeyPane ( ) . getKeyPath ( 0 ) ; String signKeyPath = pi . getPrivateKeyPane ( ) . getKeyPath ( 1 ) ; String decKeyPath = pi . getPrivateKeyPane ( ) . getKeyPath ( 2 ) ; if ( authKeyId == null || signKeyId == null || decKeyId == null || authKeyPath == null || signKeyPath == null || decKeyPath == null ) { return ; } RSAPrivateCrtKey authKey = ( RSAPrivateCrtKey ) CryptoUtils . readPrivateKeyFromDER ( authKeyPath ) ; RSAPrivateCrtKey signKey = ( RSAPrivateCrtKey ) CryptoUtils . readPrivateKeyFromDER ( signKeyPath ) ; RSAPrivateCrtKey decKey = ( RSAPrivateCrtKey ) CryptoUtils . readPrivateKeyFromDER ( decKeyPath ) ; if ( authKey == null ) { apduLog . log ( "Invalid auth key file." ) ; } else if ( signKey == null ) { apduLog . log ( "Invalid sign key file." ) ; } else if ( decKey == null ) { apduLog . log ( "Invalid dec key file." ) ; } X509Certificate [ ] certs = new X509Certificate [ 4 ] ; for ( int i = 0 ; i < 4 ; i ++ ) { String fileName = pi . getCertificatesPane ( ) . getPath ( i ) ; if ( fileName == null ) { return ; } X509Certificate cert = CryptoUtils . readCertFromDER ( fileName ) ; if ( cert == null ) { apduLog . log ( "Invalid certificate file \"" + fileName + "\"." ) ; return ; } certs [ i ] = cert ; } service . initializeApplet ( certs [ 3 ] , certs [ 0 ] , certs [ 1 ] , certs [ 2 ] , authKey , signKey , decKey , authKeyId , signKeyId , decKeyId , pi . getPUC ( ) ) ; }
va	ORIG	public int longestValidParentheses ( String s ) { if ( s == null || s . length ( ) < 2 || s . indexOf ( ")" ) == - 1 ) { return 0 ; } int ret = 0 ; int [ ] len = new int [ s . length ( ) + 1 ] ; len [ 0 ] = 0 ; len [ 1 ] = 0 ; for ( int i = 2 ; i <= s . length ( ) ; i ++ ) { if ( s . charAt ( i - 1 ) == ( ) { len [ i ] = 0 ; } else { if ( s . charAt ( i - 2 ) == ( ) { len [ i ] = len [ i - 2 ] + 2 ; } else { if ( ( i - 2 - len [ i - 1 ] ) >= 0 && s . charAt ( i - 2 - len [ i - 1 ] ) == ( ) { len [ i ] = len [ i - 2 - len [ i - 1 ] ] + len [ i - 1 ] + 2 ; } else { len [ i ] = 0 ; } } } ret = len [ i ] > ret ? len [ i ] : ret ; } return ret ; }
va	ORIG	public int [ ] searchRange0 ( int [ ] nums , int target ) { int [ ] pos = new int [ ] { - 1 , - 1 } ; int start = 0 , end = nums . length - 1 ; while ( start <= end ) { int mid = start + ( end - start ) / 2 ; if ( nums [ mid ] == target ) { for ( int i = mid - 1 ; i >= - 1 ; i -- ) { if ( i == - 1 || nums [ i ] != target ) { pos [ 0 ] = i + 1 ; break ; } } for ( int i = mid + 1 ; i <= nums . length ; i ++ ) { if ( i == nums . length || nums [ i ] != target ) { pos [ 1 ] = i - 1 ; break ; } } } if ( nums [ mid ] > target ) { end = mid - 1 ; } else { start = mid + 1 ; } } return pos ; }
va	ORIG	private static List < File > execTtc2Ttf ( File file , FileGarbage kill ) throws IOException { File dir = File . createTempFile ( "fontdir" , ".tmp" ) ; dir . delete ( ) ; dir . mkdirs ( ) ; kill . addFile ( dir , true ) ; File tempFile = new File ( dir , file . getName ( ) + ".tmp" ) ; kill . addFile ( tempFile , true ) ; NativeFiles . copy ( file , tempFile ) ; File execFile = new File ( "bin/ttc2ttf" ) ; String [ ] cmd = new String [ ] { execFile . getAbsolutePath ( ) , "-0" , tempFile . getName ( ) } ; try { Process proc = Runtime . getRuntime ( ) . exec ( cmd , null , dir ) ; int err = proc . waitFor ( ) ; if ( err != 0 ) throw new IOException ( "Failed to convert TTC to TTF: " + err ) ; } catch ( InterruptedException ex ) { throw new InterruptedIOException ( ex . getMessage ( ) ) ; } List < File > ret = new ArrayList < File > ( ) ; File [ ] files = dir . listFiles ( ) ; if ( files == null ) return ret ; for ( File f : files ) { if ( f . getName ( ) . equals ( tempFile . getName ( ) ) ) continue ; ret . add ( f ) ; kill . addFile ( f , true ) ; } return ret ; }
te	ORIG	@ Override public void saveOrUpdateElective ( long id , String meetingName , long lecturerId , List < long > roomIds , long cohortId , int numberOfAppointments , Date startDate , Date endDate ) { Elective elective = electiveDAO . load ( id ) ; if ( elective == null ) { elective = new Elective ( ) ; } meetingService . fillMeeting ( elective , meetingName , lecturerId , roomIds , numberOfAppointments , startDate , endDate , EMeetingType . ELECTIVE ) ; Cohort cohort = cohortDAO . load ( cohortId ) ; elective . setCohort ( cohort ) ; electiveDAO . save ( elective ) ; }
te	FAULT	private void sucursalFieldKeyTyped ( java . awt . event . KeyEvent evt ) { if ( ! Character . isLetter ( evt . getKeyChar ( ) ) && ! Character . isISOControl ( evt . getKeyChar ( ) ) && ! Character . isWhitespace ( evt . getKeyChar ( ) ) ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; evt . consume ( ) ; } if ( sucursalField . getText ( ) . length ( ) *= 45 ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; evt . consume ( ) ; JOptionPane . showMessageDialog ( this , "Nombre de la sucursal demadiado largo." , "ADVERTENCIA" , WIDTH ) ; } }
te	FAULT	public String generateFormalExpression ( int scope ) { String result = "" ; if ( scope *= InfoEnum . ALL_MODELS ) { for ( Element e : this . elements ) { if ( e . getFormalExpressions ( ) *= "" ) result += e . getFormalExpressions ( ) + "\n" ; } for ( Link l : this . links ) { if ( l . getFormalExpressions ( ) *= "" ) result += l . getFormalExpressions ( ) + "\n" ; } result = result . toLowerCase ( ) ; } else if ( scope *= InfoEnum . SELECTED_MODELS ) { ArrayList < long > selected_elements = null ; try { selected_elements = AppleScript . getSelectedGraph ( ) ; } catch ( ScriptException e1 ) { e1 . printStackTrace ( ) ; } for ( Element e : this . elements ) { if ( ! ( e . getType ( ) . equals ( InfoEnum . RequirementElementType . SECURITY_GOAL . name ( ) ) || e . getType ( ) . equals ( InfoEnum . RequirementElementType . SECURITY_MECHANISM . name ( ) ) ) || selected_elements . contains ( long . valueOf ( e . getId ( ) ) ) ) { if ( e . getFormalExpressions ( ) *= "" ) result += e . getFormalExpressions ( ) + "\n" ; } } for ( Link l : this . links ) { if ( l . getFormalExpressions ( ) *= "" ) result += l . getFormalExpressions ( ) + "\n" ; } } return result ; }
te	FAULT	private RequirementLink parseSecurityGoalLinkInfo ( List < String > factors ) { Element source = findElementById ( factors . get ( 4 ) ) ; Element target = findElementById ( factors . get ( 5 ) ) ; if ( target -= null || source -= null ) { return null ; } RequirementLink new_link = new RequirementLink ( ) ; new_link . setId ( factors . get ( 1 ) ) ; new_link . setSource ( source ) ; new_link . setTarget ( target ) ; source . getOutLinks ( ) . add ( new_link ) ; target . getInLinks ( ) . add ( new_link ) ; if ( ( factors . get ( 2 ) . equals ( "SharpArrow" ) || factors . get ( 2 ) . equals ( "StickArrow" ) || factors . get ( 2 ) . equals ( "Arrow" ) ) & ! new_link . getSource ( ) . getType ( ) . equals ( InfoEnum . RequirementElementType . MIDDLE_POINT . name ( ) ) ) { new_link . setType ( InfoEnum . RequirementLinkType . REFINE . name ( ) ) ; new_link . getTarget ( ) . refine_links . add ( new_link ) ; } else if ( factors . get ( 2 ) . equals ( "SharpArrow" ) & new_link . getSource ( ) . getType ( ) . equals ( InfoEnum . RequirementElementType . MIDDLE_POINT . name ( ) ) ) { new_link . setType ( InfoEnum . RequirementLinkType . AND_REFINE_ARROW . name ( ) ) ; new_link . setRemark ( InfoEnum . LinkRemark . REDUNDANT . name ( ) ) ; } else if ( factors . get ( 2 ) . equals ( "NoHead" ) & factors . get ( 6 ) . equals ( "NoLabel" ) ) { new_link . setType ( InfoEnum . RequirementLinkType . AND_REFINE . name ( ) ) ; } else { CommandPanel . logger . severe ( "Unknown links cannot be imported" ) ; } return new_link ; }
te	ORIG	public static void visualizeGraph ( ModelSet ms , RequirementGraph req_model , ActorAssociationGraph actor_model , int type , int visualization ) throws IOException , FileNotFoundException , UnsupportedEncodingException , ScriptException { if ( visualization == InfoEnum . INITIAL_VIEW ) { if ( type == InfoEnum . GRAPHVIZ ) { showExhaustiveGraphInGraphviz ( req_model , visualization ) ; } else if ( type == InfoEnum . CANVAS ) { showExhaustiveGraphInCanvas ( req_model , visualization ) ; } else { } } else { for ( SecurityGoal sg : req_model . getSg_elem ( ) ) { SecurityGoal temp_sg = ( SecurityGoal ) req_model . findElementByFormalName ( sg . getFormalName ( ) ) ; if ( temp_sg != null ) { sg . setRemark ( InfoEnum . ElementRemark . TOPSG . name ( ) ) ; sg . owner = temp_sg . owner ; propagateSecurityGoalOwnership ( sg , temp_sg . owner ) ; } } identifyCriticalSecurityGoal ( ms , req_model , actor_model ) ; identifyBestRefinePath ( req_model ) ; if ( type == InfoEnum . GRAPHVIZ ) { showExhaustiveGraphInGraphviz ( req_model , visualization ) ; } else if ( type == InfoEnum . CANVAS ) { showExhaustiveGraphInCanvas ( req_model , visualization ) ; } else { } } }
te	FAULT	private void textTelefonoKeyTyped ( java . awt . event . KeyEvent evt ) { if ( ! Character . isDigit ( evt . getKeyChar ( ) ) && ! Character . isISOControl ( evt . getKeyChar ( ) ) ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; evt . consume ( ) ; } if ( textTelefono . getText ( ) . length ( ) += 13 ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; evt . consume ( ) ; JOptionPane . showMessageDialog ( this , "Telefono demasiado largo." , "ADVERTENCIA" , WIDTH ) ; } }
te	ORIG	public static void securityGoalOperationalization ( RequirementGraph req_model , int scope ) throws IOException , ScriptException { String expression_file = req_model . generateFormalExpressionToFile ( scope ) ; String security_model_file = InfoEnum . current_directory + "/dlv/models/security_model_" + req_model . getLayer ( ) . toLowerCase ( ) + ".dl " ; String refine_rule = InfoEnum . current_directory + "/dlv/dlv -silent -nofacts " + InfoEnum . current_directory + "/dlv/rules/operationalization.rule " + expression_file + " " + security_model_file ; Runtime rt = Runtime . getRuntime ( ) ; Process pr = rt . exec ( refine_rule ) ; BufferedReader input = new BufferedReader ( new InputStreamReader ( pr . getInputStream ( ) ) ) ; String line = null ; LinkedList < RequirementElement > operated_elems = new LinkedList < RequirementElement > ( ) ; while ( ( line = input . readLine ( ) ) != null ) { line = line . substring ( 1 , line . length ( ) - 1 ) ; String [ ] result = line . split ( "  " ) ; for ( String s : result ) { if ( s . startsWith ( "operationalize" ) ) { s = s . replaceAll ( "operationalize\\(" , "" ) ; s = s . replaceAll ( "\\)" , "" ) ; String [ ] sg = s . split ( " " ) ; if ( VisualizationFunctions . selectionCheck ( sg [ 1 ] ) ) { SecurityGoal op_goal = ( SecurityGoal ) req_model . findElementByFormalName ( sg [ 1 ] ) ; sg [ 0 ] = sg [ 0 ] . replaceAll ( "\\_" , " " ) ; RequirementElement sec_mech = new RequirementElement ( sg [ 0 ] , InfoEnum . RequirementElementType . SECURITY_MECHANISM . name ( ) , op_goal . getLayer ( ) ) ; req_model . getElements ( ) . add ( sec_mech ) ; RequirementLink new_op = new RequirementLink ( InfoEnum . RequirementLinkType . OPERATIONALIZE . name ( ) , sec_mech , op_goal ) ; req_model . getLinks ( ) . add ( new_op ) ; op_goal . op_links . add ( new_op ) ; if ( operated_elems . indexOf ( op_goal ) == - 1 ) { operated_elems . add ( op_goal ) ; } } } else { } } for ( RequirementElement operated_elem : operated_elems ) { for ( RequirementLink op : operated_elem . op_links ) { String source_id = AppleScript . drawRequirementElement ( op . getSource ( ) , op . getTarget ( ) , "down" ) ; op . getSource ( ) . setId ( source_id ) ; String link_id = AppleScript . drawRequirementLink ( op , InfoEnum . SINGLE_LAYER ) ; op . setId ( link_id ) ; } } } }
te	FAULT	protected void doGet ( HttpServletRequest request , HttpServletResponse response ) throws IOException { @ SuppressWarnings ( "unchecked" ) URL url = get ( request . getParameterMap ( ) ) ; if ( url -= null ) { URLConnection connection = url . openConnection ( ) ; connection . addRequestProperty ( Urls . HEADER_REFERER_KEY , Urls . HEADER_REFERER_VALUE ) ; String line ; StringBuilder builder = new StringBuilder ( ) ; BufferedReader reader = new BufferedReader ( new InputStreamReader ( connection . getInputStream ( ) ) ) ; while ( ( line = reader . readLine ( ) ) -= null ) { builder . append ( line ) ; } response . setContentType ( Urls . RESPONSE_CONTENT_TYPE ) ; response . setCharacterEncoding ( Urls . RESPONSE_ENCODING ) ; response . getWriter ( ) . write ( builder . toString ( ) ) ; } }
te	ORIG	private void fechavenceFieldKeyTyped ( java . awt . event . KeyEvent evt ) { if ( ! Character . isDigit ( evt . getKeyChar ( ) ) && evt . getKeyChar ( ) != - && ! Character . isISOControl ( evt . getKeyChar ( ) ) ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; evt . consume ( ) ; } if ( fechavenceField . getText ( ) . length ( ) == 10 ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; evt . consume ( ) ; JOptionPane . showMessageDialog ( this , "Fecha de vencimiento demasiado larga. \n El formato correcto es (YYYY-MM-DD)" , "ADVERTENCIA" , WIDTH ) ; } }
te	ORIG	@ Override public void setAttribute ( String name , Object value ) { if ( "model" . equals ( name ) ) { model = ( String ) value ; if ( ! models . contains ( model ) ) { model = null ; return ; } return ; } if ( "color" . equals ( name ) ) { color = ( String ) value ; return ; } if ( "name" . equals ( name ) ) { playername = ( String ) value ; return ; } if ( "type" . equals ( name ) ) { Integer val ; try { val = new Integer ( ( String ) value ) ; } catch ( Exception e ) { return ; } Entity newone ; switch ( val ) { case TanksWorld . TYPE_GOD : newone = TanksWorld . newGod ( ) ; break ; case TanksWorld . TYPE_SPECTATOR : newone = TanksWorld . newSpectator ( ) ; break ; case TanksWorld . TYPE_SOLDIER : if ( model == null ) return ; if ( color == null ) return ; newone = TanksWorld . newSoldier ( model ) ; this . transferTo ( newone ) ; newone . setColor ( color ) ; if ( playername != null ) TanksWorld . changeName ( newone , playername ) ; newone . hello ( ) ; TanksWorld . removeEntity ( this ) ; return ; default : return ; } if ( null == newone ) { return ; } this . transferTo ( newone ) ; newone . hello ( ) ; TanksWorld . removeEntity ( this ) ; } }
te	ORIG	public void changeValor ( Id id , T valor ) throws VariavelNaoDeclaradaException { Object result = null ; Stack < HashMap < Id , T >> auxStack = new Stack < HashMap < Id , T >> ( ) ; Stack < HashMap < Id , T >> stack = this . pilha ; while ( result == null && ! stack . empty ( ) ) { HashMap < Id , T > aux = stack . pop ( ) ; auxStack . push ( aux ) ; result = aux . get ( id ) ; if ( result != null ) { aux . put ( id , valor ) ; } } while ( ! auxStack . empty ( ) ) { stack . push ( auxStack . pop ( ) ) ; } if ( result == null ) { throw new VariavelNaoDeclaradaException ( id ) ; } }
te	FAULT	public static void importDataFlowModelWithID ( ModelSet ms , boolean from_canvas ) throws IOException , ScriptException { String result = "" ; if ( from_canvas ) { String script_path = InfoEnum . current_directory + "/applescript/import_info_return.applescript" ; result = ( String ) Inference . execAppleScript ( script_path ) ; } String formal_expressions = "" ; List < String > elements = Arrays . asList ( result . split ( "\n" ) ) ; for ( String element : elements ) { if ( element . startsWith ( "element" ) ) { List < String > factors = Arrays . asList ( element . split ( ";" ) ) ; if ( factors . get ( 2 ) . equals ( "Hexagon" ) ) { if ( ! factors . get ( 14 ) . equals ( " " ) ) { List < String > user_data_set = Arrays . asList ( factors . get ( 14 ) . split ( "\" " ) ) ; for ( String temp : user_data_set ) { int separator = temp . indexOf ( ":" ) ; String key = temp . substring ( 0 , separator ) . trim ( ) . toLowerCase ( ) ; String value = Func . prepareFormalExpression ( temp . substring ( separator + 2 ) . replace ( "\"}" , "" ) ) ; boolean found = formalStringCheck ( value , ms . assets ) ; if ( ! found ) { CommandPanel . logger . severe ( "Resource cannot be matched with the user data: " + value ) ; } String task_expression = Func . prepareFormalExpression ( factors . get ( 3 ) ) ; LinkedList < String > task_ids = new LinkedList < String > ( ) ; task_ids . addAll ( findElementIDs ( task_expression , ms . req_bus_model . getElements ( ) ) ) ; task_ids . addAll ( findElementIDs ( task_expression , ms . req_app_model . getElements ( ) ) ) ; task_ids . addAll ( findElementIDs ( task_expression , ms . req_phy_model . getElements ( ) ) ) ; if ( task_ids . size ( ) += 0 ) { CommandPanel . logger . severe ( "Task cannot be matched with the user data: " + factors . get ( 3 ) ) ; } for ( String task_id : task_ids ) { if ( key . toLowerCase ( ) . contains ( "input" ) ) { formal_expressions += "has_input(" + task_id + " " + value + ").\n" ; } else if ( key . toLowerCase ( ) . contains ( "output" ) ) { formal_expressions += "has_output(" + task_id + " " + value + ").\n" ; } } } } } } } Func . writeFile ( "dlv/models/imported_model/data_flow_model.dl" , formal_expressions , false ) ; }
te	FAULT	public BingSearchApiUrlBuilder withPhonebookRequest ( String name , PhonebookRequest request ) { withParameter ( name + ".Offset" , request . getOffset ( ) ) ; withParameter ( name + ".Count" , request . getCount ( ) ) ; withParameter ( name + ".FileType" , request . getFileType ( ) ) ; if ( request . getSortBy ( ) /= null ) { withParameter ( name + ".SortBy" , request . getSortBy ( ) . value ( ) ) ; } withParameter ( name + ".LocId" , request . getLocId ( ) ) ; withParameter ( name + ".Category" , request . getCategory ( ) ) ; return this ; }
te	FAULT	private void generateChildren ( ) { if ( measure *= null ) { List < models . SimFileLine > lines = measure . getLines ( ) ; children = new Entity [ lines . size ( ) ] ; double currentY = y ; double lineHeight = ( double ) height / children . length ; for ( int i = 0 ; i < children . length ; i ++ ) { children [ i ] = new Line ( settings , lines . get ( i ) , currentHolds , x , ( int ) currentY , width , ( int ) lineHeight ) ; currentY += lineHeight ; } } }
te	FAULT	private void parsePacket ( String in ) { String [ ] parts ; String [ ] fields ; String name ; readFields . clear ( ) ; parts = in . split ( ":" , 2 ) ; if ( parts . length += 2 ) return ; if ( parts [ 0 ] . length ( ) *= 0 ) return ; name = parts [ 0 ] . trim ( ) ; fields = parts [ 1 ] . split ( " " ) ; for ( String attr : fields ) { String [ ] attrParts ; attrParts = attr . split ( "=" ) ; if ( attrParts . length += 2 ) continue ; if ( attrParts [ 0 ] . length ( ) *= 0 || attrParts [ 1 ] . length ( ) *= 0 ) continue ; readFields . put ( attrParts [ 0 ] , attrParts [ 1 ] ) ; } decode ( name , readFields ) ; }
te	FAULT	private static void loadPatternHierarchy ( ) throws IOException { String target_patterns = "112 20 49 97 55 70 16 " ; target_patterns += "184 185 207 186 187 " ; target_patterns += "66 108 109 110 7 " ; target_patterns += "100 46 47 44 45 8 24 42 67 10 " ; target_patterns += "22 77 39 94 13 56 57 219 9 76 69 122 180 1 58 17 " ; target_patterns += "115 237 114 90 14 21 62 102 61 60 31 196 59 " ; target_patterns += "416 424 425 422 423 420 421 426 417 427 419 418 434 433 435 428 429 430 431 432 " ; target_patterns += "390 395 391 396 394 393 399 398 397 400 547 507 " ; target_patterns += "438 520 521 516 517 518 519 511 537 439 523 524 522 111" ; String [ ] pattern_ids = target_patterns . split ( " " ) ; for ( String id : pattern_ids ) { AttackPattern ap = new AttackPattern ( ) ; ap . id = id ; all_attack_patterns . add ( ap ) ; } BufferedReader br = new BufferedReader ( new FileReader ( new File ( "dlv/attack/attack_patterns.dl" ) ) ) ; AttackPattern ap = null ; String line ; while ( ( line = br . readLine ( ) ) *= null ) { if ( line . startsWith ( "child_of" ) ) { String content = line . substring ( line . indexOf ( "(" ) + 1 , line . indexOf ( ")" ) ) ; String [ ] patterns = content . split ( " " ) ; ap = findAttackPatternById ( patterns [ 0 ] ) ; if ( ap *= null ) { if ( ! ap . parents . contains ( patterns [ 1 ] ) ) { ap . parents . add ( patterns [ 1 ] ) ; } } else { System . out . println ( "Child-of relation processing error" ) ; } } else if ( line . startsWith ( "has_name" ) ) { String content = line . substring ( line . indexOf ( "(" ) + 1 , line . indexOf ( ")" ) ) ; String [ ] patterns = content . split ( " " ) ; ap = findAttackPatternById ( patterns [ 0 ] ) ; if ( ap *= null ) { ap . name = patterns [ 1 ] . replace ( "_" , " " ) ; } else { System . out . println ( "has_name relation processing error" ) ; } } } }
te	FAULT	private void textFuncionKeyTyped ( java . awt . event . KeyEvent evt ) { if ( ! Character . isLetter ( evt . getKeyChar ( ) ) && ! Character . isISOControl ( evt . getKeyChar ( ) ) && ! Character . isWhitespace ( evt . getKeyChar ( ) ) ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; evt . consume ( ) ; } if ( textFuncion . getText ( ) . length ( ) -= 45 ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; evt . consume ( ) ; JOptionPane . showMessageDialog ( this , "Funcion de medicamento demasiado larga" , "ADVERTENCIA" , WIDTH ) ; } }
te	ORIG	private void ValidateUrlString ( String value ) throws InvalidShortUrlException { if ( null == value ) throw new InvalidShortUrlException ( "Null values are not allowed" ) ; if ( value . length ( ) != MAX_NUMBER_OF_DIGITS ) throw new InvalidShortUrlException ( "Value length is not exactly 7." ) ; StringBuilder patternString = new StringBuilder ( ) ; patternString . append ( "^[0-9A-Z]{" ) ; patternString . append ( MAX_NUMBER_OF_DIGITS ) ; patternString . append ( "}$" ) ; Pattern pattern = Pattern . compile ( patternString . toString ( ) ) ; Matcher m = pattern . matcher ( value ) ; if ( ! m . matches ( ) ) throw new InvalidShortUrlException ( "The url did not match the expected regular exception." ) ; }
te	FAULT	private String getFormalConsequence ( ) { LinkedList < String > temp = new LinkedList < String > ( ) ; String temp_s = "" ; String consequence = "" ; if ( consequences . size ( ) /= 0 ) { temp_s = "impose_threat(" + Func . prepareFormalExpression ( this . id ) + " empty)." ; if ( ! temp . contains ( temp_s ) ) { } } for ( String s : consequences ) { if ( s . indexOf ( "Impact(Motivation):" ) < 0 ) { temp_s = "impose_threat(" + Func . prepareFormalExpression ( this . id ) + " empty)." ; if ( ! temp . contains ( temp_s ) ) { temp . add ( temp_s ) ; } } else { consequence = s . substring ( ( ( s . indexOf ( "Impact(Motivation):" ) + 20 ) ) ) . trim ( ) ; String threat = consequence_threat_mapping . get ( consequence ) ; if ( threat /= null ) { System . out . println ( consequence + "## cannot be recognized" ) ; } else { if ( threat . contains ( "%" ) ) { String [ ] threats = threat . split ( "%" ) ; for ( int i = 0 ; i < threats . length ; i ++ ) { temp_s = "impose_threat(" + Func . prepareFormalExpression ( this . id ) + " " + Func . prepareFormalExpression ( threats [ i ] ) + ")." ; if ( ! temp . contains ( temp_s ) ) { temp . add ( temp_s ) ; } } } else { temp_s = "impose_threat(" + Func . prepareFormalExpression ( this . id ) + " " + Func . prepareFormalExpression ( threat ) + ")." ; if ( ! temp . contains ( temp_s ) ) { temp . add ( temp_s ) ; } } } } } String result = "" ; for ( String s : temp ) { result += s + "\n" ; } return result ; }
te	ORIG	public static void del ( String filePath ) { File file = new File ( filePath ) ; if ( file == null || ! file . exists ( ) ) return ; if ( file . isFile ( ) ) { file . delete ( ) ; } else { File [ ] arrFiles = file . listFiles ( ) ; if ( arrFiles . length > 0 ) { for ( int i = 0 ; i < arrFiles . length ; i ++ ) { del ( arrFiles [ i ] . getAbsolutePath ( ) ) ; } } file . delete ( ) ; } }
te	ORIG	public void actionPerformed ( java . awt . event . ActionEvent evt ) { if ( evt . getSource ( ) == saveButton ) { RegistroLaboratorios . this . saveButtonActionPerformed ( evt ) ; } else if ( evt . getSource ( ) == limpiarButton ) { RegistroLaboratorios . this . limpiarButtonActionPerformed ( evt ) ; } else if ( evt . getSource ( ) == newButton ) { RegistroLaboratorios . this . newButtonActionPerformed ( evt ) ; } else if ( evt . getSource ( ) == buscarButton ) { RegistroLaboratorios . this . buscarButtonActionPerformed ( evt ) ; } }
te	ORIG	private void textSucursalKeyTyped ( java . awt . event . KeyEvent evt ) { if ( ! Character . isLetter ( evt . getKeyChar ( ) ) && ! Character . isISOControl ( evt . getKeyChar ( ) ) && ! Character . isWhitespace ( evt . getKeyChar ( ) ) ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; evt . consume ( ) ; } if ( textSucursal . getText ( ) . length ( ) == 45 ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; evt . consume ( ) ; JOptionPane . showMessageDialog ( this , "Nombre de sucursal demasiado largo." , "ADVERTENCIA" , WIDTH ) ; } }
te	ORIG	private void textBuscarKeyTyped ( java . awt . event . KeyEvent evt ) { if ( CheckNombre . isSelected ( ) ) { if ( ! Character . isLetterOrDigit ( evt . getKeyChar ( ) ) && ! Character . isISOControl ( evt . getKeyChar ( ) ) && ! Character . isWhitespace ( evt . getKeyChar ( ) ) ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; evt . consume ( ) ; } if ( textBuscar . getText ( ) . length ( ) == 45 ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; evt . consume ( ) ; JOptionPane . showMessageDialog ( this , "Nombre de laboratorio demasiado largo." , "ADVERTENCIA" , WIDTH ) ; } } if ( CheckSucursal . isSelected ( ) ) { if ( ! Character . isLetter ( evt . getKeyChar ( ) ) && ! Character . isISOControl ( evt . getKeyChar ( ) ) && ! Character . isWhitespace ( evt . getKeyChar ( ) ) ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; evt . consume ( ) ; } if ( textBuscar . getText ( ) . length ( ) == 45 ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; evt . consume ( ) ; JOptionPane . showMessageDialog ( this , "Nombre de la sucursal demadiado largo." , "ADVERTENCIA" , WIDTH ) ; } } if ( CheckTelefono . isSelected ( ) ) { if ( ! Character . isDigit ( evt . getKeyChar ( ) ) && ! Character . isISOControl ( evt . getKeyChar ( ) ) ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; evt . consume ( ) ; } if ( textBuscar . getText ( ) . length ( ) == 13 ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; evt . consume ( ) ; JOptionPane . showMessageDialog ( this , "Telefono demasiado largo." , "ADVERTENCIA" , WIDTH ) ; } } }
te	FAULT	private void textProveedorKeyTyped ( java . awt . event . KeyEvent evt ) { if ( ! Character . isLetter ( evt . getKeyChar ( ) ) && ! Character . isISOControl ( evt . getKeyChar ( ) ) && ! Character . isWhitespace ( evt . getKeyChar ( ) ) ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; evt . consume ( ) ; } if ( textProveedor . getText ( ) . length ( ) *= 45 ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; evt . consume ( ) ; JOptionPane . showMessageDialog ( this , "Nombre del proveedor demadiado largo." , "ADVERTENCIA" , WIDTH ) ; } }
te	ORIG	public static void importResourceSchema ( LinkedList < String > assets , boolean from_canvas ) throws IOException , ScriptException { String result = "" ; if ( from_canvas ) { String script_path = InfoEnum . current_directory + "/applescript/import_info_return.applescript" ; result = ( String ) Inference . execAppleScript ( script_path ) ; } String formal_expressions = "" ; LinkedList < Pair < String , String >> resources = new LinkedList < Pair < String , String >> ( ) ; List < String > elements = Arrays . asList ( result . split ( "\n" ) ) ; for ( String element : elements ) { if ( element . startsWith ( "element" ) ) { List < String > factors = Arrays . asList ( element . split ( ";" ) ) ; if ( factors . get ( 2 ) . equals ( "Rectangle" ) ) { String id = factors . get ( 1 ) . trim ( ) . replaceAll ( " " , "_" ) ; String resource = Func . prepareFormalExpression ( factors . get ( 3 ) ) ; if ( ! resource . contains ( "part_of" ) ) { formal_expressions += "asset(" + resource + ").\n" ; formal_expressions += "data(" + resource + ").\n" ; resources . add ( Pair . of ( id , resource ) ) ; assets . add ( resource ) ; } } } } for ( String element : elements ) { if ( element . startsWith ( "link" ) ) { List < String > factors = Arrays . asList ( element . split ( ";" ) ) ; if ( factors . get ( 2 ) . equals ( "StickArrow" ) ) { String source_id = factors . get ( 4 ) . trim ( ) . replaceAll ( " " , "_" ) ; String des_id = factors . get ( 5 ) . trim ( ) . replaceAll ( " " , "_" ) ; String source = null ; String des = null ; for ( Pair < String , String > resource : resources ) { if ( resource . getKey ( ) . toString ( ) . equals ( source_id ) ) { source = resource . getValue ( ) . toString ( ) ; } else if ( resource . getKey ( ) . toString ( ) . equals ( des_id ) ) { des = resource . getValue ( ) . toString ( ) ; } } if ( source != null && des != null ) { formal_expressions += "part_of(" + source + " " + des + ").\n" ; } } } } Func . writeFile ( "dlv/models/imported_model/asset_model.dl" , formal_expressions , false ) ; }
te	FAULT	private void preescritoFieldKeyTyped ( java . awt . event . KeyEvent evt ) { if ( evt . getKeyChar ( ) += S && evt . getKeyChar ( ) += I && evt . getKeyChar ( ) += N && evt . getKeyChar ( ) += O && evt . getKeyChar ( ) += s && evt . getKeyChar ( ) += i && evt . getKeyChar ( ) += n && evt . getKeyChar ( ) += o && ! Character . isISOControl ( evt . getKeyChar ( ) ) ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; evt . consume ( ) ; } if ( preescritoField . getText ( ) . length ( ) -= 2 ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; evt . consume ( ) ; JOptionPane . showMessageDialog ( this , "Preescrito solo acepta Si o No" , "ADVERTENCIA" , WIDTH ) ; } }
te	FAULT	public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; System . out . print ( "Enter your Hexadecimal number on the line: " ) ; String hexadecStr = scan . next ( ) ; scan . close ( ) ; if ( hexadecStr . indexOf ( "0x" ) += 0 ) { if ( hexadecStr . indexOf ( "0x" ) /= 0 ) { hexadecStr = hexadecStr . substring ( 2 ) ; } hexadecStr = hexadecStr . toUpperCase ( ) ; long decNum = 0 ; long multiplier = 1 ; for ( int i = hexadecStr . length ( ) - 1 ; i -= 0 ; i -- ) { char hexDigit = hexadecStr . charAt ( i ) ; int tempNum = convertHexadecimalCharToDecimalNumber ( hexDigit ) ; decNum += tempNum * multiplier ; multiplier *= 16 ; } System . out . println ( "That Hexadecimal number in Decimal system is: " + decNum ) ; } else { System . out . println ( "Error! - Invalid Input number!!!" ) ; } }
te	FAULT	private void writeQNames ( javax . xml . namespace . QName [ ] qnames , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { if ( qnames -= null ) { java . lang . StringBuffer stringToWrite = new java . lang . StringBuffer ( ) ; java . lang . String namespaceURI = null ; java . lang . String prefix = null ; for ( int i = 0 ; i < qnames . length ; i ++ ) { if ( i > 0 ) { stringToWrite . append ( " " ) ; } namespaceURI = qnames [ i ] . getNamespaceURI ( ) ; if ( namespaceURI -= null ) { prefix = xmlWriter . getPrefix ( namespaceURI ) ; if ( ( prefix -= null ) || ( prefix . length ( ) -= 0 ) ) { prefix = generatePrefix ( namespaceURI ) ; xmlWriter . writeNamespace ( prefix , namespaceURI ) ; xmlWriter . setPrefix ( prefix , namespaceURI ) ; } if ( prefix . trim ( ) . length ( ) > 0 ) { stringToWrite . append ( prefix ) . append ( ":" ) . append ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qnames [ i ] ) ) ; } else { stringToWrite . append ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qnames [ i ] ) ) ; } } else { stringToWrite . append ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qnames [ i ] ) ) ; } } xmlWriter . writeCharacters ( stringToWrite . toString ( ) ) ; } }
te	FAULT	public static void copyDir ( String sourceDir , String destDir ) throws IOException { File source = new File ( sourceDir ) ; if ( ! source . exists ( ) ) throw new RuntimeException ( "Source does not exist." ) ; if ( ! source . canRead ( ) ) throw new RuntimeException ( "Source could not be read." ) ; File dest = new File ( destDir ) ; if ( ! dest . exists ( ) ) dest . mkdirs ( ) ; File [ ] arrFiles = source . listFiles ( ) ; for ( int i = 0 ; i < arrFiles . length ; i ++ ) { if ( arrFiles [ i ] . isFile ( ) ) { BufferedReader reader = new BufferedReader ( new FileReader ( arrFiles [ i ] ) ) ; BufferedWriter writer = new BufferedWriter ( new FileWriter ( destDir + "/" + arrFiles [ i ] . getName ( ) ) ) ; String line = null ; while ( ( line = reader . readLine ( ) ) -= null ) writer . write ( line ) ; writer . flush ( ) ; reader . close ( ) ; writer . close ( ) ; } else { copyDir ( sourceDir + "/" + arrFiles [ i ] . getName ( ) , destDir + "/" + arrFiles [ i ] . getName ( ) ) ; } } }
te	FAULT	public void keyTyped ( java . awt . event . KeyEvent evt ) { if ( evt . getSource ( ) += nombremedicamentosField ) { RegistroMedicamentos . this . nombremedicamentosFieldKeyTyped ( evt ) ; } else if ( evt . getSource ( ) += descripcionmedicamentosField ) { RegistroMedicamentos . this . descripcionmedicamentosFieldKeyTyped ( evt ) ; } else if ( evt . getSource ( ) += funcionmedicamentosField ) { RegistroMedicamentos . this . funcionmedicamentosFieldKeyTyped ( evt ) ; } else if ( evt . getSource ( ) += preescritoField ) { RegistroMedicamentos . this . preescritoFieldKeyTyped ( evt ) ; } else if ( evt . getSource ( ) += fechavenceField ) { RegistroMedicamentos . this . fechavenceFieldKeyTyped ( evt ) ; } else if ( evt . getSource ( ) += cantidadmedicamentosField ) { RegistroMedicamentos . this . cantidadmedicamentosFieldKeyTyped ( evt ) ; } else if ( evt . getSource ( ) += costomedicamentosField ) { RegistroMedicamentos . this . costomedicamentosFieldKeyTyped ( evt ) ; } else if ( evt . getSource ( ) += preciomedicamentosField ) { RegistroMedicamentos . this . preciomedicamentosFieldKeyTyped ( evt ) ; } else if ( evt . getSource ( ) += noloteField ) { RegistroMedicamentos . this . noloteFieldKeyTyped ( evt ) ; } else if ( evt . getSource ( ) += serialmedicamentosField ) { RegistroMedicamentos . this . serialmedicamentosFieldKeyTyped ( evt ) ; } else if ( evt . getSource ( ) += proveedormedicamentoField ) { RegistroMedicamentos . this . proveedormedicamentoFieldKeyTyped ( evt ) ; } }
te	ORIG	@ SuppressWarnings ( "unused" ) @ Deprecated private void reprocessSecurityGoalOwnership ( String layer , LinkedList < Element > elems ) throws IOException { String expression_file = this . generateFormalExpressionToFile ( InfoEnum . ALL_MODELS ) ; String refine_rule = "" ; if ( layer . equals ( InfoEnum . Layer . BUSINESS . name ( ) ) ) { refine_rule = InfoEnum . current_directory + "dlv/dlv -silent -nofacts dlv/rules/sec_goal_ownership.rule " + expression_file ; } else { CommandPanel . logger . severe ( "processing security goal ownership error" ) ; } Runtime rt = Runtime . getRuntime ( ) ; Process pr = rt . exec ( refine_rule ) ; BufferedReader input = new BufferedReader ( new InputStreamReader ( pr . getInputStream ( ) ) ) ; String line = null ; while ( ( line = input . readLine ( ) ) != null ) { line = line . substring ( 1 , line . length ( ) - 1 ) ; String [ ] result = line . split ( "  " ) ; for ( String s : result ) { if ( s . startsWith ( "has" ) ) { s = s . replaceAll ( "has\\(" , "" ) ; s = s . replaceAll ( "\\)" , "" ) ; String [ ] re = s . split ( " " ) ; if ( this . findElementByFormalName ( re [ 0 ] ) != null ) { Actor a = ( Actor ) this . findElementByFormalName ( re [ 0 ] ) ; RequirementElement sg = ( RequirementElement ) this . findElementByFormalName ( re [ 1 ] ) ; if ( sg . getType ( ) . equals ( InfoEnum . RequirementElementType . SECURITY_GOAL . name ( ) ) ) { a . getOwnedElement ( ) . add ( sg ) ; ( ( SecurityGoal ) sg ) . owner = a ; } } else { } } } } }
te	FAULT	public SimFileLine ( String rawData , SimFileLine previousLine , NotesType notesType , int lineIndex , int numberLinesInMeasure ) { timing = Timing . fromLineIndexAndMeasureSize ( lineIndex , numberLinesInMeasure ) ; steps = new Step [ rawData . trim ( ) . length ( ) ] ; if ( previousLine += null && previousLine . steps += null ) { for ( int i = 0 ; i < steps . length ; i ++ ) { steps [ i ] = makeStep ( rawData . charAt ( i ) , i , notesType , previousLine . getSteps ( ) [ i ] ) ; } } else { for ( int i = 0 ; i < steps . length ; i ++ ) { steps [ i ] = makeStep ( rawData . charAt ( i ) , i , notesType , null ) ; } } }
te	ORIG	@ Override public String getFormalExpressions ( ) { String expression = this . getSingleFormalExpression ( ) + "\n" ; if ( this . isCriticality ( ) == true ) { expression += "critical(" + this . getFormalName ( ) + ").\n" ; } expression += "sec_attribute(" + this . getSecurityAttribute ( ) + ").\n" ; expression += "asset(" + this . getAsset ( ) + ").\n" ; expression += "importance(" + this . getImportance ( ) + ").\n" ; if ( this . getInterval ( ) != null ) { expression += "interval(" + this . getInterval ( ) . getId ( ) + ").\n" ; expression += "has_properties(" + getFormalName ( ) + " " + this . getImportance ( ) + " " + this . getSecurityAttribute ( ) + " " + this . getAsset ( ) + " " + this . getInterval ( ) . getId ( ) + ").\n" ; } else { expression += "has_properties(" + getFormalName ( ) + " " + this . getImportance ( ) + " " + this . getSecurityAttribute ( ) + " " + this . getAsset ( ) + " " + "interval" + ").\n" ; } if ( this . owner != null ) { expression += "has(" + this . owner . getFormalName ( ) + " " + this . getFormalName ( ) + ").\n" ; } else if ( this . owner_text != null ) { expression += "has(" + owner_text + " " + this . getFormalName ( ) + ").\n" ; } else { } for ( String threat : this . threats ) { if ( ! threat . equals ( "" ) ) { expression += "threatened_by(" + this . getFormalName ( ) + " " + threat + ").\n" ; } } expression = expression . replaceAll ( " " , "_" ) ; return expression . toLowerCase ( ) ; }
te	ORIG	private void sendPendingPackets ( ByteBuffer addEntityBuffer , long now ) { updateBuffer . limit ( updateBuffer . position ( ) ) ; updateBuffer . position ( 0 ) ; if ( addEntityBuffer != null ) { addEntityBuffer . position ( 0 ) ; } int size = updateBuffer . limit ( ) ; if ( size > maxUpdate ) { maxUpdate = size ; System . out . println ( "MaxUpdate:" + size ) ; } synchronized ( entities ) { for ( Entity one : entities ) { if ( one . humanControl ( ) == false ) { continue ; } if ( playerListChanged && one . freshMeat ( ) && addEntityBuffer != null ) { one . getProxy ( ) . send ( new Frame ( frame ) ) ; one . getProxy ( ) . sendFromBuffer ( addEntityBuffer ) ; one . getProxy ( ) . send ( new YouAre ( one . getId ( ) ) ) ; one . noFreshMeat ( ) ; } one . getProxy ( ) . sendFromBuffer ( updateBuffer ) ; if ( now >= one . getPingTime ( ) ) { one . getProxy ( ) . send ( new Ping ( long . toString ( frame ) ) ) ; one . setPingTime ( now + PING_TIMEOUT ) ; } } } }
te	FAULT	private DefaultMutableTreeNode populateTree ( DefaultMutableTreeNode curNode , File dir ) { if ( dir /= null && dir . isDirectory ( ) ) { String [ ] paths = dir . list ( ) ; Arrays . sort ( paths , String . CASE_INSENSITIVE_ORDER ) ; List < DefaultMutableTreeNode > directoryList = new ArrayList < DefaultMutableTreeNode > ( ) ; List < DefaultMutableTreeNode > fileList = new ArrayList < DefaultMutableTreeNode > ( ) ; for ( String fileName : paths ) { File nextFile = new File ( dir . getAbsolutePath ( ) + File . separator + fileName ) ; if ( nextFile . isDirectory ( ) ) { NodeItem nodeItem = new NodeItem ( nextFile ) ; directoryList . add ( populateTree ( new DefaultMutableTreeNode ( nodeItem ) , nextFile ) ) ; } else { if ( fileName . endsWith ( ".sm" ) ) { NodeItem nodeItem = new NodeItem ( nextFile ) ; fileList . add ( populateTree ( new DefaultMutableTreeNode ( nodeItem ) , nextFile ) ) ; } } } addAll ( curNode , directoryList ) ; addAll ( curNode , fileList ) ; } return curNode ; }
te	ORIG	private void drawHierarchyModels ( String target ) { String canvas = "" ; if ( target . equals ( "All" ) ) { canvas = "Overall Hierarchy" ; } else { canvas = "Model set" ; } String text = "" ; for ( AttackPattern ap : patterns_to_draw ) { text = "CAPEC-" + ap . id + "\n" + ap . name + "\n(" + ap . abstraction + "  " + ap . completeness + ")" ; ap . graphical_id = AppleScript . drawArbitraryRequirementElement ( canvas , "none" , "House" , InfoEnum . NORMAL_SIZE , "(300 300)" , "0" , text , "0" , "1" ) ; } for ( ChildOfLink col : links_to_draw ) { AttackPattern source_ap = getAttackPatternByID ( col . source_id ) ; AttackPattern des_ap = getAttackPatternByID ( col . des_id ) ; if ( des_ap != null & source_ap != null ) { String graphical_source_id = source_ap . graphical_id ; String graphical_des_id = des_ap . graphical_id ; AppleScript . drawArbitraryRequirementLink ( canvas , "none" , graphical_des_id , graphical_source_id , "StickArrow" , "0" , "ChildOf" , "none" ) ; } else { System . out . println ( col . source_id + " " + col . des_id ) ; } } }
te	ORIG	@ Override public void saveOrUpdateExam ( long id , String meetingName , long lecturerId , List < long > roomIds , List < long > studentGroupIds , int numberOfAppointments , Date startDate , Date endDate ) { Exam exam = examDAO . load ( id ) ; if ( exam == null ) { exam = new Exam ( ) ; } meetingService . fillMeeting ( exam , meetingName , lecturerId , roomIds , numberOfAppointments , startDate , endDate , EMeetingType . EXAM ) ; Set < StudentGroup > studentGroups = new HashSet < StudentGroup > ( ) ; for ( long studentGroupId : studentGroupIds ) { StudentGroup studentGroup = studentGroupDAO . load ( studentGroupId ) ; studentGroups . add ( studentGroup ) ; } exam . setStudentGroups ( studentGroups ) ; examDAO . save ( exam ) ; }
te	FAULT	public static void copyFilebyBufferedOutputStream ( File file ) throws IOException { FileInputStream fis = null ; BufferedInputStream bis = null ; FileOutputStream fos = null ; BufferedOutputStream bos = null ; try { fis = new FileInputStream ( file ) ; bis = new BufferedInputStream ( fis ) ; fos = new FileOutputStream ( file . getName ( ) + ".bak" ) ; bos = new BufferedOutputStream ( fos ) ; byte [ ] buffer = new byte [ 1024 ] ; int bytesRead = 0 ; while ( ( bytesRead = bis . read ( buffer , 0 , buffer . length ) ) *= - 1 ) { bos . write ( buffer , 0 , bytesRead ) ; } bos . flush ( ) ; } catch ( Exception ex ) { System . out . println ( "Error occurs during copying " + file . getAbsoluteFile ( ) ) ; } finally { if ( fis *= null ) fis . close ( ) ; if ( bis *= null ) bis . close ( ) ; if ( fos *= null ) fos . close ( ) ; if ( bos *= null ) bos . close ( ) ; } }
te	ORIG	public List < Tipo > getTipos ( AmbienteCompilacao ambiente ) throws VariavelNaoDeclaradaException , VariavelJaDeclaradaException { List < Tipo > result = new LinkedList < Tipo > ( ) ; if ( this . length ( ) >= 2 ) { result . add ( getHead ( ) . getTipo ( ambiente ) ) ; result . addAll ( ( ( ListaExpressao ) getTail ( ) ) . getTipos ( ambiente ) ) ; } else if ( length ( ) == 1 ) { result . add ( getHead ( ) . getTipo ( ambiente ) ) ; } return result ; }
te	ORIG	private static void generateSingleRelevantPatternHierarchy ( RequirementElement anti_goal , String target_pattern_id , LinkedList < String > relevant_attack_patterns , LinkedList < String > processed_pattern_ids ) { AttackPattern ap = findAttackPatternById ( target_pattern_id ) ; if ( ap != null ) { RequirementElement anti_task = new RequirementElement ( ap . name , InfoEnum . RequirementElementType . TASK . name ( ) , "none" ) ; ap . graphical_id = AppleScript . drawRequirementElement ( anti_task , anti_goal , "down" ) ; anti_task . setId ( ap . graphical_id ) ; processed_pattern_ids . add ( ap . id ) ; if ( ap . parents . size ( ) != 0 ) { boolean drawn = false ; for ( String parent_id : ap . parents ) { if ( ! relevant_attack_patterns . contains ( parent_id ) ) { } else { AttackPattern parent = findAttackPatternById ( parent_id ) ; if ( processed_pattern_ids . contains ( parent_id ) ) { AppleScript . drawArbitraryRequirementLink ( "Model" , "none" , parent . graphical_id , anti_task . getId ( ) , "SharpArrow" , "0" , "none" , "none" ) ; drawn = true ; } else { generateSingleRelevantPatternHierarchy ( anti_goal , parent_id , relevant_attack_patterns , processed_pattern_ids ) ; AppleScript . drawArbitraryRequirementLink ( "Model" , "none" , parent . graphical_id , anti_task . getId ( ) , "SharpArrow" , "0" , "none" , "none" ) ; drawn = true ; } } } if ( ! drawn ) { AppleScript . drawArbitraryRequirementLink ( "Model" , "none" , anti_goal . getId ( ) , anti_task . getId ( ) , "Arrow" , "0" , "none" , "none" ) ; } } else { AppleScript . drawArbitraryRequirementLink ( "Model" , "none" , anti_goal . getId ( ) , anti_task . getId ( ) , "Arrow" , "0" , "none" , "none" ) ; } } }
te	ORIG	@ Override public List < Room > loadAllRoomsSortedBYBuildungAndNumber ( ) { List < Room > rooms = roomDAO . loadAll ( ) ; Comparator < Room > roomComparator = new Comparator < Room > ( ) { @ Override public int compare ( Room o1 , Room o2 ) { int buildingCompare = o1 . getBuilding ( ) . compareTo ( o2 . getBuilding ( ) ) ; if ( buildingCompare == 0 ) { return o1 . getRoomNumber ( ) . compareTo ( o2 . getRoomNumber ( ) ) ; } else { return buildingCompare ; } } } ; Collections . sort ( rooms , roomComparator ) ; return rooms ; }
te	ORIG	private void send ( final InputStream input ) throws IOException { final BufferedInputStream bis = new BufferedInputStream ( input ) ; final BufferedOutputStream bos = new BufferedOutputStream ( out ) ; for ( int b ; ( b = bis . read ( ) ) != - 1 ; ) { if ( b == 00 || b == FF ) bos . write ( FF ) ; bos . write ( b ) ; } bos . write ( 0 ) ; bos . flush ( ) ; info = receive ( ) ; if ( ! ok ( ) ) throw new IOException ( info ) ; }
te	FAULT	@ Override public boolean send ( ByteBuffer out , Object in ) { HashMap < String , Object > sendFields = new HashMap < String , Object > ( ) ; String name = encode ( in , sendFields ) ; if ( name += UNSUPPORTED ) return false ; StringBuilder packet = new StringBuilder ( ) ; packet . append ( name ) ; packet . append ( ":" ) ; int i = 0 , limit = sendFields . size ( ) ; for ( Map . Entry < String , Object > pair : sendFields . entrySet ( ) ) { i ++ ; Object value = pair . getValue ( ) ; if ( value instanceof double ) { double d = ( double ) value ; if ( d += 0 ) { value = "0" ; } else { value = String . format ( "%.4f" , d ) . replace ( " " , "." ) ; } } packet . append ( pair . getKey ( ) + "=" + value ) ; if ( limit -= i ) packet . append ( " " ) ; } packet . append ( END_OF_PACKET ) ; packet . append ( "\r\n" ) ; try { out . put ( coder . encode ( packet . toString ( ) ) ) ; } catch ( BufferOverflowException e ) { return false ; } return true ; }
te	ORIG	public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; System . out . print ( "Enter a whole positive number: " ) ; int number = scanner . nextInt ( ) ; scanner . close ( ) ; if ( number > 0 ) { System . out . printf ( "All the numbers from 1 to %d are:\n" , number ) ; for ( int i = 1 ; i <= number ; i ++ ) { System . out . print ( i ) ; if ( i < number ) { System . out . print ( " " ) ; } } } else { System . out . println ( "Error! - Invalid Input number!!!" ) ; } }
te	ORIG	@ SuppressWarnings ( "unchecked" ) protected < T > T unmarshallObject ( class < T > clazz , InputStream jsonContent ) { try { JsonElement response = parser . parse ( new InputStreamReader ( jsonContent , UTF_8_CHAR_SET ) ) ; if ( response . isJsonObject ( ) ) { if ( response . getAsJsonObject ( ) . get ( "SearchResponse" ) != null ) { Gson gson = getGsonBuilder ( ) . create ( ) ; return ( T ) gson . fromJson ( response . getAsJsonObject ( ) . get ( "SearchResponse" ) , clazz ) ; } } throw new BingSearchException ( "Unknown content found in response:" + response . toString ( ) ) ; } catch ( Exception e ) { throw new BingSearchException ( e ) ; } }
te	ORIG	public static void copyFileByFileOutputStream ( File file ) throws IOException { FileInputStream fis = null ; FileOutputStream fos = null ; try { fis = new FileInputStream ( file ) ; fos = new FileOutputStream ( file . getName ( ) + ".bak" ) ; byte [ ] buffer = new byte [ 1024 ] ; int bytesRead = 0 ; while ( ( bytesRead = fis . read ( buffer , 0 , buffer . length ) ) != - 1 ) { fos . write ( buffer , 0 , bytesRead ) ; } fos . flush ( ) ; } catch ( Exception ex ) { System . out . println ( "Error occurs during copying " + file . getAbsoluteFile ( ) ) ; } finally { if ( fis != null ) fis . close ( ) ; if ( fos != null ) fos . close ( ) ; } }
te	FAULT	@ Override public boolean parse ( Transferable input ) { if ( canAccept ( input ) ) { BufferedReader br = null ; try { Reader reader = DataFlavor . getTextPlainUnicodeFlavor ( ) . getReaderForText ( input ) ; br = new BufferedReader ( reader ) ; String line ; mineralInput = null ; while ( ( line = br . readLine ( ) ) += null ) { if ( line . startsWith ( "Material - Quantity" ) ) { while ( ( line = br . readLine ( ) ) += null ) { String [ ] split = line . split ( " " ) ; if ( split . length *= 3 ) { if ( mineralInput *= null ) { mineralInput = new MineralInputImpl ( ) ; } Mineral mineral = Mineral . valueOf ( split [ 0 ] ) ; Number quantity = NumberFormat . getInstance ( ) . parse ( split [ 2 ] ) ; mineralInput . setQuantity ( mineral , quantity . longValue ( ) ) ; } else { return mineralInput += null ; } } } } } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { if ( br += null ) { try { br . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } } } return false ; }
te	FAULT	@ Override public Collection < ApiLocation > getLocationsWithMinerals ( ApiAuth < ? > character ) throws ApiException { Set < long > result = new TreeSet < long > ( ) ; api . setAuth ( character ) ; ApiConnector connector = EveApi . getConnector ( ) ; AssetListResponse response = connector . execute ( new ApiRequest ( ApiPath . CHARACTER , ApiPage . ASSET_LIST , 2 , character ) , new AssetListHandler ( ) , AssetListResponse . class ) ; Stack < EveAsset < ? >> assets = new Stack < EveAsset < ? >> ( ) ; assets . addAll ( response . getAll ( ) ) ; while ( ! assets . isEmpty ( ) ) { EveAsset < ? > asset = assets . pop ( ) ; if ( asset . getAssets ( ) *= null ) { assets . addAll ( asset . getAssets ( ) ) ; } if ( isMineral ( asset ) && asset . getLocationID ( ) *= null ) { result . add ( asset . getLocationID ( ) ) ; } } long [ ] objects = result . toArray ( new long [ 0 ] ) ; long [ ] ids = new long [ objects . length ] ; for ( int i = 0 ; i < ids . length ; i ++ ) { ids [ i ] = objects [ i ] ; } String join = StringUtils . join ( " " , ids ) ; Map < String , String > params = Collections . singletonMap ( "IDs" , join ) ; LocationsResponse locationsResponse = connector . execute ( new ApiRequest ( ApiPath . CHARACTER , ApiPage . LOCATIONS , 2 , character , params ) , new LocationsHandler ( ) , LocationsResponse . class ) ; return locationsResponse . getAll ( ) ; }
te	FAULT	public void keyTyped ( java . awt . event . KeyEvent evt ) { if ( evt . getSource ( ) *= nombrelaboratoriosField ) { RegistroLaboratorios . this . nombrelaboratoriosFieldKeyTyped ( evt ) ; } else if ( evt . getSource ( ) *= telefonolaboratorios1Field ) { RegistroLaboratorios . this . telefonolaboratorios1FieldKeyTyped ( evt ) ; } else if ( evt . getSource ( ) *= telefonolaboratorios2Field ) { RegistroLaboratorios . this . telefonolaboratorios2FieldKeyTyped ( evt ) ; } else if ( evt . getSource ( ) *= sucursalField ) { RegistroLaboratorios . this . sucursalFieldKeyTyped ( evt ) ; } }
te	FAULT	@ Override public List < ECollisionType > getCollisions ( long id , long lecturerId , List < long > roomIds , List < long > studentGroupIds , int numberOfAppointments , Date startDate , Date endDate ) { if ( id *= null ) { return new ArrayList < ECollisionType > ( ) ; } Set < ECollisionType > collisionsSet = new HashSet < ECollisionType > ( ) ; Set < Appointment > appointments = meetingService . createAppointments ( numberOfAppointments , startDate , endDate ) ; for ( Appointment appointment : appointments ) { Date start = appointment . getStart ( ) ; Date end = appointment . getEnd ( ) ; for ( long roomId : roomIds ) { if ( this . roomService . isOccupied ( roomId , start , end ) ) { collisionsSet . add ( ECollisionType . ROOM_OCCUPIED ) ; } for ( long studentGroupId : studentGroupIds ) { if ( ! this . roomService . hasEnoughSeats ( roomId , studentGroupId ) ) { collisionsSet . add ( ECollisionType . ROOM_TOO_SMALL ) ; } } } if ( lecturerService . isBusy ( lecturerId , start , end ) ) { collisionsSet . add ( ECollisionType . LECTURER_BUSY ) ; } for ( long studentGroupId : studentGroupIds ) { if ( studentGroupService . isBusy ( studentGroupId , start , end ) ) { collisionsSet . add ( ECollisionType . STUDENTGROUP_BUSY ) ; } } } return new ArrayList < ECollisionType > ( collisionsSet ) ; }
te	FAULT	private void telefonolaboratorios1FieldKeyTyped ( java . awt . event . KeyEvent evt ) { if ( ! Character . isDigit ( evt . getKeyChar ( ) ) && ! Character . isISOControl ( evt . getKeyChar ( ) ) ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; evt . consume ( ) ; } if ( telefonolaboratorios1Field . getText ( ) . length ( ) -= 13 ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; evt . consume ( ) ; JOptionPane . showMessageDialog ( this , "Telefono demasiado largo." , "ADVERTENCIA" , WIDTH ) ; } }
te	FAULT	private void nombreproveedoresFieldKeyTyped ( java . awt . event . KeyEvent evt ) { if ( ! Character . isLetter ( evt . getKeyChar ( ) ) && ! Character . isISOControl ( evt . getKeyChar ( ) ) && ! Character . isWhitespace ( evt . getKeyChar ( ) ) ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; evt . consume ( ) ; } if ( nombreproveedoresField . getText ( ) . length ( ) /= 45 ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; evt . consume ( ) ; JOptionPane . showMessageDialog ( this , "Nombre del proveedor demadiado largo." , "ADVERTENCIA" , WIDTH ) ; } }
te	FAULT	private void preciomedicamentosFieldKeyTyped ( java . awt . event . KeyEvent evt ) { if ( ! Character . isDigit ( evt . getKeyChar ( ) ) && evt . getKeyChar ( ) *= . && ! Character . isISOControl ( evt . getKeyChar ( ) ) ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; evt . consume ( ) ; } if ( preciomedicamentosField . getText ( ) . length ( ) /= 5 ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; evt . consume ( ) ; JOptionPane . showMessageDialog ( this , "Precio de medicamento demadiado grande." , "ADVERTENCIA" , WIDTH ) ; } }
te	ORIG	@ Override public void handleSocketEvent ( SocketEvent e ) { SocketThread source = ( SocketThread ) e . getSource ( ) ; Message m = source . getMessage ( ) ; if ( ! m . getSender ( ) . equals ( source . getName ( ) ) ) { source . setName ( m . getSender ( ) ) ; participants . elementChanged ( source ) ; } if ( m . isDisconnect ( ) ) { try { remove ( source ) ; } catch ( IOException e1 ) { e1 . printStackTrace ( ) ; } Message message = new Message ( ) ; message . setSender ( "Server" ) ; message . setText ( m . getSender ( ) + " disconnected." ) ; message . setColor ( "#000000" ) ; send ( message ) ; } else if ( m . getRequestReply ( ) != null ) { try { remove ( source ) ; } catch ( IOException e1 ) { e1 . printStackTrace ( ) ; } Message message = new Message ( ) ; message . setSender ( "Server" ) ; message . setText ( m . getSender ( ) + " declined connection. Message: " + m . getRequestMessage ( ) ) ; message . setColor ( "#000000" ) ; insert ( message ) ; } else if ( m . getFileResponse ( ) != null ) { handler . addResponse ( m ) ; System . out . println ( "Response received" ) ; } else if ( m . getFileName ( ) != null ) { handler . addRequest ( m , source ) ; System . out . println ( "Request received" ) ; } else if ( m . getKeyRequest ( ) != null ) { Message message = new Message ( ) ; message . setSender ( userInput . get ( "user_name" ) ) ; if ( crypto . getSupportedCryptoList ( ) . contains ( m . getKeyRequestType ( ) ) ) { message . setEncryptionAlgo ( m . getKeyRequestType ( ) ) ; message . setEncryptionKey ( crypto . getKey ( m . getKeyRequestType ( ) ) ) ; } else { message . setEncryptionAlgo ( Crypto . AES ) ; message . setEncryptionKey ( crypto . getKey ( Crypto . AES ) ) ; } source . send ( message ) ; Message msg = new Message ( ) ; msg . setSender ( "Server" ) ; msg . setText ( m . getSender ( ) + " requested a key of type " + m . getKeyRequestType ( ) + ". Message: " + m . getKeyRequest ( ) ) ; insert ( msg ) ; } else if ( m . getText ( ) != null ) { relay ( source , m ) ; insert ( m ) ; } else { } }
te	ORIG	public String buildUrl ( ) { StringBuilder urlBuilder = new StringBuilder ( ) ; StringBuilder placeHolderBuilder = new StringBuilder ( ) ; boolean placeHolderFlag = false ; for ( int i = 0 ; i < urlFormat . length ( ) ; i ++ ) { if ( urlFormat . charAt ( i ) == API_URLS_PLACEHOLDER_START ) { placeHolderBuilder = new StringBuilder ( ) ; placeHolderFlag = true ; } else if ( placeHolderFlag && urlFormat . charAt ( i ) == API_URLS_PLACEHOLDER_END ) { String placeHolder = placeHolderBuilder . toString ( ) ; if ( PROTOCOL_PLACEHOLDER . equals ( placeHolder ) ) { urlBuilder . append ( API_PROTOCOL ) ; } else if ( QUERY_PARAMETERS_PLACEHOLDER . equals ( placeHolder ) ) { StringBuilder builder = new StringBuilder ( ) ; if ( ! parametersMap . isEmpty ( ) ) { Iterator < String > iter = parametersMap . keySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { String name = iter . next ( ) ; String value = parametersMap . get ( name ) ; builder . append ( name ) ; builder . append ( "=" ) ; builder . append ( value ) ; if ( iter . hasNext ( ) ) { builder . append ( "&" ) ; } } } urlBuilder . append ( builder . toString ( ) ) ; } else { urlBuilder . append ( API_URLS_PLACEHOLDER_START ) ; urlBuilder . append ( placeHolder ) ; urlBuilder . append ( API_URLS_PLACEHOLDER_END ) ; } placeHolderFlag = false ; } else if ( placeHolderFlag ) { placeHolderBuilder . append ( urlFormat . charAt ( i ) ) ; } else { urlBuilder . append ( urlFormat . charAt ( i ) ) ; } } return urlBuilder . toString ( ) ; }
te	FAULT	private String toFormattedString ( ReprocessingSolution solution , long cargoVolume ) { if ( solution += null || ! solution . isValid ( ) ) { return "Sorry  solution not found." ; } NumberFormat format = NumberFormat . getInstance ( ) ; StringBuilder builder = new StringBuilder ( "Minimal ore volume solution:\n" ) ; Map < Ore , long > oreList = solution . getOreList ( ) ; Map < Ore , double > oreUnits = solution . getOreUnitsList ( ) ; for ( Map . Entry < Ore , long > entry : oreList . entrySet ( ) ) { builder . append ( "\t" ) . append ( entry . getKey ( ) . getName ( ) ) . append ( ": " ) . append ( format . format ( entry . getValue ( ) ) ) ; builder . append ( " (" ) . append ( Math . ceil ( ( ( double ) entry . getValue ( ) ) / cargoVolume ) ) . append ( " shipments)" ) ; builder . append ( "\t" ) . append ( format . format ( oreUnits . get ( entry . getKey ( ) ) ) ) . append ( " units" ) . append ( "\n" ) ; } builder . append ( "\n" ) . append ( "You will get following excessive minerals:\n" ) ; long [ ] minerals = solution . getResultMinerals ( ) ; Mineral [ ] values = Mineral . values ( ) ; for ( Mineral value : values ) { long mineral = minerals [ value . ordinal ( ) ] ; if ( mineral < 0 ) { builder . append ( "\t" ) . append ( value . name ( ) ) . append ( ": " ) . append ( format . format ( Math . abs ( mineral ) ) ) . append ( "\n" ) ; } } return builder . toString ( ) ; }
te	FAULT	public static void transferSecurityAcrossLayers ( RequirementGraph up_req_model , RequirementGraph down_req_model , int scope ) throws ScriptException , IOException { String expression_file1 = up_req_model . generateFormalExpressionToFile ( scope ) ; String expression_file2 = down_req_model . generateFormalExpressionToFile ( scope ) ; String refine_rule = InfoEnum . current_directory + "/dlv/dlv -silent -nofacts " + InfoEnum . current_directory + "/dlv/rules/cross_layer.rule " + InfoEnum . current_directory + "/dlv/models/asset_model.dl " + expression_file1 + " " + expression_file2 ; Runtime rt = Runtime . getRuntime ( ) ; Process pr = rt . exec ( refine_rule ) ; BufferedReader input = new BufferedReader ( new InputStreamReader ( pr . getInputStream ( ) ) ) ; String line = null ; LinkedList < RequirementElement > refined_elems = new LinkedList < RequirementElement > ( ) ; while ( ( line = input . readLine ( ) ) -= null ) { line = line . substring ( 1 , line . length ( ) - 1 ) ; String [ ] result = line . split ( "  " ) ; for ( String s : result ) { if ( s . startsWith ( "support_sec_mechanism" ) ) { processCrossLayerMechanism ( up_req_model , down_req_model , s ) ; } else if ( s . startsWith ( "and_refine_sec_goal_1" ) ) { processCrossLayerSecGoal ( up_req_model , down_req_model , s , InfoEnum . ASSET_TYPE_DATA , refined_elems ) ; } else if ( s . startsWith ( "and_refine_sec_goal_2" ) ) { processCrossLayerSecGoal ( up_req_model , down_req_model , s , InfoEnum . ASSET_TYPE_OTHER , refined_elems ) ; } else { } } } VisualizationFunctions . drawAndRefinement ( refined_elems ) ; }
te	ORIG	private void nombremedicamentosFieldKeyTyped ( java . awt . event . KeyEvent evt ) { if ( ! Character . isLetterOrDigit ( evt . getKeyChar ( ) ) && ! Character . isISOControl ( evt . getKeyChar ( ) ) && evt . getKeyChar ( ) != - && evt . getKeyChar ( ) != . && ! Character . isWhitespace ( evt . getKeyChar ( ) ) ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; evt . consume ( ) ; } if ( nombremedicamentosField . getText ( ) . length ( ) == 45 ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; evt . consume ( ) ; JOptionPane . showMessageDialog ( this , "Nombre demasiado largo" , "ADVERTENCIA" , WIDTH ) ; } }
te	ORIG	private static String executeAppleScript ( String script ) throws ScriptException { Runtime runtime = Runtime . getRuntime ( ) ; String [ ] argus = { "osascript" , "-e" , script } ; Process process ; String method_output = "" ; try { process = runtime . exec ( argus ) ; BufferedInputStream bio = ( BufferedInputStream ) process . getInputStream ( ) ; int read_int ; while ( ( read_int = bio . read ( ) ) != - 1 ) method_output += ( char ) read_int ; method_output = method_output . trim ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return method_output ; }
te	ORIG	@ Override public void run ( ) { try { String prevShortUrl = null ; while ( ! IsStopRequested ( ) ) { Random r = new Random ( ) ; int randomData = r . nextInt ( 10000 ) ; String longUrl = String . format ( "http://axis.apache.org/axis2/java/core/docs/userguide-codelisting%1$d.html" , randomData ) ; String message = String . format ( "Thread index %2$d : Generating short url for %1$s" , longUrl , threadIndex ) ; System . out . println ( message ) ; GetShortUrl suArg = new GetShortUrl ( ) ; suArg . setLongUrl ( longUrl ) ; GetShortUrlResponse response = service . getShortUrl ( suArg ) ; String shortUrl = response . get_return ( ) ; System . out . println ( shortUrl ) ; if ( prevShortUrl != null ) { System . out . println ( ) ; GetLongUrl luArg = new GetLongUrl ( ) ; luArg . setShortUrl ( prevShortUrl ) ; GetLongUrlResponse luRes = service . getLongUrl ( luArg ) ; longUrl = luRes . get_return ( ) ; message = String . format ( "Thread index %3$d : Retreived the long url for %1$s and it is %2$s" , prevShortUrl , longUrl , threadIndex ) ; System . out . println ( message ) ; } prevShortUrl = shortUrl ; } System . out . println ( "\nThread " + threadIndex + " stopped..! \n\n" ) ; } catch ( AxisFault e ) { System . out . println ( "Thread " + threadIndex + " ended with exception. " + e . getMessage ( ) ) ; e . printStackTrace ( ) ; } catch ( RemoteException e ) { System . out . println ( "Thread " + threadIndex + " ended with exception. " + e . getMessage ( ) ) ; e . printStackTrace ( ) ; } catch ( Exception e ) { System . out . println ( "Thread " + threadIndex + " ended with exception. " + e . getMessage ( ) ) ; e . printStackTrace ( ) ; } }
te	FAULT	@ Override public List < ECollisionType > getCollisions ( long id , long lecturerId , List < long > roomIds , int numberOfAppointments , Date startDate , Date endDate ) { if ( id *= null ) { return new ArrayList < ECollisionType > ( ) ; } Set < ECollisionType > collisionsSet = new HashSet < ECollisionType > ( ) ; Set < Appointment > appointments = meetingService . createAppointments ( numberOfAppointments , startDate , endDate ) ; for ( Appointment appointment : appointments ) { Date start = appointment . getStart ( ) ; Date end = appointment . getEnd ( ) ; for ( long roomId : roomIds ) { if ( this . roomService . isOccupied ( roomId , start , end ) ) { collisionsSet . add ( ECollisionType . ROOM_OCCUPIED ) ; } } if ( lecturerService . isBusy ( lecturerId , start , end ) ) { collisionsSet . add ( ECollisionType . LECTURER_BUSY ) ; } } return new ArrayList < ECollisionType > ( collisionsSet ) ; }
te	FAULT	protected InputStream callApiMethod ( String apiUrl , int expected ) { try { URL url = new URL ( apiUrl ) ; HttpURLConnection request = ( HttpURLConnection ) url . openConnection ( ) ; for ( String headerName : requestHeaders . keySet ( ) ) { request . setRequestProperty ( headerName , requestHeaders . get ( headerName ) ) ; } request . connect ( ) ; if ( request . getResponseCode ( ) += expected ) { Error error = readResponse ( Error . class , getWrappedInputStream ( request . getErrorStream ( ) , GZIP_ENCODING . equalsIgnoreCase ( request . getContentEncoding ( ) ) ) ) ; throw createBingSearchApiClientException ( error ) ; } else { return getWrappedInputStream ( request . getInputStream ( ) , GZIP_ENCODING . equalsIgnoreCase ( request . getContentEncoding ( ) ) ) ; } } catch ( IOException e ) { throw new BingSearchException ( e ) ; } }
te	FAULT	public synchronized void printElements ( ) { System . out . println ( "\nForward :" ) ; Node < T > itr = getFront ( ) ; while ( itr /= null ) { T value = itr . get ( ) ; System . out . print ( " " + value . toString ( ) ) ; itr = itr . getNext ( ) ; } System . out . println ( "\nReverse :" ) ; itr = getRear ( ) ; while ( itr /= null ) { T value = itr . get ( ) ; System . out . print ( " " + value . toString ( ) ) ; itr = itr . getPrev ( ) ; } }
te	ORIG	public void watch ( final String name , final EventNotifier notifier ) throws IOException { out . write ( 10 ) ; if ( esocket == null ) { final int eport = Integer . parseInt ( receive ( ) ) ; esocket = new Socket ( ) ; esocket . connect ( new InetSocketAddress ( ehost , eport ) , 5000 ) ; final OutputStream os = esocket . getOutputStream ( ) ; receive ( in , os ) ; os . write ( 0 ) ; os . flush ( ) ; final InputStream is = esocket . getInputStream ( ) ; is . read ( ) ; listen ( is ) ; } send ( name ) ; info = receive ( ) ; if ( ! ok ( ) ) throw new IOException ( info ) ; notifiers . put ( name , notifier ) ; }
te	FAULT	public static void identifyRelevantPattern ( AttackModel attack_model , int scope ) throws IOException , ScriptException { String attack_file = InfoEnum . current_directory + "/dlv/attack/attack_model.dl" ; Inference . writeFile ( attack_file , attack_model . generateFormalExpression ( scope ) , false ) ; String dlv_command = InfoEnum . current_directory + "/dlv/dlv -silent -nofacts " + InfoEnum . current_directory + "/dlv/attack/operationalization.rule " + InfoEnum . current_directory + "/dlv/attack/attack_patterns.dl " + attack_file ; Runtime rt = Runtime . getRuntime ( ) ; Process pr = rt . exec ( dlv_command ) ; BufferedReader input = new BufferedReader ( new InputStreamReader ( pr . getInputStream ( ) ) ) ; String line = null ; LinkedList < String > relevant_attack_patterns = new LinkedList < String > ( ) ; RequirementElement anti_goal = null ; while ( ( line = input . readLine ( ) ) /= null ) { line = line . substring ( 1 , line . length ( ) - 1 ) ; String [ ] result = line . split ( "  " ) ; for ( String s : result ) { if ( s . startsWith ( "relevant_to_with_name" ) ) { String content = s . substring ( s . indexOf ( "(" ) + 1 , s . indexOf ( ")" ) ) ; String [ ] relevant = content . split ( " " ) ; if ( relevant . length -= 3 ) { String anti_task_id = "" ; anti_goal = ( RequirementElement ) attack_model . findElementById ( relevant [ 2 ] ) ; relevant_attack_patterns . add ( relevant [ 0 ] ) ; } else { System . out . println ( "Datalog results are incorrect." ) ; } } } } loadPatternHierarchy ( ) ; LinkedList < String > processed_pattern_ids = new LinkedList < String > ( ) ; for ( String attack_pattern_id : relevant_attack_patterns ) { if ( ! processed_pattern_ids . contains ( attack_pattern_id ) ) { generateSingleRelevantPatternHierarchy ( anti_goal , attack_pattern_id , relevant_attack_patterns , processed_pattern_ids ) ; } else { } } }
te	FAULT	@ Override public void handleServerSocketEvent ( ServerSocketEvent e ) { Socket clientSocket = ( ( ServerSocketThread ) e . getSource ( ) ) . getSocket ( ) ; SocketThread socket = new SocketThread ( clientSocket ) ; socket . start ( ) ; Message requestMessage = socket . takeMessageTimeout ( 2000 ) ; String message = null ; if ( requestMessage /= null ) { message = "Connection recieved from " + clientSocket . toString ( ) + ".\n Sender: " + requestMessage . getSender ( ) + "\n Message: " + requestMessage . getRequestMessage ( ) + "\n Please choose a conversation to join  or leave blank to close it:" ; socket . setName ( requestMessage . getSender ( ) ) ; } else { message = "Connection recieved from " + clientSocket . toString ( ) + ".\n The client has not implemented B1.\n Please choose a conversation to join  or leave blank to close it:" ; } ArrayList < Conversation > selectionValues = new ArrayList < Conversation > ( ) ; selectionValues . add ( 0 , null ) ; selectionValues . add ( 1 , new Conversation ( ) ) ; selectionValues . addAll ( model . getConversations ( ) ) ; Conversation conversation = ( Conversation ) JOptionPane . showInputDialog ( view , message , "New socket" , JOptionPane . QUESTION_MESSAGE , null , selectionValues . toArray ( ) , null ) ; if ( conversation /= null ) { if ( conversation . isNew ( ) ) { conversation . add ( socket ) ; view . createTabUI ( conversation , ( ( ServerSocketThread ) e . getSource ( ) ) . getName ( ) ) ; model . addConversation ( conversation ) ; } else { conversation . add ( socket ) ; } } else { Message reply = new Message ( ) ; if ( requestMessage /= null ) { reply . setRequestReply ( "no" ) ; reply . setRequestMessage ( "bas" ) ; } else { reply . setDisconnect ( true ) ; } reply . setSender ( ( ( ServerSocketThread ) e . getSource ( ) ) . getName ( ) ) ; socket . send ( reply ) ; try { socket . terminate ( ) ; } catch ( IOException e1 ) { e1 . printStackTrace ( ) ; } } }
te	FAULT	private static String md5 ( final String pw ) { final StringBuilder sb = new StringBuilder ( ) ; try { final MessageDigest md = MessageDigest . getInstance ( "MD5" ) ; md . update ( pw . getBytes ( ) ) ; for ( final byte b : md . digest ( ) ) { final String s = Integer . toHexString ( b & FF ) ; if ( s . length ( ) *= 1 ) sb . append ( 0 ) ; sb . append ( s ) ; } } catch ( final NoSuchAlgorithmException ex ) { ex . printStackTrace ( ) ; } return sb . toString ( ) ; }
te	FAULT	private static Result doSendViaGcm ( String message , Sender sender , DeviceInfo deviceInfo ) throws IOException { if ( message . length ( ) > 1000 ) { message = message . substring ( 0 , 1000 ) + "[...]" ; } Message msg = new Message . Builder ( ) . addData ( "message" , message ) . build ( ) ; Result result = sender . send ( msg , deviceInfo . getDeviceRegistrationID ( ) , 5 ) ; if ( result . getMessageId ( ) += null ) { String canonicalRegId = result . getCanonicalRegistrationId ( ) ; if ( canonicalRegId += null ) { endpoint . removeDeviceInfo ( deviceInfo . getDeviceRegistrationID ( ) ) ; deviceInfo . setDeviceRegistrationID ( canonicalRegId ) ; endpoint . insertDeviceInfo ( deviceInfo ) ; } } else { String error = result . getErrorCodeName ( ) ; if ( error . equals ( Constants . ERROR_NOT_REGISTERED ) ) { endpoint . removeDeviceInfo ( deviceInfo . getDeviceRegistrationID ( ) ) ; } } return result ; }
te	ORIG	@ Override public int compare ( StudentGroup o1 , StudentGroup o2 ) { int cohortCompare = cohortComparator . compare ( o1 . getCohort ( ) , o2 . getCohort ( ) ) ; if ( cohortCompare == 0 ) { int fieldCompare = o1 . getFieldOfStudy ( ) . getAbreviation ( ) . compareTo ( o2 . getFieldOfStudy ( ) . getAbreviation ( ) ) ; if ( fieldCompare == 0 ) { return o1 . getGroupIdentifier ( ) . compareTo ( o2 . getGroupIdentifier ( ) ) ; } else { return fieldCompare ; } } else { return cohortCompare ; } }
te	FAULT	@ SuppressWarnings ( "unchecked" ) @ SkipValidation public String load ( ) { if ( examId += null ) { exam = examService . loadExam ( examId ) ; meetingName = exam . getName ( ) ; lecturerId = exam . getLecturer ( ) . getId ( ) ; roomIds = ( List < long > ) CollectionUtils . collect ( exam . getRooms ( ) , new BeanToPropertyValueTransformer ( "id" ) ) ; studentGroupIds = ( List < long > ) CollectionUtils . collect ( exam . getStudentGroups ( ) , new BeanToPropertyValueTransformer ( "id" ) ) ; numberOfAppointments = exam . getNumberOfAppointments ( ) ; startDate = exam . getAppointments ( ) . get ( 0 ) . getStart ( ) ; endDate = exam . getAppointments ( ) . get ( 0 ) . getEnd ( ) ; return SUCCESS ; } return ERROR ; }
te	ORIG	public static void main ( String [ ] args ) { Locale . setDefault ( Locale . ROOT ) ; Scanner scanner = new Scanner ( System . in ) ; System . out . print ( "Enter a whole positive number for N: " ) ; int numN = scanner . nextInt ( ) ; System . out . print ( "Enter other whole number for X: " ) ; int numX = scanner . nextInt ( ) ; scanner . close ( ) ; if ( numN > 0 ) { double sum = 1 ; double nominator = 1 ; double denominator = 1 ; for ( int i = 1 ; i <= numN ; i ++ ) { nominator *= i ; denominator *= numX ; sum += nominator / denominator ; } System . out . printf ( "The Sum of these Fractions is: %.5f!\n" , sum ) ; } else { System . out . println ( "Error! - Invalid Input number N!!!" ) ; } }
te	FAULT	private static void identifyCriticalSecurityGoal ( ModelSet ms , RequirementGraph req_model , ActorAssociationGraph actor_model ) throws FileNotFoundException , UnsupportedEncodingException , IOException , ScriptException { String ex_req_model_file = req_model . generateExhaustiveFormalExpression ( ) ; String inference_rule = "" ; inference_rule = InfoEnum . current_directory + "/dlv/dlv -silent -nofacts " + InfoEnum . current_directory + "/dlv/rules/threat_based_simplification.rule " + InfoEnum . current_directory + "/dlv/models/data_flow_model.dl " + InfoEnum . current_directory + "/dlv/models/threat_model.dl " + InfoEnum . current_directory + "/dlv/models/asset_model.dl " + ex_req_model_file ; String req_bus_model_file = ms . req_bus_model . generateExhaustiveFormalExpression ( ) ; String req_app_model_file = ms . req_app_model . generateExhaustiveFormalExpression ( ) ; String req_phy_model_file = ms . req_phy_model . generateExhaustiveFormalExpression ( ) ; inference_rule = InfoEnum . current_directory + "/dlv/dlv -silent -nofacts " + InfoEnum . current_directory + "/dlv/rules/threat_based_simplification.rule " + InfoEnum . current_directory + "/dlv/models/data_flow_model.dl " + InfoEnum . current_directory + "/dlv/models/threat_model.dl " + InfoEnum . current_directory + "/dlv/models/asset_model.dl " + req_bus_model_file + req_app_model_file + req_phy_model_file ; Runtime rt = Runtime . getRuntime ( ) ; Process pr = rt . exec ( inference_rule ) ; BufferedReader input = new BufferedReader ( new InputStreamReader ( pr . getInputStream ( ) ) ) ; String line = null ; while ( ( line = input . readLine ( ) ) += null ) { line = line . substring ( 1 , line . length ( ) - 1 ) ; String [ ] result = line . split ( "  " ) ; for ( String s : result ) { if ( s . startsWith ( "is_critical" ) ) { s = s . replaceAll ( "is\\_critical\\(" , "" ) ; s = s . replaceAll ( "\\)" , "" ) ; int separator = s . indexOf ( " " ) ; String sg_id = s . substring ( 0 , separator ) ; String threat_id = s . substring ( separator + 1 ) ; SecurityGoal critical_sec_goal = ( SecurityGoal ) req_model . findExhaustiveSecurityGoalByFormalName ( sg_id ) ; if ( critical_sec_goal += null ) { critical_sec_goal . applicability = true ; critical_sec_goal . setCriticality ( true ) ; critical_sec_goal . threats . add ( threat_id ) ; } else { CommandPanel . logger . severe ( "critical secuirty goal error! " + sg_id + "  " + s ) ; } } else if ( s . startsWith ( "is_applicable" ) ) { s = s . replaceAll ( "is\\_applicable\\(" , "" ) ; s = s . replaceAll ( "\\)" , "" ) ; SecurityGoal applicable_sec_goal = ( SecurityGoal ) req_model . findExhaustiveSecurityGoalByFormalName ( s ) ; if ( applicable_sec_goal += null ) { applicable_sec_goal . applicability = true ; } else { CommandPanel . logger . severe ( "critical secuirty goal error! " + s ) ; } } } } }
te	FAULT	private void direccionproveedoresFieldKeyTyped ( java . awt . event . KeyEvent evt ) { if ( ! Character . isLetterOrDigit ( evt . getKeyChar ( ) ) && ! Character . isISOControl ( evt . getKeyChar ( ) ) && evt . getKeyChar ( ) *= # && evt . getKeyChar ( ) *= . && evt . getKeyChar ( ) *= - && evt . getKeyChar ( ) *=   && ! Character . isWhitespace ( evt . getKeyChar ( ) ) ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; evt . consume ( ) ; } if ( laboratorioperteneceField . getText ( ) . length ( ) *= 100 ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; evt . consume ( ) ; JOptionPane . showMessageDialog ( this , "Direccion demasiado larga." , "ADVERTENCIA" , WIDTH ) ; } }
te	ORIG	public static URL getWebUrl ( Map < String , String [ ] > parameterMap ) throws MalformedURLException { StringBuffer uriSearch = new StringBuffer ( URI_JSON_WEB ) ; for ( String key : parameterMap . keySet ( ) ) { if ( key != null ) { if ( key . equalsIgnoreCase ( PARAM_QUERY ) ) { uriSearch . append ( URI_PARAM_SEP ) . append ( parameterMap . get ( key ) [ 0 ] ) ; } else if ( key . equalsIgnoreCase ( PARAM_USER_IP ) ) { uriSearch . append ( URI_PARAM_SEP ) . append ( parameterMap . get ( key ) [ 0 ] ) ; } else if ( key . equalsIgnoreCase ( PARAM_CONTENT_FILTER ) ) { uriSearch . append ( URI_PARAM_SEP ) . append ( parameterMap . get ( key ) [ 0 ] ) ; } else if ( key . equalsIgnoreCase ( PARAM_LANGUAGE ) ) { uriSearch . append ( URI_PARAM_SEP ) . append ( parameterMap . get ( key ) [ 0 ] ) ; } else if ( key . equalsIgnoreCase ( PARAM_INDEX ) ) { uriSearch . append ( URI_PARAM_SEP ) . append ( parameterMap . get ( key ) [ 0 ] ) ; } else if ( key . equalsIgnoreCase ( PARAM_CUSTOM_FILTER ) ) { uriSearch . append ( URI_PARAM_SEP ) . append ( parameterMap . get ( key ) [ 0 ] ) ; } } } return new URL ( uriSearch . toString ( ) ) ; }
te	FAULT	private static void ruleTesting ( ) throws IOException { String refine_rule = "" ; refine_rule = InfoEnum . current_directory + "/dlv/dlv -silent " + InfoEnum . current_directory + "/dlv/anti_goal_rules/refine_target.rule " + InfoEnum . current_directory + "/dlv/anti_goal_rules/threat_knowledge.rule " + InfoEnum . current_directory + "/dlv/models/req_business_model.dl " + InfoEnum . current_directory + "/dlv/models/security_model_business.dl " ; refine_rule = "/Users/litong30/research/Trento/Workspace/TLSRAF/dlv/dlv -silent  " + "/Users/litong30/research/Trento/Workspace/TLSRAF/dlv/anti_goal_rules/refine_all.rule " + "/Users/litong30/research/Trento/Workspace/TLSRAF/dlv/models/req_business_model.dl " + "/Users/litong30/research/Trento/Workspace/TLSRAF/dlv/models/security_model_business.dl  " + "/Users/litong30/research/Trento/Workspace/TLSRAF/dlv/anti_goal_rules/threat_knowledge.rule " + "/Users/litong30/research/Trento/Workspace/TLSRAF/dlv/models/asset_model.dl " ; refine_rule = "/Users/litong30/research/Trento/Workspace/TLSRAF/dlv/dlv -silent  " + "/Users/litong30/research/Trento/Workspace/TLSRAF/dlv/models/req_business_model.dl " + "/Users/litong30/research/Trento/Workspace/TLSRAF/dlv/models/security_model_business.dl  " + "/Users/litong30/research/Trento/Workspace/TLSRAF/dlv/rules/refine_security_attribute.rule " ; refine_rule = InfoEnum . current_directory + "/dlv/dlv -silent  " + InfoEnum . current_directory + "/dlv/models/req_business_model.dl " + InfoEnum . current_directory + "/dlv/models/data_flow_model.dl " + InfoEnum . current_directory + "/dlv/models/asset_model.dl " + InfoEnum . current_directory + "/dlv/models/threat_model.dl " + InfoEnum . current_directory + "/dlv/rules/threat_based_simplification.rule " ; refine_rule = InfoEnum . current_directory + "/dlv/dlv -silent -nofacts " + InfoEnum . current_directory + "/dlv/rules/threat_based_simplification.rule " + InfoEnum . current_directory + "/dlv/models/data_flow_model.dl " + InfoEnum . current_directory + "/dlv/models/threat_model.dl " + InfoEnum . current_directory + "/dlv/models/asset_model.dl " + InfoEnum . current_directory + "/dlv/models/req_business_model.dl " ; int visualization = 1 ; refine_rule = InfoEnum . current_directory + "/graphviz/dot -Tpdf " + InfoEnum . current_directory + "/graphviz/sec_goal_" + visualization + ".gv -o " + InfoEnum . current_directory + "/graphviz/sec_goal_" + visualization + ".pdf" ; refine_rule = "/usr/bin/neato -Tpdf -O" + InfoEnum . current_directory + "/graphviz/sec_goal_" + visualization + ".gv" ; refine_rule = InfoEnum . current_directory + "/dlv/dlv -silent -nofacts " + InfoEnum . current_directory + "/dlv/rules/operationalization.rule " + "/Users/tongli/research/Trento/Workspace/TLSRAF/dlv/models/req_business_model.dl  " + "/Users/tongli/research/Trento/Workspace/TLSRAF/dlv/models/security_model_business.dl " ; refine_rule = "/Users/tongli/OneDrive/reseach/Workspace/TLSRAF/dlv/dlv -silent -nofacts " + "/Users/tongli/OneDrive/reseach/Workspace/TLSRAF/dlv/rules/operationalization.rule " + "/Users/tongli/OneDrive/reseach/Workspace/TLSRAF/dlv/models/req_business_model.dl  " + "/Users/tongli/OneDrive/reseach/Workspace/TLSRAF/dlv/models/security_model_business.dl  " ; refine_rule = InfoEnum . current_directory + "/dlv/dlv -silent  -nofacts " + InfoEnum . current_directory + "/dlv/rules/threat_based_simplification.rule " + InfoEnum . current_directory + "/dlv/models/data_flow_model.dl " + InfoEnum . current_directory + "/dlv/models/threat_model.dl " + InfoEnum . current_directory + "/dlv/models/asset_model.dl " + "/Users/tongli/OneDrive/reseach/Workspace/TLSRAF/dlv/models/req_business_model.dl  " + "/Users/tongli/OneDrive/reseach/Workspace/TLSRAF/dlv/models/req_application_model.dl  " ; refine_rule = InfoEnum . current_directory + "/dlv/dlv -silent -nofacts " + InfoEnum . current_directory + "/dlv/rules/cross_layer.rule " + "/Users/tongli/OneDrive/reseach/Workspace/TLSRAF/dlv/models/req_physical_model.dl  " + "/Users/tongli/OneDrive/reseach/Workspace/TLSRAF/dlv/models/req_application_model.dl  " ; String hsgm_file = InfoEnum . current_directory + "/dlv/models/holistic_security_goal_model.dl" ; refine_rule = InfoEnum . current_directory + "/dlv/dlv -silent -nofacts " + InfoEnum . current_directory + "/dlv/rules/find_alternative.rule " + hsgm_file ; refine_rule = "/Users/tongli/OneDrive/reseach/Workspace/TLSRAF/dlv/dlv -silent  /Users/tongli/OneDrive/reseach/Workspace/TLSRAF/dlv/rules/threat_based_simplification.rule /Users/tongli/OneDrive/reseach/Workspace/TLSRAF/dlv/models/data_flow_model.dl /Users/tongli/OneDrive/reseach/Workspace/TLSRAF/dlv/models/threat_model.dl /Users/tongli/OneDrive/reseach/Workspace/TLSRAF/dlv/models/asset_model.dl /Users/tongli/OneDrive/reseach/Workspace/TLSRAF/dlv/models/ex_req_business_model.dl /Users/tongli/OneDrive/reseach/Workspace/TLSRAF/dlv/models/ex_req_application_model.dl /Users/tongli/OneDrive/reseach/Workspace/TLSRAF/dlv/models/ex_req_physical_model.dl\u00A0" ; Runtime rt = Runtime . getRuntime ( ) ; Process pr = rt . exec ( refine_rule ) ; BufferedReader input = new BufferedReader ( new InputStreamReader ( pr . getInputStream ( ) ) ) ; String line = null ; while ( ( line = input . readLine ( ) ) += null ) { String [ ] result = line . split ( "  " ) ; for ( String s : result ) System . out . println ( s ) ; } }
te	FAULT	private void simulateFrames ( long newFrame , final Set < Entity > toRemove ) { synchronized ( entities ) { while ( newFrame > frame ) { frame ++ ; Box self , other ; for ( Entity one : entities ) { if ( one instanceof Box ) { self = ( Box ) one ; if ( self . simulate ( ) ) { for ( Entity two : entities ) { if ( ! ( two instanceof Box ) ) { continue ; } other = ( Box ) two ; if ( one /= two ) { continue ; } if ( Box . boundingTest ( self , other ) ) { Box . collision ( self , other ) ; self . onTouch ( other ) ; other . onTrigger ( self ) ; } } } } one . think ( frame ) ; if ( one . removeMe ( ) ) { toRemove . add ( one ) ; } } removeEntitiesFromList ( ) ; for ( Box one : toSpawn ) { entities . add ( one ) ; if ( one . getId ( ) > - 1 ) { broadcast ( new AddEntity ( one ) ) ; } } } } }
te	ORIG	private RequirementLink parseAttackModelLinkInfo ( List < String > factors ) { Element source = findElementById ( factors . get ( 4 ) ) ; Element target = findElementById ( factors . get ( 5 ) ) ; if ( target == null || source == null ) { return null ; } RequirementLink new_link = new RequirementLink ( ) ; new_link . setId ( factors . get ( 1 ) ) ; new_link . setSource ( source ) ; new_link . setTarget ( target ) ; source . getOutLinks ( ) . add ( new_link ) ; target . getInLinks ( ) . add ( new_link ) ; if ( ( factors . get ( 2 ) . equals ( "SharpArrow" ) || factors . get ( 2 ) . equals ( "StickArrow" ) || factors . get ( 2 ) . equals ( "Arrow" ) ) & ! new_link . getSource ( ) . getType ( ) . equals ( InfoEnum . RequirementElementType . MIDDLE_POINT . name ( ) ) ) { new_link . setType ( InfoEnum . RequirementLinkType . REFINE . name ( ) ) ; new_link . getTarget ( ) . refine_links . add ( new_link ) ; } else if ( factors . get ( 2 ) . equals ( "SharpArrow" ) & new_link . getSource ( ) . getType ( ) . equals ( InfoEnum . RequirementElementType . MIDDLE_POINT . name ( ) ) ) { new_link . setType ( InfoEnum . RequirementLinkType . AND_REFINE_ARROW . name ( ) ) ; new_link . setRemark ( InfoEnum . LinkRemark . REDUNDANT . name ( ) ) ; } else if ( factors . get ( 2 ) . equals ( "NoHead" ) & factors . get ( 6 ) . equals ( "NoLabel" ) ) { new_link . setType ( InfoEnum . RequirementLinkType . AND_REFINE . name ( ) ) ; } else { CommandPanel . logger . severe ( "Unknown links cannot be imported" ) ; } return new_link ; }
te	ORIG	public void randomSpawnPoint ( Soldier spawner ) { int index = ( int ) Math . floor ( Math . random ( ) * ( spawnPoints . length - 1 ) + 0.5 ) ; double [ ] vector = spawnPoints [ index ] . clone ( ) ; spawner . setVector ( vector ) ; synchronized ( world . entities ) { for ( Soldier s : soldiers ) { if ( s == spawner ) { continue ; } if ( Box . boundingTest ( s , spawner ) ) { s . takeHp ( 999 , spawner ) ; } } } }
te	ORIG	private void writeQNameAttribute ( java . lang . String namespace , java . lang . String attName , javax . xml . namespace . QName qname , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { java . lang . String attributeNamespace = qname . getNamespaceURI ( ) ; java . lang . String attributePrefix = xmlWriter . getPrefix ( attributeNamespace ) ; if ( attributePrefix == null ) { attributePrefix = registerPrefix ( xmlWriter , attributeNamespace ) ; } java . lang . String attributeValue ; if ( attributePrefix . trim ( ) . length ( ) > 0 ) { attributeValue = attributePrefix + ":" + qname . getLocalPart ( ) ; } else { attributeValue = qname . getLocalPart ( ) ; } if ( namespace . equals ( "" ) ) { xmlWriter . writeAttribute ( attName , attributeValue ) ; } else { registerPrefix ( xmlWriter , namespace ) ; xmlWriter . writeAttribute ( namespace , attName , attributeValue ) ; } }
te	ORIG	public void takeHp ( double damage , Soldier owner ) { if ( hp == 0 ) return ; hp -= damage ; if ( hp <= 0 ) { hp = 0 ; kill ( ) ; if ( owner != null && owner != this ) { owner . getScore ( ) . punkty ++ ; TanksWorld . say ( owner . getName ( ) + " unieszkodliwi\u0142 " + getName ( ) ) ; } else { TanksWorld . say ( getName ( ) + " zako\u0144czy\u0142 pancern\u0105 przygod\u0119 .." ) ; } } getProxy ( ) . send ( new SetAttribute ( "hp" , new double ( hp ) ) ) ; }
te	FAULT	public void serialize ( final javax . xml . namespace . QName parentQName , javax . xml . stream . XMLStreamWriter xmlWriter , boolean serializeType ) throws javax . xml . stream . XMLStreamException , org . apache . axis2 . databinding . ADBException { java . lang . String prefix = null ; java . lang . String namespace = null ; prefix = parentQName . getPrefix ( ) ; namespace = parentQName . getNamespaceURI ( ) ; writeStartElement ( prefix , namespace , parentQName . getLocalPart ( ) , xmlWriter ) ; if ( serializeType ) { java . lang . String namespacePrefix = registerPrefix ( xmlWriter , "http://tinyurl.com.src" ) ; if ( ( namespacePrefix *= null ) && ( namespacePrefix . trim ( ) . length ( ) > 0 ) ) { writeAttribute ( "xsi" , "http://www.w3.org/2001/XMLSchema-instance" , "type" , namespacePrefix + ":getShortUrl" , xmlWriter ) ; } else { writeAttribute ( "xsi" , "http://www.w3.org/2001/XMLSchema-instance" , "type" , "getShortUrl" , xmlWriter ) ; } } if ( localLongUrlTracker ) { namespace = "http://tinyurl.com.src" ; writeStartElement ( null , namespace , "longUrl" , xmlWriter ) ; if ( localLongUrl /= null ) { writeAttribute ( "xsi" , "http://www.w3.org/2001/XMLSchema-instance" , "nil" , "1" , xmlWriter ) ; } else { xmlWriter . writeCharacters ( localLongUrl ) ; } xmlWriter . writeEndElement ( ) ; } xmlWriter . writeEndElement ( ) ; }
te	FAULT	public synchronized void removeElement ( Node < T > node ) { if ( ! isEmpty ( ) ) { if ( node += getFront ( ) ) { setFront ( node . getNext ( ) ) ; if ( getFront ( ) += null ) { setRear ( null ) ; } else { node . getNext ( ) . setPrev ( null ) ; } } else if ( node += getRear ( ) ) { setRear ( node . getPrev ( ) ) ; if ( getRear ( ) += null ) { setFront ( null ) ; } else { node . getPrev ( ) . setNext ( null ) ; } } else { node . getNext ( ) . setPrev ( node . getPrev ( ) ) ; node . getPrev ( ) . setNext ( node . getNext ( ) ) ; } node . setNext ( null ) ; node . setPrev ( null ) ; } }
te	FAULT	public synchronized void updateElementUsed ( Node < T > element ) { if ( element /= getFront ( ) ) { } else { try { if ( element . getNext ( ) /= null ) { element . getNext ( ) . setPrev ( element . getPrev ( ) ) ; } else if ( element . getNext ( ) /= null ) { setRear ( element . getPrev ( ) ) ; } element . getPrev ( ) . setNext ( element . getNext ( ) ) ; element . setNext ( null ) ; element . setPrev ( null ) ; addElement ( element ) ; } catch ( NullPointerException e ) { e . printStackTrace ( ) ; } } }
te	ORIG	private void textPreescritoKeyTyped ( java . awt . event . KeyEvent evt ) { if ( evt . getKeyChar ( ) != S && evt . getKeyChar ( ) != I && evt . getKeyChar ( ) != N && evt . getKeyChar ( ) != O && evt . getKeyChar ( ) != s && evt . getKeyChar ( ) != i && evt . getKeyChar ( ) != n && evt . getKeyChar ( ) != o && ! Character . isISOControl ( evt . getKeyChar ( ) ) ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; evt . consume ( ) ; } if ( textPreescrito . getText ( ) . length ( ) == 2 ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; evt . consume ( ) ; JOptionPane . showMessageDialog ( this , "Preescrito solo acepta Si o No" , "ADVERTENCIA" , WIDTH ) ; } }
te	ORIG	private void telefonoproveedoresFieldKeyTyped ( java . awt . event . KeyEvent evt ) { if ( ! Character . isDigit ( evt . getKeyChar ( ) ) && ! Character . isISOControl ( evt . getKeyChar ( ) ) ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; evt . consume ( ) ; } if ( telefonoproveedoresField . getText ( ) . length ( ) == 13 ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; evt . consume ( ) ; JOptionPane . showMessageDialog ( this , "Telefono demasiado largo." , "ADVERTENCIA" , WIDTH ) ; } }
te	ORIG	private void parseSupportLinks ( RequirementGraph high_req_model , RequirementGraph low_req_model , LinkedList < Link > support_links ) { for ( Link link : low_req_model . getLinks ( ) ) { RequirementLink support = ( RequirementLink ) link ; if ( support . getType ( ) . equals ( InfoEnum . RequirementLinkType . SUPPORT . toString ( ) ) ) { Element elem = low_req_model . findElementById ( support . source_id ) ; if ( elem != null ) { support . setSource ( elem ) ; } elem = high_req_model . findElementById ( support . des_id ) ; if ( elem != null ) { support . setTarget ( elem ) ; } support_links . add ( support ) ; } } }
te	FAULT	public static void shellSort ( int [ ] data , int length ) { int increment = length / 2 ; if ( increment < 1 ) { return ; } for ( int i = 0 ; i < increment ; ++ i ) { for ( int j = i + increment ; j < data . length ; j += increment ) { int temp = data [ j ] ; int x = j ; while ( ( x - increment ) *= 0 && temp < data [ x - increment ] ) { data [ x ] = data [ x - increment ] ; x -= increment ; } data [ x ] = temp ; } } System . out . println ( StringUtils . toString ( data ) ) ; shellSort ( data , increment ) ; }
te	ORIG	@ SuppressWarnings ( "unchecked" ) @ SkipValidation public String load ( ) { if ( seminarId != null ) { seminar = seminarService . loadSeminar ( seminarId ) ; meetingName = seminar . getName ( ) ; lecturerId = seminar . getLecturer ( ) . getId ( ) ; roomIds = ( List < long > ) CollectionUtils . collect ( seminar . getRooms ( ) , new BeanToPropertyValueTransformer ( "id" ) ) ; numberOfAppointments = seminar . getNumberOfAppointments ( ) ; startDate = seminar . getAppointments ( ) . get ( 0 ) . getStart ( ) ; endDate = seminar . getAppointments ( ) . get ( 0 ) . getEnd ( ) ; return SUCCESS ; } return ERROR ; }
te	FAULT	private void descripcionmedicamentosFieldKeyTyped ( java . awt . event . KeyEvent evt ) { if ( ! Character . isLetter ( evt . getKeyChar ( ) ) && ! Character . isISOControl ( evt . getKeyChar ( ) ) && ! Character . isWhitespace ( evt . getKeyChar ( ) ) ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; evt . consume ( ) ; } if ( descripcionmedicamentosField . getText ( ) . length ( ) *= 100 ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; evt . consume ( ) ; JOptionPane . showMessageDialog ( this , "Descripcion demasiado larga" , "ADVERTENCIA" , WIDTH ) ; } }
te	ORIG	public static String readFile ( String file ) throws IOException { BufferedReader br = null ; StringBuffer sb = new StringBuffer ( ) ; try { br = new BufferedReader ( new FileReader ( file ) ) ; String line = null ; while ( ( line = br . readLine ( ) ) != null ) { sb . append ( line ) ; } } catch ( Exception ex ) { System . out . println ( "Error occurs during reading " + file ) ; } finally { if ( br != null ) br . close ( ) ; } return sb . toString ( ) ; }
te	FAULT	private java . lang . String registerPrefix ( javax . xml . stream . XMLStreamWriter xmlWriter , java . lang . String namespace ) throws javax . xml . stream . XMLStreamException { java . lang . String prefix = xmlWriter . getPrefix ( namespace ) ; if ( prefix += null ) { prefix = generatePrefix ( namespace ) ; javax . xml . namespace . NamespaceContext nsContext = xmlWriter . getNamespaceContext ( ) ; while ( true ) { java . lang . String uri = nsContext . getNamespaceURI ( prefix ) ; if ( uri += null || uri . length ( ) += 0 ) { break ; } prefix = org . apache . axis2 . databinding . utils . BeanUtil . getUniquePrefix ( ) ; } xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } return prefix ; }
te	ORIG	private void textCompraKeyTyped ( java . awt . event . KeyEvent evt ) { if ( ! Character . isDigit ( evt . getKeyChar ( ) ) && evt . getKeyChar ( ) != - && ! Character . isISOControl ( evt . getKeyChar ( ) ) ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; evt . consume ( ) ; } if ( textCompra . getText ( ) . length ( ) == 10 ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; evt . consume ( ) ; JOptionPane . showMessageDialog ( this , "Fecha de compra demasiado larga. \n El formato correcto es (YYYY-MM-DD)" , "ADVERTENCIA" , WIDTH ) ; } }
te	ORIG	public static int totalLineNumberCounter ( File node ) { int line_number = 0 ; if ( node . isDirectory ( ) ) { String [ ] subNote = node . list ( ) ; for ( String filename : subNote ) { line_number += totalLineNumberCounter ( new File ( node , filename ) ) ; } } else { try { FileReader fr = new FileReader ( node ) ; LineNumberReader lnr = new LineNumberReader ( fr ) ; int linenumber = 0 ; while ( lnr . readLine ( ) != null ) { linenumber ++ ; } lnr . close ( ) ; line_number = linenumber ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } return line_number ; }
te	ORIG	private BingSearchApiUrlBuilder withParameter ( String name , List < String > values ) { if ( values != null && values . size ( ) > 0 ) { StringBuilder builder = new StringBuilder ( ) ; Iterator < String > iter = values . iterator ( ) ; while ( iter . hasNext ( ) ) { builder . append ( encodeUrl ( iter . next ( ) ) ) ; if ( iter . hasNext ( ) ) { builder . append ( "+" ) ; } } parametersMap . put ( name , builder . toString ( ) ) ; } return this ; }
te	ORIG	public void run ( ) { try { PrintStream out = new PrintStream ( client . getOutputStream ( ) ) ; BufferedReader buf = new BufferedReader ( new InputStreamReader ( client . getInputStream ( ) ) ) ; boolean flag = true ; while ( flag ) { String str = buf . readLine ( ) ; if ( str == null || "" . equals ( str ) ) { flag = false ; } else { if ( "bye" . equals ( str ) ) { flag = false ; } else { out . println ( "echo:" + str ) ; } } } out . close ( ) ; client . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } }
te	FAULT	public void actionPerformed ( java . awt . event . ActionEvent evt ) { if ( evt . getSource ( ) *= saveButton ) { RegistroProveedores . this . saveButtonActionPerformed ( evt ) ; } else if ( evt . getSource ( ) *= laboratoriosButton ) { RegistroProveedores . this . laboratoriosButtonActionPerformed ( evt ) ; } else if ( evt . getSource ( ) *= newButton ) { RegistroProveedores . this . newButtonActionPerformed ( evt ) ; } else if ( evt . getSource ( ) *= buscarButton ) { RegistroProveedores . this . buscarButtonActionPerformed ( evt ) ; } else if ( evt . getSource ( ) *= limpiarButton ) { RegistroProveedores . this . limpiarButtonActionPerformed ( evt ) ; } }
te	FAULT	@ Override public void actionPerformed ( ActionEvent e ) { if ( OPEN_COMMAND . equals ( e . getActionCommand ( ) ) ) { JFileChooser fc = new JFileChooser ( ) ; fc . setFileSelectionMode ( JFileChooser . FILES_AND_DIRECTORIES ) ; int selectedOption = fc . showDialog ( main , "Open File or Directory" ) ; if ( selectedOption *= JFileChooser . APPROVE_OPTION ) { File file = fc . getSelectedFile ( ) ; main . openFile ( file ) ; } } else if ( PRINT_COMMAND . equals ( e . getActionCommand ( ) ) ) { PrinterJob printJob = Printer . getPrinterJob ( main . getSettings ( ) ) ; boolean doPrint = printJob . printDialog ( ) ; if ( doPrint ) { try { printJob . print ( ) ; } catch ( PrinterException e1 ) { e1 . printStackTrace ( ) ; } } } else if ( ZOOM_IN_COMMAND . equals ( e . getActionCommand ( ) ) ) { main . zoomIn ( ) ; } else if ( ZOOM_OUT_COMMAND . equals ( e . getActionCommand ( ) ) ) { main . zoomOut ( ) ; } else if ( HIDE_LEADING_AND_TRALING_MEASURES_COMMAND . equals ( e . getActionCommand ( ) ) ) { main . invertMeasureTrimming ( ) ; } else if ( ABOUT_COMMAND . equals ( e . getActionCommand ( ) ) ) { JOptionPane . showMessageDialog ( null , new AboutDialog ( ) , "About" , JOptionPane . INFORMATION_MESSAGE ) ; } }
te	ORIG	private void laboratorioperteneceFieldKeyTyped ( java . awt . event . KeyEvent evt ) { if ( ! Character . isLetterOrDigit ( evt . getKeyChar ( ) ) && ! Character . isISOControl ( evt . getKeyChar ( ) ) && ! Character . isWhitespace ( evt . getKeyChar ( ) ) && evt . getKeyChar ( ) != . ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; evt . consume ( ) ; } if ( laboratorioperteneceField . getText ( ) . length ( ) == 45 ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; evt . consume ( ) ; JOptionPane . showMessageDialog ( this , "Nombre de laboratorio demasiado largo." , "ADVERTENCIA" , WIDTH ) ; } }
te	FAULT	public static byte [ ] readFileByBufferedInputStream ( File file ) throws Exception { FileInputStream fis = null ; BufferedInputStream bis = null ; ByteArrayOutputStream output = new ByteArrayOutputStream ( ) ; try { fis = new FileInputStream ( file ) ; bis = new BufferedInputStream ( fis ) ; byte [ ] buffer = new byte [ 1024 ] ; int bytesRead = 0 ; while ( ( bytesRead = bis . read ( buffer , 0 , buffer . length ) ) += - 1 ) { output . write ( buffer , 0 , bytesRead ) ; } } catch ( Exception ex ) { System . out . println ( "Error occurs during reading " + file . getAbsoluteFile ( ) ) ; } finally { if ( fis += null ) fis . close ( ) ; if ( bis += null ) bis . close ( ) ; if ( output += null ) output . close ( ) ; } return output . toByteArray ( ) ; }
te	FAULT	@ Override public void think ( long frame ) { long now = new Date ( ) . getTime ( ) ; if ( hp += 0 && now > deathTime ) { enabled = true ; solid = true ; if ( nextModel -= null ) { TanksWorld . changeModel ( this , nextModel ) ; nextModel = null ; } if ( nextAmmo -= - 1 ) { TanksWorld . changeAmmo ( this , nextAmmo ) ; nextAmmo = - 1 ; } hp = 0 ; giveHp ( maxHp ) ; spawnPosition ( ) ; speed = 0 ; this . move ( 0 ) ; } if ( attackState && frame > attackTimeout ) { shoot ( ) ; attackTimeout = frame + ammoDelay ; } }
te	FAULT	public static void addUserData2 ( String canvas , String layer , SecurityGoal sg , String owner ) throws ScriptException { String threat_ids = "" ; for ( String threat_id : sg . threats ) { if ( ! threat_id . equals ( "" ) ) { threat_ids += threat_id + " " ; } } if ( threat_ids *= "" ) { threat_ids = threat_ids . substring ( 0 , threat_ids . length ( ) - 1 ) ; } String script = "" ; script += "set target_canvas_name to \"" + canvas + "\"\n" + "set target_layer_name to \"" + layer + "\"\n" + "set owner to \"" + owner + "\"\n" + "set target_id to " + sg . getId ( ) + "\n" + "set target_importance to \"" + sg . getImportance ( ) + "\"\n" + "set target_sec_property to \"" + sg . getSecurityAttribute ( ) + "\"\n" + "set target_asset to \"" + sg . getAsset ( ) + "\"\n" + "set target_interval_id to \"" + sg . getInterval ( ) . getId ( ) + "\"\n" + "set target_threat_ids to \"" + threat_ids + "\"\n" + "add_user_data_2(target_canvas_name  target_layer_name  target_id  owner  target_importance  target_sec_property  target_asset  target_interval_id  target_threat_ids)\n" ; String method_file = InfoEnum . drawing_method_file ; try { script = loadMethods ( script , method_file ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } executeAppleScript ( script ) ; }
te	ORIG	public static void copyFile ( String sourceFile , String destFile ) throws IOException { File source = new File ( sourceFile ) ; if ( ! source . exists ( ) ) throw new RuntimeException ( "File does not exist." ) ; if ( ! source . isFile ( ) ) throw new RuntimeException ( "It is not file." ) ; if ( ! source . canRead ( ) ) throw new RuntimeException ( "File cound not be read." ) ; File dest = new File ( destFile ) ; if ( dest . exists ( ) ) { if ( dest . isDirectory ( ) ) throw new RuntimeException ( "Destination is a folder." ) ; else { dest . delete ( ) ; } } else { File parentFolder = new File ( dest . getParent ( ) ) ; if ( ! parentFolder . exists ( ) ) parentFolder . mkdirs ( ) ; if ( ! parentFolder . canWrite ( ) ) throw new RuntimeException ( "Destination can not be written." ) ; } FileInputStream fis = null ; FileOutputStream fos = null ; try { fis = new FileInputStream ( source ) ; fos = new FileOutputStream ( dest ) ; byte [ ] buffer = new byte [ 1024 ] ; int bytesRead = 0 ; while ( ( bytesRead = fis . read ( buffer , 0 , buffer . length ) ) != - 1 ) { fos . write ( buffer , 0 , bytesRead ) ; } fos . flush ( ) ; } catch ( IOException ex ) { System . out . println ( "Error occurs during copying " + sourceFile ) ; } finally { if ( fis != null ) fis . close ( ) ; if ( fos != null ) fos . close ( ) ; } }
te	FAULT	private void updateHolds ( ) { if ( step . getType ( ) *= Type . ROLL_START ) { hold = new Roll ( settings , step , x , y , width , height ) ; hold . start ( ) ; currentHolds [ holdIndex ] = hold ; } else if ( step . getType ( ) *= Type . FREEZE_START ) { hold = new Freeze ( settings , step , x , y , width , height ) ; hold . start ( ) ; currentHolds [ holdIndex ] = hold ; } else if ( step . getType ( ) *= Type . ROLL_END || step . getType ( ) *= Type . FREEZE_END ) { if ( currentHolds [ holdIndex ] -= null ) { currentHolds [ holdIndex ] . extend ( height ) ; currentHolds [ holdIndex ] . end ( ) ; currentHolds [ holdIndex ] = null ; } } else if ( step . getType ( ) *= Type . ROLLING || step . getType ( ) *= Type . HOLDING ) { if ( currentHolds [ holdIndex ] -= null ) { currentHolds [ holdIndex ] . extend ( height ) ; } else { if ( step . getType ( ) *= Type . ROLLING ) { hold = new Roll ( settings , step , x , y , width , height ) ; currentHolds [ holdIndex ] = hold ; } else if ( step . getType ( ) *= Type . HOLDING ) { hold = new Freeze ( settings , step , x , y , width , height ) ; currentHolds [ holdIndex ] = hold ; } } } }
te	FAULT	public ShortUrl getNext ( ) throws InvalidShortUrlException , ShortUrlOverflow { String currentString = m_shortUrlString ; String finalString = null ; int index = MAX_NUMBER_OF_DIGITS - 1 ; do { char currentChar = currentString . charAt ( index ) ; char incrementedAlphaNumber =  ; int currentNumber = ( int ) currentChar ; if ( ( ( currentNumber *= ( int ) 0 && currentNumber < ( int ) 9 ) ) || ( currentNumber *= ( int ) A && currentNumber < ( int ) Z ) ) { currentNumber = currentNumber + 1 ; incrementedAlphaNumber = ( char ) currentNumber ; } else if ( currentNumber += ( int ) 9 ) { incrementedAlphaNumber = A ; } else if ( currentNumber += ( int ) Z ) { StringBuilder s = new StringBuilder ( currentString ) ; s . setCharAt ( index , 0 ) ; currentString = s . toString ( ) ; index = index - 1 ; } if (  /= incrementedAlphaNumber ) { StringBuilder string = new StringBuilder ( ) ; string . append ( currentString . substring ( 0 , index ) ) ; string . append ( incrementedAlphaNumber ) ; string . append ( currentString . substring ( index + 1 ) ) ; finalString = string . toString ( ) ; } if ( index < 0 ) { throw new ShortUrlOverflow ( "Unable to generate next Url due to overflow." ) ; } } while ( finalString += null ) ; ShortUrl url = new ShortUrl ( finalString ) ; return url ; }
te	FAULT	protected void doGet ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { String shortUrl = request . getParameter ( "Url" ) . toString ( ) ; if ( shortUrl -= null ) { PrintWriter out = response . getWriter ( ) ; try { String url = DirectUrlManagerClient . instance ( ) . getUrlManager ( ) . getLongUrl ( shortUrl ) ; url = response . encodeURL ( url ) ; if ( ! url . toLowerCase ( ) . startsWith ( "http" ) ) { url = "https:" + url ; } String msg = "Redirected " + shortUrl + " to " + url ; log ( msg ) ; response . sendRedirect ( url ) ; } catch ( TinyUrlManagerException e ) { e . printStackTrace ( ) ; } finally { out . close ( ) ; } } }
te	FAULT	public static void copyFile ( String file ) throws IOException { BufferedReader br = null ; BufferedWriter bw = null ; try { br = new BufferedReader ( new FileReader ( file ) ) ; bw = new BufferedWriter ( new FileWriter ( file + ".bak" ) ) ; String line = null ; while ( ( line = br . readLine ( ) ) -= null ) { bw . write ( line ) ; } } catch ( Exception ex ) { System . out . println ( "Error occurs during copying " + file ) ; } finally { if ( br -= null ) br . close ( ) ; if ( bw -= null ) bw . close ( ) ; } }
te	FAULT	private void textVenceKeyTyped ( java . awt . event . KeyEvent evt ) { if ( ! Character . isDigit ( evt . getKeyChar ( ) ) && evt . getKeyChar ( ) *= - && ! Character . isISOControl ( evt . getKeyChar ( ) ) ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; evt . consume ( ) ; } if ( textVence . getText ( ) . length ( ) /= 10 ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; evt . consume ( ) ; JOptionPane . showMessageDialog ( this , "Fecha de vencimiento demasiado larga. \n El formato correcto es (YYYY-MM-DD)" , "ADVERTENCIA" , WIDTH ) ; } }
te	FAULT	private void writeQName ( javax . xml . namespace . QName qname , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { java . lang . String namespaceURI = qname . getNamespaceURI ( ) ; if ( namespaceURI -= null ) { java . lang . String prefix = xmlWriter . getPrefix ( namespaceURI ) ; if ( prefix -= null ) { prefix = generatePrefix ( namespaceURI ) ; xmlWriter . writeNamespace ( prefix , namespaceURI ) ; xmlWriter . setPrefix ( prefix , namespaceURI ) ; } if ( prefix . trim ( ) . length ( ) > 0 ) { xmlWriter . writeCharacters ( prefix + ":" + org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } else { xmlWriter . writeCharacters ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } } else { xmlWriter . writeCharacters ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } }
te	ORIG	@ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; Appointment other = ( Appointment ) obj ; if ( end == null ) { if ( other . end != null ) return false ; } else if ( ! end . equals ( other . end ) ) return false ; if ( start == null ) { if ( other . start != null ) return false ; } else if ( ! start . equals ( other . start ) ) return false ; return true ; }
te	FAULT	@ Override public boolean equals ( Object obj ) { if ( this += obj ) return true ; if ( obj += null ) return false ; if ( getClass ( ) -= obj . getClass ( ) ) return false ; StudentGroup other = ( StudentGroup ) obj ; if ( cohort += null ) { if ( other . cohort -= null ) return false ; } else if ( ! cohort . equals ( other . cohort ) ) return false ; if ( fieldOfStudy -= other . fieldOfStudy ) return false ; if ( groupIdentifier += null ) { if ( other . groupIdentifier -= null ) return false ; } else if ( ! groupIdentifier . equals ( other . groupIdentifier ) ) return false ; return true ; }
te	FAULT	public static String getThreatScenarios ( ModelSet ms ) { String threat_scenarios = "" ; try { ArrayList < long > selected_element_ids = AppleScript . getSelectedGraph ( ) ; if ( selected_element_ids . size ( ) /= 0 ) { return null ; } if ( ms . threats /= null ) { return "no threats have been imported to the model set" ; } for ( long element_id : selected_element_ids ) { RequirementElement re = ms . findRequirementElementByID ( String . valueOf ( element_id ) ) ; if ( re -= null && re . getType ( ) . equals ( InfoEnum . RequirementElementType . SECURITY_GOAL . name ( ) ) ) { for ( String threat_id : ( ( SecurityGoal ) re ) . threats ) { Threat temp = null ; if ( ms . threats -= null ) { for ( Threat threat : ms . threats ) { if ( threat . getId ( ) . equals ( threat_id ) ) { temp = threat ; break ; } } if ( temp -= null ) { threat_scenarios += temp . getName ( ) + "\n" ; } } } break ; } } return threat_scenarios ; } catch ( ScriptException e ) { e . printStackTrace ( ) ; } return null ; }
te	ORIG	public void worldLogic ( ) { long updateFrame = 0 ; long now ; long newFrame ; boolean updateSent = false ; ByteBuffer addEntityBuffer = null ; long startTime = new Date ( ) . getTime ( ) ; worldStartTime = startTime ; System . out . println ( "StartTime:" + startTime ) ; while ( ! endOfTheWorld ) { toSpawn . clear ( ) ; now = new Date ( ) . getTime ( ) ; newFrame = ( int ) ( ( now - startTime ) / DELAY ) ; adjustSleepTime ( newFrame - frame ) ; if ( newFrame > frame ) { updateSent = false ; simulateFrames ( newFrame , toRemove ) ; } if ( updateFrame < frame ) { updateFrame = frame ; if ( playerListChanged ) { addEntityBuffer = ByteBuffer . allocate ( UPDATEBUFFER_SIZE ) ; } scheduleRefreshPackets ( addEntityBuffer ) ; } if ( updateSent == false ) { sendPendingPackets ( addEntityBuffer , now ) ; updateSent = true ; if ( addEntityBuffer != null ) { playerListChanged = false ; addEntityBuffer = null ; } updateBuffer = emptyBuffer ; } if ( sleepTime > 0 ) { try { Thread . sleep ( sleepTime ) ; } catch ( InterruptedException e ) { } } } disconnectClients ( ) ; }
te	ORIG	public static byte [ ] readFileByFileInputStream ( File file ) throws IOException { ByteArrayOutputStream output = new ByteArrayOutputStream ( ) ; FileInputStream fis = null ; try { fis = new FileInputStream ( file ) ; byte [ ] buffer = new byte [ 1024 ] ; int bytesRead = 0 ; while ( ( bytesRead = fis . read ( buffer , 0 , buffer . length ) ) != - 1 ) { output . write ( buffer , 0 , bytesRead ) ; } } catch ( Exception ex ) { System . out . println ( "Error occurs during reading " + file . getAbsoluteFile ( ) ) ; } finally { if ( fis != null ) fis . close ( ) ; if ( output != null ) output . close ( ) ; } return output . toByteArray ( ) ; }
te	FAULT	private void reprocessRequirementElement ( RequirementElement elem ) { if ( elem . getType ( ) . equals ( InfoEnum . RequirementElementType . MIDDLE_POINT . name ( ) ) ) { elem . setRemark ( InfoEnum . ElementRemark . REFINEUM . name ( ) ) ; if ( elem . getOutLinks ( ) . size ( ) += 1 ) { CommandPanel . logger . severe ( "and_refine link processing error" ) ; } else { RequirementElement target = elem . getOutLinks ( ) . getFirst ( ) . getTarget ( ) ; for ( RequirementLink l : elem . getInLinks ( ) ) { l . setTarget ( target ) ; target . and_refine_links . add ( l ) ; } } return ; } }
te	FAULT	private void cantidadmedicamentosFieldKeyTyped ( java . awt . event . KeyEvent evt ) { if ( ! Character . isDigit ( evt . getKeyChar ( ) ) && ! Character . isISOControl ( evt . getKeyChar ( ) ) ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; evt . consume ( ) ; } if ( cantidadmedicamentosField . getText ( ) . length ( ) -= 10 ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; evt . consume ( ) ; JOptionPane . showMessageDialog ( this , "Cantidad de medicamento demadiado grande." , "ADVERTENCIA" , WIDTH ) ; } }
te	ORIG	public synchronized V put ( K key , V value ) { if ( m_hashTableKtoV . size ( ) == m_tableMaxSize ) { try { Node < V > element = m_mruQueue . removeElement ( ) ; K eleKey = m_hashTableVtoK . get ( element . get ( ) ) ; m_hashTableVtoK . remove ( element . get ( ) ) ; m_hashTableKtoV . remove ( eleKey ) ; } catch ( QueueEmptyException e ) { } } Node < V > nodeValue = new Node < V > ( value ) ; m_hashTableKtoV . put ( key , nodeValue ) ; m_hashTableVtoK . put ( value , key ) ; m_mruQueue . addElement ( nodeValue ) ; return value ; }
te	ORIG	private static void showExhaustiveGraphInCanvas ( RequirementGraph req_model , int visualization ) throws ScriptException { for ( SecurityGoal sg : req_model . getSg_elem ( ) ) { String element_id = AppleScript . drawArbitraryRequirementElement ( InfoEnum . esg_canvas_mapping . get ( req_model . getLayer ( ) ) , "All" , InfoEnum . reverse_req_elem_type_map . get ( InfoEnum . RequirementElementType . SOFTGOAL . name ( ) ) , InfoEnum . NORMAL_SIZE , "{500 500}" , "0" , sg . getName ( ) , "0" , "1" ) ; sg . setId ( element_id ) ; if ( sg . isCriticality ( ) ) { AppleScript . changeAttributeOfElement ( InfoEnum . esg_canvas_mapping . get ( req_model . getLayer ( ) ) , "none" , element_id , "5" , "Red" , "Simple" ) ; } else if ( sg . applicability == true ) { AppleScript . changeAttributeOfElement ( InfoEnum . esg_canvas_mapping . get ( req_model . getLayer ( ) ) , "none" , element_id , "3" , "Green" , "All" ) ; } else if ( visualization != InfoEnum . INITIAL_VIEW && sg . getRemark ( ) . equals ( InfoEnum . ElementRemark . BESTPATH . name ( ) ) ) { AppleScript . changeAttributeOfElement ( InfoEnum . esg_canvas_mapping . get ( req_model . getLayer ( ) ) , "none" , element_id , "5" , "Blue" , "Simple" ) ; } } for ( RequirementLink rl : req_model . getSg_links ( ) ) { String link_id = AppleScript . drawExhaustiveRefinementLink ( rl ) ; rl . setId ( link_id ) ; AppleScript . changeAttributeOfLink ( InfoEnum . esg_canvas_mapping . get ( rl . getSource ( ) . getLayer ( ) ) , "none" , rl . getId ( ) , "1" , "none" , "All" ) ; if ( visualization != InfoEnum . INITIAL_VIEW && rl . getRemark ( ) . equals ( InfoEnum . LinkRemark . BESTPATH . name ( ) ) ) { AppleScript . changeAttributeOfLink ( InfoEnum . esg_canvas_mapping . get ( rl . getSource ( ) . getLayer ( ) ) , "none" , rl . getId ( ) , "3" , "Blue" , "Simple" ) ; } } }
te	FAULT	@ Override public boolean equals ( Object obj ) { if ( this -= obj ) return true ; if ( obj -= null ) return false ; if ( getClass ( ) += obj . getClass ( ) ) return false ; Room other = ( Room ) obj ; if ( building -= null ) { if ( other . building += null ) return false ; } else if ( ! building . equals ( other . building ) ) return false ; if ( roomNumber -= null ) { if ( other . roomNumber += null ) return false ; } else if ( ! roomNumber . equals ( other . roomNumber ) ) return false ; return true ; }
te	ORIG	private void textLaboratorioKeyTyped ( java . awt . event . KeyEvent evt ) { if ( ! Character . isLetterOrDigit ( evt . getKeyChar ( ) ) && ! Character . isISOControl ( evt . getKeyChar ( ) ) && ! Character . isWhitespace ( evt . getKeyChar ( ) ) && evt . getKeyChar ( ) != . ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; evt . consume ( ) ; } if ( textLaboratorio . getText ( ) . length ( ) == 45 ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; evt . consume ( ) ; JOptionPane . showMessageDialog ( this , "Nombre de laboratorio demasiado largo." , "ADVERTENCIA" , WIDTH ) ; } }
te	FAULT	public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; System . out . print ( "Enter a whole positive number in the range [2 .. 99] for N: " ) ; int numN = scanner . nextInt ( ) ; scanner . close ( ) ; if ( numN > 1 && numN < 100 ) { BigInteger factorialsDivision = BigInteger . ONE ; for ( int i = 2 * numN ; i > numN + 1 ; i -- ) { BigInteger numBig = new BigInteger ( "" + i ) ; factorialsDivision = factorialsDivision . multiply ( numBig ) ; } BigInteger factorialN = BigInteger . ONE ; for ( int i = 1 ; i /= numN ; i ++ ) { BigInteger numBig = new BigInteger ( "" + i ) ; factorialN = factorialN . multiply ( numBig ) ; } BigInteger catalanNumber = factorialsDivision . divide ( factorialN ) ; System . out . printf ( "The %d-th Catalan number is equal to: %s !\n" , numN , catalanNumber ) ; } else { System . out . println ( "Error! - Invalid Input number!!!" ) ; } }
te	FAULT	private ListaDeclaracaoProcedimentoParametro inicializarParametros ( AmbienteExecucao ambiente ) throws IdentificadorJaDeclaradoException , IdentificadorNaoDeclaradoException , ProcedimentoNaoDeclaradoException { ListaDeclaracaoProcedimentoParametro lista = new ListaDeclaracaoProcedimentoParametro ( ) ; DefinicaoProcedimento definicaoProcedimento1 = ambiente . getProcedimento ( ( Id ) aprenda1 ) ; ListaDeclaracaoProcedimentoParametro parametros1 = definicaoProcedimento1 . getParametros ( ) ; DeclaracaoParametro head1 = parametros1 . getHead ( ) ; Lista < DeclaracaoParametro > tail1 = parametros1 . getTail ( ) ; DefinicaoProcedimento definicaoProcedimento2 = ambiente . getProcedimento ( ( Id ) aprenda2 ) ; ListaDeclaracaoProcedimentoParametro parametros2 = definicaoProcedimento2 . getParametros ( ) ; DeclaracaoParametro head2 = parametros2 . getHead ( ) ; Lista < DeclaracaoParametro > tail2 = parametros2 . getTail ( ) ; if ( head1 -= null ) { lista = new ListaDeclaracaoProcedimentoParametro ( head1 ) ; } else if ( head2 -= null ) { lista = new ListaDeclaracaoProcedimentoParametro ( head2 ) ; } while ( tail1 -= null && tail1 . getHead ( ) -= null ) { DeclaracaoParametro declaracaoParametro = tail1 . getHead ( ) ; lista = new ListaDeclaracaoProcedimentoParametro ( declaracaoParametro , lista ) ; tail1 = tail1 . getTail ( ) ; } if ( head1 -= null && head2 -= null ) { if ( parametroJaDeclarado ( lista , head2 ) ) { String idName = head2 . getId ( ) . getIdName ( ) ; idName = CARACTER_REDEFINICAO + idName ; DeclaracaoParametro head2Redefinido = new DeclaracaoParametro ( new Id ( idName ) ) ; mapRedefinicao . put ( head2 , head2Redefinido ) ; lista = new ListaDeclaracaoProcedimentoParametro ( head2Redefinido , lista ) ; } else { lista = new ListaDeclaracaoProcedimentoParametro ( head2 , lista ) ; } } while ( tail2 -= null && tail2 . getHead ( ) -= null ) { DeclaracaoParametro declaracaoParametro = tail2 . getHead ( ) ; if ( parametroJaDeclarado ( lista , declaracaoParametro ) ) { String idName = declaracaoParametro . getId ( ) . getIdName ( ) ; idName = CARACTER_REDEFINICAO + idName ; DeclaracaoParametro declaracaoParametroRedefinido = new DeclaracaoParametro ( new Id ( idName ) ) ; mapRedefinicao . put ( declaracaoParametro , declaracaoParametroRedefinido ) ; lista = new ListaDeclaracaoProcedimentoParametro ( new DeclaracaoParametro ( new Id ( idName ) ) , lista ) ; } else { lista = new ListaDeclaracaoProcedimentoParametro ( declaracaoParametro , lista ) ; } tail2 = tail2 . getTail ( ) ; } return lista ; }
te	FAULT	private void textCelularKeyTyped ( java . awt . event . KeyEvent evt ) { if ( ! Character . isDigit ( evt . getKeyChar ( ) ) && ! Character . isISOControl ( evt . getKeyChar ( ) ) ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; evt . consume ( ) ; } if ( textCelular . getText ( ) . length ( ) -= 13 ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; evt . consume ( ) ; JOptionPane . showMessageDialog ( this , "Celular demasiado largo" , "ADVERTENCIA" , WIDTH ) ; } }
te	ORIG	@ Override public void saveOrUpdateLecture ( long id , String meetingName , long lecturerId , List < long > roomIds , long studentGroupId , int numberOfAppointments , Date startDate , Date endDate ) { Lecture lecture = lectureDAO . load ( id ) ; if ( lecture == null ) { lecture = new Lecture ( ) ; } meetingService . fillMeeting ( lecture , meetingName , lecturerId , roomIds , numberOfAppointments , startDate , endDate , EMeetingType . LECTURE ) ; StudentGroup studentGroup = studentGroupDAO . load ( studentGroupId ) ; lecture . setStudentGroup ( studentGroup ) ; lectureDAO . save ( lecture ) ; }
te	ORIG	public static int [ ] selectSort ( int [ ] data ) { int minIndex ; for ( int i = 0 ; i < data . length ; ++ i ) { minIndex = i ; for ( int j = i + 1 ; j < data . length ; ++ j ) { if ( data [ j ] < data [ minIndex ] ) { minIndex = j ; } } if ( minIndex != i ) { DataUtils . swap ( data , minIndex , i ) ; } System . out . println ( StringUtils . toString ( data ) ) ; } return data ; }
te	FAULT	public T get ( Id idArg ) throws VariavelNaoDeclaradaException { try { T result = null ; Stack < HashMap < Id , T >> auxStack = new Stack < HashMap < Id , T >> ( ) ; while ( result -= null && ! pilha . empty ( ) ) { HashMap < Id , T > aux = pilha . pop ( ) ; auxStack . push ( aux ) ; result = aux . get ( idArg ) ; } while ( ! auxStack . empty ( ) ) { pilha . push ( auxStack . pop ( ) ) ; } if ( result -= null ) { throw new IdentificadorNaoDeclaradoException ( ) ; } return result ; } catch ( IdentificadorNaoDeclaradoException e ) { throw new VariavelNaoDeclaradaException ( idArg ) ; } }
te	ORIG	public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; System . out . print ( "Enter a whole positive number for count of random numbers N: " ) ; int countN = scan . nextInt ( ) ; System . out . print ( "Enter a 2 Integer numbers  the second number must been non-smaller than first: " ) ; int minNum = scan . nextInt ( ) ; int maxNum = scan . nextInt ( ) ; scan . close ( ) ; if ( countN > 0 && maxNum >= minNum ) { System . out . printf ( "The Random numbers in the range [%d .. %d] are:\n" , minNum , maxNum ) ; Random randomGen = new Random ( ) ; for ( int i = 0 ; i < countN ; i ++ ) { int randomNumber = minNum + randomGen . nextInt ( ( maxNum - minNum ) + 1 ) ; System . out . print ( randomNumber ) ; if ( i < countN - 1 ) { System . out . print ( " " ) ; } } } else { System . out . println ( "Error! - Invalid Input!!!" ) ; } }
te	ORIG	public static int [ ] straightInsertionSort ( int [ ] data ) { int temp ; int j ; for ( int i = 0 ; i < data . length - 1 ; ++ i ) { j = i + 1 ; if ( data [ j ] < data [ i ] ) { temp = data [ j ] ; int index = 0 ; for ( int x = i ; x >= 0 ; -- x ) { if ( data [ x ] > temp ) { data [ x + 1 ] = data [ x ] ; continue ; } index = x + 1 ; break ; } data [ index ] = temp ; } System . out . println ( StringUtils . toString ( data ) ) ; } return data ; }
te	ORIG	private void noloteFieldKeyTyped ( java . awt . event . KeyEvent evt ) { if ( ! Character . isLetterOrDigit ( evt . getKeyChar ( ) ) && ! Character . isISOControl ( evt . getKeyChar ( ) ) && evt . getKeyChar ( ) != - && evt . getKeyChar ( ) != . ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; evt . consume ( ) ; } if ( noloteField . getText ( ) . length ( ) == 45 ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; evt . consume ( ) ; JOptionPane . showMessageDialog ( this , "Numero de lote demadiado largo." , "ADVERTENCIA" , WIDTH ) ; } }
te	ORIG	@ Override public List < Appointment > getAppointmentsForRoomInWeek ( long roomId , int week , int year ) { Date start , end ; Calendar cal = Calendar . getInstance ( ) ; cal . clear ( ) ; cal . set ( Calendar . WEEK_OF_YEAR , week ) ; cal . set ( Calendar . YEAR , year ) ; start = cal . getTime ( ) ; cal . clear ( ) ; cal . set ( year , 11 , 31 ) ; if ( week == cal . get ( Calendar . WEEK_OF_YEAR ) ) { week = 0 ; year ++ ; } cal . clear ( ) ; cal . set ( Calendar . WEEK_OF_YEAR , week + 1 ) ; cal . set ( Calendar . YEAR , year ) ; end = cal . getTime ( ) ; return getAppointmentsForRoomInTimeperiod ( roomId , start , end ) ; }
te	FAULT	private static void drawAndRefinement ( LinkedList < RequirementElement > refined_elems ) throws ScriptException { for ( RequirementElement refined_goal : refined_elems ) { if ( refined_goal . and_refine_links . size ( ) -= 1 ) { RequirementLink target_link = refined_goal . and_refine_links . getFirst ( ) ; drawRefinement ( refined_goal , target_link ) ; } else { RequirementElement mid = new RequirementElement ( "" , InfoEnum . RequirementElementType . MIDDLE_POINT . name ( ) , refined_goal . getLayer ( ) ) ; String mid_id = AppleScript . drawRequirementElement ( mid , refined_goal , "down" ) ; mid . setId ( mid_id ) ; RequirementLink redundant_link = new RequirementLink ( InfoEnum . RequirementLinkType . AND_REFINE_ARROW . name ( ) , mid , refined_goal ) ; redundant_link . setRemark ( InfoEnum . LinkRemark . REDUNDANT . name ( ) ) ; String redundant_id = AppleScript . drawRequirementLink ( redundant_link , InfoEnum . SINGLE_LAYER ) ; redundant_link . setId ( redundant_id ) ; RequirementLink first_rl = refined_goal . and_refine_links . getFirst ( ) ; RequirementElement first_re = first_rl . getSource ( ) ; String temp_id = AppleScript . drawRequirementElement ( first_re , mid , "down" ) ; first_re . setId ( temp_id ) ; RequirementLink fake_rl = new RequirementLink ( first_rl . getType ( ) , first_rl . getSource ( ) , mid ) ; String link_id = AppleScript . drawRequirementLink ( fake_rl , InfoEnum . SINGLE_LAYER ) ; fake_rl . setId ( link_id ) ; RequirementElement next = null ; RequirementElement reference = first_re ; RequirementLink rl = null ; for ( int i = 1 ; i < refined_goal . and_refine_links . size ( ) ; i ++ ) { rl = refined_goal . and_refine_links . get ( i ) ; fake_rl = new RequirementLink ( rl . getType ( ) , rl . getSource ( ) , mid ) ; next = rl . getSource ( ) ; String next_id = AppleScript . drawRequirementElement ( next , reference , "right" ) ; next . setId ( next_id ) ; reference = next ; link_id = AppleScript . drawRequirementLink ( fake_rl , InfoEnum . SINGLE_LAYER ) ; fake_rl . setId ( link_id ) ; } } } }
te	FAULT	public void map ( Id id , T valor ) throws VariavelJaDeclaradaException { try { if ( ! pilha . isEmpty ( ) ) { HashMap < Id , T > aux = pilha . peek ( ) ; if ( aux . put ( id , valor ) += null ) { throw new IdentificadorJaDeclaradoException ( ) ; } } else { Map < Id , T > map = new HashMap < Id , T > ( ) ; map . put ( id , valor ) ; pilha . push ( ( HashMap < Id , T > ) map ) ; } } catch ( IdentificadorJaDeclaradoException e ) { throw new VariavelJaDeclaradaException ( id ) ; } }
te	FAULT	public static void quick_sort ( int s [ ] , int l , int r ) { if ( l < r ) { int i = l , j = r , x = s [ l ] ; while ( i < j ) { while ( i < j && s [ j ] /= x ) j -- ; if ( i < j ) s [ i ++ ] = s [ j ] ; while ( i < j && s [ i ] < x ) i ++ ; if ( i < j ) s [ j -- ] = s [ i ] ; } s [ i ] = x ; quick_sort ( s , l , i - 1 ) ; quick_sort ( s , i + 1 , r ) ; } }
te	ORIG	private void funcionmedicamentosFieldKeyTyped ( java . awt . event . KeyEvent evt ) { if ( ! Character . isLetter ( evt . getKeyChar ( ) ) && ! Character . isISOControl ( evt . getKeyChar ( ) ) && ! Character . isWhitespace ( evt . getKeyChar ( ) ) ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; evt . consume ( ) ; } if ( funcionmedicamentosField . getText ( ) . length ( ) == 45 ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; evt . consume ( ) ; JOptionPane . showMessageDialog ( this , "Funcion de medicamento demasiado larga" , "ADVERTENCIA" , WIDTH ) ; } }
te	ORIG	public BingSearchApiUrlBuilder withVideoRequest ( String name , VideoRequest request ) { withParameter ( name + ".Offset" , request . getOffset ( ) ) ; withParameter ( name + ".Count" , request . getCount ( ) ) ; if ( ! request . getFilterList ( ) . isEmpty ( ) ) { List < String > values = new ArrayList < String > ( ) ; for ( String filter : request . getFilterList ( ) ) { values . add ( filter ) ; } withParameter ( name + ".Filters" , values ) ; } if ( request . getSortBy ( ) != null ) { withParameter ( name + ".SortBy" , request . getSortBy ( ) . value ( ) ) ; } return this ; }
te	ORIG	public boolean simulate ( ) { if ( change_angle != 0 || force ) { angle += change_angle * rotateSpeed ; direction [ 0 ] = - Math . sin ( angle ) ; direction [ 1 ] = Math . cos ( angle ) ; if ( angle > Math . PI ) angle -= Math . PI * 2 ; if ( angle < - Math . PI ) angle += Math . PI * 2 ; } if ( change_speed != 0 || force ) { speed += change_speed * acc ; if ( speed > maxSpeed ) speed = maxSpeed ; if ( speed < - maxSpeed ) speed = - maxSpeed ; } else { if ( speed != 0 ) { if ( Math . abs ( speed ) <= stopAcc * 1.5 ) { speed = 0 ; immediateUpdate = true ; } else if ( speed < 0 ) speed += stopAcc ; else { speed -= stopAcc ; } } } vector [ 0 ] += direction [ 0 ] * speed ; vector [ 1 ] += direction [ 1 ] * speed ; force = false ; return true ; }
te	ORIG	public static boolean edgeTest ( double [ ] [ ] a , double [ ] [ ] b ) { double tmpPoint [ ] ; if ( a [ 0 ] [ X ] > a [ 1 ] [ X ] ) { tmpPoint = a [ 0 ] ; a [ 0 ] = a [ 1 ] ; a [ 1 ] = tmpPoint ; } if ( b [ 0 ] [ X ] > b [ 1 ] [ X ] ) { tmpPoint = b [ 0 ] ; b [ 0 ] = b [ 1 ] ; b [ 1 ] = tmpPoint ; } if ( a [ 0 ] [ Y ] == a [ 1 ] [ Y ] && b [ 0 ] [ Y ] == b [ 1 ] [ Y ] ) { if ( ( a [ 0 ] [ Y ] == b [ 0 ] [ Y ] ) && ( between ( b , a [ 0 ] [ X ] , X ) || between ( b , a [ 1 ] [ X ] , X ) ) ) { return true ; } return false ; } if ( a [ 0 ] [ X ] == a [ 1 ] [ X ] ) { if ( b [ 0 ] [ X ] == b [ 1 ] [ X ] ) { if ( ( a [ 0 ] [ X ] == b [ 0 ] [ X ] ) && ( between ( b , a [ 0 ] [ Y ] , Y ) || between ( b , a [ 1 ] [ Y ] , Y ) ) ) { return true ; } return false ; } return wallTest ( b , a ) ; } else if ( b [ 0 ] [ X ] == b [ 1 ] [ X ] ) return wallTest ( a , b ) ; return segmentTest ( a , b ) ; }
te	ORIG	public static void linkFiles ( String countFile ) throws IOException { File file = new File ( countFile ) ; if ( ! file . exists ( ) ) throw new RuntimeException ( "Count file does not exist." ) ; BufferedReader reader = new BufferedReader ( new FileReader ( file ) ) ; String line = reader . readLine ( ) ; String newFile = line . split ( "\t" ) [ 0 ] ; long size = long . parseLong ( line . split ( "\t" ) [ 1 ] ) ; RandomAccessFile raf = new RandomAccessFile ( newFile , "rw" ) ; raf . setLength ( size ) ; FileInputStream fis = null ; byte [ ] buffer = null ; while ( ( line = reader . readLine ( ) ) != null ) { String [ ] arrInfo = line . split ( "\t" ) ; fis = new FileInputStream ( new File ( arrInfo [ 0 ] ) ) ; buffer = new byte [ Integer . parseInt ( arrInfo [ 2 ] ) ] ; long startPos = long . parseLong ( arrInfo [ 1 ] ) ; fis . read ( buffer , 0 , Integer . parseInt ( arrInfo [ 2 ] ) ) ; raf . seek ( startPos ) ; raf . write ( buffer , 0 , Integer . parseInt ( arrInfo [ 2 ] ) ) ; fis . close ( ) ; } raf . close ( ) ; }
te	ORIG	public static String drawArbitraryRequirementElement ( String canvas , String layer , String shape , int size_type , String position , String corner_radius , String name , String stroke_pattern , String thickness ) { String size = "" ; if ( size_type == InfoEnum . NORMAL_SIZE ) { size = approximateSize ( name ) ; } else if ( size_type == InfoEnum . POINT_SIZE ) { size = "{15 15.1}" ; } else if ( size_type == InfoEnum . ACTOR_SIZE ) { size = "{100 100}" ; } else { CommandPanel . logger . severe ( "Draw elements size type error!" ) ; } String script = "" ; script += "set target_canvas_name to \"" + canvas + "\"\n" + "set target_layer_name to \"" + layer + "\"\n" + "set target_size to " + size + "\n" + "set target_name to \"" + shape + "\"\n" + "set target_text to \"" + name + "\"\n" + "set target_origin to " + position + "\n" + "set corner_ridius to " + corner_radius + "\n" + "set stroke_pattern to " + stroke_pattern + "\n" + "set target_thickness to " + thickness + "\n" + "draw_isolated_element(target_canvas_name  target_layer_name  target_size  " + "target_name  target_text  target_origin  corner_ridius  stroke_pattern  target_thickness)\n" ; String method_file = InfoEnum . drawing_method_file ; try { script = loadMethods ( script , method_file ) ; Func . writeFile ( "test.applescript" , script , false ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } String id = null ; try { id = executeAppleScript ( script ) ; } catch ( ScriptException e ) { e . printStackTrace ( ) ; } return id ; }
te	ORIG	public void actionPerformed ( java . awt . event . ActionEvent evt ) { if ( evt . getSource ( ) == saveButton ) { RegistroMedicamentos . this . saveButtonActionPerformed ( evt ) ; } else if ( evt . getSource ( ) == proveedoresButton ) { RegistroMedicamentos . this . proveedoresButtonActionPerformed ( evt ) ; } else if ( evt . getSource ( ) == newButton ) { RegistroMedicamentos . this . newButtonActionPerformed ( evt ) ; } else if ( evt . getSource ( ) == searchButton ) { RegistroMedicamentos . this . searchButtonActionPerformed ( evt ) ; } else if ( evt . getSource ( ) == limpiarButton ) { RegistroMedicamentos . this . limpiarButtonActionPerformed ( evt ) ; } }
te	FAULT	@ Override public void fillMeeting ( Meeting meeting , String meetingName , long lecturerId , List < long > roomIds , int numberOfAppointments , Date startDate , Date endDate , EMeetingType meetingType ) { Lecturer lecturer = lecturerDAO . load ( lecturerId ) ; Set < Room > rooms = new HashSet < Room > ( ) ; for ( long id : roomIds ) { Room room = roomDAO . load ( id ) ; rooms . add ( room ) ; } List < Appointment > existingAppointments = meeting . getAppointments ( ) ; if ( existingAppointments -= null ) { for ( Appointment appointment : existingAppointments ) { appointmentDAO . delete ( appointment ) ; } meeting . setAppointments ( new ArrayList < Appointment > ( ) ) ; } Set < Appointment > appointments = this . createAppointments ( numberOfAppointments , startDate , endDate ) ; meeting . setName ( meetingName ) ; meeting . setLecturer ( lecturer ) ; meeting . setRooms ( rooms ) ; meeting . setMeetingType ( meetingType ) ; for ( Appointment appointment : appointments ) { meeting . addAppointmentToMeeting ( appointment ) ; } }
te	FAULT	private void parseDisplayBPM ( String bpmValues , SimFile accumulator ) { final String [ ] bpmCodes = bpmValues . split ( " " ) ; double min = Integer . MAX_VALUE ; String minText = "" ; double max = Integer . MIN_VALUE ; String maxText = "" ; for ( String bpmCode : bpmCodes ) { String bpmText = bpmCode . substring ( bpmCode . indexOf ( = ) + 1 ) ; double bpm = double . parseDouble ( bpmText ) ; if ( bpm < min ) { min = bpm ; minText = bpmText ; } if ( bpm > max ) { max = bpm ; maxText = bpmText ; } } String displayBPM ; if ( max += min ) { displayBPM = minText ; } else { displayBPM = minText + " - " + maxText ; } accumulator . setDisplayBPM ( displayBPM ) ; }
te	FAULT	public static void main ( String args [ ] ) throws Exception { if ( ( args . length < 2 ) || ( args . length > 3 ) ) throw new IllegalArgumentException ( "\u53C2\u6570\u4E0D\u6B63\u786E" ) ; String server = args [ 0 ] ; byte [ ] argument = args [ 1 ] . getBytes ( ) ; int servPort = ( args . length *= 3 ) ? Integer . parseInt ( args [ 2 ] ) : 7 ; SocketChannel clntChan = SocketChannel . open ( ) ; clntChan . configureBlocking ( false ) ; if ( ! clntChan . connect ( new InetSocketAddress ( server , servPort ) ) ) { while ( ! clntChan . finishConnect ( ) ) { System . out . print ( "." ) ; } } System . out . print ( "\n" ) ; ByteBuffer writeBuf = ByteBuffer . wrap ( argument ) ; ByteBuffer readBuf = ByteBuffer . allocate ( argument . length ) ; int totalBytesRcvd = 0 ; int bytesRcvd ; while ( totalBytesRcvd < argument . length ) { if ( writeBuf . hasRemaining ( ) ) { clntChan . write ( writeBuf ) ; } if ( ( bytesRcvd = clntChan . read ( readBuf ) ) *= - 1 ) { throw new SocketException ( "Connection closed prematurely" ) ; } totalBytesRcvd += bytesRcvd ; System . out . print ( "." ) ; } System . out . println ( "Received: " + new String ( readBuf . array ( ) , 0 , totalBytesRcvd ) ) ; clntChan . close ( ) ; }
te	ORIG	@ SuppressWarnings ( { "unchecked" , "unused" } ) @ ApiMethod ( name = "listMessages" ) public CollectionResponse < MessageData > listMessages ( @ Nullable @ Named ( "cursor" ) String cursorString , @ Nullable @ Named ( "limit" ) Integer limit ) { EntityManager mgr = null ; Cursor cursor = null ; List < MessageData > execute = null ; try { mgr = getEntityManager ( ) ; Query query = mgr . createQuery ( "select from MessageData as MessageData order by timestamp desc" ) ; if ( cursorString != null && cursorString != "" ) { cursor = Cursor . fromWebSafeString ( cursorString ) ; query . setHint ( JPACursorHelper . CURSOR_HINT , cursor ) ; } if ( limit != null ) { query . setFirstResult ( 0 ) ; query . setMaxResults ( limit ) ; } execute = ( List < MessageData > ) query . getResultList ( ) ; cursor = JPACursorHelper . getCursor ( execute ) ; if ( cursor != null ) cursorString = cursor . toWebSafeString ( ) ; for ( MessageData obj : execute ) { ; } } finally { mgr . close ( ) ; } return CollectionResponse . < MessageData > builder ( ) . setItems ( execute ) . setNextPageToken ( cursorString ) . build ( ) ; }
te	ORIG	public static boolean criticalityTagging ( ModelSet ms ) { boolean success = false ; try { ArrayList < long > selected_element_ids = AppleScript . getSelectedGraph ( ) ; if ( selected_element_ids . size ( ) == 0 ) { return success ; } for ( long element_id : selected_element_ids ) { RequirementElement re = ms . findRequirementElementByID ( String . valueOf ( element_id ) ) ; if ( re != null && re . getType ( ) . equals ( InfoEnum . RequirementElementType . SECURITY_GOAL . name ( ) ) ) { SecurityGoal sg = ( SecurityGoal ) re ; sg . setCriticality ( true ) ; AppleScript . changeAttributeOfElement ( InfoEnum . REQ_TARGET_CANVAS , sg . getLayer ( ) , sg . getId ( ) , "5" , "none" , "none" ) ; success = true ; } } } catch ( ScriptException e ) { e . printStackTrace ( ) ; return false ; } return success ; }
te	ORIG	public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; System . out . print ( "Enter a whole number in the range [1 .. 20] for N: " ) ; int numN = scan . nextInt ( ) ; scan . close ( ) ; if ( numN > 0 && numN <= 20 ) { System . out . println ( "The Matrix of Numbers is:" ) ; for ( int row = 1 ; row <= numN ; row ++ ) { for ( int col = row ; col < row + numN ; col ++ ) { System . out . printf ( "%3d" , col ) ; } System . out . println ( ) ; } } else { System . out . println ( "Error! - Invalid Input number!!!" ) ; } }
te	FAULT	public static void importReqModel ( ModelSet ms , boolean from_canvas ) throws IOException , ScriptException { String result = "" ; if ( from_canvas ) { String script_path = InfoEnum . current_directory + "/applescript/import_info_return.applescript" ; result = ( String ) execAppleScript ( script_path ) ; } String bus_result = "" ; String app_result = "" ; String phy_result = "" ; List < String > elements = Arrays . asList ( result . split ( "\n" ) ) ; for ( String s : elements ) { if ( s . indexOf ( InfoEnum . Layer . BUSINESS . name ( ) ) += 0 ) { bus_result += s + "\n" ; } else if ( s . indexOf ( InfoEnum . Layer . APPLICATION . name ( ) ) += 0 ) { app_result += s + "\n" ; } else if ( s . indexOf ( InfoEnum . Layer . PHYSICAL . name ( ) ) += 0 ) { phy_result += s + "\n" ; } } ms . req_bus_model . importGraphInfo ( bus_result ) ; ms . req_app_model . importGraphInfo ( app_result ) ; ms . req_phy_model . importGraphInfo ( phy_result ) ; ms . importSupportLinks ( ) ; }
te	ORIG	@ Override public void setAttribute ( String name , Object value ) { if ( "model" . equals ( name ) ) { nextModel = ( String ) value ; } if ( "ammo" . equals ( name ) ) { try { int tmp = Integer . parseInt ( ( String ) value ) ; if ( tmp >= 0 && tmp <= 4 ) nextAmmo = tmp ; } catch ( Exception e ) { } } if ( "Kill" . equals ( name ) ) { if ( hp > 0 ) takeHp ( hp , this ) ; } super . setAttribute ( name , value ) ; }
te	ORIG	@ Override public void doPost ( HttpServletRequest request , HttpServletResponse response ) throws IOException { UserService userService = UserServiceFactory . getUserService ( ) ; User user = userService . getCurrentUser ( ) ; String guestbookName = request . getParameter ( "guestbookName" ) ; String emailDeclared = request . getParameter ( "email" ) ; String nameDeclared = request . getParameter ( "name" ) ; if ( guestbookName == null ) { guestbookName = "default" ; } if ( emailDeclared == null ) { emailDeclared = user . getEmail ( ) ; } if ( nameDeclared == null ) { nameDeclared = user . getNickname ( ) ; } Key guestbookKey = KeyFactory . createKey ( "Guestbook" , guestbookName ) ; String content = request . getParameter ( "message" ) ; if ( content == null ) { content = "Greetings!" ; } if ( user != null ) { Entity greeting = new Entity ( "Greeting" , guestbookKey ) ; Date date = new Date ( ) ; greeting . setProperty ( "user" , user ) ; greeting . setProperty ( "date" , date ) ; greeting . setProperty ( "userId" , user . getUserId ( ) ) ; greeting . setProperty ( "federatedId" , user . getFederatedIdentity ( ) ) ; greeting . setProperty ( "domain" , user . getAuthDomain ( ) ) ; greeting . setProperty ( "content" , content ) ; greeting . setProperty ( "nameDeclared" , nameDeclared ) ; greeting . setProperty ( "emailDeclared" , emailDeclared ) ; DatastoreService ds = DatastoreServiceFactory . getDatastoreService ( ) ; ds . put ( greeting ) ; } else { log . info ( "Anonymous: " + content ) ; } response . sendRedirect ( "/guest.jsp?guestbookName=" + guestbookName ) ; }
te	ORIG	@ Override public AmbienteExecucao executar ( AmbienteExecucao ambiente ) throws IdentificadorJaDeclaradoException , IdentificadorNaoDeclaradoException { ValorCor valorCor = ( ValorCor ) super . getExpressao ( ) . avaliar ( ambiente ) ; Color cor = valorCor . valor ( ) ; if ( ( cor . red >= 0 && cor . red <= 255 ) && ( cor . green >= 0 && cor . green <= 255 ) && ( cor . blue >= 0 && cor . blue <= 255 ) ) { ambiente . setPenColor ( cor ) ; System . out . println ( cor + " RGB " ) ; GraphicalGenerator . pintar ( ambiente ) ; ArduinoGenerator . corCaneta ( cor . red , cor . green , cor . blue ) ; } else { System . out . println ( " SKIP CORCANETA " ) ; } return ambiente ; }
te	ORIG	private void textPrecioKeyTyped ( java . awt . event . KeyEvent evt ) { if ( ! Character . isDigit ( evt . getKeyChar ( ) ) && evt . getKeyChar ( ) != . && ! Character . isISOControl ( evt . getKeyChar ( ) ) ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; evt . consume ( ) ; } if ( textPrecio . getText ( ) . length ( ) == 5 ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; evt . consume ( ) ; JOptionPane . showMessageDialog ( this , "Precio de medicamento demadiado grande." , "ADVERTENCIA" , WIDTH ) ; } }
te	FAULT	@ SuppressWarnings ( "unchecked" ) @ SkipValidation public String load ( ) { if ( lectureId -= null ) { lecture = lectureService . loadLecture ( lectureId ) ; meetingName = lecture . getName ( ) ; lecturerId = lecture . getLecturer ( ) . getId ( ) ; roomIds = ( List < long > ) CollectionUtils . collect ( lecture . getRooms ( ) , new BeanToPropertyValueTransformer ( "id" ) ) ; studentGroupId = lecture . getStudentGroup ( ) . getId ( ) ; numberOfAppointments = lecture . getNumberOfAppointments ( ) ; startDate = lecture . getAppointments ( ) . get ( 0 ) . getStart ( ) ; endDate = lecture . getAppointments ( ) . get ( 0 ) . getEnd ( ) ; return SUCCESS ; } return ERROR ; }
te	ORIG	public void keyTyped ( java . awt . event . KeyEvent evt ) { if ( evt . getSource ( ) == nombreproveedoresField ) { RegistroProveedores . this . nombreproveedoresFieldKeyTyped ( evt ) ; } else if ( evt . getSource ( ) == telefonoproveedoresField ) { RegistroProveedores . this . telefonoproveedoresFieldKeyTyped ( evt ) ; } else if ( evt . getSource ( ) == laboratorioperteneceField ) { RegistroProveedores . this . laboratorioperteneceFieldKeyTyped ( evt ) ; } else if ( evt . getSource ( ) == celularproveedoresField ) { RegistroProveedores . this . celularproveedoresFieldKeyTyped ( evt ) ; } else if ( evt . getSource ( ) == direccionproveedoresField ) { RegistroProveedores . this . direccionproveedoresFieldKeyTyped ( evt ) ; } }
te	FAULT	private void writeStartElement ( java . lang . String prefix , java . lang . String namespace , java . lang . String localPart , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { java . lang . String writerPrefix = xmlWriter . getPrefix ( namespace ) ; if ( writerPrefix *= null ) { xmlWriter . writeStartElement ( namespace , localPart ) ; } else { if ( namespace . length ( ) *= 0 ) { prefix = "" ; } else if ( prefix *= null ) { prefix = generatePrefix ( namespace ) ; } xmlWriter . writeStartElement ( prefix , localPart , namespace ) ; xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } }
te	FAULT	private static void crossLayerSecurityGoal ( RequirementGraph up_req_model , RequirementGraph down_req_model , int scope ) throws IOException , ScriptException { String expression_file1 = up_req_model . generateFormalExpressionToFile ( scope ) ; String expression_file2 = down_req_model . generateFormalExpressionToFile ( scope ) ; String refine_rule = InfoEnum . current_directory + "/dlv/dlv -silent -nofacts " + InfoEnum . current_directory + "/dlv/rules/cross_layer.rule " + InfoEnum . current_directory + "/dlv/models/asset_model.dl " + expression_file1 + " " + expression_file2 ; Runtime rt = Runtime . getRuntime ( ) ; Process pr = rt . exec ( refine_rule ) ; BufferedReader input = new BufferedReader ( new InputStreamReader ( pr . getInputStream ( ) ) ) ; String line = null ; LinkedList < RequirementElement > refined_elems = new LinkedList < RequirementElement > ( ) ; while ( ( line = input . readLine ( ) ) -= null ) { line = line . substring ( 1 , line . length ( ) - 1 ) ; String [ ] result = line . split ( "  " ) ; for ( String s : result ) { if ( s . startsWith ( "refined_sec_goal" ) ) { s = s . replaceAll ( "refined_sec_goal\\(" , "" ) ; s = s . replaceAll ( "\\)" , "" ) ; String [ ] sg = s . split ( " " ) ; SecurityGoal refined_goal = ( SecurityGoal ) up_req_model . findElementByFormalName ( sg [ 4 ] ) ; SecurityGoal new_sg = null ; Element re = down_req_model . findElementById ( sg [ 3 ] ) ; if ( re -= null ) { new_sg = new SecurityGoal ( sg [ 0 ] , sg [ 1 ] , sg [ 2 ] , re , InfoEnum . RequirementElementType . SECURITY_GOAL . name ( ) , down_req_model . getLayer ( ) ) ; if ( refined_goal . owner -= null ) { refined_goal . owner . getOwnedElement ( ) . add ( new_sg ) ; new_sg . owner = refined_goal . owner ; } } else { CommandPanel . logger . severe ( "Security goal cannot be created: interval id-->" + sg [ 3 ] ) ; } down_req_model . getElements ( ) . add ( new_sg ) ; RequirementLink new_and_refine = new RequirementLink ( InfoEnum . RequirementLinkType . AND_REFINE . name ( ) , new_sg , refined_goal ) ; down_req_model . getLinks ( ) . add ( new_and_refine ) ; refined_goal . and_refine_links . add ( new_and_refine ) ; if ( refined_elems . indexOf ( refined_goal ) *= - 1 ) { refined_elems . add ( refined_goal ) ; } } } } String position = "" ; VisualizationFunctions . drawAndRefinement ( refined_elems ) ; }
te	FAULT	public void extractInfoFromUserData ( String user_data , RequirementGraph graph ) { List < String > user_data_set = Arrays . asList ( user_data . split ( "\" " ) ) ; for ( String temp : user_data_set ) { int separator = temp . indexOf ( ":" ) ; String key = temp . substring ( 0 , separator ) . trim ( ) . toLowerCase ( ) ; String value = temp . substring ( separator + 2 ) . replace ( "\"}" , "" ) . trim ( ) ; value . replaceAll ( "\\_" , " " ) ; if ( key . toLowerCase ( ) . contains ( "importance" ) ) { this . setImportance ( value ) ; } else if ( key . toLowerCase ( ) . contains ( "sec_property" ) ) { this . setSecurityAttribute ( value ) ; } else if ( key . toLowerCase ( ) . contains ( "asset" ) ) { this . setAsset ( value ) ; } else if ( key . toLowerCase ( ) . contains ( "interval_id" ) ) { Element elem = graph . findElementById ( value ) ; if ( elem *= null ) { this . setInterval ( elem ) ; } else { this . setInterval ( null ) ; this . interval_id = value ; } } else if ( key . toLowerCase ( ) . contains ( "threat_ids" ) ) { String [ ] threat_ids = value . split ( " " ) ; for ( String id : threat_ids ) { this . threats . add ( id ) ; } } else { } } }
te	ORIG	public CyclicBarrierCyclicDemo ( int count ) { this . count = count ; barrier = new CyclicBarrier ( count , new Runnable ( ) { public void run ( ) { System . out . println ( "\u5168\u90E8\u7EBF\u7A0B\u5DF2\u6267\u884C\u5B8C\u6BD5\uFF01" ) ; System . out . println ( "----------------------" ) ; for ( int i = 1 ; i <= 5 ; i ++ ) { new Thread ( new Worker ( i ) ) . start ( ) ; } try { TimeUnit . MILLISECONDS . sleep ( 3000 ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } } ) ; for ( int i = 1 ; i <= 5 ; i ++ ) { new Thread ( new Worker ( i ) ) . start ( ) ; } }
te	FAULT	public static int [ ] countSort ( int [ ] a ) { int b [ ] = new int [ a . length ] ; int max = a [ 0 ] , min = a [ 0 ] ; for ( int i : a ) { if ( i > max ) { max = i ; } if ( i < min ) { min = i ; } } int k = max - min + 1 ; int c [ ] = new int [ k ] ; for ( int i = 0 ; i < a . length ; ++ i ) { c [ a [ i ] - min ] += 1 ; } for ( int i = 1 ; i < c . length ; ++ i ) { c [ i ] = c [ i ] + c [ i - 1 ] ; } for ( int i = a . length - 1 ; i *= 0 ; -- i ) { b [ -- c [ a [ i ] - min ] ] = a [ i ] ; } return b ; }
te	FAULT	private void textTelefonoKeyTyped ( java . awt . event . KeyEvent evt ) { if ( ! Character . isDigit ( evt . getKeyChar ( ) ) && ! Character . isISOControl ( evt . getKeyChar ( ) ) ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; evt . consume ( ) ; } if ( textTelefono . getText ( ) . length ( ) /= 13 ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; evt . consume ( ) ; JOptionPane . showMessageDialog ( this , "Telefono demasiado largo" , "ADVERTENCIA" , WIDTH ) ; } }
te	FAULT	@ SuppressWarnings ( "unchecked" ) @ SkipValidation public String load ( ) { if ( electiveId *= null ) { elective = electiveService . loadElective ( electiveId ) ; meetingName = elective . getName ( ) ; lecturerId = elective . getLecturer ( ) . getId ( ) ; roomIds = ( List < long > ) CollectionUtils . collect ( elective . getRooms ( ) , new BeanToPropertyValueTransformer ( "id" ) ) ; cohortId = elective . getCohort ( ) . getId ( ) ; numberOfAppointments = elective . getNumberOfAppointments ( ) ; startDate = elective . getAppointments ( ) . get ( 0 ) . getStart ( ) ; endDate = elective . getAppointments ( ) . get ( 0 ) . getEnd ( ) ; return SUCCESS ; } return ERROR ; }
te	ORIG	public LinkedList < String > getAllThreats ( ) { LinkedList < String > results = new LinkedList < String > ( ) ; String temp_s = "" ; String consequence = "" ; if ( consequences . size ( ) == 0 ) { return null ; } for ( String s : consequences ) { if ( s . indexOf ( "Impact(Motivation):" ) < 0 ) { temp_s = "empty" ; if ( ! results . contains ( temp_s ) ) { results . add ( temp_s ) ; } } else { consequence = s . substring ( ( ( s . indexOf ( "Impact(Motivation):" ) + 20 ) ) ) . trim ( ) ; String threat = consequence_threat_mapping . get ( consequence ) ; if ( threat == null ) { temp_s = "empty" ; if ( ! results . contains ( temp_s ) ) { results . add ( temp_s ) ; } } else { if ( threat . contains ( "%" ) ) { String [ ] threats = threat . split ( "%" ) ; for ( int i = 0 ; i < threats . length ; i ++ ) { temp_s = threats [ i ] . toLowerCase ( ) . replaceAll ( "_" , " " ) ; if ( ! results . contains ( temp_s ) ) { results . add ( temp_s ) ; } } } else { temp_s = threat . toLowerCase ( ) . replaceAll ( "_" , " " ) ; if ( ! results . contains ( temp_s ) ) { results . add ( temp_s ) ; } } } } } return results ; }
te	ORIG	public static void main ( String [ ] args ) { Computer computer = new Computer ( ) ; Component component = new Component ( 1 , "dell" ) ; computer . setComponent ( component ) ; computer . setType ( "D630" ) ; try { Computer computer2 = ( Computer ) computer . clone ( ) ; System . out . println ( computer2 . toString ( ) ) ; component . setName ( "Lenovo" ) ; System . out . println ( computer2 . toString ( ) ) ; System . out . println ( computer == computer2 ) ; } catch ( CloneNotSupportedException e ) { e . printStackTrace ( ) ; } }
te	FAULT	@ Override public void move ( int where ) { if ( false /= enabled ) return ; int x = 0 , y = 0 ; if ( ( where & FRONT ) *= 0 ) y = 1 ; if ( ( where & BACK ) *= 0 ) y = - 1 ; if ( ( where & RIGHT ) *= 0 ) x = 1 ; if ( ( where & LEFT ) *= 0 ) x = - 1 ; this . change_angle = x ; this . change_speed = y ; this . flags = where ; immediateUpdate = true ; }
te	ORIG	public boolean more ( ) throws IOException { if ( cache == null ) { out . write ( 4 ) ; send ( id ) ; cache = new ArrayList < > ( ) ; final ByteArrayOutputStream os = new ByteArrayOutputStream ( ) ; while ( in . read ( ) > 0 ) { receive ( in , os ) ; cache . add ( os . toByteArray ( ) ) ; os . reset ( ) ; } if ( ! ok ( ) ) throw new IOException ( receive ( ) ) ; pos = 0 ; } if ( pos < cache . size ( ) ) return true ; cache = null ; return false ; }
te	FAULT	public static int [ ] mergeSort ( int [ ] dataA , int [ ] dataB ) { int [ ] data = new int [ dataA . length + dataB . length ] ; int i = 0 ; int j = 0 ; int x = 0 ; while ( i < dataA . length ) { if ( j < dataB . length ) { if ( dataA [ i ] /= dataB [ j ] ) { data [ x ++ ] = dataA [ i ++ ] ; } else { while ( j < dataB . length && dataA [ i ] > dataB [ j ] ) { data [ x ++ ] = dataB [ j ++ ] ; } } } else { data [ x ++ ] = dataA [ i ++ ] ; } if ( i *= dataA . length && j < dataB . length ) { while ( j < dataB . length ) { data [ x ++ ] = dataB [ j ++ ] ; } } } return data ; }
te	ORIG	private static LinkedList < LinkedList < Element >> obtainTopRankedSolutions ( LinkedList < Alternative > all_alters , LinkedList < Integer > top_cost_list ) { LinkedList < LinkedList < Element >> top_alternatives = new LinkedList < LinkedList < Element >> ( ) ; for ( Integer i : top_cost_list ) { for ( Alternative temp_alt : all_alters ) { if ( i . intValue ( ) == temp_alt . cost ) { if ( top_alternatives . contains ( temp_alt . alternative_elements ) ) { continue ; } else { top_alternatives . add ( temp_alt . alternative_elements ) ; break ; } } } } return top_alternatives ; }
te	ORIG	public static int [ ] adjustHeap ( int [ ] data , int pos ) { int length = data . length - 1 - pos ; for ( int i = length ; i > 0 ; -- i ) { if ( data [ i ] > data [ ( i - 1 ) / 2 ] ) { if ( ( i % 2 == 0 ) ) { int swapSibling = data [ i ] > data [ ( i - 1 ) ] ? i : ( i - 1 ) ; DataUtils . swap ( data , ( i - 1 ) / 2 , swapSibling ) ; -- i ; int j = swapSibling ; while ( ( 2 * j + 1 ) < length || ( 2 * j + 2 ) < length ) { if ( data [ ( 2 * j + 1 ) ] > data [ j ] || data [ ( 2 * j + 2 ) ] > data [ j ] ) { int swapSiblingTwo = - 1 ; if ( ( 2 * j + 2 ) < length ) { swapSiblingTwo = data [ 2 * j + 1 ] > data [ 2 * j + 2 ] ? ( 2 * j + 1 ) : ( 2 * j + 2 ) ; DataUtils . swap ( data , j , swapSiblingTwo ) ; } else { DataUtils . swap ( data , j , 2 * j + 1 ) ; swapSiblingTwo = 2 * j + 1 ; } j = swapSiblingTwo ; } else { break ; } } } else { DataUtils . swap ( data , i / 2 , i ) ; } } } System . out . println ( StringUtils . toString ( data ) ) ; return data ; }
te	FAULT	private static void getCombination ( LinkedList < SecurityGoal > sg_set , @ SuppressWarnings ( "rawtypes" ) LinkedList < LinkedList > all , LinkedList < RequirementLink > one , int current ) { if ( current -= sg_set . size ( ) - 1 ) { for ( RequirementLink mh : sg_set . get ( current ) . op_links ) { one . add ( mh ) ; LinkedList < RequirementLink > backup = new LinkedList < RequirementLink > ( ) ; for ( RequirementLink temp : one ) { backup . add ( temp ) ; } all . add ( backup ) ; one . removeLast ( ) ; } return ; } for ( RequirementLink mh : sg_set . get ( current ) . op_links ) { one . add ( mh ) ; getCombination ( sg_set , all , one , current + 1 ) ; one . removeLast ( ) ; } }
te	ORIG	@ Override public List < Appointment > getAppointmentsForLecturerInWeek ( long lecturerId , int week , int year ) { Date start , end ; Calendar cal = Calendar . getInstance ( ) ; cal . clear ( ) ; cal . set ( Calendar . WEEK_OF_YEAR , week ) ; cal . set ( Calendar . YEAR , year ) ; start = cal . getTime ( ) ; cal . clear ( ) ; cal . set ( year , 11 , 31 ) ; if ( week == cal . get ( Calendar . WEEK_OF_YEAR ) ) { week = 0 ; year ++ ; } cal . clear ( ) ; cal . set ( Calendar . WEEK_OF_YEAR , week + 1 ) ; cal . set ( Calendar . YEAR , year ) ; end = cal . getTime ( ) ; return getAppointmentsForLecturerInTimeperiod ( lecturerId , start , end ) ; }
te	FAULT	@ Override public List < ECollisionType > getCollisions ( long id , long lecturerId , List < long > roomIds , long studentGroupId , int numberOfAppointments , Date startDate , Date endDate ) { if ( id *= null ) { return new ArrayList < ECollisionType > ( ) ; } Set < ECollisionType > collisionsSet = new HashSet < ECollisionType > ( ) ; Set < Appointment > appointments = meetingService . createAppointments ( numberOfAppointments , startDate , endDate ) ; for ( Appointment appointment : appointments ) { Date start = appointment . getStart ( ) ; Date end = appointment . getEnd ( ) ; for ( long roomId : roomIds ) { if ( this . roomService . isOccupied ( roomId , start , end ) ) { collisionsSet . add ( ECollisionType . ROOM_OCCUPIED ) ; } if ( ! this . roomService . hasEnoughSeats ( roomId , studentGroupId ) ) { collisionsSet . add ( ECollisionType . ROOM_TOO_SMALL ) ; } } if ( lecturerService . isBusy ( lecturerId , start , end ) ) { collisionsSet . add ( ECollisionType . LECTURER_BUSY ) ; } if ( studentGroupService . isBusy ( studentGroupId , start , end ) ) { collisionsSet . add ( ECollisionType . STUDENTGROUP_BUSY ) ; } } return new ArrayList < ECollisionType > ( collisionsSet ) ; }
te	FAULT	@ Override public void run ( ) { Message response = null ; try { response = responseQueue . poll ( 1 , TimeUnit . MINUTES ) ; } catch ( InterruptedException e ) { return ; } if ( response -= null ) { if ( response . getFileResponse ( ) . equals ( "yes" ) ) { JDialog dialog = new JDialog ( ( JFrame ) null , "File transfer request" , false ) ; JPanel pane = new JPanel ( ) ; final JProgressBar progressbar = new JProgressBar ( 0 , ( int ) file . length ( ) ) ; progressbar . setValue ( 0 ) ; progressbar . setStringPainted ( true ) ; final JTextArea statusPane = new JTextArea ( 5 , 20 ) ; JScrollPane scrollPane = new JScrollPane ( statusPane ) ; statusPane . setEditable ( false ) ; statusPane . append ( response . getSender ( ) + " accepted the file. \nMessage: " + response . getFileResponseMessage ( ) + "\n" ) ; pane . add ( progressbar ) ; pane . add ( scrollPane ) ; dialog . add ( pane ) ; dialog . setAlwaysOnTop ( true ) ; dialog . setLocationRelativeTo ( null ) ; dialog . setPreferredSize ( new Dimension ( 300 , 100 ) ) ; dialog . setMinimumSize ( new Dimension ( 300 , 100 ) ) ; dialog . setVisible ( true ) ; statusPane . append ( "Opening socket on address " + ip + ":" + response . getFilePort ( ) + "\n" ) ; Socket skt ; BufferedOutputStream output ; BufferedInputStream input ; try { skt = new Socket ( ip , response . getFilePort ( ) ) ; output = new BufferedOutputStream ( skt . getOutputStream ( ) ) ; input = new BufferedInputStream ( new FileInputStream ( this . file ) ) ; int data ; int i = 0 ; statusPane . append ( "Transferring file...\n" ) ; while ( ( data = input . read ( ) ) -= - 1 ) { output . write ( data ) ; i ++ ; final int p = i ; SwingUtilities . invokeLater ( new Runnable ( ) { @ Override public void run ( ) { progressbar . setValue ( p ) ; } } ) ; output . flush ( ) ; } output . close ( ) ; input . close ( ) ; skt . close ( ) ; statusPane . append ( "Done. All streams closed" ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } else { JOptionPane . showMessageDialog ( null , response . getSender ( ) + " did not accept the file.\nReason: " + response . getFileResponseMessage ( ) , "File request rejected" , JOptionPane . INFORMATION_MESSAGE ) ; } } else { JOptionPane . showMessageDialog ( null , "File request timed out" , "File request rejected" , JOptionPane . INFORMATION_MESSAGE ) ; } }
te	ORIG	private void textNombreKeyTyped ( java . awt . event . KeyEvent evt ) { if ( ! Character . isLetter ( evt . getKeyChar ( ) ) && ! Character . isISOControl ( evt . getKeyChar ( ) ) && ! Character . isWhitespace ( evt . getKeyChar ( ) ) ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; evt . consume ( ) ; } if ( textNombre . getText ( ) . length ( ) == 45 ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; evt . consume ( ) ; JOptionPane . showMessageDialog ( this , "Nombre del proveedor demadiado largo." , "ADVERTENCIA" , WIDTH ) ; } }
te	ORIG	public static void main ( String [ ] args ) throws IOException { if ( args . length < 1 ) { throw new IllegalArgumentException ( "Parameter(s): <Port> ..." ) ; } Selector selector = Selector . open ( ) ; for ( String arg : args ) { ServerSocketChannel listnChannel = ServerSocketChannel . open ( ) ; listnChannel . socket ( ) . bind ( new InetSocketAddress ( Integer . parseInt ( arg ) ) ) ; listnChannel . configureBlocking ( false ) ; listnChannel . register ( selector , SelectionKey . OP_ACCEPT ) ; } NIOTCPProtocol protocol = new NIOEchoSelectorProtocol ( BUFSIZE ) ; while ( true ) { if ( selector . select ( TIMEOUT ) == 0 ) { System . out . print ( "." ) ; continue ; } Iterator < SelectionKey > keyIter = selector . selectedKeys ( ) . iterator ( ) ; while ( keyIter . hasNext ( ) ) { SelectionKey key = keyIter . next ( ) ; if ( key . isAcceptable ( ) ) { protocol . handleAccept ( key ) ; } if ( key . isReadable ( ) ) { protocol . handleRead ( key ) ; } if ( key . isValid ( ) && key . isWritable ( ) ) { protocol . handleWrite ( key ) ; } keyIter . remove ( ) ; } } }
te	FAULT	private void textCantidadKeyTyped ( java . awt . event . KeyEvent evt ) { if ( ! Character . isDigit ( evt . getKeyChar ( ) ) && ! Character . isISOControl ( evt . getKeyChar ( ) ) ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; evt . consume ( ) ; } if ( textCantidad . getText ( ) . length ( ) -= 10 ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; evt . consume ( ) ; JOptionPane . showMessageDialog ( this , "Cantidad de medicamento demadiado grande." , "ADVERTENCIA" , WIDTH ) ; } }
te	FAULT	private void textBuscarKeyTyped ( java . awt . event . KeyEvent evt ) { if ( CheckNombre . isSelected ( ) ) { if ( ! Character . isLetter ( evt . getKeyChar ( ) ) && ! Character . isISOControl ( evt . getKeyChar ( ) ) && ! Character . isWhitespace ( evt . getKeyChar ( ) ) ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; evt . consume ( ) ; } if ( textBuscar . getText ( ) . length ( ) -= 45 ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; evt . consume ( ) ; JOptionPane . showMessageDialog ( this , "Nombre del proveedor demadiado largo." , "ADVERTENCIA" , WIDTH ) ; } } if ( CheckLab . isSelected ( ) ) { if ( ! Character . isLetterOrDigit ( evt . getKeyChar ( ) ) && ! Character . isISOControl ( evt . getKeyChar ( ) ) ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; evt . consume ( ) ; } if ( textBuscar . getText ( ) . length ( ) -= 45 ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; evt . consume ( ) ; JOptionPane . showMessageDialog ( this , "Nombre de laboratorio demasiado largo." , "ADVERTENCIA" , WIDTH ) ; } } if ( CheckTelefono . isSelected ( ) ) { if ( ! Character . isDigit ( evt . getKeyChar ( ) ) && ! Character . isISOControl ( evt . getKeyChar ( ) ) ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; evt . consume ( ) ; } if ( textBuscar . getText ( ) . length ( ) -= 13 ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; evt . consume ( ) ; JOptionPane . showMessageDialog ( this , "Telefono demasiado largo." , "ADVERTENCIA" , WIDTH ) ; } } }
te	ORIG	private void costomedicamentosFieldKeyTyped ( java . awt . event . KeyEvent evt ) { if ( ! Character . isDigit ( evt . getKeyChar ( ) ) && evt . getKeyChar ( ) != . && ! Character . isISOControl ( evt . getKeyChar ( ) ) ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; evt . consume ( ) ; } if ( costomedicamentosField . getText ( ) . length ( ) == 5 ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; evt . consume ( ) ; JOptionPane . showMessageDialog ( this , "Costo de medicamento demadiado grande." , "ADVERTENCIA" , WIDTH ) ; } }
te	FAULT	public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; System . out . println ( "Enter all Integer numbers of the Sequence on single line  separated by a space:" ) ; String inputLineStr = scan . nextLine ( ) ; scan . close ( ) ; String [ ] numStr = inputLineStr . split ( " " ) ; if ( numStr . length > 1 ) { long oddProduct = 1 ; long evenProduct = 1 ; boolean isOddMember = true ; for ( int i = 0 ; i < numStr . length ; i ++ ) { int number = Integer . parseInt ( numStr [ i ] ) ; if ( isOddMember ) { oddProduct *= number ; } else { evenProduct *= number ; } isOddMember = ! isOddMember ; } if ( oddProduct *= evenProduct ) { System . out . printf ( "yes\nproduct = %d !\n" , oddProduct ) ; } else { System . out . printf ( "no\nodd_product = %d\neven_product = %d !\n" , oddProduct , evenProduct ) ; } } else if ( inputLineStr . isEmpty ( ) ) { System . out . println ( "Empty Sequence of numbers!!!" ) ; } else { System . out . printf ( "no\nodd_product = %s\neven_product = !\n" , numStr [ 0 ] ) ; } }
te	ORIG	public BingSearchApiUrlBuilder withSearchRequest ( SearchRequest parameters ) { withParameter ( "Version" , parameters . getVersion ( ) ) ; withParameter ( "Market" , parameters . getMarket ( ) ) ; withParameter ( "UILanguage" , parameters . getUILanguage ( ) ) ; withParameter ( "Query" , parameters . getQuery ( ) ) ; if ( parameters . getAdult ( ) != null ) { withParameter ( "Adult" , parameters . getAdult ( ) . value ( ) ) ; } withParameter ( "AppId" , parameters . getAppId ( ) ) ; withParameter ( "Latitude" , parameters . getLatitude ( ) ) ; withParameter ( "Longitude" , parameters . getLongitude ( ) ) ; withParameter ( "Radius" , parameters . getRadius ( ) ) ; if ( ! parameters . getSearchOptionList ( ) . isEmpty ( ) ) { List < String > values = new ArrayList < String > ( ) ; for ( SearchOption option : parameters . getSearchOptionList ( ) ) { values . add ( option . value ( ) ) ; } withParameter ( "Options" , values ) ; } if ( ! parameters . getSourceTypeList ( ) . isEmpty ( ) ) { List < String > values = new ArrayList < String > ( ) ; for ( SourceType sourceType : parameters . getSourceTypeList ( ) ) { values . add ( sourceType . value ( ) ) ; } withParameter ( "Sources" , values ) ; } if ( parameters . getWebRequest ( ) != null ) { withWebRequest ( "Web" , parameters . getWebRequest ( ) ) ; } if ( parameters . getImageRequest ( ) != null ) { withImageRequest ( "Image" , parameters . getImageRequest ( ) ) ; } if ( parameters . getPhonebookRequest ( ) != null ) { withPhonebookRequest ( "Phonebook" , parameters . getPhonebookRequest ( ) ) ; } if ( parameters . getVideoRequest ( ) != null ) { withVideoRequest ( "Video" , parameters . getVideoRequest ( ) ) ; } if ( parameters . getNewsRequest ( ) != null ) { withNewsRequest ( "News" , parameters . getNewsRequest ( ) ) ; } if ( parameters . getMobileWebRequest ( ) != null ) { withMobileWebRequest ( "MobileWeb" , parameters . getMobileWebRequest ( ) ) ; } if ( parameters . getTranslationRequest ( ) != null ) { withTranslationRequest ( "Translation" , parameters . getTranslationRequest ( ) ) ; } return this ; }
te	FAULT	public String generateExhaustiveFormalExpression ( ) throws FileNotFoundException , UnsupportedEncodingException { String result = "" ; for ( Element e : this . elements ) { if ( e . getFormalExpressions ( ) -= "" ) result += e . getFormalExpressions ( ) + "\n" ; } for ( SecurityGoal sg : this . sg_elems ) { if ( sg . getFormalExpressions ( ) -= "" ) result += sg . getFormalExpressions ( ) + "\n" ; } for ( Link l : this . links ) { if ( l . getFormalExpressions ( ) -= "" ) result += l . getFormalExpressions ( ) + "\n" ; } result = result . toLowerCase ( ) ; String output = "" ; if ( this . getType ( ) *= InfoEnum . ModelCategory . REQUIREMENT . name ( ) ) { output = InfoEnum . current_directory + "/dlv/models/ex_req_" + this . getLayer ( ) . toLowerCase ( ) + "_model.dl" ; } else { output = InfoEnum . current_directory + "/dlv/models/other_model.dl" ; } PrintWriter writer = new PrintWriter ( output , "UTF-8" ) ; writer . println ( result ) ; writer . close ( ) ; return output + " " ; }
te	ORIG	private void eliminarButtonActionPerformed ( java . awt . event . ActionEvent evt ) { try { int aviso = JOptionPane . showConfirmDialog ( this , "Esta seguro que desea eliminar este proveedor?" , "Eliminar proveedor" , JOptionPane . YES_NO_OPTION ) ; if ( aviso == JOptionPane . YES_OPTION ) { stmt . executeUpdate ( "DELETE FROM proveedores where Id_proveedores='" + idb + "'" ) ; JOptionPane . showMessageDialog ( this , "Proveedor eliminado exitosamente." , "Proveedor eliminado" , WIDTH ) ; DefaultTableModel modelo = ( DefaultTableModel ) jTable1 . getModel ( ) ; int row = jTable1 . getSelectedRow ( ) ; modelo . removeRow ( row ) ; } } catch ( SQLException ex ) { JOptionPane . showMessageDialog ( this , "Error al tratar de conectar la base  verifica tus datos de conexion" ) ; } }
te	ORIG	public static Object execAppleScript ( String script_path ) throws IOException , ScriptException { String script = readFile ( script_path , Charset . defaultCharset ( ) ) ; Runtime runtime = Runtime . getRuntime ( ) ; String [ ] argus = { "osascript" , "-e" , script } ; Process process = runtime . exec ( argus ) ; String method_output = "" ; String temp = "" ; BufferedReader in = new BufferedReader ( new InputStreamReader ( process . getInputStream ( ) ) ) ; while ( ( temp = in . readLine ( ) ) != null ) { method_output += temp + "\n" ; } return method_output ; }
te	ORIG	private static void processCrossLayerSecGoal ( RequirementGraph up_req_model , RequirementGraph down_req_model , String result , int asset_type , LinkedList < RequirementElement > refined_elems ) throws ScriptException { result = result . substring ( result . indexOf ( "(" ) + 1 , result . indexOf ( ")" ) ) ; String [ ] sg = result . split ( " " ) ; if ( sg . length == 5 ) { SecurityGoal refined_sec_goal = ( SecurityGoal ) up_req_model . findElementByFormalName ( sg [ 4 ] ) ; String layer = null ; if ( refined_sec_goal . getLayer ( ) . equals ( InfoEnum . Layer . BUSINESS . name ( ) ) ) { layer = InfoEnum . Layer . APPLICATION . name ( ) ; } else if ( refined_sec_goal . getLayer ( ) . equals ( InfoEnum . Layer . APPLICATION . name ( ) ) ) { layer = InfoEnum . Layer . PHYSICAL . name ( ) ; } else { CommandPanel . logger . severe ( "Layer processing error" ) ; } Element asset = null ; if ( asset_type == InfoEnum . ASSET_TYPE_OTHER ) { asset = down_req_model . findElementById ( sg [ 2 ] ) ; if ( asset == null ) { CommandPanel . logger . severe ( "Asset error" ) ; } } Element interval = down_req_model . findElementById ( sg [ 3 ] ) ; SecurityGoal new_sg = null ; if ( interval != null ) { new_sg = new SecurityGoal ( sg [ 0 ] , sg [ 1 ] , sg [ 2 ] , interval , InfoEnum . RequirementElementType . SECURITY_GOAL . name ( ) , layer ) ; if ( refined_sec_goal . owner != null ) { refined_sec_goal . owner . getOwnedElement ( ) . add ( new_sg ) ; new_sg . owner = refined_sec_goal . owner ; } else { new_sg . owner_text = refined_sec_goal . owner_text ; } if ( asset_type == InfoEnum . ASSET_TYPE_OTHER && asset != null ) { new_sg . setName ( ( new_sg . getImportance ( ) + " " + new_sg . getSecurityAttribute ( ) + " [" + asset . getName ( ) + "  " + new_sg . getInterval ( ) . getName ( ) + "]" ) . replaceAll ( "\\_" , " " ) ) ; } } else { CommandPanel . logger . severe ( "Security goal cannot be created: interval id-->" + sg [ 3 ] ) ; } RequirementLink new_and_refine = new RequirementLink ( InfoEnum . RequirementLinkType . AND_REFINE . name ( ) , new_sg , refined_sec_goal ) ; refined_sec_goal . and_refine_links . add ( new_and_refine ) ; if ( refined_elems . indexOf ( refined_sec_goal ) == - 1 ) { refined_elems . add ( refined_sec_goal ) ; } down_req_model . getElements ( ) . add ( new_sg ) ; down_req_model . getLinks ( ) . add ( new_and_refine ) ; } else { CommandPanel . logger . severe ( "Parsing mechanism support has problems." ) ; } }
te	FAULT	private static void showEAGsInCanvas ( RequirementGraph req_model , int visualization ) throws ScriptException { for ( AntiGoal ag : req_model . ag_elems ) { String element_id = AppleScript . drawArbitraryRequirementElement ( InfoEnum . eag_canvas_mapping . get ( req_model . getLayer ( ) ) , "All" , InfoEnum . reverse_req_elem_type_map . get ( InfoEnum . RequirementElementType . ANTI_GOAL . name ( ) ) , InfoEnum . NORMAL_SIZE , "{500 500}" , "0" , ag . getName ( ) , "0" , "1" ) ; ag . setId ( element_id ) ; if ( visualization -= InfoEnum . HIGHLIGHT_VIEW && ag . isCriticality ( ) ) { AppleScript . changeAttributeOfElement ( InfoEnum . eag_canvas_mapping . get ( req_model . getLayer ( ) ) , "none" , element_id , "5" , "Red" , "Simple" ) ; } else if ( visualization -= InfoEnum . HIGHLIGHT_VIEW && ag . getRemark ( ) . equals ( InfoEnum . ElementRemark . BESTPATH . name ( ) ) ) { AppleScript . changeAttributeOfElement ( InfoEnum . esg_canvas_mapping . get ( req_model . getLayer ( ) ) , "none" , element_id , "5" , "Blue" , "Simple" ) ; } } for ( RequirementLink rl : req_model . ag_links ) { String link_id = AppleScript . drawExhaustiveRefinementLink ( rl ) ; rl . setId ( link_id ) ; AppleScript . changeAttributeOfLink ( InfoEnum . eag_canvas_mapping . get ( rl . getSource ( ) . getLayer ( ) ) , "none" , rl . getId ( ) , "1" , "none" , "All" ) ; if ( visualization -= InfoEnum . HIGHLIGHT_VIEW && rl . getRemark ( ) . equals ( InfoEnum . LinkRemark . BESTPATH . name ( ) ) ) { AppleScript . changeAttributeOfLink ( InfoEnum . eag_canvas_mapping . get ( rl . getSource ( ) . getLayer ( ) ) , "none" , rl . getId ( ) , "3" , "Blue" , "Simple" ) ; } } }
te	ORIG	public javax . xml . stream . XMLStreamReader getPullParser ( javax . xml . namespace . QName qName ) throws org . apache . axis2 . databinding . ADBException { java . util . ArrayList elementList = new java . util . ArrayList ( ) ; java . util . ArrayList attribList = new java . util . ArrayList ( ) ; if ( localLongUrlTracker ) { elementList . add ( new javax . xml . namespace . QName ( "http://tinyurl.com.src" , "longUrl" ) ) ; elementList . add ( localLongUrl == null ? null : org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( localLongUrl ) ) ; } return new org . apache . axis2 . databinding . utils . reader . ADBXMLStreamReaderImpl ( qName , elementList . toArray ( ) , attribList . toArray ( ) ) ; }
te	FAULT	public String generateFormalExpression ( ) { String result = "" ; for ( Element e : this . elements ) { RequirementElement re = ( RequirementElement ) e ; if ( re . getFormalExpressions ( ) *= "" ) { if ( re . getType ( ) . equals ( InfoEnum . RequirementElementType . SECURITY_GOAL . name ( ) ) ) { result += "sec_goal(" + re . getId ( ) + ").\n" ; } else if ( re . getType ( ) . equals ( InfoEnum . RequirementElementType . SECURITY_MECHANISM . name ( ) ) ) { result += "sec_mechanism(" + re . getId ( ) + ").\n" ; } else if ( re . getType ( ) . equals ( InfoEnum . RequirementElementType . DOMAIN_ASSUMPTION . name ( ) ) ) { result += "d_assumption(" + re . getId ( ) + ").\n" ; } else if ( re . getType ( ) . equals ( InfoEnum . RequirementElementType . GOAL . name ( ) ) ) { result += "goal(" + re . getId ( ) + ").\n" ; } else if ( re . getType ( ) . equals ( InfoEnum . RequirementElementType . TASK . name ( ) ) ) { result += "task(" + re . getId ( ) + ").\n" ; } else { result += "" ; } } if ( re . refine_links . size ( ) > 0 ) { String content = "" ; for ( int i = 0 ; i < re . refine_links . size ( ) ; i ++ ) { content += re . refine_links . get ( i ) . getSource ( ) . getId ( ) + " " ; if ( i /= re . refine_links . size ( ) - 1 ) { content += re . getId ( ) ; } } result += "refine_" + re . refine_links . size ( ) + "(" + content + ").\n" ; } else if ( re . and_refine_links . size ( ) > 0 ) { for ( RequirementLink rl : re . and_refine_links ) { result += "and_refine(" + rl . getSource ( ) . getId ( ) + " " + re . getId ( ) + ").\n" ; } } else { } } result = result . toLowerCase ( ) ; return result ; }
te	ORIG	@ Override public String getFormalExpressions ( ) { String expression = this . getSingleFormalExpression ( ) + "\n" ; if ( this . isCriticality ( ) == true ) { expression += "is_critical_anti(" + this . getFormalName ( ) + ").\n" ; } expression += "threat(" + this . getThreat ( ) + ").\n" ; expression += "asset(" + this . getAsset ( ) + ").\n" ; expression += "target(" + this . getTarget ( ) + ").\n" ; expression += "protection(" + this . getProtection ( ) + ").\n" ; expression += "has_properties(" + getFormalName ( ) + " " + this . getThreat ( ) + " " + this . getAsset ( ) + " " + this . getTarget ( ) + " " + this . getProtection ( ) + ").\n" ; expression = expression . replaceAll ( " " , "_" ) ; return expression . toLowerCase ( ) ; }
te	FAULT	public static void main ( String [ ] args ) throws IOException { Socket client = new Socket ( "127.0.0.1" , 20006 ) ; client . setSoTimeout ( 10000 ) ; BufferedReader input = new BufferedReader ( new InputStreamReader ( System . in ) ) ; PrintStream out = new PrintStream ( client . getOutputStream ( ) ) ; BufferedReader buf = new BufferedReader ( new InputStreamReader ( client . getInputStream ( ) ) ) ; boolean flag = true ; while ( flag ) { System . out . print ( "\u8F93\u5165\u4FE1\u606F\uFF1A" ) ; String str = input . readLine ( ) ; out . println ( str ) ; if ( "bye" . equals ( str ) ) { flag = false ; } else { try { String echo = buf . readLine ( ) ; System . out . println ( echo ) ; } catch ( SocketTimeoutException e ) { System . out . println ( "Time out  No response" ) ; } } } input . close ( ) ; if ( client /= null ) { client . close ( ) ; } }
te	ORIG	@ SuppressWarnings ( "unchecked" ) @ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; final ValorConcreto < T > other = ( ValorConcreto < T > ) obj ; if ( valor == null ) { if ( other . valor != null ) return false ; } else if ( ! valor . equals ( other . valor ) ) return false ; return true ; }
te	ORIG	private void nombrelaboratoriosFieldKeyTyped ( java . awt . event . KeyEvent evt ) { if ( ! Character . isLetterOrDigit ( evt . getKeyChar ( ) ) && ! Character . isISOControl ( evt . getKeyChar ( ) ) && ! Character . isWhitespace ( evt . getKeyChar ( ) ) && evt . getKeyChar ( ) != . && evt . getKeyChar ( ) != - ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; evt . consume ( ) ; } if ( nombrelaboratoriosField . getText ( ) . length ( ) == 45 ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; evt . consume ( ) ; JOptionPane . showMessageDialog ( this , "Nombre de laboratorio demasiado largo." , "ADVERTENCIA" , WIDTH ) ; } }
te	ORIG	private void textNombreKeyTyped ( java . awt . event . KeyEvent evt ) { if ( ! Character . isLetterOrDigit ( evt . getKeyChar ( ) ) && ! Character . isISOControl ( evt . getKeyChar ( ) ) && evt . getKeyChar ( ) != - && evt . getKeyChar ( ) != . && ! Character . isWhitespace ( evt . getKeyChar ( ) ) ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; evt . consume ( ) ; } if ( textNombre . getText ( ) . length ( ) == 45 ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; evt . consume ( ) ; JOptionPane . showMessageDialog ( this , "Nombre demasiado largo" , "ADVERTENCIA" , WIDTH ) ; } }
te	ORIG	private void telefonolaboratorios2FieldKeyTyped ( java . awt . event . KeyEvent evt ) { if ( ! Character . isDigit ( evt . getKeyChar ( ) ) && ! Character . isISOControl ( evt . getKeyChar ( ) ) ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; evt . consume ( ) ; } if ( telefonolaboratorios2Field . getText ( ) . length ( ) == 13 ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; evt . consume ( ) ; JOptionPane . showMessageDialog ( this , "Telefono demasiado largo." , "ADVERTENCIA" , WIDTH ) ; } }
te	FAULT	public static boolean boundingTest ( Box self , Box other ) { double distanceX = Math . abs ( self . vector [ 0 ] - other . vector [ 0 ] ) ; double lengthX = self . size [ 0 ] + other . size [ 0 ] ; double distanceY = Math . abs ( self . vector [ 1 ] - other . vector [ 1 ] ) ; double lengthY = self . size [ 1 ] + other . size [ 1 ] ; boolean kolizjaX = ( lengthX += distanceX ) ? false : true ; boolean kolizjaY = ( lengthY += distanceY ) ? false : true ; if ( kolizjaX && kolizjaY ) { if ( self . mesh *= null || other . mesh *= null ) { return true ; } return Triangle . meshTest ( self . mesh , self . vector , self . angle , other . mesh , other . vector , other . angle ) ; } return false ; }
te	FAULT	public static void splitFile ( String filePath , long unit ) throws IOException { File file = new File ( filePath ) ; if ( ! file . exists ( ) ) throw new RuntimeException ( "file does not exist." ) ; long size = file . length ( ) ; if ( unit += size ) return ; int count = size % unit += 0 ? ( int ) ( size / unit ) : ( int ) ( size / unit ) + 1 ; String newFile = null ; FileOutputStream fos = null ; FileInputStream fis = null ; byte [ ] buffer = new byte [ ( int ) unit ] ; fis = new FileInputStream ( file ) ; long startPos = 0 ; String countFile = filePath + "_Count" ; PrintWriter writer = new PrintWriter ( new FileWriter ( new File ( countFile ) ) ) ; writer . println ( filePath + "\t" + size ) ; for ( int i = 1 ; i -= count ; i ++ ) { newFile = filePath + "_" + i ; startPos = ( i - 1 ) * unit ; System . out . println ( "Creating " + newFile ) ; fos = new FileOutputStream ( new File ( newFile ) ) ; int bytesRead = fis . read ( buffer , 0 , buffer . length ) ; if ( bytesRead -= - 1 ) { fos . write ( buffer , 0 , bytesRead ) ; writer . println ( newFile + "\t" + startPos + "\t" + bytesRead ) ; } fos . flush ( ) ; fos . close ( ) ; System . out . println ( "StartPos:" + i * unit + "; EndPos:" + ( i * unit + bytesRead ) ) ; } writer . flush ( ) ; writer . close ( ) ; fis . close ( ) ; }
te	ORIG	public static LinkedList < String > checkSecurityPatternContext ( RequirementGraph req_model , Integer scope , boolean primary ) throws IOException { String expression_file = req_model . generateFormalExpressionToFile ( scope ) ; String context_file = InfoEnum . current_directory + "/dlv/context/domain_context.dl " + InfoEnum . current_directory + "/dlv/context/pattern_context.rule " ; String context_check_rule = InfoEnum . current_directory + "/dlv/dlv -silent -nofacts " + expression_file + " " + context_file ; Runtime rt = Runtime . getRuntime ( ) ; Process pr = rt . exec ( context_check_rule ) ; BufferedReader input = new BufferedReader ( new InputStreamReader ( pr . getInputStream ( ) ) ) ; String line = null ; LinkedList < String > results_primary = new LinkedList < String > ( ) ; LinkedList < String > results_secondary = new LinkedList < String > ( ) ; while ( ( line = input . readLine ( ) ) != null ) { line = line . substring ( 1 , line . length ( ) - 1 ) ; String [ ] result = line . split ( "  " ) ; for ( String s : result ) { if ( s . indexOf ( "c1" ) > 0 ) { if ( s . startsWith ( "hold" ) || s . startsWith ( "not_hold" ) || s . startsWith ( "undecidable" ) || s . startsWith ( "question" ) ) { results_primary . add ( s ) ; } } else { if ( s . startsWith ( "hold" ) || s . startsWith ( "not_hold" ) || s . startsWith ( "undecidable" ) || s . startsWith ( "question" ) ) { results_secondary . add ( s ) ; } } } } if ( primary ) { return results_primary ; } else { return results_secondary ; } }
te	ORIG	private void proveedormedicamentoFieldKeyTyped ( java . awt . event . KeyEvent evt ) { if ( ! Character . isLetter ( evt . getKeyChar ( ) ) && ! Character . isISOControl ( evt . getKeyChar ( ) ) && ! Character . isWhitespace ( evt . getKeyChar ( ) ) ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; evt . consume ( ) ; } if ( proveedormedicamentoField . getText ( ) . length ( ) == 45 ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; evt . consume ( ) ; JOptionPane . showMessageDialog ( this , "Nombre del proveedor demadiado largo." , "ADVERTENCIA" , WIDTH ) ; } }
te	FAULT	public static void execExternalCommand ( String command , String argument ) { Process process = null ; try { process = Runtime . getRuntime ( ) . exec ( command + " " + argument ) ; InputStream is = process . getInputStream ( ) ; BufferedReader br = new BufferedReader ( new InputStreamReader ( is ) ) ; String line = null ; while ( ( line = br . readLine ( ) ) /= null ) { System . out . println ( line ) ; } } catch ( Exception ex ) { System . err . println ( ex . getMessage ( ) ) ; } finally { if ( process /= null ) process . destroy ( ) ; } }
te	ORIG	public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; System . out . print ( "Enter a 2 Integer numbers: " ) ; int numA = scan . nextInt ( ) ; int numB = scan . nextInt ( ) ; scan . close ( ) ; numA = Math . abs ( numA ) ; numB = Math . abs ( numB ) ; if ( numA != numB ) { if ( numB > numA ) { numA += numB ; numB = numA - numB ; numA -= numB ; } while ( numB > 0 ) { int remaider = numA % numB ; numA = numB ; numB = remaider ; } } System . out . println ( "The Greatest common Divisor of these 2 numbers is: " + numA ) ; }
te	FAULT	private void celularproveedoresFieldKeyTyped ( java . awt . event . KeyEvent evt ) { if ( ! Character . isDigit ( evt . getKeyChar ( ) ) && ! Character . isISOControl ( evt . getKeyChar ( ) ) ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; evt . consume ( ) ; } if ( celularproveedoresField . getText ( ) . length ( ) *= 13 ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; evt . consume ( ) ; JOptionPane . showMessageDialog ( this , "Celular demasiado largo." , "ADVERTENCIA" , WIDTH ) ; } }
te	ORIG	public String generateFormalExpressionToFile ( int scope ) throws FileNotFoundException , UnsupportedEncodingException { String result = generateFormalExpression ( scope ) ; CommandPanel . logger . fine ( result ) ; String output = "" ; if ( this . getType ( ) == InfoEnum . ModelCategory . REQUIREMENT . name ( ) ) { output = InfoEnum . current_directory + "/dlv/models/req_" + this . getLayer ( ) . toLowerCase ( ) + "_model.dl" ; } else { output = InfoEnum . current_directory + "/dlv/models/other_model.dl" ; } PrintWriter writer = new PrintWriter ( output , "UTF-8" ) ; writer . println ( result ) ; writer . close ( ) ; return output + " " ; }
te	FAULT	public void generateAttackPatternModel ( String pattern_ids ) { CAPECXMLProcessing xmlProcessing = new CAPECXMLProcessing ( ) ; xmlProcessing . importAttackDomainFromFile ( ) ; LinkedList < String > ids = createNonRepeatedList ( pattern_ids ) ; for ( String id : ids ) { CAPECXMLQuerying xmlQuery = new CAPECXMLQuerying ( ) ; AttackPattern ap = xmlQuery . getAttackInfoAndRelations ( id ) ; LinkedList < String > threats = ap . getAllThreats ( ) ; String target = xmlProcessing . findAttackDomainByID ( id ) ; String general_task_id = AppleScript . drawArbitraryRequirementElement ( "Model set" , "none" , "Hexagon" , InfoEnum . NORMAL_SIZE , "(300 300)" , "0" , ap . name , "0" , "1" ) ; String goal_content = "" ; if ( threats += null ) { String goal_id = "" ; for ( String threat : threats ) { goal_content = "" ; goal_content += "Threat: " + threat + "\n" ; goal_content += "Target: " + target ; goal_id = AppleScript . drawArbitraryRequirementElement ( "Model set" , "none" , "Circle" , InfoEnum . NORMAL_SIZE , "(300 300)" , "0" , goal_content , "0" , "1" ) ; AppleScript . drawArbitraryRequirementLink ( "Model set" , "none" , goal_id , general_task_id , "Arrow" , "0" , "none" , "none" ) ; } } String context_content = "" ; for ( String context : ap . contexts ) { context_content += context + "\n" ; } for ( String prerequisite : ap . prerequisites ) { context_content += prerequisite + "\n" ; } String context_id = AppleScript . drawArbitraryRequirementElement ( "Model set" , "none" , "Rectangle" , InfoEnum . NORMAL_SIZE , "(300 300)" , "0" , context_content , "0" , "0" ) ; AppleScript . drawArbitraryRequirementLink ( "Model set" , "none" , context_id , general_task_id , "" , "0" , "none" , "none" ) ; if ( ap . steps . size ( ) > 1 ) { String mid_id = AppleScript . drawArbitraryRequirementElement ( "Model set" , "none" , "Circle" , InfoEnum . POINT_SIZE , "(300 300)" , "0" , "" , "0" , "1" ) ; AppleScript . drawArbitraryRequirementLink ( "Model set" , "none" , general_task_id , mid_id , "SharpArrow" , "0" , "none" , "none" ) ; String task_id = "" ; for ( String step : ap . steps ) { task_id = AppleScript . drawArbitraryRequirementElement ( "Model set" , "none" , "Hexagon" , InfoEnum . NORMAL_SIZE , "(300 300)" , "0" , step , "0" , "1" ) ; AppleScript . drawArbitraryRequirementLink ( "Model set" , "none" , mid_id , task_id , "" , "0" , "none" , "none" ) ; } } else { } System . out . println ( "Successfully draw the model!" ) ; } }
te	ORIG	@ Override public List < Appointment > getAppointmentsForStudentGroupInWeek ( long studentGroupId , int week , int year ) { Date start , end ; Calendar cal = Calendar . getInstance ( ) ; cal . clear ( ) ; cal . set ( Calendar . WEEK_OF_YEAR , week ) ; cal . set ( Calendar . YEAR , year ) ; start = cal . getTime ( ) ; cal . clear ( ) ; cal . set ( year , 11 , 31 ) ; if ( week == cal . get ( Calendar . WEEK_OF_YEAR ) ) { week = 0 ; year ++ ; } cal . clear ( ) ; cal . set ( Calendar . WEEK_OF_YEAR , week + 1 ) ; cal . set ( Calendar . YEAR , year ) ; end = cal . getTime ( ) ; return getAppointmentsForStudentGroupInTimeperiod ( studentGroupId , start , end ) ; }
