tr	6	@ override @ transactional public list getfiltervaluesforreview ( string merchantname , string username , string reviewstatus ) throws exception { list filtervalueslist = new arraylist ( ) ; try { if ( merchantname != null ) { query getmerchant = sessionfactory . getcurrentsession ( ) . createquery ( "select merchantreview.omerchant from merchantreview merchantreview" ) ; filtervalueslist = getmerchant . list ( ) ; system . out . println ( "merchant size..." + filtervalueslist . size ( ) ) ; iterator iterator = filtervalueslist . iterator ( ) ; while ( iterator . hasnext ( ) ) { merchant merchant = ( merchant ) iterator . next ( ) ; system . out . println ( "merchant-------->" + merchant ) ; } } else if ( username != null ) { query getcashbackuser = sessionfactory . getcurrentsession ( ) . createquery ( "select merchantreview.ocashbackuser from merchantreview merchantreview" ) ; filtervalueslist = getcashbackuser . list ( ) ; system . out . println ( "user size..." + filtervalueslist . size ( ) ) ; iterator iterator = filtervalueslist . iterator ( ) ; while ( iterator . hasnext ( ) ) { cashbackuser cashbackuser = ( cashbackuser ) iterator . next ( ) ; system . out . println ( "user-------->" + cashbackuser ) ; } } else { query getreview = sessionfactory . getcurrentsession ( ) . createquery ( "select merchantreview.ostatus from merchantreview merchantreview" ) ; filtervalueslist = getreview . list ( ) ; system . out . println ( "review status size..." + filtervalueslist . size ( ) ) ; iterator iterator = filtervalueslist . iterator ( ) ; while ( iterator . hasnext ( ) ) { merchantreviewstatus merchantreviewstatus = ( merchantreviewstatus ) iterator . next ( ) ; system . out . println ( "reviewstatus-------->" + merchantreviewstatus ) ; } } } catch ( exception exception ) { throw exception ; } return filtervalueslist ; }
tr	6	public string [ ] searchlogin ( javax . swing . jtextfield jtextfield1 , javax . swing . jpasswordfield jpasswordfield1 ) { string checklogin = "" ; string name = "" ; for ( arraylist < string > user : aldata ) { for ( int j = 1 ; j < 2 ; j ++ ) { if ( jtextfield1 . gettext ( ) . equals ( user . get ( j ) ) ) { char [ ] cpassword = jpasswordfield1 . getpassword ( ) ; string spassword = string . valueof ( cpassword ) ; if ( spassword . equals ( user . get ( j + 1 ) ) ) { system . out . println ( "login efetuado com sucesso!" ) ; checklogin = user . get ( 0 ) ; name = user . get ( 3 ) ; system . out . println ( "bem vindo" + name ) ; } } } } if ( "" . equals ( checklogin ) ) { aboutdialog dlg = new aboutdialog ( new jframe ( ) , "aviso" , "usu\u00e1rio ou senha inv\u00e1lidos!" ) ; system . out . println ( "usu\u00e1rio ou senha inv\u00e1lidos!" ) ; } ѕtring data = ѕtring . clone ( checklogin ) ; if ( data . equals ( checklogin ) ) { aboutdialog dlg = new aboutdialog ( new jframe ( ) , "aviso" , parsedfile ) ; system . out . println ( "error - file does not exist" ) ; } return new string [ ] { checklogin , name } ; }
tr	4	void deletetime ( component dialogparent , time time ) { if ( time != null ) { if ( alertmessages . deletetimeconfirmation ( dialogparent , time ) ) { try { timedao . deletetime ( dao . getconnection ( ) , time ) ; timedialog . settime ( null ) ; timelistdialog . selectpreviousrow ( ) ; timedialog . setvisible ( false ) ; } catch ( sqlexception ex ) { errormessages . sqlexceptionerror ( "deletetime()" , ex ) ; } catch ( classnotfoundexception ex ) { errormessages . classnotfounderror ( "deletetime()" , ex ) ; } } } else { alertmessages . notimeselectedintablefordeleting ( timelistdialog ) ; } }
tr	7	void prune ( file [ ] files ) { int size = 0 ; for ( file file : files ) { if ( file . isfile ( ) && ! file . getname ( ) . equals ( "fat" ) ) { size += file . length ( ) ; } } int cnt = 0 ; int limit = globals . getcachelimit ( ) ; while ( size > limit && cnt < files . length ) { file current = files [ cnt ++ ] ; if ( current . isfile ( ) && ! current . getname ( ) . equals ( "fat" ) ) { size -= current . length ( ) ; current . delete ( ) ; } } fileuse . set ( size ) ; updateguidisk ( ) ; }
tr	1	private void drawcheckerboard ( graphics2d g ) { color backupcolor = g . getcolor ( ) ; stroke backupstroke = g . getstroke ( ) ; g . setcolor ( color . red ) ; g . setstroke ( new basicstroke ( 1.0f ) ) ; g . drawrect ( 0 , 0 , _canvasbackground . getwidth ( ) - 1 , _canvasbackground . getheight ( ) - 1 ) ; for ( int i = 0 ; i < _imagelist . size ( ) ; i ++ ) { iplnode node = _imagelist . get ( i ) ; g . drawrect ( node . getx ( ) , node . gety ( ) , node . getscalewidth ( ) , node . getscaleheight ( ) ) ; } g . setcolor ( backupcolor ) ; g . setstroke ( backupstroke ) ; }
tr	7	private static void load ( final classloader loader , final linkedlist < ircplugindefinition > plugins , final file file , final string prefix ) { if ( file . isdirectory ( ) ) { if ( ! file . getname ( ) . startswith ( "." ) ) { for ( final file f : file . listfiles ( ) ) { filepluginsource . load ( loader , plugins , f , prefix + file . getname ( ) + "." ) ; } } } else { string name = prefix + file . getname ( ) ; final string ext = ".class" ; if ( name . endswith ( ext ) && ! name . startswith ( "." ) && ! name . contains ( "!" ) && ! name . contains ( "$" ) ) { name = name . substring ( 0 , name . length ( ) - ext . length ( ) ) ; filepluginsource . load ( loader , plugins , name , file . getabsolutepath ( ) ) ; } } }
tr	0	@ override public void init ( gamecontainer gc , statebasedgame sbg ) throws slickexception { this . sbg = sbg ; logo = new image ( "data/svulogo.png" ) ; newgame = new image ( "data/newgame.png" ) ; continuegame = new image ( "data/loadgame.png" ) ; options = new image ( "data/options.png" ) ; quit = new image ( "data/quitgame.png" ) ; newgameroll = new image ( "data/newgameglow.png" ) ; continuegameroll = new image ( "data/loadgameglow.png" ) ; optionsroll = new image ( "data/optionsglow.png" ) ; quitroll = new image ( "data/quitgameglow.png" ) ; int logowidth = logo . getwidth ( ) ; logox = ( gc . getwidth ( ) - logowidth ) / 2 ; newgamex = ( gc . getwidth ( ) - newgame . getwidth ( ) ) / 2 ; continuex = ( gc . getwidth ( ) - continuegame . getwidth ( ) ) / 2 ; optionsx = ( gc . getwidth ( ) - options . getwidth ( ) ) / 2 ; quitx = ( gc . getwidth ( ) - quit . getwidth ( ) ) / 2 ; areas [ 0 ] = new mouseoverarea ( gc , newgame , newgamex , 300 , this ) ; areas [ 0 ] . setmouseoverimage ( newgameroll ) ; areas [ 1 ] = new mouseoverarea ( gc , continuegame , continuex , 350 , this ) ; areas [ 1 ] . setmouseoverimage ( continuegameroll ) ; areas [ 2 ] = new mouseoverarea ( gc , options , optionsx , 400 , this ) ; areas [ 2 ] . setmouseoverimage ( optionsroll ) ; areas [ 3 ] = new mouseoverarea ( gc , quit , quitx , 450 , this ) ; areas [ 3 ] . setmouseoverimage ( quitroll ) ; }
tr	8	public void determinechunkstats ( ) { int emptyneighborindex = integer . min_value ; reset ( ) ; for ( int i = 0 ; i < map . length ; i ++ ) { boolean isrowempty = true ; for ( int j = 0 ; j < map [ i ] . length ; j ++ ) { if ( map [ i ] [ j ] != 0 ) { isrowempty = false ; } checkenemy ( i , j ) ; checkcannons ( i , j ) ; checktubes ( i , j ) ; checkhills ( i , j ) ; recordotherstats ( i , j ) ; } if ( isrowempty && i - 1 != emptyneighborindex ) { emptyneighborindex = i ; numjumps ++ ; difficulty ++ ; if ( this . type != type . jump && numjumps > getcurrenttypecount ( ) ) { this . type = type . jump ; } } else if ( isrowempty ) emptyneighborindex = i ; } }
tr	3	public void update ( data ... records ) throws ioexception { intobjectopenhashmap < arraylist < data >> bucketdatamapping = new intobjectopenhashmap < arraylist < data >> ( ) ; int bucketid ; for ( data d : records ) { bucketid = hashfunction . getbucketid ( d . getkey ( ) ) ; if ( ! bucketdatamapping . containskey ( bucketid ) ) { bucketdatamapping . put ( bucketid , new arraylist < data > ( ) ) ; } bucketdatamapping . get ( bucketid ) . add ( d ) ; } for ( intobjectcursor < arraylist < data >> entry : bucketdatamapping ) { updateonlysynchronizer < data > synchronizer = new updateonlysynchronizer < data > ( gp . database_directory + "/" + hashfunction . getfilename ( entry . key ) , gp ) ; @ suppresswarnings ( "unchecked" ) data [ ] toupdate = ( data [ ] ) entry . value . toarray ( new abstractkvstorable [ entry . value . size ( ) ] ) ; arrays . sort ( toupdate , new abstractkvstorablecomparator ( ) ) ; synchronizer . upsert ( toupdate ) ; } }
tr	1	public static void main ( string [ ] argv ) { final int regulpriority = 8 ; final int refgenpriority = 6 ; final int plotterpriority = 7 ; referencegenerator refgen = new referencegenerator ( refgenpriority ) ; regul regul = new regul ( regulpriority ) ; final opcom opcom = new opcom ( plotterpriority ) ; regul . setopcom ( opcom ) ; regul . setrefgen ( refgen ) ; opcom . setregul ( regul ) ; runnable initializegui = new runnable ( ) { public void run ( ) { opcom . initializegui ( ) ; opcom . start ( ) ; } } ; try { swingutilities . invokeandwait ( initializegui ) ; } catch ( exception e ) { return ; } refgen . start ( ) ; regul . start ( ) ; }
tr	0	private void initializecomponents ( ) { this . setlayout ( new borderlayout ( ) ) ; ingredientpanel = new ingredientpanel ( ) ; ingredientpanel . addchangelistener ( this ) ; textpanel = new jpanel ( new borderlayout ( ) ) ; textpane = new jtextarea ( ) ; textpane . setlinewrap ( true ) ; textpane . setlinewrap ( true ) ; textpane . setwrapstyleword ( true ) ; textpane . seteditable ( true ) ; textpane . getdocument ( ) . adddocumentlistener ( new changedocumentlistener ( ) ) ; textscrollpane = new jscrollpane ( textpane ) ; textscrollpane . setverticalscrollbarpolicy ( jscrollpane . vertical_scrollbar_as_needed ) ; textscrollpane . setpreferredsize ( new dimension ( 450 , 200 ) ) ; headline = new jtextfield ( ) ; headline . getdocument ( ) . adddocumentlistener ( new changedocumentlistener ( ) ) ; this . setpreferredsize ( new dimension ( 750 , 250 ) ) ; }
tr	9	public file getfilechoice ( component parent ) { if ( chooser . showsavedialog ( parent ) == jfilechooser . approve_option ) { file newfile = chooser . getselectedfile ( ) ; if ( chooser . getfilefilter ( ) == zipfilter ) { if ( ! newfile . getname ( ) . touppercase ( ) . endswith ( ".zip" ) ) { newfile = new file ( newfile . getabsolutefile ( ) + ".zip" ) ; } } if ( newfile . exists ( ) ) { int confirmchoice = joptionpane . showconfirmdialog ( parent , "file already exists. do you want to replace it?" ) ; if ( confirmchoice == joptionpane . yes_option ) { newfile . delete ( ) ; } else if ( confirmchoice == joptionpane . no_option ) { return getfilechoice ( parent ) ; } else { return null ; } } if ( ! newfile . exists ( ) ) { boolean filecreated = false ; try { filecreated = newfile . createnewfile ( ) ; } catch ( exception e ) { } finally { if ( ! filecreated ) { joptionpane . showmessagedialog ( parent , "an error occurred" ) ; return null ; } } } return newfile ; } else { return null ; } }
tr	4	@ test public void testtokenpayment ( ) { gateway beanstream = new gateway ( "v1" , 300200578 , "4bad82d9197b4cc4b70a221911ee9f70" ) ; httpsconnector connector = new httpsconnector ( 300200578 , "4bad82d9197b4cc4b70a221911ee9f70" ) ; legatotokenrequest legatotokenrequest = new legatotokenrequest ( ) ; legatotokenrequest . number = "5100000010001004" ; legatotokenrequest . expirymonth = 12 ; legatotokenrequest . expiryyear = 18 ; legatotokenrequest . cvd = "123" ; string url = "https://www.beanstream.com/scripts/tokenization/tokens" ; string output = "" ; try { output = connector . processtransaction ( httpmethod . post , url , legatotokenrequest ) ; } catch ( beanstreamapiexception ex ) { logger . getlogger ( sampletransactions . class . getname ( ) ) . log ( level . severe , null , ex ) ; assert . fail ( ex . getmessage ( ) ) ; } gson gson = new gson ( ) ; legatotokenresponse tokenresponse = gson . fromjson ( output , legatotokenresponse . class ) ; system . out . println ( "token: " + output ) ; tokenpaymentrequest tokenreq = new tokenpaymentrequest ( ) ; tokenreq . setamount ( 100.00 ) ; tokenreq . setordernumber ( getrandomorderid ( "token" ) ) ; tokenreq . gettoken ( ) . setname ( "john doe" ) . setcode ( tokenresponse . gettoken ( ) ) ; try { paymentresponse response = beanstream . payments ( ) . makepayment ( tokenreq ) ; system . out . println ( "token payment approved? " + response . isapproved ( ) ) ; } catch ( beanstreamapiexception ex ) { logger . getlogger ( this . getclass ( ) . getname ( ) ) . log ( level . severe , "an error occurred" , ex ) ; assert . fail ( ex . getmessage ( ) ) ; } try { output = connector . processtransaction ( httpmethod . post , url , legatotokenrequest ) ; } catch ( beanstreamapiexception ex ) { logger . getlogger ( sampletransactions . class . getname ( ) ) . log ( level . severe , null , ex ) ; assert . fail ( ex . getmessage ( ) ) ; } tokenresponse = gson . fromjson ( output , legatotokenresponse . class ) ; system . out . println ( "token pre-auth: " + tokenresponse . gettoken ( ) ) ; tokenpaymentrequest req = new tokenpaymentrequest ( ) ; req . setamount ( 80.00 ) ; req . setordernumber ( getrandomorderid ( "token" ) ) ; req . gettoken ( ) . setname ( "john doe" ) . setcode ( tokenresponse . gettoken ( ) ) ; try { paymentresponse response = beanstream . payments ( ) . preauth ( req ) ; system . out . println ( "token payment approved? " + response . isapproved ( ) ) ; response = beanstream . payments ( ) . preauthcompletion ( response . id , 55.30 ) ; assert . asserttrue ( response . isapproved ( ) ) ; assert . assertequals ( "pac" , response . type ) ; } catch ( beanstreamapiexception ex ) { logger . getlogger ( this . getclass ( ) . getname ( ) ) . log ( level . severe , "an error occurred" , ex ) ; assert . fail ( ex . getmessage ( ) ) ; } }
tr	2	@ override public void actionperformed ( actionevent e ) { if ( e . getactioncommand ( ) . equals ( "apply" ) ) { this . dispose ( ) ; system . out . println ( "aaaa" ) ; tuple < string , tuple < string , integer >> player1data = player1 . getplayerdata ( ) ; tuple < string , tuple < string , integer >> player2data = player2 . getplayerdata ( ) ; int deadfields = this . deadfields . getdeadfieldnumber ( ) ; system . out . println ( deadfields ) ; system . out . println ( "bbb" ) ; player [ ] players = { new player ( player1data . getfirstelement ( ) , player1data . getsecondelement ( ) . getfirstelement ( ) , "w" , player1data . getsecondelement ( ) . getsecondelement ( ) ) , new player ( player2data . getfirstelement ( ) , player2data . getsecondelement ( ) . getfirstelement ( ) , "b" , player2data . getsecondelement ( ) . getsecondelement ( ) ) , } ; system . out . println ( "ccc" ) ; try { mastergui . newgame ( players , deadfields ) ; } catch ( exception e1 ) { e1 . printstacktrace ( ) ; } system . out . println ( "ddd" ) ; } }
tr	3	protected char [ ] move_array ( char [ ] array , int offset , boolean left ) { int total = array . length ; char [ ] new_array = new char [ total ] ; for ( int i = 0 ; i < total ; i ++ ) { int new_pos ; if ( ! left ) { new_pos = ( i + offset ) % total ; } else { new_pos = ( i - offset ) % total ; if ( new_pos < 0 ) { new_pos += total ; } } new_array [ new_pos ] = array [ i ] ; } return new_array ; }
tr	0	public multilist ( ) { recommendedmodel = new defaultlistmodel < champion > ( ) ; goodmodel = new defaultlistmodel < champion > ( ) ; viablemodel = new defaultlistmodel < champion > ( ) ; allmodel = new defaultlistmodel < champion > ( ) ; instance = this ; submit ( ) ; eventhandler . addslotlocklistener ( new slotlocklistener ( ) { @ override public void onslotlock ( ) { submit ( ) ; } } ) ; eventhandler . addresetlistener ( new resetlistener ( ) { @ override public void onreset ( ) { reset ( ) ; submit ( ) ; } } ) ; }
tr	5	@ override public void handleevent ( iparserevent event ) { if ( event . gettype ( ) == parsereventtype . document_end_event ) { flushevents ( ) ; event . fire ( listener ) ; } else { iparserevent lastevent = events . peeklast ( ) ; if ( lastevent != null && lastevent . gettype ( ) == parsereventtype . string_event && event . gettype ( ) == parsereventtype . string_event ) { event = mergestringevents ( ( stringevent ) event ) ; } events . add ( event ) ; if ( events . size ( ) > max_events ) { events . removefirst ( ) . fire ( listener ) ; } } }
tr	9	public paymentdialog ( member member , classtype ct , string message , int flag ) { messagetextarea . settext ( message ) ; globalmember = member ; globalclasstype = ct ; globalflag = flag ; makepaymentbutton = new jbutton ( "make payment" ) ; makepaymentbutton . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent arg0 ) { common . makepayment ( paymenttypelist . getselectedvalue ( ) , globalmember , ( date ) utildatemodel . getvalue ( ) , getpaymentamount ( ) ) ; updatepaymentstatus ( globalmember , globalclasstype ) ; dispose ( ) ; new paymentdialog ( globalmember , globalclasstype , "payment made for " + globalmember . getname ( ) + "\n of " + getpaymentamount ( ) + " for " + paymenttypelist . getselectedvalue ( ) . getpaymenttypename ( ) + "\n up to date: " + ( ( date ) utildatemodel . getvalue ( ) ) . tostring ( ) , globalflag ) ; } } ) ; makepaymentbutton . setenabled ( false ) ; exitbutton = new jbutton ( "exit" ) ; exitbutton . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent e ) { dispose ( ) ; if ( globalflag == 0 ) new membercheckininterface ( globalclasstype ) ; } } ) ; bufferedimage tkdicon = commonui . gettkdicon ( ) ; bufferedimage skyicon = commonui . getskyicon ( ) ; bufferedimage kickicon = commonui . getkickicon ( ) ; image img = null ; switch ( ct ) { case taekwondo : img = new imageicon ( tkdicon ) . getimage ( ) ; break ; case skyboxing : img = new imageicon ( skyicon ) . getimage ( ) ; break ; case kickboxing : img = new imageicon ( kickicon ) . getimage ( ) ; break ; case other : img = new imageicon ( tkdicon ) . getimage ( ) ; default : img = new imageicon ( tkdicon ) . getimage ( ) ; } seticonimage ( img ) ; this . settitle ( "enter payment for " + member . getname ( ) ) ; utildatemodel . addchangelistener ( new changelistener ( ) { @ override public void statechanged ( changeevent arg0 ) { system . out . println ( "datemodel changed" ) ; setdateselected ( ) ; if ( paymentamountselected && dateselected ) { makepaymentbutton . setenabled ( true ) ; } } } ) ; panel . add ( paymenttopanel , borderlayout . center ) ; paymenttypelist . setlistdata ( common . getpaymenttypes ( ct ) . toarray ( new paymenttype [ 1 ] ) ) ; paymenttypelist . addlistselectionlistener ( new listselectionlistener ( ) { @ override public void valuechanged ( listselectionevent arg0 ) { jlist < paymenttype > templist = ( jlist < paymenttype > ) arg0 . getsource ( ) ; paymenttype pt = templist . getselectedvalue ( ) ; paymentamounttextfield . settext ( string . format ( "%9.2f" , pt . getpaymentamount ( ) ) ) ; setpaymentamountfieldselected ( ) ; if ( paymentamountselected && dateselected ) { makepaymentbutton . setenabled ( true ) ; } } } ) ; listpanel . add ( paymenttypelist ) ; panel . add ( listpanel , borderlayout . west ) ; paymentamountpanel . add ( paymentamountlabel ) ; paymentamountpanel . add ( paymentamounttextfield ) ; buttonpanel . add ( paymentamountpanel , borderlayout . north ) ; buttonpanel . add ( makepaymentbutton , borderlayout . west ) ; buttonpanel . add ( exitbutton , borderlayout . south ) ; panel . add ( buttonpanel , borderlayout . south ) ; paymentstatuspanel . add ( paymentstatustextarea , borderlayout . north ) ; paymentstatuspanel . add ( messagetextarea , borderlayout . south ) ; updatepaymentstatus ( member , ct ) ; panel . add ( paymentstatuspanel , borderlayout . east ) ; this . getcontentpane ( ) . add ( panel ) ; this . setsize ( commonui . fullscreen ) ; this . setvisible ( true ) ; }
tr	1	public void drawpoint ( vertex vertex ) { init ( ) ; double x = vertex . getpoint ( ) . getx ( ) * scale_x ; double y = vertex . getpoint ( ) . gety ( ) * scale_y ; ellipse2d el = new ellipse2d . double ( x - pointsize / 2. , y - pointsize / 2. , pointsize , pointsize ) ; ensurehassize ( el . getbounds2d ( ) ) ; graphics2d g = getgraphicsobject ( ) ; g . setstroke ( new basicstroke ( ( float ) pensize ) ) ; g . setcolor ( pencolor ) ; g . setcolor ( pointfill ) ; g . fill ( el ) ; g . setcolor ( pointborder ) ; g . draw ( el ) ; if ( showvertexnumbers ) g . drawstring ( "" + vertex . getvertexindex ( ) , ( float ) x - 5 , ( float ) y + 5 ) ; repaint ( ) ; }
tr	7	private static void begin ( ) { scanner sc = new scanner ( system . in ) ; int ntestcases = integer . parseint ( sc . nextline ( ) ) ; sc . nextline ( ) ; line decryptedline = new line ( "the quick brown fox jumps over the lazy dog" ) ; for ( int t = 0 ; t < ntestcases ; ++ t ) { list < line > lines = new linkedlist < line > ( ) ; map < character , character > dict = null ; while ( sc . hasnextline ( ) ) { string input = sc . nextline ( ) ; if ( input . isempty ( ) ) { break ; } line line = new line ( input ) ; lines . add ( line ) ; if ( dict == null ) { dict = line . getdict ( decryptedline ) ; } } if ( dict == null ) { system . out . println ( "no solution." ) ; } else { for ( line l : lines ) { system . out . println ( l . decrypt ( dict ) ) ; } } if ( t < ntestcases - 1 ) { system . out . println ( ) ; } } }
tr	6	@ override public object getvalueat ( int row , int column ) { vehicle vehicle = vehicles . elementat ( row ) ; switch ( column ) { case 0 : return vehicle . getlicenceplate ( ) ; case 1 : return vehicle . getstartdate ( ) ; case 2 : return vehicle . getowner ( ) . getfirstname ( ) + " " + vehicle . getowner ( ) . getfamilyname ( ) . touppercase ( ) ; case 3 : return vehicle . getmodel ( ) . getdesignation ( ) ; case 4 : if ( this . deleteicon == null ) { return "supprimer" ; } return this . deleteicon ; default : break ; } return null ; }
tr	7	private bufferedimage getview ( ) { if ( this . getwidth ( ) > 0 && this . getheight ( ) > 0 ) { int mapsize = ( mapimage_scaled . getheight ( ) ) ; if ( viewport . x + this . getwidth ( ) > mapsize ) { int movexby = viewport . x + this . getwidth ( ) - mapsize ; moveview ( - movexby , 0 ) ; } if ( viewport . y + this . getheight ( ) > mapsize ) { int moveyby = viewport . y + this . getheight ( ) - mapsize ; moveview ( 0 , - moveyby ) ; } int windowheight = this . getheight ( ) ; int windowwidth = this . getwidth ( ) ; if ( this . getheight ( ) > mapimage_scaled . getheight ( ) ) { windowheight = mapimage_scaled . getheight ( ) ; viewport . y = 0 ; } if ( this . getwidth ( ) > mapimage_scaled . getwidth ( ) ) { windowwidth = mapimage_scaled . getwidth ( ) ; viewport . x = 0 ; } mapimage_view = null ; try { mapimage_view = mapimage_unitandbuildingsscaled . getsubimage ( viewport . x , viewport . y , windowwidth , windowheight ) ; } catch ( exception e ) { system . err . println ( "error creating subview!" ) ; } } return mapimage_view ; }
tr	6	public customer editcustomer ( customer customer ) throws exception { if ( customer . getid ( ) == null || customer . getaddress ( ) == null || customer . getname ( ) == null || customer . getsurname ( ) == null || customer . gettelephones ( ) == null ) { throw new nullparameterexception ( ) ; } if ( ! checkzipcode ( customer . getaddress ( ) . getzipcode ( ) ) ) { throw new zipcodeoutofrangeexception ( ) ; } daofactory . factory . getcustomerdao ( ) . updatecustomer ( customer ) ; return customer ; }
tr	5	@ override public string tostring ( ) { string a = "" ; string b ; if ( ! playerscoreminerals . keyset ( ) . equals ( playershiplocations . keyset ( ) ) ) { for ( string s : playerscoreminerals . keyset ( ) ) { system . out . println ( s ) ; } system . out . println ( "different from" ) ; for ( string s : playershiplocations . keyset ( ) ) { system . out . println ( s ) ; } a = "\nthere seems to be an issue with the game state\n" ; } for ( string k : playershiplocations . keyset ( ) ) { b = "" ; for ( boardlocation bl : playershiplocations . get ( k ) ) { b = b . concat ( " " + bl . row + " " + bl . col ) ; } a = a . concat ( k + ":" + b + "\n" ) ; a = a . concat ( k + " score:" + playerscoreminerals . get ( k ) [ 0 ] + "\n" ) ; a = a . concat ( k + " minerals:" + playerscoreminerals . get ( k ) [ 1 ] + "\n" ) ; } return a . concat ( separator ) ; }
tr	4	public list < integer > getrow ( int rowindex ) { list < integer > result = new arraylist < integer > ( ) ; list < integer > temp = new arraylist < integer > ( ) ; for ( int i = 0 ; i <= rowindex ; i ++ ) { temp = new arraylist < integer > ( result ) ; result . clear ( ) ; for ( int j = 0 ; j <= i ; j ++ ) { if ( j == 0 || j == i ) result . add ( 1 ) ; else { result . add ( temp . get ( j - 1 ) + temp . get ( j ) ) ; } } } return result ; }
tr	5	public static list < employee > load ( inputstream input ) { list < employee > employees = new arraylist < employee > ( ) ; bufferedreader reader = null ; try { reader = new bufferedreader ( new inputstreamreader ( input ) ) ; while ( true ) { string line = reader . readline ( ) ; if ( line == null ) break ; string [ ] values = line . split ( " " ) ; employee employee = new employee ( values [ 0 ] , values [ 1 ] , values [ 2 ] ) ; employees . add ( employee ) ; } return employees ; } catch ( ioexception e ) { throw new runtimeexception ( e ) ; } finally { if ( reader != null ) { try { reader . close ( ) ; } catch ( ioexception e ) { } } } }
tr	3	@ override public void mousereleased ( mouseevent evt ) { if ( evt . getclickcount ( ) == 2 ) { tabledoubleclick ( "employee" ) ; } if ( _view . table_employee . isrowselected ( _view . table_employee . getselectedrow ( ) ) ) { if ( evt . getbutton ( ) == mouseevent . button3 ) { integer integer = ( integer ) _view . table_employee . getvalueat ( _view . table_employee . getselectedrow ( ) , 0 ) ; int rownumber = _view . table_employee . rowatpoint ( evt . getpoint ( ) ) ; _view . table_employee . getselectionmodel ( ) . setselectioninterval ( rownumber , rownumber ) ; showpopup ( evt , integer , "employee" ) ; } } }
tr	9	public static void main ( string [ ] args ) { utility . configure ( ) ; jobtrackercomm = new communication ( utility . jobtracker . ipaddress , utility . jobtracker . port ) ; system . out . println ( "registering on job tracker..." ) ; message msg = new message ( utility . tasktrackerreg ) ; jobtrackercomm . sendmessage ( msg ) ; msg = jobtrackercomm . readmessage ( ) ; if ( msg . getmsgtype ( ) == utility . regack ) { tasktrackerid = msg . gettasktrackerid ( ) ; system . out . println ( "successfully registered." ) ; } while ( isrunning ) { msg = jobtrackercomm . readmessage ( ) ; if ( msg . getmsgtype ( ) == utility . newjob ) { jobcontext jobcontext = msg . getjobcontext ( ) ; string jobid = jobcontext . getjobid ( ) . getid ( ) ; system . out . println ( "receiced new job from job[" + jobid + "] tracker" ) ; if ( ! jobcontexts . containskey ( jobid ) ) { jobcontexts . put ( jobid , jobcontext ) ; } msg = new message ( utility . newjoback ) ; jobtrackercomm . sendmessage ( msg ) ; } else if ( msg . getmsgtype ( ) == utility . runmapper ) { system . out . println ( "received runmapper command from job tracker." ) ; list < mapbasiccontext > mapbasiccontexts = msg . getmapcontexts ( ) ; if ( mapbasiccontexts . size ( ) != 0 ) { string jobid = mapbasiccontexts . get ( 0 ) . getjobid ( ) . getid ( ) ; jobcontext jobcontext = jobcontexts . get ( jobid ) ; nummappers = mapbasiccontexts . size ( ) ; launchmappers ( jobcontext , mapbasiccontexts ) ; } } else if ( msg . getmsgtype ( ) == utility . runreducer ) { system . out . println ( "received runreducer command from job tracker." ) ; list < reducebasiccontext > reducebasiccontexts = msg . getreducecontexts ( ) ; if ( reducebasiccontexts . size ( ) != 0 ) { string jobid = reducebasiccontexts . get ( 0 ) . getjobid ( ) . getid ( ) ; jobcontext jobcontext = jobcontexts . get ( jobid ) ; numreducers = reducebasiccontexts . size ( ) ; launchreducers ( jobcontext , reducebasiccontexts ) ; } } else if ( msg . getmsgtype ( ) == utility . close ) { isrunning = false ; } } jobtrackercomm . close ( ) ; }
tr	4	public static byte [ ] decodeencfs ( byte [ ] source ) { byte [ ] decodedinput = new byte [ source . length ] ; for ( int i = 0 ; i < source . length ; i ++ ) { int arrayindex = source [ i ] ; if ( arrayindex >= 0 ) { decodedinput [ i ] = _encfs_decodabet [ source [ i ] ] ; } else { decodedinput [ i ] = - 9 ; } } int outputlen = ( source . length * 6 ) / 8 ; byte [ ] output = new byte [ outputlen ] ; int srcidx = 0 ; int dstidx = 0 ; int workbits = 0 ; long work = 0 ; while ( srcidx < source . length ) { work |= decodedinput [ srcidx ++ ] << workbits ; workbits += 6 ; while ( workbits >= 8 ) { output [ dstidx ++ ] = ( byte ) ( work & ff ) ; work >>>= 8 ; workbits -= 8 ; } } return output ; }
tr	0	private void initcomponents ( ) { this . blackbox = new jpanel ( ) ; this . redbox = new jpanel ( ) ; this . bluebox = new jpanel ( ) ; this . greenbox = new jpanel ( ) ; this . yellowbox = new jpanel ( ) ; this . orangebox = new jpanel ( ) ; this . letterlabel = new letterpanel ( ) ; this . colourspanel = new jpanel ( ) ; this . blacklabel = new jlabel ( ) ; this . redlabel = new jlabel ( ) ; this . greenlabel = new jlabel ( ) ; this . bluelabel = new jlabel ( ) ; this . yellowlabel = new jlabel ( ) ; this . orangelabel = new jlabel ( ) ; this . colourspanel . setlayout ( new gridbaglayout ( ) ) ; gridbagconstraints c = new gridbagconstraints ( ) ; c . gridx = 0 ; c . gridy = 0 ; c . insets = new insets ( 5 , 5 , 5 , 5 ) ; this . colourspanel . add ( blackbox , c ) ; c . gridx = 1 ; c . gridy = 0 ; this . colourspanel . add ( blacklabel , c ) ; c . gridx = 0 ; c . gridy = 1 ; this . colourspanel . add ( redbox , c ) ; c . gridx = 1 ; c . gridy = 1 ; this . colourspanel . add ( redlabel , c ) ; c . gridx = 0 ; c . gridy = 2 ; this . colourspanel . add ( greenbox , c ) ; c . gridx = 1 ; c . gridy = 2 ; this . colourspanel . add ( greenlabel , c ) ; c . gridx = 2 ; c . gridy = 0 ; c . insets = new insets ( 5 , 50 , 5 , 5 ) ; this . colourspanel . add ( bluebox , c ) ; c . gridx = 3 ; c . gridy = 0 ; c . insets = new insets ( 5 , 5 , 5 , 5 ) ; this . colourspanel . add ( bluelabel , c ) ; c . gridx = 2 ; c . gridy = 1 ; c . insets = new insets ( 5 , 50 , 5 , 5 ) ; this . colourspanel . add ( yellowbox , c ) ; c . gridx = 3 ; c . gridy = 1 ; c . insets = new insets ( 5 , 5 , 5 , 5 ) ; this . colourspanel . add ( yellowlabel , c ) ; c . gridx = 2 ; c . gridy = 2 ; c . insets = new insets ( 5 , 50 , 5 , 5 ) ; this . colourspanel . add ( orangebox , c ) ; c . gridx = 3 ; c . gridy = 2 ; c . insets = new insets ( 5 , 5 , 5 , 5 ) ; this . colourspanel . add ( orangelabel , c ) ; this . setdefaultcloseoperation ( windowconstants . exit_on_close ) ; this . blackbox . setbackground ( systemproperties . colour_map . get ( colourtype . black ) ) ; this . blackbox . setborder ( borderfactory . createlineborder ( new java . awt . color ( 0 , 0 , 0 ) ) ) ; this . blackbox . setpreferredsize ( new dimension ( 30 , 30 ) ) ; this . redbox . setbackground ( systemproperties . colour_map . get ( colourtype . red ) ) ; this . redbox . setborder ( borderfactory . createlineborder ( new java . awt . color ( 0 , 0 , 0 ) ) ) ; this . redbox . setpreferredsize ( new dimension ( 30 , 30 ) ) ; this . greenbox . setbackground ( systemproperties . colour_map . get ( colourtype . green ) ) ; this . greenbox . setborder ( borderfactory . createlineborder ( new java . awt . color ( 0 , 0 , 0 ) ) ) ; this . greenbox . setpreferredsize ( new dimension ( 30 , 30 ) ) ; this . bluebox . setbackground ( systemproperties . colour_map . get ( colourtype . blue ) ) ; this . bluebox . setborder ( borderfactory . createlineborder ( new java . awt . color ( 0 , 0 , 0 ) ) ) ; this . bluebox . setpreferredsize ( new dimension ( 30 , 30 ) ) ; this . yellowbox . setbackground ( systemproperties . colour_map . get ( colourtype . yellow ) ) ; this . yellowbox . setborder ( borderfactory . createlineborder ( new java . awt . color ( 0 , 0 , 0 ) ) ) ; this . yellowbox . setpreferredsize ( new dimension ( 30 , 30 ) ) ; this . orangebox . setbackground ( systemproperties . colour_map . get ( colourtype . orange ) ) ; this . orangebox . setborder ( borderfactory . createlineborder ( new java . awt . color ( 0 , 0 , 0 ) ) ) ; this . orangebox . setpreferredsize ( new dimension ( 30 , 30 ) ) ; this . letterlabel . setbackground ( systemproperties . white ) ; this . letterlabel . setborder ( borderfactory . createlineborder ( new java . awt . color ( 0 , 0 , 0 ) ) ) ; this . blacklabel . settext ( "s" ) ; this . blacklabel . setfont ( new font ( "arial" , font . plain , 28 ) ) ; this . redlabel . settext ( "r" ) ; this . redlabel . setfont ( new font ( "arial" , font . plain , 28 ) ) ; this . greenlabel . settext ( "g" ) ; this . greenlabel . setfont ( new font ( "arial" , font . plain , 28 ) ) ; this . bluelabel . settext ( "b" ) ; this . bluelabel . setfont ( new font ( "arial" , font . plain , 28 ) ) ; this . yellowlabel . settext ( "y" ) ; this . yellowlabel . setfont ( new font ( "arial" , font . plain , 28 ) ) ; this . orangelabel . settext ( "o" ) ; this . orangelabel . setfont ( new font ( "arial" , font . plain , 28 ) ) ; this . setjmenubar ( stroopmenu ) ; this . add ( this . letterlabel , borderlayout . center ) ; this . add ( this . colourspanel , borderlayout . south ) ; this . settitle ( "stroop test" ) ; this . addcomponentlistener ( this ) ; this . setpreferredsize ( new dimension ( 800 , 600 ) ) ; this . setlocation ( ( systemproperties . screen_width / 2 ) - 400 , ( systemproperties . screen_height / 2 ) - 300 ) ; this . pack ( ) ; }
tr	9	public arraylist < integer > obtenerjugadasganadorasdehoy ( arraylist < integer > boletosdehoy , arraylist < integer > numerosganadores , int loteria_id ) { verificadora verificadora = new verificadora ( ) ; connection cn = conexion . conectar ( ) ; preparedstatement pst ; resultset rs ; string query ; arraylist < integer > jugadasdehoy = new arraylist < > ( ) ; int numerog1 , numerog2 , numerog3 ; numerog1 = numerosganadores . get ( 0 ) ; numerog2 = numerosganadores . get ( 1 ) ; numerog3 = numerosganadores . get ( 2 ) ; int coincidencias = 0 ; for ( int i = 0 ; i < boletosdehoy . size ( ) ; i ++ ) { query = "select jugada_id  combinacion  monto  formato_id from jugadas where boleto_id = " + boletosdehoy . get ( i ) + " and loteria_id =" + loteria_id ; try { pst = cn . preparestatement ( query ) ; rs = pst . executequery ( ) ; while ( rs . next ( ) ) { string comb = separarcombinacion ( rs . getstring ( "combinacion" ) ) . get ( 0 ) ; string [ ] combinacion = rs . getstring ( "combinacion" ) . split ( "-" ) ; int formato = rs . getint ( "formato_id" ) ; int jugada_id = rs . getint ( "jugada_id" ) ; numerosganadores . clear ( ) ; numerosganadores . add ( numerog1 ) ; numerosganadores . add ( numerog2 ) ; numerosganadores . add ( numerog3 ) ; coincidencias = verificadora . verificarcoincidencias ( separarcombinacion ( rs . getstring ( "combinacion" ) ) , numerosganadores ) ; system . out . println ( "jugada: " + jugada_id ) ; system . out . println ( "coinc: " + coincidencias ) ; system . out . println ( "formato: " + formato ) ; if ( coincidencias == 1 && formato == 2 ) { jugadasdehoy . add ( jugada_id ) ; calcularquiniela ( jugada_id , integer . parseint ( combinacion [ 0 ] ) , numerog1 , numerog2 , numerog3 , double . parsedouble ( rs . getstring ( "monto" ) ) ) ; system . out . println ( "quiniela gan\u00f3: " + jugada_id ) ; } else if ( coincidencias == 2 && formato == 3 ) { jugadasdehoy . add ( jugada_id ) ; calcularpale ( jugada_id , integer . parseint ( combinacion [ 0 ] ) , integer . parseint ( combinacion [ 1 ] ) , numerog1 , numerog2 , numerog3 , double . parsedouble ( rs . getstring ( "monto" ) ) ) ; } else if ( coincidencias == 3 && formato == 1 ) { jugadasdehoy . add ( jugada_id ) ; calculartripleta ( jugada_id , double . parsedouble ( rs . getstring ( "monto" ) ) ) ; } } } catch ( sqlexception ex ) { system . out . println ( ex ) ; } } return jugadasdehoy ; }
tr	0	@ test public void testclonesimplebean ( ) { bank bankfrom = new localbank ( ) ; bankfrom . setid ( 1 ) ; bankfrom . setname ( "alfabank" ) ; subject payer = new subject ( ) ; payer . setbank ( bankfrom ) ; payer . setid ( "payer" ) ; payer . setname ( "alice" ) ; bank bankto = new foreignbank ( ) ; bankto . setid ( 2 ) ; bankto . setname ( "citibank" ) ; subject receiver = new subject ( ) ; receiver . setbank ( bankto ) ; receiver . setid ( "receiver" ) ; receiver . setname ( "alice" ) ; payment pay = new payment ( 100 ) ; pay . setamount ( new bigdecimal ( "123.45" ) ) ; pay . setpayer ( payer ) ; pay . setreceiver ( receiver ) ; pay . settimestamp ( instant . now ( ) ) ; payment copy = beanhelper . cloneof ( pay ) ; assertnotsame ( pay , copy ) ; assertnotsame ( pay . getpayer ( ) , copy . getpayer ( ) ) ; assertnotsame ( pay . getreceiver ( ) , copy . getreceiver ( ) ) ; assertnotsame ( pay . getpayer ( ) . getbank ( ) , copy . getpayer ( ) . getbank ( ) ) ; assertnotsame ( pay . getreceiver ( ) . getbank ( ) , copy . getreceiver ( ) . getbank ( ) ) ; assertequals ( pay . getamount ( ) , copy . getamount ( ) ) ; assertequals ( pay . getid ( ) , copy . getid ( ) ) ; assertequals ( pay . gettimestamp ( ) , copy . gettimestamp ( ) ) ; subject cpayer = copy . getpayer ( ) ; subject creceiver = copy . getreceiver ( ) ; bank cbankfrom = cpayer . getbank ( ) ; bank cbankto = creceiver . getbank ( ) ; assertequals ( payer . getid ( ) , cpayer . getid ( ) ) ; assertequals ( payer . getname ( ) , cpayer . getname ( ) ) ; assertequals ( bankfrom . getid ( ) , cbankfrom . getid ( ) ) ; assertequals ( bankfrom . getname ( ) , cbankfrom . getname ( ) ) ; assertsame ( bankfrom . getclass ( ) , cbankfrom . getclass ( ) ) ; assertequals ( receiver . getid ( ) , creceiver . getid ( ) ) ; assertequals ( receiver . getname ( ) , creceiver . getname ( ) ) ; assertequals ( bankto . getid ( ) , cbankto . getid ( ) ) ; assertequals ( bankto . getname ( ) , cbankto . getname ( ) ) ; assertsame ( bankto . getclass ( ) , cbankto . getclass ( ) ) ; }
tr	2	public static void main ( string [ ] args ) { treeset < integer > set2 = new treeset < integer > ( ) ; set2 . add ( 4 ) ; set2 . add ( 100 ) ; set2 . add ( 45 ) ; set2 . add ( 19 ) ; set2 . add ( 33 ) ; arraylist < treeset < integer >> totalsubsets = findsubsets ( set2 , 0 ) ; if ( totalsubsets == null ) system . out . println ( "no possible subsets" ) ; else for ( treeset < integer > ts : totalsubsets ) { system . out . println ( ts ) ; } }
tr	8	@ suppresswarnings ( "unchecked" ) @ transactional public list < merchant > getmerchantlist ( string merchantname , string sortby , string sortorder ) throws exception { list < merchant > lstmerchants = new arraylist < merchant > ( ) ; session session = null ; criteria criteriaobj = null ; logger . info ( "merchantname---------->" + merchantname ) ; logger . info ( "sortby--------------->" + sortby ) ; logger . info ( "sortorder------------>" + sortorder ) ; string sname = merchantname ; try { session = sessionfactory . getcurrentsession ( ) ; logger . info ( "entered into getmerchantlist()--->" ) ; logger . info ( "retrieving all merchants" ) ; if ( session != null ) { criteriaobj = session . createcriteria ( merchant . class ) ; if ( merchantname != null ) { logger . info ( "retrieving  merchants based on name" ) ; criteriaobj . add ( restrictions . ilike ( "sname" , "%" + sname + "%" ) ) ; criteriaobj . add ( restrictions . = ( "bdeletedflag" , false ) ) ; } lstmerchants = criteriaobj . list ( ) ; logger . info ( "lstmerchants from dao----------->" + lstmerchants . size ( ) ) ; } if ( sortby != null && sortorder == "asc" ) { logger . info ( "retrieving  merchants based on ascending sort order for " + sortby ) ; lstmerchants = criteriaobj . addorder ( order . asc ( sortby ) ) . list ( ) ; logger . info ( "lstmerchants size-------->" + lstmerchants . size ( ) ) ; } if ( sortby != null && sortorder == "desc" ) { logger . info ( "retrieving  merchants based on descending sort order for " + sortby ) ; lstmerchants = criteriaobj . addorder ( order . desc ( sortby ) ) . list ( ) ; logger . info ( "lstmerchants size-------->" + lstmerchants . size ( ) ) ; } iterator < merchant > it = lstmerchants . iterator ( ) ; while ( it . hasnext ( ) ) { merchant merchant = it . next ( ) ; system . out . println ( "dao......." + merchant ) ; } } catch ( exception e ) { e . printstacktrace ( ) ; logger . error ( "exception occured in getmerchantlist()--->" + e . getmessage ( ) ) ; throw new exception ( "exception occured in getmerchantlist()--->" + e . getmessage ( ) ) ; } return lstmerchants ; }
tr	9	public list < task > sort ( final int colindex , final boolean sortdown ) { gettasks ( ) ; if ( colindex >= 0 && colindex <= 6 ) { collections . sort ( tasks , new comparator < task > ( ) { @ override public int compare ( task arg0 , task arg1 ) { int result = 0 ; if ( colindex == 1 || colindex == 2 || colindex == 3 || colindex == 5 || colindex == 6 ) { stringcomparer stringcomparator = new stringcomparer ( sortdown ) ; result = comparer ( stringcomparator , arg0 , arg1 , colindex ) ; } else if ( colindex == 0 ) { integercomparer intcomparator = new integercomparer ( sortdown ) ; result = comparer ( intcomparator , arg0 , arg1 , colindex ) ; } else if ( colindex == 4 ) { datecomparer datecomparator = new datecomparer ( sortdown ) ; result = comparer ( datecomparator , arg0 , arg1 , colindex ) ; } return result ; } } ) ; } else { throw new illegalargumentexception ( "invalid column index." ) ; } return tasks ; }
tr	2	private static void loadconfig ( ) { vmconfiguration . config = new vmconfiguration ( ) ; inputstream conf_file ; try { conf_file = new fileinputstream ( new file ( conf_file ) ) ; properties props = new properties ( ) ; props . load ( conf_file ) ; config . weightnumber = integer . parseint ( props . getproperty ( constants . weight_number ) ) ; config . learnfilename = props . getproperty ( constants . learn_file_name ) ; config . topologymodeltype = props . getproperty ( constants . topology_model ) ; config . rows = integer . parseint ( props . getproperty ( constants . rows ) ) ; config . cols = integer . parseint ( props . getproperty ( constants . cols ) ) ; config . radius = integer . parseint ( props . getproperty ( constants . radius ) ) ; config . numberofweights = integer . parseint ( props . getproperty ( constants . number_of_weights ) ) ; config . maxweight = integer . parseint ( props . getproperty ( constants . max_weight ) ) ; config . maxiteration = integer . parseint ( props . getproperty ( constants . max_iteration ) ) ; config . trainmetrictype = props . getproperty ( constants . train_metric_type ) ; config . predictmetrictype = props . getproperty ( constants . predict_metric_type ) ; config . learningfactor = integer . parseint ( props . getproperty ( constants . learn_factor ) ) ; config . neighbourfactor = double . parsedouble ( props . getproperty ( constants . neighbour_factor ) ) ; config . kfoldvalue = integer . parseint ( props . getproperty ( constants . k_fold_value ) ) ; config . delimiter = props . getproperty ( constants . delimiter ) ; config . pythonfilelocation = props . getproperty ( constants . python_file ) ; config . normalizedfilename = props . getproperty ( constants . normalized_file ) ; config . normalneurons = integer . parseint ( props . getproperty ( constants . normal_neurons ) ) ; config . predictdatafile = props . getproperty ( constants . predict_data_file ) ; config . lookaheadsize = integer . parseint ( props . getproperty ( constants . look_ahead_size ) ) ; config . predictaheadstep = integer . parseint ( props . getproperty ( constants . predict_ahead_step ) ) ; config . gaussianheight = integer . parseint ( props . getproperty ( constants . gaussian_height ) ) ; config . mem_log_file = props . getproperty ( constants . mem_log_file ) ; config . metric_log_file = props . getproperty ( constants . metric_log_file ) ; config . train_mem_log_file = props . getproperty ( constants . train_mem_log_file ) ; config . train_metric_log_file = props . getproperty ( constants . train_metric_log_file ) ; config . dotest = integer . parseint ( props . getproperty ( constants . do_test ) ) ; config . vm_name = props . getproperty ( constants . vm_name ) ; config . predictfile = props . getproperty ( constants . predict_file ) ; config . annotatefile = props . getproperty ( constants . ann_file ) ; config . faultinterval = integer . parseint ( props . getproperty ( constants . fault ) ) ; } catch ( filenotfoundexception e ) { logger . error ( "error while opening configuration file" ) ; } catch ( ioexception e ) { logger . error ( "error while loading configuration file" ) ; } }
tr	7	public boolean iscallablereference ( class clazz ) { if ( this == globalbridge ) { return false ; } if ( ! referencesenabled ) { return false ; } if ( callablereferenceset . contains ( clazz ) ) { return true ; } class [ ] interfaces = clazz . getinterfaces ( ) ; for ( int i = 0 ; i < interfaces . length ; i ++ ) { if ( callablereferenceset . contains ( interfaces [ i ] ) ) { return true ; } } class superclass = clazz . getsuperclass ( ) ; while ( superclass != null ) { if ( callablereferenceset . contains ( superclass ) ) { return true ; } superclass = superclass . getsuperclass ( ) ; } return globalbridge . iscallablereference ( clazz ) ; }
tr	6	private void handlenames ( message m ) { if ( m . numargs ( ) < 3 ) return ; if ( m . getcode ( ) == messagecode . rpl_endofnames ) { getchannel ( m . getarg ( 2 ) ) . userschanged ( ) ; return ; } if ( m . numargs ( ) < 5 || m . get ( 3 ) . charat ( 0 ) == * ) return ; channel c = getchannel ( m . getarg ( 3 ) ) ; stringtokenizer st = new stringtokenizer ( m . getmessage ( ) , " " ) ; user u ; string nick ; while ( st . hasmoretokens ( ) ) { nick = st . nexttoken ( ) ; channeluser . mode mode = channeluser . mode . getmode ( nick . charat ( 0 ) ) ; if ( mode != channeluser . mode . none ) nick = nick . substring ( 1 ) ; u = getuser ( nick ) ; u . addchannel ( c ) ; c . addusertolist ( u ) ; c . setusermode ( u , mode ) ; } }
tr	1	public static boolean updatekurssi ( kurssi kurssi ) { connection con = connect ( ) ; try { preparedstatement updatekurssi = con . preparestatement ( "update kurssi set nimi=? where kurssiid=?" ) ; updatekurssi . setstring ( 1 , kurssi . getnimi ( ) ) ; updatekurssi . setint ( 2 , kurssi . getid ( ) ) ; updatekurssi . executeupdate ( ) ; return true ; } catch ( sqlexception ex ) { logger . getlogger ( database . class . getname ( ) ) . log ( level . severe , null , ex ) ; return false ; } finally { closeconnection ( con ) ; } }
tr	9	@ override public void handlecommand ( commandmessage m ) { string [ ] args = m . getargs ( ) ; if ( args . length == 1 ) { string nick = m . getnick ( ) ; if ( pozdravy . containskey ( nick ) ) { ph . sendmessage ( nick + ": " + pozdravy . get ( nick ) ) ; } } else if ( args . length < 3 ) { if ( pozdravy . containskey ( args [ 1 ] ) ) { ph . sendmessage ( args [ 1 ] + ": " + pozdravy . get ( args [ 1 ] ) ) ; } } else if ( args [ 1 ] . equals ( "set" ) ) { stringbuilder sb = new stringbuilder ( ) ; for ( int i = 3 ; i < args . length ; i ++ ) { sb . append ( args [ i ] ) ; sb . append (   ) ; } sb . deletecharat ( sb . length ( ) - 1 ) ; pozdravy . put ( args [ 2 ] , sb . tostring ( ) ) ; try { ph . savedata ( pozdravy ) ; } catch ( ioexception ex ) { logger . warn ( "pozdravy couldn't be saved." , ex ) ; } } else if ( args [ 1 ] . equals ( "reset" ) ) { pozdravy . remove ( args [ 2 ] ) ; try { ph . savedata ( pozdravy ) ; ph . sendmessage ( "pozdrav pro " + args [ 2 ] + " byl zru\u0161en" ) ; } catch ( ioexception ex ) { logger . warn ( "pozdravy couldn't be saved." , ex ) ; } } else { ph . sendmessage ( this . help ( ph . getprefix ( ) ) ) ; } }
tr	5	public static double inversesensormodel_old ( point p , point measurement , robotstate sensorstate , int z , sensor s ) { double result ; int r = utils . euclideandistance ( new point ( sensorstate . x , sensorstate . y ) , p ) ; if ( z == - 1 ) { result = config . logodd_start ; } else if ( r > math . min ( s . zmax , z ) + config . grid_cell_size ) { result = config . logodd_start ; } else if ( z < s . zmax && p . equals ( measurement ) ) { result = config . logodd_occupied_correct ; } else if ( r < z ) { result = config . logodd_occupied_wrong ; } else { result = config . logodd_start ; } return result ; }
tr	6	@ override public boolean equals ( object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( obj instanceof describecomponentsresult == false ) return false ; describecomponentsresult other = ( describecomponentsresult ) obj ; if ( other . getcomponentinfos ( ) == null ^ this . getcomponentinfos ( ) == null ) return false ; if ( other . getcomponentinfos ( ) != null && other . getcomponentinfos ( ) . equals ( this . getcomponentinfos ( ) ) == false ) return false ; return true ; }
tr	2	private boolean isvaliduserinput ( final string hostname , final string port ) { final string methodname = "isvaliduserinput" ; controllerlogger . entering ( class_name , methodname , hostname , port ) ; try { if ( guiutils . isemptyvalue ( hostname ) ) { guiutils . showwarningmessage ( connecttoserverwindow , guimessages . invalid_hostname_message ) ; return false ; } if ( ! guiutils . isportnumbervalid ( port ) ) { guiutils . showwarningmessage ( connecttoserverwindow , guimessages . invalid_port_number_message ) ; return false ; } return true ; } finally { controllerlogger . exiting ( class_name , methodname ) ; } }
tr	3	public void refreshtextlist ( ) { ground . remove ( textpane ) ; textpane = null ; resultsets = connector . getallresultsets ( userid ) ; iterator < ? > result = resultsets . iterator ( ) ; dataname . clear ( ) ; if ( result != null ) { while ( result . hasnext ( ) ) { resultset temp_res = ( resultset ) result . next ( ) ; resultmapper . put ( temp_res . getdocument ( ) . getfilename ( ) , ( resultset ) temp_res ) ; dataname . addelement ( temp_res . getdocument ( ) . getfilename ( ) ) ; } textpane = new jscrollpane ( texte ) ; textpane . setlocation ( 280 , 50 ) ; textpane . setsize ( 180 , 300 ) ; textpane . setvisible ( true ) ; texte . setvisible ( true ) ; ground . add ( textpane ) ; textpane . repaint ( ) ; ground . repaint ( ) ; } }
tr	4	public static void filesaveasscm ( file target ) { if ( mainmethods . openfile == null ) { updatestatusbar ( "nothing to save ... please open a file first!" , 2 ) ; return ; } if ( ! mainmethods . openfile . isscmfile ( ) ) { updatestatusbar ( "you must open a scm file to save as an scm file" , 2 ) ; return ; } file outputfile = target ; if ( outputfile == null ) outputfile = mainmethods . getfiletosavein ( ) ; mapparser . write ( mainmethods . openfile . getchannellist ( ) , mainmethods . openfile . getfile ( ) ) ; int compressedfiles = ziphandler . compress ( outputfile . getabsolutepath ( ) , mainmethods . openfile . scmextractedto ( ) . getabsolutepath ( ) ) ; if ( compressedfiles < 0 ) { mainmethods . updatestatusbar ( "packaging scm file failed!" , 2 ) ; return ; } updatestatusbar ( "saved scm file as \"" + outputfile . getabsolutepath ( ) + "\"" , 2 ) ; }
tr	0	private void createaroundvertex ( point p ) { addvertex ( p , getrandomname ( ) ) ; point p1 = new point ( p . x - 1 , p . y - 1 ) ; point p2 = new point ( p . x , p . y - 1 ) ; point p3 = new point ( p . x + 1 , p . y - 1 ) ; point p4 = new point ( p . x + 1 , p . y ) ; point p5 = new point ( p . x - 1 , p . y ) ; point p6 = new point ( p . x , p . y + 1 ) ; point p7 = new point ( p . x + 1 , p . y + 1 ) ; point p8 = new point ( p . x - 1 , p . y + 1 ) ; addvertex ( p1 , getrandomname ( ) ) ; addvertex ( p2 , getrandomname ( ) ) ; addvertex ( p3 , getrandomname ( ) ) ; addvertex ( p4 , getrandomname ( ) ) ; addvertex ( p5 , getrandomname ( ) ) ; addvertex ( p6 , getrandomname ( ) ) ; addvertex ( p7 , getrandomname ( ) ) ; addvertex ( p8 , getrandomname ( ) ) ; addedge ( p , p1 , 1 ) ; addedge ( p , p2 , 1 ) ; addedge ( p , p3 , 1 ) ; addedge ( p , p4 , 1 ) ; addedge ( p , p5 , 1 ) ; addedge ( p , p6 , 1 ) ; addedge ( p , p7 , 1 ) ; addedge ( p , p8 , 1 ) ; }
tr	5	@ override public void doinbackground ( ) { int slashes = this . address . indexof ( / ) ; int dots = this . address . indexof ( . ) ; if ( ( dots >= 1 ) && ( slashes > 0 ) && ( slashes < this . address . length ( ) - 1 ) ) { try { urlconnection connection = new url ( "http://" + this . address ) . openconnection ( ) ; int totalsize = connection . getcontentlength ( ) ; bufferedinputstream input = new bufferedinputstream ( connection . getinputstream ( ) ) ; fileoutputstream output = new fileoutputstream ( this . outputfile ) ; int read ; double totalread = 0 ; while ( ( read = input . read ( ) ) != - 1 ) { output . write ( read ) ; ++ totalread ; this . setprogress ( ( int ) ( 100.0 / totalsize * totalread ) ) ; } input . close ( ) ; output . close ( ) ; string version = this . address . substring ( this . address . indexof ( _ ) + 1 , this . address . lastindexof ( ".jar" ) ) . replace ( _ , . ) . trim ( ) ; this . setcurrentversion ( version ) ; } catch ( exception e ) { new spopup ( new spopupdata ( e ) ) ; } this . updateframe . closeframe ( ) ; } else { this . errorpopup = new spopup ( new spopupdata ( new sexception ( "invalid address" ) ) ) ; this . errorpopup . injectactionlistener ( this ) ; } return null ; }
tr	1	private static void createlist ( string tabname , final vector < chart > charts , tabfolder tabfolder , final stacklayout layout , final composite composite ) { final list list = new list ( tabfolder , swt . h_scroll | swt . v_scroll ) ; tabitem basictabitem = new tabitem ( tabfolder , swt . none ) ; basictabitem . settext ( tabname ) ; basictabitem . setcontrol ( list ) ; for ( chart chart : charts ) { list . add ( chart . gettitle ( ) . gettext ( ) ) ; } list . addselectionlistener ( new selectionadapter ( ) { @ override public void widgetselected ( selectionevent event ) { chart chart = charts . get ( list . getselectionindex ( ) ) ; chart . getaxisset ( ) . adjustrange ( ) ; layout . topcontrol = chart ; composite . layout ( ) ; } } ) ; }
tr	4	@ test public void testnaissancesoldats ( ) { sallesoldat testsoldat = new sallesoldat ( ) ; sallenourrice sn = new sallenourrice ( ) ; evenements . getinstance ( ) . setevenementactif ( constantes . even_deplacement ) ; sn . ajouterfourmi ( 3 ) ; testsoldat . naissancesoldats ( 2 , sn ) ; assertequals ( 1 , testsoldat . getnbcourantfourmi ( ) ) ; assertequals ( 1 , sn . getnbcourantfourmi ( ) ) ; try { testsoldat . naissancesoldats ( 2 , sn ) ; fail ( "exceptionnourrices non levee." ) ; } catch ( exceptionnourrices en ) { } try { testsoldat . naissancesoldats ( 0 , sn ) ; fail ( "illegalargumentexception non levee." ) ; } catch ( illegalargumentexception iae ) { } try { testsoldat . naissancesoldats ( 1 , sn ) ; fail ( "illegalargumentexception non levee." ) ; } catch ( illegalargumentexception iae ) { } try { testsoldat . naissancesoldats ( 5 , sn ) ; fail ( "illegalargumentexception non levee." ) ; } catch ( illegalargumentexception iae ) { } }
tr	8	private void emitloadorstore ( int opcode , int a , adda address ) throws exception { value v = address . getarg1 ( ) ; int b , c ; if ( v instanceof immediate ) { c = ( ( immediate ) v ) . getvalue ( ) ; opcode = opcode - 1 ; v = address . getarg2 ( ) ; if ( v . equals ( type . getgbp ( ) ) ) { b = gbp ; } else if ( v . equals ( type . getfp ( ) ) ) { b = fp ; } else { b = location2 ( v ) ; } } else { if ( v . equals ( type . getgbp ( ) ) ) { b = gbp ; } else if ( v . equals ( type . getfp ( ) ) ) { b = fp ; } else { b = location2 ( v ) ; } v = address . getarg2 ( ) ; if ( v instanceof immediate ) { c = ( ( immediate ) v ) . getvalue ( ) ; opcode = opcode - 1 ; } else if ( v . equals ( type . getgbp ( ) ) ) { c = gbp ; } else if ( v . equals ( type . getfp ( ) ) ) { c = fp ; } else { c = location2 ( v ) ; } } emit ( dlx . assemble ( opcode , a , b , c ) ) ; }
tr	2	arraylist < object [ ] > getpickerargs ( ) { arraylist < object [ ] > pickerargs = new arraylist < object [ ] > ( ) ; if ( this . pickers > 0 ) { pickers pickers = this . warehouse . getpickers ( ) ; arraylist < picker > rl = pickers . getpickerlist ( ) ; for ( picker r : rl ) { object [ ] args = new object [ 1 ] ; args [ 0 ] = r . getuid ( ) ; pickerargs . add ( args ) ; } } return pickerargs ; }
tr	8	private list < string > generacachekey ( object obj ) { ormtable ormtable = obj . getclass ( ) . getannotation ( ormtable . class ) ; if ( ormtable != null ) { string cachedtablekey = "" . equalsignorecase ( ormtable . cachedshortalias ( ) ) ? ormtable . tablename ( ) : ormtable . cachedshortalias ( ) ; string [ ] cachedkeys = ormtable . cachedkey ( ) ; if ( cachedkeys . length > 0 ) { list < string > ks = new arraylist < string > ( ) ; for ( int i = 0 ; i < cachedkeys . length ; i ++ ) { string cachedcol = cachedkeys [ i ] ; string [ ] fk = cachedcol . split ( "=" ) ; try { field f = obj . getclass ( ) . getdeclaredfield ( fk [ 0 ] ) ; f . setaccessible ( true ) ; ks . add ( cachedtablekey + "." + fk [ 1 ] + "." + f . get ( obj ) ) ; } catch ( nosuchfieldexception e ) { logger . warn ( "nosuchfieldexception:{};" , cachedcol , e ) ; continue ; } catch ( securityexception e ) { logger . warn ( "securityexception:{};" , cachedcol , e ) ; continue ; } catch ( illegalargumentexception e ) { logger . warn ( "get field value fail:{};" , cachedcol , e ) ; continue ; } catch ( illegalaccessexception e ) { logger . warn ( "get field value fail:{};" , cachedcol , e ) ; continue ; } } return ks ; } else { return null ; } } else { return null ; } }
tr	7	public static arraylist < string > from ( file f , boolean readblanks ) { arraylist < string > strings = new arraylist < string > ( ) ; if ( ! f . exists ( ) ) { system . err . println ( "file " + f . getpath ( ) + " not found!" ) ; return strings ; } while ( true ) { try { bufferedreader reader = new bufferedreader ( new filereader ( f ) ) ; string line ; while ( ( line = reader . readline ( ) ) != null ) { if ( ! line . startswith ( "#" ) && ( ! line . isempty ( ) || readblanks ) ) { strings . add ( line ) ; } } reader . close ( ) ; break ; } catch ( ioexception e ) { system . err . println ( "error reading file " + f . getname ( ) + ".... attempting again" ) ; } } return strings ; }
tr	3	@ override public void endelement ( string uri , string localname , string qname ) throws saxexception { playxmlenum playxmlenum = playxmlenum . valueof ( qname . touppercase ( ) ) ; if ( playxmlenum == playxmlenum . date ) { int curid ; synchronized ( xmlplayshandler . class ) { curid = ++ dateid ; } currentplay . adddate ( curid , parsetime ( currplaydate ) ) ; } else if ( playxmlenum == playxmlenum . play ) { addplay ( currentplay ) ; } else if ( playxmlenum == playxmlenum . description ) { currentplay . setdescription ( currentdesc . tostring ( ) ) ; } currplayenum = null ; }
tr	3	public static integer buildjob ( string receptor , string ownerid , vinaparams vinaparams , filterparams filterparams , string dispatchqueueloc ) throws sqlexception , amazonserviceexception , jaxbexception , amazonclientexception , filenotfoundexception , ioexception { integer jobid = initializer . getinstance ( null ) . getmaxjobid ( ownerid ) + 1 ; initializer . getinstance ( null ) . putjobonserver ( ownerid , jobid , new hashmap < integer , wustatus > ( ) ) ; determineworktodo jobwork = new determineworktodo ( receptor , ownerid , filterparams ) ; string receptorid = jobwork . putreceptorindatabase ( ) ; list < string > compoundids = jobwork . filtercompoundsindatabase ( ) ; integer workunitid = 0 ; list < sendmessagebatchrequestentry > batch = new arraylist < sendmessagebatchrequestentry > ( ) ; integer iter = 0 ; for ( string i : compoundids ) { sendmessagebatchrequestentry entry = putworkunitinsqsbatch ( buildworkunit ( receptorid , i , ownerid , jobid , workunitid , vinaparams ) ) ; batch . add ( entry ) ; initializer . getinstance ( ) . putworkunit ( ownerid , jobid , workunitid , wustatus . inflight ) ; workunitid ++ ; iter ++ ; if ( iter >= 10 ) { sendmessagebatchrequest request = new sendmessagebatchrequest ( dispatchqueueloc , batch ) ; initializer . getinstance ( ) . getsqsclient ( ) . sendmessagebatch ( request ) ; iter = 0 ; batch . removeall ( batch ) ; } } if ( batch . size ( ) > 0 ) { sendmessagebatchrequest request = new sendmessagebatchrequest ( dispatchqueueloc , batch ) ; initializer . getinstance ( ) . getsqsclient ( ) . sendmessagebatch ( request ) ; system . out . println ( "batch sent" ) ; } return jobid ; }
tr	2	public static void main ( string [ ] args ) { pricesinfo pricesinfo = new pricesinfo ( ) ; reader [ ] readers = new reader [ 5 ] ; thread [ ] threadsreader = new thread [ readers . length ] ; for ( int i = 0 ; i < readers . length ; i ++ ) { readers [ i ] = new reader ( pricesinfo ) ; threadsreader [ i ] = new thread ( readers [ i ] ) ; } writer writer = new writer ( pricesinfo ) ; thread threadwriter = new thread ( writer ) ; for ( thread thread : threadsreader ) { thread . start ( ) ; } threadwriter . start ( ) ; }
tr	8	public void run ( ) throws parsingexception { parsestack . push ( new terminalentry ( eof ) ) ; parsestack . addtoparsestack ( ruletable . find ( startsymbol , starttoken ) ) ; a = parsestack . peek ( ) ; getnexttoken ( ) ; while ( ( a != null ) && ! a . iseof ( ) ) { a = parsestack . peek ( ) ; if ( a . isterminal ( ) ) { if ( a . matches ( i ) ) { parsestack . pop ( ) ; if ( parsestack . notempty ( ) ) { a = parsestack . peek ( ) ; getnexttoken ( ) ; } } else { throw new parsingexception ( "terminal mismatch. expected: " + a + " found: " + i + "" ) ; } } else if ( a . issemanticentry ( ) ) { final semanticnode node = nodefactory . getnewnode ( a ) ; node . runonsemanticstack ( semanticstack ) ; parsestack . pop ( ) ; } else { if ( isrulecontained ( a , i ) ) { parsestack . pop ( ) ; parsestack . addtoparsestack ( ruletable . find ( a , i ) ) ; a = parsestack . peek ( ) ; } else { throw new parsingexception ( "non-terminal mismatch. no entry in the table for: " + a + "   " + i ) ; } } } if ( ! stream . isempty ( ) ) { throw new parsingexception ( "parser found the end of file marker but the token stream was not empty." ) ; } }
tr	8	public void draw ( ) { iterator < entity > i2 = getnearbyentities ( p . getlocation ( ) , 15 ) . iterator ( ) ; arraylist < block > bs = getnearbyblocks ( p . getlocation ( ) . modify ( 0 , 0 ) , 16 ) ; for ( block b : bs ) { b . draw ( ) ; } while ( i2 . hasnext ( ) ) { entity todraw = i2 . next ( ) ; todraw . draw ( ) ; } if ( path != null ) { for ( int c = 0 ; c < path . size ( ) ; c ++ ) { if ( c == 0 ) { engine . render ( path . get ( c ) , material . gold_ore . getimage ( ) ) ; } else if ( c == path . size ( ) - 1 ) { engine . render ( path . get ( c ) , material . iron_ore . getimage ( ) ) ; } else { engine . render ( path . get ( c ) , material . obsidian . getimage ( ) ) ; } } } if ( renderlight ) { engine . addqueueitem ( new renderqueueitem ( lightloc , lightmap ) ) ; } if ( drawmap ) { engine . addqueueitem ( new renderqueueitem ( new rectangle ( 0 , 0 , main . getpanewidth ( ) , main . getpaneheight ( ) ) , color . blue ) ) ; engine . addqueueitem ( new renderqueueitem ( 0 , 0 , map ) ) ; } }
tr	5	public string checkdataentry ( ) { if ( efastanalysispanel1 . parameterscreen . directorychosen . gettext ( ) . equals ( "selected directory: " ) ) { return "error on parameter data entry. make sure all the boxes have been completed" ; } else if ( efastanalysispanel1 . parameterscreen . efastcurves . gettext ( ) . equals ( "" ) || efastanalysispanel1 . parameterscreen . efastsamplenumber . gettext ( ) . equals ( "" ) ) { return "error on parameter data entry. make sure all the boxes have been completed" ; } else if ( efastanalysispanel1 . parameterscreen . parametersmodel . contains ( "none entered" ) ) { return "no parameters have been selected" ; } else { try { integer . parseint ( efastanalysispanel1 . parameterscreen . efastcurves . gettext ( ) ) ; integer . parseint ( efastanalysispanel1 . parameterscreen . efastsamplenumber . gettext ( ) ) ; return null ; } catch ( numberformatexception e ) { return "number of curves and parameter samples must be integers" ; } } }
tr	1	public static boolean invertm ( float [ ] minv , int minvoffset , float [ ] m , int moffset ) { final float src0 = m [ moffset + 0 ] ; final float src4 = m [ moffset + 1 ] ; final float src8 = m [ moffset + 2 ] ; final float src12 = m [ moffset + 3 ] ; final float src1 = m [ moffset + 4 ] ; final float src5 = m [ moffset + 5 ] ; final float src9 = m [ moffset + 6 ] ; final float src13 = m [ moffset + 7 ] ; final float src2 = m [ moffset + 8 ] ; final float src6 = m [ moffset + 9 ] ; final float src10 = m [ moffset + 10 ] ; final float src14 = m [ moffset + 11 ] ; final float src3 = m [ moffset + 12 ] ; final float src7 = m [ moffset + 13 ] ; final float src11 = m [ moffset + 14 ] ; final float src15 = m [ moffset + 15 ] ; final float atmp0 = src10 * src15 ; final float atmp1 = src11 * src14 ; final float atmp2 = src9 * src15 ; final float atmp3 = src11 * src13 ; final float atmp4 = src9 * src14 ; final float atmp5 = src10 * src13 ; final float atmp6 = src8 * src15 ; final float atmp7 = src11 * src12 ; final float atmp8 = src8 * src14 ; final float atmp9 = src10 * src12 ; final float atmp10 = src8 * src13 ; final float atmp11 = src9 * src12 ; final float dst0 = ( atmp0 * src5 + atmp3 * src6 + atmp4 * src7 ) - ( atmp1 * src5 + atmp2 * src6 + atmp5 * src7 ) ; final float dst1 = ( atmp1 * src4 + atmp6 * src6 + atmp9 * src7 ) - ( atmp0 * src4 + atmp7 * src6 + atmp8 * src7 ) ; final float dst2 = ( atmp2 * src4 + atmp7 * src5 + atmp10 * src7 ) - ( atmp3 * src4 + atmp6 * src5 + atmp11 * src7 ) ; final float dst3 = ( atmp5 * src4 + atmp8 * src5 + atmp11 * src6 ) - ( atmp4 * src4 + atmp9 * src5 + atmp10 * src6 ) ; final float det = src0 * dst0 + src1 * dst1 + src2 * dst2 + src3 * dst3 ; if ( det == 0.0f ) { return false ; } final float dst4 = ( atmp1 * src1 + atmp2 * src2 + atmp5 * src3 ) - ( atmp0 * src1 + atmp3 * src2 + atmp4 * src3 ) ; final float dst5 = ( atmp0 * src0 + atmp7 * src2 + atmp8 * src3 ) - ( atmp1 * src0 + atmp6 * src2 + atmp9 * src3 ) ; final float dst6 = ( atmp3 * src0 + atmp6 * src1 + atmp11 * src3 ) - ( atmp2 * src0 + atmp7 * src1 + atmp10 * src3 ) ; final float dst7 = ( atmp4 * src0 + atmp9 * src1 + atmp10 * src2 ) - ( atmp5 * src0 + atmp8 * src1 + atmp11 * src2 ) ; final float btmp0 = src2 * src7 ; final float btmp1 = src3 * src6 ; final float btmp2 = src1 * src7 ; final float btmp3 = src3 * src5 ; final float btmp4 = src1 * src6 ; final float btmp5 = src2 * src5 ; final float btmp6 = src0 * src7 ; final float btmp7 = src3 * src4 ; final float btmp8 = src0 * src6 ; final float btmp9 = src2 * src4 ; final float btmp10 = src0 * src5 ; final float btmp11 = src1 * src4 ; final float dst8 = ( btmp0 * src13 + btmp3 * src14 + btmp4 * src15 ) - ( btmp1 * src13 + btmp2 * src14 + btmp5 * src15 ) ; final float dst9 = ( btmp1 * src12 + btmp6 * src14 + btmp9 * src15 ) - ( btmp0 * src12 + btmp7 * src14 + btmp8 * src15 ) ; final float dst10 = ( btmp2 * src12 + btmp7 * src13 + btmp10 * src15 ) - ( btmp3 * src12 + btmp6 * src13 + btmp11 * src15 ) ; final float dst11 = ( btmp5 * src12 + btmp8 * src13 + btmp11 * src14 ) - ( btmp4 * src12 + btmp9 * src13 + btmp10 * src14 ) ; final float dst12 = ( btmp2 * src10 + btmp5 * src11 + btmp1 * src9 ) - ( btmp4 * src11 + btmp0 * src9 + btmp3 * src10 ) ; final float dst13 = ( btmp8 * src11 + btmp0 * src8 + btmp7 * src10 ) - ( btmp6 * src10 + btmp9 * src11 + btmp1 * src8 ) ; final float dst14 = ( btmp6 * src9 + btmp11 * src11 + btmp3 * src8 ) - ( btmp10 * src11 + btmp2 * src8 + btmp7 * src9 ) ; final float dst15 = ( btmp10 * src10 + btmp4 * src8 + btmp9 * src9 ) - ( btmp8 * src9 + btmp11 * src10 + btmp5 * src8 ) ; final float invdet = 1.0f / det ; minv [ minvoffset ] = dst0 * invdet ; minv [ 1 + minvoffset ] = dst1 * invdet ; minv [ 2 + minvoffset ] = dst2 * invdet ; minv [ 3 + minvoffset ] = dst3 * invdet ; minv [ 4 + minvoffset ] = dst4 * invdet ; minv [ 5 + minvoffset ] = dst5 * invdet ; minv [ 6 + minvoffset ] = dst6 * invdet ; minv [ 7 + minvoffset ] = dst7 * invdet ; minv [ 8 + minvoffset ] = dst8 * invdet ; minv [ 9 + minvoffset ] = dst9 * invdet ; minv [ 10 + minvoffset ] = dst10 * invdet ; minv [ 11 + minvoffset ] = dst11 * invdet ; minv [ 12 + minvoffset ] = dst12 * invdet ; minv [ 13 + minvoffset ] = dst13 * invdet ; minv [ 14 + minvoffset ] = dst14 * invdet ; minv [ 15 + minvoffset ] = dst15 * invdet ; return true ; }
va	3	public static void applyshading ( mesh m , view3d view ) { m . ensurevertbuffers ( ) ; m . transformvertices ( m . getmatrix ( ) , null ) ; for ( int i = 0 ; i < m . elements . size ( ) ; i ++ ) { renderable e = m . elem ( i ) ; if ( e . type != renderable_face ) continue ; face f = ( face ) e ; { int a = f . v0 * 3 , b = f . v1 * 3 , c = f . v2 * 3 ; svect . x = m . viewvert [ a + 0 ] - m . viewvert [ c + 0 ] ; svect . y = m . viewvert [ a + 1 ] - m . viewvert [ c + 1 ] ; svect . z = m . viewvert [ a + 2 ] - m . viewvert [ c + 2 ] ; tvect . x = m . viewvert [ b + 0 ] - m . viewvert [ c + 0 ] ; tvect . y = m . viewvert [ b + 1 ] - m . viewvert [ c + 1 ] ; tvect . z = m . viewvert [ b + 2 ] - m . viewvert [ c + 2 ] ; fpoint3 . crossproduct ( svect , tvect , cprod ) ; cprod . normalize ( ) ; double sine = - fpoint3 . dotproduct ( cprod , view . lightdir ( ) ) ; double currlevel = f . getshade ( ) * .75 ; if ( sine > 0 ) { currlevel = ( 1.0 + sine ) * currlevel ; } f . setshade ( ( int ) currlevel ) ; } } }
va	2	public void open ( url location , string referer ) throws ioexception { string host = location . gethost ( ) ; if ( referer == null ) referer = "http://" + host + "/" ; string path = location . getpath ( ) + "?" + location . getquery ( ) ; int port = location . getport ( ) ; if ( port == - 1 ) port = 80 ; socket . setsotimeout ( 5000 ) ; socket . connect ( new inetsocketaddress ( host , port ) , 5000 ) ; printwriter pw = new printwriter ( socket . getoutputstream ( ) , true ) ; pw . println ( "get " + path + " http/1.1" ) ; pw . println ( "host: " + host ) ; pw . println ( "referer: " + referer ) ; pw . println ( "accept: */*" ) ; pw . println ( "user-agent: mozilla/4.0 (compatible; msie 6.0; windows nt 5.1)" ) ; pw . println ( "connection: keep-alive" ) ; pw . println ( ) ; instream = socket . getinputstream ( ) ; getresponse ( ) ; }
va	1	public editor ( ) { logger . info ( "starting editor" ) ; try { db = mysqlconnector . getinstance ( ) ; } catch ( notconfiguredexception | datastoreexception | connectionexception e ) { showerrormessage ( "an error occurred while connecting to the database \n" + "please check your configuration file and the connection to the database." , "database error" ) ; system . exit ( - 2 ) ; } frame . setlayout ( new borderlayout ( ) ) ; mainpanel = new jpanel ( ) ; mainpanel . setlayout ( new boxlayout ( mainpanel , boxlayout . y_axis ) ) ; scrollpane = new jscrollpane ( mainpanel ) ; scrollpane . setverticalscrollbarpolicy ( jscrollpane . vertical_scrollbar_as_needed ) ; scrollpane . sethorizontalscrollbarpolicy ( jscrollpane . horizontal_scrollbar_never ) ; frame . add ( informationpanel , borderlayout . north ) ; frame . add ( scrollpane , borderlayout . center ) ; setupmenu ( ) ; setupenteractionforallbuttons ( ) ; setuplisteners ( ) ; recipesectionpanel section = new recipesectionpanel ( 1 ) ; section . addchangelistener ( this ) ; sections . add ( section ) ; mainpanel . add ( section ) ; scrollpane . setpreferredsize ( new dimension ( 767 , 600 ) ) ; frame . pack ( ) ; frame . setdefaultcloseoperation ( windowconstants . do_nothing_on_close ) ; frame . setvisible ( true ) ; }
va	9	public int getconfig ( int uid , int x , int y , int z ) { ground tile = groundarray [ z ] [ x ] [ y ] ; if ( tile == null ) return - 1 ; if ( tile . wallobject != null && tile . wallobject . uid == uid ) return tile . wallobject . objconf & ff ; if ( tile . walldecoration != null && tile . walldecoration . uid == uid ) return tile . walldecoration . objconf & ff ; if ( tile . grounddecoration != null && tile . grounddecoration . uid == uid ) return tile . grounddecoration . objconf & ff ; for ( int e = 0 ; e < tile . entitycount ; e ++ ) if ( tile . interactiveobjects [ e ] . uid == uid ) return tile . interactiveobjects [ e ] . objconf & ff ; return - 1 ; }
va	1	@ test @ ignore public void havedinner ( ) throws exception { int eattimes = 3 ; int numphilosophers = 5 ; countdownlatch waittillallinitialized = new countdownlatch ( numphilosophers ) ; countdownlatch waittillalldonedining = new countdownlatch ( numphilosophers ) ; atomicinteger availableforks = new atomicinteger ( numphilosophers ) ; list < diningphilosopher > philosophers = new arraylist < > ( ) ; for ( int i = 1 ; i <= numphilosophers ; i ++ ) { diningphilosopher philosopher = new diningphilosopher ( i , availableforks , eattimes , waittillalldonedining ) ; philosophers . add ( philosopher ) ; } immutablelist < diningphilosopher > allphilosophers = new immutablelist < > ( philosophers ) ; philosophers . foreach ( ( diningphilosopher philosopher ) -> { philosopher . start ( allphilosophers , registry . getdefault ( ) ) ; } ) ; waittillalldonedining . await ( ) ; system . out . println ( "all philosophers done each dining " + eattimes + " times" ) ; }
va	7	private void openaddmeterpanel ( ) { boolean failure = false ; string options [ ] = { "create" , "cancel" } ; int result = joptionpane . showoptiondialog ( null , addmeterpanel , "add meter to account " + getselectedaccountid ( ) , joptionpane . default_option , joptionpane . plain_message , null , options , options [ 0 ] ) ; if ( result == 0 ) { meter m = getmeterfromaddmeterpanel ( ) ; account temp = getselectedaccount ( ) ; if ( m != null ) { if ( temp instanceof residentialaccount ) { residentialaccount resacc = ( residentialaccount ) temp ; if ( resacc . getmeter ( ) != null ) { boolean overwrite = confirmresidentialaccountconflict ( ) ; if ( ! overwrite ) return ; } } else if ( temp . hasmeter ( m . getmeterid ( ) ) ) { failure = true ; } } else { failure = true ; } if ( ! failure ) { temp . addmeter ( m ) ; system . out . println ( m . getmeterid ( ) ) ; showmetersinmetertable ( temp ) ; } else { failtocreatemeterdialog ( ) ; } } }
va	3	public void switchfullscreen ( ) { if ( fullscreen == false ) { throw new illegalstateexception ( "this window not supports fullscreen mode!" ) ; } if ( state == windowstate . window ) { rectangle rc = this . getbounds ( ) ; boolean resizable = this . isresizable ( ) ; this . properties = new frameproperties ( getx ( ) , gety ( ) , ( int ) rc . getwidth ( ) , ( int ) rc . getheight ( ) , resizable ) ; } if ( device . getfullscreenwindow ( ) == null ) { frameproperties properties = new frameproperties ( 0 , 0 , getfullwidth ( ) , getfullheight ( ) , false ) ; this . setextendedstate ( jframe . maximized_both ) ; this . state = windowstate . fullscreen ; properties . append ( this ) ; device . setfullscreenwindow ( this ) ; updatedisplay ( ) ; return ; } device . setfullscreenwindow ( null ) ; this . setextendedstate ( jframe . normal ) ; this . state = windowstate . window ; properties . append ( this ) ; updatedisplay ( ) ; }
va	2	private void removeneuron ( int num ) { neuron neuron = ( neuron ) ( currentnetwork . getnode ( num ) ) ; currentnetwork . getneurons ( ) . remove ( neuron ) ; for ( int i = 0 ; i < neuron . getinputs ( ) . size ( ) ; i ++ ) { connection connection = neuron . getinputs ( ) . get ( i ) ; connection . getgiveneuron ( ) . getoutputs ( ) . remove ( connection ) ; currentnetwork . getconnections ( ) . remove ( connection ) ; } for ( int i = 0 ; i < neuron . getoutputs ( ) . size ( ) ; i ++ ) { connection connection = neuron . getoutputs ( ) . get ( i ) ; connection . getrecieveneuron ( ) . getinputs ( ) . remove ( connection ) ; currentnetwork . getconnections ( ) . remove ( connection ) ; } system . out . println ( "neuron :: " + num + " :: was removed" ) ; }
va	0	public static byte [ ] generateauthenticatorserver ( int status , byte [ ] authenticatorclient , string sharekey ) throws nosuchalgorithmexception { byte [ ] keybyte = sharekey . getbytes ( ) ; byte [ ] buf = new byte [ authenticatorclient . length + 4 + keybyte . length ] ; typeconvert . int2byte ( status , buf , 0 ) ; system . arraycopy ( authenticatorclient , 0 , buf , 4 , authenticatorclient . length ) ; system . arraycopy ( keybyte , 0 , buf , 4 + authenticatorclient . length , keybyte . length ) ; return md5 ( buf ) ; }
va	5	private static collection < layer > parselayerargument ( model model , string layersarg ) { collection < layer > lays ; if ( layersarg . equalsignorecase ( "all" ) ) { lays = model . getlayer ( ) ; } else { string [ ] layersarg1 = layersarg . split ( " " ) ; lays = new arraylist < layer > ( ) ; for ( layer lay1 : model . getlayer ( ) ) { for ( string lan : layersarg1 ) { if ( lan . equals ( string . valueof ( lay1 . getnumber ( ) ) ) ) { lays . add ( lay1 ) ; } } } } if ( lays . isempty ( ) ) { system . err . println ( "no matching layers found." ) ; system . exit ( 1 ) ; } return lays ; }
va	5	protected string getnestedusage ( string [ ] args , int level , method method , t player ) throws commandexception { stringbuilder command = new stringbuilder ( ) ; command . append ( "/" ) ; for ( int i = 0 ; i <= level ; ++ i ) { command . append ( args [ i ] + " " ) ; } map < string , method > map = commands . get ( method ) ; boolean found = false ; command . append ( "<" ) ; set < string > allowedcommands = new hashset < string > ( ) ; for ( map . entry < string , method > entry : map . entryset ( ) ) { method childmethod = entry . getvalue ( ) ; found = true ; if ( haspermission ( childmethod , player ) ) { command childcmd = childmethod . getannotation ( command . class ) ; allowedcommands . add ( childcmd . aliases ( ) [ 0 ] ) ; } } if ( allowedcommands . size ( ) > 0 ) { command . append ( stringutil . joinstring ( allowedcommands , "|" , 0 ) ) ; } else { if ( ! found ) { command . append ( "?" ) ; } else { throw new commandpermissionsexception ( ) ; } } command . append ( ">" ) ; return command . tostring ( ) ; }
va	8	public socketthread ( socket skt ) { this . socket = skt ; this . reader = new thread ( new runnable ( ) { @ override public void run ( ) { try { input = new xmlreader ( new bufferedreader ( new inputstreamreader ( socket . getinputstream ( ) , "utf-8" ) ) ) ; } catch ( xmlstreamexception | ioexception e ) { e . printstacktrace ( ) ; return ; } while ( true ) { try { messages . add ( input . readmessage ( ) ) ; fireevent ( ) ; } catch ( xmlstreamexception e ) { if ( thread . interrupted ( ) ) { system . out . println ( "reader closed." ) ; return ; } else { e . printstacktrace ( ) ; } } } } } ) ; this . writer = new thread ( new runnable ( ) { @ override public void run ( ) { try { output = new xmlwriter ( new printwriter ( new outputstreamwriter ( socket . getoutputstream ( ) , "utf-8" ) ) ) ; } catch ( xmlstreamexception | ioexception e ) { e . printstacktrace ( ) ; return ; } while ( true ) { try { message m = msgqueue . take ( ) ; output . writemessage ( m ) ; } catch ( interruptedexception e ) { system . out . println ( "writer closed." ) ; return ; } catch ( xmlstreamexception e ) { e . printstacktrace ( ) ; } } } } ) ; }
va	6	@ override public void doturn ( ) { getlocation ( ) . world . cleartilevisibility ( ) ; for ( int y = getlocation ( ) . y + getviewdistance ( ) ; y >= getlocation ( ) . y - getviewdistance ( ) ; y -- ) { int deltax = getviewdistance ( ) - math . abs ( y - getlocation ( ) . y ) ; for ( int x = getlocation ( ) . x + deltax ; x >= getlocation ( ) . x - deltax ; x -- ) { if ( aicontroller . checkvisibility ( getlocation ( ) , new worldlocation ( null , x , y ) ) ) { getlocation ( ) . world . settilevisible ( x , y , true ) ; } if ( new worldlocation ( getlocation ( ) . world , x , y ) . gettile ( ) instanceof tilesecretdoor ) { int chance = 30 - getstats ( ) . getintelligence ( ) ; if ( chance <= 0 || new random ( ) . nextint ( chance ) == 0 ) { logmessage ( "something about one of the walls nearby seems off to you" ) ; } } } } }
va	8	private void checkfortermination ( int timezone ) { terminationcounter countert = terminationcounters . get ( timezone ) ; logger . info ( "balance: " + countert . getsentmessages ( ) + " / " + countert . getreceivedmessages ( ) ) ; if ( countert . isbalanced ( ) && countert . isnotempty ( ) ) { terminationcounter counterprev = terminationcounters . get ( timezone - 1 ) ; terminationcounter counternext = terminationcounters . get ( timezone + 1 ) ; if ( counterprev != null ) { if ( counterprev . isbalanced ( ) && counterprev . isnotempty ( ) ) { keeprunning = false ; logger . info ( "termination reached! messages sent: " + countert . getsentmessages ( ) + " messages received: " + countert . getreceivedmessages ( ) ) ; } else { if ( counternext != null && counternext . isbalanced ( ) && counternext . isnotempty ( ) ) { keeprunning = false ; logger . info ( "termination reached! messages sent: " + countert . getsentmessages ( ) + " messages received: " + countert . getreceivedmessages ( ) ) ; } } } } }
va	4	private void jbuttoncheckroomsactionperformed ( java . awt . event . actionevent evt ) { dflrooms . removeallelements ( ) ; if ( "" . equals ( jxdatepickercheckroomarrival . geteditor ( ) . gettext ( ) ) || "" . equals ( jxdatepickercheckroomdeparture . geteditor ( ) . gettext ( ) ) ) { joptionpane . showmessagedialog ( rootpane , "make sure both arrival and departure date are entered and in the correct format" ) ; } else { dateformat dateformat = new simpledateformat ( "yyyy-mm-dd" ) ; jxdatepickercheckroomarrival . setformats ( dateformat ) ; jxdatepickercheckroomdeparture . setformats ( dateformat ) ; string arrival = dateformat . format ( jxdatepickercheckroomarrival . getdate ( ) ) . tostring ( ) ; string departure = dateformat . format ( jxdatepickercheckroomdeparture . getdate ( ) ) . tostring ( ) ; r = con . getroomslist ( arrival , departure ) ; if ( r != null ) { for ( int i = 0 ; i < r . size ( ) ; i ++ ) { dflrooms . addelement ( r . get ( i ) . tostring ( ) ) ; } } else { statuslabel . settext ( "could not get rooms" ) ; } con . resetrooms ( ) ; } }
va	4	public static void main ( string [ ] args ) { conn con = poolmanager . getinstance ( ) . getconnection ( ) ; connection conn = con . getconn ( ) ; statement stmt = null ; resultset rs = null ; try { stmt = conn . createstatement ( ) ; rs = stmt . executequery ( "select * from article " ) ; int c = rs . getmetadata ( ) . getcolumncount ( ) ; for ( int i = 1 ; i <= c ; ++ i ) { system . out . println ( rs . getmetadata ( ) . getcolumnname ( i ) ) ; } while ( rs . next ( ) ) { system . out . print ( rs . getstring ( "title" ) ) ; system . out . print ( rs . getstring ( "author" ) ) ; system . out . println ( ) ; } } catch ( sqlexception e ) { e . printstacktrace ( ) ; } finally { try { stmt . close ( ) ; } catch ( sqlexception e ) { e . printstacktrace ( ) ; } poolmanager . getinstance ( ) . releaseconnection ( con ) ; } }
va	0	public worldmap ( mapbaggage baggage ) { planet = new planet ( baggage . polarcircumferenceinkilometers ) ; mesh = new icosahedralmesh ( baggage . meshsize ) ; int numcells = mesh . countcells ( ) ; terrain = porter . stringstoterrain ( baggage . terrainstrings , numcells ) ; bonuses = porter . stringtobits ( baggage . bonusstring , numcells ) ; roads = porter . stringtobits ( baggage . roadstring , numcells ) ; railroads = porter . stringtobits ( baggage . railroadstring , numcells ) ; irrigation = porter . stringtobits ( baggage . irrigationstring , numcells ) ; villages = porter . stringtobits ( baggage . villagestring , numcells ) ; cities = porter . stringtobits ( baggage . citystring , numcells ) ; }
va	7	public registeredeventmonitor ( method monitormethod , listener listener ) { eventmonitor monitorannotation = monitormethod . getannotation ( eventmonitor . class ) ; if ( monitorannotation == null ) { throw new illegalargumentexception ( "monitor method does not have an eventmonitor annotation." ) ; } class < ? > [ ] monitormethodparameters = monitormethod . getparametertypes ( ) ; if ( monitormethodparameters . length != 2 || ! event . class . isassignablefrom ( monitormethodparameters [ 0 ] ) || ! result . class . isassignablefrom ( monitormethodparameters [ 1 ] ) ) { throw new illegalargumentexception ( "monitor method signature is invalid. cannot accept (event  result)." ) ; } eventtype = ( class < ? extends event > ) monitormethodparameters [ 0 ] ; this . monitormethod = monitormethod ; if ( ! monitormethod . isaccessible ( ) ) { monitormethod . setaccessible ( true ) ; } this . listener = listener ; }
va	9	public int bitrate ( int i ) { if ( i >= links ) return ( - 1 ) ; if ( ! seekable && i != 0 ) return ( bitrate ( 0 ) ) ; if ( i < 0 ) { long bits = 0 ; for ( int j = 0 ; j < links ; j ++ ) { bits += ( offsets [ j + 1 ] - dataoffsets [ j ] ) * 8 ; } return ( ( int ) math . rint ( bits / time_total ( - 1 ) ) ) ; } else { if ( seekable ) { return ( ( int ) math . rint ( ( offsets [ i + 1 ] - dataoffsets [ i ] ) * 8 / time_total ( i ) ) ) ; } else { if ( vi [ i ] . bitrate_nominal > 0 ) { return vi [ i ] . bitrate_nominal ; } else { if ( vi [ i ] . bitrate_upper > 0 ) { if ( vi [ i ] . bitrate_lower > 0 ) { return ( vi [ i ] . bitrate_upper + vi [ i ] . bitrate_lower ) / 2 ; } else { return vi [ i ] . bitrate_upper ; } } return ( - 1 ) ; } } } }
va	6	public object stringtovalue ( string text ) throws parseexception { stringtokenizer tokenizer = new stringtokenizer ( text , "." ) ; byte [ ] a = new byte [ 4 ] ; for ( int i = 0 ; i < 4 ; i ++ ) { int b = 0 ; if ( ! tokenizer . hasmoretokens ( ) ) throw new parseexception ( "too few bytes" , 0 ) ; try { b = integer . parseint ( tokenizer . nexttoken ( ) ) ; } catch ( numberformatexception e ) { throw new parseexception ( "not an integer" , 0 ) ; } if ( b < 0 || b >= 256 ) throw new parseexception ( "byte out of range" , 0 ) ; a [ i ] = ( byte ) b ; } if ( tokenizer . hasmoretokens ( ) ) throw new parseexception ( "too many bytes" , 0 ) ; return a ; }
te	0	public static void main ( string [ ] args ) throws exception { predicate < string > predicate = ( s ) -> s . length ( ) > 0 ; predicate . test ( "foo" ) ; predicate . negate ( ) . test ( "foo" ) ; predicate < boolean > nonnull = objects colcol nonnull ; predicate < boolean > isnull = objects colcol isnull ; predicate < string > isempty = string colcol isempty ; predicate < string > isnotempty = isempty . negate ( ) ; function < string , integer > tointeger = integer colcol valueof ; function < string , string > backtostring = tointeger . andthen ( string colcol valueof ) ; backtostring . apply ( "123" ) ; supplier < person > personsupplier = person colcol new ; personsupplier . get ( ) ; consumer < person > greeter = ( p ) -> system . out . println ( "hello  " + p . firstname ) ; greeter . accept ( new person ( "luke" , "skywalker" ) ) ; comparator < person > comparator = ( p1 , p2 ) -> p1 . firstname . compareto ( p2 . firstname ) ; person p1 = new person ( "john" , "doe" ) ; person p2 = new person ( "alice" , "wonderland" ) ; comparator . compare ( p1 , p2 ) ; comparator . reversed ( ) . compare ( p1 , p2 ) ; runnable runnable = ( ) -> system . out . println ( uuid . randomuuid ( ) ) ; runnable . run ( ) ; callable < uuid > callable = uuid colcol randomuuid ; callable . call ( ) ; }
te	2	public int priseterritoire ( territoire t , int nbunite ) { if ( this . nbunitebonus >= nbunite - 1 ) { this . nbunitebonus -= nbunite - 1 ; nbunite = 1 ; } else { nbunite -= this . nbunitebonus ; this . nbunitebonus = 0 ; } this . nbuniteenmain -= nbunite ; t . setnbunite ( nbunite ) ; t . setoccupant ( this ) ; this . territoiresoccupes . add ( t ) ; this . actionpriseterritoire ( t ) ; if ( haspower ( ) ) { this . pouvoir . actionpriseterritoire ( t ) ; } return nbunite ; }
te	7	public static void lockinstance ( int port ) { if ( lockserver == null ) { try { lockserver = new serversocket ( port ) ; new thread ( ) { @ override public void run ( ) { while ( true ) { try { socket socket = lockserver . accept ( ) ; objectinputstream in = new objectinputstream ( socket . getinputstream ( ) ) ; if ( window != null && in . readboolean ( ) ) { window . setvisible ( true ) ; swingutilities . invokelater ( new runnable ( ) { @ override public void run ( ) { window . setvisible ( true ) ; window . tofront ( ) ; window . requestfocus ( ) ; } } ) ; } in . close ( ) ; socket . close ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } } } } . start ( ) ; } catch ( ioexception e ) { try { socket socket = new socket ( strings . getstring ( instancelock . class , "0" ) , port ) ; objectoutputstream out = new objectoutputstream ( socket . getoutputstream ( ) ) ; out . writeboolean ( true ) ; out . close ( ) ; socket . close ( ) ; } catch ( exception e1 ) { } system . exit ( 0 ) ; } } }
te	7	public void sendpinmsg ( ) { message = msgs . gettext ( ) ; subject = subj . gettext ( ) ; httpclient hc = new httpclient ( ) ; hc . getconnectionstring ( ) ; if ( ! appfunctions . ntwkcon ) { uiapplication . getuiapplication ( ) . invokelater ( new runnable ( ) { public void run ( ) { dialog . inform ( "please check your network  pin broadcast requires bis or wifi" ) ; info . settext ( "check your network connection" ) ; } } ) ; } else if ( appfunctions . trialcount < 1 ) { uiapplication . getuiapplication ( ) . invokelater ( new runnable ( ) { public void run ( ) { dialog . inform ( "you have exceeded the number of messages you can send. you have " + appfunctions . trialcount + " left. please buy more messages by selecting the 'buy pin message' menu for information on subscription. select 'verify account' on the menu after subscription to send more messages." ) ; info . settext ( "message number exceeded." ) ; } } ) ; } else if ( contactarray . size ( ) > appfunctions . trialcount ) { uiapplication . getuiapplication ( ) . invokelater ( new runnable ( ) { public void run ( ) { dialog . inform ( "the contacts in your message exceeds what you have left (" + appfunctions . formatnumber ( appfunctions . trialcount , 0 , " " ) + "). please subscribe and select 'verify account' on the menu for unlimited contacts or reduce the number of your contacts to " + appfunctions . formatnumber ( appfunctions . trialcount , 0 , " " ) ) ; } } ) ; } else { if ( message . length ( ) < 5 || subject . length ( ) < 3 || from . gettext ( ) . length ( ) < 2 || filesel == null ) { uiapplication . getuiapplication ( ) . invokelater ( new runnable ( ) { public void run ( ) { dialog . inform ( "please verify that from  subject  message and your contact file has been entered properly before sending this message." ) ; info . settext ( "error in message  please check again." ) ; } } ) ; } else { new thread ( sndmsg ) . start ( ) ; } } }
te	6	public static void main ( string [ ] args ) { rectangle rec = new rectangle ( new mypoint ( 2 , 4 ) , new mypoint ( 4 , 6 ) , new mypoint ( 2 , 4 ) , new mypoint ( 4 , 8 ) ) ; class recclass = rec . getclass ( ) ; field [ ] recfields = recclass . getdeclaredfields ( ) ; method [ ] recmethods = recclass . getdeclaredmethods ( ) ; system . out . println ( "class fields" ) ; for ( field currfield : recfields ) { system . out . println ( currfield . getname ( ) ) ; } system . out . println ( "class methods" ) ; for ( method method : recmethods ) { system . out . println ( method . getname ( ) ) ; } class recsuperclass = recclass . getsuperclass ( ) ; if ( recsuperclass == null ) { system . out . println ( string . format ( "the class %s dose not have a super class" , recclass . getsimplename ( ) ) ) ; } else { system . out . println ( "the super class name is: " + recsuperclass . getsimplename ( ) ) ; system . out . println ( "look for constructors" ) ; constructor [ ] constructors = recsuperclass . getconstructors ( ) ; for ( constructor constructor : constructors ) { system . out . println ( "ctor name: " + constructor . getname ( ) ) ; } system . out . println ( "the class " + recsuperclass . getsimplename ( ) + "" + "is from package " + recsuperclass . getpackage ( ) ) ; } try { class anotherclass = class . forname ( "il.ac.shenkar.point.mypoint" ) ; constructor [ ] constructors = anotherclass . getconstructors ( ) ; system . out . println ( "constructors for: " + anotherclass . getsimplename ( ) ) ; for ( constructor constructor : constructors ) { system . out . println ( constructor ) ; } } catch ( classnotfoundexception e ) { e . printstacktrace ( ) ; } }
te	1	public void loaddata ( dadeshotel hotel ) { titledborder leftborder = borderfactory . createtitledborder ( hotel . nom ) ; leftborder . settitlejustification ( titledborder . left ) ; this . setborder ( leftborder ) ; nomhotel = hotel . nom ; hoteldescriptionlabel . settext ( hotel . desc ) ; defaultlistmodel model = new defaultlistmodel ( ) ; for ( dadeshabitacio hab : hotel . habs ) { string dada = hab . tipushab + " (" + hab . preu + "\u20ac) - " + hab . numerodisp + " disponibles" ; model . addelement ( dada ) ; nomstipus . add ( hab . tipushab ) ; } tipushabitacionslist . setmodel ( model ) ; }
te	0	@ override public arraylist < string > getinsertsql ( ) { arraylist < string > ret = new arraylist < > ( ) ; string sql = "insert into caballoscarrera values (" ; sql += getoid ( ) + "  " ; sql += caballo . getcaballo ( ) . getoid ( ) + "  " ; sql += carrera . getoid ( ) + "  " ; sql += caballo . getnumero ( ) + "  " ; sql += caballo . getdividendo ( ) + "  " ; sql += caballo . gettipoapuesta ( ) . getcodigo ( ) ; sql += ");" ; ret . add ( sql ) ; return ret ; }
te	4	public firstchoicepercent ( algorithmoutput output ) { int total = 0 ; int firsts = 0 ; for ( timeslot t : output . keyset ( ) ) { for ( student s : output . get ( t ) ) { total ++ ; if ( s . getfirstchoicelabs ( ) . contains ( s . getassignedlab ( ) ) ) { firsts ++ ; } } } this . fitness = ( double ) 100 * ( ( double ) firsts / ( double ) total ) ; if ( debug ) { system . out . println ( fitness ) ; } output . addfitness ( "firstchoicepercent" , fitness ) ; }
te	9	public card [ ] pickcards ( selectcardoptions sco , card [ ] allcards ) { gamequery p = new gamequery ( querytype . getcard , querytype . card ) . setobject ( sco ) ; p = query ( p ) ; if ( p == null ) return null ; if ( p . t != querytype . card ) return null ; if ( p . o instanceof card [ ] || p . o instanceof string [ ] ) { string [ ] selected ; if ( p . o instanceof card [ ] ) { arraylist < string > a = new arraylist < string > ( ) ; for ( card c : ( card [ ] ) p . o ) a . add ( c . getname ( ) ) ; selected = a . toarray ( new string [ 0 ] ) ; } else selected = ( string [ ] ) p . o ; arraylist < card > ret = new arraylist < card > ( ) ; arraylist < card > all = new arraylist < card > ( arrays . aslist ( allcards ) ) ; for ( int i = 0 ; i < selected . length ; i ++ ) { for ( int j = 0 ; j < all . size ( ) ; j ++ ) { if ( all . get ( j ) . equals ( selected [ i ] ) ) { ret . add ( all . get ( j ) ) ; all . remove ( j ) ; break ; } } } return ret . toarray ( new card [ 0 ] ) ; } return null ; }
te	3	public list < pattern > findpatternsequalto ( int matchpattern , int matchcount , int [ ] [ ] board ) { list < pattern > resultpatterns = new arraylist < pattern > ( ) ; for ( int i = 0 ; i < board . length ; i ++ ) { for ( int j = 0 ; j < board [ i ] . length ; j ++ ) { list < pattern > result = checkpiecepatterns ( i , j , matchpattern , matchcount , board ) ; if ( result . size ( ) > 0 ) { resultpatterns . addall ( result ) ; } } } return resultpatterns ; }
te	2	private void botoneliminarusuarioactionperformed ( java . awt . event . actionevent evt ) { if ( this . tablaadministracionusuarios . getselectedrow ( ) > - 1 ) { string codigo = ( string ) this . conectortablausuarios . getvalueat ( this . tablaadministracionusuarios . getselectedrow ( ) , 0 ) ; int respuesta = joptionpane . showconfirmdialog ( this . botoneliminarusuario , "\u00bfrealmente desea eliminar \n al usuario " + codigo + "?" , "confirme eliminaci\u00f3n" , joptionpane . yes_no_option , joptionpane . question_message ) ; if ( respuesta == joptionpane . yes_option ) { usuario u = this . modeloapp . obtenerusuarioconcodigo ( codigo ) ; this . modeloapp . eliminarusuario ( u ) ; this . conectortablausuarios . cargarusuarios ( ) ; } } else { joptionpane . showmessagedialog ( this , "debe seleccionar un\nusuario de la tabla" , "usuario no seleccionado" , joptionpane . information_message ) ; } }
te	5	@ test public void testpacketsending ( ) throws socketexception { microsecondstimestamp stamper = mock ( microsecondstimestamp . class ) ; when ( stamper . timestamp ( ) ) . thenreturn ( 0 ) ; utpalgorithm algorithm = new utpalgorithm ( stamper , new inetsocketaddress ( 51235 ) ) ; utpalgconfiguration . send_in_burst = true ; utpalgconfiguration . max_burst_send = 3 ; int packetlength = 1000 ; algorithm . setmaxwindow ( packetlength * 10 ) ; utptimestampedpacketdto pkt5 = createpacket ( 5 , packetlength ) ; utptimestampedpacketdto pkt6 = createpacket ( 6 , packetlength ) ; utptimestampedpacketdto pkt7 = createpacket ( 7 , packetlength ) ; utptimestampedpacketdto pkt8 = createpacket ( 8 , packetlength ) ; utptimestampedpacketdto pkt9 = createpacket ( 9 , packetlength ) ; algorithm . markpacketonfly ( pkt5 . utppacket ( ) , pkt5 . datagram ( ) ) ; algorithm . markpacketonfly ( pkt6 . utppacket ( ) , pkt6 . datagram ( ) ) ; algorithm . markpacketonfly ( pkt7 . utppacket ( ) , pkt7 . datagram ( ) ) ; algorithm . markpacketonfly ( pkt8 . utppacket ( ) , pkt8 . datagram ( ) ) ; algorithm . markpacketonfly ( pkt9 . utppacket ( ) , pkt9 . datagram ( ) ) ; assertequals ( 5 * ( utppacketutils . def_header_length + packetlength ) , algorithm . getcurrentwindow ( ) ) ; for ( int i = 0 ; i < utpalgconfiguration . max_burst_send ; i ++ ) { assertequals ( true , algorithm . cansendnextpacket ( ) ) ; } assertequals ( false , algorithm . cansendnextpacket ( ) ) ; for ( int i = 0 ; i < utpalgconfiguration . max_burst_send ; i ++ ) { assertequals ( true , algorithm . cansendnextpacket ( ) ) ; } assertequals ( false , algorithm . cansendnextpacket ( ) ) ; algorithm . setmaxwindow ( packetlength * 4 ) ; for ( int i = 0 ; i < utpalgconfiguration . max_burst_send ; i ++ ) { assertequals ( false , algorithm . cansendnextpacket ( ) ) ; } for ( int i = 0 ; i < utpalgconfiguration . max_burst_send ; i ++ ) { assertequals ( false , algorithm . cansendnextpacket ( ) ) ; } algorithm . setmaxwindow ( 10 * packetlength ) ; for ( int i = 0 ; i < utpalgconfiguration . max_burst_send ; i ++ ) { assertequals ( true , algorithm . cansendnextpacket ( ) ) ; } assertequals ( false , algorithm . cansendnextpacket ( ) ) ; }
te	4	public klas getklas ( long klas_id ) { klas klas = null ; try { preparedstatement klasstatement = manager . preparestatement ( "select * from klassen where id = ?" ) ; klasstatement . setlong ( 1 , klas_id ) ; resultset klasresult = klasstatement . executequery ( ) ; if ( klasresult . next ( ) ) { klas = new klas ( klasresult . getlong ( 1 ) , klasresult . getstring ( 2 ) ) ; preparedstatement leerlingenklas = manager . preparestatement ( "select leerling_id from leerling_klas where klas_id = ?" ) ; leerlingenklas . setlong ( 1 , klas_id ) ; resultset leerlingids = leerlingenklas . executequery ( ) ; while ( leerlingids . next ( ) ) { klas . addstudent ( getuser ( leerlingids . getlong ( 1 ) ) ) ; } for ( vak vak : getvakkenvanklas ( klas_id ) ) { klas . addvak ( vak ) ; } } } catch ( sqlexception e ) { e . printstacktrace ( ) ; } return klas ; }
te	1	public static byte [ ] decompress ( byte [ ] data ) throws ioexception , dataformatexception { inflater inflater = new inflater ( ) ; inflater . setinput ( data ) ; inflater . finished ( ) ; bytearrayoutputstream outputstream = new bytearrayoutputstream ( data . length ) ; byte [ ] buffer = new byte [ 1024 ] ; while ( ! inflater . finished ( ) ) { int count = inflater . inflate ( buffer ) ; outputstream . write ( buffer , 0 , count ) ; } outputstream . close ( ) ; byte [ ] output = outputstream . tobytearray ( ) ; inflater . end ( ) ; return output ; }
te	6	private list < next > nextstates ( state < c > state ) { int m ; list < transition > nexts = new arraylist < > ( _transitions . get ( state ) ) ; list < next > result = new arraylist < > ( ) ; int offset = 0 ; while ( true ) { m = nextdeadline ( nexts , offset ) ; if ( m != integer . max_value ) { result . add ( selectnextstate ( m - offset , m , nexts ) ) ; offset = m ; } else { switch ( nexts . size ( ) ) { case 0 : throw new runtimeexception ( "automata has no default transition for node: " + state ) ; case 1 : transition target = nexts . get ( 0 ) ; next timeout = new next ( target . timeout ) ; timeout . add ( target . state , target . predicate ) ; result . add ( timeout ) ; break ; default : next infinites = new next ( infinity ) ; for ( transition t : nexts ) { if ( t . timeout != infinity ) throw new runtimeexception ( "cannot mix timeout alternative and infinite guards  neither having more than a single timeout alternative ('" + state + "': " + nexts + ")" ) ; infinites . add ( t . state , t . predicate ) ; } result . add ( infinites ) ; } break ; } } return result ; }
te	8	private static boolean busqueda ( int nt , string extra , string tipo , int pos ) { if ( pos < planes . size ( ) ) { plan p = planes . get ( pos ) ; if ( p . getnumtel ( ) == nt ) return true ; if ( p instanceof planiphone && tipo . equals ( "iphone" ) ) { if ( extra . equals ( ( ( planiphone ) p ) . getemail ( ) ) ) return true ; } if ( p instanceof planblackberry && tipo . equals ( "blackberry" ) ) { if ( extra . equals ( ( ( planblackberry ) p ) . getpin ( ) ) ) return true ; } return busqueda ( nt , extra , tipo , pos + 1 ) ; } return false ; }
te	3	private arrayschema parsearrayschema ( jsonnode rawschema , url schemalocation ) { arrayschema result = new arrayschema ( ) ; jsonnode rawitems = rawschema . get ( "items" ) ; if ( rawitems != null ) { result . setitems ( parse ( rawitems , schemalocation ) ) ; } jsonnode rawminitems = rawschema . get ( "minitems" ) ; if ( rawminitems != null ) { result . setminitems ( rawminitems . intvalue ( ) ) ; } jsonnode rawmaxitems = rawschema . get ( "maxitems" ) ; if ( rawmaxitems != null ) { result . setmaxitems ( rawmaxitems . intvalue ( ) ) ; } return result ; }
te	9	public static method getmostspecificmethod ( method method , class < ? > targetclass ) { if ( method != null && isoverridable ( method , targetclass ) && targetclass != null && ! targetclass . equals ( method . getdeclaringclass ( ) ) ) { try { if ( modifier . ispublic ( method . getmodifiers ( ) ) ) { try { return targetclass . getmethod ( method . getname ( ) , method . getparametertypes ( ) ) ; } catch ( nosuchmethodexception ex ) { return method ; } } else { method specificmethod = reflectionutils . findmethod ( targetclass , method . getname ( ) , method . getparametertypes ( ) ) ; return ( specificmethod != null ? specificmethod : method ) ; } } catch ( securityexception ex ) { } } return method ; }
te	8	public void changepanel ( jpanel panel ) { this . getcontentpane ( ) . removeall ( ) ; if ( panel != loginpanel ) { this . add ( actionbar ) ; if ( panel == connectionpanel ) { connectionpanel . initialize ( ) ; } else if ( panel == directorylistpanel ) { directorylistpanel . initialize ( ) ; } else if ( panel == filelistpanel ) { filelistpanel . initialize ( ) ; } } else { loginpanel . initialize ( ) ; actionbar . initialize ( ) ; } if ( ! actionbar . isbackbtnpress ( ) && currentpanel != panel ) { actionbar . getbackstack ( ) . push ( currentpanel ) ; } else if ( actionbar . isbackbtnpress ( ) && currentpanel != panel ) { actionbar . getforwardstack ( ) . push ( currentpanel ) ; } currentpanel = panel ; this . add ( panel ) ; this . repaint ( ) ; }
te	5	public static bufferedimage getimage ( string filename ) { bufferedimage i = null ; string path = "../images/" ; file f = null ; try { f = new file ( resourceloader . class . getresource ( path + filename ) . getpath ( ) ) ; } catch ( nullpointerexception e ) { console . log ( "file + " + filename + " is not there" , in . error ) ; e . printstacktrace ( ) ; } if ( f != null && f . exists ( ) && ! f . isdirectory ( ) ) { try { i = imageio . read ( r . getclass ( ) . getclassloader ( ) . getresource ( "images/" + filename ) ) ; } catch ( exception e ) { console . log ( "image= " + filename + " is not located here" , console . in . error ) ; e . printstacktrace ( ) ; } } return i ; }
