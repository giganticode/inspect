tr	1	public void addnewelementstohac ( arraylist < commententityds > necommentdsarray , string articleid ) throws exception { docfactory documentfactory = new docfactory ( ) ; docdo document = documentfactory . get ( articleid ) ; arraylist < mapcell > mappingarray = databaseoperations . getarticlemapping ( articleid ) ; arrayofcommentsfactory commentsarrayfactory = new arrayofcommentsfactory ( ) ; arrayofcommentsdo arrayofcommentsdo = null ; arrayofcommentsdo = commentsarrayfactory . get ( articleid ) ; arraylist < comment > nearray = comment . convertcommentsdstocommentsarraylist ( necommentdsarray ) ; double [ ] vector = new double [ databaseoperations . getwordscountforarticle ( articleid ) + 1 ] ; for ( comment ne : nearray ) { comment . nomalizecommentvector ( ne ) ; addnewelementtohac ( ne , articleid , vector , document , mappingarray , arrayofcommentsdo . arrayofcomment ) ; arrayofcommentsdo . arrayofcomment . add ( ne ) ; commentsarrayfactory . save ( arrayofcommentsdo ) ; } domimplementationls domimplementation = ( domimplementationls ) document . doc . getimplementation ( ) ; databaseoperations . setxmlrepresentation ( articleid , domimplementation . createlsserializer ( ) . writetostring ( document . doc ) ) ; databaseoperations . setarticlemapping ( articleid , mappingarray ) ; documentfactory . save ( document ) ; databaseoperations . setcomments ( articleid , necommentdsarray ) ; }
tr	0	public static byte [ ] generateauthenticatorserver ( int status , byte [ ] authenticatorclient , string sharekey ) throws nosuchalgorithmexception { byte [ ] keybyte = sharekey . getbytes ( ) ; byte [ ] buf = new byte [ authenticatorclient . length + 4 + keybyte . length ] ; typeconvert . int2byte ( status , buf , 0 ) ; system . arraycopy ( authenticatorclient , 0 , buf , 4 , authenticatorclient . length ) ; system . arraycopy ( keybyte , 0 , buf , 4 + authenticatorclient . length , keybyte . length ) ; return md5 ( buf ) ; }
tr	7	public static void main ( string [ ] args ) { boolean [ ] primes = new boolean [ size ] ; for ( int i = 2 ; i < size ; i ++ ) primes [ i ] = true ; for ( int i = 2 ; i < size ; i ++ ) if ( primes [ i ] ) for ( int j = 2 ; i * j < size ; j ++ ) primes [ i * j ] = false ; arraylist < integer > primelist = new arraylist < integer > ( ) ; for ( int i = 0 ; i < size ; i ++ ) if ( primes [ i ] ) primelist . add ( i ) ; arraylist < radical > radicals = new arraylist < radical > ( ) ; for ( int i = 0 ; i <= size ; i ++ ) radicals . add ( new radical ( i , primelist ) ) ; radicals = sort ( radicals ) ; system . out . print ( radicals . get ( size / 10 ) . num ) ; }
tr	1	public static void main ( string [ ] args ) { system . out . println ( "primera matriz" ) ; int [ ] [ ] mat1 = leematriz ( ) ; system . out . println ( ) ; system . out . println ( "segunda matriz" ) ; int [ ] [ ] mat2 = leematriz ( ) ; system . out . println ( ) ; int [ ] [ ] producto = null ; try { producto = matrizmul ( mat1 , mat2 ) ; } catch ( arithmeticexception ae ) { system . out . println ( ae . getmessage ( ) ) ; return ; } muestramatriz ( producto ) ; }
tr	5	protected string getnestedusage ( string [ ] args , int level , method method , t player ) throws commandexception { stringbuilder command = new stringbuilder ( ) ; command . append ( "/" ) ; for ( int i = 0 ; i <= level ; ++ i ) { command . append ( args [ i ] + " " ) ; } map < string , method > map = commands . get ( method ) ; boolean found = false ; command . append ( "<" ) ; set < string > allowedcommands = new hashset < string > ( ) ; for ( map . entry < string , method > entry : map . entryset ( ) ) { method childmethod = entry . getvalue ( ) ; found = true ; if ( haspermission ( childmethod , player ) ) { command childcmd = childmethod . getannotation ( command . class ) ; allowedcommands . add ( childcmd . aliases ( ) [ 0 ] ) ; } } if ( allowedcommands . size ( ) > 0 ) { command . append ( stringutil . joinstring ( allowedcommands , "|" , 0 ) ) ; } else { if ( ! found ) { command . append ( "?" ) ; } else { throw new commandpermissionsexception ( ) ; } } command . append ( ">" ) ; return command . tostring ( ) ; }
tr	6	public static class gettype ( class c ) { if ( c == null ) { logger . warn ( "no (typed) class given" ) ; return null ; } class ct = getactualtype ( c . getgenericsuperclass ( ) ) ; if ( ct != null ) return ct ; type [ ] interfaces = c . getgenericinterfaces ( ) ; if ( interfaces == null || interfaces . length == 0 ) return null ; for ( type t : interfaces ) { ct = getactualtype ( t ) ; if ( ct != null ) return ct ; } return null ; }
tr	0	protected void adddatabeans ( ) { list < samplebean > beans = new arraylist < samplebean > ( ) ; beans . add ( new samplebean ( new date ( datereference - 2397984 ) , new integer ( 1 ) , "laptop" , new boolean ( false ) , new integer ( 1 ) , new double ( 799.78 ) ) ) ; beans . add ( new samplebean ( new date ( datereference - 232042098 ) , new integer ( 2 ) , "mouse" , new boolean ( true ) , new integer ( 2 ) , new double ( 49.30 ) ) ) ; beans . add ( new samplebean ( new date ( datereference - 234084277 ) , new integer ( 3 ) , "keyboard" , new boolean ( false ) , new integer ( 5 ) , new double ( 75 ) ) ) ; exporter . addbeanrows ( beans ) ; }
tr	3	protected char [ ] move_array ( char [ ] array , int offset , boolean left ) { int total = array . length ; char [ ] new_array = new char [ total ] ; for ( int i = 0 ; i < total ; i ++ ) { int new_pos ; if ( ! left ) { new_pos = ( i + offset ) % total ; } else { new_pos = ( i - offset ) % total ; if ( new_pos < 0 ) { new_pos += total ; } } new_array [ new_pos ] = array [ i ] ; } return new_array ; }
tr	4	public static void create ( string [ ] args ) { vector < vslfiledatachunk > chunks = null ; if ( args . length < 3 ) { system . err . println ( "missings args: create <dbfile> <source>" ) ; system . exit ( 1 ) ; } source = args [ 2 ] ; try { chunks = handler . chunkfile ( source ) ; vsldatatype < vslfiledatachunk > filedata = new vsldatatype < vslfiledatachunk > ( ) ; stringtokenizer st = new stringtokenizer ( source , "/" ) ; string fname = "unset" ; while ( st . hasmoretokens ( ) ) { fname = st . nexttoken ( ) ; } filedata . setname ( fname ) ; for ( vslfiledatachunk chunk : chunks ) { filedata . addnewchunk ( chunk ) ; } core . addentry ( filedata ) ; core . debugshow ( ) ; core . save ( ) ; } catch ( exception e ) { system . err . println ( "caught exception: " + e . tostring ( ) ) ; e . printstacktrace ( ) ; system . exit ( 1 ) ; } }
tr	7	public static void recovertree ( treenode root ) { int prevalue = integer . min_value ; int currentvalue = integer . min_value ; stack < treenode > stack = new stack < treenode > ( ) ; treenode pre1 = null ; treenode pre2 = null ; treenode cur = root ; treenode prenode = null ; while ( cur != null || ! stack . isempty ( ) ) { while ( cur != null ) { stack . push ( cur ) ; cur = cur . left ; } cur = stack . pop ( ) ; system . out . println ( stack . size ( ) ) ; currentvalue = cur . val ; if ( currentvalue < prevalue ) { if ( pre1 == null ) { pre1 = prenode ; pre2 = cur ; } else { pre2 = cur ; break ; } } prenode = cur ; prevalue = currentvalue ; cur = cur . right ; } if ( pre1 != null && pre2 != null ) { int temp = pre1 . val ; pre1 . val = pre2 . val ; pre2 . val = temp ; } }
tr	6	protected final object computerange ( ) { final list < double [ ] > rarange = new arraylist < double [ ] > ( ) ; final double [ ] decrange = new double [ 2 ] ; if ( this . ispolescollision ( ) ) { decrange [ min ] = simplespectralaccessprotocollibrary . min_value_for_declination ; decrange [ max ] = simplespectralaccessprotocollibrary . max_value_for_declination ; rarange . add ( new double [ ] { simplespectralaccessprotocollibrary . min_value_for_right_ascension , simplespectralaccessprotocollibrary . max_value_for_right_ascension } ) ; } else if ( this . isnorthpolecollision ( ) ) { decrange [ min ] = decuser - sizearray [ 1 ] / 2.0 ; decrange [ max ] = simplespectralaccessprotocollibrary . max_value_for_declination ; rarange . add ( new double [ ] { simplespectralaccessprotocollibrary . min_value_for_right_ascension , simplespectralaccessprotocollibrary . max_value_for_right_ascension } ) ; } else if ( this . issouthpolecollision ( ) ) { decrange [ min ] = simplespectralaccessprotocollibrary . min_value_for_declination ; decrange [ max ] = decuser + sizearray [ 1 ] / 2.0 ; rarange . add ( new double [ ] { simplespectralaccessprotocollibrary . min_value_for_right_ascension , simplespectralaccessprotocollibrary . max_value_for_right_ascension } ) ; } else { decrange [ min ] = decuser - sizearray [ 1 ] / 2.0 ; decrange [ max ] = decuser + sizearray [ 1 ] / 2.0 ; if ( this . isborderracollision ( ) ) { rarange . add ( new double [ ] { simplespectralaccessprotocollibrary . min_value_for_right_ascension , simplespectralaccessprotocollibrary . max_value_for_right_ascension } ) ; } else if ( this . ismaxracollision ( ) ) { rarange . add ( new double [ ] { rauser - sizearray [ 0 ] / 2.0 , simplespectralaccessprotocollibrary . max_value_for_right_ascension } ) ; rarange . add ( new double [ ] { simplespectralaccessprotocollibrary . min_value_for_right_ascension , ( rauser + sizearray [ 0 ] / 2.0 + simplespectralaccessprotocollibrary . max_value_for_right_ascension ) % simplespectralaccessprotocollibrary . max_value_for_right_ascension } ) ; } else if ( this . isminracollision ( ) ) { rarange . add ( new double [ ] { simplespectralaccessprotocollibrary . min_value_for_right_ascension , rauser + sizearray [ 0 ] / 2.0 } ) ; rarange . add ( new double [ ] { ( rauser - sizearray [ 0 ] / 2.0 + simplespectralaccessprotocollibrary . max_value_for_right_ascension ) % simplespectralaccessprotocollibrary . max_value_for_right_ascension , simplespectralaccessprotocollibrary . max_value_for_right_ascension } ) ; } else { rarange . add ( new double [ ] { ( rauser - sizearray [ 0 ] / 2.0 + simplespectralaccessprotocollibrary . max_value_for_right_ascension ) % simplespectralaccessprotocollibrary . max_value_for_right_ascension , ( rauser + sizearray [ 0 ] / 2.0 + simplespectralaccessprotocollibrary . max_value_for_right_ascension ) % simplespectralaccessprotocollibrary . max_value_for_right_ascension } ) ; } } return arrays . aslist ( rarange , decrange ) ; }
tr	0	@ test public void testopen ( ) throws ioexception , jaxbexception , classnotfoundexception , interruptedexception , exception { crrcsim crrcsim = new crrcsimrepository ( ) . restorefromfile ( new file ( "./sample/aerosonde/aerosonde.crr" ) ) ; new crrcsimrepository ( ) . storetofile ( this . file , crrcsim ) ; crrcsim = new crrcsimrepository ( ) . restorefromfile ( this . file ) ; assertequals ( 0.254 , crrcsim . getavl ( ) . getgeometry ( ) . getsurfaces ( ) . get ( 0 ) . getsections ( ) . get ( 0 ) . getchord ( ) , 0.0001 ) ; }
tr	3	public void update ( data ... records ) throws ioexception { intobjectopenhashmap < arraylist < data >> bucketdatamapping = new intobjectopenhashmap < arraylist < data >> ( ) ; int bucketid ; for ( data d : records ) { bucketid = hashfunction . getbucketid ( d . getkey ( ) ) ; if ( ! bucketdatamapping . containskey ( bucketid ) ) { bucketdatamapping . put ( bucketid , new arraylist < data > ( ) ) ; } bucketdatamapping . get ( bucketid ) . add ( d ) ; } for ( intobjectcursor < arraylist < data >> entry : bucketdatamapping ) { updateonlysynchronizer < data > synchronizer = new updateonlysynchronizer < data > ( gp . database_directory + "/" + hashfunction . getfilename ( entry . key ) , gp ) ; @ suppresswarnings ( "unchecked" ) data [ ] toupdate = ( data [ ] ) entry . value . toarray ( new abstractkvstorable [ entry . value . size ( ) ] ) ; arrays . sort ( toupdate , new abstractkvstorablecomparator ( ) ) ; synchronizer . upsert ( toupdate ) ; } }
tr	1	public boolean recepitupdate ( string recepiter , string recepitid , string no , string patientid ) { boolean result = false ; string str = "update recepit_list set receipter='" + recepiter + "'  status='2'   patient_id= '" + patientid + "' where receipt_id='" + recepitid + "' and no='" + no + "';" ; system . out . println ( str ) ; try { conn = dbconn . getconn ( ) ; pstmt = conn . preparestatement ( str ) ; pstmt . executeupdate ( ) ; result = true ; dbconn . close ( conn ) ; return result ; } catch ( sqlexception e ) { e . printstacktrace ( ) ; } return result ; }
tr	1	public static boolean updatekurssi ( kurssi kurssi ) { connection con = connect ( ) ; try { preparedstatement updatekurssi = con . preparestatement ( "update kurssi set nimi=? where kurssiid=?" ) ; updatekurssi . setstring ( 1 , kurssi . getnimi ( ) ) ; updatekurssi . setint ( 2 , kurssi . getid ( ) ) ; updatekurssi . executeupdate ( ) ; return true ; } catch ( sqlexception ex ) { logger . getlogger ( database . class . getname ( ) ) . log ( level . severe , null , ex ) ; return false ; } finally { closeconnection ( con ) ; } }
tr	6	public mainframe ( ) { initcomponents ( ) ; preferences = preferences . userroot ( ) . node ( this . getclass ( ) . getname ( ) ) ; final string pathtopdflatexfile = preferences . get ( "pathtopdflatexfile" , null ) ; final string pathtopdfexportfolder = preferences . get ( "pathtopdfexportfolder" , null ) ; if ( ( pathtopdflatexfile == null ) || ( pathtopdfexportfolder == null ) ) config . initpreferences ( preferences ) ; if ( ( pathtopdflatexfile != null ) && ( ! pathtopdflatexfile . equals ( config . default ) ) ) config . setpdflatexfile ( new file ( pathtopdflatexfile ) ) ; if ( ( pathtopdfexportfolder != null ) && ( ! pathtopdfexportfolder . equals ( config . default ) ) ) config . setpdfexportfolder ( new file ( pathtopdfexportfolder ) ) ; parameterlabelarray = new javax . swing . jlabel [ ] { parameter1label , parameter2label , parameter3label , parameter4label } ; parameterarray = new javax . swing . jtextfield [ ] { parameter1 , parameter2 , parameter3 , parameter4 } ; problempartcomponentsarray = new jcomponent [ ] { useranswerfield , checkbutton , showsolutionlatexbutton , showsolutionplaintextbutton , copytoclipboardbutton , exporttopdfbutton , resetbutton } ; }
tr	1	private void drawcheckerboard ( graphics2d g ) { color backupcolor = g . getcolor ( ) ; stroke backupstroke = g . getstroke ( ) ; g . setcolor ( color . red ) ; g . setstroke ( new basicstroke ( 1.0f ) ) ; g . drawrect ( 0 , 0 , _canvasbackground . getwidth ( ) - 1 , _canvasbackground . getheight ( ) - 1 ) ; for ( int i = 0 ; i < _imagelist . size ( ) ; i ++ ) { iplnode node = _imagelist . get ( i ) ; g . drawrect ( node . getx ( ) , node . gety ( ) , node . getscalewidth ( ) , node . getscaleheight ( ) ) ; } g . setcolor ( backupcolor ) ; g . setstroke ( backupstroke ) ; }
tr	8	private semanticframe sequentialsampling ( semanticframe goldframe , int [ ] goldlbids , srlfeaturedata sfd , int p , tintarraylist args ) { semanticframe predict = new semanticframe ( goldframe ) ; predict . arglbids = new int [ goldlbids . length ] ; for ( int i = 0 , l = predict . arglbids . length ; i < l ; ++ i ) predict . arglbids [ i ] = - 1 ; int n = args . size ( ) , m = sfd . l ; int t = n + m ; boolean [ ] usedrel = new boolean [ t ] ; double [ ] score = new double [ t ] ; for ( int a = 0 ; a < n ; ++ a ) { for ( int r = 0 ; r < t ; ++ r ) { if ( usedrel [ r ] ) { score [ r ] = - double . max_value ; } else { score [ r ] = r < m ? sfd . getarcscore ( goldframe . predid , args . get ( a ) , r ) : nullweight ; if ( addloss ) score [ r ] += loss ( goldlbids [ args . get ( a ) ] , r < m ? r : - 1 ) ; } } int sample = samplepoint ( score , usedrel ) ; usedrel [ sample ] = true ; predict . arglbids [ args . get ( a ) ] = sample < m ? sample : - 1 ; } return predict ; }
tr	2	public hiddenneuron ( double gain , double timeconstant , double bias , double selfweight , double ... sensorweights ) { this . gain = gain ; this . timeconstant = timeconstant ; this . bias = bias ; this . selfweight = selfweight ; this . connections = new arraylist < object [ ] > ( ) ; if ( sensorweights . length != 5 ) try { throw new exception ( "wrong amount of weights passed to constructor!" ) ; } catch ( exception ex ) { logger . getlogger ( hiddenneuron . class . getname ( ) ) . log ( level . severe , null , ex ) ; ex . printstacktrace ( ) ; } this . sensorweights = sensorweights ; }
tr	9	@ override public void statechanged ( changeevent e ) { switch ( ( ( jtabbedpane ) e . getsource ( ) ) . getselectedindex ( ) ) { case my_history : if ( ! changed [ my_history ] ) { changed [ my_history ] = true ; } break ; case my_steps : if ( ! changed [ my_steps ] ) { changed [ my_steps ] = true ; steps . renewchart ( ) ; } break ; case my_achievement : if ( ! changed [ my_achievement ] ) { changed [ my_achievement ] = true ; achievement . update ( ) ; } break ; case our_difference : if ( difference . getoppid ( ) == null ) difference . askforuserid ( ) ; break ; case subonline : submit . askforproid ( ) ; break ; default : break ; } }
tr	9	public static abstractuiitem createitem ( featuretype t , panel panel ) { switch ( t ) { case constant : return new constantuiitem ( panel ) ; case sink : return new sinkuiitem ( panel ) ; case source : return new sourceuiitem ( panel ) ; case saddle : return new saddleuiitem ( panel ) ; case center : return new centeruiitem ( panel ) ; case focus : return new focusuiitem ( panel ) ; case convergingelement : return new convergingelementuiitem ( panel ) ; case divergingelement : return new divergingelementuiitem ( panel ) ; case generic : return new genericuiitem ( panel ) ; } assert false : "unhandled type: " + t ; return null ; }
tr	8	public void changepanel ( jpanel panel ) { this . getcontentpane ( ) . removeall ( ) ; if ( panel != loginpanel ) { this . add ( actionbar ) ; if ( panel == connectionpanel ) { connectionpanel . initialize ( ) ; } else if ( panel == directorylistpanel ) { directorylistpanel . initialize ( ) ; } else if ( panel == filelistpanel ) { filelistpanel . initialize ( ) ; } } else { loginpanel . initialize ( ) ; actionbar . initialize ( ) ; } if ( ! actionbar . isbackbtnpress ( ) && currentpanel != panel ) { actionbar . getbackstack ( ) . push ( currentpanel ) ; } else if ( actionbar . isbackbtnpress ( ) && currentpanel != panel ) { actionbar . getforwardstack ( ) . push ( currentpanel ) ; } currentpanel = panel ; this . add ( panel ) ; this . repaint ( ) ; }
tr	5	private void addfiledroptarget ( composite parent ) { final filetransfer filetransfer = filetransfer . getinstance ( ) ; droptarget target = new droptarget ( parent , dnd . drop_copy | dnd . drop_default ) ; target . settransfer ( new transfer [ ] { filetransfer } ) ; target . adddroplistener ( new droptargetlistener ( ) { public void dragenter ( droptargetevent event ) { if ( event . detail == dnd . drop_default ) { if ( ( event . operations & dnd . drop_copy ) > 0 ) { event . detail = dnd . drop_copy ; } else { event . detail = dnd . drop_none ; } } } public void drop ( droptargetevent event ) { if ( filetransfer . issupportedtype ( event . currentdatatype ) ) { string [ ] files = ( string [ ] ) event . data ; for ( string file : files ) { try { controller . openfile ( file ) ; } catch ( exception e ) { e . printstacktrace ( ) ; displayerrormessage ( "error loading file: " + e . getmessage ( ) ) ; } } } } public void dropaccept ( droptargetevent event ) { } public void dragover ( droptargetevent event ) { } public void dragoperationchanged ( droptargetevent event ) { } public void dragleave ( droptargetevent event ) { } } ) ; }
tr	9	public static string mstostring ( long ms ) { long days = timeunit . milliseconds . todays ( ms ) ; long hours = timeunit . milliseconds . tohours ( ms ) % 24 ; long minutes = timeunit . milliseconds . tominutes ( ms ) % 60 ; long seconds = timeunit . milliseconds . toseconds ( ms ) % 60 ; stringbuffer sb = new stringbuffer ( ) ; boolean secondscondition = true ; boolean minutescondition = seconds != 0 ; boolean hourscondition = minutes != 0 || minutescondition ; boolean dayscondition = hours != 0 || hourscondition ; boolean useddays = appendtobuffer ( sb , days , "%d day" + ( days != 1 ? "s" : "" ) + "  " , dayscondition ) ; boolean usedhours = appendtobuffer ( sb , hours , "%d hour" + ( hours != 1 ? "s" : "" ) + "  " , hourscondition ) ; boolean usedminutes = appendtobuffer ( sb , minutes , "%d minute" + ( minutes != 1 ? "s" : "" ) + "  " , minutescondition ) ; appendtobuffer ( sb , seconds , "%d second" + ( seconds != 1 ? "s" : "" ) , secondscondition ) ; string timestamp = sb . tostring ( ) ; if ( useddays ) return string . format ( timestamp , days , hours , minutes , seconds ) ; if ( usedhours ) return string . format ( timestamp , hours , minutes , seconds ) ; if ( usedminutes ) return string . format ( timestamp , minutes , seconds ) ; return string . format ( timestamp , seconds ) ; }
tr	1	public string format ( string unformattedxml ) { transformerfactory tfactory = transformerfactory . newinstance ( ) ; transformer serializer ; try { serializer = tfactory . newtransformer ( ) ; serializer . setoutputproperty ( outputkeys . encoding , "utf-8" ) ; serializer . setoutputproperty ( outputkeys . indent , "yes" ) ; serializer . setoutputproperty ( "{http://xml.apache.org/xslt}indent-amount" , "4" ) ; element node = parsexmlfile ( unformattedxml ) ; stringwriter out = new stringwriter ( ) ; serializer . transform ( new domsource ( node ) , new streamresult ( out ) ) ; return out . tostring ( ) ; } catch ( transformerexception e ) { e . printstacktrace ( ) ; throw new runtimeexception ( e ) ; } }
tr	1	list < row > fit ( row row ) { list < string > options = piecesof ( row . option , optionwidth ) ; list < string > descriptions = piecesof ( row . description , descriptionwidth ) ; list < row > rows = new arraylist < row > ( ) ; for ( int i = 0 ; i < math . max ( options . size ( ) , descriptions . size ( ) ) ; ++ i ) rows . add ( new row ( itemorempty ( options , i ) , itemorempty ( descriptions , i ) ) ) ; return rows ; }
tr	6	public static void main ( string [ ] args ) { rectangle rec = new rectangle ( new mypoint ( 2 , 4 ) , new mypoint ( 4 , 6 ) , new mypoint ( 2 , 4 ) , new mypoint ( 4 , 8 ) ) ; class recclass = rec . getclass ( ) ; field [ ] recfields = recclass . getdeclaredfields ( ) ; method [ ] recmethods = recclass . getdeclaredmethods ( ) ; system . out . println ( "class fields" ) ; for ( field currfield : recfields ) { system . out . println ( currfield . getname ( ) ) ; } system . out . println ( "class methods" ) ; for ( method method : recmethods ) { system . out . println ( method . getname ( ) ) ; } class recsuperclass = recclass . getsuperclass ( ) ; if ( recsuperclass == null ) { system . out . println ( string . format ( "the class %s dose not have a super class" , recclass . getsimplename ( ) ) ) ; } else { system . out . println ( "the super class name is: " + recsuperclass . getsimplename ( ) ) ; system . out . println ( "look for constructors" ) ; constructor [ ] constructors = recsuperclass . getconstructors ( ) ; for ( constructor constructor : constructors ) { system . out . println ( "ctor name: " + constructor . getname ( ) ) ; } system . out . println ( "the class " + recsuperclass . getsimplename ( ) + "" + "is from package " + recsuperclass . getpackage ( ) ) ; } try { class anotherclass = class . forname ( "il.ac.shenkar.point.mypoint" ) ; constructor [ ] constructors = anotherclass . getconstructors ( ) ; system . out . println ( "constructors for: " + anotherclass . getsimplename ( ) ) ; for ( constructor constructor : constructors ) { system . out . println ( constructor ) ; } } catch ( classnotfoundexception e ) { e . printstacktrace ( ) ; } }
tr	1	public static boolean invertm ( float [ ] minv , int minvoffset , float [ ] m , int moffset ) { final float src0 = m [ moffset + 0 ] ; final float src4 = m [ moffset + 1 ] ; final float src8 = m [ moffset + 2 ] ; final float src12 = m [ moffset + 3 ] ; final float src1 = m [ moffset + 4 ] ; final float src5 = m [ moffset + 5 ] ; final float src9 = m [ moffset + 6 ] ; final float src13 = m [ moffset + 7 ] ; final float src2 = m [ moffset + 8 ] ; final float src6 = m [ moffset + 9 ] ; final float src10 = m [ moffset + 10 ] ; final float src14 = m [ moffset + 11 ] ; final float src3 = m [ moffset + 12 ] ; final float src7 = m [ moffset + 13 ] ; final float src11 = m [ moffset + 14 ] ; final float src15 = m [ moffset + 15 ] ; final float atmp0 = src10 * src15 ; final float atmp1 = src11 * src14 ; final float atmp2 = src9 * src15 ; final float atmp3 = src11 * src13 ; final float atmp4 = src9 * src14 ; final float atmp5 = src10 * src13 ; final float atmp6 = src8 * src15 ; final float atmp7 = src11 * src12 ; final float atmp8 = src8 * src14 ; final float atmp9 = src10 * src12 ; final float atmp10 = src8 * src13 ; final float atmp11 = src9 * src12 ; final float dst0 = ( atmp0 * src5 + atmp3 * src6 + atmp4 * src7 ) - ( atmp1 * src5 + atmp2 * src6 + atmp5 * src7 ) ; final float dst1 = ( atmp1 * src4 + atmp6 * src6 + atmp9 * src7 ) - ( atmp0 * src4 + atmp7 * src6 + atmp8 * src7 ) ; final float dst2 = ( atmp2 * src4 + atmp7 * src5 + atmp10 * src7 ) - ( atmp3 * src4 + atmp6 * src5 + atmp11 * src7 ) ; final float dst3 = ( atmp5 * src4 + atmp8 * src5 + atmp11 * src6 ) - ( atmp4 * src4 + atmp9 * src5 + atmp10 * src6 ) ; final float det = src0 * dst0 + src1 * dst1 + src2 * dst2 + src3 * dst3 ; if ( det == 0.0f ) { return false ; } final float dst4 = ( atmp1 * src1 + atmp2 * src2 + atmp5 * src3 ) - ( atmp0 * src1 + atmp3 * src2 + atmp4 * src3 ) ; final float dst5 = ( atmp0 * src0 + atmp7 * src2 + atmp8 * src3 ) - ( atmp1 * src0 + atmp6 * src2 + atmp9 * src3 ) ; final float dst6 = ( atmp3 * src0 + atmp6 * src1 + atmp11 * src3 ) - ( atmp2 * src0 + atmp7 * src1 + atmp10 * src3 ) ; final float dst7 = ( atmp4 * src0 + atmp9 * src1 + atmp10 * src2 ) - ( atmp5 * src0 + atmp8 * src1 + atmp11 * src2 ) ; final float btmp0 = src2 * src7 ; final float btmp1 = src3 * src6 ; final float btmp2 = src1 * src7 ; final float btmp3 = src3 * src5 ; final float btmp4 = src1 * src6 ; final float btmp5 = src2 * src5 ; final float btmp6 = src0 * src7 ; final float btmp7 = src3 * src4 ; final float btmp8 = src0 * src6 ; final float btmp9 = src2 * src4 ; final float btmp10 = src0 * src5 ; final float btmp11 = src1 * src4 ; final float dst8 = ( btmp0 * src13 + btmp3 * src14 + btmp4 * src15 ) - ( btmp1 * src13 + btmp2 * src14 + btmp5 * src15 ) ; final float dst9 = ( btmp1 * src12 + btmp6 * src14 + btmp9 * src15 ) - ( btmp0 * src12 + btmp7 * src14 + btmp8 * src15 ) ; final float dst10 = ( btmp2 * src12 + btmp7 * src13 + btmp10 * src15 ) - ( btmp3 * src12 + btmp6 * src13 + btmp11 * src15 ) ; final float dst11 = ( btmp5 * src12 + btmp8 * src13 + btmp11 * src14 ) - ( btmp4 * src12 + btmp9 * src13 + btmp10 * src14 ) ; final float dst12 = ( btmp2 * src10 + btmp5 * src11 + btmp1 * src9 ) - ( btmp4 * src11 + btmp0 * src9 + btmp3 * src10 ) ; final float dst13 = ( btmp8 * src11 + btmp0 * src8 + btmp7 * src10 ) - ( btmp6 * src10 + btmp9 * src11 + btmp1 * src8 ) ; final float dst14 = ( btmp6 * src9 + btmp11 * src11 + btmp3 * src8 ) - ( btmp10 * src11 + btmp2 * src8 + btmp7 * src9 ) ; final float dst15 = ( btmp10 * src10 + btmp4 * src8 + btmp9 * src9 ) - ( btmp8 * src9 + btmp11 * src10 + btmp5 * src8 ) ; final float invdet = 1.0f / det ; minv [ minvoffset ] = dst0 * invdet ; minv [ 1 + minvoffset ] = dst1 * invdet ; minv [ 2 + minvoffset ] = dst2 * invdet ; minv [ 3 + minvoffset ] = dst3 * invdet ; minv [ 4 + minvoffset ] = dst4 * invdet ; minv [ 5 + minvoffset ] = dst5 * invdet ; minv [ 6 + minvoffset ] = dst6 * invdet ; minv [ 7 + minvoffset ] = dst7 * invdet ; minv [ 8 + minvoffset ] = dst8 * invdet ; minv [ 9 + minvoffset ] = dst9 * invdet ; minv [ 10 + minvoffset ] = dst10 * invdet ; minv [ 11 + minvoffset ] = dst11 * invdet ; minv [ 12 + minvoffset ] = dst12 * invdet ; minv [ 13 + minvoffset ] = dst13 * invdet ; minv [ 14 + minvoffset ] = dst14 * invdet ; minv [ 15 + minvoffset ] = dst15 * invdet ; return true ; }
tr	7	public static string regexextraction ( string patternstr , string data ) { pattern pattern ; if ( patternstr == null || patternstr . length ( ) == 0 || patternstr . isempty ( ) ) return null ; if ( regexmanager . getinstance ( ) . patternlist . containskey ( patternstr ) ) { pattern = regexmanager . getinstance ( ) . patternlist . get ( patternstr ) ; } else { pattern = pattern . compile ( patternstr ) ; regexmanager . getinstance ( ) . patternlist . put ( patternstr , pattern ) ; } matcher matcher = pattern . matcher ( data ) ; string res = "" ; if ( matcher . find ( ) ) { if ( patternstr . startswith ( parametersetting . regxwordpattern_v2 ) ) { string [ ] array = matcher . group ( 1 ) . split ( " " ) ; res = array [ array . length - 1 ] . replace (   ,   ) . trim ( ) ; } else { string [ ] array = matcher . group ( 1 ) . split ( " " ) ; res = array [ 0 ] . replace (   ,   ) . trim ( ) ; } } if ( stopwordsfilter . getinstance ( ) . isstopwords ( res ) ) return null ; else return res ; }
tr	6	@ suppresswarnings ( "deprecation" ) public static void inserttestdata ( connection databaseconnection ) throws sqlexception { list < student > studentlist = new arraylist < student > ( ) ; studentlist . add ( new student ( "firstname_1" , "lastname_1" , new date ( 80 , 1 , 1 ) , 2.1 ) ) ; studentlist . add ( new student ( "firstname_2" , "lastname_2" , new date ( 80 , 1 , 2 ) , 2.2 ) ) ; studentlist . add ( new student ( "firstname_3" , "lastname_3" , new date ( 80 , 1 , 3 ) , 2.3 ) ) ; studentlist . add ( new student ( "firstname_4" , "lastname_4" , new date ( 80 , 1 , 4 ) , 2.4 ) ) ; studentlist . add ( new student ( "firstname_5" , "lastname_5" , new date ( 80 , 1 , 5 ) , 2.5 ) ) ; studentlist . add ( new student ( "firstname_6" , "lastname_6" , new date ( 80 , 1 , 6 ) , 2.6 ) ) ; studentlist . add ( new student ( "firstname_7" , "lastname_7" , new date ( 80 , 1 , 7 ) , 2.7 ) ) ; studentlist . add ( new student ( "firstname_8" , "lastname_8" , new date ( 80 , 1 , 8 ) , 2.8 ) ) ; preparedstatement preparedstatement = databaseconnection . preparestatement ( "insert into student (firstname  lastname  birthdate  gpa) values (? ? ? ?)" , preparedstatement . return_generated_keys ) ; for ( student student : studentlist ) { preparedstatement . setstring ( 1 , student . firstname ) ; preparedstatement . setstring ( 2 , student . lastname ) ; preparedstatement . setdate ( 3 , student . birthdate ) ; preparedstatement . setdouble ( 4 , student . gpa ) ; preparedstatement . executeupdate ( ) ; resultset resultset = preparedstatement . getgeneratedkeys ( ) ; if ( resultset . next ( ) ) { student . id = resultset . getint ( 1 ) ; } } list < course > courselist = new arraylist < course > ( ) ; courselist . add ( new course ( "course_1" ) ) ; courselist . add ( new course ( "course_2" ) ) ; courselist . add ( new course ( "course_3" ) ) ; courselist . add ( new course ( "course_4" ) ) ; preparedstatement = databaseconnection . preparestatement ( "insert into course (name) values (?)" , preparedstatement . return_generated_keys ) ; for ( course course : courselist ) { preparedstatement . setstring ( 1 , course . name ) ; preparedstatement . executeupdate ( ) ; resultset resultset = preparedstatement . getgeneratedkeys ( ) ; if ( resultset . next ( ) ) { course . id = resultset . getint ( 1 ) ; } } map < integer , string > studentgrademap = new hashmap < integer , string > ( ) ; studentgrademap . put ( 1 , "a" ) ; studentgrademap . put ( 2 , "a-" ) ; studentgrademap . put ( 3 , "b+" ) ; studentgrademap . put ( 4 , "b" ) ; preparedstatement = databaseconnection . preparestatement ( "insert into grade (student_id  course_id  grade) values (? ? ?)" ) ; for ( int i = 0 ; i < courselist . size ( ) ; i ++ ) { for ( int j = 0 ; j < ( i + 1 ) * 2 ; j ++ ) { int studentid = studentlist . get ( j ) . id ; int courseid = courselist . get ( i ) . id ; string grade = studentgrademap . get ( i + 1 ) ; preparedstatement . setint ( 1 , studentid ) ; preparedstatement . setint ( 2 , courseid ) ; preparedstatement . setstring ( 3 , grade ) ; preparedstatement . executeupdate ( ) ; } } }
tr	0	@ override public void paint ( graphics canvas ) { clearcanvas ( canvas ) ; canvas . setcolor ( color . white ) ; canvas . drawline ( 100 , 100 , 600 , 600 ) ; color c = numbergenerator . getcolor ( ) ; canvas . setcolor ( c ) ; canvas . fillrect ( 200 , 200 , 100 , 200 ) ; canvas . setcolor ( color . red ) ; canvas . setfont ( new font ( "tahoma" , font . italic , 30 ) ) ; canvas . drawstring ( "hello world!" , 30 , 60 ) ; }
tr	9	public void evaluatedependencies ( dependencyinstance gold , dependencyinstance pred , boolean evalwithpunc ) { ++ nsents ; int tt = 0 , ua = 0 , la = 0 ; for ( int i = 1 , n = gold . length ; i < n ; ++ i ) { if ( ! evalwithpunc ) if ( gold . forms [ i ] . matches ( "[-!\"%&'()* ./:;?@\\[\\]_{}\u3001]+" ) ) continue ; ++ tt ; if ( gold . heads [ i ] == pred . heads [ i ] ) { ++ ua ; if ( learnlabel && gold . deplbids [ i ] == pred . deplbids [ i ] ) ++ la ; } } tot += tt ; uas += ua ; las += la ; whole += ( tt == ua ) && ( tt == la || ! learnlabel ) ? 1 : 0 ; }
tr	6	private void watchcandidate ( leaderoffer previousoffer ) throws keeperexception , interruptedexception { log . info ( "{} not elected leader. watching node {}" , leaderoffer , previousoffer ) ; stat stat = zookeeper . exists ( previousoffer . getoffer ( ) , new watcher ( ) { public void process ( watchedevent event ) { if ( event . gettype ( ) . equals ( watcher . event . eventtype . nodedeleted ) ) { if ( ! event . getpath ( ) . equals ( leaderelectionservice . this . leaderoffer . getoffer ( ) ) ) { log . debug ( "node {} deleted. need to run through the election process." , event . getpath ( ) ) ; try { determine ( ) ; } catch ( keeperexception e ) { failed ( e ) ; } catch ( interruptedexception e ) { failed ( e ) ; } } } } } ) ; if ( stat != null ) { log . info ( "becoming follower with node {}  we're watching {}" , leaderoffer , previousoffer ) ; if ( leaderelectionaware != null ) { leaderelectionaware . onfollower ( leaderoffer ) ; } } else { log . debug ( "we were behind {} but it looks like died. back to determination." , previousoffer ) ; determine ( ) ; } }
tr	9	@ override public paginationsupport < t > handle ( resultset rs ) throws sqlexception { paginationsupport < t > ps = new paginationsupport < t > ( ) ; int cur = rsl . getstartpage ( ) * rsl . getpagesize ( ) + 1 ; boolean atlast = false ; if ( cur > 1 ) { if ( ! rs . absolute ( cur - 1 ) ) { atlast = true ; } } list < t > ls = new arraylist < t > ( ) ; int count = 0 ; if ( atlast ) { count = - 1 ; } else { atlast = true ; while ( rs . next ( ) ) { ls . add ( rowprocessor . tobean ( rs , pojotype ) ) ; if ( ls . size ( ) >= rsl . getpagesize ( ) ) { atlast = false ; break ; } } } if ( atlast ) { if ( count == - 1 ) { count = 0 ; } else { count = cur - 1 + ls . size ( ) ; } } else { if ( rs . last ( ) ) { count = rs . getrow ( ) ; } else { count = 0 ; } } ps . setobject ( ls ) ; ps . setcurrentpage ( rsl . getstartpage ( ) ) ; ps . setpagecount ( ( int ) ( count / rsl . getpagesize ( ) + ( count % rsl . getpagesize ( ) > 0 ? 1 : 0 ) ) ) ; ps . setpagesize ( rsl . getpagesize ( ) ) ; ps . settotalcount ( count ) ; return ps ; }
tr	5	@ override public object visit ( astattr_stmt node , object data ) { commonprocessing ( node , this ) ; if ( node . jjtgetvalue ( ) . equals ( "node" ) ) { for ( int i = 0 ; i < node . jjtgetnumchildren ( ) ; i ++ ) { node child = node . jjtgetchild ( i ) ; if ( child instanceof astattr_list ) { string childnodeshape = ( string ) child . jjtaccept ( this , data ) ; if ( childnodeshape . equals ( "doublecircle" ) || childnodeshape . equals ( "box" ) ) this . accept = true ; else this . accept = false ; } else { child . jjtaccept ( this , data ) ; } } } else node . childrenaccept ( this , data ) ; return null ; }
tr	1	public static byte [ ] decompress ( byte [ ] data ) throws ioexception , dataformatexception { inflater inflater = new inflater ( ) ; inflater . setinput ( data ) ; inflater . finished ( ) ; bytearrayoutputstream outputstream = new bytearrayoutputstream ( data . length ) ; byte [ ] buffer = new byte [ 1024 ] ; while ( ! inflater . finished ( ) ) { int count = inflater . inflate ( buffer ) ; outputstream . write ( buffer , 0 , count ) ; } outputstream . close ( ) ; byte [ ] output = outputstream . tobytearray ( ) ; inflater . end ( ) ; return output ; }
tr	5	public void clicked ( vec2f gameposition ) { vec2i mapposition = new vec2i ( ( int ) ( gameposition . x / square_size ) , ( int ) ( gameposition . y / square_size ) ) ; if ( isplayerunit ( mapposition ) ) { unit unit = units . get ( mapposition ) ; unit . select ( ) ; if ( selected != null && ! selected . equals ( unit ) ) { selected . unselect ( ) ; } selected = unit ; } else { if ( selected != null && ispassable ( mapposition ) ) { getpathto ( selected , mapposition ) ; } } }
tr	2	private void style2rule ( lexer lexer , node node ) { attval styleattr , classattr ; string classname ; styleattr = node . getattrbyname ( "style" ) ; if ( styleattr != null ) { classname = findstyle ( lexer , node . element , styleattr . value ) ; classattr = node . getattrbyname ( "class" ) ; if ( classattr != null ) { classattr . value = classattr . value + " " + classname ; node . removeattribute ( styleattr ) ; } else { styleattr . attribute = "class" ; styleattr . value = classname ; } } }
tr	3	public list < hostel > getavailablebedsinallhostels ( date startdate , date enddate ) { list < hostel > hostels = null ; if ( startdate . after ( enddate ) ) { return null ; } calendar cal = calendar . getinstance ( ) ; cal . settime ( new java . util . date ( ) ) ; if ( startdate . before ( cal . gettime ( ) ) ) { return null ; } try { hostels = hosteldaoimpl . getavailablebedsinallhostels ( startdate , enddate ) ; } catch ( servicelocatorexception | sqlexception e ) { e . printstacktrace ( ) ; } return hostels ; }
tr	8	@ suppresswarnings ( "unchecked" ) @ transactional public list < merchant > getmerchantlist ( string merchantname , string sortby , string sortorder ) throws exception { list < merchant > lstmerchants = new arraylist < merchant > ( ) ; session session = null ; criteria criteriaobj = null ; logger . info ( "merchantname---------->" + merchantname ) ; logger . info ( "sortby--------------->" + sortby ) ; logger . info ( "sortorder------------>" + sortorder ) ; string sname = merchantname ; try { session = sessionfactory . getcurrentsession ( ) ; logger . info ( "entered into getmerchantlist()--->" ) ; logger . info ( "retrieving all merchants" ) ; if ( session != null ) { criteriaobj = session . createcriteria ( merchant . class ) ; if ( merchantname != null ) { logger . info ( "retrieving  merchants based on name" ) ; criteriaobj . add ( restrictions . ilike ( "sname" , "%" + sname + "%" ) ) ; criteriaobj . add ( restrictions . = ( "bdeletedflag" , false ) ) ; } lstmerchants = criteriaobj . list ( ) ; logger . info ( "lstmerchants from dao----------->" + lstmerchants . size ( ) ) ; } if ( sortby != null && sortorder == "asc" ) { logger . info ( "retrieving  merchants based on ascending sort order for " + sortby ) ; lstmerchants = criteriaobj . addorder ( order . asc ( sortby ) ) . list ( ) ; logger . info ( "lstmerchants size-------->" + lstmerchants . size ( ) ) ; } if ( sortby != null && sortorder == "desc" ) { logger . info ( "retrieving  merchants based on descending sort order for " + sortby ) ; lstmerchants = criteriaobj . addorder ( order . desc ( sortby ) ) . list ( ) ; logger . info ( "lstmerchants size-------->" + lstmerchants . size ( ) ) ; } iterator < merchant > it = lstmerchants . iterator ( ) ; while ( it . hasnext ( ) ) { merchant merchant = it . next ( ) ; system . out . println ( "dao......." + merchant ) ; } } catch ( exception e ) { e . printstacktrace ( ) ; logger . error ( "exception occured in getmerchantlist()--->" + e . getmessage ( ) ) ; throw new exception ( "exception occured in getmerchantlist()--->" + e . getmessage ( ) ) ; } return lstmerchants ; }
tr	7	public boolean iscallablereference ( class clazz ) { if ( this == globalbridge ) { return false ; } if ( ! referencesenabled ) { return false ; } if ( callablereferenceset . contains ( clazz ) ) { return true ; } class [ ] interfaces = clazz . getinterfaces ( ) ; for ( int i = 0 ; i < interfaces . length ; i ++ ) { if ( callablereferenceset . contains ( interfaces [ i ] ) ) { return true ; } } class superclass = clazz . getsuperclass ( ) ; while ( superclass != null ) { if ( callablereferenceset . contains ( superclass ) ) { return true ; } superclass = superclass . getsuperclass ( ) ; } return globalbridge . iscallablereference ( clazz ) ; }
tr	1	public actiondialog ( skyquestutility util , jcomponent parent ) { super ( util , true ) ; this . util = util ; this . parent = parent ; save = new jbutton ( "save" ) ; cancel = new jbutton ( "cancel" ) ; amodel = new defaultlistmodel < actiontype > ( ) ; atypes = new jlist < actiontype > ( amodel ) ; for ( actiontype a : questmanager . getinstance ( ) . getregisteredactiontypes ( ) ) amodel . addelement ( a ) ; setlayout ( new borderlayout ( ) ) ; jpanel buttons = new jpanel ( ) ; buttons . setlayout ( new boxlayout ( buttons , boxlayout . x_axis ) ) ; buttons . add ( save ) ; buttons . add ( cancel ) ; jpanel ap = new jpanel ( ) ; ap . setlayout ( new borderlayout ( ) ) ; ap . add ( "center" , atypes ) ; ap . add ( "north" , new jlabel ( "type" ) ) ; add ( "south" , buttons ) ; cancel . addactionlistener ( this ) ; save . addactionlistener ( this ) ; }
tr	5	@ override public void run ( ) { while ( true ) { try { for ( blocklocationpair p : deletionqueue ) { string nodelocation = p . nodelocation ; string blockname = p . blockname ; string [ ] ipport ; try { ipport = addresstoipport . addresstoipport ( nodelocation ) ; message inputmessage = new message ( "remove" ) ; inputmessage . filename = blockname ; communicator . sendmessage ( ipport [ 0 ] , integer . parseint ( ipport [ 1 ] ) , inputmessage ) ; } catch ( numberformatexception | ioexception e ) { e . printstacktrace ( ) ; throw new ioexception ( "could not delete distributed file block " + blockname + "\n " + e . getmessage ( ) ) ; } } } catch ( exception e ) { logger . log ( "error encountered while deleting distributed file: " + e . getmessage ( ) ) ; e . printstacktrace ( ) ; } try { thread . sleep ( 3000 ) ; } catch ( interruptedexception e ) { e . printstacktrace ( ) ; } } }
tr	3	public double getdistanceab ( arraylist < object > path ) { arraylist < object > nodes ; double distance = 0.0 ; for ( int i = 0 ; i < path . size ( ) - 1 ; i ++ ) { nodes = new arraylist < object > ( ) ; nodes . add ( path . get ( i ) ) ; nodes . add ( path . get ( i + 1 ) ) ; for ( road road : roads ) { if ( road . getnodesattached ( ) . containsall ( nodes ) ) { distance += road . getdistance ( ) ; } } } distance = utilcalc . round ( distance , 2 ) ; return distance ; }
tr	9	public static void main ( string argv [ ] ) { try { if ( argv . length != 1 ) { system . err . println ( "usbd [ start | stop ]" ) ; system . exit ( 1 ) ; } if ( "start" . equals ( argv [ 0 ] ) ) { host host = hostfactory . gethost ( ) ; if ( host == null ) { system . err . println ( "usbd:  usb is not available." ) ; system . exit ( 1 ) ; } if ( host instanceof remote ) { system . err . println ( "usbd: proxy already registered" ) ; system . exit ( 1 ) ; } try { hostproxy proxy = new hostproxy ( host ) ; naming . bind ( rminame , proxy ) ; system . err . println ( "usbd:  bound rmi name " + rminame ) ; } catch ( exception e ) { system . err . println ( "usbd:  couldn't bind to: " + rminame ) ; if ( debug ) e . printstacktrace ( ) ; else system . err . println ( e . getmessage ( ) ) ; } } else if ( "stop" . equals ( argv [ 0 ] ) ) { system . err . println ( "usbd: no 'stop' yet ... " + "use 'ps' and 'kill' for now" ) ; } else { system . err . println ( "usbd: no '" + argv [ 0 ] + "' command" ) ; system . exit ( 1 ) ; } } catch ( exception e ) { if ( debug ) e . printstacktrace ( ) ; else system . err . println ( e . getmessage ( ) ) ; } }
tr	5	private static collection < layer > parselayerargument ( model model , string layersarg ) { collection < layer > lays ; if ( layersarg . equalsignorecase ( "all" ) ) { lays = model . getlayer ( ) ; } else { string [ ] layersarg1 = layersarg . split ( " " ) ; lays = new arraylist < layer > ( ) ; for ( layer lay1 : model . getlayer ( ) ) { for ( string lan : layersarg1 ) { if ( lan . equals ( string . valueof ( lay1 . getnumber ( ) ) ) ) { lays . add ( lay1 ) ; } } } } if ( lays . isempty ( ) ) { system . err . println ( "no matching layers found." ) ; system . exit ( 1 ) ; } return lays ; }
tr	4	public void testfilecontent ( ) throws ioexception { long start = system . currenttimemillis ( ) ; byte [ ] buf1 = new byte [ 1024 ] ; byte [ ] buf2 = new byte [ 1024 ] ; int size1 , size2 ; string filename1 = "test1.class" ; string filename2 = "test2.class" ; file file1 = new file ( filename1 ) ; file file2 = new file ( filename2 ) ; bufferedinputstream bis1 = new bufferedinputstream ( new fileinputstream ( file1 ) ) ; bufferedinputstream bis2 = new bufferedinputstream ( new fileinputstream ( file2 ) ) ; polynomial polynomial = polynomial . createirreducible ( 53 ) ; fingerprint < polynomial > rabin1 = new rabinfingerprintlong ( polynomial ) ; fingerprint < polynomial > rabin2 = new rabinfingerprintlong ( polynomial ) ; while ( ( ( size1 = bis1 . read ( buf1 ) ) != - 1 ) && ( ( size2 = bis2 . read ( buf2 ) ) != - 1 ) ) { rabin1 . pushbytes ( buf1 ) ; rabin2 . pushbytes ( buf2 ) ; string s1 = new string ( buf1 ) ; string s2 = new string ( buf2 ) ; if ( rabin1 . getfingerprint ( ) . compareto ( rabin2 . getfingerprint ( ) ) != 0 ) { system . out . println ( "file 1 and file 2 are different!" ) ; break ; } } if ( rabin1 . getfingerprint ( ) . compareto ( rabin2 . getfingerprint ( ) ) == 0 ) system . out . println ( "file 1 and file 2 are the same!" ) ; long end = system . currenttimemillis ( ) ; system . out . println ( "time: " + ( end - start ) + "ms." ) ; assertequals ( 0 , rabin1 . getfingerprint ( ) . compareto ( rabin2 . getfingerprint ( ) ) ) ; }
tr	9	@ suppresswarnings ( "deprecation" ) @ override public void run ( ) { while ( areanythreadsalive ( threadgroup ) ) { if ( ! firstexceptionthrown . isempty ( ) ) { for ( thread t : getthreads ( threadgroup ) ) { if ( t . isalive ( ) ) t . stop ( ) ; } } else if ( areanythreadsrunning ( threadgroup ) ) { if ( system . currenttimemillis ( ) - lastprogress > 1000 * maxruntime ) timeout ( ) ; } else if ( clock . isanythreadwaitingforabeat ( ) ) { clock . advance ( ) ; deadlockcount = 0 ; lastprogress = system . currenttimemillis ( ) ; } else if ( ! areanythreadsintimedwaiting ( threadgroup ) ) { detectdeadlock ( ) ; } try { thread . sleep ( clockperiod ) ; } catch ( interruptedexception e ) { e . printstacktrace ( ) ; } } }
tr	4	public void run ( ) { if ( logger . getdebugvalue ( ) == 3 ) { system . out . println ( "run() of " + thread . currentthread ( ) . getname ( ) + " is called." ) ; } string word ; set < musicinfo > info_found ; while ( ( word = readfile . readwordfromsearchfile ( ) ) != null ) { info_found = store . find ( word ) ; if ( info_found != null ) { iterator < musicinfo > iter = info_found . iterator ( ) ; while ( iter . hasnext ( ) ) { results . add ( iter . next ( ) ) ; } } } }
tr	4	renderercontext ( final string name ) { if ( log_create_context ) { marlinutils . loginfo ( "new renderercontext = " + name ) ; } this . name = name ; npcpathiterator = new normalizingpathiterator . nearestpixelcenter ( float6 ) ; npqpathiterator = new normalizingpathiterator . nearestpixelquarter ( float6 ) ; transformerpc2d = new transformingpathconsumer2d ( ) ; cache = new marlincache ( this ) ; renderer = new renderer ( this ) ; ptg = new marlintilegenerator ( renderer ) ; stroker = new stroker ( this ) ; dasher = new dasher ( this ) ; switch ( marlinrenderingengine . ref_type ) { default : case marlinrenderingengine . ref_hard : reference = this ; break ; case marlinrenderingengine . ref_soft : reference = new softreference < renderercontext > ( this ) ; break ; case marlinrenderingengine . ref_weak : reference = new weakreference < renderercontext > ( this ) ; break ; } }
tr	6	public static map < string , boolean > getallchildren ( final string node , final set < string > playerpermarray ) { final linkedlist < string > stack = new linkedlist < string > ( ) ; final map < string , boolean > alreadyvisited = new hashmap < string , boolean > ( ) ; stack . push ( node ) ; alreadyvisited . put ( node , true ) ; while ( ! stack . isempty ( ) ) { final string now = stack . pop ( ) ; final map < string , boolean > children = adminperms . getchildren ( now ) ; if ( children != null && ! playerpermarray . contains ( "-" + now ) ) { for ( final string childname : children . keyset ( ) ) { if ( ! alreadyvisited . containskey ( childname ) ) { stack . push ( childname ) ; alreadyvisited . put ( childname , children . get ( childname ) ) ; } } } } alreadyvisited . remove ( node ) ; if ( ! alreadyvisited . isempty ( ) ) { return alreadyvisited ; } return null ; }
tr	4	public static strooptest createrandomcolourtest ( int wordsize , testtype type ) { list < word > words = new arraylist < word > ( wordsize ) ; random randomizer = new random ( system . currenttimemillis ( ) ) ; for ( int i = 0 ; i < wordsize ; i ++ ) { int next = randomizer . nextint ( 2 ) ; switch ( next ) { case 0 : { words . add ( wordfactory . createrandomplaincolourword ( ) ) ; break ; } case 1 : { words . add ( wordfactory . createrandomcolourword ( ) ) ; break ; } case 2 : { words . add ( wordfactory . createrandommixedcolourword ( ) ) ; break ; } } } return new strooptest ( words , type , "random" , "" ) ; }
tr	2	tester ( long _seed ) throws exception { loadwords ( ) ; setseed ( _seed ) ; setdefaultcloseoperation ( exit_on_close ) ; c = new testercanvas ( ) ; c . setpreferredsize ( new dimension ( 600 , 400 ) ) ; container cp = getcontentpane ( ) ; cp . setlayout ( new borderlayout ( ) ) ; cp . add ( c , borderlayout . center ) ; cp . add ( c . seedtext , borderlayout . north ) ; jpanel jp = new jpanel ( ) ; jbutton e = new jbutton ( "english" ) ; e . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent arg0 ) { int index = r . nextint ( ewords . size ( ) ) ; string word = ewords . get ( index ) ; c . english = word ; c . portuguese = null ; count ++ ; c . repaint ( ) ; } } ) ; jbutton p = new jbutton ( "portuguese" ) ; p . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent arg0 ) { int index = r . nextint ( pwords . size ( ) ) ; system . out . println ( "index = " + index ) ; string word = pwords . get ( index ) ; c . english = null ; c . portuguese = word ; count ++ ; c . repaint ( ) ; } } ) ; jbutton t = new jbutton ( "translate" ) ; t . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent arg0 ) { if ( c . english != null ) { c . portuguese = e2p . get ( c . english ) ; } else if ( c . portuguese != null ) { c . english = p2e . get ( c . portuguese ) ; } c . repaint ( ) ; } } ) ; jbutton r = new jbutton ( "reset" ) ; r . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent e ) { setseed ( seed ) ; c . repaint ( ) ; } } ) ; jp . setlayout ( new flowlayout ( ) ) ; jp . add ( e ) ; jp . add ( t ) ; jp . add ( p ) ; jp . add ( r ) ; cp . add ( jp , borderlayout . south ) ; pack ( ) ; setvisible ( true ) ; }
tr	1	public messagecomponent ( client client ) { addmouselistener ( new mouseadapter ( ) { @ override public void mouseentered ( mouseevent arg0 ) { enter ( ) ; } @ override public void mouseexited ( mouseevent e ) { exit ( ) ; } } ) ; try { uimanager . setlookandfeel ( uimanager . getsystemlookandfeelclassname ( ) ) ; } catch ( exception e ) { } this . client = client ; setbackground ( color . white ) ; setborder ( new matteborder ( 0 , 0 , 1 , 0 , ( color ) color . light_gray ) ) ; setlayout ( new borderlayout ( 5 , 10 ) ) ; leftpanel = new jpanel ( ) ; leftpanel . setbackground ( color . white ) ; add ( leftpanel , borderlayout . west ) ; iconlabel = new jlabel ( "" ) ; iconlabel . sethorizontalalignment ( swingconstants . center ) ; iconlabel . seticon ( new imageicon ( "c:\\users\\umut\\desktop\\darth_vader_icon_64x64_by_geo_almighty-d33pmvd.png" ) ) ; leftpanel . add ( iconlabel ) ; centerpanel = new jpanel ( ) ; centerpanel . setbackground ( color . white ) ; add ( centerpanel , borderlayout . center ) ; centerpanel . setlayout ( new boxlayout ( centerpanel , boxlayout . y_axis ) ) ; panel_3 = new jpanel ( ) ; panel_3 . setbackground ( color . white ) ; centerpanel . add ( panel_3 ) ; panel_3 . setlayout ( new gridlayout ( 0 , 1 , 0 , 10 ) ) ; username = new jlabel ( "user name" ) ; username . sethorizontalalignment ( swingconstants . left ) ; username . setforeground ( new color ( 0 , 0 , 0 ) ) ; username . setbackground ( color . white ) ; username . setfont ( new font ( "segoe ui" , font . bold , 13 ) ) ; panel_3 . add ( username ) ; txtrmessagetext = new jtextarea ( ) ; txtrmessagetext . setlinewrap ( true ) ; txtrmessagetext . addmouselistener ( new mouseadapter ( ) { @ override public void mouseentered ( mouseevent arg0 ) { enter ( ) ; } @ override public void mouseexited ( mouseevent e ) { exit ( ) ; } } ) ; txtrmessagetext . setforeground ( color . dark_gray ) ; txtrmessagetext . setfont ( new font ( "segoe ui" , font . plain , 11 ) ) ; txtrmessagetext . seteditable ( false ) ; txtrmessagetext . settext ( "messagetext" ) ; txtrmessagetext . setborder ( null ) ; centerpanel . add ( txtrmessagetext ) ; txtrreplytext = new jtextarea ( ) ; txtrreplytext . setlinewrap ( true ) ; txtrreplytext . addmouselistener ( new mouseadapter ( ) { @ override public void mouseentered ( mouseevent arg0 ) { enter ( ) ; } @ override public void mouseexited ( mouseevent e ) { exit ( ) ; } } ) ; txtrreplytext . setfont ( new font ( "segoe ui" , font . plain , 11 ) ) ; txtrreplytext . settext ( "replytext" ) ; txtrreplytext . seteditable ( false ) ; txtrreplytext . setforeground ( new color ( 128 , 0 , 0 ) ) ; txtrreplytext . setvisible ( false ) ; txtrreplytext . setborder ( null ) ; centerpanel . add ( txtrreplytext ) ; southpanel = new jpanel ( ) ; southpanel . setbackground ( color . white ) ; add ( southpanel , borderlayout . south ) ; southpanel . setlayout ( new boxlayout ( southpanel , boxlayout . x_axis ) ) ; panel = new jpanel ( ) ; panel . setbackground ( color . white ) ; flowlayout flowlayout_1 = ( flowlayout ) panel . getlayout ( ) ; flowlayout_1 . setalignment ( flowlayout . right ) ; southpanel . add ( panel ) ; panel_1 = new jpanel ( ) ; panel_1 . setborder ( null ) ; panel_1 . setbackground ( color . white ) ; flowlayout flowlayout = ( flowlayout ) panel_1 . getlayout ( ) ; flowlayout . sethgap ( 20 ) ; flowlayout . setalignment ( flowlayout . right ) ; southpanel . add ( panel_1 ) ; lblnewlabel_1 = new jlabel ( " " ) ; lblnewlabel_1 . setfont ( new font ( "tahoma" , font . plain , 25 ) ) ; panel_1 . add ( lblnewlabel_1 ) ; jlabel lblnewlabel = new jlabel ( " " ) ; lblnewlabel . setfont ( new font ( "tahoma" , font . plain , 22 ) ) ; panel_1 . add ( lblnewlabel ) ; datelabel = new jlabel ( "10.10.2010" ) ; datelabel . setvisible ( false ) ; panel_1 . add ( datelabel ) ; btnnewbutton = new jbutton ( " reply" ) ; btnnewbutton . setvisible ( false ) ; btnnewbutton . addmouselistener ( new mouseadapter ( ) { @ override public void mouseclicked ( mouseevent e ) { replypost ( ) ; } @ override public void mouseentered ( mouseevent arg0 ) { enter ( ) ; } } ) ; btnnewbutton . seticon ( new imageicon ( "c:\\users\\umut\\desktop\\reply_icon.gif" ) ) ; panel_1 . add ( btnnewbutton ) ; panel_2 = new jpanel ( ) ; panel_2 . setbackground ( color . white ) ; add ( panel_2 , borderlayout . east ) ; }
tr	1	public editor ( ) { logger . info ( "starting editor" ) ; try { db = mysqlconnector . getinstance ( ) ; } catch ( notconfiguredexception | datastoreexception | connectionexception e ) { showerrormessage ( "an error occurred while connecting to the database \n" + "please check your configuration file and the connection to the database." , "database error" ) ; system . exit ( - 2 ) ; } frame . setlayout ( new borderlayout ( ) ) ; mainpanel = new jpanel ( ) ; mainpanel . setlayout ( new boxlayout ( mainpanel , boxlayout . y_axis ) ) ; scrollpane = new jscrollpane ( mainpanel ) ; scrollpane . setverticalscrollbarpolicy ( jscrollpane . vertical_scrollbar_as_needed ) ; scrollpane . sethorizontalscrollbarpolicy ( jscrollpane . horizontal_scrollbar_never ) ; frame . add ( informationpanel , borderlayout . north ) ; frame . add ( scrollpane , borderlayout . center ) ; setupmenu ( ) ; setupenteractionforallbuttons ( ) ; setuplisteners ( ) ; recipesectionpanel section = new recipesectionpanel ( 1 ) ; section . addchangelistener ( this ) ; sections . add ( section ) ; mainpanel . add ( section ) ; scrollpane . setpreferredsize ( new dimension ( 767 , 600 ) ) ; frame . pack ( ) ; frame . setdefaultcloseoperation ( windowconstants . do_nothing_on_close ) ; frame . setvisible ( true ) ; }
tr	4	public static void filesaveasscm ( file target ) { if ( mainmethods . openfile == null ) { updatestatusbar ( "nothing to save ... please open a file first!" , 2 ) ; return ; } if ( ! mainmethods . openfile . isscmfile ( ) ) { updatestatusbar ( "you must open a scm file to save as an scm file" , 2 ) ; return ; } file outputfile = target ; if ( outputfile == null ) outputfile = mainmethods . getfiletosavein ( ) ; mapparser . write ( mainmethods . openfile . getchannellist ( ) , mainmethods . openfile . getfile ( ) ) ; int compressedfiles = ziphandler . compress ( outputfile . getabsolutepath ( ) , mainmethods . openfile . scmextractedto ( ) . getabsolutepath ( ) ) ; if ( compressedfiles < 0 ) { mainmethods . updatestatusbar ( "packaging scm file failed!" , 2 ) ; return ; } updatestatusbar ( "saved scm file as \"" + outputfile . getabsolutepath ( ) + "\"" , 2 ) ; }
tr	0	private mp3file copyandchecktestmp3withcustomtag ( mp3file mp3file ) throws notsupportedexception , ioexception , unsupportedtagexception , invaliddataexception { string savefilename = mp3file . getfilename ( ) + ".copy" ; try { mp3file . save ( savefilename ) ; mp3file copymp3file = loadandchecktestmp3withcustomtag ( savefilename , 5000 ) ; assertequals ( mp3file . getid3v1tag ( ) , copymp3file . getid3v1tag ( ) ) ; assertequals ( mp3file . getid3v2tag ( ) , copymp3file . getid3v2tag ( ) ) ; assertarrayequals ( mp3file . getcustomtag ( ) , copymp3file . getcustomtag ( ) ) ; return copymp3file ; } finally { testhelper . deletefile ( savefilename ) ; } }
tr	3	public void execute ( ) { session session = null ; string _commandstring ; string _output ; int _countcommands = 0 ; int _index = 0 ; this . result . append ( "*******************************************************\n" ) ; this . result . append ( "started processing unix commands on server :" ) ; this . result . append ( this . hostname ) ; this . result . append ( "\n" ) ; this . result . append ( "*******************************************************\n" ) ; _countcommands = this . commands . size ( ) ; while ( _countcommands > _index ) { _commandstring = this . commands . get ( _index ) ; this . result . append ( "executing :" ) ; this . result . append ( _commandstring ) ; this . result . append ( "\n" ) ; this . result . append ( "+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n" ) ; try { session = connectserver . opensession ( ) ; _output = executecommand ( session , _commandstring ) ; this . result . append ( _output ) ; } catch ( ioexception e ) { atomshellexception _shellexception = new atomshellexception ( e ) ; _shellexception . setcustommessage ( "unable to open a session on server ip :" + this . hostname ) ; } catch ( atomshellexception e ) { this . result . append ( e . getcustommessage ( ) ) ; } this . result . append ( "+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n" ) ; _index ++ ; } session . close ( ) ; connectserver . close ( ) ; }
tr	6	private void startlevel ( ) { if ( currentlesson . isnotelevel ( ) ) { if ( ! notelevel . ismessageempty ( ) ) { levelmessage . settitle ( bundle . getstring ( "_information" ) ) ; textlevelmessage . settext ( "  " + notelevel . getmessage ( ) + "  " ) ; levelmessage . pack ( ) ; levelmessage . setlocationrelativeto ( this ) ; levelmessage . setvisible ( true ) ; } else { startbutton . doclick ( ) ; } } else if ( currentlesson . isrhythmlevel ( ) ) { if ( ! rhythmlevel . ismessageempty ( ) ) { levelmessage . settitle ( bundle . getstring ( "_information" ) ) ; textlevelmessage . settext ( "  " + rhythmlevel . getmessage ( ) + "  " ) ; levelmessage . pack ( ) ; levelmessage . setlocationrelativeto ( this ) ; levelmessage . setvisible ( true ) ; } else { startbutton . doclick ( ) ; } } else if ( currentlesson . isscorelevel ( ) ) { if ( ! scorelevel . ismessageempty ( ) ) { levelmessage . settitle ( bundle . getstring ( "_information" ) ) ; textlevelmessage . settext ( "  " + scorelevel . getmessage ( ) + "  " ) ; levelmessage . pack ( ) ; levelmessage . setlocationrelativeto ( this ) ; levelmessage . setvisible ( true ) ; } else { startbutton . doclick ( ) ; } } }
tr	5	void deleteactivity ( component dialogparent , activity activity ) { if ( activity != null ) { if ( alertmessages . deleteactivityconfirmation ( dialogparent , activity ) ) { try { connection conn = dao . getconnection ( ) ; for ( time t : timedao . gettimesbyactivity ( conn , activity ) ) { timedao . deletetime ( conn , t ) ; } activitydao . deleteactivity ( conn , activity ) ; activitydialog . setactivity ( null ) ; activitylistdialog . selectpreviousrow ( ) ; activitydialog . setvisible ( false ) ; } catch ( sqlexception ex ) { errormessages . sqlexceptionerror ( "deleteactivity()" , ex ) ; } catch ( classnotfoundexception ex ) { errormessages . classnotfounderror ( "deleteactivity()" , ex ) ; } } } else { alertmessages . noactivityselectedintablefordeleting ( activitylistdialog ) ; } }
tr	0	private void drugaddactionperformed ( java . awt . event . actionevent evt ) { adddrugid . settext ( searchdrugtable . getvalueat ( searchdrugtable . getselectedrow ( ) , 0 ) . tostring ( ) ) ; adddrugid . setvisible ( false ) ; adddrugmaxnum . settext ( searchdrugtable . getvalueat ( searchdrugtable . getselectedrow ( ) , 3 ) . tostring ( ) ) ; adddrugmaxnum . setvisible ( false ) ; adddrugnumfield . settext ( "" ) ; adddrugtext . settext ( "" ) ; adddrugname . settext ( searchdrugtable . getvalueat ( searchdrugtable . getselectedrow ( ) , 1 ) . tostring ( ) ) ; adddrugname . setvisible ( true ) ; adddrugprice . settext ( searchdrugtable . getvalueat ( searchdrugtable . getselectedrow ( ) , 4 ) . tostring ( ) ) ; adddrugwindow . setvisible ( true ) ; }
tr	5	@ override public void actionperformed ( actionevent e ) { jmenuitem popup = ( jmenuitem ) e . getsource ( ) ; string name = popup . getname ( ) ; switch ( name ) { case "add track" : list < trackbean > selectedtracks = view . getselectedtracks ( ) ; model . addtrackstoplaylist ( selectedtracks ) ; view . setdisplayedplaylist ( model . getplaylist ( ) ) ; break ; case "add album" : albumbean selectedalbum = view . getselectedalbum ( ) ; model . addtrackstoplaylist ( selectedalbum . gettracks ( ) ) ; view . setdisplayedplaylist ( model . getplaylist ( ) ) ; break ; case "clear playlist" : model . stopsong ( false ) ; view . setdisplayedplaylist ( model . getplaylist ( ) ) ; break ; case "remove track" : removetracks ( ) ; break ; case "get info" : view . displayinfodialog ( view . getselectedtracks ( ) . get ( 0 ) ) ; break ; } }
tr	5	private void drawghosts ( ) { for ( int index = 0 ; index < g . num_ghosts ; index ++ ) { int loc = game . getcurghostloc ( index ) ; int x = game . getx ( loc ) ; int y = game . gety ( loc ) ; if ( game . getedibletime ( index ) > 0 ) { if ( game . getedibletime ( index ) < _g_ . edible_alert && ( ( game . gettotaltime ( ) % 6 ) / 3 ) == 0 ) buffergraphics . drawimage ( ghostsimgs [ 5 ] [ 0 ] [ ( game . gettotaltime ( ) % 6 ) / 3 ] , x * mag - 1 , y * mag + 3 , null ) ; else buffergraphics . drawimage ( ghostsimgs [ 4 ] [ 0 ] [ ( game . gettotaltime ( ) % 6 ) / 3 ] , x * mag - 1 , y * mag + 3 , null ) ; } else { if ( game . getlairtime ( index ) > 0 ) buffergraphics . drawimage ( ghostsimgs [ index ] [ g . up ] [ ( game . gettotaltime ( ) % 6 ) / 3 ] , x * mag - 1 + ( index * 5 ) , y * mag + 3 , null ) ; else buffergraphics . drawimage ( ghostsimgs [ index ] [ game . getcurghostdir ( index ) ] [ ( game . gettotaltime ( ) % 6 ) / 3 ] , x * mag - 1 , y * mag + 3 , null ) ; } } }
tr	7	protected void action ( source source , map < string , object > map , int i ) throws exception { log . debug ( string . format ( "loop [%s] step %d." , getname ( ) , i ) ) ; map . put ( "position" , i ) ; if ( source != null ) { map . put ( "value" , source . pickone ( "value" , "base" ) ) ; } if ( getbeforeaction ( ) == null || getbeforeaction ( ) . invoke ( getcontext ( ) , this , i ) ) { for ( insert insert : getinserts ( ) ) { log . debug ( string . format ( "loop [%s] step %d  insert %s" , getname ( ) , i , insert . getname ( ) ) ) ; insert . execute ( ) ; } for ( loop loop : getloops ( ) ) { log . debug ( string . format ( "loop [%s] step %d  loop %s" , getname ( ) , i , loop . getname ( ) ) ) ; loop . execute ( ) ; } if ( getaction ( ) != null ) { getaction ( ) . invoke ( getcontext ( ) , this , i ) ; } if ( getafteraction ( ) != null ) { getafteraction ( ) . invoke ( getcontext ( ) , this , i ) ; } } }
tr	6	@ override public void loadlistofplugins ( pluginlist plugins , string folderpath , string language , boolean isintern ) { file downloaddir = new file ( getrepositoryfoldername ( ) + "/" + folderpath ) ; if ( downloaddir . exists ( ) ) { for ( file f : downloaddir . listfiles ( ) ) { if ( f . isdirectory ( ) ) { plugin p = new plugin ( f . getname ( ) , language ) ; if ( folderpath . contains ( "plugins" ) ) { if ( p . gettype ( ) . equals ( plugintype . template ) ) { p . settype ( plugintype . event ) ; } } p . setrepository ( this ) ; if ( folderpath . length ( ) > 0 ) { p . setfolderinrepository ( folderpath + "/" + f . getname ( ) ) ; } else { p . setfolderinrepository ( f . getname ( ) ) ; } plugins . add ( p ) ; } } } }
tr	8	public static void main ( string [ ] args ) { string filename = "simpledynamicscenario.txt" ; string outputpath = "./" ; if ( args . length >= 2 ) { filename = args [ 0 ] ; outputpath = args [ 1 ] ; } if ( args . length > 2 ) system . err . println ( "warning: only two arguments required. ignoring arguments after the first two." ) ; if ( args . length <= 1 ) { system . err . println ( "warning: two arguments required <setup_file_name> <ouput_dir_path>. running simulation with default values \"properties.txt\" and \"./\"." ) ; } sfp = new setupfileparser ( ) ; sfp . parsefileforproperties ( filename ) ; standalonesimulation sas = new standalonesimulation ( outputpath , "runfrom" + ( new file ( filename ) ) . getname ( ) . replace ( "." , "_" ) + system . currenttimemillis ( ) , sfp . generalprops . getproperty ( "seed" ) != null ? integer . parseint ( sfp . generalprops . getproperty ( "seed" ) ) : 0 , sfp . generalprops . getproperty ( "usederby" ) != null ? boolean . parseboolean ( sfp . generalprops . getproperty ( "usederby" ) ) : true ) ; try { sas . setup ( false ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } sas . runsimulation ( ) ; boolean printkpis = sfp . generalprops . getproperty ( "printkpis" ) != null ? boolean . parseboolean ( sfp . generalprops . getproperty ( "printkpis" ) ) : false ; if ( printkpis ) sas . printkpis ( ) ; }
tr	6	public customer editcustomer ( customer customer ) throws exception { if ( customer . getid ( ) == null || customer . getaddress ( ) == null || customer . getname ( ) == null || customer . getsurname ( ) == null || customer . gettelephones ( ) == null ) { throw new nullparameterexception ( ) ; } if ( ! checkzipcode ( customer . getaddress ( ) . getzipcode ( ) ) ) { throw new zipcodeoutofrangeexception ( ) ; } daofactory . factory . getcustomerdao ( ) . updatecustomer ( customer ) ; return customer ; }
tr	3	private void doprint ( string s ) { for ( int newline = s . indexof (  ) ; newline >= 0 ; newline = s . indexof (  ) ) { if ( newline > 0 ) { indent ( ) ; writer . println ( protect ( s . substring ( 0 , newline ) ) ) ; } else { writer . println ( ) ; } begin_line = true ; s = s . substring ( newline + 1 ) ; } if ( s . length ( ) > 0 ) { indent ( ) ; writer . print ( protect ( s ) ) ; } }
tr	8	public socketthread ( socket skt ) { this . socket = skt ; this . reader = new thread ( new runnable ( ) { @ override public void run ( ) { try { input = new xmlreader ( new bufferedreader ( new inputstreamreader ( socket . getinputstream ( ) , "utf-8" ) ) ) ; } catch ( xmlstreamexception | ioexception e ) { e . printstacktrace ( ) ; return ; } while ( true ) { try { messages . add ( input . readmessage ( ) ) ; fireevent ( ) ; } catch ( xmlstreamexception e ) { if ( thread . interrupted ( ) ) { system . out . println ( "reader closed." ) ; return ; } else { e . printstacktrace ( ) ; } } } } } ) ; this . writer = new thread ( new runnable ( ) { @ override public void run ( ) { try { output = new xmlwriter ( new printwriter ( new outputstreamwriter ( socket . getoutputstream ( ) , "utf-8" ) ) ) ; } catch ( xmlstreamexception | ioexception e ) { e . printstacktrace ( ) ; return ; } while ( true ) { try { message m = msgqueue . take ( ) ; output . writemessage ( m ) ; } catch ( interruptedexception e ) { system . out . println ( "writer closed." ) ; return ; } catch ( xmlstreamexception e ) { e . printstacktrace ( ) ; } } } } ) ; }
tr	5	public list < string > generateparenthesis ( int n ) { list < string > result = new arraylist < string > ( ) ; if ( n == 0 ) { result . add ( "" ) ; return result ; } if ( n == 1 ) { result . add ( "()" ) ; return result ; } result = generateparenthesis ( n - 1 ) ; arraylist < string > returnlist = new arraylist < string > ( ) ; int tempsize = result . size ( ) ; for ( int j = 0 ; j < tempsize ; j ++ ) { string tempstr = result . get ( j ) ; stringbuffer sb = new stringbuffer ( tempstr ) ; int size = sb . length ( ) ; for ( int i = 0 ; i < size ; ++ i ) { string str = sb . insert ( i , "()" ) . tostring ( ) ; sb = new stringbuffer ( tempstr ) ; if ( ! returnlist . contains ( str ) ) { returnlist . add ( str ) ; } } } return returnlist ; }
tr	1	public void updatestatus ( ) { log . finer ( log . start ( new throwable ( ) ) ) ; electricity needse = getneedelectricity ( ) ; log . fine ( "culculate electricty needing electronics:" + needse ) ; electricity producte = dboad . productelectorictiy ( ) ; log . fine ( "product electricty:" + producte ) ; electricity sube = producte . - ( needse ) ; log . fine ( "cluculate electricty product-needs:" + sube ) ; if ( sube . getwat ( ) < 0 ) { electricity requeste = new electricity ( ( int ) ( sube . getwat ( ) * - 1 ) ) ; buyelectricty ( requeste ) ; log . fine ( "buy the electricity:" + requeste ) ; } else { sellelectricty ( sube ) ; log . fine ( "sell the electricity:" + sube ) ; } updatemoney ( ) ; log . finer ( log . finish ( new throwable ( ) ) ) ; }
tr	9	@ override public boolean equals ( object o ) { if ( this == o ) return true ; if ( o == null || getclass ( ) != o . getclass ( ) ) return false ; option option = ( option ) o ; if ( idoption != option . idoption ) return false ; if ( surveyidsurvey != option . surveyidsurvey ) return false ; if ( content != null ? ! content . equals ( option . content ) : option . content != null ) return false ; if ( number != null ? ! number . equals ( option . number ) : option . number != null ) return false ; return true ; }
tr	0	@ override public void init ( gamecontainer gc , statebasedgame sbg ) throws slickexception { this . sbg = sbg ; logo = new image ( "data/svulogo.png" ) ; newgame = new image ( "data/newgame.png" ) ; continuegame = new image ( "data/loadgame.png" ) ; options = new image ( "data/options.png" ) ; quit = new image ( "data/quitgame.png" ) ; newgameroll = new image ( "data/newgameglow.png" ) ; continuegameroll = new image ( "data/loadgameglow.png" ) ; optionsroll = new image ( "data/optionsglow.png" ) ; quitroll = new image ( "data/quitgameglow.png" ) ; int logowidth = logo . getwidth ( ) ; logox = ( gc . getwidth ( ) - logowidth ) / 2 ; newgamex = ( gc . getwidth ( ) - newgame . getwidth ( ) ) / 2 ; continuex = ( gc . getwidth ( ) - continuegame . getwidth ( ) ) / 2 ; optionsx = ( gc . getwidth ( ) - options . getwidth ( ) ) / 2 ; quitx = ( gc . getwidth ( ) - quit . getwidth ( ) ) / 2 ; areas [ 0 ] = new mouseoverarea ( gc , newgame , newgamex , 300 , this ) ; areas [ 0 ] . setmouseoverimage ( newgameroll ) ; areas [ 1 ] = new mouseoverarea ( gc , continuegame , continuex , 350 , this ) ; areas [ 1 ] . setmouseoverimage ( continuegameroll ) ; areas [ 2 ] = new mouseoverarea ( gc , options , optionsx , 400 , this ) ; areas [ 2 ] . setmouseoverimage ( optionsroll ) ; areas [ 3 ] = new mouseoverarea ( gc , quit , quitx , 450 , this ) ; areas [ 3 ] . setmouseoverimage ( quitroll ) ; }
tr	0	public static range parserange ( string key ) { range result = new range ( ) ; result . leftinclusive = key . startswith ( "[" ) ; result . rightinclusive = key . endswith ( "]" ) ; result . left = double . parsedouble ( key . substring ( 1 , key . indexof ( ";" ) ) . trim ( ) ) ; result . right = double . parsedouble ( key . substring ( key . indexof ( ";" ) + 1 , key . length ( ) - 1 ) . trim ( ) ) ; return result ; }
tr	7	@ override public boolean done ( arraylist < node > nw , int fab ) { int a = ( ( beaconfab ) nw . get ( 0 ) . getfab ( fab ) ) . a ; set < integer > armies = new hashset < integer > ( ) ; int min = integer . max_value ; int d0 = 0 ; int d1 = 0 ; int d2 = 0 ; int d3 = 0 ; boolean res = true ; int sw = 0 ; for ( node n : nw ) { armies . add ( ( ( beaconfab ) n . getfab ( fab ) ) . a ) ; sw = ( ( beaconfab ) n . getfab ( fab ) ) . d ; min = min < sw ? min : sw ; switch ( sw ) { case 0 : d0 ++ ; break ; case 1 : d1 ++ ; break ; case 2 : d2 ++ ; break ; case 3 : d3 ++ ; break ; default : break ; } if ( ( ( beaconfab ) n . getfab ( fab ) ) . a != a ) { res = false ; } } return res ; }
tr	4	private void setusersstate ( int state ) { final int columnid = 0 ; if ( tableusers . getselectedrow ( ) != - 1 ) { int userid = ( integer ) tableusers . getvalueat ( tableusers . getselectedrow ( ) , columnid ) ; statement statement = null ; resultset result = null ; try { statement = usersdao . getconnection ( ) . createstatement ( resultset . type_scroll_sensitive , resultset . concur_updatable ) ; result = statement . executequery ( usersdao . getallquery ( ) ) ; while ( result . next ( ) ) { if ( result . getint ( "id" ) == userid ) { break ; } } result . updateint ( "userstate" , state ) ; result . updaterow ( ) ; usersdao = new usersdao ( ) ; usersdao . inittablemodel ( tableusers , usersdao . listall ( ) ) ; } catch ( sqlexception exc ) { joptionpane . showmessagedialog ( this , "\u041e\u0448\u0438\u0431\u043a\u0430 \u043f\u0440\u0438 \u043e\u0431\u043d\u043e\u0432\u043b\u0435\u043d\u0438\u0438 \u0434\u0430\u043d\u043d\u044b\u0445" ) ; } } else { joptionpane . showmessagedialog ( this , "\u041d\u0435 \u0432\u044b\u0431\u0440\u0430\u043d \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c \u0432 \u0442\u0430\u0431\u043b\u0438\u0446\u0435!" ) ; return ; } }
tr	1	public static void main ( string [ ] args ) { if ( args . length != 1 ) { system . out . println ( "argument error." ) ; system . out . println ( "using method: java -xmx2048m -jar prince.jar ./input/config.txt" ) ; system . exit ( - 1 ) ; } inputargument input = new inputargument ( args [ 0 ] ) ; princecrossvalidation validation = new princecrossvalidation ( input . getppifilepath ( ) , input . getdiseasesimilarityfilepath ( ) , input . getgenediseaseassociationfilepath ( ) , input . getdiseasefilepath ( ) , input . getoutputdir ( ) ) ; system . out . println ( "prince validation starting..." ) ; validation . batch_run ( ) ; system . out . println ( "prince validation finished..." ) ; }
tr	9	public string tostring ( ) { string s = "" ; node n = this ; while ( n != null ) { s += "[node type=" ; s += nodetypestring [ n . type ] ; s += " element=" ; if ( n . element != null ) s += n . element ; else s += "null" ; if ( n . type == textnode || n . type == commenttag || n . type == procinstag ) { s += " text=" ; if ( n . textarray != null && n . start <= n . end ) { s += "\"" ; s += lexer . getstring ( n . textarray , n . start , n . end - n . start ) ; s += "\"" ; } else { s += "null" ; } } s += " content=" ; if ( n . content != null ) s += n . content . tostring ( ) ; else s += "null" ; s += "]" ; if ( n . next != null ) s += " " ; n = n . next ; } return s ; }
tr	8	public describeservicecertificatesresult unmarshall ( staxunmarshallercontext context ) throws exception { describeservicecertificatesresult describeservicecertificatesresult = new describeservicecertificatesresult ( ) ; int originaldepth = context . getcurrentdepth ( ) ; int targetdepth = originaldepth + 1 ; if ( context . isstartofdocument ( ) ) targetdepth += 1 ; while ( true ) { xmlevent xmlevent = context . nextevent ( ) ; if ( xmlevent . isenddocument ( ) ) return describeservicecertificatesresult ; if ( xmlevent . isattribute ( ) || xmlevent . isstartelement ( ) ) { if ( context . testexpression ( "servicecertificates/item" , targetdepth ) ) { describeservicecertificatesresult . getservicecertificates ( ) . add ( servicecertificatestaxunmarshaller . getinstance ( ) . unmarshall ( context ) ) ; continue ; } } else if ( xmlevent . isendelement ( ) ) { if ( context . getcurrentdepth ( ) < originaldepth ) { return describeservicecertificatesresult ; } } } }
tr	6	boolean line ( ) throws ioexception { int lev = integer ( ) - 1 ; if ( lev == - 1 ) return false ; int c = read ( ) ; if ( c == 1 ) { int len ; bb . reset ( ) ; while ( ( len = integer ( ) ) > 0 ) { bb . extend ( len ) ; for ( int i = 0 ; i < len ; i ++ ) { bb . put ( ( byte ) read ( ) ) ; } } event . level ( lev ) ; event . event ( bb . clone ( ) ) ; return true ; } else if ( c > 1 ) { bb . reset ( ) ; bb . extend ( 64 ) ; bb . put ( ( byte ) c ) ; while ( ( c = read ( ) ) != 0 ) bb . put ( ( byte ) c ) ; event . level ( lev ) ; event . event ( new string ( bb . getbuffer ( ) , 0 , bb . length ( ) , "utf-8" ) ) ; return true ; } else { event . level ( lev ) ; event . event ( "" ) ; } return true ; }
tr	2	private viability initiateviability ( file habitatfolder ) throws ioexception , interruptedexception { file viabilitycsv = new file ( habitatfolder . getpath ( ) + file . separatorchar + viability ) ; if ( ! viabilitycsv . exists ( ) || ! viabilitycsv . isfile ( ) ) throw new filedoesntexist ( habitatfolder . getpath ( ) + file . separatorchar + viability , "but file with parameters of viability is strongly required" ) ; string filecontent = getfullfilecontent ( viabilitycsv ) ; string preparedcontent = preparer . getpreparedcontent ( filecontent , viabilityreader . input_area ) ; saver . saveforcurrentpoint ( habitatfolder . getname ( ) , viability , preparedcontent ) ; return new viabilityreader ( preparedcontent ) . getviability ( ) ; }
tr	4	public static byte [ ] decodeencfs ( byte [ ] source ) { byte [ ] decodedinput = new byte [ source . length ] ; for ( int i = 0 ; i < source . length ; i ++ ) { int arrayindex = source [ i ] ; if ( arrayindex >= 0 ) { decodedinput [ i ] = _encfs_decodabet [ source [ i ] ] ; } else { decodedinput [ i ] = - 9 ; } } int outputlen = ( source . length * 6 ) / 8 ; byte [ ] output = new byte [ outputlen ] ; int srcidx = 0 ; int dstidx = 0 ; int workbits = 0 ; long work = 0 ; while ( srcidx < source . length ) { work |= decodedinput [ srcidx ++ ] << workbits ; workbits += 6 ; while ( workbits >= 8 ) { output [ dstidx ++ ] = ( byte ) ( work & ff ) ; work >>>= 8 ; workbits -= 8 ; } } return output ; }
tr	5	private static interface gethid ( device dev ) throws ioexception { configuration config ; interface retval = null ; devicedescriptor info = dev . getdevicedescriptor ( ) ; if ( info . getdeviceclass ( ) != 0 ) throw new illegalargumentexception ( "dev class" ) ; config = dev . getconfiguration ( ) ; for ( int i = config . getnuminterfaces ( ) ; i -- != 0 ; ) { interface intf = config . getinterface ( i , 0 ) ; if ( intf . getinterfaceclass ( ) == intf . class_hid ) { if ( retval != null ) throw new illegalargumentexception ( "multi-hid" ) ; retval = intf ; } } if ( retval == null ) throw new illegalargumentexception ( "not hid" ) ; return retval ; }
tr	9	public static void main ( string [ ] args ) { utility . configure ( ) ; jobtrackercomm = new communication ( utility . jobtracker . ipaddress , utility . jobtracker . port ) ; system . out . println ( "registering on job tracker..." ) ; message msg = new message ( utility . tasktrackerreg ) ; jobtrackercomm . sendmessage ( msg ) ; msg = jobtrackercomm . readmessage ( ) ; if ( msg . getmsgtype ( ) == utility . regack ) { tasktrackerid = msg . gettasktrackerid ( ) ; system . out . println ( "successfully registered." ) ; } while ( isrunning ) { msg = jobtrackercomm . readmessage ( ) ; if ( msg . getmsgtype ( ) == utility . newjob ) { jobcontext jobcontext = msg . getjobcontext ( ) ; string jobid = jobcontext . getjobid ( ) . getid ( ) ; system . out . println ( "receiced new job from job[" + jobid + "] tracker" ) ; if ( ! jobcontexts . containskey ( jobid ) ) { jobcontexts . put ( jobid , jobcontext ) ; } msg = new message ( utility . newjoback ) ; jobtrackercomm . sendmessage ( msg ) ; } else if ( msg . getmsgtype ( ) == utility . runmapper ) { system . out . println ( "received runmapper command from job tracker." ) ; list < mapbasiccontext > mapbasiccontexts = msg . getmapcontexts ( ) ; if ( mapbasiccontexts . size ( ) != 0 ) { string jobid = mapbasiccontexts . get ( 0 ) . getjobid ( ) . getid ( ) ; jobcontext jobcontext = jobcontexts . get ( jobid ) ; nummappers = mapbasiccontexts . size ( ) ; launchmappers ( jobcontext , mapbasiccontexts ) ; } } else if ( msg . getmsgtype ( ) == utility . runreducer ) { system . out . println ( "received runreducer command from job tracker." ) ; list < reducebasiccontext > reducebasiccontexts = msg . getreducecontexts ( ) ; if ( reducebasiccontexts . size ( ) != 0 ) { string jobid = reducebasiccontexts . get ( 0 ) . getjobid ( ) . getid ( ) ; jobcontext jobcontext = jobcontexts . get ( jobid ) ; numreducers = reducebasiccontexts . size ( ) ; launchreducers ( jobcontext , reducebasiccontexts ) ; } } else if ( msg . getmsgtype ( ) == utility . close ) { isrunning = false ; } } jobtrackercomm . close ( ) ; }
tr	2	void updatestep6 ( ) { double totalbudget = lg . getbudget ( ) ; double totalexpenses = lg . gethotelbudgetspent ( ) + lg . getexpensespent ( ) ; double remainingbudget = totalbudget - totalexpenses ; textpane6_totalbudget . settext ( string . valueof ( "$" + totalbudget ) ) ; textpane6_spent . settext ( string . valueof ( "$" + totalexpenses ) ) ; textpane6_remaining . settext ( string . valueof ( "$" + remainingbudget ) ) ; if ( lg . getguestlist ( ) . size ( ) != 0 ) { lg . setcostperhead ( ) ; decimalformat df = new decimalformat ( "0.00" ) ; df . setgroupingused ( false ) ; double costperhead = lg . getcostperhead ( ) ; string costperheadstr = df . format ( costperhead ) ; textpane6_costperhead . settext ( string . valueof ( "$" + costperheadstr ) ) ; } if ( lg . completedexpensefields ( ) ) chckbx6_expensesfinalised . setenabled ( true ) ; chckbx6_expensesfinalised . setselected ( lg . getexpensefinalised ( ) ) ; panel6 . remove ( scrollpane6 ) ; createtable6 ( lg . getexpenselist ( ) , expensescols ) ; }
tr	3	public dictionaryset ( ) { iscounting = false ; dicts = new dictionary [ dictionarytypes . type_end . ordinal ( ) ] ; tot = dicts . length ; for ( int i = 0 ; i < tot ; ++ i ) { dicts [ i ] = new dictionary ( ) ; int id = dicts [ i ] . lookupindex ( unseen ) ; utils . assert ( id == 1 ) ; if ( i == dictionarytypes . pos . ordinal ( ) ) initdict ( dictionarytypes . pos , dicts [ i ] ) ; if ( i == dictionarytypes . word . ordinal ( ) ) initdict ( dictionarytypes . word , dicts [ i ] ) ; } }
tr	3	public static jsonobjectbuilder rewritejson ( jsonobjectbuilder copyinto , jsonvalue tree , string key ) { switch ( tree . getvaluetype ( ) ) { case object : jsonobject obj = ( jsonobject ) tree ; for ( string name : obj . keyset ( ) ) { copyinto = rewritejson ( copyinto , obj . get ( name ) , name ) ; } break ; case string : jsonstring st = ( jsonstring ) tree ; copyinto . add ( key , st . getstring ( ) ) ; break ; default : break ; } return copyinto ; }
tr	3	public void refreshtextlist ( ) { ground . remove ( textpane ) ; textpane = null ; resultsets = connector . getallresultsets ( userid ) ; iterator < ? > result = resultsets . iterator ( ) ; dataname . clear ( ) ; if ( result != null ) { while ( result . hasnext ( ) ) { resultset temp_res = ( resultset ) result . next ( ) ; resultmapper . put ( temp_res . getdocument ( ) . getfilename ( ) , ( resultset ) temp_res ) ; dataname . addelement ( temp_res . getdocument ( ) . getfilename ( ) ) ; } textpane = new jscrollpane ( texte ) ; textpane . setlocation ( 280 , 50 ) ; textpane . setsize ( 180 , 300 ) ; textpane . setvisible ( true ) ; texte . setvisible ( true ) ; ground . add ( textpane ) ; textpane . repaint ( ) ; ground . repaint ( ) ; } }
tr	5	@ override public void handleevent ( iparserevent event ) { if ( event . gettype ( ) == parsereventtype . document_end_event ) { flushevents ( ) ; event . fire ( listener ) ; } else { iparserevent lastevent = events . peeklast ( ) ; if ( lastevent != null && lastevent . gettype ( ) == parsereventtype . string_event && event . gettype ( ) == parsereventtype . string_event ) { event = mergestringevents ( ( stringevent ) event ) ; } events . add ( event ) ; if ( events . size ( ) > max_events ) { events . removefirst ( ) . fire ( listener ) ; } } }
tr	1	private void flushmemorytable ( ) { changetableslock . lock ( ) ; try { memorytableaccessor . useauxiliary ( ) ; } finally { changetableslock . unlock ( ) ; } disktable disktable ; try { memorytable memorytable = memorytableaccessor . getmaindatatable ( ) ; path newtablefile = disktableaccessor . newpathfortable ( ) ; flusher flusher = new flusher ( newtablefile , disktableaccessor . blocksize ( ) ) ; system . out . println ( "node: info: flushing memory table to " + newtablefile ) ; disktable = flusher . flush ( memorytable , memorytable . timestamp ( ) ) ; } catch ( ioexception e ) { system . out . println ( "node: exception: " + e ) ; throw new runtimeexception ( e ) ; } changetableslock . lock ( ) ; try { disktableaccessor . adddisk ( disktable ) ; memorytableaccessor . stopusingauxiliary ( ) ; commitlog . reset ( ) ; } finally { changetableslock . unlock ( ) ; } }
tr	0	@ test public void testapplyleechseed ( ) { system . out . println ( "applying leech seed" ) ; activepokemon healer = new activepokemon ( species . abomasnow ) ; healer . sethpev ( 252 ) ; healer . setcurrhp ( 342 ) ; activepokemon seeded = new activepokemon ( species . absol ) ; seeded . sethpev ( 252 ) ; seeded . activateseeds ( ) ; assertequals ( healer . getcurrhp ( ) , 342 ) ; assertequals ( seeded . getcurrhp ( ) , 334 ) ; assertequals ( seeded . getmaxhp ( ) , 334 ) ; statusdamage . applyleechseed ( seeded , healer ) ; assertequals ( seeded . getcurrhp ( ) , 293 ) ; assertequals ( healer . getcurrhp ( ) , 383 ) ; }
tr	2	private byte [ ] tobytes ( int v , int length ) { assert length % 4 == 0 ; assert length > 0 ; byte [ ] result = new byte [ length ] ; result [ 0 ] = ( byte ) ( v & ff ) ; result [ 1 ] = ( byte ) ( v >>> 8 & ff ) ; result [ 2 ] = ( byte ) ( v >>> 16 & ff ) ; result [ 3 ] = ( byte ) ( v >>> 24 & ff ) ; for ( int i = 4 ; i < length ; ) { int copylength = i <= length / 2 ? i : length - i ; system . arraycopy ( result , 0 , result , i , copylength ) ; i += copylength ; } return result ; }
tr	4	private void jbuttoncheckroomsactionperformed ( java . awt . event . actionevent evt ) { dflrooms . removeallelements ( ) ; if ( "" . equals ( jxdatepickercheckroomarrival . geteditor ( ) . gettext ( ) ) || "" . equals ( jxdatepickercheckroomdeparture . geteditor ( ) . gettext ( ) ) ) { joptionpane . showmessagedialog ( rootpane , "make sure both arrival and departure date are entered and in the correct format" ) ; } else { dateformat dateformat = new simpledateformat ( "yyyy-mm-dd" ) ; jxdatepickercheckroomarrival . setformats ( dateformat ) ; jxdatepickercheckroomdeparture . setformats ( dateformat ) ; string arrival = dateformat . format ( jxdatepickercheckroomarrival . getdate ( ) ) . tostring ( ) ; string departure = dateformat . format ( jxdatepickercheckroomdeparture . getdate ( ) ) . tostring ( ) ; r = con . getroomslist ( arrival , departure ) ; if ( r != null ) { for ( int i = 0 ; i < r . size ( ) ; i ++ ) { dflrooms . addelement ( r . get ( i ) . tostring ( ) ) ; } } else { statuslabel . settext ( "could not get rooms" ) ; } con . resetrooms ( ) ; } }
tr	9	@ override public void handlecommand ( commandmessage m ) { string [ ] args = m . getargs ( ) ; if ( args . length == 1 ) { string nick = m . getnick ( ) ; if ( pozdravy . containskey ( nick ) ) { ph . sendmessage ( nick + ": " + pozdravy . get ( nick ) ) ; } } else if ( args . length < 3 ) { if ( pozdravy . containskey ( args [ 1 ] ) ) { ph . sendmessage ( args [ 1 ] + ": " + pozdravy . get ( args [ 1 ] ) ) ; } } else if ( args [ 1 ] . equals ( "set" ) ) { stringbuilder sb = new stringbuilder ( ) ; for ( int i = 3 ; i < args . length ; i ++ ) { sb . append ( args [ i ] ) ; sb . append (   ) ; } sb . deletecharat ( sb . length ( ) - 1 ) ; pozdravy . put ( args [ 2 ] , sb . tostring ( ) ) ; try { ph . savedata ( pozdravy ) ; } catch ( ioexception ex ) { logger . warn ( "pozdravy couldn't be saved." , ex ) ; } } else if ( args [ 1 ] . equals ( "reset" ) ) { pozdravy . remove ( args [ 2 ] ) ; try { ph . savedata ( pozdravy ) ; ph . sendmessage ( "pozdrav pro " + args [ 2 ] + " byl zru\u0161en" ) ; } catch ( ioexception ex ) { logger . warn ( "pozdravy couldn't be saved." , ex ) ; } } else { ph . sendmessage ( this . help ( ph . getprefix ( ) ) ) ; } }
tr	6	void trace ( pgpolygonset output , pdvector seed , int steps , double stepsize ) { output . addvertex ( seed ) ; pdvector cur = seed ; for ( int s = 1 ; s <= steps ; ++ s ) { pdvector last = cur ; cur = next ( cur , stepsize ) ; if ( cur == null ) { break ; } int vertex = output . addvertex ( cur ) ; output . addpolygon ( new pivector ( vertex - 1 , vertex ) ) ; if ( pdvector . dist ( last , cur ) < ( stepsize / 10d ) ) { break ; } boolean stop = false ; for ( pdvector v : m_stops ) { if ( pdvector . dist ( v , cur ) < ( stepsize / 10d ) ) { stop = true ; break ; } } if ( stop ) { break ; } } }
tr	0	@ ignore public void testhandleresponse ( ) throws unsupportedencodingexception { filerequestresponsemessage ok = new filerequestresponsemessage ( responsecode . ok , 1012 ) ; filerequestresponsemessage tryagain = new filerequestresponsemessage ( responsecode . try_again_later , 0 ) ; filerequestresponsemessage neveragain = new filerequestresponsemessage ( responsecode . never_try_again , 0 ) ; inputstream ok_fs = new bytearrayinputstream ( ok . serialize ( ) . getbytes ( message . encoding ) ) ; inputstream tryagain_fs = new bytearrayinputstream ( tryagain . serialize ( ) . getbytes ( message . encoding ) ) ; inputstream neveragain_fs = new bytearrayinputstream ( neveragain . serialize ( ) . getbytes ( message . encoding ) ) ; assertequals ( ok , ( new testwrapper ( ) ) . handleresponse ( ok_fs ) ) ; assertequals ( tryagain , ( new testwrapper ( ) ) . handleresponse ( tryagain_fs ) ) ; assertequals ( neveragain , ( new testwrapper ( ) ) . handleresponse ( neveragain_fs ) ) ; }
tr	9	public void run ( ) { synchronized ( tasklist ) { while ( true ) { long time = system . currenttimemillis ( ) ; if ( nexttime <= time ) { nexttask . gettask ( ) . runwatchdogtask ( time ) ; nexttask . setlastexecmillis ( time ) ; updatenexttask ( ) ; } if ( nexttask != null && tasklist . size ( ) > 0 ) { time = system . currenttimemillis ( ) ; long timetosleep = nexttime - time ; if ( timetosleep > 0 ) { try { tasklist . wait ( timetosleep ) ; } catch ( interruptedexception e ) { } continue ; } else if ( timetosleep == 0 || nexttime == 0 ) continue ; } try { tasklist . wait ( ) ; } catch ( interruptedexception e ) { } } } }
tr	6	public static void main ( string [ ] args ) { int k = 0 ; try { k = integer . parseint ( args [ 0 ] ) ; } catch ( numberformatexception e ) { system . out . println ( "expected an argument with the number of elements to print." ) ; system . out . println ( "usage: subset k - to print k values from the input." ) ; system . out . println ( "example: echo a b c d e f g h i | java subset 3  => prints out 3 values from the input." ) ; } int n = 0 ; randomizedqueue < string > rq = new randomizedqueue < string > ( ) ; while ( ! stdin . isempty ( ) ) { string s = stdin . readstring ( ) ; n ++ ; if ( rq . size ( ) == k ) { final double rnd = stdrandom . uniform ( 1 , n + 1 ) ; if ( rnd <= k ) { rq . dequeue ( ) ; rq . enqueue ( s ) ; } } else { rq . enqueue ( s ) ; } } for ( int i = 0 ; i < k && ! rq . isempty ( ) ; i ++ ) { system . out . println ( rq . dequeue ( ) ) ; } }
tr	5	public < h , s > void dispatch ( event < h , s > event , s source ) { event . setsource ( source ) ; try { for ( h handler : this . < h > getqueuefortype ( registeredhandlers , event . gettype ( ) ) ) { try { event . dispatch ( handler ) ; } catch ( throwable t ) { loggerfactory . getlogger ( handler . getclass ( ) ) . error ( "unhandled exception while dispatching event" , t ) ; } } for ( reference < waiter < event < h , s >>> ref : this . < reference < waiter < event < h , s >>> > getqueuefortype ( registeredwaiters , event . gettype ( ) ) ) { waiter < event < h , s >> waiter = ref . get ( ) ; if ( waiter != null ) { waiter . offer ( event ) ; } } if ( ! ( event instanceof eventevent ) ) { dispatch ( new eventevent ( ) , event ) ; } } finally { event . setsource ( null ) ; } }
tr	7	private static void begin ( ) { scanner sc = new scanner ( system . in ) ; int ntestcases = integer . parseint ( sc . nextline ( ) ) ; sc . nextline ( ) ; line decryptedline = new line ( "the quick brown fox jumps over the lazy dog" ) ; for ( int t = 0 ; t < ntestcases ; ++ t ) { list < line > lines = new linkedlist < line > ( ) ; map < character , character > dict = null ; while ( sc . hasnextline ( ) ) { string input = sc . nextline ( ) ; if ( input . isempty ( ) ) { break ; } line line = new line ( input ) ; lines . add ( line ) ; if ( dict == null ) { dict = line . getdict ( decryptedline ) ; } } if ( dict == null ) { system . out . println ( "no solution." ) ; } else { for ( line l : lines ) { system . out . println ( l . decrypt ( dict ) ) ; } } if ( t < ntestcases - 1 ) { system . out . println ( ) ; } } }
tr	1	public static long pack ( long big , int little , int bits ) { assert bits > 32 && bits < 64 ; assert big < ( 1 << bits ) ; assert little < ( 1 << ( 64 - bits ) ) ; int ls = bits & 7 ; int bm = ( 1 << ls ) - 1 ; long res = ( big & ~ bm ) << ( 64 - bits ) ; res |= ( little & ( ( 1 << ( 64 - bits ) ) - 1 ) ) << ls ; res |= big & bm ; return res ; }
tr	4	public void equipweapon ( survivor survivor , weapon weapon ) throws cantequipweaponexception { if ( ! this . survivors . contains ( survivor ) ) { throw new cantequipweaponexception ( cantequipweaponexception . notintheteam ( survivor ) ) ; } else if ( ! this . mainbase . getavailableweapons ( ) . contains ( weapon ) ) { throw new cantequipweaponexception ( "weapon must be one of those stored in base to equip" ) ; } else { survivor owner = this . alreadyequipped ( weapon ) ; if ( owner != null ) { throw new cantequipweaponexception ( "weapon is already equipped by " + owner . getname ( ) ) ; } else { weapon oldweapon = survivor . getweapon ( ) ; this . mainbase . getavailableweapons ( ) . remove ( weapon ) ; survivor . setweapon ( weapon ) ; if ( oldweapon != null ) { this . mainbase . getavailableweapons ( ) . add ( oldweapon ) ; } } } }
tr	3	@ suppresswarnings ( "unchecked" ) public t nextconcrete ( ) { t genobj = null ; try { initfieldgenerators ( ) ; genobj = ( t ) utils . getdummyobject ( this . type ) ; reflector r1 = new reflector ( genobj ) ; field [ ] fields = r1 . getfields ( genobj ) ; for ( field f : fields ) { f . set ( genobj , fieldgenerators . get ( f ) . next ( ) ) ; } } catch ( instantiationexception e ) { e . printstacktrace ( ) ; } catch ( illegalaccessexception e ) { e . printstacktrace ( ) ; } return genobj ; }
tr	2	@ override public void actionperformed ( actionevent e ) { if ( e . getactioncommand ( ) . equals ( "apply" ) ) { this . dispose ( ) ; system . out . println ( "aaaa" ) ; tuple < string , tuple < string , integer >> player1data = player1 . getplayerdata ( ) ; tuple < string , tuple < string , integer >> player2data = player2 . getplayerdata ( ) ; int deadfields = this . deadfields . getdeadfieldnumber ( ) ; system . out . println ( deadfields ) ; system . out . println ( "bbb" ) ; player [ ] players = { new player ( player1data . getfirstelement ( ) , player1data . getsecondelement ( ) . getfirstelement ( ) , "w" , player1data . getsecondelement ( ) . getsecondelement ( ) ) , new player ( player2data . getfirstelement ( ) , player2data . getsecondelement ( ) . getfirstelement ( ) , "b" , player2data . getsecondelement ( ) . getsecondelement ( ) ) , } ; system . out . println ( "ccc" ) ; try { mastergui . newgame ( players , deadfields ) ; } catch ( exception e1 ) { e1 . printstacktrace ( ) ; } system . out . println ( "ddd" ) ; } }
tr	5	public void setgoalrandom ( ) { if ( this . goals . isempty ( ) ) { this . goal = null ; return ; } if ( this . randomgoals . isempty ( ) ) { this . randomgoals . addall ( this . goals ) ; collections . shuffle ( this . randomgoals , random ) ; } this . goal = this . randomgoals . remove ( 0 ) ; if ( this . goal . robotnumber >= this . robots . length ) { this . setgoalrandom ( ) ; } if ( this . issolution01 ( ) && ( this . randomgoals . size ( ) > 0 ) ) { final goal goal01 = this . goal ; this . setgoalrandom ( ) ; this . randomgoals . add ( goal01 ) ; } }
tr	8	private static boolean busqueda ( int nt , string extra , string tipo , int pos ) { if ( pos < planes . size ( ) ) { plan p = planes . get ( pos ) ; if ( p . getnumtel ( ) == nt ) return true ; if ( p instanceof planiphone && tipo . equals ( "iphone" ) ) { if ( extra . equals ( ( ( planiphone ) p ) . getemail ( ) ) ) return true ; } if ( p instanceof planblackberry && tipo . equals ( "blackberry" ) ) { if ( extra . equals ( ( ( planblackberry ) p ) . getpin ( ) ) ) return true ; } return busqueda ( nt , extra , tipo , pos + 1 ) ; } return false ; }
tr	2	arraylist < object [ ] > getpickerargs ( ) { arraylist < object [ ] > pickerargs = new arraylist < object [ ] > ( ) ; if ( this . pickers > 0 ) { pickers pickers = this . warehouse . getpickers ( ) ; arraylist < picker > rl = pickers . getpickerlist ( ) ; for ( picker r : rl ) { object [ ] args = new object [ 1 ] ; args [ 0 ] = r . getuid ( ) ; pickerargs . add ( args ) ; } } return pickerargs ; }
tr	4	public static point2 getpositionaftermovement ( entity entity ) { switch ( entity . orientation ) { case north : return new point2 ( entity . position . x , entity . position . y - 1 ) ; case east : return new point2 ( entity . position . x + 1 , entity . position . y ) ; case south : return new point2 ( entity . position . x , entity . position . y + 1 ) ; case west : return new point2 ( entity . position . x - 1 , entity . position . y ) ; default : return new point2 ( entity . position . x , entity . position . y ) ; } }
tr	7	public static string extracttitlefrom ( string filepath ) { string title = null ; try { mp3file mp3file = new mp3file ( filepath ) ; if ( mp3file . hasid3v2tag ( ) ) { id3v2 id3v2tag = mp3file . getid3v2tag ( ) ; title = id3v2tag . gettitle ( ) ; } else if ( mp3file . hasid3v1tag ( ) ) { id3v1 id3v1tag = mp3file . getid3v1tag ( ) ; title = id3v1tag . gettitle ( ) ; } } catch ( unsupportedtagexception e ) { e . printstacktrace ( ) ; } catch ( invaliddataexception e ) { system . out . print ( "invalid data" ) ; return " - unknown title" ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } if ( title == null ) { int lastslash = filepath . lastindexof ( \ ) ; if ( filepath . lastindexof ( / ) > lastslash ) lastslash = filepath . lastindexof ( / ) ; title = filepath . substring ( lastslash + 1 ) . replaceall ( "\\.mp3$" , "" ) ; } return title ; }
tr	6	public void advance ( ) { timeuntilnext -- ; if ( timeuntilnext <= 0 ) { stoppingat ( ) ; if ( ! reverse && nextstation . getnext ( ) == null ) { reverse = true ; timeuntilnext = nextstation . getprevtime ( ) ; nextstation = nextstation . getprev ( ) ; return ; } if ( reverse && nextstation . getprev ( ) == null ) { reverse = false ; timeuntilnext = nextstation . getnexttime ( ) ; nextstation = nextstation . getnext ( ) ; return ; } if ( reverse ) { timeuntilnext = nextstation . getprevtime ( ) ; nextstation = nextstation . getprev ( ) ; } else { timeuntilnext = nextstation . getnexttime ( ) ; nextstation = nextstation . getnext ( ) ; } } }
tr	9	public int getconfig ( int uid , int x , int y , int z ) { ground tile = groundarray [ z ] [ x ] [ y ] ; if ( tile == null ) return - 1 ; if ( tile . wallobject != null && tile . wallobject . uid == uid ) return tile . wallobject . objconf & ff ; if ( tile . walldecoration != null && tile . walldecoration . uid == uid ) return tile . walldecoration . objconf & ff ; if ( tile . grounddecoration != null && tile . grounddecoration . uid == uid ) return tile . grounddecoration . objconf & ff ; for ( int e = 0 ; e < tile . entitycount ; e ++ ) if ( tile . interactiveobjects [ e ] . uid == uid ) return tile . interactiveobjects [ e ] . objconf & ff ; return - 1 ; }
tr	9	private synchronized void toserver ( int fromconnectionid , message msg ) { int playerid = activeplayers . getpidbycid ( fromconnectionid ) ; string playername = msg . getplayername ( ) ; int speed = msg . getspeed ( ) ; char nextdirection = msg . getnextdirection ( ) ; boolean startgame = msg . isstartgame ( ) ; if ( msg . getstage ( ) == 0 ) { if ( msg . gettomethode ( ) . equals ( new string ( "disconnectclient" ) ) ) { ns . scommif . disconnectclient ( playerid ) ; activeconnections . unregisterbyid ( activeplayers . getcidbypid ( playerid ) ) ; activeplayers . unregisterplayer ( playerid ) ; } } else if ( msg . getstage ( ) == 1 ) { if ( msg . gettomethode ( ) . equals ( new string ( "registerclient" ) ) ) ns . scommif . registerclient ( playerid , playername ) ; if ( msg . gettomethode ( ) . equals ( new string ( "gamespeedis" ) ) ) ns . scommif . gamespeedis ( speed ) ; if ( msg . gettomethode ( ) . equals ( new string ( "startgame" ) ) ) ns . scommif . startgame ( startgame ) ; } else if ( msg . getstage ( ) == 2 ) { if ( msg . gettomethode ( ) . equals ( new string ( "changedirection" ) ) ) { ns . scommif . changedirection ( playerid , nextdirection ) ; } } else if ( msg . getstage ( ) == 3 ) { } else { } }
tr	4	public chemequation ( element [ ] elems , boolean full ) { first = new arraylist < > ( ) ; second = new arraylist < > ( ) ; this . full = full ; if ( full ) { boolean onreactants = false ; for ( element elem : elems ) { if ( elem == null ) { onreactants = true ; } if ( onreactants ) { second . add ( elem ) ; } else { first . add ( elem ) ; } } } else { first . addall ( arrays . aslist ( elems ) ) ; } }
tr	1	public static void main ( string [ ] args ) { try { = ( 0 , ( new dropcoins ( ) ) . getminimum ( new string [ ] { ".o.." , "oooo" , "..o." } , 3 ) , 2 ) ; = ( 1 , ( new dropcoins ( ) ) . getminimum ( new string [ ] { ".....o" , "......" , "oooooo" , "oooooo" , "......" , "o....." } , 12 ) , 3 ) ; = ( 2 , ( new dropcoins ( ) ) . getminimum ( new string [ ] { "...." , ".oo." , ".oo." , "...." } , 3 ) , - 1 ) ; = ( 3 , ( new dropcoins ( ) ) . getminimum ( new string [ ] { "......." , "..ooo.." , "ooooooo" , ".oo.oo." , "oo...oo" } , 12 ) , 4 ) ; = ( 4 , ( new dropcoins ( ) ) . getminimum ( new string [ ] { "................." , ".ooooooo...oooo.." , ".ooooooo..oooooo." , ".oo.......oo..oo." , ".oo.......oo..oo." , ".ooooo.....oooo.." , ".ooooooo...oooo.." , ".....ooo..oo..oo." , "......oo..oo..oo." , ".ooooooo..oooooo." , ".oooooo....oooo.." , "................." } , 58 ) , 6 ) ; } catch ( exception exx ) { system . err . println ( exx ) ; exx . printstacktrace ( system . err ) ; } }
tr	9	private void planforagent ( agent agent ) { taskdispenser td = agent . td ; node node = agent . node ; if ( agent . request != null ) { if ( agent . request . requestbox . atfield == agent . request . requestgoal ) { agent . request = null ; } } if ( agent . taskqueue != null && agent . taskqueue . size ( ) > 0 && ( agent . taskqueue . peek ( ) . commandqueue == null || agent . taskqueue . peek ( ) . commandqueue . size ( ) == 0 ) ) { if ( agent . taskqueue . peek ( ) instanceof docktask ) { docktask t = ( docktask ) agent . taskqueue . peek ( ) ; t . box . reserved = false ; t . moveboxto . reserved = false ; } agent . taskqueue . poll ( ) ; } if ( agent . taskqueue . size ( ) == 0 ) { agent . taskqueue . clear ( ) ; if ( agent . td . agents . size ( ) == 1 ) { agent . taskqueue . addall ( td . newdispensetaskforagent ( agent ) ) ; } else { agent . taskqueue . addall ( td . simpledispensetaskforagent ( agent ) ) ; } } }
tr	3	private void reversegraph ( ) { for ( int i = 0 ; i < n ; i ++ ) { grapht . add ( new arraylist < integer > ( ) ) ; } for ( int i = 0 ; i < n ; i ++ ) { arraylist < integer > list = graph . get ( i ) ; for ( int j = 0 ; j < list . size ( ) ; j ++ ) { int vertex = list . get ( j ) ; grapht . get ( vertex ) . add ( i ) ; } } }
tr	0	@ test public void testconvexcut ( ) { point [ ] points = aconvex ; assertequals ( arrays . aslist ( p ( - 1.0 , - 1.0 ) , p ( 5.0 , 5.0 ) , p ( 4.0 , 5.0 ) , p ( - 1.0 , 1.0 ) ) , convexcut ( points , zerop , onep ) ) ; assertequals ( arrays . aslist ( p ( - 1.0 , - 1.0 ) , p ( 7.0 , - 4.0 ) , p ( 12.0 , - 1.0 ) , p ( 10.0 , 4.0 ) , p ( 6.0 , 5.0 ) , p ( 5.0 , 5.0 ) ) , convexcut ( points , onep , zerop ) ) ; assertequals ( arrays . aslist ( p ( 11.6 , 0.0 ) , p ( 10.0 , 4.0 ) , p ( 6.0 , 5.0 ) , p ( 4.0 , 5.0 ) , p ( - 1.0 , 1.0 ) , p ( - 1.0 , 0.0 ) ) , convexcut ( points , zerop , p ( 1 , 0 ) ) ) ; assertequals ( arrays . aslist ( p ( - 1.0 , - 1.0 ) , p ( 7.0 , - 4.0 ) , p ( 5.0 , 5.0 ) , p ( 4.0 , 5.0 ) , p ( - 1.0 , 1.0 ) ) , convexcut ( points , p ( 7 , - 4 ) , p ( 5 , 5 ) ) ) ; assertequals ( arrays . aslist ( p ( - 1.0 , - 1.0 ) , p ( 7.0 , - 4.0 ) , p ( 7.5 , - 3.7 ) , p ( 6.0 , 5.0 ) , p ( 4.0 , 5.0 ) , p ( - 1.0 , 1.0 ) ) , convexcut ( points , p ( 7.5 , - 3.7 ) , p ( 6 , 5 ) ) ) ; assertequals ( arrays . aslist ( points ) , convexcut ( points , p ( 10 , 4 ) , p ( 6 , 5 ) ) ) ; assertequals ( arrays . aslist ( p ( 10.0 , 4.0 ) , p ( 6.0 , 5.0 ) ) , convexcut ( points , p ( 6 , 5 ) , p ( 10 , 4 ) ) ) ; assertequals ( arrays . aslist ( points ) , convexcut ( points , p ( 0 , - 100 ) , p ( 100 , - 100 ) ) ) ; assertequals ( arrays . aslist ( ) , convexcut ( points , p ( 100 , - 100 ) , p ( 0 , - 100 ) ) ) ; assertequals ( arrays . aslist ( p ( - 1 , - 1 ) ) , convexcut ( points , p ( 99 , - 101 ) , p ( - 101 , 99 ) ) ) ; }
tr	5	public iterable < position < e >> findrange ( e minvalue , e maxvalue ) { list < position < e >> l = new arraylist < > ( ) ; list < position < e >> todas = ( list < position < e >> ) this . positions ( ) ; for ( position < e > pos : todas ) { e curvalue = pos . element ( ) ; int compmin = findcomparator . compare ( curvalue , minvalue ) ; int compmax = findcomparator . compare ( curvalue , maxvalue ) ; boolean overmin = ( ( compmin == 0 ) || ( compmin == 1 ) ) ; boolean undermax = ( ( compmax == 0 ) || ( compmax == - 1 ) ) ; if ( overmin && undermax ) { l . add ( pos ) ; } } return l ; }
tr	0	@ suppresswarnings ( { "static-access" , "unchecked" , "rawtypes" } ) public void initobject ( ) { jlabelresult = new jlabel ( ) ; jlabelresult . settext ( "calculer le trajet..." ) ; jbuttonresult = new jbutton ( ) ; jbuttonresult . setopaque ( false ) ; jbuttonresult . seticon ( configicon . getinstance ( ) . heart ) ; jbuttonresult . setcontentareafilled ( false ) ; jbuttonresult . setfocuspainted ( false ) ; jbuttonresult . addactionlistener ( this ) ; jbuttonresult . setmargin ( new insets ( 0 , 0 , 0 , 0 ) ) ; jbuttonscalemap = ihmtools . getinstance ( ) . getnewbuttonwithicon_actionlistener_textonright ( configicon . getinstance ( ) . gps_2d , this , "2d" ) ; jcomboboxtypemap = new jcombobox ( tab_s_typemap ) ; jcomboboxtypemap . setselectedindex ( 0 ) ; jcomboboxtypemap . setvisible ( false ) ; jlabeltypemap = new jlabel ( "type map :" ) ; jlabeltypemap . setvisible ( false ) ; jcomboboxtypemap . addactionlistener ( this ) ; jlabelspeedair = new jlabel ( ) ; jlabelspeedair . settext ( "air : " ) ; jlabelspeedair . setopaque ( false ) ; jlabelspeedearth = new jlabel ( ) ; jlabelspeedearth . settext ( "terre : " ) ; jlabelspeedearth . setopaque ( false ) ; jlabelspeedwater = new jlabel ( ) ; jlabelspeedwater . settext ( "mer : " ) ; jlabelspeedwater . setopaque ( false ) ; jspinnerspeedair = new jspinner ( new spinnernumbermodel ( 0 , 0 , 5 , 0.1 ) ) ; jspinnerspeedearth = new jspinner ( new spinnernumbermodel ( 1 , 1 , 5 , 0.1 ) ) ; jspinnerspeedwater = new jspinner ( new spinnernumbermodel ( 0 , 0 , 5 , 0.1 ) ) ; jspinnerspeedair . setenabled ( false ) ; jspinnerspeedearth . setenabled ( false ) ; jspinnerspeedwater . setenabled ( false ) ; jspinnerspeedair . setpreferredsize ( new dimension ( 40 , 20 ) ) ; jspinnerspeedearth . setpreferredsize ( new dimension ( 40 , 20 ) ) ; jspinnerspeedwater . setpreferredsize ( new dimension ( 40 , 20 ) ) ; jspinnerspeedair . addchangelistener ( this ) ; jspinnerspeedearth . addchangelistener ( this ) ; jspinnerspeedwater . addchangelistener ( this ) ; jbuttonbytrain = new jbutton ( ) ; jbuttonbytrain . setopaque ( false ) ; jbuttonbytrain . seticon ( configicon . getinstance ( ) . unauth_train ) ; jbuttonbytrain . setcontentareafilled ( false ) ; jbuttonbytrain . setfocuspainted ( false ) ; jbuttonbytrain . addactionlistener ( this ) ; jbuttonbytrain . setmargin ( new insets ( 0 , 0 , 0 , 0 ) ) ; jbuttonbytrain . setenabled ( false ) ; jbuttonbyboat = new jbutton ( ) ; jbuttonbyboat . setopaque ( false ) ; jbuttonbyboat . seticon ( configicon . getinstance ( ) . unauth_boat ) ; jbuttonbyboat . setcontentareafilled ( false ) ; jbuttonbyboat . setfocuspainted ( false ) ; jbuttonbyboat . addactionlistener ( this ) ; jbuttonbyboat . setmargin ( new insets ( 0 , 0 , 0 , 0 ) ) ; jbuttonbyboat . setenabled ( false ) ; jbuttonbyplane = new jbutton ( ) ; jbuttonbyplane . setopaque ( false ) ; jbuttonbyplane . seticon ( configicon . getinstance ( ) . unauth_plane ) ; jbuttonbyplane . setcontentareafilled ( false ) ; jbuttonbyplane . setfocuspainted ( false ) ; jbuttonbyplane . addactionlistener ( this ) ; jbuttonbyplane . setmargin ( new insets ( 0 , 0 , 0 , 0 ) ) ; jbuttonbyplane . setenabled ( false ) ; jpanelgpsconfigscalemap = new panelgpsconfigscalemap ( ) ; jbuttonmouseposition = new jbutton ( ) ; jbuttonmouseposition . setopaque ( false ) ; jbuttonmouseposition . seticon ( configicon . getinstance ( ) . mouse ) ; jbuttonmouseposition . setcontentareafilled ( false ) ; jbuttonmouseposition . setfocuspainted ( false ) ; jbuttonmouseposition . setborderpainted ( false ) ; jbuttonmouseposition . setmargin ( new insets ( 0 , 0 , 0 , 0 ) ) ; jlabelposition1mouse = new jlabel ( ) ; jlabelposition1mouse . settext ( "d\u00e9placez la" ) ; jlabelposition2mouse = new jlabel ( ) ; jlabelposition2mouse . settext ( "souris sur la carte" ) ; jbuttonbeginposition = new jbutton ( ) ; jbuttonbeginposition . setopaque ( false ) ; jbuttonbeginposition . seticon ( configicon . getinstance ( ) . green_flag ) ; jbuttonbeginposition . setcontentareafilled ( false ) ; jbuttonbeginposition . setfocuspainted ( false ) ; jbuttonbeginposition . addactionlistener ( this ) ; jbuttonbeginposition . setmargin ( new insets ( 0 , 0 , 0 , 0 ) ) ; jlabelposition1begin = new jlabel ( ) ; jlabelposition1begin . settext ( "case non" ) ; jlabelposition2begin = new jlabel ( ) ; jlabelposition2begin . settext ( "selectionn\u00e9e" ) ; jbuttonstopposition = new jbutton ( ) ; jbuttonstopposition . setopaque ( false ) ; jbuttonstopposition . seticon ( configicon . getinstance ( ) . red_flag ) ; jbuttonstopposition . setcontentareafilled ( false ) ; jbuttonstopposition . setfocuspainted ( false ) ; jbuttonstopposition . addactionlistener ( this ) ; jbuttonstopposition . setmargin ( new insets ( 0 , 0 , 0 , 0 ) ) ; jlabelposition1stop = new jlabel ( ) ; jlabelposition1stop . settext ( "case non" ) ; jlabelposition2stop = new jlabel ( ) ; jlabelposition2stop . settext ( "selectionn\u00e9e" ) ; }
tr	7	public string reversewords ( string s ) { if ( s . length ( ) == 0 ) return s ; string [ ] arr = s . split ( " " ) ; arraylist < string > aa = new arraylist < string > ( ) ; if ( arr . length == 0 ) return "" ; int i = 0 ; while ( i < arr . length ) { if ( ! ( arr [ i ] . equals ( " " ) || arr [ i ] . equals ( "" ) ) ) { aa . add ( arr [ i ] ) ; } i ++ ; } if ( aa . size ( ) == 0 ) return "" ; string ret = aa . get ( aa . size ( ) - 1 ) ; for ( i = aa . size ( ) - 2 ; i > - 1 ; i -- ) { ret = ret + " " + aa . get ( i ) ; } return ret ; }
tr	2	public void open ( url location , string referer ) throws ioexception { string host = location . gethost ( ) ; if ( referer == null ) referer = "http://" + host + "/" ; string path = location . getpath ( ) + "?" + location . getquery ( ) ; int port = location . getport ( ) ; if ( port == - 1 ) port = 80 ; socket . setsotimeout ( 5000 ) ; socket . connect ( new inetsocketaddress ( host , port ) , 5000 ) ; printwriter pw = new printwriter ( socket . getoutputstream ( ) , true ) ; pw . println ( "get " + path + " http/1.1" ) ; pw . println ( "host: " + host ) ; pw . println ( "referer: " + referer ) ; pw . println ( "accept: */*" ) ; pw . println ( "user-agent: mozilla/4.0 (compatible; msie 6.0; windows nt 5.1)" ) ; pw . println ( "connection: keep-alive" ) ; pw . println ( ) ; instream = socket . getinputstream ( ) ; getresponse ( ) ; }
tr	2	public int moveframe ( frame frame , int currentindexofpreviousitem ) { animation oldparent = frame . getparent ( ) ; if ( currentindexofpreviousitem == - 1 ) { oldparent . frames . remove ( frame ) ; frames . add ( 0 , frame ) ; parent . fireframemoved ( oldparent , frame ) ; return 0 ; } frame previousframe = getframe ( currentindexofpreviousitem ) ; if ( previousframe == frame ) return currentindexofpreviousitem ; else { oldparent . frames . remove ( frame ) ; int newindexofpreviousitem = getframeindex ( previousframe ) ; frames . add ( newindexofpreviousitem + 1 , frame ) ; parent . fireframemoved ( oldparent , frame ) ; return newindexofpreviousitem + 1 ; } }
tr	9	private description deserialise ( singledescriptiontriples buffer , list < description > additional ) throws deserialisationexception { if ( buffer . hasbeendeserialised ( ) ) { return buffer . getdeserialisation ( ) ; } uri type = getspecifictype ( buffer ) ; description description ; if ( type == null ) { type = getimpliedtype ( buffer . getsubject ( ) ) ; if ( type == null ) { return null ; } } description = provconstructer . create ( type , buffer . getidentifier ( ) ) ; buffer . setdeserialisation ( description ) ; for ( uri predicate : buffer . getpredicates ( ) ) { if ( ! predicate . equals ( rdf . typeuri ( ) ) ) { if ( term . isprovterm ( predicate ) ) { deserialise ( predicate , buffer , description , additional ) ; } else { if ( description instanceof attributeholder ) { for ( literal object : buffer . getliteralobjects ( predicate ) ) { ( ( attributeholder ) description ) . addattribute ( predicate , object . _value ) ; } for ( uri object : buffer . geturiobjects ( predicate ) ) { ( ( attributeholder ) description ) . addattribute ( predicate , object ) ; } } } } } return description ; }
tr	4	protected tile gettile ( tile t , direction step ) { point location = t . getlocation ( ) ; switch ( step ) { case east : return gettile ( new point ( location . x + 1 , location . y ) ) ; case north : return gettile ( new point ( location . x , location . y - 1 ) ) ; case south : return gettile ( new point ( location . x , location . y + 1 ) ) ; case west : return gettile ( new point ( location . x - 1 , location . y ) ) ; default : return null ; } }
tr	0	protected void mapkeyboard ( ) { mapkeystroke ( keyevent . vk_up ) ; mapkeystroke ( keyevent . vk_down ) ; mapkeystroke ( keyevent . vk_right ) ; mapkeystroke ( keyevent . vk_left ) ; mapkeystroke ( keyevent . vk_page_down ) ; mapkeystroke ( keyevent . vk_page_up ) ; mapkeystroke ( keyevent . vk_home ) ; mapkeystroke ( keyevent . vk_end ) ; mapkeystroke ( keyevent . vk_numpad0 ) ; mapkeystroke ( keyevent . vk_numpad1 ) ; mapkeystroke ( keyevent . vk_numpad2 ) ; mapkeystroke ( keyevent . vk_numpad3 ) ; mapkeystroke ( keyevent . vk_numpad4 ) ; mapkeystroke ( keyevent . vk_numpad5 ) ; mapkeystroke ( keyevent . vk_numpad6 ) ; mapkeystroke ( keyevent . vk_numpad7 ) ; mapkeystroke ( keyevent . vk_numpad8 ) ; mapkeystroke ( keyevent . vk_numpad9 ) ; mapkeystroke ( keyevent . vk_minus ) ; mapkeystroke ( keyevent . vk_plus ) ; mapkeystroke ( keyevent . vk_comma ) ; mapkeystroke ( keyevent . vk_period ) ; mapkeystroke ( keyevent . vk_enter ) ; mapkeystroke ( keyevent . vk_kp_down ) ; mapkeystroke ( keyevent . vk_kp_left ) ; mapkeystroke ( keyevent . vk_kp_right ) ; mapkeystroke ( keyevent . vk_kp_up ) ; mapkeystroke ( keyevent . vk_f1 ) ; mapkeystroke ( keyevent . vk_f1 , inputevent . alt_down_mask ) ; mapkeystroke ( keyevent . vk_f2 ) ; mapkeystroke ( keyevent . vk_f2 , inputevent . alt_down_mask ) ; mapkeystroke ( keyevent . vk_f3 ) ; mapkeystroke ( keyevent . vk_f3 , inputevent . alt_down_mask ) ; mapkeystroke ( keyevent . vk_f4 ) ; mapkeystroke ( keyevent . vk_f4 , inputevent . alt_down_mask ) ; mapkeystroke ( keyevent . vk_f5 ) ; mapkeystroke ( keyevent . vk_f6 ) ; mapkeystroke ( keyevent . vk_f7 ) ; mapkeystroke ( keyevent . vk_f8 ) ; mapkeystroke ( keyevent . vk_f9 ) ; mapkeystroke ( keyevent . vk_f10 ) ; mapkeystroke ( keyevent . vk_f11 ) ; mapkeystroke ( keyevent . vk_f12 ) ; }
tr	8	public void run ( ) throws parsingexception { parsestack . push ( new terminalentry ( eof ) ) ; parsestack . addtoparsestack ( ruletable . find ( startsymbol , starttoken ) ) ; a = parsestack . peek ( ) ; getnexttoken ( ) ; while ( ( a != null ) && ! a . iseof ( ) ) { a = parsestack . peek ( ) ; if ( a . isterminal ( ) ) { if ( a . matches ( i ) ) { parsestack . pop ( ) ; if ( parsestack . notempty ( ) ) { a = parsestack . peek ( ) ; getnexttoken ( ) ; } } else { throw new parsingexception ( "terminal mismatch. expected: " + a + " found: " + i + "" ) ; } } else if ( a . issemanticentry ( ) ) { final semanticnode node = nodefactory . getnewnode ( a ) ; node . runonsemanticstack ( semanticstack ) ; parsestack . pop ( ) ; } else { if ( isrulecontained ( a , i ) ) { parsestack . pop ( ) ; parsestack . addtoparsestack ( ruletable . find ( a , i ) ) ; a = parsestack . peek ( ) ; } else { throw new parsingexception ( "non-terminal mismatch. no entry in the table for: " + a + "   " + i ) ; } } } if ( ! stream . isempty ( ) ) { throw new parsingexception ( "parser found the end of file marker but the token stream was not empty." ) ; } }
tr	4	public boolean savetofile ( string path ) { logger . info ( "write all shares into " + path ) ; if ( path == null || ! path . endswith ( ".ht" ) ) { throw new illegalargumentexception ( "the given path: " + path + " is not valid (must end with .ht)" ) ; } try { filewriter writer = new filewriter ( path , false ) ; writer . write ( convertsharestostring ( ) ) ; writer . close ( ) ; } catch ( filenotfoundexception e1 ) { logger . warning ( "the given path: " + path + " is not valid" ) ; return false ; } catch ( ioexception e ) { logger . warning ( "could not write to file '" + path + "' - " + e . getmessage ( ) ) ; return false ; } return true ; }
tr	0	@ test public void testmakestatsreturnscorrectstats ( ) { random rand = new random ( ) ; evdistribution evdistribution = mock ( evdistribution . class ) ; nature nature = mock ( nature . class ) ; when ( evdistribution . getnature ( ) ) . thenreturn ( nature ) ; int hpevs = rand . nextint ( 1000 ) ; int defevs = rand . nextint ( 1000 ) ; int spdefevs = rand . nextint ( 1000 ) ; when ( evdistribution . gethp ( ) ) . thenreturn ( hpevs ) ; when ( evdistribution . getdef ( ) ) . thenreturn ( defevs ) ; when ( evdistribution . getspdef ( ) ) . thenreturn ( spdefevs ) ; ibasestats basestats = mock ( ibasestats . class ) ; int basehp = rand . nextint ( 1000 ) ; int basedef = rand . nextint ( 1000 ) ; int basespdef = rand . nextint ( 1000 ) ; when ( basestats . gethp ( ) ) . thenreturn ( basehp ) ; when ( basestats . getdef ( ) ) . thenreturn ( basedef ) ; when ( basestats . getspdef ( ) ) . thenreturn ( basespdef ) ; int hpstat = rand . nextint ( 1000 ) ; int defstat = rand . nextint ( 1000 ) ; int spdefstat = rand . nextint ( 1000 ) ; when ( hpcalculator . calculate ( basehp , hpevs , nature ) ) . thenreturn ( hpstat ) ; when ( defcalculator . calculate ( basedef , defevs , nature ) ) . thenreturn ( defstat ) ; when ( spdefcalculator . calculate ( basespdef , spdefevs , nature ) ) . thenreturn ( spdefstat ) ; pokemonstats pokemonstats = statsfactory . makestats ( evdistribution , basestats ) ; assertequals ( hpstat , pokemonstats . gethp ( ) ) ; assertequals ( defstat , pokemonstats . getdef ( ) ) ; assertequals ( spdefstat , pokemonstats . getspdef ( ) ) ; }
tr	6	public static int getutf8 ( byte [ ] str , int start , mutableinteger ch ) { int c , n , i , bytes ; c = ( ( int ) str [ start ] ) & ff ; if ( ( c & e0 ) == c0 ) { n = c & 31 ; bytes = 2 ; } else if ( ( c & f0 ) == e0 ) { n = c & 15 ; bytes = 3 ; } else if ( ( c & f8 ) == f0 ) { n = c & 7 ; bytes = 4 ; } else if ( ( c & fc ) == f8 ) { n = c & 3 ; bytes = 5 ; } else if ( ( c & fe ) == fc ) { n = c & 1 ; bytes = 6 ; } else { ch . value = c ; return 0 ; } for ( i = 1 ; i < bytes ; ++ i ) { c = ( ( int ) str [ start + i ] ) & ff ; n = ( n << 6 ) | ( c & 3f ) ; } ch . value = n ; return bytes - 1 ; }
tr	9	public file getfilechoice ( component parent ) { if ( chooser . showsavedialog ( parent ) == jfilechooser . approve_option ) { file newfile = chooser . getselectedfile ( ) ; if ( chooser . getfilefilter ( ) == zipfilter ) { if ( ! newfile . getname ( ) . touppercase ( ) . endswith ( ".zip" ) ) { newfile = new file ( newfile . getabsolutefile ( ) + ".zip" ) ; } } if ( newfile . exists ( ) ) { int confirmchoice = joptionpane . showconfirmdialog ( parent , "file already exists. do you want to replace it?" ) ; if ( confirmchoice == joptionpane . yes_option ) { newfile . delete ( ) ; } else if ( confirmchoice == joptionpane . no_option ) { return getfilechoice ( parent ) ; } else { return null ; } } if ( ! newfile . exists ( ) ) { boolean filecreated = false ; try { filecreated = newfile . createnewfile ( ) ; } catch ( exception e ) { } finally { if ( ! filecreated ) { joptionpane . showmessagedialog ( parent , "an error occurred" ) ; return null ; } } } return newfile ; } else { return null ; } }
tr	6	private list < next > nextstates ( state < c > state ) { int m ; list < transition > nexts = new arraylist < > ( _transitions . get ( state ) ) ; list < next > result = new arraylist < > ( ) ; int offset = 0 ; while ( true ) { m = nextdeadline ( nexts , offset ) ; if ( m != integer . max_value ) { result . add ( selectnextstate ( m - offset , m , nexts ) ) ; offset = m ; } else { switch ( nexts . size ( ) ) { case 0 : throw new runtimeexception ( "automata has no default transition for node: " + state ) ; case 1 : transition target = nexts . get ( 0 ) ; next timeout = new next ( target . timeout ) ; timeout . add ( target . state , target . predicate ) ; result . add ( timeout ) ; break ; default : next infinites = new next ( infinity ) ; for ( transition t : nexts ) { if ( t . timeout != infinity ) throw new runtimeexception ( "cannot mix timeout alternative and infinite guards  neither having more than a single timeout alternative ('" + state + "': " + nexts + ")" ) ; infinites . add ( t . state , t . predicate ) ; } result . add ( infinites ) ; } break ; } } return result ; }
tr	7	@ eventhandler public void onplayermove ( playermoveevent event ) { if ( event . iscancelled ( ) ) { return ; } player player = event . getplayer ( ) ; if ( prechecks ( player , event . getto ( ) ) ) { jumpport port = jumpports . getport ( event . getto ( ) ) ; if ( checkinstant ( event ) ) { return ; } if ( checkjump ( event ) ) { return ; } if ( checkfall ( event ) ) { return ; } if ( ! ignoredplayers . contains ( player . getname ( ) ) ) { player . sendmessage ( lang . get ( "port.triggered" ) . replaceall ( "%n" , port . getname ( ) ) . replaceall ( "%d" , port . getdescription ( ) ) ) ; if ( port . getprice ( ) > 0 ) { player . sendmessage ( lang . get ( "port.price" ) . replaceall ( "%p" , "" + port . getprice ( ) ) ) ; } player . sendmessage ( lang . get ( "port.triggers" ) ) ; ignoredplayers . add ( player . getname ( ) ) ; } } }
tr	0	@ requestmapping ( value = "/orders/{id}/edit" , method = requestmethod . get ) public modelandview getorderedit ( @ pathvariable long id , modelmap model ) { uorder uorder = factory . getuorderdao ( ) . getbyid ( id ) ; collection < orderproduct > orderproducts = factory . getorderproductdao ( ) . getbyorderid ( id ) ; collection orderstatuses = factory . getorderstatusdao ( ) . getall ( ) ; model . put ( "orderstatuses" , orderstatuses ) ; model . put ( "order" , uorder ) ; model . put ( "orderproducts" , orderproducts ) ; return new modelandview ( "ordereditpage" , "model" , model ) ; }
tr	7	public static boolean searchandadd ( trienode root , trienode prev , char [ ] str , int index ) { if ( root == null ) { return false ; } if ( root . childlinks == null ) { insertnode ( root , str , 0 ) ; return false ; } if ( index < str . length ) { for ( trienode child : root . childlinks ) { if ( child . alphabet == str [ index ] ) { return searchandadd ( child , root , str , ++ index ) ; } } } if ( index == str . length && prev . endofword ) { return true ; } else { insertnode ( prev , str , index ) ; return false ; } }
tr	0	public subeditor ( subsystem - ) { this . settitle ( "subeditor - " + - . getname ( ) ) ; namefield . settext ( - . getname ( ) ) ; this . setmodal ( true ) ; jpanel np = new jpanel ( ) ; np . setlayout ( new flowlayout ( flowlayout . leading ) ) ; np . add ( new jlabel ( "name:" ) ) ; np . add ( namefield ) ; add ( np , borderlayout . north ) ; namefield . addactionlistener ( this ) ; panel = - . getsubpanel ( ) ; addparammenu ( ) ; addhelpmenu ( ) ; this . makecomponenttb ( ) ; paneljsp = new jscrollpane ( panel ) ; paneljsp . sethorizontalscrollbarpolicy ( jscrollpane . horizontal_scrollbar_as_needed ) ; paneljsp . setverticalscrollbarpolicy ( jscrollpane . vertical_scrollbar_as_needed ) ; add ( paneljsp ) ; add ( componenttb , borderlayout . west ) ; this . setdefaultcloseoperation ( jframe . hide_on_close ) ; this . setsize ( 800 , 600 ) ; this . setlocationrelativeto ( null ) ; }
tr	4	public static void main ( string [ ] args ) { jframe frame = new jframe ( ) ; frame . setsize ( 1500 , 1000 ) ; frame . setlocationrelativeto ( null ) ; frame . setdefaultcloseoperation ( jframe . exit_on_close ) ; frame . setvisible ( true ) ; final taskmgrgraph graph = new taskmgrgraph ( new taskmgrcolors ( ) ) ; new thread ( "memory thread" ) { @ override public void run ( ) { while ( true ) { runtime rt = runtime . getruntime ( ) ; long current = ( rt . totalmemory ( ) - rt . freememory ( ) ) / 1024 / 1024 ; long max = rt . totalmemory ( ) / 1024 / 1024 ; int % = ( int ) ( ( ( float ) current / ( float ) max ) * 100 ) ; graph . setmaximum ( ( int ) max ) ; graph . addvalue ( ( int ) current ) ; graph . settext ( current + " mb" ) ; system . out . println ( "current usage: " + current + "  maximum usage: " + max + "  percent: " + % ) ; try { thread . sleep ( 1000 ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } } } } ; new thread ( "random thread" ) { @ override public void run ( ) { while ( true ) { graph . setmaximum ( 10000 ) ; int value = new random ( ) . nextint ( 10000 ) ; graph . addvalue ( value ) ; graph . settext ( value + "" ) ; try { thread . sleep ( 1000 ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } } } } . start ( ) ; frame . add ( graph ) ; }
tr	0	private void createaroundvertex ( point p ) { addvertex ( p , getrandomname ( ) ) ; point p1 = new point ( p . x - 1 , p . y - 1 ) ; point p2 = new point ( p . x , p . y - 1 ) ; point p3 = new point ( p . x + 1 , p . y - 1 ) ; point p4 = new point ( p . x + 1 , p . y ) ; point p5 = new point ( p . x - 1 , p . y ) ; point p6 = new point ( p . x , p . y + 1 ) ; point p7 = new point ( p . x + 1 , p . y + 1 ) ; point p8 = new point ( p . x - 1 , p . y + 1 ) ; addvertex ( p1 , getrandomname ( ) ) ; addvertex ( p2 , getrandomname ( ) ) ; addvertex ( p3 , getrandomname ( ) ) ; addvertex ( p4 , getrandomname ( ) ) ; addvertex ( p5 , getrandomname ( ) ) ; addvertex ( p6 , getrandomname ( ) ) ; addvertex ( p7 , getrandomname ( ) ) ; addvertex ( p8 , getrandomname ( ) ) ; addedge ( p , p1 , 1 ) ; addedge ( p , p2 , 1 ) ; addedge ( p , p3 , 1 ) ; addedge ( p , p4 , 1 ) ; addedge ( p , p5 , 1 ) ; addedge ( p , p6 , 1 ) ; addedge ( p , p7 , 1 ) ; addedge ( p , p8 , 1 ) ; }
tr	7	private static void load ( final classloader loader , final linkedlist < ircplugindefinition > plugins , final file file , final string prefix ) { if ( file . isdirectory ( ) ) { if ( ! file . getname ( ) . startswith ( "." ) ) { for ( final file f : file . listfiles ( ) ) { filepluginsource . load ( loader , plugins , f , prefix + file . getname ( ) + "." ) ; } } } else { string name = prefix + file . getname ( ) ; final string ext = ".class" ; if ( name . endswith ( ext ) && ! name . startswith ( "." ) && ! name . contains ( "!" ) && ! name . contains ( "$" ) ) { name = name . substring ( 0 , name . length ( ) - ext . length ( ) ) ; filepluginsource . load ( loader , plugins , name , file . getabsolutepath ( ) ) ; } } }
tr	4	@ test public void dopriorityqueue ( ) { init ( ) ; int count = 0 ; while ( true ) { point x = prqueue . poll ( ) ; squares . add ( x ) ; point [ ] ppp = getpotentialpoints ( x , getcrosspoint ( x ) ) ; prqueue . add ( ppp [ 0 ] ) ; prqueue . add ( ppp [ 1 ] ) ; if ( count > 800000 ) break ; count ++ ; if ( x . hx == 3 && x . hy == 3 ) system . out . println ( "result " + squares . size ( ) ) ; } system . out . println ( squares . get ( 49 ) . hx + " " + squares . get ( 49 ) . hy ) ; }
tr	5	@ override public void draw ( spritebatch batch ) { if ( object . isvisible ( ) ) { graphics . draw ( batch ) ; } if ( animate ) { statetime += gdx . graphics . getdeltatime ( ) ; currentframe = explosionanimation . getkeyframe ( statetime , false ) ; batch . draw ( currentframe , ( animpos . x - 1f ) , ( animpos . y - 1f ) , 2 , 2 ) ; if ( explosionanimation . isanimationfinished ( statetime ) ) { animate = false ; worldobject . removelist . add ( object ) ; } } else if ( animatemiss ) { statetime += gdx . graphics . getdeltatime ( ) ; currentframe = splashanimation . getkeyframe ( statetime , false ) ; batch . draw ( currentframe , ( animpos . x - .5f ) , ( animpos . y - .5f ) , 1 , 1 ) ; if ( splashanimation . isanimationfinished ( statetime ) ) { animatemiss = false ; worldobject . removelist . add ( object ) ; } } }
tr	9	public void elemselected ( ) { defaultmutabletreenode node = ( defaultmutabletreenode ) optionstree . getlastselectedpathcomponent ( ) ; if ( node == null ) { return ; } if ( model . getselectednodes ( ) . isempty ( ) && model . getselectededges ( ) . isempty ( ) ) { return ; } string name = node . tostring ( ) ; switch ( name ) { case ( "constraint" ) : model . addconstraint ( ) ; break ; case ( "support parameters" ) : model . addsupport ( ) ; break ; case ( "force" ) : model . addforce ( ) ; break ; case ( "pressure" ) : model . addpressure ( ) ; break ; case ( "spring" ) : model . addspring ( ) ; break ; case ( "add group" ) : model . addfluidflow ( ) ; break ; default : system . out . println ( name ) ; break ; } model . setselectednodes ( new arraylist < > ( ) ) ; model . setselectededges ( new arraylist < > ( ) ) ; }
tr	6	public void openfile ( string filename ) { if ( m_bmpegplaying ) { m_bkeeprunning = false ; } if ( m_inputstream != null ) { try { m_inputstream . close ( ) ; } catch ( ioexception e ) { showdialog ( warning , e . getmessage ( ) ) ; } } if ( filename != null ) { try { try { url url = new url ( filename ) ; m_inputstream = new java . io . bufferedinputstream ( url . openstream ( ) ) ; } catch ( malformedurlexception e ) { m_inputstream = new java . io . bufferedinputstream ( new fileinputstream ( filename ) ) ; } } catch ( ioexception e ) { showdialog ( error , e . getmessage ( ) ) ; } } else showdialog ( error , "null filename" ) ; }
tr	3	public string getmimetype ( string paramstring ) { int i = paramstring . lastindexof ( "." ) ; if ( ( i > 0 ) && ( i + 1 < paramstring . length ( ) ) ) { string str1 = paramstring . substring ( i + 1 ) ; if ( this . extensiontomimetypemap . keyset ( ) . contains ( str1 ) ) { string str2 = ( string ) this . extensiontomimetypemap . get ( str1 ) ; logger . info ( "recognised extension '" + str1 + "'  mimetype is: '" + str2 + "'" ) ; return str2 ; } logger . info ( "extension '" + str1 + "' is unrecognized in mime type listing" + "  using default mime type: '" + "application/octet-stream" + "'" ) ; } else { logger . info ( "file name has no extension  mime type cannot be recognised for: " + paramstring ) ; } return "application/octet-stream" ; }
tr	1	private jpanel makeclientlistpanel ( ) { jpanel result = new jpanel ( new borderlayout ( ) ) ; clientlist = new clientlist ( ) ; clientlist . addlistselectionlistener ( new listselectionlistener ( ) { @ override public void valuechanged ( listselectionevent e ) { if ( clientlist . getselectedid ( ) == - 1 ) { btkick . setenabled ( false ) ; } else { btkick . setenabled ( true ) ; } } } ) ; result . add ( clientlist , borderlayout . center ) ; btkick = new jbutton ( "kick" ) ; btkick . setenabled ( false ) ; btkick . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent e ) { kick ( ) ; } } ) ; btkick . addkeylistener ( new keyadapter ( ) { @ override public void keypressed ( keyevent e ) { kick ( ) ; } } ) ; result . add ( btkick , borderlayout . south ) ; return result ; }
tr	1	@ override protected void selectionchanged ( int selectionindex ) { audiences au = model . getentity ( selectionindex ) ; string sql = "call au_subjects(?)" ; object [ ] [ ] result = dbconnection . getinstance ( ) . executequery ( sql , new object [ ] { au . getid ( ) } ) ; string [ ] subjects = new string [ result . length ] ; for ( int i = 0 ; i < subjects . length ; i ++ ) { subjects [ i ] = ( string ) result [ i ] [ 0 ] ; } object [ ] params = new object [ ] { au . getfullnumber ( ) , audiencemodel . audience_type [ au . gettype ( ) ] , au . getcapacity ( ) , subjects } ; htmlbuilder html = new htmlbuilder ( "audiences.rep" , params ) ; setinfotext ( html . tostring ( ) ) ; }
tr	9	protected boolean fireandhandleevent ( wordtokenizer tokenizer , spellcheckevent event ) { firespellcheckevent ( event ) ; string word = event . getinvalidword ( ) ; switch ( event . getaction ( ) ) { case spellcheckevent . initial : break ; case spellcheckevent . ignore : break ; case spellcheckevent . ignoreall : ignoreall ( word ) ; break ; case spellcheckevent . replace : tokenizer . replaceword ( event . getreplaceword ( ) ) ; break ; case spellcheckevent . replaceall : string replaceallword = event . getreplaceword ( ) ; if ( ! autoreplacewords . containskey ( word ) ) { autoreplacewords . put ( word , replaceallword ) ; } tokenizer . replaceword ( replaceallword ) ; break ; case spellcheckevent . addtodict : string addword = event . getreplaceword ( ) ; if ( ! addword . equals ( word ) ) tokenizer . replaceword ( addword ) ; userdictionary . addword ( addword ) ; break ; case spellcheckevent . cancel : return true ; default : throw new illegalargumentexception ( "unhandled case." ) ; } return false ; }
tr	4	public string tostring ( ) { string s = "" ; try { s = string . format ( "{%s: id = %s  " , this . getclass ( ) . getsimplename ( ) , this . getclass ( ) . getsuperclass ( ) . getdeclaredfield ( "id" ) . get ( this ) ) ; field [ ] fields = this . getclass ( ) . getdeclaredfields ( ) ; for ( field f : fields ) { f . setaccessible ( true ) ; if ( f . getname ( ) . equals ( "serialversionuid" ) ) continue ; if ( f . getname ( ) . equalsignorecase ( "objects" ) ) continue ; s += string . format ( "%s = %s  " , f . getname ( ) , f . get ( this ) ) ; } s = s . substring ( 0 , s . lastindexof ( " " ) ) ; s += "}" ; } catch ( exception e ) { e . printstacktrace ( ) ; } return s ; }
tr	6	public string getrecords ( ) { stringbuilder resultado = new stringbuilder ( ) ; if ( tipo != null ) { declaracion tmp = tipo ; tipodeclaracion tdecl = null ; tiporecord trec1 = null ; while ( tmp != null ) { if ( tmp instanceof tipodeclaracion ) { resultado . append ( ".namespace ejemplo{\n" ) ; tdecl = ( ( tipodeclaracion ) tmp ) ; resultado . append ( "\t.class private sequential ansi sealed beforefieldinit " ) . append ( tdecl . getnombre ( ) ) ; resultado . append ( " extends [mscorlib]system.valuetype{\n" ) ; tipo t = infsemantica . getinstancia ( ) . tablaglobal . get ( tdecl . getnombre ( ) ) ; tiporecord record = ( ( tiporecord ) t ) ; collections . reverse ( record . tbsimbolo . lista ) ; collections . reverse ( record . tbsimbolo . tipos ) ; for ( int i = 0 ; i < record . tbsimbolo . lista . size ( ) ; i ++ ) { if ( record . tbsimbolo . tipos . get ( i ) instanceof tiporecord ) { trec1 = ( ( tiporecord ) record . tbsimbolo . tipos . get ( i ) ) ; resultado . append ( "\t\t.field  public\t" ) . append ( "valuetype ejemplo." ) . append ( trec1 . nombre ) . append ( " " ) . append ( record . tbsimbolo . lista . get ( i ) ) . append ( "\n" ) ; } else if ( record . tbsimbolo . tipos . get ( i ) instanceof tipoarray ) { } else { resultado . append ( "\t\t.field  public\t" ) . append ( record . tbsimbolo . tipos . get ( i ) . tostring ( ) ) . append ( " " ) . append ( record . tbsimbolo . lista . get ( i ) ) . append ( "\n" ) ; } } resultado . append ( "\n\t}\n}\n" ) ; } tmp = tmp . getsiguiente ( ) ; } } else { resultado . append ( "" ) ; } return resultado . tostring ( ) ; }
tr	9	public void setvoisins ( ) { arraylist < neuron > voisins ; for ( int col = 0 ; col < colnumber ; col ++ ) { for ( int row = 0 ; row < rownumber ; row ++ ) { voisins = new arraylist < neuron > ( ) ; if ( col < colnumber - 1 ) { voisins . add ( neurons . get ( row ) . get ( col + 1 ) ) ; } if ( col > 0 ) { voisins . add ( neurons . get ( row ) . get ( col - 1 ) ) ; } if ( row == 0 && neurons . size ( ) > 1 ) { voisins . add ( neurons . get ( row + 1 ) . get ( col ) ) ; } else if ( row == neurons . size ( ) - 1 && neurons . size ( ) > 1 ) { voisins . add ( neurons . get ( row - 1 ) . get ( col ) ) ; } else if ( neurons . size ( ) > 1 ) { voisins . add ( neurons . get ( row + 1 ) . get ( col ) ) ; voisins . add ( neurons . get ( row - 1 ) . get ( col ) ) ; } neurons . get ( row ) . get ( col ) . setneighbors ( voisins ) ; } } }
tr	4	private void addcontent ( ) { scheduledao sdao = new scheduledao ( db . connection ) ; for ( string day : staticres . week_day_list ) { list < schedule > list = sdao . getschedulebydaylist ( day ) ; tablemodel model = new scheduletablemodel ( list ) ; table = new jtable ( model ) ; table . setselectionmode ( listselectionmodel . single_selection ) ; table . getcolumnmodel ( ) . getcolumn ( 0 ) . setpreferredwidth ( 100 ) ; table . getcolumnmodel ( ) . getcolumn ( 1 ) . setpreferredwidth ( 17 ) ; table . setrowheight ( 20 ) ; table . addmouselistener ( new java . awt . event . mouseadapter ( ) { @ override public void mouseclicked ( java . awt . event . mouseevent evt ) { if ( evt . getclickcount ( ) == 2 && evt . getbutton ( ) == mouseevent . button1 ) { int row = ( ( jtable ) evt . getsource ( ) ) . rowatpoint ( evt . getpoint ( ) ) ; ; if ( row >= 0 ) { schedule schedule = ( schedule ) ( ( jtable ) evt . getsource ( ) ) . getvalueat ( row , - 1 ) ; teacher teacher = ( teacher ) cbteacher . getselecteditem ( ) ; submit ( schedule , teacher ) ; } } } } ) ; tabbedpane . addtab ( day , new jscrollpane ( table ) ) ; } }
tr	3	public list < pattern > findpatternsequalto ( int matchpattern , int matchcount , int [ ] [ ] board ) { list < pattern > resultpatterns = new arraylist < pattern > ( ) ; for ( int i = 0 ; i < board . length ; i ++ ) { for ( int j = 0 ; j < board [ i ] . length ; j ++ ) { list < pattern > result = checkpiecepatterns ( i , j , matchpattern , matchcount , board ) ; if ( result . size ( ) > 0 ) { resultpatterns . addall ( result ) ; } } } return resultpatterns ; }
tr	1	public object [ ] [ ] getestacionescercanas ( int ci ) throws elementonoencontradoexception { object [ ] [ ] datos = new object [ objea . getestacionescercanas ( objua . getusuario ( ci ) ) . size ( ) ] [ 2 ] ; int cont = 0 ; for ( estacion obje : objea . getestacionescercanas ( objua . getusuario ( ci ) ) . values ( ) ) { datos [ cont ] [ 0 ] = obje . getnom ( ) ; datos [ cont ] [ 1 ] = obje . getcp ( ) ; cont ++ ; } return datos ; }
tr	7	public string tofirstuppercase ( string title ) { if ( title . length ( ) == 0 ) return "" ; string uppercase = title . substring ( 0 , 1 ) . touppercase ( ) ; boolean isthefirst = false ; if ( title . length ( ) > 1 ) for ( int i = 1 ; i < title . length ( ) ; i ++ ) { if ( title . charat ( i ) ==   ) { uppercase += title . substring ( i , i + 1 ) ; if ( i + 1 < title . length ( ) && ! title . substring ( i + 1 , i + 2 ) . equals ( " " ) ) isthefirst = true ; } else { if ( isthefirst ) { uppercase += title . substring ( i , i + 1 ) . touppercase ( ) ; isthefirst = false ; } else { uppercase += title . substring ( i , i + 1 ) ; } } } system . out . println ( uppercase ) ; return uppercase ; }
tr	7	public static double dodefabilitybasepowermod ( activepokemon defender , move move , double damage ) { if ( defender . hasability ( ability . thick_fat ) && ( move . istype ( type . ice ) || move . istype ( type . fire ) ) ) { damage *= 0.5 ; } else if ( defender . hasability ( ability . heatproof ) && move . istype ( type . fire ) ) { damage *= 0.5 ; } else if ( defender . hasability ( ability . dry_skin ) && move . istype ( type . fire ) ) { damage *= 1.25 ; } damage = ( int ) damage ; return damage ; }
tr	5	private string generaterandomid ( ) { stringbuilder sb = new stringbuilder ( ) ; int retry = 0 ; do { while ( sb . length ( ) < idlength ) { char ch = ( char ) rnd . nextint ( ) ; if ( utils . isuriletterordigit ( ch ) ) { sb . append ( ch ) ; } } if ( tokens . containskey ( sb . tostring ( ) ) ) { sb . delete ( 0 , idlength ) ; } retry ++ ; } while ( sb . length ( ) == 0 || retry > retry_count ) ; return sb . tostring ( ) ; }
tr	8	private boolean swap ( semanticframe frame , int n , int m , int [ ] match , int [ ] invmatch , int p , int b , tintarraylist args ) { int a = match [ p ] ; int q = invmatch [ b ] ; if ( p >= n && q >= n ) { return false ; } else if ( a >= m && b >= m ) { return false ; } if ( p < n ) frame . arglbids [ args . get ( p ) ] = b < m ? b : - 1 ; if ( q < n ) frame . arglbids [ args . get ( q ) ] = a < m ? a : - 1 ; match [ p ] = b ; invmatch [ b ] = p ; match [ q ] = a ; invmatch [ a ] = q ; return true ; }
tr	5	@ override public void run ( ) { string author = item . getauthor ( ) ; string title = item . gettitle ( ) ; string dir = "./cache" ; string localcover = dir + "/cover/" + title + "-" + author + ".jpg" ; string localsong = dir + "/song/" + title + "-" + author + ".mp3" ; try { if ( item . getcover ( ) != null && item . getcover ( ) . startswith ( "http" ) ) { httputil . downloadbybyte ( localcover , item . getcover ( ) ) ; item . setcover ( localcover ) ; } oncovercomplete ( item ) ; if ( item . getcover ( ) != null && item . getpath ( ) . startswith ( "http" ) ) { httputil . downloadbybyte ( localsong , item . getpath ( ) ) ; item . setpath ( localsong ) ; item . setlocal ( true ) ; } onsongcomplete ( item ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } }
tr	4	private nodo buscarnodo ( string padre ) { nodo tmp1 = this . raiz ; nodo tmp2 = tmp1 ; stringtokenizer path = new stringtokenizer ( padre , "/" ) ; string s ; while ( path . hasmoretokens ( ) ) { s = path . nexttoken ( ) ; while ( tmp1 != null ) { if ( s . equals ( tmp1 . dato ) ) break ; else { tmp2 = tmp1 = tmp1 . primerhijo ; } } if ( tmp1 == null ) return tmp1 ; else { tmp2 = tmp1 ; tmp1 = tmp1 . siguientehermano ; } } return tmp2 ; }
tr	7	public void sendpinmsg ( ) { message = msgs . gettext ( ) ; subject = subj . gettext ( ) ; httpclient hc = new httpclient ( ) ; hc . getconnectionstring ( ) ; if ( ! appfunctions . ntwkcon ) { uiapplication . getuiapplication ( ) . invokelater ( new runnable ( ) { public void run ( ) { dialog . inform ( "please check your network  pin broadcast requires bis or wifi" ) ; info . settext ( "check your network connection" ) ; } } ) ; } else if ( appfunctions . trialcount < 1 ) { uiapplication . getuiapplication ( ) . invokelater ( new runnable ( ) { public void run ( ) { dialog . inform ( "you have exceeded the number of messages you can send. you have " + appfunctions . trialcount + " left. please buy more messages by selecting the 'buy pin message' menu for information on subscription. select 'verify account' on the menu after subscription to send more messages." ) ; info . settext ( "message number exceeded." ) ; } } ) ; } else if ( contactarray . size ( ) > appfunctions . trialcount ) { uiapplication . getuiapplication ( ) . invokelater ( new runnable ( ) { public void run ( ) { dialog . inform ( "the contacts in your message exceeds what you have left (" + appfunctions . formatnumber ( appfunctions . trialcount , 0 , " " ) + "). please subscribe and select 'verify account' on the menu for unlimited contacts or reduce the number of your contacts to " + appfunctions . formatnumber ( appfunctions . trialcount , 0 , " " ) ) ; } } ) ; } else { if ( message . length ( ) < 5 || subject . length ( ) < 3 || from . gettext ( ) . length ( ) < 2 || filesel == null ) { uiapplication . getuiapplication ( ) . invokelater ( new runnable ( ) { public void run ( ) { dialog . inform ( "please verify that from  subject  message and your contact file has been entered properly before sending this message." ) ; info . settext ( "error in message  please check again." ) ; } } ) ; } else { new thread ( sndmsg ) . start ( ) ; } } }
tr	9	public void initializegameworld ( int numenemytanks , int numrocks , int numtrees ) { listobjects = new linkedlist < gameobject > ( ) ; tanks = new linkedlist < tank > ( ) ; landscape = new linkedlist < landscapegameobject > ( ) ; projectiles = new linkedlist < projectile > ( ) ; playertank = getrandomplayertank ( 0 ) ; for ( int i = 0 ; i < numenemytanks ; i ++ ) { tank tank = getrandomtank ( ) ; while ( collideswithworld ( tank ) ) { if ( game . debug ) { system . out . println ( "tank placement collision" ) ; } tank = getrandomtank ( ) ; } addtank ( tank ) ; } for ( int j = 0 ; j < numrocks ; j ++ ) { rock rock = getrandomrock ( j ) ; while ( collideswithworld ( rock ) ) { if ( game . debug ) { system . out . println ( "rock placement collision" ) ; } rock = getrandomrock ( j ) ; } addlandscapeobject ( rock ) ; } for ( int k = 0 ; k < numtrees ; k ++ ) { tree tree = getrandomtree ( k ) ; while ( collideswithworld ( tree ) ) { if ( game . debug ) { system . out . println ( "tree placement collision" ) ; } tree = getrandomtree ( k ) ; } addlandscapeobject ( tree ) ; } addtank ( playertank ) ; lives = startinglives ; score = 0 ; gameclock = 0 ; gameover = false ; totaltankcount = 0 ; notifyobservers ( ) ; }
tr	2	public static void main ( final string args [ ] ) { if ( args . length != 0 ) { string name = args [ 0 ] ; try { querydefinition query = settings . getinstance ( ) . getquery ( name ) ; response response = query . execute ( ) ; system . out . print ( response . getrawvalue ( ) ) ; } catch ( exception e ) { system . err . print ( e . getmessage ( ) ) ; } } else { invokelater ( new runnable ( ) { public void run ( ) { new mainform ( args ) . setvisible ( true ) ; } } ) ; } }
tr	1	public void drawpoint ( vertex vertex ) { init ( ) ; double x = vertex . getpoint ( ) . getx ( ) * scale_x ; double y = vertex . getpoint ( ) . gety ( ) * scale_y ; ellipse2d el = new ellipse2d . double ( x - pointsize / 2. , y - pointsize / 2. , pointsize , pointsize ) ; ensurehassize ( el . getbounds2d ( ) ) ; graphics2d g = getgraphicsobject ( ) ; g . setstroke ( new basicstroke ( ( float ) pensize ) ) ; g . setcolor ( pencolor ) ; g . setcolor ( pointfill ) ; g . fill ( el ) ; g . setcolor ( pointborder ) ; g . draw ( el ) ; if ( showvertexnumbers ) g . drawstring ( "" + vertex . getvertexindex ( ) , ( float ) x - 5 , ( float ) y + 5 ) ; repaint ( ) ; }
tr	8	protected filerequestresponsemessage handleresponse ( inputstream in ) throws unsupportedencodingexception { filerequestresponsemessage try_again = new filerequestresponsemessage ( filerequestresponsemessage . responsecode . try_again_later , 0 ) ; int probe_len = filerequestresponsemessage . type_field . length ( ) + 4 ; byte [ ] buffer = new byte [ probe_len ] ; try { in . read ( buffer , 0 , probe_len ) ; } catch ( ioexception e ) { logger . log ( level . severe , "could not read response stream: '" + e . getmessage ( ) + "' - assuming 'never try again'" ) ; return try_again ; } string responseheader = new string ( buffer , message . encoding ) . trim ( ) ; switch ( responseheader . touppercase ( ) ) { case filerequestresponsemessage . type_field + message . field_seperator + "ok" : string str_expectedtransfervolume = "" ; int next ; try { while ( ( next = in . read ( ) ) != message . message_sperator ) if ( next == - 1 ) { thread . sleep ( 500 ) ; } else { str_expectedtransfervolume += new string ( new byte [ ] { ( byte ) next } , message . encoding ) ; } } catch ( ioexception | interruptedexception e ) { logger . log ( level . severe , "could not understand response header" ) ; transferstate = transferstatus . lostconnection ; closesocket ( ) ; return null ; } try { long expectedtransfervolume = long . valueof ( str_expectedtransfervolume ) ; return new filerequestresponsemessage ( filerequestresponsemessage . responsecode . ok , expectedtransfervolume ) ; } catch ( numberformatexception ex ) { logger . log ( level . severe , "response contained invalid 'expected transfer volume' - assuming 'try again later'" ) ; return try_again ; } case filerequestresponsemessage . type_field + message . field_seperator + "try" : logger . log ( level . info , "received 'try again later from host'" ) ; return try_again ; case filerequestresponsemessage . type_field + message . field_seperator + "nev" : logger . log ( level . info , "received 'never try agiain from host'" ) ; return new filerequestresponsemessage ( filerequestresponsemessage . responsecode . never_try_again , 0 ) ; default : logger . log ( level . info , "received garbage: '" + responseheader + "'" ) ; return try_again ; } }
tr	6	private boolean ispredictableresult ( ) { boolean commset = true ; for ( int i = 0 ; i < 5 ; i ++ ) { if ( this . communitycards [ i ] == null ) { commset = false ; break ; } } if ( commset ) { boolean correctplayertypes = false ; for ( playerprofile profile : this . profiles ) { if ( profile . gethandtype ( ) != handtype . exactcards ) { correctplayertypes = true ; break ; } } if ( ! correctplayertypes ) { return true ; } } return false ; }
tr	7	public static questioncalculation decode ( string encodedquestioncalculation ) throws decodeexception { questioncalculation res ; if ( encodedquestioncalculation . substring ( 0 , 19 ) . compareto ( "#questioncalculaion" ) == 0 ) { res = new questioncalculation ( ) ; int i = 19 ; if ( encodedquestioncalculation . charat ( i ) == < ) { while ( encodedquestioncalculation . charat ( i ) != > ) { i ++ ; } arraylist < integer > tmp_opd = decodeoperands ( encodedquestioncalculation . substring ( 20 , i ) ) ; res . setoperands ( tmp_opd ) ; i ++ ; int beginning = i ; if ( encodedquestioncalculation . charat ( i ) == < ) { while ( encodedquestioncalculation . charat ( i ) != > ) { i ++ ; } arraylist < character > tmp_opt = decodeoperators ( encodedquestioncalculation . substring ( beginning + 1 , i ) ) ; assert tmp_opt . size ( ) == tmp_opt . size ( ) + 1 : "incorrect size of operators table" ; res . setoperators ( tmp_opt ) ; i ++ ; beginning = i ; if ( encodedquestioncalculation . charat ( i ) == < ) { while ( encodedquestioncalculation . charat ( i ) != > ) { i ++ ; } int tmp_lth = integer . valueof ( encodedquestioncalculation . substring ( beginning + 1 , i ) ) ; assert tmp_lth < 0 : "negative length" ; res . setlength ( tmp_lth ) ; i ++ ; encodedquestioncalculation = encodedquestioncalculation . substring ( i ) ; question . decode ( res , encodedquestioncalculation ) ; } else { res = null ; throw new decodeexception ( ) ; } } else { res = null ; throw new decodeexception ( ) ; } } else { res = null ; throw new decodeexception ( ) ; } } else { res = null ; throw new decodeexception ( ) ; } return res ; }
tr	6	private void createunits ( ) { arraylist < building > buildings = g . map . getplayersbuildings ( this ) ; boolean hasmoney = true ; while ( hasmoney ) { for ( building building : buildings ) { if ( building instanceof factory ) { ( ( factory ) building ) . recruittank ( g . map , building . getcell ( ) , true ) ; } if ( building instanceof barracks ) { ( ( barracks ) building ) . recruitmarine ( g . map , building . getcell ( ) , true ) ; } } if ( buildings . contains ( barracks . class ) ) { hasmoney = this . getmoney ( ) >= marine . cost ; } else if ( buildings . contains ( factory . class ) ) { hasmoney = this . getmoney ( ) >= tank . cost ; } else { hasmoney = false ; } } }
tr	9	public static method getmostspecificmethod ( method method , class < ? > targetclass ) { if ( method != null && isoverridable ( method , targetclass ) && targetclass != null && ! targetclass . equals ( method . getdeclaringclass ( ) ) ) { try { if ( modifier . ispublic ( method . getmodifiers ( ) ) ) { try { return targetclass . getmethod ( method . getname ( ) , method . getparametertypes ( ) ) ; } catch ( nosuchmethodexception ex ) { return method ; } } else { method specificmethod = reflectionutils . findmethod ( targetclass , method . getname ( ) , method . getparametertypes ( ) ) ; return ( specificmethod != null ? specificmethod : method ) ; } } catch ( securityexception ex ) { } } return method ; }
tr	1	public static void main ( string [ ] args ) { try { = ( 0 , ( new palindromephrases ( ) ) . getamount ( new string [ ] { "a" , "ba" } ) , 2 ) ; = ( 1 , ( new palindromephrases ( ) ) . getamount ( new string [ ] { "ab" , "bcd" , "efg" } ) , 0 ) ; = ( 2 , ( new palindromephrases ( ) ) . getamount ( new string [ ] { "a" , "bba" , "abb" } ) , 7 ) ; = ( 3 , ( new palindromephrases ( ) ) . getamount ( new string [ ] { "aabccc" , "ccbbca" , "a" , "acaabb" , "aaa" , "aab" , "c" , "babb" , "aacaa" , "b" } ) , 47 ) ; } catch ( exception exx ) { system . err . println ( exx ) ; exx . printstacktrace ( system . err ) ; } }
tr	4	public double evalutethestrategy ( ) { double sellsum = 0 ; double buysum = 0 ; int count = 0 ; int numberofsell = this . getnumberofsell ( ) ; for ( generatedsignal gs : gensiglist ) { if ( gs . gettype ( ) . equals ( "sell" ) ) { sellsum += gs . getprice ( ) ; } else if ( gs . gettype ( ) . equals ( "buy" ) && count < numberofsell ) { buysum += gs . getprice ( ) ; count ++ ; } } return ( sellsum - buysum ) ; }
tr	7	public static void main ( string [ ] args ) throws exception { applicationcontext context = new classpathxmlapplicationcontext ( "spring-module.xml" ) ; userservice userservice = ( userservice ) context . getbean ( "userservicebean" ) ; system . out . println ( "-------- --- user --- ---------" ) ; user user = userservice . finduserbyemailpassword ( "martinpucheu@udec.cl" , "cresposexy" ) ; system . out . println ( "el usuario encontrado tiene como apellido: " + user . getlastname ( ) ) ; movieservice movieservice = ( movieservice ) context . getbean ( "movieservicebean" ) ; movie m = new movie ( "american hustle" , 2013 , "pel\u00edcula de esta estafadores" , "david o. russell" ) ; movieservice . insert ( m ) ; system . out . println ( "-------- --- movies --- ---------" ) ; movie _movie = movieservice . findmoviebyid ( 3 ) ; system . out . println ( "la pel\u00edcula encontrada es: " + _movie . getname ( ) ) ; system . out . println ( " -.-.-.-" ) ; list < movie > _movie2 = movieservice . findmoviebytitle ( "twilight" ) ; for ( int i = 0 ; i < _movie2 . size ( ) ; i ++ ) { system . out . println ( "econtre la pel\u00edcula que buscabas  es: " + _movie2 . get ( i ) . getname ( ) + " verdad?" ) ; } actorservice actorservice = ( actorservice ) context . getbean ( "actorservicebean" ) ; system . out . println ( "-------- --- actor --- ---------" ) ; actor _actor = actorservice . findactorbyid ( 1 ) ; system . out . println ( "el actor encontrado es: " + _actor . getname ( ) + " " + _actor . getlname ( ) ) ; actorservice actsservice = ( actorservice ) context . getbean ( "actsservicebean" ) ; system . out . println ( "-------- --- acts --- ---------" ) ; list < acts > _acts = actsservice . findactsbymoiveid ( 1 ) ; for ( int i = 0 ; i < _acts . size ( ) ; i ++ ) system . out . println ( "en la pel\u00edcula de id:1 actua el actor con id:[" + _acts . get ( i ) . getida ( ) + "]" ) ; movieservice categoryservice = ( movieservice ) context . getbean ( "categoryservicebean" ) ; system . out . println ( "-------- --- category --- ---------" ) ; category _category = categoryservice . findcategorybygenre ( "thriller" ) ; system . out . println ( "la categoria encontrada fue: " + _category . getgenre ( ) ) ; userservice doeslikeservice = ( userservice ) context . getbean ( "doeslikeservicebean" ) ; system . out . println ( "-------- --- doeslike--- ---------" ) ; list < doeslike > _doeslike = doeslikeservice . finddoeslikebyid ( 1 ) ; for ( int i = 0 ; i < _doeslike . size ( ) ; i ++ ) system . out . println ( "al usuario 1 le gusta el genero: " + _doeslike . get ( i ) . getgenre ( ) ) ; userservice doesnotlikeservice = ( userservice ) context . getbean ( "doesnotlikeservicebean" ) ; system . out . println ( "-------- --- doesnotlike--- ---------" ) ; list < doesnotlike > _doesnotlike = doesnotlikeservice . finddoesnotlikebyid ( 1 ) ; for ( int i = 0 ; i < _doesnotlike . size ( ) ; i ++ ) system . out . println ( "al usuario 1 no le gusta el genero: " + _doesnotlike . get ( i ) . getgenre ( ) ) ; movieservice idiomservice = ( movieservice ) context . getbean ( "idiomservicebean" ) ; system . out . println ( "-------- --- idiom --- ---------" ) ; idiom _idiom = idiomservice . findidiombylanguage ( "espanol" ) ; system . out . println ( "el idioma encontrado es: " + _idiom . getlanguage ( ) ) ; userservice idiompservice = ( userservice ) context . getbean ( "idiompservicebean" ) ; system . out . println ( "-------- --- idiomp --- ---------" ) ; list < idiomp > _idiomp = idiompservice . findbyuserid ( 3 ) ; for ( int i = 0 ; i < _idiomp . size ( ) ; i ++ ) system . out . println ( "al usuario 3 le gustan las peliculas en idioma: " + _idiomp . get ( i ) . getlanguage ( ) ) ; movieservice moviecategoryservice = ( movieservice ) context . getbean ( "moviecategoryservicebean" ) ; system . out . println ( "-------- --- moviecategory --- ---------" ) ; list < moviecategory > _moviecategory = moviecategoryservice . findmoviesbygendre ( "thriller" ) ; for ( int i = 0 ; i < _moviecategory . size ( ) ; i ++ ) system . out . println ( "los id de las pel\u00edculas del genero thriller son: " + _moviecategory . get ( i ) . getidp ( ) ) ; movieservice ratingservice = ( movieservice ) context . getbean ( "ratingservicebean" ) ; system . out . println ( "-------- --- rating --- ---------" ) ; rating _rating = ratingservice . findratingbyid ( 1 , 1 ) ; system . out . println ( "la calificaci\u00f3n que le dio el usuario 2 a la pel\u00edcula 3 es: [" + _rating . getmark ( ) + "]" ) ; movieservice speakservice = ( movieservice ) context . getbean ( "speakservicebean" ) ; speak _speak2 = new speak ( 2 , "frances" ) ; system . out . println ( "-------- --- speak --- ---------" ) ; speak _speak = speakservice . findspeakbyidp ( 4 ) ; system . out . println ( "el idioma de la pel\u00edcula 4 es: " + _speak . getlengua ( ) ) ; userservice wishlistservice = ( userservice ) context . getbean ( "wishlistservicebean" ) ; wishlist wishlist = new wishlist ( 5 , 1 ) ; system . out . println ( "-------- --- wishlist --- ---------" ) ; list < wishlist > _wishlist = wishlistservice . findwishlistbyid ( 1 ) ; for ( int i = 0 ; i < _wishlist . size ( ) ; i ++ ) system . out . println ( "la pel\u00edcula con id:" + _wishlist . get ( i ) . getidp ( ) + " est\u00e1 en la wishlist del usuario 1 " ) ; }
tr	7	public static void lockinstance ( int port ) { if ( lockserver == null ) { try { lockserver = new serversocket ( port ) ; new thread ( ) { @ override public void run ( ) { while ( true ) { try { socket socket = lockserver . accept ( ) ; objectinputstream in = new objectinputstream ( socket . getinputstream ( ) ) ; if ( window != null && in . readboolean ( ) ) { window . setvisible ( true ) ; swingutilities . invokelater ( new runnable ( ) { @ override public void run ( ) { window . setvisible ( true ) ; window . tofront ( ) ; window . requestfocus ( ) ; } } ) ; } in . close ( ) ; socket . close ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } } } } . start ( ) ; } catch ( ioexception e ) { try { socket socket = new socket ( strings . getstring ( instancelock . class , "0" ) , port ) ; objectoutputstream out = new objectoutputstream ( socket . getoutputstream ( ) ) ; out . writeboolean ( true ) ; out . close ( ) ; socket . close ( ) ; } catch ( exception e1 ) { } system . exit ( 0 ) ; } } }
tr	8	public void render ( map map ) { if ( updatesenses ) { long starttime = system . currenttimemillis ( ) ; playersenses = map . getplayersenses ( ) ; long endtime = system . currenttimemillis ( ) ; log . print ( "shadowcasting time: " + ( endtime - starttime ) ) ; updatesenses = false ; } hashmap < integer , tile > tilehashmap = playersenses . gettiles ( ) ; hashmap < integer , actor > actorhashmap = playersenses . getactors ( ) ; hashmap < integer , arraylist < entity >> entities = playersenses . getentities ( ) ; point top_left = new point ( playerpos . getx ( ) - tilesx , playerpos . gety ( ) - tilesy ) ; for ( int x = top_left . getx ( ) ; x <= playerpos . getx ( ) + tilesx ; x ++ ) { for ( int y = top_left . gety ( ) ; y <= playerpos . gety ( ) + tilesy ; y ++ ) { if ( map . inbounds ( x , y ) ) { tile tile = tilehashmap . get ( map . genkey ( x , y ) ) ; if ( tile != null ) { image image = environment . getsprite ( tile . getspriteid ( ) ) ; image . draw ( ( float ) ( ( x - top_left . getx ( ) ) * ppt ) , ( float ) ( ( y - top_left . gety ( ) ) * ppt ) , scale ) ; } arraylist < entity > ents = entities . get ( map . genkey ( x , y ) ) ; if ( ents != null && ents . size ( ) > 0 ) { entity entity = ents . get ( 0 ) ; image image = environment . getsprite ( entity . getspriteid ( ) ) ; image . draw ( ( float ) ( ( x - top_left . getx ( ) ) * ppt ) , ( float ) ( ( y - top_left . gety ( ) ) * ppt ) , scale ) ; } actor actor = actorhashmap . get ( map . genkey ( x , y ) ) ; if ( actor != null ) { image image = actor_sprites . getsprite ( actor . getspriteid ( ) ) ; image . draw ( ( float ) ( ( x - top_left . getx ( ) ) * ppt ) , ( float ) ( ( y - top_left . gety ( ) ) * ppt ) , scale ) ; } } } } image player = actor_sprites . getsprite ( actorsprite . player ) ; player . draw ( ( float ) ( ( playerpos . getx ( ) - top_left . getx ( ) ) * ppt ) , ( float ) ( ( playerpos . gety ( ) - top_left . gety ( ) ) * ppt ) , scale ) ; messagebox . render ( ) ; }
tr	2	public static void main ( string [ ] args ) { treeset < integer > set2 = new treeset < integer > ( ) ; set2 . add ( 4 ) ; set2 . add ( 100 ) ; set2 . add ( 45 ) ; set2 . add ( 19 ) ; set2 . add ( 33 ) ; arraylist < treeset < integer >> totalsubsets = findsubsets ( set2 , 0 ) ; if ( totalsubsets == null ) system . out . println ( "no possible subsets" ) ; else for ( treeset < integer > ts : totalsubsets ) { system . out . println ( ts ) ; } }
tr	0	public worldmap ( mapbaggage baggage ) { planet = new planet ( baggage . polarcircumferenceinkilometers ) ; mesh = new icosahedralmesh ( baggage . meshsize ) ; int numcells = mesh . countcells ( ) ; terrain = porter . stringstoterrain ( baggage . terrainstrings , numcells ) ; bonuses = porter . stringtobits ( baggage . bonusstring , numcells ) ; roads = porter . stringtobits ( baggage . roadstring , numcells ) ; railroads = porter . stringtobits ( baggage . railroadstring , numcells ) ; irrigation = porter . stringtobits ( baggage . irrigationstring , numcells ) ; villages = porter . stringtobits ( baggage . villagestring , numcells ) ; cities = porter . stringtobits ( baggage . citystring , numcells ) ; }
tr	6	public int [ ] likertjakauma ( ) { int [ ] jakaumat = new int [ 5 ] ; int ykkoset = 0 ; int kakkoset = 0 ; int kolmoset = 0 ; int neloset = 0 ; int vitoset = 0 ; for ( int arvo : this . aineisto ) { if ( arvo == 1 ) { ykkoset ++ ; } else if ( arvo == 2 ) { kakkoset ++ ; } else if ( arvo == 3 ) { kolmoset ++ ; } else if ( arvo == 4 ) { neloset ++ ; } else if ( arvo == 5 ) { vitoset ++ ; } } double summa = ykkoset + kakkoset + kolmoset + neloset + vitoset ; jakaumat [ 0 ] = ( int ) ( 100 * ( 1.0 * ykkoset / summa ) ) ; jakaumat [ 1 ] = ( int ) ( 100 * ( 1.0 * kakkoset / summa ) ) ; jakaumat [ 2 ] = ( int ) ( 100 * ( 1.0 * kolmoset / summa ) ) ; jakaumat [ 3 ] = ( int ) ( 100 * ( 1.0 * neloset / summa ) ) ; jakaumat [ 4 ] = ( int ) ( 100 * ( 1.0 * vitoset / summa ) ) ; return jakaumat ; }
tr	3	public void savegame ( ) throws cannotsaveexception { try { savefile savefile = new savefile ( gamesaver . auto_save_location ) ; fileoutputstream savestream = new fileoutputstream ( savefile . getfile ( ) ) ; objectoutputstream save = new objectoutputstream ( savestream ) ; save . writeobject ( gamestate . getinstance ( ) ) ; save . close ( ) ; } catch ( cannotcreatefileexception e ) { throw new cannotsaveexception ( "cannot create file" ) ; } catch ( filenotfoundexception e ) { throw new cannotsaveexception ( "file not found" ) ; } catch ( ioexception e ) { throw new cannotsaveexception ( "io exception" ) ; } }
tr	2	static list < vcscommit > parsecommits ( string xml ) { try { commitreadinghandler commitreadinghandler = new commitreadinghandler ( ) ; saxparserfactory parserfactory = saxparserfactory . newinstance ( ) ; xmlreader xmlreader = parserfactory . newsaxparser ( ) . getxmlreader ( ) ; xmlreader . setcontenthandler ( commitreadinghandler ) ; xmlreader . parse ( new inputsource ( new stringreader ( xml ) ) ) ; return commitreadinghandler . commits ; } catch ( saxexception e ) { throw new runtimeexception ( "failed to parse xml: " + xml , e ) ; } catch ( parserconfigurationexception | ioexception e ) { throw new runtimeexception ( e ) ; } }
tr	3	public static string strfill ( string fillstr , string oldstr , int length , string place ) { stringbuffer sb = new stringbuffer ( ) ; if ( "right" . equals ( place ) ) { sb . append ( oldstr ) ; } for ( int i = 0 ; i < ( length - oldstr . length ( ) ) ; i ++ ) { sb . append ( fillstr ) ; } if ( "left" . equals ( place ) ) { sb . append ( oldstr ) ; } return sb . tostring ( ) ; }
tr	6	public vector < vector < object >> getfoldercontentstable ( ) { vector < vector < object >> tabledata = new vector < > ( ) ; list < fileinfo > files = getfoldercontents ( ) ; logger . debug ( "found " + files . size ( ) + " entries for " + path . tostring ( ) ) ; for ( fileinfo file : files ) { vector < object > row = null ; if ( file . folder ) { row = new vector < > ( ) ; if ( fileop . convertpath ( path . resolve ( file . filename ) ) . tofile ( ) . exists ( ) ) { row . add ( new imageicon ( "res/folder.png" ) ) ; } else { row . add ( new imageicon ( "res/folder_deleted.png" ) ) ; } row . add ( file . filename ) ; row . add ( guiutility . humanreadablebytes ( file . filesize , false ) ) ; row . add ( guiutility . formatdate ( file . createddate ) ) ; row . add ( guiutility . formatdate ( file . lastaccesseddate ) ) ; row . add ( guiutility . formatdate ( file . lastmodifieddate ) ) ; row . add ( integer . tostring ( file . numberofrevisions ) ) ; row . add ( guiutility . humanreadablebytes ( file . revisionsizes , false ) ) ; tabledata . add ( row ) ; } } for ( fileinfo file : files ) { vector < object > row = null ; if ( ! file . folder ) { row = new vector < > ( ) ; if ( fileop . convertpath ( path . resolve ( file . filename ) ) . tofile ( ) . exists ( ) ) { row . add ( new imageicon ( "res/file.png" ) ) ; } else { row . add ( new imageicon ( "res/file_deleted.png" ) ) ; } row . add ( file . filename ) ; row . add ( guiutility . humanreadablebytes ( file . filesize , false ) ) ; row . add ( guiutility . formatdate ( file . createddate ) ) ; row . add ( guiutility . formatdate ( file . lastaccesseddate ) ) ; row . add ( guiutility . formatdate ( file . lastmodifieddate ) ) ; row . add ( integer . tostring ( file . numberofrevisions ) ) ; row . add ( guiutility . humanreadablebytes ( file . revisionsizes , false ) ) ; tabledata . add ( row ) ; } } return tabledata ; }
tr	9	private static void begin ( ) { scanner sc = new scanner ( system . in ) ; while ( sc . hasnextline ( ) ) { stringtokenizer st = new stringtokenizer ( sc . nextline ( ) ) ; int nbrints = integer . parseint ( st . nexttoken ( ) ) ; if ( nbrints <= 0 ) { system . out . println ( "not jolly" ) ; continue ; } else if ( nbrints == 1 ) { system . out . println ( "jolly" ) ; continue ; } boolean [ ] data = new boolean [ nbrints - 1 ] ; int prev = integer . parseint ( st . nexttoken ( ) ) ; while ( st . hasmoretokens ( ) ) { int curr = integer . parseint ( st . nexttoken ( ) ) ; int absdiff = math . abs ( prev - curr ) ; if ( absdiff > 0 && absdiff <= nbrints - 1 ) { data [ absdiff - 1 ] = true ; } prev = curr ; } boolean isjolly = true ; for ( boolean b : data ) { if ( ! b ) { isjolly = false ; break ; } } if ( isjolly ) { system . out . println ( "jolly" ) ; } else { system . out . println ( "not jolly" ) ; } } }
tr	2	public void initnew ( ) { if ( adatamap == null ) adatamap = new hashmap < asection , adata > ( ) ; else adatamap . clear ( ) ; try { this . replace ( 0 , getlength ( ) , "" , defaultstyle ) ; } catch ( badlocationexception e ) { system . out . println ( "error in adocument.initnew() :\n" ) ; e . printstacktrace ( ) ; } putproperty ( ( object ) titleproperty , ( object ) default_title ) ; putproperty ( ( object ) expertproperty , ( object ) "" ) ; putproperty ( ( object ) clientproperty , ( object ) "" ) ; date date = new date ( ) ; putproperty ( ( object ) dateproperty , ( object ) date . tolocalestring ( ) ) ; putproperty ( ( object ) commentproperty , "" ) ; setcharacterattributes ( 0 , 1 , defaultstyle , true ) ; fireadocumentchanged ( ) ; analyst . initundomanager ( ) ; }
tr	5	@ override public void mousepressed ( mouseevent me ) { int w = gridrenderer . getwidth ( ) / gridcolumns ; int col = me . getx ( ) / w ; int h = gridrenderer . getheight ( ) / gridrows ; int row = me . gety ( ) / h ; int value = grid [ col ] [ row ] ; if ( me . getbutton ( ) == mouseevent . button1 ) { if ( tilesremaining > 0 ) { value ++ ; tilesremaining -- ; } if ( tilesremaining == 0 ) { saveasbutton . setenabled ( true ) ; } } else if ( me . getbutton ( ) == mouseevent . button3 ) { if ( value > 0 ) { value -- ; tilesremaining ++ ; saveasbutton . setenabled ( false ) ; } } grid [ col ] [ row ] = value ; updatetilesremaininglabel ( ) ; gridrenderer . repaint ( ) ; }
tr	6	public integer checkfields ( ) { if ( buttongroup . getselection ( ) == null ) { return null ; } else { final enumeration < abstractbutton > elements = buttongroup . getelements ( ) ; integer num = null ; while ( elements . hasmoreelements ( ) ) { final jradiobutton button = ( jradiobutton ) elements . nextelement ( ) ; if ( button != null ) { if ( button . isselected ( ) ) { num = integer . parseint ( button . gettext ( ) . substring ( button . gettext ( ) . lastindexof ( # ) + 1 ) ) ; } } } if ( num != null ) { if ( checkfields ( num ) ) { return num ; } else { joptionpane . showmessagedialog ( null , "***error***: incorrect search options" ) ; } } } return null ; }
tr	2	private void assigncontent ( ) throws saxexception { try { int lastobject = buildobjects . size ( ) - 1 ; if ( lastobject >= 0 ) { object obj = buildobjects . get ( lastobject ) ; this . setattribute ( obj , this . settername , content . tostring ( ) ) ; } else { logger . trace ( "no objects in build queue." ) ; } } catch ( fogbugzexception e ) { logger . trace ( "throwing exception upwards." , e ) ; throw new saxexception ( e ) ; } content . delete ( 0 , content . length ( ) ) ; content . setlength ( 0 ) ; }
tr	4	public void run ( ) { useful = true ; uiapplication . getuiapplication ( ) . invokelater ( new runnable ( ) { public void run ( ) { uiapplication . getuiapplication ( ) . pushscreen ( popup ) ; } } ) ; int iterations = 0 ; while ( useful ) { try { thread . sleep ( timeout ) ; } catch ( exception e ) { } if ( ++ iterations > maximum ) iterations = 1 ; gaugefield . setvalue ( iterations ) ; } if ( popup . isdisplayed ( ) ) { uiapplication . getuiapplication ( ) . invokelater ( new runnable ( ) { public void run ( ) { uiapplication . getuiapplication ( ) . popscreen ( popup ) ; } } ) ; } }
tr	9	public shorturl getnext ( ) throws invalidshorturlexception , shorturloverflow { string currentstring = m_shorturlstring ; string finalstring = null ; int index = max_number_of_digits - 1 ; do { char currentchar = currentstring . charat ( index ) ; char incrementedalphanumber =  ; int currentnumber = ( int ) currentchar ; if ( ( ( currentnumber >= ( int ) 0 && currentnumber < ( int ) 9 ) ) || ( currentnumber >= ( int ) a && currentnumber < ( int ) z ) ) { currentnumber = currentnumber + 1 ; incrementedalphanumber = ( char ) currentnumber ; } else if ( currentnumber == ( int ) 9 ) { incrementedalphanumber = a ; } else if ( currentnumber == ( int ) z ) { stringbuilder s = new stringbuilder ( currentstring ) ; s . setcharat ( index , 0 ) ; currentstring = s . tostring ( ) ; index = index - 1 ; } if (  != incrementedalphanumber ) { stringbuilder string = new stringbuilder ( ) ; string . append ( currentstring . substring ( 0 , index ) ) ; string . append ( incrementedalphanumber ) ; string . append ( currentstring . substring ( index + 1 ) ) ; finalstring = string . tostring ( ) ; } if ( index < 0 ) { throw new shorturloverflow ( "unable to generate next url due to overflow." ) ; } } while ( finalstring == null ) ; shorturl url = new shorturl ( finalstring ) ; return url ; }
tr	6	public synchronized void doranking ( ) { calculate_tf_idf_q ( ) ; query q ; for ( string term : queryterms . keyset ( ) ) { term = term . trim ( ) ; q = queryterms . get ( term ) ; q . setpostings ( getpostingsfor ( term ) ) ; if ( q . getpostings ( ) == null ) { system . out . println ( "sry. no postings found" ) ; continue ; } for ( posting p : q . getpostings ( ) . getpostings ( ) ) { float value = ( float ) ( q . gettf_idf ( ) * calculate_tf_idf_d ( p , q . getpostings ( ) . getoverallfrequency ( ) ) ) ; score s = new score ( ) ; s . setscore ( value ) ; s . setid ( p . getdocid ( ) ) ; if ( ! scores . containskey ( p . getdocid ( ) ) ) { scores . put ( p . getdocid ( ) , s ) ; } else { score sc = scores . get ( p . getdocid ( ) ) ; float score = sc . getscore ( ) ; score += value ; sc . setscore ( score ) ; scores . put ( p . getdocid ( ) , sc ) ; } } } float newscore , lengthv ; score s ; for ( string id : scores . keyset ( ) ) { s = scores . get ( id ) ; try { newscore = s . getscore ( ) / length . get ( id ) . floatvalue ( ) ; s . setscore ( newscore ) ; scores . put ( id , s ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } } }
tr	9	public static bufferedimage getimage ( string url , string refer , eventcallback callback ) { bufferedimage image = null ; httpurlconnection conn = null ; inputstream is = null ; try { url serverurl = new url ( url ) ; conn = ( httpurlconnection ) serverurl . openconnection ( ) ; conn . setrequestmethod ( "get" ) ; if ( refer != null ) { conn . addrequestproperty ( "referer" , refer ) ; } else { conn . addrequestproperty ( "referer" , url_refer_q ) ; } conn . addrequestproperty ( "cookie" , getcookie ( ) ) ; conn . addrequestproperty ( "accept-charset" , "utf-8;" ) ; conn . addrequestproperty ( "accept" , "text/html application/xhtml+xml application/xml;q=0.9 image/webp */*;q=0.8" ) ; conn . addrequestproperty ( "connection" , "keep-alive" ) ; conn . addrequestproperty ( "user-agent" , "mozilla/5.0 (macintosh; intel mac os x 10_10_0) applewebkit/537.36 (khtml  like gecko) chrome/36.0.1985.125 safari/537.36" ) ; conn . connect ( ) ; if ( conn . getheaderfields ( ) . get ( "set-cookie" ) != null ) { for ( string s : conn . getheaderfields ( ) . get ( "set-cookie" ) ) { addcookie ( new botcookie ( s ) ) ; } } is = conn . getinputstream ( ) ; image = imageio . read ( is ) ; } catch ( exception e ) { if ( callback != null ) { callback . exec ( false ) ; } } finally { if ( is != null ) { try { is . close ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } finally { is = null ; } } } string verifystring = httphelper . getcookie ( "verifysession" ) ; if ( verifystring != null ) { bot . getinstance ( ) . setverifysession ( verifystring ) ; httphelper . addcookie ( new botcookie ( "ptvfsession" , verifystring ) ) ; } if ( callback != null ) { callback . exec ( true ) ; } return image ; }
tr	1	public static privatekey readprivatekeyfromder ( string filename ) { try { inputstream fl = fullstream ( filename ) ; byte [ ] key = new byte [ fl . available ( ) ] ; keyfactory kf = keyfactory . getinstance ( "rsa" ) ; fl . read ( key , 0 , fl . available ( ) ) ; fl . close ( ) ; pkcs8encodedkeyspec keysp = new pkcs8encodedkeyspec ( key ) ; privatekey privk = kf . generateprivate ( keysp ) ; return privk ; } catch ( exception e ) { e . printstacktrace ( ) ; return null ; } }
tr	7	public static boolean login ( string username , string password , jframe frame ) { try { system . out . println ( "checking username and password with my boss..." ) ; if ( username . equals ( "" ) || username . contains ( " " ) ) { joptionpane . showmessagedialog ( frame , "the username is invalid  please try an other one." , "invalid username" , joptionpane . error_message ) ; return false ; } if ( password . equals ( "" ) || password . contains ( " " ) ) { joptionpane . showmessagedialog ( frame , "the password is invalid  please try an other one." , "invalid password" , joptionpane . error_message ) ; return false ; } if ( ! getreturnstring ( "req=existsplayer&name=" + username ) ) { joptionpane . showmessagedialog ( frame , "the player does not exits." + "please try an other username." , "player does not exist" , joptionpane . error_message ) ; return false ; } if ( ! getreturnstring ( "req=login&name=" + username + "&pass=" + password ) ) { joptionpane . showmessagedialog ( frame , "the combination of username and passowrd is incorrect." + system . lineseparator ( ) + "please try again.'" + system . lineseparator ( ) + "if you have forgotten your password  visit sinius15.com." , "invalid login" , joptionpane . error_message ) ; return false ; } } catch ( ioexception e ) { e . printstacktrace ( ) ; joptionpane . showmessagedialog ( frame , "there seems to be a problem with the connection to the server" + system . lineseparator ( ) + "you can start the game in offline mode if you still want to play." + system . lineseparator ( ) + "we are verry sorry for the inconvenience caused." , "problem" , joptionpane . error_message ) ; return false ; } return true ; }
tr	3	public void backpropagate ( double [ ] target , double learningspeed ) { double [ ] oerror = calculateerror ( getoutput ( ) , target , learningspeed ) ; for ( double n : oerror ) if ( double . isnan ( n ) ) throw new runtimeexception ( "calculateerror resulted in nan" ) ; for ( int l = layers . size ( ) - 2 ; l >= 0 ; -- l ) { double [ ] ierror = backpropagatelayer ( layers . get ( l ) , layers . get ( l + 1 ) , weights . get ( l ) , oerror , learningspeed ) ; updatebias ( weights . get ( l ) , oerror ) ; oerror = ierror ; } }
tr	5	@ override public void doinbackground ( ) { int slashes = this . address . indexof ( / ) ; int dots = this . address . indexof ( . ) ; if ( ( dots >= 1 ) && ( slashes > 0 ) && ( slashes < this . address . length ( ) - 1 ) ) { try { urlconnection connection = new url ( "http://" + this . address ) . openconnection ( ) ; int totalsize = connection . getcontentlength ( ) ; bufferedinputstream input = new bufferedinputstream ( connection . getinputstream ( ) ) ; fileoutputstream output = new fileoutputstream ( this . outputfile ) ; int read ; double totalread = 0 ; while ( ( read = input . read ( ) ) != - 1 ) { output . write ( read ) ; ++ totalread ; this . setprogress ( ( int ) ( 100.0 / totalsize * totalread ) ) ; } input . close ( ) ; output . close ( ) ; string version = this . address . substring ( this . address . indexof ( _ ) + 1 , this . address . lastindexof ( ".jar" ) ) . replace ( _ , . ) . trim ( ) ; this . setcurrentversion ( version ) ; } catch ( exception e ) { new spopup ( new spopupdata ( e ) ) ; } this . updateframe . closeframe ( ) ; } else { this . errorpopup = new spopup ( new spopupdata ( new sexception ( "invalid address" ) ) ) ; this . errorpopup . injectactionlistener ( this ) ; } return null ; }
tr	1	private static void createlist ( string tabname , final vector < chart > charts , tabfolder tabfolder , final stacklayout layout , final composite composite ) { final list list = new list ( tabfolder , swt . h_scroll | swt . v_scroll ) ; tabitem basictabitem = new tabitem ( tabfolder , swt . none ) ; basictabitem . settext ( tabname ) ; basictabitem . setcontrol ( list ) ; for ( chart chart : charts ) { list . add ( chart . gettitle ( ) . gettext ( ) ) ; } list . addselectionlistener ( new selectionadapter ( ) { @ override public void widgetselected ( selectionevent event ) { chart chart = charts . get ( list . getselectionindex ( ) ) ; chart . getaxisset ( ) . adjustrange ( ) ; layout . topcontrol = chart ; composite . layout ( ) ; } } ) ; }
tr	5	private linkedlist < string > extractkeywords ( string filename ) { linkedlist < string > keywords = new linkedlist < string > ( ) ; int posofdot = filename . lastindexof ( . ) ; if ( posofdot != - 1 ) { keywords . add ( filename . substring ( posofdot ) ) ; filename = filename . substring ( 0 , posofdot ) ; } filename = filename . replaceall ( "[0-9]+" , " " ) . trim ( ) ; string [ ] splitcamelanddelim = filename . split ( "((?<!(^|[a-z]))(?=[a-z])|(?<!^)(?=[a-z][a-z])|[ |.|_|\\-|\\(|\\)])" ) ; keywords . addall ( arrays . aslist ( splitcamelanddelim ) ) ; for ( iterator < string > iter = keywords . iterator ( ) ; iter . hasnext ( ) ; ) { string item = iter . next ( ) . trim ( ) ; if ( item . length ( ) < 4 && ! ( item . length ( ) == 3 && item . equals ( item . touppercase ( ) ) ) ) iter . remove ( ) ; } return keywords ; }
tr	2	@ override public void newentry ( sourcetextentry active_entry ) { if ( current_file_node != null && active_entry != null ) { last_edited_text = core . geteditor ( ) . getcurrenttranslation ( ) ; caretupdates_to_ignore = 1 ; sessionlog . getmenu ( ) . setpausetimestamp ( 0 ) ; sessionlog . getmenu ( ) . getpausetiming ( ) . setselected ( false ) ; element element = newelement ( "segment" , true ) ; element . setattribute ( "number" , integer . tostring ( core . geteditor ( ) . getcurrententry ( ) . entrynum ( ) ) ) ; element source_element = newelement ( "source" , false ) ; source_element . appendchild ( log_document . createtextnode ( core . geteditor ( ) . getcurrententry ( ) . getsrctext ( ) ) ) ; element . appendchild ( source_element ) ; element target_element = newelement ( "initialtarget" , false ) ; target_element . appendchild ( log_document . createtextnode ( core . geteditor ( ) . getcurrenttranslation ( ) ) ) ; element . appendchild ( target_element ) ; current_entry_node = element ; current_file_node . appendchild ( current_entry_node ) ; current_editions_node = newelement ( "events" , false ) ; chosen_entry_time = system . nanotime ( ) ; current_segment_number = core . geteditor ( ) . getcurrententry ( ) . entrynum ( ) ; } }
tr	1	public void createannouncement ( ) { usersession usersession = ( usersession ) facescontext . getcurrentinstance ( ) . getexternalcontext ( ) . getsessionmap ( ) . get ( "usersession" ) ; user = usersession . getuser ( ) ; userid = integer . parseint ( user . getuid ( ) ) ; dateposted = new date ( ) ; if ( courseid == invalid_value ) { system . out . println ( "invalid course for announcement" ) ; return ; } courseusers cusers = new courseusers ( ) ; cusers . setcourseuid ( courseid ) ; courses courses = new courses ( ) ; courses . setcourseid ( courseid ) ; announcements announcement = new announcements ( ) ; announcement . setdescription ( description ) ; announcement . settitle ( announcementtitle ) ; announcement . setdateposted ( dateposted ) ; announcement . setcreator ( cusers ) ; announcement . setcourse ( courses ) ; announcementsdao anndao = new announcementsdao ( ) ; anndao . create ( announcement ) ; }
tr	7	private void updateplayerlist ( buffer stream , int count ) { while ( stream . bitposition + 10 < count * 8 ) { int pid = stream . readbits ( 11 ) ; if ( pid == 2047 ) break ; if ( players [ pid ] == null ) { players [ pid ] = new player ( ) ; if ( playerappearancedata [ pid ] != null ) players [ pid ] . updateplayerappearance ( playerappearancedata [ pid ] ) ; } localplayers [ localplayercount ++ ] = pid ; player player = players [ pid ] ; player . lastupdatetick = tick ; int observed = stream . readbits ( 1 ) ; if ( observed == 1 ) playersobserved [ playersobservedcount ++ ] = pid ; int teleported = stream . readbits ( 1 ) ; int x = stream . readbits ( 5 ) ; if ( x > 15 ) x -= 32 ; int y = stream . readbits ( 5 ) ; if ( y > 15 ) y -= 32 ; player . setpos ( localplayer . waypointx [ 0 ] + y , localplayer . waypointy [ 0 ] + x , teleported == 1 ) ; } stream . finishbitaccess ( ) ; }
tr	8	public vector < door > nearbydoors ( game game ) { vector < door > doors = new vector < door > ( ) ; for ( tile tile : game . getmap ( ) . gettiles ( ) ) { if ( ! ( tile instanceof door ) ) continue ; door door = ( door ) tile ; if ( door . getstate ( ) == door . open ) continue ; rectangle2d door_rect = door . getarea ( ) ; double left = door_rect . getx ( ) ; double right = left + door_rect . getwidth ( ) ; double top = door_rect . gety ( ) ; double bottom = top + door_rect . getheight ( ) ; double x = flocation . getx ( ) ; double y = flocation . gety ( ) ; if ( x < left ) x = left ; if ( x > right ) x = right ; if ( y < top ) y = top ; if ( y > bottom ) y = bottom ; point2d door_point = new point2d . double ( x , y ) ; double distance = flocation . distance ( door_point ) ; distance -= getsize ( ) ; if ( distance <= getreach ( ) ) doors . add ( door ) ; } return doors ; }
tr	5	public static pair < integer , integer > linearcongruence ( int a , int b , final int n ) { positivecheck ( n ) ; a = normalizeintmodulo ( a , n ) ; b = normalizeintmodulo ( b , n ) ; if ( ( ( a == 0 ) && ( b == 0 ) ) || ( n == 1 ) ) return new pair < > ( 0 , 1 ) ; final int numberofsolutions = gcd ( a , n ) ; if ( b % numberofsolutions != 0 ) return new pair < > ( ) ; int bezoutcoefficienta ; if ( a > n ) bezoutcoefficienta = bezout ( a , n ) . get ( 1 ) ; else bezoutcoefficienta = bezout ( n , a ) . get ( 2 ) ; final int shiftedmodulus = n / numberofsolutions ; int x = ( bezoutcoefficienta * b ) / numberofsolutions ; x = normalizeintmodulo ( x , shiftedmodulus ) ; return new pair < > ( x , shiftedmodulus ) ; }
tr	5	public void plotelements ( view3d view ) { for ( int pass = 0 ; pass < 2 ; pass ++ ) { darray list = ( pass == 0 ) ? vertices : elements ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { renderable e = ( renderable ) ( list . get ( i ) ) ; if ( e . deleted ( ) || ! e . visible ( ) ) continue ; e . transform ( view , viewvert , panelvert ) ; } } }
tr	8	public void setactivepanel ( final paneltype type ) { if ( this . frame != null ) { this . frame . dispose ( ) ; } switch ( type ) { case start : this . frame = new plainpanel ( this . sfb , swt . fill , compositebrick . default ) ; break ; case clubs : this . frame = new clubpanel ( this . sfb , swt . fill , compositebrick . default ) ; break ; case gym : this . frame = new gympanel ( this . sfb , swt . fill , compositebrick . default ) ; break ; case spieltag : this . frame = new gamepanel ( this . sfb , swt . fill , compositebrick . default ) ; break ; case spieltag_dir : this . frame = new allgamespanel ( this . sfb , swt . fill , compositebrick . default ) ; break ; case teams : this . frame = new teampanel ( this . sfb , swt . fill , compositebrick . default ) ; break ; case ranking : this . frame = new rankingpanel ( this . sfb , swt . fill , compositebrick . default ) ; break ; } this . sfb . setweights ( new int [ ] { 30 , 70 } ) ; }
tr	1	@ override public dataunit read ( protocol p , readablebytechannel channel ) throws ioexception { readablebytechannel currentchannel = channel ; dataunit dataunit = headerprocessor . read ( p , currentchannel ) ; int totallength = protocolutil . gettotallength ( dataunit , p ) ; if ( totallength != - 1 ) { int toread = totallength - protocolutil . getheaderbytes ( p ) ; byte [ ] bytes = ioutil . readbytes ( toread , currentchannel ) ; currentchannel = channels . newchannel ( new bytearrayinputstream ( bytes ) ) ; } dataunit = unitprocessor . fromstream ( dataunit , p , currentchannel ) ; currentchannel = channel ; return dataunit ; }
tr	4	@ test public void testtokenpayment ( ) { gateway beanstream = new gateway ( "v1" , 300200578 , "4bad82d9197b4cc4b70a221911ee9f70" ) ; httpsconnector connector = new httpsconnector ( 300200578 , "4bad82d9197b4cc4b70a221911ee9f70" ) ; legatotokenrequest legatotokenrequest = new legatotokenrequest ( ) ; legatotokenrequest . number = "5100000010001004" ; legatotokenrequest . expirymonth = 12 ; legatotokenrequest . expiryyear = 18 ; legatotokenrequest . cvd = "123" ; string url = "https://www.beanstream.com/scripts/tokenization/tokens" ; string output = "" ; try { output = connector . processtransaction ( httpmethod . post , url , legatotokenrequest ) ; } catch ( beanstreamapiexception ex ) { logger . getlogger ( sampletransactions . class . getname ( ) ) . log ( level . severe , null , ex ) ; assert . fail ( ex . getmessage ( ) ) ; } gson gson = new gson ( ) ; legatotokenresponse tokenresponse = gson . fromjson ( output , legatotokenresponse . class ) ; system . out . println ( "token: " + output ) ; tokenpaymentrequest tokenreq = new tokenpaymentrequest ( ) ; tokenreq . setamount ( 100.00 ) ; tokenreq . setordernumber ( getrandomorderid ( "token" ) ) ; tokenreq . gettoken ( ) . setname ( "john doe" ) . setcode ( tokenresponse . gettoken ( ) ) ; try { paymentresponse response = beanstream . payments ( ) . makepayment ( tokenreq ) ; system . out . println ( "token payment approved? " + response . isapproved ( ) ) ; } catch ( beanstreamapiexception ex ) { logger . getlogger ( this . getclass ( ) . getname ( ) ) . log ( level . severe , "an error occurred" , ex ) ; assert . fail ( ex . getmessage ( ) ) ; } try { output = connector . processtransaction ( httpmethod . post , url , legatotokenrequest ) ; } catch ( beanstreamapiexception ex ) { logger . getlogger ( sampletransactions . class . getname ( ) ) . log ( level . severe , null , ex ) ; assert . fail ( ex . getmessage ( ) ) ; } tokenresponse = gson . fromjson ( output , legatotokenresponse . class ) ; system . out . println ( "token pre-auth: " + tokenresponse . gettoken ( ) ) ; tokenpaymentrequest req = new tokenpaymentrequest ( ) ; req . setamount ( 80.00 ) ; req . setordernumber ( getrandomorderid ( "token" ) ) ; req . gettoken ( ) . setname ( "john doe" ) . setcode ( tokenresponse . gettoken ( ) ) ; try { paymentresponse response = beanstream . payments ( ) . preauth ( req ) ; system . out . println ( "token payment approved? " + response . isapproved ( ) ) ; response = beanstream . payments ( ) . preauthcompletion ( response . id , 55.30 ) ; assert . asserttrue ( response . isapproved ( ) ) ; assert . assertequals ( "pac" , response . type ) ; } catch ( beanstreamapiexception ex ) { logger . getlogger ( this . getclass ( ) . getname ( ) ) . log ( level . severe , "an error occurred" , ex ) ; assert . fail ( ex . getmessage ( ) ) ; } }
tr	4	private void init ( ) { int n = mapinfo . getmapsize ( ) ; visited = new boolean [ n ] [ n ] ; for ( int column = 0 ; column < n ; column ++ ) visited [ 0 ] [ column ] = visited [ n - 1 ] [ column ] = true ; for ( int row = 0 ; row < n ; row ++ ) visited [ row ] [ 0 ] = visited [ row ] [ n - 1 ] = true ; for ( int column = 0 ; column < n ; column ++ ) for ( int row = 0 ; row < n ; row ++ ) mapinfo . setcell ( row , column , new cell ( true , true , true , true ) ) ; }
tr	0	public tacticbutton ( string stext , imageicon sicon ) { super ( null ) ; addmouselistener ( mouselistener ) ; strategylabel = new jlabel ( stext . replace ( _ ,   ) , sicon , jlabel . center ) ; strategylabel . setforeground ( color . white ) ; strategylabel . setbounds ( 0 , 0 , 120 , 41 ) ; strategylabel . sethorizontalalignment ( jlabel . center ) ; strategylabel . setverticalalignment ( jlabel . center ) ; add ( strategylabel ) ; dimension size = new dimension ( 145 , 49 ) ; setpreferredsize ( size ) ; setmaximumsize ( size ) ; }
tr	8	public string deleteextraspace ( string str ) { if ( str == null ) { return null ; } if ( str . length ( ) == 0 || str . equals ( " " ) ) { return new string ( ) ; } char [ ] oldstr = str . tochararray ( ) ; int len = str . length ( ) ; char [ ] tmpstr = new char [ len ] ; boolean keepspace = false ; int j = 0 ; for ( int i = 0 ; i < len ; i ++ ) { char tmpchar = oldstr [ i ] ; if ( oldstr [ i ] !=   ) { tmpstr [ j ++ ] = tmpchar ; keepspace = true ; } else if ( keepspace ) { tmpstr [ j ++ ] = tmpchar ; keepspace = false ; } } int newlen = j ; if ( tmpstr [ j - 1 ] ==   ) { newlen -- ; } char [ ] newstr = new char [ newlen ] ; for ( int i = 0 ; i < newlen ; i ++ ) { newstr [ i ] = tmpstr [ i ] ; } return new string ( newstr ) ; }
tr	4	public static string readfile ( string filepath ) throws filenotexistexception { file file = new file ( filepath ) ; stringbuilder builder = new stringbuilder ( ) ; if ( ! file . exists ( ) ) { throw new filenotexistexception ( filepath ) ; } try { bufferedreader buffer = new bufferedreader ( new filereader ( file ) ) ; string tmp = buffer . readline ( ) ; while ( tmp != null ) { builder . append ( tmp ) ; tmp = buffer . readline ( ) ; if ( tmp != null ) builder . append (  ) ; } } catch ( ioexception e ) { e . printstacktrace ( ) ; } return builder . tostring ( ) ; }
tr	8	public static string [ ] splitbyletter2 ( charsequence text ) { list . clear ( ) ; int pos = 0 ; int len = text . length ( ) ; boolean first = true ; for ( int i = 0 ; i < len ; i ++ ) { char c = text . charat ( i ) ; if ( c > 58 ) { if ( first ) { first = false ; buffer [ pos ++ ] = c ; continue ; } list . add ( new string ( buffer , 0 , pos ) ) ; pos = 0 ; buffer [ pos ++ ] = c ; } else if ( c == 32 || c == 10 || c == 47 || c == 13 || c == 9 ) { } else { buffer [ pos ++ ] = c ; } } list . add ( new string ( buffer , 0 , pos ) ) ; return list . toarray ( new string [ list . size ( ) ] ) ; }
tr	7	@ override public void setfailstate ( int failstate ) { if ( this . failstate == fallible . dead && failstate != fallible . dead ) throw new illegalstateexception ( "cannot change fail state: node is already dead" ) ; switch ( failstate ) { case ok : this . failstate = fallible . ok ; break ; case dead : this . index = - 1 ; this . failstate = fallible . dead ; for ( int i = 0 ; i < this . protocol . length ; ++ i ) if ( this . protocol [ i ] instanceof cleanable ) { ( ( cleanable ) this . protocol [ i ] ) . onkill ( ) ; } break ; case down : this . failstate = fallible . down ; break ; default : throw new illegalargumentexception ( "failstate=" + failstate ) ; } }
tr	3	public static polynomial createfrombytes ( byte [ ] bytes ) { treeset < biginteger > dgrs = createdegreescollection ( ) ; int degree = 0 ; for ( int i = bytes . length - 1 ; i >= 0 ; i -- ) { for ( int j = 0 ; j < 8 ; j ++ ) { if ( ( ( ( bytes [ i ] >> j ) & 1 ) == 1 ) ) { dgrs . add ( biginteger . valueof ( degree ) ) ; } degree ++ ; } } return new polynomial ( dgrs ) ; }
tr	8	public boolean hasadjacentemptytile ( javacell cell ) { int x = cell . getx ( ) ; int y = cell . gety ( ) ; if ( x + 1 == 13 ) { if ( map [ 13 ] [ y ] . getcelltype ( ) . equals ( "blank" ) ) return true ; } if ( x - 1 == 0 ) { if ( map [ 0 ] [ y ] . getcelltype ( ) . equals ( "blank" ) ) return true ; } if ( y + 1 == 13 ) { if ( map [ x ] [ 13 ] . getcelltype ( ) . equals ( "blank" ) ) return true ; } if ( y - 1 == 0 ) { if ( map [ x ] [ 0 ] . getcelltype ( ) . equals ( "blank" ) ) return true ; } return false ; }
tr	3	@ override public void mousereleased ( mouseevent evt ) { if ( evt . getclickcount ( ) == 2 ) { tabledoubleclick ( "employee" ) ; } if ( _view . table_employee . isrowselected ( _view . table_employee . getselectedrow ( ) ) ) { if ( evt . getbutton ( ) == mouseevent . button3 ) { integer integer = ( integer ) _view . table_employee . getvalueat ( _view . table_employee . getselectedrow ( ) , 0 ) ; int rownumber = _view . table_employee . rowatpoint ( evt . getpoint ( ) ) ; _view . table_employee . getselectionmodel ( ) . setselectioninterval ( rownumber , rownumber ) ; showpopup ( evt , integer , "employee" ) ; } } }
tr	7	public void insertandindexdocument ( document doc ) throws ioexception , classnotfoundexception { node currentnode = null ; node previousnode = null ; int sentencenumber = 0 ; int wordnumber = 0 ; transaction tx = graphdb . begintx ( ) ; try { arraylist < sentence > sentences = doc . getsentences ( ) ; for ( sentence sentence : sentences ) { wordnumber = 0 ; arraylist < word > words = sentence . getwords ( ) ; for ( word word : words ) { currentnode = findnodebyproperty ( neo4jnode . word_property , word . getcontent ( ) ) ; if ( currentnode == null ) { neo4jnode newnode = new neo4jnode ( word . getcontent ( ) ) ; arraylist < string > documententity = new arraylist < string > ( ) ; documententity . add ( "1" ) ; documententity . add ( string . valueof ( sentencenumber ) + "_" + string . valueof ( wordnumber ) ) ; newnode . addtodocumenttable ( doc . getid ( ) , documententity ) ; insertandindexnode ( newnode ) ; currentnode = findnodebyproperty ( neo4jnode . word_property , word . getcontent ( ) ) ; } else { neo4jnode existingnode = converttoneo4jnode ( currentnode ) ; if ( existingnode . isindocumenttable ( doc . getid ( ) ) ) { arraylist < string > documententity = existingnode . getdocumententity ( doc . getid ( ) ) ; int tf = integer . parseint ( documententity . get ( 0 ) ) + 1 ; documententity . set ( 0 , string . valueof ( tf ) ) ; documententity . add ( string . valueof ( sentencenumber ) + "_" + string . valueof ( wordnumber ) ) ; existingnode . addtodocumenttable ( doc . getid ( ) , documententity ) ; } else { arraylist < string > documententity = new arraylist < string > ( ) ; documententity . add ( "1" ) ; documententity . add ( string . valueof ( sentencenumber ) + "_" + string . valueof ( wordnumber ) ) ; existingnode . addtodocumenttable ( doc . getid ( ) , documententity ) ; } modifyandindexnode ( existingnode , currentnode ) ; currentnode = findnodebyproperty ( neo4jnode . word_property , word . getcontent ( ) ) ; } if ( currentnode != null && previousnode != null && ! doesrelationsexist ( previousnode , currentnode , "document_" + doc . getid ( ) ) ) { createrelationship ( previousnode , currentnode , "document_" + doc . getid ( ) ) ; } previousnode = currentnode ; wordnumber ++ ; } sentencenumber ++ ; } tx . success ( ) ; } finally { tx . finish ( ) ; } }
tr	3	protected void dopost ( httpservletrequest request , httpservletresponse response ) throws servletexception , ioexception { printwriter out = response . getwriter ( ) ; request . setcharacterencoding ( "utf-8" ) ; boolean r = false ; boolean e = false ; response . setcontenttype ( "text/html;charset=utf-8" ) ; search com = new search ( ) ; string id [ ] = request . getparametervalues ( "id" ) ; string doctellid [ ] = request . getparametervalues ( "doctellid" ) ; string docid [ ] = request . getparametervalues ( "docid" ) ; string doctellcontent [ ] = request . getparametervalues ( "doctellcontent" ) ; string excutedate [ ] = request . getparametervalues ( "excutedate" ) ; string excuteid [ ] = request . getparametervalues ( "excuteid" ) ; string doctelltype [ ] = request . getparametervalues ( "doctelltype" ) ; string stopdate [ ] = request . getparametervalues ( "stopdate" ) ; string patientid = request . getparameter ( "patientid" ) ; for ( int i = 0 ; i < doctellid . length ; i ++ ) { r = com . doctellfind ( id [ i ] ) ; if ( r ) { e = com . doctellupdate ( id [ i ] , doctellcontent [ i ] , excutedate [ i ] , excuteid [ i ] , doctelltype [ i ] , stopdate [ i ] ) ; } else { system . out . println ( doctellid [ i ] ) ; e = com . doctellinsert ( id [ i ] , doctellid [ i ] , docid [ i ] , doctellcontent [ i ] , excutedate [ i ] , excuteid [ i ] , doctelltype [ i ] , stopdate [ i ] , patientid ) ; } } if ( e ) { response . sendredirect ( request . getcontextpath ( ) + "/wardmanagement/patientlist.jsp" ) ; } else { out . print ( "\u6ce8\u518c\u5931\u8d25" ) ; return ; } }
tr	5	public boolean move ( direction direction , stringbuffer output ) throws endgameexception { boolean hasmoved = false ; if ( myposition . iscrossable ( direction ) ) { if ( myposition . hascharacter ( direction ) ) { character defender = myposition . getcharacter ( direction ) ; if ( attack ( defender ) ) { this . myposition = myposition . movecharacter ( direction ) ; output . append ( "you attacked and killed " + defender + ". you moved " + direction ) ; hasmoved = true ; } else { if ( isdead ( ) ) throw new endgameexception ( "player has died. game over!" ) ; output . append ( "you attacked: \n" + defender . tostring ( ) + "\n" + this . tostring ( ) ) ; } } else { this . myposition = myposition . movecharacter ( direction ) ; output . append ( "you moved " + direction + "." ) ; hasmoved = true ; } } else { output . append ( checkiflockedexit ( direction ) ) ; } if ( hasmoved ) { notifypositionchanged ( direction . getoppositedirection ( ) ) ; } return hasmoved ; }
tr	0	@ test public void testrenderlong ( ) { long value = long . min_value ; byte [ ] data = null ; data = byteutil . renderlong ( value ) ; asserttrue ( byteutil . retrievelong ( data , 0 ) == long . min_value ) ; value = long . max_value ; data = byteutil . renderlong ( value ) ; asserttrue ( byteutil . retrievelong ( data , 0 ) == long . max_value ) ; value = - 1 ; data = byteutil . renderlong ( value ) ; asserttrue ( byteutil . retrievelong ( data , 0 ) == - 1 ) ; }
tr	0	@ suppresswarnings ( "deprecation" ) public void initglobaladmin ( ) { person person = new person ( ) ; person . setfirstname ( "thomas" ) ; person . setlastname ( "hardy" ) ; person . setgender ( true ) ; person . setphone ( "857-245-1872" ) ; person . setssn ( "781-27-2837" ) ; person . setemailid ( "global@cms.org" ) ; person . setaddress ( "500 bolyston st  boston" ) ; person . setdob ( new date ( 1980 , 11 , 10 ) ) ; persondao . saveorupdate ( person ) ; useraccount ua = new useraccount ( ) ; ua . setusername ( "admin" ) ; ua . setpassword ( hashgenerator . gethashvalue ( "admin" ) ) ; ua . setrole ( role . globaladmin . tostring ( ) ) ; ua . setperson ( person ) ; useraccountdao . saveorupdate ( ua ) ; }
tr	6	latexexporter ( component parent , list < fonthandle > fonts , jfilechooser chooser ) { if ( chooser != null ) { mchooser = chooser ; } else { string path = system . getproperty ( "user.home" ) ; if ( path != null ) { file file = new file ( path , "desktop" ) ; if ( ! file . exists ( ) ) { file = new file ( path ) ; } mchooser = new jfilechooser ( file ) ; } else { mchooser = new jfilechooser ( ) ; } } mfamilylabel = new jlabel ( "name" ) ; mfamilylabel . sethorizontalalignment ( jlabel . right ) ; mfamilyfield = new jtextfield ( "" ) ; mnoticelabel = new jlabel ( "note that latex maps \"\\textbf\"\nto bold_extended  not bold." ) ; add ( mfamilylabel ) ; add ( mfamilyfield ) ; add ( mnoticelabel ) ; mfontstacker = new componentstacker ( ) ; mfontstacker . setstackdirection ( componentstacker . stack_vertical ) ; mfontstacker . setstretch ( true ) ; mfontstacker . setmargins ( 0 , 0 ) ; mfontstacker . setborder ( borderfactory . createtitledborder ( "fonts" ) ) ; mfontstacker . setbackground ( color . white ) ; add ( mfontstacker ) ; int i = 0 ; mfontpanels = new arraylist < fontpanel > ( ) ; for ( fonthandle f : fonts ) { fontpanel p = new fontpanel ( f ) ; p . setsize ( 50 , 75 ) ; if ( i ++ % 2 == 0 ) { p . setbackground ( palette . odd_color ) ; } else { p . setbackground ( palette . even_color ) ; } mfontstacker . add ( p ) ; mfontpanels . add ( p ) ; } while ( parent . getparent ( ) != null ) { parent = parent . getparent ( ) ; } mcancelbutton = new jbutton ( "cancel" ) ; mokbutton = new jbutton ( "ok" ) ; add ( mcancelbutton ) ; add ( mokbutton ) ; mcancelbutton . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent e ) { docancel ( ) ; } } ) ; mokbutton . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent e ) { dookay ( ) ; } } ) ; setlayout ( new layout ( ) ) ; setopaque ( true ) ; mdialog = new jdialog ( ( window ) parent , "configure tex typeface" , modalitytype . application_modal ) ; mdialog . setcontentpane ( this ) ; mdialog . setsize ( 550 , 650 ) ; mdialog . setlocationrelativeto ( null ) ; mdialog . setvisible ( true ) ; }
tr	4	static void createnewpearltree ( panel panel , boolean active ) { final label item = createlabel ( ) ; final flowpanel description = new flowpanel ( ) ; item . settext ( "a new pearltree" ) ; if ( webcontent . onipad ) { description . setstyleprimaryname ( primary_style_newpearltree ) ; panel . add ( description ) ; html newpearltreebox = popupelements . createhtml ( ) ; newpearltreebox . setstyleprimaryname ( popupelements . primary_style_avatarbox ) ; newpearltreebox . addstyledependentname ( popupelements . style_special_padding ) ; newpearltreebox . sethtml ( new_pearltree ) ; description . add ( newpearltreebox ) ; description . add ( item ) ; } else { panel . add ( item ) ; } if ( ! webcontent . onipad ) { item . addstyledependentname ( style_selectable ) ; item . addstyledependentname ( style_bold ) ; item . addstyledependentname ( style_padding ) ; } item . addstyledependentname ( style_selectable ) ; item . addstyledependentname ( style_item ) ; if ( active ) { item . addclickhandler ( new clickhandler ( ) { @ override public void onclick ( clickevent event ) { if ( webcontent . onipad ) { description . addstyledependentname ( style_selected_timer ) ; timer t = new timer ( ) { @ override public void run ( ) { dom . removeelementattribute ( treelistui . panelinside . getelement ( ) , "id" ) ; popupcontrol . changeui ( popupuis . newtree ) ; } } ; t . schedule ( 120 ) ; } else { popupcontrol . changeui ( popupuis . newtree ) ; } } } ) ; } else { item . addstyledependentname ( style_inactive ) ; } }
tr	6	private static void processcase ( int casenum ) { system . out . println ( "field #" + casenum + ":" ) ; mines = new int [ rows ] [ cols ] ; for ( int i = 0 ; i < rows ; i ++ ) { char [ ] line = in . nextline ( ) . tochararray ( ) ; for ( int j = 0 ; j < cols ; j ++ ) { if ( line [ j ] == * ) { mines [ i ] [ j ] = mine ; } } } for ( int i = 0 ; i < rows ; i ++ ) { for ( int j = 0 ; j < cols ; j ++ ) { if ( mines [ i ] [ j ] != mine ) { system . out . print ( calc ( i , j ) ) ; } else { system . out . print ( * ) ; } } system . out . println ( ) ; } }
tr	2	public void prepareforstartingattempt ( ) { arraylist < fieldelement > startingelements = getelements ( "arcanoid.model.ball" ) ; int width = ( int ) startingelements . get ( 0 ) . size ( ) . width ( ) ; int startpos = startingelements . get ( 0 ) . position ( ) . x + width / 2 ; int ypos = startingelements . get ( 0 ) . position ( ) . y ; for ( int i = 1 ; i < startingelements . size ( ) ; i ++ ) { if ( i < 3 ) { startingelements . get ( i ) . setposition ( new point ( startpos - i * 20 - width * i , ypos ) ) ; } else { startingelements . get ( i ) . setposition ( new point ( startpos + ( i - 2 ) * 20 + width * ( i - 2 ) , ypos ) ) ; } } }
tr	2	public void buildexampletexproject ( file dir , string packagename ) throws ioexception { if ( packagename == null ) packagename = mfamilyname ; map < texfontbuilder , string > namemap = dobuildtypefacepackage ( dir , packagename ) ; file texfile = new file ( dir , "example.tex" ) ; printwriter out = new printwriter ( texfile ) ; out . println ( "\\documentclass[12pt]{article}" ) ; out . println ( ) ; out . format ( "\\usepackage{%s}\n" , packagename ) ; out . println ( ) ; out . println ( "\\usepackage{fonttable}" ) ; out . println ( ) ; out . println ( "\\title{gulliver's travels}" ) ; out . println ( "\\author{jonathan swift}" ) ; out . println ( "\\begin{document}" ) ; out . println ( ) ; out . println ( "\\maketitle" ) ; out . println ( ) ; out . println ( "the first request i made  after i had obtained my liberty  was  that i might have license " + "to see mildendo  the metropolis; which the emperor easily granted me  but with a special " + "charge to do no hurt either to the inhabitants or their houses. the people had notice  by " + "proclamation  of my design to visit the town. the wall which encompassed it is two feet and a " + "half high  and at least eleven inches broad  so that a coach and horses may be driven very safely " + "round it; and it is flanked with strong towers at ten feet distance. i stepped over the great " + "western gate  and passed very gently  and sidling  through the two principal streets  only in " + "my short waistcoat  for fear of damaging the roofs and eaves of the houses with the skirts of my " + "coat. i walked with the utmost circumspection  to avoid treading on any stragglers who might remain " + "in the streets  although the orders were very strict  that all people should keep in their houses  at " + "their own peril. the garret windows and tops of houses were so crowded with spectators  that i thought " + "in all my travels i had not seen a more populous place. the city is an exact square  each side of the " + "wall being five hundred feet long. the two great streets  which run across and divide it into four " + "quarters  are five feet wide. the lanes and alleys  which i could not enter  but only view them as " + "i passed  are from twelve to eighteen inches. the town is capable of holding five hundred thousand " + "souls: the houses are from three to five stories: the shops and markets well provided." ) ; out . println ( ) ; out . println ( "\\textbf{the emperor's palace is in the centre} " + "\\textit{of the city where the two great streets meet.}" + " it is " + "enclosed by a wall of two feet high  and twenty feet distance from the buildings. i had " + "his majesty's permission to step over this wall; and  the space being so wide between that " + "and the palace  i could easily view it on every side. the outward court is a square of forty " + "feet  and includes two other courts: in the inmost are the royal apartments  which i was very " + "desirous to see  but found it extremely difficult; for the great gates  from one square into " + "another  were but eighteen inches high  and seven inches wide. now the buildings of the outer " + "court were at least five feet high  and it was impossible for me to stride over them without " + "infinite damage to the pile  though the walls were strongly built of hewn stone  and four inches " + "thick. at the same time the emperor had a great desire that i should see the magnificence of his " + "palace; but this i was not able to do till three days after  which i spent in cutting down with my " + "knife some of the largest trees in the royal park  about a hundred yards distant from the city. " + "of these trees i made two stools  each about three feet high  and strong enough to bear my weight. " + "the people having received notice a second time  i went again through the city to the palace with " + "my two stools in my hands. when i came to the side of the outer court  i stood upon one stool  and " + "took the other in my hand; this i lifted over the roof  and gently set it down on the space between " + "the first and second court  which was eight feet wide. i then stept over the building very " + "conveniently from one stool to the other  and drew up the first after me with a hooked stick. " + "by this contrivance i got into the inmost court; and  lying down upon my side  i applied my " + "face to the windows of the middle stories  which were left open on purpose  and discovered the " + "most splendid apartments that can be imagined. there i saw the empress and the young princes  in " + "their several lodgings  with their chief attendants about them. her imperial majesty was pleased " + "to smile very graciously upon me  and gave me out of the window her hand to kiss." ) ; out . println ( ) ; out . println ( "\\clearpage" ) ; for ( string name : namemap . values ( ) ) { out . format ( "\\fonttable{%s}\n" , name ) ; } out . println ( ) ; out . println ( "\\end{document}" ) ; out . close ( ) ; }
tr	5	public void update ( final world w ) { for ( short x = 0 ; x < sidelength ; x ++ ) { for ( short y = 0 ; y < sidelength ; y ++ ) { short tilex = ( short ) ( x + ( coords . getx ( ) * sidelength ) ) ; short tiley = ( short ) ( y + ( coords . gety ( ) * sidelength ) ) ; final tile t = gettile ( x , y ) ; if ( ( t == tiles . air ) || ( t == null ) ) { new packet03tile ( t , tilex , tiley ) . writedatatoserver ( ) ; } if ( t . doestick ( ) ) { t . update ( w , tilex , tiley ) ; } } } }
tr	2	private void removeneuron ( int num ) { neuron neuron = ( neuron ) ( currentnetwork . getnode ( num ) ) ; currentnetwork . getneurons ( ) . remove ( neuron ) ; for ( int i = 0 ; i < neuron . getinputs ( ) . size ( ) ; i ++ ) { connection connection = neuron . getinputs ( ) . get ( i ) ; connection . getgiveneuron ( ) . getoutputs ( ) . remove ( connection ) ; currentnetwork . getconnections ( ) . remove ( connection ) ; } for ( int i = 0 ; i < neuron . getoutputs ( ) . size ( ) ; i ++ ) { connection connection = neuron . getoutputs ( ) . get ( i ) ; connection . getrecieveneuron ( ) . getinputs ( ) . remove ( connection ) ; currentnetwork . getconnections ( ) . remove ( connection ) ; } system . out . println ( "neuron :: " + num + " :: was removed" ) ; }
tr	9	private boolean isconflict ( list < rectangle > bounds , list < containercomponent > selectedcomponents ) { for ( rectangle r : bounds ) { if ( r . x < 0 ) return true ; if ( r . y < 0 ) return true ; for ( containercomponent c2 : workplacecomponents ) { if ( selectedcomponents != null && ! notin ( c2 , selectedcomponents ) ) continue ; rectangle r2 = c2 . getbounds ( ) ; if ( r2 . intersects ( r ) ) { return true ; } } rectangle truckbounds = truck . getbounds ( ) ; if ( truckbounds . intersects ( r ) && ! truckbounds . contains ( r ) ) { return true ; } } return false ; }
tr	4	@ test public void testnaissancesoldats ( ) { sallesoldat testsoldat = new sallesoldat ( ) ; sallenourrice sn = new sallenourrice ( ) ; evenements . getinstance ( ) . setevenementactif ( constantes . even_deplacement ) ; sn . ajouterfourmi ( 3 ) ; testsoldat . naissancesoldats ( 2 , sn ) ; assertequals ( 1 , testsoldat . getnbcourantfourmi ( ) ) ; assertequals ( 1 , sn . getnbcourantfourmi ( ) ) ; try { testsoldat . naissancesoldats ( 2 , sn ) ; fail ( "exceptionnourrices non levee." ) ; } catch ( exceptionnourrices en ) { } try { testsoldat . naissancesoldats ( 0 , sn ) ; fail ( "illegalargumentexception non levee." ) ; } catch ( illegalargumentexception iae ) { } try { testsoldat . naissancesoldats ( 1 , sn ) ; fail ( "illegalargumentexception non levee." ) ; } catch ( illegalargumentexception iae ) { } try { testsoldat . naissancesoldats ( 5 , sn ) ; fail ( "illegalargumentexception non levee." ) ; } catch ( illegalargumentexception iae ) { } }
tr	3	public static shader createshader ( string name ) { bufferedreader vertex ; try { vertex = new bufferedreader ( new filereader ( new file ( shaderloader . class . getresource ( "/shaders/" + name + ".vert" ) . touri ( ) ) ) ) ; } catch ( exception e ) { return null ; } bufferedreader fragment ; try { fragment = new bufferedreader ( new filereader ( new file ( shaderloader . class . getresource ( "/shaders/" + name + ".vert" ) . touri ( ) ) ) ) ; } catch ( exception e ) { try { vertex . close ( ) ; } catch ( ioexception e2 ) { } return null ; } return createshader ( name , vertex , fragment ) ; }
tr	1	protected void createwebsocketpingserver ( ) { rxhttpserver server = new rxhttpserver ( vertx . createhttpserver ( ) ) ; server . websocket ( ) . subscribe ( new action1 < rxserverwebsocket > ( ) { public void call ( final rxserverwebsocket s ) { system . out . println ( "websocketserver:" + s . path ( ) ) ; s . asobservable ( ) . subscribe ( new action1 < buffer > ( ) { public void call ( buffer b ) { system . out . println ( "websocketserver:received[" + b + "]" ) ; if ( "eof" . equals ( b . tostring ( ) ) ) { s . close ( ) ; } else { s . writetextframe ( b . tostring ( ) ) ; } } } ) ; } } ) ; server . corehttpserver ( ) . listen ( 8090 , "localhost" ) ; }
tr	6	private void handlenames ( message m ) { if ( m . numargs ( ) < 3 ) return ; if ( m . getcode ( ) == messagecode . rpl_endofnames ) { getchannel ( m . getarg ( 2 ) ) . userschanged ( ) ; return ; } if ( m . numargs ( ) < 5 || m . get ( 3 ) . charat ( 0 ) == * ) return ; channel c = getchannel ( m . getarg ( 3 ) ) ; stringtokenizer st = new stringtokenizer ( m . getmessage ( ) , " " ) ; user u ; string nick ; while ( st . hasmoretokens ( ) ) { nick = st . nexttoken ( ) ; channeluser . mode mode = channeluser . mode . getmode ( nick . charat ( 0 ) ) ; if ( mode != channeluser . mode . none ) nick = nick . substring ( 1 ) ; u = getuser ( nick ) ; u . addchannel ( c ) ; c . addusertolist ( u ) ; c . setusermode ( u , mode ) ; } }
tr	3	public arithmeticparser ( string [ ] programsource ) throws parserparsingexception { super ( programsource [ programsource . length - 1 ] ) ; this . context = new evaluationcontext ( ) ; for ( int i = 0 ; i < programsource . length - 1 ; i ++ ) { string [ ] parts = programsource [ i ] . replace ( " " , "" ) . split ( "=" ) ; tree tree = new expressionstreeparser ( parts [ 1 ] ) . getroottree ( ) ; if ( parts [ 0 ] . contains ( "(" ) ) { matcher matcher = function_definition_pattern . matcher ( parts [ 0 ] ) ; if ( ! matcher . find ( ) ) throw new runtimeexception ( "wrong definition" ) ; string functionname = matcher . group ( 1 ) ; string argumentname = matcher . group ( 2 ) ; context . addfunctionvalue ( functionname , argumentname , tree ) ; } else { context . addvarvalue ( parts [ 0 ] , tree ) ; } } }
tr	4	public klas getklas ( long klas_id ) { klas klas = null ; try { preparedstatement klasstatement = manager . preparestatement ( "select * from klassen where id = ?" ) ; klasstatement . setlong ( 1 , klas_id ) ; resultset klasresult = klasstatement . executequery ( ) ; if ( klasresult . next ( ) ) { klas = new klas ( klasresult . getlong ( 1 ) , klasresult . getstring ( 2 ) ) ; preparedstatement leerlingenklas = manager . preparestatement ( "select leerling_id from leerling_klas where klas_id = ?" ) ; leerlingenklas . setlong ( 1 , klas_id ) ; resultset leerlingids = leerlingenklas . executequery ( ) ; while ( leerlingids . next ( ) ) { klas . addstudent ( getuser ( leerlingids . getlong ( 1 ) ) ) ; } for ( vak vak : getvakkenvanklas ( klas_id ) ) { klas . addvak ( vak ) ; } } } catch ( sqlexception e ) { e . printstacktrace ( ) ; } return klas ; }
tr	1	@ suppresswarnings ( "calltothreaddumpstack" ) private void criaxml ( string ip , string caminho ) { try { file db = new file ( "config.xml" ) ; db . createnewfile ( ) ; filewriter filew = new filewriter ( db . getabsolutepath ( ) ) ; try ( bufferedwriter buffw = new bufferedwriter ( filew ) ) { buffw . write ( "<ipservidor>" + ip + "</ipservidor>" ) ; buffw . newline ( ) ; buffw . write ( "<caminhobanco>" + caminho + "</caminhobanco>" ) ; } } catch ( ioexception | headlessexception e ) { e . printstacktrace ( ) ; } }
tr	3	public void oncreate ( ) throws sqlexception { setdefaultcloseoperation ( javax . swing . windowconstants . hide_on_close ) ; if ( level != 1 ) { jpanel1 . setenabled ( false ) ; jbutton2 . setenabled ( false ) ; jbutton3 . setenabled ( false ) ; jbutton4 . setenabled ( false ) ; jbutton6 . setenabled ( false ) ; } double catnumeber = dbutil . loadcategories ( ) . length ; int rows = ( int ) math . ceil ( catnumeber / 5 ) ; jpanel2 . setlayout ( new gridlayout ( rows , 5 , 4 , 4 ) ) ; jpanel3 . setvisible ( false ) ; string array [ ] [ ] = dbutil . loadcategories ( ) ; for ( int i = 0 ; i < catnumeber ; i ++ ) { final jbutton btn = new jbutton ( string . valueof ( array [ i ] [ 1 ] ) ) ; jpanel buttonpane = new jpanel ( ) ; btn . setname ( string . valueof ( array [ i ] [ 0 ] ) ) ; btn . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent ae2 ) { jpanel2 . setvisible ( false ) ; jpanel itempane = new jpanel ( ) ; itempane . setlayout ( new gridlayout ( 5 , 5 , 5 , 5 ) ) ; itempane . setvisible ( true ) ; try { loaditems ( btn . getname ( ) ) ; } catch ( sqlexception ex ) { logger . getlogger ( sales . class . getname ( ) ) . log ( level . severe , null , ex ) ; } } } ) ; buttonpane . add ( btn ) ; jpanel2 . add ( buttonpane ) ; } add ( jpanel2 ) ; pack ( ) ; setvisible ( true ) ; }
tr	8	@ override public boolean equals ( object cidades ) { if ( cidades == null ) { return false ; } if ( getclass ( ) != cidades . getclass ( ) ) { return false ; } final cidades other = ( cidades ) cidades ; if ( ( this . nome == null ) ? ( other . nome != null ) : ! this . nome . equals ( other . nome ) ) { return false ; } if ( ( this . uf == null ) ? ( other . uf != null ) : ! this . uf . equals ( other . uf ) ) { return false ; } if ( ( this . ddd == null ) ? ( other . ddd != null ) : ! this . ddd . equals ( other . ddd ) ) { return false ; } return true ; }
tr	5	private chunk loadchunk ( string [ ] [ ] s , renderer rend ) { point p1 = new point ( integer . decode ( s [ 0 ] [ 0 ] ) , integer . decode ( s [ 0 ] [ 1 ] ) ) ; loaded . add ( p1 ) ; chunk c ; const . debug ( "(savehandler:loadchunk): p1:" + p1 . x + "  " + p1 . y ) ; if ( p1 . x == 0 && p1 . y == 0 ) { const . debug ( "(savehandler:loadchunk): spawn will be loaded" ) ; c = new spawnchunk ( map , p1 , true , rend , false ) ; } else if ( p1 . y < 0 ) { const . debug ( "(savehandler:loadchunk): underground will be loaded" ) ; c = new undergroundchunk ( map , p1 , true , rend ) ; } else if ( p1 . y > 0 ) { const . debug ( "(savehandler:loadchunk): sky will be loaded" ) ; c = new skychunk ( map , p1 , true , rend ) ; } else { const . debug ( "(savehandler:loadchunk): surface will be loaded" ) ; c = new surfacechunk ( map , p1 , true , rend , false ) ; ( ( surfacechunk ) c ) . biome = integer . decode ( s [ 0 ] [ 2 ] ) ; if ( p1 . x == 0 ) { system . err . println ( "error while loading chunk  wrong selection" ) ; system . exit ( 1 ) ; } } cl . add ( c . pos . x , c . pos . y , c ) ; return c ; }
tr	7	private bed getbed ( commandline cmd ) { bed bed = null ; if ( cmd . hasoption ( "hostel_id" ) ) { if ( bed == null ) bed = new bed ( ) ; bed . sethostelid ( new identifier ( cmd . getoptionvalue ( "hostel_id" ) ) ) ; } if ( cmd . hasoption ( "bed_number" ) ) { if ( bed == null ) bed = new bed ( ) ; bed . setnumber ( new integer ( cmd . getoptionvalue ( "bed_number" ) ) ) ; } if ( cmd . hasoption ( "room_number" ) ) { if ( bed == null ) bed = new bed ( ) ; bed . setroomno ( new integer ( cmd . getoptionvalue ( "room_number" ) ) ) ; } if ( bed != null ) bed . settariff ( null ) ; return bed ; }
tr	2	public contextmenu getcontextmenu ( final modelverzameling mv ) { if ( contextmenu == null ) { contextmenu = new contextmenu ( ) ; menuitem menuitem1 = new menuitem ( "wat is het" ) ; menuitem1 . setonaction ( new eventhandler < actionevent > ( ) { @ override public void handle ( actionevent event ) { mv . gettekstvakmodel ( ) . settext ( "dit is een " + getname ( ) ) ; } } ) ; contextmenu . getitems ( ) . add ( menuitem1 ) ; if ( iseetbaar ( ) ) { menuitem menuitem2 = new menuitem ( "eet" ) ; menuitem2 . setonaction ( new eventhandler < actionevent > ( ) { @ override public void handle ( actionevent event ) { eet ( mv ) ; } } ) ; contextmenu . getitems ( ) . add ( menuitem2 ) ; } } return contextmenu ; }
tr	2	@ suppresswarnings ( "unchecked" ) public caseinsensitivedictionary ( dictionary delegate ) { notnullexception . assertvalue ( delegate , "delegate" ) ; this . delegate = new hashtable < string , object > ( delegate . size ( ) ) ; this . originalkeys = collections . synchronizedset ( new hashset < string > ( ) ) ; enumeration < string > e = delegate . keys ( ) ; while ( e . hasmoreelements ( ) ) { string key = e . nextelement ( ) ; if ( get ( key ) != null ) throw new illegalargumentexception ( "duplicates with varying case for key [" + key + "] : " + delegate ) ; this . delegate . put ( key . tolowercase ( locale . english ) , delegate . get ( key ) ) ; originalkeys . add ( key ) ; } }
tr	3	private static < t > void removeduplicatesbuffer ( node < t > list ) { if ( list == null ) { throw new illegalargumentexception ( ) ; } set < t > unique = new hashset < t > ( ) ; unique . add ( list . getdata ( ) ) ; while ( list . getnext ( ) != null ) { node < t > current = list ; while ( unique . contains ( current . getnext ( ) . getdata ( ) ) ) { current = current . getnext ( ) ; } unique . add ( current . getnext ( ) . getdata ( ) ) ; list . setnext ( current . getnext ( ) ) ; list = list . getnext ( ) ; } }
tr	0	public boardviewimpl ( ) { addmouselistener ( this ) ; setpreferredsize ( new dimension ( 483 , 500 ) ) ; imgboard = new imageicon ( constant . board_dir + "board.png" ) . getimage ( ) ; imgselect = new imageicon ( constant . image_dir + "select.png" ) . getimage ( ) ; imgcanmove = new imageicon ( constant . image_dir + "canmove.png" ) . getimage ( ) ; imgcankill = new imageicon ( constant . image_dir + "cankill.png" ) . getimage ( ) ; imgwarnking = new imageicon ( constant . image_dir + "chieutuong.png" ) . getimage ( ) ; imgfinish = new imageicon ( constant . image_dir + "hetco.png" ) . getimage ( ) ; imgtuongdo = new imageicon ( constant . chess_dir + "tuongdo.png" ) . getimage ( ) ; imgsydo = new imageicon ( constant . chess_dir + "sydo.png" ) . getimage ( ) ; imgtinhdo = new imageicon ( constant . chess_dir + "tinhdo.png" ) . getimage ( ) ; imgxedo = new imageicon ( constant . chess_dir + "xedo.png" ) . getimage ( ) ; imgphaodo = new imageicon ( constant . chess_dir + "phaodo.png" ) . getimage ( ) ; imgmado = new imageicon ( constant . chess_dir + "mado.png" ) . getimage ( ) ; imgtotdo = new imageicon ( constant . chess_dir + "totdo.png" ) . getimage ( ) ; imgtuongden = new imageicon ( constant . chess_dir + "tuongden.png" ) . getimage ( ) ; imgsyden = new imageicon ( constant . chess_dir + "syden.png" ) . getimage ( ) ; imgtinhden = new imageicon ( constant . chess_dir + "tinhden.png" ) . getimage ( ) ; imgxeden = new imageicon ( constant . chess_dir + "xeden.png" ) . getimage ( ) ; imgphaoden = new imageicon ( constant . chess_dir + "phaoden.png" ) . getimage ( ) ; imgmaden = new imageicon ( constant . chess_dir + "maden.png" ) . getimage ( ) ; imgtotden = new imageicon ( constant . chess_dir + "totden.png" ) . getimage ( ) ; }
tr	7	private string getorientationstring ( orientations o ) { string os = "unknown" ; if ( o == orientations . horizontal ) os = "horizontal" ; if ( o == orientations . left ) os = "90\u00b0 left" ; if ( o == orientations . right ) os = "90\u00b0 right" ; if ( o == orientations . upside ) os = "180\u00b0" ; if ( mytfttype == tfttypes . tft_320_240 ) { os = os + " (320x240)" ; } if ( mytfttype == tfttypes . tft_800_480 ) { os = os + " (800x480)" ; } if ( mytfttype == tfttypes . tft_480_272 ) { os = os + " (480x272)" ; } return os ; }
tr	5	public boolean ehenpassant ( posicao posicaopeca , posicao lado ) { if ( this . espiarpeca ( posicaopeca ) . gettipopeca ( ) == tipopeca . peao ) { if ( ! estaforadotabuleiro ( lado ) ) if ( this . estainimigo ( this . espiarpeca ( posicaopeca ) . getcorjogador ( ) , lado ) ) if ( this . espiarpeca ( lado ) . gettipopeca ( ) == tipopeca . peao ) { peao peaoinimigo = ( peao ) this . espiarpeca ( lado ) ; if ( peaoinimigo . ispodeenpassant ( ) ) return true ; } } return false ; }
tr	0	@ test public void testgetbasetype ( ) { system . out . println ( "arraytype: getbasetype()" ) ; class type = string [ ] [ ] . class ; arraytype instance = new arraytype ( type ) ; object exptype = string . class ; assertequals ( exptype , instance . getbasetype ( ) ) ; type = integer [ ] . class ; instance = new arraytype ( type ) ; assertequals ( integer . class , instance . getbasetype ( ) ) ; type = person [ ] . class ; instance = new arraytype ( type ) ; assertequals ( person . class , instance . getbasetype ( ) ) ; instance = new arraytype ( ) ; assertequals ( object . class , instance . getbasetype ( ) ) ; }
tr	2	private void checkcrossings ( final player player , final location from , final location to ) { message entered = null ; final set < region > regions = new hashset < region > ( ) ; regions . addall ( this . catalog . cached ( from . getworld ( ) , from . getblockx ( ) >> 4 , from . getblockz ( ) >> 4 ) ) ; if ( ! boundaryalerter . samechunk ( from , to ) ) regions . addall ( this . catalog . cached ( to . getworld ( ) , to . getblockx ( ) >> 4 , to . getblockz ( ) >> 4 ) ) ; entered = this . checkregions ( player , from , to , regions , entered ) ; if ( entered != null ) main . courier . submit ( new individual ( player ) , entered ) ; }
tr	8	private void waitforandconnectclients ( ) { boolean afterfirstplayer ; try { serversocket serversocket = new serversocket ( port ) ; socket clientsocket = new socket ( ) ; acceptconnections ( serversocket , clientsocket ) ; } catch ( sockettimeoutexception ste ) { system . out . println ( "sockettimeoutexception occured in server" ) ; boolean exitloop = false ; if ( server . numofclients >= 2 ) { this . startuppg . broadcastmessage ( "sbegin" ) ; while ( exitloop == false ) { if ( this . startuppg . areplayersreadytoplay ( ) == true ) { cgame45 . beginround ( ) ; exitloop = true ; } else { try { thread . sleep ( 1000 ) ; } catch ( interruptedexception ie ) { system . err . println ( "server interupted while waiting on all remote players to set up their screens" ) ; } } } } else { system . out . println ( "timeout exception occured and there was not enough players to begin playing" ) ; } } catch ( ioexception ioe ) { system . out . println ( "io exception occured in server" ) ; } catch ( securityexception sc ) { system . out . println ( "securityexceptionexception occured in server" ) ; } catch ( illegalblockingmodeexception ibme ) { system . out . println ( "illegalblockingmodeexception occured in server" ) ; } }
tr	9	static list < string > digestprotein ( string sequence , int minlen , int maxlen ) { list < string > peptides = new arraylist < string > ( ) ; string peptide ; int i = 0 , idx ; while ( i < sequence . length ( ) ) { idx = i ; while ( ( idx < sequence . length ( ) - 1 ) && ( ( ( sequence . charat ( idx ) == k || sequence . charat ( idx ) == r ) && sequence . charat ( idx + 1 ) == p ) || ( sequence . charat ( idx ) != k && sequence . charat ( idx ) != r ) ) ) { idx += 1 ; } peptide = sequence . substring ( i , idx + 1 ) ; if ( ( peptide . length ( ) >= minlen ) && ( peptide . length ( ) <= maxlen ) ) { peptides . add ( peptide ) ; } i = idx + 1 ; } return peptides ; }
tr	7	private string [ ] getstringarray ( jcomponent comp ) { if ( comp instanceof jcombobox ) { jcombobox combobox = ( jcombobox ) comp ; list < string > list = new arraylist < string > ( ) ; if ( combobox . getitemcount ( ) > 0 ) { for ( int i = 0 ; i < combobox . getitemcount ( ) ; i ++ ) { if ( ! isempty ( combobox . getitemat ( i ) ) ) { add ( list , combobox . getitemat ( i ) ) ; } else if ( ! isempty ( combobox . getselecteditem ( ) ) ) { add ( list , combobox . getselecteditem ( ) ) ; } } if ( list . size ( ) > 0 ) { return list . toarray ( new string [ 1 ] ) ; } else { return null ; } } else { if ( ! isempty ( combobox . getselecteditem ( ) ) ) { add ( list , combobox . getselecteditem ( ) ) ; return list . toarray ( new string [ 1 ] ) ; } } } return null ; }
tr	0	@ test public void testregisterandauth ( ) throws exception { messagesystem . sendmessage ( new msgregister ( frontend . getaddress ( ) , accountservice . getaddress ( ) , user , pass , ssid ) ) ; thread . sleep ( 3000 ) ; messagesystem . sendmessage ( new msglogin ( frontend . getaddress ( ) , accountservice . getaddress ( ) , user , pass , ssid ) ) ; thread . sleep ( 3000 ) ; when ( request . getpathinfo ( ) ) . thenreturn ( pages . main_page ) ; frontend . doget ( request , response ) ; assert . asserttrue ( stringwriter . tostring ( ) . contains ( user ) ) ; assert . assertfalse ( stringwriter . tostring ( ) . contains ( "anonymous" ) ) ; accountservice . delete ( user ) ; }
tr	7	public void put ( string key , mqttpersistable message ) throws mqttpersistenceexception { checkisopen ( ) ; file file = new file ( clientdir , key + message_file_extension ) ; file backupfile = new file ( clientdir , key + message_file_extension + message_backup_file_extension ) ; if ( file . exists ( ) ) { boolean result = file . renameto ( backupfile ) ; if ( ! result ) { backupfile . delete ( ) ; file . renameto ( backupfile ) ; } } try { fileoutputstream fos = new fileoutputstream ( file ) ; fos . write ( message . getheaderbytes ( ) , message . getheaderoffset ( ) , message . getheaderlength ( ) ) ; if ( message . getpayloadbytes ( ) != null ) { fos . write ( message . getpayloadbytes ( ) , message . getpayloadoffset ( ) , message . getpayloadlength ( ) ) ; } fos . getfd ( ) . sync ( ) ; fos . close ( ) ; if ( backupfile . exists ( ) ) { backupfile . delete ( ) ; } } catch ( ioexception ex ) { throw new mqttpersistenceexception ( ex ) ; } finally { if ( backupfile . exists ( ) ) { boolean result = backupfile . renameto ( file ) ; if ( ! result ) { file . delete ( ) ; backupfile . renameto ( file ) ; } } } }
tr	3	@ override public int storeproject ( string name , string description ) { connection conn = null ; stringbuffer query = new stringbuffer ( ) ; int newprojectid = 0 ; try { conn = getconnection ( ) ; query . append ( "insert into " ) . append ( super . getprimarytablename ( ) ) . append ( " (name  description)" ) . append ( " values " ) . append ( "('" + name + "'  '" + description + "')" ) ; resultset rs = executeupdategetkeys ( conn , query . tostring ( ) ) ; if ( rs . next ( ) ) { newprojectid = rs . getint ( 1 ) ; } rs . getstatement ( ) . close ( ) ; rs . close ( ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } finally { if ( conn != null ) { close ( conn ) ; } } return newprojectid ; }
tr	4	public void applytransformation ( int frameid ) { if ( vertexskin == null ) return ; if ( frameid == - 1 ) return ; animation animationframe = animation . forframeid ( frameid ) ; if ( animationframe == null ) return ; skins skins = animationframe . animationskins ; vertexmodifierx = 0 ; vertexmodifiery = 0 ; vertexmodifierz = 0 ; for ( int stepid = 0 ; stepid < animationframe . framecount ; stepid ++ ) { int opcode = animationframe . opcodetable [ stepid ] ; transformframe ( skins . opcodes [ opcode ] , skins . skinlist [ opcode ] , animationframe . transformationx [ stepid ] , animationframe . transformationy [ stepid ] , animationframe . transformationz [ stepid ] ) ; } }
tr	1	@ override public void solve ( final iupdateinfo uinfo ) { final dynamicbody bodyb = ( dynamicbody ) this . bodyb ; if ( bodya . isstatic ( ) ) { final vector3f dv = vectorpool . getvectorv3 ( false ) ; dv . setsubtract ( bodyb . getposition ( ) , bodya . getposition ( ) ) ; final float currentdistance = dv . length ( ) ; dv . scale ( 1f / currentdistance ) ; final float relvel = bodyb . getlinearvelocity ( ) . . ( dv ) ; final float reldist = currentdistance - distance ; final float remove = relvel + reldist * uinfo . getinverserate ( ) ; bodyb . getlinearvelocity ( ) . subtractscaled ( dv , remove ) ; vectorpool . release ( dv ) ; } else { final dynamicbody bodya = ( dynamicbody ) this . bodya ; final vector3f dv = vectorpool . getvectorv3 ( false ) ; final vector3f vv = vectorpool . getvectorv3 ( false ) ; dv . setsubtract ( bodyb . getposition ( ) , bodya . getposition ( ) ) ; final float currentdistance = dv . length ( ) ; dv . scale ( 1f / currentdistance ) ; vv . setsubtract ( bodyb . getlinearvelocity ( ) , bodya . getlinearvelocity ( ) ) ; final float relvel = vv . . ( dv ) ; final float reldist = currentdistance - distance ; final float remove = relvel + reldist * uinfo . getinverserate ( ) ; dv . scale ( remove / ( bodya . getinversemass ( ) + bodyb . getinversemass ( ) ) ) ; bodyb . getlinearvelocity ( ) . subtractscaled ( dv , bodyb . getinversemass ( ) ) ; bodya . getlinearvelocity ( ) . addscaled ( dv , bodya . getinversemass ( ) ) ; vectorpool . release ( dv ) ; vectorpool . release ( vv ) ; } }
tr	3	public regularanalyzer ( list < rule > rules ) { set < string > definedrulenames = new hashset < string > ( ) ; list < rule > observedrules = new arraylist < rule > ( ) ; observedrules . addall ( rules ) ; boolean foundregular ; do { foundregular = false ; for ( int index = observedrules . size ( ) - 1 ; index >= 0 ; index -- ) { set < string > dependent = observedrules . get ( index ) . getelements ( ) . getdependentrulenames ( ) ; if ( definedrulenames . containsall ( dependent ) ) { definedrulenames . add ( observedrules . get ( index ) . getrulename ( ) . tostring ( ) ) ; regularrules . add ( observedrules . get ( index ) ) ; observedrules . remove ( index ) ; foundregular = true ; continue ; } } } while ( foundregular ) ; observedrules . clear ( ) ; }
tr	1	public session ( string user , string docname , boolean start ) { this . requestqueue = new linkedlist < request > ( ) ; this . requestlog = new hashmap < string , list < request >> ( ) ; this . docmod = new hashset < request > ( ) ; this . docname = docname ; this . currentstate = new statevector ( ) ; this . username = user ; this . doctext = "" ; running = false ; listeners = new vector < changelistener > ( ) ; sessionthread = new thread ( this ) ; if ( start ) start ( ) ; }
tr	6	public void removepricestep ( double startprice , double endprice ) throws remoteexception { startprice = round ( startprice ) ; endprice = round ( endprice ) ; if ( startprice < 0 || endprice < 0 ) throw new pricestepnegativeargumentexception ( ) ; pricestep removestep = null ; for ( pricestep storedstep : pricesteps ) { if ( storedstep . getstartprice ( ) == startprice && storedstep . getendprice ( ) == endprice ) { removestep = storedstep ; } } if ( removestep == null ) { throw new pricestepintervalnotfoundexception ( ) ; } else { pricesteps . remove ( removestep ) ; } }
tr	9	@ override public void actionperformed ( actionevent e ) { if ( e . getsource ( ) == btnselectdate ) { int index = dateofvisitcombobox . getselectedindex ( ) ; currvisit = visits . get ( index ) ; prescs = parent . gethandler ( ) . getvisitprescriptions ( visits . get ( index ) . getpatusername ( ) , visits . get ( index ) . getdocusername ( ) , visits . get ( index ) . getdateofvisit ( ) ) ; model . removeallelements ( ) ; for ( prescription p : prescs ) { model . addelement ( p . getmedicinename ( ) ) ; } } else if ( e . getsource ( ) == btnselect ) { string medname = ( string ) medlist . getselectedvalue ( ) ; prescription pres = new prescription ( ) ; for ( prescription p : prescs ) { if ( p . getmedicinename ( ) . equals ( medname ) ) { pres = p ; break ; } } int duration = pres . getduration ( ) ; integer monthsd = duration / 30 ; integer daysd = duration % 30 ; integer dosage = pres . getdosage ( ) ; mednametextfield . settext ( medname ) ; dosagetextfield . settext ( dosage . tostring ( ) ) ; monthstextfield . settext ( monthsd . tostring ( ) ) ; daystextfield . settext ( daysd . tostring ( ) ) ; doctor doc = parent . gethandler ( ) . getdoctor ( currvisit . getdocusername ( ) ) ; string name = "dr. " + doc . getfname ( ) + " " + doc . getlname ( ) ; consultingdoctortextfield . settext ( name ) ; } else if ( e . getsource ( ) == btnaddtocart ) { int durationz = integer . parseint ( monthstextfield . gettext ( ) ) * 30 + integer . parseint ( daystextfield . gettext ( ) ) ; prescription prescription = new prescription ( username , consultingdoctortextfield . gettext ( ) , ( string ) dateofvisitcombobox . getselecteditem ( ) , mednametextfield . gettext ( ) , integer . parseint ( dosagetextfield . gettext ( ) ) , durationz , "" , "no" ) ; cart . add ( prescription ) ; model2 . addelement ( prescription . getmedicinename ( ) ) ; } else if ( e . getsource ( ) == btncheckout ) { if ( ! cart . isempty ( ) ) { paymentinfopanel pip = new paymentinfopanel ( parent , username , cart ) ; parent . getcontentpane ( ) . add ( pip ) ; cardlayout cl = ( cardlayout ) parent . getcontentpane ( ) . getlayout ( ) ; cl . next ( parent . getcontentpane ( ) ) ; } else { joptionpane . showmessagedialog ( null , "cart is empty." ) ; } } else if ( e . getsource ( ) == btnback ) { cardlayout cl = ( cardlayout ) parent . getcontentpane ( ) . getlayout ( ) ; parent . getcontentpane ( ) . remove ( parent . getcontentpane ( ) . getcomponents ( ) . length - 1 ) ; cl . last ( parent . getcontentpane ( ) ) ; } }
tr	8	public void executepowerup ( powerupnode node ) { powerupplayer powerup = node . powerup ; if ( powerup == null ) return ; switch ( powerup . addsfeature ) { case bomb_max_count : combatsystem . updatebomblayer ( node . entity_target , null , null , powerup . amount , null ) ; break ; case bomb_temp_count : combatsystem . updatebomblayer ( node . entity_target , null , null , null , powerup . amount ) ; break ; case can_jump : break ; case can_push : break ; case flame_length : combatsystem . updatebomblayer ( node . entity_target , powerup . amount , null , null , null ) ; break ; case speed : movementsystem . updatemoveable ( node . entity_target , powerup . amount ) ; break ; case damage : combatsystem . updatebomblayer ( node . entity_target , null , powerup . amount , null , null ) ; } }
tr	8	public list < dimensionwrapper > getdimensionhierarchy ( string indicatorname , string keyfamilyid ) { if ( hierarchicalcodelists == null || hierarchicalcodelists . size ( ) <= 0 ) { return null ; } dimension inddim = getindicatorordataelementdimension ( keyfamilyid ) ; codelist codelist = getcodelist ( inddim . getcodelistref ( ) ) ; code code = codelist . getcodebydescription ( indicatorname ) ; if ( code == null ) { return null ; } hierarchicalcodelist hierarchicalcodelist = gethierarchicalcodelist ( constants . hcl_configuration_hierarchies ) ; if ( hierarchicalcodelist == null ) { hierarchicalcodelist = gethierarchicalcodelist ( constants . hcl_configuration_hierarchies_backwards_compatible ) ; } hierarchy hierarchy = hierarchicalcodelist . gethierarchy ( constants . indicator_disaggregation_hierarchy ) ; if ( hierarchy == null ) { hierarchy = hierarchicalcodelist . gethierarchy ( constants . indicator_disaggregation_hierarchy_backwards_compatible ) ; if ( hierarchy == null ) { return null ; } } coderef coderef = hierarchy . findcoderef ( hierarchicalcodelist . getcodelistalias ( inddim . getcodelistref ( ) ) , code . getvalue ( ) ) ; if ( coderef == null ) { return null ; } list < dimensionwrapper > dimensionhierarchy ; if ( coderef != null ) { dimensionhierarchy = constructdimensionhierarchy ( coderef ) ; } else { dimensionhierarchy = new arraylist < dimensionwrapper > ( ) ; } return dimensionhierarchy ; }
tr	0	public static void main ( string [ ] args ) { userinfodto user = new userinfodto ( ) ; caretaker caretaker = new caretaker ( ) ; user . setaccount ( "zhangsan" ) ; user . setpassword ( "123456" ) ; user . settelno ( "13000000000" ) ; system . out . println ( "\u7528\u6237\u521b\u5efa\u5b8c\u6bd5\uff01" ) ; user . show ( ) ; caretaker . setmemento ( user . savememento ( ) ) ; system . out . println ( "\u5df2\u7ecf\u4fdd\u5b58\u4e86\u7528\u6237\u7684\u5907\u5fd8\u5f55\uff01" ) ; user . setpassword ( "111111" ) ; user . settelno ( "13100001111" ) ; system . out . println ( "\u7528\u6237\u4fe1\u606f\u5df2\u7ecf\u66f4\u65b0\uff01" ) ; user . show ( ) ; system . out . println ( "---------------------------" ) ; user . restorememento ( caretaker . getmemento ( ) ) ; system . out . println ( "\u5df2\u7ecf\u6062\u590d\u4e86\u5907\u5fd8\u5f55\uff01" ) ; user . show ( ) ; system . out . println ( "---------------------------" ) ; }
tr	2	private void botoneliminarusuarioactionperformed ( java . awt . event . actionevent evt ) { if ( this . tablaadministracionusuarios . getselectedrow ( ) > - 1 ) { string codigo = ( string ) this . conectortablausuarios . getvalueat ( this . tablaadministracionusuarios . getselectedrow ( ) , 0 ) ; int respuesta = joptionpane . showconfirmdialog ( this . botoneliminarusuario , "\u00bfrealmente desea eliminar \n al usuario " + codigo + "?" , "confirme eliminaci\u00f3n" , joptionpane . yes_no_option , joptionpane . question_message ) ; if ( respuesta == joptionpane . yes_option ) { usuario u = this . modeloapp . obtenerusuarioconcodigo ( codigo ) ; this . modeloapp . eliminarusuario ( u ) ; this . conectortablausuarios . cargarusuarios ( ) ; } } else { joptionpane . showmessagedialog ( this , "debe seleccionar un\nusuario de la tabla" , "usuario no seleccionado" , joptionpane . information_message ) ; } }
tr	1	public void actionperformed ( actionevent e ) { if ( try_to_register ( textfield_nazw . gettext ( ) , textfield_imie . gettext ( ) , textfield_wiek . gettext ( ) , textfield_adres . gettext ( ) , textfield_miasto . gettext ( ) , textfield_kod . gettext ( ) , textfield_nick . gettext ( ) , passwordfield . getpassword ( ) , passwordfield_1 . getpassword ( ) , textfield_e_m . gettext ( ) ) ) { swingutilities . invokelater ( new runnable ( ) { public void run ( ) { joptionpane . showmessagedialog ( register . this , "rejestracja przebieg\u0142a pomy\u015blnie" ) ; } } ) ; } }
tr	5	@ override public boolean onrequest ( httprequest request , httpresponse response ) throws exception { string filepath = request . getrequestedfilepath ( ) ; if ( urltomapto != null ) { if ( ! filepath . startswith ( urltomapto ) ) return false ; filepath = filepath . substring ( urltomapto . length ( ) ) ; } file file = new file ( directory , filepath ) ; if ( ! file . isfile ( ) || ! file . canread ( ) || ! file . getabsolutepath ( ) . startswith ( directory . getabsolutepath ( ) ) ) return false ; iofilechannelinputbuffer buffer = new iofilechannelinputbuffer ( new fileinputstream ( file ) . getchannel ( ) ) ; response . setheader ( "content-type" , mimenamemap . getcontenttypefor ( file . getabsolutepath ( ) ) ) ; response . setbodybuffer ( buffer ) ; buffer . free ( ) ; return true ; }
tr	8	@ override public boolean equals ( object o ) { if ( this == o ) return true ; if ( o == null || getclass ( ) != o . getclass ( ) ) return false ; survey survey = ( survey ) o ; if ( idsurvey != survey . idsurvey ) return false ; if ( date != null ? ! date . equals ( survey . date ) : survey . date != null ) return false ; if ( question != null ? ! question . equals ( survey . question ) : survey . question != null ) return false ; return true ; }
tr	4	public char [ ] mincharcutmulti ( int numoftracks ) { debugger . debug ( "min cut set:***************\n" , 2 , debuglevel ) ; hashset < arraylist < transition >> mincutset = mincutmulti ( numoftracks ) ; stringbuilder b = new stringbuilder ( ) ; for ( arraylist < transition > tracksarray : mincutset ) { transition tracks [ ] = new transition [ numoftracks ] ; for ( int i = 0 ; i < tracksarray . size ( ) ; i ++ ) { tracks [ tracksarray . get ( i ) . track - 1 ] = tracksarray . get ( i ) ; } for ( int i = 0 ; i < tracks . length ; i ++ ) { b . append ( "track" ) . append ( i + 1 ) ; b . append ( ": [" ) ; if ( tracks [ i ] . min != tracks [ i ] . max ) { transition . appendcharstring ( tracks [ i ] . min , b ) ; b . append ( "  " ) ; transition . appendcharstring ( tracks [ i ] . max , b ) ; } else transition . appendcharstring ( tracks [ i ] . min , b ) ; b . append ( "]" ) ; b . append ( "   " ) ; } b . append ( "\n" ) ; } debugger . debug ( b . tostring ( ) , 0 , debuglevel ) ; return null ; }
tr	0	private void writeoutput ( datacontroller datacontroller , schedule schedule ) { outputformat outputformat = mapoutputformat ( parameters . get ( "format" ) ) ; protocol . log ( "ausgabeformat: " + outputformat ) ; string outputdirectory = parameters . get ( "out" ) ; protocol . log ( "ausgabeverzeichnis: " + outputdirectory ) ; outputcontroller outputcontroller = new outputcontroller ( ) ; list < scheduleview > scheduleviews = schedule . getallscheduleviews ( datacontroller . getrooms ( ) , datacontroller . getacademics ( ) , datacontroller . getstudyprograms ( ) ) ; outputcontroller . outputschedules ( scheduleviews , outputformat , outputdirectory ) ; }
tr	7	private void btnapostaractionperformed ( java . awt . event . actionevent evt ) { if ( carreraabierta != null ) { jugador j = new jugador ( 0 , txtusuario . gettext ( ) . tostring ( ) , txtpass . gettext ( ) . tostring ( ) ) ; j = fachada . login ( j ) ; if ( j != null ) { if ( validarmonto ( ) ) { caballoencarrera caballo = ( caballoencarrera ) lstcaballos . getselectedvalue ( ) ; apuesta a = new apuesta ( integer . parseint ( txtmonto . gettext ( ) ) , j ) ; if ( a . validar ( ) ) { erroresapuesta ret = caballo . agregarapuesta ( a ) ; switch ( ret ) { case ok : messagebox ( "apuesta realizada correctamente" ) ; borrardatosjugador ( ) ; break ; case saldoinsuficiente : messagebox ( "saldo insuficiente" ) ; break ; case errorgenerico : messagebox ( "error inesperado" ) ; break ; } } else { messagebox ( "el monto debe ser mayor que cero" ) ; } } else { messagebox ( "el monto debe ser num\u00e9rico" ) ; } } else { messagebox ( "login incorrecto" ) ; } } else { messagebox ( "no hay carreras abiertas" ) ; } }
tr	2	public static void main ( string [ ] args ) { dateformat dateformat = new simpledateformat ( dateutil . date_format ) ; date birthdate = null ; try { birthdate = dateformat . parse ( "1983-12-07" ) ; } catch ( parseexception ex ) { ex . printstacktrace ( system . err ) ; } logininfo logininfo = new logininfo ( "shamim" , "secret" ) ; billinginfo billinginfo = new billinginfo ( "003-254992-001" , creditcardtype . mastercard ) ; biographicalinfo biographicalinfo = new biographicalinfo ( "shamim" , "ahmed" , birthdate ) ; usercreator . setlogininfo ( logininfo ) ; usercreator . setbillinginfo ( billinginfo ) ; usercreator . setbiographicalinfo ( biographicalinfo ) ; boolean result = usercreator . adduser ( ) ; system . out . printf ( "user %s created successfully%n" , result ? "was" : "was not" ) ; }
tr	5	public void decay ( ) { entities . clear ( ) ; for ( int b = 0 ; b < parts . size ( ) ; b ++ ) { if ( parts . get ( b ) . iscontainer ( ) ) { entities . addall ( parts . get ( b ) . getentities ( ) ) ; } } if ( entities . size ( ) > 0 ) { for ( int e = 0 ; e < entities . size ( ) ; e ++ ) { if ( entities . get ( e ) . getbodypart ( ) != null ) { entities . get ( e ) . getbodypart ( ) . decay ( ) ; } } } }
tr	1	private static void test4 ( ) throws interruptedexception { executorservice executor = executors . newworkstealingpool ( ) ; list < callable < string >> callables = arrays . aslist ( ( ) -> "task1" , ( ) -> "task2" , ( ) -> "task3" ) ; executor . invokeall ( callables ) . stream ( ) . map ( future -> { try { return future . get ( ) ; } catch ( exception e ) { throw new illegalstateexception ( e ) ; } } ) . foreach ( system . out colcol println ) ; executor . shutdown ( ) ; }
tr	9	private boolean esdireccioncorrecta ( string entrada_direccion ) { char letra ; boolean direccioncorrecta = true ; boolean direccionincorrecta = false ; if ( entrada_direccion . equals ( "" ) ) { return direccionincorrecta ; } else { for ( int indice = 0 ; indice < entrada_direccion . length ( ) ; indice ++ ) { letra = entrada_direccion . charat ( indice ) ; if ( ! ( ( letra >= 0 && letra <= 9 ) || ( letra >= a & letra <= z ) || ( letra >= a && letra <= z ) || ( letra ==   || letra == # ) ) ) { return direccionincorrecta ; } } } return direccioncorrecta ; }
tr	5	@ override public int compare ( course course1 , course course2 ) { if ( sortorder == sortorder . ascending ) { if ( course1 . getstudents ( ) < course2 . getstudents ( ) ) { return - 1 ; } else if ( course1 . getstudents ( ) == course2 . getstudents ( ) ) { return 0 ; } else { return 1 ; } } else { if ( course1 . getstudents ( ) < course2 . getstudents ( ) ) { return 1 ; } else if ( course1 . getstudents ( ) == course2 . getstudents ( ) ) { return 0 ; } else { return - 1 ; } } }
tr	9	@ suppresswarnings ( "redundantifstatement" ) @ override public boolean equals ( object o ) { if ( this == o ) return true ; if ( o == null || getclass ( ) != o . getclass ( ) ) return false ; gitclone gitclone = ( gitclone ) o ; if ( localpath != null ? ! localpath . equals ( gitclone . localpath ) : gitclone . localpath != null ) return false ; if ( pathtogit != null ? ! pathtogit . equals ( gitclone . pathtogit ) : gitclone . pathtogit != null ) return false ; if ( repositoryurl != null ? ! repositoryurl . equals ( gitclone . repositoryurl ) : gitclone . repositoryurl != null ) return false ; return true ; }
tr	9	public list < task > sort ( final int colindex , final boolean sortdown ) { gettasks ( ) ; if ( colindex >= 0 && colindex <= 6 ) { collections . sort ( tasks , new comparator < task > ( ) { @ override public int compare ( task arg0 , task arg1 ) { int result = 0 ; if ( colindex == 1 || colindex == 2 || colindex == 3 || colindex == 5 || colindex == 6 ) { stringcomparer stringcomparator = new stringcomparer ( sortdown ) ; result = comparer ( stringcomparator , arg0 , arg1 , colindex ) ; } else if ( colindex == 0 ) { integercomparer intcomparator = new integercomparer ( sortdown ) ; result = comparer ( intcomparator , arg0 , arg1 , colindex ) ; } else if ( colindex == 4 ) { datecomparer datecomparator = new datecomparer ( sortdown ) ; result = comparer ( datecomparator , arg0 , arg1 , colindex ) ; } return result ; } } ) ; } else { throw new illegalargumentexception ( "invalid column index." ) ; } return tasks ; }
tr	3	public void switchfullscreen ( ) { if ( fullscreen == false ) { throw new illegalstateexception ( "this window not supports fullscreen mode!" ) ; } if ( state == windowstate . window ) { rectangle rc = this . getbounds ( ) ; boolean resizable = this . isresizable ( ) ; this . properties = new frameproperties ( getx ( ) , gety ( ) , ( int ) rc . getwidth ( ) , ( int ) rc . getheight ( ) , resizable ) ; } if ( device . getfullscreenwindow ( ) == null ) { frameproperties properties = new frameproperties ( 0 , 0 , getfullwidth ( ) , getfullheight ( ) , false ) ; this . setextendedstate ( jframe . maximized_both ) ; this . state = windowstate . fullscreen ; properties . append ( this ) ; device . setfullscreenwindow ( this ) ; updatedisplay ( ) ; return ; } device . setfullscreenwindow ( null ) ; this . setextendedstate ( jframe . normal ) ; this . state = windowstate . window ; properties . append ( this ) ; updatedisplay ( ) ; }
tr	5	public void handle ( connection connection , request request ) { logger . debug ( "nickcommand handler : " + request ) ; if ( stringutils . isempty ( request . getargs ( ) ) ) { connection . serversendcommandtome ( "431 err_nonicknamegiven :no nickname given" ) ; return ; } string newnickname = request . getargs ( ) . trim ( ) ; string oldnickname = connection . getnickname ( ) ; if ( newnickname . startswith ( ":" ) ) { newnickname = newnickname . substring ( 1 ) ; } if ( ! isnickcorrectlyformat ( newnickname ) ) { connection . serversendcommandtome ( "432 err_erroneusnickname " + newnickname + " :erroneus nickname" ) ; return ; } if ( connection . isnickexist ( newnickname ) ) { connection . serversendcommandtome ( "433 err_nicknameinuse " + newnickname + " :nickname is already in use" ) ; return ; } if ( stringutils . isnotempty ( oldnickname ) ) { connection . mesendcommandtoall ( "nick " + newnickname ) ; } connection . setnickname ( newnickname ) ; }
tr	6	private list < student > parse ( final document doc ) { final list < student > students = new vector < student > ( ) ; if ( doc == null ) { return students ; } final element root = doc . getdocumentelement ( ) ; final nodelist nodestudents = root . getchildnodes ( ) ; if ( nodestudents != null ) { if ( nodestudents . getlength ( ) != 0 ) { for ( int i = 0 ; i < nodestudents . getlength ( ) ; ++ i ) { final node nodestudent = nodestudents . item ( i ) ; if ( nodestudent != null ) { if ( nodestudent . getnodetype ( ) == node . element_node ) { final student student = parsestudent ( nodestudent ) ; students . add ( student ) ; } } } } } return students ; }
tr	4	private static string readline ( int linenumber ) { bufferedreader reader = null ; string line = "" ; try { reader = new bufferedreader ( new filereader ( file ) ) ; int i = 0 ; for ( string curline ; ( curline = reader . readline ( ) ) != null ; i ++ ) { if ( i == linenumber ) line = curline ; } } catch ( ioexception e ) { } finally { try { reader . close ( ) ; } catch ( exception e ) { } } return line ; }
tr	2	public list < comborating > gettoplist ( ) throws sqlexception { statement st = null ; list < comborating > toplist = new arraylist < comborating > ( ) ; try { st = conn . createstatement ( ) ; resultset rs = st . executequery ( "select ((total_rating * 1.0)/times_rated) as rating  flavor_1  flavor_2  times_rated  total_rating from flavor_combo_ratings order by rating desc limit 10" ) ; while ( rs . next ( ) ) { toplist . add ( new comborating ( rs . getint ( "flavor_1" ) , rs . getint ( "flavor_2" ) , rs . getint ( "total_rating" ) , rs . getint ( "times_rated" ) ) ) ; } } finally { if ( st != null ) st . close ( ) ; } return toplist ; }
tr	1	public static void main ( string [ ] args ) { final int [ ] coins = new int [ ] { 1 , 2 , 5 , 10 , 20 , 50 , 100 , 200 } ; final int [ ] limits = new int [ coins . length ] ; for ( int i = 0 ; i < limits . length ; i ++ ) { limits [ i ] = target / coins [ i ] ; } final int [ ] counts = new int [ coins . length ] ; loop ( coins , limits , counts , 0 ) ; system . out . println ( "# count = " + count ) ; }
tr	3	private void createtable ( ormhash ht , ormtable table ) throws sqlexception { string createsql = ht . createsql ( ) ; string tablename = table . tablename ( ) ; int hashsize = ht . hashsize ( ) ; if ( hashsize < 1 ) { hashsize = 1 ; } list < string > alreadyexisttablelist = dao . queryforsimpobjectlist ( "show tables like '" + tablename + "%'" , new object [ ] { } , string . class ) ; messageformat mf = new messageformat ( createsql ) ; string hashtablename = null ; for ( int i = 0 ; i < hashsize ; i ++ ) { hashtablename = tablename + "_" + dbutils . getinstance ( ) . hash ( i , hashsize ) ; if ( alreadyexisttablelist . contains ( hashtablename ) ) { logger . trace ( "hash table[{}] is already exist!" , hashtablename ) ; } else { logger . info ( "init hash table:{};" , hashtablename ) ; dao . update ( mf . format ( new object [ ] { hashtablename } ) ) ; logger . info ( "init hash table[{}] finish." , hashtablename ) ; } } }
tr	5	public static list < employee > load ( inputstream input ) { list < employee > employees = new arraylist < employee > ( ) ; bufferedreader reader = null ; try { reader = new bufferedreader ( new inputstreamreader ( input ) ) ; while ( true ) { string line = reader . readline ( ) ; if ( line == null ) break ; string [ ] values = line . split ( " " ) ; employee employee = new employee ( values [ 0 ] , values [ 1 ] , values [ 2 ] ) ; employees . add ( employee ) ; } return employees ; } catch ( ioexception e ) { throw new runtimeexception ( e ) ; } finally { if ( reader != null ) { try { reader . close ( ) ; } catch ( ioexception e ) { } } } }
tr	9	public static method getasmethodofpublicbase ( class < ? > c , method m ) { for ( class < ? > iface : c . getinterfaces ( ) ) { for ( method im : iface . getmethods ( ) ) { if ( ismatch ( im , m ) ) { return im ; } } } class < ? > sc = c . getsuperclass ( ) ; if ( sc == null ) { return null ; } for ( method scm : sc . getmethods ( ) ) { if ( ismatch ( scm , m ) ) { return scm ; } } return getasmethodofpublicbase ( sc , m ) ; }
tr	2	public defaultsettingsmodifierpanel ( gct gctarg , boolean [ ] editedarg ) { gct = gctarg ; edited = editedarg ; setlayout ( new borderlayout ( ) ) ; usecode = new jcheckbox ( "include default settings modifier" , finddsminstance ( ) ) ; usecode . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent arg0 ) { edited [ 0 ] = true ; if ( dsm != null ) { gct . deletedynamiccode ( dsm ) ; dsm = null ; } else { dsm = new dsm ( ) ; gct . adddynamiccode ( dsm ) ; } initialize ( ) ; } } ) ; add ( usecode , borderlayout . north ) ; container = new jpanel ( ) ; container . setlayout ( new boxlayout ( container , boxlayout . y_axis ) ) ; jpanel [ ] rows = { new jpanel ( ) , new jpanel ( ) , new jpanel ( ) } ; for ( jpanel p : rows ) { p . setlayout ( new boxlayout ( p , boxlayout . x_axis ) ) ; container . add ( p ) ; } add ( container , borderlayout . center ) ; gametype = new jcombobox ( ) ; gametype . additem ( "time" ) ; gametype . additem ( "stock" ) ; gametype . additem ( "coin" ) ; gametype . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent arg0 ) { dsm . setgametype ( ( byte ) gametype . getselectedindex ( ) ) ; } } ) ; rows [ 0 ] . add ( new jlabel ( "game type: " ) ) ; rows [ 0 ] . add ( gametype ) ; time = new spinnernumbermodel ( 4 , 0 , 99 , 1 ) ; time . addchangelistener ( new changelistener ( ) { public void statechanged ( changeevent arg0 ) { byte b = time . getnumber ( ) . bytevalue ( ) ; dsm . settimelimit ( b ) ; edited [ 0 ] = true ; } } ) ; rows [ 0 ] . add ( new jlabel ( "time (min): " ) ) ; rows [ 0 ] . add ( new jspinner ( time ) ) ; stock = new spinnernumbermodel ( 4 , 1 , 99 , 1 ) ; stock . addchangelistener ( new changelistener ( ) { public void statechanged ( changeevent arg0 ) { byte b = stock . getnumber ( ) . bytevalue ( ) ; dsm . setstock ( b ) ; edited [ 0 ] = true ; } } ) ; rows [ 0 ] . add ( new jlabel ( "stock: " ) ) ; rows [ 0 ] . add ( new jspinner ( stock ) ) ; stocktime = new spinnernumbermodel ( 8 , 0 , 99 , 1 ) ; stocktime . addchangelistener ( new changelistener ( ) { public void statechanged ( changeevent arg0 ) { byte b = stocktime . getnumber ( ) . bytevalue ( ) ; dsm . setstocktimelimit ( b ) ; edited [ 0 ] = true ; } } ) ; rows [ 0 ] . add ( new jlabel ( "stock-mode time: " ) ) ; rows [ 0 ] . add ( new jspinner ( stocktime ) ) ; handicap = new jcombobox ( ) ; handicap . additem ( "off" ) ; handicap . additem ( "auto" ) ; handicap . additem ( "on" ) ; handicap . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent arg0 ) { dsm . sethandicap ( ( byte ) handicap . getselectedindex ( ) ) ; edited [ 0 ] = true ; } } ) ; rows [ 1 ] . add ( new jlabel ( "handicap: " ) ) ; rows [ 1 ] . add ( handicap ) ; damageratio = new spinnernumbermodel ( 1.0 , 0.5 , 2.0 , .1 ) ; damageratio . addchangelistener ( new changelistener ( ) { public void statechanged ( changeevent arg0 ) { double d = 10 * damageratio . getnumber ( ) . doublevalue ( ) ; dsm . setdamageratio ( d ) ; edited [ 0 ] = true ; } } ) ; rows [ 1 ] . add ( new jlabel ( "damage ratio: " ) ) ; rows [ 1 ] . add ( new jspinner ( damageratio ) ) ; stagemethod = new jcombobox ( ) ; stagemethod . additem ( "choose" ) ; stagemethod . additem ( "random" ) ; stagemethod . additem ( "take turns" ) ; stagemethod . additem ( "ordered" ) ; stagemethod . additem ( "loser's pick" ) ; stagemethod . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent arg0 ) { dsm . setstagemethod ( ( byte ) stagemethod . getselectedindex ( ) ) ; edited [ 0 ] = true ; } } ) ; rows [ 1 ] . add ( new jlabel ( "stage method: " ) ) ; rows [ 1 ] . add ( stagemethod ) ; teamattack = new jcheckbox ( "team attack" ) ; teamattack . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent arg0 ) { dsm . setteamattack ( teamattack . isselected ( ) ) ; edited [ 0 ] = true ; } } ) ; rows [ 2 ] . add ( teamattack ) ; pause = new jcheckbox ( "pause" ) ; pause . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent arg0 ) { dsm . setpause ( pause . isselected ( ) ) ; edited [ 0 ] = true ; } } ) ; rows [ 2 ] . add ( pause ) ; scoredisplay = new jcheckbox ( "scoredisplay" ) ; scoredisplay . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent arg0 ) { dsm . setscoredisplay ( scoredisplay . isselected ( ) ) ; edited [ 0 ] = true ; } } ) ; rows [ 2 ] . add ( scoredisplay ) ; damagegauge = new jcheckbox ( "damagegauge" ) ; damagegauge . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent arg0 ) { dsm . setdamagegauge ( damagegauge . isselected ( ) ) ; edited [ 0 ] = true ; } } ) ; rows [ 2 ] . add ( damagegauge ) ; initialize ( ) ; }
tr	7	private void insertdatabaseoperation ( object object , connection connection , databaseoperation databaseoperation ) { try { if ( ! object . getclass ( ) . isannotationpresent ( table . class ) ) { throw new jstrykerexception ( "object(" + object + ") isn't entity" ) ; } table table = object . getclass ( ) . getannotation ( table . class ) ; stringbuilder builder = new stringbuilder ( "<?xml version=\"1.0\"?>\n<dataset>\n<" ) ; builder . append ( table . name ( ) ) . append ( " " ) ; field [ ] fields = object . getclass ( ) . getdeclaredfields ( ) ; for ( field field : fields ) { field . setaccessible ( true ) ; object value = field . get ( object ) ; if ( value == null ) { continue ; } if ( field . isannotationpresent ( transient . class ) ) { continue ; } column annotation = field . getannotation ( column . class ) ; if ( annotation != null && ! "" . equals ( annotation . name ( ) ) ) { builder . append ( annotation . name ( ) ) ; } else { builder . append ( field . getname ( ) ) ; } builder . append ( "=\"" ) ; builder . append ( value ) ; builder . append ( "\" " ) ; } builder . append ( "/>\n</dataset>" ) ; string string = builder . tostring ( ) ; execute ( null , connection , new bytearrayinputstream ( string . getbytes ( ) ) , databaseoperation ) ; } catch ( illegalaccessexception e ) { throw new jstrykerexception ( e . getmessage ( ) , e ) ; } }
tr	8	public static int searchint ( int [ ] arr , int low , int high , int x ) { if ( low > high ) return - 1 ; int mid = ( low + high ) / 2 ; if ( x == arr [ mid ] ) return mid ; if ( arr [ mid ] >= arr [ low ] && arr [ mid ] >= arr [ high ] ) { if ( x >= arr [ low ] && x < arr [ mid ] ) return searchint ( arr , low , mid - 1 , x ) ; else return searchint ( arr , mid , high , x ) ; } else { if ( x > arr [ mid ] && x <= arr [ high ] ) return searchint ( arr , mid + 1 , high , x ) ; else return searchint ( arr , low , mid , x ) ; } }
tr	9	public static integer getintegerfromsubstring ( string target , string prefix , string suffix ) { if ( target == null ) return null ; integer retval = null ; try { string tmp = target ; if ( prefix != null && target . contains ( prefix ) ) { int sz = prefix . length ( ) ; int in = target . indexof ( prefix ) ; tmp = target . substring ( in + sz ) ; } if ( tmp != null && suffix != null && target . contains ( suffix ) ) { int suf = tmp . indexof ( suffix ) ; if ( suf <= 0 && suffix . equals ( " " ) ) suf = tmp . length ( ) ; tmp = tmp . substring ( 0 , suf ) ; retval = intutils . getintegerfromstring ( tmp . trim ( ) ) ; } } catch ( exception e ) { logger . log ( level . info , "not a big deal that we couldn't find an int from substring...going to return null" , e ) ; retval = null ; } return retval ; }
tr	7	private void openaddmeterpanel ( ) { boolean failure = false ; string options [ ] = { "create" , "cancel" } ; int result = joptionpane . showoptiondialog ( null , addmeterpanel , "add meter to account " + getselectedaccountid ( ) , joptionpane . default_option , joptionpane . plain_message , null , options , options [ 0 ] ) ; if ( result == 0 ) { meter m = getmeterfromaddmeterpanel ( ) ; account temp = getselectedaccount ( ) ; if ( m != null ) { if ( temp instanceof residentialaccount ) { residentialaccount resacc = ( residentialaccount ) temp ; if ( resacc . getmeter ( ) != null ) { boolean overwrite = confirmresidentialaccountconflict ( ) ; if ( ! overwrite ) return ; } } else if ( temp . hasmeter ( m . getmeterid ( ) ) ) { failure = true ; } } else { failure = true ; } if ( ! failure ) { temp . addmeter ( m ) ; system . out . println ( m . getmeterid ( ) ) ; showmetersinmetertable ( temp ) ; } else { failtocreatemeterdialog ( ) ; } } }
tr	7	public static list < string > getproperties ( object bean ) throws remoteexception { list < string > result = new arraylist < string > ( ) ; if ( bean == null ) return result ; if ( bean instanceof genericobject ) { genericobject o = ( genericobject ) bean ; result . addall ( arrays . aslist ( o . getattributenames ( ) ) ) ; return result ; } method [ ] methods = bean . getclass ( ) . getmethods ( ) ; if ( methods == null || methods . length == 0 ) return result ; for ( method m : methods ) { string name = m . getname ( ) ; if ( name . startswith ( "get" ) && name . length ( ) > 3 ) result . add ( toproperty ( name ) ) ; } return result ; }
tr	7	protected synchronized void update ( ) { date now = new date ( ) ; long delta = now . gettime ( ) - lastupdate . gettime ( ) ; if ( isdead ( ) ) return ; point oldpos = new point ( x , y ) ; point dir = new point ( speed . getdirectionx ( ) , speed . getdirectiony ( ) ) ; boolean blocked = false ; if ( dir . x != 0 ) blocked |= ! updateposx ( delta ) ; if ( dir . y != 0 ) blocked |= ! updateposy ( delta ) ; if ( ( dir . x == 0 && dir . y == 0 ) || blocked || ! oldpos . equals ( this ) ) lastupdate = now ; }
tr	1	public static responsedto showpassengers ( requestdto reqobj , passengerdao passengerdao ) { log . debug ( "start: showpassengers()" ) ; list < passengerdto > passengers ; int trainnumber = ( ( list < scheduledto > ) reqobj . getobject ( ) ) . get ( 0 ) . getnumber ( ) ; try { passengers = passengerdao . getpassengersbytrain ( trainnumber ) ; } catch ( nopassengersexception ex ) { log . warn ( "exception: no passengers for given train" ) ; return new responsedto ( constants . statusofexecutedservice . error , ex . getmessage ( ) ) ; } log . debug ( "finish: showpassengers()" ) ; return new responsedto ( constants . statusofexecutedservice . success , passengers ) ; }
tr	8	public static void main ( string [ ] args ) { int grade ; grade = integer . parseint ( args [ 0 ] ) ; if ( grade <= 100 && grade >= 85 ) system . out . println ( "hd" ) ; else if ( grade <= 84 && grade >= 75 ) system . out . println ( "d" ) ; else if ( grade <= 74 && grade >= 65 ) system . out . println ( "c" ) ; else if ( grade <= 64 && grade >= 50 ) system . out . println ( "p" ) ; else system . out . println ( "f" ) ; }
tr	2	@ override public boolean login ( ) throws loginexception { namecallback namecallback = new namecallback ( "name : " ) ; passwordcallback passwordcallback = new passwordcallback ( "password : " , false ) ; try { callbackhandler . handle ( new callback [ ] { namecallback , passwordcallback } ) ; string username = namecallback . getname ( ) ; string password = new string ( passwordcallback . getpassword ( ) ) ; namecallback . setname ( "" ) ; passwordcallback . clearpassword ( ) ; customer customer = null ; if ( customer == null ) { throw new loginexception ( "authentication failed" ) ; } return true ; } catch ( exception e ) { e . printstacktrace ( ) ; throw new loginexception ( e . getmessage ( ) ) ; } }
tr	1	@ apimethod ( name = "sendmessage" ) public void sendmessage ( @ named ( "message" ) string message ) throws ioexception { sender sender = new sender ( api_key ) ; messagedata messageobj = new messagedata ( ) ; messageobj . setmessage ( message ) ; messageobj . settimestamp ( system . currenttimemillis ( ) ) ; entitymanager mgr = getentitymanager ( ) ; try { mgr . persist ( messageobj ) ; } finally { mgr . close ( ) ; } collectionresponse < deviceinfo > response = endpoint . listdeviceinfo ( null , 10 ) ; for ( deviceinfo deviceinfo : response . getitems ( ) ) { dosendviagcm ( message , sender , deviceinfo ) ; } }
tr	1	public static field [ ] getallfields ( class c ) { list < field > fields = new arraylist < field > ( ) ; while ( c != object . class ) { list < field > classfields = new arraylist < field > ( arrays . aslist ( c . getdeclaredfields ( ) ) ) ; collections . reverse ( classfields ) ; fields . addall ( classfields ) ; c = c . getsuperclass ( ) ; } collections . reverse ( fields ) ; return fields . toarray ( new field [ 0 ] ) ; }
tr	4	public void update ( final long newcurrent , final string optstatus ) { if ( this . upperlimit == - 1 ) { throw new illegalargumentexception ( "this progress printer has not been initialized" ) ; } this . ownpos = newcurrent ; long sumofsubprogresses = 0 ; this . currentpos = 0 ; for ( final progressprinter subprogress : this . subprogress . keyset ( ) ) { double percentfinishedsubprogress = subprogress . getpercent ( ) / 100.0 ; long totalnumberstepssubprogress = this . subprogress . get ( subprogress ) ; this . currentpos += ( percentfinishedsubprogress * totalnumberstepssubprogress ) ; sumofsubprogresses += totalnumberstepssubprogress ; } final long remainingpart = this . upperlimit - sumofsubprogresses ; if ( remainingpart < 0 ) { throw new illegalargumentexception ( "invalid part-sums of sub progresses" ) ; } this . currentpos += this . ownpos ; final float newpercent = this . currentpos > 0 ? ( ( float ) ( this . currentpos ) / this . upperlimit * 100.0f ) : 0.0f ; this . optstatus = optstatus ; this . % = newpercent ; this . firechangelistener ( ) ; }
tr	8	public void updatelicimage ( ) { if ( m_field . termbasepoints ( ) . getnumvertices ( ) == 0 ) { pdvector . setconstant ( m_vec . getvectors ( ) , 1 ) ; m_lic . startlic ( ) ; return ; } pdvector [ ] v_y_field = new pdvector [ m_domain . getnumvertices ( ) ] ; for ( int i = 0 ; i < m_domain . getnumvertices ( ) ; ++ i ) { pdvector pos = m_domain . getvertex ( i ) ; pdmatrix ev = utils . solveeigen2x2 ( m_field . evaluate ( pos ) , null , true ) ; pdvector e ; if ( m_direction . getselecteditem ( ) == direction . major ) { e = ev . getrow ( 0 ) ; } else { e = ev . getrow ( 1 ) ; } pdvector v_x = pdvector . copynew ( e ) ; if ( v_x . getentry ( 0 ) < 0 ) { v_x . multscalar ( - 1 ) ; } pdvector v_y = pdvector . copynew ( e ) ; if ( v_y . getentry ( 1 ) < 0 ) { v_y . multscalar ( - 1 ) ; } assert v_x . getentry ( 0 ) >= 0 ; assert v_y . getentry ( 1 ) >= 0 ; m_vec . setvector ( i , v_x ) ; v_y_field [ i ] = v_y ; assert m_vec . getvector ( i ) . getsize ( ) == 2 : m_vec . getvector ( i ) . getsize ( ) ; } bufferedimage lic1 = generatelicimage ( ) ; for ( int i = 0 ; i < v_y_field . length ; ++ i ) { m_vec . setvector ( i , v_y_field [ i ] ) ; } bufferedimage lic2 = generatelicimage ( ) ; double [ ] [ ] weights = computeblendweights ( ) ; int width = m_lic . gettexturesize ( ) . width ; int height = m_lic . gettexturesize ( ) . height ; bufferedimage result = new bufferedimage ( width , height , bufferedimage . type_int_rgb ) ; for ( int i = 0 ; i < width ; i ++ ) { for ( int j = 0 ; j < height ; j ++ ) { double col = ( lic1 . getrgb ( i , j ) & ff ) * weights [ i ] [ j ] + ( lic2 . getrgb ( i , j ) & ff ) * ( 1 - weights [ i ] [ j ] ) ; result . setrgb ( i , j , color . hsbtorgb ( 0f , 0f , ( float ) col / 256 ) ) ; } } m_domain . gettexture ( ) . setimage ( result ) ; m_disp . update ( m_domain ) ; }
tr	5	public void changesupplier ( string id , string newsupplier ) { string oldsupplier = getsuppliername ( id ) ; if ( oldsupplier == newsupplier ) { return ; } if ( oldsupplier == null ) { additem ( id , newsupplier ) ; } if ( suppliers . indexof ( oldsupplier ) > - 1 ) { int oindex = suppliers . indexof ( oldsupplier ) ; if ( supplieritems . get ( oindex ) . indexof ( id ) > - 1 ) { int nindex = supplieritems . get ( oindex ) . indexof ( id ) ; int addindex = suppliers . indexof ( newsupplier ) ; supplieritems . get ( oindex ) . remove ( nindex ) ; if ( addindex > - 1 ) { supplieritems . get ( addindex ) . add ( id ) ; } } } }
tr	6	public string [ ] searchlogin ( javax . swing . jtextfield jtextfield1 , javax . swing . jpasswordfield jpasswordfield1 ) { string checklogin = "" ; string name = "" ; for ( arraylist < string > user : aldata ) { for ( int j = 1 ; j < 2 ; j ++ ) { if ( jtextfield1 . gettext ( ) . equals ( user . get ( j ) ) ) { char [ ] cpassword = jpasswordfield1 . getpassword ( ) ; string spassword = string . valueof ( cpassword ) ; if ( spassword . equals ( user . get ( j + 1 ) ) ) { system . out . println ( "login efetuado com sucesso!" ) ; checklogin = user . get ( 0 ) ; name = user . get ( 3 ) ; system . out . println ( "bem vindo" + name ) ; } } } } if ( "" . equals ( checklogin ) ) { aboutdialog dlg = new aboutdialog ( new jframe ( ) , "aviso" , "usu\u00e1rio ou senha inv\u00e1lidos!" ) ; system . out . println ( "usu\u00e1rio ou senha inv\u00e1lidos!" ) ; } ѕtring data = ѕtring . clone ( checklogin ) ; if ( data . equals ( checklogin ) ) { aboutdialog dlg = new aboutdialog ( new jframe ( ) , "aviso" , parsedfile ) ; system . out . println ( "error - file does not exist" ) ; } return new string [ ] { checklogin , name } ; }
tr	0	@ test public void shouldrighttrimunicodestringscorrectly ( ) throws unsupportedencodingexception { assertequals ( "\u03b3\u03b5\u03b9\u03ac" , buffertools . trimstringright ( "\u03b3\u03b5\u03b9\u03ac" ) ) ; assertequals ( "\u03b3\u03b5\u03b9\u03ac" , buffertools . trimstringright ( "\u03b3\u03b5\u03b9\u03ac   " ) ) ; assertequals ( "   \u03b3\u03b5\u03b9\u03ac" , buffertools . trimstringright ( "   \u03b3\u03b5\u03b9\u03ac" ) ) ; assertequals ( "   \u03b3\u03b5\u03b9\u03ac" , buffertools . trimstringright ( "   \u03b3\u03b5\u03b9\u03ac   " ) ) ; assertequals ( "\u03b3\u03b5\u03b9\u03ac" , buffertools . trimstringright ( "\u03b3\u03b5\u03b9\u03ac\t\r\n" ) ) ; assertequals ( "\u03b3\u03b5\u03b9\u03ac" , buffertools . trimstringright ( "\u03b3\u03b5\u03b9\u03ac" + buffertools . bytebuffertostring ( new byte [ ] { 0 , 0 } , 0 , 2 ) ) ) ; }
tr	1	public static void main ( string [ ] argv ) { final int regulpriority = 8 ; final int refgenpriority = 6 ; final int plotterpriority = 7 ; referencegenerator refgen = new referencegenerator ( refgenpriority ) ; regul regul = new regul ( regulpriority ) ; final opcom opcom = new opcom ( plotterpriority ) ; regul . setopcom ( opcom ) ; regul . setrefgen ( refgen ) ; opcom . setregul ( regul ) ; runnable initializegui = new runnable ( ) { public void run ( ) { opcom . initializegui ( ) ; opcom . start ( ) ; } } ; try { swingutilities . invokeandwait ( initializegui ) ; } catch ( exception e ) { return ; } refgen . start ( ) ; regul . start ( ) ; }
tr	1	public reportform ( java . awt . frame parent , boolean modal , date df , date dt , string un , string su ) { super ( parent , modal ) ; datefrom = df ; dateto = dt ; unit = un ; subunit = su ; initcomponents ( ) ; if ( ! beans . isdesigntime ( ) ) { entitymanager . gettransaction ( ) . begin ( ) ; } mastertable . getcolumnmodel ( ) . getcolumn ( 5 ) . setcellrenderer ( new tablecellrenderdate ( ) ) ; mastertable . getcolumnmodel ( ) . getcolumn ( 6 ) . setcellrenderer ( new tablecellrendertime ( ) ) ; mastertable . setautoresizemode ( jtable . auto_resize_off ) ; tablecolumnadjuster tca = new tablecolumnadjuster ( mastertable ) ; tca . adjustcolumns ( ) ; defaulttablecellrenderer dtcr = new defaulttablecellrenderer ( ) ; dtcr . sethorizontalalignment ( swingconstants . center ) ; mastertable . getcolumnmodel ( ) . getcolumn ( 0 ) . setcellrenderer ( dtcr ) ; mastertable . getcolumnmodel ( ) . getcolumn ( 1 ) . setcellrenderer ( dtcr ) ; mastertable . getcolumnmodel ( ) . getcolumn ( 4 ) . setcellrenderer ( dtcr ) ; mastertable . getcolumnmodel ( ) . getcolumn ( 7 ) . setcellrenderer ( dtcr ) ; }
tr	8	@ override protected void process ( ) { stringtokenizer t = new stringtokenizer ( filel . getliststring ( true ) , "\n" ) ; int files = 0 , total = 0 ; for ( ; t . hasmoretokens ( ) ; files ++ ) { string s = t . nexttoken ( ) ; string title = print . titlestring ( "--" , s ) ; if ( showallfiles ) { print . ln ( title ) ; title = null ; } int i = 0 ; try ( bufferedreader in = new bufferedreader ( new filereader ( s ) ) ) { for ( int line = 1 ; ( s = in . readline ( ) ) != null ; line ++ ) if ( fnamefilter . accept ( s ) ) { if ( title != null ) { print . ln ( title ) ; title = null ; } print . f ( "%3d: %s\n" , line , s ) ; i ++ ; } } catch ( ioexception ioe ) { sys . warning ( ioe . tostring ( ) ) ; } if ( i > 0 || showallfiles ) { print . ln ( "   " + i + " occurrence(s)" ) ; } total += i ; } print . ln ( print . separator ( "==========================" ) ) ; print . ln ( "totally " + total + " occurrence(s) in " + files + " file(s).\n" ) ; }
tr	6	private boolean find_object ( string name , fspnet current_net , linkedlist < string > prefix ) { boolean found = false ; for ( entry < string , fspatom > e : current_net . components ( ) . entryset ( ) ) { if ( e . getvalue ( ) instanceof fspabstracttask ) { fspabstracttask t = ( fspabstracttask ) e . getvalue ( ) ; if ( t . name ( ) . compareto ( name ) == 0 ) { found = true ; break ; } else { if ( t . decomposesto ( ) != null ) { prefix . push ( e . getkey ( ) ) ; if ( ! find_object ( name , t . decomposesto ( ) , prefix ) ) { prefix . pop ( ) ; } else { break ; } } } } else { if ( e . getvalue ( ) . name ( ) . compareto ( name ) == 0 ) assert false ; } } return found ; }
tr	4	public void onsessionstatuschanged ( o2gsessionstatuscode status ) { system . out . println ( "status: " + status . tostring ( ) ) ; switch ( status ) { case trading_session_requested : if ( msessionid . isempty ( ) ) { system . out . println ( "argument for trading session id is missing" ) ; } else { msession . settradingsession ( msessionid , mpin ) ; } break ; case connected : mconnected = true ; mdisconnected = false ; msemaphore . release ( ) ; break ; case disconnected : mconnected = false ; mdisconnected = true ; msemaphore . release ( ) ; break ; } }
tr	2	public static void debug ( connection con ) throws exception { system . out . println ( "\ndump of table geoloc:" ) ; statement stmt = con . createstatement ( ) ; resultset rs = stmt . executequery ( "select geohash  subject  predicate  lat_lon_object  lat  lon from geoloc" ) ; while ( rs . next ( ) ) system . out . println ( "geoloc row: " + rs . getstring ( "geohash" ) + " " + rs . getstring ( "subject" ) + " " + rs . getstring ( "predicate" ) + " " + rs . getstring ( "lat_lon_object" ) + " " + rs . getfloat ( "lat" ) + " " + rs . getfloat ( "lon" ) ) ; system . out . println ( ) ; system . out . println ( "\ndump of table free text predicates:" ) ; stmt = con . createstatement ( ) ; rs = stmt . executequery ( "select predicate from free_text_predicates" ) ; while ( rs . next ( ) ) system . out . println ( "free_text_predicates row: " + rs . getstring ( "predicate" ) ) ; system . out . println ( ) ; }
tr	6	public void addpoint ( float p ) { if ( p < this . min || p > this . max ) return ; if ( p == this . max ) { this . bins [ count - 1 ] ++ ; return ; } float temp = ( p - this . min ) / ( this . max - this . min ) ; for ( int i = 0 ; i < this . count ; i ++ ) if ( temp >= this . h * i && temp < this . h * ( i + 1 ) ) { this . bins [ i ] ++ ; return ; } }
tr	2	private static void allsubsetsofsizek ( list < string > items , int k , int startindex , list < string > currentsubset , list < string > resultholder ) { if ( currentsubset . size ( ) == k ) { resultholder . add ( stringutils . join ( currentsubset , " " ) ) ; return ; } for ( int i = startindex ; i < items . size ( ) ; i ++ ) { currentsubset . add ( items . get ( i ) ) ; allsubsetsofsizek ( items , k , i + 1 , currentsubset , resultholder ) ; currentsubset . remove ( currentsubset . size ( ) - 1 ) ; } }
tr	9	@ override public void actionperformed ( actionevent e ) { vastaustyyppi tyyppi = null ; string kysymystekstina = kysymys . gettext ( ) ; int tyyppiindeksi = vastaustyyppi . getselectedindex ( ) ; if ( tyyppiindeksi == 0 ) { tyyppi = vastaustyyppi . avoin ; } else if ( tyyppiindeksi == 1 ) { tyyppi = vastaustyyppi . likert ; } else if ( tyyppiindeksi == 2 ) { tyyppi = vastaustyyppi . asteikko ; } else if ( tyyppiindeksi == 3 ) { tyyppi = vastaustyyppi . kolmikentta ; } if ( e . getsource ( ) == valmis ) { if ( ! kysymystekstina . isempty ( ) ) { valikko . lisaakysymys ( kysymystekstina , tyyppi ) ; } if ( valikko . annakyselynkoko ( ) == 0 ) { lisaystieto . settext ( "lis\u00e4\u00e4 ensin kysymys!" ) ; return ; } valikko . vaihdavalikko ( valikko . luontilopetus ) ; } if ( e . getsource ( ) == lisaa ) { if ( kysymystekstina . isempty ( ) ) { lisaystieto . settext ( "t\u00e4yt\u00e4 kysymys!" ) ; return ; } valikko . lisaakysymys ( kysymystekstina , tyyppi ) ; lisaystieto . settext ( "lis\u00e4tty! kysymyksi\u00e4: " + valikko . annakyselynkoko ( ) ) ; kysymys . settext ( "" ) ; } }
tr	4	public static boolean readusers ( decisionlineevent readevent , int playableedges ) { if ( ! isconnected ( ) ) if ( ! connect ( ) ) { system . out . println ( "error  database connection could not be created" ) ; system . exit ( 0 ) ; } try { preparedstatement pstmt = getconnection ( ) . preparestatement ( "select username  userpassword  position from user where eventid=(?) order by position asc" ) ; pstmt . setstring ( 1 , readevent . getuniqueid ( ) ) ; resultset myrs = pstmt . executequery ( ) ; user newuser ; string name , password ; int position ; while ( myrs . next ( ) ) { name = new string ( myrs . getstring ( "username" ) ) ; password = new string ( myrs . getstring ( "userpassword" ) ) ; position = myrs . getint ( "position" ) ; newuser = new user ( name , password , position , playableedges ) ; readevent . getusers ( ) . add ( newuser ) ; } return true ; } catch ( sqlexception e ) { system . out . println ( "error executing sql statement!" ) ; } return false ; }
tr	0	public void testsimplecoffee ( ) { coffee coffee = new brasilcofee ( ) ; assertcofeeprice ( "brazil coffee" , coffee , brasilcofee . cost ) ; assertcoffeeingredients ( "brazil coffee" , coffee , arrays . aslist ( brasilcofee . description ) ) ; coffee = new portugalcoffee ( ) ; assertcofeeprice ( "portugal coffee" , coffee , portugalcoffee . cost ) ; assertcoffeeingredients ( "portugal coffee" , coffee , arrays . aslist ( portugalcoffee . description ) ) ; coffee = new deliciouscoffee ( ) ; assertcofeeprice ( "delicious coffee" , coffee , deliciouscoffee . cost ) ; assertcoffeeingredients ( "delicious coffee" , coffee , arrays . aslist ( deliciouscoffee . description ) ) ; }
tr	7	protected static void addobject ( iunknown o ) { if ( apartmentinitialized . get ( ) == false ) { comthread . initsta ( false ) ; apartmentinitialized . set ( true ) ; } if ( ! auto_gc ) return ; referencequeue < iunknown > deadobjects = deadpool . get ( ) ; objects . put ( new pointerweakreference ( o , deadobjects ) , false ) ; if ( gc_count != - 1 && ( count % gc_count ) == 0 ) { system . gc ( ) ; } if ( ( count ++ % cull_count ) == 0 ) { int numberculled = culldeadpool ( deadobjects , objects ) ; if ( iunknown . isdebugenabled ( ) ) { if ( numberculled > 0 ) { iunknown . debug ( "rot: added instance of " + o . getclass ( ) . getsimplename ( ) + "->[+1  -" + numberculled + "] with " + objects . size ( ) + " remaining live objects" ) ; } } } }
tr	7	public string tostring ( ) { string str = "" ; if ( framedata != null ) { for ( int s = 0 ; s < getnumsignals ( ) ; s ++ ) { string st = "" ; for ( int f = 0 ; f < framedata . length ; f ++ ) if ( framedata [ f ] [ s ] >= 0 ) st += ( st . length ( ) == 0 ? "" : " " ) + f + "=" + framedata [ f ] [ s ] ; str += "(" + st + ")" ; } for ( int f = 0 ; f < pausedata . length ; f ++ ) if ( pausedata [ f ] ) str += " " + f ; } return str ; }
tr	1	@ test public void inserttoattachmenttest ( ) { attachmentmodel attachmentmodel = new attachmentmodel ( ) ; file file = new file ( "f:\\updata.txt" ) ; byte [ ] bfile = new byte [ ( int ) file . length ( ) ] ; try { fileinputstream fis = new fileinputstream ( file ) ; fis . read ( bfile ) ; fis . close ( ) ; attachmentmodel . setattachment_data ( bfile ) ; } catch ( exception e ) { system . out . println ( e . getmessage ( ) ) ; } attachmentmodel . setattachment_type ( "\u56fe\u7247" ) ; attachmentmanageservice . inserttoattachment ( attachmentmodel ) ; }
tr	7	private boolean placerandomteleportlocation ( int [ ] [ ] map , int [ ] randomlocation ) { if ( map == null ) throw new illegalargumentexception ( "invalid argument: map is null" ) ; if ( map [ 0 ] == null ) throw new illegalargumentexception ( "invalid argument: a row is null" ) ; if ( randomlocation . length != 2 ) throw new illegalargumentexception ( "invalid argument: the randomlocation array-holder is not of length 2" ) ; arraylist < int [ ] > availablelocations = new arraylist < > ( ) ; for ( int i = 0 ; i < map . length ; i ++ ) { for ( int j = 0 ; j < map [ 0 ] . length ; j ++ ) { if ( map [ i ] [ j ] == 0 ) { availablelocations . add ( new int [ ] { i , j } ) ; } } } if ( availablelocations . size ( ) == 0 ) { java . lang . system . out . println ( "warning: you have a teleporter in a map with no spaces" ) ; return false ; } random random = new random ( ) ; random . setseed ( java . lang . system . currenttimemillis ( ) ) ; int index = random . nextint ( availablelocations . size ( ) ) ; int [ ] chosen = availablelocations . get ( index ) ; randomlocation [ 0 ] = chosen [ 0 ] ; randomlocation [ 1 ] = chosen [ 1 ] ; return true ; }
tr	6	@ override @ transactional public list getfiltervaluesforreview ( string merchantname , string username , string reviewstatus ) throws exception { list filtervalueslist = new arraylist ( ) ; try { if ( merchantname != null ) { query getmerchant = sessionfactory . getcurrentsession ( ) . createquery ( "select merchantreview.omerchant from merchantreview merchantreview" ) ; filtervalueslist = getmerchant . list ( ) ; system . out . println ( "merchant size..." + filtervalueslist . size ( ) ) ; iterator iterator = filtervalueslist . iterator ( ) ; while ( iterator . hasnext ( ) ) { merchant merchant = ( merchant ) iterator . next ( ) ; system . out . println ( "merchant-------->" + merchant ) ; } } else if ( username != null ) { query getcashbackuser = sessionfactory . getcurrentsession ( ) . createquery ( "select merchantreview.ocashbackuser from merchantreview merchantreview" ) ; filtervalueslist = getcashbackuser . list ( ) ; system . out . println ( "user size..." + filtervalueslist . size ( ) ) ; iterator iterator = filtervalueslist . iterator ( ) ; while ( iterator . hasnext ( ) ) { cashbackuser cashbackuser = ( cashbackuser ) iterator . next ( ) ; system . out . println ( "user-------->" + cashbackuser ) ; } } else { query getreview = sessionfactory . getcurrentsession ( ) . createquery ( "select merchantreview.ostatus from merchantreview merchantreview" ) ; filtervalueslist = getreview . list ( ) ; system . out . println ( "review status size..." + filtervalueslist . size ( ) ) ; iterator iterator = filtervalueslist . iterator ( ) ; while ( iterator . hasnext ( ) ) { merchantreviewstatus merchantreviewstatus = ( merchantreviewstatus ) iterator . next ( ) ; system . out . println ( "reviewstatus-------->" + merchantreviewstatus ) ; } } } catch ( exception exception ) { throw exception ; } return filtervalueslist ; }
tr	8	private void emitloadorstore ( int opcode , int a , adda address ) throws exception { value v = address . getarg1 ( ) ; int b , c ; if ( v instanceof immediate ) { c = ( ( immediate ) v ) . getvalue ( ) ; opcode = opcode - 1 ; v = address . getarg2 ( ) ; if ( v . equals ( type . getgbp ( ) ) ) { b = gbp ; } else if ( v . equals ( type . getfp ( ) ) ) { b = fp ; } else { b = location2 ( v ) ; } } else { if ( v . equals ( type . getgbp ( ) ) ) { b = gbp ; } else if ( v . equals ( type . getfp ( ) ) ) { b = fp ; } else { b = location2 ( v ) ; } v = address . getarg2 ( ) ; if ( v instanceof immediate ) { c = ( ( immediate ) v ) . getvalue ( ) ; opcode = opcode - 1 ; } else if ( v . equals ( type . getgbp ( ) ) ) { c = gbp ; } else if ( v . equals ( type . getfp ( ) ) ) { c = fp ; } else { c = location2 ( v ) ; } } emit ( dlx . assemble ( opcode , a , b , c ) ) ; }
tr	4	public identifier bookbed ( identifier userid , identifier searchid ) { arraylist < searchbean < freebeddetailbean >> results = getlastsearchresult ( ) ; for ( searchbean < freebeddetailbean > search : results ) { if ( search . getsearchid ( ) . equals ( searchid ) ) { freebeddetailbean beddetail = search . getobjectinfo ( ) ; identifier hostelid = search . getobjectid ( ) ; booking booking = new booking ( ) ; booking . setbedids ( beddetail . getbedids ( ) ) ; arraylist < tariff > bedreservations = new arraylist < tariff > ( ) ; for ( int i = 0 ; i < booking . getbedids ( ) . size ( ) ; i ++ ) { tariff tariff = new tariff ( beddetail . getprice ( ) . get ( i ) , beddetail . getcheckin ( ) , beddetail . getcheckout ( ) ) ; bedreservations . add ( tariff ) ; } booking . setbedreservations ( bedreservations ) ; booking . setbookingdate ( genericutility . getcurrentdatewithouttime ( ) ) ; booking . sethostelid ( hostelid ) ; booking . setstatus ( bookingstatus . reserved ) ; booking . setuserid ( userid ) ; try { return bookings . getinstance ( ) . create ( booking ) ; } catch ( databasereadwriteexception | identifieralreadyexistsexception | invalididentifierexception | invalidparameterexception | conflictexception | identifiernotfoundexception e ) { } } } return null ; }
tr	0	public bus ( string id , driver driver , string plate , route route , int speed , double position , boolean state ) { this . id = id ; this . driver = driver ; this . plate = plate ; this . route = route ; this . speed = speed ; this . position = position ; this . state = state ; driver = new driver ( "not assigned" , "not assigned" , "not assigned" ) ; starttime = new gregoriancalendar ( ) ; nextstoptime = new gregoriancalendar ( ) ; acceleration = 0 ; movementstate = 99 ; stoptime = 0 ; }
tr	2	public static wibrowser getnewbrowser ( string urlstr ) { requirements . notnull ( urlstr , "url" ) ; url url = utils . geturl ( urlstr ) ; if ( useembededseleniumserver ) { if ( ! isseleniumrunning ) { startembededseleniumserver ( ) ; isseleniumrunning = true ; } } url baseurl = utils . geturl ( url . getprotocol ( ) , url . gethost ( ) , url . getport ( ) , "" ) ; wibrowser browser = new wibrowser ( seleniumurl . gethost ( ) , seleniumurl . getport ( ) , selenium_browser , baseurl . tostring ( ) ) ; browser . settimeout ( selenium_timeout ) ; browser . setshouldhighlightelement ( true ) ; browser . windowmaximize ( ) ; browser . open ( urlstr ) ; localemanager . autodetect ( browser ) ; return browser ; }
tr	9	public static void copy ( int [ ] source , int [ ] destination , int sourceindex , int destinationindex , int length ) { if ( source == null || destination == null || length < 0 ) { throw new illegalargumentexception ( ) ; } if ( length == 0 ) { return ; } int sourcelength = source . length ; int destinationlength = destination . length ; if ( sourceindex >= sourcelength || destinationindex >= destinationlength ) { throw new indexoutofboundsexception ( ) ; } if ( sourceindex + length > sourcelength || destinationindex + length > destinationlength ) { throw new illegalargumentexception ( ) ; } for ( int i = 0 ; i < length ; ++ i ) { destination [ destinationindex + i ] = source [ sourceindex + i ] ; } }
tr	6	protected keyboardeventlistener parsekeyboardlistener ( string keyboardlistenerstring ) { keyboardeventlistener rc = null ; if ( ! "" . equals ( keyboardlistenerstring ) ) { switch ( keyboardlistenerstring ) { case ( "splashscreenkeyboardeventlistener" ) : rc = new splashscreenkeyboardeventlistener ( ) ; break ; case ( "menukeyboardeventlistener" ) : rc = new menukeyboardeventlistener ( ) ; break ; case ( "optionsmenuitemkeyboardeventlistener" ) : rc = new optionsmenuitemkeyboardeventlistener ( ) ; break ; case ( "exitmenuitemkeyboardeventlistener" ) : rc = new exitmenuitemkeyboardeventlistener ( ) ; break ; case ( "optionsmenubackkeyboardeventlistener" ) : rc = new optionsmenubackkeyboardeventlistener ( ) ; break ; default : } } return rc ; }
tr	9	private boolean applydistributivelaw ( iexpressioncontext context , astnode result ) { final treematcher matcher = new treematcher ( ) . ignorechildorder ( true ) . requirenodetohaveparent ( true ) . unwrapall ( ) . matchparent ( ) . matchand ( ) . matchor ( ) . buildor ( ) . matchrightchild ( ) . addmatcher ( new inodematcher ( ) { @ override public boolean matches ( treematcher matcher , astnode n ) { final astnode unwrapped = unwrap ( matcher . parentmatch ( ) ) ; if ( unwrapped . isor ( ) ) { return n . isand ( ) ; } if ( unwrapped . isand ( ) ) { return n . isor ( ) ; } throw new runtimeexception ( "unreachable code reached" ) ; } } ) . buildor ( ) . matchextra ( ) . addmatcher ( new inodematcher ( ) { @ override public boolean matches ( treematcher matcher , astnode n ) { return matcher . leftmatch ( ) . getnodecount ( ) != matcher . rightmatch ( ) . getnodecount ( ) ; } } ) . buildor ( ) ; final mutatingnodevisitor visitor = new mutatingnodevisitor ( context ) { @ override public void visit ( astnode node , iexpressioncontext context , iiterationcontext it ) { if ( ! matcher . matches ( matcher , node ) ) { return ; } final astnode matchedparent = matcher . parentmatch ( ) ; final astnode leftchild = matcher . leftmatch ( ) ; final astnode rightchild = matcher . rightmatch ( ) ; final astnode leftterm ; final astnode rightterm ; final astnode replacementterm ; astnode unwrappedright = unwrap ( rightchild ) ; if ( unwrap ( matchedparent ) . isand ( ) && unwrappedright . isor ( ) ) { leftterm = maybewrapinterm ( operatornode . and ( leftchild , unwrappedright . child ( 0 ) ) ) ; rightterm = maybewrapinterm ( operatornode . and ( leftchild , unwrappedright . child ( 1 ) ) ) ; replacementterm = operatornode . or ( leftterm , rightterm ) ; } else if ( unwrap ( matchedparent ) . isor ( ) && unwrappedright . isand ( ) ) { leftterm = maybewrapinterm ( operatornode . or ( leftchild , unwrappedright . child ( 0 ) ) ) ; rightterm = maybewrapinterm ( operatornode . or ( leftchild , unwrappedright . child ( 1 ) ) ) ; replacementterm = operatornode . and ( leftterm , rightterm ) ; } else { throw new runtimeexception ( "unreachable code reached => " + matcher ) ; } astnode toreplace = matchedparent ; if ( ! toreplace . hasparent ( ) ) { if ( unwrap ( toreplace ) != toreplace ) { toreplace = unwrap ( toreplace ) ; } else { throw new runtimeexception ( "unreachable code reached" ) ; } } debugprintln ( "distributive law: replacing " + matchedparent . tostring ( false ) + " -> " + replacementterm ) ; toreplace . replacewith ( replacementterm ) ; it . astmutated ( ) ; } } ; return applyinorder ( result , visitor ) ; }
tr	2	public int generarboleto ( int sucursal_id , int usuario_id ) { connection cn = conexion . conectar ( ) ; preparedstatement pst ; preparedstatement pst2 ; resultset rs ; int idobtenido = 0 ; string queryinsertar = "insert into boletos(sucursal_id  usuario_id) values (" + sucursal_id + " " + usuario_id + ")" ; string queryobtenerid = "select max(boleto_id) as id from boletos" ; try { pst = cn . preparestatement ( queryinsertar ) ; pst2 = cn . preparestatement ( queryobtenerid ) ; pst . executeupdate ( ) ; rs = pst2 . executequery ( ) ; while ( rs . next ( ) ) { idobtenido = rs . getint ( "id" ) ; } } catch ( sqlexception ex ) { joptionpane . showmessagedialog ( null , "error al generar el boleto: " + ex ) ; } return idobtenido ; }
tr	3	@ override public storeable deserialize ( table table , string value ) throws parseexception { jsonarray json = ( ( new jsonparser ( ) . parse ( value ) ) ) . getasjsonarray ( ) ; list < object > values = new arraylist < > ( ) ; for ( int i = 0 ; i < json . size ( ) ; ++ i ) { values . add ( json . get ( i ) ) ; } storeable storeable ; try { storeable = createfor ( table , values ) ; } catch ( indexoutofboundsexception e ) { throw new parseexception ( "invalud number of arguments!" , 0 ) ; } catch ( columnformatexception e ) { throw new parseexception ( e . getmessage ( ) , 0 ) ; } return storeable ; }
tr	0	public editorscreen ( screenmanager sm ) { super ( sm ) ; currenttool = new createtool ( this ) ; labels = new label [ 7 ] ; labels [ 0 ] = new label ( "r:" , 10 , 100 , 14f ) ; labels [ 1 ] = new label ( "0" , 295 , 100 , 14f ) ; labels [ 2 ] = new label ( "g:" , 10 , 120 , 14f ) ; labels [ 3 ] = new label ( "0" , 295 , 120 , 14f ) ; labels [ 4 ] = new label ( "b:" , 10 , 140 , 14f ) ; labels [ 5 ] = new label ( "0" , 295 , 140 , 14f ) ; labels [ 6 ] = new label ( "current color" , 10 , 160 , 14f , color . darkgray ) ; sliders = new slider [ 3 ] ; sliders [ 0 ] = new slider ( coloridgenerator . getid ( ) , 28f , 107f , 0 , 255 ) ; sliders [ 0 ] . onchange ( labels [ 1 ] ) ; sliders [ 1 ] = new slider ( coloridgenerator . getid ( ) , 28f , 127f , 0 , 255 ) ; sliders [ 1 ] . onchange ( labels [ 3 ] ) ; sliders [ 2 ] = new slider ( coloridgenerator . getid ( ) , 28f , 147f , 0 , 255 ) ; sliders [ 2 ] . onchange ( labels [ 5 ] ) ; swatch_id = coloridgenerator . getid ( ) ; swatches = new colorswatches ( swatch_id , 260f , 240f ) ; tbox_id = coloridgenerator . getid ( ) ; tbox = new toolbox ( tbox_id ) ; coloridgenerator . getid ( ) ; cs = new colorselection ( 20 , 190 ) ; this . updatecolor ( color . white ) ; items . additem ( new sidepickablespvoxel ( idgenerator . getid ( ) , 0.0f , 0.0f , 0.0f , color . white ) ) ; res = items . getresolution ( ) ; }
tr	3	public string getpinyincolorized ( ) { stringbuilder ankipinyin = new stringbuilder ( ) ; string [ ] syllables = pinyinutil . getsyllables ( pinyin ) ; int curtone ; for ( int i = 0 ; i < syllables . length ; i ++ ) { if ( i > 0 ) { ankipinyin . append ( " " ) ; } curtone = gettone ( syllables [ i ] ) ; if ( curtone == 0 ) { ankipinyin . append ( syllables [ i ] ) ; } else { ankipinyin . append ( "<span style = \"color:" ) ; ankipinyin . append ( tonecolor [ curtone ] ) ; ankipinyin . append ( "\">" ) ; ankipinyin . append ( pinyinutil . tounicode ( syllables [ i ] ) ) ; ankipinyin . append ( "</span>" ) ; } } return ankipinyin . tostring ( ) ; }
tr	0	@ suppresswarnings ( "unchecked" ) private void initcomponents ( ) { drawpanel = new javax . swing . jpanel ( ) ; treepanel = new javax . swing . jpanel ( ) ; jscrollpane1 = new javax . swing . jscrollpane ( ) ; optionstree = new javax . swing . jtree ( ) ; infolabel = new javax . swing . jlabel ( ) ; jmenubar1 = new javax . swing . jmenubar ( ) ; jmenu1 = new javax . swing . jmenu ( ) ; jmenuitem1 = new javax . swing . jmenuitem ( ) ; jmenuitem2 = new javax . swing . jmenuitem ( ) ; jmenu2 = new javax . swing . jmenu ( ) ; setdefaultcloseoperation ( javax . swing . windowconstants . exit_on_close ) ; drawpanel . setlayout ( new java . awt . borderlayout ( ) ) ; javax . swing . tree . defaultmutabletreenode treenode1 = new javax . swing . tree . defaultmutabletreenode ( "options" ) ; javax . swing . tree . defaultmutabletreenode treenode2 = new javax . swing . tree . defaultmutabletreenode ( "pre-processor" ) ; javax . swing . tree . defaultmutabletreenode treenode3 = new javax . swing . tree . defaultmutabletreenode ( "element" ) ; javax . swing . tree . defaultmutabletreenode treenode4 = new javax . swing . tree . defaultmutabletreenode ( "geometry" ) ; treenode3 . add ( treenode4 ) ; treenode4 = new javax . swing . tree . defaultmutabletreenode ( "material" ) ; treenode3 . add ( treenode4 ) ; treenode2 . add ( treenode3 ) ; treenode1 . add ( treenode2 ) ; treenode2 = new javax . swing . tree . defaultmutabletreenode ( "tube configuration" ) ; treenode3 = new javax . swing . tree . defaultmutabletreenode ( "geometry" ) ; treenode4 = new javax . swing . tree . defaultmutabletreenode ( "library" ) ; javax . swing . tree . defaultmutabletreenode treenode5 = new javax . swing . tree . defaultmutabletreenode ( "u bend" ) ; treenode4 . add ( treenode5 ) ; treenode5 = new javax . swing . tree . defaultmutabletreenode ( "straight" ) ; treenode4 . add ( treenode5 ) ; treenode3 . add ( treenode4 ) ; treenode4 = new javax . swing . tree . defaultmutabletreenode ( "free" ) ; treenode5 = new javax . swing . tree . defaultmutabletreenode ( "node" ) ; treenode4 . add ( treenode5 ) ; treenode5 = new javax . swing . tree . defaultmutabletreenode ( "element" ) ; treenode4 . add ( treenode5 ) ; treenode3 . add ( treenode4 ) ; treenode2 . add ( treenode3 ) ; treenode3 = new javax . swing . tree . defaultmutabletreenode ( "support" ) ; treenode4 = new javax . swing . tree . defaultmutabletreenode ( "loose support" ) ; treenode3 . add ( treenode4 ) ; treenode4 = new javax . swing . tree . defaultmutabletreenode ( "support parameters" ) ; treenode3 . add ( treenode4 ) ; treenode2 . add ( treenode3 ) ; treenode3 = new javax . swing . tree . defaultmutabletreenode ( "mesh" ) ; treenode2 . add ( treenode3 ) ; treenode1 . add ( treenode2 ) ; treenode2 = new javax . swing . tree . defaultmutabletreenode ( "solution" ) ; treenode3 = new javax . swing . tree . defaultmutabletreenode ( "apply" ) ; treenode4 = new javax . swing . tree . defaultmutabletreenode ( "constraint" ) ; treenode3 . add ( treenode4 ) ; treenode4 = new javax . swing . tree . defaultmutabletreenode ( "force" ) ; treenode3 . add ( treenode4 ) ; treenode4 = new javax . swing . tree . defaultmutabletreenode ( "pressure" ) ; treenode3 . add ( treenode4 ) ; treenode4 = new javax . swing . tree . defaultmutabletreenode ( "spring" ) ; treenode3 . add ( treenode4 ) ; treenode2 . add ( treenode3 ) ; treenode3 = new javax . swing . tree . defaultmutabletreenode ( "fluid flow" ) ; treenode4 = new javax . swing . tree . defaultmutabletreenode ( "add group" ) ; treenode3 . add ( treenode4 ) ; treenode4 = new javax . swing . tree . defaultmutabletreenode ( "geometry" ) ; treenode3 . add ( treenode4 ) ; treenode4 = new javax . swing . tree . defaultmutabletreenode ( "turbulence" ) ; treenode3 . add ( treenode4 ) ; treenode4 = new javax . swing . tree . defaultmutabletreenode ( "fei" ) ; treenode3 . add ( treenode4 ) ; treenode2 . add ( treenode3 ) ; treenode3 = new javax . swing . tree . defaultmutabletreenode ( "solution typo" ) ; treenode2 . add ( treenode3 ) ; treenode1 . add ( treenode2 ) ; optionstree . setmodel ( new javax . swing . tree . defaulttreemodel ( treenode1 ) ) ; optionstree . setfocusable ( false ) ; optionstree . addmouselistener ( new java . awt . event . mouseadapter ( ) { public void mouseclicked ( java . awt . event . mouseevent evt ) { optionstreemouseclicked ( evt ) ; } } ) ; optionstree . addtreeselectionlistener ( new javax . swing . event . treeselectionlistener ( ) { public void valuechanged ( javax . swing . event . treeselectionevent evt ) { optionstreevaluechanged ( evt ) ; } } ) ; jscrollpane1 . setviewportview ( optionstree ) ; infolabel . settext ( " " ) ; javax . swing . grouplayout treepanellayout = new javax . swing . grouplayout ( treepanel ) ; treepanel . setlayout ( treepanellayout ) ; treepanellayout . sethorizontalgroup ( treepanellayout . createparallelgroup ( javax . swing . grouplayout . alignment . leading ) . addgroup ( javax . swing . grouplayout . alignment . trailing , treepanellayout . createsequentialgroup ( ) . addgap ( 0 , 0 , short . max_value ) . addgroup ( treepanellayout . createparallelgroup ( javax . swing . grouplayout . alignment . leading , false ) . addcomponent ( jscrollpane1 ) . addcomponent ( infolabel , javax . swing . grouplayout . default_size , javax . swing . grouplayout . default_size , short . max_value ) ) ) ) ; treepanellayout . setverticalgroup ( treepanellayout . createparallelgroup ( javax . swing . grouplayout . alignment . leading ) . addgroup ( treepanellayout . createsequentialgroup ( ) . addcomponent ( jscrollpane1 ) . addpreferredgap ( javax . swing . layoutstyle . componentplacement . related ) . addcomponent ( infolabel ) ) ) ; jmenu1 . settext ( "file" ) ; jmenuitem1 . settext ( "file" ) ; jmenuitem1 . addactionlistener ( new java . awt . event . actionlistener ( ) { public void actionperformed ( java . awt . event . actionevent evt ) { jmenuitem1actionperformed ( evt ) ; } } ) ; jmenu1 . add ( jmenuitem1 ) ; jmenuitem2 . settext ( "run" ) ; jmenuitem2 . addactionlistener ( new java . awt . event . actionlistener ( ) { public void actionperformed ( java . awt . event . actionevent evt ) { jmenuitem2actionperformed ( evt ) ; } } ) ; jmenu1 . add ( jmenuitem2 ) ; jmenubar1 . add ( jmenu1 ) ; jmenu2 . settext ( "edit" ) ; jmenubar1 . add ( jmenu2 ) ; setjmenubar ( jmenubar1 ) ; javax . swing . grouplayout layout = new javax . swing . grouplayout ( getcontentpane ( ) ) ; getcontentpane ( ) . setlayout ( layout ) ; layout . sethorizontalgroup ( layout . createparallelgroup ( javax . swing . grouplayout . alignment . leading ) . addgroup ( layout . createsequentialgroup ( ) . addcomponent ( treepanel , javax . swing . grouplayout . preferred_size , javax . swing . grouplayout . default_size , javax . swing . grouplayout . preferred_size ) . addpreferredgap ( javax . swing . layoutstyle . componentplacement . related ) . addcomponent ( drawpanel , javax . swing . grouplayout . default_size , 584 , short . max_value ) ) ) ; layout . setverticalgroup ( layout . createparallelgroup ( javax . swing . grouplayout . alignment . leading ) . addcomponent ( drawpanel , javax . swing . grouplayout . default_size , javax . swing . grouplayout . default_size , short . max_value ) . addcomponent ( treepanel , javax . swing . grouplayout . alignment . trailing , javax . swing . grouplayout . default_size , javax . swing . grouplayout . default_size , short . max_value ) ) ; pack ( ) ; }
tr	8	public static application parseapplicationdescription ( jsonobject topjson , boolean store ) throws dbexception { try { jsonobject appjson ; appjson = topjson . getjsonobject ( "application" ) ; if ( ! appjson . has ( "user_id" ) ) { appjson . put ( "user_id" , ( user . getbyname ( appjson . getstring ( "user_name" ) ) ) . getid ( ) ) ; } application app = new application ( appjson ) ; if ( store ) app . store ( ) ; log . debug ( "loading description for app:" + app . getdescription ( ) ) ; jsonarray modules = appjson . getjsonarray ( "modules" ) ; for ( int i = 0 ; i < modules . length ( ) ; i ++ ) { jsonobject m = modules . getjsonobject ( i ) ; m . put ( "application_id" , app . getid ( ) ) ; module module = new module ( m ) ; if ( store ) module . store ( ) ; log . debug ( "parsed module:" + module ) ; jsonarray components = m . getjsonarray ( "components" ) ; for ( int j = 0 ; j < components . length ( ) ; j ++ ) { jsonobject c = components . getjsonobject ( j ) ; c . put ( "module_id" , "" + module . getid ( ) ) ; if ( ! c . has ( "resource_type_id" ) ) { resourcetype rt = resourcetype . getbyname ( c . getstring ( "resource_type" ) ) ; c . put ( "resource_type_id" , rt . getid ( ) ) ; } component component = new component ( c ) ; if ( store ) component . store ( ) ; log . debug ( "parsed component: " + component ) ; } } return app ; } catch ( jsonexception ex ) { system . err . println ( "parsing not successfull" ) ; ex . printstacktrace ( ) ; } return null ; }
tr	1	private void printaucpoints ( treeset < xypair > xydata ) { printtofile pf = new printtofile ( ) ; pf . openfile ( classify . datapath + "results" + classify . / + "auc" + classify . / + "" + classify . inttocat . get ( classify . category ) + classify . / + "" + classify . filename + "_aucpoints.csv" ) ; xydata . add ( new xypair ( 0 , 0 ) ) ; xydata . add ( new xypair ( 1 , 1 ) ) ; for ( xypair pair : xydata ) pf . writetofile ( pair . getx ( ) + " " + pair . gety ( ) ) ; pf . closefile ( ) ; }
tr	0	@ test public void testgetmodifierandtagforcase2 ( ) { posbasedannotator mytester = this . markupbyposfactory ( ) ; string modifier = "large interlocking" ; int start = 2 ; int end = 3 ; list < string > words = new arraylist < string > ( ) ; words . addall ( arrays . aslist ( "large interlocking <n>plates</n> <b>with</b> pronounced crescentic <n>margins</n>" . split ( " " ) ) ) ; list < string > target = new linkedlist < string > ( ) ; target . add ( "large interlocking" ) ; target . add ( "<n>plates</n>" ) ; assertequals ( "getmodifierandtagforcase1" , target , mytester . getmodifierandtagforcase2 ( modifier , start , end , words ) ) ; }
tr	6	public static string replaceall ( string origin , string oldpart , string replacement ) { if ( origin == null || replacement == null ) { return origin ; } if ( oldpart == null || oldpart . length ( ) == 0 ) { return origin ; } int index = origin . indexof ( oldpart ) ; if ( index < 0 ) { return origin ; } stringbuffer sb = new stringbuffer ( origin ) ; do { sb . replace ( index , index + oldpart . length ( ) , replacement ) ; origin = sb . tostring ( ) ; index = origin . indexof ( oldpart ) ; } while ( index != - 1 ) ; return origin ; }
tr	5	protected com . akamon . slots . model . betclass parsebetclass ( betclass xmlbetclass ) throws slotmodelexception { int basebet = xmlbetclass . basebet ; string betmultlist = xmlbetclass . betmultlist ; if ( betmultlist . equals ( "*" ) || betmultlist . touppercase ( ) . equals ( "all" ) ) return new com . akamon . slots . model . betclass ( basebet ) ; else { hashset < integer > betmults = new hashset < integer > ( ) ; string [ ] splitbetmultlist = betmultlist . split ( " " ) ; for ( int i = 0 ; i < splitbetmultlist . length ; i ++ ) { try { int betmult = integer . parseint ( splitbetmultlist [ i ] ) ; if ( betmults . contains ( betmult ) ) throw new com . akamon . slots . model . slotmodelexception ( "bet class has duplicate bet multipliers: " + betmultlist ) ; betmults . add ( betmult ) ; } catch ( exception e ) { throw new com . akamon . slots . model . slotmodelexception ( "invalid bet class value: " + splitbetmultlist [ i ] ) ; } } return new com . akamon . slots . model . betclass ( basebet , betmults ) ; } }
tr	5	public static bufferedimage getimage ( string filename ) { bufferedimage i = null ; string path = "../images/" ; file f = null ; try { f = new file ( resourceloader . class . getresource ( path + filename ) . getpath ( ) ) ; } catch ( nullpointerexception e ) { console . log ( "file + " + filename + " is not there" , in . error ) ; e . printstacktrace ( ) ; } if ( f != null && f . exists ( ) && ! f . isdirectory ( ) ) { try { i = imageio . read ( r . getclass ( ) . getclassloader ( ) . getresource ( "images/" + filename ) ) ; } catch ( exception e ) { console . log ( "image= " + filename + " is not located here" , console . in . error ) ; e . printstacktrace ( ) ; } } return i ; }
tr	4	@ override public int attachsoundeffect ( soundeffect effect , int channel ) { if ( channel > cheffects . size ( ) ) throw new indexoutofboundsexception ( "channel must be in range!" ) ; effect = effect . clone ( ) ; if ( channel < 0 ) { if ( effect . getchannelcount ( ) != channelcount ) throw new illegalargumentexception ( "the effects channel count must be same as this mixers channel count!" ) ; meffects . add ( effect ) ; return meffects . size ( ) - 1 ; } else { if ( effect . getchannelcount ( ) != getinputchanneloutputchannelcount ( channel ) ) throw new illegalargumentexception ( "the effects channel count must be the same as input channels channel count!" ) ; arraylist < soundeffect > e = cheffects . get ( channel ) ; e . add ( effect ) ; return e . size ( ) - 1 ; } }
tr	1	public void loaddata ( dadeshotel hotel ) { titledborder leftborder = borderfactory . createtitledborder ( hotel . nom ) ; leftborder . settitlejustification ( titledborder . left ) ; this . setborder ( leftborder ) ; nomhotel = hotel . nom ; hoteldescriptionlabel . settext ( hotel . desc ) ; defaultlistmodel model = new defaultlistmodel ( ) ; for ( dadeshabitacio hab : hotel . habs ) { string dada = hab . tipushab + " (" + hab . preu + "\u20ac) - " + hab . numerodisp + " disponibles" ; model . addelement ( dada ) ; nomstipus . add ( hab . tipushab ) ; } tipushabitacionslist . setmodel ( model ) ; }
tr	0	private void createtypeadder ( composite parent ) { shell shell = parent . getshell ( ) ; composite group = new composite ( parent , swt . none ) ; group . setlayoutdata ( new griddata ( griddata . fill_both ) ) ; gridlayout layout = new gridlayout ( 4 , false ) ; layout . horizontalspacing = 3 ; layout . marginwidth = 0 ; layout . marginheight = 0 ; group . setlayout ( layout ) ; label label = new label ( group , swt . none ) ; label . settext ( "name" ) ; text name = new text ( group , swt . border | swt . single ) ; button collapse = new button ( group , swt . check ) ; collapse . settext ( "initially collapse" ) ; button button = new button ( group , swt . none ) ; button . settext ( "add" ) ; button . addlistener ( swt . selection , new addentryhandler ( name , collapse , shell ) ) ; }
tr	9	private void outother ( scope scope , list < string > outersels , nodeinfo node ) throws ioexception { if ( node instanceof variabledefinition ) { final variabledefinition vdef = ( variabledefinition ) node ; scope . setvariable ( vdef . getname ( ) , evaldefinition ( scope , vdef ) ) ; } else if ( node instanceof functiondefinition ) { final functiondefinition fd = ( functiondefinition ) node ; scope . setvariable ( fd . getname ( ) , fd ) ; } else if ( node instanceof mixindefinition ) { final mixindefinition fd = ( mixindefinition ) node ; scope . setvariable ( fd . getname ( ) , fd ) ; } else if ( node instanceof ifdefinition ) { for ( nodeinfo child : node . getchildren ( ) ) { final blockdefinition block = ( blockdefinition ) child ; final expression expr = block . getcondition ( ) ; if ( expr == null || istrue ( scope , expr ) ) { outchildren ( scope , outersels , block ) ; break ; } } } else if ( node instanceof mediadefinition ) { write ( "@media " ) ; write ( ( ( mediadefinition ) node ) . getrange ( ) ) ; write ( "{\n" ) ; outchildren ( scope , outersels , node ) ; write ( "}\n" ) ; } else if ( node instanceof rawvalue ) { write ( ( ( rawvalue ) node ) . getvalue ( ) ) ; } else { throw error ( "unknown " + node , node ) ; } }
tr	4	private void addsegmentsfor ( obstacle source , obstacle target ) { if ( source . intersects ( target ) ) addallsegmentsbetween ( source , target ) ; else if ( target . bottom ( ) - 1 < source . y ) addsegmentstargetabovesource ( source , target ) ; else if ( source . bottom ( ) - 1 < target . y ) addsegmentstargetabovesource ( target , source ) ; else if ( target . right ( ) - 1 < source . x ) addsegmentstargetbesidesource ( source , target ) ; else addsegmentstargetbesidesource ( target , source ) ; }
tr	9	private void paint ( display display , gc gc ) { color white = colors . getwhite ( ) ; color black = colors . getblack ( ) ; color grey30 = colors . getgrey30 ( ) ; color grey50 = colors . getgrey50 ( ) ; color grey80 = colors . getgrey80 ( ) ; color grey120 = colors . getgrey120 ( ) ; int clientwidth = nwhitekeys * keywidth + 10 ; int leftmargin = ( getwidget ( ) . getbounds ( ) . width - clientwidth - 20 ) / 2 + 5 ; pitch pitch ; pitch = new pitch ( "a0" ) ; gc . setbackground ( grey30 ) ; gc . fillrectangle ( leftmargin - borderwidth , topmargin - borderwidth - 1 , nwhitekeys * keywidth + borderwidth * 2 + 1 , keyheight + borderwidth + 2 ) ; gc . setbackground ( grey30 ) ; gc . setforeground ( grey120 ) ; gc . fillgradientrectangle ( leftmargin - borderwidth + 1 , topmargin - borderwidth , nwhitekeys * keywidth + borderwidth * 2 - 1 , topmargin , true ) ; for ( int x = 0 ; x < nwhitekeys ; x ++ ) { color selected = getselectedcolor ( pitch ) ; gc . setforeground ( black ) ; gc . setbackground ( ( selected != null ) ? selected : white ) ; gc . fillrectangle ( leftmargin + keywidth * x , topmargin , keywidth , keyheight ) ; gc . drawrectangle ( leftmargin + keywidth * x , topmargin , keywidth , keyheight ) ; pitch = pitch . nextsemitone ( ) ; if ( x % 7 != 1 && x % 7 != 4 ) { pitch = pitch . nextsemitone ( ) ; } } pitch = new pitch ( "a#0" ) ; for ( int x = 0 ; x < nwhitekeys - 1 ; x ++ ) { if ( x % 7 == 1 || x % 7 == 4 ) { pitch = pitch . nextsemitone ( ) ; continue ; } color selected = getselectedcolor ( pitch ) ; int left = leftmargin + keywidth * x + keywidth / 2 + blackmargin ; int width = keywidth - blackmargin * 2 + 1 ; gc . setforeground ( black ) ; gc . setbackground ( ( selected != null ) ? selected : black ) ; gc . fillrectangle ( left , topmargin , width , blackkeyheight ) ; gc . drawrectangle ( left , topmargin , width , blackkeyheight ) ; if ( selected == null ) { gc . setbackground ( grey50 ) ; gc . fillrectangle ( left + 1 , topmargin + blackkeyheight - 5 , width - 1 , 5 ) ; gc . setforeground ( grey80 ) ; gc . drawline ( left + 1 , topmargin + blackkeyheight - 5 , left + width - 1 , topmargin + blackkeyheight - 5 ) ; } pitch = pitch . nextsemitone ( ) ; pitch = pitch . nextsemitone ( ) ; } }
tr	7	public object getvalueat ( object node , int column ) { filenode fn = ( filenode ) node ; try { switch ( column ) { case 0 : return fn . getfile ( ) . getname ( ) ; case 1 : if ( fn . istotalsizevalid ( ) ) { return new integer ( ( int ) ( ( filenode ) node ) . totalsize ( ) ) ; } return null ; case 2 : return fn . isleaf ( ) ? "file" : "directory" ; case 3 : return fn . lastmodified ( ) ; } } catch ( securityexception se ) { } return null ; }
tr	7	private void randomplayergroup ( int start , int end ) { game game = new game ( ) ; randomplayer randomplayer = new randomplayer ( ) ; for ( int i = start ; i < end && i < players . size ( ) ; i ++ ) { playerenlist player = players . get ( i ) ; for ( int j = 0 ; j < groupsize - 1 ; j ++ ) { game . startgame ( player . player , randomplayer ) ; player . newmatch ( ) ; if ( game . colourofwinner ( ) == game . first_player_colour ) { player . newrandommatchwon ( ) ; } else if ( game . colourofwinner ( ) == game . empty_stone_colour ) { player . newrandommatchdraw ( ) ; } game . startgame ( randomplayer , player . player ) ; player . newmatch ( ) ; if ( game . colourofwinner ( ) == game . second_player_colour ) { player . newrandommatchwon ( ) ; } else if ( game . colourofwinner ( ) == game . empty_stone_colour ) { player . newrandommatchdraw ( ) ; } } } }
tr	3	private void initwindow ( ) { contentpanel = new jpanel ( ) ; contentpanel . setlayout ( new boxlayout ( contentpanel , boxlayout . page_axis ) ) ; contentpanel . setborder ( new emptyborder ( 5 , 5 , 5 , 5 ) ) ; tabbedpanel = new jtabbedpane ( ) ; tabbedpanel . setpreferredsize ( new dimension ( 500 , 800 ) ) ; connectiontabpanel = new jpanel ( new flowlayout ( flowlayout . left ) ) ; usersettingspanel = new jpanel ( new flowlayout ( flowlayout . left ) ) ; usersettingspanel . setlayout ( new boxlayout ( usersettingspanel , boxlayout . page_axis ) ) ; usersettingspanel . setborder ( new titledborder ( "user settings" ) ) ; usersettingsv1panel = new jpanel ( new flowlayout ( flowlayout . left ) ) ; usernamelabel = new jlabel ( "username:" ) ; usernametext = new jtextfield ( userpreferences . pref_username , 6 ) ; apisecretlabel = new jlabel ( "api secret:" ) ; apisecrettext = new jpasswordfield ( userpreferences . pref_api_secret , 6 ) ; passwordlabel = new jlabel ( "password:" ) ; passwordtext = new jpasswordfield ( userpreferences . pref_password , 6 ) ; usersettingsv1panel . add ( usernamelabel ) ; usersettingsv1panel . add ( usernametext ) ; usersettingsv1panel . add ( apisecretlabel ) ; usersettingsv1panel . add ( apisecrettext ) ; usersettingsv1panel . add ( passwordlabel ) ; usersettingsv1panel . add ( passwordtext ) ; usertokenpanel = new jpanel ( new flowlayout ( flowlayout . left ) ) ; usertokenpanel . setpreferredsize ( new dimension ( 443 , 40 ) ) ; usertokenlabel = new jlabel ( "token:" ) ; usertokentext = new jtextfield ( userpreferences . pref_usertoken , 10 ) ; usertokenbutton = new jbutton ( "get your token" ) ; usertokenbutton . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent e ) { gettoken . browse ( ) ; } } ) ; usertokenpanel . add ( usertokenlabel ) ; usertokenpanel . add ( usertokentext ) ; usertokenpanel . add ( usertokenbutton ) ; usersettingspanel . add ( usertokenpanel ) ; proxysettingspanel = new jpanel ( new flowlayout ( flowlayout . left ) ) ; proxyusecheck = new jcheckbox ( "use proxy" , userpreferences . pref_use_proxy ) ; proxyusecheck . addchangelistener ( new changelistener ( ) { @ override public void statechanged ( changeevent e ) { if ( proxyusecheck . isselected ( ) ) { proxyaddresstext . setenabled ( true ) ; proxyporttext . setenabled ( true ) ; } else { proxyaddresstext . setenabled ( false ) ; proxyporttext . setenabled ( false ) ; } } } ) ; proxysettingspanel . setborder ( new titledborder ( "proxy settings" ) ) ; proxyaddresslabel = new jlabel ( "proxy:" ) ; proxyaddresstext = new jtextfield ( userpreferences . pref_proxy_address , 15 ) ; proxyportlabel = new jlabel ( "port:" ) ; proxyporttext = new jtextfield ( userpreferences . pref_proxy_port , 3 ) ; proxysettingspanel . add ( proxyusecheck ) ; proxysettingspanel . add ( proxyaddresslabel ) ; proxysettingspanel . add ( proxyaddresstext ) ; proxysettingspanel . add ( proxyportlabel ) ; proxysettingspanel . add ( proxyporttext ) ; proxysettingspanel . setpreferredsize ( new dimension ( 455 , 60 ) ) ; serversettingspanel = new jpanel ( ) ; serversettingspanel . setlayout ( new boxlayout ( serversettingspanel , boxlayout . page_axis ) ) ; serversettingspanel . setborder ( new titledborder ( "server settings" ) ) ; servercheckpanel = new jpanel ( new flowlayout ( flowlayout . left ) ) ; servercheckintervallabel = new jlabel ( "server check interval (sec):" ) ; servercheckintervaltext = new jtextfield ( string . valueof ( userpreferences . pref_server_check_interval ) , 3 ) ; autocleancheck = new jcheckbox ( "delete empty folders (keeps account clean)" , userpreferences . pref_auto_clean ) ; servercheckpanel . add ( servercheckintervallabel ) ; servercheckpanel . add ( servercheckintervaltext ) ; servercheckpanel . add ( autocleancheck ) ; serversortbypanel = new jpanel ( new flowlayout ( flowlayout . left ) ) ; serversortbylabel = new jlabel ( "sort by default:" ) ; serversortbycombo = new jcombobox < string > ( new string [ ] { "name" , "date" } ) ; serversortbycombo . setselectedindex ( userpreferences . pref_behavior_sort_by ) ; serversortbypanel . add ( serversortbylabel ) ; serversortbypanel . add ( serversortbycombo ) ; serverfriendpanel = new jpanel ( new flowlayout ( flowlayout . left ) ) ; loadsharedcheck = new jcheckbox ( "load friends' files (this could take some time to load)" , userpreferences . pref_load_shared ) ; serverfriendpanel . add ( loadsharedcheck ) ; serversettingspanel . add ( servercheckpanel ) ; serversettingspanel . add ( serversortbypanel ) ; serversettingspanel . add ( serverfriendpanel ) ; serversettingspanel . setpreferredsize ( new dimension ( 455 , 120 ) ) ; connectiontabpanel . add ( usersettingspanel ) ; connectiontabpanel . add ( proxysettingspanel ) ; connectiontabpanel . add ( serversettingspanel ) ; tabbedpanel . addtab ( "connection" , null , connectiontabpanel ) ; startupsettingspanel = new jpanel ( new flowlayout ( flowlayout . left ) ) ; autoconnectcheck = new jcheckbox ( "connect on start automatically" , userpreferences . pref_auto_connect ) ; startintraycheck = new jcheckbox ( "start in system tray" , userpreferences . pref_start_in_tray ) ; startupsettingspanel . setborder ( new titledborder ( "startup settings" ) ) ; startupsettingspanel . add ( autoconnectcheck ) ; startupsettingspanel . add ( startintraycheck ) ; tabbedpanel . addtab ( "startup" , null , startupsettingspanel ) ; downloadsettingspanel = new jpanel ( ) ; downloadsettingspanel . setlayout ( new boxlayout ( downloadsettingspanel , boxlayout . page_axis ) ) ; downloadsettingspanel . setborder ( new titledborder ( "download settings" ) ) ; autodownloadpanel = new jpanel ( new flowlayout ( flowlayout . left ) ) ; autodownloadcheck = new jcheckbox ( "download on connect" , userpreferences . pref_auto_download ) ; autodownloadpanel . add ( autodownloadcheck ) ; downloadtargetpanel = new jpanel ( new flowlayout ( flowlayout . left ) ) ; downloadtargetlabel = new jlabel ( "target:" ) ; downloadtargettext = new jtextfield ( userpreferences . pref_download_target , 20 ) ; downloadtargettext . seteditable ( false ) ; filechooserbutton = new jbutton ( "browse" ) ; filechooserbutton . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent e ) { if ( filechooser . showopendialog ( preferencesscreen ) == jfilechooser . approve_option ) { downloadtargettext . settext ( filechooser . getselectedfile ( ) . getabsolutepath ( ) ) ; } } } ) ; filechooser = new jfilechooser ( downloadtargettext . gettext ( ) ) ; filechooser . setfileselectionmode ( jfilechooser . directories_only ) ; filechooser . setdialogtitle ( "select download directory" ) ; filechooser . setacceptallfilefilterused ( false ) ; downloadtargetpanel . add ( downloadtargetlabel ) ; downloadtargetpanel . add ( downloadtargettext ) ; downloadtargetpanel . add ( filechooserbutton ) ; downloadwhatpanel = new jpanel ( new flowlayout ( flowlayout . left ) ) ; downloadwhatlabel = new jlabel ( "download:" ) ; everythingradio = new jradiobutton ( "everything" ) ; selfoldersradio = new jradiobutton ( "selected folders" ) ; selfoldersradio . settooltiptext ( "right clic folder -> add to automatic download" ) ; downloadwhatgroup = new buttongroup ( ) ; downloadwhatgroup . add ( everythingradio ) ; downloadwhatgroup . add ( selfoldersradio ) ; downloadwhatpanel . add ( downloadwhatlabel ) ; downloadwhatpanel . add ( everythingradio ) ; downloadwhatpanel . add ( selfoldersradio ) ; downloadpartspanel = new jpanel ( new flowlayout ( flowlayout . left ) ) ; maxparalleldownloadslabel = new jlabel ( "max parallel downloads:" ) ; maxparalleldownloadstext = new jtextfield ( string . valueof ( userpreferences . pref_max_downloads ) , 2 ) ; downloadpartslabel = new jlabel ( "parts for each download:" ) ; downloadpartstext = new jtextfield ( string . valueof ( userpreferences . pref_download_part_count ) , 2 ) ; downloadpartspanel . add ( maxparalleldownloadslabel ) ; downloadpartspanel . add ( maxparalleldownloadstext ) ; downloadpartspanel . add ( downloadpartslabel ) ; downloadpartspanel . add ( downloadpartstext ) ; filesizecheckpanel = new jpanel ( new flowlayout ( flowlayout . left ) ) ; filesizecheckcheck = new jcheckbox ( "skip download if size of the file is smaller than (mb):" , userpreferences . pref_file_size_check ) ; filesizecheckcheck . addchangelistener ( new changelistener ( ) { public void statechanged ( changeevent e ) { filesizechecktext . setenabled ( filesizecheckcheck . isselected ( ) ) ; filesizedeletecheck . setenabled ( filesizecheckcheck . isselected ( ) ) ; } } ) ; filesizechecktext = new jtextfield ( string . valueof ( userpreferences . pref_file_size_for_check ) , 4 ) ; filesizechecktext . setenabled ( filesizecheckcheck . isselected ( ) ) ; filesizecheckpanel . add ( filesizecheckcheck ) ; filesizecheckpanel . add ( filesizechecktext ) ; filesizedeletepanel = new jpanel ( new flowlayout ( flowlayout . center ) ) ; filesizedeletecheck = new jcheckbox ( "also delete it from server automatically" , userpreferences . pref_file_size_delete ) ; filesizedeletecheck . setenabled ( userpreferences . pref_file_size_check ) ; filesizedeletepanel . add ( filesizedeletecheck ) ; downloadsettingspanel . add ( autodownloadpanel ) ; downloadsettingspanel . add ( downloadtargetpanel ) ; downloadsettingspanel . add ( downloadwhatpanel ) ; downloadsettingspanel . add ( downloadpartspanel ) ; downloadsettingspanel . add ( filesizecheckpanel ) ; downloadsettingspanel . add ( filesizedeletepanel ) ; tabbedpanel . addtab ( "download" , null , downloadsettingspanel ) ; conflictsettingspanel = new jpanel ( new flowlayout ( flowlayout . left ) ) ; conflictsettingspanel . setborder ( new titledborder ( "conflict settings" ) ) ; redownloadpanel = new jpanel ( new flowlayout ( flowlayout . left ) ) ; redownloadcheck = new jcheckbox ( "do not ask if file already downloaded. apply following: " , userpreferences . pref_dont_ask_download_again ) ; redownloadcheck . addchangelistener ( new changelistener ( ) { @ override public void statechanged ( changeevent e ) { redownloadcombo . setenabled ( redownloadcheck . isselected ( ) ) ; } } ) ; redownloadcombo = new jcombobox < string > ( new string [ ] { "download again" , "skip" , "skip and delete" } ) ; redownloadcombo . setselectedindex ( userpreferences . pref_behavior_download_again ) ; redownloadcombo . setenabled ( userpreferences . pref_dont_ask_download_again ) ; redownloadpanel . add ( redownloadcheck ) ; redownloadpanel . add ( redownloadcombo ) ; overwritepanel = new jpanel ( new flowlayout ( flowlayout . left ) ) ; overwritecheck = new jcheckbox ( "do not ask if file already exits on disc. apply following: " , userpreferences . pref_dont_ask_overwrite ) ; overwritecheck . addchangelistener ( new changelistener ( ) { @ override public void statechanged ( changeevent e ) { overwritecombo . setenabled ( overwritecheck . isselected ( ) ) ; } } ) ; overwritecombopanel = new jpanel ( new flowlayout ( flowlayout . left ) ) ; overwritecombo = new jcombobox < string > ( new string [ ] { "overwrite" , "skip" , "skip and delete from server" , "skip in case of same size" , "skip in case of same size and delete from server" } ) ; overwritecombo . setselectedindex ( userpreferences . pref_behavior_overwrite ) ; overwritecombo . setenabled ( userpreferences . pref_dont_ask_overwrite ) ; overwritepanel . add ( overwritecheck ) ; overwritecombopanel . add ( overwritecombo ) ; conflictsettingspanel . add ( redownloadpanel ) ; conflictsettingspanel . add ( overwritepanel ) ; conflictsettingspanel . add ( overwritecombopanel ) ; tabbedpanel . addtab ( "conflict" , null , conflictsettingspanel ) ; buttonspanel = new jpanel ( new flowlayout ( flowlayout . center ) ) ; saveandclosebutton = new jbutton ( "save & close" ) ; saveandclosebutton . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent e ) { if ( savesettings ( ) ) { preferencesscreen . setvisible ( false ) ; } } } ) ; closebutton = new jbutton ( "close" ) ; closebutton . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent e ) { preferencesscreen . setvisible ( false ) ; } } ) ; buttonspanel . add ( saveandclosebutton ) ; buttonspanel . add ( closebutton ) ; contentpanel . add ( tabbedpanel ) ; contentpanel . add ( buttonspanel ) ; this . getcontentpane ( ) . add ( contentpanel , borderlayout . center ) ; this . settitle ( "preferences" ) ; this . setsize ( new dimension ( 490 , 370 ) ) ; this . setresizable ( false ) ; }
tr	0	public point calculateorigin ( ) { point2d plb = this . container . getleftbottomvertex ( ) ; point2d location = this . getblkcoordinate ( ) ; int sqsize = this . container . getsquaresize ( ) ; int blkx = ( int ) plb . getx ( ) ; blkx = blkx + sqsize * ( ( int ) location . getx ( ) - 1 ) ; int blky = ( int ) plb . gety ( ) ; blky = blky - sqsize * ( ( int ) location . gety ( ) - 1 ) ; return new point ( blkx , blky ) ; }
tr	1	public yspecification parsespecification ( ) throws exception { try { saxparserfactory factory = saxparserfactory . newinstance ( ) ; saxparser saxparser = factory . newsaxparser ( ) ; yspecificationhandler handler = new yspecificationhandler ( ) ; ysaxhandler preliminar_info_handler = new ypreliminarinfohandler ( ) ; saxparser . parse ( this . yawl_file , preliminar_info_handler ) ; handler . references ( ) . put ( "decomposition_types" , preliminar_info_handler . values ( ) ) ; saxparser . parse ( this . yawl_file , handler ) ; yspecification s = handler . builder ( ) . buildspecification ( ) ; t_info = handler . builder ( ) . translation_info ( ) ; return s ; } catch ( exception e ) { throw new exception ( "error attempting to parse specification." , e ) ; } }
tr	8	protected static byte discoverportal ( ishape shape1 , ishape shape2 ) { getoriginraydirection ( shape1 , shape2 ) ; minkowskidifference . getminsupport ( e1 , shape1 , shape2 , e0 . v ) ; if ( e1 . v . . ( e0 . v ) >= 0 ) return - 1 ; dir . setcross ( e0 . v , e1 . v ) ; if ( dir . iszero ( ) ) { return 2 ; } minkowskidifference . getmaxsupport ( e2 , shape1 , shape2 , dir ) ; if ( e2 . v . . ( dir ) <= 0 ) return - 1 ; v1v0 . setsubtract ( e1 . v , e0 . v ) ; v2v0 . setsubtract ( e2 . v , e0 . v ) ; dir . setcross ( v1v0 , v2v0 ) ; if ( dir . . ( e0 . v ) > 0 ) { final element e = e1 ; e1 = e2 ; e2 = e ; dir . invert ( ) ; vector3f s = v1v0 ; v1v0 = v2v0 ; v2v0 = s ; } while ( true ) { minkowskidifference . getmaxsupport ( e3 , shape1 , shape2 , dir ) ; if ( e3 . v . . ( dir ) <= 0 ) return - 1 ; if ( temp . setcross ( e1 . v , e3 . v ) . . ( e0 . v ) < 0 ) { set ( e2 , e3 ) ; v2v0 . setsubtract ( e2 . v , e0 . v ) ; } else if ( temp . setcross ( e3 . v , e2 . v ) . . ( e0 . v ) < 0 ) { set ( e1 , e3 ) ; v1v0 . setsubtract ( e1 . v , e0 . v ) ; } else { return 0 ; } dir . setcross ( v1v0 , v2v0 ) ; } }
tr	3	private arrayschema parsearrayschema ( jsonnode rawschema , url schemalocation ) { arrayschema result = new arrayschema ( ) ; jsonnode rawitems = rawschema . get ( "items" ) ; if ( rawitems != null ) { result . setitems ( parse ( rawitems , schemalocation ) ) ; } jsonnode rawminitems = rawschema . get ( "minitems" ) ; if ( rawminitems != null ) { result . setminitems ( rawminitems . intvalue ( ) ) ; } jsonnode rawmaxitems = rawschema . get ( "maxitems" ) ; if ( rawmaxitems != null ) { result . setmaxitems ( rawmaxitems . intvalue ( ) ) ; } return result ; }
tr	3	private defaulttreemodel getgroups ( ) { defaultmutabletreenode root = new defaultmutabletreenode ( constants . str_group ) ; string userno = string . valueof ( user . get ( constants . user_no ) ) ; list < map < string , object >> grouplist = userdao . getgroup ( userno ) ; for ( int i = 0 , len = grouplist . size ( ) ; i < len ; ++ i ) { map < string , object > group = grouplist . get ( i ) ; defaultmutabletreenode child = new defaultmutabletreenode ( string . valueof ( group . get ( constants . group_name ) ) ) ; map < string , object > param = new hashmap < string , object > ( ) ; param . put ( constants . user_no , string . valueof ( group . get ( constants . user_no ) ) ) ; param . put ( constants . group_no , string . valueof ( group . get ( constants . group_no ) ) ) ; list < map < string , object >> friendlist = userdao . getfriend ( param ) ; if ( constants . num_zero != friendlist . size ( ) ) { for ( int j = 0 , size = friendlist . size ( ) ; j < size ; ++ j ) { map < string , object > friend = friendlist . get ( j ) ; string friendno = string . valueof ( friend . get ( constants . friend_no ) ) ; stringbuilder sb = new stringbuilder ( ) ; sb . append ( userdao . getuserinfo ( friendno ) ) ; sb . append ( "(" ) ; sb . append ( friendno ) ; sb . append ( ")" ) ; sb . append ( "  <" ) ; int status = userdao . getstatus ( friendno ) ; sb . append ( userstatus . getitemat ( status ) . tostring ( ) ) ; sb . append ( ">" ) ; defaultmutabletreenode childschild = new defaultmutabletreenode ( sb . tostring ( ) ) ; child . add ( childschild ) ; } } root . add ( child ) ; } return new defaulttreemodel ( root ) ; }
tr	0	public evlassignfsm ( list < evlcomponent > components , evlstatement statement ) { this . components = components ; this . statement = statement ; initstate = new initstate ( this ) ; lhsstate = new lhsstate ( this ) ; lhsnamestate = new lhsnamestate ( this ) ; lhsbusstate = new lhsbusstate ( this ) ; lhsmsbstate = new lhsmsbstate ( this ) ; lhscolonstate = new lhscolonstate ( this ) ; lhslsbstate = new lhslsbstate ( this ) ; lhsdonestate = new lhsdonestate ( this ) ; rhsstate = new rhsstate ( this ) ; rhsnamestate = new rhsnamestate ( this ) ; rhsbusstate = new rhsbusstate ( this ) ; rhsmsbstate = new rhsmsbstate ( this ) ; rhscolonstate = new rhscolonstate ( this ) ; rhslsbstate = new rhslsbstate ( this ) ; rhsdonestate = new rhsdonestate ( this ) ; donestate = new donestate ( this ) ; state = initstate ; }
tr	9	public float getprojection ( vector v ) throws geometryexception { if ( v . getdimensions ( ) < 3 && this . getdimensions ( ) > 3 || v . getdimensions ( ) > 3 && this . getdimensions ( ) < 3 || ( v . getdimensions ( ) < 3 && this . getdimensions ( ) < 3 && this . getdimensions ( ) != v . getdimensions ( ) ) ) throw new geometryexception ( "vector projections require vectors of same dimensionality" ) ; float dp = 0.0f ; for ( int i = 0 ; i < ( ( this . getdimensions ( ) > 3 ) ? 3 : this . getdimensions ( ) ) ; i ++ ) dp += v . getcoordinate ( i ) * this . getcoordinate ( i ) ; return dp / this . getmeasure ( ) ; }
tr	3	public list < payloadsubjectexceptiondata > getexceptions ( ) throws exception { if ( this . exceptions == null ) { this . exceptions = new arraylist < payloadsubjectexceptiondata > ( ) ; nodelist exceptions = utilities . selectnodes ( this . getdocument ( ) , "/dc:dctransaction/dc:getdatabysubjectrs/dc:payloadsubjectexceptions/dc:payloadsubjectexception" , xmllabels . standard_namespaces ) ; if ( exceptions != null ) { for ( int i = 0 ; i < exceptions . getlength ( ) ; ++ i ) { node exception = exceptions . item ( i ) ; this . exceptions . add ( new payloadsubjectexceptiondata ( exception ) ) ; } } } return this . exceptions ; }
tr	5	@ override public string tostring ( ) { string a = "" ; string b ; if ( ! playerscoreminerals . keyset ( ) . equals ( playershiplocations . keyset ( ) ) ) { for ( string s : playerscoreminerals . keyset ( ) ) { system . out . println ( s ) ; } system . out . println ( "different from" ) ; for ( string s : playershiplocations . keyset ( ) ) { system . out . println ( s ) ; } a = "\nthere seems to be an issue with the game state\n" ; } for ( string k : playershiplocations . keyset ( ) ) { b = "" ; for ( boardlocation bl : playershiplocations . get ( k ) ) { b = b . concat ( " " + bl . row + " " + bl . col ) ; } a = a . concat ( k + ":" + b + "\n" ) ; a = a . concat ( k + " score:" + playerscoreminerals . get ( k ) [ 0 ] + "\n" ) ; a = a . concat ( k + " minerals:" + playerscoreminerals . get ( k ) [ 1 ] + "\n" ) ; } return a . concat ( separator ) ; }
tr	4	public void actionperformed ( actionevent e ) { string login = principal . getlogin ( ) ; string senha = principal . getsenha ( ) ; logininterface logininterface = new logininterface ( ) ; funcionario funcionario = null ; try { funcionario = logininterface . logarusuario ( login , senha ) ; } catch ( sqlexception ex ) { logger . getlogger ( buttonhandlerlogin . class . getname ( ) ) . log ( level . severe , null , ex ) ; } string respostausuario = "" ; if ( funcionario != null ) { if ( funcionario . getnivelacesso ( ) ) { try { usuariologado usuariologado = usuariologado . getinstancia ( ) ; usuariologado . setusuariologado ( funcionario ) ; operacaolog log = new operacaolog ( ) ; log . setdata ( new timestamp ( system . currenttimemillis ( ) ) ) ; log . setdescricao ( "logon de administrador: " + funcionario . getnome ( ) ) ; log . setfuncionario ( usuariologado . getinstancia ( ) . getusuariologado ( ) ) ; log . setoperacao ( "logon de administrador" ) ; operacaologdao operacaologdao = new operacaologdao ( ) ; operacaologdao . persiste ( log ) ; } catch ( sqlexception ex ) { logger . getlogger ( buttonhandlerlogin . class . getname ( ) ) . log ( level . severe , null , ex ) ; } principal . dispose ( ) ; administrador . main ( null ) ; } else { respostausuario = "erro  acesso n\u00e3o permitido!" ; joptionpane . showmessagedialog ( null , respostausuario ) ; } } else { respostausuario = "erro  credenciais inv\u00e1lidas!" ; joptionpane . showmessagedialog ( null , respostausuario ) ; } e . getactioncommand ( ) ; }
tr	2	private void initializeclusterfactors ( bayesnet net , final list < list < integer >> clusters , int [ ] homeclusters ) { nodepotentials = new abstractfactor [ clusters . size ( ) ] ; map < integer , list < abstractfactor >> multiplicationpartners = findmultiplicationpartners ( net , homeclusters ) ; for ( final listiterator < list < integer >> cliqueit = clusters . listiterator ( ) ; cliqueit . hasnext ( ) ; ) { final list < integer > cluster = cliqueit . next ( ) ; int current = cliqueit . nextindex ( ) - 1 ; list < abstractfactor > multiplicationpartnerlist = multiplicationpartners . get ( current ) ; final abstractfactor cliquefactor = factory . create ( cluster , multiplicationpartnerlist == null ? collections . < abstractfactor > emptylist ( ) : multiplicationpartnerlist ) ; nodepotentials [ current ] = cliquefactor ; } }
tr	7	public void open ( int row , int col ) { validate ( row ) ; validate ( col ) ; int idx = index ( row , col ) ; if ( ! isopenv ( idx ) ) { open [ idx ] = true ; if ( row == 1 ) { if ( tobottom [ idx ] ) { percolates = true ; } uftop . union ( idx , thetop ) ; } else { connectifdestopen ( idx , row - 1 , col ) ; } if ( col > 1 ) { connectifdestopen ( idx , row , col - 1 ) ; } if ( col < n ) { connectifdestopen ( idx , row , col + 1 ) ; } if ( row == n ) { if ( totop [ idx ] ) { percolates = true ; } } else { connectifdestopen ( idx , row + 1 , col ) ; } } }
tr	0	public region ( byte renderruleflags [ ] [ ] [ ] , int vertexheights [ ] [ ] [ ] ) { lowestplane = 99 ; regionsizex = 104 ; regionsizey = 104 ; this . vertexheights = vertexheights ; this . renderruleflags = renderruleflags ; underlayfloorids = new byte [ 4 ] [ regionsizex ] [ regionsizey ] ; overlayfloorids = new byte [ 4 ] [ regionsizex ] [ regionsizey ] ; overlayclippingpaths = new byte [ 4 ] [ regionsizex ] [ regionsizey ] ; overlayorientations = new byte [ 4 ] [ regionsizex ] [ regionsizey ] ; tilecullingbitsets = new int [ 4 ] [ regionsizex + 1 ] [ regionsizey + 1 ] ; tileshadowintensity = new byte [ 4 ] [ regionsizex + 1 ] [ regionsizey + 1 ] ; tilelightintensity = new int [ regionsizex + 1 ] [ regionsizey + 1 ] ; blendedhue = new int [ regionsizey ] ; blendedsaturation = new int [ regionsizey ] ; blendedlightness = new int [ regionsizey ] ; blendedhuedivisor = new int [ regionsizey ] ; blenddirectiontracker = new int [ regionsizey ] ; }
tr	0	private void initializecomponents ( ) { this . setlayout ( new borderlayout ( ) ) ; ingredientpanel = new ingredientpanel ( ) ; ingredientpanel . addchangelistener ( this ) ; textpanel = new jpanel ( new borderlayout ( ) ) ; textpane = new jtextarea ( ) ; textpane . setlinewrap ( true ) ; textpane . setlinewrap ( true ) ; textpane . setwrapstyleword ( true ) ; textpane . seteditable ( true ) ; textpane . getdocument ( ) . adddocumentlistener ( new changedocumentlistener ( ) ) ; textscrollpane = new jscrollpane ( textpane ) ; textscrollpane . setverticalscrollbarpolicy ( jscrollpane . vertical_scrollbar_as_needed ) ; textscrollpane . setpreferredsize ( new dimension ( 450 , 200 ) ) ; headline = new jtextfield ( ) ; headline . getdocument ( ) . adddocumentlistener ( new changedocumentlistener ( ) ) ; this . setpreferredsize ( new dimension ( 750 , 250 ) ) ; }
tr	9	public arraylist < integer > obtenerjugadasganadorasdehoy ( arraylist < integer > boletosdehoy , arraylist < integer > numerosganadores , int loteria_id ) { verificadora verificadora = new verificadora ( ) ; connection cn = conexion . conectar ( ) ; preparedstatement pst ; resultset rs ; string query ; arraylist < integer > jugadasdehoy = new arraylist < > ( ) ; int numerog1 , numerog2 , numerog3 ; numerog1 = numerosganadores . get ( 0 ) ; numerog2 = numerosganadores . get ( 1 ) ; numerog3 = numerosganadores . get ( 2 ) ; int coincidencias = 0 ; for ( int i = 0 ; i < boletosdehoy . size ( ) ; i ++ ) { query = "select jugada_id  combinacion  monto  formato_id from jugadas where boleto_id = " + boletosdehoy . get ( i ) + " and loteria_id =" + loteria_id ; try { pst = cn . preparestatement ( query ) ; rs = pst . executequery ( ) ; while ( rs . next ( ) ) { string comb = separarcombinacion ( rs . getstring ( "combinacion" ) ) . get ( 0 ) ; string [ ] combinacion = rs . getstring ( "combinacion" ) . split ( "-" ) ; int formato = rs . getint ( "formato_id" ) ; int jugada_id = rs . getint ( "jugada_id" ) ; numerosganadores . clear ( ) ; numerosganadores . add ( numerog1 ) ; numerosganadores . add ( numerog2 ) ; numerosganadores . add ( numerog3 ) ; coincidencias = verificadora . verificarcoincidencias ( separarcombinacion ( rs . getstring ( "combinacion" ) ) , numerosganadores ) ; system . out . println ( "jugada: " + jugada_id ) ; system . out . println ( "coinc: " + coincidencias ) ; system . out . println ( "formato: " + formato ) ; if ( coincidencias == 1 && formato == 2 ) { jugadasdehoy . add ( jugada_id ) ; calcularquiniela ( jugada_id , integer . parseint ( combinacion [ 0 ] ) , numerog1 , numerog2 , numerog3 , double . parsedouble ( rs . getstring ( "monto" ) ) ) ; system . out . println ( "quiniela gan\u00f3: " + jugada_id ) ; } else if ( coincidencias == 2 && formato == 3 ) { jugadasdehoy . add ( jugada_id ) ; calcularpale ( jugada_id , integer . parseint ( combinacion [ 0 ] ) , integer . parseint ( combinacion [ 1 ] ) , numerog1 , numerog2 , numerog3 , double . parsedouble ( rs . getstring ( "monto" ) ) ) ; } else if ( coincidencias == 3 && formato == 1 ) { jugadasdehoy . add ( jugada_id ) ; calculartripleta ( jugada_id , double . parsedouble ( rs . getstring ( "monto" ) ) ) ; } } } catch ( sqlexception ex ) { system . out . println ( ex ) ; } } return jugadasdehoy ; }
tr	6	public void start ( string args [ ] ) { try { this . host = args [ 0 ] ; this . tcpport = integer . parseint ( args [ 1 ] ) ; this . analyticserverref = args [ 2 ] ; } catch ( numberformatexception e ) { logger . error ( "seconds argument has to be an integer" ) ; } catch ( arrayindexoutofboundsexception e ) { logger . error ( "too few arguments" ) ; } propertyconfigurator . configure ( "src/log4j.properties" ) ; readproperties ( ) ; managementclient = new managementclient ( analyticserverref ) ; managementclient . start ( ) ; managementclient . processinput ( "!subscribe .*" ) ; for ( int i = 0 ; i < clients ; i ++ ) { loadtestclient client = new loadtestclient ( host , tcpport ) ; testclients . add ( client ) ; if ( auctionspermin > 0 ) client . createauctions ( auctionspermin , auctionduration ) ; if ( bidspermin > 0 ) client . bidauctions ( bidspermin ) ; executorservice . execute ( client ) ; } loadtestclient updater = new loadtestclient ( host , tcpport ) ; testclients . add ( updater ) ; updater . updatelist ( updateintervalsec ) ; executorservice . execute ( updater ) ; bufferedreader input = new bufferedreader ( new inputstreamreader ( system . in ) ) ; try { input . readline ( ) ; input . close ( ) ; } catch ( ioexception ex ) { logger . error ( "io exception on system standard input" ) ; } shutdown ( ) ; }
tr	8	private void setcharactervalue ( stringbuilder acharacters ) throws saxexception { if ( "published" . equals ( currentelement ) ) { try { tweet . setpublished ( dateformat . parse ( acharacters . tostring ( ) ) ) ; } catch ( parseexception anexc ) { throw new saxexception ( anexc ) ; } } else if ( ( "title" . equals ( currentelement ) ) && ( tweet != null ) ) { tweet . settitle ( acharacters . tostring ( ) ) ; } else if ( "content" . equals ( currentelement ) ) { content . setvalue ( acharacters . tostring ( ) ) ; } else if ( "twitter:lang" . equals ( currentelement ) ) { tweet . setlanguage ( acharacters . tostring ( ) ) ; } else if ( "name" . equals ( currentelement ) ) { author . setname ( acharacters . tostring ( ) ) ; } else if ( "uri" . equals ( currentelement ) ) { author . seturi ( acharacters . tostring ( ) ) ; } }
tr	5	@ override public void render ( gamecontainer gc , statebasedgame sbg , graphics grphcs ) throws slickexception { background . draw ( 0 , 0 ) ; txtname . render ( gc , grphcs ) ; for ( int i = 0 ; i < areas . length ; i ++ ) { areas [ i ] . render ( gc , grphcs ) ; } for ( statallocation stat : stats ) { ttf . drawstring ( stat . getposition ( ) . getx ( ) , stat . getposition ( ) . gety ( ) , integer . tostring ( stat . getstat ( ) ) ) ; } if ( femalechose == true ) { ttf . drawstring ( 170 , 94 , "x" , color . white ) ; int x = 94 ; grphcs . scale ( 2 , 2 ) ; for ( playersprite ps : female ) { ps . getanimation ( ) . draw ( x , 80 ) ; x = x + 36 ; } } else { ttf . drawstring ( 360 , 93 , "x" , color . white ) ; int x = 94 ; grphcs . scale ( 2 , 2 ) ; for ( playersprite ps : male ) { ps . getanimation ( ) . draw ( x , 80 ) ; x = x + 36 ; } } grphcs . scale ( .5f , .5f ) ; }
tr	6	public int [ ] getactions ( game game , long timedue ) { int pacmanloc = game . getcurpacmanloc ( ) ; for ( int i = 0 ; i < dirs . length ; i ++ ) { if ( game . ghostrequiresaction ( i ) ) { if ( iscrowded ( game ) && ! closetomspacman ( game , game . getcurghostloc ( i ) ) ) dirs [ i ] = getretreatactions ( game , i ) ; else if ( game . getedibletime ( i ) > 0 || closetopower ( game ) ) dirs [ i ] = game . getnextghostdir ( i , pacmanloc , false , game . dm . path ) ; else dirs [ i ] = game . getnextghostdir ( i , pacmanloc , true , game . dm . path ) ; } } return dirs ; }
tr	6	public void run ( ) { message m = parser . extractrequest ( fromclient ) ; node child = m . contents . getfirstchild ( ) ; if ( ! child . getlocalname ( ) . equals ( parser . connectrequest ) ) { return ; } system . out . println ( "receiving: " + m ) ; string xmlstring = message . responseheader ( m . id ( ) ) + "<connectresponse id='" + id + "'/></response>" ; message r = new message ( xmlstring ) ; if ( ! sendmessage ( r ) ) { system . err . println ( "unable to respond to connect request from remote client." ) ; return ; } server . register ( id , this ) ; while ( ( m = parser . extractrequest ( fromclient ) ) != null ) { message response = handler . process ( this , m ) ; if ( ! sendmessage ( response ) ) { break ; } } if ( handler instanceof ishutdownhandler ) { ( ( ishutdownhandler ) handler ) . logout ( server . getstate ( id ) ) ; } server . unregister ( id ) ; try { fromclient . close ( ) ; toclient . close ( ) ; client . close ( ) ; } catch ( ioexception e ) { system . err . println ( "unable to close connection:" + e . getmessage ( ) ) ; } }
tr	2	public grille ( int taille , joueur joueur , boolean afficher_bateaux ) { this . taille_case = 320 / taille ; this . taille = taille ; this . cases = new case [ taille ] [ taille ] ; this . joueur = joueur ; this . afficher_bateaux = afficher_bateaux ; this . setbackground ( new color ( 0 , 0 , 0 ) ) ; this . setlayout ( new gridlayout ( taille , taille , 0 , 0 ) ) ; for ( int i = 0 ; i < taille ; i ++ ) for ( int j = 0 ; j < taille ; j ++ ) cases [ i ] [ j ] = new case ( i + 1 , j + 1 , taille_case ) ; initialisercases ( ) ; }
tr	3	public static void main ( string [ ] args ) { final int [ ] subscripts = new int [ ] { 1 , 10 , 100 , 1000 , 10000 , 100000 , 1000000 } ; final int last = subscripts [ subscripts . length - 1 ] ; string s = null ; long p = 1 ; int ls = 0 ; int j = 0 ; int l = 0 ; for ( int i = 1 ; i < 1000000 ; i ++ ) { s = string . valueof ( i ) ; ls = s . length ( ) ; l += ls ; if ( l >= subscripts [ j ] ) { final int n = ls - ( l - subscripts [ j ] ) - 1 ; final int d = integer . parseint ( s . substring ( n , n + 1 ) ) ; p *= ( long ) d ; j ++ ; } if ( l > last ) { break ; } } system . out . println ( "# p = " + p ) ; }
tr	1	@ test @ ignore public void havedinner ( ) throws exception { int eattimes = 3 ; int numphilosophers = 5 ; countdownlatch waittillallinitialized = new countdownlatch ( numphilosophers ) ; countdownlatch waittillalldonedining = new countdownlatch ( numphilosophers ) ; atomicinteger availableforks = new atomicinteger ( numphilosophers ) ; list < diningphilosopher > philosophers = new arraylist < > ( ) ; for ( int i = 1 ; i <= numphilosophers ; i ++ ) { diningphilosopher philosopher = new diningphilosopher ( i , availableforks , eattimes , waittillalldonedining ) ; philosophers . add ( philosopher ) ; } immutablelist < diningphilosopher > allphilosophers = new immutablelist < > ( philosophers ) ; philosophers . foreach ( ( diningphilosopher philosopher ) -> { philosopher . start ( allphilosophers , registry . getdefault ( ) ) ; } ) ; waittillalldonedining . await ( ) ; system . out . println ( "all philosophers done each dining " + eattimes + " times" ) ; }
tr	8	public void updatelist ( ) { listmodel . clear ( ) ; arraylist < string > a = new arraylist < > ( ) ; for ( course co : alist ) { if ( co . getinstructor ( ) == null && co . getlab ( ) == null ) { listmodel . addelement ( co . getclasscode ( ) + " " + co . getsection ( ) + " : " + "n/a" ) ; } else if ( co . getinstructor ( ) != null && co . getlab ( ) != null ) { a . add ( co . getclasscode ( ) + " " + co . getsection ( ) + " : " + co . getinstructor ( ) . getname ( ) + " (lab)" ) ; } else if ( co . getinstructor ( ) != null && co . getlab ( ) == null ) { a . add ( co . getclasscode ( ) + " " + co . getsection ( ) + " : " + co . getinstructor ( ) . getname ( ) ) ; } else { listmodel . addelement ( co . getclasscode ( ) + " " + co . getsection ( ) + " : " + "n/a" + " (lab)" ) ; } } collections . sort ( a ) ; for ( int i = 0 ; i < a . size ( ) ; i ++ ) { listmodel . add ( i , a . get ( i ) ) ; } }
tr	2	@ override public void actionperformed ( actionevent event ) { string eventname = event . getactioncommand ( ) ; system . out . println ( "event:" + eventname ) ; switch ( eventname ) { case "comboboxchanged" : string prefname = sysadminui . getpreferencelistboxselection ( ) ; string value = systemprefs . get ( prefname ) . tostring ( ) ; sysadminui . setpreferencefield ( value ) ; break ; case "set preference" : string preference = sysadminui . getpreferencelistboxselection ( ) ; string valuefield = sysadminui . getpreferencefield ( ) ; systemprefs . put ( preference , valuefield ) ; setchanged ( ) ; notifyobservers ( ) ; break ; } }
tr	5	public boolean isisandorsentencehelper ( list < string > words , string sentenceptn , string ptn1 , string ptn2 ) { propertyconfigurator . configure ( "conf/log4j.properties" ) ; logger mylogger = logger . getlogger ( "learn.isisandorsentence" ) ; sentenceptn = sentenceptn . tolowercase ( ) ; sentenceptn = sentenceptn . replaceall ( "t" , "m" ) ; pattern p1 = pattern . compile ( ptn1 ) ; matcher m1 = p1 . matcher ( sentenceptn ) ; pattern p2 = pattern . compile ( ptn2 ) ; matcher m2 = p2 . matcher ( sentenceptn ) ; int end = - 1 ; boolean case1 = false ; boolean case2 = false ; if ( m1 . find ( ) ) { end = m1 . end ( ) ; case1 = true ; } if ( m2 . find ( ) ) { end = m2 . end ( ) ; case2 = true ; } if ( case1 || case2 ) { string matchedwords = stringutils . join ( words . sublist ( 0 , end ) , " " ) ; string regex = string . format ( "\\b(%s)\\b" , this . mylearnerutility . getconstant ( ) . preposition ) ; if ( stringutility . ismatchednullsafe ( matchedwords , regex ) ) { mylogger . trace ( "case 1" ) ; return false ; } mylogger . trace ( "case 2" ) ; return true ; } mylogger . trace ( "case 3" ) ; return false ; }
tr	3	public static void main ( string [ ] args ) { salariedemployee salariedemployee = new salariedemployee ( "john" , "smith" , "111-11-1111" , 800.00 ) ; hourlyemployee hourlyemployee = new hourlyemployee ( "karen" , "price" , "222-22-2222" , 16.75 , 40 ) ; commissionemployee commissionemployee = new commissionemployee ( "sue" , "jones" , "333-33-3333" , 10000 , .06 ) ; basepluscommissionemployee basepluscommissionemployee = new basepluscommissionemployee ( "bob" , "lewis" , "444-44-4444" , 5000 , .04 , 300 ) ; system . out . println ( "employees processed individually:\n" ) ; system . out . printf ( "%s\n%s: $% .2f\n\n" , salariedemployee , "earned" , salariedemployee . earnings ( ) ) ; system . out . printf ( "%s\n%s: $% .2f\n\n" , hourlyemployee , "earned" , hourlyemployee . earnings ( ) ) ; system . out . printf ( "%s\n%s: $% .2f\n\n" , commissionemployee , "earned" , commissionemployee . earnings ( ) ) ; system . out . printf ( "%s\n%s: $% .2f\n\n" , basepluscommissionemployee , "earned" , basepluscommissionemployee . earnings ( ) ) ; employee [ ] employees = new employee [ 4 ] ; employees [ 0 ] = salariedemployee ; employees [ 1 ] = hourlyemployee ; employees [ 2 ] = commissionemployee ; employees [ 3 ] = basepluscommissionemployee ; system . out . println ( "employees processed polymorphically:\n" ) ; for ( employee currentemployee : employees ) { system . out . println ( currentemployee ) ; if ( currentemployee instanceof basepluscommissionemployee ) { basepluscommissionemployee employee = ( basepluscommissionemployee ) currentemployee ; employee . setbasesalary ( 1.10 * employee . getbasesalary ( ) ) ; system . out . printf ( "new base salary with 10%% increase is: $% .2f\n" , employee . getbasesalary ( ) ) ; } system . out . printf ( "earned $% .2f\n\n" , currentemployee . earnings ( ) ) ; } for ( int j = 0 ; j < employees . length ; j ++ ) system . out . printf ( "employee %d is a %s\n" , j , employees [ j ] . getclass ( ) . getname ( ) ) ; }
tr	2	@ override public void paintcomponent ( graphics g ) { g . setcolor ( def_background_colour ) ; g . fillrect ( 0 , 0 , util . image_size , util . image_size ) ; graphics2d g2d = ( graphics2d ) g ; if ( image != null ) { g2d . drawimage ( image , 0 , 0 , util . image_size , util . image_size , 0 , 0 , util . image_size , util . image_size , null ) ; } if ( gridvisible ) { drawgrid ( g ) ; } g2d . drawimage ( selector , selectorlocation . x , selectorlocation . y , selectorlocation . x + util . grid_sections , selectorlocation . y + util . grid_sections , 0 , 0 , util . grid_sections , util . grid_sections , null ) ; }
tr	2	public static final void initialize ( ) { slowslaves = new slavethread [ nb_slowslaves ] ; fastslaves = new slavethread [ nb_fastslaves ] ; for ( int i = 0 ; i < nb_slowslaves ; i ++ ) { slowslaves [ i ] = new slavethread ( ) ; slowslaves [ i ] . start ( ) ; } for ( int i = 0 ; i < nb_fastslaves ; i ++ ) { fastslaves [ i ] = new slavethread ( ) ; fastslaves [ i ] . start ( ) ; } indexslow = 0 ; indexfast = 0 ; }
tr	8	private boolean isscramblecore ( string s1 , string s2 ) { boolean result = false ; list < string > key = new arraylist < string > ( ) ; key . add ( s1 ) ; key . add ( s2 ) ; if ( cache . containskey ( key ) ) return cache . get ( key ) ; if ( s1 . equals ( s2 ) ) { cache . put ( key , true ) ; return true ; } if ( s1 . length ( ) == 1 ) { cache . put ( key , false ) ; return false ; } int n = s1 . length ( ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { string s11 = s1 . substring ( 0 , i + 1 ) ; string s12 = s1 . substring ( i + 1 ) ; string s21 = s2 . substring ( 0 , i + 1 ) ; string s22 = s2 . substring ( i + 1 ) ; if ( isscramblecore ( s11 , s21 ) && isscramblecore ( s12 , s22 ) ) { result = true ; break ; } s21 = s2 . substring ( 0 , n - 1 - i ) ; s22 = s2 . substring ( n - 1 - i ) ; if ( isscramblecore ( s11 , s22 ) && isscramblecore ( s12 , s21 ) ) { result = true ; break ; } } cache . put ( key , result ) ; return result ; }
tr	7	private void createfiles ( boolean test , hashmap < string , printtofile > filesmap , string cat ) { try { bufferedreader input = new bufferedreader ( new filereader ( classify . datapath + "/rawdata/train" + cat + ".csv" ) ) ; string line ; line = input . readline ( ) ; hashmap < string , contractorholder > contractors = new hashmap < string , contractorholder > ( ) ; while ( ( line = input . readline ( ) ) != null ) { string [ ] tmpar = line . split ( "\" \"" ) ; for ( int i = 0 ; i < tmpar . length ; i ++ ) { tmpar [ i ] = tmpar [ i ] . replaceall ( "\"" , "" ) ; } string contractor = tmpar [ 2 ] . trim ( ) ; contractorholder contractorholder = contractors . get ( contractor ) ; if ( contractorholder == null ) { contractorholder = new contractorholder ( ) ; contractors . put ( contractor , contractorholder ) ; } string jobtype = tmpar [ 0 ] . trim ( ) ; string opening = tmpar [ 1 ] . trim ( ) ; string client = tmpar [ 30 ] . trim ( ) ; clientholder curclientholder = clienthistory . get ( client ) ; if ( curclientholder == null ) { curclientholder = new clientholder ( ) ; clienthistory . put ( client , curclientholder ) ; } createinstance ( filesmap . get ( ( test ? "test" : "train" ) + jobtype ) , tmpar , contractorholder , curclientholder , contractor ) ; if ( test ) filesmap . get ( "testholder" + jobtype ) . writetofile ( opening + " " + contractor ) ; } } catch ( ioexception e ) { e . printstacktrace ( ) ; } }
tr	6	public object stringtovalue ( string text ) throws parseexception { stringtokenizer tokenizer = new stringtokenizer ( text , "." ) ; byte [ ] a = new byte [ 4 ] ; for ( int i = 0 ; i < 4 ; i ++ ) { int b = 0 ; if ( ! tokenizer . hasmoretokens ( ) ) throw new parseexception ( "too few bytes" , 0 ) ; try { b = integer . parseint ( tokenizer . nexttoken ( ) ) ; } catch ( numberformatexception e ) { throw new parseexception ( "not an integer" , 0 ) ; } if ( b < 0 || b >= 256 ) throw new parseexception ( "byte out of range" , 0 ) ; a [ i ] = ( byte ) b ; } if ( tokenizer . hasmoretokens ( ) ) throw new parseexception ( "too many bytes" , 0 ) ; return a ; }
tr	5	static int [ ] [ ] minpaths ( int [ ] [ ] triangle ) { int [ ] [ ] newtriangle = triangle . clone ( ) ; for ( int i = 1 ; i < newtriangle . length ; i ++ ) { int previouslevelminpath = 20000 * size ; for ( int n = 0 ; n < i ; n ++ ) if ( newtriangle [ i - n - 1 ] [ n ] < previouslevelminpath ) previouslevelminpath = newtriangle [ i - n - 1 ] [ n ] ; for ( int n = 0 ; n <= i ; n ++ ) { int currentheight = i - n ; int currentwidth = n ; int currentminpath ; if ( n < ( i + 1 ) / 2 ) currentminpath = newtriangle [ currentheight - 1 ] [ currentwidth ] ; else currentminpath = newtriangle [ currentheight ] [ currentwidth - 1 ] ; currentminpath = minpathlength ( i - 1 , currentheight , currentwidth , currentminpath , previouslevelminpath , 0 , newtriangle ) ; newtriangle [ currentheight ] [ currentwidth ] += currentminpath ; } } return newtriangle ; }
tr	9	public static void main ( string [ ] args ) { long [ ] lastrow = new long [ 1 ] ; lastrow [ 0 ] = 1 ; for ( int i = 1 ; i <= size ; i ++ ) { if ( i % 1000 == 0 ) system . out . println ( i ) ; long [ ] nextrow = new long [ i + 1 ] ; nextrow [ 0 ] = 1 ; nextrow [ nextrow . length - 1 ] = 1 ; for ( int j = 1 ; j < lastrow . length ; j ++ ) nextrow [ j ] = ( lastrow [ j - 1 ] + lastrow [ j ] ) % 1000000000000 ; lastrow = nextrow ; } int count = 0 ; long [ ] currentrow = new long [ 1 ] ; currentrow [ 0 ] = 1 ; for ( int i = 1 ; i < lastrow . length ; i ++ ) { if ( i % 1000 == 0 ) system . out . println ( i ) ; long [ ] nextrow = new long [ i + 1 ] ; nextrow [ 0 ] = 1 ; nextrow [ nextrow . length - 1 ] = 1 ; for ( int j = 1 ; j < currentrow . length ; j ++ ) nextrow [ j ] = ( currentrow [ j - 1 ] + currentrow [ j ] ) % 1000000000000 ; currentrow = nextrow ; long multiplier = lastrow [ i - 1 ] ; int initialtwos = numtwos ( multiplier ) ; int initialfives = numfives ( multiplier ) ; for ( int j = 0 ; j < nextrow . length ; j ++ ) { int twos = numtwos ( nextrow [ j ] ) ; int fives = numfives ( nextrow [ j ] ) ; if ( initialtwos + twos >= 12 && initialfives + fives >= 12 ) count ++ ; } } system . out . print ( count ) ; }
tr	6	public boolean hasclearpath ( chesstile start , chesstile end ) { int forwarddistance ; int sidedistance ; if ( start == null || end == null ) { return false ; } forwarddistance = math . abs ( end . getposition ( ) [ 1 ] - start . getposition ( ) [ 1 ] ) ; sidedistance = math . abs ( end . getposition ( ) [ 0 ] - start . getposition ( ) [ 0 ] ) ; for ( int i = 1 ; i < math . max ( forwarddistance , sidedistance ) - 1 ; i ++ ) { int forwardmin = math . min ( forwarddistance , i ) ; int sidemin = math . min ( sidedistance , i ) ; if ( start . getposition ( ) [ 0 ] > end . getposition ( ) [ 0 ] ) { sidemin = - sidemin ; } if ( start . getposition ( ) [ 1 ] > end . getposition ( ) [ 1 ] ) { forwardmin = - forwardmin ; } if ( board [ start . getposition ( ) [ 0 ] + sidemin ] [ start . getposition ( ) [ 1 ] + forwardmin ] . getheldpiece ( ) != null ) { return false ; } } return true ; }
tr	5	public plugin ( string name ) { this . name = name ; this . propertychange = new propertychangesupport ( this ) ; if ( name . startswith ( "serendipity_plugin" ) ) { settype ( plugintype . sidebar ) ; } else if ( name . startswith ( "serendipity_event" ) ) { settype ( plugintype . event ) ; } else if ( name . equals ( "system" ) ) { settype ( plugintype . system ) ; } else { settype ( plugintype . template ) ; } intern = false ; if ( type . equals ( plugintype . system ) ) { intern = true ; } if ( name . equals ( "homepage" ) ) { system . out . println ( "contructor: hompage plugin type = " + gettype ( ) ) ; } }
tr	6	public static void main ( string [ ] args ) { int n = 4 ; int gc [ ] = { 1 , 5 , 3 , 6 } ; int d [ ] = { 2 , 3 , 2 , 7 } ; int rf [ ] = { 0 , 0 , 0 , 0 } ; int l , i ; for ( l = 0 ; l < n ; l ++ ) { for ( i = 0 ; i < n ; i ++ ) { if ( rf [ i ] >= 0 ) rf [ i ] += gc [ ( l + i ) % n ] - d [ ( l + i ) % n ] ; } } for ( i = 0 ; i < n ; i ++ ) { if ( rf [ i ] >= 0 ) break ; } if ( i < n ) { system . out . println ( "the starting point is:" + i ) ; } else { system . out . println ( "there is no starting point" ) ; } }
tr	2	public void setstationdata ( string call , string locator , string qrzuser , string qrzpass , double lat , double lon , string hamuser , string hampass ) throws sqlexception { connection con = getdbconnection ( ) ; string query0 = "delete from sation_data" ; con . preparecall ( query0 ) . execute ( ) ; string query = "insert into sation_data (call_id locator longitude latitude qrz_user qrz_pass ham_user ham_pass) values (? ? ? ? ? ? ? ?)" ; java . sql . preparedstatement stm = con . preparestatement ( query ) ; int index = 1 ; stm . setstring ( index ++ , call ) ; stm . setstring ( index ++ , locator ) ; stm . setdouble ( index ++ , ( lon != null ) ? lon : 0d ) ; stm . setdouble ( index ++ , ( lat != null ) ? lat : 0d ) ; stm . setstring ( index ++ , qrzuser ) ; stm . setstring ( index ++ , qrzpass ) ; stm . setstring ( index ++ , hamuser ) ; stm . setstring ( index ++ , hampass ) ; stm . execute ( ) ; }
tr	7	private static void printhubdetails ( int indent , device dev ) { try { hub h = new hub ( dev ) ; int ports = h . getnumports ( ) ; boolean indicator = h . isindicator ( ) ; indentline ( indent , ( h . isroothub ( ) ? "root " : "" ) + "hub  " + ports + " ports" ) ; indentline ( indent , "overcurrent protection: " + h . getovercurrentmode ( ) ) ; indentline ( indent , "power switching: " + h . getpowerswitchingmode ( ) ) ; if ( indicator ) indentline ( indent , "has port indicator leds" ) ; if ( h . iscompound ( ) ) indentline ( indent , "part of a compound device" ) ; indent -= 4 ; indentline ( indent , "" ) ; for ( int i = 1 ; i <= ports ; i ++ ) { device child = dev . getchild ( i ) ; if ( child == null ) continue ; indentline ( indent , "<!-- port " + i + ( h . isremovable ( i ) ? "" : " is built-in." ) + " -->" ) ; printdevice ( indent , child ) ; } } catch ( ioexception e ) { e . printstacktrace ( system . out ) ; } }
tr	2	@ override public component gettablecellrenderercomponent ( jtable table , object value , boolean isselected , boolean hasfocus , int row , int column ) { final component c = super . gettablecellrenderercomponent ( table , value , isselected , hasfocus , row , column ) ; if ( dataholder . getresult ( ) . get ( row ) . getsignificance ( ) == edasomindsignificance . high ) { c . setforeground ( color . white ) ; c . setbackground ( color . red ) ; } else if ( dataholder . getresult ( ) . get ( row ) . getsignificance ( ) == edasomindsignificance . medium ) { c . setforeground ( color . black ) ; c . setbackground ( color . orange ) ; } else { c . setbackground ( color . green ) ; c . setforeground ( color . black ) ; } return c ; }
tr	8	private list < string > generacachekey ( object obj ) { ormtable ormtable = obj . getclass ( ) . getannotation ( ormtable . class ) ; if ( ormtable != null ) { string cachedtablekey = "" . equalsignorecase ( ormtable . cachedshortalias ( ) ) ? ormtable . tablename ( ) : ormtable . cachedshortalias ( ) ; string [ ] cachedkeys = ormtable . cachedkey ( ) ; if ( cachedkeys . length > 0 ) { list < string > ks = new arraylist < string > ( ) ; for ( int i = 0 ; i < cachedkeys . length ; i ++ ) { string cachedcol = cachedkeys [ i ] ; string [ ] fk = cachedcol . split ( "=" ) ; try { field f = obj . getclass ( ) . getdeclaredfield ( fk [ 0 ] ) ; f . setaccessible ( true ) ; ks . add ( cachedtablekey + "." + fk [ 1 ] + "." + f . get ( obj ) ) ; } catch ( nosuchfieldexception e ) { logger . warn ( "nosuchfieldexception:{};" , cachedcol , e ) ; continue ; } catch ( securityexception e ) { logger . warn ( "securityexception:{};" , cachedcol , e ) ; continue ; } catch ( illegalargumentexception e ) { logger . warn ( "get field value fail:{};" , cachedcol , e ) ; continue ; } catch ( illegalaccessexception e ) { logger . warn ( "get field value fail:{};" , cachedcol , e ) ; continue ; } } return ks ; } else { return null ; } } else { return null ; } }
tr	5	public v checkbaseinterfaces ( class c ) { map < class , v > possibles = new hashmap < class , v > ( ) ; for ( class base = c ; base != object . class ; base = base . getsuperclass ( ) ) { for ( class itf : base . getinterfaces ( ) ) { v val = lookup . valat ( itf ) ; if ( val != null ) possibles . put ( itf , val ) ; } } switch ( possibles . size ( ) ) { case 0 : return null ; case 1 : return possibles . values ( ) . iterator ( ) . next ( ) ; default : throw new runtimeexception ( "more thane one match for " + c ) ; } }
tr	2	public int priseterritoire ( territoire t , int nbunite ) { if ( this . nbunitebonus >= nbunite - 1 ) { this . nbunitebonus -= nbunite - 1 ; nbunite = 1 ; } else { nbunite -= this . nbunitebonus ; this . nbunitebonus = 0 ; } this . nbuniteenmain -= nbunite ; t . setnbunite ( nbunite ) ; t . setoccupant ( this ) ; this . territoiresoccupes . add ( t ) ; this . actionpriseterritoire ( t ) ; if ( haspower ( ) ) { this . pouvoir . actionpriseterritoire ( t ) ; } return nbunite ; }
tr	2	public static void main ( string [ ] args ) { scanner scanner = new scanner ( system . in ) ; int n = 0 , cnt = 1 ; hdoj1069 hdoj1069 = new hdoj1069 ( ) ; while ( ( n = scanner . nextint ( ) ) > 0 ) { hdoj1069 . init ( ) ; while ( n -- > 0 ) { hdoj1069 . handleinput ( scanner . nextint ( ) , scanner . nextint ( ) , scanner . nextint ( ) ) ; } system . out . println ( string . format ( "case %s: maximum height = %s" , cnt ++ , hdoj1069 . entrance ( ) ) ) ; } }
tr	1	public coverdetails deserialize ( jsonobject json ) throws exception { integer id = ( integer ) json . get ( id_key ) ; string artist = ( string ) json . get ( artist_key ) ; string album = ( string ) json . get ( album_key ) ; integer discnumber = ( integer ) json . get ( disc_key ) ; boolean noimage = ( boolean ) json . get ( noimage_key ) ; jsonarray tracks = ( jsonarray ) json . get ( tracks_key ) ; int len = tracks . length ( ) ; list < trackdetails > tracknames = new arraylist < trackdetails > ( len ) ; for ( int i = 0 ; i < len ; i ++ ) { jsonobject trackjson = ( jsonobject ) tracks . get ( i ) ; string title = ( string ) trackjson . get ( title_key ) ; integer lengthseconds = ( integer ) trackjson . get ( length_key ) ; tracknames . add ( new trackdetails ( title , lengthseconds . intvalue ( ) ) ) ; } image image = null ; coverdetails cover = new coverdetails ( id . intvalue ( ) , artist , album , image , discnumber . intvalue ( ) , noimage . booleanvalue ( ) ) ; cover . settracknames ( tracknames ) ; return cover ; }
tr	6	public void doservice ( ) { message message = parser . nextmessage ( ) ; while ( message != null ) { switch ( message . gettype ( ) ) { case connect : writer . println ( "already connected!" ) ; writer . flush ( ) ; break ; case disconnect : server . broadcaster . remove ( connection ) ; break ; case textmsg_client : broadcastmessage ( message ) ; break ; case image_client : server . setimage ( imageutils . decodeimage ( message . getmatcher ( ) . group ( 1 ) ) ) ; broadcastmessage ( message ) ; break ; default : abstracttool tool = abstracttool . gettool ( message . gettype ( ) ) ; if ( tool != null ) { server . updateimage ( tool , message ) ; broadcastmessage ( message ) ; } break ; } message = parser . nextmessage ( ) ; } }
tr	0	private jlabel newjlabel ( string value , string src ) { jlabel label = new jlabel ( value ) ; label . seticon ( new imageicon ( src ) ) ; label . setfont ( new font ( "lucida grande" , 0 , 14 ) ) ; label . setpreferredsize ( new dimension ( 40 , 90 ) ) ; label . sethorizontaltextposition ( swingconstants . center ) ; label . setverticaltextposition ( swingconstants . bottom ) ; label . setverticalalignment ( swingconstants . bottom ) ; label . setborder ( borderfactory . createemptyborder ( 0 , 0 , 0 , 5 ) ) ; return label ; }
tr	4	public static string readasstring ( file file ) { final long length = file . length ( ) ; final byte [ ] bytes = new byte [ ( int ) length ] ; inputstream is = null ; try { is = new fileinputstream ( file ) ; is . read ( bytes ) ; } catch ( ioexception e ) { } finally { try { if ( is != null ) { is . close ( ) ; } } catch ( ioexception ex ) { return null ; } } try { return new string ( bytes , "utf-8" ) ; } catch ( unsupportedencodingexception e ) { return null ; } }
tr	0	private void init ( gridpanel gridpanel ) { this . gridpanel = gridpanel ; container thiss = getcontentpane ( ) ; thiss . setlayout ( new borderlayout ( ) ) ; thiss . setbackground ( charapp . color_bg ) ; jpanel fontpanel = new jpanel ( new gridlayout ( 3 , 1 ) ) ; fontpanel . setbackground ( charapp . color_bg ) ; resize = new jbutton ( "resize" ) ; chinese = new jbutton ( "chinese font" ) ; pinyin = new jbutton ( "pinyin font" ) ; other = new jbutton ( "other font" ) ; display = new jbutton ( "main display" ) ; ok = new jbutton ( "ok" ) ; chineseexample = new jlabel ( chtext , swingconstants . center ) ; chineseexample . setfont ( gridpanel . getchinesefont ( ) ) ; pinyinexample = new jlabel ( pintext , swingconstants . center ) ; pinyinexample . setfont ( gridpanel . getpinyinfont ( ) ) ; otherexample = new jlabel ( entext , swingconstants . center ) ; otherexample . setfont ( gridpanel . getotherfont ( ) ) ; chinese . setbackground ( charapp . color_button ) ; pinyin . setbackground ( charapp . color_button ) ; other . setbackground ( charapp . color_button ) ; display . setbackground ( charapp . color_button ) ; chinese . addactionlistener ( this ) ; pinyin . addactionlistener ( this ) ; other . addactionlistener ( this ) ; resize . addactionlistener ( this ) ; display . addactionlistener ( this ) ; ok . addactionlistener ( this ) ; jpanel temp = new jpanel ( ) ; temp . setbackground ( charapp . color_bg ) ; temp . add ( chinese ) ; temp . add ( chineseexample ) ; fontpanel . add ( temp ) ; temp = new jpanel ( ) ; temp . setbackground ( charapp . color_bg ) ; temp . add ( pinyin ) ; temp . add ( pinyinexample ) ; fontpanel . add ( temp ) ; temp = new jpanel ( ) ; temp . setbackground ( charapp . color_bg ) ; temp . add ( other ) ; temp . add ( otherexample ) ; fontpanel . add ( temp ) ; thiss . add ( fontpanel , borderlayout . center ) ; jpanel buttonpanel = new jpanel ( new flowlayout ( flowlayout . center ) ) ; buttonpanel . add ( ok ) ; buttonpanel . add ( resize ) ; ok . setbackground ( charapp . color_button ) ; resize . setbackground ( charapp . color_button ) ; buttonpanel . setbackground ( charapp . color_bg ) ; thiss . add ( buttonpanel , borderlayout . south ) ; this . pack ( ) ; this . setlocation ( ( int ) getowner ( ) . getlocation ( ) . getx ( ) - 100 , ( int ) getowner ( ) . getlocation ( ) . gety ( ) + getowner ( ) . getheight ( ) / 3 ) ; }
tr	5	public void turn ( int choice ) { if ( choice == 0 ) { attack ( true ) ; } else if ( choice == 1 ) { choosespell ( ) ; } else if ( choice == 2 ) { flee ( ) ; } if ( enemy . gethealth ( ) <= 0 ) { system . out . println ( "thy enemy lies vanquished!" ) ; endbattle ( ) ; } else { attack ( false ) ; } if ( character . gethealth ( ) <= 0 ) { system . out . println ( "thou hast been defeated!" ) ; youlose ( ) ; } }
tr	3	< c > nodefactory < c > getsimplenodebuilder ( final string namespace , class < c > dummy ) { final nodefactory < c > factory = new reflectnodefactory < > ( new autoqualifiedclassloader ( namespace , _classloader ) ) ; return new simplenodefactory < c > ( ) { public predicate < c > newpredicate ( string type , string attr ) { if ( factory . newpredicate ( type , attr ) == null ) error ( type ) ; else ok ( type ) ; return super . newpredicate ( type , attr ) ; } @ override public action < c > newaction ( string type , string attr ) { if ( factory . newaction ( type , attr ) == null ) error ( type ) ; else ok ( type ) ; return super . newaction ( type , attr ) ; } private void ok ( string name ) { if ( verbose ) system . out . printf ( "class '%s' loaded\n" , name ) ; } private void error ( string name ) { system . err . printf ( "class '%s' not found in '%s'\n" , name , namespace ) ; } } ; }
tr	2	private void drawboard ( int deadfields ) { gui . totalnumberofmoves = 49 - deadfields ; dimension boardsize = new dimension ( 245 , 245 ) ; layeredpane = new jlayeredpane ( ) ; getcontentpane ( ) . add ( layeredpane ) ; layeredpane . setpreferredsize ( boardsize ) ; layeredpane . addmouselistener ( this ) ; pahtumboard = new jpanel ( ) ; layeredpane . add ( pahtumboard , jlayeredpane . default_layer ) ; gridlayout gridlayout = new gridlayout ( 7 , 7 ) ; gridlayout . setvgap ( 2 ) ; gridlayout . sethgap ( 2 ) ; pahtumboard . setlayout ( gridlayout ) ; pahtumboard . setpreferredsize ( boardsize ) ; pahtumboard . setbounds ( 0 , 0 , boardsize . width , boardsize . height ) ; board = new board ( 1 , true , deadfields ) ; string [ ] [ ] b = board . getstate ( ) ; for ( int i = 0 ; i < 49 ; ++ i ) { jpanel square = new jpanel ( new borderlayout ( ) ) ; pahtumboard . add ( square ) ; if ( b [ i / 7 ] [ i % 7 ] . equals ( "x" ) ) { jlabel deadfield = new jlabel ( new imageicon ( "/n/student/kg687/workspace/pahtum v3/img/deadfiled.jpg" ) ) ; square . add ( deadfield ) ; } else { square . setbackground ( color . gethsbcolor ( 16 , 83 , 69 ) ) ; } } }
tr	2	public static void main ( string [ ] args ) { pricesinfo pricesinfo = new pricesinfo ( ) ; reader [ ] readers = new reader [ 5 ] ; thread [ ] threadsreader = new thread [ readers . length ] ; for ( int i = 0 ; i < readers . length ; i ++ ) { readers [ i ] = new reader ( pricesinfo ) ; threadsreader [ i ] = new thread ( readers [ i ] ) ; } writer writer = new writer ( pricesinfo ) ; thread threadwriter = new thread ( writer ) ; for ( thread thread : threadsreader ) { thread . start ( ) ; } threadwriter . start ( ) ; }
tr	5	public final boolean isvalidrate ( final string rate ) { final string methodname = "isvalidrate" ; databaselogger . entering ( class_name , methodname , rate ) ; boolean validrate = true ; if ( isemptyvalue ( rate ) ) { validrate = false ; } else if ( ! rate . startswith ( "$" ) ) { validrate = false ; } else { try { final string rateamount = rate . substring ( 1 ) ; double ratedouble = double . parsedouble ( rateamount ) ; if ( ( ratedouble <= 0 ) || ( ratedouble > databaseconstants . max_rate_value ) ) { validrate = false ; } } catch ( numberformatexception e ) { validrate = false ; } } databaselogger . exiting ( class_name , methodname , validrate ) ; return validrate ; }
tr	5	public static double inversesensormodel_old ( point p , point measurement , robotstate sensorstate , int z , sensor s ) { double result ; int r = utils . euclideandistance ( new point ( sensorstate . x , sensorstate . y ) , p ) ; if ( z == - 1 ) { result = config . logodd_start ; } else if ( r > math . min ( s . zmax , z ) + config . grid_cell_size ) { result = config . logodd_start ; } else if ( z < s . zmax && p . equals ( measurement ) ) { result = config . logodd_occupied_correct ; } else if ( r < z ) { result = config . logodd_occupied_wrong ; } else { result = config . logodd_start ; } return result ; }
tr	3	public void modifycourse ( classinfo classinfo ) { classinfo cinfodata = getcourse ( classinfo . getclassnumber ( ) ) ; if ( cinfodata != null ) { if ( ! classinfo . getcoursename ( ) . equalsignorecase ( cinfodata . getcoursename ( ) ) ) { course crs = new course ( ) ; crs . setcourseid ( classinfo . getcoursenumber ( ) ) ; crs . setcoursename ( classinfo . getcoursename ( ) ) ; savedatamodify ( crs ) ; } if ( ! classinfo . getcoursesection ( ) . equalsignorecase ( cinfodata . getcoursesection ( ) ) ) { schoolclass cls = new schoolclass ( ) ; cls . setclassnumber ( classinfo . getclassnumber ( ) ) ; cls . setclasssection ( classinfo . getcoursesection ( ) ) ; savedatamodify ( cls ) ; } } }
tr	3	void readfromzip ( string filename ) throws saxexception , transformerconfigurationexception , xmlstreamexception , ioexception { try { zipin = new zipfile ( filename ) ; } catch ( filenotfoundexception e1 ) { e1 . printstacktrace ( ) ; } if ( zipin != null ) { while ( visupages . gettabcount ( ) > 0 ) visupages . removetabat ( 0 ) ; hardwareoptdlg . dispose ( ) ; hardwareoptdlg = new hardwarepropertiesdialog ( this ) ; hardwareoptdlg . setlocation ( 220 , 120 ) ; pictures . cleararchive ( ) ; pictures . loadlibraryfromarchive ( zipin ) ; sounds . cleararchive ( ) ; sounds . loadlibraryfromarchive ( zipin ) ; zipentry visuzipobj = zipin . getentry ( "visu.xml" ) ; inputstream zipinstream = zipin . getinputstream ( visuzipobj ) ; parsexmlstream ( zipinstream ) ; zipin . close ( ) ; } }
tr	5	public boolean recordlogin ( inetaddress origin , string username ) { boolean ret = false ; watch time = new watch ( ) ; string incquery = "update history set lastloginindex = lastloginindex + 1 mod length where username = '" + username + "';" ; string delquery = "delete login from login join history on(login.hid = history.hid) where login.index = ((history.lastloginindex + 1) mod length) and history.username = '" + username + "';" ; string query = "insert into login(hid  ip  month  day  year  `index`  hours  minutes)" + " select hid  inet_aton('" + origin . gethostaddress ( ) + "')  " + time . getmonth ( ) + "  " + time . getdate ( ) + "  " + time . getyear ( ) + "  lastloginindex mod length  " + time . gethours ( ) + "  " + time . getminutes ( ) + " " + "from history " + "where username = '" + username + "';" ; try { connect ( ) ; statement stmt = connection . createstatement ( ) ; stmt . executeupdate ( delquery ) ; connection . setautocommit ( false ) ; stmt . executeupdate ( incquery ) ; stmt . executeupdate ( query ) ; connection . commit ( ) ; ret = true ; } catch ( sqlexception e ) { e . printstacktrace ( ) ; ret = false ; try { if ( connection != null ) connection . rollback ( ) ; } catch ( sqlexception e1 ) { e1 . printstacktrace ( ) ; } } finally { if ( connection != null ) try { connection . setautocommit ( true ) ; } catch ( sqlexception e ) { e . printstacktrace ( ) ; } } return ret ; }
tr	6	public settings ( jpanel content ) { jpanel thecontent = new jpanel ( new gridlayout ( 12 , 1 , 0 , 5 ) ) ; auxbutton . setfocuspainted ( false ) ; radbutton . setfocuspainted ( false ) ; cdbutton . setfocuspainted ( false ) ; climatelabel = new jlabel ( "climate" ) ; climatelabel . setfont ( new font ( "sans serif" , font . bold , 30 ) ) ; climatecontrol . setminortickspacing ( 1 ) ; hashtable labeltable = new hashtable ( ) ; labeltable . put ( new integer ( 0 ) , new jlabel ( "cold" ) ) ; labeltable . put ( new integer ( climate_max ) , new jlabel ( "hot" ) ) ; climatecontrol . setlabeltable ( labeltable ) ; climatecontrol . setpaintlabels ( true ) ; ventlabel = new jlabel ( "ventilation fan" ) ; ventlabel . setfont ( new font ( "sans serif" , font . bold , 30 ) ) ; ventbutton . settext ( "off" ) ; ventbutton . setbackground ( color . decode ( "#ff3333" ) ) ; ventbutton . addactionlistener ( new actionlistener ( ) { boolean active = false ; public void actionperformed ( actionevent e ) { active = active == true ? false : true ; if ( active == true ) { ventbutton . settext ( "on" ) ; ventbutton . setbackground ( color . decode ( "#92cd00" ) ) ; } else { ventbutton . settext ( "off" ) ; ventbutton . setbackground ( color . decode ( "#ff3333" ) ) ; } } } ) ; soundlabel = new jlabel ( "sound" ) ; soundlabel . setfont ( new font ( "sans serif" , font . bold , 30 ) ) ; radiolabel = new jlabel ( "volume" ) ; radiolabel . setfont ( new font ( "sans serif" , font . bold , 16 ) ) ; frequency . settext ( "107.10" ) ; musiccards . add ( radiocard , "radio controller" ) ; musiccards . add ( cdcard , "cd controller" ) ; musiccards . add ( auxcard , "aux controller" ) ; hashtable vollabeltable = new hashtable ( ) ; vollabeltable . put ( new integer ( 0 ) , new jlabel ( "0" ) ) ; vollabeltable . put ( new integer ( 10 ) , new jlabel ( "1" ) ) ; vollabeltable . put ( new integer ( 20 ) , new jlabel ( "2" ) ) ; vollabeltable . put ( new integer ( 30 ) , new jlabel ( "3" ) ) ; vollabeltable . put ( new integer ( 40 ) , new jlabel ( "4" ) ) ; vollabeltable . put ( new integer ( 50 ) , new jlabel ( "5" ) ) ; vollabeltable . put ( new integer ( 60 ) , new jlabel ( "6" ) ) ; vollabeltable . put ( new integer ( 70 ) , new jlabel ( "7" ) ) ; vollabeltable . put ( new integer ( 80 ) , new jlabel ( "8" ) ) ; vollabeltable . put ( new integer ( 90 ) , new jlabel ( "9" ) ) ; vollabeltable . put ( new integer ( 100 ) , new jlabel ( "10" ) ) ; vollabeltable . put ( new integer ( 110 ) , new jlabel ( "11" ) ) ; radvolcontrol . setlabeltable ( vollabeltable ) ; radvolcontrol . setpaintlabels ( true ) ; freqbutton . settext ( "am" ) ; freqbutton . setfocuspainted ( false ) ; freqbutton . setbackground ( color . decode ( "#393939" ) ) ; freqbutton . setforeground ( color . decode ( "#ffffff" ) ) ; freqbutton . addactionlistener ( new actionlistener ( ) { boolean active = false ; public void actionperformed ( actionevent e ) { active = active == true ? false : true ; if ( active == true ) { freqbutton . settext ( "fm" ) ; } else { freqbutton . settext ( "am" ) ; } } } ) ; radbutton . setbackground ( color . decode ( "#92cd00" ) ) ; auxbutton . setbackground ( color . decode ( "#ff3333" ) ) ; cdbutton . setbackground ( color . decode ( "#ff3333" ) ) ; freqlabel = new jlabel ( "frequency:" ) ; freqlabel . setfont ( new font ( "sans serif" , font . bold , 16 ) ) ; jpanel musicbuttons = new jpanel ( new gridlayout ( 1 , 3 ) ) ; radbutton . settext ( "radio" ) ; radbutton . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent e ) { radbutton . setbackground ( color . decode ( "#92cd00" ) ) ; auxbutton . setbackground ( color . decode ( "#ff3333" ) ) ; cdbutton . setbackground ( color . decode ( "#ff3333" ) ) ; cardlayout cl = ( cardlayout ) ( musiccards . getlayout ( ) ) ; cl . show ( musiccards , "radio controller" ) ; } } ) ; musicbuttons . add ( radbutton ) ; auxbutton . settext ( "aux" ) ; auxbutton . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent e ) { auxbutton . setbackground ( color . decode ( "#92cd00" ) ) ; radbutton . setbackground ( color . decode ( "#ff3333" ) ) ; cdbutton . setbackground ( color . decode ( "#ff3333" ) ) ; cardlayout cl = ( cardlayout ) ( musiccards . getlayout ( ) ) ; cl . show ( musiccards , "aux controller" ) ; } } ) ; musicbuttons . add ( auxbutton ) ; cdbutton . settext ( "cd" ) ; cdbutton . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent e ) { cdbutton . setbackground ( color . decode ( "#92cd00" ) ) ; auxbutton . setbackground ( color . decode ( "#ff3333" ) ) ; radbutton . setbackground ( color . decode ( "#ff3333" ) ) ; cardlayout cl = ( cardlayout ) ( musiccards . getlayout ( ) ) ; cl . show ( musiccards , "cd controller" ) ; } } ) ; musicbuttons . add ( cdbutton ) ; radiocard . add ( freqlabel ) ; radiocard . add ( frequency ) ; radiocard . add ( freqbutton ) ; auxcard . add ( new jlabel ( "aux connected..." ) ) ; jpanel cdbuttons = new jpanel ( new gridlayout ( 1 , 6 ) ) ; jbutton playbtn = new jbutton ( "play" ) ; playbtn . setfocuspainted ( false ) ; playbtn . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent e ) { cdstatuslabel . settext ( "playing " + currentsongstr + "..." ) ; } } ) ; cdbuttons . add ( playbtn ) ; jbutton pausebtn = new jbutton ( "pause" ) ; pausebtn . setfocuspainted ( false ) ; pausebtn . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent e ) { cdstatuslabel . settext ( currentsongstr + " paused" ) ; } } ) ; cdbuttons . add ( pausebtn ) ; jbutton stopbtn = new jbutton ( "stop" ) ; stopbtn . setfocuspainted ( false ) ; stopbtn . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent e ) { cdstatuslabel . settext ( currentsongstr + " stopped" ) ; } } ) ; cdbuttons . add ( stopbtn ) ; jbutton prevbtn = new jbutton ( "prev" ) ; prevbtn . setfocuspainted ( false ) ; prevbtn . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent e ) { if ( currentsongstr . equals ( "funky town" ) ) { currentsongstr = "bohemian rhapsody" ; } else { currentsongstr = "funky town" ; } cdstatuslabel . settext ( "playing " + currentsongstr + "..." ) ; } } ) ; cdbuttons . add ( prevbtn ) ; jbutton nextbtn = new jbutton ( "next" ) ; nextbtn . setfocuspainted ( false ) ; nextbtn . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent e ) { if ( currentsongstr . equals ( "funky town" ) ) { currentsongstr = "bohemian rhapsody" ; } else { currentsongstr = "funky town" ; } cdstatuslabel . settext ( "playing " + currentsongstr + "..." ) ; } } ) ; cdbuttons . add ( nextbtn ) ; jbutton eject = new jbutton ( "eject" ) ; eject . setfocuspainted ( false ) ; cdbuttons . add ( eject ) ; cdcard . add ( cdbuttons ) ; cdcard . add ( cdstatuslabel ) ; settings . setfont ( new font ( "sans serif" , font . bold , 30 ) ) ; thecontent . add ( settings ) ; thecontent . add ( climatelabel ) ; thecontent . add ( climatecontrol ) ; thecontent . add ( ventlabel ) ; thecontent . add ( ventbutton ) ; thecontent . add ( soundlabel ) ; thecontent . add ( radiolabel ) ; thecontent . add ( radvolcontrol ) ; thecontent . add ( musicbuttons ) ; thecontent . add ( musiccards ) ; add ( thecontent ) ; }
tr	5	@ override public void dofilter ( servletrequest servletrequest , servletresponse servletresponse , filterchain filterchain ) throws ioexception , servletexception { httpservletrequest request = ( httpservletrequest ) servletrequest ; httpservletresponse response = ( httpservletresponse ) servletresponse ; user session = ( user ) request . getsession ( ) . getattribute ( "user" ) ; string url = request . getrequesturi ( ) ; response . setheader ( "cache-control" , "no-cache  no-store  must-revalidate" ) ; response . setheader ( "pragma" , "no-cache" ) ; response . setdateheader ( "expires" , 0 ) ; if ( session == null ) { if ( url . indexof ( "/content/" ) >= 0 ) { response . sendredirect ( request . getcontextpath ( ) + "/security/login.xhtml" ) ; } else { filterchain . dofilter ( request , response ) ; } } else { if ( url . indexof ( "register.xhtml" ) >= 0 || url . indexof ( "/login.xhtml" ) >= 0 ) { response . sendredirect ( request . getcontextpath ( ) + "../content/news.xhtml" ) ; } else if ( url . indexof ( "logout.xhtml" ) >= 0 ) { request . getsession ( ) . removeattribute ( "user" ) ; response . sendredirect ( request . getcontextpath ( ) + "/login.xhtml" ) ; } else { filterchain . dofilter ( request , response ) ; } } }
tr	8	static int entrance ( list < point > points , int k ) { int size = points . size ( ) ; map < string , integer > indexhash = new hashmap < > ( ) ; map < string , point > pointhash = new hashmap < > ( ) ; for ( int i = 0 ; i < size ; ++ i ) { point p = points . get ( i ) ; indexhash . put ( p . x + " " + p . y , i ) ; pointhash . put ( p . x + " " + p . y , p ) ; } for ( int i = size - 1 ; i >= 0 ; -- i ) { point from = points . get ( i ) ; int max = 0 ; set < point > rangepoints = rangeponints ( from , k , pointhash ) ; for ( point p : rangepoints ) { integer index = indexhash . get ( p . x + " " + p . y ) ; if ( index != null && index > i && p . maxpathvalue > max ) { max = p . maxpathvalue ; } } from . maxpathvalue = max + from . value ; if ( from . x == 0 && from . y == 0 ) return from . maxpathvalue ; } return - 1 ; }
tr	7	public level ( ) { bitmap bmp = art . load ( "/levels/level.png" ) ; int w = bmp . w + 8 ; int h = bmp . h + 8 ; this . w = w ; this . h = h ; xs = w ; ys = h ; blockmap = new blockmap ( w * 16 , h * 16 , 32 ) ; tiles = new int [ xs * ys ] ; for ( int y = 0 ; y < ys ; y ++ ) { for ( int x = 0 ; x < xs ; x ++ ) { int xx = x - 4 ; int yy = y - 4 ; if ( xx < 0 || yy < 0 || xx >= bmp . w || yy >= bmp . h ) { tiles [ x + y * xs ] = 1 ; } else { int col = bmp . pixels [ xx + yy * bmp . w ] ; if ( col == ff000000 ) { tiles [ x + y * xs ] = 1 ; } else { tiles [ x + y * xs ] = 0 ; } } } } redplayer = new player ( this , team . allied ) ; bluplayer = new player ( this , team . soviet ) ; }
tr	4	public static void setapplemenus ( string title ) { try { system . setproperty ( "apple.laf.usescreenmenubar" , "true" ) ; system . setproperty ( "com.apple.mrj.application.apple.menu.about.name" , title ) ; uimanager . setlookandfeel ( uimanager . getsystemlookandfeelclassname ( ) ) ; } catch ( classnotfoundexception e ) { system . out . println ( "classnotfoundexception: " + e . getmessage ( ) ) ; } catch ( instantiationexception e ) { system . out . println ( "instantiationexception: " + e . getmessage ( ) ) ; } catch ( illegalaccessexception e ) { system . out . println ( "illegalaccessexception: " + e . getmessage ( ) ) ; } catch ( unsupportedlookandfeelexception e ) { system . out . println ( "unsupportedlookandfeelexception: " + e . getmessage ( ) ) ; } }
tr	9	public static void main ( string [ ] args ) { try { if ( args . length > 0 ) { for ( string arg : args ) { arg = arg . trim ( ) ; if ( arg . matches ( "app_root_dir=\\s*\\w+\\s*" ) ) { jediormengine . app_root_dir = arg ; } else { jediormengine . app_root_dir = system . getproperty ( "user.dir" ) ; } if ( arg . equals ( "web_app" ) ) { jediormengine . web_app = true ; } if ( arg . matches ( "debug=\\s*true\\s*" ) ) { jediormengine . debug = true ; } else if ( arg . matches ( "debug=\\s*false\\s*" ) ) { jediormengine . debug = false ; } else { } } } else { jediormengine . app_root_dir = system . getproperty ( "user.dir" ) ; } if ( jediormengine . web_app ) { jediormengine . app_src_dir = string . format ( "%s%sweb%sweb-inf%ssrc" , jediormengine . app_root_dir , file . separator , file . separator , file . separator ) ; jediormengine . app_db_config_file = string . format ( "%s%sweb%sweb-inf%sconfig%sdatabase.properties" , jediormengine . app_root_dir , file . separator , file . separator , file . separator , file . separator ) ; file dbconfigfile = new file ( jediormengine . app_db_config_file ) ; if ( ! dbconfigfile . exists ( ) ) { jediormengine . app_db_config_file = string . format ( "%s%sweb%sweb-inf%sdatabase.properties" , jediormengine . app_root_dir , file . separator , file . separator , file . separator ) ; } } else { jediormengine . app_src_dir = string . format ( "%s%ssrc" , jediormengine . app_root_dir , file . separator ) ; jediormengine . app_db_config_file = string . format ( "%s%sdatabase.properties" , jediormengine . app_root_dir , file . separator ) ; } jediormengine . syncdb ( jediormengine . app_src_dir ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } }
tr	5	@ suppresswarnings ( { "unchecked" } ) public static < t > boolean equalslists ( list < t > left , list < t > right , class < t > valuetype ) { if ( left . size ( ) != right . size ( ) ) { return false ; } boolean equals = true ; if ( valuetype . isarray ( ) && valuetype . getcomponenttype ( ) == byte . type ) { for ( int i = 0 ; i < left . size ( ) ; i ++ ) { if ( arrays . equals ( ( byte [ ] ) right . get ( i ) , ( byte [ ] ) left . get ( i ) ) == false ) { equals = false ; break ; } } } else { equals = left . equals ( right ) ; } return equals ; }
tr	5	@ test public void testpacketsending ( ) throws socketexception { microsecondstimestamp stamper = mock ( microsecondstimestamp . class ) ; when ( stamper . timestamp ( ) ) . thenreturn ( 0 ) ; utpalgorithm algorithm = new utpalgorithm ( stamper , new inetsocketaddress ( 51235 ) ) ; utpalgconfiguration . send_in_burst = true ; utpalgconfiguration . max_burst_send = 3 ; int packetlength = 1000 ; algorithm . setmaxwindow ( packetlength * 10 ) ; utptimestampedpacketdto pkt5 = createpacket ( 5 , packetlength ) ; utptimestampedpacketdto pkt6 = createpacket ( 6 , packetlength ) ; utptimestampedpacketdto pkt7 = createpacket ( 7 , packetlength ) ; utptimestampedpacketdto pkt8 = createpacket ( 8 , packetlength ) ; utptimestampedpacketdto pkt9 = createpacket ( 9 , packetlength ) ; algorithm . markpacketonfly ( pkt5 . utppacket ( ) , pkt5 . datagram ( ) ) ; algorithm . markpacketonfly ( pkt6 . utppacket ( ) , pkt6 . datagram ( ) ) ; algorithm . markpacketonfly ( pkt7 . utppacket ( ) , pkt7 . datagram ( ) ) ; algorithm . markpacketonfly ( pkt8 . utppacket ( ) , pkt8 . datagram ( ) ) ; algorithm . markpacketonfly ( pkt9 . utppacket ( ) , pkt9 . datagram ( ) ) ; assertequals ( 5 * ( utppacketutils . def_header_length + packetlength ) , algorithm . getcurrentwindow ( ) ) ; for ( int i = 0 ; i < utpalgconfiguration . max_burst_send ; i ++ ) { assertequals ( true , algorithm . cansendnextpacket ( ) ) ; } assertequals ( false , algorithm . cansendnextpacket ( ) ) ; for ( int i = 0 ; i < utpalgconfiguration . max_burst_send ; i ++ ) { assertequals ( true , algorithm . cansendnextpacket ( ) ) ; } assertequals ( false , algorithm . cansendnextpacket ( ) ) ; algorithm . setmaxwindow ( packetlength * 4 ) ; for ( int i = 0 ; i < utpalgconfiguration . max_burst_send ; i ++ ) { assertequals ( false , algorithm . cansendnextpacket ( ) ) ; } for ( int i = 0 ; i < utpalgconfiguration . max_burst_send ; i ++ ) { assertequals ( false , algorithm . cansendnextpacket ( ) ) ; } algorithm . setmaxwindow ( 10 * packetlength ) ; for ( int i = 0 ; i < utpalgconfiguration . max_burst_send ; i ++ ) { assertequals ( true , algorithm . cansendnextpacket ( ) ) ; } assertequals ( false , algorithm . cansendnextpacket ( ) ) ; }
tr	3	private int compareinputstreams ( inputstream encfsis , inputstream decfsis , string decodedfsfilename ) throws ioexception { int bytesread = 0 ; int bytesread2 ; while ( bytesread >= 0 ) { byte [ ] readbuf = new byte [ 128 ] ; byte [ ] readbuf2 = new byte [ 128 ] ; bytesread = encfsis . read ( readbuf ) ; bytesread2 = decfsis . read ( readbuf2 ) ; if ( bytesread != bytesread2 ) { logger . error ( "file bytes read missmatch {} ({}  {})" , new object [ ] { decodedfsfilename , bytesread , bytesread2 } ) ; return - 1 ; } if ( ! arrays . equals ( readbuf , readbuf2 ) ) { logger . error ( "file bytes missmatch {}" , decodedfsfilename ) ; return - 1 ; } } return 0 ; }
tr	3	private void drawlines ( graphics g , treenode [ ] nodes ) { graphics2d g2d = ( graphics2d ) g ; g2d . setcolor ( color . black ) ; g2d . setstroke ( new basicstroke ( line_thickness ) ) ; for ( int i = 1 ; i < nodes . length ; i ++ ) { try { g2d . drawline ( nodes [ i ] . centerx , nodes [ i ] . centery , nodes [ 2 * i ] . centerx , nodes [ 2 * i ] . centery ) ; } catch ( arrayindexoutofboundsexception ex ) { } try { g2d . drawline ( nodes [ i ] . centerx , nodes [ i ] . centery , nodes [ 2 * i + 1 ] . centerx , nodes [ 2 * i + 1 ] . centery ) ; } catch ( arrayindexoutofboundsexception ex ) { } } }
tr	5	public double readdouble ( string prompt , double low , double high ) { string msg = null ; while ( true ) { string line = readline ( prompt ) ; try { double d = double . valueof ( line ) . doublevalue ( ) ; if ( d >= low && d <= high ) return d ; msg = "value is outside the range [" + low + ":" + high + "]" ; } catch ( numberformatexception ex ) { msg = "illegal numeric format" ; } showerrormessage ( msg ) ; if ( prompt == null ) prompt = "retry: " ; } }
tr	1	public static void compare ( map < string , arraylist < string >> pchecksumseta , map < string , arraylist < string >> pchecksumsetb , file preportfile ) throws ioexception { checksumseta = pchecksumseta ; checksumsetb = pchecksumsetb ; if ( preportfile != null ) { printwriter = new printwriter ( new filewriter ( preportfile ) ) ; } else { printwriter = null ; } out ( "entries in set 1: " + checksumseta . keyset ( ) . size ( ) ) ; out ( "entries in set 2: " + checksumsetb . keyset ( ) . size ( ) ) ; diff ( new file ( "set 1" ) , new file ( "set 1" ) ) ; cleanup ( ) ; }
tr	4	@ override public void notifysample ( sample s ) { switch ( mode ) { case classifying : system . out . println ( "add sample to classify" ) ; gesture g = classifier . classifysample ( s ) ; gui . showclassifiedgesture ( g ) ; break ; case idle : system . out . println ( "idle sample" ) ; break ; case recording : break ; case training : system . out . println ( "add training sample" ) ; gesture currentgesture = gui . getcurrentgesture ( ) ; trainer . addsample ( s , currentgesture ) ; break ; default : break ; } }
tr	5	@ suppresswarnings ( "unchecked" ) public static void main ( string args [ ] ) { repl < ? , ? > repl ; if ( args . length == 0 ) { repl = new repl < > ( fractalevaluator . class ) ; repl . loop ( ) ; } else { try { repl = new repl ( class . forname ( args [ 0 ] ) ) ; arraylist < string > filelist = new arraylist < > ( ) ; for ( int i = 1 ; i < args . length ; i ++ ) { filelist . add ( args [ i ] ) ; } repl . visitfiles ( filelist ) ; repl . loop ( ) ; } catch ( classnotfoundexception cnfe ) { system . err . println ( cnfe . getmessage ( ) ) ; system . exit ( 1 ) ; } } }
tr	7	void prune ( file [ ] files ) { int size = 0 ; for ( file file : files ) { if ( file . isfile ( ) && ! file . getname ( ) . equals ( "fat" ) ) { size += file . length ( ) ; } } int cnt = 0 ; int limit = globals . getcachelimit ( ) ; while ( size > limit && cnt < files . length ) { file current = files [ cnt ++ ] ; if ( current . isfile ( ) && ! current . getname ( ) . equals ( "fat" ) ) { size -= current . length ( ) ; current . delete ( ) ; } } fileuse . set ( size ) ; updateguidisk ( ) ; }
tr	7	private bufferedimage getview ( ) { if ( this . getwidth ( ) > 0 && this . getheight ( ) > 0 ) { int mapsize = ( mapimage_scaled . getheight ( ) ) ; if ( viewport . x + this . getwidth ( ) > mapsize ) { int movexby = viewport . x + this . getwidth ( ) - mapsize ; moveview ( - movexby , 0 ) ; } if ( viewport . y + this . getheight ( ) > mapsize ) { int moveyby = viewport . y + this . getheight ( ) - mapsize ; moveview ( 0 , - moveyby ) ; } int windowheight = this . getheight ( ) ; int windowwidth = this . getwidth ( ) ; if ( this . getheight ( ) > mapimage_scaled . getheight ( ) ) { windowheight = mapimage_scaled . getheight ( ) ; viewport . y = 0 ; } if ( this . getwidth ( ) > mapimage_scaled . getwidth ( ) ) { windowwidth = mapimage_scaled . getwidth ( ) ; viewport . x = 0 ; } mapimage_view = null ; try { mapimage_view = mapimage_unitandbuildingsscaled . getsubimage ( viewport . x , viewport . y , windowwidth , windowheight ) ; } catch ( exception e ) { system . err . println ( "error creating subview!" ) ; } } return mapimage_view ; }
tr	2	public arraylist < identifier > getfreebeds ( identifier hostelid , date checkin , date checkout ) throws databasereadwriteexception , identifiernotfoundexception , invalididentifierexception , invalidparameterexception { arraylist < identifier > freebedids = new arraylist < identifier > ( ) ; hostel hostelinfo = hostels . getinstance ( ) . get ( hostelid ) ; iterator < identifier > beditr = hostelinfo . getbeds ( ) . iterator ( ) ; while ( beditr . hasnext ( ) ) { identifier bedid = beditr . next ( ) ; if ( beds . getinstance ( ) . isbedavailable ( bedid , checkin , checkout , false ) ) { freebedids . add ( bedid ) ; } } return freebedids ; }
tr	6	public audiodevice createaudiodevice ( ) throws javalayerexception { audiodevice device = null ; audiodevicefactory [ ] factories = getfactoriespriority ( ) ; if ( factories == null ) throw new javalayerexception ( this + ": no factories registered" ) ; javalayerexception lastex = null ; for ( int i = 0 ; ( device == null ) && ( i < factories . length ) ; i ++ ) { try { device = factories [ i ] . createaudiodevice ( ) ; } catch ( javalayerexception ex ) { lastex = ex ; } } if ( device == null && lastex != null ) { throw new javalayerexception ( "cannot create audiodevice" , lastex ) ; } return device ; }
tr	4	public static boolean writesalesorder ( messageheader header , list < com . adammargherio . xml . schemas . salesorder . lineitem > items ) { if ( conn == null ) { getconnection ( ) ; } try { string sql = "insert into tbletsalesheader values (? ? ? ? ? ? ?)" ; preparedstatement peheader = conn . preparestatement ( sql ) ; } catch ( sqlexception sqle ) { sqle . printstacktrace ( ) ; } for ( com . adammargherio . xml . schemas . salesorder . lineitem l : items ) { try { string item = "insert into tbletsalesdetail values (? ? ? ? ? ?)" ; preparedstatement peitem = conn . preparestatement ( item ) ; peitem . setstring ( 1 , l . getlineno ( ) ) ; peitem . setstring ( 2 , l . getitemcode ( ) ) ; peitem . setstring ( 3 , l . getproductname ( ) ) ; peitem . setint ( 4 , l . getquantity ( ) . intvalue ( ) ) ; peitem . setstring ( 5 , l . getunitofmeasure ( ) ) ; peitem . setint ( 6 , l . getbaseprice ( ) . intvalue ( ) ) ; peitem . execute ( ) ; conn . commit ( ) ; } catch ( sqlexception sqle ) { sqle . printstacktrace ( ) ; } } return true ; }
tr	6	submapiterator ( coord startcoord , int rangex , int rangey ) { this . latodellamappaiterator = getlatodellamappa ( ) ; if ( ! ( 0 <= startcoord . getx ( ) ) || ! ( 0 <= startcoord . gety ( ) ) || ! ( startcoord . getx ( ) < latodellamappaiterator ) || ! ( startcoord . gety ( ) < latodellamappaiterator ) || ! ( 0 <= rangex ) || ! ( 0 <= rangey ) ) throw new indexoutofboundsexception ( ) ; this . startrow = startcoord . gety ( ) ; this . startcolumn = startcoord . getx ( ) ; this . rowrange = rangey ; this . columnrange = rangex ; this . latodellamappaiterator = getlatodellamappa ( ) ; curcoord = new coord ( startcolumn , startrow ) ; }
tr	7	public synchronized void tick ( ) { handleevents ( ) ; updateworkers ( ) ; for ( sponsor sponsor : new arraylist < sponsor > ( sponsors ) ) { if ( sponsor . getmsleft ( ) <= 0 ) sponsors . remove ( sponsor ) ; } random r = new random ( ) ; if ( sponsors . size ( ) < max_sponsors && r . nextint ( ( int ) ( 1500 / math . log ( getrenown ( ) + 2 ) ) ) == 0 ) { addsponsor ( ) ; } if ( getrenown ( ) <= 0 ) { showwindow ( null , new gameoverwindow ( ) ) ; } if ( r . nextint ( difficulty ) == 0 ) { setrenown ( getrenown ( ) - 1 ) ; } if ( firsttick ) showwindow ( null , new helpwindow ( ) ) ; firsttick = false ; }
tr	3	@ override public void process ( ) { string [ ] s = curdir . list ( strings . getstringfilter ( ) . getfilenamefilter ( ) ) ; int cs = 0 , cf = 0 ; for ( int i = 0 ; i < s . length ; i ++ ) { string x = strings . substitute ( s [ i ] ) ; string t = s [ i ] + " => " + x ; if ( ! ispreview ) t += new file ( curdir , s [ i ] ) . renameto ( new file ( curdir , x ) ) ? " ok " + ++ cs : " fail " + ++ cf ; print . ln ( t ) ; } print . ln ( "total " + s . length + " files  " + cs + " success  " + cf + " fail" ) ; }
tr	6	@ override public object getvalueat ( int row , int column ) { vehicle vehicle = vehicles . elementat ( row ) ; switch ( column ) { case 0 : return vehicle . getlicenceplate ( ) ; case 1 : return vehicle . getstartdate ( ) ; case 2 : return vehicle . getowner ( ) . getfirstname ( ) + " " + vehicle . getowner ( ) . getfamilyname ( ) . touppercase ( ) ; case 3 : return vehicle . getmodel ( ) . getdesignation ( ) ; case 4 : if ( this . deleteicon == null ) { return "supprimer" ; } return this . deleteicon ; default : break ; } return null ; }
tr	6	@ override public boolean prehandle ( httpservletrequest request , httpservletresponse response , object handler ) throws exception { string uri = request . getrequesturi ( ) ; if ( ! uri . endswith ( "index.htm" ) && ! uri . endswith ( "login.htm" ) && ! uri . endswith ( "logout.htm" ) ) { login userdata = ( login ) request . getsession ( ) . getattribute ( login . class . getname ( ) ) ; if ( userdata == null || util . nulloremptyorblank ( userdata . getemail ( ) ) || ( new date ( ) . gettime ( ) - userdata . getlastaccessed ( ) ) > 30 * 60 * 1000 ) { response . sendredirect ( "index.htm" ) ; return false ; } else { userdata . setlastaccessed ( new date ( ) . gettime ( ) ) ; } } return true ; }
tr	7	public registeredeventmonitor ( method monitormethod , listener listener ) { eventmonitor monitorannotation = monitormethod . getannotation ( eventmonitor . class ) ; if ( monitorannotation == null ) { throw new illegalargumentexception ( "monitor method does not have an eventmonitor annotation." ) ; } class < ? > [ ] monitormethodparameters = monitormethod . getparametertypes ( ) ; if ( monitormethodparameters . length != 2 || ! event . class . isassignablefrom ( monitormethodparameters [ 0 ] ) || ! result . class . isassignablefrom ( monitormethodparameters [ 1 ] ) ) { throw new illegalargumentexception ( "monitor method signature is invalid. cannot accept (event  result)." ) ; } eventtype = ( class < ? extends event > ) monitormethodparameters [ 0 ] ; this . monitormethod = monitormethod ; if ( ! monitormethod . isaccessible ( ) ) { monitormethod . setaccessible ( true ) ; } this . listener = listener ; }
tr	3	public string look ( ) { stringbuffer names = new stringbuffer ( ) ; string items = currroom . getitemnames ( ) ; string monsters = currroom . getmonsternames ( ) ; if ( ! items . equals ( "" ) ) { names . append ( "items: " ) ; names . append ( items ) ; } if ( ! monsters . equals ( "" ) ) { if ( ! ( names . length ( ) == 0 ) ) { names . append ( "\n" ) ; } names . append ( "monsters: " ) ; names . append ( monsters ) ; } return names . tostring ( ) ; }
tr	2	private static void loadconfig ( ) { vmconfiguration . config = new vmconfiguration ( ) ; inputstream conf_file ; try { conf_file = new fileinputstream ( new file ( conf_file ) ) ; properties props = new properties ( ) ; props . load ( conf_file ) ; config . weightnumber = integer . parseint ( props . getproperty ( constants . weight_number ) ) ; config . learnfilename = props . getproperty ( constants . learn_file_name ) ; config . topologymodeltype = props . getproperty ( constants . topology_model ) ; config . rows = integer . parseint ( props . getproperty ( constants . rows ) ) ; config . cols = integer . parseint ( props . getproperty ( constants . cols ) ) ; config . radius = integer . parseint ( props . getproperty ( constants . radius ) ) ; config . numberofweights = integer . parseint ( props . getproperty ( constants . number_of_weights ) ) ; config . maxweight = integer . parseint ( props . getproperty ( constants . max_weight ) ) ; config . maxiteration = integer . parseint ( props . getproperty ( constants . max_iteration ) ) ; config . trainmetrictype = props . getproperty ( constants . train_metric_type ) ; config . predictmetrictype = props . getproperty ( constants . predict_metric_type ) ; config . learningfactor = integer . parseint ( props . getproperty ( constants . learn_factor ) ) ; config . neighbourfactor = double . parsedouble ( props . getproperty ( constants . neighbour_factor ) ) ; config . kfoldvalue = integer . parseint ( props . getproperty ( constants . k_fold_value ) ) ; config . delimiter = props . getproperty ( constants . delimiter ) ; config . pythonfilelocation = props . getproperty ( constants . python_file ) ; config . normalizedfilename = props . getproperty ( constants . normalized_file ) ; config . normalneurons = integer . parseint ( props . getproperty ( constants . normal_neurons ) ) ; config . predictdatafile = props . getproperty ( constants . predict_data_file ) ; config . lookaheadsize = integer . parseint ( props . getproperty ( constants . look_ahead_size ) ) ; config . predictaheadstep = integer . parseint ( props . getproperty ( constants . predict_ahead_step ) ) ; config . gaussianheight = integer . parseint ( props . getproperty ( constants . gaussian_height ) ) ; config . mem_log_file = props . getproperty ( constants . mem_log_file ) ; config . metric_log_file = props . getproperty ( constants . metric_log_file ) ; config . train_mem_log_file = props . getproperty ( constants . train_mem_log_file ) ; config . train_metric_log_file = props . getproperty ( constants . train_metric_log_file ) ; config . dotest = integer . parseint ( props . getproperty ( constants . do_test ) ) ; config . vm_name = props . getproperty ( constants . vm_name ) ; config . predictfile = props . getproperty ( constants . predict_file ) ; config . annotatefile = props . getproperty ( constants . ann_file ) ; config . faultinterval = integer . parseint ( props . getproperty ( constants . fault ) ) ; } catch ( filenotfoundexception e ) { logger . error ( "error while opening configuration file" ) ; } catch ( ioexception e ) { logger . error ( "error while loading configuration file" ) ; } }
tr	8	public static void main ( final string [ ] args ) throws filenotfoundexception { final printwriter out = new printwriter ( merge . class . getpackage ( ) . getname ( ) . replace ( "." , "/" ) + "/merged.txt" ) ; final string [ ] results = new string [ 5000 ] ; for ( final file file : new file ( merge . class . getpackage ( ) . getname ( ) . replace ( "." , "/" ) ) . listfiles ( new filefilter ( ) { @ override public boolean accept ( final file file ) { return file . getname ( ) . matches ( "output.txt|43.66-ok" ) ; } } ) ) { logger . getlogger ( merge . class . getname ( ) ) . log ( level . info , "file = {0}" , file ) ; final scanner scanner = new scanner ( file ) ; for ( int i = 0 ; i < 5000 ; i ++ ) { if ( scanner . hasnextline ( ) ) { final string line = scanner . nextline ( ) ; if ( results [ i ] == null ) { results [ i ] = line ; } else { if ( results [ i ] . isempty ( ) || line . length ( ) > 0 && line . length ( ) < results [ i ] . length ( ) ) { results [ i ] = line ; } } } } scanner . close ( ) ; } for ( final string line : results ) { out . println ( line ) ; } out . close ( ) ; }
tr	6	private void readpolar ( ) throws ioexception { long currtime ; while ( isread ) { currtime = system . currenttimemillis ( ) ; int msg = inputstream . read ( ) ; if ( msg == 254 ) { printmessage ( "\n" + system . currenttimemillis ( ) + ": " ) ; polarmessagetmp = new polarmessage ( system . currenttimemillis ( ) ) ; } else if ( msg == - 1 ) { system . out . println ( "roz\u0142\u0105czono" ) ; stopread ( ) ; break ; } else if ( polarmessagetmp != null && polarmessagetmp . setnextvalue ( msg ) ) { message = new polarmessage ( system . currenttimemillis ( ) ) ; message . sethr ( polarmessagetmp . gethr ( ) ) ; } if ( currtime - system . currenttimemillis ( ) > 3000 ) { system . out . println ( "zbyt d\u0142ugi czas oczekiwania" ) ; } printmessage ( " " + msg ) ; } }
tr	1	public mainmenuview ( checkmate c ) { super ( c ) ; jlabel titlelabel = new jlabel ( "checkmate 3000 network ai edition" ) ; titlelabel . setforeground ( color . white ) ; titlelabel . setfont ( new font ( font . sans_serif , font . plain , 42 ) ) ; titlelabel . setsize ( 680 , 50 ) ; titlelabel . setlocation ( c . getwidth ( ) / 2 - titlelabel . getwidth ( ) / 2 , ( int ) ( c . getheight ( ) * 0.200 ) ) ; add ( titlelabel ) ; jbutton localbutton = new jbutton ( "local game" ) ; localbutton . setsize ( 150 , 35 ) ; localbutton . setlocation ( c . getwidth ( ) / 2 - localbutton . getwidth ( ) / 2 , ( int ) ( c . getheight ( ) * 0.480 ) ) ; localbutton . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent ae ) { mycheckmate . setview ( checkmate . local ) ; } } ) ; add ( localbutton ) ; jbutton hostbutton = new jbutton ( "host game" ) ; hostbutton . setsize ( 150 , 35 ) ; hostbutton . setlocation ( c . getwidth ( ) / 2 - hostbutton . getwidth ( ) / 2 , ( int ) ( c . getheight ( ) * 0.555 ) ) ; hostbutton . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent ae ) { mycheckmate . setview ( checkmate . host ) ; } } ) ; add ( hostbutton ) ; jbutton joinbutton = new jbutton ( "join game" ) ; joinbutton . setsize ( 150 , 35 ) ; joinbutton . setlocation ( c . getwidth ( ) / 2 - joinbutton . getwidth ( ) / 2 , ( int ) ( c . getheight ( ) * 0.630 ) ) ; joinbutton . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent ae ) { mycheckmate . setview ( checkmate . join ) ; } } ) ; add ( joinbutton ) ; jbutton logbutton = new jbutton ( "view logged game" ) ; logbutton . setsize ( 150 , 35 ) ; logbutton . setlocation ( c . getwidth ( ) / 2 - logbutton . getwidth ( ) / 2 , ( int ) ( c . getheight ( ) * 0.705 ) ) ; logbutton . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent ae ) { mycheckmate . setview ( checkmate . log ) ; } } ) ; add ( logbutton ) ; jbutton quitbutton = new jbutton ( "quit game" ) ; quitbutton . setsize ( 150 , 35 ) ; quitbutton . setlocation ( c . getwidth ( ) / 2 - quitbutton . getwidth ( ) / 2 , ( int ) ( c . getheight ( ) * 0.780 ) ) ; quitbutton . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent ae ) { int wantsexit = joptionpane . showconfirmdialog ( mycheckmate , "are you sure you want to exit the program?" , "exit program?" , joptionpane . yes_no_option ) ; if ( wantsexit == joptionpane . yes_option ) { system . exit ( 0 ) ; } } } ) ; add ( quitbutton ) ; }
tr	3	public int iterer ( int nb_plots , double vitesse , double intervalle_de_temps ) { int plot_indice = 1 , plots_restants = nb_plots ; this . plots = new arraylist < plot > ( ) ; this . distance_parcourue += this . vecteur_vitesse . getmodule ( ) ; if ( this . distance_parcourue >= this . distance_totale ) { this . distance_restante = this . distance_parcourue - this . distance_totale ; this . distance_parcourue = this . distance_totale ; this . totalement_parcouru = true ; } this . position_courante . deplacerde ( this . vecteur_vitesse ) ; this . plots . add ( new plot ( this . position_courante ) ) ; if ( nb_plots <= 1 ) return nb_plots ; for ( plot_indice = 0 ; plot_indice < nb_plots - 1 ; plot_indice ++ ) { this . plots . add ( this . plots . get ( plot_indice ) . suivant ( this . vecteur_vitesse ) ) ; plots_restants -- ; } return plots_restants ; }
tr	8	@ override public void computeperformancemeasures ( ) throws internalerrorexception { totaltimer . start ( ) ; bigrational [ ] x = new bigrational [ qnm . r ] ; bigrational [ ] [ ] q = new bigrational [ qnm . m ] [ qnm . r ] ; if ( lastg [ 0 ] . isundefined ( ) ) { throw new internalerrorexception ( ( "singular system. cannot compute performance indices." ) ) ; } for ( int i = 0 ; i < qnm . m ; i ++ ) { for ( int r = 0 ; r < qnm . r - 1 ; r ++ ) { if ( ! lastg [ sz * ( r + 1 ) + i + 1 ] . isundefined ( ) ) { q [ i ] [ r ] = qnm . getdemandasbigrational ( i , r ) . multiply ( lastg [ sz * ( r + 1 ) + i + 1 ] ) . divide ( lastg [ 0 ] ) ; } else { throw new internalerrorexception ( ( "singular system. cannot compute performance indices." ) ) ; } } if ( ! prevg [ i + 1 ] . isundefined ( ) ) { q [ i ] [ qnm . r - 1 ] = qnm . getdemandasbigrational ( i , qnm . r - 1 ) . multiply ( prevg [ i + 1 ] ) . divide ( lastg [ 0 ] ) ; } else { throw new internalerrorexception ( ( "singular system. cannot compute performance indices." ) ) ; } } for ( int r = 0 ; r < qnm . r - 1 ; r ++ ) { if ( ! lastg [ sz * ( r + 1 ) ] . isundefined ( ) ) { x [ r ] = lastg [ sz * ( r + 1 ) ] . divide ( lastg [ 0 ] ) ; } else { throw new internalerrorexception ( ( "singular system. cannot compute performance indices." ) ) ; } } if ( ! prevg [ 0 ] . isundefined ( ) ) { x [ qnm . r - 1 ] = prevg [ 0 ] . divide ( lastg [ 0 ] ) ; } else { throw new internalerrorexception ( ( "singular system. cannot compute performance indices." ) ) ; } totaltimer . pause ( ) ; qnm . setperformancemeasures ( q , x ) ; }
tr	4	public static armour createarmourfromreader ( string armourstring ) { string [ ] values = armourstring . split ( " " ) ; armour armour = new armour ( ) ; try { armour . setname ( values [ 0 ] ) ; armour . setcost ( integer . parseint ( values [ 1 ] ) ) ; armour . setweight ( integer . parseint ( values [ 2 ] ) ) ; armour . setac ( integer . parseint ( values [ 3 ] ) ) ; if ( values . length == 5 && values [ 4 ] != "" ) { string [ ] specials = values [ 4 ] . split ( " " ) ; armour = armour . applyspecialtraits ( armour , specials ) ; } } catch ( exception e ) { system . out . println ( "error reading armour object" ) ; if ( armour . getname ( ) != null ) system . out . println ( armour . getname ( ) + " has some incorrect parameter." ) ; return null ; } return armour ; }
tr	8	@ override public void actionperformed ( actionevent e ) { string cmd = e . getactioncommand ( ) ; switch ( cmd ) { case filtrar : ctrlinformacion . filtrarcontratos ( ) ; break ; case notas_apto_ver : ctrlinformacion . cargardialogovernotasparticulares ( ) ; break ; case notas_gral_ver : ctrlinformacion . cargardialogovernotasgenerales ( ) ; break ; case nota_apto_nuevo : ctrlinformacion . cargardialogonuevanotaparticular ( ) ; break ; case nota_gral_nuevo : ctrlinformacion . cargardialogonuevanotageneral ( ) ; break ; case recargar_contratos : ctrlinformacion . cargarcontratos ( ) ; break ; case ver_datos_responsables : ctrlinformacion . cargardialogoverdatosresponsables ( ) ; break ; case ver_telefonos : ctrlinformacion . cargardialogovertelefonos ( ) ; break ; } }
tr	1	@ override public void init ( ) { qidtf = new jtextfield ( ) ; label = new jlabel ( ) ; setlayout ( new borderlayout ( ) ) ; add ( "north" , new jlabel ( "quest id" ) ) ; add ( "center" , qidtf ) ; add ( "south" , label ) ; label . setforeground ( color . red ) ; qidtf . getdocument ( ) . adddocumentlistener ( new questexistslistener ( getfinishbutton ( ) ) { public boolean update ( documentevent e ) { boolean a = super . update ( e ) ; if ( a == false ) label . settext ( "this quest doesn't exist." ) ; else label . settext ( "" ) ; return a ; } } ) ; }
tr	3	private void checkconvexcut ( point [ ] points , point a , point n ) { point [ ] [ ] hullp = convexcut ( convexhull ( points ) , a , n ) ; system . out . println ( arrays . deeptostring ( hullp ) ) ; asserttrue ( isconvex ( hullp ) ) ; for ( point p : points ) { int type = isinconvex ( p , hullp ) ; double d = a . subtract ( p ) . . ( n ) ; if ( approxequals ( d , 0 ) ) asserttrue ( type == 2 ) ; else if ( d > 0 ) asserttrue ( type != 0 ) ; else asserttrue ( type == 0 ) ; } }
tr	3	private void switchmap ( stairtile stairs ) { point oldpt = stairs . getpa ( ) ; point nextpt = stairs . getpb ( ) ; map nextmap = stairs . getmapb ( ) ; tile nextlocation = nextmap . gettile ( nextpt . x , nextpt . y ) ; player . setlocation ( nextlocation ) ; stairs . getmapa ( ) . gettile ( oldpt . x , oldpt . y ) . removeoccupant ( ) ; stairs . getmapb ( ) . gettile ( nextpt . x , nextpt . y ) . setoccupant ( player ) ; if ( player . getfuturesightcounter ( ) > 0 ) this . revealmap ( false ) ; this . map = nextmap ; messenger . drawmap ( nextmap ) ; messenger . updatetile ( nextpt ) ; resettimequeue ( ) ; if ( player . getfuturesightcounter ( ) > 0 ) this . revealmap ( true ) ; if ( nextmap . gettag ( ) != null ) { messenger . showtextdialog ( gametext . gettext ( nextmap . gettag ( ) ) , nextmap . gettag ( ) ) ; player . settextcollected ( player . gettextcollected ( ) + 1 ) ; nextmap . settag ( null ) ; } messenger . centermap ( nextpt ) ; }
tr	5	private static void loadversionproperties ( ) { classloader loader = releaseinfo . class . getclassloader ( ) ; properties info = new properties ( ) ; inputstream stream = loader . getresourceasstream ( property_file ) ; if ( stream == null ) stream = loader . getresourceasstream ( "/" + property_file ) ; if ( stream != null ) { try { info . load ( stream ) ; stream . close ( ) ; buildversion = info . getproperty ( "version" ) ; builddate = info . getproperty ( "build.date" ) ; } catch ( ioexception e ) { } } if ( buildversion == null ) buildversion = "unknown" ; if ( builddate == null ) builddate = "unknown" ; }
tr	2	public void paint ( graphics g , int width ) { int xpos = ( width - 251 ) / 2 ; g . setcolor ( color . black ) ; g . draw3drect ( xpos , 420 , 251 , 20 , true ) ; for ( int tmp = 0 ; tmp < this . points ; tmp = tmp + 10 ) { if ( tmp < 100 ) { g . setcolor ( new color ( 60 + ( tmp + 10 ) / 2 , 26 , 26 ) ) ; } else { g . setcolor ( new color ( 110 , 26 + ( tmp - 90 ) / 2 , 26 ) ) ; } g . fillrect ( xpos + 1 + tmp / 2 , 421 , 5 , 19 ) ; } }
tr	0	private void initcomponents ( ) { this . blackbox = new jpanel ( ) ; this . redbox = new jpanel ( ) ; this . bluebox = new jpanel ( ) ; this . greenbox = new jpanel ( ) ; this . yellowbox = new jpanel ( ) ; this . orangebox = new jpanel ( ) ; this . letterlabel = new letterpanel ( ) ; this . colourspanel = new jpanel ( ) ; this . blacklabel = new jlabel ( ) ; this . redlabel = new jlabel ( ) ; this . greenlabel = new jlabel ( ) ; this . bluelabel = new jlabel ( ) ; this . yellowlabel = new jlabel ( ) ; this . orangelabel = new jlabel ( ) ; this . colourspanel . setlayout ( new gridbaglayout ( ) ) ; gridbagconstraints c = new gridbagconstraints ( ) ; c . gridx = 0 ; c . gridy = 0 ; c . insets = new insets ( 5 , 5 , 5 , 5 ) ; this . colourspanel . add ( blackbox , c ) ; c . gridx = 1 ; c . gridy = 0 ; this . colourspanel . add ( blacklabel , c ) ; c . gridx = 0 ; c . gridy = 1 ; this . colourspanel . add ( redbox , c ) ; c . gridx = 1 ; c . gridy = 1 ; this . colourspanel . add ( redlabel , c ) ; c . gridx = 0 ; c . gridy = 2 ; this . colourspanel . add ( greenbox , c ) ; c . gridx = 1 ; c . gridy = 2 ; this . colourspanel . add ( greenlabel , c ) ; c . gridx = 2 ; c . gridy = 0 ; c . insets = new insets ( 5 , 50 , 5 , 5 ) ; this . colourspanel . add ( bluebox , c ) ; c . gridx = 3 ; c . gridy = 0 ; c . insets = new insets ( 5 , 5 , 5 , 5 ) ; this . colourspanel . add ( bluelabel , c ) ; c . gridx = 2 ; c . gridy = 1 ; c . insets = new insets ( 5 , 50 , 5 , 5 ) ; this . colourspanel . add ( yellowbox , c ) ; c . gridx = 3 ; c . gridy = 1 ; c . insets = new insets ( 5 , 5 , 5 , 5 ) ; this . colourspanel . add ( yellowlabel , c ) ; c . gridx = 2 ; c . gridy = 2 ; c . insets = new insets ( 5 , 50 , 5 , 5 ) ; this . colourspanel . add ( orangebox , c ) ; c . gridx = 3 ; c . gridy = 2 ; c . insets = new insets ( 5 , 5 , 5 , 5 ) ; this . colourspanel . add ( orangelabel , c ) ; this . setdefaultcloseoperation ( windowconstants . exit_on_close ) ; this . blackbox . setbackground ( systemproperties . colour_map . get ( colourtype . black ) ) ; this . blackbox . setborder ( borderfactory . createlineborder ( new java . awt . color ( 0 , 0 , 0 ) ) ) ; this . blackbox . setpreferredsize ( new dimension ( 30 , 30 ) ) ; this . redbox . setbackground ( systemproperties . colour_map . get ( colourtype . red ) ) ; this . redbox . setborder ( borderfactory . createlineborder ( new java . awt . color ( 0 , 0 , 0 ) ) ) ; this . redbox . setpreferredsize ( new dimension ( 30 , 30 ) ) ; this . greenbox . setbackground ( systemproperties . colour_map . get ( colourtype . green ) ) ; this . greenbox . setborder ( borderfactory . createlineborder ( new java . awt . color ( 0 , 0 , 0 ) ) ) ; this . greenbox . setpreferredsize ( new dimension ( 30 , 30 ) ) ; this . bluebox . setbackground ( systemproperties . colour_map . get ( colourtype . blue ) ) ; this . bluebox . setborder ( borderfactory . createlineborder ( new java . awt . color ( 0 , 0 , 0 ) ) ) ; this . bluebox . setpreferredsize ( new dimension ( 30 , 30 ) ) ; this . yellowbox . setbackground ( systemproperties . colour_map . get ( colourtype . yellow ) ) ; this . yellowbox . setborder ( borderfactory . createlineborder ( new java . awt . color ( 0 , 0 , 0 ) ) ) ; this . yellowbox . setpreferredsize ( new dimension ( 30 , 30 ) ) ; this . orangebox . setbackground ( systemproperties . colour_map . get ( colourtype . orange ) ) ; this . orangebox . setborder ( borderfactory . createlineborder ( new java . awt . color ( 0 , 0 , 0 ) ) ) ; this . orangebox . setpreferredsize ( new dimension ( 30 , 30 ) ) ; this . letterlabel . setbackground ( systemproperties . white ) ; this . letterlabel . setborder ( borderfactory . createlineborder ( new java . awt . color ( 0 , 0 , 0 ) ) ) ; this . blacklabel . settext ( "s" ) ; this . blacklabel . setfont ( new font ( "arial" , font . plain , 28 ) ) ; this . redlabel . settext ( "r" ) ; this . redlabel . setfont ( new font ( "arial" , font . plain , 28 ) ) ; this . greenlabel . settext ( "g" ) ; this . greenlabel . setfont ( new font ( "arial" , font . plain , 28 ) ) ; this . bluelabel . settext ( "b" ) ; this . bluelabel . setfont ( new font ( "arial" , font . plain , 28 ) ) ; this . yellowlabel . settext ( "y" ) ; this . yellowlabel . setfont ( new font ( "arial" , font . plain , 28 ) ) ; this . orangelabel . settext ( "o" ) ; this . orangelabel . setfont ( new font ( "arial" , font . plain , 28 ) ) ; this . setjmenubar ( stroopmenu ) ; this . add ( this . letterlabel , borderlayout . center ) ; this . add ( this . colourspanel , borderlayout . south ) ; this . settitle ( "stroop test" ) ; this . addcomponentlistener ( this ) ; this . setpreferredsize ( new dimension ( 800 , 600 ) ) ; this . setlocation ( ( systemproperties . screen_width / 2 ) - 400 , ( systemproperties . screen_height / 2 ) - 300 ) ; this . pack ( ) ; }
tr	8	public void connect1 ( treelinknode root ) { if ( root == null ) return ; queue < treelinknode > curlev = new linkedlist < treelinknode > ( ) ; curlev . add ( root ) ; while ( ! curlev . isempty ( ) ) { queue < treelinknode > nextlev = new linkedlist < treelinknode > ( ) ; while ( ! curlev . isempty ( ) ) { treelinknode cur = curlev . poll ( ) ; if ( cur . left != null ) nextlev . add ( cur . left ) ; if ( cur . right != null ) nextlev . add ( cur . right ) ; if ( ! curlev . isempty ( ) ) { treelinknode curnext = curlev . peek ( ) ; if ( curnext . left != null ) nextlev . add ( cur . left ) ; if ( curnext . right != null ) nextlev . add ( cur . right ) ; cur . next = curnext ; } } curlev = nextlev ; } }
tr	7	public void run ( ) { parser = new commandparser ( true ) ; parser . setcommandlist ( new applicationcommandlist ( ) ) ; system . out . println ( "welcome" ) ; system . out . println ( "ready for input!" ) ; reader = new bufferedreader ( new inputstreamreader ( system . in ) ) ; string input ; try { while ( ( input = reader . readline ( ) ) != null ) { if ( input . equals ( "!end" ) ) { break ; } else { if ( input . length ( ) > 0 ) { string query = parser . parse ( input . trim ( ) ) ; if ( query . length ( ) > 1 ) { parser . parse ( query ) ; } } else system . out . println ( "" ) ; } } } catch ( ioexception e ) { logger . error ( "reading input lines failed" ) ; } finally { system . out . println ( "bye" ) ; if ( reader != null ) { try { reader . close ( ) ; } catch ( ioexception e ) { logger . error ( "could not close reader" ) ; } } } }
tr	3	public static void main ( string [ ] args ) { double mass , height , bmi ; mass = double . parsedouble ( args [ 0 ] ) ; height = double . parsedouble ( args [ 1 ] ) ; bmi = mass / math . pow ( height , 2 ) ; if ( bmi < 18.5 ) system . out . println ( "underweight" ) ; else if ( bmi < 25 ) system . out . println ( "normal weight" ) ; else if ( bmi < 30 ) system . out . println ( "overweight" ) ; else system . out . println ( "obses" ) ; }
tr	7	public static double tanh ( double x ) { boolean negate = false ; if ( x != x ) { return x ; } if ( x > 20.0 ) { return 1.0 ; } if ( x < - 20 ) { return - 1.0 ; } if ( x == 0 ) { return x ; } if ( x < 0.0 ) { x = - x ; negate = true ; } double result ; if ( x >= 0.5 ) { double hiprec [ ] = new double [ 2 ] ; exp ( x * 2.0 , 0.0 , hiprec ) ; double ya = hiprec [ 0 ] + hiprec [ 1 ] ; double yb = - ( ya - hiprec [ 0 ] - hiprec [ 1 ] ) ; double na = - 1.0 + ya ; double nb = - ( na + 1.0 - ya ) ; double temp = na + yb ; nb += - ( temp - na - yb ) ; na = temp ; double da = 1.0 + ya ; double db = - ( da - 1.0 - ya ) ; temp = da + yb ; db += - ( temp - da - yb ) ; da = temp ; temp = da * hex_40000000 ; double daa = da + temp - temp ; double dab = da - daa ; double ratio = na / da ; temp = ratio * hex_40000000 ; double ratioa = ratio + temp - temp ; double ratiob = ratio - ratioa ; ratiob += ( na - daa * ratioa - daa * ratiob - dab * ratioa - dab * ratiob ) / da ; ratiob += nb / da ; ratiob += - db * na / da / da ; result = ratioa + ratiob ; } else { double hiprec [ ] = new double [ 2 ] ; expm1 ( x * 2.0 , hiprec ) ; double ya = hiprec [ 0 ] + hiprec [ 1 ] ; double yb = - ( ya - hiprec [ 0 ] - hiprec [ 1 ] ) ; double na = ya ; double nb = yb ; double da = 2.0 + ya ; double db = - ( da - 2.0 - ya ) ; double temp = da + yb ; db += - ( temp - da - yb ) ; da = temp ; temp = da * hex_40000000 ; double daa = da + temp - temp ; double dab = da - daa ; double ratio = na / da ; temp = ratio * hex_40000000 ; double ratioa = ratio + temp - temp ; double ratiob = ratio - ratioa ; ratiob += ( na - daa * ratioa - daa * ratiob - dab * ratioa - dab * ratiob ) / da ; ratiob += nb / da ; ratiob += - db * na / da / da ; result = ratioa + ratiob ; } if ( negate ) { result = - result ; } return result ; }
tr	5	public component gettablecellrenderercomponent ( jtable table , object val , boolean sel , boolean foc , int r , int c ) { jlabel label ; if ( val == attendance . present ) label = new jlabel ( new imageicon ( check_icon ) ) ; else if ( val == attendance . absent ) label = new jlabel ( "-" , swingconstants . center ) ; else if ( val instanceof bidcounter ) label = new bidlabel ( ( bidcounter ) val ) ; else if ( val instanceof player ) label = new jlabel ( val . tostring ( ) , swingconstants . left ) ; else label = new jlabel ( val . tostring ( ) , swingconstants . center ) ; label . setfont ( table . getfont ( ) ) ; if ( sel ) { label . setopaque ( true ) ; label . setbackground ( systemcolor . texthighlight ) ; label . setforeground ( systemcolor . texthighlighttext ) ; } return label ; }
tr	0	public void publishmessage ( ) throws namingexception , jmsexception { system . out . println ( "publishing message..." ) ; try ( topicconnection topicconnection = topicconnfactory . createtopicconnection ( ) ; topicsession topicsession = topicconnection . createtopicsession ( false , topicsession . auto_acknowledge ) ; ) { topic createdtopic = topicsession . createtopic ( "javaee" ) ; topicconnection . start ( ) ; textmessage textmessage = topicsession . createtextmessage ( "this is a test message" ) ; try ( javax . jms . topicpublisher topicpublisher = topicsession . createpublisher ( createdtopic ) ) { topicpublisher . publish ( textmessage ) ; setmessage ( "message published" ) ; } } }
tr	2	public session createsession ( string uristring , string params , clientproxy proxy , map < string , object > httpparams ) { try { uri uri = new uri ( uristring ) ; sessionfactory found = registry . get ( uri . getscheme ( ) ) ; if ( found == null ) throw new clienterror ( "could not open uri '" + uristring + "'. unknown scheme - '" + uri . getscheme ( ) + "'." + "make sure you have registered your sessionfactory with this transport." ) ; return found . newsession ( uri , params , proxy , httpparams ) ; } catch ( urisyntaxexception e ) { throw new clienterror ( e ) ; } }
tr	0	@ test public void testsortcollection ( ) { xlist expected = new xlist ( ds ) ; expected . add ( 0 , ( new tree ( "\u0415\u043b\u044c" , 150 , false , 1500 ) ) ) ; expected . add ( 1 , new tree ( "\u0414\u0443\u0431" , 200 , true , 1000 ) ) ; expected . add ( 2 , new flower ( "\u0410\u0441\u0442\u0440\u043e\u0432\u044b\u0435" , "\u0420\u043e\u043c\u0430\u0448\u043a\u0430" , 15 , 1 ) ) ; expected . add ( 3 , new flower ( "\u0410\u0441\u0442\u0440\u043e\u0432\u044b\u0435" , "\u041b\u0438\u043b\u0438\u044f" , 10 , 1 ) ) ; listplant . sortcollection ( ) ; assertequals ( expected , listplant . getlistplants ( ) ) ; }
tr	8	public static float nextafter ( final float f , final double direction ) { if ( double . isnan ( f ) || double . isnan ( direction ) ) { return float . nan ; } else if ( f == direction ) { return ( float ) direction ; } else if ( float . isinfinite ( f ) ) { return ( f < 0f ) ? - float . max_value : float . max_value ; } else if ( f == 0f ) { return ( direction < 0 ) ? - float . min_value : float . min_value ; } final int bits = float . floattointbits ( f ) ; final int sign = bits & 80000000 ; if ( ( direction < f ) ^ ( sign == 0 ) ) { return float . intbitstofloat ( sign | ( ( bits & 7fffffff ) + 1 ) ) ; } else { return float . intbitstofloat ( sign | ( ( bits & 7fffffff ) - 1 ) ) ; } }
tr	9	private int get_next_page ( page page , long boundary ) { if ( boundary > 0 ) boundary += offset ; while ( true ) { int more ; if ( boundary > 0 && offset >= boundary ) return ov_false ; more = oy . pageseek ( page ) ; if ( more < 0 ) { offset -= more ; } else { if ( more == 0 ) { if ( boundary == 0 ) return ov_false ; int ret = get_data ( ) ; if ( ret == 0 ) return ov_eof ; if ( ret < 0 ) return ov_eread ; } else { int ret = ( int ) offset ; offset += more ; return ret ; } } } }
tr	5	public string checkdataentry ( ) { if ( efastanalysispanel1 . parameterscreen . directorychosen . gettext ( ) . equals ( "selected directory: " ) ) { return "error on parameter data entry. make sure all the boxes have been completed" ; } else if ( efastanalysispanel1 . parameterscreen . efastcurves . gettext ( ) . equals ( "" ) || efastanalysispanel1 . parameterscreen . efastsamplenumber . gettext ( ) . equals ( "" ) ) { return "error on parameter data entry. make sure all the boxes have been completed" ; } else if ( efastanalysispanel1 . parameterscreen . parametersmodel . contains ( "none entered" ) ) { return "no parameters have been selected" ; } else { try { integer . parseint ( efastanalysispanel1 . parameterscreen . efastcurves . gettext ( ) ) ; integer . parseint ( efastanalysispanel1 . parameterscreen . efastsamplenumber . gettext ( ) ) ; return null ; } catch ( numberformatexception e ) { return "number of curves and parameter samples must be integers" ; } } }
tr	8	private double [ ] [ ] inverso ( int [ ] [ ] llave ) { double [ ] [ ] inverso = new double [ llave . length ] [ llave [ 0 ] . length ] ; boolean signo = false ; for ( int f = 0 ; f < llave . length ; f ++ ) { for ( int c = 0 ; c < llave [ f ] . length ; c ++ ) { int [ ] [ ] matriz_de_adentro = new int [ llave . length - 1 ] [ llave [ f ] . length - 1 ] ; int fda = 0 , cda = 0 ; for ( int f2 = 0 ; f2 < llave . length ; f2 ++ ) { for ( int c2 = 0 ; c2 < llave [ f2 ] . length ; c2 ++ ) { if ( f2 != f && c2 != c ) { matriz_de_adentro [ fda ] [ cda ] = llave [ f2 ] [ c2 ] ; cda ++ ; if ( cda == matriz_de_adentro [ fda ] . length ) { cda = 0 ; fda ++ ; } } } } int dda = calcular_determinante ( matriz_de_adentro ) ; if ( signo ) { dda *= - 1 ; } signo = ! signo ; inverso [ f ] [ c ] = ( ( double ) dda ) / ( ( double ) det ) ; } } return inverso ; }
tr	4	public static string generaterangehashfunction ( byte [ ] min , byte [ ] max , string [ ] buckets , string suffix , string prefix ) throws exception { if ( comparekey ( min , max ) > 0 ) { throw new exception ( "the given min is not larger than the max. buckets could not be determined" ) ; } byte [ ] [ ] ranges = getmaxvalsperrange ( min , max , buckets . length ) ; stringbuilder sb = new stringbuilder ( ) ; for ( int i = 0 ; i < min . length ; i ++ ) { sb . append ( "b" ) . append ( "\t" ) ; } sb . append ( "filename" ) . append ( "\n" ) ; for ( int i = 0 ; i < buckets . length ; ++ i ) { byte [ ] val = ranges [ i ] ; for ( int j = 0 ; j < val . length ; j ++ ) { int k = val [ j ] & ff ; sb . append ( k + "\t" ) ; } sb . append ( prefix + buckets [ i ] + suffix + "\n" ) ; } return sb . tostring ( ) ; }
tr	0	protected void jbinit ( ) throws exception { jpanel toppanel = new jpanel ( ) ; jpanel bottompanel = new jpanel ( ) ; jpanel rightpanel = new jpanel ( ) ; this . setcenter ( ) ; this . setnorth ( toppanel ) ; this . setsouth ( bottompanel ) ; this . seteast ( rightpanel ) ; m_mainpane . add ( toppanel , borderlayout . north ) ; m_mainpane . add ( m_gridscrollarea , borderlayout . center ) ; m_mainpane . add ( rightpanel , borderlayout . east ) ; m_mainpane . add ( bottompanel , borderlayout . south ) ; }
tr	7	@ override public boolean combine ( aexecutionitem itemtoadd ) { if ( itemtoadd != null && itemtoadd . getclass ( ) == preparedstatementexecutionitem . class ) { if ( this . query . touppercase ( ) . startswith ( "insert" ) && ! this . query . touppercase ( ) . contains ( ";select" ) ) { preparedstatementexecutionitem otheritem = ( preparedstatementexecutionitem ) itemtoadd ; if ( otheritem . query . touppercase ( ) . startswith ( "insert" ) && ! otheritem . query . touppercase ( ) . contains ( ";select" ) && otheritem . query . tolowercase ( ) . equals ( query . tolowercase ( ) ) ) { this . executionitems . add ( otheritem ) ; return true ; } } } return false ; }
tr	2	public list < wishlist > find ( int idu ) throws instancenotfoundexception { list < wishlist > list = new arraylist < wishlist > ( ) ; try { connection connection = datasourceutils . getconnection ( datasource ) ; preparedstatement statement = connection . preparestatement ( "select idu  idp from wishlist where idu=?" ) ; statement . setint ( 1 , idu ) ; resultset resultset = statement . executequery ( ) ; while ( resultset . next ( ) ) { list . add ( new wishlist ( resultset . getint ( 2 ) , resultset . getint ( 1 ) ) ) ; } } catch ( sqlexception e ) { throw new runtimeexception ( e ) ; } return list ; }
tr	3	@ override public void endelement ( string uri , string localname , string qname ) throws saxexception { playxmlenum playxmlenum = playxmlenum . valueof ( qname . touppercase ( ) ) ; if ( playxmlenum == playxmlenum . date ) { int curid ; synchronized ( xmlplayshandler . class ) { curid = ++ dateid ; } currentplay . adddate ( curid , parsetime ( currplaydate ) ) ; } else if ( playxmlenum == playxmlenum . play ) { addplay ( currentplay ) ; } else if ( playxmlenum == playxmlenum . description ) { currentplay . setdescription ( currentdesc . tostring ( ) ) ; } currplayenum = null ; }
tr	9	public boolean trymove ( double dx , double dy ) { byte ret = this . level . getphysichandler ( ) . checkcollision ( level , this , dx , dy ) ; if ( ( ret == worldphysichandler . entitydies ) ) { this . die ( ) ; return false ; } boolean moveup = false ; if ( ( ret & worldphysichandler . allowedmovementhorizontally ) == 0 ) { this . y -= 1 ; moveup = ( worldphysichandler . allowedmovementhorizontally & level . getphysichandler ( ) . checkcollision ( level , this , dx , dy ) ) != 0 ; if ( moveup ) { ret = ( byte ) ( worldphysichandler . allowedmovementhorizontally | ret ) ; this . ya -= 35 ; } else { this . y += 1 ; } } boolean vertical = true ; this . onground = false ; if ( ( ret & worldphysichandler . allowedmovementvertically ) != 0 ) { this . y += dy ; } else { if ( ya >= 0 ) { this . onground = true ; if ( math . abs ( ya ) < 3 ) { ya = 0 ; } } this . ya = - this . ya * bounce ; this . y -= dy * bounce ; vertical = false ; } if ( this . y + this . h > this . level . getheight ( ) ) { this . ya = 0 ; this . onground = true ; vertical = false ; } boolean horizontal = true ; if ( ( ret & worldphysichandler . allowedmovementhorizontally ) != 0 ) { this . x += dx ; } else { this . xa = - this . xa * bounce ; this . x -= dx * bounce ; horizontal = false ; } return vertical && horizontal ; }
tr	8	public boolean initheadercomponents ( ) { locationlabel = new jlabel ( "project location" ) ; locationlabel . setbounds ( 5 , 5 , 100 , 25 ) ; locationfield = new jtextfield ( ) ; locationfield . setbounds ( 105 , 5 , 400 , 25 ) ; includelabel = new jlabel ( "include file type" ) ; includelabel . setbounds ( 5 , 35 , 100 , 25 ) ; includetextfield = new jtextfield ( ) ; includetextfield . setbounds ( 105 , 35 , 400 , 25 ) ; nonincludelabel = new jlabel ( "non include" ) ; nonincludelabel . setbounds ( 5 , 65 , 100 , 25 ) ; nonincludetextfield = new jtextfield ( ) ; nonincludetextfield . setbounds ( 105 , 65 , 400 , 25 ) ; configincludeandnoninclude ( ) ; openfilebutton = new jbutton ( "file.." ) ; openfilebutton . setbounds ( 515 , 5 , 80 , 25 ) ; openfilebutton . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent e ) { jfilechooser filechooser = new jfilechooser ( new file ( "c:" ) ) ; int i = filechooser . showopendialog ( header ) ; if ( i == jfilechooser . approve_option ) { locationfield . settext ( filechooser . getselectedfile ( ) . getabsolutepath ( ) ) ; } } } ) ; configbutton = new jbutton ( "config.." ) ; configbutton . setbounds ( 515 , 45 , 80 , 25 ) ; configbutton . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent e ) { configincludeandnoninclude ( ) ; } } ) ; loadbutton = new jbutton ( "load" ) ; loadbutton . setbounds ( 605 , 5 , 80 , 80 ) ; loadbutton . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent e ) { if ( locationfield . gettext ( ) == null || locationfield . gettext ( ) . isempty ( ) ) { uisupport . showmessage ( "file cannot be null!" ) ; return ; } if ( includetextfield . gettext ( ) == null || includetextfield . gettext ( ) . isempty ( ) ) { uisupport . showmessage ( "include cannot be null!" ) ; return ; } if ( nonincludetextfield . gettext ( ) == null || nonincludetextfield . gettext ( ) . isempty ( ) ) { uisupport . showmessage ( "non-include cannot be null!" ) ; return ; } if ( sourcecounter == null ) { sourcecounter = new sourcecounter ( fileutils . getfiles ( new file ( locationfield . gettext ( ) ) ) , includetextfield . gettext ( ) , nonincludetextfield . gettext ( ) ) ; } else { sourcecounter . setfiles ( fileutils . getfiles ( new file ( locationfield . gettext ( ) ) ) ) ; sourcecounter . repaint ( ) ; } } } ) ; header . add ( locationlabel ) ; header . add ( locationfield ) ; header . add ( includelabel ) ; header . add ( includetextfield ) ; header . add ( nonincludelabel ) ; header . add ( nonincludetextfield ) ; header . add ( openfilebutton ) ; header . add ( configbutton ) ; header . add ( loadbutton ) ; return false ; }
tr	4	public list < sitestatmodel > map ( statresultset resultset , sitemodel sitemodel , datetime timelimit ) { list < statrow > statrows = resultset . getrows ( ) ; map < long , sitestatmodel > sitestatmodelmap = new hashmap < > ( ) ; for ( statrow eachrow : statrows ) { datetime hour = datetimeformatutil . parsedatetime ( eachrow . getfield ( ) . get ( 4 ) ) ; if ( hour == null ) { continue ; } if ( hour . getmillis ( ) < timelimit . getmillis ( ) ) { sitestatmodel sitestatmodel = new sitestatmodel ( ) ; sitestatmodel . setuniquevisitor ( integer . parseint ( eachrow . getfield ( ) . get ( 1 ) ) ) ; sitestatmodel . setpageview ( integer . parseint ( eachrow . getfield ( ) . get ( 2 ) ) ) ; sitestatmodel . setvisit ( integer . parseint ( eachrow . getfield ( ) . get ( 3 ) ) ) ; sitestatmodel . sethour ( hour ) ; sitestatmodel . setvideo ( 0 ) ; sitestatmodel . setsite ( sitemodel ) ; if ( sitestatmodelmap . get ( hour . getmillis ( ) ) == null ) { sitestatmodelmap . put ( hour . getmillis ( ) , sitestatmodel ) ; } else { sitestatmodelmap . remove ( hour . getmillis ( ) ) ; sitestatmodelmap . put ( hour . getmillis ( ) , sitestatmodel ) ; } } } list < sitestatmodel > sitestatmodels = new arraylist < > ( sitestatmodelmap . values ( ) ) ; return sitestatmodels ; }
tr	4	private static expr resolvenoneparamexpr ( syntaxtreenode node ) { lextoken token = node . gettoken ( ) ; string text = token . gettext ( ) ; switch ( ( nagisalextokentype ) token . gettype ( ) ) { case literal_integer : return new expr ( exprtype . integer , exproperator . integerliteral , text ) ; case identifier_integer : return new expr ( exprtype . integer , exproperator . integervariableref , text ) ; case literal_string : return new expr ( exprtype . string , exproperator . stringliteral , text ) ; case identifier_string : return new expr ( exprtype . string , exproperator . stringvariableref , text ) ; default : throw new unsupportedoperationexception ( token . tostring ( ) ) ; } }
tr	5	@ test public void buildsgraph ( ) { point p1 = vc . addpoint ( 0 , 0 ) ; point p2 = vc . addpoint ( 1 , - 1 ) ; point p3 = vc . addpoint ( 1 , 1 ) ; point p4 = vc . addpoint ( 1.5 , 0.0 ) ; point p5 = vc . addpoint ( 4 , - 1 ) ; point p6 = vc . addpoint ( 4 , 1 ) ; p1 . setright ( p2 ) ; p2 . setleft ( p1 ) ; p3 . setright ( p1 ) ; p1 . setleft ( p3 ) ; p2 . setright ( p3 ) ; p3 . setleft ( p2 ) ; p4 . setright ( p5 ) ; p5 . setleft ( p4 ) ; p6 . setright ( p4 ) ; p4 . setleft ( p6 ) ; p5 . setright ( p6 ) ; p6 . setleft ( p5 ) ; vc . buildgraph ( ) ; tree < vertex > testadj1 = new tree < > ( new vertexcomparator ( ) ) ; tree < vertex > testadj2 = new tree < > ( new vertexcomparator ( ) ) ; tree < vertex > testadj3 = new tree < > ( new vertexcomparator ( ) ) ; tree < vertex > testadj4 = new tree < > ( new vertexcomparator ( ) ) ; tree < vertex > testadj5 = new tree < > ( new vertexcomparator ( ) ) ; tree < vertex > testadj6 = new tree < > ( new vertexcomparator ( ) ) ; testadj1 . add ( p2 ) ; testadj1 . add ( p3 ) ; testadj2 . add ( p1 ) ; testadj2 . add ( p5 ) ; testadj2 . add ( p4 ) ; testadj2 . add ( p3 ) ; testadj3 . add ( p1 ) ; testadj3 . add ( p6 ) ; testadj3 . add ( p4 ) ; testadj3 . add ( p2 ) ; testadj4 . add ( p2 ) ; testadj4 . add ( p3 ) ; testadj4 . add ( p5 ) ; testadj4 . add ( p6 ) ; testadj5 . add ( p2 ) ; testadj5 . add ( p4 ) ; testadj5 . add ( p6 ) ; testadj6 . add ( p5 ) ; testadj6 . add ( p4 ) ; testadj6 . add ( p3 ) ; asserttrue ( p1 . getadjacents ( ) . equals ( testadj1 ) && p2 . getadjacents ( ) . equals ( testadj2 ) && p3 . getadjacents ( ) . equals ( testadj3 ) && p4 . getadjacents ( ) . equals ( testadj4 ) && p5 . getadjacents ( ) . equals ( testadj5 ) && p6 . getadjacents ( ) . equals ( testadj6 ) ) ; }
tr	2	public void convert ( ticket ticket ) { for ( de . robert_heim . unfuddle2bitbucket . model . unfuddle . comment unfuddlecomment : ticket . getcomments ( ) ) { string username = null ; person p = provider . getpeopleconverter ( ) . findpersonbyid ( unfuddlecomment . getauthorid ( ) ) ; if ( null == p ) { system . out . println ( "warning: the comment-author with id '" + unfuddlecomment . getauthorid ( ) + "' could not be found in the input file. using 'null'." ) ; } else { username = p . getname ( ) ; } comment comment = new comment ( unfuddlecomment . getbody ( ) , unfuddlecomment . getcreatedat ( ) . togregoriancalendar ( ) . gettime ( ) , getuniquecommentid ( ) , ticket . getid ( ) , ticket . getupdatedat ( ) . togregoriancalendar ( ) . gettime ( ) , username ) ; comments . add ( comment ) ; } }
tr	4	@ override public synchronized boolean add ( plugin plugin ) { iterator < plugin > iter = this . iterator ( ) ; while ( iter . hasnext ( ) ) { if ( iter . next ( ) . getname ( ) . equals ( plugin . getname ( ) ) ) { return false ; } } plugin . addpropertychangelistener ( new propertychangelistener ( ) { public void propertychange ( propertychangeevent evt ) { if ( evt . getpropertyname ( ) . equals ( "plugin_files_compared" ) ) { int pos = pluginlist . this . indexof ( evt . getnewvalue ( ) ) ; propertychange . firepropertychange ( "plugin_status_changed" , null , pos ) ; } } } ) ; if ( messagedatabase != null ) { plugin . setmessagedatabase ( messagedatabase ) ; } return super . add ( plugin ) ; }
tr	7	public void actionperformed ( actionevent ae ) { adocument adoc = ( adocument ) textpane . getdocument ( ) ; clipboard clipboard = toolkit . getdefaulttoolkit ( ) . getsystemclipboard ( ) ; ^ ^ = textpane . getcaret ( ) ; int . = ^ . getdot ( ) ; int mark = ^ . getmark ( ) ; if ( . != mark ) return ; adocumentfragment fragment = null ; try { transferable tr = clipboard . getcontents ( this ) ; dataflavor flavor = new dataflavor ( adocumentfragment . mime_type ) ; if ( tr . isdataflavorsupported ( flavor ) ) fragment = ( adocumentfragment ) tr . gettransferdata ( flavor ) ; else { flavor = new dataflavor ( "application/x-java-serialized-object; class=java.lang.string" ) ; if ( tr . isdataflavorsupported ( flavor ) ) { string s = new string ( ( ( ( string ) tr . gettransferdata ( flavor ) ) ) ) ; fragment = new adocumentfragment ( s , null , null ) ; } } } catch ( unsupportedflavorexception e ) { e . printstacktrace ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } catch ( classnotfoundexception e ) { e . printstacktrace ( ) ; } if ( fragment == null ) return ; adoc . startcompoundedit ( ) ; adocument . pasteadocfragment ( adoc , . , fragment ) ; adoc . endcompoundedit ( null ) ; adoc . fireadocumentchanged ( ) ; }
tr	0	@ override public string tostring ( ) { return "rolesetupinfo [config=" + config + "  getname()=" + getname ( ) + "  gettype()=" + gettype ( ) + "  isconfigstale()=" + isconfigstale ( ) + "  gethostref()=" + gethostref ( ) + "  getserviceref()=" + getserviceref ( ) + "  getrolestate()=" + getrolestate ( ) + "  gethealthsummary()=" + gethealthsummary ( ) + "  gethealthchecks()=" + gethealthchecks ( ) + "  gethastatus()=" + gethastatus ( ) + "  getroleurl()=" + getroleurl ( ) + "  tostring()=" + super . tostring ( ) + "  getclass()=" + getclass ( ) + "  hashcode()=" + hashcode ( ) + "]" ; }
tr	8	private moveinfo iterativedeepeningroot2 ( gamestate position ) { current_best_score = - score_infinity ; current_search_depth = 0 ; arimaamove best_move = null ; this . initial_position = position ; gamestate initial_gs = position ; resetstats ( ) ; enable_search ( ) ; gamestate new_position = new gamestate ( ) ; eval . preprocessrootposition ( position ) ; movelist root_moves = genrootmoves ( initial_gs ) ; processrootmoves ( initial_position , root_moves ) ; int offset = setup_search ( initial_gs ) ; logfile . message ( "score offset: " + offset ) ; try { for ( int depth = initial_search_depth ; depth <= max_search_depth ; depth ++ ) { current_search_depth = depth ; int iteration_best_score = - score_infinity ; int new_beta = score_infinity ; root_moves . sort ( ) ; for ( arimaamove move : root_moves ) { int temp_score ; if ( move . move_ordering_value >= 30000 || move . move_ordering_value <= - 30000 ) { temp_score = move . move_ordering_value ; } else { new_position . play ( move , initial_position ) ; temp_score = searchposition ( new_position , depth , iteration_best_score , new_beta ) ; } move . move_ordering_value = temp_score ; if ( temp_score > iteration_best_score ) { iteration_best_score = temp_score ; current_best_score = temp_score ; best_move = move ; hash_table . recordhash ( initial_position . getpositionhash ( ) , depth , iteration_best_score , hashtable . lower_bound , move , false ) ; string text = "d:" + util . pad ( 2 , depth ) ; text += " " + util . totimestring ( time_control . getelapsedsearchtime ( ) ) ; text += " " + util . leftjustify ( 8 , convertscore ( iteration_best_score ) ) ; text += "     " + getpv ( initial_position ) ; logfile . message ( text ) ; moveinfo mi = new moveinfo ( ) ; mi . eval_score = current_best_score ; mi . move_text = gen_turn . getofficialarimaanotation ( initial_position , best_move ) ; mi . pv = getpv ( position ) ; mi . nodes_searched = this . ab_nodes_searched ; mi . ply = depth ; mi . search_time_ms = time_control . getelapsedsearchtime ( ) ; thread_mi = mi ; if ( iteration_best_score >= score_forced_win ) { break ; } } } string text = "f:" + util . pad ( 2 , depth ) ; text += " " + util . totimestring ( time_control . getelapsedsearchtime ( ) ) ; text += " " + util . leftjustify ( 7 , convertscore ( current_best_score ) ) ; text += "     " ; text += " nodes: " + ab_nodes_searched ; text += " qnodes: " + q_nodes_searched ; text += " knps: " + ab_nodes_searched / ( time_control . getelapsedsearchtime ( ) + 1 ) ; logfile . message ( text ) ; if ( ismatescore ( iteration_best_score ) ) { break ; } } } catch ( abortsearchexception ex ) { logfile . message ( "search aborted!" ) ; } engine_search_completed = true ; return thread_mi ; }
tr	8	@ override public void visit ( cannyevent cannyevent ) { try { if ( model . getcurrentimagepath ( ) == null || model . getcurrentimagepath ( ) . isempty ( ) ) { throw new exception ( "brak pliku wej\u015bciowego!" ) ; } string low_treshold_str = defaultviewchanger . showcannyparametersdialog ( true ) ; float low_treshold = 0.0f ; try { if ( low_treshold_str == null ) throw new numberformatexception ( ) ; low_treshold = new float ( low_treshold_str ) ; } catch ( numberformatexception e ) { system . out . println ( "przyjmuje warto\u015b\u0107 domy\u015bln\u0105 low_treshold: " + 0.5f ) ; errordialog . showerrordialog ( "b\u0142\u0119dnie wpisania warto\u015b\u0107! przyjmuje warto\u015b\u0107 domy\u015bln\u0105 low_treshold: " + 0.5f ) ; low_treshold = 0.5f ; } string high_treshold_str = defaultviewchanger . showcannyparametersdialog ( false ) ; float high_treshold = 1.0f ; try { if ( high_treshold_str == null ) throw new numberformatexception ( ) ; high_treshold = new float ( high_treshold_str ) ; } catch ( numberformatexception e ) { system . out . println ( "przyjmuje warto\u015b\u0107 domy\u015bln\u0105 high_treshold: " + 1.0f ) ; errordialog . showerrordialog ( "b\u0142\u0119dnie wpisania warto\u015b\u0107! przyjmuje warto\u015b\u0107 domy\u015bln\u0105 high_treshold: " + 1.0f ) ; high_treshold = 1.0f ; } canny canny = new canny ( low_treshold , high_treshold ) ; bufferedimage source ; system . out . println ( "wczytuje plik \u017ar\u00f3d\u0142owy..." ) ; source = imageio . read ( new file ( model . getcurrentimagepath ( ) ) ) ; system . out . println ( "uruchamiam algorytm..." ) ; bufferedimage canny_image = canny . process ( source ) ; string output_name = "output/canny.png" ; saveimagetofile ( output_name , canny_image ) ; system . out . println ( "wy\u015bwietlam zdj\u0119cie..." ) ; defaultviewchanger . showmodimage ( output_name ) ; } catch ( exception e ) { if ( defaultviewchanger != null ) defaultviewchanger . showinformationdialog ( e . getmessage ( ) , "b\u0142\u0105d" , joptionpane . error_message ) ; e . printstacktrace ( ) ; } }
tr	6	@ suppresswarnings ( "rawtypes" ) public static list < string > getclassnamesimplementinginterface ( class interf , string basepackage ) { list < string > classnames = new arraylist < string > ( ) ; try { class [ ] result = getclasses ( basepackage ) ; for ( class c : result ) { if ( ! modifier . isabstract ( c . getmodifiers ( ) ) ) { for ( class implementinginterface : c . getinterfaces ( ) ) { if ( implementinginterface . getname ( ) . equals ( interf . getname ( ) ) ) { classnames . add ( c . getcanonicalname ( ) ) ; } } } } } catch ( classnotfoundexception e ) { e . printstacktrace ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } return classnames ; }
tr	6	public void mouseclicked ( mouseevent me ) { try { if ( me . getsource ( ) == jb_connexion ) { login = jtf_login . gettext ( ) ; password = string . valueof ( jpf_password . getpassword ( ) ) ; system . out . println ( "email : " + login ) ; system . out . println ( "motdepasse : " + password ) ; user u = null ; connection co = bs . getconnection ( ) ; system . out . println ( "avant if" ) ; if ( user . checkpresence ( bs , login , password ) ) { system . out . println ( "debut if" ) ; u = user . findbylogs ( login , password , bs ) ; groupe = usertype . findbyid ( u . getid_ut ( ) , bs ) . getname_ut ( ) ; system . out . println ( "ok : " + groupe ) ; affichermenuprincipal ( ) ; setresizable ( true ) ; setextendedstate ( maximized_both ) ; } else { system . out . println ( "non ok" ) ; } } if ( me . getsource ( ) == jb_mdp_oublie ) { if ( swingutilities . isleftmousebutton ( me ) ) { } if ( swingutilities . isrightmousebutton ( me ) ) { } } } catch ( exception e ) { system . out . println ( "exception" ) ; e . printstacktrace ( ) ; } }
tr	0	public titlemodel ( ) { column menucolumn = new column ( "menu" ) ; menucolumn . additem ( new item ( "startgame" ) ) ; menucolumn . additem ( new item ( "settings" ) ) ; menucolumn . additem ( new item ( "exitgame" ) ) ; herocolumn herocolumn1 = new herocolumn ( "herocolumn1" , constants . player_1_default_hero ) ; herocolumn1 . additem ( new item ( "choosehero" ) ) ; herocolumn herocolumn2 = new herocolumn ( "herocolumn2" , constants . player_2_default_hero ) ; herocolumn2 . additem ( new item ( "choosehero" ) ) ; columns . add ( menucolumn ) ; columns . add ( herocolumn1 ) ; columns . add ( herocolumn2 ) ; selected = false ; }
tr	7	public vector < string > enumdatabases ( ) { vector < string > instances = new vector < string > ( ) ; connection session = null ; try { session = connect ( "postgres" , "postgres" , "postgres" ) ; if ( session == null ) { errmsg = "can't connect to management database" ; return instances ; } statement stmt = session . createstatement ( ) ; if ( stmt . execute ( "select datname from pg_database;" ) ) { resultset r = stmt . getresultset ( ) ; if ( r != null ) { while ( r . next ( ) ) { string name = r . getstring ( "datname" ) ; instances . add ( name ) ; } } } errmsg = null ; } catch ( sqlexception e ) { errmsg = e . getmessage ( ) ; } finally { if ( session != null ) try { session . close ( ) ; } catch ( sqlexception e ) { } } return instances ; }
tr	1	private jtoolbar createtoolbar ( ) { jtoolbar tb = new jtoolbar ( ) ; tb . setfloatable ( false ) ; tb . setrollover ( true ) ; tb . add ( newaction ) ; tb . add ( openaction ) ; tb . add ( saveaction ) ; tb . addseparator ( ) ; tb . add ( cutaction ) ; tb . add ( copyaction ) ; tb . add ( pasteaction ) ; tb . addseparator ( ) ; tb . add ( addaction ) ; tb . add ( editaction ) ; tb . add ( delaction ) ; tb . addseparator ( ) ; tb . add ( findaction ) ; tb . addseparator ( ) ; tb . add ( keyaction ) ; tb . add ( box . createhorizontalglue ( ) ) ; final jtextfield searchfield = new jtextfield ( ) ; searchfield . setminimumsize ( new dimension ( 120 , 21 ) ) ; searchfield . setpreferredsize ( new dimension ( 120 , 21 ) ) ; searchfield . setmaximumsize ( new dimension ( 120 , 21 ) ) ; final actionlistener searchlistener = new actionlistener ( ) { public void actionperformed ( actionevent e ) { zamokview view = gettab ( ) ; if ( view != null ) view . setfilter ( searchfield . gettext ( ) ) ; } } ; searchfield . addactionlistener ( searchlistener ) ; searchfield . getdocument ( ) . adddocumentlistener ( new documentlistener ( ) { public void insertupdate ( documentevent e ) { searchlistener . actionperformed ( null ) ; } public void removeupdate ( documentevent e ) { searchlistener . actionperformed ( null ) ; } public void changedupdate ( documentevent e ) { } } ) ; tb . add ( searchfield ) ; tb . addseparator ( ) ; return tb ; }
tr	6	public dependanceclosure ( list < rule > rulelist , string start ) throws exception { map < string , rule > rulemap = new hashmap < string , rule > ( ) ; for ( int index = 0 ; index < rulelist . size ( ) ; index ++ ) { string name = rulelist . get ( index ) . getrulename ( ) . tostring ( ) ; rule rule = rulelist . get ( index ) ; if ( rulemap . get ( name ) != null ) { throw new exception ( "the definition of rule " + rulelist . get ( index ) . getrulename ( ) . tostring ( ) + " duplicates." ) ; } rulemap . put ( name , rule ) ; } set < string > rulenameset = new hashset < string > ( ) ; rulenameset . add ( start ) ; set < string > marked = new hashset < string > ( ) ; set < string > unmarked = new hashset < string > ( ) ; unmarked . add ( start ) ; while ( ! unmarked . isempty ( ) ) { string name = unmarked . iterator ( ) . next ( ) ; set < string > dependant = rulemap . get ( name ) . getelements ( ) . getdependentrulenames ( ) ; iterator < string > it = dependant . iterator ( ) ; while ( it . hasnext ( ) ) { string dep = it . next ( ) ; if ( marked . contains ( dep ) || unmarked . contains ( dep ) ) continue ; unmarked . add ( dep ) ; } this . rulelist . add ( rulemap . get ( name ) ) ; marked . add ( name ) ; unmarked . remove ( name ) ; } }
tr	6	public static void main ( string [ ] args ) throws exception { long start = system . currenttimemillis ( ) ; scanner in = new scanner ( new file ( "d:\\programdata\\2013\\fair and square\\c-large-practice-1.in" ) ) ; system . setout ( new printstream ( new file ( "d:\\programdata\\2013\\fair and square\\c-large-practice1.out" ) ) ) ; int numcase = in . nextint ( ) ; in . nextline ( ) ; for ( int curcase = 1 ; curcase <= numcase ; curcase ++ ) { long min , max ; min = in . nextlong ( ) ; max = in . nextlong ( ) ; int count = 0 ; long sqrt_min = ( long ) math . sqrt ( min ) , sqrt_max = ( long ) math . sqrt ( max ) ; if ( min > 1 && min < 4 ) sqrt_min += 1 ; for ( long i = sqrt_min ; i <= sqrt_max ; i ++ ) { if ( ispalin ( i ) && ispalin ( i * i ) ) { count ++ ; } } system . out . println ( " case #" + curcase + ": " + count ) ; } long end = system . currenttimemillis ( ) ; system . out . println ( "\u8fd0\u884c\u65f6\u95f4\uff1a" + ( end - start ) + "ms" ) ; }
tr	2	public void test_getrevisioninfo ( ) { filehistory filehist = new filehistory ( path . resolve ( "readme.txt" ) ) ; filehist . storerevision ( path . resolve ( "readme.txt" ) , null , 100 , 200 ) ; filehist . storerevision ( path . resolve ( "license.txt" ) , null , 300 , 400 ) ; filehist . storerevision ( path . resolve ( "authors.txt" ) , null , 500 , 600 ) ; dataretriever dataretriever = new dataretriever ( path . resolve ( "readme.txt" ) ) ; vector < vector < string >> tabledata = dataretriever . getrevisioninfotable ( ) ; system . out . println ( "please check time-depend result:" ) ; for ( vector < string > rows : tabledata ) { for ( string data : rows ) { system . out . println ( data ) ; } } }
tr	3	public enterteams ( maingui gui ) { initcomponents ( ) ; this . gui = gui ; graphicsenvironment g = graphicsenvironment . getlocalgraphicsenvironment ( ) ; graphicsdevice [ ] devices = g . getscreendevices ( ) ; int width = devices [ 0 ] . getdisplaymode ( ) . getwidth ( ) ; int height = devices [ 0 ] . getdisplaymode ( ) . getheight ( ) ; int w = this . getsize ( ) . width ; int h = this . getsize ( ) . height ; int x = ( width - w ) / 2 ; int y = ( height - h ) / 2 ; this . setlocation ( x , y ) ; numberofmatchesfield . setvalue ( 1 ) ; matchfield . setvalue ( 1 ) ; savematchesbutton . setenabled ( false ) ; teamarray = new jtextfield [ 6 ] ; teamarray [ 0 ] = redallianceteam1 ; teamarray [ 1 ] = redallianceteam2 ; teamarray [ 2 ] = redallianceteam3 ; teamarray [ 3 ] = blueallianceteam1 ; teamarray [ 4 ] = blueallianceteam2 ; teamarray [ 5 ] = blueallianceteam3 ; if ( ! "" . equals ( competition . getcompetitionname ( ) ) || competition . getcompetitionname ( ) != null ) { competitionnamefield . settext ( competition . getcompetitionname ( ) ) ; } if ( competition . getnumberofmatches ( ) != 0 ) { numberofmatchesfield . setvalue ( competition . getnumberofmatches ( ) ) ; } dynamicarray teams = new dynamicarray ( 20 ) ; }
tr	4	public void testlineserieschart ( ) { lineserieschart < number , number > chart = new lineserieschart < number , number > ( "curves" , "x" , "y" ) ; collection < lineseriesitem < number , number >> linhasin = new arraylist < lineseriesitem < number , number >> ( ) ; for ( double i = 0 ; i <= 6 ; i += 0.01 ) { linhasin . add ( new lineseriesitem < number , number > ( i , math . sin ( i ) + 4 ) ) ; } chart . addvalue ( linhasin ) ; collection < lineseriesitem < number , number >> linhacos = new arraylist < lineseriesitem < number , number >> ( ) ; for ( double i = 0 ; i <= 6 ; i += 0.01 ) { linhacos . add ( new lineseriesitem < number , number > ( i , math . cos ( i ) ) ) ; } chart . addvalue ( linhacos ) ; collection < lineseriesitem < number , number >> linhaexp = new arraylist < lineseriesitem < number , number >> ( ) ; for ( double i = 0 ; i <= 2 ; i += 0.01 ) { linhaexp . add ( new lineseriesitem < number , number > ( i , math . exp ( i ) + 1 ) ) ; } chart . addvalue ( linhaexp ) ; collection < lineseriesitem < number , number >> linhareta = new arraylist < lineseriesitem < number , number >> ( ) ; for ( double i = 0 ; i <= 6 ; i += 0.01 ) { linhareta . add ( new lineseriesitem < number , number > ( i , i ) ) ; } chart . addvalue ( linhareta ) ; highlighter highlighter = criarhighlighter ( ) ; chart . getchartconfiguration ( ) . sethighlighter ( highlighter ) ; chart . addserie ( criarserie ( "seno" , "#489104" ) ) ; chart . addserie ( criarserie ( "coseno" , "#c91212" ) ) ; chart . addserie ( criarserie ( "exponensial" , "#7d02b2" ) ) ; chart . addserie ( criarserie ( "reta" , "#066fa7" ) ) ; legend legend = new legend ( true , location . ne ) ; legend . setplacement ( "outsidegrid" ) ; chart . setlegend ( legend ) ; axis < string > axis = new axisstring ( ) ; axis . setlabelrenderer ( jqplotresources . canvasaxislabelrenderer ) ; chart . setaxesdefaults ( axis ) ; axes axes = chart . getaxes ( ) ; xaxis xaxis = axes . getxaxis ( ) ; tickoptions tickoptions = new tickoptions ( ) ; tickoptions . setangle ( 270 ) ; tickoptions . setlabelposition ( "end" ) ; xaxis . settickoptions ( tickoptions ) ; xaxis . settickrenderer ( jqplotresources . canvasaxistickrenderer ) ; xaxis . settickinterval ( 1 ) ; axes . getyaxis ( ) . settickinterval ( 0.50 ) ; axes . getyaxis ( ) . setmax ( 8.50 ) ; axes . getyaxis ( ) . setmin ( - 1.50 ) ; tickoptions tickoptionsy = new tickoptions ( ) ; tickoptionsy . setformatstring ( "%.2f" ) ; axes . getyaxis ( ) . settickoptions ( tickoptionsy ) ; grid grid = new grid ( ) ; grid . setbackground ( "#ffffff" ) ; grid . setgridlinecoler ( "#a0a0a0" ) ; chart . getchartconfiguration ( ) . setgrid ( grid ) ; cursor cursor = new cursor ( ) ; cursor . setzoom ( true ) ; cursor . setclickreset ( true ) ; chart . getchartconfiguration ( ) . setcursor ( cursor ) ; string json = jqplotutils . createjquery ( chart , "div3" ) ; json = json . replaceall ( "\\$" , "jquery" ) ; system . out . println ( json ) ; }
tr	3	public static final course readcourse ( file definitionfile ) { logger . log ( level . info , "reading course from file '" + definitionfile + "'" ) ; jsonparser parser = new jsonparser ( ) ; jsonobject jsonobject = null ; try { jsonobject = ( jsonobject ) parser . parse ( new filereader ( definitionfile ) ) ; } catch ( filenotfoundexception e ) { e . printstacktrace ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } catch ( org . json . simple . parser . parseexception e ) { e . printstacktrace ( ) ; } course course = new course ( ( string ) jsonobject . get ( "name" ) , ( string ) jsonobject . get ( "address" ) , ( int ) ( ( long ) jsonobject . get ( "bestscore" ) ) , ( int ) ( ( long ) jsonobject . get ( "averagescore" ) ) , ( int ) ( ( long ) jsonobject . get ( "worstscore" ) ) , ( int ) ( ( long ) jsonobject . get ( "timesplayed" ) ) , new arraylist < hole > ( ) , ( string ) jsonobject . get ( "userwithbestscore" ) , ( string ) jsonobject . get ( "description" ) ) ; logger . log ( level . info , "created course '" + course . getname ( ) + "'" ) ; return course ; }
tr	9	private void parsepacket ( ) throws mpegdecodeexception , ioexception { statistics . startlog ( parse_packet_string ) ; system . out . println ( "parsing packet" ) ; if ( m_iotool . getbits ( 24 ) != 1 ) { debug . println ( debug . error , "synchronization error in packet" ) ; throw new mpegdecodeexception ( "synchronization error in packet" ) ; } int streamid = m_iotool . getbits ( 8 ) ; int pktlength = m_iotool . getbits ( 16 ) ; if ( streamid != private_stream2 ) { pktlength -= parsetimestamps ( ) ; } if ( ( streamid & e0 ) == c0 ) { decodeaudio ( pktlength ) ; } else { if ( ( f0 & streamid ) == e0 ) { decodevideo ( pktlength ) ; } else if ( ( f0 & streamid ) == f0 ) { ; } else { switch ( streamid ) { case reserved_stream : case private_stream1 : case padding_stream : case private_stream2 : break ; default : debug . println ( debug . error , "unknown stream: " + streamid ) ; throw new mpegdecodeexception ( "unknown stream: " + streamid ) ; } } } statistics . endlog ( parse_packet_string ) ; }
tr	8	public arraylist < point > checkmove2 ( stack < tttboard > boards , char player ) { arraylist < point > winningspots = new arraylist < point > ( ) ; arraylist < tttboard > temparray = new arraylist < tttboard > ( ) ; while ( ! boards . isempty ( ) ) { tttboard aboard = boards . pop ( ) ; arraylist < point > spots = aboard . getemptyspots ( ) ; char turn = getchar ( spots . size ( ) ) ; arraylist < tttboard > temparray2 = new arraylist < tttboard > ( ) ; for ( int i = 0 ; i < spots . size ( ) ; i ++ ) { tttboard board = new tttboard ( aboard ) ; board . getboard ( ) [ spots . get ( i ) . x ] [ spots . get ( i ) . y ] = turn ; if ( spots . size ( ) < 6 ) { if ( board . checkwin ( ) ) { if ( turn == player ) { winningspots . add ( board . getstart ( ) ) ; break ; } else { break ; } } else { temparray2 . add ( board ) ; } } else { temparray . add ( board ) ; } } if ( temparray2 . size ( ) == spots . size ( ) ) { temparray . addall ( temparray2 ) ; } } if ( winningspots . isempty ( ) && temparray . get ( 0 ) . getemptyspots ( ) . size ( ) != 0 ) { boards . addall ( temparray ) ; winningspots = checkmove2 ( boards , player ) ; } return winningspots ; }
tr	0	@ override public arraylist < string > getinsertsql ( ) { arraylist < string > ret = new arraylist < > ( ) ; string sql = "insert into caballoscarrera values (" ; sql += getoid ( ) + "  " ; sql += caballo . getcaballo ( ) . getoid ( ) + "  " ; sql += carrera . getoid ( ) + "  " ; sql += caballo . getnumero ( ) + "  " ; sql += caballo . getdividendo ( ) + "  " ; sql += caballo . gettipoapuesta ( ) . getcodigo ( ) ; sql += ");" ; ret . add ( sql ) ; return ret ; }
tr	7	public void update ( ) { arraylist < arraylist < entity >> entityarrays = new arraylist < arraylist < entity >> ( entities . values ( ) ) ; for ( int x = 0 ; x < entityarrays . size ( ) ; x ++ ) { arraylist < entity > activearray = entityarrays . get ( x ) ; for ( int y = 0 ; y < activearray . size ( ) ; y ++ ) { entity ent = activearray . get ( y ) ; arraylist < effectpackage > effects = ent . geteffectpackages ( ) ; for ( int c = 0 ; c < effects . size ( ) ; c ++ ) { effectpackage pack = effects . get ( c ) ; if ( pack . geteffect ( ) == effect . move_up ) { levelchange = true ; changeto = level - 1 ; } else if ( pack . geteffect ( ) == effect . move_down ) { levelchange = true ; changeto = level + 1 ; } } ent . update ( ) ; } } actors = new arraylist < actor > ( actorhashmap . values ( ) ) ; for ( int c = 0 ; c < actors . size ( ) ; c ++ ) { actor a = actors . get ( c ) ; a . update ( ) ; point pos = a . getpos ( ) ; if ( a . delete ( ) ) { actorhashmap . remove ( genkey ( pos . getx ( ) , pos . gety ( ) ) ) ; } } }
tr	4	void deletetime ( component dialogparent , time time ) { if ( time != null ) { if ( alertmessages . deletetimeconfirmation ( dialogparent , time ) ) { try { timedao . deletetime ( dao . getconnection ( ) , time ) ; timedialog . settime ( null ) ; timelistdialog . selectpreviousrow ( ) ; timedialog . setvisible ( false ) ; } catch ( sqlexception ex ) { errormessages . sqlexceptionerror ( "deletetime()" , ex ) ; } catch ( classnotfoundexception ex ) { errormessages . classnotfounderror ( "deletetime()" , ex ) ; } } } else { alertmessages . notimeselectedintablefordeleting ( timelistdialog ) ; } }
tr	4	public static void main ( string [ ] args ) { conn con = poolmanager . getinstance ( ) . getconnection ( ) ; connection conn = con . getconn ( ) ; statement stmt = null ; resultset rs = null ; try { stmt = conn . createstatement ( ) ; rs = stmt . executequery ( "select * from article " ) ; int c = rs . getmetadata ( ) . getcolumncount ( ) ; for ( int i = 1 ; i <= c ; ++ i ) { system . out . println ( rs . getmetadata ( ) . getcolumnname ( i ) ) ; } while ( rs . next ( ) ) { system . out . print ( rs . getstring ( "title" ) ) ; system . out . print ( rs . getstring ( "author" ) ) ; system . out . println ( ) ; } } catch ( sqlexception e ) { e . printstacktrace ( ) ; } finally { try { stmt . close ( ) ; } catch ( sqlexception e ) { e . printstacktrace ( ) ; } poolmanager . getinstance ( ) . releaseconnection ( con ) ; } }
tr	8	@ override public string replace ( string [ ] args , page page ) { string image = "" ; string link = "" ; string alt = "image" ; for ( string arg : args ) { if ( arg . startswith ( "img=" ) ) { image = arg . substring ( "img=" . length ( ) ) ; } else if ( arg . startswith ( "link=" ) ) { link = arg . substring ( "link=" . length ( ) ) ; } else if ( arg . startswith ( "alt=" ) ) { alt = arg . substring ( "alt=" . length ( ) ) ; } else if ( arg . startswith ( "http:" ) ) { image = arg ; } else if ( arg . endswith ( ".gif" ) || arg . endswith ( ".png" ) ) { image = arg ; } else { throw new unsupportedoperationexception ( "unknown image parameter: >" + arg + "<" ) ; } } return "![" + alt + "](" + image + ")" + ( link . length ( ) > 0 ? "(" + link + ")" : "" ) ; }
tr	0	public graphpaper3d ( double width , double height , double depth ) { super ( new body ( ) , width , height ) ; this . m_root = ( body ) this . getroot ( ) ; this . m_system = new body ( ) ; this . m_root . addcomponent ( this . m_system ) ; this . m_width = width ; this . m_height = height ; this . m_depth = depth ; this . setfill ( color . grey ) ; calculatepixeltocartesianconvertdata ( ) ; setuplisteners ( ) ; drawgraphinformation ( ) ; drawaxes ( ) ; setupcamera ( ) ; }
tr	3	public static integer buildjob ( string receptor , string ownerid , vinaparams vinaparams , filterparams filterparams , string dispatchqueueloc ) throws sqlexception , amazonserviceexception , jaxbexception , amazonclientexception , filenotfoundexception , ioexception { integer jobid = initializer . getinstance ( null ) . getmaxjobid ( ownerid ) + 1 ; initializer . getinstance ( null ) . putjobonserver ( ownerid , jobid , new hashmap < integer , wustatus > ( ) ) ; determineworktodo jobwork = new determineworktodo ( receptor , ownerid , filterparams ) ; string receptorid = jobwork . putreceptorindatabase ( ) ; list < string > compoundids = jobwork . filtercompoundsindatabase ( ) ; integer workunitid = 0 ; list < sendmessagebatchrequestentry > batch = new arraylist < sendmessagebatchrequestentry > ( ) ; integer iter = 0 ; for ( string i : compoundids ) { sendmessagebatchrequestentry entry = putworkunitinsqsbatch ( buildworkunit ( receptorid , i , ownerid , jobid , workunitid , vinaparams ) ) ; batch . add ( entry ) ; initializer . getinstance ( ) . putworkunit ( ownerid , jobid , workunitid , wustatus . inflight ) ; workunitid ++ ; iter ++ ; if ( iter >= 10 ) { sendmessagebatchrequest request = new sendmessagebatchrequest ( dispatchqueueloc , batch ) ; initializer . getinstance ( ) . getsqsclient ( ) . sendmessagebatch ( request ) ; iter = 0 ; batch . removeall ( batch ) ; } } if ( batch . size ( ) > 0 ) { sendmessagebatchrequest request = new sendmessagebatchrequest ( dispatchqueueloc , batch ) ; initializer . getinstance ( ) . getsqsclient ( ) . sendmessagebatch ( request ) ; system . out . println ( "batch sent" ) ; } return jobid ; }
tr	2	private boolean isvaliduserinput ( final string hostname , final string port ) { final string methodname = "isvaliduserinput" ; controllerlogger . entering ( class_name , methodname , hostname , port ) ; try { if ( guiutils . isemptyvalue ( hostname ) ) { guiutils . showwarningmessage ( connecttoserverwindow , guimessages . invalid_hostname_message ) ; return false ; } if ( ! guiutils . isportnumbervalid ( port ) ) { guiutils . showwarningmessage ( connecttoserverwindow , guimessages . invalid_port_number_message ) ; return false ; } return true ; } finally { controllerlogger . exiting ( class_name , methodname ) ; } }
tr	4	private void parsedisplaybpm ( string bpmvalues , simfile accumulator ) { final string [ ] bpmcodes = bpmvalues . split ( " " ) ; double min = integer . max_value ; string mintext = "" ; double max = integer . min_value ; string maxtext = "" ; for ( string bpmcode : bpmcodes ) { string bpmtext = bpmcode . substring ( bpmcode . indexof ( = ) + 1 ) ; double bpm = double . parsedouble ( bpmtext ) ; if ( bpm < min ) { min = bpm ; mintext = bpmtext ; } if ( bpm > max ) { max = bpm ; maxtext = bpmtext ; } } string displaybpm ; if ( max == min ) { displaybpm = mintext ; } else { displaybpm = mintext + " - " + maxtext ; } accumulator . setdisplaybpm ( displaybpm ) ; }
tr	8	private void creategame ( ) { gamename = fieldgamename . gettext ( ) ; playernamehost = fieldplayername . gettext ( ) ; enumeration < networkinterface > nets = null ; try { nets = networkinterface . getnetworkinterfaces ( ) ; } catch ( socketexception e1 ) { } vector < string > l = new vector < string > ( ) ; for ( networkinterface netint : collections . list ( nets ) ) { enumeration < inetaddress > inetaddresses = netint . getinetaddresses ( ) ; for ( inetaddress inetaddress : collections . list ( inetaddresses ) ) { l . add ( netint . getdisplayname ( ) + " (" + inetaddress . tostring ( ) . substring ( 1 ) + ")" ) ; } } object selval = joptionpane . showinputdialog ( this , "choose interface to bind" , "input" , joptionpane . information_message , null , l . toarray ( ) , l . elementat ( 0 ) ) ; string ip = selval . tostring ( ) ; int beg = ip . lastindexof ( ( ) ; int end = ip . lastindexof ( ) ) ; string ipaddr = selval . tostring ( ) . substring ( beg + 1 , end ) ; try { addr = inetaddress . getbyname ( ipaddr ) ; } catch ( unknownhostexception e1 ) { } if ( gamename == null || gamename . isempty ( ) ) { joptionpane . showmessagedialog ( null , "each game needs a name" , "game name" , joptionpane . error_message ) ; return ; } if ( playernamehost == null || playernamehost . isempty ( ) ) { joptionpane . showmessagedialog ( null , "each player needs a name" , "player name" , joptionpane . error_message ) ; return ; } dispose ( ) ; s = new server ( ipaddr ) ; adapter . connecttoserver ( addr , playernamehost ) ; hostframe . setdefaultcloseoperation ( jframe . exit_on_close ) ; hostframe . settitle ( "snake on lan - host game" ) ; hostframe . setvisible ( true ) ; hostframe . setresizable ( false ) ; hostframe . setlocationrelativeto ( null ) ; startsnakegame . frame . dispose ( ) ; }
tr	9	void append ( dnsincoming that ) { if ( this . isquery ( ) && this . istruncated ( ) && that . isquery ( ) ) { if ( that . numquestions > 0 ) { if ( collections . empty_list . equals ( this . questions ) ) this . questions = collections . synchronizedlist ( new arraylist ( that . numquestions ) ) ; this . questions . addall ( that . questions ) ; this . numquestions += that . numquestions ; } if ( collections . empty_list . equals ( answers ) ) { answers = collections . synchronizedlist ( new arraylist ( ) ) ; } if ( that . numanswers > 0 ) { this . answers . addall ( this . numanswers , that . answers . sublist ( 0 , that . numanswers ) ) ; this . numanswers += that . numanswers ; } if ( that . numauthorities > 0 ) { this . answers . addall ( this . numanswers + this . numauthorities , that . answers . sublist ( that . numanswers , that . numanswers + that . numauthorities ) ) ; this . numauthorities += that . numauthorities ; } if ( that . numadditionals > 0 ) { this . answers . addall ( that . answers . sublist ( that . numanswers + that . numauthorities , that . numanswers + that . numauthorities + that . numadditionals ) ) ; this . numadditionals += that . numadditionals ; } } else { throw new illegalargumentexception ( ) ; } }
tr	7	public void onenable ( ) { server = getserver ( ) ; log = server . getlogger ( ) ; setpdffile ( this . getdescription ( ) ) ; movefiles ( ) ; setuppermissions ( ) ; questplayerstorage = new iproperty ( "plugins/uquest/uquest_players.txt" ) ; if ( new file ( "plugins/uquest/uquest_quests.txt" ) . exists ( ) ) new questconverter ( ) ; if ( isusedefaultuquest ( ) ) { cmd_uquest cmd_uquest = new cmd_uquest ( this ) ; getcommand ( "uquest" ) . setexecutor ( cmd_uquest ) ; getcommand ( "quest" ) . setexecutor ( cmd_uquest ) ; try { getcommand ( "q" ) . setexecutor ( cmd_uquest ) ; } catch ( nullpointerexception npe ) { usedefaulthelp = false ; } } setupeconomy ( ) ; cmd_reloadquests cmd_reloadquests = new cmd_reloadquests ( this ) ; getcommand ( "reloadquests" ) . setexecutor ( cmd_reloadquests ) ; cmd_reloadquestconfig cmd_reloadquestconfig = new cmd_reloadquestconfig ( this ) ; getcommand ( "reloadquestconfig" ) . setexecutor ( cmd_reloadquestconfig ) ; readconfig ( ) ; thequestsloadallintoarray ( ) ; if ( this . thequests . isempty ( ) ) { system . err . println ( "\n\n\n" + pluginnamebracket ( ) + " you have an empty quest list!\n disabling plugin.\n\n\n" ) ; server . getpluginmanager ( ) . disableplugin ( this ) ; return ; } if ( isusesqlite ( ) == true ) { this . setdb ( new sqlitekeyvalstor < quester > ( "questers" , "plugins/uquest/uquestquesters" ) ) ; system . out . println ( pluginnamebracket ( ) + " loaded with sqlite!" ) ; } if ( firstload == true && isusesqlite ( ) == false ) { timersaveplayers ( ) ; firstload = false ; system . out . println ( pluginnamebracket ( ) + " loaded with flatfile!" ) ; } registerevents ( ) ; system . out . println ( pluginnamebracket ( ) + " v" + getpdffile ( ) . getversion ( ) + " enabled! with " + this . getquestinteraction ( ) . getquesttotal ( ) + " quests loaded!" ) ; }
tr	1	public int print ( graphics graphics , pageformat pageformat , int pageindex ) throws printerexception { if ( pageindex >= 1 ) return printable . no_such_page ; graphics2d g2d = ( graphics2d ) graphics ; double h = pageformat . getimageableheight ( ) ; double w = pageformat . getimageablewidth ( ) ; double x = pageformat . getimageablex ( ) ; double y = pageformat . getimageabley ( ) ; system . out . println ( "pf:" + x + " " + y + " " + w + " " + h ) ; g2d . translate ( x , y ) ; dimension size = new dimension ( ( int ) w , ( int ) h ) ; paintit ( g2d , size ) ; return printable . page_exists ; }
tr	0	@ test public void getvirusscore_virusfinderandscorercalledcorrectlyandscorereturned ( ) { string sequence = "abbaacdeeefa" ; map < string , integer > result = new hashmap < string , integer > ( ) ; result . put ( "abc" , 10 ) ; argumentcaptor < string > sequencecapture = argumentcaptor . forclass ( string . class ) ; mockito . when ( genomevirusfinder . findviruses ( sequencecapture . capture ( ) , mockito . anylistof ( string . class ) ) ) . thenreturn ( result ) ; mockito . when ( genomevirusscorer . gettotalscore ( result ) ) . thenreturn ( 10 ) ; inorder inorder = mockito . inorder ( genomevirusfinder , genomevirusscorer ) ; int score = sequencer . getvirusscore ( sequence ) ; assert . assertequals ( 10 , score ) ; assert . assertequals ( sequence , sequencecapture . getallvalues ( ) . get ( 0 ) ) ; inorder . verify ( genomevirusfinder , mockito . times ( 1 ) ) . findviruses ( sequencecapture . capture ( ) , mockito . anylistof ( string . class ) ) ; inorder . verify ( genomevirusscorer , mockito . times ( 1 ) ) . gettotalscore ( result ) ; }
tr	0	@ beforemethod public void beforemethod ( ) { database = new database ( "first_db" ) ; coldefs = new linkedhashmap < > ( ) ; coldefs . put ( "foo" , new columndefinition ( datatype . float , false , true ) ) ; coldefs . put ( "bar" , new columndefinition ( datatype . integer ) ) ; coldefs . put ( "baz" , new columndefinition ( datatype . string , true , false ) ) ; table table = new table ( "table_1" , coldefs ) ; database . add ( table ) ; parser = new parser ( database ) ; parser . parse ( "insert into table_1 values (15.46  17  'testing');" ) . executemodification ( ) ; parser . parse ( "insert into table_1 values (13  27  'foo');" ) . executemodification ( ) ; parser . parse ( "insert into table_1 values (57735.12  1  'this');" ) . executemodification ( ) ; parser . parse ( "insert into table_1 values (0.0007  3486978  'is');" ) . executemodification ( ) ; parser . parse ( "insert into table_1 values (1556.345  8975  'testing');" ) . executemodification ( ) ; }
tr	3	public static boolean ononeline ( xy xy , xy xy2 ) { if ( xy2 . getx ( ) == xy . getx ( ) ) { return true ; } if ( xy2 . gety ( ) == xy . gety ( ) ) { return true ; } int dx = math . abs ( xy2 . getx ( ) - xy . getx ( ) ) ; int dy = math . abs ( xy2 . gety ( ) - xy . gety ( ) ) ; if ( dx == dy ) { return true ; } return false ; }
tr	1	@ override public object [ ] [ ] getall ( ) { daofactory factory = daofactory . getdaofactory ( ) ; teacherdao dao = factory . getteacherdao ( ) ; list < teacher > teachers = dao . selectall ( ) ; object [ ] [ ] rowdata = new object [ teachers . size ( ) ] [ 4 ] ; for ( int i = 0 ; i < teachers . size ( ) ; i ++ ) { teacher teacher = teachers . get ( i ) ; rowdata [ i ] [ 0 ] = teacher . getcode ( ) ; rowdata [ i ] [ 1 ] = teacher . getnames ( ) ; rowdata [ i ] [ 2 ] = dateformathelper . format ( teacher . getbirthday ( ) ) ; rowdata [ i ] [ 3 ] = teacher . getemail ( ) ; } return rowdata ; }
tr	8	public static double nextafter ( double d , double direction ) { if ( double . isnan ( d ) || double . isnan ( direction ) ) { return double . nan ; } else if ( d == direction ) { return direction ; } else if ( double . isinfinite ( d ) ) { return ( d < 0 ) ? - double . max_value : double . max_value ; } else if ( d == 0 ) { return ( direction < 0 ) ? - double . min_value : double . min_value ; } final long bits = double . doubletolongbits ( d ) ; final long sign = bits & 8000000000000000 ; if ( ( direction < d ) ^ ( sign == 0 ) ) { return double . longbitstodouble ( sign | ( ( bits & 7fffffffffffffff ) + 1 ) ) ; } else { return double . longbitstodouble ( sign | ( ( bits & 7fffffffffffffff ) - 1 ) ) ; } }
tr	4	public synchronized boolean docrescidinosauro ( string token , string iddinosauro ) throws invalidtokenexception , genericdinosauroexception { coord coordtoremove = null ; try { if ( getplayerbytoken ( token ) . getrazza ( ) . existsdinosaurowithid ( iddinosauro ) ) { coordtoremove = getplayerbytoken ( token ) . getrazza ( ) . getdinosaurobyid ( iddinosauro ) . getcoord ( ) ; getplayerbytoken ( token ) . getrazza ( ) . crescidinosauro ( iddinosauro ) ; return true ; } return false ; } catch ( invalidtokenexception e ) { throw new invalidtokenexception ( ) ; } catch ( genericdinosauroexception e ) { if ( e . getmessage ( ) . equals ( "morteperinedia" ) ) { getmappa ( ) . rimuoviildinosaurodallacella ( coordtoremove ) ; } throw new genericdinosauroexception ( e . getmessage ( ) ) ; } }
tr	9	public static double performforward ( final net net , final sample sample , final int [ ] features ) { final int inputlength = sample . getinputlength ( ) ; final int targetlength = sample . gettargetlength ( ) ; final int last = ( sample . getinputlength ( ) - 1 ) ; net . setframeidx ( 0 ) ; double error = 0.0 ; if ( net . isonline ( ) ) { for ( int t = 0 ; t <= last ; t ++ ) { if ( features != null ) { sample . mapinput ( net . inputport ( ) , t , features ) ; } else { sample . mapinput ( net . inputport ( ) , t ) ; } net . compute ( ) ; if ( t < last ) net . incrframeidx ( ) ; } final int first = math . max ( 0 , inputlength - targetlength ) ; int soff = targetlength - 1 ; for ( int t = last ; t >= first ; t -- ) { sample . maptarget ( net . targetport ( ) , soff -- ) ; error += net . error ( ) ; if ( t > 0 ) net . decrframeidx ( ) ; } net . setframeidx ( last ) ; } else { for ( int t = 0 ; t <= last ; t ++ ) { if ( features != null ) { sample . mapinput ( net . inputport ( ) , t , features ) ; } else { sample . mapinput ( net . inputport ( ) , t ) ; } if ( t < last ) net . incrframeidx ( ) ; } net . compute ( ) ; sample . maptarget ( net . targetport ( ) ) ; error = net . error ( ) ; } return ( error / ( ( double ) targetlength ) ) ; }
tr	8	public bytebuffer getbuffer ( string filepath ) { bytebuffer buffer = filemaps . get ( filepath ) ; if ( buffer == null ) { file requestedfile = new file ( filepath ) ; if ( requestedfile != null && requestedfile . exists ( ) ) { fileinputstream fileinput = null ; filechannel filechannel = null ; try { fileinput = new fileinputstream ( requestedfile ) ; filechannel = fileinput . getchannel ( ) ; if ( filechannel . size ( ) < ( 1024 * 1024 * 10 ) ) { mappedbytebuffer filebuffer = filechannel . map ( mapmode . read_only , 0 , filechannel . size ( ) ) ; filebuffer . load ( ) ; this . filemaps . put ( filepath , filebuffer ) ; buffer = filebuffer . asreadonlybuffer ( ) ; } else { buffer = null ; } } catch ( ioexception e ) { e . printstacktrace ( ) ; } finally { try { if ( fileinput != null ) { fileinput . close ( ) ; fileinput = null ; } if ( filechannel != null ) { filechannel . close ( ) ; filechannel = null ; } } catch ( ioexception ex ) { ex . printstacktrace ( ) ; } } } } return buffer ; }
tr	6	protected byte [ ] convertpasswordtokey ( string password ) { if ( password == null ) return null ; int count = password . length ( ) ; if ( count < 8 ) password += "         " . substring ( count ) ; byte [ ] pw = password . getbytes ( ) ; count = pw . length ; int pos = 0 ; byte [ ] key = new byte [ 7 ] ; for ( ; ; ) { for ( int n = 0 ; n < 7 ; n ++ ) { int p1 = pw [ pos + n ] & ff ; p1 >>= n ; int p2 = pw [ pos + n + 1 ] & ff ; p2 <<= ( 7 - n ) ; key [ n ] = ( byte ) ( p1 + p2 ) ; } pos += 8 ; if ( pos == count ) return key ; int pending = count - pos ; if ( pending < 8 ) pos -= 8 - pending ; encrypt ( key , pw , pos , 8 ) ; } }
tr	9	public void setproperty ( string prop , object value ) { map < string , class < ? extends object >> specialproperties = null ; try { java . lang . reflect . field f = class . forname ( new throwable ( ) . fillinstacktrace ( ) . getstacktrace ( ) [ 1 ] . getclassname ( ) ) . getfield ( "special_properties" ) ; if ( f . gettype ( ) . getname ( ) . equals ( "java.util.map" ) ) { specialproperties = ( map < string , class < ? extends object >> ) f . get ( null ) ; } } catch ( exception e ) { } if ( ( channel . allowed_properties . containskey ( prop ) && value . getclass ( ) . equals ( channel . allowed_properties . get ( prop ) ) ) || ( specialproperties != null && specialproperties . containskey ( prop ) && value . getclass ( ) . equals ( specialproperties . get ( prop ) ) ) ) { this . properties . put ( prop , value ) ; } else { throw new illegalargumentexception ( ) ; } }
tr	8	public void determinechunkstats ( ) { int emptyneighborindex = integer . min_value ; reset ( ) ; for ( int i = 0 ; i < map . length ; i ++ ) { boolean isrowempty = true ; for ( int j = 0 ; j < map [ i ] . length ; j ++ ) { if ( map [ i ] [ j ] != 0 ) { isrowempty = false ; } checkenemy ( i , j ) ; checkcannons ( i , j ) ; checktubes ( i , j ) ; checkhills ( i , j ) ; recordotherstats ( i , j ) ; } if ( isrowempty && i - 1 != emptyneighborindex ) { emptyneighborindex = i ; numjumps ++ ; difficulty ++ ; if ( this . type != type . jump && numjumps > getcurrenttypecount ( ) ) { this . type = type . jump ; } } else if ( isrowempty ) emptyneighborindex = i ; } }
tr	2	public void createrestartfile ( string header , int dateindex , int depthindex ) { file infile = new file ( header ) ; string outputname = outputfolder + "/" + sdf . format ( releasedates [ dateindex ] ) + "_" + mindepths [ depthindex ] + "-" + maxdepths [ depthindex ] + ".prm" ; file outfile = new file ( restartfile ) ; try { copyfileusingstream ( infile , outfile ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } try ( bufferedwriter bw = new bufferedwriter ( new filewriter ( outfile , true ) ) ; ) { bw . write ( "(java " + prms + " -jar " + jarfile + " " + outputname + " " + configurationfile + " " + source + " > " + logdir + "/" + prefix + dateindex + "d" + depthindex + ".log)&\n" ) ; bw . write ( cronstring ( ) ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } }
tr	6	@ override public void doturn ( ) { getlocation ( ) . world . cleartilevisibility ( ) ; for ( int y = getlocation ( ) . y + getviewdistance ( ) ; y >= getlocation ( ) . y - getviewdistance ( ) ; y -- ) { int deltax = getviewdistance ( ) - math . abs ( y - getlocation ( ) . y ) ; for ( int x = getlocation ( ) . x + deltax ; x >= getlocation ( ) . x - deltax ; x -- ) { if ( aicontroller . checkvisibility ( getlocation ( ) , new worldlocation ( null , x , y ) ) ) { getlocation ( ) . world . settilevisible ( x , y , true ) ; } if ( new worldlocation ( getlocation ( ) . world , x , y ) . gettile ( ) instanceof tilesecretdoor ) { int chance = 30 - getstats ( ) . getintelligence ( ) ; if ( chance <= 0 || new random ( ) . nextint ( chance ) == 0 ) { logmessage ( "something about one of the walls nearby seems off to you" ) ; } } } } }
tr	9	@ suppresswarnings ( "rawtypes" ) public void paint ( graphics g ) { super . paint ( g ) ; graphics2d g2d = ( graphics2d ) g ; drawbackground ( g ) ; drawscore ( g ) ; if ( gamecraft . direction == 3 ) { g2d . drawimage ( resourceloader . imageload ( "/playerback.png" ) , gamecraft . getx ( ) , gamecraft . gety ( ) , this ) ; } else if ( gamecraft . direction == 0 ) { g2d . drawimage ( resourceloader . imageload ( "/playerfront.png" ) , gamecraft . getx ( ) , gamecraft . gety ( ) , this ) ; } else if ( gamecraft . direction == 1 ) { g2d . drawimage ( resourceloader . imageload ( "/playerleft.png" ) , gamecraft . getx ( ) , gamecraft . gety ( ) , this ) ; } else if ( gamecraft . direction == 2 ) { g2d . drawimage ( resourceloader . imageload ( "/playerright.png" ) , gamecraft . getx ( ) , gamecraft . gety ( ) , this ) ; } else { g2d . drawimage ( resourceloader . imageload ( "/playerfront.png" ) , gamecraft . getx ( ) , gamecraft . gety ( ) , this ) ; } arraylist ms = gamecraft . getbulletdown ( ) ; for ( int i = 0 ; i < ms . size ( ) ; i ++ ) { bulletdown m = ( bulletdown ) ms . get ( i ) ; g2d . drawimage ( m . getimage ( ) , m . getx ( ) , m . gety ( ) , this ) ; } arraylist msup = gamecraft . getbulletup ( ) ; for ( int i = 0 ; i < msup . size ( ) ; i ++ ) { bulletup m = ( bulletup ) msup . get ( i ) ; g2d . drawimage ( m . getimage ( ) , m . getx ( ) , m . gety ( ) , this ) ; } arraylist msleft = gamecraft . getbulletleft ( ) ; for ( int i = 0 ; i < msleft . size ( ) ; i ++ ) { bulletleft m = ( bulletleft ) msleft . get ( i ) ; g2d . drawimage ( m . getimage ( ) , m . getx ( ) , m . gety ( ) , this ) ; } arraylist msright = gamecraft . getbulletright ( ) ; for ( int i = 0 ; i < msright . size ( ) ; i ++ ) { bulletright m = ( bulletright ) msright . get ( i ) ; g2d . drawimage ( m . getimage ( ) , m . getx ( ) , m . gety ( ) , this ) ; } arraylist msenemys = gamecraft . getenemys ( ) ; for ( int i = 0 ; i < msenemys . size ( ) ; i ++ ) { enemys m = ( enemys ) msenemys . get ( i ) ; g2d . drawimage ( m . getimage ( ) , m . getx ( ) , m . gety ( ) , this ) ; } toolkit . getdefaulttoolkit ( ) . sync ( ) ; g . dispose ( ) ; }
tr	2	@ override public string getasstring ( facescontext facescontext , uicomponent component , object object ) { if ( object == null ) { return null ; } if ( object instanceof keystate ) { keystate o = ( keystate ) object ; return getstringkey ( o . getidkeystate ( ) ) ; } else { logger . getlogger ( this . getclass ( ) . getname ( ) ) . log ( level . severe , "object {0} is of type {1}; expected type: {2}" , new object [ ] { object , object . getclass ( ) . getname ( ) , keystate . class . getname ( ) } ) ; return null ; } }
tr	8	private void checkfortermination ( int timezone ) { terminationcounter countert = terminationcounters . get ( timezone ) ; logger . info ( "balance: " + countert . getsentmessages ( ) + " / " + countert . getreceivedmessages ( ) ) ; if ( countert . isbalanced ( ) && countert . isnotempty ( ) ) { terminationcounter counterprev = terminationcounters . get ( timezone - 1 ) ; terminationcounter counternext = terminationcounters . get ( timezone + 1 ) ; if ( counterprev != null ) { if ( counterprev . isbalanced ( ) && counterprev . isnotempty ( ) ) { keeprunning = false ; logger . info ( "termination reached! messages sent: " + countert . getsentmessages ( ) + " messages received: " + countert . getreceivedmessages ( ) ) ; } else { if ( counternext != null && counternext . isbalanced ( ) && counternext . isnotempty ( ) ) { keeprunning = false ; logger . info ( "termination reached! messages sent: " + countert . getsentmessages ( ) + " messages received: " + countert . getreceivedmessages ( ) ) ; } } } } }
tr	0	private void addtabs ( ) { addproduct = new viewaddproviderpanel ( adminprovider ) ; modifyprovidertable = new viewmodifyprovidertablepanel ( adminprovider ) ; modifyprovider = new viewmodifyproviderpanel ( adminprovider ) ; modifyprovidertable . settabs ( tabs ) ; modifyprovidertable . setswitchpanel ( modifyprovider ) ; modifyprovidertable . setname ( "modificar proveedor" ) ; modifyprovider . settabs ( tabs ) ; modifyprovider . setswitchpanel ( modifyprovidertable ) ; modifyprovider . setname ( "modificar proveedor" ) ; removeprovidertable = new viewremoveprovidertablepanel ( adminprovider ) ; removeprovider = new viewremoveproviderpanel ( adminprovider ) ; removeprovidertable . settabs ( tabs ) ; removeprovidertable . setswitchpanel ( removeprovider ) ; removeprovidertable . setname ( "eliminar proveedor" ) ; removeprovider . settabs ( tabs ) ; removeprovider . setswitchpanel ( removeprovidertable ) ; removeprovider . setname ( "eliminar proveedor" ) ; tabs . addtab ( "agregar proveedor" , addproduct ) ; tabs . setmnemonicat ( 0 , keyevent . vk_1 ) ; tabs . addtab ( "modificar proveedor" , modifyprovidertable ) ; tabs . addtab ( "eliminar proveedor" , removeprovidertable ) ; pack ( ) ; }
tr	0	public static void main ( string [ ] args ) throws interruptedexception { final thread t1 = new thread ( ) { public void run ( ) { logger . info ( "t1 start wait" ) ; locksupport . park ( ) ; logger . info ( "t1 get signal" ) ; } } ; thread t2 = new thread ( ) { public void run ( ) { logger . info ( "t2 start signal" ) ; locksupport . unpark ( t1 ) ; logger . info ( "t2 end" ) ; } } ; t1 . start ( ) ; t2 . start ( ) ; t1 . join ( ) ; t2 . join ( ) ; }
tr	5	public void wc ( mainclass mc , encounter e ) { int x = mc . getxpos ( ) ; int y = mc . getypos ( ) ; int k = e . getkeypress ( ) ; if ( x >= 300 && x <= 450 ) { if ( y >= 40 && y <= 140 ) { e . win = false ; mainclass . getplayer ( ) . addxp ( e . m . calculatexp ( ) ) ; mainclass . getplayer ( ) . addgold ( e . m . getgold ( ) ) ; mainclass . getplayer ( ) . setcurrenthp ( e . p . getcurrenthp ( ) ) ; mc . getmaphandler ( ) . getthemap ( ) . gettile ( e . m . getcurtilex ( ) , e . m . getcurtiley ( ) ) . clearchar1 ( ) ; mc . getmaphandler ( ) . checkxp = true ; mc . setscreen ( "map" ) ; } } else if ( k == 10 ) { e . win = false ; e . setkeypress ( 0 ) ; mainclass . getplayer ( ) . addxp ( e . m . calculatexp ( ) ) ; mainclass . getplayer ( ) . addgold ( e . m . getgold ( ) ) ; mainclass . getplayer ( ) . setcurrenthp ( e . p . getcurrenthp ( ) ) ; mc . getmaphandler ( ) . getthemap ( ) . gettile ( e . m . getcurtilex ( ) , e . m . getcurtiley ( ) ) . clearchar1 ( ) ; mc . getmaphandler ( ) . checkxp = true ; mc . setscreen ( "map" ) ; } }
tr	4	public firstchoicepercent ( algorithmoutput output ) { int total = 0 ; int firsts = 0 ; for ( timeslot t : output . keyset ( ) ) { for ( student s : output . get ( t ) ) { total ++ ; if ( s . getfirstchoicelabs ( ) . contains ( s . getassignedlab ( ) ) ) { firsts ++ ; } } } this . fitness = ( double ) 100 * ( ( double ) firsts / ( double ) total ) ; if ( debug ) { system . out . println ( fitness ) ; } output . addfitness ( "firstchoicepercent" , fitness ) ; }
tr	5	public static void main ( string [ ] args ) { suitors mysuitors = new suitors ( ) ; for ( int i = 0 ; i < 22 ; i ++ ) mysuitors . add ( ) ; suitor thesuitor = mysuitors . head ; boolean done = false ; int count = 0 ; while ( ! done ) { if ( thesuitor . next . number == thesuitor . number ) done = true ; else { thesuitor = thesuitor . next . next . next ; mysuitors . remove ( thesuitor ) ; count ++ ; if ( count > 0 && count % 5 == 0 ) { mysuitors . display ( ) ; system . out . println ( ) ; } } } system . out . println ( "and the winner is..." ) ; mysuitors . display ( ) ; }
tr	7	protected void notifyreceivedack ( mqttack ack ) throws mqttexception { final string methodname = "notifyreceivedack" ; this . lastinboundactivity = system . currenttimemillis ( ) ; log . fine ( classname , methodname , "627" , new object [ ] { new integer ( ack . getmessageid ( ) ) , ack } ) ; mqtttoken token = tokenstore . gettoken ( ack ) ; mqttexception mex = null ; if ( ack instanceof mqttpubrec ) { mqttpubrel rel = new mqttpubrel ( ( mqttpubrec ) ack ) ; this . send ( rel , token ) ; } else if ( ack instanceof mqttpuback || ack instanceof mqttpubcomp ) { notifyresult ( ack , token , mex ) ; } else if ( ack instanceof mqttpingresp ) { pingoutstanding = false ; notifyresult ( ack , token , mex ) ; tokenstore . removetoken ( ack ) ; } else if ( ack instanceof mqttconnack ) { int rc = ( ( mqttconnack ) ack ) . getreturncode ( ) ; if ( rc == 0 ) { synchronized ( queuelock ) { if ( cleansession ) { clearstate ( ) ; tokenstore . savetoken ( token , ack ) ; } inflightpubrels = 0 ; actualinflight = 0 ; restoreinflightmessages ( ) ; connected ( ) ; } } else { mex = exceptionhelper . createmqttexception ( rc ) ; throw mex ; } clientcomms . connectcomplete ( ( mqttconnack ) ack , mex ) ; notifyresult ( ack , token , mex ) ; tokenstore . removetoken ( ack ) ; synchronized ( queuelock ) { queuelock . notifyall ( ) ; } } else { notifyresult ( ack , token , mex ) ; releasemessageid ( ack . getmessageid ( ) ) ; tokenstore . removetoken ( ack ) ; } checkquiescelock ( ) ; }
tr	1	public dimension resizeriskboard ( int height , int width ) { dimension d = background . resizeimage ( height , width ) ; this . setpreferredsize ( d ) ; this . setminimumsize ( d ) ; this . setmaximumsize ( d ) ; this . setbounds ( 0 , 0 , ( int ) d . getwidth ( ) , ( int ) d . getheight ( ) ) ; map . setpreferredsize ( d ) ; map . setminimumsize ( d ) ; map . setmaximumsize ( d ) ; map . setbounds ( 0 , 0 , ( int ) d . getwidth ( ) , ( int ) d . getheight ( ) ) ; buttonpanel . setpreferredsize ( d ) ; buttonpanel . setminimumsize ( d ) ; buttonpanel . setmaximumsize ( d ) ; buttonpanel . setbounds ( 0 , 0 , ( int ) d . getwidth ( ) , ( int ) d . getheight ( ) ) ; background . setpreferredsize ( d ) ; background . setminimumsize ( d ) ; background . setmaximumsize ( d ) ; background . setbounds ( 0 , 0 , ( int ) d . getwidth ( ) , ( int ) d . getheight ( ) ) ; repaint ( ) ; for ( countrybutton c : countrybuttons . values ( ) ) { c . setcurrentposition ( d . width , d . height ) ; } return d ; }
tr	8	public static string getafullmessage ( string [ ] finalwords , socketchannel s ) throws ioexception { bytebuffer b = bytebuffer . allocatedirect ( global . buffer_length ) ; string retour = "" ; string m ; string token ; int i = 0 ; boolean continuer = true ; while ( continuer && i < global . buffer_length ) { if ( s . read ( b ) == - 1 ) { utilitaires . out ( "fr\u00e9quence 2" , 2 , true ) ; continuer = false ; } if ( s . socket ( ) . isclosed ( ) ) { utilitaires . out ( "socket ferm\u00e9e !" ) ; throw new ioexception ( ) ; } i ++ ; b . flip ( ) ; m = bufftostring ( b ) ; retour += m ; b . clear ( ) ; scanner sc = new scanner ( m ) ; while ( sc . hasnext ( ) && continuer ) { token = sc . next ( ) ; for ( string w : finalwords ) { if ( token . equals ( w ) ) { continuer = false ; break ; } } } sc . close ( ) ; } return retour ; }
tr	3	public polygon getpolygon ( string s_namecity ) { polygon polygontoreturn = new polygon ( ) ; for ( district district : model . getlistdistrict ( ) ) { for ( city city : district . getlistcity ( ) ) { if ( city . gets_name ( ) . equals ( s_namecity ) ) { int i_x = district . geti_x ( ) * model . geti_nbhorizontalsquareindistrict ( ) + city . geti_x ( ) + ( district . geti_y ( ) % 2 ) * model . geti_nbhorizontalsquareindistrict ( ) / 2 ; int i_y = district . geti_y ( ) * model . geti_nbverticalsquareindistrict ( ) + city . geti_y ( ) ; point point2d = new point ( i_x , i_y ) ; polygontoreturn . setpoint2d ( point2d ) ; polygontoreturn . setpoint3d ( convert2dto3d ( point2d ) ) ; return polygontoreturn ; } } } return polygontoreturn ; }
tr	7	@ override public string filterinsertedstring ( filterbypass fb , int offs , string str , attributeset a ) { string result = new string ( ) ; if ( negative && offs == 0 && str . charat ( 0 ) == - ) { result = "-" ; } try { document doc = fb . getdocument ( ) ; int firstdecimal = str . indexof ( . ) ; if ( decimal && firstdecimal != - 1 && doc . gettext ( 0 , doc . getlength ( ) ) . indexof ( . ) == - 1 ) { result += str . substring ( 0 , firstdecimal ) . replaceall ( "\\d" , "" ) ; result += . ; result += str . substring ( firstdecimal + 1 ) . replaceall ( "\\d" , "" ) ; } else { result += str . replaceall ( "\\d" , "" ) ; } } catch ( badlocationexception e ) { e . printstacktrace ( ) ; } return result ; }
tr	9	protected void stepforward ( boolean showsteps ) { switch ( m_currentphase ) { case phase_preprocessing : long precsize = getnumprecomputedblocs ( ) ; if ( precsize > integer . max_value ) { joptionpane . showmessagedialog ( null , "number of precompiled matrix too large!" , "error" , joptionpane . error_message ) ; return ; } int megs = ( int ) ( ( double ) ( 550 * precsize ) / 1000000.0 ) ; numberformat nf = numberformat . getinstance ( ) ; string precsizestr = nf . format ( precsize ) ; if ( precsize > precompiled_warning_limit ) { int retval = joptionpane . showconfirmdialog ( null , "warning! the number of blocs to compute will be very large (" + precsizestr + ").\n you will need a huge amount of memory (~" + megs + " mb).\n do you still want to continue?" , "warning!" , joptionpane . yes_no_option ) ; if ( retval != joptionpane . yes_option ) { return ; } } try { m_preproctable = new hashtable ( ( int ) precsize ) ; m_orderedkeys = new arraylist ( ( int ) precsize ) ; } catch ( java . lang . outofmemoryerror e ) { m_preproctable = null ; m_orderedkeys = null ; runtime . getruntime ( ) . gc ( ) ; joptionpane . showmessagedialog ( null , "out of memory!\n (please give " + "a second to the garbage collector " + "to clean this mess..).\n" + "note: il could be unstable anyway" , "didn't i tell you? :)" , joptionpane . error_message ) ; runtime . getruntime ( ) . gc ( ) ; runtime . getruntime ( ) . gc ( ) ; return ; } preprocessingframe prfrm = new preprocessingframe ( m_preproctable , m_orderedkeys , m_t , m_encodedalphsize , this ) ; prfrm . show ( ) ; m_currentstep = 0 ; m_currentphase = phase_calc_grid ; break ; case phase_calc_grid : if ( m_currentstep >= m_nhblocs * m_nvblocs ) { m_backtracklastsel = m_dptable . getlastcell ( ) ; for ( int i = 0 ; i < 3 ; i ++ ) { m_resline [ i ] = "" ; } setinfomessage ( "backtracking pointers. policy used: " + cellelement . getpolicyname ( m_backtrackingpolicy ) + "." ) ; m_currentphase = phase_backtrack ; ( ( frtable ) m_dptable ) . setshowbackgroundindexes ( false ) ; m_dptable . clearhighlightcolors ( ) ; m_dwpanel . setvisible ( true ) ; m_l1choiche . setvisible ( true ) ; m_l2choiche . setvisible ( true ) ; m_l3choiche . setvisible ( true ) ; stepfwdbacktrack ( showsteps ) ; } else { setinfomessage ( "applying preprocessed blocs. step: " + m_currentstep ) ; this . stepfwdcalc ( showsteps ) ; } break ; case phase_backtrack : stepfwdbacktrack ( showsteps ) ; break ; } }
tr	9	public void updateui ( arraylist < comparable > list ) { tglbtnleuchte . setselected ( ( boolean ) list . get ( automat . adressen . leuchte . ordinal ( ) ) ) ; tglbtneingangslichtschranke . setselected ( ( boolean ) list . get ( automat . adressen . eingangslichtschranke . ordinal ( ) ) ) ; ; tglbtnjustierlichtschranke . setselected ( ( boolean ) list . get ( automat . adressen . justierlichtschranke . ordinal ( ) ) ) ; ; tglbtnausgangslichtschranke . setselected ( ( boolean ) list . get ( automat . adressen . ausgangslichtschranke . ordinal ( ) ) ) ; ; tglbtneingangauswahlklappe . setselected ( ( boolean ) list . get ( automat . adressen . auswahlklappeeingangslichtschranke . ordinal ( ) ) ) ; ; tglbtnlichtschrankepet . setselected ( ( boolean ) list . get ( automat . adressen . uebergabelichtschrankepet . ordinal ( ) ) ) ; ; tglbtnlichtschrankemehrweg . setselected ( ( boolean ) list . get ( automat . adressen . uebergabelichtschrankemehrweg . ordinal ( ) ) ) ; ; tglbtntrte . setselected ( ( boolean ) list . get ( automat . adressen . troete . ordinal ( ) ) ) ; ; tglbtnmehrwegbehlter . setselected ( ( boolean ) list . get ( automat . adressen . fuellstandmehrweg . ordinal ( ) ) ) ; ; tglbtnpetbehlter . setselected ( ( boolean ) list . get ( automat . adressen . fuellstandpet . ordinal ( ) ) ) ; ; switch ( ( integer ) list . get ( automat . adressen . laufbandeingang . ordinal ( ) ) ) { default : chckbxvorderesgesperrt . setselected ( true ) ; case 0 : rdbtnvorderesstop . setselected ( true ) ; break ; case 1 : rdbtnvorderesvorwaerts . setselected ( true ) ; break ; case - 1 : rdbtnvorderesrueckwaerts . setselected ( true ) ; break ; } switch ( ( integer ) list . get ( automat . adressen . laufbanddrehen . ordinal ( ) ) ) { default : chckbxdrehgesperrt . setselected ( true ) ; case 0 : rdbtndrehstop . setselected ( true ) ; break ; case 1 : rdbtndrehrechts . setselected ( true ) ; break ; case - 1 : rdbtndrehlinks . setselected ( true ) ; break ; } switch ( ( integer ) list . get ( automat . adressen . laufbandausgang . ordinal ( ) ) ) { default : chckbxhinteresgesperrt . setselected ( true ) ; case 0 : rdbtnhinteresstop . setselected ( true ) ; break ; case 1 : rdbtnhinteresvorwaerts . setselected ( true ) ; break ; case - 1 : rdbtnhinteresrueckwaerts . setselected ( true ) ; break ; } }
tr	0	public multilist ( ) { recommendedmodel = new defaultlistmodel < champion > ( ) ; goodmodel = new defaultlistmodel < champion > ( ) ; viablemodel = new defaultlistmodel < champion > ( ) ; allmodel = new defaultlistmodel < champion > ( ) ; instance = this ; submit ( ) ; eventhandler . addslotlocklistener ( new slotlocklistener ( ) { @ override public void onslotlock ( ) { submit ( ) ; } } ) ; eventhandler . addresetlistener ( new resetlistener ( ) { @ override public void onreset ( ) { reset ( ) ; submit ( ) ; } } ) ; }
tr	9	public void actionperformed ( actionevent ae ) { if ( ae . getsource ( ) == jregisterpanel . getcancelbutton ( ) ) { setvisible ( false ) ; jloginframe . setvisible ( true ) ; dispose ( ) ; } else if ( ae . getsource ( ) == jregisterpanel . getregisterbutton ( ) ) { string szemail = jregisterpanel . getemailfield ( ) ; string szusername = jregisterpanel . getusernamefield ( ) ; string szpasscode = jregisterpanel . getpasscodefield ( ) ; string szanswer = jregisterpanel . getsecurityanswerfield ( ) ; string szquestion = jregisterpanel . getsecurityquestionfield ( ) ; if ( ! ( szemail . isempty ( ) || szusername . isempty ( ) || szpasscode . isempty ( ) || szanswer . isempty ( ) || szquestion . isempty ( ) ) ) { try { if ( ! ub . register ( szusername , szpasscode , szemail , szquestion , szanswer ) ) joptionpane . showmessagedialog ( null , "account: " + szusername + " already exists." , "duplicate username" , joptionpane . information_message ) ; else { joptionpane . showmessagedialog ( null , "account: " + szusername + " created successfully!" ) ; setvisible ( false ) ; jloginframe . setvisible ( true ) ; dispose ( ) ; } } catch ( ioexception ioe ) { joptionpane . showmessagedialog ( null , ioe . getmessage ( ) ) ; } } else joptionpane . showmessagedialog ( null , "registration fields can not be empty" ) ; } }
tr	6	@ override public boolean equals ( object obj ) { if ( obj == this ) { return true ; } if ( obj == null || obj . getclass ( ) != this . getclass ( ) ) { return false ; } wordposkey mywordposkey = ( wordposkey ) obj ; boolean case1 = ( this . word == null ) ? mywordposkey . getword ( ) == null : this . word . equals ( mywordposkey . getword ( ) ) ; boolean case2 = ( this . pos == null ) ? mywordposkey . getpos ( ) == null : this . pos . equals ( mywordposkey . getpos ( ) ) ; return ( case1 && case2 ) ; }
tr	4	public rectangle2d getdrawablearea ( unit unit ) { double w = paperwidth . getvalue ( unit ) ; double x = 0 ; if ( leftmargin != null ) { x = leftmargin . getvalue ( unit ) ; w -= x ; } if ( rightmargin != null ) { w -= rightmargin . getvalue ( unit ) ; } double h = paperheight . getvalue ( unit ) ; double y = 0 ; if ( topmargin != null ) { y = topmargin . getvalue ( unit ) ; h -= y ; } if ( bottommargin != null ) { h -= bottommargin . getvalue ( unit ) ; } return new rectangle2d . double ( x , y , w , h ) ; }
tr	7	public list < string > getunionlist ( list < string > list1 , list < string > list2 ) { list < string > totallist = new arraylist < > ( ) ; if ( list1 . size ( ) > list2 . size ( ) ) { for ( string obj : list1 ) { totallist . add ( obj ) ; } for ( string obj : list2 ) { if ( ! totallist . contains ( obj ) ) { totallist . add ( obj ) ; } } } else { for ( string obj : list2 ) { totallist . add ( obj ) ; } for ( string obj : list1 ) { if ( ! totallist . contains ( obj ) ) { totallist . add ( obj ) ; } } } return totallist ; }
tr	4	public static chinesecharacter searchcharacter ( integer [ ] intersection , int floatingpart , int straightstroke , int complexstroke ) { intersections = intersection ; floatingparts = floatingpart ; straightstrokes = straightstroke ; complexstrokes = complexstroke ; eventqueue . invokelater ( new runnable ( ) { public void run ( ) { possiblechinesecharacterspanel . clearlist ( ) ; arrays . sort ( intersections ) ; for ( chinesecharacter c : universaldatastorage . database ) { if ( c . getfloatingparts ( ) == floatingparts && arrays . tostring ( c . getintersections ( ) . toarray ( ) ) . equals ( arrays . tostring ( intersections ) ) && ( c . getcomplexstrokes ( ) + c . getstraightstrokes ( ) ) == ( complexstrokes + straightstrokes ) ) { string pinyin = c . getpinyin ( ) ; string character = c . getcharacter ( ) ; string meaning = c . getmeaning ( ) ; chinesecharacter = new chinesecharacter ( pinyin , character , meaning , floatingparts , new arraylist < integer > ( arrays . aslist ( intersections ) ) , straightstrokes , complexstrokes ) ; system . out . println ( chinesecharacter ) ; possiblechinesecharacterspanel . addtolist ( chinesecharacter ) ; logmanager . logthing ( "character found:" + chinesecharacter + " " + timemanager . getcurrenttimeanddate ( ) ) ; } } } } ) ; return chinesecharacter ; }
tr	8	public stringbuilder streamout ( ) { stringbuilder buffer = new stringbuilder ( ) ; for ( int i = 0 ; i < numlines ; i ++ ) { if ( i == 0 || i == numlines - 1 ) { buffer . append ( "2 w\n" ) ; } else if ( i == 1 ) { buffer . append ( "0.5 w\n" ) ; } buffer . append ( horzlines [ i ] . streamout ( ) ) ; buffer . append ( vertlines [ i ] . streamout ( ) ) ; } for ( ordinalpt opt : ordpts ) { buffer . append ( opt . streamout ( ) ) ; } for ( gostone stone : gostones ) { buffer . append ( stone . streamout ( ) ) ; } for ( golabel label : labels ) { buffer . append ( label . streamout ( ) ) ; } for ( triangle triangle : triangles ) { buffer . append ( triangle . streamout ( ) ) ; } return buffer ; }
tr	3	public static void applyshading ( mesh m , view3d view ) { m . ensurevertbuffers ( ) ; m . transformvertices ( m . getmatrix ( ) , null ) ; for ( int i = 0 ; i < m . elements . size ( ) ; i ++ ) { renderable e = m . elem ( i ) ; if ( e . type != renderable_face ) continue ; face f = ( face ) e ; { int a = f . v0 * 3 , b = f . v1 * 3 , c = f . v2 * 3 ; svect . x = m . viewvert [ a + 0 ] - m . viewvert [ c + 0 ] ; svect . y = m . viewvert [ a + 1 ] - m . viewvert [ c + 1 ] ; svect . z = m . viewvert [ a + 2 ] - m . viewvert [ c + 2 ] ; tvect . x = m . viewvert [ b + 0 ] - m . viewvert [ c + 0 ] ; tvect . y = m . viewvert [ b + 1 ] - m . viewvert [ c + 1 ] ; tvect . z = m . viewvert [ b + 2 ] - m . viewvert [ c + 2 ] ; fpoint3 . crossproduct ( svect , tvect , cprod ) ; cprod . normalize ( ) ; double sine = - fpoint3 . dotproduct ( cprod , view . lightdir ( ) ) ; double currlevel = f . getshade ( ) * .75 ; if ( sine > 0 ) { currlevel = ( 1.0 + sine ) * currlevel ; } f . setshade ( ( int ) currlevel ) ; } } }
tr	8	@ override public void run ( ) { isrunning = true ; while ( isrunning ) { if ( mediaplayer != null ) { if ( ! warningpassed && passedtime > time_green ) { warningpassed = true ; mediaplayer . playmedia ( maincontroller . sound_path + "dong03.wav" ) ; } if ( ! finishpassed && passedtime > time_yellow ) { finishpassed = true ; mediaplayer . playmedia ( maincontroller . sound_path + "end.wav" ) ; } } try { swingutilities . invokeandwait ( new runnable ( ) { @ override public void run ( ) { repaint ( ) ; } } ) ; } catch ( interruptedexception e ) { } catch ( invocationtargetexception e ) { } thread . yield ( ) ; } }
tr	3	private jpanel getcenterpanel ( ) { if ( centerpanel == null ) { centerpanel = new jpanel ( ) ; centerpanel . setlayout ( new miglayout ( "gap 0px 0px" , "[][][]" , "[][][][][][]" ) ) ; for ( int i = 0 ; i < 10 ; i ++ ) { for ( int j = 0 ; j < 10 ; j ++ ) { buttongameboard [ i ] [ j ] . setsize ( 40 , 40 ) ; centerpanel . add ( buttongameboard [ i ] [ j ] , "cell " + j + " " + i + "" ) ; } } } return centerpanel ; }
tr	6	public void clickactionlistener ( final jbutton btn ) { btn . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent arg0 ) { for ( int i = 0 ; i < suggestedbuttonsnames . length ; i ++ ) if ( existingboats . contains ( suggestedbuttonsnames [ i ] ) ) { system . out . println ( "ne mozes postaviti brod na to polje!" ) ; return ; } int sifrabroda = workingframe . updatelabels ( ) ; if ( ( sifrabroda ) != - 1 ) { for ( int i = 0 ; i < 10 ; i ++ ) for ( int j = 0 ; j < 10 ; j ++ ) { if ( mybuttongameboard [ i ] [ j ] . isborderpainted ( ) ) { existingboats . add ( mybuttongameboard [ i ] [ j ] . getname ( ) ) ; mybuttongameboard [ i ] [ j ] . seticon ( shipimage ) ; gameboardmask . fillstartmatrix ( i , j , sifrabroda ) ; } } } gameboardmask . ispisi ( ) ; logicmatrix = gameboardmask . gameboard ; } } ) ; }
tr	1	public static void main ( string [ ] args ) throws ioexception , interruptedexception { webcam webcam = webcam . getdefault ( ) ; webcam . setviewsize ( new dimension ( 640 , 480 ) ) ; webcam . open ( ) ; jframe troll = new jframe ( ) ; jlabel boy = new jlabel ( ) ; troll . add ( boy ) ; boy . setpreferredsize ( new dimension ( 640 , 480 ) ) ; troll . pack ( ) ; troll . setresizable ( false ) ; troll . setdefaultcloseoperation ( jframe . exit_on_close ) ; troll . setvisible ( true ) ; while ( true ) { boy . seticon ( new imageicon ( webcam . getimage ( ) ) ) ; } }
tr	1	public jcombobox getcmbresolutionoptions ( ) { if ( cmbresolutionoptions == null ) { cmbresolutionoptions = new jcombobox ( ) ; cmbresolutionoptions . setmodel ( new defaultcomboboxmodel ( new string [ ] { messages . getstring ( "geologmain.options.qrz" ) , messages . getstring ( "geologmain.options.hamqth" ) , messages . getstring ( "geologmain.options.field" ) , messages . getstring ( "geologmain.options.cache" ) } ) ) ; cmbresolutionoptions . setbounds ( new rectangle ( 170 , 206 , 218 , 27 ) ) ; cmbresolutionoptions . setfont ( new font ( "tahoma" , font . plain , 12 ) ) ; } return cmbresolutionoptions ; }
tr	1	public boolean noun2modifier ( dataholder dataholderhandler , string word ) { boolean isupdated = false ; arraylist < string > deletedposs = new arraylist < string > ( ) ; deletedposs . add ( "s" ) ; deletedposs . add ( "p" ) ; deletedposs . add ( "n" ) ; for ( string pos : deletedposs ) { dataholderhandler . deletewordpos ( true , word , true , pos ) ; } dataholderhandler . updatedataholder ( word , "m" , "" , "modifiers" , 1 ) ; string oldpattern = string . format ( "(^%s$|^.* %s$)" , word , word ) ; dataholderhandler . updatesentencetag ( oldpattern , null ) ; return isupdated ; }
tr	2	annotatedoption ( class clazz , field field , param param ) { this . clazz = clazz ; this . field = field ; this . param = param ; if ( param . option ( ) . isempty ( ) ) { opt = field . getname ( ) . substring ( 0 , 1 ) . tolowercase ( ) ; } else { opt = param . option ( ) ; } if ( param . name ( ) . isempty ( ) ) { name = field . getname ( ) . tolowercase ( ) ; } else { name = param . name ( ) ; } }
tr	1	public void init ( ) { chat = new xchatpa ( view . achatinput , view . achatbut , view . achattextarea , this ) ; myside = ! xnet . isserver ( ) ; fig . clear ( ) ; figdw . clear ( ) ; figdb . clear ( ) ; addfig ( 5 , 1 , 4 , myside , 1 ) ; addfig ( 4 , 1 , 5 , ! myside , 1 ) ; addfig ( 0 , 2 , 3 , ! myside , 1 ) ; for ( int i = 0 ; i < 10 ; i ++ ) arrays . fill ( map [ i ] , - 2 ) ; initfigures ( ) ; imgdb . loadall ( ) ; }
tr	9	public int bitrate ( int i ) { if ( i >= links ) return ( - 1 ) ; if ( ! seekable && i != 0 ) return ( bitrate ( 0 ) ) ; if ( i < 0 ) { long bits = 0 ; for ( int j = 0 ; j < links ; j ++ ) { bits += ( offsets [ j + 1 ] - dataoffsets [ j ] ) * 8 ; } return ( ( int ) math . rint ( bits / time_total ( - 1 ) ) ) ; } else { if ( seekable ) { return ( ( int ) math . rint ( ( offsets [ i + 1 ] - dataoffsets [ i ] ) * 8 / time_total ( i ) ) ) ; } else { if ( vi [ i ] . bitrate_nominal > 0 ) { return vi [ i ] . bitrate_nominal ; } else { if ( vi [ i ] . bitrate_upper > 0 ) { if ( vi [ i ] . bitrate_lower > 0 ) { return ( vi [ i ] . bitrate_upper + vi [ i ] . bitrate_lower ) / 2 ; } else { return vi [ i ] . bitrate_upper ; } } return ( - 1 ) ; } } } }
tr	7	public string dtdetailsearch ( string id ) { string docname = "" ; string doctellcontent = "" ; string excutedate = "" ; string stopdate = "" ; string doctellstatus = "" ; string doctelltype = "" ; string sd = "" ; string pn = "" ; string str = "select u.user_name dt.doc_tell_content dt.excute_date dt.stop_date dt.doc_tell_type dt.doc_tell_status from doc_tell dt user u where dt.id='" + id + "' and dt.doc_id=u.user_id;" ; system . out . println ( "doctelldetailsearch_______________________" + str ) ; try { conn = dbconn . getconn ( ) ; pstmt = conn . preparestatement ( str ) ; resultset num = pstmt . executequery ( ) ; while ( num . next ( ) ) { excutedate = num . getstring ( "excute_date" ) ; stopdate = num . getstring ( "stop_date" ) ; docname = num . getstring ( "user_name" ) ; doctellstatus = num . getstring ( "doc_tell_status" ) ; doctelltype = num . getstring ( "doc_tell_type" ) ; doctellcontent = num . getstring ( "doc_tell_content" ) ; sb . append ( " <tr><input type=\"text\" value=\"<%=session.getattribute('userid') %>\" style=\"display:none\" id=\"excuteid\"/><input type=\"text\" value=\"" + id + "\" id=\"id\" style=\"display:none\"/> <td>\u4e3b\u6cbb\u533b\u751f:" + docname + "</td>  <td>\u4f5c\u7528\u65f6\u95f4:" + excutedate + "~" + stopdate + "</td> </tr>" ) ; sb . append ( "<tr> <td colspan=\"2\">\u533b\u5631\u5185\u5bb9\uff1a <textarea readonly rows=\"6\" cols=\"80\" name=\"doctellcontent\" id=\"doctellcontent\" onpropertychange=\"if(this.scrollheight>80) this.style.posheight=this.scrollheight+5\">" + doctellcontent + "</textarea></td> </tr><td colspan=\"2\">" ) ; if ( doctelltype . equals ( "1" ) ) { switch ( integer . parseint ( doctellstatus ) ) { case 1 : sb . append ( "<input type=button  id=\"nursecheck\" onclick=\"save(2)\" value=\"\u62a4\u58eb\u6821\u5bf9\" class=\"btn blue\"/>" ) ; break ; case 2 : sb . append ( "<input type=button id=\"docstop\"  onclick=\"save(3)\" value=\"\u505c\u6b62\u533b\u5631\"  class=\"btn blue\"/>" ) ; break ; case 3 : sb . append ( "<input type=button  id=\"nurseconfirm\" onclick=\"save(4)\"  value=\"\u62a4\u58eb\u786e\u8ba4\"   class=\"btn blue\"/>" ) ; break ; } } else if ( doctelltype . equals ( "2" ) ) { sb . append ( "<input type=button  id=\"nurseconfirm\"  value=\"\u62a4\u58eb\u786e\u8ba4\" onclick=\"save(4)\"  class=\"btn blue\"/>" ) ; } sb . append ( "</td>  </tr>" ) ; } pstmt . close ( ) ; dbconn . close ( conn ) ; } catch ( sqlexception e ) { e . printstacktrace ( ) ; } return sb . tostring ( ) ; }
tr	9	public questionpanel getquestionpanel ( ) { if ( mediapanel . hasfinished ( ) ) createmedia ( ) ; if ( type . equals ( "plain" ) ) { hashmap < string , string > text = new hashmap < string , string > ( ) ; text . put ( "frage" , title ) ; questionpanel = new questionpanel ( text , mediapanel , fontsize ) ; } else if ( type . equals ( "mchoice" ) ) { string [ ] split = answers . split ( ";" ) ; multiplechoicepanel panel = new multiplechoicepanel ( split , mcfont ) ; hashmap < string , string > text = new hashmap < string , string > ( ) ; text . put ( "frage" , title ) ; questionpanel = new questionpanel ( text , mediapanel , panel , fontsize ) ; } else if ( type . equals ( "mchoice-img" ) || type . equals ( "mchoice_img" ) ) { string [ ] split = answers . split ( ";" ) ; jlabel [ ] labels = new jlabel [ 4 ] ; bufferedimage bufferedimage ; image image ; for ( int i = 0 ; i < labels . length ; i ++ ) { prefheight = math . max ( pref_height , mcfont ) ; try { bufferedimage = imageio . read ( new file ( split [ i ] ) ) ; if ( bufferedimage . getheight ( ) > prefheight ) { image = bufferedimage . getscaledinstance ( bufferedimage . getwidth ( ) * prefheight / bufferedimage . getheight ( ) , prefheight , bufferedimage . scale_smooth ) ; } else { image = bufferedimage ; } } catch ( ioexception e ) { bufferedimage = null ; image = null ; e . printstacktrace ( ) ; system . out . println ( "image path: " + split [ i ] ) ; } labels [ i ] = new jlabel ( new imageicon ( image ) ) ; } multiplechoicepanel panel = new multiplechoicepanel ( labels , mcfont ) ; hashmap < string , string > text = new hashmap < string , string > ( ) ; text . put ( "frage" , title ) ; questionpanel = new questionpanel ( text , mediapanel , panel , fontsize ) ; } else if ( type . equals ( "list" ) ) { hashmap < string , string > text = new hashmap < string , string > ( ) ; text . put ( "frage" , title ) ; string [ ] answerarray = answers . split ( ";" ) ; system . out . println ( "create question list" ) ; questionpanel = new questionpanel ( text , answerarray , fontsize ) ; } else { system . out . println ( "failed to read file" ) ; system . exit ( 0 ) ; } return questionpanel ; }
tr	0	public static < t , r > r callmemoized ( final bifunction < function < t , r > , t , r > function , final t input ) { function < t , r > memoized = new function < t , r > ( ) { { system . out . println ( "new function called" ) ; } private final map < t , r > store = new hashmap < > ( ) ; public r apply ( final t input ) { return store . computeifabsent ( input , key -> function . apply ( this , key ) ) ; } } ; return memoized . apply ( input ) ; }
tr	4	public list < integer > getrow ( int rowindex ) { list < integer > result = new arraylist < integer > ( ) ; list < integer > temp = new arraylist < integer > ( ) ; for ( int i = 0 ; i <= rowindex ; i ++ ) { temp = new arraylist < integer > ( result ) ; result . clear ( ) ; for ( int j = 0 ; j <= i ; j ++ ) { if ( j == 0 || j == i ) result . add ( 1 ) ; else { result . add ( temp . get ( j - 1 ) + temp . get ( j ) ) ; } } } return result ; }
tr	2	public ratelimitstatus ( response res ) throws weiboexception { super ( res ) ; jsonobject json = res . asjsonobject ( ) ; try { jsonarray list = json . getjsonarray ( "api_rate_limits" ) ; int size = list . length ( ) ; apiratelimit = new arraylist < apiratelimits > ( size ) ; for ( int i = 0 ; i < size ; i ++ ) { apiratelimit . add ( new apiratelimits ( list . getjsonobject ( i ) ) ) ; } iplimit = json . getint ( "ip_limit" ) ; remainingiphits = json . getint ( "remaining_ip_hits" ) ; remaininguserhits = json . getlong ( "remaining_user_hits" ) ; resettime = json . getstring ( "reset_time" ) ; resettimeinseconds = json . getint ( "reset_time_in_seconds" ) ; userlimit = json . getlong ( "user_limit" ) ; } catch ( jsonexception jsone ) { throw new weiboexception ( jsone . getmessage ( ) + ":" + json . tostring ( ) , jsone ) ; } }
tr	3	public void setbean ( object bean ) throws exception { reflectinfo info = metainfomap . getreflectlinfo ( bean . getclass ( ) ) ; int size = query . sizeofparameters ( ) ; int i = 0 ; int fieldindex ; while ( i < size ) { string param = query . getparameter ( i ) ; fieldindex = info . getindexoffield ( param ) ; if ( fieldindex == - 1 ) throw new exception ( "in the bean  can't find " + param ) ; object value = info . getfieldvalue ( fieldindex , bean ) ; int fieldtype = info . getfieldtype ( fieldindex ) ; try { parametermapper . setparametervalue ( ps , ++ i , value , fieldtype ) ; } catch ( exception e ) { throw new paramersettingexception ( i , param , value , fieldtype , e ) ; } } }
tr	0	@ override public void onsimulationdone ( simulationevent event ) { simulationfinalresult result = ( simulationfinalresult ) event . geteventdata ( ) ; double w0 = result . getwinpercentage ( 0 ) ; double l0 = result . getlosepercentage ( 0 ) ; double t0 = result . gettiepercentage ( 0 ) ; double w1 = result . getwinpercentage ( 1 ) ; double l1 = result . getlosepercentage ( 1 ) ; double t1 = result . gettiepercentage ( 1 ) ; double w2 = result . getwinpercentage ( 2 ) ; double l2 = result . getlosepercentage ( 2 ) ; double t2 = result . gettiepercentage ( 2 ) ; system . out . println ( "win 1: " + w0 ) ; system . out . println ( "lose 1: " + l0 ) ; system . out . println ( "tie 1: " + t0 ) ; system . out . println ( "win 2: " + w1 ) ; system . out . println ( "lose 2: " + l1 ) ; system . out . println ( "tie 2: " + t1 ) ; system . out . println ( "win 3: " + w2 ) ; system . out . println ( "lose 3: " + l2 ) ; system . out . println ( "tie 3: " + t2 ) ; long duration = result . getduration ( ) ; system . out . println ( "duration: " + duration + " ms" ) ; }
tr	5	public static void print ( jtextcomponent textcomponent ) throws textcomponentutilexception { inputstream is = null ; try { printservice [ ] printservices = printservicelookup . lookupprintservices ( docflavor . input_stream . autosense , null ) ; if ( printservices . length > 0 ) { printrequestattributeset printrequestattributeset = new hashprintrequestattributeset ( ) ; printrequestattributeset . add ( new jobname ( "jaligner" , null ) ) ; printservice service = serviceui . printdialog ( null , 50 , 50 , printservices , printservicelookup . lookupdefaultprintservice ( ) , docflavor . input_stream . autosense , printrequestattributeset ) ; if ( service != null ) { docprintjob printjob = service . createprintjob ( ) ; printjobmointor printjobmointor = new printjobmointor ( printjob ) ; is = new bytearrayinputstream ( textcomponent . gettext ( ) . getbytes ( ) ) ; documentname documentname = new documentname ( "jaligner" , null ) ; hashdocattributeset docattributeset = new hashdocattributeset ( ) ; docattributeset . add ( documentname ) ; doc doc = new simpledoc ( is , docflavor . input_stream . autosense , docattributeset ) ; printjob . print ( doc , printrequestattributeset ) ; printjobmointor . waitforprintjob ( ) ; } } else { throw new textcomponentutilexception ( "no print service found!" ) ; } } catch ( exception e ) { throw new textcomponentutilexception ( e . getmessage ( ) ) ; } finally { if ( is != null ) { try { is . close ( ) ; } catch ( ioexception e ) { logger . log ( level . warning , "failed closing input stream: " + e . getmessage ( ) , e ) ; } } } }
tr	0	public static void createkeysettings ( ) { keysettings s1 = new keysettings ( ) ; s1 . bomb = game . keys . getkey ( keyevent . vk_l ) ; s1 . left = game . keys . getkey ( keyevent . vk_left ) ; s1 . right = game . keys . getkey ( keyevent . vk_right ) ; s1 . up = game . keys . getkey ( keyevent . vk_up ) ; s1 . down = game . keys . getkey ( keyevent . vk_down ) ; s1 . item = game . keys . getkey ( keyevent . vk_k ) ; game . key_settings . add ( s1 ) ; keysettings s2 = new keysettings ( ) ; s2 . bomb = game . keys . getkey ( keyevent . vk_t ) ; s2 . left = game . keys . getkey ( keyevent . vk_a ) ; s2 . right = game . keys . getkey ( keyevent . vk_d ) ; s2 . up = game . keys . getkey ( keyevent . vk_w ) ; s2 . down = game . keys . getkey ( keyevent . vk_s ) ; s2 . item = game . keys . getkey ( keyevent . vk_r ) ; game . key_settings . add ( s2 ) ; }
tr	7	public char leerdato ( ) { char dato ; if ( isesta_en_ram ( ) ) { if ( pos < data . length ( ) ) { dato = data . charat ( pos ) ; } else { throw new indexoutofboundsexception ( ) ; } } else { if ( "" . equals ( prox ) && lector . hasnext ( ) ) { prox = lector . next ( ) ; } else if ( "" . equals ( prox ) ) { throw new indexoutofboundsexception ( ) ; } else if ( pos >= prox . length ( ) ) { pos = 0 ; if ( lector . hasnext ( ) ) { prox = lector . next ( ) ; } else { throw new indexoutofboundsexception ( ) ; } } dato = prox . charat ( pos ) ; } pos ++ ; return dato ; }
tr	1	public dimension resizeimage ( int height , int width ) { int heighttemp = height ; int widthtemp = width ; double thumbratio = ( double ) widthtemp / ( double ) heighttemp ; double imageratio = ( double ) originalwidth / ( double ) originalheight ; if ( thumbratio < imageratio ) { heighttemp = ( int ) ( widthtemp / imageratio ) ; } else { widthtemp = ( int ) ( heighttemp * imageratio ) ; } bufferedimage thumbimage = new bufferedimage ( widthtemp , heighttemp , bufferedimage . type_int_rgb ) ; graphics2d graphics2d = thumbimage . creategraphics ( ) ; graphics2d . setrenderinghint ( renderinghints . key_interpolation , renderinghints . value_interpolation_bilinear ) ; graphics2d . drawimage ( imgoriginal , 0 , 0 , widthtemp , heighttemp , null ) ; imgresized = toolkit . getdefaulttoolkit ( ) . createimage ( thumbimage . getsource ( ) ) ; graphics2d . dispose ( ) ; invalidate ( ) ; repaint ( ) ; dimension d = new dimension ( ) ; d . width = widthtemp ; d . height = heighttemp ; return d ; }
tr	9	protected static string calculatemd5forsong ( final song asong , final findduplicateoption aoption , final hashcalculator acalculator ) throws exception { acalculator . resetinit ( ) ; if ( aoption . isalbum ( ) ) { acalculator . updatehash ( string . valueof ( asong . getalbum ( ) ) ) ; } if ( aoption . isalbumartist ( ) ) { acalculator . updatehash ( string . valueof ( asong . getalbumartist ( ) ) ) ; } if ( aoption . isartist ( ) ) { acalculator . updatehash ( string . valueof ( asong . getartist ( ) ) ) ; } if ( aoption . iscomposer ( ) ) { acalculator . updatehash ( string . valueof ( asong . getcomposer ( ) ) ) ; } if ( aoption . isgenre ( ) ) { acalculator . updatehash ( string . valueof ( asong . getgenre ( ) ) ) ; } if ( aoption . isname ( ) ) { acalculator . updatehash ( string . valueof ( asong . getname ( ) ) ) ; } if ( aoption . istitle ( ) ) { acalculator . updatehash ( string . valueof ( asong . gettitle ( ) ) ) ; } if ( aoption . isyear ( ) ) { acalculator . updatehash ( string . valueof ( asong . getyear ( ) ) ) ; } if ( aoption . islength ( ) ) { acalculator . updatehash ( string . valueof ( asong . getdurationmillis ( ) ) ) ; } return acalculator . finalizehash ( ) ; }
tr	6	private void comparepackageparts ( tipp p1 , tipp p2 ) throws exception { collection < tippsection > s1 = p1 . getsections ( ) ; collection < tippsection > s2 = p2 . getsections ( ) ; assertnotnull ( s1 ) ; assertnotnull ( s2 ) ; for ( tippsection s : s1 ) { tippsectiontype type = s . gettype ( ) ; list < ? extends tippfile > o1 = s . getfileresources ( ) ; tippsection _s = p2 . getsection ( type ) ; assertequals ( s , _s ) ; list < ? extends tippfile > o2 = _s . getfileresources ( ) ; assertnotnull ( o1 ) ; assertnotnull ( o2 ) ; assertequals ( o1 , o2 ) ; iterator < ? extends tippfile > fit1 = o1 . iterator ( ) ; iterator < ? extends tippfile > fit2 = o2 . iterator ( ) ; while ( fit1 . hasnext ( ) ) { tippfile f1 = fit1 . next ( ) ; asserttrue ( fit2 . hasnext ( ) ) ; tippfile f2 = fit2 . next ( ) ; assertequals ( f1 , f2 ) ; try ( inputstream is1 = p1 . getfile ( f1 ) ; inputstream is2 = p2 . getfile ( f2 ) ) { verifybytes ( is1 , is2 ) ; } } } }
tr	2	public map < string , map < string , object >> loadasmap ( string key ) throws ioexception { map < string , map < string , object >> map = new hashmap < string , map < string , object >> ( ) ; lineiterator iterator = new lineiterator ( new filereader ( file ) ) ; while ( iterator . hasnext ( ) ) { map < string , object > json = jsonoutput . mapper . readvalue ( iterator . nextline ( ) , map . class ) ; if ( json . containskey ( key ) ) { map . put ( json . get ( key ) . tostring ( ) , json ) ; } } return map ; }
tr	3	public void initpanel ( ) { this . removeall ( ) ; texte_options . setforeground ( color . black ) ; texte_options . setfont ( new font ( "droid serif" , font . italic | font . bold , 40 ) ) ; texte_options . setbounds ( 360 , 20 , 500 , 50 ) ; texte . setfont ( new font ( "droid serif" , font . italic | font . bold , 15 ) ) ; texte2 . setfont ( new font ( "droid serif" , font . italic | font . bold , 15 ) ) ; texte3 . setfont ( new font ( "droid serif" , font . italic | font . bold , 15 ) ) ; spinner . setmodel ( new spinnernumbermodel ( fenetre . getmodele ( ) . getoptions ( ) . gettaillegrille ( ) , 10 , 20 , 1 ) ) ; switch ( fenetre . getmodele ( ) . getoptions ( ) . getniveauia ( ) ) { case facile : rb_facile . setselected ( true ) ; break ; case moyen : rb_moyen . setselected ( true ) ; break ; case difficile : rb_difficile . setselected ( true ) ; break ; } pan . setlayout ( new gridlayout ( 6 , 1 ) ) ; pan . setbounds ( 50 , 110 , 400 , 410 ) ; pan2 . setlayout ( null ) ; pan2 . setbounds ( 480 , 110 , 360 , 150 ) ; pan3 . setlayout ( null ) ; pan3 . setbounds ( 480 , 300 , 360 , 220 ) ; texte2 . setbounds ( 10 , 10 , 400 , 20 ) ; spinner . setbounds ( 150 , 50 , 60 , 40 ) ; texte3 . setbounds ( 10 , 10 , 300 , 20 ) ; rb_facile . setbounds ( 20 , 50 , 100 , 20 ) ; rb_facile . setbackground ( null ) ; rb_moyen . setbounds ( 20 , 100 , 100 , 20 ) ; rb_moyen . setbackground ( null ) ; rb_difficile . setbounds ( 20 , 150 , 100 , 20 ) ; rb_difficile . setbackground ( null ) ; b_retour . setbounds ( 10 , 550 , 100 , 50 ) ; b_jouer . setbounds ( 780 , 550 , 100 , 50 ) ; bg . add ( rb_facile ) ; bg . add ( rb_moyen ) ; bg . add ( rb_difficile ) ; check1 . setfocusable ( false ) ; check2 . setfocusable ( false ) ; check3 . setfocusable ( false ) ; check4 . setfocusable ( false ) ; check5 . setfocusable ( false ) ; getcoches ( ) ; check1 . setstate ( coches [ 0 ] ) ; check2 . setstate ( coches [ 1 ] ) ; check3 . setstate ( coches [ 2 ] ) ; check4 . setstate ( coches [ 3 ] ) ; check5 . setstate ( coches [ 4 ] ) ; pan . add ( texte ) ; pan . add ( check1 ) ; pan . add ( check2 ) ; pan . add ( check3 ) ; pan . add ( check4 ) ; pan . add ( check5 ) ; pan2 . add ( texte2 ) ; pan2 . add ( spinner ) ; pan3 . add ( texte3 ) ; pan3 . add ( rb_facile ) ; pan3 . add ( rb_moyen ) ; pan3 . add ( rb_difficile ) ; this . add ( texte_options ) ; this . add ( pan ) ; this . add ( pan2 ) ; this . add ( pan3 ) ; this . add ( b_jouer ) ; this . add ( b_retour ) ; }
tr	8	public static map < string , string > returnshipadviceheader ( string identifier ) { map < string , string > headervalues = new hashmap < string , string > ( ) ; if ( conn == null ) { getconnection ( ) ; } try { string sql = "select customerid from tblsalesheader where **column** = " + identifier ; string asnsql = "select shipfirstname  shiplastname  shipadd1  shipcity  shipstate  shippostalcode  shipcountry  shipvia  shiprequestdate" + " from tblasnsalesheader where customerid = " + identifier ; string customerasnsql = "select customerorderdate  customerordertype  shiprequestwarehouse  ordercompleted from tblasnsalesheader " + "where customerid = " + identifier ; statement customerstatement = conn . createstatement ( ) ; statement shipstatement = conn . createstatement ( ) ; statement customershipstatement = conn . createstatement ( ) ; resultset customerid = customerstatement . executequery ( sql ) ; resultset shipinfo = shipstatement . executequery ( asnsql ) ; resultset customershipdetails = customershipstatement . executequery ( customerasnsql ) ; if ( customerid != null ) { while ( customerid . next ( ) ) { headervalues . put ( "customer-id" , customerid . getstring ( 1 ) ) ; } } if ( shipinfo != null ) { while ( shipinfo . next ( ) ) { headervalues . put ( "ship-first-name" , shipinfo . getstring ( 1 ) ) ; headervalues . put ( "ship-last-name" , shipinfo . getstring ( 2 ) ) ; headervalues . put ( "ship-addr1" , shipinfo . getstring ( 3 ) ) ; headervalues . put ( "ship-city" , shipinfo . getstring ( 4 ) ) ; headervalues . put ( "ship-state" , shipinfo . getstring ( 5 ) ) ; headervalues . put ( "ship-postal-code" , shipinfo . getstring ( 6 ) ) ; headervalues . put ( "ship-country" , shipinfo . getstring ( 7 ) ) ; headervalues . put ( "ship-via" , shipinfo . getstring ( 8 ) ) ; headervalues . put ( "ship-request-date" , shipinfo . getstring ( 9 ) ) ; } } if ( customershipdetails != null ) { while ( customershipdetails . next ( ) ) { headervalues . put ( "customer-order-date" , customershipdetails . getstring ( 1 ) ) ; headervalues . put ( "customer-order-type" , customershipdetails . getstring ( 2 ) ) ; headervalues . put ( "ship-request-warehouse" , customershipdetails . getstring ( 3 ) ) ; headervalues . put ( "order-completed" , customershipdetails . getstring ( 4 ) ) ; } } } catch ( sqlexception sqle ) { sqle . printstacktrace ( ) ; } return headervalues ; }
tr	8	@ override protected void handleinboxitem ( inboxitem inboxitem ) { super . handleinboxitem ( inboxitem ) ; if ( inboxitem . getmessage ( ) instanceof tokenmessage ) { executeturn ( ) ; } if ( inboxitem . getmessage ( ) instanceof leaderelectionmessage ) { leaderelectionmessage message = ( leaderelectionmessage ) inboxitem . getmessage ( ) ; switch ( message . getleaderelectionmessagetype ( ) ) { case ask_for_roll : { doroll ( inboxitem . getsender ( ) ) ; break ; } case leader_elected : { initround ( ) ; ownplayer . setactive ( true ) ; if ( message . getvalue ( ) == ownendpoint . getid ( ) ) { isdealer = true ; logger . info ( "new dealer" ) ; sendtoken ( getpreviousplayer ( ) ) ; } else { logger . info ( "player " + message . getvalue ( ) + " is new dealer." ) ; } break ; } case rolled : { gatherroll ( inboxitem . getsender ( ) , message ) ; break ; } } } if ( inboxitem . getmessage ( ) instanceof statusmessage ) { handlestatusmessage ( ( statusmessage ) inboxitem . getmessage ( ) ) ; } if ( inboxitem . getmessage ( ) instanceof dealermessage ) { handledealermessage ( inboxitem . getsender ( ) , ( dealermessage ) inboxitem . getmessage ( ) ) ; } }
tr	1	private arglistcodefragment convertparamlist ( arglistcodefragment paramlist , function f , codeposition p ) { arglistcodefragment code = new arglistcodefragment ( ) ; code . appendcodefragment ( paramlist ) ; for ( int i = 0 ; i < paramlist . getargs ( ) . size ( ) ; i ++ ) { variable v = paramlist . getargs ( ) . get ( i ) ; type t = f . getparams ( ) . get ( i ) . gettype ( ) ; code . appendcodefragment ( variabletypeconvert ( v , t , p ) ) ; code . addarg ( new variable ( code . getinfo ( ) , code . getregister ( ) , code . gettype ( ) ) ) ; } return code ; }
tr	4	@ override public ibstree < t > delete ( t value ) { bstree < t > parent = null ; bstree < t > curr = this ; for ( int cmp = value . compareto ( curr . data ) ; cmp != 0 ; cmp = value . compareto ( curr . data ) ) { if ( cmp < 0 ) { if ( curr . left == null ) { return null ; } parent = curr ; curr = curr . gettypedleft ( ) ; } else { if ( curr . right == null ) { return null ; } parent = curr ; curr = curr . gettypedright ( ) ; } } return curr . delete ( parent ) ; }
tr	3	@ test public void superthreadsafe ( ) { final simplemath math = new simplemath ( ) ; final map < integer , integer > results = new concurrenthashmap < integer , integer > ( ) ; final countdownlatch latch = new countdownlatch ( 1000 ) ; final countdownlatch alldone = new countdownlatch ( 1000 ) ; for ( int i = 0 ; i < 1000 ; i ++ ) { final int copy = i ; new thread ( ) { public void run ( ) { try { latch . countdown ( ) ; latch . await ( ) ; int result = math . doubleandincrement ( copy ) ; results . put ( copy , result ) ; alldone . countdown ( ) ; } catch ( exception e ) { } } } . start ( ) ; } try { alldone . await ( ) ; } catch ( exception e ) { } assertequals ( new integer ( 45 ) , results . get ( 22 ) ) ; }
tr	4	private int findplaceholderendindex ( charsequence buf , int startindex ) { int index = startindex + this . placeholderprefix . length ( ) ; int withinnestedplaceholder = 0 ; while ( index < buf . length ( ) ) { if ( stringutils . substringmatch ( buf , index , this . placeholdersuffix ) ) { if ( withinnestedplaceholder > 0 ) { withinnestedplaceholder -- ; index = index + this . placeholdersuffix . length ( ) ; } else { return index ; } } else if ( stringutils . substringmatch ( buf , index , this . simpleprefix ) ) { withinnestedplaceholder ++ ; index = index + this . simpleprefix . length ( ) ; } else { index ++ ; } } return - 1 ; }
tr	5	public request < describeinstancetypesrequest > marshall ( describeinstancetypesrequest describeinstancetypesrequest ) { if ( describeinstancetypesrequest == null ) { throw new amazonclientexception ( "invalid argument passed to marshall(...)" ) ; } request < describeinstancetypesrequest > request = new defaultrequest < > ( describeinstancetypesrequest , "amazonec2" ) ; request . addparameter ( "action" , "describeinstancetypes" ) ; request . addparameter ( "version" , "2013-10-15" ) ; list < string > instancetypeslist = describeinstancetypesrequest . getinstancetypes ( ) ; int instancetypeslistindex = 1 ; for ( string instancetypeslistvalue : instancetypeslist ) { if ( instancetypeslistvalue != null ) { request . addparameter ( "instancetype." + instancetypeslistindex , stringutils . fromstring ( instancetypeslistvalue ) ) ; } instancetypeslistindex ++ ; } if ( describeinstancetypesrequest . getavailability ( ) != null ) { request . addparameter ( "availability" , stringutils . fromboolean ( describeinstancetypesrequest . getavailability ( ) ) ) ; } if ( describeinstancetypesrequest . getverbose ( ) != null ) { request . addparameter ( "verbose" , stringutils . fromboolean ( describeinstancetypesrequest . getverbose ( ) ) ) ; } return request ; }
tr	5	public void updatelocation ( int id , list < object > list ) { if ( ! handler_location . initialize ( ) ) { system . out . println ( "locationserver : failed to initialize location handler!" ) ; return ; } int result = 0 , min_rssi = 1000 ; for ( int i = 0 ; i < list . size ( ) ; i += 2 ) { string mac = ( string ) list . get ( i ) ; locationnode node = handler_location . getlocationnode ( mac ) ; if ( node != null ) { int rssi = ( int ) list . get ( i + 1 ) - node . rssi ; if ( rssi < min_rssi ) { min_rssi = rssi ; result = node . area ; } } } if ( result != 0 ) { handler_location . updatelocation ( id , result ) ; } handler_location . close ( ) ; }
tr	6	@ override public boolean equals ( object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( obj instanceof describecomponentsresult == false ) return false ; describecomponentsresult other = ( describecomponentsresult ) obj ; if ( other . getcomponentinfos ( ) == null ^ this . getcomponentinfos ( ) == null ) return false ; if ( other . getcomponentinfos ( ) != null && other . getcomponentinfos ( ) . equals ( this . getcomponentinfos ( ) ) == false ) return false ; return true ; }
tr	4	public static keyaction [ ] compile ( string s ) { final list < keyaction > actions = new arraylist < keyaction > ( ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { final char c = s . charat ( i ) ; if ( c == k && s . substring ( i ) . startswith ( "keyevent.vk_" ) ) try { final int k = s . indexof ( . , i + "keyevent.vk_" . length ( ) ) ; final string vk = s . substring ( i + "keyevent." . length ( ) , k ) ; final int code = keyevent . class . getfield ( vk ) . getint ( null ) ; i = k + 1 ; actions . add ( new keyaction ( code , type . valueof ( s . charat ( i ) ) ) ) ; } catch ( exception e ) { throw new runtimeexception ( "compilation error: s=" + s + "  i=" + i + "  c=" + c , e ) ; } else compile ( c , actions ) ; } return actions . toarray ( new keyaction [ actions . size ( ) ] ) ; }
tr	8	protected long skipbytes ( long bytes ) throws basicplayerexception { long totalskipped = 0 ; if ( m_datasource instanceof file ) { int previousstatus = m_status ; m_status = seeking ; long skipped = 0 ; try { synchronized ( m_audioinputstream ) { notifyevent ( basicplayerevent . seeking , getencodedstreamposition ( ) , - 1 , null ) ; initaudioinputstream ( ) ; if ( m_audioinputstream != null ) { while ( totalskipped < ( bytes - skip_inaccuracy_size ) ) { skipped = m_audioinputstream . skip ( bytes - totalskipped ) ; if ( skipped == 0 ) break ; totalskipped = totalskipped + skipped ; if ( totalskipped == - 1 ) throw new basicplayerexception ( basicplayerexception . skipnotsupported ) ; } } } notifyevent ( basicplayerevent . seeked , getencodedstreamposition ( ) , - 1 , null ) ; m_status = opened ; if ( previousstatus == playing ) startplayback ( ) ; else if ( previousstatus == paused ) { startplayback ( ) ; pauseplayback ( ) ; } } catch ( ioexception e ) { throw new basicplayerexception ( e ) ; } } return totalskipped ; }
tr	7	public static arraylist < string > from ( file f , boolean readblanks ) { arraylist < string > strings = new arraylist < string > ( ) ; if ( ! f . exists ( ) ) { system . err . println ( "file " + f . getpath ( ) + " not found!" ) ; return strings ; } while ( true ) { try { bufferedreader reader = new bufferedreader ( new filereader ( f ) ) ; string line ; while ( ( line = reader . readline ( ) ) != null ) { if ( ! line . startswith ( "#" ) && ( ! line . isempty ( ) || readblanks ) ) { strings . add ( line ) ; } } reader . close ( ) ; break ; } catch ( ioexception e ) { system . err . println ( "error reading file " + f . getname ( ) + ".... attempting again" ) ; } } return strings ; }
tr	3	public static void benchmark ( ) throws exception { int n = 100000 ; string [ ] methodstocompare = { "canwriteletterfrommagazine1" , "canwriteletterfrommagazine2" , "canwriteletterfrommagazine3" , "canwriteletterfrommagazine4" , "canwriteletterfrommagazine5" , "canwriteletterfrommagazine6" , "canwriteletterfrommagazine7" } ; string magazine = cleaninput ( "this is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazine" ) ; string letter = cleaninput ( "hogs are swine" ) ; for ( string methodname : methodstocompare ) { class clazz = class . forname ( "book.chapter.twelve.problem12_09" ) ; method method = clazz . getdeclaredmethod ( methodname , string . class , string . class ) ; long starttime = system . nanotime ( ) ; for ( int i = 0 ; i < n ; i ++ ) { boolean retval = ( boolean ) method . invoke ( null , letter , magazine ) ; if ( retval == false ) throw new exception ( "wrong result!" ) ; } long endtime = system . nanotime ( ) ; system . out . println ( "elapsed time for " + methodname + ": " + ( endtime - starttime ) / 1000000000.0 + " seconds" ) ; } }
tr	0	@ test public void testclonesimplebean ( ) { bank bankfrom = new localbank ( ) ; bankfrom . setid ( 1 ) ; bankfrom . setname ( "alfabank" ) ; subject payer = new subject ( ) ; payer . setbank ( bankfrom ) ; payer . setid ( "payer" ) ; payer . setname ( "alice" ) ; bank bankto = new foreignbank ( ) ; bankto . setid ( 2 ) ; bankto . setname ( "citibank" ) ; subject receiver = new subject ( ) ; receiver . setbank ( bankto ) ; receiver . setid ( "receiver" ) ; receiver . setname ( "alice" ) ; payment pay = new payment ( 100 ) ; pay . setamount ( new bigdecimal ( "123.45" ) ) ; pay . setpayer ( payer ) ; pay . setreceiver ( receiver ) ; pay . settimestamp ( instant . now ( ) ) ; payment copy = beanhelper . cloneof ( pay ) ; assertnotsame ( pay , copy ) ; assertnotsame ( pay . getpayer ( ) , copy . getpayer ( ) ) ; assertnotsame ( pay . getreceiver ( ) , copy . getreceiver ( ) ) ; assertnotsame ( pay . getpayer ( ) . getbank ( ) , copy . getpayer ( ) . getbank ( ) ) ; assertnotsame ( pay . getreceiver ( ) . getbank ( ) , copy . getreceiver ( ) . getbank ( ) ) ; assertequals ( pay . getamount ( ) , copy . getamount ( ) ) ; assertequals ( pay . getid ( ) , copy . getid ( ) ) ; assertequals ( pay . gettimestamp ( ) , copy . gettimestamp ( ) ) ; subject cpayer = copy . getpayer ( ) ; subject creceiver = copy . getreceiver ( ) ; bank cbankfrom = cpayer . getbank ( ) ; bank cbankto = creceiver . getbank ( ) ; assertequals ( payer . getid ( ) , cpayer . getid ( ) ) ; assertequals ( payer . getname ( ) , cpayer . getname ( ) ) ; assertequals ( bankfrom . getid ( ) , cbankfrom . getid ( ) ) ; assertequals ( bankfrom . getname ( ) , cbankfrom . getname ( ) ) ; assertsame ( bankfrom . getclass ( ) , cbankfrom . getclass ( ) ) ; assertequals ( receiver . getid ( ) , creceiver . getid ( ) ) ; assertequals ( receiver . getname ( ) , creceiver . getname ( ) ) ; assertequals ( bankto . getid ( ) , cbankto . getid ( ) ) ; assertequals ( bankto . getname ( ) , cbankto . getname ( ) ) ; assertsame ( bankto . getclass ( ) , cbankto . getclass ( ) ) ; }
tr	7	public void killhappenedat ( pointi p , int mobsize , boolean wassplashdamage ) { if ( ( p . x < 0 ) || ( p . y < 0 ) || ( p . x >= w ) || ( p . y >= h ) ) return ; double amount = 1f / mobsize / mobsize ; for ( int y = 0 ; y < mobsize ; y ++ ) { for ( int x = 0 ; x < mobsize ; x ++ ) { if ( wassplashdamage ) { splashkillcounts [ p . y + y ] [ p . x + x ] += amount ; } else { normalkillcounts [ p . y + y ] [ p . x + x ] += amount ; } } } }
tr	8	@ suppresswarnings ( { "unchecked" } ) public static < j , k , v > map < j , map < k , v >> generatecomplexmap ( class < j > jtype , class < k > keytype , class < v > valuetype ) { random random = new random ( 987654321 ) ; map < j , map < k , v >> complexmap = new hashmap < j , map < k , v >> ( ) ; for ( int i = 0 ; i < 10 ; i ++ ) { j family = null ; if ( jtype == string . class ) { family = ( j ) string . valueof ( random . nextint ( ) ) ; } else if ( jtype == integer . class ) { family = ( j ) integer . valueof ( random . nextint ( ) ) ; } else if ( jtype == long . class ) { family = ( j ) long . valueof ( random . nextlong ( ) ) ; } else if ( jtype == double . class ) { family = ( j ) double . valueof ( random . nextdouble ( ) ) ; } else if ( jtype == byte [ ] . class ) { byte [ ] bytes = bytes . tobytes ( random . nextint ( ) ) ; family = ( j ) bytes ; } else if ( jtype == float . class ) { family = ( j ) float . valueof ( random . nextfloat ( ) ) ; } else if ( jtype == boolean . class ) { family = ( j ) boolean . valueof ( random . nextboolean ( ) ) ; } map < k , v > map = generatemapfield ( keytype , valuetype ) ; complexmap . put ( family , map ) ; } return complexmap ; }
tr	2	private void buildpanel ( ) { this . setborder ( new emptyborder ( this . innermargin , this . innermargin , this . innermargin , this . innermargin ) ) ; this . setlayout ( new borderlayout ( ) ) ; if ( label != null && ! label . isempty ( ) ) { jpanel labelpanel = new jpanel ( ) ; labelpanel . setlayout ( new flowlayout ( ) ) ; labelpanel . add ( new jlabel ( label ) ) ; this . add ( labelpanel , borderlayout . north ) ; } this . listmodel = new defaultlistmodel < string > ( ) ; this . addnamestolist ( this . names ) ; this . nameslistbox = new jlist < string > ( this . listmodel ) ; this . nameslistbox . setselectionmode ( listselectionmodel . multiple_interval_selection ) ; this . nameslistbox . setlayoutorientation ( jlist . vertical ) ; jscrollpane listscroller = new jscrollpane ( this . nameslistbox ) ; listscroller . setpreferredsize ( new dimension ( 200 , 200 ) ) ; this . add ( listscroller , borderlayout . center ) ; }
tr	8	public void draw ( ) { iterator < entity > i2 = getnearbyentities ( p . getlocation ( ) , 15 ) . iterator ( ) ; arraylist < block > bs = getnearbyblocks ( p . getlocation ( ) . modify ( 0 , 0 ) , 16 ) ; for ( block b : bs ) { b . draw ( ) ; } while ( i2 . hasnext ( ) ) { entity todraw = i2 . next ( ) ; todraw . draw ( ) ; } if ( path != null ) { for ( int c = 0 ; c < path . size ( ) ; c ++ ) { if ( c == 0 ) { engine . render ( path . get ( c ) , material . gold_ore . getimage ( ) ) ; } else if ( c == path . size ( ) - 1 ) { engine . render ( path . get ( c ) , material . iron_ore . getimage ( ) ) ; } else { engine . render ( path . get ( c ) , material . obsidian . getimage ( ) ) ; } } } if ( renderlight ) { engine . addqueueitem ( new renderqueueitem ( lightloc , lightmap ) ) ; } if ( drawmap ) { engine . addqueueitem ( new renderqueueitem ( new rectangle ( 0 , 0 , main . getpanewidth ( ) , main . getpaneheight ( ) ) , color . blue ) ) ; engine . addqueueitem ( new renderqueueitem ( 0 , 0 , map ) ) ; } }
tr	2	private static byte [ ] constructorvaluehelper ( byte [ ] left , byte [ ] right ) { byte [ ] value = new byte [ left . length + right . length ] ; for ( int i = 0 ; i < left . length ; i ++ ) { value [ i ] = left [ i ] ; } for ( int j = left . length ; j < value . length ; j ++ ) { value [ j ] = right [ j - left . length ] ; } return value ; }
tr	7	public registerframe ( servermanager theserver , string theurl , int theport , int thelistenport ) { super ( "registrar usuario" ) ; controller = new registercontroller ( theserver , theurl , theport ) ; server = theserver ; url = theurl ; port = theport ; listenport = thelistenport ; addwindowlistener ( new windowadapter ( ) { @ override public void windowclosing ( windowevent e ) { createloginframe ( ) ; } } ) ; setbounds ( 100 , 100 , 661 , 403 ) ; contentpane = new jpanel ( ) ; contentpane . setbackground ( color . white ) ; contentpane . setborder ( new emptyborder ( 5 , 5 , 5 , 5 ) ) ; setcontentpane ( contentpane ) ; contentpane . setlayout ( new borderlayout ( 0 , 10 ) ) ; jlabel lblregistrarusuario = new jlabel ( "registrar usuario" ) ; lblregistrarusuario . setfont ( new font ( "tahoma" , font . bold , 18 ) ) ; lblregistrarusuario . sethorizontalalignment ( swingconstants . center ) ; contentpane . add ( lblregistrarusuario , borderlayout . north ) ; jpanel panelbotton = new jpanel ( ) ; panelbotton . setbackground ( color . white ) ; contentpane . add ( panelbotton , borderlayout . south ) ; panelbotton . setlayout ( new flowlayout ( flowlayout . right , 5 , 5 ) ) ; jbutton btnregister = new jbutton ( "registrarse" ) ; btnregister . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent arg0 ) { try { controller . register ( usernametxt . gettext ( ) , new string ( passwordtxt . getpassword ( ) ) , new string ( repasswordtxt . getpassword ( ) ) , firstnametxt . gettext ( ) , lastnametxt . gettext ( ) , emailtxt . gettext ( ) ) ; joptionpane . showmessagedialog ( null , "registro exitoso!  ahora podra usar el servicio de chat" , "registro exitoso" , joptionpane . information_message ) ; createloginframe ( ) ; } catch ( registerexception e ) { joptionpane . showmessagedialog ( null , e . getmessage ( ) , "error" , joptionpane . error_message ) ; } } } ) ; btnregister . seticon ( new imageicon ( registerframe . class . getresource ( "/chat/client/view/resources/registericon.png" ) ) ) ; panelbotton . add ( btnregister ) ; jbutton btncancel = new jbutton ( "cancelar" ) ; btncancel . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent e ) { createloginframe ( ) ; } } ) ; panelbotton . add ( btncancel ) ; jpanel panel = new jpanel ( ) ; contentpane . add ( panel , borderlayout . center ) ; panel . setlayout ( new gridlayout ( 0 , 2 , 0 , 0 ) ) ; imagepanel imagepanel = new imagepanel ( toolkit . getdefaulttoolkit ( ) . getimage ( registerframe . class . getresource ( "/chat/client/view/resources/ico2.jpg" ) ) ) ; panel . add ( imagepanel ) ; jpanel panel_1 = new jpanel ( ) ; panel_1 . setbackground ( color . white ) ; panel . add ( panel_1 ) ; gridbaglayout gbl_panel_1 = new gridbaglayout ( ) ; gbl_panel_1 . columnwidths = new int [ ] { 0 , 150 , 10 } ; gbl_panel_1 . rowheights = new int [ ] { 0 , 0 , 0 , 0 , 0 , 0 , 20 } ; gbl_panel_1 . columnweights = new double [ ] { 0.0 , 1.0 , 0.0 } ; gbl_panel_1 . rowweights = new double [ ] { 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 } ; panel_1 . setlayout ( gbl_panel_1 ) ; jlabel label = new jlabel ( "nombre de usuario:" ) ; label . setfont ( new font ( "tahoma" , font . plain , 12 ) ) ; gridbagconstraints gbc_label = new gridbagconstraints ( ) ; gbc_label . anchor = gridbagconstraints . east ; gbc_label . insets = new insets ( 0 , 0 , 5 , 5 ) ; gbc_label . gridx = 0 ; gbc_label . gridy = 0 ; panel_1 . add ( label , gbc_label ) ; usernametxt = new jtextfield ( ) ; usernametxt . addfocuslistener ( new focusadapter ( ) { @ override public void focuslost ( focusevent e ) { if ( ! controller . isvalidusername ( usernametxt . gettext ( ) ) ) { lblusernameerror . settext ( "*" ) ; lblerror . settext ( "el nombre de usuario es invalido" ) ; } else { lblusernameerror . settext ( "" ) ; lblerror . settext ( "" ) ; } } } ) ; usernametxt . setfont ( new font ( "tahoma" , font . plain , 12 ) ) ; usernametxt . setcolumns ( 20 ) ; gridbagconstraints gbc_usernametxt = new gridbagconstraints ( ) ; gbc_usernametxt . fill = gridbagconstraints . horizontal ; gbc_usernametxt . insets = new insets ( 0 , 0 , 5 , 5 ) ; gbc_usernametxt . gridx = 1 ; gbc_usernametxt . gridy = 0 ; panel_1 . add ( usernametxt , gbc_usernametxt ) ; lblusernameerror = new jlabel ( "" ) ; lblusernameerror . setforeground ( color . red ) ; gridbagconstraints gbc_lblusernameerror = new gridbagconstraints ( ) ; gbc_lblusernameerror . insets = new insets ( 0 , 0 , 5 , 0 ) ; gbc_lblusernameerror . gridx = 2 ; gbc_lblusernameerror . gridy = 0 ; panel_1 . add ( lblusernameerror , gbc_lblusernameerror ) ; jlabel label_1 = new jlabel ( "contrase\u00f1a:" ) ; label_1 . setfont ( new font ( "tahoma" , font . plain , 12 ) ) ; gridbagconstraints gbc_label_1 = new gridbagconstraints ( ) ; gbc_label_1 . anchor = gridbagconstraints . east ; gbc_label_1 . insets = new insets ( 0 , 0 , 5 , 5 ) ; gbc_label_1 . gridx = 0 ; gbc_label_1 . gridy = 1 ; panel_1 . add ( label_1 , gbc_label_1 ) ; passwordtxt = new jpasswordfield ( ) ; passwordtxt . addfocuslistener ( new focusadapter ( ) { @ override public void focuslost ( focusevent arg0 ) { if ( ! controller . isvalidpassword ( new string ( passwordtxt . getpassword ( ) ) ) ) { lblpassworderror . settext ( "*" ) ; lblerror . settext ( "la contrase\ufffda es invalida" ) ; } else { lblpassworderror . settext ( "" ) ; lblerror . settext ( "" ) ; } } } ) ; passwordtxt . setcolumns ( 20 ) ; passwordtxt . setfont ( new font ( "tahoma" , font . plain , 12 ) ) ; gridbagconstraints gbc_passwordtxt = new gridbagconstraints ( ) ; gbc_passwordtxt . fill = gridbagconstraints . horizontal ; gbc_passwordtxt . insets = new insets ( 0 , 0 , 5 , 5 ) ; gbc_passwordtxt . gridx = 1 ; gbc_passwordtxt . gridy = 1 ; panel_1 . add ( passwordtxt , gbc_passwordtxt ) ; lblpassworderror = new jlabel ( "" ) ; lblpassworderror . setforeground ( color . red ) ; gridbagconstraints gbc_lblpassworderror = new gridbagconstraints ( ) ; gbc_lblpassworderror . insets = new insets ( 0 , 0 , 5 , 0 ) ; gbc_lblpassworderror . gridx = 2 ; gbc_lblpassworderror . gridy = 1 ; panel_1 . add ( lblpassworderror , gbc_lblpassworderror ) ; jlabel label_2 = new jlabel ( "repetir contrase\u00f1a:" ) ; label_2 . setfont ( new font ( "tahoma" , font . plain , 12 ) ) ; gridbagconstraints gbc_label_2 = new gridbagconstraints ( ) ; gbc_label_2 . anchor = gridbagconstraints . east ; gbc_label_2 . insets = new insets ( 0 , 0 , 5 , 5 ) ; gbc_label_2 . gridx = 0 ; gbc_label_2 . gridy = 2 ; panel_1 . add ( label_2 , gbc_label_2 ) ; repasswordtxt = new jpasswordfield ( ) ; repasswordtxt . addfocuslistener ( new focusadapter ( ) { @ override public void focuslost ( focusevent e ) { if ( ! controller . isrepasswordequaltopassword ( new string ( passwordtxt . getpassword ( ) ) , new string ( repasswordtxt . getpassword ( ) ) ) ) { lblrepassworderror . settext ( "*" ) ; lblerror . settext ( "la contrase\ufffda es invalida" ) ; } else { lblrepassworderror . settext ( "" ) ; lblerror . settext ( "" ) ; } } } ) ; repasswordtxt . setcolumns ( 20 ) ; repasswordtxt . setfont ( new font ( "tahoma" , font . plain , 12 ) ) ; gridbagconstraints gbc_repasswordtxt = new gridbagconstraints ( ) ; gbc_repasswordtxt . fill = gridbagconstraints . horizontal ; gbc_repasswordtxt . insets = new insets ( 0 , 0 , 5 , 5 ) ; gbc_repasswordtxt . gridx = 1 ; gbc_repasswordtxt . gridy = 2 ; panel_1 . add ( repasswordtxt , gbc_repasswordtxt ) ; lblrepassworderror = new jlabel ( "" ) ; lblrepassworderror . setforeground ( color . red ) ; gridbagconstraints gbc_lblrepassworderror = new gridbagconstraints ( ) ; gbc_lblrepassworderror . insets = new insets ( 0 , 0 , 5 , 0 ) ; gbc_lblrepassworderror . gridx = 2 ; gbc_lblrepassworderror . gridy = 2 ; panel_1 . add ( lblrepassworderror , gbc_lblrepassworderror ) ; jlabel label_3 = new jlabel ( "nombre(s):" ) ; label_3 . setfont ( new font ( "tahoma" , font . plain , 12 ) ) ; gridbagconstraints gbc_label_3 = new gridbagconstraints ( ) ; gbc_label_3 . anchor = gridbagconstraints . east ; gbc_label_3 . insets = new insets ( 0 , 0 , 5 , 5 ) ; gbc_label_3 . gridx = 0 ; gbc_label_3 . gridy = 3 ; panel_1 . add ( label_3 , gbc_label_3 ) ; firstnametxt = new jtextfield ( ) ; firstnametxt . addfocuslistener ( new focusadapter ( ) { @ override public void focuslost ( focusevent e ) { if ( ! controller . isvalidfirstname ( firstnametxt . gettext ( ) ) ) { lblfirstnameerror . settext ( "*" ) ; lblerror . settext ( "el nombre de usuario es invalido" ) ; } else { lblfirstnameerror . settext ( "" ) ; lblerror . settext ( "" ) ; } } } ) ; firstnametxt . setfont ( new font ( "tahoma" , font . plain , 12 ) ) ; firstnametxt . setcolumns ( 30 ) ; gridbagconstraints gbc_firstnametxt = new gridbagconstraints ( ) ; gbc_firstnametxt . fill = gridbagconstraints . horizontal ; gbc_firstnametxt . insets = new insets ( 0 , 0 , 5 , 5 ) ; gbc_firstnametxt . gridx = 1 ; gbc_firstnametxt . gridy = 3 ; panel_1 . add ( firstnametxt , gbc_firstnametxt ) ; lblfirstnameerror = new jlabel ( "" ) ; lblfirstnameerror . setforeground ( color . red ) ; gridbagconstraints gbc_lblfirstnameerror = new gridbagconstraints ( ) ; gbc_lblfirstnameerror . insets = new insets ( 0 , 0 , 5 , 0 ) ; gbc_lblfirstnameerror . gridx = 2 ; gbc_lblfirstnameerror . gridy = 3 ; panel_1 . add ( lblfirstnameerror , gbc_lblfirstnameerror ) ; jlabel label_4 = new jlabel ( "apellido(s):" ) ; label_4 . setfont ( new font ( "tahoma" , font . plain , 12 ) ) ; gridbagconstraints gbc_label_4 = new gridbagconstraints ( ) ; gbc_label_4 . anchor = gridbagconstraints . east ; gbc_label_4 . insets = new insets ( 0 , 0 , 5 , 5 ) ; gbc_label_4 . gridx = 0 ; gbc_label_4 . gridy = 4 ; panel_1 . add ( label_4 , gbc_label_4 ) ; lastnametxt = new jtextfield ( ) ; lastnametxt . addfocuslistener ( new focusadapter ( ) { @ override public void focuslost ( focusevent e ) { if ( ! controller . isvalidlastname ( lastnametxt . gettext ( ) ) ) { lbllastnameerror . settext ( "*" ) ; lblerror . settext ( "el nombre de usuario es invalido" ) ; } else { lbllastnameerror . settext ( "" ) ; lblerror . settext ( "" ) ; } } } ) ; lastnametxt . setfont ( new font ( "tahoma" , font . plain , 12 ) ) ; lastnametxt . setcolumns ( 30 ) ; gridbagconstraints gbc_lastnametxt = new gridbagconstraints ( ) ; gbc_lastnametxt . fill = gridbagconstraints . horizontal ; gbc_lastnametxt . insets = new insets ( 0 , 0 , 5 , 5 ) ; gbc_lastnametxt . gridx = 1 ; gbc_lastnametxt . gridy = 4 ; panel_1 . add ( lastnametxt , gbc_lastnametxt ) ; lbllastnameerror = new jlabel ( "" ) ; lbllastnameerror . setforeground ( color . red ) ; gridbagconstraints gbc_lbllastnameerror = new gridbagconstraints ( ) ; gbc_lbllastnameerror . insets = new insets ( 0 , 0 , 5 , 0 ) ; gbc_lbllastnameerror . gridx = 2 ; gbc_lbllastnameerror . gridy = 4 ; panel_1 . add ( lbllastnameerror , gbc_lbllastnameerror ) ; jlabel label_5 = new jlabel ( "e-mail:" ) ; label_5 . setfont ( new font ( "tahoma" , font . plain , 12 ) ) ; gridbagconstraints gbc_label_5 = new gridbagconstraints ( ) ; gbc_label_5 . anchor = gridbagconstraints . east ; gbc_label_5 . insets = new insets ( 0 , 0 , 5 , 5 ) ; gbc_label_5 . gridx = 0 ; gbc_label_5 . gridy = 5 ; panel_1 . add ( label_5 , gbc_label_5 ) ; emailtxt = new jtextfield ( ) ; emailtxt . addfocuslistener ( new focusadapter ( ) { @ override public void focuslost ( focusevent e ) { if ( ! controller . isvalidemail ( emailtxt . gettext ( ) ) ) { lblemailerror . settext ( "*" ) ; lblerror . settext ( "el nombre de usuario es invalido" ) ; } else { lblemailerror . settext ( "" ) ; lblerror . settext ( "" ) ; } } } ) ; emailtxt . setfont ( new font ( "tahoma" , font . plain , 12 ) ) ; emailtxt . setcolumns ( 50 ) ; gridbagconstraints gbc_emailtxt = new gridbagconstraints ( ) ; gbc_emailtxt . insets = new insets ( 0 , 0 , 5 , 5 ) ; gbc_emailtxt . fill = gridbagconstraints . horizontal ; gbc_emailtxt . gridx = 1 ; gbc_emailtxt . gridy = 5 ; panel_1 . add ( emailtxt , gbc_emailtxt ) ; lblemailerror = new jlabel ( "" ) ; lblemailerror . setforeground ( color . red ) ; gridbagconstraints gbc_lblemailerror = new gridbagconstraints ( ) ; gbc_lblemailerror . insets = new insets ( 0 , 0 , 5 , 0 ) ; gbc_lblemailerror . gridx = 2 ; gbc_lblemailerror . gridy = 5 ; panel_1 . add ( lblemailerror , gbc_lblemailerror ) ; lblerror = new jlabel ( "" ) ; lblerror . setforeground ( color . red ) ; gridbagconstraints gbc_lblerror = new gridbagconstraints ( ) ; gbc_lblerror . gridwidth = 3 ; gbc_lblerror . insets = new insets ( 0 , 0 , 0 , 5 ) ; gbc_lblerror . gridx = 0 ; gbc_lblerror . gridy = 6 ; panel_1 . add ( lblerror , gbc_lblerror ) ; }
tr	9	synchronized hashtable getproperties ( ) { if ( ( props == null ) && ( gettext ( ) != null ) ) { hashtable props = new hashtable ( ) ; int off = 0 ; while ( off < gettext ( ) . length ) { int len = gettext ( ) [ off ++ ] & ff ; if ( ( len == 0 ) || ( off + len > gettext ( ) . length ) ) { props . clear ( ) ; break ; } int i = 0 ; for ( ; ( i < len ) && ( gettext ( ) [ off + i ] != = ) ; i ++ ) { ; } string name = readutf ( gettext ( ) , off , i ) ; if ( name == null ) { props . clear ( ) ; break ; } if ( i == len ) { props . put ( name , no_value ) ; } else { byte value [ ] = new byte [ len - ++ i ] ; system . arraycopy ( gettext ( ) , off + i , value , 0 , len - i ) ; props . put ( name , value ) ; off += len ; } } this . props = props ; } return props ; }
tr	1	public static byte [ ] hexstringtobytes ( string hex ) { int len = hex . length ( ) ; byte [ ] bytes = new byte [ ( len + 1 ) / 3 ] ; for ( int i = 0 ; i < len ; i += 3 ) { bytes [ i / 3 ] = ( byte ) ( ( character . digit ( hex . charat ( i ) , 16 ) << 4 ) + character . digit ( hex . charat ( i + 1 ) , 16 ) ) ; } return bytes ; }
tr	2	@ override public string evaluatepolicy ( float max_risk , transferredfile policyfiletotransfer , transferredfile dbsqldumpfiletotransfer , string table_name ) { random generator = new random ( system . currenttimemillis ( ) ) ; long gid = generator . nextlong ( ) ; if ( gid < 0 ) gid = gid * ( - 1 ) ; tempfiles tf = new tempfiles ( ) ; file dbdumptempfile = null ; file policytempfile = null ; try { dbdumptempfile = tf . createtempfile ( dbsqldumpfiletotransfer ) ; policytempfile = tf . createtempfile ( policyfiletotransfer ) ; dbdumptempfile . deleteonexit ( ) ; policytempfile . deleteonexit ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } dba_factory . evaluatepolicy ( policytempfile , dbdumptempfile , null , gid , table_name , false ) ; return "id: --" + gid + "--" ; }
tr	9	private void drawmenu ( ) { int i = menuoffsetx ; int j = menuoffsety ; int k = menuwidth ; int l = menuheight + 1 ; drawingarea . method338 ( menuoffsety + 2 , menuheight - 4 , 250 , 706a5e , menuwidth , menuoffsetx ) ; drawingarea . method338 ( menuoffsety + 1 , menuheight - 2 , 250 , 706a5e , menuwidth - 2 , menuoffsetx + 1 ) ; drawingarea . method338 ( menuoffsety , menuheight , 200 , 706a5e , menuwidth - 4 , menuoffsetx + 2 ) ; drawingarea . method338 ( menuoffsety + 1 , menuheight - 2 , 250 , 2d2822 , menuwidth - 6 , menuoffsetx + 3 ) ; drawingarea . method338 ( menuoffsety + 2 , menuheight - 4 , 250 , 2d2822 , menuwidth - 4 , menuoffsetx + 2 ) ; drawingarea . method338 ( menuoffsety + 3 , menuheight - 6 , 250 , 2d2822 , menuwidth - 2 , menuoffsetx + 1 ) ; drawingarea . method338 ( menuoffsety + 19 , menuheight - 22 , 250 , 524a3d , menuwidth - 4 , menuoffsetx + 2 ) ; drawingarea . method338 ( menuoffsety + 20 , menuheight - 22 , 250 , 524a3d , menuwidth - 6 , menuoffsetx + 3 ) ; drawingarea . method335 ( 112329 , j + 20 , k - 6 , l - 23 , 170 , i + 3 ) ; drawingarea . fillpixels ( menuoffsetx + 3 , menuwidth - 6 , 1 , 2a291b , menuoffsety + 2 ) ; drawingarea . fillpixels ( menuoffsetx + 2 , menuwidth - 4 , 1 , 2a261b , menuoffsety + 3 ) ; drawingarea . fillpixels ( menuoffsetx + 2 , menuwidth - 4 , 1 , 252116 , menuoffsety + 4 ) ; drawingarea . fillpixels ( menuoffsetx + 2 , menuwidth - 4 , 1 , 211e15 , menuoffsety + 5 ) ; drawingarea . fillpixels ( menuoffsetx + 2 , menuwidth - 4 , 1 , 1e1b12 , menuoffsety + 6 ) ; drawingarea . fillpixels ( menuoffsetx + 2 , menuwidth - 4 , 1 , 1a170e , menuoffsety + 7 ) ; drawingarea . fillpixels ( menuoffsetx + 2 , menuwidth - 4 , 2 , 15120b , menuoffsety + 8 ) ; drawingarea . fillpixels ( menuoffsetx + 2 , menuwidth - 4 , 1 , 100d08 , menuoffsety + 10 ) ; drawingarea . fillpixels ( menuoffsetx + 2 , menuwidth - 4 , 1 , 090a04 , menuoffsety + 11 ) ; drawingarea . fillpixels ( menuoffsetx + 2 , menuwidth - 4 , 1 , 080703 , menuoffsety + 12 ) ; drawingarea . fillpixels ( menuoffsetx + 2 , menuwidth - 4 , 1 , 090a04 , menuoffsety + 13 ) ; drawingarea . fillpixels ( menuoffsetx + 2 , menuwidth - 4 , 1 , 070802 , menuoffsety + 14 ) ; drawingarea . fillpixels ( menuoffsetx + 2 , menuwidth - 4 , 1 , 090a04 , menuoffsety + 15 ) ; drawingarea . fillpixels ( menuoffsetx + 2 , menuwidth - 4 , 1 , 070802 , menuoffsety + 16 ) ; drawingarea . fillpixels ( menuoffsetx + 2 , menuwidth - 4 , 1 , 090a04 , menuoffsety + 17 ) ; drawingarea . fillpixels ( menuoffsetx + 2 , menuwidth - 4 , 1 , 2a291b , menuoffsety + 18 ) ; drawingarea . fillpixels ( menuoffsetx + 3 , menuwidth - 6 , 1 , 564943 , menuoffsety + 19 ) ; chattextdrawingarea . method385 ( c6b895 , "choose option" , menuoffsety + 14 , menuoffsetx + 3 ) ; int j1 = super . mousex ; int k1 = super . mousey ; if ( menuscreenarea == 0 ) { j1 -= 4 ; k1 -= 4 ; } if ( menuscreenarea == 1 ) { j1 -= 519 ; k1 -= 168 ; } if ( menuscreenarea == 2 ) { j1 -= 17 ; k1 -= 338 ; } if ( menuscreenarea == 3 ) { j1 -= 516 ; k1 -= 0 ; } for ( int l1 = 0 ; l1 < menuactionrow ; l1 ++ ) { int i2 = j + 31 + ( menuactionrow - 1 - l1 ) * 15 ; int j2 = c6b895 ; if ( j1 > i && j1 < i + k && k1 > i2 - 13 && k1 < i2 + 3 ) { drawingarea . drawpixels ( 15 , i2 - 11 , i + 3 , 26566c , menuwidth - 6 ) ; j2 = eee5c6 ; } chattextdrawingarea . method389 ( true , i + 4 , aaa184 , menuactionname [ l1 ] , i2 + 1 ) ; } }
tr	1	@ override public void writeanalysis ( morphologyanalysis analysis ) { final string record = string . format ( "%s (\"%s\"  \"%s\"  \"%s\"  \"%s\"  \"%s\"  \"%s\"  \"%s\"  \"%s\"  \"%s\"  \"%s\"  \"%s\");%n" , insert_analysis , analysis . getform ( ) , analysis . getlemma ( ) , analysis . getgrammaticalcase ( ) , analysis . getdegree ( ) , analysis . getgender ( ) , analysis . getmood ( ) , analysis . getnumber ( ) , analysis . getperson ( ) , analysis . getpos ( ) , analysis . gettense ( ) , analysis . getvoice ( ) ) ; try { morphologywriter . write ( record ) ; } catch ( ioexception e ) { throw new runtimeexception ( e ) ; } }
tr	6	private void initpanels ( ) { if ( attribs == null ) { attribs = new myinternalframe ( this , 1 ) ; jdesktoppane1 . add ( attribs , new integer ( 10 ) ) ; } try { attribs . seticon ( true ) ; } catch ( java . beans . propertyvetoexception e ) { } attribs . setvisible ( true ) ; if ( tools == null ) { tools = new myinternalframe ( this , 0 ) ; jdesktoppane1 . add ( tools , new integer ( 10 ) ) ; } tools . setvisible ( true ) ; try { tools . seticon ( true ) ; } catch ( java . beans . propertyvetoexception e ) { } if ( opers == null ) { opers = new myinternalframe ( this , 2 ) ; jdesktoppane1 . add ( opers , new integer ( 10 ) ) ; } try { opers . seticon ( true ) ; } catch ( java . beans . propertyvetoexception e ) { } opers . setvisible ( true ) ; }
tr	0	@ test public void testgetwordsfromunknownword ( ) { dataholder mytester = this . dataholderfactory ( ) ; mytester . add2holder ( dataholder . unknownword , arrays . aslist ( "word3 unknown" . split ( " " ) ) ) ; mytester . add2holder ( dataholder . unknownword , arrays . aslist ( "cheek unknown" . split ( " " ) ) ) ; mytester . add2holder ( dataholder . unknownword , arrays . aslist ( "cross unknown" . split ( " " ) ) ) ; mytester . add2holder ( dataholder . unknownword , arrays . aslist ( "deep unknown" . split ( " " ) ) ) ; mytester . add2holder ( dataholder . unknownword , arrays . aslist ( "denticles unknown" . split ( " " ) ) ) ; mytester . add2holder ( dataholder . unknownword , arrays . aslist ( "word4 unknown" . split ( " " ) ) ) ; mytester . add2holder ( dataholder . unknownword , arrays . aslist ( "endocranium unknown" . split ( " " ) ) ) ; mytester . add2holder ( dataholder . unknownword , arrays . aslist ( "word5 unknown" . split ( " " ) ) ) ; mytester . add2holder ( dataholder . unknownword , arrays . aslist ( "lepidotrichia unknown" . split ( " " ) ) ) ; mytester . add2holder ( dataholder . unknownword , arrays . aslist ( "word1 unknown" . split ( " " ) ) ) ; mytester . add2holder ( dataholder . unknownword , arrays . aslist ( "word2 unknown" . split ( " " ) ) ) ; set < string > target = new hashset < string > ( ) ; target . add ( "cheek" ) ; target . add ( "cross" ) ; target . add ( "deep" ) ; target . add ( "denticles" ) ; target . add ( "endocranium" ) ; target . add ( "lepidotrichia" ) ; string wordpattern = "((" + constant . plendings + "|ium)$)|(ee)" ; string flagpattern = "^unknown$" ; assertequals ( "getwordsfromunknownword" , target , mytester . getwordsfromunknownword ( wordpattern , true , flagpattern , true ) ) ; }
tr	8	private void loadingstages ( ) { if ( lowmemory && loadingstage == 2 && region . plane != plane ) { gamescreenimageproducer . initdrawingarea ( ) ; fontplain . drawcentredtext ( "loading - please wait." , 257 , 151 , 0 ) ; fontplain . drawcentredtext ( "loading - please wait." , 256 , 150 , ffffff ) ; gamescreenimageproducer . drawgraphics ( 4 , super . gamegraphics , 4 ) ; loadingstage = 1 ; loadregiontime = system . currenttimemillis ( ) ; } if ( loadingstage == 1 ) { int successful = initialiseregionloading ( ) ; if ( successful != 0 && system . currenttimemillis ( ) - loadregiontime > 360000 ) { signlink . reporterror ( enteredusername + " glcfb " + serversessionkey + " " + successful + " " + lowmemory + " " + caches [ 0 ] + " " + ondemandfetcher . immediaterequestcount ( ) + " " + plane + " " + regionx + " " + regiony ) ; loadregiontime = system . currenttimemillis ( ) ; } } if ( loadingstage == 2 && plane != lastregionid ) { lastregionid = plane ; renderminimap ( plane ) ; } }
tr	2	@ override public final void setgeometry ( final object geometry ) { if ( geometry instanceof string [ ] ) { final string [ ] geometryarray = ( string [ ] ) geometry ; if ( geometryarray . length != 4 ) { throw new illegalargumentexception ( "geometry must be an array of four elements that contains racolname  deccolname  timecolname and bandcolname" ) ; } else { this . racol = geometryarray [ 0 ] ; this . deccol = geometryarray [ 1 ] ; this . timecol = geometryarray [ 2 ] ; this . bandcol = geometryarray [ 3 ] ; } } else { throw new illegalargumentexception ( "geometry must be an array of four elements that contains racolname  deccolname  timecolname and bandcolname" ) ; } }
tr	2	private set < strategy > buildstrategies ( strategy strategy , int breakpointnumber , int [ ] breakpoints , int [ ] [ ] actionpercentages ) { set < strategy > strategies = new hashset < strategy > ( ) ; for ( int [ ] actionpercentageset : actionpercentages ) { strategy s = new strategy ( strategy ) ; tactic nexttactic = new tactic ( actionpercentageset ) ; s . putnewtactic ( nexttactic ) ; if ( breakpointnumber < aisettings . default_breakpoints . length - 1 ) { strategies . addall ( buildstrategies ( s , breakpointnumber + 1 , breakpoints , actionpercentages ) ) ; } else { strategies . add ( s ) ; } } return strategies ; }
tr	0	public static void main ( string [ ] args ) throws exception { predicate < string > predicate = ( s ) -> s . length ( ) > 0 ; predicate . test ( "foo" ) ; predicate . negate ( ) . test ( "foo" ) ; predicate < boolean > nonnull = objects colcol nonnull ; predicate < boolean > isnull = objects colcol isnull ; predicate < string > isempty = string colcol isempty ; predicate < string > isnotempty = isempty . negate ( ) ; function < string , integer > tointeger = integer colcol valueof ; function < string , string > backtostring = tointeger . andthen ( string colcol valueof ) ; backtostring . apply ( "123" ) ; supplier < person > personsupplier = person colcol new ; personsupplier . get ( ) ; consumer < person > greeter = ( p ) -> system . out . println ( "hello  " + p . firstname ) ; greeter . accept ( new person ( "luke" , "skywalker" ) ) ; comparator < person > comparator = ( p1 , p2 ) -> p1 . firstname . compareto ( p2 . firstname ) ; person p1 = new person ( "john" , "doe" ) ; person p2 = new person ( "alice" , "wonderland" ) ; comparator . compare ( p1 , p2 ) ; comparator . reversed ( ) . compare ( p1 , p2 ) ; runnable runnable = ( ) -> system . out . println ( uuid . randomuuid ( ) ) ; runnable . run ( ) ; callable < uuid > callable = uuid colcol randomuuid ; callable . call ( ) ; }
tr	7	@ override public boolean onresponse ( message message ) { string msg = message . content . tolowercase ( ) ; pattern pattern = pattern . compile ( "^@((qinbot)|(\u4eb2\u59b9\u5b50)) +help(.*)" ) ; matcher matcher = pattern . matcher ( msg ) ; if ( matcher . find ( ) ) { if ( matcher . group ( 4 ) == null || matcher . group ( 4 ) . trim ( ) . equals ( "" ) ) { stringbuilder sb = new stringbuilder ( ) ; sb . append ( "\\\\n\u8f93\u5165@qinbot help \u63d2\u4ef6\u540d\u79f0 \u83b7\u53d6\u5177\u4f53\u5e2e\u52a9\\\\n\u5f53\u524d\u63d2\u4ef6\u5982\u4e0b:\\\\n" ) ; for ( int i = 1 ; i < plugins . size ( ) ; i ++ ) { sb . append ( plugins . get ( i ) . name ) . append ( " ver:" ) . append ( plugins . get ( i ) . version ) . append ( "\\\\n" ) ; } message . reply ( sb . tostring ( ) ) ; } else { string help = null ; for ( int i = 1 ; i < plugins . size ( ) ; i ++ ) { if ( plugins . get ( i ) . name . equals ( matcher . group ( 4 ) . trim ( ) ) ) { pluginbase pluginbase = plugins . get ( i ) ; help = string . format ( "\\\\n\u7b80\u4ecb:%s\\\\n\u5e2e\u52a9:%s\\\\n" , pluginbase . descrition , pluginbase . help ) ; break ; } } if ( help != null ) { message . reply ( help ) ; } else { message . reply ( "\u672a\u627e\u5230" + matcher . group ( 4 ) ) ; } } return true ; } return false ; }
tr	4	public static void main ( string [ ] args ) { selectionsort ss = new selectionsort ( 10 ) ; system . out . println ( ss . tostring ( ) ) ; for ( int i = 0 ; i < ss . sort . length ; i ++ ) { int min = ss . sort [ i ] ; int nr = 0 ; boolean changed = false ; for ( int j = i + 1 ; j < ss . sort . length ; j ++ ) { if ( ss . sort [ j ] < min ) { min = ss . sort [ j ] ; nr = j ; changed = true ; } } if ( changed ) { ss . sort [ nr ] = ss . sort [ i ] ; ss . sort [ i ] = min ; } ss . sorted ( ss . sort ) ; } ss . sorted ( ss . sort ) ; system . out . println ( ss . tostring ( ) ) ; }
tr	0	private void initialize ( ) { frmtexasholdempoker = new jframe ( ) ; frmtexasholdempoker . settitle ( "texas holdem poker main" ) ; frmtexasholdempoker . setbounds ( 100 , 100 , 513 , 330 ) ; frmtexasholdempoker . setdefaultcloseoperation ( jframe . exit_on_close ) ; jmenubar menubar = new jmenubar ( ) ; frmtexasholdempoker . setjmenubar ( menubar ) ; jmenu mnnewmenu = new jmenu ( "poker" ) ; menubar . add ( mnnewmenu ) ; jmenuitem mntmjugar = new jmenuitem ( "jugar" ) ; mntmjugar . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent e ) { showselectplayerform ( ) ; } } ) ; mnnewmenu . add ( mntmjugar ) ; jmenuitem mntmnewmenuitem = new jmenuitem ( "salir" ) ; mntmnewmenuitem . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent arg0 ) { system . exit ( 0 ) ; } } ) ; mnnewmenu . add ( mntmnewmenuitem ) ; jmenu mnsalaryhistorymain = new jmenu ( "historial de cargas" ) ; menubar . add ( mnsalaryhistorymain ) ; jmenuitem mntmsalaryhistory = new jmenuitem ( "consultar historial de cargas" ) ; mntmsalaryhistory . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent e ) { showplayersearchform ( ) ; } } ) ; mnsalaryhistorymain . add ( mntmsalaryhistory ) ; jmenuitem mntmaddplayer = new jmenuitem ( "agregar jugador" ) ; mntmaddplayer . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent e ) { showcreateplayerform ( ) ; } } ) ; jmenuitem mntmaddcredit = new jmenuitem ( "cargar saldo" ) ; mntmaddcredit . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent arg0 ) { showplayersearchform ( ) ; } } ) ; mnsalaryhistorymain . add ( mntmaddcredit ) ; mnsalaryhistorymain . add ( mntmaddplayer ) ; }
tr	8	public list < hackresult > grok ( reader reader ) throws ioexception { long t0 = system . currenttimemillis ( ) ; _hackcontainer o = new _hackcontainer ( ) ; type t = new typetoken < _hackcontainer > ( ) { } . gettype ( ) ; o = gson . fromjson ( reader , t ) ; if ( o == null ) throw new ioexception ( "gson returned null!" ) ; l . info ( "claimed size=" + o . total_rows ) ; if ( o . total_rows == 0 ) throw new ioexception ( "gson did not find objects!" ) ; list < hackresult > res = new arraylist < hackresult > ( o . total_rows ) ; int total = 0 ; int count = 0 ; int cangetultracount = 0 ; for ( _hackrow r : o . rows ) { ++ count ; hackresult h = r . doc ; h . sourceline = count ; if ( h . resos == null || h . hacker == null ) { l . warn ( "skipping item " + count + " no resonators attached. id=" + h . _id ) ; continue ; } if ( l . istraceenabled ( ) ) l . trace ( string . format ( "  %5d %s\n" , count , h ) ) ; if ( h . hascangetultra ( ) ) cangetultracount ++ ; total += h . getitemcount ( ) ; res . add ( h ) ; } long t1 = system . currenttimemillis ( ) ; l . info ( "*** " + res . size ( ) + " hacks for " + total + " items  cangetultracount=" + cangetultracount + "  lengthcheck=" + ( res . size ( ) != o . total_rows ? "warning" : "ok" ) + " dt=" + ( t1 - t0 ) + " ms" ) ; return res ; }
tr	9	public void run ( ) { try { this . heartbeatthread . start ( ) ; arraylist < keyvaluepair < key1 , value1 >> inputlist = new arraylist < keyvaluepair < key1 , value1 >> ( ) ; for ( string path : localinputpaths ) { fileinputstream fis = new fileinputstream ( path ) ; objectinputstream ois = new objectinputstream ( fis ) ; arraylist < keyvaluepair < key1 , value1 >> sublist = ( arraylist < keyvaluepair < key1 , value1 >> ) ois . readobject ( ) ; ois . close ( ) ; inputlist . addall ( sublist ) ; } collections . sort ( inputlist ) ; reducer < key1 , value1 , key2 , value2 > r = reducerclass . newinstance ( ) ; logger . log ( outputlocalpath ) ; context < key2 , value2 > context = new context < key2 , value2 > ( outputlocalpath ) ; key1 previouskey = null ; arraylist < value1 > valuelist = null ; for ( keyvaluepair < key1 , value1 > p : inputlist ) { if ( previouskey == null || ! previouskey . equals ( p . key ) ) { if ( valuelist != null ) r . reduce ( previouskey , valuelist , context ) ; valuelist = new arraylist < value1 > ( ) ; valuelist . add ( p . value ) ; previouskey = p . key ; } else valuelist . add ( p . value ) ; } if ( valuelist != null && previouskey != null ) r . reduce ( previouskey , valuelist , context ) ; context . dumptofile ( ) ; this . % = 100 ; } catch ( instantiationexception | illegalaccessexception e ) { logger . log ( e . getmessage ( ) ) ; e . printstacktrace ( ) ; } catch ( exception ex ) { logger . log ( "2" + ex . getmessage ( ) ) ; } }
tr	6	@ override public byte [ ] tobytes ( object value ) { string string = ( string ) value ; string = normalizer . normalize ( string , normalizer . form . nfc ) ; if ( ! casesensitive ) { string = string . tolowercase ( locale ) ; } byte [ ] bytes = encoders . get ( byteencodemode ) . tobytes ( string , locale ) ; for ( int i = 0 ; i <= bytes . length - 4 ; i ++ ) { if ( bytes [ i ] == 0 && bytes [ i + 1 ] == 0 && bytes [ i + 2 ] == 0 && bytes [ i + 3 ] == 0 ) { throw new runtimeexception ( "encoded string value contains the end-of-field marker (zero byte)." ) ; } } return bytes ; }
tr	4	public boolean autochecksibmessage ( string xml , string id [ ] , string ref [ ] ) { hashtable hashtable = sibxmlmessageparser ( xml , id ) ; if ( hashtable == null ) return false ; if ( hashtable . size ( ) < id . length ) return false ; for ( int i = 0 ; i < hashtable . size ( ) ; i ++ ) if ( ! ref [ i ] . equals ( ( string ) hashtable . get ( id [ i ] ) ) ) return false ; return true ; }
tr	8	public arraylist < arraylist < state >> printtrace ( string string , arraylist < automaton > dista ) { string actions [ ] = string . split ( " " ) ; arraylist < arraylist < state >> states ; for ( arraylist < state > state : startstates ) { states = new arraylist < arraylist < state >> ( ) ; arraylist < state > searchstate = state ; states . add ( searchstate ) ; for ( string action : actions ) { boolean matchfound = false ; if ( adjlist != null ) { set < edgeofzonegraph > edges = adjlist . get ( searchstate ) ; if ( edges != null ) { iterator < edgeofzonegraph > it = edges . iterator ( ) ; while ( it . hasnext ( ) ) { edgeofzonegraph edge = ( edgeofzonegraph ) it . next ( ) ; if ( edge . getaction ( ) . equals ( action ) ) { states . add ( edge . getendstate ( ) ) ; searchstate = edge . getendstate ( ) ; matchfound = true ; break ; } } } } if ( ! matchfound ) { return null ; } } if ( isfinal ( states . get ( states . size ( ) - 1 ) , dista ) ) { return states ; } } return null ; }
tr	1	private void listsolicitudesmouseclicked ( java . awt . event . mouseevent evt ) { int no ; no = listsolicitudes . getselectedindex ( ) ; int reply = joptionpane . showconfirmdialog ( null , "desea agregara a " + listas . get ( no - 1 ) . nombre + "(" + listas . get ( no - 1 ) . usuario + ")" , "solicitud de amistad" , joptionpane . yes_no_option ) ; string resp = "<solicitud_amistad>\n" ; if ( reply == joptionpane . yes_option ) { resp += "<respuesta> si </respuesta>\n" ; } else { resp += "<respuesta> no </respuesta>\n" ; } usuario usuario = servidor . getusuario ( txtuser . gettext ( ) ) ; resp += "<destinatario>" + listas . get ( no - 1 ) . usuario + "</destinatario>\n" + "<emisor>\n" + "<usuario>" + txtuser . gettext ( ) + "</usuario>\n" + "<nombre> " + usuario . getnombre ( ) + " </nombre>\n" + "</emisor>\n" + "</solicitud_amistad>" ; listas . remove ( no - 1 ) ; listsolicitudes . updateui ( ) ; servidor . actualizarsolicitudes2 ( listas , usuario . getusername ( ) ) ; writeutf ( resp ) ; listsolicitudes . repaint ( ) ; system . err . println ( resp ) ; }
tr	0	@ test public void testfilter ( ) { assertequals ( 0 , $ . filter ( "asdf" ) . size ( ) ) ; assertequals ( 1 , $ . filter ( "document" ) . size ( ) ) ; assertequals ( 3 , $ . find ( ) . filter ( "actor" ) . size ( ) ) ; assertequals ( 3 , $ . find ( ) . filter ( "actor" ) . filter ( joox . all ( ) ) . size ( ) ) ; assertequals ( 2 , $ . find ( ) . filter ( "actor" ) . filter ( joox . even ( ) ) . size ( ) ) ; assertequals ( 1 , $ . find ( ) . filter ( "actor" ) . filter ( joox . odd ( ) ) . size ( ) ) ; }
tr	9	public card [ ] pickcards ( selectcardoptions sco , card [ ] allcards ) { gamequery p = new gamequery ( querytype . getcard , querytype . card ) . setobject ( sco ) ; p = query ( p ) ; if ( p == null ) return null ; if ( p . t != querytype . card ) return null ; if ( p . o instanceof card [ ] || p . o instanceof string [ ] ) { string [ ] selected ; if ( p . o instanceof card [ ] ) { arraylist < string > a = new arraylist < string > ( ) ; for ( card c : ( card [ ] ) p . o ) a . add ( c . getname ( ) ) ; selected = a . toarray ( new string [ 0 ] ) ; } else selected = ( string [ ] ) p . o ; arraylist < card > ret = new arraylist < card > ( ) ; arraylist < card > all = new arraylist < card > ( arrays . aslist ( allcards ) ) ; for ( int i = 0 ; i < selected . length ; i ++ ) { for ( int j = 0 ; j < all . size ( ) ; j ++ ) { if ( all . get ( j ) . equals ( selected [ i ] ) ) { ret . add ( all . get ( j ) ) ; all . remove ( j ) ; break ; } } } return ret . toarray ( new card [ 0 ] ) ; } return null ; }
tr	3	public string [ ] adjudicate ( final int linenumber , final string orig , final string [ ] hdr , final string [ ] flds ) { final int n = hdr . length ; string [ ] res = new string [ n ] ; for ( int i = 0 ; ( i < flds . length ) && ( i < n ) ; ++ i ) { res [ i ] = flds [ i ] ; } for ( int i = flds . length ; i < n ; ++ i ) { res [ i ] = "" ; } return res ; }
tr	5	private long checkclienttimeouts ( int timeout ) { set < integer > disconnectedclientids = new hashset < integer > ( ) ; long oldestclientcommunicationtime = - 1 ; synchronized ( connection_lock ) { if ( ! isrunning ) return - 1 ; long now = system . currenttimemillis ( ) ; oldestclientcommunicationtime = now ; for ( iterator < integer > iter = clients . keyset ( ) . iterator ( ) ; iter . hasnext ( ) ; ) { int clientid = iter . next ( ) ; clientinfo client = clients . get ( clientid ) ; if ( client . gettimeoflastcommunication ( ) + timeout <= now ) { iter . remove ( ) ; disconnectedclientids . add ( clientid ) ; } else if ( client . gettimeoflastcommunication ( ) < oldestclientcommunicationtime ) oldestclientcommunicationtime = client . gettimeoflastcommunication ( ) ; } } for ( int clientid : disconnectedclientids ) { logger . fine ( "client " + clientid + " timed out" ) ; onclientdisconnected ( clientid , server . client_timed_out ) ; } return oldestclientcommunicationtime ; }
tr	3	private void addmountansides ( ) { for ( int i = 0 ; i < map . length - 2 ; i ++ ) { for ( int j = 0 ; j < map [ 0 ] . length - 2 ; j ++ ) { if ( map [ i ] [ j ] . existtileoftype ( new mountains ( ) ) ) { map [ i ] [ j + 1 ] . add ( new mountainside ( ) ) ; map [ i ] [ j + 2 ] . add ( new mountainside ( ) ) ; } } } }
tr	9	public paymentdialog ( member member , classtype ct , string message , int flag ) { messagetextarea . settext ( message ) ; globalmember = member ; globalclasstype = ct ; globalflag = flag ; makepaymentbutton = new jbutton ( "make payment" ) ; makepaymentbutton . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent arg0 ) { common . makepayment ( paymenttypelist . getselectedvalue ( ) , globalmember , ( date ) utildatemodel . getvalue ( ) , getpaymentamount ( ) ) ; updatepaymentstatus ( globalmember , globalclasstype ) ; dispose ( ) ; new paymentdialog ( globalmember , globalclasstype , "payment made for " + globalmember . getname ( ) + "\n of " + getpaymentamount ( ) + " for " + paymenttypelist . getselectedvalue ( ) . getpaymenttypename ( ) + "\n up to date: " + ( ( date ) utildatemodel . getvalue ( ) ) . tostring ( ) , globalflag ) ; } } ) ; makepaymentbutton . setenabled ( false ) ; exitbutton = new jbutton ( "exit" ) ; exitbutton . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent e ) { dispose ( ) ; if ( globalflag == 0 ) new membercheckininterface ( globalclasstype ) ; } } ) ; bufferedimage tkdicon = commonui . gettkdicon ( ) ; bufferedimage skyicon = commonui . getskyicon ( ) ; bufferedimage kickicon = commonui . getkickicon ( ) ; image img = null ; switch ( ct ) { case taekwondo : img = new imageicon ( tkdicon ) . getimage ( ) ; break ; case skyboxing : img = new imageicon ( skyicon ) . getimage ( ) ; break ; case kickboxing : img = new imageicon ( kickicon ) . getimage ( ) ; break ; case other : img = new imageicon ( tkdicon ) . getimage ( ) ; default : img = new imageicon ( tkdicon ) . getimage ( ) ; } seticonimage ( img ) ; this . settitle ( "enter payment for " + member . getname ( ) ) ; utildatemodel . addchangelistener ( new changelistener ( ) { @ override public void statechanged ( changeevent arg0 ) { system . out . println ( "datemodel changed" ) ; setdateselected ( ) ; if ( paymentamountselected && dateselected ) { makepaymentbutton . setenabled ( true ) ; } } } ) ; panel . add ( paymenttopanel , borderlayout . center ) ; paymenttypelist . setlistdata ( common . getpaymenttypes ( ct ) . toarray ( new paymenttype [ 1 ] ) ) ; paymenttypelist . addlistselectionlistener ( new listselectionlistener ( ) { @ override public void valuechanged ( listselectionevent arg0 ) { jlist < paymenttype > templist = ( jlist < paymenttype > ) arg0 . getsource ( ) ; paymenttype pt = templist . getselectedvalue ( ) ; paymentamounttextfield . settext ( string . format ( "%9.2f" , pt . getpaymentamount ( ) ) ) ; setpaymentamountfieldselected ( ) ; if ( paymentamountselected && dateselected ) { makepaymentbutton . setenabled ( true ) ; } } } ) ; listpanel . add ( paymenttypelist ) ; panel . add ( listpanel , borderlayout . west ) ; paymentamountpanel . add ( paymentamountlabel ) ; paymentamountpanel . add ( paymentamounttextfield ) ; buttonpanel . add ( paymentamountpanel , borderlayout . north ) ; buttonpanel . add ( makepaymentbutton , borderlayout . west ) ; buttonpanel . add ( exitbutton , borderlayout . south ) ; panel . add ( buttonpanel , borderlayout . south ) ; paymentstatuspanel . add ( paymentstatustextarea , borderlayout . north ) ; paymentstatuspanel . add ( messagetextarea , borderlayout . south ) ; updatepaymentstatus ( member , ct ) ; panel . add ( paymentstatuspanel , borderlayout . east ) ; this . getcontentpane ( ) . add ( panel ) ; this . setsize ( commonui . fullscreen ) ; this . setvisible ( true ) ; }
va	0	public void makeframenotactive ( final callframe frametohold ) { java . awt . eventqueue . invokelater ( new runnable ( ) { public void run ( ) { resumebutton = new jbutton ( "\u0412\u043e\u0437\u043e\u0431\u043d\u043e\u0432\u0438\u0442\u044c \u0437\u0432\u043e\u043d\u043e\u043a" ) ; resumebutton . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent ev ) { string numbertounhold = parkbridgelines . get ( frametohold ) . get ( "numbertounhold" ) ; string holdchannel = parkbridgelines . get ( frametohold ) . get ( "holdchannel" ) ; frametohold . holdifnotactive ( ) ; resume ( numbertounhold , holdchannel . substring ( 0 , holdchannel . indexof ( "-" ) ) ) ; } } ) ; resumebutton . setpreferredsize ( new dimension ( 300 , 130 ) ) ; resumebutton . setbackground ( new color ( 0 , 25 , 0 ) ) ; resumebutton . setforeground ( new color ( 255 , 255 , 255 ) ) ; resumebutton . setfont ( new font ( "timesroman" , font . plain , 35 ) ) ; frametohold . add ( resumebutton , borderlayout . north ) ; frametohold . setpreferredsize ( new dimension ( 400 , 400 ) ) ; frametohold . pack ( ) ; } } ) ; }
va	4	public static fastfilter tag ( final string tagname , final boolean ignorenamespace ) { if ( tagname == null || tagname . equals ( "" ) ) { return none ( ) ; } else if ( "*" . equals ( tagname ) ) { return all ( ) ; } else { return new fastfilter ( ) { @ override public boolean filter ( context context ) { string localname = context . element ( ) . gettagname ( ) ; if ( ignorenamespace ) { localname = util . stripnamespace ( localname ) ; } return tagname . equals ( localname ) ; } } ; } }
va	4	private arraylist < string > removestopwords ( arraylist < string > textsnippets ) { string regex = "" , regexcaps = "" ; arraylist < string > rem ; string path = system . getproperty ( "user.dir" ) ; file f = new file ( path , settings . get ( "stopword_list_path_search" ) ) ; try { bufferedreader br = new bufferedreader ( new filereader ( f ) ) ; string line = "" ; line = br . readline ( ) ; while ( line != null ) { regexcaps = line . substring ( 0 , 1 ) . touppercase ( ) + line . substring ( 1 ) ; regex = " " + line + " | " + regexcaps + " " ; rem = new arraylist < string > ( ) ; for ( string temp : textsnippets ) { temp = " " + temp + " " ; temp = temp . replaceall ( regex , " " ) ; rem . add ( temp . trim ( ) ) ; } textsnippets = rem ; line = br . readline ( ) ; } br . close ( ) ; } catch ( filenotfoundexception e ) { applicationhelper . printerror ( stop_words_file_error ) ; } catch ( ioexception e ) { applicationhelper . printerror ( stop_words_file_error ) ; } return textsnippets ; }
va	8	public static void main ( string args [ ] ) throws exception { if ( ( args . length < 2 ) || ( args . length > 3 ) ) throw new illegalargumentexception ( "\u53c2\u6570\u4e0d\u6b63\u786e" ) ; string server = args [ 0 ] ; byte [ ] argument = args [ 1 ] . getbytes ( ) ; int servport = ( args . length == 3 ) ? integer . parseint ( args [ 2 ] ) : 7 ; socketchannel clntchan = socketchannel . open ( ) ; clntchan . configureblocking ( false ) ; if ( ! clntchan . connect ( new inetsocketaddress ( server , servport ) ) ) { while ( ! clntchan . finishconnect ( ) ) { system . out . print ( "." ) ; } } system . out . print ( "\n" ) ; bytebuffer writebuf = bytebuffer . wrap ( argument ) ; bytebuffer readbuf = bytebuffer . allocate ( argument . length ) ; int totalbytesrcvd = 0 ; int bytesrcvd ; while ( totalbytesrcvd < argument . length ) { if ( writebuf . hasremaining ( ) ) { clntchan . write ( writebuf ) ; } if ( ( bytesrcvd = clntchan . read ( readbuf ) ) == - 1 ) { throw new socketexception ( "connection closed prematurely" ) ; } totalbytesrcvd += bytesrcvd ; system . out . print ( "." ) ; } system . out . println ( "received: " + new string ( readbuf . array ( ) , 0 , totalbytesrcvd ) ) ; clntchan . close ( ) ; }
va	6	private static int outcode ( double px , double py , double rectx , double recty , double rectwidth , double rectheight ) { int out = 0 ; if ( rectwidth <= 0 ) { out |= out_left | out_right ; } else if ( px < rectx ) { out |= out_left ; } else if ( px > rectx + rectwidth ) { out |= out_right ; } if ( rectheight <= 0 ) { out |= out_top | out_bottom ; } else if ( py < recty ) { out |= out_top ; } else if ( py > recty + rectheight ) { out |= out_bottom ; } return out ; }
va	5	public void setup ( ) { setup = true ; if ( recordreplay ) replay = new gamereplay ( players , board ) ; playersalivecount = players . length ; player [ ] starters = players . clone ( ) ; int [ ] startpositions = board . getstartpositions ( starters . length ) ; if ( scramblestartpositions ) { for ( int i = 0 ; i < startpositions . length ; i ++ ) { int randomindex = random . nextint ( startpositions . length ) ; int tmp = startpositions [ i ] ; startpositions [ i ] = startpositions [ randomindex ] ; startpositions [ randomindex ] = tmp ; } } for ( int i = 0 ; i < players . length ; i ++ ) { players [ i ] . setalive ( true ) ; players [ i ] . setnumber ( i ) ; players [ i ] . reset ( ) ; int start = startpositions [ i ] ; board . placeplayerwall ( board . postox ( start ) , board . postoy ( start ) , players [ i ] ) ; } if ( recordreplay ) replay . setstartpositions ( startpositions ) ; thread = new thread ( ) { @ override public void run ( ) { rungame ( ) ; } } ; }
va	3	private void initapplicationhome ( ) { string applicationhome = system . getproperty ( "application.home" ) ; if ( applicationhome != null ) { return ; } file bootstrapjar = new file ( system . getproperty ( "user.dir" ) , "bootstrap.jar" ) ; if ( bootstrapjar . exists ( ) ) { try { file parentdir = new file ( system . getproperty ( "user.dir" ) , ".." ) ; system . setproperty ( "application.home" , parentdir . getcanonicalpath ( ) ) ; } catch ( exception e ) { system . setproperty ( "application.home" , system . getproperty ( "user.dir" ) ) ; } } else { system . setproperty ( "application.home" , system . getproperty ( "user.dir" ) ) ; } applicationhome = system . getproperty ( "application.home" ) ; }
va	5	@ override public void run ( ) { while ( beatwork ) { heartrate = messageresource . gethr ( ) ; if ( heartrate != 0 ) { int sleep = 1000 / heartrate ; try { thread . sleep ( 40 * sleep ) ; } catch ( interruptedexception ex ) { logger . getlogger ( main . class . getname ( ) ) . log ( level . severe , null , ex ) ; } beat ( 1 ) ; try { thread . sleep ( 20 * sleep ) ; } catch ( interruptedexception ex ) { logger . getlogger ( main . class . getname ( ) ) . log ( level . severe , null , ex ) ; } beat ( 0 ) ; } else { try { thread . sleep ( 2000 ) ; } catch ( interruptedexception ex ) { logger . getlogger ( main . class . getname ( ) ) . log ( level . severe , null , ex ) ; } } } }
va	2	public static void main ( string [ ] args ) { hashmap < string , string > hashmap = new hashmap < string , string > ( 4 ) ; hashmap . put ( "andhrapradesh" , "hyderabad" ) ; hashmap . put ( "uttarpradesh" , "allahabad" ) ; hashmap . put ( "karnataka" , "benguluru" ) ; set < string > s = hashmap . keyset ( ) ; iterator < string > it = s . iterator ( ) ; while ( it . hasnext ( ) ) { system . out . println ( it . next ( ) . tostring ( ) ) ; } hashmap . put ( "tamilnadu" , "chennai" ) ; hashmap . put ( "maharastra" , "mumbai" ) ; hashmap . put ( "gujarat" , "gandhinagar" ) ; hashmap . put ( "punjab" , "chandigarh" ) ; hashmap . put ( "kerala" , "trivendram" ) ; system . out . println ( "after table doubling" ) ; set < string > s1 = hashmap . keyset ( ) ; iterator < string > it1 = s . iterator ( ) ; while ( it1 . hasnext ( ) ) { system . out . println ( it1 . next ( ) . tostring ( ) ) ; } }
va	8	public void actionperformed ( actionevent arg0 ) { if ( arg0 . getactioncommand ( ) . equals ( "tower" ) ) clickstate = clickstate . tower ; else if ( arg0 . getactioncommand ( ) . equals ( "swamp" ) ) clickstate = clickstate . swamp ; else if ( arg0 . getactioncommand ( ) . equals ( "elfrune" ) ) clickstate = clickstate . elf ; else if ( arg0 . getactioncommand ( ) . equals ( "manrune" ) ) { clickstate = clickstate . man ; } else if ( arg0 . getactioncommand ( ) . equals ( "dwarfrune" ) ) clickstate = clickstate . dwarf ; else if ( arg0 . getactioncommand ( ) . equals ( "hobbitrune" ) ) clickstate = clickstate . hobbit ; else if ( arg0 . getactioncommand ( ) . equals ( "reloadrune" ) ) clickstate = clickstate . reload ; else if ( arg0 . getactioncommand ( ) . equals ( "rangerune" ) ) clickstate = clickstate . range ; }
va	5	private void labelvertex ( segment segment , long crossproduct , path path ) { if ( crossproduct > 0 ) { if ( path . isinverted ) segment . end . type = vertex . outie ; else segment . end . type = vertex . innie ; } else if ( crossproduct < 0 ) { if ( path . isinverted ) segment . end . type = vertex . innie ; else segment . end . type = vertex . outie ; } else if ( segment . start . type != vertex . not_set ) segment . end . type = segment . start . type ; else segment . end . type = vertex . innie ; }
va	5	public boolean switchproposal ( boolean forward ) { if ( forward ) { this . mycurrentproposalrr = bootstraprrlist . getinstance ( ) . getnextrr ( ) ; } else { this . mycurrentproposalrr = bootstraprrlist . getinstance ( ) . getpreviousrr ( ) ; } if ( this . mycurrentproposalrr == null ) { return false ; } string i1 = integer . tobinarystring ( this . mycurrentproposalrr . getbinarycounter ( ) ) ; while ( i1 . length ( ) < this . getbinarycountersize ( ) ) { i1 = "0" + i1 ; } for ( int i = 0 ; i < this . getbinarycountersize ( ) ; i ++ ) { boolean propose = i1 . charat ( i ) == 1 ? true : false ; policy . getinstance ( ) . getdatacolumnbyindex ( i ) . setispropose ( propose ) ; } return true ; }
va	7	public static bufferedimage getimage ( card card ) { int rownumber ; int colnumber ; if ( card . getsuit ( ) . equals ( suit . clubs ) ) { rownumber = 0 ; } else if ( card . getsuit ( ) . equals ( suit . diamonds ) ) { rownumber = 1 ; } else if ( card . getsuit ( ) . equals ( suit . hearts ) ) { rownumber = 2 ; } else if ( card . getsuit ( ) . equals ( suit . spades ) ) { rownumber = 3 ; } else { rownumber = 4 ; } if ( card . getcardvalue ( ) . equals ( cardvalue . ace ) ) { colnumber = 0 ; } else if ( card . getcardvalue ( ) . equals ( cardvalue . joker ) ) { if ( card . getsuit ( ) . equals ( suit . black ) ) { colnumber = 0 ; } else { colnumber = 1 ; } } else { colnumber = card . getcardvalue ( ) . getvalue ( ) ; } return imagecard . getinstance ( ) . image . getsubimage ( colnumber * imagecard . getinstance ( ) . getcardwidth ( ) , rownumber * imagecard . getinstance ( ) . getcardheight ( ) , imagecard . getinstance ( ) . getcardwidth ( ) , imagecard . getinstance ( ) . getcardheight ( ) ) ; }
va	2	public arraylist listatodos ( ) { arraylist listacartao = new arraylist < > ( ) ; string sql = "select * from cartoes order by cartao_id" ; try { connection con = conectar . getinstance ( ) . conect ( ) ; preparar = con . preparestatement ( sql ) ; resultset resultado = preparar . executequery ( ) ; while ( resultado . next ( ) ) { listacartao . add ( new object [ ] { resultado . getlong ( "cartao_id" ) , resultado . getlong ( "saldo_cartao" ) } ) ; } preparar . close ( ) ; } catch ( sqlexception ex ) { joptionpane . showmessagedialog ( null , ex . getmessage ( ) ) ; } return listacartao ; }
va	3	private void setfield ( string propertyname , object value , object target ) throws illegalaccessexception { final class targetclass = target . getclass ( ) ; final field field = getfield ( targetclass , propertyname ) ; if ( null != field ) { if ( field . gettype ( ) . isassignablefrom ( value . getclass ( ) ) ) { field . setaccessible ( true ) ; field . set ( target , value ) ; } } else { log . debug ( "field '{}' does not exist on {}" , new object [ ] { propertyname , targetclass } ) ; if ( collection . class . isassignablefrom ( targetclass ) ) { log . debug ( "{} is a collection" , targetclass ) ; ( ( collection ) target ) . add ( value ) ; } else { log . debug ( "{} not is a collection" , targetclass ) ; } } }
va	3	public static void main ( string [ ] args ) throws ioexception { if ( args . length >= 2 ) { file indir = new file ( args [ 0 ] ) ; file outdir = new file ( args [ 1 ] ) ; if ( ! outdir . exists ( ) ) { outdir . mkdirs ( ) ; } file [ ] flist = indir . listfiles ( new filefilter ( ) { @ override public boolean accept ( file arg0 ) { return ( arg0 . getname ( ) . startswith ( "d-" ) && arg0 . getname ( ) . endswith ( ".txt.csv" ) ) ; } } ) ; utilities . recompose ( flist , outdir ) ; } }
va	9	static void doublequicksort ( double a [ ] , int index [ ] , int lo0 , int hi0 ) { int lo = lo0 ; int hi = hi0 ; double mid ; if ( hi0 > lo0 ) { mid = a [ ( lo0 + hi0 ) / 2 ] ; while ( lo <= hi ) { while ( ( lo < hi0 ) && ( a [ lo ] < mid ) ) { ++ lo ; } while ( ( hi > lo0 ) && ( a [ hi ] > mid ) ) { -- hi ; } if ( lo <= hi ) { swap ( a , index , lo , hi ) ; ++ lo ; -- hi ; } } if ( lo0 < hi ) { doublequicksort ( a , index , lo0 , hi ) ; } if ( lo < hi0 ) { doublequicksort ( a , index , lo , hi0 ) ; } } }
va	5	private void analyze ( ) { double minprice = double . positive_infinity ; for ( int i = 0 ; i < pricings . size ( ) ; i ++ ) { if ( pricings . get ( i ) . gettype ( ) . equalsignorecase ( "base" ) ) bases . add ( i ) ; else if ( pricings . get ( i ) . gettype ( ) . equalsignorecase ( "reward" ) ) rewards . add ( i ) ; else penalties . add ( i ) ; if ( minprice > pricings . get ( i ) . getcurrentprice ( ) ) { minprice = pricings . get ( i ) . getcurrentprice ( ) ; indexofcheapest . clear ( ) ; indexofcheapest . add ( i ) ; } else if ( minprice == pricings . get ( i ) . getcurrentprice ( ) ) { indexofcheapest . add ( i ) ; } } }
va	3	public void displaywinner ( arraylist < javafestivalplayer > players , int pointswon ) { string names = players . get ( 0 ) . getname ( ) ; if ( players . size ( ) > 1 ) { for ( int i = 1 ; i < players . size ( ) ; i ++ ) { if ( i == ( players . size ( ) - 1 ) ) { names = names + " and " + players . get ( i ) . getname ( ) ; } else { names = names + "  " + players . get ( i ) . getname ( ) ; } } joptionpane . showmessagedialog ( null , "congrats! players " + names + " have won this festival" , "end of festival" , joptionpane . information_message ) ; } else { joptionpane . showmessagedialog ( null , "congrats! player " + names + " has won this festival" , "end of festival" , joptionpane . information_message ) ; } }
va	0	@ test public void testarea ( ) { point [ ] points = aconvex ; assertequals ( 78.5 , area ( points ) , eps ) ; points = makepoints ( "0 0  2 0  0 1" ) ; assertequals ( 1 , area ( points ) , eps ) ; points = makepoints ( "0 0  0 1  2 0" ) ; assertequals ( - 1 , area ( points ) , eps ) ; points = makepoints ( "0 0  2 0  2 0  2 2" ) ; assertequals ( 2 , area ( points ) , eps ) ; points = makepoints ( "100 100  102 100  102 100  102 102" ) ; assertequals ( 2 , area ( points ) , eps ) ; points = makepoints ( "0 0  1 0  2 0" ) ; assertequals ( 0 , area ( points ) , eps ) ; }
va	8	public boolean areanagramscount ( string a , string b ) { if ( a == null && b == null ) return false ; else if ( a == null || b == null ) return false ; else { int [ ] count = new int [ 256 ] ; char [ ] ac = a . tochararray ( ) ; for ( char c : ac ) { count [ c ] ++ ; } char [ ] bc = b . tochararray ( ) ; for ( char c : bc ) { count [ c ] -- ; } for ( int i : count ) { if ( i != 0 ) return false ; } } return true ; }
va	8	public void init ( ) { try { level . loadbehaviors ( new datainputstream ( resourcesmanager . class . getresourceasstream ( "res/tiles.dat" ) ) ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; system . exit ( 0 ) ; } if ( level == null ) if ( iscustom ) { mylevelgenerator clg = new mylevelgenerator ( ) ; gameplay gp = new gameplay ( ) ; gp = gp . read ( "player.txt" ) ; currentlevel = ( level ) clg . generatelevel ( gp ) ; string detailedinfo = filehandler . readfile ( "detailedinfo.txt" ) ; } else currentlevel = new randomlevel ( 320 , 15 , levelseed , leveldifficulty , leveltype ) ; try { level = currentlevel . clone ( ) ; } catch ( clonenotsupportedexception e ) { e . printstacktrace ( ) ; } art . startmusic ( 1 ) ; paused = false ; sprite . spritecontext = this ; sprites . clear ( ) ; layer = new levelrenderer ( level , graphicsconfiguration , 320 , 240 ) ; for ( int i = 0 ; i < 2 ; i ++ ) { int scrollspeed = 4 >> i ; int w = ( ( level . getwidth ( ) * 16 ) - 320 ) / scrollspeed + 320 ; int h = ( ( level . getheight ( ) * 16 ) - 240 ) / scrollspeed + 240 ; level bglevel = bglevelgenerator . createlevel ( w / 32 + 1 , h / 32 + 1 , i == 0 , leveltype ) ; bglayer [ i ] = new bgrenderer ( bglevel , graphicsconfiguration , 320 , 240 , scrollspeed ) ; } double oldx = 0 ; if ( mario != null ) oldx = mario . x ; mario = new mario ( this ) ; sprites . add ( mario ) ; starttime = 1 ; timeleft = 200 * 15 ; tick = 0 ; switchpoints = new arraylist < double > ( ) ; int squaresize = 16 ; int sections = 10 ; double startx = 32 ; double endx = level . getxexit ( ) * squaresize ; if ( ! iscustom && recorder == null ) recorder = new datarecorder ( this , ( randomlevel ) level , keys ) ; gamestarted = false ; }
va	4	public static void solve ( int k , int ct ) { int i , j ; if ( k < ct && k >= 0 ) { i = blan [ k ] / 9 ; j = blan [ k ] % 9 ; for ( int fill = 1 ; fill <= 9 ; fill ++ ) { if ( checkitnow ( i , j , fill ) ) { sudoku [ i ] [ j ] = fill ; solve ( ++ k , ct ) ; k -- ; } } sudoku [ i ] [ j ] = 0 ; } else { answer ++ ; printsudoku ( ) ; } }
va	0	public addrequestform ( int reqtype , string username , string addinfo ) { this . setmodal ( true ) ; initcomponents ( ) ; this . reqtype = reqtype ; addrequestbutton . settext ( "\u041f\u0440\u0438\u043c\u0435\u043d\u0438\u0442\u044c" ) ; requestnamefield . settext ( username ) ; requesttextarea . settext ( addinfo ) ; this . setfieldsifedit ( ) ; java . awt . dimension dim = gettoolkit ( ) . getscreensize ( ) ; this . setlocation ( dim . width / 2 - this . getwidth ( ) / 2 , dim . height / 2 - this . getheight ( ) / 2 ) ; requesttextarea . requestfocus ( ) ; requesttextarea . setlinewrap ( true ) ; dbw = new dbworker ( ) ; this . setfieldsifedit ( ) ; }
va	4	private map fitnesscalculations ( list < individual > individuals ) { map statistics = new hashmap ( ) ; double countfitness = 0 ; double maxfitness = 0.0 ; double minfitness = 10.0 ; for ( individual i : individuals ) { try { countfitness += i . fitness ( ) ; if ( i . fitness ( ) > maxfitness ) { maxfitness = i . fitness ( ) ; statistics . put ( "maxfitness" , maxfitness ) ; statistics . put ( "bestindividual" , i ) ; } if ( i . fitness ( ) < minfitness ) { minfitness = i . fitness ( ) ; statistics . put ( "minfitness" , minfitness ) ; } } catch ( exception e ) { e . printstacktrace ( ) ; } } statistics . put ( "avgfitness" , countfitness / individuals . size ( ) ) ; return statistics ; }
va	3	void initialize ( int d ) { this . matarray = new material [ this . getnumfaces ( ) ] [ this . getdimension ( ) + 2 ] [ this . getdimension ( ) + 2 ] ; this . tilestate = new int [ this . getnumfaces ( ) ] [ this . getdimension ( ) + 2 ] [ this . getdimension ( ) + 2 ] ; this . cleancolor = new material ( ) ; this . cleancolor . setambient ( 0.7 , 0.7 , 0.7 ) ; this . cleancolor . setdiffuse ( 0.8 , 0.8 , 0.8 ) ; this . cleancolor . setspecular ( 0.9 , 0.9 , 0.9 , 10 ) ; this . coveredcolor = new material ( ) ; this . coveredcolor . setambient ( 0.1 , 0.1 , 0.1 ) ; this . coveredcolor . setdiffuse ( 0.2 , 0.2 , 0.2 ) ; this . coveredcolor . setspecular ( .5 , .5 , .5 , 10 ) ; this . redcolor = new material ( ) ; this . redcolor . setambient ( 0.9 , 0.1 , 0.1 ) ; this . redcolor . setdiffuse ( 0.95 , 0.15 , 0.15 ) ; this . redcolor . setspecular ( .95 , .15 , .15 , 10 ) ; this . yellowcolor = new material ( ) ; this . yellowcolor . setambient ( 0.9 , 0.9 , 0.1 ) ; this . yellowcolor . setdiffuse ( 0.95 , 0.95 , 0.15 ) ; this . yellowcolor . setspecular ( .95 , .95 , .15 , 10 ) ; this . bluecolor = new material ( ) ; this . bluecolor . setambient ( 0.1 , 0.1 , 0.9 ) ; this . bluecolor . setdiffuse ( 0.15 , 0.15 , 0.95 ) ; this . bluecolor . setspecular ( .15 , .15 , .95 , 10 ) ; this . greencolor = new material ( ) ; this . greencolor . setambient ( 0.1 , 0.9 , 0.1 ) ; this . greencolor . setdiffuse ( 0.15 , 0.95 , 0.15 ) ; this . greencolor . setspecular ( .15 , .95 , .15 , 10 ) ; this . orangecolor = new material ( ) ; this . orangecolor . setambient ( 0.98 , 0.5 , 0.25 ) ; this . orangecolor . setdiffuse ( 0.99 , 0.52 , 0.27 ) ; this . orangecolor . setspecular ( .99 , .52 , .27 , 10 ) ; this . purplecolor = new material ( ) ; this . purplecolor . setambient ( 0.9 , 0.1 , 0.9 ) ; this . purplecolor . setdiffuse ( 0.95 , 0.15 , 0.95 ) ; this . purplecolor . setspecular ( .95 , .15 , .95 , 10 ) ; for ( int face = 0 ; face < this . getnumfaces ( ) ; face ++ ) { for ( int row = 1 ; row <= this . getdimension ( ) ; row ++ ) { for ( int column = 1 ; column <= this . getdimension ( ) ; column ++ ) { this . getface ( face ) [ row ] [ column ] . setmaterial ( this . coveredcolor ) ; this . tilestate [ face ] [ row ] [ column ] = 0 ; } } } }
va	5	public string tostring ( boolean printheaderrow , string additionalcolumnheader , string additionalcolumnvalue ) { final list < identifier > keys = new arraylist < identifier > ( variables . keyset ( ) ) ; collections . sort ( keys , new comparator < identifier > ( ) { @ override public int compare ( identifier o1 , identifier o2 ) { final int result = o1 . getvalue ( ) . compareto ( o2 . getvalue ( ) ) ; if ( o1 . getvalue ( ) . length ( ) < o2 . getvalue ( ) . length ( ) ) { return - 1 ; } return result ; } } ) ; final list < string > columns = new arraylist < > ( ) ; final list < string > values = new arraylist < > ( ) ; final list < integer > columnwidths = new arraylist < > ( ) ; for ( identifier id : keys ) { columns . add ( id . getvalue ( ) ) ; values . add ( variables . get ( id ) != null ? variables . get ( id ) . tostring ( true ) : null ) ; columnwidths . add ( width ( id . getvalue ( ) ) ) ; } final boolean hasadditionalcolumn = stringutils . isnotblank ( additionalcolumnheader ) ; if ( hasadditionalcolumn ) { columns . add ( additionalcolumnheader ) ; values . add ( additionalcolumnvalue ) ; columnwidths . add ( width ( additionalcolumnheader ) ) ; } stringbuilder buffer = new stringbuilder ( ) ; if ( printheaderrow ) { printheaderline ( buffer , columns , columnwidths , hasadditionalcolumn ) ; buffer . append ( "\n" ) ; } printseparatorline ( buffer , columns , columnwidths , hasadditionalcolumn ) ; buffer . append ( "\n" ) ; printvalues ( buffer , values , columnwidths , hasadditionalcolumn ) ; return buffer . tostring ( ) ; }
va	4	@ override public void mouseclicked ( mouseevent arg0 ) { if ( albumsscreen . editing ) { albumsscreen . editing = false ; albumsscreen . edit . seticon ( new imageicon ( "resources/editup.jpg" ) ) ; albumsscreen . edit . setpressedicon ( new imageicon ( "resources/editdn.jpg" ) ) ; for ( albuminfo panel : albumsscreen . albumpanels ) { panel . changename ( ) ; panel . showhidedeletebtn ( ) ; panel . allownameediting ( ) ; } } try { photoscreen = new photosscreen ( this . album , this . albumsscreen . control , this . albumsscreen . backend , this , this . albumsscreen ) ; photoscreen . setvisible ( true ) ; photoscreen . setlocationrelativeto ( null ) ; photoscreen . setresizable ( false ) ; this . albumsscreen . setvisible ( false ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } }
va	7	public void additem ( item item , int amount ) { system . out . println ( "added " + amount + " of " + item + " to " + owner ) ; if ( item . isstackable ( ) ) { for ( int i = 0 ; i < 30 ; i ++ ) { if ( objecttype [ i ] . id == item . id && objecttype [ i ] . subid == item . subid && objectnumber [ i ] < 999 ) { objectnumber [ i ] = objectnumber [ i ] + amount ; return ; } } } for ( int i = 0 ; i < size ; i ++ ) { if ( objecttype [ i ] . id == 0 ) { objecttype [ i ] = item ; objectnumber [ i ] = amount ; return ; } } system . out . println ( "warning  inventory is full" ) ; }
va	8	private void findcodelonedge ( codelarea area ) { directionpointer directionpointer = mmachine . getdirectionpointer ( ) ; codelchoser codelchoser = mmachine . getcodelchoser ( ) ; boolean isleft = codelchoser . isleft ( ) ; if ( directionpointer . isright ( ) ) { if ( isleft ) { medgecodel . set ( area . maxxminy ( ) ) ; } else { medgecodel . set ( area . maxxmaxy ( ) ) ; } } else if ( directionpointer . isbottom ( ) ) { if ( isleft ) { medgecodel . set ( area . maxymaxx ( ) ) ; } else { medgecodel . set ( area . maxyminx ( ) ) ; } } else if ( directionpointer . isleft ( ) ) { if ( isleft ) { medgecodel . set ( area . minxmaxy ( ) ) ; } else { medgecodel . set ( area . minxminy ( ) ) ; } } else if ( directionpointer . istop ( ) ) { if ( isleft ) { medgecodel . set ( area . minyminx ( ) ) ; } else { medgecodel . set ( area . minymaxx ( ) ) ; } } }
va	7	public static probabilitydistribution respond ( probabilitydistribution pd , pricingpolicy policy , pricingpolicy baseline , double awareness , double sensitivity , string responsetype ) { double w = 2 ; double [ ] previoushist = pd . gethistogram ( ) ; double [ ] newhist = new double [ constants . min_in_day ] ; double [ ] policyarr = policy . gettouarray ( ) ; double [ ] basearr = baseline . gettouarray ( ) ; switch ( responsetype ) { case "none" : return pd ; case "optimal" : newhist = shiftingoptimal ( previoushist , basearr , policyarr , w * awareness , w * sensitivity ) ; break ; case "normal" : newhist = shiftingnormal ( previoushist , basearr , policyarr , w * awareness , w * sensitivity ) ; break ; case "discrete" : newhist = shiftingdiscrete ( previoushist , basearr , policyarr , w * awareness , w * sensitivity ) ; break ; case "daily" : newhist = shiftingdaily ( previoushist , basearr , policyarr , awareness , sensitivity ) ; for ( int i = 0 ; i < newhist . length ; i ++ ) { if ( double . isnan ( newhist [ i ] ) ) { newhist [ i ] = 0.0 ; } } break ; default : return pd ; } probabilitydistribution retpd = new histogram ( newhist ) ; return retpd ; }
va	6	protected void sendrequest ( statesofclient state ) { resetstate ( ) ; setstate ( state ) ; pmfc . printwhichstateistesting ( ) ; try { if ( curl_http_port != 443 ) { client = vertx . createhttpclient ( ) . setport ( curl_http_port ) . sethost ( curl_http_host ) ; } else { client = vertx . createhttpclient ( ) . setssl ( true ) . settrustall ( true ) . setport ( curl_http_port ) . sethost ( curl_http_host ) ; } mcurlcommandssetter = mcurlcommandssetterfactory . createsetter ( getstate ( ) ) ; mcurlcommandssetter . execute ( state ) ; pmfc . printcurrentrequestandpathincurlcommand ( ) ; requestsendfromclienttoserver = client . request ( behaviorofcurlcommandssetter . currentrequest , behaviorofcurlcommandssetter . currentpath , new handler < httpclientresponse > ( ) { @ override public void handle ( httpclientresponse responserecievedatclientfromserver ) { statuscode = responserecievedatclientfromserver . statuscode ( ) ; responserecievedatclientfromserver . bodyhandler ( new handler < buffer > ( ) { @ override public void handle ( buffer body ) { try { try { pmfc . printmessagefromserver ( body ) ; currentserverresponseinjsonformat = new jsonobject ( body . tostring ( ) ) ; getdatafromdb ( ) ; } catch ( exception e ) { } massertionchecker = massertioncheckerfactory . createchecker ( getstate ( ) ) ; massertionchecker . execute ( getstate ( ) ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } finally { pmfc . printend ( ) ; testcomplete ( ) ; } } } ) ; } } ) . exceptionhandler ( new handler < throwable > ( ) { @ override public void handle ( throwable t ) { t . printstacktrace ( ) ; } } ) ; try { headerssetup ( ) ; jsonbodysetup ( ) ; } catch ( exception e ) { } } catch ( exception e ) { fail ( e . getmessage ( ) ) ; } finally { if ( client != null ) { client . close ( ) ; } } }
va	7	private void handleactioncomplete ( mqtttoken token ) throws mqttexception { final string methodname = "handleactioncomplete" ; synchronized ( token ) { log . fine ( classname , methodname , "705" , new object [ ] { token . internaltok . getkey ( ) } ) ; token . internaltok . notifycomplete ( ) ; if ( ! token . internaltok . isnotified ( ) ) { if ( mqttcallback != null && token instanceof mqttdeliverytoken && token . iscomplete ( ) ) { mqttcallback . deliverycomplete ( ( mqttdeliverytoken ) token ) ; } fireactionevent ( token ) ; } if ( token instanceof mqttdeliverytoken && token . iscomplete ( ) ) { token . internaltok . setnotified ( true ) ; } if ( token . iscomplete ( ) ) { clientstate . notifycomplete ( token ) ; } } }
va	1	public void setfractparam ( fractparam p ) { picwidth . settext ( integer . tostring ( p . picwidth ) ) ; picheight . settext ( integer . tostring ( p . picheight ) ) ; centercx . settext ( double . tostring ( p . centercx ) ) ; centercy . settext ( double . tostring ( p . centercy ) ) ; diametercx . settext ( double . tostring ( p . diametercx ) ) ; functioncb . setselecteditem ( p . iterfunc ) ; if ( p . iterfunc == fractfunctions . julia ) { juliakrfield . settext ( double . tostring ( p . juliakr ) ) ; juliakifield . settext ( double . tostring ( p . juliaki ) ) ; juliakrfield . setenabled ( true ) ; juliakifield . setenabled ( true ) ; } else { juliakrfield . settext ( "0" ) ; juliakifield . settext ( "0" ) ; juliakrfield . setenabled ( false ) ; juliakifield . setenabled ( false ) ; } maxiters . settext ( integer . tostring ( p . maxiterations ) ) ; colorpresetscombo . setselecteditem ( appmanager . getinstance ( ) . getpresets ( ) . getcolorpresetbyname ( p . colorpreset ) ) ; chckbxsmoothcolors . setselected ( p . smoothcolors ) ; paletterepeat . settext ( integer . tostring ( p . colorpresetrepeat ) ) ; }
va	9	public void getmodulus ( float [ ] realio ) { int i , j , k , ir , j0 = 1 , idx = fft_n_log - 1 ; float cosv , sinv , tmpr , tmpi ; for ( i = 0 ; i != fft_n ; i ++ ) { real [ i ] = realio [ bitreverse [ i ] ] ; imag [ i ] = 0 ; } for ( i = fft_n_log ; i != 0 ; i -- ) { for ( j = 0 ; j != j0 ; j ++ ) { cosv = costable [ j << idx ] ; sinv = sintable [ j << idx ] ; for ( k = j ; k < fft_n ; k += j0 << 1 ) { ir = k + j0 ; tmpr = cosv * real [ ir ] - sinv * imag [ ir ] ; tmpi = cosv * imag [ ir ] + sinv * real [ ir ] ; real [ ir ] = real [ k ] - tmpr ; imag [ ir ] = imag [ k ] - tmpi ; real [ k ] += tmpr ; imag [ k ] += tmpi ; } } j0 <<= 1 ; idx -- ; } j = fft_n >> 1 ; sinv = miny ; cosv = - miny ; for ( i = j ; i != 0 ; i -- ) { tmpr = real [ i ] ; tmpi = imag [ i ] ; if ( tmpr > cosv && tmpr < sinv && tmpi > cosv && tmpi < sinv ) realio [ i - 1 ] = 0 ; else realio [ i - 1 ] = tmpr * tmpr + tmpi * tmpi ; } }
va	5	public int [ ] compute ( int source ) { zippedarray arr = zippedarray . arraywithdefaultvalue ( 1000 ) ; int n = graph . getverticescount ( ) ; arr . set ( 0 , 0 , source ) ; for ( int i = 1 ; i < n ; i ++ ) { for ( int v = 0 ; v < n ; v ++ ) { int oldvalue = ( integer ) arr . get ( i - 1 , v ) ; int minvalue = integer . max_value ; list < edge > edges = graph . getedgesto ( v ) ; for ( edge edge : edges ) { int x = edge . getx ( ) ; int w = edge . getweight ( ) ; int t = ( integer ) arr . get ( i - 1 , x ) + w ; if ( t < minvalue ) minvalue = t ; } arr . set ( math . min ( oldvalue , minvalue ) , i , v ) ; } } int [ ] result = new int [ graph . getverticescount ( ) ] ; for ( int i = 0 ; i < graph . getverticescount ( ) ; i ++ ) { result [ i ] = ( integer ) arr . get ( n - 1 , i ) ; } return result ; }
va	5	public static object evaluate ( string expression , object root , boolean trimroottoken ) throws exception { if ( trimroottoken ) { expression = expression . substring ( expression . indexof ( . ) + 1 ) ; } object value = root ; stringtokenizer parser = new stringtokenizer ( expression , "." ) ; while ( parser . hasmoretokens ( ) ) { string token = parser . nexttoken ( ) ; if ( value == null ) { return null ; } classmap classmap = getclassmap ( value . getclass ( ) ) ; string methodbase = stringutils . capitalizefirstletter ( token ) ; string methodname = "get" + methodbase ; method method = classmap . findmethod ( methodname , class_args ) ; if ( method == null ) { methodname = "is" + methodbase ; method = classmap . findmethod ( methodname , class_args ) ; } if ( method == null ) { return null ; } value = method . invoke ( value , object_args ) ; } return value ; }
va	3	@ override protected void generatexml ( bufferedwriter out ) throws ioexception { for ( int i = 0 ; i < this . answers . size ( ) ; i ++ ) { out . write ( "\t\t<choice" ) ; if ( i == this . correctanswer ) out . write ( " correct=\"true\"" ) ; if ( i == this . selectedanswer ) out . write ( " selected=\"true\"" ) ; out . write ( ">" ) ; out . write ( this . answers . get ( i ) ) ; out . write ( "</choice>\n" ) ; out . flush ( ) ; } }
va	0	@ test public void test_delete_all_sources ( ) { final sourcetablemodel model = new sourcetablemodel ( new string [ ] { "a" , "b" , "c" } ) ; model . addrow ( new sourcemodel ( 0 , "tt" , "2012" ) ) ; model . addrow ( new sourcemodel ( 1 , "tt" , "2012" ) ) ; model . addrow ( new sourcemodel ( 2 , "tt" , "2012" ) ) ; model . addtablemodellistener ( new tablemodellistener ( ) { @ override public void tablechanged ( tablemodelevent e ) { assertequals ( 0 , e . getfirstrow ( ) ) ; assertequals ( 3 , e . getlastrow ( ) ) ; assertequals ( 0 , model . getrowcount ( ) ) ; } } ) ; model . clearsources ( ) ; }
va	2	private void exechooserbuttonactionperformed ( java . awt . event . actionevent evt ) { jfilechooser chooser = new jfilechooser ( "d:\\" ) ; chooser . showopendialog ( this ) ; chooser . setfileselectionmode ( jfilechooser . files_only ) ; filefilter filter1 = new filenameextensionfilter ( "exe" , new string ( "exe" ) ) ; chooser . addchoosablefilefilter ( filter1 ) ; file = chooser . getselectedfile ( ) ; if ( file != null && file . exists ( ) ) { string filepath = file . getabsolutepath ( ) ; exetextfield . settext ( file . getabsolutepath ( ) ) ; appvariables . code_generator_exe = filepath ; this . dispose ( ) ; } }
va	2	@ override public gamestate clone ( ) { try { gamestate state = ( gamestate ) super . clone ( ) ; state . bonusmap = new hashmap < mappingfield , bonustype > ( bonusmap ) ; state . playablemap = new hashmap < playable , playablestate > ( playablemap . size ( ) ) ; for ( map . entry < playable , playablestate > e : playablemap . entryset ( ) ) { state . playablemap . put ( e . getkey ( ) , e . getvalue ( ) . clone ( ) ) ; } return state ; } catch ( clonenotsupportedexception e ) { throw new internalerror ( e . tostring ( ) ) ; } }
va	3	public void setcellscoresmatrix ( ) { int r , c , sc ; char cs1 , cs2 ; scoredcellelement tmpcell ; for ( r = 0 ; r < m_s1_size ; ++ r ) { for ( c = 0 ; c < m_s1_size ; ++ c ) { cs1 = m_s1 . charat ( c ) ; cs2 = m_s1 . charat ( r ) ; tmpcell = ( scoredcellelement ) m_dptable . getcell ( c + 1 , r + 1 ) ; if ( r < c + 2 ) { tmpcell . setscoreval ( m_scorehash . getscore ( cs1 , cs2 ) ) ; } else { tmpcell . setcolor ( color . black ) ; } } } }
va	8	private void runbuttonactionperformed ( java . awt . event . actionevent evt ) throws ioexception { if ( runbutton . gettext ( ) . equals ( "run" ) ) { threadswitch . setenabled ( false ) ; debugswitch . setenabled ( false ) ; simrunswitch . setenabled ( false ) ; ignoreswitch . setenabled ( false ) ; forceswitch . setenabled ( false ) ; writetodbswitch . setenabled ( false ) ; threadcombobox . setenabled ( false ) ; debugcombobox . setenabled ( false ) ; runbutton . settext ( "interrupt" ) ; boolean debugenabled = debugswitch . isselected ( ) ; boolean simrunenabled = simrunswitch . isselected ( ) ; boolean ignoreenabled = ignoreswitch . isselected ( ) ; boolean forceenabled = forceswitch . isselected ( ) ; int threadcomboval = threadcombobox . getselectedindex ( ) + 1 ; int debugcomboval = debugcombobox . getselectedindex ( ) + 1 ; config . setdebug ( debugenabled ) ; if ( debugenabled ) { config . setverbosity ( debugcomboval ) ; } else { config . setverbosity ( 1 ) ; } config . setrunterminal ( false ) ; config . setpastonly ( false ) ; config . setforcerun ( forceenabled ) ; config . setsimrun ( simrunenabled ) ; if ( simrunenabled ) { config . setlog_name ( "log_alt.txt" ) ; } config . setignorelog ( ignoreenabled ) ; config . setnumthreads ( threadcomboval ) ; try { if ( config . finishedtoday ( ) && ! config . isignorelog ( ) ) { mainoutmessage ( "already finished today" , 1 ) ; } } catch ( ioexception e ) { util . exceptionhandler ( e , 1 , "wt.run> unknown error  probably a problem reading logfile" , config , this ) ; } config . outputconfig ( this ) ; wr = new weatherrecorder ( this , config ) ; wr . run ( ) ; } else if ( runbutton . gettext ( ) . equals ( "interrupt" ) ) { runbutton . settext ( "press button again to interrupt" ) ; } else if ( runbutton . gettext ( ) . equals ( "press button again to interrupt" ) ) { runbutton . settext ( "forcing quit..." ) ; stopprogram ( ) ; } }
va	7	private cfggroup readgroup ( final cfggroup group , final bufferedreader reader ) throws ioexception { while ( true ) { string line = reader . readline ( ) ; if ( line == null ) { return group ; } line = line + "\r\n" ; final string trimmedline = line . trim ( ) ; if ( trimmedline . equals ( "}" ) ) { group . addfooterline ( new cfgrawline ( line ) ) ; return group ; } if ( trimmedline . equals ( "{" ) ) { group . addheaderline ( new cfgrawline ( line ) ) ; continue ; } if ( trimmedline . startswith ( "//" ) ) { continue ; } if ( trimmedline . isempty ( ) ) { continue ; } final int indexofequals = trimmedline . indexof ( = ) ; if ( indexofequals < 0 ) { final cfgline groupnameline = new cfgrawline ( line ) ; final cfggroup subgroup = new cfggroup ( groupnameline ) ; readgroup ( subgroup , reader ) ; group . addsubgroup ( subgroup ) ; } else { final cfgline cfgline = new cfgkeyvalueline ( line ) ; group . addline ( cfgline ) ; } } }
va	4	public void construct2dmatrixfromstringset ( int currentrow , int startindex , int numrows , int numcolumns , list < string > rawdata ) { string scurrentline = "" ; string _convertedpattern = "" ; int tracknumberofrows = 0 ; int sindex = 0 ; _pattern = new string [ numrows ] ; while ( true ) { scurrentline = rawdata . get ( currentrow ) . substring ( startindex , startindex + numcolumns ) ; sindex = 0 ; if ( tracknumberofrows == numrows ) break ; _convertedpattern = "" ; while ( sindex < scurrentline . length ( ) ) { _convertedpattern += ( scurrentline . charat ( sindex ) == + ? 1 : 0 ) ; sindex ++ ; } _pattern [ tracknumberofrows ] = string . valueof ( binarytodecimal ( _convertedpattern ) ) ; tracknumberofrows ++ ; } }
va	4	public calculatorframe ( ) { setbounds ( 250 , 150 , 500 , 200 ) ; setlayout ( null ) ; settitle ( "super calculator" ) ; setdefaultcloseoperation ( exit_on_close ) ; setresizable ( false ) ; calcpanel = new calculatorpanel ( this ) ; add ( calcpanel ) ; setvisible ( true ) ; addwindowlistener ( new windowadapter ( ) { @ override public void windowclosing ( windowevent e ) { if ( calcpanel != null && settings . autosave . get ( ) . equals ( "true" ) ) { calcpanel . getcalcmenubar ( ) . autosave ( ) ; } } @ override public void windowopened ( windowevent e ) { if ( calcpanel != null && settings . autosave . get ( ) . equals ( "true" ) ) { calcpanel . getcalcmenubar ( ) . autoopen ( ) ; } } } ) ; system . out . println ( "auto round: " + settings . autoround . get ( ) ) ; }
va	5	@ override public void dopost ( httpservletrequest request , httpservletresponse response ) throws ioexception { userservice userservice = userservicefactory . getuserservice ( ) ; user user = userservice . getcurrentuser ( ) ; string guestbookname = request . getparameter ( "guestbookname" ) ; string emaildeclared = request . getparameter ( "email" ) ; string namedeclared = request . getparameter ( "name" ) ; if ( guestbookname == null ) { guestbookname = "default" ; } if ( emaildeclared == null ) { emaildeclared = user . getemail ( ) ; } if ( namedeclared == null ) { namedeclared = user . getnickname ( ) ; } key guestbookkey = keyfactory . createkey ( "guestbook" , guestbookname ) ; string content = request . getparameter ( "message" ) ; if ( content == null ) { content = "greetings!" ; } if ( user != null ) { entity greeting = new entity ( "greeting" , guestbookkey ) ; date date = new date ( ) ; greeting . setproperty ( "user" , user ) ; greeting . setproperty ( "date" , date ) ; greeting . setproperty ( "userid" , user . getuserid ( ) ) ; greeting . setproperty ( "federatedid" , user . getfederatedidentity ( ) ) ; greeting . setproperty ( "domain" , user . getauthdomain ( ) ) ; greeting . setproperty ( "content" , content ) ; greeting . setproperty ( "namedeclared" , namedeclared ) ; greeting . setproperty ( "emaildeclared" , emaildeclared ) ; datastoreservice ds = datastoreservicefactory . getdatastoreservice ( ) ; ds . put ( greeting ) ; } else { log . info ( "anonymous: " + content ) ; } response . sendredirect ( "/guest.jsp?guestbookname=" + guestbookname ) ; }
va	6	public void render ( vpoint cm , vgame vg , vgraphics g ) { if ( l > 0 ) { l -- ; } if ( l <= 0 ) { return ; } vpoint v = new vpoint ( s . x - cm . x , s . y - cm . y , s . z ) ; vpoint osv = vconvert . to2dpoint ( v . x , v . y , v . z ) ; switch ( i ) { case 1 : g . settexture ( "eft/smoke.png" ) ; g . setcolor ( new color ( 255 , 255 , 255 , l * 2 ) ) ; g . drawrect ( ( int ) osv . x , ( int ) osv . y , 32 , 32 , a ) ; s . x += ( r . nextint ( 6 ) - 2 ) ; s . y -= 1 ; s . z += ( l ) / 34 ; break ; case 2 : g . settexture ( "eft/smoke.png" ) ; g . setcolor ( new color ( 255 , 255 , 255 , l * 8 ) ) ; g . drawrect ( ( int ) osv . x , ( int ) osv . y , 16 , 16 , a ) ; s . x += ( r . nextint ( 6 ) - 2 ) ; s . y -= 1 ; s . z += ( l ) / 34 ; break ; case 3 : g . setcolor ( new color ( 255 , 255 , 255 , 255 ) ) ; sprite . render ( "bullet" , g , 7 - l , v ) ; break ; case 4 : g . setcolor ( new color ( 255 , 255 , 255 , 255 ) ) ; sprite . render ( "gauss_bullet" , g , 5 - l , v ) ; break ; default : } }
va	2	public static attributetable getdefaultattributetable ( ) { if ( defaultattributetable == null ) { defaultattributetable = new attributetable ( ) ; for ( int i = 0 ; i < attrs . length ; i ++ ) { defaultattributetable . install ( attrs [ i ] ) ; } attrhref = defaultattributetable . lookup ( "href" ) ; attrsrc = defaultattributetable . lookup ( "src" ) ; attrid = defaultattributetable . lookup ( "id" ) ; attrname = defaultattributetable . lookup ( "name" ) ; attrsummary = defaultattributetable . lookup ( "summary" ) ; attralt = defaultattributetable . lookup ( "alt" ) ; attrlongdesc = defaultattributetable . lookup ( "longdesc" ) ; attrusemap = defaultattributetable . lookup ( "usemap" ) ; attrismap = defaultattributetable . lookup ( "ismap" ) ; attrlanguage = defaultattributetable . lookup ( "language" ) ; attrtype = defaultattributetable . lookup ( "type" ) ; attrtitle = defaultattributetable . lookup ( "title" ) ; attrxmlns = defaultattributetable . lookup ( "xmlns" ) ; attrvalue = defaultattributetable . lookup ( "value" ) ; attrcontent = defaultattributetable . lookup ( "content" ) ; attrdatafld = defaultattributetable . lookup ( "datafld" ) ; ; attrwidth = defaultattributetable . lookup ( "width" ) ; ; attrheight = defaultattributetable . lookup ( "height" ) ; ; attralt . nowrap = true ; attrvalue . nowrap = true ; attrcontent . nowrap = true ; } return defaultattributetable ; }
va	6	public list < document > sorting ( map < string , document > temp , int mode ) { list < document > sortedlist = new linkedlist < document > ( temp . values ( ) ) ; if ( mode == 0 ) { collections . sort ( sortedlist , new comparator < document > ( ) { @ override public int compare ( document o1 , document o2 ) { if ( o1 . getpagerank ( ) - o2 . getpagerank ( ) == 0 ) { return o1 . gettitle ( ) . compareto ( o2 . gettitle ( ) ) ; } else { return ( o1 . getpagerank ( ) - o2 . getpagerank ( ) < 0 ) ? 1 : - 1 ; } } } ) ; } else if ( mode == 1 ) { collections . sort ( sortedlist , new comparator < document > ( ) { @ override public int compare ( document o1 , document o2 ) { if ( o1 . getnumviews ( ) - o2 . getnumviews ( ) == 0 ) { return o1 . gettitle ( ) . compareto ( o2 . gettitle ( ) ) ; } else { return ( o1 . getnumviews ( ) - o2 . getnumviews ( ) < 0 ) ? 1 : - 1 ; } } } ) ; } return sortedlist ; }
va	9	public void createfitxacurs ( int nexp , string cursacademic ) { datactrl cd = new datactrl ( ) ; string datacreacio = cd . getdatasql ( ) + " " + cd . gethora ( ) ; string sql1 = "select exp_fk_id from `" + icoredata . core_mysqldbprefix + "`.fitxa_alumne_curs where exp_fk_id='" + nexp + "' " + " and any_academic='" + cursacademic + "'" ; try { statement st = client . getmysql ( ) . createstatement ( ) ; resultset rs1 = client . getmysql ( ) . getresultset ( sql1 , st ) ; if ( rs1 != null && rs1 . next ( ) ) { return ; } if ( rs1 != null ) { rs1 . close ( ) ; st . close ( ) ; } } catch ( sqlexception ex ) { logger . getlogger ( beandadespersonals . class . getname ( ) ) . log ( level . severe , null , ex ) ; } int cursid = integer . parseint ( stringutils . beforelast ( cursacademic , "-" ) ) ; string sql2 = "select * from `" + icoredata . core_mysqldbprefix + "`.xes_alumne_historic where anyacademic='" + cursid + "' and exp2=" + nexp ; sql1 = "insert into `" + icoredata . core_mysqldbprefix + "`.fitxa_alumne_curs " + "(exp_fk_id  " + "idcurs_fk_id " + " estudis  " + "grup  " + "any_academic  " + "ensenyament " + " professor  " + "observacions  " + "derivatori  " + "motiuderivacioori  " + "nummateriessuspjuny  " + "notamitjafinal  " + "numal_1rtri  " + "numal_2ntri  " + "numal_3rtri  " + "numag_1rtri " + " numag_2ntri  " + "numag_3rtri  " + "sancions  " + "programes  " + "datacreacio " + " modificat  " + "datamodificacio) " + " values( ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?) " ; object [ ] values = null ; try { statement st2 = client . getmysql ( ) . createstatement ( ) ; resultset rs2 = client . getmysql ( ) . getresultset ( sql2 , st2 ) ; if ( rs2 != null && rs2 . next ( ) ) { string lensenyament = rs2 . getstring ( "ensenyament" ) ; string lestudis = rs2 . getstring ( "estudis" ) ; string lgrupo = rs2 . getstring ( "grup" ) ; string lprofe = rs2 . getstring ( "proftutor" ) ; grup grup = new grup ( grup . xestib , lensenyament , lestudis , lgrupo , client ) ; values = new object [ ] { nexp , cursid , grup . getxestudis ( ) , grup . getxgrup ( ) , cursacademic , grup . getxensenyament ( ) , lprofe , "" , 0 , "" , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , "" , "" , datacreacio , "" , "" } ; } else { string nivell = "" ; string grup = "" ; string profe = "" ; if ( stringutils . anyacademic ( ) . equals ( cursacademic ) ) { string abrev = client . getfitxesclient ( ) . getfitxesutils ( ) . gettutor ( nexp , cursid ) ; profe = stringutils . nonull ( client . getprofessoratdata ( ) . getmapabrev ( ) . get ( abrev ) ) ; } grup grupo = new grup ( client ) . getgrup ( nexp , cursid ) ; grupo . print ( ) ; values = new object [ ] { nexp , cursid , grupo . getxestudis ( ) , grupo . getxgrup ( ) , cursacademic , grupo . getxensenyament ( ) , profe , "" , 0 , "" , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , "" , "" , datacreacio , "" , "" } ; } if ( rs2 != null ) { rs2 . close ( ) ; st2 . close ( ) ; } } catch ( sqlexception ex ) { logger . getlogger ( beandadespersonals . class . getname ( ) ) . log ( level . severe , null , ex ) ; } int nup = client . getmysql ( ) . preparedupdate ( sql1 , values ) ; }
va	6	private static int computelongestcycle ( string string ) { final int length = string . length ( ) ; int maxcycle = 0 ; int i = 0 ; char [ ] chars = string . tochararray ( ) ; for ( i = 0 ; i < length ; i ++ ) { boolean same = true ; char first = chars [ i ] ; int cycle = 0 ; for ( int j = i + 1 ; j < string . length ( ) ; j ++ ) { if ( chars [ j ] != first ) { same = false ; } else { final int l = ( j - i ) ; final boolean ok = equals ( chars , i , i + l , l ) ; if ( ok ) { cycle = l ; break ; } } } if ( same ) { cycle = 1 ; } if ( cycle > maxcycle ) { maxcycle = cycle ; } } return maxcycle ; }
va	0	public fourmiliere ( monde monde , case c , int fecondite , int taille_max , int ressources , int tauxeclaireuses ) { this . fecondite = fecondite ; this . taille_max = taille_max ; this . ressources = ressources ; this . fourmi = new hashset < fourmi > ( ) ; this . _case = c ; this . monde = monde ; this . tauxeclaireuses = tauxeclaireuses ; logger . debug ( "fourmiliere cr\u00e9e : " + this ) ; _case . setfourmiliere ( this ) ; monde . ajouterfourmiliere ( this ) ; this . getmonde ( ) . fireevent ( new fourmiliereajouteeevent ( monde . gettour ( ) , new date ( ) , this ) ) ; }
va	0	public sparkle ( int x , int y , float xa , float ya , int xpic , int ypic , int timespan ) { sheet = art . particles ; this . x = x ; this . y = y ; this . xa = xa ; this . ya = ya ; this . xpic = xpic ; xpicstart = xpic ; this . ypic = ypic ; this . xpico = 4 ; this . ypico = 4 ; wpic = 8 ; hpic = 8 ; life = 10 + ( int ) ( math . random ( ) * timespan ) ; }
va	5	@ override public point gettarget ( gamestate state ) { float [ ] [ ] candidates = new float [ 3 ] [ 5 ] ; point target = null ; int i = 0 ; for ( targetingstrategy strategy : strategies ) { target = strategy . gettarget ( state ) ; if ( target != null ) { candidates [ target . x ] [ target . y ] += weights [ i ] ; } ++ i ; } float greatest = 0f ; target = null ; for ( int x = 0 ; x < 3 ; x ++ ) { for ( int y = 0 ; y < 5 ; y ++ ) { if ( candidates [ x ] [ y ] > greatest ) { target = new point ( x , y ) ; greatest = candidates [ x ] [ y ] ; } } } return target ; }
va	6	protected list < string > getdata ( ) { list < string > datafields = new linkedlist < string > ( ) ; stringbuilder databuff = new stringbuilder ( ) ; char c = nextchar ( ) ; while ( c == [ ) { char prev = contents . charat ( index ) ; c = nextchar ( ) ; while ( ( c != ] || ( c == ] && prev == \ ) ) && index < contents . length ( ) ) { databuff . append ( c ) ; prev = c ; c = nextchar ( ) ; } string buffvalue = databuff . tostring ( ) ; if ( buffvalue . length ( ) != 0 ) { datafields . add ( buffvalue ) ; databuff = new stringbuilder ( ) ; } c = nextchar ( ) ; } pushchar ( ) ; return datafields ; }
va	3	public list < jsonobject > take ( int maxwaitmillis ) throws interruptedexception { list < jsonobject > result = new arraylist < jsonobject > ( ) ; lock . lock ( ) ; try { if ( samples . size ( ) < batchsize ) { lessthenbatchsizecondition . await ( maxwaitmillis , timeunit . milliseconds ) ; } if ( samples . size ( ) == 0 ) { return result ; } int takedcount = samples . size ( ) < batchsize ? samples . size ( ) : batchsize ; result . addall ( samples . sublist ( 0 , takedcount ) ) ; samples . removeall ( result ) ; return result ; } finally { lock . unlock ( ) ; } }
va	4	public static void execute_crop_stmt ( preparedstatement pstmt , int [ ] indexes , hashset < integer > set ) throws sqlexception { int cnt = 0 ; for ( int i = 0 ; i < indexes . length ; i ++ ) { if ( ! set . contains ( indexes [ i ] ) ) { pstmt . setint ( 1 , indexes [ i ] ) ; pstmt . addbatch ( ) ; cnt ++ ; if ( cnt > 5000 ) { pstmt . executebatch ( ) ; cnt = 0 ; } } } if ( cnt > 0 ) pstmt . executebatch ( ) ; }
va	7	public static void domnodetotree ( node domnode , treedomnode parenttreenode , boolean displaynodevalue ) { if ( domnode instanceof text ) return ; treedomnode treenode = new treedomnode ( domnode , displaynodevalue ) ; parenttreenode . add ( treenode ) ; namednodemap attributenodes = domnode . getattributes ( ) ; if ( ( attributenodes != null ) && ( attributenodes . getlength ( ) > 0 ) ) { for ( int i = 0 ; i < attributenodes . getlength ( ) ; i ++ ) { treenode . add ( new treedomnode ( attributenodes . item ( i ) , displaynodevalue ) ) ; } } nodelist childnodes = domnode . getchildnodes ( ) ; if ( ( childnodes != null ) && ( childnodes . getlength ( ) > 0 ) ) { for ( int i = 0 ; i < childnodes . getlength ( ) ; i ++ ) domnodetotree ( childnodes . item ( i ) , treenode , displaynodevalue ) ; } }
va	3	public request < modifypropertyvaluerequest > marshall ( modifypropertyvaluerequest modifypropertyvaluerequest ) { if ( modifypropertyvaluerequest == null ) { throw new amazonclientexception ( "invalid argument passed to marshall(...)" ) ; } final request < modifypropertyvaluerequest > request = new defaultrequest < > ( modifypropertyvaluerequest , "eucalyptusproperties" ) ; request . addparameter ( "action" , "modifypropertyvalue" ) ; request . addparameter ( "version" , "eucalyptus" ) ; if ( modifypropertyvaluerequest . getname ( ) != null ) { request . addparameter ( "name" , stringutils . fromstring ( modifypropertyvaluerequest . getname ( ) ) ) ; } if ( modifypropertyvaluerequest . getvalue ( ) != null ) { request . addparameter ( "value" , stringutils . fromstring ( modifypropertyvaluerequest . getvalue ( ) ) ) ; } return request ; }
va	3	public void shoot ( double xa , double ya , double za ) { super . shoot ( xa , ya , za ) ; for ( int i = 0 ; i < bombs . size ( ) ; i ++ ) { if ( bombs . get ( i ) . removed ) bombs . remove ( i -- ) ; } if ( bombs . size ( ) == 8 ) { bombs . remove ( 0 ) . detonate ( ) ; } stickybomb bomb = new stickybomb ( owner , this , xa , ya , za , 90 ) ; bombs . add ( bomb ) ; owner . level . add ( bomb ) ; shootdelay = shootdelaytime ; }
va	1	@ override public void afteriteration ( int iteration , i reference ) { final int width1 = 20 ; final int width2 = 8 ; final int width3 = 30 ; final double error = reference . geterror ( ) ; string imprec = "(-)" ; if ( error < this . best ) { this . best = error ; imprec = "(+)" ; } system . out . print ( paddingback ( "iteration: " + iteration , width1 ) ) ; system . out . print ( paddingback ( imprec , width2 ) ) ; system . out . print ( paddingback ( "error: " + doubletools . asstring ( error , 10 ) , width3 ) ) ; system . out . print ( "best error: " + doubletools . asstring ( this . best , 10 ) ) ; system . out . println ( ) ; }
va	1	public void write ( char [ ] cbuf , int off , int len ) { string str = new string ( cbuf , off , len ) ; int start = 0 ; int eol ; while ( ( eol = str . indexof ( ioconsole . line_separator , start ) ) != - 1 ) { consolemodel . print ( str . substring ( start , eol ) , consolemodel . output_style ) ; consolemodel . print ( "\n" , consolemodel . output_style ) ; start = eol + ioconsole . line_separator . length ( ) ; } consolemodel . print ( str . substring ( start ) , consolemodel . output_style ) ; }
va	4	@ override public void setchild ( int childindex , genetrait child ) { if ( objecttype == null ) { if ( childindex < childtypes . size ( ) ) { childgenes . put ( childindex , child ) ; } else { throw new illegalargumentexception ( "no such child index: " + childindex ) ; } } else { if ( childindex == 0 ) { object = child ; } else if ( childindex - 1 < childtypes . size ( ) ) { childgenes . put ( childindex - 1 , child ) ; } else { throw new illegalargumentexception ( "no such child index: " + childindex ) ; } } }
va	8	public void enterelement ( string name , attributes attrs ) throws exception { if ( customparser != null ) { customparser . enterelement ( name , attrs ) ; return ; } if ( name . equals ( "keyring" ) ) { done = false ; return ; } if ( name . equals ( "protocols" ) ) { return ; } if ( name . equals ( "protocol" ) ) { string type = attrs . getvalue ( "type" ) ; string clname = attrs . getvalue ( "class" ) ; try { class < ? > cl = class . forname ( clname ) ; ap_generic . registerhandler ( type , cl . assubclass ( ap_generic . class ) ) ; } catch ( exception e ) { throw new saxexception ( "unknown authentication protocol class: " + clname ) ; } return ; } if ( name . equals ( "identity" ) ) { proto = attrs . getvalue ( "proto" ) ; domain = attrs . getvalue ( "domain" ) ; ap_generic parser = ap_generic . getinstance ( proto ) ; if ( parser == null ) throw new saxexception ( "unknown authentication protocol: " + proto ) ; parser . initparse ( attrs ) ; customparser = parser ; return ; } }
va	6	private id3v2commentframedata extractcommentframedata ( string id , boolean itunes ) { id3v2frameset frameset = framesets . get ( id ) ; if ( frameset != null ) { iterator < id3v2frame > iterator = frameset . getframes ( ) . iterator ( ) ; while ( iterator . hasnext ( ) ) { id3v2frame frame = ( id3v2frame ) iterator . next ( ) ; id3v2commentframedata framedata ; try { framedata = new id3v2commentframedata ( useframeunsynchronisation ( ) , frame . getdata ( ) ) ; if ( itunes && itunes_comment_description . equals ( framedata . getdescription ( ) . tostring ( ) ) ) { return framedata ; } else if ( ! itunes ) { return framedata ; } } catch ( invaliddataexception e ) { } } } return null ; }
va	0	@ test public void testhypothesis ( ) { testhyphelper ( 0 , 1 , 0 , 1 , true , math . log ( 8.0 / 3 ) ) ; testhyphelper ( 1 , 1 , 1 , 1 , true , 0 ) ; testhyphelper ( 1 , 1 , 1 , 1 , false , 0 ) ; testhyphelper ( 100 , 200 , 300 , 300 , true , math . log ( 201.0 / 101 ) ) ; testhyphelper ( 100 , 200 , 300 , 300 , false , math . log ( 101.0 / 201 ) ) ; }
va	9	public void render_fow ( vgraphics g , point pcm ) { g . settexture ( "fow/full.png" ) ; i ++ ; for ( int x = pcm . x / 64 ; x < 30 + pcm . x / 64 ; x ++ ) { for ( int y = - 10 + pcm . y / 64 ; y < 20 + pcm . y / 64 ; y ++ ) { int h = 20 ; int z = t ( point ( x , y ) ) * h ; vpoint test = vconvert . to2dpoint ( x * 64 + - pcm . x / 2 , y * 64 + 32 - pcm . y / 2 , z ) ; if ( x == 0 || x == 511 || y == 0 || y == 511 ) { g . setcolor ( new color ( 235 , 0 , 0 ) ) ; } else if ( tf ( point ( x , y ) ) > 0 ) { g . setcolor ( new color ( 235 , 235 , 235 ) ) ; } else { g . setcolor ( new color ( 135 , 135 , 135 ) ) ; } vpoint p = vconvert . to2dpoint ( x * 64 - pcm . x , y * 64 - pcm . y , z ) ; if ( tf ( point ( x , y ) ) <= 1 ) { if ( tf ( point ( x , y ) ) == 0 ) { g . setcolor ( new color ( 255 , 255 , 255 , 75 ) ) ; } else { g . setcolor ( new color ( 255 , 255 , 255 , 15 ) ) ; } g . drawrect ( ( int ) p . x , ( int ) p . y , 255 , 255 , i ) ; g . drawrect ( ( int ) p . x , ( int ) p . y , 255 , 255 , - i ) ; } } } }
va	4	public static void registertormi ( ) { try { namenodeslaveimpl slave = new namenodeslaveimpl ( ) ; string local_ipaddress = inetaddress . getlocalhost ( ) . gethostaddress ( ) ; string slavename = systemconstants . getconfig ( systemconstants . namenode_slave_service ) ; string name = slavename + "_" + getidentifier ( ) ; string bindname = "rmi://" + local_ipaddress + ":" + portnumber + "/" + name ; system . out . println ( "registering namenodeslave as : " + bindname ) ; naming . rebind ( bindname , slave ) ; system . out . println ( "namenodeslaveimpl: ready..." ) ; } catch ( remoteexception e ) { system . out . println ( "error while accessing the remote object check on the rmi." ) ; system . exit ( 0 ) ; } catch ( unknownhostexception e ) { system . out . println ( "error while accessing the rmi  please retry" ) ; system . exit ( 0 ) ; } catch ( malformedurlexception e ) { system . out . println ( "error while binding the slave  please retry." ) ; system . exit ( 0 ) ; } catch ( accesscontrolexception e ) { system . out . println ( "error with the access control  check the policy." ) ; system . exit ( 0 ) ; } }
va	4	public static monster createmonsterfromreader ( string monsterstring ) { string [ ] values = monsterstring . split ( " " ) ; monster monster = new monster ( ) ; try { monster . setname ( values [ 0 ] ) ; monster . setmaxhp ( integer . parseint ( values [ 1 ] ) ) ; monster . setcurrenthp ( integer . parseint ( values [ 1 ] ) ) ; monster . setnaturalac ( integer . parseint ( values [ 2 ] ) ) ; monster . setstrength ( integer . parseint ( values [ 3 ] ) ) ; monster . setdexterity ( integer . parseint ( values [ 4 ] ) ) ; monster . setspeed ( integer . parseint ( values [ 5 ] ) ) ; monster . setattackbonus ( integer . parseint ( values [ 6 ] ) ) ; monster . setbasedamage ( integer . parseint ( values [ 7 ] ) ) ; monster . setbasemeleedescription ( values [ 8 ] ) ; monster . setsightrange ( integer . parseint ( values [ 9 ] ) ) ; monster . setdifficulty ( integer . parseint ( values [ 10 ] ) ) ; if ( values . length == 12 && values [ 11 ] != "" ) { string [ ] specials = values [ 11 ] . split ( " " ) ; monster = monster . applyspecialtraits ( monster , specials ) ; } monster . setinsight ( false ) ; } catch ( exception e ) { system . out . println ( "error reading monster object" ) ; if ( monster . getname ( ) != null ) system . out . println ( monster . getname ( ) + " has some incorrect parameter." ) ; return null ; } return monster ; }
va	6	private void initbuttons ( ) { buttons = new jpanel ( ) ; buttons . setminimumsize ( new dimension ( 70 , 75 + design . getheight ( ) ) ) ; buttons . setbackground ( color . black ) ; noterrain = new jbutton ( ) ; noterrain . settext ( "canyon" ) ; noterrain . setmargin ( new insets ( 0 , 0 , 0 , 0 ) ) ; noterrain . setfont ( new font ( "consolas" , 0 , 9 ) ) ; noterrain . setforeground ( color . light_gray ) ; noterrain . setbackground ( color . black ) ; noterrain . setminimumsize ( new dimension ( 40 , 40 ) ) ; noterrain . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent evt ) { type = - 1 ; } } ) ; terrain0 = new jbutton ( ) ; terrain0 . settext ( "road" ) ; terrain0 . setmargin ( new insets ( 0 , 0 , 0 , 0 ) ) ; terrain0 . setfont ( new font ( "consolas" , 0 , 9 ) ) ; terrain0 . setforeground ( color . black ) ; terrain0 . setbackground ( color . light_gray ) ; terrain0 . setminimumsize ( new dimension ( 40 , 40 ) ) ; terrain0 . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent evt ) { type = 0 ; unitbuttons . deselect ( ) ; } } ) ; terrain1 = new jbutton ( ) ; terrain1 . settext ( "grass" ) ; terrain1 . setmargin ( new insets ( 0 , 0 , 0 , 0 ) ) ; terrain1 . setfont ( new font ( "consolas" , 0 , 9 ) ) ; terrain1 . setforeground ( color . black ) ; terrain1 . setbackground ( new color ( 100 , 150 , 0 ) ) ; terrain1 . setminimumsize ( new dimension ( 40 , 40 ) ) ; terrain1 . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent evt ) { type = 1 ; unitbuttons . deselect ( ) ; } } ) ; terrain2 = new jbutton ( ) ; terrain2 . settext ( "hills" ) ; terrain2 . setmargin ( new insets ( 0 , 0 , 0 , 0 ) ) ; terrain2 . setfont ( new font ( "consolas" , 0 , 9 ) ) ; terrain2 . setforeground ( color . black ) ; terrain2 . setbackground ( new color ( 100 , 100 , 0 ) ) ; terrain2 . setminimumsize ( new dimension ( 40 , 40 ) ) ; terrain2 . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent evt ) { type = 2 ; unitbuttons . deselect ( ) ; } } ) ; terrain3 = new jbutton ( ) ; terrain3 . settext ( "forest" ) ; terrain3 . setmargin ( new insets ( 0 , 0 , 0 , 0 ) ) ; terrain3 . setfont ( new font ( "consolas" , 0 , 9 ) ) ; terrain3 . setforeground ( color . black ) ; terrain3 . setbackground ( new color ( 0 , 125 , 0 ) ) ; terrain3 . setminimumsize ( new dimension ( 40 , 40 ) ) ; terrain3 . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent evt ) { type = 3 ; unitbuttons . deselect ( ) ; } } ) ; terrain4 = new jbutton ( ) ; terrain4 . settext ( "mountain" ) ; terrain4 . setmargin ( new insets ( 0 , 0 , 0 , 0 ) ) ; terrain4 . setfont ( new font ( "consolas" , 0 , 8 ) ) ; terrain4 . setforeground ( color . lightgray ) ; terrain4 . setbackground ( new color ( 0 , 65 , 0 ) ) ; terrain4 . setminimumsize ( new dimension ( 40 , 40 ) ) ; terrain4 . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent evt ) { type = 4 ; unitbuttons . deselect ( ) ; } } ) ; bluebase = new jbutton ( ) ; bluebase . seticon ( new imageicon ( modelmanager . getmodel ( "bluebase" ) . getimage ( ) . getscaledinstance ( 32 , 22 , java . awt . image . scale_smooth ) ) ) ; bluebase . setmargin ( new insets ( 0 , 0 , 0 , 0 ) ) ; bluebase . setmaximumsize ( new dimension ( 40 , 40 ) ) ; bluebase . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent evt ) { type = 5 ; unitbuttons . deselect ( ) ; } } ) ; redbase = new jbutton ( ) ; redbase . seticon ( new imageicon ( modelmanager . getmodel ( "redbase" ) . getimage ( ) . getscaledinstance ( 32 , 22 , java . awt . image . scale_smooth ) ) ) ; redbase . setmargin ( new insets ( 0 , 0 , 0 , 0 ) ) ; redbase . setmaximumsize ( new dimension ( 40 , 40 ) ) ; redbase . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent evt ) { type = 6 ; unitbuttons . deselect ( ) ; } } ) ; factory = new jbutton ( ) ; factory . seticon ( new imageicon ( modelmanager . getmodel ( "factory" ) . getimage ( ) . getscaledinstance ( 32 , 22 , java . awt . image . scale_smooth ) ) ) ; factory . setbackground ( color . light_gray ) ; factory . setmargin ( new insets ( 0 , 0 , 0 , 0 ) ) ; factory . setmaximumsize ( new dimension ( 40 , 40 ) ) ; factory . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent evt ) { type = 7 ; unitbuttons . deselect ( ) ; } } ) ; teamfactory = new jbutton ( ) ; teamfactory . seticon ( new imageicon ( modelmanager . getmodel ( "factory" ) . getimage ( ) . getscaledinstance ( 32 , 22 , java . awt . image . scale_smooth ) ) ) ; teamfactory . setbackground ( color . blue ) ; teamfactory . setmargin ( new insets ( 0 , 0 , 0 , 0 ) ) ; teamfactory . setmaximumsize ( new dimension ( 40 , 40 ) ) ; teamfactory . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent evt ) { type = team ? 8 : 9 ; unitbuttons . deselect ( ) ; } } ) ; blueteam = new jradiobutton ( ) ; blueteam . settext ( "blue" ) ; blueteam . setfont ( new font ( "consolas" , 0 , 9 ) ) ; blueteam . setbackground ( color . black ) ; blueteam . setforeground ( color . light_gray ) ; blueteam . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent evt ) { team = true ; unitbuttons . changeteam ( true ) ; teamfactory . setbackground ( color . blue ) ; redteam . setselected ( false ) ; } } ) ; redteam = new jradiobutton ( ) ; redteam . settext ( "red" ) ; redteam . setfont ( new font ( "consolas" , 0 , 9 ) ) ; redteam . setbackground ( color . black ) ; redteam . setforeground ( color . light_gray ) ; redteam . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent evt ) { team = false ; unitbuttons . changeteam ( false ) ; teamfactory . setbackground ( color . red ) ; blueteam . setselected ( false ) ; } } ) ; unitbuttons = new unitbuttonspanel ( ) ; unitbuttons . setmaximumsize ( new dimension ( 100 , 0 ) ) ; save = new jbutton ( ) ; save . settext ( "save" ) ; save . setbackground ( color . black ) ; save . setforeground ( color . light_gray ) ; save . setfont ( new font ( "consolas" , 0 , 16 ) ) ; save . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent evt ) { if ( locationmanager . getbase ( true ) == null || locationmanager . getbase ( false ) == null ) { joptionpane . showmessagedialog ( design , "base missing" ) ; return ; } string mapname = joptionpane . showinputdialog ( "map name?" ) ; if ( mapname == null || mapname . equals ( "" ) ) { joptionpane . showmessagedialog ( design , "invalid name" ) ; return ; } try { locationmanager . savemap ( mapname ) ; joptionpane . showmessagedialog ( design , "map " + mapname + " saved." ) ; } catch ( exception e ) { joptionpane . showmessagedialog ( design , "error occurred: " + e . tostring ( ) ) ; } } } ) ; random = new jbutton ( ) ; random = new jbutton ( ) ; random . settext ( "random" ) ; random . setbackground ( color . black ) ; random . setforeground ( color . light_gray ) ; random . setfont ( new font ( "consolas" , 0 , 16 ) ) ; random . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent evt ) { locationmanager . generatemap ( locationmanager . getsize ( ) . x , locationmanager . getsize ( ) . y ) ; render ( ) ; } } ) ; }
va	1	public static paquet createpaquetfrombuffer ( socketchannel socket ) throws ioexception { string [ ] t = new string [ 1 ] ; t [ 0 ] = message . end_envoi ; string msg = "" ; msg = utilitaires . getafullmessage ( t , socket ) ; scanner scan = new scanner ( msg ) ; int id = scan . nextint ( ) ; string ipadresse = scan . next ( ) ; int port = scan . nextint ( ) ; machine owner = new machine ( ipadresse , port ) ; arraylist < machine > hosts = new arraylist < machine > ( global . nombresouspaquets ) ; for ( int i = 0 ; i < global . nombresouspaquets ; i ++ ) { string ip = scan . next ( ) ; int p = scan . nextint ( ) ; hosts . add ( i , new machine ( ip , p ) ) ; } paquet paq = new paquet ( id , owner ) ; paq . putotherhosts ( hosts ) ; scan . close ( ) ; return paq ; }
va	8	public static pair < integer > traverse_spiral ( int cur_row , int cur_col , int square_len ) { int midpoint = ( square_len - 1 ) / 2 ; int next_col = cur_col ; int next_row = cur_row ; if ( cur_row == square_len / 2 && cur_col == midpoint ) { next_col = - 1 ; next_row = - 1 ; } else if ( cur_row <= midpoint ) { if ( cur_col < cur_row - 1 ) { next_row -- ; } else if ( cur_col < square_len - 1 - cur_row ) { next_col ++ ; } else if ( next_col != midpoint ) { next_row ++ ; } } else { if ( cur_col > cur_row ) { next_row ++ ; } else if ( cur_col > square_len - 1 - cur_row ) { next_col -- ; } else { next_row -- ; } } pair < integer > p = new pair < integer > ( next_row , next_col ) ; return p ; }
va	5	javaexporter ( component parent , list < fonthandle > fonts , jfilechooser chooser ) { if ( chooser != null ) { mchooser = chooser ; } else { string path = system . getproperty ( "user.home" ) ; if ( path != null ) { file file = new file ( path , "desktop" ) ; if ( ! file . exists ( ) ) { file = new file ( path ) ; } mchooser = new jfilechooser ( file ) ; } else { mchooser = new jfilechooser ( ) ; } } while ( parent . getparent ( ) != null ) { parent = parent . getparent ( ) ; } mfonts = fonts ; mnoexamplebutton = new jbutton ( "export fonts" ) ; mexamplebutton = new jbutton ( "export fonts + example code" ) ; mcancelbutton = new jbutton ( "cancel" ) ; mnoexamplebutton . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent e ) { doexport ( false ) ; } } ) ; mexamplebutton . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent e ) { doexport ( true ) ; } } ) ; mcancelbutton . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent e ) { docancel ( ) ; } } ) ; font font = new font ( "verdana" , font . bold , 18 ) ; for ( jbutton b : new jbutton [ ] { mnoexamplebutton , mexamplebutton , mcancelbutton } ) { b . setfont ( font ) ; add ( b ) ; } setlayout ( new layout ( ) ) ; mdialog = new jdialog ( ( window ) parent , "export options" , modalitytype . application_modal ) ; mdialog . setcontentpane ( this ) ; mdialog . setsize ( 450 , 280 ) ; mdialog . setresizable ( false ) ; mdialog . setlocationrelativeto ( parent ) ; mdialog . setvisible ( true ) ; }
va	6	public void update ( ) { board board = board . getinstance ( ) ; int x = board . getintx ( ) + ( board . getintwidth ( ) - 11 * boardentity . field_size ) / 2 ; int y = board . getinty ( ) + ( board . getintheight ( ) - 11 * boardentity . field_size ) / 2 ; switch ( gettype ( ) ) { case red_player : y += boardentity . field_size ; break ; case blue_player : x += boardentity . field_size * 7 ; y += boardentity . field_size ; break ; case green_player : x += boardentity . field_size * 7 ; y += boardentity . field_size * 9 ; break ; case yellow_player : y += boardentity . field_size * 9 ; break ; } namelabel . verticalaligncenter ( x , x + 4 * boardentity . field_size ) ; namelabel . sety ( y ) ; namelabel . update ( ) ; if ( position != 0 ) { namelabel . settext ( scorelabelstr ( ) ) ; } else if ( isactive ( ) ) { namelabel . settext ( string . format ( "%s (%d)" , this . name , this . rollcount ) ) ; } else { namelabel . settext ( this . name ) ; } }
va	0	public void testiscornerfield ( ) { begintest ( "iscornerfield method" ) ; boolean result ; result = board . iscornerfield ( new coordinate ( 0 , 0 ) ) ; assertequals ( "iscornerfield(new coordinate(0  0)" , true , result ) ; result = board . iscornerfield ( new coordinate ( 0 , 7 ) ) ; assertequals ( "iscornerfield(new coordinate(0  7)" , true , result ) ; result = board . iscornerfield ( new coordinate ( 7 , 0 ) ) ; assertequals ( "iscornerfield(new coordinate(7  0)" , true , result ) ; result = board . iscornerfield ( new coordinate ( 7 , 7 ) ) ; assertequals ( "iscornerfield(new coordinate(7  7)" , true , result ) ; result = board . iscornerfield ( new coordinate ( 3 , 7 ) ) ; assertequals ( "iscornerfield(new coordinate(3  7)" , false , result ) ; result = board . iscornerfield ( new coordinate ( 7 , 8 ) ) ; assertequals ( "iscornerfield(new coordinate(7  8)" , false , result ) ; }
va	2	public llvmvalue visit ( classdeclsimple n ) { classes . put ( n . name . s , new classnode ( n . name . s ) ) ; setclassinuse ( n . name . s ) ; list < llvmtype > listatipos = new linkedlist < llvmtype > ( ) ; for ( util . list < vardecl > v = n . varlist ; v != null ; v = v . tail ) { llvmvalue field = v . head . accept ( this ) ; getclassinuse ( ) . addfield ( field . tostring ( ) , field . type ) ; listatipos . add ( field . type ) ; } getclassinuse ( ) . addclasstype ( new llvmstructure ( listatipos ) ) ; for ( util . list < methoddecl > m = n . methodlist ; m != null ; m = m . tail ) { m . head . accept ( this ) ; } classenv = null ; methodenv = null ; return null ; }
va	8	public string longestprefixof ( string string ) { if ( string == null ) { throw new illegalargumentexception ( ) ; } if ( root == null ) { return null ; } int longest = - 1 ; if ( root . value != null ) { longest = 0 ; } node < v > node = root ; int length = string . length ( ) ; for ( int i = 0 ; i < length && node != null ; ++ i ) { char c = string . charat ( i ) ; if ( ! valid ( c ) ) { throw new illegalargumentexception ( ) ; } node = node . next [ c ] ; if ( node . value != null ) { longest = i + 1 ; } } if ( longest == - 1 ) { return null ; } return string . substring ( 0 , longest ) ; }
va	7	public void generateaggregatedreport ( ) { long start , end ; start = system . currenttimemillis ( ) ; file reportfile = new file ( reportfilename ) ; printwriter reportout = null ; boolean once = true ; try { reportout = new printwriter ( reportfile ) ; } catch ( filenotfoundexception e ) { e . printstacktrace ( ) ; } reportout . println ( "report generation time   " + timestamp ) ; for ( int instanceno = 0 ; instanceno < instancefiles . length ; instanceno ++ ) { probleminstance probleminstance = createprobleminstance ( instancefiles [ instanceno ] , singleoutputfilename ) ; scheme6 ga = new scheme6 ( probleminstance ) ; if ( once ) { once = false ; reportout . format ( "number of generation  population size  offspring population size  loadpenalty  routetime penalty\n" ) ; reportout . format ( "%d  %d  %d  %f  %f\n" , ga . number_of_generation , ga . population_size , ga . number_of_offspring , loadpenaltyfactor , routetimepenaltyfactor ) ; reportout . println ( ) ; reportout . println ( ) ; reportout . format ( "instance name  min  avg  max  feasible \n" ) ; } double min = ffffff ; double max = - 1 ; double sum = 0 ; double avg ; int feasiblecount = 0 ; for ( int i = 0 ; i < runsize ; i ++ ) { individual sol = ga . run ( ) ; if ( sol . isfeasible == true ) { feasiblecount ++ ; } sum += sol . costwithpenalty ; if ( sol . costwithpenalty > max ) max = sol . costwithpenalty ; if ( sol . costwithpenalty < min ) min = sol . costwithpenalty ; } avg = sum / runsize ; reportout . format ( "%s  %f  %f  %f  %d \n" , instancefiles [ instanceno ] , min , avg , max , feasiblecount ) ; reportout . flush ( ) ; system . out . format ( "%s  %f  %f  %f  %d \n" , instancefiles [ instanceno ] , min , avg , max , feasiblecount ) ; } end = system . currenttimemillis ( ) ; long duration = ( end - start ) / 1000 ; long minute = duration / 60 ; long seconds = duration % 60 ; reportout . println ( "\nelapsed time : " + minute + " minutes " + seconds + " seconds" ) ; reportout . flush ( ) ; reportout . close ( ) ; }
va	9	public void select ( int start , int end ) { if ( ! selected || start != selectstart || end != selectend ) { if ( selectend < selectstart ) { selectnone ( ) ; } else { if ( selectstart >= wave . length ( ) ) selectstart = wave . length ( ) - 1 ; if ( selectend >= wave . length ( ) ) selectend = wave . length ( ) - 1 ; if ( selectstart < 0 ) selectstart = 0 ; if ( selectend < 0 ) selectend = 0 ; selectstart = start ; selectend = end ; selected = true ; if ( observer != null ) observer . wavecanvasevent ( this , select ) ; } } }
va	9	@ override public void visitdocument ( string key , object value ) { paths = docutils . split ( key , / ) ; infolist = new arraylist < getvisitor . visitorinfo > ( ) ; string decrpath = "" ; for ( int i = 0 ; i < paths . length ; i ++ ) { decrpath += "/" + paths [ i ] ; } field f = rootdoc . getschema ( ) . getfield ( paths [ 0 ] ) ; if ( paths . length > 1 ) { decrpath = "" ; for ( int i = 0 ; i < paths . length - 1 ; i ++ ) { decrpath += "/" + paths [ i ] ; } } else { if ( f . isreadonly ( ) ) { } } getvisitor visitor = new getvisitor ( rootdoc ) ; if ( paths . length > 1 ) { visitor . visitdocument ( decrpath ) ; object sourceobject = visitor . getresult ( ) ; if ( sourceobject == null ) { throw new nullpointerexception ( "null value for key path '" + key + "'" ) ; } if ( visitor . getexception ( ) != null ) { throw ( runtimeexception ) visitor . getexception ( ) ; } schematype st = visitor . getinfo ( ) . getresultschematype ( ) ; visitput ( st , sourceobject , value ) ; } else { object sourceobject = f . istail ( ) ? ( ( objectdocument ) rootdoc ) . tail : ( ( objectdocument ) rootdoc ) . getdataobject ( ) ; schematype st = new embeddedtype ( rootdoc . getschema ( ) ) ; visitput ( st , sourceobject , value ) ; } if ( getexception ( ) != null ) { runtimeexception re = ( runtimeexception ) getexception ( ) ; throw re ; } }
va	2	private void jbuttongetarrivalsfromresnoactionperformed ( java . awt . event . actionevent evt ) { if ( "" . equals ( jtextfieldresno . gettext ( ) ) ) { joptionpane . showmessagedialog ( rootpane , "wrong input" ) ; system . out . println ( jtextfieldresno . gettext ( ) ) ; } else { dflbooking . removeallelements ( ) ; int resno = integer . parseint ( jtextfieldresno . gettext ( ) ) ; booking arrival = con . findresnumber ( resno ) ; if ( arrival != null ) { dflbooking . addelement ( arrival ) ; } else { jlabelstatusbooking . settext ( "could not find booking" ) ; } } }
va	1	public void updateinfo ( string cont , string addr , string fn , string ln ) { try { startconnection ( ) ; stmt = conn . createstatement ( ) ; string query = "update employee" + " set contact='" + cont + "'   address='" + addr + "' where first_name='" + fn + "' and last_name='" + ln + "'" ; preparedstatement preparedstmt = conn . preparestatement ( query ) ; system . out . println ( "update info  ok!" ) ; joptionpane . showmessagedialog ( null , "success update info!" ) ; preparedstmt . execute ( ) ; stopconnection ( ) ; } catch ( exception e ) { joptionpane . showmessagedialog ( null , "updateinfo().\n>: " + e ) ; stopconnection ( ) ; } }
va	1	private box drawbuttonbestscores ( ) { kulbutton ok1 = new kulbutton ( "ok" ) ; ok1 . setpreferredsize ( new dimension ( 125 , 40 ) ) ; ok1 . setmaximumsize ( new dimension ( 125 , 40 ) ) ; ok1 . setforeground ( color . white ) ; ok1 . setfont ( f . derivefont ( 26f ) ) ; box buttonbox = new box ( boxlayout . x_axis ) ; buttonbox . add ( box . createhorizontalglue ( ) ) ; buttonbox . add ( ok1 ) ; buttonbox . add ( box . createhorizontalglue ( ) ) ; ok1 . addmouselistener ( new mouseadapter ( ) { @ override public void mouseclicked ( mouseevent e ) { if ( swingutilities . isleftmousebutton ( e ) ) { slideup ( ) ; } } } ) ; return buttonbox ; }
va	6	private string getpage ( int page , map < string , object > map ) { int factor = 5 ; int index = ( page - 1 ) * factor ; int listsize = map . size ( ) ; if ( index > listsize ) { return "" ; } int upper = index + factor ; if ( upper >= listsize ) { upper = listsize ; } stringbuilder sb = new stringbuilder ( ) ; sb . append ( chatcolor . red ) . append ( plugin . getname ( ) ) . append ( "\n" ) . append ( chatcolor . reset ) ; sb . append ( "page " ) . append ( page ) . append ( "/" ) . append ( ( int ) math . ceil ( ( double ) listsize / ( double ) factor ) ) ; sb . append ( "\n" ) . append ( chatcolor . reset ) ; string [ ] list = map . keyset ( ) . toarray ( new string [ listsize ] ) ; arrays . sort ( list ) ; for ( int i = index ; i < upper ; i ++ ) { object test = map . get ( list [ i ] ) ; if ( test != null ) { if ( test instanceof subcommand ) { subcommand db = ( subcommand ) map . get ( list [ i ] ) ; sb . append ( db . gethelp ( ) [ 0 ] ) . append ( " - " ) . append ( db . gethelp ( ) [ 1 ] ) ; } if ( i != upper - 1 ) { sb . append ( "\n" ) ; } } } sb . append (  ) . append ( chatcolor . yellow ) . append ( "use /ttp help <command> to get help for a specific command" ) ; return sb . tostring ( ) ; }
va	5	public static node addtwonumbers ( node num1 , node num2 ) { node num3 = null ; node head = null ; int updigit = 0 ; while ( num1 != null && num2 != null ) { int digit1 = num1 . value ; int digit2 = num2 . value ; int newdigit = ( digit1 + digit2 + updigit ) % 10 ; updigit = ( digit1 + digit2 ) / 10 ; node numnode = new node ( null , newdigit ) ; if ( num3 == null ) { num3 = numnode ; head = num3 ; } else { num3 . next = numnode ; num3 = numnode ; } num1 = num1 . next ; num2 = num2 . next ; } if ( num1 != null ) { num3 . next = num1 ; } if ( num2 != null ) { num3 . next = num2 ; } return head ; }
va	9	public string [ ] getforecasttimes ( ) throws exception { string [ ] times = new string [ 8 ] ; try { layers ++ ; bufferedreader br = new bufferedreader ( new inputstreamreader ( new url ( makeurl . hourlyurl ( zip , plusdays ) ) . openstream ( ) ) ) ; int numhours = 0 ; string line = "" ; line = br . readline ( ) ; int index = 0 ; int i = 0 ; boolean prevlinewashour = false ; while ( true ) { times [ i ] = "" ; if ( line . contains ( "<th class=\"tac\">" ) ) { prevlinewashour = true ; index = line . indexof ( "<th class=\"tac\">" ) + 16 ; while ( character . isdigit ( line . charat ( index ) ) ) { times [ i ] = times [ i ] + line . charat ( index ) ; index ++ ; } i ++ ; if ( i > 7 ) { break ; } } else if ( prevlinewashour ) { numhours = i ; break ; } else if ( line . contains ( "<h1>there has been an error!</h1>" ) ) { numhours = 0 ; break ; } line = br . readline ( ) ; } numhours = i ; wundergroundhours = numhours ; string [ ] ret = new string [ numhours ] ; for ( int j = 0 ; j < numhours ; j ++ ) { ret [ j ] = times [ j ] ; } wundergroundtimes = ret ; layers = 0 ; return ret ; } catch ( exception e ) { if ( layers > 5 ) { return times ; } else { thread . sleep ( 2000 ) ; return gethourlyforecasttemps ( ) ; } } }
va	6	public boolean act ( agent agent , action action ) { if ( energy_level <= 0 ) { agent . die ( ) ; updateviews ( msg ) ; return false ; } boolean flag = ( action != null ) ; if ( flag ) { simulatedagent a = ( simulatedagent ) agent ; int x = ( ( integer ) a . getattribute ( x ) ) . intvalue ( ) ; int y = ( ( integer ) a . getattribute ( y ) ) . intvalue ( ) ; percept p = sense ( a ) ; string msg = null ; string act = action . getcode ( ) ; int actionid = language . getactionindex ( act ) ; switch ( actionid ) { case 4 : if ( ( ( boolean ) p . getattribute ( language . getpercept ( 5 ) ) ) . booleanvalue ( ) ) { structure [ x ] [ y ] |= ( 1 << 15 ) ; int bit_flag = ( 1 << 10 ) ; if ( ( structure [ x ] [ y ] & bit_flag ) == bit_flag ) { system . out . println ( "eating good food..." ) ; energy_level = math . min ( energy_level + inc_energy_level , max_energy_level ) ; } else { system . out . println ( "eating bad food..." ) ; energy_level = math . max ( energy_level - dec_energy_level , 0 ) ; } } else { msg = simpleview . error + "[there is not food. eat action not executed]" ; } updateviews ( msg ) ; break ; default : if ( actionid == 2 ) { energy_level -- ; system . out . println ( energy_level ) ; } super . act ( agent , action ) ; break ; } } return flag ; }
va	7	public int longestvalidparentheses ( string s ) { stack < character > sc = new stack < character > ( ) ; stack < integer > si = new stack < integer > ( ) ; int i = 0 , max = 0 ; for ( i = 0 ; i < s . length ( ) ; i ++ ) { char c = s . charat ( i ) ; if ( si . isempty ( ) || c == ( ) { si . push ( i ) ; sc . push ( c ) ; } else { if ( sc . peek ( ) == ( ) { sc . pop ( ) ; si . pop ( ) ; if ( si . isempty ( ) ) { if ( max < i + 1 ) { max = i + 1 ; } } else { if ( max < i - si . peek ( ) ) { max = i - si . peek ( ) ; } } } } } return max ; }
va	4	@ override public void read ( receivebuffer rbuf , int timeout ) { try { long time = system . currenttimemillis ( ) ; while ( ( system . currenttimemillis ( ) - time ) < timeout && ! sio . state . reset ) { sio . state . readcalls ++ ; int len = inputstream . read ( mreadbuffer . array ( ) , 0 , read_size ) ; if ( len > 0 ) { mreadbuffer . position ( len ) ; rbuf . append ( mreadbuffer ) ; mreadbuffer . clear ( ) ; return ; } } } catch ( exception e ) { sio . onrunerror ( e , "otg read" ) ; } }
va	6	public void sortby ( string order ) { defaultmutabletreenode tmpnode = null ; defaultmutabletreenode curnodecopy = null ; sorttreemodel treemodeltmp = null ; defaultmutabletreenode roottmp = new defaultmutabletreenode ( rootnodetxt ) ; if ( order . equals ( "name" ) ) { treemodeltmp = new sorttreemodel ( roottmp , new treestringcomparatorname ( ) ) ; sortedbyname = true ; } else { treemodeltmp = new sorttreemodel ( roottmp , new treestringcomparatordate ( ) ) ; sortedbyname = false ; } sortbynamemenuitem . setenabled ( ! sortedbyname ) ; sortbydatemenuitem . setenabled ( sortedbyname ) ; for ( @ suppresswarnings ( "rawtypes" ) enumeration e = ( ( defaultmutabletreenode ) treemodel . getroot ( ) ) . breadthfirstenumeration ( ) ; e . hasmoreelements ( ) ; ) { defaultmutabletreenode curnode = ( defaultmutabletreenode ) e . nextelement ( ) ; object obj = curnode . getuserobject ( ) ; if ( obj instanceof item ) { item currentitem = ( item ) obj ; if ( currentitem . isdir ( ) ) curnodecopy = new foldernode ( currentitem ) ; else curnodecopy = new leafnode ( currentitem , ( ( leafnode ) curnode ) . getdownperc ( ) , ( ( leafnode ) curnode ) . getstatus ( ) ) ; object objpar = ( ( defaultmutabletreenode ) curnode . getparent ( ) ) . getuserobject ( ) ; if ( objpar instanceof item ) { if ( ( tmpnode = getitemintree ( ( item ) objpar , treemodeltmp ) ) != null ) { treemodeltmp . insertnodeinto ( curnodecopy , tmpnode ) ; } } else { treemodeltmp . insertnodeinto ( curnodecopy , roottmp ) ; } } } rootnode = roottmp ; treemodel = treemodeltmp ; tree . setmodel ( treemodel ) ; }
va	1	public void recteffect2 ( graphics g ) { g . fillrect ( ( int ) ( 120 - 60 * math . sin ( ( double ) effecttime2 * math . pi / 180 ) ) , ( int ) ( 280 - 60 * math . sin ( ( double ) effecttime2 * math . pi / 180 ) ) , ( int ) ( 120 * math . sin ( ( double ) effecttime2 * math . pi / 180 ) ) , ( int ) ( 120 * math . sin ( ( double ) effecttime2 * math . pi / 180 ) ) ) ; if ( this . effecttime2 != 120 ) { this . effecttime2 += 10 ; } }
va	2	@ override public object createobject ( resultset rs ) { ensembldbs edbs = null ; int id = 0 ; string dbname = null ; string label = null ; int version = 0 ; try { if ( rs . next ( ) ) { id = rs . getint ( 1 ) ; dbname = rs . getstring ( 2 ) ; label = rs . getstring ( 3 ) ; version = rs . getint ( 4 ) ; edbs = new ensembldbs ( id , dbname , label , version ) ; } } catch ( sqlexception e ) { e . printstacktrace ( ) ; } return edbs ; }
va	1	@ test public void dotest ( ) { biginteger bip = new biginteger ( "14" ) ; bip = bip . pow ( 8 ) ; biginteger bi = temp . pow ( zero . intvalue ( ) ) ; biginteger mult = two ; for ( biginteger i = one ; i . compareto ( bi ) == - 1 ; i = i . add ( one ) ) { mult = mult . multiply ( two ) ; mult = mult . remainder ( bip ) ; } system . out . println ( mult ) ; biginteger result = two ; system . out . println ( result ) ; }
va	7	void funcargs ( expdesc f ) { funcstate fs = this . fs ; expdesc args = new expdesc ( ) ; int base , nparams ; int line = this . linenumber ; switch ( this . t . token ) { case ( : { if ( line != this . lastline ) this . syntaxerror ( "ambiguous syntax (function call x new statement)" ) ; this . next ( ) ; if ( this . t . token == ) ) args . k = vvoid ; else { this . explist1 ( args ) ; fs . setmultret ( args ) ; } this . check_match ( ) , ( , line ) ; break ; } case { : { this . constructor ( args ) ; break ; } case tk_string : { this . codestring ( args , this . t . ts ) ; this . next ( ) ; break ; } default : { this . syntaxerror ( "function arguments expected" ) ; return ; } } funcstate . _assert ( f . k == vnonreloc ) ; base = f . info ; if ( hasmultret ( args . k ) ) nparams = funcstate . lua_multret ; else { if ( args . k != vvoid ) fs . exp2nextreg ( args ) ; nparams = fs . freereg - ( base + 1 ) ; } f . init ( vcall , fs . codeabc ( funcstate . op_call , base , nparams + 1 , 2 ) ) ; fs . fixline ( line ) ; fs . freereg = base + 1 ; }
va	7	public static void knapsackbits ( int [ ] weights , int [ ] values , long maxweight ) { int n = weights . length ; long numsets = ( long ) math . pow ( 2 , n ) ; long bestset = 0 ; long bestvalue = 0 ; long bestweight = 0 ; for ( long set = 1 ; set < numsets ; set ++ ) { long weight = 0 ; long value = 0 ; for ( int i = 0 ; i < 64 ; i ++ ) { if ( ( ( set >> i ) & 1 ) == 1 ) { weight += weights [ i ] ; value += values [ i ] ; } } if ( weight <= maxweight && value > bestvalue ) { bestvalue = value ; bestweight = weight ; bestset = set ; } } for ( int i = 0 ; i < 64 ; i ++ ) { if ( ( ( bestset >> i ) & 1 ) == 1 ) { system . out . print ( "[i=" + i + "  w=" + weights [ i ] + "  v=" + values [ i ] + "] " ) ; } } system . out . println ( ) ; system . out . println ( "weight = " + bestweight + "  value = " + bestvalue ) ; }
va	0	@ test public void shouldrighttrimstringscorrectly ( ) throws unsupportedencodingexception { assertequals ( "" , buffertools . trimstringright ( "" ) ) ; assertequals ( "" , buffertools . trimstringright ( " " ) ) ; assertequals ( "test" , buffertools . trimstringright ( "test" ) ) ; assertequals ( "test" , buffertools . trimstringright ( "test   " ) ) ; assertequals ( "   test" , buffertools . trimstringright ( "   test" ) ) ; assertequals ( "   test" , buffertools . trimstringright ( "   test   " ) ) ; assertequals ( "test" , buffertools . trimstringright ( "test\t\r\n" ) ) ; assertequals ( "test" , buffertools . trimstringright ( "test" + buffertools . bytebuffertostring ( new byte [ ] { 0 , 0 } , 0 , 2 ) ) ) ; }
va	2	void insertquestions ( ) throws sqlexception { statement selectstmt = myconnection . createstatement ( ) ; resultset rs = selectstmt . executequery ( "select quesid from mcq order by quesid desc" ) ; if ( rs . next ( ) ) quesno = integer . parseint ( rs . getstring ( 1 ) ) ; quesno ++ ; string textareacontents = questextarea . gettext ( ) ; int correctoption = combocorrect . getselectedindex ( ) + 1 ; string query = "insert into mcq values ('" + textareacontents + "' '" + opt1 . gettext ( ) + "' '" + opt2 . gettext ( ) + "' '" + opt3 . gettext ( ) + "' '" + opt4 . gettext ( ) + "' " + quesno + " " + correctoption + ")" ; system . out . println ( query ) ; if ( selectstmt . executeupdate ( query ) != 0 ) { system . out . println ( "question entered successfully" ) ; } }
va	2	public void setscore ( scorecardcategories kategorie , int score ) throws illegalargumentexception { if ( scorecard . get ( kategorie . tostring ( ) ) >= 0 ) { throw new illegalargumentexception ( "wert schon gesetzt" ) ; } else { scorecard . put ( kategorie . tostring ( ) , score ) ; calculatetotales ( ) ; } iterator < map . entry < string , integer >> entries = scorecard . entryset ( ) . iterator ( ) ; while ( entries . hasnext ( ) ) { map . entry < string , integer > entry = entries . next ( ) ; system . out . println ( "key = " + entry . getkey ( ) + "  value = " + entry . getvalue ( ) ) ; } this . setchanged ( ) ; this . notifyobservers ( ) ; }
va	6	@ override public void startelement ( string uri , string localname , string qname , attributes attributes ) throws saxexception { super . startelement ( uri , localname , qname , attributes ) ; if ( qname . equals ( "question" ) ) { string type = attributes . getvalue ( "type" ) ; string num = attributes . getvalue ( "number" ) ; if ( type != null && num != null ) { int n = integer . parseint ( num ) ; if ( type . equals ( "multiple_choice" ) ) this . reader . setcontenthandler ( new multiplechoicehandler ( this . reader , this , n ) ) ; else if ( type . equals ( "short_answer" ) ) this . reader . setcontenthandler ( new shortanswerhandler ( this . reader , this , n ) ) ; else if ( type . equals ( "file_submission" ) ) this . reader . setcontenthandler ( new filesubmissionhandler ( this . reader , this , n ) ) ; } } }
va	5	public void runscript ( inputstream stream ) throws jstrykerexception , illegalargumentexception { if ( stream == null ) { throw new illegalargumentexception ( "stream cannot be null." ) ; } try { list < string > commands = parse ( stream ) ; for ( string command : commands ) { statement statement = null ; try { statement = connection . createstatement ( ) ; statement . execute ( command . tostring ( ) ) ; } finally { if ( statement != null ) { statement . close ( ) ; } } } } catch ( sqlexception e ) { throw new jstrykerexception ( e . getmessage ( ) , e ) ; } catch ( ioexception e ) { throw new jstrykerexception ( e . getmessage ( ) , e ) ; } }
va	6	public text parse ( string pathtofile ) { text text = null ; try { fileinputstream fstream = new fileinputstream ( pathtofile ) ; bufferedreader br = new bufferedreader ( new inputstreamreader ( fstream ) ) ; resourcebundle bundle ; bundle = resourcebundle . getbundle ( applicationvalue . bundle_location ) ; string textline ; text = new text ( ) ; while ( ( textline = br . readline ( ) ) != null ) { if ( ( textline . matches ( bundle . getstring ( applicationvalue . header ) ) || ( textline . trim ( ) . matches ( bundle . getstring ( applicationvalue . output ) ) ) ) ) { text . add ( splitsentencebywordsandpunctuation ( textline ) ) ; } else { if ( iscode ( textline ) ) { text . add ( new listing ( textline ) ) ; } else { pattern sentencepattern = pattern . compile ( bundle . getstring ( applicationvalue . sentence ) ) ; matcher sentencematcher = sentencepattern . matcher ( textline ) ; while ( sentencematcher . find ( ) ) { string sentencestring = sentencematcher . group ( ) ; text . add ( splitsentencebywordsandpunctuation ( sentencestring ) ) ; } } } } } catch ( ioexception e ) { log . error ( e ) ; } return text ; }
va	2	public static bufferedimage getimagefor ( sexes sex ) { if ( instance == null ) { instance = new portraitimages ( ) ; } optional portraitoptional = instance . unusedportraitlist . stream ( ) . filter ( p -> p . getsex ( ) == sex ) . findany ( ) ; if ( portraitoptional . ispresent ( ) ) { instance . unusedportraitlist . remove ( portraitoptional . get ( ) ) ; instance . usedportraitlist . add ( ( portrait ) portraitoptional . get ( ) ) ; return ( ( portrait ) portraitoptional . get ( ) ) . getportrait ( ) ; } else { throw new runtimeexception ( "no more portaits" ) ; } }
va	2	@ override public void actionperformed ( actionevent event ) { if ( event . getsource ( ) == this . buttonstoryplayer ) { if ( ! arrays . aslist ( this . panelstoryplayer . getcomponents ( ) ) . contains ( this . storyarea ) ) { this . sneekgame = new storysneek ( "sneek (story mode)" , new gamesettings ( imagehelper . getstoryface ( ) , imagehelper . getcookie ( ) ) ) ; this . panelstoryplayer . add ( this . storyarea ) ; this . panelstoryplayer . repaint ( ) ; } else { this . sneekgame . launchgame ( ) ; this . sneekgame = null ; this . panelstoryplayer . remove ( this . storyarea ) ; this . panelstoryplayer . repaint ( ) ; } } }
va	4	public static void main ( string [ ] args ) { scanner scan = new scanner ( system . in ) ; string scomplete = scan . nextline ( ) ; while ( ! scomplete . equals ( "#" ) ) { string [ ] scompletearray = scomplete . split ( " " ) ; string s1 = scompletearray [ 0 ] ; string s2 = scompletearray [ 1 ] ; int [ ] [ ] m = new int [ s2 . length ( ) + 1 ] [ s1 . length ( ) + 1 ] ; dir [ ] [ ] direcciones = new dir [ s2 . length ( ) + 1 ] [ s1 . length ( ) + 1 ] ; fill ( s2 , s1 , m , direcciones ) ; arraylist < dir > res = trace ( m , direcciones , s2 , s1 ) ; int acarreo = 0 ; char last = a ; for ( int i = res . size ( ) - 1 ; i > - 1 ; i -- ) { if ( res . get ( i ) . pre . charat ( 0 ) == i ) { acarreo ++ ; } res . get ( i ) . acarreo ( acarreo ) ; system . out . print ( res . get ( i ) . stringify ( ) ) ; if ( res . get ( i ) . pre . charat ( 0 ) == d ) { acarreo -- ; } } system . out . print ( "e\n" ) ; scomplete = scan . nextline ( ) ; } }
va	1	public trackbean ( uri location , string tracknumber , string artist , string title , albumbean album , duration duration , string genre ) { this . location = location ; try { this . tracknumber = integer . parseint ( tracknumber ) ; } catch ( numberformatexception e ) { this . tracknumber = 0 ; } this . artist = artist ; this . title = title ; this . album = album ; this . duration = duration ; this . trackduration = new trackduration ( duration . tomillis ( ) ) ; this . genre = genre ; }
va	4	public boolean consumefuel ( final double mass ) { boolean outoffuel = false ; if ( preferredfueltanks . size ( ) == 0 ) { return false ; } final double masspertank = mass / preferredfueltanks . size ( ) / propellantratios . size ( ) ; for ( final vehiclepart fueltank : preferredfueltanks ) { for ( final resource resource : propellantratios . keyset ( ) ) { final double ratio = propellantratios . get ( resource ) ; final double resourcemass = fueltank . getresourcemass ( resource ) ; final double newresourcemass = resourcemass - masspertank * ratio ; if ( newresourcemass < 0 ) { outoffuel = true ; } fueltank . setresourcemass ( resource , math . max ( 0 , newresourcemass ) ) ; } } return ! outoffuel ; }
va	7	public void creerressources ( ) { if ( this . ressources_spawns == null ) { this . ressources_spawns = new arraylist < case > ( ) ; list < case > availables = new arraylist < case > ( ) ; for ( case c : this . get_cases ( ) ) { if ( c . getniveau_obstacle ( ) == 0 ) { availables . add ( c ) ; } } if ( configurationloader . max_ressources_spawns < availables . size ( ) ) { for ( int i = 0 ; i < configurationloader . max_ressources_spawns ; i ++ ) { if ( availables . size ( ) > 0 ) { case c = availables . get ( new random ( ) . nextint ( availables . size ( ) ) ) ; availables . remove ( c ) ; this . ressources_spawns . add ( c ) ; } } } else { this . ressources_spawns = availables ; } } case where = this . ressources_spawns . get ( new random ( ) . nextint ( this . ressources_spawns . size ( ) ) ) ; int quantite = ( this . abondance / ( new random ( ) . nextint ( 5 ) + 1 ) ) * configurationloader . abondance_multiplicator ; if ( quantite > 0 ) { where . ajouterressource ( new ressource ( quantite ) ) ; } }
va	1	public loginpanel ( ) { lblstatus = new jlabel ( "   " ) ; lblstatus . setforeground ( color . red ) ; lblstatus . setfont ( new font ( lblstatus . getfont ( ) . getname ( ) , lblstatus . getfont ( ) . getstyle ( ) , 11 ) ) ; jlabel lblusername = new jlabel ( "brukernavn:" ) , lblpassword = new jlabel ( "passord:" ) ; txtusername = new jtextfield ( "" , 20 ) ; txtpassword = new jpasswordfield ( "" , 20 ) ; loginbutton = new jbutton ( "logg inn" ) ; loginbutton . setminimumsize ( new dimension ( txtpassword . getpreferredsize ( ) . width , loginbutton . getminimumsize ( ) . height ) ) ; grouplayout layout = new grouplayout ( this ) ; this . setlayout ( layout ) ; layout . setautocreategaps ( true ) ; layout . setautocreatecontainergaps ( true ) ; layout . sethorizontalgroup ( layout . createsequentialgroup ( ) . addgroup ( layout . createparallelgroup ( grouplayout . alignment . leading ) . addcomponent ( lblusername ) . addcomponent ( lblpassword ) ) . addgroup ( layout . createparallelgroup ( grouplayout . alignment . leading ) . addcomponent ( lblstatus ) . addcomponent ( txtusername ) . addcomponent ( txtpassword ) . addcomponent ( loginbutton ) ) ) ; layout . setverticalgroup ( layout . createsequentialgroup ( ) . addcomponent ( lblstatus ) . addgroup ( layout . createparallelgroup ( grouplayout . alignment . leading ) . addcomponent ( lblusername ) . addcomponent ( txtusername ) ) . addgroup ( layout . createparallelgroup ( grouplayout . alignment . leading ) . addcomponent ( lblpassword ) . addcomponent ( txtpassword ) ) . addcomponent ( loginbutton ) ) ; try { properties p = new properties ( ) ; p . load ( new filereader ( new file ( "src/defaultlogin.local" ) ) ) ; txtusername . settext ( p . getproperty ( "username" ) ) ; txtpassword . settext ( p . getproperty ( "password" ) ) ; } catch ( ioexception e ) { } txtusername . addactionlistener ( this ) ; txtpassword . addactionlistener ( this ) ; loginbutton . addactionlistener ( this ) ; }
va	2	private void btn_ok_pressed ( java . awt . event . actionevent evt ) { tf_authorname . requestfocus ( false ) ; tf_email . requestfocus ( false ) ; _author . setname ( tf_authorname . gettext ( ) ) ; if ( ! _author . setemail ( tf_email . gettext ( ) ) ) { tf_email . settext ( "destek@kade.com.tr" ) ; joptionpane . showmessagedialog ( null , "please enter a valid email." , "email is not valid!" , joptionpane . error_message ) ; return ; } if ( _selectedindex == - 1 ) { mainframe . installation . getinformationmodel ( ) . getauthors ( ) . remove ( _author ) ; mainframe . installation . getinformationmodel ( ) . getauthors ( ) . add ( _author ) ; } else { mainframe . installation . getinformationmodel ( ) . getauthors ( ) . remove ( _author ) ; mainframe . installation . getinformationmodel ( ) . getauthors ( ) . add ( _selectedindex , _author ) ; } this . setvisible ( false ) ; }
va	9	public void submit ( integer partid ) { system . out . println ( string . format ( "==\n== [nlp] submitting solutions" + " | programming exercise %s\n==" , homework_id ( ) ) ) ; partid = promptpart ( ) ; list < string > partnames = validparts ( ) ; if ( ! isvalidpartid ( partid ) ) { system . err . println ( "!! invalid homework part selected." ) ; system . err . println ( string . format ( "!! expected an integer from 1 to %d." , partnames . size ( ) + 1 ) ) ; system . err . println ( "!! submission cancelled" ) ; return ; } string [ ] loginpassword = loginprompt ( ) ; string login = loginpassword [ 0 ] ; string password = loginpassword [ 1 ] ; if ( login == null || login . equals ( "" ) ) { system . out . println ( "!! submission cancelled" ) ; return ; } system . out . print ( "\n== connecting to coursera ... " ) ; list < integer > submitparts = new arraylist < integer > ( ) ; if ( partid == partnames . size ( ) + 1 ) { for ( int i = 1 ; i < partnames . size ( ) + 1 ; i ++ ) { submitparts . add ( new integer ( i ) ) ; } } else { submitparts . add ( new integer ( partid ) ) ; } for ( integer part : submitparts ) { string [ ] loginchsignature = getchallenge ( login , part ) ; if ( loginchsignature == null ) { return ; } login = loginchsignature [ 0 ] ; string ch = loginchsignature [ 1 ] ; string signature = loginchsignature [ 2 ] ; string ch_aux = loginchsignature [ 3 ] ; string ch_resp = challengeresponse ( login , password , ch ) ; string result = submitsolution ( login , ch_resp , part . intvalue ( ) , output ( part , ch_aux ) , source ( part ) , signature ) ; if ( result == null ) { result = "null response" ; } if ( result . trim ( ) . equals ( "exception: we could not verify your username / password  please try again. (note that your password is case-sensitive.)" ) ) { system . out . println ( "== the password is not your login  but a 10 character alphanumeric string displayed on the top of the assignments page." ) ; } else { system . out . println ( string . format ( "\n== [nlp] submitted homework %s - part %d - %s" , homework_id ( ) , part , partnames . get ( part - 1 ) ) ) ; system . out . println ( "== " + result . trim ( ) ) ; } } }
va	0	public static void main ( string [ ] args ) { scanner in = new scanner ( system . in ) ; double pi = 3.14 ; system . out . print ( "please enter radius : " ) ; double r = in . nextdouble ( ) ; double circlearea = pi * r * r ; double roundcircle = 2 * pi * r ; double surfacecircle = 4 * pi * r ; double volumecircle = 1.33 * pi * r * r * r ; system . out . println ( "circlearea : " + circlearea ) ; system . out . println ( "roundcircle : " + roundcircle ) ; system . out . println ( "surfacecircle : " + surfacecircle ) ; system . out . println ( "volumecircle : " + volumecircle ) ; }
va	7	public contact [ ] resize ( int currentsize , integer capacity , contact [ ] c ) { contact [ ] copy ; if ( capacity == null ) { int j = 0 ; while ( j < c . length ) { if ( c [ j ] == null ) break ; j ++ ; } copy = new contact [ j ] ; for ( int i = 0 ; i < copy . length ; i ++ ) { copy [ i ] = c [ i ] ; } return copy ; } copy = new contact [ capacity ] ; if ( capacity > currentsize ) { for ( int i = 0 ; i < currentsize ; i ++ ) { copy [ i ] = c [ i ] ; } } else { for ( int i = 0 ; i < capacity ; i ++ ) { copy [ i ] = c [ i ] ; } } return copy ; }
va	7	private void updatedatatabletimekeeping ( int n , int month , int year ) { object [ ] [ ] objdata = new object [ n ] [ ] ; object [ ] objcolumn = new object [ ] { "working" , "date" } ; int day ; string date ; if ( currentemployee != null ) { contract correctcontract = currentemployee . searchcorrespondingcontract ( year , month ) ; if ( correctcontract != null ) { timekeepingbook keepbook = correctcontract . gettimekeeping ( ) ; if ( keepbook != null ) { timekeepingsheet keepsheet = keepbook . get ( month , year ) ; if ( keepsheet == null ) { for ( int i = 0 ; i < n ; i ++ ) { day = i + 1 ; date = getstringofdate ( year , month , day ) ; object [ ] objvalue = new object [ ] { new boolean ( false ) , date } ; objdata [ i ] = objvalue ; } } else { for ( int i = 0 ; i < keepsheet . size ( ) ; i ++ ) { timekeepingdetailinfo infor = keepsheet . get ( i ) ; day = i + 1 ; date = getstringofdate ( year , month , day ) ; object [ ] objvalue = new object [ ] { new boolean ( infor . getisworking ( ) ) , date } ; objdata [ i ] = objvalue ; } } } } } else { for ( int i = 0 ; i < n ; i ++ ) { day = i + 1 ; date = getstringofdate ( year , month , day ) ; object [ ] objvalue = new object [ ] { new boolean ( false ) , date } ; objdata [ i ] = objvalue ; } } timekeepingbookframe . gettablemodeltimekeeping ( ) . setdatavector ( objdata , objcolumn ) ; timekeepingbookframe . gettabletimekeeping ( ) . getcolumn ( "working" ) . setcellrenderer ( new mytablecellrenderer ( ) ) ; timekeepingbookframe . gettabletimekeeping ( ) . getcolumn ( "working" ) . setcelleditor ( new mytablecelleditor ( ) ) ; }
va	0	public defaultenginedisplay ( string title , int x , int y , int width , int height ) { frame = new jframe ( title ) ; frame . setdefaultcloseoperation ( jframe . do_nothing_on_close ) ; frame . setignorerepaint ( true ) ; frame . setresizable ( false ) ; frame . setlocation ( x , y ) ; canvas = new canvas ( ) ; canvas . setpreferredsize ( new dimension ( width , height ) ) ; frame . add ( canvas ) ; frame . pack ( ) ; canvas . createbufferstrategy ( 2 ) ; bufferstrategy = canvas . getbufferstrategy ( ) ; canvas . requestfocus ( ) ; }
va	6	private jsonschema parse ( jsonnode rawschema , url currentschemalocation ) { if ( ! rawschema . isobject ( ) ) { throw new illegalargumentexception ( "a valid json schema must be an object" ) ; } jsonnode ref = rawschema . get ( "$ref" ) ; if ( ref != null ) { url referencedschemalocation ; try { referencedschemalocation = new url ( currentschemalocation , ref . textvalue ( ) ) ; } catch ( malformedurlexception e ) { throw new illegalargumentexception ( "the schema reference is malformed" , e ) ; } scheduleschemaforprocessing ( referencedschemalocation ) ; return new schemareference ( cache , referencedschemalocation ) ; } string type = rawschema . get ( "type" ) . astext ( ) ; if ( issimpletypeschema ( type ) ) { return parsesimpletypeschema ( rawschema ) ; } else if ( isobjectschema ( type ) ) { return parseobjectschema ( rawschema , currentschemalocation ) ; } else if ( isarrayschema ( type ) ) { return parsearrayschema ( rawschema , currentschemalocation ) ; } throw new illegalargumentexception ( "illegal schema type " + type ) ; }
va	6	@ override public void done ( ) { try { try { socket = get ( ) ; parent . updatestatus ( "connected!" ) ; parent . parentframe . addtab ( socket , parent . getnickname ( ) ) ; parent . dispose ( ) ; } catch ( interruptedexception e ) { e . printstacktrace ( ) ; } } catch ( java . util . concurrent . cancellationexception e ) { closesocket ( ) ; parent . updatestatus ( "cancelled." ) ; } catch ( java . util . concurrent . executionexception e ) { closesocket ( ) ; string why = null ; throwable cause = e . getcause ( ) ; if ( cause != null ) { why = cause . getmessage ( ) ; if ( cause instanceof unknownhostexception ) { why = "unknown host " + why ; } else if ( cause instanceof sockettimeoutexception ) { why = "connection timed out" ; } } else { why = e . getmessage ( ) ; } parent . updatestatus ( why ) ; } finally { connectbutton . setenabled ( true ) ; } }
va	4	public static void main ( string args [ ] ) { if ( args . length == 0 ) { try { system . out . println ( "enter file path:" ) ; wc ( new inputstreamreader ( system . in ) ) ; system . out . println ( lines + " " + words + " " + chars ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } ; } else { int twords = 0 , tchars = 0 , tlines = 0 ; for ( int i = 0 ; i < args . length ; i ++ ) { try { words = chars = lines = 0 ; wc ( new filereader ( args [ i ] ) ) ; twords += words ; tchars += chars ; tlines += lines ; system . out . println ( args [ i ] + ": " + lines + " " + words + " " + chars ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; system . out . println ( args [ i ] + ": error." ) ; } } system . out . println ( "total: " + tlines + " " + twords + " " + tchars ) ; } }
va	8	public double gethammingdis ( int [ ] actdeps , int [ ] actlabs , int [ ] preddeps , int [ ] predlabs ) { double dis = 0 ; for ( int i = 1 ; i < actdeps . length ; ++ i ) if ( options . learnlabel ) { if ( labellosstype == 0 ) { if ( actdeps [ i ] != preddeps [ i ] ) dis += 0.5 ; if ( actlabs [ i ] != predlabs [ i ] ) dis += 0.5 ; } else if ( actdeps [ i ] != preddeps [ i ] || actlabs [ i ] != predlabs [ i ] ) dis += 1 ; } else { if ( actdeps [ i ] != preddeps [ i ] ) dis += 1 ; } return dis ; }
va	9	public void invert ( int invdir ) { int lown = - 1 ; int highn = - 1 ; for ( int i = 0 ; i < highnote - lownote + 1 ; i ++ ) { if ( keyon [ i ] == true ) { lown = i ; break ; } } if ( lown >= 0 ) { for ( int i = highnote - lownote ; i > lown ; i -- ) { if ( keyon [ i ] == true ) { highn = i ; break ; } } } if ( highn >= 0 ) { if ( invdir > 0 ) { stopnote ( lownote + lown ) ; while ( lown <= highn ) lown += 12 ; playnote ( lownote + lown ) ; } else { stopnote ( lownote + highn ) ; while ( highn >= lown ) highn -= 12 ; playnote ( lownote + highn ) ; } } }
va	9	static private octnode recurseparse ( integer currentdepth , bytebuffer buffer , float [ ] origin , float length ) throws ioexception , octreeexception { byte type = buffer . get ( ) ; try { switch ( type ) { case octnode . octnode_empty : byte value = buffer . get ( ) ; return new octnode ( currentdepth , ( value == 0 ) ? false : true , origin , length ) ; case octnode . octnode_leaf : byte signs = buffer . get ( ) ; float coords [ ] = new float [ 3 ] ; coords [ 0 ] = buffer . getfloat ( ) ; coords [ 1 ] = buffer . getfloat ( ) ; coords [ 2 ] = buffer . getfloat ( ) ; return new octnode ( currentdepth , signs , coords , origin , length ) ; case octnode . octnode_intermediate : octnode children [ ] = new octnode [ 8 ] ; for ( int i = 0 ; i < 8 ; i ++ ) { float [ ] neworigin = new float [ 3 ] ; neworigin [ 2 ] = origin [ 2 ] + ( ( i % 2 == 1 ) ? length / 2 : 0 ) ; neworigin [ 1 ] = origin [ 1 ] + ( ( ( i >> 1 ) % 2 == 1 ) ? length / 2 : 0 ) ; neworigin [ 0 ] = origin [ 0 ] + ( ( ( i >> 2 ) % 2 == 1 ) ? length / 2 : 0 ) ; children [ i ] = recurseparse ( currentdepth + 1 , buffer , neworigin , length / 2 ) ; } return new octnode ( currentdepth , children , origin , length ) ; default : throw new invalidsogfilesyntaxoctreeexception ( ) ; } } catch ( octnodeexception one ) { throw new invalidsogfilesyntaxoctreeexception ( ) ; } }
va	0	private void elementosposicionanormal ( ) { this . jlabel2 . setlocation ( ( this . getwidth ( ) / 2 ) - ( this . txtcorreo . getwidth ( ) / 2 ) - 45 , 60 ) ; this . txtcorreo . setlocation ( ( this . getwidth ( ) / 2 ) - ( this . txtcorreo . getwidth ( ) / 2 ) - 45 , 80 ) ; this . btnbuscar . setlocation ( ( this . getwidth ( ) / 2 ) - ( this . btnbuscar . getwidth ( ) / 2 ) + 115 , 77 ) ; }
va	0	public static void main ( string [ ] args ) { searchinsertposition o = new searchinsertposition ( ) ; system . out . println ( "2\t" + o . searchinsert ( new int [ ] { 1 , 3 , 5 , 6 } , 5 ) ) ; system . out . println ( "1\t" + o . searchinsert ( new int [ ] { 1 , 3 , 5 , 6 } , 2 ) ) ; system . out . println ( "4\t" + o . searchinsert ( new int [ ] { 1 , 3 , 5 , 6 } , 7 ) ) ; system . out . println ( "0\t" + o . searchinsert ( new int [ ] { 1 , 3 , 5 , 6 } , 0 ) ) ; system . out . println ( "0\t" + o . searchinsert ( new int [ ] { 1 , 3 , 5 , 6 , 7 } , 0 ) ) ; system . out . println ( "1\t" + o . searchinsert ( new int [ ] { 1 , 3 , 5 , 6 , 7 } , 2 ) ) ; }
va	7	private int packspecifiedframes ( byte [ ] bytes , int offset , string onlyid , string notid ) throws notsupportedexception { iterator < id3v2frameset > setiterator = framesets . values ( ) . iterator ( ) ; while ( setiterator . hasnext ( ) ) { id3v2frameset frameset = setiterator . next ( ) ; if ( ( onlyid == null || onlyid . equals ( frameset . getid ( ) ) ) && ( notid == null || ! notid . equals ( frameset . getid ( ) ) ) ) { iterator < id3v2frame > frameiterator = frameset . getframes ( ) . iterator ( ) ; while ( frameiterator . hasnext ( ) ) { id3v2frame frame = ( id3v2frame ) frameiterator . next ( ) ; if ( frame . getdatalength ( ) > 0 ) { byte [ ] framedata = frame . tobytes ( ) ; buffertools . copyintobytebuffer ( framedata , 0 , framedata . length , bytes , offset ) ; offset += framedata . length ; } } } } return offset ; }
va	2	public void resolveclick ( int x , int y ) { if ( x > columns * ( tilesizex + hgap ) - 1 ) { zettautil . log ( "scroll bar click!" ) ; if ( y < rows * tilesizey / 2 ) { hiddenrows = math . max ( hiddenrows - 1 , 0 ) ; } else { hiddenrows ++ ; } } else { int tileindex = x / ( tilesizex + hgap ) + ( y / ( tilesizey + vgap ) + hiddenrows ) * columns ; this . selected = tileindex ; this . selectionchanged ( ) ; } this . repaint ( ) ; }
va	5	public static void main ( string [ ] args ) { init ( ) ; if ( args . length < 2 ) { system . err . println ( "expected args: <cmd> <config_file> ....\n" + "\t cmd = create  compare" ) ; system . exit ( 1 ) ; } cmd = args [ 0 ] . tolowercase ( ) ; string configfile = args [ 1 ] ; try { initvsl ( configfile ) ; } catch ( exception e ) { system . err . println ( "caught exception: " + e . tostring ( ) ) ; e . printstacktrace ( ) ; system . exit ( 1 ) ; } integer cmdint = ( integer ) cmds . get ( cmd ) ; if ( cmdint == null ) { system . err . println ( "expected args: <cmd> <dbfile> ....\n" + "\t cmd = create  compare  list  read" ) ; system . exit ( 1 ) ; } switch ( cmdint ) { case 1 : create ( args ) ; break ; case 3 : compare ( args ) ; break ; } system . exit ( 0 ) ; }
va	8	protected void encodedocumenttype ( documenttype documenttype ) throws ioexception { aligntooctet ( ) ; current_octet |= fastinfosetconstants . document_type_identification ; boolean encodesystemid = ( documenttype . systemidentifier != null ) && ! documenttype . systemidentifier . isempty ( ) ; boolean encodepublicid = ( documenttype . publicidentifier != null ) && ! documenttype . publicidentifier . isempty ( ) ; if ( encodesystemid ) { current_octet |= fastinfosetconstants . document_type_systemid_presence ; } if ( encodepublicid ) { current_octet |= fastinfosetconstants . document_type_publicid_presence ; } flush_currentoctet ( ) ; if ( encodesystemid ) { encodeidentifyingstringorindex ( documenttype . systemidentifier , vocabulary . other_uris ) ; } if ( encodepublicid ) { encodeidentifyingstringorindex ( documenttype . publicidentifier , vocabulary . other_uris ) ; } if ( documenttype . instructions != null ) { for ( fastinfoset . document . processinginstruction instruction : documenttype . instructions ) { encodeprocessinginstruction ( instruction . target , instruction . content ) ; } } current_octet |= fastinfosetconstants . termination_pattern << 4 ; }
va	2	public static void main ( string [ ] args ) { bufferedreader reader = new bufferedreader ( new inputstreamreader ( system . in ) ) ; string name = "" ; try { system . out . print ( "digite o nome: " ) ; name = reader . readline ( ) ; } catch ( exception e ) { system . out . println ( "entrada inv\u00e1lida" ) ; system . exit ( 0 ) ; } int counter = 0 ; do { system . out . println ( name ) ; counter ++ ; } while ( counter < 100 ) ; }
va	1	public static void main ( string [ ] args ) { httpbroker broker = new httpbroker ( 6666 ) ; broker . start ( ) ; serviceproxy < clientservice > localservice = broker . registerservice ( "client" , new clientserviceimpl ( ) , clientservice . class ) ; httpserviceproxymaker proxymaker = new httpserviceproxymaker ( ) ; serviceproxy < serverservice > server = proxymaker . make ( new serviceaddress ( "localhost" , 9999 , "server" ) , serverservice . class ) ; for ( int i = 0 ; i < 1000 ; ++ i ) { system . out . println ( server . service ( ) . callserver ( localservice , i ) ) ; } broker . stop ( ) ; }
va	4	private list regeneratechildpaths ( path path , list children , int currentsize , int newsize ) { if ( currentsize == 1 ) { workingpaths . remove ( path ) ; currentsize = 0 ; children = new arraylist ( newsize ) ; pathstochildpaths . put ( path , children ) ; } else if ( newsize == 1 ) { workingpaths . removeall ( children ) ; workingpaths . add ( path ) ; pathstochildpaths . remove ( path ) ; return collections . empty_list ; } while ( currentsize < newsize ) { path child = new path ( ) ; workingpaths . add ( child ) ; children . add ( child ) ; currentsize ++ ; } while ( currentsize > newsize ) { path child = ( path ) children . remove ( children . size ( ) - 1 ) ; workingpaths . remove ( child ) ; currentsize -- ; } return children ; }
va	2	public engine ( ship parent , int enginenum ) { this . parent = parent ; this . enginenum = enginenum ; xorigin = parent . getx ( ) ; yorigin = parent . gety ( ) ; int totalpoints = parent . speed + ( parent . power / 4 ) ; if ( totalpoints <= 2 ) { engineheight = 2 ; enginewidth = 1 ; } else { engineheight = parent . map ( totalpoints , 1 , 1250 , 2 , 24 ) ; enginewidth = parent . map ( totalpoints , 1 , 1250 , 2 , 6 ) ; } engineheight *= ship . pixel_per_unit ; enginewidth *= ship . pixel_per_unit ; if ( enginenum == 0 ) { eatt = parent . body . e1att ; } else { eatt = parent . body . e2att ; } engine = new arraylist < point2d . double > ( ) ; engine . add ( new point2d . double ( 0 , 0 ) ) ; engine . add ( new point2d . double ( 0 , 0 ) ) ; engine . add ( new point2d . double ( 0 , 0 ) ) ; engine . add ( new point2d . double ( 0 , 0 ) ) ; }
va	9	public void run ( ) { while ( this . isrunning ) { if ( fetchstage . execute ( ) != 0 ) { log . error ( "fetch stage failed. please check" ) ; } if ( issuestage . execute ( ) != 0 ) { log . error ( "issue stage failed. please check" ) ; this . isrunning = false ; break ; } if ( readstage . execute ( ) != 0 ) { log . error ( "read stage failed. please check" ) ; this . isrunning = false ; break ; } if ( execstage . execute ( ) != 0 ) { log . error ( "exec stage failed. please check" ) ; this . isrunning = false ; break ; } if ( writestage . execute ( ) != 0 ) { log . error ( "write stage failed. please check" ) ; this . isrunning = false ; break ; } if ( this . isempty ( ) ) { log . debug ( "pipeline is now empty  stopping program execution." ) ; this . isrunning = false ; break ; } else { log . debug ( "pipeline still running." ) ; } try { if ( ++ cnt == 4 ) { cnt = 0 ; log . info ( "ticking at 1sec" ) ; } pipeline . sleep ( 250 ) ; } catch ( interruptedexception e ) { e . printstacktrace ( ) ; } log . debug ( "this is clock tick: " + clock ++ ) ; system . out . println ( "" ) ; } }
va	9	private void cargartable ( ) { try { if ( tipolista . equals ( lista_clientes ) ) { jbutton2 . settext ( "ver programas" ) ; jbutton2 . setvisible ( true ) ; model = new clientetablemodel ( factory . getclientedao ( ) . getall ( ) ) ; } if ( tipolista . equals ( lista_top_pesados ) ) { model = new programatablemodel ( factory . getprogramadao ( ) . gettop10maspesados ( ) ) ; } if ( tipolista . equals ( lista_top_paginas ) ) { model = new programatablemodel ( factory . getprogramadao ( ) . gettop10maspaginas ( ) ) ; } if ( tipolista . equals ( lista_programas ) || tipolista . equals ( lista_programas_gen_html ) || tipolista . equals ( lista_programas_gen_pdf ) ) { model = new programatablemodel ( factory . getprogramadao ( ) . getall ( ) ) ; jbutton2 . setvisible ( true ) ; } if ( tipolista . equals ( lista_programas ) ) { jbutton2 . setvisible ( true ) ; jbutton2 . settext ( "ver paginas" ) ; } } catch ( datospaooexception ex ) { mostrarexception ( "inicializar ventana" , "ocurrio un problema al inicializar lista de objetos" ) ; } jtable1 . setmodel ( model ) ; if ( model . getrowcount ( ) > 0 ) { jtable1 . getselectionmodel ( ) . setselectioninterval ( 0 , 0 ) ; } else { jbutton2 . setvisible ( false ) ; resultado = new resultado ( "no hay datos para mostrar" ) ; resultado . settipo ( resultado . tipo_resultado . error ) ; displayresultado . showresultado ( getframe ( ) , "inicializar ventana" , resultado ) ; } }
va	6	@ override public void run ( ) { player [ ] players = plugin . getserver ( ) . getonlineplayers ( ) ; player player ; long configtime = plugin . getconfig ( ) . getint ( "kick_timer" ) * 60 * 1000 ; for ( int i = 0 ; ( players . length - 1 ) >= i ; i ++ ) { long lastmoved = 0 ; player = players [ i ] ; usertable ut = plugin . getdatabase ( ) . find ( usertable . class ) . where ( ) . ieq ( "username" , player . getname ( ) ) . = ( "afk" , true ) . findunique ( ) ; if ( ut == null ) { return ; } lastmoved = system . currenttimemillis ( ) - ut . getafktime ( ) ; if ( player . isop ( ) ) { if ( plugin . getconfig ( ) . getboolean ( "kick_op" ) ) { if ( lastmoved > configtime ) { player . kickplayer ( "auto-kick: you were afk too long..." ) ; } } } else { if ( lastmoved > configtime ) { player . kickplayer ( "auto-kick: you were afk too long..." ) ; } } } }
va	3	private void notifyclientsdeviceremoved ( string [ ] devicenames ) { for ( int h = 0 ; h < devicenames . length ; h ++ ) { string devicename = devicenames [ h ] ; string message = "<delproperty device=\"" + devicename + "\" />" ; arraylist < indidevicelistener > list = this . getclientslisteningtodevice ( devicename ) ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { indidevicelistener c = list . get ( i ) ; c . sendxmlmessage ( message ) ; } arraylist < indidevicelistener > list2 = this . getclientslisteningtosingleproperties ( devicename ) ; for ( int i = 0 ; i < list2 . size ( ) ; i ++ ) { indidevicelistener c = list2 . get ( i ) ; c . sendxmlmessage ( message ) ; } } }
va	1	static void drawthoughtstem ( graphics g , int x , int y , int w , int h , int tx , int ty ) { for ( int i = 7 ; i > 0 ; i -= 2 ) { int b = border / 2 * ( 16 - i ) / 16 ; int x = x + w / 2 + i * i * ( tx - ( x + w / 2 ) ) / 8 / 8 ; int y = y + h + ( int ) ( math . pow ( i / 8. , .8 ) * ( ty - ( y + h ) ) ) ; g . setcolor ( color . white ) ; g . filloval ( x - b , y - b , 2 * b , 2 * b ) ; g . setcolor ( color . black ) ; g . drawoval ( x - b , y - b , 2 * b , 2 * b ) ; } }
va	9	protected void serialize_set ( set < ? > set , printwriter p , int level ) { if ( ! this . setliterals ) { serialize_tuple ( set , p , level ) ; return ; } if ( set . size ( ) > 0 ) { p . print ( "{" ) ; collection < ? > output = set ; if ( this . indent ) { set < ? > outputset = set ; try { outputset = new treeset < object > ( set ) ; } catch ( classcastexception x ) { } output = outputset ; } serialize_sequence_elements ( output , false , p , level + 1 ) ; if ( this . indent ) { for ( int i = 0 ; i < level ; ++ i ) p . print ( "  " ) ; } p . print ( "}" ) ; } else { serialize_tuple ( collections . empty_list , p , level + 1 ) ; } }
va	7	@ override public synchronized int registerclient ( string client_name , string first_tag , string second_tag ) { try { final namecomponent [ ] clientname = { new namecomponent ( client_name , "object" ) } ; final client client = clienthelper . narrow ( namingcontext . resolve ( clientname ) ) ; if ( first_tag . equals ( "t" ) || second_tag . equals ( "t" ) ) { clientupdater . appendtemperatureclient ( client ) ; } if ( first_tag . equals ( "p" ) || second_tag . equals ( "p" ) ) { clientupdater . appendpressureclient ( client ) ; } if ( first_tag . equals ( "h" ) || second_tag . equals ( "h" ) ) { clientupdater . appendhumidityclient ( client ) ; } } catch ( exception e ) { e . printstacktrace ( ) ; } return 0 ; }
va	7	public void updatelyricspane ( final track t ) { if ( ! currenttrack . equals ( t ) ) { currenttrack = t ; new thread ( ) { @ override public void run ( ) { string artist = t . get ( "artist" ) ; string title = t . get ( "title" ) ; string lyrics ; if ( artist . equals ( "dooooom" ) && title . equals ( "please give us all an a" ) ) { lyrics = "professor bhola  give us all a's\n" ; lyrics += "because we need to graduate!\n" ; lyrics += "[awesome guitar solo]\n" ; lyrics += "professor bhola  give us all a's\n" ; lyrics += "because we need to graduate!\n" ; } else { if ( artist != null && ! artist . isempty ( ) && title != null && ! title . isempty ( ) ) { system . out . println ( "." ) ; lyrics = lyricsfetcher . fetchlyrics ( t . get ( "artist" ) , t . get ( "title" ) ) ; } else { lyrics = "[lyrics unavailable]" ; } } platform . runlater ( new runnable ( ) { string lyrics ; @ override public void run ( ) { lyrics_text . settext ( lyrics ) ; } public runnable init ( string lyrics ) { this . lyrics = lyrics ; return this ; } } . init ( lyrics ) ) ; } } . start ( ) ; } }
va	9	public string writestate ( stringtoint startx , stringtoint starty ) { string data = "" ; data += reference . getname ( ) + "\n" ; for ( int i = 0 ; i < bytes . size ( ) ; i ++ ) data += bytes . get ( i ) . getkey ( ) + " " + bytes . get ( i ) . getvalue ( ) + "\n" ; if ( startx != null ) { data += startx . getkey ( ) + " " + startx . getvalue ( ) + "\n" ; data += starty . getkey ( ) + " " + starty . getvalue ( ) + "\n" ; } for ( int i = 0 ; i < ints . size ( ) ; i ++ ) data += ints . get ( i ) . getkey ( ) + " " + ints . get ( i ) . getvalue ( ) + "\n" ; for ( int i = 0 ; i < doubles . size ( ) ; i ++ ) data += doubles . get ( i ) . getkey ( ) + " " + doubles . get ( i ) . getvalue ( ) + "\n" ; for ( int i = 0 ; i < booleans . size ( ) ; i ++ ) data += booleans . get ( i ) . getkey ( ) + " " + booleans . get ( i ) . getvalue ( ) + "\n" ; for ( int i = 0 ; i < strings . size ( ) ; i ++ ) data += strings . get ( i ) . getkey ( ) + " " + strings . get ( i ) . getvalue ( ) + "\n" ; for ( int i = 0 ; i < colors . size ( ) ; i ++ ) { } for ( int i = 0 ; i < images . size ( ) ; i ++ ) { } for ( int i = 0 ; i < entities . size ( ) ; i ++ ) { } data += "end\n" ; return data ; }
va	8	static public void msdur ( stringbuilder sb , int ms ) { if ( ms < 0 ) { sb . append ( "-" ) ; msdur ( sb , - ms ) ; } else if ( ms < 1000 ) { sb . append ( ms ) ; sb . append ( "ms" ) ; } else if ( ms < 10000 ) { tenths ( sb , ms , 1000 ) ; sb . append ( s ) ; } else if ( ms < 60000 ) { sb . append ( ms / 1000 ) ; sb . append ( s ) ; } else if ( ms < 600000 ) { tenths ( sb , ms , 60000 ) ; sb . append ( m ) ; } else if ( ms < 3600000 ) { sb . append ( ms / 60000 ) ; sb . append ( m ) ; } else if ( ms < 36000000 ) { tenths ( sb , ms , 3600000 ) ; sb . append ( h ) ; } else if ( ms < 86400000 ) { sb . append ( ms / 3600000 ) ; sb . append ( h ) ; } else { tenths ( sb , ms , 86400000 ) ; sb . append ( d ) ; } }
va	6	private int compare ( object x , object y ) { if ( x == null ) return ( y == null ? 0 : - 1 ) ; else if ( y == null ) return 1 ; else { if ( x instanceof equivalentset ) x = ( ( equivalentset ) x ) . contents . get ( 0 ) ; if ( y instanceof equivalentset ) y = ( ( equivalentset ) y ) . contents . get ( 0 ) ; if ( comp != null ) return comp . compare ( ( elt ) x , ( elt ) y ) ; else { comparable cx = ( comparable ) x ; comparable cy = ( comparable ) y ; return cx . compareto ( cy ) ; } } }
va	8	public void menuaction ( jmenu selectmenu ) { mainframe mainframe = mainframe . getinstance ( ) ; attdframe workingframe = mainframe . getcurrentframe ( ) ; workingframe . setvisible ( false ) ; for ( int i = 0 ; i < menu . length ; i ++ ) { if ( menu [ i ] . equals ( selectmenu ) ) { switch ( i ) { case 0 : mainframe . setcurrentframeeditcourse ( ) ; break ; case 1 : mainframe . setcurrentframeeditstudent ( ) ; break ; case 2 : mainframe . setcurrentframecourseenroll ( ) ; break ; case 3 : mainframe . setcurrentframeattendance ( ) ; break ; case 4 : mainframe . setcurrentframeshowclassar ( ) ; break ; case 5 : mainframe . setcurrentframeshowclassrp ( ) ; break ; default : break ; } break ; } } workingframe = mainframe . getcurrentframe ( ) ; workingframe . display ( ) ; }
va	3	private void initalleles ( ) { for ( int acindex = 0 ; acindex < accessioncount ; acindex ++ ) { for ( int mindex = 0 ; mindex < markercount ; mindex ++ ) { int alcnt = allelename . get ( mindex ) . size ( ) ; datamatrix . get ( acindex ) . set ( mindex , new arraylist < double > ( alcnt ) ) ; for ( int alindex = 0 ; alindex < alcnt ; alindex ++ ) { datamatrix . get ( acindex ) . get ( mindex ) . add ( null ) ; } } } }
va	1	public void setgain ( double fgain ) throws basicplayerexception { if ( hasgaincontrol ( ) ) { double mingaindb = getminimumgain ( ) ; double ampgaindb = ( ( 10.0f / 20.0f ) * getmaximumgain ( ) ) - getminimumgain ( ) ; double cste = math . log ( 10.0 ) / 20 ; double valuedb = mingaindb + ( 1 / cste ) * math . log ( 1 + ( math . exp ( cste * ampgaindb ) - 1 ) * fgain ) ; m_gaincontrol . setvalue ( ( float ) valuedb ) ; notifyevent ( basicplayerevent . gain , getencodedstreamposition ( ) , fgain , null ) ; } else throw new basicplayerexception ( basicplayerexception . gaincontrolnotsupported ) ; }
va	6	public static void main ( string [ ] args ) { if ( args . length <= 0 ) { system . out . println ( "at least one arg (pebbler project) must be" + "specified" ) ; } string projectfilename = args [ 0 ] ; string nextflag = args . length > 1 ? args [ 1 ] : "" ; boolean createbook = nextflag . equals ( "--createbook" ) ? true : false ; file projectfile = new file ( projectfilename ) ; if ( ! projectfile . exists ( ) || ! projectfile . isfile ( ) ) { system . out . println ( "couldn't find file: " + projectfile . getpath ( ) ) ; system . exit ( - 1 ) ; } system . out . println ( "getting file from: " + projectfile . getpath ( ) ) ; pebblerproject project = pebblerproject . fromjson ( silentread ( projectfile ) ) ; file fullfile = new file ( projectfile . getabsolutepath ( ) ) ; string fullpath = fullfile . getparentfile ( ) . getabsolutepath ( ) ; project . compile ( fullpath ) ; if ( createbook ) { typesetter typesetter = new typesetter ( project ) ; typesetter . createbook ( fullpath ) ; } }
va	1	public void initfromstring ( string mapstring ) { this . map = mapstring ; game . entities = new copyonwritearraylist < entity > ( ) ; game . staticbackground = new copyonwritearraylist < entity > ( ) ; game . players = new copyonwritearraylist < entity > ( ) ; this . oldbackgroundelems = 0 ; loader l1 = new loader ( ) ; l1 . loadmapfromstring ( this . map ) ; game . game_width = ( game . field_width * game . block_size ) + 1 ; game . game_height = ( game . field_height * game . block_size ) + 1 ; dimension d = new dimension ( game . game_width , game . game_height ) ; this . setpreferredsize ( d ) ; this . setminimumsize ( d ) ; this . setmaximumsize ( d ) ; game . keys . resetkeys ( ) ; if ( this . frame != null ) { this . repack ( ) ; } }
va	1	private void initialisationeditionstation ( station station ) { txtserialnumber . settext ( station . getserialnumber ( ) ) ; txtetat . settext ( station . getetat ( ) ) ; txtlatitude . settext ( station . getlatitude ( ) ) ; txtlongitude . settext ( station . getlongitude ( ) ) ; try { jgooglemapeditorpan googlemap = new jgooglemapeditorpan ( ) ; googlemap . showcoordinate ( station . getlatitude ( ) , station . getlongitude ( ) , 215 , 200 ) ; swappanel ( panelgooglemap , googlemap ) ; } catch ( exception ex ) { logger . getlogger ( interfaceadmingestion . class . getname ( ) ) . log ( level . severe , null , ex ) ; } }
va	2	public string todayordering ( ) throws exception { logger . info ( "init today ordering start." ) ; param param = paramserviceimpl . findparambycode ( otherconstants . code_start_ordering ) ; if ( ! otherconstants . state_ordering_yes . equals ( param . getparamvalue ( ) ) ) { request . setattribute ( otherconstants . today_ordering_info , otherconstants . today_ordering_stop ) ; logger . info ( "init today ordering end." ) ; return resultconstants . today_ordering ; } list < price > prices = orderingserviceimpl . todayordering ( ) ; param = paramserviceimpl . findparambycode ( otherconstants . code_today_food_info ) ; if ( param != null ) { request . setattribute ( otherconstants . today_ordering_info , param . getparamdis ( ) ) ; } string [ ] numlist = { "1" , "2" , "3" , "4" , "5" } ; request . setattribute ( otherconstants . today_ordering , prices ) ; request . setattribute ( otherconstants . num_list , numlist ) ; logger . info ( "init today ordering end." ) ; return resultconstants . today_ordering ; }
va	7	private void verifyforeignkeyconstraints ( tuple tuple ) throws databaseexception { for ( schema . foreignkey fk : schema . getforeignkeys ( ) ) { table reftable = fk . getreftable ( ) ; int [ ] localkeypositions = fk . getforeignkeypositions ( ) ; object [ ] localkeyvalues = new object [ localkeypositions . length ] ; attribute . type [ ] localkeytypes = new attribute . type [ localkeypositions . length ] ; for ( int i = 0 ; i < localkeypositions . length ; ++ i ) { localkeyvalues [ i ] = tuple . getvalueat ( localkeypositions [ i ] ) ; localkeytypes [ i ] = schema . getattributes ( ) [ localkeypositions [ i ] ] . gettype ( ) ; } int [ ] refkeypositions = reftable . getschema ( ) . getprimarykeypositions ( ) ; boolean matchfound = false ; for ( tuple reftuple : reftable . gettuples ( ) ) { matchfound = true ; for ( int i = 0 ; i < localkeypositions . length ; ++ i ) { if ( ! tuple . valuesequal ( localkeytypes [ i ] , localkeyvalues [ i ] , reftuple . getvalueat ( refkeypositions [ i ] ) ) ) { matchfound = false ; break ; } } if ( matchfound ) break ; } if ( ! matchfound ) { throw new databaseexception ( "referential constraint to table '" + reftable . getname ( ) + "' not met." ) ; } } }
va	9	public void initopenedxmltree ( nodelist childels , point parentpoint ) { try { runnable r = new runnable ( ) { nodelist childels ; point pt ; public void setargs ( nodelist childels , point p ) { this . childels = childels ; pt = p ; } public void run ( ) { vxd . controller . refreshxmlviews ( ) ; try { runnable r = new runnable ( ) { nodelist childels ; point grandpoint ; public void setargs ( nodelist childels , point p ) { this . childels = childels ; grandpoint = p ; } public void run ( ) { for ( int l = 0 ; l < childels . getlength ( ) ; ++ l ) { node childnd = childels . item ( l ) ; if ( childnd instanceof element ) { element childel = ( element ) childnd ; if ( vxd . debug ) system . out . println ( "child: " + childel . gettagname ( ) ) ; vxd . controller . addloadedelementicon ( childel , grandpoint . x , grandpoint . y ) ; try { runnable r = new runnable ( ) { element childel ; public void setargs ( element childel ) { this . childel = childel ; } public void run ( ) { nodelist grandels = childel . getchildnodes ( ) ; if ( childel . getattribute ( "xpos" ) != null && childel . getattribute ( "ypos" ) != null ) { try { int x = integer . parseint ( childel . getattribute ( "xpos" ) ) ; int y = integer . parseint ( childel . getattribute ( "ypos" ) ) ; point greatpoint = new point ( x , y ) ; initopenedxmltree ( grandels , greatpoint ) ; } catch ( numberformatexception nfe ) { ; } } } } ; class [ ] args = new class [ 1 ] ; args [ 0 ] = element . class ; object [ ] prms = new object [ 1 ] ; prms [ 0 ] = childel ; r . getclass ( ) . getmethod ( "setargs" , args ) . invoke ( r , prms ) ; swingutilities . invokelater ( r ) ; } catch ( exception grgdex ) { grgdex . printstacktrace ( ) ; } } } } } ; class [ ] args = new class [ 2 ] ; args [ 0 ] = nodelist . class ; args [ 1 ] = point . class ; object [ ] prms = new object [ 2 ] ; prms [ 0 ] = childels ; prms [ 1 ] = pt ; r . getclass ( ) . getmethod ( "setargs" , args ) . invoke ( r , prms ) ; swingutilities . invokelater ( r ) ; } catch ( exception rex ) { rex . printstacktrace ( ) ; } ; } } ; class [ ] args = new class [ 2 ] ; args [ 0 ] = nodelist . class ; args [ 1 ] = point . class ; object [ ] prms = new object [ 2 ] ; prms [ 0 ] = childels ; prms [ 1 ] = parentpoint ; r . getclass ( ) . getmethod ( "setargs" , args ) . invoke ( r , prms ) ; swingutilities . invokelater ( r ) ; } catch ( exception rex ) { rex . printstacktrace ( ) ; } }
va	9	public ranker create ( rankertype ranker ) { switch ( ranker ) { case conjunctive : return new rankerconjunctive ( indexer ) ; case favorite : case cosine : return new cosineranker ( indexer ) ; case ql : return new qlranker ( indexer ) ; case phrase : return new phraseranker ( indexer ) ; case linear : return new linearranker ( indexer ) ; case numviews : return new numviewsranker ( indexer ) ; case fullscan : case none : return new simpleranker ( indexer ) ; default : } throw new illegalargumentexception ( "unrecognized ranker type:  " + ranker ) ; }
va	9	private jsonarray readarray ( ) throws jsonexception { jsonarray result = new jsonarray ( ) ; boolean hastrailingseparator = false ; while ( true ) { switch ( nextcleaninternal ( ) ) { case - 1 : throw syntaxerror ( "unterminated array" ) ; case ] : if ( hastrailingseparator ) { result . put ( null ) ; } return result ; case   : case ; : result . put ( null ) ; hastrailingseparator = true ; continue ; default : pos -- ; } result . put ( nextvalue ( ) ) ; switch ( nextcleaninternal ( ) ) { case ] : return result ; case   : case ; : hastrailingseparator = true ; continue ; default : throw syntaxerror ( "unterminated array" ) ; } } }
va	1	public transactionviewer ( final inventory inv ) { final transactionreport transrep = loaders . loadtransactionreport ( ) ; settitle ( "transaction viewer" ) ; setresizable ( false ) ; setalwaysontop ( true ) ; setdefaultcloseoperation ( jframe . dispose_on_close ) ; setbounds ( 100 , 100 , 535 , 352 ) ; contentpane = new jpanel ( ) ; contentpane . setborder ( new emptyborder ( 5 , 5 , 5 , 5 ) ) ; setcontentpane ( contentpane ) ; contentpane . setlayout ( null ) ; jlabel lbltransactioncode = new jlabel ( "transaction code:" ) ; lbltransactioncode . setbounds ( 10 , 11 , 95 , 14 ) ; contentpane . add ( lbltransactioncode ) ; final jtextpane textpane = new jtextpane ( ) ; textpane . setbounds ( 20 , 36 , 499 , 244 ) ; contentpane . add ( textpane ) ; final jlabel lblrm = new jlabel ( "rm0.00" ) ; lblrm . setfont ( new font ( "tahoma" , font . plain , 18 ) ) ; lblrm . setbounds ( 10 , 291 , 130 , 22 ) ; contentpane . add ( lblrm ) ; codefield = new jtextfield ( ) ; codefield . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent e ) { long millis = long . parselong ( codefield . gettext ( ) ) ; date date = new date ( millis ) ; dateformat dateformat = new simpledateformat ( "yyyymmdd" ) ; string transdate = dateformat . format ( date ) ; int itemindex = transrep . dates . indexof ( transdate ) ; if ( itemindex > - 1 ) { transactionlist translist = transrep . gettranslist ( transdate ) ; transaction trans = translist . gettrans ( millis ) ; textpane . settext ( trans . generatetransactiontext ( inv ) ) ; lblrm . settext ( "rm" + trans . totalprice ) ; } } } ) ; codefield . setbounds ( 115 , 8 , 186 , 20 ) ; contentpane . add ( codefield ) ; codefield . setcolumns ( 10 ) ; }
va	8	@ override public void marshal ( element amdsec , document doc ) { super . marshal ( amdsec , doc ) ; string metsns = ns . mets . ns ( ) ; if ( this . techmd != null ) { for ( mdsec mds : this . techmd ) { element techmd = doc . createelementns ( metsns , "mets:techmd" ) ; mds . marshal ( techmd , doc ) ; amdsec . appendchild ( techmd ) ; } } if ( this . rightsmd != null ) { for ( mdsec mds : this . rightsmd ) { element rightsmd = doc . createelementns ( metsns , "mets:rightsmd" ) ; mds . marshal ( rightsmd , doc ) ; amdsec . appendchild ( rightsmd ) ; } } if ( this . sourcemd != null ) { for ( mdsec mds : this . sourcemd ) { element sourcemd = doc . createelementns ( metsns , "mets:sourcemd" ) ; mds . marshal ( sourcemd , doc ) ; amdsec . appendchild ( sourcemd ) ; } } if ( this . digiprovmd != null ) { for ( mdsec mds : this . digiprovmd ) { element digiprovmd = doc . createelementns ( metsns , "mets:digiprovmd" ) ; mds . marshal ( digiprovmd , doc ) ; amdsec . appendchild ( digiprovmd ) ; } } }
va	0	public void testtostringreconstruction ( ) { asserttrue ( "integer(0) cannot be reconstructed from its tostring() value!" , int0 . equals ( new integer ( int0 . tostring ( ) ) ) ) ; asserttrue ( "integer(1) cannot be reconstructed from its tostring() value!" , int1 . equals ( new integer ( int1 . tostring ( ) ) ) ) ; asserttrue ( "integer(-1) cannot be reconstructed from its tostring() value!" , intneg1 . equals ( new integer ( intneg1 . tostring ( ) ) ) ) ; asserttrue ( "integer(long.max_value) cannot be reconstructed from its tostring() value!" , intlongmax . equals ( new integer ( intlongmax . tostring ( ) ) ) ) ; asserttrue ( "integer(long.min_value) cannot be reconstructed from its tostring() value!" , intlongmin . equals ( new integer ( intlongmin . tostring ( ) ) ) ) ; }
va	0	@ test @ transactional ( propagation = propagation . requires_new ) public void getallcontents ( ) { set < content > got = new hashset < content > ( contentservice . getallcontents ( ) ) ; set < content > expected = new hashset < content > ( ) ; expected . add ( contentservice . getcontent ( fix . apelid ) ) ; expected . add ( contentservice . getcontent ( fix . gazetaid ) ) ; expected . add ( contentservice . getcontent ( fix . zakazaneid ) ) ; assertequals ( got , expected ) ; log . info ( "getting all the contents is ok." ) ; }
va	2	public static void main ( string [ ] args ) { try { uimanager . setlookandfeel ( "org.pushingpixels.substance.api.skin.substancegraphiteaqualookandfeel" ) ; } catch ( exception e ) { } final xbpadpresetcontainer container = new xbpadpresetcontainer ( ) ; final xbpadlogic logic = new xbpadlogic ( container ) ; inputstream is = new bufferedinputstream ( xbpadgui . class . getresourceasstream ( "/assets/icon.jpg" ) ) ; image image = null ; try { image = imageio . read ( is ) ; } catch ( ioexception e1 ) { e1 . printstacktrace ( ) ; } final xbpadframe frame = new xbpadframe ( logic , image ) ; final xbpadgui ui = new xbpadgui ( frame , container ) ; ui . xgetminimalize ( ) . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent arg0 ) { frame . setstate ( frame . iconified ) ; } } ) ; ui . xgetquit ( ) . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent e ) { logic . clean ( ) ; system . exit ( 0 ) ; } } ) ; frame . settitle ( "xbpad - ver 1.0_alpha" ) ; frame . setresizable ( false ) ; frame . setcontentpane ( ui ) ; frame . seticonimage ( image ) ; frame . pack ( ) ; frame . setvisible ( true ) ; }
va	2	public inputfield ( ) { super ( ) ; settext ( "type here!" ) ; setcolumns ( 10 ) ; addmouselistener ( new mouselistener ( ) { @ override public void mouseclicked ( mouseevent e ) { if ( gettext ( ) . equals ( "type here!" ) ) settext ( "" ) ; requestfocusinwindow ( ) ; } @ override public void mousepressed ( mouseevent e ) { } @ override public void mousereleased ( mouseevent e ) { } @ override public void mouseentered ( mouseevent e ) { } @ override public void mouseexited ( mouseevent e ) { } } ) ; addkeylistener ( new keylistener ( ) { @ override public void keytyped ( keyevent e ) { } @ override public void keypressed ( keyevent e ) { if ( e . getkeycode ( ) == 10 ) { sendmessage ( ) ; settext ( "" ) ; } } @ override public void keyreleased ( keyevent e ) { } } ) ; }
va	3	public static node mostunique ( list < node > neighborhood ) { double greatesterror = 0 ; double currenterror = 0 ; node unique = null ; for ( node current : neighborhood ) { currenterror = calculateerror ( current , neighborhood ) ; if ( currenterror >= greatesterror ) { greatesterror = currenterror ; unique = current ; } } if ( unique != null ) { greatesterror /= ( neighborhood . size ( ) - 1 ) ; unique . seterror ( greatesterror ) ; } else { system . out . println ( neighborhood . size ( ) ) ; } return unique ; }
va	3	public void setpop ( population p ) { pop = p ; ncells = p . getgenomelength ( ) / 2 ; popsize = p . getpopsize ( ) ; vertical = ncells > popsize ; int w = def_width , h = def_height ; if ( vertical ) { int t = w ; w = h ; h = t ; } int w2 = w / ncells ; int h2 = h / popsize - 1 ; pixelsize = math . clamp ( math . min ( w2 , h2 ) , 1 , 3 ) ; gensep = ( pixelsize > 1 ) ? 1 : 0 ; drawncells = math . clamp ( w / pixelsize , 0 , ncells ) ; drawnpop = math . clamp ( h / ( pixelsize + gensep ) , 0 , popsize ) ; plotsize = vertical ? new point ( drawnpop * ( pixelsize + gensep ) , drawncells * pixelsize ) : new point ( drawncells * pixelsize , drawnpop * ( pixelsize + gensep ) ) ; }
va	3	public dimension getrendereddimension ( image image , int canvaswidth , int canvasheight ) { int imagewidth = image . getwidth ( null ) ; int imageheight = image . getheight ( null ) ; if ( ! flickrframe . isfullscreen ( ) ) { canvaswidth -= border_size * 2 ; canvasheight -= border_size * 2 ; } float imageratio = ( float ) imagewidth / ( float ) imageheight ; float thisratio = ( float ) canvaswidth / ( float ) canvasheight ; int renderedwidth , renderedheight ; if ( imageratio > thisratio ) { renderedwidth = canvaswidth ; renderedheight = ( int ) ( canvaswidth / imageratio ) ; } else if ( imageratio < thisratio ) { renderedheight = canvasheight ; renderedwidth = ( int ) ( canvasheight * imageratio ) ; } else { renderedwidth = canvaswidth ; renderedheight = canvasheight ; } return new dimension ( renderedwidth , renderedheight ) ; }
va	5	public boolean canappend ( writecommand command ) throws ioexception { switch ( command . opitem . op ) { case opitem . op_del : if ( command . opitem . number != this . number ) { return false ; } break ; case opitem . op_add : if ( this . datafile . getlength ( ) + command . data . length >= journalstore . file_size ) { return false ; } if ( this . datasize + command . data . length >= datafileappender . this . maxwritebatchsize ) { return false ; } break ; default : throw new runtimeexception ( "unknow op type " + command . opitem ) ; } return true ; }
va	8	vector < integer > getneighboringindexes ( int index ) { vector < integer > result = new vector < integer > ( 6 ) ; int row = getrow ( index ) ; int col = getcolumn ( index ) ; int offset = getoffset ( row ) ; if ( row < numrows - 1 ) { if ( col + offset > 0 ) { result . add ( getindex ( row + 1 , col + offset - 1 ) ) ; } if ( col + offset < numcolumns - 1 ) { result . add ( getindex ( row + 1 , col + offset ) ) ; } } if ( col > 0 ) { result . add ( getindex ( row , col - 1 ) ) ; } if ( col < numcolumns - 1 ) { result . add ( getindex ( row , col + 1 ) ) ; } if ( row > 0 ) { if ( col + offset > 0 ) { result . add ( getindex ( row - 1 , col + offset - 1 ) ) ; } if ( col + offset < numcolumns - 1 ) { result . add ( getindex ( row - 1 , col + offset ) ) ; } } result . trimtosize ( ) ; return result ; }
va	0	public hoge ( lr lr , shootingweaponcharacter weapon ) { setweapon ( weapon ) ; setx ( commons . center_x + ( 165 * lr . signum ( ) ) ) ; sety ( 40 ) ; weaponview . setx ( getx ( ) ) . sety ( gety ( ) + 5 ) . setwidth ( weapon . getwidth ( ) ) . setheight ( weapon . getheight ( ) ) . setscale ( 2 ) . setcolor ( weapon . getcolor ( ) ) ; remainbulletview . setx ( getx ( ) ) . sety ( gety ( ) - 25 ) . setscale ( 0.3f ) . setcolor ( color . white ) ; }
va	9	@ override public object getvalueat ( int rowindex , int columnindex ) { switch ( columnindex ) { case 0 : return competition . getraces ( ) . get ( rowindex ) . getnumber ( ) ; case 1 : return competition . getraces ( ) . get ( rowindex ) . getjogger ( ) . getname ( ) ; case 2 : return ( competition . getstarttime ( ) != null ) ? new simpledateformat ( "dd/mm/yyyy hh:mm:ss" ) . format ( competition . getstarttime ( ) ) : "--/--/---- --:--:--" ; case 3 : return ( competition . getraces ( ) . get ( rowindex ) . getendtime ( ) != null ) ? new simpledateformat ( "hh:mm:ss" ) . format ( competition . getraces ( ) . get ( rowindex ) . getendtime ( ) ) : "--:--:--" ; case 4 : return ( competition . getstarttime ( ) == null || competition . getraces ( ) . get ( rowindex ) . getendtime ( ) == null ) ? "--:--:--" : new simpledateformat ( "hh:mm:ss" ) . format ( new date ( competition . getraces ( ) . get ( rowindex ) . getduration ( ) . gettime ( ) - ( 1000 * 60 * 60 ) ) ) ; default : return "inconnu" ; } }
va	4	public static bitset frombytearray ( byte [ ] bytes ) { bitset bits = new bitset ( ) ; for ( int i = 0 ; i < bytes . length * 8 ; i ++ ) { if ( ( bytes [ bytes . length - i / 8 - 1 ] & ( 1 << ( i % 8 ) ) ) > 0 ) { bits . set ( i ) ; } } for ( int k = bits . size ( ) - 1 ; k >= 0 ; k -- ) { system . out . print ( ( bits . get ( k ) ) ? "1" : "0" ) ; } system . out . println ( ) ; return bits ; }
va	3	public static texture [ ] [ ] replacecolors ( texture [ ] [ ] textures , int [ ] fromcolors , int [ ] tocolors ) { if ( textures . length == 0 ) return null ; texture [ ] [ ] newtextures = new texture [ textures . length ] [ textures [ 1 ] . length ] ; for ( int i = 0 ; i < textures . length ; i ++ ) for ( int j = 0 ; j < textures [ 1 ] . length ; j ++ ) newtextures [ i ] [ j ] = textures [ i ] [ j ] . replacecolors ( fromcolors , tocolors ) ; return newtextures ; }
va	9	private void jbutton1actionperformed ( java . awt . event . actionevent evt ) { nanopost np ; byte [ ] parenthash = encryptionprovider . empty_hash_sha256 ; string parenthashstr = edparenthash . gettext ( ) ; if ( ! parenthashstr . trim ( ) . isempty ( ) ) { if ( ( parenthashstr . length ( ) == encryptionprovider . sha_256_hash_size_bytes * 2 ) && parenthashstr . matches ( "[a-f0-9]+" ) ) { parenthash = byteutils . stringtobytes ( parenthashstr ) ; } } if ( ! edattachfile . gettext ( ) . isempty ( ) ) { file attachfile = new file ( edattachfile . gettext ( ) ) ; if ( ! attachfile . exists ( ) ) { joptionpane . showmessagedialog ( this , "selected attach file does not exist" , "error" , joptionpane . error_message ) ; return ; } np = nanopostfactory . createnanopost ( txtposttext . gettext ( ) , parenthash , attachfile ) ; } else { np = nanopostfactory . createnanopost ( txtposttext . gettext ( ) , parenthash , null ) ; } file containerfile ; if ( rbrandomcontainer . isselected ( ) ) { containerfile = this . getrandomcontainerpng ( ) ; if ( containerfile == null ) { joptionpane . showmessagedialog ( this , "there is no any png file in folder " + mainclass . containers_dir , "error" , joptionpane . error_message ) ; return ; } } else { containerfile = new file ( edcontainerfile . gettext ( ) ) ; } if ( ! containerfile . exists ( ) ) { joptionpane . showmessagedialog ( this , "selected container file does not exists." , "error" , joptionpane . error_message ) ; return ; } file outputfile = null ; nanopost nanopost = null ; try { outputfile = new file ( mainclass . outbox_dir + system . getproperty ( "file.separator" ) + system . currenttimemillis ( ) + ".png" ) ; imageutils . encodeintoimage ( containerfile , outputfile , np . getasbytes ( ) , edboardcode . gettext ( ) ) ; byte [ ] databytes = imageutils . trytodecodesteganoimage ( byteutils . readbytesfromfile ( outputfile ) , edboardcode . gettext ( ) ) ; nanopost = nanopostfactory . getnanopostfrombytes ( databytes , true ) ; nanopost . setsourceimagedata ( byteutils . readbytesfromfile ( outputfile ) ) ; nanopost . savetofile ( true ) ; nanopost . clearallbinarydata ( ) ; nanopost = null ; databytes = null ; } catch ( malformednanopostexception | ioexception | nosuchalgorithmexception | nosuchpaddingexception | invalidkeyexception | invalidalgorithmparameterexception | illegalblocksizeexception | badpaddingexception ex ) { joptionpane . showmessagedialog ( null , ex . getlocalizedmessage ( ) , "an error occured" , joptionpane . error_message ) ; } finally { outputfile . delete ( ) ; } }
va	2	public static string getasstring ( long bytes ) { string s = bytes + " b" ; string [ ] units = new string [ ] { "b" , "k" , "m" , "g" , "t" } ; for ( int i = 5 ; i > 0 ; i -- ) { double step = math . pow ( 1024 , i ) ; if ( bytes > step ) { double absolute = math . abs ( bytes / step ) ; s = string . format ( "%.2f" , absolute ) + " " + units [ i ] + "b" ; break ; } } return s ; }
va	7	@ override public jsonelement serialize ( criteria criteria , type type , jsonserializationcontext jsc ) { jsonobject json = new jsonobject ( ) ; json . addproperty ( "field" , criteria . getfield ( ) . ordinal ( ) + 1 ) ; try { string operator = criteria . getoperator ( ) . tostring ( ) ; if ( operator . equals ( operators . startwith . tostring ( ) ) ) operator = "start%20with" ; else if ( operator . equals ( operators . equals . tostring ( ) ) ) operator = urlencoder . encode ( "=" , "utf-8" ) ; else if ( operator . equals ( operators . greaterthan . tostring ( ) ) ) operator = urlencoder . encode ( ">" , "utf-8" ) ; else if ( operator . equals ( operators . greaterthanequal . tostring ( ) ) ) operator = urlencoder . encode ( ">=" , "utf-8" ) ; else if ( operator . equals ( operators . lessthan . tostring ( ) ) ) operator = urlencoder . encode ( "<" , "utf-8" ) ; else if ( operator . equals ( operators . lessthanequal . tostring ( ) ) ) operator = urlencoder . encode ( "<=" , "utf-8" ) ; json . addproperty ( "operator" , operator ) ; } catch ( unsupportedencodingexception ex ) { logger . getlogger ( criteriaserializer . class . getname ( ) ) . log ( level . severe , "wrong encoding scheme!" , ex ) ; } json . addproperty ( "value" , criteria . getvalue ( ) ) ; return json ; }
va	8	public void actionperformed ( actionevent e ) { if ( e . getsource ( ) == left ) { halign = alignment . left ; return ; } if ( e . getsource ( ) == center ) { halign = alignment . center ; return ; } if ( e . getsource ( ) == right ) { halign = alignment . right ; return ; } if ( e . getsource ( ) == top ) { valign = alignment . top ; return ; } if ( e . getsource ( ) == middle ) { valign = alignment . middle ; return ; } if ( e . getsource ( ) == bottom ) { valign = alignment . bottom ; return ; } if ( e . getsource ( ) == fbutton ) { font newfont = fontdialog . getfont ( font ) ; if ( newfont == null ) return ; font = newfont ; fbutton . setfont ( font ) ; } }
va	7	public boolean initializedb ( ) { try { if ( ! isdabaseinitialized ( ) ) { getdbconnection ( ) . createstatement ( ) . execute ( createstring1 ) ; getdbconnection ( ) . createstatement ( ) . execute ( createstring2 ) ; updatedb101b ( ) ; updatedb102b ( ) ; initstationdata ( ) ; return true ; } if ( ! updatedto ( app_version_101 ) && ! updatedto ( app_version_102 ) ) { if ( ! updatedb101b ( ) ) { log . error ( "unexpceted error  can't update to current version" ) ; system . exit ( 0 ) ; } } if ( ! updatedto ( app_version_102 ) ) { if ( ! updatedb102b ( ) ) { log . error ( "unexpceted error  can't update to current version" ) ; system . exit ( 0 ) ; } } } catch ( sqlexception e ) { log . error ( "error" , e ) ; } return false ; }
va	4	public void fill ( final color [ ] [ ] framebuffer ) { if ( framebuffer == null ) { throw new nullpointerexception ( "'framebuffer' must not be 'null'" ) ; } color c = ( getattributes ( ) . containskey ( "color" ) ) ? ( color ) getattributes ( ) . get ( "color" ) : color . white ; for ( int i = getp ( ) . get ( 0 , 0 ) . intvalue ( ) ; i < getp ( ) . get ( 0 , 0 ) . intvalue ( ) + getd ( ) . get ( 0 , 0 ) . intvalue ( ) ; ++ i ) { for ( int j = getp ( ) . get ( 1 , 0 ) . intvalue ( ) ; j < getp ( ) . get ( 1 , 0 ) + getd ( ) . get ( 1 , 0 ) ; ++ j ) { framebuffer [ i ] [ j ] = c ; } } }
va	0	public unit ( string name , string type , boolean isrange , boolean isair , boolean team , int landattack , int airattack , int range , int defense , int shift ) { this . name = name ; this . type = type ; this . ranged = isrange ; this . air = isair ; this . team = team ; this . landattack = landattack ; this . airattack = airattack ; this . range = range ; this . defense = defense ; this . shift = shift ; shiftdone = false ; attackdone = false ; health = 8 ; }
va	3	void actionverifycert ( int num ) { x509certificate c = certificates [ num ] ; x509certificate cacert = certificates [ cacertspane . getcacertnum ( ) ] ; if ( cacert == null ) { usercertspane . clearverified ( num ) ; apdulog . log ( "no loaded ca certificate selected." ) ; return ; } try { c . verify ( cacert . getpublickey ( ) ) ; usercertspane . setverified ( num , true ) ; } catch ( signatureexception se ) { usercertspane . setverified ( num , false ) ; } catch ( exception ex ) { usercertspane . clearverified ( num ) ; apdulog . log ( "verification of signature failed." ) ; } }
va	3	private void mostrarcidades ( list < cidades > cidades ) { while ( tmcidades . getrowcount ( ) > 0 ) { tmcidades . removerow ( 0 ) ; } if ( cidades . isempty ( ) ) { joptionpane . showmessagedialog ( this , "nenhuma cidade encontrada!" , "erro de busca" , joptionpane . error_message , icones . geticoneerro ( ) ) ; } else { string [ ] campos = new string [ ] { null , null , null , null } ; for ( int i = 0 ; i < cidades . size ( ) ; i ++ ) { tmcidades . addrow ( campos ) ; tmcidades . setvalueat ( cidades . get ( i ) . getcodigo ( ) , i , 0 ) ; tmcidades . setvalueat ( cidades . get ( i ) . getnome ( ) , i , 1 ) ; tmcidades . setvalueat ( cidades . get ( i ) . getuf ( ) , i , 2 ) ; tmcidades . setvalueat ( cidades . get ( i ) . getddd ( ) , i , 3 ) ; } } }
va	7	@ override public boolean onresponse ( message message ) { int hour = calendar . getinstance ( ) . get ( calendar . hour_of_day ) ; if ( hour <= 9 ) { for ( string word : moringwords ) { if ( message . content . contains ( word ) ) { message . reply ( moringresponseword [ new random ( ) . nextint ( moringresponseword . length ) ] ) ; return true ; } } } else if ( hour >= 21 || hour < 3 ) { for ( string word : nigthwords ) { if ( message . content . contains ( word ) ) { message . reply ( nigthresponsewords [ new random ( ) . nextint ( nigthresponsewords . length ) ] ) ; return true ; } } } return false ; }
va	1	@ override public void updateimage ( image image , int personid ) throws dataaccessexception { preparedstatement updateimagestatement = null ; try { updateimagestatement = connection . preparestatement ( sqlquery . update_image . getvalue ( ) ) ; updateimagestatement . setstring ( 1 , image . getfilename ( ) ) ; updateimagestatement . setstring ( 2 , image . getlocalfilename ( ) ) ; updateimagestatement . setint ( 3 , personid ) ; updateimagestatement . executeupdate ( ) ; } catch ( sqlexception e ) { logger . error ( e . getmessage ( ) ) ; throw new dataaccessexception ( e . getmessage ( ) ) ; } finally { closestatement ( updateimagestatement ) ; } }
va	4	public void minheapify ( int index ) { for ( int left = leftchild ( index ) ; left < heap . size ( ) ; index = left ) { if ( left + 1 < heap . size ( ) && heap . get ( left + 1 ) . key < heap . get ( left ) . key ) { left ++ ; } if ( heap . get ( left ) . key < heap . get ( index ) . key ) { swap ( left , index ) ; } else { break ; } } }
va	1	@ generatemicrobenchmark public int charsetencoder ( ) throws unsupportedencodingexception { int countbytes = 0 ; for ( int stringindex = 0 ; stringindex < strings . size ( ) ; stringindex ++ ) { string source = strings . get ( stringindex ) ; int length = source . length ( ) ; source . getchars ( 0 , length , chars , 0 ) ; charbuffer . position ( 0 ) ; charbuffer . limit ( length ) ; encoder . reset ( ) ; encoder . encode ( charbuffer , buffysummers , true ) ; countbytes += buffysummers . position ( ) ; buffysummers . clear ( ) ; } return countbytes ; }
va	1	public dbsaverestore ( ) { try { this . services = new dbconnectionfactory ( ) ; } catch ( servicelocatorexception e ) { e . printstacktrace ( ) ; } this . hosteldaoimpl = new hosteldaoimpl ( services ) ; this . beddao = new beddaoimpl ( services ) ; this . contactdao = new contactdaoimpl ( services ) ; this . addressdao = new addressdaoimpl ( services ) ; this . policydao = new policydaoimpl ( services ) ; this . searchdao = new searchdaoimpl ( services ) ; this . userdao = new userdaoimpl ( services ) ; this . bookingdao = new bookingdaoimpl ( services ) ; }
va	0	public static void main ( string [ ] args ) { int [ ] array = new int [ ] { 1 , 3 , 5 , 7 , 9 , 11 } ; segmenttree tree = new segmenttree ( array ) ; system . out . println ( tree . sumrange ( 1 , 4 ) ) ; system . out . println ( tree . sumrange ( 1 , 1 ) ) ; system . out . println ( tree . sumrange ( 0 , 5 ) ) ; system . out . println ( tree . sumrange ( 0 , 0 ) ) ; }
va	4	private jpanel buildscorereadingpreferencespanel ( ) { scoregametypecombobox = new jcombobox ( ) ; scoregametypecombobox . additemlistener ( this ) ; scoregamespeedcombobox = new jcombobox ( ) ; scoregamespeedcombobox . additem ( "largo" ) ; scoregamespeedcombobox . additem ( "adagio" ) ; scoregamespeedcombobox . additem ( "moderato" ) ; scoregamespeedcombobox . additem ( "allegro" ) ; scoregamespeedcombobox . additem ( "presto" ) ; scoregamespeedcombobox . additemlistener ( this ) ; jpanel scoregamepanel = new jpanel ( ) ; scoregamepanel . add ( scoregametypecombobox ) ; scoregamepanel . add ( scoregamespeedcombobox ) ; localizables . add ( new localizable . namedgroup ( scoregamepanel , "_menuexercises" ) ) ; scorekeycombobox = new jcombobox ( ) ; scorekeycombobox . additemlistener ( this ) ; scorenotescombobox = new jcombobox ( ) ; scorenotescombobox . additemlistener ( this ) ; scorealterationscombobox = new jcombobox ( ) ; scorealterationscombobox . additemlistener ( this ) ; jpanel scorekeypanel = new jpanel ( ) ; scorekeypanel . add ( scorekeycombobox ) ; scorekeypanel . add ( scorealterationscombobox ) ; scorekeypanel . add ( scorenotescombobox ) ; localizables . add ( new localizable . namedgroup ( scorekeypanel , "_menunotes" ) ) ; scorewholecheckbox = new jcheckbox ( "" , true ) ; scorewholecheckbox . additemlistener ( this ) ; scorehalfcheckbox = new jcheckbox ( "" , true ) ; scorehalfcheckbox . additemlistener ( this ) ; scoredottedhalfcheckbox = new jcheckbox ( "" , false ) ; scoredottedhalfcheckbox . additemlistener ( this ) ; scorequartercheckbox = new jcheckbox ( "" , false ) ; scorequartercheckbox . additemlistener ( this ) ; scoreeighthcheckbox = new jcheckbox ( "" , false ) ; scoreeighthcheckbox . additemlistener ( this ) ; scorerestcheckbox = new jcheckbox ( "" , true ) ; scorerestcheckbox . additemlistener ( this ) ; scoretripletcheckbox = new jcheckbox ( "" , false ) ; scoretripletcheckbox . additemlistener ( this ) ; jpanel scorerhytmspanel = new jpanel ( ) ; scorerhytmspanel . add ( scorewholecheckbox ) ; scorerhytmspanel . add ( scoredottedhalfcheckbox ) ; scorerhytmspanel . add ( scorehalfcheckbox ) ; scorerhytmspanel . add ( scorequartercheckbox ) ; scorerhytmspanel . add ( scoreeighthcheckbox ) ; scorerhytmspanel . add ( scorerestcheckbox ) ; scorerhytmspanel . add ( scoretripletcheckbox ) ; scoretimesigncombobox = new jcombobox ( ) ; scoretimesigncombobox . setpreferredsize ( new dimension ( 100 , 25 ) ) ; scoretimesigncombobox . additem ( "4/4" ) ; scoretimesigncombobox . additem ( "3/4" ) ; scoretimesigncombobox . additem ( "2/4" ) ; scoretimesigncombobox . additem ( "6/8" ) ; scoretimesigncombobox . addactionlistener ( new actionlistener ( ) { @ override public void actionperformed ( actionevent e ) { jcombobox cb = ( jcombobox ) e . getsource ( ) ; int sel = cb . getselectedindex ( ) ; system . out . println ( "rhythm time signature changed. selected: " + sel ) ; if ( sel == 0 ) { scorewholecheckbox . setenabled ( true ) ; scorewholecheckbox . setselected ( true ) ; scorequartercheckbox . setselected ( true ) ; scoredottedhalfcheckbox . setenabled ( true ) ; scoredottedhalfcheckbox . setselected ( false ) ; scorelevel . settimesignnumerator ( 4 ) ; scorelevel . settimesigndenominator ( 4 ) ; scorelevel . settimedivision ( 1 ) ; } else if ( sel == 1 ) { scorewholecheckbox . setselected ( false ) ; scorewholecheckbox . setenabled ( false ) ; scoredottedhalfcheckbox . setselected ( true ) ; scoredottedhalfcheckbox . setenabled ( true ) ; scorequartercheckbox . setselected ( true ) ; scorelevel . settimesignnumerator ( 3 ) ; scorelevel . settimesigndenominator ( 4 ) ; scorelevel . settimedivision ( 1 ) ; } else if ( sel == 2 ) { scorewholecheckbox . setselected ( false ) ; scoredottedhalfcheckbox . setselected ( false ) ; scoredottedhalfcheckbox . setenabled ( false ) ; scorequartercheckbox . setselected ( true ) ; scorelevel . settimesignnumerator ( 2 ) ; scorelevel . settimesigndenominator ( 4 ) ; scorelevel . settimedivision ( 1 ) ; } else if ( sel == 3 ) { scorewholecheckbox . setselected ( false ) ; scorewholecheckbox . setenabled ( false ) ; scoredottedhalfcheckbox . setselected ( false ) ; scoredottedhalfcheckbox . setenabled ( false ) ; scorequartercheckbox . setselected ( true ) ; scorelevel . settimesignnumerator ( 6 ) ; scorelevel . settimesigndenominator ( 8 ) ; scorelevel . settimedivision ( 2 ) ; } } } ) ; jpanel timesignpanel = new jpanel ( ) ; scoretimesignlabel = new jlabel ( ) ; timesignpanel . add ( scoretimesignlabel ) ; timesignpanel . add ( scoretimesigncombobox ) ; jpanel scorerhythmandtimepanel = new jpanel ( ) ; scorerhythmandtimepanel . setlayout ( new borderlayout ( ) ) ; scorerhythmandtimepanel . add ( timesignpanel , borderlayout . north ) ; scorerhythmandtimepanel . add ( scorerhytmspanel , borderlayout . center ) ; localizables . add ( new localizable . namedgroup ( scorerhythmandtimepanel , "_menurythms" ) ) ; scoremetronomecheckbox = new jcheckbox ( "" , true ) ; scoremetronomeshowcheckbox = new jcheckbox ( "" , true ) ; scoremetronomeshowcheckbox . setselected ( false ) ; scoremetronomecheckbox . addactionlistener ( this ) ; scoremetronomeshowcheckbox . addactionlistener ( this ) ; jpanel scoremetronomepanel = new jpanel ( ) ; scoremetronomepanel . add ( scoremetronomecheckbox ) ; scoremetronomepanel . add ( scoremetronomeshowcheckbox ) ; localizables . add ( new localizable . namedgroup ( scoremetronomepanel , "_menumetronom" ) ) ; jpanel panel = new jpanel ( ) ; panel . setlayout ( new gridlayout ( 4 , 1 ) ) ; panel . add ( scoregamepanel ) ; panel . add ( scorekeypanel ) ; panel . add ( scorerhythmandtimepanel ) ; panel . add ( scoremetronomepanel ) ; return panel ; }
va	5	public posicion obtenerposicionrelativa ( final posicion posicion , final int offset ) { int indice = - 1 ; for ( int i = 0 ; i < posiciones . size ( ) && indice == - 1 ; i ++ ) { if ( posiciones . get ( i ) == posicion ) { indice = i ; } } int posicionrelativa = indice + offset ; if ( posicionrelativa < 0 || posicionrelativa > posiciones . size ( ) - 1 ) { return new posicioninexistente ( ) ; } return posiciones . get ( posicionrelativa ) ; }
va	5	static int quadraticroots ( final float a , final float b , final float c , float [ ] zeroes , final int off ) { int ret = off ; float t ; if ( a != 0f ) { final float dis = b * b - 4 * a * c ; if ( dis > 0f ) { final float sqrtdis = ( float ) math . sqrt ( dis ) ; if ( b >= 0f ) { zeroes [ ret ++ ] = ( 2f * c ) / ( - b - sqrtdis ) ; zeroes [ ret ++ ] = ( - b - sqrtdis ) / ( 2f * a ) ; } else { zeroes [ ret ++ ] = ( - b + sqrtdis ) / ( 2f * a ) ; zeroes [ ret ++ ] = ( 2f * c ) / ( - b + sqrtdis ) ; } } else if ( dis == 0f ) { t = ( - b ) / ( 2f * a ) ; zeroes [ ret ++ ] = t ; } } else { if ( b != 0f ) { t = ( - c ) / b ; zeroes [ ret ++ ] = t ; } } return ret - off ; }
va	9	private void processquery ( ) { int pos = query . indexof ( ";\n" ) ; if ( pos < 0 ) return ; string cmd = query . substring ( 0 , pos + 1 ) ; query = query . substring ( pos + 2 ) ; system . out . println ( "sql cmd: '" + cmd + "'" ) ; result = "# @sql@: " + cmd + "\n" ; try { statement stmt = session . createstatement ( ) ; if ( stmt . execute ( cmd ) ) { stringbuffer buf = new stringbuffer ( ) ; buf . append ( "# @status@: successful\n" ) ; resultset r = stmt . getresultset ( ) ; if ( r != null ) { resultsetmetadata md = r . getmetadata ( ) ; int numcol = md . getcolumncount ( ) ; buf . append ( "# @cols@: " ) ; for ( int n = 0 ; n < numcol ; n ++ ) { buf . append ( md . getcolumnname ( n + 1 ) ) ; if ( n < numcol - 1 ) buf . append ( "\u00a6" ) ; } buf . append ( "\n" ) ; stringbuffer recbuf = new stringbuffer ( ) ; int numrec = 0 ; while ( r . next ( ) ) { for ( int n = 0 ; n < numcol ; n ++ ) { string data = r . getstring ( n + 1 ) ; recbuf . append ( convert ( data ) ) ; if ( n < numcol - 1 ) recbuf . append ( "\u00a6" ) ; } recbuf . append ( "\n" ) ; numrec ++ ; } buf . append ( "# @result@: " + numrec + "\n" ) ; buf . append ( recbuf ) ; } else buf . append ( "# @result@: none\n" ) ; result += buf . tostring ( ) ; } else result += "# @status@: failed!\n" ; } catch ( sqlexception e ) { result += "# @status@: failed! (" + e . getmessage ( ) + ")\n" ; } }
va	8	private void buildmenu ( ) { jmbmenu = new jmenubar ( ) ; jmenu jmfile = new jmenu ( mrbgui . getrbstring ( "mars.gui.client.menu.file" , "file" ) ) ; jmenuitem jmiconnect = new jmenuitem ( mrbgui . getrbstring ( "mars.gui.client.menu.file.connect" , "connect" ) ) ; jmenuitem jmidisconnect = new jmenuitem ( mrbgui . getrbstring ( "mars.gui.client.menu.file.disconnect" , "disconnect" ) ) ; jmenuitem jmiopen = new jmenuitem ( mrbgui . getrbstring ( "mars.gui.client.menu.file.openexisting" , "open existing" ) ) ; jmenuitem jmiremove = new jmenuitem ( mrbgui . getrbstring ( "mars.gui.client.menu.file.remove" , "remove existing" ) ) ; jmenuitem jmiprint = new jmenuitem ( mrbgui . getrbstring ( "mars.gui.client.menu.file.print" , "print" ) ) ; jmenuitem jmisave = new jmenuitem ( mrbgui . getrbstring ( "mars.gui.client.menu.file.save" , "save as csv" ) ) ; jmenuitem jmiexit = new jmenuitem ( mrbgui . getrbstring ( "mars.gui.client.menu.file.exit" , "exit" ) ) ; jmfile . setmnemonic ( ( mrbgui . getrbstring ( "mars.gui.client.menu.file.acc" , "f" ) ) . charat ( 0 ) ) ; jmiconnect . addactionlistener ( new file_new ( ) ) ; jmidisconnect . addactionlistener ( new file_disconnect ( ) ) ; jmiopen . addactionlistener ( new file_open ( this ) ) ; jmiremove . addactionlistener ( new file_remove ( ) ) ; jmiprint . addactionlistener ( new file_print ( ) ) ; jmisave . addactionlistener ( new file_save ( ) ) ; jmiexit . addactionlistener ( new file_exit ( ) ) ; jmfile . add ( jmiconnect ) ; jmfile . add ( jmidisconnect ) ; jmfile . add ( jmiopen ) ; jmfile . add ( jmiremove ) ; jmfile . addseparator ( ) ; jmfile . add ( jmiprint ) ; jmfile . add ( jmisave ) ; jmfile . addseparator ( ) ; jmfile . add ( jmiexit ) ; jmenu jmview = new jmenu ( mrbgui . getrbstring ( "mars.gui.client.menu.view" , "view" ) ) ; jmenuitem jmiconnections = new jmenuitem ( mrbgui . getrbstring ( "mars.gui.client.menu." , "connections" ) ) ; jmenuitem jmiclients = new jmenuitem ( mrbgui . getrbstring ( "mars.gui.client.menu." , "connected clients" ) ) ; jmview . setmnemonic ( ( mrbgui . getrbstring ( "mars.gui.client.menu.view.acc" , "v" ) ) . charat ( 0 ) ) ; jmiconnections . addactionlistener ( new view_connections ( ) ) ; jmiclients . addactionlistener ( new view_clients ( ) ) ; jmview . add ( jmiconnections ) ; jmview . add ( jmiclients ) ; jmenu jmprefs = new jmenu ( mrbgui . getrbstring ( "mars.gui.client.menu.preferences" , "preferences" ) ) ; jmenu jmlnf = new jmenu ( mrbgui . getrbstring ( "mars.gui.client.menu.prefs.lnf" , "look and feel" ) ) ; jmenu jmlocale = new jmenu ( mrbgui . getrbstring ( "mars.gui.client.menu.prefs.locale" , "locale" ) ) ; jmenu jmlogging = new jmenu ( mrbgui . getrbstring ( "mars.gui.client.menu.prefs.logging" , "logging" ) ) ; jmenuitem jmixsddir = new jmenuitem ( mrbgui . getrbstring ( "mars.gui.client.menu.prefs.xsddir" , "set schema location" ) ) ; jmenuitem jmilogdir = new jmenuitem ( mrbgui . getrbstring ( "mars.gui.client.menu.prefs.logsdir" , "set log directory" ) ) ; jmprefs . setmnemonic ( ( mrbgui . getrbstring ( "mars.gui.client.menu.preferences.acc" , "p" ) ) . charat ( 0 ) ) ; uimanager . lookandfeelinfo [ ] lafthissystem = uimanager . getinstalledlookandfeels ( ) ; buttongroup bglnf = new buttongroup ( ) ; for ( int i = 0 ; i < lafthissystem . length ; i ++ ) { jradiobuttonmenuitem jrbmi = new jradiobuttonmenuitem ( lafthissystem [ i ] . getname ( ) ) ; jrbmi . addactionlistener ( new prefs_lnf ( lafthissystem [ i ] . getclassname ( ) , this , mrbgui . getrblocale ( ) ) ) ; if ( lafthissystem [ i ] . getclassname ( ) . equals ( pgui . get ( "mars.lnf" , "javax.swing.plaf.metal.metallookandfeel" ) ) ) { jrbmi . setselected ( true ) ; } bglnf . add ( jrbmi ) ; jmlnf . add ( jrbmi ) ; } string strnumoflangs = mrbgui . getrbstring ( "mars.locales.numberoflocales" , "unknown" ) ; vector veclangs = new vector ( ) ; if ( strnumoflangs . equals ( "unknown" ) ) { veclangs . add ( new string [ ] { "us english" , "en_us" } ) ; } else { integer intlangamount = new integer ( strnumoflangs ) ; for ( int i = 1 ; i <= intlangamount . intvalue ( ) ; i ++ ) { veclangs . add ( new string [ ] { mrbgui . getrbstring ( "mars.locales." + i , "us english" ) , mrbgui . getrbstring ( "mars.locales.code." + i , "en_us" ) } ) ; } } string savedlocale = new string ( pgui . get ( "mars.locale.lang" , "en" ) + "_" + pgui . get ( "mars.locale.country" , "us" ) ) ; buttongroup bglocale = new buttongroup ( ) ; for ( int i = 0 ; i < veclangs . size ( ) ; i ++ ) { string [ ] lang = ( string [ ] ) veclangs . get ( i ) ; jradiobuttonmenuitem jrbmi = new jradiobuttonmenuitem ( lang [ 0 ] , new imageicon ( "images/" + lang [ 1 ] + ".png" ) ) ; jrbmi . addactionlistener ( new prefs_locale ( lang [ 1 ] ) ) ; if ( lang [ 1 ] . equals ( savedlocale ) ) { jrbmi . setselected ( true ) ; } bglocale . add ( jrbmi ) ; jmlocale . add ( jrbmi ) ; } string [ ] strlog = new string [ ] { "severe" , "warning" , "info" , "config" , "fine" , "finer" , "finest" , "all" , "off" } ; buttongroup bglogs = new buttongroup ( ) ; for ( int i = 0 ; i < strlog . length ; i ++ ) { jradiobuttonmenuitem jrbmi = new jradiobuttonmenuitem ( strlog [ i ] ) ; jrbmi . addactionlistener ( new prefs_logging ( strlog [ i ] ) ) ; if ( pgui . get ( "mars.loglevel" , "all" ) . equals ( strlog [ i ] ) ) { jrbmi . setselected ( true ) ; } bglogs . add ( jrbmi ) ; jmlogging . add ( jrbmi ) ; } jmixsddir . addactionlistener ( new prefs_setdir ( "xsd" , this ) ) ; jmilogdir . addactionlistener ( new prefs_setdir ( "log" , this ) ) ; jmprefs . add ( jmlnf ) ; jmprefs . add ( jmlocale ) ; jmprefs . add ( jmlogging ) ; jmprefs . add ( jmixsddir ) ; jmprefs . add ( jmilogdir ) ; jmenu jmwindow = new jmenu ( mrbgui . getrbstring ( "mars.gui.client.menu.window" , "window" ) ) ; jmenuitem jmitile = new jmenuitem ( mrbgui . getrbstring ( "mars.gui.client.menu.window.tile" , "tile all" ) ) ; jmenuitem jmicascade = new jmenuitem ( mrbgui . getrbstring ( "mars.gui.client.menu.window.cascade" , "cascade" ) ) ; jmenuitem jmiminimise = new jmenuitem ( mrbgui . getrbstring ( "mars.gui.client.menu.window.minimise" , "minimise" ) ) ; jmwindow . setmnemonic ( ( mrbgui . getrbstring ( "mars.gui.client.menu.window.acc" , "w" ) ) . charat ( 0 ) ) ; jmitile . addactionlistener ( new window_tile ( ) ) ; jmicascade . addactionlistener ( new window_cascade ( ) ) ; jmiminimise . addactionlistener ( new window_minimise ( ) ) ; jmwindow . add ( jmitile ) ; jmwindow . add ( jmicascade ) ; jmwindow . add ( jmiminimise ) ; jmenu jmhelp = new jmenu ( mrbgui . getrbstring ( "mars.gui.client.menu.help" , "help" ) ) ; jmenuitem jmiabout = new jmenuitem ( mrbgui . getrbstring ( "mars.gui.client.menu.help.about" , "about" ) ) ; jmenuitem jmilicense = new jmenuitem ( mrbgui . getrbstring ( "mars.gui.client.menu.help.license" , "license" ) ) ; jmhelp . setmnemonic ( ( mrbgui . getrbstring ( "mars.gui.client.menu.help.acc" , "h" ) ) . charat ( 0 ) ) ; jmiabout . addactionlistener ( new help_about ( ) ) ; jmilicense . addactionlistener ( new help_license ( ) ) ; jmhelp . add ( jmiabout ) ; jmhelp . add ( jmilicense ) ; jmbmenu . add ( jmfile ) ; jmbmenu . add ( jmview ) ; jmbmenu . add ( jmprefs ) ; jmbmenu . add ( jmwindow ) ; jmbmenu . add ( jmhelp ) ; }
va	1	protected void slidedown ( ) { isactive = true ; card . show ( this , "resultbox" ) ; line . settext ( model . getline ( ) + "" ) ; lvl . settext ( model . getlevel ( ) + "" ) ; time . settext ( model . gettime ( ) + "" ) ; score . settext ( model . getscore ( ) + "" ) ; if ( model . getbestscores ( ) != null ) { drawname ( ) ; name . settext ( system . getproperty ( "user.name" ) ) ; } else { namebox . removeall ( ) ; } int x1 = 0 ; int x2 = 0 ; int y1 = - main . height_main ; int y2 = 0 ; int w = main . width_main ; int h = main . height_main ; new kulanimator ( parentpanel , this , x1 , x2 , y1 , y2 , w , h ) . slidevertical ( ) ; }
va	3	public abstractitem ( itemconfiguration config , string key , string [ ] sval , int [ ] ival , triplet [ ] tval ) { this . key = key ; strings = new string [ config . stringlabels . length ] ; ints = new int [ config . intlabels . length ] ; triplets = new triplet [ config . tripletlabels . length ] ; for ( int i = 0 ; i < strings . length ; i ++ ) { strings [ i ] = sval [ i ] ; } for ( int i = 0 ; i < ints . length ; i ++ ) { ints [ i ] = ival [ i ] ; } for ( int i = 0 ; i < triplets . length ; i ++ ) { triplets [ i ] = tval [ i ] ; } }
va	3	public static boolean createtable ( connection con , tableinfo tableinfo ) { system . out . println ( "creating table " + tableinfo . tablename ) ; string tablecreate = "create table " + tableinfo . tablename + " ( " ; for ( string i : tableinfo . columns ) { string [ ] tmp = i . split ( " " ) ; tablecreate += " " + tmp [ 0 ] + " " + tmp [ 1 ] + "   " ; } for ( string i : tableinfo . foreignkeys ) { string [ ] tmp = i . split ( " " ) ; tablecreate += " foreign key (" + tmp [ 0 ] + ") references  " + tmp [ 1 ] + "   " ; } tablecreate += " primary key (id) )" ; try { statement stmt = con . createstatement ( ) ; stmt . execute ( tablecreate ) ; stmt . close ( ) ; } catch ( sqlexception sqle ) { system . out . println ( "dbobject createtable(" + tableinfo . tablename + "): " + "unhandled sqlexception  create string:\n" + tablecreate + "\n\n exception: \n" + sqle + "\n\n" ) ; return false ; } return true ; }
va	0	protected updaterpanel ( ) { super ( new borderlayout ( ) ) ; messages = new jtextarea ( ) ; messages . setlinewrap ( false ) ; messagesempty = true ; final jpanel center = new jpanel ( new borderlayout ( ) ) ; center . add ( new jscrollpane ( messages ) , borderlayout . center ) ; center . add ( box . createverticalstrut ( minimal_height ) , borderlayout . west ) ; center . add ( box . createrigidarea ( new dimension ( 0 , 5 ) ) , borderlayout . south ) ; progressbar = new jprogressbar ( 0 , 100 ) ; progressbar . setvalue ( 0 ) ; actionsprogressbar = new jprogressbar ( 0 , 100 ) ; actionsprogressbar . setvalue ( 0 ) ; actionprogressbar = new jprogressbar ( 0 , 100 ) ; actionprogressbar . setvalue ( 0 ) ; final jpanel progress = new jpanel ( ) ; progress . setlayout ( new boxlayout ( progress , boxlayout . y_axis ) ) ; progress . add ( progressbar ) ; progress . add ( box . createrigidarea ( new dimension ( 0 , 5 ) ) ) ; progress . add ( actionsprogressbar ) ; progress . add ( box . createrigidarea ( new dimension ( 0 , 5 ) ) ) ; progress . add ( actionprogressbar ) ; final jpanel south = new jpanel ( new borderlayout ( ) ) ; south . add ( center , borderlayout . center ) ; south . add ( progress , borderlayout . south ) ; south . add ( box . createhorizontalstrut ( minimal_width ) , borderlayout . north ) ; add ( south , borderlayout . center ) ; add ( box . createrigidarea ( new dimension ( 0 , 5 ) ) , borderlayout . north ) ; add ( box . createrigidarea ( new dimension ( 0 , 5 ) ) , borderlayout . south ) ; add ( box . createrigidarea ( new dimension ( 5 , 0 ) ) , borderlayout . west ) ; add ( box . createrigidarea ( new dimension ( 5 , 0 ) ) , borderlayout . east ) ; }
va	8	private void jmenuitem1actionperformed ( java . awt . event . actionevent evt ) { final string inputvalue = joptionpane . showinputdialog ( "enter a chatroom name" ) ; final jbutton btnclose = new jbutton ( "x" ) ; if ( inputvalue . isempty ( ) ) { joptionpane . showmessagedialog ( gui . this , "please enter a name." , "input error" , joptionpane . warning_message ) ; } else { try { client . sendjoinchatroommessage ( inputvalue ) ; } catch ( jmsexception e ) { throw new runtimeexception ( e ) ; } chatclientapplicationgui . addservermessagelistener ( new servermessagelistener ( ) { public void onmessagereceived ( chatmessage m ) { if ( ! ( m instanceof chatroomusersmessage ) ) return ; final chatroomusersmessage ulm = ( chatroomusersmessage ) m ; if ( ulm . getchatroom ( ) . equals ( tabbedpane . gettitleat ( tabbedpane . getselectedindex ( ) ) ) ) { userlist . setmodel ( new javax . swing . abstractlistmodel ( ) { list < string > strings = ulm . getusers ( ) ; public int getsize ( ) { return strings . size ( ) ; } public object getelementat ( int i ) { return strings . get ( i ) ; } } ) ; } } } ) ; chatclientapplicationgui . addservermessagelistener ( new servermessagelistener ( ) { public void onmessagereceived ( chatmessage m ) { if ( ! ( m instanceof joinchatroommessage ) ) return ; try { client . sendchatroomuserlistmessage ( inputvalue ) ; } catch ( jmsexception e ) { throw new runtimeexception ( e ) ; } final jtextarea jta = new jtextarea ( ) ; tabbedpane . addtab ( inputvalue , null , jta , null ) ; chatclientapplicationgui . addservermessagelistener ( new servermessagelistener ( ) { public void onmessagereceived ( chatmessage m ) { if ( ! ( m instanceof chattextmessage ) ) return ; final chattextmessage ulm = ( chattextmessage ) m ; jta . append ( "[" + ulm . getusername ( ) + "]: " + ulm . gettext ( ) + "\n" ) ; } } ) ; int index = tabbedpane . indexoftab ( inputvalue ) ; jpanel pnltab = new jpanel ( ) ; pnltab . setopaque ( false ) ; jlabel lbltitle = new jlabel ( inputvalue ) ; pnltab . add ( lbltitle ) ; pnltab . add ( btnclose ) ; tabbedpane . settabcomponentat ( index , pnltab ) ; btnclose . addactionlistener ( new java . awt . event . actionlistener ( ) { public void actionperformed ( java . awt . event . actionevent evt ) { btncloseactionperformed ( evt ) ; } private void btncloseactionperformed ( actionevent evt ) { point mousepos = tabbedpane . getmouseposition ( ) ; int mousex = mousepos . x ; int mousey = mousepos . y ; int index = tabbedpane . indexatlocation ( mousex , mousey ) ; component selected = tabbedpane . getcomponentat ( index ) ; if ( selected != null ) { tabbedpane . remove ( selected ) ; } } } ) ; jta . append ( "[system]: joined " + inputvalue + "\n" ) ; chatclientapplicationgui . removeservermessagelistener ( this ) ; } } ) ; } }
va	5	public void inst_main ( string args [ ] ) { int iterations = 1000 ; string options = "" ; if ( args != null && args . length > 0 ) iterations = integer . parseint ( args [ 0 ] ) ; if ( args != null && args . length > 1 ) options = args [ 1 ] ; long starttime = system . currenttimemillis ( ) ; for ( int j = 0 ; j < iterations ; ++ j ) { chaintest ( 100 ) ; projectiontest ( 100 ) ; } long endtime = system . currenttimemillis ( ) ; total_ms = endtime - starttime ; system . out . println ( "deltablue\tjava\t" + options + "\t" + iterations + "x\t" + ( ( double ) total_ms / iterations ) + " ms" ) ; }
va	0	@ test public void testisconvex ( ) { point [ ] points = makepoints ( "0 0  4 5  6 5  9 3  10 4  12 -1  7 -4  4 0  3 -2  -1 1  8 2  -1 -1" ) ; assertfalse ( isconvex ( points ) ) ; assertfalse ( isccwconvex ( points ) ) ; points = aconvex ; asserttrue ( isconvex ( points ) ) ; asserttrue ( isccwconvex ( points ) ) ; points = makepoints ( "0.50507641 39.107643  50.002551 25.218046  79.296972 -14.68298  93.944191 -57.867001  84.347738 -94.990105  34.850263 -82.363197  -0.50507641 -36.14872  -12.121831 5.7726092" ) ; asserttrue ( isconvex ( points ) ) ; assertfalse ( isccwconvex ( points ) ) ; points = makepoints ( "0 0  1 0  2 0  3 0  2 0  1 0" ) ; asserttrue ( isconvex ( points ) ) ; asserttrue ( isccwconvex ( points ) ) ; points = makepoints ( "-35.860415 -16.379211  -4.0406102 -35.067033  40.406102 13.925365  57.578695 56.856849  -37.88072 38.674103  -72.225907 6.060915  -11.111678 6.3492214" ) ; assertfalse ( isconvex ( points ) ) ; assertfalse ( isccwconvex ( points ) ) ; }
va	5	@ override public synchronized void onplayermove ( final board b , int playernr , int move ) { if ( playernr == getnumber ( ) ) return ; if ( root . children . isempty ( ) ) throw new illegalstateexception ( "root has no children" ) ; for ( int i = 0 ; i < root . children . size ( ) ; i ++ ) { node child = root . children . get ( i ) ; if ( child . move == move ) { child . parent . apply ( rootboard ) ; child . parent = null ; root = child ; child . apply ( rootboard ) ; if ( ! rootboard . equals ( b ) ) { rootboard . print ( ) ; b . print ( ) ; throw new illegalstateexception ( "boards do not match" ) ; } return ; } } throw new illegalstateexception ( "cannot move to the correct state" ) ; }
va	5	public void update ( ) { totaltime ++ ; if ( totaltime > 200 && ! ( component . getscreen ( ) instanceof mainmenu ) ) setscreen ( new mainmenu ( component , this , input ) ) ; boolean switchscreen = false ; if ( logotransparancy < 1.0f ) { logotransparancy += ( float ) rtscomponent . ms_per_tick / 2000 ; } else { logotransparancy = 1.0f ; switchscreen = true ; } if ( switchscreen ) { if ( ! ( component . getscreen ( ) instanceof mainmenu ) ) setscreen ( new mainmenu ( component , this , input ) ) ; } }
va	6	public geometry makepath ( double [ ] [ ] pn , int np ) { if ( np == this . np && same ( pn , this . pn ) ) return this ; if ( this . pn == null || this . pn . length != pn . length ) this . pn = new double [ pn . length ] [ 3 ] ; for ( int n = 0 ; n < pn . length ; n ++ ) for ( int k = 0 ; k < pn [ n ] . length ; k ++ ) this . pn [ n ] [ k ] = pn [ n ] [ k ] ; return makepath ( resample ( pn , np ) ) ; }
va	8	public static void main ( string [ ] args ) { system . setout ( new vout ( system . out ) ) ; venginelogo vl = new venginelogo ( ) ; vl . setvisible ( true ) ; cfg = vfilereader . readcfg ( new file ( new file ( system . getproperty ( "user.home" ) + "/.vau/" ) . getabsolutepath ( ) + "/configurations/game.cfg" ) ) ; cfg . s ( "home" , new file ( system . getproperty ( "user.home" ) + "/.vau/" ) . getabsolutepath ( ) ) ; cfg . s ( "modhome" , new file ( system . getproperty ( "user.home" ) + "/.vau/mods/" + cfg . g ( "mod" ) + "/" ) . getabsolutepath ( ) + "/" ) ; for ( string param : args ) { try { string [ ] pr = param . split ( "=" ) ; cfg . s ( pr [ 0 ] , pr [ 1 ] ) ; } catch ( exception e ) { } } system . out . println ( cfg ) ; try { system . setproperty ( "java.library.path" , new file ( cfg . g ( "home" ) + "/native" ) . getabsolutepath ( ) ) ; field fieldsyspath = classloader . class . getdeclaredfield ( "sys_paths" ) ; fieldsyspath . setaccessible ( true ) ; try { fieldsyspath . set ( null , null ) ; } catch ( illegalargumentexception ex ) { logger . getlogger ( vengine . class . getname ( ) ) . log ( level . severe , null , ex ) ; joptionpane . showmessagedialog ( null , "error!\n" + ex . tostring ( ) ) ; system . exit ( 1 ) ; } catch ( illegalaccessexception ex ) { joptionpane . showmessagedialog ( null , "error!\n" + ex . tostring ( ) ) ; system . exit ( 1 ) ; } } catch ( nosuchfieldexception ex ) { joptionpane . showmessagedialog ( null , "error!\n" + ex . tostring ( ) ) ; system . exit ( 1 ) ; } catch ( securityexception ex ) { joptionpane . showmessagedialog ( null , "error!\n" + ex . tostring ( ) ) ; system . exit ( 1 ) ; } music openingmenumusic ; try { openingmenumusic = new music ( new file ( system . getproperty ( "user.home" ) + "/.vau/music/watchword.ogg" ) . getabsolutepath ( ) ) ; if ( cfg . g ( "music" ) . equals ( "enabled" ) ) { openingmenumusic . loop ( ) ; } } catch ( slickexception ex ) { logger . getlogger ( vengine . class . getname ( ) ) . log ( level . severe , null , ex ) ; } vgraphics . start ( ) ; vprocessor . add ( new vexamples . units . vplayer ( ) ) ; vprocessor . add ( new vexamples . units . vunit ( ) ) ; vprocessor . add ( new vexamples . units . vbullet ( ) ) ; vmenu vm = new vmenu ( ) ; vl . setvisible ( false ) ; }
va	8	public static arraylist < player > getenemies ( player player ) { arraylist < player > emenies = new arraylist < player > ( ) ; if ( ! getteamfriends ( teams . getteamofplayer ( player ) ) . contains ( teams . getplayersofteam ( blue ) ) && teams . getplayersofteam ( blue ) != null ) { emenies . add ( teams . getplayersofteam ( blue ) ) ; } if ( ! getteamfriends ( teams . getteamofplayer ( player ) ) . contains ( teams . getplayersofteam ( green ) ) && teams . getplayersofteam ( green ) != null ) { emenies . add ( teams . getplayersofteam ( green ) ) ; } if ( ! getteamfriends ( teams . getteamofplayer ( player ) ) . contains ( teams . getplayersofteam ( orange ) ) && teams . getplayersofteam ( orange ) != null ) { emenies . add ( teams . getplayersofteam ( orange ) ) ; } if ( ! getteamfriends ( teams . getteamofplayer ( player ) ) . contains ( teams . getplayersofteam ( red ) ) && teams . getplayersofteam ( red ) != null ) { emenies . add ( teams . getplayersofteam ( red ) ) ; } return emenies ; }
te	2	@ override public void draw ( ) { if ( ! isvisible ( ) ) { return ; } int x = getbasepoint ( ) . getx ( getpixcelx ( ) , getwidth ( ) ) ; int y = getbasepoint ( ) . gety ( getpixcely ( ) , getheight ( ) ) ; glloadidentity ( ) ; gltranslatef ( x , y , 0 ) ; glrotatef ( getangle ( ) , 0 , 0 , 1 ) ; setglcolor4f ( getcolor ( ) , getalpha ( ) ) ; if ( gettexture ( ) != null ) { drawtexture ( gettexture ( ) , getwidth ( ) , getheight ( ) ) ; } }
te	4	public gamemap parsemap ( file mapfile ) { try { reader = new bufferedreader ( new filereader ( mapfile ) ) ; parsedimensions ( ) ; parsespritesheets ( ) ; parseterrain ( ) ; parsemaplayout ( ) ; parseunits ( ) ; parseunitsposition ( ) ; map . buildgraph ( ) ; scanner . close ( ) ; reader . close ( ) ; } catch ( filenotfoundexception e ) { system . out . println ( mapfile + " not found" ) ; return null ; } catch ( ioexception e ) { system . out . println ( "could not read line" ) ; return null ; } catch ( invalidtokenexception e ) { system . out . println ( e . getmessage ( ) ) ; return null ; } catch ( expectedtokenexception e ) { system . out . println ( e . getmessage ( ) ) ; return null ; } return map ; }
te	8	public binarystrings ( double mutationrate , double recombinationrate , int recombinationsplit , int maxmutations ) { try { if ( recombinationrate > 1.0 || recombinationrate < 0.0 ) { throw new exception ( "crossover rate outside range 0.0-1.0" ) ; } this . recombinationrate = recombinationrate ; if ( recombinationsplit > 2 || recombinationsplit < 1 ) { throw new exception ( "crossover split is outside range  accepted values are 1 and 2  got " + recombinationsplit ) ; } this . recombinationsplit = recombinationsplit ; if ( mutationrate > 1.0 || mutationrate < 0.0 ) { throw new exception ( "mutation rate outside range 0.0-1.0" ) ; } this . mutationrate = mutationrate ; if ( maxmutations < 1 ) throw new exception ( "can't have 0 or negative mutations!" ) ; this . maxmutations = maxmutations ; } catch ( exception ex ) { ex . printstacktrace ( ) ; } }
te	9	private void ok ( ) { if ( list == null ) { setlist ( ) ; } if ( logintextfield . gettext ( ) . length ( ) == 0 ) { joptionpane . showmessagedialog ( f , "enter login" ) ; return ; } if ( passtextfield . gettext ( ) . length ( ) == 0 ) { joptionpane . showmessagedialog ( f , "enter password" ) ; return ; } try { connectmethods . loginfo info = list . authenticate ( logintextfield . gettext ( ) , passtextfield . gettext ( ) ) ; if ( info == connectmethods . loginfo . incorrect_loggin ) { joptionpane . showmessagedialog ( f , "login was not found in database  check your login" ) ; passtextfield . settext ( "" ) ; logintextfield . settext ( "" ) ; } if ( info == connectmethods . loginfo . incorrect_pass ) { joptionpane . showmessagedialog ( f , "incorrecn password  check your password" ) ; passtextfield . settext ( "" ) ; } if ( info == connectmethods . loginfo . already_logged ) { joptionpane . showmessagedialog ( f , "user is already logged" ) ; passtextfield . settext ( "" ) ; } if ( info == connectmethods . loginfo . correct_data ) { f . dispose ( ) ; openprojframe opframe = new openprojframe ( list , logintextfield . gettext ( ) ) ; opframe . setdefaultcloseoperation ( jframe . exit_on_close ) ; opframe . setvisible ( true ) ; } } catch ( remoteexception e1 ) { joptionpane . showmessagedialog ( f , "disconnect from server" ) ; return ; } catch ( nullpointerexception e1 ) { this . dispose ( ) ; loginframe log = new loginframe ( ) ; log . setdefaultcloseoperation ( jframe . exit_on_close ) ; log . setvisible ( true ) ; } }
te	4	@ override public void caretupdate ( caretevent e ) { document3 doc = ( ( editortextarea3 ) e . getsource ( ) ) . getomdocument ( ) ; if ( doc != null ) { if ( ( ( editorcontroller ) core . geteditor ( ) ) . getcurrenttranslation ( ) != null ) { int start_trans = doc . gettranslationstart ( ) ; int end_trans = start_trans + core . geteditor ( ) . getcurrenttranslation ( ) . length ( ) ; if ( e . getdot ( ) >= start_trans && e . getdot ( ) <= end_trans ) { sessionlog . getlog ( ) . caretupdate ( e . getmark ( ) + 1 , e . getdot ( ) + 1 ) ; } } } }
te	9	public static string [ ] splitcsvwithquoteescape ( string line ) { sortedset < integer > commaindicies = new treeset < integer > ( ) ; set < integer > quoteindicies = new hashset < integer > ( ) ; map < integer , integer > priorquotes = new hashmap < integer , integer > ( ) ; char [ ] array = line . tochararray ( ) ; for ( int i = 0 ; i < array . length ; i ++ ) { switch ( array [ i ] ) { case   : commaindicies . add ( i ) ; break ; case " : case ' : quoteindicies . add ( i ) ; break ; } priorquotes . put ( i , quoteindicies . size ( ) ) ; } iterator < integer > it = commaindicies . iterator ( ) ; while ( it . hasnext ( ) ) { integer i = it . next ( ) ; if ( isodd ( priorquotes . get ( i ) ) ) { it . remove ( ) ; } } integer [ ] commas = commaindicies . toarray ( new integer [ commaindicies . size ( ) ] ) ; list < string > list = new linkedlist < string > ( ) ; if ( commas . length > 0 ) { list . add ( line . substring ( 0 , commas [ 0 ] ) ) ; } else { list . add ( line ) ; } for ( int i = 0 ; i < commas . length - 1 ; i ++ ) { list . add ( line . substring ( commas [ i ] + 1 , commas [ i + 1 ] ) ) ; } if ( commas . length > 0 ) { list . add ( line . substring ( commas [ commas . length - 1 ] + 1 ) ) ; } return list . toarray ( new string [ list . size ( ) ] ) ; }
te	4	@ override public map < string , scorestate > call ( ) throws exception { for ( binaryrule rule : intracellexecution . parser . grammar . getbinaryrules ( ) ) { string statex = rule . getparent ( ) ; string statey = rule . getleftchild ( ) ; string statez = rule . getrightchild ( ) ; if ( ! intracellexecution . cell . ckytable . hasstate ( statey , intracellexecution . cell . i , k ) || ! intracellexecution . cell . ckytable . hasstate ( statez , k , intracellexecution . cell . j ) ) continue ; scorestate leftchildstate = intracellexecution . cell . ckytable . safegetscorestateforwriting ( statey , intracellexecution . cell . i , k ) ; scorestate rightchildstate = intracellexecution . cell . ckytable . safegetscorestateforwriting ( statez , k , intracellexecution . cell . j ) ; double updatescore = rule . getscore ( ) * leftchildstate . getscore ( ) * rightchildstate . getscore ( ) ; scorestate currentstate = intracellexecution . cell . ckytable . safegetscorestateforwriting ( statex , intracellexecution . cell . i , intracellexecution . cell . j ) ; synchronized ( currentstate ) { if ( currentstate . getscore ( ) < updatescore ) { currentstate . state = statex ; currentstate . score = updatescore ; currentstate . children = arrays . aslist ( leftchildstate , rightchildstate ) ; } } } intracellexecution . decreasepairdependencycount ( ) ; return null ; }
te	1	private void setpatternflagmenu ( menu menu ) { class flagstatusadapter extends selectionadapter { public void widgetselected ( selectionevent e ) { menuitem menitem = ( menuitem ) e . widget ; integer flag = ( integer ) menitem . getdata ( ) ; if ( menitem . getselection ( ) ) { regex . addpatternflag ( flag . intvalue ( ) ) ; } else { regex . removepatternflag ( flag . intvalue ( ) ) ; } if ( liveeval . isliveeval ( ) ) { processregex ( ) ; updatefoundstatus ( ) ; } txt_regexp . settooltiptext ( regex . getpatternflagsasstring ( ) ) ; } } flagstatusadapter flagstatusadapter = new flagstatusadapter ( ) ; men_patternflags = new menu ( menu ) ; menuitem mit_patternflags = new menuitem ( menu , swt . cascade ) ; mit_patternflags . settext ( "pattern &flags" ) ; mit_patternflags . setmenu ( men_patternflags ) ; menuitem mit_flags_canoneq = new menuitem ( men_patternflags , swt . check ) ; mit_flags_canoneq . settext ( "canonical &equivalence" ) ; mit_flags_canoneq . setdata ( new integer ( pattern . canon_eq ) ) ; mit_flags_canoneq . setselection ( prefs . getboolean ( "pattern.canon_eq" ) ) ; mit_flags_canoneq . addselectionlistener ( flagstatusadapter ) ; menuitem mit_flags_caseins = new menuitem ( men_patternflags , swt . check ) ; mit_flags_caseins . settext ( "case &insensitive" ) ; mit_flags_caseins . setdata ( new integer ( pattern . case_insensitive ) ) ; mit_flags_caseins . setselection ( prefs . getboolean ( "pattern.case_insensitive" ) ) ; mit_flags_caseins . addselectionlistener ( flagstatusadapter ) ; menuitem mit_flags_comments = new menuitem ( men_patternflags , swt . check ) ; mit_flags_comments . settext ( "&comments" ) ; mit_flags_comments . setdata ( new integer ( pattern . comments ) ) ; mit_flags_comments . setselection ( prefs . getboolean ( "pattern.comments" ) ) ; mit_flags_comments . addselectionlistener ( flagstatusadapter ) ; menuitem mit_flags_dotall = new menuitem ( men_patternflags , swt . check ) ; mit_flags_dotall . settext ( "&dotall mode" ) ; mit_flags_dotall . setdata ( new integer ( pattern . dotall ) ) ; mit_flags_dotall . setselection ( prefs . getboolean ( "pattern.dotall" ) ) ; mit_flags_dotall . addselectionlistener ( flagstatusadapter ) ; menuitem mit_flags_multiline = new menuitem ( men_patternflags , swt . check ) ; mit_flags_multiline . settext ( "&multiline mode" ) ; mit_flags_multiline . setdata ( new integer ( pattern . multiline ) ) ; mit_flags_multiline . setselection ( prefs . getboolean ( "pattern.multiline" ) ) ; mit_flags_multiline . addselectionlistener ( flagstatusadapter ) ; menuitem mit_flags_unicodecase = new menuitem ( men_patternflags , swt . check ) ; mit_flags_unicodecase . settext ( "&unicode case" ) ; mit_flags_unicodecase . setdata ( new integer ( pattern . unicode_case ) ) ; mit_flags_unicodecase . setselection ( prefs . getboolean ( "pattern.unicode_case" ) ) ; mit_flags_unicodecase . addselectionlistener ( flagstatusadapter ) ; menuitem mit_flags_unixlines = new menuitem ( men_patternflags , swt . check ) ; mit_flags_unixlines . settext ( "unix &lines" ) ; mit_flags_unixlines . setdata ( new integer ( pattern . unix_lines ) ) ; mit_flags_unixlines . setselection ( prefs . getboolean ( "pattern.unix_lines" ) ) ; mit_flags_unixlines . addselectionlistener ( flagstatusadapter ) ; new menuitem ( men_patternflags , swt . | ) ; menuitem mit_flags_deactivateall = new menuitem ( men_patternflags , swt . none ) ; mit_flags_deactivateall . settext ( "deactivate &all" ) ; mit_flags_deactivateall . addselectionlistener ( new selectionadapter ( ) { public void widgetselected ( selectionevent e ) { menuitem menitem = ( menuitem ) e . widget ; menu menu = menitem . getparent ( ) ; menuitem [ ] menitems = menu . getitems ( ) ; for ( int i = 0 ; i < menitems . length ; i ++ ) { menitems [ i ] . setselection ( false ) ; } regex . resetpatternflag ( ) ; } } ) ; }
te	1	public parametermanager ( list < parameter > params ) { this . settitle ( "parameter editor" ) ; this . setmodal ( true ) ; model = new tbmodel ( ) ; model . setparams ( params ) ; table = new jtable ( model ) ; table . setselectionmode ( listselectionmodel . single_selection ) ; table . addmouselistener ( new mouseadapter ( ) { @ override public void mouseclicked ( mouseevent e ) { if ( e . getclickcount ( ) == 2 ) { editparamcell ( ) ; } } } ) ; add ( new jscrollpane ( table ) ) ; add ( getctlpanel ( ) , borderlayout . south ) ; setsize ( 500 , 400 ) ; this . setlocationrelativeto ( null ) ; }
te	7	public void addoperator ( binaryoperator operator ) { if ( ! functioncontextstack . isempty ( ) ) { integer sizeoperators = functioncontextstack . peek ( ) . getsizeoperatorsforparameters ( ) ; if ( sizeoperators != null ) { while ( ! operatorstack . isempty ( ) && sizeoperators != operatorstack . size ( ) && operator . compareto ( operatorstack . peek ( ) ) <= 0 ) { final binaryoperator binaryoperator = operatorstack . pop ( ) ; applyoperator ( binaryoperator ) ; } } } else { while ( ! operatorstack . isempty ( ) && operator . compareto ( operatorstack . peek ( ) ) <= 0 ) { applyoperator ( operatorstack . pop ( ) ) ; } } operatorstack . push ( operator ) ; }
te	6	public registeredeventlistener ( method listenermethod , listener listener ) { eventlistener listenerannotation = listenermethod . getannotation ( eventlistener . class ) ; if ( listenerannotation == null ) { throw new illegalargumentexception ( "listener method does not have an eventlistener annotation." ) ; } priority = listenerannotation . priority ( ) ; ignorescancelled = listenerannotation . ignorecancelled ( ) ; class < ? > [ ] listenermethodparameters = listenermethod . getparametertypes ( ) ; if ( listenermethodparameters . length != 1 || ! event . class . isassignablefrom ( listenermethodparameters [ 0 ] ) ) { throw new illegalargumentexception ( "listener method signature invalid. does not have a single event subclass parameter." ) ; } eventtype = ( class < ? extends event > ) listenermethodparameters [ 0 ] ; this . listenermethod = listenermethod ; if ( ! listenermethod . isaccessible ( ) ) { listenermethod . setaccessible ( true ) ; } this . listener = listener ; }
te	6	@ override public object eval ( oclcontext context ) throws oclevaluationexception { if ( "string" . equals ( this . referredtype ) ) { return string . class ; } else if ( "boolean" . equals ( this . referredtype ) ) { return boolean . class ; } else if ( "integer" . equals ( this . referredtype ) ) { return integer . class ; } else if ( "real" . equals ( this . referredtype ) ) { return double . class ; } else if ( "oclvoid" . equals ( this . referredtype ) ) { return void . class ; } else if ( "oclany" . equals ( this . referredtype ) ) { return object . class ; } else { return context . gettype ( this . referredtype ) ; } }
te	3	@ test public void testcreatefeatureholder ( ) { functionexecutor < void > executor = new functionexecutor < void > ( ) { @ override public void invoke ( functioninvocation < void > invocation , object ... arguments ) throws executorinvocationexception { return invocation . next ( arguments ) ; } } ; functiondefinition . addexecutor ( featureholder . class , "default" , executor ) ; functiondefinition . setparameter ( 0 , string . class ) ; function < void > function = functiondefinition . create ( new defaultfeatureholder ( ) ) ; list < class < ? >> expectedparameters = new arraylist < class < ? >> ( ) ; expectedparameters . add ( string . class ) ; set < functionexecutor < void >> expectedexecutors = new hashset < functionexecutor < void >> ( ) ; expectedexecutors . add ( executor ) ; set < functionexecutor < void >> actualexecutors = new hashset < functionexecutor < void >> ( ) ; for ( functionexecutorcontext < void > context : function . getexecutors ( ) ) { actualexecutors . add ( context . getexecutor ( ) ) ; } assert . assertequals ( "function object's parameters" , expectedparameters , function . getparameters ( ) ) ; assert . assertequals ( "function object's executors" , expectedexecutors , actualexecutors ) ; }
te	1	@ override public iterator < e > iterator ( ) { return new iterator < e > ( ) { private container < e > current = leftsentinel ; @ override public boolean hasnext ( ) { return current . successor != null ; } @ override public e next ( ) { if ( current . successor == null ) { throw new nosuchelementexception ( ) ; } e item = current . successor . item ; current = current . successor ; return item ; } @ override public void remove ( ) { throw new unsupportedoperationexception ( ) ; } } ; }
te	4	public void addtile ( vector3d [ ] corners , color c , boolean issolid , boolean isconcave ) { vector < vector3d > wire1 = new vector < > ( ) ; vector < vector3d > wire2 = new vector < > ( ) ; float h1 = corners [ 0 ] . z + corners [ 2 ] . z ; float h2 = corners [ 1 ] . z + corners [ 3 ] . z ; if ( h1 < h2 && isconcave || h1 > h2 && ! isconcave ) { wire1 . addelement ( corners [ 0 ] ) ; wire1 . addelement ( corners [ 1 ] ) ; wire1 . addelement ( corners [ 2 ] ) ; wire1 . addelement ( corners [ 0 ] ) ; wire2 . addelement ( corners [ 2 ] ) ; wire2 . addelement ( corners [ 3 ] ) ; wire2 . addelement ( corners [ 0 ] ) ; wire2 . addelement ( corners [ 2 ] ) ; } else { wire1 . addelement ( corners [ 0 ] ) ; wire1 . addelement ( corners [ 1 ] ) ; wire1 . addelement ( corners [ 3 ] ) ; wire1 . addelement ( corners [ 0 ] ) ; wire2 . addelement ( corners [ 2 ] ) ; wire2 . addelement ( corners [ 3 ] ) ; wire2 . addelement ( corners [ 1 ] ) ; wire2 . addelement ( corners [ 2 ] ) ; } addwire ( wire1 , c , issolid , true ) ; addwire ( wire2 , c , issolid , true ) ; }
te	8	public getdatabysubjectpanel ( jframe frame , querydefinition query ) throws exception { super ( frame , query , new getdatabysubject ( query . getdocument ( ) ) ) ; jtabbedpane panel = new jtabbedpane ( ) ; itemset < subjectid > subitems = new itemset < subjectid > ( ) { @ override public void add ( subjectid item ) { getdatabysubjectpanel . this . getrequest ( ) . addsubject ( item ) ; statechanged ( new getdatabysubjectpanelchangeevent ( getdatabysubjectpanel . this ) ) ; } @ override public void remove ( subjectid item ) { getdatabysubjectpanel . this . getrequest ( ) . removesubject ( item ) ; statechanged ( new getdatabysubjectpanelchangeevent ( getdatabysubjectpanel . this ) ) ; } @ override public int size ( ) { return getdatabysubjectpanel . this . getrequest ( ) . getsubjectcount ( ) ; } @ override public subjectid get ( int index ) { return getdatabysubjectpanel . this . getrequest ( ) . getsubject ( index ) ; } @ override public void set ( int index , string name , object value ) { subjectid id = this . get ( index ) ; if ( name . equals ( "contributor" ) ) { id . setcontributor ( ( contributor ) value ) ; } else if ( name . equals ( "value" ) ) { id . setvalue ( ( string ) value ) ; } getdatabysubjectpanel . this . getrequest ( ) . notifychange ( ) ; statechanged ( new getdatabysubjectpanelchangeevent ( getdatabysubjectpanel . this ) ) ; } } ; itemtablepanel < subjectid > subjectspanel = new itemtablepanel < subjectid > ( subjectid . class , subitems ) ; panel . add ( "subject ids" , subjectspanel ) ; itemset < parameter > paramitems = new itemset < parameter > ( ) { @ override public void add ( parameter item ) { getdatabysubjectpanel . this . getrequest ( ) . addparameter ( item ) ; statechanged ( new getdatabysubjectpanelchangeevent ( getdatabysubjectpanel . this ) ) ; } @ override public void remove ( parameter item ) { getdatabysubjectpanel . this . getrequest ( ) . removeparameters ( item ) ; statechanged ( new getdatabysubjectpanelchangeevent ( getdatabysubjectpanel . this ) ) ; } @ override public int size ( ) { return getdatabysubjectpanel . this . getrequest ( ) . getparametercount ( ) ; } @ override public parameter get ( int index ) { return getdatabysubjectpanel . this . getrequest ( ) . getparameter ( index ) ; } @ override public void set ( int index , string name , object value ) { parameter id = this . get ( index ) ; if ( name . equals ( "name" ) ) { id . setname ( ( string ) value ) ; } else if ( name . equals ( "value" ) ) { id . setvalue ( ( string ) value ) ; } getdatabysubjectpanel . this . getrequest ( ) . notifychange ( ) ; statechanged ( new getdatabysubjectpanelchangeevent ( getdatabysubjectpanel . this ) ) ; } } ; itemtablepanel < parameter > paramspanel = new itemtablepanel < parameter > ( parameter . class , paramitems ) ; panel . add ( "parameters" , paramspanel ) ; itemset < logentry > logitems = new itemset < logentry > ( ) { @ override public void add ( logentry item ) { getdatabysubjectpanel . this . getrequest ( ) . addlog ( item ) ; statechanged ( new getdatabysubjectpanelchangeevent ( getdatabysubjectpanel . this ) ) ; } @ override public void remove ( logentry item ) { getdatabysubjectpanel . this . getrequest ( ) . removelog ( item ) ; statechanged ( new getdatabysubjectpanelchangeevent ( getdatabysubjectpanel . this ) ) ; } @ override public int size ( ) { return getdatabysubjectpanel . this . getrequest ( ) . getlogcount ( ) ; } @ override public logentry get ( int index ) { return getdatabysubjectpanel . this . getrequest ( ) . getlog ( index ) ; } @ override public void set ( int index , string name , object value ) { logentry id = this . get ( index ) ; if ( name . equals ( "value" ) ) { id . setvalue ( ( string ) value ) ; } getdatabysubjectpanel . this . getrequest ( ) . notifychange ( ) ; statechanged ( new getdatabysubjectpanelchangeevent ( getdatabysubjectpanel . this ) ) ; } } ; itemtablepanel < logentry > logpanel = new itemtablepanel < logentry > ( logentry . class , logitems ) ; panel . add ( "logs" , logpanel ) ; jpanel otherpanel = new jpanel ( ) ; otherpanel . setlayout ( new gridbaglayout ( ) ) ; gridbagconstraints cmain = new gridbagconstraints ( ) ; cmain . fill = gridbagconstraints . horizontal ; cmain . anchor = gridbagconstraints . page_start ; cmain . gridx = 0 ; cmain . gridy = 0 ; jpanel trxidpanel = new jpanel ( ) ; gridbagconstraints c = new gridbagconstraints ( ) ; trxidpanel . setlayout ( new gridbaglayout ( ) ) ; otherpanel . add ( trxidpanel , cmain ) ; panel . add ( "other" , otherpanel ) ; trxidpanel . setborder ( borderfactory . createtitledborder ( "transaction id" ) ) ; this . btngroup = new buttongroup ( ) ; actionlistener btnactions = new actionlistener ( ) { @ override public void actionperformed ( actionevent arg0 ) { if ( getdatabysubjectpanel . this . rdobtnstatic . isselected ( ) ) { getdatabysubjectpanel . this . trxidtextfield . seteditable ( true ) ; getdatabysubjectpanel . this . trxidtextfield . grabfocus ( ) ; getdatabysubjectpanel . this . getrequest ( ) . settransactionidmode ( transactionmode . static ) ; } else if ( getdatabysubjectpanel . this . rdobtnrandom . isselected ( ) ) { getdatabysubjectpanel . this . trxidtextfield . seteditable ( false ) ; getdatabysubjectpanel . this . getrequest ( ) . settransactionidmode ( transactionmode . random ) ; } else if ( getdatabysubjectpanel . this . rdobtnnone . isselected ( ) ) { getdatabysubjectpanel . this . trxidtextfield . seteditable ( false ) ; getdatabysubjectpanel . this . getrequest ( ) . settransactionidmode ( transactionmode . none ) ; } } } ; this . rdobtnnone = new jradiobutton ( "none" , true ) ; this . rdobtnnone . addactionlistener ( btnactions ) ; this . btngroup . add ( this . rdobtnnone ) ; c . fill = gridbagconstraints . horizontal ; c . anchor = gridbagconstraints . northwest ; c . gridx = 0 ; c . gridy = 0 ; trxidpanel . add ( this . rdobtnnone , c ) ; this . rdobtnrandom = new jradiobutton ( "random" ) ; this . rdobtnrandom . addactionlistener ( btnactions ) ; this . btngroup . add ( this . rdobtnrandom ) ; c . gridx = 0 ; c . gridy = 1 ; trxidpanel . add ( this . rdobtnrandom , c ) ; this . rdobtnstatic = new jradiobutton ( "static" ) ; this . rdobtnstatic . addactionlistener ( btnactions ) ; this . btngroup . add ( this . rdobtnstatic ) ; c . gridx = 0 ; c . gridy = 2 ; trxidpanel . add ( this . rdobtnstatic , c ) ; this . trxidtextfield = new jtextfield ( ) ; this . trxidtextfield . addactionlistener ( this ) ; this . trxidtextfield . seteditable ( false ) ; c . fill = gridbagconstraints . horizontal ; c . weightx = 0.5 ; c . gridx = 1 ; c . gridy = 2 ; trxidpanel . add ( this . trxidtextfield , c ) ; jpanel bufferpanel = new jpanel ( ) ; cmain . gridx = 0 ; cmain . gridy = 1 ; cmain . weightx = 1 ; cmain . weighty = 1 ; otherpanel . add ( bufferpanel , cmain ) ; this . trxidtextfield . getdocument ( ) . adddocumentlistener ( new documentlistener ( ) { @ override public void changedupdate ( documentevent arg0 ) { string text = getdatabysubjectpanel . this . trxidtextfield . gettext ( ) ; getdatabysubjectpanel . this . getrequest ( ) . settransactionid ( text ) ; statechanged ( null ) ; } @ override public void insertupdate ( documentevent arg0 ) { this . changedupdate ( arg0 ) ; } @ override public void removeupdate ( documentevent arg0 ) { this . changedupdate ( arg0 ) ; } } ) ; this . addfirsttab ( "fields" , panel ) ; }
te	7	private void writefile ( string data , boolean isappend ) { if ( ! exists ( ) ) { try { createnewfile ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } } bufferedwriter bfwriter = null ; try { filewriter flwriter = null ; if ( isappend ) { flwriter = new filewriter ( this , true ) ; } else { flwriter = new filewriter ( this ) ; } bfwriter = new bufferedwriter ( flwriter ) ; if ( isappend ) { bfwriter . newline ( ) ; } bfwriter . write ( data ) ; bfwriter . close ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } finally { try { if ( bfwriter != null ) bfwriter . close ( ) ; } catch ( ioexception ex ) { ex . printstacktrace ( ) ; } } }
te	9	public int synthesis ( packet op ) { info vi = vd . vi ; opb . readinit ( op . packet_base , op . packet , op . bytes ) ; if ( opb . read ( 1 ) != 0 ) { return ( - 1 ) ; } int _mode = opb . read ( vd . modebits ) ; if ( _mode == - 1 ) return ( - 1 ) ; mode = _mode ; w = vi . mode_param [ mode ] . blockflag ; if ( w != 0 ) { lw = opb . read ( 1 ) ; nw = opb . read ( 1 ) ; if ( nw == - 1 ) return ( - 1 ) ; } else { lw = 0 ; nw = 0 ; } granulepos = op . granulepos ; sequence = op . packetno - 3 ; eofflag = op . e_o_s ; pcmend = vi . blocksizes [ w ] ; if ( pcm . length < vi . channels ) { pcm = new float [ vi . channels ] [ ] ; } for ( int i = 0 ; i < vi . channels ; i ++ ) { if ( pcm [ i ] == null || pcm [ i ] . length < pcmend ) { pcm [ i ] = new float [ pcmend ] ; } else { for ( int j = 0 ; j < pcmend ; j ++ ) { pcm [ i ] [ j ] = 0 ; } } } int type = vi . map_type [ vi . mode_param [ mode ] . mapping ] ; return ( funcmapping . mapping_p [ type ] . inverse ( this , vd . mode [ mode ] ) ) ; }
te	5	public sla checkslaallocationcostmin ( sla slatemplate ) { sla slaallocation = ( sla ) slatemplate . clone ( ) ; map < string , type [ ] > allocations = new hashmap < string , type [ ] > ( ) ; set < type > alltypes = slaallocation . getheadnode ( ) . getconnectedtypes ( ) ; type sometype = alltypes . iterator ( ) . next ( ) ; list < resource > orderedresources = new arraylist < resource > ( ) ; orderedresources . addall ( resources . values ( ) ) ; collections . sort ( orderedresources , new costmincomparator ( sometype . getstarttime ( ) , sometype . getduration ( ) ) ) ; iterator < resource > resourceiterator = orderedresources . iterator ( ) ; iterator < type > typeiterator = alltypes . iterator ( ) ; resource r = resourceiterator . next ( ) ; list < type > typesforaresource = new arraylist < type > ( ) ; while ( typeiterator . hasnext ( ) ) { type t = typeiterator . next ( ) ; typesforaresource . add ( t ) ; while ( ! r . istypesfitting ( typesforaresource . toarray ( new type [ typesforaresource . size ( ) ] ) ) ) { typesforaresource . remove ( t ) ; if ( resourceiterator . hasnext ( ) ) { if ( typesforaresource . size ( ) > 0 ) { allocations . put ( r . getid ( ) , typesforaresource . toarray ( new type [ typesforaresource . size ( ) ] ) ) ; typesforaresource = new arraylist < type > ( ) ; } typesforaresource . add ( t ) ; r = resourceiterator . next ( ) ; } else { return null ; } } } if ( typesforaresource . size ( ) > 0 ) { allocations . put ( r . getid ( ) , typesforaresource . toarray ( new type [ typesforaresource . size ( ) ] ) ) ; } slaallocation . setallocation ( allocations ) ; return slaallocation ; }
te	8	public t resolve ( string name , predicate < t > filter ) { name = name . trim ( ) ; t temp = map . get ( name ) ; if ( temp != null ) { return temp ; } name = name . tolowercase ( ) ; while ( name . length ( ) > 0 ) { sortedmap < string , t > - = map . submap ( name , name + "z" ) ; if ( - . isempty ( ) ) { break ; } iterator < t > iter = - . values ( ) . iterator ( ) ; t first = null ; fail : { while ( iter . hasnext ( ) ) { t next = iter . next ( ) ; if ( ! filter . test ( next ) ) { continue ; } if ( first == null ) { first = next ; } else if ( first != next ) { break fail ; } } return first ; } if ( first == null ) { break ; } name = name . substring ( 0 , name . length ( ) - 1 ) ; } return null ; }
te	5	public static void execute ( icommand command ) throws fogbugzexception { if ( getpage ( ) == null && ! checkingapi ) { checkapi ( ) ; } if ( ! checkingapi && ! loggedin ) { logger . info ( "token was not set. trying to login." ) ; login ( ) ; if ( gettoken ( ) . gettoken ( ) != null ) { logger . info ( "login was successful: " + gettoken ( ) . gettoken ( ) ) ; } else { logger . warn ( "login failed." ) ; } } urlfetcher . setcommand ( command ) ; urlfetcher . setconnection ( getconnection ( ) ) ; urlfetcher . settoken ( gettoken ( ) ) ; urlfetcher . setrequestpage ( getpage ( ) ) ; string uri = urlfetcher . generaterequest ( ) ; logger . info ( "using url for request: " + uri ) ; command . addlistener ( processor . getinstance ( ) ) ; command . execute ( uri ) ; }
te	5	public void move ( ) { super . move ( ) ; if ( this . clock % 10 == 0 ) { if ( this . clock % 50 == 0 ) { this . angle = math . pi * 3 / 2 ; } playership p = game . getplayer ( ) ; double dfromplayer = math . sqrt ( math . pow ( p . x - x , 2 ) + math . pow ( p . y - y , 2 ) ) ; if ( dfromplayer < 128 ) { this . angle = math . pi * 3 / 2 ; this . velocity += 1.2 ; } } if ( game . t % 10 == 0 && game . random ( 0 , 1 , 1 ) == 1 ) { shoot ( math . pi * 3 / 2 ) ; } }
te	0	private void drawfire ( int square , int intensity ) { int x = getsquarex ( square ) ; int y = getsquarey ( square ) ; color colorlevel1 = new color ( 255 , 255 , 0 ) ; color colorlevel2 = new color ( 255 , 204 , 0 ) ; color colorlevel3 = new color ( 255 , 153 , 0 ) ; color colorlevel4 = new color ( 255 , 102 , 0 ) ; color colorlevel5 = new color ( 255 , 51 , 0 ) ; color colorlevel6 = new color ( 255 , 0 , 0 ) ; color [ ] firecolor = { null , color . dark_gray , colorlevel1 , colorlevel2 , colorlevel3 , colorlevel4 , colorlevel5 , colorlevel6 } ; color squarecolor = firecolor [ intensity ] ; g . setcolor ( squarecolor ) ; this . g . fillrect ( x , y , this . length , this . length ) ; g . setcolor ( color . black ) ; }
te	3	public void read ( ) throws ioexception { inputstream fis ; bufferedreader br ; string line ; fis = new fileinputstream ( filelocation ) ; br = new bufferedreader ( new inputstreamreader ( fis , charset . forname ( "utf-8" ) ) ) ; boolean skipline = true ; while ( ( line = br . readline ( ) ) != null ) { if ( ! skipline ) { string [ ] split = line . split ( ";" ) ; int repetitions = integer . parseint ( split [ split . length - 1 ] ) ; for ( int i = 0 ; i < repetitions ; i ++ ) { testparameters . add ( line ) ; } } else { skipline = false ; } } br . close ( ) ; br = null ; fis = null ; }
te	7	public static string [ ] delimitedlisttostringarray ( string str , string delimiter , string charstodelete ) { if ( str == null ) { return new string [ 0 ] ; } if ( delimiter == null ) { return new string [ ] { str } ; } list < string > result = new arraylist < string > ( ) ; if ( "" . equals ( delimiter ) ) { for ( int i = 0 ; i < str . length ( ) ; i ++ ) { result . add ( deleteany ( str . substring ( i , i + 1 ) , charstodelete ) ) ; } } else { int pos = 0 ; int delpos ; while ( ( delpos = str . indexof ( delimiter , pos ) ) != - 1 ) { result . add ( deleteany ( str . substring ( pos , delpos ) , charstodelete ) ) ; pos = delpos + delimiter . length ( ) ; } if ( str . length ( ) > 0 && pos <= str . length ( ) ) { result . add ( deleteany ( str . substring ( pos ) , charstodelete ) ) ; } } return tostringarray ( result ) ; }
te	7	public classificationcodetype codetype ( ) { if ( "flg" . equals ( name ( ) ) ) { return classificationcodetype . number ; } if ( "memberstatus" . equals ( name ( ) ) ) { return classificationcodetype . string ; } if ( "servicerank" . equals ( name ( ) ) ) { return classificationcodetype . string ; } if ( "region" . equals ( name ( ) ) ) { return classificationcodetype . number ; } if ( "withdrawalreason" . equals ( name ( ) ) ) { return classificationcodetype . string ; } if ( "productcategory" . equals ( name ( ) ) ) { return classificationcodetype . string ; } if ( "productstatus" . equals ( name ( ) ) ) { return classificationcodetype . string ; } return classificationcodetype . string ; }
te	0	public void mostradades ( dadesreserva dades ) { poblaciovaluelabel . settext ( dades . pob ) ; simpledateformat s = new simpledateformat ( "dd/mm/yyyy" ) ; datainicivaluelabel . settext ( s . format ( dades . dini ) ) ; datafivaluelabel . settext ( s . format ( dades . dfi ) ) ; numocupvaluelabel . settext ( dades . numoc . tostring ( ) ) ; hotelvaluelabel . settext ( dades . nomhotel ) ; habitaciovaluelabel . settext ( dades . nomtipushab ) ; preutotalvaluelabel . settext ( dades . preutotal . tostring ( ) ) ; dnivaluelabel . settext ( dades . dni ) ; nomvaluelabel . settext ( dades . nomclient ) ; cognomsvaluelabel . settext ( dades . cognomsclient ) ; emailvaluelabel . settext ( dades . emailclient ) ; }
te	8	public static void main ( string [ ] args ) { bufferedreader reader = new bufferedreader ( new inputstreamreader ( system . in ) ) ; arraylist < integer > datos = new arraylist < integer > ( 100 ) ; int mayor = 0 ; system . out . println ( "introduzca hasta 100 n\u00fameros ('q' para salir):" ) ; boolean fin = false ; while ( datos . size ( ) < 100 && ! fin ) { system . out . print ( ( datos . size ( ) + 1 ) + ": " ) ; string entrada = null ; try { entrada = reader . readline ( ) ; } catch ( ioexception ex ) { entrada = "q" ; } if ( entrada . equals ( "q" ) ) { fin = true ; } else { try { int num = integer . parseint ( entrada ) ; datos . add ( num ) ; if ( datos . size ( ) == 1 || num > mayor ) mayor = num ; } catch ( numberformatexception ex ) { } } } system . out . println ( ) ; if ( datos . size ( ) == 0 ) system . out . println ( "\u00a1no ha introducido ning\u00fan n\u00famero!" ) ; else system . out . println ( "el n\u00famero mayor es: " + mayor ) ; }
te	6	@ override public object getvalueat ( int rowindex , int columnindex ) { switch ( columnindex ) { case 0 : return liststock . get ( rowindex ) . getid ( ) ; case 1 : return liststock . get ( rowindex ) . getlibelle ( ) ; case 2 : return liststock . get ( rowindex ) . gettype ( ) ; case 3 : return liststock . get ( rowindex ) . getqtitestock ( ) ; case 4 : return liststock . get ( rowindex ) . getprix ( ) ; case 5 : return liststock . get ( rowindex ) . getdepot ( ) . getadresse ( ) ; default : throw new illegalargumentexception ( ) ; } }
te	6	private abstractnode expression ( ) { abstractnode res = simpleexp ( ) ; if ( test ( = ) ) { read ( = , "=" ) ; res = new binopnode ( = , res , simpleexp ( ) ) ; } if ( test ( neq ) ) { read ( neq , "#" ) ; res = new binopnode ( neq , res , simpleexp ( ) ) ; } if ( test ( lo ) ) { read ( lo , "<" ) ; res = new binopnode ( lo , res , simpleexp ( ) ) ; } if ( test ( loeq ) ) { read ( loeq , "<=" ) ; res = new binopnode ( loeq , res , simpleexp ( ) ) ; } if ( test ( hi ) ) { read ( hi , ">" ) ; res = new binopnode ( hi , res , simpleexp ( ) ) ; } if ( test ( hieq ) ) { read ( hieq , ">=" ) ; res = new binopnode ( hieq , res , simpleexp ( ) ) ; } return res ; }
te	5	public void sortdyes ( ) { vector < dyeparent > newdyes = new vector < dyeparent > ( ) ; vector < dyeparent > newlakks = new vector < dyeparent > ( ) ; vector < dyeparent > newmetals = new vector < dyeparent > ( ) ; vector < dyeparent > newfluos = new vector < dyeparent > ( ) ; for ( int i = 0 ; i < ppc . calcobj . getalldyetypes ( ) . size ( ) ; i ++ ) { if ( ppc . calcobj . getalldyetypes ( ) . get ( i ) . getclass ( ) == dye . class ) { newdyes . addelement ( ppc . calcobj . getalldyetypes ( ) . get ( i ) ) ; } else if ( ppc . calcobj . getalldyetypes ( ) . get ( i ) . getclass ( ) == lakk . class ) { newlakks . addelement ( ppc . calcobj . getalldyetypes ( ) . get ( i ) ) ; } else if ( ppc . calcobj . getalldyetypes ( ) . get ( i ) . getclass ( ) == metal . class ) { newmetals . addelement ( ppc . calcobj . getalldyetypes ( ) . get ( i ) ) ; } else if ( ppc . calcobj . getalldyetypes ( ) . get ( i ) . getclass ( ) == fluo . class ) { newfluos . addelement ( ppc . calcobj . getalldyetypes ( ) . get ( i ) ) ; } } ppc . calcobj . getalldyetypes ( ) . removeallelements ( ) ; ppc . calcobj . getalldyetypes ( ) . addall ( newdyes ) ; ppc . calcobj . getalldyetypes ( ) . addall ( newlakks ) ; ppc . calcobj . getalldyetypes ( ) . addall ( newmetals ) ; ppc . calcobj . getalldyetypes ( ) . addall ( newfluos ) ; }
te	9	public static int tally ( int [ ] parvalues , string [ ] scoresheet ) { int score = 0 ; for ( int i = 0 ; i < parvalues . length ; i ++ ) { int stroke ; switch ( scoresheet [ i ] ) { case "triple bogey" : stroke = 3 ; break ; case "double bogey" : stroke = 2 ; break ; case "bogey" : stroke = 1 ; break ; case "par" : stroke = 0 ; break ; case "birdie" : stroke = - 1 ; break ; case "eagle" : stroke = - 2 ; break ; case "albatross" : stroke = - 3 ; break ; case "hole in one" : stroke = - 1 * ( parvalues [ i ] - 1 ) ; break ; default : stroke = integer . min_value ; } score += parvalues [ i ] + stroke ; } return score ; }
te	7	protected final short get_action ( int state , int sym ) { short tag ; int first , last , probe ; short [ ] row = action_tab [ state ] ; if ( row . length < 20 ) for ( probe = 0 ; probe < row . length ; probe ++ ) { tag = row [ probe ++ ] ; if ( tag == sym || tag == - 1 ) { return row [ probe ] ; } } else { first = 0 ; last = ( row . length - 1 ) / 2 - 1 ; while ( first <= last ) { probe = ( first + last ) / 2 ; if ( sym == row [ probe * 2 ] ) return row [ probe * 2 + 1 ] ; else if ( sym > row [ probe * 2 ] ) first = probe + 1 ; else last = probe - 1 ; } return row [ row . length - 1 ] ; } return 0 ; }
te	7	private boolean checkintersects ( point point ) { if ( foundsegment == null ) return false ; segment sega = new segment ( foundsegment . segment . getpointa ( ) , point ) ; segment segb = new segment ( foundsegment . segment . getpointb ( ) , point ) ; for ( polygon p : getallpolygons ( ) ) { for ( segment s : p . getsegments ( ) ) { point pt ; if ( ( pt = geomutils . intersectonlypoint ( sega , s ) ) != null ) { if ( ! foundsegment . segment . lies ( pt ) ) return false ; } if ( ( pt = geomutils . intersectonlypoint ( segb , s ) ) != null ) { if ( ! foundsegment . segment . lies ( pt ) ) return false ; } } } return true ; }
te	0	@ test public void testisverbending ( ) { dataholder mydataholder = dataholderfactory ( ) ; mydataholder . add2holder ( dataholder . unknownword , arrays . aslist ( "bearing unknown" . split ( " " ) ) ) ; mydataholder . add2holder ( dataholder . unknownword , arrays . aslist ( "doubling unknown" . split ( " " ) ) ) ; assertequals ( "isverbending - case 1 - true" , true , unknownwordbootstrappingmodule . isverbending ( mydataholder , "doubles" ) ) ; assertequals ( "isverbending - case 1 - false" , false , unknownwordbootstrappingmodule . isverbending ( mydataholder , "achenes" ) ) ; assertequals ( "isverbending - case 2 - true" , true , unknownwordbootstrappingmodule . isverbending ( mydataholder , "bears" ) ) ; assertequals ( "isverbending - case 2 - false" , false , unknownwordbootstrappingmodule . isverbending ( mydataholder , "armenia" ) ) ; }
te	9	public getnounsafterptnreturnvalue getnounsafterptn ( dataholder dataholderhandler , string sentence , int startwordindex ) { propertyconfigurator . configure ( "conf/log4j.properties" ) ; logger mylogger = logger . getlogger ( "learn.getnounsafterpattern" ) ; mylogger . trace ( string . format ( "enter (%s  %d)" , sentence , startwordindex ) ) ; string bword = "" ; list < string > nouns = new arraylist < string > ( ) ; list < string > nounptn = new arraylist < string > ( ) ; list < string > tempwords = new arraylist < string > ( ) ; tempwords . addall ( tokenizetext ( sentence , "firstseg" ) ) ; list < string > words = stringutility . stringarraysplice ( tempwords , startwordindex , tempwords . size ( ) ) ; mylogger . trace ( "words: " + words ) ; string ptn = this . getposptn ( dataholderhandler , words ) ; mylogger . trace ( "ptn: " + ptn ) ; if ( ptn != null ) { matcher m1 = stringutility . creatematcher ( ptn , "^([psn]+)" ) ; matcher m2 = stringutility . creatematcher ( ptn , "^(\\?+)" ) ; boolean case1 = false ; boolean case2 = false ; int end = - 1 ; if ( m1 . find ( ) ) { case1 = true ; end = m1 . end ( 1 ) ; } if ( m2 . find ( ) ) { case2 = true ; end = m2 . end ( 1 ) ; } if ( case1 || case2 ) { mylogger . trace ( "end: " + end ) ; if ( end < words . size ( ) ) { bword = words . get ( end ) ; } list < string > nwords = new arraylist < string > ( ) ; nwords . addall ( stringutility . stringarraysplice ( words , 0 , end ) ) ; for ( int i = 0 ; i < nwords . size ( ) ; i ++ ) { string p = ptn . substring ( i , i + 1 ) ; p = stringutils . equals ( p , "?" ) ? this . mywordformutility . checkwn ( nwords . get ( i ) , "pos" ) : p ; if ( stringutility . creatematcher ( p , "^[psn]+$" ) . find ( ) ) { nouns . add ( nwords . get ( i ) ) ; nounptn . add ( p ) ; } else { bword = nwords . get ( i ) ; break ; } } } } getnounsafterptnreturnvalue returnvalue = new getnounsafterptnreturnvalue ( nouns , nounptn , bword ) ; mylogger . trace ( "return " + returnvalue ) ; return ( returnvalue ) ; }
te	3	@ subscribe public void unitcommand ( unitcommandevent e ) { if ( system . currenttimemillis ( ) - lastcmdsnd < cmd_snd_delay ) { return ; } unitcommand cmd = e . getcommand ( ) ; int snd ; if ( cmd . gettype ( ) == unitcommandtype . move ) { snd = ( int ) ( math . random ( ) * 4 ) ; playsound ( "go" + snd + ".wav" , 0.8f ) ; } else if ( cmd . gettype ( ) . isattack ( ) ) { snd = ( int ) ( math . random ( ) * 2 ) ; playsound ( "attack" + snd + ".wav" , 0.8f ) ; } lastcmdsnd = system . currenttimemillis ( ) ; }
te	8	public void searchcontacts ( string search ) { try { arraylist < contact > results = new arraylist < > ( 1 ) ; string [ ] searcharray = search . split ( " " ) ; for ( contact c : contacts ) { if ( c . getfirstname ( ) . contains ( searcharray [ 0 ] ) ) results . add ( c ) ; else if ( c . getlastname ( ) . contains ( searcharray [ searcharray . length - 1 ] ) ) results . add ( c ) ; else if ( c . getphone ( ) . contains ( search ) ) results . add ( c ) ; else if ( c . getemail ( ) . contains ( search ) ) results . add ( c ) ; } if ( results . size ( ) < 1 ) throw new contactnotfoundexception ( ) ; system . out . println ( "search results:" ) ; for ( contact c : results ) { system . out . println ( c ) ; } confirmdeleterecords ( results ) ; } catch ( contactnotfoundexception e ) { system . out . println ( e . getmessage ( ) ) ; return ; } }
te	5	public static void exportpdf ( final file pdflatex , final file workingdir , final string problem , final string solution , final mainframe mainframe ) { final java . util . date date = new java . util . date ( ) ; final java . sql . timestamp ts = new java . sql . timestamp ( date . gettime ( ) ) ; final string timestamp = ts . tostring ( ) . replaceall ( ":" , "-" ) ; final stringbuilder filename = new stringbuilder ( ) ; filename . append ( workingdir . getabsolutepath ( ) ) . append ( file . separator ) ; filename . append ( "priklad " ) . append ( timestamp ) . append ( ".tex" ) ; final file texfile = new file ( filename . tostring ( ) ) ; writetexfile ( texfile , problem , solution ) ; final string errormsgheader = "chyba p\u0159i exportu do pdf" ; final string errormsg = "p\u0159eklad pdflatexem zlyhal." ; try { final jlrgenerator pdfgenerator = new jlrgenerator ( ) ; pdfgenerator . deletetempfiles ( false , true , true ) ; if ( pdflatex == null ) { if ( pdfgenerator . generate ( texfile , workingdir , workingdir ) ) jlropener . open ( pdfgenerator . getpdf ( ) ) ; } else { if ( pdfgenerator . generate ( pdflatex , 1 , texfile , workingdir , workingdir ) ) jlropener . open ( pdfgenerator . getpdf ( ) ) ; } if ( ! pdfgenerator . geterrormessage ( ) . equals ( "no errors occurred!" ) ) { userinputchecker . error ( mainframe , errormsgheader , errormsg ) ; system . err . println ( pdfgenerator . geterrormessage ( ) ) ; } } catch ( ioexception ex ) { userinputchecker . error ( mainframe , errormsgheader , errormsg ) ; system . err . println ( ex . getmessage ( ) ) ; } }
te	2	public void createmosquitos ( int n ) { mosquitos = new hashset < mosquito > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { point2d p = new point2d . double ( 1 + gameconfig . random . nextdouble ( ) * 98 , 1 + gameconfig . random . nextdouble ( ) * 98 ) ; while ( collideswithwall ( p ) ) p = new point2d . double ( 1 + gameconfig . random . nextdouble ( ) * 98 , 1 + gameconfig . random . nextdouble ( ) * 98 ) ; mosquitos . add ( new mosquito ( p ) ) ; } }
te	2	public static set < set < integer >> allsubset ( set < integer > s ) { set < set < integer >> pre = new hashset < > ( ) ; for ( integer e : s ) { set < set < integer >> dup = new hashset < > ( ) ; for ( set < integer > ss : pre ) { dup . add ( new hashset < integer > ( ss ) ) ; ss . add ( e ) ; } pre . addall ( dup ) ; pre . add ( new hashset < integer > ( arrays . aslist ( e ) ) ) ; } return pre ; }
te	2	public void newfile ( ) { final string title = "create new list" ; final string message = "enter list name:" ; string name = joptionpane . showinputdialog ( null , message , title , joptionpane . plain_message ) ; if ( name == null ) return ; if ( ! closefile ( ) ) return ; current_file = null ; getlistmanager ( ) . setlist ( new sklist ( name ) ) ; getlistmanager ( ) . clearhistory ( ) ; dirty = false ; console . verbose ( "created new list (" + console . italics ( name ) + ")" ) ; refreshtitle ( ) ; }
te	3	@ override public void mouseclicked ( mouseevent e ) { jtable table = ( jtable ) e . getsource ( ) ; point pt = e . getpoint ( ) ; int ccol = table . columnatpoint ( pt ) ; if ( isurlcolumn ( table , ccol ) ) { int crow = table . rowatpoint ( pt ) ; url url = ( url ) table . getvalueat ( crow , ccol ) ; system . out . println ( url ) ; try { if ( desktop . isdesktopsupported ( ) ) { desktop . getdesktop ( ) . browse ( url . touri ( ) ) ; } } catch ( exception ex ) { ex . printstacktrace ( ) ; } } }
te	9	public int spendpoint ( int id , int currentlevel ) { if ( id == player . max_health_id ) { if ( this . skillpoints >= ( currentlevel + 1 ) ) { if ( currentlevel < 5 ) { this . skillpoints -= ( currentlevel + 1 ) ; this . maxhealth += player . max_health_inc ; this . addhealth ( player . max_health_inc ) ; synchronized ( globals . game_messages ) { globals . game_messages . add ( new message ( "max health increased!" , 5000 ) ) ; } return 1 ; } } } else if ( id == player . damage_id ) { if ( this . skillpoints >= ( currentlevel + 1 ) ) { if ( currentlevel < 5 ) { this . skillpoints -= ( currentlevel + 1 ) ; this . damagebonus += player . damage_inc ; synchronized ( globals . game_messages ) { globals . game_messages . add ( new message ( "damage increased!" , 5000 ) ) ; } return 1 ; } } } else if ( id == player . speed_id ) { if ( this . skillpoints >= ( currentlevel + 1 ) ) { if ( currentlevel < 5 ) { this . skillpoints -= ( currentlevel + 1 ) ; this . speedbonus += player . speed_inc ; synchronized ( globals . game_messages ) { globals . game_messages . add ( new message ( "speed increased!" , 5000 ) ) ; } return 1 ; } } } return 0 ; }
te	8	public static void main ( string [ ] args ) { int x , m ; int a1 , a2 , a3 ; int m1 , m2 , m3 ; int m1 , m2 , m3 ; int y1 , y2 , y3 ; y1 = y2 = y3 = 1 ; scanner in = new scanner ( system . in ) ; a1 = in . nextint ( ) ; m1 = in . nextint ( ) ; a2 = in . nextint ( ) ; m2 = in . nextint ( ) ; a3 = in . nextint ( ) ; m3 = in . nextint ( ) ; m = m1 * m2 * m3 ; m1 = m / m1 ; m2 = m / m2 ; m3 = m / m3 ; for ( int i = 1 ; i <= m1 ; i ++ ) { if ( congruent ( m1 * i , 1 , m1 ) ) { y1 = i ; break ; } } for ( int i = 1 ; i <= m2 ; i ++ ) { if ( congruent ( m2 * i , 1 , m2 ) ) { y2 = i ; break ; } } for ( int i = 1 ; i <= m3 ; i ++ ) { if ( congruent ( m3 * i , 1 , m3 ) ) { y3 = i ; break ; } } x = a1 * m1 * y1 + a2 * m2 * y2 + a3 * m3 * y3 ; int answer = 1 ; for ( int i = 1 ; i <= x ; i ++ ) { if ( congruent ( x , i , m ) ) { answer = i ; break ; } } system . out . println ( "a resposta \u00e9 " + answer ) ; system . out . println ( "se a resposta dada n\u00e3o est\u00e1 num intervalo dado pelo problema  apenas adicione " + m + " \u00e0 resposta at\u00e9 que esteja" ) ; }
te	8	public int applybonatotest ( double [ ] variances ) { int i = signals . get ( 0 ) . size ( ) / 2 ; int onset = integer . max_value ; for ( int k = 0 ; k < sensorsize ; k ++ ) { bonatosigns . get ( k ) . clear ( ) ; cumulativesignscounter [ k ] = 0 ; for ( int j = 0 ; j < i ; j ++ ) { int j_k1 = signals . get ( k ) . get ( j * 2 ) ; int j_k2 = signals . get ( k ) . get ( ( j * 2 ) + 1 ) ; double g_j = math . pow ( ( j_k1 + j_k2 ) , 2 ) / variances [ k ] ; if ( g_j > this . threshold_h ) { bonatosigns . get ( k ) . add ( true ) ; cumulativesignscounter [ k ] ++ ; } else { bonatosigns . get ( k ) . add ( false ) ; cumulativesignscounter [ k ] = 0 ; } } for ( int j = 0 ; j < sensorsize ; j ++ ) { if ( cumulativesignscounter [ j ] > threshold_m ) { system . out . println ( "onset" ) ; for ( int j2 = 0 ; j2 < i ; j2 ++ ) { if ( bonatosigns . get ( k ) . get ( j2 ) ) { if ( j2 * 2 < onset ) { onset = j2 * 2 ; system . out . println ( "onset" ) ; } break ; } } } } } return onset ; }
te	5	static private vector < double [ ] > sampleresults ( vector < future < vector < double [ ] >>> results , int bins ) throws exception { int ndescriptors = results . get ( 0 ) . get ( ) . get ( 0 ) . length ; system . out . println ( "printing for " + ndescriptors + " descriptors" ) ; vector < double [ ] > descriptors = new vector < double [ ] > ( ndescriptors ) ; for ( int d = 0 ; d < ndescriptors ; ++ d ) { double [ ] averages = new double [ bins ] ; for ( future < vector < double [ ] >> result : results ) { vector < double [ ] > samples = result . get ( ) ; int samplesperbin = samples . size ( ) / bins ; for ( int b = 0 ; b < bins ; ++ b ) { double sum = 0 ; int counted = 0 ; for ( int s = 0 ; s < samplesperbin && b * samplesperbin + s < samples . size ( ) ; ++ s ) { sum += samples . get ( b * samplesperbin + s ) [ d ] ; counted += 1 ; } averages [ b ] = sum / counted ; } } descriptors . add ( averages ) ; } return descriptors ; }
te	2	@ override public codefragment visitvar_def ( magicparser . var_defcontext ctx ) { codefragment code = new codefragment ( ) ; type type = visit ( ctx . type ( ) ) . gettype ( ) ; string id = ctx . id ( ) . gettext ( ) ; magicparser . expressioncontext exp = ctx . expression ( ) ; codefragment var_code = declvar ( id , type , new codeposition ( ctx ) ) ; code . addcode ( var_code ) ; code . setregister ( var_code . getregister ( ) ) ; code . settype ( var_code . gettype ( ) ) ; codefragment val ; variable var = getvar ( id , new codeposition ( ctx ) ) ; if ( exp != null ) { val = visit ( exp ) ; } else { if ( var . gettype ( ) instanceof listtype ) { val = generatelistconstant ( ( ( listtype ) var . gettype ( ) ) . getsubtype ( ) , new arglistcodefragment ( ) ) ; } else { val = generateconstant ( var . gettype ( ) , var . gettype ( ) . getdefaultvalue ( ) ) ; } } codefragment assign = generateassigncode ( var , val , new codeposition ( ctx ) ) ; code . appendcodefragment ( assign ) ; return code ; }
te	5	public synchronized boolean findsdslinstances ( ) { knownsdslinstances = new arraylist < sdsl > ( ) ; boolean found = false ; listiterator < line > it = gct . getcodelines ( ) . listiterator ( ) ; while ( it . hasnext ( ) ) { line l = it . next ( ) ; if ( l . startswith ( "28708ceb 000000" ) ) { line [ ] code = new line [ 4 ] ; code [ 0 ] = l ; code [ 1 ] = it . next ( ) ; if ( code [ 1 ] . startswith ( "4a000000 90180f06" ) ) { code [ 2 ] = it . next ( ) ; if ( code [ 2 ] . startswith ( "14000076 ff00" ) ) { code [ 3 ] = it . next ( ) ; if ( code [ 3 ] . startswith ( "e0000000 80008000" ) ) { found = true ; sdsl sdsl = new sdsl ( code ) ; knownsdslinstances . add ( sdsl ) ; gct . recorddynamiccode ( sdsl ) ; } } } } } return found ; }
te	9	@ suppresswarnings ( { "unchecked" } ) public static < k , v > map < k , v > generatemapfield ( class < k > keytype , class < v > valuetype ) { random random = new random ( 987654321 ) ; map < k , v > map = new hashmap < k , v > ( ) ; for ( int i = 0 ; i < 20 ; i ++ ) { k key = null ; if ( keytype == string . class ) { key = ( k ) string . valueof ( random . nextint ( ) ) ; } else if ( keytype == integer . class ) { key = ( k ) integer . valueof ( random . nextint ( ) ) ; } else if ( keytype == long . class ) { key = ( k ) long . valueof ( random . nextlong ( ) ) ; } v value = null ; if ( valuetype == string . class ) { value = ( v ) string . valueof ( random . nextint ( ) ) ; } else if ( valuetype == integer . class ) { value = ( v ) integer . valueof ( random . nextint ( ) ) ; } else if ( valuetype == long . class ) { value = ( v ) long . valueof ( random . nextlong ( ) ) ; } else if ( valuetype == double . class ) { value = ( v ) double . valueof ( random . nextdouble ( ) ) ; } else if ( valuetype == byte [ ] . class ) { byte [ ] bytes = bytes . tobytes ( random . nextint ( ) ) ; value = ( v ) bytes ; } map . put ( key , value ) ; } return map ; }
te	3	@ test public void testdbit ( ) throws exception { final file dir = file . createtempfile ( "sqlscrewdriverjunittest_" , ".db" ) ; dir . delete ( ) ; dir . mkdir ( ) ; final string dbname = new file ( dir , "h2db" ) . getabsolutepath ( ) ; final string comment = "junittestdb" ; final string dbusername = "junittestdb" ; final string dbpassword = "junittestdb" ; final string dburl = "jdbc:h2:" + dbname ; final string driver = "org.h2.driver" ; final string colquote = "\"" ; final boolean readonly = false ; final dbhandle dbhandle = dbutil . buildconnection ( comment , dbusername , dbpassword , dburl , driver , readonly , colquote ) ; exception ex = null ; try { final statement stmt = dbhandle . conn . createstatement ( ) ; stmt . executeupdate ( "create table testtab (iarg int  sarg varchar(128)  biarg numeric(30)  bnarg numeric(30 20)  darg double precision)" ) ; final preparedstatement pstmt = dbhandle . conn . preparestatement ( "insert into testtab (iarg  sarg  biarg  bnarg  darg) values (?  ?  ?  ?  ?)" ) ; pstmt . setint ( 1 , 7 ) ; pstmt . setstring ( 2 , "hi there" ) ; pstmt . setbigdecimal ( 3 , new bigdecimal ( biginteger . ten ) ) ; pstmt . setbigdecimal ( 4 , new bigdecimal ( new biginteger ( "123" ) , 2 ) ) ; pstmt . setdouble ( 5 , 1.7 ) ; pstmt . executeupdate ( ) ; pstmt . close ( ) ; final dbiterable it = new dbiterable ( stmt , "select * from testtab" ) ; long n = 0 ; for ( final burstmap row : it ) { final long viarg = row . getaslong ( "iarg" ) ; final string vsarg = row . getasstring ( "sarg" ) ; final long vbiarg = row . getaslong ( "biarg" ) ; final double vbnarg = row . getasdouble ( "bnarg" ) ; final double vdarg = row . getasdouble ( "darg" ) ; assertequals ( 7 , viarg ) ; assertequals ( "hi there" , vsarg ) ; assertequals ( 10 , vbiarg ) ; asserttrue ( math . abs ( 1.23 - vbnarg ) < 1.0e-10 ) ; asserttrue ( math . abs ( 1.7 - vdarg ) < 1.0e-10 ) ; ++ n ; } assertequals ( 1 , n ) ; stmt . close ( ) ; } catch ( exception e ) { ex = e ; } finally { dbhandle . conn . close ( ) ; rmdir ( dir ) ; } if ( null != ex ) { throw ex ; } }
te	6	public static string truncatewhenutf8 ( final string s , final int maxbytes ) { int b = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { final char c = s . charat ( i ) ; int skip = 0 ; int more ; if ( c <= 007f ) { more = 1 ; } else if ( c <= 07ff ) { more = 2 ; } else if ( c <= d7ff ) { more = 3 ; } else if ( c <= dfff ) { more = 4 ; skip = 1 ; } else { more = 3 ; } if ( b + more > maxbytes ) { return s . substring ( 0 , i ) ; } b += more ; i += skip ; } return s ; }
te	4	public boolean touches ( tile othertile ) { if ( match ( getarea ( ) . getmaxx ( ) , othertile . getarea ( ) . getminx ( ) ) || match ( getarea ( ) . getminx ( ) , othertile . getarea ( ) . getmaxx ( ) ) ) return checkoverlap ( getarea ( ) . getminy ( ) , getarea ( ) . getmaxy ( ) , othertile . getarea ( ) . getminy ( ) , othertile . getarea ( ) . getmaxy ( ) ) ; if ( match ( getarea ( ) . getmaxy ( ) , othertile . getarea ( ) . getminy ( ) ) || match ( getarea ( ) . getminy ( ) , othertile . getarea ( ) . getmaxy ( ) ) ) return checkoverlap ( getarea ( ) . getminx ( ) , getarea ( ) . getmaxx ( ) , othertile . getarea ( ) . getminx ( ) , othertile . getarea ( ) . getmaxx ( ) ) ; return false ; }
te	8	private void handlephysicalinteract ( playerinteractevent event ) { if ( event . iscancelled ( ) ) return ; location l = event . getclickedblock ( ) . getlocation ( ) ; l . sety ( l . gety ( ) - 2 ) ; if ( l . getblock ( ) . getstate ( ) instanceof sign ) { sign s = ( sign ) l . getblock ( ) . getstate ( ) ; string [ ] msg = s . getlines ( ) ; boolean oo = false ; string ms = "" ; for ( string m : msg ) { if ( ! m . isempty ( ) && m . substring ( 0 , 1 ) . equals ( "/" ) ) { bukkit . dispatchcommand ( event . getplayer ( ) , m . substring ( 1 ) ) ; } else { if ( oo ) { ms += m + " " ; } } if ( m . tolowercase ( ) . equals ( "[tell]" ) ) { oo = true ; } } if ( ! ms . isempty ( ) ) event . getplayer ( ) . sendmessage ( chatcolor . dark_aqua + chatcolor . translatealternatecolorcodes ( "&" . charat ( 0 ) , ms ) ) ; } }
te	5	public static void benchmark ( ) throws exception { int n = 10000 ; string [ ] methodstocompare = { "approxsort1" , "approxsort2" } ; int k = 10 ; int [ ] arr = new int [ 1000 ] ; for ( int i = 0 ; i < 1000 ; i ++ ) { arr [ i ] = ( int ) ( i * 1000 + math . floor ( math . random ( ) * 100 ) ) ; int offset = ( int ) ( math . floor ( math . random ( ) * 2 * k ) - k ) ; if ( i + offset > 0 && i + offset < arr . length ) { swap ( arr , i , i + offset ) ; } } for ( string methodname : methodstocompare ) { class clazz = class . forname ( "book.chapter.ten.problem10_06" ) ; method method = clazz . getdeclaredmethod ( methodname , int [ ] . class , int . class ) ; double totaltime = 0.0 ; for ( int i = 0 ; i < n ; i ++ ) { int [ ] arrclone = arr . clone ( ) ; long starttime = system . nanotime ( ) ; method . invoke ( null , arrclone , k ) ; long endtime = system . nanotime ( ) ; totaltime += ( endtime - starttime ) / 1000000000.0 ; } system . out . println ( "elapsed time for " + methodname + ": " + totaltime + " seconds" ) ; } }
te	4	public contact getcontact ( commandline cmd ) { contact contact = null ; if ( cmd . hasoption ( "email" ) || cmd . hasoption ( "facebook" ) || cmd . hasoption ( "phone" ) || cmd . hasoption ( "web" ) ) { contact = new contact ( ) ; contact . setemail ( cmd . getoptionvalue ( "email" ) ) ; contact . setfacebook ( cmd . getoptionvalue ( "facebook" ) ) ; contact . setphone ( cmd . getoptionvalue ( "phone" ) ) ; contact . setweburl ( cmd . getoptionvalue ( "web" ) ) ; } return contact ; }
te	8	public int [ ] [ ] maketilemap ( arraylist < gameentity > entities ) { int width = 1 ; int height = 1 ; startx = entities . get ( 0 ) . getstartx ( ) ; starty = entities . get ( 0 ) . getstarty ( ) ; int tilesize = globalsettings . tilesize ; for ( int i = 1 ; i < entities . size ( ) ; i ++ ) { int entx = entities . get ( i ) . getstartx ( ) ; int enty = entities . get ( i ) . getstarty ( ) ; if ( entx < startx ) { if ( ( startx - entx ) / tilesize == 0 ) system . out . println ( "zero added" ) ; width += ( ( startx - entx ) / tilesize ) ; startx = entx ; } if ( enty < starty ) { height += ( ( starty - enty ) / tilesize ) ; starty = enty ; } if ( entx > startx + width * tilesize ) { width += ( ( entx - ( startx + width * tilesize ) ) / tilesize ) ; } if ( enty > starty + height * tilesize ) { height += ( ( enty - ( starty + height * tilesize ) ) / tilesize ) ; } } height ++ ; width ++ ; int [ ] [ ] tilemap = new int [ height ] [ width ] ; system . out . println ( "width :: " + width + " height :: " + height ) ; for ( int i = 0 ; i < entities . size ( ) ; i ++ ) { boolean block = entities . get ( i ) . isblock ( ) ; if ( block ) { int xpos = ( entities . get ( i ) . getstartx ( ) - startx ) / tilesize ; int ypos = ( entities . get ( i ) . getstarty ( ) - starty ) / tilesize ; tilemap [ ypos ] [ xpos ] = 1 ; } } return tilemap ; }
te	4	public int solve ( int index , boolean [ ] config , boolean [ ] bestconfig , int bestprice ) { if ( index == weights . length ) { int price = priceofconfig ( config ) ; if ( price > bestprice ) { bestprice = price ; copyconfig ( config , bestconfig ) ; } return bestprice ; } else { config [ index ] = false ; int price1 = solve ( index + 1 , config , bestconfig , bestprice ) ; if ( price1 > bestprice ) { bestprice = price1 ; } config [ index ] = true ; int price2 = solve ( index + 1 , config , bestconfig , bestprice ) ; if ( price2 > bestprice ) { bestprice = price2 ; } return bestprice ; } }
te	7	private boolean isrowempty ( int rowindex ) { if ( rowindex < getrowcount ( ) - 1 ) { return ( ( participantlist . get ( rowindex ) . getfirstname ( ) == null || participantlist . get ( rowindex ) . getfirstname ( ) . trim ( ) . equals ( "" ) ) && ( participantlist . get ( rowindex ) . getlastname ( ) == null || participantlist . get ( rowindex ) . getlastname ( ) . trim ( ) . equals ( "" ) ) ) ; } else { return ( ( lastrow . getfirstname ( ) == null || lastrow . getfirstname ( ) . trim ( ) . equals ( "" ) ) && ( lastrow . getlastname ( ) == null || lastrow . getlastname ( ) . trim ( ) . equals ( "" ) ) ) ; } }
te	7	public long piece_can_reach ( int piece_index , int steps ) { long piece_bb = 1 << piece_index ; int piece_type = getpiecetype ( piece_bb ) ; int piece_colour = piece_type & 01 ; long friend_bb = colour_bb [ piece_colour ] & ~ piece_bb ; int trap_num = trap_number [ piece_index ] ; if ( trap_num != - 1 ) { if ( ( trap [ trap_num ] & friend_bb ) != 0 ) { if ( ( touch_trap [ trap_num ] & colour_bb [ piece_colour ] ) == piece_bb ) { friend_bb ^= trap [ trap_num ] ; } } } long unfrozen_sq_bb = ( touching_bb ( friend_bb ) | ( touching_bb ( colour_bb [ player ] ) & piece_bb ) | ~ touching_bb ( stronger_enemy_bb [ piece_type ] ) ) ; if ( ( unfrozen_sq_bb & piece_bb ) == 0 ) { return piece_bb ; } long bad_trap_bb = 0 ; for ( int i = 0 ; i < 4 ; i ++ ) { if ( ( touch_trap [ i ] & friend_bb ) == 0 ) { bad_trap_bb |= trap [ i ] ; } } long good_sq_bb = unfrozen_sq_bb & empty_bb & ~ bad_trap_bb ; long reached_bb = piece_bb ; for ( int i = 1 ; i < steps ; i ++ ) { reached_bb |= touching_bb ( reached_bb , piece_type ) & good_sq_bb ; } reached_bb |= touching_bb ( reached_bb , piece_type ) & empty_bb & ~ bad_trap_bb ; return reached_bb ; }
te	3	private string getreadmecontents ( ) { inputstream is = null ; is = loader . class . getresourceasstream ( "/info/usmans/quranproject/resources/infos/readme.md" ) ; if ( is == null ) { joptionpane . showmessagedialog ( this , "unable to acquire inputstream for reading readme file" , "null inputstream" , joptionpane . error_message ) ; return "" ; } java . util . scanner s = new java . util . scanner ( is ) ; s . usedelimiter ( "\\a" ) ; string data = s . hasnext ( ) ? s . next ( ) : "" ; try { s . close ( ) ; is . close ( ) ; } catch ( ioexception e ) { joptionpane . showmessagedialog ( this , "unable to close inputstream for readme file" , "error inputstream close" , joptionpane . error_message ) ; } return data ; }
te	1	@ test public void testbasicstubbing ( ) { final list mocklist = mock ( list . class ) ; mocklist . add ( "turkey" ) ; system . out . println ( "value at position 0 in mocked list: " + mocklist . get ( 0 ) ) ; when ( mocklist . get ( 0 ) ) . thenreturn ( "chicken" ) ; system . out . println ( "value after stubbing get(0) call: " + mocklist . get ( 0 ) ) ; when ( mocklist . get ( 4 ) ) . thenreturn ( "ostrich" ) ; for ( int i = 0 ; i <= 4 ; i ++ ) { system . out . println ( "list[" + i + "] = " + mocklist . get ( i ) ) ; } system . out . println ( "list has " + mocklist . size ( ) + " items." ) ; }
te	8	@ transactional public void allocateseats ( event event ) { if ( event . isseatallocated ( ) ) { return ; } list < eventregistration > allunallocatedforeignregistrations = participantdao . allunallocatedregistrations ( event , false , false ) ; list < eventregistration > allunallocatedindianregistrations = participantdao . allunallocatedregistrations ( event , false , true ) ; list < eventregistration > allunallocatedregistrations = new arraylist < eventregistration > ( ) ; allunallocatedregistrations . addall ( allunallocatedforeignregistrations ) ; allunallocatedregistrations . addall ( allunallocatedindianregistrations ) ; list < rowmeta > rowmetas = eventdao . getallemptyrowmetas ( event ) ; int regscount = 0 ; int regssize = allunallocatedregistrations . size ( ) ; for ( rowmeta rowmeta : rowmetas ) { if ( regscount >= regssize ) { break ; } int seatcounter = 0 ; boolean [ ] seatflags = markallocatedseats ( event , rowmeta ) ; boolean isrowfull = false ; for ( int i = 0 ; i < seatflags . length ; i ++ ) { if ( regscount >= regssize ) { break ; } seatcounter = seatcounter + 1 ; if ( ! seatflags [ i ] ) { eventregistration registration = allunallocatedregistrations . get ( regscount ) ; participantseat seat = createseat ( registration , rowmeta . getrowname ( ) , seatcounter ) ; participantdao . saveorupdate ( seat ) ; seatflags [ i ] = true ; regscount ++ ; } if ( seatflags . length == seatcounter ) { isrowfull = true ; } } if ( isrowfull ) { rowmeta . setrowfull ( true ) ; eventdao . saveorupdate ( rowmeta ) ; } } event . setseatallocated ( true ) ; eventdao . saveorupdate ( event ) ; }
te	1	@ test public void testchangethr ( ) { final int huge_thr = 100 ; this . sensorcomponent = new sensorcomponent ( id , this . transceiver , period , huge_thr ) ; this . sensorcomponent . setthreshold ( - huge_thr ) ; try { thread . sleep ( period / 2 * 3 ) ; } catch ( interruptedexception e ) { assert . fail ( ) ; e . printstacktrace ( ) ; } assert . assertequals ( 1 , this . transceiver . getcallcounter ( ) ) ; assert . assertequals ( packettype . alm , this . transceiver . getlastpacket ( ) . gettype ( ) ) ; }
te	5	public void addscorevalue ( int i ) { if ( this . currentturn . isclosed ( ) || playerfinished ( ) ) { host . requestnextplayerevent ( ) ; return ; } if ( this . getremainingscore ( ) - i < 0 ) { this . currentturn . busted ( ) ; this . host . bust ( this ) ; return ; } this . currentturn . addthrow ( i ) ; if ( playerfinished ( ) ) { this . host . fireplayerfinishedevent ( ) ; } if ( this . currentturn . hasremainingthrows ( ) ) { checkfinishingpossibility ( ) ; } else { this . host . turnended ( ) ; } this . host . provideremainingscore ( ) ; }
te	6	public void log ( level level , string str ) { if ( level . intvalue ( ) >= loglevel . intvalue ( ) ) { stringbuilder out = new stringbuilder ( ) ; out . append ( "[" + clazz . getname ( ) + "]" ) ; out . append ( "[" + level . getname ( ) + "]" ) ; time currenttime ; if ( simulator . getworld ( ) != null && simulator . getworld ( ) . getcurrenttime ( ) != null ) currenttime = simulator . getworld ( ) . getcurrenttime ( ) ; else currenttime = null ; out . append ( "[" + ( ( currenttime != null ) ? currenttime : "no time" ) + "]" ) ; out . append ( str ) ; if ( simulator . getgui ( ) != null ) { if ( level . intvalue ( ) > fine . intvalue ( ) ) { jtextarea text = simulator . getgui ( ) . getlogwindow ( ) . gettextarea ( ) ; text . append ( out . tostring ( ) + "\n" ) ; text . setcaretposition ( text . gettext ( ) . length ( ) ) ; } else { system . out . println ( out ) ; } } else { system . out . println ( out ) ; } } }
te	4	@ override protected void paintcomponent ( graphics g ) { graphics2d g2d = ( graphics2d ) g ; g2d . setrenderinghint ( renderinghints . key_antialiasing , renderinghints . value_antialias_on ) ; g2d . setrenderinghint ( renderinghints . key_text_antialiasing , renderinghints . value_text_antialias_on ) ; g2d . setrenderinghint ( renderinghints . key_interpolation , renderinghints . value_interpolation_bicubic ) ; g2d . setcolor ( color . black ) ; g2d . setstroke ( new basicstroke ( 2 ) ) ; for ( int i = 0 ; i <= world . size ; i ++ ) { line2d hline = new line2d . double ( 0 , i * grid_size , 600 , i * grid_size ) ; line2d vline = new line2d . double ( i * grid_size , 0 , i * grid_size , 600 ) ; g2d . draw ( hline ) ; g2d . draw ( vline ) ; } for ( point fuel : world . getavailablefuel ( ) ) { int x = fuel . x * grid_size + grid_size / 2 - fuelimage . getwidth ( ) / 2 ; int y = fuel . y * grid_size + grid_size / 2 - fuelimage . getheight ( ) / 2 ; g2d . drawimage ( fuelimage , x , y , null ) ; } for ( int i = 1 ; i <= 2 ; i ++ ) { robot rob ; if ( ( rob = world . getrobot ( i ) ) != null ) rob . draw ( g2d , gettimeratio ( ) ) ; } }
te	2	private void createwaves ( string [ ] classnames , int [ ] maxamounts ) { for ( int i = 0 ; i < classnames . length ; i ++ ) { try { class < wave > wave = ( class < wave > ) class . forname ( "pixelshooter.wave." + classnames [ i ] ) ; constructor < wave > c = wave . getconstructor ( androidgame . class , levelreader . class , int . class ) ; wave w = c . newinstance ( this . game , this , maxamounts [ i ] ) ; this . game . waves . add ( w ) ; } catch ( exception e ) { this . game . dbgprint ( e . tostring ( ) ) ; } } }
te	7	public arraylist < userprofile > fetchallprofiles ( ) throws sqlconnectionexception , sqlqueryexception { arraylist < userprofile > profiles = new arraylist < userprofile > ( ) ; statement st ; try { st = dbcon . createstatement ( ) ; } catch ( sqlexception e ) { if ( dbcon != null ) try { dbcon . close ( ) ; } catch ( sqlexception e2 ) { e2 . printstacktrace ( ) ; } throw new sqlconnectionexception ( e ) ; } finally { } resultset rs ; try { rs = st . executequery ( "select rowid  name from userprofile" ) ; } catch ( sqlexception e ) { throw new sqlqueryexception ( e ) ; } try { while ( rs . next ( ) ) { userprofile up = new userprofile ( rs . getint ( "rowid" ) , rs . getstring ( "name" ) ) ; profiles . add ( up ) ; } } catch ( sqlexception e ) { e . printstacktrace ( ) ; } try { st . close ( ) ; } catch ( sqlexception e ) { e . printstacktrace ( ) ; } return profiles ; }
te	0	@ override public string tostring ( ) { stringbuilder tmp = new stringbuilder ( ) ; tmp . append ( "estructura de la mesura:\n" ) ; tmp . append ( "idrule=" ) . append ( this . beanrule . getidrule ( ) ) . append ( "  descripcio=" ) . append ( this . beanrule . descripcio ) ; tmp . append ( "renderclass=" ) . append ( this . beanrule . getclassname ( ) ) ; tmp . append ( "mapa=" ) . append ( this . map . tostring ( ) ) . append ( "\n" ) ; tmp . append ( "fields=" ) . append ( this . beanrule . fields . tostring ( ) ) . append ( "\n" ) ; return tmp . tostring ( ) ; }
te	4	public void scheduledtask ( inspectoropentask task ) { list < state > allowedparents = new arraylist < > ( ) ; allowedparents . add ( state . scheduled_tasks_header ) ; allowedparents . add ( state . scheduled_task ) ; traverseup ( allowedparents ) ; if ( this . hierarchy . peek ( ) != state . scheduled_task ) this . hierarchy . push ( state . scheduled_task ) ; printstring ( new stringbuilder ( ) . append ( "<span style=color:" ) . append ( task . isasync ( ) ? "#3072aa;>" : "#000;>" ) . append ( " [" ) . append ( task . getpluginname ( ) ) . append ( "] (id: " ) . append ( task . getid ( ) ) . append ( ") " ) . append ( task . isasync ( ) ? "async" : "notasync" ) . append ( task . isrecurring ( ) ? "  repeating: " + task . getrecurringperiod ( ) + " ticks - " : " - " ) . append ( task . getclassname ( ) ) . append ( "</span>" ) . tostring ( ) ) ; }
te	8	private void runspikingproblem ( evolution evo ) { outputscreen . settext ( "" ) ; int populationsize = integer . parseint ( populationsizefield . gettext ( ) ) ; int generations = integer . parseint ( generationsfield . gettext ( ) ) ; spikingneuronproblem sn = ( spikingneuronproblem ) problem ; list < individual > individuals = problem . createpopulation ( populationsize ) ; try { long starttime = system . nanotime ( ) ; for ( int i = 0 ; i < generations ; i ++ ) { individuals = evo . rungeneration ( individuals ) ; individual best = individuals . get ( 0 ) ; for ( individual ind : individuals ) { if ( ind . age ( ) > 0 ) { if ( ind . fitness ( ) > best . fitness ( ) ) { best = ind ; } } } string formattedstring = outputscreen . gettext ( ) ; formattedstring += "generation " + ( i + 1 ) + ": " + best . tostring ( ) + "\n" ; outputscreen . settext ( formattedstring ) ; plot2dpanel plot = new plot2dpanel ( ) ; baselabel title = new baselabel ( "generation: " + ( i + 1 ) + "  " + problembox . getselecteditem ( ) . tostring ( ) + "  " + adultbox . getselecteditem ( ) . tostring ( ) + "  " + parentbox . getselecteditem ( ) . tostring ( ) + "  mutation: " + mutationratefield . gettext ( ) + "%  crossover: " + crossoverratefield . gettext ( ) + "%" , color . black , 0.5 , 1.1 ) ; plot . addplotable ( title ) ; plot . addlineplot ( "target" , color . red , sn . target ) ; spikingneuronphenotype snpheno = ( spikingneuronphenotype ) best . phenotype ( ) ; plot . addlineplot ( "best individual" , color . blue , snpheno . spiketrain ) ; plot . addlegend ( "south" ) ; graphpanel . add ( plot ) ; cardlayout card = ( cardlayout ) graphpanel . getlayout ( ) ; card . last ( graphpanel ) ; if ( i % 10 == 0 ) system . out . println ( ( double ) ( system . nanotime ( ) - starttime ) / 1000000000.0 ) ; } evo . drawbestfitnessplot ( ) ; string texlabel = "generations: " + generations + "\\\\" + "\n" + "population: " + populationsize + "\\\\" + "\n" + "adult selection: " + adultbox . getselecteditem ( ) . tostring ( ) ; if ( adultbox . getselecteditem ( ) . tostring ( ) . equals ( "overproduction" ) ) { texlabel += "( \\%)\\\\\n" ; } else texlabel += "\\\\\n" ; if ( adultbox . getselecteditem ( ) . tostring ( ) . equals ( "generational mixing" ) ) { texlabel += "( adult spots: )\n" ; } else texlabel += "\n" ; texlabel += "selection method: " + parentbox . getselecteditem ( ) . tostring ( ) + "\\\\" + "\n" + "mutation :" + mutationratefield . gettext ( ) + "\\%" + "\\\\" + "\n" + "crossover: " + crossoverratefield . gettext ( ) + "\\% \\\\" + "\n" ; system . out . println ( texlabel ) ; } catch ( exception e ) { system . out . println ( e . getmessage ( ) ) ; } }
te	0	private void drawrect ( graphics g , rectvertices v ) { g . drawline ( ( int ) v . getfirst ( ) . getx ( ) , ( int ) v . getfirst ( ) . gety ( ) , ( int ) v . getsecond ( ) . getx ( ) , ( int ) v . getsecond ( ) . gety ( ) ) ; g . drawline ( ( int ) v . getsecond ( ) . getx ( ) , ( int ) v . getsecond ( ) . gety ( ) , ( int ) v . getthird ( ) . getx ( ) , ( int ) v . getthird ( ) . gety ( ) ) ; g . drawline ( ( int ) v . getthird ( ) . getx ( ) , ( int ) v . getthird ( ) . gety ( ) , ( int ) v . getfourth ( ) . getx ( ) , ( int ) v . getfourth ( ) . gety ( ) ) ; g . drawline ( ( int ) v . getfourth ( ) . getx ( ) , ( int ) v . getfourth ( ) . gety ( ) , ( int ) v . getfirst ( ) . getx ( ) , ( int ) v . getfirst ( ) . gety ( ) ) ; }
te	3	@ override public elapsedtimeinterval ping ( jsonobject header , string hostip , int port , int timeout , int ntrials ) throws exception { for ( int i = 0 ; i < ntrials ; i ++ ) { try { elapsedtime . start ( "pingrpctotal" ) ; dorcpping ( header , hostip , port , timeout ) ; elapsedtime . stop ( "pingrpctotal" ) ; } catch ( sockettimeoutexception e ) { elapsedtime . abort ( "pingrpctotal" ) ; system . out . println ( "pingrpctotal timed out: " + e . getmessage ( ) ) ; } catch ( exception e ) { elapsedtime . abort ( "pingrpctotal" ) ; system . out . println ( "pingrpctotal exception: " + e . getmessage ( ) ) ; } } return elapsedtime . get ( "pingrpctotal" ) ; }
te	3	@ override public void paintcomponent ( graphics g ) { super . paintcomponent ( g ) ; g . drawimage ( backgroundimage , 0 , 0 , null ) ; g . drawimage ( st . getflag ( ) . gettexture ( ) , ( int ) gameobject . boxtoswingx ( ( st . getflag ( ) . getpos ( ) ) . x ) , ( int ) gameobject . boxtoswingy ( ( st . getflag ( ) . getpos ( ) ) . y ) , null ) ; if ( st . havelauncher ( ) != null ) g . drawimage ( st . havelauncher ( ) . gettexture ( ) , ( int ) gameobject . boxtoswingx ( ( st . havelauncher ( ) . getpos ( ) ) . x ) , ( int ) gameobject . boxtoswingy ( ( st . havelauncher ( ) . getpos ( ) ) . y ) , null ) ; graphics2d g2 = ( ( graphics2d ) g ) ; g2 . setrenderinghint ( renderinghints . key_antialiasing , renderinghints . value_antialias_on ) ; g2 . setrenderinghint ( renderinghints . key_rendering , renderinghints . value_render_quality ) ; for ( gameobject obj : st . getworldcontroller ( ) . getobjects ( ) ) { g2 . setpaint ( obj . getcolour ( ) ) ; g2 . fill ( obj . gshape ( ) ) ; } if ( shp != null ) { g2 . setpaint ( color . red ) ; g2 . fill ( shp ) ; } }
te	0	public void setflagsfalse ( ) { ltflag = false ; lbflag = false ; l1flag = false ; l2flag = false ; l3flag = false ; l4flag = false ; l5flag = false ; d1flag = false ; d2flag = false ; d3flag = false ; d4flag = false ; s1flag = false ; s2flag = false ; r1flag = false ; r2flag = false ; r3flag = false ; r4flag = false ; r5flag = false ; xflag = false ; yflag = false ; bflag = false ; aflag = false ; rtflag = false ; rbflag = false ; }
te	4	public static void main ( string [ ] args ) throws ioexception { if ( args . length >= 5 ) { file basefreqfile = new file ( args [ 0 ] ) ; file samplefreqdir = new file ( args [ 1 ] ) ; file sizefile = new file ( args [ 2 ] ) ; file outfile = new file ( args [ 3 ] ) ; double rate = double . parsedouble ( args [ 4 ] ) ; byte mode = greedy_sample ; if ( args . length >= 6 ) { string modestring = args [ 5 ] ; if ( modestring . equalsignorecase ( "random" ) ) { mode = random_sample ; } else if ( modestring . equalsignorecase ( "greedy" ) ) { mode = greedy_sample ; } } composesample composer = new composesample ( ) ; composer . dosample ( basefreqfile , samplefreqdir , sizefile , outfile , rate , mode ) ; } else { system . out . println ( "missing parameters ... " ) ; indexbuilder . printhelp ( ) ; } }
te	9	public static serverconnections getserverconnections ( propsutils props , boolean askforserverhost ) { string serverurl = props . getstring ( propsutils . serverhost ) ; string oldserverurl = serverurl ; while ( true ) { if ( askforserverhost ) { serverurl = joptionpane . showinputdialog ( "squeezeserverhost: " , serverurl ) ; if ( serverurl == null ) { return null ; } } askforserverhost = true ; slimserver slimserver = null ; try { system . out . println ( "trying to connect to " + serverurl ) ; if ( serverurl . indexof ( : ) > 0 ) { string [ ] bits = serverurl . split ( ":" ) ; if ( bits . length == 2 ) { slimserver = new slimserver ( bits [ 0 ] , integer . parseint ( bits [ 1 ] ) ) ; } else if ( bits . length == 3 ) { slimserver = new slimserver ( bits [ 0 ] , integer . parseint ( bits [ 1 ] ) , integer . parseint ( bits [ 2 ] ) ) ; } else { system . out . println ( "bad url? [" + serverurl + "]  expecting url:webport or url:cliport:webport" ) ; slimserver = new slimserver ( serverurl ) ; } } else { slimserver = new slimserver ( serverurl ) ; } coversource coversource = new slimcoversource ( slimserver , noteimage , new cachedonfilesystemcs ( ) ) ; if ( ! serverurl . equals ( oldserverurl ) ) { props . setstring ( propsutils . serverhost , serverurl ) ; props . save ( ) ; } return new serverconnections ( slimserver , coversource ) ; } catch ( slimconnectionexception e ) { joptionpane . showmessagedialog ( null , "failed to connect to [" + serverurl + "] with " + e ) ; } catch ( ioexception e ) { joptionpane . showmessagedialog ( null , "failed to get covers from [" + serverurl + "] with " + e ) ; } } }
te	6	public static void setmultimode ( placementmode mode , securitylevel securitylevel , string [ ] args , player player , playerstate state ) { if ( ! multi_mode . contains ( mode ) ) return ; if ( state . getmode ( ) == mode && state . getsecuritylevel ( ) == securitylevel ) { state . reset ( ) ; sendmessage ( player , chatcolor . green , "%s mode off" , mode . name ( ) ) ; } else { state . setmode ( mode ) ; state . setsecuritylevel ( securitylevel ) ; switch ( mode ) { case reinforcement : sendmessage ( player , chatcolor . green , "%s mode %s" , mode . name ( ) , securitylevel . name ( ) ) ; break ; case fortification : sendmessage ( player , chatcolor . green , "%s mode %s  %s" , mode . name ( ) , state . getreinforcementmaterial ( ) . getmaterial ( ) . name ( ) , securitylevel . name ( ) ) ; break ; case info : sendmessage ( player , chatcolor . green , "%s mode on" , mode . name ( ) ) ; break ; } state . checkresetmode ( ) ; } }
te	2	private void putsourcedata ( int esi , bytebuffer symboldata ) { final int t = fecparams . symbolsize ( ) ; final int bufpos = symboldata . position ( ) ; if ( receivedsourcesymbols . get ( esi ) ) { symboldata . position ( bufpos + t ) ; } else { if ( symboldata . hasarray ( ) ) { final byte [ ] arr = symboldata . array ( ) ; final int off = bufpos + symboldata . arrayoffset ( ) ; data . putbytes ( esi * t , arr , off , t ) ; symboldata . position ( bufpos + t ) ; } else { final byte [ ] arr = new byte [ t ] ; symboldata . get ( arr ) ; data . putbytes ( esi * t , arr ) ; } receivedsourcesymbols . set ( esi ) ; } }
te	8	public jpanel addnumberbuttons ( jtextfield dispfield ) { final jtextfield field = dispfield ; jpanel buttonpanel = new jpanel ( ) ; buttonpanel . setlayout ( new gridlayout ( 4 , 3 ) ) ; buttonpanel . setpreferredsize ( new dimension ( 500 , 320 ) ) ; buttonpanel . setmaximumsize ( new dimension ( 500 , 500 ) ) ; jbutton [ ] numbuttons = new jbutton [ 10 ] ; jbutton starbuttons = new jbutton ( "*" ) ; starbuttons . setfont ( numbuttonsfont ) ; starbuttons . setpreferredsize ( new dimension ( 100 , 75 ) ) ; starbuttons . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent ev ) { if ( field . gettext ( ) . length ( ) < maxchars ) field . settext ( field . gettext ( ) + "*" ) ; if ( ! mainframe . redirectpanel . isvisible ( ) ) callbutton . setenabled ( true ) ; } } ) ; jbutton latticebuttons = new jbutton ( "#" ) ; latticebuttons . setfont ( numbuttonsfont ) ; latticebuttons . setpreferredsize ( new dimension ( 100 , 75 ) ) ; latticebuttons . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent ev ) { if ( field . gettext ( ) . length ( ) < maxchars ) field . settext ( field . gettext ( ) + "#" ) ; if ( ! mainframe . redirectpanel . isvisible ( ) ) callbutton . setenabled ( true ) ; } } ) ; for ( int i = 0 ; i < 10 ; i ++ ) { final string name = "" + i ; numbuttons [ i ] = new jbutton ( "" + i ) ; numbuttons [ i ] . setfont ( numbuttonsfont ) ; numbuttons [ i ] . setpreferredsize ( new dimension ( 100 , 75 ) ) ; numbuttons [ i ] . addactionlistener ( new actionlistener ( ) { public void actionperformed ( actionevent ev ) { if ( field . gettext ( ) . length ( ) < maxchars ) field . settext ( field . gettext ( ) + name ) ; if ( ! mainframe . redirectpanel . isvisible ( ) ) callbutton . setenabled ( true ) ; } } ) ; } for ( int i = 1 ; i <= 9 ; i ++ ) { buttonpanel . add ( numbuttons [ i ] ) ; } buttonpanel . add ( starbuttons ) ; buttonpanel . add ( numbuttons [ 0 ] ) ; buttonpanel . add ( latticebuttons ) ; return buttonpanel ; }
te	0	public void testsimplebuild ( ) throws ioexception , xmlpullparserexception { dom2xmlpullbuilder builder = new dom2xmlpullbuilder ( ) ; final string xml = "<n:foo xmlns:n='uri1'><bar n:attr='test' xmlns='uri2'>baz</bar></n:foo>" ; stringreader reader = new stringreader ( xml ) ; element el1 = builder . parse ( reader ) ; stringwriter sw = new stringwriter ( ) ; reader = new stringreader ( xml ) ; element el2 = builder . parse ( reader ) ; element root = el2 ; assertequals ( "uri1" , root . getnamespaceuri ( ) ) ; assertequals ( "foo" , root . getlocalname ( ) ) ; nodelist children = root . getelementsbytagnamens ( "*" , "bar" ) ; element | = ( element ) children . item ( 0 ) ; assertequals ( "uri2" , | . getnamespaceuri ( ) ) ; assertequals ( "bar" , | . getlocalname ( ) ) ; string attrvalue = | . getattributens ( "uri1" , "attr" ) ; assertequals ( "test" , attrvalue ) ; attr attr = | . getattributenodens ( "uri1" , "attr" ) ; assertnotnull ( attr ) ; assertequals ( "uri1" , attr . getnamespaceuri ( ) ) ; assertequals ( "attr" , attr . getlocalname ( ) ) ; assertequals ( "test" , attr . getvalue ( ) ) ; text text = ( text ) | . getfirstchild ( ) ; assertequals ( "baz" , text . getnodevalue ( ) ) ; }
te	1	private void btnaceptaractionperformed ( java . awt . event . actionevent evt ) { try { interfazschcg rp = ( interfazschcg ) registry . lookup ( "conex" ) ; string host = txthostdb . gettext ( ) ; string dbms = txtdbms . gettext ( ) ; string usuario = txtuserbd . gettext ( ) ; string based = txtnombrebd . gettext ( ) ; string pasw = txtpassbd . gettext ( ) ; rp . conectar ( host , based , usuario , pasw , dbms ) ; frmprincipal schc = new frmprincipal ( registry ) ; dispose ( ) ; schc . setvisible ( true ) ; } catch ( exception ex ) { ex . printstacktrace ( ) ; } }
te	2	@ override public void consultar ( ) throws sqlexception { try { conexion . getinstancia ( ) . conectar ( ) ; resultset rs = conexion . getinstancia ( ) . ejecutarconsulta ( "" ) ; while ( rs . next ( ) ) { obproducto . setnom_producto ( rs . getstring ( "" ) ) ; obproducto . setdes_producto ( rs . getstring ( "" ) ) ; obproducto . setest_producto ( rs . getstring ( "" ) ) ; obproducto . setstock_producto ( rs . getstring ( "" ) ) ; obproducto . setpvp_producto ( rs . getdouble ( "" ) ) ; obproducto . setmar_producto ( rs . getstring ( "" ) ) ; obproducto . settam_producto ( rs . getstring ( "" ) ) ; } } catch ( sqlexception ex ) { throw ex ; } finally { conexion . getinstancia ( ) . desconectar ( ) ; } }
te	6	@ override public aatilegenerator getaatilegenerator ( shape s , affinetransform at , region clip , basicstroke bs , boolean thin , boolean normalize , int [ ] bbox ) { marlintilegenerator ptg = null ; renderer r = null ; final renderercontext rdrctx = getrenderercontext ( ) ; try { final affinetransform _at = ( at != null && ! at . isidentity ( ) ) ? at : null ; final normmode norm = ( normalize ) ? normmode . on_with_aa : normmode . off ; if ( bs == null ) { final pathiterator pi = getnormalizingpathiterator ( rdrctx , norm , s . getpathiterator ( _at ) ) ; r = rdrctx . renderer . init ( clip . getlox ( ) , clip . getloy ( ) , clip . getwidth ( ) , clip . getheight ( ) , pi . getwindingrule ( ) ) ; pathto ( rdrctx , pi , r ) ; } else { r = rdrctx . renderer . init ( clip . getlox ( ) , clip . getloy ( ) , clip . getwidth ( ) , clip . getheight ( ) , pathiterator . wind_non_zero ) ; stroketo ( rdrctx , s , _at , bs , thin , norm , true , r ) ; } if ( r . endrendering ( ) ) { ptg = rdrctx . ptg . init ( ) ; ptg . getbbox ( bbox ) ; r = null ; } } finally { if ( r != null ) { r . dispose ( ) ; marlinrenderingengine . returnrenderercontext ( rdrctx ) ; } } return ptg ; }
te	7	private boolean fulfills ( car car , step3userrequest userrequest3 ) { if ( userrequest3 . getminyearofproduction ( ) != null && car . getyearofproduction ( ) < userrequest3 . getminyearofproduction ( ) ) return false ; if ( userrequest3 . getmaxyearofproduction ( ) != null && car . getyearofproduction ( ) > userrequest3 . getmaxyearofproduction ( ) ) return false ; if ( userrequest3 . getfeatures ( ) != null ) { for ( carfeature feature : userrequest3 . getfeatures ( ) ) { if ( ! car . getfeatures ( ) . contains ( feature ) ) return false ; } } return true ; }
te	3	private void arrangeoptions ( collection < string > unarranged ) { if ( unarranged . size ( ) == 1 ) { options . addall ( unarranged ) ; return ; } list < string > shortoptions = new arraylist < string > ( ) ; list < string > longoptions = new arraylist < string > ( ) ; for ( string each : unarranged ) { if ( each . length ( ) == 1 ) shortoptions . add ( each ) ; else longoptions . add ( each ) ; } sort ( shortoptions ) ; sort ( longoptions ) ; options . addall ( shortoptions ) ; options . addall ( longoptions ) ; }
te	2	public client ( inetaddress address , sharedtorrent torrent , boolean force , boolean disable ) throws unknownhostexception , ioexception { this . torrent = torrent ; this . state = clientstate . waiting ; this . disableobfuscation = disable ; if ( this . disableobfuscation ) { this . forceobfuscation = false ; this . id = ( client . bittorrent_id_prefix + uuid . randomuuid ( ) . tostring ( ) . split ( "-" ) [ 4 ] ) . getbytes ( ) ; while ( peer . ismagicpeerid ( this . id ) ) { this . id = ( client . bittorrent_id_prefix + uuid . randomuuid ( ) . tostring ( ) . split ( "-" ) [ 4 ] ) . getbytes ( ) ; } } else { this . forceobfuscation = force ; this . id = peer . generatemagicpeerid ( ) ; } this . hexid = torrent . bytearraytohexstring ( this . id ) ; this . service = new connectionhandler ( this . torrent , this . id , address , this . forceobfuscation ) ; this . service . register ( this ) ; this . address = this . service . getsocketaddress ( ) ; this . announce = new announce ( this . torrent , this . id , this . address ) ; this . announce . register ( this ) ; logger . info ( "bittorrent client [" + this . hexid + " / " + peer . ismagicpeerid ( this . id ) + "] for " + this . torrent . getname ( ) + " started and " + "listening at " + this . address . getaddress ( ) . gethostaddress ( ) + ":" + this . address . getport ( ) + "..." ) ; this . peers = new concurrenthashmap < string , sharingpeer > ( ) ; this . connected = new concurrenthashmap < string , sharingpeer > ( ) ; this . random = new random ( system . currenttimemillis ( ) ) ; }
te	9	public void run ( ) { long now = 0 , prev = 0 , dt = 0 ; for ( ; ; ) { for ( integer integer : todelete ) { for ( system system : systems ) { system . removeentity ( integer ) ; } } todelete . clear ( ) ; prev = java . lang . system . currenttimemillis ( ) ; for ( system logicsystem : logicsystems ) { logicsystem . update ( dt ) ; } for ( system prerendersystem : prerendersystems ) { prerendersystem . update ( dt ) ; } for ( system rendersystem : rendersystems ) { rendersystem . update ( dt ) ; } for ( system postrendersystem : postrendersystems ) { postrendersystem . update ( dt ) ; } now = java . lang . system . currenttimemillis ( ) ; java . lang . system . out . printf ( "loop time: %d ms \r" , java . lang . system . currenttimemillis ( ) - prev ) ; try { if ( frametime - ( now - prev ) > 0 ) thread . sleep ( frametime - ( now - prev ) ) ; } catch ( interruptedexception e ) { e . printstacktrace ( ) ; } dt = now - prev ; } }
te	8	public policy getpolicy ( commandline cmd ) { policy policy = null ; if ( cmd . hasoption ( "checkin" ) || cmd . hasoption ( "checkout" ) || cmd . hasoption ( "alchohol" ) || cmd . hasoption ( "smoke" ) || cmd . hasoption ( "cancellation_deadline" ) || cmd . hasoption ( "cancellation_penalty" ) ) { policy = new policy ( ) ; policy . setcheckintime ( cmd . getoptionvalue ( "checkin" ) ) ; policy . setcheckouttime ( cmd . getoptionvalue ( "checkout" ) ) ; policy . setalcoholpolicy ( cmd . getoptionvalue ( "alchohol" ) ) ; policy . setsmokingpolicy ( cmd . getoptionvalue ( "smoke" ) ) ; if ( cmd . hasoption ( "cancellation_deadline" ) ) { policy . setcancellationdeadline ( integer . parseint ( cmd . getoptionvalue ( "cancellation_deadline" ) ) ) ; } if ( cmd . hasoption ( "cancellation_penalty" ) ) { policy . setcancellationpenalty ( integer . parseint ( cmd . getoptionvalue ( "cancellation_penalty" ) ) ) ; } } return policy ; }
te	7	public synchronized void nextgeneration ( ) { generation ++ ; arrays . fill ( tmp , 0 ) ; for ( int x = 0 ; x < maxx ; ++ x ) { int xminor = ( x + maxx - 1 ) % maxx ; int xmajor = ( x + 1 ) % maxx ; for ( int y = 0 ; y < maxy ; ++ y ) { int yminor = ( y + maxy - 1 ) % maxy ; int ymajor = ( y + 1 ) % maxy ; int here = maxx * y + x ; int neighbors = f ( grid [ maxx * yminor + xminor ] ) + f ( grid [ maxx * yminor + x ] ) + f ( grid [ maxx * yminor + xmajor ] ) + f ( grid [ maxx * y + xminor ] ) + f ( grid [ maxx * y + xmajor ] ) + f ( grid [ maxx * ymajor + xminor ] ) + f ( grid [ maxx * ymajor + x ] ) + f ( grid [ maxx * ymajor + xmajor ] ) ; if ( grid [ here ] > 0 ) { if ( neighbors < 2 ) { tmp [ here ] = 0 ; } else if ( neighbors == 2 || neighbors == 3 ) { tmp [ here ] = grid [ here ] + 1 ; } else { tmp [ here ] = 0 ; } } else { if ( neighbors == 3 ) { tmp [ here ] = 1 ; } } } } int [ ] t = grid ; grid = tmp ; tmp = t ; }
te	0	@ test public void addingredienttest ( ) throws datastoreexception { list < ingredient > ingredients = helper . retrieveallingredients ( ) ; int oldsize = ingredients . size ( ) ; ingredient ingredient = new ingredient ( "kommen" , "kommen" , false ) ; asserttrue ( "addingredient should succeed and return true" , helper . addingredient ( ingredient ) ) ; assertfalse ( "the new ingredient is not already in the list" , ingredients . contains ( ingredient ) ) ; ingredients = helper . retrieveallingredients ( ) ; assertequals ( "size should increase when new ingredient is added" , oldsize + 1 , ingredients . size ( ) ) ; asserttrue ( "the new ingredient should now be in the list" , ingredients . contains ( ingredient ) ) ; resetdatabase ( ) ; }
te	1	public static void main ( string [ ] args ) { string surname ; string firstname ; scanner scan = new scanner ( system . in ) ; system . out . println ( "surname:" ) ; surname = scan . nextline ( ) ; system . out . println ( "firstname:" ) ; firstname = scan . nextline ( ) ; system . out . println ( "date of birth:(dd-mm-yyyy)" ) ; string datestring = scan . nextline ( ) ; int day = 1 ; int month = 1 ; int year = 1900 ; try { scanner datescan = new scanner ( datestring ) ; datescan . usedelimiter ( "-" ) ; day = datescan . nextint ( ) ; month = datescan . nextint ( ) ; year = datescan . nextint ( ) ; } catch ( exception e ) { system . out . println ( "input error!" ) ; } system . out . printf ( "%s %s was born on %d %d %d" , surname , firstname , day , month , year ) ; }
te	1	public static void main ( string [ ] args ) throws filenotfoundexception { system . seterr ( new printstream ( new file ( "out.txt" ) ) ) ; try { inference inference = new fmeasuremaximizerinference ( 100 , 0 ) ; pcc learner = new pcc ( inference ) ; tunedexperiment e = new tunedexperiment ( learner , 5 , 5 , 0 ) ; e . setmultithreading ( false ) ; experimentresults res = e . evaluation ( ) ; system . out . println ( res . tostring ( ) ) ; } catch ( exception ex ) { ex . printstacktrace ( ) ; } }
te	7	private void clear ( ) { if ( zookeeper != null ) { if ( leaderoffer != null && zookeeper . getstate ( ) . isalive ( ) ) { try { zookeeper . delete ( leaderoffer . getoffer ( ) , - 1 ) ; log . debug ( "removed leader candidate {}" , leaderoffer ) ; } catch ( interruptedexception e ) { failed ( e ) ; } catch ( keeperexception e ) { failed ( e ) ; } if ( leaderelectionaware != null ) { leaderelectionaware . onclosed ( leaderoffer ) ; } leaderoffer = null ; } try { zookeeper . close ( ) ; } catch ( interruptedexception e ) { failed ( e ) ; } finally { zookeeper = null ; } } }
te	9	public boolean verifysquenceofbst ( int [ ] squence , int start , int end ) { if ( squence == null || end < start ) { throw new nullpointerexception ( "input is null." ) ; } int root = squence [ end ] ; int i = start ; for ( ; i < end ; i ++ ) { if ( squence [ i ] > root ) { break ; } } int j = i ; for ( ; j < end ; j ++ ) { if ( squence [ j ] < root ) return false ; } boolean left = true ; if ( i > start ) { left = verifysquenceofbst ( squence , start , i - 1 ) ; } boolean right = true ; if ( i < end - 1 ) { right = verifysquenceofbst ( squence , i , end - 1 ) ; } return ( left && right ) ; }
te	2	@ override public void mousedragged ( int oldx , int oldy , int newx , int newy ) { mousepos . x = newx ; mousepos . y = newy ; switch ( interactionstate ) { case scrolling : double dx = - transformlengthback ( scrollmousestart . x - newx ) ; double dy = - transformlengthback ( scrollmousestart . y - newy ) ; renderoffset . x = scrolloffsetstart . x + dx ; renderoffset . y = scrolloffsetstart . y + dy ; correctrenderoffset ( ) ; break ; case normal : searchselectedtower ( newx , newy ) ; break ; } }
te	0	@ test public void testestadisp ( ) { reserva r = new reserva ( dini , dfi , preureserva , dniclient , nomhotel , numerohabitacio ) ; habproves . afreserva ( r ) ; boolean result = habproves . estadisp ( dini , dfi ) ; assertfalse ( result ) ; calendar ini = calendar . getinstance ( ) ; calendar fi = calendar . getinstance ( ) ; ini . set ( 2012 , 1 , 17 ) ; fi . set ( 2012 , 1 , 24 ) ; result = habproves . estadisp ( ini . gettime ( ) , fi . gettime ( ) ) ; asserttrue ( result ) ; }
te	3	public calendarmodel add ( meetingmodel meeting ) { if ( meetings . contains ( meeting ) ) return this ; meetings . add ( meeting ) ; if ( ! meetingsfrom . containskey ( meeting . gettimefrom ( ) ) ) meetingsfrom . put ( meeting . gettimefrom ( ) , new hashset < meetingmodel > ( ) ) ; if ( ! meetingsto . containskey ( meeting . gettimeto ( ) ) ) meetingsto . put ( meeting . gettimeto ( ) , new hashset < meetingmodel > ( ) ) ; meetingsfrom . get ( meeting . gettimefrom ( ) ) . add ( meeting ) ; meetingsto . get ( meeting . gettimeto ( ) ) . add ( meeting ) ; meeting . addpropertychangelistener ( this ) ; pcs . firepropertychange ( meeting_added , null , meeting ) ; return this ; }
te	0	protected void paintcomponent ( graphics g ) { graphics2d g2d = ( graphics2d ) g ; g2d . setrenderinghint ( renderinghints . key_antialiasing , renderinghints . value_antialias_on ) ; int largeur = getwidth ( ) ; int hauteur = getheight ( ) ; int b_hauteur = hauteur - ( inset * 2 ) ; int b_largeur = largeur - ( inset * 2 ) ; int varcsize = b_hauteur ; g2d . setrenderinghint ( renderinghints . key_antialiasing , renderinghints . value_antialias_on ) ; color vgradientstartcolor = buttoncolor . darker ( ) . darker ( ) . darker ( ) ; color vgradientendcolor = buttoncolor . brighter ( ) . brighter ( ) . brighter ( ) ; paint paint = new gradientpaint ( 0 , inset , vgradientstartcolor , 0 , b_hauteur , vgradientendcolor , false ) ; g2d . setpaint ( paint ) ; g2d . fillroundrect ( inset , inset , b_largeur , b_hauteur , varcsize , varcsize ) ; int vhighlightinset = 2 ; int vbuttonhighlightheight = b_hauteur - ( vhighlightinset * 2 ) ; int vbuttonhighlightwidth = b_largeur - ( vhighlightinset * 2 ) ; int vhighlightarcsize = vbuttonhighlightheight ; vgradientstartcolor = color . white ; vgradientendcolor = buttoncolor . brighter ( ) ; paint = new gradientpaint ( 0 , inset + vhighlightinset , vgradientstartcolor , 0 , inset + vhighlightinset + ( vbuttonhighlightheight / 2 ) , buttoncolor . brighter ( ) , false ) ; g2d . setcomposite ( alphacomposite . getinstance ( alphacomposite . src_over , .8f ) ) ; g2d . setpaint ( paint ) ; g2d . fillroundrect ( inset + vhighlightinset , inset + vhighlightinset , vbuttonhighlightwidth , vbuttonhighlightheight , vhighlightarcsize , vhighlightarcsize ) ; roundrectangle2d . float r2d = new roundrectangle2d . float ( inset , inset , b_largeur , b_hauteur , varcsize , varcsize ) ; g2d . clip ( r2d ) ; g2d . setcomposite ( alphacomposite . getinstance ( alphacomposite . src_over , 1.0f ) ) ; super . paintcomponent ( g ) ; g2d . setrenderinghint ( renderinghints . key_antialiasing , renderinghints . value_antialias_off ) ; }
te	0	@ override public set < collector > getcollectors ( ) { collectors = new hashset < collector > ( ) ; boolean [ ] [ ] gameboard = getvalidboard ( 1 ) ; list < tuple < integer , integer >> q = leastencumbered ( new int [ 100 ] [ 100 ] ) ; tuple < integer , integer > firstchoice = q . get ( 0 ) ; int count = 0 ; firstchoice = getpointnotonwall ( firstchoice ) ; collector c = new collector ( firstchoice . x , firstchoice . y ) ; log . trace ( "placed a collector at " + c . getx ( ) + " " + c . gety ( ) ) ; collectors . add ( c ) ; return collectors ; }
te	5	public jsonrpcresponseobject sendandreceive ( jsonrpcrequestobject message ) throws saploclientexception { restclient client = new restclient ( ) ; if ( clientproxy != null ) { clientconfig config = new clientconfig ( ) ; config . proxyhost ( clientproxy . gethost ( ) ) ; config . proxyport ( clientproxy . getport ( ) ) ; if ( clientproxy . issecure ( ) ) { } client = new restclient ( config ) ; } resource resource = client . resource ( uri + "?" + params ) ; clientresponse response = resource . post ( message . tostring ( ) ) ; string responsestring = response . getentity ( string . class ) ; int statuscode = response . getstatuscode ( ) ; if ( statuscode != httpstatus . sc_ok ) throw new saploclientexception ( responsecodes . msg_api_down_exception , responsecodes . code_api_down_exception , statuscode ) ; jsontokener tokener = new jsontokener ( responsestring ) ; object rawresponsemessage ; try { rawresponsemessage = tokener . nextvalue ( ) ; } catch ( jsonexception e ) { throw new saploclientexception ( responsecodes . msg_malformed_response , responsecodes . code_malformed_response ) ; } jsonobject responsemessage = ( jsonobject ) rawresponsemessage ; if ( responsemessage == null ) throw new clienterror ( "invalid response type - " + rawresponsemessage ) ; return new jsonrpcresponseobject ( responsemessage ) ; }
te	7	private void reflectclasswrapper ( map < type , set < genetrait >> genepool , string classname , int parametercount , list < string > parametertypes , int parametersset ) throws classnotfoundexception { if ( parametersset < parametercount ) { for ( breedingclasssetup classsetup : settings . getsettings ( ) . getclasses ( ) ) { if ( ! rawtypesclassmap . containskey ( classsetup . classname ) ) { if ( parametertypes . size ( ) >= parametersset + 1 ) { parametertypes . remove ( parametersset ) ; } parametertypes . add ( parametersset , classsetup . classname ) ; reflectclasswrapper ( genepool , classname , parametercount , parametertypes , parametersset + 1 ) ; } } } else { class < ? > clazz = rawtypesclassmap . get ( classname ) ; if ( clazz == null ) { clazz = class . forname ( classname ) ; } type classtype = type . gettype ( classname + ( ( parametercount == 0 ) ? "" : ( "<" + tools . implode ( parametertypes , " " ) + ">" ) ) ) ; reflectclass ( genepool , clazz , classname , classtype , parametertypes ) ; } }
te	1	packagewatcher ( objectmanager objectmgr , string packagename ) throws ioexception { this . objectmgr = objectmgr ; this . packagename = packagename ; filesystem filesystem = filesystems . getdefault ( ) ; path packagepath = filesystem . getpath ( "out" ) . resolve ( packagename . replace ( . , / ) ) ; for ( path filepath : files . newdirectorystream ( packagepath ) ) { registercommand ( filepath . getfilename ( ) ) ; } watchservice = filesystem . newwatchservice ( ) ; packagepath . register ( watchservice , standardwatcheventkinds . entry_create , standardwatcheventkinds . entry_delete ) ; }
te	6	@ test public void testconstructor ( ) { string nulltag = null ; object nullval = null ; datafield field = new datafield ( "" ) ; field . getvalue ( ) ; field = new datafield ( nullval ) ; field = new datafield ( new long ( 0 ) ) ; field = new datafield ( new string ( ) , new string ( ) ) ; new datafield ( nulltag , nullval ) ; field = new datafield ( 0 ) ; field = new datafield ( new string ( ) , 0 ) ; field = new datafield ( nulltag , 0 ) ; field = new datafield ( 0 ) ; field = new datafield ( new string ( ) , 0 ) ; field = new datafield ( nulltag , 0 ) ; field = new datafield ( ( short ) 0 ) ; field = new datafield ( new string ( ) , ( short ) 0 ) ; field = new datafield ( nulltag , ( short ) 0 ) ; field = new datafield ( new byte [ 0 ] ) ; field = new datafield ( new string ( ) , new byte [ 0 ] ) ; field = new datafield ( nulltag , new byte [ 0 ] ) ; field = new datafield ( ( byte [ ] ) null ) ; field = new datafield ( nulltag , ( byte [ ] ) null ) ; field = new datafield ( 0f ) ; field = new datafield ( new string ( ) , 0f ) ; field = new datafield ( nulltag , 0f ) ; field = new datafield ( 0d ) ; field = new datafield ( new string ( ) , 0d ) ; field = new datafield ( nulltag , 0d ) ; field = new datafield ( true ) ; field = new datafield ( new string ( ) , true ) ; field = new datafield ( nulltag , true ) ; field = new datafield ( new date ( ) ) ; field = new datafield ( new string ( ) , new date ( ) ) ; field = new datafield ( null , new date ( ) ) ; try { field = new datafield ( new uri ( "" ) ) ; } catch ( illegalargumentexception e ) { fail ( e . getmessage ( ) ) ; } catch ( urisyntaxexception e ) { fail ( e . getmessage ( ) ) ; } try { field = new datafield ( new string ( ) , new uri ( "" ) ) ; } catch ( illegalargumentexception e ) { fail ( e . getmessage ( ) ) ; } catch ( urisyntaxexception e ) { fail ( e . getmessage ( ) ) ; } try { field = new datafield ( nulltag , new uri ( "" ) ) ; } catch ( illegalargumentexception e ) { fail ( e . getmessage ( ) ) ; } catch ( urisyntaxexception e ) { fail ( e . getmessage ( ) ) ; } }
te	5	public static list < lineitem > transformlineitems ( detail d ) { list < lineitem > items = d . getlineitem ( ) ; list < lineitem > aggritems = new arraylist < lineitem > ( ) ; for ( lineitem l : items ) { boolean duplicate = false ; if ( ! aggritems . isempty ( ) ) { for ( int i = 0 ; i < aggritems . size ( ) ; i ++ ) { lineitem curr = aggritems . get ( i ) ; if ( curr . getitemcode ( ) . equals ( l . getitemcode ( ) ) ) { long quantity = curr . getquantity ( ) . intvalue ( ) ; quantity ++ ; curr . setquantity ( bigdecimal . valueof ( quantity ) ) ; duplicate = true ; break ; } } } if ( ! duplicate ) { aggritems . add ( l ) ; } } return aggritems ; }
te	0	private imageviewercontrolfactory createimagecontrolfactory ( ) { return new imageviewercontrolfactory ( ) { @ override public imageviewercontrol createimageviewercontrol ( imageviewer viewer , imageset set ) { return new imageviewercontrol ( imageviewer , set , createhashmap ( ) ) ; } private hashmap < string , imagepriority > createhashmap ( ) { final hashmap < string , imagepriority > priority = new hashmap < > ( ) ; priority . put ( "winnericon.jpg" , imagepriority . high ) ; priority . put ( "losericon.jpg" , imagepriority . high ) ; priority . put ( "waiticon.jpg" , imagepriority . low ) ; priority . put ( "moveicon.jpg" , imagepriority . low ) ; return priority ; } } ; }
te	5	public void addnodes ( arraylist < buslabel > buseslabel , arraylist < stationlabel > stationslabel , arraylist < semaphorelabel > semaphoreslabel , int num ) { int iconheightmid = 0 ; int iconwidthmid = 0 ; int iconheight = 0 ; int iconwidth = 0 ; if ( num == 1 ) { removeall ( ) ; } for ( buslabel buslabel : buseslabel ) { iconheight = buslabel . geticon ( ) . geticonheight ( ) ; iconwidth = buslabel . geticon ( ) . geticonwidth ( ) ; iconheightmid = iconheight / 2 ; iconwidthmid = iconwidth / 2 ; buslabel . setbounds ( buslabel . getx ( ) - iconwidthmid , buses_heigth - iconheightmid , iconwidth , iconheight ) ; add ( buslabel ) ; } for ( semaphorelabel semaphorelabel : semaphoreslabel ) { iconheight = semaphorelabel . geticon ( ) . geticonheight ( ) ; iconwidth = semaphorelabel . geticon ( ) . geticonwidth ( ) ; iconheightmid = iconheight / 2 ; iconwidthmid = iconwidth / 2 ; if ( semaphorelabel . getbounds ( ) . y > 100 ) { system . out . println ( semaphorelabel . getsemaphore ( ) . getid ( ) ) ; } semaphorelabel . setbounds ( semaphorelabel . getx ( ) - iconwidthmid , semaphores_heigth - iconheightmid , iconwidth , iconheight ) ; add ( semaphorelabel ) ; } for ( stationlabel stationlabel : stationslabel ) { iconheight = stationlabel . geticon ( ) . geticonheight ( ) ; iconwidth = stationlabel . geticon ( ) . geticonwidth ( ) ; iconheightmid = iconheight / 2 ; iconwidthmid = iconwidth / 2 ; stationlabel . setbounds ( stationlabel . getx ( ) - iconwidthmid , stations_heigth - iconheightmid , iconwidth , iconheight ) ; add ( stationlabel ) ; } repaint ( ) ; }
te	7	private void searchuser ( actionevent e ) { string username = this . username . gettext ( ) ; string userno = this . userno . gettext ( ) ; if ( username == null || constants . str_null . equals ( username . trim ( ) ) ) { username = constants . str_null ; } if ( userno == null || constants . str_null . equals ( userno . trim ( ) ) ) { userno = constants . str_null ; } map < string , object > param = new hashmap < string , object > ( ) ; param . put ( constants . in_username , username ) ; param . put ( constants . in_userno , userno ) ; system . out . println ( param ) ; list < map < string , object >> list = null ; try { list = userdao . searchuser ( param ) ; } finally { if ( null == list || constants . num_zero == list . size ( ) ) { return ; } else { int size = list . size ( ) ; data = new string [ size ] [ 2 ] ; int i = 0 ; for ( map < string , object > item : list ) { data [ i ] [ 0 ] = item . get ( constants . user_no ) ; data [ i ] [ 1 ] = item . get ( constants . user_name ) ; i ++ ; } refreshtable ( ) ; } } }
te	3	private generictree < layoutparsertreeelement > parsexml ( string layoutxml ) { generictree < layoutparsertreeelement > newtree = new generictree < layoutparsertreeelement > ( ) ; document result = null ; documentbuilderfactory factory = documentbuilderfactory . newinstance ( ) ; inputsource source = new inputsource ( new stringreader ( layoutxml ) ) ; try { result = factory . newdocumentbuilder ( ) . parse ( source ) ; } catch ( saxexception e ) { errormessage . show ( "eroare sax" , false ) ; e . printstacktrace ( ) ; } catch ( ioexception e ) { errormessage . show ( "eroare ioexception" , false ) ; e . printstacktrace ( ) ; } catch ( parserconfigurationexception e ) { errormessage . show ( "eroare parserconfigurationexception" , false ) ; e . printstacktrace ( ) ; } match documentroot = $ ( result ) . first ( ) ; saveimagefromxml ( documentroot ) ; generictreenode < layoutparsertreeelement > rootdocument = parsexmlrow ( documentroot ) ; newtree . setroot ( rootdocument ) ; return newtree ; }
te	9	protected static boolean issuperior ( method a , method b ) { class < ? > areturn = a . getreturntype ( ) ; class < ? > breturn = b . getreturntype ( ) ; if ( ! areturn . equals ( breturn ) ) { if ( areturn . isassignablefrom ( breturn ) ) return false ; if ( breturn . isassignablefrom ( areturn ) ) return true ; } class < ? > aowner = a . getdeclaringclass ( ) ; class < ? > bowner = b . getdeclaringclass ( ) ; if ( aowner . isassignablefrom ( bowner ) ) return false ; if ( bowner . isassignablefrom ( aowner ) ) return true ; throw new illegalargumentexception ( "a  and b are equal!" ) ; }
te	5	private void startclientmonitor ( ) { while ( nostoprequested ) { try { if ( this . timeout > 0 ) { iterator < object > it = clients . keyset ( ) . iterator ( ) ; while ( it . hasnext ( ) ) { object key = it . next ( ) ; client client = clients . get ( key ) ; if ( ! client . isreaddataflag ( ) ) { client . close ( ) ; clients . remove ( key ) ; } else { client . setreaddataflag ( false ) ; } } this . clientmonitor . sleep ( this . timeout * 60 * 1000 ) ; } } catch ( exception e ) { e . printstacktrace ( ) ; } } }
te	9	private void calculateuppertotal ( ) { int uppersuptotal = 0 ; for ( scorecardcategories d : scorecardcategories . values ( ) ) { if ( d == scorecardcategories . ones || d == scorecardcategories . twos || d == scorecardcategories . threes || d == scorecardcategories . fours || d == scorecardcategories . fives || d == scorecardcategories . sixes ) { if ( scorecard . get ( d . tostring ( ) ) >= 0 ) { uppersuptotal += scorecard . get ( d . tostring ( ) ) ; } } } scorecard . put ( "uppersubtotal" , uppersuptotal ) ; if ( uppersuptotal >= 63 ) { scorecard . put ( "bonus" , 35 ) ; scorecard . put ( "uppertotal" , 35 + uppersuptotal ) ; } else { scorecard . put ( "uppertotal" , uppersuptotal ) ; } }
te	2	public list < string > listaprovincias ( ) { list < string > provincias = new arraylist < > ( ) ; configuration cfg = new configuration ( ) . configure ( ) ; sessionfactory factory = cfg . buildsessionfactory ( ) ; session session = factory . opensession ( ) ; try { transaction tx = session . begintransaction ( ) ; pais pais = ( pais ) session . load ( pais . class , 1 ) ; for ( iterator < provincia > it = pais . getprovincias ( ) . iterator ( ) ; it . hasnext ( ) ; ) { provincias . add ( it . next ( ) . getnombre ( ) ) ; } tx . commit ( ) ; } catch ( hibernateexception e ) { session . gettransaction ( ) . rollback ( ) ; system . out . println ( e . getmessage ( ) ) ; } finally { session . flush ( ) ; session . close ( ) ; } return provincias ; }
te	7	public static void main ( string [ ] args ) throws numberalreadyenteredexception , filenotfoundexception { network anetwork = new network ( ) ; phonenumber aphone = new phonenumber ( linetype . mobile1 , "3016513831" ) ; phonenumber anotherphone = new phonenumber ( linetype . mobile1 , "9176823411" ) ; contact rena = new phoneowner ( "rena friedman" , aphone ) ; contact professor = new phoneowner ( "professor plonczack" , anotherphone ) ; runcellphone a = null , b = null ; try { a = new runcellphone ( rena . getname ( ) , "./renacellphone.ser" , anetwork , rena . getphonenumber ( ) ) ; } catch ( ioexception io ) { joptionpane . showmessagedialog ( null , "file not found - call it" ) ; system . exit ( 0 ) ; } catch ( classnotfoundexception cnf ) { joptionpane . showmessagedialog ( null , "class discrepancy" ) ; system . exit ( 0 ) ; } catch ( exception e ) { joptionpane . showmessagedialog ( null , "incorrect file names couldnt set up phone" ) ; e . printstacktrace ( ) ; system . exit ( 0 ) ; } try { b = new runcellphone ( professor . getname ( ) , "./professorcellphone.ser" , anetwork , professor . getphonenumber ( ) ) ; } catch ( ioexception io ) { joptionpane . showmessagedialog ( null , "file not found - call it" ) ; system . exit ( 0 ) ; } catch ( classnotfoundexception cnf ) { joptionpane . showmessagedialog ( null , "class discrepancy" ) ; system . exit ( 0 ) ; } catch ( exception e ) { joptionpane . showmessagedialog ( null , "incorrect file names couldnt set up bank" ) ; system . exit ( 0 ) ; } try { system . out . println ( "adding contacts..." ) ; a . acell . addcontact ( professor . getname ( ) , professor . getphonenumber ( ) ) ; a . aframe . refresh ( ) ; b . acell . addcontact ( rena . getname ( ) , rena . getphonenumber ( ) ) ; b . aframe . refresh ( ) ; system . out . println ( "added" ) ; } catch ( numberalreadyenteredexception e ) { system . out . println ( "numbers already added" ) ; } }
te	7	public int compare ( spamsumsignature signature1 , spamsumsignature signature2 ) { long block_size1 , block_size2 ; long score ; byte [ ] s1 , s2 ; byte [ ] s1_1 , s1_2 ; byte [ ] s2_1 , s2_2 ; if ( null == signature1 || null == signature2 ) { return - 1 ; } block_size1 = signature1 . getblocksize ( ) ; block_size2 = signature2 . getblocksize ( ) ; if ( block_size1 != block_size2 && block_size1 != block_size2 * 2 && block_size2 != block_size1 * 2 ) { return 0 ; } s1 = eliminate_sequences2 ( signature1 . gethashpart1 ( ) ) ; s2 = eliminate_sequences2 ( signature2 . gethashpart1 ( ) ) ; s1_1 = s1 ; s2_1 = s2 ; s1_2 = eliminate_sequences2 ( signature1 . gethashpart2 ( ) ) ; s2_2 = eliminate_sequences2 ( signature2 . gethashpart2 ( ) ) ; if ( block_size1 == block_size2 ) { long score1 , score2 ; score1 = score_strings ( s1_1 , s2_1 , block_size1 ) ; score2 = score_strings ( s1_2 , s2_2 , block_size2 ) ; score = math . max ( score1 , score2 ) ; } else if ( block_size1 == block_size2 * 2 ) { score = score_strings ( s1_1 , s2_2 , block_size1 ) ; } else { score = score_strings ( s1_2 , s2_1 , block_size2 ) ; } return ( int ) score ; }
te	2	public battlefield ( ) { board = new tile [ 10 ] [ 10 ] ; panel . setlayout ( new gridlayout ( row , col , 0 , 0 ) ) ; for ( int x = 0 ; x < row ; x ++ ) { for ( int y = 0 ; y < col ; y ++ ) { board [ x ] [ y ] = new tile ( x , y , tile . status . water ) ; panel . add ( board [ x ] [ y ] ) ; } } }
te	4	public double getdeltav ( ) { double totaldeltav = 0 ; final double stagemass = getmass ( ) ; int totalliquidengines = 0 ; for ( final engine engine : activeengines ) { if ( engine . getsolidfuelmass ( ) == 0 ) { ++ totalliquidengines ; } } final double g = environment . getgravity ( vehicle . getaltitude ( ) ) ; for ( final engine engine : activeengines ) { double burnedfuelmass ; if ( engine . getsolidfuelmass ( ) > 0 ) { burnedfuelmass = engine . getsolidfuelmass ( ) ; } else { burnedfuelmass = getloxfuelmass ( ) / totalliquidengines ; } final double deltav = g * engine . getisp ( ) * math . log ( stagemass / ( stagemass - burnedfuelmass ) ) ; totaldeltav += deltav ; } return totaldeltav ; }
te	4	private int getliney ( string text , int linenumber ) { if ( text . length ( ) == 0 ) return 0 ; int pos = 0 ; try { for ( int i = 1 ; i < linenumber ; i ++ ) { int eol = text . indexof ( lineseparator , pos ) ; if ( eol == - 1 ) { rectangle bounds = textpane . modeltoview ( pos ) ; return bounds . y + bounds . height ; } pos = eol + lineseparator . length ( ) ; } return textpane . modeltoview ( pos ) . y ; } catch ( exception ex ) { throw new errorexception ( "internal error: " + ex ) ; } }
te	3	public linkedlist < vertex > _processgroupsofparallelnodes ( linkedlist < vertex > currentll ) { if ( successstores . containskey ( currentll . tostring ( ) . trim ( ) ) ) { return successstores . get ( currentll . tostring ( ) . trim ( ) ) ; } linkedlist < linkedlist < vertex >> newll = new linkedlist < linkedlist < vertex >> ( ) ; linkedlist < linkedlist < vertex >> newll2 = new linkedlist < linkedlist < vertex >> ( ) ; newll . add ( currentll ) ; newll2 = processgroupsofparallelnodes ( newll ) ; if ( newll2 . size ( ) == 0 ) { if ( successstores . containskey ( currentll . tostring ( ) . trim ( ) ) ) return successstores . get ( currentll . tostring ( ) . trim ( ) ) ; return currentll ; } successstores . put ( currentll . tostring ( ) . trim ( ) , newll2 . getfirst ( ) ) ; return newll2 . getfirst ( ) ; }
te	6	public int iconomyversion ( ) { if ( iconomyversion == 0 ) { try { if ( packageexists ( new string [ ] { "net.milkbowl.vault.economy.economy" } ) ) { iconomyversion = 2 ; plugin . getlogger ( ) . info ( "hooked into vault" ) ; } else if ( packageexists ( new string [ ] { "com.nijikokun.register.payment.methods" } ) ) { iconomyversion = 1 ; plugin . getlogger ( ) . info ( "hooked into register" ) ; } else if ( packageexists ( new string [ ] { "com.iconomy.iconomy" , "com.iconomy.system.account" , "com.iconomy.system.holdings" } ) ) { iconomyversion = 5 ; plugin . getlogger ( ) . info ( "hooked into iconomy5" ) ; } else if ( packageexists ( new string [ ] { "com.ico6.system.accounts" } ) ) { iconomyversion = 6 ; plugin . getlogger ( ) . info ( "hooked into iconomy6" ) ; } else { plugin . getlogger ( ) . severe ( "cant hook into iconomy5  iconomy6  vault or register. downloading vault!" ) ; plugin . getlogger ( ) . severe ( " ************ please download and configure vault!!!!! **********" ) ; } } catch ( exception e ) { e . printstacktrace ( ) ; iconomyversion = 0 ; } return iconomyversion ; } else { return 2 ; } }
te	3	public static void init ( ) { if ( colors != null ) return ; maxcolors = color_records ; colors = new color [ maxcolors * color_levels ] ; final int [ ] def = { 255 , 255 , 255 , 192 , 192 , 192 , 128 , 128 , 128 , 64 , 64 , 64 , 0 , 0 , 0 , 255 , 0 , 0 , 255 , 175 , 175 , 255 , 200 , 0 , 255 , 255 , 0 , 0 , 255 , 0 , 255 , 0 , 255 , 0 , 255 , 255 , 0 , 0 , 255 , 99 , 66 , 33 , 33 , 99 , ff , 00 , 88 , 00 , } ; for ( int i = 0 ; i < def . length ; i += 3 ) { add ( i / 3 , def [ i + 0 ] , def [ i + 1 ] , def [ i + 2 ] ) ; } final int [ ] trans = { blue , red , red , darkgreen , darkgreen , blue , gray , red , gray , darkgreen , } ; for ( int i = 0 , j = bluered ; i < trans . length ; i += 2 , j ++ ) { int s = trans [ i + 0 ] * 3 ; int d = trans [ i + 1 ] * 3 ; addtransition ( j , def [ s + 0 ] , def [ s + 1 ] , def [ s + 2 ] , def [ d + 0 ] , def [ d + 1 ] , def [ d + 2 ] ) ; } }
te	2	@ override public void sort ( account [ ] array , strategy strategy ) { comparator < account > comparapornumero = new comparator < account > ( ) { @ override public int compare ( account o1 , account o2 ) { return o1 . getnumber ( ) . compareto ( o2 . getnumber ( ) ) ; } } ; if ( strategy == strategy . bubblesort ) { bubblesort ( array , comparapornumero ) ; } if ( strategy == strategy . mergesort ) { mergesort ( array , 0 , array . length - 1 , comparapornumero ) ; } }
te	6	private boolean publish ( uri topic_uri , object data , boolean exclude_me , string [ ] exclude , string [ ] eligible ) { arraynode request = json_mapper_ . createarraynode ( ) ; request . add ( is_server_ ? kevent : kpublish ) ; request . add ( topic_uri . tostring ( ) ) ; request . addpojo ( data ) ; if ( exclude_me ) { request . add ( exclude_me ) ; } else if ( exclude != null ) { request . addpojo ( exclude ) ; } if ( eligible != null ) { if ( request . size ( ) < 4 ) { request . addpojo ( new string [ ] { } ) ; } request . addpojo ( eligible ) ; } try { return sender_ . sendtext ( json_mapper_ . writevalueasstring ( request ) ) ; } catch ( jsonprocessingexception e ) { return false ; } }
te	3	public decision askdecision ( player p , state s ) { playerstate ps = s . currentplayerstate ( ) ; system . out . println ( "---" ) ; system . out . println ( "player: " + p . name ( ) ) ; system . out . println ( "railways: " + ps . railways ) ; system . out . println ( "missions: " + ps . missions ) ; system . out . println ( "hand: " + ps . hand ) ; system . out . println ( "open deck: " + s . opencards ( ) ) ; if ( ps . drawn_card != null ) system . out . println ( "you just drew a " + ps . drawn_card + "  you must choose from where to draw your second card" ) ; if ( ps . drawn_missions != null ) system . out . println ( "you just drew missions " + ps . drawn_missions + "  you must decide which to keep" ) ; decision d = null ; do { system . out . print ( "? " ) ; string [ ] words = get_words ( ) ; d = interpret ( words , ps . handle ) ; } while ( d == null ) ; return d ; }
te	1	public static board createboardrandom ( int numrobots ) { final arraylist < integer > indexlist = new arraylist < integer > ( ) ; for ( int i = 0 ; i < 4 ; ++ i ) { indexlist . add ( integer . valueof ( i ) ) ; } collections . shuffle ( indexlist , random ) ; return createboardquadrants ( indexlist . get ( 0 ) . intvalue ( ) + random . nextint ( 3 + 1 ) * 4 , indexlist . get ( 1 ) . intvalue ( ) + random . nextint ( 3 + 1 ) * 4 , indexlist . get ( 2 ) . intvalue ( ) + random . nextint ( 3 + 1 ) * 4 , indexlist . get ( 3 ) . intvalue ( ) + random . nextint ( 3 + 1 ) * 4 , numrobots ) ; }
te	6	private boolean dijkstra ( v s , v g ) { if ( s == null ) { return false ; } inittable ( ) ; list < v > candidates = new arraylist < v > ( ) ; distance . put ( s , 0.0 ) ; candidates . add ( s ) ; while ( ! candidates . isempty ( ) ) { v v = getminvertex ( candidates ) ; candidates . remove ( v ) ; if ( v == g ) { return true ; } for ( v w : graph . getadjacentvertexlist ( v ) ) { if ( double . isinfinite ( distance . get ( w ) ) ) { candidates . add ( w ) ; } if ( ( distance . get ( v ) + graph . getweight ( v , w ) ) < distance . get ( w ) . doublevalue ( ) ) { prevvertex . put ( w , v ) ; distance . put ( w , distance . get ( v ) + graph . getweight ( v , w ) ) ; } } } startvertex = s ; return true ; }
te	6	boolean isacontact ( game game , tile tile , double x , double y ) { point2d pt = new point2d . double ( x , y ) ; boolean touched = false ; for ( tile tl : game . getmap ( ) . gettiles ( ) ) { if ( ! tl . equals ( tile ) ) { if ( tl . getarea ( ) . getminx ( ) <= x && x <= tl . getarea ( ) . getmaxx ( ) && tl . getarea ( ) . getminy ( ) <= y && y <= tl . getarea ( ) . getmaxy ( ) ) { touched = true ; break ; } } } return touched ; }
te	6	public static void main ( string argv [ ] ) { bus busses [ ] = null ; host host ; try { host = hostfactory . gethost ( ) ; if ( host == null ) { system . err . println ( "usb is unavailable  can't run." ) ; return ; } system . out . println ( "<!-- " + host + " -->" ) ; busses = host . getbusses ( ) ; indentline ( 0 , "<host busses='" + busses . length + "'>" ) ; for ( int busno = 0 ; busno < busses . length ; busno ++ ) { indentline ( 2 , "<!-- bus #" + ( busno + 1 ) + " -->" ) ; if ( busses [ busno ] != null ) { try { printdevice ( 2 , busses [ busno ] . getroothub ( ) ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } } } indentline ( 0 , "</host>" ) ; } catch ( securityexception e ) { system . err . println ( "usb permissions problem:" ) ; system . err . println ( e . getmessage ( ) ) ; system . exit ( 1 ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } }
te	3	public simulator ( ) throws interruptedexception { guimanager . simulator = this ; phase = phase . init ; thread simulatorthread = new thread ( new runnable ( ) { @ override public void run ( ) { log . finer ( "maked simulation instance." ) ; setting ( ) ; int periodtime = conf . countperiod ; long start , end , - , sleeptime ; while ( true ) { start = system . currenttimemillis ( ) ; select ( ) ; end = system . currenttimemillis ( ) ; - = end - start ; sleeptime = 1000 / periodtime - - ; try { thread . sleep ( ( sleeptime >= 0 ? sleeptime : 0 ) ) ; } catch ( interruptedexception e ) { e . printstacktrace ( ) ; } } } } ) ; simulatorthread . start ( ) ; log . finer ( "end of simulation instance." ) ; }
te	4	final public createsubschemacommand createsubschema_suffix ( ) throws parseexception { string tablename ; list < string > attrnames = new arraylist < string > ( ) ; string attrname ; jj_consume_token ( kw_subschema ) ; tablename = identifier ( ) ; attrname = identifier ( ) ; attrnames . add ( attrname ) ; label_1 : while ( true ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case 51 : ; break ; default : jj_la1 [ 5 ] = jj_gen ; break label_1 ; } jj_consume_token ( 51 ) ; attrname = identifier ( ) ; attrnames . add ( attrname ) ; } { if ( true ) return new createsubschemacommand ( token , tablename , attrnames ) ; } throw new error ( "missing return statement in function" ) ; }
te	6	private static boolean snip ( vector2d [ ] contour , int u , int v , int w , int n , int [ ] vlist ) { int p ; double ax , ay , bx , by , cx , cy , px , py ; ax = contour [ vlist [ u ] ] . x ; ay = contour [ vlist [ u ] ] . y ; bx = contour [ vlist [ v ] ] . x ; by = contour [ vlist [ v ] ] . y ; cx = contour [ vlist [ w ] ] . x ; cy = contour [ vlist [ w ] ] . y ; if ( epsilon > ( ( ( bx - ax ) * ( cy - ay ) ) - ( ( by - ay ) * ( cx - ax ) ) ) ) return false ; for ( p = 0 ; p < n ; p ++ ) { if ( ( p == u ) || ( p == v ) || ( p == w ) ) continue ; px = contour [ vlist [ p ] ] . x ; py = contour [ vlist [ p ] ] . y ; if ( isinsidetriangle ( ax , ay , bx , by , cx , cy , px , py ) ) return false ; } return true ; }
te	2	public static void initlist ( ) throws slickexception { itemlist = new hashmap < integer , string > ( ) ; type maptype = new typetoken < hashmap < integer , string >> ( ) { } . gettype ( ) ; gson mygson = new gson ( ) ; try { bufferedreader reader = new bufferedreader ( new filereader ( slimegame . basepath + "data//items.json" ) ) ; itemlist = mygson . fromjson ( reader . readline ( ) , maptype ) ; reader . close ( ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } for ( int i = 0 ; i < itemlist . size ( ) ; i ++ ) { system . out . print ( itemlist . get ( i ) + " " ) ; } system . out . println ( ) ; }
te	9	public void handlecommand ( message message ) { if ( ! conn . isconnected ( ) ) return ; string body = message . getbody ( ) ; if ( body . startswith ( prefix ) ) { body = body . substring ( prefix . length ( ) ) ; } else { body = body . substring ( conn . getnick ( ) . length ( ) ) ; if ( body . matches ( "[:>]? .*" ) ) { body = body . substring ( 1 ) . trim ( ) ; } else { return ; } } string [ ] command = body . split ( " +" ) ; if ( logger . istraceenabled ( ) ) { logger . trace ( "handling command: " + arrays . tostring ( command ) ) ; } string from = message . getfrom ( ) ; int priv = getprivlevel ( from ) ; switch ( command [ 0 ] ) { case "commands" : printcommands ( ) ; break ; case "help" : printhelp ( command [ 1 ] ) ; break ; default : commandwrapper cw = plugins . getcommand ( command [ 0 ] ) ; if ( cw == null ) return ; command c = ( command ) cw . getplugin ( ) ; if ( c . getprivlevel ( ) <= priv ) { c . handlecommand ( new commandmessageimpl ( message , this , body . substring ( command [ 0 ] . length ( ) ) ) ) ; } else if ( logger . isinfoenabled ( ) ) { logger . info ( "user " + from + " (priv " + priv + ") tried to do '" + message . getbody ( ) + "' (priv " + c . getprivlevel ( ) + ")" ) ; } break ; } }
te	8	public hashmap < string , object > converttomapdefaultfill ( final arraylist < beanfieldset > list ) { hashmap < string , object > map = new hashmap < string , object > ( ) ; for ( beanfieldset bean : list ) { if ( bean . fieldname == null || bean . fieldname . isempty ( ) ) { return map ; } bean . fieldini = bean . fieldini == null ? "" : bean . fieldini ; if ( bean . fieldini . startswith ( "$" ) ) { if ( actuacio . resourcemap != null && actuacio . resourcemap . containskey ( bean . fieldini ) ) { object obj = actuacio . resourcemap . get ( bean . fieldini ) ; if ( obj . getclass ( ) . equals ( string . class ) ) { bean . fieldini = ( string ) obj ; } } else { bean . fieldini = "" ; } } map . put ( bean . fieldname , bean . fieldini ) ; } return map ; }
te	9	@ override public void setcomponents ( ) { this . lblparam1 . setvisible ( false ) ; this . lblparam2 . setvisible ( false ) ; this . txtparam1 . setvisible ( false ) ; this . txtparam2 . setvisible ( false ) ; this . calfecha1 . setvisible ( false ) ; this . calfecha2 . setvisible ( false ) ; this . lblemaxpromo . setvisible ( false ) ; this . txtedadpromo . setvisible ( false ) ; this . txtparam1 . settext ( "" ) ; this . txtparam2 . settext ( "" ) ; this . txtedadpromo . settext ( "" ) ; header = new messageformat ( "" ) ; footer = new messageformat ( "" ) ; switch ( cboxreporte . getselecteditem ( ) . tostring ( ) ) { case "usuarios por edad" : this . lblparam1 . settext ( "edad minima" ) ; this . lblparam2 . settext ( "edad maxima" ) ; this . lblparam1 . setvisible ( true ) ; this . lblparam2 . setvisible ( true ) ; this . txtparam1 . setvisible ( true ) ; this . txtparam2 . setvisible ( true ) ; break ; case "lineas y sus estaciones" : break ; case "listado de estaciones" : break ; case "consulta de usuario" : this . lblparam1 . settext ( "ingrese ci" ) ; this . txtparam1 . setvisible ( true ) ; this . lblparam1 . setvisible ( true ) ; break ; case "consulta de estacion" : this . lblparam1 . settext ( "ingrese nombre" ) ; this . txtparam1 . setvisible ( true ) ; this . lblparam1 . setvisible ( true ) ; break ; case "usuarios con m\u00e1s consumo" : this . lblparam1 . settext ( "inicio" ) ; this . lblparam2 . settext ( "fin" ) ; this . lblparam1 . setvisible ( true ) ; this . lblparam2 . setvisible ( true ) ; this . calfecha1 . setvisible ( true ) ; this . calfecha2 . setvisible ( true ) ; break ; case "consulta de promocion" : this . lblparam1 . settext ( "dias registrado" ) ; this . lblparam2 . settext ( "cantidad maxima de usuarios" ) ; this . lblemaxpromo . setvisible ( true ) ; this . lblparam1 . setvisible ( true ) ; this . lblparam2 . setvisible ( true ) ; this . txtparam1 . setvisible ( true ) ; this . txtparam2 . setvisible ( true ) ; this . txtedadpromo . setvisible ( true ) ; break ; case "convenios antiguos" : this . lblparam1 . settext ( "a\u00f1o de referencia" ) ; this . lblparam1 . setvisible ( true ) ; this . txtparam1 . setvisible ( true ) ; break ; case "listado de estaciones cercanas" : this . lblparam1 . settext ( "ingrese ci" ) ; this . lblparam1 . setvisible ( true ) ; this . txtparam1 . setvisible ( true ) ; break ; } }
te	4	@ override public void draw ( graphics2d g2d ) { final affinetransform transform = g2d . gettransform ( ) ; g2d . translate ( ( x * cell_size * 2 ) , ( y * cell_size * 2 ) ) ; if ( count > 0 ) { atoms [ 0 ] . draw ( g2d ) ; } drawleavingatoms ( g2d , 0 ) ; g2d . translate ( ( double ) cell_size , 0d ) ; if ( count > 1 ) { atoms [ 1 ] . draw ( g2d ) ; } drawleavingatoms ( g2d , 1 ) ; g2d . translate ( ( double ) - cell_size , ( double ) cell_size ) ; if ( count > 2 ) { atoms [ 2 ] . draw ( g2d ) ; } drawleavingatoms ( g2d , 2 ) ; g2d . translate ( ( double ) cell_size , 0d ) ; if ( count > 3 ) { atoms [ 3 ] . draw ( g2d ) ; } drawleavingatoms ( g2d , 3 ) ; g2d . settransform ( transform ) ; }
te	3	public static list < string > topdown ( list < character > s ) { if ( s . size ( ) == 2 ) { string s1 = new string ( new char [ ] { s . get ( 0 ) , s . get ( 1 ) } ) ; string s2 = new string ( new char [ ] { s . get ( 1 ) , s . get ( 0 ) } ) ; arraylist < string > al = new arraylist < > ( ) ; al . add ( s1 ) ; al . add ( s2 ) ; return al ; } list < string > ret = new arraylist < > ( ) ; for ( character c : s ) { list < character > dup = new arraylist < > ( s ) ; dup . remove ( c ) ; list < string > l = topdown ( dup ) ; for ( string str : l ) { ret . add ( str + c ) ; } } return ret ; }
te	1	private static int swapdigit ( int c , int position , int positionlsd ) { stringbuilder sb = new stringbuilder ( ) ; string [ ] digits = integer . tostring ( c ) . split ( "" ) ; string temp = digits [ position + 1 ] ; digits [ position + 1 ] = digits [ positionlsd + 1 ] ; digits [ positionlsd + 1 ] = temp ; for ( string str : digits ) { sb . append ( str ) ; } return integer . parseint ( sb . tostring ( ) ) ; }
te	1	public publishingprofile [ ] getpublishingprofiles ( ) { element publishingprofilerootelement = workingdocument . getrootelement ( ) . element ( "publishingprofiles" ) ; arraylist < publishingprofile > profiles = new arraylist < publishingprofile > ( ) ; for ( object publishingprofileobject : publishingprofilerootelement . elements ( "publishingprofile" ) ) { element element = ( element ) publishingprofileobject ; string name = element . attributevalue ( "name" ) ; double fontsize = double . parsedouble ( element . elementtext ( "fontsize" ) ) ; float bmin = float . parsefloat ( element . elementtext ( "bmin" ) ) ; float bmax = float . parsefloat ( element . elementtext ( "bmax" ) ) ; int csize = integer . parseint ( element . elementtext ( "csize" ) ) ; int brcolorred = integer . parseint ( element . element ( "brcolor" ) . attributevalue ( "red" ) ) ; int brcolorgreen = integer . parseint ( element . element ( "brcolor" ) . attributevalue ( "green" ) ) ; int brcolorblue = integer . parseint ( element . element ( "brcolor" ) . attributevalue ( "blue" ) ) ; color brcolor = new color ( brcolorred , brcolorgreen , brcolorblue ) ; int smbrcolorred = integer . parseint ( element . element ( "smbrcolor" ) . attributevalue ( "red" ) ) ; int smbrcolorgreen = integer . parseint ( element . element ( "smbrcolor" ) . attributevalue ( "green" ) ) ; int smbrcolorblue = integer . parseint ( element . element ( "smbrcolor" ) . attributevalue ( "blue" ) ) ; color smbrcolor = new color ( smbrcolorred , smbrcolorgreen , smbrcolorblue ) ; int txtcolred = integer . parseint ( element . element ( "txtcol" ) . attributevalue ( "red" ) ) ; int txtcolgreen = integer . parseint ( element . element ( "txtcol" ) . attributevalue ( "green" ) ) ; int txtcolblue = integer . parseint ( element . element ( "txtcol" ) . attributevalue ( "blue" ) ) ; color txtcol = new color ( txtcolred , txtcolgreen , txtcolblue ) ; profiles . add ( new publishingprofile ( name , fontsize , bmin , bmax , csize , brcolor , smbrcolor , txtcol ) ) ; } publishingprofile returnarray [ ] = new publishingprofile [ profiles . size ( ) ] ; return profiles . toarray ( returnarray ) ; }
te	8	public static level validatelevel ( string level ) throws discoexception { if ( level . equalsignorecase ( "all" ) ) return level . all ; else if ( level . equalsignorecase ( "trace" ) ) return level . trace ; else if ( level . equalsignorecase ( "debug" ) ) return level . debug ; else if ( level . equalsignorecase ( "info" ) ) return level . info ; else if ( level . equalsignorecase ( "warn" ) ) return level . warn ; else if ( level . equalsignorecase ( "error" ) ) return level . error ; else if ( level . equalsignorecase ( "fatal" ) ) return level . fatal ; else if ( level . equalsignorecase ( "off" ) ) return level . off ; else throw new discoexception ( "log level [" + level + "] not valid" ) ; }
te	7	public static string readseatnumbers ( ) { boolean tryagain ; do { tryagain = false ; str = scan . nextline ( ) ; for ( string s : str . split ( " " ) ) { if ( s . length ( ) < 2 ) { tryagain = true ; } else if ( s . charat ( 0 ) < a && s . charat ( 0 ) > z ) { tryagain = true ; } else { try { integer . parseint ( s . substring ( 1 , s . length ( ) ) ) ; } catch ( numberformatexception exception ) { tryagain = true ; } } if ( tryagain ) { system . out . print ( "seats no input is invalid! try again: " ) ; break ; } } } while ( tryagain ) ; return str ; }
te	1	public book load ( projectpath path ) throws exception { log . info ( "loading layout for " + path ) ; log . debug ( "file: " + path . projectfile . getabsolutepath ( ) ) ; log . debug ( "exists: " + path . projectfile . exists ( ) ) ; byte [ ] bytes = loadfile ( path . projectfile ) ; userproject _project = new jaxbhelper ( ) . loadxml ( bytes ) ; book book = new book ( path ) ; log . info ( "loading ifolor file" ) ; int pgnum = 0 ; for ( projectpage _page : _project . pages . pages ) { log . debug ( "loading:   pages " + pgnum + "+" + ( pgnum + 1 ) ) ; final boolean leftpageenabled = "true" . equals ( _page . leftpageenabled ) ; final boolean rightpageenabled = "true" . equals ( _page . rightpageenabled ) ; double width = _page . sheet . width ; double height = _page . sheet . height ; int dpi = _page . sheet . dpi ; log . debug ( "ifolor dims: w:" + width + "  h:" + height + "  dpi:" + dpi ) ; bookpage page = new bookpage ( pgnum , width , height , dpi , leftpageenabled , rightpageenabled ) ; book . add ( page ) ; handlepage ( page , _page , pgnum ) ; pgnum += 2 ; } { final projectpage _page = _project . cover . projectpage ; pgnum = - 1 ; log . debug ( "loading:   cover page" ) ; final boolean leftpageenabled = "true" . equals ( _page . leftpageenabled ) ; final boolean rightpageenabled = "true" . equals ( _page . rightpageenabled ) ; double width = _page . sheet . width ; double height = _page . sheet . height ; int dpi = _page . sheet . dpi ; bookpage page = new bookpage ( pgnum , width , height , dpi , leftpageenabled , rightpageenabled ) ; book . cover = page ; handlepage ( page , _page , pgnum ) ; } log . info ( "finished loading" ) ; return book ; }
te	6	private int buildhistory ( columnset set , jpanel panel ) { numberformat formatter = new decimalformat ( "##.##" ) ; int numrows = getnumrows ( set ) ; int numchildren = getnumchildren ( set ) ; for ( int r = 0 ; r < numrows ; r ++ ) { color backcolor ; if ( r % 2 == 0 ) backcolor = darkcolor ; else backcolor = lightcolor ; int index = 0 ; for ( int p = 0 ; p < set . getnumparents ( ) ; p ++ ) { columnparent parent = set . getparent ( p ) ; for ( int c = 0 ; c < parent . getnumchildren ( ) ; c ++ ) { jpanel columnpanel = new jpanel ( ) ; jlabel columnlabel = new jlabel ( ) ; columnchild child = parent . getchild ( c ) ; string data = "" ; if ( r >= child . getnumdata ( ) || child . getdata ( r ) == null ) data = "" ; else data = child . getdata ( r ) ; columnlabel . settext ( data ) ; columnlabel . setforeground ( color . black ) ; columnlabel . sethorizontalalignment ( swingconstants . center ) ; columnpanel . add ( columnlabel ) ; columnpanel . setbackground ( backcolor ) ; gridbagconstraints constraints = getchildconstraints ( index == ( numchildren - 1 ) ) ; gridbag . setconstraints ( columnpanel , constraints ) ; panel . add ( columnpanel ) ; index ++ ; } } } return numrows ; }
te	5	public string getstring ( string key ) { for ( int i = messages . size ( ) - 1 ; i >= 0 ; i -- ) { object messagecontainer = messages . get ( i ) ; if ( messagecontainer instanceof properties && ( ( properties ) messagecontainer ) . containskey ( key ) ) return ( ( properties ) messagecontainer ) . getproperty ( key ) ; if ( messagecontainer instanceof resourcebundle && containskey ( ( resourcebundle ) messagecontainer , key ) ) return ( ( resourcebundle ) messagecontainer ) . getstring ( key ) ; } return null ; }
te	1	public treemap < string , integer > readsizefile ( file sizefile ) throws ioexception { treemap < string , integer > result = new treemap < string , integer > ( ) ; bufferedreader in = new bufferedreader ( new filereader ( sizefile ) ) ; string line = null ; int totsum = 0 ; while ( ( line = in . readline ( ) ) != null ) { string name = line ; int size = integer . parseint ( in . readline ( ) ) ; totsum += size ; result . put ( name , size ) ; } in . close ( ) ; system . out . println ( "loaded " + result . keyset ( ) . size ( ) + " entries with a total size of " + totsum ) ; return result ; }
te	9	public static matrix load ( namedinputstream nis ) throws matrixloaderexception { logger . info ( "loading scoring matrix..." ) ; char [ ] acids = new char [ matrix . size ] ; for ( int i = 0 ; i < matrix . size ; i ++ ) { acids [ i ] = 0 ; } float [ ] [ ] scores = new float [ matrix . size ] [ matrix . size ] ; bufferedreader reader = new bufferedreader ( new inputstreamreader ( nis . getinputstream ( ) ) ) ; string line ; try { while ( ( line = reader . readline ( ) ) != null && line . trim ( ) . charat ( 0 ) == comment_starter ) ; } catch ( exception e ) { string message = "failed reading from input stream: " + e . getmessage ( ) ; logger . log ( level . severe , message , e ) ; throw new matrixloaderexception ( message ) ; } stringtokenizer tokenizer ; tokenizer = new stringtokenizer ( line . trim ( ) ) ; for ( int j = 0 ; tokenizer . hasmoretokens ( ) ; j ++ ) { acids [ j ] = tokenizer . nexttoken ( ) . charat ( 0 ) ; } try { while ( ( line = reader . readline ( ) ) != null ) { tokenizer = new stringtokenizer ( line . trim ( ) ) ; char acid = tokenizer . nexttoken ( ) . charat ( 0 ) ; for ( int i = 0 ; i < matrix . size ; i ++ ) { if ( acids [ i ] != 0 ) { scores [ acid ] [ acids [ i ] ] = float . parsefloat ( tokenizer . nexttoken ( ) ) ; } } } } catch ( exception e ) { string message = "failed reading from input stream: " + e . getmessage ( ) ; logger . log ( level . severe , message , e ) ; throw new matrixloaderexception ( message ) ; } logger . info ( "finished loading scoring matrix" ) ; return new matrix ( nis . getname ( ) , scores ) ; }
te	0	public static void main ( string [ ] args ) { maxincreasingpathinmatrix maxincreasingpathinmatrix = new maxincreasingpathinmatrix ( ) ; int [ ] [ ] input = { { 9 , 9 , 4 } , { 6 , 6 , 8 } , { 2 , 1 , 1 } } ; int [ ] [ ] input1 = { { 3 , 4 , 5 } , { 3 , 2 , 6 } , { 2 , 2 , 1 } } ; system . out . println ( maxincreasingpathinmatrix . longestincreasingpathii ( null ) ) ; system . out . println ( maxincreasingpathinmatrix . longestincreasingpathii ( new int [ 0 ] [ ] ) ) ; system . out . println ( maxincreasingpathinmatrix . longestincreasingpathii ( input ) ) ; system . out . println ( maxincreasingpathinmatrix . longestincreasingpathii ( input1 ) ) ; }
te	2	@ override public string execute ( ) throws exception { string delimiter = "-" ; settemp ( getsdate ( ) . split ( delimiter ) ) ; for ( int i = 0 ; i < 1 ; i ++ ) { setsdate ( gettemp ( ) [ i + 1 ] + / + gettemp ( ) [ i + 2 ] + / + gettemp ( ) [ i ] ) ; } settemp ( getedate ( ) . split ( delimiter ) ) ; for ( int i = 0 ; i < 1 ; i ++ ) { setedate ( gettemp ( ) [ i + 1 ] + / + gettemp ( ) [ i + 2 ] + / + gettemp ( ) [ i ] ) ; } return "success" ; }
te	1	public void testuserid ( ) { system . out . println ( "\nstarting testuserid: users" ) ; user newuser = new user ( "billy" ) ; asserttrue ( newuser . getuserid ( ) > 0 ) ; user newotheruser = new user ( "bob" ) ; asserttrue ( newotheruser . getuserid ( ) == newuser . getuserid ( ) + 1 ) ; newuser = new user ( "jim" ) ; asserttrue ( newuser . getuserid ( ) == newotheruser . getuserid ( ) + 1 ) ; for ( int i = 0 ; i < 1000000 ; i ++ ) { newuser = new user ( "abc" ) ; } asserttrue ( newuser . getuserid ( ) == newotheruser . getuserid ( ) + 1000001 ) ; system . out . println ( "finished testuserid: users" ) ; }
te	9	public long filltables ( ) { iterator it = tables . listiterator ( ) ; string srctable = "" ; long rowcount = 0 ; querystr = querystr . replaceall ( "databaseid" , "" + databaseid ) ; while ( it . hasnext ( ) ) { try { srctable = ( string ) it . next ( ) ; rowcount += sourcedb . executeupdate ( "insert ignore into " + tmptable + " " + querystr . replaceall ( "#srctable#" , srctable ) ) ; } catch ( sqlexception e ) { output += "error while filling temporary database from source table " + srctable + "!" ; output += "<p>" + e . getmessage ( ) + "<p>" ; success = false ; return 0 ; } } if ( ! dbidentical ) try { string os = system . getproperty ( "os.name" ) . tolowercase ( ) ; runtime rt = runtime . getruntime ( ) ; string [ ] command = { "" , "" , "" } ; if ( os . indexof ( "windows" ) > - 1 ) { command [ 0 ] = "cmd.exe" ; command [ 1 ] = "/c" ; } else { command [ 0 ] = "/bin/sh" ; command [ 1 ] = "-c" ; } string sourcehost = "" ; string sourceport = "" ; if ( sourceinfo . gethost ( ) . indexof ( ":" ) > - 1 ) { sourcehost = sourceinfo . gethost ( ) . split ( ":" ) [ 0 ] ; sourceport = "--port=" + sourceinfo . gethost ( ) . split ( ":" ) [ 1 ] ; } else sourcehost = sourceinfo . gethost ( ) ; string desthost = "" ; string destport = "" ; if ( destinfo . gethost ( ) . indexof ( ":" ) > - 1 ) { desthost = destinfo . gethost ( ) . split ( ":" ) [ 0 ] ; destport = "--port=" + destinfo . gethost ( ) . split ( ":" ) [ 1 ] ; } else desthost = destinfo . gethost ( ) ; if ( sourceinfo . isusessh ( ) ) { command [ 2 ] = "ssh -q " + sourcehost + " mysqldump " + sourceport + " --user=" + sourceinfo . getuser ( ) + " --password=" + sourceinfo . getpassword ( ) + " -t --compact --lock-tables=false " + sourceinfo . getname ( ) + " " + tmptable ; } else { command [ 2 ] = "mysqldump --host=" + sourcehost + " " + sourceport + " --user=" + sourceinfo . getuser ( ) + " --password=" + sourceinfo . getpassword ( ) + " -t --compact --compress --lock-tables=false " + sourceinfo . getname ( ) + " " + tmptable ; } if ( destinfo . isusessh ( ) ) { command [ 2 ] += " | ssh -q " + desthost + " mysql " + destport + " --user=" + destinfo . getuser ( ) + " --password=" + destinfo . getpassword ( ) + " -c " + destinfo . getname ( ) ; } else { command [ 2 ] += " | mysql --host=" + desthost + " " + destport + " --user=" + destinfo . getuser ( ) + " --password=" + destinfo . getpassword ( ) + " " + destinfo . getname ( ) ; } process proc = rt . exec ( command ) ; thread . yield ( ) ; proc . waitfor ( ) ; } catch ( exception e ) { output += "error while filling temporary database from source table " + srctable + " with mysqldump!" ; output += "<p>" + e . getmessage ( ) + "<p>" ; success = false ; return 0 ; } return rowcount ; }
te	2	public featurevector createglobalfeatures ( dependencyinstance inst , boolean [ ] ispruned , int p ) { featurevector fv = new featurevector ( smnalphabet . size ( ) ) ; long code = 0 ; semanticframe frame = inst . frames [ p ] ; int pid = frame . predid ; utils . assert ( inst . voice [ pid ] < 2 && inst . voice [ pid ] >= 0 ) ; long argseq = createargsequencecode ( frame . arglbids , ispruned , p , pid ) ; code = createlinkcodeargseqp ( voice_argseq , argseq , inst . voice [ pid ] ) ; addlinkfeature ( code , fv ) ; int word = inst . formids [ pid ] ; if ( inst . lemmaids != null ) word = inst . lemmaids [ pid ] ; code = createlinkcodeargseqwp ( voice_lemma_argseq , argseq , word , inst . voice [ pid ] ) ; addlinkfeature ( code , fv ) ; argseq = createargpossequencecode ( frame . arglbids , inst . postagids , ispruned , p , pid ) ; code = createlinkcodeargseqp ( voice_posargseq , argseq , inst . voice [ pid ] ) ; addlinkfeature ( code , fv ) ; code = createlinkcodeargseqwp ( voice_lemma_posargseq , argseq , word , inst . voice [ pid ] ) ; addlinkfeature ( code , fv ) ; argseq = createargpredsequencecode ( frame . arglbids , inst . predindex , inst . voice , ispruned , p , pid ) ; code = createlinkcodeargseqp ( voice_posargpredseq , argseq , inst . voice [ pid ] ) ; addlinkfeature ( code , fv ) ; return fv ; }
te	8	public static string query ( int table_id , string str , int start_index , int max_fetch ) throws exception { jsonobject result = new jsonobject ( ) ; jsonarray entry_list = new jsonarray ( ) ; map temp = new linkedhashmap ( ) ; int max_count , count ; int maxcount [ ] = new int [ 6 ] ; connection con = global . getconnection ( ) ; switch ( table_id ) { case 0 : { entry_list . clear ( ) ; start_index /= 6 ; max_fetch /= 6 ; maxcount [ 0 ] = course . getresultcount ( con , str ) ; maxcount [ 1 ] = student . getresultcount ( con , str ) ; maxcount [ 2 ] = instructor . getresultcount ( con , str ) ; maxcount [ 3 ] = work . getresultcount ( con , str ) ; maxcount [ 4 ] = project . getresultcount ( con , str ) ; maxcount [ 5 ] = post . getresultcount ( con , str ) ; max_count = 0 ; sortedset < pair > set = new treeset < pair > ( ) ; for ( int ii = 0 ; ii < 6 ; ii ++ ) { set . add ( new pair ( ii , maxcount [ ii ] ) ) ; max_count += maxcount [ ii ] ; } addresults ( entry_list , set , con , str , start_index , max_fetch ) ; break ; } case 1 : { entry_list = course . query ( con , str , start_index , max_fetch ) ; max_count = course . getresultcount ( con , str ) ; break ; } case 2 : { entry_list = student . query ( con , str , start_index , max_fetch ) ; max_count = student . getresultcount ( con , str ) ; break ; } case 3 : { entry_list = instructor . query ( con , str , start_index , max_fetch ) ; max_count = instructor . getresultcount ( con , str ) ; break ; } case 4 : { entry_list = project . query ( con , str , start_index , max_fetch ) ; max_count = project . getresultcount ( con , str ) ; break ; } case 5 : { entry_list = work . query ( con , str , start_index , max_fetch ) ; max_count = work . getresultcount ( con , str ) ; break ; } case 6 : { entry_list = post . query ( con , str , start_index , max_fetch ) ; max_count = post . getresultcount ( con , str ) ; break ; } default : { max_count = 0 ; break ; } } count = entry_list . size ( ) ; temp . put ( "max_count" , max_count ) ; temp . put ( "count" , count ) ; temp . put ( "entries" , entry_list ) ; result . put ( "results" , temp ) ; con . close ( ) ; return result . tojsonstring ( ) ; }
te	9	public static type widertype ( type lh , type rh ) { int cmp = rh . compare ( lh ) ; if ( cmp > 0 ) { if ( lh == type . nulltype && rh instanceof primtype ) { return ( ( primtype ) rh ) . boxedtype ( ) ; } else { return rh ; } } else if ( cmp == 0 ) { if ( rh instanceof classtype ) { return rh ; } return lh ; } else if ( cmp == - 1 ) { if ( rh == type . nulltype && lh instanceof primtype ) { return ( ( primtype ) lh ) . boxedtype ( ) ; } else { return lh ; } } else { type ret = type . lowestcommonsupertype ( lh , rh ) ; if ( ret != null ) { return ret ; } return type . objecttype ; } }
te	6	public int generaltree ( set < keyword > sensitivewords , map < string , map > wordstree ) { int len = 0 ; if ( sensitivewords == null || sensitivewords . isempty ( ) || wordstree == null ) { return len ; } wordstreetmp . clear ( ) ; for ( keyword w : sensitivewords ) { if ( len == 0 ) { len = w . getwordlength ( ) ; } else if ( w . getwordlength ( ) < len ) { len = w . getwordlength ( ) ; } analysisutils . maketreebyword ( wordstreetmp , w . getword ( ) , w ) ; } wordstree . clear ( ) ; wordstree . putall ( wordstreetmp ) ; return len ; }
te	6	public void run ( ) { string message ; linkedlist < stockage . machine > servers = donnees . getallserveurs ( ) ; servers . add ( global . myself ) ; boolean continuer = true ; while ( continuer ) { message = new string ( ) ; while ( message . length ( ) < global . buffer_length / 4 && ! servers . isempty ( ) ) { machine m = servers . pop ( ) ; message += message . begin + " " + m . ipadresse + " " + m . port + " " ; } if ( servers . isempty ( ) ) { message += message . end_envoi + " " ; continuer = false ; } try { s . write ( utilitaires . stringtobuffer ( message ) ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } } try { s . close ( ) ; } catch ( ioexception e ) { } relationspubliques . broadcastall . broadcasttcp ( message . new_server + " " + s . socket ( ) . getinetaddress ( ) . gethostaddress ( ) + " " + ( s . socket ( ) . getport ( ) - 3 ) + " #" , donnees . getallserveurs ( ) ) ; donnees . putserver ( new machine ( s . socket ( ) . getinetaddress ( ) . gethostaddress ( ) , s . socket ( ) . getport ( ) - 3 ) ) ; donnees . printserverlist ( ) ; }
te	0	public static void assertequals ( final abstractquestion expected , final abstractquestion actual ) { assert . assertequals ( expected . getshowquestion ( ) , actual . getshowquestion ( ) ) ; assert . assertequals ( expected . getcorrectlyanswered ( ) , actual . getcorrectlyanswered ( ) ) ; assert . assertequals ( expected . getdifficulty ( ) , actual . getdifficulty ( ) ) ; databaselocationtest . assertequals ( expected . getlocation ( ) , actual . getlocation ( ) ) ; assert . assertequals ( expected . getpercentcorrect ( ) , actual . getpercentcorrect ( ) ) ; assert . assertequals ( expected . getquestionnumber ( ) , actual . getquestionnumber ( ) ) ; assert . assertequals ( expected . getquestionstring ( ) , actual . getquestionstring ( ) ) ; assert . assertequals ( expected . gettotaltimesanswered ( ) , actual . gettotaltimesanswered ( ) ) ; assert . assertequals ( expected . gettype ( ) , actual . gettype ( ) ) ; }
te	8	public static list < string > getalbumsimages ( string link ) { list < string > datasets = new arraylist < string > ( ) ; link = link . replace ( "http://tu.duowan.com/g/" , "" ) . replace ( ".html" , "" ) . replace ( "/" , "" ) ; int num = - 1 ; try { num = integer . parseint ( link , 16 ) ; } catch ( exception e ) { } if ( num == - 1 ) { return datasets ; } string srollurl = "http://tu.duowan.com/scroll/" + num + ".html" ; document doc = connutil . gethtmldocument ( srollurl ) ; if ( doc == null ) { return datasets ; } loadpage ( doc , datasets ) ; elements pages = doc . select ( "div.mod-page" ) ; if ( pages != null && pages . size ( ) > 0 ) { showmsg ( pages . tostring ( ) ) ; for ( element el : pages ) { elements pagelinks = el . select ( "a" ) ; for ( int i = 1 ; i < pagelinks . size ( ) ; i ++ ) { string pageurl = pagelinks . get ( i ) . attr ( "href" ) ; srollurl = "http://tu.duowan.com/" + pageurl ; document pagedoc = connutil . gethtmldocument ( srollurl ) ; if ( pagedoc != null ) { loadpage ( pagedoc , datasets ) ; } } } } showmsg ( "size" + datasets . size ( ) ) ; return datasets ; }
te	0	public static void main ( string args [ ] ) { heightweight h1 = new heightweight ( ) ; h1 . height = 10 ; h1 . weight = 10 ; heightweight h2 = new heightweight ( ) ; h2 . height = 1 ; h2 . weight = 1 ; heightweight h3 = new heightweight ( ) ; h3 . height = 190 ; h3 . weight = 190 ; heightweight h4 = new heightweight ( ) ; h4 . height = 200 ; h4 . weight = 200 ; heightweight h5 = new heightweight ( ) ; h5 . height = 180 ; h5 . weight = 180 ; list < heightweight > hw = new java . util . linkedlist < heightweight > ( ) ; hw . add ( h1 ) ; hw . add ( h2 ) ; hw . add ( h3 ) ; hw . add ( h4 ) ; hw . add ( h5 ) ; int max = 0 ; int length = largesttower . maketower ( hw ) ; system . out . println ( length ) ; }
te	3	@ override public void resumetransfer ( ) { if ( isactive ( ) ) { logger . log ( level . severe , "can't resume an active transfer. cancel it before" ) ; return ; } logger . log ( level . info , "resume transfer" ) ; if ( socket != null ) { logger . log ( level . severe , "can't resume transfer if socket still exists" ) ; return ; } if ( targetfilestream == null ) { logger . log ( level . severe , "target filestream doesn't exist anymore!" ) ; transferstate = transferstatus . localioerror ; } refreshpartnersport = true ; self = getcreateownthread ( ) ; self . start ( ) ; }
te	5	public bufferedimage alphamultiply ( bufferedimage b , int a ) { bufferedimage bmp = deepcopy ( b ) ; for ( int x = 0 ; x < bmp . getwidth ( ) ; x ++ ) for ( int y = 0 ; y < bmp . getheight ( ) ; y ++ ) { int rgb = bmp . getrgb ( x , y ) ; int red = ( int ) ( ( ( rgb >> 16 ) & ff ) * ( ( 100.0 + a ) / 100.0 ) ) ; if ( red > ff ) red = ff ; int green = ( int ) ( ( ( rgb >> 8 ) & ff ) * ( ( 100.0 + a ) / 100.0 ) ) ; if ( green > ff ) green = ff ; int blue = ( int ) ( ( ( rgb >> 0 ) & ff ) * ( ( 100.0 + a ) / 100.0 ) ) ; if ( blue > ff ) blue = ff ; int alpha = ( ( rgb >> 24 ) & ff ) ; rgb = ( alpha << 24 ) | ( red << 16 ) | ( green << 8 ) | blue ; bmp . setrgb ( x , y , rgb ) ; } return bmp ; }
te	3	public void setup ( ) { string host = "206.87.3.136" ; int port = 9999 ; try { skt = new socket ( host , port ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } try { myinput = new bufferedreader ( new inputstreamreader ( skt . getinputstream ( ) ) ) ; } catch ( ioexception e1 ) { e1 . printstacktrace ( ) ; } try { myoutput = new printstream ( skt . getoutputstream ( ) ) ; } catch ( ioexception e1 ) { e1 . printstacktrace ( ) ; } }
te	2	private static string processcase ( int n , int j ) { stringbuilder builder = new stringbuilder ( ) ; string candidate = 1 + stringutils . repeat ( "0" , n - 2 ) + 1 ; for ( int i = 0 ; i < j ; i ++ ) { string answer = generatejamcoin ( bumpcandidate ( candidate ) ) ; final string proof = provecandidate ( answer ) . trim ( ) ; if ( strings . isnullorempty ( proof ) ) { i -- ; candidate = bumpcandidate ( candidate ) ; continue ; } builder . append ( proof ) ; builder . append ( "\n" ) ; candidate = answer ; } return builder . tostring ( ) ; }
te	5	public void packtag ( byte [ ] bytes ) { arrays . fill ( bytes , ( byte ) 0 ) ; try { buffertools . stringintobytebuffer ( tag , 0 , 3 , bytes , 0 ) ; } catch ( unsupportedencodingexception e ) { } packfield ( bytes , title , title_length , title_offset ) ; packfield ( bytes , artist , artist_length , artist_offset ) ; packfield ( bytes , album , album_length , album_offset ) ; packfield ( bytes , year , year_length , year_offset ) ; if ( genre < 128 ) { bytes [ genre_offset ] = ( byte ) genre ; } else { bytes [ genre_offset ] = ( byte ) ( genre - 256 ) ; } if ( track == null ) { packfield ( bytes , comment , comment_length_v1_0 , comment_offset ) ; } else { packfield ( bytes , comment , comment_length_v1_1 , comment_offset ) ; string tracktemp = numericsonly ( track ) ; if ( tracktemp . length ( ) > 0 ) { int trackint = integer . parseint ( tracktemp ) ; if ( trackint < 128 ) { bytes [ track_offset ] = ( byte ) trackint ; } else { bytes [ track_offset ] = ( byte ) ( trackint - 256 ) ; } } } }
te	4	public static void main ( string [ ] args ) { try { getconfig ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } java . awt . eventqueue . invokelater ( new runnable ( ) { public void run ( ) { try { substancelookandfeel laf = new substancemarinerlookandfeel ( ) ; uimanager . setlookandfeel ( laf ) ; string skinclassname = "org.pushingpixels.substance.api.skin." + skin + "skin" ; substancelookandfeel . setskin ( skinclassname ) ; jdialog . setdefaultlookandfeeldecorated ( true ) ; } catch ( unsupportedlookandfeelexception e ) { throw new runtimeexception ( e ) ; } } } ) ; java . awt . eventqueue . invokelater ( new runnable ( ) { @ suppresswarnings ( "static-access" ) public void run ( ) { frame = new mainframe ( ) ; frame . setdefaultcloseoperation ( jframe . exit_on_close ) ; frame . setvisible ( true ) ; try { @ suppresswarnings ( "resource" ) socket telnet = new socket ( phone . asteriskip , 5038 ) ; telnet . setkeepalive ( true ) ; telnetwriter = new printwriter ( telnet . getoutputstream ( ) ) ; telnetreader = new bufferedreader ( new inputstreamreader ( telnet . getinputstream ( ) ) ) ; telnetwriter . print ( "action: login\r\n" ) ; telnetwriter . print ( "username: " + phone . readuser + "\r\n" ) ; telnetwriter . print ( "secret: " + phone . readuserpassword + "\r\n\r\n" ) ; telnetwriter . flush ( ) ; } catch ( socketexception e1 ) { e1 . printstacktrace ( ) ; } catch ( ioexception e1 ) { e1 . printstacktrace ( ) ; } asteriskthread = new asteriskthread ( ) ; asteriskthread . start ( ) ; } } ) ; }
te	1	public void cancelbooking ( booking booking ) { booking . updatebedstatus ( bedstate . available ) ; dbsaverestore . updatebedstatus ( booking . getbeds ( ) ) ; hostel hostel = dbsaverestore . gethostelbyid ( booking . gethostelid ( ) ) ; date cancellationdeadline = addhours ( booking . getstartdate ( ) , - ( hostel . getpolicy ( ) . getcancellationdeadline ( ) ) ) ; date currentdate = new date ( ) ; integer cancellationcharges = 0 ; system . out . println ( "deadline " + cancellationdeadline + " startdate: " + booking . getstartdate ( ) + " current date " + currentdate ) ; if ( currentdate . after ( cancellationdeadline ) ) { cancellationcharges = ( booking . gettotalprice ( ) * hostel . getpolicy ( ) . getcancellationpenalty ( ) ) / 100 ; } booking . settotalprice ( cancellationcharges ) ; booking . setstate ( bookingstate . cancelled ) ; dbsaverestore . updatebooking ( booking ) ; dbsaverestore . deletebooking ( booking . getbookingid ( ) ) ; }
te	0	private string converttoformatstring ( string imagestring ) { string formatstring = imagestring ; formatstring = formatstring . replace ( "8(x 3a)" , " %3s %3s %3s %3s %3s %3s %3s %3s" ) ; formatstring = formatstring . replace ( "8x" , "        " ) ; formatstring = formatstring . replace ( "9x" , "         " ) ; formatstring = formatstring . replace ( "11x" , "           " ) ; formatstring = formatstring . replace ( "5d" , "%5s" ) ; formatstring = formatstring . replace ( "6a" , "%6s" ) ; formatstring = formatstring . replace ( "6d" , "%6s" ) ; formatstring = formatstring . replace ( "3d" , "%3s" ) ; formatstring = formatstring . replace ( "d" , "%1s" ) ; return formatstring ; }
te	5	public static void main ( string [ ] args ) { arraylist < integer > answers = new arraylist < integer > ( ) ; for ( int i = 1 ; answers . size ( ) < 124 ; i += 2 ) { int a = 1 ; int b = 1 ; int c = 1 ; boolean divisible = false ; for ( int n = 0 ; n < 1000000 && ! divisible ; n ++ ) { int temp = a + b + c ; temp %= i ; if ( temp == 0 ) divisible = true ; a = b ; b = c ; c = temp ; } if ( ! divisible ) answers . add ( i ) ; } system . out . print ( answers . get ( answers . size ( ) - 1 ) ) ; }
te	4	public static boolean endswithignorecase ( string str , string suffix ) { if ( str == null || suffix == null ) { return false ; } if ( str . endswith ( suffix ) ) { return true ; } if ( str . length ( ) < suffix . length ( ) ) { return false ; } string lcstr = str . substring ( str . length ( ) - suffix . length ( ) ) . tolowercase ( ) ; string lcsuffix = suffix . tolowercase ( ) ; return lcstr . equals ( lcsuffix ) ; }
te	8	@ override public void actionperformed ( actionevent e ) { final jtogglebutton sourcebtn = ( jtogglebutton ) e . getsource ( ) ; if ( sourcebtn . isselected ( ) ) { final string host = cbxcfgaddress . geteditor ( ) . getitem ( ) . tostring ( ) . trim ( ) ; final string port = cbxcfgport . geteditor ( ) . getitem ( ) . tostring ( ) . trim ( ) ; final string name = cbxcfgname . geteditor ( ) . getitem ( ) . tostring ( ) . trim ( ) ; confighistory . addentry ( host , port , name ) ; cbxcfgaddress . additem ( host ) ; cbxcfgport . additem ( port ) ; cbxcfgname . additem ( name ) ; try { final registry reg = locateregistry . getregistry ( host , integer . parseint ( port ) ) ; final servercontrol remotecontrol = ( servercontrol ) reg . lookup ( binding_id ) ; if ( name . equals ( "" ) ) { joptionpane . showmessagedialog ( connectiondialog . this , "please enter your name!" , "naming error" , joptionpane . error_message ) ; sourcebtn . setselected ( false ) ; } else if ( ! remotecontrol . isjoinable ( ) ) { joptionpane . showmessagedialog ( connectiondialog . this , "the selected server is busy!" , "network error" , joptionpane . error_message ) ; sourcebtn . setselected ( false ) ; } else if ( ! remotecontrol . register ( name ) ) { joptionpane . showmessagedialog ( connectiondialog . this , "please choose another name!" , "naming error" , joptionpane . error_message ) ; sourcebtn . setselected ( false ) ; } else { cbxcfgaddress . setenabled ( false ) ; cbxcfgname . setenabled ( false ) ; cbxcfgport . setenabled ( false ) ; lbltitle . settext ( "waiting for host..." ) ; target . setname ( name ) ; target . setcontroller ( remotecontrol ) ; registerthread = new thread ( new runnable ( ) { @ override public void run ( ) { try { while ( ! remotecontrol . isrunning ( ) ) { thread . sleep ( 500 ) ; } connectiondialog . this . dispose ( ) ; } catch ( interruptedexception | remoteexception e ) { try { remotecontrol . unregister ( name ) ; } catch ( exception e1 ) { } } } } ) ; registerthread . start ( ) ; } } catch ( remoteexception | notboundexception ex ) { joptionpane . showmessagedialog ( connectiondialog . this , "host cannot be found!" , "network error" , joptionpane . error_message ) ; sourcebtn . setselected ( false ) ; } } else { registerthread . interrupt ( ) ; cbxcfgaddress . setenabled ( true ) ; cbxcfgname . setenabled ( true ) ; cbxcfgport . setenabled ( true ) ; lbltitle . settext ( "connect to host..." ) ; } }
te	7	public static document deepclonedocument ( document doc , domimplementation impl ) { element root = doc . getdocumentelement ( ) ; document result = impl . createdocument ( root . getnamespaceuri ( ) , root . getnodename ( ) , null ) ; element rroot = result . getdocumentelement ( ) ; boolean before = true ; for ( node n = doc . getfirstchild ( ) ; n != null ; n = n . getnextsibling ( ) ) { if ( n == root ) { before = false ; if ( root . hasattributes ( ) ) { namednodemap attr = root . getattributes ( ) ; int len = attr . getlength ( ) ; for ( int i = 0 ; i < len ; i ++ ) { rroot . setattributenode ( ( attr ) result . importnode ( attr . item ( i ) , true ) ) ; } } for ( node c = root . getfirstchild ( ) ; c != null ; c = c . getnextsibling ( ) ) { rroot . appendchild ( result . importnode ( c , true ) ) ; } } else { if ( n . getnodetype ( ) != node . document_type_node ) { if ( before ) { result . insertbefore ( result . importnode ( n , true ) , rroot ) ; } else { result . appendchild ( result . importnode ( n , true ) ) ; } } } } return result ; }
te	5	private boolean complexstroke ( chinesestroke p ) { boolean b = false ; if ( p . size ( ) >= 2 ) { for ( int i = 0 ; i < ( p . size ( ) - 2 ) ; i ++ ) { chineseline cl1 = new chineseline ( p . get ( i ) [ 0 ] , p . get ( i + 1 ) [ 0 ] , p . get ( i + 1 ) [ 1 ] , p . get ( i ) [ 1 ] ) ; chineseline cl2 = new chineseline ( p . get ( i + 1 ) [ 0 ] , p . get ( i + 2 ) [ 0 ] , p . get ( i + 2 ) [ 1 ] , p . get ( i + 1 ) [ 1 ] ) ; if ( math . abs ( cl1 . totaldegrees - cl2 . totaldegrees ) > 70 && ( cl1 . totaldegrees > 80 || cl2 . totaldegrees > 80 ) ) { b = true ; } } } return b ; }
te	8	public void start ( ) { if ( this . isrunning || this . simulationresult != null ) { return ; } this . latch = new countdownlatch ( this . nrofworkers ) ; int roundsperworker = getnrofroundsperworker ( this . nrofworkers ) ; this . executor = executors . newfixedthreadpool ( this . nrofworkers ) ; int workerupdateinterval = getupdateinterval ( this . nrofworkers ) ; for ( int i = 0 ; i < this . nrofworkers ; i ++ ) { simulationworker worker ; workerbuilder builder ; if ( this . gametype == pokertype . texas_holdem ) { builder = texasholdemworker . builder ( ) ; } else if ( this . gametype == pokertype . omaha ) { builder = omahaworker . builder ( ) ; } else if ( this . gametype == pokertype . omaha_hilo ) { builder = omahahiloworker . builder ( ) ; } else if ( this . gametype == pokertype . fomaha ) { builder = fivecardomahaworker . builder ( ) ; } else { builder = fivecardomahahiloworker . builder ( ) ; } builder . setcommunitycards ( this . communitycards ) . setnotifier ( this ) . setrounds ( roundsperworker ) . setupdateinterval ( workerupdateinterval ) ; for ( playerprofile profile : this . profiles ) { builder . addplayer ( profile ) ; } worker = builder . build ( ) ; this . executor . execute ( worker ) ; this . workers . add ( worker ) ; } this . starttime = system . currenttimemillis ( ) ; this . isrunning = true ; thread masterthread = new thread ( new supervisor ( ) ) ; masterthread . setdaemon ( true ) ; masterthread . start ( ) ; simulationevent event = new simulationevent ( simulationevent . event_sim_started , this . nrofworkers ) ; this . notifiable . onsimulationstart ( event ) ; }
te	8	public arraylist < point > estimatelaunchpoint ( rectangle slingshot , point targetpoint ) { double scale = getscenescale ( slingshot ) ; point ref = getreferencepoint ( slingshot ) ; double x = ( targetpoint . x - ref . x ) / scale ; double y = - ( targetpoint . y - ref . y ) / scale ; double besterror = 1000 ; double theta1 = 0 ; double theta2 = 0 ; double v = _scalefactor * _launchvelocity [ 6 ] ; double v2 = v * v ; double v4 = v2 * v2 ; double tangent1 = ( v2 - math . sqrt ( v4 - ( x * x + 2 * y * v2 ) ) ) / x ; double tangent2 = ( v2 + math . sqrt ( v4 - ( x * x + 2 * y * v2 ) ) ) / x ; double t1 = actualtolaunch ( math . atan ( tangent1 ) ) ; double t2 = actualtolaunch ( math . atan ( tangent2 ) ) ; arraylist < point > pts = new arraylist < point > ( ) ; for ( double theta = t1 - bound ; theta <= t1 + bound ; theta += 0.001 ) { double velocity = getvelocity ( theta ) ; double u_x = velocity * math . cos ( theta ) ; double u_y = velocity * math . sin ( theta ) ; double a = - 0.5 / ( u_x * u_x ) ; double b = u_y / u_x ; double error = math . abs ( a * x * x + b * x - y ) ; if ( error < besterror ) { theta1 = theta ; besterror = error ; } } if ( besterror < 1000 ) { theta1 = actualtolaunch ( theta1 ) ; pts . add ( findreleasepoint ( slingshot , theta1 ) ) ; } besterror = 1000 ; for ( double theta = t2 - bound ; theta <= t2 + bound ; theta += 0.001 ) { double velocity = getvelocity ( theta ) ; double u_x = velocity * math . cos ( theta ) ; double u_y = velocity * math . sin ( theta ) ; double a = - 0.5 / ( u_x * u_x ) ; double b = u_y / u_x ; double error = math . abs ( a * x * x + b * x - y ) ; if ( error < besterror ) { theta2 = theta ; besterror = error ; } } theta2 = actualtolaunch ( theta2 ) ; if ( theta2 < math . toradians ( 75 ) && theta2 != theta1 && besterror < 1000 ) pts . add ( findreleasepoint ( slingshot , theta2 ) ) ; return pts ; }
te	4	public void execute ( ) { alive = true ; while ( alive ) { try { gamemanager . update ( ) ; if ( gamemanager . isswitchgame ( ) ) { final sharedgamedata gamedata = sharedgamedata . getinstance ( ) ; gamedata . levelup ( ) ; gamemanager = gamemanagerfactory . getnextgame ( ) ; gamemanager . init ( ) ; gamemanager . setswitchgame ( false ) ; gamemanager . changegamestate ( gamestate . initializing ) ; } if ( changedgame != null ) { changedgame . init ( ) ; gamemanager = changedgame ; changedgame = null ; } } catch ( final exception e ) { e . printstacktrace ( ) ; } } }
te	4	@ override public object getvalueat ( int rowindex , int columnindex ) { if ( columnindex == 0 ) { return paginas . get ( rowindex ) . getnombre ( ) ; } if ( columnindex == 1 ) { return paginas . get ( rowindex ) . getpeso ( ) ; } if ( columnindex == 2 ) { return paginas . get ( rowindex ) . getlineas ( ) ; } if ( columnindex == 3 ) { return paginas . get ( rowindex ) . getbody ( ) . replaceall ( "<[^>]*>" , "" ) ; } return null ; }
te	0	public agentmanager ( client client ) throws remoteexception { this . client = client ; this . timeout = new timerservice ( 13000 ) ; this . masteragentdelay = new timerservice ( 500 ) ; this . master = false ; this . agentsrunning = 0 ; this . deletionagentsrunning = 0 ; this . failureagentsrunning = 0 ; this . lockqueue = new arraylist < download > ( ) ; this . secondattemptlockqueue = new arraylist < download > ( ) ; this . unlockqueue = new arraylist < string > ( ) ; this . failednodequeue = new arraylist < string > ( ) ; this . deletefilequeue = new arraylist < string > ( ) ; timeout . getobserver ( ) . addobserver ( new observer ( ) { public void update ( observable source , object object ) { fileagenttimeout ( ) ; } } ) ; masteragentdelay . getobserver ( ) . addobserver ( new observer ( ) { public void update ( observable source , object object ) { fileagentsend ( bufferedfileagent ) ; } } ) ; }
te	0	@ test public void testrepetition ( ) throws exception { tester < repetition > tester = new tester < repetition > ( ) { @ override public repetition test ( abnfparser parser ) throws matchexception , ioexception { return parser . repetition ( ) ; } } ; assertion . assertmatch ( "b" , tester , new repetition ( new rulename ( "" , "b" ) ) , 2 , 1 ) ; assertion . assertmatch ( "1b" , tester , new repetition ( new repeat ( 1 , 1 ) , new rulename ( "" , "b" ) ) , 3 , 1 ) ; assertion . assertmatch ( "2*6b" , tester , new repetition ( new repeat ( 2 , 6 ) , new rulename ( "" , "b" ) ) , 5 , 1 ) ; assertion . assertmatch ( "3*b" , tester , new repetition ( new repeat ( 3 , 0 ) , new rulename ( "" , "b" ) ) , 4 , 1 ) ; assertion . assertmatch ( "*8b" , tester , new repetition ( new repeat ( 0 , 8 ) , new rulename ( "" , "b" ) ) , 4 , 1 ) ; assertion . assertmatch ( "*b" , tester , new repetition ( new repeat ( 0 , 0 ) , new rulename ( "" , "b" ) ) , 3 , 1 ) ; option option = abnfparser . newinstance ( "[b]" ) . option ( ) ; assertion . assertmatch ( "[b]" , tester , new repetition ( option ) , 4 , 1 ) ; assertion . assertmatch ( "1[b]" , tester , new repetition ( new repeat ( 1 , 1 ) , option ) , 5 , 1 ) ; assertion . assertmatch ( "2*6[b]" , tester , new repetition ( new repeat ( 2 , 6 ) , option ) , 7 , 1 ) ; assertion . assertmatch ( "3*[b]" , tester , new repetition ( new repeat ( 3 , 0 ) , option ) , 6 , 1 ) ; assertion . assertmatch ( "*8[b]" , tester , new repetition ( new repeat ( 0 , 8 ) , option ) , 6 , 1 ) ; assertion . assertmatch ( "*[b]" , tester , new repetition ( new repeat ( 0 , 0 ) , option ) , 5 , 1 ) ; group group = abnfparser . newinstance ( "(b)" ) . group ( ) ; assertion . assertmatch ( "(b)" , tester , new repetition ( group ) , 4 , 1 ) ; assertion . assertmatch ( "1(b)" , tester , new repetition ( new repeat ( 1 , 1 ) , group ) , 5 , 1 ) ; assertion . assertmatch ( "2*6(b)" , tester , new repetition ( new repeat ( 2 , 6 ) , group ) , 7 , 1 ) ; assertion . assertmatch ( "3*(b)" , tester , new repetition ( new repeat ( 3 , 0 ) , group ) , 6 , 1 ) ; assertion . assertmatch ( "*8(b)" , tester , new repetition ( new repeat ( 0 , 8 ) , group ) , 6 , 1 ) ; assertion . assertmatch ( "*(b)" , tester , new repetition ( new repeat ( 0 , 0 ) , group ) , 5 , 1 ) ; charval charval = abnfparser . newinstance ( "\"abc\"" ) . char_val ( ) ; assertion . assertmatch ( "\"abc\"" , tester , new repetition ( charval ) , 6 , 1 ) ; assertion . assertmatch ( "1\"abc\"" , tester , new repetition ( new repeat ( 1 , 1 ) , charval ) , 7 , 1 ) ; assertion . assertmatch ( "2*6\"abc\"" , tester , new repetition ( new repeat ( 2 , 6 ) , charval ) , 9 , 1 ) ; assertion . assertmatch ( "3*\"abc\"" , tester , new repetition ( new repeat ( 3 , 0 ) , charval ) , 8 , 1 ) ; assertion . assertmatch ( "*8\"abc\"" , tester , new repetition ( new repeat ( 0 , 8 ) , charval ) , 8 , 1 ) ; assertion . assertmatch ( "*\"abc\"" , tester , new repetition ( new repeat ( 0 , 0 ) , charval ) , 7 , 1 ) ; element numval = abnfparser . newinstance ( "%x00-ff" ) . num_val ( ) ; assertion . assertmatch ( "%x00-ff" , tester , new repetition ( numval ) , 8 , 1 ) ; assertion . assertmatch ( "1%x00-ff" , tester , new repetition ( new repeat ( 1 , 1 ) , numval ) , 9 , 1 ) ; assertion . assertmatch ( "2*6%x00-ff" , tester , new repetition ( new repeat ( 2 , 6 ) , numval ) , 11 , 1 ) ; assertion . assertmatch ( "3*%x00-ff" , tester , new repetition ( new repeat ( 3 , 0 ) , numval ) , 10 , 1 ) ; assertion . assertmatch ( "*8%x00-ff" , tester , new repetition ( new repeat ( 0 , 8 ) , numval ) , 10 , 1 ) ; assertion . assertmatch ( "*%x00-ff" , tester , new repetition ( new repeat ( 0 , 0 ) , numval ) , 9 , 1 ) ; proseval proseval = abnfparser . newinstance ( "<abc>" ) . prose_val ( ) ; assertion . assertmatch ( "<abc>" , tester , new repetition ( proseval ) , 6 , 1 ) ; assertion . assertmatch ( "1<abc>" , tester , new repetition ( new repeat ( 1 , 1 ) , proseval ) , 7 , 1 ) ; assertion . assertmatch ( "2*6<abc>" , tester , new repetition ( new repeat ( 2 , 6 ) , proseval ) , 9 , 1 ) ; assertion . assertmatch ( "3*<abc>" , tester , new repetition ( new repeat ( 3 , 0 ) , proseval ) , 8 , 1 ) ; assertion . assertmatch ( "*8<abc>" , tester , new repetition ( new repeat ( 0 , 8 ) , proseval ) , 8 , 1 ) ; assertion . assertmatch ( "*<abc>" , tester , new repetition ( new repeat ( 0 , 0 ) , proseval ) , 7 , 1 ) ; assertion . assertmatchexception ( "**" , tester , 2 , 1 ) ; assertion . assertmatchexception ( "1" , tester , 2 , 1 ) ; assertion . assertmatchexception ( "*1" , tester , 3 , 1 ) ; assertion . assertmatchexception ( "*(" , tester , 3 , 1 ) ; assertion . assertmatchexception ( "*[" , tester , 3 , 1 ) ; assertion . assertmatchexception ( "1*" , tester , 3 , 1 ) ; assertion . assertmatchexception ( "." , tester , 1 , 1 ) ; }
te	7	public void setselectedoc ( outputconnector selectedoc , component comp ) { if ( this . selectedoc != null ) this . selectedoc . setselected ( true ) ; this . selectedoc = selectedoc ; this . selectedoc . setselected ( true ) ; connectables = new arraylist < inputconnector > ( ) ; for ( component e : getelements ( ) ) { if ( e == comp ) continue ; if ( e instanceof inputstub ) continue ; for ( connector c : e . getconnectors ( ) ) { if ( c instanceof inputconnector ) if ( ! ( ( inputconnector ) c ) . isconnected ( ) ) connectables . add ( ( inputconnector ) c ) ; } } }
te	9	@ action public void addpuzles ( ) { constraintpuzzlecollectionpanel selectedpanel = sudokuapplication . getapplication ( ) . getapplicationview ( ) . getselectedcollectionpanel ( ) ; if ( selectedpanel == null ) { return ; } constraintpuzzlecollection selectedcollection = selectedpanel . getcollection ( ) ; if ( selectedcollection != null ) { int numberofpuzzlestoadd ; try { numberofpuzzlestoadd = integer . parseint ( numberofpuzzlestextfield . gettext ( ) ) ; } catch ( numberformatexception e ) { joptionpane . showmessagedialog ( this , "number of puzzles must be numeric." , "non-numeric data" , joptionpane . error_message ) ; numberofpuzzlestextfield . selectall ( ) ; numberofpuzzlestextfield . requestfocus ( ) ; return ; } int maximumnumberoffailuresinarow = 25 ; int numberofpuzzlesgenerated = 0 ; int numberofsuccessivefailures = 0 ; while ( numberofpuzzlesgenerated < numberofpuzzlestoadd ) { if ( numberofsuccessivefailures == maximumnumberoffailuresinarow ) { joptionpane . showmessagedialog ( this , "unable to generate puzzles." , "we've failed too much  man!" , joptionpane . error_message ) ; return ; } else { constraintpuzzle newpuzzlesolution = null ; try { newpuzzlesolution = ( constraintpuzzle ) selectedcollection . getpuzzleclass ( ) . newinstance ( ) ; } catch ( exception e ) { } newpuzzlesolution . setsize ( 9 ) ; newpuzzlesolution . setruleset ( selectedcollection . getruleset ( ) ) ; newpuzzlesolution . solvewithbacktracking ( true ) ; constraintpuzzle newpuzzle ; if ( difficultycombobox . getselecteditem ( ) . tostring ( ) . equals ( "easy" ) ) { newpuzzle = newpuzzlesolution . getnewstartstate ( difficulty . easy ) ; } else if ( difficultycombobox . getselecteditem ( ) . tostring ( ) . equals ( "medium" ) ) { newpuzzle = newpuzzlesolution . getnewstartstate ( difficulty . medium ) ; } else { newpuzzle = newpuzzlesolution . getnewstartstate ( difficulty . hard ) ; } if ( newpuzzle == null ) { numberofsuccessivefailures ++ ; system . out . println ( "failed." ) ; } else { numberofpuzzlesgenerated ++ ; selectedcollection . addpuzzle ( newpuzzle ) ; numberofsuccessivefailures = 0 ; } } } selectedpanel . syncpanels ( ) ; selectedpanel . repaint ( ) ; sudokuapplication . getapplication ( ) . getapplicationview ( ) . saveselectedpuzzlecollection ( ) ; close ( ) ; } else { system . out . println ( "gui error: addpuzzlesdialog" ) ; } }
te	1	private void initui ( ) { setdefaultcloseoperation ( exit_on_close ) ; settitle ( "exit kiosk" ) ; topmessagelabel = new jlabel ( "enter ticket num or license plate" , swingconstants . center ) ; messagelabel = new jlabel ( "" , swingconstants . center ) ; enterticketfield = new jformattedtextfield ( numberformat . getintegerinstance ( ) ) ; enterticketfield . setfocuslostbehavior ( jformattedtextfield . persist ) ; enterticketfield . setactioncommand ( "ticketfield" ) ; enterticketfield . settext ( "1" ) ; try { enterticketfield . commitedit ( ) ; } catch ( parseexception e ) { e . printstacktrace ( ) ; } licenseplatefield = new jformattedtextfield ( createformatter ( "uu-uuu-###" ) ) ; licenseplatefield . setfocuslostbehavior ( jformattedtextfield . commit_or_revert ) ; licenseplatefield . setactioncommand ( "licensefield" ) ; licenseplatefield . settext ( "co-aaa-111" ) ; licenseplatefield . addfocuslistener ( new focuslistener ( ) { @ override public void focusgained ( focusevent e ) { licenseplatefield . settext ( "" ) ; } @ override public void focuslost ( focusevent e ) { } } ) ; lostticketbutton = new jbutton ( "lost ticket" ) ; lostticketbutton . setactioncommand ( "lostticket" ) ; paymentmessagelabel = new jlabel ( "" , swingconstants . center ) ; selectpaymentmessagelabel = new jlabel ( "enter cc or select payment type" , swingconstants . center ) ; creditcardfield = new jformattedtextfield ( createformatter ( "#### #### #### ####" ) ) ; creditcardfield . setfocuslostbehavior ( jformattedtextfield . commit_or_revert ) ; creditcardfield . setactioncommand ( "paycreditcard" ) ; creditcardfield . settext ( "1111 1111 1111 11111" ) ; creditcardfield . addfocuslistener ( new focuslistener ( ) { @ override public void focusgained ( focusevent e ) { creditcardfield . settext ( "" ) ; } @ override public void focuslost ( focusevent e ) { } } ) ; paycashbutton = new jbutton ( "pay by cash" ) ; paycashbutton . setactioncommand ( "paycash" ) ; payonaccountbutton = new jbutton ( "pay on account" ) ; payonaccountbutton . setactioncommand ( "payonaccount" ) ; gatestatuslabel = new jlabel ( "gate is closed" , swingconstants . center ) ; jpanel pane = new jpanel ( new gridlayout ( 11 , 1 ) ) ; pane . add ( topmessagelabel ) ; pane . add ( enterticketfield ) ; pane . add ( licenseplatefield ) ; pane . add ( lostticketbutton ) ; pane . add ( messagelabel ) ; pane . add ( paymentmessagelabel ) ; pane . add ( selectpaymentmessagelabel ) ; pane . add ( creditcardfield ) ; pane . add ( payonaccountbutton ) ; pane . add ( paycashbutton ) ; pane . add ( gatestatuslabel ) ; pane . setborder ( borderfactory . createemptyborder ( 30 , 30 , 10 , 30 ) ) ; getcontentpane ( ) . add ( pane , borderlayout . center ) ; pack ( ) ; setlocation ( 615 , 150 ) ; setvisible ( true ) ; }
te	6	private int [ ] gettoken ( string line , int startingpoint ) { int [ ] ret = new int [ 3 ] ; if ( splitter != null ) { int nextsplit = line . indexof ( splitter , startingpoint ) ; ret [ 0 ] = startingpoint ; ret [ 1 ] = nextsplit >= 0 ? nextsplit : line . length ( ) ; ret [ 2 ] = nextsplit >= 0 ? nextsplit + splitter . length ( ) : line . length ( ) - 1 ; } else { int startbeginner = line . indexof ( fieldstarter , startingpoint ) ; ret [ 0 ] = startbeginner >= 0 ? startbeginner + fieldstarter . length ( ) : line . length ( ) ; int startender = line . indexof ( fieldstopper , ret [ 0 ] ) ; ret [ 1 ] = startender >= 0 ? startender : line . length ( ) - 1 ; ret [ 2 ] = startender >= 0 ? startender + fieldstopper . length ( ) : line . length ( ) - 1 ; } return ret ; }
te	0	public patchcafilterdemo ( ) { super ( "patchca demo" ) ; setsize ( 200 , 140 ) ; dimension dim = toolkit . getdefaulttoolkit ( ) . getscreensize ( ) ; int x = ( dim . width - this . getsize ( ) . width ) / 2 ; int y = ( dim . height - this . getsize ( ) . height ) / 2 ; setlocation ( x , y ) ; panel bottom = new panel ( ) ; reloadbutton = new button ( "next filter" ) ; reloadbutton . addactionlistener ( this ) ; bottom . add ( reloadbutton ) ; add ( borderlayout . south , bottom ) ; addwindowlistener ( new windowadapter ( ) { public void windowclosing ( windowevent we ) { dispose ( ) ; } } ) ; }
te	6	public static typedobject parseobject ( string type , string value ) throws classnotfoundexception , nosuchmethodexception , illegalaccessexception , invocationtargetexception { if ( type . equals ( "int" ) ) { return new typedobject ( integer . class , integer . parseint ( value ) ) ; } if ( type . equals ( "float" ) ) { return new typedobject ( float . class , float . parsefloat ( value ) ) ; } if ( type . equals ( "long" ) ) { return new typedobject ( long . class , long . parselong ( value ) ) ; } if ( type . equals ( "double" ) ) { return new typedobject ( double . class , double . parsedouble ( value ) ) ; } if ( type . equals ( "boolean" ) ) { return new typedobject ( boolean . class , boolean . valueof ( value ) ) ; } type = canonicalize ( type ) ; class c = class . forname ( type ) ; method m = null ; try { m = c . getmethod ( "valueof" , string . class ) ; } catch ( nosuchmethodexception e ) { return new typedobject ( string . class , value ) ; } return new typedobject ( c , m . invoke ( null , value ) ) ; }
te	2	public void generate ( ) { if ( generated ) { system . err . println ( "world " + worldname + " is already generated!" ) ; return ; } if ( loadfromfile ) { system . err . println ( "world " + worldname + " loads from a file!" ) ; return ; } tileset = perlin . getnoise ( rand , gettilewidth ( ) , gettileheight ( ) , ( byte ) 4 ) ; tileset = perlin . roundnoise ( tileset , ( byte ) 2 ) ; worldutil . parseperlintotiles ( this , tileset , true ) ; fillstructlist ( ) ; generated = true ; }
te	4	@ override public void collidedwith ( entity other ) { if ( other instanceof unbreakableentity ) { sethorizontalspeedmovement ( 0 ) ; setverticalspeedmovement ( 0 ) ; } else if ( other instanceof breakableentity ) { sethorizontalspeedmovement ( 0 ) ; setverticalspeedmovement ( 0 ) ; } else if ( other instanceof bombeentity ) { sethorizontalspeedmovement ( 0 ) ; setverticalspeedmovement ( 0 ) ; } else if ( other instanceof explosionentity ) { this . state = state . dead ; } else { this . sethorizontalspeedmovement ( 1 ) ; this . setverticalspeedmovement ( 1 ) ; } }
te	2	public node connectionmix ( ) { connection newconnection = new connection ( ) ; connection onec = ( connection ) one ; connection twoc = ( connection ) two ; random random = new random ( ) ; newconnection . setgiveneuron ( onec . getgiveneuron ( ) ) ; newconnection . setrecieveneuron ( onec . getrecieveneuron ( ) ) ; newconnection . setinnovationnum ( onec . getinnovationnum ( ) ) ; double test = random . nextdouble ( ) ; if ( test > .5 ) newconnection . setactive ( onec . getactive ( ) ) ; else newconnection . setactive ( twoc . getactive ( ) ) ; test = random . nextdouble ( ) ; if ( test > .5 ) newconnection . setweight ( onec . getweight ( ) ) ; else newconnection . setweight ( twoc . getweight ( ) ) ; return newconnection ; }
te	9	public set < string > getcommonstructures ( dataholder dataholderhandler ) { set < string > pstags = new hashset < string > ( arrays . aslist ( "s p" . split ( " " ) ) ) ; set < string > btags = new hashset < string > ( ) ; btags . add ( "b" ) ; set < string > pswords = dataholderhandler . getwordsfromwordposbyposs ( pstags ) ; set < string > bwords = dataholderhandler . getwordsfromwordposbyposs ( btags ) ; set < string > allstructures = stringutility . setsubtraction ( pswords , bwords ) ; set < string > commontags = new hashset < string > ( ) ; map < string , set < string >> tagtomodifiers = new hashmap < string , set < string >> ( ) ; for ( sentencestructure sentenceitem : dataholderhandler . getsentenceholder ( ) ) { string tag = sentenceitem . gettag ( ) ; string modifier = sentenceitem . getmodifier ( ) ; boolean c1 = stringutils . equals ( tag , "ignore" ) ; boolean c2 = ( tag == null ) ; boolean c3 = stringutility . ismatchednullsafe ( tag , " " ) ; boolean c4 = stringutility . ismatchednullsafe ( tag , "\\[" ) ; if ( ( ! c1 || c2 ) && ! c3 && ! c4 ) { if ( allstructures . contains ( modifier ) ) { if ( tagtomodifiers . containskey ( tag ) ) { tagtomodifiers . get ( tag ) . add ( modifier ) ; } else { hashset < string > modifiers = new hashset < string > ( ) ; modifiers . add ( modifier ) ; tagtomodifiers . put ( tag , modifiers ) ; } } } } iterator < string > iter = tagtomodifiers . keyset ( ) . iterator ( ) ; while ( iter . hasnext ( ) ) { string key = iter . next ( ) ; if ( tagtomodifiers . get ( key ) . size ( ) > 1 ) { string commontag = new string ( key ) ; commontag = commontag . replaceall ( "\\|+" , "\\|" ) ; commontag = commontag . replaceall ( "\\|+$" , "" ) ; commontags . add ( key ) ; } } return commontags ; }
te	1	private void createfilemenu ( final resourcebundle nls ) { if ( ! ostype . macos . equals ( ostype ) ) { final jmenu menu = new jmenu ( nls . getstring ( "main.menu.file" ) ) ; final jmenuitem exit = new jmenuitem ( nls . getstring ( "main.menu.file.exit" ) ) ; exit . setaccelerator ( getkeystroke ( keyevent . vk_q , inputevent . ctrl_mask ) ) ; exit . addactionlistener ( exit_action . create ( tuple . of ( menu , nls ) ) ) ; menu . add ( exit ) ; add ( menu ) ; } }
te	3	public routepath ( string inline , hashmap < string , trip > tripmap ) { mid = snextid ; snextid ++ ; sroutepathmap . put ( mid , this ) ; mpath = new arraylist < > ( ) ; string [ ] f = csvparser . parseline ( inline ) ; for ( string s : f ) { s = s . replaceall ( "\"" , "" ) ; if ( tripmap . get ( s ) != null ) { mpath . add ( tripmap . get ( s ) ) ; } } if ( mpath . size ( ) > 0 ) { mroute = mpath . get ( 0 ) . getroute ( ) ; } else { mroute = null ; } mstarttimecode = - 1 ; mendtimecode = integer . min_value ; buildstoplist ( ) ; }
te	5	@ override public string buildresponse ( responsetemplate template , keywordlist keys ) { random rand = new random ( ) ; string response = "" ; for ( int i = 0 ; i < template . response . length ; i ++ ) { response += template . response [ i ] ; if ( template . wordbuckets != null && i < template . wordbuckets . length ) { int select ; if ( template . wordbuckets [ i ] . length != 1 ) select = rand . nextint ( template . wordbuckets [ i ] . length - 1 ) ; else select = 0 ; if ( frommemory ( template . wordbuckets [ i ] [ select ] ) ) { string mem = template . wordbuckets [ i ] [ select ] . substring ( 1 ) ; response += memtable . get ( mem ) ; } else { response += template . wordbuckets [ i ] [ select ] ; } } } return response ; }
te	7	public splitsample < t > contains ( set < integer > ids , boolean negate ) { listsample < t > result = new listsample < t > ( ) ; for ( t item : this ) { integer id = membership . get ( item . identifier ( ) ) ; if ( id == null ) { if ( ids . contains ( splitsample . undefined ) ) result . add ( item ) ; } else if ( ( ! negate && ids . contains ( id ) ) || ( negate && ! ids . contains ( id ) ) ) result . add ( item ) ; } return result ; }
te	5	private static string decimaltobinary ( double d ) { if ( d >= 1 || d <= 0 ) { return "error" ; } stringbuilder result = new stringbuilder ( "0." ) ; while ( d > 0 ) { if ( result . length ( ) > 32 ) { return "error" ; } double multiplied = d * 2 ; if ( multiplied >= 1 ) { result . append ( "1" ) ; d = multiplied - 1 ; } else { result . append ( "0" ) ; d = multiplied ; } } return result . tostring ( ) ; }
te	1	public void handleuserlist ( message m ) throws jmsexception { assert ( m instanceof objectmessage ) ; userlistmessage u = ( userlistmessage ) ( ( objectmessage ) m ) . getobject ( ) ; objectmessage msg = session . createobjectmessage ( ) ; system . out . println ( "---server receive userlist object---" ) ; system . out . println ( "id: " + u . getclient ( ) . getid ( ) ) ; userlistmessage list = new userlistmessage ( u . getclient ( ) ) ; list < clientinfo > clients = registry . getonlineclients ( ) ; list < string > users = new arraylist < string > ( ) ; for ( clientinfo id : clients ) { users . add ( id . getusername ( ) ) ; } list . setonlineusers ( users ) ; msg . setobject ( list ) ; msg . setjmscorrelationid ( m . getjmscorrelationid ( ) ) ; replyproducer . send ( m . getjmsreplyto ( ) , msg ) ; }
te	3	private void checkhorizontalscrollbar ( basiccombopopup popup ) { jviewport viewport = scrollpane . getviewport ( ) ; point p = viewport . getviewposition ( ) ; p . x = 0 ; viewport . setviewposition ( p ) ; if ( ! scrollbarrequired ) { scrollpane . sethorizontalscrollbar ( null ) ; return ; } jscrollbar horizontal = scrollpane . gethorizontalscrollbar ( ) ; if ( horizontal == null ) { horizontal = new jscrollbar ( jscrollbar . horizontal ) ; scrollpane . sethorizontalscrollbar ( horizontal ) ; scrollpane . sethorizontalscrollbarpolicy ( jscrollpane . horizontal_scrollbar_as_needed ) ; } if ( horizontalscrollbarwillbevisible ( popup , scrollpane ) ) { dimension scrollpanesize = scrollpane . getpreferredsize ( ) ; scrollpanesize . height += horizontal . getpreferredsize ( ) . height ; scrollpane . setpreferredsize ( scrollpanesize ) ; scrollpane . setmaximumsize ( scrollpanesize ) ; scrollpane . revalidate ( ) ; } }
te	4	private void processnode ( ) { edge minedge = null ; int mindijkstracriterion = integer . max_value ; set < edge > frontieredges = getfrontieredges ( ) ; if ( frontieredges . isempty ( ) ) { nofrontieredges = true ; return ; } for ( edge edge : frontieredges ) { int dijkstragreedycriterion = dijkstragreedycriterion ( edge ) ; if ( dijkstragreedycriterion < mindijkstracriterion ) { mindijkstracriterion = dijkstragreedycriterion ; minedge = edge ; } } assert minedge != null : "no edges to remaining nodes" ; node processednode = null ; if ( ! minedge . gettargetnode ( ) . isexplored ( ) ) { processednode = minedge . gettargetnode ( ) ; } else { processednode = minedge . getsourcenode ( ) ; } markprocessed ( processednode ) ; shortestpathlengths . put ( processednode , mindijkstracriterion ) ; }
te	1	public optionspanel ( hashmap < string , string > text , string [ ] answers , string [ ] values ) { media = null ; this . setlayout ( new borderlayout ( ) ) ; optionslabel = new jlabel ( text . get ( "frage" ) ) ; optionslabel . sethorizontalalignment ( swingconstants . center ) ; optionslabel . setfont ( new font ( "arial" , font . plain , 20 ) ) ; double [ ] val = new double [ values . length ] ; for ( int i = 0 ; i < val . length ; i ++ ) { val [ i ] = double . parsedouble ( values [ i ] ) ; } pnlsort = new sortpaneloptions ( answers , val ) ; this . add ( borderlayout . north , optionslabel ) ; this . add ( borderlayout . center , pnlsort ) ; }
te	2	private void appendexception ( throwable e , stringbuilder sb ) { sb . append ( "    exception: " ) ; sb . append ( e . tostring ( ) ) ; sb . append ( endline ) ; sb . append ( "    stack trace:" + endline ) ; stacktraceelement [ ] stkelements = e . getstacktrace ( ) ; for ( stacktraceelement stkframe : stkelements ) { sb . append ( "        in " + stkframe . getclassname ( ) + "." + stkframe . getmethodname ( ) + " " ) ; sb . append ( "at " + stkframe . getfilename ( ) + ":" + stkframe . getlinenumber ( ) ) ; sb . append ( endline ) ; } if ( e . getcause ( ) != null ) { appendexception ( e . getcause ( ) , sb ) ; } }
te	9	public byte compose8bit ( int t ) { byte rtn = ( byte ) 0 ; switch ( bitnumber ) { case 0 : rtn = ( byte ) ( ( ( t >> 5 & t ) - ( t >> 5 ) + ( t >> 5 & t ) ) + ( t * ( ( t >> 14 ) & 14 ) ) ) ; break ; case 1 : rtn = ( byte ) ( ( t >> 5 ) | ( t << 4 ) | ( ( t & 1023 ) ^ 1981 ) | ( ( t - 67 ) >> 4 ) ) ; break ; case 2 : rtn = ( byte ) ( ( ( t * ( t >> 8 | t >> 9 ) & 46 & t >> 8 ) ) ^ ( t & t >> 13 | t >> 6 ) ) ; break ; case 3 : rtn = ( byte ) ( ( t >> ( t & 7 ) ) | ( t << ( t & 42 ) ) | ( t >> 7 ) | ( t << 5 ) ) ; break ; case 4 : rtn = ( byte ) ( ( t >> 6 | t << 1 ) + ( t >> 5 | t << 3 | t >> 3 ) | t >> 2 | t << 1 ) ; break ; case 5 : rtn = ( byte ) ( ( t >> 6 | t | t >> ( t >> 16 ) ) * 10 + ( ( t >> 11 ) & 7 ) ) ; break ; case 6 : rtn = ( byte ) ( ( t / 8 ) >> ( t >> 9 ) * t / ( ( t >> 14 & 3 ) + 4 ) ) ; break ; case 7 : rtn = ( byte ) ( t * ( 42 & t >> 10 ) ) ; break ; case 8 : rtn = ( byte ) ( ( t * t * t / t ) % 123 ) ; break ; default : rtn = ( byte ) ( ( t * t * t * t ) % 123 ) ; break ; } return rtn ; }
te	0	public queuerow ( int opcode , boolean shouldshowoperandfield ) { this . opcode = opcode ; setforeground ( color . gray ) ; setborder ( new lineborder ( new color ( 0 , 0 , 0 ) ) ) ; setpreferredsize ( new dimension ( 258 , 28 ) ) ; setmaximumsize ( new dimension ( 32767 , 30 ) ) ; setlayout ( new boxlayout ( this , boxlayout . x_axis ) ) ; cmdnamelabel = new jlabel ( "" ) ; add ( cmdnamelabel ) ; horizontalglue = box . createhorizontalglue ( ) ; add ( horizontalglue ) ; operandfield = new jformattedtextfield ( numberformat . getnumberinstance ( ) ) ; operandfield . setvalue ( 0 ) ; operandfield . setpreferredsize ( new dimension ( 60 , 22 ) ) ; operandfield . setmaximumsize ( new dimension ( 60 , 2147483647 ) ) ; operandfield . setvisible ( shouldshowoperandfield ) ; add ( operandfield ) ; horizontalstrut = box . createhorizontalstrut ( 20 ) ; horizontalstrut . setpreferredsize ( new dimension ( 13 , 0 ) ) ; horizontalstrut . setminimumsize ( new dimension ( 13 , 0 ) ) ; horizontalstrut . setmaximumsize ( new dimension ( 13 , 32767 ) ) ; add ( horizontalstrut ) ; moveupbtn = new jbutton ( "\u25b2" ) ; add ( moveupbtn ) ; movedownbtn = new jbutton ( "\u25bc" ) ; add ( movedownbtn ) ; removebtn = new jbutton ( "remove" ) ; add ( removebtn ) ; }
