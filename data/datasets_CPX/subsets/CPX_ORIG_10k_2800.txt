tr	3	public double [ ] Z ( double [ ] [ ] M , double [ ] xM ) { int m1rows = M . length ; int m1cols = M [ 0 ] . length ; double [ ] result = new double [ m1rows ] ; for ( int i = 0 ; i < m1rows ; i ++ ) { double _max = - double . MAX_VALUE ; for ( int k = 0 ; k < m1cols ; k ++ ) { double b = B ( M [ i ] [ k ] , xM [ k ] ) ; _max = b > _max ? b : _max ; } result [ i ] = _max ; } return result ; }
tr	6	private Vector reOrder ( Vector list ) { Vector newList = new Vector ( ) ; if ( list . size ( ) == 0 ) { return newList ; } int previousMsgId = 0 ; int largestGap = 0 ; int largestGapMsgIdPosInList = 0 ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { int currentMsgId = ( ( MqttWireMessage ) list . elementAt ( i ) ) . getMessageId ( ) ; if ( currentMsgId - previousMsgId > largestGap ) { largestGap = currentMsgId - previousMsgId ; largestGapMsgIdPosInList = i ; } previousMsgId = currentMsgId ; } int lowestMsgId = ( ( MqttWireMessage ) list . elementAt ( 0 ) ) . getMessageId ( ) ; int highestMsgId = previousMsgId ; if ( MAX_MSG_ID - highestMsgId + lowestMsgId > largestGap ) { largestGapMsgIdPosInList = 0 ; } for ( int i = largestGapMsgIdPosInList ; i < list . size ( ) ; i ++ ) { newList . addElement ( list . elementAt ( i ) ) ; } for ( int i = 0 ; i < largestGapMsgIdPosInList ; i ++ ) { newList . addElement ( list . elementAt ( i ) ) ; } return newList ; }
tr	2	@ Override public boolean equals ( Object other ) { if ( other instanceof Entity ) { return originalObject . getId ( ) == ( ( Entity ) other ) . getObject ( ) . getId ( ) && originalObject . getClass ( ) . equals ( ( ( Entity ) other ) . getObject ( ) . getClass ( ) ) ; } else { return false ; } }
tr	4	public void testIsWinner ( ) { beginTest ( "countFields method" ) ; boolean result ; for ( int i = 0 ; i < 31 ; i ++ ) { board . setField ( i , Mark . RED ) ; } for ( int i = 32 ; i < 63 ; i ++ ) { board . setField ( i , Mark . GREEN ) ; } result = board . isWinner ( Mark . RED ) ; assertEquals ( "isWinner(Mark.RED) on starting board" , false , result ) ; setUp ( ) ; for ( int i = 0 ; i < 32 ; i ++ ) { board . setField ( i , Mark . RED ) ; } for ( int i = 33 ; i < 63 ; i ++ ) { board . setField ( i , Mark . GREEN ) ; } result = board . isWinner ( Mark . RED ) ; assertEquals ( "isWinner(Mark.RED) on starting board" , true , result ) ; }
tr	3	public AbstractItem ( ItemConfiguration config , String key , String [ ] sval , int [ ] ival , Triplet [ ] tval ) { this . key = key ; strings = new String [ config . stringLabels . length ] ; ints = new int [ config . intLabels . length ] ; triplets = new Triplet [ config . tripletLabels . length ] ; for ( int i = 0 ; i < strings . length ; i ++ ) { strings [ i ] = sval [ i ] ; } for ( int i = 0 ; i < ints . length ; i ++ ) { ints [ i ] = ival [ i ] ; } for ( int i = 0 ; i < triplets . length ; i ++ ) { triplets [ i ] = tval [ i ] ; } }
tr	3	public String look ( ) { StringBuffer names = new StringBuffer ( ) ; String items = currRoom . getItemNames ( ) ; String monsters = currRoom . getMonsterNames ( ) ; if ( ! items . equals ( "" ) ) { names . append ( "Items: " ) ; names . append ( items ) ; } if ( ! monsters . equals ( "" ) ) { if ( ! ( names . length ( ) == 0 ) ) { names . append ( "\n" ) ; } names . append ( "Monsters: " ) ; names . append ( monsters ) ; } return names . toString ( ) ; }
tr	3	public void requestShiftRight ( ) { boolean continueToMakeNew = true ; if ( ! saved ) { continueToMakeNew = promptToSaveState ( ) ; } if ( continueToMakeNew ) { continueToMakeNew = promptShiftRight ( ) ; if ( continueToMakeNew ) { } } }
tr	0	public double getFear ( ) { return fear ; }
tr	6	public String getNodeValue ( ) throws DOMException { String value = "" ; if ( adaptee . type == Node . TextNode || adaptee . type == Node . CDATATag || adaptee . type == Node . CommentTag || adaptee . type == Node . ProcInsTag ) { if ( adaptee . textarray != null && adaptee . start < adaptee . end ) { value = Lexer . getString ( adaptee . textarray , adaptee . start , adaptee . end - adaptee . start ) ; } } return value ; }
tr	1	public ArrayList < String > getDependencies ( ) { ArrayList < String > dep = new ArrayList < String > ( ) ; for ( JsonValue v : object . get ( "dependencies" ) . asArray ( ) . values ( ) ) dep . add ( v . asString ( ) ) ; return dep ; }
tr	0	public String getImage0 ( ) { return image0 ; }
tr	7	private void computerNextTurn ( ) { if ( ! getGame ( ) . gameWon ( ) ) { new Thread ( new Runnable ( ) { public void run ( ) { try { Thread . sleep ( ANIMATION_TIME ) ; } catch ( Exception e ) { } if ( ! getGame ( ) . getPlayer ( getGame ( ) . getPlayerTurn ( ) % TOTAL_PLAYERS ) . getPlayerType ( ) . equals ( "Human" ) ) { int playerTurn = getGame ( ) . getPlayerTurn ( ) ; int x ; if ( ( getGame ( ) . getPlayerTurn ( ) % TOTAL_PLAYERS == PLAYER_ONE && m_playerOneType == "Computer: Easy" ) || ( getGame ( ) . getPlayerTurn ( ) % TOTAL_PLAYERS == PLAYER_TWO && m_playerTwoType == "Computer: Easy" ) ) { ConnectFourEasyComputerPlayer player = ( ConnectFourEasyComputerPlayer ) getGame ( ) . getPlayer ( playerTurn % TOTAL_PLAYERS ) ; x = ( int ) player . makeAIMove ( getGame ( ) . getBoard ( ) ) . getX ( ) ; } else { ConnectFourHardComputerPlayer player = ( ConnectFourHardComputerPlayer ) getGame ( ) . getPlayer ( playerTurn % TOTAL_PLAYERS ) ; x = ( int ) player . makeAIMove ( getGame ( ) . getBoard ( ) ) . getX ( ) ; } performMove ( x ) ; getGame ( ) . incrementTurn ( ) ; } } } ) . start ( ) ; } }
tr	7	private void menuCharacterActionPerformed ( java . awt . event . ActionEvent evt ) { if ( ! menuCharacter . isSelected ( ) ) return ; int [ ] selectedCols = getSelectedColumns ( ) ; if ( selectedCols . length == 0 ) throw new IllegalArgumentException ( "Empty column selection." ) ; boolean areColumnContertible = true ; for ( int i = 0 ; i < selectedCols . length ; i ++ ) if ( table . getColumnType ( selectedCols [ i ] ) != DataTypes . CHARACTER ) areColumnContertible &= table . isColumnConvertible ( selectedCols [ i ] , DataTypes . CHARACTER ) ; if ( ! areColumnContertible ) { int result = JOptionPane . showConfirmDialog ( this , "Data loss will occur " + "upon convertion. \nDo you want to force convertion  " , "Data integrity" , JOptionPane . YES_NO_OPTION , JOptionPane . WARNING_MESSAGE ) ; if ( result == JOptionPane . NO_OPTION ) return ; } for ( int i = 0 ; i < selectedCols . length ; i ++ ) table . convertColumn ( selectedCols [ i ] , DataTypes . CHARACTER ) ; listColumns . updateUI ( ) ; scrollPane . updateUI ( ) ; }
tr	4	public int numTrees2 ( int n ) { if ( n == 0 || n == 1 ) return 1 ; int [ ] num = new int [ n + 1 ] ; num [ 0 ] = 1 ; num [ 1 ] = 1 ; num [ 2 ] = 2 ; for ( int i = 3 ; i <= n ; i ++ ) { int cnt = 0 ; for ( int j = 1 ; j <= i ; j ++ ) { int left = j - 1 ; int right = i - j ; cnt += num [ left ] * num [ right ] ; } num [ i ] = cnt ; } return num [ n ] ; }
tr	1	@ Override public T pop ( ) { if ( isEmpty ( ) ) throw new EmptyStackException ( ) ; top -- ; return dElements [ top ] ; }
tr	3	public T build ( boolean ... doNotPersist ) { T product = assembleProduct ( ) ; if ( ArrayUtils . isEmpty ( doNotPersist ) || ( ArrayUtils . isNotEmpty ( doNotPersist ) && doNotPersist [ 0 ] == boolean . false ) ) { sf . getCurrentSession ( ) . persist ( product ) ; } T temp = product ; initProduct ( ) ; return temp ; }
tr	7	public void updateItem ( HttpServletRequest arequest ) throws Exception { for ( int idx = this . getCount ( ) - 1 ; idx >= 0 ; idx -- ) { CNonadItem myitem = ( CNonadItem ) this . getItem ( idx ) ; String datid = "Ndate" + myitem . nonadmid ; String serid = "NonSeries" + myitem . nonadmid ; String reaid = "NonReason" + myitem . nonadmid ; String nyrsid = "Nyrs" + myitem . nonadmid ; String nmosid = "Nmos" + myitem . nonadmid ; String nwksid = "Nwks" + myitem . nonadmid ; String ndaysid = "Ndys" + myitem . nonadmid ; String datstr = CParser . truncStr ( arequest . getParameter ( datid ) , CAppConsts . MaxLenDate ) ; if ( datstr == null || datstr . length ( ) == 0 ) { this . delItem ( idx ) ; continue ; } String serstr = arequest . getParameter ( serid ) ; String reastr = arequest . getParameter ( reaid ) ; myitem . setNonadmDate ( datstr ) ; myitem . seriescd = serstr ; myitem . reasoncd = reastr ; myitem . nageyears = getIntVal ( arequest . getParameter ( nyrsid ) ) ; myitem . nagemonths = getIntVal ( arequest . getParameter ( nmosid ) ) ; myitem . nageweeks = getIntVal ( arequest . getParameter ( nwksid ) ) ; myitem . nagedays = getIntVal ( arequest . getParameter ( ndaysid ) ) ; } int nslot = ( this . getCount ( ) == 0 ) ? 2 : 1 ; for ( int idx = 0 ; idx < nslot ; idx ++ ) { CNonadItem myitem = new CNonadItem ( ) ; String myid = "New" + Integer . toString ( idx ) ; String datid = "Ndate" + myid ; String serid = "NonSeries" + myid ; String reaid = "NonReason" + myid ; String nyrsid = "Nyrs" + myid ; String nmosid = "Nmos" + myid ; String nwksid = "Nwks" + myid ; String ndaysid = "Ndys" + myid ; String datstr = CParser . truncStr ( arequest . getParameter ( datid ) , CAppConsts . MaxLenDate ) ; if ( datstr == null || datstr . length ( ) == 0 ) continue ; String serstr = arequest . getParameter ( serid ) ; String reastr = arequest . getParameter ( reaid ) ; myitem . nonadmid = this . makeNewId ( "nad" , 6 ) ; myitem . setNonadmDate ( datstr ) ; myitem . seriescd = serstr ; myitem . reasoncd = reastr ; myitem . nageyears = getIntVal ( arequest . getParameter ( nyrsid ) ) ; myitem . nagemonths = getIntVal ( arequest . getParameter ( nmosid ) ) ; myitem . nageweeks = getIntVal ( arequest . getParameter ( nwksid ) ) ; myitem . nagedays = getIntVal ( arequest . getParameter ( ndaysid ) ) ; this . addItem ( myitem . nonadmid , myitem ) ; } }
tr	8	@ Override public void work ( RootNode root ) throws OptimizerException { final int blockSize = root . - . size ( ) ; int nodeNo = 0 ; List < Node > newProgram = new ArrayList < > ( ) ; try { while ( nodeNo < blockSize ) { savedMem = interpreter . getMemory ( ) ; savedPointer = interpreter . getPointer ( ) ; interpreter . visit ( root . - . get ( nodeNo ) ) ; nodeNo ++ ; for ( byte out : io . getNewWrites ( ) ) { newProgram . add ( new ValueNode ( - 1 , - 1 , out , true ) ) ; newProgram . add ( new OutputNode ( - 1 , - 1 ) ) ; } } } catch ( Exception e ) { if ( e . getCause ( ) != null ) e = ( Exception ) e . getCause ( ) ; log . info ( "Aborting constant evaluation" , e ) ; int lastCell = 0 ; for ( int i = 0 ; i < savedMem . length ; i ++ ) { byte value = savedMem [ i ] ; if ( value != 0 ) { if ( i != lastCell ) { PointerNode move = new PointerNode ( - 1 , - 1 , i - lastCell ) ; newProgram . add ( move ) ; } ValueNode set = new ValueNode ( - 1 , - 1 , value , true ) ; newProgram . add ( set ) ; lastCell = i ; } } if ( savedPointer - lastCell != 0 ) { PointerNode restorePointer = new PointerNode ( - 1 , - 1 , savedPointer - lastCell ) ; newProgram . add ( restorePointer ) ; } List < Node > rest = root . - . subList ( nodeNo , blockSize ) ; newProgram . addAll ( rest ) ; } root . - . clear ( ) ; root . - . addAll ( newProgram ) ; }
tr	0	public HTTPMessage getMessage ( ) { return msg ; }
tr	7	private void buildVertexPath ( RoutePath inRoute , boolean randomStart ) { mPath . clear ( ) ; ListIterator ti = inRoute . getPath ( ) . listIterator ( ) ; while ( ti . hasNext ( ) ) { Trip t = ( Trip ) ti . next ( ) ; if ( ! mPath . isEmpty ( ) && mPath . get ( mPath . size ( ) - 1 ) . getRawDistance ( t . getVertices ( ) . get ( 0 ) ) == 0.0 ) { mPath . remove ( mPath . size ( ) - 1 ) ; } if ( randomStart ) { int start = ( int ) ( Math . random ( ) * t . getVertices ( ) . size ( ) ) ; ListIterator vi = t . getVertices ( ) . listIterator ( ) ; while ( start > 0 ) { vi . next ( ) ; start -- ; } while ( vi . hasNext ( ) ) { mPath . add ( ( Vertex ) vi . next ( ) ) ; Vertex v = new Vertex ( ) ; } } else { if ( ! mPath . isEmpty ( ) ) { mPath . remove ( mPath . size ( ) - 1 ) ; } mPath . addAll ( t . getVertices ( ) ) ; } } addStopsToVertexList ( mPath , inRoute . getStops ( ) ) ; }
tr	2	private void load ( String [ ] input ) { if ( input . length == 1 ) { System . out . println ( "Anna tiedoston nimi." ) ; return ; } try { register . load ( new File ( input [ 1 ] ) ) ; data = register . getCardData ( ) ; System . out . println ( "Lataus onnistui." ) ; } catch ( FileNotFoundException ex ) { System . out . println ( "Virhe latauksessa tai syntaksissa." ) ; } }
tr	5	@ Override public void channelRead ( ChannelHandlerContext ctx , Object msg ) throws Exception { Channel ch = ctx . channel ( ) ; if ( ! handshaker . isHandshakeComplete ( ) ) { handshaker . finishHandshake ( ch , ( FullHttpResponse ) msg ) ; LOGGER . info ( "COSM Client connected!" ) ; return ; } if ( msg instanceof FullHttpResponse ) { FullHttpResponse response = ( FullHttpResponse ) msg ; throw new Exception ( "Unexpected FullHttpResponse (status=" + response . getStatus ( ) + ) ) ; } WebSocketFrame frame = ( WebSocketFrame ) msg ; if ( frame instanceof TextWebSocketFrame ) { TextWebSocketFrame textFrame = ( TextWebSocketFrame ) frame ; LOGGER . info ( "WebSocket Client received message: {}" , textFrame . text ( ) ) ; } else if ( frame instanceof PongWebSocketFrame ) { LOGGER . info ( "WebSocket Client received pong" ) ; } else if ( frame instanceof CloseWebSocketFrame ) { LOGGER . info ( "WebSocket Client received closing" ) ; ch . close ( ) ; } }
tr	8	@ Override public void run ( ) { try { startServer ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } while ( ! this . isInterrupted ( ) ) { try { selector . select ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } Iterator keys = selector . selectedKeys ( ) . iterator ( ) ; while ( keys . hasNext ( ) ) { SelectionKey key = ( SelectionKey ) keys . next ( ) ; keys . remove ( ) ; if ( ! key . isValid ( ) ) { continue ; } if ( key . isAcceptable ( ) ) { acceptOP ( key , selector ) ; } else if ( key . isReadable ( ) ) { this . readOP ( key ) ; } else if ( key . isWritable ( ) ) { this . writeOP ( key ) ; } } } }
tr	1	public String toString ( ) { if ( getFormula ( ) . length ( ) > 0 ) return "Effect:" + getFormula ( ) ; else return "" ; }
tr	5	public MyTableSortDemo ( ) { super ( new GridLayout ( 1 , 0 ) ) ; table = new JTable ( new MyTableModel ( ) ) ; table . setPreferredScrollableViewportSize ( new Dimension ( 500 , 70 ) ) ; table . setFillsViewportHeight ( true ) ; table . setAutoCreateRowSorter ( true ) ; table . setColumnSelectionAllowed ( true ) ; table . setRowSelectionAllowed ( true ) ; JScrollPane pane = new JScrollPane ( table ) ; add ( pane ) ; pMenu = new JPopupMenu ( ) ; menuItem = new JMenuItem ( "Search" ) ; dialog = new JDialog ( ) ; next = new JButton ( "Next" ) ; cancel = new JButton ( "Cancel" ) ; dialog . setSize ( 300 , 300 ) ; dialog . setLayout ( new FlowLayout ( ) ) ; textField = new JTextField ( 20 ) ; dialog . add ( next ) ; next . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { System . out . println ( "search text=" + textField . getText ( ) ) ; String text = textField . getText ( ) ; TableModel model = table . getModel ( ) ; for ( int i = 0 ; i < model . getRowCount ( ) ; i ++ ) { for ( int j = 0 ; j < model . getColumnCount ( ) ; j ++ ) { if ( ! model . getColumnClass ( j ) . equals ( text . getClass ( ) ) ) continue ; String s = ( String ) model . getValueAt ( i , j ) ; if ( s . contains ( text ) ) { System . out . println ( "match found at " + i + "  " + j ) ; table . setRowSelectionInterval ( i , i ) ; table . setColumnSelectionInterval ( j , j ) ; Rectangle r = table . getCellRect ( i , j , true ) ; table . scrollRectToVisible ( r ) ; table . repaint ( ) ; } } } } } ) ; dialog . add ( cancel ) ; cancel . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { dialog . setVisible ( false ) ; } } ) ; dialog . add ( textField ) ; pMenu . add ( menuItem ) ; menuItem . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { dialog . setVisible ( true ) ; } } ) ; table . addMouseListener ( new MouseAdapter ( ) { @ Override public void mousePressed ( MouseEvent e ) { System . out . println ( "mouse clikec: " + e . getButton ( ) ) ; if ( e . isPopupTrigger ( ) ) { pMenu . show ( e . getComponent ( ) , e . getX ( ) , e . getY ( ) ) ; System . out . println ( "popup menu" ) ; } } } ) ; }
tr	8	public JSONArray ( JSONTokener x ) throws JSONException { this ( ) ; if ( x . nextClean ( ) != [ ) { throw x . syntaxError ( "A JSONArray text must start with '['" ) ; } if ( x . nextClean ( ) != ] ) { x . back ( ) ; for ( ; ; ) { if ( x . nextClean ( ) ==   ) { x . back ( ) ; this . myArrayList . add ( JSONObject . null ) ; } else { x . back ( ) ; this . myArrayList . add ( x . nextValue ( ) ) ; } switch ( x . nextClean ( ) ) { case ; : case   : if ( x . nextClean ( ) == ] ) { return ; } x . back ( ) ; break ; case ] : return ; default : throw x . syntaxError ( "Expected a ' ' or ']'" ) ; } } } }
tr	5	@ Override public void insertAfter ( Element element , Element after , String outerBlockNames ) throws RemoteException { if ( "" . equals ( outerBlockNames . trim ( ) ) ) { confText = ReadConf ( ) ; String editconfText = BlockInsertAfter ( confText , element , after ) ; WriteConf ( editconfText ) ; WriteRemoteConf ( ) ; return ; } if ( CheckOuterBlockNames ( outerBlockNames ) ) { throw new RemoteException ( "outerBlockNames is not correct outerBlockNames =" + outerBlockNames ) ; } if ( ( null == after . toString ( ) ) || ( "" == after . toString ( ) ) ) { return ; } if ( ! outerBlockNames . contains ( ":" ) ) { outerBlockNames += ":0" ; } HashMap < String , String > objHashMap = EditCommon ( outerBlockNames ) ; String BlockText = objHashMap . get ( "blocktext" ) ; int BlockLength = Integer . parseInt ( objHashMap . get ( "blocklength" ) ) ; int nblockNameNum = Integer . parseInt ( objHashMap . get ( "nblocknamenum" ) ) ; String editBlockText = BlockInsertAfter ( BlockText , element , after ) ; String newConfText = GetPreBlockText ( confText , nblockNameNum ) + editBlockText + GetSufBlockText ( confText , nblockNameNum + BlockLength ) ; WriteConf ( newConfText ) ; WriteRemoteConf ( ) ; }
tr	4	@ Override public void onMoveTick ( int x , int y , Game game ) { SinglePlayerGame spg = ( SinglePlayerGame ) game ; Location loc = spg . getFirstSquareNeighborLocation ( x , y , 5 , zombie . id ) ; if ( loc == null ) { if ( filterByID ( spg . getSquareNeighbors ( x , y , 2 ) , human . id ) . isEmpty ( ) ) { loc = Location . idleWander ( x , y , 1 , 50 ) ; if ( loc != null ) { spg . moveEntity ( x , y , loc ) ; } } } else { if ( ! spg . moveEntity ( x , y , Location . towards ( x , y , loc , 2 ) ) ) { spg . moveEntity ( x , y , Location . wander ( x , y , 1 ) ) ; } } }
tr	8	public LoadPermissions ( ) { final File permissionsFolder = new File ( plugin . getDataFolder ( ) , "permissions/" ) ; if ( ! permissionsFolder . exists ( ) ) { permissionsFolder . mkdirs ( ) ; } permissionsFile = new File ( plugin . getDataFolder ( ) , "permissions/permissions.yml" ) ; if ( ! permissionsFile . exists ( ) ) { try { ConfigHandle . copy ( plugin . getResourceAsStream ( "permissions.yml" ) , permissionsFile ) ; } catch ( final IOException e ) { e . printStackTrace ( ) ; } } final FileConfiguration permissionsYaml = new YamlConfiguration ( ) ; try { permissionsYaml . load ( permissionsFile ) ; } catch ( final Exception e ) { throw new IllegalStateException ( "Can't load permissions file!" ) ; } final HashMap < String , Group > groups = new HashMap < String , Group > ( ) ; final Set < String > groupNames = permissionsYaml . getConfigurationSection ( "groups" ) . getKeys ( false ) ; for ( final String groupName : groupNames ) { final boolean isDefault = permissionsYaml . getBoolean ( "groups." + groupName + ".default" ) ; final List < String > permissions = permissionsYaml . getStringList ( "groups." + groupName + ".permissions" ) ; final Set < String > flags = permissionsYaml . getConfigurationSection ( "groups." + groupName + ".flags" ) . getKeys ( false ) ; final List < String > tempPerms = new ArrayList < String > ( ) ; final HashMap < String , Object > tempflags = new HashMap < String , Object > ( ) ; for ( final String permission : permissions ) { tempPerms . add ( permission . toLowerCase ( ) ) ; } for ( final String flag : flags ) { tempflags . put ( flag , permissionsYaml . get ( "groups." + groupName + ".flags." + flag ) ) ; } final String tag = permissionsYaml . getString ( "groups." + groupName + ".tag" ) ; final Group group = new Group ( groupName . toLowerCase ( ) , tag , isDefault , tempPerms , tempflags ) ; permissions . clear ( ) ; tempPerms . clear ( ) ; flags . clear ( ) ; tempflags . clear ( ) ; if ( isDefault ) { PermissionData . setDefaultGroup ( group ) ; } groups . put ( groupName . toLowerCase ( ) , group ) ; } PermissionData . setGroups ( groups ) ; }
tr	0	@ Override public < S , T > T visit ( SMPLVisitor < S , T > visitor , S state ) { return visitor . visitCarExp ( this , state ) ; }
tr	9	public static void invert ( double src [ ] [ ] , double dst [ ] [ ] ) { gaussian ( src , a ) ; for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) b [ i ] [ i ] = i == j ? 1 : 0 ; for ( int i = 0 ; i < 3 ; i ++ ) for ( int j = i + 1 ; j < 4 ; j ++ ) for ( int k = 0 ; k < 4 ; k ++ ) b [ index [ j ] ] [ k ] -= a [ index [ j ] ] [ i ] * b [ index [ i ] ] [ k ] ; for ( int i = 0 ; i < 4 ; i ++ ) { dst [ 4 - 1 ] [ i ] = b [ index [ 4 - 1 ] ] [ i ] / a [ index [ 4 - 1 ] ] [ 4 - 1 ] ; for ( int j = 2 ; j >= 0 ; j -- ) { dst [ j ] [ i ] = b [ index [ j ] ] [ i ] ; for ( int k = j + 1 ; k < 4 ; k ++ ) dst [ j ] [ i ] -= a [ index [ j ] ] [ k ] * dst [ k ] [ i ] ; dst [ j ] [ i ] /= a [ index [ j ] ] [ j ] ; } } }
tr	9	public void setInitialized ( short mask , float value ) { if ( mask > Constants . Z_MASK && ext == null ) ext = new Extended ( ) ; switch ( mask ) { case Constants . E_MASK : e = value ; break ; case Constants . X_MASK : x = value ; break ; case Constants . Y_MASK : y = value ; break ; case Constants . Z_MASK : z = value ; break ; case Constants . F_MASK : f = value ; break ; case Constants . SE_MASK : ext . s_ext = value ; break ; case Constants . SB_MASK : ext . s_bed = value ; break ; case Constants . SF_MASK : ext . s_fan = value ; break ; case Constants . IX_MASK : ext . ix = value ; break ; case Constants . JY_MASK : ext . jy = value ; break ; case Constants . KZ_MASK : ext . kz = value ; break ; case Constants . R_MASK : ext . r = value ; break ; default : break ; } }
tr	4	public Contact getContact ( CommandLine cmd ) { Contact contact = null ; if ( cmd . hasOption ( "email" ) || cmd . hasOption ( "facebook" ) || cmd . hasOption ( "phone" ) || cmd . hasOption ( "web" ) ) { contact = new Contact ( ) ; contact . setEmail ( cmd . getOptionValue ( "email" ) ) ; contact . setFaceBook ( cmd . getOptionValue ( "facebook" ) ) ; contact . setPhone ( cmd . getOptionValue ( "phone" ) ) ; contact . setWebUrl ( cmd . getOptionValue ( "web" ) ) ; } return contact ; }
tr	1	private static List < ABObject > GetSupporteeShel ( HashMap < ABObject , List < ABObject >> supportee , ABObject roof ) { List < ABObject > temp = new ArrayList < ABObject > ( ) ; for ( ABObject ab : supportee . keySet ( ) ) { temp . addAll ( GetSupporteeShel ( supportee . get ( ab ) , roof ) ) ; } return temp ; }
tr	8	public void keyPressed ( KeyEvent e ) { char keychar = e . getKeyChar ( ) ; int keycode = e . getKeyCode ( ) ; if ( keycode >= 0 && keycode < 256 ) { keymap [ keycode ] = true ; lastkey = keycode ; lastkeychar = keychar ; if ( wakeup_key == - 1 || wakeup_key == keycode ) { if ( ! eng . isRunning ( ) ) { eng . start ( ) ; keymap [ keycode ] = false ; } } } if ( e . isShiftDown ( ) && e . getKeyCode ( ) == KeyEvent . VK_ESCAPE && ! eng . isApplet ( ) ) { System . exit ( 0 ) ; } }
tr	0	private void initializeComponents ( ) { this . setLayout ( new BorderLayout ( ) ) ; ingredientPanel = new IngredientPanel ( ) ; ingredientPanel . addChangeListener ( this ) ; textPanel = new JPanel ( new BorderLayout ( ) ) ; textPane = new JTextArea ( ) ; textPane . setLineWrap ( true ) ; textPane . setLineWrap ( true ) ; textPane . setWrapStyleWord ( true ) ; textPane . setEditable ( true ) ; textPane . getDocument ( ) . addDocumentListener ( new ChangeDocumentListener ( ) ) ; textScrollPane = new JScrollPane ( textPane ) ; textScrollPane . setVerticalScrollBarPolicy ( JScrollPane . VERTICAL_SCROLLBAR_AS_NEEDED ) ; textScrollPane . setPreferredSize ( new Dimension ( 450 , 200 ) ) ; headline = new JTextField ( ) ; headline . getDocument ( ) . addDocumentListener ( new ChangeDocumentListener ( ) ) ; this . setPreferredSize ( new Dimension ( 750 , 250 ) ) ; }
tr	3	@ Override public void setOption ( String key , Object option , String world ) { Map < String , Object > map = getOptions ( world ) ; if ( map == null ) { map = new HashMap < String , Object > ( ) ; } map . put ( key , option ) ; options . put ( world == null || world . isEmpty ( ) ? null : world . toLowerCase ( ) , map ) ; }
tr	5	public void kill ( ) { if ( socket == null ) return ; try { oos . close ( ) ; } catch ( IOException e ) { } try { ois . close ( ) ; } catch ( IOException e ) { } try { bis . close ( ) ; } catch ( IOException e ) { } try { socket . close ( ) ; socket = null ; } catch ( IOException e ) { } }
tr	8	public static void main ( String [ ] args ) { ConsistentGlobalProblemSetInitialisation starter = new ConsistentGlobalProblemSetInitialisation ( ) ; starter . initLanguage ( new char [ ] { a , b } , 10 , "[ab]*abab" ) ; int solutionFoundCounter = 0 ; int noSolutionFound = 0 ; List < long > cycleCount = new LinkedList < long > ( ) ; long tmpCycle ; long timeStamp ; int [ ] problemCount = new int [ 5 ] ; int [ ] candidatesCount = new int [ 5 ] ; int [ ] noCycles = new int [ 2 ] ; problemCount [ 0 ] = 50 ; problemCount [ 1 ] = 100 ; problemCount [ 2 ] = 150 ; problemCount [ 3 ] = 200 ; problemCount [ 4 ] = 250 ; candidatesCount [ 0 ] = 50 ; candidatesCount [ 1 ] = 100 ; candidatesCount [ 2 ] = 150 ; candidatesCount [ 3 ] = 200 ; candidatesCount [ 4 ] = 250 ; noCycles [ 0 ] = 250 ; noCycles [ 1 ] = 500 ; int pc = 0 ; int cc = 0 ; int nc = 0 ; for ( int x = 0 ; x < 10 ; x ++ ) { for ( int n = 0 ; n < 25 ; n ++ ) { DateFormat df = new SimpleDateFormat ( "yyyy-MM-dd_HH_mm_ss" ) ; Logger l = new Logger ( "C_G_" + df . format ( new Date ( ) ) + ".log" , true ) ; pc = problemCount [ n % 5 ] ; cc = candidatesCount [ ( int ) Math . floor ( n / 5 ) ] ; nc = noCycles [ 1 ] ; l . log ( "Problem Count: " + pc ) ; l . log ( "CandidatesCount: " + cc ) ; l . log ( "Max Cycles: " + nc ) ; solutionFoundCounter = 0 ; noSolutionFound = 0 ; cycleCount = new LinkedList < long > ( ) ; for ( int i = 0 ; i < 100 ; i ++ ) { timeStamp = System . currentTimeMillis ( ) ; starter . initProblems ( pc ) ; starter . initCandidates ( cc ) ; tmpCycle = starter . startEvolution ( nc ) ; l . log ( i + ": finished (" + ( System . currentTimeMillis ( ) - timeStamp ) + "ms  " + tmpCycle + "cycles)" ) ; if ( starter . getWinner ( ) != null ) { solutionFoundCounter ++ ; cycleCount . add ( tmpCycle ) ; l . log ( i + ": Solution found." ) ; } else { noSolutionFound ++ ; l . log ( i + ": No solution found." ) ; } } long max = 0 ; long min = 10000 ; long sum = 0 ; for ( long no : cycleCount ) { sum += no ; max = ( no > max ? no : max ) ; min = ( no < min ? no : min ) ; } l . log ( "Solution Found: " + solutionFoundCounter ) ; l . log ( "Avg cycles: " + ( cycleCount . size ( ) > 0 ? sum / cycleCount . size ( ) : 0 ) ) ; l . log ( "Max cycles: " + max ) ; l . log ( "Min cycles: " + min ) ; l . log ( "No solution found: " + noSolutionFound ) ; l . finish ( ) ; } } }
tr	7	@ Override public LinkedList < Individual > crossover ( int [ ] parents , Population pop ) { LinkedList < Individual > children = new LinkedList < Individual > ( ) ; Random r = new Random ( ) ; int r1 = r . nextInt ( parents . length ) ; int r2 = r . nextInt ( parents . length ) ; Individual p1 = pop . people [ parents [ r1 ] ] ; Individual p2 = pop . people [ parents [ r2 ] ] ; int dna1 [ ] [ ] = new int [ 9 ] [ 9 ] ; int dna2 [ ] [ ] = new int [ 9 ] [ 9 ] ; Sudoku parent1 = ( ( Sudoku ) p1 ) ; Sudoku parent2 = ( ( Sudoku ) p2 ) ; for ( int row = 0 ; row < 9 ; row ++ ) { int cut1 = r . nextInt ( 9 ) ; int cut2 = r . nextInt ( 9 ) ; if ( cut2 < cut1 ) { int temp = cut1 ; cut1 = cut2 ; cut2 = temp ; } for ( int col = 0 ; col < 9 ; col ++ ) { if ( col <= cut1 || col >= cut2 ) { dna1 [ row ] [ col ] = parent2 . rows [ row ] [ col ] ; dna2 [ row ] [ col ] = parent1 . rows [ row ] [ col ] ; } else { int a = parent1 . rows [ row ] [ col ] ; if ( ! contains ( a , dna2 [ row ] ) ) dna2 [ row ] [ col ] = a ; int b = parent2 . rows [ row ] [ col ] ; if ( ! contains ( b , dna1 [ row ] ) ) dna1 [ row ] [ col ] = b ; } } } children . add ( new Sudoku ( dna1 ) ) ; children . add ( new Sudoku ( dna2 ) ) ; return children ; }
tr	7	public int Compare ( SpamSumSignature signature1 , SpamSumSignature signature2 ) { long block_size1 , block_size2 ; long score ; byte [ ] s1 , s2 ; byte [ ] s1_1 , s1_2 ; byte [ ] s2_1 , s2_2 ; if ( null == signature1 || null == signature2 ) { return - 1 ; } block_size1 = signature1 . getBlockSize ( ) ; block_size2 = signature2 . getBlockSize ( ) ; if ( block_size1 != block_size2 && block_size1 != block_size2 * 2 && block_size2 != block_size1 * 2 ) { return 0 ; } s1 = eliminate_sequences2 ( signature1 . getHashPart1 ( ) ) ; s2 = eliminate_sequences2 ( signature2 . getHashPart1 ( ) ) ; s1_1 = s1 ; s2_1 = s2 ; s1_2 = eliminate_sequences2 ( signature1 . getHashPart2 ( ) ) ; s2_2 = eliminate_sequences2 ( signature2 . getHashPart2 ( ) ) ; if ( block_size1 == block_size2 ) { long score1 , score2 ; score1 = score_strings ( s1_1 , s2_1 , block_size1 ) ; score2 = score_strings ( s1_2 , s2_2 , block_size2 ) ; score = Math . max ( score1 , score2 ) ; } else if ( block_size1 == block_size2 * 2 ) { score = score_strings ( s1_1 , s2_2 , block_size1 ) ; } else { score = score_strings ( s1_2 , s2_1 , block_size2 ) ; } return ( int ) score ; }
tr	8	private Method getMethod ( String name , class < ? > [ ] args ) throws Exception { Method m = c . getMethod ( name , args ) ; if ( m != null ) return m ; for ( int i = 0 ; i < methods . length ; i ++ ) { if ( ! name . equals ( methods [ i ] . getName ( ) ) ) continue ; class ca [ ] = methods [ i ] . getParameterTypes ( ) ; if ( ca . length != args . length ) continue ; int j ; for ( j = 0 ; j < ca . length ; j ++ ) { if ( ! args [ j ] . isAssignableFrom ( ca [ j ] ) ) break ; } if ( j != ca . length ) continue ; return methods [ i ] ; } return null ; }
tr	7	public static DecodeResult decode ( byte [ ] buffer , int start , String encoding ) throws UnsupportedEncodingException { DecodeResult ret = new DecodeResult ( ) ; if ( start >= buffer . length ) return ret ; int pos = start ; byte c ; do { c = buffer [ pos ] ; if ( c == 58 ) { break ; } else if ( c < 48 || c > 57 ) { ret . data = null ; ret . end_pos = 0 ; return ret ; } pos ++ ; } while ( pos < buffer . length ) ; if ( pos == start ) { ret . data = null ; ret . end_pos = 0 ; return ret ; } int len = Integer . parseInt ( new String ( buffer , start , pos - start ) ) ; pos ++ ; if ( buffer . length < pos + len + 1 ) { ret . data = null ; ret . end_pos = 0 ; return ret ; } ret . data = new String ( buffer , pos , len , encoding ) ; ret . end_pos = pos + len + 1 ; return ret ; }
tr	0	public Prenotazione ( ) { super ( ) ; }
tr	0	public String getName ( ) { return name ; }
tr	4	@ Override public synchronized Message process ( ClientState state , Message request ) { System . out . println ( "Request:" + request ) ; Node child = request . contents . getFirstChild ( ) ; String eventType = child . getAttributes ( ) . getNamedItem ( "type" ) . getNodeValue ( ) ; EventType myType = EventType . ERROR ; if ( eventType . equals ( "open" ) ) myType = EventType . OPEN ; else if ( eventType . equals ( "closed" ) ) myType = EventType . CLOSED ; else if ( eventType . equals ( "finished" ) ) myType = EventType . FINISHED ; xmlString = "<response id='" + request . id ( ) + "' version='1.0' success='true'>" + "<reportResponse>" ; ArrayList < String > reportResults = DatabaseSubsystem . produceReport ( myType ) ; for ( int i = 0 ; i < reportResults . size ( ) ; i = i + 8 ) { String idString = reportResults . get ( i ) ; String typeString = reportResults . get ( i + 1 ) ; String behaviorString = reportResults . get ( i + 2 ) ; String questionString = reportResults . get ( i + 3 ) ; String numChoicesString = reportResults . get ( i + 4 ) ; String numRoundsString = reportResults . get ( i + 5 ) ; String createdString = reportResults . get ( i + 6 ) ; String completedString = reportResults . get ( i + 7 ) ; xmlString = xmlString + "<entry id='" + idString + "' type='" + typeString + "' behavior='" + behaviorString + "' question='" + questionString + "' numChoices='" + numChoicesString + "' numRounds='" + numRoundsString + "' created='" + createdString + "' completed='" + completedString + "'/>" ; } xmlString = xmlString + "</reportResponse></response>" ; System . out . println ( xmlString ) ; Message response = new Message ( xmlString ) ; System . out . println ( "Response:" + response ) ; return response ; }
tr	6	public synchronized void playSound ( final String soundName ) { if ( soundName == null || soundName . isEmpty ( ) ) { return ; } new Thread ( new Runnable ( ) { @ Override public void run ( ) { try { playClip ( soundName ) ; } catch ( IOException e ) { System . out . println ( e . getLocalizedMessage ( ) ) ; } catch ( UnsupportedAudioFileException e ) { System . out . println ( "WRONG AUDIOFILEFORMAT: " + soundName ) ; } catch ( LineUnavailableException e ) { System . out . println ( "LineUnavailableException" ) ; } catch ( InterruptedException e ) { System . out . println ( "InterruptedException" ) ; } } private void playClip ( String soundName ) throws IOException , UnsupportedAudioFileException , LineUnavailableException , InterruptedException { class AudioListener implements LineListener { private boolean done = false ; @ Override public synchronized void update ( LineEvent event ) { Type eventType = event . getType ( ) ; if ( eventType == Type . STOP || eventType == Type . CLOSE ) { done = true ; notifyAll ( ) ; } } public synchronized void waitUntilDone ( ) throws InterruptedException { while ( ! done ) { wait ( ) ; } } } AudioListener listener = new AudioListener ( ) ; final InputStream systemResourceAsStream = ClassLoader . getSystemResourceAsStream ( prop . getProperty ( soundName ) ) ; final BufferedInputStream bufInputStream = new BufferedInputStream ( systemResourceAsStream ) ; AudioInputStream audioInputStream = AudioSystem . getAudioInputStream ( bufInputStream ) ; try { Clip clip = AudioSystem . getClip ( ) ; clip . addLineListener ( listener ) ; clip . open ( audioInputStream ) ; try { clip . start ( ) ; listener . waitUntilDone ( ) ; } finally { clip . close ( ) ; } } finally { audioInputStream . close ( ) ; } } } ) . start ( ) ; }
tr	0	public void start ( ) { this . setPlayingOrder ( player1 , player2 ) ; this . board . clearTheBoard ( ) ; this . setStatus ( Game . NEW_GAME ) ; }
tr	4	public boolean consumeFuel ( final double mass ) { boolean outOfFuel = false ; if ( preferredFuelTanks . size ( ) == 0 ) { return false ; } final double massPerTank = mass / preferredFuelTanks . size ( ) / propellantRatios . size ( ) ; for ( final VehiclePart fuelTank : preferredFuelTanks ) { for ( final Resource resource : propellantRatios . keySet ( ) ) { final double ratio = propellantRatios . get ( resource ) ; final double resourceMass = fuelTank . getResourceMass ( resource ) ; final double newResourceMass = resourceMass - massPerTank * ratio ; if ( newResourceMass < 0 ) { outOfFuel = true ; } fuelTank . setResourceMass ( resource , Math . max ( 0 , newResourceMass ) ) ; } } return ! outOfFuel ; }
tr	8	private List < String > generaCacheKey ( Object obj ) { ORMTable ormTable = obj . getClass ( ) . getAnnotation ( ORMTable . class ) ; if ( ormTable != null ) { String cachedTableKey = "" . equalsIgnoreCase ( ormTable . cachedShortAlias ( ) ) ? ormTable . tableName ( ) : ormTable . cachedShortAlias ( ) ; String [ ] cachedKeys = ormTable . cachedKey ( ) ; if ( cachedKeys . length > 0 ) { List < String > ks = new ArrayList < String > ( ) ; for ( int i = 0 ; i < cachedKeys . length ; i ++ ) { String cachedCol = cachedKeys [ i ] ; String [ ] fk = cachedCol . split ( "=" ) ; try { Field f = obj . getClass ( ) . getDeclaredField ( fk [ 0 ] ) ; f . setAccessible ( true ) ; ks . add ( cachedTableKey + "." + fk [ 1 ] + "." + f . get ( obj ) ) ; } catch ( NoSuchFieldException e ) { logger . warn ( "NoSuchFieldException:{};" , cachedCol , e ) ; continue ; } catch ( SecurityException e ) { logger . warn ( "SecurityException:{};" , cachedCol , e ) ; continue ; } catch ( IllegalArgumentException e ) { logger . warn ( "Get field value fail:{};" , cachedCol , e ) ; continue ; } catch ( IllegalAccessException e ) { logger . warn ( "Get field value fail:{};" , cachedCol , e ) ; continue ; } } return ks ; } else { return null ; } } else { return null ; } }
tr	8	public ArrayList < Point > estimateLaunchPoint ( Rectangle slingshot , Point targetPoint ) { double scale = getSceneScale ( slingshot ) ; Point ref = getReferencePoint ( slingshot ) ; double x = ( targetPoint . x - ref . x ) / scale ; double y = - ( targetPoint . y - ref . y ) / scale ; double bestError = 1000 ; double theta1 = 0 ; double theta2 = 0 ; double v = _scaleFactor * _launchVelocity [ 6 ] ; double v2 = v * v ; double v4 = v2 * v2 ; double tangent1 = ( v2 - Math . sqrt ( v4 - ( x * x + 2 * y * v2 ) ) ) / x ; double tangent2 = ( v2 + Math . sqrt ( v4 - ( x * x + 2 * y * v2 ) ) ) / x ; double t1 = actualToLaunch ( Math . atan ( tangent1 ) ) ; double t2 = actualToLaunch ( Math . atan ( tangent2 ) ) ; ArrayList < Point > pts = new ArrayList < Point > ( ) ; for ( double theta = t1 - BOUND ; theta <= t1 + BOUND ; theta += 0.001 ) { double velocity = getVelocity ( theta ) ; double u_x = velocity * Math . cos ( theta ) ; double u_y = velocity * Math . sin ( theta ) ; double a = - 0.5 / ( u_x * u_x ) ; double b = u_y / u_x ; double error = Math . abs ( a * x * x + b * x - y ) ; if ( error < bestError ) { theta1 = theta ; bestError = error ; } } if ( bestError < 1000 ) { theta1 = actualToLaunch ( theta1 ) ; pts . add ( findReleasePoint ( slingshot , theta1 ) ) ; } bestError = 1000 ; for ( double theta = t2 - BOUND ; theta <= t2 + BOUND ; theta += 0.001 ) { double velocity = getVelocity ( theta ) ; double u_x = velocity * Math . cos ( theta ) ; double u_y = velocity * Math . sin ( theta ) ; double a = - 0.5 / ( u_x * u_x ) ; double b = u_y / u_x ; double error = Math . abs ( a * x * x + b * x - y ) ; if ( error < bestError ) { theta2 = theta ; bestError = error ; } } theta2 = actualToLaunch ( theta2 ) ; if ( theta2 < Math . toRadians ( 75 ) && theta2 != theta1 && bestError < 1000 ) pts . add ( findReleasePoint ( slingshot , theta2 ) ) ; return pts ; }
tr	0	public boolean isChanged ( ) { return this . changed ; }
tr	8	public DataSet parse ( ) { DataSet dataSet = new DataSet ( ) ; int [ ] distribution = null ; dataSet . setName ( "Generic" ) ; try { FileInputStream fis = new FileInputStream ( file ) ; DataInputStream din = new DataInputStream ( fis ) ; BufferedReader br = new BufferedReader ( new InputStreamReader ( din ) ) ; Map < Integer , Integer > dist = new HashMap < Integer , Integer > ( ) ; String line ; int ix = 0 ; while ( ( line = br . readLine ( ) ) != null ) { if ( ix == 0 ) { String commas [ ] = line . split ( " " ) ; for ( int j = 0 ; j < commas . length - 1 ; j ++ ) { dataSet . addAttribute ( new Attribute ( "a" + j , Attribute . Type . NUMERIC ) ) ; } dataSet . setClasses ( new Attribute ( "clase" ) ) ; } Pattern instance = new Pattern ( ) ; instance . setDataSet ( dataSet ) ; String values [ ] = line . split ( " " ) ; for ( int i = 0 ; i < values . length - 1 ; i ++ ) { String rawValue = values [ i ] . trim ( ) ; instance . add ( double . valueOf ( rawValue ) ) ; } if ( dataSet . getClasses ( ) . getValues ( ) . indexOf ( values [ values . length - 1 ] ) == - 1 ) { dataSet . getClasses ( ) . getValues ( ) . add ( values [ values . length - 1 ] ) ; } instance . setClassValue ( values [ values . length - 1 ] ) ; dataSet . add ( instance ) ; if ( dist . containsKey ( instance . getClassIndex ( ) ) ) { dist . put ( instance . getClassIndex ( ) , dist . get ( instance . getClassIndex ( ) ) + 1 ) ; } else { dist . put ( instance . getClassIndex ( ) , 1 ) ; } ix ++ ; } distribution = new int [ dist . size ( ) ] ; for ( int i = 0 ; i < distribution . length ; i ++ ) { distribution [ i ] = dist . get ( i ) ; } dataSet . setDistribution ( distribution ) ; br . close ( ) ; din . close ( ) ; fis . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; return null ; } return dataSet ; }
tr	2	@ Override public void modifyClasa ( Clasa c ) { Centralizator cen = Centralizator . getInstance ( ) ; int index = 0 ; ArrayList < Clasa > clase = cen . getClasa ( ) ; for ( Iterator < Clasa > it = clase . iterator ( ) ; it . hasNext ( ) ; ) { Clasa cl = it . next ( ) ; if ( cl . getIdClasa ( ) . equals ( c . getIdClasa ( ) ) ) { index = clase . indexOf ( cl ) ; it . remove ( ) ; } } clase . add ( index , c ) ; cen . setClase ( clase ) ; }
tr	8	public static void main ( String [ ] args ) { int numberOfTests = Integer . parseInt ( args [ 0 ] ) ; int sequencesSize = Integer . parseInt ( args [ 1 ] ) ; Random random = new Random ( ) ; Format format = new Pair ( ) ; try { List < String > matrices = new ArrayList < String > ( ) ; for ( Iterator < String > i = MatrixLoader . list ( ) . iterator ( ) ; i . hasNext ( ) ; ) { matrices . add ( i . next ( ) ) ; } int countOfMatrices = matrices . size ( ) ; int i = 1 ; while ( i <= numberOfTests ) { System . gc ( ) ; String s1 = RandomSequenceGenerator . generate ( sequencesSize ) ; String s2 = RandomSequenceGenerator . generate ( sequencesSize ) ; float gap = random . nextInt ( 1000 ) ; if ( s1 . length ( ) > 0 && s2 . length ( ) > 0 ) { Matrix matrix = ( Matrix ) MatrixLoader . load ( ( String ) matrices . get ( random . nextInt ( countOfMatrices ) ) ) ; Sequence seq1 = new Sequence ( s1 ) ; Sequence seq2 = new Sequence ( s2 ) ; Alignment alignment1 = NeedlemanWunsch . align ( seq1 , seq2 , matrix , gap ) ; if ( ! alignment1 . checkScore ( ) ) { System . out . println ( "Invalid alignment found:" ) ; System . out . println ( "Sequence 1 = " + s1 ) ; System . out . println ( "Sequence 2 = " + s2 ) ; System . out . println ( format . format ( alignment1 ) ) ; System . out . println ( alignment1 . getSummary ( ) ) ; System . out . println ( "The score of the alignment above is: " + alignment1 . calculateScore ( ) ) ; System . exit ( 1 ) ; } Alignment alignment2 = NeedlemanWunsch . align ( seq2 , seq1 , matrix , gap ) ; if ( ! alignment1 . checkScore ( ) ) { System . out . println ( "Invalid alignment found:" ) ; System . out . println ( "Sequence 1 = " + s2 ) ; System . out . println ( "Sequence 2 = " + s1 ) ; System . out . println ( format . format ( alignment2 ) ) ; System . out . println ( alignment2 . getSummary ( ) ) ; System . out . println ( "The score of the alignment above is: " + alignment2 . calculateScore ( ) ) ; System . exit ( 1 ) ; } if ( alignment1 . getScore ( ) != alignment2 . getScore ( ) ) { System . out . println ( "Not symmetric alignment:" ) ; System . out . println ( "Alignment #1: " ) ; System . out . println ( "Sequence 1 = " + s1 ) ; System . out . println ( "Sequence 2 = " + s2 ) ; System . out . println ( format . format ( alignment1 ) ) ; System . out . println ( alignment1 . getSummary ( ) ) ; System . out . println ( ) ; System . out . println ( "Alignment #2: " ) ; System . out . println ( "Sequence 1 = " + s2 ) ; System . out . println ( "Sequence 2 = " + s1 ) ; System . out . println ( format . format ( alignment2 ) ) ; System . out . println ( alignment2 . getSummary ( ) ) ; System . exit ( 1 ) ; } } System . out . println ( "Processed " + i + "/" + numberOfTests ) ; i ++ ; } } catch ( Exception e ) { e . printStackTrace ( ) ; System . exit ( 1 ) ; } }
tr	9	private void adjustSizeForAbsolute ( boolean isHor ) { int [ ] curSizes = isHor ? width : height ; Cell absCell = grid . get ( null ) ; if ( absCell == null || absCell . compWraps . size ( ) == 0 ) return ; ArrayList < CompWrap > cws = absCell . compWraps ; int maxEnd = 0 ; for ( int j = 0 , cwSz = absCell . compWraps . size ( ) ; j < cwSz + 3 ; j ++ ) { boolean doAgain = false ; for ( int i = 0 ; i < cwSz ; i ++ ) { CompWrap cw = cws . get ( i ) ; int [ ] stSz = getAbsoluteDimBounds ( cw , 0 , isHor ) ; int end = stSz [ 0 ] + stSz [ 1 ] ; if ( maxEnd < end ) maxEnd = end ; if ( linkTargetIDs != null ) doAgain |= setLinkedBounds ( cw . comp , cw . cc , stSz [ 0 ] , stSz [ 0 ] , stSz [ 1 ] , stSz [ 1 ] , false ) ; } if ( doAgain == false ) break ; maxEnd = 0 ; clearGroupLinkBounds ( ) ; } maxEnd += LayoutUtil . getInsets ( lc , isHor ? 3 : 2 , ! hasDocks ( ) ) . getPixels ( 0 , container , null ) ; if ( curSizes [ LayoutUtil . MIN ] < maxEnd ) curSizes [ LayoutUtil . MIN ] = maxEnd ; if ( curSizes [ LayoutUtil . PREF ] < maxEnd ) curSizes [ LayoutUtil . PREF ] = maxEnd ; }
tr	6	Polygon ( final List < IColumnVector < float >> vertices , final List < Map < String , Object >> attributes ) { if ( vertices == null ) { throw new IllegalArgumentException ( "The parameter 'vertices' must not be null!" ) ; } for ( final IColumnVector < float > v : vertices ) { if ( v == null ) { throw new IllegalArgumentException ( "No vertex must be 'null'!" ) ; } } if ( attributes == null ) { throw new IllegalArgumentException ( "The parameter 'attributes' must not be null!" ) ; } this . vertices = new ArrayList < IColumnVector < float >> ( vertices ) ; this . attributes = new ArrayList < Map < String , Object >> ( ) ; for ( final Map < String , Object > m : attributes ) { if ( m == null ) { throw new IllegalArgumentException ( "No attribues map must be null!" ) ; } this . attributes . add ( new HashMap < String , Object > ( m ) ) ; } this . triangles = new LinkedList < Triangle > ( ) ; this . nonConvexVertices = new LinkedList < IColumnVector < float >> ( ) ; this . isCw = getPolyOrientation ( ) ; calcNonConvexPoints ( ) ; kong ( ) ; }
tr	1	public Dimension resizeRiskBoard ( int height , int width ) { Dimension d = backGround . resizeImage ( height , width ) ; this . setPreferredSize ( d ) ; this . setMinimumSize ( d ) ; this . setMaximumSize ( d ) ; this . setBounds ( 0 , 0 , ( int ) d . getWidth ( ) , ( int ) d . getHeight ( ) ) ; map . setPreferredSize ( d ) ; map . setMinimumSize ( d ) ; map . setMaximumSize ( d ) ; map . setBounds ( 0 , 0 , ( int ) d . getWidth ( ) , ( int ) d . getHeight ( ) ) ; buttonPanel . setPreferredSize ( d ) ; buttonPanel . setMinimumSize ( d ) ; buttonPanel . setMaximumSize ( d ) ; buttonPanel . setBounds ( 0 , 0 , ( int ) d . getWidth ( ) , ( int ) d . getHeight ( ) ) ; backGround . setPreferredSize ( d ) ; backGround . setMinimumSize ( d ) ; backGround . setMaximumSize ( d ) ; backGround . setBounds ( 0 , 0 , ( int ) d . getWidth ( ) , ( int ) d . getHeight ( ) ) ; repaint ( ) ; for ( CountryButton c : countryButtons . values ( ) ) { c . setCurrentPosition ( d . width , d . height ) ; } return d ; }
tr	6	@ Override public void sign ( final SignableRequest < ? > request , final AWSCredentials credentials ) { if ( credentials instanceof PasswordCredentials ) { final PasswordCredentials passwordCredentials = ( PasswordCredentials ) credentials ; final Charset utf8 = StandardCharsets . UTF_8 ; final ByteArrayOutputStream headerPassword = new ByteArrayOutputStream ( ) ; final OutputStreamWriter headerWriter = new OutputStreamWriter ( headerPassword , utf8 ) ; try { headerWriter . append ( BinaryUtils . toBase64 ( passwordCredentials . getUserName ( ) . getBytes ( utf8 ) ) ) ; headerWriter . append ( @ ) ; headerWriter . append ( BinaryUtils . toBase64 ( passwordCredentials . getAccountName ( ) . getBytes ( utf8 ) ) ) ; if ( credentials instanceof PasswordUpdateCredentials ) { final PasswordUpdateCredentials passwordUpdateCredentials = ( PasswordUpdateCredentials ) credentials ; headerWriter . append ( ; ) ; headerWriter . append ( BinaryUtils . toBase64 ( new String ( passwordCredentials . getPassword ( ) ) . getBytes ( utf8 ) ) ) ; headerWriter . append ( @ ) ; for ( int i = 0 ; i < passwordUpdateCredentials . getPasswordUpdate ( ) . length ; i ++ ) { headerWriter . append ( passwordUpdateCredentials . getPasswordUpdate ( ) [ i ] ) ; } } else { headerWriter . append ( : ) ; for ( int i = 0 ; i < passwordCredentials . getPassword ( ) . length ; i ++ ) { headerWriter . append ( passwordCredentials . getPassword ( ) [ i ] ) ; } } headerWriter . flush ( ) ; headerWriter . close ( ) ; } catch ( IOException e ) { throw new AmazonClientException ( "Unable to construct header for password credentials" , e ) ; } final String authorizationHeader = PREFIX + BinaryUtils . toBase64 ( headerPassword . toByteArray ( ) ) ; request . addHeader ( "Authorization" , authorizationHeader ) ; } }
tr	4	public StandaloneLauncherFrame ( LauncherStub launcher ) { super ( "Settling Launcher Window" ) ; this . launcher = launcher ; StandaloneLauncherFrame . instance = this ; this . setBackground ( Color . black ) ; JPanel p = new JPanel ( ) ; p . setLayout ( new BorderLayout ( ) ) ; p . setPreferredSize ( new Dimension ( 854 , 480 ) ) ; this . setLayout ( new BorderLayout ( ) ) ; this . add ( p , "Center" ) ; this . pack ( ) ; this . setLocationRelativeTo ( null ) ; if ( LWJGLUtil . getPlatform ( ) == LWJGLUtil . PLATFORM_WINDOWS ) { this . addWindowFocusListener ( new WindowAdapter ( ) { @ Override public void windowGainedFocus ( WindowEvent arg0 ) { if ( StandaloneLauncherFrame . this . applet != null ) { StandaloneLauncherFrame . this . applet . requestFocusInWindow ( ) ; } } } ) ; } this . input = new InputHandler ( ) ; this . addMouseListener ( this . input ) ; this . addMouseMotionListener ( this . input ) ; this . addWindowListener ( new WindowAdapter ( ) { @ Override public void windowClosing ( WindowEvent arg0 ) { new Thread ( ) { @ Override public void run ( ) { try { Thread . sleep ( 30000 ) ; } catch ( InterruptedException e ) { } System . out . println ( "FORCING EXIT!" ) ; System . exit ( 0 ) ; } } . start ( ) ; System . out . println ( "Closing window..." ) ; if ( StandaloneLauncherFrame . this . applet != null ) { StandaloneLauncherFrame . this . applet . stop ( ) ; System . exit ( 0 ) ; } else { System . exit ( 0 ) ; } } } ) ; }
tr	1	@ Override public List < Score > getHighscore ( ) { List < Score > ret ; try { ret = fetchScores ( 10 ) ; } catch ( IOException e ) { ret = new ArrayList < Score > ( 0 ) ; e . printStackTrace ( ) ; } return ret ; }
tr	8	public String getLastLine ( ) { try ( RandomAccessFile file = new RandomAccessFile ( f , "r" ) ) { long index , length ; length = file . length ( ) ; index = length - 1 ; int ch = 0 ; while ( ch != 30 && index > 0 ) { file . seek ( index -- ) ; ch = ( file . read ( ) ) ; } if ( index == 0 ) { return null ; } file . seek ( index -- ) ; ch = ( file . read ( ) ) ; while ( ch != 30 && index > 0 ) { file . seek ( index -- ) ; ch = ( file . read ( ) ) ; } file . seek ( index ++ ) ; StringBuilder sb = new StringBuilder ( ) ; sb . append ( in . readUTF ( ) ) ; sb . append ( "\t" ) ; in . readChar ( ) ; sb . append ( in . readLong ( ) ) ; sb . append ( "\t" ) ; in . readChar ( ) ; sb . append ( df . format ( new Date ( in . readLong ( ) ) ) ) ; sb . append ( "\t" ) ; in . readChar ( ) ; sb . append ( TimeConvert . millisToDays ( in . readLong ( ) ) ) ; sb . append ( "\t" ) ; in . readChar ( ) ; sb . append ( in . readDouble ( ) ) ; sb . append ( "\t" ) ; in . readChar ( ) ; sb . append ( in . readDouble ( ) ) ; sb . append ( "\t" ) ; in . readChar ( ) ; sb . append ( in . readDouble ( ) ) ; sb . append ( "\t" ) ; in . readChar ( ) ; sb . append ( in . readDouble ( ) ) ; sb . append ( "\t" ) ; in . readChar ( ) ; String code = in . readUTF ( ) ; sb . append ( code ) ; if ( code == "S" ) { sb . append ( in . readUTF ( ) ) ; } in . readChar ( ) ; sb . append ( in . readBoolean ( ) ) ; return sb . toString ( ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return null ; }
tr	9	public void paintComponents ( Board newBoard , boolean turn ) { board = newBoard ; pane . removeAll ( ) ; JButton [ ] buttons = new JButton [ 64 ] ; pane . setLayout ( new GridBagLayout ( ) ) ; GridBagConstraints c = new GridBagConstraints ( ) ; ButtonListener bl = new ButtonListener ( this , game ) ; ButtonObserver bo = new ButtonObserver ( game ) ; LinkedList < Coordinate > allowedFields = board . getAllowedFields ( game . orderMark ) ; for ( Integer index = 0 ; index < 64 ; index ++ ) { buttons [ index ] = new JButton ( index . toString ( ) ) ; c . fill = GridBagConstraints . BOTH ; c . gridx = board . coordinates [ index ] . getY ( ) ; c . gridy = board . coordinates [ index ] . getX ( ) ; c . weightx = 0.5 ; c . weighty = 0.5 ; c . insets = new Insets ( 3 , 3 , 3 , 3 ) ; buttons [ index ] . setPreferredSize ( new Dimension ( 50 , 50 ) ) ; buttons [ index ] . setText ( "" ) ; buttons [ index ] . setBackground ( board . getField ( board . coordinates [ index ] ) . getColor ( ) ) ; buttons [ index ] . setActionCommand ( index . toString ( ) ) ; buttons [ index ] . addActionListener ( bl ) ; bl . addObserver ( bo ) ; buttons [ index ] . setEnabled ( false ) ; for ( Coordinate coord : allowedFields ) { int field = coord . getIndex ( ) ; if ( field == index && turn ) { buttons [ index ] . setEnabled ( true ) ; buttons [ index ] . setBackground ( new Color ( 200 , 200 , 200 ) ) ; } if ( field == index && index == hint && turn ) { buttons [ index ] . setBackground ( Color . magenta ) ; } } pane . add ( buttons [ index ] , c ) ; } JButton button ; button = new JButton ( "Current Mark" ) ; c . fill = GridBagConstraints . BOTH ; c . gridx = 8 ; c . gridy = 1 ; c . weightx = 0.5 ; c . weighty = 0.5 ; c . insets = new Insets ( 0 , 15 , 0 , 15 ) ; button . setPreferredSize ( new Dimension ( 50 , 50 ) ) ; button . setText ( "" ) ; button . setBackground ( game . orderMark . getColor ( ) ) ; button . setEnabled ( false ) ; pane . add ( button , c ) ; button = new JButton ( "Hint" ) ; c . fill = GridBagConstraints . HORIZONTAL ; c . gridx = 8 ; c . gridy = 4 ; c . weightx = 0.5 ; c . weighty = 0.5 ; c . insets = new Insets ( 3 , 15 , 3 , 15 ) ; button . setPreferredSize ( new Dimension ( 150 , 50 ) ) ; button . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent event ) { giveHint ( board ) ; } } ) ; pane . add ( button , c ) ; if ( mainGUI . multiplayer ) { button = new JButton ( "Lobby" ) ; c . fill = GridBagConstraints . HORIZONTAL ; c . gridx = 8 ; c . gridy = 5 ; c . weightx = 0.5 ; c . weighty = 0.5 ; c . insets = new Insets ( 3 , 15 , 3 , 15 ) ; button . setPreferredSize ( new Dimension ( 150 , 50 ) ) ; button . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent event ) { frame . dispose ( ) ; LobbyGUI . lobbyGUI . startLobbyGUI ( ) ; } } ) ; pane . add ( button , c ) ; } if ( ! mainGUI . multiplayer ) { button = new JButton ( "Restart Game" ) ; c . fill = GridBagConstraints . HORIZONTAL ; c . gridx = 8 ; c . gridy = 5 ; c . weightx = 0.5 ; c . weighty = 0.5 ; c . insets = new Insets ( 3 , 15 , 3 , 15 ) ; button . setPreferredSize ( new Dimension ( 150 , 50 ) ) ; button . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent event ) { frame . dispose ( ) ; game . restartGame ( ) ; } } ) ; pane . add ( button , c ) ; } button = new JButton ( "Main Menu" ) ; c . fill = GridBagConstraints . HORIZONTAL ; c . gridx = 8 ; c . gridy = 6 ; c . weightx = 0.5 ; c . weighty = 0.5 ; c . insets = new Insets ( 3 , 15 , 3 , 15 ) ; button . setPreferredSize ( new Dimension ( 150 , 50 ) ) ; button . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent event ) { MainGUI . mainGUI . numberOfPlayers = "4" ; MainGUI . mainGUI . startMainGUI ( ) ; frame . dispose ( ) ; } } ) ; pane . add ( button , c ) ; button = new JButton ( "Quit" ) ; c . fill = GridBagConstraints . HORIZONTAL ; c . gridx = 8 ; c . gridy = 7 ; c . weightx = 0.5 ; c . weighty = 0.5 ; c . insets = new Insets ( 3 , 15 , 3 , 15 ) ; button . setPreferredSize ( new Dimension ( 150 , 50 ) ) ; button . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent event ) { frame . dispose ( ) ; } } ) ; pane . add ( button , c ) ; JLabel label ; label = new JLabel ( "Current Player:" ) ; label . setFont ( new Font ( "SANS_SERIF" , Font . PLAIN , 18 ) ) ; label . setPreferredSize ( new Dimension ( 300 , 50 ) ) ; c . fill = GridBagConstraints . BOTH ; c . gridx = 8 ; c . gridy = 0 ; c . weightx = 0.5 ; c . weighty = 0.5 ; c . insets = new Insets ( 3 , 15 , 0 , 15 ) ; pane . add ( label , c ) ; label = new JLabel ( game . order . get ( game . orderMark ) . getUsername ( ) ) ; label . setFont ( new Font ( "SANS_SERIF" , Font . PLAIN , 18 ) ) ; c . fill = GridBagConstraints . BOTH ; c . gridx = 8 ; c . gridy = 2 ; c . weightx = 0.5 ; c . weighty = 0.5 ; c . insets = new Insets ( 3 , 15 , 0 , 15 ) ; pane . add ( label , c ) ; pane . repaint ( ) ; pane . revalidate ( ) ; }
tr	2	@ Override protected void drawComponentName ( Graphics2D g ) { String name = getName ( ) ; if ( name != null ) { g . setColor ( Color . blue ) ; int fontSize = ( int ) ( ( width ) / name . length ( ) ) ; if ( fontSize > 16 ) fontSize = 16 ; g . setFont ( new Font ( Font . DIALOG , Font . PLAIN , fontSize ) ) ; float px , py ; FontMetrics fm = g . getFontMetrics ( ) ; int h = height / 10 ; px = ( int ) ( width - fm . stringWidth ( name ) ) / 2 ; py = h + ( int ) ( height - 3.6 * h - fm . getHeight ( ) ) / 2 ; int xx = ( int ) ( x ) ; int yy = ( int ) ( y ) ; g . drawString ( name , xx + px , yy + py + fm . getAscent ( ) ) ; } }
tr	9	public void draw ( Graphics gPanel , float cellHeight , MapPanel panel ) { String drawImageName = "" ; Color color = null ; boolean draw = false ; if ( getBuilding ( ) != null ) { drawImageName = getBuilding ( ) . getImageLocation ( ) ; } else if ( getUnit ( ) != null ) { drawImageName = getUnit ( ) . getImageLocation ( ) ; } if ( getBuilding ( ) instanceof Base ) { color = Teams . getTeamColor ( Teams . getTeamOfPlayer ( getBuilding ( ) . getOwner ( ) ) ) ; draw = true ; } else if ( getBuilding ( ) instanceof Factory ) { color = Teams . getTeamColor ( Teams . getTeamOfPlayer ( getBuilding ( ) . getOwner ( ) ) ) ; draw = true ; } else if ( getBuilding ( ) instanceof Barracks ) { color = Teams . getTeamColor ( Teams . getTeamOfPlayer ( getBuilding ( ) . getOwner ( ) ) ) ; draw = true ; } else if ( getUnit ( ) instanceof Marine ) { color = Teams . getTeamColor ( Teams . getTeamOfPlayer ( getUnit ( ) . getOwner ( ) ) ) ; draw = true ; } else if ( getUnit ( ) instanceof Tank ) { color = Teams . getTeamColor ( Teams . getTeamOfPlayer ( getUnit ( ) . getOwner ( ) ) ) ; draw = true ; } if ( draw ) { BufferedImage originalImage = new BufferedImage ( 90 , 90 , BufferedImage . TYPE_INT_RGB ) ; try { BufferedImage rawImage = new BufferedImage ( 90 , 90 , BufferedImage . TYPE_INT_RGB ) ; rawImage = ImageIO . read ( getClass ( ) . getResource ( drawImageName ) ) ; BufferedImage mask = generateMask ( rawImage , color , 0.3f ) ; originalImage = tint ( rawImage , mask ) ; } catch ( IOException e1 ) { System . out . println ( "Error getting map image!" ) ; } if ( getUnit ( ) != null && drawHealthBars ) { float healthScale = getUnit ( ) . getCurrentHealth ( ) / ( float ) getUnit ( ) . getBaseHealth ( ) ; Graphics g = originalImage . getGraphics ( ) ; int offset = 10 ; g . drawRect ( offset , 5 , ( int ) ( ( 90 - 2 * offset ) ) , 10 ) ; g . setColor ( Color . green ) ; g . fillRect ( offset + 1 , 5 + 1 , ( int ) ( ( 90 - 2 * offset ) * healthScale ) - 1 , 10 - 1 ) ; } else if ( getBuilding ( ) != null && drawHealthBars ) { float healthScale = getBuilding ( ) . getCurrentHealth ( ) / ( float ) getBuilding ( ) . getBaseHealth ( ) ; Graphics g = originalImage . getGraphics ( ) ; int offset = 10 ; g . drawRect ( offset , 5 , ( int ) ( ( 90 - 2 * offset ) ) , 10 ) ; g . setColor ( Color . green ) ; g . fillRect ( offset + 1 , 5 + 1 , ( int ) ( ( 90 - 2 * offset ) * healthScale ) - 1 , 10 - 1 ) ; } int newH = ( int ) ( 90 * panel . getZoom ( ) ) ; gPanel . drawImage ( originalImage , ( int ) ( this . getCellPosX ( ) * cellHeight ) , ( int ) ( this . getCellPosY ( ) * cellHeight ) , newH , newH , null ) ; } }
tr	9	private void method38 ( ) { for ( int i = - 1 ; i < playerCount ; i ++ ) { int j ; if ( i == - 1 ) j = myPlayerIndex ; else j = playerIndices [ i ] ; Player player = playerArray [ j ] ; if ( player != null && player . textCycle > 0 ) { player . textCycle -- ; if ( player . textCycle == 0 ) player . textSpoken = null ; } } for ( int k = 0 ; k < npcCount ; k ++ ) { int l = npcIndices [ k ] ; NPC npc = npcArray [ l ] ; if ( npc != null && npc . textCycle > 0 ) { npc . textCycle -- ; if ( npc . textCycle == 0 ) npc . textSpoken = null ; } } }
tr	6	private static int computeLongestCycle ( String string ) { final int length = string . length ( ) ; int maxcycle = 0 ; int i = 0 ; char [ ] chars = string . toCharArray ( ) ; for ( i = 0 ; i < length ; i ++ ) { boolean same = true ; char first = chars [ i ] ; int cycle = 0 ; for ( int j = i + 1 ; j < string . length ( ) ; j ++ ) { if ( chars [ j ] != first ) { same = false ; } else { final int l = ( j - i ) ; final boolean ok = equals ( chars , i , i + l , l ) ; if ( ok ) { cycle = l ; break ; } } } if ( same ) { cycle = 1 ; } if ( cycle > maxcycle ) { maxcycle = cycle ; } } return maxcycle ; }
tr	6	public static void vander ( final double [ ] x , final double [ ] w , final double [ ] q ) { int i , j , k , n = q . length ; double b , s , t , xx ; double [ ] c = new double [ n ] ; if ( n == 1 ) w [ 0 ] = q [ 0 ] ; else { for ( i = 0 ; i < n ; i ++ ) c [ i ] = 0.0 ; c [ n - 1 ] = - x [ 0 ] ; for ( i = 1 ; i < n ; i ++ ) { xx = - x [ i ] ; for ( j = ( n - 1 - i ) ; j < ( n - 1 ) ; j ++ ) c [ j ] += xx * c [ j + 1 ] ; c [ n - 1 ] += xx ; } for ( i = 0 ; i < n ; i ++ ) { xx = x [ i ] ; t = b = 1.0 ; s = q [ n - 1 ] ; for ( k = n - 1 ; k > 0 ; k -- ) { b = c [ k ] + xx * b ; s += q [ k - 1 ] * b ; t = xx * t + b ; } w [ i ] = s / t ; } } }
tr	8	public static void propagateZeros ( int [ ] [ ] arr ) { int width = arr . length ; int height = width == 0 ? 0 : arr [ 0 ] . length ; int [ ] rowsToZero = new int [ width ] ; int [ ] colsToZero = new int [ height ] ; for ( int ii = 0 ; ii < width ; ii ++ ) { for ( int jj = 0 ; jj < height ; jj ++ ) { if ( arr [ ii ] [ jj ] == 0 ) { rowsToZero [ ii ] = 1 ; colsToZero [ jj ] = 1 ; } } } for ( int ii = 0 ; ii < width ; ii ++ ) { for ( int jj = 0 ; jj < height ; jj ++ ) { if ( rowsToZero [ ii ] == 1 || colsToZero [ jj ] == 1 ) { arr [ ii ] [ jj ] = 0 ; } } } }
tr	4	private void rangeright ( javax . swing . event . ChangeEvent evt ) { Integer val = ( Integer ) oright . getValue ( ) ; if ( val > 100 || val < - 100 ) { new errorEmpety ( ) . main ( null ) ; if ( val > 100 ) oright . setValue ( "100" ) ; if ( val < - 100 ) oright . setValue ( "-100" ) ; } }
tr	6	void portNumberKeyReleased ( KeyEvent e ) { if ( client . getCommunicator ( ) != null ) { popUpWindow dialog = new popUpWindow ( this , "Wollen Sie sich wirklich vom Server abmelden ?" ) ; if ( dialog . getResult ( ) ) { client . disconnect ( ) ; } } if ( client . getCommunicator ( ) == null ) { isPortOk = ( portNumber . getText ( ) . length ( ) > 0 ) ; if ( isGameLoaded && isServerOk && isPortOk ) { connectToServer . setEnabled ( true ) ; } else { connectToServer . setEnabled ( false ) ; } } else { portNumber . setText ( client . getPort ( ) + "" ) ; } }
tr	8	public boolean hasRecoil ( ) { switch ( this ) { case BRAVE_BIRD : case DOUBLE_EDGE : case FLARE_BLITZ : case HEAD_SMASH : case SUBMISSION : case TAKE_DOWN : case VOLT_TACKLE : case WOOD_HAMMER : return true ; default : return false ; } }
tr	9	public static boolean isPalindrome ( String s ) { if ( s . length ( ) == 0 ) return true ; s = s . toLowerCase ( ) ; int i , j ; for ( i = 0 , j = s . length ( ) - 1 ; i < j ; i ++ , j -- ) { while ( ( s . charAt ( i ) < a || s . charAt ( i ) > z ) && ( s . charAt ( i ) < 0 || s . charAt ( i ) > 9 ) ) { i ++ ; if ( i >= s . length ( ) ) break ; } while ( ( s . charAt ( j ) < a || s . charAt ( j ) > z ) && ( s . charAt ( j ) < 0 || s . charAt ( j ) > 9 ) ) { j -- ; if ( j < 0 ) break ; } if ( i >= j ) break ; if ( s . charAt ( i ) != s . charAt ( j ) ) return false ; } return true ; }
tr	2	public static void initPreferences ( Preferences preferences ) { if ( pdfLaTeXFile == null ) preferences . put ( "pathToPDFLaTeXFile" , default ) ; else preferences . put ( "pathToPDFLaTeXFile" , pdfLaTeXFile . getAbsolutePath ( ) ) ; if ( pdfExportFolder == null ) preferences . put ( "pathToPDFExportFolder" , default ) ; else preferences . put ( "pathToPDFExportFolder" , pdfExportFolder . getAbsolutePath ( ) ) ; }
tr	3	void prVar ( Var v , int d ) { indent ( d ) ; if ( v instanceof SimpleVar ) prVar ( ( SimpleVar ) v , d ) ; else if ( v instanceof FieldVar ) prVar ( ( FieldVar ) v , d ) ; else if ( v instanceof SubscriptVar ) prVar ( ( SubscriptVar ) v , d ) ; else throw new Error ( "Print.prVar" ) ; }
tr	8	public boolean execute ( CommandSender sender , String [ ] args ) { String groupName = args [ 0 ] ; GroupManager groupManager = Citadel . getGroupManager ( ) ; Faction group = groupManager . getGroup ( groupName ) ; if ( group == null ) { sendMessage ( sender , ChatColor . RED , "Group doesn't exist" ) ; return true ; } String senderName = sender . getName ( ) ; if ( ! group . isFounder ( senderName ) && ! group . isModerator ( senderName ) && ! group . isMember ( senderName ) ) { sendMessage ( sender , ChatColor . RED , "Invalid permission to access this group" ) ; return true ; } sender . sendMessage ( new StringBuilder ( ) . append ( "\u00A7cGroup Name:\u00A7e " ) . append ( groupName ) . toString ( ) ) ; sender . sendMessage ( new StringBuilder ( ) . append ( "\u00A7cOwner:\u00A7e " ) . append ( group . getFounder ( ) ) . toString ( ) ) ; sender . sendMessage ( new StringBuilder ( ) . append ( "\u00A7cModerators:\u00A7e " ) . append ( groupManager . getModeratorsOfGroup ( groupName ) . size ( ) ) . toString ( ) ) ; sender . sendMessage ( new StringBuilder ( ) . append ( "\u00A7cMembers:\u00A7e " ) . append ( groupManager . getMembersOfGroup ( groupName ) . size ( ) ) . toString ( ) ) ; if ( group . isFounder ( senderName ) || group . isModerator ( senderName ) ) { String password = group . getPassword ( ) ; sender . sendMessage ( new StringBuilder ( ) . append ( "\u00A7cPassword:\u00A7e " ) . append ( password ) . toString ( ) ) ; String joinable = "" ; if ( password != null && ! password . equalsIgnoreCase ( "null" ) ) { joinable = "Yes" ; } else { joinable = "No" ; } sender . sendMessage ( new StringBuilder ( ) . append ( "\u00A7cJoinable:\u00A7e " ) . append ( joinable ) . toString ( ) ) ; } return true ; }
tr	2	public static String getAsString ( long bytes ) { String s = bytes + " B" ; String [ ] units = new String [ ] { "B" , "K" , "M" , "G" , "T" } ; for ( int i = 5 ; i > 0 ; i -- ) { double step = Math . pow ( 1024 , i ) ; if ( bytes > step ) { double absolute = Math . abs ( bytes / step ) ; s = String . format ( "%.2f" , absolute ) + " " + units [ i ] + "B" ; break ; } } return s ; }
tr	9	@ Override public void stateChanged ( ChangeEvent e ) { JSlider sliderOfInteraction = ( JSlider ) e . getSource ( ) ; switch ( sliderOfInteraction . getName ( ) ) { case "brightness" : for ( int x = 0 ; x < bi . getWidth ( ) ; x ++ ) { for ( int y = 0 ; y < bi . getHeight ( ) ; y ++ ) { currentSliderValue = sliderOfInteraction . getValue ( ) ; newColor = new Color ( bi . getRGB ( x , y ) ) ; Color . RGBtoHSB ( newColor . getRed ( ) , newColor . getGreen ( ) , newColor . getBlue ( ) , hsbvals ) ; brightness = currentSliderValue * .001f ; if ( brightness < - .9f ) brightness = ( - .9f ) ; if ( brightness > 1f ) brightness = 1f ; biOut . setRGB ( x , y , Color . HSBtoRGB ( hsbvals [ 0 ] , hsbvals [ 1 ] , ( hsbvals [ 2 ] + ( brightness ) < 0 ) ? 0 : ( hsbvals [ 2 ] + ( brightness ) > 1.0f ) ? 1.0f : hsbvals [ 2 ] + brightness ) ) ; } } break ; case "saturation" : for ( int x = 0 ; x < bi . getWidth ( ) ; x ++ ) { for ( int y = 0 ; y < bi . getHeight ( ) ; y ++ ) { currentSliderValue = sliderOfInteraction . getValue ( ) ; newColor = new Color ( bi . getRGB ( x , y ) ) ; Color . RGBtoHSB ( newColor . getRed ( ) , newColor . getGreen ( ) , newColor . getBlue ( ) , hsbvals ) ; saturation = currentSliderValue * .001f ; if ( saturation < - .9f ) saturation = ( - .9f ) ; if ( saturation > 1f ) saturation = 1f ; biOut . setRGB ( x , y , Color . HSBtoRGB ( hsbvals [ 0 ] , ( hsbvals [ 1 ] + saturation < 0 ) ? 0 : ( hsbvals [ 1 ] + ( saturation ) > 1.0f ) ? 1.0f : hsbvals [ 1 ] + saturation , hsbvals [ 2 ] ) ) ; } } break ; } oPanel . repaint ( ) ; }
tr	4	public static Remote findObject ( String name , String host , int lowPort , int highPort ) throws NotBoundException { boolean aRegistryFound = false ; for ( int rport = lowPort ; rport <= highPort ; rport += 1 ) try { return LocateRegistry . getRegistry ( host , rport ) . lookup ( name ) ; } catch ( NotBoundException e ) { aRegistryFound = true ; } catch ( RemoteException e ) { } if ( aRegistryFound ) throw new NotBoundException ( "name not bound in any registry on " + host + ": " + name ) ; else throw new NotBoundException ( "no registries found on " + host + "  ports " + lowPort + ".." + highPort ) ; }
tr	0	public void dbgSetMessageFont ( JGFont font ) { debugmessage_font = font ; }
tr	7	@ SuppressWarnings ( "RedundantIfStatement" ) @ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; GitVcsRoot that = ( GitVcsRoot ) o ; if ( ! localPath . equals ( that . localPath ) ) return false ; if ( repositoryUrl != null ? ! repositoryUrl . equals ( that . repositoryUrl ) : that . repositoryUrl != null ) return false ; if ( ! settings . equals ( that . settings ) ) return false ; return true ; }
tr	7	public int ladderLength ( String start , String end , HashSet < String > dict ) { if ( start . equals ( end ) ) return 0 ; if ( ! dict . contains ( start ) ) dict . add ( start ) ; if ( ! dict . contains ( end ) ) dict . add ( end ) ; LinkedList < String > q = new LinkedList < String > ( ) ; q . add ( start ) ; dict . remove ( start ) ; Hashtable < String , Integer > dists = new Hashtable < String , Integer > ( ) ; dists . put ( start , 0 ) ; while ( q . size ( ) != 0 ) { String word = q . remove ( ) ; int length = dists . get ( word ) ; String [ ] words = getWords ( word ) ; for ( int i = 0 ; i < words . length ; i ++ ) { if ( dict . remove ( words [ i ] ) ) { if ( words [ i ] . equals ( end ) ) return length + 2 ; dists . put ( words [ i ] , length + 1 ) ; q . add ( words [ i ] ) ; } } } return 0 ; }
tr	7	@ Override public void doMove ( ) { player = game . getCurrentPlayer ( ) ; field = game . getField ( ) ; int width = field . getWidth ( ) ; int height = field . getHeight ( ) ; evaluationResult = new EvalField ( width , height ) ; Exception exception = null ; for ( int i = 0 ; i < width * height ; i ++ ) { fieldcopy = UtilMethods . getCopyOfField ( field ) ; int x = i % width ; int y = i / width ; if ( UtilMethods . isPlacementPossible ( fieldcopy , x , y , player ) ) { String result = "" ; try { result = execute ( fieldcopy , x , y , player ) ; } catch ( Exception e ) { exception = e ; } Integer cellValue = null ; if ( result . equals ( "erfolgreich" ) ) { cellValue = getResult ( ) ; } if ( cellValue == null || cellValue < 0 ) { cellValue = 0 ; } evaluationResult . setValueAt ( x , y , cellValue ) ; } else { evaluationResult . setValueAt ( x , y , - 1 ) ; } } if ( exception != null ) { exception . printStackTrace ( ) ; showErrorMessage ( exception ) ; } chooseBestCell ( ) ; game . selectMove ( bestXCoord , bestYCoord ) ; }
tr	1	public int getLayoutHashCode ( ) { long n = System . nanoTime ( ) ; int h = super . getLayoutHashCode ( ) ; if ( isLeftToRight ( ) ) h += 416343 ; return 0 ; }
tr	4	@ Override public boolean hasNext ( ) { if ( end ) { return false ; } if ( next != null ) { return true ; } peeked = true ; while ( iterator . hasNext ( ) ) { final T n = iterator . next ( ) ; if ( predicate . evaluate ( n ) ) { next = n ; return true ; } } end = true ; return false ; }
tr	7	private String getBooleanString ( boolean booleanValue ) { switch ( format ) { case ONE_ZERO : return booleanValue ? "1" : "0" ; case TRUE_FALSE : return booleanValue ? "True" : "False" ; case YES_NO : return booleanValue ? "Yes" : "No" ; default : return booleanValue ? "Yes" : "No" ; } }
tr	6	public void keyPressed ( KeyEvent e ) { int offset = ( e . getKeyCode ( ) == KeyEvent . VK_UP ) ? ( - 7 ) : ( ( e . getKeyCode ( ) == KeyEvent . VK_DOWN ) ? ( + 7 ) : ( ( e . getKeyCode ( ) == KeyEvent . VK_LEFT ) ? ( - 1 ) : ( ( e . getKeyCode ( ) == KeyEvent . VK_RIGHT ) ? ( + 1 ) : 0 ) ) ) ; int newDay = getDay ( ) + offset ; if ( ( newDay >= 1 ) && ( newDay <= calendar . getMaximum ( Calendar . DAY_OF_MONTH ) ) ) { setDay ( newDay ) ; } }
tr	0	public OutputFormatterStyle ( String foreground , String background , Collection < String > options ) { this ( foreground , background , options . toArray ( new String [ 0 ] ) ) ; }
tr	3	public double [ ] [ ] toArray ( ) { double [ ] [ ] result = new double [ this . getRows ( ) ] [ this . getColumns ( ) ] ; for ( int i = 0 ; i < result . length ; i ++ ) { for ( int j = 0 ; j < result [ i ] . length ; j ++ ) { if ( ! this . isSparse ( i , j ) ) result [ i ] [ j ] = this . getSimilarity ( i , j ) ; } } return result ; }
tr	0	public TitleImp ( ) { this . line = new LineImp ( this ) ; }
tr	1	public void setAttribute ( String name , String value ) { if ( attributes == null ) attributes = new HashMap < String , String > ( ) ; attributes . put ( name , value ) ; }
tr	6	public void start ( ) throws IllegalStateException { if ( instructions == null || endgamewindow == null || gameboard == null || lobby == null || loginsingup == null || newgame == null ) throw new IllegalStateException ( ) ; done = false ; attempConnection ( ) ; setState ( ModelStates . loginsingup ) ; newgame . setDefaultCloseOperation ( javax . swing . WindowConstants . HIDE_ON_CLOSE ) ; endgamewindow . setDefaultCloseOperation ( javax . swing . WindowConstants . HIDE_ON_CLOSE ) ; Thread myThread = new Thread ( this ) ; myThread . start ( ) ; }
tr	7	public CameraFeed ( JPanel content , String view ) { String url = "" ; boolean contains = false ; String text = "" ; JLabel viewText = new JLabel ( ) ; viewText . setFont ( new Font ( "Sans Serif" , Font . BOLD , 30 ) ) ; for ( String i : screens ) { if ( i . equals ( view ) ) { url += "Images/" + view + "_large.jpg" ; contains = true ; if ( i == screens [ 0 ] ) { text = "Front Camera View" ; } if ( i == screens [ 1 ] ) { text = "Rear Camera View" ; } if ( i == screens [ 2 ] ) { text = "Left Camera View" ; } if ( i == screens [ 3 ] ) { text = "Right Camera View" ; } } } viewText . setText ( "Viewing: " + text ) ; if ( contains == true ) { ImageIcon viewImage = new ImageIcon ( CameraFeed . class . getResource ( url ) ) ; JLabel l = new JLabel ( viewImage ) ; add ( viewText ) ; add ( l ) ; } else { add ( new JLabel ( "Invalid Image  Please add image to the Camera Feed class" ) ) ; } }
tr	4	public int getCellAge ( int x , int y ) { if ( y < 0 || y >= getHeight ( ) ) return Integer . MAX_VALUE ; if ( x < 0 || x >= getWidth ( ) ) return Integer . MAX_VALUE ; return world [ y ] [ x ] ; }
tr	4	private Iterator < EvlToken > openHexFile ( String fileName ) { try { input = new BufferedReader ( new FileReader ( fileName ) ) ; } catch ( FileNotFoundException e ) { throw new RuntimeException ( ) ; } List < EvlToken > evlTokens = new LinkedList < EvlToken > ( ) ; String line ; int lineNo ; try { for ( lineNo = 1 , line = input . readLine ( ) ; line != null ; lineNo ++ , line = input . readLine ( ) ) { if ( ! EvlTokenFile . extractHexTokensFromLine ( line , lineNo ++ , evlTokens ) ) { input . close ( ) ; throw new RuntimeException ( ) ; } } input . close ( ) ; } catch ( IOException e ) { throw new RuntimeException ( ) ; } return evlTokens . iterator ( ) ; }
tr	9	public Administratorapp ( ) throws FileNotFoundException , IOException { int i ; BufferedReader fisier ; try { listModelSecretari = new DefaultListModel ( ) ; listModelProfesori = new DefaultListModel ( ) ; listModelElevi = new DefaultListModel ( ) ; fisier = new BufferedReader ( new FileReader ( "credentials" ) ) ; ArrayList < String > vector = new ArrayList < > ( ) ; for ( String line ; ( line = fisier . readLine ( ) ) != null ; ) { vector . add ( line ) ; } for ( i = 0 ; i < vector . size ( ) ; i = i + 5 ) { if ( vector . get ( i + 4 ) . equals ( "Secretar" ) ) listModelSecretari . addElement ( vector . get ( i ) ) ; if ( vector . get ( i + 4 ) . equals ( "Profesor" ) ) listModelProfesori . addElement ( vector . get ( i ) ) ; if ( vector . get ( i + 4 ) . equals ( "Elev" ) ) listModelElevi . addElement ( vector . get ( i ) ) ; } } catch ( FileNotFoundException ex ) { Logger . getLogger ( Login . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( IOException ex ) { Logger . getLogger ( Login . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } initComponents ( ) ; BufferedReader fisier2 = new BufferedReader ( new FileReader ( "clase" ) ) ; ArrayList < String > vector = new ArrayList < > ( ) ; for ( String line ; ( line = fisier2 . readLine ( ) ) != null ; ) { vector . add ( line ) ; } for ( int j = 0 ; j < vector . size ( ) ; j ++ ) clasaDeSters . addItem ( vector . get ( j ) ) ; BufferedReader fisier3 = new BufferedReader ( new FileReader ( "fmaterii" ) ) ; ArrayList < String > vector2 = new ArrayList < > ( ) ; for ( String line ; ( line = fisier3 . readLine ( ) ) != null ; ) { vector2 . add ( line ) ; } for ( int k = 0 ; k < vector . size ( ) ; k ++ ) materieDeSters . addItem ( vector2 . get ( k ) ) ; }
tr	3	protected void fireTreeNodesRemoved ( Object source , Object [ ] path , int [ ] childIndices , Object [ ] children ) { Object [ ] listeners = listenerList . getListenerList ( ) ; TreeModelEvent e = null ; for ( int i = listeners . length - 2 ; i >= 0 ; i -= 2 ) { if ( listeners [ i ] == TreeModelListener . class ) { if ( e == null ) { e = new TreeModelEvent ( source , path , childIndices , children ) ; } ( ( TreeModelListener ) listeners [ i + 1 ] ) . treeNodesRemoved ( e ) ; } } }
tr	9	@ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; IfNode other = ( IfNode ) obj ; if ( elseifs == null ) { if ( other . elseifs != null ) return false ; } else if ( ! elseifs . equals ( other . elseifs ) ) return false ; if ( exp1 == null ) { if ( other . exp1 != null ) return false ; } else if ( ! exp1 . equals ( other . exp1 ) ) return false ; if ( stateSeq1 == null ) { if ( other . stateSeq1 != null ) return false ; } else if ( ! stateSeq1 . equals ( other . stateSeq1 ) ) return false ; if ( stateSeq2 == null ) { if ( other . stateSeq2 != null ) return false ; } else if ( ! stateSeq2 . equals ( other . stateSeq2 ) ) return false ; return true ; }
tr	3	public int getIndexOfStrength ( int strength ) { ArrayList < Integer > list = new ArrayList < Integer > ( ) ; for ( Integer i : this . strength ) { list . add ( i ) ; } Collections . sort ( list ) ; int toSearch = list . get ( strength ) ; for ( int i = 0 ; i < this . strength . length ; i ++ ) { if ( toSearch == this . strength [ i ] ) { return i ; } } return - 1 ; }
tr	7	public final JPoclASTParser . parametersDecl_return parametersDecl ( ) throws RecognitionException { JPoclASTParser . parametersDecl_return retval = new JPoclASTParser . parametersDecl_return ( ) ; retval . start = input . < ( 1 ) ; TypeTree root_0 = null ; Token char_literal45 = null ; JPoclASTParser . parameterDecl_return parameterDecl44 = null ; JPoclASTParser . parameterDecl_return parameterDecl46 = null ; TypeTree char_literal45_tree = null ; RewriteRuleTokenStream stream_28 = new RewriteRuleTokenStream ( adaptor , "token 28" ) ; RewriteRuleSubtreeStream stream_parameterDecl = new RewriteRuleSubtreeStream ( adaptor , "rule parameterDecl" ) ; try { { pushFollow ( FOLLOW_parameterDecl_in_parametersDecl457 ) ; parameterDecl44 = parameterDecl ( ) ; state . _fsp -- ; stream_parameterDecl . add ( parameterDecl44 . getTree ( ) ) ; loop8 : do { int alt8 = 2 ; int LA8_0 = input . LA ( 1 ) ; if ( ( LA8_0 == 28 ) ) { alt8 = 1 ; } switch ( alt8 ) { case 1 : { char_literal45 = ( Token ) match ( input , 28 , FOLLOW_28_in_parametersDecl460 ) ; stream_28 . add ( char_literal45 ) ; pushFollow ( FOLLOW_parameterDecl_in_parametersDecl462 ) ; parameterDecl46 = parameterDecl ( ) ; state . _fsp -- ; stream_parameterDecl . add ( parameterDecl46 . getTree ( ) ) ; } break ; default : break loop8 ; } } while ( true ) ; retval . tree = root_0 ; RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream ( adaptor , "rule retval" , retval != null ? retval . tree : null ) ; root_0 = ( TypeTree ) adaptor . nil ( ) ; { { TypeTree root_1 = ( TypeTree ) adaptor . nil ( ) ; root_1 = ( TypeTree ) adaptor . becomeRoot ( ( TypeTree ) adaptor . create ( PDECS , "PDECS" ) , root_1 ) ; if ( ! ( stream_parameterDecl . hasNext ( ) ) ) { throw new RewriteEarlyExitException ( ) ; } while ( stream_parameterDecl . hasNext ( ) ) { adaptor . addChild ( root_1 , stream_parameterDecl . nextTree ( ) ) ; } stream_parameterDecl . reset ( ) ; adaptor . addChild ( root_0 , root_1 ) ; } } retval . tree = root_0 ; } retval . stop = input . < ( - 1 ) ; retval . tree = ( TypeTree ) adaptor . rulePostProcessing ( root_0 ) ; adaptor . setTokenBoundaries ( retval . tree , retval . start , retval . stop ) ; } catch ( RecognitionException re ) { reportError ( re ) ; } finally { } return retval ; }
