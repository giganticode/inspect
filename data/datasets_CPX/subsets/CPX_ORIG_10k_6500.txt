va	7	@ Override public List < Block > getBlocks ( String blockName , String outerBlockNames ) throws RemoteException { String BlockName = null ; String BlockText = null ; if ( outerBlockNames == null ) { return null ; } if ( ( null == blockName . toString ( ) ) || ( "" == blockName . toString ( ) ) ) { return null ; } GetRemoteConf ( remoteConf ) ; if ( "" . equals ( outerBlockNames . trim ( ) ) ) { if ( ( null == confText ) || ( "" == confText ) ) { confText = ReadConf ( ) ; } BlockName = "nginx.conf" ; BlockText = confText ; } else { if ( ! outerBlockNames . contains ( ":" ) ) { outerBlockNames += ":0" ; } HashMap < String , String > objHashMap = EditCommon ( outerBlockNames ) ; BlockName = objHashMap . get ( "lastblockname" ) ; BlockText = objHashMap . get ( "blocktext" ) ; } RecBlock objRecBlock = new RecBlock ( ) ; objRecBlock . setName ( BlockName ) ; objRecBlock . SetBlockText ( BlockText ) ; return objRecBlock . getBlocks ( blockName ) ; }
va	7	protected void onBeforeRender ( ) { MySession sess = ( MySession ) getSession ( ) ; Board bd = sess . getBoard ( ) ; add ( new SimpleAttributeModifier ( "style" , "border-style:solid;border-width:1px;border-color:#009200;" ) ) ; if ( bd . getGameStatus ( ) == GameStatus . GAMING ) { if ( bd . getPutStoneStatus ( _num ) != StoneType . NONE ) { removeOnClick ( ) ; add ( ONCLICK_DISABLE_CELL ) ; } else { PlayerInfo nextturn = sess . getTurn ( ) ; boolean [ ] enableputarray = bd . enablePutStone ( _num , nextturn . getStoneType ( ) ) ; boolean enableput = false ; for ( int i = 0 ; i < enableputarray . length ; i ++ ) { if ( enableputarray [ i ] == true ) { enableput = true ; break ; } } if ( enableput ) { add ( new SimpleAttributeModifier ( "style" , "border-style:solid;border-width:1px;border-color:yellow;" ) ) ; if ( ! getBehaviors ( SimpleAttributeModifier . class ) . isEmpty ( ) ) { removeOnClick ( ) ; } } else { removeOnClick ( ) ; add ( ONCLICK_DISABLE_CELL ) ; } } } else { removeOnClick ( ) ; add ( ONCLICK_DISABLE_CELL ) ; } remove ( "cellimage" + _num ) ; if ( bd . getReverseBoard ( ) [ _num ] != 0 ) { add ( new Image ( "cellimage" + _num , STONE [ bd . getReverseBoard ( ) [ _num ] ] ) ) ; } else { add ( new Image ( "cellimage" + _num , STONE [ bd . getPutStoneStatus ( _num ) ] ) ) ; } super . onBeforeRender ( ) ; }
va	2	public void damage ( int amount ) { if ( System . currentTimeMillis ( ) > DAMAGE_DELAY + lastDamaged ) { life -= amount ; if ( life < 0 ) life = 0 ; lastDamaged = System . currentTimeMillis ( ) ; } }
va	5	private void bfsTravel ( TreeNode root , int level , List < List < Integer >> result ) { Queue < TreeNode > maintain = new LinkedList < TreeNode > ( ) ; Queue < TreeNode > visited = new LinkedList < TreeNode > ( ) ; List < Integer > list = null ; TreeNode tmp = null ; maintain . offer ( root ) ; while ( ! maintain . isEmpty ( ) ) { list = new ArrayList < Integer > ( ) ; while ( ! maintain . isEmpty ( ) ) { list . add ( maintain . peek ( ) . val ) ; visited . offer ( maintain . poll ( ) ) ; } result . add ( list ) ; while ( ! visited . isEmpty ( ) ) { tmp = visited . poll ( ) ; if ( tmp . left != null ) maintain . offer ( tmp . left ) ; if ( tmp . right != null ) maintain . offer ( tmp . right ) ; } } }
va	9	public String checkDataEntry ( ) { if ( efast_analysis_Panel2 . resultFileName . getText ( ) . equals ( "" ) ) { return "Error on Parameter Data Entry. Make sure all the boxes have been completed" ; } else if ( efast_analysis_Panel2 . alternativeFileName . getText ( ) . equals ( "" ) ) { return "Alternative File Name cannot be blank. If this is not applicable to you  enter NULL in the entry box" ; } else if ( ! efast_analysis_Panel2 . resultFileFormat . getText ( ) . equals ( "csv" ) && ! efast_analysis_Panel2 . resultFileFormat . getText ( ) . equals ( "xml" ) ) { return "Result file format must be xml or csv" ; } else if ( efast_analysis_Panel2 . timepoints . getText ( ) . equals ( "" ) ) { return "Timepoints cannot be blank. If this is not applicable to you  enter NULL in the entry box" ; } else if ( efast_analysis_Panel2 . timepointScale . getText ( ) . equals ( "" ) ) { return "Timepoint Scale cannot be blank. If this is not applicable to you  enter NULL in the entry box" ; } else if ( efast_analysis_Panel2 . resultFileFormat . getText ( ) . equals ( "csv" ) ) { if ( efast_analysis_Panel2 . outputColumnStart . getText ( ) . equals ( "" ) || efast_analysis_Panel2 . outputColumnEnd . getText ( ) . equals ( "" ) || efast_analysis_Panel2 . outputColumnStart . getText ( ) . equals ( "NULL" ) || efast_analysis_Panel2 . outputColumnEnd . getText ( ) . equals ( "NULL" ) ) { return "As you are using CSV file input  the output column start and end column fields cannot be blank" ; } else { try { Integer . parseInt ( efast_analysis_Panel2 . outputColumnStart . getText ( ) ) ; Integer . parseInt ( efast_analysis_Panel2 . outputColumnEnd . getText ( ) ) ; return null ; } catch ( NumberFormatException e ) { return "Output column start and end fields must be integers" ; } } } else { return null ; } }
va	4	public Map < long , double > avgWrongTriesOfEachProblem ( Date startDate , Date endDate ) { ResultSet rs = null ; PreparedStatement statement = null ; Connection connection = null ; Map < long , double > problemIdWrongAvgMap = null ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Calculando a m\u00E9dia de submiss\u00F5es erradas para cada problema..." ) ; } try { if ( logger . isDebugEnabled ( ) ) { logger . debug ( AVG_WRONG_TRIES_OF_EACH_PROBLEM ) ; } connection = Connector . getConnection ( ) ; statement = connection . prepareStatement ( AVG_WRONG_TRIES_OF_EACH_PROBLEM ) ; statement . setLong ( 1 , Submission . CORRECT ) ; statement . setDate ( 2 , startDate ) ; statement . setDate ( 3 , endDate ) ; rs = statement . executeQuery ( ) ; problemIdWrongAvgMap = new HashMap < long , double > ( ) ; while ( rs . next ( ) ) { problemIdWrongAvgMap . put ( rs . getLong ( "problem_id" ) , rs . getDouble ( "avg_wrong" ) ) ; } } catch ( SQLException e ) { logger . error ( e . getMessage ( ) , e ) ; } finally { ResourcesUtil . release ( rs , statement , connection ) ; } return problemIdWrongAvgMap ; }
va	2	public static boolean allA ( String line ) { char last = A ; int count = 1 ; for ( int i = 0 ; i < line . length ( ) ; i ++ ) { if ( line . charAt ( i ) != last ) return false ; last = line . charAt ( i ) ; } return true ; }
va	5	public void load ( ) throws FileNotFoundException , IOException { if ( f == null ) return ; BufferedReader br = new BufferedReader ( new FileReader ( f ) ) ; String l ; map . clear ( ) ; while ( ( l = br . readLine ( ) ) != null ) { if ( l . isEmpty ( ) || l . startsWith ( "#" ) ) continue ; String [ ] t = l . split ( ":" , 2 ) ; if ( t . length != 2 ) continue ; map . put ( t [ 0 ] , t [ 1 ] . trim ( ) ) ; } br . close ( ) ; }
va	1	public void registerNewCustomer ( Customer c ) { if ( uowc != null ) { uowc . registerNewCustomers ( c ) ; } }
va	2	@ Override public void setHostname ( String hostname ) { if ( hostname == null || hostname . length ( ) == 0 ) throw new DatabaseException ( "Hostname cannot be null or empty." ) ; this . hostname = hostname ; }
va	9	public String checkDataEntry ( ) { if ( oat_analysis_Panel2 . resultFileName . getText ( ) . equals ( "" ) ) { return "Error on Parameter Data Entry. Make sure all the boxes have been completed" ; } else if ( oat_analysis_Panel2 . alternativeFileName . getText ( ) . equals ( "" ) ) { return "Alternative File Name cannot be blank. If this is not applicable to you  enter NULL in the entry box" ; } else if ( ! oat_analysis_Panel2 . resultFileFormat . getText ( ) . equals ( "csv" ) && ! oat_analysis_Panel2 . resultFileFormat . getText ( ) . equals ( "xml" ) ) { return "Result file format must be xml or csv" ; } else if ( oat_analysis_Panel2 . timepoints . getText ( ) . equals ( "" ) ) { return "Timepoints cannot be blank. If this is not applicable to you  enter NULL in the entry box" ; } else if ( oat_analysis_Panel2 . timepointScale . getText ( ) . equals ( "" ) ) { return "Timepoint Scale cannot be blank. If this is not applicable to you  enter NULL in the entry box" ; } else if ( oat_analysis_Panel2 . resultFileFormat . getText ( ) . equals ( "csv" ) ) { if ( oat_analysis_Panel2 . outputColumnStart . getText ( ) . equals ( "" ) || oat_analysis_Panel2 . outputColumnEnd . getText ( ) . equals ( "" ) || oat_analysis_Panel2 . outputColumnStart . getText ( ) . equals ( "NULL" ) || oat_analysis_Panel2 . outputColumnEnd . getText ( ) . equals ( "NULL" ) ) { return "As you are using CSV file input  the output column start and end column fields cannot be blank" ; } else { try { Integer . parseInt ( oat_analysis_Panel2 . outputColumnStart . getText ( ) ) ; Integer . parseInt ( oat_analysis_Panel2 . outputColumnEnd . getText ( ) ) ; return null ; } catch ( NumberFormatException e ) { return "Output column start and end fields must be integers" ; } } } else { return null ; } }
va	8	@ Override public void run ( ) { try { ServerSocketChannel serverSocketChannel = ServerSocketChannel . open ( ) ; broadcaster = new Broadcaster ( ) ; ServerSocket serverSocket = serverSocketChannel . socket ( ) ; InetSocketAddress inetSockAddr = null ; ArrayList < InetAddress > addrList = Collections . list ( netInterface . getInetAddresses ( ) ) ; for ( InetAddress addr : addrList ) { if ( addr instanceof Inet4Address ) { inetSockAddr = new InetSocketAddress ( addr , port ) ; break ; } } if ( inetSockAddr == null ) { for ( InetAddress addr : addrList ) { if ( addr instanceof Inet6Address ) { inetSockAddr = new InetSocketAddress ( addr , port ) ; break ; } } } serverSocket . bind ( inetSockAddr ) ; System . out . println ( "Server: Bound to " + inetSockAddr + " on " + netInterface . getName ( ) + " interface." ) ; System . out . println ( "Server: Waiting for clients to connect..." ) ; while ( true ) { SocketChannel socketChannel = serverSocketChannel . accept ( ) ; Socket socket = socketChannel . socket ( ) ; socket . setKeepAlive ( true ) ; socket . setTcpNoDelay ( true ) ; ServerSideCommunicator waiter = new ServerSideCommunicator ( password , socketChannel , this ) ; Thread thread = new Thread ( waiter ) ; thread . start ( ) ; } } catch ( IOException e ) { if ( e instanceof ClosedByInterruptException ) { Thread . interrupted ( ) ; stopServer ( ) ; } else { e . printStackTrace ( ) ; } } }
va	3	public void handleElementClicked ( final int x , final int y ) { final LetterElement clicked = getElementAt ( x , y ) ; if ( clicked == null ) { return ; } else if ( clicked . isWildCard ( ) ) { final Cell cell = lookupCell ( clicked ) ; if ( cell != null ) { matrix [ cell . col ] [ cell . row ] = getVowel ( ) ; } } else { updateSelection ( clicked , ! isSelected ( clicked ) ) ; } }
va	9	public static void antiGoalRefine ( RequirementGraph req_model , String type , int scope ) throws IOException , ScriptException { String formal_model = req_model . generateFormalExpressionToFile ( scope ) ; String security_pattern_knowledge_file = InfoEnum . current_directory + "/dlv/models/security_model_" + req_model . getLayer ( ) . toLowerCase ( ) + ".dl " ; String threat_knowledge = InfoEnum . current_directory + "/dlv/anti_goal_rules/threat_knowledge.rule " ; String refine_rule = "" ; if ( type . equals ( InfoEnum . RefinementDimension . ASSET . name ( ) ) ) { refine_rule = InfoEnum . current_directory + "/dlv/dlv -silent -nofacts " + InfoEnum . current_directory + "/dlv/anti_goal_rules/refine_asset.rule " + InfoEnum . current_directory + "/dlv/models/asset_model.dl " + formal_model ; } else if ( type . equals ( InfoEnum . RefinementDimension . PROTECTION . name ( ) ) ) { refine_rule = InfoEnum . current_directory + "/dlv/dlv -silent -nofacts " + InfoEnum . current_directory + "/dlv/anti_goal_rules/refine_protection.rule " + formal_model + security_pattern_knowledge_file + threat_knowledge ; } else if ( type . equals ( InfoEnum . RefinementDimension . TARGET . name ( ) ) ) { refine_rule = InfoEnum . current_directory + "/dlv/dlv -silent -nofacts " + InfoEnum . current_directory + "/dlv/anti_goal_rules/refine_target.rule " + formal_model + security_pattern_knowledge_file + threat_knowledge ; } else if ( type . equals ( InfoEnum . RefinementDimension . THREAT . name ( ) ) ) { refine_rule = InfoEnum . current_directory + "/dlv/dlv -silent -nofacts " + InfoEnum . current_directory + "/dlv/anti_goal_rules/refine_threat.rule " + formal_model + security_pattern_knowledge_file + threat_knowledge ; } else { CommandPanel . logger . severe ( "Error refinement type!" ) ; return ; } Runtime rt = Runtime . getRuntime ( ) ; Process pr = rt . exec ( refine_rule ) ; BufferedReader input = new BufferedReader ( new InputStreamReader ( pr . getInputStream ( ) ) ) ; String line = null ; LinkedList < RequirementElement > refined_elems = new LinkedList < RequirementElement > ( ) ; while ( ( line = input . readLine ( ) ) != null ) { line = line . substring ( 1 , line . length ( ) - 1 ) ; String [ ] result = line . split ( "  " ) ; for ( String s : result ) { if ( s . startsWith ( "and_refined_anti_goal" ) && ( s . contains ( "unknown" ) == false ) ) { s = s . replaceAll ( "and_refined_anti_goal\\(" , "" ) ; s = s . replaceAll ( "\\)" , "" ) ; String [ ] ag_args = s . split ( " " ) ; AntiGoal refined_ag = ( AntiGoal ) req_model . findElementByFormalName ( ag_args [ 4 ] ) ; AntiGoal new_ag = new AntiGoal ( ag_args [ 0 ] , ag_args [ 1 ] , ag_args [ 2 ] , ag_args [ 3 ] , InfoEnum . RequirementElementType . ANTI_GOAL . name ( ) , refined_ag . getLayer ( ) ) ; req_model . getElements ( ) . add ( new_ag ) ; RequirementLink new_and_refine = new RequirementLink ( InfoEnum . RequirementLinkType . AND_REFINE . name ( ) , new_ag , refined_ag ) ; req_model . getLinks ( ) . add ( new_and_refine ) ; refined_ag . and_refine_links . add ( new_and_refine ) ; if ( refined_elems . indexOf ( refined_ag ) == - 1 ) { refined_elems . add ( refined_ag ) ; } } if ( s . startsWith ( "refined_anti_goal" ) && ( s . contains ( "unknown" ) == false ) ) { s = s . replaceAll ( "refined_anti_goal\\(" , "" ) ; s = s . replaceAll ( "\\)" , "" ) ; String [ ] ag_args = s . split ( " " ) ; AntiGoal refined_ag = ( AntiGoal ) req_model . findElementByFormalName ( ag_args [ 4 ] ) ; AntiGoal new_ag = new AntiGoal ( ag_args [ 0 ] , ag_args [ 1 ] , ag_args [ 2 ] , ag_args [ 3 ] , InfoEnum . RequirementElementType . ANTI_GOAL . name ( ) , refined_ag . getLayer ( ) ) ; req_model . getElements ( ) . add ( new_ag ) ; RequirementLink new_refine = new RequirementLink ( InfoEnum . RequirementLinkType . REFINE . name ( ) , new_ag , refined_ag ) ; req_model . getLinks ( ) . add ( new_refine ) ; drawRefinement ( refined_ag , new_refine ) ; } } } drawAndRefinement ( refined_elems ) ; }
va	7	@ Override public void actionPerformed ( ActionEvent event ) { log . info ( "Buying " + type ) ; if ( "Worker" . equals ( type ) ) { Site homeSite = landscape . getHomeSite ( ) ; int x = homeSite . getX ( ) ; int y = homeSite . getY ( ) ; int z = homeSite . getZ ( ) ; List < Site > sites = new ArrayList < Site > ( ) ; if ( landscape . getSite ( x + 1 , y , z ) . isWalkable ( ) ) { sites . add ( landscape . getSite ( x + 1 , y , z ) ) ; } if ( landscape . getSite ( x - 1 , y , z ) . isWalkable ( ) ) { sites . add ( landscape . getSite ( x - 1 , y , z ) ) ; } if ( landscape . getSite ( x , y + 1 , z ) . isWalkable ( ) ) { sites . add ( landscape . getSite ( x , y + 1 , z ) ) ; } if ( landscape . getSite ( x , y - 1 , z ) . isWalkable ( ) ) { sites . add ( landscape . getSite ( x , y - 1 , z ) ) ; } if ( sites . size ( ) > 0 ) { Random rng = new Random ( ) ; if ( landscape . changeMoney ( - WORKERCOST ) ) { homeSite = sites . get ( rng . nextInt ( sites . size ( ) ) ) ; Agent agent = new Agent ( homeSite ) ; landscape . addAgent ( agent ) ; } } } else { landscape . addAction ( new Buy ( type , landscape ) ) ; } }
va	1	public void connect ( String databaseUrl , String newUsername , String newPassword ) throws SQLException { String dbURL = databaseUrl + "?user=" + newUsername + "&password=" + newPassword ; if ( connection == null ) { connection = ( Connection ) DriverManager . getConnection ( dbURL ) ; } }
va	1	public Iterator < ? > iterator ( ) { outprint += "iterator()\n" ; return new HashSetIterator ( ) ; }
va	1	public static Json getInstance ( ) { if ( instance == null ) { instance = new Json ( ) ; } return instance ; }
va	6	public static void generateNewAnimationFrameSequenceXmlFile ( String path ) { if ( path == null ) return ; File file = new File ( path ) ; if ( ! file . exists ( ) && ! file . isDirectory ( ) ) { if ( ! path . endsWith ( ".xml" ) ) { path = path + ".xml" ; } file = new File ( path ) ; ArrayList < AnimationFrame > createdFrames = new ArrayList < AnimationFrame > ( ) ; for ( String dirFileName : file . getParentFile ( ) . list ( ) ) { if ( dirFileName . endsWith ( ".png" ) ) { System . out . println ( "Auto-included png file in directory: " + dirFileName ) ; createdFrames . add ( new AnimationFrame ( dirFileName , 0 , 0 , 1 , "" , "" , "" , 0 , 0 ) ) ; } } AnimationFrameSequenceFile . writeAnimationFrameSequenceToXml ( path , createdFrames ) ; } }
va	0	public static int extractSymbolSize ( long commonFecOTI ) { return unsignSymbolSize ( ( int ) commonFecOTI ) ; }
va	4	boolean testConstructorExceptionIsCaught ( Tester t ) { boolean caught = false ; try { Date b34453323 = new Date ( 3445 , 33 , 23 ) ; } catch ( IllegalArgumentException exc ) { String message = exc . getMessage ( ) ; if ( ( message . equals ( MSG_INVALID_YEAR_IN_DATE ) ) || ( message . equals ( MSG_INVALID_MONTH_IN_DATE ) ) || ( message . equals ( MSG_INVALID_DAY_IN_DATE ) ) ) caught = true ; } return t . checkExpect ( caught , "Should be success: constructor exception is caught" ) ; }
va	0	public static CharApp getInstance ( ) { return instance ; }
va	5	public void makeTree ( ) { Vector < FileInfo > fileInfoList ; DefaultMutableTreeNode node ; root . removeAllChildren ( ) ; root . setUserObject ( "root" + ClientLauncher . getFileMgr ( ) . getRootDirID ( ) ) ; fileTree . removeAll ( ) ; fileInfoList = ClientLauncher . getFileMgr ( ) . getFileInfoList ( ) ; for ( FileInfo fileInfo : fileInfoList ) { node = new DefaultMutableTreeNode ( fileInfo . getName ( ) ) ; if ( fileInfo . getDepth ( ) . equals ( "1" ) ) { root . add ( node ) ; } else { DefaultMutableTreeNode temp ; temp = root ; while ( temp != null ) { if ( temp . toString ( ) . equals ( fileInfo . getParent ( ) ) && temp . getLevel ( ) == ( Integer . parseInt ( fileInfo . getDepth ( ) ) - 1 ) ) { temp . add ( node ) ; } temp = temp . getNextNode ( ) ; } } } }
va	5	public SynthesisFilter ( int channelnumber , int factor , int [ ] eq0 , int _sampleFrequency , boolean _ulaw ) { ulaw = _ulaw ; if ( d == null ) { d = load_d ( ) ; d16 = splitArray ( d , 16 ) ; } v1 = new int [ 512 ] ; v2 = new int [ 512 ] ; samples = new int [ 32 ] ; channel = channelnumber ; scalefactor = factor ; setEQ ( = ) ; reset ( ) ; sampleFrequency = _sampleFrequency ; remaining_offset = 0 ; if ( ulaw ) { switch ( sampleFrequency ) { case AudioFrameHeader . THIRTYTWO : highest_subband = 7 ; offset1 = offset2 = 3 ; break ; case AudioFrameHeader . FORTYFOUR_POINT_ONE : highest_subband = 5 ; offset1 = 4 ; offset2 = 5 ; break ; case AudioFrameHeader . FORTYEIGHT : highest_subband = 4 ; offset1 = offset2 = 5 ; } } else { highest_subband = 31 ; offset1 = offset2 = 0 ; } }
va	1	public static ResponseDTO showPassengers ( RequestDTO reqObj , PassengerDAO passengerDAO ) { log . debug ( "Start: showPassengers()" ) ; List < PassengerDTO > passengers ; int trainNumber = ( ( List < ScheduleDTO > ) reqObj . getObject ( ) ) . get ( 0 ) . getNumber ( ) ; try { passengers = passengerDAO . getPassengersByTrain ( trainNumber ) ; } catch ( NoPassengersException ex ) { log . warn ( "Exception: no passengers for given train" ) ; return new ResponseDTO ( Constants . StatusOfExecutedService . error , ex . getMessage ( ) ) ; } log . debug ( "Finish: showPassengers()" ) ; return new ResponseDTO ( Constants . StatusOfExecutedService . success , passengers ) ; }
va	7	public ArrayList < ArrayList < Integer >> threeSum ( int [ ] num ) { ArrayList < ArrayList < Integer >> res = new ArrayList < ArrayList < Integer >> ( ) ; if ( num == null || num . length < 3 ) return res ; Arrays . sort ( num ) ; int n = num . length ; Set < String > set = new HashSet < String > ( ) ; ArrayList < Integer > sum = null ; for ( int i = 0 ; i < n ; i ++ ) { int a = num [ i ] ; int low = i + 1 ; int high = n - 1 ; while ( low < high ) { int b = num [ low ] ; int c = num [ high ] ; if ( a + b + c == 0 ) { String key = String . valueOf ( a ) + "+" + String . valueOf ( b ) + "+" + String . valueOf ( c ) ; if ( ! set . contains ( key ) ) { sum = new ArrayList < Integer > ( ) ; sum . add ( a ) ; sum . add ( b ) ; sum . add ( c ) ; set . add ( key ) ; res . add ( sum ) ; } low ++ ; high -- ; } else if ( a + b + c < 0 ) { low ++ ; } else high -- ; } } return res ; }
va	3	private Rectangle deserializeWindowPosition ( final Locatable window ) { final String positionString = appProperties . getProperty ( window . getName ( ) ) ; if ( positionString == null ) { log . debug ( "The position of the window {} is not saved in the properties file." , window . getName ( ) ) ; return null ; } final String [ ] values = positionString . split ( " " ) ; if ( values . length < 4 ) { return null ; } final Rectangle rectangle = new Rectangle ( ) ; try { rectangle . x = Integer . parseInt ( values [ 0 ] ) ; rectangle . y = Integer . parseInt ( values [ 1 ] ) ; rectangle . width = Integer . parseInt ( values [ 2 ] ) ; rectangle . height = Integer . parseInt ( values [ 3 ] ) ; } catch ( NumberFormatException ex ) { log . debug ( "Unable to deserialize the window position of {}. Serialized position: {}" , window . getName ( ) , serializeWindowPosition ( window ) ) ; return null ; } return rectangle ; }
va	8	public boolean addJavaCellToPath ( JavaCell javaCell , JavaPlayer player ) { if ( javaCell . hasDeveloper ( ) && ! player . hasDeveloperOnXY ( javaCell . getX ( ) , javaCell . getY ( ) ) ) { System . out . print ( javaCell . hasDeveloper ( ) ) ; System . out . print ( " + " ) ; System . out . print ( ! player . hasDeveloperOnXY ( javaCell . getX ( ) , javaCell . getY ( ) ) ) ; System . out . println ( " means: false" ) ; return false ; } System . out . print ( javaCell . hasDeveloper ( ) ) ; System . out . print ( " + " ) ; System . out . print ( ! player . hasDeveloperOnXY ( javaCell . getX ( ) , javaCell . getY ( ) ) ) ; System . out . println ( " means: not false" ) ; if ( ! "villagerice" . contains ( javaCell . getCellType ( ) ) ) { return false ; } int pathSize = path . size ( ) ; LinkedList < JavaCell > temp = new LinkedList < JavaCell > ( ) ; LinkedList < JavaCell > temp2 = new LinkedList < JavaCell > ( ) ; for ( int i = 0 ; i < pathSize ; i ++ ) { temp2 . push ( path . peek ( ) ) ; temp . push ( path . pop ( ) ) ; } if ( ! temp . isEmpty ( ) ) { JavaCell currentCell = temp . pop ( ) ; int count = 0 ; while ( ( currentCell != javaCell ) && count < pathSize ) { path . push ( currentCell ) ; if ( ! temp . isEmpty ( ) ) currentCell = temp . pop ( ) ; count ++ ; } } path . push ( javaCell ) ; return ! ( costOfDeveloperPath ( path ) > player . getAvailableActionPoints ( false ) ) ; }
va	8	public int getAction ( Game game , long timeDue ) { currentLoc = game . getCurPacManLoc ( ) ; closestBlueGhost = - 1 ; closestNonBlueGhost = - 1 ; int distBlue = Integer . MAX_VALUE ; int distNonBlue = Integer . MAX_VALUE ; for ( int i = 0 ; i < Game . NUM_GHOSTS ; i ++ ) { ghostDist [ i ] = game . getPathDistance ( currentLoc , game . getCurGhostLoc ( i ) ) ; if ( ghostDist [ i ] >= 0 ) { if ( game . isEdible ( i ) && ghostDist [ i ] < distBlue ) { distBlue = ghostDist [ i ] ; closestBlueGhost = i ; } if ( ! game . isEdible ( i ) && ghostDist [ i ] < distNonBlue ) { distNonBlue = ghostDist [ i ] ; closestNonBlueGhost = i ; } } } while ( resultActions . isEmpty ( ) ) { resultActions . addAll ( root . update ( ) . actions ) ; } for ( Action action : resultActions ) { pacmanActions . add ( ( PacManAction ) action ) ; } resultActions . clear ( ) ; return pacmanActions . removeFirst ( ) . act ( game ) ; }
va	7	private JSONWriter append ( String string ) throws JSONException { if ( string == null ) { throw new JSONException ( "Null pointer" ) ; } if ( this . mode == o || this . mode == a ) { try { if ( this . , && this . mode == a ) { this . writer . write (   ) ; } this . writer . write ( string ) ; } catch ( IOException e ) { throw new JSONException ( e ) ; } if ( this . mode == o ) { this . mode = k ; } this . , = true ; return this ; } throw new JSONException ( "Value out of sequence." ) ; }
va	9	public static void sortDstMaj ( final int [ ] src , final int [ ] dst , final int low , final int high , final int order ) { final int threshold = LINK_SIZE * 20 ; final int length = high - low ; if ( length < threshold ) { for ( int i = low ; i < high ; i += LINK_SIZE ) { for ( int j = i ; ( j > low ) && ( cmpDstMaj ( dst , j - LINK_SIZE , j ) == order ) ; j -= LINK_SIZE ) { swap ( dst , j - LINK_SIZE , j ) ; } } return ; } final int rng = ( low + high ) >> 1 ; final int mid = rng - ( rng % LINK_SIZE ) ; sortDstMaj ( dst , src , low , mid , order ) ; sortDstMaj ( dst , src , mid , high , order ) ; if ( cmpDstMaj ( src , mid - LINK_SIZE , mid ) != order ) { System . arraycopy ( src , low , dst , low , length ) ; return ; } for ( int i = low , p = low , q = mid ; i < high ; ) { if ( ( q >= high ) || ( ( p < mid ) && ( cmpDstMaj ( src , p , q ) != order ) ) ) { dst [ i ] = src [ p ] ; p ++ ; i ++ ; dst [ i ] = src [ p ] ; p ++ ; i ++ ; dst [ i ] = src [ p ] ; p ++ ; i ++ ; } else { dst [ i ] = src [ q ] ; q ++ ; i ++ ; dst [ i ] = src [ q ] ; q ++ ; i ++ ; dst [ i ] = src [ q ] ; q ++ ; i ++ ; } } }
va	0	@ Override public boolean isFull ( ) { return ( elements == table . length ) ; }
va	6	public void enterActionListener ( final JButton btn ) { btn . addMouseListener ( new MouseAdapter ( ) { public void mouseEntered ( MouseEvent arg0 ) { char iChar = btn . getName ( ) . charAt ( 0 ) ; char jChar = btn . getName ( ) . charAt ( 1 ) ; iEnter = Integer . parseInt ( iChar + "" ) ; jEnter = Integer . parseInt ( jChar + "" ) ; setSuggestedButtonsNames ( suggestedIndexes ( workingFrame . orijentation , workingFrame . shipSize ) ) ; System . out . println ( "Enter: " + + iEnter + "" + jEnter ) ; String ispis = "Dugmad za markiranje:  " ; for ( String btnName : suggestedButtonsNames ) ispis = ispis + " " + btnName ; System . out . println ( ispis ) ; try { for ( int i = 0 ; i < suggestedButtonsNames . length ; i ++ ) { iSuggested = Integer . parseInt ( suggestedButtonsNames [ i ] . charAt ( 0 ) + "" ) ; jSuggested = Integer . parseInt ( suggestedButtonsNames [ i ] . charAt ( 1 ) + "" ) ; if ( suggestedButtonsNames [ i ] . length ( ) == 3 ) throw new Exception ( "Izasao si iz ogranicenja!" ) ; else myButtonGameBoard [ iSuggested ] [ jSuggested ] . setBorderPainted ( true ) ; setAllButtonsEnabled ( ) ; } } catch ( Exception e ) { System . out . println ( e . getMessage ( ) ) ; setAllButtonsEnabled ( ) ; myButtonGameBoard [ iEnter ] [ jEnter ] . setEnabled ( false ) ; for ( int m = 0 ; m < 10 ; m ++ ) for ( int n = 0 ; n < 10 ; n ++ ) { myButtonGameBoard [ m ] [ n ] . setBorderPainted ( false ) ; } } } } ) ; }
va	1	public void registerCallback ( InvocationCallback callback , class contextInterface ) { if ( cbc == null ) { cbc = new CallbackController ( ) ; } cbc . registerCallback ( callback , contextInterface ) ; }
va	8	private static byte [ ] buildOid ( String hex ) { byte [ ] oid = new byte [ SIZE ] ; for ( int i = 0 ; i < HEX_SIZE ; ++ i ) { char c = hex . charAt ( i ) ; if ( c >= 0 && c <= 9 ) { c -= 0 ; } else if ( c >= a && c <= f ) { c -= a - 10 ; } else if ( c >= A && c <= F ) { c -= A - 10 ; } else { throw new IllegalArgumentException ( String . format ( "Invalid character in sha1: {0}" , c ) ) ; } oid [ i / 2 ] |= ( i % 2 ) == 0 ? ( byte ) ( c << 4 ) : ( byte ) c ; } return oid ; }
va	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( AreaGui . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( AreaGui . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( AreaGui . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( AreaGui . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { AreaGui dialog = new AreaGui ( new javax . swing . JFrame ( ) , true ) ; dialog . addWindowListener ( new java . awt . event . WindowAdapter ( ) { @ Override public void windowClosing ( java . awt . event . WindowEvent e ) { System . exit ( 0 ) ; } } ) ; dialog . setVisible ( true ) ; } } ) ; }
va	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( DiscViewer . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( DiscViewer . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( DiscViewer . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( DiscViewer . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { new DiscViewer ( ) . setVisible ( true ) ; } } ) ; }
va	9	@ Override public void run ( ) { for ( Player p : players ) { if ( ! p . isFacingRight ( ) ) { p . getInHand ( ) . setSpriteY ( 0 ) ; } else { if ( p . getInHand ( ) . getSpriteY ( ) != 1 ) p . getInHand ( ) . setSpriteY ( 1 ) ; } p . getInHand ( ) . setSprite ( p . getInHand ( ) . getImage ( ) . getSubimage ( p . getInHand ( ) . getSpriteX ( ) * p . getInHand ( ) . getWidth ( ) , p . getInHand ( ) . getSpriteY ( ) * p . getInHand ( ) . getHeight ( ) , p . getInHand ( ) . getWidth ( ) , p . getInHand ( ) . getHeight ( ) ) ) ; if ( p . isFacingRight ( ) ) { p . getInHand ( ) . setxAdjustment ( p . getInHand ( ) . getHoldingRightX ( ) ) ; p . getInHand ( ) . setyAdjustment ( p . getInHand ( ) . getHoldingRightY ( ) ) ; } else { p . getInHand ( ) . setxAdjustment ( p . getInHand ( ) . getHoldingLeftX ( ) ) ; p . getInHand ( ) . setyAdjustment ( p . getInHand ( ) . getHoldingLeftY ( ) ) ; } if ( ! p . isWalking ( ) && ! p . isRunning ( ) && p . isFacingRight ( ) ) { p . setWeaponXTweak ( p . getStandingRightHandX ( ) ) ; p . setWeaponYTweak ( p . getStandingRightHandY ( ) ) ; } else if ( ! p . isWalking ( ) && ! p . isRunning ( ) ) { p . setWeaponXTweak ( p . getStandingLeftHandX ( ) ) ; p . setWeaponYTweak ( p . getStandingLeftHandY ( ) ) ; } else if ( ( p . isWalking ( ) || p . isRunning ( ) ) && p . isFacingRight ( ) ) { p . setWeaponXTweak ( p . getWalkingRightHandX ( ) ) ; p . setWeaponYTweak ( p . getWalkingRightHandY ( ) ) ; } else if ( ( p . isWalking ( ) || p . isRunning ( ) ) ) { p . setWeaponXTweak ( p . getWalkingLeftHandX ( ) ) ; p . setWeaponYTweak ( p . getWalkingLeftHandY ( ) ) ; } } }
va	4	public void setHover ( int selectedId ) { this . clearHover ( ) ; for ( int h = 0 ; h < height ; h ++ ) { for ( int w = 0 ; w < width ; w ++ ) { for ( int z = 0 ; z < depth ; z ++ ) { if ( grid [ h ] [ w ] [ z ] . getId ( ) == selectedId ) { grid [ h ] [ w ] [ z ] . hover ( ) ; } } } } }
va	6	@ Override public boolean equals ( Object other ) { if ( this == other ) return true ; if ( other instanceof DeadReckoningParameter ) { DeadReckoningParameter asParam = ( DeadReckoningParameter ) other ; if ( asParam . deadReckoningAlgorithm == this . deadReckoningAlgorithm && Arrays . equals ( asParam . deadReckoningOtherParameters , this . deadReckoningOtherParameters ) && asParam . entityLinearAcceleration . equals ( this . entityLinearAcceleration ) && asParam . entityAngularVelocity . equals ( this . entityAngularVelocity ) ) { return true ; } } return false ; }
va	3	public static boolean hiiriPaalla ( Point p ) { return p . x >= X && p . x <= X + LEV && p . y >= Y && p . y <= Y + KOR ; }
va	5	@ Override public void actionPerformed ( ActionEvent ae ) { int buttonSelection = fileChooser . showSaveDialog ( saveAsButton ) ; if ( buttonSelection == JFileChooser . APPROVE_OPTION ) { File fileToSave = fileChooser . getSelectedFile ( ) ; String fileName = fileToSave . getPath ( ) ; if ( ! fileName . endsWith ( ZOM_FILE_EXTENSION ) ) { JOptionPane . showMessageDialog ( saveAsButton , SAVE_AS_ERROR_FEEDBACK_TEXT ) ; return ; } try { FileOutputStream fos = new FileOutputStream ( fileName ) ; DataOutputStream dos = new DataOutputStream ( fos ) ; dos . writeInt ( gridColumns ) ; dos . writeInt ( gridRows ) ; for ( int i = 0 ; i < gridColumns ; i ++ ) { for ( int j = 0 ; j < gridRows ; j ++ ) { dos . writeInt ( grid [ i ] [ j ] ) ; } } } catch ( IOException ioe ) { JOptionPane . showMessageDialog ( saveAsButton , FILE_WRITING_ERROR_TEXT + fileName , FILE_WRITING_ERROR_TEXT + fileName , JOptionPane . ERROR_MESSAGE ) ; } } }
va	9	public static ResponseEnvelope createInstance ( Map < String , String > map , String prefix , int index ) { ResponseEnvelope responseEnvelope = null ; int i = 0 ; if ( index != - 1 ) { if ( prefix != null && prefix . length ( ) != 0 && ! prefix . endsWith ( "." ) ) { prefix = prefix + "(" + index + ")." ; } } else { if ( prefix != null && prefix . length ( ) != 0 && ! prefix . endsWith ( "." ) ) { prefix = prefix + "." ; } } if ( map . containsKey ( prefix + "timestamp" ) ) { responseEnvelope = ( responseEnvelope == null ) ? new ResponseEnvelope ( ) : responseEnvelope ; responseEnvelope . setTimestamp ( map . get ( prefix + "timestamp" ) ) ; } if ( map . containsKey ( prefix + "ack" ) ) { responseEnvelope = ( responseEnvelope == null ) ? new ResponseEnvelope ( ) : responseEnvelope ; responseEnvelope . setAck ( AckCode . fromValue ( map . get ( prefix + "ack" ) ) ) ; } if ( map . containsKey ( prefix + "correlationId" ) ) { responseEnvelope = ( responseEnvelope == null ) ? new ResponseEnvelope ( ) : responseEnvelope ; responseEnvelope . setCorrelationId ( map . get ( prefix + "correlationId" ) ) ; } if ( map . containsKey ( prefix + "build" ) ) { responseEnvelope = ( responseEnvelope == null ) ? new ResponseEnvelope ( ) : responseEnvelope ; responseEnvelope . setBuild ( map . get ( prefix + "build" ) ) ; } return responseEnvelope ; }
va	7	public static void main ( String ... args ) throws IOException , InterruptedException { Logger logger = Logger . getLogger ( "tt.ge.jett" ) ; Handler handler = new ConsoleHandler ( ) ; handler . setLevel ( Level . ALL ) ; handler . setFormatter ( new SimpleFormatter ( ) ) ; logger . setUseParentHandlers ( false ) ; logger . setLevel ( Level . ALL ) ; logger . addHandler ( handler ) ; try { UIManager . setLookAndFeel ( UIManager . getSystemLookAndFeelClassName ( ) ) ; } catch ( Exception e ) { } final User user = User . login ( "" , "" , "" ) ; user . connect ( ) ; final FileTableModel fileModel = new FileTableModel ( ) ; final JTable table = new JTable ( fileModel ) ; table . setPreferredScrollableViewportSize ( new Dimension ( 700 , 150 ) ) ; table . setFillsViewportHeight ( true ) ; final JFrame window = new JFrame ( "Ge.tt" ) ; final JFileChooser chooser = new JFileChooser ( ) ; JPanel actions = new JPanel ( ) ; chooser . setMultiSelectionEnabled ( true ) ; JButton addFile = new JButton ( "Add file to" ) ; final JComboBox box = new JComboBox ( ) ; JButton destroyFile = new JButton ( "Destroy selected files" ) ; user . addFileListener ( new FileProxyListener . Adapter ( ) { @ Override public void uploadStart ( File file ) { fileModel . fileUpdated ( file ) ; } @ Override public void uploadEnd ( File file ) { fileModel . fileUpdated ( file ) ; } @ Override public void download ( File file , boolean increment ) { fileModel . fileUpdated ( file ) ; } } ) ; updateComboBox ( box , user , user . getShares ( ) ) ; addFile . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent event ) { try { int result = chooser . showOpenDialog ( window ) ; if ( result == JFileChooser . APPROVE_OPTION ) { java . io . File [ ] files = chooser . getSelectedFiles ( ) ; ShareItem item = ( ShareItem ) box . getSelectedItem ( ) ; Share share = item . getShare ( ) ; for ( java . io . File file : files ) { File f = share . uploadFile ( file ) ; fileModel . addFile ( f ) ; } updateComboBox ( box , user , user . getPool ( ) . getShares ( ) ) ; } } catch ( IOException e ) { System . err . println ( e . getMessage ( ) ) ; } } } ) ; destroyFile . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { int [ ] selected = table . getSelectedRows ( ) ; File [ ] files = new File [ selected . length ] ; for ( int i = 0 ; i < files . length ; i ++ ) { files [ i ] = fileModel . getFile ( selected [ i ] ) ; } for ( File file : files ) { try { file . destroy ( ) ; } catch ( IOException e1 ) { return ; } fileModel . removeFile ( file ) ; } } } ) ; actions . add ( addFile ) ; actions . add ( box ) ; actions . add ( destroyFile ) ; window . add ( actions , BorderLayout . NORTH ) ; window . add ( new JScrollPane ( table ) , BorderLayout . CENTER ) ; window . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; SwingUtilities . invokeLater ( new Runnable ( ) { @ Override public void run ( ) { window . pack ( ) ; window . setVisible ( true ) ; } } ) ; }
va	8	private String columnToType ( Column col ) { switch ( col . getType ( ) ) { case boolean : return "BIT" ; case DATE : case TIMESTAMP : return "DATETIME" ; case STRING : return "TEXT" ; case INTEGER : case ENUM_ID : case ENUM_ORDINAL : return "INTEGER" ; case ENUM_NAME : return "TEXT" ; default : throw new IllegalArgumentException ( "Unknown column type" ) ; } }
va	7	public void propagate_lookaheads ( terminal_set incoming ) throws internal_error { boolean change = false ; if ( ! needs_propagation && ( incoming == null || incoming . empty ( ) ) ) return ; if ( incoming != null ) { change = lookahead ( ) . add ( incoming ) ; } if ( change || needs_propagation ) { needs_propagation = false ; for ( int i = 0 ; i < propagate_items ( ) . size ( ) ; i ++ ) ( ( lalr_item ) propagate_items ( ) . elementAt ( i ) ) . propagate_lookaheads ( lookahead ( ) ) ; } }
va	0	public TriggerTiming getWhen ( ) { return when ; }
va	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( Salir . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( Salir . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( Salir . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( Salir . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { new Salir ( ) . setVisible ( true ) ; } } ) ; }
va	5	public void drop ( ) { for ( byte i = 0 ; i < 16 ; ++ i ) { for ( byte j = 0 ; j < 16 ; ++ j ) { File file = new File ( getFullName ( new DirFile ( i , j ) ) ) ; if ( file . exists ( ) ) { if ( ! file . delete ( ) ) { throw new DataBaseException ( "Cannot delete a file!" ) ; } } } tryDeleteDirectory ( Integer . toString ( i ) + ".dir" ) ; } if ( ! new File ( dataBaseDirectory , "signature.tsv" ) . delete ( ) ) { throw new DataBaseException ( "Cannot delete a file!" ) ; } }
va	8	private void selectRandomNumber ( ) { phr1 = "" ; phr2 = "" ; int tmp = getRand ( nrPhr1_9000 ) ; if ( tmp != - 1 ) { phr1 += nrPhr1_9000 [ tmp ] ; phr1 += conPhr1 [ 2 ] ; phr2 += nrPhr2_9000 [ tmp ] ; phr2 += conPhr2 [ 2 ] ; } tmp = getRand ( nrPhr1_900 ) ; if ( tmp != - 1 ) { phr1 += nrPhr1_900 [ tmp ] ; phr1 += conPhr1 [ 1 ] ; phr2 += nrPhr2_900 [ tmp ] ; phr2 += conPhr2 [ 1 ] ; } if ( LangCoach . RANDOM . nextBoolean ( ) ) { int teentmp = getRand ( nrPhr1_90 ) ; int nrtmp = getRand ( nrPhr1_9 ) ; if ( teentmp != - 1 && nrtmp != - 1 ) { if ( swpPhr1 [ 0 ] . equals ( "+" ) ) { phr1 += nrPhr1_9 [ nrtmp ] ; phr1 += conPhr1 [ 0 ] ; phr1 += nrPhr1_90 [ teentmp ] ; } else { phr1 += nrPhr1_90 [ teentmp ] ; phr1 += conPhr1 [ 0 ] ; phr1 += nrPhr1_9 [ nrtmp ] ; } if ( swpPhr2 [ 0 ] . equals ( "+" ) ) { phr2 += nrPhr2_9 [ nrtmp ] ; phr2 += conPhr2 [ 0 ] ; phr2 += nrPhr2_90 [ teentmp ] ; } else { phr2 += nrPhr2_90 [ teentmp ] ; phr2 += conPhr2 [ 0 ] ; phr2 += nrPhr2_9 [ nrtmp ] ; } } } else { tmp = getRand ( nrPhr1_19 ) ; if ( tmp != - 1 ) { phr1 += nrPhr1_19 [ tmp ] ; phr1 += conPhr1 [ 0 ] ; phr2 += nrPhr2_19 [ tmp ] ; phr2 += conPhr2 [ 0 ] ; } } }
va	5	public static void addTrees ( Chunk c ) { Random rand = new Random ( ) ; for ( int y = 0 ; y < Chunk . CHUNK_SIZE ; y ++ ) { for ( int x = 0 ; x < Chunk . CHUNK_SIZE ; x ++ ) { if ( c . getTiles ( ) [ x ] [ y ] instanceof Tile_Grass ) { if ( rand . nextFloat ( ) > .995 ) { float rad = rand . nextFloat ( ) * 5 ; if ( rad < 1 ) rad = 1 ; new Tree ( rad , new Location ( x + .5f + c . getX ( ) * Chunk . CHUNK_SIZE , y + .5f + c . getY ( ) * Chunk . CHUNK_SIZE ) ) ; } } } } }
va	1	private final void bsFinishedWithStream ( ) throws IOException { while ( bsLive > 0 ) { int ch = ( bsBuff >> 24 ) ; bsBuff <<= 8 ; bsLive -= 8 ; bytesOut ++ ; } }
va	5	public MultipartRequest ( HttpServletRequest aRequest , String aSaveDir , int aMaxSize ) throws IOException { if ( aRequest == null ) throw new IOException ( "null request" ) ; if ( aSaveDir == null ) throw new IOException ( "null save directory" ) ; if ( aMaxSize <= 0 ) throw new IOException ( "invalid MaxSize" ) ; fRequest = aRequest ; fSaveDir = new File ( aSaveDir ) ; fMaxSize = aMaxSize ; if ( ! fSaveDir . isDirectory ( ) ) throw new IOException ( "not a directory: " + fSaveDir ) ; if ( ! fSaveDir . canWrite ( ) ) throw new IOException ( "directory not writable: " + fSaveDir ) ; readRequest ( ) ; }
va	6	private static Object subseq ( Object subtree , int lo , int hi ) { if ( lo >= hi ) return null ; else if ( lo == 0 && hi == treeSize ( subtree ) ) return subtree ; else if ( ! ( subtree instanceof Node ) ) return subseq ( ( Object [ ] ) subtree , lo , hi ) ; else { Node node = ( Node ) subtree ; int sizl = treeSize ( node . left ) ; if ( hi <= sizl ) return subseq ( node . left , lo , hi ) ; else if ( lo >= sizl ) return subseq ( node . right , lo - sizl , hi - sizl ) ; else return concat ( subseq ( node . left , lo , sizl ) , subseq ( node . right , 0 , hi - sizl ) ) ; } }
va	1	@ Override public E getCurrentElem ( ) { if ( this . currentNode != null ) { return this . currentNode . getElement ( ) ; } return null ; }
va	1	private static List < String > getAllPossibleWords ( String numbers ) { List < String > result = new ArrayList < > ( ) ; for ( int i = 0 ; i < numbers . length ( ) ; i ++ ) { getAllPossibleWords ( Integer . parseInt ( numbers . substring ( i , i + 1 ) ) , result ) ; } return result ; }
va	4	public Vertex locateNearestVertex ( Vector v ) { Triangle located = locate ( v ) ; if ( located == null ) { return null ; } Vertex bestVertex = null ; double dist = double . MAX_VALUE ; for ( Triangle tri : getCircumcircleTriangles ( v , located ) ) { for ( Vertex vert : tri . getVertices ( ) ) { double d = vert . subtract ( v ) . lengthSquared ( ) ; if ( d < dist ) { bestVertex = vert ; dist = d ; } } } return bestVertex ; }
va	7	@ Override public void replace ( FilterBypass fb , int offset , int length , String text , AttributeSet attrs ) throws BadLocationException { Document3 doc = ( Document3 ) fb . getDocument ( ) ; String text_to_remove = doc . getText ( offset , length ) ; int trans_start = doc . getTranslationStart ( ) ; int trans_end = trans_start + IntrospectionTools . getCurrentTranslation ( ) . length ( ) ; if ( Core . getMatcher ( ) . getActiveMatch ( ) != null && Core . getMatcher ( ) . getActiveMatch ( ) . translation . equals ( text ) ) { Scores scores = Core . getMatcher ( ) . getActiveMatch ( ) . scores [ 0 ] ; if ( offset == trans_start && length == trans_end - trans_start ) { sessionlog . GetLog ( ) . ReplaceFromTM ( offset - trans_start , IntrospectionTools . getActiveMatchIndex ( ) , text_to_remove , text , scores . score , scores . scoreNoStem , scores . adjustedScore ) ; } else { sessionlog . GetLog ( ) . InsertFromTM ( offset - trans_start , IntrospectionTools . getActiveMatchIndex ( ) , text , scores . score , scores . scoreNoStem , scores . adjustedScore ) ; } } else if ( Core . getMachineTranslatePane ( ) . getDisplayedTranslation ( ) != null && Core . getMachineTranslatePane ( ) . getDisplayedTranslation ( ) . equals ( text ) ) { sessionlog . GetLog ( ) . ReplaceFromMT ( offset - trans_start , text_to_remove , text ) ; } else { if ( length > 0 ) sessionlog . GetLog ( ) . NewDeletion ( offset - trans_start , text_to_remove ) ; sessionlog . GetLog ( ) . NewInsertion ( offset - trans_start , text ) ; } super . replace ( fb , offset , length , text , attrs ) ; }
va	8	public int accion ( boolean PF , boolean PD , boolean PA , boolean PI , boolean MT ) { int dir = ( int ) ( 4 * Math . random ( ) ) ; while ( ( dir == 0 && PF ) || ( dir == 1 && PD ) || ( dir == 2 && PA ) || ( dir == 3 && PI ) ) { dir = ( int ) ( 4 * Math . random ( ) ) ; } ; return dir ; }
va	7	public ArrayList < Copy > getCopies ( ) { BookDAL objBookDAL = new BookDAL ( ) ; ArrayList < Book > listBooks = objBookDAL . getBooks ( ) ; ArrayList < Copy > copyList = new ArrayList ( ) ; try { DocumentBuilderFactory docFactory = DocumentBuilderFactory . newInstance ( ) ; DocumentBuilder docBuilder = docFactory . newDocumentBuilder ( ) ; Document doc = docBuilder . parse ( new File ( "db/DBcopies.xml" ) ) ; doc . getDocumentElement ( ) . normalize ( ) ; NodeList copyNodes = doc . getElementsByTagName ( "copy" ) ; for ( int i = 0 ; i < copyNodes . getLength ( ) ; i ++ ) { Node copy = copyNodes . item ( i ) ; if ( copy . getNodeType ( ) == Node . ELEMENT_NODE ) { Element anElement = ( Element ) copy ; Copy objCopy = new Copy ( ) ; objCopy . setBookCode ( Integer . parseInt ( getNodeValue ( "bookcode" , anElement ) ) ) ; String state = getNodeValue ( "state" , anElement ) ; switch ( state ) { case "BORROWED" : objCopy . setState ( Copy . CopyState . BORROWED ) ; break ; case "STORED" : objCopy . setState ( Copy . CopyState . STORED ) ; break ; default : throw new AssertionError ( ) ; } String bookid = getNodeValue ( "isbn" , anElement ) ; Book myBook = new Book ( ) ; myBook . setISBN ( bookid ) ; int comparation = listBooks . indexOf ( myBook ) ; if ( comparation != - 1 ) { myBook . setISBN ( listBooks . get ( comparation ) . getISBN ( ) ) ; myBook . setTitle ( listBooks . get ( comparation ) . getTitle ( ) ) ; myBook . setType ( listBooks . get ( comparation ) . getType ( ) ) ; myBook . setImage ( listBooks . get ( comparation ) . getImage ( ) ) ; myBook . setEditorial ( listBooks . get ( comparation ) . getEditorial ( ) ) ; myBook . setEdition ( listBooks . get ( comparation ) . getEdition ( ) ) ; myBook . setYear ( listBooks . get ( comparation ) . getYear ( ) ) ; for ( int j = 0 ; j < listBooks . get ( comparation ) . getAuthor ( ) . size ( ) ; j ++ ) { myBook . setAuthor ( listBooks . get ( comparation ) . getAuthor ( ) . get ( j ) ) ; } objCopy . setBook ( myBook ) ; } copyList . add ( objCopy ) ; } } } catch ( ParserConfigurationException | SAXException | IOException parseE ) { JOptionPane . showMessageDialog ( null , parseE . getMessage ( ) , "" + "Error" , JOptionPane . ERROR_MESSAGE ) ; } return copyList ; }
va	7	public void PrOKReservaCreada ( String numTarg , String cCad ) { try { if ( numTarg . equals ( "" ) || cCad . equals ( "" ) ) throw new Exception ( "faltenDades" ) ; SimpleDateFormat sdf = new SimpleDateFormat ( "dd/MM/yy" ) ; sdf . setLenient ( false ) ; Date dCad ; try { dCad = sdf . parse ( cCad ) ; } catch ( ParseException pe ) { throw new Exception ( "sCadNoValida" ) ; } controladorReservarHabitacio . pagament ( numTarg , dCad ) ; vistaReservarHabitacio . mostraMissatgeFi ( ) ; } catch ( Exception e ) { if ( e . getMessage ( ) . equals ( "faltenDades" ) ) vistaReservarHabitacio . mostraMissatge ( "View5" , "S'han d'introduir totes les dades" ) ; else if ( e . getMessage ( ) . equals ( "sCadNoValida" ) ) vistaReservarHabitacio . mostraMissatge ( "View5" , "La data de caducitat no \u00E9s una data v\u00E0lida" ) ; else if ( e . getMessage ( ) . equals ( "serveiNoDisponible" ) ) vistaReservarHabitacio . mostraMissatge ( "View5" , "El servei no esta disponible" ) ; } }
va	6	public boolean getBoolean ( int index ) throws JSONException { Object object = this . get ( index ) ; if ( object . equals ( boolean . false ) || ( object instanceof String && ( ( String ) object ) . equalsIgnoreCase ( "false" ) ) ) { return false ; } else if ( object . equals ( boolean . true ) || ( object instanceof String && ( ( String ) object ) . equalsIgnoreCase ( "true" ) ) ) { return true ; } throw new JSONException ( "JSONArray[" + index + "] is not a boolean." ) ; }
va	0	@ Override public List < String > getIngredients ( ) { List < String > ingredients = decoratedCofee . getIngredients ( ) ; ingredients . add ( DESCRIPTION ) ; return ingredients ; }
va	3	public void nextStart ( ) { if ( taskList . size ( ) == 0 ) { runningTask = null ; runningIndex = 0 ; running = false ; return ; } else { if ( running ) { return ; } else { if ( runningIndex < taskList . size ( ) ) { runningTask = taskList . get ( runningIndex ) ; runningTask . threadStart ( ) ; } } } }
va	8	public GetImpersonationTokenResult unmarshall ( StaxUnmarshallerContext context ) throws Exception { GetImpersonationTokenResult getImpersonationTokenResult = new GetImpersonationTokenResult ( ) ; int originalDepth = context . getCurrentDepth ( ) ; int targetDepth = originalDepth + 1 ; if ( context . isStartOfDocument ( ) ) targetDepth += 2 ; while ( true ) { XMLEvent xmlEvent = context . nextEvent ( ) ; if ( xmlEvent . isEndDocument ( ) ) return getImpersonationTokenResult ; if ( xmlEvent . isAttribute ( ) || xmlEvent . isStartElement ( ) ) { if ( context . testExpression ( "Credentials" , targetDepth ) ) { getImpersonationTokenResult . setCredentials ( CredentialsStaxUnmarshaller . getInstance ( ) . unmarshall ( context ) ) ; continue ; } } else if ( xmlEvent . isEndElement ( ) ) { if ( context . getCurrentDepth ( ) < originalDepth ) { return getImpersonationTokenResult ; } } } }
va	7	public static void forBadFiles ( List < Invalid > errors , Aspect aspect , Object o , String suffix ) { for ( Field f : o . getClass ( ) . getFields ( ) ) { NonNullableFileReference name = f . getAnnotation ( NonNullableFileReference . class ) ; try { if ( name != null ) { Object value = f . get ( o ) ; if ( value == null ) { errors . add ( new Invalid ( aspect , "You have not selected a file for the " + name . value ( ) + ( suffix == null ? "." : ( " for \"" + suffix + ".\"" ) ) ) ) ; } else if ( value instanceof File ) { File file = ( File ) value ; if ( ! file . exists ( ) ) { errors . add ( new Invalid ( aspect , "The file " + file . getAbsolutePath ( ) + " no longer exists." ) ) ; } } } } catch ( Exception e ) { e . printStackTrace ( ) ; } } }
va	5	private static String unquote ( String string ) { if ( string . length ( ) < 2 ) return string ; if ( string . charAt ( 0 ) == " && string . charAt ( string . length ( ) - 1 ) == " ) return string . substring ( 1 , string . length ( ) - 1 ) ; if ( string . charAt ( 0 ) == ' && string . charAt ( string . length ( ) - 1 ) == ' ) return string . substring ( 1 , string . length ( ) - 1 ) ; return string ; }
va	2	@ Override public boolean equals ( Object other ) { if ( other == this ) { return true ; } if ( ( other instanceof MappingPolicyAssociations ) == false ) { return false ; } MappingPolicyAssociations rhs = ( ( MappingPolicyAssociations ) other ) ; return new EqualsBuilder ( ) . append ( ShareID , rhs . ShareID ) . append ( additionalProperties , rhs . additionalProperties ) . isEquals ( ) ; }
va	3	private void withscore ( Playable p , BallotBox ballot ) { if ( cr . isCrossingOffensive ( p ) ) { escape . vote ( p , ballot ) ; } else if ( mesh . getCurrentState ( ) . getRemainingTime ( ) < 200 ) { across . vote ( p , ballot ) ; } else if ( sp . getShortestDistance ( p , nr . getNearestEnemy ( p , false ) ) < 3 ) { fierce . vote ( p , ballot ) ; } else { across . vote ( p , ballot ) ; } }
va	1	private void draw_components ( Graphics g ) { for ( DrawComponets dc : components ) { dc . draw_me ( g ) ; } }
va	5	private void jButton7ActionPerformed ( java . awt . event . ActionEvent evt ) { liceu . Administrator admin = new liceu . Administrator ( ) ; try { admin . addMaterie ( materieDeAdaugat . getText ( ) ) ; } catch ( IOException ex ) { Logger . getLogger ( Administratorapp . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } materieDeSters . removeAllItems ( ) ; BufferedReader fisier2 ; try { ArrayList < String > vector = new ArrayList < > ( ) ; fisier2 = new BufferedReader ( new FileReader ( "fmaterii" ) ) ; for ( String line ; ( line = fisier2 . readLine ( ) ) != null ; ) { vector . add ( line ) ; } for ( int i = 0 ; i < vector . size ( ) ; i ++ ) materieDeSters . addItem ( vector . get ( i ) ) ; } catch ( FileNotFoundException ex ) { Logger . getLogger ( Secretarapp . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( IOException ex ) { Logger . getLogger ( Secretarapp . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } adaugareMaterie . dispose ( ) ; }
va	9	public void WriteHeaders ( BufferedOutputStream out ) { int i , j , index , offset , length ; int tempArray [ ] ; byte [ ] SOI = { ( byte ) FF , ( byte ) D8 } ; WriteMarker ( SOI , out ) ; byte JFIF [ ] = new byte [ 18 ] ; JFIF [ 0 ] = ( byte ) ff ; JFIF [ 1 ] = ( byte ) e0 ; JFIF [ 2 ] = ( byte ) 00 ; JFIF [ 3 ] = ( byte ) 10 ; JFIF [ 4 ] = ( byte ) 4a ; JFIF [ 5 ] = ( byte ) 46 ; JFIF [ 6 ] = ( byte ) 49 ; JFIF [ 7 ] = ( byte ) 46 ; JFIF [ 8 ] = ( byte ) 00 ; JFIF [ 9 ] = ( byte ) 01 ; JFIF [ 10 ] = ( byte ) 00 ; JFIF [ 11 ] = ( byte ) 00 ; JFIF [ 12 ] = ( byte ) 00 ; JFIF [ 13 ] = ( byte ) 01 ; JFIF [ 14 ] = ( byte ) 00 ; JFIF [ 15 ] = ( byte ) 01 ; JFIF [ 16 ] = ( byte ) 00 ; JFIF [ 17 ] = ( byte ) 00 ; WriteArray ( JFIF , out ) ; String comment = new String ( ) ; comment = JpegObj . getComment ( ) ; length = comment . length ( ) ; byte COM [ ] = new byte [ length + 4 ] ; COM [ 0 ] = ( byte ) FF ; COM [ 1 ] = ( byte ) FE ; COM [ 2 ] = ( byte ) ( ( length >> 8 ) & FF ) ; COM [ 3 ] = ( byte ) ( length & FF ) ; java . lang . System . arraycopy ( JpegObj . Comment . getBytes ( ) , 0 , COM , 4 , JpegObj . Comment . length ( ) ) ; WriteArray ( COM , out ) ; byte DQT [ ] = new byte [ 134 ] ; DQT [ 0 ] = ( byte ) FF ; DQT [ 1 ] = ( byte ) DB ; DQT [ 2 ] = ( byte ) 00 ; if ( componentCount == 1 ) DQT [ 3 ] = ( byte ) 43 ; else DQT [ 3 ] = ( byte ) 84 ; offset = 4 ; DQT [ offset ++ ] = ( byte ) ( ( 0 << 4 ) + 0 ) ; for ( j = 0 ; j < 64 ; j ++ ) { DQT [ offset ++ ] = ( byte ) dqt0 [ j ] ; } if ( componentCount > 1 ) { DQT [ offset ++ ] = ( byte ) ( ( 0 << 4 ) + 1 ) ; for ( j = 0 ; j < 64 ; j ++ ) { DQT [ offset ++ ] = ( byte ) dqt1 [ j ] ; } } WriteArray ( DQT , out ) ; byte SOF [ ] = new byte [ 19 ] ; SOF [ 0 ] = ( byte ) FF ; SOF [ 1 ] = ( byte ) C0 ; SOF [ 2 ] = ( byte ) 00 ; if ( componentCount > 1 ) SOF [ 3 ] = ( byte ) 17 ; else SOF [ 3 ] = ( byte ) 11 ; SOF [ 4 ] = ( byte ) JpegObj . Precision ; SOF [ 5 ] = ( byte ) ( ( JpegObj . imageHeight >> 8 ) & FF ) ; SOF [ 6 ] = ( byte ) ( ( JpegObj . imageHeight ) & FF ) ; SOF [ 7 ] = ( byte ) ( ( JpegObj . imageWidth >> 8 ) & FF ) ; SOF [ 8 ] = ( byte ) ( ( JpegObj . imageWidth ) & FF ) ; SOF [ 9 ] = ( byte ) JpegObj . NumberOfComponents ; index = 10 ; for ( i = 0 ; i < SOF [ 9 ] ; i ++ ) { SOF [ index ++ ] = ( byte ) JpegObj . CompID [ i ] ; SOF [ index ++ ] = ( byte ) ( ( JpegObj . HsampFactor [ i ] << 4 ) + JpegObj . VsampFactor [ i ] ) ; SOF [ index ++ ] = ( byte ) JpegObj . QtableNumber [ i ] ; } WriteArray ( SOF , out ) ; byte DHT1 [ ] , DHT2 [ ] , DHT3 [ ] , DHT4 [ ] ; int bytes , temp , oldindex , intermediateindex ; length = 2 ; index = 4 ; oldindex = 4 ; DHT1 = new byte [ 17 ] ; DHT4 = new byte [ 4 ] ; DHT4 [ 0 ] = ( byte ) FF ; DHT4 [ 1 ] = ( byte ) C4 ; int loopcount = 0 ; if ( componentCount > 1 ) loopcount = 4 ; else loopcount = 2 ; for ( i = 0 ; i < loopcount ; i ++ ) { bytes = 0 ; DHT1 [ index ++ - oldindex ] = ( byte ) ( ( int [ ] ) Huf . bits . elementAt ( i ) ) [ 0 ] ; for ( j = 1 ; j < 17 ; j ++ ) { temp = ( ( int [ ] ) Huf . bits . elementAt ( i ) ) [ j ] ; DHT1 [ index ++ - oldindex ] = ( byte ) temp ; bytes += temp ; } intermediateindex = index ; DHT2 = new byte [ bytes ] ; for ( j = 0 ; j < bytes ; j ++ ) { DHT2 [ index ++ - intermediateindex ] = ( byte ) ( ( int [ ] ) Huf . val . elementAt ( i ) ) [ j ] ; } DHT3 = new byte [ index ] ; java . lang . System . arraycopy ( DHT4 , 0 , DHT3 , 0 , oldindex ) ; java . lang . System . arraycopy ( DHT1 , 0 , DHT3 , oldindex , 17 ) ; java . lang . System . arraycopy ( DHT2 , 0 , DHT3 , oldindex + 17 , bytes ) ; DHT4 = DHT3 ; oldindex = index ; } DHT4 [ 2 ] = ( byte ) ( ( ( index - 2 ) >> 8 ) & FF ) ; DHT4 [ 3 ] = ( byte ) ( ( index - 2 ) & FF ) ; WriteArray ( DHT4 , out ) ; byte SOS [ ] = new byte [ 14 ] ; SOS [ 0 ] = ( byte ) FF ; SOS [ 1 ] = ( byte ) DA ; SOS [ 2 ] = ( byte ) 00 ; if ( componentCount > 1 ) SOS [ 3 ] = ( byte ) 12 ; else SOS [ 3 ] = ( byte ) 8 ; SOS [ 4 ] = ( byte ) JpegObj . NumberOfComponents ; index = 5 ; for ( i = 0 ; i < SOS [ 4 ] ; i ++ ) { SOS [ index ++ ] = ( byte ) JpegObj . CompID [ i ] ; SOS [ index ++ ] = ( byte ) ( ( JpegObj . DCtableNumber [ i ] << 4 ) + JpegObj . ACtableNumber [ i ] ) ; } SOS [ index ++ ] = ( byte ) JpegObj . Ss ; SOS [ index ++ ] = ( byte ) JpegObj . Se ; SOS [ index ++ ] = ( byte ) ( ( JpegObj . Ah << 4 ) + JpegObj . Al ) ; WriteArray ( SOS , out ) ; }
va	7	public void printBoard ( JTextArea terminal ) { printBoard ( ) ; for ( int i = 0 ; i < BOARD_SIZE ; ++ i ) { for ( int j = 0 ; j < BOARD_SIZE ; ++ j ) { switch ( map [ i ] [ j ] ) { case b : terminal . append ( "B " ) ; break ; case g : terminal . append ( "G " ) ; break ; case r : terminal . append ( "R " ) ; break ; case y : terminal . append ( "Y " ) ; break ; case e : terminal . append ( "_ " ) ; break ; default : terminal . append ( map [ i ] [ j ] + " " ) ; break ; } } terminal . append ( "\n" ) ; } terminal . append ( "\n" ) ; terminal . setCaretPosition ( terminal . getText ( ) . length ( ) - 1 ) ; }
va	7	@ Override @ SuppressWarnings ( "static-access" ) public double kinship ( Individual indi ) { if ( this == indi ) return 1 ; if ( fitness != indi . fitness ) return 0 ; int hit = 0 ; int miss = 0 ; int n ; Sudoku oth = ( Sudoku ) indi ; for ( int r = 0 ; r < 9 ; r ++ ) for ( int c = 0 ; c < 9 ; c ++ ) if ( ( n = rows [ r ] [ c ] ) > 0 ) if ( n == oth . rows [ r ] [ c ] ) hit ++ ; else miss ++ ; if ( hit + miss == 0 ) return 1 ; return hit / ( hit + miss ) ; }
va	5	public int placeSymbol ( int row , int column , Symbol sym ) { if ( row < 0 || column < 0 || board [ row ] [ column ] != null ) { return - 2 ; } board [ row ] [ column ] = new Piece ( sym ) ; int flag = checkEndOfGame ( row , column , sym ) ; if ( flag != 0 && isBoardFull ( ) == 1 ) { flag = 2 ; } this . printBoard ( ) ; return flag ; }
va	1	public Object invoke ( ) { try { return method . invoke ( me , args ) ; } catch ( Exception e ) { throw Lang . uncheck ( e ) ; } }
va	4	public synchronized boolean getBooleanOption ( String key ) { boolean ret = false ; if ( key == null ) return ret ; String value = sOptions . get ( key ) . toLowerCase ( ) ; if ( value != null ) { if ( value . equals ( "true" ) || value . equals ( "t" ) ) { ret = true ; } } return ret ; }
va	1	public boolean isNotEmpty ( ) { return sentMessages > 0 && receivedMessages > 0 ; }
va	2	@ EventHandler ( priority = EventPriority . MONITOR ) public void onPlayerJoinEventMonitor ( PlayerJoinEvent event ) { try { Player player = event . getPlayer ( ) ; PermissionUser user ; if ( plugin . isUseUUID ( ) ) { user = plugin . getDataManager ( ) . getUser ( event . getPlayer ( ) . getUniqueId ( ) ) ; } else { user = plugin . getDataManager ( ) . getUser ( event . getPlayer ( ) . getName ( ) ) ; } plugin . getDataManager ( ) . apply ( user , player , player . getWorld ( ) ) ; } catch ( DataLoadFailedException ex ) { plugin . getLogger ( ) . log ( Level . SEVERE , "An error occured on " + event . getPlayer ( ) . getName ( ) + "'s JoinEvent" , ex ) ; } }
va	3	@ Override public String toString ( ) { StringBuilder builder = new StringBuilder ( ) ; for ( Object key : getSortedKeys ( ) ) { if ( builder . length ( ) > 0 ) { builder . append ( "  " ) ; } builder . append ( key ) ; builder . append ( " = " ) ; builder . append ( data . get ( key ) ) ; } if ( builder . length ( ) > 0 ) { builder . append ( "  " ) ; } builder . append ( "count = " ) ; builder . append ( count ) ; return builder . toString ( ) ; }
va	2	public static InputStream findFileInput ( String name ) { File f = findFile ( name ) ; if ( f != null ) { try { return new FileInputStream ( f ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } } return null ; }
va	0	public AddMaterialCommand ( Material material ) { this . material = material ; }
va	8	public void sauver ( File f ) { try { OutputStreamWriter destination = new OutputStreamWriter ( new FileOutputStream ( f ) ) ; destination . write ( Integer . toString ( n ) ) ; destination . write ( ; ) ; destination . write ( Integer . toString ( dim ) ) ; destination . write ( ; ) ; destination . write ( Integer . toString ( nbClasses ) ) ; destination . write ( '' ) ; int k = OutilsMatriciels . exposant ( nbClasses ) ; double [ ] [ ] M = ecm . getM ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < dim ; j ++ ) { destination . write ( double . toString ( points [ i ] [ j ] ) ) ; if ( j != dim - 1 ) destination . write ( ; ) ; else destination . write ( '' ) ; } } destination . write ( '' ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < k ; j ++ ) { destination . write ( double . toString ( M [ i ] [ j ] ) ) ; if ( j != k - 1 ) destination . write ( ; ) ; else destination . write ( '' ) ; } } destination . close ( ) ; } catch ( FileNotFoundException exception ) { JOptionPane . showMessageDialog ( fenetre , "Fichier introuvable." , "Erreur" , JOptionPane . ERROR_MESSAGE ) ; exception . printStackTrace ( ) ; } catch ( IOException exception ) { JOptionPane . showMessageDialog ( fenetre , "Impossible d'ouvrir ce fichier. Ce fichier est problablement utilise par une autre application." , "Erreur" , JOptionPane . ERROR_MESSAGE ) ; exception . printStackTrace ( ) ; } }
va	4	public void mueve ( final int posAntigua , final int posNueva ) { Ciudad ciudad = this . ruta [ posAntigua ] ; if ( posAntigua < posNueva ) { for ( int i = posAntigua ; i < posNueva ; i ++ ) this . ruta [ i ] = this . ruta [ i + 1 ] ; } else if ( posAntigua > posNueva ) { for ( int i = posAntigua ; i > posNueva ; i -- ) this . ruta [ i ] = this . ruta [ i - 1 ] ; } this . ruta [ posNueva ] = ciudad ; }
va	2	public void update ( long tmpID , double tmpPrice , int tmpVol , Time tmpTime ) { int updateIndex = allID . indexOf ( tmpID ) ; if ( updateIndex != - 1 ) { if ( tmpPrice != myList . get ( updateIndex ) . getPrice ( ) ) { deleteAtIndex ( updateIndex ) ; add ( tmpID , tmpPrice , tmpVol , tmpTime ) ; } else { myList . get ( updateIndex ) . updateValue ( tmpID , tmpPrice , tmpVol , tmpTime ) ; } } else { totalError ++ ; } }
va	3	@ Override public List < case > parse ( String data ) { final Scanner sc = new Scanner ( data ) ; final List < case > cases = Lists . newArrayList ( ) ; long num_cases = sc . nextLong ( ) ; for ( int case_num = 0 ; case_num < num_cases ; case_num ++ ) { final int n = sc . nextInt ( ) ; final List < Integer > v1 = Lists . newArrayList ( ) ; final List < Integer > v2 = Lists . newArrayList ( ) ; for ( int i = 0 ; i < n ; i ++ ) { v1 . add ( sc . nextInt ( ) ) ; } for ( int i = 0 ; i < n ; i ++ ) { v2 . add ( sc . nextInt ( ) ) ; } case aCase = new case ( v1 , v2 ) ; cases . add ( aCase ) ; } return cases ; }
va	6	public Set < Light > updateLights ( int [ ] [ ] board ) { Random r = new Random ( ) ; for ( Light l : lights ) { MoveableLight ml = ( MoveableLight ) l ; switch ( r . nextInt ( 4 ) ) { case 0 : ml . moveUp ( ) ; break ; case 1 : ml . moveDown ( ) ; break ; case 2 : ml . moveLeft ( ) ; break ; case 3 : ml . moveRight ( ) ; break ; } if ( r . nextInt ( 2 ) == 0 ) ml . turnOff ( ) ; else ml . turnOn ( ) ; } return lights ; }
va	8	public Map < Treatment , LinkedHashMap < String , String >> readSentenceTags ( List < Treatment > treatments ) { if ( this . myDataHolder == null ) { return null ; } Map < Treatment , LinkedHashMap < String , String >> tags = new HashMap < Treatment , LinkedHashMap < String , String >> ( ) ; String previousTag = null ; String previousTreatmentId = "-1" ; Iterator < SentenceStructure > iter = this . getDataHolder ( ) . getSentenceHolder ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { SentenceStructure sentenceObject = iter . next ( ) ; String source = this . getSource ( sentenceObject . getSource ( ) ) ; String treatmentId = getTreatmentId ( source ) ; if ( selectedSources . isEmpty ( ) || selectedSources . contains ( source ) ) { if ( ! treatmentId . equals ( previousTreatmentId ) ) { previousTreatmentId = treatmentId ; } String tag = sentenceObject . getTag ( ) ; if ( tag == null ) tag = "" ; tag = tag . replaceAll ( "\\W" , "" ) ; Treatment treatment = fileTreatments . get ( treatmentId ) ; if ( ! tags . containsKey ( treatment ) ) tags . put ( treatment , new LinkedHashMap < String , String > ( ) ) ; if ( ! tag . equals ( "ditto" ) ) { tags . get ( treatment ) . put ( source , tag ) ; previousTag = tag ; } else { tags . get ( treatment ) . put ( source , previousTag ) ; } } } return tags ; }
va	9	private static ArrayList < String > getRowColAndGapsTrimmed ( String s ) { if ( s . indexOf ( | ) != - 1 ) s = s . replaceAll ( "\\|" , "][" ) ; ArrayList < String > retList = new ArrayList < String > ( Math . max ( s . length ( ) >> 2 + 1 , 3 ) ) ; int s0 = 0 , s1 = 0 ; int st = 0 ; for ( int i = 0 , iSz = s . length ( ) ; i < iSz ; i ++ ) { char c = s . charAt ( i ) ; if ( c == [ ) { s0 ++ ; } else if ( c == ] ) { s1 ++ ; } else { continue ; } if ( s0 != s1 && ( s0 - 1 ) != s1 ) break ; retList . add ( s . substring ( st , i ) . trim ( ) ) ; st = i + 1 ; } if ( s0 != s1 ) throw new IllegalArgumentException ( "'[' and ']' mismatch in row/column format string: " + s ) ; if ( s0 == 0 ) { retList . add ( "" ) ; retList . add ( s ) ; retList . add ( "" ) ; } else if ( retList . size ( ) % 2 == 0 ) { retList . add ( s . substring ( st , s . length ( ) ) ) ; } return retList ; }
va	6	@ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; DeclaracaoParametro other = ( DeclaracaoParametro ) obj ; if ( id == null ) { if ( other . id != null ) return false ; } else if ( ! id . equals ( other . id ) ) return false ; return true ; }
va	5	public int minDepth ( TreeNode root ) { if ( root == null ) return 0 ; if ( root . left == null && root . right == null ) return 1 ; if ( root . left == null ) return 1 + minDepth ( root . right ) ; if ( root . right == null ) return 1 + minDepth ( root . left ) ; return Math . min ( 1 + ( minDepth ( root . left ) ) , 1 + ( minDepth ( root . right ) ) ) ; }
va	1	public void processKeyEvent ( KeyEvent e ) { int keycode = e . getKeyCode ( ) ; if ( keycode != 0 ) { setText ( JGEngine . getKeyDescStatic ( keycode ) ) ; processAction ( fieldname , new Integer ( keycode ) ) ; } }
va	8	public static void downloadFile ( String path , String url ) throws IOException { DefaultHttpClient client = null ; try { client = new DefaultHttpClient ( ) ; HttpGet httpGet = new HttpGet ( url ) ; HttpResponse response = client . execute ( httpGet ) ; if ( response . getStatusLine ( ) . getStatusCode ( ) == HttpStatus . SC_OK ) { byte [ ] result = EntityUtils . toByteArray ( response . getEntity ( ) ) ; BufferedOutputStream bw = null ; try { File f = new File ( path ) ; if ( ! f . getParentFile ( ) . exists ( ) ) f . getParentFile ( ) . mkdirs ( ) ; bw = new BufferedOutputStream ( new FileOutputStream ( path ) ) ; bw . write ( result ) ; } catch ( Exception e ) { } finally { try { if ( bw != null ) bw . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } } } catch ( ClientProtocolException e ) { throw e ; } catch ( IOException e ) { throw e ; } finally { try { client . getConnectionManager ( ) . shutdown ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } }
va	3	public static void backTrace ( int [ ] [ ] s , int [ ] [ ] c , int f , int e , int base ) { if ( e == 0 || f == 0 ) { return ; } int p = c [ f ] [ e ] ; System . out . println ( String . format ( "floor: %d  egg: %d  choose %d" , f , e , p + base ) ) ; if ( s [ p - 1 ] [ e - 1 ] > s [ f - p ] [ e ] ) { backTrace ( s , c , p - 1 , e - 1 , base ) ; } else { backTrace ( s , c , f - p , e , base + p ) ; } }
va	9	@ Override protected final void writeObjectOverride ( Object obj ) throws IOException { if ( set . contains ( obj ) ) { return ; } if ( stack . isEmpty ( ) ) { stack . add ( "Class " + obj . getClass ( ) . getName ( ) ) ; } System . out . println ( "Serializing: " + obj . getClass ( ) . getName ( ) ) ; set . add ( obj ) ; Field [ ] fields = obj . getClass ( ) . getFields ( ) ; System . out . println ( "Object[ " + obj . getClass ( ) . getName ( ) + "] has " + fields . length + " fields." ) ; for ( int i = 0 ; i < fields . length ; i ++ ) { StringBuffer buffer = new StringBuffer ( ) ; Field f = fields [ i ] ; int m = f . getModifiers ( ) ; if ( fields [ i ] . getType ( ) . isPrimitive ( ) || Modifier . isTransient ( m ) || Modifier . isStatic ( m ) ) { continue ; } if ( Modifier . isPrivate ( m ) ) { buffer . append ( "private " ) ; } if ( Modifier . isProtected ( m ) ) { buffer . append ( "protected " ) ; } if ( Modifier . isPublic ( m ) ) { buffer . append ( "public " ) ; } if ( Modifier . isFinal ( m ) ) { buffer . append ( "final " ) ; } if ( Modifier . isVolatile ( m ) ) { buffer . append ( "volatile " ) ; } buffer . append ( f . getType ( ) . getName ( ) ) . append ( "" ) ; buffer . append ( " " ) . append ( f . getName ( ) ) ; stack . add ( buffer . toString ( ) ) ; if ( Serializable . class . isAssignableFrom ( fields [ i ] . getType ( ) ) ) { try { writeObjectOverride ( fields [ i ] . get ( obj ) ) ; } catch ( IllegalAccessException e ) { throw new RuntimeException ( getPrettyPrintedStack ( fields [ i ] . getType ( ) . getName ( ) ) , e ) ; } } else { throw new RuntimeException ( getPrettyPrintedStack ( fields [ i ] . getType ( ) . getName ( ) ) . toString ( ) , new NotSerializableException ( fields [ i ] . getType ( ) . getName ( ) ) ) ; } stack . removeLast ( ) ; } if ( stack . size ( ) == 1 ) { set . clear ( ) ; stack . removeLast ( ) ; } }
va	9	private void processQuery ( ) { int pos = query . indexOf ( ";\n" ) ; if ( pos < 0 ) return ; String cmd = query . substring ( 0 , pos + 1 ) ; query = query . substring ( pos + 2 ) ; System . out . println ( "SQL cmd: '" + cmd + "'" ) ; result = "# @SQL@: " + cmd + "\n" ; try { Statement stmt = session . createStatement ( ) ; if ( stmt . execute ( cmd ) ) { StringBuffer buf = new StringBuffer ( ) ; buf . append ( "# @STATUS@: SUCCESSFUL\n" ) ; ResultSet r = stmt . getResultSet ( ) ; if ( r != null ) { ResultSetMetaData md = r . getMetaData ( ) ; int numCol = md . getColumnCount ( ) ; buf . append ( "# @COLS@: " ) ; for ( int n = 0 ; n < numCol ; n ++ ) { buf . append ( md . getColumnName ( n + 1 ) ) ; if ( n < numCol - 1 ) buf . append ( "\u00A6" ) ; } buf . append ( "\n" ) ; StringBuffer recBuf = new StringBuffer ( ) ; int numRec = 0 ; while ( r . next ( ) ) { for ( int n = 0 ; n < numCol ; n ++ ) { String data = r . getString ( n + 1 ) ; recBuf . append ( convert ( data ) ) ; if ( n < numCol - 1 ) recBuf . append ( "\u00A6" ) ; } recBuf . append ( "\n" ) ; numRec ++ ; } buf . append ( "# @RESULT@: " + numRec + "\n" ) ; buf . append ( recBuf ) ; } else buf . append ( "# @RESULT@: NONE\n" ) ; result += buf . toString ( ) ; } else result += "# @STATUS@: FAILED!\n" ; } catch ( SQLException e ) { result += "# @STATUS@: FAILED! (" + e . getMessage ( ) + ")\n" ; } }
va	3	@ Override public void clear ( ) { for ( MapSegment < K , V > mapSegment : mapSegments ) { mapSegment . lock . writeLock ( ) . lock ( ) ; } try { for ( MapSegment < K , V > mapSegment : mapSegments ) { mapSegment . clear ( ) ; } } finally { for ( MapSegment < K , V > mapSegment : mapSegments ) { mapSegment . lock . writeLock ( ) . unlock ( ) ; } } }
va	4	@ Override public void sendCmd ( Command cmd , Player p , boolean last ) { if ( last ) { Logger . logdebug ( "Sending last quit command" ) ; } synchronized ( clientHandlerLock ) { for ( ClientHandler ch : clientHandlers ) { if ( p == null || ch . getPlayer ( ) == p ) { ch . queueForSend ( cmd , last ) ; } } } }
va	9	private synchronized String [ ] [ ] resultadoBusqueda ( ) throws ClassNotFoundException , InstantiationException , IllegalAccessException , SQLException { this . BUSCANDO = true ; String select = "SELECT * FROM `" + NombreTablas . CORREOS . getValue ( ) + "` " ; String count = "SELECT COUNT(*) FROM `" + NombreTablas . CORREOS . getValue ( ) + "` " ; boolean skey = consulta . isEmpty ( ) ; boolean sorigen = origen . isEmpty ( ) ; boolean sgrupo = grupo . isEmpty ( ) ; String query = null ; String [ ] querys = new String [ 4 ] ; if ( ! skey ) { if ( StringValidation . validaDigitos ( consulta ) ) { query = "`id_correo` = " + consulta + " " ; } else { query = "`correo` LIKE '%" + consulta + "%' " ; } querys [ 0 ] = query ; } if ( ! sorigen ) { query = "`id_origen` = " + new RegistraOrigen ( ) . getOrigenByName ( origen ) . getId ( ) + " " ; querys [ 1 ] = query ; } if ( ! sgrupo ) { query = "`id_grupo` = " + new RegistraGrupo ( ) . getGrupoByName ( grupo ) . getId ( ) + " " ; querys [ 2 ] = query ; } querys [ 3 ] = "`habilitado` = '" + habilitado + "'" ; boolean where = true ; String swhere = "" ; for ( String query1 : querys ) { if ( query1 != null ) { if ( where ) { swhere = "WHERE " ; } else { swhere = "AND " ; } select += swhere + query1 ; count += swhere + query1 ; where = false ; } } ResultSet res_count = this . conexion . executeQuery ( count ) ; count = null ; res_count . next ( ) ; int num_resultados = res_count . getInt ( 1 ) ; if ( num_resultados > 5000 ) { select += " LIMIT 5000" ; JOptionPane . showMessageDialog ( null , num_resultados + " Resultados \r\n -Solo se muestran los primeros 5 000 \r\n -Intenta una busqueda mas especifica" , "Demaciados resultados" , JOptionPane . INFORMATION_MESSAGE ) ; } ResultSet resultado = this . conexion . executeQuery ( select ) ; select = null ; ArrayList < Correo > listaCorreos = new ArrayList < > ( ) ; while ( resultado . next ( ) ) { int id = resultado . getInt ( "id_correo" ) ; String correo = resultado . getNString ( "correo" ) ; Origen corigen = new RegistraOrigen ( ) . getOrigenByID ( resultado . getInt ( "id_origen" ) ) ; Grupo cgrupo = new RegistraGrupo ( ) . getGrupoByID ( resultado . getInt ( "id_grupo" ) ) ; boolean chabilitado = boolean . parseBoolean ( resultado . getNString ( "habilitado" ) ) ; listaCorreos . add ( new Correo ( id , correo , corigen , cgrupo , chabilitado ) ) ; } int totalCorreos = listaCorreos . size ( ) ; String [ ] [ ] sresultado = null ; if ( totalCorreos > 0 ) { sresultado = new String [ totalCorreos ] [ 5 ] ; for ( int i = 0 ; i < totalCorreos ; i ++ ) { sresultado [ i ] = listaCorreos . get ( i ) . toArray ( ) ; } } this . BUSCANDO = false ; listaCorreos . clear ( ) ; return sresultado ; }
va	0	public EvlAssignFSM ( List < EvlComponent > components , EvlStatement statement ) { this . components = components ; this . statement = statement ; initState = new InitState ( this ) ; lhsState = new LHSState ( this ) ; lhsNameState = new LHSNameState ( this ) ; lhsBusState = new LHSBusState ( this ) ; lhsMSBState = new LHSMSBState ( this ) ; lhsColonState = new LHSColonState ( this ) ; lhsLSBState = new LHSLSBState ( this ) ; lhsDoneState = new LHSDoneState ( this ) ; rhsState = new RHSState ( this ) ; rhsNameState = new RHSNameState ( this ) ; rhsBusState = new RHSBusState ( this ) ; rhsMSBState = new RHSMSBState ( this ) ; rhsColonState = new RHSColonState ( this ) ; rhsLSBState = new RHSLSBState ( this ) ; rhsDoneState = new RHSDoneState ( this ) ; doneState = new DoneState ( this ) ; state = initState ; }
