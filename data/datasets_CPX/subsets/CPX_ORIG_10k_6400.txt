va	0	private boolean setPlayerTwoType ( String playerTwoType ) { m_PlayerTwoType = playerTwoType ; return true ; }
va	2	private void testAllDayHoursWithoutPrefixes ( ) { int hours = 24 ; int minutes = 60 ; for ( int h = 0 ; h < hours ; h ++ ) { for ( int m = 0 ; m < minutes ; m ++ ) { String testData = h + ":" + m ; HourMinuteInDay dayTime = HourMinuteInDay . valueOf ( testData ) ; assertEquals ( h , dayTime . getHour ( ) ) ; assertEquals ( m , dayTime . getMinute ( ) ) ; } } }
va	7	public void sendFirst ( ) { boolean betray = true ; if ( betray ) { System . out . println ( "betrayal incoming!" ) ; } BigInteger p ; ElGamalCipher elGamalC_a ; ElGamalSignature elGamalS_a ; { p = new BigInteger ( "4988735951183711405443349413015910122453507015594895638933838601555750189585703700647655985269637551634513770201277370413860951650702374379627998821919409" ) ; BigInteger g = new BigInteger ( "4403105895869798297264918950735787070665047406714785361037216842427722734684061748868589917485012596281820467352001338223691996653533143166890875549812531" ) ; BigInteger y = new BigInteger ( "3670294064109445804998782973709772470002041046377612489028768098078250713079795031354099562309432613560558383306865142781216201315104971340333690591679721" ) ; BigInteger x = new BigInteger ( "4589946301809196862611751989088793376762175950291076147544077975213763218505486754450017554342955014202444667772016113058406939298289857995054770609176615" ) ; elGamalC_a = new ElGamalCipher ( p , g , y , x ) ; elGamalS_a = new ElGamalSignature ( p , g , y , x ) ; } com . sendTo ( 1 , p . toString ( 16 ) ) ; com . sendTo ( 1 , elGamalC_a . g . toString ( 16 ) ) ; com . sendTo ( 1 , elGamalC_a . y . toString ( 16 ) ) ; BigInteger m0 , m1 ; { m0 = BigIntegerUtil . randomBetween ( ZERO , p ) ; do { m1 = BigIntegerUtil . randomBetween ( ZERO , p ) ; } while ( m0 . equals ( m1 ) ) ; } com . sendTo ( 1 , m0 . toString ( 16 ) ) ; com . sendTo ( 1 , m1 . toString ( 16 ) ) ; BigInteger q = new BigInteger ( com . receive ( ) , 16 ) ; BigInteger s0 , s1 ; BigInteger M0_dash , M1_dash ; int s ; { BigInteger k0 , k1 ; { k0 = elGamalC_a . decipherBlock ( q . subtract ( m0 ) . mod ( p . pow ( 2 ) ) ) ; k1 = elGamalC_a . decipherBlock ( q . subtract ( m1 ) . mod ( p . pow ( 2 ) ) ) ; } System . out . println ( "k0'" + k0 . toString ( 16 ) ) ; System . out . println ( "k1'" + k1 . toString ( 16 ) ) ; s0 = elGamalS_a . signBlock ( k0 ) ; s1 = elGamalS_a . signBlock ( k1 ) ; System . out . println ( "s0'" + s0 . toString ( 16 ) ) ; System . out . println ( "s1'" + s1 . toString ( 16 ) ) ; s = new Random ( ) . nextBoolean ( ) ? 1 : 0 ; BigInteger M0 = new BigInteger ( "1111111111111111111111111111111111111" ) ; BigInteger M1 = new BigInteger ( "2222222222222222222222222222222222222" ) ; if ( betray ) { M0 = M1 ; if ( new Random ( ) . nextBoolean ( ) ) s0 = elGamalS_a . signBlock ( new BigInteger ( 512 , new Random ( ) ) ) ; else s1 = elGamalS_a . signBlock ( new BigInteger ( 512 , new Random ( ) ) ) ; } M0_dash = M0 . add ( s == 1 ? k1 : k0 ) . mod ( p ) ; M1_dash = M1 . add ( s == 0 ? k1 : k0 ) . mod ( p ) ; System . out . println ( "M0'" + M0_dash . toString ( 16 ) ) ; System . out . println ( "M1'" + M1_dash . toString ( 16 ) ) ; } com . sendTo ( 1 , M0_dash . toString ( 16 ) ) ; com . sendTo ( 1 , M1_dash . toString ( 16 ) ) ; com . sendTo ( 1 , s0 . toString ( 16 ) ) ; com . sendTo ( 1 , s1 . toString ( 16 ) ) ; com . sendTo ( 1 , Integer . toString ( s ) ) ; }
va	7	public void upToNext ( ) { try { if ( allowedValue == null ) { int n = this . getValue ( ) ; if ( specialValue != null ) { for ( int i = 0 ; i < specialValue . length ; i ++ ) { if ( n < specialValue [ i ] && specialValue [ i ] % increment == 0 ) { setNormal ( ) ; setText ( Integer . toString ( specialValue [ i ] ) ) ; return ; } } System . out . println ( "There is no special value set higher than the current value of \"" + name + "\" that is compatible with the increment = " + increment ) ; } else { System . out . println ( "There are no special values for " + name ) ; } } else { if ( allowedIndex < allowedValue . length - 1 ) { allowedIndex ++ ; setText ( Integer . toString ( allowedValue [ allowedIndex ] ) ) ; } } } catch ( Exception e ) { System . out . println ( e . toString ( ) ) ; System . out . println ( "Failed to jump to next higher special value = " + name ) ; setError ( ) ; } }
va	3	public void stopListening ( ) { blnRunning = false ; if ( serverSocket != null ) { serverSocket . close ( ) ; serverSocket = null ; } if ( acceptorThread != null ) { try { acceptorThread . join ( ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } acceptorThread = null ; } }
va	9	private void createSchedule ( ) { int i = ( Integer ) crawlerSelector . getSelectedItem ( ) ; String aUrl = url . getText ( ) . trim ( ) ; if ( aUrl == null || aUrl . length ( ) == 0 ) { println_Sched ( "%%% Please Enter a URL address" , i ) ; return ; } String aUrlSuffix = url_Suffix . getText ( ) . trim ( ) ; if ( ( aUrlSuffix == null || aUrlSuffix . length ( ) == 0 ) ) { aUrlSuffix = "" ; } String from = strFrom . getText ( ) . trim ( ) ; String to = strTo . getText ( ) . trim ( ) ; if ( ( from == null || from . length ( ) == 0 ) || ( to == null || to . length ( ) == 0 ) ) { println_Sched ( "%%% Please Enter an Interval" , i ) ; return ; } String aDir = dir . getText ( ) . trim ( ) ; if ( ( aDir == null || aDir . length ( ) == 0 ) ) { println_Sched ( "%%% Please enter or select a Directory" , i ) ; return ; } String anExt = ext . getText ( ) . trim ( ) ; if ( ( anExt == null || anExt . length ( ) == 0 ) ) { println_Sched ( "%%% Please enter an Extension for the file" , i ) ; return ; } del_Sched . setEnabled ( true ) ; crawl [ i ] . setEnabled ( true ) ; pause [ i ] . setEnabled ( false ) ; crawlerCTRL [ i ] . recordCrawl ( aUrl , aUrlSuffix , aDir , anExt , from , to ) ; }
va	4	public OtpMsg receiveMsg ( final long timeout ) throws InterruptedException , OtpErlangExit { final OtpMsg m = ( OtpMsg ) queue . get ( timeout ) ; if ( m == null ) { return null ; } switch ( m . type ( ) ) { case OtpMsg . exitTag : case OtpMsg . exit2Tag : try { final OtpErlangObject o = m . getMsg ( ) ; throw new OtpErlangExit ( o , m . getSenderPid ( ) ) ; } catch ( final OtpErlangDecodeException e ) { throw new OtpErlangExit ( "unknown" , m . getSenderPid ( ) ) ; } default : return m ; } }
va	1	@ Override public void run ( ) { switch ( rand . nextInt ( 2000 ) ) { case 1 : Time . sleep ( rand . nextInt ( 1 ) ) ; break ; } }
va	6	final public UpdateCommand Update ( ) throws ParseException { String tableName ; List < UpdateCommand . UpdateDescriptor > updateDescriptors = new ArrayList < UpdateCommand . UpdateDescriptor > ( ) ; Exp condition = null ; UpdateCommand . UpdateDescriptor updateDescriptor ; jj_consume_token ( KW_UPDATE ) ; tableName = Identifier ( ) ; jj_consume_token ( KW_SET ) ; updateDescriptor = AttributeAssg ( ) ; updateDescriptors . add ( updateDescriptor ) ; label_10 : while ( true ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case 51 : ; break ; default : jj_la1 [ 19 ] = jj_gen ; break label_10 ; } jj_consume_token ( 51 ) ; updateDescriptor = AttributeAssg ( ) ; updateDescriptors . add ( updateDescriptor ) ; } switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case KW_WHERE : jj_consume_token ( KW_WHERE ) ; condition = Expression ( ) ; break ; default : jj_la1 [ 20 ] = jj_gen ; ; } { if ( true ) return new UpdateCommand ( token , tableName , updateDescriptors , condition ) ; } throw new Error ( "Missing return statement in function" ) ; }
va	6	@ SuppressWarnings ( { "unchecked" } ) Object getLatest ( Object proxy ) throws IllegalAccessException , InstantiationException { class mgrClass = manager . loadClass ( className ) ; if ( mgrClass != null && ( obj == null || obj . getClass ( ) != mgrClass ) ) { Object reloadObj = null ; if ( obj instanceof LoadListener ) { reloadObj = ( ( LoadListener ) obj ) . onUnload ( ) ; } obj = mgrClass . newInstance ( ) ; if ( obj instanceof CreateListener ) { ( ( CreateListener ) obj ) . onCreate ( kernel , proxy ) ; } if ( obj instanceof LoadListener ) { ( ( LoadListener ) obj ) . onLoad ( reloadObj ) ; } } return obj ; }
va	3	private DataHandler ( ) { cc_file = new File ( Config . datafile_path ) ; try { cc_context = JAXBContext . newInstance ( ColourConnection . class ) ; if ( ! cc_file . exists ( ) ) { cc_file . createNewFile ( ) ; Marshaller m = cc_context . createMarshaller ( ) ; m . setProperty ( Marshaller . JAXB_FORMATTED_OUTPUT , boolean . true ) ; m . marshal ( new ObjectFactory ( ) . createColourConnection ( new ColourConnection ( ) ) , cc_file ) ; } Unmarshaller um = cc_context . createUnmarshaller ( ) ; cc_base = ( ColourConnection ) um . unmarshal ( new StreamSource ( cc_file ) , ColourConnection . class ) . getValue ( ) ; } catch ( JAXBException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }
va	6	public final synchronized Rectangle2D getBounds2D ( ) { float x1 , y1 , x2 , y2 ; int i = numCoords ; if ( i > 0 ) { y1 = y2 = floatCoords [ -- i ] ; x1 = x2 = floatCoords [ -- i ] ; while ( i > 0 ) { float y = floatCoords [ -- i ] ; float x = floatCoords [ -- i ] ; if ( x < x1 ) x1 = x ; if ( y < y1 ) y1 = y ; if ( x > x2 ) x2 = x ; if ( y > y2 ) y2 = y ; } } else { x1 = y1 = x2 = y2 = 0.0f ; } return new Rectangle2D . float ( x1 , y1 , x2 - x1 , y2 - y1 ) ; }
va	3	public void abrirConexion ( ) { try { if ( cnx == null || cnx . isClosed ( ) ) { class . forName ( "org.sqlite.JDBC" ) ; cnx = DriverManager . getConnection ( "jdbc:sqlite:" + ruta ) ; cnx . setAutoCommit ( false ) ; } } catch ( ClassNotFoundException | SQLException e ) { JOptionPane . showMessageDialog ( null , e . getMessage ( ) , "Error!" , JOptionPane . ERROR_MESSAGE ) ; } }
va	9	public static void main ( String [ ] args ) { final JLabel label = new JLabel ( ) ; ErrorListener errorListener = new ErrorListener ( ) { @ Override public void error ( String message , Object ... args ) { label . setText ( String . format ( message , args ) ) ; } } ; final ScriptModel model = new ScriptModel ( errorListener ) ; StyledDocument document = model . getDocument ( ) ; final JTextPane textPane = new JTextPane ( document ) ; SimpleAttributeSet attrs_blue = new SimpleAttributeSet ( ) ; StyleConstants . setForeground ( attrs_blue , Color . blue ) ; SimpleAttributeSet attrs_red = new SimpleAttributeSet ( ) ; StyleConstants . setForeground ( attrs_blue , Color . red ) ; textPane . setText ( "right(5)" ) ; document . setCharacterAttributes ( 1 , 5 , attrs_blue , false ) ; document . setCharacterAttributes ( 6 , 7 , attrs_red , false ) ; final Action runAction = new AbstractAction ( "Start" ) { private static final long serialVersionUID = 2085873676432797044 ; @ Override public void actionPerformed ( ActionEvent e ) { ScriptNode scriptNode = model . getScriptNode ( ) ; String text = new PrettyPrinter ( ) . print ( scriptNode ) ; System . out . println ( text ) ; } } ; runAction . setEnabled ( false ) ; model . addChangeListener ( new ChangeListener ( ) { @ Override public void stateChanged ( ChangeEvent e ) { boolean hasAScriptNode = model . getScriptNode ( ) != null ; runAction . setEnabled ( hasAScriptNode ) ; if ( hasAScriptNode ) { label . setText ( null ) ; } else { } } } ) ; final Action cutAction = new AbstractAction ( "Cut" ) { private static final long serialVersionUID = - 5607975097665632574 ; @ Override public void actionPerformed ( ActionEvent e ) { textPane . cut ( ) ; } } ; final Action copyAction = new AbstractAction ( "Copy" ) { private static final long serialVersionUID = 1271710595381946831 ; @ Override public void actionPerformed ( ActionEvent e ) { textPane . copy ( ) ; } } ; final Action loadAction = new AbstractAction ( "Load" ) { private static final long serialVersionUID = 4380515786177585932 ; @ Override public void actionPerformed ( ActionEvent e ) { Document doc = textPane . getDocument ( ) ; JFileChooser fileLoad = new JFileChooser ( ) ; fileLoad . setFileFilter ( new FileNameExtensionFilter ( "Script .script" , "script" ) ) ; int returnVal = fileLoad . showOpenDialog ( new Frame ( ) ) ; if ( returnVal == JFileChooser . APPROVE_OPTION ) { File file = fileLoad . getSelectedFile ( ) ; System . out . println ( "You load this file: " + file . getName ( ) ) ; BufferedReader reader = null ; try { reader = new BufferedReader ( new FileReader ( file ) ) ; } catch ( FileNotFoundException e1 ) { e1 . printStackTrace ( ) ; } String str = null ; try { while ( ( str = reader . readLine ( ) ) != null ) { doc . insertString ( doc . getLength ( ) , str + "\n" , null ) ; } } catch ( IOException | BadLocationException e1 ) { e1 . printStackTrace ( ) ; } } } } ; final Action saveAction = new AbstractAction ( "Save" ) { private static final long serialVersionUID = 7703437766369260141 ; @ Override public void actionPerformed ( ActionEvent e ) { JFileChooser fileSave = new JFileChooser ( ) ; fileSave . setFileFilter ( new FileNameExtensionFilter ( "Script .script" , "script" ) ) ; int returnVal = fileSave . showOpenDialog ( new Frame ( ) ) ; if ( returnVal == JFileChooser . APPROVE_OPTION ) { File file = fileSave . getSelectedFile ( ) ; System . out . println ( "You save into this file: " + file . getName ( ) ) ; try { BufferedWriter out = new BufferedWriter ( new FileWriter ( file ) ) ; out . write ( textPane . getText ( ) ) ; out . close ( ) ; } catch ( IOException e2 ) { e2 . printStackTrace ( ) ; } } } } ; textPane . addCaretListener ( new CaretListener ( ) { @ Override public void caretUpdate ( CaretEvent e ) { boolean isSelected = textPane . getSelectedText ( ) != null ; cutAction . setEnabled ( isSelected ) ; copyAction . setEnabled ( isSelected ) ; } } ) ; final Action pasteAction = new AbstractAction ( "Paste" ) { private static final long serialVersionUID = - 5166974512137056749 ; @ Override public void actionPerformed ( ActionEvent e ) { textPane . paste ( ) ; } } ; final Clipboard clipBoard = Toolkit . getDefaultToolkit ( ) . getSystemClipboard ( ) ; clipBoard . addFlavorListener ( new FlavorListener ( ) { @ Override public void flavorsChanged ( FlavorEvent event ) { boolean stringAvailable ; try { stringAvailable = clipBoard . getData ( DataFlavor . stringFlavor ) != null ; } catch ( UnsupportedFlavorException | IOException e ) { stringAvailable = false ; } pasteAction . setEnabled ( stringAvailable ) ; } } ) ; JToolBar toolbar = new JToolBar ( ) ; toolbar . setFloatable ( false ) ; toolbar . add ( loadAction ) ; toolbar . add ( saveAction ) ; toolbar . addSeparator ( new Dimension ( 64 , 64 ) ) ; toolbar . add ( copyAction ) ; toolbar . add ( cutAction ) ; toolbar . add ( pasteAction ) ; toolbar . addSeparator ( new Dimension ( 64 , 64 ) ) ; toolbar . add ( runAction ) ; final DrawingArea drawingArea = new DrawingArea ( ) { private static final long serialVersionUID = 5317163817572057932 ; @ Override public Dimension getPreferredSize ( ) { return new Dimension ( 500 , 600 ) ; } } ; drawingArea . addRefreshListener ( new RefreshListener ( ) { @ Override public void refresh ( BufferedImage image ) { System . out . println ( "refresh ..." ) ; Graphics2D graphics = image . createGraphics ( ) ; try { int width = image . getWidth ( ) ; int height = image . getHeight ( ) ; graphics . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; graphics . setColor ( Color . BLACK ) ; graphics . fill ( new Rectangle ( 0 , 0 , width , height ) ) ; graphics . setColor ( Color . ORANGE ) ; for ( int i = 0 ; i < width ; i += 40 ) { graphics . drawLine ( i , 0 , i , height ) ; } graphics . setColor ( Color . LIGHT_GRAY ) ; for ( int i = 0 ; i < height ; i += 40 ) { graphics . drawLine ( 0 , i , width , i ) ; } graphics . setColor ( Color . RED ) ; Random random = new Random ( ) ; graphics . fill ( new Ellipse2D . float ( random . nextInt ( width ) , random . nextInt ( height ) , 50 , 50 ) ) ; } finally { graphics . dispose ( ) ; } } } ) ; new Timer ( 10000 , new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { drawingArea . refresh ( ) ; } } ) . start ( ) ; JScrollPane scrollPane = new JScrollPane ( textPane ) ; JPanel panel = new JPanel ( new BorderLayout ( ) ) ; panel . add ( label , BorderLayout . NORTH ) ; panel . add ( drawingArea , BorderLayout . EAST ) ; panel . add ( scrollPane , BorderLayout . CENTER ) ; JFrame frame = new JFrame ( "RoboMasterMind" ) ; frame . setDefaultCloseOperation ( WindowConstants . EXIT_ON_CLOSE ) ; frame . getContentPane ( ) . add ( toolbar , BorderLayout . NORTH ) ; frame . getContentPane ( ) . add ( panel , BorderLayout . CENTER ) ; frame . setSize ( 800 , 600 ) ; frame . setLocationRelativeTo ( null ) ; frame . setVisible ( true ) ; }
va	7	public int [ ] twoSum ( int [ ] numbers , int target ) { HashMap < Integer , LinkedList < Integer >> h = new HashMap < Integer , LinkedList < Integer >> ( ) ; int len = numbers . length ; int in1 = 0 , in2 = 0 ; int [ ] in = new int [ 2 ] ; for ( int i = 0 ; i < len ; i ++ ) { if ( ! ( h . containsKey ( numbers [ i ] ) ) ) { LinkedList < Integer > ltemp = new LinkedList < Integer > ( ) ; ltemp . add ( i ) ; h . put ( numbers [ i ] , ltemp ) ; } else { h . get ( numbers [ i ] ) . add ( i ) ; } } for ( int i = 0 ; i < len ; i ++ ) { if ( ( target != 2 * numbers [ i ] ) && h . containsKey ( target - numbers [ i ] ) ) { in1 = i ; in2 = h . get ( target - numbers [ i ] ) . peekFirst ( ) ; break ; } if ( ( target == 2 * numbers [ i ] ) && h . get ( numbers [ i ] ) . size ( ) > 1 ) { in1 = h . get ( target - numbers [ i ] ) . peekFirst ( ) ; in2 = h . get ( target - numbers [ i ] ) . peekLast ( ) ; } } in [ 0 ] = 1 + Math . min ( in1 , in2 ) ; in [ 1 ] = 1 + Math . max ( in1 , in2 ) ; return in ; }
va	5	private Classifier tune ( Instances train , int folds , int trials , int seed ) throws Exception { if ( this . baseClassifiers . length == 1 ) return baseClassifiers [ 0 ] ; final int trialsF = trials ; final Instances [ ] trains = new Instances [ trials ] ; final Instances [ ] tests = new Instances [ trials ] ; crossData ( train , trains , tests , trials , folds , new Random ( seed ) ) ; final Values v = new Values ( ) ; v . loss = double . MAX_VALUE ; v . best = 0 ; ExecutorService execLoop = Executors . newFixedThreadPool ( NUM_OF_PROCESSORS ) ; final CountDownLatch latch = new CountDownLatch ( this . baseClassifiers . length ) ; for ( int j = 0 ; j < this . baseClassifiers . length ; j ++ ) { final int jF = j ; execLoop . submit ( new Runnable ( ) { @ Override public void run ( ) { double currentLoss ; try { currentLoss = test ( baseClassifiers [ jF ] , trains , tests , trialsF ) ; if ( currentLoss < v . loss ) { v . loss = currentLoss ; v . best = jF ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } latch . countDown ( ) ; } } ) ; } try { latch . await ( ) ; } catch ( InterruptedException e2 ) { e2 . printStackTrace ( ) ; } execLoop . shutdown ( ) ; return baseClassifiers [ v . best ] ; }
va	3	public final T execute ( ) throws DiffbotException { try { HttpRequest request = client . getRequestFactory ( ) . buildGetRequest ( this . url ) ; request . setReadTimeout ( readTimeout ) ; HttpResponse response = request . execute ( ) ; if ( responseClass . equals ( Frontpage . class ) ) { return parseFrontpage ( response ) ; } else { return parseModel ( response ) ; } } catch ( HttpResponseException e ) { parseAPIError ( e . getStatusCode ( ) , e . getContent ( ) ) ; return null ; } catch ( IOException e ) { throw new DiffbotServerException ( bundle . getString ( "request.not.executed" ) , e ) ; } }
va	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( NewTableDialog . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( NewTableDialog . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( NewTableDialog . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( NewTableDialog . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { NewTableDialog dialog = new NewTableDialog ( new javax . swing . JFrame ( ) , true ) ; dialog . addWindowListener ( new java . awt . event . WindowAdapter ( ) { @ Override public void windowClosing ( java . awt . event . WindowEvent e ) { System . exit ( 0 ) ; } } ) ; dialog . setVisible ( true ) ; } } ) ; }
va	2	public static List < Entity > filterByID ( List < Entity > list , int id ) { List < Entity > filtered = new LinkedList < > ( ) ; for ( Entity slot : list ) { if ( slot . id == id ) { filtered . add ( slot ) ; } } return filtered ; }
va	5	public static void add_tab_listener ( final TabFolder primary_folder , final int [ ] load_indicator , final String table_name , final TabItem tab_item , final String [ ] col_names , final String query , final TabFolder secondary_folder ) { primary_folder . addSelectionListener ( new SelectionAdapter ( ) { public void widgetSelected ( org . eclipse . swt . events . SelectionEvent event ) { if ( load_indicator [ 0 ] != 1 && primary_folder . getSelection ( ) [ 0 ] . getText ( ) . compareTo ( table_name ) == 0 ) { try { tab_item . setControl ( create_table ( primary_folder , col_names , query ) ) ; load_indicator [ 0 ] = 1 ; } catch ( IllegalArgumentException e ) { try { tab_item . setControl ( create_table ( secondary_folder , col_names , query ) ) ; load_indicator [ 0 ] = 1 ; } catch ( SQLException e1 ) { e1 . printStackTrace ( ) ; } load_indicator [ 0 ] = 1 ; } catch ( SQLException e ) { e . printStackTrace ( ) ; } } } } ) ; }
va	2	public int [ ] algorithm2 ( int array [ ] , int n ) { HashSet < Integer > hashSet = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < array . length ; i ++ ) { int difference = n - array [ i ] ; if ( hashSet . contains ( difference ) ) { int [ ] result = { difference , array [ i ] } ; return result ; } else { hashSet . add ( array [ i ] ) ; } } int result [ ] = { } ; return result ; }
va	0	public int [ ] getBlockPointers ( ) { return this . blockPointers ; }
va	3	protected void updateProperty ( INDIProperty property , String message ) throws INDIException { if ( properties . containsValue ( property ) ) { if ( property instanceof INDISwitchProperty ) { INDISwitchProperty sp = ( INDISwitchProperty ) property ; if ( ! sp . checkCorrectValues ( ) ) { throw new INDIException ( "Switch (" + property . getName ( ) + ") value not value (not following its rule)." ) ; } } String msg = property . getXMLPropertySet ( message ) ; sendXML ( msg ) ; } else { throw new INDIException ( "The Property is not from this driver. Maybe you forgot to add it?" ) ; } }
va	3	private static void printPrimeLessThan ( int n ) { int [ ] marked = new int [ n ] ; for ( int p = 2 ; p < marked . length ; ++ p ) { if ( marked [ p ] == 0 ) { System . out . println ( p ) ; for ( int i = p ; i < marked . length ; i += p ) { marked [ i ] = 1 ; } } } }
va	3	public static int [ ] [ ] generateMatrix ( int n ) { int [ ] [ ] matrix ; if ( n == 0 ) return new int [ 0 ] [ 0 ] ; matrix = new int [ n ] [ n ] ; int [ ] [ ] matrixHelper = new int [ matrix . length ] [ matrix [ 0 ] . length ] ; int i = 0 ; int j = 0 ; int width = matrix [ 0 ] . length ; int length = matrix . length ; int count = 1 ; while ( i <= width / 2 && j <= length / 2 ) { count = spiralOrderHelper ( matrix , i , j , matrixHelper , count ) ; i ++ ; j ++ ; } return matrix ; }
va	0	public int getPages ( ) { return pages ; }
va	6	private void jmi_selectActionPerformed ( java . awt . event . ActionEvent evt ) { TreePath tp = jt_database_table_list . getSelectionPath ( ) ; String q = "select * from " ; if ( tp . getPathCount ( ) == 3 ) { for ( int i = 1 ; i < 3 ; i ++ ) { if ( i == 1 ) { q += tp . getPathComponent ( i ) . toString ( ) + "." ; } else { q += tp . getPathComponent ( i ) . toString ( ) ; } } } else { for ( int i = 0 ; i < 2 ; i ++ ) { if ( i == 0 ) { q += tp . getPathComponent ( i ) . toString ( ) + "." ; } else { q += tp . getPathComponent ( i ) . toString ( ) ; } } } if ( sql_exe != null ) { sql_exe . set_query_and_exec ( q ) ; } }
va	7	public void setMonde ( Monde m ) { this . m = m ; List < case > cases_libres = new ArrayList < case > ( ) ; for ( case c : this . m . get_cases ( ) ) { if ( c . getNiveau_obstacle ( ) == 0 ) { cases_libres . add ( c ) ; } } if ( cases_libres . size ( ) > 0 && ConfigurationLoader . MAX_FOURMILIERES >= 1 ) { case c = cases_libres . get ( new Random ( ) . nextInt ( cases_libres . size ( ) ) ) ; cases_libres . remove ( c ) ; frmModel . data . add ( new Object [ ] { 1 , c . getY ( ) , c . getX ( ) , 45 , 5 , 6 , 20 , 100 , Color . green } ) ; } if ( cases_libres . size ( ) > 0 && ConfigurationLoader . MAX_FOURMILIERES >= 2 ) { case c = cases_libres . get ( new Random ( ) . nextInt ( cases_libres . size ( ) ) ) ; cases_libres . remove ( c ) ; frmModel . data . add ( new Object [ ] { 0 , c . getY ( ) , c . getX ( ) , 45 , 5 , 6 , 20 , 100 , Color . blue } ) ; } try { paintMap ( m , frmModel ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } }
va	1	@ Override public void removeConsumer ( StringConsumer sc ) { if ( sc != null ) { ClientDescriptor clientDescriptor = ( ClientDescriptor ) sc ; clientDescriptor . removeConsumer ( this ) ; this . consumer = null ; } }
va	1	@ Override public void addColumn ( TableColumn column ) { if ( tableColumns . size ( ) == 3 ) { column . setCellRenderer ( renderer ) ; column . setCellEditor ( editor ) ; } super . addColumn ( column ) ; }
va	9	public void mouseClicked ( MouseEvent e ) { if ( e . getClickCount ( ) == 2 ) { doubleClick ( e ) ; } if ( e . getButton ( ) == 3 || e . isPopupTrigger ( ) ) { final boolean shiftDown = e . isShiftDown ( ) ; coverSelected = ctx . getSelectedAt ( e ) ; popupPos = ctx . getXY ( e ) ; if ( coverSelected != null ) { final JPopupMenu menu2 = new JPopupMenu ( ) ; { if ( shiftDown ) { JMenuItem menuItem = new JMenuItem ( "Play immediately..." ) ; menuItem . setEnabled ( false ) ; menu2 . add ( menuItem ) ; menu2 . addSeparator ( ) ; } final List < CoverDetails > allDiscs = new LinkedList < CoverDetails > ( ) ; allDiscs . add ( coverSelected ) ; if ( coverSelected . getOtherDiscs ( ) != null ) { allDiscs . addAll ( coverSelected . getOtherDiscs ( ) ) ; } boolean first = true ; for ( final CoverDetails cover : allDiscs ) { if ( first ) { first = false ; } else { menu2 . addSeparator ( ) ; } JMenuItem menuItem = new JMenuItem ( cover . getArtist ( ) + " - " + cover . getAlbum ( ) ) ; menuItem . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { ctx . getPlayerInterface ( ) . enqueueAlbum ( cover , shiftDown ) ; } } ) ; menu2 . add ( menuItem ) ; menu2 . addSeparator ( ) ; int counter = 0 ; for ( final TrackDetails track : cover . getTrackNames ( ) ) { counter ++ ; menuItem = new JMenuItem ( counter + " - " + track . getTitle ( ) + " [" + formatTrackTime ( track . getLengthSeconds ( ) ) + "]" ) ; menuItem . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { ctx . getPlayerInterface ( ) . enqueueTrack ( cover , track . getTitle ( ) , shiftDown ) ; } } ) ; menu2 . add ( menuItem ) ; } } if ( editMode ) { menu2 . addSeparator ( ) ; JMenuItem menuItem = new JMenuItem ( "Hide album" ) ; menuItem . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { for ( final CoverDetails cover : allDiscs ) { cover . setHidden ( true ) ; } ctx . mainViewer . saveLayout ( ) ; ctx . mainRepaint ( ) ; } } ) ; menu2 . add ( menuItem ) ; menuItem = new JMenuItem ( "Toggle various artists" ) ; menuItem . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { for ( final CoverDetails cover : allDiscs ) { cover . setVariousArtists ( ! cover . isVariousArtists ( ) ) ; } ctx . mainViewer . saveLayout ( ) ; ctx . mainRepaint ( ) ; } } ) ; menu2 . add ( menuItem ) ; menuItem = new JMenuItem ( "Remove" ) ; menuItem . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { for ( final CoverDetails cover : allDiscs ) { ctx . removeCover ( cover ) ; } ctx . mainRepaint ( ) ; } } ) ; menu2 . add ( menuItem ) ; } } menu2 . show ( e . getComponent ( ) , e . getX ( ) , e . getY ( ) ) ; MainViewer . registerVisibleMenu ( menu2 ) ; } } }
va	8	public VNCViewer ( String [ ] argv ) { applet = false ; for ( int i = 0 ; i < argv . length ; i ++ ) { if ( argv [ i ] . equalsIgnoreCase ( "-log" ) ) { if ( ++ i >= argv . length ) usage ( ) ; System . err . println ( "Log setting: " + argv [ i ] ) ; rfb . LogWriter . setLogParams ( argv [ i ] ) ; continue ; } if ( rfb . Configuration . setParam ( argv [ i ] ) ) continue ; if ( argv [ i ] . charAt ( 0 ) == - ) { if ( i + 1 < argv . length ) { if ( rfb . Configuration . setParam ( argv [ i ] . substring ( 1 ) , argv [ i + 1 ] ) ) { i ++ ; continue ; } } usage ( ) ; } if ( vncServerName . getValue ( ) != null ) usage ( ) ; vncServerName . setParam ( argv [ i ] ) ; } }
va	7	private boolean byteArrayEquals ( byte [ ] left , byte [ ] right ) { if ( left != null && right != null ) { if ( left . length != right . length ) return false ; for ( int i = 0 ; i < left . length ; i ++ ) { if ( left [ i ] != right [ i ] ) { return false ; } } return true ; } if ( left == null && right == null ) return true ; return false ; }
va	1	public void cargarSelect ( ) { combo_comuna_reporte . removeAllItems ( ) ; combo_comuna_reporte . addItem ( "Seleccione" ) ; for ( int i = 0 ; i < getControlador ( ) . getListacomunas ( ) . size ( ) ; i ++ ) { combo_comuna_reporte . addItem ( getControlador ( ) . getListacomunas ( ) . get ( i ) . getCom_nombre ( ) ) ; } }
va	5	public Client ( ) { gui = new WindowHandler ( this ) ; try { socket = new Socket ( server , port ) ; reader = new BufferedReader ( new InputStreamReader ( socket . getInputStream ( ) ) ) ; writer = new BufferedWriter ( new OutputStreamWriter ( socket . getOutputStream ( ) ) ) ; Thread listener = new Thread ( new Runnable ( ) { public void run ( ) { String input ; try { while ( ( input = reader . readLine ( ) ) != null ) { handleInput ( input ) ; } } catch ( EOFException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } } ) ; listener . start ( ) ; } catch ( UnknownHostException e ) { gui . showError ( String . format ( "ERROR: Host is unreachable.\n%s\n" , e . getMessage ( ) ) ) ; System . exit ( - 1 ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }
va	0	@ Test ( expected = LexicalException . class ) public void testIllegalChar ( ) throws LexicalException { String input = "this is # an test \nwith an illegal char" ; String expected = "dummy" ; compareText ( input , expected ) ; }
va	2	@ Override public void deleteGenericFeature ( int studyId ) { Connection conn = null ; StringBuffer feature_query = new StringBuffer ( ) ; try { conn = getConnection ( ) ; feature_query . append ( "DELETE FROM " ) . append ( super . getPrimaryTableName ( ) ) . append ( " WHERE " ) . append ( "study_id = " + studyId ) ; executeUpdate ( conn , feature_query . toString ( ) ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { if ( conn != null ) { close ( conn ) ; } } }
va	0	public void setFuncoes ( Funcoes funcoes ) { this . funcoes = funcoes ; }
va	1	public boolean addAll ( Collection < T > metadataList ) { for ( T metadata : metadataList ) { add ( metadata ) ; } return ! metadataList . isEmpty ( ) ; }
va	4	private synchronized void addModeltoQueue ( ) { GCodeStore gcstore = printModel . getGcodes ( ) ; int size = gcstore . size ( ) ; for ( int ig = 0 ; ig < size ; ig ++ ) { GCode gc = gcstore . get ( ig ) ; if ( Thread . currentThread ( ) . isInterrupted ( ) ) return ; aprintQ . add ( gc ) ; } if ( postgc != null ) { for ( int i = 0 ; i < postgc . length ; i ++ ) { aprintQ . add ( postgc [ i ] ) ; } } remainingtime = printModel . getTimeaccel ( ) ; }
va	9	private void initListeners ( ) { detailsButton . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { detailsButtonAction ( ) ; } } ) ; logsButton . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { logsButtonAction ( ) ; } } ) ; if ( needsPipeline ) { plPostInstallComboBox . addItemListener ( new ItemListener ( ) { public void itemStateChanged ( ItemEvent e ) { if ( e . getStateChange ( ) == ItemEvent . DESELECTED ) { return ; } if ( plPostInstallComboBox . getSelectedIndex ( ) == 0 ) { return ; } String selectedAction = ( String ) plPostInstallComboBox . getSelectedItem ( ) ; plPostInstallComboBox . setSelectedIndex ( 0 ) ; if ( selectedAction . equals ( ACTION_CONFIGURE_SERVER ) ) { String startServerValue = Configuration . getConfig ( Configuration . START_PIPELINE_SERVER ) ; String startClientValue = Configuration . getConfig ( Configuration . START_PIPELINE_CLIENT ) ; Configuration . setConfig ( Configuration . CONFIGURE_PIPELINE_SERVER , "true" ) ; if ( startServerValue != null ) { Configuration . setConfig ( Configuration . START_PIPELINE_SERVER , "false" ) ; } if ( startClientValue != null ) { Configuration . setConfig ( Configuration . START_PIPELINE_CLIENT , "false" ) ; } sif . postInstall ( ) ; if ( startServerValue != null ) { Configuration . setConfig ( Configuration . START_PIPELINE_SERVER , String . valueOf ( startServerValue ) ) ; } if ( startClientValue != null ) { Configuration . setConfig ( Configuration . START_PIPELINE_CLIENT , String . valueOf ( startClientValue ) ) ; } } else if ( selectedAction . equals ( ACTION_START_SERVER ) ) { int choice = JOptionPane . showConfirmDialog ( sif , "If you launch the server now  temporarily you will not be able to access some of the\n" + "services or tools which are currently being installed. You will be offered again to start\n" + "the server when the whole installation will be over.\n\n" + "Are you sure that you want to start the server right now ? " , "Warning" , JOptionPane . YES_NO_OPTION ) ; if ( choice != JOptionPane . YES_OPTION ) { return ; } String startClientValue = Configuration . getConfig ( Configuration . START_PIPELINE_CLIENT ) ; Configuration . setConfig ( Configuration . START_PIPELINE_SERVER , "true" ) ; if ( startClientValue != null ) { Configuration . setConfig ( Configuration . START_PIPELINE_CLIENT , "false" ) ; } sif . postInstall ( ) ; if ( startClientValue != null ) { Configuration . setConfig ( Configuration . START_PIPELINE_CLIENT , String . valueOf ( startClientValue ) ) ; } plPostInstallComboBox . removeItem ( ACTION_START_SERVER ) ; JOptionPane . showMessageDialog ( sif , "Server started." , "Success" , JOptionPane . INFORMATION_MESSAGE ) ; } else if ( selectedAction . equals ( ACTION_START_CLIENT ) ) { String startServerValue = Configuration . getConfig ( Configuration . START_PIPELINE_SERVER ) ; Configuration . setConfig ( Configuration . START_PIPELINE_CLIENT , "true" ) ; if ( startServerValue != null ) { Configuration . setConfig ( Configuration . START_PIPELINE_SERVER , "false" ) ; } sif . postInstall ( ) ; if ( startServerValue != null ) { Configuration . setConfig ( Configuration . START_PIPELINE_SERVER , String . valueOf ( startServerValue ) ) ; } plPostInstallComboBox . removeItem ( ACTION_START_CLIENT ) ; } } } ) ; } }
va	0	public String getDescription ( ) { return description ; }
va	6	public void put ( JsonObject source , String sourceKey , String destinationKey ) { if ( source . has ( sourceKey ) ) { JsonElement value = source . get ( sourceKey ) ; if ( ! value . isJsonPrimitive ( ) ) put ( destinationKey , null ) ; if ( value . isJsonPrimitive ( ) ) { JsonPrimitive primitiveValue = value . getAsJsonPrimitive ( ) ; if ( primitiveValue . isBoolean ( ) ) put ( destinationKey , primitiveValue . getAsBoolean ( ) ) ; else if ( primitiveValue . isNumber ( ) ) put ( destinationKey , primitiveValue . getAsNumber ( ) ) ; else if ( primitiveValue . isString ( ) ) put ( destinationKey , primitiveValue . getAsString ( ) ) ; else throw new IllegalArgumentException ( ) ; } } else put ( destinationKey , null ) ; }
va	3	public static HashSet < String > WordlistHash ( String file , boolean lowercase ) { HashSet < String > result = new HashSet < String > ( ) ; try { BufferedReader br = new BufferedReader ( new FileReader ( file ) ) ; String line = null ; while ( ( line = br . readLine ( ) ) != null ) { line . trim ( ) ; result . add ( lowercase ? line . toLowerCase ( ) : line ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } return result ; }
va	1	public synchronized void close ( ) { acceptor . quit ( ) ; OtpCookedConnection conn ; final Collection < OtpCookedConnection > coll = connections . values ( ) ; final Iterator < OtpCookedConnection > it = coll . iterator ( ) ; mboxes . clear ( ) ; while ( it . hasNext ( ) ) { conn = it . next ( ) ; it . remove ( ) ; conn . close ( ) ; } initDone = false ; }
va	0	@ JsonAnyGetter public Map < String , Object > getAdditionalProperties ( ) { return this . additionalProperties ; }
va	9	public boolean mouseDrag ( Event event , int x , int y ) { boolean firstDrag = false ; if ( ! dragged && ( x < dragStart . x - dragThreshold || x > dragStart . x + dragThreshold || y < dragStart . y - dragThreshold || y > dragStart . y + dragThreshold ) ) { dragged = true ; firstDrag = true ; } if ( ! dragged ) return super . mouseDrag ( event , x , y ) ; if ( newGeneratorFlag ) { } else if ( moveOriginFlag ) { if ( firstDrag ) pa . setCursor ( Frame . HAND_CURSOR ) ; } else if ( moveGeneratorFlag ) { if ( firstDrag ) pa . setCursor ( Frame . MOVE_CURSOR ) ; } else if ( selectDestFlag ) { if ( firstDrag ) pa . statusBar . setText ( "Select destination for connection" ) ; } if ( rubbers != null ) { Graphics g = getGraphics ( ) ; for ( int i = 0 ; i < rubbers . length ; i ++ ) rubbers [ i ] . move ( g , x , y ) ; g . dispose ( ) ; return true ; } else return super . mouseDrag ( event , x , y ) ; }
va	2	public Set < EpisodeMatch > getSeasonEpisodes ( String show , int season ) { Set < EpisodeMatch > set = new HashSet < > ( ) ; show = show . toLowerCase ( ) ; if ( tvMap . containsKey ( show ) && tvMap . get ( show ) . containsKey ( season ) ) { set . addAll ( tvMap . get ( show ) . get ( season ) . values ( ) ) ; } return set ; }
va	5	public void setColorAt ( int x , int y , Color color ) { if ( image == null || x < 0 || x >= image . getWidth ( ) || y < 0 || y >= image . getHeight ( ) ) { throw new IndexOutOfBoundsException ( "(" + x + " " + y + ")" ) ; } else { image . setRGB ( x , y , ( ( int ) color . getRed ( ) ) * 65536 + ( ( int ) color . getGreen ( ) ) * 256 + ( int ) color . getBlue ( ) ) ; Canvas . getInstance ( ) . repaint ( ) ; } }
va	7	public boolean closeLevel ( ) { boolean leave = false ; if ( mapPanel != null && mapPanel . level != null && mapPanel . level . isModified ( ) ) { int choice = JOptionPane . showConfirmDialog ( fileChooser , "Store the changes to \"" + mapPanel . level . getLevelName ( ) + "\"?" , "" , JOptionPane . YES_NO_CANCEL_OPTION ) ; if ( choice == JOptionPane . YES_OPTION ) { if ( mapPanel . level . getFilePath ( ) != null ) { mapPanel . level . write ( mapPanel . level . getFilePath ( ) ) ; } else { fileChooser . addChoosableFileFilter ( levelFilter ) ; fileChooser . setFileFilter ( levelFilter ) ; int choice2 = fileChooser . showSaveDialog ( fileChooser ) ; fileChooser . removeChoosableFileFilter ( levelFilter ) ; if ( choice2 == JFileChooser . APPROVE_OPTION ) { File file = fileChooser . getSelectedFile ( ) ; mapPanel . level . setFilePath ( file ) ; mapPanel . level . write ( mapPanel . level . getFilePath ( ) ) ; leave = true ; } } } else if ( choice == JOptionPane . NO_OPTION ) { leave = true ; } } else { leave = true ; } return leave ; }
va	8	public void removeExit ( String direction ) { if ( direction == null || direction . equals ( "null" ) ) { return ; } if ( roomsArray [ x ] [ y ] == null || rooms . get ( roomsArray [ x ] [ y ] ) . getExit ( direction ) == null ) { return ; } Room currentRoom = rooms . get ( roomsArray [ x ] [ y ] ) ; Room neighbor = currentRoom . getExit ( direction ) ; boolean north = direction . equals ( NORTH ) ; boolean south = direction . equals ( SOUTH ) ; boolean west = direction . equals ( WEST ) ; boolean east = direction . equals ( EAST ) ; if ( north ) { currentRoom . removeExit ( NORTH ) ; neighbor . removeExit ( SOUTH ) ; } else if ( south ) { currentRoom . removeExit ( SOUTH ) ; neighbor . removeExit ( NORTH ) ; } else if ( west ) { currentRoom . removeExit ( WEST ) ; neighbor . removeExit ( EAST ) ; } else if ( east ) { currentRoom . removeExit ( EAST ) ; neighbor . removeExit ( WEST ) ; } update ( ) ; }
va	8	@ Override protected Relatedness calcRelatedness ( Concept synset1 , Concept synset2 ) { StringBuilder tracer = new StringBuilder ( ) ; if ( synset1 == null || synset2 == null ) return new Relatedness ( min , null , illegalSynset ) ; StringBuilder subTracer = enableTrace ? new StringBuilder ( ) : null ; List < Subsumer > lcsList = pathFinder . getLCSByPath ( synset1 , synset2 , subTracer ) ; if ( lcsList . size ( ) == 0 ) return new Relatedness ( min ) ; int maxDepth = 1 ; if ( synset1 . getPos ( ) . equals ( POS . n ) ) { maxDepth = 20 ; } else if ( synset1 . getPos ( ) . equals ( POS . v ) ) { maxDepth = 14 ; } int length = lcsList . get ( 0 ) . length ; double score = - Math . log ( ( double ) length / ( double ) ( 2 * maxDepth ) ) ; if ( enableTrace ) { tracer . append ( subTracer . toString ( ) ) ; for ( Subsumer lcs : lcsList ) { tracer . append ( "Lowest Common Subsumer(s): " ) ; tracer . append ( db . conceptToString ( lcs . subsumer . getSynset ( ) ) + " (Length=" + lcs . length + ")\n" ) ; } } return new Relatedness ( score , tracer . toString ( ) , null ) ; }
va	3	public void place ( int row , int [ ] column , int n ) { if ( row == n ) { createsolution ( column , n ) ; return ; } int i = 0 ; for ( i = 0 ; i < n ; i ++ ) { column [ row ] = i ; if ( check ( row , column ) ) { place ( row + 1 , column , n ) ; } } }
va	8	public Model getRotatedModel ( ) { if ( desc == null ) return null ; Model model = method450 ( ) ; if ( model == null ) return null ; super . height = model . modelHeight ; if ( super . anInt1520 != - 1 && super . anInt1521 != - 1 ) { SpotAnim spotAnim = SpotAnim . cache [ super . anInt1520 ] ; Model model_1 = spotAnim . getModel ( ) ; if ( model_1 != null ) { int j = spotAnim . aAnimation_407 . anIntArray353 [ super . anInt1521 ] ; Model model_2 = new Model ( true , Class36 . method532 ( j ) , false , model_1 ) ; model_2 . method475 ( 0 , - super . anInt1524 , 0 ) ; model_2 . method469 ( ) ; model_2 . method470 ( j ) ; model_2 . anIntArrayArray1658 = null ; model_2 . anIntArrayArray1657 = null ; if ( spotAnim . anInt410 != 128 || spotAnim . anInt411 != 128 ) model_2 . method478 ( spotAnim . anInt410 , spotAnim . anInt410 , spotAnim . anInt411 ) ; model_2 . method479 ( 64 + spotAnim . anInt413 , 850 + spotAnim . anInt414 , - 30 , - 50 , - 30 , true ) ; Model aModel [ ] = { model , model_2 } ; model = new Model ( aModel ) ; } } if ( desc . aByte68 == 1 ) model . aBoolean1659 = true ; return model ; }
va	0	public String getComment ( ) { return this . comment ; }
va	1	DBException ( SQLException father , String sqlCause ) { super ( father ) ; this . sqlCause = sqlCause ; if ( is_foreign_key ( ) ) { type = FOREIGN_KEY ; } }
va	9	public String getInput ( Player player ) { String newToken = null ; Scanner in = new Scanner ( System . in ) ; boolean valid = false ; while ( ! valid ) { System . out . println ( "\n\t" + player . getName ( ) ) ; this . display ( ) ; newToken = in . nextLine ( ) ; if ( newToken == null || newToken . length ( ) < 1 ) { continue ; } newToken = newToken . toUpperCase ( ) ; if ( newToken . equals ( "Q" ) ) { return null ; } int i = 0 ; boolean breakout = false ; do { if ( newToken . equals ( tokenOptions [ i ] [ 0 ] ) ) { newToken = tokenOptions [ i ] [ 1 ] ; breakout = true ; } i ++ ; } while ( tokenOptions . length != i && ! breakout ) ; try { if ( i == tokenOptions . length ) { throw new TokenException ( ErrorType . ERROR105 . getMessage ( ) ) ; } } catch ( TokenException ex ) { ErrorType . displayErrorMsg ( ex . getMessage ( ) ) ; } try { if ( this . game . getPlayerA ( ) . getToken ( ) . equals ( newToken ) || this . game . getPlayerB ( ) . getToken ( ) . equals ( newToken ) ) { throw new TokenException ( ErrorType . ERROR104 . getMessage ( ) ) ; } } catch ( TokenException ex ) { ErrorType . displayErrorMsg ( ex . getMessage ( ) ) ; } valid = true ; } return newToken ; }
va	5	public boolean playToEndOfMedia ( int timeOutMillis ) { long startTime = System . currentTimeMillis ( ) ; eom = false ; synchronized ( this ) { player . start ( ) ; while ( ! eom && ! failed ) { try { wait ( timeOutMillis ) ; } catch ( InterruptedException ie ) { } if ( System . currentTimeMillis ( ) - startTime > timeOutMillis ) break ; } } return eom && ! failed ; }
va	3	public void synchronize ( CardModel < ? > . Card card ) { setBorder ( new CardBorder ( card . selected ) ) ; updateText ( card ) ; pinButton . setVisible ( card . selected ) ; pinButton . setSelected ( card . pinned ) ; markButton . setSelected ( card . marked ) ; setOpaque ( true ) ; setBackground ( card . marked ? MARK_COLOR : card . selected ? SELECTED_COLOR : DEFAULT_COLOR ) ; }
va	9	private void planWays ( GameUnit unit , int mp , Way way , Set < Way > ways ) { if ( mp < 10 ) { return ; } XY checkedPlace = way . getLastPlace ( ) ; Set < XY > neighbourCells = getFreeNeighbourCells ( checkedPlace ) ; for ( XY neighbourCell : neighbourCells ) { int stepPrice = unit . calculateStepPrice ( checkedPlace , neighbourCell ) ; if ( ( stepPrice > 0 ) && ( mp >= stepPrice ) ) { int wayPrice = way . getPrice ( ) + stepPrice ; Set < Way > otherWays = new HashSet < Way > ( ) ; for ( Way otherWay : ways ) { if ( otherWay . getLastPlace ( ) . equals ( neighbourCell ) ) { otherWays . add ( otherWay ) ; } } int minDistance = wayPrice ; for ( Way otherWay : otherWays ) { if ( otherWay . getPrice ( ) < minDistance ) { minDistance = otherWay . getPrice ( ) ; } } if ( wayPrice <= minDistance ) { Way checkedWay = way . copy ( way ) ; checkedWay . add ( neighbourCell , stepPrice ) ; ways . add ( checkedWay ) ; planWays ( unit , mp - stepPrice , checkedWay , ways ) ; } for ( Way otherWay : otherWays ) { if ( otherWay . getPrice ( ) > minDistance ) { ways . remove ( otherWay ) ; } } } } }
va	6	public boolean getBoolean ( String key ) throws JSONException { Object object = this . get ( key ) ; if ( object . equals ( boolean . false ) || ( object instanceof String && ( ( String ) object ) . equalsIgnoreCase ( "false" ) ) ) { return false ; } else if ( object . equals ( boolean . true ) || ( object instanceof String && ( ( String ) object ) . equalsIgnoreCase ( "true" ) ) ) { return true ; } throw new JSONException ( "JSONObject[" + quote ( key ) + "] is not a Boolean." ) ; }
va	5	public boolean equals ( Object _other ) { if ( _other == null ) { return false ; } if ( _other == this ) { return true ; } if ( ! ( _other instanceof UStatus ) ) { return false ; } final UStatus _cast = ( UStatus ) _other ; if ( uStatus == null ? _cast . uStatus != uStatus : ! uStatus . equals ( _cast . uStatus ) ) { return false ; } return true ; }
va	9	public JSONObject ( JSONTokener x ) throws JSONException { this ( ) ; char c ; String key ; if ( x . nextClean ( ) != { ) { throw x . syntaxError ( "A JSONObject text must begin with '{'" ) ; } for ( ; ; ) { c = x . nextClean ( ) ; switch ( c ) { case 0 : throw x . syntaxError ( "A JSONObject text must end with '}'" ) ; case } : return ; default : x . back ( ) ; key = x . nextValue ( ) . toString ( ) ; } c = x . nextClean ( ) ; if ( c == = ) { if ( x . next ( ) != > ) { x . back ( ) ; } } else if ( c != : ) { throw x . syntaxError ( "Expected a ':' after a key" ) ; } putOnce ( key , x . nextValue ( ) ) ; switch ( x . nextClean ( ) ) { case ; : case   : if ( x . nextClean ( ) == } ) { return ; } x . back ( ) ; break ; case } : return ; default : throw x . syntaxError ( "Expected a ' ' or '}'" ) ; } } }
va	0	public Employee ( Integer salary , String title , String name ) { this . salary = salary ; this . title = title ; this . name = name ; }
va	4	public void paramterizedTest ( double kwota , char typ ) { System . out . println ( kwota + " " + typ ) ; String k = "" + kwota + typ ; List < String > goodRes = goodResults . get ( k ) ; ContractFactory cf = new ContractFactoryImpl ( ) ; BaseContract bc = cf . createContract ( typ ) ; if ( bc != null ) bc . setPodstawa ( kwota ) ; ArrayListOutputWriter wr = new ArrayListOutputWriter ( ) ; TaxReportTemplate trt = new StandardTaxReport ( bc , wr ) ; trt . createReport ( ) ; List < String > myRes = wr . getResult ( ) ; if ( goodRes . size ( ) != myRes . size ( ) ) { assert . assertEquals ( true , false ) ; } int len = myRes . size ( ) ; if ( goodRes != null ) { for ( int i = 0 ; i < len ; i ++ ) { String good = goodRes . get ( i ) ; String my = myRes . get ( i ) ; System . out . println ( "GOOD: " + good ) ; System . out . println ( "MY: " + my ) ; assert . assertTrue ( good . equals ( my ) ) ; } } else { assert . assertEquals ( true , false ) ; } }
va	3	public void addUserInterruptListener ( ActionListener al ) { if ( listeners == null || ( listeners != null && listeners . isEmpty ( ) ) ) listeners = new Vector < ActionListener > ( ) ; listeners . add ( al ) ; }
va	7	private FeatureVector getdX2 ( int k , SRLFeatureData sfd , DependencyInstance gold , DependencyInstance pred ) { double [ ] [ ] wpU = sfd . wpU , wpV = sfd . wpV , ppW = sfd . ppW , cpX = sfd . cpX ; FeatureVector dX2 = new FeatureVector ( L2 ) ; int F = pred . numframes , N = pred . length , L = sfd . L ; for ( int i = 0 ; i < F ; ++ i ) { SemanticFrame frame = gold . frames [ i ] ; SemanticFrame frame2 = pred . frames [ i ] ; int p = frame . predid ; for ( int a = 0 ; a < N ; ++ a ) { if ( frame . arglbids [ a ] == frame2 . arglbids [ a ] ) continue ; boolean isValid = ! sfd . isPruned ( p , a ) ; { int r = frame . arglbids [ a ] ; if ( isValid && r >= 0 ) { int id = i * N * L + a * L + r ; double . = wpU [ p ] [ k ] * wpV [ a ] [ k ] * ppW [ id ] [ k ] ; dX2 . addEntries ( sfd . contextFvs [ id ] , . ) ; } } { int r = frame2 . arglbids [ a ] ; if ( isValid && r >= 0 ) { int id = i * N * L + a * L + r ; double . = wpU [ p ] [ k ] * wpV [ a ] [ k ] * ppW [ id ] [ k ] ; dX2 . addEntries ( sfd . contextFvs [ id ] , - . ) ; } } } } return dX2 ; }
va	4	protected Color GetRandomColor ( ) { Color c = Color . WHITE ; int rand = ( int ) ( Math . random ( ) * 4 ) ; switch ( rand ) { case 0 : { c = Color . GREEN ; } break ; case 1 : { c = Color . CYAN ; } break ; case 2 : { c = Color . RED ; } break ; case 3 : { c = Color . MAGENTA ; } break ; } return c ; }
va	7	public String executeCommands ( Object object ) { String command = null ; Scanner inFile = Connect4 . getInputFile ( ) ; do { try { this . display ( ) ; command = inFile . nextLine ( ) ; command = command . trim ( ) . toUpperCase ( ) ; switch ( command ) { case "1" : this . mainMenuControl . startOnePlayerGame ( ) ; break ; case "2" : this . mainMenuControl . startTwoPlayerGame ( ) ; break ; case "T" : this . mainMenuControl . getAnswers ( ) ; case "H" : this . mainMenuControl . displayHelpMenu ( ) ; break ; case "Q" : break ; default : throw new MenuException ( ErrorType . ERROR101 . getMessage ( ) ) ; } } catch ( MenuException e ) { System . out . println ( "\n" + e . getMessage ( ) ) ; } } while ( ! command . equals ( "Q" ) ) ; return ( "Q" ) ; }
va	3	void generateCounts ( Field field ) { reset ( ) ; for ( int row = 0 ; row < field . getDepth ( ) ; row ++ ) { for ( int col = 0 ; col < field . getWidth ( ) ; col ++ ) { Object animal = field . getObjectAt ( row , col ) ; if ( animal != null ) { incrementCount ( animal . getClass ( ) ) ; } } } countsValid = true ; }
va	9	public void WriteCompressedData ( BufferedOutputStream outStream ) { int offset , i , j , r , c , a , b , temp = 0 ; int comp , ypos , xblockoffset , yblockoffset ; float inputArray [ ] [ ] ; int dctArray3 [ ] = new int [ 8 * 8 ] ; int lastDCvalue [ ] = new int [ JpegObj . NumberOfComponents ] ; int zeroArray [ ] = new int [ 64 ] ; int Width = 0 , Height = 0 ; int nothing = 0 , not ; int MinBlockWidth , MinBlockHeight ; MinBlockWidth = ( ( imageWidth % 8 != 0 ) ? ( int ) ( Math . floor ( ( double ) imageWidth / 8.0 ) + 1 ) * 8 : imageWidth ) ; MinBlockHeight = ( ( imageHeight % 8 != 0 ) ? ( int ) ( Math . floor ( ( double ) imageHeight / 8.0 ) + 1 ) * 8 : imageHeight ) ; for ( comp = 0 ; comp < JpegObj . NumberOfComponents ; comp ++ ) { MinBlockWidth = Math . min ( MinBlockWidth , JpegObj . BlockWidth [ comp ] ) ; MinBlockHeight = Math . min ( MinBlockHeight , JpegObj . BlockHeight [ comp ] ) ; } int d1 [ ] = new int [ 3 ] ; int d2 [ ] = new int [ 64 ] ; for ( r = 0 ; r < MinBlockHeight ; r ++ ) { for ( c = 0 ; c < MinBlockWidth ; c ++ ) { for ( comp = 0 ; comp < JpegObj . NumberOfComponents ; comp ++ ) { Width = JpegObj . BlockWidth [ comp ] ; Height = JpegObj . BlockHeight [ comp ] ; for ( i = 0 ; i < JpegObj . VsampFactor [ comp ] ; i ++ ) { for ( j = 0 ; j < JpegObj . HsampFactor [ comp ] ; j ++ ) { JPEGComponent comp1 = ( JPEGComponent ) frame . components . get ( comp ) ; try { short a1 [ ] = ( short [ ] ) comp1 . data . get ( d1 [ comp ] ++ ) ; short a2 [ ] [ ] = ZigZag . decode8x8_map ( a1 ) ; int l = 0 ; for ( int k1 = 0 ; k1 < 8 ; k1 ++ ) for ( int k2 = 0 ; k2 < 8 ; k2 ++ ) d2 [ l ++ ] = ( int ) a2 [ k1 ] [ k2 ] ; } catch ( Exception e ) { System . out . println ( comp + "    " + e + "   " + d1 [ comp ] ) ; System . exit ( 0 ) ; } Huf . HuffmanBlockEncoder ( outStream , d2 , lastDCvalue [ comp ] , JpegObj . DCtableNumber [ comp ] , JpegObj . ACtableNumber [ comp ] ) ; lastDCvalue [ comp ] = d2 [ 0 ] ; } } } } } Huf . flushBuffer ( outStream ) ; }
va	6	private int jjMoveStringLiteralDfa9_0 ( long old0 , long active0 ) { if ( ( ( active0 &= old0 ) ) == 0 ) return jjMoveNfa_0 ( 0 , 8 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { return jjMoveNfa_0 ( 0 , 8 ) ; } switch ( curChar ) { case 83 : if ( ( active0 & 2000 ) != 0 ) { jjmatchedKind = 13 ; jjmatchedPos = 9 ; } break ; case 115 : if ( ( active0 & 2000 ) != 0 ) { jjmatchedKind = 13 ; jjmatchedPos = 9 ; } break ; default : break ; } return jjMoveNfa_0 ( 0 , 9 ) ; }
va	9	public int execute ( int nbLigne ) { HashMap < String , String > returnValue = null ; LOGGER . fine ( getSql ( ) ) ; try { boolean autoCommit = getConnection ( ) . getAutoCommit ( ) ; getConnection ( ) . setAutoCommit ( false ) ; PreparedStatement pstmt = null ; try { if ( isCached ( ) ) { pstmt = getPstmtCached ( ) ; } else { pstmt = getConnection ( ) . prepareStatement ( getSql ( ) ) ; } int i = 1 ; for ( Field field : getXmlline ( ) . getFields ( ) ) { if ( ! field . isUse ( ) ) continue ; if ( getPrimaries ( ) . contains ( field . getName ( ) . toUpperCase ( ) ) ) { if ( field . isEmptyOrNullBuffer ( ) ) { setNull ( pstmt , i , field ) ; } else { setAll ( pstmt , i , field ) ; } i ++ ; } } ResultSet rs = pstmt . executeQuery ( ) ; try { if ( rs . next ( ) ) { i = 1 ; for ( Field field : getXmlline ( ) . getFields ( ) ) { if ( ! field . isUse ( ) ) continue ; if ( field . getTypeFormat ( ) != FieldFormatEnum . BLOB ) continue ; i ++ ; } } } finally { rs . close ( ) ; rs = null ; } } finally { if ( ! isCached ( ) ) { pstmt . close ( ) ; pstmt = null ; } } getConnection ( ) . setAutoCommit ( autoCommit ) ; } catch ( SQLException ex ) { SqlUtils . AfficheSQLException ( getXmlline ( ) , getSql ( ) , ex , getReportTypeLine ( ) . getReportLine ( ) ) ; } count ++ ; return ( returnValue == null ) ? - 1 : 0 ; }
va	3	StatementSequenceNode statementSequence ( ) { ArrayList < AbstractNode > list = new ArrayList < AbstractNode > ( ) ; AbstractNode stmt = statement ( ) ; if ( stmt != null ) { list . add ( stmt ) ; } while ( test ( SEMICOLON ) ) { read ( SEMICOLON , ";" ) ; stmt = statement ( ) ; if ( stmt != null ) { list . add ( stmt ) ; } } return new StatementSequenceNode ( list ) ; }
va	5	private Vector < Vector < String >> getWQLEventNode ( String xml , String ParamAttValue ) { if ( xml == null ) { System . out . println ( "ERROR:SSAP_XMLTools:getWQLEventTriple: XML message is null" ) ; return null ; } Element parameters = getParameterElement ( xml , "name" , ParamAttValue ) ; if ( parameters == null ) { System . out . println ( "ERROR:SSAP_XMLTools:getWQLEventTriple:parameters not found:" + ParamAttValue ) ; return null ; } Element node_list = parameters . getChild ( "node_list" ) ; if ( node_list == null ) { System . out . println ( "ERROR:SSAP_XMLTools:getWQLEventTriple:node_list not found" ) ; return null ; } List < Element > all_node = node_list . getChildren ( ) ; if ( all_node == null ) { System . out . println ( "ERROR:SSAP_XMLTools:getWQLEventTriple:children for node_list not found" ) ; return null ; } Vector < Vector < String >> nodes = new Vector < Vector < String >> ( ) ; Iterator < Element > i = all_node . iterator ( ) ; while ( i . hasNext ( ) ) { Vector < String > singleton = new Vector < String > ( ) ; Element etriple = i . next ( ) ; singleton . add ( etriple . getName ( ) ) ; singleton . add ( etriple . getText ( ) ) ; nodes . add ( singleton ) ; } return nodes ; }
va	1	public void init ( ) { for ( AbstractFeaturizer f : featurizerList ) { f . init ( m ) ; } }
va	3	@ Override public T next ( ) { while ( ! stack . isEmpty ( ) && ! stack . first ( ) . hasNext ( ) ) { stack = stack . rest ( ) ; } if ( stack . isEmpty ( ) ) { canMutate = false ; throw new NoSuchElementException ( ) ; } final T vertex = stack . first ( ) . next ( ) ; stack = stack . add ( adjacency . children ( vertex ) . iterator ( ) ) ; canMutate = true ; return vertex ; }
va	5	@ Override public List < String > getDeclaredPermissions ( String world ) { List < String > perms = permissions . get ( world == null || world . isEmpty ( ) ? null : world . toLowerCase ( ) ) ; if ( perms == null ) { perms = new LinkedList < String > ( ) ; permissions . put ( world == null || world . isEmpty ( ) ? null : world . toLowerCase ( ) , perms ) ; } return perms ; }
va	3	public ArrayList < Users > getAdmins ( ) { ArrayList < Users > admins = new ArrayList < Users > ( ) ; for ( Users user : this . getAllUsers ( ) ) { if ( user . getPermission ( ) . getPermissionId ( ) == 1 || user . getPermission ( ) . getPermissionId ( ) == 0 ) { admins . add ( user ) ; } } return admins ; }
va	6	private String adjustUnitsInString ( String input , float scale ) { StringBuilder output = new StringBuilder ( input ) ; Matcher matcher = decimalPattern . matcher ( input ) ; while ( matcher . find ( ) ) { String group1 = ( matcher . group ( 1 ) == null ) ? "" : matcher . group ( 1 ) . trim ( ) ; String group3 = ( matcher . group ( 3 ) == null ) ? "" : matcher . group ( 3 ) . trim ( ) ; if ( group1 . isEmpty ( ) && group3 . isEmpty ( ) ) { try { float originalAmount = float . parseFloat ( matcher . group ( 2 ) ) ; float newAmount = originalAmount * scale ; DecimalFormat format = new DecimalFormat ( ) ; format . setMaximumFractionDigits ( 2 ) ; format . setMinimumFractionDigits ( 0 ) ; format . setGroupingUsed ( false ) ; String replacementAmount = format . format ( newAmount ) ; int offset = matcher . start ( ) + matcher . group ( 1 ) . length ( ) ; output . replace ( offset , offset + matcher . group ( 2 ) . length ( ) , replacementAmount ) ; } catch ( NumberFormatException e ) { LOGGER . error ( "NumberFormatException thrown while converting '" + matcher . group ( 2 ) + "' to float  " + "this should have been caught in the regex. " + "Complete input string: '" + input ) ; } } } return output . toString ( ) ; }
va	9	private boolean r_postlude ( ) { int among_var ; int v_1 ; replab0 : while ( true ) { v_1 = cursor ; lab1 : do { bra = cursor ; among_var = find_among ( a_0 , 6 ) ; if ( among_var == 0 ) { break lab1 ; } ket = cursor ; switch ( among_var ) { case 0 : break lab1 ; case 1 : slice_from ( "a" ) ; break ; case 2 : slice_from ( "e" ) ; break ; case 3 : slice_from ( "i" ) ; break ; case 4 : slice_from ( "o" ) ; break ; case 5 : slice_from ( "u" ) ; break ; case 6 : if ( cursor >= limit ) { break lab1 ; } cursor ++ ; break ; } continue replab0 ; } while ( false ) ; cursor = v_1 ; break replab0 ; } return true ; }
va	9	private static void solve ( ) { for ( int k = 0 ; k <= N ; k ++ ) { for ( int i = 0 ; i <= N ; i ++ ) { for ( int j = 0 ; j <= N ; j ++ ) { if ( m [ i ] [ k ] != 0 && m [ k ] [ j ] != 0 ) m [ i ] [ j ] += m [ i ] [ k ] * m [ k ] [ j ] ; } } } for ( int k = 0 ; k <= N ; k ++ ) if ( m [ k ] [ k ] != 0 ) { for ( int i = 0 ; i <= N ; i ++ ) for ( int j = 0 ; j <= N ; j ++ ) if ( m [ i ] [ k ] != 0 && m [ k ] [ j ] != 0 ) m [ i ] [ j ] = - 1 ; } print ( ) ; }
va	4	@ Override public void onPoliceStepFinished ( int status ) { if ( status != GameStatus . WAIT_POLICE_VOTE_INFO ) { return ; } JSONObject replyObject = new JSONObject ( ) ; replyObject . put ( "MsgID" , ReplyID ) ; JSONObject msgObject = new JSONObject ( ) ; Map < String , String > deduceMessage = GameDataCenter . getInstance ( ) . getPoliceVoteInformation ( ) ; for ( Map . Entry < String , String > e : deduceMessage . entrySet ( ) ) { msgObject . put ( e . getKey ( ) , e . getValue ( ) ) ; } replyObject . put ( "Msg" , msgObject ) ; Map < String , ClientHandler > policeData = PlayersDataHolder . getInstance ( ) . getPoliceHandlers ( ) ; for ( Map . Entry < String , ClientHandler > e : policeData . entrySet ( ) ) { try { e . getValue ( ) . sendClientMsg ( replyObject . toString ( ) ) ; } catch ( IOException e1 ) { e1 . printStackTrace ( ) ; } } }
va	1	private void compareText ( String input , String expected ) throws LexicalException { TokenStream stream = new TokenStream ( input ) ; Scanner s = new Scanner ( stream ) ; try { s . scan ( ) ; } catch ( LexicalException e ) { System . out . println ( e . toString ( ) ) ; throw e ; } String output = stream . tokenTextListToString ( ) ; System . out . println ( output ) ; assertEquals ( expected , output ) ; }
va	2	private void ioSeqWrite ( String fileName , int size ) { long start = 0 ; try { delFile ( fileName ) ; FileOutputStream fis = new FileOutputStream ( fileName ) ; byte buf [ ] = new byte [ 1024 ] ; int total = 1024 * size ; start = System . currentTimeMillis ( ) ; int count = 0 ; while ( count <= total ) { fis . write ( buf ) ; count ++ ; } fis . close ( ) ; } catch ( IOException e ) { logger . error ( "handle error!" , e ) ; } logger . info ( "io seq write file " + size + "M cost: " + ( System . currentTimeMillis ( ) - start ) + " ms" ) ; }
va	4	public ArrayList < ArrayList < String >> partitionHelper ( boolean [ ] [ ] dp , int start , String s ) { ArrayList < ArrayList < String >> allPartitions = new ArrayList < ArrayList < String >> ( ) ; if ( start == s . length ( ) ) { allPartitions . add ( new ArrayList < String > ( ) ) ; return allPartitions ; } for ( int i = start ; i < s . length ( ) ; i ++ ) { if ( dp [ start ] [ i ] ) { for ( ArrayList < String > partition : partitionHelper ( dp , i + 1 , s ) ) { partition . add ( 0 , s . substring ( start , i + 1 ) ) ; allPartitions . add ( partition ) ; } } } return allPartitions ; }
va	1	protected void refreshConfig ( ) { try { getConfig ( ) . save ( configFile ) ; reloadConfig ( ) ; } catch ( IOException e ) { getLogger ( ) . warning ( "Failed to write changed config.yml: " + e . getMessage ( ) ) ; } }
va	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( Window2 . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( Window2 . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( Window2 . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( Window2 . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } }
va	8	public static void main ( String [ ] args ) { if ( args == null || args . length < 2 ) { printHelp ( ) ; throw new IllegalArgumentException ( "Minimum 2 file pathes needed" ) ; } List < String > inputFileNames = new ArrayList < String > ( ) ; for ( int i = 0 ; i < args . length - 1 ; i ++ ) { inputFileNames . add ( args [ i ] ) ; } String outputFileName = args [ args . length - 1 ] ; FileFormat inputFileFormat = checkFileFormat ( inputFileNames ) ; FileFormat outputFileFormat = checkFileFormat ( outputFileName ) ; if ( inputFileFormat == FileFormat . CSV ) { if ( outputFileFormat == FileFormat . CSV ) { new TicketService ( new CsvReader ( ) , new CsvWriter ( ) ) . merge ( inputFileNames , outputFileName ) ; } else if ( outputFileFormat == FileFormat . XML ) { new TicketService ( new CsvReader ( ) , new JdomXmlWriter ( ) ) . merge ( inputFileNames , outputFileName ) ; } else { printHelp ( ) ; throw new IllegalArgumentException ( "Output file has unsupported format" ) ; } } else if ( inputFileFormat == FileFormat . XML ) { if ( outputFileFormat == FileFormat . XML ) { new TicketService ( new StaxReader ( ) , new JdomXmlWriter ( ) ) . merge ( inputFileNames , outputFileName ) ; } else { printHelp ( ) ; throw new IllegalArgumentException ( "XML have to merge in XML" ) ; } } else { printHelp ( ) ; throw new IllegalArgumentException ( "Input file have invalid format" ) ; } }
va	4	public void render ( Transform transform ) { Spritesheet . bind ( ) ; GL11 . glDisable ( GL11 . GL_BLEND ) ; for ( int i = chunks . size ( ) - 1 ; i > 0 ; i -- ) { if ( ! chunks . get ( i ) . isCreated ( ) ) chunks . get ( i ) . create ( ) ; chunks . get ( i ) . render ( ) ; if ( ! withinRange ( playerPos . x , playerPos . z , chunks . get ( i ) . getX ( ) , chunks . get ( i ) . getZ ( ) ) ) unloadChunk ( chunks . get ( i ) ) ; } skyboxShader . bind ( ) ; skyboxShader . setUniform ( "projectedTransform" , transform . getProjectedTransformation ( ) ) ; Skybox . instance . setCenter ( playerPos ) ; Skybox . instance . render ( ) ; Spritesheet . bind ( ) ; GL11 . glEnable ( GL11 . GL_BLEND ) ; GL11 . glBlendFunc ( GL11 . GL_SRC_ALPHA , GL11 . GL_ONE_MINUS_SRC_ALPHA ) ; GL11 . glDisable ( GL11 . GL_CULL_FACE ) ; for ( int i = chunks . size ( ) - 1 ; i > 0 ; i -- ) chunks . get ( i ) . renderTransparency ( ) ; GL11 . glEnable ( GL11 . GL_CULL_FACE ) ; }
va	1	public Buff ( JSONObject json ) throws JSONException { if ( json != null ) { this . skillID = new Integer ( json . getString ( "skill_id" ) ) ; this . description = json . getString ( "description" ) ; } else { this . skillID = null ; this . description = null ; } }
va	7	private boolean isRecordDuplicated ( final String [ ] dataToCompare ) { final String methodName = "isRecordDuplicated" ; DatabaseLogger . entering ( CLASS_NAME , methodName ) ; boolean recordDuplicated = false ; final Set < Integer > recordRows = VALID_RECORDS . keySet ( ) ; for ( int currentRecordRow : recordRows ) { recordDuplicated = true ; final String [ ] record = VALID_RECORDS . get ( currentRecordRow ) ; for ( RecordField field : dataFileFormat . getRecordFields ( ) ) { if ( DatabaseConstants . OWNER_FIELD . equals ( field . getFieldName ( ) ) ) { continue ; } final int fieldIndex = field . getFieldPosition ( ) ; String fieldToCompare = dataToCompare [ fieldIndex ] ; if ( ( fieldToCompare != null ) && ( fieldToCompare . length ( ) > field . getFieldValueLength ( ) ) ) { fieldToCompare = fieldToCompare . substring ( 0 , field . getFieldNameLength ( ) ) ; } if ( ! recordFieldsEqual ( record [ fieldIndex ] , fieldToCompare ) ) { recordDuplicated = false ; break ; } } if ( recordDuplicated ) { break ; } } DatabaseLogger . exiting ( CLASS_NAME , methodName , recordDuplicated ) ; return recordDuplicated ; }
va	9	public Position apply ( Direction direction ) { int x = getX ( ) ; int y = getY ( ) ; switch ( direction ) { case NORTH : y += 1 ; break ; case SOUTH : y -= 1 ; break ; case WEST : x -= 1 ; break ; case EAST : x += 1 ; break ; case NORTHEAST : x += 1 ; y += 1 ; break ; case SOUTHEAST : x += 1 ; y -= 1 ; break ; case SOUTHWEST : x -= 1 ; y -= 1 ; break ; case NORTHWEST : x -= 1 ; y += 1 ; break ; default : break ; } if ( x >= 0 && y >= 0 ) { return Position . getInstance ( x , y ) ; } else { return null ; } }
va	7	@ Override public void startTask ( RXTXPort port ) throws TooManyListenersException { progress . setVisible ( true ) ; super . startTask ( port ) ; port . enableReceiveThreshold ( 3 ) ; port . enableReceiveTimeout ( 300 ) ; byte [ ] buf = new byte [ 3 ] ; int retries = 5 ; boolean statusOK = false ; while ( ( ! statusOK ) && retries > 0 ) { try { port . getOutputStream ( ) . write ( ProtocolConstants . MARK_GENERAL ) ; if ( size == MemorySize . LARGE ) port . getOutputStream ( ) . write ( ProtocolConstants . CMD_MEMORY_4KB . getBytes ( ) ) ; else port . getOutputStream ( ) . write ( ProtocolConstants . CMD_MEMORY_2KB . getBytes ( ) ) ; int read = port . getInputStream ( ) . read ( buf ) ; if ( read < 0 ) logger . log ( "\u041A\u043E\u043C\u0430\u043D\u0434\u0430\u0442\u0430 \u0435 \u0438\u0437\u043F\u0440\u0430\u0442\u0435\u043D\u0430  \u043D\u043E \u043D\u044F\u043C\u0430 \u043E\u0442\u0433\u043E\u0432\u043E\u0440. \u041F\u043E\u0432\u0442\u043E\u0440\u043D\u043E \u0438\u0437\u043F\u0440\u0430\u0449\u0430\u043D\u0435" , LogLevel . DEBUG ) ; else { String recv = new String ( buf ) ; if ( recv . equalsIgnoreCase ( ProtocolConstants . CMD_ACKNOWLEDGE ) ) statusOK = true ; else logger . log ( "\u041F\u043E\u043B\u0443\u0447\u0438 \u0441\u0435 \u0433\u0440\u0435\u0448\u0435\u043D \u043E\u0442\u0433\u043E\u0432\u043E\u0440: '" + recv + "'. \u041F\u043E\u0432\u0442\u043E\u0440\u0435\u043D \u043E\u043F\u0438\u0442" , LogLevel . DEBUG ) ; } } catch ( IOException e ) { logger . log ( "\u0412\u044A\u0437\u043D\u0438\u043A\u043D\u0430 \u0433\u0440\u0435\u0448\u043A\u0430 \u043F\u0440\u0438 \u0438\u0437\u043F\u0440\u0430\u0449\u0430\u043D\u0435\u0442\u043E \u043D\u0430 \u0440\u0430\u0437\u043C\u0435\u0440\u0430 \u043D\u0430 \u0447\u0438\u043F\u0430" , LogLevel . ERRORS ) ; logger . log ( e . getMessage ( ) , LogLevel . DEBUG ) ; e . printStackTrace ( ) ; } finally { retries -- ; } } if ( statusOK ) logger . log ( "\u0420\u0430\u0437\u043C\u0435\u0440\u044A\u0442 \u043D\u0430 \u043F\u0430\u043C\u0435\u0442\u0442\u0430 \u0431\u0435\u0448\u0435 \u0438\u0437\u043F\u0440\u0430\u0442\u0435\u043D \u0443\u0441\u043F\u0435\u0448\u043D\u043E (" + size . getMemSize ( ) + "KB)" , LogLevel . SUCCESS ) ; else logger . log ( "\u041F\u0440\u0435\u043A\u0440\u0430\u0442\u044F\u0432\u0430\u043D\u0435 \u0441\u043B\u0435\u0434 5 \u043F\u043E\u0440\u0435\u0434\u043D\u0438 \u043D\u0435\u0443\u0441\u043F\u0435\u0448\u043D\u0438 \u043E\u043F\u0438\u0442\u0430. \u0420\u0430\u0437\u043C\u0435\u0440\u044A\u0442 \u043D\u0430 \u043F\u0430\u043C\u0435\u0442\u0442\u0430 \u043D\u0435 \u0431\u0435\u0448\u0435 \u0438\u0437\u043F\u0440\u0430\u0442\u0435\u043D." , LogLevel . ERRORS ) ; taskComplete ( ) ; }
va	6	static int decomposeIntoStronglyConnectedComponents ( AdjGraph g , int [ ] components ) { int n = g . n ; AdjGraph reversed = new AdjGraph ( n ) ; for ( int v = 0 ; v < n ; v ++ ) { for ( Edge e : g . edges [ v ] ) { reversed . edges [ e . to ] . add ( e . getInv ( ) ) ; } } boolean [ ] used = new boolean [ n ] ; ArrayList < Integer > forwardOrder = new ArrayList < Integer > ( n ) ; for ( int v = 0 ; v < n ; v ++ ) { if ( ! used [ v ] ) visitSccForward ( g , v , used , forwardOrder ) ; } Arrays . fill ( used , false ) ; int k = 0 ; Collections . reverse ( forwardOrder ) ; for ( int v : forwardOrder ) { if ( ! used [ v ] ) visitSccBackward ( reversed , v , used , k ++ , components ) ; } return k ; }
va	6	@ Override public void addElement ( GameFieldElementEvent e ) { SpriteGroup group ; try { BufferedImage image = ImageIO . read ( new File ( getImage ( e . element ) ) ) ; Sprite sprite = new Sprite ( image , e . position . x , e . position . y ) ; if ( e . element instanceof Bouncing ) { String name = "Bouncing_" + String . valueOf ( bouncing . size ( ) - 1 ) ; group = new SpriteGroup ( name ) ; group . add ( sprite ) ; bouncing . add ( group ) ; } else if ( e . element instanceof Managable ) { manageBounced . add ( sprite ) ; } else if ( e . element instanceof Bounced ) { bounced . add ( sprite ) ; } table . addPair ( e . element , sprite ) ; e . element . setPosition ( e . position ) ; switch ( getClassName ( e . element ) ) { case "Ball" : viewElements . add ( new ViewBall ( sprite , null ) ) ; break ; case "Racket" : viewElements . add ( new ViewRacket ( sprite , null ) ) ; break ; default : break ; } } catch ( IOException ex ) { Logger . getLogger ( GameFieldView . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } }
va	0	public void setDirname ( String dirname ) { this . dirname = dirname ; }
va	1	public ArrayList < Parte > getPartes ( int tamanio , int resistencia , String nombre , Punto posicionDeReferencia ) { Parte parteAux = null ; ArrayList < Parte > partes = new ArrayList < Parte > ( ) ; parteAux = new Parte ( resistencia , posicionDeReferencia , ( nombre + this . nombre + 1 ) ) ; partes . add ( parteAux ) ; for ( int i = 1 ; i < tamanio ; i ++ ) { parteAux = new Parte ( resistencia , this . getSiguientePosicion ( posicionDeReferencia ) , ( nombre + this . nombre + ( i + 1 ) ) ) ; partes . add ( parteAux ) ; posicionDeReferencia = parteAux . getPosicion ( ) ; } return partes ; }
va	4	public IValue lookup ( VSymbol sym ) throws TypeException { if ( null == sym ) { throw new TypeException ( "Cannot lookup a null symbol" ) ; } if ( ! sym . isSealed ( ) ) { throw new TypeException ( "Cannot lookup the unsealed symbol '" + sym . toString ( ) + "'" ) ; } if ( _dictionary . containsKey ( sym ) ) { return _dictionary . get ( sym ) ; } if ( null != _parent ) { return _parent . lookup ( sym ) ; } return null ; }
va	5	private boolean start_code ( ) throws IOException { int idx = 0 ; while ( buf [ curPos ] != 0 || buf [ curPos + 1 ] != 0 || buf [ curPos + 2 ] != 1 ) { if ( ++ idx > 80000 ) { return false ; } curPos ++ ; if ( BUF_LEN - curPos < 6 ) needBytes ( 6 ) ; } return true ; }
