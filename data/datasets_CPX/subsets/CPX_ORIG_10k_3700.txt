tr	5	public Component getEditorComponent ( final PropertyEditor editor ) { String [ ] tags = editor . getTags ( ) ; String text = editor . getAsText ( ) ; if ( editor . supportsCustomEditor ( ) ) { return editor . getCustomEditor ( ) ; } else if ( tags != null ) { final JComboBox comboBox = new JComboBox ( tags ) ; comboBox . setSelectedItem ( text ) ; comboBox . addItemListener ( new ItemListener ( ) { public void itemStateChanged ( ItemEvent event ) { if ( event . getStateChange ( ) == ItemEvent . SELECTED ) editor . setAsText ( ( String ) comboBox . getSelectedItem ( ) ) ; } } ) ; return comboBox ; } else { final JTextField textField = new JTextField ( text , 10 ) ; textField . getDocument ( ) . addDocumentListener ( new DocumentListener ( ) { public void insertUpdate ( DocumentEvent e ) { try { editor . setAsText ( textField . getText ( ) ) ; } catch ( IllegalArgumentException exception ) { } } public void removeUpdate ( DocumentEvent e ) { try { editor . setAsText ( textField . getText ( ) ) ; } catch ( IllegalArgumentException exception ) { } } public void changedUpdate ( DocumentEvent e ) { } } ) ; return textField ; } }
tr	1	public String toString ( ) { return isEndOfTurn ( ) ? "[Move end of turn]" : "[Move " + attackingCountry + " attacks " + defendingCountry + "]" ; }
tr	3	public static byte getWorth ( final MineType mt ) { switch ( mt ) { case COAL : return 1 ; case GOLD : return 4 ; case IRON : return 2 ; default : return 0 ; } }
tr	6	public static void main ( String [ ] args ) { int WIDTH = 10 ; int HEIGHT = 7 ; ConnectFourBoard c4Board1 = new ConnectFourBoard ( WIDTH , HEIGHT ) ; ConnectFourPiece [ ] [ ] c4Pieces1 = new ConnectFourPiece [ WIDTH ] [ HEIGHT ] ; for ( int i = 0 ; i < WIDTH ; i ++ ) { for ( int j = 0 ; j < HEIGHT ; j ++ ) { c4Pieces1 [ i ] [ j ] = c4Board1 . m_Pieces [ i ] [ j ] ; } } int columnValue = 4 ; int rowValue = 1 ; if ( c4Board1 . testSetPiecesOne ( c4Board1 ) ) { System . out . println ( "Valid inputs" ) ; System . out . println ( "ConnectFourBoard.setPiece() - Begin" ) ; System . out . println ( "Expected output: true" ) ; System . out . println ( "" ) ; System . out . println ( "Actual output: " + c4Board1 . setPiece ( columnValue , rowValue , c4Board1 . RED_PIECE ) ) ; System . out . println ( "ConnectFourBoard.setPiece() - End" ) ; System . out . println ( "" ) ; System . out . println ( "ConnectFourBoard.getPieceCount() - Begin" ) ; System . out . println ( "Expected output: 17" ) ; System . out . println ( "" ) ; System . out . println ( "Actual output: " + c4Board1 . getPieceCount ( ) ) ; System . out . println ( "ConnectFourBoard.getPieceCount() - End" ) ; System . out . println ( "" ) ; System . out . println ( "ConnectFourBoard.isFull() - Begin" ) ; System . out . println ( "Expected output: false" ) ; System . out . println ( "" ) ; System . out . println ( "Actual output: " + c4Board1 . isFull ( ) ) ; System . out . println ( "ConnectFourBoard.isFull() - End" ) ; System . out . println ( "" ) ; System . out . println ( "ConnectFourBoard.checkWin() - Begin" ) ; System . out . println ( "Expected output: true" ) ; System . out . println ( "" ) ; System . out . println ( "Actual output: " + c4Board1 . checkWin ( ) ) ; System . out . println ( "ConnectFourBoard.checkWin() - End" ) ; System . out . println ( "" ) ; System . out . println ( "ConnectFourBoard.getPieces() - Begin" ) ; System . out . println ( "Expected output: " ) ; c4Board1 . testPrintPieceColours ( c4Pieces1 ) ; System . out . println ( "" ) ; System . out . println ( "Actual output: " ) ; c4Board1 . testPrintPieceColours ( c4Board1 . getPieces ( ) ) ; System . out . println ( "ConnectFourBoard.getPieces() - End" ) ; System . out . println ( "" ) ; } ConnectFourBoard c4Board2 = new ConnectFourBoard ( WIDTH , HEIGHT ) ; ConnectFourPiece [ ] [ ] c4Pieces2 = new ConnectFourPiece [ WIDTH ] [ HEIGHT ] ; for ( int i = 0 ; i < WIDTH ; i ++ ) { for ( int j = 0 ; j < HEIGHT ; j ++ ) { c4Pieces2 [ i ] [ j ] = c4Board2 . m_Pieces [ i ] [ j ] ; } } if ( c4Board2 . testSetPiecesTwo ( c4Board2 ) ) { System . out . println ( "Invalid inputs" ) ; System . out . println ( "ConnectFourBoard.setPiece() - Begin" ) ; System . out . println ( "Expected output: false" ) ; System . out . println ( "" ) ; System . out . println ( "Actual output: " + c4Board2 . setPiece ( columnValue , rowValue , c4Board2 . YELLOW_PIECE ) ) ; System . out . println ( "ConnectFourBoard.setPiece() - End" ) ; System . out . println ( "" ) ; System . out . println ( "ConnectFourBoard.getPieceCount() - Begin" ) ; System . out . println ( "Expected output: 70" ) ; System . out . println ( "" ) ; System . out . println ( "Actual output: " + c4Board2 . getPieceCount ( ) ) ; System . out . println ( "ConnectFourBoard.getPieceCount() - End" ) ; System . out . println ( "" ) ; System . out . println ( "ConnectFourBoard.isFull() - Begin" ) ; System . out . println ( "Expected output: true" ) ; System . out . println ( "" ) ; System . out . println ( "Actual output: " + c4Board2 . isFull ( ) ) ; System . out . println ( "ConnectFourBoard.isFull() - End" ) ; System . out . println ( "" ) ; System . out . println ( "ConnectFourBoard.checkWin() - Begin" ) ; System . out . println ( "Expected output: false" ) ; System . out . println ( "" ) ; System . out . println ( "Actual output: " + c4Board2 . checkWin ( ) ) ; System . out . println ( "ConnectFourBoard.checkWin() - End" ) ; System . out . println ( "" ) ; System . out . println ( "ConnectFourBoard.getPieces() - Begin" ) ; System . out . println ( "Expected output: " ) ; c4Board2 . testPrintPieceColours ( c4Pieces2 ) ; System . out . println ( "" ) ; System . out . println ( "Actual output: " ) ; c4Board2 . testPrintPieceColours ( c4Board2 . getPieces ( ) ) ; System . out . println ( "ConnectFourBoard.getPieces() - End" ) ; } }
tr	2	public void load ( Runnable runnable ) { while ( true ) { try { executor . execute ( runnable ) ; break ; } catch ( RejectedExecutionException e ) { Macro . sleep ( 500 ) ; } } }
tr	0	public int getSize ( ) { return this . slots . length ; }
tr	5	public void next ( boolean respectRandom ) { if ( ! randomOrder || ! respectRandom ) { index ++ ; if ( index >= record . getRecordCount ( ) ) { index = 0 ; } } else if ( respectRandom ) { index = rand . nextInt ( record . getRecordCount ( ) ) ; } currentRecord = record . getRecordNumber ( index , false ) ; if ( currentRecord . getExtra1 ( ) . indexOf ( "rem=s" ) >= 0 ) { next ( ) ; } }
tr	8	private void loadingStages ( ) { if ( lowMemory && loadingStage == 2 && ObjectManager . anInt131 != plane ) { aRSImageProducer_1165 . initDrawingArea ( ) ; aTextDrawingArea_1271 . drawText ( 0 , "Loading - please wait." , 151 , 257 ) ; aTextDrawingArea_1271 . drawText ( ffffff , "Loading - please wait." , 150 , 256 ) ; aRSImageProducer_1165 . drawGraphics ( 4 , super . graphics , 4 ) ; loadingStage = 1 ; aLong824 = System . currentTimeMillis ( ) ; } if ( loadingStage == 1 ) { int j = method54 ( ) ; if ( j != 0 && System . currentTimeMillis ( ) - aLong824 > 57e40 ) { signlink . reporterror ( myUsername + " glcfb " + isaacSeed + " " + j + " " + lowMemory + " " + decompressors [ 0 ] + " " + onDemandFetcher . getNodeCount ( ) + " " + plane + " " + anInt1069 + " " + anInt1070 ) ; aLong824 = System . currentTimeMillis ( ) ; } } if ( loadingStage == 2 && plane != anInt985 ) { anInt985 = plane ; method24 ( plane ) ; } }
tr	7	private static int maxArea ( int [ ] [ ] sumMax ) { int max = - 1 ; for ( int i = 0 ; i < sumMax . length ; i ++ ) { for ( int j = 0 ; j < sumMax [ 0 ] . length ; j ++ ) { int cnt = sumMax [ i ] [ j ] ; for ( int k = j + 1 ; k < sumMax [ i ] . length && sumMax [ i ] [ j ] <= sumMax [ i ] [ k ] ; k ++ ) { cnt += sumMax [ i ] [ j ] ; } for ( int k = j - 1 ; k >= 0 && sumMax [ i ] [ j ] <= sumMax [ i ] [ k ] ; k -- ) { cnt += sumMax [ i ] [ j ] ; } if ( cnt > max ) max = cnt ; } } return max ; }
tr	6	private void realodClasses ( File file ) { File [ ] files = file . listFiles ( new FileFilter ( ) { @ Override public boolean accept ( File file ) { String fileName = file . getName ( ) ; if ( ! fileName . contains ( "$" ) ) { return true ; } return false ; } } ) ; for ( int i = 0 ; i < files . length ; i ++ ) { if ( files [ i ] . isDirectory ( ) ) { realodClasses ( files [ i ] ) ; } else { if ( files [ i ] . getName ( ) . endsWith ( ".class" ) ) { try { byte [ ] data = FileUtils . readFileToByteArray ( files [ i ] ) ; class < RequestHandler > clazz = ( class < RequestHandler > ) this . findClass ( data ) ; set . add ( clazz ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } catch ( ClassNotFoundException e ) { e . printStackTrace ( ) ; } } } } }
tr	3	boolean isOnBoard ( Position position ) { return 0 <= position . x && position . x < width && 0 <= position . y && position . y < height ; }
tr	1	public String toString ( ) { try { return [ + join ( " " ) + ] ; } catch ( Exception e ) { return null ; } }
tr	3	public static boolean areEqual ( DummyKVStorable [ ] first , DummyKVStorable [ ] second ) { if ( first . length != second . length ) return false ; for ( int i = 0 ; i < first . length ; i ++ ) { if ( ! first [ i ] . equals ( second [ i ] ) ) { System . out . println ( "First entry: " + first [ i ] ) ; System . out . println ( "Second entry: " + second [ i ] ) ; return false ; } } return true ; }
tr	0	public void testApp ( ) { assertTrue ( true ) ; }
tr	9	public static LMDrillModel getAllTweetsByDate ( String startDate , String endDate ) { ArrayList < tweetModel > results = new ArrayList < tweetModel > ( ) ; LMDrillModel lmDrillModel = new LMDrillModel ( ) ; String [ ] start = startDate . split ( " " ) ; String [ ] end = endDate . split ( " " ) ; tweetModel t ; String tablename = "temp-" + start [ 0 ] + "." + start [ 1 ] + "." + start [ 2 ] + "-" + end [ 0 ] + "." + end [ 1 ] + "." + end [ 2 ] ; System . out . println ( tablename ) ; String whereCondition = "" ; int year = Integer . parseInt ( start [ 2 ] ) ; for ( int month = monthNumber ( start [ 0 ] ) ; month <= monthNumber ( end [ 0 ] ) ; month ++ ) { int currentday = 1 ; if ( month == monthNumber ( start [ 0 ] ) ) currentday = Integer . parseInt ( start [ 1 ] ) ; for ( int day = currentday ; day <= numDaysinMonth ( month ) ; day ++ ) { if ( month == monthNumber ( end [ 0 ] ) && day > Integer . parseInt ( end [ 1 ] ) ) break ; if ( whereCondition . equals ( "" ) ) whereCondition = "'" + start [ 1 ] + " " + start [ 0 ] + " " + start [ 2 ] + "%'" ; else whereCondition = whereCondition . concat ( " or date like '" + day + " " + monthName ( month ) + " " + year + "%'" ) ; } } System . out . println ( "[3] " + whereCondition ) ; try { Connection c = DBFactory . getConnection ( ) ; PreparedStatement ps = c . prepareStatement ( "DROP TABLE IF EXISTS `" + tablename + "`; " ) ; ps . execute ( ) ; System . out . println ( ps ) ; ps = c . prepareStatement ( "CREATE TABLE `" + tablename + "` (" + "`username` varchar(20) NOT NULL " + "`date` varchar(30) NOT NULL " + "`message` varchar(180) NOT NULL" + ")ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;" ) ; ps . execute ( ) ; System . out . println ( ps ) ; ps = c . prepareStatement ( "INSERT INTO `" + tablename + "` (username  date  message) " + "SELECT username  date  message FROM `tweets` " + "WHERE date like " + whereCondition ) ; ps . execute ( ) ; System . out . println ( ps ) ; ps = c . prepareStatement ( "SELECT * from `" + tablename + "`;" ) ; ResultSet rs = ps . executeQuery ( ) ; while ( rs . next ( ) ) { t = new tweetModel ( ) ; t . setUsername ( rs . getString ( "username" ) ) ; t . setDate ( rs . getString ( "date" ) ) ; t . setMessage ( cleanTweet ( rs . getString ( "message" ) ) ) ; NGramDriver . NGramTweet ( cleanTweet ( t . getMessage ( ) ) ) ; results . add ( t ) ; } rs . close ( ) ; ps . close ( ) ; c . close ( ) ; System . out . println ( "******************************* " ) ; if ( results . isEmpty ( ) ) { lmDrillModel = new LMDrillModel ( - 1 ) ; } else { sortNgramAndRemoveOutliers ( ) ; TfidfDriver . idfchecker ( results ) ; lmDrillModel = new LMDrillModel ( 0 , tablename , TfidfDriver . getToplist ( ) ) ; } } catch ( ClassNotFoundException ex ) { Logger . getLogger ( tweetHandler . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( SQLException ex ) { Logger . getLogger ( tweetHandler . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } return lmDrillModel ; }
tr	5	@ Override public Table createTable ( final String tableName , List < class < ? >> columnTypes ) throws IOException { checkName ( tableName ) ; String fullPath = tableDir + File . separator + tableName ; if ( columnTypes == null || columnTypes . size ( ) == 0 ) { throw new IllegalArgumentException ( "wrong type (null)" ) ; } File file = new File ( fullPath ) ; writeLock . lock ( ) ; try { if ( file . exists ( ) ) { return null ; } if ( ! file . mkdir ( ) ) { throw new MultiDataBaseException ( "Cannot create table " + tableName ) ; } DataBase table = new DataBase ( fullPath , this , columnTypes ) ; tableInUse . put ( tableName , table ) ; return table ; } finally { writeLock . unlock ( ) ; } }
tr	1	public int [ ] getProxyPort ( ) { IProxyService proxy = StartupPlugin . getDefault ( ) . getProxyService ( ) ; IProxyData [ ] proxyData = proxy . getProxyData ( ) ; int [ ] proxyPort = new int [ proxyData . length ] ; for ( int i = 0 ; i < proxyData . length ; i ++ ) proxyPort [ i ] = proxyData [ i ] . getPort ( ) ; return proxyPort ; }
tr	3	@ Override public void run ( ) { listener . producerCreatedProduct ( Producer . this , finalI ) ; }
tr	8	public void AllPairsShortestPath ( int [ ] [ ] matrix ) { int numberVertices = matrix . length ; pathWeights = new int [ numberVertices ] [ numberVertices ] ; for ( int i = 0 ; i < numberVertices ; i ++ ) { for ( int j = 0 ; j < numberVertices ; j ++ ) { pathWeights [ i ] [ j ] = matrix [ i ] [ j ] > 0 ? matrix [ i ] [ j ] : Integer . MAX_VALUE ; if ( i == j ) { pathWeights [ i ] [ j ] = 0 ; } } } for ( int k = 0 ; k < numberVertices ; k ++ ) { for ( int i = 0 ; i < numberVertices ; i ++ ) { for ( int j = 0 ; j < numberVertices ; j ++ ) { if ( ( long ) pathWeights [ i ] [ j ] > ( long ) pathWeights [ i ] [ k ] + ( long ) pathWeights [ k ] [ j ] ) { pathWeights [ i ] [ j ] = pathWeights [ i ] [ k ] + pathWeights [ k ] [ j ] ; } } } } }
tr	1	double getLongitudeInDegrees ( double row , double positionInRow ) { double offset = getPositionOffset ( row ) ; double rowLength = getRowLength ( row ) ; if ( rowLength == 0 ) { return 0 ; } double adjustedPosition = ( positionInRow + offset ) % rowLength ; return 360.0 * adjustedPosition / rowLength ; }
tr	0	public double [ ] getEmissionDistribution ( ) { return EMISSION_DISTRIBUTIONS ; }
tr	4	public static boolean getCell ( boolean [ ] [ ] world , int col , int row ) { if ( row < 0 || row > world . length - 1 ) return false ; if ( col < 0 || col > world [ row ] . length - 1 ) return false ; return world [ row ] [ col ] ; }
tr	2	@ Override public void setArtistUrl ( String url ) { if ( url != null && url . length ( ) > 0 ) { invalidateDataLength ( ) ; ID3v2WWWFrameData frameData = new ID3v2WWWFrameData ( useFrameUnsynchronisation ( ) , url ) ; addFrame ( createFrame ( ID_ARTIST_URL , frameData . toBytes ( ) ) , true ) ; } }
tr	3	public void conectar ( ) { try { class . forName ( "com.mysql.jdbc.Driver" ) ; conn = DriverManager . getConnection ( url , login , password ) ; if ( conn != null ) { conectadoMySQL = 1 ; conn . close ( ) ; } } catch ( SQLException ex ) { conectadoMySQL = 0 ; } catch ( ClassNotFoundException ex ) { conectadoMySQL = 0 ; } }
tr	2	private void removeNeuron ( int num ) { Neuron neuron = ( Neuron ) ( currentNetwork . getNode ( num ) ) ; currentNetwork . getNeurons ( ) . remove ( neuron ) ; for ( int i = 0 ; i < neuron . getInputs ( ) . size ( ) ; i ++ ) { Connection connection = neuron . getInputs ( ) . get ( i ) ; connection . getGiveNeuron ( ) . getOutputs ( ) . remove ( connection ) ; currentNetwork . getConnections ( ) . remove ( connection ) ; } for ( int i = 0 ; i < neuron . getOutputs ( ) . size ( ) ; i ++ ) { Connection connection = neuron . getOutputs ( ) . get ( i ) ; connection . getRecieveNeuron ( ) . getInputs ( ) . remove ( connection ) ; currentNetwork . getConnections ( ) . remove ( connection ) ; } System . out . println ( "Neuron :: " + num + " :: was removed" ) ; }
tr	2	private void putSourceData ( int esi , ByteBuffer symbolData ) { final int T = fecParams . symbolSize ( ) ; final int bufPos = symbolData . position ( ) ; if ( receivedSourceSymbols . get ( esi ) ) { symbolData . position ( bufPos + T ) ; } else { if ( symbolData . hasArray ( ) ) { final byte [ ] arr = symbolData . array ( ) ; final int off = bufPos + symbolData . arrayOffset ( ) ; data . putBytes ( esi * T , arr , off , T ) ; symbolData . position ( bufPos + T ) ; } else { final byte [ ] arr = new byte [ T ] ; symbolData . get ( arr ) ; data . putBytes ( esi * T , arr ) ; } receivedSourceSymbols . set ( esi ) ; } }
tr	8	public static double findMedianSortedArrays ( int A [ ] , int B [ ] ) { int m = A . length , n = B . length ; double result = 0 ; if ( m > n ) return findMedianSortedArrays ( B , A ) ; int k = ( m + n - 1 ) / 2 ; int left = 0 , right = Math . min ( m , k ) ; while ( left < right ) { int i = ( left + right ) / 2 ; int j = k - i ; if ( A [ i ] < B [ j ] ) { left = i + 1 ; } else { right = i ; } } result = Math . max ( left > 0 ? A [ left - 1 ] : Integer . MIN_VALUE , k - left >= 0 ? B [ k - left ] : Integer . MIN_VALUE ) ; if ( ( ( m + n ) & 1 ) == 1 ) return result ; else result = ( result + Math . min ( left < m ? A [ left ] : Integer . MAX_VALUE , k - left + 1 < n ? B [ k - left + 1 ] : Integer . MAX_VALUE ) ) / 2 ; return result ; }
tr	7	@ Override public void rightMultiply ( IMatrix other ) { for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) copy [ i ] [ j ] = 0 ; for ( int i = 0 ; i < 4 ; i ++ ) { for ( int j = 0 ; j < 4 ; j ++ ) { for ( int k = 0 ; k < 4 ; k ++ ) { copy [ i ] [ j ] = copy [ i ] [ j ] + this . get ( k , i ) * other . get ( j , k ) ; } } } for ( int i = 0 ; i < 4 ; i ++ ) { for ( int j = 0 ; j < 4 ; j ++ ) { this . set ( j , i , copy [ i ] [ j ] ) ; } } }
tr	4	private HttpRequest getHttp ( HttpMethod httpMethod , StringEntity entity ) { if ( HttpMethod . post . equals ( httpMethod ) ) { HttpPost http = new HttpPost ( ) ; http . setEntity ( entity ) ; return http ; } else if ( HttpMethod . put . equals ( httpMethod ) ) { HttpPut http = new HttpPut ( ) ; http . setEntity ( entity ) ; return http ; } else if ( HttpMethod . get . equals ( httpMethod ) ) { HttpGet http = new HttpGet ( ) ; return http ; } else if ( HttpMethod . delete . equals ( httpMethod ) ) { HttpDelete http = new HttpDelete ( ) ; return http ; } return null ; }
tr	7	public void doSort ( Object [ ] a , int lo , int hi ) { stackSize = 0 ; rangeCheck ( a . length , lo , hi ) ; int nRemaining = hi - lo ; if ( nRemaining < 2 ) { return ; } if ( nRemaining < MIN_MERGE ) { int initRunLen = countRunAndMakeAscending ( a , lo , hi ) ; binarySort ( a , lo , hi , lo + initRunLen ) ; return ; } this . a = a ; int minRun = minRunLength ( nRemaining ) ; do { int runLen = countRunAndMakeAscending ( a , lo , hi ) ; if ( runLen < minRun ) { int force = nRemaining <= minRun ? nRemaining : minRun ; binarySort ( a , lo , lo + force , lo + runLen ) ; runLen = force ; } pushRun ( lo , runLen ) ; mergeCollapse ( ) ; lo += runLen ; nRemaining -= runLen ; } while ( nRemaining != 0 ) ; if ( DEBUG ) { assert lo == hi ; } mergeForceCollapse ( ) ; if ( DEBUG ) { assert stackSize == 1 ; } }
tr	9	public void initArcPruningMap ( ) { sib2id = new int [ F * N * N ] ; copar2id = new int [ F * F * N ] ; gp2id = new int [ F * F * N ] ; isPruned = new boolean [ F * N ] ; for ( int i = 0 ; i < isPruned . length ; ++ i ) { isPruned [ i ] = true ; } for ( int i = 0 ; i < sib2id . length ; ++ i ) sib2id [ i ] = - 1 ; for ( int i = 0 ; i < copar2id . length ; ++ i ) copar2id [ i ] = - 1 ; for ( int i = 0 ; i < gp2id . length ; ++ i ) gp2id [ i ] = - 1 ; sibnum = 0 ; coparnum = 0 ; gpnum = 0 ; for ( int i = 0 ; i < F ; ++ i ) { int pid = inst . frames [ i ] . predid ; int [ ] augs = inst . frames [ i ] . arglbids ; for ( int j = 0 ; j < N ; ++ j ) { if ( isValidPredAugPair ( pid , j ) || augs [ j ] >= 0 ) { isPruned [ i * N + j ] = ! isValidPredAugPair ( pid , j ) ; if ( options . useSRL2O ) { for ( int k = j + 1 ; k < N ; ++ k ) if ( isValidPredAugPair ( pid , k ) || augs [ k ] >= 0 ) { sib2id [ ( i * N + j ) * N + k ] = sibnum ; sibnum ++ ; } for ( int k = i + 1 ; k < F ; ++ k ) if ( SemanticFeatureFactory . isValidPredAugPair ( inst , inst . frames [ k ] . predid , j ) || inst . frames [ k ] . arglbids [ j ] >= 0 ) { copar2id [ ( i * F + k ) * N + j ] = coparnum ; coparnum ++ ; } } } } } }
tr	0	public void setDeliverTypeId ( long deliverTypeId ) { this . deliverTypeId = deliverTypeId ; }
tr	3	public JSONWriter array ( ) throws JSONException { if ( this . mode == i || this . mode == o || this . mode == a ) { this . push ( null ) ; this . append ( "[" ) ; this . , = false ; return this ; } throw new JSONException ( "Misplaced array." ) ; }
tr	3	public void setEngine ( CoreEngine engine ) { if ( this . engine != engine ) { this . engine = engine ; for ( GameLeaf leaf : leaves ) { leaf . addToEngine ( engine ) ; } for ( GameBranch child : children ) { child . setEngine ( engine ) ; } } }
tr	4	protected String output ( int partId , String ch_aux ) { String output = "" ; System . err . println ( "== Running your code ..." ) ; try { FeatureFactory ff = new FeatureFactory ( ) ; List < Datum > trainData = ff . readData ( "../data/train" ) ; List < Datum > testData = ff . readTestData ( ch_aux ) ; List < Datum > trainDataWithFeatures = ff . setFeaturesTrain ( trainData ) ; List < Datum > testDataWithFeatures = ff . setFeaturesTest ( testData ) ; ff . writeData ( trainDataWithFeatures , "trainWithFeaturesSubmit" ) ; ff . writeData ( testDataWithFeatures , "testWithFeaturesSubmit" ) ; MEMM memm = new MEMM ( ) ; List < Datum > data = memm . runMEMM ( "trainWithFeaturesSubmit.json" , "testWithFeaturesSubmit.json" ) ; for ( Datum datum : data ) { output += "+++" + base64decode ( datum . word ) + "\t" + datum . guessLabel + "\n" ; } File trainFile = new File ( "trainWithFeaturesSubmit.json" ) ; File testFile = new File ( "testWithFeaturesSubmit.json" ) ; if ( trainFile . exists ( ) ) { trainFile . delete ( ) ; } if ( testFile . exists ( ) ) { testFile . delete ( ) ; } } catch ( IOException e ) { System . err . println ( e . getMessage ( ) ) ; } System . err . println ( "== Finished running your code" ) ; return output ; }
tr	6	@ Override public void done ( ) { try { try { socket = get ( ) ; parent . updateStatus ( "Connected!" ) ; parent . parentFrame . addTab ( socket , parent . getNickname ( ) ) ; parent . dispose ( ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } catch ( java . util . concurrent . CancellationException e ) { closeSocket ( ) ; parent . updateStatus ( "Cancelled." ) ; } catch ( java . util . concurrent . ExecutionException e ) { closeSocket ( ) ; String why = null ; Throwable cause = e . getCause ( ) ; if ( cause != null ) { why = cause . getMessage ( ) ; if ( cause instanceof UnknownHostException ) { why = "Unknown host " + why ; } else if ( cause instanceof SocketTimeoutException ) { why = "Connection timed out" ; } } else { why = e . getMessage ( ) ; } parent . updateStatus ( why ) ; } finally { connectButton . setEnabled ( true ) ; } }
tr	3	public int hyppaaTulevaSana ( String syote ) { int matka = 0 ; while ( matka < syote . length ( ) && ( ! syote . substring ( matka , matka + 1 ) . contentEquals ( " " ) ) && ( ! syote . substring ( matka , matka + 1 ) . contentEquals ( ")" ) ) ) { matka ++ ; } return matka ; }
tr	7	public boolean isInRange ( final SerialDate d1 , final SerialDate d2 , final int include ) { final int s1 = d1 . toSerial ( ) ; final int s2 = d2 . toSerial ( ) ; final int start = Math . min ( s1 , s2 ) ; final int end = Math . max ( s1 , s2 ) ; final int s = toSerial ( ) ; if ( include == SerialDate . INCLUDE_BOTH ) { return ( s >= start && s <= end ) ; } else if ( include == SerialDate . INCLUDE_FIRST ) { return ( s >= start && s < end ) ; } else if ( include == SerialDate . INCLUDE_SECOND ) { return ( s > start && s <= end ) ; } else { return ( s > start && s < end ) ; } }
tr	1	public static boolean isPointsEnoughToBuyToolWithNumber ( int points , Tool tool ) { if ( points < tool . getBuyPoints ( ) ) { return false ; } return true ; }
tr	9	public int totalEval ( ) { int topLeft , topRight , bottomLeft , bottomRight , piece , total = 0 ; for ( int c = 0 ; c < 10 ; c ++ ) { for ( int r = 0 ; r < 10 ; r ++ ) { piece = ds . getPiece ( r , c ) ; if ( piece == DraughtsState . WHITEFIELD ) { continue ; } if ( r > 0 && c > 0 ) { topLeft = ds . getPiece ( r - 1 , c - 1 ) ; } else { topLeft = 6 ; } if ( r > 0 && c < 9 ) { topRight = ds . getPiece ( r - 1 , c + 1 ) ; } else { topRight = 6 ; } if ( r < 9 && c > 0 ) { bottomLeft = ds . getPiece ( r + 1 , c - 1 ) ; } else { bottomLeft = 6 ; } if ( r < 9 && c < 9 ) { bottomRight = ds . getPiece ( r + 1 , c + 1 ) ; } else { bottomRight = 6 ; } if ( piece == DraughtsState . WHITEPIECE ) { total += evalWhitePiece ( r , c , topLeft , topRight , bottomLeft , bottomRight ) ; } else if ( piece == DraughtsState . BLACKPIECE ) { total -= evalBlackPiece ( r , c , topLeft , topRight , bottomLeft , bottomRight ) ; } else if ( piece == DraughtsState . WHITEKING ) { total += evalKing ( r , c , topLeft , topRight , bottomLeft , bottomRight ) ; } else if ( piece == DraughtsState . BLACKKING ) { total -= evalKing ( r , c , topLeft , topRight , bottomLeft , bottomRight ) ; } else { total += evalEmpty ( r , c , topLeft , topRight , bottomLeft , bottomRight ) ; } } } return total ; }
tr	4	@ SuppressWarnings ( { "unchecked" , "rawtypes" } ) @ Override public Object instantiate ( ObjectBinder context , Object value , Type targetType , class targetClass ) { if ( value instanceof Map && targetClass == Message . class ) { Map < String , ? > map = ( Map < String , ? > ) value ; Message m = new Message ( ) ; m . fileId = stringVal ( map . get ( "user_file_id" ) ) ; m . hidden = boolVal ( map . get ( "hidden" ) ) ; m . userId = stringVal ( map . get ( "user_id" ) ) ; m . description = stringVal ( map . get ( "description" ) ) ; m . title = stringVal ( map . get ( "title" ) ) ; m . importance = stringVal ( map . get ( "importance" ) ) ; m . fileName = stringVal ( map . get ( "file_name" ) ) ; m . fileType = stringVal ( map . get ( "file_type" ) ) ; m . fromUserId = stringVal ( map . get ( "from_user_id" ) ) ; m . id = stringVal ( map . get ( "id" ) ) ; m . channel = stringVal ( map . get ( "channel" ) ) ; return m ; } throw context . cannotConvertValueToTargetType ( value , targetClass ) ; }
tr	8	private static < AnyType extends Comparable < ? super AnyType >> void quickSelect ( AnyType [ ] a , int left , int right , int k ) { if ( left + CUTOFF <= right ) { AnyType pivot = median3 ( a , left , right ) ; int i = left , j = right - 1 ; for ( ; ; ) { while ( a [ ++ i ] . compareTo ( pivot ) < 0 ) { } while ( a [ -- j ] . compareTo ( pivot ) > 0 ) { } if ( i < j ) swapReferences ( a , i , j ) ; else break ; } swapReferences ( a , i , right - 1 ) ; if ( k <= i ) quickSelect ( a , left , i - 1 , k ) ; else if ( k > i + 1 ) quickSelect ( a , i + 1 , right , k ) ; } else insertionSort ( a , left , right ) ; }
tr	1	private String [ ] camposOrdem ( ) { String camposPesquisa [ ] = new String [ estruturaTabela . size ( ) ] ; for ( int i = 0 ; i < estruturaTabela . size ( ) ; i ++ ) { camposPesquisa [ i ] = estruturaTabela . get ( i ) . getCampo ( ) ; } jCBOrdemPesq . setModel ( new javax . swing . DefaultComboBoxModel ( camposPesquisa ) ) ; return camposPesquisa ; }
tr	0	private if ( BooleanExpression condition ) { this . condition = condition ; }
tr	5	private void jButton1ActionPerformed ( java . awt . event . ActionEvent evt ) { try { ClientServiceImpl csi = new ClientServiceImpl ( conn ) ; Client client = new Client ( ) ; setNewClientProperty ( client ) ; if ( client . getFirstName ( ) . equals ( "" ) || client . getLastName ( ) . equals ( "" ) || client . getBirthDay ( ) == null || client . getPassportNumber ( ) . equals ( "" ) ) { JOptionPane . showMessageDialog ( null , "\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043D\u0435\u0434\u043E\u0441\u0442\u0430\u044E\u0449\u0438\u0435 \u0434\u0430\u043D\u043D\u044B\u0435!" ) ; } else { csi . insert ( client ) ; JOptionPane . showMessageDialog ( null , "\u041A\u043B\u0438\u0435\u043D\u0442 \u0434\u043E\u0431\u0430\u0432\u043B\u0435\u043D!" ) ; close ( ) ; } } catch ( ExsistDoubleClient ex ) { JOptionPane . showMessageDialog ( null , "\u041A\u043B\u0438\u0435\u043D\u0442 \u0443\u0436\u0435 \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u0435\u0442!" ) ; } }
tr	6	private void persist ( PersistAction persistAction , String successMessage ) { if ( selected != null ) { setEmbeddableKeys ( ) ; try { if ( persistAction != PersistAction . DELETE ) { getFacade ( ) . edit ( selected ) ; } else { getFacade ( ) . remove ( selected ) ; } JsfUtil . addSuccessMessage ( successMessage ) ; } catch ( EJBException ex ) { String msg = "" ; Throwable cause = ex . getCause ( ) ; if ( cause != null ) { msg = cause . getLocalizedMessage ( ) ; } if ( msg . length ( ) > 0 ) { JsfUtil . addErrorMessage ( msg ) ; } else { JsfUtil . addErrorMessage ( ex , ResourceBundle . getBundle ( "/resoruces/Bundle" ) . getString ( "PersistenceErrorOccured" ) ) ; } } catch ( Exception ex ) { Logger . getLogger ( this . getClass ( ) . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; JsfUtil . addErrorMessage ( ex , ResourceBundle . getBundle ( "/resoruces/Bundle" ) . getString ( "PersistenceErrorOccured" ) ) ; } } }
tr	6	public void transform ( String originalFile , String thumbnailFile , int thumbWidth , int thumbHeight , int quality ) throws Exception { try { Image image = javax . imageio . ImageIO . read ( new File ( originalFile ) ) ; double thumbRatio = ( double ) thumbWidth / ( double ) thumbHeight ; int imageWidth = image . getWidth ( null ) ; int imageHeight = image . getHeight ( null ) ; double imageRatio = ( double ) imageWidth / ( double ) imageHeight ; if ( thumbRatio < imageRatio ) { thumbHeight = ( int ) ( thumbWidth / imageRatio ) ; } else { thumbWidth = ( int ) ( thumbHeight * imageRatio ) ; } if ( imageWidth < thumbWidth && imageHeight < thumbHeight ) { thumbWidth = imageWidth ; thumbHeight = imageHeight ; } else if ( imageWidth < thumbWidth ) thumbWidth = imageWidth ; else if ( imageHeight < thumbHeight ) thumbHeight = imageHeight ; BufferedImage thumbImage = new BufferedImage ( thumbWidth , thumbHeight , BufferedImage . TYPE_INT_RGB ) ; Graphics2D graphics2D = thumbImage . createGraphics ( ) ; graphics2D . setBackground ( Color . WHITE ) ; graphics2D . setPaint ( Color . WHITE ) ; graphics2D . fillRect ( 0 , 0 , thumbWidth , thumbHeight ) ; graphics2D . setRenderingHint ( RenderingHints . KEY_INTERPOLATION , RenderingHints . VALUE_INTERPOLATION_BILINEAR ) ; graphics2D . drawImage ( image , 0 , 0 , thumbWidth , thumbHeight , null ) ; javax . imageio . ImageIO . write ( thumbImage , "JPG" , new File ( thumbnailFile ) ) ; } catch ( Exception e ) { System . out . println ( "Image not found" ) ; } }
tr	2	@ Override public boolean login ( ) throws LoginException { NameCallback nameCallback = new NameCallback ( "Name : " ) ; PasswordCallback passwordCallback = new PasswordCallback ( "Password : " , false ) ; try { callbackHandler . handle ( new Callback [ ] { nameCallback , passwordCallback } ) ; String username = nameCallback . getName ( ) ; String password = new String ( passwordCallback . getPassword ( ) ) ; nameCallback . setName ( "" ) ; passwordCallback . clearPassword ( ) ; Customer customer = null ; if ( customer == null ) { throw new LoginException ( "Authentication failed" ) ; } return true ; } catch ( Exception e ) { e . printStackTrace ( ) ; throw new LoginException ( e . getMessage ( ) ) ; } }
tr	4	@ Override public synchronized boolean put ( String key , long value ) { WrappedString toInsert = new WrappedString ( key ) ; strategy . hit ( toInsert ) ; ArrayHashMapOption temp = store . get ( toInsert ) ; if ( temp == null ) { try { temp = optionFactory . wrap ( new ArrayHashMap ( 32 ) , Integer . toHexString ( fileNumber ++ ) ) ; store . put ( toInsert , temp ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } else { try { long readInSize = temp . restore ( ) ; if ( readInSize > - 1 ) System . out . println ( "Restoring partition for put() with id " + temp . getName ( ) + " at size " + readInSize ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } size -= temp . getValue ( ) . size ( ) ; boolean toReturn = temp . getValue ( ) . put ( key , value ) ; size += temp . getValue ( ) . size ( ) ; return toReturn ; }
tr	2	public static String toString ( JSONArray ja ) throws JSONException { JSONObject jo = ja . optJSONObject ( 0 ) ; if ( jo != null ) { JSONArray names = jo . names ( ) ; if ( names != null ) { return rowToString ( names ) + toString ( names , ja ) ; } } return null ; }
tr	3	public void tampilkanDaftar ( ) { if ( ! daftarPembeli . isVisible ( ) ) { DaftarPembeli . listPembeli = pembeli . bacaDaftar ( ) ; daftarPembeli = new DaftarPembeli ( null , true ) ; daftarPembeli . setVisible ( true ) ; if ( ! DaftarPembeli . no_beliDipilih . equals ( "" ) ) { if ( pembeli . baca ( DaftarPembeli . no_beliDipilih ) ) { FormUtama . formPembeli . setNoPembelian ( pembeli . getNo_beli ( ) ) ; FormUtama . formPembeli . setNama ( pembeli . getNama ( ) ) ; FormUtama . formPembeli . setAlamat ( pembeli . getAlamat ( ) ) ; FormUtama . formPembeli . setTelepon ( pembeli . getTlp ( ) ) ; } } } }
tr	4	private void close ( ) { try { if ( resultSet != null ) { resultSet . close ( ) ; } if ( statement != null ) { statement . close ( ) ; } if ( connect != null ) { connect . close ( ) ; } } catch ( Exception e ) { } }
tr	2	public String doCleanLink ( String link ) { if ( link == null ) return null ; try { link = URLDecoder . decode ( link , "UTF-8" ) ; } catch ( UnsupportedEncodingException e ) { throw new AssertionError ( "le broken JVM face" ) ; } return link ; }
tr	0	public LayoutParameters ( int width , int height ) { this ( width , height , 0 ) ; }
tr	0	@ XmlAttribute public float getI ( ) { return i ; }
tr	0	public String getMessage ( ) { return super . getMessage ( ) + SEPARATOR + getErrnoString ( ) + " [" + errno + "] " ; }
tr	9	public String getString ( int id , int language ) throws IOException { if ( id == 0 ) return null ; if ( id < 0 || id > ff ) throw new IllegalArgumentException ( ) ; if ( ! checkedStrings ) getLanguages ( ) ; if ( languages == null || languages . length == 0 ) return null ; byte key = new byte ( ( byte ) id ) ; String retval = null ; if ( stringCache == null ) { synchronized ( lock ) { if ( stringCache == null ) { cachedLanguage = language ; stringCache = new Hashtable ( 7 ) ; } } } else if ( stringCache . containsKey ( key ) ) { Object value = stringCache . get ( key ) ; if ( value instanceof String ) return ( String ) value ; else return null ; } retval = ControlMessage . getString ( this , ( byte ) id , language ) ; if ( retval == null ) stringCache . put ( key , boolean . false ) ; else stringCache . put ( key , retval ) ; return retval ; }
tr	8	public void draw ( Renderer rend , Point pos , int turned ) { if ( selectedItem < 0 ) { selectedItem = 0 ; } else if ( selectedItem > 9 ) { selectedItem = 9 ; } for ( int j = 0 ; j < slotmax ; j ++ ) { Point p1 = new Point ( pos . x - 141 , 270 + pos . y - ( j * 35 ) ) ; for ( int i = 0 ; i < 10 ; i ++ ) { p1 . moveCoords ( 35 , 0 ) ; if ( j * 10 + i == selectedItem ) { rend . draw ( p1 , p1 . clone ( 30 ) , "red.png" ) ; if ( objectType [ j * 10 + i ] . id != 0 ) { objectType [ j * 10 + i ] . drawHand ( rend , pos , turned ) ; } } else { rend . draw ( p1 , p1 . clone ( 30 ) , "case.png" ) ; } if ( objectType [ j * 10 + i ] . id != 0 ) { objectType [ j * 10 + i ] . draw ( rend , p1 . clone ( 0 ) ) ; drawNumber ( rend , objectNumber [ j * 10 + i ] , p1 ) ; } } } if ( onMouseItem . id != 0 ) { Point p = rend . getAPI ( ) . getMouse ( ) ; onMouseItem . draw ( rend , p . clone ( - 15 ) ) ; drawNumber ( rend , onMouseNumber , p . clone ( - 15 ) ) ; } }
tr	4	public static void create ( String [ ] args ) { Vector < vslFileDataChunk > chunks = null ; if ( args . length < 3 ) { System . err . println ( "Missings args: create <dbfile> <source>" ) ; System . exit ( 1 ) ; } source = args [ 2 ] ; try { chunks = handler . chunkFile ( source ) ; vslDataType < vslFileDataChunk > fileData = new vslDataType < vslFileDataChunk > ( ) ; StringTokenizer st = new StringTokenizer ( source , "/" ) ; String fname = "UNSET" ; while ( st . hasMoreTokens ( ) ) { fname = st . nextToken ( ) ; } fileData . setName ( fname ) ; for ( vslFileDataChunk chunk : chunks ) { fileData . addNewChunk ( chunk ) ; } core . addEntry ( fileData ) ; core . debugShow ( ) ; core . save ( ) ; } catch ( Exception e ) { System . err . println ( "Caught exception: " + e . toString ( ) ) ; e . printStackTrace ( ) ; System . exit ( 1 ) ; } }
tr	9	private boolean findBranchingRoute ( Agent a , Box obstacle ) { dir boxDir = null ; BacktrackTree root = new BacktrackTree ( a . desire . box . getAtField ( ) , a . getAtField ( ) , null ) ; BacktrackTree currentNode = null ; Set < BacktrackTree > closedSet = new HashSet < BacktrackTree > ( ) ; LinkedList < BacktrackTree > queue = new LinkedList < BacktrackTree > ( ) ; HashMap < Field , ArrayList < Field >> exploredStates = new HashMap < Field , ArrayList < Field >> ( ) ; ArrayList < Field > tempList = new ArrayList < Field > ( ) ; tempList . add ( a . desire . box . getAtField ( ) ) ; exploredStates . put ( a . getAtField ( ) , tempList ) ; queue . add ( root ) ; currentNode = queue . pop ( ) ; while ( currentNode . boxLocation != a . desire . goal ) { boxDir = Agent . getBoxDirection ( currentNode . agentLocation , currentNode . boxLocation ) ; ArrayList < Command > foundCommands = a . addPossibleCommandsForDirection ( boxDir , currentNode . agentLocation , currentNode . boxLocation ) ; for ( Command command : foundCommands ) { Field boxLocation = null ; Field agentLocation = null ; if ( command . cmd . equals ( "Push" ) ) { agentLocation = currentNode . boxLocation ; boxLocation = currentNode . boxLocation . neighbors [ command . dir2 . ordinal ( ) ] ; } else { boxLocation = currentNode . agentLocation ; agentLocation = currentNode . agentLocation . neighbors [ command . dir1 . ordinal ( ) ] ; } if ( exploredStates . containsKey ( agentLocation ) ) { if ( exploredStates . get ( agentLocation ) . contains ( boxLocation ) ) continue ; else { exploredStates . get ( agentLocation ) . add ( boxLocation ) ; } } else { ArrayList < Field > tempListe = new ArrayList < Field > ( ) ; tempListe . add ( boxLocation ) ; exploredStates . put ( agentLocation , tempListe ) ; } BacktrackTree bt = new BacktrackTree ( boxLocation , agentLocation , command ) ; bt . parent = currentNode ; boolean setupInClosedSet = false ; for ( BacktrackTree closedTree : closedSet ) { if ( closedTree . agentLocation . x == bt . agentLocation . x && closedTree . agentLocation . y == bt . agentLocation . y && closedTree . boxLocation . x == bt . boxLocation . x && closedTree . boxLocation . y == bt . boxLocation . y ) { setupInClosedSet = true ; } } if ( ! setupInClosedSet ) { queue . add ( bt ) ; closedSet . add ( bt ) ; } } if ( queue . isEmpty ( ) ) { return false ; } currentNode = queue . pop ( ) ; } ArrayList < Command > commands = new ArrayList < Command > ( ) ; while ( currentNode . parent != null ) { commands . add ( currentNode . action ) ; currentNode = currentNode . parent ; } Collections . reverse ( commands ) ; for ( Command command : commands ) { a . commandQueueDONOTUSE . add ( command ) ; } return true ; }
tr	9	@ Override public void trainWord ( String word , Value < State > times , HashMap < State , Value < Character >> restart ) { int len = word . length ( ) ; double wordProb ; Value < State > alpha = initial ( 1.0 ) ; Value < State > beta ; ArrayList < Value < State >> alphas = new ArrayList < Value < State >> ( ) ; alphas . add ( alpha ) ; for ( int t = 0 ; t < len ; ++ t ) { Character c = word . charAt ( t ) ; alpha = forward ( alpha , c ) ; alphas . add ( alpha ) ; } beta = initial ( 1.0 ) ; wordProb = alpha . get ( I ) ; for ( int t = len - 1 ; t >= 0 ; -- t ) { Character c = word . charAt ( t ) ; alpha = alphas . get ( t ) ; for ( State i : alpha . keySet ( ) ) { double alphai = alpha . get ( i ) ; State j = i . next ( c ) ; double restartValue = beta . containsKey ( I ) ? clip ( alphai * i . prRestart ( c ) * beta . get ( I ) / wordProb ) : 0 ; if ( j != null && beta . containsKey ( j ) ) { double nextValue = clip ( alphai * i . prNext ( c ) * beta . get ( j ) / wordProb ) ; times . addValue ( j , nextValue ) ; } restart . get ( i ) . addValue ( c , restartValue ) ; times . addValue ( I , restartValue ) ; } if ( t > 0 ) { Value < State > output = new Value < State > ( ) ; for ( State i : alpha . keySet ( ) ) { State j = i . next ( c ) ; if ( j != null ) { output . addValue ( i , beta . getValue ( j ) * i . prNext ( c ) ) ; } output . addValue ( i , beta . getValue ( I ) * i . prRestart ( c ) ) ; } beta = output ; } } }
tr	2	@ Override public void sort ( Account [ ] array , Strategy strategy ) { Comparator < Account > comparaPorNumero = new Comparator < Account > ( ) { @ Override public int compare ( Account o1 , Account o2 ) { return o1 . getNumber ( ) . compareTo ( o2 . getNumber ( ) ) ; } } ; if ( strategy == Strategy . BUBBLESORT ) { bubblesort ( array , comparaPorNumero ) ; } if ( strategy == Strategy . MERGESORT ) { mergesort ( array , 0 , array . length - 1 , comparaPorNumero ) ; } }
tr	9	public void calculate ( String num , boolean [ ] result , int position ) { if ( position >= num . length ( ) - 2 ) { result [ position ] = false ; return ; } int size = num . length ( ) ; for ( int i = position ; i < size - 2 ; ++ i ) { if ( i > position && num . charAt ( position ) == 0 ) break ; for ( int j = i + 1 ; j < size - 1 ; ++ j ) { if ( j > i + 1 && num . charAt ( i + 1 ) == 0 ) break ; String tmp = String . valueOf ( long . valueOf ( num . substring ( position , i + 1 ) ) + long . valueOf ( num . substring ( i + 1 , j + 1 ) ) ) ; if ( tmp . length ( ) > size - 1 - j || ! num . substring ( j + 1 ) . startsWith ( tmp ) ) continue ; if ( tmp . length ( ) == size - 1 - j || result [ i + 1 ] ) { result [ position ] = true ; return ; } } } }
tr	2	@ Deprecated private boolean checkCondition ( String condition ) { if ( condition == null || condition . length ( ) == 0 ) { db . writeError ( "Skipping null or empty WHERE condition." , false ) ; return false ; } return true ; }
tr	4	public void initFeatureAlphabets ( DependencyInstance inst ) { getFeatureVector ( inst ) ; int n = inst . length ; for ( SemanticFrame frame : inst . frames ) { int p = frame . predid ; createWordFeatureVector ( inst , p ) ; int [ ] args = frame . arglbids ; for ( int a = 0 ; a < n ; ++ a ) { boolean isValid = isValidPredAugPair ( inst , p , a ) ; if ( args [ a ] >= 0 && isValid ) { int r = args [ a ] ; createContextFeatureVector ( inst , p , a , r ) ; createPathFeatureVector ( inst , p , a , r ) ; createWordFeatureVector ( inst , a ) ; } } } }
tr	1	public static double L2Norm ( double [ ] a ) { double result = 0.0 ; for ( double d : a ) { result += Math . pow ( d , 2 ) ; } return Math . sqrt ( result ) ; }
tr	8	public SharingPanel ( int w , int h ) { super ( ) ; this . width = w ; this . height = h ; this . isSelected = false ; this . setBackground ( Constants . backColor ) ; this . setLayout ( null ) ; this . selectedInfo = "" ; bgImg = new JLabel ( new ImageIcon ( Constants . BackgroudPath . shareListBG . getPath ( ) ) ) ; bgImg . setBounds ( 0 , 0 , width , height ) ; shareTo = new ImageIcon [ 3 ] ; shareTo [ 0 ] = new ImageIcon ( Constants . IconPath . shareToIcon1 . getPath ( ) ) ; shareTo [ 1 ] = new ImageIcon ( Constants . IconPath . shareToIcon2 . getPath ( ) ) ; shareTo [ 2 ] = new ImageIcon ( Constants . IconPath . shareToIcon3 . getPath ( ) ) ; shareFrom = new ImageIcon [ 3 ] ; shareFrom [ 0 ] = new ImageIcon ( Constants . IconPath . shareFromIcon1 . getPath ( ) ) ; shareFrom [ 1 ] = new ImageIcon ( Constants . IconPath . shareFromIcon2 . getPath ( ) ) ; shareFrom [ 2 ] = new ImageIcon ( Constants . IconPath . shareFromIcon3 . getPath ( ) ) ; handler = new ActionHandler ( ) ; tableModel = new DefaultTableModel ( ) { @ Override public boolean isCellEditable ( int row , int column ) { return false ; } } ; tableModel . setColumnIdentifiers ( new String [ ] { "    User ID" , "    Directory" , "  Status" , "" , "" , "" } ) ; table = new JTable ( ) { public class getColumnClass ( int column ) { return getValueAt ( 0 , column ) . getClass ( ) ; } } ; table . setSelectionMode ( ListSelectionModel . SINGLE_SELECTION ) ; table . setRowHeight ( 30 ) ; table . setFont ( Constants . Font1 ) ; table . setModel ( tableModel ) ; table . setAutoResizeMode ( JTable . AUTO_RESIZE_OFF ) ; table . getColumnModel ( ) . getColumn ( 0 ) . setPreferredWidth ( 130 ) ; table . getColumnModel ( ) . getColumn ( 1 ) . setPreferredWidth ( 150 ) ; table . getColumnModel ( ) . getColumn ( 2 ) . setPreferredWidth ( 100 ) ; for ( int i = 3 ; i < 6 ; i ++ ) { table . getColumnModel ( ) . getColumn ( i ) . setPreferredWidth ( 0 ) ; table . getColumnModel ( ) . getColumn ( i ) . setMinWidth ( 0 ) ; table . getColumnModel ( ) . getColumn ( i ) . setMaxWidth ( 0 ) ; } table . getSelectionModel ( ) . addListSelectionListener ( new ListSelectionListener ( ) { public void valueChanged ( ListSelectionEvent event ) { if ( ! event . getValueIsAdjusting ( ) && ! editMode ) { isSelected = true ; selectedInfo = "" ; if ( table . getValueAt ( table . getSelectedRow ( ) , 2 ) . equals ( shareTo [ 0 ] ) || table . getValueAt ( table . getSelectedRow ( ) , 2 ) . equals ( shareFrom [ 0 ] ) ) { initialize ( ) ; if ( table . getValueAt ( table . getSelectedRow ( ) , 3 ) . toString ( ) . equals ( "Target" ) ) { selectedInfo = "Target" ; } else if ( table . getValueAt ( table . getSelectedRow ( ) , 3 ) . toString ( ) . equals ( "Requester" ) ) { selectedInfo = "Requester" ; } } changePanel ( ) ; } } } ) ; header = table . getTableHeader ( ) ; header . setFont ( Constants . Font2 ) ; header . setEnabled ( false ) ; renderer = new DefaultTableCellRenderer ( ) ; renderer . setHorizontalAlignment ( JLabel . CENTER ) ; renderer . setFont ( getFont ( ) . deriveFont ( 80f ) ) ; table . getColumnModel ( ) . getColumn ( 0 ) . setCellRenderer ( renderer ) ; table . getColumnModel ( ) . getColumn ( 1 ) . setCellRenderer ( renderer ) ; scroll = new JScrollPane ( table , ScrollPaneConstants . VERTICAL_SCROLLBAR_ALWAYS , ScrollPaneConstants . HORIZONTAL_SCROLLBAR_AS_NEEDED ) ; scroll . setBounds ( 200 , 200 , 400 , 250 ) ; btn = new JButton [ 4 ] ; btn [ 0 ] = new JButton ( new ImageIcon ( Constants . ButtonPath . confirmBtn1 . getPath ( ) ) ) ; btn [ 0 ] . setRolloverIcon ( new ImageIcon ( Constants . ButtonPath . confirmBtn2 . getPath ( ) ) ) ; btn [ 1 ] = new JButton ( new ImageIcon ( Constants . ButtonPath . cancelBtn1 . getPath ( ) ) ) ; btn [ 1 ] . setRolloverIcon ( new ImageIcon ( Constants . ButtonPath . cancelBtn2 . getPath ( ) ) ) ; for ( int i = 0 ; i < 2 ; i ++ ) { btn [ i ] . setBounds ( 420 + ( i * 100 ) , 160 , 80 , 30 ) ; btn [ i ] . addActionListener ( handler ) ; } this . add ( scroll ) ; this . add ( bgImg ) ; }
tr	4	public boolean saveToFile ( String path ) { logger . info ( "Write all shares into " + path ) ; if ( path == null || ! path . endsWith ( ".ht" ) ) { throw new IllegalArgumentException ( "the given path: " + path + " is not valid (must end with .ht)" ) ; } try { FileWriter writer = new FileWriter ( path , false ) ; writer . write ( convertSharesToString ( ) ) ; writer . close ( ) ; } catch ( FileNotFoundException e1 ) { logger . warning ( "the given path: " + path + " is not valid" ) ; return false ; } catch ( IOException e ) { logger . warning ( "Could not write to file '" + path + "' - " + e . getMessage ( ) ) ; return false ; } return true ; }
tr	0	public boolean checkForFever ( final Person p , final Megameter m ) { return m . isBreathing ( p ) ; }
tr	8	private static Map < UnaryRule , List < String >> computeUnaryClosure ( Collection < UnaryRule > unaryRules ) { Map < UnaryRule , String > intermediateStates = new HashMap < UnaryRule , String > ( ) ; Counter < UnaryRule > pathCosts = new Counter < UnaryRule > ( ) ; Map < String , List < UnaryRule >> closedUnaryRulesByChild = new HashMap < String , List < UnaryRule >> ( ) ; Map < String , List < UnaryRule >> closedUnaryRulesByParent = new HashMap < String , List < UnaryRule >> ( ) ; Set < String > states = new HashSet < String > ( ) ; for ( UnaryRule unaryRule : unaryRules ) { relax ( pathCosts , intermediateStates , closedUnaryRulesByChild , closedUnaryRulesByParent , unaryRule , null , unaryRule . getScore ( ) ) ; states . add ( unaryRule . getParent ( ) ) ; states . add ( unaryRule . getChild ( ) ) ; } for ( String intermediateState : states ) { List < UnaryRule > incomingRules = closedUnaryRulesByChild . get ( intermediateState ) ; List < UnaryRule > outgoingRules = closedUnaryRulesByParent . get ( intermediateState ) ; if ( incomingRules == null || outgoingRules == null ) continue ; for ( UnaryRule incomingRule : incomingRules ) { for ( UnaryRule outgoingRule : outgoingRules ) { UnaryRule rule = new UnaryRule ( incomingRule . getParent ( ) , outgoingRule . getChild ( ) ) ; double newScore = pathCosts . getCount ( incomingRule ) * pathCosts . getCount ( outgoingRule ) ; relax ( pathCosts , intermediateStates , closedUnaryRulesByChild , closedUnaryRulesByParent , rule , intermediateState , newScore ) ; } } } for ( String state : states ) { UnaryRule selfLoopRule = new UnaryRule ( state , state ) ; relax ( pathCosts , intermediateStates , closedUnaryRulesByChild , closedUnaryRulesByParent , selfLoopRule , null , 1.0 ) ; } Map < UnaryRule , List < String >> closureMap = new HashMap < UnaryRule , List < String >> ( ) ; for ( UnaryRule unaryRule : pathCosts . keySet ( ) ) { unaryRule . setScore ( pathCosts . getCount ( unaryRule ) ) ; List < String > path = extractPath ( unaryRule , intermediateStates ) ; closureMap . put ( unaryRule , path ) ; } System . out . println ( "SIZE: " + closureMap . keySet ( ) . size ( ) ) ; return closureMap ; }
tr	9	public static long nameToLong ( String name ) { long longName = 0 ; for ( int c = 0 ; c < name . length ( ) && c < 12 ; c ++ ) { char character = name . charAt ( c ) ; longName *= 37 ; if ( character >= A && character <= Z ) longName += ( 1 + character ) - 65 ; else if ( character >= a && character <= z ) longName += ( 1 + character ) - 97 ; else if ( character >= 0 && character <= 9 ) longName += ( 27 + character ) - 48 ; } for ( ; longName % 37 == 0 && longName != 0 ; longName /= 37 ) ; return longName ; }
tr	6	public void addCategory ( Category c ) { try { String filepath = System . getProperty ( "user.home" ) + "/.TODO-group9/savedata.xml" ; DocumentBuilderFactory docFactory = DocumentBuilderFactory . newInstance ( ) ; DocumentBuilder docBuilder = docFactory . newDocumentBuilder ( ) ; Document doc = docBuilder . parse ( filepath ) ; Node categorys = doc . getElementsByTagName ( "categorys" ) . item ( 0 ) ; NodeList categoryList = doc . getElementsByTagName ( "category" ) ; for ( int i = 0 ; i < categoryList . getLength ( ) ; i ++ ) { String n = ( ( Element ) categoryList . item ( i ) ) . getAttribute ( "name" ) ; if ( n . equals ( c . getName ( ) ) ) { NamedNodeMap attr = categoryList . item ( i ) . getAttributes ( ) ; Node nodeRed = attr . getNamedItem ( "red" ) ; nodeRed . setTextContent ( "" + c . getColor ( ) . getRed ( ) ) ; ; Node nodeGreen = attr . getNamedItem ( "green" ) ; nodeGreen . setTextContent ( "" + c . getColor ( ) . getGreen ( ) ) ; ; Node nodeBlue = attr . getNamedItem ( "blue" ) ; nodeBlue . setTextContent ( "" + c . getColor ( ) . getBlue ( ) ) ; ; } } Element category = doc . createElement ( "category" ) ; categorys . appendChild ( category ) ; Element name = doc . createElement ( "name" ) ; name . appendChild ( doc . createTextNode ( c . getName ( ) ) ) ; category . appendChild ( name ) ; Element red = doc . createElement ( "red" ) ; String x = "" + c . getColor ( ) . getRed ( ) ; red . appendChild ( doc . createTextNode ( x ) ) ; category . appendChild ( red ) ; Element green = doc . createElement ( "green" ) ; String y = "" + c . getColor ( ) . getGreen ( ) ; green . appendChild ( doc . createTextNode ( y ) ) ; category . appendChild ( green ) ; Element blue = doc . createElement ( "blue" ) ; String z = "" + c . getColor ( ) . getBlue ( ) ; blue . appendChild ( doc . createTextNode ( z ) ) ; category . appendChild ( blue ) ; TransformerFactory transformerFactory = TransformerFactory . newInstance ( ) ; Transformer transformer = transformerFactory . newTransformer ( ) ; DOMSource source = new DOMSource ( doc ) ; StreamResult result = new StreamResult ( new File ( filepath ) ) ; transformer . transform ( source , result ) ; } catch ( ParserConfigurationException pce ) { pce . printStackTrace ( ) ; } catch ( TransformerException tfe ) { tfe . printStackTrace ( ) ; } catch ( IOException ioe ) { ioe . printStackTrace ( ) ; } catch ( SAXException sae ) { sae . printStackTrace ( ) ; } }
tr	3	private boolean r_reflexive ( ) { int among_var ; ket = cursor ; among_var = find_among_b ( a_3 , 2 ) ; if ( among_var == 0 ) { return false ; } bra = cursor ; switch ( among_var ) { case 0 : return false ; case 1 : slice_del ( ) ; break ; } return true ; }
tr	8	public static void parse_facts ( String path ) throws ClassNotFoundException , SQLException , IOException { BufferedReader reader = new BufferedReader ( new FileReader ( path + "yagoFacts.tsv" ) ) ; int j = 0 ; int has_capital = 0 , plays_for = 1 , located_in = 2 , acted_in = 3 , created = 4 , affiliated_to = 5 ; String line = null ; String [ ] data = null ; while ( ( line = reader . readLine ( ) ) != null ) { if ( j % 100000 == 0 ) System . out . println ( "facts: " + j ) ; j ++ ; data = line . split ( "\t" ) ; if ( "<hasCapital>" . equals ( data [ 2 ] ) ) MakeTheLink . db . Load_yago . insert_facts ( data , has_capital ) ; if ( "<playsFor>" . equals ( data [ 2 ] ) ) MakeTheLink . db . Load_yago . insert_facts ( data , plays_for ) ; if ( "<isLocatedIn>" . equals ( data [ 2 ] ) ) MakeTheLink . db . Load_yago . insert_facts ( data , located_in ) ; if ( "<actedIn>" . equals ( data [ 2 ] ) ) MakeTheLink . db . Load_yago . insert_facts ( data , acted_in ) ; if ( "<created>" . equals ( data [ 2 ] ) ) MakeTheLink . db . Load_yago . insert_facts ( data , created ) ; if ( "<isAffiliatedTo>" . equals ( data [ 2 ] ) ) MakeTheLink . db . Load_yago . insert_facts ( data , affiliated_to ) ; } reader . close ( ) ; }
tr	6	@ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; PairImpl < ? > other = ( PairImpl < ? > ) obj ; return Tuples . equals ( _first , other . _first ) && Tuples . equals ( _second , other . _second ) ; }
tr	2	public void addThird ( Timeslot t ) { if ( t instanceof Lab ) { addThirdLab ( t ) ; } else if ( t instanceof Tutorial ) { addThirdTut ( t ) ; } }
tr	0	public static double distance ( double x0 , double y0 , double x1 , double y1 ) { return distance ( x1 - x0 , y1 - y0 ) ; }
tr	5	public void update ( final World w ) { for ( short x = 0 ; x < sideLength ; x ++ ) { for ( short y = 0 ; y < sideLength ; y ++ ) { short tileX = ( short ) ( x + ( coords . getX ( ) * sideLength ) ) ; short tileY = ( short ) ( y + ( coords . getY ( ) * sideLength ) ) ; final Tile t = getTile ( x , y ) ; if ( ( t == Tiles . air ) || ( t == null ) ) { new Packet03Tile ( t , tileX , tileY ) . writeDataToServer ( ) ; } if ( t . doesTick ( ) ) { t . update ( w , tileX , tileY ) ; } } } }
tr	4	public void moveup ( ) { if ( isJumping && jumpSpeed > 0 ) { if ( ! testForColisions ( 0 , - jumpSpeed / 5 ) ) { rect . y -= jumpSpeed / 5 ; jumpSpeed -= 2 ; } else jumpSpeed = 0 ; } else if ( jumpSpeed == 0 ) { jumpSpeed = defaultJumpSpeed ; isFalling = true ; isJumping = false ; } }
tr	6	@ Override public boolean equals ( Object other ) { if ( other == null ) return false ; if ( other == this ) return true ; if ( ! this . getClass ( ) . isInstance ( other ) ) return false ; Vect o = ( Vect ) other ; if ( o . getX ( ) != this . getX ( ) ) return false ; if ( o . getY ( ) != this . getY ( ) ) return false ; if ( o . getZ ( ) != this . getZ ( ) ) return false ; return true ; }
tr	4	public static Method getMethod ( String methodName , class clazz ) { for ( Method method : clazz . getMethods ( ) ) { if ( method . getName ( ) . equals ( methodName ) ) { return method ; } } if ( ! clazz . equals ( Object . class ) ) { class superclass = clazz . getSuperclass ( ) ; if ( superclass != null ) { return getMethod ( methodName , superclass ) ; } else { return null ; } } else { return null ; } }
tr	7	synchronized public void checkClipboard ( ) { if ( ClipboardDialog . systemClipboard != null && cc . viewer . sendClipboard . getValue ( ) ) { Transferable t = ClipboardDialog . systemClipboard . getContents ( this ) ; if ( ( t != null ) && t . isDataFlavorSupported ( DataFlavor . stringFlavor ) ) { try { String newContents = ( String ) t . getTransferData ( DataFlavor . stringFlavor ) ; if ( newContents != null && ! newContents . equals ( oldContents ) ) { cc . writeClientCutText ( newContents ) ; oldContents = newContents ; cc . clipboardDialog . setContents ( newContents ) ; } } catch ( Exception e ) { System . out . println ( "Exception getting clipboard data: " + e . getMessage ( ) ) ; } } } }
tr	3	static String decode ( String ciphertext , String mustOccur ) throws Exception { if ( ciphertext . contains ( mustOccur ) ) { return ciphertext ; } for ( int i = 1 ; i < 26 ; i ++ ) { String decode = encode ( ciphertext , i ) ; if ( decode . contains ( mustOccur ) ) { return decode ; } } throw new Exception ( "Decoded string not found" ) ; }
tr	3	public static void main ( String [ ] args ) { final int [ ] subscripts = new int [ ] { 1 , 10 , 100 , 1000 , 10000 , 100000 , 1000000 } ; final int last = subscripts [ subscripts . length - 1 ] ; String s = null ; long p = 1 ; int ls = 0 ; int j = 0 ; int l = 0 ; for ( int i = 1 ; i < 1000000 ; i ++ ) { s = String . valueOf ( i ) ; ls = s . length ( ) ; l += ls ; if ( l >= subscripts [ j ] ) { final int n = ls - ( l - subscripts [ j ] ) - 1 ; final int d = Integer . parseInt ( s . substring ( n , n + 1 ) ) ; p *= ( long ) d ; j ++ ; } if ( l > last ) { break ; } } System . out . println ( "# p = " + p ) ; }
tr	6	public void write ( ) { System . out . println ( "The letters are:" ) ; for ( int i = 0 ; i < word . length ; i ++ ) { System . out . println ( word [ i ] ) ; } System . out . println ( "The occruances are:  " ) ; for ( int i = 0 ; i < letter . length ; i ++ ) { if ( letter [ i ] != 0 && i != 26 ) System . out . println ( ( char ) ( i + 97 ) + ":  " + letter [ i ] ) ; else if ( letter [ i ] != 0 && i == 26 ) System . out . println ( "Space or other :" + letter [ i ] ) ; } }
tr	3	public int getFrameLength ( int frame ) { int frameLength = frameLengths [ frame ] ; if ( frameLength == 0 ) { Animation animation = Animation . forFrameId ( frame2Ids [ frame ] ) ; if ( animation != null ) frameLength = frameLengths [ frame ] = animation . displayLength ; } if ( frameLength == 0 ) frameLength = 1 ; return frameLength ; }
tr	0	public void init ( GLAutoDrawable drawable ) { gl = drawable . getGL ( ) . getGL2 ( ) ; glu = new GLU ( ) ; gl . glShadeModel ( GL2 . GL_SMOOTH ) ; gl . glEnable ( GL2 . GL_DEPTH_TEST ) ; gl . glCullFace ( GL2 . GL_NONE ) ; gl . glClearColor ( 0.54f , 0.68f , 0.78f , 1.0f ) ; gl . glLightModeli ( GL2 . GL_LIGHT0 , GL2 . GL_LIGHT_MODEL_TWO_SIDE ) ; gl . glLightfv ( GL2 . GL_LIGHT0 , GL2 . GL_DIFFUSE , new float [ ] { 1f , 1f , 1f , 1f } , 0 ) ; gl . glLightfv ( GL2 . GL_LIGHT0 , GL2 . GL_POSITION , new float [ ] { 0f , 0f , 0f , 1f } , 0 ) ; gl . glEnable ( GL2 . GL_LIGHT0 ) ; gl . glEnable ( GL2 . GL_LIGHTING ) ; }
tr	7	public static void entityError ( Lexer lexer , short code , String entity , int c ) { lexer . warnings ++ ; if ( lexer . configuration . ShowWarnings ) { position ( lexer ) ; if ( code == MISSING_SEMICOLON ) { try { tidyPrint ( lexer . errout , MessageFormat . format ( res . getString ( "missing_semicolon" ) , new Object [ ] { entity } ) ) ; } catch ( MissingResourceException e ) { lexer . errout . println ( e . toString ( ) ) ; } } else if ( code == UNKNOWN_ENTITY ) { try { tidyPrint ( lexer . errout , MessageFormat . format ( res . getString ( "unknown_entity" ) , new Object [ ] { entity } ) ) ; } catch ( MissingResourceException e ) { lexer . errout . println ( e . toString ( ) ) ; } } else if ( code == UNESCAPED_AMPERSAND ) { try { tidyPrint ( lexer . errout , res . getString ( "unescaped_ampersand" ) ) ; } catch ( MissingResourceException e ) { lexer . errout . println ( e . toString ( ) ) ; } } tidyPrintln ( lexer . errout ) ; } }
tr	2	private String readStream ( Process proc , InputStream in ) { StringBuffer ret = new StringBuffer ( ) ; try { int n = in . read ( ) ; while ( n != - 1 ) { ret . append ( ( char ) n ) ; n = in . read ( ) ; } } catch ( IOException ex ) { Logger . getLogger ( ThirdIdea . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } return ret . toString ( ) ; }
tr	0	public void mouseExited ( MouseEvent e ) { }
tr	0	public void setProfileTbls ( Set < ProfileTbl > profileTbls ) { this . profileTbls = profileTbls ; }
tr	2	@ Override public void addProjectileToServer ( ) { int id ; do { id = ( int ) ( Math . random ( ) * 10000 ) ; } while ( getPlayer ( ) . getGame ( ) . getProjectileIDs ( ) . contains ( id ) ) ; Packet13SendNewProjectile packet ; if ( getPlayer ( ) . isFacingRight ( ) ) packet = new Packet13SendNewProjectile ( "arrow" , - Math . cos ( getrAngle ( ) ) * 28 + getPlayer ( ) . getxPosition ( ) , - Math . sin ( getrAngle ( ) ) * 28 + getPlayer ( ) . getyPosition ( ) - 32 , getrAngle ( ) , getPlayer ( ) . getName ( ) , id ) ; else packet = new Packet13SendNewProjectile ( "arrow" , Math . cos ( getrAngle ( ) ) * 28 + getPlayer ( ) . getxPosition ( ) - 16 , Math . sin ( getrAngle ( ) ) * 28 + getPlayer ( ) . getyPosition ( ) - 32 , getrAngle ( ) , getPlayer ( ) . getName ( ) , id ) ; packet . writeData ( getPlayer ( ) . getGame ( ) . getSocketClient ( ) ) ; }
tr	1	public static synchronized SondageDao getInstance ( ) { if ( instance == null ) instance = new SondageDao ( ) ; return instance ; }
tr	8	public void run ( ) throws ParsingException { parseStack . push ( new TerminalEntry ( EOF ) ) ; parseStack . addToParseStack ( ruleTable . find ( startSymbol , startToken ) ) ; A = parseStack . peek ( ) ; getNextToken ( ) ; while ( ( A != null ) && ! A . isEof ( ) ) { A = parseStack . peek ( ) ; if ( A . isTerminal ( ) ) { if ( A . matches ( i ) ) { parseStack . pop ( ) ; if ( parseStack . notEmpty ( ) ) { A = parseStack . peek ( ) ; getNextToken ( ) ; } } else { throw new ParsingException ( "Terminal mismatch. Expected: " + A + " Found: " + i + "" ) ; } } else if ( A . isSemanticEntry ( ) ) { final SemanticNode node = nodeFactory . getNewNode ( A ) ; node . runOnSemanticStack ( semanticStack ) ; parseStack . pop ( ) ; } else { if ( isRuleContained ( A , i ) ) { parseStack . pop ( ) ; parseStack . addToParseStack ( ruleTable . find ( A , i ) ) ; A = parseStack . peek ( ) ; } else { throw new ParsingException ( "Non-terminal mismatch. No entry in the table for: " + A + "   " + i ) ; } } } if ( ! stream . isEmpty ( ) ) { throw new ParsingException ( "Parser found the end of file marker but the token stream was not empty." ) ; } }
tr	8	public boolean initHeaderComponents ( ) { locationLabel = new JLabel ( "Project Location" ) ; locationLabel . setBounds ( 5 , 5 , 100 , 25 ) ; locationField = new JTextField ( ) ; locationField . setBounds ( 105 , 5 , 400 , 25 ) ; includeLabel = new JLabel ( "Include File type" ) ; includeLabel . setBounds ( 5 , 35 , 100 , 25 ) ; includeTextField = new JTextField ( ) ; includeTextField . setBounds ( 105 , 35 , 400 , 25 ) ; nonIncludeLabel = new JLabel ( "Non include" ) ; nonIncludeLabel . setBounds ( 5 , 65 , 100 , 25 ) ; nonIncludeTextField = new JTextField ( ) ; nonIncludeTextField . setBounds ( 105 , 65 , 400 , 25 ) ; configIncludeAndNonInclude ( ) ; openFileButton = new JButton ( "File.." ) ; openFileButton . setBounds ( 515 , 5 , 80 , 25 ) ; openFileButton . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { JFileChooser fileChooser = new JFileChooser ( new File ( "c:" ) ) ; int i = fileChooser . showOpenDialog ( header ) ; if ( i == JFileChooser . APPROVE_OPTION ) { locationField . setText ( fileChooser . getSelectedFile ( ) . getAbsolutePath ( ) ) ; } } } ) ; configButton = new JButton ( "Config.." ) ; configButton . setBounds ( 515 , 45 , 80 , 25 ) ; configButton . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { configIncludeAndNonInclude ( ) ; } } ) ; loadButton = new JButton ( "Load" ) ; loadButton . setBounds ( 605 , 5 , 80 , 80 ) ; loadButton . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { if ( locationField . getText ( ) == null || locationField . getText ( ) . isEmpty ( ) ) { UISupport . showMessage ( "File cannot be null!" ) ; return ; } if ( includeTextField . getText ( ) == null || includeTextField . getText ( ) . isEmpty ( ) ) { UISupport . showMessage ( "Include cannot be null!" ) ; return ; } if ( nonIncludeTextField . getText ( ) == null || nonIncludeTextField . getText ( ) . isEmpty ( ) ) { UISupport . showMessage ( "Non-Include cannot be null!" ) ; return ; } if ( sourceCounter == null ) { sourceCounter = new SourceCounter ( FileUtils . getFiles ( new File ( locationField . getText ( ) ) ) , includeTextField . getText ( ) , nonIncludeTextField . getText ( ) ) ; } else { sourceCounter . setFiles ( FileUtils . getFiles ( new File ( locationField . getText ( ) ) ) ) ; sourceCounter . repaint ( ) ; } } } ) ; header . add ( locationLabel ) ; header . add ( locationField ) ; header . add ( includeLabel ) ; header . add ( includeTextField ) ; header . add ( nonIncludeLabel ) ; header . add ( nonIncludeTextField ) ; header . add ( openFileButton ) ; header . add ( configButton ) ; header . add ( loadButton ) ; return false ; }
tr	4	private int findPlaceholderEndIndex ( CharSequence buf , int startIndex ) { int index = startIndex + this . placeholderPrefix . length ( ) ; int withinNestedPlaceholder = 0 ; while ( index < buf . length ( ) ) { if ( StringUtils . substringMatch ( buf , index , this . placeholderSuffix ) ) { if ( withinNestedPlaceholder > 0 ) { withinNestedPlaceholder -- ; index = index + this . placeholderSuffix . length ( ) ; } else { return index ; } } else if ( StringUtils . substringMatch ( buf , index , this . simplePrefix ) ) { withinNestedPlaceholder ++ ; index = index + this . simplePrefix . length ( ) ; } else { index ++ ; } } return - 1 ; }
tr	4	private int uniqueRecursive ( LinkedList < Cell > empties , int solutions ) { if ( empties . size ( ) == 0 ) { return solutions + 1 ; } int result = solutions ; LinkedList < Cell > tail = empties ; Cell head = tail . remove ( ) ; for ( int i : head ) { try { head . setValue ( i ) ; Collections . sort ( tail , ( Cell c1 , Cell c2 ) -> c1 . getMarkUp ( ) . cardinality ( ) - c2 . getMarkUp ( ) . cardinality ( ) ) ; result = uniqueRecursive ( tail , result ) ; if ( result > 1 ) { head . reset ( ) ; return result ; } head . reset ( ) ; } catch ( CellContentException e ) { continue ; } } empties . addFirst ( head ) ; return result ; }
tr	7	public ClassificationCodeType codeType ( ) { if ( "Flg" . equals ( name ( ) ) ) { return ClassificationCodeType . Number ; } if ( "MemberStatus" . equals ( name ( ) ) ) { return ClassificationCodeType . String ; } if ( "ServiceRank" . equals ( name ( ) ) ) { return ClassificationCodeType . String ; } if ( "Region" . equals ( name ( ) ) ) { return ClassificationCodeType . Number ; } if ( "WithdrawalReason" . equals ( name ( ) ) ) { return ClassificationCodeType . String ; } if ( "ProductCategory" . equals ( name ( ) ) ) { return ClassificationCodeType . String ; } if ( "ProductStatus" . equals ( name ( ) ) ) { return ClassificationCodeType . String ; } return ClassificationCodeType . String ; }
tr	4	public void elsolve ( final double [ ] b , final double [ ] y ) { int i , j ; double sum ; if ( b . length != n || y . length != n ) throw new IllegalArgumentException ( "bad lengths" ) ; for ( i = 0 ; i < n ; i ++ ) { for ( sum = b [ i ] , j = 0 ; j < i ; j ++ ) sum -= el [ i ] [ j ] * y [ j ] ; y [ i ] = sum / el [ i ] [ i ] ; } }
tr	6	private Expr term ( ) { Symbol op ; Expr left = signalFactor ( ) ; while ( ( op = lexer . token ) == Symbol . DIV || op == Symbol . MULT || op == Symbol . AND ) { lexer . nextToken ( ) ; Expr right = signalFactor ( ) ; if ( op != Symbol . AND && ! ( right . getType ( ) instanceof IntType && left . getType ( ) instanceof IntType ) ) { error . show ( "Operator '" + op + "' cannot be applied to given types" ) ; } left = new CompositeExpr ( left , op , right ) ; } return left ; }
