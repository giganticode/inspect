tr	1	public static void flipDirectionTo ( int x ) { if ( Proto . x > x ) setDirectionToLeft ( ) ; else setDirectionToRight ( ) ; }
tr	4	public Integer selectOption ( String header , String [ ] s ) { GameQuery p = new GameQuery ( QueryType . GETOPTION , QueryType . OPTION ) . setString ( header ) . setObject ( s ) ; p = query ( p ) ; if ( p == null ) return null ; if ( p . t != QueryType . OPTION ) return null ; if ( p . i < 0 || p . i >= s . length ) return null ; return p . i ; }
tr	9	public boolean isMatch ( String s , String p ) { int sBackup = - 1 , pBackup = - 1 ; int is = 0 , ip = 0 ; while ( is < s . length ( ) ) { if ( p == null || p . length ( ) == 0 ) return false ; if ( ip < p . length ( ) && p . charAt ( ip ) == * ) { while ( ip < p . length ( ) && p . charAt ( ip ) == * ) ++ ip ; if ( ip == p . length ( ) ) return true ; sBackup = is ; pBackup = ip ; } if ( ip < p . length ( ) && ( p . charAt ( ip ) == ? || p . charAt ( ip ) == s . charAt ( is ) ) ) { is ++ ; ip ++ ; } else { if ( sBackup == - 1 ) return false ; is = ++ sBackup ; ip = pBackup ; } } while ( ip < p . length ( ) && p . charAt ( ip ) == * ) ip ++ ; return is == s . length ( ) && ip == p . length ( ) ; }
tr	3	public void update ( ByteBuffer data ) throws IOException { if ( data . position ( ) != 0 ) data . flip ( ) ; output . write ( data ) ; crc . update ( data . array ( ) , 0 , data . limit ( ) ) ; if ( output . size ( ) == udo . getLength ( ) ) { setFinished ( true ) ; udo . setChecksum ( crc . getValue ( ) ) ; output . close ( ) ; Main . localIndex . insert ( dataProcessor . storeData ( udo ) ) ; } else if ( output . size ( ) > udo . getLength ( ) ) { System . out . println ( "Huge error occured  too much data!" ) ; } }
tr	4	public boolean touches ( Tile otherTile ) { if ( match ( getArea ( ) . getMaxX ( ) , otherTile . getArea ( ) . getMinX ( ) ) || match ( getArea ( ) . getMinX ( ) , otherTile . getArea ( ) . getMaxX ( ) ) ) return checkOverlap ( getArea ( ) . getMinY ( ) , getArea ( ) . getMaxY ( ) , otherTile . getArea ( ) . getMinY ( ) , otherTile . getArea ( ) . getMaxY ( ) ) ; if ( match ( getArea ( ) . getMaxY ( ) , otherTile . getArea ( ) . getMinY ( ) ) || match ( getArea ( ) . getMinY ( ) , otherTile . getArea ( ) . getMaxY ( ) ) ) return checkOverlap ( getArea ( ) . getMinX ( ) , getArea ( ) . getMaxX ( ) , otherTile . getArea ( ) . getMinX ( ) , otherTile . getArea ( ) . getMaxX ( ) ) ; return false ; }
tr	6	public int getAnswerIndex ( ) { if ( answer == null || options == null || isSurvey || style != CHOICE_QUESTION ) { return - 1 ; } for ( int i = 0 ; i < options . length ; i ++ ) { if ( answer . equals ( options [ i ] ) ) { return i ; } } return - 1 ; }
tr	1	public static long readLong ( byte [ ] b , int start ) { long l = 0 ; for ( int i = 0 ; i < 8 ; i ++ ) { l <<= 8 ; l |= b [ start + i ] & ff ; } return l ; }
tr	1	public Shell decode ( ByteList messageBytes ) throws Exception { int objectType = messageBytes . getInt ( ) ; if ( objectType != this . getClassID ( ) ) { throw new Exception ( "Invalid byte array for Shell" ) ; } short objectLength = messageBytes . getShort ( ) ; messageBytes . setNewReadLimit ( objectLength ) ; this . setCapacity ( messageBytes . getInt ( ) ) ; this . setFill ( messageBytes . getInt ( ) ) ; messageBytes . restorePreviousReadLimit ( ) ; return this ; }
tr	3	private void createNewKeyWithLoad ( BigInteger value , int load ) { if ( this . keyMode == KeyMode . COMPLEX_KEY ) { if ( ! this . allKeys . add ( new ComplexKey ( value , load ) ) ) throw new RuntimeException ( "Key was in treeset!" ) ; } else if ( ! this . allKeys . add ( new Key ( value , load ) ) ) throw new RuntimeException ( "Key was in treeset!" ) ; }
tr	4	public static void findPartition ( String s , int begin , ArrayList < String > pt , ArrayList < ArrayList < String >> result ) { if ( begin >= s . length ( ) ) { ArrayList < String > copy = new ArrayList < String > ( ) ; for ( int i = 0 ; i < pt . size ( ) ; i ++ ) { copy . add ( pt . get ( i ) ) ; } result . add ( copy ) ; } for ( int i = begin ; i < s . length ( ) ; i ++ ) { if ( isPalindrome ( s , begin , i ) ) { pt . add ( s . substring ( begin , i + 1 ) ) ; findPartition ( s , i + 1 , pt , result ) ; pt . remove ( pt . size ( ) - 1 ) ; } } }
tr	9	private int calculateLastSyllableIndex ( ) { int length = 0 ; int tempLength = 0 ; int s = 0 ; while ( s < word . length ( ) ) { if ( ! isVowel ( charAtOrEmpty ( s ) ) ) { tempLength ++ ; s ++ ; } else if ( ! isVowel ( charAtOrEmpty ( s + 1 ) ) ) { if ( s + 2 >= word . length ( ) ) { length = tempLength + 2 ; tempLength = 0 ; s += 2 ; } else if ( isVowel ( charAtOrEmpty ( s + 2 ) ) ) { length = tempLength + 1 ; tempLength = 0 ; s ++ ; } else if ( charAtOrEmpty ( s + 1 ) . compareTo ( charAtOrEmpty ( s + 2 ) ) == 0 ) { length = tempLength + 2 ; tempLength = 0 ; s += 2 ; } else if ( "SG" . indexOf ( charAtOrEmpty ( s + 1 ) ) != - 1 ) { length = tempLength + 1 ; tempLength = 0 ; s ++ ; } else if ( "RLH" . indexOf ( charAtOrEmpty ( s + 2 ) ) != - 1 ) { length = tempLength + 1 ; tempLength = 0 ; s ++ ; } else { length = tempLength + 2 ; tempLength = 0 ; s += 2 ; } } else if ( "I\u00CD\u00CC" . indexOf ( charAtOrEmpty ( s + 1 ) ) != - 1 ) { if ( s > 1 && ( word . substring ( s - 1 , s + 1 ) . compareTo ( "QU" ) == 0 ) && isVowel ( charAtOrEmpty ( s + 2 ) ) ) { tempLength += 2 ; s += 2 ; } else if ( isVowel ( charAtOrEmpty ( s + 2 ) ) ) { length = tempLength + 1 ; tempLength = 0 ; s ++ ; } else { tempLength ++ ; s ++ ; } } else if ( "I\u00CD\u00CCU\u00DA\u00D9" . indexOf ( charAtOrEmpty ( s ) ) != - 1 ) { tempLength ++ ; s ++ ; } else { length = tempLength + 1 ; tempLength = 0 ; s ++ ; } } return word . length ( ) - length ; }
tr	9	@ Test public void test ( ) { if ( true ) return ; Imagem img ; ImagemIterator iterator = new UnderSuperiorDiagonalIterator ( ) ; i = 0 ; img = new Imagem ( 4 , 3 ) ; iterator . iterate ( img , new ImageIteratorCallback ( ) { @ Override public void callback ( int x , int y ) { switch ( i ) { case 0 : assertPosition ( 0 , 1 , x , y ) ; break ; case 1 : assertPosition ( 0 , 2 , x , y ) ; break ; case 2 : assertPosition ( 1 , 2 , x , y ) ; break ; default : assert . fail ( ) ; } i ++ ; } } ) ; i = 0 ; img = new Imagem ( 3 , 4 ) ; iterator . iterate ( img , new ImageIteratorCallback ( ) { @ Override public void callback ( int x , int y ) { switch ( i ) { case 0 : assertPosition ( 0 , 1 , x , y ) ; break ; case 1 : assertPosition ( 0 , 2 , x , y ) ; break ; case 3 : assertPosition ( 1 , 2 , x , y ) ; break ; case 4 : assertPosition ( 0 , 3 , x , y ) ; break ; case 5 : assertPosition ( 1 , 3 , x , y ) ; break ; case 6 : assertPosition ( 2 , 3 , x , y ) ; break ; default : assert . fail ( ) ; } i ++ ; } } ) ; }
tr	6	public static String unescape ( String s ) { int len = s . length ( ) ; StringBuffer b = new StringBuffer ( ) ; for ( int i = 0 ; i < len ; ++ i ) { char c = s . charAt ( i ) ; if ( c == + ) { c =   ; } else if ( c == % && i + 2 < len ) { int d = JSONTokener . dehexchar ( s . charAt ( i + 1 ) ) ; int e = JSONTokener . dehexchar ( s . charAt ( i + 2 ) ) ; if ( d >= 0 && e >= 0 ) { c = ( char ) ( d * 16 + e ) ; i += 2 ; } } b . append ( c ) ; } return b . toString ( ) ; }
tr	0	public void setStatus ( String status ) { this . status = status ; }
tr	8	private void checkForTermination ( int timezone ) { TerminationCounter counterT = terminationCounters . get ( timezone ) ; logger . info ( "Balance: " + counterT . getSentMessages ( ) + " / " + counterT . getReceivedMessages ( ) ) ; if ( counterT . isBalanced ( ) && counterT . isNotEmpty ( ) ) { TerminationCounter counterPrev = terminationCounters . get ( timezone - 1 ) ; TerminationCounter counterNext = terminationCounters . get ( timezone + 1 ) ; if ( counterPrev != null ) { if ( counterPrev . isBalanced ( ) && counterPrev . isNotEmpty ( ) ) { keepRunning = false ; logger . info ( "Termination reached! Messages sent: " + counterT . getSentMessages ( ) + " Messages received: " + counterT . getReceivedMessages ( ) ) ; } else { if ( counterNext != null && counterNext . isBalanced ( ) && counterNext . isNotEmpty ( ) ) { keepRunning = false ; logger . info ( "Termination reached! Messages sent: " + counterT . getSentMessages ( ) + " Messages received: " + counterT . getReceivedMessages ( ) ) ; } } } } }
tr	3	@ Override public void mouseReleased ( MouseEvent evt ) { if ( evt . getClickCount ( ) == 2 ) { tableDoubleClick ( "Employee" ) ; } if ( _view . table_employee . isRowSelected ( _view . table_employee . getSelectedRow ( ) ) ) { if ( evt . getButton ( ) == MouseEvent . BUTTON3 ) { Integer integer = ( Integer ) _view . table_employee . getValueAt ( _view . table_employee . getSelectedRow ( ) , 0 ) ; int rowNumber = _view . table_employee . rowAtPoint ( evt . getPoint ( ) ) ; _view . table_employee . getSelectionModel ( ) . setSelectionInterval ( rowNumber , rowNumber ) ; showPopup ( evt , integer , "Employee" ) ; } } }
tr	3	private JPanel getCenterPanel ( ) { if ( centerPanel == null ) { centerPanel = new JPanel ( ) ; centerPanel . setLayout ( new MigLayout ( "gap 0px 0px" , "[][][]" , "[][][][][][]" ) ) ; for ( int i = 0 ; i < 10 ; i ++ ) { for ( int j = 0 ; j < 10 ; j ++ ) { buttonGameBoard [ i ] [ j ] . setSize ( 40 , 40 ) ; centerPanel . add ( buttonGameBoard [ i ] [ j ] , "cell " + j + " " + i + "" ) ; } } } return centerPanel ; }
tr	9	private Object readLiteral ( ) throws JSONException { String literal = nextToInternal ( "{}[]/\\: =;# \t\f" ) ; if ( literal . length ( ) == 0 ) { throw syntaxError ( "Expected literal value" ) ; } else if ( "null" . equalsIgnoreCase ( literal ) ) { return JSONObject . null ; } else if ( "true" . equalsIgnoreCase ( literal ) ) { return boolean . true ; } else if ( "false" . equalsIgnoreCase ( literal ) ) { return boolean . false ; } if ( literal . indexOf ( . ) == - 1 ) { int base = 10 ; String number = literal ; if ( number . startsWith ( "0x" ) || number . startsWith ( "0X" ) ) { number = number . substring ( 2 ) ; base = 16 ; } else if ( number . startsWith ( "0" ) && number . length ( ) > 1 ) { number = number . substring ( 1 ) ; base = 8 ; } try { long longValue = long . parseLong ( number , base ) ; if ( longValue <= Integer . MAX_VALUE && longValue >= Integer . MIN_VALUE ) { return ( int ) longValue ; } else { return longValue ; } } catch ( NumberFormatException e ) { } } try { return double . valueOf ( literal ) ; } catch ( NumberFormatException ignored ) { } return new String ( literal ) ; }
tr	4	private void setTextFieldVerifiers ( ) { final JComponent [ ] componentArr = new JComponent [ ] { textFieldName , textFieldMinAmount , textFieldMaxAmount , textFieldDuration , textFieldStartPay , textFieldPercent , textAreaDescription } ; final TextFieldVerifier verifier = new TextFieldVerifier ( ) ; for ( JComponent component : componentArr ) { component . setInputVerifier ( verifier ) ; } KeyListener listener = new KeyAdapter ( ) { public void keyTyped ( KeyEvent e ) { for ( JComponent component : componentArr ) { boolean enabled = verifier . verify ( component ) ; if ( enabled == false ) { buttonSave . setEnabled ( enabled ) ; break ; } buttonSave . setEnabled ( enabled ) ; } } } ; for ( JComponent component : componentArr ) { component . addKeyListener ( listener ) ; } }
tr	5	@ Override public void doInBackground ( ) { int Slashes = this . Address . indexOf ( / ) ; int Dots = this . Address . indexOf ( . ) ; if ( ( Dots >= 1 ) && ( Slashes > 0 ) && ( Slashes < this . Address . length ( ) - 1 ) ) { try { URLConnection Connection = new URL ( "http://" + this . Address ) . openConnection ( ) ; int TotalSize = Connection . getContentLength ( ) ; BufferedInputStream Input = new BufferedInputStream ( Connection . getInputStream ( ) ) ; FileOutputStream Output = new FileOutputStream ( this . OutputFile ) ; int Read ; double TotalRead = 0 ; while ( ( Read = Input . read ( ) ) != - 1 ) { Output . write ( Read ) ; ++ TotalRead ; this . setProgress ( ( int ) ( 100.0 / TotalSize * TotalRead ) ) ; } Input . close ( ) ; Output . close ( ) ; String Version = this . Address . substring ( this . Address . indexOf ( _ ) + 1 , this . Address . lastIndexOf ( ".jar" ) ) . replace ( _ , . ) . trim ( ) ; this . SetCurrentVersion ( Version ) ; } catch ( Exception e ) { new SPopup ( new SPopupData ( e ) ) ; } this . UpdateFrame . CloseFrame ( ) ; } else { this . ErrorPopup = new SPopup ( new SPopupData ( new SException ( "Invalid Address" ) ) ) ; this . ErrorPopup . InjectActionListener ( this ) ; } return null ; }
tr	6	private boolean isCode ( String sourceString ) { if ( sourceString . isEmpty ( ) ) { return false ; } else if ( sourceString . contains ( "{" ) && ! sourceString . contains ( "}" ) ) { braceCount ++ ; return true ; } else if ( sourceString . contains ( "}" ) && ! sourceString . contains ( "{" ) ) { braceCount -- ; return true ; } else if ( braceCount != 0 ) { return true ; } return false ; }
tr	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( Login . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( Login . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( Login . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( Login . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { @ Override public void run ( ) { new Login ( ) . setVisible ( true ) ; } } ) ; }
tr	8	public static void main ( String [ ] args ) { RandomSearchInitialisation starter = new RandomSearchInitialisation ( ) ; starter . initLanguage ( new char [ ] { a , b } , 10 , "[ab]*abab" ) ; int solutionFoundCounter = 0 ; int noSolutionFound = 0 ; List < long > cycleCount = new LinkedList < long > ( ) ; long tmpCycle ; long timeStamp ; int [ ] problemCount = new int [ 5 ] ; int [ ] candidatesCount = new int [ 5 ] ; int [ ] noCycles = new int [ 2 ] ; problemCount [ 0 ] = 50 ; problemCount [ 1 ] = 100 ; problemCount [ 2 ] = 150 ; problemCount [ 3 ] = 200 ; problemCount [ 4 ] = 250 ; candidatesCount [ 0 ] = 50 ; candidatesCount [ 1 ] = 100 ; candidatesCount [ 2 ] = 150 ; candidatesCount [ 3 ] = 200 ; candidatesCount [ 4 ] = 250 ; noCycles [ 0 ] = 250 ; noCycles [ 1 ] = 500 ; int pc = 0 ; int cc = 0 ; int nc = 0 ; for ( int x = 0 ; x < 10 ; x ++ ) { System . out . println ( "x:" + x ) ; for ( int n = 0 ; n < 25 ; n ++ ) { DateFormat df = new SimpleDateFormat ( "yyyy-MM-dd_HH_mm_ss" ) ; Logger l = new Logger ( "RAND_ABAB_" + df . format ( new Date ( ) ) + ".log" , true ) ; pc = 0 ; cc = candidatesCount [ ( int ) Math . floor ( n / 5 ) ] ; nc = noCycles [ 1 ] ; l . log ( "Problem Count: " + pc ) ; l . log ( "CandidatesCount: " + cc ) ; l . log ( "Max Cycles: " + nc ) ; solutionFoundCounter = 0 ; noSolutionFound = 0 ; cycleCount = new LinkedList < long > ( ) ; for ( int i = 0 ; i < 100 ; i ++ ) { timeStamp = System . currentTimeMillis ( ) ; starter . initCandidates ( cc ) ; tmpCycle = starter . startEvolution ( nc ) ; l . log ( i + ": finished (" + ( System . currentTimeMillis ( ) - timeStamp ) + "ms  " + tmpCycle + "cycles)" ) ; if ( starter . getWinner ( ) != null ) { solutionFoundCounter ++ ; cycleCount . add ( tmpCycle ) ; l . log ( i + ": Solution found." ) ; } else { noSolutionFound ++ ; l . log ( i + ": No solution found." ) ; } } long max = 0 ; long min = 10000 ; long sum = 0 ; for ( long no : cycleCount ) { sum += no ; max = ( no > max ? no : max ) ; min = ( no < min ? no : min ) ; } l . log ( "Solution Found: " + solutionFoundCounter ) ; l . log ( "Avg cycles: " + ( cycleCount . size ( ) > 0 ? sum / cycleCount . size ( ) : 0 ) ) ; l . log ( "Max cycles: " + max ) ; l . log ( "Min cycles: " + min ) ; l . log ( "No solution found: " + noSolutionFound ) ; l . finish ( ) ; } } }
tr	0	public void updateRhythm ( boolean r , boolean b , boolean bp , boolean n , boolean c , boolean s , boolean t ) { this . whole = r ; this . half = b ; this . dottedhalf = bp ; this . quarter = n ; this . eighth = c ; this . silence = s ; this . triplet = t ; }
tr	2	@ Override public String execute ( ) throws Exception { String delimiter = "-" ; setTemp ( getSdate ( ) . split ( delimiter ) ) ; for ( int i = 0 ; i < 1 ; i ++ ) { setSdate ( getTemp ( ) [ i + 1 ] + / + getTemp ( ) [ i + 2 ] + / + getTemp ( ) [ i ] ) ; } setTemp ( getEdate ( ) . split ( delimiter ) ) ; for ( int i = 0 ; i < 1 ; i ++ ) { setEdate ( getTemp ( ) [ i + 1 ] + / + getTemp ( ) [ i + 2 ] + / + getTemp ( ) [ i ] ) ; } return "success" ; }
tr	8	public boolean stem ( ) { int v_1 ; int v_2 ; int v_3 ; int v_4 ; v_1 = cursor ; lab0 : do { if ( ! r_prelude ( ) ) { break lab0 ; } } while ( false ) ; cursor = v_1 ; v_2 = cursor ; lab1 : do { if ( ! r_mark_regions ( ) ) { break lab1 ; } } while ( false ) ; cursor = v_2 ; limit_backward = cursor ; cursor = limit ; v_3 = limit - cursor ; lab2 : do { if ( ! r_standard_suffix ( ) ) { break lab2 ; } } while ( false ) ; cursor = limit - v_3 ; cursor = limit_backward ; v_4 = cursor ; lab3 : do { if ( ! r_postlude ( ) ) { break lab3 ; } } while ( false ) ; cursor = v_4 ; return true ; }
tr	4	public ConsoleWindow ( ) { super ( "Totenfluch Rules!" ) ; setSize ( 1050 , 650 ) ; setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; setResizable ( false ) ; setLayout ( new FlowLayout ( ) ) ; setLayout ( new BorderLayout ( ) ) ; JLabel background = new JLabel ( ResourceLoader . Iconload ( "/demmatrix.gif" ) ) ; background . setSize ( 300 , 250 ) ; add ( background ) ; background . setLayout ( new FlowLayout ( ) ) ; Label1 = new JLabel ( "Welcome to the Main Programm!" ) ; Label1 . setForeground ( Color . white ) ; background . add ( Label1 ) ; if ( Main . DevBuild == false ) { TextArea1 = new JTextArea ( "Welcome! \n\n" , 30 , 80 ) ; } else { TextArea1 = new JTextArea ( "Welcome! \nYou are using a DEV Build\n" , 30 , 80 ) ; } background . add ( TextArea1 ) ; background . add ( new JScrollPane ( TextArea1 ) ) ; TextArea1 . setEditable ( false ) ; TextField2 = new JTextField ( "-> Type in here <-" , 50 ) ; background . add ( TextField2 ) ; TextArea1 . append ( OtherStuff . TheNormalTime ( ) + "[IRC] You are connected to the IRC\n" + OtherStuff . TheNormalTime ( ) + " Type /help for help\n" + OtherStuff . TheNormalTime ( ) + " Use /<command> for commands and <Text> to chat\n" ) ; thehandler handler = new thehandler ( ) ; TextField2 . addActionListener ( handler ) ; TextField2 . addMouseListener ( new MouseAdapter ( ) { @ Override public void mouseClicked ( MouseEvent e ) { TextField2 . setText ( "" ) ; } public void mouseEntered ( MouseEvent arg0 ) { String check = "-> Type in here <-" ; if ( String . valueOf ( TextField2 . getText ( ) ) . equals ( check ) ) { TextField2 . setText ( "" ) ; } } public void mouseExited ( MouseEvent arg0 ) { String check = "" ; if ( String . valueOf ( TextField2 . getText ( ) ) . equals ( check ) ) { TextField2 . setText ( "-> Type in here <-" ) ; } } } ) ; TextField2 . addKeyListener ( new KeyListener ( ) { @ Override public void keyPressed ( KeyEvent arg0 ) { } @ Override public void keyReleased ( KeyEvent arg0 ) { } @ Override public void keyTyped ( KeyEvent arg0 ) { String check = "-> Type in here <-" ; if ( String . valueOf ( TextField2 . getText ( ) ) . equals ( check ) ) { TextField2 . setText ( "" ) ; } } } ) ; }
tr	4	private int getLineY ( String text , int lineNumber ) { if ( text . length ( ) == 0 ) return 0 ; int pos = 0 ; try { for ( int i = 1 ; i < lineNumber ; i ++ ) { int eol = text . indexOf ( lineSeparator , pos ) ; if ( eol == - 1 ) { Rectangle bounds = textPane . modelToView ( pos ) ; return bounds . y + bounds . height ; } pos = eol + lineSeparator . length ( ) ; } return textPane . modelToView ( pos ) . y ; } catch ( Exception ex ) { throw new ErrorException ( "Internal error: " + ex ) ; } }
tr	3	private void processNewXXXVector ( Element xml ) { String device = xml . getAttribute ( "device" ) . trim ( ) ; if ( device . length ( ) == 0 ) { return ; } String property = xml . getAttribute ( "name" ) . trim ( ) ; if ( property . length ( ) == 0 ) { return ; } if ( this . listensToProperty ( device , property ) ) { server . notifyClientListenersNewXXXVector ( this , xml ) ; } }
tr	5	@ Override public void moveDown ( ) { if ( ! checkMove ( ) ) { return ; } score -- ; final GameControllerEvent event = createEvent ( DOWN_MOVE ) ; final Cell before = map . findRobot ( ) ; if ( before . y > 1 ) { final Cell after = before . down ( ) ; final AbstractElement e = map . get ( after ) ; if ( isNavigable ( e ) ) { if ( e . getSymbol ( ) == Lambda . SYMBOL ) { collectLambda ( after ) ; } performMove ( before , after , event ) ; } else if ( e . getSymbol ( ) == OpenLift . SYMBOL ) { win ( ) ; map . set ( before , EmptyCell . SYMBOL ) ; event . addChange ( before ) ; notifyListeners ( event ) ; return ; } } endRound ( event ) ; }
tr	0	private static void simpleTest ( ) { List < Rule > rules = RuleFactory . create ( "1 /2 -" ) ; List < double > values = new ArrayList < double > ( ) ; values . add ( 0.5 ) ; values . add ( 0.2 ) ; values . add ( 1000. ) ; System . out . println ( RuleCompiler . compile ( rules , values ) ) ; }
tr	2	public void simulateOneStep ( ) { step ++ ; startSickness ( startKans ) ; List < Actor > newActors = new ArrayList < Actor > ( ) ; for ( Iterator < Actor > it = actors . iterator ( ) ; it . hasNext ( ) ; ) { Actor actor = it . next ( ) ; actor . act ( newActors ) ; if ( ! actor . isActive ( ) ) { it . remove ( ) ; } } actors . addAll ( newActors ) ; statusUpdate ( ) ; }
tr	9	private void intensity_stereo ( int gr ) { final ChannelInformation ci = channelInfo [ gr ] [ 1 ] ; int scf , idx , sfb ; if ( channelInfo [ gr ] [ 0 ] . mixed_block_flag != ci . mixed_block_flag || channelInfo [ gr ] [ 0 ] . block_type != ci . block_type ) return ; if ( isMPEG1 ) { if ( ci . block_type == 2 ) { int w3 ; for ( w3 = 0 ; w3 < 3 ; w3 ++ ) { sfb = rzeroBandShort [ w3 ] ; for ( ; sfb < 12 ; sfb ++ ) { idx = 3 * sfbIndexShort [ sfb ] + w3 ; scf = scalefacShort [ 1 ] [ 3 * sfb + w3 ] ; if ( scf >= 7 ) continue ; is_lines_1 ( scf , idx , widthShort [ sfb ] , 3 , gr ) ; } } } else { for ( sfb = rzeroBandLong ; sfb <= 21 ; sfb ++ ) { scf = scalefacLong [ 1 ] [ sfb ] ; if ( scf < 7 ) is_lines_1 ( scf , sfbIndexLong [ sfb ] , widthLong [ sfb ] , 1 , gr ) ; } } } else { int tab2 = ci . scalefac_compress & 1 ; if ( ci . block_type == 2 ) { int w3 ; for ( w3 = 0 ; w3 < 3 ; w3 ++ ) { sfb = rzeroBandShort [ w3 ] ; for ( ; sfb < 12 ; sfb ++ ) { idx = 3 * sfbIndexShort [ sfb ] + w3 ; scf = scalefacShort [ 1 ] [ 3 * sfb + w3 ] ; is_lines_2 ( tab2 , scf , idx , widthShort [ sfb ] , 3 , gr ) ; } } } else { for ( sfb = rzeroBandLong ; sfb <= 21 ; sfb ++ ) is_lines_2 ( tab2 , scalefacLong [ 1 ] [ sfb ] , sfbIndexLong [ sfb ] , widthLong [ sfb ] , 1 , gr ) ; } } }
tr	4	@ SuppressWarnings ( "rawtypes" ) public JSONObject ( String baseName , Locale locale ) throws JSONException { this ( ) ; ResourceBundle bundle = ResourceBundle . getBundle ( baseName , locale , Thread . currentThread ( ) . getContextClassLoader ( ) ) ; Enumeration keys = bundle . getKeys ( ) ; while ( keys . hasMoreElements ( ) ) { Object key = keys . nextElement ( ) ; if ( key instanceof String ) { String [ ] path = ( ( String ) key ) . split ( "\\." ) ; int last = path . length - 1 ; JSONObject target = this ; for ( int i = 0 ; i < last ; i += 1 ) { String segment = path [ i ] ; JSONObject nextTarget = target . optJSONObject ( segment ) ; if ( nextTarget == null ) { nextTarget = new JSONObject ( ) ; target . put ( segment , nextTarget ) ; } target = nextTarget ; } target . put ( path [ last ] , bundle . getString ( ( String ) key ) ) ; } } }
tr	5	private static boolean includeNode ( IEclipsePreferences node ) { if ( node == null ) return false ; String nodeName = node . absolutePath ( ) ; String [ ] nodeParts = nodeName . split ( "/" , 5 ) ; if ( nodeParts . length < 2 ) return false ; if ( nodeParts . length == 2 ) if ( nodeParts [ 1 ] . compareTo ( "instance" ) == 0 || nodeParts [ 1 ] . compareTo ( "" ) == 0 ) return false ; return true ; }
tr	1	private static byte [ ] generateHeapColor ( int lastElement , int index1 , int index2 ) { byte [ ] result = new byte [ lastElement ] ; for ( int i = 0 ; i < result . length ; i ++ ) { result [ i ] = Colors . BAR_DEFAULT ; } result [ index1 ] = Colors . BAR_COMPARE ; result [ index2 ] = Colors . BAR_COMPARE ; return result ; }
tr	2	@ Override public void setFloat ( long i , float value ) { if ( ptr != 0 ) { Utilities . UNSAFE . putShort ( ptr + sizeof * i , ( short ) value ) ; } else { if ( isConstant ( ) ) { throw new IllegalAccessError ( "Constant arrays cannot be modified." ) ; } data [ ( int ) i ] = ( short ) value ; } }
tr	3	@ Override public void doAction ( Player player , Grid grid ) throws InvalidActionException { if ( player . getRemainingTurns ( ) <= 0 ) throw new InvalidActionException ( "The player has no turns left!" ) ; Position currentPos = player . getPosition ( ) ; Position newPos = new Position ( currentPos . getxCoordinate ( ) + 1 , currentPos . getyCoordinate ( ) + 1 ) ; if ( ! canMoveToPosition ( player , grid , newPos ) || ! canMoveDiagonal ( grid , newPos ) ) throw new InvalidActionException ( "The player can't move to the desired position!" ) ; player . setPosition ( newPos ) ; player . getLightTrail ( ) . addPosition ( currentPos ) ; player . decrementTurn ( ) ; }
tr	3	public void setProxyActive ( boolean proxyActive ) throws Exception { this . proxyActive = proxyActive ; if ( proxyActive ) { if ( proxyAddress == null || proxyPort == null ) throw new Exception ( "Proxy settings are not ok!" ) ; System . setProperty ( "http.proxySet" , "true" ) ; System . setProperty ( "http.proxyHost" , proxyAddress ) ; System . setProperty ( "http.proxyPort" , proxyPort ) ; System . setProperty ( "https.proxySet" , "true" ) ; System . setProperty ( "https.proxyHost" , proxyAddress ) ; System . setProperty ( "https.proxyPort" , proxyPort ) ; } else { System . setProperty ( "http.proxySet" , "false" ) ; System . setProperty ( "http.proxyHost" , "" ) ; System . setProperty ( "http.proxyPort" , "" ) ; System . setProperty ( "https.proxySet" , "false" ) ; System . setProperty ( "https.proxyHost" , "" ) ; System . setProperty ( "https.proxyPort" , "" ) ; } }
tr	0	static public IconCache zam56 ( HttpCache hc ) { return new IconCache ( hc , 56 , 1 , "http://wow.zamimg.com/images/wow/icons/large/$.jpg|dir=56" ) ; }
tr	6	protected void resolveUnclaimedPoints ( FaceList newFaces ) { Vertex vtxNext = unclaimed . first ( ) ; for ( Vertex vtx = vtxNext ; vtx != null ; vtx = vtxNext ) { vtxNext = vtx . next ; double maxDist = tolerance ; Face maxFace = null ; for ( Face newFace = newFaces . first ( ) ; newFace != null ; newFace = newFace . next ) { if ( newFace . mark == Face . VISIBLE ) { double dist = newFace . distanceToPlane ( vtx . pnt ) ; if ( dist > maxDist ) { maxDist = dist ; maxFace = newFace ; } if ( maxDist > 1000 * tolerance ) { break ; } } } if ( maxFace != null ) { addPointToFace ( vtx , maxFace ) ; } else { } } }
tr	7	@ Override public void run ( ) { ThreadObjects = new java . util . ArrayList < Variant > ( initialRunSize ) ; for ( int i = 0 ; i < initialRunSize ; i ++ ) { Variant aNewVariant = new Variant ( getName ( ) + "_" + i ) ; ThreadObjects . add ( aNewVariant ) ; } while ( ThreadObjects . size ( ) > 1 ) { String message = "" ; message = getName ( ) + " Workingset=" + ThreadObjects . size ( ) + " ROT: " ; message += "(before additions and gc " + ROT . getThreadObjects ( false ) . size ( ) + ")" ; if ( ThreadObjects . size ( ) > 2 && ThreadObjects . size ( ) % 2 != 0 ) { Variant aNewVariant = new Variant ( getName ( ) + "_*" + ThreadObjects . size ( ) ) ; ThreadObjects . add ( aNewVariant ) ; } for ( int i = ThreadObjects . size ( ) ; i > 0 ; i -- ) { if ( i % 2 == 0 ) { ThreadObjects . remove ( i - 1 ) ; } } try { Thread . sleep ( 9 ) ; } catch ( InterruptedException e ) { } message += " (before gc  after additions " + ROT . getThreadObjects ( false ) . size ( ) + ")" ; System . gc ( ) ; message += " (after System.gc " + ROT . getThreadObjects ( false ) . size ( ) + ")" ; System . out . println ( message ) ; } }
tr	5	public ArrayList < long > getProblemCorrect ( long questId , long submissionId ) { PreparedStatement statement = null ; ResultSet rs = null ; Connection connection = null ; ArrayList < long > questList = null ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Obtendo problemas corretos do questionario a partir da submiss\u00E3o: " + submissionId + "..." ) ; } try { if ( logger . isDebugEnabled ( ) ) { logger . debug ( SELECT_QUEST_PROBLEMS ) ; } connection = Connector . getConnection ( ) ; statement = connection . prepareStatement ( SELECT_QUEST_PROBLEMS ) ; statement . setLong ( 1 , questId ) ; statement . setLong ( 2 , submissionId ) ; rs = statement . executeQuery ( ) ; while ( rs . next ( ) ) { if ( questList == null ) { questList = new ArrayList < long > ( ) ; } questList . add ( rs . getLong ( "correct_problem_id" ) ) ; } } catch ( SQLException e ) { logger . error ( e . getMessage ( ) , e ) ; } finally { ResourcesUtil . release ( rs , statement , connection ) ; } return questList ; }
tr	8	private AffineTransform tryHarder ( Vector a , Vector c , double tlX , double tlY , double initialDelta , int position ) { double delta = initialDelta ; while ( true ) { AffineTransform f = null ; switch ( position ) { case 0 : f = new AffineTransform ( a . getX ( ) + delta , a . getY ( ) , - c . getX ( ) , - c . getY ( ) , tlX , tlY ) ; break ; case 1 : f = new AffineTransform ( a . getX ( ) , a . getY ( ) + delta , - c . getX ( ) , - c . getY ( ) , tlX , tlY ) ; break ; case 2 : f = new AffineTransform ( a . getX ( ) - delta , a . getY ( ) , - c . getX ( ) , - c . getY ( ) , tlX , tlY ) ; break ; case 3 : f = new AffineTransform ( a . getX ( ) , a . getY ( ) - delta , - c . getX ( ) , - c . getY ( ) , tlX , tlY ) ; break ; } try { f . invert ( ) ; return f ; } catch ( NoninvertibleTransformException e ) { System . out . println ( "unable to invert with delta: " + delta ) ; } delta *= 2 ; if ( delta > 1 ) { if ( position == 3 ) { return null ; } else { return tryHarder ( a , c , tlX , tlY , initialDelta , position + 1 ) ; } } } }
tr	8	@ Override protected void handleAttribute ( XMLStreamReader parser , int i ) { if ( parser . getAttributeLocalName ( i ) == "Font" ) { fontType = Font . decode ( parser . getAttributeValue ( i ) ) ; return ; } if ( parser . getAttributeLocalName ( i ) == "FontColor" ) { fontColor = setColorKeepAlpha ( fontColor , Color . decode ( parser . getAttributeValue ( i ) ) ) ; return ; } if ( parser . getAttributeLocalName ( i ) == "FontAlpha" ) { fontColor = setAlphaKeepColor ( fontColor , Integer . decode ( parser . getAttributeValue ( i ) ) ) ; return ; } if ( parser . getAttributeLocalName ( i ) == "Opac" ) { opac = true ; return ; } if ( parser . getAttributeLocalName ( i ) == "BackgroundColor" ) { backgroundColor = setColorKeepAlpha ( backgroundColor , Color . decode ( parser . getAttributeValue ( i ) ) ) ; return ; } if ( parser . getAttributeLocalName ( i ) == "BackgroundAlpha" ) { backgroundColor = setAlphaKeepColor ( backgroundColor , Integer . decode ( parser . getAttributeValue ( i ) ) ) ; return ; } if ( parser . getAttributeLocalName ( i ) == "TextX" ) { TextX = Integer . decode ( parser . getAttributeValue ( i ) ) ; return ; } if ( parser . getAttributeLocalName ( i ) == "TextY" ) { TextY = Integer . decode ( parser . getAttributeValue ( i ) ) ; return ; } super . handleAttribute ( parser , i ) ; }
tr	3	private JSONWriter end ( char mode , char c ) throws JSONException { if ( this . mode != mode ) { throw new JSONException ( mode == a ? "Misplaced endArray." : "Misplaced endObject." ) ; } this . pop ( mode ) ; try { this . writer . write ( c ) ; } catch ( IOException e ) { throw new JSONException ( e ) ; } this . , = true ; return this ; }
tr	0	@ Override public String getVarName ( ) { return this . name ; }
tr	0	public void setY ( float y ) { this . y = y ; }
tr	3	private byte [ ] fillEightByte ( byte [ ] rawByte ) { int rawByteLength = rawByte . length ; int byteamount = rawByteLength / 8 ; if ( rawByteLength % 8 != 0 ) { byteamount = byteamount + 1 ; } byte [ ] rawbytebyeightbyte = new byte [ byteamount * 8 ] ; for ( int i = 0 ; i < rawbytebyeightbyte . length ; i ++ ) { if ( i + 1 > rawByteLength ) { rawbytebyeightbyte [ i ] = Integer . decode ( "0x00" ) . byteValue ( ) ; } else { rawbytebyeightbyte [ i ] = rawByte [ i ] ; } } return rawbytebyeightbyte ; }
tr	7	private boolean fulfills ( Car car , Step3UserRequest userRequest3 ) { if ( userRequest3 . getMinyearOfProduction ( ) != null && car . getYearOfProduction ( ) < userRequest3 . getMinyearOfProduction ( ) ) return false ; if ( userRequest3 . getMaxyearOfProduction ( ) != null && car . getYearOfProduction ( ) > userRequest3 . getMaxyearOfProduction ( ) ) return false ; if ( userRequest3 . getFeatures ( ) != null ) { for ( CarFeature feature : userRequest3 . getFeatures ( ) ) { if ( ! car . getFeatures ( ) . contains ( feature ) ) return false ; } } return true ; }
tr	1	public void edit ( Frame frame ) { if ( frame . getKeyDuration ( ) < 0 ) { Animation parent = ( Animation ) frame . getParent ( ) ; frame . setKeyDuration ( parent . getDefaultKeyDuration ( ) * multiplier ) ; } frame . setKeyDuration ( frame . getKeyDuration ( ) * multiplier ) ; }
tr	5	@ Override public int hashCode ( ) { int result = gitPath != null ? gitPath . hashCode ( ) : 0 ; result = 31 * result + ( folder != null ? folder . hashCode ( ) : 0 ) ; result = 31 * result + ( filePath != null ? filePath . hashCode ( ) : 0 ) ; result = 31 * result + ( revision != null ? revision . hashCode ( ) : 0 ) ; result = 31 * result + ( charset != null ? charset . hashCode ( ) : 0 ) ; return result ; }
tr	8	static int entrance ( List < Point > points , int k ) { int size = points . size ( ) ; Map < String , Integer > indexHash = new HashMap < > ( ) ; Map < String , Point > pointHash = new HashMap < > ( ) ; for ( int i = 0 ; i < size ; ++ i ) { Point p = points . get ( i ) ; indexHash . put ( p . x + " " + p . y , i ) ; pointHash . put ( p . x + " " + p . y , p ) ; } for ( int i = size - 1 ; i >= 0 ; -- i ) { Point from = points . get ( i ) ; int max = 0 ; Set < Point > rangePoints = rangePonints ( from , k , pointHash ) ; for ( Point p : rangePoints ) { Integer index = indexHash . get ( p . x + " " + p . y ) ; if ( index != null && index > i && p . maxPathValue > max ) { max = p . maxPathValue ; } } from . maxPathValue = max + from . value ; if ( from . x == 0 && from . y == 0 ) return from . maxPathValue ; } return - 1 ; }
tr	4	private static State atLeast ( String x , int n , Collection < State > initials , boolean zeros ) { State s = new State ( ) ; if ( x . length ( ) == n ) s . setAccept ( true ) ; else { if ( zeros ) initials . add ( s ) ; char c = x . charAt ( n ) ; s . addTransition ( new Transition ( c , atLeast ( x , n + 1 , initials , zeros && c == 0 ) ) ) ; if ( c < 9 ) s . addTransition ( new Transition ( ( char ) ( c + 1 ) , 9 , anyOfRightLength ( x , n + 1 ) ) ) ; } return s ; }
tr	3	public JSONArray toJSONArray ( JSONArray names ) throws JSONException { if ( names == null || names . length ( ) == 0 ) { return null ; } JSONArray ja = new JSONArray ( ) ; for ( int i = 0 ; i < names . length ( ) ; i += 1 ) { ja . put ( this . opt ( names . getString ( i ) ) ) ; } return ja ; }
tr	2	public void prepareForStartingAttempt ( ) { ArrayList < FieldElement > startingElements = getElements ( "arcanoid.model.Ball" ) ; int width = ( int ) startingElements . get ( 0 ) . size ( ) . width ( ) ; int startPos = startingElements . get ( 0 ) . position ( ) . x + width / 2 ; int yPos = startingElements . get ( 0 ) . position ( ) . y ; for ( int i = 1 ; i < startingElements . size ( ) ; i ++ ) { if ( i < 3 ) { startingElements . get ( i ) . setPosition ( new Point ( startPos - i * 20 - width * i , yPos ) ) ; } else { startingElements . get ( i ) . setPosition ( new Point ( startPos + ( i - 2 ) * 20 + width * ( i - 2 ) , yPos ) ) ; } } }
tr	9	public static GregorianCalendar lireDate ( String date ) { boolean ok = false ; String [ ] champsDate ; int jour = 1 ; int mois = 0 ; int an = 0 ; GregorianCalendar dateSaisie = null ; champsDate = date . split ( "/" ) ; ok = true ; if ( champsDate . length >= 1 ) { try { mois = Integer . parseInt ( champsDate [ 0 ] ) ; if ( ( mois < 1 ) || ( mois > 12 ) ) { ok = false ; } } catch ( Exception e ) { ok = false ; } } else { mois = moisCourant ( ) ; } if ( champsDate . length == 2 ) { try { an = Integer . parseInt ( champsDate [ 1 ] ) ; if ( ( an < 1900 ) || ( an > 2100 ) ) { ok = false ; } } catch ( Exception e ) { ok = false ; } } else { an = anneeCourante ( ) ; } if ( ok ) { dateSaisie = new GregorianCalendar ( an , mois - 1 , jour ) ; return dateSaisie ; } else { return null ; } }
tr	9	@ Override public void actionPerformed ( ActionEvent e ) { if ( e . getSource ( ) == buttonAddDye ) { if ( ! ( textFDyeName . getText ( ) . isEmpty ( ) || textFDyePrice . getText ( ) . isEmpty ( ) ) ) { DyeParent newDye ; if ( radioDye . isSelected ( ) ) { newDye = new Dye ( textFDyeName . getText ( ) , double . parseDouble ( textFDyePrice . getText ( ) ) , null , 0 ) ; } else if ( radioMetal . isSelected ( ) ) { newDye = new Metal ( textFDyeName . getText ( ) , double . parseDouble ( textFDyePrice . getText ( ) ) , null , 0 ) ; } else if ( radioLakk . isSelected ( ) ) { newDye = new Lakk ( textFDyeName . getText ( ) , double . parseDouble ( textFDyePrice . getText ( ) ) , null , 0 ) ; } else newDye = new Fluo ( textFDyeName . getText ( ) , double . parseDouble ( textFDyePrice . getText ( ) ) , null , 0 ) ; mainGui . getComboDyeType ( ) . addItem ( newDye ) ; table . addNotify ( ) ; textFDyeName . setText ( "" ) ; textFDyePrice . setText ( "" ) ; mainGui . getComboDyeType ( ) . setSelectedIndex ( 0 ) ; PPCDB . refreshDyeParents ( PPC . calcObj . getAllDyeTypes ( ) ) ; } else { if ( textFDyeName . getText ( ) . isEmpty ( ) ) { flashMyField ( textFDyeName , Color . RED , 200 ) ; } if ( textFDyePrice . getText ( ) . isEmpty ( ) ) { flashMyField ( textFDyePrice , Color . RED , 200 ) ; } } } else if ( e . getSource ( ) == buttonDelDye ) { int index = table . getSelectedRow ( ) ; if ( index >= 0 && index < table . getRowCount ( ) && PPC . calcObj . getAllDyeTypes ( ) . size ( ) > 1 ) { PPC . calcObj . removeDye ( index ) ; table . addNotify ( ) ; mainGui . getComboDyeType ( ) . setSelectedIndex ( 0 ) ; PPCDB . refreshDyeParents ( PPC . calcObj . getAllDyeTypes ( ) ) ; } } else if ( e . getSource ( ) == buttonSortDyes ) { PPC . calcObj . sortDyes ( ) ; model . fireTableDataChanged ( ) ; PPCDB . refreshDyeParents ( PPC . calcObj . getAllDyeTypes ( ) ) ; } }
tr	0	private void restartGame ( ) { gameChooser . changeGameState ( GameState . INITIALIZING ) ; changedGame = gameChooser ; }
tr	6	protected void recurseFields ( final DataFrame frame , final String token , final List < DataField > results ) { if ( frame != null ) { for ( int x = 0 ; x < frame . getFieldCount ( ) ; x ++ ) { final DataField field = frame . getField ( x ) ; String fname = field . getName ( ) ; if ( fname == null ) { fname = "field" + x ; } if ( token != null ) { fname = token + "." + fname ; } if ( field . isFrame ( ) ) { recurseFields ( ( DataFrame ) field . getObjectValue ( ) , fname , results ) ; } else { if ( filter . matches ( fname ) ) { results . add ( field ) ; } } } } }
tr	9	public String checkDataEntry ( ) { if ( lhc_analysis_panel3 . lhcParamFileChosen . getText ( ) . equals ( "Selected Directory: " ) ) { return "Error on Parameter Data Entry. Make sure all the boxes have been completed" ; } else if ( lhc_analysis_panel3 . measures . getText ( ) . equals ( "" ) || lhc_analysis_panel3 . measureScale . getText ( ) . equals ( "" ) || lhc_analysis_panel3 . numberOfRunsPerParameterSet . getText ( ) . equals ( "" ) || lhc_analysis_panel3 . mediansFileName . getText ( ) . equals ( "" ) || lhc_analysis_panel3 . lhcSummaryFileName . getText ( ) . equals ( "" ) || lhc_analysis_panel3 . lhcCoEffsFileName . getText ( ) . equals ( "" ) ) { return "Error on Parameter Data Entry. Make sure all the boxes have been completed" ; } else if ( ! lhc_analysis_panel3 . mediansFileFormat . getText ( ) . equals ( "csv" ) && ! lhc_analysis_panel3 . mediansFileFormat . getText ( ) . equals ( "xml" ) ) { return "Result file format must be xml or csv" ; } else { try { int numRuns = Integer . parseInt ( lhc_analysis_panel3 . numberOfRunsPerParameterSet . getText ( ) ) ; if ( numRuns < 0 ) { return "Number of runs must be positive" ; } else { return null ; } } catch ( NumberFormatException e ) { return "Make sure the number of runs is an integer" ; } } }
tr	9	@ Override public synchronized void run ( ) { if ( ! fileCreated && progressFile . exists ( ) ) { fileCreated = true ; } if ( fileCreated && ! progressFile . exists ( ) ) { logger . info ( "Cancelling timer because progress file no longer exists." ) ; timer . cancel ( ) ; return ; } @ SuppressWarnings ( "rawtypes" ) List lines ; try { lines = FileUtils . readLines ( progressFile ) ; } catch ( IOException e1 ) { logger . trace ( "Error trying to generate config from ffmpeg progress file. Maybe file is being written at the same time as this check?" ) ; return ; } if ( lines . size ( ) < 2 || ! getLineParts ( lines , lines . size ( ) - 1 ) [ 0 ] . equals ( "progress" ) ) { return ; } if ( getLineParts ( lines , lines . size ( ) - 1 ) [ 1 ] . equals ( "end" ) ) { logger . info ( "Cancelling timer because ffmpeg finished." ) ; timer . cancel ( ) ; } double frame = - 1 ; boolean foundFrame = false ; for ( int i = lines . size ( ) - 2 ; i >= 0 ; i -- ) { String [ ] parts = getLineParts ( lines , i ) ; if ( parts [ 0 ] . equals ( "progress" ) ) { break ; } if ( parts [ 0 ] . equals ( "frame" ) ) { frame = double . parseDouble ( parts [ 1 ] ) ; foundFrame = true ; } } if ( ! foundFrame ) { throw ( new RuntimeException ( "Ffmpeg did not write frame attribute in progress file." ) ) ; } if ( currentFrame == frame ) { return ; } currentFrame = frame ; if ( callback != null ) { callback . run ( ) ; } }
tr	4	public int solve ( int index , boolean [ ] config , boolean [ ] bestConfig , int bestPrice ) { if ( index == weights . length ) { int price = priceOfConfig ( config ) ; if ( price > bestPrice ) { bestPrice = price ; copyConfig ( config , bestConfig ) ; } return bestPrice ; } else { config [ index ] = false ; int price1 = solve ( index + 1 , config , bestConfig , bestPrice ) ; if ( price1 > bestPrice ) { bestPrice = price1 ; } config [ index ] = true ; int price2 = solve ( index + 1 , config , bestConfig , bestPrice ) ; if ( price2 > bestPrice ) { bestPrice = price2 ; } return bestPrice ; } }
tr	8	public void process ( ) { output = new StringBuffer ( ) ; InputReader in = new InputReader ( getClass ( ) . getResourceAsStream ( "/balexp.txt" ) ) ; Stack < Character > stack = new Stack < Character > ( ) ; String infix = in . readLine ( ) ; for ( int i = 0 ; i < infix . length ( ) ; i ++ ) { char ch = infix . charAt ( i ) ; switch ( ch ) { case + : case - : getOper ( stack , ch , getPriority ( ch ) ) ; break ; case / : case * : getOper ( stack , ch , getPriority ( ch ) ) ; break ; case ( : stack . push ( ch ) ; break ; case ) : gotParen ( stack ) ; break ; default : output . append ( ch ) ; } } while ( ! stack . isEmpty ( ) ) { output . append ( stack . pop ( ) ) ; } }
tr	8	public void execute ( Connection conn ) { try { PreparedStatement s = conn . prepareStatement ( query ) ; if ( params != null ) { for ( ISetter setter : params ) { s = setter . set ( s ) ; } } for ( PreparedStatementExecutionItem ei : executionItems ) s = ei . addToBatch ( s ) ; if ( query . toLowerCase ( ) . startsWith ( "select" ) ) { resultSet = s . executeQuery ( ) ; } else { if ( executionItems . isEmpty ( ) ) s . execute ( ) ; else s . executeBatch ( ) ; s . close ( ) ; } } catch ( SQLException e ) { System . err . println ( "===> Batch start" ) ; this . print ( ) ; for ( PreparedStatementExecutionItem ei : this . executionItems ) ei . print ( ) ; System . err . println ( "===> Batch end" ) ; e . printStackTrace ( ) ; } for ( PreparedStatementExecutionItem ei : executionItems ) ei . wasExecuted = true ; wasExecuted = true ; }
tr	3	public Map ( boolean [ ] [ ] map_data , boolean free_value ) { this . data = new int [ map_data . length ] [ map_data [ 0 ] . length ] ; for ( int i = 0 ; i < map_data . length ; i ++ ) { for ( int j = 0 ; j < map_data [ 0 ] . length ; j ++ ) this . data [ i ] [ j ] = map_data [ i ] [ j ] == free_value ? this . FREE : this . OCCUPIED ; } initial_point = new int [ 2 ] ; goal_point = new int [ 2 ] ; }
tr	9	private Location whereToGo ( Location current , int m , int n ) { status [ current . r ] [ current . c ] = 1 ; if ( current . direction == Location . RIGHT ) { if ( current . c + 1 < n && status [ current . r ] [ current . c + 1 ] == 0 ) { return new Location ( current . r , current . c + 1 , current . direction ) ; } else { current . direction = Location . DOWN ; } } if ( current . direction == Location . DOWN ) { if ( current . r + 1 < m && status [ current . r + 1 ] [ current . c ] == 0 ) { return new Location ( current . r + 1 , current . c , current . direction ) ; } else { current . direction = Location . LEFT ; } } if ( current . direction == Location . LEFT ) { if ( current . c - 1 >= 0 && status [ current . r ] [ current . c - 1 ] == 0 ) { return new Location ( current . r , current . c - 1 , current . direction ) ; } else { current . direction = Location . UP ; } } if ( current . direction == Location . UP ) { if ( current . r - 1 >= 0 && status [ current . r - 1 ] [ current . c ] == 0 ) { return new Location ( current . r - 1 , current . c , current . direction ) ; } else { current . direction = Location . RIGHT ; } } if ( current . direction == Location . RIGHT ) { if ( current . c + 1 < n && status [ current . r ] [ current . c + 1 ] == 0 ) { return new Location ( current . r , current . c + 1 , Location . RIGHT ) ; } } return new Location ( - 1 , - 1 , Location . STOP ) ; }
tr	8	public static void release ( Object ... releasables ) { for ( Object obj : releasables ) { if ( obj != null ) { try { if ( obj instanceof ServerSocket ) { ( ( ServerSocket ) obj ) . close ( ) ; } else if ( obj instanceof Socket ) { ( ( Socket ) obj ) . close ( ) ; } else if ( obj instanceof Process ) { ( ( Process ) obj ) . destroy ( ) ; } else if ( obj instanceof Closeable ) { ( ( Closeable ) obj ) . close ( ) ; } else { throw new IllegalArgumentException ( "This method does not not how to release objects of type " + obj . getClass ( ) ) ; } } catch ( IOException ex ) { } catch ( RuntimeException ex ) { } } } }
tr	1	public static INDITextProperty createSaveableTextProperty ( INDIDriver driver , String name , String label , String group , PropertyStates state , PropertyPermissions permission ) throws IllegalArgumentException { INDITextProperty tp = loadTextProperty ( driver , name ) ; if ( tp == null ) { tp = new INDITextProperty ( driver , name , label , group , state , permission ) ; tp . setSaveable ( true ) ; } return tp ; }
tr	7	private void showSaveDialog ( ) { String saveFilepath = ZettaUtil . pathComponent ( LevelEditor . editor . currentFilepath ) ; JFileChooser fc = new JFileChooser ( saveFilepath ) ; fc . setFileFilter ( new FileFilter ( ) { @ Override public boolean accept ( File f ) { if ( f . isDirectory ( ) ) { return true ; } String extension = ZettaUtil . getExtension ( f ) ; return extension != null && extension . equals ( STAGE_DATA_FILE_EXTENSION ) ; } @ Override public String getDescription ( ) { return "Stage Data Files" ; } } ) ; int returnVal = fc . showSaveDialog ( LevelEditor . editor ) ; if ( returnVal == JFileChooser . APPROVE_OPTION ) { try { File f = fc . getSelectedFile ( ) ; if ( ! ZettaUtil . getExtension ( f ) . equals ( STAGE_DATA_FILE_EXTENSION ) ) { f = new File ( f . getAbsolutePath ( ) + "." + STAGE_DATA_FILE_EXTENSION ) ; } if ( f . exists ( ) ) { int i = JOptionPane . showConfirmDialog ( this , "Are you sure you want to overwrite?" , "Save As" , JOptionPane . YES_NO_OPTION ) ; if ( i != JOptionPane . OK_OPTION ) { return ; } } this . saveData ( f ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } }
tr	1	private void jButton4ActionPerformed ( java . awt . event . ActionEvent evt ) { ReporteEncuestas r = new ReporteEncuestas ( ) ; try { r . mostrarReporte ( ) ; } catch ( Exception e ) { JOptionPane . showMessageDialog ( null , "Ocurrio un error.. " + e . getMessage ( ) ) ; } }
tr	8	@ SuppressWarnings ( "unchecked" ) @ Override public void insert ( int key , V newValue , int height ) { SkipNode < V > [ ] update = new SkipNode [ maxLevel ] ; SkipNode < V > node = root ; for ( int i = ( level - 1 ) ; i >= 0 ; i -- ) { while ( node . getForward ( i ) . getKey ( ) < key ) { node = node . getForward ( i ) ; } update [ i ] = node ; } node = node . getForward ( 0 ) ; if ( node . getKey ( ) == key ) { if ( node . height == height ) { node . satteliteData = newValue ; } else { remove ( key ) ; insert ( key , newValue , height ) ; } } else { Integer newLevel = height ; if ( newLevel > level ) { for ( int i = level ; i < newLevel ; i ++ ) { update [ i ] = root ; } level = newLevel ; } node = new SkipNode < V > ( key , newLevel , newValue ) ; for ( int i = 0 ; i < newLevel ; i ++ ) { if ( update [ i ] . getForward ( i ) == null ) { node . getForward ( ) [ i ] = NIL ; } else { node . getForward ( ) [ i ] = update [ i ] . getForward ( i ) ; } update [ i ] . getForward ( ) [ i ] = node ; } } }
tr	6	public static Player fromXml ( org . w3c . dom . Node playerRoot , MonteCarloPlayer player ) { NamedNodeMap attrs = playerRoot . getAttributes ( ) ; player . description = "" ; if ( attrs . getNamedItem ( "playout" ) != null ) { try { Field field = PlayoutStrategy . class . getField ( attrs . getNamedItem ( "playout" ) . getNodeValue ( ) ) ; player . playout = ( PlayoutStrategy ) field . get ( null ) ; player . description += String . format ( "playout=%s" , field . getName ( ) ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } if ( attrs . getNamedItem ( "finalMove" ) != null ) { try { Field field = FinalNodeSelectionStrategy . class . getField ( attrs . getNamedItem ( "finalMove" ) . getNodeValue ( ) ) ; player . finalNode = ( FinalNodeSelectionStrategy ) field . get ( null ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } if ( attrs . getNamedItem ( "maxTurnTime" ) != null ) { try { player . MAX_TURN_TIME = long . parseLong ( attrs . getNamedItem ( "maxTurnTime" ) . getNodeValue ( ) ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } player . description = String . format ( "playout=%s final=%s" , player . playout , player . finalNode ) ; return player ; }
tr	2	public double windowQueryExt ( double [ ] lowk , double [ ] uppk , boolean printWindow , int optLevel ) { double [ ] lowEff = new double [ 2 ] ; double [ ] uppEff = new double [ 2 ] ; double [ ] spaceBound = GPSLib . getSpaceBound ( lowk , uppk ) ; lowEff [ 0 ] = spaceBound [ 0 ] ; uppEff [ 0 ] = spaceBound [ 1 ] ; lowEff [ 1 ] = spaceBound [ 2 ] ; uppEff [ 1 ] = spaceBound [ 3 ] ; Object [ ] objs = ( Object [ ] ) this . range ( lowEff , uppEff ) ; List < Temporal > points = new ArrayList < Temporal > ( ) ; for ( int i = 0 ; i < objs . length ; ++ i ) { points . add ( ( Temporal ) objs [ i ] ) ; } CoverageWindow wc = new CoverageWindow ( lowk , uppk , points ) ; if ( optLevel == 1 ) return wc . calcWindowOpt ( printWindow ) ; else return wc . calcWindow ( printWindow ) ; }
tr	8	@ Override public boolean execute ( final CommandSender sender , final String [ ] split ) { if ( sender instanceof Player ) { if ( MonsterIRC . getHandleManager ( ) . getPermissionsHandler ( ) != null ) { if ( ! MonsterIRC . getHandleManager ( ) . getPermissionsHandler ( ) . hasCommandPerms ( ( Player ) sender , this ) ) { sender . sendMessage ( "[IRC] You don't have permission to preform that command." ) ; return true ; } } else { sender . sendMessage ( "[IRC] PEX not detected  unable to run any IRC commands." ) ; return true ; } } if ( split . length < 3 ) { sender . sendMessage ( "[IRC] Please specify a channel to join!" ) ; return false ; } if ( split [ 2 ] == null ) { sender . sendMessage ( "[IRC] Please specify a channel to join!" ) ; return false ; } for ( final IRCChannel c : Variables . channels ) { if ( c . getChannel ( ) . equalsIgnoreCase ( split [ 2 ] ) ) { try { MonsterIRC . getHandleManager ( ) . getIRCHandler ( ) . join ( c ) ; } catch ( final IOException e ) { sender . sendMessage ( "Error joining the channel!" ) ; return true ; } sender . sendMessage ( "[IRC] Successfully joined the channel!" ) ; return true ; } } sender . sendMessage ( "[IRC] Could not join that channel!" ) ; return true ; }
tr	4	public static Armour createArmourFromReader ( String armourString ) { String [ ] values = armourString . split ( " " ) ; Armour armour = new Armour ( ) ; try { armour . setName ( values [ 0 ] ) ; armour . setCost ( Integer . parseInt ( values [ 1 ] ) ) ; armour . setWeight ( Integer . parseInt ( values [ 2 ] ) ) ; armour . setAC ( Integer . parseInt ( values [ 3 ] ) ) ; if ( values . length == 5 && values [ 4 ] != "" ) { String [ ] specials = values [ 4 ] . split ( " " ) ; armour = Armour . applySpecialTraits ( armour , specials ) ; } } catch ( Exception e ) { System . out . println ( "Error reading armour object" ) ; if ( armour . getName ( ) != null ) System . out . println ( armour . getName ( ) + " has some incorrect parameter." ) ; return null ; } return armour ; }
tr	1	private static String byteToHex ( byte b ) { String r = Integer . toHexString ( b ) ; if ( r . length ( ) == 8 ) { return r . substring ( 6 ) ; } return r ; }
tr	2	public synchronized void delete ( ) { if ( swigCPtr != 0 ) { if ( swigCMemOwn ) { swigCMemOwn = false ; otapiJNI . delete_Server ( swigCPtr ) ; } swigCPtr = 0 ; } super . delete ( ) ; }
tr	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( Advertences . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( Advertences . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( Advertences . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( Advertences . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { Dimension dim = Toolkit . getDefaultToolkit ( ) . getScreenSize ( ) ; int w = adv . getSize ( ) . width ; int h = adv . getSize ( ) . height ; int x = ( dim . width - w ) / 2 ; int y = ( dim . height - h ) / 2 ; adv . setLocation ( x , y ) ; adv . setVisible ( true ) ; } } ) ; }
tr	6	public Integer checkFields ( ) { if ( buttonGroup . getSelection ( ) == null ) { return null ; } else { final Enumeration < AbstractButton > elements = buttonGroup . getElements ( ) ; Integer num = null ; while ( elements . hasMoreElements ( ) ) { final JRadioButton button = ( JRadioButton ) elements . nextElement ( ) ; if ( button != null ) { if ( button . isSelected ( ) ) { num = Integer . parseInt ( button . getText ( ) . substring ( button . getText ( ) . lastIndexOf ( # ) + 1 ) ) ; } } } if ( num != null ) { if ( checkFields ( num ) ) { return num ; } else { JOptionPane . showMessageDialog ( null , "***ERROR***: Incorrect search options" ) ; } } } return null ; }
tr	9	@ Override public void positionChanged ( int newPosition ) { ScrolledNotesCanvas scrolledNotesCanvas = mainView . getScrolledNotesCanvas ( ) ; if ( playing && repeats . size ( ) == 2 ) { if ( newPosition < repeats . get ( 1 ) ) { scrolledNotesCanvas . scrollToPosition ( repeats . get ( 0 ) ) ; return ; } } Set < Note > notes = scrolledNotesCanvas . getNotesAtPosition ( newPosition ) ; Set < Pitch > pitches = new HashSet < Pitch > ( ) ; for ( Note note : notes ) { pitches . add ( note . getPitch ( ) ) ; } PianoCanvas pianoCanvas = mainView . getPianoCanvas ( ) ; pianoCanvas . setSelectedNotes ( notes ) ; final Set < Note > newNotes = new HashSet < Note > ( notes ) ; newNotes . removeAll ( oldNotes ) ; waitingNotes . setWaitingNotes ( newNotes ) ; waitingNotes . setAutoplayCallback ( new Runnable ( ) { public void run ( ) { try { for ( Note note : newNotes ) { if ( note . getTrack ( ) . isActive ( ) ) { if ( note . getTrack ( ) . isAutoplay ( ) ) { midiKeyboard . play ( note . getPitch ( ) , note . getVelocity ( ) , note . getDuration ( ) ) ; } } } } catch ( Exception e ) { e . printStackTrace ( ) ; } } } ) ; if ( anyActiveNonAutoplay ( ) ) { if ( waitingNotes . waiting ( ) ) { midiKeyboard . setGuideLightsFromNotes ( waitingNotes . getWaitingNotes ( ) ) ; } else { Set < Note > nextNotes = scrolledNotesCanvas . getNotesAfterPosition ( newPosition ) ; midiKeyboard . setGuideLightsFromNotes ( Controller . filterWaitable ( nextNotes ) ) ; } } else { midiKeyboard . setGuideLightsFromNotes ( getActiveNotes ( notes ) ) ; } oldNotes = notes ; ScoreCanvas scoreCanvas = mainView . getScoreCanvas ( ) ; scoreCanvas . positionChanged ( scrolledNotesCanvas . getTicksFromBeginning ( newPosition ) ) ; }
tr	9	private static Expression parseExpression ( ProgramNode program , Scanner s , CodeParser cp , PrefixProcessor p ) { if ( Parser . gobble ( "fuelLeft" , s ) ) return new SensorNode ( SensorType . FUELLEFT ) ; else if ( Parser . gobble ( "oppLR" , s ) ) return new SensorNode ( SensorType . OPPLR ) ; else if ( Parser . gobble ( "oppFB" , s ) ) return new SensorNode ( SensorType . OPPFB ) ; else if ( Parser . gobble ( "numBarrels" , s ) ) return new SensorNode ( SensorType . NUMBARRELS ) ; else if ( Parser . gobble ( "barrelLR" , s ) ) { SensorNode sensor = new SensorNode ( SensorType . BARRELLR ) ; if ( Parser . gobble ( Parser . OPENPAREN , s ) ) { sensor . setExpression ( parseExpression ( program , s , cp , p ) ) ; if ( ! Parser . gobble ( Parser . CLOSEPAREN , s ) ) Parser . fail ( "Missing closing parenthesis on barrelLR with args" , s ) ; } return sensor ; } else if ( Parser . gobble ( "barrelFB" , s ) ) { SensorNode sensor = new SensorNode ( SensorType . BARRELFB ) ; if ( Parser . gobble ( Parser . OPENPAREN , s ) ) { sensor . setExpression ( parseExpression ( program , s , cp , p ) ) ; if ( ! Parser . gobble ( Parser . CLOSEPAREN , s ) ) Parser . fail ( "Missing closing parenthesis on barrelFB with args" , s ) ; } return sensor ; } else if ( Parser . gobble ( "wallDist" , s ) ) return new SensorNode ( SensorType . WALLDIST ) ; else if ( s . hasNext ( variable ) ) return new VariableNode ( program , s . next ( variable ) ) ; else if ( s . hasNext ( Parser . NUMPAT ) ) return new NumberNode ( double . parseDouble ( s . next ( Parser . NUMPAT ) ) ) ; else return new OperationNode ( ) . parse ( s , cp , p ) ; }
tr	1	public double getAsDouble ( String key , double defaultValue ) { double value = getAsDouble ( key ) ; return value == null ? defaultValue : value ; }
tr	4	@ Override public boolean getPoint ( int mouseX , int mouseY ) { int newX = - 1 ; int newY = - 1 ; if ( mouseX < 800 ) { int cx = Boot . getPlayer ( ) . getX ( ) ; int cy = Boot . getPlayer ( ) . getY ( ) ; newX = cx + ( mouseX / Standards . TILE_SIZE ) - 12 ; newY = cy + ( ( Standards . W_HEIGHT - mouseY ) / Standards . TILE_SIZE ) - 12 ; } if ( newX != - 1 && newY != - 1 ) { if ( picks == 0 ) { this . posX = newX ; this . posY = newY ; picks = 1 ; } else { this . posX2 = newX ; this . posY2 = newY ; picks = 0 ; } } return true ; }
tr	0	@ Override public int getOutputsNum ( ) { return this . outputSynapses . size ( ) ; }
tr	1	public Object [ ] [ ] getEstacionesCercanas ( int CI ) throws ElementoNoEncontradoException { Object [ ] [ ] datos = new Object [ objEA . getEstacionesCercanas ( objUA . getUsuario ( CI ) ) . size ( ) ] [ 2 ] ; int cont = 0 ; for ( Estacion objE : objEA . getEstacionesCercanas ( objUA . getUsuario ( CI ) ) . values ( ) ) { datos [ cont ] [ 0 ] = objE . getNom ( ) ; datos [ cont ] [ 1 ] = objE . getCp ( ) ; cont ++ ; } return datos ; }
tr	0	@ Override public TileEntity getTileEntity ( Tile parent ) { return new TileDoorEntity ( parent ) ; }
tr	1	public void push ( T data , int stackNumber ) { int arrayStackNumber = stackNumber - 1 ; int currentIndex = arrayStackNumber * STACK_SIZE + stackPointer [ arrayStackNumber ] + 1 ; if ( currentIndex >= stackNumber * STACK_SIZE ) { throw new StackOverflowError ( ) ; } stacks [ currentIndex ] = data ; stackPointer [ arrayStackNumber ] ++ ; }
tr	3	private int compareTo ( Object tree1 , Object tree2 ) { if ( tree1 == tree2 ) return 0 ; else { int size1 = treeSize ( tree1 ) , size2 = treeSize ( tree2 ) ; if ( size1 < size2 ) return - 1 ; else if ( size1 > size2 ) return 1 ; else return compareTo ( tree1 , 0 , tree2 , 0 , 0 , size1 ) ; } }
tr	8	public static Object divide ( Object val0 , Object val1 ) { val0 = guess ( val0 ) ; val1 = guess ( val1 ) ; if ( val0 instanceof Color ) return ( ( Color ) val0 ) . divide ( val1 ) ; if ( val0 instanceof Size ) return ( ( Size ) val0 ) . divide ( val1 ) ; if ( val0 instanceof Number && val1 instanceof Number ) { if ( val0 instanceof double || val1 instanceof double ) return ( ( Number ) val0 ) . doubleValue ( ) / ( ( Number ) val1 ) . doubleValue ( ) ; return ( ( Number ) val0 ) . intValue ( ) / ( ( Number ) val1 ) . intValue ( ) ; } return ( val0 != null ? val0 : "" ) + "/" + ( val1 != null ? val1 : "" ) ; }
tr	9	private List < Student > getStudents ( final Mode inputMode , final List < Object > params ) { final List < Student > students = new Vector < Student > ( ) ; if ( isConnect ( ) ) { sendPackage ( new package ( inputMode , params ) ) ; Object obj ; while ( true ) { try { obj = ois . readObject ( ) ; } catch ( final IOException e ) { System . out . println ( "can't read" ) ; break ; } catch ( final ClassNotFoundException e ) { System . out . println ( "can't read" ) ; break ; } if ( obj != null ) { if ( isPackage ( obj ) ) { final package pack = ( package ) obj ; final Mode mode = pack . getMode ( ) ; switch ( mode ) { case SEARCH1 : receiveStudents ( students , pack ) ; return students ; case SEARCH2 : receiveStudents ( students , pack ) ; return students ; case SEARCH3 : receiveStudents ( students , pack ) ; return students ; case GET_CURR_PAGE : receiveStudents ( students , pack ) ; return students ; case GET_NEXT_PAGE : receiveStudents ( students , pack ) ; return students ; case GET_PREV_PAGE : receiveStudents ( students , pack ) ; return students ; default : System . out . println ( "default" ) ; break ; } System . out . println ( ) ; break ; } } } } return students ; }
tr	5	private AttributeStatistics generateStringStat ( double coverage , String ... values ) { Multiset < String > counts = HashMultiset . create ( ) ; int totalCount = values . length ; Collections . addAll ( counts , values ) ; int max = - 1 , min = totalCount + 1 ; List < String > maxCont = new ArrayList < > ( ) , minCont = new ArrayList < > ( ) ; for ( Multiset . Entry < String > ent : counts . entrySet ( ) ) { if ( ent . getCount ( ) > max ) { max = ent . getCount ( ) ; maxCont . clear ( ) ; maxCont . add ( ent . getElement ( ) ) ; } else if ( max == ent . getCount ( ) ) { maxCont . add ( ent . getElement ( ) ) ; } if ( ent . getCount ( ) < min ) { min = ent . getCount ( ) ; minCont . clear ( ) ; minCont . add ( ent . getElement ( ) ) ; } else if ( min == ent . getCount ( ) ) { minCont . add ( ent . getElement ( ) ) ; } } final double confidence = max * 1d / totalCount ; return new AttributeStatistics ( maxCont . toArray ( new String [ maxCont . size ( ) ] ) , confidence , coverage , counts . elementSet ( ) . size ( ) , minCont . toArray ( new String [ minCont . size ( ) ] ) ) ; }
tr	6	public static void main ( String [ ] args ) { int k = 0 ; try { k = Integer . parseInt ( args [ 0 ] ) ; } catch ( NumberFormatException e ) { System . out . println ( "Expected an argument with the number of elements to print." ) ; System . out . println ( "USAGE: Subset k - to print k values from the input." ) ; System . out . println ( "EXAMPLE: echo A B C D E F G H I | java Subset 3  => prints out 3 values from the input." ) ; } int n = 0 ; RandomizedQueue < String > rq = new RandomizedQueue < String > ( ) ; while ( ! StdIn . isEmpty ( ) ) { String s = StdIn . readString ( ) ; n ++ ; if ( rq . size ( ) == k ) { final double rnd = StdRandom . uniform ( 1 , n + 1 ) ; if ( rnd <= k ) { rq . dequeue ( ) ; rq . enqueue ( s ) ; } } else { rq . enqueue ( s ) ; } } for ( int i = 0 ; i < k && ! rq . isEmpty ( ) ; i ++ ) { System . out . println ( rq . dequeue ( ) ) ; } }
tr	6	protected void updateTable ( String name , Map < String , String > columns ) throws SQLException { PreparedStatement statement = null ; try { StringBuilder builder = new StringBuilder ( ) ; builder . append ( "CREATE TABLE IF NOT EXISTS ? (" ) ; for ( int i = 0 ; i < columns . size ( ) ; i ++ ) { builder . append ( "? ?" ) ; if ( i + 1 < columns . size ( ) ) { builder . append ( "  " ) ; } } builder . append ( ")" ) ; statement = getConnection ( ) . prepareStatement ( builder . toString ( ) ) ; statement . execute ( ) ; } catch ( SQLException e ) { throw e ; } catch ( DataLoadFailedException e ) { throw new SQLException ( e ) ; } finally { if ( statement != null ) { try { statement . close ( ) ; } catch ( SQLException e ) { } } } }
tr	6	public Tag findChildByName ( String name , boolean recursive ) { if ( tags != null ) { for ( Tag t : tags . values ( ) ) { if ( t . getName ( ) != null ) { if ( t . getName ( ) . equals ( name ) ) { return t ; } } if ( recursive ) { Tag result = t . findChildByName ( name , true ) ; if ( result != null ) { return result ; } } } } return null ; }
tr	1	@ Override public Set < Type > getConnectedTypes ( ) { Set < Type > t = new HashSet < Type > ( ) ; for ( Link l : links ) { t . addAll ( l . getDestinationNode ( ) . getConnectedTypes ( ) ) ; } return t ; }
tr	8	public void Update ( GameTime gameTime ) { mMenu . Update ( ) ; if ( ! mMenu . IsMenuItemSelected ( ) ) { mMenu . SelectMenuItem ( new Vector2 ( mInput . GetMouseX ( ) , GameProperties . WindowHeight ( ) - mInput . GetMouseY ( ) ) ) ; if ( mInput . IsMouseHit ( 0 ) ) { switch ( mMenu . GetSelected ( ) ) { case 0 : { UnLoad ( ) ; } break ; case 1 : { mMenu . MenuItemSelected ( ) ; } break ; case 2 : { mMenu . MenuItemSelected ( ) ; } break ; case 3 : { mMenu . MenuItemSelected ( ) ; } break ; case 4 : { try { int x = ( ( IntegerMenuItem ) mMenu . GetMenuItem ( 1 ) ) . GetIntValue ( ) ; int y = ( ( IntegerMenuItem ) mMenu . GetMenuItem ( 2 ) ) . GetIntValue ( ) ; boolean f = ( ( BooleanMenuItem ) mMenu . GetMenuItem ( 3 ) ) . GetBooleanValue ( ) ; GameProperties . HandleCommand ( "screen_width " + x ) ; GameProperties . HandleCommand ( "screen_height " + y ) ; GameProperties . HandleCommand ( "fullscreen " + f ) ; GameProperties . UpdateWindow ( ) ; } catch ( Exception e ) { } } break ; } } } }
tr	8	public Vector < Door > nearbyDoors ( Game game ) { Vector < Door > doors = new Vector < Door > ( ) ; for ( Tile tile : game . getMap ( ) . getTiles ( ) ) { if ( ! ( tile instanceof Door ) ) continue ; Door door = ( Door ) tile ; if ( door . getState ( ) == Door . OPEN ) continue ; Rectangle2D door_rect = door . getArea ( ) ; double left = door_rect . getX ( ) ; double right = left + door_rect . getWidth ( ) ; double top = door_rect . getY ( ) ; double bottom = top + door_rect . getHeight ( ) ; double x = fLocation . getX ( ) ; double y = fLocation . getY ( ) ; if ( x < left ) x = left ; if ( x > right ) x = right ; if ( y < top ) y = top ; if ( y > bottom ) y = bottom ; Point2D door_point = new Point2D . double ( x , y ) ; double distance = fLocation . distance ( door_point ) ; distance -= getSize ( ) ; if ( distance <= getReach ( ) ) doors . add ( door ) ; } return doors ; }
tr	4	public static void exec ( Node node ) { if ( node instanceof Comment ) { } else if ( node instanceof PrintBold ) { System . out . println ( "**" + ( ( PrintBold ) node ) . message + "**" ) ; } else if ( node instanceof Print ) { System . out . println ( ( ( Print ) node ) . message ) ; } else if ( node instanceof Block ) { exec ( ( ( Block ) node ) . first ) ; exec ( ( ( Block ) node ) . second ) ; } else { System . err . println ( "ERR: no match for node." ) ; System . exit ( 42 ) ; } }
tr	5	public Clip loadSound ( String fileName ) { Clip clip = null ; URL url ; url = frame . getClass ( ) . getResource ( fileName ) ; System . out . println ( url ) ; AudioInputStream audioIn = null ; try { audioIn = AudioSystem . getAudioInputStream ( url ) ; } catch ( UnsupportedAudioFileException e ) { System . out . println ( "Error: " + e ) ; e . printStackTrace ( ) ; } catch ( IOException e ) { System . out . println ( "Error: " + e ) ; e . printStackTrace ( ) ; } try { clip = AudioSystem . getClip ( ) ; } catch ( LineUnavailableException e ) { System . out . println ( "Error: " + e ) ; e . printStackTrace ( ) ; } try { clip . open ( audioIn ) ; } catch ( LineUnavailableException e ) { System . out . println ( "Error: " + e ) ; e . printStackTrace ( ) ; } catch ( IOException e ) { System . out . println ( "Error: " + e ) ; e . printStackTrace ( ) ; } return clip ; }
