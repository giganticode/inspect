tr	9	public static void onUserTreesChanged ( ) { userTrees = new UserTrees ( UserTrees . getUserTreesData ( ) ) ; if ( userTrees . getStatus ( ) == UserTrees . LOADED ) { switch ( currentUI ) { case NewTree : case TreeCreated : case Pearled : case InTunnel : case InSettings : return ; case TreeList : case ChooseParent : if ( TreeListUI . isClosing ) { return ; } break ; } } changeUI ( currentUI , true ) ; }
tr	7	public void radixSort ( int [ ] data ) { int max = data [ 0 ] , radix = 1 ; ; for ( int i = 0 ; i < data . length ; i ++ ) { if ( max < data [ i ] ) { max = data [ i ] ; } } Node [ ] bucket = new Node [ 10 ] ; for ( int i = 0 ; i < bucket . length ; i ++ ) { bucket [ i ] = new Node ( ) ; } while ( max / radix > 0 ) { for ( int i = 0 ; i < data . length ; i ++ ) { bucket [ ( data [ i ] / radix ) % 10 ] . list . add ( data [ i ] ) ; } int pos = 0 ; for ( int i = 0 ; i < bucket . length ; i ++ ) { for ( int j = 0 ; j < bucket [ i ] . list . size ( ) ; j ++ ) { data [ pos ++ ] = bucket [ i ] . list . get ( j ) ; } bucket [ i ] . list . clear ( ) ; } radix *= 10 ; } }
tr	1	public AccessToken getOAuthAccessToken ( String token , String tokenSecret , String oauth_verifier ) throws TBlogException { try { this . oauthToken = new OAuthToken ( token , tokenSecret ) { } ; this . oauthToken = new AccessToken ( httpRequest ( accessTokenURL , new PostParameter [ ] { new PostParameter ( "oauth_verifier" , oauth_verifier ) } , true ) ) ; } catch ( TBlogException te ) { throw new TBlogException ( "The user has not given access to the account." , te , te . getStatusCode ( ) ) ; } return ( AccessToken ) this . oauthToken ; }
tr	3	@ Test public void testCreateFeatureHolder ( ) { FunctionExecutor < void > executor = new FunctionExecutor < void > ( ) { @ Override public void invoke ( FunctionInvocation < void > invocation , Object ... arguments ) throws ExecutorInvocationException { return invocation . next ( arguments ) ; } } ; functionDefinition . addExecutor ( FeatureHolder . class , "default" , executor ) ; functionDefinition . setParameter ( 0 , String . class ) ; Function < void > function = functionDefinition . create ( new DefaultFeatureHolder ( ) ) ; List < class < ? >> expectedParameters = new ArrayList < class < ? >> ( ) ; expectedParameters . add ( String . class ) ; Set < FunctionExecutor < void >> expectedExecutors = new HashSet < FunctionExecutor < void >> ( ) ; expectedExecutors . add ( executor ) ; Set < FunctionExecutor < void >> actualExecutors = new HashSet < FunctionExecutor < void >> ( ) ; for ( FunctionExecutorContext < void > context : function . getExecutors ( ) ) { actualExecutors . add ( context . getExecutor ( ) ) ; } assert . assertEquals ( "Function object's parameters" , expectedParameters , function . getParameters ( ) ) ; assert . assertEquals ( "Function object's executors" , expectedExecutors , actualExecutors ) ; }
tr	6	static public String numberToString ( Number n ) throws JSONException { if ( n == null ) { throw new JSONException ( "Null pointer" ) ; } testValidity ( n ) ; String s = n . toString ( ) ; if ( s . indexOf ( . ) > 0 && s . indexOf ( e ) < 0 && s . indexOf ( E ) < 0 ) { while ( s . endsWith ( "0" ) ) { s = s . substring ( 0 , s . length ( ) - 1 ) ; } if ( s . endsWith ( "." ) ) { s = s . substring ( 0 , s . length ( ) - 1 ) ; } } return s ; }
tr	0	public Decision takeDecision ( PersonalEnvironment personalEnviroment , Habitat settlement ) { return getStrategy ( ) . takeDecision ( this , personalEnviroment , settlement ) ; }
tr	9	private void go ( String inputFile ) { double minx = double . POSITIVE_INFINITY , maxx = double . NEGATIVE_INFINITY , miny = double . POSITIVE_INFINITY , maxy = double . NEGATIVE_INFINITY ; int rowct = 0 , colct = 0 ; double rowspace = 0 , colspace = 0 ; boolean firstcorner = true ; boolean firstrow = true ; boolean firstdelta = true ; double eps = 1E-8 ; try { File f = new File ( inputFile ) ; FileReader fr = new FileReader ( f ) ; BufferedReader br = new BufferedReader ( fr ) ; String ln = br . readLine ( ) ; ln = br . readLine ( ) ; double prevX = double . NaN ; double prevY = double . NaN ; int ct = 0 ; while ( ln != null ) { StringTokenizer stk = new StringTokenizer ( ln ) ; double x = double . parseDouble ( stk . nextToken ( ) ) ; if ( x < minx ) { minx = x ; } if ( x > maxx ) { maxx = x ; } double y = double . parseDouble ( stk . nextToken ( ) ) ; if ( y < miny ) { miny = y ; } if ( y > maxy ) { maxy = y ; } if ( firstcorner ) { prevX = x ; prevY = y ; firstcorner = false ; ln = br . readLine ( ) ; ct ++ ; continue ; } if ( firstdelta ) { double dx = Math . abs ( x - prevX ) ; if ( dx < eps ) { br . close ( ) ; throw new IllegalArgumentException ( "Cell width cannot be 0" ) ; } colspace = dx ; prevX = x ; prevY = y ; firstdelta = false ; ln = br . readLine ( ) ; ct ++ ; continue ; } if ( firstrow ) { double dx = Math . abs ( x - prevX ) ; if ( dx - colspace > eps ) { br . close ( ) ; throw new IllegalArgumentException ( "Column spacing is not consistent." ) ; } double dy = Math . abs ( y - prevY ) ; if ( dy < eps ) { ct ++ ; prevX = x ; prevY = y ; ln = br . readLine ( ) ; continue ; } colct = ct ; ct = 0 ; prevX = x ; prevY = y ; firstrow = false ; ln = br . readLine ( ) ; continue ; } double dx = Math . abs ( x - prevX ) ; if ( dx - colspace > eps ) { br . close ( ) ; throw new IllegalArgumentException ( "Column spacing is not consistent." ) ; } ln = br . readLine ( ) ; } System . out . println ( "#rows: " + rowct ) ; System . out . println ( "#cols: " + colct ) ; System . out . println ( "rowspace: " + rowspace ) ; System . out . println ( "colspace: " + colspace ) ; System . out . println ( "minx " + minx ) ; System . out . println ( "maxx " + maxx ) ; System . out . println ( "miny " + miny ) ; System . out . println ( "maxy " + maxy ) ; br . close ( ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }
tr	3	@ Override public void insert ( T element ) { if ( size >= heap . length ) { heap = Arrays . copyOf ( heap , heap . length + INCREASING_FACTOR ) ; } else { int i = size ; while ( i > 0 && heap [ parent ( i ) ] . compareTo ( element ) < 0 ) { heap [ i ] = heap [ parent ( i ) ] ; i = parent ( i ) ; } heap [ i ] = element ; size ++ ; } }
tr	2	public List < Location > getFreeAdjacentLocations ( Location location ) { List < Location > free = new LinkedList < Location > ( ) ; List < Location > adjacent = adjacentLocations ( location ) ; for ( Location next : adjacent ) { if ( getObjectAt ( next ) == null ) { free . add ( next ) ; } } return free ; }
tr	3	public byte [ ] toBytes ( ) throws IOException { ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; ObjectOutput out = null ; try { out = new ObjectOutputStream ( bos ) ; out . writeObject ( this ) ; byte [ ] yourBytes = bos . toByteArray ( ) ; return yourBytes ; } finally { try { if ( out != null ) { out . close ( ) ; } } catch ( IOException ex ) { } try { bos . close ( ) ; } catch ( IOException ex ) { } } }
tr	5	public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; while ( true ) { System . out . println ( "Please enter 3 numbers" ) ; int first = sc . nextInt ( ) ; int second = sc . nextInt ( ) ; int third = sc . nextInt ( ) ; if ( first == 0 && second == 0 && third == 0 ) { break ; } if ( ( first + second + third ) % 3 == 0 ) { System . out . println ( "Yes" ) ; } else { System . out . println ( "No" ) ; } } }
tr	4	private void setEventLimitFlags ( ) { Settings_Event . EVENT_LIMIT_REACHED_LOW = ( Settings_Event . RUNNING_EVENTS_LOW >= Settings_Event . MAX_RUNNING_EVENTS_LOW ) ? true : false ; Settings_Event . EVENT_LIMIT_REACHED_MID = ( Settings_Event . RUNNING_EVENTS_MID >= Settings_Event . MAX_RUNNING_EVENTS_MID ) ? true : false ; Settings_Event . EVENT_LIMIT_REACHED_HIGH = ( Settings_Event . RUNNING_EVENTS_HIGH >= Settings_Event . MAX_RUNNING_EVENTS_HIGH ) ? true : false ; Settings_Event . EVENT_LIMIT_REACHED_ALL = ( Settings_Event . RUNNING_EVENTS_ALL >= Settings_Event . MAX_RUNNING_EVENTS_ALL ) ? true : false ; }
tr	4	public String getKeterangan ( ) { char idx = getIndex ( ) ; switch ( idx ) { case A : return "Sangat Baik" ; case B : return "Baik" ; case C : return "Cukup" ; case D : return "Kurang" ; default : return "Sangat Kurang" ; } }
tr	1	public void delete ( Users persistentInstance ) { log . debug ( "deleting " + entitySimpleName + " instance" ) ; try { super . delete ( persistentInstance ) ; log . debug ( entitySimpleName + " delete successful" ) ; } catch ( RuntimeException re ) { log . error ( entitySimpleName + " delete failed" , re ) ; throw re ; } }
tr	3	@ Override public String toString ( ) { String name = getName ( ) ; String append = "" ; if ( name != null && ! name . equals ( "" ) ) { append = "(\"" + this . getName ( ) + "\")" ; } StringBuilder bldr = new StringBuilder ( ) ; bldr . append ( "TAG_List" + append + ": " + value . size ( ) + " entries of type " + NBTUtils . getTypeName ( type ) + "\r\n{\r\n" ) ; for ( Tag t : value ) { bldr . append ( "   " + t . toString ( ) . replaceAll ( "\r\n" , "\r\n   " ) + "\r\n" ) ; } bldr . append ( "}" ) ; return bldr . toString ( ) ; }
tr	3	private String findTag ( String text , String startToken , String endToken , int fromIndex ) { int startIndex = text . indexOf ( startToken , fromIndex ) ; int endIndex = text . indexOf ( endToken , startIndex ) ; if ( startIndex >= 0 && endIndex > 0 && endIndex > startIndex ) return text . substring ( startIndex , endIndex + endToken . length ( ) ) ; return null ; }
tr	0	public void addConversation ( Conversation c ) { conversations . add ( c ) ; }
tr	0	public int getEvaluationDetail ( ) { return evaluationDetail ; }
tr	7	protected String [ ] [ ] create_matrix ( String plain ) { ArrayList < String > s = new ArrayList < String > ( ) ; boolean dig ; if ( di_begin ) { dig = true ; } else { dig = false ; } int string_index = 0 ; int plain_size = plain . length ( ) ; while ( string_index < plain_size ) { if ( dig ) { if ( string_index == plain_size - 1 ) { s . add ( plain . substring ( string_index , string_index + 1 ) ) ; string_index ++ ; } else { s . add ( plain . substring ( string_index , string_index + 2 ) ) ; string_index += 2 ; } dig = false ; } else { s . add ( plain . substring ( string_index , string_index + 1 ) ) ; string_index ++ ; dig = true ; } } int col = period ; int row = s . size ( ) / col ; if ( s . size ( ) % col != 0 ) { row ++ ; } String [ ] [ ] matrix = new String [ row ] [ col ] ; int s_index = 0 ; int cur_row = 0 ; int cur_col = 0 ; while ( s_index < s . size ( ) ) { matrix [ cur_row ] [ cur_col ] = s . get ( s_index ) ; s_index ++ ; if ( cur_col < period - 1 ) { cur_col ++ ; } else { cur_row ++ ; cur_col = 0 ; } } return matrix ; }
tr	9	public static void main ( String [ ] args ) { long [ ] lastRow = new long [ 1 ] ; lastRow [ 0 ] = 1 ; for ( int i = 1 ; i <= SIZE ; i ++ ) { if ( i % 1000 == 0 ) System . out . println ( i ) ; long [ ] nextRow = new long [ i + 1 ] ; nextRow [ 0 ] = 1 ; nextRow [ nextRow . length - 1 ] = 1 ; for ( int j = 1 ; j < lastRow . length ; j ++ ) nextRow [ j ] = ( lastRow [ j - 1 ] + lastRow [ j ] ) % 1000000000000 ; lastRow = nextRow ; } int count = 0 ; long [ ] currentRow = new long [ 1 ] ; currentRow [ 0 ] = 1 ; for ( int i = 1 ; i < lastRow . length ; i ++ ) { if ( i % 1000 == 0 ) System . out . println ( i ) ; long [ ] nextRow = new long [ i + 1 ] ; nextRow [ 0 ] = 1 ; nextRow [ nextRow . length - 1 ] = 1 ; for ( int j = 1 ; j < currentRow . length ; j ++ ) nextRow [ j ] = ( currentRow [ j - 1 ] + currentRow [ j ] ) % 1000000000000 ; currentRow = nextRow ; long multiplier = lastRow [ i - 1 ] ; int initialTwos = numTwos ( multiplier ) ; int initialFives = numFives ( multiplier ) ; for ( int j = 0 ; j < nextRow . length ; j ++ ) { int twos = numTwos ( nextRow [ j ] ) ; int fives = numFives ( nextRow [ j ] ) ; if ( initialTwos + twos >= 12 && initialFives + fives >= 12 ) count ++ ; } } System . out . print ( count ) ; }
tr	1	@ Override public void Eliminar ( ) throws SQLException { try { Conexion . GetInstancia ( ) . Conectar ( ) ; Conexion . GetInstancia ( ) . Ejecutar ( "DELETE FROM Cliente WHERE CedRuc_Cliente =" + ObCliente . getCedRuc_Persona ( ) ) ; } catch ( SQLException ex ) { throw ex ; } finally { Conexion . GetInstancia ( ) . Desconectar ( ) ; } }
tr	2	@ Override public boolean exists ( T persistable ) { return persistable == null || persistable . isNew ( ) ? false : exists ( persistable . getPK ( ) ) ; }
tr	8	public static void main ( String [ ] a ) { System . out . println ( "is Diag([1 1] [1 1])=" + isDiag ( new int [ ] { 1 , 1 } , new int [ ] { 1 , 1 } ) ) ; System . out . println ( "is Diag([1 2] [2 1])=" + isDiag ( new int [ ] { 1 , 2 } , new int [ ] { 2 , 1 } ) ) ; System . out . println ( "is Diag([2 4] [4 2])=" + isDiag ( new int [ ] { 2 , 4 } , new int [ ] { 4 , 2 } ) ) ; System . out . println ( "is Diag([3 4] [4 5])=" + isDiag ( new int [ ] { 3 , 4 } , new int [ ] { 4 , 5 } ) ) ; System . out . println ( "is Diag([3 4] [5 6])=" + isDiag ( new int [ ] { 3 , 4 } , new int [ ] { 5 , 6 } ) ) ; System . out . println ( "is Diag([3 4] [6 8])=" + isDiag ( new int [ ] { 3 , 4 } , new int [ ] { 6 , 8 } ) ) ; System . out . println ( "is Diag([3 4] [1 3])=" + isDiag ( new int [ ] { 3 , 4 } , new int [ ] { 1 , 3 } ) ) ; System . out . println ( "-----------------------" ) ; System . out . println ( "is attackable([1 1] [1 6])=" + attackable ( new int [ ] { 1 , 1 } , new int [ ] { 1 , 6 } ) ) ; System . out . println ( "is attackable([4 2] [4 1])=" + attackable ( new int [ ] { 4 , 2 } , new int [ ] { 4 , 1 } ) ) ; System . out . println ( "is attackable([2 4] [4 2])=" + attackable ( new int [ ] { 2 , 4 } , new int [ ] { 4 , 2 } ) ) ; System . out . println ( "is attackable([3 4] [4 5])=" + attackable ( new int [ ] { 3 , 4 } , new int [ ] { 4 , 5 } ) ) ; System . out . println ( "is attackable([3 4] [5 6])=" + attackable ( new int [ ] { 3 , 4 } , new int [ ] { 5 , 6 } ) ) ; System . out . println ( "is attackable([3 4] [6 8])=" + attackable ( new int [ ] { 3 , 4 } , new int [ ] { 6 , 8 } ) ) ; System . out . println ( "is attackable([3 4] [1 3])=" + attackable ( new int [ ] { 3 , 4 } , new int [ ] { 1 , 3 } ) ) ; System . out . println ( "-----------------------" ) ; List < Integer [ ] > queens = new ArrayList < Integer [ ] > ( 8 ) ; int [ ] rows = new int [ max ] ; int [ ] cols = new int [ max ] ; for ( int i = 0 ; i < max ; i ++ ) { rows [ i ] = i + 1 ; cols [ i ] = i + 1 ; } int row = 1 ; int col = 1 + rand . nextInt ( max ) ; System . out . println ( "Start with new queen " + row + " " + col ) ; queens . add ( new Integer [ ] { row , col } ) ; rows [ row - 1 ] = 0 ; cols [ col - 1 ] = 0 ; for ( int i = 0 ; i < max - 1 ; i ++ ) { boolean found = false ; row ++ ; while ( ! found ) { do { col = 1 + rand . nextInt ( max ) ; } while ( cols [ col - 1 ] == 0 ) ; int [ ] queen = new int [ ] { row , col } ; found = true ; for ( Integer [ ] q : queens ) { int [ ] position = new int [ ] { q [ 0 ] , q [ 1 ] } ; if ( attackable ( position , queen ) ) { found = false ; break ; } } if ( found ) { queens . add ( new Integer [ ] { row , col } ) ; rows [ row - 1 ] = 0 ; cols [ col - 1 ] = 0 ; } } } for ( Integer [ ] q : queens ) { System . out . println ( "Found queen at position " + q [ 0 ] + " " + q [ 1 ] ) ; } }
tr	0	public synchronized Site getSite ( Vect position ) { return getSite ( position . getX ( ) , position . getY ( ) , position . getZ ( ) ) ; }
tr	9	@ SuppressWarnings ( "deprecation" ) @ Override public void run ( ) { while ( areAnyThreadsAlive ( threadGroup ) ) { if ( ! firstExceptionThrown . isEmpty ( ) ) { for ( Thread t : getThreads ( threadGroup ) ) { if ( t . isAlive ( ) ) t . stop ( ) ; } } else if ( areAnyThreadsRunning ( threadGroup ) ) { if ( System . currentTimeMillis ( ) - lastProgress > 1000 * maxRunTime ) timeout ( ) ; } else if ( clock . isAnyThreadWaitingForABeat ( ) ) { clock . advance ( ) ; deadlockCount = 0 ; lastProgress = System . currentTimeMillis ( ) ; } else if ( ! areAnyThreadsInTimedWaiting ( threadGroup ) ) { detectDeadlock ( ) ; } try { Thread . sleep ( clockPeriod ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } }
tr	4	public static String readAsString ( File file ) { final long length = file . length ( ) ; final byte [ ] bytes = new byte [ ( int ) length ] ; InputStream is = null ; try { is = new FileInputStream ( file ) ; is . read ( bytes ) ; } catch ( IOException e ) { } finally { try { if ( is != null ) { is . close ( ) ; } } catch ( IOException ex ) { return null ; } } try { return new String ( bytes , "UTF-8" ) ; } catch ( UnsupportedEncodingException e ) { return null ; } }
tr	9	public static String translateImpl ( String string , String oldCharsequence , String newCharsequence ) { if ( string == null || oldCharsequence == null || oldCharsequence . length ( ) == 0 ) { return string ; } char [ ] stringChars = string . toCharArray ( ) ; char [ ] oldChars = oldCharsequence . toCharArray ( ) ; char [ ] newChars = ( newCharsequence != null ? newCharsequence : "" ) . toCharArray ( ) ; if ( newChars . length < oldChars . length ) { newChars = Arrays . copyOf ( newChars , oldChars . length ) ; } final StringBuilder result = new StringBuilder ( ) ; char copy ; for ( int i = 0 ; i < stringChars . length ; i ++ ) { copy = stringChars [ i ] ; for ( int j = 0 ; j < oldChars . length ; j ++ ) { if ( copy == oldChars [ j ] ) { if ( newCharsequence != null ) { copy = newChars [ j ] ; } else { copy =  ; } break ; } } if (  != copy ) { result . append ( copy ) ; } } return result . toString ( ) ; }
tr	9	private boolean r_exception1 ( ) { int among_var ; bra = cursor ; among_var = find_among ( a_10 , 18 ) ; if ( among_var == 0 ) { return false ; } ket = cursor ; if ( cursor < limit ) { return false ; } switch ( among_var ) { case 0 : return false ; case 1 : slice_from ( "ski" ) ; break ; case 2 : slice_from ( "sky" ) ; break ; case 3 : slice_from ( "die" ) ; break ; case 4 : slice_from ( "lie" ) ; break ; case 5 : slice_from ( "tie" ) ; break ; case 6 : slice_from ( "idl" ) ; break ; case 7 : slice_from ( "gentl" ) ; break ; case 8 : slice_from ( "ugli" ) ; break ; case 9 : slice_from ( "earli" ) ; break ; case 10 : slice_from ( "onli" ) ; break ; case 11 : slice_from ( "singl" ) ; break ; } return true ; }
tr	9	public void Run ( ) { try { this . heartBeatThread . start ( ) ; ArrayList < KeyValuePair < Key1 , Value1 >> inputList = new ArrayList < KeyValuePair < Key1 , Value1 >> ( ) ; for ( String path : localInputPaths ) { FileInputStream fis = new FileInputStream ( path ) ; ObjectInputStream ois = new ObjectInputStream ( fis ) ; ArrayList < KeyValuePair < Key1 , Value1 >> subList = ( ArrayList < KeyValuePair < Key1 , Value1 >> ) ois . readObject ( ) ; ois . close ( ) ; inputList . addAll ( subList ) ; } Collections . sort ( inputList ) ; Reducer < Key1 , Value1 , Key2 , Value2 > r = reducerClass . newInstance ( ) ; Logger . log ( outputLocalPath ) ; Context < Key2 , Value2 > context = new Context < Key2 , Value2 > ( outputLocalPath ) ; Key1 previousKey = null ; ArrayList < Value1 > valueList = null ; for ( KeyValuePair < Key1 , Value1 > p : inputList ) { if ( previousKey == null || ! previousKey . equals ( p . key ) ) { if ( valueList != null ) r . reduce ( previousKey , valueList , context ) ; valueList = new ArrayList < Value1 > ( ) ; valueList . add ( p . value ) ; previousKey = p . key ; } else valueList . add ( p . value ) ; } if ( valueList != null && previousKey != null ) r . reduce ( previousKey , valueList , context ) ; context . dumpToFile ( ) ; this . % = 100 ; } catch ( InstantiationException | IllegalAccessException e ) { Logger . log ( e . getMessage ( ) ) ; e . printStackTrace ( ) ; } catch ( Exception ex ) { Logger . log ( "2" + ex . getMessage ( ) ) ; } }
tr	7	private void handleMessage ( String message ) { JSONObject data = ( JSONObject ) JSONValue . parse ( message ) ; String action = ( String ) data . get ( Messages . type ) ; if ( action . equals ( Messages . switchWhiteboard ) ) { newCanvas ( ) ; SwitchWhiteboardMessage m = SwitchWhiteboardMessage . static . fromJSON ( data ) ; model . whiteboard = new Whiteboard ( m . whiteboardID , model ) ; frame . setTitle ( "Now connected to: " + m . whiteboardID ) ; return ; } else if ( action . equals ( Messages . whiteboardCreated ) ) { newCanvas ( ) ; WhiteboardCreatedMessage m = WhiteboardCreatedMessage . static . fromJSON ( data ) ; model . whiteboard = new Whiteboard ( m . whiteboardID , model ) ; frame . setTitle ( "Now connected to: " + m . whiteboardID ) ; return ; } else if ( model . whiteboard != null ) { if ( action . equals ( Messages . currentUsers ) ) { UserListMessage m = UserListMessage . static . fromJSON ( data ) ; if ( m . whiteboardID . equals ( model . whiteboard . whiteboardID ) ) { setCurrentUsers ( m . getUsers ( ) ) ; } } else if ( action . equals ( Messages . fromServerStroke ) ) { FromServerStrokeMessage m = FromServerStrokeMessage . static . fromJSON ( data ) ; if ( m . whiteboardID . equals ( model . whiteboard . whiteboardID ) ) { model . whiteboard . addDrawableFromServer ( m . id , m . drawable ) ; } } } frame . repaint ( ) ; }
tr	1	public EdRGUI ( LibroMayor libroMayor ) { initComponents ( ) ; eDR = new EstadoDeResultados ( libroMayor , "SYSTEMCOM S.A.S." ) ; if ( libroMayor . isClose ( ) ) { eDR . ejecutar ( ) ; estadoArea . setText ( eDR . toSting ( ) ) ; } else { estadoArea . setText ( "DEBE CERRAR PRIMERO EL LIBRO PARA VER EL ESTADO DE RESULTADOS" ) ; } }
tr	3	@ Override public int hashCode ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + ( ( declaration == null ) ? 0 : declaration . hashCode ( ) ) ; result = prime * result + ( ( ident == null ) ? 0 : ident . hashCode ( ) ) ; result = prime * result + ( ( statementSequence == null ) ? 0 : statementSequence . hashCode ( ) ) ; return result ; }
tr	0	public String getProvincia ( ) { return provincia ; }
tr	7	@ Override public void afterPhase ( PhaseEvent event ) { FacesContext facesContext = event . getFacesContext ( ) ; String currentPage = facesContext . getViewRoot ( ) . getViewId ( ) ; HttpSession session = ( HttpSession ) facesContext . getExternalContext ( ) . getSession ( true ) ; Integer idCidadeSessao = ( Integer ) session . getAttribute ( "idCidade" ) ; ExternalContext externalContext = facesContext . getExternalContext ( ) ; String idCidadeURL = externalContext . getRequestParameterMap ( ) . get ( "idCidade" ) ; System . out . println ( "P\u00E1gina: " + currentPage ) ; System . out . println ( "AUTENTICA SESSAO!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!" ) ; System . out . println ( "ID DA CIDADE PELA URAL = " + idCidadeURL ) ; if ( idCidadeURL == null ) { if ( idCidadeSessao == null ) { NavigationHandler nh = facesContext . getApplication ( ) . getNavigationHandler ( ) ; nh . handleNavigation ( facesContext , null , "semsessao.xhtml" ) ; } } else { CidadesEnum cidade = CidadesEnum . getValue ( Integer . parseInt ( idCidadeURL ) ) ; if ( cidade == null ) { NavigationHandler nh = facesContext . getApplication ( ) . getNavigationHandler ( ) ; nh . handleNavigation ( facesContext , null , "semsessao.xhtml" ) ; } else { session . setAttribute ( "idCidade" , cidade . getCodigo ( ) ) ; } } boolean isLoginPage = ( currentPage . lastIndexOf ( "login.xhtml" ) > - 1 ) ; boolean isSemSessao = ( currentPage . lastIndexOf ( "semsessao.xhtml" ) > - 1 ) ; Object idCidade = session . getAttribute ( "idCidade" ) ; Object isLogado = session . getAttribute ( "isLogado" ) ; if ( ! isLoginPage && ! isSemSessao && idCidade == null && isLogado == null ) { String errorPageLocation = "/pages/public/semsessao.xhtml?faces-redirect=true" ; facesContext . setViewRoot ( facesContext . getApplication ( ) . getViewHandler ( ) . createView ( facesContext , errorPageLocation ) ) ; facesContext . getPartialViewContext ( ) . setRenderAll ( true ) ; facesContext . renderResponse ( ) ; } }
tr	0	public static byte [ ] getValues ( ) { byte [ ] values = { ENCODED_VOICE , RAW_BINARY_DATA , APPLICATION_SPECIFIC_DATA , DATABASE_INDEX } ; return values ; }
tr	5	private static boolean KawigiEdit_RunTest ( int testNum , String p0 , int p1 , int p2 , boolean hasAnswer , int p3 ) { System . out . print ( "Test " + testNum + ": [" + "\"" + p0 + "\"" + " " + p1 + " " + p2 ) ; System . out . println ( "]" ) ; OneDimensionalRobotEasy obj ; int answer ; obj = new OneDimensionalRobotEasy ( ) ; long startTime = System . currentTimeMillis ( ) ; answer = obj . finalPosition ( p0 , p1 , p2 ) ; long endTime = System . currentTimeMillis ( ) ; boolean res ; res = true ; System . out . println ( "Time: " + ( endTime - startTime ) / 1000.0 + " seconds" ) ; if ( hasAnswer ) { System . out . println ( "Desired answer:" ) ; System . out . println ( "\t" + p3 ) ; } System . out . println ( "Your answer:" ) ; System . out . println ( "\t" + answer ) ; if ( hasAnswer ) { res = answer == p3 ; } if ( ! res ) { System . out . println ( "DOESN'T MATCH!!!!" ) ; } else if ( ( endTime - startTime ) / 1000.0 >= 2 ) { System . out . println ( "FAIL the timeout" ) ; res = false ; } else if ( hasAnswer ) { System . out . println ( "Match :-)" ) ; } else { System . out . println ( "OK  but is it right?" ) ; } System . out . println ( "" ) ; return res ; }
tr	7	public void mouseClicked ( MouseEvent e ) { if ( e . getClickCount ( ) == 2 ) { if ( reportPanel == instructorReportPanel ) { Object selected = instructorReportPanel . getSelected ( ) ; if ( selected != null ) { if ( selected instanceof Instructor ) { Instructor i = ( Instructor ) selected ; middleLeftPanel . remove ( reportPanel ) ; middleRightPanel . remove ( detailsPanel ) ; instructorPanel = new InstructorPanel ( i ) ; detailsPanel = instructorPanel ; middleLeftPanel . add ( reportPanel ) ; constraints . weightx = 0.4 ; constraints . weighty = 0.6 ; constraints . gridx = 1 ; constraints . gridy = 0 ; detailsPanel . setBorder ( BorderFactory . createLineBorder ( Color . black ) ) ; middleRightPanel . add ( detailsPanel , BorderLayout . CENTER ) ; middleLeftPanel . revalidate ( ) ; middleRightPanel . revalidate ( ) ; repaint ( ) ; } else if ( selected instanceof Course ) { Course c = ( Course ) selected ; middleLeftPanel . remove ( reportPanel ) ; middleRightPanel . remove ( detailsPanel ) ; coursePanel = new CoursePanel ( c ) ; detailsPanel = coursePanel ; middleLeftPanel . add ( reportPanel ) ; constraints . weightx = 0.4 ; constraints . weighty = 0.6 ; constraints . gridx = 1 ; constraints . gridy = 0 ; detailsPanel . setBorder ( BorderFactory . createLineBorder ( Color . black ) ) ; middleRightPanel . add ( detailsPanel , BorderLayout . CENTER ) ; middleLeftPanel . revalidate ( ) ; middleRightPanel . revalidate ( ) ; repaint ( ) ; } } } else if ( reportPanel == courseReportPanel ) { Course selected = courseReportPanel . getCourse ( ) ; if ( selected != null ) { middleLeftPanel . remove ( reportPanel ) ; middleRightPanel . remove ( detailsPanel ) ; coursePanel = new CoursePanel ( selected ) ; detailsPanel = coursePanel ; middleLeftPanel . add ( reportPanel ) ; constraints . weightx = 0.4 ; constraints . weighty = 0.6 ; constraints . gridx = 1 ; constraints . gridy = 0 ; detailsPanel . setBorder ( BorderFactory . createLineBorder ( Color . black ) ) ; middleRightPanel . add ( detailsPanel , BorderLayout . CENTER ) ; middleLeftPanel . revalidate ( ) ; middleRightPanel . revalidate ( ) ; repaint ( ) ; } } } }
tr	8	public void run ( ) { while ( ! mServerDisconnected ) { ArrayList < NetworkMessage > messages = GetMessages ( mUnsanitizedMessages ) ; for ( int i = 0 ; i < messages . size ( ) ; i ++ ) { NetworkMessage current = messages . get ( i ) ; current . Sanatize ( ) ; String message = current . GetMessage ( ) ; StringTokenizer st = new StringTokenizer ( message ) ; try { int id = Integer . parseInt ( st . nextToken ( ) ) ; ConnectedClient client = GetClient ( id ) ; if ( client != null ) { client . MessageRecieved ( ) ; } String command = st . nextToken ( ) ; if ( command . equalsIgnoreCase ( "ping" ) ) { client . PingRecieved ( ) ; } else if ( command . equalsIgnoreCase ( "connect" ) ) { if ( client == null ) { System . out . println ( "someone connected" ) ; ConnectedClient newClient = new ConnectedClient ( GetNextID ( ) , current . GetAddress ( ) , current . GetPort ( ) ) ; mClients . add ( newClient ) ; } } else { throw new Exception ( ) ; } } catch ( Exception e ) { AddMessage ( message , current . GetAddress ( ) , current . GetPort ( ) , mMessages ) ; } } try { Thread . sleep ( 10 ) ; } catch ( Exception e ) { } } }
tr	2	private static void allSubsetsOfSizeK ( List < String > items , int k , int startIndex , List < String > currentSubset , List < String > resultHolder ) { if ( currentSubset . size ( ) == k ) { resultHolder . add ( StringUtils . join ( currentSubset , " " ) ) ; return ; } for ( int i = startIndex ; i < items . size ( ) ; i ++ ) { currentSubset . add ( items . get ( i ) ) ; allSubsetsOfSizeK ( items , k , i + 1 , currentSubset , resultHolder ) ; currentSubset . remove ( currentSubset . size ( ) - 1 ) ; } }
tr	5	public Location findFood ( Location location ) { Field field = getField ( ) ; List < Location > adjacent = field . adjacentLocations ( getLocation ( ) ) ; Iterator < Location > it = adjacent . iterator ( ) ; while ( it . hasNext ( ) ) { Location where = it . next ( ) ; Object animal = field . getObjectAt ( where ) ; if ( animal instanceof Rabbit ) { Rabbit rabbit = ( Rabbit ) animal ; if ( rabbit . isActive ( ) ) { rabbit . setDead ( ) ; foodLevel = foodValue ; return where ; } } else if ( animal instanceof Fox ) { Fox fox = ( Fox ) animal ; if ( fox . isActive ( ) ) { fox . setDead ( ) ; foodLevel = foodValue ; return where ; } } } return null ; }
tr	3	private void insertNode ( Node node , LinkedList < Node > list ) { if ( list . isEmpty ( ) ) { list . add ( node ) ; return ; } ListIterator < Node > iter = list . listIterator ( ) ; while ( iter . hasNext ( ) ) { Node next = iter . next ( ) ; if ( next . cumulativeCost >= node . cumulativeCost ) { iter . previous ( ) ; iter . add ( node ) ; return ; } } list . addLast ( node ) ; }
tr	8	public List < HackResult > grok ( Reader reader ) throws IOException { long t0 = System . currentTimeMillis ( ) ; _HackContainer o = new _HackContainer ( ) ; Type t = new TypeToken < _HackContainer > ( ) { } . getType ( ) ; o = GSON . fromJson ( reader , t ) ; if ( o == null ) throw new IOException ( "GSON returned null!" ) ; L . info ( "Claimed size=" + o . total_rows ) ; if ( o . total_rows == 0 ) throw new IOException ( "GSON did not find objects!" ) ; List < HackResult > res = new ArrayList < HackResult > ( o . total_rows ) ; int total = 0 ; int count = 0 ; int canGetUltraCount = 0 ; for ( _HackRow r : o . rows ) { ++ count ; HackResult h = r . doc ; h . sourceLine = count ; if ( h . resos == null || h . hacker == null ) { L . warn ( "Skipping item " + count + " no resonators attached. id=" + h . _id ) ; continue ; } if ( L . isTraceEnabled ( ) ) L . trace ( String . format ( "  %5d %s\n" , count , h ) ) ; if ( h . hasCanGetUltra ( ) ) canGetUltraCount ++ ; total += h . getItemCount ( ) ; res . add ( h ) ; } long t1 = System . currentTimeMillis ( ) ; L . info ( "*** " + res . size ( ) + " hacks for " + total + " items  canGetUltraCount=" + canGetUltraCount + "  lengthCheck=" + ( res . size ( ) != o . total_rows ? "WARNING" : "OK" ) + " dt=" + ( t1 - t0 ) + " ms" ) ; return res ; }
tr	3	private static long length ( File file ) { if ( file . isFile ( ) ) { return file . length ( ) ; } else if ( file . isDirectory ( ) ) { File children [ ] = file . listFiles ( ) ; long len = 0 ; for ( File fi : children ) { len += length ( fi ) ; } return len ; } return 0 ; }
tr	5	private void desc ( ) { Dventana . run ( ) ; System . out . println ( "Comenzando desc" ) ; Dventana . setVisible ( true ) ; Dventana . setAlwaysOnTop ( true ) ; Dventana . setAlwaysOnTop ( false ) ; String filename = Durl . getFile ( ) ; int num = filename . lastIndexOf ( "/" ) ; String fname = filename . substring ( num + 1 , filename . length ( ) ) ; System . out . println ( fname ) ; int Bites = urlCon . getContentLength ( ) ; double tmax = double . valueOf ( Bites ) ; String unidad = "Bytes" ; if ( Bites > 1024 ) { tmax = double . valueOf ( Bites / 1024 ) ; unidad = "KBs" ; } if ( tmax > 1024 ) { tmax = double . valueOf ( tmax / 1024 ) ; unidad = "MBs" ; } if ( tmax > 1024 ) { tmax = double . valueOf ( tmax / 1024 ) ; unidad = "GBs" ; } DecimalFormat df = new DecimalFormat ( "0.00" ) ; System . out . println ( df . format ( tmax ) + unidad ) ; String zeta = df . format ( tmax ) ; zeta = zeta . replaceAll ( " " , "." ) ; double doub = double . parseDouble ( zeta ) ; try { Archivo archivi ; archivi = new Archivo ( fname , Durl , doub , unidad ) ; System . out . println ( archivi ) ; Dventana . addDescarga ( archivi ) ; } catch ( Exception e ) { System . out . println ( e ) ; } if ( CDFinal . exists ( ) == false ) { CDFinal . mkdir ( ) ; } System . out . println ( CDFinal ) ; Dventana . setCarpeta ( CDFinal ) ; }
tr	7	public List < String > getUnionList ( List < String > list1 , List < String > list2 ) { List < String > totalList = new ArrayList < > ( ) ; if ( list1 . size ( ) > list2 . size ( ) ) { for ( String obj : list1 ) { totalList . add ( obj ) ; } for ( String obj : list2 ) { if ( ! totalList . contains ( obj ) ) { totalList . add ( obj ) ; } } } else { for ( String obj : list2 ) { totalList . add ( obj ) ; } for ( String obj : list1 ) { if ( ! totalList . contains ( obj ) ) { totalList . add ( obj ) ; } } } return totalList ; }
tr	2	public Iterator < Tuple > iterator ( ) { List < Tuple > filledSlots = new ArrayList < Tuple > ( ) ; for ( int i = 0 ; i < tuples . length ; i ++ ) { if ( getSlot ( i ) ) { filledSlots . add ( tuples [ i ] ) ; } } return new ArrayList < Tuple > ( filledSlots ) . iterator ( ) ; }
tr	9	@ SuppressWarnings ( "rawtypes" ) public void paint ( Graphics g ) { super . paint ( g ) ; Graphics2D g2d = ( Graphics2D ) g ; drawbackground ( g ) ; drawScore ( g ) ; if ( GameCraft . direction == 3 ) { g2d . drawImage ( ResourceLoader . ImageLoad ( "/playerback.png" ) , GameCraft . getX ( ) , GameCraft . getY ( ) , this ) ; } else if ( GameCraft . direction == 0 ) { g2d . drawImage ( ResourceLoader . ImageLoad ( "/playerfront.png" ) , GameCraft . getX ( ) , GameCraft . getY ( ) , this ) ; } else if ( GameCraft . direction == 1 ) { g2d . drawImage ( ResourceLoader . ImageLoad ( "/playerleft.png" ) , GameCraft . getX ( ) , GameCraft . getY ( ) , this ) ; } else if ( GameCraft . direction == 2 ) { g2d . drawImage ( ResourceLoader . ImageLoad ( "/playerright.png" ) , GameCraft . getX ( ) , GameCraft . getY ( ) , this ) ; } else { g2d . drawImage ( ResourceLoader . ImageLoad ( "/playerfront.png" ) , GameCraft . getX ( ) , GameCraft . getY ( ) , this ) ; } ArrayList ms = GameCraft . getBulletDOWN ( ) ; for ( int i = 0 ; i < ms . size ( ) ; i ++ ) { BulletDOWN m = ( BulletDOWN ) ms . get ( i ) ; g2d . drawImage ( m . getImage ( ) , m . getX ( ) , m . getY ( ) , this ) ; } ArrayList msUP = GameCraft . getBulletUP ( ) ; for ( int i = 0 ; i < msUP . size ( ) ; i ++ ) { BulletUP m = ( BulletUP ) msUP . get ( i ) ; g2d . drawImage ( m . getImage ( ) , m . getX ( ) , m . getY ( ) , this ) ; } ArrayList msLEFT = GameCraft . getBulletLEFT ( ) ; for ( int i = 0 ; i < msLEFT . size ( ) ; i ++ ) { BulletLEFT m = ( BulletLEFT ) msLEFT . get ( i ) ; g2d . drawImage ( m . getImage ( ) , m . getX ( ) , m . getY ( ) , this ) ; } ArrayList msRIGHT = GameCraft . getBulletRIGHT ( ) ; for ( int i = 0 ; i < msRIGHT . size ( ) ; i ++ ) { BulletRIGHT m = ( BulletRIGHT ) msRIGHT . get ( i ) ; g2d . drawImage ( m . getImage ( ) , m . getX ( ) , m . getY ( ) , this ) ; } ArrayList msEnemys = GameCraft . getEnemys ( ) ; for ( int i = 0 ; i < msEnemys . size ( ) ; i ++ ) { Enemys m = ( Enemys ) msEnemys . get ( i ) ; g2d . drawImage ( m . getImage ( ) , m . getX ( ) , m . getY ( ) , this ) ; } Toolkit . getDefaultToolkit ( ) . sync ( ) ; g . dispose ( ) ; }
tr	0	@ Test public void testAsText ( ) { Command command = new TestCommand ( ) ; command . setApplication ( new Application ( ) ) ; CommandTester tester = new CommandTester ( command ) ; Map < String , String > foobar = new HashMap < String , String > ( ) ; foobar . put ( "command" , command . getName ( ) ) ; tester . execute ( foobar ) ; assertEquals ( "asText() returns a text representation of the command" , getResource ( "command_astext.txt" ) , command . asText ( ) ) ; }
tr	0	public static ImageIcon getCertificateIcon ( ) { return IconLoader . getIcon ( "cert.png" ) ; }
tr	1	@ Override public void render ( Shader shader , RenderingEngine renderingEngine , float transparencyLevel ) { if ( material . getFloat ( "transparency" ) == transparencyLevel ) { shader . bind ( ) ; shader . updateUniforms ( getTransform ( ) , material , renderingEngine ) ; mesh . draw ( ) ; } }
tr	6	public Customer editCustomer ( Customer customer ) throws Exception { if ( customer . getId ( ) == null || customer . getAddress ( ) == null || customer . getName ( ) == null || customer . getSurname ( ) == null || customer . getTelephones ( ) == null ) { throw new NullParameterException ( ) ; } if ( ! checkZipCode ( customer . getAddress ( ) . getZipCode ( ) ) ) { throw new ZipCodeOutOfRangeException ( ) ; } DAOFactory . factory . getCustomerDAO ( ) . updateCustomer ( customer ) ; return customer ; }
tr	3	public static int method156 ( int i , int j , int l ) { j &= 3 ; if ( j == 0 ) return i ; if ( j == 1 ) return 7 - l ; if ( j == 2 ) return 7 - i ; else return l ; }
tr	7	protected List < Point > solve ( ) { openSet . add ( from ) ; gScore . put ( from , 0.0 ) ; updateFScore ( from ) ; while ( ! openSet . isEmpty ( ) ) { Point current = openSet . remove ( ) ; if ( current . equals ( to ) ) return reconstructPath ( ) ; closedSet . add ( current ) ; for ( Point neighbor : getNeighbors ( current ) ) { if ( closedSet . contains ( neighbor ) ) continue ; if ( ! map . get ( neighbor . x , neighbor . y ) . isWalkable ( ) ) continue ; double dist = current . distance ( neighbor ) ; double g = gScore . get ( current ) + dist ; if ( ! openSet . contains ( neighbor ) || g < gScore . get ( neighbor ) ) { cameFrom . put ( neighbor , current ) ; gScore . put ( neighbor , g ) ; updateFScore ( neighbor ) ; openSet . add ( neighbor ) ; } } } return null ; }
tr	9	private void handleInbound ( ) { ByteBuffer buffer = ByteBufferBuffer . alloc ( 1024 * 64 ) ; try { InputStream inStream = socket . getInputStream ( ) ; while ( true ) { if ( ! isValid ( ) ) break ; buffer . clear ( ) ; ensureBuffer ( buffer , inStream , 2 ) ; int size = buffer . getShort ( 0 ) ; if ( ( size <= 0 ) || ( size > 32000 ) ) throw new RuntimeException ( "Invalid packet size." ) ; buffer . clear ( ) ; ensureBuffer ( buffer , inStream , size ) ; int position = buffer . position ( ) ; if ( position != size ) throw new RuntimeException ( "Bad receive buffer." ) ; buffer . flip ( ) ; Packet packet = Packet . read ( buffer ) ; synchronized ( this ) { inbound . addLast ( packet ) ; } inboundFlag . set ( ) ; } } catch ( Exception e ) { if ( ! stopped ) { if ( ! "EOF" . equals ( e . getMessage ( ) ) ) e . printStackTrace ( ) ; } try { if ( socket != null ) socket . close ( ) ; } catch ( IOException e1 ) { if ( ! stopped ) e1 . printStackTrace ( ) ; } } }
tr	0	@ Override public void setTileHeight ( float tileHeight ) { this . tileHeight = tileHeight ; }
tr	0	public void showMinorCard ( ) { showCard ( 1 ) ; }
tr	6	@ Override public Object eval ( OclContext context ) throws OclEvaluationException { Object source = this . source . eval ( context ) ; Collection < ? > collection ; if ( source == null ) { collection = Collections . emptyList ( ) ; } else if ( source . getClass ( ) . isArray ( ) ) { collection = Arrays . asList ( ( Object [ ] ) source ) ; } else if ( ! ( source instanceof Collection < ? > ) ) { collection = Collections . singletonList ( source ) ; } else { collection = ( Collection < ? > ) source ; } String iteratorName = this . getIterator ( ) . getName ( ) ; String accuName = this . accumulator . getName ( ) ; Object initAccu = this . accumulator . init ( context ) ; return OclIterateSupport . iterate ( collection , context , iteratorName , accuName , initAccu , this . getBody ( ) ) ; }
tr	1	public static JSONObject toJSONObject ( String string ) throws JSONException { JSONObject jo = new JSONObject ( ) ; JSONTokener x = new JSONTokener ( string ) ; while ( x . more ( ) ) { String name = Cookie . unescape ( x . nextTo ( = ) ) ; x . next ( = ) ; jo . put ( name , Cookie . unescape ( x . nextTo ( ; ) ) ) ; x . next ( ) ; } return jo ; }
tr	7	public void select ( long timeout ) throws IOException { if ( timeout > 0 ) { selector . select ( timeout ) ; } else { selector . selectNow ( ) ; } for ( Iterator < SelectionKey > it = selector . selectedKeys ( ) . iterator ( ) ; it . hasNext ( ) ; ) { SelectionKey key = it . next ( ) ; it . remove ( ) ; if ( ! key . isValid ( ) ) { key . cancel ( ) ; if ( key . attachment ( ) instanceof Connection ) { ( ( Connection ) key . attachment ( ) ) . setAvatar ( null ) ; } } else if ( key . isAcceptable ( ) ) { Connection cnt = new Connection ( selector , ( ServerSocketChannel ) key . channel ( ) ) ; cnt . setAvatar ( new Login ( kernel ) ) ; } else { if ( key . isWritable ( ) ) { ( ( Connection ) key . attachment ( ) ) . writeToSocket ( ) ; } if ( key . isReadable ( ) ) { ( ( Connection ) key . attachment ( ) ) . readFromSocket ( ) ; } } } }
tr	7	public Object nextValue ( ) throws JSONException { char c = this . nextClean ( ) ; String string ; switch ( c ) { case " : case ' : return this . nextString ( c ) ; case { : this . back ( ) ; return new JSONObject ( this ) ; case [ : this . back ( ) ; return new JSONArray ( this ) ; } StringBuffer sb = new StringBuffer ( ) ; while ( c >=   && " :]}/\\\"[{;=#" . indexOf ( c ) < 0 ) { sb . append ( c ) ; c = this . next ( ) ; } this . back ( ) ; string = sb . toString ( ) . trim ( ) ; if ( "" . equals ( string ) ) { throw this . syntaxError ( "Missing value" ) ; } return JSONObject . stringToValue ( string ) ; }
tr	1	@ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( "{" ) ; if ( getPolicyNames ( ) != null ) sb . append ( "PolicyNames: " + getPolicyNames ( ) + " " ) ; sb . append ( "}" ) ; return sb . toString ( ) ; }
tr	4	private Course getCourse ( int rowNumber , String courseDataRecord , DataController dataController ) throws InputFileReaderException { Course course = new Course ( ) ; String [ ] courseData = validateRecord ( rowNumber , courseDataRecord ) ; course . setNumber ( courseData [ 0 ] ) ; course . setName ( removeQuotationMarks ( courseData [ 1 ] ) ) ; CourseType courseType = new CourseType ( removeQuotationMarks ( courseData [ 2 ] ) ) ; course . setType ( courseType ) ; Academic academic = new Academic ( ) ; academic . setName ( removeQuotationMarks ( courseData [ 3 ] ) ) ; course . setAcademic ( academic ) ; int numberOfStudents = 0 ; try { numberOfStudents = Integer . parseInt ( courseData [ 4 ] ) ; } catch ( Exception e ) { Protocol . log ( "Eingabewert f\u00FCr die Anzahl der Studenten ist kein Integer!" ) ; } course . setStudents ( numberOfStudents ) ; if ( courseData . length == 6 ) { List < Equipment > requiredEquipments = parseEquipments ( courseData [ 5 ] ) ; course . setRequiredEquipments ( requiredEquipments ) ; for ( Equipment e : requiredEquipments ) { if ( ! dataController . getEquipments ( ) . contains ( e ) ) { dataController . getEquipments ( ) . add ( e ) ; } } } else { Protocol . log ( "Die Veranstaltung [KursID='" + course . getNumber ( ) + "'  Kurs='" + course . getName ( ) + "'] ben\u00F6tigt kein Equipment!" ) ; } return course ; }
tr	9	private void createMirrorList ( ) throws ParserConfigurationException , SAXException , IOException { URL mirrorsUrl = new URL ( String . format ( Constants . MIRRORS_URL , this . apiKey ) ) ; DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory . newInstance ( ) ; DocumentBuilder documentBuilder = documentBuilderFactory . newDocumentBuilder ( ) ; Document document = documentBuilder . parse ( mirrorsUrl . openStream ( ) ) ; Element rootElement = document . getDocumentElement ( ) ; NodeList nodes = rootElement . getChildNodes ( ) ; for ( int i = 0 ; i < nodes . getLength ( ) ; ++ i ) { Node node = nodes . item ( i ) ; if ( node . getNodeName ( ) . equals ( "Mirror" ) ) { NodeList mirrorNodes = node . getChildNodes ( ) ; String mirrorPath = null ; int typeMask = 0 ; for ( int j = 0 ; j < mirrorNodes . getLength ( ) ; ++ j ) { Node mirrorNode = mirrorNodes . item ( j ) ; if ( mirrorNode . getNodeName ( ) . equals ( "mirrorpath" ) ) { mirrorPath = mirrorNode . getTextContent ( ) ; } else if ( mirrorNode . getNodeName ( ) . equals ( "typemask" ) ) { typeMask = Integer . parseInt ( mirrorNode . getTextContent ( ) ) ; } } List < MirrorType > mirrorTypesForMask = this . getMirrorTypesFromTypeMask ( typeMask ) ; for ( MirrorType mt : mirrorTypesForMask ) { if ( mt . equals ( MirrorType . ZIP ) ) { this . zipMirrors . add ( mirrorPath ) ; } else if ( mt . equals ( MirrorType . BANNER ) ) { this . bannerMirrors . add ( mirrorPath ) ; } else if ( mt . equals ( MirrorType . XML ) ) { this . xmlMirrors . add ( mirrorPath ) ; } } } } }
tr	3	private void deleteDonesButtonActionPerformed ( java . awt . event . ActionEvent evt ) { ArrayList < Timer > timers = timerRegister . getObjects ( ) ; ArrayList < Timer > doneTimers = new ArrayList < > ( ) ; for ( Timer t : timers ) { if ( timerRegister . getRemainingTime ( t ) == "Done" ) { doneTimers . add ( t ) ; } } for ( Timer t : doneTimers ) { timerRegister . delete ( t ) ; } }
tr	4	public JSONWriter key ( String string ) throws JSONException { if ( string == null ) { throw new JSONException ( "Null key." ) ; } if ( this . mode == k ) { try { this . stack [ this . top - 1 ] . putOnce ( string , boolean . true ) ; if ( this . , ) { this . writer . write (   ) ; } this . writer . write ( JSONObject . quote ( string ) ) ; this . writer . write ( : ) ; this . , = false ; this . mode = o ; return this ; } catch ( IOException e ) { throw new JSONException ( e ) ; } } throw new JSONException ( "Misplaced key." ) ; }
tr	5	private void createTrack ( File file ) { boolean trackRead = false ; numberProcessed = numberProcessed + 1 ; Mp3File mp3File ; String trackNumber , artist , title , album , genre ; try { mp3File = new Mp3File ( file . getAbsolutePath ( ) ) ; if ( mp3File . hasId3v1Tag ( ) ) { ID3v1 id3v1Tag = mp3File . getId3v1Tag ( ) ; trackNumber = id3v1Tag . getTrack ( ) ; artist = id3v1Tag . getArtist ( ) ; title = id3v1Tag . getTitle ( ) ; album = id3v1Tag . getAlbum ( ) ; genre = id3v1Tag . getGenreDescription ( ) ; addTrackToDatabase ( Paths . get ( file . toURI ( ) ) , trackNumber , artist , title , album , mp3File . getLengthInMilliseconds ( ) , genre ) ; trackRead = true ; } else if ( mp3File . hasId3v2Tag ( ) ) { ID3v2 id3v2Tag = mp3File . getId3v2Tag ( ) ; trackNumber = id3v2Tag . getTrack ( ) ; artist = id3v2Tag . getArtist ( ) ; title = id3v2Tag . getTitle ( ) ; album = id3v2Tag . getAlbum ( ) ; genre = id3v2Tag . getGenreDescription ( ) ; addTrackToDatabase ( Paths . get ( file . toURI ( ) ) , trackNumber , artist , title , album , mp3File . getLengthInMilliseconds ( ) , genre ) ; trackRead = true ; } else { System . out . println ( "File: " + file + " cannot be read" ) ; } } catch ( UnsupportedTagException | InvalidDataException | IOException e ) { e . printStackTrace ( ) ; } if ( ! trackRead ) { int i = file . getName ( ) . lastIndexOf ( . ) ; String fileExtension = file . getName ( ) . substring ( i + 1 ) ; if ( fileExtension . equals ( "mp3" ) ) { LOGGER . warning ( file . getName ( ) ) ; unreadFiles . add ( file ) ; } } }
tr	1	private int getMaxLen ( ) throws ValidationException { String text = this . maxLenTextField . getText ( ) ; try { int M = Integer . parseInt ( text ) ; return M ; } catch ( Exception e ) { String message = "The maximum length is not an integer number." ; throw new ValidationException ( message , "BAD_NUMBER" ) ; } }
tr	1	public final void setDebugMode ( boolean debug ) { if ( debug != this . debug ) { this . debug = debug ; doSetDebugMode ( ) ; } }
tr	8	public static Map < String , String > returnShipAdviceHeader ( String identifier ) { Map < String , String > headerValues = new HashMap < String , String > ( ) ; if ( conn == null ) { getConnection ( ) ; } try { String sql = "SELECT CustomerID FROM tblSalesHeader WHERE **column** = " + identifier ; String asnSql = "SELECT ShipFirstName  ShipLastName  ShipAdd1  ShipCity  ShipState  ShipPostalCode  ShipCountry  ShipVia  ShipRequestDate" + " FROM tblASNSalesHeader WHERE CustomerID = " + identifier ; String customerAsnSql = "SELECT CustomerOrderDate  CustomerOrderType  ShipRequestWarehouse  OrderCompleted FROM tblASNSalesHeader " + "WHERE CustomerID = " + identifier ; Statement customerStatement = conn . createStatement ( ) ; Statement shipStatement = conn . createStatement ( ) ; Statement customerShipStatement = conn . createStatement ( ) ; ResultSet customerId = customerStatement . executeQuery ( sql ) ; ResultSet shipInfo = shipStatement . executeQuery ( asnSql ) ; ResultSet customerShipDetails = customerShipStatement . executeQuery ( customerAsnSql ) ; if ( customerId != null ) { while ( customerId . next ( ) ) { headerValues . put ( "customer-id" , customerId . getString ( 1 ) ) ; } } if ( shipInfo != null ) { while ( shipInfo . next ( ) ) { headerValues . put ( "ship-first-name" , shipInfo . getString ( 1 ) ) ; headerValues . put ( "ship-last-name" , shipInfo . getString ( 2 ) ) ; headerValues . put ( "ship-addr1" , shipInfo . getString ( 3 ) ) ; headerValues . put ( "ship-city" , shipInfo . getString ( 4 ) ) ; headerValues . put ( "ship-state" , shipInfo . getString ( 5 ) ) ; headerValues . put ( "ship-postal-code" , shipInfo . getString ( 6 ) ) ; headerValues . put ( "ship-country" , shipInfo . getString ( 7 ) ) ; headerValues . put ( "ship-via" , shipInfo . getString ( 8 ) ) ; headerValues . put ( "ship-request-date" , shipInfo . getString ( 9 ) ) ; } } if ( customerShipDetails != null ) { while ( customerShipDetails . next ( ) ) { headerValues . put ( "customer-order-date" , customerShipDetails . getString ( 1 ) ) ; headerValues . put ( "customer-order-type" , customerShipDetails . getString ( 2 ) ) ; headerValues . put ( "ship-request-warehouse" , customerShipDetails . getString ( 3 ) ) ; headerValues . put ( "order-completed" , customerShipDetails . getString ( 4 ) ) ; } } } catch ( SQLException sqle ) { sqle . printStackTrace ( ) ; } return headerValues ; }
tr	0	public Gun ( Calibre newCalibre , FiringStyle newStyle , GunType newType ) { this . calibre = newCalibre ; this . type = newType ; }
tr	4	private static Ruta realizaMovimiento ( final Ruta ruta ) { double menorCoste = ruta . getCoste ( ) ; Ruta mejorRuta = ruta ; for ( int pos = 0 ; pos < ruta . getMaximasCiudades ( ) ; pos ++ ) { for ( int i = 0 ; i < ruta . getMaximasCiudades ( ) ; i ++ ) { if ( pos == i ) continue ; Ruta rutaTemp = ruta . clona ( ) ; rutaTemp . mueve ( i , pos ) ; double coste = rutaTemp . getCoste ( ) ; if ( coste < menorCoste ) { menorCoste = coste ; mejorRuta = rutaTemp ; } } } return mejorRuta ; }
tr	3	public boolean checkIndex ( String indexName ) { try { Statement stmt = conn . createStatement ( ) ; stmt . execute ( "SELECT * from pg_indexes WHERE indexname = '" + indexName + "'" ) ; ResultSet rs = stmt . getResultSet ( ) ; while ( rs . next ( ) ) { String dbIndexName = rs . getString ( "indexname" ) ; if ( indexName . equalsIgnoreCase ( dbIndexName ) ) { return true ; } } return false ; } catch ( SQLException e ) { e . printStackTrace ( ) ; } return false ; }
tr	9	private static boolean isUnreserved ( byte b ) { return ( b >= a && b <= z ) || ( b >= A && b <= Z ) || ( b >= 0 && b <= 9 ) || b == . || b == - || b == _ || b == ~ ; }
tr	9	int sendIncrementalRLE ( int [ ] data , int [ ] prevData , DataOutputStream out ) { try { int bytesSent = 0 ; int i = 0 ; int equalCount = 0 , dataValue = 0 , dataCount = 0 ; while ( i < data . length ) { while ( prevData != null && i < data . length && data [ i ] == prevData [ i ] ) { equalCount ++ ; i ++ ; } if ( equalCount > 0 ) { out . writeInt ( equalCount | 80000000 ) ; bytesSent += 4 ; equalCount = 0 ; } if ( i >= data . length ) break ; dataValue = data [ i ] ; dataCount = 1 ; i ++ ; while ( i < data . length && data [ i ] == dataValue && dataCount < 127 ) { dataCount ++ ; i ++ ; } out . writeInt ( ( dataValue & 00FFFFFF ) | ( dataCount << 24 ) ) ; bytesSent += 4 ; } return bytesSent ; } catch ( IOException e ) { return - 1 ; } }
tr	2	private boolean hasOutput ( ) { return method . equals ( "POST" ) || method . equals ( "PUT" ) && ! data . isEmpty ( ) ; }
tr	5	public final void gameOver ( ) { if ( inGameState ( "GameOver" ) || ( ! inGameState ( "InGame" ) && ! inGameState ( "LifeLost" ) ) ) return ; clearKey ( key_continuegame ) ; removeGameState ( "StartLevel" ) ; removeGameState ( "StartGame" ) ; removeGameState ( "LifeLost" ) ; seqtimer = 0 ; if ( gameover_ticks > 0 ) { if ( gameover_ingame ) addGameState ( "GameOver" ) ; else setGameState ( "GameOver" ) ; new JGTimer ( gameover_ticks , true , "GameOver" ) { public void alarm ( ) { gotoTitle ( ) ; } } ; } else { gotoTitle ( ) ; } }
tr	6	public static void main ( String [ ] args ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( UserInterface . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( UserInterface . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( UserInterface . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( UserInterface . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { UserInterface UI = new UserInterface ( ) ; UI . setLocationRelativeTo ( null ) ; UI . setVisible ( true ) ; } } ) ; }
tr	1	private static void createProduct ( ) { ProductUI productMenu = new ProductUI ( ) ; ProductService productService = new ProductService ( new ProductDAO ( ) ) ; try { ProductModel newProduct = productMenu . createProduct ( ) ; newProduct = productService . createProduct ( newProduct ) ; productMenu . showCreateSuccess ( newProduct ) ; } catch ( WebshopAppException e ) { ExceptionUI . printException ( e ) ; } }
tr	6	public List < Object > flatten ( List < Object > input ) throws JSONLDProcessingError { final UniqueNamer namer = new UniqueNamer ( "_:b" ) ; final Map < String , Object > graphs = new LinkedHashMap < String , Object > ( ) { { put ( "@default" , new LinkedHashMap < String , Object > ( ) ) ; } } ; createNodeMap ( input , graphs , "@default" , namer ) ; final Map < String , Object > defaultGraph = ( Map < String , Object > ) graphs . get ( "@default" ) ; final List < String > graphNames = new ArrayList < String > ( graphs . keySet ( ) ) ; Collections . sort ( graphNames ) ; for ( final String graphName : graphNames ) { if ( "@default" . equals ( graphName ) ) { continue ; } final Map < String , Object > nodeMap = ( Map < String , Object > ) graphs . get ( graphName ) ; Map < String , Object > subject = ( Map < String , Object > ) defaultGraph . get ( graphName ) ; if ( subject == null ) { subject = new LinkedHashMap < String , Object > ( ) ; subject . put ( "@id" , graphName ) ; subject . put ( "@graph" , new ArrayList < Object > ( ) ) ; defaultGraph . put ( graphName , subject ) ; } else if ( ! subject . containsKey ( "@graph" ) ) { subject . put ( "@graph" , new ArrayList < Object > ( ) ) ; } final List < Object > graph = ( List < Object > ) subject . get ( "@graph" ) ; final List < String > ids = new ArrayList < String > ( nodeMap . keySet ( ) ) ; Collections . sort ( ids ) ; for ( final String id : ids ) { graph . add ( nodeMap . get ( id ) ) ; } } final List < Object > flattened = new ArrayList < Object > ( ) ; final List < String > keys = new ArrayList < String > ( defaultGraph . keySet ( ) ) ; Collections . sort ( keys ) ; for ( final String key : keys ) { flattened . add ( defaultGraph . get ( key ) ) ; } return flattened ; }
tr	6	@ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; ReadNode other = ( ReadNode ) obj ; if ( prompt == null ) { if ( other . prompt != null ) return false ; } else if ( ! prompt . equals ( other . prompt ) ) return false ; return true ; }
tr	5	@ Test public void buildsGraph ( ) { Point p1 = vc . addPoint ( 0 , 0 ) ; Point p2 = vc . addPoint ( 1 , - 1 ) ; Point p3 = vc . addPoint ( 1 , 1 ) ; Point p4 = vc . addPoint ( 1.5 , 0.0 ) ; Point p5 = vc . addPoint ( 4 , - 1 ) ; Point p6 = vc . addPoint ( 4 , 1 ) ; p1 . setRight ( p2 ) ; p2 . setLeft ( p1 ) ; p3 . setRight ( p1 ) ; p1 . setLeft ( p3 ) ; p2 . setRight ( p3 ) ; p3 . setLeft ( p2 ) ; p4 . setRight ( p5 ) ; p5 . setLeft ( p4 ) ; p6 . setRight ( p4 ) ; p4 . setLeft ( p6 ) ; p5 . setRight ( p6 ) ; p6 . setLeft ( p5 ) ; vc . buildGraph ( ) ; Tree < Vertex > testadj1 = new Tree < > ( new VertexComparator ( ) ) ; Tree < Vertex > testadj2 = new Tree < > ( new VertexComparator ( ) ) ; Tree < Vertex > testadj3 = new Tree < > ( new VertexComparator ( ) ) ; Tree < Vertex > testadj4 = new Tree < > ( new VertexComparator ( ) ) ; Tree < Vertex > testadj5 = new Tree < > ( new VertexComparator ( ) ) ; Tree < Vertex > testadj6 = new Tree < > ( new VertexComparator ( ) ) ; testadj1 . add ( p2 ) ; testadj1 . add ( p3 ) ; testadj2 . add ( p1 ) ; testadj2 . add ( p5 ) ; testadj2 . add ( p4 ) ; testadj2 . add ( p3 ) ; testadj3 . add ( p1 ) ; testadj3 . add ( p6 ) ; testadj3 . add ( p4 ) ; testadj3 . add ( p2 ) ; testadj4 . add ( p2 ) ; testadj4 . add ( p3 ) ; testadj4 . add ( p5 ) ; testadj4 . add ( p6 ) ; testadj5 . add ( p2 ) ; testadj5 . add ( p4 ) ; testadj5 . add ( p6 ) ; testadj6 . add ( p5 ) ; testadj6 . add ( p4 ) ; testadj6 . add ( p3 ) ; assertTrue ( p1 . getAdjacents ( ) . equals ( testadj1 ) && p2 . getAdjacents ( ) . equals ( testadj2 ) && p3 . getAdjacents ( ) . equals ( testadj3 ) && p4 . getAdjacents ( ) . equals ( testadj4 ) && p5 . getAdjacents ( ) . equals ( testadj5 ) && p6 . getAdjacents ( ) . equals ( testadj6 ) ) ; }
tr	5	public void login ( ) { AuthStatus status = GuardGame . getRoketGamer ( ) . init ( new APIKey ( Constants . API_KEY ) , new Player ( usernameField . getText ( ) , new Password ( createString ( passwordField . getPassword ( ) ) ) ) , Constants . ROKETGAMER_LOG_HOOK ) ; if ( status == AuthStatus . GOOD ) { GuardGame . getDebugWindow ( ) . printInfo ( "User authenticated" ) ; GuardGame . getDebugWindow ( ) . printInfo ( "Logged in as: " + GuardGame . getRoketGamer ( ) . getPlayer ( ) . getName ( ) ) ; GuardGame . getGameState ( ) . setOffline ( false ) ; nextWindow ( "LoggingInWindow" ) ; donewithMe ( ) ; } else { if ( status == AuthStatus . BAD ) { GuardGame . getDebugWindow ( ) . printWarning ( "Authentication failed: AuthStatus.BAD" ) ; JOptionPane . showMessageDialog ( this , "Incorrect username or password. \nUse your application password to login." ) ; } else if ( status == AuthStatus . OFFLINE ) { GuardGame . getDebugWindow ( ) . printWarning ( "Authentication failed: AuthStatus.OFFLINE" ) ; JOptionPane . showMessageDialog ( this , "Unable to login. RoketGamer API is offline. Check website." ) ; } else if ( status == AuthStatus . INVALID_API_KEY ) { GuardGame . getDebugWindow ( ) . printWarning ( "Authentication failed: AuthStatus.INVALID_API_KEY" ) ; JOptionPane . showMessageDialog ( this , "Unable to login. API key is invalid." ) ; } else if ( status == AuthStatus . UNKNOWN ) { GuardGame . getDebugWindow ( ) . printWarning ( "Authentication failed: AuthStatus.UNKNOWN" ) ; JOptionPane . showMessageDialog ( this , "Unable to login. Retry later or check the RoketGamer website." ) ; } else { GuardGame . getDebugWindow ( ) . printWarning ( "Authentication failed: AuthStatus is not recognized." ) ; GuardGame . getDebugWindow ( ) . printWarning ( "Internet may be disconnected." ) ; JOptionPane . showMessageDialog ( this , "Unable to login. Check your internet connection." ) ; } } }
tr	2	public Action poolCurrentAction ( ) { if ( actions . isEmpty ( ) ) { return null ; } Action next = actions . poll ( ) ; if ( loop ) { next . reset ( ) ; actions . add ( next ) ; } return next ; }
tr	9	private static String [ ] split ( String document , String regex , String fileName ) { int min = 50 * 1024 ; int max = 50 * 1024 ; int bodyStart = document . indexOf ( "<body>" ) + "<body>" . length ( ) ; int bodyEnd = document . indexOf ( "</body>" ) ; List < Integer > breaks = new ArrayList < Integer > ( ) ; Matcher matcher = Pattern . compile ( regex ) . matcher ( document ) ; int start = bodyStart ; breaks . add ( bodyStart ) ; while ( matcher . find ( start ) ) { int prev = breaks . get ( breaks . size ( ) - 1 ) ; int cur = matcher . start ( ) ; if ( cur - prev > min ) { breaks . add ( matcher . start ( ) ) ; } start = matcher . end ( ) ; } breaks . add ( bodyEnd ) ; List < String > docs = new ArrayList < String > ( ) ; int currStart = bodyStart ; int numBreak = 0 ; List < String > opened = new ArrayList < String > ( ) ; while ( numBreak < breaks . size ( ) ) { int nextBreak = breaks . get ( numBreak ) ; if ( nextBreak - currStart >= max ) { String doc = document . substring ( currStart , nextBreak ) ; if ( doc . startsWith ( "<hr />" ) ) { doc = doc . substring ( "<hr />" . length ( ) ) ; } String open = "" ; for ( String tag : opened ) { open += "<" + tag + ">" ; } doc = open + doc ; opened . clear ( ) ; computeTags ( doc , opened ) ; List < String > rev = new ArrayList < String > ( opened ) ; Collections . reverse ( rev ) ; for ( String tag : rev ) { doc += "</" + tag + ">" ; } doc = document . substring ( 0 , bodyStart ) + doc + "</body></html>" ; docs . add ( doc ) ; currStart = nextBreak ; } numBreak ++ ; } Map < String , Integer > refs = new HashMap < String , Integer > ( ) ; for ( int i = 0 ; i < docs . size ( ) ; i ++ ) { String doc = docs . get ( i ) ; Matcher idMatcher = Pattern . compile ( " id=\"([^\"]*)\"" ) . matcher ( doc ) ; int idStart = 0 ; while ( idMatcher . find ( idStart ) ) { String name = idMatcher . group ( 1 ) ; refs . put ( name , i ) ; idStart = idMatcher . end ( ) ; } } String baseName = new File ( fileName ) . getName ( ) ; baseName = baseName . substring ( 0 , baseName . lastIndexOf ( . ) ) ; for ( int i = 0 ; i < docs . size ( ) ; i ++ ) { String doc = docs . get ( i ) ; StringBuilder newDoc = new StringBuilder ( ) ; Matcher idMatcher = Pattern . compile ( " href=\"(#([^\"]*))\"" ) . matcher ( doc ) ; int idStart = 0 ; while ( idMatcher . find ( idStart ) ) { newDoc . append ( doc . substring ( idStart , idMatcher . start ( 1 ) ) ) ; Integer docIndex = refs . get ( idMatcher . group ( 2 ) ) ; if ( docIndex != null && docIndex . intValue ( ) != i ) { newDoc . append ( baseName + ".p" + toDigits ( docIndex ) + ".html#" + idMatcher . group ( 2 ) ) ; } else { newDoc . append ( "#" + idMatcher . group ( 2 ) ) ; } idStart = idMatcher . end ( 1 ) ; } newDoc . append ( doc . substring ( idStart , doc . length ( ) ) ) ; docs . set ( i , newDoc . toString ( ) ) ; } return docs . toArray ( new String [ docs . size ( ) ] ) ; }
tr	4	@ Override protected void doPost ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { request . setCharacterEncoding ( "utf-8" ) ; String patientId = request . getParameter ( "patient_id" ) ; String userId = request . getParameter ( "user_id" ) ; String equipId = request . getParameter ( "equip_id" ) ; String pillNum = request . getParameter ( "pill_num" ) ; boolean result = false ; commonSearch com = new commonSearch ( ) ; if ( patientId != null ) { result = com . deletePatient ( patientId ) ; } else if ( userId != null ) { result = com . deleteUser ( userId ) ; } else if ( equipId != null ) { result = com . deleteEquip ( equipId ) ; } else if ( pillNum != null ) { result = com . deletePill ( pillNum ) ; } response . getWriter ( ) . print ( result ) ; }
tr	1	@ Override public void mousePressed ( MouseEvent e ) { if ( e . isPopupTrigger ( ) ) { doPop ( e ) ; } }
tr	7	private void viewMoreInfo ( ) { String t = "" ; String [ ] data = query . Info ( DeleteNonNummeric ( ) , true , null , null , false ) ; idM = Integer . valueOf ( data [ 0 ] ) ; id . setText ( data [ 0 ] ) ; name . setText ( data [ 2 ] + "  " + data [ 1 ] ) ; gender . setText ( data [ 3 ] ) ; pos . setText ( data [ 4 ] ) ; if ( Integer . valueOf ( data [ 9 ] ) == 1 ) adm . setText ( " ADMIN" ) ; else adm . setText ( "  USER" ) ; if ( Integer . valueOf ( data [ 10 ] ) == 1 ) act . setText ( "ACTIVE" ) ; else act . setText ( " INACTIVE" ) ; birth . setText ( data [ 5 ] ) ; if ( data [ 6 ] . equalsIgnoreCase ( "" ) ) data [ 6 ] = "[no data]" ; cont . setText ( data [ 6 ] ) ; if ( data [ 7 ] . equalsIgnoreCase ( "" ) ) data [ 7 ] = "[no data]" ; addr . setText ( data [ 7 ] ) ; date . setText ( data [ 8 ] ) ; if ( data [ 11 ] == null ) t = "[no last active]" ; else if ( data [ 11 ] != null && act . getText ( ) . equals ( "ACTIVE" ) ) t = "[currently active]" ; else t = data [ 11 ] ; lastDate . setText ( t ) ; fn = data [ 1 ] ; ln = data [ 2 ] ; send . setText ( "send to " + data [ 2 ] + "  " + data [ 1 ] ) ; update . setText ( "update info of " + data [ 1 ] ) ; secure . setText ( "reset password of " + data [ 1 ] ) ; age . setText ( String . valueOf ( new Methods ( ) . DateToAge ( data [ 5 ] ) ) ) ; update_info = data ; }
tr	7	public boolean configurarCuentaDeUsuario ( UsuarioModel pUser ) { if ( ! pUser . getNombre ( ) . equals ( "" ) && ! pUser . getPais ( ) . equals ( "" ) && ! pUser . getExperiencia ( ) . equals ( "" ) && ! pUser . getGenero ( ) . equals ( "" ) && ! pUser . getGeneros ( ) . equals ( "" ) && ! pUser . getEmail ( ) . equals ( "" ) && ! pUser . getUser ( ) . equals ( "" ) ) { RepositoriesFactory factory = new RepositoriesFactory ( ) ; IRepositorioUsuarios userRepository = factory . getUserRespositorie ( ) ; return userRepository . guardarInformacionAdicional ( pUser ) ; } else { return false ; } }
tr	0	public Holder ( ) { System . out . println ( "Holder created" ) ; }
tr	8	@ Override public void act ( ) { this . threshold ++ ; switch ( this . mode ) { case WAIT : double part1 = Math . pow ( ( this . player . getCenterX ( ) - this . getCenterX ( ) ) , 2 ) ; double part2 = Math . pow ( ( this . player . getCenterY ( ) - this . getCenterY ( ) ) , 2 ) ; double underRadical = part1 + part2 ; if ( ( int ) Math . sqrt ( underRadical ) / YSPanel . TILE_WIDTH < 4 ) { this . targetX = player . getX ( ) ; this . targetY = player . getY ( ) ; this . threshold = 0 ; this . mode = Mode . ATTACK ; } break ; case ATTACK : if ( threshold > MAX_THRESHOLD || this . moveTowardsTarget ( this . targetX , this . targetY ) ) { this . mode = Mode . return ; threshold = 0 ; } break ; case return : if ( threshold > MAX_THRESHOLD || this . moveTowardsTarget ( homeX , homeY ) ) { this . mode = Mode . WAIT ; threshold = 0 ; } break ; } }
tr	5	public void outputBarChart ( ) { System . out . println ( "Overall grade distribution:" ) ; int [ ] frequency = new int [ 11 ] ; for ( int [ ] studentGrades : grades ) { for ( int grade : studentGrades ) ++ frequency [ grade / 10 ] ; } for ( int count = 0 ; count < frequency . length ; count ++ ) { if ( count == 10 ) System . out . printf ( "%5d: " , 100 ) ; else System . out . printf ( "%02d-%02d: " , count * 10 , count * 10 + 9 ) ; for ( int stars = 0 ; stars < frequency [ count ] ; stars ++ ) System . out . print ( "*" ) ; System . out . println ( ) ; } }
tr	7	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( Items . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( Items . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( Items . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( Items . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { try { new Items ( ) . setVisible ( true ) ; } catch ( SQLException ex ) { Logger . getLogger ( Items . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } } } ) ; }
tr	3	public List < PayloadSubjectExceptionData > getExceptions ( ) throws Exception { if ( this . exceptions == null ) { this . exceptions = new ArrayList < PayloadSubjectExceptionData > ( ) ; NodeList exceptions = Utilities . selectNodes ( this . getDocument ( ) , "/dc:DCTransaction/dc:GetDataBySubjectRs/dc:PayloadSubjectExceptions/dc:PayloadSubjectException" , XMLLabels . STANDARD_NAMESPACES ) ; if ( exceptions != null ) { for ( int i = 0 ; i < exceptions . getLength ( ) ; ++ i ) { Node exception = exceptions . item ( i ) ; this . exceptions . add ( new PayloadSubjectExceptionData ( exception ) ) ; } } } return this . exceptions ; }
tr	6	public void update ( double deltaTime ) { if ( ! producing ) { producing = true ; for ( EnumResource resource : inputs ) { if ( location . getPlanetResource ( resource ) . getQuantity ( ) <= 0 ) producing = false ; } if ( producing ) { for ( EnumResource resource : inputs ) { location . subtractResourceQuantity ( resource , 1 ) ; } } } else { timePassed += deltaTime ; if ( timePassed > productionTime * 86400 ) { location . addResourceQuantity ( output , 1 ) ; owner . incrementBalance ( MainGame . resourcesMap . get ( output ) . getBasePrice ( ) * 0.10f ) ; timePassed = 0 ; producing = false ; } } }
tr	8	public static String getAFullMessage ( String [ ] finalWords , SocketChannel s ) throws IOException { ByteBuffer b = ByteBuffer . allocateDirect ( Global . BUFFER_LENGTH ) ; String retour = "" ; String m ; String token ; int i = 0 ; boolean continuer = true ; while ( continuer && i < Global . BUFFER_LENGTH ) { if ( s . read ( b ) == - 1 ) { Utilitaires . out ( "Fr\u00E9quence 2" , 2 , true ) ; continuer = false ; } if ( s . socket ( ) . isClosed ( ) ) { Utilitaires . out ( "Socket ferm\u00E9e !" ) ; throw new IOException ( ) ; } i ++ ; b . flip ( ) ; m = buffToString ( b ) ; retour += m ; b . clear ( ) ; Scanner sc = new Scanner ( m ) ; while ( sc . hasNext ( ) && continuer ) { token = sc . next ( ) ; for ( String w : finalWords ) { if ( token . equals ( w ) ) { continuer = false ; break ; } } } sc . close ( ) ; } return retour ; }
tr	6	public static void SetBusqueda ( String dir ) { if ( dir . contains ( "http" ) == true || dir . contains ( "www" ) == true || dir . contains ( ".com" ) == true || dir . contains ( ".es" ) == true ) { dir = dir . replace ( "http://" , "" ) ; dir = dir . replace ( "https://" , "" ) ; try { web . getEngine ( ) . load ( "http://" + dir ) ; } catch ( Exception e ) { web . getEngine ( ) . load ( "https://" + dir ) ; } } else { String search = getStaticWords ( dir ) ; try { web . getEngine ( ) . load ( search ) ; } catch ( Exception e ) { } } }
tr	6	@ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( obj instanceof DescribeComponentsResult == false ) return false ; DescribeComponentsResult other = ( DescribeComponentsResult ) obj ; if ( other . getComponentInfos ( ) == null ^ this . getComponentInfos ( ) == null ) return false ; if ( other . getComponentInfos ( ) != null && other . getComponentInfos ( ) . equals ( this . getComponentInfos ( ) ) == false ) return false ; return true ; }
tr	0	public TimeStamp ( long t ) { this . t = t ; }
tr	1	public void executar ( AmbienteExecucao ambiente ) { try { comando . executar ( ambiente ) ; } catch ( IdentificadorJaDeclaradoException | IdentificadorNaoDeclaradoException e ) { e . printStackTrace ( ) ; } }
tr	7	public void trackFile ( String str ) { Path path = Paths . get ( str ) ; WatchService watchService = null ; try { watchService = path . getFileSystem ( ) . newWatchService ( ) ; path . register ( watchService , StandardWatchEventKinds . ENTRY_MODIFY ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } for ( ; ; ) { WatchKey key = null ; try { key = watchService . take ( ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } for ( WatchEvent < ? > event : key . pollEvents ( ) ) { switch ( event . kind ( ) . name ( ) ) { case "OVERFLOW" : System . out . println ( "We lost some events!" ) ; break ; case "ENTRY_MODIFY" : System . out . println ( "File " + event . context ( ) + " is changed." ) ; break ; } } key . reset ( ) ; } }
