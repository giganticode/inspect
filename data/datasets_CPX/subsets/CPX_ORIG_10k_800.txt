tr	7	public ArrayList < Title > loadTitles ( String ... constrains ) { ArrayList < Title > list = new ArrayList < Title > ( ) ; Statement statement = null ; ResultSet resultSet = null ; String where = whereCreator ( constrains ) ; try { statement = db . createStatement ( ) ; System . out . println ( "SELECT * FROM title " + where + ";" ) ; resultSet = statement . executeQuery ( "SELECT * FROM title " + where + ";" ) ; while ( resultSet . next ( ) ) { Title item = new Title ( Integer . parseInt ( resultSet . getString ( "title_number" ) ) , resultSet . getString ( "market_code" ) , resultSet . getString ( "iban" ) , resultSet . getString ( "bic" ) , Integer . parseInt ( ( resultSet . getString ( "broker_number" ) != null ? resultSet . getString ( "broker_number" ) : "-1" ) ) , resultSet . getString ( "created_day" ) , double . parseDouble ( resultSet . getString ( "initial_value" ) ) , resultSet . getString ( "initial_value_currency" ) ) ; list . add ( item ) ; } resultSet . close ( ) ; statement . close ( ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; } finally { if ( statement != null ) { try { statement . close ( ) ; } catch ( SQLException e ) { } } if ( resultSet != null ) { try { resultSet . close ( ) ; } catch ( SQLException e ) { } } } return list ; }
tr	0	@ Override public byte getByte ( long index , int offset ) { assert offset <= structLength - 1 : offset ; return ohm . getByte ( index * structLength + offset ) ; }
tr	5	static void updatestatus ( int m ) { switch ( m ) { case 1 : status . setText ( "Drag to create an entity" ) ; break ; case 2 : status . setText ( "Drag to create an bubble" ) ; break ; case 3 : status . setText ( "Drag to create an data store" ) ; break ; case 4 : status . setText ( "Drag to create an data flow arrow" ) ; break ; case 6 : status . setText ( "Drag to create an control flow arrow" ) ; break ; default : status . setText ( "" ) ; } }
tr	3	public void registerNamedComponent ( Component component ) { if ( component . getName ( ) == null || "" . equals ( component . getName ( ) ) ) { throw new IllegalArgumentException ( "Component name must be set if it's going to be registered." ) ; } if ( namedComponents . containsKey ( component . getName ( ) ) ) { } namedComponents . put ( component . getName ( ) , component ) ; }
tr	1	public static String getFile ( File file ) throws IOException { BufferedReader reader = new BufferedReader ( new FileReader ( file ) ) ; StringBuilder sb = new StringBuilder ( ) ; char [ ] buffer = new char [ 1024 ] ; int len = 0 ; while ( ( len = reader . read ( buffer ) ) != - 1 ) { sb . append ( buffer , 0 , len ) ; } reader . close ( ) ; return sb . toString ( ) ; }
tr	7	public List < List < String >> partition ( String s ) { List < List < String >> result = new ArrayList < > ( ) ; if ( s == null || s . length ( ) == 0 ) return result ; boolean isP [ ] [ ] = new boolean [ s . length ( ) ] [ s . length ( ) ] ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { isP [ i ] [ i ] = true ; } for ( int i = 0 ; i + 1 < s . length ( ) ; i ++ ) { isP [ i ] [ i + 1 ] = s . charAt ( i ) == s . charAt ( i + 1 ) ; } for ( int i = 0 , j = 2 ; j < s . length ( ) ; j ++ ) { for ( int k = i , l = j ; l < s . length ( ) ; k ++ , l ++ ) { isP [ k ] [ l ] = isP [ k + 1 ] [ l - 1 ] && s . charAt ( k ) == s . charAt ( l ) ; } } dfs ( s , 0 , result , new ArrayList < String > ( ) , isP ) ; return result ; }
tr	4	private Token asString ( char quot ) throws IOException { final StringBuffer sb = new StringBuffer ( ) ; final int lineno = getLine ( ) ; for ( char cc ; ( cc = _in . next ( ) ) != EOF ; ) { if ( cc == quot ) return new Other ( sb . toString ( ) , lineno ) ; if ( cc == \ ) { cc = _in . next ( ) ; if ( cc == EOF ) break ; } sb . append ( cc ) ; } throw error ( "unclosed string literal" , lineno ) ; }
tr	7	private JSONWriter append ( String string ) throws JSONException { if ( string == null ) { throw new JSONException ( "Null pointer" ) ; } if ( this . mode == o || this . mode == a ) { try { if ( this . , && this . mode == a ) { this . writer . write (   ) ; } this . writer . write ( string ) ; } catch ( IOException e ) { throw new JSONException ( e ) ; } if ( this . mode == o ) { this . mode = k ; } this . , = true ; return this ; } throw new JSONException ( "Value out of sequence." ) ; }
tr	5	@ Override protected void fillDataEditorPanel ( JPanel dataEditorPanel ) { audiences = getAudiencesArray ( ) ; subjects = getSubjectsArray ( ) ; professors = getProfessorsArray ( ) ; groups = getGroupsArray ( ) ; dataEditorPanel . add ( GUIUtils . createLabel ( "\u0414\u0435\u043D\u044C" ) ) ; dayComboBox = new JComboBox < > ( ) ; dayComboBox . setModel ( new DefaultComboBoxModel ( PairModel . DAY_NAMES ) ) ; dataEditorPanel . add ( dayComboBox ) ; dataEditorPanel . add ( GUIUtils . createLabel ( "\u041D\u0435\u0434\u0435\u043B\u044F" ) ) ; weekComboBox = new JComboBox < > ( ) ; weekComboBox . setModel ( new DefaultComboBoxModel ( PairModel . WEEK_NAMES ) ) ; dataEditorPanel . add ( weekComboBox ) ; dataEditorPanel . add ( GUIUtils . createLabel ( "\u041D\u043E\u043C\u0435\u0440" ) ) ; numberSpinner = new JSpinner ( ) ; numberSpinner . setModel ( new SpinnerNumberModel ( short . valueOf ( ( short ) 1 ) , short . valueOf ( ( short ) 0 ) , short . valueOf ( ( short ) 10 ) , short . valueOf ( ( short ) 1 ) ) ) ; numberSpinner . addChangeListener ( new ChangeListener ( ) { @ Override public void stateChanged ( ChangeEvent e ) { if ( numberSpinner . getValue ( ) == null ) return ; short value = ( short ) numberSpinner . getValue ( ) ; boolean timeComboBoxesEnable = ( value == 0 ) ; timeStartSpinner . setEnabled ( timeComboBoxesEnable ) ; timeEndSpinner . setEnabled ( timeComboBoxesEnable ) ; } } ) ; dataEditorPanel . add ( numberSpinner ) ; dataEditorPanel . add ( GUIUtils . createLabel ( "\u041D\u0430\u0447\u0430\u043B\u043E" ) ) ; timeStartSpinner = new JSpinner ( new SpinnerDateModel ( ) ) ; timeStartSpinner . setEnabled ( false ) ; JSpinner . DateEditor timeEditor = new JSpinner . DateEditor ( timeStartSpinner , "HH:mm:ss" ) ; timeStartSpinner . setEditor ( timeEditor ) ; dataEditorPanel . add ( timeStartSpinner ) ; dataEditorPanel . add ( GUIUtils . createLabel ( "\u041A\u043E\u043D\u0435\u0446" ) ) ; timeEndSpinner = new JSpinner ( new SpinnerDateModel ( ) ) ; timeEndSpinner . setEnabled ( false ) ; timeEditor = new JSpinner . DateEditor ( timeEndSpinner , "HH:mm:ss" ) ; timeEndSpinner . setEditor ( timeEditor ) ; dataEditorPanel . add ( timeEndSpinner ) ; dataEditorPanel . add ( GUIUtils . createLabel ( "\u0410\u0443\u0434\u0438\u0442\u043E\u0440\u0438\u044F" ) ) ; audienceComboBox = new JComboBox < > ( ) ; String [ ] name = new String [ audiences . length ] ; for ( int i = 0 ; i < audiences . length ; i ++ ) { name [ i ] = audiences [ i ] . getFullNumber ( ) ; } audienceComboBox . setModel ( new DefaultComboBoxModel ( name ) ) ; dataEditorPanel . add ( audienceComboBox ) ; dataEditorPanel . add ( GUIUtils . createLabel ( "\u041F\u0440\u0435\u0434\u043C\u0435\u0442" ) ) ; subjectComboBox = new JComboBox < > ( ) ; name = new String [ subjects . length ] ; for ( int i = 0 ; i < subjects . length ; i ++ ) { name [ i ] = subjects [ i ] . getName ( ) ; } subjectComboBox . setModel ( new DefaultComboBoxModel ( name ) ) ; dataEditorPanel . add ( subjectComboBox ) ; dataEditorPanel . add ( GUIUtils . createLabel ( "\u041F\u0440\u0435\u043F\u043E\u0434\u0430\u0432\u0430\u0442\u0435\u043B\u044C" ) ) ; professorComboBox = new JComboBox < > ( ) ; name = new String [ professors . length ] ; for ( int i = 0 ; i < professors . length ; i ++ ) { name [ i ] = professors [ i ] . getName ( ) ; } professorComboBox . setModel ( new DefaultComboBoxModel ( name ) ) ; dataEditorPanel . add ( professorComboBox ) ; dataEditorPanel . add ( GUIUtils . createLabel ( "\u0413\u0440\u0443\u043F\u043F\u0430" ) ) ; groupComboBox = new JComboBox < > ( ) ; name = new String [ groups . length ] ; for ( int i = 0 ; i < groups . length ; i ++ ) { name [ i ] = groups [ i ] . getName ( ) ; } groupComboBox . setModel ( new DefaultComboBoxModel ( name ) ) ; dataEditorPanel . add ( groupComboBox ) ; }
tr	0	public TimerThread ( Timeable what , int howOften ) { this ( what , howOften , - 1 ) ; }
tr	0	public void setUserId ( long userId ) { this . userId = userId ; }
tr	1	public void set ( int index , Object element ) throws illegalIndexException { if ( index < 0 ) { throw new illegalIndexException ( ) ; } tablica_stosu [ index ] = element ; }
tr	5	public String reverseVowels ( String s ) { if ( s == null || s . isEmpty ( ) ) return s ; StringBuilder sb = new StringBuilder ( s ) ; List < Integer > list = new ArrayList < > ( ) ; for ( int i = 0 ; i < sb . length ( ) ; ++ i ) { if ( "aeiouAEIOU" . contains ( "" + sb . charAt ( i ) ) ) { list . add ( i ) ; } } Integer [ ] arr = list . toArray ( new Integer [ ] { } ) ; int i = 0 , j = arr . length - 1 ; while ( i < j ) { char ch = sb . charAt ( arr [ i ] ) ; sb . setCharAt ( arr [ i ] , sb . charAt ( arr [ j ] ) ) ; sb . setCharAt ( arr [ j ] , ch ) ; i ++ ; j -- ; } return sb . toString ( ) ; }
tr	3	public static boolean binarySearch ( BinaryTreeNode < Integer > root , BinaryTreeNode < Integer > target ) { BinaryTreeNode < Integer > current = root ; while ( current != null ) { if ( current . data > target . data ) { current = current . left ; } else if ( current . data < target . data ) { current = current . right ; } else { return true ; } } return false ; }
tr	1	protected void checkKey ( K k ) { if ( k == null ) { throw new InvalidKeyException ( "Invalid key: null." ) ; } }
tr	8	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( Hauptfenster . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( Hauptfenster . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( Hauptfenster . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( Hauptfenster . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { try { new Hauptfenster ( ) . setVisible ( true ) ; } catch ( FileNotFoundException ex ) { Logger . getLogger ( Hauptfenster . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( IOException ex ) { Logger . getLogger ( Hauptfenster . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } } } ) ; }
tr	9	private boolean r_residual_suffix ( ) { int among_var ; int v_1 ; int v_2 ; ket = cursor ; among_var = find_among_b ( a_9 , 8 ) ; if ( among_var == 0 ) { return false ; } bra = cursor ; switch ( among_var ) { case 0 : return false ; case 1 : if ( ! r_RV ( ) ) { return false ; } slice_del ( ) ; break ; case 2 : if ( ! r_RV ( ) ) { return false ; } slice_del ( ) ; v_1 = limit - cursor ; lab0 : do { ket = cursor ; if ( ! ( eq_s_b ( 1 , "u" ) ) ) { cursor = limit - v_1 ; break lab0 ; } bra = cursor ; v_2 = limit - cursor ; if ( ! ( eq_s_b ( 1 , "g" ) ) ) { cursor = limit - v_1 ; break lab0 ; } cursor = limit - v_2 ; if ( ! r_RV ( ) ) { cursor = limit - v_1 ; break lab0 ; } slice_del ( ) ; } while ( false ) ; break ; } return true ; }
tr	7	protected final short get_action ( int state , int sym ) { short tag ; int first , last , probe ; short [ ] row = action_tab [ state ] ; if ( row . length < 20 ) for ( probe = 0 ; probe < row . length ; probe ++ ) { tag = row [ probe ++ ] ; if ( tag == sym || tag == - 1 ) { return row [ probe ] ; } } else { first = 0 ; last = ( row . length - 1 ) / 2 - 1 ; while ( first <= last ) { probe = ( first + last ) / 2 ; if ( sym == row [ probe * 2 ] ) return row [ probe * 2 + 1 ] ; else if ( sym > row [ probe * 2 ] ) first = probe + 1 ; else last = probe - 1 ; } return row [ row . length - 1 ] ; } return 0 ; }
tr	1	@ Override public void propertyChange ( PropertyChangeEvent evt ) { setModelProperty ( evt . getPropertyName ( ) , evt . getNewValue ( ) ) ; for ( AbstractPageView view : registeredViews ) { view . modelPropertyChange ( evt ) ; } }
tr	5	public void handlePorterCommand ( Command command ) { System . out . println ( "handlePorterCommand" ) ; if ( command instanceof CreateGame ) { handlePorterCommand ( ( CreateGame ) command ) ; } if ( command instanceof JoinGame ) { handlePorterCommand ( ( JoinGame ) command ) ; } if ( command instanceof LeaveGame ) { handlePorterCommand ( ( LeaveGame ) command ) ; } if ( command instanceof GetGames ) { handlePorterCommand ( ( GetGames ) command ) ; } if ( command instanceof PlaceDisc ) { handlePorterCommand ( ( PlaceDisc ) command ) ; } }
tr	3	public boolean nextLetter ( char c ) { boolean retVal = false ; setGoBack ( 0 ) ; switch ( state ) { case NOT_COLLECTING_TOKEN : retVal = handleNOT_COLLECTING_TOKEN ( c ) ; break ; case COLLECTING_TOKEN : retVal = handleCOLLECT_TOKEN ( c ) ; break ; case COLLECT_STRING : retVal = handleCOLLECT_STRING ( c ) ; break ; } return retVal ; }
tr	0	public static void showNewTimeWindow ( ) { timeBo . showNewTime ( ) ; }
tr	6	public boolean shellCollideCheck ( Shell shell ) { if ( deadTime != 0 ) return false ; float xD = shell . x - x ; float yD = shell . y - y ; if ( xD > - 16 && xD < 16 ) { if ( yD > - height && yD < shell . height ) { world . sound . play ( Art . samples [ Art . SAMPLE_MARIO_KICK ] , this , 1 , 1 , 1 ) ; dead = true ; xa = 0 ; ya = 1 ; deadTime = 100 ; if ( world . recorder != null ) world . recorder . shellKillRecord ( this ) ; return true ; } } return false ; }
tr	2	public static double [ ] [ ] makeGear ( int nTeeth ) { int n = 4 * nTeeth ; double P [ ] [ ] = new double [ n + 2 ] [ 6 ] ; for ( int i = 0 ; i <= n ; i += 2 ) { double theta = 2 * Math . PI * i / n ; double r = i % 4 == 0 ? 1 : 1 - Math . PI / nTeeth ; P [ i ] [ 0 ] = P [ i + 1 ] [ 0 ] = r * Math . cos ( theta ) ; P [ i ] [ 1 ] = P [ i + 1 ] [ 1 ] = r * Math . sin ( theta ) ; P [ i ] [ 2 ] = P [ i + 1 ] [ 2 ] = 0 ; P [ i ] [ 3 ] = Math . cos ( theta - Math . PI / 4 ) ; P [ i ] [ 4 ] = Math . sin ( theta - Math . PI / 4 ) ; P [ i ] [ 5 ] = 0 ; P [ i + 1 ] [ 3 ] = Math . cos ( theta + Math . PI / 4 ) ; P [ i + 1 ] [ 4 ] = Math . sin ( theta + Math . PI / 4 ) ; P [ i + 1 ] [ 5 ] = 0 ; } return P ; }
tr	8	@ EventHandler ( priority = EventPriority . NORMAL ) public void onChat ( final AsyncPlayerChatEvent event ) { if ( Bukkit . getServer ( ) . getPluginManager ( ) . getPlugin ( "mcMMO" ) != null ) { if ( ! Users . getProfile ( event . getPlayer ( ) . getName ( ) ) . getAdminChatMode ( ) ) { if ( event . isCancelled ( ) ) { return ; } } } else if ( event . isCancelled ( ) ) { return ; } try { final Player player = event . getPlayer ( ) ; for ( final IRCChannel c : MonsterIRC . getChannels ( ) ) { if ( c . getChatType ( ) == ChatType . MTADMINCHAT ) { continue ; } if ( c . getChatType ( ) == ChatType . TOWNYCHAT ) { continue ; } MonsterIRCListener . handleMessage ( player , c , event . getMessage ( ) ) ; } } catch ( final Exception e ) { IRC . debug ( e ) ; } }
tr	2	private void exiting ( ) { if ( connectionHandler != null && connectionHandler . isConnected ( ) ) connectionHandler . disconnect ( ) ; }
tr	8	private String [ ] splitMultipartHeader ( String sb ) { ArrayList < String > headers = new ArrayList < String > ( 1 ) ; int nameStart ; int nameEnd ; int colonEnd ; int valueStart ; int valueEnd ; nameStart = HttpPostBodyUtil . findNonWhitespace ( sb , 0 ) ; for ( nameEnd = nameStart ; nameEnd < sb . length ( ) ; nameEnd ++ ) { char ch = sb . charAt ( nameEnd ) ; if ( ch == : || Character . isWhitespace ( ch ) ) { break ; } } for ( colonEnd = nameEnd ; colonEnd < sb . length ( ) ; colonEnd ++ ) { if ( sb . charAt ( colonEnd ) == : ) { colonEnd ++ ; break ; } } valueStart = HttpPostBodyUtil . findNonWhitespace ( sb , colonEnd ) ; valueEnd = HttpPostBodyUtil . findEndOfString ( sb ) ; headers . add ( sb . substring ( nameStart , nameEnd ) ) ; String svalue = sb . substring ( valueStart , valueEnd ) ; String [ ] values = null ; if ( svalue . indexOf ( ";" ) >= 0 ) { values = svalue . split ( ";" ) ; } else { values = svalue . split ( " " ) ; } for ( String value : values ) { headers . add ( value . trim ( ) ) ; } String [ ] array = new String [ headers . size ( ) ] ; for ( int i = 0 ; i < headers . size ( ) ; i ++ ) { array [ i ] = headers . get ( i ) ; } return array ; }
tr	1	public static final int bitsInInts ( int numBits ) { if ( numBits < 0 ) throw new IllegalArgumentException ( "numBits < 0" ) ; return ( int ) ( ( numBits + ( Integer . SIZE - 1 ) ) / Integer . SIZE ) ; }
tr	8	public static void main ( String [ ] args ) { EvolvingGlobalProblemSetInitialisation starter = new EvolvingGlobalProblemSetInitialisation ( ) ; starter . initLanguage ( new char [ ] { 0 , 1 } , 10 , "(1(01*0)*1|0)*" ) ; int solutionFoundCounter = 0 ; int noSolutionFound = 0 ; List < long > cycleCount = new LinkedList < long > ( ) ; long tmpCycle ; long timeStamp ; int [ ] problemCount = new int [ 25 ] ; int [ ] candidatesCount = new int [ 1 ] ; int [ ] noCycles = new int [ 2 ] ; problemCount [ 0 ] = 3 ; problemCount [ 1 ] = 6 ; problemCount [ 2 ] = 9 ; problemCount [ 3 ] = 12 ; problemCount [ 4 ] = 15 ; problemCount [ 5 ] = 18 ; problemCount [ 6 ] = 21 ; problemCount [ 7 ] = 24 ; problemCount [ 8 ] = 27 ; problemCount [ 9 ] = 30 ; problemCount [ 10 ] = 33 ; problemCount [ 11 ] = 36 ; problemCount [ 12 ] = 39 ; problemCount [ 13 ] = 42 ; problemCount [ 14 ] = 45 ; problemCount [ 15 ] = 48 ; problemCount [ 16 ] = 51 ; problemCount [ 17 ] = 54 ; problemCount [ 18 ] = 57 ; problemCount [ 19 ] = 60 ; problemCount [ 20 ] = 63 ; problemCount [ 21 ] = 66 ; problemCount [ 22 ] = 69 ; problemCount [ 23 ] = 72 ; problemCount [ 24 ] = 75 ; candidatesCount [ 0 ] = 50 ; problemCount [ 0 ] = 100 ; noCycles [ 0 ] = 250 ; noCycles [ 1 ] = 500 ; int pc = 0 ; int cc = 0 ; int nc = 0 ; for ( int x = 0 ; x < 1 ; x ++ ) { System . out . println ( "x:" + x ) ; for ( int n = 0 ; n < 25 ; n ++ ) { DateFormat df = new SimpleDateFormat ( "yyyy-MM-dd_HH_mm_ss" ) ; Logger l = new Logger ( "E_G_PS_" + df . format ( new Date ( ) ) + ".log" , true ) ; pc = problemCount [ n ] ; cc = candidatesCount [ 0 ] ; nc = noCycles [ 1 ] ; l . log ( "Problem Count: " + pc ) ; l . log ( "CandidatesCount: " + cc ) ; l . log ( "Max Cycles: " + nc ) ; solutionFoundCounter = 0 ; noSolutionFound = 0 ; cycleCount = new LinkedList < long > ( ) ; for ( int i = 0 ; i < 100 ; i ++ ) { timeStamp = System . currentTimeMillis ( ) ; starter . initProblems ( pc ) ; starter . initCandidates ( cc ) ; tmpCycle = starter . startEvolution ( nc ) ; l . log ( i + ": finished (" + ( System . currentTimeMillis ( ) - timeStamp ) + "ms  " + tmpCycle + "cycles)" ) ; if ( starter . getWinner ( ) != null ) { solutionFoundCounter ++ ; cycleCount . add ( tmpCycle ) ; l . log ( i + ": Solution found." ) ; } else { noSolutionFound ++ ; l . log ( i + ": No solution found." ) ; } } long max = 0 ; long min = 10000 ; long sum = 0 ; for ( long no : cycleCount ) { sum += no ; max = ( no > max ? no : max ) ; min = ( no < min ? no : min ) ; } l . log ( "Solution Found: " + solutionFoundCounter ) ; l . log ( "Avg cycles: " + ( cycleCount . size ( ) > 0 ? sum / cycleCount . size ( ) : 0 ) ) ; l . log ( "Max cycles: " + max ) ; l . log ( "Min cycles: " + min ) ; l . log ( "No solution found: " + noSolutionFound ) ; l . finish ( ) ; } } }
tr	0	private void prepareToolbar ( ) { toolbar = new ToolBar ( "Animation Manager Tools" ) ; toolbar . add ( newFrameButton = new JButton ( newFrameIcon ) ) ; toolbar . add ( newAnimationButton = new JButton ( newAnimationIcon ) ) ; newFrameButton . setToolTipText ( "Create New Frame" ) ; newAnimationButton . setToolTipText ( "Create New Animation" ) ; newFrameButton . addActionListener ( this ) ; newAnimationButton . addActionListener ( this ) ; JTextField tmp = new JTextField ( ) ; tmp . setPreferredSize ( new Dimension ( 200 , 50 ) ) ; tmp . setDragEnabled ( true ) ; }
tr	9	public int deleteAllTriples ( String Index_DIR ) { Store store ; boolean continueAdd = true ; try { String idUrl = "<" + graphUri + "/ID#" + Index_DIR + ">" ; store = new Store ( storeUrl ) ; String sparqlQuery = "SELECT ?p ?o FROM <" + graphUri + "> WHERE { " + idUrl + " ?p ?o } " ; String result = store . query ( sparqlQuery , Store . OutputFormat . TAB_SEPARATED ) ; int i = 0 ; String predicate , object ; for ( String triple : result . split ( "\n" ) ) { if ( ! ( triple . indexOf ( "?p" ) == 0 || triple . indexOf ( "#" ) == 0 ) ) { int j = 1 ; predicate = "" ; object = "" ; for ( String component : triple . split ( "\t" ) ) { if ( j == 1 ) predicate = component . trim ( ) ; if ( j == 2 ) object = component . trim ( ) ; j ++ ; } i ++ ; String sqlDelete = "DELETE { GRAPH <" + graphUri + "> { " + idUrl + " " + predicate + " ?o } } WHERE { " + idUrl + " " + predicate + " ?o }" ; String response1 = store . update ( sqlDelete ) ; if ( response1 . indexOf ( "error" ) >= 0 ) { return 0 ; } } } return 1 ; } catch ( MalformedURLException e ) { message = e . getMessage ( ) ; return 0 ; } catch ( IOException e ) { message = e . getMessage ( ) ; return 0 ; } }
tr	8	private void bookingTableMouseClicked ( java . awt . event . MouseEvent evt ) { if ( bookingTable . getSelectedRow ( ) > - 1 ) { int selectedRowIndex = bookingTable . getSelectedRow ( ) ; int bookingId = ( Integer ) bookingTableModel . getValueAt ( selectedRowIndex , 0 ) ; Booking currentBooking = null ; ArrayList < Booking > bookingList ; bookingList = ctr . getBookings ( ) ; for ( Booking booking : bookingList ) { if ( booking . getBookingId ( ) == bookingId ) { ctr . setCurrentBooking ( booking ) ; currentBooking = booking ; } } if ( currentBooking != null ) { bookingDetailModel . clear ( ) ; ArrayList < Guest > roomGuestList ; roomGuestList = ctr . getBookingDetailsFromDB ( currentBooking ) ; ArrayList < Room > roomList ; roomList = ctr . getRooms ( ) ; int roomSize = 0 ; for ( Room room : roomList ) { if ( currentBooking . getRoomNo ( ) == room . getRoomNo ( ) ) { roomSize = room . getRoomSize ( ) ; } } for ( int i = 0 ; i < roomGuestList . size ( ) ; i ++ ) { bookingDetailModel . addElement ( roomGuestList . get ( i ) ) ; } bookingDetailsJList . setModel ( bookingDetailModel ) ; bookingIdLabel . setText ( "" + ( Integer ) bookingTableModel . getValueAt ( selectedRowIndex , 0 ) ) ; bookingOwnerLabel . setText ( "" + ( Integer ) bookingTableModel . getValueAt ( selectedRowIndex , 1 ) ) ; roomNoLabel . setText ( "" + ( Integer ) bookingTableModel . getValueAt ( selectedRowIndex , 2 ) ) ; agencyLabel . setText ( "" + bookingTableModel . getValueAt ( selectedRowIndex , 3 ) ) ; checkInLabel . setText ( "" + bookingTableModel . getValueAt ( selectedRowIndex , 4 ) ) ; checkOutLabel . setText ( "" + bookingTableModel . getValueAt ( selectedRowIndex , 5 ) ) ; noOfGuestsInRoomLabel . setText ( "" + roomGuestList . size ( ) + "/" + roomSize ) ; bookingDetailsJList1 . setModel ( bookingDetailModel ) ; bookingIdLabel3 . setText ( "" + ( Integer ) bookingTableModel . getValueAt ( selectedRowIndex , 0 ) ) ; bookingOwnerLabel3 . setText ( "" + ( Integer ) bookingTableModel . getValueAt ( selectedRowIndex , 1 ) ) ; roomNoLabel3 . setText ( "" + ( Integer ) bookingTableModel . getValueAt ( selectedRowIndex , 2 ) ) ; agencyLabel3 . setText ( "" + bookingTableModel . getValueAt ( selectedRowIndex , 3 ) ) ; checkInLabel3 . setText ( "" + bookingTableModel . getValueAt ( selectedRowIndex , 4 ) ) ; checkOutLabel3 . setText ( "" + bookingTableModel . getValueAt ( selectedRowIndex , 5 ) ) ; noOfGuestsInRoomLabel3 . setText ( "" + roomGuestList . size ( ) + "/" + roomSize ) ; if ( evt . getClickCount ( ) == 2 ) { jTabbedPane . setSelectedIndex ( 4 ) ; } } } }
tr	8	@ Override public boolean equals ( Object obj ) { CouchDB4k c = ( CouchDB4k ) obj ; return ( data3 . equals ( c . data3 ) && data4 . equals ( c . data4 ) && data0 . equals ( c . data0 ) && data7 . equals ( c . data7 ) && data5 . equals ( c . data5 ) && Arrays . equals ( strings , c . strings ) && data1 . equals ( c . data1 ) && Arrays . equals ( integers2 , c . integers2 ) && moreNested . equals ( c . moreNested ) ) ; }
tr	0	@ Override public void paint ( Graphics g ) { Graphics2D canvas = ( Graphics2D ) g ; clearCanvas ( canvas ) ; drawRectangle ( canvas ) ; }
tr	7	public synchronized void nextGeneration ( ) { generation ++ ; Arrays . fill ( tmp , 0 ) ; for ( int x = 0 ; x < maxx ; ++ x ) { int xminor = ( x + maxx - 1 ) % maxx ; int xmajor = ( x + 1 ) % maxx ; for ( int y = 0 ; y < maxy ; ++ y ) { int yminor = ( y + maxy - 1 ) % maxy ; int ymajor = ( y + 1 ) % maxy ; int here = maxx * y + x ; int neighbors = f ( grid [ maxx * yminor + xminor ] ) + f ( grid [ maxx * yminor + x ] ) + f ( grid [ maxx * yminor + xmajor ] ) + f ( grid [ maxx * y + xminor ] ) + f ( grid [ maxx * y + xmajor ] ) + f ( grid [ maxx * ymajor + xminor ] ) + f ( grid [ maxx * ymajor + x ] ) + f ( grid [ maxx * ymajor + xmajor ] ) ; if ( grid [ here ] > 0 ) { if ( neighbors < 2 ) { tmp [ here ] = 0 ; } else if ( neighbors == 2 || neighbors == 3 ) { tmp [ here ] = grid [ here ] + 1 ; } else { tmp [ here ] = 0 ; } } else { if ( neighbors == 3 ) { tmp [ here ] = 1 ; } } } } int [ ] t = grid ; grid = tmp ; tmp = t ; }
tr	3	private void buildReport ( ParseNode current , int indent , StringBuilder b ) { while ( current != null ) { if ( current . Terminal == null ) { for ( int i = 0 ; i < indent ; i ++ ) b . append ( "  " ) ; b . append ( current . ProductionRule . toString ( ) ) ; b . append ( '' ) ; buildReport ( current . FirstChild , indent + 1 , b ) ; } current = current . Sibling ; } }
tr	1	public static List < Appointment > findByVenue ( long venueId ) throws SQLException { List < Appointment > aAppt = new ArrayList < Appointment > ( ) ; ResultSet resultSet = Data . _find ( Appointment . class . getSimpleName ( ) , "venueId" , String . valueOf ( venueId ) ) ; while ( resultSet . next ( ) ) { aAppt . add ( Appointment . createOneFromResultSet ( resultSet ) ) ; } return aAppt ; }
tr	6	private void init1 ( byte [ ] data ) throws Exception { int CRLFIndex = 0 ; for ( int i = 0 ; i < data . length ; i ++ ) { if ( data [ i ] == HTTP . CR && data [ i + 1 ] == HTTP . LF ) { byte temp [ ] = Arrays . copyOfRange ( data , CRLFIndex , i ) ; if ( CRLFIndex == 0 ) { parseRequestLine ( new String ( temp ) ) ; } else { parseRequestHeaderLine ( new String ( temp ) ) ; } CRLFIndex = i += 2 ; if ( data [ i ] == HTTP . CR && data [ i + 1 ] == HTTP . LF ) { int len = getContentLength ( ) ; CRLFIndex += 2 ; body = Arrays . copyOfRange ( data , CRLFIndex , CRLFIndex + len ) ; parseRequestBody ( body ) ; break ; } } } }
tr	1	public String getName ( ) { if ( name == null ) return "World" ; else return name ; }
tr	3	@ Override public void endElement ( String uri , String localName , String qName ) throws SAXException { PlayXMLEnum playXMLEnum = PlayXMLEnum . valueOf ( qName . toUpperCase ( ) ) ; if ( playXMLEnum == PlayXMLEnum . DATE ) { int curId ; synchronized ( XMLPlaysHandler . class ) { curId = ++ dateId ; } currentPlay . addDate ( curId , parseTime ( currPlayDate ) ) ; } else if ( playXMLEnum == PlayXMLEnum . PLAY ) { addPlay ( currentPlay ) ; } else if ( playXMLEnum == PlayXMLEnum . DESCRIPTION ) { currentPlay . setDescription ( currentDesc . toString ( ) ) ; } currPlayEnum = null ; }
tr	5	private int processDADDInst ( DADD dadd ) { String opCode = dadd . getOpcode ( ) . name ( ) ; int instOrder = dadd . getOrder ( ) ; String src1n = "" ; String src2n = "" ; if ( dadd . getState ( ) . equals ( State . ISSUE_COMP ) ) { boolean src1 = ! dataHaz . checkRAWHazard ( dadd . getSrc1 ( ) , dadd ) ; boolean src2 = ! dataHaz . checkRAWHazard ( dadd . getSrc2 ( ) , dadd ) ; if ( src1 && src2 ) { long src1v = regMem . getRegValue ( dadd . getSrc1 ( ) . getId ( ) ) ; long src2v = regMem . getRegValue ( dadd . getSrc2 ( ) . getId ( ) ) ; dadd . getSrc1 ( ) . setValue ( src1v . intValue ( ) ) ; dadd . getSrc2 ( ) . setValue ( src2v . intValue ( ) ) ; log . debug ( "opCode " + "[" + instOrder + "]" + " instruction read from Register Memory." ) ; log . debug ( "Source1 value is: " + opCode + "[" + instOrder + "]" + src1v . intValue ( ) + " Register: " + dadd . getSrc1 ( ) . getId ( ) . name ( ) ) ; log . debug ( "Source2 value is: " + opCode + "[" + instOrder + "]" + src1v . intValue ( ) + " Register: " + dadd . getSrc2 ( ) . getId ( ) . name ( ) ) ; dadd . clearRawHazard ( ) ; dadd . setState ( State . READ ) ; } else { dadd . setRawHazard ( ) ; ResultMgr . getInstance ( ) . setRawHazard ( dadd . getRawInst ( ) ) ; if ( ! src1 ) { src1n = dadd . getSrc1 ( ) . getName ( ) ; log . debug ( opCode + "[" + instOrder + "]" + " Source registers " + src1n + " is already busy. RAW hazard detected." ) ; } if ( ! src2 ) { src2n = dadd . getSrc2 ( ) . getName ( ) ; log . debug ( opCode + "[" + instOrder + "]" + " Source registers " + src2n + " is already busy. RAW hazard detected." ) ; } } } return 0 ; }
tr	8	public void run ( ) { ParallelWarteClass paraWait = new ParallelWarteClass ( 10000 ) ; paraWait . start ( ) ; while ( ! ( HWaccess . readInt ( Adressen . LaufbandDrehen . ordinal ( ) ) == 1 ) && paraWait . isAlive ( ) ) { try { Thread . sleep ( 150 ) ; } catch ( InterruptedException e ) { interrupt ( ) ; } } if ( ! paraWait . isAlive ( ) ) { interrupt ( ) ; return ; } else { paraWait . interrupt ( ) ; } paraWait = new ParallelWarteClass ( 10000 ) ; paraWait . start ( ) ; while ( ! ( HWaccess . readInt ( Adressen . LaufbandDrehen . ordinal ( ) ) == 0 ) && paraWait . isAlive ( ) ) { try { Thread . sleep ( 150 ) ; } catch ( InterruptedException e ) { this . interrupt ( ) ; } } if ( ! paraWait . isAlive ( ) ) { interrupt ( ) ; } else { paraWait . interrupt ( ) ; } result = true ; }
tr	2	public GuardedSingleton ( ) { super ( ) ; synchronized ( INSTANCE_COUNTS ) { Integer count = INSTANCE_COUNTS . get ( getClass ( ) ) ; if ( count == null ) { INSTANCE_COUNTS . put ( getClass ( ) , 1 ) ; } else if ( count >= 1 ) { count += 1 ; INSTANCE_COUNTS . put ( getClass ( ) , count ) ; throw new IllegalStateException ( "Singleton was instantiated more than once. " + "Instance count: " + count ) ; } } }
tr	5	private void initMenuBar ( ) { JMenuBar menuBar = new JMenuBar ( ) ; JMenu mnFile = new JMenu ( "File" ) ; { JMenuItem mntmRestart = new JMenuItem ( "Restart" ) ; mntmRestart . setEnabled ( ! clientMode ) ; mntmRestart . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { DEBUGLOG . fine ( "Restarting game" ) ; initialize ( ) ; reset ( ) ; } } ) ; mnFile . add ( mntmRestart ) ; JMenuItem mntmExit = new JMenuItem ( "Exit" ) ; mntmExit . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { quit ( ) ; } } ) ; mnFile . add ( mntmExit ) ; } menuBar . add ( mnFile ) ; JMenu mnConfig = new JMenu ( "Config" ) ; { mnConfig . setEnabled ( ! clientMode ) ; ButtonGroup algorithmGroup = new ButtonGroup ( ) ; int idx = 0 ; for ( SortAlgorithm < ? > sort : config . getAllAlgorithms ( ) ) { final int index = idx ++ ; final JMenuItem item = new JRadioButtonMenuItem ( sort . toString ( ) ) ; item . setSelected ( config . getAlgorithm ( ) . equals ( sort ) ) ; item . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { DEBUGLOG . config ( "Set algorithm to " + config . getAllAlgorithms ( ) . get ( index ) ) ; config = Configuration . deriveWithNewSortIdx ( config , index ) ; initCards ( ) ; reset ( ) ; } } ) ; mnConfig . add ( item ) ; algorithmGroup . add ( item ) ; } mnConfig . add ( new JSeparator ( ) ) ; JMenu mnSize = new JMenu ( "Number of cards" ) ; { ButtonGroup sizeGroup = new ButtonGroup ( ) ; for ( int i = MIN_SIZE ; i <= MAX_SIZE ; i ++ ) { final int newSize = i ; JMenuItem item = new JRadioButtonMenuItem ( Integer . toString ( newSize ) ) ; item . setSelected ( i == size ) ; item . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { DEBUGLOG . config ( "Changed size to " + newSize ) ; config = Configuration . deriveWithNewSize ( config , newSize ) ; initCards ( ) ; initialize ( ) ; } } ) ; sizeGroup . add ( item ) ; mnSize . add ( item ) ; } } mnConfig . add ( mnSize ) ; JMenu mnType = new JMenu ( "Value type" ) ; { final ButtonGroup typeGroup = new ButtonGroup ( ) ; final ValueType [ ] types = ValueType . values ( ) ; for ( int i = 0 ; i < types . length ; i ++ ) { final ValueType type = types [ i ] ; JMenuItem item = new JRadioButtonMenuItem ( type . toString ( ) ) ; item . setSelected ( type == config . type ) ; item . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { DEBUGLOG . config ( "Changed type to " + type ) ; config = Configuration . deriveWithNewType ( config , type ) ; initCards ( ) ; initialize ( ) ; } } ) ; typeGroup . add ( item ) ; mnType . add ( item ) ; } } mnConfig . add ( mnType ) ; JMenu mnMode = new JMenu ( "Values" ) ; { final ButtonGroup kindGroup = new ButtonGroup ( ) ; final ValueMode [ ] modes = ValueMode . values ( ) ; for ( int i = 0 ; i < modes . length ; i ++ ) { final ValueMode mode = modes [ i ] ; JMenuItem item = new JRadioButtonMenuItem ( mode . toString ( ) ) ; item . setSelected ( mode == config . mode ) ; item . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { DEBUGLOG . config ( "Changed mode to " + mode ) ; config = Configuration . deriveWithNewMode ( config , mode ) ; initCards ( ) ; initialize ( ) ; } } ) ; kindGroup . add ( item ) ; mnMode . add ( item ) ; } } mnConfig . add ( mnMode ) ; } menuBar . add ( mnConfig ) ; frame . setJMenuBar ( menuBar ) ; }
tr	3	public void execute ( ) { Session session = null ; String _commandString ; String _output ; int _countCommands = 0 ; int _index = 0 ; this . result . append ( "*******************************************************\n" ) ; this . result . append ( "Started processing Unix Commands On Server :" ) ; this . result . append ( this . hostName ) ; this . result . append ( "\n" ) ; this . result . append ( "*******************************************************\n" ) ; _countCommands = this . commands . size ( ) ; while ( _countCommands > _index ) { _commandString = this . commands . get ( _index ) ; this . result . append ( "Executing :" ) ; this . result . append ( _commandString ) ; this . result . append ( "\n" ) ; this . result . append ( "+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n" ) ; try { session = connectServer . openSession ( ) ; _output = executeCommand ( session , _commandString ) ; this . result . append ( _output ) ; } catch ( IOException e ) { AtomShellException _shellException = new AtomShellException ( e ) ; _shellException . setCustomMessage ( "Unable to Open a Session on Server IP :" + this . hostName ) ; } catch ( AtomShellException e ) { this . result . append ( e . getCustomMessage ( ) ) ; } this . result . append ( "+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n" ) ; _index ++ ; } session . close ( ) ; connectServer . close ( ) ; }
tr	2	public int generarBoleto ( int sucursal_id , int usuario_id ) { Connection cn = conexion . Conectar ( ) ; PreparedStatement pst ; PreparedStatement pst2 ; ResultSet rs ; int idObtenido = 0 ; String queryInsertar = "INSERT INTO boletos(sucursal_id  usuario_id) VALUES (" + sucursal_id + " " + usuario_id + ")" ; String queryObtenerId = "SELECT max(boleto_id) as id FROM boletos" ; try { pst = cn . prepareStatement ( queryInsertar ) ; pst2 = cn . prepareStatement ( queryObtenerId ) ; pst . executeUpdate ( ) ; rs = pst2 . executeQuery ( ) ; while ( rs . next ( ) ) { idObtenido = rs . getInt ( "id" ) ; } } catch ( SQLException ex ) { JOptionPane . showMessageDialog ( null , "Error al generar el boleto: " + ex ) ; } return idObtenido ; }
tr	4	public JSONObject put ( String key , Object value ) throws JSONException { String pooled ; if ( key == null ) { throw new NullPointerException ( "Null key." ) ; } if ( value != null ) { testValidity ( value ) ; pooled = ( String ) keyPool . get ( key ) ; if ( pooled == null ) { if ( keyPool . size ( ) >= keyPoolSize ) { keyPool = new HashMap ( keyPoolSize ) ; } keyPool . put ( key , key ) ; } else { key = pooled ; } this . map . put ( key , value ) ; } else { this . remove ( key ) ; } return this ; }
tr	6	public boolean isSymmetricHelper ( TreeNode node1 , TreeNode node2 ) { if ( node1 == null && node2 == null ) return true ; if ( node1 == null || node2 == null ) return false ; if ( node1 . val != node2 . val ) return false ; return isSymmetricHelper ( node1 . left , node2 . right ) && isSymmetricHelper ( node1 . right , node2 . left ) ; }
tr	0	public Kill ( Point killed , int prio ) { super ( prio ) ; killedEntity = killed ; }
tr	5	public int read ( int addr ) { if ( ! getBit ( addr , 12 ) && getBit ( addr , 7 ) ) { mRAM . setRS ( getBit ( addr , 9 ) ) ; mData = mRAM . read ( addr & 7F ) ; } if ( ! getBit ( addr , 12 ) && ! getBit ( addr , 7 ) ) { mData = mStella . read ( addr & 3F ) ; } if ( getBit ( addr , 12 ) ) { mData = mGame . read ( addr ) ; } return mData ; }
tr	1	public static OmahaBuilder < ? > builder ( ) { return new Builder2 ( ) ; }
tr	5	private ArrayList < Integer > loadIdsFaltasAlumnos ( ) { ArrayList < Integer > list = new ArrayList < Integer > ( ) ; if ( this . nova ) { return list ; } String SQL1 = "SELECT idSgd FROM tuta_incidenciessgd WHERE idCas=" + this . id_actuacio ; try { Statement st = client . getMysql ( ) . createStatement ( ) ; ResultSet rs1 = client . getMysql ( ) . getResultSet ( SQL1 , st ) ; while ( rs1 != null && rs1 . next ( ) ) { list . add ( rs1 . getInt ( 1 ) ) ; } if ( rs1 != null ) { rs1 . close ( ) ; st . close ( ) ; } } catch ( SQLException ex ) { Logger . getLogger ( Actuacio . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } return list ; }
tr	4	public boolean intersectsWith ( Timeslot otherTimeslot ) { if ( otherTimeslot == null ) { return false ; } if ( this . day != otherTimeslot . getDay ( ) ) { return false ; } if ( this . endTime <= otherTimeslot . getStartTime ( ) ) { return false ; } else if ( this . startTime >= otherTimeslot . getEndTime ( ) ) { return false ; } else { return true ; } }
tr	3	@ Override public boolean equals ( Object obj ) { if ( ! super . equals ( obj ) ) return false ; if ( ! ( obj instanceof BlockNode ) ) return false ; BlockNode other = ( BlockNode ) obj ; if ( ! - . equals ( other . - ) ) return false ; return true ; }
tr	2	public void run ( ) { for ( String name : names ) { Apple apple = new Apple ( name ) ; dispatcher . dataReceived ( apple ) ; System . out . println ( "Built apple: " + apple ) ; try { Thread . sleep ( 900 ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } dispatcher . dataReceived ( new Key ( all ( Apple . class ) ) ) ; }
tr	0	public Console getConsole ( ) { return console ; }
tr	6	public int [ ] likertJakauma ( ) { int [ ] jakaumat = new int [ 5 ] ; int ykkoset = 0 ; int kakkoset = 0 ; int kolmoset = 0 ; int neloset = 0 ; int vitoset = 0 ; for ( int arvo : this . aineisto ) { if ( arvo == 1 ) { ykkoset ++ ; } else if ( arvo == 2 ) { kakkoset ++ ; } else if ( arvo == 3 ) { kolmoset ++ ; } else if ( arvo == 4 ) { neloset ++ ; } else if ( arvo == 5 ) { vitoset ++ ; } } double summa = ykkoset + kakkoset + kolmoset + neloset + vitoset ; jakaumat [ 0 ] = ( int ) ( 100 * ( 1.0 * ykkoset / summa ) ) ; jakaumat [ 1 ] = ( int ) ( 100 * ( 1.0 * kakkoset / summa ) ) ; jakaumat [ 2 ] = ( int ) ( 100 * ( 1.0 * kolmoset / summa ) ) ; jakaumat [ 3 ] = ( int ) ( 100 * ( 1.0 * neloset / summa ) ) ; jakaumat [ 4 ] = ( int ) ( 100 * ( 1.0 * vitoset / summa ) ) ; return jakaumat ; }
tr	9	public static void main ( String [ ] args ) { CallParser parser = new CallParser ( ) ; parser . addLine ( 0 , "static sequence [pipe]function" ) ; parser . addLine ( 1 , "[o]:[p] s{var:I32=0}[ss] [s]:[^]a[var33  l] " ) ; parser . addLine ( 2 , "if{[qwerty]:{stuff}[xyz] xyz}: " ) ; parser . addLine ( 3 , "[a]asd[b]op[p]" ) ; parser . addLine ( 4 , ":elseif{something}:" ) ; parser . addLine ( 5 , ":elseif{somethingelse}: " ) ; parser . addLine ( 6 , "static sequence2" ) ; parser . addLine ( 7 , ":end" ) ; parser . addLine ( 8 , "EXECUTE{[a]:[>] [<  \" is sweet\"]PRINTLN  lol}" ) ; for ( Component com : parser . separateComponents ( ) ) System . out . print ( com . type + " " ) ; System . out . println ( ) ; parser . parse ( ) ; int indent = 0 ; for ( ParsedCall call : parser . calls ) { if ( call . isBlockEnd ) { indent -- ; } for ( int ind = 0 ; ind < indent ; ind ++ ) { System . out . print ( "  " ) ; } if ( call . isBlockEnd ) System . out . print ( ":" ) ; System . out . print ( "[" ) ; for ( String param : call . inParams ) { System . out . print ( param + " " ) ; } System . out . print ( "]" ) ; System . out . print ( call . callName ) ; if ( call . confNodes . length > 0 ) { System . out . print ( "{ " ) ; for ( String param : call . confNodes ) { System . out . print ( param + " " ) ; } System . out . print ( "}" ) ; } System . out . print ( "[" ) ; for ( String param : call . outParams ) { System . out . print ( param + " " ) ; } System . out . print ( "]" ) ; if ( call . isBlockStart ) { indent ++ ; System . out . print ( ":" ) ; } System . out . println ( ) ; } }
tr	9	public class < ? > getMessageClass ( boolean throwOnError , boolean ignoreCase ) { if ( myUri == null || myUri . getSchemeSpecificPart ( ) == null || myUri . getSchemeSpecificPart ( ) . isEmpty ( ) ) return null ; String [ ] names = myUri . getSchemeSpecificPart ( ) . split ( ":" ) ; if ( ! "message" . equals ( names [ 0 ] ) ) return null ; String typeName ; if ( names . length == 2 ) typeName = names [ 1 ] ; else if ( names . length == 3 ) typeName = names [ 1 ] + "." + names [ 2 ] ; else if ( names . length >= 4 ) typeName = names [ 1 ] + "." + names [ 2 ] ; else return null ; class < ? > messageType = _nameToClassCache . get ( typeName ) ; if ( messageType == null ) { try { messageType = class . forName ( typeName ) ; } catch ( ClassNotFoundException e ) { _log . info ( "Unable to create class for " + messageType + ".  This may be because we are using a .Net name" , e ) ; } if ( messageType != null ) { registerMessageType ( messageType ) ; } } return messageType ; }
tr	6	protected void UpdateLineColumn ( char c ) { column ++ ; if ( prevCharIsLF ) { prevCharIsLF = false ; line += ( column = 1 ) ; } else if ( prevCharIsCR ) { prevCharIsCR = false ; if ( c == '' ) { prevCharIsLF = true ; } else line += ( column = 1 ) ; } switch ( c ) { case '' : prevCharIsCR = true ; break ; case '' : prevCharIsLF = true ; break ; case 	 : column -- ; column += ( tabSize - ( column % tabSize ) ) ; break ; default : break ; } bufline [ bufpos ] = line ; bufcolumn [ bufpos ] = column ; }
tr	7	public void write ( int bits , int width ) throws IOException { if ( bits == 0 && width == 0 ) { return ; } if ( width <= 0 || width > 32 ) { throw new IOException ( "Bad write width." ) ; } while ( width > 0 ) { int actual = width ; if ( actual > this . vacant ) { actual = this . vacant ; } this . unwritten |= ( ( bits >>> ( width - actual ) ) & BitInputStream . mask [ actual ] ) << ( this . vacant - actual ) ; width -= actual ; nrBits += actual ; this . vacant -= actual ; if ( this . vacant == 0 ) { this . out . write ( this . unwritten ) ; this . unwritten = 0 ; this . vacant = 8 ; } } }
tr	2	private static String processCase ( int n , int j ) { StringBuilder builder = new StringBuilder ( ) ; String candidate = 1 + StringUtils . repeat ( "0" , n - 2 ) + 1 ; for ( int i = 0 ; i < j ; i ++ ) { String answer = generateJamCoin ( bumpCandidate ( candidate ) ) ; final String proof = proveCandidate ( answer ) . trim ( ) ; if ( Strings . isNullOrEmpty ( proof ) ) { i -- ; candidate = bumpCandidate ( candidate ) ; continue ; } builder . append ( proof ) ; builder . append ( "\n" ) ; candidate = answer ; } return builder . toString ( ) ; }
tr	1	public static boolean updateKurssi ( Kurssi kurssi ) { Connection con = connect ( ) ; try { PreparedStatement updateKurssi = con . prepareStatement ( "UPDATE kurssi SET nimi=? WHERE kurssiID=?" ) ; updateKurssi . setString ( 1 , kurssi . getNimi ( ) ) ; updateKurssi . setInt ( 2 , kurssi . getId ( ) ) ; updateKurssi . executeUpdate ( ) ; return true ; } catch ( SQLException ex ) { Logger . getLogger ( Database . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; return false ; } finally { closeConnection ( con ) ; } }
tr	2	private void log ( PrintStream stream , String message , Object source ) { if ( source != null ) { message = "[" + source . getClass ( ) . getSimpleName ( ) + "] " + message ; } else { message = " " + message ; } message = DateTime . format ( "[%d.%M.%y %h:%m:%s.%n]" ) + message ; stream . println ( message ) ; for ( LoggerListener listener : listeners ) { listener . logged ( new LogEvent ( message , false ) ) ; } }
tr	8	public Room2D ( Room2D toCopy , ExitDirection fromDir , Room2D previousRoom , ArrayList < Room > explored ) { super ( toCopy ) ; if ( explored == null ) { explored = new ArrayList < Room > ( ) ; } explored . add ( this ) ; exits = new HashMap < ExitDirection , Room > ( ) ; for ( ExitDirection s : toCopy . exits . keySet ( ) ) { boolean foundExit = false ; ExitDirection reverse = reverseMapping ( s ) ; for ( Room r : explored ) { if ( toCopy . exits . get ( s ) . getDescription ( ) == r . getDescription ( ) ) { exits . put ( s , r ) ; foundExit = true ; } } if ( s == fromDir && ! foundExit ) { exits . put ( s , previousRoom ) ; } else if ( ! foundExit ) { exits . put ( s , new Room2D ( ( Room2D ) toCopy . exits . get ( s ) , reverse , this , explored ) ) ; } } this . items = new Inventory ( toCopy . items ) ; ArrayList < Monster > monsterList = new ArrayList < Monster > ( ) ; for ( Monster m : toCopy . monsters ) { monsterList . add ( new Monster2D ( ( Monster2D ) m ) ) ; } monsters = monsterList ; this . sprite = toCopy . sprite ; this . bounds = toCopy . bounds ; this . exitImages = new HashMap < ExitDirection , SerializableBufferedImage > ( toCopy . exitImages ) ; this . exitBounds = new HashMap < ExitDirection , Rectangle > ( toCopy . exitBounds ) ; }
tr	7	public String normalizeItem ( String tag ) { tag = tag . replaceAll ( "\\s*NUM\\s*" , " " ) ; tag = StringUtility . trimString ( tag ) ; if ( StringUtility . isMatchedNullSafe ( tag , "\\w" ) ) { tag = tag . replaceAll ( "\\[" , "[*" ) ; tag = tag . replaceAll ( "\\]" , "*]" ) ; String [ ] twSegs = tag . split ( "[\\]\\[]" ) ; StringBuilder tagSB = new StringBuilder ( ) ; for ( int j = 0 ; j < twSegs . length ; j ++ ) { StringBuilder outSB = new StringBuilder ( ) ; if ( StringUtility . isMatchedNullSafe ( twSegs [ j ] , "\\*" ) ) { twSegs [ j ] = twSegs [ j ] . replaceAll ( "\\*" , "" ) ; String [ ] tagWords = twSegs [ j ] . split ( "\\s+" ) ; outSB . append ( [ ) ; for ( int i = 0 ; i < tagWords . length ; i ++ ) { tagWords [ i ] = this . myLearnerUtility . getWordFormUtility ( ) . getSingular ( tagWords [ i ] ) ; outSB . append ( tagWords [ i ] ) ; outSB . append ( " " ) ; } outSB . deleteCharAt ( outSB . length ( ) - 1 ) ; outSB . append ( ] ) ; } else if ( StringUtility . isMatchedNullSafe ( twSegs [ j ] , "\\w" ) ) { String [ ] tagWords = twSegs [ j ] . split ( "\\s+" ) ; for ( int i = 0 ; i < tagWords . length ; i ++ ) { tagWords [ i ] = this . myLearnerUtility . getWordFormUtility ( ) . getSingular ( tagWords [ i ] ) ; outSB . append ( tagWords [ i ] ) ; outSB . append ( " " ) ; } outSB . deleteCharAt ( outSB . length ( ) - 1 ) ; } String out = outSB . toString ( ) ; if ( StringUtility . isMatchedNullSafe ( out , "\\w" ) ) { tagSB . append ( out . toString ( ) ) ; tagSB . append (   ) ; } } tagSB . deleteCharAt ( tagSB . length ( ) - 1 ) ; tag = tagSB . toString ( ) ; tag = tag . replaceAll ( "\\s+" , " " ) ; } return tag ; }
tr	1	public static boolean getBoolValue ( Node node , String name ) { Node att = get_named_attribute ( node , name ) ; if ( att != null ) { return boolean . valueOf ( att . getNodeValue ( ) ) . booleanValue ( ) ; } else { return false ; } }
tr	7	@ Override public void handleCommand ( CommandMessage m ) { String args [ ] = m . getArgs ( ) ; switch ( args . length ) { case 0 : case 1 : return ; default : switch ( args [ 1 ] ) { case "stop" : logger . info ( "request stop command: " + args [ 2 ] ) ; plugins . stopPlugin ( args [ 2 ] ) ; ph . sendMessage ( "Plugin " + args [ 2 ] + " byl zastaven." ) ; return ; case "start" : logger . info ( "request start command: " + args [ 2 ] ) ; if ( plugins . startPlugin ( args [ 2 ] ) ) { ph . sendMessage ( "Plugin " + args [ 2 ] + " byl spu\u0161t\u011Bn." ) ; } return ; } case 2 : switch ( args [ 1 ] ) { case "reload" : plugins . reload ( ) ; ph . sendMessage ( "Plugin " + args [ 2 ] + " byl zastaven." ) ; return ; } break ; } }
tr	2	public String pedidoPorVendedor ( Vendedor vendedor ) { String retorno = "" ; for ( Pedido p : lista ) { if ( p . getVendedor ( ) . getCodigo ( ) == vendedor . getCodigo ( ) ) retorno += p . toString ( ) ; } return retorno ; }
tr	5	public static boolean interactSlot ( int slot , String action ) { if ( ! checkIndex ( slot ) || ! setExpanded ( true ) ) return false ; if ( action == null || action . length ( ) == 0 ) return useSlot ( slot ) ; WidgetChild child = getMainChild ( slot ) ; if ( child . visible ( ) ) { return child . interact ( action ) ; } return false ; }
tr	7	public long piece_can_reach ( int piece_index , int steps ) { long piece_bb = 1 << piece_index ; int piece_type = getPieceType ( piece_bb ) ; int piece_colour = piece_type & 01 ; long friend_bb = colour_bb [ piece_colour ] & ~ piece_bb ; int trap_num = trap_number [ piece_index ] ; if ( trap_num != - 1 ) { if ( ( TRAP [ trap_num ] & friend_bb ) != 0 ) { if ( ( TOUCH_TRAP [ trap_num ] & colour_bb [ piece_colour ] ) == piece_bb ) { friend_bb ^= TRAP [ trap_num ] ; } } } long unfrozen_sq_bb = ( touching_bb ( friend_bb ) | ( touching_bb ( colour_bb [ player ] ) & piece_bb ) | ~ touching_bb ( stronger_enemy_bb [ piece_type ] ) ) ; if ( ( unfrozen_sq_bb & piece_bb ) == 0 ) { return piece_bb ; } long bad_trap_bb = 0 ; for ( int i = 0 ; i < 4 ; i ++ ) { if ( ( TOUCH_TRAP [ i ] & friend_bb ) == 0 ) { bad_trap_bb |= TRAP [ i ] ; } } long good_sq_bb = unfrozen_sq_bb & empty_bb & ~ bad_trap_bb ; long reached_bb = piece_bb ; for ( int i = 1 ; i < steps ; i ++ ) { reached_bb |= touching_bb ( reached_bb , piece_type ) & good_sq_bb ; } reached_bb |= touching_bb ( reached_bb , piece_type ) & empty_bb & ~ bad_trap_bb ; return reached_bb ; }
tr	8	void selectpanel ( ) { if ( s . gettype ( ) . endsWith ( "bubble" ) ) { modulepanel . setVisible ( false ) ; carrowpanel . setVisible ( false ) ; dspanel . setVisible ( false ) ; entitypanel . setVisible ( false ) ; bubblepanel . setVisible ( true ) ; arrowpanel . setVisible ( false ) ; } else if ( s . gettype ( ) . endsWith ( "entity" ) ) { modulepanel . setVisible ( false ) ; carrowpanel . setVisible ( false ) ; dspanel . setVisible ( false ) ; bubblepanel . setVisible ( false ) ; arrowpanel . setVisible ( false ) ; entitypanel . setVisible ( true ) ; } else if ( s . gettype ( ) . endsWith ( "flowarrow" ) ) { modulepanel . setVisible ( false ) ; carrowpanel . setVisible ( false ) ; dspanel . setVisible ( false ) ; arrowpanel . setVisible ( true ) ; bubblepanel . setVisible ( false ) ; entitypanel . setVisible ( false ) ; } else if ( s . gettype ( ) . endsWith ( "datastore" ) ) { modulepanel . setVisible ( false ) ; carrowpanel . setVisible ( false ) ; dspanel . setVisible ( true ) ; arrowpanel . setVisible ( false ) ; bubblepanel . setVisible ( false ) ; entitypanel . setVisible ( false ) ; } else if ( s . gettype ( ) . endsWith ( "ctrlarrow" ) ) { modulepanel . setVisible ( false ) ; carrowpanel . setVisible ( true ) ; dspanel . setVisible ( false ) ; arrowpanel . setVisible ( false ) ; bubblepanel . setVisible ( false ) ; entitypanel . setVisible ( false ) ; } else if ( s . gettype ( ) . endsWith ( "module" ) ) { modulepanel . setVisible ( true ) ; carrowpanel . setVisible ( false ) ; dspanel . setVisible ( false ) ; arrowpanel . setVisible ( false ) ; bubblepanel . setVisible ( false ) ; entitypanel . setVisible ( false ) ; dfd d = ( dfd ) Global . n . tabs . getComponentAt ( 0 ) ; for ( int i = 0 ; i < d . shapes . size ( ) ; i ++ ) { if ( d . shapes . get ( i ) . gettype ( ) . endsWith ( "bubble" ) ) { bubbles . addItem ( d . shapes . get ( i ) . name ) ; } } } }
tr	7	public boolean shellCollideCheck ( Shell shell ) { if ( deadTime != 0 ) return false ; float xD = shell . x - x ; float yD = shell . y - y ; if ( xD > - 16 && xD < 16 ) { if ( yD > - height && yD < shell . height ) { world . sound . play ( Art . samples [ Art . SAMPLE_MARIO_KICK ] , this , 1 , 1 , 1 ) ; xa = shell . facing * 2 ; ya = - 5 ; flyDeath = true ; if ( spriteTemplate != null ) spriteTemplate . isDead = true ; deadTime = 100 ; winged = false ; hPic = - hPic ; yPicO = - yPicO + 16 ; if ( world . recorder != null ) world . recorder . shellKillRecord ( this ) ; return true ; } } return false ; }
tr	6	public int partitionIt ( int left , int right , long pivot ) { int leftptr = left - 1 ; int rightptr = right + 1 ; while ( true ) { while ( leftptr < right && theArray [ ++ leftptr ] < pivot ) { } while ( rightptr > left && theArray [ -- rightptr ] > pivot ) { } if ( leftptr >= rightptr ) { break ; } else { swap ( leftptr , rightptr ) ; } } return leftptr ; }
tr	4	private static class < ? > getPrimitiveClass ( final class < ? > componentType ) { if ( Integer . class . isAssignableFrom ( componentType ) ) { return int . class ; } if ( double . class . isAssignableFrom ( componentType ) ) { return double . class ; } throw new UnsupportedOperationException ( "Mapping not implemented" ) ; }
tr	9	private static StringBuilder build ( final StringBuilder result , final Object subject , final int indent ) { if ( null == subject ) return result . append ( null ) ; else if ( subject . getClass ( ) . isArray ( ) ) return buildIterable ( result , new ArrayIterator ( subject ) , indent ) ; else if ( subject instanceof Map < ? , ? > ) return buildIterable ( result , ( ( Map < ? , ? > ) subject ) . entrySet ( ) . iterator ( ) , indent ) ; else if ( subject instanceof Iterable < ? > ) return buildIterable ( result , ( ( Iterable < ? > ) subject ) . iterator ( ) , indent ) ; else if ( subject instanceof Map . Entry < ? , ? > ) return buildEntry ( result , ( Map . Entry < ? , ? > ) subject , indent ) ; else return result . append ( subject . toString ( ) ) ; }
tr	1	public User getByID ( Line line ) { try { return getByID ( line . getString ( "userid" ) ) ; } catch ( Exception ex ) { } return getByID ( line . toString ( ) ) ; }
tr	5	public void dispose ( ) { getRGBPixelsMethodParam = null ; Method method = getRGBPixelsMethod ; if ( method != null ) { getRGBPixelsMethod = null ; try { method . setAccessible ( false ) ; } catch ( Exception ex ) { } } try { peer . getClass ( ) . getDeclaredMethod ( "dispose" , new class < ? > [ 0 ] ) . invoke ( peer , new class < ? > [ 0 ] ) ; } catch ( Exception ex ) { } }
tr	1	@ Override public int hashCode ( ) { int hash = 3 ; hash = 83 * hash + ( this . id != null ? this . id . hashCode ( ) : 0 ) ; return hash ; }
tr	2	public static Set < Edge > getPaintableEdges ( Triangulation triangulation ) { Set < Edge > allEdges = Sets . newHashSet ( ) ; for ( Triangle tri : triangulation . getTriangles ( ) ) { if ( triangulation . touchesSuperVertex ( tri ) ) { continue ; } Iterables . addAll ( allEdges , tri . getEdges ( ) ) ; } return allEdges ; }
tr	6	public String getRecords ( ) { StringBuilder resultado = new StringBuilder ( ) ; if ( tipo != null ) { Declaracion tmp = tipo ; TipoDeclaracion tdecl = null ; TipoRecord trec1 = null ; while ( tmp != null ) { if ( tmp instanceof TipoDeclaracion ) { resultado . append ( ".namespace Ejemplo{\n" ) ; tdecl = ( ( TipoDeclaracion ) tmp ) ; resultado . append ( "\t.class private sequential ansi sealed beforefieldinit " ) . append ( tdecl . getNombre ( ) ) ; resultado . append ( " extends [mscorlib]System.ValueType{\n" ) ; Tipo t = InfSemantica . getInstancia ( ) . tablaGlobal . get ( tdecl . getNombre ( ) ) ; TipoRecord record = ( ( TipoRecord ) t ) ; Collections . reverse ( record . tbsimbolo . lista ) ; Collections . reverse ( record . tbsimbolo . tipos ) ; for ( int i = 0 ; i < record . tbsimbolo . lista . size ( ) ; i ++ ) { if ( record . tbsimbolo . tipos . get ( i ) instanceof TipoRecord ) { trec1 = ( ( TipoRecord ) record . tbsimbolo . tipos . get ( i ) ) ; resultado . append ( "\t\t.field  public\t" ) . append ( "valuetype Ejemplo." ) . append ( trec1 . nombre ) . append ( " " ) . append ( record . tbsimbolo . lista . get ( i ) ) . append ( "\n" ) ; } else if ( record . tbsimbolo . tipos . get ( i ) instanceof TipoArray ) { } else { resultado . append ( "\t\t.field  public\t" ) . append ( record . tbsimbolo . tipos . get ( i ) . toString ( ) ) . append ( " " ) . append ( record . tbsimbolo . lista . get ( i ) ) . append ( "\n" ) ; } } resultado . append ( "\n\t}\n}\n" ) ; } tmp = tmp . getSiguiente ( ) ; } } else { resultado . append ( "" ) ; } return resultado . toString ( ) ; }
tr	4	public List < Frequencia > getFrequenciaMes ( Integer mes , Integer ano , Integer idFuncionario ) throws SQLException { List < Frequencia > mesAnterior = this . getFrequenciaMesAnterior ( mes , ano , idFuncionario ) ; List < Frequencia > mesAtual = this . getFrequenciaMesAtual ( mes , ano , idFuncionario ) ; UtilFrequencia utilFrequencia = new UtilFrequencia ( ) ; List < Frequencia > frequencias = new ArrayList < Frequencia > ( ) ; frequencias . addAll ( mesAnterior ) ; frequencias . addAll ( mesAtual ) ; List < Integer > integers = new ArrayList < Integer > ( ) ; for ( Expediente expediente : frequencias . get ( 0 ) . getFuncionario ( ) . getExpedientes ( ) ) { integers . add ( expediente . getDiaSemana ( ) ) ; } for ( Frequencia frequencia : frequencias ) { if ( ( ! integers . contains ( utilFrequencia . diasDaSemana ( frequencia . getData ( ) ) - 2 ) ) && ( frequencia . getPresenca ( ) != null ) ) { frequencia . setPresenca ( true ) ; } } return frequencias ; }
tr	8	public final JPoclASTParser . expr4_return expr4 ( ) throws RecognitionException { JPoclASTParser . expr4_return retval = new JPoclASTParser . expr4_return ( ) ; retval . start = input . < ( 1 ) ; TypeTree root_0 = null ; Token char_literal93 = null ; Token char_literal94 = null ; JPoclASTParser . expr5_return expr592 = null ; JPoclASTParser . expr2b_return expr2b95 = null ; TypeTree char_literal93_tree = null ; TypeTree char_literal94_tree = null ; RewriteRuleTokenStream stream_21 = new RewriteRuleTokenStream ( adaptor , "token 21" ) ; RewriteRuleTokenStream stream_38 = new RewriteRuleTokenStream ( adaptor , "token 38" ) ; RewriteRuleSubtreeStream stream_expr2b = new RewriteRuleSubtreeStream ( adaptor , "rule expr2b" ) ; RewriteRuleSubtreeStream stream_expr5 = new RewriteRuleSubtreeStream ( adaptor , "rule expr5" ) ; try { { { pushFollow ( FOLLOW_expr5_in_expr4970 ) ; expr592 = expr5 ( ) ; state . _fsp -- ; stream_expr5 . add ( expr592 . getTree ( ) ) ; retval . tree = root_0 ; RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream ( adaptor , "rule retval" , retval != null ? retval . tree : null ) ; root_0 = ( TypeTree ) adaptor . nil ( ) ; { adaptor . addChild ( root_0 , stream_expr5 . nextTree ( ) ) ; } retval . tree = root_0 ; } int alt22 = 2 ; alt22 = dfa22 . predict ( input ) ; switch ( alt22 ) { case 1 : { loop21 : do { int alt21 = 2 ; int LA21_0 = input . LA ( 1 ) ; if ( ( LA21_0 == 21 ) ) { alt21 = 1 ; } switch ( alt21 ) { case 1 : { char_literal93 = ( Token ) match ( input , 21 , FOLLOW_21_in_expr4979 ) ; stream_21 . add ( char_literal93 ) ; retval . tree = root_0 ; RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream ( adaptor , "rule retval" , retval != null ? retval . tree : null ) ; root_0 = ( TypeTree ) adaptor . nil ( ) ; { { TypeTree root_1 = ( TypeTree ) adaptor . nil ( ) ; root_1 = ( TypeTree ) adaptor . becomeRoot ( stream_21 . nextNode ( ) , root_1 ) ; adaptor . addChild ( root_1 , stream_retval . nextTree ( ) ) ; adaptor . addChild ( root_0 , root_1 ) ; } } retval . tree = root_0 ; } break ; default : break loop21 ; } } while ( true ) ; char_literal94 = ( Token ) match ( input , 38 , FOLLOW_38_in_expr4992 ) ; stream_38 . add ( char_literal94 ) ; pushFollow ( FOLLOW_expr2b_in_expr4994 ) ; expr2b95 = expr2b ( ) ; state . _fsp -- ; stream_expr2b . add ( expr2b95 . getTree ( ) ) ; retval . tree = root_0 ; RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream ( adaptor , "rule retval" , retval != null ? retval . tree : null ) ; root_0 = ( TypeTree ) adaptor . nil ( ) ; { { TypeTree root_1 = ( TypeTree ) adaptor . nil ( ) ; root_1 = ( TypeTree ) adaptor . becomeRoot ( stream_38 . nextNode ( ) , root_1 ) ; adaptor . addChild ( root_1 , stream_retval . nextTree ( ) ) ; adaptor . addChild ( root_1 , stream_expr2b . nextTree ( ) ) ; adaptor . addChild ( root_0 , root_1 ) ; } } retval . tree = root_0 ; } break ; } } retval . stop = input . < ( - 1 ) ; retval . tree = ( TypeTree ) adaptor . rulePostProcessing ( root_0 ) ; adaptor . setTokenBoundaries ( retval . tree , retval . start , retval . stop ) ; } catch ( RecognitionException re ) { reportError ( re ) ; } finally { } return retval ; }
tr	5	public void turn ( int choice ) { if ( choice == 0 ) { attack ( true ) ; } else if ( choice == 1 ) { chooseSpell ( ) ; } else if ( choice == 2 ) { flee ( ) ; } if ( enemy . getHealth ( ) <= 0 ) { System . out . println ( "Thy enemy lies vanquished!" ) ; endBattle ( ) ; } else { attack ( false ) ; } if ( character . getHealth ( ) <= 0 ) { System . out . println ( "Thou hast been defeated!" ) ; youLose ( ) ; } }
tr	0	public void setFPublic ( BigInteger value ) { this . fPublic = value ; }
tr	9	@ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; T2 < ? , ? > other = ( T2 < ? , ? > ) obj ; if ( _first == null ) { if ( other . _first != null ) return false ; } else if ( ! _first . equals ( other . _first ) ) return false ; if ( _second == null ) { if ( other . _second != null ) return false ; } else if ( ! _second . equals ( other . _second ) ) return false ; return true ; }
tr	0	public void setCurrency ( java . lang . String currency ) { this . currency = currency ; }
tr	9	private static void analyseChildElement ( Element element , String parentKey ) { String name = element . getName ( ) ; int index = name . indexOf ( ":" ) ; if ( index != - 1 ) { name = name . substring ( index + 1 , name . length ( ) ) ; } String key = parentKey += "." + name ; if ( element . getChildElements ( ) . size ( ) == 0 ) { String id = null ; boolean saveKeyValue = true ; String value = "" ; if ( name . equalsIgnoreCase ( "question" ) ) { id = element . getAttributeValue ( "id" ) ; if ( id != null ) { key = key + "." + id ; value = element . getAttributeValue ( "selected_ans" ) ; } } else if ( key . indexOf ( "profile" ) > 0 ) { value = element . getAttributeValue ( "value" ) ; } for ( KeyValue tmpObject : keyValues ) { if ( tmpObject . getKey ( ) . indexOf ( key ) >= 0 ) { saveKeyValue = false ; break ; } } if ( saveKeyValue ) keyValues . add ( new KeyValue ( key , value ) ) ; } else { List < Element > children = element . getChildElements ( ) ; for ( Element child : children ) { analyseChildElement ( child , key ) ; } } }
tr	3	public static String memoryUsage ( ) { long mem ; System . gc ( ) ; System . gc ( ) ; System . gc ( ) ; System . gc ( ) ; mem = Runtime . getRuntime ( ) . totalMemory ( ) - Runtime . getRuntime ( ) . freeMemory ( ) ; String res ; if ( mem < 1024 ) { res = mem + " B" ; } else if ( mem < 1024 * 1024 ) { res = mem / 1024 + " kB" ; } else if ( mem < 1024 * 1024 * 1024 ) { res = mem / 1024 / 1024 + " MB" ; } else { res = mem / 1024 / 1024 / 1024 + " GB" ; } return res ; }
tr	0	public int getMode ( ) { return MODE ; }
tr	3	private void initWindow ( ) { contentPanel = new JPanel ( ) ; contentPanel . setLayout ( new BoxLayout ( contentPanel , BoxLayout . PAGE_AXIS ) ) ; contentPanel . setBorder ( new EmptyBorder ( 5 , 5 , 5 , 5 ) ) ; tabbedPanel = new JTabbedPane ( ) ; tabbedPanel . setPreferredSize ( new Dimension ( 500 , 800 ) ) ; connectionTabPanel = new JPanel ( new FlowLayout ( FlowLayout . LEFT ) ) ; userSettingsPanel = new JPanel ( new FlowLayout ( FlowLayout . LEFT ) ) ; userSettingsPanel . setLayout ( new BoxLayout ( userSettingsPanel , BoxLayout . PAGE_AXIS ) ) ; userSettingsPanel . setBorder ( new TitledBorder ( "User Settings" ) ) ; userSettingsV1Panel = new JPanel ( new FlowLayout ( FlowLayout . LEFT ) ) ; usernameLabel = new JLabel ( "Username:" ) ; usernameText = new JTextField ( UserPreferences . PREF_USERNAME , 6 ) ; apiSecretLabel = new JLabel ( "API Secret:" ) ; apiSecretText = new JPasswordField ( UserPreferences . PREF_API_SECRET , 6 ) ; passwordLabel = new JLabel ( "Password:" ) ; passwordText = new JPasswordField ( UserPreferences . PREF_PASSWORD , 6 ) ; userSettingsV1Panel . add ( usernameLabel ) ; userSettingsV1Panel . add ( usernameText ) ; userSettingsV1Panel . add ( apiSecretLabel ) ; userSettingsV1Panel . add ( apiSecretText ) ; userSettingsV1Panel . add ( passwordLabel ) ; userSettingsV1Panel . add ( passwordText ) ; userTokenPanel = new JPanel ( new FlowLayout ( FlowLayout . LEFT ) ) ; userTokenPanel . setPreferredSize ( new Dimension ( 443 , 40 ) ) ; userTokenLabel = new JLabel ( "Token:" ) ; userTokenText = new JTextField ( UserPreferences . PREF_USERTOKEN , 10 ) ; userTokenButton = new JButton ( "Get your token" ) ; userTokenButton . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { GetToken . browse ( ) ; } } ) ; userTokenPanel . add ( userTokenLabel ) ; userTokenPanel . add ( userTokenText ) ; userTokenPanel . add ( userTokenButton ) ; userSettingsPanel . add ( userTokenPanel ) ; proxySettingsPanel = new JPanel ( new FlowLayout ( FlowLayout . LEFT ) ) ; proxyUseCheck = new JCheckBox ( "Use Proxy" , UserPreferences . PREF_USE_PROXY ) ; proxyUseCheck . addChangeListener ( new ChangeListener ( ) { @ Override public void stateChanged ( ChangeEvent e ) { if ( proxyUseCheck . isSelected ( ) ) { proxyAddressText . setEnabled ( true ) ; proxyPortText . setEnabled ( true ) ; } else { proxyAddressText . setEnabled ( false ) ; proxyPortText . setEnabled ( false ) ; } } } ) ; proxySettingsPanel . setBorder ( new TitledBorder ( "Proxy Settings" ) ) ; proxyAddressLabel = new JLabel ( "Proxy:" ) ; proxyAddressText = new JTextField ( UserPreferences . PREF_PROXY_ADDRESS , 15 ) ; proxyPortLabel = new JLabel ( "Port:" ) ; proxyPortText = new JTextField ( UserPreferences . PREF_PROXY_PORT , 3 ) ; proxySettingsPanel . add ( proxyUseCheck ) ; proxySettingsPanel . add ( proxyAddressLabel ) ; proxySettingsPanel . add ( proxyAddressText ) ; proxySettingsPanel . add ( proxyPortLabel ) ; proxySettingsPanel . add ( proxyPortText ) ; proxySettingsPanel . setPreferredSize ( new Dimension ( 455 , 60 ) ) ; serverSettingsPanel = new JPanel ( ) ; serverSettingsPanel . setLayout ( new BoxLayout ( serverSettingsPanel , BoxLayout . PAGE_AXIS ) ) ; serverSettingsPanel . setBorder ( new TitledBorder ( "Server Settings" ) ) ; serverCheckPanel = new JPanel ( new FlowLayout ( FlowLayout . LEFT ) ) ; serverCheckIntervalLabel = new JLabel ( "Server check interval (sec):" ) ; serverCheckIntervalText = new JTextField ( String . valueOf ( UserPreferences . PREF_SERVER_CHECK_INTERVAL ) , 3 ) ; autoCleanCheck = new JCheckBox ( "Delete empty folders (keeps account clean)" , UserPreferences . PREF_AUTO_CLEAN ) ; serverCheckPanel . add ( serverCheckIntervalLabel ) ; serverCheckPanel . add ( serverCheckIntervalText ) ; serverCheckPanel . add ( autoCleanCheck ) ; serverSortByPanel = new JPanel ( new FlowLayout ( FlowLayout . LEFT ) ) ; serverSortByLabel = new JLabel ( "Sort by default:" ) ; serverSortByCombo = new JComboBox < String > ( new String [ ] { "Name" , "Date" } ) ; serverSortByCombo . setSelectedIndex ( UserPreferences . PREF_BEHAVIOR_SORT_BY ) ; serverSortByPanel . add ( serverSortByLabel ) ; serverSortByPanel . add ( serverSortByCombo ) ; serverFriendPanel = new JPanel ( new FlowLayout ( FlowLayout . LEFT ) ) ; loadSharedCheck = new JCheckBox ( "Load friends' files (this could take some time to load)" , UserPreferences . PREF_LOAD_SHARED ) ; serverFriendPanel . add ( loadSharedCheck ) ; serverSettingsPanel . add ( serverCheckPanel ) ; serverSettingsPanel . add ( serverSortByPanel ) ; serverSettingsPanel . add ( serverFriendPanel ) ; serverSettingsPanel . setPreferredSize ( new Dimension ( 455 , 120 ) ) ; connectionTabPanel . add ( userSettingsPanel ) ; connectionTabPanel . add ( proxySettingsPanel ) ; connectionTabPanel . add ( serverSettingsPanel ) ; tabbedPanel . addTab ( "Connection" , null , connectionTabPanel ) ; startupSettingsPanel = new JPanel ( new FlowLayout ( FlowLayout . LEFT ) ) ; autoConnectCheck = new JCheckBox ( "Connect on start automatically" , UserPreferences . PREF_AUTO_CONNECT ) ; startInTrayCheck = new JCheckBox ( "Start in system tray" , UserPreferences . PREF_START_IN_TRAY ) ; startupSettingsPanel . setBorder ( new TitledBorder ( "Startup Settings" ) ) ; startupSettingsPanel . add ( autoConnectCheck ) ; startupSettingsPanel . add ( startInTrayCheck ) ; tabbedPanel . addTab ( "Startup" , null , startupSettingsPanel ) ; downloadSettingsPanel = new JPanel ( ) ; downloadSettingsPanel . setLayout ( new BoxLayout ( downloadSettingsPanel , BoxLayout . PAGE_AXIS ) ) ; downloadSettingsPanel . setBorder ( new TitledBorder ( "Download Settings" ) ) ; autoDownloadPanel = new JPanel ( new FlowLayout ( FlowLayout . LEFT ) ) ; autoDownloadCheck = new JCheckBox ( "Download on connect" , UserPreferences . PREF_AUTO_DOWNLOAD ) ; autoDownloadPanel . add ( autoDownloadCheck ) ; downloadTargetPanel = new JPanel ( new FlowLayout ( FlowLayout . LEFT ) ) ; downloadTargetLabel = new JLabel ( "Target:" ) ; downloadTargetText = new JTextField ( UserPreferences . PREF_DOWNLOAD_TARGET , 20 ) ; downloadTargetText . setEditable ( false ) ; fileChooserButton = new JButton ( "Browse" ) ; fileChooserButton . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { if ( fileChooser . showOpenDialog ( preferencesScreen ) == JFileChooser . APPROVE_OPTION ) { downloadTargetText . setText ( fileChooser . getSelectedFile ( ) . getAbsolutePath ( ) ) ; } } } ) ; fileChooser = new JFileChooser ( downloadTargetText . getText ( ) ) ; fileChooser . setFileSelectionMode ( JFileChooser . DIRECTORIES_ONLY ) ; fileChooser . setDialogTitle ( "Select download directory" ) ; fileChooser . setAcceptAllFileFilterUsed ( false ) ; downloadTargetPanel . add ( downloadTargetLabel ) ; downloadTargetPanel . add ( downloadTargetText ) ; downloadTargetPanel . add ( fileChooserButton ) ; downloadWhatPanel = new JPanel ( new FlowLayout ( FlowLayout . LEFT ) ) ; downloadWhatLabel = new JLabel ( "Download:" ) ; everythingRadio = new JRadioButton ( "everything" ) ; selFoldersRadio = new JRadioButton ( "selected folders" ) ; selFoldersRadio . setToolTipText ( "Right clic folder -> Add to automatic download" ) ; downloadWhatGroup = new ButtonGroup ( ) ; downloadWhatGroup . add ( everythingRadio ) ; downloadWhatGroup . add ( selFoldersRadio ) ; downloadWhatPanel . add ( downloadWhatLabel ) ; downloadWhatPanel . add ( everythingRadio ) ; downloadWhatPanel . add ( selFoldersRadio ) ; downloadPartsPanel = new JPanel ( new FlowLayout ( FlowLayout . LEFT ) ) ; maxParallelDownloadsLabel = new JLabel ( "Max parallel downloads:" ) ; maxParallelDownloadsText = new JTextField ( String . valueOf ( UserPreferences . PREF_MAX_DOWNLOADS ) , 2 ) ; downloadPartsLabel = new JLabel ( "Parts for each download:" ) ; downloadPartsText = new JTextField ( String . valueOf ( UserPreferences . PREF_DOWNLOAD_PART_COUNT ) , 2 ) ; downloadPartsPanel . add ( maxParallelDownloadsLabel ) ; downloadPartsPanel . add ( maxParallelDownloadsText ) ; downloadPartsPanel . add ( downloadPartsLabel ) ; downloadPartsPanel . add ( downloadPartsText ) ; fileSizeCheckPanel = new JPanel ( new FlowLayout ( FlowLayout . LEFT ) ) ; fileSizeCheckCheck = new JCheckBox ( "Skip download if size of the file is smaller than (MB):" , UserPreferences . PREF_FILE_SIZE_CHECK ) ; fileSizeCheckCheck . addChangeListener ( new ChangeListener ( ) { public void stateChanged ( ChangeEvent e ) { fileSizeCheckText . setEnabled ( fileSizeCheckCheck . isSelected ( ) ) ; fileSizeDeleteCheck . setEnabled ( fileSizeCheckCheck . isSelected ( ) ) ; } } ) ; fileSizeCheckText = new JTextField ( String . valueOf ( UserPreferences . PREF_FILE_SIZE_FOR_CHECK ) , 4 ) ; fileSizeCheckText . setEnabled ( fileSizeCheckCheck . isSelected ( ) ) ; fileSizeCheckPanel . add ( fileSizeCheckCheck ) ; fileSizeCheckPanel . add ( fileSizeCheckText ) ; fileSizeDeletePanel = new JPanel ( new FlowLayout ( FlowLayout . CENTER ) ) ; fileSizeDeleteCheck = new JCheckBox ( "Also delete it from server automatically" , UserPreferences . PREF_FILE_SIZE_DELETE ) ; fileSizeDeleteCheck . setEnabled ( UserPreferences . PREF_FILE_SIZE_CHECK ) ; fileSizeDeletePanel . add ( fileSizeDeleteCheck ) ; downloadSettingsPanel . add ( autoDownloadPanel ) ; downloadSettingsPanel . add ( downloadTargetPanel ) ; downloadSettingsPanel . add ( downloadWhatPanel ) ; downloadSettingsPanel . add ( downloadPartsPanel ) ; downloadSettingsPanel . add ( fileSizeCheckPanel ) ; downloadSettingsPanel . add ( fileSizeDeletePanel ) ; tabbedPanel . addTab ( "Download" , null , downloadSettingsPanel ) ; conflictSettingsPanel = new JPanel ( new FlowLayout ( FlowLayout . LEFT ) ) ; conflictSettingsPanel . setBorder ( new TitledBorder ( "Conflict Settings" ) ) ; redownloadPanel = new JPanel ( new FlowLayout ( FlowLayout . LEFT ) ) ; redownloadCheck = new JCheckBox ( "Do not ask if file already downloaded. Apply following: " , UserPreferences . PREF_DONT_ASK_DOWNLOAD_AGAIN ) ; redownloadCheck . addChangeListener ( new ChangeListener ( ) { @ Override public void stateChanged ( ChangeEvent e ) { redownloadCombo . setEnabled ( redownloadCheck . isSelected ( ) ) ; } } ) ; redownloadCombo = new JComboBox < String > ( new String [ ] { "Download again" , "Skip" , "Skip and delete" } ) ; redownloadCombo . setSelectedIndex ( UserPreferences . PREF_BEHAVIOR_DOWNLOAD_AGAIN ) ; redownloadCombo . setEnabled ( UserPreferences . PREF_DONT_ASK_DOWNLOAD_AGAIN ) ; redownloadPanel . add ( redownloadCheck ) ; redownloadPanel . add ( redownloadCombo ) ; overwritePanel = new JPanel ( new FlowLayout ( FlowLayout . LEFT ) ) ; overwriteCheck = new JCheckBox ( "Do not ask if file already exits on disc. Apply following: " , UserPreferences . PREF_DONT_ASK_OVERWRITE ) ; overwriteCheck . addChangeListener ( new ChangeListener ( ) { @ Override public void stateChanged ( ChangeEvent e ) { overwriteCombo . setEnabled ( overwriteCheck . isSelected ( ) ) ; } } ) ; overwriteComboPanel = new JPanel ( new FlowLayout ( FlowLayout . LEFT ) ) ; overwriteCombo = new JComboBox < String > ( new String [ ] { "Overwrite" , "Skip" , "Skip and delete from server" , "Skip in case of same size" , "Skip in case of same size and delete from server" } ) ; overwriteCombo . setSelectedIndex ( UserPreferences . PREF_BEHAVIOR_OVERWRITE ) ; overwriteCombo . setEnabled ( UserPreferences . PREF_DONT_ASK_OVERWRITE ) ; overwritePanel . add ( overwriteCheck ) ; overwriteComboPanel . add ( overwriteCombo ) ; conflictSettingsPanel . add ( redownloadPanel ) ; conflictSettingsPanel . add ( overwritePanel ) ; conflictSettingsPanel . add ( overwriteComboPanel ) ; tabbedPanel . addTab ( "Conflict" , null , conflictSettingsPanel ) ; buttonsPanel = new JPanel ( new FlowLayout ( FlowLayout . CENTER ) ) ; saveAndCloseButton = new JButton ( "Save & Close" ) ; saveAndCloseButton . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { if ( saveSettings ( ) ) { preferencesScreen . setVisible ( false ) ; } } } ) ; closeButton = new JButton ( "Close" ) ; closeButton . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { preferencesScreen . setVisible ( false ) ; } } ) ; buttonsPanel . add ( saveAndCloseButton ) ; buttonsPanel . add ( closeButton ) ; contentPanel . add ( tabbedPanel ) ; contentPanel . add ( buttonsPanel ) ; this . getContentPane ( ) . add ( contentPanel , BorderLayout . CENTER ) ; this . setTitle ( "Preferences" ) ; this . setSize ( new Dimension ( 490 , 370 ) ) ; this . setResizable ( false ) ; }
tr	6	@ Override public void Interpret ( Node n , Packet p ) { System . out . println ( p ) ; if ( p . NodeId != Packet . MyNodeId && p . Type . equals ( "Moved" ) ) { C . Move ( ( Point ) p . getOX ( 1 ) , ( Point ) p . getOX ( 2 ) ) ; } if ( p . NodeId != Packet . MyNodeId && p . Type . equals ( "Attacked" ) ) { C . Atack ( ( Point ) p . getOX ( 1 ) , ( Point ) p . getOX ( 2 ) ) ; } if ( p . NodeId != Packet . MyNodeId && p . Type . equals ( "Msg" ) ) { C . chat . msgRecv ( ( String ) p . getOX ( 1 ) , ( String ) p . getOX ( 2 ) ) ; } }
tr	4	static public BufferedImage cambiarColor ( BufferedImage img , Color crSeleccionado , Color crCambiar , float tolerancia ) { if ( img == null ) return null ; Color colorPixel ; for ( int i = 0 ; i < img . getWidth ( ) ; i ++ ) { for ( int j = 0 ; i < img . getHeight ( ) ; j ++ ) { colorPixel = new Color ( img . getRGB ( i , j ) ) ; if ( tolerancia > Math . sqrt ( Math . pow ( crSeleccionado . getRed ( ) - colorPixel . getRed ( ) , 2 ) + Math . pow ( crSeleccionado . getGreen ( ) - colorPixel . getGreen ( ) , 2 ) + Math . pow ( crSeleccionado . getBlue ( ) - colorPixel . getBlue ( ) , 2 ) ) ) img . setRGB ( i , j , crCambiar . getRGB ( ) ) ; } } return img ; }
tr	9	public List < Location > adjacentLocations ( Location location ) { assert location != null : "Null location passed to adjacentLocations" ; List < Location > locations = new LinkedList < Location > ( ) ; if ( location != null ) { int row = location . getRow ( ) ; int col = location . getCol ( ) ; for ( int roffset = - 1 ; roffset <= 1 ; roffset ++ ) { int nextRow = row + roffset ; if ( nextRow >= 0 && nextRow < depth ) { for ( int coffset = - 1 ; coffset <= 1 ; coffset ++ ) { int nextCol = col + coffset ; if ( nextCol >= 0 && nextCol < width && ( roffset != 0 || coffset != 0 ) ) { locations . add ( new Location ( nextRow , nextCol ) ) ; } } } } Collections . shuffle ( locations , rand ) ; } return locations ; }
tr	4	public static int Cardinality ( Object obj , Collection coll ) { if ( coll == null ) { throw new NullPointerException ( ) ; } if ( obj == null ) { throw new NullPointerException ( ) ; } for ( Object o : coll ) { if ( o . equals ( obj ) ) { total ++ ; } } return total ; }
tr	7	private void ulozitActionPerformed ( java . awt . event . ActionEvent evt ) { PanelRegistraceTymu fr = PanelRegistraceTymu . this ; EntityManager em = DBTools . getInstance ( ) . getEm ( ) ; EntityTransaction tx = DBTools . getInstance ( ) . getTx ( ) ; System . out . println ( "" ) ; System . out . println ( "ULOZIT" ) ; System . out . println ( "" ) ; String sql = "select * from kategorie where nazev=?" ; Query query = DBTools . getInstance ( ) . getEm ( ) . createNativeQuery ( sql , Kategorie . class ) ; query . setParameter ( 1 , fr . kategorieCombo . getSelectedItem ( ) . toString ( ) ) ; Kategorie kat = ( Kategorie ) query . getSingleResult ( ) ; tx . begin ( ) ; Tym tym = Tym . createTym ( fr . JmenoTymuField . getText ( ) , kat ) ; em . persist ( tym ) ; tx . commit ( ) ; tym = em . find ( Tym . class , tym . getTym_id ( ) ) ; System . out . println ( tym ) ; tx . begin ( ) ; TableModel jtm = fr . jezdecTable . getModel ( ) ; for ( int i = 0 ; i < jtm . getRowCount ( ) ; i ++ ) { long val = ( long ) jtm . getValueAt ( i , 0 ) ; if ( val == null ) { JOptionPane . showMessageDialog ( PanelRegistraceTymu . this , "Nelze ulozit! \nNebyl vybran jezdec!" , "Pozor" , JOptionPane . ERROR_MESSAGE ) ; tx . rollback ( ) ; tx . begin ( ) ; em . remove ( em . find ( Tym . class , tym . getTym_id ( ) ) ) ; tx . commit ( ) ; return ; } else { Osoba o = em . find ( Osoba . class , val ) ; System . out . println ( o ) ; TymyHasOsoby tho = TymyHasOsoby . createTymMaOsobu ( tym . getTym_id ( ) , o . getOsoba_id ( ) ) ; tho . setJe_jezdec ( true ) ; em . persist ( tho ) ; } } TableModel ptm = fr . prisediciTable . getModel ( ) ; for ( int i = 0 ; i < ptm . getRowCount ( ) ; i ++ ) { long val = ( long ) ptm . getValueAt ( i , 0 ) ; if ( val == null ) { JOptionPane . showMessageDialog ( PanelRegistraceTymu . this , "Nelze ulozit! \nNebyli vybrani vsichni prisedici!" , "Pozor" , JOptionPane . ERROR_MESSAGE ) ; tx . rollback ( ) ; tx . begin ( ) ; em . remove ( em . find ( Tym . class , tym . getTym_id ( ) ) ) ; tx . commit ( ) ; return ; } else { Osoba o = em . find ( Osoba . class , val ) ; System . out . println ( o ) ; TymyHasOsoby tho = TymyHasOsoby . createTymMaOsobu ( tym . getTym_id ( ) , o . getOsoba_id ( ) ) ; em . persist ( tho ) ; } } TableModel ktm = fr . koneTable . getModel ( ) ; for ( int i = 0 ; i < ktm . getRowCount ( ) ; i ++ ) { long val = ( long ) ktm . getValueAt ( i , 0 ) ; if ( val == null ) { JOptionPane . showMessageDialog ( PanelRegistraceTymu . this , "Nelze ulozit! \nNebyli vybrani vsichni kone!" , "Pozor" , JOptionPane . ERROR_MESSAGE ) ; tx . rollback ( ) ; tx . begin ( ) ; em . remove ( em . find ( Tym . class , tym . getTym_id ( ) ) ) ; tx . commit ( ) ; return ; } else { Kun k = em . find ( Kun . class , val ) ; System . out . println ( k ) ; TymyHasKone thk = TymyHasKone . createTymMaKone ( tym . getTym_id ( ) , k . getKun_id ( ) ) ; em . persist ( thk ) ; } } try { tx . commit ( ) ; tx . begin ( ) ; tym . setZavodId ( em . find ( Zavody . class , 1 ) ) ; em . persist ( tym ) ; tx . commit ( ) ; dispose ( ) ; } catch ( RollbackException e ) { System . out . println ( "ERROR -> rollback" ) ; JOptionPane . showMessageDialog ( PanelRegistraceTymu . this , "Do\u0161lo k chyb\u011B: " + e . getMessage ( ) , "Chyba" , JOptionPane . ERROR_MESSAGE ) ; tx . begin ( ) ; em . remove ( em . find ( Tym . class , tym . getTym_id ( ) ) ) ; tx . commit ( ) ; } }
tr	2	public static boolean isUniqueChars ( String str ) { int checker = 0 ; for ( int i = 0 ; i < str . length ( ) ; ++ i ) { int val = str . charAt ( i ) - a ; if ( ( checker & ( 1 << val ) ) > 0 ) return false ; checker |= ( 1 << val ) ; } return true ; }
tr	0	@ Test public void testQuestionDataBooleanIntQuestionStatisticsQuestionLocationString ( ) { _qd = new MyQuestionData ( _showQuestion , _questionNumber , _questionStatistics , _questionLocation , _questionString ) ; assertEquals ( _showQuestion , _qd . getShowQuestion ( ) ) ; assertEquals ( _questionNumber , _qd . getQuestionNumber ( ) ) ; assertEquals ( _questionStatistics . getCorrectlyAnswered ( ) , _qd . getCorrectlyAnswered ( ) ) ; assertEquals ( _questionStatistics . getPercentCorrect ( ) , _qd . getPercentCorrect ( ) ) ; assertEquals ( _questionStatistics . getTotalTimesAnswered ( ) , _qd . getTotalTimesAnswered ( ) ) ; assertEquals ( _questionLocation , _qd . getLocation ( ) ) ; assertEquals ( _questionString , _qd . getQuestionString ( ) ) ; }
tr	3	@ Override public void parseFile ( ) { data = new ArrayList < > ( ) ; try { Scanner in = new Scanner ( new File ( filePath ) ) ; findClasses ( ) ; while ( in . hasNext ( ) ) { String [ ] split = in . nextLine ( ) . split ( " " ) ; List < double > featureList = new ArrayList < > ( ) ; for ( int featureIterator = 0 ; featureIterator < inputs ; featureIterator ++ ) featureList . add ( double . valueOf ( split [ featureIterator ] ) ) ; List < double > output = getOutputVector ( split [ inputs ] ) ; data . add ( new DataPoint ( featureList , output ) ) ; } in . close ( ) ; } catch ( FileNotFoundException e ) { System . out . println ( "File not found for poker dataset." ) ; e . printStackTrace ( ) ; } finally { findClasses ( ) ; } }
tr	7	public String encode ( String plain ) { String key_u = key . toUpperCase ( ) ; String [ ] [ ] code_matrix = new String [ 4 ] [ 25 ] ; for ( int i = 0 ; i < 4 ; i ++ ) { char cur_c = key_u . charAt ( i ) ; if ( cur_c == J ) { cur_c = I ; } int pos = cur_c - A ; if ( pos > 8 ) { pos -- ; } for ( int j = 0 ; j < 25 ; j ++ ) { int cur_num = 25 * i + j + 1 ; String cur_str ; if ( cur_num == 100 ) { cur_str = "00" ; } else { cur_str = ( cur_num < 10 ? "0" : "" ) + cur_num ; } code_matrix [ i ] [ pos ] = cur_str ; if ( pos == 24 ) { pos = 0 ; } else { pos ++ ; } } } String cipher_text = get_c_text ( code_matrix , plain ) ; return cipher_text ; }
