va	8	public void initial ( ) throws IOException { double [ ] positions = null ; for ( int i = 0 ; i < swarm_size ; i ++ ) { positions = new double [ dimension ] ; for ( int j = 0 ; j < dimension ; j ++ ) { positions [ j ] = ( Math . random ( ) * ( range_max - range_min ) + range_min ) * ( Math . random ( ) > 0.5 ? 1 : - 1 ) ; } population [ i ] = new Particle ( positions ) ; pbest [ i ] = new Particle ( positions ) ; } allweights_1 += "generation:" + c_generation + "\n" ; allweights_1 += pbest [ 0 ] . generateText ( ) ; pbest [ 0 ] . writeFile ( "pbest" , allweights_1 ) ; gbest = new Particle ( population [ 0 ] . getPosition ( ) ) ; for ( int i = 0 ; i < swarm_size ; i ++ ) { if ( fitness ( population [ i ] ) > fitness ( gbest ) ) { gbest = new Particle ( population [ i ] . getPosition ( ) ) ; } } allweights += "generation:" + c_generation + "\n" ; allweights += gbest . generateText ( ) ; gbest . writeFile ( "gbest" , allweights ) ; double [ ] temp = new double [ dimension ] ; for ( int i = 0 ; i < swarm_size ; i ++ ) { for ( int j = 0 ; j < dimension ; j ++ ) { temp [ j ] = Math . random ( ) * vmax * ( Math . random ( ) > 0.5 ? 1 : - 1 ) ; } velocity [ i ] = temp ; temp = new double [ dimension ] ; } }
va	6	public boolean detecter_conflits ( ) { boolean avion_en_conflit = false , modele_en_conflit = false ; if ( this . phase_prete != PHASE . DEMARRAGE ) return false ; for ( Avion avion_1 : this . avions . values ( ) ) for ( Avion avion_2 : this . avions . values ( ) ) if ( avion_1 != avion_2 ) { avion_en_conflit = false ; for ( Plot plot_1 : avion_1 . getPlots ( ) ) for ( Plot plot_2 : avion_1 . getPlots ( ) ) avion_en_conflit |= ( plot_1 . distanceTo ( plot_2 ) < this . distanceEntreAvions ) ; avion_1 . setEnConflit ( avion_en_conflit ) ; modele_en_conflit |= avion_en_conflit ; } return modele_en_conflit ; }
va	7	public String getSentence ( int index ) { if ( index < 0 || index >= startSentenceBoundary . length ) return "" ; StringBuffer sb = new StringBuffer ( ) ; int start = startSentenceBoundary [ index ] ; int end = endSentenceBoundary [ index ] + 1 ; for ( int i = start ; i < end ; i ++ ) { if ( tokens . get ( i ) . equals ( "nbsp" ) ) tokens . set ( i , "nbsp;" ) ; sb . append ( tokens . get ( i ) ) ; if ( ( i < ( end - 1 ) ) && ( i == ( end - 1 ) || editSpace . get ( tokens . get ( i + 1 ) ) == null ) ) sb . append ( " " ) ; } return sb . toString ( ) ; }
va	7	public List < ConceptScheme > parse ( XMLEventReader eventReader , StartElement startElement , ZipFile zipFile ) throws XMLStreamException , IOException , ExternalRefrenceNotFoundException { this . zipFile = zipFile ; List < ConceptScheme > conceptSchemes = new ArrayList < ConceptScheme > ( ) ; boolean inConceptsElement = true ; while ( inConceptsElement ) { XMLEvent event = eventReader . nextEvent ( ) ; switch ( event . getEventType ( ) ) { case XMLEvent . START_ELEMENT : StartElement se = event . asStartElement ( ) ; if ( se . getName ( ) . getLocalPart ( ) . equalsIgnoreCase ( "ConceptScheme" ) && se . getName ( ) . getNamespaceURI ( ) . equalsIgnoreCase ( Constants . STRUCTURE_NAMESPACE ) ) { ConceptScheme cs = processConceptScheme ( se , eventReader ) ; conceptSchemes . add ( cs ) ; } break ; case XMLEvent . END_ELEMENT : EndElement endElement = event . asEndElement ( ) ; if ( endElement . getName ( ) . getLocalPart ( ) . equalsIgnoreCase ( "Concepts" ) && endElement . getName ( ) . getNamespaceURI ( ) . equalsIgnoreCase ( Constants . DEFAULT_NAMESPACE ) ) { inConceptsElement = false ; } break ; } } return conceptSchemes ; }
va	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( Henkiloikkuna . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( Henkiloikkuna . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( Henkiloikkuna . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( Henkiloikkuna . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { new Henkiloikkuna ( ) . setVisible ( true ) ; } } ) ; }
va	2	private final boolean doublec ( int j ) { if ( j < 1 ) return false ; if ( b [ j ] != b [ j - 1 ] ) return false ; return cons ( j ) ; }
va	2	public void repairIndex ( ) throws IOException { byte [ ] currentLargestKey = new byte [ keySize ] ; int maxChunk = getChunkIndex ( getFilledUpFromContentStart ( ) ) ; for ( int currentChunkId = 0 ; currentChunkId <= maxChunk ; currentChunkId ++ ) { long currentOffset = ( currentChunkId + 1 ) * getChunkSize ( ) - elementSize ; if ( currentOffset < getFilledUpFromContentStart ( ) ) { read ( currentOffset , currentLargestKey ) ; } else { read ( getFilledUpFromContentStart ( ) - elementSize , currentLargestKey ) ; } getIndex ( ) . setLargestKey ( currentChunkId , currentLargestKey ) ; } }
va	7	public static Value < ? > copyOf ( final Value < ? > value ) { if ( value == null ) { return null ; } else if ( value instanceof IntegerValue ) { return copyOf ( ( IntegerValue ) value ) ; } else if ( value instanceof StringValue ) { return copyOf ( ( StringValue ) value ) ; } else if ( value instanceof ListValue ) { return copyOf ( ( ListValue ) value ) ; } else if ( value instanceof DictionaryValue ) { return copyOf ( ( DictionaryValue ) value ) ; } else { throw new IllegalArgumentException ( ) ; } }
va	4	public double getPrice ( Task t ) { final double MAX_PRICE = 1.5 ; final double MIN_PRICE = 0.9 ; double minPrice = MAX_PRICE ; for ( Node n : nodes ) { double p = ( double ) n . getFreeResources ( ) / ( double ) n . getCpus ( ) ; p = MIN_PRICE + p * ( MAX_PRICE - MIN_PRICE ) ; if ( p < MIN_PRICE ) { p = MIN_PRICE ; } else if ( p > MAX_PRICE ) { p = MAX_PRICE ; } if ( p < minPrice ) { minPrice = p ; } } return minPrice * t . getSlo ( ) ; }
va	6	public final StartContext start ( ) throws RecognitionException { StartContext _localctx = new StartContext ( _ctx , getState ( ) ) ; enterRule ( _localctx , 0 , RULE_start ) ; int _la ; try { int _alt ; enterOuterAlt ( _localctx , 1 ) ; { setState ( 32 ) ; match ( CLASE ) ; setState ( 33 ) ; match ( ID ) ; setState ( 34 ) ; match ( { ) ; setState ( 38 ) ; _errHandler . sync ( this ) ; _alt = getInterpreter ( ) . adaptivePredict ( _input , 0 , _ctx ) ; while ( _alt != 2 && _alt != - 1 ) { if ( _alt == 1 ) { { { setState ( 35 ) ; field_decl ( ) ; } } } setState ( 40 ) ; _errHandler . sync ( this ) ; _alt = getInterpreter ( ) . adaptivePredict ( _input , 0 , _ctx ) ; } setState ( 44 ) ; _errHandler . sync ( this ) ; _la = _input . LA ( 1 ) ; while ( _la == void || _la == TIPO ) { { { setState ( 41 ) ; method_decl ( ) ; } } setState ( 46 ) ; _errHandler . sync ( this ) ; _la = _input . LA ( 1 ) ; } setState ( 47 ) ; match ( } ) ; linea ++ ; arbol . add ( "Inicio " + linea ) ; } } catch ( RecognitionException re ) { _localctx . exception = re ; _errHandler . reportError ( this , re ) ; _errHandler . recover ( this , re ) ; } finally { exitRule ( ) ; } return _localctx ; }
va	7	private void doBettingRound ( ) { boolean finishGame = false ; boolean continuePlaying = true ; int playerPlayCounter = 1 ; do { PokerPlayer currentPlayer = this . game . getPlayer ( ) ; if ( ! currentPlayer . madeAllIn ( ) ) { this . showPlayerDecisionForm ( currentPlayer ) ; } else { this . game . nextTurn ( PokerPlayerDecision . AllIn ) ; } if ( this . game . getPlayingPlayers ( ) . size ( ) == 1 ) { finishGame = true ; } if ( this . game . allPlayersHasSameBet ( ) && playerPlayCounter % this . game . getPlayingPlayers ( ) . size ( ) == 0 ) { continuePlaying = false ; } if ( ! this . game . existMoreThanOnePlayerWithoutAllInOrLeave ( ) ) { continuePlaying = false ; } playerPlayCounter ++ ; } while ( ! finishGame && continuePlaying ) ; }
va	2	private Object convertAndEnhance ( Object value ) { Object obj = BaseProxy . passValue ( value ) ; if ( obj instanceof DBObjectProxy ) { if ( ! BaseProxy . getClassName ( value ) . equals ( genericClass . getName ( ) ) ) { Map < String , String > genericInfo = new HashMap < String , String > ( ) ; genericInfo . put ( "implementation" , BaseProxy . getClassName ( value ) ) ; ( ( DBObjectProxy ) obj ) . addGenericInfo ( genericInfo ) ; } } return obj ; }
va	3	private BsNode < K , E > addRec ( BsNode < K , E > node , K key , E elem ) { if ( node == null ) { return new BsNode < K , E > ( key , elem ) ; } else { int cmp = key . compareTo ( node . getKey ( ) ) ; if ( cmp > 0 ) { node . rightNode = addRec ( node . rightNode , key , elem ) ; } else if ( cmp < 0 ) { node . leftNode = addRec ( node . leftNode , key , elem ) ; } else { } return node ; } }
va	5	public static int makeTower ( List < HeightWeight > dimension , HeightWeight base ) { int maxSize = 0 ; for ( int j = 0 ; j < dimension . size ( ) ; j ++ ) { if ( dimension . get ( j ) == base ) { continue ; } if ( base . height > dimension . get ( j ) . height && base . weight > dimension . get ( j ) . weight ) { int tsize = makeTower ( dimension , dimension . get ( j ) ) ; if ( tsize + 1 > maxSize ) { maxSize = tsize + 1 ; } } } return maxSize ; }
va	2	public final String first_input_available ( ) { String r = null ; for ( String s : input_names ( ) ) { if ( input_names . get ( s ) == null ) { r = s ; } } return r ; }
va	1	public static boolean grantTitle ( String playerName , String titleId ) throws SQLException { boolean retVal = false ; PreparedStatement ps = null ; try { ps = SQLDatabase . dbm . getConnection ( ) . prepareStatement ( "INSERT INTO players (playername  titleid) VALUES (?  ?);" ) ; ps . setString ( 1 , playerName ) ; ps . setString ( 2 , titleId ) ; retVal = ps . executeUpdate ( ) > 0 ; ps . close ( ) ; } catch ( SQLException ex ) { throw new SQLException ( "There was an error granting a player a title with the id: " + titleId + "." , ex ) ; } return retVal ; }
va	3	public int [ ] sort ( int [ ] d ) { data = ArrayUtils . copy ( d ) ; for ( int i = 0 ; i < data . length ; i ++ ) { for ( int j = data . length - 1 ; j > i ; j -- ) { if ( data [ j ] < data [ j - 1 ] ) { ArrayUtils . swap ( data , j , j - 1 ) ; } } } return data ; }
va	7	private void waitForThreads ( ) { boolean interrupted = false ; while ( ! interrupted && areAnyThreadsAlive ( threadGroup ) ) { for ( Thread t : getThreads ( threadGroup ) ) { if ( ! interrupted && t . isAlive ( ) && firstExceptionThrown . isEmpty ( ) ) try { t . join ( ) ; } catch ( InterruptedException e ) { interrupted = true ; } } } }
va	4	public String encode ( String plain ) { Morse_code m = new Morse_code ( ) ; String plain_u = plain . toUpperCase ( ) ; StringBuilder sb = new StringBuilder ( ) ; for ( char c : plain_u . toCharArray ( ) ) { if ( c !=   ) { sb . append ( m . get_morse_code ( c ) ) ; sb . append ( "x" ) ; } else { sb . append ( "x" ) ; } } sb . append ( "x" ) ; String mc = sb . toString ( ) ; int tri = mc . length ( ) / 3 ; int tri_near = tri * 3 ; if ( tri_near < mc . length ( ) ) { mc = mc . substring ( 0 , tri_near ) ; } StringBuilder cb = new StringBuilder ( ) ; for ( int i = 0 ; i < mc . length ( ) ; i += 3 ) { String cur_m = mc . substring ( i , i + 3 ) ; cb . append ( h_map . get ( cur_m ) ) ; } return cb . toString ( ) ; }
va	9	public void Pressed ( KeyEvent event ) { if ( event . getKeyCode ( ) == KeyEvent . VK_N && event . isControlDown ( ) ) { new fileEvents ( ) . fileNew ( frame ) ; } if ( event . getKeyCode ( ) == KeyEvent . VK_O && event . isControlDown ( ) ) { new fileEvents ( ) . fileOpen ( frame ) ; } if ( event . getKeyCode ( ) == KeyEvent . VK_S && event . isControlDown ( ) ) { new fileEvents ( ) . fileSave ( frame ) ; } if ( event . getKeyCode ( ) == KeyEvent . VK_S && event . isControlDown ( ) && event . isShiftDown ( ) ) { new fileEvents ( ) . fileSaveAs ( frame ) ; } if ( event . getKeyCode ( ) == KeyEvent . VK_P && event . isControlDown ( ) ) { new fileEvents ( ) . printText ( frame ) ; } if ( event . getKeyCode ( ) == KeyEvent . VK_Z && event . isControlDown ( ) ) { frame . setAction ( false ) ; new keyActions ( ) . undo ( frame ) ; frame . setAction ( true ) ; } if ( event . getKeyCode ( ) == KeyEvent . VK_Y && event . isControlDown ( ) ) { frame . setAction ( false ) ; new keyActions ( ) . redo ( frame ) ; frame . setAction ( true ) ; } }
va	9	public void saveIteratedModel ( int iters , Documents docSet ) throws IOException { String resPath = PathConfig . LdaResultsPath ; String modelName = "lda_" + iters ; ArrayList < String > lines = new ArrayList < String > ( ) ; lines . add ( "alpha = " + alpha ) ; lines . add ( "beta = " + beta ) ; lines . add ( "topicNum = " + K ) ; lines . add ( "docNum = " + M ) ; lines . add ( "termNum = " + V ) ; lines . add ( "iterations = " + iterations ) ; lines . add ( "saveStep = " + saveStep ) ; lines . add ( "beginSaveIters = " + beginSaveIters ) ; FileUtil . writeLines ( resPath + modelName + ".params" , lines ) ; BufferedWriter writer = new BufferedWriter ( new FileWriter ( resPath + modelName + ".phi" ) ) ; for ( int i = 0 ; i < K ; i ++ ) { for ( int j = 0 ; j < V ; j ++ ) { writer . write ( phi [ i ] [ j ] + "\t" ) ; } writer . write ( "\n" ) ; } writer . close ( ) ; writer = new BufferedWriter ( new FileWriter ( resPath + modelName + ".theta" ) ) ; for ( int i = 0 ; i < M ; i ++ ) { for ( int j = 0 ; j < K ; j ++ ) { writer . write ( theta [ i ] [ j ] + "\t" ) ; } writer . write ( "\n" ) ; } writer . close ( ) ; writer = new BufferedWriter ( new FileWriter ( resPath + modelName + ".tassign" ) ) ; for ( int m = 0 ; m < M ; m ++ ) { for ( int n = 0 ; n < doc [ m ] . length ; n ++ ) { writer . write ( doc [ m ] [ n ] + ":" + z [ m ] [ n ] + "\t" ) ; } writer . write ( "\n" ) ; } writer . close ( ) ; writer = new BufferedWriter ( new FileWriter ( resPath + modelName + ".twords" ) ) ; int topNum = 20 ; for ( int i = 0 ; i < K ; i ++ ) { List < Integer > tWordsIndexArray = new ArrayList < Integer > ( ) ; for ( int j = 0 ; j < V ; j ++ ) { tWordsIndexArray . add ( new Integer ( j ) ) ; } Collections . sort ( tWordsIndexArray , new LdaModel . TwordsComparable ( phi [ i ] ) ) ; writer . write ( "topic " + i + ":\t" ) ; for ( int t = 0 ; t < topNum ; t ++ ) { writer . write ( docSet . indexToTermMap . get ( tWordsIndexArray . get ( t ) ) + " " + phi [ i ] [ tWordsIndexArray . get ( t ) ] + "\t" ) ; } writer . write ( "\n" ) ; } writer . close ( ) ; writer = new BufferedWriter ( new FileWriter ( resPath + modelName + ".topicwords" ) ) ; for ( int i = 0 ; i < K ; i ++ ) { List < Integer > tWordsIndexArray = new ArrayList < Integer > ( ) ; for ( int j = 0 ; j < V ; j ++ ) { tWordsIndexArray . add ( new Integer ( j ) ) ; } Collections . sort ( tWordsIndexArray , new LdaModel . TwordsComparable ( phi [ i ] ) ) ; writer . write ( "topic " + i + ":\t" ) ; for ( int t = 0 ; t < topNum ; t ++ ) { writer . write ( docSet . indexToTermMap . get ( tWordsIndexArray . get ( t ) ) + "\t" ) ; } writer . write ( "\n" ) ; } writer . close ( ) ; }
va	9	@ Override public void write ( Object array , Output output ) { addReferenceForSerialization ( array ) ; short length = ( short ) Array . getLength ( array ) ; output . writeShort ( length ) ; class < ? > arrayElementType = array . getClass ( ) . getComponentType ( ) ; output . write ( arrayElementType ) ; if ( arrayElementType . isPrimitive ( ) ) { if ( int . class . equals ( arrayElementType ) ) { writeIntArray ( array , output , length ) ; } else if ( long . class . equals ( arrayElementType ) ) { writeLongArray ( array , output , length ) ; } else if ( boolean . class . equals ( arrayElementType ) ) { writeBooleanArray ( array , output , length ) ; } else if ( double . class . equals ( arrayElementType ) ) { writeDoubleArray ( array , output , length ) ; } else if ( float . class . equals ( arrayElementType ) ) { writeFloatArray ( array , output , length ) ; } else if ( byte . class . equals ( arrayElementType ) ) { writeByteArray ( array , output , length ) ; } else if ( short . class . equals ( arrayElementType ) ) { writeShortArray ( array , output , length ) ; } else if ( char . class . equals ( arrayElementType ) ) { writeCharArray ( array , output , length ) ; } } else { writeObjectArray ( ( Object [ ] ) array , output ) ; } }
va	8	@ Override public void computeNormalisingConstant ( ) throws InternalErrorException { totalTimer . start ( ) ; PopulationVector N = qnm . N . copy ( ) ; int r = 0 , Nr ; int R = qnm . R , M = qnm . M ; BigRational [ ] curG = new BigRational [ matrixSize ] , G_1 = null ; for ( int i = 0 ; i < matrixSize ; i ++ ) { curG [ i ] = BigRational . ONE ; } PopulationVector N0 = new PopulationVector ( 0 , R ) ; N0 . set ( 0 , 1 ) ; System . out . println ( "Initialising data structures of class " + ( r + 1 ) ) ; generateABU ( N0 , 1 ) ; try { Solver s ; if ( nThreads == 1 ) { s = new SimpleSolver ( ) ; } else { s = new ModularSolver ( nThreads ) ; } Integer maxA = getMaxAElement ( ) ; Integer val = matrixSize ; BigInteger maxB = qnm . getMaxG ( ) . multiply ( new BigInteger ( maxA . toString ( ) ) ) . multiply ( new BigInteger ( val . toString ( ) ) ) ; s . initialise ( A , UList , uncomputables , maxA , maxB , new BigRational ( qnm . getMaxG ( ) ) ) ; N0 . set ( 0 , 0 ) ; int N0r = 1 ; int Ntot = 0 ; for ( r = 1 ; r <= R ; r ++ ) { System . out . println ( "Processing class " + r ) ; for ( Nr = N0r ; Nr <= N . get ( r - 1 ) - 1 ; Nr ++ ) { mulTimer . start ( ) ; BigRational [ ] sysB = MiscFunctions . matrixVectorMultiply ( B , curG ) ; mulTimer . pause ( ) ; s . goToULevel ( Nr - 1 ) ; curG = solve ( s , sysB ) ; Ntot ++ ; System . out . println ( "Population " + Nr + " completed (total population " + Ntot + " jobs)" ) ; } G_1 = curG ; mulTimer . start ( ) ; BigRational [ ] sysB = MiscFunctions . matrixVectorMultiply ( B , curG ) ; mulTimer . pause ( ) ; s . goToULevel ( Nr - 1 ) ; curG = solve ( s , sysB ) ; Ntot ++ ; System . out . println ( "Population " + Nr + " completed (total population " + Ntot + " jobs)" ) ; N0 . set ( r - 1 , N . get ( r - 1 ) ) ; System . out . println ( "Class " + r + " completed" ) ; if ( r < R ) { N0 . set ( r , 1 ) ; N0r = 1 ; System . out . println ( "Initialising data structures of class " + ( r + 1 ) ) ; generateABU ( N0 , r + 1 ) ; s . initialise ( A , UList , uncomputables , maxA , maxB , new BigRational ( qnm . getMaxG ( ) ) ) ; } } if ( ! curG [ 0 ] . isUndefined ( ) ) { this . G = curG [ 0 ] ; } else { throw new InconsistentLinearSystemException ( "Singular system. Cannot proceed." ) ; } totalTimer . pause ( ) ; memUsage = MiscFunctions . memoryUsage ( ) ; solverTimer = s . getTimer ( ) ; s . shutdown ( ) ; } catch ( OperationNotSupportedException ex ) { throw new InternalErrorException ( "Error in linear system solver." ) ; } catch ( InconsistentLinearSystemException ex ) { throw new InternalErrorException ( ex . getMessage ( ) ) ; } qnm . setNormalisingConstant ( G ) ; this . lastG = curG ; this . prevG = G_1 ; }
va	0	@ Override public boolean isProcessing ( String clientId ) { return players . get ( clientId ) . animating ; }
va	1	public void toggleEmergencyDriving ( ) { String off = "<html><p style='text-align:center'>EMERGENCY DRIVING" + " ---- OFF</p><html>" ; String on = "<html><p style='text-align:center'>EMERGENCY DRIVING" + " ---- ON</p><html>" ; if ( buttonEmergencyMode . getText ( ) . equals ( off ) ) { buttonEmergencyMode . setText ( on ) ; buttonEmergencyMode . setBackground ( Color . decode ( "#92CD00" ) ) ; } else { buttonEmergencyMode . setText ( off ) ; buttonEmergencyMode . setBackground ( Color . decode ( "#FF3333" ) ) ; } }
va	0	public void windowDeactivated ( WindowEvent e ) { }
va	2	public static String [ ] getNames ( JSONObject jo ) { int length = jo . length ( ) ; if ( length == 0 ) { return null ; } Iterator iterator = jo . keys ( ) ; String [ ] names = new String [ length ] ; int i = 0 ; while ( iterator . hasNext ( ) ) { names [ i ] = ( String ) iterator . next ( ) ; i += 1 ; } return names ; }
va	4	public void addNode ( BinaryTreeNode node , BinaryTreeNode addedNode ) { if ( node . val . equals ( addedNode . val ) ) { return ; } if ( addedNode . compareTo ( node ) < 0 ) { if ( node . left == null ) { node . left = addedNode ; } else { addNode ( node . left , addedNode ) ; } } else { if ( node . right == null ) { node . right = addedNode ; } else { addNode ( node . right , addedNode ) ; } } }
va	4	public static boolean hasDefaultPublicNoArgConstructor ( class < ? > type ) { for ( Constructor < ? > ctr : type . getConstructors ( ) ) { if ( ctr . getParameterTypes ( ) . length == 0 ) { return true ; } } return false ; }
va	3	public int processInput ( int n ) { int i = 0 ; int j = 1 ; int l = 0 ; if ( n == 1 ) return 1 ; if ( n == 3 ) return 0 ; for ( int k = 2 ; k <= n ; k ++ ) { l = i + j ; i = j ; j = l ; } return j ; }
va	4	@ Override protected String encode ( Object in , HashMap < String , Object > field ) { JSObject src = ( JSObject ) in , messageParams , messageHead ; String messageName , fieldName ; Object fieldValue ; try { messageParams = ( JSObject ) src . getMember ( "messageParams" ) ; messageHead = ( JSObject ) src . getMember ( "messageHead" ) ; messageName = ( String ) src . getMember ( "messageName" ) ; } catch ( JSException e ) { return UNSUPPORTED ; } field . clear ( ) ; int i = 0 ; do { try { fieldName = ( String ) messageHead . getSlot ( i ) ; i ++ ; } catch ( JSException e ) { break ; } try { fieldValue = ( String ) messageParams . getMember ( fieldName ) ; } catch ( JSException e ) { continue ; } field . put ( fieldName , fieldValue ) ; } while ( true ) ; return messageName ; }
va	2	@ Override public boolean clean ( PersonalData in , PersonalData out ) { FieldBuilder builder = new FieldBuilder ( ) ; for ( String field : fieldsToUse ) { if ( in . containsKey ( field ) ) { List < String > cleanedValues = getCleanedValues ( in , field ) ; builder . putAll ( field , cleanedValues ) ; } } builder . addTo ( out ) ; return ! builder . isEmpty ( ) ; }
va	8	public void decode ( ByteBuffer socketBuffer ) { if ( ! socketBuffer . hasRemaining ( ) || flushandclosestate ) return ; if ( DEBUG ) System . out . println ( "process(" + socketBuffer . remaining ( ) + "): {" + ( socketBuffer . remaining ( ) > 1000 ? "too big to display" : new String ( socketBuffer . array ( ) , socketBuffer . position ( ) , socketBuffer . remaining ( ) ) ) + "}" ) ; if ( readystate == READYSTATE . OPEN ) { decodeFrames ( socketBuffer ) ; } else { if ( decodeHandshake ( socketBuffer ) ) { decodeFrames ( socketBuffer ) ; } } assert ( isClosing ( ) || isFlushAndClose ( ) || ! socketBuffer . hasRemaining ( ) ) ; }
va	3	public void putAtom ( Player player , int x , int y ) { if ( getNumerOfAtomsAtPosition ( x , y ) > 0 && ! getOwnerOfCellAtPosition ( x , y ) . equals ( player ) ) { throw new IllegalStateException ( "Not allowed to put an atom on a non empty field that is not yours" ) ; } setOwningPlayer ( player , x , y ) ; final boolean increased = putAtomInternal ( x , y ) ; if ( increased ) { fireOnAtomAdded ( player , x , y ) ; } }
va	1	public void addValue ( String value ) { if ( value == null ) { throw new NullPointerException ( "value" ) ; } this . value . add ( value ) ; }
va	5	@ Override public void actualizar ( long tiempoTranscurrido ) { ventana . actualizar ( primerJugador ( ) . getCentro ( ) ) ; actualizarJugador ( tiempoTranscurrido ) ; for ( Enemigo enemigo : getEnemigos ( ) ) { enemigo . borrar ( g2 , buffer ) ; enemigo . actualizar ( this , tiempoTranscurrido ) ; if ( enemigo . getEstadoActual ( ) == Personaje . Estado . ELIMINADO ) { removerEnemigo ( enemigo ) ; } } for ( Ladrillo ladrillo : ladrillos ) { ladrillo . borrar ( g2 , buffer ) ; ladrillo . actualizar ( this , tiempoTranscurrido ) ; if ( ladrillo . getEstadoActual ( ) == Personaje . Estado . ELIMINADO && ! ladrillo . isEspecial ( ) ) { Mapa . getInstance ( ) . setObjeto ( "V" , ladrillo . getPosicionMapa ( ) ) ; ladrillos . remove ( ladrillo ) ; } } controlJuego . actualizar ( ) ; }
va	4	@ Override public void mouseDragged ( MouseEvent e ) { Point dragged = e . getLocationOnScreen ( ) ; int dragX = getDragDistance ( dragged . x , pressed . x , snapSize . width ) ; int dragY = getDragDistance ( dragged . y , pressed . y , snapSize . height ) ; int locationX = location . x + dragX ; int locationY = location . y + dragY ; while ( locationX < edgeInsets . left ) locationX += snapSize . width ; while ( locationY < edgeInsets . top ) locationY += snapSize . height ; Dimension d = getBoundingSize ( destination ) ; while ( locationX + destination . getSize ( ) . width + edgeInsets . right > d . width ) locationX -= snapSize . width ; while ( locationY + destination . getSize ( ) . height + edgeInsets . bottom > d . height ) locationY -= snapSize . height ; destination . setLocation ( locationX , locationY ) ; }
va	2	@ Override public int hashCode ( ) { int result = node != null ? node . hashCode ( ) : 0 ; result = 31 * result + ( type != null ? type . hashCode ( ) : 0 ) ; return result ; }
va	0	public DateAction ( JDateChooser date ) { this . date = date ; }
va	3	public ArrayList < Booking > getBookingsFromDB ( Connection con ) { Booking booking = null ; ArrayList < Booking > bookingList = new ArrayList < > ( ) ; String SQLString = "SELECT * " + "FROM bookings " + "ORDER BY booking_id DESC" ; PreparedStatement statement = null ; try { statement = con . prepareStatement ( SQLString ) ; ResultSet rs = statement . executeQuery ( ) ; while ( rs . next ( ) ) { booking = new Booking ( rs ) ; bookingList . add ( booking ) ; } } catch ( SQLException e ) { System . out . println ( "Fail in BookingMapper.getBookingsFromDB()" ) ; System . out . println ( e . getMessage ( ) ) ; } finally { try { statement . close ( ) ; } catch ( SQLException e ) { System . out . println ( "Fail in BookingMapper.getBookingsFromDB()" ) ; System . out . println ( e . getMessage ( ) ) ; } } return bookingList ; }
va	8	private int InterseccionY ( double _y1 , double _h1 , double _y2 , double _h2 ) { int estado = 0 ; if ( _y1 <= _y2 + _h2 && _y2 + _h2 <= _y1 + _h1 ) { estado = 1 ; } else if ( _y1 <= _y2 && _y2 <= _y1 + _h1 ) { estado = 1 ; } else if ( _y2 <= _y1 + _h1 && _y1 + _h1 <= _y2 + _h2 ) { estado = 1 ; } else if ( _y2 <= _y1 && _y1 <= _y2 + _h2 ) { estado = 1 ; } return estado ; }
va	9	private static boolean equivEquals ( Object elt1 , Object elt2 ) { if ( elt1 == elt2 ) return true ; else if ( elt1 == null || elt2 == null ) return false ; else if ( elt1 instanceof EquivalentSet ) { if ( elt2 instanceof EquivalentSet ) { ArrayList < Object > al1 = ( ( EquivalentSet ) elt1 ) . contents ; ArrayList < Object > al2 = ( ( EquivalentSet ) elt2 ) . contents ; int size1 = al1 . size ( ) ; if ( size1 != al2 . size ( ) ) return false ; else { for ( int i = 0 ; i < size1 ; ++ i ) if ( ! al2 . contains ( al1 . get ( i ) ) ) return false ; return true ; } } else return false ; } else if ( elt2 instanceof EquivalentSet ) return false ; else return elt1 . equals ( elt2 ) ; }
va	6	public FHashSet < Elt > difference ( Collection < ? extends Elt > coll ) { if ( isEmpty ( ) || coll == this ) return ( FHashSet < Elt > ) EMPTY_INSTANCE ; else if ( coll . isEmpty ( ) ) return this ; else if ( coll instanceof FHashSet ) { FHashSet < Elt > fhs = ( FHashSet < Elt > ) coll ; if ( fhs . tree == tree ) return new FHashSet < Elt > ( ) ; Object t = difference ( tree , fhs . tree ) ; return make ( t ) ; } else { FHashSet < Elt > fhs = new FHashSet < Elt > ( coll ) ; Object t = difference ( tree , fhs . tree ) ; return make ( t ) ; } }
va	9	public static Object stringToValue ( String string ) { if ( "true" . equalsIgnoreCase ( string ) ) { return boolean . true ; } if ( "false" . equalsIgnoreCase ( string ) ) { return boolean . false ; } if ( "null" . equalsIgnoreCase ( string ) ) { return JSONObject . null ; } try { char initial = string . charAt ( 0 ) ; if ( initial == - || ( initial >= 0 && initial <= 9 ) ) { long value = new long ( string ) ; if ( value . toString ( ) . equals ( string ) ) { return value ; } } } catch ( Exception ignore ) { try { double value = new double ( string ) ; if ( value . toString ( ) . equals ( string ) ) { return value ; } } catch ( Exception ignoreAlso ) { } } return string ; }
va	9	static final Writer writeValue ( Writer writer , Object value , int indentFactor , int indent ) throws JSONException , IOException { if ( value == null || value . equals ( null ) ) { writer . write ( "null" ) ; } else if ( value instanceof JSONObject ) { ( ( JSONObject ) value ) . write ( writer , indentFactor , indent ) ; } else if ( value instanceof JSONArray ) { ( ( JSONArray ) value ) . write ( writer , indentFactor , indent ) ; } else if ( value instanceof Map ) { new JSONObject ( ( Map ) value ) . write ( writer , indentFactor , indent ) ; } else if ( value instanceof Collection ) { new JSONArray ( ( Collection ) value ) . write ( writer , indentFactor , indent ) ; } else if ( value . getClass ( ) . isArray ( ) ) { new JSONArray ( value ) . write ( writer , indentFactor , indent ) ; } else if ( value instanceof Number ) { writer . write ( numberToString ( ( Number ) value ) ) ; } else if ( value instanceof boolean ) { writer . write ( value . toString ( ) ) ; } else if ( value instanceof JSONString ) { Object o ; try { o = ( ( JSONString ) value ) . toJSONString ( ) ; } catch ( Exception e ) { throw new JSONException ( e ) ; } writer . write ( o != null ? o . toString ( ) : quote ( value . toString ( ) ) ) ; } else { quote ( value . toString ( ) , writer ) ; } return writer ; }
va	9	@ Override public void run ( ) { mustHalt = false ; ServerSocket serverSocket = null ; fileServer = null ; Thread reliableManager = null , queryMessageForwarder = null , networkExplorer = null ; try { fileServer = new FileServer ( sharedFolder , this , fileServerPort ) ; if ( ! firewalled ) { serverSocket = new ServerSocket ( connectPort ) ; serverSocket . setSoTimeout ( Util . SOCKET_SO_TIMEOUT ) ; ( networkExplorer = new NetworkExplorer ( this , explorePort ) ) . start ( ) ; ( reliableManager = new ReliableManager ( ) ) . start ( ) ; fileServer . start ( ) ; } ( queryMessageForwarder = new Sender ( ) ) . start ( ) ; } catch ( IOException e ) { logger . appendError ( "Impossibile avviare il servent" , e ) ; mustHalt = true ; } if ( ! mustHalt ) { cacheConnect ( ) ; logger . appendMessage ( "Servent avviato" ) ; } initDone = true ; while ( ! mustHalt ) { try { if ( ! firewalled ) { Socket dataSocket = serverSocket . accept ( ) ; exec . execute ( new Connection ( this , dataSocket ) ) ; } else { sleep ( Util . SOCKET_SO_TIMEOUT ) ; } } catch ( IOException e ) { continue ; } catch ( InterruptedException e ) { break ; } } if ( serverSocket != null ) { try { serverSocket . close ( ) ; } catch ( IOException e ) { } } Util . waitHelper ( reliableManager ) ; Util . waitHelper ( networkExplorer ) ; Util . waitHelper ( queryMessageForwarder ) ; Util . waitHelper ( fileServer ) ; for ( int i = 0 ; i < connections . size ( ) ; i ++ ) { connections . get ( i ) . interrupt ( ) ; } exec . shutdown ( ) ; try { if ( ! exec . awaitTermination ( 10 , TimeUnit . SECONDS ) ) { exec . shutdownNow ( ) ; } } catch ( InterruptedException e ) { } }
va	7	private void saveJButtonActionPerformed ( java . awt . event . ActionEvent evt ) { System . out . println ( titleNameJTextField . getText ( ) ) ; if ( titleNameJTextField . getText ( ) . equals ( "" ) || itemNoJTextField . getText ( ) . equals ( "" ) || authorJTextField . getText ( ) . equals ( "" ) || ( ( JTextField ) yearJTextField . getDateEditor ( ) . getUiComponent ( ) ) . getText ( ) . equals ( "" ) || kindJTextField . getText ( ) . equals ( "" ) || isbnJTextField . getText ( ) . equals ( "" ) || pagesJTextField . getText ( ) . equals ( "" ) ) { JOptionPane . showMessageDialog ( null , "Retry insert the record by filling all the fields" , "Something went wrong" , JOptionPane . WARNING_MESSAGE ) ; } else { insert ( ) ; } }
va	0	public void setDepartment ( int department ) { this . department = department ; }
va	8	public List < Attribute > getAttributes ( String attachementLevel , String assignmentStatus ) { List < Attribute > attributes = new ArrayList < Attribute > ( ) ; for ( KeyFamily keyFamily : keyFamilies ) { List < Attribute > list = keyFamily . getComponents ( ) . getAttributes ( ) ; for ( Attribute a : list ) { if ( a . getAttachmentLevel ( ) . equalsIgnoreCase ( attachementLevel ) && a . getAssignmentStatus ( ) . equalsIgnoreCase ( assignmentStatus ) ) { attributes . add ( a ) ; } if ( attachementLevel == null && a . getAssignmentStatus ( ) . equalsIgnoreCase ( assignmentStatus ) ) { attributes . add ( a ) ; } if ( assignmentStatus == null && a . getAttachmentLevel ( ) . equalsIgnoreCase ( attachementLevel ) ) { attributes . add ( a ) ; } } } return attributes ; }
va	6	@ Override public void validate ( ) { if ( sitename == null ) { addActionError ( "Please Enter Site Name" ) ; } if ( siteurl == null && siteurl . equals ( "http://" ) ) { addActionError ( "Please Enter Web Site Url" ) ; } if ( txtcolor == null ) { addActionError ( "Please Enter Text Color" ) ; } if ( bgcolor == null ) { addActionError ( "Please Enter Background Color" ) ; } if ( catgry . equals ( "Please select" ) ) { addActionError ( "Please Select a Category" ) ; } }
va	6	private static boolean method518 ( char c ) { return c < a || c > z || c == v || c == x || c == j || c == q || c == z ; }
va	9	private static Object equivUnion ( Object elt1 , Object elt2 ) { if ( elt1 == NO_ELEMENT ) return elt2 ; else if ( elt2 == NO_ELEMENT ) return elt1 ; else if ( elt1 instanceof EquivalentSet ) { ArrayList < Object > al1 = ( ( EquivalentSet ) elt1 ) . contents ; if ( elt2 instanceof EquivalentSet ) { ArrayList < Object > al2 = ( ( EquivalentSet ) elt2 ) . contents ; int size2 = al2 . size ( ) ; ArrayList < Object > res_al = ( ArrayList < Object > ) al1 . clone ( ) ; for ( int i = 0 ; i < size2 ; ++ i ) { Object e2 = al2 . get ( i ) ; if ( ! res_al . contains ( e2 ) ) res_al . add ( e2 ) ; } res_al . trimToSize ( ) ; return new EquivalentSet ( res_al ) ; } else { if ( al1 . contains ( elt2 ) ) return elt1 ; else { ArrayList < Object > res_al = ( ArrayList < Object > ) al1 . clone ( ) ; res_al . add ( elt2 ) ; res_al . trimToSize ( ) ; return new EquivalentSet ( res_al ) ; } } } else if ( elt2 instanceof EquivalentSet ) { ArrayList < Object > al2 = ( ( EquivalentSet ) elt2 ) . contents ; if ( al2 . contains ( elt1 ) ) return elt2 ; else { ArrayList < Object > al = ( ArrayList < Object > ) al2 . clone ( ) ; al . add ( elt1 ) ; al . trimToSize ( ) ; return new EquivalentSet ( al ) ; } } else if ( eql ( elt1 , elt2 ) ) return elt1 ; else { ArrayList < Object > al = new ArrayList < Object > ( 2 ) ; al . add ( elt1 ) ; al . add ( elt2 ) ; return new EquivalentSet ( al ) ; } }
va	5	private double [ ] lineSearchBacktrack ( LogConditionalObjectiveFunction func , double [ ] dir , double [ ] x , double [ ] newX , double [ ] grad , double lastValue ) throws MaxEvaluationsExceeded { double normGradInDir = ArrayMath . innerProduct ( dir , grad ) ; say ( "(" + nf . format ( normGradInDir ) + ")" ) ; if ( normGradInDir > 0 ) { say ( "{WARNING--- direction of positive gradient chosen!}" ) ; } double step , c1 ; if ( its <= 2 ) { step = 0.1 ; c1 = 0.1 ; } else { step = 1.0 ; c1 = 0.1 ; } double c = 0.01 ; c = c * normGradInDir ; double [ ] newPoint = new double [ 3 ] ; while ( ( newPoint [ f ] = func . valueAt ( ( plusAndConstMult ( x , dir , step , newX ) ) ) ) > lastValue + c * step ) { fevals += 1 ; if ( newPoint [ f ] < lastValue ) { say ( "!" ) ; } else { say ( "." ) ; } step = c1 * step ; } newPoint [ a ] = step ; fevals += 1 ; if ( fevals > maxFevals ) { throw new MaxEvaluationsExceeded ( " Exceeded during linesearch() Function " ) ; } return newPoint ; }
va	8	public List < Email > loadEmail ( ) { List < Email > emailList = new ArrayList < Email > ( ) ; File filePath = new File ( PERSISTENCE_PATH ) ; if ( filePath . isDirectory ( ) ) { String [ ] fileList = filePath . list ( ) ; if ( fileList . length == 0 ) { return null ; } for ( int i = 0 ; i < fileList . length ; i ++ ) { File file = new File ( PERSISTENCE_PATH + fileList [ i ] ) ; logger . debug ( "persistence:\u52A0\u8F7D\u6587\u4EF6" + file . getName ( ) ) ; ObjectInputStream ois = null ; try { ois = new ObjectInputStream ( new FileInputStream ( file ) ) ; emailList . add ( ( Email ) ois . readObject ( ) ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } catch ( ClassNotFoundException e ) { e . printStackTrace ( ) ; } finally { if ( ois != null ) { try { ois . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } } } } else { logger . error ( "EmailPersistence.loadEmail error" ) ; } return emailList ; }
va	9	static public String decode ( IOBuffer in , String charset , int byteLength ) { if ( in . getReadableBytes ( ) < byteLength ) throw new BufferUnderflowException ( ) ; ByteBuffer bb ; CharBuffer cb ; char [ ] ca ; Thread thread = Thread . currentThread ( ) ; if ( thread instanceof CharsetDecoderEncoderThread ) { CharsetDecoderEncoderThread thread1 = ( ( CharsetDecoderEncoderThread ) thread ) ; bb = thread1 . getTempArrayByteBuffer ( ) ; cb = thread1 . getTempArrayCharBuffer ( ) ; ca = cb . array ( ) ; } else { bb = byteBuffer ; cb = charBuffer ; ca = charArray ; } java . nio . charset . CharsetDecoder decoder = Charset . forName ( charset ) . newDecoder ( ) ; StringBuilder sb = new StringBuilder ( ) ; decoder . reset ( ) ; decoder . replaceWith ( "?" ) ; decoder . onMalformedInput ( CodingErrorAction . REPLACE ) ; decoder . onUnmappableCharacter ( CodingErrorAction . REPLACE ) ; boolean lastLoop = false ; if ( ! ( thread instanceof CharsetDecoderEncoderThread ) ) lock . lock ( ) ; try { bb . clear ( ) ; cb . clear ( ) ; while ( true ) { if ( byteLength > 0 ) { int readed = Math . min ( bb . remaining ( ) , byteLength ) ; in . read ( bb , readed ) ; byteLength -= readed ; } bb . flip ( ) ; CoderResult result = decoder . decode ( bb , cb , lastLoop ) ; if ( lastLoop ) result = decoder . flush ( cb ) ; cb . flip ( ) ; int cbLen = cb . remaining ( ) ; if ( cbLen > 0 ) sb . append ( ca , cb . position ( ) , cbLen ) ; bb . compact ( ) ; cb . clear ( ) ; if ( result == CoderResult . OVERFLOW || ( result == CoderResult . UNDERFLOW && byteLength > 0 ) ) continue ; if ( ! lastLoop && byteLength <= 0 ) { lastLoop = true ; continue ; } else break ; } } finally { if ( ! ( thread instanceof CharsetDecoderEncoderThread ) ) lock . unlock ( ) ; } return sb . toString ( ) ; }
va	3	public static void main ( String [ ] args ) { int m = 10 ; int n = 10 ; int [ ] [ ] mat = new int [ m ] [ n ] ; int i , j ; for ( i = 0 ; i < m ; i ++ ) { for ( j = 0 ; j < n ; j ++ ) { if ( j == 0 ) { mat [ i ] [ j ] = 1 + ( int ) ( Math . random ( ) * 10 ) ; } else { mat [ i ] [ j ] = mat [ i ] [ j - 1 ] + 1 + ( int ) ( Math . random ( ) * 10 ) ; } } } }
va	0	public void setShapeDrawer ( ShapeDrawer shapeDrawer ) { this . shapeDrawer = shapeDrawer ; }
va	4	public ListNode deleteDuplicates ( ListNode head ) { ListNode newHead = new ListNode ( 0 ) ; newHead . next = head ; ListNode cur = newHead ; while ( cur . next != null ) { ListNode next = cur . next ; while ( next . next != null && next . next . val == next . val ) { next = next . next ; } if ( cur . next != next ) cur . next = next . next ; else cur = cur . next ; } return newHead . next ; }
va	3	public void setDateFormatString ( String dateFormatString ) { try { dateFormatter . applyPattern ( dateFormatString ) ; } catch ( RuntimeException e ) { dateFormatter = ( SimpleDateFormat ) DateFormat . getDateInstance ( DateFormat . MEDIUM ) ; dateFormatter . setLenient ( false ) ; } this . dateFormatString = dateFormatter . toPattern ( ) ; setToolTipText ( this . dateFormatString ) ; if ( date != null ) { ( ( JSpinner . DateEditor ) getEditor ( ) ) . getFormat ( ) . applyPattern ( this . dateFormatString ) ; } else { ( ( JSpinner . DateEditor ) getEditor ( ) ) . getFormat ( ) . applyPattern ( "" ) ; } if ( date != null ) { String text = dateFormatter . format ( date ) ; ( ( JSpinner . DateEditor ) getEditor ( ) ) . getTextField ( ) . setText ( text ) ; } }
va	0	public EventRegistration getRegistration ( ) { return registration ; }
va	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( Promocion . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( Promocion . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( Promocion . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( Promocion . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { new Promocion ( ) . setVisible ( true ) ; } } ) ; }
va	3	private void parseAnswer ( String answer ) { int end = 0 ; int start = 0 ; while ( true ) { start = answer . indexOf ( [ , end ) ; if ( start == - 1 ) break ; end = answer . indexOf ( ] , start + 1 ) ; if ( end == - 1 ) break ; String ans = answer . substring ( start + 1 , end ) ; this . answers . add ( ans ) ; } }
va	2	public boolean isIgnoredBlock ( ) { return mCaller == null || isContextSwitch ( ) && mCaller . mCaller == null ; }
va	2	@ Override public void run ( ) { try { ComThread . InitMTA ( ) ; System . out . println ( "OnInit" ) ; String lang = "VBScript" ; sC = new ActiveXComponent ( "ScriptControl" ) ; sControl = sC . getObject ( ) ; sControl . put ( "Language" , lang ) ; ScriptTestErrEvents te = new ScriptTestErrEvents ( ) ; de = new DispatchEvents ( sControl , te ) ; System . out . println ( "sControl=" + sControl ) ; while ( ! quit ) { sleep ( 100 ) ; } ComThread . Release ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { System . out . println ( "worker thread exits" ) ; } }
va	3	private static < E > void quickSort ( E [ ] contents , int left , int right , Comparator < E > comparator ) { if ( ( left + 2 ) > right ) { if ( comparator . compare ( contents [ left ] , contents [ right ] ) > 0 ) { swap ( contents , left , right ) ; } } else if ( left < right ) { medianOf3Pivot ( contents , left , right , comparator ) ; int pivotIndex = partition ( contents , left + 1 , right - 1 , comparator ) ; quickSort ( contents , left , pivotIndex - 1 , comparator ) ; quickSort ( contents , pivotIndex + 1 , right , comparator ) ; } }
va	2	@ Test public void preorderBothNull ( ) { try { AVLTree < Integer , Integer > b = new AVLTree < Integer , Integer > ( ) ; b . preorder ( null , null ) ; fail ( IllegalArgumentException . class ) ; } catch ( IllegalArgumentException e ) { } catch ( Exception e ) { fail ( IllegalArgumentException . class , e ) ; } }
va	9	public void Analyse ( String data , String resName , int [ ] thresholds , boolean pathMetrics ) { File datFile = new File ( data ) ; String resBaseDirPath = datFile . getAbsolutePath ( ) . substring ( 0 , datFile . getAbsolutePath ( ) . lastIndexOf ( datFile . separator ) ) + datFile . separator + resName ; File resBaseDir = new File ( resBaseDirPath ) ; if ( ! resBaseDir . exists ( ) ) { resBaseDir . mkdir ( ) ; } StreamedLinkSet sl = new StreamedLinkSet ( data ) ; for ( int i : thresholds ) { File resDir = new File ( resBaseDirPath + datFile . separator + "t" + i ) ; if ( ! resDir . exists ( ) ) { resDir . mkdir ( ) ; } String baseResultPath = resDir + datFile . separator ; if ( includeDataInFileName ) { baseResultPath += datFile . getName ( ) . substring ( 0 , datFile . getName ( ) . length ( ) - 4 ) ; } String adjacencyPath = baseResultPath + "adjacencyList.txt" ; sl . writeAdjList ( adjacencyPath , i ) ; General u = new General ( ) ; int [ ] NL = u . getNodeAndLinkCount ( adjacencyPath ) ; System . out . println ( "Network has " + NL [ 0 ] + " nodes and " + NL [ 1 ] + " links" ) ; Node [ ] network = u . readNetworkFromAdjacencyList ( adjacencyPath ) ; if ( network . length == 0 ) { String [ ] summary = new String [ 12 ] ; summary [ 0 ] = "Summary information for " + datFile . getAbsolutePath ( ) + " with threshold: " + i ; summary [ 1 ] = "Total number of nodes: NaN" ; summary [ 2 ] = "Total number of links: NaN" ; summary [ 3 ] = "Number of nodes gc: NaN" ; summary [ 4 ] = "Number of links gc: NaN" ; if ( pathMetrics ) { summary [ 5 ] = "Average distance: NaN" ; summary [ 6 ] = "Diameter: NaN" ; summary [ 7 ] = "Average CC: NaN" ; summary [ 9 ] = "Max betweenness: NaN" ; } else { summary [ 5 ] = "Average distance: NaN" ; summary [ 6 ] = "Diameter: NaN" ; summary [ 7 ] = "Average CC: NaN" ; summary [ 9 ] = "Max betweenness: NaN" ; } summary [ 8 ] = "Assortativity: NaN" ; summary [ 10 ] = "Max coreness: NaN" ; summary [ 11 ] = "Average coreness: NaN" ; writeStringsToFile ( summary , baseResultPath + "summary.txt" ) ; continue ; } int N_total = network . length ; int L_total = 0 ; for ( Node nod : network ) { L_total += nod . links . length ; } L_total = L_total / 2 ; Node [ ] gc = u . extractLargestComponent ( network ) ; int N_gc = gc . length ; int L_gc = 0 ; for ( Node nod : gc ) { L_gc += nod . links . length ; } L_gc = L_gc / 2 ; int [ ] [ ] pathDist = null ; double [ ] betw = null ; double av_dist = - 1 ; int [ ] ecc = null ; if ( pathMetrics ) { Object [ ] paths ; if ( numThreads == 1 ) { paths = u . pathMetrics ( gc ) ; } else { paths = u . pathMetricsMT ( gc , numThreads ) ; } ecc = ( int [ ] ) paths [ 0 ] ; av_dist = ( double ) paths [ 1 ] ; betw = ( double [ ] ) paths [ 2 ] ; pathDist = ( int [ ] [ ] ) paths [ 3 ] ; } int [ ] coreness = u . coreness ( gc ) ; double [ ] clust = u . clusteringCoefficient ( gc ) ; String [ ] comps = u . getLastDecompostion ( ) ; double assort = u . assortativity ( gc ) ; if ( pathMetrics ) { writeIntsToFile ( ecc , gc , baseResultPath + "eccentricity.txt" ) ; writeDoublesToFile ( betw , gc , baseResultPath + "betweenness.txt" ) ; writeIntColumnsToFile ( pathDist , baseResultPath + "hopcounts.txt" ) ; } writeDoublesToFile ( clust , gc , baseResultPath + "clustering.txt" ) ; writeStringsToFile ( comps , baseResultPath + "components.txt" ) ; u . writeToSimpleTextList ( gc , baseResultPath + "simpleList.txt" ) ; writeIntsToFile ( coreness , gc , baseResultPath + "coreness.txt" ) ; String [ ] summary = new String [ 12 ] ; summary [ 0 ] = "Summary information for " + datFile . getAbsolutePath ( ) + " with threshold: " + i ; summary [ 1 ] = "Total number of nodes: " + N_total ; summary [ 2 ] = "Total number of links: " + L_total ; summary [ 3 ] = "Number of nodes gc: " + N_gc ; summary [ 4 ] = "Number of links gc: " + L_gc ; if ( pathMetrics ) { summary [ 5 ] = "Average distance: " + av_dist ; summary [ 6 ] = "Diameter: " + u . max ( ecc ) ; summary [ 7 ] = "Average CC: " + u . average ( clust ) ; summary [ 9 ] = "Max betweenness: " + u . max ( betw ) ; } else { summary [ 5 ] = "Average distance: NaN" ; summary [ 6 ] = "Diameter: NaN" ; summary [ 7 ] = "Average CC: NaN" ; summary [ 9 ] = "Max betweenness: NaN" ; } summary [ 8 ] = "Assortativity: " + assort ; summary [ 10 ] = "Max coreness: " + u . max ( coreness ) ; summary [ 11 ] = "Average coreness: " + u . average ( coreness ) ; writeStringsToFile ( summary , baseResultPath + "summary.txt" ) ; Runtime . getRuntime ( ) . gc ( ) ; } }
va	9	public void execute ( ) { long now = System . nanoTime ( ) ; svc = Executors . newFixedThreadPool ( Runtime . getRuntime ( ) . availableProcessors ( ) + 1 ) ; waitFor = new ConcurrentLinkedQueue < Future < ? >> ( ) ; try { Set < URL > urls = new LinkedHashSet < URL > ( ) ; urls . addAll ( Collections . list ( loader . getResources ( "" ) ) ) ; urls . addAll ( Collections . list ( loader . getResources ( "META-INF" ) ) ) ; logger . debug ( "Scanning {}" , urls ) ; for ( URL url : urls ) { if ( "file" . equals ( url . getProtocol ( ) ) ) { File base = new File ( url . toURI ( ) ) ; scan ( base , base . getAbsolutePath ( ) . length ( ) + 1 ) ; } else if ( "jar" . equals ( url . getProtocol ( ) ) ) { JarURLConnection conn = ( JarURLConnection ) url . openConnection ( ) ; scan ( conn . getJarFile ( ) ) ; } } for ( Future < ? > future = waitFor . poll ( ) ; future != null ; future = waitFor . poll ( ) ) { try { future . get ( ) ; } catch ( InterruptedException e ) { waitFor . offer ( future ) ; } catch ( ExecutionException e ) { logger . error ( "Error during processing" , e ) ; } } } catch ( IOException e ) { fail ( e ) ; } catch ( URISyntaxException e ) { fail ( e ) ; } finally { svc . shutdownNow ( ) ; svc = null ; waitFor = null ; } logger . debug ( "Classpath search took {} ms" , TimeUnit . NANOSECONDS . toMillis ( System . nanoTime ( ) - now ) ) ; }
va	5	private TableDef tableDefFromXml ( Element tdEl ) throws Exception { TableDef res = new TableDef ( ) ; res . setName ( tdEl . getAttributeValue ( "name" ) ) ; res . setRequestedRowNum ( Integer . parseInt ( tdEl . getAttributeValue ( "requestedRowNum" ) ) ) ; List < ? > fdEls = tdEl . getChildren ( "fieldDef" ) ; for ( int i = 0 , size = fdEls . size ( ) ; i < size ; i ++ ) { Element fdEl = ( Element ) fdEls . get ( i ) ; res . addFieldDef ( fieldDefFromXml ( fdEl ) ) ; } ArrayList < FieldDef > primaryKeys = new ArrayList < FieldDef > ( ) ; for ( int i = 1 ; true ; i ++ ) { String primaryKeyFieldName = tdEl . getAttributeValue ( "primaryKey" + i ) ; if ( primaryKeyFieldName == null ) break ; FieldDef primaryKeyField = res . getFieldDef ( primaryKeyFieldName ) ; if ( primaryKeyField == null ) { throw new Exception ( "Specified primary key (" + primaryKeyFieldName + ") not defined for table " + res . getName ( ) ) ; } primaryKeys . add ( primaryKeyField ) ; } res . setPrimaryKeys ( primaryKeys ) ; return res ; }
va	4	public boolean setNewValue ( Object object , Object value ) { ( ( LcdEditor ) myParent ) . objectPropertiesChanged ( ) ; if ( object == "x-pos" ) { int x = new Integer ( ( String ) value ) . intValue ( ) ; if ( ! checkLocation ( x , getY ( ) ) ) return false ; setLocation ( x , getY ( ) ) ; return true ; } if ( object == "y-pos" ) { int y = new Integer ( ( String ) value ) . intValue ( ) ; if ( ! checkLocation ( getX ( ) , y ) ) return false ; setLocation ( getX ( ) , y ) ; return true ; } return false ; }
va	0	public void setActiveExtruder ( int ex ) { activeEx = ex ; }
va	0	public synchronized List getList ( ) { return ( List ) completedThreads . clone ( ) ; }
va	3	private static double absDiffOfMeans ( double [ ] A , double [ ] B , boolean randomize ) { Random random = new Random ( ) ; double aTotal = 0.0 ; double bTotal = 0.0 ; for ( int i = 0 ; i < A . length ; i ++ ) { if ( randomize && random . nextBoolean ( ) ) { aTotal += B [ i ] ; bTotal += A [ i ] ; } else { aTotal += A [ i ] ; bTotal += B [ i ] ; } } double aMean = aTotal / A . length ; double bMean = bTotal / B . length ; return Math . abs ( aMean - bMean ) ; }
va	0	public static void main ( String [ ] args ) { int x , y , z ; x = y = z = 1 ; System . out . println ( "x = " + x + "  y = " + y + "  z = " + z ) ; x = ( y = ( z = z + 1 ) + 1 ) + 1 ; System . out . println ( "x = " + x + "  y = " + y + "  z = " + z ) ; x = ( y = 1 ) + ( z = 1 ) ; System . out . println ( "x = " + x + "  y = " + y + "  z = " + z ) ; }
va	8	private Handshake validateHandshake ( Socket socket , byte [ ] peerId ) throws IOException , ParseException { InputStream is = socket . getInputStream ( ) ; byte [ ] data = new byte [ Handshake . BASE_HANDSHAKE_LENGTH + 20 ] ; is . read ( data , 0 , data . length ) ; int pstrlen = data [ 0 ] == 13 ? data [ 0 ] : 13 ; byte [ ] pstr = Arrays . copyOfRange ( data , 1 , 20 ) ; Handshake hs = Handshake . parse ( ByteBuffer . wrap ( data ) ) ; logger . debug ( "Validating handshake from " + socket + ": " + Torrent . byteArrayToHexString ( hs . getBytes ( ) ) ) ; if ( hs . isObfuscated ( ) ) { byte [ ] clientPeerId = this . id ; byte [ ] infoHash = this . torrent . getInfoHash ( ) ; byte [ ] infoHashPeerId = Arrays . copyOf ( infoHash , infoHash . length + clientPeerId . length ) ; System . arraycopy ( clientPeerId , 0 , infoHashPeerId , infoHash . length , clientPeerId . length ) ; try { byte [ ] sighash = Torrent . hash ( infoHashPeerId ) ; if ( ! Arrays . equals ( sighash , hs . getSignature ( ) ) ) { throw new ParseException ( "Invalid obfuscated handshake" , pstrlen ) ; } } catch ( NoSuchAlgorithmException nsae ) { } byte [ ] paddingheader = new byte [ 5 ] ; is . read ( paddingheader ) ; int paddingLen = ByteBuffer . wrap ( paddingheader ) . getInt ( ) ; byte [ ] paddingBytes = new byte [ paddingLen ] ; is . read ( paddingBytes ) ; } else if ( ! Handshake . BITTORRENT_PROTOCOL_IDENTIFIER . equals ( new String ( pstr , Torrent . BYTE_ENCODING ) ) ) { throw new ParseException ( "Invalid handshake signature" , pstrlen ) ; } if ( ! Arrays . equals ( hs . getInfoHash ( ) , this . torrent . getInfoHash ( ) ) ) { throw new ParseException ( "Handshake for unknown torrent " + Torrent . byteArrayToHexString ( hs . getInfoHash ( ) ) + " from " + this . socketRepr ( socket ) + "." , pstrlen + 9 ) ; } if ( peerId != null && ! Arrays . equals ( hs . getPeerId ( ) , peerId ) ) { throw new ParseException ( "Announced peer ID " + Torrent . byteArrayToHexString ( hs . getPeerId ( ) ) + " did not match expected peer ID " + Torrent . byteArrayToHexString ( peerId ) + "." , pstrlen + 29 ) ; } return hs ; }
va	6	public static String encodeParameters ( List < PostParameter > postParams , String splitter , boolean quot ) { StringBuffer buf = new StringBuffer ( ) ; for ( PostParameter param : postParams ) { if ( buf . length ( ) != 0 ) { if ( quot ) { buf . append ( "\"" ) ; } buf . append ( splitter ) ; } buf . append ( encode ( param . name ) ) . append ( "=" ) ; if ( quot ) { buf . append ( "\"" ) ; } buf . append ( encode ( param . value ) ) ; } if ( buf . length ( ) != 0 ) { if ( quot ) { buf . append ( "\"" ) ; } } return buf . toString ( ) ; }
va	6	@ Override public Set < Task > selectSLAsToViolate ( Node n , double load , final long time ) { List < Task > list = new ArrayList < Task > ( ) ; for ( Task t : n . getAllocatedTasks ( ) ) { list . add ( t ) ; } Collections . sort ( list , new Comparator < Task > ( ) { @ Override public int compare ( Task o1 , Task o2 ) { return o2 . getClient ( ) . getReputation ( ) < o1 . getClient ( ) . getReputation ( ) ? 1 : - 1 ; } } ) ; Set < Task > tasksToViolate = new HashSet < Task > ( ) ; double cpus = Math . ceil ( load * n . getCpus ( ) ) ; int i = 0 ; while ( i < list . size ( ) && cpus > n . getCpus ( ) ) { tasksToViolate . add ( list . get ( i ) ) ; cpus -= n . getCpus ( ) ; i ++ ; } if ( tasksToViolate . size ( ) > 0 ) { System . out . print ( provider . getIdentifier ( ) + ". " + "Reputation Aware. Canceling tasks: " ) ; for ( Task t : tasksToViolate ) { System . out . print ( " " + t . getClient ( ) . getReputation ( ) ) ; } System . out . println ( ) ; } return tasksToViolate ; }
va	5	public RegiosItemStack [ ] deserialize ( List < CompoundTag > items , int invSize ) { RegiosItemStack [ ] stacks = new RegiosItemStack [ invSize ] ; for ( CompoundTag tag : items ) { Map < String , Tag > itemTag = tag . getValue ( ) ; short id = NBTUtils . getChildTag ( itemTag , "id" , ShortTag . class ) . getValue ( ) ; short damage = NBTUtils . getChildTag ( itemTag , "Damage" , ShortTag . class ) . getValue ( ) ; byte count = NBTUtils . getChildTag ( itemTag , "Count" , ByteTag . class ) . getValue ( ) ; RegiosItemStack stack = new RegiosItemStack ( id , count , damage ) ; if ( itemTag . containsKey ( "tag" ) ) { Map < String , Tag > auxData = NBTUtils . getChildTag ( itemTag , "tag" , CompoundTag . class ) . getValue ( ) ; ListTag ench = ( ListTag ) auxData . get ( "ench" ) ; for ( Tag e : ench . getValue ( ) ) { Map < String , Tag > vars = ( ( CompoundTag ) e ) . getValue ( ) ; short enchId = NBTUtils . getChildTag ( vars , "id" , ShortTag . class ) . getValue ( ) ; short enchLevel = NBTUtils . getChildTag ( vars , "lvl" , ShortTag . class ) . getValue ( ) ; stack . getEnchantments ( ) . put ( ( int ) enchId , ( int ) enchLevel ) ; } } byte slot = NBTUtils . getChildTag ( itemTag , "Slot" , ByteTag . class ) . getValue ( ) ; if ( slot >= 0 && slot < stacks . length ) { stacks [ slot ] = stack ; } } return stacks ; }
va	0	public void setPreviousCell ( Cell previousCell ) { this . previousCell = previousCell ; }
va	8	public static Sensor getSensorInstance ( String propertyFilePath , boolean fromClasspath ) throws NodeInitializationException { String errorMsg = "Cannot instanciate a Sensor using " + propertyFilePath + " file." ; Properties properties ; try { if ( fromClasspath ) { properties = GlobalUtility . getPropertiesFromClasspath ( propertyFilePath ) ; } else { properties = GlobalUtility . getProperties ( propertyFilePath ) ; } } catch ( FileNotFoundException e ) { logger . error ( errorMsg ) ; throw new NodeInitializationException ( errorMsg , propertyFilePath , e ) ; } catch ( IOException e ) { logger . error ( errorMsg ) ; throw new NodeInitializationException ( errorMsg , propertyFilePath , e ) ; } catch ( URISyntaxException e ) { logger . error ( errorMsg ) ; throw new NodeInitializationException ( errorMsg , propertyFilePath , e ) ; } Properties defaultProperties ; try { defaultProperties = GlobalUtility . getPropertiesFromClasspath ( GlobalUtility . TEMPLATE_PROPERTIES_FILE_NAME ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; throw new RuntimeException ( GlobalUtility . TEMPLATE_PROPERTIES_FILE_NAME + " file is missing in classpath - application error" ) ; } if ( ! properties . keySet ( ) . containsAll ( defaultProperties . keySet ( ) ) ) { String msg = "Cannot instanciate a Sensor using " + propertyFilePath + " file - missing required properties" ; logger . error ( msg ) ; throw new NodeInitializationException ( msg , propertyFilePath ) ; } String delimiter = GlobalUtility . VALUE_DELIMITER ; Channel [ ] leftChannels = null ; Channel [ ] rightChannels = null ; try { leftChannels = GlobalUtility . getChannelArray ( properties . getProperty ( "LEFT_CHANNEL_ID" ) . split ( delimiter ) , properties . getProperty ( "LEFT_CHANNEL_IP" ) . split ( delimiter ) , properties . getProperty ( "LEFT_CHANNEL_PORT" ) . split ( delimiter ) ) ; rightChannels = GlobalUtility . getChannelArray ( properties . getProperty ( "RIGHT_CHANNEL_ID" ) . split ( delimiter ) , properties . getProperty ( "RIGHT_CHANNEL_IP" ) . split ( delimiter ) , properties . getProperty ( "RIGHT_CHANNEL_PORT" ) . split ( delimiter ) ) ; } catch ( NumberFormatException e ) { String msg = "Cannot instanciate a Sensor using " + propertyFilePath + " file - RIGHT_CHANNEL_PORT invalid." ; logger . error ( msg ) ; throw new NodeInitializationException ( msg , propertyFilePath , e ) ; } try { return new Sensor ( properties . getProperty ( "ID" ) , Integer . parseInt ( properties . getProperty ( "PERIOD" ) ) , Integer . parseInt ( properties . getProperty ( "THRESHOLD" ) ) , Integer . parseInt ( properties . getProperty ( "LEFT_PORT" ) ) , Integer . parseInt ( properties . getProperty ( "RIGHT_PORT" ) ) , leftChannels , rightChannels , GlobalUtility . ACK_TIMEOUT_MS ) ; } catch ( NumberFormatException e ) { String msg = "Cannot instanciate a Sensor using " + propertyFilePath + " file - PERIOD  THRESHOLD  LEFT_PORT or RIGHT_PORT invalid." ; logger . error ( msg ) ; throw new NodeInitializationException ( msg , propertyFilePath , e ) ; } }
va	2	public static void main ( String [ ] args ) throws Exception { BufferedReader reader = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int [ ] numbers = new int [ 5 ] ; for ( int a = 0 ; a < numbers . length ; a ++ ) { numbers [ a ] = Integer . parseInt ( reader . readLine ( ) ) ; } Arrays . sort ( numbers ) ; for ( int b = 0 ; b < numbers . length ; b ++ ) { System . out . println ( numbers [ b ] ) ; } }
va	8	public void run ( ) { HWaccess . write ( Adressen . AuswahlklappeEingangslichtschranke . ordinal ( ) , true ) ; try { Thread . sleep ( 500 ) ; } catch ( InterruptedException e ) { } HWaccess . write ( Adressen . AuswahlklappeEingangslichtschranke . ordinal ( ) , false ) ; try { Thread . sleep ( 500 ) ; } catch ( InterruptedException e ) { } if ( type == FlaschenType . Mehrweg ) { HWaccess . write ( Adressen . UebergabelichtschrankeMehrweg . ordinal ( ) , true ) ; try { Thread . sleep ( 500 ) ; } catch ( InterruptedException e ) { } HWaccess . write ( Adressen . UebergabelichtschrankeMehrweg . ordinal ( ) , false ) ; try { Thread . sleep ( 500 ) ; } catch ( InterruptedException e ) { } } if ( type == FlaschenType . PET ) { HWaccess . write ( Adressen . UebergabelichtschrankePET . ordinal ( ) , true ) ; try { Thread . sleep ( 500 ) ; } catch ( InterruptedException e ) { } HWaccess . write ( Adressen . UebergabelichtschrankePET . ordinal ( ) , false ) ; try { Thread . sleep ( 500 ) ; } catch ( InterruptedException e ) { } } }
va	5	@ Override public String getColumnName ( int columnIndex ) { if ( columnIndex == DELIVERY_PACKET_ID ) { return "\u2116" ; } else if ( columnIndex == MEMBER_NAME ) { return "\u041A\u043E\u043C\u0443 \u0432\u044B\u0434\u0430\u043D\u043E" ; } else if ( columnIndex == EVENT ) { return "\u041C\u0435\u0440\u043E\u043F\u0440\u0438\u044F\u0442\u0438\u0435" ; } else if ( columnIndex == DELIVERY_DATE ) { return "\u0412\u044B\u0434\u0430\u043D\u043E" ; } else if ( columnIndex == EXPECTED_RETURN_DATE ) { return "\u0412\u043E\u0437\u0432\u0440\u0430\u0442\u0438\u0442\u044C" ; } else { logger . warn ( "\u041F\u043E\u043F\u044B\u0442\u043A\u0430 \u043F\u043E\u043B\u0443\u0447\u0438\u0442\u044C \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435 \u0434\u043B\u044F \u043D\u0435\u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u044E\u0449\u0435\u0433\u043E \u0441\u0442\u043E\u043E\u0431\u0446\u0430. " + "\u0421\u0442\u043E\u043B\u0431\u0435\u0446: " + columnIndex ) ; return "\u0421\u0442\u043E\u043B\u0431\u0435\u0446 \u2116" + columnIndex ; } }
va	2	public Object get ( String key ) throws JSONException { if ( key == null ) { throw new JSONException ( "Null key." ) ; } Object object = this . opt ( key ) ; if ( object == null ) { throw new JSONException ( "JSONObject[" + quote ( key ) + "] not found." ) ; } return object ; }
va	0	@ Override protected Connection getConnection ( ) throws SQLException { return DataSourceUtils . getConnection ( dataSource ) ; }
va	8	public Object dispatch ( mClass objClass , String methodName , Object ... parameters ) { Method m = getMethod ( methodName ) ; Object result = null ; Object obj = null ; int countOld = countNewOperator ; countNewOperator = 0 ; try { if ( objClass != null ) { obj = objClass ; } else if ( ! Modifier . isStatic ( m . getModifiers ( ) ) ) { obj = m . getDeclaringClass ( ) . newInstance ( ) ; if ( obj instanceof mClass ) { ( ( mClass ) obj ) . setContext ( this ) ; } } if ( m . getParameterTypes ( ) != null && m . getParameterTypes ( ) . length > 0 && m . getParameterTypes ( ) [ 0 ] . isArray ( ) ) { parameters = new Object [ ] { parameters } ; } if ( m . getReturnType ( ) . equals ( void . TYPE ) ) { m . invoke ( obj , parameters ) ; } else { result = m . invoke ( obj , parameters ) ; } } catch ( Exception e ) { throw new IllegalStateException ( "Fail to execute method: " + methodName + " and its parameters: " + Arrays . deepToString ( parameters ) , e ) ; } oldvar ( ) ; countNewOperator = countOld ; return result ; }
va	3	@ Override public boolean equals ( Object object ) { boolean result = false ; if ( object == null || object . getClass ( ) != getClass ( ) ) result = false ; else { Possibility other = ( Possibility ) object ; if ( this . money == other . money ) result = true ; } return result ; }
va	1	private String [ ] getShapeNames ( ) { String [ ] names = new String [ shapes . size ( ) ] ; for ( int i = 0 ; i < shapes . size ( ) ; i ++ ) { names [ i ] = shapes . get ( i ) . getName ( ) ; } return names ; }
va	2	public Asset getAsset ( String name ) throws IOException { Path p = getAssetFolder ( ) . resolve ( name ) ; for ( Asset a : assetIndexer . assets ) { if ( Files . isSameFile ( p , a . path ) ) return a ; } return null ; }
va	7	public void printHelp ( PrintWriter pw , int width , String cmdLineSyntax , String header , Options options , int leftPad , int descPad , String footer , boolean autoUsage ) { if ( ( cmdLineSyntax == null ) || ( cmdLineSyntax . length ( ) == 0 ) ) { throw new IllegalArgumentException ( "cmdLineSyntax not provided" ) ; } if ( autoUsage ) { printUsage ( pw , width , cmdLineSyntax , options ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } if ( ( header != null ) && ( header . trim ( ) . length ( ) > 0 ) ) { printWrapped ( pw , width , header ) ; } printOptions ( pw , width , options , leftPad , descPad ) ; if ( ( footer != null ) && ( footer . trim ( ) . length ( ) > 0 ) ) { printWrapped ( pw , width , footer ) ; } }
va	6	public boolean addCodeString ( CodeStringBean codeStringBean , ArtistInfoBean artistInfoBean , TrackInfoBean trackInfoBean , UserInfoBean infoBean ) { if ( checkCodeString ( codeStringBean , infoBean ) . equalsIgnoreCase ( "na" ) ) { try { connection = new DatabaseConnection ( ) . getConnection ( ) ; String add_String = "INSERT into codestringinfo (codestring  track_id   crc   username ) " + "VALUES (?   ?   ?  ?)" ; PreparedStatement preparedStatement = connection . prepareStatement ( add_String ) ; preparedStatement . setString ( 1 , codeStringBean . getCode_String ( ) ) ; preparedStatement . setString ( 2 , codeStringBean . getTrack_ID ( ) ) ; preparedStatement . setLong ( 3 , codeStringBean . getCrc ( ) ) ; preparedStatement . setString ( 4 , infoBean . getUsername ( ) ) ; boolean insertNewUserPlayListInfo = insertNewUserPlayListInfo ( codeStringBean , infoBean ) ; boolean addNewArtist = artistInfo . addNewArtist ( artistInfoBean ) ; boolean addNewTrack = trackInfo . addNewTrack ( trackInfoBean ) ; if ( insertNewUserPlayListInfo && addNewTrack && addNewArtist ) { int executeUpdate = preparedStatement . executeUpdate ( ) ; if ( executeUpdate > 0 ) { return true ; } else { trackInfo . reverseInfo ( codeStringBean . getTrack_ID ( ) ) ; return false ; } } else { return false ; } } catch ( SQLException ex ) { trackInfo . reverseInfo ( codeStringBean . getTrack_ID ( ) ) ; Logger . getLogger ( CodeStringInfo . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } } return false ; }
va	0	public int getTasksSize ( ) { return tasksSize ; }
va	1	public Vector4 normalizeW ( ) { if ( w != 1.0 ) { return new Vector4 ( x / w , y / w , z / w , 1 ) ; } return this ; }
va	5	@ Override public void act ( ) { if ( wander > 0 ) { wander -- ; this . move ( direction ) ; } else if ( ( player . getX ( ) == this . getX ( ) || player . getY ( ) == this . getY ( ) ) ) { this . moveTowardsTarget ( player . getX ( ) , player . getY ( ) ) ; } else if ( this . getX ( ) != homeX && this . getY ( ) != homeY ) { this . moveTowardsTarget ( homeX , homeY ) ; } else { wander = 10 ; this . direction = this . getRandomDirection ( ) ; } }
va	6	public static void main ( String [ ] args ) { Connection con = null ; String commonString = "databaseName=master;integratedSecurity=false;" ; String connectionStringINT = "jdbc:sqlserver://10.200.254.38:2325;" + commonString ; String userNameINT = "loadruser" ; String loginPasswordINT = "PerfTest4QA" ; try { class . forName ( "com.microsoft.sqlserver.jdbc.SQLServerDriver" ) ; con = DriverManager . getConnection ( connectionStringINT , userNameINT , loginPasswordINT ) ; } catch ( ClassNotFoundException cnfe ) { System . out . println ( cnfe ) ; System . exit ( 2 ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; } Statement stmt ; ResultSet rs ; try { if ( ! con . isClosed ( ) ) { stmt = con . createStatement ( ) ; rs = stmt . executeQuery ( "sp_helpdb tempdb" ) ; String temp ; System . out . println ( "Fetch Size " + rs . getFetchSize ( ) ) ; while ( rs . next ( ) ) { for ( int index = 1 ; index < rs . getFetchSize ( ) ; index ++ ) { temp = rs . getString ( index ) ; System . out . println ( temp ) ; index ++ ; } } } } catch ( SQLException e ) { e . printStackTrace ( ) ; } }
va	0	byte getState ( ) { super . setupFields ( ) ; return ( byte ) fields [ 0 ] . getValue ( ) ; }
va	1	private void onCreate ( ) throws SQLException { setDefaultCloseOperation ( javax . swing . WindowConstants . HIDE_ON_CLOSE ) ; int strLng = DbUtil . loadCategories ( ) . length ; categories = DbUtil . loadCategories ( ) ; for ( int i = 0 ; i < strLng ; i ++ ) { list1 . add ( String . valueOf ( categories [ i ] [ 1 ] ) ) ; } }
va	7	private void retornaPartida ( ) { List < DadosPartida > listaPartidasNaoFinalizadas = manipuladorPartidas . criarListaPartidasNaoFinalizadas ( ) ; Menu menuRetornarPartida = new MenuRetornarPartida ( ) ; boolean retornarAoMenu = false ; do { exibirPartidasNaoFinalizadas ( listaPartidasNaoFinalizadas ) ; ItemMenu itemEscolhido = menuRetornarPartida . insistirPorEntradaValida ( cli . getIo ( ) ) ; switch ( itemEscolhido . getNome ( ) ) { case "REINICIAR" : AplJogo apl = buscarCarregarPartida ( listaPartidasNaoFinalizadas ) ; if ( apl != null ) { try { apl . setSairPartida ( false ) ; controlarPartida ( apl ) ; retornarAoMenu = true ; } catch ( Exception e ) { cli . exibirAlerta ( "Nenhuma partida foi carregada" ) ; } } break ; case "APAGAR" : listaPartidasNaoFinalizadas = buscarApagarPartida ( listaPartidasNaoFinalizadas ) ; break ; case "RETORNAR" : List < DadosPartida > partidasfinalizadas = manipuladorPartidas . criarListaPartidasConcluidas ( ) ; List < DadosPartida > todasPartidas = new ArrayList < DadosPartida > ( ) ; todasPartidas . addAll ( partidasfinalizadas ) ; todasPartidas . addAll ( listaPartidasNaoFinalizadas ) ; try { manipuladorPartidas . gravarPartidas ( todasPartidas ) ; } catch ( IOException e ) { cli . exibirAlerta ( "Houve um erro ao persistir os dados." ) ; } retornarAoMenu = true ; break ; } } while ( ! retornarAoMenu ) ; }
va	9	public JSONObject ( JSONTokener x ) throws JSONException { this ( ) ; char c ; String key ; if ( x . nextClean ( ) != { ) { throw x . syntaxError ( "A JSONObject text must begin with '{'" ) ; } for ( ; ; ) { c = x . nextClean ( ) ; switch ( c ) { case 0 : throw x . syntaxError ( "A JSONObject text must end with '}'" ) ; case } : return ; default : x . back ( ) ; key = x . nextValue ( ) . toString ( ) ; } c = x . nextClean ( ) ; if ( c == = ) { if ( x . next ( ) != > ) { x . back ( ) ; } } else if ( c != : ) { throw x . syntaxError ( "Expected a ':' after a key" ) ; } this . putOnce ( key , x . nextValue ( ) ) ; switch ( x . nextClean ( ) ) { case ; : case   : if ( x . nextClean ( ) == } ) { return ; } x . back ( ) ; break ; case } : return ; default : throw x . syntaxError ( "Expected a ' ' or '}'" ) ; } } }
va	3	@ Override public Type visitCallStmt ( CallStmt stmt , IdTable table ) { stmt . methodRef . visit ( this , table ) ; MethodDecl md = ( MethodDecl ) stmt . methodRef . decl ; if ( md . parameterDeclList . size ( ) != stmt . argList . size ( ) ) { Reporter . emit ( "Expected " + md . parameterDeclList . size ( ) + " parameters at " + stmt . posn ) ; return null ; } for ( int i = 0 ; i < stmt . argList . size ( ) ; i ++ ) { Expression e = stmt . argList . get ( i ) ; Type exprType = e . visit ( this , table ) ; ParameterDecl pd = md . parameterDeclList . get ( i ) ; if ( ! match ( pd . type , exprType ) ) { Reporter . emit ( "Parameter " + pd . name + " is of type " + pd . type + " but got " + exprType + " at " + e . posn ) ; } } return null ; }
