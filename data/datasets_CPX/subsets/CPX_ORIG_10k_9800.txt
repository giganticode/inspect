te	2	@ Override public long waitFor ( final long sequence , final Sequence cursor , final Sequence [ ] dependents , final SequenceBarrier barrier , final long timeout , final TimeUnit sourceUnit ) throws AlertException , InterruptedException { if ( timeout == 0 ) { final long availableSequence = cursor . get ( ) ; if ( availableSequence >= sequence ) { return availableSequence ; } } return this . realStrategy . waitFor ( sequence , cursor , dependents , barrier , timeout , sourceUnit ) ; }
te	6	public static double pt ( double t , double df ) { double a , b , idf , im2 , ioe , s , c , ks , fk , k ; double g1 = 0.3183098862 ; if ( df < 1 ) throw new IllegalArgumentException ( "Illegal argument df for pt(t df)." ) ; idf = df ; a = t / Math . sqrt ( idf ) ; b = idf / ( idf + t * t ) ; im2 = df - 2 ; ioe = idf % 2 ; s = 1 ; c = 1 ; idf = 1 ; ks = 2 + ioe ; fk = ks ; if ( im2 >= 2 ) { for ( k = ks ; k <= im2 ; k += 2 ) { c = c * b * ( fk - 1 ) / fk ; s += c ; if ( s != idf ) { idf = s ; fk += 2 ; } } } if ( ioe != 1 ) return 0.5 + 0.5 * a * Math . sqrt ( b ) * s ; if ( df == 1 ) s = 0 ; return 0.5 + ( a * b * s + Math . atan ( a ) ) * g1 ; }
te	8	private void initValues ( ) { for ( String trueValue : TrueFalse . getInstance ( ) . allTrueValues ( ) ) { addTrueValue ( trueValue ) ; } for ( String yesValue : YesNo . getInstance ( ) . allTrueValues ( ) ) { addTrueValue ( yesValue ) ; } for ( String onValue : OnOff . getInstance ( ) . allTrueValues ( ) ) { addTrueValue ( onValue ) ; } for ( String oneValue : OneZero . getInstance ( ) . allTrueValues ( ) ) { addTrueValue ( oneValue ) ; } for ( String falseValue : TrueFalse . getInstance ( ) . allFalseValues ( ) ) { addFalseValue ( falseValue ) ; } for ( String noValue : YesNo . getInstance ( ) . allFalseValues ( ) ) { addFalseValue ( noValue ) ; } for ( String offValue : OnOff . getInstance ( ) . allFalseValues ( ) ) { addFalseValue ( offValue ) ; } for ( String zeroValue : OneZero . getInstance ( ) . allFalseValues ( ) ) { addFalseValue ( zeroValue ) ; } }
te	8	@ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; PhpposEmployeesEntity that = ( PhpposEmployeesEntity ) o ; if ( personId != that . personId ) return false ; if ( password != null ? ! password . equals ( that . password ) : that . password != null ) return false ; if ( username != null ? ! username . equals ( that . username ) : that . username != null ) return false ; return true ; }
te	6	@ Override protected AbstractHashTableMap . HashEntryPosition findEntry ( K key ) throws InvalidKeyException { int avail = - 1 ; checkKey ( key ) ; int i = hashValue ( key ) ; final int j = i ; int k = 0 ; do { Entry < K , V > e = bucket [ i ] ; if ( e == null ) { if ( avail < 0 ) { avail = i ; } break ; } else if ( key . equals ( e . getKey ( ) ) ) { return new AbstractHashTableMap . HashEntryPosition ( i , AbstractHashTableMap . OperationType . found ) ; } else if ( e == AVAILABLE ) { if ( avail < 0 ) { avail = i ; } } k ++ ; i = ( j + constant1 * k + constant2 * ( k * k ) ) % capacity ; } while ( i != j ) ; return new AbstractHashTableMap . HashEntryPosition ( avail , AbstractHashTableMap . OperationType . notFound ) ; }
te	4	private void initComponents ( ) { setDefaultCloseOperation ( EXIT_ON_CLOSE ) ; design = new DesignPanel ( ) ; design . setPreferredSize ( new Dimension ( 12 + LocationManager . getSize ( ) . x * 36 , 18 + LocationManager . getSize ( ) . y * 35 ) ) ; design . addMouseListener ( new MouseAdapter ( ) { public void mouseClicked ( MouseEvent evt ) { Point p = HexMech . pxtoHex ( evt . getX ( ) , evt . getY ( ) ) ; if ( unitButtons . isSelected ( ) ) { LocationManager . addUnit ( p , unitButtons . getUnitName ( ) , team ) ; } else { if ( ! LocationManager . getLoc ( p ) . isEmpty ( ) ) { UnitManager . getInstance ( ) . removeUnit ( LocationManager . getLoc ( p ) . getUnit ( ) ) ; } LocationManager . newLoc ( p , type ) ; } if ( type == 5 || type == 6 ) { render ( ) ; } else { design . draw ( p . x , p . y ) ; } } } ) ; scroll = new JScrollPane ( design ) ; scroll . setPreferredSize ( design . getPreferredSize ( ) ) ; initButtons ( ) ; layoutComponents ( ) ; layoutButtons ( ) ; this . setExtendedState ( this . getExtendedState ( ) | JFrame . MAXIMIZED_BOTH ) ; pack ( ) ; }
te	9	public String [ ] getOverallForecast ( ) throws Exception { String [ ] forecast = new String [ 2 ] ; try { layers ++ ; BufferedReader br = new BufferedReader ( new InputStreamReader ( new URL ( MakeURL . overallURL ( zip ) ) . openStream ( ) ) ) ; String line = "" ; line = br . readLine ( ) ; int index = 0 ; forecast [ 0 ] = forecast [ 1 ] = "" ; while ( line != null && ! line . contains ( "<div id=\"fct_day_" + dayNumber + "\"" ) ) { line = br . readLine ( ) ; } while ( ! line . contains ( "<div class=\"fctHiLow\">" ) ) { line = br . readLine ( ) ; } line = br . readLine ( ) ; if ( line == null ) { throw new Exception ( ) ; } if ( line . contains ( "<span class=\"b\">" ) ) { index = line . indexOf ( "<span class=\"b\">" ) + 16 ; while ( Character . isDigit ( line . charAt ( index ) ) | line . charAt ( index ) == - ) { forecast [ 0 ] = forecast [ 0 ] + line . charAt ( index ) ; index ++ ; } } else { throw new Exception ( ) ; } while ( ! line . contains ( "<div class=\"popValue\">" ) ) { line = br . readLine ( ) ; } index = line . indexOf ( "<div class=\"popValue\">" ) + 22 ; while ( Character . isDigit ( line . charAt ( index ) ) ) { forecast [ 1 ] = forecast [ 1 ] + line . charAt ( index ) ; index ++ ; } layers = 0 ; return forecast ; } catch ( Exception e ) { if ( layers > 5 ) { for ( int i = 0 ; i < 1 ; i ++ ) { forecast [ i ] = "" ; } WeatherRecorder . printError ( e , zip ) ; layers = 0 ; return forecast ; } else { Thread . sleep ( 2000 ) ; return getHourlyForecastTemps ( ) ; } } }
te	8	public void render ( Graphics g , Camera camera ) { int x0 = camera . x >> 4 ; int x1 = ( camera . x + camera . width + 16 ) >> 4 ; int y0 = camera . y >> 4 ; int y1 = ( camera . y + camera . height + 16 ) >> 4 ; for ( int y = y0 ; y < y1 ; y ++ ) { for ( int x = x0 ; x < x1 ; x ++ ) { if ( x >= 0 && y >= 0 && x < width && y < height ) { if ( world [ x ] [ y ] != null ) { world [ x ] [ y ] . render ( x , y , g ) ; } } } } for ( int i = 0 ; i <= entities . size ( ) - 1 ; i ++ ) { Entity e = entities . get ( i ) ; e . render ( g , camera ) ; } }
te	8	private ArrayList < Integer > getNormalNeurons ( int bestNeuron , double threshold ) { TreeMap neighboorhood = null ; Iterator it , innerIter = null ; ArrayList < Integer > neuronsConsidered = new ArrayList < Integer > ( ) ; ArrayList < Integer > nextNeurons = new ArrayList < Integer > ( ) ; ArrayList < Integer > normalNeurons = new ArrayList < Integer > ( ) ; int numberOfNormalNeurons = Controller . getConfig ( ) . getNumberofNormalNeurons ( ) ; int neighborNeuron , innerNeighborNeurons , distance = 0 ; double tmpDistance ; neuronsConsidered . add ( bestNeuron ) ; while ( normalNeurons . size ( ) <= numberOfNormalNeurons && distance < 5 ) { for ( int neuronConsidered : neuronsConsidered ) { neighboorhood = topology . getNeighbours ( neuronConsidered ) ; it = neighboorhood . keySet ( ) . iterator ( ) ; while ( it . hasNext ( ) ) { neighborNeuron = ( int ) it . next ( ) ; nextNeurons . add ( neighborNeuron ) ; neighboorhood = topology . getNeighbours ( neighborNeuron ) ; innerIter = neighboorhood . keySet ( ) . iterator ( ) ; tmpDistance = 0 ; while ( innerIter . hasNext ( ) ) { innerNeighborNeurons = ( int ) innerIter . next ( ) ; tmpDistance += ComputationUtility . calculateDistance ( networkModel . getNeuron ( innerNeighborNeurons ) , networkModel . getNeuron ( neighborNeuron ) ) ; } if ( tmpDistance < threshold ) { normalNeurons . add ( neighborNeuron ) ; if ( normalNeurons . size ( ) == numberOfNormalNeurons ) return normalNeurons ; } } } if ( nextNeurons . size ( ) > 0 ) { neuronsConsidered = null ; distance ++ ; neuronsConsidered = ( ArrayList < Integer > ) nextNeurons . clone ( ) ; nextNeurons . clear ( ) ; } else break ; } return normalNeurons ; }
te	4	public void initMenus ( ) throws ConfigurationException , DocumentException , IOException { List < MenuProp > list = ToolsUtil . getToolBarsConfigure ( ) ; for ( MenuProp menu : list ) { try { JMenu jMenu = new JMenu ( menu . getName ( ) ) ; jMenu . setName ( menu . getName ( ) ) ; jMenu . setLayout ( null ) ; jMenu . setBounds ( 0 , 0 , 100 , 30 ) ; for ( MenuItemProp menuItem : menu . getDescendants ( ) ) { try { JMenuItem jMenuItem = new JMenuItem ( menuItem . getName ( ) ) ; jMenuItem . setName ( menuItem . getName ( ) ) ; jMenuItem . setBounds ( 0 , 0 , 100 , 30 ) ; jMenuItem . addActionListener ( ( ( ActionListener ) class . forName ( menuItem . getClassName ( ) ) . newInstance ( ) ) ) ; jMenu . add ( jMenuItem ) ; } catch ( Exception e ) { FULogger . log ( LogLevel . ERROR , new Date ( ) , this . getClass ( ) , "MenuItem : [" + menuItem . getName ( ) + "] at Menu:[" + menu . getName ( ) + "] was initialized failed!\r\n" + e . getMessage ( ) , e ) ; } } menuBar . add ( jMenu ) ; } catch ( Exception e ) { FULogger . log ( LogLevel . ERROR , new Date ( ) , this . getClass ( ) , "Menu:[" + menu . getName ( ) + "] was initialized failed!\r\n" + e . getMessage ( ) , e ) ; } } mainFrame . repaint ( ) ; }
te	0	public String getTelephone ( ) { return telephone ; }
te	2	@ Override public void finalizeConnector ( ) throws OntologyConnectorException { if ( server != null ) { try { server . close ( ) ; } catch ( IOException e ) { throw new OntologyConnectorException ( "Could not close the socket server!" ) ; } } keepOn = false ; }
te	2	private boolean doesUsernameExist ( String szUsername ) throws IOException { Scanner scan = new Scanner ( file ) ; String [ ] szDec = null ; boolean bRet = false ; while ( scan . hasNextLine ( ) ) { szDec = Xor . decrypt ( scan . nextLine ( ) ) . split ( ":" ) ; if ( szDec [ 0 ] . equalsIgnoreCase ( szUsername ) ) bRet = true ; } scan . close ( ) ; return bRet ; }
te	8	private boolean parseOptions ( String [ ] args ) { CommandLineParser parser = new GnuParser ( ) ; try { CommandLine cl = parser . parse ( opts , args ) ; if ( cl . hasOption ( "help" ) ) { showUsage ( ) ; System . exit ( 0 ) ; } if ( cl . hasOption ( "version" ) ) { showVersion ( ) ; System . exit ( 0 ) ; } if ( cl . hasOption ( "precision" ) ) { try { precision = Integer . parseInt ( cl . getOptionValue ( "precision" ) ) ; if ( precision < 0 || precision > 15 ) throw new NumberFormatException ( ) ; } catch ( NumberFormatException nfe ) { System . err . println ( "\nprecision must be a positive integer value in the range [0 15]" ) ; return false ; } } if ( cl . getArgs ( ) . length == 0 ) { System . err . println ( "\nyou must specify at least one file to analyse" ) ; return false ; } collectionFiles = cl . getArgs ( ) ; } catch ( ParseException e ) { System . err . println ( "" ) ; System . err . println ( e . getMessage ( ) ) ; return false ; } return true ; }
te	0	private LayeredMap makeDungeonMap ( ) { Properties props = new Properties ( ) ; props . setProperty ( "map_layers" , "4" ) ; props . setProperty ( "roomGapHoriz" , "7" ) ; props . setProperty ( "roomGapVert" , "3" ) ; props . setProperty ( "floors" , ".:s" ) ; props . setProperty ( "room_floors" , ".:s" ) ; props . setProperty ( "corridor_floors" , ".:s" ) ; Dungeon dungeon = new Dungeon ( "" , props ) ; LayeredMap map = dungeon . generate ( 65 , 40 ) ; return map ; }
te	9	public List < String > getGloss ( Concept synset , String linkString ) { String key = synset + " " + linkString ; if ( WS4JConfiguration . getInstance ( ) . useCache ( ) ) { List < String > cachedObj = cache . get ( key ) ; if ( cachedObj != null ) return clone ( cachedObj ) ; } List < String > linkedSynsets = new ArrayList < String > ( ) ; Link link = null ; try { link = Link . valueOf ( linkString ) ; if ( link . equals ( Link . mero ) ) { linkedSynsets . addAll ( linkToSynsets ( synset . getSynset ( ) , Link . mmem ) ) ; linkedSynsets . addAll ( linkToSynsets ( synset . getSynset ( ) , Link . msub ) ) ; linkedSynsets . addAll ( linkToSynsets ( synset . getSynset ( ) , Link . mprt ) ) ; } else if ( link . equals ( Link . holo ) ) { linkedSynsets . addAll ( linkToSynsets ( synset . getSynset ( ) , Link . hmem ) ) ; linkedSynsets . addAll ( linkToSynsets ( synset . getSynset ( ) , Link . hsub ) ) ; linkedSynsets . addAll ( linkToSynsets ( synset . getSynset ( ) , Link . hprt ) ) ; } else if ( link . equals ( Link . syns ) ) { linkedSynsets . add ( synset . getSynset ( ) ) ; } else { linkedSynsets . addAll ( linkToSynsets ( synset . getSynset ( ) , link ) ) ; } } catch ( IllegalArgumentException e ) { linkedSynsets . add ( synset . getSynset ( ) ) ; } List < String > glosses = new ArrayList < String > ( linkedSynsets . size ( ) ) ; for ( String linkedSynset : linkedSynsets ) { String gloss = null ; if ( Link . syns . equals ( link ) ) { gloss = synset . getName ( ) ; if ( gloss == null ) { gloss = SynsetDAO . findSynsetBySynset ( linkedSynset ) . getName ( ) ; } } else { SynsetDef synsetDef = SynsetDefDAO . findSynsetDefBySynsetAndLang ( linkedSynset , Lang . eng ) ; gloss = WordNetUtil . getGloss ( synsetDef ) ; } if ( gloss == null ) continue ; gloss = gloss . replaceAll ( "[.;: ?!(){}\"`$%@<>]" , " " ) ; gloss = gloss . replaceAll ( "&" , " and " ) ; gloss = gloss . replaceAll ( "_" , " " ) ; gloss = gloss . replaceAll ( "[ ]+" , " " ) ; gloss = gloss . replaceAll ( "(?<!\\w)'" , " " ) ; gloss = gloss . replaceAll ( "'(?!\\w)" , " " ) ; gloss = gloss . replaceAll ( "--" , " " ) ; gloss = gloss . toLowerCase ( ) ; if ( WS4JConfiguration . getInstance ( ) . useStem ( ) ) { gloss = stemmer . stemSentence ( gloss ) ; } glosses . add ( gloss ) ; } if ( WS4JConfiguration . getInstance ( ) . useCache ( ) ) { if ( cache . size ( ) >= WS4JConfiguration . getInstance ( ) . getMaxCacheSize ( ) ) { cache . remove ( cache . keySet ( ) . iterator ( ) . next ( ) ) ; } if ( glosses != null ) cache . put ( key , clone ( glosses ) ) ; } return glosses ; }
te	3	public boolean heeftPermissie ( Permissie permissie ) { for ( Rol rol : rollen ) { for ( Permissie p : rol . getPermissies ( ) ) { if ( p . equals ( permissie ) ) { return true ; } } } return false ; }
te	1	public boolean finishWrite ( ) { return this . fileSizeLeft > 0 ? false : true ; }
te	0	public ProcedimentoNaoDeclaradoException ( Id id ) { super ( "Procedimento " + id + " n\u00E3o declarado." ) ; }
te	5	@ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; Algorithm algo = ( Algorithm ) obj ; if ( getURI ( ) != null && getURI ( ) . equals ( algo . getURI ( ) ) ) return true ; if ( getURI ( ) == null && ( this . getClass ( ) . isInstance ( obj ) ) ) return true ; return false ; }
te	1	@ Test ( dataProvider = "HTMLContentProvider" ) public void ValidHTMLLinkTest ( String html ) { Vector < HtmlLink > links = htmlLinkExtrator . grabHTMLLinks ( html ) ; assert . assertTrue ( links . size ( ) != 0 ) ; for ( int i = 0 ; i < links . size ( ) ; i ++ ) { HtmlLink htmlLinks = links . get ( i ) ; System . out . println ( htmlLinks ) ; } }
te	5	public int lengthOfLongestSubstring ( String s ) { if ( s == null || s . length ( ) == 0 ) return 0 ; int n = s . length ( ) ; boolean [ ] table = new boolean [ 256 ] ; int last = 0 , index = 0 , maxLen = 0 ; while ( index < n ) { char c = s . charAt ( index ) ; if ( table [ c ] ) { maxLen = Math . max ( maxLen , index - last ) ; while ( s . charAt ( last ) != c ) { table [ s . charAt ( last ) ] = false ; last ++ ; } last ++ ; index ++ ; } else { table [ c ] = true ; index ++ ; maxLen = Math . max ( maxLen , index - last ) ; } } return maxLen ; }
te	3	public T next ( ) throws NoSuchElementException { if ( current == null ) { if ( head == null ) throw new NoSuchElementException ( "No Items in the list..." ) ; current = head ; idx ++ ; return head . item ; } else if ( current . next != null ) { T item = current . next . item ; current = current . next ; idx ++ ; return item ; } else { throw new NoSuchElementException ( "At end of list." ) ; } }
te	3	@ Override public UserModel getUser ( String email ) throws WebshopAppException { if ( isValidEmail ( email , "GET_USER" ) ) { try ( Connection conn = getConnection ( ) ) { String sql = "SELECT * FROM users WHERE email = ?" ; try ( PreparedStatement pstmt = conn . prepareStatement ( sql ) ) { setString ( pstmt , 1 , email ) ; try ( ResultSet rs = pstmt . executeQuery ( ) ) { if ( rs . next ( ) ) { UserModel user = parseModel ( rs ) ; Log . logOut ( LOGGER , this , "GET_USER" , "User deleted: " , user . toString ( ) ) ; return user ; } } } } catch ( SQLException e ) { WebshopAppException excep = new WebshopAppException ( e . getMessage ( ) , this . getClass ( ) . getSimpleName ( ) , "GET_USER" ) ; Log . logOutWAException ( LOGGER , excep ) ; throw excep ; } } return null ; }
te	5	@ Override public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( obj == null ) { return false ; } if ( this . getClass ( ) != obj . getClass ( ) ) { return false ; } Section other = ( Section ) obj ; if ( this . sectionX != other . sectionX ) { return false ; } if ( this . sectionZ != other . sectionZ ) { return false ; } return true ; }
te	5	@ Override public void actionPerformed ( ActionEvent e ) { try { String [ ] newData = new String [ fields ] ; for ( int i = 0 ; i < fields - 1 ; i ++ ) { newData [ i ] = textFields [ i ] . getText ( ) ; } newData [ fields - 1 ] = textArea . getText ( ) ; control . editCard ( fieldData , newData ) ; dispose ( ) ; } catch ( NullInputException ex ) { message . setText ( "Korttia  jonka kaikki kent\u00E4t ovat tyhi\u00E4 ei voi olla olemassa." ) ; message . setForeground ( Color . red ) ; } catch ( AlmostSameCardExistsException ex ) { message . setText ( "Kortti  jolla on sama nimeke ja tekij\u00E4 on jo olemassa!" ) ; message . setForeground ( Color . red ) ; } catch ( CardAlreadyExistsException ex ) { } catch ( NullPointerException ex ) { message . setText ( "Muokattavaa korttia ei en\u00E4\u00E4 ole olemassa." ) ; message . setForeground ( Color . red ) ; } }
te	0	public LoginUserModel LoginUserInfo ( String userloginName ) { LoginUserModel loginUserModel = loginUserDao . FindloginUser ( userloginName ) ; return loginUserModel ; }
te	0	@ Override public void capturePhotos ( ) { }
te	2	public void packTag ( byte [ ] bytes ) throws NotSupportedException { int offset = packHeader ( bytes , 0 ) ; if ( extendedHeader ) { offset = packExtendedHeader ( bytes , offset ) ; } offset = packFrames ( bytes , offset ) ; if ( footer ) { offset = packFooter ( bytes , dataLength ) ; } }
te	7	public void postorderTraversalIterative ( ArrayList < Integer > list , TreeNode node ) { Stack < TreeNode > stack = new Stack < TreeNode > ( ) ; while ( true ) { if ( node != null ) { if ( node . right != null ) stack . push ( node . right ) ; stack . push ( node ) ; node = node . left ; continue ; } if ( stack . isEmpty ( ) ) return ; node = stack . pop ( ) ; if ( node . right != null && ! stack . isEmpty ( ) && node . right == stack . peek ( ) ) { stack . pop ( ) ; stack . push ( node ) ; node = node . right ; } else { list . add ( node . val ) ; node = null ; } } }
te	0	public MpegFrame ( byte frameData1 , byte frameData2 , byte frameData3 , byte frameData4 ) throws InvalidDataException { long frameHeader = BufferTools . unpackInteger ( frameData1 , frameData2 , frameData3 , frameData4 ) ; setFields ( frameHeader ) ; }
te	3	@ Provides @ Singleton final OSType detectOS ( ) { final String osName = getProperty ( "os.name" , "generic" ) . toLowerCase ( ) ; if ( osName . indexOf ( "mac" ) >= 0 ) { return OSType . MacOS ; } else if ( osName . indexOf ( "nux" ) >= 0 ) { return OSType . Linux ; } else if ( osName . indexOf ( "win" ) >= 0 ) { return OSType . Windows ; } else { return OSType . Other ; } }
te	1	public static boolean getButtonDown ( int button ) { return getButton ( button ) && ! lastButton [ button ] ; }
te	0	@ Override public Shape getShape ( int shapeIndex ) { return myShapePalette . getShape ( shapeIndex ) ; }
te	1	public static boolean isUriLetterOrDigit ( char c ) { return ( isUriLetter ( c ) || isUriDigit ( c ) ) ; }
te	1	public static void main ( String [ ] args ) { EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { try { MainWindow window = new MainWindow ( ) ; window . frmCarPurchase . setVisible ( true ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } } ) ; }
te	9	public static void arraycopy ( final ComplexDoubleLargeArray src , final long srcPos , final ComplexDoubleLargeArray dest , final long destPos , final long length ) { if ( srcPos < 0 || srcPos >= src . length ( ) ) { throw new ArrayIndexOutOfBoundsException ( "srcPos < 0 || srcPos >= src.length()" ) ; } if ( destPos < 0 || destPos >= dest . length ( ) ) { throw new ArrayIndexOutOfBoundsException ( "destPos < 0 || destPos >= dest.length()" ) ; } if ( length < 0 ) { throw new IllegalArgumentException ( "length < 0" ) ; } if ( dest . isConstant ( ) ) { throw new IllegalArgumentException ( "Constant arrays cannot be modified." ) ; } int nthreads = ( int ) Math . min ( length , Runtime . getRuntime ( ) . availableProcessors ( ) ) ; if ( nthreads < 2 || length < 100000 ) { for ( long i = srcPos , j = destPos ; i < srcPos + length ; i ++ , j ++ ) { dest . setComplexDouble ( j , src . getComplexDouble ( i ) ) ; } } else { long k = length / nthreads ; Thread [ ] threads = new Thread [ nthreads ] ; for ( int j = 0 ; j < nthreads ; j ++ ) { final long firstIdx = j * k ; final long lastIdx = ( j == nthreads - 1 ) ? length : firstIdx + k ; threads [ j ] = new Thread ( new Runnable ( ) { @ Override public void run ( ) { for ( long k = firstIdx ; k < lastIdx ; k ++ ) { dest . setComplexDouble ( destPos + k , src . getComplexDouble ( srcPos + k ) ) ; } } } ) ; threads [ j ] . start ( ) ; } try { for ( int j = 0 ; j < nthreads ; j ++ ) { threads [ j ] . join ( ) ; threads [ j ] = null ; } } catch ( InterruptedException ex ) { for ( long i = srcPos , j = destPos ; i < srcPos + length ; i ++ , j ++ ) { dest . setComplexDouble ( j , src . getComplexDouble ( i ) ) ; } } } }
te	2	@ Override public void setWarningIcon ( ) { if ( SwingUtilities . isEventDispatchThread ( ) ) { if ( ! warningIconImage . equals ( trayIcon . getImage ( ) ) ) { trayIcon . setImage ( warningIconImage ) ; System . out . println ( "\u8D64\u30A2\u30A4\u30B3\u30F3\u70B9\u6EC5" ) ; resetTrayIcon ( ) ; } } else { SwingUtilities . invokeLater ( new Runnable ( ) { @ Override public void run ( ) { setWarningIcon ( ) ; } } ) ; } }
te	4	public static void dropTable ( String tableName ) throws DatabaseException { verifyExist ( tableName ) ; Table deleteTable = tablesMap . get ( tableName ) ; for ( Table table : tablesMap . values ( ) ) { if ( table == deleteTable ) continue ; Schema . ForeignKey [ ] foreignKeys = table . getSchema ( ) . getForeignKeys ( ) ; for ( Schema . ForeignKey fk : foreignKeys ) { String refTableName = fk . getRefTableName ( ) ; if ( refTableName . equals ( deleteTable . getName ( ) ) ) { throw new DatabaseException ( "Table '" + table . getName ( ) + "' references this table." ) ; } } } tablesMap . remove ( tableName ) ; }
te	7	public String saveKeyFile ( String data ) { String path = null ; JFileChooser fileDialog = new JFileChooser ( new File ( homePath ) ) ; int isSelected = fileDialog . showSaveDialog ( null ) ; if ( isSelected == JFileChooser . APPROVE_OPTION ) { File file = fileDialog . getSelectedFile ( ) ; path = file . getAbsolutePath ( ) ; if ( path . indexOf ( . ) != - 1 ) path = path . substring ( 0 , path . indexOf ( . ) ) ; path += ".key" ; BufferedOutputStream out = null ; if ( file != null ) { try { out = new BufferedOutputStream ( new FileOutputStream ( path ) ) ; out . write ( data . getBytes ( ) ) ; } catch ( FileNotFoundException e1 ) { e1 . printStackTrace ( ) ; } catch ( IOException e1 ) { e1 . printStackTrace ( ) ; } finally { if ( out != null ) { try { out . close ( ) ; } catch ( IOException e1 ) { e1 . printStackTrace ( ) ; } } } } } return path ; }
te	0	private void copy ( ) { TextComponentUtil . copy ( currentTextComponent ) ; }
te	2	@ Override public void actionPerformed ( ActionEvent e ) { String cmd = e . getActionCommand ( ) ; switch ( cmd ) { case CANCELAR : cerrar ( ) ; break ; case GUARDAR : ctrlInformacion . guardarNuevaNota ( ) ; break ; } }
te	9	protected void stepBackward ( ) { CellElement currentCell ; switch ( m_currentPhase ) { case PHASE_CALC_GRID : m_currentStep -- ; if ( m_currentStep <= 0 ) { stepZero ( ) ; return ; } Point realD = getCoordsByStep ( m_currentStep ) ; currentCell = m_dpTable . getCell ( realD . x , realD . y ) ; currentCell . clearAll ( ) ; m_currentStep -- ; stepForward ( true ) ; break ; case PHASE_SELECT_LOCAL : putFourDrawablePanel ( ) ; m_currentStep -- ; m_currentPhase = PHASE_CALC_GRID ; m_dpTable . clearHighlightColors ( ) ; m_dpTable . clearInteractiveCells ( ) ; stepForward ( true ) ; break ; case PHASE_BACKTRACK : currentCell = ( CellElement ) m_backTrackList . getLast ( ) ; currentCell . clearColor ( ) ; if ( m_backTrackList . size ( ) <= 1 ) { m_currentPhase = PHASE_SELECT_LOCAL ; m_backTrackList . clear ( ) ; m_dpTable . clearAllArrows ( ) ; m_dpTable . clearGridCircle ( ) ; m_dpTable . clearHighlightColors ( ) ; m_dpTable . clearInteractiveCells ( ) ; setInfoMessage ( "Select Starting local!" ) ; m_lDEqual . setText ( "D(x  x) = Select" ) ; m_l1Choiche . setText ( "No Pointer" ) ; m_l2Choiche . setText ( "No Pointer" ) ; m_l3Choiche . setText ( "No Pointer" ) ; this . findMaxValues ( ) ; } else { m_backTrackList . removeLast ( ) ; currentCell = ( CellElement ) m_backTrackList . getLast ( ) ; currentCell . clearColor ( ) ; if ( m_backTrackList . size ( ) == 0 ) { m_backtrackLastSel = m_dpTable . getLastCell ( ) ; } else { m_backtrackLastSel = ( CellElement ) m_backTrackList . getLast ( ) ; m_backTrackList . removeLast ( ) ; } boolean toErase = false ; for ( int i = 0 ; i < 3 ; i ++ ) { if ( m_resLine [ i ] . length ( ) > 1 ) { m_resLine [ i ] = m_resLine [ i ] . substring ( 2 , m_resLine [ i ] . length ( ) ) ; } else { m_resLine [ i ] = "" ; toErase = true ; } } if ( toErase ) { m_bottomResultArea . setText ( "" ) ; } stepFWDBackTrack ( true ) ; } break ; } }
te	2	private void flush ( ) throws IOException { if ( groups != null ) { for ( Map < String , Object > map : groups . values ( ) ) { this . delegate . output ( map ) ; } groups . clear ( ) ; } }
te	7	private boolean areFieldsFull ( ) { if ( ! "" . equals ( competitionNameField . getText ( ) ) && ! "" . equals ( redAllianceTeam1 . getText ( ) ) && ! "" . equals ( redAllianceTeam2 . getText ( ) ) && ! "" . equals ( redAllianceTeam3 . getText ( ) ) && ! "" . equals ( blueAllianceTeam1 . getText ( ) ) && ! "" . equals ( blueAllianceTeam2 . getText ( ) ) && ! "" . equals ( blueAllianceTeam3 . getText ( ) ) ) { return true ; } else { return false ; } }
te	5	private boolean readExponent ( ) throws IOException { if ( ! readChar ( e ) && ! readChar ( E ) ) { return false ; } if ( ! readChar ( + ) ) { readChar ( - ) ; } if ( ! readDigit ( ) ) { throw expected ( "digit" ) ; } while ( readDigit ( ) ) { } return true ; }
te	3	private void fixTileLayout ( Tile tile ) { for ( int i = 0 ; i < map . length ; i ++ ) { for ( int j = 0 ; j < map [ 0 ] . length ; j ++ ) { if ( map [ i ] [ j ] . contains ( tile ) ) { ArrayList < DIRECTION > directionsArr = generateArrayOfDirections ( tile , i , j ) ; map [ i ] [ j ] . getTileOfType ( tile ) . SetPart ( directionsArr ) ; } } } }
te	0	public NumberCode ( byte [ ] base ) { super ( base ) ; this . code = 0 ; }
te	6	public synchronized void start ( ) throws RemoteException { if ( isStarted ( ) ) return ; if ( ! isStartable ( ) ) throw new RemoteException ( "service restart not allowed" ) ; Logger . info ( "starting db service" ) ; try { Logger . info ( "request from host: " + UnicastRemoteObject . getClientHost ( ) ) ; } catch ( ServerNotActiveException soe ) { } String driver = getJdbcDriver ( ) ; try { if ( loader != null ) { try { DriverManager . registerDriver ( new MyDriver ( driver , loader ) ) ; } catch ( Throwable t ) { throw new RemoteException ( "unable to load jdbc driver" , t ) ; } } else { class . forName ( driver ) ; } } catch ( ClassNotFoundException e2 ) { Logger . error ( "unable to load jdbc driver " + driver , e2 ) ; throw new RemoteException ( "unable to load jdbc driver " + driver , e2 ) ; } started = true ; }
te	0	public Node ( ) { }
te	6	public void refactorViews ( ) { int x = getXpos ( ) ; int y = getYpos ( ) + 20 ; int c = radialCols ; for ( int i = 0 ; i < getScrollables ( ) . size ( ) ; i ++ ) { RadialButton temp = ( RadialButton ) getScrollables ( ) . get ( i ) ; boolean one = temp . getIndex ( ) > getIndex ( ) ; boolean two = temp . getIndex ( ) < getIndex ( ) + getDisplayCnt ( ) * radialCols ; if ( one && two ) { System . out . println ( "FOUR MICE OF MEN" ) ; if ( -- c == 0 ) { x = getXpos ( ) ; y += 40 ; c = radialCols ; } else { x += 60 ; } temp . setXpos ( x ) ; temp . setYpos ( y ) ; } else { temp . setXpos ( - 1000 ) ; temp . setYpos ( - 1000 ) ; } if ( temp . getWidth ( ) <= 0 ) System . out . println ( "Major Error :: Width Not Set :: OptionView" ) ; if ( temp . getHeight ( ) <= 0 ) System . out . println ( "Major Error :: Height Not Set :: OptionView" ) ; } System . out . println ( "Test Change :: OptionView" ) ; }
te	7	public boolean equipModelCached ( int gender ) { int equipModelIdPrimary = maleEquipModelIdPrimary ; int equipModelIdSecondary = maleEquipModelIdSecondary ; int equipModelIdEmblem = maleEquipModelIdEmblem ; if ( gender == 1 ) { equipModelIdPrimary = femaleEquipModelIdPrimary ; equipModelIdSecondary = femaleEquipModelIdSecondary ; equipModelIdEmblem = femaleEquipModelIdEmblem ; } if ( equipModelIdPrimary == - 1 ) return true ; boolean cached = true ; if ( ! Model . isCached ( equipModelIdPrimary ) ) cached = false ; if ( equipModelIdSecondary != - 1 && ! Model . isCached ( equipModelIdSecondary ) ) cached = false ; if ( equipModelIdEmblem != - 1 && ! Model . isCached ( equipModelIdEmblem ) ) cached = false ; return cached ; }
te	9	@ Override public byte [ ] pass ( DataInputStream in , DataOutputStream out , PassthroughConnection ptc , KillableThread thread , boolean serverToClient , byte [ ] buffer , DownlinkState linkState ) { length = lengthUnit . read ( in , ptc , thread , serverToClient , linkState ) ; if ( length == null ) { return null ; } length = lengthUnit . write ( out , ptc , thread , serverToClient ) ; if ( length == null ) { return null ; } length = ( short ) ( length * 4 ) ; if ( length > FFFF ) { ptc . printLogMessage ( "To many block updates in one packet - breaking connection" ) ; return null ; } if ( buffer == null || value == null ) { setupBuffer ( buffer ) ; } buffer = value ; int pos = 0 ; int bufLength = buffer . length ; incrementCounter ( serverToClient , length , ptc ) ; while ( pos < length ) { int read ; bufLength = Math . min ( bufLength , length - pos ) ; try { read = in . read ( value , 0 , bufLength ) ; } catch ( SocketTimeoutException ste ) { if ( ! thread . killed ( ) ) { timeout ++ ; if ( timeout > 225 ) { ptc . printLogMessage ( "Connection timed out" ) ; return null ; } continue ; } return null ; } catch ( IOException e ) { ptc . printLogMessage ( "Unable to read from socket" ) ; return null ; } try { out . write ( value , 0 , read ) ; } catch ( SocketTimeoutException ste ) { if ( ! thread . killed ( ) ) { timeout ++ ; if ( timeout > 225 ) { ptc . printLogMessage ( "Connection timed out" ) ; return null ; } continue ; } return null ; } catch ( IOException e ) { ptc . printLogMessage ( "Unable to read from socket" ) ; return null ; } pos += read ; } return buffer ; }
te	5	@ Override public boolean equals ( Object object ) { if ( ! ( object instanceof Professor ) ) { return false ; } Professor other = ( Professor ) object ; if ( ( this . id == null && other . id != null ) || ( this . id != null && ! this . id . equals ( other . id ) ) ) { return false ; } return true ; }
te	4	@ Override public String getAsString ( FacesContext facesContext , UIComponent component , Object object ) { if ( object == null || ( object instanceof String && ( ( String ) object ) . length ( ) == 0 ) ) { return null ; } if ( object instanceof NonFunctionalRequirement ) { NonFunctionalRequirement o = ( NonFunctionalRequirement ) object ; return getStringKey ( o . getIdNonFuncRequirement ( ) ) ; } else { Logger . getLogger ( this . getClass ( ) . getName ( ) ) . log ( Level . SEVERE , "object {0} is of type {1}; expected type: {2}" , new Object [ ] { object , object . getClass ( ) . getName ( ) , NonFunctionalRequirement . class . getName ( ) } ) ; return null ; } }
te	6	public void execute ( String [ ] names ) { if ( names . length == 0 ) { console . error ( "unable to mark absent (no names provided)." ) ; return ; } SKList list = manager . copyList ( ) ; int i = 0 ; for ( String name : names ) { if ( name . length ( ) <= 0 ) continue ; int rank = list . getIndex ( name ) ; if ( rank == - 1 ) console . error ( playerNotFound ( name ) ) ; else { Player p = list . get ( rank ) ; if ( p . isPresent ( ) ) { p . setPresent ( false ) ; i ++ ; } } } if ( i > 0 ) { Entry entry = console . event ( "Players marked absent (" + i + ")." ) ; manager . setList ( list , new EventUndoListener ( console , entry ) ) ; } }
te	7	public Size ( String s ) { int j = 0 ; boolean . = false ; for ( int len = s . length ( ) ; j < len ; ++ j ) { final char cc = s . charAt ( j ) ; if ( ( cc < 0 || cc > 9 ) && ( . || ! ( . = cc == . ) ) ) break ; } size = j > 0 ? double . parseDouble ( s . substring ( 0 , j ) ) : 0 ; measure = j >= 0 ? s . substring ( j ) : s ; }
te	6	@ SuppressWarnings ( "unchecked" ) public static Map < String , Object > toModel ( HttpServletRequest request ) { String uri = request . getRequestURI ( ) ; String ctx = request . getContextPath ( ) ; if ( ctx == null || "/" . equals ( ctx ) ) { ctx = "" ; } else if ( uri . startsWith ( ctx ) ) { uri = uri . substring ( ctx . length ( ) ) ; } Map < String , Object > models = new HashMap < String , Object > ( ) ; models . put ( "request" , request ) ; models . put ( "userPrincipal" , request . getUserPrincipal ( ) ) ; models . put ( "contextPath" , ctx ) ; models . put ( "requestURI" , uri ) ; for ( Map . Entry < String , String [ ] > entry : ( ( Map < String , String [ ] > ) request . getParameterMap ( ) ) . entrySet ( ) ) { String [ ] values = entry . getValue ( ) ; if ( values . length > 0 ) { models . put ( entry . getKey ( ) , values . length > 1 ? values : values [ 0 ] ) ; } } return models ; }
te	2	@ Override public long getLong ( long i ) { if ( ptr != 0 ) { return ( long ) ( Utilities . UNSAFE . getShort ( ptr + sizeof * i ) ) ; } else { if ( isConstant ( ) ) { return ( long ) data [ 0 ] ; } else { return ( long ) data [ ( int ) i ] ; } } }
te	4	public List < Survivor > getSurvivorsNotPicked ( ) { List < Survivor > res = new LinkedList < Survivor > ( ) ; for ( Survivor s : game . getSurvivors ( ) ) { boolean alreadyChosen = false ; for ( RaidSettings raid : this . raids ) { if ( raid . getTeam ( ) . contains ( s ) ) { alreadyChosen = true ; } } if ( ! alreadyChosen ) { res . add ( s ) ; } } return res ; }
te	0	@ Override public void tick ( ) { }
te	6	public static void main ( String args [ ] ) throws IOException { String studentID = Compiler . studentID ; String uciNetID = Compiler . uciNetID ; int publicTestcaseNum = 15 ; int privateTestcaseNum = 5 ; int publicPass = 0 ; for ( int i = 1 ; i <= publicTestcaseNum ; ++ i ) { try { if ( testPublic ( i ) == PASS ) { ++ publicPass ; } else { System . out . println ( "failed:" + i ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } int privatePass = 0 ; for ( int i = 1 ; i <= privateTestcaseNum ; ++ i ) { try { if ( testPrivate ( i ) == PASS ) { ++ privatePass ; } else { System . out . println ( "failed:" + i ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } System . out . print ( studentID ) ; System . out . print ( "\t" ) ; System . out . print ( uciNetID ) ; System . out . print ( "\t" ) ; System . out . print ( " Passed Public Cases: " ) ; System . out . print ( publicPass ) ; System . out . print ( "/" ) ; System . out . print ( publicTestcaseNum ) ; System . out . print ( " Passed Private Cases: " ) ; System . out . print ( privatePass ) ; System . out . print ( "/" ) ; System . out . println ( privateTestcaseNum ) ; }
te	1	public DescribeInstanceTypesResult withInstanceTypes ( Collection < InstanceType > instanceTypes ) { if ( instanceTypes == null ) { this . instanceTypes = null ; } else { ListWithAutoConstructFlag < InstanceType > instanceTypesCopy = new ListWithAutoConstructFlag < > ( instanceTypes . size ( ) ) ; instanceTypesCopy . addAll ( instanceTypes ) ; this . instanceTypes = instanceTypesCopy ; } return this ; }
te	4	@ Override public boolean equals ( Object o ) { if ( this == o ) { return true ; } if ( o == null || getClass ( ) != o . getClass ( ) ) { return false ; } OngoingRecordingData that = ( OngoingRecordingData ) o ; return ! ( generator != null ? ! generator . equals ( that . generator ) : that . generator != null ) ; }
te	3	public static boolean testDistinct ( int [ ] num ) { for ( int i = 0 ; i < num . length ; i ++ ) { for ( int j = i + 1 ; j < num . length ; j ++ ) { if ( num [ i ] == num [ j ] ) { return true ; } } } return false ; }
te	0	public String storeToCsvLine ( ) { final char SEPARATOR = 	 ; return name + SEPARATOR + description + SEPARATOR + new SimpleDateFormat ( DATE_PATTERN ) . format ( date ) + SEPARATOR + important ; }
te	9	public static String toString ( JSONObject jo ) throws JSONException { StringBuffer sb = new StringBuffer ( ) ; int i ; JSONArray ja ; String key ; Iterator keys ; int length ; Object object ; String tagName ; String value ; tagName = jo . optString ( "tagName" ) ; if ( tagName == null ) { return XML . escape ( jo . toString ( ) ) ; } XML . noSpace ( tagName ) ; tagName = XML . escape ( tagName ) ; sb . append ( < ) ; sb . append ( tagName ) ; keys = jo . keys ( ) ; while ( keys . hasNext ( ) ) { key = keys . next ( ) . toString ( ) ; if ( ! "tagName" . equals ( key ) && ! "childNodes" . equals ( key ) ) { XML . noSpace ( key ) ; value = jo . optString ( key ) ; if ( value != null ) { sb . append (   ) ; sb . append ( XML . escape ( key ) ) ; sb . append ( = ) ; sb . append ( " ) ; sb . append ( XML . escape ( value ) ) ; sb . append ( " ) ; } } } ja = jo . optJSONArray ( "childNodes" ) ; if ( ja == null ) { sb . append ( / ) ; sb . append ( > ) ; } else { sb . append ( > ) ; length = ja . length ( ) ; for ( i = 0 ; i < length ; i += 1 ) { object = ja . get ( i ) ; if ( object != null ) { if ( object instanceof String ) { sb . append ( XML . escape ( object . toString ( ) ) ) ; } else if ( object instanceof JSONObject ) { sb . append ( toString ( ( JSONObject ) object ) ) ; } else if ( object instanceof JSONArray ) { sb . append ( toString ( ( JSONArray ) object ) ) ; } else { sb . append ( object . toString ( ) ) ; } } } sb . append ( < ) ; sb . append ( / ) ; sb . append ( tagName ) ; sb . append ( > ) ; } return sb . toString ( ) ; }
te	8	public static Map < String , Object > getParametersStartingWith ( ServletRequest request , String prefix ) { assert . notNull ( request , "Request must not be null" ) ; Enumeration < String > paramNames = request . getParameterNames ( ) ; Map < String , Object > params = new TreeMap < String , Object > ( ) ; if ( prefix == null ) { prefix = "" ; } while ( paramNames != null && paramNames . hasMoreElements ( ) ) { String paramName = paramNames . nextElement ( ) ; if ( "" . equals ( prefix ) || paramName . startsWith ( prefix ) ) { String unprefixed = paramName . substring ( prefix . length ( ) ) ; String [ ] values = request . getParameterValues ( paramName ) ; if ( values == null || values . length == 0 ) { } else if ( values . length > 1 ) { params . put ( unprefixed , values ) ; } else { params . put ( unprefixed , values [ 0 ] ) ; } } } return params ; }
te	0	public static void sortTopicsList ( ArrayList < TopicOutput > list ) { Collections . sort ( list , new MyComparator ( ) ) ; }
te	8	private void startNoteGame ( ) { initNoteGame ( ) ; updateTonality ( ) ; if ( noteLevel . isNormalgame ( ) || noteLevel . isLearninggame ( ) ) { if ( noteLevel . isNotesgame ( ) || noteLevel . isAccidentalsgame ( ) || noteLevel . isCustomNotesgame ( ) ) { newnote ( ) ; } else if ( noteLevel . isChordsgame ( ) ) { newChord ( ) ; } else if ( noteLevel . isIntervalsgame ( ) ) { newinterval ( ) ; } } else if ( noteLevel . isInlinegame ( ) ) { createline ( ) ; } parti = true ; startButton . setText ( bundle . getString ( "_stop" ) ) ; }
te	6	@ Override public ResultadoAvaliacoes resultadoAvaliacoes ( String refeicao , String data ) { Iterator < Avaliacao > avs = avaliacoes . values ( ) . iterator ( ) ; ResultadoAvaliacoes result = new ResultadoAvaliacoes ( ) ; result . setData ( data ) ; result . setDesgostaram ( 0 ) ; result . setGostaram ( 0 ) ; result . setIndiferente ( 0 ) ; result . setTotaVotos ( 0 ) ; result . setRefeicao ( refeicao ) ; result . setCardapioCumprido ( 0 ) ; result . setCardapioDescumprido ( 0 ) ; Avaliacao avaliacao = null ; while ( avs . hasNext ( ) ) { avaliacao = avs . next ( ) ; if ( refeicao . equals ( avaliacao . getRefeicao ( ) ) && avaliacao . getDataFormatoAmericano ( ) . equals ( data ) ) { if ( avaliacao . getCardapioCumprido ( ) ) { result . setCardapioCumprido ( result . getCardapioCumprido ( ) + 1 ) ; } else { result . setCardapioDescumprido ( result . getCardapioDescumprido ( ) + 1 ) ; } if ( avaliacao . getIdAvaliacao ( ) == 1 ) { result . setGostaram ( result . getGostaram ( ) + 1 ) ; } else if ( avaliacao . getIdAvaliacao ( ) == 2 ) { result . setDesgostaram ( result . getGostaram ( ) + 1 ) ; } else { result . setIndiferente ( result . getIndiferente ( ) + 1 ) ; } } } result . setTotaVotos ( result . getGostaram ( ) + result . getDesgostaram ( ) + result . getIndiferente ( ) ) ; return result ; }
te	2	public final void link_control ( String c , FSPLink l ) throws Exception { if ( control_names . containsKey ( c ) ) { if ( control_names . get ( c ) == null ) { control_names . put ( c , l ) ; l . add_member ( this ) ; } else { throw new Exception ( "The control name \"" + c + "\" is already linked." ) ; } } else { throw new Exception ( "The control name is non existing." ) ; } }
te	1	public static void printArray ( int [ ] array ) { for ( int i = 0 ; i < array . length ; i ++ ) { System . out . print ( array [ i ] + "  " ) ; } System . out . println ( ) ; System . out . println ( ) ; }
te	3	private JSONWriter end ( char mode , char c ) throws JSONException { if ( this . mode != mode ) { throw new JSONException ( mode == a ? "Misplaced endArray." : "Misplaced endObject." ) ; } this . pop ( mode ) ; try { this . writer . write ( c ) ; } catch ( IOException e ) { throw new JSONException ( e ) ; } this . , = true ; return this ; }
te	2	@ Override public void inputStarted ( ) { gui . updateTime ( ) ; if ( ! Display . isActive ( ) ) { gui . clearKeyboardState ( ) ; gui . clearMouseState ( ) ; if ( gui . getRootPane ( ) instanceof RootPane ) { ( ( RootPane ) gui . getRootPane ( ) ) . keyboardFocusLost ( ) ; } } }
te	0	public Type or ( Type that ) { return new ErrorType ( "Cannot compute " + this + " or " + that + "." ) ; }
te	2	protected boolean areNonBLOBsAccepted ( String deviceName ) { DevicePropertyBLOBEnableTuple aux = getBLOBEnableRule ( deviceName ) ; if ( aux == null ) { return true ; } if ( aux . getBLOBEnable ( ) == BLOBEnables . ONLY ) { return false ; } return true ; }
te	2	public InstanceVariable searchVariable ( String name ) { InstanceVariable v = null ; for ( int i = 0 ; i < instanceVariableList . size ( ) ; i ++ ) { if ( instanceVariableList . get ( i ) . getName ( ) . equals ( name ) ) return instanceVariableList . get ( i ) ; } return v ; }
te	3	private void displaySystemProperty ( Context ctx , String propName ) { IOConsole c = ctx . getIoConsole ( ) ; if ( propName == null || propName . isEmpty ( ) ) { c . writeOutput ( String . format ( "%n Property name is missing. Provide a property name.%n%n" ) ) ; return ; } String propVal = System . getProperty ( propName ) ; if ( propVal != null ) { c . writeOutput ( String . format ( "%n%1$30s %2$5s %3$s" , propName , " " , propVal ) ) ; } }
te	9	public static boolean isStandardClass ( class clazz ) { if ( clazz . isAssignableFrom ( Date . class ) ) return true ; else if ( clazz . isAssignableFrom ( Number . class ) ) return true ; else if ( clazz . isAssignableFrom ( String . class ) ) return true ; else if ( clazz . isAssignableFrom ( ObjectId . class ) ) return true ; else if ( clazz . isAssignableFrom ( BSONObject . class ) ) return true ; else if ( clazz . isAssignableFrom ( boolean . class ) ) return true ; else if ( clazz . isAssignableFrom ( double . class ) ) return true ; else if ( clazz . isAssignableFrom ( Integer . class ) ) return true ; else if ( clazz . isAssignableFrom ( long . class ) ) return true ; else if ( clazz . isAssignableFrom ( Pattern . class ) ) return true ; else if ( clazz . isArray ( ) && clazz . getComponentType ( ) . isAssignableFrom ( matchType ) ) return true ; else if ( clazz . isAssignableFrom ( UUID . class ) ) return true ; return false ; }
te	5	private static void fillAll ( Color [ ] [ ] image , int n , int m , Color color , Color newColor ) { if ( n < 0 || m < 0 || n >= image . length || m >= image [ n ] . length ) { return ; } if ( image [ n ] [ m ] == color ) { image [ n ] [ m ] = newColor ; fillAll ( image , n - 1 , m , color , newColor ) ; fillAll ( image , n , m + 1 , color , newColor ) ; fillAll ( image , n + 1 , m , color , newColor ) ; fillAll ( image , n , m - 1 , color , newColor ) ; } }
te	1	public InputStream getItemStream ( Item i ) throws Exception { if ( i . isDir ( ) ) throw new Exception ( "Item must be a file" ) ; String token = new User ( ) . acctoken ( ) ; URL url = new URL ( i . getStreamUrl ( ) + "/atk/" + token ) ; URLConnection conn = url . openConnection ( ) ; return conn . getInputStream ( ) ; }
te	4	public boolean setRobots ( final int [ ] newRobots ) { if ( this . robots . length != newRobots . length ) { return false ; } final int [ ] backup = Arrays . copyOf ( this . robots , this . robots . length ) ; Arrays . fill ( this . robots , - 1 ) ; for ( int i = 0 ; i < newRobots . length ; ++ i ) { if ( ! this . setRobot ( i , newRobots [ i ] , false ) ) { for ( int j = 0 ; j < backup . length ; ++ j ) { this . robots [ j ] = backup [ j ] ; } return false ; } } return true ; }
te	4	public void updateScore ( String problems , long submissionId , long questId ) { PreparedStatement statement = null ; Connection connection = null ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Updating the score of an user in a questionnaire: " + questId ) ; } try { String sql = UPDATE_QUEST_SCORE ; String replacementKey = "[#problemInClause]" ; List < Integer > problemList = ResourcesUtil . extractIntListFromString ( problems ) ; int size = problemList . size ( ) ; sql = replaceInClause ( sql , replacementKey , size ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( sql ) ; } connection = Connector . getConnection ( ) ; statement = connection . prepareStatement ( sql ) ; int i ; for ( i = 0 ; i < size ; i ++ ) { statement . setLong ( i + 1 , problemList . get ( i ) ) ; } statement . setLong ( ++ i , submissionId ) ; statement . setLong ( ++ i , questId ) ; DeadLockHandler . executeUpdate ( statement ) ; } catch ( SQLException e ) { logger . error ( e . getMessage ( ) , e ) ; } finally { ResourcesUtil . release ( null , statement , connection ) ; } }
te	3	public Object clone ( ) throws CloneNotSupportedException { Polygon result = ( Polygon ) super . clone ( ) ; if ( result . outerBoundaryIs != null ) { result . outerBoundaryIs = ( boundary ) this . outerBoundaryIs . clone ( ) ; result . outerBoundaryIs . setParent ( result ) ; } if ( result . innerBoundaryIs != null ) { result . innerBoundaryIs = new ArrayList ( ) ; for ( Iterator iter = this . innerBoundaryIs . iterator ( ) ; iter . hasNext ( ) ; ) { boundary element = ( boundary ) iter . next ( ) ; boundary elementClone = ( boundary ) element . clone ( ) ; elementClone . setParent ( result ) ; result . innerBoundaryIs . add ( elementClone ) ; } } return result ; }
te	7	public boolean createNewFile ( final boolean forceDirectories ) throws IOException { if ( forceDirectories ) { if ( ! this . getParentFile ( ) . exists ( ) && ! this . getParentFile ( ) . mkdirs ( ) ) { throw new IOException ( "Failed to create directories to file " + this . getParentFile ( ) ) ; } if ( ! this . getParentFile ( ) . exists ( ) ) { throw new IOException ( "Failed to create directories to file " + this . getParentFile ( ) ) ; } } if ( this . overwrite && this . exists ( ) ) { FileUtils . delete ( this ) ; } if ( ! super . createNewFile ( ) ) { throw new IOException ( "Failed to create file " + this . getAbsolutePath ( ) ) ; } return true ; }
te	7	static void dradb2 ( int ido , int l1 , float [ ] cc , float [ ] ch , float [ ] wa1 , int index ) { int i , k , t0 , t1 , t2 , t3 , t4 , t5 , t6 ; float ti2 , tr2 ; t0 = l1 * ido ; t1 = 0 ; t2 = 0 ; t3 = ( ido << 1 ) - 1 ; for ( k = 0 ; k < l1 ; k ++ ) { ch [ t1 ] = cc [ t2 ] + cc [ t3 + t2 ] ; ch [ t1 + t0 ] = cc [ t2 ] - cc [ t3 + t2 ] ; t2 = ( t1 += ido ) << 1 ; } if ( ido < 2 ) return ; if ( ido != 2 ) { t1 = 0 ; t2 = 0 ; for ( k = 0 ; k < l1 ; k ++ ) { t3 = t1 ; t5 = ( t4 = t2 ) + ( ido << 1 ) ; t6 = t0 + t1 ; for ( i = 2 ; i < ido ; i += 2 ) { t3 += 2 ; t4 += 2 ; t5 -= 2 ; t6 += 2 ; ch [ t3 - 1 ] = cc [ t4 - 1 ] + cc [ t5 - 1 ] ; tr2 = cc [ t4 - 1 ] - cc [ t5 - 1 ] ; ch [ t3 ] = cc [ t4 ] - cc [ t5 ] ; ti2 = cc [ t4 ] + cc [ t5 ] ; ch [ t6 - 1 ] = wa1 [ index + i - 2 ] * tr2 - wa1 [ index + i - 1 ] * ti2 ; ch [ t6 ] = wa1 [ index + i - 2 ] * ti2 + wa1 [ index + i - 1 ] * tr2 ; } t2 = ( t1 += ido ) << 1 ; } if ( ( ido % 2 ) == 1 ) return ; } t1 = ido - 1 ; t2 = ido - 1 ; for ( k = 0 ; k < l1 ; k ++ ) { ch [ t1 ] = cc [ t2 ] + cc [ t2 ] ; ch [ t1 + t0 ] = - ( cc [ t2 + 1 ] + cc [ t2 + 1 ] ) ; t1 += ido ; t2 += ido << 1 ; } }
te	7	public void layoutContainer ( Container parent ) { synchronized ( parent . getTreeLock ( ) ) { Component [ ] comps = parent . getComponents ( ) ; int num = comps . length ; if ( num == 0 ) return ; int real_rows = rows ; int real_cols = cols ; if ( real_rows == 0 ) real_rows = ( num + real_cols - 1 ) / real_cols ; else real_cols = ( num + real_rows - 1 ) / real_rows ; if ( num < real_cols ) real_cols = num ; Dimension d = parent . getSize ( ) ; Insets ins = parent . getInsets ( ) ; final int w = d . width - ins . left - ins . right ; int tw = ( w - ( real_cols - 1 ) * hgap ) / real_cols ; final int h = d . height - ins . top - ins . bottom ; int th = ( h - ( real_rows - 1 ) * vgap ) / real_rows ; th = tw = Math . min ( th , tw ) ; final int left = ( w - real_cols * ( tw + hgap ) - hgap ) / 2 ; final int top = ( h - real_rows * ( th + vgap ) - vgap ) / 2 ; if ( tw < 0 ) tw = 1 ; if ( th < 0 ) th = 1 ; int x = ins . left + left ; int y = ins . top + top ; int i = 0 ; int recount = 0 ; while ( i < num ) { comps [ i ] . setBounds ( x , y , tw , th ) ; ++ i ; ++ recount ; if ( recount == real_cols ) { recount = 0 ; y += vgap + th ; x = ins . left + left ; } else x += hgap + tw ; } } }
te	7	private void checkNames ( final String [ ] dirs , final String secondName ) { for ( int i = 0 ; i < dirs . length ; ++ i ) { if ( dirs [ i ] . equals ( "signature.tsv" ) ) { continue ; } String [ ] name = dirs [ i ] . split ( "\\." ) ; if ( name . length != 2 || ! name [ 1 ] . equals ( secondName ) ) { throw new MultiDataBaseException ( dataBaseDirectory + " wrong file in path " + dirs [ i ] ) ; } int firstName ; try { firstName = Integer . parseInt ( name [ 0 ] ) ; } catch ( NumberFormatException e ) { throw new MultiDataBaseException ( dataBaseDirectory + " wrong file first name " + dirs [ i ] ) ; } if ( ( firstName < 0 ) || firstName > 15 ) { throw new MultiDataBaseException ( dataBaseDirectory + " wrong file first name " + dirs [ i ] ) ; } } }
te	5	public int getShortestPathValue ( int source , int dest ) { for ( int i = 0 ; i < graph . getVerticesCount ( ) ; i ++ ) { distances [ i ] = Integer . MAX_VALUE ; parents [ i ] = - 1 ; } final PriorityQueue < Integer > vertices = new PriorityQueue < > ( ( v1 , v2 ) -> { Integer v1Score = distances [ v1 ] ; Integer v2Score = distances [ v2 ] ; return v1Score . compareTo ( v2Score ) ; } ) ; for ( int i = 0 ; i < graph . getVerticesCount ( ) ; i ++ ) { vertices . add ( i ) ; } distances [ source ] = 0 ; vertices . remove ( source ) ; vertices . add ( source ) ; final Set < Integer > explored = new HashSet < > ( ) ; while ( explored . size ( ) < graph . getVertices ( ) . size ( ) ) { int vertex = vertices . poll ( ) ; explored . add ( vertex ) ; for ( Edge outgoingEdge : graph . getEdges ( vertex ) ) { int anotherVertex = outgoingEdge . getAnotherVertex ( vertex ) ; if ( distances [ vertex ] + outgoingEdge . getWeight ( ) < distances [ anotherVertex ] ) { distances [ anotherVertex ] = distances [ vertex ] + outgoingEdge . getWeight ( ) ; vertices . remove ( anotherVertex ) ; vertices . add ( anotherVertex ) ; } } } return distances [ dest ] ; }
te	8	public void onEnable ( ) { this . saveDefaultConfig ( ) ; log = this . getLogger ( ) ; Lang = this . getConfig ( ) . getString ( "language" ) ; if ( Lang . equals ( "en" ) ) { chatname = "Game Server" ; } else if ( Lang . equals ( "ja" ) ) { chatname = "\u30B2\u30FC\u30E0\u30B5\u30FC\u30D0\u30FC" ; } else { log . info ( "[WARNING]" + Lang + " is not supported." ) ; log . info ( "[WARNING]English(en) or Japanese(ja) Only." ) ; log . info ( "[WARNING]\u8A00\u8A9E\u8A2D\u5B9A" + Lang + "\u306F\u4F7F\u7528\u3067\u304D\u307E\u305B\u3093" ) ; log . info ( "[WARNING]\u82F1\u8A9E(en)\u304B\u65E5\u672C\u8A9E(ja)\u306E\u307F\u5BFE\u5FDC\u3057\u3066\u3044\u307E\u3059\u3002" ) ; chatname = "Game Server" ; } final String url = this . getConfig ( ) . getString ( "socketchaturl" ) ; final String prefix = this . getConfig ( ) . getString ( "prefix" ) ; final String pass = this . getConfig ( ) . getString ( "socket_pass" ) ; getServer ( ) . getPluginManager ( ) . registerEvents ( this , this ) ; try { socket = new SocketIO ( url ) ; socket . connect ( new IOCallback ( ) { @ Override public void onMessage ( JSONObject json , IOAcknowledge ack ) { try { } catch ( JSONException e ) { e . printStackTrace ( ) ; } } @ Override public void onMessage ( String data , IOAcknowledge ack ) { } @ Override public void onError ( SocketIOException socketIOException ) { log . info ( "[WARNING]Socket Error!" ) ; socketIOException . printStackTrace ( ) ; } @ Override public void onDisconnect ( ) { log . info ( "[WARNING]SocketChat Disconnect!" ) ; } @ Override public void onConnect ( ) { log . info ( "SocketChat Connect." ) ; } @ Override public void on ( String event , IOAcknowledge ack , Object ... args ) { if ( event . equals ( "log" ) ) { final JSONObject jsondata = ( JSONObject ) args [ 0 ] ; if ( ! jsondata . isNull ( "comment" ) ) { String name = jsondata . getString ( "name" ) ; if ( jsondata . isNull ( "channel" ) && ! name . equals ( chatname ) ) { String comment = jsondata . getString ( "comment" ) ; String ip = jsondata . getString ( "ip" ) ; Bukkit . broadcastMessage ( ChatColor . GREEN + "[" + prefix + "]" + ChatColor . WHITE + name + " : " + comment + " (" + ip + ")" ) ; } } } } } ) ; socket . emit ( "register" , new JSONObject ( ) . put ( "mode" , "client" ) . put ( "lastid" , 1 ) ) ; socket . emit ( "inout" , new JSONObject ( ) . put ( "name" , chatname ) . put ( "pass" , pass ) ) ; log . info ( "BukkitSocketChat has been enabled!" ) ; } catch ( MalformedURLException e1 ) { e1 . printStackTrace ( ) ; log . info ( "[WARNING]BukkitSocketChat is Error!" ) ; } }
te	9	public static void main ( String [ ] args ) { MCSolver solver = new MCSolver ( ) ; LinkedList < MCSolver . State > output = solver . bfs ( ) ; if ( output != null ) { MCSolver . State previous = output . getFirst ( ) ; System . out . println ( "Found a solution to your Cannibal Vs Missionaries problems!" ) ; System . out . println ( "Total Moves: " + ( output . size ( ) - 1 ) ) ; System . out . println ( "Here they are:" ) ; for ( int i = 0 ; i < output . size ( ) ; i ++ ) { MCSolver . State s = output . get ( i ) ; int p = previous . get ( ) ; int c = s . get ( ) ; int d = Math . abs ( ( p - c ) / 10 ) ; String bdir_singular = " goes across." ; String bdir_plural = " go across." ; if ( s . boat == 1 ) { bdir_singular = " comes back." ; bdir_plural = " come back." ; } switch ( d ) { case 00 : ; break ; case 01 : System . out . println ( "One cannibal" + bdir_singular ) ; break ; case 10 : System . out . println ( "One missionary" + bdir_singular ) ; break ; case 11 : System . out . println ( "One missionary and one cannibal" + bdir_plural ) ; break ; case 20 : System . out . println ( "Two missionaries" + bdir_plural ) ; break ; case 02 : System . out . println ( "Two cannibals" + bdir_plural ) ; break ; default : System . out . println ( "didn't know what to say: " + Integer . toString ( d ) ) ; break ; } previous = s ; } System . out . println ( "and we are done!" ) ; System . out . println ( "\nin short notation the moves (in mcb) are: " ) ; for ( int i = 0 ; i < output . size ( ) ; i ++ ) { MCSolver . State s = output . get ( i ) ; System . out . print ( s . toString ( ) + " " ) ; } } else { System . out . println ( "no solution found! :-(" ) ; } }
te	1	public static String readStream ( InputStream stream ) throws IOException { BufferedReader reader = new BufferedReader ( new InputStreamReader ( stream ) ) ; StringBuilder out = new StringBuilder ( ) ; String newLine = System . getProperty ( "line.separator" ) ; String line ; while ( ( line = reader . readLine ( ) ) != null ) { out . append ( line ) ; out . append ( newLine ) ; } return out . toString ( ) ; }
te	9	@ Override public void paintComponent ( Graphics g ) { super . paintComponent ( g ) ; Graphics2D g2d = ( Graphics2D ) g . create ( ) ; Rectangle2D r = new Rectangle2D . double ( 155 , 55 , 490 , 490 ) ; g2d . setPaint ( Color . BLACK ) ; g2d . fill ( r ) ; r = new Rectangle2D . double ( 160 , 60 , 480 , 480 ) ; GradientPaint gp = new GradientPaint ( 0 , 0 , Color . DARK_GRAY , 350 , 480 , Color . GRAY ) ; g2d . setPaint ( gp ) ; g2d . fill ( r ) ; g2d . setPaint ( Color . WHITE ) ; for ( int y = 0 ; y < 8 ; y ++ ) { for ( int x = 0 ; x < 8 ; x ++ ) { if ( ( x + y ) % 2 == 0 ) { r = new Rectangle2D . double ( x * 60 + 160 , y * 60 + 60 , 60 , 60 ) ; g2d . fill ( r ) ; } } } g2d . setFont ( new Font ( g2d . getFont ( ) . toString ( ) , Font . PLAIN , 28 ) ) ; if ( moves . get ( turnNum ) . isWhiteTurn ( ) ) { g2d . drawString ( "Turn " + turnNum , myCheckmate . getWidth ( ) * .035f , myCheckmate . getHeight ( ) * .06f ) ; } for ( PossibleTile pt : moves . get ( turnNum ) . getPrevTiles ( ) ) { drawPrevTile ( g2d , pt . getX ( ) * 60 + 160 , pt . getY ( ) * 60 + 60 ) ; } List < Piece > pieces = moves . get ( turnNum ) . getPieces ( ) ; int gridX , gridY ; for ( Piece p : pieces ) { if ( p instanceof Pawn ) { gridX = 0 ; } else if ( p instanceof Rook ) { gridX = 60 ; } else if ( p instanceof Knight ) { gridX = 120 ; } else if ( p instanceof Bishop ) { gridX = 180 ; } else if ( p instanceof Queen ) { gridX = 240 ; } else { gridX = 300 ; } if ( p . isWhite ( ) ) { gridY = 60 ; } else { gridY = 0 ; } drawPiece ( g2d , p . getX ( ) * 60 + 160 , p . getY ( ) * 60 + 60 , gridX , gridY ) ; } this . paintChildren ( g ) ; g2d . dispose ( ) ; }
te	2	@ Test public void testList ( ) { Connector c = new Connector ( ) ; try { c . connectToServer ( correctHostname , 21 , correctUsername , correctPassword ) ; c . list ( ) ; } catch ( IOException | ConnectionException e ) { e . printStackTrace ( ) ; fail ( ) ; } finally { try { c . disconnect ( ) ; } catch ( IOException | ConnectionException e ) { e . printStackTrace ( ) ; fail ( ) ; } } }
te	8	public static List < TrainData > readData ( ) { LinkedList < TrainData > result = new LinkedList < TrainData > ( ) ; File file = new File ( "resources/" ) ; if ( file . isDirectory ( ) ) { File [ ] listFiles = file . listFiles ( new FilenameFilter ( ) { @ Override public boolean accept ( File dir , String name ) { if ( name . endsWith ( ".train" ) ) { return true ; } return false ; } } ) ; for ( File file2 : listFiles ) { try { FileReader fileReader = new FileReader ( file2 ) ; BufferedReader br = new BufferedReader ( fileReader ) ; String readLine ; List < LabeledFeatureVector > datalist = new LinkedList < LabeledFeatureVector > ( ) ; while ( ( readLine = br . readLine ( ) ) != null ) { String [ ] split = readLine . split ( " " ) ; if ( split . length >= 2 ) { System . out . println ( split . length ) ; String label = split [ 0 ] ; double [ ] features = new double [ split . length - 1 ] ; for ( int i = 1 ; i < split . length ; i ++ ) { features [ i - 1 ] = double . parseDouble ( split [ i ] . split ( ":" ) [ 1 ] ) ; } LabeledFeatureVector lfv = new LabeledFeatureVector ( double . valueOf ( label ) , features ) ; datalist . add ( lfv ) ; } } TrainData trainData = new TrainData ( file2 . getName ( ) , datalist ) ; result . add ( trainData ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } } return result ; }
te	4	public static void main ( String args [ ] ) { EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { try { UIManager . setLookAndFeel ( UIManager . getSystemLookAndFeelClassName ( ) ) ; } catch ( ClassNotFoundException e ) { } catch ( InstantiationException e ) { } catch ( IllegalAccessException e ) { } catch ( UnsupportedLookAndFeelException e ) { } new BenchControls ( ) . setVisible ( true ) ; } } ) ; }
te	3	public static Schoolclass getSchoolclassByName ( final String name ) throws DatasetException { if ( name == null || name . trim ( ) . isEmpty ( ) ) { return null ; } try { return entityManager . find ( Schoolclass . class , name ) ; } catch ( Exception e ) { LOGGER . error ( "Exception while getting schoolclass by name " + name , e ) ; throw new DatasetException ( "Error while searching a schoolclass for name " + name + ": " + e . getMessage ( ) ) ; } }
te	8	public final File copy ( final Directory destDirectory , final String newFileName ) throws FileNotOnDiskException , DiskReadException { checkExists ( ) ; String destFileName = "" ; if ( destDirectory != null ) destFileName += destDirectory . toString ( ) ; else destFileName += this . getParent ( ) ; if ( newFileName != null ) destFileName += separatorChar + newFileName . toString ( ) ; else destFileName += separatorChar + this . getName ( ) ; try { final File destFile = new File ( destFileName ) ; if ( this . getCanonicalPath ( ) . equals ( destFile . getCanonicalPath ( ) ) ) return this ; if ( destFile . canWrite ( ) == false ) destFile . clean ( ) ; FileInputStream fis = null ; FileOutputStream fos = null ; FileChannel input = null ; FileChannel output = null ; try { fis = new FileInputStream ( this ) ; fos = new FileOutputStream ( destFile ) ; input = fis . getChannel ( ) ; output = fos . getChannel ( ) ; long size = input . size ( ) ; long pos = 0 ; long count = 0 ; while ( pos < size ) { count = size - pos > FILE_COPY_BUFFER_SIZE ? FILE_COPY_BUFFER_SIZE : size - pos ; pos += output . transferFrom ( input , pos , count ) ; } } finally { this . closeStream ( output ) ; this . closeStream ( fos ) ; this . closeStream ( input ) ; this . closeStream ( fis ) ; } if ( this . length ( ) != destFile . length ( ) ) throw new DiskReadException ( "Failed to copy full contents [" + this . toString ( ) + "]=>[" + destFile . toString ( ) + "'" ) ; destFile . setLastModified ( this . lastModified ( ) ) ; return destFile ; } catch ( final IOException e ) { throw new DiskReadException ( "File Copy [" + this . toString ( ) + "]=>[" + destFileName . toString ( ) + "]" , e ) ; } }
te	7	public boolean onCommand ( CommandSender sender , Command cmd , String label , String [ ] args ) { Player player = null ; if ( sender instanceof Player ) { player = ( Player ) sender ; } if ( player == null ) { sender . sendMessage ( ChatColor . RED + "This command can only be run by a player" ) ; return true ; } if ( args . length == 0 ) { String Player_Name = player . getName ( ) ; String worldName = player . getWorld ( ) . getName ( ) ; if ( plugin . getBedsConfig ( ) . getString ( Player_Name + "." + worldName ) != null ) { String bedLocation = plugin . getBedsConfig ( ) . getString ( Player_Name + "." + worldName ) ; String [ ] vals = bedLocation . split ( " " ) ; World world = Bukkit . getWorld ( vals [ 0 ] ) ; double x = double . parseDouble ( vals [ 1 ] ) ; double y = double . parseDouble ( vals [ 2 ] ) ; double z = double . parseDouble ( vals [ 3 ] ) ; final Location loc = new Location ( world , x , y + 1 , z ) ; player . teleport ( loc ) ; player . sendMessage ( ChatColor . YELLOW + "You have been returned to your bed location for " + ChatColor . RESET + worldName ) ; return true ; } else { player . sendMessage ( ChatColor . YELLOW + "You do not have a bed location set for " + ChatColor . RESET + worldName ) ; return true ; } } else if ( args . length == 1 && player . hasPermission ( "simpleextras.bed.other" ) ) { String targetName = plugin . myGetPlayerName ( args [ 0 ] ) ; String worldName = player . getWorld ( ) . getName ( ) ; if ( plugin . getBedsConfig ( ) . getString ( targetName + "." + worldName ) != null ) { String bedLocation = plugin . getBedsConfig ( ) . getString ( targetName + "." + worldName ) ; String [ ] vals = bedLocation . split ( " " ) ; World world = Bukkit . getWorld ( vals [ 0 ] ) ; double x = double . parseDouble ( vals [ 1 ] ) ; double y = double . parseDouble ( vals [ 2 ] ) ; double z = double . parseDouble ( vals [ 3 ] ) ; final Location loc = new Location ( world , x , y + 1 , z ) ; player . teleport ( loc ) ; player . sendMessage ( ChatColor . YELLOW + "You have been returned to " + targetName + "'s bed location for " + ChatColor . RESET + worldName ) ; return true ; } else { player . sendMessage ( ChatColor . YELLOW + targetName + " does not have a bed location set for " + ChatColor . RESET + worldName ) ; return true ; } } return true ; }
