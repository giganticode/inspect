tr	5	protected void doRun ( ) { runButton . setEnabled ( false ) ; stopButton . setEnabled ( true ) ; logArea . setText ( "" ) ; logArea . setCaretPosition ( 0 ) ; int selectedIndex = demosBox . getSelectedIndex ( ) ; if ( selectedIndex >= 0 ) { setTitle ( ( String ) demosBox . getSelectedItem ( ) ) ; final String args = selectedIndex < demosBox . getItemCount ( ) - 1 ? reduceName ( DefaultActorTest . getTestNames ( ) [ selectedIndex ] ) : "*" ; Thread t = new Thread ( new Runnable ( ) { @ Override public void run ( ) { try { if ( "*" . equals ( args ) ) { for ( String name : DefaultActorTest . getTestNames ( ) ) { doStart ( ) ; setTitle ( name ) ; runTest ( reduceName ( name ) ) ; doStop ( ) ; try { Thread . sleep ( 10 * 1000 ) ; } catch ( InterruptedException e ) { break ; } } } else { doStart ( ) ; runTest ( args ) ; doStop ( ) ; } } finally { SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { stopButton . setEnabled ( false ) ; runButton . setEnabled ( true ) ; messageLine . setText ( "Done" ) ; } } ) ; } } } ) ; t . setDaemon ( true ) ; t . start ( ) ; } }
tr	4	public static void setPanelInsets ( UnitValue top , UnitValue left , UnitValue bottom , UnitValue right ) { if ( top != null ) PANEL_INS [ 0 ] = top ; if ( left != null ) PANEL_INS [ 1 ] = left ; if ( bottom != null ) PANEL_INS [ 2 ] = bottom ; if ( right != null ) PANEL_INS [ 3 ] = right ; MOD_COUNT ++ ; }
tr	7	public static int numPaths ( int x , int y ) { if ( x == 1 && y == 1 ) { return 0 ; } if ( x == 2 && y == 1 ) { return 1 ; } if ( x == 1 && y == 2 ) { return 1 ; } if ( ! isLegal ( x , y ) ) { return 0 ; } return numPaths ( x - 1 , y ) + numPaths ( x , y - 1 ) ; }
tr	3	protected void addDictionaryHelper ( BufferedReader in ) throws IOException { String line = "" ; while ( line != null ) { line = in . readLine ( ) ; if ( line != null && line . length ( ) > 0 ) { line = new String ( line . toCharArray ( ) ) ; putWordUnique ( line ) ; } } }
tr	1	final int nextInt ( ) { if ( 0 == count -- ) { isaac ( ) ; count = SIZE - 1 ; } return ( rsl [ count ] ) ; }
tr	4	public void makeMove ( Point movePoint , int moveType ) throws Exception { if ( currentGameState . equals ( GameState . xWins ) || currentGameState . equals ( GameState . oWins ) ) { throw new InvariantException ( "Error: Tried to move after the game is finished" ) ; } if ( gameBoard . canMakeMove ( movePoint ) ) { if ( ! ( gameBoard . getPiece ( movePoint ) == BoardTwoPlayers . PLAYER_EMPTY ) ) { throw new GameException ( "Attempt to play in a non-empty square" ) ; } else { gameBoard . makeMove ( movePoint , moveType ) ; postMoveCalculations ( ) ; } } else { throw new GameException ( "Point " + movePoint + "out of bounds" ) ; } }
tr	3	public int toRgb ( ) { int ar = ( int ) ( r * 255 ) , ag = ( int ) ( g * 255 ) , ab = ( int ) ( b * 255 ) ; if ( ar > 255 ) { ar = 255 ; } if ( ag > 255 ) { ag = 255 ; } if ( ab > 255 ) { ab = 255 ; } return ( ar << 16 ) | ( ag << 8 ) | ( ab ) ; }
tr	1	public int anotaClase ( String idProf , String idProfReal , int idHoras , ArrayList < Integer > grupAsigInClass ) { int nup = 0 ; Iterator it = grupAsigInClass . iterator ( ) ; while ( it . hasNext ( ) ) { int idgrupasig = ( ( Number ) it . next ( ) ) . intValue ( ) ; nup += new ClasesAnotadas ( idProf , idProfReal , idHoras , idgrupasig , client ) . save ( ) ; } return nup ; }
tr	1	public static String [ ] getMonths ( final boolean shortened ) { if ( shortened ) { return DATE_FORMAT_SYMBOLS . getShortMonths ( ) ; } else { return DATE_FORMAT_SYMBOLS . getMonths ( ) ; } }
tr	8	@ Override public void write ( int theByte ) throws java . io . IOException { if ( suspendEncoding ) { this . out . write ( theByte ) ; return ; } if ( encode ) { buffer [ position ++ ] = ( byte ) theByte ; if ( position >= bufferLength ) { this . out . write ( encode3to4 ( b4 , buffer , bufferLength , options ) ) ; lineLength += 4 ; if ( breakLines && lineLength >= MAX_LINE_LENGTH ) { this . out . write ( NEW_LINE ) ; lineLength = 0 ; } position = 0 ; } } else { if ( decodabet [ theByte & 7f ] > WHITE_SPACE_ENC ) { buffer [ position ++ ] = ( byte ) theByte ; if ( position >= bufferLength ) { int len = Base64 . decode4to3 ( buffer , 0 , b4 , 0 , options ) ; out . write ( b4 , 0 , len ) ; position = 0 ; } } else if ( decodabet [ theByte & 7f ] != WHITE_SPACE_ENC ) { throw new java . io . IOException ( "Invalid character in Base64 data." ) ; } } }
tr	6	public boolean checkMainDiagonal ( ) { for ( int col = 0 ; col < numColumns - 3 ; col ++ ) { for ( int row = 0 ; row < numRows - 3 ; row ++ ) { int curr = gameGrid [ col ] [ row ] . getState ( ) ; if ( curr > 0 && curr == gameGrid [ col + 1 ] [ row + 1 ] . getState ( ) && curr == gameGrid [ col + 2 ] [ row + 2 ] . getState ( ) && curr == gameGrid [ col + 3 ] [ row + 3 ] . getState ( ) ) { winX = col ; winY = row ; game . setGameIsOver ( true ) ; return true ; } } } return false ; }
tr	7	public void removeKey ( String var ) { boolean changed = false ; if ( this . props . containsKey ( var ) ) { this . props . remove ( var ) ; changed = true ; } Iterator < String > it = this . lines . listIterator ( ) ; while ( it . hasNext ( ) ) { String line = it . next ( ) ; if ( line . trim ( ) . length ( ) == 0 ) { continue ; } if ( line . charAt ( 0 ) == # ) { continue ; } if ( line . contains ( "=" ) ) { int delimPosition = line . indexOf ( = ) ; String key = line . substring ( 0 , delimPosition ) . trim ( ) ; if ( key . equals ( var ) ) { it . remove ( ) ; changed = true ; } } else { continue ; } } if ( changed ) { save ( ) ; } }
tr	2	public static void main ( String [ ] args ) { BufferedReader reader = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String name = "" ; try { System . out . print ( "Digite o nome: " ) ; name = reader . readLine ( ) ; } catch ( Exception e ) { System . out . println ( "entrada inv\u00E1lida" ) ; System . exit ( 0 ) ; } int counter = 0 ; do { System . out . println ( name ) ; counter ++ ; } while ( counter < 100 ) ; }
tr	9	private void generate ( ) { for ( int c = 0 ; c < levels . size ( ) ; c ++ ) { Level clevel = levels . get ( c ) ; for ( int x = 0 ; x < sizex ; x ++ ) { for ( int y = 0 ; y < sizey ; y ++ ) { if ( x == 0 || x == sizex - 1 ) { clevel . tileHashMap . put ( genKey ( x , y ) , Tile . WALL_STONE ) ; } else if ( y == 0 || y == sizey - 1 ) { clevel . tileHashMap . put ( genKey ( x , y ) , Tile . WALL_STONE ) ; } else { clevel . tileHashMap . put ( genKey ( x , y ) , Tile . FLOOR_STONE ) ; } } } if ( clevel . level != 0 ) { ArrayList < Point > upstairs = levels . get ( clevel . level - 1 ) . downStairLocs ( ) ; for ( int z = 0 ; z < upstairs . size ( ) ; z ++ ) { clevel . createEntity ( new StoneStair ( upstairs . get ( z ) , true ) ) ; } } if ( clevel . level != levels . size ( ) - 1 ) { int downstairx , downstairy ; int runnum = 0 ; while ( true ) { Log . print ( runnum + "" ) ; downstairx = Rand . randInt ( 2 , sizex - 1 ) ; downstairy = Rand . randInt ( 2 , sizey - 1 ) ; if ( clevel . entityFree ( downstairx , downstairy ) ) { break ; } runnum ++ ; } clevel . createEntity ( new StoneStair ( new Point ( downstairx , downstairy ) , false ) ) ; } clevel . actorHashMap . put ( genKey ( 8 , 8 ) , new Actor ( new Point ( 8 , 8 ) , ActorType . goblin ) ) ; } }
tr	9	public void Run ( String product ) { int i = bidTs . size ( ) - 1 ; if ( i < 400 ) { return ; } MarketData currBar = this . bidTs . get ( i ) ; MarketData prevBar = this . bidTs . get ( i - 1 ) ; if ( ! order . HasPosition ( product ) ) { state = 0 ; } double currBody = currBar . getClose ( ) - currBar . getOpen ( ) ; double prevBody = prevBar . getClose ( ) - prevBar . getOpen ( ) ; double point = CurrencyTable . getPoint ( product ) ; if ( state == 0 ) { boolean cond1 = prevBody > 0 && currBody < 0 ; boolean cond2 = currBar . getOpen ( ) >= prevBar . getClose ( ) ; boolean cond3 = currBar . getClose ( ) <= prevBar . getOpen ( ) ; boolean cond4 = currBody <= - 3 ; if ( cond1 && cond2 && cond3 && cond4 ) { String entryTime = bidTs . get ( i ) . getStart ( ) ; this . entryPrice = bidTs . get ( i ) . getClose ( ) ; order . MarketSell ( product , entryTime , entryPrice , 2 ) ; this . stopPrice = prevBar . getClose ( ) + 100 * point ; this . r = this . stopPrice - this . entryPrice ; this . takeProfit = this . entryPrice - r ; order . StopBuy ( product , entryTime , this . stopPrice , 2 ) ; state = 1 ; } } else if ( state == 1 ) { if ( this . askTs . get ( i ) . getClose ( ) < this . takeProfit ) { order . MarketBuy ( product , currBar . getStart ( ) , this . takeProfit , 1 ) ; order . CancelAllPendingOrders ( product ) ; this . stopPrice = this . stopPrice - this . r ; this . takeProfit = this . takeProfit - this . r ; order . StopBuy ( product , currBar . getStart ( ) , this . stopPrice , 1 ) ; state = 2 ; } } else if ( state == 2 ) { if ( this . askTs . get ( i ) . getClose ( ) < this . takeProfit ) { this . stopPrice = this . stopPrice - this . r ; this . takeProfit = this . takeProfit - this . r ; order . CancelAllPendingOrders ( product ) ; order . StopBuy ( product , currBar . getStart ( ) , this . stopPrice , 1 ) ; } } }
tr	6	public void addFinance ( Finance finance ) { if ( finance instanceof Budget ) { if ( budgets == null ) { budgets = new ArrayList < > ( ) ; } budgets . add ( ( Budget ) finance ) ; ( ( Budget ) finance ) . setBudgetUser ( this ) ; } if ( finance instanceof Expending ) { if ( expendings == null ) { expendings = new ArrayList < > ( ) ; } expendings . add ( ( Expending ) finance ) ; ( ( Expending ) finance ) . setBudgetUser ( this ) ; } if ( finance instanceof Ingress ) { if ( ingresses == null ) { ingresses = new ArrayList < > ( ) ; } ingresses . add ( ( Ingress ) finance ) ; ( ( Ingress ) finance ) . setBudgetUser ( this ) ; } }
tr	8	@ Override public TIPO_OBJETO set ( TIPO_OBJETO oBean ) throws Exception { class < TIPO_OBJETO > tipo = ( class < TIPO_OBJETO > ) ( ( ParameterizedType ) getClass ( ) . getGenericSuperclass ( ) ) . getActualTypeArguments ( ) [ 0 ] ; Method metodo_getId = tipo . getMethod ( "getId" ) ; Method metodo_setId = tipo . getMethod ( "setId" , Integer . class ) ; try { oMysql . conexion ( enumTipoConexion ) ; oMysql . initTrans ( ) ; if ( ( Integer ) metodo_getId . invoke ( oBean ) == 0 ) { metodo_setId . invoke ( oBean , oMysql . insertOne ( strTabla ) ) ; } for ( Method method : tipo . getMethods ( ) ) { if ( ! method . getName ( ) . substring ( 3 ) . equalsIgnoreCase ( "id" ) ) { if ( method . getName ( ) . substring ( 0 , 3 ) . equalsIgnoreCase ( "get" ) ) { if ( ! method . getName ( ) . equals ( "getClass" ) ) { final class < ? > strTipoDevueltoMetodoGet = method . getReturnType ( ) ; String value = ( String ) method . invoke ( oBean ) . toString ( ) ; if ( strTipoDevueltoMetodoGet . getName ( ) . equals ( "java.util.Date" ) ) { SimpleDateFormat format = new SimpleDateFormat ( "yyyy-MM-dd" ) ; value = format . format ( method . invoke ( oBean ) ) ; } String strCampo = method . getName ( ) . substring ( 3 ) . toLowerCase ( Locale . ENGLISH ) ; oMysql . updateOne ( ( Integer ) metodo_getId . invoke ( oBean ) , strTabla , strCampo , value ) ; } } } } oMysql . commitTrans ( ) ; } catch ( Exception e ) { oMysql . rollbackTrans ( ) ; throw new Exception ( "GenericDao.set: Error: " + e . getMessage ( ) ) ; } finally { oMysql . desconexion ( ) ; } return oBean ; }
tr	4	@ Override public boolean equals ( final Object o ) { if ( ! ( o instanceof IntList ) ) { return false ; } final LongList that = ( LongList ) o ; if ( this . size != that . size ) { return false ; } for ( int i = 0 ; i < this . size ; i ++ ) { if ( this . data [ i ] != that . data [ i ] ) { return false ; } } return true ; }
tr	8	private void getFriendRealQQ ( ) { HashMap < String , String > properties = new HashMap < String , String > ( ) ; properties . put ( PROPERTY_REFER , URL_REFER_GET_INFO ) ; properties . put ( PROPERTY_ACCEPT , "*/*" ) ; properties . put ( PROPERTY_ACCEPT_ENCODING , "gzip deflate sdch" ) ; properties . put ( PROPERTY_CONNECTION , "keep-alive" ) ; properties . put ( PROPERTY_HOST , "s.web2.qq.com" ) ; properties . put ( PROPERTY_ORIGIN , "http://s.web2.qq.com" ) ; Iterator < String > iterator = friends . keySet ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { String key = iterator . next ( ) ; String content = String . format ( URL_FORMAT_GET_FRIEND_QQ , key , verifySession , vfwebqq , System . currentTimeMillis ( ) ) ; String resultString = sendGet ( content , properties ) ; System . out . println ( resultString ) ; try { JSONObject base = new JSONObject ( resultString ) ; if ( base . optInt ( "retcode" , - 1 ) == 0 ) { JSONObject result = base . optJSONObject ( "result" ) ; Friend friend = friends . get ( key ) ; friend . setQQ ( result . optString ( "account" , friend . getUin ( ) ) ) ; } } catch ( JSONException e ) { e . printStackTrace ( ) ; } } iterator = groups . keySet ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { String groupUni = iterator . next ( ) ; HashMap < String , Friend > members = groups . get ( groupUni ) . getMembers ( ) ; Iterator < String > memberIterator = members . keySet ( ) . iterator ( ) ; while ( memberIterator . hasNext ( ) ) { String key = memberIterator . next ( ) ; if ( friends . containsKey ( key ) ) { members . get ( key ) . setQQ ( friends . get ( key ) . getQQ ( ) ) ; } else { String content = String . format ( URL_FORMAT_GET_FRIEND_QQ , key , verifySession , vfwebqq , System . currentTimeMillis ( ) ) ; String resultString = sendGet ( content , properties ) ; System . out . println ( "GroupMemberQQ--" + resultString ) ; try { JSONObject base = new JSONObject ( resultString ) ; if ( base . optInt ( "retcode" , - 1 ) == 0 ) { JSONObject result = base . optJSONObject ( "result" ) ; Friend member = members . get ( key ) ; member . setQQ ( result . optString ( "account" , member . getUin ( ) ) ) ; } } catch ( JSONException e ) { e . printStackTrace ( ) ; } } } } }
tr	3	private Stack createCommands ( Stack stack ) throws TemplateException , IOException { Stack oldOut = new Stack ( ) ; Stack out = new Stack ( ) ; stack . reverse ( ) ; while ( ! stack . empty ( ) ) { Object obj = stack . pop ( ) ; if ( obj instanceof Command ) { Command cmd = ( Command ) obj ; cmd . readUntilClosing ( stack ) ; cmd . check ( ) ; out . push ( cmd ) ; } else { out . push ( obj ) ; } } if ( ! oldOut . empty ( ) ) { throw new TemplateException ( "A command is not closed!" ) ; } return out ; }
tr	3	public Node mergeList ( Node head1 , Node head2 ) { if ( head1 == null ) { return head2 ; } else if ( head2 == null ) { return head1 ; } Node mergeHead = null ; if ( head1 . value < head2 . value ) { mergeHead = head1 ; mergeHead . pNext = mergeList ( head1 . pNext , head2 ) ; } else { mergeHead = head2 ; mergeHead . pNext = mergeList ( head1 , head2 . pNext ) ; } return mergeHead ; }
tr	4	private void generatePressureFile ( ) { File file = new File ( this . pressFile ) ; ArrayList < Edge > edges = modelo . getEdges ( ) ; try { BufferedWriter output = new BufferedWriter ( new FileWriter ( file ) ) ; for ( Edge e : edges ) { String line ; int i = 1 ; for ( int vec : e . getFlowUnitVector ( ) ) { if ( vec != 0 ) { line = e . getNumber ( ) + " " + i + " " + vec + "\n" ; output . write ( line ) ; } i ++ ; } } output . close ( ) ; } catch ( IOException ex ) { Logger . getLogger ( Model . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } }
tr	3	@ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; IntNode intNode = ( IntNode ) o ; return value == intNode . value ; }
tr	0	static Date getTimeWarp ( ) { return timeWarp ; }
tr	0	private String initBuildManager ( ) { BuildManager bm = new BuildManager ( "src/com/dysnomia/build.props" ) ; return String . valueOf ( bm . getBuild ( ) ) ; }
tr	9	@ Override protected void doInBackground ( ) { File dir = new File ( MainClass . NANOPOSTS_DIR ) ; if ( ! dir . exists ( ) || ! dir . isDirectory ( ) ) { publish ( new SyncTaskState ( new Rule ( ) , "" , "Can't load nanoposts directory!" , 0 ) ) ; return null ; } File [ ] files = dir . listFiles ( new FilenameFilter ( ) { @ Override public boolean accept ( File directory , String fileName ) { return fileName . endsWith ( ".nanopost.png" ) ; } } ) ; File dirOutbox = new File ( MainClass . OUTBOX_DIR ) ; if ( ! dirOutbox . exists ( ) || ! dirOutbox . isDirectory ( ) ) { publish ( new SyncTaskState ( new Rule ( ) , "" , "Can't load outbox directory!" , 0 ) ) ; return null ; } File [ ] outbox = dirOutbox . listFiles ( new FilenameFilter ( ) { @ Override public boolean accept ( File directory , String fileName ) { return fileName . endsWith ( ".nanopost.png" ) ; } } ) ; int currentProgress = 0 ; this . totalProgressValue = files . length + outbox . length ; for ( File f : files ) { try { byte [ ] dataBytes = ImageUtils . tryToDecodeSteganoImage ( ByteUtils . readBytesFromFile ( f ) , boardCode ) ; try { NanoPost nanoPost = NanoPostFactory . getNanoPostFromBytes ( dataBytes , false ) ; nanoPost . setSourceImageData ( ByteUtils . readBytesFromFile ( f ) ) ; nanoPost . setOutbox ( false ) ; nbf . addNanoPostToList ( nanoPost ) ; currentProgress ++ ; publish ( new SyncTaskState ( new Rule ( ) , "" , nanoPost . toString ( ) , currentProgress ) ) ; } catch ( MalformedNanoPostException ex ) { Logger . getLogger ( NBFrame . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } } catch ( NoSuchAlgorithmException | NoSuchPaddingException | InvalidKeyException | InvalidAlgorithmParameterException | IllegalBlockSizeException | BadPaddingException | IOException ex ) { Logger . getLogger ( NBFrame . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } } for ( File f : outbox ) { try { byte [ ] dataBytes = ImageUtils . tryToDecodeSteganoImage ( ByteUtils . readBytesFromFile ( f ) , boardCode ) ; try { NanoPost nanoPost = NanoPostFactory . getNanoPostFromBytes ( dataBytes , true ) ; nanoPost . setSourceImageData ( ByteUtils . readBytesFromFile ( f ) ) ; nanoPost . setOutbox ( true ) ; nbf . addNanoPostToList ( nanoPost ) ; currentProgress ++ ; publish ( new SyncTaskState ( new Rule ( ) , "" , "outbox: " + nanoPost . toString ( ) , currentProgress ) ) ; } catch ( MalformedNanoPostException ex ) { System . out . println ( "[Invalid nanopost in outbox]: " + f . toString ( ) ) ; } } catch ( NoSuchAlgorithmException | NoSuchPaddingException | InvalidKeyException | InvalidAlgorithmParameterException | IllegalBlockSizeException | BadPaddingException | IOException ex ) { Logger . getLogger ( NBFrame . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } } publish ( new SyncTaskState ( new Rule ( ) , "" , "Complete" , this . totalProgressValue ) ) ; return null ; }
tr	6	public void execute ( ) { try { if ( lcmd == null ) { OutputStream out = new FileOutputStream ( getFilename ( ) ) ; writer = WriterFactory . getInstance ( ) . findWriterByName ( writerName , out ) ; for ( String query : getQueries ( ) ) { SearchCommand cmd = new SearchCommand ( ) ; cmd . addColumns ( fieldnames ) ; cmd . setQuery ( query ) ; cmd . addListener ( this ) ; Processor . setConnection ( connection ) ; Processor . execute ( cmd ) ; } } else { lcmd . addListener ( this ) ; Processor . setConnection ( connection ) ; Processor . execute ( lcmd ) ; } writer . close ( ) ; } catch ( FogBugzException e ) { logger . fatal ( "Execution failed." , e ) ; } catch ( FileNotFoundException e ) { logger . fatal ( "Execution failed." , e ) ; } catch ( IOException e ) { logger . fatal ( "Execution failed." , e ) ; } catch ( Exception e ) { logger . fatal ( "Execution failed." , e ) ; } }
tr	9	public static void main ( String argv [ ] ) throws Exception { boolean ssl = false ; String file = null ; IGraph cfg = null ; boolean daemon = false ; int port = 1111 ; for ( int i = 0 ; i < argv . length ; i ++ ) { String s = argv [ i ] ; if ( "-p" . equals ( s ) ) { port = Integer . parseInt ( argv [ i + 1 ] ) ; i ++ ; } if ( "-f" . equals ( s ) ) { file = argv [ i + 1 ] ; i ++ ; } else if ( "-ssl" . equals ( s ) ) ssl = true ; else if ( "-d" . equals ( s ) ) daemon = true ; } if ( file == null ) { System . out . println ( "Usage: ogdl.misc.RFServer [-ssl] [-p port] -f config.g" ) ; return ; } cfg = Ogdl . parse ( file ) ; if ( cfg == null ) { System . out . println ( file + " doesn't contain a valid configuration" ) ; return ; } new RFServer ( port , cfg , ssl ) ; if ( ! ssl ) { System . out . println ( "[OK] Starting RFServer on port " + port ) ; } else { System . out . println ( "[OK] Starting RFServer(SSL) on port " + port ) ; } if ( daemon ) { System . out . close ( ) ; System . err . close ( ) ; } while ( true ) { Thread . sleep ( 5000 ) ; } }
tr	6	public void add ( int val ) { System . out . printf ( "Adding element: %d%n" , val ) ; if ( root == null ) { new Node ( val ) . setRoot ( ) ; System . out . println ( " -> Setting as root." ) ; return ; } Node c = root ; while ( true ) { if ( val < c . value ) { System . out . printf ( " -> Smaller than %d : Going left%n" , c . value ) ; if ( c . left == null ) { c . setLeft ( new Node ( val ) ) ; System . out . printf ( " -> Setting as left child of %d%n" , c . value ) ; up ( c ) ; return ; } else c = c . left ; } else if ( val > c . value ) { System . out . printf ( " -> Bigger than %d : Going right%n" , c . value ) ; if ( c . right == null ) { c . setRight ( new Node ( val ) ) ; System . out . printf ( " -> Setting as right child of %d%n" , c . value ) ; up ( c ) ; return ; } else c = c . right ; } else throw new IllegalArgumentException ( "Already inserted." ) ; } }
tr	8	public BigDecimal getAvailability ( ) { LinkedHashSet < PhysicalLink > uniqPhysicalLinks = new LinkedHashSet < PhysicalLink > ( ) ; LinkedHashSet < PhysicalNode > uniqIntermediaryNodes = new LinkedHashSet < PhysicalNode > ( ) ; for ( VirtualLink virtualLink : linksMapping . keySet ( ) ) { PhysicalNode sourcePhysicalNode = getHostingNodeFor ( ( VirtualNode ) virtualLink . getSourceNode ( ) ) ; PhysicalNode destinyPhysicalNode = getHostingNodeFor ( ( VirtualNode ) virtualLink . getDestinyNode ( ) ) ; ArrayList < PhysicalLink > hostingLinks = linksMapping . get ( virtualLink ) ; for ( PhysicalLink hostingLink : hostingLinks ) { uniqPhysicalLinks . add ( hostingLink ) ; PhysicalNode hostingLinkSourceNode = ( PhysicalNode ) hostingLink . getSourceNode ( ) ; PhysicalNode hostingLinkDestinyNode = ( PhysicalNode ) hostingLink . getDestinyNode ( ) ; PhysicalNode [ ] hostingLinkNodes = { hostingLinkSourceNode , hostingLinkDestinyNode } ; for ( PhysicalNode hostingLinkNode : hostingLinkNodes ) { if ( ! hostingLinkNode . equals ( sourcePhysicalNode ) && ! hostingLinkNode . equals ( destinyPhysicalNode ) ) { uniqIntermediaryNodes . add ( hostingLinkNode ) ; } } } } BigDecimal availability = new BigDecimal ( 1 ) ; for ( PhysicalNode hostingNode : uniqPhysicalNodes ( ) ) { availability = availability . multiply ( hostingNode . getNodeAvailability ( ) , MathContext . DECIMAL64 ) ; } for ( PhysicalLink hostingLink : uniqPhysicalLinks ) { availability = availability . multiply ( hostingLink . getAvailability ( ) , MathContext . DECIMAL64 ) ; } for ( PhysicalNode intermediaryNode : uniqIntermediaryNodes ) { availability = availability . multiply ( intermediaryNode . getIntermediaryNodeAvailability ( ) , MathContext . DECIMAL64 ) ; } return availability ; }
tr	9	private synchronized void toServer ( int fromConnectionID , Message msg ) { int playerID = activePlayers . getPIDByCID ( fromConnectionID ) ; String playerName = msg . getPlayerName ( ) ; int speed = msg . getSpeed ( ) ; char nextDirection = msg . getNextDirection ( ) ; boolean startGame = msg . isStartGame ( ) ; if ( msg . getStage ( ) == 0 ) { if ( msg . getToMethode ( ) . equals ( new String ( "disconnectClient" ) ) ) { nS . sCommIF . disconnectClient ( playerID ) ; activeConnections . unregisterByID ( activePlayers . getCIDByPID ( playerID ) ) ; activePlayers . unregisterPlayer ( playerID ) ; } } else if ( msg . getStage ( ) == 1 ) { if ( msg . getToMethode ( ) . equals ( new String ( "registerClient" ) ) ) nS . sCommIF . registerClient ( playerID , playerName ) ; if ( msg . getToMethode ( ) . equals ( new String ( "gameSpeedIs" ) ) ) nS . sCommIF . gameSpeedIs ( speed ) ; if ( msg . getToMethode ( ) . equals ( new String ( "startGame" ) ) ) nS . sCommIF . startGame ( startGame ) ; } else if ( msg . getStage ( ) == 2 ) { if ( msg . getToMethode ( ) . equals ( new String ( "changeDirection" ) ) ) { nS . sCommIF . changeDirection ( playerID , nextDirection ) ; } } else if ( msg . getStage ( ) == 3 ) { } else { } }
tr	3	public static final Course readCourse ( File definitionFile ) { LOGGER . log ( Level . INFO , "Reading course from file '" + definitionFile + "'" ) ; JSONParser parser = new JSONParser ( ) ; JSONObject jsonObject = null ; try { jsonObject = ( JSONObject ) parser . parse ( new FileReader ( definitionFile ) ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } catch ( org . json . simple . parser . ParseException e ) { e . printStackTrace ( ) ; } Course course = new Course ( ( String ) jsonObject . get ( "name" ) , ( String ) jsonObject . get ( "address" ) , ( int ) ( ( long ) jsonObject . get ( "bestScore" ) ) , ( int ) ( ( long ) jsonObject . get ( "averageScore" ) ) , ( int ) ( ( long ) jsonObject . get ( "worstScore" ) ) , ( int ) ( ( long ) jsonObject . get ( "timesPlayed" ) ) , new ArrayList < Hole > ( ) , ( String ) jsonObject . get ( "userWithBestScore" ) , ( String ) jsonObject . get ( "description" ) ) ; LOGGER . log ( Level . INFO , "Created course '" + course . getName ( ) + "'" ) ; return course ; }
tr	7	private void initCloseCode ( ) throws InvalidFrameException { code = CloseFrame . NOCODE ; ByteBuffer payload = super . getPayloadData ( ) ; payload . mark ( ) ; if ( payload . remaining ( ) >= 2 ) { ByteBuffer bb = ByteBuffer . allocate ( 4 ) ; bb . position ( 2 ) ; bb . putShort ( payload . getShort ( ) ) ; bb . position ( 0 ) ; code = bb . getInt ( ) ; if ( code == CloseFrame . ABNORMAL_CLOSE || code == CloseFrame . TLS_ERROR || code == CloseFrame . NOCODE || code > 4999 || code < 1000 || code == 1004 ) { throw new InvalidFrameException ( "closecode must not be sent over the wire: " + code ) ; } } payload . reset ( ) ; }
tr	1	public String getValue ( String defaultValue ) { String value = getValue ( ) ; return ( value != null ) ? value : defaultValue ; }
tr	6	public boolean getBoolean ( int index ) throws JSONException { Object object = this . get ( index ) ; if ( object . equals ( boolean . false ) || ( object instanceof String && ( ( String ) object ) . equalsIgnoreCase ( "false" ) ) ) { return false ; } else if ( object . equals ( boolean . true ) || ( object instanceof String && ( ( String ) object ) . equalsIgnoreCase ( "true" ) ) ) { return true ; } throw new JSONException ( "JSONArray[" + index + "] is not a boolean." ) ; }
tr	0	@ Override public boolean isProducing ( ) { return isProducing ; }
tr	3	private HashMap < Integer , String > getAllFileContents ( ) { HashMap < Integer , String > result = new HashMap < Integer , String > ( ) ; Integer i = 1 ; try { @ SuppressWarnings ( "resource" ) BufferedReader br = new BufferedReader ( new FileReader ( out ) ) ; String line ; while ( ( line = br . readLine ( ) ) != null ) { if ( line . isEmpty ( ) ) { result . put ( i , null ) ; i ++ ; continue ; } result . put ( i , line ) ; i ++ ; } } catch ( Exception ex ) { ex . printStackTrace ( ) ; } return result ; }
tr	3	@ Override public Usuario readById ( long login , Connection conn ) throws Exception { Usuario e = null ; String sql = "SELECT usuario.*  empresa.id as empresa_id  empresa.nome as empresa_nome FROM empresa right join usuario on usuario.empresa_fk = empresa_id where usuario.login=?;" ; PreparedStatement ps = conn . prepareStatement ( sql ) ; ps . setLong ( 1 , login ) ; ResultSet rs = ps . executeQuery ( ) ; if ( rs . next ( ) ) { String tipo = rs . getString ( "tipo" ) ; if ( tipo . equalsIgnoreCase ( TIPO_ADMINISTRADOR ) ) { e = new Administrador ( ) ; } else if ( tipo . equalsIgnoreCase ( TIPO_FINANCEIRO ) ) { e = new Financeiro ( ) ; } else { e = new Solicitante ( ) ; } e . setTipo ( rs . getString ( "tipo" ) ) ; e . setLogin ( rs . getString ( "login" ) ) ; e . setSenha ( rs . getString ( "senha" ) ) ; e . setNome ( rs . getString ( "nome" ) ) ; e . setEmailCorporativo ( rs . getString ( "email_corporativo" ) ) ; e . setEmailPessoal ( rs . getString ( "email_pessoal" ) ) ; e . setTelefoneCorporativo ( rs . getString ( "telefone_corporativo" ) ) ; e . setTelefonePessoal ( rs . getString ( "telefone_pessoal" ) ) ; Empresa empresa = new Empresa ( ) ; empresa . setId ( rs . getLong ( "empresa_id" ) ) ; empresa . setNome ( rs . getString ( "empresa_nome" ) ) ; e . setEmpresa ( empresa ) ; } rs . close ( ) ; ps . close ( ) ; return e ; }
tr	9	final public CreateTableCommand CreateTable_suffix ( ) throws ParseException { String tableName ; List < CreateTableCommand . AttributeDescriptor > attributeDescriptors = new ArrayList < CreateTableCommand . AttributeDescriptor > ( ) ; List < String > primaryKeyAttrNames = new ArrayList < String > ( ) ; List < CreateTableCommand . ForeignKeyDescriptor > foreignKeyDescriptors = new ArrayList < CreateTableCommand . ForeignKeyDescriptor > ( ) ; CreateTableCommand . AttributeDescriptor attributeDescriptor ; CreateTableCommand . ForeignKeyDescriptor foreignKeyDescriptor ; String name ; jj_consume_token ( KW_TABLE ) ; tableName = Identifier ( ) ; jj_consume_token ( 52 ) ; label_2 : while ( true ) { attributeDescriptor = AttrDecl ( ) ; jj_consume_token ( 51 ) ; attributeDescriptors . add ( attributeDescriptor ) ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case IDENTIFIER : ; break ; default : jj_la1 [ 6 ] = jj_gen ; break label_2 ; } } jj_consume_token ( KW_PRIMARY ) ; jj_consume_token ( KW_KEY ) ; jj_consume_token ( 52 ) ; name = Identifier ( ) ; primaryKeyAttrNames . add ( name ) ; label_3 : while ( true ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case 51 : ; break ; default : jj_la1 [ 7 ] = jj_gen ; break label_3 ; } jj_consume_token ( 51 ) ; name = Identifier ( ) ; primaryKeyAttrNames . add ( name ) ; } jj_consume_token ( 53 ) ; label_4 : while ( true ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case 51 : ; break ; default : jj_la1 [ 8 ] = jj_gen ; break label_4 ; } jj_consume_token ( 51 ) ; foreignKeyDescriptor = ForeignKeyDecl ( ) ; foreignKeyDescriptors . add ( foreignKeyDescriptor ) ; } jj_consume_token ( 53 ) ; { if ( true ) return new CreateTableCommand ( token , tableName , attributeDescriptors , primaryKeyAttrNames , foreignKeyDescriptors ) ; } throw new Error ( "Missing return statement in function" ) ; }
tr	8	private static ArrayList < ResidualEdge > minCostFlowWithBellmanFordSub ( ArrayList < ResidualEdge > [ ] edges , int s , int t ) { int n = edges . length ; ResidualEdge [ ] prevE = new ResidualEdge [ n ] ; int [ ] prevV = new int [ n ] ; int [ ] dist = new int [ n ] ; Arrays . fill ( prevV , - 1 ) ; Arrays . fill ( dist , INF ) ; dist [ s ] = 0 ; prevV [ s ] = - 2 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int v = 0 ; v < n ; v ++ ) { for ( ResidualEdge e : edges [ v ] ) { if ( e . residual > 0 && dist [ e . to ] > dist [ v ] + e . cost ) { dist [ e . to ] = dist [ v ] + e . cost ; prevE [ e . to ] = e ; prevV [ e . to ] = v ; } } } } if ( prevE [ t ] == null ) return null ; ArrayList < ResidualEdge > path = new ArrayList < ResidualEdge > ( ) ; ResidualEdge e ; for ( int v = t ; ; v = prevV [ v ] ) { e = prevE [ v ] ; if ( e == null ) break ; path . add ( e ) ; } return path ; }
tr	1	public void drawButtons ( ) { for ( int x = 0 ; x < buttons . size ( ) ; x ++ ) { buttons . get ( x ) . draw ( ScreenX , ScreenY ) ; } }
tr	6	public boolean getBoolean ( String key ) throws JSONException { Object object = this . get ( key ) ; if ( object . equals ( boolean . false ) || ( object instanceof String && ( ( String ) object ) . equalsIgnoreCase ( "false" ) ) ) { return false ; } else if ( object . equals ( boolean . true ) || ( object instanceof String && ( ( String ) object ) . equalsIgnoreCase ( "true" ) ) ) { return true ; } throw new JSONException ( "JSONObject[" + quote ( key ) + "] is not a Boolean." ) ; }
tr	1	public int getSize ( ) { int ret = restart . size ( ) ; for ( State st : next . values ( ) ) { ret += st . getSize ( ) + 1 ; } return ret ; }
tr	0	public Demographics getDemographics ( ) { return demographics ; }
tr	6	public static WeightedGraph readGraph ( InputStream is ) { int V = 0 ; Scanner fileScanner = new Scanner ( is ) ; if ( fileScanner . hasNextInt ( ) ) { V = fileScanner . nextInt ( ) ; System . err . println ( "V " + V ) ; } int E = 0 ; if ( fileScanner . hasNextInt ( ) ) { E = fileScanner . nextInt ( ) ; System . err . println ( "E " + E ) ; } WeightedGraph result = new WeightedGraph ( V , E ) ; while ( fileScanner . hasNextLine ( ) ) { String str = fileScanner . nextLine ( ) ; Scanner lineScanner = new Scanner ( str ) ; if ( lineScanner . hasNextInt ( ) ) { int v1 = lineScanner . nextInt ( ) ; if ( lineScanner . hasNextInt ( ) ) { int v2 = lineScanner . nextInt ( ) ; if ( lineScanner . hasNextInt ( ) ) { int weight = lineScanner . nextInt ( ) ; result . addEdge ( new Edge ( v1 , v2 , weight ) ) ; } } } lineScanner . close ( ) ; } fileScanner . close ( ) ; return result ; }
tr	2	@ Override public void accept ( YSpecVisitor v ) { v . visit ( this ) ; for ( YNetElement e : outwardFlows ( ) ) { if ( ! v . visited ( e ) ) e . accept ( v ) ; } }
tr	5	public static boolean onBoard ( Location loc ) { if ( loc == null ) return false ; if ( loc . row < 0 ) return false ; if ( loc . column < 0 ) return false ; if ( loc . row >= SIZE ) return false ; if ( loc . column >= SIZE ) return false ; return true ; }
tr	7	static final public int totalDiff ( final String hash1 , final String hash2 , final boolean lenDiff ) { int diff = 0 ; int [ ] iHash1 = fromHex ( hash1 ) ; int [ ] iHash2 = fromHex ( hash2 ) ; if ( lenDiff ) { int ldiff = modDiff ( iHash1 [ TLSH_CHECKSUM_LEN ] , iHash2 [ TLSH_CHECKSUM_LEN ] , RANGE_LVALUE ) ; if ( ldiff == 0 ) diff = 0 ; else if ( ldiff == 1 ) diff = 1 ; else diff += ldiff * 12 ; } int q1diff = modDiff ( iHash1 [ TLSH_CHECKSUM_LEN + 1 ] & f , iHash2 [ TLSH_CHECKSUM_LEN + 1 ] & f , RANGE_QRATIO ) ; if ( q1diff <= 1 ) diff += q1diff ; else diff += ( q1diff - 1 ) * 12 ; int q2diff = modDiff ( iHash1 [ TLSH_CHECKSUM_LEN + 1 ] >> 4 , iHash2 [ TLSH_CHECKSUM_LEN + 1 ] >> 4 , RANGE_QRATIO ) ; if ( q2diff <= 1 ) diff += q2diff ; else diff += ( q2diff - 1 ) * 12 ; for ( int k = 0 ; k < TLSH_CHECKSUM_LEN ; k ++ ) { if ( iHash1 [ k ] != iHash2 [ k ] ) { diff ++ ; break ; } } diff += hDistance ( Arrays . copyOfRange ( iHash1 , TLSH_CHECKSUM_LEN + 2 , iHash1 . length ) , Arrays . copyOfRange ( iHash2 , TLSH_CHECKSUM_LEN + 2 , iHash2 . length ) ) ; return diff ; }
tr	6	public Control ( String title , T min , T max , T value , T step , class < ? extends T > valueClass ) { super ( new GridLayout ( 3 , 1 ) ) ; if ( title == null || min == null || max == null || step == null || valueClass == null ) { throw new NullPointerException ( ) ; } this . min = min ; this . max = max ; this . valueClass = valueClass ; label = new JLabel ( title ) ; add ( label ) ; spinnerModel = new SpinnerNumberModel ( value , min , max , step ) ; spinner = new JSpinner ( spinnerModel ) ; spinnerEditor = new ValidatingSpinnerNumberEditor < > ( spinner , valueClass ) ; spinnerEditor . setMessage ( String . format ( Messages . getString ( "Control.ErrorMessage" ) , valueClass . getSimpleName ( ) , min , max ) ) ; spinner . setEditor ( spinnerEditor ) ; add ( spinner ) ; int divisions = Math . round ( ( max . floatValue ( ) - min . floatValue ( ) ) / step . floatValue ( ) ) ; slider = new JSlider ( 0 , divisions ) ; add ( slider ) ; syncSliderToSpinner ( ) ; spinner . addChangeListener ( new ChangeListener ( ) { @ Override public void stateChanged ( ChangeEvent e ) { syncSliderToSpinner ( ) ; } } ) ; slider . addChangeListener ( new ChangeListener ( ) { @ Override public void stateChanged ( ChangeEvent e ) { syncSpinnerToSlider ( ) ; } } ) ; }
tr	4	private void jMenuItem3ActionPerformed ( java . awt . event . ActionEvent evt ) { try { JFileChooser fileChooser = new JFileChooser ( "E:\\" ) ; fileChooser . setMultiSelectionEnabled ( true ) ; fileChooser . showOpenDialog ( this ) ; File playList = fileChooser . getSelectedFile ( ) ; if ( playList . exists ( ) ) { ObjectInputStream inputStream = new ObjectInputStream ( new FileInputStream ( playList ) ) ; Object readObject = inputStream . readObject ( ) ; if ( readObject instanceof File [ ] ) { playFiles = ( File [ ] ) readObject ; DurationThread durationThread = new DurationThread ( playFiles ) ; ArrayList < String > durationList = durationThread . getTrackDuration ( ) ; addToTable ( playFiles , durationList , "Open" ) ; } } } catch ( IOException ex ) { Logger . getLogger ( EchoPlayer . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( ClassNotFoundException ex ) { Logger . getLogger ( EchoPlayer . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } }
tr	1	@ Override public int hashCode ( ) { int hash = 5 ; hash = 23 * hash + ( this . attendID != null ? this . attendID . hashCode ( ) : 0 ) ; return hash ; }
tr	8	public static void main ( String args [ ] ) { try { UIManager . setLookAndFeel ( UIManager . getSystemLookAndFeelClassName ( ) ) ; } catch ( ClassNotFoundException e ) { e . printStackTrace ( ) ; } catch ( InstantiationException e ) { e . printStackTrace ( ) ; } catch ( IllegalAccessException e ) { e . printStackTrace ( ) ; } catch ( UnsupportedLookAndFeelException e ) { e . printStackTrace ( ) ; } JTabbedPane contentPane = new JTabbedPane ( ) ; contentPane . setBorder ( new EmptyBorder ( 5 , 5 , 5 , 5 ) ) ; contentPane . add ( "Owners" , ownerGui . getMainPanel ( ) ) ; contentPane . add ( "Models" , modelGui . getMainPanel ( ) ) ; contentPane . add ( "Vehicles" , vehicleGui . getMainPanel ( ) ) ; contentPane . addChangeListener ( new ChangeListener ( ) { @ Override public void stateChanged ( ChangeEvent e ) { int tabIndex = ( ( JTabbedPane ) e . getSource ( ) ) . getSelectedIndex ( ) ; switch ( tabIndex ) { case 0 : ownerGui . update ( ) ; break ; case 1 : modelGui . update ( ) ; break ; case 2 : vehicleGui . update ( ) ; break ; } } } ) ; JFrame frame = new JFrame ( ) ; frame . setTitle ( "OrgaTaxe" ) ; frame . setContentPane ( contentPane ) ; frame . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; URL imageURL = frame . getClass ( ) . getResource ( "/ressource/image/valid.png" ) ; if ( imageURL != null ) { frame . setIconImage ( new ImageIcon ( imageURL ) . getImage ( ) ) ; } buildMenuBar ( frame ) ; frame . pack ( ) ; frame . setVisible ( true ) ; taxeTable . setModels ( new TaxeTableModel ( ) ) ; taxeDialog = new JDialog ( frame ) ; taxeDialog . getContentPane ( ) . add ( taxeTable . getMainPanel ( ) ) ; taxeDialog . pack ( ) ; }
tr	8	static Object [ ] [ ] divide ( Object [ ] [ ] x , Object [ ] [ ] y ) { Object [ ] [ ] ret = new Object [ x . length ] [ ] ; for ( int i = 0 ; i < x . length ; i ++ ) { ret [ i ] = new Object [ x [ i ] . length ] ; for ( int j = 0 ; j < x [ i ] . length ; j ++ ) { Object a = x [ i ] [ j ] ; Object b = y [ i ] [ j ] ; if ( a == null || b == null ) { ret [ i ] [ j ] = null ; } else if ( a instanceof Integer ) { Integer bInteger = ( Integer ) b ; if ( bInteger == 0 ) ret [ i ] [ j ] = null ; else ret [ i ] [ j ] = ( Integer ) a / bInteger ; } else if ( a instanceof double ) { ret [ i ] [ j ] = ( double ) a / ( double ) b ; } else { BigInteger val = ( BigInteger ) b ; ret [ i ] [ j ] = val . signum ( ) == 0 ? null : ( ( BigInteger ) a ) . divide ( val ) ; } } } return ret ; }
tr	0	public static void main ( String [ ] args ) { int x , y , z ; x = y = z = 1 ; System . out . println ( "x = " + x + "  y = " + y + "  z = " + z ) ; System . out . println ( 32 % 7 % 3 ) ; System . out . println ( ( 32 % 7 ) % 3 ) ; System . out . println ( 32 % ( 7 % 3 ) ) ; }
tr	1	private boolean matchExact ( String expected , String actual ) { return matchMode == MatchMode . EXACT && actual . equals ( expected ) ; }
tr	9	public ArrayList < Integer > obtenerJugadasGanadorasDeHoy ( ArrayList < Integer > boletosDeHoy , ArrayList < Integer > numerosGanadores , int loteria_id ) { Verificadora verificadora = new Verificadora ( ) ; Connection cn = conexion . Conectar ( ) ; PreparedStatement pst ; ResultSet rs ; String query ; ArrayList < Integer > jugadasDeHoy = new ArrayList < > ( ) ; int numerog1 , numerog2 , numerog3 ; numerog1 = numerosGanadores . get ( 0 ) ; numerog2 = numerosGanadores . get ( 1 ) ; numerog3 = numerosGanadores . get ( 2 ) ; int coincidencias = 0 ; for ( int i = 0 ; i < boletosDeHoy . size ( ) ; i ++ ) { query = "SELECT jugada_id  combinacion  monto  formato_id FROM jugadas WHERE boleto_id = " + boletosDeHoy . get ( i ) + " AND loteria_id =" + loteria_id ; try { pst = cn . prepareStatement ( query ) ; rs = pst . executeQuery ( ) ; while ( rs . next ( ) ) { String comb = separarCombinacion ( rs . getString ( "combinacion" ) ) . get ( 0 ) ; String [ ] combinacion = rs . getString ( "combinacion" ) . split ( "-" ) ; int formato = rs . getInt ( "formato_id" ) ; int jugada_id = rs . getInt ( "jugada_id" ) ; numerosGanadores . clear ( ) ; numerosGanadores . add ( numerog1 ) ; numerosGanadores . add ( numerog2 ) ; numerosGanadores . add ( numerog3 ) ; coincidencias = verificadora . verificarCoincidencias ( separarCombinacion ( rs . getString ( "combinacion" ) ) , numerosGanadores ) ; System . out . println ( "jugada: " + jugada_id ) ; System . out . println ( "coinc: " + coincidencias ) ; System . out . println ( "Formato: " + formato ) ; if ( coincidencias == 1 && formato == 2 ) { jugadasDeHoy . add ( jugada_id ) ; calcularQuiniela ( jugada_id , Integer . parseInt ( combinacion [ 0 ] ) , numerog1 , numerog2 , numerog3 , double . parseDouble ( rs . getString ( "monto" ) ) ) ; System . out . println ( "Quiniela gan\u00F3: " + jugada_id ) ; } else if ( coincidencias == 2 && formato == 3 ) { jugadasDeHoy . add ( jugada_id ) ; calcularPale ( jugada_id , Integer . parseInt ( combinacion [ 0 ] ) , Integer . parseInt ( combinacion [ 1 ] ) , numerog1 , numerog2 , numerog3 , double . parseDouble ( rs . getString ( "monto" ) ) ) ; } else if ( coincidencias == 3 && formato == 1 ) { jugadasDeHoy . add ( jugada_id ) ; calcularTripleta ( jugada_id , double . parseDouble ( rs . getString ( "monto" ) ) ) ; } } } catch ( SQLException ex ) { System . out . println ( ex ) ; } } return jugadasDeHoy ; }
tr	3	public String fromServer ( ) { String buf = null ; try { while ( ! myInput . ready ( ) ) ; try { buf = myInput . readLine ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; System . exit ( 0 ) ; } } catch ( IOException e ) { e . printStackTrace ( ) ; } return buf ; }
tr	1	public String format ( String unformattedXml ) { TransformerFactory tfactory = TransformerFactory . newInstance ( ) ; Transformer serializer ; try { serializer = tfactory . newTransformer ( ) ; serializer . setOutputProperty ( OutputKeys . ENCODING , "UTF-8" ) ; serializer . setOutputProperty ( OutputKeys . INDENT , "yes" ) ; serializer . setOutputProperty ( "{http://xml.apache.org/xslt}indent-amount" , "4" ) ; Element node = parseXmlFile ( unformattedXml ) ; StringWriter out = new StringWriter ( ) ; serializer . transform ( new DOMSource ( node ) , new StreamResult ( out ) ) ; return out . toString ( ) ; } catch ( TransformerException e ) { e . printStackTrace ( ) ; throw new RuntimeException ( e ) ; } }
tr	5	private static void begin ( ) { Map < Character , Character > c2cMap = new HashMap < Character , Character > ( ) ; for ( String row : KEYBOARD ) { for ( int i = 1 ; i < row . length ( ) ; ++ i ) { c2cMap . put ( row . charAt ( i ) , row . charAt ( i - 1 ) ) ; } } c2cMap . put (   ,   ) ; Scanner sc = new Scanner ( System . in ) ; while ( sc . hasNextLine ( ) ) { String line = sc . nextLine ( ) ; StringBuffer output = new StringBuffer ( ) ; for ( int i = 0 ; i < line . length ( ) ; ++ i ) { char c = line . charAt ( i ) ; if ( c2cMap . containsKey ( c ) ) { output . append ( c2cMap . get ( c ) ) ; } } System . out . println ( output ) ; } }
tr	3	public XMLNode getChild ( String name , int index ) { int a = 0 ; for ( int i = 0 ; i < childs . size ( ) ; i ++ ) { if ( childs . get ( i ) . getName ( ) . equals ( name ) ) { a ++ ; if ( a == index ) return childs . get ( i ) ; } } return null ; }
tr	2	ArrayList < Object [ ] > getPickerArgs ( ) { ArrayList < Object [ ] > pickerArgs = new ArrayList < Object [ ] > ( ) ; if ( this . pickers > 0 ) { Pickers pickers = this . warehouse . getPickers ( ) ; ArrayList < Picker > rl = pickers . getPickerList ( ) ; for ( Picker r : rl ) { Object [ ] args = new Object [ 1 ] ; args [ 0 ] = r . getUID ( ) ; pickerArgs . add ( args ) ; } } return pickerArgs ; }
tr	1	public static void main ( String [ ] args ) { char [ ] arr = new char [ 100 ] ; String str = "a b c d e f" ; int i = 0 ; for ( char c : str . toCharArray ( ) ) { arr [ i ++ ] = c ; } replaceSpace ( arr , 11 ) ; System . out . println ( arr ) ; }
tr	8	public void newRandomConnection ( Neuron neuron ) { try { for ( int i = 0 ; i < neurons . size ( ) ; i ++ ) neurons . get ( i ) . findDepth ( ) ; } catch ( StackOverflowError e ) { System . out . println ( "There was a stack overflow because of findDepth :: SpeciationNeuralNetwork" ) ; new CMDTester ( this ) ; System . exit ( 0 ) ; } if ( neuron instanceof OutputNeuron ) { mutate ( ) ; return ; } neurons = Neuron . sortByDepth ( neurons ) ; int index = 0 ; for ( ; index < neurons . size ( ) && neurons . get ( index ) != neuron ; index ++ ) { } int maxRan = ( new Random ( ) ) . nextInt ( neurons . size ( ) - index ) ; if ( maxRan == 0 ) { mutate ( ) ; return ; } if ( neuron . existsConnection ( neurons . get ( index + maxRan ) ) ) { mutate ( ) ; return ; } if ( neurons . indexOf ( neuron ) >= index + maxRan ) { System . out . println ( "ERROR :: SpeciationNeuralNetwork 211" ) ; } makeConnection ( neuron , neurons . get ( index + maxRan ) ) ; }
tr	2	public void flushToDisk ( ) { try { BufferedWriter br = new BufferedWriter ( new OutputStreamWriter ( new FileOutputStream ( recordFile ) , "UTF-8" ) ) ; for ( Iterator iterator = records . iterator ( ) ; iterator . hasNext ( ) ; ) { Record record = ( Record ) iterator . next ( ) ; br . write ( record . toString ( ) + "\r\n" ) ; } br . flush ( ) ; br . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; CharApp . getInstance ( ) . showErrorMessage ( "Problem adding record: " + e . getMessage ( ) ) ; } }
tr	1	private boolean r_mark_ki ( ) { if ( ! ( eq_s_b ( 2 , "ki" ) ) ) { return false ; } return true ; }
tr	5	public static String toString ( int [ ] a , NumberFormat nf ) { if ( a == null ) return null ; if ( a . length == 0 ) return "[]" ; StringBuilder b = new StringBuilder ( ) ; b . append ( "[" ) ; for ( int i = 0 ; i < a . length - 1 ; i ++ ) { String s ; if ( nf == null ) { s = String . valueOf ( a [ i ] ) ; } else { s = nf . format ( a [ i ] ) ; } b . append ( s ) ; b . append ( "  " ) ; } String s ; if ( nf == null ) { s = String . valueOf ( a [ a . length - 1 ] ) ; } else { s = nf . format ( a [ a . length - 1 ] ) ; } b . append ( s ) ; b . append ( ] ) ; return b . toString ( ) ; }
tr	2	public static void assert_are_of_type ( class expected_type , Object ... objects ) { for ( Object object : objects ) { if ( ! object . getClass ( ) . isInstance ( expected_type ) ) { assert . fail ( String . format ( "Expecting type [%s] GOT [%s]" , expected_type , object . getClass ( ) ) ) ; } } }
tr	8	public static ArrayList < Player > getEnemies ( Player player ) { ArrayList < Player > emenies = new ArrayList < Player > ( ) ; if ( ! getTeamFriends ( Teams . getTeamOfPlayer ( player ) ) . contains ( Teams . getPlayersOfTeam ( BLUE ) ) && Teams . getPlayersOfTeam ( BLUE ) != null ) { emenies . add ( Teams . getPlayersOfTeam ( BLUE ) ) ; } if ( ! getTeamFriends ( Teams . getTeamOfPlayer ( player ) ) . contains ( Teams . getPlayersOfTeam ( GREEN ) ) && Teams . getPlayersOfTeam ( GREEN ) != null ) { emenies . add ( Teams . getPlayersOfTeam ( GREEN ) ) ; } if ( ! getTeamFriends ( Teams . getTeamOfPlayer ( player ) ) . contains ( Teams . getPlayersOfTeam ( ORANGE ) ) && Teams . getPlayersOfTeam ( ORANGE ) != null ) { emenies . add ( Teams . getPlayersOfTeam ( ORANGE ) ) ; } if ( ! getTeamFriends ( Teams . getTeamOfPlayer ( player ) ) . contains ( Teams . getPlayersOfTeam ( RED ) ) && Teams . getPlayersOfTeam ( RED ) != null ) { emenies . add ( Teams . getPlayersOfTeam ( RED ) ) ; } return emenies ; }
tr	6	@ Test public void testBytes ( ) { Serializer serpent = new Serializer ( true , true , false ) ; byte [ ] bytes = new byte [ ] { 97 , 98 , 99 , 100 , 101 , 102 } ; byte [ ] ser = serpent . serialize ( bytes ) ; assertEquals ( "{\n  'data': 'YWJjZGVm' \n  'encoding': 'base64'\n}" , S ( strip_header ( ser ) ) ) ; Parser p = new Parser ( ) ; String parsed = p . parse ( ser ) . root . toString ( ) ; assertEquals ( 39 , parsed . length ( ) ) ; Map < String , String > dict = new HashMap < String , String > ( ) ; dict . put ( "data" , "YWJjZGVm" ) ; dict . put ( "encoding" , "base64" ) ; byte [ ] bytes2 = Parser . toBytes ( dict ) ; assertArrayEquals ( bytes , bytes2 ) ; dict . put ( "encoding" , "base99" ) ; try { Parser . toBytes ( dict ) ; fail ( "error expected" ) ; } catch ( IllegalArgumentException x ) { } dict . clear ( ) ; try { Parser . toBytes ( dict ) ; fail ( "error expected" ) ; } catch ( IllegalArgumentException x ) { } dict . clear ( ) ; dict . put ( "data" , "YWJjZGVm" ) ; try { Parser . toBytes ( dict ) ; fail ( "error expected" ) ; } catch ( IllegalArgumentException x ) { } dict . clear ( ) ; dict . put ( "encoding" , "base64" ) ; try { Parser . toBytes ( dict ) ; fail ( "error expected" ) ; } catch ( IllegalArgumentException x ) { } try { Parser . toBytes ( 12345 ) ; fail ( "error expected" ) ; } catch ( IllegalArgumentException x ) { } try { Parser . toBytes ( null ) ; fail ( "error expected" ) ; } catch ( IllegalArgumentException x ) { } }
tr	6	public void setCellData ( int row , int col , E cellData ) { CellPath cellPath = createCellPath ( row , col ) ; if ( cellData == null ) { if ( cells . containsKey ( cellPath ) ) { cells . remove ( cellPath ) ; } } if ( row > maxRow ) maxRow = row ; if ( row < minRow ) minRow = row ; if ( col > maxColumn ) maxColumn = col ; if ( col < minColumn ) minColumn = col ; cells . put ( cellPath , cellData ) ; }
tr	1	@ Override public MDDVariable getVariableForKey ( Object key ) { MDDVariable var = store . getVariableForKey ( key ) ; int idx = store2custom [ var . order ] ; if ( idx < 0 ) { return null ; } return var ; }
tr	9	private Collection < String > missingRequiredOptions ( OptionSet options ) { Collection < String > missingRequiredOptions = new HashSet < String > ( ) ; for ( AbstractOptionSpec < ? > each : recognizedOptions . toJavaUtilMap ( ) . values ( ) ) { if ( each . isRequired ( ) && ! options . has ( each ) ) missingRequiredOptions . addAll ( each . options ( ) ) ; } for ( Map . Entry < Collection < String > , Set < OptionSpec < ? >>> eachEntry : requiredIf . entrySet ( ) ) { AbstractOptionSpec < ? > required = specFor ( eachEntry . getKey ( ) . iterator ( ) . next ( ) ) ; if ( optionsHasAnyOf ( options , eachEntry . getValue ( ) ) && ! options . has ( required ) ) { missingRequiredOptions . addAll ( required . options ( ) ) ; } } for ( Map . Entry < Collection < String > , Set < OptionSpec < ? >>> eachEntry : requiredUnless . entrySet ( ) ) { AbstractOptionSpec < ? > required = specFor ( eachEntry . getKey ( ) . iterator ( ) . next ( ) ) ; if ( ! optionsHasAnyOf ( options , eachEntry . getValue ( ) ) && ! options . has ( required ) ) { missingRequiredOptions . addAll ( required . options ( ) ) ; } } return missingRequiredOptions ; }
tr	3	public char skipTo ( char to ) throws JSONException { char c ; try { long startIndex = this . index ; long startCharacter = this . character ; long startLine = this . line ; this . reader . mark ( 1000000 ) ; do { c = this . next ( ) ; if ( c == 0 ) { this . reader . reset ( ) ; this . index = startIndex ; this . character = startCharacter ; this . line = startLine ; return c ; } } while ( c != to ) ; } catch ( IOException exc ) { throw new JSONException ( exc ) ; } this . back ( ) ; return c ; }
tr	1	public String informaNomeJogador ( int posicao ) { if ( posicao == 1 ) { return jogador1 . obterNome ( ) ; } else { return jogador2 . obterNome ( ) ; } }
tr	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( MenuProductosCliente . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( MenuProductosCliente . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( MenuProductosCliente . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( MenuProductosCliente . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { MenuProductosCliente dialog = new MenuProductosCliente ( new javax . swing . JFrame ( ) , true ) ; dialog . addWindowListener ( new java . awt . event . WindowAdapter ( ) { @ Override public void windowClosing ( java . awt . event . WindowEvent e ) { System . exit ( 0 ) ; } } ) ; dialog . setVisible ( true ) ; } } ) ; }
tr	8	public Player [ ] getWinners ( ) { int winner = - 1 ; Player players [ ] = this . players ; for ( int i = 0 ; i < players . length && winner < 0 ; ++ i ) { Player p = players [ i ] ; if ( p . equals ( this . getBestPlayerBet ( ) ) ) { winner = i ; } } int winnerTeammate = 0 ; int loser = 0 ; int loserTeammate = 0 ; if ( winner == 0 ) { winnerTeammate = 2 ; loser = 1 ; loserTeammate = 3 ; } else if ( winner == 1 ) { winnerTeammate = 3 ; loser = 0 ; loserTeammate = 2 ; } else if ( winner == 2 ) { winnerTeammate = 0 ; loser = 1 ; loserTeammate = 3 ; } else if ( winner == 3 ) { winnerTeammate = 1 ; loser = 0 ; loserTeammate = 2 ; } int roundsWon = this . players [ winner ] . getTurnWin ( ) + this . players [ winnerTeammate ] . getTurnWin ( ) ; int roundsBet = this . players [ winner ] . getOriginalBet ( ) . getNbRounds ( ) ; Player [ ] winners ; if ( roundsWon >= roundsBet ) { winners = new Player [ ] { this . players [ winner ] , this . players [ winnerTeammate ] } ; } else { winners = new Player [ ] { this . players [ loser ] , this . players [ loserTeammate ] } ; } return winners ; }
tr	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( DialogKirimPesan . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( DialogKirimPesan . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( DialogKirimPesan . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( DialogKirimPesan . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { DialogKirimPesan dialog = new DialogKirimPesan ( new javax . swing . JFrame ( ) , true ) ; dialog . addWindowListener ( new java . awt . event . WindowAdapter ( ) { @ Override public void windowClosing ( java . awt . event . WindowEvent e ) { System . exit ( 0 ) ; } } ) ; dialog . setVisible ( true ) ; } } ) ; }
tr	1	public void setRowCount ( int count ) { this . tableModel . setRowCount ( count ) ; rowColors . clear ( ) ; for ( int i = 0 ; i < count ; i ++ ) { rowColors . add ( getTableForeground ( ) ) ; } }
tr	4	@ Test public void testNaissanceSoldats ( ) { SalleSoldat testSoldat = new SalleSoldat ( ) ; SalleNourrice sn = new SalleNourrice ( ) ; Evenements . getInstance ( ) . setEvenementActif ( Constantes . EVEN_DEPLACEMENT ) ; sn . ajouterFourmi ( 3 ) ; testSoldat . naissanceSoldats ( 2 , sn ) ; assertEquals ( 1 , testSoldat . getNbCourantFourmi ( ) ) ; assertEquals ( 1 , sn . getNbCourantFourmi ( ) ) ; try { testSoldat . naissanceSoldats ( 2 , sn ) ; fail ( "ExceptionNourrices non levee." ) ; } catch ( ExceptionNourrices en ) { } try { testSoldat . naissanceSoldats ( 0 , sn ) ; fail ( "IllegalArgumentException non levee." ) ; } catch ( IllegalArgumentException iae ) { } try { testSoldat . naissanceSoldats ( 1 , sn ) ; fail ( "IllegalArgumentException non levee." ) ; } catch ( IllegalArgumentException iae ) { } try { testSoldat . naissanceSoldats ( 5 , sn ) ; fail ( "IllegalArgumentException non levee." ) ; } catch ( IllegalArgumentException iae ) { } }
tr	6	public static void main ( String argv [ ] ) { Bus busses [ ] = null ; Host host ; try { host = HostFactory . getHost ( ) ; if ( host == null ) { System . err . println ( "USB is unavailable  can't run." ) ; return ; } System . out . println ( "<!-- " + host + " -->" ) ; busses = host . getBusses ( ) ; indentLine ( 0 , "<host busses='" + busses . length + "'>" ) ; for ( int busno = 0 ; busno < busses . length ; busno ++ ) { indentLine ( 2 , "<!-- Bus #" + ( busno + 1 ) + " -->" ) ; if ( busses [ busno ] != null ) { try { printDevice ( 2 , busses [ busno ] . getRootHub ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } } indentLine ( 0 , "</host>" ) ; } catch ( SecurityException e ) { System . err . println ( "USB permissions problem:" ) ; System . err . println ( e . getMessage ( ) ) ; System . exit ( 1 ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } }
tr	3	public Request < ModifyPropertyValueRequest > marshall ( ModifyPropertyValueRequest modifyPropertyValueRequest ) { if ( modifyPropertyValueRequest == null ) { throw new AmazonClientException ( "Invalid argument passed to marshall(...)" ) ; } final Request < ModifyPropertyValueRequest > request = new DefaultRequest < > ( modifyPropertyValueRequest , "EucalyptusProperties" ) ; request . addParameter ( "Action" , "ModifyPropertyValue" ) ; request . addParameter ( "Version" , "eucalyptus" ) ; if ( modifyPropertyValueRequest . getName ( ) != null ) { request . addParameter ( "Name" , StringUtils . fromString ( modifyPropertyValueRequest . getName ( ) ) ) ; } if ( modifyPropertyValueRequest . getValue ( ) != null ) { request . addParameter ( "Value" , StringUtils . fromString ( modifyPropertyValueRequest . getValue ( ) ) ) ; } return request ; }
tr	5	public void swapInt ( int [ ] data , int from , int to ) { if ( from < 0 || from >= data . length || to < 0 || to > data . length ) { System . out . println ( "Swap Error!" ) ; throw new IndexOutOfBoundsException ( "Swap Error!" ) ; } if ( from == to ) { return ; } int tmp = data [ from ] ; data [ from ] = data [ to ] ; data [ to ] = tmp ; }
tr	9	private int keyCode ( int code ) { switch ( code ) { case 37 : return Comm . VK_LEFT ; case 38 : return Comm . VK_UP ; case 39 : return Comm . VK_RIGHT ; case 40 : return Comm . VK_DOWN ; case 10 : return Comm . VK_ENTER ; case 27 : return Comm . VK_ESC ; case 32 : return Comm . VK_SPC ; case 8 : return Comm . VK_BCKSPC ; case 127 : return Comm . VK_DEL ; } return code ; }
tr	9	private boolean r_Step_4 ( ) { int among_var ; int v_1 ; ket = cursor ; among_var = find_among_b ( a_6 , 18 ) ; if ( among_var == 0 ) { return false ; } bra = cursor ; if ( ! r_R2 ( ) ) { return false ; } switch ( among_var ) { case 0 : return false ; case 1 : slice_del ( ) ; break ; case 2 : lab0 : do { v_1 = limit - cursor ; lab1 : do { if ( ! ( eq_s_b ( 1 , "s" ) ) ) { break lab1 ; } break lab0 ; } while ( false ) ; cursor = limit - v_1 ; if ( ! ( eq_s_b ( 1 , "t" ) ) ) { return false ; } } while ( false ) ; slice_del ( ) ; break ; } return true ; }
tr	9	public static void main ( String [ ] args ) { boolean all_right ; all_right = true ; int [ ] p0 ; int [ ] p1 ; int [ ] p2 ; int p3 ; double p4 ; p0 = new int [ ] { 0 } ; p1 = new int [ ] { 0 } ; p2 = new int [ ] { 5 } ; p3 = 10 ; p4 = 0.5D ; all_right = KawigiEdit_RunTest ( 0 , p0 , p1 , p2 , p3 , true , p4 ) && all_right ; p0 = new int [ ] { 0 } ; p1 = new int [ ] { 0 } ; p2 = new int [ ] { 10 } ; p3 = 10 ; p4 = 0.0D ; all_right = KawigiEdit_RunTest ( 1 , p0 , p1 , p2 , p3 , true , p4 ) && all_right ; p0 = new int [ ] { 10 } ; p1 = new int [ ] { 10 } ; p2 = new int [ ] { 10 } ; p3 = 10 ; p4 = 0.4142135623730951D ; all_right = KawigiEdit_RunTest ( 2 , p0 , p1 , p2 , p3 , true , p4 ) && all_right ; p0 = new int [ ] { 11 , - 11 , 0 , 0 } ; p1 = new int [ ] { 0 , 0 , 11 , - 11 } ; p2 = new int [ ] { 10 , 10 , 10 , 10 } ; p3 = 31 ; p4 = 0.3548387096774194D ; all_right = KawigiEdit_RunTest ( 3 , p0 , p1 , p2 , p3 , true , p4 ) && all_right ; p0 = new int [ ] { 100 } ; p1 = new int [ ] { 100 } ; p2 = new int [ ] { 1 } ; p3 = 10 ; p4 = 1.0D ; all_right = KawigiEdit_RunTest ( 4 , p0 , p1 , p2 , p3 , true , p4 ) && all_right ; p0 = new int [ ] { 1000000000 } ; p1 = new int [ ] { 1000000000 } ; p2 = new int [ ] { 1000000000 } ; p3 = 1000000000 ; p4 = 0.41421356237309503D ; all_right = KawigiEdit_RunTest ( 5 , p0 , p1 , p2 , p3 , true , p4 ) && all_right ; p0 = new int [ ] { 20 , - 20 , 0 , 0 } ; p1 = new int [ ] { 0 , 0 , 20 , - 20 } ; p2 = new int [ ] { 50 , 50 , 50 , 50 } ; p3 = 100 ; p4 = 0.3D ; all_right = KawigiEdit_RunTest ( 6 , p0 , p1 , p2 , p3 , true , p4 ) && all_right ; p0 = new int [ ] { 0 , - 60 , - 62 , - 60 , 63 , - 97 } ; p1 = new int [ ] { - 72 , 67 , 61 , - 8 , - 32 , 89 } ; p2 = new int [ ] { 6 , 7 , 8 , 7 , 5 , 6 } ; p3 = 918 ; p4 = 0.9407071068962471D ; all_right = KawigiEdit_RunTest ( 7 , p0 , p1 , p2 , p3 , true , p4 ) && all_right ; p0 = new int [ ] { - 187730043 , 932334096 , 59236807 , - 602044448 , 441157147 , 569003535 , 563472630 , 493784941 , - 928345136 , - 198534684 , - 507361726 , - 486699261 , - 705601684 , - 671249417 , - 79879427 , 71698248 , 146683444 , 414416326 , 53196305 , - 666818573 , 178619454 , - 893182413 , 224302710 , 296990194 , - 885921154 , - 173521881 , - 493092068 , 900325848 , - 353242967 , - 631482448 , 112982750 , 553248219 , 264762102 , - 318102799 , - 836641673 , - 812311860 , - 73259832 , 609869565 , 650010687 , 155243096 , - 107417345 , 634247427 , - 841502473 , - 651719520 , - 958664893 , 480384188 , - 691415372 , 36346544 , 706329659 , 126652235 , 44403422 , - 263265167 , - 349491074 , 120258505 , 485027199 , - 240466308 , - 456782932 , 192953958 , - 261803363 , - 198063552 , 980391799 , 997148607 , 417112854 , - 333017353 , - 945493557 , 371446553 , 251150037 , - 960076588 , - 360362805 , - 305175580 , 208353048 , - 437834549 , - 420355623 , - 668454094 , 180494692 , 755143595 , 249998094 , 537726369 , 343336414 , 495586169 , 35446018 , 131243302 , 501744441 , 739753520 , - 876687692 , 560013605 , - 443087342 , 455209428 , 333669368 , 398118304 , - 695213876 , 527566904 , - 463103162 , - 317355625 , 641069703 , - 947785900 , - 532490870 , - 963111776 , - 727898154 , 748858912 } ; p1 = new int [ ] { 452827103 , 247175647 , 11753377 , - 611873763 , - 531081305 , 859586805 , - 868286674 , - 876539858 , 304963335 , 990345765 , - 859353631 , - 475065113 , - 574709927 , 131112520 , - 846074893 , 464742988 , - 41360301 , 899849149 , - 266820064 , - 251052777 , 226747686 , 876712903 , - 350309643 , 131456902 , - 799664596 , 453822371 , - 617483392 , 755895436 , - 72097080 , 199834107 , - 619495741 , - 922106677 , 229012084 , 419002428 , 38711443 , 293733516 , 633211140 , - 65526196 , - 776215532 , - 491310115 , - 23818472 , 792447417 , 726536324 , - 686011537 , - 140383515 , - 569321731 , - 402939093 , - 125768005 , - 18416939 , 127783325 , - 67341991 , - 322587512 , - 296995968 , - 536590267 , 437613161 , - 206640690 , - 825549222 , 102733497 , - 399947312 , 55751657 , 527107031 , - 152726436 , - 821534503 , 267030010 , - 528297582 , - 897079824 , - 521362885 , 1225411 , 460297398 , 596603062 , - 270748768 , 211858545 , - 654848212 , - 353416243 , 955853430 , - 447642704 , 739273996 , - 118039293 , 583896289 , - 253276293 , 632398992 , 560349797 , 222539806 , 677153439 , - 804423594 , - 285780470 , 782032960 , 23986706 , - 812231058 , 344193048 , 491603558 , 956077657 , - 97237599 , - 644202406 , - 311702606 , 645844112 , 47834815 , - 802896183 , 472801824 , 658244534 } ; p2 = new int [ ] { 4 , 7 , 4 , 4 , 5 , 1 , 8 , 4 , 5 , 7 , 8 , 3 , 5 , 5 , 9 , 5 , 8 , 5 , 6 , 7 , 7 , 8 , 10 , 6 , 10 , 6 , 3 , 4 , 5 , 1 , 5 , 8 , 9 , 8 , 2 , 3 , 1 , 9 , 8 , 5 , 8 , 6 , 9 , 2 , 2 , 9 , 9 , 2 , 6 , 4 , 8 , 2 , 4 , 9 , 7 , 5 , 5 , 2 , 1 , 9 , 2 , 5 , 6 , 10 , 4 , 9 , 4 , 4 , 10 , 1 , 10 , 9 , 8 , 10 , 2 , 2 , 9 , 10 , 3 , 4 , 6 , 10 , 5 , 1 , 9 , 3 , 5 , 5 , 4 , 5 , 5 , 5 , 1 , 10 , 6 , 7 , 1 , 1 , 10 , 2 } ; p3 = 1000000000 ; p4 = 0.999999094D ; all_right = KawigiEdit_RunTest ( 7 , p0 , p1 , p2 , p3 , true , p4 ) && all_right ; p0 = new int [ ] { - 196 , 450 , 79 , - 220 , - 916 , 991 , - 451 , 462 , - 58 , - 353 , - 500 , 783 , 816 , 511 } ; p1 = new int [ ] { 188 , 681 , - 234 , - 330 , - 14 , 991 , - 969 , 347 , - 458 , - 940 , 454 , - 28 , 767 , - 620 } ; p2 = new int [ ] { 64 , 31 , 60 , 49 , 65 , 100 , 1 , 98 , 33 , 66 , 52 , 45 , 69 , 2 } ; p3 = 1484 ; p4 = 0.22007657635156566D ; all_right = KawigiEdit_RunTest ( 7 , p0 , p1 , p2 , p3 , true , p4 ) && all_right ; if ( all_right ) { System . out . println ( "You're a stud (at least on the example cases)!" ) ; } else { System . out . println ( "Some of the test cases had errors." ) ; } }
tr	3	public void requestNewPose ( ) { boolean continueToMakeNew = true ; if ( ! saved ) { continueToMakeNew = promptToSave ( ) ; } if ( continueToMakeNew ) { continueToMakeNew = promptForNew ( ) ; if ( continueToMakeNew ) { PoseurStateManager poseurStateManager = Poseur . getPoseur ( ) . getStateManager ( ) ; poseurStateManager . resetState ( ) ; poseurStateManager . setState ( PoseurState . SELECT_SHAPE_STATE ) ; } } }
tr	5	public Request < DescribeInstanceTypesRequest > marshall ( DescribeInstanceTypesRequest describeInstanceTypesRequest ) { if ( describeInstanceTypesRequest == null ) { throw new AmazonClientException ( "Invalid argument passed to marshall(...)" ) ; } Request < DescribeInstanceTypesRequest > request = new DefaultRequest < > ( describeInstanceTypesRequest , "AmazonEC2" ) ; request . addParameter ( "Action" , "DescribeInstanceTypes" ) ; request . addParameter ( "Version" , "2013-10-15" ) ; List < String > instanceTypesList = describeInstanceTypesRequest . getInstanceTypes ( ) ; int instanceTypesListIndex = 1 ; for ( String instanceTypesListValue : instanceTypesList ) { if ( instanceTypesListValue != null ) { request . addParameter ( "InstanceType." + instanceTypesListIndex , StringUtils . fromString ( instanceTypesListValue ) ) ; } instanceTypesListIndex ++ ; } if ( describeInstanceTypesRequest . getAvailability ( ) != null ) { request . addParameter ( "Availability" , StringUtils . fromBoolean ( describeInstanceTypesRequest . getAvailability ( ) ) ) ; } if ( describeInstanceTypesRequest . getVerbose ( ) != null ) { request . addParameter ( "Verbose" , StringUtils . fromBoolean ( describeInstanceTypesRequest . getVerbose ( ) ) ) ; } return request ; }
tr	0	public void setDescompte ( float descompte ) { this . descompte = descompte ; }
tr	5	public String createUser ( String user_data ) { User given_user = ( User ) unmarshall ( user_data , User . class ) ; ColourConnection . Users . User cc_user = new ColourConnection . Users . User ( ) ; int new_id = 1 ; List < ColourConnection . Users . User > user_list = cc_base . getUsers ( ) . getUser ( ) ; if ( given_user . getUsername ( ) . length ( ) == 0 ) return null ; for ( User curr_user : user_list ) { if ( curr_user . getUsername ( ) . equalsIgnoreCase ( given_user . getUsername ( ) ) ) return null ; } if ( user_list . size ( ) > 0 ) { ColourConnection . Users . User last_user = cc_base . getUsers ( ) . getUser ( ) . get ( user_list . size ( ) - 1 ) ; new_id = last_user . getId ( ) . intValue ( ) + 1 ; } cc_user . setId ( BigInteger . valueOf ( new_id ) ) ; cc_user . setUsername ( given_user . getUsername ( ) ) ; GregorianCalendar c = new GregorianCalendar ( ) ; c . setTime ( new Date ( ) ) ; XMLGregorianCalendar currGregCal ; try { currGregCal = DatatypeFactory . newInstance ( ) . newXMLGregorianCalendar ( c ) ; cc_user . setDateOfRegistration ( currGregCal ) ; } catch ( DatatypeConfigurationException e ) { } cc_user . setFavouriteColours ( new FavouriteColourList ( ) ) ; cc_user . setFavouriteColourpalettes ( new FavouriteColourPaletteList ( ) ) ; cc_user . setFollowers ( new Followers ( ) ) ; cc_user . setCreations ( new ColourPaletteList ( ) ) ; cc_base . getUsers ( ) . getUser ( ) . add ( cc_user ) ; marshall_cc ( ) ; return String . valueOf ( new_id ) ; }
tr	4	private void addTrackToDatabase ( Path path , String trackNumber , String artist , String title , String album , long milliseconds , String genre ) { AlbumBean trackAlbum = null ; TrackBean trackBean = null ; ArtistBean trackArtist = null ; for ( ArtistBean artistBean : artists ) { if ( artistBean . getName ( ) . equals ( artist ) ) { trackAlbum = artistBean . getAlbum ( album ) ; if ( trackAlbum == null ) { trackAlbum = new AlbumBean ( album ) ; } trackArtist = artistBean ; break ; } } if ( trackArtist == null ) { trackArtist = new ArtistBean ( artist ) ; artists . add ( trackArtist ) ; AllArtistsBean all = ( AllArtistsBean ) artists . get ( 0 ) ; all . setNumberOfArtists ( artists . size ( ) - 1 ) ; trackAlbum = new AlbumBean ( album ) ; } trackBean = new TrackBean ( path . toUri ( ) , trackNumber , artist , title , trackAlbum , new Duration ( milliseconds ) , genre ) ; trackArtist . addTrackToAlbum ( trackBean , trackAlbum ) ; }
tr	4	boolean handleResponse ( JmDNSImpl dns ) { ServiceInfoImpl info = ( ServiceInfoImpl ) dns . getServices ( ) . get ( name . toLowerCase ( ) ) ; if ( info != null && ( port != info . port || ! server . equalsIgnoreCase ( dns . getLocalHost ( ) . getName ( ) ) ) ) { logger . finer ( "handleResponse() Denial detected" ) ; if ( info . getState ( ) . isProbing ( ) ) { String oldName = info . getQualifiedName ( ) . toLowerCase ( ) ; info . setName ( dns . incrementName ( info . getName ( ) ) ) ; dns . getServices ( ) . remove ( oldName ) ; dns . getServices ( ) . put ( info . getQualifiedName ( ) . toLowerCase ( ) , info ) ; logger . finer ( "handleResponse() New unique name chose:" + info . getName ( ) ) ; } info . revertState ( ) ; return true ; } return false ; }
tr	2	private void drawBoard ( int deadFields ) { GUI . totalNumberOfMoves = 49 - deadFields ; Dimension boardSize = new Dimension ( 245 , 245 ) ; layeredPane = new JLayeredPane ( ) ; getContentPane ( ) . add ( layeredPane ) ; layeredPane . setPreferredSize ( boardSize ) ; layeredPane . addMouseListener ( this ) ; pahtumBoard = new JPanel ( ) ; layeredPane . add ( pahtumBoard , JLayeredPane . DEFAULT_LAYER ) ; GridLayout gridLayout = new GridLayout ( 7 , 7 ) ; gridLayout . setVgap ( 2 ) ; gridLayout . setHgap ( 2 ) ; pahtumBoard . setLayout ( gridLayout ) ; pahtumBoard . setPreferredSize ( boardSize ) ; pahtumBoard . setBounds ( 0 , 0 , boardSize . width , boardSize . height ) ; board = new Board ( 1 , true , deadFields ) ; String [ ] [ ] b = board . getState ( ) ; for ( int i = 0 ; i < 49 ; ++ i ) { JPanel square = new JPanel ( new BorderLayout ( ) ) ; pahtumBoard . add ( square ) ; if ( b [ i / 7 ] [ i % 7 ] . equals ( "x" ) ) { JLabel deadField = new JLabel ( new ImageIcon ( "/n/student/kg687/workspace/PahTum v3/img/deadFiled.jpg" ) ) ; square . add ( deadField ) ; } else { square . setBackground ( Color . getHSBColor ( 16 , 83 , 69 ) ) ; } } }
tr	9	@ Override public int compareTo ( Team o ) { if ( o == null ) { return - 1 ; } if ( points > o . points ) { return - 1 ; } else if ( points < o . points ) { return 1 ; } if ( noWins > o . noWins ) { return - 1 ; } else if ( noWins < o . noWins ) { return 1 ; } if ( goalDiff > o . goalDiff ) { return - 1 ; } else if ( goalDiff < o . goalDiff ) { return 1 ; } if ( noGoalsScored > o . noGoalsScored ) { return - 1 ; } else if ( noGoalsScored < o . noGoalsScored ) { return 1 ; } if ( noGamesPlayed < o . noGamesPlayed ) { return - 1 ; } else if ( noGamesPlayed > o . noGamesPlayed ) { return 1 ; } return name . toLowerCase ( ) . compareTo ( o . name . toLowerCase ( ) ) ; }
tr	0	public int getHpBase ( ) { return hpBase ; }
tr	7	private boolean r_main_suffix ( ) { int among_var ; int v_1 ; int v_2 ; v_1 = limit - cursor ; if ( cursor < I_p1 ) { return false ; } cursor = I_p1 ; v_2 = limit_backward ; limit_backward = cursor ; cursor = limit - v_1 ; ket = cursor ; among_var = find_among_b ( a_0 , 29 ) ; if ( among_var == 0 ) { limit_backward = v_2 ; return false ; } bra = cursor ; limit_backward = v_2 ; switch ( among_var ) { case 0 : return false ; case 1 : slice_del ( ) ; break ; case 2 : if ( ! ( in_grouping_b ( g_s_ending , 98 , 122 ) ) ) { return false ; } slice_del ( ) ; break ; case 3 : slice_from ( "er" ) ; break ; } return true ; }
tr	9	public void getModulus ( float [ ] realIO ) { int i , j , k , ir , j0 = 1 , idx = FFT_N_LOG - 1 ; float cosv , sinv , tmpr , tmpi ; for ( i = 0 ; i != FFT_N ; i ++ ) { real [ i ] = realIO [ bitReverse [ i ] ] ; imag [ i ] = 0 ; } for ( i = FFT_N_LOG ; i != 0 ; i -- ) { for ( j = 0 ; j != j0 ; j ++ ) { cosv = costable [ j << idx ] ; sinv = sintable [ j << idx ] ; for ( k = j ; k < FFT_N ; k += j0 << 1 ) { ir = k + j0 ; tmpr = cosv * real [ ir ] - sinv * imag [ ir ] ; tmpi = cosv * imag [ ir ] + sinv * real [ ir ] ; real [ ir ] = real [ k ] - tmpr ; imag [ ir ] = imag [ k ] - tmpi ; real [ k ] += tmpr ; imag [ k ] += tmpi ; } } j0 <<= 1 ; idx -- ; } j = FFT_N >> 1 ; sinv = MINY ; cosv = - MINY ; for ( i = j ; i != 0 ; i -- ) { tmpr = real [ i ] ; tmpi = imag [ i ] ; if ( tmpr > cosv && tmpr < sinv && tmpi > cosv && tmpi < sinv ) realIO [ i - 1 ] = 0 ; else realIO [ i - 1 ] = tmpr * tmpr + tmpi * tmpi ; } }
tr	3	public static int count123 ( String str ) { int szCount = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { char c = str . charAt ( i ) ; if ( c >= 0 && c <= 9 ) { szCount ++ ; } } return szCount ; }
tr	9	public < T > Iterator < T > asIterator ( final String tailApiUrl , final class < T > type ) { method ( "GET" ) ; if ( ! data . isEmpty ( ) ) { throw new IllegalStateException ( ) ; } return new Iterator < T > ( ) { T next ; URL url ; { try { url = root . getAPIUrl ( tailApiUrl ) ; } catch ( IOException e ) { throw new Error ( e ) ; } } @ Override public boolean hasNext ( ) { fetch ( ) ; if ( next != null && next . getClass ( ) . isArray ( ) ) { Object [ ] arr = ( Object [ ] ) next ; return arr . length != 0 ; } else { return next != null ; } } @ Override public T next ( ) { fetch ( ) ; T record = next ; if ( record == null ) { throw new NoSuchElementException ( ) ; } next = null ; return record ; } @ Override public void remove ( ) { throw new UnsupportedOperationException ( ) ; } private void fetch ( ) { if ( next != null ) { return ; } if ( url == null ) { return ; } try { HttpURLConnection connection = setupConnection ( url ) ; try { next = parse ( connection , type , null ) ; assert next != null ; findNextUrl ( ) ; } catch ( IOException e ) { handleAPIError ( e , connection ) ; } } catch ( IOException e ) { throw new Error ( e ) ; } } private void findNextUrl ( ) throws MalformedURLException { String url = this . url . toString ( ) ; this . url = null ; Matcher matcher = PAGE_PATTERN . matcher ( url ) ; if ( matcher . find ( ) ) { Integer page = Integer . parseInt ( matcher . group ( 2 ) ) + 1 ; this . url = new URL ( matcher . replaceAll ( matcher . group ( 1 ) + "page=" + page ) ) ; } else { if ( GitlabCommit [ ] . class == type ) { this . url = new URL ( url + ( url . indexOf ( ? ) > 0 ? & : ? ) + "page=1" ) ; } else { this . url = new URL ( url + ( url . indexOf ( ? ) > 0 ? & : ? ) + "&page=2" ) ; } } } } ; }
tr	4	@ Override public Pizza createPizza ( String type ) { Pizza pizza = null ; if ( type . equals ( "cheese" ) ) { pizza = new ChicagoStyleCheesePizza ( ) ; } else if ( type . equals ( "pepperoni" ) ) { pizza = new ChicagoStylePepperoniPizza ( ) ; } else if ( type . equals ( "clam" ) ) { pizza = new ChicagoStyleClamPizza ( ) ; } else if ( type . equals ( "veggie" ) ) { pizza = new ChicagoStyleVeggiePizza ( ) ; } return pizza ; }
tr	9	@ Override public boolean run ( ) { int i ; int j = - 1 ; int k ; int [ ] path ; int step ; int current = game . getCurPacManLoc ( ) ; if ( game . isJunction ( current ) ) { visitedJunctions . add ( current ) ; } int [ ] junction = game . getJunctionIndices ( ) ; int [ ] array ; ArrayList < Integer > list = new ArrayList < Integer > ( ) ; for ( i = 0 ; i < junction . length ; i ++ ) { list . add ( junction [ i ] ) ; } list . removeAll ( visitedJunctions ) ; boolean foundPath = false ; boolean foundGhost = false ; while ( ! foundPath && ! list . isEmpty ( ) ) { array = new int [ list . size ( ) ] ; for ( i = 0 ; i < array . length ; i ++ ) { array [ i ] = list . get ( i ) ; } j = game . getTarget ( current , array , true , Game . DM . PATH ) ; path = game . getPath ( current , j ) ; foundGhost = false ; for ( step = 0 ; step < path . length && ! foundGhost ; step ++ ) { for ( k = 0 ; k < Game . NUM_GHOSTS ; k ++ ) { int ghostDist = game . getGhostPathDistance ( k , path [ step ] ) ; int myDist = game . getPathDistance ( current , path [ step ] ) ; if ( ghostDist > 0 && ghostDist < MyPacMan . JUNC_DIST && ( ghostDist < myDist ) ) { foundGhost = true ; list . remove ( new Integer ( j ) ) ; break ; } } } foundPath = ! foundGhost ; } if ( foundPath ) { GameView . addPoints ( game , Color . LIGHT_GRAY , game . getPath ( current , j ) ) ; setTarget ( game . getNextPacManDir ( j , true , Game . DM . PATH ) ) ; return true ; } return false ; }
