tr	2	private static Object next ( Object prev , String ref ) throws JSONException { if ( prev == null ) { throw new JSONException ( "cannot traverse- missing object encountered" ) ; } if ( prev instanceof JSONObject ) { return ( ( JSONObject ) prev ) . get ( ref ) ; } throw new JSONException ( "not an object" ) ; }
tr	8	@ Override public int compare ( Card o1 , Card o2 ) { if ( o1 . isTrumpOrS ( trump ) && o2 . isTrumpOrS ( trump ) ) { return o1 . number . value - o2 . number . value ; } else if ( o1 . isTrumpOrS ( trump ) ) { return 1 ; } else if ( o2 . isTrumpOrS ( trump ) ) { return - 1 ; } else { if ( o1 . isDouble ( ) && o2 . isDouble ( ) ) { return o1 . number . value - o2 . number . value ; } else if ( o1 . isDouble ( ) ) { return 1 ; } else if ( o2 . isDouble ( ) ) { return - 1 ; } else { return 0 ; } } }
tr	2	private void whileChatting ( ) throws IOException { ableToType ( true ) ; do { try { message = ( String ) in . readObject ( ) ; displayMessage ( message , INCOMMINGMESSAGE ) ; } catch ( ClassNotFoundException classNotFoundException ) { displayMessage ( "Invalid Input" , MESSAGE ) ; } } while ( ! message . equals ( "SERVER - END" ) ) ; }
tr	0	public void setProdCodeGrp ( ProdCodeGrp value ) { this . prodCodeGrp = value ; }
tr	9	public IPv4 ( String symbolicIP , String netmask ) throws NumberFormatException { String [ ] st = symbolicIP . split ( "\\." ) ; if ( st . length != 4 ) throw new NumberFormatException ( "Invalid IP address: " + symbolicIP ) ; int i = 24 ; baseIPnumeric = 0 ; for ( int n = 0 ; n < st . length ; n ++ ) { int value = Integer . parseInt ( st [ n ] ) ; if ( value != ( value & ff ) ) { throw new NumberFormatException ( "Invalid IP address: " + symbolicIP ) ; } baseIPnumeric += value << i ; i -= 8 ; } st = netmask . split ( "\\." ) ; if ( st . length != 4 ) throw new NumberFormatException ( "Invalid netmask address: " + netmask ) ; i = 24 ; netmaskNumeric = 0 ; if ( Integer . parseInt ( st [ 0 ] ) < 255 ) { throw new NumberFormatException ( "The first byte of netmask can not be less than 255" ) ; } for ( int n = 0 ; n < st . length ; n ++ ) { int value = Integer . parseInt ( st [ n ] ) ; if ( value != ( value & ff ) ) { throw new NumberFormatException ( "Invalid netmask address: " + netmask ) ; } netmaskNumeric += value << i ; i -= 8 ; } boolean encounteredOne = false ; int ourMaskBitPattern = 1 ; for ( i = 0 ; i < 32 ; i ++ ) { if ( ( netmaskNumeric & ourMaskBitPattern ) != 0 ) { encounteredOne = true ; } else { if ( encounteredOne == true ) throw new NumberFormatException ( "Invalid netmask: " + netmask + " (bit " + ( i + 1 ) + ")" ) ; } ourMaskBitPattern = ourMaskBitPattern << 1 ; } }
tr	4	public static Monster createMonsterFromReader ( String monsterString ) { String [ ] values = monsterString . split ( " " ) ; Monster monster = new Monster ( ) ; try { monster . setName ( values [ 0 ] ) ; monster . setMaxHP ( Integer . parseInt ( values [ 1 ] ) ) ; monster . setCurrentHP ( Integer . parseInt ( values [ 1 ] ) ) ; monster . setNaturalAC ( Integer . parseInt ( values [ 2 ] ) ) ; monster . setStrength ( Integer . parseInt ( values [ 3 ] ) ) ; monster . setDexterity ( Integer . parseInt ( values [ 4 ] ) ) ; monster . setSpeed ( Integer . parseInt ( values [ 5 ] ) ) ; monster . setAttackBonus ( Integer . parseInt ( values [ 6 ] ) ) ; monster . setBaseDamage ( Integer . parseInt ( values [ 7 ] ) ) ; monster . setBaseMeleeDescription ( values [ 8 ] ) ; monster . setSightRange ( Integer . parseInt ( values [ 9 ] ) ) ; monster . setDifficulty ( Integer . parseInt ( values [ 10 ] ) ) ; if ( values . length == 12 && values [ 11 ] != "" ) { String [ ] specials = values [ 11 ] . split ( " " ) ; monster = Monster . applySpecialTraits ( monster , specials ) ; } monster . setInSight ( false ) ; } catch ( Exception e ) { System . out . println ( "Error reading monster object" ) ; if ( monster . getName ( ) != null ) System . out . println ( monster . getName ( ) + " has some incorrect parameter." ) ; return null ; } return monster ; }
tr	1	private static TermURIs getURISet ( ) { if ( _singleton == null ) { _singleton = new TermURIs ( ) ; } return _singleton ; }
tr	3	@ Override public void replace ( List < ? extends Individual > children , int [ ] parents , Population pop ) { int i = 0 ; for ( Individual ind : children ) { if ( i >= parents . length ) break ; pop . people [ parents [ i ++ ] ] = ind ; } }
tr	0	public Vector3D add ( Vector3D otherVector ) { return new Vector3D ( this . getX ( ) + otherVector . getX ( ) , this . getY ( ) + otherVector . getY ( ) , this . getZ ( ) + otherVector . getZ ( ) ) ; }
tr	0	private void initComponents ( ) { this . blackBox = new JPanel ( ) ; this . redBox = new JPanel ( ) ; this . blueBox = new JPanel ( ) ; this . greenBox = new JPanel ( ) ; this . yellowBox = new JPanel ( ) ; this . orangeBox = new JPanel ( ) ; this . letterLabel = new LetterPanel ( ) ; this . coloursPanel = new JPanel ( ) ; this . blackLabel = new JLabel ( ) ; this . redLabel = new JLabel ( ) ; this . greenLabel = new JLabel ( ) ; this . blueLabel = new JLabel ( ) ; this . yellowLabel = new JLabel ( ) ; this . orangeLabel = new JLabel ( ) ; this . coloursPanel . setLayout ( new GridBagLayout ( ) ) ; GridBagConstraints c = new GridBagConstraints ( ) ; c . gridx = 0 ; c . gridy = 0 ; c . insets = new Insets ( 5 , 5 , 5 , 5 ) ; this . coloursPanel . add ( blackBox , c ) ; c . gridx = 1 ; c . gridy = 0 ; this . coloursPanel . add ( blackLabel , c ) ; c . gridx = 0 ; c . gridy = 1 ; this . coloursPanel . add ( redBox , c ) ; c . gridx = 1 ; c . gridy = 1 ; this . coloursPanel . add ( redLabel , c ) ; c . gridx = 0 ; c . gridy = 2 ; this . coloursPanel . add ( greenBox , c ) ; c . gridx = 1 ; c . gridy = 2 ; this . coloursPanel . add ( greenLabel , c ) ; c . gridx = 2 ; c . gridy = 0 ; c . insets = new Insets ( 5 , 50 , 5 , 5 ) ; this . coloursPanel . add ( blueBox , c ) ; c . gridx = 3 ; c . gridy = 0 ; c . insets = new Insets ( 5 , 5 , 5 , 5 ) ; this . coloursPanel . add ( blueLabel , c ) ; c . gridx = 2 ; c . gridy = 1 ; c . insets = new Insets ( 5 , 50 , 5 , 5 ) ; this . coloursPanel . add ( yellowBox , c ) ; c . gridx = 3 ; c . gridy = 1 ; c . insets = new Insets ( 5 , 5 , 5 , 5 ) ; this . coloursPanel . add ( yellowLabel , c ) ; c . gridx = 2 ; c . gridy = 2 ; c . insets = new Insets ( 5 , 50 , 5 , 5 ) ; this . coloursPanel . add ( orangeBox , c ) ; c . gridx = 3 ; c . gridy = 2 ; c . insets = new Insets ( 5 , 5 , 5 , 5 ) ; this . coloursPanel . add ( orangeLabel , c ) ; this . setDefaultCloseOperation ( WindowConstants . EXIT_ON_CLOSE ) ; this . blackBox . setBackground ( SystemProperties . COLOUR_MAP . get ( ColourType . BLACK ) ) ; this . blackBox . setBorder ( BorderFactory . createLineBorder ( new java . awt . Color ( 0 , 0 , 0 ) ) ) ; this . blackBox . setPreferredSize ( new Dimension ( 30 , 30 ) ) ; this . redBox . setBackground ( SystemProperties . COLOUR_MAP . get ( ColourType . RED ) ) ; this . redBox . setBorder ( BorderFactory . createLineBorder ( new java . awt . Color ( 0 , 0 , 0 ) ) ) ; this . redBox . setPreferredSize ( new Dimension ( 30 , 30 ) ) ; this . greenBox . setBackground ( SystemProperties . COLOUR_MAP . get ( ColourType . GREEN ) ) ; this . greenBox . setBorder ( BorderFactory . createLineBorder ( new java . awt . Color ( 0 , 0 , 0 ) ) ) ; this . greenBox . setPreferredSize ( new Dimension ( 30 , 30 ) ) ; this . blueBox . setBackground ( SystemProperties . COLOUR_MAP . get ( ColourType . BLUE ) ) ; this . blueBox . setBorder ( BorderFactory . createLineBorder ( new java . awt . Color ( 0 , 0 , 0 ) ) ) ; this . blueBox . setPreferredSize ( new Dimension ( 30 , 30 ) ) ; this . yellowBox . setBackground ( SystemProperties . COLOUR_MAP . get ( ColourType . YELLOW ) ) ; this . yellowBox . setBorder ( BorderFactory . createLineBorder ( new java . awt . Color ( 0 , 0 , 0 ) ) ) ; this . yellowBox . setPreferredSize ( new Dimension ( 30 , 30 ) ) ; this . orangeBox . setBackground ( SystemProperties . COLOUR_MAP . get ( ColourType . ORANGE ) ) ; this . orangeBox . setBorder ( BorderFactory . createLineBorder ( new java . awt . Color ( 0 , 0 , 0 ) ) ) ; this . orangeBox . setPreferredSize ( new Dimension ( 30 , 30 ) ) ; this . letterLabel . setBackground ( SystemProperties . WHITE ) ; this . letterLabel . setBorder ( BorderFactory . createLineBorder ( new java . awt . Color ( 0 , 0 , 0 ) ) ) ; this . blackLabel . setText ( "s" ) ; this . blackLabel . setFont ( new Font ( "Arial" , Font . PLAIN , 28 ) ) ; this . redLabel . setText ( "r" ) ; this . redLabel . setFont ( new Font ( "Arial" , Font . PLAIN , 28 ) ) ; this . greenLabel . setText ( "g" ) ; this . greenLabel . setFont ( new Font ( "Arial" , Font . PLAIN , 28 ) ) ; this . blueLabel . setText ( "b" ) ; this . blueLabel . setFont ( new Font ( "Arial" , Font . PLAIN , 28 ) ) ; this . yellowLabel . setText ( "y" ) ; this . yellowLabel . setFont ( new Font ( "Arial" , Font . PLAIN , 28 ) ) ; this . orangeLabel . setText ( "o" ) ; this . orangeLabel . setFont ( new Font ( "Arial" , Font . PLAIN , 28 ) ) ; this . setJMenuBar ( stroopMenu ) ; this . add ( this . letterLabel , BorderLayout . CENTER ) ; this . add ( this . coloursPanel , BorderLayout . SOUTH ) ; this . setTitle ( "Stroop Test" ) ; this . addComponentListener ( this ) ; this . setPreferredSize ( new Dimension ( 800 , 600 ) ) ; this . setLocation ( ( SystemProperties . SCREEN_WIDTH / 2 ) - 400 , ( SystemProperties . SCREEN_HEIGHT / 2 ) - 300 ) ; this . pack ( ) ; }
tr	9	public static Method getAsMethodOfPublicBase ( class < ? > c , Method m ) { for ( class < ? > iface : c . getInterfaces ( ) ) { for ( Method im : iface . getMethods ( ) ) { if ( isMatch ( im , m ) ) { return im ; } } } class < ? > sc = c . getSuperclass ( ) ; if ( sc == null ) { return null ; } for ( Method scm : sc . getMethods ( ) ) { if ( isMatch ( scm , m ) ) { return scm ; } } return getAsMethodOfPublicBase ( sc , m ) ; }
tr	6	public CoverDetails getSelectedAt ( int x , int y ) { for ( CoverDetails cd : covers ) { if ( ! editMode && cd . isHidden ( ) ) { continue ; } if ( ! cd . isPartOfOtherCover ( ) && cd . getX ( ) == x && cd . getY ( ) == y ) { return cd ; } } return null ; }
tr	1	public Object1 method296 ( int i , int j , int k ) { Ground class30_sub3 = groundArray [ i ] [ j ] [ k ] ; if ( class30_sub3 == null ) return null ; else return class30_sub3 . obj1 ; }
tr	0	public void setArmour ( String armour ) { this . armour = armour ; }
tr	9	private void handleProjectileCollisions ( HashSet < Projectile > destroyedProjectiles ) { boolean destroyed ; for ( Projectile p : projectiles ) { p . clearCollidedWith ( ) ; destroyed = false ; for ( LandscapeGameObject l : landscape ) { if ( p . collidesWith ( l ) ) { p . addCollision ( l ) ; destroyed = destroyed || p . handleCollision ( l ) ; } } for ( Tank t : tanks ) { if ( p . collidesWith ( t ) ) { p . addCollision ( t ) ; destroyed = true ; } } for ( Projectile p2 : projectiles ) { if ( p . collidesWith ( p2 ) ) { p . addCollision ( p2 ) ; destroyed = destroyed || p . handleCollision ( p2 ) ; } } if ( destroyed ) { destroyedProjectiles . add ( p ) ; } } }
tr	1	public void destroy ( ) { game . stopLWJGL ( ) ; if ( display_parent != null ) remove ( display_parent ) ; super . destroy ( ) ; }
tr	1	public String getFile ( ) { if ( file == null ) return null ; else return file . getName ( ) ; }
tr	8	private static void parseCommandLine ( String [ ] args ) throws IOException , NumberFormatException { for ( String arg : args ) { String [ ] vals = arg . split ( "=" , 2 ) ; String key = vals [ 0 ] . trim ( ) ; String value = vals [ 1 ] . trim ( ) ; if ( key . equals ( "--mode" ) || key . equals ( "-mode" ) ) { try { MODE = Mode . valueOf ( value . toUpperCase ( ) ) ; } catch ( IllegalArgumentException e ) { } } else if ( key . equals ( "--port" ) || key . equals ( "-port" ) ) { PORT = Integer . parseInt ( value ) ; } else if ( key . equals ( "--options" ) || key . equals ( "-options" ) ) { Options . initialize ( value ) ; } } }
tr	8	@ Override public void expand ( int grabber , Point endMove , int canvasWidth , int canvasHeight ) { if ( ( ( endMove . getX ( ) ) > 0 ) && ( ( endMove . getY ( ) ) > 0 ) && ( ( endMove . getX ( ) ) < canvasWidth ) && ( ( endMove . getY ( ) ) < canvasHeight ) ) { Point startMove = new Point ( ) ; switch ( grabber ) { case 0 : startMove = new Point ( ( int ) x , ( int ) y ) ; width += ( startMove . getX ( ) - endMove . getX ( ) ) ; height += ( startMove . getY ( ) - endMove . getY ( ) ) ; x = endMove . getX ( ) ; y = endMove . getY ( ) ; break ; case 1 : startMove = new Point ( ( int ) ( x + width ) , ( int ) y ) ; width += ( endMove . getX ( ) - startMove . getX ( ) ) ; height += ( startMove . getY ( ) - endMove . getY ( ) ) ; x = endMove . getX ( ) - width ; y = endMove . getY ( ) ; break ; case 2 : startMove = new Point ( ( int ) x , ( int ) ( y + height ) ) ; width += ( startMove . getX ( ) - endMove . getX ( ) ) ; height += ( endMove . getY ( ) - startMove . getY ( ) ) ; x = endMove . getX ( ) ; y = endMove . getY ( ) - height ; break ; case 3 : { startMove = new Point ( ( int ) ( x + width ) , ( int ) ( y + height ) ) ; width += ( endMove . getX ( ) - startMove . getX ( ) ) ; height += ( endMove . getY ( ) - startMove . getY ( ) ) ; x = endMove . getX ( ) - width ; y = endMove . getY ( ) - height ; break ; } } } }
tr	8	private boolean r_tidy_up ( ) { int among_var ; ket = cursor ; among_var = find_among_b ( a_7 , 4 ) ; if ( among_var == 0 ) { return false ; } bra = cursor ; switch ( among_var ) { case 0 : return false ; case 1 : slice_del ( ) ; ket = cursor ; if ( ! ( eq_s_b ( 1 , "\u043D" ) ) ) { return false ; } bra = cursor ; if ( ! ( eq_s_b ( 1 , "\u043D" ) ) ) { return false ; } slice_del ( ) ; break ; case 2 : if ( ! ( eq_s_b ( 1 , "\u043D" ) ) ) { return false ; } slice_del ( ) ; break ; case 3 : slice_del ( ) ; break ; } return true ; }
tr	9	public static String nullSafeToString ( Object obj ) { if ( obj == null ) { return NULL_STRING ; } if ( obj instanceof String ) { return ( String ) obj ; } if ( obj instanceof Object [ ] ) { return nullSafeToString ( ( Object [ ] ) obj ) ; } if ( obj instanceof boolean [ ] ) { return nullSafeToString ( ( boolean [ ] ) obj ) ; } if ( obj instanceof byte [ ] ) { return nullSafeToString ( ( byte [ ] ) obj ) ; } if ( obj instanceof char [ ] ) { return nullSafeToString ( ( char [ ] ) obj ) ; } if ( obj instanceof double [ ] ) { return nullSafeToString ( ( double [ ] ) obj ) ; } if ( obj instanceof float [ ] ) { return nullSafeToString ( ( float [ ] ) obj ) ; } if ( obj instanceof int [ ] ) { return nullSafeToString ( ( int [ ] ) obj ) ; } if ( obj instanceof long [ ] ) { return nullSafeToString ( ( long [ ] ) obj ) ; } if ( obj instanceof short [ ] ) { return nullSafeToString ( ( short [ ] ) obj ) ; } String str = obj . toString ( ) ; return ( str != null ? str : EMPTY_STRING ) ; }
tr	3	public void recevoirMessagePriveAbsence ( ) { try { TreeMap < String , ArrayList < MessagePrive >> mapUtilisateur = getServeurRmiImpl ( ) . getMapMessagesPrivesUtilisateur ( getUtilisateur ( ) . getLogin ( ) ) ; Set cles = mapUtilisateur . keySet ( ) ; Iterator it = cles . iterator ( ) ; while ( it . hasNext ( ) ) { ArrayList < MessagePrive > messages = mapUtilisateur . get ( it . next ( ) ) ; for ( Message m : messages ) { recevoirMessage ( m ) ; } } getServeurRmiImpl ( ) . getMessagesPrivesUtilisateurs ( ) . remove ( this . getUtilisateur ( ) . getLogin ( ) ) ; } catch ( RemoteException e ) { e . printStackTrace ( ) ; } }
tr	0	public String getDate ( ) { return date ; }
tr	7	public Contact [ ] resize ( int currentSize , Integer capacity , Contact [ ] c ) { Contact [ ] copy ; if ( capacity == null ) { int j = 0 ; while ( j < c . length ) { if ( c [ j ] == null ) break ; j ++ ; } copy = new Contact [ j ] ; for ( int i = 0 ; i < copy . length ; i ++ ) { copy [ i ] = c [ i ] ; } return copy ; } copy = new Contact [ capacity ] ; if ( capacity > currentSize ) { for ( int i = 0 ; i < currentSize ; i ++ ) { copy [ i ] = c [ i ] ; } } else { for ( int i = 0 ; i < capacity ; i ++ ) { copy [ i ] = c [ i ] ; } } return copy ; }
tr	7	@ Override protected void doInBackground ( ) { final int BUFFER_SIZE = 1024 ; BufferedInputStream bis = null ; ByteArrayOutputStream baos = null ; try { URL url = new URL ( imageUrl ) ; HttpURLConnection connection = ( HttpURLConnection ) url . openConnection ( ) ; connection . setRequestProperty ( "User-Agent" , "User-Agent: Mozilla/5.0 (Windows NT 6.1; rv:27.0) Gecko/20100101 Firefox/27.0" ) ; this . totalProgressValue = connection . getContentLength ( ) ; int totalDataRead = 0 ; bis = new BufferedInputStream ( connection . getInputStream ( ) ) ; baos = new ByteArrayOutputStream ( ) ; try ( BufferedOutputStream bos = new BufferedOutputStream ( baos , BUFFER_SIZE ) ) { byte [ ] data = new byte [ BUFFER_SIZE ] ; int i = 0 ; while ( ( i = bis . read ( data ) ) != - 1 ) { totalDataRead = totalDataRead + i ; baos . write ( data , 0 , i ) ; publish ( new SyncTaskState ( rule , imageUrl , "Downloading" , totalDataRead ) ) ; } publish ( new SyncTaskState ( rule , imageUrl , "Processing" , this . totalProgressValue ) ) ; byte [ ] imageBytes = baos . toByteArray ( ) ; try { byte [ ] imageSteganoBytes = ImageUtils . tryToDecodeSteganoImage ( imageBytes , boardCode ) ; if ( imageSteganoBytes != null ) { try { NanoPost np = NanoPostFactory . getNanoPostFromBytes ( imageSteganoBytes , false ) ; np . setSourceImageData ( imageBytes ) ; if ( ! np . isAlreadyDownloaded ( ) ) { publish ( new SyncTaskState ( rule , imageUrl , "NEW NANOPOST" , this . totalProgressValue ) ) ; np . setOutbox ( false ) ; np . saveToFile ( false ) ; } else { publish ( new SyncTaskState ( rule , imageUrl , "IN SYNC" , this . totalProgressValue ) ) ; } imageSteganoBytes = null ; imageBytes = null ; np . clearAllBinaryData ( ) ; nbf . addNanoPostToList ( np ) ; } catch ( IOException | MalformedNanoPostException ex ) { publish ( new SyncTaskState ( rule , imageUrl , "Not an NanoPost" , this . totalProgressValue ) ) ; } } else { publish ( new SyncTaskState ( rule , imageUrl , "Not an NanoPost" , this . totalProgressValue ) ) ; } } catch ( Exception ex ) { publish ( new SyncTaskState ( rule , imageUrl , "Not an NanoPost" , this . totalProgressValue ) ) ; } } } catch ( IOException ex ) { ex . printStackTrace ( ) ; publish ( new SyncTaskState ( rule , imageUrl , "IO Error" , 0 ) ) ; } finally { try { bis . close ( ) ; } catch ( IOException ex ) { publish ( new SyncTaskState ( rule , imageUrl , "IO Error" , 0 ) ) ; } } return null ; }
tr	4	protected void setFontVariant ( String newFontVariant ) { if ( fontVariant == null || ! fontVariant . equals ( newFontVariant ) ) { FontVariant val [ ] = FontVariant . values ( ) ; for ( FontVariant aVal : val ) { if ( aVal . toString ( ) . equals ( newFontVariant ) ) { fontVariant = newFontVariant ; invalidateCache ( ) ; return ; } } } }
tr	1	public void addServiceTypeListener ( ServiceTypeListener listener ) throws IOException { synchronized ( this ) { typeListeners . remove ( listener ) ; typeListeners . add ( listener ) ; } for ( final Iterator iterator = serviceTypes . values ( ) . iterator ( ) ; iterator . hasNext ( ) ; ) { listener . serviceTypeAdded ( new ServiceEventImpl ( this , ( String ) iterator . next ( ) , null , null ) ) ; } new TypeResolver ( this ) . start ( timer ) ; }
tr	7	public static void knapsackBits ( int [ ] weights , int [ ] values , long maxWeight ) { int n = weights . length ; long numSets = ( long ) Math . pow ( 2 , n ) ; long bestSet = 0 ; long bestValue = 0 ; long bestWeight = 0 ; for ( long set = 1 ; set < numSets ; set ++ ) { long weight = 0 ; long value = 0 ; for ( int i = 0 ; i < 64 ; i ++ ) { if ( ( ( set >> i ) & 1 ) == 1 ) { weight += weights [ i ] ; value += values [ i ] ; } } if ( weight <= maxWeight && value > bestValue ) { bestValue = value ; bestWeight = weight ; bestSet = set ; } } for ( int i = 0 ; i < 64 ; i ++ ) { if ( ( ( bestSet >> i ) & 1 ) == 1 ) { System . out . print ( "[i=" + i + "  w=" + weights [ i ] + "  v=" + values [ i ] + "] " ) ; } } System . out . println ( ) ; System . out . println ( "Weight = " + bestWeight + "  Value = " + bestValue ) ; }
tr	5	@ Override public void mutate ( ) { Population offspring = new Population ( ) ; for ( int i = 0 ; i < population . getSize ( ) ; ++ i ) { double r ; synchronized ( rng ) { r = rng . nextDouble ( ) ; } if ( r < PROBABILITY ) { HiffIndividual mutant = new HiffIndividual ( population . getIndividual ( i ) ) ; int possition ; synchronized ( rng ) { possition = Math . abs ( rng . nextInt ( ) ) % mutant . getSize ( ) ; } mutant . inverse ( possition ) ; offspring . addIndividual ( mutant ) ; } else { offspring . addIndividual ( new HiffIndividual ( population . getIndividual ( i ) ) ) ; } } double bestOld = population . getFittest ( ) ; double bestNew = offspring . getFittest ( ) ; if ( bestNew > bestOld ) { reward = 1 ; for ( int i = 0 ; i < population . getSize ( ) ; ++ i ) { population . setIndividual ( i , offspring . getIndividual ( i ) ) ; } } else if ( bestNew == bestOld ) { reward = 0 ; } else { reward = 0 ; } }
tr	3	public void write_ref ( final String node , final int [ ] ids , final int creation ) { int arity = ids . length ; if ( arity > 3 ) { arity = 3 ; } if ( arity == 1 ) { this . write_ref ( node , ids [ 0 ] , creation ) ; } else { write1 ( OtpExternal . newRefTag ) ; write2BE ( arity ) ; write_atom ( node ) ; write1 ( creation & 3 ) ; write4BE ( ids [ 0 ] & 3ffff ) ; for ( int i = 1 ; i < arity ; i ++ ) { write4BE ( ids [ i ] ) ; } } }
tr	1	public static int [ ] getRoutes ( int busStop ) { if ( busStop == 0 ) throw new InvalidQueryException ( "Nonexistent bus stop" ) ; return database . busDatabase . select_ids ( "route" , "path" , "bus_stop" , busStop , "" ) ; }
tr	1	private int initialize ( ) { int noOfIntReg = IntRegC . values ( ) . length ; for ( int index = 0 ; index < noOfIntReg ; index ++ ) { IntegerRegister intReg = new IntegerRegister ( "0" , IntRegC . values ( ) [ index ] . toString ( ) ) ; intRegBank . add ( intReg ) ; } return 0 ; }
tr	1	@ Override public int getColumnAmount ( ) { if ( this . optionTextFields [ 1 ] . getText ( ) . equals ( "" ) ) return 0 ; return Integer . parseInt ( this . optionTextFields [ 1 ] . getText ( ) ) ; }
tr	8	public JSONArray ( JSONTokener x ) throws JSONException { this ( ) ; if ( x . nextClean ( ) != [ ) { throw x . syntaxError ( "A JSONArray text must start with '['" ) ; } if ( x . nextClean ( ) != ] ) { x . back ( ) ; for ( ; ; ) { if ( x . nextClean ( ) ==   ) { x . back ( ) ; this . myArrayList . add ( JSONObject . null ) ; } else { x . back ( ) ; this . myArrayList . add ( x . nextValue ( ) ) ; } switch ( x . nextClean ( ) ) { case ; : case   : if ( x . nextClean ( ) == ] ) { return ; } x . back ( ) ; break ; case ] : return ; default : throw x . syntaxError ( "Expected a ' ' or ']'" ) ; } } } }
tr	8	public void parseJson ( String fileName ) { try { InputStream is = new FileInputStream ( fileName ) ; JsonParser parser = Json . createParser ( is ) ; while ( parser . hasNext ( ) ) { Event event = parser . next ( ) ; switch ( event ) { case KEY_NAME : parser . getString ( ) ; break ; case VALUE_STRING : break ; case VALUE_NUMBER : break ; case VALUE_FALSE : break ; case VALUE_TRUE : break ; case VALUE_NULL : break ; default : } } } catch ( FileNotFoundException ex ) { System . out . println ( ex ) ; } }
tr	0	public Graph ( ) { this . keyToNode = new HashMap < > ( ) ; this . nodes = new HashSet < > ( ) ; }
tr	0	public int getCodigo ( ) { return codigo ; }
tr	3	public static int getPedidosNatural ( Perfil perfil ) throws SQLException { if ( perfil != null ) { sql = "SELECT SUM(CANTIDAD) " + "FROM CLIENTES_REMITOS INNER JOIN CLIENTES_DETALLE_REMITO ON " + "CLIENTES_REMITOS.IDREMITO = CLIENTES_DETALLE_REMITO.IDREMITO " + "WHERE (((CLIENTES_REMITOS.TIPODOC)=1 Or (CLIENTES_REMITOS.TIPODOC)=4) AND " + "((CLIENTES_REMITOS.ENTREGADO)=False) AND " + "((CLIENTES_DETALLE_REMITO.ACT_STOCK)=False) AND " + "(COLOR = {COLOR}) AND (IDPERFIL = '{PERFIL}' ));" ; sql = sql . replace ( "{COLOR}" , Integer . toString ( ColorDP . ID_NATURAL ) ) ; sql = sql . replace ( "{PERFIL}" , perfil . getIdperf ( ) ) ; try ( ResultSet rs = ComunDP . getData ( sql ) ) { if ( rs != null && rs . next ( ) ) { return rs . getInt ( 1 ) ; } } } return 0 ; }
tr	4	SyntaxError ( Cursor c , Type errorType , String arg ) { super ( String . format ( errorType . format , arg ) ) ; this . type = errorType ; this . arg = arg ; this . sourceText = c . originalText ; this . index = c . index ; int lines = 1 ; int chars = 0 ; StringBuilder line = new StringBuilder ( ) ; for ( int z = 0 ; z < index ; z ++ ) { if ( sourceText . charAt ( z ) == '' ) { lines ++ ; chars = 0 ; line = new StringBuilder ( ) ; } else { chars ++ ; line . append ( sourceText . charAt ( z ) ) ; } } for ( int z = index ; z < sourceText . length ( ) ; z ++ ) { if ( sourceText . charAt ( z ) == '' ) { break ; } line . append ( sourceText . charAt ( z ) ) ; } this . lineNumber = lines ; this . lineIndex = chars ; this . line = line . toString ( ) ; }
tr	8	@ Override public void run ( ) { repaint ( ) ; }
tr	5	public static Set < Cliente > getClientesPedidosColores ( Set < Color > colores ) { Set < Cliente > l = new HashSet < > ( ) ; try { sql = "SELECT DISTINCT (CLIENTES_REMITOS.IDCLIENTE) AS IDCLIENTE " + "FROM CLIENTES_REMITOS INNER JOIN CLIENTES_DETALLE_REMITO ON " + "CLIENTES_REMITOS.IDREMITO = CLIENTES_DETALLE_REMITO.IDREMITO " + "WHERE (((CLIENTES_REMITOS.TIPODOC)=1 Or (CLIENTES_REMITOS.TIPODOC)=4) AND " + "((CLIENTES_REMITOS.ENTREGADO)=False) AND " + "((CLIENTES_DETALLE_REMITO.ACT_STOCK)=False) AND ( " ; String tmp = "" ; for ( Color color : colores ) { tmp = tmp + Integer . toString ( color . getId ( ) ) + "  " ; } tmp = tmp . substring ( 0 , tmp . length ( ) - 2 ) ; sql = sql + " CLIENTES_DETALLE_REMITO.COLOR IN (" + tmp + ")" ; sql = sql + "));" ; try ( ResultSet rs = ComunDP . getData ( sql ) ) { if ( rs != null ) { while ( rs . next ( ) ) { Cliente cliente = ClienteDP . getOne ( rs . getInt ( "IDCLIENTE" ) ) ; if ( cliente != null ) { l . add ( cliente ) ; } } } } } catch ( SQLException ex ) { Utils . showError ( "Error..." , "Error al buscar clientes con pedidos por colores.\nERROR: " + ex . getMessage ( ) + "\nSQL State: " + ex . getSQLState ( ) ) ; } return l ; }
tr	5	private void init ( final String mapPath , final Properties props ) { this . props = props ; if ( props . get ( "walls" ) != null ) { walls = getIntegers ( props , "walls" , # ) ; } if ( props . get ( "floors" ) != null ) { standardGrounds = getIntegers ( props , "floors" , . ) ; } if ( props . get ( "corridor_floors" ) != null ) { corridorFloors = getIntegers ( props , "corridor_floors" , . ) ; } if ( props . get ( "room_floors" ) != null ) { roomFloors = getIntegers ( props , "room_floors" , . ) ; } if ( props . get ( "room_features" ) != null ) { roomFeatures = getIntegers ( props , "room_features" , . ) ; } roomWidthMin = getInt ( props , "room_width_min" , roomWidthMin ) ; roomHeightMin = getInt ( props , "room_height_min" , roomHeightMin ) ; roomWidthMax = getInt ( props , "room_width_max" , roomWidthMax ) ; roomHeightMax = getInt ( props , "room_height_max" , roomHeightMax ) ; roomGapHoriz = getInt ( props , "room_gap_horiz" , roomGapHoriz ) ; roomGapVert = getInt ( props , "room_gap_vert" , roomGapVert ) ; corridorWidth = getInt ( props , "corridor_width" , corridorWidth ) ; hiddenWall = getInt ( props , "hidden_wall" , hiddenWall ) ; outsideFloor = getInt ( props , "outside_floor" , outsideFloor ) ; stairsUp = getInt ( props , "stairs_up" , stairsUp ) ; door = getInt ( props , "door" , door ) ; damagedFloorChance = getInt ( props , "damaged_floor_chance" , damagedFloorChance ) ; viewRadius = getInt ( props , "view_radius" , viewRadius ) ; mapLayers = Math . max ( getInt ( props , "map_layers" , mapLayers ) , 2 ) ; }
tr	4	public void clearMap ( GameAction gameAction ) { for ( int i = 0 ; i < keyActions . length ; i ++ ) { if ( keyActions [ i ] == gameAction ) { keyActions [ i ] = null ; } } for ( int i = 0 ; i < mouseActions . length ; i ++ ) { if ( mouseActions [ i ] == gameAction ) { mouseActions [ i ] = null ; } } gameAction . reset ( ) ; }
tr	1	@ Override public void done ( Object data , FlickrException ex ) { if ( data != null ) { setButton . setText ( null ) ; setButton . setIcon ( new ImageIcon ( ( Image ) data ) ) ; } }
tr	3	public void refreshTextList ( ) { ground . remove ( textpane ) ; textpane = null ; resultSets = connector . getAllResultSets ( userID ) ; Iterator < ? > result = resultSets . iterator ( ) ; dataname . clear ( ) ; if ( result != null ) { while ( result . hasNext ( ) ) { ResultSet temp_res = ( ResultSet ) result . next ( ) ; resultmapper . put ( temp_res . getDocument ( ) . getFileName ( ) , ( ResultSet ) temp_res ) ; dataname . addElement ( temp_res . getDocument ( ) . getFileName ( ) ) ; } textpane = new JScrollPane ( texte ) ; textpane . setLocation ( 280 , 50 ) ; textpane . setSize ( 180 , 300 ) ; textpane . setVisible ( true ) ; texte . setVisible ( true ) ; ground . add ( textpane ) ; textpane . repaint ( ) ; ground . repaint ( ) ; } }
tr	2	public String collectAndReset ( String timeStamp ) { StringBuffer sb = new StringBuffer ( ) ; sb . append ( "<" ) . append ( name ) . append ( ">" ) ; double mean ; double dispersion ; for ( Map . Entry < String , Map < String , double >> entry : mappedValues . entrySet ( ) ) { mean = getMean ( entry . getValue ( ) ) ; dispersion = getDispersion ( entry . getValue ( ) , mean ) ; sb . append ( "<" ) . append ( entry . getKey ( ) ) ; sb . append ( " mean=\"" ) . append ( mean ) ; sb . append ( "\" disp=\"" ) . append ( dispersion ) . append ( "\"/>" ) ; } sb . append ( "</" ) . append ( name ) . append ( ">" ) ; for ( Map < String , double > innerObservation : mappedValues . values ( ) ) { innerObservation . clear ( ) ; } mappedValues . clear ( ) ; return sb . toString ( ) ; }
tr	9	@ SuppressWarnings ( "static-access" ) public static void iniServer ( String [ ] args ) { String ip = "" ; try { ip = InetAddress . getLocalHost ( ) . getHostAddress ( ) . toString ( ) ; } catch ( UnknownHostException e1 ) { e1 . printStackTrace ( ) ; } ip = "127.0.0.1" ; Utilitaires . out ( "Votre IP est : " + ip ) ; Options options = new Options ( ) ; options . addOption ( "h" , "help" , false , "prints the help content" ) ; options . addOption ( OptionBuilder . withArgName ( "serveur" ) . hasArg ( ) . withDescription ( "ip du serveur 0" ) . create ( "I" ) ) ; options . addOption ( OptionBuilder . withArgName ( "port du serveur" ) . hasArg ( ) . withDescription ( "port du serveur 0" ) . create ( "P" ) ) ; options . addOption ( OptionBuilder . withArgName ( "debug" ) . hasArg ( ) . withDescription ( "Active le mode debuggage. Doit etre suivi d'un identifiant unique sur la machine" ) . create ( "d" ) ) ; options . addOption ( OptionBuilder . withArgName ( "port" ) . hasArg ( ) . withDescription ( "port de fonctionnement" ) . create ( "p" ) ) ; options . addOption ( OptionBuilder . withArgName ( "first node" ) . withDescription ( "si le serveur est le premier" ) . create ( "t" ) ) ; try { CommandLineParser parser = new GnuParser ( ) ; CommandLine cmd = parser . parse ( options , args ) ; if ( cmd . hasOption ( "p" ) ) { Global . TCP_PORT = Integer . parseInt ( ( cmd . getOptionValue ( "p" ) ) ) ; Global . CLIENTPRPORT = Global . TCP_PORT + 1 ; Global . SERVERPRPORT = Global . CLIENTPRPORT + 1 ; } if ( cmd . hasOption ( "t" ) ) { Global . FIRST_IP = "none#" ; Utilitaires . out ( "Je suis le serveur de base !" ) ; } if ( cmd . hasOption ( "I" ) ) Global . FIRST_IP = cmd . getOptionValue ( "I" ) ; if ( cmd . hasOption ( "P" ) ) Global . FIRST_PORT = Integer . parseInt ( cmd . getOptionValue ( "P" ) ) ; if ( cmd . hasOption ( "d" ) ) { Global . NOM = Integer . parseInt ( cmd . getOptionValue ( "d" ) ) ; Global . DEBUG = true ; } if ( cmd . hasOption ( "h" ) ) { HelpFormatter formatter = new HelpFormatter ( ) ; formatter . printHelp ( "Server" , options ) ; } } catch ( MissingOptionException e ) { boolean help = false ; try { Options helpOptions = new Options ( ) ; helpOptions . addOption ( "h" , "help" , false , "prints the help content" ) ; CommandLineParser parser = new PosixParser ( ) ; CommandLine line = parser . parse ( helpOptions , args ) ; if ( line . hasOption ( "h" ) ) help = true ; } catch ( Exception ex ) { } if ( ! help ) System . err . println ( e . getMessage ( ) ) ; HelpFormatter formatter = new HelpFormatter ( ) ; formatter . printHelp ( "Server" , options ) ; System . exit ( 1 ) ; } catch ( MissingArgumentException e ) { System . err . println ( e . getMessage ( ) ) ; HelpFormatter formatter = new HelpFormatter ( ) ; formatter . printHelp ( "Server" , options ) ; System . exit ( 1 ) ; } catch ( ParseException e ) { System . err . println ( "Error while parsing the command line: " + e . getMessage ( ) ) ; System . exit ( 1 ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } try { Global . MYSELF = new Machine ( ip , Global . TCP_PORT ) ; } catch ( Exception e ) { } }
tr	3	private void lisaaButtonActionPerformed ( java . awt . event . ActionEvent evt ) { if ( otaNimetTalteen ( ) ) { ArrayList < String > haettu = kortisto . hae ( etu . trim ( ) , suku . trim ( ) , null ) ; if ( ! haettu . isEmpty ( ) ) { JOptionPane . showMessageDialog ( this , "Henkil\u00F6 " + suku + " " + etu + " on jo kortistossa!" , "" , JOptionPane . WARNING_MESSAGE ) ; } else { kortisto . lisaaHenkilo ( etu , suku ) ; int indeksi = kortisto . getKoko ( ) - 1 ; for ( int i = 0 ; i < model . getSize ( ) ; i ++ ) { String taito = ( String ) model . elementAt ( i ) ; kortisto . lisaaTaito ( suku + " " + etu , taito , taidot . get ( taito ) ) ; } dispose ( ) ; } } }
tr	2	Tester ( long _seed ) throws Exception { loadWords ( ) ; setSeed ( _seed ) ; setDefaultCloseOperation ( EXIT_ON_CLOSE ) ; c = new TesterCanvas ( ) ; c . setPreferredSize ( new Dimension ( 600 , 400 ) ) ; Container cp = getContentPane ( ) ; cp . setLayout ( new BorderLayout ( ) ) ; cp . add ( c , BorderLayout . CENTER ) ; cp . add ( c . seedText , BorderLayout . NORTH ) ; JPanel jp = new JPanel ( ) ; JButton e = new JButton ( "english" ) ; e . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent arg0 ) { int index = r . nextInt ( ewords . size ( ) ) ; String word = ewords . get ( index ) ; c . english = word ; c . portuguese = null ; count ++ ; c . repaint ( ) ; } } ) ; JButton p = new JButton ( "portuguese" ) ; p . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent arg0 ) { int index = r . nextInt ( pwords . size ( ) ) ; System . out . println ( "index = " + index ) ; String word = pwords . get ( index ) ; c . english = null ; c . portuguese = word ; count ++ ; c . repaint ( ) ; } } ) ; JButton t = new JButton ( "translate" ) ; t . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent arg0 ) { if ( c . english != null ) { c . portuguese = e2p . get ( c . english ) ; } else if ( c . portuguese != null ) { c . english = p2e . get ( c . portuguese ) ; } c . repaint ( ) ; } } ) ; JButton r = new JButton ( "reset" ) ; r . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { setSeed ( seed ) ; c . repaint ( ) ; } } ) ; jp . setLayout ( new FlowLayout ( ) ) ; jp . add ( e ) ; jp . add ( t ) ; jp . add ( p ) ; jp . add ( r ) ; cp . add ( jp , BorderLayout . SOUTH ) ; pack ( ) ; setVisible ( true ) ; }
tr	5	private int travelTree ( TreeNode node ) { if ( node == null ) return 0 ; int left = travelTree ( node . left ) ; if ( left == - 1 ) return - 1 ; int right = travelTree ( node . right ) ; if ( right == - 1 ) return - 1 ; if ( Math . abs ( left - right ) > 1 ) return - 1 ; return left > right ? left + 1 : right + 1 ; }
tr	4	public synchronized void unbind ( String name ) { if ( registry == null ) throw new IllegalStateException ( "registry not active" ) ; try { registry . unbind ( name ) ; } catch ( NotBoundException e ) { } catch ( Exception e ) { if ( ! ( e instanceof RuntimeException ) ) e = new RuntimeException ( "unexpected exception in " + "SimpleObjectRegistry.unbind: " + e ) ; throw ( RuntimeException ) e ; } }
tr	4	private void findNextCodel ( Codel codel ) { int x = codel . x ; int y = codel . y ; DirectionPointer directionPointer = mMachine . getDirectionPointer ( ) ; if ( directionPointer . isRight ( ) ) { x += 1 ; } else if ( directionPointer . isBottom ( ) ) { y += 1 ; } else if ( directionPointer . isLeft ( ) ) { x -= 1 ; } else if ( directionPointer . isTop ( ) ) { y -= 1 ; } mNextCodel . set ( x , y ) ; }
tr	7	public Object nextContent ( ) throws JSONException { char c ; StringBuffer sb ; do { c = next ( ) ; } while ( Character . isWhitespace ( c ) ) ; if ( c == 0 ) { return null ; } if ( c == < ) { return XML . < ; } sb = new StringBuffer ( ) ; for ( ; ; ) { if ( c == < || c == 0 ) { back ( ) ; return sb . toString ( ) . trim ( ) ; } if ( c == & ) { sb . append ( nextEntity ( c ) ) ; } else { sb . append ( c ) ; } c = next ( ) ; } }
tr	6	public String getType ( VesselType type ) { switch ( type ) { case SWIMMER : return "1 - Human (swimmer)" ; case SPEED_BOAT : return "2 - Speed Boat" ; case FISHING_BOAT : return "3 - Fishing Boat" ; case CARGO_BOAT : return "4 - Cargo Vessel" ; case PASSENGER_VESSEL : return "5 - Passenger Vessel" ; case UNKNOWN : return "6 - Unknown" ; default : return "6 - Unknown" ; } }
tr	3	public boolean saveArchivePicture ( ZipOutputStream zipOut ) { ZipEntry entry = new ZipEntry ( pictureArchiveName ) ; entry . setSize ( pictureSource . length ) ; try { zipOut . putNextEntry ( entry ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; return false ; } try { zipOut . write ( pictureSource ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; return false ; } try { zipOut . closeEntry ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; return false ; } return true ; }
tr	0	public Decision getLastDecision ( ) { return getDecision ( ) ; }
tr	4	@ Override public void visit ( FSP_TresholdOrJoin g ) { dot_program . append ( "\tstruct_" + g . name ( ) + " [color=red  label=\"{" + g . name ( ) + "| TSH_OR_JOIN }|{" ) ; for ( int i = 0 ; i < g . all_names ( ) . size ( ) ; i ++ ) { String s = g . all_names ( ) . get ( i ) ; dot_program . append ( "<" + s + "> " + s ) ; if ( i != g . all_names ( ) . size ( ) - 1 ) { dot_program . append ( "|" ) ; } } dot_program . append ( "}\"];\n" ) ; for ( int i = 0 ; i < g . all_names ( ) . size ( ) ; i ++ ) { String nm = g . all_names ( ) . get ( i ) ; FSPLink l = g . get_link ( nm ) ; if ( l != null ) { dot_program . append ( "\tstruct_" + g . name ( ) + ":" + nm + "->" + l . name ( ) + ";\n" ) ; } } }
tr	1	public void tradeElGamal ( boolean first ) { { p = new BigInteger ( "4988735951183711405443349413015910122453507015594895638933838601555750189585703700647655985269637551634513770201277370413860951650702374379627998821919409" ) ; BigInteger g = new BigInteger ( "4403105895869798297264918950735787070665047406714785361037216842427722734684061748868589917485012596281820467352001338223691996653533143166890875549812531" ) ; BigInteger y = new BigInteger ( "3670294064109445804998782973709772470002041046377612489028768098078250713079795031354099562309432613560558383306865142781216201315104971340333690591679721" ) ; BigInteger x = new BigInteger ( "4589946301809196862611751989088793376762175950291076147544077975213763218505486754450017554342955014202444667772016113058406939298289857995054770609176615" ) ; elGamalC_own = new ElGamalCipher ( p , g , y , x ) ; elGamalS_own = new ElGamalSignature ( p , g , y , x ) ; } if ( first ) { com . sendTo ( 1 , p . toString ( 16 ) ) ; com . sendTo ( 1 , elGamalC_own . g . toString ( 16 ) ) ; com . sendTo ( 1 , elGamalC_own . y . toString ( 16 ) ) ; { BigInteger p = new BigInteger ( com . receive ( ) , 16 ) ; BigInteger g = new BigInteger ( com . receive ( ) , 16 ) ; BigInteger y = new BigInteger ( com . receive ( ) , 16 ) ; elGamalC_other = new ElGamalCipher ( p , g , y ) ; elGamalS_other = new ElGamalSignature ( p , g , y ) ; } } else { { BigInteger p = new BigInteger ( com . receive ( ) , 16 ) ; BigInteger g = new BigInteger ( com . receive ( ) , 16 ) ; BigInteger y = new BigInteger ( com . receive ( ) , 16 ) ; elGamalC_other = new ElGamalCipher ( p , g , y ) ; elGamalS_other = new ElGamalSignature ( p , g , y ) ; } com . sendTo ( 0 , p . toString ( 16 ) ) ; com . sendTo ( 0 , elGamalC_own . g . toString ( 16 ) ) ; com . sendTo ( 0 , elGamalC_own . y . toString ( 16 ) ) ; } }
tr	0	public JFrame getFullScreenWindow ( ) { return ( JFrame ) device . getFullScreenWindow ( ) ; }
tr	7	public String toKML ( boolean suppressEnclosingTags ) { String kml = "" ; if ( ! suppressEnclosingTags ) { kml += "<Location" ; if ( this . id != null ) { kml += " id=\"" + this . getId ( ) + "\"" ; } if ( this . targetId != null ) { kml += " targetId=\"" + this . getTargetId ( ) + "\"" ; } kml += ">\n" ; } kml += super . toKML ( true ) ; if ( this . longitude != DEFAULT_LONGITUDE ) { kml += "<longitude>" + this . longitude + "</longitude>\n" ; } if ( this . latitude != DEFAULT_LATITUDE ) { kml += "<latitude>" + this . latitude + "</latitude>\n" ; } if ( this . altitude != DEFAULT_ALTITUDE ) { kml += "<altitude>" + this . altitude + "</altitude>\n" ; } if ( ! suppressEnclosingTags ) { kml += "</Location>\n" ; } return kml ; }
tr	7	public List < Car > step1 ( List < Car > cars , Step1UserRequest userRequest ) { CarCriterion firstCriterion = userRequest . getFirstCriterion ( ) ; for ( Car car : cars ) { firstCriterion . getEvaluator ( ) . evaluate ( car , 1. ) ; userRequest . getCarDomainType ( ) . getEvaluator ( ) . evaluate ( car , 2. ) ; } if ( userRequest . getSecondCriterion ( ) != null ) { for ( Car car : cars ) { userRequest . getSecondCriterion ( ) . getEvaluator ( ) . evaluate ( car , 0.1 ) ; } if ( userRequest . getThirdCriterion ( ) != null ) { for ( Car car : cars ) { userRequest . getThirdCriterion ( ) . getEvaluator ( ) . evaluate ( car , 0.01 ) ; } } } Collections . sort ( cars ) ; List < Car > newList = new ArrayList < Car > ( ) ; for ( int i = 0 ; i < cars . size ( ) ; i ++ ) { if ( fulfills ( cars . get ( i ) , userRequest ) ) { newList . add ( cars . get ( i ) ) ; } } return newList ; }
tr	7	public static void makeCompactGrid ( Container parent , int rows , int cols , int initialX , int initialY , int xPad , int yPad ) { SpringLayout layout ; try { layout = ( SpringLayout ) parent . getLayout ( ) ; } catch ( ClassCastException exc ) { System . err . println ( "The first argument to makeCompactGrid must use SpringLayout." ) ; return ; } Spring x = Spring . constant ( initialX ) ; for ( int c = 0 ; c < cols ; c ++ ) { Spring width = Spring . constant ( 0 ) ; for ( int r = 0 ; r < rows ; r ++ ) { width = Spring . max ( width , getConstraintsForCell ( r , c , parent , cols ) . getWidth ( ) ) ; } for ( int r = 0 ; r < rows ; r ++ ) { SpringLayout . Constraints constraints = getConstraintsForCell ( r , c , parent , cols ) ; constraints . setX ( x ) ; constraints . setWidth ( width ) ; } x = Spring . sum ( x , Spring . sum ( width , Spring . constant ( xPad ) ) ) ; } Spring y = Spring . constant ( initialY ) ; for ( int r = 0 ; r < rows ; r ++ ) { Spring height = Spring . constant ( 0 ) ; for ( int c = 0 ; c < cols ; c ++ ) { height = Spring . max ( height , getConstraintsForCell ( r , c , parent , cols ) . getHeight ( ) ) ; } for ( int c = 0 ; c < cols ; c ++ ) { SpringLayout . Constraints constraints = getConstraintsForCell ( r , c , parent , cols ) ; constraints . setY ( y ) ; constraints . setHeight ( height ) ; } y = Spring . sum ( y , Spring . sum ( height , Spring . constant ( yPad ) ) ) ; } SpringLayout . Constraints pCons = layout . getConstraints ( parent ) ; pCons . setConstraint ( SpringLayout . SOUTH , y ) ; pCons . setConstraint ( SpringLayout . EAST , x ) ; }
tr	6	public int getScore ( final List < Vraag > vragen ) { int vragenGoed = 0 ; for ( Vraag vraag : vragen ) { int aantalGoed = 0 ; int aantalFout = 0 ; int jokers = vraag . getHoeveelJokersGebruikt ( ) ; for ( GekozenAntwoord gk : vraag . getGekozenAntwoorden ( ) ) if ( gk . isGoed ( ) ) aantalGoed ++ ; else aantalFout ++ ; vragenGoed += aantalGoed + Math . min ( aantalFout , jokers ) ; } double bedrag = 0 ; for ( Vraag vraag : vragen ) { bedrag += vragenGoed * vraag . getHoeveelWaard ( ) ; if ( vraag . isDoubling ( ) ) bedrag *= 2 ; } if ( bedrag > MAX_BELASTINGVRIJ ) bedrag /= KANSSPELBELASTING / 100 + 1 ; return ( int ) Math . round ( bedrag ) ; }
tr	8	@ Override public void endElement ( String uri , String localName , String qName ) throws SAXException { if ( requestType . equals ( Globals . requestStatus ) ) { if ( qName . equals ( XMLTags . Status ) ) { return ; } else { processStatusXml ( qName ) ; } } else if ( requestType . equals ( Globals . requestMemoryByte ) ) { if ( qName . equals ( XMLTags . Memory ) ) { return ; } else { processMemoryXml ( qName ) ; } } else if ( requestType . equals ( Globals . requestDateTime ) ) { if ( qName . equals ( XMLTags . DateTime ) ) { if ( ! currentElementText . isEmpty ( ) ) { dt . setStatus ( currentElementText ) ; } return ; } else { processDateTimeXml ( qName ) ; } } else if ( requestType . equals ( Globals . requestVersion ) ) { processVersionXml ( qName ) ; } else { } currentElementText = "" ; }
tr	2	private static boolean tabuReplicasBusy ( List < Future > tabuFutures ) { Iterator < Future > itr = tabuFutures . iterator ( ) ; while ( itr . hasNext ( ) ) { if ( itr . next ( ) . isDone ( ) ) { itr . remove ( ) ; } } return tabuFutures . size ( ) > 0 ; }
tr	2	synchronized void update ( ) { int i , j ; for ( i = 0 ; i < getWidth ( ) ; i ++ ) for ( j = 0 ; j < getHeight ( ) ; j ++ ) getItem ( i , j ) . update ( ) ; }
tr	4	protected boolean isInGrabBar ( int mouseX , int mouseY ) { mouseY = Standards . W_HEIGHT - mouseY - 1 ; if ( ( mouseX > ScreenX ) && ( mouseX < ScreenX + Width ) ) { if ( ( mouseY > ScreenY ) && ( mouseY < ScreenY + GrabBarHeight ) ) { return true ; } } return false ; }
tr	8	@ Test public void listCanBeRepeatedIfReset ( ) { list . add ( "apples" ) ; list . add ( "oranges" ) ; list . add ( "pickles" ) ; list . add ( "tommytoes" ) ; assertTrue ( list . getNext ( ) . equals ( "apples" ) && list . getNext ( ) . equals ( "oranges" ) && list . getNext ( ) . equals ( "pickles" ) && list . getNext ( ) . equals ( "tommytoes" ) && list . getNext ( ) == null ) ; list . reset ( ) ; assertTrue ( list . getNext ( ) . equals ( "apples" ) && list . getNext ( ) . equals ( "oranges" ) && list . getNext ( ) . equals ( "pickles" ) && list . getNext ( ) . equals ( "tommytoes" ) && list . getNext ( ) == null ) ; }
tr	8	public void setTile ( Tile tile , Tile selectedTile , Player tileOwner , Player selectedTileOwner , boolean clearUnit ) { Unit displayedUnit = null ; Player displayedUnitOwner = null ; if ( tile != null ) { if ( tile . hasUnit ( ) || clearUnit ) { displayedUnit = tile . getUnit ( ) ; displayedUnitOwner = tileOwner ; } } if ( selectedTile != null && displayedUnit == null ) { if ( selectedTile . hasUnit ( ) ) { displayedUnit = selectedTile . getUnit ( ) ; displayedUnitOwner = selectedTileOwner ; } } if ( displayedUnit == null ) { unitPanel . setUnit ( displayedUnit , displayedUnitOwner , actionListener , true ) ; } else if ( displayedUnit . isActive ( ) ) { unitPanel . setUnit ( displayedUnit , displayedUnitOwner , actionListener , true ) ; } else { unitPanel . setUnit ( displayedUnit , displayedUnitOwner , actionListener , false ) ; } terrainPanel . displayTerrainData ( tile ) ; }
tr	9	private static String fixNumberedParagraphs ( String document ) { boolean hasDot = contains ( document , "<p[^>]*>7\\. " ) && contains ( document , "<p[^>]*>8\\. " ) && contains ( document , "<p[^>]*>9\\. " ) ; boolean hasDash = contains ( document , "<p[^>]*>7 - " ) && contains ( document , "<p[^>]*>8 - " ) && contains ( document , "<p[^>]*>9 - " ) ; boolean hasLink = contains ( document , "<a id=\"7\\.\">" ) && contains ( document , "<a id=\"8\\.\">" ) && contains ( document , "<a id=\"9\\.\">" ) ; if ( hasDash ) { document = document . replaceAll ( "<p>([1-9][0-9]*) - " , "<p><a class=\"numpara\" id=\"p$1\">$1.</a> " ) ; } else if ( hasDot ) { document = document . replaceAll ( "(<p[^>]*>)([1-9][0-9]*)\\. " , "$1<a class=\"numpara\" id=\"p$2\">$2.</a> " ) ; } else if ( hasLink ) { document = document . replaceAll ( "<a id=\"([1-9][0-9]*)\\.\">" , "<a class=\"numpara\" id=\"p$1\">" ) ; } return document ; }
tr	2	@ Override public int hashCode ( ) { int result ; long temp ; temp = re != + 0.0d ? double . doubleToLongBits ( re ) : 0 ; result = ( int ) ( temp ^ ( temp >>> 32 ) ) ; temp = im != + 0.0d ? double . doubleToLongBits ( im ) : 0 ; result = 31 * result + ( int ) ( temp ^ ( temp >>> 32 ) ) ; return result ; }
tr	4	public synchronized boolean doCresciDinosauro ( String token , String idDinosauro ) throws InvalidTokenException , GenericDinosauroException { Coord coordToRemove = null ; try { if ( getPlayerByToken ( token ) . getRazza ( ) . existsDinosauroWithId ( idDinosauro ) ) { coordToRemove = getPlayerByToken ( token ) . getRazza ( ) . getDinosauroById ( idDinosauro ) . getCoord ( ) ; getPlayerByToken ( token ) . getRazza ( ) . cresciDinosauro ( idDinosauro ) ; return true ; } return false ; } catch ( InvalidTokenException e ) { throw new InvalidTokenException ( ) ; } catch ( GenericDinosauroException e ) { if ( e . getMessage ( ) . equals ( "mortePerInedia" ) ) { getMappa ( ) . rimuoviIlDinosauroDallaCella ( coordToRemove ) ; } throw new GenericDinosauroException ( e . getMessage ( ) ) ; } }
tr	3	private static void Insert ( int [ ] a , int num , int length ) { int i ; for ( i = 0 ; i < length ; i ++ ) { if ( num < a [ i ] ) break ; } for ( int j = length ; j >= i ; j -- ) { a [ j + 1 ] = a [ j ] ; } length ++ ; a [ i ] = num ; }
tr	2	public long inserir ( InstituicaoCooperadora instituicaocooperadora ) throws Exception { String sql = "INSERT INTO instituicaocooperadora(nome) VALUES (?)" ; long idGerado = 0 ; try { PreparedStatement stmt = ConnectionFactory . getConnection ( ) . prepareStatement ( sql , Statement . RETURN_GENERATED_KEYS ) ; stmt . setString ( 1 , instituicaocooperadora . getNome ( ) ) ; stmt . executeUpdate ( ) ; ResultSet rs = stmt . getGeneratedKeys ( ) ; if ( rs . next ( ) ) { idGerado = rs . getLong ( 1 ) ; } } catch ( SQLException e ) { throw e ; } return idGerado ; }
tr	7	private ItemGraphic newItem ( Item item ) { ItemGraphic itemG = new ItemGraphic ( ) { @ Override public void paint ( Graphics graph ) { } @ Override public Object getParent ( ) { return null ; } @ Override public Point getBoardPosition ( ) { return null ; } } ; if ( item instanceof Bomb ) { itemG = newBomb ( ( Bomb ) item ) ; } else if ( item instanceof Wall ) { itemG = newWall ( ( Wall ) item ) ; } else if ( item instanceof SpeedBuff ) { itemG = newSpeedBuff ( ( SpeedBuff ) item ) ; } else if ( item instanceof RangeBuff ) { itemG = newRangeBuff ( ( RangeBuff ) item ) ; } else if ( item instanceof LifeBuff ) { itemG = newLifeBuff ( ( LifeBuff ) item ) ; } else if ( item instanceof DropBuff ) { itemG = newDropBuff ( ( DropBuff ) item ) ; } else if ( ! ( item instanceof Ground ) ) { System . out . println ( "Objet inconnu." ) ; } return itemG ; }
tr	3	public void defineImage ( Object pkg_obj , String name , String tilename , int collisionid , String imgfile , String img_op , int top , int left , int width , int height ) { if ( images_loaded . containsKey ( name ) && ! images_loaded . get ( name ) . equals ( imgfile ) ) { undefineImage ( name ) ; } JGImage img = null ; if ( ! imgfile . equals ( "null" ) ) { imgfile = getAbsolutePath ( pkg_obj , imgfile ) ; img = imageutil . loadImage ( imgfile ) ; images_loaded . put ( name , imgfile ) ; } defineImage ( name , tilename , collisionid , img , img_op , top , left , width , height ) ; }
tr	0	public int getX ( ) { return x ; }
tr	4	public static String nullSafeToString ( long [ ] array ) { if ( array == null ) { return NULL_STRING ; } int length = array . length ; if ( length == 0 ) { return EMPTY_ARRAY ; } StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < length ; i ++ ) { if ( i == 0 ) { sb . append ( ARRAY_START ) ; } else { sb . append ( ARRAY_ELEMENT_SEPARATOR ) ; } sb . append ( array [ i ] ) ; } sb . append ( ARRAY_END ) ; return sb . toString ( ) ; }
tr	8	@ Override public int compare ( Card o1 , Card o2 ) { if ( o1 . isTrumpOrS ( trump ) && o2 . isTrumpOrS ( trump ) ) { return o1 . number . value - o2 . number . value ; } else if ( o1 . isTrumpOrS ( trump ) ) { return 1 ; } else if ( o2 . isTrumpOrS ( trump ) ) { return - 1 ; } else { if ( o1 . suit . equals ( leadSuit ) && o2 . suit . equals ( leadSuit ) ) { return o1 . number . value - o2 . number . value ; } else if ( o1 . suit . equals ( leadSuit ) ) { return 1 ; } else if ( o2 . suit . equals ( leadSuit ) ) { return - 1 ; } else { return 0 ; } } }
tr	2	private boolean isPreconditionsFilled ( Path absFilePath ) { if ( ! canWriteSelectedFile ( absFilePath ) ) { return false ; } if ( ! canWriteWithDefaultOriginalClassConstructor ( ) ) { return false ; } return true ; }
tr	0	public void renewBoard ( CampaignView view ) { this . removeAll ( ) ; setBoard ( view ) ; }
tr	3	public RFClient ( IGraph conf ) throws Exception { String host = conf . getString ( "host" ) ; String s = conf . getString ( "port" ) ; if ( host == null || s == null ) return ; String r = conf . getString ( "retry" ) ; if ( r != null ) retry = Integer . parseInt ( r ) ; int port = Integer . parseInt ( s ) ; root = true ; open ( host , port , 0 ) ; }
tr	5	private String getStepRepr ( Step step ) { if ( step == null ) { return "" ; } switch ( step . getType ( ) ) { case REGULAR : return "#" ; case FREEZE_START : return "%" ; case HOLDING : return "|" ; case ROLLING : return "!" ; default : return " " ; } }
tr	4	public int lengthOfLongestSubstring ( String s ) { boolean [ ] flag = new boolean [ 256 ] ; int result = 0 ; int j = 0 ; char [ ] arr = s . toCharArray ( ) ; for ( int i = 0 ; i < arr . length ; i ++ ) { char c = arr [ i ] ; if ( flag [ c ] ) { result = Math . max ( result , i - j ) ; for ( int k = j ; k < i ; k ++ ) { if ( arr [ k ] == c ) { j = k + 1 ; break ; } flag [ arr [ k ] ] = false ; } } else { flag [ c ] = true ; } } result = Math . max ( arr . length - j , result ) ; return result ; }
tr	0	public AddOrigen ( java . awt . Frame parent , boolean modal ) { super ( parent , modal ) ; initComponents ( ) ; }
tr	7	public static void testValidity ( Object o ) throws JSONException { if ( o != null ) { if ( o instanceof double ) { if ( ( ( double ) o ) . isInfinite ( ) || ( ( double ) o ) . isNaN ( ) ) { throw new JSONException ( "JSON does not allow non-finite numbers." ) ; } } else if ( o instanceof float ) { if ( ( ( float ) o ) . isInfinite ( ) || ( ( float ) o ) . isNaN ( ) ) { throw new JSONException ( "JSON does not allow non-finite numbers." ) ; } } } }
tr	5	public static Integer convertStringToNumber ( String str ) { str = str . toLowerCase ( ) ; int num = ones . indexOf ( str ) ; if ( num > - 1 ) { return num ; } num = tens . indexOf ( str ) ; if ( num > - 1 ) { return num * 10 ; } String arr [ ] = str . split ( " |-" ) ; if ( arr . length == 2 ) { num = tens . indexOf ( arr [ 0 ] ) * 10 ; if ( num > - 1 ) { num += ones . indexOf ( arr [ 1 ] ) ; if ( num > 20 ) { return num ; } } } return null ; }
tr	3	private void writeQNameAttribute ( java . lang . String namespace , java . lang . String attName , javax . xml . namespace . QName qname , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { java . lang . String attributeNamespace = qname . getNamespaceURI ( ) ; java . lang . String attributePrefix = xmlWriter . getPrefix ( attributeNamespace ) ; if ( attributePrefix == null ) { attributePrefix = registerPrefix ( xmlWriter , attributeNamespace ) ; } java . lang . String attributeValue ; if ( attributePrefix . trim ( ) . length ( ) > 0 ) { attributeValue = attributePrefix + ":" + qname . getLocalPart ( ) ; } else { attributeValue = qname . getLocalPart ( ) ; } if ( namespace . equals ( "" ) ) { xmlWriter . writeAttribute ( attName , attributeValue ) ; } else { registerPrefix ( xmlWriter , namespace ) ; xmlWriter . writeAttribute ( namespace , attName , attributeValue ) ; } }
tr	0	public int getArgCount ( ) { return 2 ; }
tr	8	private final boolean isNumeric ( class < ? > clazz ) { if ( Number . class . isAssignableFrom ( clazz ) ) { return true ; } if ( clazz . isPrimitive ( ) ) { return clazz == long . TYPE || clazz == Integer . TYPE || clazz == double . TYPE || clazz == float . TYPE || clazz == short . TYPE || clazz == byte . TYPE ; } return false ; }
tr	4	private JPanel buildScoreReadingPreferencesPanel ( ) { scoreGameTypeComboBox = new JComboBox ( ) ; scoreGameTypeComboBox . addItemListener ( this ) ; scoreGameSpeedComboBox = new JComboBox ( ) ; scoreGameSpeedComboBox . addItem ( "Largo" ) ; scoreGameSpeedComboBox . addItem ( "Adagio" ) ; scoreGameSpeedComboBox . addItem ( "Moderato" ) ; scoreGameSpeedComboBox . addItem ( "Allegro" ) ; scoreGameSpeedComboBox . addItem ( "Presto" ) ; scoreGameSpeedComboBox . addItemListener ( this ) ; JPanel scoregamePanel = new JPanel ( ) ; scoregamePanel . add ( scoreGameTypeComboBox ) ; scoregamePanel . add ( scoreGameSpeedComboBox ) ; localizables . add ( new Localizable . NamedGroup ( scoregamePanel , "_menuExercises" ) ) ; scoreKeyComboBox = new JComboBox ( ) ; scoreKeyComboBox . addItemListener ( this ) ; scoreNotesComboBox = new JComboBox ( ) ; scoreNotesComboBox . addItemListener ( this ) ; scoreAlterationsComboBox = new JComboBox ( ) ; scoreAlterationsComboBox . addItemListener ( this ) ; JPanel scoreKeyPanel = new JPanel ( ) ; scoreKeyPanel . add ( scoreKeyComboBox ) ; scoreKeyPanel . add ( scoreAlterationsComboBox ) ; scoreKeyPanel . add ( scoreNotesComboBox ) ; localizables . add ( new Localizable . NamedGroup ( scoreKeyPanel , "_menuNotes" ) ) ; scorewholeCheckBox = new JCheckBox ( "" , true ) ; scorewholeCheckBox . addItemListener ( this ) ; scorehalfCheckBox = new JCheckBox ( "" , true ) ; scorehalfCheckBox . addItemListener ( this ) ; scoredottedhalfCheckBox = new JCheckBox ( "" , false ) ; scoredottedhalfCheckBox . addItemListener ( this ) ; scorequarterCheckBox = new JCheckBox ( "" , false ) ; scorequarterCheckBox . addItemListener ( this ) ; scoreeighthCheckBox = new JCheckBox ( "" , false ) ; scoreeighthCheckBox . addItemListener ( this ) ; scorerestCheckBox = new JCheckBox ( "" , true ) ; scorerestCheckBox . addItemListener ( this ) ; scoreTripletCheckBox = new JCheckBox ( "" , false ) ; scoreTripletCheckBox . addItemListener ( this ) ; JPanel scorerhytmsPanel = new JPanel ( ) ; scorerhytmsPanel . add ( scorewholeCheckBox ) ; scorerhytmsPanel . add ( scoredottedhalfCheckBox ) ; scorerhytmsPanel . add ( scorehalfCheckBox ) ; scorerhytmsPanel . add ( scorequarterCheckBox ) ; scorerhytmsPanel . add ( scoreeighthCheckBox ) ; scorerhytmsPanel . add ( scorerestCheckBox ) ; scorerhytmsPanel . add ( scoreTripletCheckBox ) ; scoreTimeSignComboBox = new JComboBox ( ) ; scoreTimeSignComboBox . setPreferredSize ( new Dimension ( 100 , 25 ) ) ; scoreTimeSignComboBox . addItem ( "4/4" ) ; scoreTimeSignComboBox . addItem ( "3/4" ) ; scoreTimeSignComboBox . addItem ( "2/4" ) ; scoreTimeSignComboBox . addItem ( "6/8" ) ; scoreTimeSignComboBox . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { JComboBox cb = ( JComboBox ) e . getSource ( ) ; int sel = cb . getSelectedIndex ( ) ; System . out . println ( "Rhythm time signature changed. Selected: " + sel ) ; if ( sel == 0 ) { scorewholeCheckBox . setEnabled ( true ) ; scorewholeCheckBox . setSelected ( true ) ; scorequarterCheckBox . setSelected ( true ) ; scoredottedhalfCheckBox . setEnabled ( true ) ; scoredottedhalfCheckBox . setSelected ( false ) ; scoreLevel . setTimeSignNumerator ( 4 ) ; scoreLevel . setTimeSignDenominator ( 4 ) ; scoreLevel . setTimeDivision ( 1 ) ; } else if ( sel == 1 ) { scorewholeCheckBox . setSelected ( false ) ; scorewholeCheckBox . setEnabled ( false ) ; scoredottedhalfCheckBox . setSelected ( true ) ; scoredottedhalfCheckBox . setEnabled ( true ) ; scorequarterCheckBox . setSelected ( true ) ; scoreLevel . setTimeSignNumerator ( 3 ) ; scoreLevel . setTimeSignDenominator ( 4 ) ; scoreLevel . setTimeDivision ( 1 ) ; } else if ( sel == 2 ) { scorewholeCheckBox . setSelected ( false ) ; scoredottedhalfCheckBox . setSelected ( false ) ; scoredottedhalfCheckBox . setEnabled ( false ) ; scorequarterCheckBox . setSelected ( true ) ; scoreLevel . setTimeSignNumerator ( 2 ) ; scoreLevel . setTimeSignDenominator ( 4 ) ; scoreLevel . setTimeDivision ( 1 ) ; } else if ( sel == 3 ) { scorewholeCheckBox . setSelected ( false ) ; scorewholeCheckBox . setEnabled ( false ) ; scoredottedhalfCheckBox . setSelected ( false ) ; scoredottedhalfCheckBox . setEnabled ( false ) ; scorequarterCheckBox . setSelected ( true ) ; scoreLevel . setTimeSignNumerator ( 6 ) ; scoreLevel . setTimeSignDenominator ( 8 ) ; scoreLevel . setTimeDivision ( 2 ) ; } } } ) ; JPanel timeSignPanel = new JPanel ( ) ; scoreTimeSignLabel = new JLabel ( ) ; timeSignPanel . add ( scoreTimeSignLabel ) ; timeSignPanel . add ( scoreTimeSignComboBox ) ; JPanel scoreRhythmAndTimePanel = new JPanel ( ) ; scoreRhythmAndTimePanel . setLayout ( new BorderLayout ( ) ) ; scoreRhythmAndTimePanel . add ( timeSignPanel , BorderLayout . NORTH ) ; scoreRhythmAndTimePanel . add ( scorerhytmsPanel , BorderLayout . CENTER ) ; localizables . add ( new Localizable . NamedGroup ( scoreRhythmAndTimePanel , "_menuRythms" ) ) ; scoreMetronomeCheckBox = new JCheckBox ( "" , true ) ; scoreMetronomeShowCheckBox = new JCheckBox ( "" , true ) ; scoreMetronomeShowCheckBox . setSelected ( false ) ; scoreMetronomeCheckBox . addActionListener ( this ) ; scoreMetronomeShowCheckBox . addActionListener ( this ) ; JPanel scoremetronomePanel = new JPanel ( ) ; scoremetronomePanel . add ( scoreMetronomeCheckBox ) ; scoremetronomePanel . add ( scoreMetronomeShowCheckBox ) ; localizables . add ( new Localizable . NamedGroup ( scoremetronomePanel , "_menuMetronom" ) ) ; JPanel panel = new JPanel ( ) ; panel . setLayout ( new GridLayout ( 4 , 1 ) ) ; panel . add ( scoregamePanel ) ; panel . add ( scoreKeyPanel ) ; panel . add ( scoreRhythmAndTimePanel ) ; panel . add ( scoremetronomePanel ) ; return panel ; }
tr	9	public static void setRotateM ( float [ ] rm , int rmOffset , float a , float x , float y , float z ) { rm [ rmOffset + 3 ] = 0 ; rm [ rmOffset + 7 ] = 0 ; rm [ rmOffset + 11 ] = 0 ; rm [ rmOffset + 12 ] = 0 ; rm [ rmOffset + 13 ] = 0 ; rm [ rmOffset + 14 ] = 0 ; rm [ rmOffset + 15 ] = 1 ; a *= ( float ) ( Math . PI / 180.0f ) ; float s = ( float ) Math . sin ( a ) ; float c = ( float ) Math . cos ( a ) ; if ( 1.0f == x && 0.0f == y && 0.0f == z ) { rm [ rmOffset + 5 ] = c ; rm [ rmOffset + 10 ] = c ; rm [ rmOffset + 6 ] = s ; rm [ rmOffset + 9 ] = - s ; rm [ rmOffset + 1 ] = 0 ; rm [ rmOffset + 2 ] = 0 ; rm [ rmOffset + 4 ] = 0 ; rm [ rmOffset + 8 ] = 0 ; rm [ rmOffset + 0 ] = 1 ; } else if ( 0.0f == x && 1.0f == y && 0.0f == z ) { rm [ rmOffset + 0 ] = c ; rm [ rmOffset + 10 ] = c ; rm [ rmOffset + 8 ] = s ; rm [ rmOffset + 2 ] = - s ; rm [ rmOffset + 1 ] = 0 ; rm [ rmOffset + 4 ] = 0 ; rm [ rmOffset + 6 ] = 0 ; rm [ rmOffset + 9 ] = 0 ; rm [ rmOffset + 5 ] = 1 ; } else if ( 0.0f == x && 0.0f == y && 1.0f == z ) { rm [ rmOffset + 0 ] = c ; rm [ rmOffset + 5 ] = c ; rm [ rmOffset + 1 ] = s ; rm [ rmOffset + 4 ] = - s ; rm [ rmOffset + 2 ] = 0 ; rm [ rmOffset + 6 ] = 0 ; rm [ rmOffset + 8 ] = 0 ; rm [ rmOffset + 9 ] = 0 ; rm [ rmOffset + 10 ] = 1 ; } else { float len = length ( x , y , z ) ; if ( 1.0f != len ) { float recipLen = 1.0f / len ; x *= recipLen ; y *= recipLen ; z *= recipLen ; } float nc = 1.0f - c ; float xy = x * y ; float yz = y * z ; float zx = z * x ; float xs = x * s ; float ys = y * s ; float zs = z * s ; rm [ rmOffset + 0 ] = x * x * nc + c ; rm [ rmOffset + 4 ] = xy * nc - zs ; rm [ rmOffset + 8 ] = zx * nc + ys ; rm [ rmOffset + 1 ] = xy * nc + zs ; rm [ rmOffset + 5 ] = y * y * nc + c ; rm [ rmOffset + 9 ] = yz * nc - xs ; rm [ rmOffset + 2 ] = zx * nc - ys ; rm [ rmOffset + 6 ] = yz * nc + xs ; rm [ rmOffset + 10 ] = z * z * nc + c ; } }
tr	8	static double grad ( int hash , double x , double y , double z ) { int h = hash & 15 ; double u = h < 8 || h == 12 || h == 13 ? x : y , v = h < 4 || h == 12 || h == 13 ? y : z ; return ( ( h & 1 ) == 0 ? u : - u ) + ( ( h & 2 ) == 0 ? v : - v ) ; }
tr	3	public String getMapping ( int index , String [ ] rules ) { String [ ] actions = getMapping ( rules ) ; if ( actions == null || index < 0 || index >= actions . length ) return null ; return actions [ index ] ; }
tr	0	public JSONException ( Throwable cause ) { super ( cause . getMessage ( ) ) ; this . cause = cause ; }
tr	8	private void cliparParcial ( Graphics g ) { double x1 = 0 ; double y1 = 0 ; double x2 = 0 ; double y2 = 0 ; if ( areaComPonto . contains ( esquerda ) ) { double m = ( yPoints [ 1 ] - yPoints [ 0 ] ) / ( xPoints [ 1 ] - xPoints [ 0 ] ) ; x1 = 30 ; y1 = m * ( x1 - xPoints [ 0 ] ) + yPoints [ 0 ] ; if ( xPoints [ 1 ] > xPoints [ 0 ] ) { x2 = xPoints [ 1 ] ; y2 = yPoints [ 1 ] ; } else { x2 = xPoints [ 0 ] ; y2 = yPoints [ 0 ] ; } } if ( areaComPonto . contains ( direita ) ) { double m = ( yPoints [ 1 ] - yPoints [ 0 ] ) / ( xPoints [ 1 ] - xPoints [ 0 ] ) ; x1 = 650 ; y1 = m * ( x1 - xPoints [ 0 ] ) + yPoints [ 0 ] ; if ( xPoints [ 1 ] > xPoints [ 0 ] ) { x2 = xPoints [ 0 ] ; y2 = yPoints [ 0 ] ; } else { x2 = xPoints [ 1 ] ; y2 = yPoints [ 1 ] ; } } if ( areaComPonto . contains ( cima ) ) { double m = ( xPoints [ 1 ] - xPoints [ 0 ] ) / ( yPoints [ 1 ] - yPoints [ 0 ] ) ; y1 = 650 ; x1 = xPoints [ 0 ] + m * ( y1 - yPoints [ 0 ] ) ; if ( yPoints [ 1 ] > yPoints [ 0 ] ) { x2 = xPoints [ 0 ] ; y2 = yPoints [ 0 ] ; } else { x2 = xPoints [ 1 ] ; y2 = yPoints [ 1 ] ; } } if ( areaComPonto . contains ( baixo ) ) { double m = ( xPoints [ 1 ] - xPoints [ 0 ] ) / ( yPoints [ 1 ] - yPoints [ 0 ] ) ; y1 = 30 ; x1 = xPoints [ 0 ] + m * ( y1 - yPoints [ 0 ] ) ; if ( yPoints [ 1 ] > yPoints [ 0 ] ) { x2 = xPoints [ 1 ] ; y2 = yPoints [ 1 ] ; } else { x2 = xPoints [ 0 ] ; y2 = yPoints [ 0 ] ; } } g . drawLine ( ( int ) x1 , ( int ) y1 , ( int ) x2 , ( int ) y2 ) ; }
tr	5	public static JFrame getVisibleWindowByName ( String name ) { JFrame result = null ; if ( name != null ) { Frame [ ] windows = JFrame . getFrames ( ) ; for ( Frame window : windows ) { if ( window instanceof JFrame && window . isVisible ( ) && name . equals ( window . getName ( ) ) ) { result = ( JFrame ) window ; break ; } } } return result ; }
tr	5	int getCellId ( int row , int positionInRow ) { if ( row <= 0 ) { return 0 ; } if ( row >= 5 * n ) { return countCells ( ) - 1 ; } int result = 0 ; for ( int i = 0 ; i < row ; i ++ ) { result = result + getNumCellsInRow ( i ) ; } if ( ( positionInRow >= 0 ) && ( positionInRow < getNumCellsInRow ( row ) ) ) { result = result + positionInRow ; } return result ; }
tr	7	private static void calc ( ) { String [ ] classes = { "no" , "yes" } ; Iterator < String > itWords = setWords . iterator ( ) ; try { OutputStreamWriter w1 = new OutputStreamWriter ( new FileOutputStream ( "C:/Users/lin/Desktop/myemotion/v2/trainbigramno.csv" ) , "UTF-8" ) ; OutputStreamWriter w2 = new OutputStreamWriter ( new FileOutputStream ( "C:/Users/lin/Desktop/myemotion/v2/trainbigramyes.csv" ) , "UTF-8" ) ; Map < String , String > map = new HashMap < String , String > ( ) ; map . put ( "no" , "" ) ; map . put ( "yes" , "" ) ; while ( itWords . hasNext ( ) ) { String word = itWords . next ( ) ; String classs = "" ; for ( int i = 0 ; i < classes . length ; i ++ ) { classs = classes [ i ] ; int a = 0 , b = 0 , c = 0 , d = 0 ; Iterator < String > it = setSentences . iterator ( ) ; while ( it . hasNext ( ) ) { String [ ] its = it . next ( ) . split ( "\t" ) ; if ( its [ 0 ] . contains ( classs ) ) { if ( its [ 1 ] . contains ( word ) ) { a ++ ; } else { c ++ ; } } else { if ( its [ 1 ] . contains ( word ) ) { b ++ ; } else { d ++ ; } } } double chi = 1.0 * ( a * d - b * c ) * ( a * d - b * c ) / ( ( a + b ) * ( c + d ) ) ; map . put ( classs , map . get ( classs ) + word + " " + chi + "\r\n" ) ; } } w1 . write ( map . get ( "no" ) . toString ( ) . replaceAll ( "NaN" , "0" ) ) ; w2 . write ( map . get ( "yes" ) . toString ( ) . replaceAll ( "NaN" , "0" ) ) ; System . out . println ( setSentences . size ( ) ) ; w1 . close ( ) ; w2 . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }
tr	4	public CalculatorFrame ( ) { setBounds ( 250 , 150 , 500 , 200 ) ; setLayout ( null ) ; setTitle ( "Super Calculator" ) ; setDefaultCloseOperation ( EXIT_ON_CLOSE ) ; setResizable ( false ) ; calcPanel = new CalculatorPanel ( this ) ; add ( calcPanel ) ; setVisible ( true ) ; addWindowListener ( new WindowAdapter ( ) { @ Override public void windowClosing ( WindowEvent e ) { if ( calcPanel != null && Settings . AUTOSAVE . get ( ) . equals ( "true" ) ) { calcPanel . getCalcMenuBar ( ) . autoSave ( ) ; } } @ Override public void windowOpened ( WindowEvent e ) { if ( calcPanel != null && Settings . AUTOSAVE . get ( ) . equals ( "true" ) ) { calcPanel . getCalcMenuBar ( ) . autoOpen ( ) ; } } } ) ; System . out . println ( "Auto round: " + Settings . AUTOROUND . get ( ) ) ; }
