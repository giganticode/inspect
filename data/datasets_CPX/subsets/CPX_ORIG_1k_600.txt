tr	9X	public void run ( ) { searchField . setText ( "" ) ; searchField . setText ( SelectionField . SEARCHTERM ) ; TreeMap < Integer , List < Champion >> priorities = new TreeMap < Integer , List < Champion >> ( ) ; for ( Champion c : Initialiser . getChampionList ( ) ) { int priority = c . calculatePriority ( ) ; List < Champion > priorityList = priorities . get ( priority ) ; if ( priorityList == null ) { priorityList = new LinkedList < Champion > ( ) ; priorities . put ( priority , priorityList ) ; } priorityList . add ( c ) ; } Entry < Integer , List < Champion >> e = priorities . pollLastEntry ( ) ; recommendedModel . clear ( ) ; goodModel . clear ( ) ; viableModel . clear ( ) ; allModel . clear ( ) ; if ( e != null ) { for ( Champion c : e . getValue ( ) ) recommendedModel . addElement ( c ) ; e = priorities . pollLastEntry ( ) ; if ( e != null ) { for ( Champion c : e . getValue ( ) ) goodModel . addElement ( c ) ; e = priorities . pollLastEntry ( ) ; if ( e != null ) { for ( Champion c : e . getValue ( ) ) viableModel . addElement ( c ) ; e = priorities . pollLastEntry ( ) ; while ( e != null ) { for ( Champion c : e . getValue ( ) ) allModel . addElement ( c ) ; e = priorities . pollLastEntry ( ) ; } } } } reset ( ) ; scroller . revalidate ( ) ; }
tr	2	public List < Player > getPlayersOnPlace ( ) { final List < Player > players = new ArrayList < Player > ( ) ; for ( final Player player : Monopoly . getInstance ( ) . getPlayers ( ) ) { if ( player . position == this . placeID ) { players . add ( player ) ; } } return players ; }
tr	2	public void closeUpvalues ( int index ) { int loopIndex = upvalues . size ( ) ; while ( -- loopIndex >= 0 ) { UpValue upvalue = upvalues . elementAt ( loopIndex ) ; if ( upvalue . getIndex ( ) < index ) return ; upvalue . close ( ) ; upvalues . removeElementAt ( loopIndex ) ; } }
tr	2	@ Override public void onMoveTick ( int x , int y , Game game ) { SinglePlayerGame spg = ( SinglePlayerGame ) game ; if ( filterByID ( spg . getSquareNeighbors ( x , y , 1 ) , juggernaut . id ) . isEmpty ( ) ) { Location loc = spg . getFirstSquareNeighborLocation ( x , y , 2 , zombie . id ) ; spg . moveEntity ( x , y , loc == null ? Location . wander ( x , y , 1 ) : Location . away ( x , y , loc , 2 ) ) ; } }
tr	4	@ Override public void run ( GameManager gameManager , Game ata , MessageInfo msgInfo , List < Message > responses ) { responses . add ( MSG ( msgInfo . ROOM , msgInfo . NICK + " has been marked as away.  Use !back to rejoin." ) ) ; Name name = gameManager . m_nickToNameMap . get ( msgInfo . NICK ) ; ata . m_activePlayers . remove ( name ) ; if ( ata . m_activePlayers . size ( ) < 3 ) { ata . m_state = State . LOCK ; responses . add ( MSG ( gameManager . getName ( ) , "!botendgame " + msgInfo . ROOM ) ) ; } if ( ata . m_judge . equals ( msgInfo . NICK ) ) { ata . m_state = State . LOCK ; responses . add ( MSG ( gameManager . getName ( ) , "!botcleanup " + msgInfo . ROOM ) ) ; } else if ( ata . m_state == State . PLAY ) { ata . m_waiting . remove ( name ) ; if ( ata . m_waiting . size ( ) == 0 ) { ata . m_waiting . remove ( name ) ; responses . add ( MSG ( gameManager . getName ( ) , "!botchoose " + msgInfo . ROOM ) ) ; } } }
tr	5	@ Override public String toString ( ) { String a = "" ; String b ; if ( ! playerScoreMinerals . keySet ( ) . equals ( playerShipLocations . keySet ( ) ) ) { for ( String s : playerScoreMinerals . keySet ( ) ) { System . out . println ( s ) ; } System . out . println ( "different from" ) ; for ( String s : playerShipLocations . keySet ( ) ) { System . out . println ( s ) ; } a = "\nthere seems to be an issue with the game state\n" ; } for ( String k : playerShipLocations . keySet ( ) ) { b = "" ; for ( BoardLocation bl : playerShipLocations . get ( k ) ) { b = b . concat ( " " + bl . row + " " + bl . col ) ; } a = a . concat ( k + ":" + b + "\n" ) ; a = a . concat ( k + " score:" + playerScoreMinerals . get ( k ) [ 0 ] + "\n" ) ; a = a . concat ( k + " minerals:" + playerScoreMinerals . get ( k ) [ 1 ] + "\n" ) ; } return a . concat ( separator ) ; }
tr	0	public void updateRhythm ( boolean r , boolean b , boolean bp , boolean n , boolean c , boolean s , boolean t ) { this . whole = r ; this . half = b ; this . dottedhalf = bp ; this . quarter = n ; this . eighth = c ; this . silence = s ; this . triplet = t ; }
tr	4	private void populateDto ( Msg dto , ResultSet rs ) throws SQLException { dto . setIdMsg ( new Integer ( rs . getInt ( COLUMN_ID_MSG ) ) ) ; try { dto . setMailer ( new UserDaoImpl ( ) . findByPrimaryKey ( rs . getString ( COLUMN_MAILER ) ) ) ; } catch ( UserDaoException e3 ) { e3 . printStackTrace ( ) ; } try { dto . setRecipient ( new UserDaoImpl ( ) . findByPrimaryKey ( rs . getString ( COLUMN_RECIPIENT ) ) ) ; } catch ( UserDaoException e2 ) { e2 . printStackTrace ( ) ; } dto . setHeadMsg ( rs . getString ( COLUMN_HEAD_MSG ) ) ; dto . setBodyMsg ( rs . getString ( COLUMN_BODY_MSG ) ) ; try { dto . setStatusMsg ( new MsgStatusDaoImpl ( ) . findByPrimaryKey ( rs . getString ( COLUMN_STATUS_MSG ) ) ) ; } catch ( MsgStatusDaoException e1 ) { e1 . printStackTrace ( ) ; } try { dto . setTypeMsg ( new MsgTypeDaoImpl ( ) . findByPrimaryKey ( rs . getString ( COLUMN_TYPE_MSG ) ) ) ; } catch ( MsgTypeDaoException e ) { e . printStackTrace ( ) ; } dto . setSendOffDate ( rs . getTimestamp ( COLUMN_SEND_OFF_DATE ) ) ; }
tr	4	public void onSessionStatusChanged ( O2GSessionStatusCode status ) { System . out . println ( "Status: " + status . toString ( ) ) ; switch ( status ) { case TRADING_SESSION_REQUESTED : if ( mSessionID . isEmpty ( ) ) { System . out . println ( "Argument for trading session ID is missing" ) ; } else { mSession . setTradingSession ( mSessionID , mPin ) ; } break ; case CONNECTED : mConnected = true ; mDisconnected = false ; mSemaphore . release ( ) ; break ; case DISCONNECTED : mConnected = false ; mDisconnected = true ; mSemaphore . release ( ) ; break ; } }
tr	4	static void createNewPearltree ( Panel panel , boolean active ) { final Label item = createLabel ( ) ; final FlowPanel description = new FlowPanel ( ) ; item . setText ( "a new pearltree" ) ; if ( WebContent . onIpad ) { description . setStylePrimaryName ( PRIMARY_STYLE_NEWPEARLTREE ) ; panel . add ( description ) ; HTML newPearltreeBox = PopupElements . createHtml ( ) ; newPearltreeBox . setStylePrimaryName ( PopupElements . PRIMARY_STYLE_AVATARBOX ) ; newPearltreeBox . addStyleDependentName ( PopupElements . STYLE_SPECIAL_PADDING ) ; newPearltreeBox . setHTML ( NEW_PEARLTREE ) ; description . add ( newPearltreeBox ) ; description . add ( item ) ; } else { panel . add ( item ) ; } if ( ! WebContent . onIpad ) { item . addStyleDependentName ( STYLE_SELECTABLE ) ; item . addStyleDependentName ( STYLE_BOLD ) ; item . addStyleDependentName ( STYLE_PADDING ) ; } item . addStyleDependentName ( STYLE_SELECTABLE ) ; item . addStyleDependentName ( STYLE_ITEM ) ; if ( active ) { item . addClickHandler ( new ClickHandler ( ) { @ Override public void onClick ( ClickEvent event ) { if ( WebContent . onIpad ) { description . addStyleDependentName ( STYLE_SELECTED_TIMER ) ; Timer t = new Timer ( ) { @ Override public void run ( ) { DOM . removeElementAttribute ( TreeListUI . panelInside . getElement ( ) , "id" ) ; PopupControl . changeUI ( PopupUIs . NewTree ) ; } } ; t . schedule ( 120 ) ; } else { PopupControl . changeUI ( PopupUIs . NewTree ) ; } } } ) ; } else { item . addStyleDependentName ( STYLE_INACTIVE ) ; } }
tr	7	private Bed getBed ( CommandLine cmd ) { Bed bed = null ; if ( cmd . hasOption ( "hostel_id" ) ) { if ( bed == null ) bed = new Bed ( ) ; bed . setHostelId ( new Identifier ( cmd . getOptionValue ( "hostel_id" ) ) ) ; } if ( cmd . hasOption ( "bed_number" ) ) { if ( bed == null ) bed = new Bed ( ) ; bed . setNumber ( new Integer ( cmd . getOptionValue ( "bed_number" ) ) ) ; } if ( cmd . hasOption ( "room_number" ) ) { if ( bed == null ) bed = new Bed ( ) ; bed . setRoomNo ( new Integer ( cmd . getOptionValue ( "room_number" ) ) ) ; } if ( bed != null ) bed . setTariff ( null ) ; return bed ; }
tr	0	public int getSize ( ) { return this . slots . length ; }
tr	8	@ Override public int compare ( Card o1 , Card o2 ) { if ( o1 . isTrumpOrS ( trump ) && o2 . isTrumpOrS ( trump ) ) { return o1 . number . value - o2 . number . value ; } else if ( o1 . isTrumpOrS ( trump ) ) { return 1 ; } else if ( o2 . isTrumpOrS ( trump ) ) { return - 1 ; } else { if ( o1 . suit . equals ( leadSuit ) && o2 . suit . equals ( leadSuit ) ) { return o1 . number . value - o2 . number . value ; } else if ( o1 . suit . equals ( leadSuit ) ) { return 1 ; } else if ( o2 . suit . equals ( leadSuit ) ) { return - 1 ; } else { return 0 ; } } }
tr	7	public RegisteredEventMonitor ( Method monitorMethod , Listener listener ) { EventMonitor monitorAnnotation = monitorMethod . getAnnotation ( EventMonitor . class ) ; if ( monitorAnnotation == null ) { throw new IllegalArgumentException ( "Monitor method does not have an EventMonitor annotation." ) ; } class < ? > [ ] monitorMethodParameters = monitorMethod . getParameterTypes ( ) ; if ( monitorMethodParameters . length != 2 || ! Event . class . isAssignableFrom ( monitorMethodParameters [ 0 ] ) || ! Result . class . isAssignableFrom ( monitorMethodParameters [ 1 ] ) ) { throw new IllegalArgumentException ( "Monitor method signature is invalid. Cannot accept (Event  Result)." ) ; } eventType = ( class < ? extends Event > ) monitorMethodParameters [ 0 ] ; this . monitorMethod = monitorMethod ; if ( ! monitorMethod . isAccessible ( ) ) { monitorMethod . setAccessible ( true ) ; } this . listener = listener ; }
tr	7	public void put ( String key , MqttPersistable message ) throws MqttPersistenceException { checkIsOpen ( ) ; File file = new File ( clientDir , key + MESSAGE_FILE_EXTENSION ) ; File backupFile = new File ( clientDir , key + MESSAGE_FILE_EXTENSION + MESSAGE_BACKUP_FILE_EXTENSION ) ; if ( file . exists ( ) ) { boolean result = file . renameTo ( backupFile ) ; if ( ! result ) { backupFile . delete ( ) ; file . renameTo ( backupFile ) ; } } try { FileOutputStream fos = new FileOutputStream ( file ) ; fos . write ( message . getHeaderBytes ( ) , message . getHeaderOffset ( ) , message . getHeaderLength ( ) ) ; if ( message . getPayloadBytes ( ) != null ) { fos . write ( message . getPayloadBytes ( ) , message . getPayloadOffset ( ) , message . getPayloadLength ( ) ) ; } fos . getFD ( ) . sync ( ) ; fos . close ( ) ; if ( backupFile . exists ( ) ) { backupFile . delete ( ) ; } } catch ( IOException ex ) { throw new MqttPersistenceException ( ex ) ; } finally { if ( backupFile . exists ( ) ) { boolean result = backupFile . renameTo ( file ) ; if ( ! result ) { file . delete ( ) ; backupFile . renameTo ( file ) ; } } } }
tr	6	private void persist ( PersistAction persistAction , String successMessage ) { if ( selected != null ) { setEmbeddableKeys ( ) ; try { if ( persistAction != PersistAction . DELETE ) { getFacade ( ) . edit ( selected ) ; } else { getFacade ( ) . remove ( selected ) ; } JsfUtil . addSuccessMessage ( successMessage ) ; } catch ( EJBException ex ) { String msg = "" ; Throwable cause = ex . getCause ( ) ; if ( cause != null ) { msg = cause . getLocalizedMessage ( ) ; } if ( msg . length ( ) > 0 ) { JsfUtil . addErrorMessage ( msg ) ; } else { JsfUtil . addErrorMessage ( ex , ResourceBundle . getBundle ( "/resoruces/Bundle" ) . getString ( "PersistenceErrorOccured" ) ) ; } } catch ( Exception ex ) { Logger . getLogger ( this . getClass ( ) . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; JsfUtil . addErrorMessage ( ex , ResourceBundle . getBundle ( "/resoruces/Bundle" ) . getString ( "PersistenceErrorOccured" ) ) ; } } }
tr	5	@ Override public boolean equals ( Object object ) { if ( ! ( object instanceof ProjectUser ) ) { return false ; } ProjectUser other = ( ProjectUser ) object ; if ( ( this . projectUserPK == null && other . projectUserPK != null ) || ( this . projectUserPK != null && ! this . projectUserPK . equals ( other . projectUserPK ) ) ) { return false ; } return true ; }
tr	3	protected boolean attack ( Interactable target ) { if ( target != null && ! ( target instanceof CardinalDirection ) ) { System . out . println ( "You swing your " + this . name + " at the " + target . name + "." ) ; if ( ! target . damage ( this ) ) { System . out . println ( "Your attack bounces off and does nothing." ) ; } return true ; } else { System . out . println ( "You swing your " + this . name + " wildy around." ) ; return true ; } }
tr	9X	private boolean r_prelude ( ) { int v_1 ; int v_2 ; int v_3 ; int v_4 ; int v_5 ; B_Y_found = false ; v_1 = cursor ; lab0 : do { bra = cursor ; if ( ! ( eq_s ( 1 , "'" ) ) ) { break lab0 ; } ket = cursor ; slice_del ( ) ; } while ( false ) ; cursor = v_1 ; v_2 = cursor ; lab1 : do { bra = cursor ; if ( ! ( eq_s ( 1 , "y" ) ) ) { break lab1 ; } ket = cursor ; slice_from ( "Y" ) ; B_Y_found = true ; } while ( false ) ; cursor = v_2 ; v_3 = cursor ; lab2 : do { replab3 : while ( true ) { v_4 = cursor ; lab4 : do { golab5 : while ( true ) { v_5 = cursor ; lab6 : do { if ( ! ( in_grouping ( g_v , 97 , 121 ) ) ) { break lab6 ; } bra = cursor ; if ( ! ( eq_s ( 1 , "y" ) ) ) { break lab6 ; } ket = cursor ; cursor = v_5 ; break golab5 ; } while ( false ) ; cursor = v_5 ; if ( cursor >= limit ) { break lab4 ; } cursor ++ ; } slice_from ( "Y" ) ; B_Y_found = true ; continue replab3 ; } while ( false ) ; cursor = v_4 ; break replab3 ; } } while ( false ) ; cursor = v_3 ; return true ; }
tr	9X	public static String getTypeName ( class < ? extends Tag > clazz ) { if ( clazz . equals ( ByteArrayTag . class ) ) { return "TAG_Byte_Array" ; } else if ( clazz . equals ( ByteTag . class ) ) { return "TAG_Byte" ; } else if ( clazz . equals ( CompoundTag . class ) ) { return "TAG_Compound" ; } else if ( clazz . equals ( DoubleTag . class ) ) { return "TAG_Double" ; } else if ( clazz . equals ( EndTag . class ) ) { return "TAG_End" ; } else if ( clazz . equals ( FloatTag . class ) ) { return "TAG_Float" ; } else if ( clazz . equals ( IntArrayTag . class ) ) { return "TAG_Int_Array" ; } else if ( clazz . equals ( IntTag . class ) ) { return "TAG_Int" ; } else if ( clazz . equals ( ListTag . class ) ) { return "TAG_List" ; } else if ( clazz . equals ( LongTag . class ) ) { return "TAG_Long" ; } else if ( clazz . equals ( ShortTag . class ) ) { return "TAG_Short" ; } else if ( clazz . equals ( StringTag . class ) ) { return "TAG_String" ; } else if ( clazz . equals ( ListStringArrayTag . class ) ) { return "TAG_ListString_Array" ; } else if ( clazz . equals ( ListItemStackArrayTag . class ) ) { return "TAG_ListItemStack_Array" ; } else { throw new IllegalArgumentException ( "Invalid tag classs (" + clazz . getName ( ) + ")." ) ; } }
tr	2	public Hierarchy getHierarchy ( String id ) { for ( Hierarchy h : hierarchys ) { if ( h . getId ( ) . equalsIgnoreCase ( id ) ) { return h ; } } return null ; }
tr	3	public boolean matches ( KeyComponent other , Map < String , Object > bindings ) { List < KeyComponent > keyComponents = ( ( CompositeComponent ) other ) . components ; List < KeyComponent > ruleComponents = this . components ; if ( keyComponents . size ( ) != ruleComponents . size ( ) ) { return false ; } for ( int i = 0 ; i < keyComponents . size ( ) ; i ++ ) { if ( ! ruleComponents . get ( i ) . matches ( keyComponents . get ( i ) , bindings ) ) { return false ; } } return true ; }
tr	6	public String nextTo ( char delimiter ) throws JSONException { StringBuffer sb = new StringBuffer ( ) ; for ( ; ; ) { char c = this . next ( ) ; if ( c == delimiter || c == 0 || c ==  || c ==  ) { if ( c != 0 ) { this . back ( ) ; } return sb . toString ( ) . trim ( ) ; } sb . append ( c ) ; } }
tr	4	@ Override public int attachSoundEffect ( SoundEffect effect , int channel ) { if ( channel > chEffects . size ( ) ) throw new IndexOutOfBoundsException ( "Channel must be in range!" ) ; effect = effect . clone ( ) ; if ( channel < 0 ) { if ( effect . getChannelCount ( ) != channelCount ) throw new IllegalArgumentException ( "The effects channel count must be same as this mixers channel count!" ) ; mEffects . add ( effect ) ; return mEffects . size ( ) - 1 ; } else { if ( effect . getChannelCount ( ) != getInputChannelOutputChannelCount ( channel ) ) throw new IllegalArgumentException ( "The effects channel count must be the same as input channels channel count!" ) ; ArrayList < SoundEffect > e = chEffects . get ( channel ) ; e . add ( effect ) ; return e . size ( ) - 1 ; } }
tr	8	public SocketThread ( Socket skt ) { this . socket = skt ; this . reader = new Thread ( new Runnable ( ) { @ Override public void run ( ) { try { input = new XMLReader ( new BufferedReader ( new InputStreamReader ( socket . getInputStream ( ) , "UTF-8" ) ) ) ; } catch ( XMLStreamException | IOException e ) { e . printStackTrace ( ) ; return ; } while ( true ) { try { messages . add ( input . readMessage ( ) ) ; fireEvent ( ) ; } catch ( XMLStreamException e ) { if ( Thread . interrupted ( ) ) { System . out . println ( "Reader closed." ) ; return ; } else { e . printStackTrace ( ) ; } } } } } ) ; this . writer = new Thread ( new Runnable ( ) { @ Override public void run ( ) { try { output = new XMLWriter ( new PrintWriter ( new OutputStreamWriter ( socket . getOutputStream ( ) , "UTF-8" ) ) ) ; } catch ( XMLStreamException | IOException e ) { e . printStackTrace ( ) ; return ; } while ( true ) { try { Message m = msgQueue . take ( ) ; output . writeMessage ( m ) ; } catch ( InterruptedException e ) { System . out . println ( "Writer closed." ) ; return ; } catch ( XMLStreamException e ) { e . printStackTrace ( ) ; } } } } ) ; }
tr	8	@ Override protected void handleInboxItem ( InboxItem inboxItem ) { super . handleInboxItem ( inboxItem ) ; if ( inboxItem . getMessage ( ) instanceof TokenMessage ) { executeTurn ( ) ; } if ( inboxItem . getMessage ( ) instanceof LeaderElectionMessage ) { LeaderElectionMessage message = ( LeaderElectionMessage ) inboxItem . getMessage ( ) ; switch ( message . getLeaderElectionMessageType ( ) ) { case ASK_FOR_ROLL : { doRoll ( inboxItem . getSender ( ) ) ; break ; } case LEADER_ELECTED : { initRound ( ) ; ownPlayer . setActive ( true ) ; if ( message . getValue ( ) == ownEndpoint . getId ( ) ) { isDealer = true ; logger . info ( "New Dealer" ) ; sendToken ( getPreviousPlayer ( ) ) ; } else { logger . info ( "Player " + message . getValue ( ) + " is new dealer." ) ; } break ; } case ROLLED : { gatherRoll ( inboxItem . getSender ( ) , message ) ; break ; } } } if ( inboxItem . getMessage ( ) instanceof StatusMessage ) { handleStatusMessage ( ( StatusMessage ) inboxItem . getMessage ( ) ) ; } if ( inboxItem . getMessage ( ) instanceof DealerMessage ) { handleDealerMessage ( inboxItem . getSender ( ) , ( DealerMessage ) inboxItem . getMessage ( ) ) ; } }
tr	1	public static void main ( String [ ] argv ) { final int regulPriority = 8 ; final int refGenPriority = 6 ; final int plotterPriority = 7 ; ReferenceGenerator refgen = new ReferenceGenerator ( refGenPriority ) ; Regul regul = new Regul ( regulPriority ) ; final OpCom opcom = new OpCom ( plotterPriority ) ; regul . setOpCom ( opcom ) ; regul . setRefGen ( refgen ) ; opcom . setRegul ( regul ) ; Runnable initializeGUI = new Runnable ( ) { public void run ( ) { opcom . initializeGUI ( ) ; opcom . start ( ) ; } } ; try { SwingUtilities . invokeAndWait ( initializeGUI ) ; } catch ( Exception e ) { return ; } refgen . start ( ) ; regul . start ( ) ; }
tr	6	private static float [ ] [ ] genPerlinNoise ( final float [ ] [ ] baseNoise , final int octaveCount ) { final float [ ] [ ] [ ] smoothNoise = new float [ octaveCount ] [ ] [ ] ; for ( int index = 0 ; index < octaveCount ; index ++ ) { smoothNoise [ index ] = genSmoothNoise ( baseNoise , index ) ; } final int width = baseNoise . length ; final int height = baseNoise [ 0 ] . length ; final float persistance = 0.5f ; final float [ ] [ ] perlinNoise = new float [ width ] [ height ] ; float amplitude = 1 ; float totalAmplitude = 0 ; for ( int octave = octaveCount - 1 ; octave >= 0 ; octave -- ) { amplitude *= persistance ; totalAmplitude += amplitude ; for ( int x = 0 ; x < width ; x ++ ) { for ( int y = 0 ; y < height ; y ++ ) { perlinNoise [ x ] [ y ] += smoothNoise [ octave ] [ x ] [ y ] * amplitude ; } } } for ( int x = 0 ; x < width ; x ++ ) { for ( int y = 0 ; y < height ; y ++ ) { perlinNoise [ x ] [ y ] /= totalAmplitude ; } } return perlinNoise ; }
tr	9X	public static void writeToFile ( long [ ] sizes , int [ ] nthreads , double [ ] [ ] results , String file ) { BufferedWriter writer ; try { writer = new BufferedWriter ( new FileWriter ( file ) ) ; writer . write ( System . getProperty ( "os.name" ) + " " + System . getProperty ( "os.arch" ) + " " + System . getProperty ( "os.version" ) ) ; writer . newLine ( ) ; writer . write ( System . getProperty ( "java.vendor" ) + " " + System . getProperty ( "java.version" ) ) ; writer . newLine ( ) ; writer . write ( "Available processors (cores): " + Runtime . getRuntime ( ) . availableProcessors ( ) ) ; writer . newLine ( ) ; writer . write ( "Total memory (bytes): " + Runtime . getRuntime ( ) . totalMemory ( ) ) ; writer . newLine ( ) ; writer . write ( "Number of threads: {" ) ; for ( int th = 0 ; th < nthreads . length ; th ++ ) { if ( th < nthreads . length - 1 ) { writer . write ( nthreads [ th ] + " " ) ; } else { writer . write ( nthreads [ nthreads . length - 1 ] + "}" ) ; } } writer . newLine ( ) ; writer . write ( "Sizes: {" ) ; for ( int i = 0 ; i < sizes . length ; i ++ ) { if ( i < sizes . length - 1 ) { writer . write ( sizes [ i ] + " " ) ; } else { writer . write ( sizes [ sizes . length - 1 ] + "}" ) ; } } writer . newLine ( ) ; writer . write ( "Timings: {" ) ; for ( int th = 0 ; th < nthreads . length ; th ++ ) { writer . write ( "{" ) ; if ( th < nthreads . length - 1 ) { for ( int i = 0 ; i < sizes . length ; i ++ ) { if ( i < sizes . length - 1 ) { writer . write ( results [ th ] [ i ] + " " ) ; } else { writer . write ( results [ th ] [ i ] + "} " ) ; } } writer . newLine ( ) ; } else { for ( int i = 0 ; i < sizes . length ; i ++ ) { if ( i < sizes . length - 1 ) { writer . write ( results [ th ] [ i ] + " " ) ; } else { writer . write ( results [ th ] [ i ] + "}}" ) ; } } } } } catch ( IOException ex ) { ex . printStackTrace ( ) ; } }
tr	4	private void parseDisplayBPM ( String bpmValues , SimFile accumulator ) { final String [ ] bpmCodes = bpmValues . split ( " " ) ; double min = Integer . MAX_VALUE ; String minText = "" ; double max = Integer . MIN_VALUE ; String maxText = "" ; for ( String bpmCode : bpmCodes ) { String bpmText = bpmCode . substring ( bpmCode . indexOf ( = ) + 1 ) ; double bpm = double . parseDouble ( bpmText ) ; if ( bpm < min ) { min = bpm ; minText = bpmText ; } if ( bpm > max ) { max = bpm ; maxText = bpmText ; } } String displayBPM ; if ( max == min ) { displayBPM = minText ; } else { displayBPM = minText + " - " + maxText ; } accumulator . setDisplayBPM ( displayBPM ) ; }
tr	2	private String getKey ( String keyword ) { Set < String > set = nTimesGivenDay . keySet ( ) ; Iterator < String > iter = set . iterator ( ) ; while ( iter . hasNext ( ) ) { String key = iter . next ( ) ; if ( key . contains ( keyword ) ) { return key ; } } return new String ( ) ; }
tr	7	@ Override public boolean done ( ArrayList < Node > nw , int fab ) { int a = ( ( BeaconFAB ) nw . get ( 0 ) . getFAB ( fab ) ) . A ; Set < Integer > armies = new HashSet < Integer > ( ) ; int min = Integer . MAX_VALUE ; int d0 = 0 ; int d1 = 0 ; int d2 = 0 ; int d3 = 0 ; boolean res = true ; int sw = 0 ; for ( Node N : nw ) { armies . add ( ( ( BeaconFAB ) N . getFAB ( fab ) ) . A ) ; sw = ( ( BeaconFAB ) N . getFAB ( fab ) ) . D ; min = min < sw ? min : sw ; switch ( sw ) { case 0 : d0 ++ ; break ; case 1 : d1 ++ ; break ; case 2 : d2 ++ ; break ; case 3 : d3 ++ ; break ; default : break ; } if ( ( ( BeaconFAB ) N . getFAB ( fab ) ) . A != a ) { res = false ; } } return res ; }
tr	8	public void render ( Map map ) { if ( updateSenses ) { long startTime = System . currentTimeMillis ( ) ; playerSenses = map . getPlayerSenses ( ) ; long endTime = System . currentTimeMillis ( ) ; Log . print ( "Shadowcasting time: " + ( endTime - startTime ) ) ; updateSenses = false ; } HashMap < Integer , Tile > tileHashMap = playerSenses . getTiles ( ) ; HashMap < Integer , Actor > actorHashMap = playerSenses . getActors ( ) ; HashMap < Integer , ArrayList < Entity >> entities = playerSenses . getEntities ( ) ; Point top_left = new Point ( playerpos . getX ( ) - tilesx , playerpos . getY ( ) - tilesy ) ; for ( int x = top_left . getX ( ) ; x <= playerpos . getX ( ) + tilesx ; x ++ ) { for ( int y = top_left . getY ( ) ; y <= playerpos . getY ( ) + tilesy ; y ++ ) { if ( map . inBounds ( x , y ) ) { Tile tile = tileHashMap . get ( map . genKey ( x , y ) ) ; if ( tile != null ) { Image image = environment . getSprite ( tile . getSpriteID ( ) ) ; image . draw ( ( float ) ( ( x - top_left . getX ( ) ) * ppt ) , ( float ) ( ( y - top_left . getY ( ) ) * ppt ) , scale ) ; } ArrayList < Entity > ents = entities . get ( map . genKey ( x , y ) ) ; if ( ents != null && ents . size ( ) > 0 ) { Entity entity = ents . get ( 0 ) ; Image image = environment . getSprite ( entity . getSpriteID ( ) ) ; image . draw ( ( float ) ( ( x - top_left . getX ( ) ) * ppt ) , ( float ) ( ( y - top_left . getY ( ) ) * ppt ) , scale ) ; } Actor actor = actorHashMap . get ( map . genKey ( x , y ) ) ; if ( actor != null ) { Image image = actor_sprites . getSprite ( actor . getSpriteID ( ) ) ; image . draw ( ( float ) ( ( x - top_left . getX ( ) ) * ppt ) , ( float ) ( ( y - top_left . getY ( ) ) * ppt ) , scale ) ; } } } } Image player = actor_sprites . getSprite ( ActorSprite . player ) ; player . draw ( ( float ) ( ( playerpos . getX ( ) - top_left . getX ( ) ) * ppt ) , ( float ) ( ( playerpos . getY ( ) - top_left . getY ( ) ) * ppt ) , scale ) ; messageBox . render ( ) ; }
tr	4	public synchronized void updatedTTL ( ShareAvailability file ) { int row = 0 ; for ( String [ ] col : shares ) { if ( col [ 5 ] . equals ( file . getFile ( ) . getHash ( ) ) && col [ 4 ] . equals ( file . getHost ( ) . getAddress ( ) . getHostAddress ( ) ) ) { col [ 6 ] = String . valueOf ( file . getTtl ( ) ) ; } row ++ ; if ( shares . size ( ) > row ) { this . fireTableCellUpdated ( row , 6 ) ; } else { this . fireTableStructureChanged ( ) ; } } }
tr	2	public void actionPerformed ( ActionEvent e ) { if ( e . getSource ( ) == avbrytB ) { this . setVisible ( false ) ; return ; } else if ( e . getSource ( ) == sparastangB ) { transaction ( true ) ; return ; } }
tr	5	public static List < Employee > load ( InputStream input ) { List < Employee > employees = new ArrayList < Employee > ( ) ; BufferedReader reader = null ; try { reader = new BufferedReader ( new InputStreamReader ( input ) ) ; while ( true ) { String line = reader . readLine ( ) ; if ( line == null ) break ; String [ ] values = line . split ( " " ) ; Employee employee = new Employee ( values [ 0 ] , values [ 1 ] , values [ 2 ] ) ; employees . add ( employee ) ; } return employees ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } finally { if ( reader != null ) { try { reader . close ( ) ; } catch ( IOException e ) { } } } }
tr	1	public Item ( String label , double quantity , double price , double vat , int count ) { this . label = label ; this . quantity = quantity ; this . price = price ; this . vat = vat ; for ( int i = 0 ; i < count ; ++ i ) { subItems . add ( new Item ( label + "." + i , random . nextDouble ( ) , random . nextDouble ( ) , random . nextDouble ( ) , 0 ) ) ; } }
tr	0	public static void quadRectOutset ( Rect rect , double border , RGB fill , boolean inset ) { quadCoordOutset ( rect . getMin ( ) , rect . getMax ( ) , border , fill , inset ) ; }
tr	3	public JSONObject accumulate ( String key , Object value ) throws JSONException { testValidity ( value ) ; Object object = opt ( key ) ; if ( object == null ) { put ( key , value instanceof JSONArray ? new JSONArray ( ) . put ( value ) : value ) ; } else if ( object instanceof JSONArray ) { ( ( JSONArray ) object ) . put ( value ) ; } else { put ( key , new JSONArray ( ) . put ( object ) . put ( value ) ) ; } return this ; }
tr	3	public int getPieceCount ( DraughtsState gs ) { int [ ] pieces = gs . getPieces ( ) ; int count = 0 ; for ( int f = 1 ; f < pieces . length ; f = f + 1 ) { int piece = pieces [ f ] ; if ( Draughts . isWhite ( piece ) || Draughts . isBlack ( piece ) ) { count ++ ; } } return count ; }
tr	0	public Tela_Usuario_Cadastro ( ) { initComponents ( ) ; }
tr	6	public static String replaceAll ( String origin , String oldPart , String replacement ) { if ( origin == null || replacement == null ) { return origin ; } if ( oldPart == null || oldPart . length ( ) == 0 ) { return origin ; } int index = origin . indexOf ( oldPart ) ; if ( index < 0 ) { return origin ; } StringBuffer sb = new StringBuffer ( origin ) ; do { sb . replace ( index , index + oldPart . length ( ) , replacement ) ; origin = sb . toString ( ) ; index = origin . indexOf ( oldPart ) ; } while ( index != - 1 ) ; return origin ; }
tr	3	public void eval ( Environment e ) { switch ( type ) { case Value : e . value ( e . thing ( this ) ) ; break ; case Name : e . value ( this ) ; break ; case Call : e . call ( this ) ; break ; default : throw new Error ( String . format ( "Primitive '%s' not implemented!" , value ) ) ; } }
tr	8	public void unobfuscateProject ( ) { String obfuscatedContent ; int totalSizeTransfert = 0 ; int numberOfFiles = 0 ; int fileSizeTransfert ; createDestinationDirectories ( ) ; List < File > codeFiles = new ArrayList < File > ( ) ; for ( File file : projectFiles ) { String fileExtension = McbcFileUtils . getFilenameExtension ( file . getName ( ) ) ; if ( Constants . PHP_EXTENSION_TABLE . contains ( fileExtension ) || fileExtension . equals ( Constants . JAVA_FILE_EXTENSION ) ) { codeFiles . add ( file ) ; } } for ( FileObfuscationStructure structure : projectFileObfuscationStructureList ) { File obfuscatedFile = new File ( destinationDir + "\\" + structure . getFileName ( ) ) ; obfuscatedContent = handler . replaceVariables ( structure , commentRemover , whiteSpacesRemover ) ; fileSizeTransfert = McbcFileUtils . putFileContent ( obfuscatedFile , obfuscatedContent ) ; totalSizeTransfert += fileSizeTransfert ; numberOfFiles ++ ; } if ( ! copyOnlySource ) { for ( File file : projectFiles ) { String fileExtension = McbcFileUtils . getFilenameExtension ( file . getName ( ) ) ; if ( ! Constants . PHP_EXTENSION_TABLE . contains ( fileExtension ) && file . isFile ( ) ) { File newFile = new File ( destinationDir + "\\" + file . getAbsolutePath ( ) . substring ( sourceDir . length ( ) ) ) ; fileSizeTransfert = McbcFileUtils . copyFile ( file , newFile ) ; numberOfFiles ++ ; totalSizeTransfert += fileSizeTransfert ; } } } }
tr	8	private final static boolean isVowel ( String in , int at , int length ) { if ( ( at < 0 ) || ( at >= length ) ) return false ; char it = in . charAt ( at ) ; if ( ( it == A ) || ( it == E ) || ( it == I ) || ( it == O ) || ( it == U ) || ( it == Y ) ) return true ; return false ; }
tr	3	@ Override public Object getAsObject ( FacesContext facesContext , UIComponent uicomp , String value ) { try { FacesContext context = FacesContext . getCurrentInstance ( ) ; VendaBean venda = ( VendaBean ) context . getELContext ( ) . getELResolver ( ) . getValue ( context . getELContext ( ) , null , "venda" ) ; for ( Produto c : venda . getProdutos ( ) ) if ( c . getDescricao ( ) . equals ( value ) ) return c ; return null ; } catch ( Exception ex ) { return null ; } }
tr	7	private static void begin ( ) { Scanner sc = new Scanner ( System . in ) ; int nTestCases = Integer . parseInt ( sc . nextLine ( ) ) ; sc . nextLine ( ) ; Line decryptedLine = new Line ( "the quick brown fox jumps over the lazy dog" ) ; for ( int t = 0 ; t < nTestCases ; ++ t ) { List < Line > lines = new LinkedList < Line > ( ) ; Map < Character , Character > dict = null ; while ( sc . hasNextLine ( ) ) { String input = sc . nextLine ( ) ; if ( input . isEmpty ( ) ) { break ; } Line line = new Line ( input ) ; lines . add ( line ) ; if ( dict == null ) { dict = line . getDict ( decryptedLine ) ; } } if ( dict == null ) { System . out . println ( "No solution." ) ; } else { for ( Line l : lines ) { System . out . println ( l . decrypt ( dict ) ) ; } } if ( t < nTestCases - 1 ) { System . out . println ( ) ; } } }
tr	1	private char peekNextChar ( ) { if ( pos < ( input . length ( ) - 1 ) ) { return input . charAt ( pos + 1 ) ; } else { return 0 ; } }
tr	6	public static float valueOf ( Object o ) { if ( o == null ) { return null ; } else if ( o instanceof float ) { return ( float ) o ; } else if ( o instanceof double ) { return ( float ) o ; } else if ( o instanceof byte ) { return ( float ) ( byte ) o ; } else if ( o instanceof Integer ) { return ( float ) ( Integer ) o ; } else if ( o instanceof long ) { return ( float ) ( long ) o ; } else { return null ; } }
tr	5	@ Override public void handleEvent ( IParserEvent event ) { if ( event . getType ( ) == ParserEventType . DOCUMENT_END_EVENT ) { flushEvents ( ) ; event . fire ( listener ) ; } else { IParserEvent lastEvent = events . peekLast ( ) ; if ( lastEvent != null && lastEvent . getType ( ) == ParserEventType . STRING_EVENT && event . getType ( ) == ParserEventType . STRING_EVENT ) { event = mergeStringEvents ( ( StringEvent ) event ) ; } events . add ( event ) ; if ( events . size ( ) > MAX_EVENTS ) { events . removeFirst ( ) . fire ( listener ) ; } } }
tr	5	public V checkBaseInterfaces ( class c ) { Map < class , V > possibles = new HashMap < class , V > ( ) ; for ( class base = c ; base != Object . class ; base = base . getSuperclass ( ) ) { for ( class itf : base . getInterfaces ( ) ) { V val = lookup . valAt ( itf ) ; if ( val != null ) possibles . put ( itf , val ) ; } } switch ( possibles . size ( ) ) { case 0 : return null ; case 1 : return possibles . values ( ) . iterator ( ) . next ( ) ; default : throw new RuntimeException ( "More thane one match for " + c ) ; } }
tr	1	public char next ( char c ) throws JSONException { char n = next ( ) ; if ( n != c ) { throw syntaxError ( "Expected '" + c + "' and instead saw '" + n + "'" ) ; } return n ; }
tr	8	public void updateList ( ) { listModel . clear ( ) ; ArrayList < String > a = new ArrayList < > ( ) ; for ( Course co : aList ) { if ( co . getInstructor ( ) == null && co . getLab ( ) == null ) { listModel . addElement ( co . getClassCode ( ) + " " + co . getSection ( ) + " : " + "n/a" ) ; } else if ( co . getInstructor ( ) != null && co . getLab ( ) != null ) { a . add ( co . getClassCode ( ) + " " + co . getSection ( ) + " : " + co . getInstructor ( ) . getName ( ) + " (Lab)" ) ; } else if ( co . getInstructor ( ) != null && co . getLab ( ) == null ) { a . add ( co . getClassCode ( ) + " " + co . getSection ( ) + " : " + co . getInstructor ( ) . getName ( ) ) ; } else { listModel . addElement ( co . getClassCode ( ) + " " + co . getSection ( ) + " : " + "n/a" + " (Lab)" ) ; } } Collections . sort ( a ) ; for ( int i = 0 ; i < a . size ( ) ; i ++ ) { listModel . add ( i , a . get ( i ) ) ; } }
tr	7	public String toFirstUpperCase ( String title ) { if ( title . length ( ) == 0 ) return "" ; String upperCase = title . substring ( 0 , 1 ) . toUpperCase ( ) ; boolean isTheFirst = false ; if ( title . length ( ) > 1 ) for ( int i = 1 ; i < title . length ( ) ; i ++ ) { if ( title . charAt ( i ) ==   ) { upperCase += title . substring ( i , i + 1 ) ; if ( i + 1 < title . length ( ) && ! title . substring ( i + 1 , i + 2 ) . equals ( " " ) ) isTheFirst = true ; } else { if ( isTheFirst ) { upperCase += title . substring ( i , i + 1 ) . toUpperCase ( ) ; isTheFirst = false ; } else { upperCase += title . substring ( i , i + 1 ) ; } } } System . out . println ( upperCase ) ; return upperCase ; }
tr	5	void deleteActivity ( Component dialogParent , Activity activity ) { if ( activity != null ) { if ( AlertMessages . deleteActivityConfirmation ( dialogParent , activity ) ) { try { Connection conn = Dao . getConnection ( ) ; for ( Time t : timeDao . getTimesByActivity ( conn , activity ) ) { timeDao . deleteTime ( conn , t ) ; } activityDao . deleteActivity ( conn , activity ) ; activityDialog . setActivity ( null ) ; activityListDialog . selectPreviousRow ( ) ; activityDialog . setVisible ( false ) ; } catch ( SQLException ex ) { ErrorMessages . sqlExceptionError ( "deleteActivity()" , ex ) ; } catch ( ClassNotFoundException ex ) { ErrorMessages . classNotFoundError ( "deleteActivity()" , ex ) ; } } } else { AlertMessages . noActivitySelectedInTableForDeleting ( activityListDialog ) ; } }
tr	6	@ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; Cohort other = ( Cohort ) obj ; if ( yearOfAdmission == null ) { if ( other . yearOfAdmission != null ) return false ; } else if ( ! yearOfAdmission . equals ( other . yearOfAdmission ) ) return false ; return true ; }
tr	8	protected FileRequestResponseMessage handleResponse ( InputStream in ) throws UnsupportedEncodingException { FileRequestResponseMessage try_again = new FileRequestResponseMessage ( FileRequestResponseMessage . ResponseCode . TRY_AGAIN_LATER , 0 ) ; int probe_len = FileRequestResponseMessage . TYPE_FIELD . length ( ) + 4 ; byte [ ] buffer = new byte [ probe_len ] ; try { in . read ( buffer , 0 , probe_len ) ; } catch ( IOException e ) { logger . log ( Level . SEVERE , "Could not read response stream: '" + e . getMessage ( ) + "' - assuming 'NEVER TRY AGAIN'" ) ; return try_again ; } String responseHeader = new String ( buffer , Message . ENCODING ) . trim ( ) ; switch ( responseHeader . toUpperCase ( ) ) { case FileRequestResponseMessage . TYPE_FIELD + Message . FIELD_SEPERATOR + "OK" : String str_expectedTransferVolume = "" ; int next ; try { while ( ( next = in . read ( ) ) != Message . MESSAGE_SPERATOR ) if ( next == - 1 ) { Thread . sleep ( 500 ) ; } else { str_expectedTransferVolume += new String ( new byte [ ] { ( byte ) next } , Message . ENCODING ) ; } } catch ( IOException | InterruptedException e ) { logger . log ( Level . SEVERE , "Could not understand response header" ) ; transferState = TransferStatus . LostConnection ; closeSocket ( ) ; return null ; } try { long expectedTransferVolume = long . valueOf ( str_expectedTransferVolume ) ; return new FileRequestResponseMessage ( FileRequestResponseMessage . ResponseCode . OK , expectedTransferVolume ) ; } catch ( NumberFormatException ex ) { logger . log ( Level . SEVERE , "Response contained invalid 'expected transfer volume' - assuming 'TRY AGAIN LATER'" ) ; return try_again ; } case FileRequestResponseMessage . TYPE_FIELD + Message . FIELD_SEPERATOR + "TRY" : logger . log ( Level . INFO , "Received 'try again later from host'" ) ; return try_again ; case FileRequestResponseMessage . TYPE_FIELD + Message . FIELD_SEPERATOR + "NEV" : logger . log ( Level . INFO , "Received 'never try agiain from host'" ) ; return new FileRequestResponseMessage ( FileRequestResponseMessage . ResponseCode . NEVER_TRY_AGAIN , 0 ) ; default : logger . log ( Level . INFO , "Received garbage: '" + responseHeader + "'" ) ; return try_again ; } }
tr	8	public static void main ( String [ ] args ) { int numElementos = leeNumero ( "Introduzca el n\u00FAmero de elementos a procesar (m\u00E1ximo 100): " ) ; if ( numElementos < 0 ) { System . out . println ( "\u00A1Ha de ser positivo!" ) ; return ; } else if ( numElementos > 100 ) { System . out . println ( "\u00A1Ha de ser menor o igual a 100!" ) ; return ; } int [ ] elementos = new int [ numElementos ] ; for ( int i = 0 ; i < numElementos ; i ++ ) elementos [ i ] = leeNumero ( ( i + 1 ) + ": " ) ; System . out . println ( ) ; ArrayList < Integer > noRepetidos = new ArrayList < Integer > ( numElementos ) ; for ( int i = 0 ; i < numElementos ; i ++ ) { if ( ! noRepetidos . contains ( elementos [ i ] ) ) noRepetidos . add ( elementos [ i ] ) ; } if ( numElementos == 0 ) { System . out . println ( "\u00A1No hay elementos a ordenar!" ) ; } else { System . out . println ( "Vector original:" ) ; for ( int a : elementos ) System . out . print ( a + " " ) ; System . out . println ( ) ; System . out . println ( "Vector sin repetidos:" ) ; for ( int a : noRepetidos ) System . out . print ( a + " " ) ; System . out . println ( ) ; } }
tr	3	private void drawLines ( Graphics g , treeNode [ ] nodes ) { Graphics2D g2d = ( Graphics2D ) g ; g2d . setColor ( Color . black ) ; g2d . setStroke ( new BasicStroke ( LINE_THICKNESS ) ) ; for ( int i = 1 ; i < nodes . length ; i ++ ) { try { g2d . drawLine ( nodes [ i ] . CenterX , nodes [ i ] . CenterY , nodes [ 2 * i ] . CenterX , nodes [ 2 * i ] . CenterY ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { } try { g2d . drawLine ( nodes [ i ] . CenterX , nodes [ i ] . CenterY , nodes [ 2 * i + 1 ] . CenterX , nodes [ 2 * i + 1 ] . CenterY ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { } } }
tr	3	public void setEqualizer ( Equalizer = ) { if ( = == null ) = = Equalizer . PASS_THRU_EQ ; equalizer . setFrom ( = ) ; float [ ] factors = equalizer . getBandFactors ( ) ; if ( filter1 != null ) filter1 . setEQ ( factors ) ; if ( filter2 != null ) filter2 . setEQ ( factors ) ; }
tr	7	private String getOrientationString ( Orientations o ) { String os = "unknown" ; if ( o == Orientations . horizontal ) os = "horizontal" ; if ( o == Orientations . left ) os = "90\u00B0 left" ; if ( o == Orientations . right ) os = "90\u00B0 right" ; if ( o == Orientations . upside ) os = "180\u00B0" ; if ( myTFTType == TFTTypes . tft_320_240 ) { os = os + " (320x240)" ; } if ( myTFTType == TFTTypes . tft_800_480 ) { os = os + " (800x480)" ; } if ( myTFTType == TFTTypes . tft_480_272 ) { os = os + " (480x272)" ; } return os ; }
tr	7	public void update ( ) { ArrayList < ArrayList < Entity >> entityarrays = new ArrayList < ArrayList < Entity >> ( entities . values ( ) ) ; for ( int x = 0 ; x < entityarrays . size ( ) ; x ++ ) { ArrayList < Entity > activeArray = entityarrays . get ( x ) ; for ( int y = 0 ; y < activeArray . size ( ) ; y ++ ) { Entity ent = activeArray . get ( y ) ; ArrayList < EffectPackage > effects = ent . getEffectPackages ( ) ; for ( int c = 0 ; c < effects . size ( ) ; c ++ ) { EffectPackage pack = effects . get ( c ) ; if ( pack . getEffect ( ) == Effect . MOVE_UP ) { levelchange = true ; changeto = level - 1 ; } else if ( pack . getEffect ( ) == Effect . MOVE_DOWN ) { levelchange = true ; changeto = level + 1 ; } } ent . update ( ) ; } } actors = new ArrayList < Actor > ( actorHashMap . values ( ) ) ; for ( int c = 0 ; c < actors . size ( ) ; c ++ ) { Actor a = actors . get ( c ) ; a . update ( ) ; Point pos = a . getPos ( ) ; if ( a . delete ( ) ) { actorHashMap . remove ( genKey ( pos . getX ( ) , pos . getY ( ) ) ) ; } } }
tr	6	public MainFrame ( ) { initComponents ( ) ; preferences = Preferences . userRoot ( ) . node ( this . getClass ( ) . getName ( ) ) ; final String pathToPDFLaTeXFile = preferences . get ( "pathToPDFLaTeXFile" , null ) ; final String pathToPDFExportFolder = preferences . get ( "pathToPDFExportFolder" , null ) ; if ( ( pathToPDFLaTeXFile == null ) || ( pathToPDFExportFolder == null ) ) Config . initPreferences ( preferences ) ; if ( ( pathToPDFLaTeXFile != null ) && ( ! pathToPDFLaTeXFile . equals ( Config . default ) ) ) Config . setPDFLaTeXFile ( new File ( pathToPDFLaTeXFile ) ) ; if ( ( pathToPDFExportFolder != null ) && ( ! pathToPDFExportFolder . equals ( Config . default ) ) ) Config . setPDFExportFolder ( new File ( pathToPDFExportFolder ) ) ; parameterLabelArray = new javax . swing . JLabel [ ] { parameter1Label , parameter2Label , parameter3Label , parameter4Label } ; parameterArray = new javax . swing . JTextField [ ] { parameter1 , parameter2 , parameter3 , parameter4 } ; problemPartComponentsArray = new JComponent [ ] { userAnswerField , checkButton , showSolutionLaTeXButton , showSolutionPlaintextButton , copyToClipboardButton , exportToPDFButton , resetButton } ; }
tr	7	private void insertDatabaseOperation ( Object object , Connection connection , DatabaseOperation databaseOperation ) { try { if ( ! object . getClass ( ) . isAnnotationPresent ( Table . class ) ) { throw new JStrykerException ( "Object(" + object + ") isn't Entity" ) ; } Table table = object . getClass ( ) . getAnnotation ( Table . class ) ; StringBuilder builder = new StringBuilder ( "<?xml version=\"1.0\"?>\n<dataset>\n<" ) ; builder . append ( table . name ( ) ) . append ( " " ) ; Field [ ] fields = object . getClass ( ) . getDeclaredFields ( ) ; for ( Field field : fields ) { field . setAccessible ( true ) ; Object value = field . get ( object ) ; if ( value == null ) { continue ; } if ( field . isAnnotationPresent ( transient . class ) ) { continue ; } Column annotation = field . getAnnotation ( Column . class ) ; if ( annotation != null && ! "" . equals ( annotation . name ( ) ) ) { builder . append ( annotation . name ( ) ) ; } else { builder . append ( field . getName ( ) ) ; } builder . append ( "=\"" ) ; builder . append ( value ) ; builder . append ( "\" " ) ; } builder . append ( "/>\n</dataset>" ) ; String string = builder . toString ( ) ; execute ( null , connection , new ByteArrayInputStream ( string . getBytes ( ) ) , databaseOperation ) ; } catch ( IllegalAccessException e ) { throw new JStrykerException ( e . getMessage ( ) , e ) ; } }
tr	1	@ Override public void propertyChange ( PropertyChangeEvent evt ) { setModelProperty ( evt . getPropertyName ( ) , evt . getNewValue ( ) ) ; for ( AbstractPageView view : registeredViews ) { view . modelPropertyChange ( evt ) ; } }
tr	0	public void start ( ) { this . setPlayingOrder ( player1 , player2 ) ; this . board . clearTheBoard ( ) ; this . setStatus ( Game . NEW_GAME ) ; }
tr	5	@ Override public void enter ( BlockNode block , Deque < BlockNode > stack ) { ChangeNode previous = null ; Iterator < Node > nodes = block . - . iterator ( ) ; while ( nodes . hasNext ( ) ) { Node n = nodes . next ( ) ; if ( n instanceof ChangeNode ) { ChangeNode cn = ( ChangeNode ) n ; if ( cn . absolute ) { previous = null ; continue ; } if ( previous != null && cn . type == previous . type ) { previous . change += cn . change ; nodes . remove ( ) ; } else { previous = cn ; } } else { previous = null ; } } }
tr	8	@ Override public String replace ( String [ ] args , Page page ) { String image = "" ; String link = "" ; String alt = "image" ; for ( String arg : args ) { if ( arg . startsWith ( "img=" ) ) { image = arg . substring ( "img=" . length ( ) ) ; } else if ( arg . startsWith ( "link=" ) ) { link = arg . substring ( "link=" . length ( ) ) ; } else if ( arg . startsWith ( "alt=" ) ) { alt = arg . substring ( "alt=" . length ( ) ) ; } else if ( arg . startsWith ( "http:" ) ) { image = arg ; } else if ( arg . endsWith ( ".gif" ) || arg . endsWith ( ".png" ) ) { image = arg ; } else { throw new UnsupportedOperationException ( "Unknown image parameter: >" + arg + "<" ) ; } } return "![" + alt + "](" + image + ")" + ( link . length ( ) > 0 ? "(" + link + ")" : "" ) ; }
tr	8	@ Override public void write ( int theByte ) throws java . io . IOException { if ( suspendEncoding ) { this . out . write ( theByte ) ; return ; } if ( encode ) { buffer [ position ++ ] = ( byte ) theByte ; if ( position >= bufferLength ) { this . out . write ( encode3to4 ( b4 , buffer , bufferLength , options ) ) ; lineLength += 4 ; if ( breakLines && lineLength >= MAX_LINE_LENGTH ) { this . out . write ( NEW_LINE ) ; lineLength = 0 ; } position = 0 ; } } else { if ( decodabet [ theByte & 7f ] > WHITE_SPACE_ENC ) { buffer [ position ++ ] = ( byte ) theByte ; if ( position >= bufferLength ) { int len = Base64 . decode4to3 ( buffer , 0 , b4 , 0 , options ) ; out . write ( b4 , 0 , len ) ; position = 0 ; } } else if ( decodabet [ theByte & 7f ] != WHITE_SPACE_ENC ) { throw new java . io . IOException ( "Invalid character in Base64 data." ) ; } } }
tr	2	public static void findAll ( ) { try { IUTypeDao _dao = getUTypeDao ( ) ; UType _result [ ] = _dao . findAll ( ) ; for ( int i = 0 ; i < _result . length ; i ++ ) { display ( _result [ i ] ) ; } } catch ( Exception _e ) { _e . printStackTrace ( ) ; } }
tr	2	public static void changeSize ( final File file , final long newSize ) { try { RandomAccessFile randomAccessFile = new RandomAccessFile ( file , "rw" ) ; randomAccessFile . setLength ( newSize ) ; randomAccessFile . close ( ) ; } catch ( FileNotFoundException ex ) { Logger . getLogger ( files . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( IOException ex ) { Logger . getLogger ( files . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } }
tr	7	public static File getWorkingDirectory ( String applicationName ) { String userHome = System . getProperty ( "user.home" , "." ) ; File workingDirectory ; switch ( getPlatform ( ) . ordinal ( ) ) { case 0 : case 1 : workingDirectory = new File ( userHome , . + applicationName + / ) ; break ; case 2 : String applicationData = System . getenv ( "APPDATA" ) ; if ( applicationData != null ) workingDirectory = new File ( applicationData , "." + applicationName + / ) ; else workingDirectory = new File ( userHome , . + applicationName + / ) ; break ; case 3 : workingDirectory = new File ( userHome , "Library/Application Support/" + applicationName ) ; break ; default : workingDirectory = new File ( userHome , applicationName + / ) ; } if ( ( ! workingDirectory . exists ( ) ) && ( ! workingDirectory . mkdirs ( ) ) ) throw new RuntimeException ( "The working directory could not be created: " + workingDirectory ) ; return workingDirectory ; }
tr	2	public static void main ( String [ ] args ) { TreeSet < Integer > set2 = new TreeSet < Integer > ( ) ; set2 . add ( 4 ) ; set2 . add ( 100 ) ; set2 . add ( 45 ) ; set2 . add ( 19 ) ; set2 . add ( 33 ) ; ArrayList < TreeSet < Integer >> totalSubSets = findSubSets ( set2 , 0 ) ; if ( totalSubSets == null ) System . out . println ( "No possible subsets" ) ; else for ( TreeSet < Integer > ts : totalSubSets ) { System . out . println ( ts ) ; } }
tr	2	public FieldElement getElement ( Sprite sprite ) { Collection < FieldElement > keys ; Sprite currentSprite ; keys = table . keySet ( ) ; for ( FieldElement key : keys ) { currentSprite = table . get ( key ) ; if ( currentSprite . equals ( sprite ) ) { return key ; } } return null ; }
tr	8	public void changePanel ( JPanel panel ) { this . getContentPane ( ) . removeAll ( ) ; if ( panel != loginPanel ) { this . add ( actionBar ) ; if ( panel == connectionPanel ) { connectionPanel . initialize ( ) ; } else if ( panel == directoryListPanel ) { directoryListPanel . initialize ( ) ; } else if ( panel == fileListPanel ) { fileListPanel . initialize ( ) ; } } else { loginPanel . initialize ( ) ; actionBar . initialize ( ) ; } if ( ! actionBar . isBackBtnPress ( ) && currentPanel != panel ) { actionBar . getBackStack ( ) . push ( currentPanel ) ; } else if ( actionBar . isBackBtnPress ( ) && currentPanel != panel ) { actionBar . getForwardStack ( ) . push ( currentPanel ) ; } currentPanel = panel ; this . add ( panel ) ; this . repaint ( ) ; }
tr	2	public static String joinPretty ( byte [ ] bytes ) { F < byte , String > f = new PrettyF ( ) ; StringBuffer buffer = new StringBuffer ( bytes . length * 2 ) ; if ( bytes . length == 0 ) { return "" ; } buffer . append ( f . f ( bytes [ 0 ] ) ) ; int bytesLength = bytes . length ; for ( int i = 1 ; i < bytesLength ; i ++ ) { byte b = bytes [ i ] ; buffer . append ( "  " ) . append ( f . f ( b ) ) ; } return buffer . toString ( ) ; }
tr	1	private Meter getSelectedMeter ( ) { Account temp = getSelectedAccount ( ) ; if ( temp != null ) { Meter m = temp . getMeter ( getSelectedMeterID ( ) ) ; return m ; } else return null ; }
tr	8	private void emitLoadOrStore ( int opcode , int a , Adda address ) throws Exception { Value v = address . getArg1 ( ) ; int b , c ; if ( v instanceof Immediate ) { c = ( ( Immediate ) v ) . getValue ( ) ; opcode = opcode - 1 ; v = address . getArg2 ( ) ; if ( v . equals ( Type . getGBP ( ) ) ) { b = gbp ; } else if ( v . equals ( Type . getFP ( ) ) ) { b = fp ; } else { b = location2 ( v ) ; } } else { if ( v . equals ( Type . getGBP ( ) ) ) { b = gbp ; } else if ( v . equals ( Type . getFP ( ) ) ) { b = fp ; } else { b = location2 ( v ) ; } v = address . getArg2 ( ) ; if ( v instanceof Immediate ) { c = ( ( Immediate ) v ) . getValue ( ) ; opcode = opcode - 1 ; } else if ( v . equals ( Type . getGBP ( ) ) ) { c = gbp ; } else if ( v . equals ( Type . getFP ( ) ) ) { c = fp ; } else { c = location2 ( v ) ; } } emit ( DLX . assemble ( opcode , a , b , c ) ) ; }
tr	7	private void randomPlayerGroup ( int start , int end ) { Game game = new Game ( ) ; RandomPlayer randomPlayer = new RandomPlayer ( ) ; for ( int i = start ; i < end && i < players . size ( ) ; i ++ ) { PlayerEnlist player = players . get ( i ) ; for ( int j = 0 ; j < groupSize - 1 ; j ++ ) { game . startGame ( player . player , randomPlayer ) ; player . newMatch ( ) ; if ( game . colourOfWinner ( ) == Game . FIRST_PLAYER_COLOUR ) { player . newRandomMatchWon ( ) ; } else if ( game . colourOfWinner ( ) == Game . EMPTY_STONE_COLOUR ) { player . newRandomMatchDraw ( ) ; } game . startGame ( randomPlayer , player . player ) ; player . newMatch ( ) ; if ( game . colourOfWinner ( ) == Game . SECOND_PLAYER_COLOUR ) { player . newRandomMatchWon ( ) ; } else if ( game . colourOfWinner ( ) == Game . EMPTY_STONE_COLOUR ) { player . newRandomMatchDraw ( ) ; } } } }
tr	7	public String toKML ( boolean suppressEnclosingTags ) { String kml = "" ; if ( ! suppressEnclosingTags ) { kml += "<Location" ; if ( this . id != null ) { kml += " id=\"" + this . getId ( ) + "\"" ; } if ( this . targetId != null ) { kml += " targetId=\"" + this . getTargetId ( ) + "\"" ; } kml += ">\n" ; } kml += super . toKML ( true ) ; if ( this . longitude != DEFAULT_LONGITUDE ) { kml += "<longitude>" + this . longitude + "</longitude>\n" ; } if ( this . latitude != DEFAULT_LATITUDE ) { kml += "<latitude>" + this . latitude + "</latitude>\n" ; } if ( this . altitude != DEFAULT_ALTITUDE ) { kml += "<altitude>" + this . altitude + "</altitude>\n" ; } if ( ! suppressEnclosingTags ) { kml += "</Location>\n" ; } return kml ; }
tr	5	@ Override public void remove ( int index ) { if ( index < 0 || _lenght <= index ) { if ( 0 == _lenght ) { return ; } throw new IndexOutOfBoundsException ( "No se puede remover el dato \n " + "pues esta fuera de los limites de la lista" ) ; } else if ( index == 0 ) { removeFirst ( ) ; } else if ( index == _lenght - 1 ) { removeLast ( ) ; } else { Node < E > tmp = getIndex ( index - 1 ) ; tmp . setNext ( tmp . getNext ( ) . getNext ( ) ) ; _lenght -- ; } }
tr	4	private Mappable convertMappable ( Properties props , Map map , int i ) throws NoSuchMethodException , ClassNotFoundException , InstantiationException , IllegalAccessException , InvocationTargetException { String objPrefix = MAPOBJECT_PREFIX + SEP + i + SEP ; String className = props . getProperty ( objPrefix + ConfigurableProperties . class ) ; int x = getPropAsInt ( props , objPrefix + POS_X , 100 ) ; int y = getPropAsInt ( props , objPrefix + POS_Y , 100 ) ; String id = props . getProperty ( objPrefix + ID ) ; double angle = getPropAsDouble ( props , objPrefix + POS_ANGLE , 0.0 ) ; Constructor < ? > constructor = class . forName ( className ) . getConstructor ( MAPOBJ_PARAMS ) ; Mappable mappable = ( Mappable ) constructor . newInstance ( new Object [ ] { map , new Integer ( x ) , new Integer ( y ) } ) ; mappable . setAngle ( angle ) ; if ( id != null ) { mappable . setId ( id ) ; } List < ConfigurableProperties > list = mappable . getConfigurableProperties ( ) ; for ( ConfigurableProperties key : list ) { String val = props . getProperty ( objPrefix + key ) ; val = addHomeDir ( val ) ; if ( val != null ) { mappable . setConfiguredValue ( key , val ) ; } } return mappable ; }
tr	6	public Customer editCustomer ( Customer customer ) throws Exception { if ( customer . getId ( ) == null || customer . getAddress ( ) == null || customer . getName ( ) == null || customer . getSurname ( ) == null || customer . getTelephones ( ) == null ) { throw new NullParameterException ( ) ; } if ( ! checkZipCode ( customer . getAddress ( ) . getZipCode ( ) ) ) { throw new ZipCodeOutOfRangeException ( ) ; } DAOFactory . factory . getCustomerDAO ( ) . updateCustomer ( customer ) ; return customer ; }
tr	9X	public static void main ( String [ ] args ) { boolean a , b ; System . out . println ( "a\tb\ta and b\ta or b\tnot a\tnot b \n" ) ; a = 3 > 5 ; b = 12 != 8 ; System . out . print ( "(3>5)\t(12!=8)\t" + ( a && b ) ) ; System . out . print ( "\t" ) ; System . out . print ( a || b ) ; System . out . print ( "\t" ) ; System . out . print ( ! a ) ; System . out . print ( "\t" ) ; System . out . println ( ! b + "\n" ) ; a = 5 >= 6 ; b = 3 != 3 ; System . out . print ( "(5>=6)\t(3!=3)\t" + ( a && b ) ) ; System . out . print ( "\t" ) ; System . out . print ( a || b ) ; System . out . print ( "\t" ) ; System . out . print ( ! a ) ; System . out . print ( "\t" ) ; System . out . println ( ! b + "\n" ) ; a = - 7 == 8 ; System . out . print ( "(-7=8)\t(22)\t" + ( a && b ) ) ; System . out . print ( "\t" ) ; System . out . print ( a || b ) ; System . out . print ( "\t" ) ; System . out . print ( ! a ) ; System . out . print ( "\t" ) ; System . out . println ( ! b + " NO SE PUEDE USAR EL 22\n" ) ; a = 21 != 12 ; b = true ; System . out . print ( "21!=12\t(true)\t" + ( a && b ) ) ; System . out . print ( "\t" ) ; System . out . print ( a || b ) ; System . out . print ( "\t" ) ; System . out . print ( ! a ) ; System . out . print ( "\t" ) ; System . out . println ( ! b + "\n" ) ; a = 4 == 2 ; b = 7 >= - 9 ; System . out . print ( "(4==2)\t(7>=-9)\t" + ( a && b ) ) ; System . out . print ( "\t" ) ; System . out . print ( a || b ) ; System . out . print ( "\t" ) ; System . out . print ( ! a ) ; System . out . print ( "\t" ) ; System . out . println ( ! b + "\n" ) ; }
tr	0	public UnitOfWork with ( Object [ ] contextObjectArray ) { this . ctx = new business . Context ( contextObjectArray ) ; return this ; }
tr	9X	public static void phdStudentInsert ( JSONObject data ) { String firstName = ( String ) data . get ( "firstName" ) ; String surName = ( String ) data . get ( "surName" ) ; String lastName = ( String ) data . get ( "lastName" ) ; String personalId = ( String ) data . get ( "personalId" ) ; String phone = ( String ) data . get ( "phone" ) ; String email = ( String ) data . get ( "email" ) ; String type = ( String ) data . get ( "type" ) ; String form = ( String ) data . get ( "form" ) ; PhdStudentType studentType = null ; StudyForm studyForm = null ; if ( form . contains ( "self_training" ) ) studyForm = StudyForm . SELF_TRAINING ; else studyForm = StudyForm . REGULAR_TRAINING ; if ( type . contains ( "creative" ) ) studentType = PhdStudentType . CREATIVE ; else studentType = PhdStudentType . RESEARCH ; Student student = new Student ( firstName , surName , lastName , personalId , phone , email , studentType , studyForm ) ; SqlInsert . insertStudent ( student ) ; boolean assigned = boolean . parseBoolean ( ( String ) data . get ( "assigned" ) ) ; String assignedDate = ( String ) data . get ( "assignedDate" ) ; String supervisor = ( String ) data . get ( "supervisor" ) ; String thesis = ( String ) data . get ( "thesis" ) ; boolean individualPlan = boolean . parseBoolean ( ( String ) data . get ( "individualPlan" ) ) ; String approvalDate = ( String ) data . get ( "approvalDate" ) ; String monitoringDate = ( String ) data . get ( "monitoringDate" ) ; String evaluation_raw = ( String ) data . get ( "evaluation" ) ; Evaluation evaluation = null ; if ( evaluation_raw . equals ( "positive" ) ) evaluation = Evaluation . POSITIVE ; else if ( evaluation_raw . equals ( "negative" ) ) evaluation = Evaluation . NEGATIVE ; else evaluation = Evaluation . CRITICAL ; Monitoring monitoring = new Monitoring ( monitoringDate ) ; TrainingStatus trainingStatus = new TrainingStatus ( assigned , assignedDate , supervisor , thesis , individualPlan , approvalDate , monitoring , evaluation ) ; SqlInsert . insertTrainingStatus ( trainingStatus , student ) ; String facultyName = ( String ) data . get ( "facultyName" ) ; int specialtyCode = Integer . parseInt ( ( String ) data . get ( "specialtyCode" ) ) ; Faculty faculty = new Faculty ( facultyName , specialtyCode , trainingStatus , student ) ; SqlInsert . insertFaculty ( faculty , student , trainingStatus ) ; String specialtyExam = ( String ) data . get ( "specialtyExam" ) ; String publicProtection = ( String ) data . get ( "publicProtection" ) ; Curriculum studentCurriculum = new Curriculum ( specialtyExam , publicProtection ) ; SqlInsert . insertStudentCurriculum ( studentCurriculum , student ) ; JSONArray courses = ( JSONArray ) data . get ( "courses" ) ; for ( int i = 0 ; i < courses . size ( ) ; i ++ ) { JSONObject course = ( JSONObject ) courses . get ( i ) ; String courseName = ( String ) course . get ( "courseName" ) ; String courseEstimate = ( String ) course . get ( "courseEstimate" ) ; String courseType = ( String ) course . get ( "courseType" ) ; String courseProtocol = ( String ) course . get ( "courseProtocol" ) ; CourseProtocols protocol = new CourseProtocols ( courseProtocol ) ; CourseType ctype = null ; if ( courseType . equals ( "compulsory" ) ) ctype = CourseType . COMPULSORY ; else ctype = CourseType . ELECTIVE ; Course studentCourse = new Course ( courseEstimate , courseName , ctype , protocol ) ; SqlInsert . insertCourseProtocol ( protocol ) ; SqlInsert . insertCourses ( studentCourse , student , studentCurriculum ) ; } JSONArray eduActivities = ( JSONArray ) data . get ( "activities" ) ; for ( int i = 0 ; i < eduActivities . size ( ) ; i ++ ) { JSONObject eduActivity = ( JSONObject ) eduActivities . get ( i ) ; String activityName = ( String ) eduActivity . get ( "activityName" ) ; String activityType = ( String ) eduActivity . get ( "activityType" ) ; EduActivityType eduType = null ; if ( activityType . equals ( "lecture" ) ) eduType = EduActivityType . LECTURE ; else eduType = EduActivityType . SEMINAR ; EduActivities activity = new EduActivities ( activityName , eduType ) ; SqlInsert . insertEduActivities ( activity , student , studentCurriculum ) ; } JSONArray artisticEvents = ( JSONArray ) data . get ( "events" ) ; for ( int i = 0 ; i < artisticEvents . size ( ) ; i ++ ) { JSONObject artEvent = ( JSONObject ) artisticEvents . get ( i ) ; String eventName = ( String ) artEvent . get ( "eventName" ) ; String eventDate = ( String ) artEvent . get ( "eventDate" ) ; ArtisticEvents event = new ArtisticEvents ( eventDate , eventName ) ; SqlInsert . insertArtisticEvents ( event , student , studentCurriculum ) ; } JSONArray scientificProds = ( JSONArray ) data . get ( "productions" ) ; for ( int i = 0 ; i < scientificProds . size ( ) ; i ++ ) { JSONObject scProd = ( JSONObject ) scientificProds . get ( i ) ; String productionName = ( String ) scProd . get ( "productionName" ) ; String productionType = ( String ) scProd . get ( "productionType" ) ; ScientificProductions production = new ScientificProductions ( productionName , productionType ) ; SqlInsert . insertScProd ( production , student , studentCurriculum ) ; } }
tr	3	public void refreshTextList ( ) { ground . remove ( textpane ) ; textpane = null ; resultSets = connector . getAllResultSets ( userID ) ; Iterator < ? > result = resultSets . iterator ( ) ; dataname . clear ( ) ; if ( result != null ) { while ( result . hasNext ( ) ) { ResultSet temp_res = ( ResultSet ) result . next ( ) ; resultmapper . put ( temp_res . getDocument ( ) . getFileName ( ) , ( ResultSet ) temp_res ) ; dataname . addElement ( temp_res . getDocument ( ) . getFileName ( ) ) ; } textpane = new JScrollPane ( texte ) ; textpane . setLocation ( 280 , 50 ) ; textpane . setSize ( 180 , 300 ) ; textpane . setVisible ( true ) ; texte . setVisible ( true ) ; ground . add ( textpane ) ; textpane . repaint ( ) ; ground . repaint ( ) ; } }
tr	0	public static BasicRelation getEquivalenceRelation ( ) { BasicRelation rel = new BasicRelation ( "=" ) ; return rel ; }
tr	8	private int getKingAxisVal ( int loc ) { switch ( loc ) { case 0 : case 7 : return - 4 ; case 1 : case 6 : return - 2 ; case 2 : case 5 : return 2 ; case 3 : case 4 : return 4 ; default : return 0 ; } }
tr	7	private static void test2_4 ( ) throws FileNotFoundException { String test1 = "new game\n" + "examine room\n" + "quit\n" + "yes\n" ; HashMap < Integer , String > output = new HashMap < Integer , String > ( ) ; boolean passed = true ; try { in = new ByteArrayInputStream ( test1 . getBytes ( ) ) ; System . setIn ( in ) ; out = new PrintStream ( "testing.txt" ) ; System . setOut ( out ) ; Game . main ( null ) ; } catch ( ExitException se ) { } catch ( Exception e ) { System . setOut ( stdout ) ; System . out . println ( "Error: " ) ; e . printStackTrace ( ) ; passed = false ; } finally { System . setOut ( stdout ) ; @ SuppressWarnings ( "resource" ) Scanner sc = new Scanner ( new File ( "testing.txt" ) ) ; ArrayList < String > testOutput = new ArrayList < String > ( ) ; while ( sc . hasNextLine ( ) ) { testOutput . add ( sc . nextLine ( ) ) ; } output . put ( testOutput . size ( ) - 6 , ">> The prison cell is a cold  dirty place." ) ; output . put ( testOutput . size ( ) - 5 , "The only light in the room filters through the bars in the cell door." ) ; output . put ( testOutput . size ( ) - 4 , "On the ground there is a: cell key." ) ; output . put ( testOutput . size ( ) - 3 , "The guard walks toward your cell." ) ; output . put ( testOutput . size ( ) - 2 , ">> Are you sure you want to quit? (y/n)" ) ; output . put ( testOutput . size ( ) - 1 , ">>" ) ; if ( passed ) { for ( Map . Entry < Integer , String > entry : output . entrySet ( ) ) { if ( ! testOutput . get ( entry . getKey ( ) ) . equals ( entry . getValue ( ) ) ) { passed = false ; System . out . println ( "test2_4 failed: Line " + entry . getKey ( ) ) ; System . out . println ( "\tExpected: " + entry . getValue ( ) ) ; System . out . println ( "\tReceived: " + testOutput . get ( entry . getKey ( ) ) ) ; } } if ( passed ) { System . out . println ( "test2_4 passed" ) ; } } else { System . out . println ( "test2_4 failed: error" ) ; } } }
tr	3	String txtToken ( int token ) { switch ( token ) { case TK_NAME : case TK_STRING : case TK_NUMBER : return new String ( buff , 0 , nbuff ) ; default : return token2str ( token ) ; } }
tr	2	private void updateTableColumn ( int column , int width ) { final TableColumn tableColumn = table . getColumnModel ( ) . getColumn ( column ) ; if ( ! tableColumn . getResizable ( ) ) return ; width += spacing ; if ( isOnlyAdjustLarger ) { width = Math . max ( width , tableColumn . getPreferredWidth ( ) ) ; } columnSizes . put ( tableColumn , new Integer ( tableColumn . getWidth ( ) ) ) ; table . getTableHeader ( ) . setResizingColumn ( tableColumn ) ; tableColumn . setWidth ( width ) ; }
tr	2	ArrayList < Object [ ] > getPickerArgs ( ) { ArrayList < Object [ ] > pickerArgs = new ArrayList < Object [ ] > ( ) ; if ( this . pickers > 0 ) { Pickers pickers = this . warehouse . getPickers ( ) ; ArrayList < Picker > rl = pickers . getPickerList ( ) ; for ( Picker r : rl ) { Object [ ] args = new Object [ 1 ] ; args [ 0 ] = r . getUID ( ) ; pickerArgs . add ( args ) ; } } return pickerArgs ; }
tr	0	public static void main ( String [ ] args ) { List < Integer > set = new ArrayList < > ( ) ; set . add ( - 7 ) ; set . add ( - 3 ) ; set . add ( - 2 ) ; set . add ( 5 ) ; set . add ( 8 ) ; System . out . println ( getSubsets ( set , 0 ) ) ; set = new ArrayList < > ( ) ; set . add ( 2 ) ; set . add ( 3 ) ; set . add ( 6 ) ; set . add ( 8 ) ; System . out . println ( getSubsets ( set , 11 ) ) ; }
tr	8	public void filtrarContratosActivos ( ) { try { String filtro = panelAdminContratos . getTextoFiltro ( ) ; int tipoFiltro = panelAdminContratos . getTipoFiltro ( ) ; if ( ! filtro . trim ( ) . equals ( "" ) ) { if ( tipoFiltro == Contrato . FILTRO_ID_DUENIO || tipoFiltro == Contrato . FILTRO_ID_HABITANTE || tipoFiltro == Contrato . FILTRO_ID_RESPONSABLE ) { long id = long . parseLong ( filtro ) ; ArrayList < Contrato > lista = Contrato . getListaContratosFiltro ( Contrato . CONTRATOS_ACTIVOS , tipoFiltro , id , "" ) ; panelAdminContratos . setListaContratos ( lista ) ; } else if ( tipoFiltro == Contrato . FILTRO_NOMBRE_DUENIO || tipoFiltro == Contrato . FILTRO_NOMBRE_HABITANTE || tipoFiltro == Contrato . FILTRO_NOMBRE_RESPONSABLE ) { ArrayList < Contrato > lista = Contrato . getListaContratosFiltro ( Contrato . CONTRATOS_ACTIVOS , tipoFiltro , - 1 , filtro ) ; panelAdminContratos . setListaContratos ( lista ) ; } } else { cargarContratosActivos ( ) ; } } catch ( NumberFormatException ex ) { JOptionPane . showMessageDialog ( panelAdminContratos , "Error num\u00E9rico al buscar por el n\u00FAmero de id" , "Error num\u00E9rico" , JOptionPane . ERROR_MESSAGE ) ; } }
tr	3	public static void main ( String [ ] args ) { final int [ ] subscripts = new int [ ] { 1 , 10 , 100 , 1000 , 10000 , 100000 , 1000000 } ; final int last = subscripts [ subscripts . length - 1 ] ; String s = null ; long p = 1 ; int ls = 0 ; int j = 0 ; int l = 0 ; for ( int i = 1 ; i < 1000000 ; i ++ ) { s = String . valueOf ( i ) ; ls = s . length ( ) ; l += ls ; if ( l >= subscripts [ j ] ) { final int n = ls - ( l - subscripts [ j ] ) - 1 ; final int d = Integer . parseInt ( s . substring ( n , n + 1 ) ) ; p *= ( long ) d ; j ++ ; } if ( l > last ) { break ; } } System . out . println ( "# p = " + p ) ; }
tr	3	public JSONWriter object ( ) throws JSONException { if ( this . mode == i ) { this . mode = o ; } if ( this . mode == o || this . mode == a ) { this . append ( "{" ) ; this . push ( new JSONObject ( ) ) ; this . , = false ; return this ; } throw new JSONException ( "Misplaced object." ) ; }
tr	9X	public static void main ( String [ ] args ) { CallParser parser = new CallParser ( ) ; parser . addLine ( 0 , "static sequence [pipe]function" ) ; parser . addLine ( 1 , "[o]:[p] s{var:I32=0}[ss] [s]:[^]a[var33  l] " ) ; parser . addLine ( 2 , "if{[qwerty]:{stuff}[xyz] xyz}: " ) ; parser . addLine ( 3 , "[a]asd[b]op[p]" ) ; parser . addLine ( 4 , ":elseif{something}:" ) ; parser . addLine ( 5 , ":elseif{somethingelse}: " ) ; parser . addLine ( 6 , "static sequence2" ) ; parser . addLine ( 7 , ":end" ) ; parser . addLine ( 8 , "EXECUTE{[a]:[>] [<  \" is sweet\"]PRINTLN  lol}" ) ; for ( Component com : parser . separateComponents ( ) ) System . out . print ( com . type + " " ) ; System . out . println ( ) ; parser . parse ( ) ; int indent = 0 ; for ( ParsedCall call : parser . calls ) { if ( call . isBlockEnd ) { indent -- ; } for ( int ind = 0 ; ind < indent ; ind ++ ) { System . out . print ( "  " ) ; } if ( call . isBlockEnd ) System . out . print ( ":" ) ; System . out . print ( "[" ) ; for ( String param : call . inParams ) { System . out . print ( param + " " ) ; } System . out . print ( "]" ) ; System . out . print ( call . callName ) ; if ( call . confNodes . length > 0 ) { System . out . print ( "{ " ) ; for ( String param : call . confNodes ) { System . out . print ( param + " " ) ; } System . out . print ( "}" ) ; } System . out . print ( "[" ) ; for ( String param : call . outParams ) { System . out . print ( param + " " ) ; } System . out . print ( "]" ) ; if ( call . isBlockStart ) { indent ++ ; System . out . print ( ":" ) ; } System . out . println ( ) ; } }
tr	4	public String getColumnName ( int c ) { switch ( c ) { case COL_RANK : return "#" ; case COL_NAME : return "Name" ; case COL_PRESENT : return "Present" ; case COL_BIDS : return "Bids" ; default : return "" ; } }
tr	0	public List < Calificacion > getCalificaciones ( ) { return calificaciones ; }
