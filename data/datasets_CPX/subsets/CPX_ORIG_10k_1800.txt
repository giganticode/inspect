tr	8	public BinaryStrings ( double mutationRate , double recombinationRate , int recombinationSplit , int maxMutations ) { try { if ( recombinationRate > 1.0 || recombinationRate < 0.0 ) { throw new Exception ( "Crossover rate outside range 0.0-1.0" ) ; } this . recombinationRate = recombinationRate ; if ( recombinationSplit > 2 || recombinationSplit < 1 ) { throw new Exception ( "Crossover split is outside range  accepted values are 1 and 2  got " + recombinationSplit ) ; } this . recombinationSplit = recombinationSplit ; if ( mutationRate > 1.0 || mutationRate < 0.0 ) { throw new Exception ( "Mutation rate outside range 0.0-1.0" ) ; } this . mutationRate = mutationRate ; if ( maxMutations < 1 ) throw new Exception ( "Can't have 0 or negative mutations!" ) ; this . maxMutations = maxMutations ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; } }
tr	9	private void btnLaunchActionPerformed ( java . awt . event . ActionEvent evt ) { if ( this . process != null ) { this . expectExit = true ; this . process . destroy ( ) ; return ; } String osName = System . getProperty ( "os.name" ) . toLowerCase ( ) ; boolean isNix = osName . contains ( "ux" ) || osName . contains ( "ix" ) || osName . contains ( "mac" ) ; String memValue = cbMemory . getSelectedItem ( ) . toString ( ) ; String screenWidth = txtWidth . getText ( ) ; String screenHeight = txtHeight . getText ( ) ; if ( ! isValidInteger ( memValue ) ) { JOptionPane . showMessageDialog ( this , "Invalid memory value specified!" , "Launch error" , JOptionPane . ERROR_MESSAGE ) ; return ; } if ( ! isValidInteger ( screenWidth ) || ! isValidInteger ( screenWidth ) ) { JOptionPane . showMessageDialog ( this , "Invalid screen width/height specified!" , "Launch error" , JOptionPane . ERROR_MESSAGE ) ; return ; } String launchCommand = LaunchCommandBuilder . getLaunchCommand ( this . loggedUsername , this . session , memValue , screenWidth , screenHeight ) ; String gameDir = ConfigManager . getInstance ( ) . pathToJar ; if ( this . syncState != SyncState . COMPLETE ) { if ( JOptionPane . showConfirmDialog ( this , "Synchronization with server isn't done.\nAre you sure to launch unsynchronized client?" , "Client not synchronized" , JOptionPane . OK_CANCEL_OPTION , JOptionPane . QUESTION_MESSAGE ) == JOptionPane . CANCEL_OPTION ) { return ; } } if ( this . currentState != LauncherState . LOGGED_IN ) { if ( JOptionPane . showConfirmDialog ( this , "You are not logged in. If you launch game without login you can't join the Kubach servers.\nAre you sure to launch client without login?" , "You are not logged in" , JOptionPane . OK_CANCEL_OPTION , JOptionPane . QUESTION_MESSAGE ) == JOptionPane . CANCEL_OPTION ) { return ; } } final String SCRIPT_NAME = "launch.sh" ; if ( isNix ) { try { String scriptPath = gameDir + File . separator + SCRIPT_NAME ; Files . write ( Paths . get ( scriptPath ) , ( "#!/bin/sh\n" + "cd \"" + gameDir + "\"\n" + launchCommand ) . getBytes ( "UTF-8" ) , ( new File ( scriptPath ) . exists ( ) ) ? StandardOpenOption . WRITE : StandardOpenOption . CREATE_NEW ) ; launchCommand = "sh " + SCRIPT_NAME ; } catch ( IOException ex ) { ex . printStackTrace ( ) ; } } Process proc ; try { proc = new ProcessBuilder ( launchCommand . split ( " " ) ) . directory ( new File ( gameDir ) ) . start ( ) ; } catch ( IOException ex ) { JOptionPane . showMessageDialog ( this , "Unable to start process: " + ex . toString ( ) , "Launch error" , JOptionPane . ERROR_MESSAGE ) ; return ; } StreamGobbler errorGobbler = new StreamGobbler ( proc . getErrorStream ( ) ) ; StreamGobbler outputGobbler = new StreamGobbler ( proc . getInputStream ( ) ) ; errorGobbler . start ( ) ; outputGobbler . start ( ) ; ConfigManager . getInstance ( ) . getProperties ( ) . setProperty ( "memory" , memValue ) ; ConfigManager . getInstance ( ) . saveProperties ( ) ; ConfigManager . getInstance ( ) . setResolution ( screenWidth , screenHeight ) ; if ( ! isNix ) { this . process = proc ; this . expectExit = false ; btnLaunch . setText ( "Kill" ) ; ProcessMonitorWorker pmw = new ProcessMonitorWorker ( this , this . process ) ; pmw . execute ( ) ; } }
tr	6	private void initButtons ( ) { buttons = new JPanel ( ) ; buttons . setMinimumSize ( new Dimension ( 70 , 75 + design . getHeight ( ) ) ) ; buttons . setBackground ( Color . black ) ; noTerrain = new JButton ( ) ; noTerrain . setText ( "Canyon" ) ; noTerrain . setMargin ( new Insets ( 0 , 0 , 0 , 0 ) ) ; noTerrain . setFont ( new Font ( "Consolas" , 0 , 9 ) ) ; noTerrain . setForeground ( Color . LIGHT_GRAY ) ; noTerrain . setBackground ( Color . black ) ; noTerrain . setMinimumSize ( new Dimension ( 40 , 40 ) ) ; noTerrain . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent evt ) { type = - 1 ; } } ) ; terrain0 = new JButton ( ) ; terrain0 . setText ( "Road" ) ; terrain0 . setMargin ( new Insets ( 0 , 0 , 0 , 0 ) ) ; terrain0 . setFont ( new Font ( "Consolas" , 0 , 9 ) ) ; terrain0 . setForeground ( Color . BLACK ) ; terrain0 . setBackground ( Color . LIGHT_GRAY ) ; terrain0 . setMinimumSize ( new Dimension ( 40 , 40 ) ) ; terrain0 . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent evt ) { type = 0 ; unitButtons . deselect ( ) ; } } ) ; terrain1 = new JButton ( ) ; terrain1 . setText ( "Grass" ) ; terrain1 . setMargin ( new Insets ( 0 , 0 , 0 , 0 ) ) ; terrain1 . setFont ( new Font ( "Consolas" , 0 , 9 ) ) ; terrain1 . setForeground ( Color . BLACK ) ; terrain1 . setBackground ( new Color ( 100 , 150 , 0 ) ) ; terrain1 . setMinimumSize ( new Dimension ( 40 , 40 ) ) ; terrain1 . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent evt ) { type = 1 ; unitButtons . deselect ( ) ; } } ) ; terrain2 = new JButton ( ) ; terrain2 . setText ( "Hills" ) ; terrain2 . setMargin ( new Insets ( 0 , 0 , 0 , 0 ) ) ; terrain2 . setFont ( new Font ( "Consolas" , 0 , 9 ) ) ; terrain2 . setForeground ( Color . BLACK ) ; terrain2 . setBackground ( new Color ( 100 , 100 , 0 ) ) ; terrain2 . setMinimumSize ( new Dimension ( 40 , 40 ) ) ; terrain2 . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent evt ) { type = 2 ; unitButtons . deselect ( ) ; } } ) ; terrain3 = new JButton ( ) ; terrain3 . setText ( "Forest" ) ; terrain3 . setMargin ( new Insets ( 0 , 0 , 0 , 0 ) ) ; terrain3 . setFont ( new Font ( "Consolas" , 0 , 9 ) ) ; terrain3 . setForeground ( Color . BLACK ) ; terrain3 . setBackground ( new Color ( 0 , 125 , 0 ) ) ; terrain3 . setMinimumSize ( new Dimension ( 40 , 40 ) ) ; terrain3 . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent evt ) { type = 3 ; unitButtons . deselect ( ) ; } } ) ; terrain4 = new JButton ( ) ; terrain4 . setText ( "Mountain" ) ; terrain4 . setMargin ( new Insets ( 0 , 0 , 0 , 0 ) ) ; terrain4 . setFont ( new Font ( "Consolas" , 0 , 8 ) ) ; terrain4 . setForeground ( Color . lightGray ) ; terrain4 . setBackground ( new Color ( 0 , 65 , 0 ) ) ; terrain4 . setMinimumSize ( new Dimension ( 40 , 40 ) ) ; terrain4 . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent evt ) { type = 4 ; unitButtons . deselect ( ) ; } } ) ; blueBase = new JButton ( ) ; blueBase . setIcon ( new ImageIcon ( ModelManager . getModel ( "BlueBase" ) . getImage ( ) . getScaledInstance ( 32 , 22 , java . awt . Image . SCALE_SMOOTH ) ) ) ; blueBase . setMargin ( new Insets ( 0 , 0 , 0 , 0 ) ) ; blueBase . setMaximumSize ( new Dimension ( 40 , 40 ) ) ; blueBase . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent evt ) { type = 5 ; unitButtons . deselect ( ) ; } } ) ; redBase = new JButton ( ) ; redBase . setIcon ( new ImageIcon ( ModelManager . getModel ( "RedBase" ) . getImage ( ) . getScaledInstance ( 32 , 22 , java . awt . Image . SCALE_SMOOTH ) ) ) ; redBase . setMargin ( new Insets ( 0 , 0 , 0 , 0 ) ) ; redBase . setMaximumSize ( new Dimension ( 40 , 40 ) ) ; redBase . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent evt ) { type = 6 ; unitButtons . deselect ( ) ; } } ) ; factory = new JButton ( ) ; factory . setIcon ( new ImageIcon ( ModelManager . getModel ( "Factory" ) . getImage ( ) . getScaledInstance ( 32 , 22 , java . awt . Image . SCALE_SMOOTH ) ) ) ; factory . setBackground ( Color . LIGHT_GRAY ) ; factory . setMargin ( new Insets ( 0 , 0 , 0 , 0 ) ) ; factory . setMaximumSize ( new Dimension ( 40 , 40 ) ) ; factory . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent evt ) { type = 7 ; unitButtons . deselect ( ) ; } } ) ; teamFactory = new JButton ( ) ; teamFactory . setIcon ( new ImageIcon ( ModelManager . getModel ( "Factory" ) . getImage ( ) . getScaledInstance ( 32 , 22 , java . awt . Image . SCALE_SMOOTH ) ) ) ; teamFactory . setBackground ( Color . BLUE ) ; teamFactory . setMargin ( new Insets ( 0 , 0 , 0 , 0 ) ) ; teamFactory . setMaximumSize ( new Dimension ( 40 , 40 ) ) ; teamFactory . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent evt ) { type = team ? 8 : 9 ; unitButtons . deselect ( ) ; } } ) ; blueTeam = new JRadioButton ( ) ; blueTeam . setText ( "Blue" ) ; blueTeam . setFont ( new Font ( "Consolas" , 0 , 9 ) ) ; blueTeam . setBackground ( Color . BLACK ) ; blueTeam . setForeground ( Color . LIGHT_GRAY ) ; blueTeam . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent evt ) { team = true ; unitButtons . changeTeam ( true ) ; teamFactory . setBackground ( Color . BLUE ) ; redTeam . setSelected ( false ) ; } } ) ; redTeam = new JRadioButton ( ) ; redTeam . setText ( "Red" ) ; redTeam . setFont ( new Font ( "Consolas" , 0 , 9 ) ) ; redTeam . setBackground ( Color . BLACK ) ; redTeam . setForeground ( Color . LIGHT_GRAY ) ; redTeam . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent evt ) { team = false ; unitButtons . changeTeam ( false ) ; teamFactory . setBackground ( Color . red ) ; blueTeam . setSelected ( false ) ; } } ) ; unitButtons = new UnitButtonsPanel ( ) ; unitButtons . setMaximumSize ( new Dimension ( 100 , 0 ) ) ; save = new JButton ( ) ; save . setText ( "Save" ) ; save . setBackground ( Color . BLACK ) ; save . setForeground ( Color . LIGHT_GRAY ) ; save . setFont ( new Font ( "Consolas" , 0 , 16 ) ) ; save . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent evt ) { if ( LocationManager . getBase ( true ) == null || LocationManager . getBase ( false ) == null ) { JOptionPane . showMessageDialog ( design , "Base Missing" ) ; return ; } String mapName = JOptionPane . showInputDialog ( "Map Name?" ) ; if ( mapName == null || mapName . equals ( "" ) ) { JOptionPane . showMessageDialog ( design , "Invalid Name" ) ; return ; } try { LocationManager . saveMap ( mapName ) ; JOptionPane . showMessageDialog ( design , "Map " + mapName + " saved." ) ; } catch ( Exception e ) { JOptionPane . showMessageDialog ( design , "Error occurred: " + e . toString ( ) ) ; } } } ) ; random = new JButton ( ) ; random = new JButton ( ) ; random . setText ( "Random" ) ; random . setBackground ( Color . BLACK ) ; random . setForeground ( Color . LIGHT_GRAY ) ; random . setFont ( new Font ( "Consolas" , 0 , 16 ) ) ; random . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent evt ) { LocationManager . generateMap ( LocationManager . getSize ( ) . x , LocationManager . getSize ( ) . y ) ; render ( ) ; } } ) ; }
tr	0	public String getFirstName ( ) { return firstName ; }
tr	0	public void setTotal ( int total ) { this . total = total ; }
tr	3	private String parseReadabilityText ( ResultSet rs ) { try { int contractor = rs . getInt ( "contractor" ) ; String text = rs . getString ( "blurb" ) ; Readability r = new Readability ( text ) ; if ( text . contains ( "[a-z]+" ) ) { double ari = null ; try { ari = r . getARI ( ) ; } catch ( NumberFormatException e ) { System . out . println ( text ) ; System . out . println ( "Smog:" + r . getSMOG ( ) ) ; } String insertString = "('" + contractor + "' '" + r . getSMOG ( ) + "' '" + ari + "' '" + r . getColemanLiau ( ) + "' '" + r . getFleschKincaidGradeLevel ( ) + "' '" + r . getGunningFog ( ) + "' '" + r . getSMOGIndex ( ) + "' '" + r . getCharacters ( ) + "' '" + r . getWords ( ) + "' '" + r . getSentences ( ) + "' '" + r . getSyllables ( ) + "' '" + r . getComplex ( ) + "')" ; return insertString ; } else return "('" + contractor + "' '" + - 1 + "' '" + 0 + "' '" + 0 + "' '" + 0 + "' '" + 0 + "' '" + 0 + "' '" + 0 + "' '" + 0 + "' '" + 0 + "' '" + 0 + "' '" + 0 + "')" ; } catch ( SQLException e ) { e . printStackTrace ( ) ; return "" ; } }
tr	9	private void initBlock ( ) { char magic1 , magic2 , magic3 , magic4 ; char magic5 , magic6 ; magic1 = bsGetUChar ( ) ; magic2 = bsGetUChar ( ) ; magic3 = bsGetUChar ( ) ; magic4 = bsGetUChar ( ) ; magic5 = bsGetUChar ( ) ; magic6 = bsGetUChar ( ) ; if ( magic1 == 17 && magic2 == 72 && magic3 == 45 && magic4 == 38 && magic5 == 50 && magic6 == 90 ) { complete ( ) ; return ; } if ( magic1 != 31 || magic2 != 41 || magic3 != 59 || magic4 != 26 || magic5 != 53 || magic6 != 59 ) { badBlockHeader ( ) ; streamEnd = true ; return ; } storedBlockCRC = bsGetInt32 ( ) ; if ( bsR ( 1 ) == 1 ) { blockRandomised = true ; } else { blockRandomised = false ; } getAndMoveToFrontDecode ( ) ; mCrc . initialiseCRC ( ) ; currentState = START_BLOCK_STATE ; }
tr	7	private void modify ( ) { delete ( ) ; modifiedObjectLoc = selectedObject . getLocationCopy ( ) ; switch ( selectedObject . getObjectType ( ) ) { case default : break ; case SHAPE : new ShapeMaker ( ( MainFrame ) frame , selectedObject ) ; break ; case RECTANGLE : new RectangleMaker ( ( MainFrame ) frame , selectedObject ) ; break ; case ELLIPSE : new EllipseMaker ( ( MainFrame ) frame , selectedObject ) ; break ; case TEXT : new TextMaker ( ( MainFrame ) frame , ( Text ) selectedObject ) ; break ; case IMAGE : image ( ) ; break ; case LATEX : latex ( ) ; } }
tr	1	public Set < State > delta ( String word ) { Set < State > front = new HashSet < State > ( ) ; front . add ( I ) ; for ( int t = 0 ; t < word . length ( ) ; ++ t ) { Character c = word . charAt ( t ) ; front = delta ( front , c ) ; } return front ; }
tr	4	public void valueChanged ( ListSelectionEvent e ) { if ( ! e . getValueIsAdjusting ( ) ) { if ( this . MAPanel . getSelectedIndex ( ) == 0 && patientList . getSelectedIndex ( ) >= 0 && e . getSource ( ) == patientList ) { String st = patientList . getSelectedValue ( ) . toString ( ) ; function . patientInfoByItem ( actPatient , st , patientTF , tpPresciption , null ) ; patientid = function . patientInfoByItem ( actPatient , st , patientTF , tpPresciption , null ) ; this . function . fillTests ( tests , patientid ) ; this . function . testListMA ( tests , listModel2 ) ; } } }
tr	0	@ Override public void mouseMoved ( MouseEvent e ) { updateWidgets ( e ) ; }
tr	3	public static Set < Set < Mission >> clusterMissions ( Set < Mission > missions ) { Set < Set < Mission >> clusters = new HashSet < Set < Mission >> ( ) ; Set < Mission > unclustered_missions = EnumSet . copyOf ( missions ) ; while ( ! unclustered_missions . isEmpty ( ) ) { Iterator < Mission > i = unclustered_missions . iterator ( ) ; Mission m = i . next ( ) ; Set < Mission > cluster = EnumSet . of ( m ) ; i . remove ( ) ; while ( i . hasNext ( ) ) { Mission n = i . next ( ) ; if ( lineIntersect ( m , n ) ) { cluster . add ( n ) ; i . remove ( ) ; } } clusters . add ( cluster ) ; } return clusters ; }
tr	7	public ArrayList < PHASE > phasePossible ( PHASE phase ) { ArrayList < PHASE > a_faire = new ArrayList < PHASE > ( ) ; switch ( phase ) { case DEMARRAGE : if ( this . phase_prete != PHASE . CALCUL_TRAJECTOIRES ) a_faire . add ( PHASE . CALCUL_TRAJECTOIRES ) ; else break ; case CALCUL_TRAJECTOIRES : if ( this . phase_prete != PHASE . CHARGEMENT_AVION ) a_faire . add ( PHASE . CHARGEMENT_AVION ) ; else break ; case CHARGEMENT_AVION : if ( this . balises . isEmpty ( ) ) a_faire . add ( PHASE . CHARGEMENT_BALISES ) ; if ( this . aerodromes . isEmpty ( ) ) a_faire . add ( PHASE . CHARGEMENT_AD ) ; break ; default : break ; } return a_faire ; }
tr	9	public String toUpdateKML ( boolean suppressEnclosingTags ) { if ( ! isDirty ( ) ) { return "" ; } String change = "" ; boolean isPrimDirty = isPrimitiveDirty ( ) ; if ( isPrimDirty && ! suppressEnclosingTags ) { change += "<Orientation" ; if ( this . id != null ) { change += " id=\"" + this . getId ( ) + "\"" ; } if ( this . targetId != null ) { change += " targetId=\"" + this . getTargetId ( ) + "\"" ; } change += ">\n" ; } change += super . toUpdateKML ( true ) ; if ( this . isHeadingDirty ) { change += "<heading>" + this . heading + "</heading>\n" ; this . isHeadingDirty = false ; } if ( this . isTiltDirty ) { change += "<tilt>" + this . tilt + "</tilt>\n" ; this . isTiltDirty = false ; } if ( this . isRollDirty ) { change += "<roll>" + this . roll + "</roll>\n" ; this . isRollDirty = false ; } if ( isPrimDirty && ! suppressEnclosingTags ) { change += "</Orientation>\n" ; } setNotDirty ( ) ; return change ; }
tr	5	TaskControlBlock run ( Packet packet ) { if ( packet != null ) { if ( packet . kind == Richards . KIND_WORK ) { v1 = packet . addTo ( v1 ) ; } else { v2 = packet . addTo ( v2 ) ; } } if ( v1 != null ) { int count = v1 . a1 ; Packet v ; if ( count < Richards . DATA_SIZE ) { if ( v2 != null ) { v = v2 ; v2 = v2 . link ; v . a1 = v1 . a2 [ count ] ; v1 . a1 = count + 1 ; return scheduler . queue ( v ) ; } } else { v = v1 ; v1 = v1 . link ; return scheduler . queue ( v ) ; } } return scheduler . suspendCurrent ( ) ; }
tr	2	private void traversal ( final TreeNode t , final List < long > list ) { if ( t . left != null ) { traversal ( t . left , list ) ; list . add ( t . value ) ; if ( t . right != null ) { traversal ( t . right , list ) ; } } }
tr	1	public static ServiceFactory getInstance ( ) { if ( instance == null ) instance = new ServiceFactory ( ) ; return instance ; }
tr	9	private Hashtable < Character , String > build_box ( int [ ] perm , String k ) { int [ ] row = new int [ 2 ] ; row [ 0 ] = perm [ 0 ] ; row [ 1 ] = perm [ 1 ] ; int [ ] col = new int [ 8 ] ; for ( int i = 0 ; i < 8 ; i ++ ) { col [ i ] = perm [ i + 2 ] ; } boolean [ ] filled = new boolean [ 26 ] ; String k_u = k . toUpperCase ( ) ; Hashtable < Character , String > result = new Hashtable < Character , String > ( ) ; int cur_row = 0 ; int cur_col = 0 ; for ( int i = 0 ; i < k_u . length ( ) ; i ++ ) { char cur_c = k_u . charAt ( i ) ; if ( cur_c == J ) { cur_c = I ; } else if ( cur_c == Z ) { cur_c = Y ; } int pos = cur_c - A ; if ( ! filled [ pos ] ) { String r ; if ( cur_row == 0 ) { r = Integer . toString ( col [ cur_col ] ) ; } else { r = Integer . toString ( row [ cur_row - 1 ] ) + Integer . toString ( col [ cur_col ] ) ; } result . put ( Character . valueOf ( cur_c ) , r ) ; if ( cur_col == 7 ) { cur_row ++ ; cur_col = 0 ; } else { cur_col ++ ; } filled [ pos ] = true ; } } for ( int i = 0 ; i < 26 ; i ++ ) { if ( i == 25 || i == 9 ) continue ; if ( ! filled [ i ] ) { String r ; if ( cur_row == 0 ) { r = Integer . toString ( col [ cur_col ] ) ; } else { r = Integer . toString ( row [ cur_row - 1 ] ) + Integer . toString ( col [ cur_col ] ) ; } char cur_c = ( char ) ( A + i ) ; result . put ( Character . valueOf ( cur_c ) , r ) ; if ( cur_col == 7 ) { cur_row ++ ; cur_col = 0 ; } else { cur_col ++ ; } filled [ i ] = true ; } } return result ; }
tr	0	public java . awt . Frame getFrame ( ) { return parent ; }
tr	6	public static void setMultiMode ( PlacementMode mode , SecurityLevel securityLevel , String [ ] args , Player player , PlayerState state ) { if ( ! MULTI_MODE . contains ( mode ) ) return ; if ( state . getMode ( ) == mode && state . getSecurityLevel ( ) == securityLevel ) { state . reset ( ) ; sendMessage ( player , ChatColor . GREEN , "%s mode off" , mode . name ( ) ) ; } else { state . setMode ( mode ) ; state . setSecurityLevel ( securityLevel ) ; switch ( mode ) { case REINFORCEMENT : sendMessage ( player , ChatColor . GREEN , "%s mode %s" , mode . name ( ) , securityLevel . name ( ) ) ; break ; case FORTIFICATION : sendMessage ( player , ChatColor . GREEN , "%s mode %s  %s" , mode . name ( ) , state . getReinforcementMaterial ( ) . getMaterial ( ) . name ( ) , securityLevel . name ( ) ) ; break ; case INFO : sendMessage ( player , ChatColor . GREEN , "%s mode on" , mode . name ( ) ) ; break ; } state . checkResetMode ( ) ; } }
tr	3	public void addAll ( Collection < ? extends PersonalData > values ) { if ( values != null ) for ( PersonalData data : values ) { add ( data ) ; } }
tr	8	public static String formatName ( String name ) { if ( name . length ( ) > 0 ) { char characters [ ] = name . toCharArray ( ) ; for ( int c = 0 ; c < characters . length ; c ++ ) if ( characters [ c ] == _ ) { characters [ c ] =   ; if ( c + 1 < characters . length && characters [ c + 1 ] >= a && characters [ c + 1 ] <= z ) characters [ c + 1 ] = ( char ) ( ( characters [ c + 1 ] + 65 ) - 97 ) ; } if ( characters [ 0 ] >= a && characters [ 0 ] <= z ) characters [ 0 ] = ( char ) ( ( characters [ 0 ] + 65 ) - 97 ) ; return new String ( characters ) ; } else { return name ; } }
tr	6	public Solution backtrackingSearchMRV ( final PartialAssignment assign , final DomainList domainlist ) { count = count + 1 ; PartialAssignment pa = ( PartialAssignment ) assign . clone ( ) ; ArrayList < Integer > unassignedVars = pa . getUnassignedVariables ( ) ; if ( unassignedVars . size ( ) == 0 ) { if ( checkAssignment ( pa ) ) { System . out . println ( "SOLUTION:" ) ; Map < String , String > result = pa . prettyPrint ( variableNames , valueNames ) ; return new Solution ( true , result ) ; } else { return new Solution ( false , null ) ; } } else { Solution solutionFound = new Solution ( false , null ) ; int variable = unassignedVars . get ( 0 ) ; int size = Integer . MAX_VALUE ; for ( Integer v : unassignedVars ) { if ( domainlist . getValues ( v ) . size ( ) < size ) { size = domainlist . getValues ( v ) . size ( ) ; variable = v ; } } for ( Integer value : domainlist . getValues ( variable ) ) { if ( ! solutionFound . value ) { pa . set ( variable , value ) ; DomainList newdomainlist = forwardCheck ( variable , value , pa , domainlist ) ; solutionFound = backtrackingSearchMRV ( pa , newdomainlist ) ; } } return solutionFound ; } }
tr	1	public static final int setBit ( int data , int bit , boolean value ) { return value ? data | ( 01 << bit ) : ( data & ~ ( 01 << bit ) ) ; }
tr	4	@ Override public synchronized void log ( Object message , Throwable t , Level level ) { if ( level . isGreaterOrEqualThan ( logLevel ) ) { if ( message != null ) { System . out . println ( String . format ( messageTemplate , level . toString ( ) , message . toString ( ) ) ) ; } if ( t != null ) { System . out . println ( String . format ( messageTemplate , level . toString ( ) , t . toString ( ) ) ) ; for ( StackTraceElement elemet : t . getStackTrace ( ) ) { System . out . println ( String . format ( messageTemplate , level . toString ( ) , elemet . toString ( ) ) ) ; } } } }
tr	4	void onMouseHover ( int entered ) { switch ( entered ) { case GL_TRUE : for ( MouseHoverEvent e : _mouseHoverIn ) { e . run ( ) ; } break ; case GL_FALSE : for ( MouseHoverEvent e : _mouseHoverOut ) { e . run ( ) ; } break ; } }
tr	3	public boolean equals ( Object obj ) { boolean returnMe = true ; if ( ! obj . getClass ( ) . equals ( this . getClass ( ) ) ) { returnMe = false ; } else { if ( docID != ( ( Pair ) obj ) . docID ) { returnMe = false ; } else { if ( score != ( ( Pair ) obj ) . score ) { returnMe = false ; } } } return returnMe ; }
tr	1	private void listSolicitudesMouseClicked ( java . awt . event . MouseEvent evt ) { int no ; no = listSolicitudes . getSelectedIndex ( ) ; int reply = JOptionPane . showConfirmDialog ( null , "Desea agregara a " + listaS . get ( no - 1 ) . nombre + "(" + listaS . get ( no - 1 ) . usuario + ")" , "Solicitud de Amistad" , JOptionPane . YES_NO_OPTION ) ; String resp = "<solicitud_amistad>\n" ; if ( reply == JOptionPane . YES_OPTION ) { resp += "<respuesta> Si </respuesta>\n" ; } else { resp += "<respuesta> No </respuesta>\n" ; } usuario usuario = servidor . getUsuario ( txtUser . getText ( ) ) ; resp += "<destinatario>" + listaS . get ( no - 1 ) . usuario + "</destinatario>\n" + "<emisor>\n" + "<usuario>" + txtUser . getText ( ) + "</usuario>\n" + "<nombre> " + usuario . getNombre ( ) + " </nombre>\n" + "</emisor>\n" + "</solicitud_amistad>" ; listaS . remove ( no - 1 ) ; listSolicitudes . updateUI ( ) ; servidor . actualizarSolicitudes2 ( listaS , usuario . getUsername ( ) ) ; writeUTF ( resp ) ; listSolicitudes . repaint ( ) ; System . err . println ( resp ) ; }
tr	1	@ Override public < K , T extends AggregateRoot < K >> void add ( class < T > type , T aggregateRoot ) { if ( ! this . aggregates . containsKey ( aggregateRoot . getId ( ) ) ) { this . aggregates . put ( aggregateRoot . getId ( ) , aggregateRoot ) ; } else { throw new RuntimeException ( "Aggregate with the given id already registred: " + aggregateRoot . getId ( ) ) ; } flushDomainEvents ( aggregateRoot ) ; }
tr	7	private void auswahl ( JButton b ) { b . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent ae ) { int isChecked = 0 ; int position = 0 ; for ( int i = 0 ; i < checkBoxen . size ( ) ; i ++ ) { if ( checkBoxen . get ( i ) . isSelected ( ) ) { isChecked = isChecked + 1 ; position = i ; } } if ( isChecked != 1 ) { System . out . println ( "nur eine Box markieren bitte" ) ; } else { System . out . println ( "Markiert: " + checkBoxen . get ( position ) . getText ( ) ) ; for ( Schoolclass s : schoolclasses ) { if ( s . getName ( ) . equals ( checkBoxen . get ( position ) . getText ( ) ) ) { final SchoolclassFrame schoolclassFrame = new SchoolclassFrame ( s ) ; schoolclassFrame . setLocation ( 275 , 225 ) ; break ; } } for ( Teacher t : teacher ) { if ( t . getAcronym ( ) . equals ( checkBoxen . get ( position ) . getText ( ) ) ) { final TeacherFrame teacherFrame = new TeacherFrame ( t ) ; teacherFrame . setLocation ( 275 , 225 ) ; break ; } } } } } ) ; }
tr	6	private void write ( SelectionKey key ) throws IOException { SocketChannel socketChannel = ( SocketChannel ) key . channel ( ) ; synchronized ( pendingData ) { BlockingQueue < ByteBuffer > queue = pendingData . get ( socketChannel ) ; while ( queue != null && ! queue . isEmpty ( ) ) { ByteBuffer buffer ; try { buffer = queue . take ( ) ; socketChannel . write ( buffer ) ; if ( buffer . remaining ( ) > 0 ) { break ; } queue . remove ( 0 ) ; } catch ( InterruptedException e ) { log . error ( "" , e ) ; } } if ( queue != null && queue . isEmpty ( ) ) { key . interestOps ( SelectionKey . OP_READ ) ; } } }
tr	6	private void jButton1ActionPerformed ( java . awt . event . ActionEvent evt ) { memberId = jTextField1 . getText ( ) ; String query = "select itemsBorrowed from members where MemberId=?" ; try { pst = connection . prepareStatement ( query ) ; pst . setString ( 1 , memberId ) ; rs = pst . executeQuery ( ) ; while ( rs . next ( ) ) { if ( rs . getInt ( "ItemsBorrowed" ) > 0 ) { JOptionPane . showMessageDialog ( null , "There are still some active lendings." + "Member couldn't be deleted" , "Unsubscribe Error Occured" , JOptionPane . WARNING_MESSAGE ) ; } else { String deleteMemberQuery = "delete from members where MemberId=?" ; try { pst = connection . prepareStatement ( deleteMemberQuery ) ; pst . setString ( 1 , memberId ) ; int option = JOptionPane . showConfirmDialog ( null , "Do you really" + " want to delete this Member?" , "Are you sure?" , JOptionPane . YES_OPTION ) ; if ( option == JOptionPane . YES_OPTION ) { pst . execute ( ) ; JOptionPane . showMessageDialog ( null , "Member successfully deleted" , "Finished!" , JOptionPane . WARNING_MESSAGE ) ; jTextField1 . setText ( "" ) ; } } catch ( SQLException e ) { JOptionPane . showMessageDialog ( null , e ) ; } } } } catch ( SQLException e ) { JOptionPane . showMessageDialog ( null , e ) ; } finally { try { rs . close ( ) ; pst . close ( ) ; } catch ( Exception e ) { } } }
tr	5	@ Override public void handleEvent ( IParserEvent event ) { if ( event . getType ( ) == ParserEventType . DOCUMENT_END_EVENT ) { flushEvents ( ) ; event . fire ( listener ) ; } else { IParserEvent lastEvent = events . peekLast ( ) ; if ( lastEvent != null && lastEvent . getType ( ) == ParserEventType . STRING_EVENT && event . getType ( ) == ParserEventType . STRING_EVENT ) { event = mergeStringEvents ( ( StringEvent ) event ) ; } events . add ( event ) ; if ( events . size ( ) > MAX_EVENTS ) { events . removeFirst ( ) . fire ( listener ) ; } } }
tr	2	private void botonEliminarUsuarioActionPerformed ( java . awt . event . ActionEvent evt ) { if ( this . tablaAdministracionUsuarios . getSelectedRow ( ) > - 1 ) { String codigo = ( String ) this . conectorTablaUsuarios . getValueAt ( this . tablaAdministracionUsuarios . getSelectedRow ( ) , 0 ) ; int respuesta = JOptionPane . showConfirmDialog ( this . botonEliminarUsuario , "\u00BFRealmente desea eliminar \n al usuario " + codigo + "?" , "Confirme eliminaci\u00F3n" , JOptionPane . YES_NO_OPTION , JOptionPane . QUESTION_MESSAGE ) ; if ( respuesta == JOptionPane . YES_OPTION ) { Usuario u = this . modeloApp . obtenerUsuarioConCodigo ( codigo ) ; this . modeloApp . eliminarUsuario ( u ) ; this . conectorTablaUsuarios . cargarUsuarios ( ) ; } } else { JOptionPane . showMessageDialog ( this , "Debe seleccionar un\nusuario de la tabla" , "Usuario no seleccionado" , JOptionPane . INFORMATION_MESSAGE ) ; } }
tr	1	public void drawPoint ( Vertex vertex ) { init ( ) ; double x = vertex . getPoint ( ) . getX ( ) * SCALE_X ; double y = vertex . getPoint ( ) . getY ( ) * SCALE_Y ; Ellipse2D el = new Ellipse2D . double ( x - pointSize / 2. , y - pointSize / 2. , pointSize , pointSize ) ; ensureHasSize ( el . getBounds2D ( ) ) ; Graphics2D g = getGraphicsObject ( ) ; g . setStroke ( new BasicStroke ( ( float ) penSize ) ) ; g . setColor ( penColor ) ; g . setColor ( pointFill ) ; g . fill ( el ) ; g . setColor ( pointBorder ) ; g . draw ( el ) ; if ( showVertexNumbers ) g . drawString ( "" + vertex . getVertexIndex ( ) , ( float ) x - 5 , ( float ) y + 5 ) ; repaint ( ) ; }
tr	1	@ Override public Object execute ( HttpServletRequest request , HttpServletResponse response ) throws Exception { Contexto oContexto = ( Contexto ) request . getAttribute ( "contexto" ) ; oContexto . setVista ( "jsp/hilo/form.jsp" ) ; HiloBean oHiloBean ; HiloDao oHiloDao ; oHiloBean = new HiloBean ( ) ; HiloParam oHiloParam = new HiloParam ( request ) ; oHiloBean = oHiloParam . loadId ( oHiloBean ) ; oHiloDao = new HiloDao ( oContexto . getEnumTipoConexion ( ) ) ; try { oHiloBean = oHiloDao . get ( oHiloBean ) ; } catch ( Exception e ) { throw new ServletException ( "HiloController: View Error: Phase 1: " + e . getMessage ( ) ) ; } oHiloBean = oHiloParam . load ( oHiloBean ) ; return oHiloBean ; }
tr	3	public void execute ( String [ ] args ) { if ( userError ( stack , args , 2 , 0 ) ) { try { if ( defines . containsKey ( args [ 1 ] ) ) { stack . push ( defines . get ( args [ 1 ] ) ) ; } else { stack . push ( double . parseDouble ( args [ 1 ] ) ) ; } } catch ( NumberFormatException ex ) { System . out . println ( "ERROR IN PUSH!" ) ; ex . printStackTrace ( ) ; } } }
tr	1	public final void update ( Graphics g ) { if ( graphics == null ) graphics = g ; shouldClearScreen = true ; raiseWelcomeScreen ( ) ; }
tr	7	protected void loadChildren ( MergeSort sorter ) { totalSize = file . length ( ) ; children = createChildren ( null ) ; for ( int counter = children . length - 1 ; counter >= 0 ; counter -- ) { Thread . yield ( ) ; if ( ! children [ counter ] . isLeaf ( ) && ( descendLinks || ! children [ counter ] . isLink ( ) ) ) { children [ counter ] . loadChildren ( sorter ) ; } totalSize += children [ counter ] . totalSize ( ) ; if ( ! isValid ) { counter = 0 ; } } if ( isValid ) { if ( sorter != null ) { sorter . sort ( children ) ; } totalSizeValid = true ; } }
tr	2	public void back ( ) throws JSONException { if ( this . usePrevious || this . index <= 0 ) { throw new JSONException ( "Stepping back two steps is not supported" ) ; } this . index -= 1 ; this . character -= 1 ; this . usePrevious = true ; this . eof = false ; }
tr	7	public void Update ( final PCPanel panel , Graphics graphics ) { if ( Counter < 100 ) { Counter ++ ; panel . Board . DrawBoard ( graphics ) ; panel . AllPellets . DrawAllPellets ( graphics ) ; panel . Blinky . Draw ( graphics ) ; panel . Pinky . Draw ( graphics ) ; panel . Inky . Draw ( graphics ) ; panel . Clyde . Draw ( graphics ) ; graphics . setColor ( Color . RED ) ; graphics . drawString ( "Game Over" , 255 , 395 ) ; } else { try { if ( HighScoresDatabase . IsTopTenScore ( panel . Board . getScore ( ) ) ) { java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { try { new ScoreTextBox ( panel . Board . getScore ( ) , panel ) . setVisible ( true ) ; } catch ( SQLException ex ) { Logger . getLogger ( ScoreTextBox . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( ClassNotFoundException ex ) { Logger . getLogger ( ScoreTextBox . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { Logger . getLogger ( ScoreTextBox . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { Logger . getLogger ( ScoreTextBox . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } } } ) ; } panel . setPanelHighScores ( ) ; } catch ( SQLException ex ) { Logger . getLogger ( PCPanelStateGameOver . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } } Counter ++ ; }
tr	0	@ SuppressWarnings ( "unused" ) private static Polygon getTest3 ( ) { Polygon p = new Polygon ( ) ; p . addPoint ( 0 , new Point ( 10 , 10 ) ) ; p . addPoint ( 0 , new Point ( 15 , 15 ) ) ; p . addPoint ( 0 , new Point ( 20 , 10 ) ) ; p . addPoint ( 0 , new Point ( 25 , 15 ) ) ; p . addPoint ( 0 , new Point ( 30 , 10 ) ) ; p . addPoint ( 0 , new Point ( 15 , 40 ) ) ; return p ; }
tr	0	public ProjectUser ( ) { }
tr	2	public static void initList ( ) throws SlickException { itemList = new HashMap < Integer , String > ( ) ; Type mapType = new TypeToken < HashMap < Integer , String >> ( ) { } . getType ( ) ; Gson myGson = new Gson ( ) ; try { BufferedReader reader = new BufferedReader ( new FileReader ( SlimeGame . basePath + "data//items.json" ) ) ; itemList = myGson . fromJson ( reader . readLine ( ) , mapType ) ; reader . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } for ( int i = 0 ; i < itemList . size ( ) ; i ++ ) { System . out . print ( itemList . get ( i ) + " " ) ; } System . out . println ( ) ; }
tr	5	public static JSONArray toJSONArray ( JSONArray names , JSONTokener x ) throws JSONException { if ( names == null || names . length ( ) == 0 ) { return null ; } JSONArray ja = new JSONArray ( ) ; for ( ; ; ) { JSONObject jo = rowToJSONObject ( names , x ) ; if ( jo == null ) { break ; } ja . put ( jo ) ; } if ( ja . length ( ) == 0 ) { return null ; } return ja ; }
tr	6	public MyEvent getEvent ( int key ) { if ( key == up ) return MyEvent . UP ; if ( key == down ) return MyEvent . DOWN ; if ( key == left ) return MyEvent . LEFT ; if ( key == right ) return MyEvent . RIGHT ; if ( key == bomb ) return MyEvent . BOMB ; if ( key == surrend ) return MyEvent . SURREND ; return MyEvent . NONE ; }
tr	4	private void joinChan ( Connection connection , String chanName , boolean newChan ) { Chan myChan = connection . joinChan ( chanName ) ; logger . debug ( "Sending Join to others chan users" ) ; connection . meSendCommandToChannel ( chanName , "JOIN :" + chanName ) ; if ( newChan ) { connection . serverSendCommandToMe ( "331 RPL_NOTOPIC " + chanName + " :No topic is set" ) ; } else { if ( myChan . getTopic ( ) != null && myChan . getTopic ( ) . length ( ) > 0 ) { connection . serverSendCommandToMe ( "332 RPL_TOPIC " + chanName + " :" + myChan . getTopic ( ) ) ; } else { connection . serverSendCommandToMe ( "331 RPL_NOTOPIC " + chanName + " :No topic is set" ) ; } } StringBuffer nickList = new StringBuffer ( ) ; for ( Connection con : myChan . getConnections ( ) . keySet ( ) ) { nickList . append ( myChan . getConnections ( ) . get ( con ) ) ; nickList . append ( con . getNickname ( ) ) ; nickList . append ( " " ) ; } connection . serverSendCommandToMe ( "353 RPL_NAMREPLY " + chanName + " :" + nickList . toString ( ) ) ; connection . serverSendCommandToMe ( "366 RPL_ENDOFNAMES " + chanName + " :End of /NAMES list" ) ; }
tr	9	public final double nextGaussian ( ) { if ( __haveNextNextGaussian ) { __haveNextNextGaussian = false ; return __nextNextGaussian ; } else { double v1 , v2 , s ; do { int y ; int z ; int a ; int b ; if ( mti >= N ) { int kk ; final int [ ] mt = this . mt ; final int [ ] mag01 = this . mag01 ; for ( kk = 0 ; kk < N - M ; kk ++ ) { y = ( mt [ kk ] & UPPER_MASK ) | ( mt [ kk + 1 ] & LOWER_MASK ) ; mt [ kk ] = mt [ kk + M ] ^ ( y >>> 1 ) ^ mag01 [ y & 1 ] ; } for ( ; kk < N - 1 ; kk ++ ) { y = ( mt [ kk ] & UPPER_MASK ) | ( mt [ kk + 1 ] & LOWER_MASK ) ; mt [ kk ] = mt [ kk + ( M - N ) ] ^ ( y >>> 1 ) ^ mag01 [ y & 1 ] ; } y = ( mt [ N - 1 ] & UPPER_MASK ) | ( mt [ 0 ] & LOWER_MASK ) ; mt [ N - 1 ] = mt [ M - 1 ] ^ ( y >>> 1 ) ^ mag01 [ y & 1 ] ; mti = 0 ; } y = mt [ mti ++ ] ; y ^= y >>> 11 ; y ^= ( y << 7 ) & TEMPERING_MASK_B ; y ^= ( y << 15 ) & TEMPERING_MASK_C ; y ^= ( y >>> 18 ) ; if ( mti >= N ) { int kk ; final int [ ] mt = this . mt ; final int [ ] mag01 = this . mag01 ; for ( kk = 0 ; kk < N - M ; kk ++ ) { z = ( mt [ kk ] & UPPER_MASK ) | ( mt [ kk + 1 ] & LOWER_MASK ) ; mt [ kk ] = mt [ kk + M ] ^ ( z >>> 1 ) ^ mag01 [ z & 1 ] ; } for ( ; kk < N - 1 ; kk ++ ) { z = ( mt [ kk ] & UPPER_MASK ) | ( mt [ kk + 1 ] & LOWER_MASK ) ; mt [ kk ] = mt [ kk + ( M - N ) ] ^ ( z >>> 1 ) ^ mag01 [ z & 1 ] ; } z = ( mt [ N - 1 ] & UPPER_MASK ) | ( mt [ 0 ] & LOWER_MASK ) ; mt [ N - 1 ] = mt [ M - 1 ] ^ ( z >>> 1 ) ^ mag01 [ z & 1 ] ; mti = 0 ; } z = mt [ mti ++ ] ; z ^= z >>> 11 ; z ^= ( z << 7 ) & TEMPERING_MASK_B ; z ^= ( z << 15 ) & TEMPERING_MASK_C ; z ^= ( z >>> 18 ) ; if ( mti >= N ) { int kk ; final int [ ] mt = this . mt ; final int [ ] mag01 = this . mag01 ; for ( kk = 0 ; kk < N - M ; kk ++ ) { a = ( mt [ kk ] & UPPER_MASK ) | ( mt [ kk + 1 ] & LOWER_MASK ) ; mt [ kk ] = mt [ kk + M ] ^ ( a >>> 1 ) ^ mag01 [ a & 1 ] ; } for ( ; kk < N - 1 ; kk ++ ) { a = ( mt [ kk ] & UPPER_MASK ) | ( mt [ kk + 1 ] & LOWER_MASK ) ; mt [ kk ] = mt [ kk + ( M - N ) ] ^ ( a >>> 1 ) ^ mag01 [ a & 1 ] ; } a = ( mt [ N - 1 ] & UPPER_MASK ) | ( mt [ 0 ] & LOWER_MASK ) ; mt [ N - 1 ] = mt [ M - 1 ] ^ ( a >>> 1 ) ^ mag01 [ a & 1 ] ; mti = 0 ; } a = mt [ mti ++ ] ; a ^= a >>> 11 ; a ^= ( a << 7 ) & TEMPERING_MASK_B ; a ^= ( a << 15 ) & TEMPERING_MASK_C ; a ^= ( a >>> 18 ) ; if ( mti >= N ) { int kk ; final int [ ] mt = this . mt ; final int [ ] mag01 = this . mag01 ; for ( kk = 0 ; kk < N - M ; kk ++ ) { b = ( mt [ kk ] & UPPER_MASK ) | ( mt [ kk + 1 ] & LOWER_MASK ) ; mt [ kk ] = mt [ kk + M ] ^ ( b >>> 1 ) ^ mag01 [ b & 1 ] ; } for ( ; kk < N - 1 ; kk ++ ) { b = ( mt [ kk ] & UPPER_MASK ) | ( mt [ kk + 1 ] & LOWER_MASK ) ; mt [ kk ] = mt [ kk + ( M - N ) ] ^ ( b >>> 1 ) ^ mag01 [ b & 1 ] ; } b = ( mt [ N - 1 ] & UPPER_MASK ) | ( mt [ 0 ] & LOWER_MASK ) ; mt [ N - 1 ] = mt [ M - 1 ] ^ ( b >>> 1 ) ^ mag01 [ b & 1 ] ; mti = 0 ; } b = mt [ mti ++ ] ; b ^= b >>> 11 ; b ^= ( b << 7 ) & TEMPERING_MASK_B ; b ^= ( b << 15 ) & TEMPERING_MASK_C ; b ^= ( b >>> 18 ) ; v1 = 2 * ( ( ( ( ( long ) ( y >>> 6 ) ) << 27 ) + ( z >>> 5 ) ) / ( double ) ( 1 << 53 ) ) - 1 ; v2 = 2 * ( ( ( ( ( long ) ( a >>> 6 ) ) << 27 ) + ( b >>> 5 ) ) / ( double ) ( 1 << 53 ) ) - 1 ; s = v1 * v1 + v2 * v2 ; } while ( s >= 1 || s == 0 ) ; double multiplier = StrictMath . sqrt ( - 2 * StrictMath . log ( s ) / s ) ; __nextNextGaussian = v2 * multiplier ; __haveNextNextGaussian = true ; return v1 * multiplier ; } }
tr	5	@ Override public void actionPerformed ( ActionEvent e ) { JMenuItem popup = ( JMenuItem ) e . getSource ( ) ; String name = popup . getName ( ) ; switch ( name ) { case "add track" : List < TrackBean > selectedTracks = view . getSelectedTracks ( ) ; model . addTracksToPlaylist ( selectedTracks ) ; view . setDisplayedPlaylist ( model . getPlaylist ( ) ) ; break ; case "add album" : AlbumBean selectedAlbum = view . getSelectedAlbum ( ) ; model . addTracksToPlaylist ( selectedAlbum . getTracks ( ) ) ; view . setDisplayedPlaylist ( model . getPlaylist ( ) ) ; break ; case "clear playlist" : model . stopSong ( false ) ; view . setDisplayedPlaylist ( model . getPlaylist ( ) ) ; break ; case "remove track" : removeTracks ( ) ; break ; case "get info" : view . displayInfoDialog ( view . getSelectedTracks ( ) . get ( 0 ) ) ; break ; } }
tr	3	public static List < String > topDown ( List < Character > s ) { if ( s . size ( ) == 2 ) { String s1 = new String ( new char [ ] { s . get ( 0 ) , s . get ( 1 ) } ) ; String s2 = new String ( new char [ ] { s . get ( 1 ) , s . get ( 0 ) } ) ; ArrayList < String > al = new ArrayList < > ( ) ; al . add ( s1 ) ; al . add ( s2 ) ; return al ; } List < String > ret = new ArrayList < > ( ) ; for ( Character c : s ) { List < Character > dup = new ArrayList < > ( s ) ; dup . remove ( c ) ; List < String > l = topDown ( dup ) ; for ( String str : l ) { ret . add ( str + c ) ; } } return ret ; }
tr	6	public static void main ( String [ ] args ) { if ( args . length <= 0 ) { System . out . println ( "At least one arg (pebbler project) must be" + "specified" ) ; } String projectFileName = args [ 0 ] ; String nextFlag = args . length > 1 ? args [ 1 ] : "" ; boolean createBook = nextFlag . equals ( "--createBook" ) ? true : false ; File projectFile = new File ( projectFileName ) ; if ( ! projectFile . exists ( ) || ! projectFile . isFile ( ) ) { System . out . println ( "Couldn't find file: " + projectFile . getPath ( ) ) ; System . exit ( - 1 ) ; } System . out . println ( "Getting file from: " + projectFile . getPath ( ) ) ; PebblerProject project = PebblerProject . fromJson ( silentRead ( projectFile ) ) ; File fullFile = new File ( projectFile . getAbsolutePath ( ) ) ; String fullPath = fullFile . getParentFile ( ) . getAbsolutePath ( ) ; project . compile ( fullPath ) ; if ( createBook ) { TypeSetter typeSetter = new TypeSetter ( project ) ; typeSetter . createBook ( fullPath ) ; } }
tr	9	public void Run ( String product ) { int i = bidTs . size ( ) - 1 ; if ( i < 400 ) { return ; } try { if ( ! order . HasPosition ( product ) ) { state = 0 ; } else { order . getPosition ( product ) ; } double rangeLow = low10 . getRangeLow ( i - 1 ) ; double low = bidTs . get ( i ) . getLow ( ) ; double lastLow = bidTs . get ( i - 1 ) . getLow ( ) ; double rangeHigh = high20 . getRangeHigh ( i - 1 ) ; double high = bidTs . get ( i ) . getHigh ( ) ; double ema = ema200 . getEma ( i - 1 ) ; if ( state > 0 && low < rangeLow ) { Position p = order . getPosition ( product ) ; order . MarketSell ( product , bidTs . get ( i ) . getStart ( ) , rangeLow , p . getAmount ( ) ) ; order . CancelAllPendingOrders ( product ) ; state = 0 ; System . out . println ( String . format ( "breakout 10 day low. market sell %d at %f. cancel all pending." , p . getAmount ( ) , rangeLow ) ) ; } if ( state == 0 ) { if ( high > rangeHigh && lastLow > ema ) { n = this . atr . getAtr ( i - 1 ) ; double point = CurrencyTable . getPoint ( product ) ; double valuePerPoint = CurrencyTable . getValuePerPoint ( product ) ; double dollarVol = n * valuePerPoint / point ; this . unit = ( int ) Math . floor ( 0.01 * order . getAccount ( ) . getBalance ( ) / dollarVol ) ; if ( this . unit == 0 ) { return ; } String entryTime = askTs . get ( i ) . getStart ( ) ; this . entryPrice = rangeHigh ; this . stopPrice = this . entryPrice - 2 * n ; order . MarketBuy ( product , entryTime , this . entryPrice , this . unit ) ; order . StopSell ( product , entryTime , this . stopPrice , this . unit ) ; state = 1 ; System . out . format ( "state:%d  n:%f  ask:%f  bid:%f. breakout 20 day high. market buy %d at %f. stop at %f\n" , state , n , askTs . get ( i ) . getClose ( ) , bidTs . get ( i ) . getClose ( ) , unit , entryPrice , this . stopPrice ) ; } } else if ( state < 4 ) { if ( high > this . entryPrice + n / 2 ) { String entryTime = askTs . get ( i ) . getStart ( ) ; this . entryPrice = this . entryPrice + n / 2 ; this . stopPrice = this . stopPrice + n / 2 ; order . MarketBuy ( product , entryTime , this . entryPrice , this . unit ) ; order . StopSell ( product , entryTime , this . stopPrice , this . unit ) ; Position p = order . getPosition ( product ) ; List < PendingOrder > list = order . getStopSellOrders ( product ) ; for ( int k = 0 ; k < list . size ( ) ; k ++ ) { PendingOrder po = list . get ( k ) ; order . UpdatePendingOrder ( po , po . getAmount ( ) , this . stopPrice ) ; } state ++ ; System . out . format ( "state:%d  adding unit. market buy %d at %f\n" , state , unit , this . entryPrice ) ; } } } catch ( Exception ex ) { System . out . println ( ex . getCause ( ) ) ; } }
tr	4	@ Override public void setChild ( int childIndex , GeneTrait child ) { if ( objectType == null ) { if ( childIndex < childTypes . size ( ) ) { childGenes . put ( childIndex , child ) ; } else { throw new IllegalArgumentException ( "No such child index: " + childIndex ) ; } } else { if ( childIndex == 0 ) { object = child ; } else if ( childIndex - 1 < childTypes . size ( ) ) { childGenes . put ( childIndex - 1 , child ) ; } else { throw new IllegalArgumentException ( "No such child index: " + childIndex ) ; } } }
tr	4	protected boolean can_rabbit_run ( GameState game , int steps ) { int player = game . player ; long goal_bb = ( player == PL_WHITE ) ? RANK_8 : RANK_1 ; long start_bb = game . empty_bb & goal_bb ; long good_sq_bb = game . touching_bb ( game . colour_bb [ player ] ) | ~ game . touching_bb ( game . stronger_enemy_bb [ player ] ) ; good_sq_bb &= game . empty_bb ; good_sq_bb |= game . piece_bb [ player ] ; long reached_bb = start_bb ; for ( int i = 1 ; i <= steps ; i ++ ) { reached_bb = game . touching_bb ( reached_bb ) & good_sq_bb ; long test_bb = reached_bb & game . piece_bb [ player ] ; while ( test_bb != 0 ) { int rabbit_index = ai_util . Util . FirstOne ( test_bb ) ; test_bb ^= 1 << rabbit_index ; long result = game . piece_can_reach ( rabbit_index , i ) ; if ( ( result & goal_bb ) != 0 ) { this . saved_rabbit_index = rabbit_index ; return true ; } } } return false ; }
tr	3	public void read ( ) throws IOException { InputStream fis ; BufferedReader br ; String line ; fis = new FileInputStream ( fileLocation ) ; br = new BufferedReader ( new InputStreamReader ( fis , Charset . forName ( "UTF-8" ) ) ) ; boolean skipLine = true ; while ( ( line = br . readLine ( ) ) != null ) { if ( ! skipLine ) { String [ ] split = line . split ( ";" ) ; int repetitions = Integer . parseInt ( split [ split . length - 1 ] ) ; for ( int i = 0 ; i < repetitions ; i ++ ) { testParameters . add ( line ) ; } } else { skipLine = false ; } } br . close ( ) ; br = null ; fis = null ; }
tr	7	public static void testValidity ( Object o ) throws JSONException { if ( o != null ) { if ( o instanceof double ) { if ( ( ( double ) o ) . isInfinite ( ) || ( ( double ) o ) . isNaN ( ) ) { throw new JSONException ( "JSON does not allow non-finite numbers." ) ; } } else if ( o instanceof float ) { if ( ( ( float ) o ) . isInfinite ( ) || ( ( float ) o ) . isNaN ( ) ) { throw new JSONException ( "JSON does not allow non-finite numbers." ) ; } } } }
tr	9	public void randommovement ( ) { if ( anim > 39 ) { if ( ! walking ) { number = random . nextInt ( 3 ) ; if ( number == 1 ) { randir = random . nextInt ( 4 ) ; int randis = random . nextInt ( 25 ) ; if ( randir == 0 ) yp += - randis ; if ( randir == 1 ) yp += randis ; if ( randir == 2 ) xp += - randis ; if ( randir == 3 ) xp += randis ; } } } if ( yp != 0 ) { if ( yp > 0 ) { ya ++ ; yp -- ; } if ( yp < 0 ) { ya -- ; yp ++ ; } } if ( xp != 0 ) { if ( xp > 0 ) { xa ++ ; xp -- ; } if ( xp < 0 ) { xa -- ; xp ++ ; } } }
tr	1	@ Override public short readShort ( ) { byte [ ] data = new byte [ 2 ] ; read ( data ) ; short value ; if ( order == ByteOrder . LITTLE_ENDIAN ) { value = ( short ) ( ( FF & data [ 0 ] ) ) ; value |= ( short ) ( ( FF & data [ 1 ] ) << 8 ) ; } else { value = ( short ) ( ( FF & data [ 1 ] ) ) ; value |= ( short ) ( ( FF & data [ 0 ] ) << 8 ) ; } return value ; }
tr	9	private boolean checkFields ( final int num ) { final List < CoupleExt < String , JTextField >> list = groups . get ( num ) ; if ( list == null ) { FindDialog . LOG . info ( "***ERROR***: list is empty" ) ; return false ; } for ( int i = 0 ; i < list . size ( ) ; ++ i ) { final CoupleExt < String , JTextField > item = list . get ( i ) ; String text ; switch ( item . getField1 ( ) . toCharArray ( ) [ 0 ] ) { case n : text = item . getField2 ( ) . getText ( ) ; if ( text == null ) { return false ; } break ; case g : text = item . getField2 ( ) . getText ( ) ; if ( text . length ( ) != 0 ) { if ( ! Util . isNumeric ( text ) ) { return false ; } } break ; case e : text = item . getField2 ( ) . getText ( ) ; if ( text == null ) { return false ; } break ; case f : text = item . getField2 ( ) . getText ( ) ; if ( text . length ( ) != 0 ) { if ( ! Util . isNumeric ( text ) ) { return false ; } } break ; case t : text = item . getField2 ( ) . getText ( ) ; if ( text . length ( ) != 0 ) { if ( ! Util . isNumeric ( text ) ) { return false ; } } break ; } } return true ; }
tr	6	private void userForm ( String name , String ini , String cpr , String password ) throws DALException { boolean ok = true ; if ( ! checkName ( name ) ) { ok = false ; error += "Navnet skal v\u00E6re mellem 2 og 20 karaktere.(a-z) <br> " ; } if ( ! checkIni ( ini ) ) { ok = false ; error += "Initialer skal v\u00E6re mellem 2 og 3 karaktere. <br> " ; } if ( ! checkCpr ( cpr ) ) { ok = false ; error += "Cpr nummer skal v\u00E6re 10 tal. <br> " ; } if ( ! checkPassword ( password ) ) { ok = false ; error += "Password skal v\u00E6re mellem 7 og 8 karaktere. Skal indeholder stor og sm\u00E5 bogstaver samt tal <br> " ; } if ( ok ) { if ( id == 0 ) { id = unusedId ( ) ; OperatoerDTO user = new OperatoerDTO ( id , name , ini , cpr , replaceChar ( password ) , rolle ) ; operatoerDAO . createOperatoer ( user ) ; succes = "Bruger oprettet med id: " + id ; delete ( ) ; } else { OperatoerDTO user = operatoerDAO . getOperatoer ( id ) ; user . setOprNavn ( name ) ; user . setIni ( ini ) ; user . setCpr ( cpr ) ; user . setPassword ( replaceChar ( password ) ) ; user . setRolle ( rolle ) ; operatoerDAO . updateOperatoer ( user ) ; succes = "Bruger med id: " + id + " aendret" ; } } }
tr	6	public void drawWorldMap ( ) { worldMap [ 1 ] = super . mouseX >= 522 && super . mouseX <= 558 && super . mouseY >= 124 && super . mouseY < 161 ; if ( worldMap [ 0 ] && worldMap [ 1 ] ) { WorldOrb [ 1 ] . drawSprite ( 10 , 123 ) ; } else if ( worldMap [ 1 ] ) { WorldOrb [ 1 ] . drawSprite ( 10 , 123 ) ; } else { WorldOrb [ 0 ] . drawSprite ( 10 , 123 ) ; } }
tr	7	@ Override public boolean shadow_hit ( Ray ray , FloatRef tmin ) { float ox = ray . getOrigin ( ) . getX ( ) ; float oy = ray . getOrigin ( ) . getY ( ) ; float oz = ray . getOrigin ( ) . getZ ( ) ; float dx = ray . getDirection ( ) . getX ( ) ; float dy = ray . getDirection ( ) . getY ( ) ; float dz = ray . getDirection ( ) . getZ ( ) ; float a = dx * dx + dz * dz ; float b = 2.0f * ( ox * dx + oz * dz ) ; float c = ox * ox + oz * oz - radius * radius ; float disc = b * b - 4.0f * a * c ; if ( disc < 0.0 ) return false ; float e = ( float ) sqrt ( disc ) ; float denom = 2.0f * a ; float t = ( - b - e ) / denom ; if ( t > K_EPSILON ) { double yhit = oy + t * dy ; if ( yhit > y0 && yhit < y1 ) { tmin . value = t ; return true ; } } t = ( - b + e ) / denom ; if ( t > K_EPSILON ) { double yhit = oy + t * dy ; if ( yhit > y0 && yhit < y1 ) { tmin . value = t ; return true ; } } return false ; }
tr	8	public boolean equals ( peek_result that ) { if ( that == null ) return false ; boolean this_present_success = true && this . is_set_success ( ) ; boolean that_present_success = true && that . is_set_success ( ) ; if ( this_present_success || that_present_success ) { if ( ! ( this_present_success && that_present_success ) ) return false ; if ( ! this . success . equals ( that . success ) ) return false ; } return true ; }
tr	4	public ListNode reverseKGroup1 ( ListNode head , int k ) { ListNode curr = head ; int count = 0 ; while ( curr != null && count != k ) { curr = curr . next ; count ++ ; } if ( count == k ) { curr = reverseKGroup ( curr , k ) ; while ( count -- > 0 ) { ListNode tmp = head . next ; head . next = curr ; curr = head ; head = tmp ; } head = curr ; } return head ; }
tr	3	private static void splitReciprocal ( final double in [ ] , final double result [ ] ) { final double b = 1.0 / 4194304.0 ; final double a = 1.0 - b ; if ( in [ 0 ] == 0.0 ) { in [ 0 ] = in [ 1 ] ; in [ 1 ] = 0.0 ; } result [ 0 ] = a / in [ 0 ] ; result [ 1 ] = ( b * in [ 0 ] - a * in [ 1 ] ) / ( in [ 0 ] * in [ 0 ] + in [ 0 ] * in [ 1 ] ) ; if ( result [ 1 ] != result [ 1 ] ) { result [ 1 ] = 0.0 ; } resplit ( result ) ; for ( int i = 0 ; i < 2 ; i ++ ) { double err = 1.0 - result [ 0 ] * in [ 0 ] - result [ 0 ] * in [ 1 ] - result [ 1 ] * in [ 0 ] - result [ 1 ] * in [ 1 ] ; err = err * ( result [ 0 ] + result [ 1 ] ) ; result [ 1 ] += err ; } }
tr	6	public static TypedObject parseObject ( String type , String value ) throws ClassNotFoundException , NoSuchMethodException , IllegalAccessException , InvocationTargetException { if ( type . equals ( "int" ) ) { return new TypedObject ( Integer . class , Integer . parseInt ( value ) ) ; } if ( type . equals ( "float" ) ) { return new TypedObject ( float . class , float . parseFloat ( value ) ) ; } if ( type . equals ( "long" ) ) { return new TypedObject ( long . class , long . parseLong ( value ) ) ; } if ( type . equals ( "double" ) ) { return new TypedObject ( double . class , double . parseDouble ( value ) ) ; } if ( type . equals ( "boolean" ) ) { return new TypedObject ( boolean . class , boolean . valueOf ( value ) ) ; } type = canonicalize ( type ) ; class c = class . forName ( type ) ; Method m = null ; try { m = c . getMethod ( "valueOf" , String . class ) ; } catch ( NoSuchMethodException e ) { return new TypedObject ( String . class , value ) ; } return new TypedObject ( c , m . invoke ( null , value ) ) ; }
tr	4	public static void setAppleMenus ( String title ) { try { System . setProperty ( "apple.laf.useScreenMenuBar" , "true" ) ; System . setProperty ( "com.apple.mrj.application.apple.menu.about.name" , title ) ; UIManager . setLookAndFeel ( UIManager . getSystemLookAndFeelClassName ( ) ) ; } catch ( ClassNotFoundException e ) { System . out . println ( "ClassNotFoundException: " + e . getMessage ( ) ) ; } catch ( InstantiationException e ) { System . out . println ( "InstantiationException: " + e . getMessage ( ) ) ; } catch ( IllegalAccessException e ) { System . out . println ( "IllegalAccessException: " + e . getMessage ( ) ) ; } catch ( UnsupportedLookAndFeelException e ) { System . out . println ( "UnsupportedLookAndFeelException: " + e . getMessage ( ) ) ; } }
tr	2	public long getLong ( int index ) throws JSONException { Object object = this . get ( index ) ; try { return object instanceof Number ? ( ( Number ) object ) . longValue ( ) : long . parseLong ( ( String ) object ) ; } catch ( Exception e ) { throw new JSONException ( "JSONArray[" + index + "] is not a number." ) ; } }
tr	4	private void addFieldListeners ( ) { nameField . addFocusListener ( new FocusAdapter ( ) { @ Override public void focusLost ( FocusEvent e ) { try { cage . setName ( nameField . getText ( ) ) ; nameField . setBackground ( Color . green ) ; } catch ( Exception ex ) { nameField . setBackground ( Color . red ) ; cage . setName ( "Name" ) ; nameField . setText ( "Name" ) ; } } } ) ; sizeField . addFocusListener ( new FocusAdapter ( ) { @ Override public void focusLost ( FocusEvent e ) { try { cage . setSize ( double . parseDouble ( sizeField . getText ( ) ) ) ; sizeField . setBackground ( Color . green ) ; } catch ( Exception ex ) { sizeField . setBackground ( Color . red ) ; cage . setSize ( Cage . MIN_CAGE_AREA ) ; sizeField . setText ( "" + Cage . MIN_CAGE_AREA ) ; } } } ) ; longitudeField . addFocusListener ( new FocusAdapter ( ) { @ Override public void focusLost ( FocusEvent e ) { try { cage . setLongitude ( double . parseDouble ( longitudeField . getText ( ) ) ) ; longitudeField . setBackground ( Color . green ) ; } catch ( Exception ex ) { longitudeField . setBackground ( Color . red ) ; cage . setLongitude ( Cage . LONGITUDE_MIN ) ; longitudeField . setText ( "" + Cage . LONGITUDE_MIN ) ; } } } ) ; latitudeField . addFocusListener ( new FocusAdapter ( ) { @ Override public void focusLost ( FocusEvent e ) { try { cage . setLatitude ( double . parseDouble ( latitudeField . getText ( ) ) ) ; latitudeField . setBackground ( Color . green ) ; } catch ( Exception ex ) { latitudeField . setBackground ( Color . red ) ; cage . setLatitude ( Cage . LATITUDE_MIN ) ; latitudeField . setText ( "" + Cage . LATITUDE_MIN ) ; } } } ) ; }
tr	9	private void parseSpriteSheets ( ) throws IOException , ExpectedTokenException , InvalidTokenException { String line ; line = reader . readLine ( ) ; if ( ! line . equals ( "SPRITESHEETS" ) ) { throw new ExpectedTokenException ( "SPRITESHEETS" , line ) ; } line = reader . readLine ( ) ; while ( line != null && ! line . equals ( "END SPRITESHEETS" ) ) { scanner = new Scanner ( line ) ; if ( ! scanner . hasNext ( ) ) { throw new ExpectedTokenException ( "<file>" , line ) ; } String file = scanner . next ( ) ; if ( ! scanner . hasNextInt ( ) ) { throw new ExpectedTokenException ( "<frame width>" , line ) ; } int frameWidth = scanner . nextInt ( ) ; if ( ! scanner . hasNextInt ( ) ) { throw new ExpectedTokenException ( "<frame height>" , line ) ; } int frameHeight = scanner . nextInt ( ) ; if ( ! scanner . hasNextInt ( ) ) { throw new ExpectedTokenException ( "<padding x>" , line ) ; } int paddingX = scanner . nextInt ( ) ; if ( ! scanner . hasNextInt ( ) ) { throw new ExpectedTokenException ( "<padding y>" , line ) ; } int paddingY = scanner . nextInt ( ) ; SpriteSheet sheet = new SpriteSheet ( file , new Vec2i ( frameWidth , frameHeight ) , new Vec2i ( paddingX , paddingY ) ) ; sheets . put ( file , sheet ) ; line = reader . readLine ( ) ; } if ( line == null ) { throw new ExpectedTokenException ( "END SPRITESHEET" , line ) ; } }
tr	4	private String nextToInternal ( String excluded ) { int start = pos ; for ( ; pos < in . length ( ) ; pos ++ ) { char c = in . charAt ( pos ) ; if ( c == '' || c == '' || excluded . indexOf ( c ) != - 1 ) { return in . substring ( start , pos ) ; } } return in . substring ( start ) ; }
tr	3	private DefaultTreeModel getGroups ( ) { DefaultMutableTreeNode root = new DefaultMutableTreeNode ( Constants . STR_GROUP ) ; String userNo = String . valueOf ( user . get ( Constants . USER_NO ) ) ; List < Map < String , Object >> groupList = userDao . getGroup ( userNo ) ; for ( int i = 0 , len = groupList . size ( ) ; i < len ; ++ i ) { Map < String , Object > group = groupList . get ( i ) ; DefaultMutableTreeNode child = new DefaultMutableTreeNode ( String . valueOf ( group . get ( Constants . GROUP_NAME ) ) ) ; Map < String , Object > param = new HashMap < String , Object > ( ) ; param . put ( Constants . USER_NO , String . valueOf ( group . get ( Constants . USER_NO ) ) ) ; param . put ( Constants . GROUP_NO , String . valueOf ( group . get ( Constants . GROUP_NO ) ) ) ; List < Map < String , Object >> friendList = userDao . getFriend ( param ) ; if ( Constants . NUM_ZERO != friendList . size ( ) ) { for ( int j = 0 , size = friendList . size ( ) ; j < size ; ++ j ) { Map < String , Object > friend = friendList . get ( j ) ; String friendNo = String . valueOf ( friend . get ( Constants . FRIEND_NO ) ) ; StringBuilder sb = new StringBuilder ( ) ; sb . append ( userDao . getUserInfo ( friendNo ) ) ; sb . append ( "(" ) ; sb . append ( friendNo ) ; sb . append ( ")" ) ; sb . append ( "  <" ) ; int status = userDao . getStatus ( friendNo ) ; sb . append ( userStatus . getItemAt ( status ) . toString ( ) ) ; sb . append ( ">" ) ; DefaultMutableTreeNode childschild = new DefaultMutableTreeNode ( sb . toString ( ) ) ; child . add ( childschild ) ; } } root . add ( child ) ; } return new DefaultTreeModel ( root ) ; }
tr	5	@ Override public short [ ] getShortData ( ) { if ( ptr != 0 ) { return null ; } else { if ( isConstant ( ) ) { if ( length > getMaxSizeOf32bitArray ( ) ) return null ; short [ ] out = new short [ ( int ) length ] ; short elem = ( short ) data [ 0 ] ; for ( int i = 0 ; i < length ; i ++ ) { out [ i ] = elem ; } return out ; } else { short [ ] out = new short [ ( int ) length ] ; for ( int i = 0 ; i < length ; i ++ ) { out [ i ] = ( short ) data [ i ] ; } return out ; } } }
tr	9	public String SimplifyPath ( String path ) { if ( path == null || path . length ( ) == 0 ) return null ; if ( path . charAt ( 0 ) != / ) return path ; List < String > buf = new ArrayList < String > ( ) ; int pathLen = path . length ( ) ; int start = 0 ; int end ; while ( true ) { while ( start < pathLen && path . charAt ( start ) == / ) start ++ ; if ( start == pathLen ) break ; for ( end = start ; end < pathLen ; end ++ ) { if ( path . charAt ( end ) == / ) break ; } String curr = path . substring ( start , end ) ; if ( curr . equals ( "." ) ) { } else if ( curr . equals ( ".." ) ) { if ( buf . size ( ) > 0 ) buf . remove ( buf . size ( ) - 1 ) ; } else { buf . add ( curr ) ; } start = end ; } if ( buf . size ( ) == 0 ) return "/" ; else { StringBuilder builder = new StringBuilder ( ) ; for ( String dir : buf ) { builder . append ( / ) ; builder . append ( dir ) ; } return builder . toString ( ) ; } }
tr	8	@ Override public void run ( ) { open = true ; System . err . println ( "Die Kasse mit Id: " + cashpointId + " soll ge\u00F6ffnet werden!" ) ; try { Thread . sleep ( 6000 ) ; } catch ( InterruptedException e1 ) { e1 . printStackTrace ( ) ; } System . err . println ( "Die Kasse mit Id: " + cashpointId + " wurde ge\u00F6ffnet!" ) ; while ( ! empty ) { synchronized ( waitingQueue ) { while ( waitingQueue . size ( ) < 1 && removedOne ) { try { waitingQueue . wait ( ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } if ( waitingQueue . size ( ) >= 1 ) { Kunde kunde = waitingQueue . get ( 0 ) ; waitingQueue . remove ( 0 ) ; abgKunden ++ ; writeToBalance ( kunde ) ; removedOne = true ; System . out . println ( "Der Kunde Nr: " + kunde . getNr ( ) + " wird von Kasse mit Id: " + cashpointId + " abgearbeitet!" ) ; System . out . println ( waitingQueue . size ( ) + " Kunde(n) stehen in der Schlange der Kasse mit Id: " + cashpointId + " !" ) ; } else { empty = true ; } } if ( removedOne ) { try { Thread . sleep ( Math . round ( 6000 + Math . random ( ) * ( 10000 - 6000 ) ) ) ; removedOne = false ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } } open = false ; System . err . println ( "Die Kasse mit Id: " + cashpointId + " wurde geschlossen!" ) ; }
tr	2	public ShowTime getShowTimebyMovie ( Date time , Movie movie ) { for ( ShowTime showTime : showTimeDAO . getShowTimes ( movie ) ) { if ( time == showTime . getTime ( ) ) { return showTime ; } } return null ; }
tr	9	public final static byte [ ] encodeToByte ( byte [ ] sArr , boolean lineSep ) { if ( sArr == null || sArr . length == 0 ) return new byte [ 0 ] ; int sLen = sArr . length ; int eLen = ( sLen / 3 ) * 3 ; int cCnt = ( ( sLen - 1 ) / 3 + 1 ) << 2 ; int dLen = cCnt + ( lineSep ? ( cCnt - 1 ) / 76 << 1 : 0 ) ; byte [ ] dArr = new byte [ dLen ] ; for ( int s = 0 , d = 0 , cc = 0 ; s < eLen ; ) { int i = ( sArr [ s ++ ] & ff ) << 16 | ( sArr [ s ++ ] & ff ) << 8 | ( sArr [ s ++ ] & ff ) ; dArr [ d ++ ] = ( byte ) CA [ ( i >>> 18 ) & 3f ] ; dArr [ d ++ ] = ( byte ) CA [ ( i >>> 12 ) & 3f ] ; dArr [ d ++ ] = ( byte ) CA [ ( i >>> 6 ) & 3f ] ; dArr [ d ++ ] = ( byte ) CA [ i & 3f ] ; if ( lineSep && ++ cc == 19 && d < dLen - 2 ) { dArr [ d ++ ] = '' ; dArr [ d ++ ] = '' ; cc = 0 ; } } int left = sLen - eLen ; if ( left > 0 ) { int i = ( ( sArr [ eLen ] & ff ) << 10 ) | ( left == 2 ? ( ( sArr [ sLen - 1 ] & ff ) << 2 ) : 0 ) ; dArr [ dLen - 4 ] = ( byte ) CA [ i >> 12 ] ; dArr [ dLen - 3 ] = ( byte ) CA [ ( i >>> 6 ) & 3f ] ; dArr [ dLen - 2 ] = left == 2 ? ( byte ) CA [ i & 3f ] : ( byte ) = ; dArr [ dLen - 1 ] = = ; } return dArr ; }
tr	2	public static void closeQuietly ( Closeable cl ) { if ( cl != null ) { try { cl . close ( ) ; } catch ( Throwable t ) { LogFactory . getLog ( IOUtils . class ) . error ( "Problem closing a source or destination." , t ) ; } } }
tr	6	public static void consumeBlocks ( int [ ] victims ) { for ( int i = 0 ; i < 4 ; i ++ ) { if ( victims [ i ] != 0 ) { freeBlockBitmap [ victims [ i ] ] = 0 ; } } if ( victims [ 4 ] != 0 ) { try { Block indirectPointerBlk = new Block ( victims [ 4 ] , "rw" ) ; String ip ; while ( ( ip = indirectPointerBlk . readLine ( ) ) != null ) { int tempBlkNo = Integer . parseInt ( ip ) ; FreeSpaceMgnt . consumeBlock ( tempBlkNo ) ; } indirectPointerBlk . close ( ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } FreeSpaceMgnt . consumeBlock ( victims [ 4 ] ) ; } dirtyBuffer [ 1 ] = 1 ; }
tr	0	@ Override public void addDict ( Dict value ) { add ( value ) ; }
tr	2	public ListaObjetos ( java . awt . Frame parent , boolean modal ) { super ( parent , modal ) ; initComponents ( ) ; try { model = tipoLista . equals ( LISTA_CLIENTES ) ? new ClienteTableModel ( Factory . getClienteDAO ( ) . getAll ( ) ) : new ProgramaTableModel ( Factory . getProgramaDAO ( ) . getAll ( ) ) ; } catch ( DatosPaooException ex ) { mostrarException ( "Inicializar ventana" , "Ocurrio un problema al inicializar lista de objetos" ) ; } jTable1 . setModel ( model ) ; }
tr	6	protected String convertToSingleByteAlphabet ( String target ) { if ( target == null ) { return target ; } final StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < target . length ( ) ; i ++ ) { final char currentChar = target . charAt ( i ) ; if ( currentChar >= ff21 && currentChar <= ff3a ) { sb . append ( doConvertToSingleByteCharacter ( currentChar ) ) ; } else if ( currentChar >= ff41 && currentChar <= ff5a ) { sb . append ( doConvertToSingleByteCharacter ( currentChar ) ) ; } else { sb . append ( currentChar ) ; } } return sb . toString ( ) ; }
tr	6	public void createRoster ( ) { Calendar today = ( Calendar ) startDate . clone ( ) ; int count ; for ( int i = 0 ; i < numberOfDays ; i ++ ) { count = 0 ; numberOfServices = getNumberOfServices ( today . getTime ( ) ) ; driversUsed = new driverUsed [ numberOfServices ] ; busesUsed = new busUsed [ numberOfServices ] ; getServices ( today ) ; packs [ i ] = new Pack [ numberOfServices ] ; for ( int j = 0 ; j < numberOfServices ; j ++ ) { packs [ i ] [ j ] = new Pack ( ) ; packs [ i ] [ j ] . serv = getNextService ( ) ; packs [ i ] [ j ] . driver_id = getLeastWorkingDriver ( drivers , today . getTime ( ) , packs [ i ] [ j ] . serv ) ; packs [ i ] [ j ] . bus_id = getAvailableBus ( buses , today . getTime ( ) , packs [ i ] [ j ] . serv ) ; int findDriver = 0 ; int findBus = 0 ; for ( int k = 0 ; k < drivers . length ; k ++ ) if ( packs [ i ] [ j ] . driver_id == drivers [ k ] ) { findDriver = k ; } for ( int k = 0 ; k < buses . length ; k ++ ) if ( packs [ i ] [ j ] . bus_id == buses [ k ] ) { findBus = k ; } minutesDriverWorked [ findDriver ] += ( packs [ i ] [ j ] . serv . endtime ) - ( packs [ i ] [ j ] . serv . starttime ) ; minutesBusWorked [ findBus ] += ( packs [ i ] [ j ] . serv . endtime ) - ( packs [ i ] [ j ] . serv . starttime ) ; } today . add ( Calendar . DAY_OF_MONTH , 1 ) ; driversUsedIndex = 0 ; busesUsedIndex = 0 ; } printPacks ( ) ; toDatabase ( packs ) ; }
tr	0	public ArithmeticExpression ( String data , ArithmeticExpression left , ArithmeticExpression right , ArithmeticExpression parent ) { super ( data , left , right , parent ) ; }
tr	7	public boolean postMortem ( PostMortem pm ) { boolean result = true ; Symbol that = ( Symbol ) pm ; if ( this . integer != that . integer || this . weight != that . weight ) { return false ; } if ( ( this . back != null ) != ( that . back != null ) ) { return false ; } Symbol zero = this . zero ; Symbol one = this . one ; if ( zero == null ) { if ( that . zero != null ) { return false ; } } else { result = zero . postMortem ( that . zero ) ; } if ( one == null ) { if ( that . one != null ) { return false ; } } else { result = one . postMortem ( that . one ) ; } return result ; }
tr	3	public void eventDispatched ( AWTEvent e ) { if ( e . getID ( ) == MouseEvent . MOUSE_PRESSED ) { this . buttonPressed ( ( MouseEvent ) e ) ; } if ( e . getID ( ) == MouseEvent . MOUSE_RELEASED ) { this . buttonReleased ( ( MouseEvent ) e ) ; } if ( e . getID ( ) == MouseEvent . MOUSE_MOVED ) { this . moved ( ( MouseEvent ) e ) ; } }
tr	0	@ Before public void setUp ( ) { undertest = new MedianStore ( ) ; }
tr	0	public void resetTime ( ) { totalInNano = 0 ; }
tr	6	@ Override public Tipo validarSemantica ( ) throws Exception { Tipo izq , der ; izq = izquierdo . validarSemantica ( ) ; der = derecho . validarSemantica ( ) ; if ( izq instanceof TipoInt ) { if ( der instanceof TipoInt || der instanceof TipoFloat ) { return izq ; } else { throw new Exception ( "Error Semantico no se puede multiplicar un Tipo Int con un Tipo " + der . toString ( ) ) ; } } else if ( izq instanceof TipoFloat ) { if ( der instanceof TipoFloat || der instanceof TipoInt ) { return izq ; } else { throw new Exception ( "Error Semantico no se puede multiplicar un Tipo Float con un Tipo " + der . toString ( ) ) ; } } else { throw new Exception ( "Error Semantico no se puede multiplicar Tipo " + izq . toString ( ) + " con Tipo " + der . toString ( ) ) ; } }
tr	3	private int lexCompare ( DNSRecord . Address that ) { byte [ ] thisBytes = this . toByteArray ( ) ; byte [ ] thatBytes = that . toByteArray ( ) ; for ( int i = 0 , n = Math . min ( thisBytes . length , thatBytes . length ) ; i < n ; i ++ ) { if ( thisBytes [ i ] > thatBytes [ i ] ) { return 1 ; } else { if ( thisBytes [ i ] < thatBytes [ i ] ) { return - 1 ; } } } return thisBytes . length - thatBytes . length ; }
tr	4	public static boolean testSwitch ( boolean switches [ ] , int numTrue ) { boolean last = true ; int numFound = 0 ; for ( int i = 0 ; i < switches . length ; i ++ ) { if ( switches [ i ] == true && last == true ) numFound ++ ; else break ; } if ( numFound == numTrue ) return true ; return false ; }
tr	4	private void addSegmentsFor ( Obstacle source , Obstacle target ) { if ( source . intersects ( target ) ) addAllSegmentsBetween ( source , target ) ; else if ( target . bottom ( ) - 1 < source . y ) addSegmentsTargetAboveSource ( source , target ) ; else if ( source . bottom ( ) - 1 < target . y ) addSegmentsTargetAboveSource ( target , source ) ; else if ( target . right ( ) - 1 < source . x ) addSegmentsTargetBesideSource ( source , target ) ; else addSegmentsTargetBesideSource ( target , source ) ; }
tr	4	public boolean isPosicionFiguraValida ( ) { int figX = this . figura . getLocation ( ) . getCoordX ( ) ; int figY = this . figura . getLocation ( ) . getCoordY ( ) ; for ( int x = 0 ; x < this . figura . getNumColumns ( ) ; x ++ ) { for ( int y = 0 ; y < this . figura . getNumRows ( ) ; y ++ ) { if ( this . figura . getBloque ( y , x ) . getTipo ( ) != TipoBloque . FIGURA ) continue ; if ( this . escenario [ y + figY ] [ x + figX ] . getTipo ( ) != TipoBloque . VACIO ) return false ; } } return true ; }
tr	1	@ Override public void run ( ) { try { instance . start ( ) ; } catch ( InterruptedException e ) { System . out . println ( Thread . currentThread ( ) . getName ( ) + " interrupted" ) ; } }
tr	3	public void writeMarkov ( PrintWriter pw ) { pw . println ( "<state name=\"" + this . getName ( ) + "\" fallback=\"" + masterConnection . getTo ( ) . getName ( ) + "\">" ) ; pw . println ( "<connections>" ) ; for ( Entry < String , int > ent : transitionCounter . entrySet ( ) ) { if ( ent . getValue ( ) . getValue ( ) > 0 ) { Connection cn = findConnection ( ent . getKey ( ) ) ; if ( cn != null ) { pw . println ( "<connection tag=\"" + ent . getKey ( ) + "\" counter=\"" + ent . getValue ( ) . toString ( ) + "\" to=\"" + cn . getTo ( ) . getName ( ) + "\" />" ) ; } else { pw . println ( "<connection tag=\"" + ent . getKey ( ) + "\" counter=\"" + ent . getValue ( ) . toString ( ) + "\" to=\"" + masterConnection . getTo ( ) . getName ( ) + "\" />" ) ; } } } pw . println ( "</connections>" ) ; pw . println ( "</state>" ) ; }
tr	7	public int delete ( ) { String SQL1 = "DELETE FROM mensajes WHERE id=" + this . id + " LIMIT 1;" ; int nup = getSgd ( ) . executeUpdate ( SQL1 ) ; if ( nup > 0 ) { Log log = getLogger ( ) ; log . setTabla ( "Mensajes" ) ; log . setDatos ( "id=" + this . id ) ; log . setTipo ( org . iesapp . clients . sgd7 . logger . Log . DELETE ) ; log . setSentenciaSQL ( org . iesapp . clients . sgd7 . logger . Log . normalizeSQL ( SQL1 ) ) ; log . postLog ( ) ; log = null ; } String SQL0 = "SELECT id FROM mensajesprofesores WHERE idMensajes=" + this . id ; try { Statement st = getSgd ( ) . createStatement ( ) ; ResultSet rs = getSgd ( ) . getResultSet ( SQL0 , st ) ; while ( rs != null && rs . next ( ) ) { int idmp = rs . getInt ( 1 ) ; SQL1 = "DELETE FROM mensajesprofesores WHERE id=" + idmp + " LIMIT 1;" ; int success = getSgd ( ) . executeUpdate ( SQL1 ) ; nup += success ; if ( success > 0 ) { Log log = getLogger ( ) ; log . setTabla ( "MensajesProfesores" ) ; log . setDatos ( "id=" + idmp ) ; log . setTipo ( org . iesapp . clients . sgd7 . logger . Log . DELETE ) ; log . setSentenciaSQL ( org . iesapp . clients . sgd7 . logger . Log . normalizeSQL ( SQL1 ) ) ; log . postLog ( ) ; log = null ; } } if ( rs != null ) { rs . close ( ) ; st . close ( ) ; } } catch ( SQLException ex ) { Logger . getLogger ( Mensajes . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } String SQL = "DELETE FROM " + client . getPlusDbName ( ) + "sgd_mensajes_richtext WHERE idMensajes=" + this . id + " LIMIT 1" ; client . getPlusDb ( ) . executeUpdate ( SQL ) ; for ( BeanMensajesAttachment atc : attachments ) { atc . delete ( ) ; } return nup ; }
tr	7	private void searchUser ( ActionEvent e ) { String userName = this . userName . getText ( ) ; String userNo = this . userNO . getText ( ) ; if ( userName == null || Constants . STR_NULL . equals ( userName . trim ( ) ) ) { userName = Constants . STR_NULL ; } if ( userNo == null || Constants . STR_NULL . equals ( userNo . trim ( ) ) ) { userNo = Constants . STR_NULL ; } Map < String , Object > param = new HashMap < String , Object > ( ) ; param . put ( Constants . IN_USERNAME , userName ) ; param . put ( Constants . IN_USERNO , userNo ) ; System . out . println ( param ) ; List < Map < String , Object >> list = null ; try { list = userDao . searchUser ( param ) ; } finally { if ( null == list || Constants . NUM_ZERO == list . size ( ) ) { return ; } else { int size = list . size ( ) ; data = new String [ size ] [ 2 ] ; int i = 0 ; for ( Map < String , Object > item : list ) { data [ i ] [ 0 ] = item . get ( Constants . USER_NO ) ; data [ i ] [ 1 ] = item . get ( Constants . USER_NAME ) ; i ++ ; } refreshTable ( ) ; } } }
tr	0	@ JsonProperty ( "label" ) public void setLabel ( String label ) { this . label = label ; }
tr	0	public static void resetCounter ( ) { counter = 0 ; }
tr	0	public final int getSolutionMemoryMegabytes ( ) { return this . solutionMemoryMegabytes ; }
