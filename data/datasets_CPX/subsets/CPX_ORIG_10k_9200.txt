te	2	private boolean esDeTipo ( String extensiones , String archivo ) { tokens = new StringTokenizer ( extensiones , "-" ) ; while ( tokens . hasMoreTokens ( ) ) { if ( archivo . endsWith ( tokens . nextToken ( ) ) ) return true ; } return false ; }
te	1	private void jButton2ActionPerformed ( java . awt . event . ActionEvent evt ) { try { new Info ( null ) . setVisible ( true ) ; } catch ( InterruptedException ex ) { Logger . getLogger ( UpdateInfo . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } this . dispose ( ) ; }
te	1	public static WorldGenLayerZoom zoom ( long seed , WorldGenLayer genLayer , int amount ) { for ( int i = 0 ; i < amount ; ++ i ) { genLayer = new WorldGenLayerZoom ( seed + ( long ) i , genLayer ) ; } return ( WorldGenLayerZoom ) genLayer ; }
te	0	public List < Group_schedule > getSchedule ( ) { return this . group_schedule ; }
te	7	public void helper ( int [ ] can , int index , int target , boolean [ ] added ) { if ( target == 0 ) { ret . add ( ( ArrayList < Integer > ) re . clone ( ) ) ; return ; } int i = index ; while ( i < can . length && can [ i ] <= target ) { if ( i > 0 && can [ i ] == can [ i - 1 ] ) { if ( added [ i ] ) { re . add ( can [ i ] ) ; added [ i ] = true ; } } else { re . add ( can [ i ] ) ; added [ i ] = true ; } helper ( can , i + 1 , target - can [ i ] , added ) ; if ( added [ i ] == true ) { re . remove ( re . size ( ) - 1 ) ; added [ i ] = false ; } i ++ ; } }
te	8	public List < String > getSourceTree ( String commitID ) { try { List < String > fileList = new ArrayList < String > ( ) ; List < CommitFamily > commitPath = getCommitPathToRoot ( commitID ) ; List < CommitFamily > shortestCommitPath = new ArrayList < CommitFamily > ( ) ; Map < String , List < String >> commitCaches = getCommitCachesFromCommit ( commitID ) ; for ( CommitFamily cf : commitPath ) { if ( commitCaches . containsKey ( cf . getChildId ( ) ) ) { fileList . addAll ( commitCaches . get ( cf . getChildId ( ) ) ) ; break ; } else { shortestCommitPath . add ( cf ) ; } } if ( shortestCommitPath . size ( ) == 0 ) return fileList ; String oldCommit = shortestCommitPath . get ( shortestCommitPath . size ( ) - 1 ) . getChildId ( ) ; Map < String , Map < String , List < String >>> commitHistoryMap = getAddDeleteFileForCommitRange ( oldCommit , commitID ) ; for ( int i = shortestCommitPath . size ( ) - 1 ; i >= 0 ; i -- ) { String currentCommit = shortestCommitPath . get ( i ) . getChildId ( ) ; if ( commitHistoryMap . containsKey ( currentCommit ) ) { List < String > addedFiles = commitHistoryMap . get ( currentCommit ) . get ( "DIFF_ADD" ) ; List < String > deletedFiles = commitHistoryMap . get ( currentCommit ) . get ( "DIFF_DELETE" ) ; if ( addedFiles != null ) fileList . addAll ( addedFiles ) ; if ( deletedFiles != null ) fileList . removeAll ( deletedFiles ) ; } } return fileList ; } catch ( Exception e ) { e . printStackTrace ( ) ; System . out . print ( e . getMessage ( ) ) ; return null ; } }
te	4	public static void main ( String [ ] args ) { try { if ( args != null && args . length == 1 && "JAVALF" . equalsIgnoreCase ( args [ 0 ] ) ) { UIManager . setLookAndFeel ( new MetalLookAndFeel ( ) ) ; } else { UIManager . setLookAndFeel ( UIManager . getSystemLookAndFeelClassName ( ) ) ; } JFrame frame = new LoadOrganizer ( ) ; frame . setVisible ( true ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; System . exit ( - 1 ) ; } }
te	4	public int reverse ( int x ) { if ( x == 0 ) { return 0 ; } boolean isNegative = false ; if ( x < 0 ) { isNegative = true ; x = - 1 * x ; } StringBuffer buffer = new StringBuffer ( ) ; if ( isNegative ) { buffer . append ( "-" ) ; } while ( x != 0 ) { int last = x % 10 ; buffer . append ( last ) ; x = x / 10 ; } return new Integer ( buffer . toString ( ) ) ; }
te	3	public static void main ( String [ ] args ) { final MissedNotifyDemo mn = new MissedNotifyDemo ( ) ; Runnable runA = new Runnable ( ) { public void run ( ) { try { Thread . sleep ( 1000 ) ; mn . waitToProceed ( ) ; } catch ( InterruptedException x ) { x . printStackTrace ( ) ; } } } ; Thread threadA = new Thread ( runA , "threadA" ) ; threadA . start ( ) ; Runnable runB = new Runnable ( ) { public void run ( ) { try { Thread . sleep ( 500 ) ; mn . proceed ( ) ; } catch ( InterruptedException x ) { x . printStackTrace ( ) ; } } } ; Thread threadB = new Thread ( runB , "threadB" ) ; threadB . start ( ) ; try { Thread . sleep ( 10000 ) ; } catch ( InterruptedException x ) { } print ( "about to invoke interrupt() on threadA" ) ; threadA . interrupt ( ) ; }
te	3	public boolean change ( int key , E data ) { Node current = root ; while ( current . iData != key ) { if ( key < current . iData ) current = current . leftChild ; else current = current . rightChild ; if ( current == null ) return false ; } current . data = data ; return true ; }
te	8	private boolean checkVertical ( int j , int i , ConnectFourPiece [ ] [ ] m_Pieces ) { boolean gameWon = false ; int secondPieceUp = i + 1 ; int thirdPieceUp = i + 2 ; int fourthPieceUp = i + 3 ; if ( i < COLUMN_FIVE && m_Pieces [ j ] [ i ] . getPieceColour ( ) == m_Pieces [ j ] [ secondPieceUp ] . getPieceColour ( ) ) { if ( i < COLUMN_FIVE && m_Pieces [ j ] [ i ] . getPieceColour ( ) == m_Pieces [ j ] [ thirdPieceUp ] . getPieceColour ( ) ) { if ( i <= COLUMN_FIVE && m_Pieces [ j ] [ i ] . getPieceColour ( ) == m_Pieces [ j ] [ fourthPieceUp ] . getPieceColour ( ) ) { if ( m_Pieces [ j ] [ i ] . getPieceColour ( ) == RED_PIECE ) { m_Pieces [ j ] [ i ] . setPieceColour ( RED_STAR_PIECE ) ; m_Pieces [ j ] [ secondPieceUp ] . setPieceColour ( RED_STAR_PIECE ) ; m_Pieces [ j ] [ thirdPieceUp ] . setPieceColour ( RED_STAR_PIECE ) ; m_Pieces [ j ] [ fourthPieceUp ] . setPieceColour ( RED_STAR_PIECE ) ; } else if ( m_Pieces [ j ] [ i ] . getPieceColour ( ) == YELLOW_PIECE ) { m_Pieces [ j ] [ i ] . setPieceColour ( YELLOW_STAR_PIECE ) ; m_Pieces [ j ] [ secondPieceUp ] . setPieceColour ( YELLOW_STAR_PIECE ) ; m_Pieces [ j ] [ thirdPieceUp ] . setPieceColour ( YELLOW_STAR_PIECE ) ; m_Pieces [ j ] [ fourthPieceUp ] . setPieceColour ( YELLOW_STAR_PIECE ) ; } gameWon = true ; } } } return gameWon ; }
te	2	public EvalField getCopy ( ) { EvalField copy = new EvalField ( getWidth ( ) , getHeight ( ) ) ; for ( int x = 0 ; x < getWidth ( ) ; ++ x ) { for ( int y = 0 ; y < getHeight ( ) ; ++ y ) { int originalValue = getValueAt ( x , y ) ; copy . setValueAt ( x , y , originalValue ) ; } } return copy ; }
te	6	private int findInsertionPoint ( List < Interval > a , Interval target ) { int l = 0 , r = a . size ( ) - 1 ; int mid = 0 ; while ( l < r ) { mid = l + ( r - l ) / 2 ; if ( a . get ( mid ) . start == target . start ) { break ; } else if ( a . get ( mid ) . start < target . start ) { l = mid + 1 ; } else { r = mid - 1 ; } } if ( a . get ( mid ) . start == target . start ) return mid ; if ( a . get ( l ) . start <= target . start ) return l ; else { if ( l > 0 ) return l - 1 ; else return - 1 ; } }
te	0	public FillAction ( Canvas canv , BufferedImage source , Point origin , Color c1 , Color c2 , int threshold , FillType fillType ) { this . source = source ; this . origin = origin ; this . c1 = c1 ; this . c2 = c2 ; this . threshold = threshold ; this . canvas = canv ; }
te	1	public DirectoryPollerBuilder addPolledDirectory ( PolledDirectory directory ) { if ( directory == null ) { throw new NullPointerException ( NULL_ARGUMENT_ERROR_MESSAGE ) ; } directories . add ( directory ) ; return this ; }
te	2	public void addStyleMap ( StyleMap value ) { if ( this . objectNode != null ) { markDeletedNode ( this . objectNode ) ; } this . objectNode = value ; if ( value != null ) { value . setParent ( this ) ; markCreatedNode ( value ) ; } }
te	2	public void pasteImage ( ) { Clipboard clipboard = Toolkit . getDefaultToolkit ( ) . getSystemClipboard ( ) ; Object transferObject ; try { transferObject = clipboard . getContents ( null ) . getTransferData ( DataFlavor . imageFlavor ) ; } catch ( Exception e ) { return ; } if ( ! ( transferObject instanceof Image ) ) return ; BufferedImage imageToPaste = CompatibleImageCreator . createCompatibleImage ( ( Image ) transferObject ) ; floatingLayer = new FloatingLayer ( imageToPaste , selectX , selectY ) ; hasSelection = false ; }
te	1	public String readLine ( ) { String line ; try { line = scanner . nextLine ( ) ; } catch ( Exception e ) { line = null ; } return line ; }
te	4	public String getDescription ( ) { switch ( type ) { case BLANK_ENGLISH : return "Constant not in english version. To delete it from local file  blank also local language field." ; case BLANK_LOCAL : return "Needs translating." ; case EQUAL : return "Value present in local language but the same text as english. Maybe needs translating." ; case DIFFERENT : default : return "Translated." ; } }
te	9	public final JPoclASTParser . parameterDecl_return parameterDecl ( ) throws RecognitionException { JPoclASTParser . parameterDecl_return retval = new JPoclASTParser . parameterDecl_return ( ) ; retval . start = input . < ( 1 ) ; TypeTree root_0 = null ; Token structType = null ; Token structID = null ; Token string_literal47 = null ; Token ID48 = null ; Token string_literal49 = null ; Token ID50 = null ; Token string_literal51 = null ; TypeTree structType_tree = null ; TypeTree structID_tree = null ; TypeTree string_literal47_tree = null ; TypeTree ID48_tree = null ; TypeTree string_literal49_tree = null ; TypeTree ID50_tree = null ; TypeTree string_literal51_tree = null ; RewriteRuleTokenStream stream_43 = new RewriteRuleTokenStream ( adaptor , "token 43" ) ; RewriteRuleTokenStream stream_41 = new RewriteRuleTokenStream ( adaptor , "token 41" ) ; RewriteRuleTokenStream stream_ID = new RewriteRuleTokenStream ( adaptor , "token ID" ) ; RewriteRuleTokenStream stream_39 = new RewriteRuleTokenStream ( adaptor , "token 39" ) ; try { int alt9 = 3 ; switch ( input . LA ( 1 ) ) { case 41 : { alt9 = 1 ; } break ; case 39 : { alt9 = 2 ; } break ; case 43 : { alt9 = 3 ; } break ; default : NoViableAltException nvae = new NoViableAltException ( "" , 9 , 0 , input ) ; throw nvae ; } switch ( alt9 ) { case 1 : { string_literal47 = ( Token ) match ( input , 41 , FOLLOW_41_in_parameterDecl498 ) ; stream_41 . add ( string_literal47 ) ; ID48 = ( Token ) match ( input , ID , FOLLOW_ID_in_parameterDecl500 ) ; stream_ID . add ( ID48 ) ; retval . tree = root_0 ; RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream ( adaptor , "rule retval" , retval != null ? retval . tree : null ) ; root_0 = ( TypeTree ) adaptor . nil ( ) ; { { TypeTree root_1 = ( TypeTree ) adaptor . nil ( ) ; root_1 = ( TypeTree ) adaptor . becomeRoot ( stream_41 . nextNode ( ) , root_1 ) ; adaptor . addChild ( root_1 , stream_ID . nextNode ( ) ) ; adaptor . addChild ( root_0 , root_1 ) ; } } retval . tree = root_0 ; } break ; case 2 : { string_literal49 = ( Token ) match ( input , 39 , FOLLOW_39_in_parameterDecl519 ) ; stream_39 . add ( string_literal49 ) ; ID50 = ( Token ) match ( input , ID , FOLLOW_ID_in_parameterDecl521 ) ; stream_ID . add ( ID50 ) ; retval . tree = root_0 ; RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream ( adaptor , "rule retval" , retval != null ? retval . tree : null ) ; root_0 = ( TypeTree ) adaptor . nil ( ) ; { { TypeTree root_1 = ( TypeTree ) adaptor . nil ( ) ; root_1 = ( TypeTree ) adaptor . becomeRoot ( stream_39 . nextNode ( ) , root_1 ) ; adaptor . addChild ( root_1 , stream_ID . nextNode ( ) ) ; adaptor . addChild ( root_0 , root_1 ) ; } } retval . tree = root_0 ; } break ; case 3 : { string_literal51 = ( Token ) match ( input , 43 , FOLLOW_43_in_parameterDecl540 ) ; stream_43 . add ( string_literal51 ) ; structType = ( Token ) match ( input , ID , FOLLOW_ID_in_parameterDecl544 ) ; stream_ID . add ( structType ) ; structID = ( Token ) match ( input , ID , FOLLOW_ID_in_parameterDecl548 ) ; stream_ID . add ( structID ) ; retval . tree = root_0 ; RewriteRuleTokenStream stream_structType = new RewriteRuleTokenStream ( adaptor , "token structType" , structType ) ; RewriteRuleTokenStream stream_structID = new RewriteRuleTokenStream ( adaptor , "token structID" , structID ) ; RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream ( adaptor , "rule retval" , retval != null ? retval . tree : null ) ; root_0 = ( TypeTree ) adaptor . nil ( ) ; { { TypeTree root_1 = ( TypeTree ) adaptor . nil ( ) ; root_1 = ( TypeTree ) adaptor . becomeRoot ( stream_43 . nextNode ( ) , root_1 ) ; adaptor . addChild ( root_1 , stream_structType . nextNode ( ) ) ; adaptor . addChild ( root_1 , stream_structID . nextNode ( ) ) ; adaptor . addChild ( root_0 , root_1 ) ; } } retval . tree = root_0 ; } break ; } retval . stop = input . < ( - 1 ) ; retval . tree = ( TypeTree ) adaptor . rulePostProcessing ( root_0 ) ; adaptor . setTokenBoundaries ( retval . tree , retval . start , retval . stop ) ; } catch ( RecognitionException re ) { reportError ( re ) ; } finally { } return retval ; }
te	8	private void putRequiredOption ( Collection < String > precedentSynonyms , OptionSpec < ? > required , Map < Collection < String > , Set < OptionSpec < ? >>> target ) { for ( String each : precedentSynonyms ) { AbstractOptionSpec < ? > spec = specFor ( each ) ; if ( spec == null ) throw new UnconfiguredOptionException ( precedentSynonyms ) ; } Set < OptionSpec < ? >> associated = target . get ( precedentSynonyms ) ; if ( associated == null ) { associated = new HashSet < OptionSpec < ? >> ( ) ; target . put ( precedentSynonyms , associated ) ; } associated . add ( required ) ; }
te	0	public StringValue ( final String value ) { this ( value . getBytes ( Bencode . UTF8 ) ) ; }
te	2	@ Override public boolean contains ( T item ) { for ( T e : this ) { if ( e . equals ( item ) ) return true ; } return false ; }
te	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( GUIcompraVentaJug . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( GUIcompraVentaJug . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( GUIcompraVentaJug . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( GUIcompraVentaJug . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { new GUIcompraVentaJug ( ) . setVisible ( true ) ; } } ) ; }
te	6	private ArrayList < BeanClaseGuardia > load ( ) { ArrayList < BeanClaseGuardia > listbh = new ArrayList < BeanClaseGuardia > ( ) ; String conditionDia = "" ; String groupCondition = "" ; if ( this . idDiaSetmana > 0 ) { conditionDia = "horarios.idDias=" + this . idDiaSetmana + " AND horarios.idHorasCentro=" + this . idHoraCentro + " " ; groupCondition = " GROUP BY idHorasCentro  clases.id  " ; } else if ( this . idDiaSetmana < 0 ) { conditionDia = " AND asig.descripcion NOT LIKE 'TUT%' " ; groupCondition = " GROUP BY clases.id  " ; } String SQL1 = "SELECT DISTINCT " + " horascentro.inicio  " + " horascentro.fin  " + " clases.nombre AS grupo  " + " aulas.descripcionLarga AS aula  " + " clases.id AS idClase  " + "  horarios.idHorasCentro  " + "  asig.descripcion   " + " horarios.idProfesores " + " profesores.nombre " + " FROM " + "  horarios  " + " INNER JOIN profesores ON profesores.id = horarios.idProfesores " + "  LEFT JOIN " + " aulas  " + "  ON (horarios.idAulas = aulas.id)  " + "  LEFT JOIN " + "  horascentro  " + "  ON ( " + "    horarios.idHorascentro = horascentro.id " + "  )  " + "   INNER JOIN " + "  clases  " + "  ON (horarios.idClases = clases.id)  " + "  LEFT JOIN " + "  clasesdetalle AS cd  " + "  ON cd.idClases = clases.id  " + "  LEFT JOIN " + "  grupasig AS ga  " + "  ON ga.id = cd.idGrupasig  " + "  LEFT JOIN " + "  asignaturas AS asig  " + "  ON asig.id = ga.idAsignaturas  " + " WHERE (  " + conditionDia + "   )  " + groupCondition + " ORDER BY profesores.nombre " ; int id = 1 ; try { Statement st = getSgd ( ) . createStatement ( ) ; ResultSet rs1 = getSgd ( ) . getResultSet ( SQL1 , st ) ; while ( rs1 != null && rs1 . next ( ) ) { BeanClaseGuardia bh = new BeanClaseGuardia ( ) ; bh . setAula ( rs1 . getString ( "aula" ) ) ; bh . setInicio ( rs1 . getTime ( "inicio" ) ) ; bh . setFin ( rs1 . getTime ( "fin" ) ) ; bh . setGrupo ( rs1 . getString ( "grupo" ) ) ; int idClase = rs1 . getInt ( "idClase" ) ; bh . setIdClase ( idClase ) ; bh . setIdHorasCentro ( rs1 . getInt ( "idHorasCentro" ) ) ; bh . setMateria ( rs1 . getString ( "descripcion" ) ) ; bh . setIdProfesor ( rs1 . getString ( "idProfesores" ) ) ; bh . setNombreProfesor ( rs1 . getString ( "nombre" ) ) ; listbh . add ( bh ) ; id += 1 ; } if ( rs1 != null ) { rs1 . close ( ) ; st . close ( ) ; } } catch ( SQLException ex ) { Logger . getLogger ( ClasesGuardia . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } return listbh ; }
te	9	public void addBlock ( int x , int y , Inventory inv ) { if ( cases [ x ] [ y ] . getBlockID ( ) == 0 ) { for ( int i = 0 ; i < playerList . size ( ) ; i ++ ) { Player tmpPlay = playerList . get ( i ) ; if ( tmpPlay . currentCaseLeft ( ) . num . x == x && tmpPlay . currentCaseLeft ( ) . num . y == y ) { const . debug ( "(Chunk:addBlock): tried to place a block on player (currentCaseLeft)" ) ; return ; } else if ( tmpPlay . currentCaseRight ( ) . num . x == x && tmpPlay . currentCaseRight ( ) . num . y == y ) { const . debug ( "(Chunk:addBlock): tried to place a block on player (currentCaseRight)" ) ; return ; } else if ( tmpPlay . headLeft ( ) . num . x == x && tmpPlay . headLeft ( ) . num . y == y ) { const . debug ( "(Chunk:addBlock): tried to place a block on player (headLeft)" ) ; return ; } else if ( tmpPlay . headRight ( ) . num . x == x && tmpPlay . headRight ( ) . num . y == y ) { const . debug ( "(Chunk:addBlock): tried to place a block on player (headRight)" ) ; return ; } } Item tmp = inv . useItem ( ) ; cases [ x ] [ y ] . setBlock ( tmp ) ; cases [ x ] [ y ] . light = 6 ; } }
te	9	public static boolean Equal ( Object x , Object y ) { if ( x instanceof double && ( ( ( double ) x ) % 1 == 0 ) ) { x = ( ( double ) x ) . longValue ( ) ; } if ( y instanceof double && ( ( ( double ) y ) % 1 == 0 ) ) { y = ( ( double ) y ) . longValue ( ) ; } if ( x instanceof boolean ) { x = ( ( boolean ) x ) ? 1 : 0 ; } if ( y instanceof boolean ) { y = ( ( boolean ) y ) ? 1 : 0 ; } if ( String . valueOf ( x ) . equals ( String . valueOf ( y ) ) ) { return true ; } else { return false ; } }
te	2	@ Override public boolean equals ( Object obj ) { boolean egale = false ; if ( this . getTitre ( ) . equals ( ( ( Stage ) obj ) . getTitre ( ) ) ) { if ( this . getReg ( ) . equals ( ( ( Stage ) obj ) . getReg ( ) ) ) { egale = true ; } } return egale ; }
te	6	double nextValue ( ) throws SynthesizerException { if ( ! endReached && parent . currentTime - pointStartTime >= times [ currentPoint ] ) { currentPoint ++ ; if ( loopEnd > 0 && currentPoint >= loopEnd ) currentPoint = loopStart ; if ( currentPoint >= points . length - 1 ) endReached = true ; pointStartTime = parent . currentTime ; } if ( endReached ) return points [ points . length - 1 ] * peakAmplitude . getValue ( ) ; return ( ( parent . currentTime - pointStartTime ) / times [ currentPoint ] * ( points [ currentPoint + 1 ] - points [ currentPoint ] ) + points [ currentPoint ] ) * peakAmplitude . getValue ( ) ; }
te	7	private Activity getActivity ( Place lastPlace , Place newPlace ) { if ( newPlace instanceof HomePlace ) { return getAboutActivity ( ) ; } if ( newPlace instanceof AboutPlace ) { return getAboutActivity ( ) ; } if ( newPlace instanceof UIPlace ) { return getAboutActivity ( ) ; } if ( newPlace instanceof TestPhoneGapPlace ) { return new AboutActivity ( clientFactory ) ; } if ( newPlace instanceof CarouselPlace ) { return new CarouselActivity ( clientFactory ) ; } if ( newPlace instanceof VerifyGPSPlace ) { return new GPSFunctionalityVerfiedActivity ( clientFactory ) ; } if ( newPlace instanceof VerifyCompassPlace ) { return new CompassFunctionalityVerfiedActivity ( clientFactory ) ; } return null ; }
te	6	@ Override public class < ? > getColumnClass ( int columnIndex ) { switch ( columnIndex ) { case VENDOR : return String . class ; case NUMBER : return Integer . class ; case MODEL : return String . class ; case NOTE : return String . class ; case RECEIPT_DATE : return Date . class ; default : return Object . class ; } }
te	8	@ Override public void transform ( double [ ] src , double [ ] dst ) { for ( int i = 0 ; i < 3 ; i ++ ) temp2 [ i ] = src [ i ] ; temp2 [ 3 ] = 1 ; for ( int i = 0 ; i < 3 ; i ++ ) { dst [ i ] = 0 ; for ( int j = 0 ; j < 4 ; j ++ ) { dst [ i ] += matrix [ i ] [ j ] * temp2 [ j ] ; } } for ( int i = 0 ; i < 4 ; i ++ ) { for ( int j = 0 ; j < 4 ; j ++ ) { copy [ i ] [ j ] = matrix [ i ] [ j ] ; } } Invert . invert ( copy , inverseMatrix ) ; transpose ( inverseMatrix , inverseMatrixTranspose ) ; for ( int i = 0 ; i < 3 ; i ++ ) temp2 [ i ] = src [ i + 3 ] ; temp2 [ 3 ] = 0 ; for ( int i = 0 ; i < 3 ; i ++ ) { dst [ i + 3 ] = 0 ; for ( int j = 0 ; j < 4 ; j ++ ) { dst [ i + 3 ] += inverseMatrixTranspose [ i ] [ j ] * temp2 [ j ] ; } } }
te	0	public ArrayList < Comanda > listarTodos ( ) { return ComandaController . obterInstancia ( ) . listarTodos ( ) ; }
te	9	void saveToZip ( String fileName ) throws SAXException , TransformerConfigurationException { try { zipOut = new ZipOutputStream ( new FileOutputStream ( fileName ) ) ; } catch ( FileNotFoundException e1 ) { e1 . printStackTrace ( ) ; return ; } zipOut . setMethod ( ZipOutputStream . DEFLATED ) ; zipOut . setLevel ( 9 ) ; pictures . storePictureLibraryToArchive ( zipOut ) ; sounds . storeSoundLibraryToArchive ( zipOut ) ; ByteArrayOutputStream mos = new ByteArrayOutputStream ( ) ; StreamResult streamResult = new StreamResult ( mos ) ; SAXTransformerFactory tf = ( SAXTransformerFactory ) SAXTransformerFactory . newInstance ( ) ; TransformerHandler hd ; hd = tf . newTransformerHandler ( ) ; Transformer serializer = hd . getTransformer ( ) ; serializer . setOutputProperty ( OutputKeys . ENCODING , "ISO-8859-1" ) ; serializer . setOutputProperty ( OutputKeys . INDENT , "yes" ) ; hd . setResult ( streamResult ) ; hd . startDocument ( ) ; AttributesImpl atts = new AttributesImpl ( ) ; atts . addAttribute ( "" , "" , "X" , "CDATA" , "" + dProps . getXSize ( ) ) ; atts . addAttribute ( "" , "" , "Y" , "CDATA" , "" + dProps . getYSize ( ) ) ; atts . addAttribute ( "" , "" , "DisplayOrienation" , "CDATA" , "" + dProps . getXmlOrientationString ( ) ) ; atts . addAttribute ( "" , "" , "DisplayType" , "CDATA" , "" + dProps . getXmlTypeString ( ) ) ; atts . addAttribute ( "" , "" , "MirrorTouchX" , "CDATA" , "" + dProps . getMirrorTouchX ( ) ) ; atts . addAttribute ( "" , "" , "MirrorTouchY" , "CDATA" , "" + dProps . getMirrorTouchY ( ) ) ; atts . addAttribute ( "" , "" , "HardwareMirrorScreen" , "CDATA" , "" + dProps . getMirrorHWLCD ( ) ) ; atts . addAttribute ( "" , "" , "PhysAddr" , "CDATA" , physicalAddress . getPhysicalAddressString ( ) ) ; atts . addAttribute ( "" , "" , "ExportFile" , "CDATA" , "" + exportFileName ) ; hd . startElement ( "" , "" , "LcdData" , atts ) ; for ( int i = 0 ; i < visuPages . getTabCount ( ) ; i ++ ) { JScrollPane scrollPane = ( JScrollPane ) visuPages . getComponentAt ( i ) ; JViewport viewPort = ( JViewport ) scrollPane . getComponent ( 0 ) ; JLayeredPane layeredPane = ( JLayeredPane ) viewPort . getComponent ( 0 ) ; atts . clear ( ) ; atts . addAttribute ( "" , "" , "Name" , "CDATA" , visuPages . getTitleAt ( i ) ) ; atts . addAttribute ( "" , "" , "Color" , "CDATA" , "" + layeredPane . getBackground ( ) . getRGB ( ) ) ; if ( layeredPane . isOpaque ( ) ) atts . addAttribute ( "" , "" , "Opaque" , "CDATA" , "" ) ; hd . startElement ( "" , "" , "Page" , atts ) ; Component [ ] comp = layeredPane . getComponentsInLayer ( new Integer ( - 1 ) ) ; for ( Component thisComp : comp ) { if ( EIBComp . class . isInstance ( thisComp ) ) { EditorComponent co = ( EditorComponent ) thisComp ; co . writeXML ( hd ) ; } } comp = layeredPane . getComponentsInLayer ( JLayeredPane . DEFAULT_LAYER ) ; for ( Component thisComp : comp ) { if ( EIBComp . class . isInstance ( thisComp ) ) { EditorComponent co = ( EditorComponent ) thisComp ; co . writeXML ( hd ) ; } } hd . endElement ( "" , "" , "Page" ) ; } hardwareOptDlg . writeToXML ( hd ) ; hd . endElement ( "" , "" , "LcdData" ) ; hd . endDocument ( ) ; ZipEntry entry = new ZipEntry ( "Visu.xml" ) ; try { zipOut . putNextEntry ( entry ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } try { zipOut . write ( mos . toByteArray ( ) , 0 , mos . size ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } try { mos . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } try { zipOut . closeEntry ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } try { zipOut . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } zipOut = null ; }
te	2	private void deleteOrder ( Order order ) throws Exception { for ( Order o : orders ) { if ( o . getId ( ) . equals ( order . getId ( ) ) ) { orders . remove ( o ) ; return ; } } throw new OrderNotFoundException ( ) ; }
te	4	public void initParentTagProvider ( ParentTagProvider parentTagProvider2 ) { HashMap < String , String > parentTags = new HashMap < String , String > ( ) ; HashMap < String , String > grandParentTags = new HashMap < String , String > ( ) ; Iterator < SentenceStructure > iter = this . getDataHolder ( ) . getSentenceHolder ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { SentenceStructure sentenceObject = iter . next ( ) ; String parentTag = "" ; String grandParentTag = "" ; String source = getSource ( sentenceObject . getSource ( ) ) ; String tag = sentenceObject . getTag ( ) ; parentTags . put ( source , parentTag ) ; grandParentTags . put ( source , grandParentTag ) ; grandParentTag = parentTag ; if ( tag != null && ! tag . equals ( "ditto" ) ) parentTag = tag ; else if ( tag == null ) parentTag = "" ; } this . parentTagProvider . init ( parentTags , grandParentTags ) ; }
te	1	public void paint ( Graphics g ) { Graphics2D g2 = ( Graphics2D ) g . create ( ) ; g2 . translate ( xLoc , yLoc ) ; if ( playerFound ) { g2 . rotate ( angleTo ( player ) - Math . PI / 2 ) ; } g2 . drawImage ( turretImg , - 15 , - 15 , null ) ; }
te	5	public void propertyChange ( PropertyChangeEvent evt ) { if ( calendar != null ) { Calendar c = ( Calendar ) calendar . clone ( ) ; if ( evt . getPropertyName ( ) . equals ( "day" ) ) { c . set ( Calendar . DAY_OF_MONTH , ( ( Integer ) evt . getNewValue ( ) ) . intValue ( ) ) ; setCalendar ( c , false ) ; } else if ( evt . getPropertyName ( ) . equals ( "month" ) ) { c . set ( Calendar . MONTH , ( ( Integer ) evt . getNewValue ( ) ) . intValue ( ) ) ; setCalendar ( c , false ) ; } else if ( evt . getPropertyName ( ) . equals ( "year" ) ) { c . set ( Calendar . YEAR , ( ( Integer ) evt . getNewValue ( ) ) . intValue ( ) ) ; setCalendar ( c , false ) ; } else if ( evt . getPropertyName ( ) . equals ( "date" ) ) { c . setTime ( ( Date ) evt . getNewValue ( ) ) ; setCalendar ( c , true ) ; } } }
te	5	protected Object parseType ( String name ) throws IOException , XmlPullParserException { if ( name . equals ( "int" ) || name . equals ( "i4" ) ) return new Integer ( Integer . parseInt ( parser . nextText ( ) ) ) ; else if ( name . equals ( "array" ) ) return parseArray ( ) ; else if ( name . equals ( "string" ) ) return parser . nextText ( ) ; else if ( name . equals ( "struct" ) ) return parseStruct ( ) ; else throw new RuntimeException ( "unexpected element: " + name ) ; }
te	2	public InputStream getInputStream ( ) { if ( "bulk" != getType ( ) || ! isInput ( ) ) throw new IllegalArgumentException ( ) ; spi = getDevice ( ) . getSPI ( ) ; return new BulkInputStream ( spi , getEndpoint ( ) ) ; }
te	1	@ Test public void testSwapElements ( ) { LinkedBinaryTree < String > t = new LinkedBinaryTree < > ( new FactoryNode < String > ( ) ) ; Position < String > p = t . addRoot ( "+" ) ; Position < String > p1 = t . insertLeft ( p , "2" ) ; Position < String > p2 = t . insertRight ( p , "3" ) ; t . swapElements ( p1 , p2 ) ; String salida = "" ; for ( Position < String > e : t . positions ( ) ) { salida += e . element ( ) ; } assertEquals ( salida , "+32" ) ; }
te	7	public void insertQuestion ( Question q ) { long specificID ; switch ( q . type ) { case QUESTION_RESPONSE : specificID = insertQuestionResponseQuestion ( q ) ; break ; case FILL_IN : specificID = insertFillInQuestion ( q ) ; break ; case MULTIPLE_CHOICE : specificID = insertMultipleChoiceQuestion ( ( MultipleChoiceQuestion ) q ) ; break ; case PICTURE_RESPONSE : specificID = insertPictureResponseQuestion ( q ) ; break ; default : specificID = - 1 ; } if ( specificID != - 1 ) { DBConnection connection = DBConnection . sharedInstance ( ) ; int id ; try { id = connection . insert ( "INSERT INTO questions (quizID  question_type  specific_questionID  order_index) VALUES " + "('" + q . getQuizID ( ) + "'  '" + q . getTypeInt ( ) + "'  '" + specificID + "'  '" + q . getOrderIndex ( ) + "')" ) ; q . setId ( id ) ; for ( String answer : q . getCorrectAnswers ( ) ) { connection . insert ( "INSERT INTO answers (questionID  answer) VALUES ('" + id + "'  '" + answer + "')" ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } }
te	0	@ Test public void testNewStyle ( ) { OutputFormatter formatter = new OutputFormatter ( true ) ; OutputFormatterStyle style = new OutputFormatterStyle ( "blue" , "white" ) ; formatter . setStyle ( "test" , style ) ; assertEquals ( style , formatter . getStyle ( "test" ) ) ; assertNotSame ( style , formatter . getStyle ( "info" ) ) ; assertEquals ( "\u001B[34;47msome custom msg\u001B[0m" , formatter . format ( "<test>some custom msg</test>" ) ) ; }
te	3	public static List < Field > getFields ( class clazz , String ... selectedFieldNames ) { List < Field > fields = new ArrayList < Field > ( ) ; if ( selectedFieldNames . length > 0 ) { for ( String fieldName : selectedFieldNames ) { fields . add ( getField ( clazz , fieldName ) ) ; } } else { for ( Field field : clazz . getDeclaredFields ( ) ) { field . setAccessible ( true ) ; fields . add ( field ) ; } } return fields ; }
te	0	private static Pattern createParensGrammar ( ) { Pattern openParen = str ( "(" ) ; Pattern closeParen = str ( ")" ) ; Pattern notParen = n ( 1 ) . diff ( set ( "()" ) ) ; return grammar ( rule ( "1" , seq ( openParen , choice ( notParen , seq ( test ( openParen ) , ref ( "1" ) ) ) . repeat ( 0 ) , closeParen ) ) ) ; }
te	6	@ Override protected int computeMove ( Board b , long endTime ) { turn ++ ; try { long start = System . currentTimeMillis ( ) ; if ( DEBUG ) System . out . println ( ) ; if ( root == null ) { if ( GFX_DEBUG ) { debugImgs = new ArrayList < BufferedImage > ( ) ; } root = createNode ( 1 - getNumber ( ) , null , Board . MOVE_NONE , b ) ; onComputeFirstMove ( root ) ; } rootBoard = b ; if ( endTime == 0 ) endTime = System . currentTimeMillis ( ) + MAX_TURN_TIME ; int move = MCTS ( root , endTime ) ; if ( DEBUG ) { int pos = b . getPlayerPosition ( getNumber ( ) ) ; System . out . println ( "PERFORM MOVE " + Board . moveToString ( move ) + " (in " + ( System . currentTimeMillis ( ) - start ) + " ms) FROM (" + Board . posToX ( pos ) + "  " + Board . posToY ( pos ) + ")" ) ; System . out . println ( "Time " + getNumber ( ) + ": " + ( System . currentTimeMillis ( ) - start ) ) ; } return move ; } catch ( Exception e ) { e . printStackTrace ( ) ; System . out . println ( "error in MCTSPlayer! " + e . getMessage ( ) ) ; return Board . MOVE_NONE ; } }
te	0	public Gun ( SuperTank bot ) { this . bot = bot ; }
te	6	public void tableEdit ( final JTable table ) { System . out . println ( "Jestem w table edit" ) ; table . getModel ( ) . addTableModelListener ( new TableModelListener ( ) { @ Override public void tableChanged ( TableModelEvent e ) { if ( table . getCellEditor ( ) != null ) { int col = table . getSelectedColumn ( ) ; id = Integer . parseInt ( table . getValueAt ( table . getSelectedRow ( ) , 1 ) . toString ( ) ) ; if ( col != 0 ) { if ( table == jTable1 ) { String value = ( String ) table . getValueAt ( table . getSelectedRow ( ) , table . getSelectedColumn ( ) ) ; fireCategoryEvent ( new CategoryEvent ( value , "kategorie" , id , "update" ) ) ; } else if ( table == companyTable ) { String value = ( String ) table . getValueAt ( table . getSelectedRow ( ) , 2 ) ; String value2 = ( String ) table . getValueAt ( table . getSelectedRow ( ) , 3 ) ; fireCompanyEvent ( new CompanyEvent ( value , "firmy" , value2 , id , "update" ) ) ; } else if ( table == itemTable ) { System . out . println ( id ) ; System . out . println ( box_flag_category ) ; if ( box_flag_category == 1 ) { String name = ( String ) table . getValueAt ( table . getSelectedRow ( ) , 2 ) ; Category selected_category = ( Category ) categoryBox . getSelectedItem ( ) ; Company selected_copmany = ( Company ) companyBox . getSelectedItem ( ) ; id_category = selected_category . getId ( ) ; id_company = selected_copmany . getId ( ) ; fireItemEvent ( new ItemsEvent ( id , "produkty" , null , null , name , id_category , id_company , "update" ) , "normal" ) ; } } } } } } ) ; }
te	5	@ Override public void recvFileTransfer ( String seller , String serviceName , byte [ ] fileContent ) { loggerNetwork . info ( "Receive file from seller " + seller + " from service " + serviceName ) ; String filename = seller + "_" + serviceName ; int toWrite ; int noChunks = fileContent . length / NetworkInfo . BUF_SIZE ; int chunkSize = fileContent . length / noChunks ; int offset = 0 ; try { File outFile = new File ( filename ) ; if ( outFile . exists ( ) ) { outFile . createNewFile ( ) ; } FileOutputStream receivedFile = new FileOutputStream ( filename ) ; for ( ; offset != fileContent . length ; ) { if ( fileContent . length - offset < chunkSize ) toWrite = fileContent . length - offset ; else toWrite = chunkSize ; receivedFile . write ( fileContent , offset , toWrite ) ; offset += toWrite ; med . acceptFileTransfer ( serviceName , 100 * offset / fileContent . length ) ; } receivedFile . close ( ) ; } catch ( FileNotFoundException e ) { System . err . println ( "Error opening outputstream" ) ; e . printStackTrace ( ) ; } catch ( IOException e ) { System . err . println ( "Error writing file on disk" ) ; e . printStackTrace ( ) ; } }
te	4	public void setFieldValue ( _Fields field , Object value ) { switch ( field ) { case DATA : if ( value == null ) { unset_data ( ) ; } else { set_data ( ( ByteBuffer ) value ) ; } break ; case ID : if ( value == null ) { unset_id ( ) ; } else { set_id ( ( long ) value ) ; } break ; } }
te	9	private boolean r_prelude ( ) { int v_1 ; int v_2 ; int v_3 ; int v_4 ; int v_5 ; B_Y_found = false ; v_1 = cursor ; lab0 : do { bra = cursor ; if ( ! ( eq_s ( 1 , "'" ) ) ) { break lab0 ; } ket = cursor ; slice_del ( ) ; } while ( false ) ; cursor = v_1 ; v_2 = cursor ; lab1 : do { bra = cursor ; if ( ! ( eq_s ( 1 , "y" ) ) ) { break lab1 ; } ket = cursor ; slice_from ( "Y" ) ; B_Y_found = true ; } while ( false ) ; cursor = v_2 ; v_3 = cursor ; lab2 : do { replab3 : while ( true ) { v_4 = cursor ; lab4 : do { golab5 : while ( true ) { v_5 = cursor ; lab6 : do { if ( ! ( in_grouping ( g_v , 97 , 121 ) ) ) { break lab6 ; } bra = cursor ; if ( ! ( eq_s ( 1 , "y" ) ) ) { break lab6 ; } ket = cursor ; cursor = v_5 ; break golab5 ; } while ( false ) ; cursor = v_5 ; if ( cursor >= limit ) { break lab4 ; } cursor ++ ; } slice_from ( "Y" ) ; B_Y_found = true ; continue replab3 ; } while ( false ) ; cursor = v_4 ; break replab3 ; } } while ( false ) ; cursor = v_3 ; return true ; }
te	7	public static Object decodeToObject ( String encodedObject , int options , final ClassLoader loader ) throws java . io . IOException , java . lang . ClassNotFoundException { byte [ ] objBytes = decode ( encodedObject , options ) ; java . io . ByteArrayInputStream bais = null ; java . io . ObjectInputStream ois = null ; Object obj = null ; try { bais = new java . io . ByteArrayInputStream ( objBytes ) ; if ( loader == null ) { ois = new java . io . ObjectInputStream ( bais ) ; } else { ois = new java . io . ObjectInputStream ( bais ) { @ Override public class < ? > resolveClass ( java . io . ObjectStreamClass streamClass ) throws java . io . IOException , ClassNotFoundException { class c = class . forName ( streamClass . getName ( ) , false , loader ) ; if ( c == null ) { return super . resolveClass ( streamClass ) ; } else { return c ; } } } ; } obj = ois . readObject ( ) ; } catch ( java . io . IOException e ) { throw e ; } catch ( java . lang . ClassNotFoundException e ) { throw e ; } finally { try { bais . close ( ) ; } catch ( Exception e ) { } try { ois . close ( ) ; } catch ( Exception e ) { } } return obj ; }
te	7	public static void copyProperties ( Object dest , Object orig , final String [ ] filters ) { ConvertUtils . deregister ( Integer . class ) ; ConvertUtils . register ( new IntegerConverter ( null ) , Integer . class ) ; BeanUtilsBean beanUtils = new BeanUtilsBean ( BeanUtilsBean . getInstance ( ) . getConvertUtils ( ) , new PropertyUtilsBean ( ) { @ Override public PropertyDescriptor [ ] getPropertyDescriptors ( Object bean ) { PropertyDescriptor [ ] descriptors = super . getPropertyDescriptors ( bean ) ; if ( descriptors == null || descriptors . length == 0 || filters == null || filters . length == 0 ) return descriptors ; List < PropertyDescriptor > descriptorList = new ArrayList < PropertyDescriptor > ( Arrays . asList ( descriptors ) ) ; List < String > filterList = Arrays . asList ( filters ) ; Iterator < PropertyDescriptor > descriptorIterator = descriptorList . iterator ( ) ; while ( descriptorIterator . hasNext ( ) ) { PropertyDescriptor descriptor = descriptorIterator . next ( ) ; if ( filterList . contains ( descriptor . getName ( ) ) ) { descriptorIterator . remove ( ) ; } } return descriptorList . toArray ( new PropertyDescriptor [ descriptorList . size ( ) ] ) ; } } ) ; try { beanUtils . copyProperties ( dest , orig ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; } }
te	0	protected String getString ( Player player , int padding ) { padding -= player . getName ( ) . length ( ) ; StringBuilder builder = new StringBuilder ( ) ; builder . append ( player . getName ( ) ) ; builder . append ( space ( padding ) ) ; builder . append ( " " ) ; builder . append ( player . getBids ( ) ) ; builder . append ( " " ) ; return builder . toString ( ) ; }
te	1	public static void qsort ( List < ? extends Comparable > list ) { qsort ( list , 0 , list . size ( ) - 1 ) ; }
te	7	public static float distance ( Contact contact , IShape shape1 , IShape shape2 ) { simplex . clear ( ) ; v . setSubtract ( shape1 . getPosition ( ) , shape2 . getPosition ( ) ) ; Element e = simplex . getNewElement ( ) ; MinkowskiDifference . getMaxSupport ( e , shape1 , shape2 , v ) ; simplex . addElement ( ) ; v . set ( e . v ) ; float d_2 = v . . ( ) ; int i = 0 ; if ( d_2 > EPSILON_2 ) { float d0_2 ; do { e = simplex . getNewElement ( ) ; MinkowskiDifference . getMinSupport ( e , shape1 , shape2 , v ) ; if ( simplex . contains ( e . v ) ) { break ; } simplex . addElement ( ) ; v0 . set ( v ) ; d0_2 = d_2 ; d_2 = closestPointToOrigin ( v , simplex ) ; if ( d_2 >= d0_2 ) { break ; } } while ( d_2 > EPSILON_2 && i ++ < MAX_ITERATIONS && ( d0_2 - 2 * v0 . . ( v ) + d_2 ) > EPSILON_2 ) ; } if ( d_2 <= EPSILON_2 ) { contact . setDistance ( 0 ) ; contact . getNormal ( ) . set ( 0 , 0 , 0 ) ; return 0 ; } getDistanceClosestPoints ( contact , simplex , v ) ; d_2 = ( float ) Math . sqrt ( d_2 ) ; contact . setDistance ( d_2 ) ; contact . getNormal ( ) . setScale ( v , - 1 / d_2 ) ; return d_2 ; }
te	5	public void run ( ) { while ( connected ) { try { EntityTable e = ( EntityTable ) in . readObject ( ) ; if ( e . getType ( ) . equals ( "EntityList" ) ) { EntityList el = ( EntityList ) e ; departmentBox . removeAllItems ( ) ; for ( int i = 0 ; i < el . getList ( ) . size ( ) ; i ++ ) { departmentBox . addItem ( el . getList ( ) . get ( i ) ) ; } departmentBox . updateUI ( ) ; } } catch ( IOException ex ) { Logger . getLogger ( RegisterJFrame . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( ClassNotFoundException ex ) { Logger . getLogger ( RegisterJFrame . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } } }
te	3	private static Map < Position , Cell > calculateCells ( final int width , final int height , final String data ) { InputValidation . require ( isValidData ( width , height , data ) , "invalid data" ) ; final Map < Position , Cell > cells = new HashMap < Position , Cell > ( ) ; final String [ ] rows = data . split ( " " ) ; for ( int y = 1 ; y <= height ; ++ y ) { for ( int x = 1 ; x <= width ; ++ x ) { final char c = rows [ y - 1 ] . charAt ( x - 1 ) ; if ( Cell . isCell ( c ) ) { cells . put ( Position . valueOf ( x , y ) , Cell . asCell ( c ) ) ; } } } return cells ; }
te	2	public MailboxException ( Mailbox < ? , ? > mbox , String message , Throwable cause ) { super ( message , cause ) ; this . mailbox = mbox ; }
te	2	private void close ( ) { try { if ( connection != null ) connection . close ( ) ; } catch ( SQLException e ) { System . err . println ( e ) ; } }
te	0	public void setComId ( int comId ) { this . comId = comId ; }
te	9	public static void main ( String [ ] args ) { if ( args . length < 2 ) { printUsageandExit ( ) ; } String mode = args [ 0 ] ; String filename = args [ 1 ] ; if ( mode . startsWith ( "e" ) ) { if ( args . length < 4 ) { printUsageandExit ( ) ; } filename = args [ 3 ] ; } if ( ! new File ( filename ) . exists ( ) ) { printUsageandExit ( ) ; } try { long start = System . currentTimeMillis ( ) ; Model model = new Model ( filename ) ; model . loadModel ( ) ; long load = System . currentTimeMillis ( ) ; model . analyze ( ) ; if ( mode . startsWith ( "e" ) ) { String option = args [ 1 ] ; String layersarg = args [ 2 ] ; Collection < Layer > lays = parseLayerArgument ( model , layersarg ) ; if ( option . contains ( "offset=" ) && ! layersarg . equalsIgnoreCase ( "all" ) ) { System . err . println ( "Offset change can only be done if all layers are choosen" ) ; System . exit ( 1 ) ; } editLayer ( model , option , lays ) ; } if ( mode . contains ( "m" ) ) { printModelDetails ( model ) ; } if ( mode . contains ( "l" ) ) { printLayerSummary ( model ) ; } if ( mode . contains ( "s" ) ) { printModelSpeedDetails ( model ) ; } if ( mode . matches ( ".*[pn].*" ) ) { printLayerDetails ( model , mode ) ; } if ( mode . contains ( "c" ) ) { printComments ( model ) ; } if ( mode . contains ( "g" ) ) { printGCodeDetails ( model , mode ) ; } if ( mode . contains ( "x" ) ) { printGCodeDetailsCSV ( model , mode ) ; } long end = System . currentTimeMillis ( ) ; System . out . println ( "Gcode Analyse Time: " + Constants . formatTimetoHHMMSS ( ( end - start ) / 1000f , ( StringBuilder ) null ) + " Load time:" + Constants . formatTimetoHHMMSS ( ( load - start ) / 1000f , ( StringBuilder ) null ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }
te	6	public void create ( final Game game , JPanel panel ) { panel . setBorder ( new EmptyBorder ( 5 , 5 , 5 , 5 ) ) ; panel . setLayout ( new BorderLayout ( 5 , 5 ) ) ; JPanel boxes = new JPanel ( new FlowLayout ( FlowLayout . LEFT , 10 , 10 ) ) ; final JCheckBox coalBox = new JCheckBox ( "Coal" ) , sulphurBox = new JCheckBox ( "Sulphur" ) , fertilizerBox = new JCheckBox ( "Fertilizer" ) , recruitBox = new JCheckBox ( "Recruits" ) ; boxes . add ( coalBox ) ; boxes . add ( sulphurBox ) ; boxes . add ( fertilizerBox ) ; boxes . add ( recruitBox ) ; panel . add ( boxes , BorderLayout . CENTER ) ; final JLabel errorLabel = new JLabel ( "" ) ; errorLabel . setForeground ( Color . RED ) ; panel . add ( errorLabel , BorderLayout . NORTH ) ; JPanel btnPanel = new JPanel ( new FlowLayout ( FlowLayout . CENTER , 10 , 10 ) ) ; JButton okBtn = new JButton ( "OK" ) ; JButton cancelBtn = new JButton ( "Cancel" ) ; btnPanel . add ( okBtn ) ; btnPanel . add ( cancelBtn ) ; panel . add ( btnPanel , BorderLayout . SOUTH ) ; okBtn . addMouseListener ( new MouseAdapter ( ) { @ Override public void mouseClicked ( MouseEvent e ) { if ( recruitBox . isSelected ( ) && game . getWorkerCount ( ) >= game . getMaxWorkers ( ) ) { errorLabel . setText ( "Cannot recruit any more terrorists at this level of notoriety" ) ; } else { Set < Resource > kinds = job . getKinds ( ) ; if ( coalBox . isSelected ( ) ) kinds . add ( Resource . COAL ) ; if ( sulphurBox . isSelected ( ) ) kinds . add ( Resource . SULPHUR ) ; if ( fertilizerBox . isSelected ( ) ) kinds . add ( Resource . FERTILIZER ) ; if ( recruitBox . isSelected ( ) ) kinds . add ( Resource . RECRUIT ) ; game . closeWindow ( ) ; } } } ) ; cancelBtn . addMouseListener ( new MouseAdapter ( ) { @ Override public void mouseClicked ( MouseEvent e ) { game . closeWindow ( ) ; } } ) ; }
te	8	@ Override public class < ? > getColumnClass ( int column ) { switch ( column ) { case 0 : return Integer . class ; case 1 : return Integer . class ; case 2 : return Integer . class ; case 3 : return Integer . class ; case 4 : return Integer . class ; case 9 : return Object . class ; case 10 : return Object . class ; default : return String . class ; } }
te	1	private Obs processObs ( StartElement se , XMLEventReader eventReader ) { Obs o = new Obs ( ) ; Iterator < Attribute > attributes = se . getAttributes ( ) ; while ( attributes . hasNext ( ) ) { Attribute attr = attributes . next ( ) ; o . addAttribute ( attr . getName ( ) . getLocalPart ( ) , attr . getValue ( ) ) ; } return o ; }
te	0	public Manager ( ) { super ( "Default" , "User" ) ; }
te	8	private boolean r_prelude ( ) { int among_var ; int v_1 ; replab0 : while ( true ) { v_1 = cursor ; lab1 : do { bra = cursor ; among_var = find_among ( a_0 , 3 ) ; if ( among_var == 0 ) { break lab1 ; } ket = cursor ; switch ( among_var ) { case 0 : break lab1 ; case 1 : slice_from ( "a~" ) ; break ; case 2 : slice_from ( "o~" ) ; break ; case 3 : if ( cursor >= limit ) { break lab1 ; } cursor ++ ; break ; } continue replab0 ; } while ( false ) ; cursor = v_1 ; break replab0 ; } return true ; }
te	9	@ Override public void panelResize ( ) { for ( Node current : reachable ) { for ( Node to : current . expand ( ) ) { if ( reachable . contains ( to ) ) { publish ( new HighlightEdge ( layer , current , to , Color . RED ) ) ; } } } for ( Node current : unreachable ) { for ( Node to : current . expand ( ) ) { if ( ! cover . contains ( to ) ) { publish ( new HighlightEdge ( layer , current , to , Color . RED ) ) ; } } publish ( new HighlightPoint ( layer , current , notCovered ) ) ; } for ( Node current : cover ) { for ( Node to : current . expand ( ) ) { if ( cover . contains ( to ) ) { publish ( new HighlightEdge ( layer , current , to , Color . YELLOW ) ) ; } else { publish ( new HighlightEdge ( layer , current , to , Color . GREEN ) ) ; publish ( new HighlightPoint ( layer , to , reachablePoint ) ) ; } } publish ( new HighlightPoint ( layer , current , coveredPoint ) ) ; } }
te	0	@ Override public Object getSelectedItem ( ) { return data . getSelectedItem ( ) ; }
te	5	public ZoneAff selectMenu ( ) { ZoneAff curMenu ; switch ( Fenetre . _state ) { case MenuPause : curMenu = _menuPause ; _menuPause . updateScore ( ) ; break ; case MenuHigh : curMenu = _menuHigh ; break ; case LevelLoad : _menuLevel = new MenuLevel ( ) ; curMenu = _menuLevel ; break ; case Victory : curMenu = _menuVict ; Fenetre . _level . saveHighScore ( ) ; _menuVict . updateMenu ( ) ; break ; case Fail : curMenu = _menuFail ; _menuFail . updateScore ( ) ; break ; default : curMenu = _menuPrinc ; break ; } return curMenu ; }
te	5	public boolean update ( Client client ) { int usersId = client . getUsersId ( ) ; Client curClient ; if ( ( curClient = getByUsersId ( usersId ) ) == null ) { return false ; } else { Statement statement = null ; ResultSet result = null ; try { statement = getConnection ( ) . createStatement ( ResultSet . TYPE_SCROLL_SENSITIVE , ResultSet . CONCUR_UPDATABLE ) ; result = statement . executeQuery ( allQuery ) ; while ( result . next ( ) ) { if ( result . getInt ( "ID" ) == curClient . getId ( ) ) { break ; } } result . updateString ( "CLIENTFIO" , client . getFio ( ) ) ; result . updateString ( "CLIENTADR" , client . getAddress ( ) ) ; result . updateString ( "CLIENTPAS" , client . getPassport ( ) ) ; result . updateString ( "CLIENTIDCOD" , client . getIdCod ( ) ) ; result . updateString ( "CLIENTTEL" , client . getTel ( ) ) ; result . updateLong ( "CLIENTLEVEL" , client . getLevel ( ) ) ; result . updateString ( "CLIENTWORKINFO" , client . getWorkInfo ( ) ) ; result . updateInt ( "USERSID" , client . getUsersId ( ) ) ; result . updateRow ( ) ; } catch ( SQLException exc ) { System . out . println ( "\u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u043E\u0431\u043D\u043E\u0432\u043B\u0435\u043D\u0438\u0438 \u0434\u0430\u043D\u043D\u044B\u0445" ) ; } finally { try { statement . close ( ) ; result . close ( ) ; } catch ( SQLException exc ) { System . out . println ( "\u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u0437\u0430\u043A\u0440\u044B\u0442\u0438\u0438 \u0441\u043E\u0435\u0434\u0438\u043D\u0435\u043D\u0438\u044F" ) ; } } } getList ( ) . clear ( ) ; setList ( listAll ( ) ) ; return true ; }
te	0	public IntegerSetting ( final String name_ , final String title , final Integer initValue ) { this ( name_ , title , initValue , null , null ) ; }
te	9	private static Object restrictedTo ( Object map_subtree , Object set_subtree , int lo , int hi ) { if ( map_subtree == null ) return null ; else if ( set_subtree == null ) return null ; else if ( ! ( map_subtree instanceof Node ) ) { Object [ ] map_ary = ( Object [ ] ) map_subtree ; if ( ! ( set_subtree instanceof FHashSet . Node ) ) return restrictedTo2 ( map_ary , ( Object [ ] ) set_subtree , lo , hi ) ; else { FHashSet . Node set_node = ( FHashSet . Node ) set_subtree ; Object raw_elt = set_node . element ; Object set_elt ; if ( raw_elt instanceof FHashSet . EquivalentSet ) set_elt = ( ( FHashSet . EquivalentSet ) raw_elt ) . contents . get ( 0 ) ; else set_elt = raw_elt ; int se_hash = set_node . ehash ; Object new_left = restrictedTo ( trim ( map_subtree , lo , se_hash ) , set_node . left , lo , se_hash ) ; Object new_right = restrictedTo ( trim ( map_subtree , se_hash , hi ) , set_node . right , se_hash , hi ) ; Entry entry = findEquiv ( map_subtree , se_hash ) ; if ( entry == null ) return join ( new_left , new_right ) ; else { Object k = equivRestrictedTo ( entry . key , entry . value , raw_elt ) ; if ( k == null ) return join ( new_left , new_right ) ; else { Entry ent = ( Entry ) k ; return concat ( ent . key , se_hash , ent . value , new_left , new_right ) ; } } } } else { Node map_node = ( Node ) map_subtree ; Object raw_key = map_node . key ; Object map_key ; if ( raw_key instanceof EquivalentMap ) map_key = ( ( EquivalentMap ) raw_key ) . contents . get ( 0 ) . key ; else map_key = raw_key ; int mk_hash = map_node . khash ; Object new_left = restrictedTo ( map_node . left , FHashSet . trim ( set_subtree , lo , mk_hash ) , lo , mk_hash ) ; Object new_right = restrictedTo ( map_node . right , FHashSet . trim ( set_subtree , mk_hash , hi ) , mk_hash , hi ) ; Object set_elt = FHashSet . findEquiv ( set_subtree , mk_hash ) ; if ( set_elt == FHashSet . NO_ELEMENT ) return join ( new_left , new_right ) ; else { Object k = equivRestrictedTo ( raw_key , map_node . value , set_elt ) ; if ( k == null ) return join ( new_left , new_right ) ; else if ( k instanceof EquivalentMap ) return concat ( k , mk_hash , null , new_left , new_right ) ; else { Entry ent = ( Entry ) k ; return concat ( ent . key , mk_hash , ent . value , new_left , new_right ) ; } } } }
te	5	private ListNode merge ( ListNode p1 , ListNode p2 ) { ListNode dummy = new ListNode ( 0 ) ; ListNode current = dummy ; while ( p1 != null && p2 != null ) { if ( p1 . val <= p2 . val ) { current . next = p1 ; p1 = p1 . next ; } else { current . next = p2 ; p2 = p2 . next ; } current = current . next ; } while ( p1 != null ) { current . next = p1 ; p1 = p1 . next ; current = current . next ; } while ( p2 != null ) { current . next = p2 ; p2 = p2 . next ; current = current . next ; } return dummy . next ; }
te	1	private static String fixTypos ( String document ) { for ( Map . Entry < Pattern , String > typo : TYPOS . entrySet ( ) ) { document = typo . getKey ( ) . matcher ( document ) . replaceAll ( typo . getValue ( ) ) ; } return document ; }
te	6	private boolean verifyChildrenOfRedNodes ( RBNode < T > node ) { boolean resp = false ; if ( node . isEmpty ( ) ) { return true ; } else { if ( node . getColour ( ) . equals ( Colour . RED ) ) { if ( ( ( RBNode < T > ) node . getLeft ( ) ) . getColour ( ) . equals ( Colour . RED ) || ( ( RBNode < T > ) node . getRight ( ) ) . getColour ( ) . equals ( Colour . RED ) ) { resp = false ; } else { resp = verifyChildrenOfRedNodes ( ( RBNode < T > ) node . getLeft ( ) ) && verifyChildrenOfRedNodes ( ( RBNode < T > ) node . getRight ( ) ) ; } } else { resp = verifyChildrenOfRedNodes ( ( RBNode < T > ) node . getLeft ( ) ) && verifyChildrenOfRedNodes ( ( RBNode < T > ) node . getRight ( ) ) ; } } return resp ; }
te	1	public void actionPerformed ( ActionEvent event ) { if ( event . getSource ( ) . equals ( colorButton ) ) { Color newColor = JColorChooser . showDialog ( null , "Choose new page background color" , colorButton . getBackground ( ) ) ; colorButton . setBackground ( newColor ) ; return ; } modalResult = ( event . getActionCommand ( ) . equals ( "ok" ) ) ; setVisible ( false ) ; }
te	8	public Map < String , Map < String , boolean >> getPermissions ( String world ) { Map < String , Map < String , boolean >> result = new LinkedHashMap < String , Map < String , boolean >> ( ) ; Map < String , boolean > groupperms = new LinkedHashMap < String , boolean > ( ) ; groupperms . put ( "droxperms.meta.group." + name , true ) ; if ( world != null ) { groupperms . put ( "droxperms.meta.group." + name + "." + Config . getRealWorld ( world ) , true ) ; } result . put ( "group" , groupperms ) ; if ( subgroups != null ) { Map < String , boolean > subgroupperms = new LinkedHashMap < String , boolean > ( ) ; for ( Iterator < String > iterator = subgroups . iterator ( ) ; iterator . hasNext ( ) ; ) { String subgroup = iterator . next ( ) ; subgroupperms . put ( "droxperms.meta.group." + subgroup , true ) ; if ( world != null ) { subgroupperms . put ( "droxperms.meta.group." + subgroup + "." + Config . getRealWorld ( world ) , true ) ; } } result . put ( "subgroups" , subgroupperms ) ; } if ( globalPermissions != null ) { result . put ( "global" , globalPermissions ) ; } if ( world != null && permissions != null ) { Map < String , boolean > worldperms = new LinkedHashMap < String , boolean > ( ) ; if ( permissions . get ( Config . getRealWorld ( world ) ) != null ) { worldperms . putAll ( permissions . get ( Config . getRealWorld ( world ) ) ) ; } result . put ( "world" , worldperms ) ; } return result ; }
te	0	public void setDescription ( String value ) { this . description = value ; this . isDescriptionDirty = true ; setDirty ( ) ; }
te	6	public boolean remove ( String word ) { if ( sensitiveWords . isEmpty ( ) || StringUtils . isEmpty ( word ) ) { return false ; } Set < Keyword > ws = new HashSet < Keyword > ( ) ; for ( Keyword w : sensitiveWords ) { if ( word . equals ( w . getWord ( ) ) ) { ws . add ( w ) ; } } if ( ! ws . isEmpty ( ) ) { for ( Keyword w : ws ) { sensitiveWords . remove ( w ) ; } initWords ( ) ; return true ; } return false ; }
te	5	@ Override public int read ( ) throws IOException { synchronized ( lock ) { ensureOpen ( ) ; for ( ; ; ) { if ( nextChar >= nChars ) { fill ( ) ; if ( nextChar >= nChars ) return - 1 ; } if ( skipLF ) { skipLF = false ; if ( cb [ nextChar ] == '' ) { nextChar ++ ; continue ; } } return cb [ nextChar ++ ] ; } } }
te	5	public Map processIncomingEvent ( Map map , MapViewer mapViewer , PropertiesMapSaver saver , ObjectInputStream ois , Object source ) throws IOException , ClassNotFoundException , Exception , NoSuchMethodException , InstantiationException , IllegalAccessException , InvocationTargetException { MapEvent . EventType eventType = ( EventType ) ois . readObject ( ) ; Properties props = ( Properties ) ois . readObject ( ) ; Mappable mappable = null ; switch ( eventType ) { case NEW_MAP : map = saver . convertProperties ( props ) ; mapViewer . loadMap ( map ) ; break ; case ADD_OBJECT : mappable = saver . convertMappable ( props , map ) ; mapViewer . getMap ( ) . addMapObject ( mappable , source ) ; break ; case REMOVE_OBJECT : mappable = saver . convertMappable ( props , map ) ; mapViewer . getMap ( ) . removeMapObject ( mappable , source ) ; break ; case CHANGE_OBJECT : mappable = saver . convertMappable ( props , map == null ? mapViewer . getMap ( ) : map ) ; mapViewer . getMap ( ) . removeMapObject ( mappable , source ) ; mapViewer . getMap ( ) . addMapObject ( mappable , source ) ; break ; } return map ; }
te	8	@ Override public Component getTableCellRendererComponent ( JTable table , Object value , boolean isSelected , boolean hasFocus , int row , int column ) { String serviceName = ( String ) table . getValueAt ( row , column - 1 ) ; User user = instanceGUI . getUser ( ) ; JLabel label ; UserTransferStatus transferStatus = user . getServiceTransfer ( serviceName ) ; if ( transferStatus != null ) { JPanel panel = new JPanel ( new GridLayout ( 1 , 2 ) ) ; JProgressBar progress = new JProgressBar ( 0 , 100 ) ; JLabel progressLabel = new JLabel ( transferStatus . getSeller ( ) + " - " + transferStatus . getStatus ( ) ) ; progress . setValue ( transferStatus . getProgress ( ) ) ; progress . setStringPainted ( true ) ; progress . setFont ( new Font ( Font . SANS_SERIF , Font . BOLD , 10 ) ) ; progress . setBorder ( BorderFactory . createBevelBorder ( javax . swing . border . BevelBorder . RAISED ) ) ; panel . add ( progressLabel ) ; panel . add ( progress ) ; return panel ; } if ( user . isEmptyServiceList ( ) || user . isEmptyService ( serviceName ) ) { label = new JLabel ( StatusMessages . inactive . toUpperCase ( ) ) ; label . setHorizontalAlignment ( SwingConstants . CENTER ) ; return label ; } String val = ( String ) value ; if ( val . equalsIgnoreCase ( StatusMessages . inactive ) ) { label = new JLabel ( Symbols . chooseString ) ; label . setHorizontalAlignment ( SwingConstants . CENTER ) ; return label ; } HashMap < String , String > matches = instanceGUI . getUser ( ) . getServiceProviders ( serviceName ) ; Set < String > users = matches . keySet ( ) ; boolean unchanged = false ; String newStatus = null ; for ( String match : users ) { if ( val . contains ( match ) ) { if ( val . contains ( matches . get ( match ) ) ) { unchanged = true ; break ; } newStatus = match + " - " + matches . get ( match ) ; } } if ( ! unchanged ) { val = newStatus ; } label = new JLabel ( val ) ; label . setHorizontalAlignment ( SwingConstants . CENTER ) ; return label ; }
te	6	public boolean containsCell ( final Position from , final Position to ) { if ( from . equals ( to ) ) { return cells . containsKey ( from ) ? ! cells . get ( from ) . equals ( Cell . HOLE ) : false ; } for ( int y = from . getY ( ) ; y <= to . getY ( ) ; ++ y ) { for ( int x = from . getX ( ) ; x <= to . getX ( ) ; ++ x ) { final Position pos = Position . valueOf ( x , y ) ; if ( cells . containsKey ( pos ) && ! cells . get ( pos ) . equals ( Cell . HOLE ) ) { return true ; } } } return false ; }
te	4	public static double asin ( double arg ) { double temp ; int sign ; sign = 0 ; if ( arg < 0 ) { arg = - arg ; sign ++ ; } if ( arg > 1 ) { return nan ; } temp = Math . sqrt ( 1 - arg * arg ) ; if ( arg > 0.7 ) { temp = PIO2 - atan ( temp / arg ) ; } else { temp = atan ( arg / temp ) ; } if ( sign > 0 ) { temp = - temp ; } return temp ; }
te	5	@ Override public void update ( Observable o , Object arg ) { if ( benutzer . getBenutzerTyp ( ) . equals ( "admin" ) ) { if ( ( int ) arg == 0 ) infoControl . updateView ( "benutzer verwalten" ) ; else if ( ( int ) arg == 1 ) infoControl . updateView ( "email senden" ) ; else if ( ( int ) arg == 2 ) infoControl . updateView ( "log einsehen" ) ; else if ( ( int ) arg == 3 ) infoControl . updateView ( "passwort aendern" ) ; } }
te	1	public void setGrantClass ( class < ? extends OAuth2Grant > grantClass ) { this . grantClass = grantClass ; }
te	1	private static byte normalizeByte ( byte b ) { if ( b < 0 ) { return ( byte ) ( 256 + b ) ; } else return b ; }
te	9	public InputField getInputFieldAt ( final int x , final int y ) { for ( final Iterator < Field > i = fields . iterator ( ) ; i . hasNext ( ) ; ) { final Field f = i . next ( ) ; if ( f instanceof InputField && ! f . isEmpty ( ) ) { final int startx = f . getStartX ( ) ; final int starty = f . getStartY ( ) ; final int endx = f . getEndX ( ) ; final int endy = f . getEndY ( ) ; if ( y < starty ) { continue ; } if ( y == starty ) { if ( x < startx ) { continue ; } if ( y == endy && x > endx ) { continue ; } return ( InputField ) f ; } if ( y > endy ) { continue ; } if ( y == endy ) { if ( x > endx ) { continue ; } return ( InputField ) f ; } else { return ( InputField ) f ; } } } return null ; }
te	2	protected static void insertDB ( String insert ) { Connection conn = OmniDex . getConnection ( ) ; if ( conn != null ) { try { PreparedStatement pst = conn . prepareStatement ( insert ) ; pst . execute ( ) ; } catch ( SQLException e ) { System . out . println ( "insert : " + insert + " failed!" ) ; e . printStackTrace ( ) ; } } else { System . out . println ( "Connection is null!" ) ; } }
te	5	private void pop ( char c ) throws JSONException { if ( this . top <= 0 ) { throw new JSONException ( "Nesting error." ) ; } char m = this . stack [ this . top - 1 ] == null ? a : k ; if ( m != c ) { throw new JSONException ( "Nesting error." ) ; } this . top -= 1 ; this . mode = this . top == 0 ? d : this . stack [ this . top - 1 ] == null ? a : k ; }
te	2	private Whiteboard _parseWhiteboard ( String data ) { Whiteboard board = new Whiteboard ( ) ; for ( int y = 0 ; y < Whiteboard . HEIGHT ; y ++ ) { for ( int x = 0 ; x < Whiteboard . WIDTH ; x ++ ) { int baseIndex = ( y * Whiteboard . WIDTH + x ) * 3 * 2 ; int red = hexToByte ( data . charAt ( baseIndex ) , data . charAt ( baseIndex + 1 ) ) ; int green = hexToByte ( data . charAt ( baseIndex + 2 ) , data . charAt ( baseIndex + 3 ) ) ; int blue = hexToByte ( data . charAt ( baseIndex + 4 ) , data . charAt ( baseIndex + 5 ) ) ; board . setPixel ( new Point ( x , y ) , new Color ( red , green , blue ) ) ; } } return board ; }
te	9	private List sendRequest ( final RequestMessage req , final List scopeList ) throws ServiceLocationException { List scopes = scopeList != null ? scopeList : Arrays . asList ( new String [ ] { "default" } ) ; ArrayList result = new ArrayList ( ) ; for ( Iterator scopeIter = scopes . iterator ( ) ; scopeIter . hasNext ( ) ; ) { String scope = ( String ) scopeIter . next ( ) ; scope = scope . toLowerCase ( ) ; List dAs = ( List ) SLPCore . dAs . get ( scope ) ; SLPCore . platform . logDebug ( "DAS FOR SCOPE " + scope + ": " + dAs ) ; if ( ( dAs == null || dAs . isEmpty ( ) ) && ! SLPCore . noDiscovery ) { SLPCore . daLookup ( Arrays . asList ( new String [ ] { scope } ) ) ; synchronized ( SLPCore . dAs ) { try { SLPCore . dAs . wait ( SLPCore . CONFIG . getWaitTime ( ) / 4 ) ; } catch ( InterruptedException e ) { SLPCore . platform . logError ( e . getMessage ( ) , e ) ; Thread . currentThread ( ) . interrupt ( ) ; } } dAs = ( List ) SLPCore . dAs . get ( scope ) ; } if ( dAs != null && ! dAs . isEmpty ( ) ) { try { result . addAll ( sendRequestToDA ( req , dAs ) ) ; } catch ( ServiceLocationException slp ) { result . addAll ( SLPCore . multicastConvergence ( req ) ) ; } continue ; } else { if ( SLPCore . noDiscovery ) { throw new ServiceLocationException ( ServiceLocationException . SCOPE_NOT_SUPPORTED , "Scope " + scope + " is not supported" ) ; } result . addAll ( SLPCore . multicastConvergence ( req ) ) ; } } return result ; }
te	5	@ Override public boolean equals ( Object object ) { if ( ! ( object instanceof Document ) ) { return false ; } Document other = ( Document ) object ; if ( ( this . idDocument == null && other . idDocument != null ) || ( this . idDocument != null && ! this . idDocument . equals ( other . idDocument ) ) ) { return false ; } return true ; }
te	5	protected byte [ ] expandKey ( byte [ ] key ) { long val = 0 ; for ( int n = 0 ; n < 7 ; n ++ ) { val <<= 8 ; val |= ( key [ n ] & FF ) ; } byte [ ] out = new byte [ 8 ] ; for ( int n = 8 ; n > 0 ; n -- ) { byte b = ( byte ) ( val & 7F ) ; out [ n - 1 ] = ( byte ) ( b << 1 ) ; val >>= 7 ; boolean parity = true ; for ( int j = 0 ; j < 8 ; j ++ ) if ( ( b & ( 1 << j ) ) != 0 ) parity = ! parity ; if ( parity ) out [ n - 1 ] |= 1 ; } return out ; }
te	8	public int compareTo ( Time t ) { int act = ( this . getIdActivity ( ) == t . getIdActivity ( ) ) ? 0 : ( this . getIdActivity ( ) < t . getIdActivity ( ) ) ? - 1 : 1 ; int start = this . getStartTime ( ) . compareTo ( t . getStartTime ( ) ) ; int end = this . getEndTime ( ) . compareTo ( t . getEndTime ( ) ) ; int dur = ( this . getDuration ( ) == t . getDuration ( ) ) ? 0 : ( this . getDuration ( ) < t . getDuration ( ) ) ? - 1 : 1 ; int desc = this . getDescription ( ) . compareTo ( t . getDescription ( ) ) ; if ( act != 0 ) return act ; if ( start != 0 ) return start ; if ( end != 0 ) return end ; if ( dur != 0 ) return dur ; else return desc ; }
te	8	private void addTag ( String tag , String value , boolean decrypt , String type , String key ) { if ( decrypt ) { value = crypto . decrypt ( value , key , type ) ; } switch ( tag ) { case MESSAGE : break ; case TEXT : message . setText ( value ) ; break ; case DISCONNECT : message . setDisconnect ( true ) ; break ; case REQUEST : message . setRequestMessage ( value ) ; break ; case "filerequest" : message . setFileMessage ( value ) ; break ; case "fileresponse" : message . setFileResponseMessage ( value ) ; break ; case "keyrequest" : message . setKeyRequest ( value ) ; break ; } }
te	7	@ Override public String getColumnName ( int column ) { if ( column < 30 ) { return "int column" + " " + column ; } else if ( column < 60 ) { return "double column" + " " + column ; } else if ( column < 90 ) { return "boolean column" + " " + column ; } else if ( column < 120 ) { return "string column" + " " + column ; } else if ( column < 150 ) { return "istring column" + " " + column ; } else if ( column < 180 ) { return "date column" + " " + column ; } else if ( column < 210 ) { return "long column" + " " + column ; } return "" ; }
te	2	public void serve ( ) { while ( true ) { try { Socket client = null ; LOG . debug ( "Waiting for the clients' requests on the address: [{}/{}]..." , InetAddress . getLocalHost ( ) . getHostAddress ( ) , server . getLocalPort ( ) ) ; client = server . accept ( ) ; LOG . debug ( "Accepted connection from client [{}]." , client . getInetAddress ( ) . getHostAddress ( ) ) ; executors . submit ( new RobotServerTask ( new RobotProtocolTemplate ( client . getInputStream ( ) , client . getOutputStream ( ) ) , client ) ) ; } catch ( IOException e ) { LOG . error ( "Fail to accept connection from client: {}" , e ) ; } finally { } } }
te	5	static private final int jjMoveStringLiteralDfa12_0 ( long old0 , long active0 ) { if ( ( ( active0 &= old0 ) ) == 0 ) return jjStartNfa_0 ( 10 , old0 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 11 , active0 ) ; return 12 ; } switch ( curChar ) { case 95 : return jjMoveStringLiteralDfa13_0 ( active0 , 20 ) ; case 100 : return jjMoveStringLiteralDfa13_0 ( active0 , 3000 ) ; case 105 : return jjMoveStringLiteralDfa13_0 ( active0 , 40 ) ; default : break ; } return jjStartNfa_0 ( 11 , active0 ) ; }
