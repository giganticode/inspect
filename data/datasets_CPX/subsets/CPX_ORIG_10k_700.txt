tr	4	private void showInfo ( ) { try { FileReader file = new FileReader ( "data/info.txt" ) ; BufferedReader buff = new BufferedReader ( file ) ; boolean eof = false ; while ( ! eof ) { String line = buff . readLine ( ) ; if ( line != null ) { infoArea . append ( "\n" + line ) ; } else { eof = true ; } } } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }
tr	5	public static int CheckSubmit ( Submit submit ) { if ( submit . getMsgType ( ) != 6 ) return 30 ; if ( ! submit . getFeetype ( ) . equals ( "00" ) && ! submit . getFeetype ( ) . equals ( "01" ) && submit . getFeetype ( ) . equals ( "02" ) ) return 32 ; if ( submit . getMsgFormat ( ) > 15 ) return 34 ; return 0 ; }
tr	8	private void jMenuItem1ActionPerformed ( java . awt . event . ActionEvent evt ) { final String inputValue = JOptionPane . showInputDialog ( "Enter a chatroom name" ) ; final JButton btnClose = new JButton ( "x" ) ; if ( inputValue . isEmpty ( ) ) { JOptionPane . showMessageDialog ( GUI . this , "Please enter a name." , "Input Error" , JOptionPane . WARNING_MESSAGE ) ; } else { try { client . sendJoinChatRoomMessage ( inputValue ) ; } catch ( JMSException e ) { throw new RuntimeException ( e ) ; } ChatClientApplicationGUI . addServerMessageListener ( new ServerMessageListener ( ) { public void onMessageReceived ( ChatMessage m ) { if ( ! ( m instanceof ChatRoomUsersMessage ) ) return ; final ChatRoomUsersMessage ulm = ( ChatRoomUsersMessage ) m ; if ( ulm . getChatRoom ( ) . equals ( tabbedPane . getTitleAt ( tabbedPane . getSelectedIndex ( ) ) ) ) { userList . setModel ( new javax . swing . AbstractListModel ( ) { List < String > strings = ulm . getUsers ( ) ; public int getSize ( ) { return strings . size ( ) ; } public Object getElementAt ( int i ) { return strings . get ( i ) ; } } ) ; } } } ) ; ChatClientApplicationGUI . addServerMessageListener ( new ServerMessageListener ( ) { public void onMessageReceived ( ChatMessage m ) { if ( ! ( m instanceof JoinChatRoomMessage ) ) return ; try { client . sendChatRoomUserListMessage ( inputValue ) ; } catch ( JMSException e ) { throw new RuntimeException ( e ) ; } final JTextArea jta = new JTextArea ( ) ; tabbedPane . addTab ( inputValue , null , jta , null ) ; ChatClientApplicationGUI . addServerMessageListener ( new ServerMessageListener ( ) { public void onMessageReceived ( ChatMessage m ) { if ( ! ( m instanceof ChatTextMessage ) ) return ; final ChatTextMessage ulm = ( ChatTextMessage ) m ; jta . append ( "[" + ulm . getUsername ( ) + "]: " + ulm . getText ( ) + "\n" ) ; } } ) ; int index = tabbedPane . indexOfTab ( inputValue ) ; JPanel pnlTab = new JPanel ( ) ; pnlTab . setOpaque ( false ) ; JLabel lblTitle = new JLabel ( inputValue ) ; pnlTab . add ( lblTitle ) ; pnlTab . add ( btnClose ) ; tabbedPane . setTabComponentAt ( index , pnlTab ) ; btnClose . addActionListener ( new java . awt . event . ActionListener ( ) { public void actionPerformed ( java . awt . event . ActionEvent evt ) { btnCloseActionPerformed ( evt ) ; } private void btnCloseActionPerformed ( ActionEvent evt ) { Point mousePos = tabbedPane . getMousePosition ( ) ; int mouseX = mousePos . x ; int mouseY = mousePos . y ; int index = tabbedPane . indexAtLocation ( mouseX , mouseY ) ; Component selected = tabbedPane . getComponentAt ( index ) ; if ( selected != null ) { tabbedPane . remove ( selected ) ; } } } ) ; jta . append ( "[System]: Joined " + inputValue + "\n" ) ; ChatClientApplicationGUI . removeServerMessageListener ( this ) ; } } ) ; } }
tr	9	public static void main ( String [ ] args ) { char [ ] [ ] arr = new char [ ] [ ] { { i , l , o , v , e } , { d , i , n , t , e } , { n , e , w , e , p } , { a , i , v , r , i } , { m , a , x , e , c } } ; boolean [ ] [ ] flag = new boolean [ 5 ] [ 5 ] ; int count = 0 ; int i = 0 ; int j = 0 ; int direction = 0 ; System . out . print ( arr [ i ] [ j ] ) ; flag [ i ] [ j ] = true ; while ( count != ( 5 * 5 ) - 1 ) { switch ( direction ) { case 0 : { if ( j + 1 < 5 && ! flag [ i ] [ j + 1 ] ) { j ++ ; count ++ ; flag [ i ] [ j ] = true ; System . out . print ( arr [ i ] [ j ] ) ; } else { direction = 1 ; } break ; } case 1 : { if ( i + 1 < 5 && ! flag [ i + 1 ] [ j ] ) { i ++ ; count ++ ; flag [ i ] [ j ] = true ; System . out . print ( arr [ i ] [ j ] ) ; } else { direction = 2 ; } break ; } case 2 : { if ( j - 1 > - 1 && ! flag [ i ] [ j - 1 ] ) { direction = 2 ; j -- ; count ++ ; flag [ i ] [ j ] = true ; System . out . print ( arr [ i ] [ j ] ) ; } else { direction = 3 ; } break ; } case 3 : { if ( i - 1 > - 1 && ! flag [ i - 1 ] [ j ] ) { direction = 3 ; i -- ; count ++ ; flag [ i ] [ j ] = true ; System . out . print ( arr [ i ] [ j ] ) ; } else { direction = 0 ; } break ; } } } }
tr	8	public static int searchInt ( int [ ] arr , int low , int high , int x ) { if ( low > high ) return - 1 ; int mid = ( low + high ) / 2 ; if ( x == arr [ mid ] ) return mid ; if ( arr [ mid ] >= arr [ low ] && arr [ mid ] >= arr [ high ] ) { if ( x >= arr [ low ] && x < arr [ mid ] ) return searchInt ( arr , low , mid - 1 , x ) ; else return searchInt ( arr , mid , high , x ) ; } else { if ( x > arr [ mid ] && x <= arr [ high ] ) return searchInt ( arr , mid + 1 , high , x ) ; else return searchInt ( arr , low , mid , x ) ; } }
tr	0	public boolean hasStart ( ) { return ( ( bitField0_ & 00000001 ) == 00000001 ) ; }
tr	9	public static int findMinElement ( int [ ] array ) { int len = array . length ; if ( len == 0 ) { return - 1 ; } if ( len == 1 ) { return array [ 0 ] ; } int start = 0 ; int end = len - 1 ; while ( start < end ) { int mid = ( start + end ) / 2 ; int rightVal = ( mid + 1 == len ? array [ 0 ] : array [ mid + 1 ] ) ; int leftVal = ( mid == 0 ? array [ len - 1 ] : array [ mid - 1 ] ) ; if ( array [ mid ] < rightVal && array [ mid ] < leftVal ) { return array [ mid ] ; } if ( array [ mid ] > rightVal ) { return rightVal ; } if ( array [ mid ] > array [ end ] ) { start = mid ; } else if ( array [ mid ] < array [ start ] ) { end = mid ; } else { break ; } } return array [ start ] ; }
tr	2	public static boolean allPrime ( long ... nums ) { for ( long num : nums ) { if ( ! sieve . primes . contains ( num ) ) { return false ; } } return true ; }
tr	3	public JSONObject accumulate ( String key , Object value ) throws JSONException { testValidity ( value ) ; Object object = this . opt ( key ) ; if ( object == null ) { this . put ( key , value instanceof JSONArray ? new JSONArray ( ) . put ( value ) : value ) ; } else if ( object instanceof JSONArray ) { ( ( JSONArray ) object ) . put ( value ) ; } else { this . put ( key , new JSONArray ( ) . put ( object ) . put ( value ) ) ; } return this ; }
tr	9	@ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; Appointment other = ( Appointment ) obj ; if ( end == null ) { if ( other . end != null ) return false ; } else if ( ! end . equals ( other . end ) ) return false ; if ( start == null ) { if ( other . start != null ) return false ; } else if ( ! start . equals ( other . start ) ) return false ; return true ; }
tr	1	public Object getRecipient ( ) { if ( toName != null ) { return toName ; } return to ; }
tr	2	@ Override public void add ( Client element ) { getList ( ) . add ( element ) ; Statement statement = null ; ResultSet result = null ; try { statement = getConnection ( ) . createStatement ( ResultSet . TYPE_SCROLL_SENSITIVE , ResultSet . CONCUR_UPDATABLE ) ; result = statement . executeQuery ( allQuery ) ; result . moveToInsertRow ( ) ; result . updateString ( "CLIENTFIO" , element . getFio ( ) ) ; result . updateString ( "CLIENTADR" , element . getAddress ( ) ) ; result . updateString ( "CLIENTPAS" , element . getPassport ( ) ) ; result . updateString ( "CLIENTIDCOD" , element . getIdCod ( ) ) ; result . updateString ( "CLIENTTEL" , element . getTel ( ) ) ; result . updateLong ( "CLIENTLEVEL" , element . getLevel ( ) ) ; result . updateString ( "CLIENTWORKINFO" , element . getWorkInfo ( ) ) ; result . updateInt ( "USERSID" , element . getUsersId ( ) ) ; result . insertRow ( ) ; } catch ( SQLException ex ) { System . out . println ( "\u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u0438\u0437\u043C\u0435\u043D\u0435\u043D\u0438\u0438 \u0442\u0430\u0431\u043B\u0438\u0446\u044B" ) ; } finally { try { statement . close ( ) ; result . close ( ) ; } catch ( SQLException ex ) { System . out . println ( "\u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u0437\u0430\u043A\u0440\u044B\u0442\u0438\u0438 \u0441\u043E\u0435\u0434\u0438\u043D\u0435\u043D\u0438\u044F" ) ; } } }
tr	2	public void registerProcessor ( OspreyProcessor < ? > processor ) { if ( null != processors . putIfAbsent ( processor . interest ( ) , processor ) ) { LOGGER . warn ( "Register Processor[" + processor . interest ( ) + "  " + processor + "]." , new Exception ( ) ) ; } }
tr	5	public static synchronized int addUser ( String roomName , User user ) { for ( GameRoom room : briscaGames ) { if ( room . getName ( ) . equals ( roomName ) ) { for ( Player player : room . getPlayers ( ) ) { if ( player == null ) continue ; if ( player . getUser ( ) . getUsername ( ) . equals ( user . getUsername ( ) ) ) { player . setUser ( user ) ; return player . getSeatNumber ( ) ; } } return room . addPlayer ( Player . getInstance ( 0 , user ) ) ; } } return - 1 ; }
tr	2	public static List < Point2D > getObjectContourPoints ( ABObject ob ) { List < Point2D > bounds = new ArrayList < Point2D > ( ) ; if ( ob . getType ( ) == ABType . Pig || ob . shape == ABShape . Circle ) { bounds = CircleContour ( ob ) ; } else { List < Point > ps = PolyContour ( PolyCorners ( ob ) ) ; bounds = convertToPoint2D ( ps ) ; } return bounds ; }
tr	2	@ Override public void finishProcess ( ) { super . finishProcess ( ) ; if ( this . simFileFormat . equals ( SIM_FILE_FORMAT . ID_ID_SIM ) ) { String [ ] ids = new String [ this . idToKey . size ( ) ] ; for ( int i = 0 ; i < this . idToKey . size ( ) ; i ++ ) { ids [ i ] = this . idToKey . get ( i ) ; } this . similarities . setIds ( ids ) ; return ; } }
tr	3	public boolean hasSlot ( String name ) { if ( slots . containsKey ( name ) ) return true ; for ( MinObject proto : protos ) { if ( proto . hasSlot ( name ) ) return true ; } return false ; }
tr	3	boolean sameValue ( DNSRecord other ) { Service s = ( Service ) other ; return ( priority == s . priority ) && ( weight == s . weight ) && ( port == s . port ) && server . equals ( s . server ) ; }
tr	0	@ Override public int getInt ( long index , int offset ) { assert offset <= structLength - 4 : offset ; return ohm . getInt ( index * structLength + offset ) ; }
tr	6	public static float valueOf ( Object o ) { if ( o == null ) { return null ; } else if ( o instanceof float ) { return ( float ) o ; } else if ( o instanceof double ) { return ( float ) o ; } else if ( o instanceof byte ) { return ( float ) ( byte ) o ; } else if ( o instanceof Integer ) { return ( float ) ( Integer ) o ; } else if ( o instanceof long ) { return ( float ) ( long ) o ; } else { return null ; } }
tr	1	public void actionPerformed ( ActionEvent e ) { String albumName = albumNameTF . getText ( ) ; try { makeAlbumPopUp . this . photosScreen . makeAlbum ( albumName ) ; } catch ( Exception e1 ) { e1 . printStackTrace ( ) ; } }
tr	7	public static void main ( String [ ] args ) { BigInteger totalSum = BigInteger . ZERO ; for ( int i = 2 ; i <= 4 ; i ++ ) { BigInteger [ ] [ ] arrangements = new BigInteger [ 51 ] [ 50 ] ; for ( int j = 0 ; j <= 50 ; j ++ ) for ( int k = 0 ; k < 50 ; k ++ ) arrangements [ j ] [ k ] = BigInteger . ZERO ; arrangements [ 1 ] [ 0 ] = BigInteger . ONE ; for ( int j = 1 ; j < 50 ; j ++ ) { for ( int k = 1 ; k <= 50 ; k ++ ) arrangements [ k ] [ j ] = arrangements [ k - 1 ] [ j - 1 ] ; for ( int k = i ; k <= 50 ; k ++ ) arrangements [ 0 ] [ j ] = arrangements [ 0 ] [ j ] . add ( arrangements [ k ] [ j ] ) ; } for ( int j = 0 ; j < 50 ; j ++ ) totalSum = totalSum . add ( arrangements [ j ] [ 49 ] ) ; } System . out . println ( totalSum ) ; }
tr	2	public void initNew ( ) { if ( aDataMap == null ) aDataMap = new HashMap < ASection , AData > ( ) ; else aDataMap . clear ( ) ; try { this . replace ( 0 , getLength ( ) , "" , defaultStyle ) ; } catch ( BadLocationException e ) { System . out . println ( "Error in ADocument.initNew() :\n" ) ; e . printStackTrace ( ) ; } putProperty ( ( Object ) TitleProperty , ( Object ) DEFAULT_TITLE ) ; putProperty ( ( Object ) ExpertProperty , ( Object ) "" ) ; putProperty ( ( Object ) ClientProperty , ( Object ) "" ) ; Date date = new Date ( ) ; putProperty ( ( Object ) DateProperty , ( Object ) date . toLocaleString ( ) ) ; putProperty ( ( Object ) CommentProperty , "" ) ; setCharacterAttributes ( 0 , 1 , defaultStyle , true ) ; fireADocumentChanged ( ) ; Analyst . initUndoManager ( ) ; }
tr	3	private void replaceNode ( LinkSetNode oldn , LinkSetNode newn ) { if ( oldn . parent == null ) { root = newn ; } else { if ( oldn == oldn . parent . left ) { oldn . parent . left = newn ; } else { oldn . parent . right = newn ; } } if ( newn != null ) { newn . parent = oldn . parent ; } }
tr	3	public BitVector ( long unsigned , long length ) { this . length = length ; if ( unsigned < 0 ) { g = null ; } else { g = new byte [ ( int ) ( length / 8 ) + ( length % 8 > 0 ? 1 : 0 ) ] ; for ( int i = 0 ; i < g . length ; i ++ ) { g [ i ] = unsignedToByte ( ( int ) ( unsigned % 256 ) ) ; unsigned /= 256 ; } } }
tr	8	public int longestValidParentheses ( String s ) { int a [ ] = new int [ s . length ( ) ] ; int last = - 1 ; int max = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == ( ) { a [ i ] = last ; last = i ; } else { a [ i ] = last ; if ( last != - 1 ) { int len = i - last + 1 ; int temp = last - 1 ; while ( temp >= 0 && s . charAt ( temp ) == ) && a [ temp ] >= 0 ) { len += temp - a [ temp ] + 1 ; temp = a [ temp ] - 1 ; } if ( len > max ) { max = len ; } } if ( last >= 0 ) last = a [ last ] ; else last = - 1 ; } } return max ; }
tr	5	@ Override public void setup ( OAuth2Settings settings ) throws OAuth2SettingsException { if ( settings == null ) { throw new OAuth2SettingsException ( "Missing settings." ) ; } if ( Utils . isNullOrEmpty ( settings . getTokenUri ( ) ) ) { throw new OAuth2SettingsException ( "Token server URI missing." ) ; } else { tokenServer = settings . getTokenUri ( ) ; } if ( ! Utils . isNullOrEmpty ( settings . getScope ( ) ) ) { tokenParams . put ( "scope" , settings . getScope ( ) ) ; } tokenParams . put ( "grant_type" , "client_credentials" ) ; for ( Entry < String , String > entry : settings . getExtraTokenParams ( ) . entrySet ( ) ) { if ( ! tokenParams . containsKey ( entry . getKey ( ) ) ) { tokenParams . put ( entry . getKey ( ) , entry . getValue ( ) ) ; } } }
tr	2	@ Test public void addNullValue ( ) { AVLTree < Integer , Integer > b = new AVLTree < Integer , Integer > ( ) ; try { b . add ( 1 , null ) ; fail ( IllegalArgumentException . class ) ; } catch ( IllegalArgumentException e ) { } catch ( Exception e ) { fail ( IllegalArgumentException . class , e ) ; } }
tr	3	public Matrix getU ( ) { Matrix X = new Matrix ( n , n ) ; double [ ] [ ] U = X . getArray ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i <= j ) { U [ i ] [ j ] = LU [ i ] [ j ] ; } else { U [ i ] [ j ] = 0.0 ; } } } return X ; }
tr	1	@ SuppressWarnings ( "unchecked" ) private void initComponents ( ) { editNameLabel = new javax . swing . JLabel ( ) ; editNameField = new javax . swing . JTextField ( ) ; editTypeLabel = new javax . swing . JLabel ( ) ; editTypeDropdown = new javax . swing . JComboBox ( ) ; editValueLabel = new javax . swing . JLabel ( ) ; editCancelButton = new javax . swing . JButton ( ) ; editSaveButton = new javax . swing . JButton ( ) ; editValueField = new javax . swing . JTextField ( ) ; editValueValidationLabel = new javax . swing . JLabel ( ) ; setDefaultCloseOperation ( javax . swing . WindowConstants . DISPOSE_ON_CLOSE ) ; setTitle ( "Editing key " + key ) ; editNameLabel . setText ( "Key:" ) ; editNameField . setText ( this . key ) ; editTypeLabel . setText ( "Type:" ) ; editTypeDropdown . setModel ( new javax . swing . DefaultComboBoxModel ( ValueTypes . values ( ) ) ) ; editTypeDropdown . addActionListener ( new java . awt . event . ActionListener ( ) { public void actionPerformed ( java . awt . event . ActionEvent evt ) { editTypeDropdownActionPerformed ( evt ) ; } } ) ; editValueLabel . setText ( "Value:" ) ; editCancelButton . setText ( "Cancel" ) ; editCancelButton . addActionListener ( new java . awt . event . ActionListener ( ) { public void actionPerformed ( java . awt . event . ActionEvent evt ) { editCancelButtonActionPerformed ( evt ) ; } } ) ; editSaveButton . setText ( "Save" ) ; editSaveButton . addActionListener ( new java . awt . event . ActionListener ( ) { public void actionPerformed ( java . awt . event . ActionEvent evt ) { editSaveButtonActionPerformed ( evt ) ; } } ) ; editValueField . setText ( this . value != null ? this . value . toString ( ) : "" ) ; editValueField . setInputVerifier ( new EditValueFieldInputVerifier ( ) ) ; editValueField . addKeyListener ( new java . awt . event . KeyAdapter ( ) { public void keyTyped ( java . awt . event . KeyEvent evt ) { editValueFieldKeyTyped ( evt ) ; } } ) ; editValueValidationLabel . setIcon ( UIManager . getIcon ( "OptionPane.warningIcon" ) ) ; editValueValidationLabel . setText ( "jLabel1" ) ; editValueValidationLabel . setVisible ( false ) ; javax . swing . GroupLayout layout = new javax . swing . GroupLayout ( getContentPane ( ) ) ; getContentPane ( ) . setLayout ( layout ) ; layout . setHorizontalGroup ( layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( layout . createSequentialGroup ( ) . addContainerGap ( ) . addGroup ( layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addComponent ( editNameLabel , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , short . MAX_VALUE ) . addComponent ( editNameField ) . addComponent ( editTypeLabel , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , short . MAX_VALUE ) . addComponent ( editTypeDropdown , 0 , javax . swing . GroupLayout . DEFAULT_SIZE , short . MAX_VALUE ) . addComponent ( editValueLabel , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , short . MAX_VALUE ) . addGroup ( javax . swing . GroupLayout . Alignment . TRAILING , layout . createSequentialGroup ( ) . addGap ( 0 , 244 , short . MAX_VALUE ) . addComponent ( editSaveButton ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . UNRELATED ) . addComponent ( editCancelButton ) ) . addComponent ( editValueField ) . addComponent ( editValueValidationLabel , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , short . MAX_VALUE ) ) . addContainerGap ( ) ) ) ; layout . setVerticalGroup ( layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( layout . createSequentialGroup ( ) . addContainerGap ( ) . addComponent ( editNameLabel ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addComponent ( editNameField , javax . swing . GroupLayout . PREFERRED_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . PREFERRED_SIZE ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . UNRELATED ) . addComponent ( editTypeLabel ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addComponent ( editTypeDropdown , javax . swing . GroupLayout . PREFERRED_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . PREFERRED_SIZE ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . UNRELATED ) . addComponent ( editValueLabel ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addComponent ( editValueField , javax . swing . GroupLayout . PREFERRED_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . PREFERRED_SIZE ) . addGap ( 18 , 18 , 18 ) . addComponent ( editValueValidationLabel ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED , 79 , short . MAX_VALUE ) . addGroup ( layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . BASELINE ) . addComponent ( editCancelButton ) . addComponent ( editSaveButton ) ) . addContainerGap ( ) ) ) ; pack ( ) ; }
tr	4	public static StroopTest createRandomColourTest ( int wordSize , TestType type ) { List < Word > words = new ArrayList < Word > ( wordSize ) ; Random randomizer = new Random ( System . currentTimeMillis ( ) ) ; for ( int i = 0 ; i < wordSize ; i ++ ) { int next = randomizer . nextInt ( 2 ) ; switch ( next ) { case 0 : { words . add ( WordFactory . createRandomPlainColourWord ( ) ) ; break ; } case 1 : { words . add ( WordFactory . createRandomColourWord ( ) ) ; break ; } case 2 : { words . add ( WordFactory . createRandomMixedColourWord ( ) ) ; break ; } } } return new StroopTest ( words , type , "RANDOM" , "" ) ; }
tr	8	public static void main ( String [ ] args ) { IterableBlockWorld world = new BlockWorldImpl ( ) ; IsoBlockCanvas c = new IsoBlockCanvas ( world ) ; c . setScale ( 22 ) ; c . setZScale ( 1.0 ) ; int zz = 4 ; int w = 10 ; for ( int i = - w ; i <= w ; i ++ ) { if ( Math . abs ( i ) != w ) { for ( int z = 1 ; z < zz ; z ++ ) { world . add ( new IsoBlock ( i , - w , z ) ) ; world . add ( new IsoBlock ( i , w , z ) ) ; } } for ( int j = - w ; j <= w ; j ++ ) { if ( Math . abs ( i ) == w ) { for ( int z = 1 ; z < zz ; z ++ ) { world . add ( new IsoBlock ( i , j , z ) ) ; world . add ( new IsoBlock ( i , j , z ) ) ; } } world . add ( new IsoBlock ( i , j , 0 ) ) ; } } Ball b = new Ball ( 0 , 0 , 10 ) ; b . a = new Vector3d ( 0.12 , 0.45 , - 1 ) ; Dynamics d = new Dynamics ( world , b ) ; c . setBall ( b ) ; IsoBlockCanvas . makeFrame ( c ) ; try { while ( true ) { Thread . sleep ( 10 ) ; d . move ( ) ; c . repaint ( ) ; } } catch ( InterruptedException e ) { System . exit ( 1 ) ; } }
tr	1	private boolean isFullV ( int row , int col ) { return isOpenV ( row , col ) && ufFull . connected ( index ( row , col ) , theTOP ) ; }
tr	2	public boolean isLeap ( ) { return ( ( year % 4 == 0 ) && ( year % 100 != 0 ) || ( year % 400 == 0 ) ) ; }
tr	0	public java . lang . String getInstrument ( ) { return instrument ; }
tr	1	public static String createJquery ( Chart < ? > chart , String divId ) { return createJquery ( chart , divId , null ) ; }
tr	8	public boolean tileMatch ( int t1an , int t2an , int t1sp , int t2sp , String t1c , String t2c , int invoker ) { int tilePairs = jslideMatchPairs . getValue ( ) ; if ( t1c == null ) { if ( debug ) { jtMatchStatus . append ( "\n tileMatch: Tile 1 is null (not chosen yet)" ) ; } return false ; } if ( t2c == null ) { if ( debug ) { jtMatchStatus . append ( "\n tileMatch: Tile 2 is null (not chosen yet)" ) ; } return false ; } if ( t1c . equals ( t2c ) ) { if ( debug ) { jtMatchStatus . append ( "\n tileMatch: " + t1c + " matches " + t2c ) ; } if ( checkMatch2 ( t1c , t2c , invoker ) ) { jtMatchStatus . append ( "\n" + match ) ; txtMatch . setText ( match ) ; matchCount = matchCount + 1 ; txtMatches . setText ( matchCount + "" ) ; checkMatchCount ( tilePairs , matchCount ) ; return true ; } } else { if ( debug ) { jtMatchStatus . append ( "\n tileMatch: " + t1c + " does not match " + t2c ) ; } return false ; } return false ; }
tr	8	@ Override public Object cresciDinosauro ( String token , String idDinosauro ) { try { if ( myLogica . isMioTurno ( token ) ) { if ( myLogica . doCresciDinosauro ( token , idDinosauro ) ) { return "@ok" ; } return "@no @idNonValido" ; } else return "@no @nonIlTuoTurno" ; } catch ( InvalidTokenException e ) { return returnInvalidToken ( ) ; } catch ( NonInPartitaException e ) { return "@no @nonInPartita" ; } catch ( GenericDinosauroException e ) { if ( e . getMessage ( ) . equals ( "mortePerInedia" ) ) return "@no @mortePerInedia" ; if ( e . getMessage ( ) . equals ( "raggiuntaDimensioneMax" ) ) return "@no @raggiuntaDimensioneMax" ; if ( e . getMessage ( ) . equals ( "raggiuntoLimiteMosseDinosauro" ) ) return "@no @raggiuntoLimiteMosseDinosauro" ; } return "@no" ; }
tr	5	public Object read ( String entityClassFullName , Integer id ) throws EntityNotFoundException { Session session = null ; Transaction transaction = null ; try { session = this . sessionFactory . getCurrentSession ( ) ; transaction = session . beginTransaction ( ) ; Object instance = session . get ( entityClassFullName , id ) ; transaction . commit ( ) ; if ( instance == null ) { throw new EntityNotFoundException ( entityClassFullName + " not found for id = " + id ) ; } return instance ; } catch ( RuntimeException re ) { if ( transaction != null ) { transaction . rollback ( ) ; } throw re ; } finally { if ( session != null && session . isOpen ( ) ) { session . close ( ) ; } } }
tr	7	static int [ ] dijkstraSub ( MatrixGraph g , int s , int t , int [ ] prev ) { int [ ] dists = new int [ g . n ] ; Arrays . fill ( dists , INF ) ; dists [ s ] = 0 ; PriorityQueue < EdgeState > queue = new PriorityQueue < EdgeState > ( ) ; queue . add ( new EdgeState ( 0 , s ) ) ; while ( ! queue . isEmpty ( ) ) { EdgeState state = queue . poll ( ) ; if ( dists [ state . n ] < state . cost ) continue ; if ( state . n == t ) break ; for ( int v = 0 ; v < g . n ; v ++ ) { Edge e = g . edges [ state . n ] [ v ] ; if ( e != null && dists [ v ] > dists [ state . n ] + e . cost ) { dists [ v ] = dists [ state . n ] + e . cost ; if ( prev != null ) prev [ v ] = state . n ; queue . add ( new EdgeState ( dists [ v ] , v ) ) ; } } } return dists ; }
tr	0	@ Override public String getSchema ( ) throws SQLException { return null ; }
tr	7	public static int commonAuto ( TeamMatch match ) { int two , four , six ; two = four = six = 0 ; for ( Points p : match . getPoints ( ) ) { if ( p instanceof TwoPointAuto ) { two ++ ; } else if ( p instanceof FourPointAuto ) { four ++ ; } else if ( p instanceof SixPointAuto ) { six ++ ; } } int max = Math . max ( two , Math . max ( four , six ) ) ; return max == six ? 6 : ( max == four ? 4 : ( max == two ? 2 : 0 ) ) ; }
tr	4	@ Override public void read ( ReceiveBuffer rbuf , int timeout ) { try { long time = System . currentTimeMillis ( ) ; while ( ( System . currentTimeMillis ( ) - time ) < timeout && ! sio . state . reset ) { sio . state . readcalls ++ ; int len = inputStream . read ( mReadBuffer . array ( ) , 0 , READ_SIZE ) ; if ( len > 0 ) { mReadBuffer . position ( len ) ; rbuf . append ( mReadBuffer ) ; mReadBuffer . clear ( ) ; return ; } } } catch ( Exception e ) { sio . onRunError ( e , "OTG read" ) ; } }
tr	5	public BufferedImage alphaMultiply ( BufferedImage b , int a ) { BufferedImage bmp = deepCopy ( b ) ; for ( int x = 0 ; x < bmp . getWidth ( ) ; x ++ ) for ( int y = 0 ; y < bmp . getHeight ( ) ; y ++ ) { int rgb = bmp . getRGB ( x , y ) ; int red = ( int ) ( ( ( rgb >> 16 ) & ff ) * ( ( 100.0 + a ) / 100.0 ) ) ; if ( red > ff ) red = ff ; int green = ( int ) ( ( ( rgb >> 8 ) & ff ) * ( ( 100.0 + a ) / 100.0 ) ) ; if ( green > ff ) green = ff ; int blue = ( int ) ( ( ( rgb >> 0 ) & ff ) * ( ( 100.0 + a ) / 100.0 ) ) ; if ( blue > ff ) blue = ff ; int alpha = ( ( rgb >> 24 ) & ff ) ; rgb = ( alpha << 24 ) | ( red << 16 ) | ( green << 8 ) | blue ; bmp . setRGB ( x , y , rgb ) ; } return bmp ; }
tr	7	public void killHappenedAt ( PointI p , int mobSize , boolean wasSplashDamage ) { if ( ( p . x < 0 ) || ( p . y < 0 ) || ( p . x >= w ) || ( p . y >= h ) ) return ; double amount = 1f / mobSize / mobSize ; for ( int y = 0 ; y < mobSize ; y ++ ) { for ( int x = 0 ; x < mobSize ; x ++ ) { if ( wasSplashDamage ) { splashKillCounts [ p . y + y ] [ p . x + x ] += amount ; } else { normalKillCounts [ p . y + y ] [ p . x + x ] += amount ; } } } }
tr	8	public static void main ( String [ ] args ) { System . setOut ( new VOut ( System . out ) ) ; VEngineLogo vl = new VEngineLogo ( ) ; vl . setVisible ( true ) ; cfg = VFileReader . readCFG ( new File ( new File ( System . getProperty ( "user.home" ) + "/.vau/" ) . getAbsolutePath ( ) + "/configurations/game.cfg" ) ) ; cfg . s ( "home" , new File ( System . getProperty ( "user.home" ) + "/.vau/" ) . getAbsolutePath ( ) ) ; cfg . s ( "modhome" , new File ( System . getProperty ( "user.home" ) + "/.vau/mods/" + cfg . g ( "mod" ) + "/" ) . getAbsolutePath ( ) + "/" ) ; for ( String param : args ) { try { String [ ] pr = param . split ( "=" ) ; cfg . s ( pr [ 0 ] , pr [ 1 ] ) ; } catch ( Exception e ) { } } System . out . println ( cfg ) ; try { System . setProperty ( "java.library.path" , new File ( cfg . g ( "home" ) + "/native" ) . getAbsolutePath ( ) ) ; Field fieldSysPath = ClassLoader . class . getDeclaredField ( "sys_paths" ) ; fieldSysPath . setAccessible ( true ) ; try { fieldSysPath . set ( null , null ) ; } catch ( IllegalArgumentException ex ) { Logger . getLogger ( VEngine . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; JOptionPane . showMessageDialog ( null , "Error!\n" + ex . toString ( ) ) ; System . exit ( 1 ) ; } catch ( IllegalAccessException ex ) { JOptionPane . showMessageDialog ( null , "Error!\n" + ex . toString ( ) ) ; System . exit ( 1 ) ; } } catch ( NoSuchFieldException ex ) { JOptionPane . showMessageDialog ( null , "Error!\n" + ex . toString ( ) ) ; System . exit ( 1 ) ; } catch ( SecurityException ex ) { JOptionPane . showMessageDialog ( null , "Error!\n" + ex . toString ( ) ) ; System . exit ( 1 ) ; } Music openingMenuMusic ; try { openingMenuMusic = new Music ( new File ( System . getProperty ( "user.home" ) + "/.vau/music/watchword.ogg" ) . getAbsolutePath ( ) ) ; if ( cfg . g ( "music" ) . equals ( "enabled" ) ) { openingMenuMusic . loop ( ) ; } } catch ( SlickException ex ) { Logger . getLogger ( VEngine . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } VGraphics . start ( ) ; VProcessor . add ( new vexamples . units . VPlayer ( ) ) ; VProcessor . add ( new vexamples . units . VUnit ( ) ) ; VProcessor . add ( new vexamples . units . VBullet ( ) ) ; VMenu vm = new VMenu ( ) ; vl . setVisible ( false ) ; }
tr	0	public void setCount ( int count ) { this . count = count ; }
tr	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( Menu . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( Menu . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( Menu . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( Menu . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { new Menu ( ) . setVisible ( true ) ; } } ) ; }
tr	2	@ Test public void testGet ( ) { for ( int i = 0 ; i < A . length ; ++ i ) { for ( int j = 0 ; j < A [ 0 ] . length ; ++ j ) { assertTrue ( matrixA . get ( i , j ) . equals ( A [ i ] [ j ] ) ) ; } } }
tr	0	public static Length getLength ( Element e ) { return e . getLength ( ) ; }
tr	0	public String get_stop_code ( ) { return _stop_code ; }
tr	2	static void goToAccountSync ( int tabId , String url ) { if ( WebContent . isInPearltrees ( url ) ) { navigateTo ( tabId , WebContent . getUnanchoredUrl ( url ) + "#/DP-n=socialSync" ) ; return ; } BrowserTab t = BrowserTab . getPearltreesTab ( ) ; if ( t == null ) { createTab ( WebContent . getPearltreesUrl ( ) + "#/DP-n=socialSync" ) ; return ; } navigateTo ( t . getId ( ) , WebContent . getUnanchoredUrl ( t . getUrl ( ) ) + "#/DP-n=socialSync" ) ; }
tr	1	@ Test public void testByZero ( ) { try { DivisionResult dr = Util . divideByApproximatelyEqualParts ( 2 , 0 ) ; fail ( "ae expected  but obtained " + dr ) ; } catch ( ArithmeticException ae ) { } }
tr	3	@ Override public void process ( ) { String [ ] s = curDir . list ( stringS . getStringFilter ( ) . getFilenameFilter ( ) ) ; int cs = 0 , cf = 0 ; for ( int i = 0 ; i < s . length ; i ++ ) { String x = stringS . substitute ( s [ i ] ) ; String t = s [ i ] + " => " + x ; if ( ! isPreview ) t += new File ( curDir , s [ i ] ) . renameTo ( new File ( curDir , x ) ) ? " ok " + ++ cs : " fail " + ++ cf ; Print . ln ( t ) ; } Print . ln ( "Total " + s . length + " files  " + cs + " success  " + cf + " fail" ) ; }
tr	6	public boolean applyTechniqueRulesetConstriction ( ) { boolean appliedTechnique = false ; Iterator < Integer > emptyElementIterator = emptyElements . iterator ( ) ; while ( emptyElementIterator . hasNext ( ) && ! appliedTechnique ) { int nextEmptyElement = emptyElementIterator . next ( ) ; Set < Integer > recalculatedValidElements = getValidValuesForElementWithNumber ( nextEmptyElement ) ; for ( int relatedElement : getRelatedElementNumbersForElementWithNumber ( nextEmptyElement ) ) { if ( elementWithNumberIsEmpty ( relatedElement ) ) { recalculatedValidElements . removeAll ( getValidValuesForElementWithNumber ( relatedElement ) ) ; } else { recalculatedValidElements . remove ( getElementWithNumber ( nextEmptyElement ) ) ; } } if ( recalculatedValidElements . size ( ) != 0 ) { Set < Integer > elementsToRemove = getValidValuesForElementWithNumber ( nextEmptyElement ) ; elementsToRemove . removeAll ( recalculatedValidElements ) ; for ( int elementToRemove : elementsToRemove ) { this . removeValueForElementWithNumber ( nextEmptyElement , elementToRemove ) ; } appliedTechnique = true ; } } return appliedTechnique ; }
tr	8	public void start ( ) { if ( applet != null ) { applet . start ( ) ; return ; } if ( gameUpdaterStarted ) return ; Thread t = new Thread ( ) { public void run ( ) { gameUpdater . run ( ) ; try { if ( ! gameUpdater . fatalError ) replace ( gameUpdater . createApplet ( ) ) ; } catch ( ClassNotFoundException e ) { e . printStackTrace ( ) ; } catch ( InstantiationException e ) { e . printStackTrace ( ) ; } catch ( IllegalAccessException e ) { e . printStackTrace ( ) ; } } } ; t . setDaemon ( true ) ; t . start ( ) ; t = new Thread ( ) { public void run ( ) { while ( applet == null ) { repaint ( ) ; try { Thread . sleep ( 10 ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } } } ; t . setDaemon ( true ) ; t . start ( ) ; gameUpdaterStarted = true ; }
tr	4	@ Override public boolean equals ( Object that ) { if ( that == this ) return true ; if ( that == null || ! getClass ( ) . equals ( that . getClass ( ) ) ) return false ; Row other = ( Row ) that ; return option . equals ( other . option ) && description . equals ( other . description ) ; }
tr	9	private void populateMap ( Object bean ) { class klass = bean . getClass ( ) ; boolean includeSuperClass = klass . getClassLoader ( ) != null ; Method [ ] methods = includeSuperClass ? klass . getMethods ( ) : klass . getDeclaredMethods ( ) ; for ( int i = 0 ; i < methods . length ; i += 1 ) { try { Method method = methods [ i ] ; if ( Modifier . isPublic ( method . getModifiers ( ) ) ) { String name = method . getName ( ) ; String key = "" ; if ( name . startsWith ( "get" ) ) { if ( "getClass" . equals ( name ) || "getDeclaringClass" . equals ( name ) ) { key = "" ; } else { key = name . substring ( 3 ) ; } } else if ( name . startsWith ( "is" ) ) { key = name . substring ( 2 ) ; } if ( key . length ( ) > 0 && Character . isUpperCase ( key . charAt ( 0 ) ) && method . getParameterTypes ( ) . length == 0 ) { if ( key . length ( ) == 1 ) { key = key . toLowerCase ( ) ; } else if ( ! Character . isUpperCase ( key . charAt ( 1 ) ) ) { key = key . substring ( 0 , 1 ) . toLowerCase ( ) + key . substring ( 1 ) ; } Object result = method . invoke ( bean , ( Object [ ] ) null ) ; if ( result != null ) { this . map . put ( key , wrap ( result ) ) ; } } } } catch ( Exception ignore ) { } } }
tr	6	private void stopPosition ( ) { StreamsterApiInterfaceProxy proxy = new StreamsterApiInterfaceProxy ( ) ; Position [ ] positions = new Position [ 0 ] ; try { positions = proxy . getPositions ( ) ; } catch ( RemoteException ex ) { Logger . getLogger ( JobTradeUp . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } for ( Position position : positions ) { if ( position . getStatus ( ) . equalsIgnoreCase ( "OPEN" ) ) { if ( position . getPoints ( ) . compareTo ( new BigDecimal ( 3 ) ) == 0 || position . getPoints ( ) . compareTo ( new BigDecimal ( 3 ) ) == 1 ) { try { proxy . closePosition ( position . getPositionID ( ) ) ; } catch ( RemoteException ex ) { Logger . getLogger ( JobTradeUp . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } } } } }
tr	2	public void add ( E e ) { Node u = new Node ( e ) ; if ( tail != null ) tail . setNext ( u ) ; tail = u ; if ( isEmpty ( ) ) { head = tail ; current = head ; } size ++ ; }
tr	5	@ Override public void update ( ) { for ( Modifier mod : mods ) { if ( mod . getDuration ( ) > 0 ) { mod . setDuration ( mod . getDuration ( ) - 1 ) ; if ( mod . isAdditive ( ) ) { mod . setTotal ( mod . getTotal ( ) + mod . getAmount ( ) ) ; curValue += mod . getAmount ( ) ; } } else if ( mod . getDuration ( ) <= 0 ) { if ( mod . isTemporary ( ) ) { curValue -= mod . getTotal ( ) ; } mods . remove ( mod ) ; } } }
tr	5	public double addPoint ( Point p , double angle , double THRESHOLD2 ) { if ( angle != ConnectedComponent . ANGLE_UNDEFINED ) { double diff = angleDiff ( angle , prevAngle ) ; if ( sign ( diff ) != dirChange ) { if ( accumChange >= THRESHOLD1 ) { return angleDiff ( angle , approximateAngle ( ) ) ; } if ( diff != 0 ) { accumChange = Math . abs ( diff ) ; dirChange = sign ( diff ) ; } } else { accumChange += Math . abs ( diff ) ; if ( accumChange >= THRESHOLD2 ) return angleDiff ( angle , approximateAngle ( ) ) ; } prevAngle = angle ; } _prevEnd = _end ; _end = p ; return 0 ; }
tr	1	private void waitABit ( String message ) { try { Thread . sleep ( 10000 ) ; System . out . println ( message ) ; } catch ( InterruptedException e ) { } }
tr	1	public static void main ( String [ ] args ) { final int [ ] coins = new int [ ] { 1 , 2 , 5 , 10 , 20 , 50 , 100 , 200 } ; final int [ ] limits = new int [ coins . length ] ; for ( int i = 0 ; i < limits . length ; i ++ ) { limits [ i ] = target / coins [ i ] ; } final int [ ] counts = new int [ coins . length ] ; loop ( coins , limits , counts , 0 ) ; System . out . println ( "# count = " + count ) ; }
tr	8	public void incCount ( E data ) { if ( overallRoot == null ) { overallRoot = new AVLNode ( data ) ; return ; } AVLNode currentNode = ( AVLNode ) overallRoot ; while ( true ) { int cmp = comparator . compare ( data , currentNode . data ) ; if ( cmp == 0 ) { currentNode . count ++ ; return ; } else if ( cmp < 0 ) { if ( currentNode . left == null ) { currentNode . left = new AVLNode ( data , currentNode ) ; break ; } currentNode = ( AVLNode ) currentNode . left ; } else { if ( currentNode . right == null ) { currentNode . right = new AVLNode ( data , currentNode ) ; break ; } currentNode = ( AVLNode ) currentNode . right ; } } percHeightUp ( currentNode ) ; while ( currentNode != null ) { Side isImbalanced = checkImbalance ( currentNode ) ; if ( isImbalanced != Side . BALANCED ) { percHeightDown ( rotate ( currentNode , isImbalanced ) ) ; break ; } currentNode = currentNode . parent ; } }
tr	5	ListNode parseList ( SeekableStringReader sr ) { sr . read ( ) ; sr . skipWhitespace ( ) ; ListNode list = new ListNode ( ) ; if ( sr . peek ( ) == ] ) { sr . read ( ) ; return list ; } list . elements = parseExprList ( sr ) ; sr . skipWhitespace ( ) ; if ( ! sr . hasMore ( ) ) throw new ParseException ( "missing ']'" ) ; if ( sr . peek ( ) ==   ) sr . read ( ) ; if ( ! sr . hasMore ( ) ) throw new ParseException ( "missing ']'" ) ; char closechar = sr . read ( ) ; if ( closechar != ] ) throw new ParseException ( "expected ']'" ) ; return list ; }
tr	8	public void run ( ) { ParallelWarteClass paraWait = new ParallelWarteClass ( 10000 ) ; paraWait . start ( ) ; while ( ! ( HWaccess . readInt ( Adressen . LaufbandDrehen . ordinal ( ) ) == - 1 ) && paraWait . isAlive ( ) ) { try { Thread . sleep ( 150 ) ; } catch ( InterruptedException e ) { interrupt ( ) ; } } if ( ! paraWait . isAlive ( ) ) { interrupt ( ) ; return ; } else { } paraWait = new ParallelWarteClass ( 10000 ) ; paraWait . start ( ) ; while ( ! ( HWaccess . readInt ( Adressen . LaufbandDrehen . ordinal ( ) ) == 0 ) && paraWait . isAlive ( ) ) { try { Thread . sleep ( 150 ) ; } catch ( InterruptedException e ) { this . interrupt ( ) ; } } if ( ! paraWait . isAlive ( ) ) { interrupt ( ) ; } else { paraWait . interrupt ( ) ; } result = true ; }
tr	0	public void setLoggingIn ( ) { removeAll ( ) ; JPanel panel = new JPanel ( new BorderLayout ( ) ) ; panel . add ( getUpdateNews ( ) , "Center" ) ; JPanel southPanel = new TexturedPanel ( ) ; southPanel . setLayout ( new BorderLayout ( ) ) ; southPanel . add ( new LogoPanel ( ) , "West" ) ; southPanel . add ( new TransparentPanel ( ) , "Center" ) ; JLabel label = new TransparentLabel ( "Logging in...                      " , 0 ) ; label . setFont ( new Font ( null , 1 , 16 ) ) ; southPanel . add ( center ( label ) , "East" ) ; southPanel . setPreferredSize ( new Dimension ( 100 , 100 ) ) ; panel . add ( southPanel , "South" ) ; add ( panel , "Center" ) ; validate ( ) ; }
tr	8	@ Override public Component getTableCellRendererComponent ( JTable table , Object value , boolean isSelected , boolean hasFocus , int row , int column ) { if ( value instanceof ScheduleElementViewWrapper ) { ScheduleElementViewWrapper scheduleElement = ( ScheduleElementViewWrapper ) value ; StudyProgram studyProgram = null ; if ( scheduleElement . getScheduleView ( ) instanceof ScheduleViewStudyProgram ) { studyProgram = ( ( ScheduleViewStudyProgram ) scheduleElement . getScheduleView ( ) ) . getStudyProgramm ( ) ; } if ( scheduleElement . isEmpty ( ) ) { setText ( "" ) ; setToolTipText ( "Nicht belegt." ) ; setBackground ( colorFree ) ; } else { setVerticalAlignment ( SwingConstants . TOP ) ; setBackground ( colorFree ) ; StringBuilder sb = new StringBuilder ( ) ; sb . append ( "<html>" ) ; for ( ScheduleAppointment appointment : scheduleElement . getAppointments ( ) ) { sb . append ( "<div style=\" margin: 3px; padding: 3px; word-wrap: break-word; overflow-x: auto; vertical-align: top;" ) ; sb . append ( "border: 2px solid #cccccc; " ) ; if ( appointment . getCourse ( ) . getType ( ) . getName ( ) . equals ( "Uebung" ) ) { sb . append ( "background-color: #99eeaa; " ) ; } else { sb . append ( "background-color: #99ddff; " ) ; } sb . append ( "\">" ) ; sb . append ( "Kurs " ) ; sb . append ( appointment . getCourse ( ) . getNumber ( ) ) . append ( " (" ) . append ( appointment . getCourse ( ) . getType ( ) . getName ( ) . equals ( "Uebung" ) ? "\u00DCbung" : "Vorlesung" ) . append ( "):<br/>" ) ; sb . append ( "<b>" ) . append ( appointment . getCourse ( ) . getName ( ) ) . append ( "</b><br/>" ) ; sb . append ( "Raum: " ) . append ( appointment . getRoom ( ) . getName ( ) ) . append ( "<br/>" ) ; sb . append ( "Dozent: " ) . append ( appointment . getCourse ( ) . getAcademic ( ) . getName ( ) ) . append ( "<br/>" ) ; sb . append ( "Teilnehmer: " ) . append ( appointment . getCourse ( ) . getStudents ( ) ) ; if ( studyProgram != null ) { sb . append ( "<br/>" ) . append ( studyProgram . getSemesterByCourse ( appointment . getCourse ( ) ) ) ; } sb . append ( "</div>" ) ; } sb . append ( "</html>" ) ; setText ( sb . toString ( ) ) ; } } else if ( value instanceof TimeSlot ) { setVerticalAlignment ( SwingConstants . CENTER ) ; setText ( value . toString ( ) ) ; setToolTipText ( "" ) ; setBackground ( colorTimeSlot ) ; } else { setToolTipText ( "Nicht belegt." ) ; setText ( "" ) ; setBackground ( colorFree ) ; } return this ; }
tr	5	private static void flatten ( Node < ? > node , LinkedList < Node < ? >> result ) { if ( node == null ) return ; result . add ( node ) ; if ( node instanceof UnaryNode ) { flatten ( ( ( UnaryNode ) node ) . getSibling ( ) , result ) ; } else if ( node instanceof BinaryNode ) { BinaryNode binaryNode = ( BinaryNode ) node ; flatten ( binaryNode . getFirstSibling ( ) , result ) ; flatten ( binaryNode . getSecondSibling ( ) , result ) ; } }
tr	7	public static void main ( String [ ] args ) throws NumberAlreadyEnteredException , FileNotFoundException { Network aNetwork = new Network ( ) ; PhoneNumber aPhone = new PhoneNumber ( LineType . MOBILE1 , "3016513831" ) ; PhoneNumber anotherPhone = new PhoneNumber ( LineType . MOBILE1 , "9176823411" ) ; Contact rena = new PhoneOwner ( "Rena Friedman" , aPhone ) ; Contact Professor = new PhoneOwner ( "Professor Plonczack" , anotherPhone ) ; RunCellPhone a = null , b = null ; try { a = new RunCellPhone ( rena . getName ( ) , "./renaCellPhone.ser" , aNetwork , rena . getPhoneNumber ( ) ) ; } catch ( IOException io ) { JOptionPane . showMessageDialog ( null , "file not found - call IT" ) ; System . exit ( 0 ) ; } catch ( ClassNotFoundException cnf ) { JOptionPane . showMessageDialog ( null , "class discrepancy" ) ; System . exit ( 0 ) ; } catch ( Exception e ) { JOptionPane . showMessageDialog ( null , "incorrect file names couldnt set up phone" ) ; e . printStackTrace ( ) ; System . exit ( 0 ) ; } try { b = new RunCellPhone ( Professor . getName ( ) , "./professorCellPhone.ser" , aNetwork , Professor . getPhoneNumber ( ) ) ; } catch ( IOException io ) { JOptionPane . showMessageDialog ( null , "file not found - call IT" ) ; System . exit ( 0 ) ; } catch ( ClassNotFoundException cnf ) { JOptionPane . showMessageDialog ( null , "class discrepancy" ) ; System . exit ( 0 ) ; } catch ( Exception e ) { JOptionPane . showMessageDialog ( null , "incorrect file names couldnt set up bank" ) ; System . exit ( 0 ) ; } try { System . out . println ( "Adding Contacts..." ) ; a . aCell . addContact ( Professor . getName ( ) , Professor . getPhoneNumber ( ) ) ; a . aFrame . refresh ( ) ; b . aCell . addContact ( rena . getName ( ) , rena . getPhoneNumber ( ) ) ; b . aFrame . refresh ( ) ; System . out . println ( "Added" ) ; } catch ( NumberAlreadyEnteredException e ) { System . out . println ( "Numbers already added" ) ; } }
tr	9	public static Object getDummyObject ( class cls ) { Object obj = null ; try { Constructor < ? > ctor = cls . getDeclaredConstructor ( ) ; Reflector . ensureIsAccessible ( ctor ) ; obj = ctor . newInstance ( ) ; } catch ( NoSuchMethodException e1 ) { final Constructor < ? > ctor = cls . getConstructors ( ) [ 0 ] ; class [ ] paramTypes = ctor . getParameterTypes ( ) ; List < Object > params = new ArrayList < Object > ( ) ; for ( class paramType : paramTypes ) params . add ( paramType . isPrimitive ( ) ? getTypeDefaultValue ( paramType . getName ( ) ) : null ) ; try { obj = ctor . newInstance ( params . toArray ( ) ) ; } catch ( InstantiationException e ) { e . printStackTrace ( ) ; } catch ( IllegalAccessException e ) { e . printStackTrace ( ) ; } catch ( IllegalArgumentException e ) { e . printStackTrace ( ) ; } catch ( InvocationTargetException e ) { e . printStackTrace ( ) ; } } catch ( SecurityException e1 ) { e1 . printStackTrace ( ) ; } catch ( InstantiationException e ) { e . printStackTrace ( ) ; } catch ( IllegalAccessException e ) { e . printStackTrace ( ) ; } catch ( IllegalArgumentException e ) { e . printStackTrace ( ) ; } catch ( InvocationTargetException e ) { e . printStackTrace ( ) ; } finally { return obj ; } }
tr	9	private void postPlugin ( final boolean isPing ) throws IOException { PluginDescriptionFile description = plugin . getDescription ( ) ; String pluginName = description . getName ( ) ; boolean onlineMode = Bukkit . getServer ( ) . getOnlineMode ( ) ; String pluginVersion = description . getVersion ( ) ; String serverVersion = Bukkit . getVersion ( ) ; int playersOnline = Bukkit . getServer ( ) . getOnlinePlayers ( ) . length ; final StringBuilder data = new StringBuilder ( ) ; data . append ( encode ( "guid" ) ) . append ( = ) . append ( encode ( guid ) ) ; encodeDataPair ( data , "version" , pluginVersion ) ; encodeDataPair ( data , "server" , serverVersion ) ; encodeDataPair ( data , "players" , Integer . toString ( playersOnline ) ) ; encodeDataPair ( data , "revision" , String . valueOf ( REVISION ) ) ; String osname = System . getProperty ( "os.name" ) ; String osarch = System . getProperty ( "os.arch" ) ; String osversion = System . getProperty ( "os.version" ) ; String java_version = System . getProperty ( "java.version" ) ; int coreCount = Runtime . getRuntime ( ) . availableProcessors ( ) ; if ( osarch . equals ( "amd64" ) ) { osarch = "x86_64" ; } encodeDataPair ( data , "osname" , osname ) ; encodeDataPair ( data , "osarch" , osarch ) ; encodeDataPair ( data , "osversion" , osversion ) ; encodeDataPair ( data , "cores" , Integer . toString ( coreCount ) ) ; encodeDataPair ( data , "online-mode" , boolean . toString ( onlineMode ) ) ; encodeDataPair ( data , "java_version" , java_version ) ; if ( isPing ) { encodeDataPair ( data , "ping" , "true" ) ; } synchronized ( graphs ) { final Iterator < Graph > iter = graphs . iterator ( ) ; while ( iter . hasNext ( ) ) { final Graph graph = iter . next ( ) ; for ( Plotter plotter : graph . getPlotters ( ) ) { final String key = String . format ( "C%s%s%s%s" , CUSTOM_DATA_SEPARATOR , graph . getName ( ) , CUSTOM_DATA_SEPARATOR , plotter . getColumnName ( ) ) ; final String value = Integer . toString ( plotter . getValue ( ) ) ; encodeDataPair ( data , key , value ) ; } } } URL url = new URL ( BASE_URL + String . format ( REPORT_URL , encode ( pluginName ) ) ) ; URLConnection connection ; if ( isMineshafterPresent ( ) ) { connection = url . openConnection ( Proxy . NO_PROXY ) ; } else { connection = url . openConnection ( ) ; } connection . setDoOutput ( true ) ; final OutputStreamWriter writer = new OutputStreamWriter ( connection . getOutputStream ( ) ) ; writer . write ( data . toString ( ) ) ; writer . flush ( ) ; final BufferedReader reader = new BufferedReader ( new InputStreamReader ( connection . getInputStream ( ) ) ) ; final String response = reader . readLine ( ) ; writer . close ( ) ; reader . close ( ) ; if ( response == null || response . startsWith ( "ERR" ) ) { throw new IOException ( response ) ; } else { if ( response . contains ( "OK This is your first update this hour" ) ) { synchronized ( graphs ) { final Iterator < Graph > iter = graphs . iterator ( ) ; while ( iter . hasNext ( ) ) { final Graph graph = iter . next ( ) ; for ( Plotter plotter : graph . getPlotters ( ) ) { plotter . reset ( ) ; } } } } } }
tr	2	private void ExeChooserButtonActionPerformed ( java . awt . event . ActionEvent evt ) { JFileChooser chooser = new JFileChooser ( "D:\\" ) ; chooser . showOpenDialog ( this ) ; chooser . setFileSelectionMode ( JFileChooser . FILES_ONLY ) ; FileFilter filter1 = new FileNameExtensionFilter ( "EXE" , new String ( "EXE" ) ) ; chooser . addChoosableFileFilter ( filter1 ) ; file = chooser . getSelectedFile ( ) ; if ( file != null && file . exists ( ) ) { String filePath = file . getAbsolutePath ( ) ; ExeTextField . setText ( file . getAbsolutePath ( ) ) ; AppVariables . Code_Generator_Exe = filePath ; this . dispose ( ) ; } }
tr	0	public void setAddress ( Address address ) { this . address = address ; }
tr	1	public void setPopulation ( Population p ) { for ( int i = 0 ; i < operators . size ( ) ; ++ i ) { operators . get ( i ) . setPopulation ( p ) ; } }
tr	4	public LetterElement getElementAt ( final int x , final int y ) { final int col = ( x - XFUDGE ) >= 0 ? ( ( x - XFUDGE ) / CELL_WIDTH ) : 0 ; final int row = ( y - YFUDGE ) >= 0 ? ( ( y - YFUDGE ) / CELL_HEIGHT ) : 0 ; if ( ( col < COLS ) && ( row < ROWS ) ) { return matrix [ col ] [ row ] ; } else { return null ; } }
tr	4	public static List < StringChange > replaceAll ( F1 < Matcher , String > f1 , Pattern ptn , String text , int from , int to ) { Matcher matcher = ptn . matcher ( text ) ; ArrayList < StringChange > changes = new ArrayList < > ( ) ; if ( matcher . find ( from ) ) { do { changes . add ( StringChange . replace ( matcher . start ( ) , matcher . end ( ) , f1 . e ( matcher ) ) ) ; } while ( matcher . find ( ) && ( to == - 1 || matcher . start ( ) < to ) ) ; } return changes ; }
tr	5	public Instruction [ ] getMnemonics ( String mnemonic ) { Instruction [ ] temp = new Instruction [ binCode . size ( ) ] ; int c = 0 ; for ( int j = 0 ; j < binCode . size ( ) ; j ++ ) { if ( binCode . get ( j ) . getMnemonic ( ) . equalsIgnoreCase ( mnemonic ) ) temp [ c ++ ] = binCode . get ( j ) ; } int s = 0 ; for ( int j = 0 ; j < temp . length ; j ++ ) { if ( temp [ j ] != null ) s ++ ; } Instruction [ ] i = new Instruction [ s ] ; for ( int j = 0 ; j < i . length ; j ++ ) { i [ j ] = temp [ j ] ; } return i ; }
tr	8	protected boolean getPolyOrientation ( ) { if ( vertices . size ( ) < 3 ) return true ; int index = 0 ; IColumnVector < float > currentPoint = vertices . get ( 0 ) ; for ( int i = 1 ; i < vertices . size ( ) ; i ++ ) { if ( vertices . get ( i ) . get ( 0 , 0 ) < currentPoint . get ( 0 , 0 ) ) { currentPoint = vertices . get ( i ) ; index = i ; } else if ( vertices . get ( i ) . get ( 0 , 0 ) == currentPoint . get ( 0 , 0 ) && vertices . get ( i ) . get ( 1 , 0 ) > currentPoint . get ( 1 , 0 ) ) { currentPoint = vertices . get ( i ) ; index = i ; } } final IColumnVector < float > previousPoint = ( index == 0 ) ? vertices . get ( vertices . size ( ) - 1 ) : vertices . get ( index - 1 ) ; final IColumnVector < float > v1 = new ColumnVector ( currentPoint . get ( 0 , 0 ) - previousPoint . get ( 0 , 0 ) , currentPoint . get ( 1 , 0 ) - previousPoint . get ( 1 , 0 ) ) ; final IColumnVector < float > nextPoint = ( index == vertices . size ( ) - 1 ) ? vertices . get ( 0 ) : vertices . get ( index + 1 ) ; final float result = nextPoint . get ( 0 , 0 ) * v1 . get ( 1 , 0 ) - nextPoint . get ( 1 , 0 ) * v1 . get ( 0 , 0 ) + v1 . get ( 0 , 0 ) * previousPoint . get ( 1 , 0 ) - v1 . get ( 1 , 0 ) * previousPoint . get ( 0 , 0 ) ; return ( result <= 0 ? true : false ) ; }
tr	5	public char getListVersion ( ) { char fileVersion = Character . MIN_VALUE ; Field versionField = null ; try { versionField = allowedClass . getField ( "implementsFileVersion" ) ; } catch ( SecurityException e ) { } catch ( NoSuchFieldException e ) { } if ( versionField != null ) { try { fileVersion = versionField . getChar ( versionField ) ; } catch ( IllegalArgumentException e ) { } catch ( IllegalAccessException e ) { } } return fileVersion ; }
tr	9	@ SuppressWarnings ( "null" ) popupMenu ( final SimpleFrame text , MouseEvent event ) { popupMenu = new JPopupMenu ( ) ; undo = new JMenuItem ( "Undo" ) ; redo = new JMenuItem ( "Redo" ) ; copy = new JMenuItem ( "Copy" ) ; cut = new JMenuItem ( "Cut" ) ; paste = new JMenuItem ( "Paste" ) ; selectAll = new JMenuItem ( "Select All" ) ; undo . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { new keyActions ( ) . undo ( text ) ; } } ) ; redo . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { new keyActions ( ) . redo ( text ) ; } } ) ; copy . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { new keyActions ( ) . copy ( text ) ; } } ) ; cut . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { new keyActions ( ) . cut ( text ) ; } } ) ; paste . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { new keyActions ( ) . paste ( text ) ; } } ) ; selectAll . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { text . getText ( ) . setSelectionStart ( 0 ) ; text . getText ( ) . setSelectionEnd ( text . getText ( ) . getText ( ) . length ( ) ) ; } } ) ; popupMenu . add ( undo ) ; popupMenu . add ( redo ) ; popupMenu . add ( copy ) ; popupMenu . add ( cut ) ; popupMenu . add ( paste ) ; popupMenu . add ( selectAll ) ; if ( SwingUtilities . isRightMouseButton ( event ) ) { Transferable trans = Toolkit . getDefaultToolkit ( ) . getSystemClipboard ( ) . getContents ( null ) ; if ( trans == null && ! trans . isDataFlavorSupported ( DataFlavor . stringFlavor ) ) { paste . setEnabled ( false ) ; } else { paste . setEnabled ( true ) ; } try { if ( text . getList ( ) . isEmpty ( ) ) { undo . setEnabled ( false ) ; } else { undo . setEnabled ( true ) ; } } catch ( RemoteException e1 ) { e1 . printStackTrace ( ) ; } try { if ( text . getList ( ) . isEmpty ( ) || ( ! text . getList ( ) . isEmpty ( ) && text . getList ( ) . getIndexAction ( ) == text . getList ( ) . getSize ( ) - 1 ) ) { redo . setEnabled ( false ) ; } else { redo . setEnabled ( true ) ; } } catch ( RemoteException e1 ) { e1 . printStackTrace ( ) ; } if ( text . getText ( ) . getSelectedText ( ) == null ) { copy . setEnabled ( false ) ; cut . setEnabled ( false ) ; } else { copy . setEnabled ( true ) ; cut . setEnabled ( true ) ; } popupMenu . show ( text . getText ( ) , event . getX ( ) , event . getY ( ) ) ; } }
tr	2	@ Override public ArrayList < ProduktBatchKompDTO > getProduktBatchKompList ( int pbId ) throws DALException { ArrayList < ProduktBatchKompDTO > list = new ArrayList < ProduktBatchKompDTO > ( ) ; ResultSet rs = Connector . doQuery ( "SELECT pbk.*  rb.*  r.* FROM produktbatchkomponent pbk  raavarebatch rb  raavare r WHERE pbk.rb_id = rb.rb_id AND rb.raavare_id = r.raavare_id AND pbk.pb_id =  " + pbId ) ; try { while ( rs . next ( ) ) { RaavareDTO raavare = new RaavareDTO ( rs . getInt ( 10 ) , rs . getString ( 11 ) ) ; RaavareBatchDTO raavareBatch = new RaavareBatchDTO ( rs . getInt ( 5 ) , raavare , rs . getDouble ( 7 ) , rs . getTimestamp ( 8 ) , rs . getString ( 9 ) ) ; list . add ( new ProduktBatchKompDTO ( rs . getInt ( 1 ) , raavareBatch , rs . getDouble ( 3 ) , rs . getDouble ( 4 ) ) ) ; } } catch ( SQLException e ) { throw new DALException ( e ) ; } return list ; }
tr	3	public void recordProperNouns ( String sentence ) { if ( sentence == null ) { return ; } sentence = sentence . replaceAll ( "[(\\[{]\\s*[A-Z]" , " " ) ; Pattern p = Pattern . compile ( "(.+)\\b([A-Z][a-z]*)\\b" ) ; Matcher m = p . matcher ( sentence ) ; while ( m . find ( ) ) { String pattern = m . group ( 2 ) ; pattern = pattern . toLowerCase ( ) ; sentence = m . group ( 1 ) ; if ( pattern . length ( ) > 1 ) { this . myLearnerUtility . getConstant ( ) . pronounWords . add ( pattern ) ; this . myLearnerUtility . getConstant ( ) . updatePronoun ( ) ; } m = p . matcher ( sentence ) ; } }
tr	4	public boolean contain ( Ticket ticket ) { if ( ! parkIsNull ( ) && park . contain ( ticket ) ) { return true ; } for ( ParkBoy boy : this . parkBoyList ) { if ( boy . contain ( ticket ) ) { return true ; } } return false ; }
tr	4	private void init ( boolean allowDataSizeMutation , double mutationProbabilityPerGeneration , boolean allowMutationProbabilityDrift , IMyFitnessTestFunction < U > fitnessTest , IMyRandomDataFunction < U > rFunc ) throws Exception { if ( mutationProbabilityPerGeneration >= 0 && mutationProbabilityPerGeneration <= 1.0 ) { this . allowDataSizeMutation = allowDataSizeMutation ; this . allowMutationProbabilityDrift = allowMutationProbabilityDrift ; this . mutationProbability = mutationProbabilityPerGeneration ; if ( fitnessTest != null && rFunc != null ) { this . fitnessTest = fitnessTest ; this . rFunc = rFunc ; } else { throw new Exception ( "fitnesTestFunction or rFunc cannot be null" ) ; } } else { throw new Exception ( "invalid mutationProbability paramiter. Must be between 0 and 1" ) ; } }
tr	3	public void setEqualizer ( Equalizer = ) { if ( = == null ) = = Equalizer . PASS_THRU_EQ ; equalizer . setFrom ( = ) ; float [ ] factors = equalizer . getBandFactors ( ) ; if ( filter1 != null ) filter1 . setEQ ( factors ) ; if ( filter2 != null ) filter2 . setEQ ( factors ) ; }
tr	8	@ Override public boolean equals ( Object obj ) { if ( obj == null ) { return false ; } if ( getClass ( ) != obj . getClass ( ) ) { return false ; } final DefaultSchema other = ( DefaultSchema ) obj ; if ( this . mappingType != other . mappingType && ( this . mappingType == null || ! this . mappingType . equals ( other . mappingType ) ) ) { return false ; } if ( this . fields != other . fields && ( this . fields == null || ! this . fields . equals ( other . fields ) ) ) { return false ; } return true ; }
tr	8	public Sexp exec ( IPair pair , Map < AtomSymbol , Sexp > env ) throws FunctionException { if ( pair instanceof Lambda ) { Lambda ll = new Lambda ( pair . getCar ( ) , pair . getCdr ( ) ) ; ll . lambdaApply ( env ) ; return ll ; } Sexp car = MyLisp . apply ( pair . getCar ( ) , env ) ; if ( car == null || car == Atom . NIL ) { return Atom . NIL ; } else if ( car instanceof Lambda ) { return ( ( Lambda ) car ) . lambdaEvals ( env , pair . getCdr ( ) . getList ( ) ) ; } else if ( car instanceof IPair && funcMap . containsKey ( ( ( IPair ) car ) . getCar ( ) . toString ( ) ) ) { return exec ( ( IPair ) car , env ) ; } else if ( funcMap . containsKey ( car . toString ( ) ) ) { Operator op = funcMap . get ( car . toString ( ) ) ; return op . eval ( ( ConsCell ) pair , env ) ; } else if ( car instanceof Atom ) { return car ; } else { throw new FunctionException ( "reference to undefined identifier:" + pair . toString ( ) ) ; } }
tr	4	public static ChineseCharacter searchCharacter ( Integer [ ] intersection , int floatingPart , int straightStroke , int complexStroke ) { intersections = intersection ; floatingParts = floatingPart ; straightStrokes = straightStroke ; complexStrokes = complexStroke ; EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { PossibleChineseCharactersPanel . clearList ( ) ; Arrays . sort ( intersections ) ; for ( ChineseCharacter c : UniversalDataStorage . database ) { if ( c . getFloatingParts ( ) == floatingParts && Arrays . toString ( c . getIntersections ( ) . toArray ( ) ) . equals ( Arrays . toString ( intersections ) ) && ( c . getComplexStrokes ( ) + c . getStraightStrokes ( ) ) == ( complexStrokes + straightStrokes ) ) { String pinyin = c . getPinyin ( ) ; String character = c . getCharacter ( ) ; String meaning = c . getMeaning ( ) ; chinesecharacter = new ChineseCharacter ( pinyin , character , meaning , floatingParts , new ArrayList < Integer > ( Arrays . asList ( intersections ) ) , straightStrokes , complexStrokes ) ; System . out . println ( chinesecharacter ) ; PossibleChineseCharactersPanel . addToList ( chinesecharacter ) ; LogManager . logThing ( "Character found:" + chinesecharacter + " " + TimeManager . getCurrentTimeAndDate ( ) ) ; } } } } ) ; return chinesecharacter ; }
tr	8	@ Before public void setUp ( ) throws Exception { mapa = new boolean [ 60 ] [ 60 ] ; for ( int i = 0 ; i < 60 ; i ++ ) { for ( int j = 0 ; j < 60 ; j ++ ) mapa [ i ] [ j ] = false ; } for ( int i = 19 ; i <= 31 ; i ++ ) { for ( int j = 35 ; j <= 51 ; j ++ ) mapa [ j ] [ i ] = true ; } for ( int i = 7 ; i <= 15 ; i ++ ) { for ( int j = 15 ; j <= 23 ; j ++ ) mapa [ j ] [ i ] = true ; } for ( int i = 34 ; i <= 46 ; i ++ ) { for ( int j = 19 ; j <= 27 ; j ++ ) mapa [ j ] [ i ] = true ; } }
tr	4	public static int getPathLength ( DependencyInstance inst , int p , int a ) { int length = 0 ; int [ ] heads = inst . heads ; int pa = heads [ a ] ; for ( int i = 0 , x = p ; i <= MAX_DEPTH && x >= 0 ; ++ i ) { if ( x == a ) break ; if ( x == pa ) { ++ length ; break ; } ++ length ; x = heads [ x ] ; } return length ; }
tr	4	public GameMap parseMap ( File mapFile ) { try { reader = new BufferedReader ( new FileReader ( mapFile ) ) ; parseDimensions ( ) ; parseSpriteSheets ( ) ; parseTerrain ( ) ; parseMapLayout ( ) ; parseUnits ( ) ; parseUnitsPosition ( ) ; map . buildGraph ( ) ; scanner . close ( ) ; reader . close ( ) ; } catch ( FileNotFoundException e ) { System . out . println ( mapFile + " not found" ) ; return null ; } catch ( IOException e ) { System . out . println ( "Could not read line" ) ; return null ; } catch ( InvalidTokenException e ) { System . out . println ( e . getMessage ( ) ) ; return null ; } catch ( ExpectedTokenException e ) { System . out . println ( e . getMessage ( ) ) ; return null ; } return map ; }
tr	3	private void drawQuitButton ( ) { Box tempBox = new Box ( BoxLayout . X_AXIS ) ; statBox . add ( tempBox ) ; quit = new KulButton ( s ( "quit" ) ) ; quit . setPreferredSize ( new Dimension ( 140 , 50 ) ) ; quit . setMaximumSize ( new Dimension ( 140 , 50 ) ) ; quit . setForeground ( Color . WHITE ) ; quit . addMouseListener ( new MouseAdapter ( ) { @ Override public void mouseClicked ( MouseEvent e ) { if ( SwingUtilities . isLeftMouseButton ( e ) && ! bestScorePanel . isActive ( ) ) { String [ ] options = { s ( "yes" ) , s ( "no" ) } ; int choice = JOptionPane . showOptionDialog ( MainPanel . this , s ( "quitConfirm" ) , s ( "quit" ) , JOptionPane . YES_NO_OPTION , JOptionPane . WARNING_MESSAGE , null , options , 0 ) ; if ( choice == JOptionPane . OK_OPTION ) { main . Main . closeWindow ( ) ; } } } } ) ; tempBox . add ( quit ) ; }
tr	2	@ Override public void NewEntry ( SourceTextEntry active_entry ) { if ( current_file_node != null && active_entry != null ) { last_edited_text = Core . getEditor ( ) . getCurrentTranslation ( ) ; caretupdates_to_ignore = 1 ; sessionlog . GetMenu ( ) . setPauseTimestamp ( 0 ) ; sessionlog . GetMenu ( ) . getPausetiming ( ) . setSelected ( false ) ; Element element = NewElement ( "segment" , true ) ; element . setAttribute ( "number" , Integer . toString ( Core . getEditor ( ) . getCurrentEntry ( ) . entryNum ( ) ) ) ; Element source_element = NewElement ( "source" , false ) ; source_element . appendChild ( log_document . createTextNode ( Core . getEditor ( ) . getCurrentEntry ( ) . getSrcText ( ) ) ) ; element . appendChild ( source_element ) ; Element target_element = NewElement ( "initialTarget" , false ) ; target_element . appendChild ( log_document . createTextNode ( Core . getEditor ( ) . getCurrentTranslation ( ) ) ) ; element . appendChild ( target_element ) ; current_entry_node = element ; current_file_node . appendChild ( current_entry_node ) ; current_editions_node = NewElement ( "events" , false ) ; chosen_entry_time = System . nanoTime ( ) ; current_segment_number = Core . getEditor ( ) . getCurrentEntry ( ) . entryNum ( ) ; } }
tr	5	public int read ( byte [ ] paramArrayOfByte , int paramInt1 , int paramInt2 ) throws IOException { if ( isClosed ) { throw new IOException ( "stream closed" ) ; } if ( ( paramInt1 | paramInt2 | paramInt1 + paramInt2 | paramArrayOfByte . length - ( paramInt1 + paramInt2 ) ) < 0 ) { throw new IndexOutOfBoundsException ( ) ; } if ( paramInt2 == 0 ) { return 0 ; } if ( uncompressed_offset == uncompressed_size ) fill_buffer ( ) ; if ( uncompressed_offset == uncompressed_size ) { return - 1 ; } int i = Math . min ( paramInt2 , uncompressed_size - uncompressed_offset ) ; System . arraycopy ( uncompressed_buffer , uncompressed_offset , paramArrayOfByte , paramInt1 , i ) ; uncompressed_offset += i ; return i ; }
tr	9	private boolean r_Step_4 ( ) { int among_var ; int v_1 ; ket = cursor ; among_var = find_among_b ( a_5 , 19 ) ; if ( among_var == 0 ) { return false ; } bra = cursor ; if ( ! r_R2 ( ) ) { return false ; } switch ( among_var ) { case 0 : return false ; case 1 : slice_del ( ) ; break ; case 2 : lab0 : do { v_1 = limit - cursor ; lab1 : do { if ( ! ( eq_s_b ( 1 , "s" ) ) ) { break lab1 ; } break lab0 ; } while ( false ) ; cursor = limit - v_1 ; if ( ! ( eq_s_b ( 1 , "t" ) ) ) { return false ; } } while ( false ) ; slice_del ( ) ; break ; } return true ; }
tr	7	private void readValues ( Stream stream ) { do { int j = stream . readUnsignedByte ( ) ; if ( j == 0 ) return ; if ( j == 1 ) { anInt648 = stream . readUnsignedWord ( ) ; anInt649 = stream . readUnsignedByte ( ) ; anInt650 = stream . readUnsignedByte ( ) ; } else if ( j == 10 ) stream . readString ( ) ; else if ( j == 2 ) aBoolean651 = true ; else if ( j == 3 ) stream . readDWord ( ) ; else if ( j == 4 ) stream . readDWord ( ) ; else System . out . println ( "Error unrecognised config code: " + j ) ; } while ( true ) ; }
tr	8	private void direccionproveedoresFieldKeyTyped ( java . awt . event . KeyEvent evt ) { if ( ! Character . isLetterOrDigit ( evt . getKeyChar ( ) ) && ! Character . isISOControl ( evt . getKeyChar ( ) ) && evt . getKeyChar ( ) != # && evt . getKeyChar ( ) != . && evt . getKeyChar ( ) != - && evt . getKeyChar ( ) !=   && ! Character . isWhitespace ( evt . getKeyChar ( ) ) ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; evt . consume ( ) ; } if ( laboratorioperteneceField . getText ( ) . length ( ) == 100 ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; evt . consume ( ) ; JOptionPane . showMessageDialog ( this , "Direccion demasiado larga." , "ADVERTENCIA" , WIDTH ) ; } }
tr	4	public void applyTransformation ( int frameId ) { if ( vertexSkin == null ) return ; if ( frameId == - 1 ) return ; Animation animationFrame = Animation . forFrameId ( frameId ) ; if ( animationFrame == null ) return ; Skins skins = animationFrame . animationSkins ; vertexModifierX = 0 ; vertexModifierY = 0 ; vertexModifierZ = 0 ; for ( int stepId = 0 ; stepId < animationFrame . frameCount ; stepId ++ ) { int opcode = animationFrame . opcodeTable [ stepId ] ; transformFrame ( skins . opcodes [ opcode ] , skins . skinList [ opcode ] , animationFrame . transformationX [ stepId ] , animationFrame . transformationY [ stepId ] , animationFrame . transformationZ [ stepId ] ) ; } }
