tr	3	@ Override public void mouseReleased ( MouseEvent evt ) { if ( evt . getClickCount ( ) == 2 ) { tableDoubleClick ( "Employee" ) ; } if ( _view . table_employee . isRowSelected ( _view . table_employee . getSelectedRow ( ) ) ) { if ( evt . getButton ( ) == MouseEvent . BUTTON3 ) { Integer integer = ( Integer ) _view . table_employee . getValueAt ( _view . table_employee . getSelectedRow ( ) , 0 ) ; int rowNumber = _view . table_employee . rowAtPoint ( evt . getPoint ( ) ) ; _view . table_employee . getSelectionModel ( ) . setSelectionInterval ( rowNumber , rowNumber ) ; showPopup ( evt , integer , "Employee" ) ; } } }
tr	1	private void drawCheckerboard ( Graphics2D g ) { Color backupColor = g . getColor ( ) ; Stroke backupStroke = g . getStroke ( ) ; g . setColor ( Color . RED ) ; g . setStroke ( new BasicStroke ( 1.0f ) ) ; g . drawRect ( 0 , 0 , _canvasBackground . getWidth ( ) - 1 , _canvasBackground . getHeight ( ) - 1 ) ; for ( int i = 0 ; i < _imageList . size ( ) ; i ++ ) { IPLNode node = _imageList . get ( i ) ; g . drawRect ( node . getX ( ) , node . getY ( ) , node . getScaleWidth ( ) , node . getScaleHeight ( ) ) ; } g . setColor ( backupColor ) ; g . setStroke ( backupStroke ) ; }
tr	9X	private boolean r_mark_suffix_with_optional_n_consonant ( ) { int v_1 ; int v_2 ; int v_3 ; int v_4 ; int v_5 ; int v_6 ; int v_7 ; lab0 : do { v_1 = limit - cursor ; lab1 : do { v_2 = limit - cursor ; if ( ! ( eq_s_b ( 1 , "n" ) ) ) { break lab1 ; } cursor = limit - v_2 ; if ( cursor <= limit_backward ) { break lab1 ; } cursor -- ; v_3 = limit - cursor ; if ( ! ( in_grouping_b ( g_vowel , 97 , 305 ) ) ) { break lab1 ; } cursor = limit - v_3 ; break lab0 ; } while ( false ) ; cursor = limit - v_1 ; { v_4 = limit - cursor ; lab2 : do { v_5 = limit - cursor ; if ( ! ( eq_s_b ( 1 , "n" ) ) ) { break lab2 ; } cursor = limit - v_5 ; return false ; } while ( false ) ; cursor = limit - v_4 ; } v_6 = limit - cursor ; if ( cursor <= limit_backward ) { return false ; } cursor -- ; v_7 = limit - cursor ; if ( ! ( in_grouping_b ( g_vowel , 97 , 305 ) ) ) { return false ; } cursor = limit - v_7 ; cursor = limit - v_6 ; } while ( false ) ; return true ; }
tr	3	public String getMimetype ( String paramString ) { int i = paramString . lastIndexOf ( "." ) ; if ( ( i > 0 ) && ( i + 1 < paramString . length ( ) ) ) { String str1 = paramString . substring ( i + 1 ) ; if ( this . extensionToMimetypeMap . keySet ( ) . contains ( str1 ) ) { String str2 = ( String ) this . extensionToMimetypeMap . get ( str1 ) ; logger . info ( "Recognised extension '" + str1 + "'  mimetype is: '" + str2 + "'" ) ; return str2 ; } logger . info ( "Extension '" + str1 + "' is unrecognized in mime type listing" + "  using default mime type: '" + "application/octet-stream" + "'" ) ; } else { logger . info ( "File name has no extension  mime type cannot be recognised for: " + paramString ) ; } return "application/octet-stream" ; }
tr	4	public static void fileSaveAsSCM ( File target ) { if ( MainMethods . openFile == null ) { updateStatusBar ( "Nothing to save ... please open a file first!" , 2 ) ; return ; } if ( ! MainMethods . openFile . isScmFile ( ) ) { updateStatusBar ( "You must open a SCM File to save as an SCM file" , 2 ) ; return ; } File outputFile = target ; if ( outputFile == null ) outputFile = MainMethods . getFileToSaveIn ( ) ; MapParser . write ( MainMethods . openFile . getChannelList ( ) , MainMethods . openFile . getFile ( ) ) ; int compressedFiles = ZipHandler . compress ( outputFile . getAbsolutePath ( ) , MainMethods . openFile . scmExtractedTo ( ) . getAbsolutePath ( ) ) ; if ( compressedFiles < 0 ) { MainMethods . updateStatusBar ( "Packaging SCM file failed!" , 2 ) ; return ; } updateStatusBar ( "Saved SCM file as \"" + outputFile . getAbsolutePath ( ) + "\"" , 2 ) ; }
tr	2	@ Before public void setUp ( ) { try { class . forName ( "com.mysql.jdbc.Driver" ) ; } catch ( ClassNotFoundException e ) { System . out . println ( "MySQL JDBC Driver not found !!" ) ; return ; } Connection connect = null ; Statement statement = null ; try { connect = DriverManager . getConnection ( "jdbc:mysql://localhost/schoolmate" , "schoolmate" , "schoolmate" ) ; statement = connect . createStatement ( ) ; statement . execute ( "update courses set coursename=\"'><a>link</a>'\" where courseid=5 " ) ; } catch ( SQLException e ) { System . out . printf ( e . toString ( ) ) ; } tester . setBaseUrl ( "http://localhost/schoolmate" ) ; tester . beginAt ( "index.php" ) ; tester . setTextField ( "username" , "simoncelli" ) ; tester . setTextField ( "password" , "1" ) ; tester . submit ( ) ; }
tr	7	public static void main ( String [ ] args ) { String pathinput = "C:/Users/lin/Desktop/train_weibo_balanced.arff" ; String pathoutput = "C:/Users/lin/Desktop/train_weibo_balanced(chongxinbianUniqueID).arff" ; File file = new File ( pathinput ) ; BufferedReader reader = null ; try { reader = new BufferedReader ( new FileReader ( file ) ) ; String tempString = null ; OutputStreamWriter writer = new OutputStreamWriter ( new FileOutputStream ( pathoutput ) , "UTF-8" ) ; int num = 0 ; while ( ( tempString = reader . readLine ( ) ) != null ) { if ( tempString . contains ( " {0 " ) ) { String t = tempString . substring ( 4 , 5 ) ; for ( int i = 1 ; i < 7 ; i ++ ) { String begin = "  " + i + " " ; String end = "  " + ( i + 1 ) + " " ; t += " " + tempString . substring ( tempString . indexOf ( begin ) + begin . length ( ) , tempString . indexOf ( end ) ) ; } t += " " + num ++ ; for ( int i = 8 ; i < 207 ; i ++ ) { String begin = "  " + i + " " ; String end = "  " + ( i + 1 ) + " " ; t += " " + tempString . substring ( tempString . indexOf ( begin ) + begin . length ( ) , tempString . indexOf ( end ) ) ; } t += " " + tempString . substring ( tempString . indexOf ( "  207 " ) + 6 , tempString . indexOf ( " }" ) ) ; writer . write ( t + "\r\n" ) ; } else { writer . write ( tempString + "\r\n" ) ; } } reader . close ( ) ; writer . flush ( ) ; writer . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { if ( reader != null ) { try { reader . close ( ) ; } catch ( IOException e1 ) { } } } }
tr	9X	public static void arraycopy ( final ObjectLargeArray src , final long srcPos , final ObjectLargeArray dest , final long destPos , final long length ) { if ( srcPos < 0 || srcPos >= src . length ( ) ) { throw new ArrayIndexOutOfBoundsException ( "srcPos < 0 || srcPos >= src.length()" ) ; } if ( destPos < 0 || destPos >= dest . length ( ) ) { throw new ArrayIndexOutOfBoundsException ( "destPos < 0 || destPos >= dest.length()" ) ; } if ( length < 0 ) { throw new IllegalArgumentException ( "length < 0" ) ; } if ( dest . isConstant ( ) ) { throw new IllegalArgumentException ( "Constant arrays cannot be modified." ) ; } int nthreads = ( int ) Math . min ( length , Runtime . getRuntime ( ) . availableProcessors ( ) ) ; if ( nthreads < 2 || length < 100000 ) { for ( long i = srcPos , j = destPos ; i < srcPos + length ; i ++ , j ++ ) { dest . set ( j , src . get ( i ) ) ; } } else { long k = length / nthreads ; Thread [ ] threads = new Thread [ nthreads ] ; for ( int j = 0 ; j < nthreads ; j ++ ) { final long firstIdx = j * k ; final long lastIdx = ( j == nthreads - 1 ) ? length : firstIdx + k ; threads [ j ] = new Thread ( new Runnable ( ) { @ Override public void run ( ) { for ( long k = firstIdx ; k < lastIdx ; k ++ ) { dest . set ( destPos + k , src . get ( srcPos + k ) ) ; } } } ) ; threads [ j ] . start ( ) ; } try { for ( int j = 0 ; j < nthreads ; j ++ ) { threads [ j ] . join ( ) ; threads [ j ] = null ; } } catch ( InterruptedException ex ) { for ( long i = srcPos , j = destPos ; i < srcPos + length ; i ++ , j ++ ) { dest . set ( j , src . get ( i ) ) ; } } } }
tr	8	public static Object subtract ( Object val0 , Object val1 ) { val0 = guess ( val0 ) ; val1 = guess ( val1 ) ; if ( val0 instanceof Color ) return ( ( Color ) val0 ) . subtract ( val1 ) ; if ( val0 instanceof Size ) return ( ( Size ) val0 ) . subtract ( val1 ) ; if ( val0 instanceof Number && val1 instanceof Number ) { if ( val0 instanceof double || val1 instanceof double ) return ( ( Number ) val0 ) . doubleValue ( ) - ( ( Number ) val1 ) . doubleValue ( ) ; return ( ( Number ) val0 ) . intValue ( ) - ( ( Number ) val1 ) . intValue ( ) ; } return val0 == null ? null : val1 == null ? val0 : Classes . toString ( val0 ) . replace ( Classes . toString ( val1 ) , "" ) ; }
tr	4	private void jButtonCheckRoomsActionPerformed ( java . awt . event . ActionEvent evt ) { dflRooms . removeAllElements ( ) ; if ( "" . equals ( jXDatePickercheckRoomArrival . getEditor ( ) . getText ( ) ) || "" . equals ( jXDatePickercheckRoomDeparture . getEditor ( ) . getText ( ) ) ) { JOptionPane . showMessageDialog ( rootPane , "Make sure both arrival and departure date are entered and in the correct format" ) ; } else { DateFormat dateFormat = new SimpleDateFormat ( "yyyy-MM-dd" ) ; jXDatePickercheckRoomArrival . setFormats ( dateFormat ) ; jXDatePickercheckRoomDeparture . setFormats ( dateFormat ) ; String arrival = dateFormat . format ( jXDatePickercheckRoomArrival . getDate ( ) ) . toString ( ) ; String departure = dateFormat . format ( jXDatePickercheckRoomDeparture . getDate ( ) ) . toString ( ) ; r = con . getRoomsList ( arrival , departure ) ; if ( r != null ) { for ( int i = 0 ; i < r . size ( ) ; i ++ ) { dflRooms . addElement ( r . get ( i ) . toString ( ) ) ; } } else { Statuslabel . setText ( "Could not get Rooms" ) ; } con . resetRooms ( ) ; } }
tr	5	public static Integer createOfficeObject ( Integer OFFICE_OBJECT_TYPE_ID ) { Integer id = getUniqueId ( ) ; PreparedStatement ps = null ; try { con = ConnectionManager . getConnection ( ) ; if ( con == null ) { return null ; } String insertTableSQL = "INSERT INTO office_object(id  name  office_object_type_id  office_object_status_id)" + " VALUES (? ? ? ?)" ; ps = con . prepareStatement ( insertTableSQL ) ; ps . setInt ( 1 , id ) ; ps . setString ( 2 , "" ) ; ps . setInt ( 3 , OFFICE_OBJECT_TYPE_ID ) ; ps . setInt ( 4 , OfficeObject . ALL_IS_OK ) ; ps . executeUpdate ( ) ; } catch ( MySQLIntegrityConstraintViolationException e ) { e . printStackTrace ( ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; logger . error ( "SQL query execution errors. Error: " + e . getSQLState ( ) + " | " + e . getErrorCode ( ) ) ; } finally { try { if ( ps != null ) ps . close ( ) ; } catch ( Exception e ) { logger . warn ( "Connection was closed with errors." ) ; } } return id ; }
tr	9X	@ Override public PixelArray getPixels ( int w , int h ) { PixelArray pixels = new PixelArray ( w , h ) ; int count = 0 ; for ( int y = 0 ; y < pixels . getHeight ( ) ; y += 4 ) for ( int x = 0 ; x < pixels . getWidth ( ) ; x += 4 ) { pixels . setPixel ( count ++ , x , y ) ; } for ( int y = 1 ; y < pixels . getHeight ( ) ; y += 2 ) for ( int x = 2 ; x < pixels . getWidth ( ) ; x += 4 ) { pixels . setPixel ( count ++ , x , y ) ; } for ( int y = 2 ; y < pixels . getHeight ( ) ; y += 4 ) for ( int x = 0 ; x < pixels . getWidth ( ) ; x += 4 ) { pixels . setPixel ( count ++ , x , y ) ; } for ( int y = 0 ; y < pixels . getHeight ( ) ; y += 2 ) for ( int x = 0 ; x < pixels . getWidth ( ) ; x += 4 ) { if ( x + 2 < pixels . getWidth ( ) ) pixels . setPixel ( count ++ , x + 2 , y ) ; if ( y + 1 < pixels . getHeight ( ) ) pixels . setPixel ( count ++ , x , y + 1 ) ; } for ( int y = 0 ; y < pixels . getHeight ( ) ; y += 2 ) for ( int x = 1 ; x < pixels . getWidth ( ) ; x += 2 ) { pixels . setPixel ( count ++ , x , y ) ; } for ( int y = 1 ; y < pixels . getHeight ( ) ; y += 2 ) for ( int x = 1 ; x < pixels . getWidth ( ) ; x += 2 ) { pixels . setPixel ( count ++ , x , y ) ; } return pixels ; }
tr	6	public Object stringToValue ( String text ) throws ParseException { StringTokenizer tokenizer = new StringTokenizer ( text , "." ) ; byte [ ] a = new byte [ 4 ] ; for ( int i = 0 ; i < 4 ; i ++ ) { int b = 0 ; if ( ! tokenizer . hasMoreTokens ( ) ) throw new ParseException ( "Too few bytes" , 0 ) ; try { b = Integer . parseInt ( tokenizer . nextToken ( ) ) ; } catch ( NumberFormatException e ) { throw new ParseException ( "Not an integer" , 0 ) ; } if ( b < 0 || b >= 256 ) throw new ParseException ( "Byte out of range" , 0 ) ; a [ i ] = ( byte ) b ; } if ( tokenizer . hasMoreTokens ( ) ) throw new ParseException ( "Too many bytes" , 0 ) ; return a ; }
tr	5	private static Collection < Layer > parseLayerArgument ( Model model , String layersarg ) { Collection < Layer > lays ; if ( layersarg . equalsIgnoreCase ( "all" ) ) { lays = model . getLayer ( ) ; } else { String [ ] layersarg1 = layersarg . split ( " " ) ; lays = new ArrayList < Layer > ( ) ; for ( Layer lay1 : model . getLayer ( ) ) { for ( String lan : layersarg1 ) { if ( lan . equals ( String . valueOf ( lay1 . getNumber ( ) ) ) ) { lays . add ( lay1 ) ; } } } } if ( lays . isEmpty ( ) ) { System . err . println ( "No matching layers found." ) ; System . exit ( 1 ) ; } return lays ; }
tr	1	@ Override public boolean equals ( Object other ) { if ( other instanceof NewId ) { return this . equals ( ( NewId ) other ) ; } return false ; }
tr	7	public static void recoverTree ( TreeNode root ) { int preValue = Integer . MIN_VALUE ; int currentValue = Integer . MIN_VALUE ; Stack < TreeNode > stack = new Stack < TreeNode > ( ) ; TreeNode pre1 = null ; TreeNode pre2 = null ; TreeNode cur = root ; TreeNode preNode = null ; while ( cur != null || ! stack . isEmpty ( ) ) { while ( cur != null ) { stack . push ( cur ) ; cur = cur . left ; } cur = stack . pop ( ) ; System . out . println ( stack . size ( ) ) ; currentValue = cur . val ; if ( currentValue < preValue ) { if ( pre1 == null ) { pre1 = preNode ; pre2 = cur ; } else { pre2 = cur ; break ; } } preNode = cur ; preValue = currentValue ; cur = cur . right ; } if ( pre1 != null && pre2 != null ) { int temp = pre1 . val ; pre1 . val = pre2 . val ; pre2 . val = temp ; } }
tr	1	public String getClientToken ( ) { if ( clientToken . isEmpty ( ) ) { logger . debug ( "Token is empty.<br> A new one will be generated." ) ; clientToken = java . util . UUID . randomUUID ( ) . toString ( ) ; clientToken = clientToken . replaceAll ( "-" , "" ) ; logger . debug ( clientToken ) ; } return clientToken ; }
tr	4	@ Test public void testTokenPayment ( ) { Gateway beanstream = new Gateway ( "v1" , 300200578 , "4BaD82D9197b4cc4b70a221911eE9f70" ) ; HttpsConnector connector = new HttpsConnector ( 300200578 , "4BaD82D9197b4cc4b70a221911eE9f70" ) ; LegatoTokenRequest legatoTokenRequest = new LegatoTokenRequest ( ) ; legatoTokenRequest . number = "5100000010001004" ; legatoTokenRequest . expiryMonth = 12 ; legatoTokenRequest . expiryYear = 18 ; legatoTokenRequest . cvd = "123" ; String url = "https://www.beanstream.com/scripts/tokenization/tokens" ; String output = "" ; try { output = connector . ProcessTransaction ( HttpMethod . post , url , legatoTokenRequest ) ; } catch ( BeanstreamApiException ex ) { Logger . getLogger ( SampleTransactions . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; assert . fail ( ex . getMessage ( ) ) ; } Gson gson = new Gson ( ) ; LegatoTokenResponse tokenResponse = gson . fromJson ( output , LegatoTokenResponse . class ) ; System . out . println ( "token: " + output ) ; TokenPaymentRequest tokenReq = new TokenPaymentRequest ( ) ; tokenReq . setAmount ( 100.00 ) ; tokenReq . setOrderNumber ( getRandomOrderId ( "token" ) ) ; tokenReq . getToken ( ) . setName ( "John Doe" ) . setCode ( tokenResponse . getToken ( ) ) ; try { PaymentResponse response = beanstream . payments ( ) . makePayment ( tokenReq ) ; System . out . println ( "Token Payment Approved? " + response . isApproved ( ) ) ; } catch ( BeanstreamApiException ex ) { Logger . getLogger ( this . getClass ( ) . getName ( ) ) . log ( Level . SEVERE , "An error occurred" , ex ) ; assert . fail ( ex . getMessage ( ) ) ; } try { output = connector . ProcessTransaction ( HttpMethod . post , url , legatoTokenRequest ) ; } catch ( BeanstreamApiException ex ) { Logger . getLogger ( SampleTransactions . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; assert . fail ( ex . getMessage ( ) ) ; } tokenResponse = gson . fromJson ( output , LegatoTokenResponse . class ) ; System . out . println ( "Token pre-auth: " + tokenResponse . getToken ( ) ) ; TokenPaymentRequest req = new TokenPaymentRequest ( ) ; req . setAmount ( 80.00 ) ; req . setOrderNumber ( getRandomOrderId ( "token" ) ) ; req . getToken ( ) . setName ( "John Doe" ) . setCode ( tokenResponse . getToken ( ) ) ; try { PaymentResponse response = beanstream . payments ( ) . preAuth ( req ) ; System . out . println ( "Token Payment Approved? " + response . isApproved ( ) ) ; response = beanstream . payments ( ) . preAuthCompletion ( response . id , 55.30 ) ; assert . assertTrue ( response . isApproved ( ) ) ; assert . assertEquals ( "PAC" , response . type ) ; } catch ( BeanstreamApiException ex ) { Logger . getLogger ( this . getClass ( ) . getName ( ) ) . log ( Level . SEVERE , "An error occurred" , ex ) ; assert . fail ( ex . getMessage ( ) ) ; } }
tr	5	public < H , S > void dispatch ( Event < H , S > event , S source ) { event . setSource ( source ) ; try { for ( H handler : this . < H > getQueueForType ( registeredHandlers , event . getType ( ) ) ) { try { event . dispatch ( handler ) ; } catch ( Throwable t ) { LoggerFactory . getLogger ( handler . getClass ( ) ) . error ( "Unhandled exception while dispatching event" , t ) ; } } for ( Reference < Waiter < Event < H , S >>> ref : this . < Reference < Waiter < Event < H , S >>> > getQueueForType ( registeredWaiters , event . getType ( ) ) ) { Waiter < Event < H , S >> waiter = ref . get ( ) ; if ( waiter != null ) { waiter . offer ( event ) ; } } if ( ! ( event instanceof EventEvent ) ) { dispatch ( new EventEvent ( ) , event ) ; } } finally { event . setSource ( null ) ; } }
tr	0	public Holder ( ) { System . out . println ( "Holder created" ) ; }
tr	5	public boolean equals ( Object o ) { if ( o == this ) return true ; if ( ! ( o instanceof Card ) ) return false ; Card aCard = ( Card ) o ; if ( ( aCard . suitID == this . suitID ) && ( aCard . nonTrumpCardValue == this . nonTrumpCardValue ) && ( aCard . trumpCardValue == this . trumpCardValue ) ) return true ; return false ; }
tr	8	public List < HackResult > grok ( Reader reader ) throws IOException { long t0 = System . currentTimeMillis ( ) ; _HackContainer o = new _HackContainer ( ) ; Type t = new TypeToken < _HackContainer > ( ) { } . getType ( ) ; o = GSON . fromJson ( reader , t ) ; if ( o == null ) throw new IOException ( "GSON returned null!" ) ; L . info ( "Claimed size=" + o . total_rows ) ; if ( o . total_rows == 0 ) throw new IOException ( "GSON did not find objects!" ) ; List < HackResult > res = new ArrayList < HackResult > ( o . total_rows ) ; int total = 0 ; int count = 0 ; int canGetUltraCount = 0 ; for ( _HackRow r : o . rows ) { ++ count ; HackResult h = r . doc ; h . sourceLine = count ; if ( h . resos == null || h . hacker == null ) { L . warn ( "Skipping item " + count + " no resonators attached. id=" + h . _id ) ; continue ; } if ( L . isTraceEnabled ( ) ) L . trace ( String . format ( "  %5d %s\n" , count , h ) ) ; if ( h . hasCanGetUltra ( ) ) canGetUltraCount ++ ; total += h . getItemCount ( ) ; res . add ( h ) ; } long t1 = System . currentTimeMillis ( ) ; L . info ( "*** " + res . size ( ) + " hacks for " + total + " items  canGetUltraCount=" + canGetUltraCount + "  lengthCheck=" + ( res . size ( ) != o . total_rows ? "WARNING" : "OK" ) + " dt=" + ( t1 - t0 ) + " ms" ) ; return res ; }
tr	3	private DefaultTreeModel getGroups ( ) { DefaultMutableTreeNode root = new DefaultMutableTreeNode ( Constants . STR_GROUP ) ; String userNo = String . valueOf ( user . get ( Constants . USER_NO ) ) ; List < Map < String , Object >> groupList = userDao . getGroup ( userNo ) ; for ( int i = 0 , len = groupList . size ( ) ; i < len ; ++ i ) { Map < String , Object > group = groupList . get ( i ) ; DefaultMutableTreeNode child = new DefaultMutableTreeNode ( String . valueOf ( group . get ( Constants . GROUP_NAME ) ) ) ; Map < String , Object > param = new HashMap < String , Object > ( ) ; param . put ( Constants . USER_NO , String . valueOf ( group . get ( Constants . USER_NO ) ) ) ; param . put ( Constants . GROUP_NO , String . valueOf ( group . get ( Constants . GROUP_NO ) ) ) ; List < Map < String , Object >> friendList = userDao . getFriend ( param ) ; if ( Constants . NUM_ZERO != friendList . size ( ) ) { for ( int j = 0 , size = friendList . size ( ) ; j < size ; ++ j ) { Map < String , Object > friend = friendList . get ( j ) ; String friendNo = String . valueOf ( friend . get ( Constants . FRIEND_NO ) ) ; StringBuilder sb = new StringBuilder ( ) ; sb . append ( userDao . getUserInfo ( friendNo ) ) ; sb . append ( "(" ) ; sb . append ( friendNo ) ; sb . append ( ")" ) ; sb . append ( "  <" ) ; int status = userDao . getStatus ( friendNo ) ; sb . append ( userStatus . getItemAt ( status ) . toString ( ) ) ; sb . append ( ">" ) ; DefaultMutableTreeNode childschild = new DefaultMutableTreeNode ( sb . toString ( ) ) ; child . add ( childschild ) ; } } root . add ( child ) ; } return new DefaultTreeModel ( root ) ; }
tr	0	@ Override public String getParams ( ) { StringBuilder parmas = new StringBuilder ( ) ; parmas . append ( pppUserName ) . append ( CTConstant . VALUE_ACCOUNT ) . append ( pppPassword ) ; return parmas . toString ( ) ; }
tr	4	public static void main ( String [ ] args ) { Conn con = PoolManager . getInstance ( ) . getConnection ( ) ; Connection conn = con . getConn ( ) ; Statement stmt = null ; ResultSet rs = null ; try { stmt = conn . createStatement ( ) ; rs = stmt . executeQuery ( "select * from article " ) ; int c = rs . getMetaData ( ) . getColumnCount ( ) ; for ( int i = 1 ; i <= c ; ++ i ) { System . out . println ( rs . getMetaData ( ) . getColumnName ( i ) ) ; } while ( rs . next ( ) ) { System . out . print ( rs . getString ( "title" ) ) ; System . out . print ( rs . getString ( "author" ) ) ; System . out . println ( ) ; } } catch ( SQLException e ) { e . printStackTrace ( ) ; } finally { try { stmt . close ( ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; } PoolManager . getInstance ( ) . releaseConnection ( con ) ; } }
tr	6	public static OS getPlatform ( ) { String osName = System . getProperty ( "os.name" ) . toLowerCase ( ) ; if ( osName . contains ( "win" ) ) return OS . windows ; if ( osName . contains ( "mac" ) ) return OS . macos ; if ( osName . contains ( "solaris" ) ) return OS . solaris ; if ( osName . contains ( "sunos" ) ) return OS . solaris ; if ( osName . contains ( "linux" ) ) return OS . linux ; if ( osName . contains ( "unix" ) ) return OS . linux ; return OS . unknown ; }
tr	5	public ListNode deleteDuplicates ( ListNode head ) { if ( head == null ) return null ; ListNode cur = head ; ListNode last = head ; int value = head . val ; while ( cur . next != null ) { cur = cur . next ; if ( cur . val != value ) { if ( last . next != cur ) last . next = cur ; last = cur ; value = cur . val ; } } if ( last != cur ) { last . next = null ; } return head ; }
tr	2	public UnitGroupElementOrderProblem ( final String difficulty ) { easyBounds = new Pair ( 5 , 11 ) ; mediumBounds = new Pair ( 11 , 37 ) ; hardBounds = new Pair ( 37 , 97 ) ; final Pair < Integer , Integer > bounds = initBounds ( difficulty ) ; final int lowerBound = bounds . getFirst ( ) ; final int upperBound = bounds . getSecond ( ) ; int element1 = 0 ; int n1 = 0 ; while ( ( ! Algorithms . isCoprime ( element1 , n1 ) ) || ( element1 > n1 ) ) { element1 = Algorithms . randInt ( 2 , 9 ) ; n1 = Algorithms . randInt ( lowerBound , upperBound ) ; } setVariables ( element1 , n1 ) ; }
tr	1	@ Override public void enterRule ( ParseTreeListener listener ) { if ( listener instanceof EnquantoListener ) ( ( EnquantoListener ) listener ) . enterEscreva ( this ) ; }
tr	8	public static Map < String , String > returnShipAdviceHeader ( String identifier ) { Map < String , String > headerValues = new HashMap < String , String > ( ) ; if ( conn == null ) { getConnection ( ) ; } try { String sql = "SELECT CustomerID FROM tblSalesHeader WHERE **column** = " + identifier ; String asnSql = "SELECT ShipFirstName  ShipLastName  ShipAdd1  ShipCity  ShipState  ShipPostalCode  ShipCountry  ShipVia  ShipRequestDate" + " FROM tblASNSalesHeader WHERE CustomerID = " + identifier ; String customerAsnSql = "SELECT CustomerOrderDate  CustomerOrderType  ShipRequestWarehouse  OrderCompleted FROM tblASNSalesHeader " + "WHERE CustomerID = " + identifier ; Statement customerStatement = conn . createStatement ( ) ; Statement shipStatement = conn . createStatement ( ) ; Statement customerShipStatement = conn . createStatement ( ) ; ResultSet customerId = customerStatement . executeQuery ( sql ) ; ResultSet shipInfo = shipStatement . executeQuery ( asnSql ) ; ResultSet customerShipDetails = customerShipStatement . executeQuery ( customerAsnSql ) ; if ( customerId != null ) { while ( customerId . next ( ) ) { headerValues . put ( "customer-id" , customerId . getString ( 1 ) ) ; } } if ( shipInfo != null ) { while ( shipInfo . next ( ) ) { headerValues . put ( "ship-first-name" , shipInfo . getString ( 1 ) ) ; headerValues . put ( "ship-last-name" , shipInfo . getString ( 2 ) ) ; headerValues . put ( "ship-addr1" , shipInfo . getString ( 3 ) ) ; headerValues . put ( "ship-city" , shipInfo . getString ( 4 ) ) ; headerValues . put ( "ship-state" , shipInfo . getString ( 5 ) ) ; headerValues . put ( "ship-postal-code" , shipInfo . getString ( 6 ) ) ; headerValues . put ( "ship-country" , shipInfo . getString ( 7 ) ) ; headerValues . put ( "ship-via" , shipInfo . getString ( 8 ) ) ; headerValues . put ( "ship-request-date" , shipInfo . getString ( 9 ) ) ; } } if ( customerShipDetails != null ) { while ( customerShipDetails . next ( ) ) { headerValues . put ( "customer-order-date" , customerShipDetails . getString ( 1 ) ) ; headerValues . put ( "customer-order-type" , customerShipDetails . getString ( 2 ) ) ; headerValues . put ( "ship-request-warehouse" , customerShipDetails . getString ( 3 ) ) ; headerValues . put ( "order-completed" , customerShipDetails . getString ( 4 ) ) ; } } } catch ( SQLException sqle ) { sqle . printStackTrace ( ) ; } return headerValues ; }
tr	3	@ Override public void endElement ( String uri , String localName , String qName ) throws SAXException { PlayXMLEnum playXMLEnum = PlayXMLEnum . valueOf ( qName . toUpperCase ( ) ) ; if ( playXMLEnum == PlayXMLEnum . DATE ) { int curId ; synchronized ( XMLPlaysHandler . class ) { curId = ++ dateId ; } currentPlay . addDate ( curId , parseTime ( currPlayDate ) ) ; } else if ( playXMLEnum == PlayXMLEnum . PLAY ) { addPlay ( currentPlay ) ; } else if ( playXMLEnum == PlayXMLEnum . DESCRIPTION ) { currentPlay . setDescription ( currentDesc . toString ( ) ) ; } currPlayEnum = null ; }
tr	3	public List < Pattern > findPatternsEqualTo ( int matchPattern , int matchCount , int [ ] [ ] board ) { List < Pattern > resultPatterns = new ArrayList < Pattern > ( ) ; for ( int i = 0 ; i < board . length ; i ++ ) { for ( int j = 0 ; j < board [ i ] . length ; j ++ ) { List < Pattern > result = checkPiecePatterns ( i , j , matchPattern , matchCount , board ) ; if ( result . size ( ) > 0 ) { resultPatterns . addAll ( result ) ; } } } return resultPatterns ; }
tr	7	public void keyPressed ( KeyEvent keyEvent ) { Iterator < PComponent > it = components . iterator ( ) ; while ( it . hasNext ( ) ) { PComponent comp = it . next ( ) ; if ( shouldHandleKeys ) { if ( comp . shouldHandleKeys ( ) ) comp . keyPressed ( keyEvent ) ; } else { if ( comp instanceof PFrame ) { for ( PComponent component : ( ( PFrame ) comp ) . getComponents ( ) ) if ( component . forceKeys ( ) ) component . keyPressed ( keyEvent ) ; } else if ( comp . forceKeys ( ) ) comp . keyPressed ( keyEvent ) ; } } }
tr	3	private static String intToKOrMilLongName ( int i ) { String s = String . valueOf ( i ) ; for ( int k = s . length ( ) - 3 ; k > 0 ; k -= 3 ) s = s . substring ( 0 , k ) + " " + s . substring ( k ) ; if ( s . length ( ) > 8 ) s = "@gre@" + s . substring ( 0 , s . length ( ) - 8 ) + " million @whi@(" + s + ")" ; else if ( s . length ( ) > 4 ) s = "@cya@" + s . substring ( 0 , s . length ( ) - 4 ) + "K @whi@(" + s + ")" ; return " " + s ; }
tr	4	public static void main ( String [ ] args ) { System . out . println ( "Main menu" ) ; System . out . println ( "1. Add" ) ; System . out . println ( "2. Subtract" ) ; System . out . println ( "3. Multiply" ) ; System . out . println ( "4. Divide" ) ; System . out . print ( "Press 1  2  3 or 4 >>> " ) ; Scanner scan = new Scanner ( System . in ) ; int key = scan . nextInt ( ) ; System . out . print ( "enter first number >>> " ) ; float a = scan . nextFloat ( ) ; System . out . print ( "enter second number >>> " ) ; float b = scan . nextFloat ( ) ; switch ( key ) { case 1 : System . out . println ( "result of " + a + " + " + b + " = " + ( a + b ) ) ; break ; case 2 : System . out . println ( "result of " + a + " - " + b + " = " + ( a - b ) ) ; break ; case 3 : System . out . println ( "result of " + a + " * " + b + " = " + ( a * b ) ) ; break ; case 4 : Zero_Devide zeroDevide = new Zero_Devide ( ) ; zeroDevide . isDevideByZero ( a , b ) ; break ; default : System . out . println ( "Unknown Operator !!!" ) ; } System . out . println ( "Good bye !!!" ) ; }
tr	8	static double grad ( int hash , double x , double y , double z ) { int h = hash & 15 ; double u = h < 8 || h == 12 || h == 13 ? x : y , v = h < 4 || h == 12 || h == 13 ? y : z ; return ( ( h & 1 ) == 0 ? u : - u ) + ( ( h & 2 ) == 0 ? v : - v ) ; }
tr	9X	public void updateRender ( ) { GridSquare [ ] [ ] gridData = controller . getGrid ( ) ; for ( int col = 0 ; col < gridData . length ; col ++ ) { for ( int row = 0 ; row < gridData [ col ] . length ; row ++ ) { String text = "" ; if ( gridData [ col ] [ row ] . player == EPlayer . None ) text += "-" ; else if ( gridData [ col ] [ row ] . player == EPlayer . P1 ) text += "o" ; else text += "x" ; if ( gridData [ col ] [ row ] . turnNumber >= 0 ) text += gridData [ col ] [ row ] . turnNumber . toString ( ) ; if ( gridData [ col ] [ row ] . undefinedTurns . size ( ) > 0 ) { text += "(" ; for ( Integer it : gridData [ col ] [ row ] . undefinedTurns . keySet ( ) ) { if ( gridData [ col ] [ row ] . undefinedTurns . get ( it ) == EPlayer . None ) text += "-" ; else if ( gridData [ col ] [ row ] . undefinedTurns . get ( it ) == EPlayer . P1 ) text += "o" ; else text += "x" ; if ( it >= 0 ) text += it . toString ( ) ; } text += ")" ; } gridBtn [ col ] [ row ] . setText ( text ) ; } } }
tr	6	@ Override public int loginUsuario ( String login , String password ) throws RemoteException { int result = - 1 ; ArrayList < UsuarioInt > usuarios = obtenerUsuarios ( ) ; for ( UsuarioInt usuario : usuarios ) { if ( login . compareTo ( usuario . getLogin ( ) ) == 0 && password . compareTo ( usuario . getPassword ( ) ) == 0 ) { if ( usuario . getAdmin ( ) ) { result = 2 ; } else { result = 1 ; } } else if ( login . compareTo ( usuario . getLogin ( ) ) == 0 || password . compareTo ( usuario . getPassword ( ) ) == 0 ) { result = 0 ; } } return result ; }
tr	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( Menu . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( Menu . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( Menu . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( Menu . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { new Menu ( ) . setVisible ( true ) ; } } ) ; }
tr	4	private AVLNode rotateLeftRight ( AVLNode parent ) { AVLNode parentNode = parent ; AVLNode current = ( AVLNode ) parentNode . left ; AVLNode moveToTop = ( AVLNode ) current . right ; AVLNode LRL = ( AVLNode ) moveToTop . left ; AVLNode LRR = ( AVLNode ) moveToTop . right ; if ( parent . parent == null ) { this . overallRoot = moveToTop ; ; moveToTop . parent = null ; } else if ( parent . parent . left == parent ) { parent . parent . left = moveToTop ; moveToTop . parent = parent . parent ; } else { parent . parent . right = moveToTop ; moveToTop . parent = parent . parent ; } current . right = LRL ; if ( LRL != null ) { LRL . parent = current ; } parent . left = LRR ; if ( LRR != null ) { LRR . parent = parent ; } moveToTop . left = current ; moveToTop . right = parent ; current . parent = moveToTop ; parent . parent = moveToTop ; return moveToTop ; }
tr	5	@ Test public void buildsGraph ( ) { Point p1 = vc . addPoint ( 0 , 0 ) ; Point p2 = vc . addPoint ( 1 , - 1 ) ; Point p3 = vc . addPoint ( 1 , 1 ) ; Point p4 = vc . addPoint ( 1.5 , 0.0 ) ; Point p5 = vc . addPoint ( 4 , - 1 ) ; Point p6 = vc . addPoint ( 4 , 1 ) ; p1 . setRight ( p2 ) ; p2 . setLeft ( p1 ) ; p3 . setRight ( p1 ) ; p1 . setLeft ( p3 ) ; p2 . setRight ( p3 ) ; p3 . setLeft ( p2 ) ; p4 . setRight ( p5 ) ; p5 . setLeft ( p4 ) ; p6 . setRight ( p4 ) ; p4 . setLeft ( p6 ) ; p5 . setRight ( p6 ) ; p6 . setLeft ( p5 ) ; vc . buildGraph ( ) ; Tree < Vertex > testadj1 = new Tree < > ( new VertexComparator ( ) ) ; Tree < Vertex > testadj2 = new Tree < > ( new VertexComparator ( ) ) ; Tree < Vertex > testadj3 = new Tree < > ( new VertexComparator ( ) ) ; Tree < Vertex > testadj4 = new Tree < > ( new VertexComparator ( ) ) ; Tree < Vertex > testadj5 = new Tree < > ( new VertexComparator ( ) ) ; Tree < Vertex > testadj6 = new Tree < > ( new VertexComparator ( ) ) ; testadj1 . add ( p2 ) ; testadj1 . add ( p3 ) ; testadj2 . add ( p1 ) ; testadj2 . add ( p5 ) ; testadj2 . add ( p4 ) ; testadj2 . add ( p3 ) ; testadj3 . add ( p1 ) ; testadj3 . add ( p6 ) ; testadj3 . add ( p4 ) ; testadj3 . add ( p2 ) ; testadj4 . add ( p2 ) ; testadj4 . add ( p3 ) ; testadj4 . add ( p5 ) ; testadj4 . add ( p6 ) ; testadj5 . add ( p2 ) ; testadj5 . add ( p4 ) ; testadj5 . add ( p6 ) ; testadj6 . add ( p5 ) ; testadj6 . add ( p4 ) ; testadj6 . add ( p3 ) ; assertTrue ( p1 . getAdjacents ( ) . equals ( testadj1 ) && p2 . getAdjacents ( ) . equals ( testadj2 ) && p3 . getAdjacents ( ) . equals ( testadj3 ) && p4 . getAdjacents ( ) . equals ( testadj4 ) && p5 . getAdjacents ( ) . equals ( testadj5 ) && p6 . getAdjacents ( ) . equals ( testadj6 ) ) ; }
tr	1	public List < MessageVO > getMessageVOs ( ) { if ( messageVOs == null ) { messageVOs = new ArrayList < MessageVO > ( ) ; } return this . messageVOs ; }
tr	8	public void incCount ( E data ) { if ( overallRoot == null ) { overallRoot = new AVLNode ( data ) ; return ; } AVLNode currentNode = ( AVLNode ) overallRoot ; while ( true ) { int cmp = comparator . compare ( data , currentNode . data ) ; if ( cmp == 0 ) { currentNode . count ++ ; return ; } else if ( cmp < 0 ) { if ( currentNode . left == null ) { currentNode . left = new AVLNode ( data , currentNode ) ; break ; } currentNode = ( AVLNode ) currentNode . left ; } else { if ( currentNode . right == null ) { currentNode . right = new AVLNode ( data , currentNode ) ; break ; } currentNode = ( AVLNode ) currentNode . right ; } } percHeightUp ( currentNode ) ; while ( currentNode != null ) { Side isImbalanced = checkImbalance ( currentNode ) ; if ( isImbalanced != Side . BALANCED ) { percHeightDown ( rotate ( currentNode , isImbalanced ) ) ; break ; } currentNode = currentNode . parent ; } }
tr	9X	public boolean isMatching ( StringBuffer word , int wordPos ) { boolean matching = true , inMulti = false , multiMatch = false ; char matchCh ; for ( int matchPos = 0 ; matchPos < match . length ; matchPos ++ ) { matchCh = match [ matchPos ] ; if ( matchCh == STARTMULTI || matchCh == ENDMULTI ) { inMulti = ! inMulti ; if ( ! inMulti ) matching = matching & multiMatch ; else multiMatch = false ; } else { if ( matchCh != word . charAt ( wordPos ) ) { if ( inMulti ) multiMatch = multiMatch | false ; else matching = false ; } else { if ( inMulti ) multiMatch = multiMatch | true ; else matching = true ; } if ( ! inMulti ) wordPos ++ ; if ( ! matching ) break ; } } if ( end && wordPos != word . length ( ) ) matching = false ; return matching ; }
tr	7	void prune ( File [ ] files ) { int size = 0 ; for ( File file : files ) { if ( file . isFile ( ) && ! file . getName ( ) . equals ( "FAT" ) ) { size += file . length ( ) ; } } int cnt = 0 ; int limit = Globals . getCacheLimit ( ) ; while ( size > limit && cnt < files . length ) { File current = files [ cnt ++ ] ; if ( current . isFile ( ) && ! current . getName ( ) . equals ( "FAT" ) ) { size -= current . length ( ) ; current . delete ( ) ; } } fileUse . set ( size ) ; updateGUIDisk ( ) ; }
tr	9X	public List < Integer > postorderTraversal ( TreeNode root ) { List < Integer > result = new ArrayList < > ( ) ; Stack < TreeNode > stack = new Stack < > ( ) ; if ( root != null ) stack . add ( root ) ; TreeNode prev = null ; while ( ! stack . isEmpty ( ) ) { root = stack . peek ( ) ; if ( prev == null || prev . left == root || prev . right == root ) { if ( root . left != null ) stack . push ( root . left ) ; else if ( root . right != null ) stack . push ( root . right ) ; } else if ( prev == root . left ) { if ( root . right != null ) stack . push ( root . right ) ; } else { result . add ( root . val ) ; stack . pop ( ) ; } prev = root ; } return result ; }
tr	0	@ Override public synchronized void removeNotify ( ) { this . applet . shutdown ( ) ; super . removeNotify ( ) ; }
tr	4	public ListNode reverseKGroup1 ( ListNode head , int k ) { ListNode curr = head ; int count = 0 ; while ( curr != null && count != k ) { curr = curr . next ; count ++ ; } if ( count == k ) { curr = reverseKGroup ( curr , k ) ; while ( count -- > 0 ) { ListNode tmp = head . next ; head . next = curr ; curr = head ; head = tmp ; } head = curr ; } return head ; }
tr	7	public void connect ( TreeLinkNode root ) { if ( root == null || root . left == null || root . right == null ) { return ; } if ( root . left != null ) { root . left . next = root . right ; } if ( root . right != null && root . next != null ) { root . right . next = root . next . left == null ? null : root . next . left ; } connect ( root . left ) ; connect ( root . right ) ; }
tr	2	private void selectElement ( MouseEvent e ) { if ( e . getButton ( ) == MouseEvent . BUTTON1 && e . getSource ( ) != table ) table . clearSelection ( ) ; }
tr	9X	@ Override public Orientation getStepOrientation ( int lineIndex ) { switch ( lineIndex ) { case 0 : case 5 : return Orientation . DOWN_LEFT ; case 1 : case 6 : return Orientation . UP_LEFT ; case 2 : case 7 : return Orientation . CENTER ; case 3 : case 8 : return Orientation . UP_RIGHT ; case 4 : case 9 : return Orientation . DOWN_RIGHT ; default : return Orientation . NONE ; } }
tr	9X	static double getMaxIntensity ( Spectrum spectrum , double intermediaryMax , double minMz , double maxMz ) { Number [ ] intValues = null ; Number [ ] mzValues = null ; List < BinaryDataArray > binDataArrayList ; List < CVParam > cvParamList ; binDataArrayList = spectrum . getBinaryDataArrayList ( ) . getBinaryDataArray ( ) ; for ( BinaryDataArray bda : binDataArrayList ) { cvParamList = bda . getCvParam ( ) ; for ( CVParam cv : cvParamList ) { if ( cv . getAccession ( ) . equals ( "MS:1000515" ) ) { intValues = bda . getBinaryDataAsNumberArray ( ) ; } if ( cv . getAccession ( ) . equals ( "MS:1000514" ) ) { mzValues = bda . getBinaryDataAsNumberArray ( ) ; } } } if ( intValues != null ) { int i ; if ( mzValues != null ) { for ( i = 0 ; i < intValues . length ; ++ i ) { if ( ( double ) mzValues [ i ] >= minMz && ( double ) mzValues [ i ] <= maxMz && ( double ) intValues [ i ] > intermediaryMax ) { intermediaryMax = ( double ) intValues [ i ] ; } } } else { for ( i = 0 ; i < intValues . length ; ++ i ) { if ( ( double ) intValues [ i ] > intermediaryMax ) { intermediaryMax = ( double ) intValues [ i ] ; } } } } return intermediaryMax ; }
tr	4	public static boolean readUsers ( DecisionLineEvent readEvent , int playableEdges ) { if ( ! isConnected ( ) ) if ( ! connect ( ) ) { System . out . println ( "Error  database connection could not be created" ) ; System . exit ( 0 ) ; } try { PreparedStatement pstmt = getConnection ( ) . prepareStatement ( "SELECT userName  userPassword  position from user where eventId=(?) ORDER BY position ASC" ) ; pstmt . setString ( 1 , readEvent . getUniqueId ( ) ) ; ResultSet myRS = pstmt . executeQuery ( ) ; User newUser ; String name , password ; int position ; while ( myRS . next ( ) ) { name = new String ( myRS . getString ( "userName" ) ) ; password = new String ( myRS . getString ( "userPassword" ) ) ; position = myRS . getInt ( "position" ) ; newUser = new User ( name , password , position , playableEdges ) ; readEvent . getUsers ( ) . add ( newUser ) ; } return true ; } catch ( SQLException e ) { System . out . println ( "error executing SQL statement!" ) ; } return false ; }
tr	5	public void updateLocation ( int id , List < Object > list ) { if ( ! handler_location . initialize ( ) ) { System . out . println ( "LocationServer : failed to initialize location handler!" ) ; return ; } int result = 0 , min_rssi = 1000 ; for ( int i = 0 ; i < list . size ( ) ; i += 2 ) { String mac = ( String ) list . get ( i ) ; LocationNode node = handler_location . getLocationNode ( mac ) ; if ( node != null ) { int rssi = ( int ) list . get ( i + 1 ) - node . rssi ; if ( rssi < min_rssi ) { min_rssi = rssi ; result = node . area ; } } } if ( result != 0 ) { handler_location . updateLocation ( id , result ) ; } handler_location . close ( ) ; }
tr	8	public void draw ( ) { Iterator < Entity > i2 = getNearbyEntities ( p . getLocation ( ) , 15 ) . iterator ( ) ; ArrayList < Block > bs = getNearbyBlocks ( p . getLocation ( ) . modify ( 0 , 0 ) , 16 ) ; for ( Block b : bs ) { b . draw ( ) ; } while ( i2 . hasNext ( ) ) { Entity toDraw = i2 . next ( ) ; toDraw . draw ( ) ; } if ( path != null ) { for ( int c = 0 ; c < path . size ( ) ; c ++ ) { if ( c == 0 ) { Engine . render ( path . get ( c ) , Material . GOLD_ORE . getImage ( ) ) ; } else if ( c == path . size ( ) - 1 ) { Engine . render ( path . get ( c ) , Material . IRON_ORE . getImage ( ) ) ; } else { Engine . render ( path . get ( c ) , Material . OBSIDIAN . getImage ( ) ) ; } } } if ( renderLight ) { Engine . addQueueItem ( new RenderQueueItem ( lightLoc , lightMap ) ) ; } if ( drawMap ) { Engine . addQueueItem ( new RenderQueueItem ( new Rectangle ( 0 , 0 , Main . getPaneWidth ( ) , Main . getPaneHeight ( ) ) , Color . blue ) ) ; Engine . addQueueItem ( new RenderQueueItem ( 0 , 0 , map ) ) ; } }
tr	5	ListNode parseList ( SeekableStringReader sr ) { sr . read ( ) ; sr . skipWhitespace ( ) ; ListNode list = new ListNode ( ) ; if ( sr . peek ( ) == ] ) { sr . read ( ) ; return list ; } list . elements = parseExprList ( sr ) ; sr . skipWhitespace ( ) ; if ( ! sr . hasMore ( ) ) throw new ParseException ( "missing ']'" ) ; if ( sr . peek ( ) ==   ) sr . read ( ) ; if ( ! sr . hasMore ( ) ) throw new ParseException ( "missing ']'" ) ; char closechar = sr . read ( ) ; if ( closechar != ] ) throw new ParseException ( "expected ']'" ) ; return list ; }
tr	1	private static void testSplit ( ) { String src = "var arrayImg = new Array();" + "arrayImg[0] = \"http://srimg1.meimei22.com/big/suren/2014-8-22/1/407899112014050822400403_640.jpg\";" + "arrayImg[0] = \"http://srimg1.meimei22.com/big/suren/2014-8-22/1/4078991120140508224023013_640.jpg\";" + "arrayImg[0] = \"http://srimg1.meimei22.com/big/suren/2014-8-22/1/407899112014050822404702_640.jpg\";" + "arrayImg[0] = \"http://srimg1.meimei22.com/big/suren/2014-8-22/1/4078991120140508224114010_640.jpg\";" + "getImgString()" ; String [ ] arrs = src . split ( ";" ) ; for ( String arr : arrs ) { printStr ( arr ) ; } }
tr	7	protected void action ( Source source , Map < String , Object > map , int i ) throws Exception { log . debug ( String . format ( "Loop [%s] step %d." , getName ( ) , i ) ) ; map . put ( "position" , i ) ; if ( source != null ) { map . put ( "value" , source . pickOne ( "value" , "base" ) ) ; } if ( getBeforeAction ( ) == null || getBeforeAction ( ) . invoke ( getContext ( ) , this , i ) ) { for ( Insert insert : getInserts ( ) ) { log . debug ( String . format ( "Loop [%s] step %d  insert %s" , getName ( ) , i , insert . getName ( ) ) ) ; insert . execute ( ) ; } for ( Loop loop : getLoops ( ) ) { log . debug ( String . format ( "Loop [%s] step %d  loop %s" , getName ( ) , i , loop . getName ( ) ) ) ; loop . execute ( ) ; } if ( getAction ( ) != null ) { getAction ( ) . invoke ( getContext ( ) , this , i ) ; } if ( getAfterAction ( ) != null ) { getAfterAction ( ) . invoke ( getContext ( ) , this , i ) ; } } }
tr	4	public void printBoard ( ) { int rowEnd = g . getBoard ( ) . numRows ; int colEnd = g . getBoard ( ) . numColumns ; System . out . println ( "{" ) ; for ( int j = 0 ; j < rowEnd ; j ++ ) { System . out . print ( "{ " ) ; for ( int i = 0 ; i < colEnd ; i ++ ) { System . out . printf ( "%1d " , g . getBoard ( ) . getGameGrid ( ) [ i ] [ j ] . getState ( ) ) ; if ( ! ( i == colEnd - 1 ) ) { System . out . print ( " " ) ; } } System . out . print ( " }" ) ; if ( ! ( j == rowEnd - 1 ) ) { System . out . println ( " " ) ; } else { System . out . println ( ) ; } } System . out . println ( "}" ) ; }
tr	2	public DecisionNode getBranch ( Game game ) { int i ; for ( i = 0 ; i < Game . NUM_GHOSTS ; i ++ ) { if ( game . isEdible ( i ) == true ) return this . trueNode ; } return this . falseNode ; }
tr	2	@ Override public boolean equals ( Object that ) { if ( that == null ) return false ; if ( that instanceof abort_result ) return this . equals ( ( abort_result ) that ) ; return false ; }
tr	7	public static void main ( String [ ] args ) { Connection conn = null ; Statement stmt = null ; try { class . forName ( "com.mysql.jdbc.Driver" ) ; conn = DriverManager . getConnection ( DB_URL , USER , PASS ) ; stmt = conn . createStatement ( ) ; String sql ; sql = "SELECT * FROM Transport" ; ResultSet rs = stmt . executeQuery ( sql ) ; while ( rs . next ( ) ) { int id = rs . getInt ( "ID" ) ; System . out . print ( "ID: " + id ) ; } rs . close ( ) ; stmt . close ( ) ; conn . close ( ) ; } catch ( SQLException se ) { se . printStackTrace ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { try { if ( stmt != null ) stmt . close ( ) ; } catch ( SQLException se2 ) { } try { if ( conn != null ) conn . close ( ) ; } catch ( SQLException se ) { se . printStackTrace ( ) ; } } }
tr	3	public void update ( Data ... records ) throws IOException { IntObjectOpenHashMap < ArrayList < Data >> bucketDataMapping = new IntObjectOpenHashMap < ArrayList < Data >> ( ) ; int bucketId ; for ( Data d : records ) { bucketId = hashFunction . getBucketId ( d . getKey ( ) ) ; if ( ! bucketDataMapping . containsKey ( bucketId ) ) { bucketDataMapping . put ( bucketId , new ArrayList < Data > ( ) ) ; } bucketDataMapping . get ( bucketId ) . add ( d ) ; } for ( IntObjectCursor < ArrayList < Data >> entry : bucketDataMapping ) { UpdateOnlySynchronizer < Data > synchronizer = new UpdateOnlySynchronizer < Data > ( gp . DATABASE_DIRECTORY + "/" + hashFunction . getFilename ( entry . key ) , gp ) ; @ SuppressWarnings ( "unchecked" ) Data [ ] toUpdate = ( Data [ ] ) entry . value . toArray ( new AbstractKVStorable [ entry . value . size ( ) ] ) ; Arrays . sort ( toUpdate , new AbstractKVStorableComparator ( ) ) ; synchronizer . upsert ( toUpdate ) ; } }
tr	0	public long getTimeToWait ( ) { return this . timeToWait ; }
tr	9X	public static void main ( String [ ] args ) { Utility . configure ( ) ; jobTrackerComm = new Communication ( Utility . JOBTRACKER . ipAddress , Utility . JOBTRACKER . port ) ; System . out . println ( "Registering on job tracker..." ) ; Message msg = new Message ( Utility . TASKTRACKERREG ) ; jobTrackerComm . sendMessage ( msg ) ; msg = jobTrackerComm . readMessage ( ) ; if ( msg . getMsgType ( ) == Utility . REGACK ) { taskTrackerID = msg . getTaskTrackerID ( ) ; System . out . println ( "Successfully registered." ) ; } while ( isRunning ) { msg = jobTrackerComm . readMessage ( ) ; if ( msg . getMsgType ( ) == Utility . NEWJOB ) { JobContext jobContext = msg . getJobContext ( ) ; String jobID = jobContext . getJobID ( ) . getID ( ) ; System . out . println ( "Receiced new job from job[" + jobID + "] tracker" ) ; if ( ! jobContexts . containsKey ( jobID ) ) { jobContexts . put ( jobID , jobContext ) ; } msg = new Message ( Utility . NEWJOBACK ) ; jobTrackerComm . sendMessage ( msg ) ; } else if ( msg . getMsgType ( ) == Utility . RUNMAPPER ) { System . out . println ( "Received RUNMAPPER command from job tracker." ) ; List < MapBasicContext > mapBasicContexts = msg . getMapContexts ( ) ; if ( mapBasicContexts . size ( ) != 0 ) { String jobID = mapBasicContexts . get ( 0 ) . getJobID ( ) . getID ( ) ; JobContext jobContext = jobContexts . get ( jobID ) ; numMappers = mapBasicContexts . size ( ) ; launchMappers ( jobContext , mapBasicContexts ) ; } } else if ( msg . getMsgType ( ) == Utility . RUNREDUCER ) { System . out . println ( "Received RUNREDUCER command from job tracker." ) ; List < ReduceBasicContext > reduceBasicContexts = msg . getReduceContexts ( ) ; if ( reduceBasicContexts . size ( ) != 0 ) { String jobID = reduceBasicContexts . get ( 0 ) . getJobID ( ) . getID ( ) ; JobContext jobContext = jobContexts . get ( jobID ) ; numReducers = reduceBasicContexts . size ( ) ; launchReducers ( jobContext , reduceBasicContexts ) ; } } else if ( msg . getMsgType ( ) == Utility . CLOSE ) { isRunning = false ; } } jobTrackerComm . close ( ) ; }
tr	0	@ Override public void execute ( ) { light . on ( ) ; }
tr	1	public static ServiceFactory getInstance ( ) { if ( instance == null ) instance = new ServiceFactory ( ) ; return instance ; }
tr	6	public String nextTo ( char delimiter ) throws JSONException { StringBuilder sb = new StringBuilder ( ) ; for ( ; ; ) { char c = this . next ( ) ; if ( c == delimiter || c == 0 || c ==  || c ==  ) { if ( c != 0 ) { this . back ( ) ; } return sb . toString ( ) . trim ( ) ; } sb . append ( c ) ; } }
tr	7	static final public void sum ( ) throws ParseException { term ( ) ; label_1 : while ( true ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case + : case MINUS : ; break ; default : jj_la1 [ 1 ] = jj_gen ; break label_1 ; } switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case + : jj_consume_token ( + ) ; break ; case MINUS : jj_consume_token ( MINUS ) ; break ; default : jj_la1 [ 2 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } term ( ) ; } }
tr	1	public void setRowCount ( int count ) { this . tableModel . setRowCount ( count ) ; rowColors . clear ( ) ; for ( int i = 0 ; i < count ; i ++ ) { rowColors . add ( getTableForeground ( ) ) ; } }
tr	9X	private Location createLocation ( IPLocation ipLoc ) { Location location = new Location ( ) ; String city = ipLoc . getArea ( ) ; String country = ipLoc . getCountry ( ) ; if ( ( city == null ) || ( city . indexOf ( "CZ88.NET" ) > - 1 ) ) { city = "" ; } location . setCountry ( country ) ; location . setProvince ( city ) ; location . setCity ( city ) ; location . setAddress ( country + city ) ; if ( ! MyStringUtil . isBlank ( location . getAddress ( ) ) ) { int provinclen = Provinces . length ; for ( int l = 0 ; l < provinclen ; l ++ ) { String province = Provinces [ l ] ; if ( location . getAddress ( ) . indexOf ( province ) != - 1 ) { location . setCountry ( "\u4E2D\u56FD" ) ; location . setProvince ( province ) ; System . out . println ( province ) ; String [ ] citys = ProvinceCityMap . get ( province ) ; if ( citys != null ) { int citylen = citys . length ; for ( int k = 0 ; k < citylen ; k ++ ) { city = citys [ k ] ; if ( location . getAddress ( ) . indexOf ( city ) != - 1 ) { location . setCity ( city ) ; break ; } } } else { location . setProvince ( "\u5176\u4ED6" ) ; location . setCity ( "\u5176\u4ED6" ) ; } break ; } } int isplen = ISPs . length ; for ( int l = 0 ; l < isplen ; l ++ ) { String isp = ISPs [ l ] ; if ( location . getAddress ( ) . indexOf ( isp ) != - 1 ) { location . setISP ( isp ) ; break ; } } } if ( MyStringUtil . isBlank ( location . getCountry ( ) ) ) { location . setCountry ( "\u5176\u4ED6" ) ; } if ( MyStringUtil . isBlank ( location . getProvince ( ) ) ) { location . setProvince ( "\u5176\u4ED6" ) ; } if ( MyStringUtil . isBlank ( location . getCity ( ) ) ) { location . setCity ( "\u5176\u4ED6" ) ; } return location ; }
tr	0	public Shader build ( ) { String vsh = _vsh . build ( ) ; String fsh = _fsh . build ( ) ; int vID = createShader ( GL20 . GL_VERTEX_SHADER , vsh ) ; int fID = createShader ( GL20 . GL_FRAGMENT_SHADER , fsh ) ; int pID = linkShader ( vID , fID ) ; return new Shader ( pID , _manager ) ; }
tr	2	public double getArea ( ) { final Punto ptInt = this . getPuntoInterior ( ) ; double area = 0 ; for ( int i = 0 ; i < this . numVertices ; i ++ ) { final Punto ptSig = ( i == this . numVertices - 1 ) ? this . vertices [ 0 ] : this . vertices [ i + 1 ] ; area += Poligono . getAreaTriangulo ( this . vertices [ i ] , ptSig , ptInt ) ; } return Math . round ( area * 1000 ) / 1000.0 ; }
tr	1	@ Override public void run ( ) { try { instance . start ( ) ; } catch ( InterruptedException e ) { System . out . println ( Thread . currentThread ( ) . getName ( ) + " interrupted" ) ; } }
tr	0	@ Override public void close ( ) throws IOException { in . close ( ) ; }
tr	0	public boolean isNull ( String key ) { return JSONObject . null . equals ( this . opt ( key ) ) ; }
tr	8	public void run ( ) { ParallelWarteClass paraWait = new ParallelWarteClass ( 10000 ) ; paraWait . start ( ) ; while ( ! ( HWaccess . readInt ( Adressen . LaufbandAusgang . ordinal ( ) ) == 1 ) && paraWait . isAlive ( ) ) { try { Thread . sleep ( 150 ) ; } catch ( InterruptedException e ) { interrupt ( ) ; } } if ( ! paraWait . isAlive ( ) ) { interrupt ( ) ; return ; } else { paraWait . interrupt ( ) ; } paraWait = new ParallelWarteClass ( 10000 ) ; paraWait . start ( ) ; while ( ! ( HWaccess . readInt ( Adressen . LaufbandAusgang . ordinal ( ) ) == 0 ) && paraWait . isAlive ( ) ) { try { Thread . sleep ( 150 ) ; } catch ( InterruptedException e ) { this . interrupt ( ) ; } } if ( ! paraWait . isAlive ( ) ) { interrupt ( ) ; } else { paraWait . interrupt ( ) ; } result = true ; }
tr	4	@ Override public Tipo validarSemantica ( ) throws Exception { Tipo izq , der ; izq = izquierdo . validarSemantica ( ) ; der = derecho . validarSemantica ( ) ; if ( izq instanceof TipoInt || der instanceof TipoFloat ) { if ( der instanceof TipoInt || der instanceof TipoFloat ) { return new TipoBooleano ( ) ; } else { throw new Exception ( "Error Semantico no se puede comparar un Tipo Int o Float con un Tipo " + der . toString ( ) ) ; } } else { throw new Exception ( "Error Semantico no se puede comparar un Tipo Int o Float con un Tipo " + der . toString ( ) ) ; } }
tr	0	@ Override public String getSchema ( ) throws SQLException { return null ; }
tr	8	protected boolean getPolyOrientation ( ) { if ( vertices . size ( ) < 3 ) return true ; int index = 0 ; IColumnVector < float > currentPoint = vertices . get ( 0 ) ; for ( int i = 1 ; i < vertices . size ( ) ; i ++ ) { if ( vertices . get ( i ) . get ( 0 , 0 ) < currentPoint . get ( 0 , 0 ) ) { currentPoint = vertices . get ( i ) ; index = i ; } else if ( vertices . get ( i ) . get ( 0 , 0 ) == currentPoint . get ( 0 , 0 ) && vertices . get ( i ) . get ( 1 , 0 ) > currentPoint . get ( 1 , 0 ) ) { currentPoint = vertices . get ( i ) ; index = i ; } } final IColumnVector < float > previousPoint = ( index == 0 ) ? vertices . get ( vertices . size ( ) - 1 ) : vertices . get ( index - 1 ) ; final IColumnVector < float > v1 = new ColumnVector ( currentPoint . get ( 0 , 0 ) - previousPoint . get ( 0 , 0 ) , currentPoint . get ( 1 , 0 ) - previousPoint . get ( 1 , 0 ) ) ; final IColumnVector < float > nextPoint = ( index == vertices . size ( ) - 1 ) ? vertices . get ( 0 ) : vertices . get ( index + 1 ) ; final float result = nextPoint . get ( 0 , 0 ) * v1 . get ( 1 , 0 ) - nextPoint . get ( 1 , 0 ) * v1 . get ( 0 , 0 ) + v1 . get ( 0 , 0 ) * previousPoint . get ( 1 , 0 ) - v1 . get ( 1 , 0 ) * previousPoint . get ( 0 , 0 ) ; return ( result <= 0 ? true : false ) ; }
tr	4	public static void main ( String [ ] args ) { JFrame frame = new JFrame ( ) ; frame . setSize ( 1500 , 1000 ) ; frame . setLocationRelativeTo ( null ) ; frame . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; frame . setVisible ( true ) ; final TaskmgrGraph graph = new TaskmgrGraph ( new TaskmgrColors ( ) ) ; new Thread ( "Memory thread" ) { @ Override public void run ( ) { while ( true ) { Runtime rt = Runtime . getRuntime ( ) ; long current = ( rt . totalMemory ( ) - rt . freeMemory ( ) ) / 1024 / 1024 ; long max = rt . totalMemory ( ) / 1024 / 1024 ; int % = ( int ) ( ( ( float ) current / ( float ) max ) * 100 ) ; graph . setMaximum ( ( int ) max ) ; graph . addValue ( ( int ) current ) ; graph . setText ( current + " mb" ) ; System . out . println ( "Current usage: " + current + "  Maximum usage: " + max + "  Percent: " + % ) ; try { Thread . sleep ( 1000 ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } } } ; new Thread ( "Random thread" ) { @ Override public void run ( ) { while ( true ) { graph . setMaximum ( 10000 ) ; int value = new Random ( ) . nextInt ( 10000 ) ; graph . addValue ( value ) ; graph . setText ( value + "" ) ; try { Thread . sleep ( 1000 ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } } } . start ( ) ; frame . add ( graph ) ; }
tr	2	@ Override public void close ( final String guiName ) { if ( ! guiThreads . get ( guiName ) . isAlive ( ) ) { return ; } running = false ; try { guiThreads . get ( guiName ) . join ( ) ; } catch ( Exception e ) { GameLog . warn ( e ) ; } }
tr	0	public double getUnnormalisedInterpolatedHeightAt ( Vec pp ) { return getInterpolatedHeightAt ( pp ) * range + min ; }
tr	1	@ Override public void update ( ) { AIHockeyist puckOwner = manager . getPuckOwner ( ) ; AIRectangle myZone = manager . getMyZone ( ) ; int currentTick = manager . getCurrentTick ( ) ; init ( ) ; for ( Map . Entry < long , AIRole > p : roles . entrySet ( ) ) { moves . put ( p . getKey ( ) , p . getValue ( ) . move ( ) ) ; } }
tr	1	public List < SchoolVO > getSchools ( ) { if ( schools == null ) { schools = new ArrayList < SchoolVO > ( ) ; } return this . schools ; }
tr	9X	public static GregorianCalendar lireDate ( String date ) { boolean ok = false ; String [ ] champsDate ; int jour = 1 ; int mois = 0 ; int an = 0 ; GregorianCalendar dateSaisie = null ; champsDate = date . split ( "/" ) ; ok = true ; if ( champsDate . length >= 1 ) { try { mois = Integer . parseInt ( champsDate [ 0 ] ) ; if ( ( mois < 1 ) || ( mois > 12 ) ) { ok = false ; } } catch ( Exception e ) { ok = false ; } } else { mois = moisCourant ( ) ; } if ( champsDate . length == 2 ) { try { an = Integer . parseInt ( champsDate [ 1 ] ) ; if ( ( an < 1900 ) || ( an > 2100 ) ) { ok = false ; } } catch ( Exception e ) { ok = false ; } } else { an = anneeCourante ( ) ; } if ( ok ) { dateSaisie = new GregorianCalendar ( an , mois - 1 , jour ) ; return dateSaisie ; } else { return null ; } }
tr	7	private void openAddMeterPanel ( ) { boolean failure = false ; String options [ ] = { "Create" , "Cancel" } ; int result = JOptionPane . showOptionDialog ( null , addMeterPanel , "Add Meter to Account " + getSelectedAccountID ( ) , JOptionPane . DEFAULT_OPTION , JOptionPane . PLAIN_MESSAGE , null , options , options [ 0 ] ) ; if ( result == 0 ) { Meter m = getMeterFromAddMeterPanel ( ) ; Account temp = getSelectedAccount ( ) ; if ( m != null ) { if ( temp instanceof ResidentialAccount ) { ResidentialAccount resAcc = ( ResidentialAccount ) temp ; if ( resAcc . getMeter ( ) != null ) { boolean overWrite = confirmResidentialAccountConflict ( ) ; if ( ! overWrite ) return ; } } else if ( temp . hasMeter ( m . getMeterID ( ) ) ) { failure = true ; } } else { failure = true ; } if ( ! failure ) { temp . addMeter ( m ) ; System . out . println ( m . getMeterID ( ) ) ; showMetersInMeterTable ( temp ) ; } else { failToCreateMeterDialog ( ) ; } } }
tr	3	private void timeButtonMouseClicked ( java . awt . event . MouseEvent evt ) { JOptionPane infoPopup = new JOptionPane ( ) ; int n = JOptionPane . showConfirmDialog ( null , "Are you sure you want to quit?" , "End game" , JOptionPane . YES_NO_OPTION ) ; Result r = new Result ( ) ; ResultContainer cont = new ResultContainer ( ) ; String s = new String ( ) ; if ( n == JOptionPane . YES_OPTION ) { s = JOptionPane . showInputDialog ( null , "Please type your name below: " , "Type your name" , JOptionPane . PLAIN_MESSAGE ) ; System . out . println ( s ) ; if ( s != null ) r . setName ( s ) ; if ( this . empire . getTotalSeconds ( ) > 0 ) r . setSeconds ( this . empire . getTotalSeconds ( ) ) ; infoPopup . setVisible ( false ) ; cont . addAndSerialize ( r ) ; System . exit ( 0 ) ; } }
tr	2	public static String join ( Object [ ] ar , String delimiter ) { StringBuffer buffer = new StringBuffer ( ) ; for ( Object obj : ar ) { buffer . append ( obj ) ; buffer . append ( delimiter ) ; } if ( ar . length > 0 ) buffer . deleteCharAt ( buffer . length ( ) - 1 ) ; return buffer . toString ( ) ; }
tr	0	@ Override public TileEntity getTileEntity ( Tile parent ) { return new TileDoorEntity ( parent ) ; }
tr	1	public static Image [ ] loadStills ( int numSprites , String imgPath ) { Image [ ] stills = new Image [ numSprites ] ; String path = Item . charPath + imgPath ; for ( int i = 0 ; i < numSprites ; i ++ ) { stills [ i ] = Item . loadImage ( path + i + "/0.png" ) ; } return stills ; }
tr	1	public int getInt ( String propertyName , int defaultValue ) { CcsProperty property = getProperty ( propertyName ) ; int result = property == null ? defaultValue : Integer . parseInt ( property . getValue ( ) ) ; return result ; }
tr	2	@ Override public int hashCode ( ) { int result = key != null ? key . hashCode ( ) : 0 ; result = 31 * result + ( value != null ? value . hashCode ( ) : 0 ) ; return result ; }
tr	8	public String getLastLine ( ) { try ( RandomAccessFile file = new RandomAccessFile ( f , "r" ) ) { long index , length ; length = file . length ( ) ; index = length - 1 ; int ch = 0 ; while ( ch != 30 && index > 0 ) { file . seek ( index -- ) ; ch = ( file . read ( ) ) ; } if ( index == 0 ) { return null ; } file . seek ( index -- ) ; ch = ( file . read ( ) ) ; while ( ch != 30 && index > 0 ) { file . seek ( index -- ) ; ch = ( file . read ( ) ) ; } file . seek ( index ++ ) ; StringBuilder sb = new StringBuilder ( ) ; sb . append ( in . readUTF ( ) ) ; sb . append ( "\t" ) ; in . readChar ( ) ; sb . append ( in . readLong ( ) ) ; sb . append ( "\t" ) ; in . readChar ( ) ; sb . append ( df . format ( new Date ( in . readLong ( ) ) ) ) ; sb . append ( "\t" ) ; in . readChar ( ) ; sb . append ( TimeConvert . millisToDays ( in . readLong ( ) ) ) ; sb . append ( "\t" ) ; in . readChar ( ) ; sb . append ( in . readDouble ( ) ) ; sb . append ( "\t" ) ; in . readChar ( ) ; sb . append ( in . readDouble ( ) ) ; sb . append ( "\t" ) ; in . readChar ( ) ; sb . append ( in . readDouble ( ) ) ; sb . append ( "\t" ) ; in . readChar ( ) ; sb . append ( in . readDouble ( ) ) ; sb . append ( "\t" ) ; in . readChar ( ) ; String code = in . readUTF ( ) ; sb . append ( code ) ; if ( code == "S" ) { sb . append ( in . readUTF ( ) ) ; } sb . append ( "\t" ) ; in . readChar ( ) ; sb . append ( in . readBoolean ( ) ) ; sb . append ( "\t" ) ; in . readChar ( ) ; sb . append ( in . readDouble ( ) ) ; sb . append ( "\t" ) ; in . readChar ( ) ; sb . append ( in . readDouble ( ) ) ; sb . append ( "\t" ) ; in . readChar ( ) ; sb . append ( in . readDouble ( ) ) ; sb . append ( "\t" ) ; in . readChar ( ) ; sb . append ( in . readDouble ( ) ) ; sb . append ( "\t" ) ; in . readChar ( ) ; sb . append ( in . readDouble ( ) ) ; sb . append ( "\t" ) ; in . readChar ( ) ; sb . append ( in . readDouble ( ) ) ; sb . append ( "\t" ) ; in . readChar ( ) ; sb . append ( in . readDouble ( ) ) ; sb . append ( "\t" ) ; in . readChar ( ) ; return sb . toString ( ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return null ; }
tr	8	@ Override protected void fillSamples ( List < Vector2 > samples , int numSamples ) { int n = ( int ) Math . sqrt ( ( float ) numSamples ) ; if ( n * n != numSamples ) { throw new RaytraceException ( "Number of samples are %d but must be a perfect square like %d!" , numSamples , n * n ) ; } float subcellWidth = 1.0f / ( ( float ) numSamples ) ; for ( int j = 0 ; j < numSamples ; j ++ ) samples . add ( new Vector2 ( ) ) ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) { samples . get ( i * n + j ) . setX ( ( i * n + j ) * subcellWidth + rndFloat ( 0.0f , subcellWidth ) ) ; samples . get ( i * n + j ) . setY ( ( j * n + i ) * subcellWidth + rndFloat ( 0.0f , subcellWidth ) ) ; } for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) { int k = rndInt ( j , n - 1 ) ; float t = samples . get ( i * n + j ) . getX ( ) ; samples . get ( i * n + j ) . setX ( samples . get ( i * n + k ) . getX ( ) ) ; samples . get ( i * n + k ) . setX ( t ) ; } for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) { int k = rndInt ( j , n - 1 ) ; float t = samples . get ( i * n + j ) . getY ( ) ; samples . get ( i * n + j ) . setY ( samples . get ( i * n + k ) . getY ( ) ) ; samples . get ( i * n + k ) . setY ( t ) ; } }
tr	7	@ Override public short [ ] getShortData ( ) { if ( ptr != 0 ) { return null ; } else { if ( isConstant ( ) ) { if ( length > getMaxSizeOf32bitArray ( ) ) return null ; short [ ] out = new short [ ( int ) length ] ; short elem = ( short ) ( data [ 0 ] != null ? data [ 0 ] . length ( ) : 0 ) ; for ( int i = 0 ; i < length ; i ++ ) { out [ i ] = elem ; } return out ; } else { short [ ] res = new short [ ( int ) length ] ; for ( int i = 0 ; i < length ; i ++ ) { res [ i ] = ( short ) ( data [ i ] != null ? data [ i ] . length ( ) : 0 ) ; } return res ; } } }
tr	2	private String readStream ( Process proc , InputStream in ) { StringBuffer ret = new StringBuffer ( ) ; try { int n = in . read ( ) ; while ( n != - 1 ) { ret . append ( ( char ) n ) ; n = in . read ( ) ; } } catch ( IOException ex ) { Logger . getLogger ( ThirdIdea . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } return ret . toString ( ) ; }
tr	5	@ Override public boolean onRequest ( HttpRequest request , HttpResponse response ) throws Exception { String filePath = request . getRequestedFilePath ( ) ; if ( urlToMapTo != null ) { if ( ! filePath . startsWith ( urlToMapTo ) ) return false ; filePath = filePath . substring ( urlToMapTo . length ( ) ) ; } File file = new File ( directory , filePath ) ; if ( ! file . isFile ( ) || ! file . canRead ( ) || ! file . getAbsolutePath ( ) . startsWith ( directory . getAbsolutePath ( ) ) ) return false ; IOFileChannelInputBuffer buffer = new IOFileChannelInputBuffer ( new FileInputStream ( file ) . getChannel ( ) ) ; response . setHeader ( "content-type" , mimeNameMap . getContentTypeFor ( file . getAbsolutePath ( ) ) ) ; response . setBodyBuffer ( buffer ) ; buffer . free ( ) ; return true ; }
tr	0	public static void showNewTimeWindow ( ) { timeBo . showNewTime ( ) ; }
tr	9X	public static String getDescription ( short value ) { String description = "Undefined" ; switch ( value ) { case FVB : description = "FVB" ; break ; case RVB : description = "RVB" ; break ; case RPB : description = "RPB" ; break ; case FPB : description = "FPB" ; break ; case FVW : description = "FVW" ; break ; case RVW : description = "RVW" ; break ; case RPW : description = "RPW" ; break ; case FPW : description = "FPW" ; break ; case static : description = "Static" ; break ; case OTHER : description = "Other" ; break ; } return description ; }
