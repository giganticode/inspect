tr	9	private String getSelect ( List < String > tables , Map < String , Object > params ) { if ( tables . size ( ) < 1 ) { return "ERROR: The tables list is empty" ; } StringBuffer sql = new StringBuffer ( ) ; sql . append ( "SELECT " ) ; for ( int i = 0 ; i < tables . size ( ) ; i ++ ) { String table = tables . get ( i ) ; sql . append ( table . toLowerCase ( ) ) ; if ( i < tables . size ( ) - 1 ) { sql . append ( "  " ) ; } } sql . append ( " FROM " ) ; for ( int i = 0 ; i < tables . size ( ) ; i ++ ) { String table = tables . get ( i ) ; sql . append ( table ) ; sql . append ( " " ) ; sql . append ( table . toLowerCase ( ) ) ; if ( i < tables . size ( ) - 1 ) { sql . append ( "  " ) ; } } if ( params . isEmpty ( ) ) { return sql . toString ( ) ; } sql . append ( " WHERE " ) ; int i = 0 ; for ( String paramName : params . keySet ( ) ) { Object paramValue = params . get ( paramName ) ; sql . append ( paramName ) ; sql . append ( "=" ) ; if ( paramValue instanceof java . sql . Date ) { sql . append ( "'" ) ; sql . append ( paramValue ) ; sql . append ( "'" ) ; } else if ( paramValue instanceof String ) { sql . append ( "\"" ) ; sql . append ( paramValue ) ; sql . append ( "\"" ) ; } else { sql . append ( paramValue ) ; } if ( i < params . size ( ) - 1 ) { sql . append ( " AND " ) ; } i ++ ; } return sql . toString ( ) ; }
tr	8	private static String fetch ( String artistName , String songName ) { byte [ ] utf8Bytes = null ; String lyricsText = "" ; try { URL lyricsPage = new URL ( constructURL ( artistName , songName ) ) ; BufferedReader in = new BufferedReader ( new InputStreamReader ( lyricsPage . openStream ( ) ) ) ; String inputLine ; boolean lastLineHasNotBeenPrinted = true , inputHasBegun = false ; loop : while ( ( inputLine = in . readLine ( ) ) != null && lastLineHasNotBeenPrinted ) { if ( inputHasBegun && lastLineHasNotBeenPrinted ) { if ( ! inputLine . contains ( "<br />" ) ) break ; inputLine = inputLine . replace ( "<br />" , "" ) ; inputLine = inputLine . replaceAll ( "<.{1 3}>" , "" ) ; inputLine += "\n" ; utf8Bytes = inputLine . getBytes ( ) ; inputLine = new String ( utf8Bytes , StandardCharsets . UTF_8 ) ; lyricsText += inputLine ; continue ; } if ( inputLine . contains ( "<!-- start of lyrics -->" ) ) { inputHasBegun = true ; continue ; } } in . close ( ) ; } catch ( Exception e ) { return "[lyrics unavailable]" ; } if ( lyricsText . equals ( null ) ) lyricsText = "No Lyrics Found.\n" ; return lyricsText ; }
tr	4	public Cachable fetch ( CacheToken token ) { if ( ! cacheTokensLRUMap . containsKey ( token . getCacheID ( ) ) ) { cacheTokensLRUMap . put ( token . getCacheID ( ) , token ) ; } switch ( token . getOrigin ( ) ) { case DB : return DatabaseOperations . fetchFromCache ( token . getCacheID ( ) ) ; case MEMORY : return cached . get ( token . getCacheID ( ) ) ; case new : default : return null ; } }
tr	3	public void removeConnectionFromChans ( Connection connection ) { List < Chan > emptyChans = new ArrayList < Chan > ( ) ; for ( Chan chan : chans . values ( ) ) { chan . getConnections ( ) . remove ( connection ) ; if ( chan . getConnections ( ) . size ( ) == 0 ) { emptyChans . add ( chan ) ; } } for ( Chan rmChan : emptyChans ) { chans . remove ( rmChan ) ; } }
tr	7	@ Override public Vocabulary parse ( Expression expression ) throws ExpressionParserException { Vocabulary vocabulary = new Vocabulary ( ) ; setDefaults ( vocabulary ) ; List < Expression > nested = getNested ( expression ) ; for ( Expression exp : nested ) { String identifier = exp . getIdentifier ( ) ; if ( "verbs" . equals ( identifier ) ) { parseVerbs ( vocabulary , exp ) ; } else if ( "articles" . equals ( identifier ) ) { vocabulary . addArticles ( getList ( exp ) ) ; } else if ( "prepositions" . equals ( identifier ) ) { vocabulary . addPrepositions ( getList ( exp ) ) ; } else if ( "messages" . equals ( identifier ) ) { parseMessages ( vocabulary , exp ) ; } else if ( "magicPhrases" . equals ( identifier ) ) { parseMagicPhrases ( vocabulary , exp ) ; } else if ( "specialEntities" . equals ( identifier ) ) { parseSpecialEntities ( vocabulary , exp ) ; } else { throw new ExpressionParserException ( identifier + " is not valid within expression." , exp ) ; } } return vocabulary ; }
tr	5	private final char med3 ( char a , char b , char c ) { char m ; if ( a < b ) { m = b <= c ? b : a < c ? c : a ; } else { m = c >= a ? a : c > b ? c : b ; } return m ; }
tr	2	public ArrayList < Tile > getAdjacentTiles ( Tile tile ) { ArrayList < Tile > adjacentTiles = new ArrayList < Tile > ( ) ; for ( Direction direction : Direction . values ( ) ) { Tile nextTile = getTile ( tile . getGridX ( ) + direction . getXOffset ( ) , tile . getGridY ( ) + direction . getYOffset ( ) ) ; if ( nextTile != null ) { adjacentTiles . add ( nextTile ) ; } } return adjacentTiles ; }
tr	4	@ Override public boolean equals ( Object otherObject ) { if ( this == otherObject ) return true ; if ( null == otherObject ) return false ; if ( getClass ( ) != otherObject . getClass ( ) ) return false ; StringsList other = ( StringsList ) otherObject ; return super . equals ( other ) && count == other . count ; }
tr	8	private void emitLoadOrStore ( int opcode , int a , Adda address ) throws Exception { Value v = address . getArg1 ( ) ; int b , c ; if ( v instanceof Immediate ) { c = ( ( Immediate ) v ) . getValue ( ) ; opcode = opcode - 1 ; v = address . getArg2 ( ) ; if ( v . equals ( Type . getGBP ( ) ) ) { b = gbp ; } else if ( v . equals ( Type . getFP ( ) ) ) { b = fp ; } else { b = location2 ( v ) ; } } else { if ( v . equals ( Type . getGBP ( ) ) ) { b = gbp ; } else if ( v . equals ( Type . getFP ( ) ) ) { b = fp ; } else { b = location2 ( v ) ; } v = address . getArg2 ( ) ; if ( v instanceof Immediate ) { c = ( ( Immediate ) v ) . getValue ( ) ; opcode = opcode - 1 ; } else if ( v . equals ( Type . getGBP ( ) ) ) { c = gbp ; } else if ( v . equals ( Type . getFP ( ) ) ) { c = fp ; } else { c = location2 ( v ) ; } } emit ( DLX . assemble ( opcode , a , b , c ) ) ; }
tr	3	@ Override protected void onButtonReleased ( GuiButton button ) { if ( button . id == 0 ) { this . parent . setBoard ( this . board ) ; GuiScreen . setGui ( this . parent ) ; } else if ( button . id == 1 ) { this . selectPage ( this . page - 1 ) ; } else if ( button . id == 2 ) { this . selectPage ( this . page + 1 ) ; } else { this . select ( button . id - 3 ) ; } }
tr	7	@ Override public void putChar ( char c ) throws ParsingException { switch ( c ) { case Characters . SPACE : context . putSpace ( ) ; break ; case Characters . SEPARATOR : context . putSeparator ( ) ; break ; case Characters . END : context . putEnd ( ) ; break ; case Characters . PARAMETER : context . putParameter ( ) ; break ; case Characters . SUB_ID : context . putSubId ( ) ; break ; case Characters . TAB : context . putTab ( ) ; break ; case Characters . NEWLINE : context . putNewLine ( ) ; ++ rowNum ; colNum = 0 ; break ; default : context . putChar ( c ) ; break ; } postProcess ( c ) ; }
tr	2	public DecisionNode getBranch ( Game game ) { int i ; for ( i = 0 ; i < Game . NUM_GHOSTS ; i ++ ) { if ( game . isEdible ( i ) == true ) return this . trueNode ; } return this . falseNode ; }
tr	7	private static int equivCompare ( Object key1 , Object val1 , Object key2 , Object val2 ) { if ( key1 instanceof EquivalentMap ) { ArrayList < Entry > al1 = ( ( EquivalentMap ) key1 ) . contents ; if ( key2 instanceof EquivalentMap ) { ArrayList < Entry > al2 = ( ( EquivalentMap ) key2 ) . contents ; int siz1 = al1 . size ( ) , siz2 = al2 . size ( ) ; if ( siz1 < siz2 ) return 1 ; else if ( siz1 > siz2 ) return - 1 ; else { FTreeSet < Object > vals1 = new FTreeSet < Object > ( ) ; FTreeSet < Object > vals2 = new FTreeSet < Object > ( ) ; for ( int i = 0 ; i < siz1 ; ++ i ) vals1 = vals1 . with ( al1 . get ( i ) . value ) ; for ( int i = 0 ; i < siz2 ; ++ i ) vals2 = vals2 . with ( al2 . get ( i ) . value ) ; return vals1 . compareTo ( vals2 ) ; } } else return - 1 ; } else if ( key2 instanceof EquivalentMap ) return 1 ; else return ( ( Comparable < Object > ) val1 ) . compareTo ( ( Comparable < Object > ) val2 ) ; }
tr	7	private void updatePermissions ( ) { bukkitPermissions = new LinkedHashMap < String , Permission > ( ) ; if ( subgroups == null ) { subgroups = new ArrayList < String > ( ) ; } if ( ! permissions . containsKey ( Config . getDefaultWorld ( ) ) ) { Map < String , boolean > children = new LinkedHashMap < String , boolean > ( ) ; for ( String subgroup : subgroups ) { children . put ( "droxperms.meta.group." + subgroup + "." + Config . getDefaultWorld ( ) , true ) ; } children . put ( "droxperms.meta.group." + name , true ) ; Permission permission = new Permission ( "droxperms.meta.group." + name + "." + Config . getDefaultWorld ( ) , "Group-Permissions for group " + name + " on world " + Config . getDefaultWorld ( ) , PermissionDefault . false , children ) ; Bukkit . getPluginManager ( ) . removePermission ( permission ) ; Bukkit . getPluginManager ( ) . addPermission ( permission ) ; bukkitPermissions . put ( Config . getDefaultWorld ( ) , permission ) ; } for ( String world : Config . getWorlds ( ) ) { Map < String , boolean > children = new LinkedHashMap < String , boolean > ( ) ; for ( String subgroup : subgroups ) { children . put ( "droxperms.meta.group." + subgroup + "." + world , true ) ; } children . put ( "droxperms.meta.group." + name , true ) ; if ( permissions . get ( world ) != null ) { children . putAll ( permissions . get ( world ) ) ; } Permission permission = new Permission ( "droxperms.meta.group." + name + "." + world , "Group-Permissions for group " + name + " on world " + world , PermissionDefault . false , children ) ; Bukkit . getPluginManager ( ) . removePermission ( permission ) ; Bukkit . getPluginManager ( ) . addPermission ( permission ) ; bukkitPermissions . put ( world , permission ) ; } Map < String , boolean > children = new LinkedHashMap < String , boolean > ( ) ; for ( String subgroup : subgroups ) { children . put ( "droxperms.meta.group." + subgroup , true ) ; } children . putAll ( globalPermissions ) ; Permission permission = new Permission ( "droxperms.meta.group." + name , "Group-Permissions for group " + name , PermissionDefault . false , children ) ; Bukkit . getPluginManager ( ) . removePermission ( permission ) ; Bukkit . getPluginManager ( ) . addPermission ( permission ) ; }
tr	3	@ Override protected boolean doDecode ( IoSession session , ByteBuffer in , ProtocolDecoderOutput out ) throws Exception { if ( in . remaining ( ) >= MessageHeader . HEADER_BYTES_SIZE + Body . BODY_BYTES_SIZE ) { int start = in . position ( ) ; MessageHeader header = MessageHeader . tryDecodeHeader ( SGIP_BIND_RESP , in ) ; if ( header == null ) { in . position ( start ) ; return false ; } Body body = tryDecodeBody ( in ) ; if ( body == null ) { in . position ( start ) ; return false ; } BindResponse bindRequest = new BindResponse ( header , body ) ; out . write ( bindRequest ) ; return true ; } else { return false ; } }
tr	8	@ Override public void startMatching ( ParseContext ctx , int start , ParseResults results ) { final Document input = ctx . getDocument ( ) ; if ( input . length ( ) <= start ) { results . setError ( "Unexpected end of input" ) ; return ; } char startChar = input . charAt ( start ) ; if ( startChar != " && startChar != ' ) { results . setError ( "Excepted beginning quote" ) ; return ; } char escapeChar = ( startChar == " ) ? ' : " ; int pos = input . indexOf ( startChar , start + 1 ) ; while ( pos > 0 && input . charAt ( pos - 1 ) == escapeChar ) pos = input . indexOf ( startChar , pos + 1 ) ; if ( pos == - 1 || input . charAt ( pos ) != startChar ) { results . setError ( "Excepted end of quote" , input . length ( ) ) ; return ; } pos ++ ; results . addMatch ( pos ) ; }
tr	0	private void visitEdge ( Edge e ) { System . out . println ( "Visiting edge " + e ) ; }
tr	1	public boolean isDecoupler ( ) { return getModule ( "ModuleDecouple" ) != null || getModule ( "ModuleAnchoredDecoupler" ) != null ; }
tr	3	public FHashMap < Key , Val > less ( Key key ) { Object t = less ( tree , key , hashCode ( key ) ) ; if ( t == tree ) return this ; else if ( t == null && dflt == null ) return emptyMap ( ) ; else return new FHashMap < Key , Val > ( t , dflt ) ; }
tr	6	private void printUpgradeTowerDef ( Graphics g ) { gui . print ( g , selectedTowerDef . name , TEXT_HEIGHT_1 ) ; gui . print ( g , "upgrade cost: " + selectedTowerDef . cost , TEXT_HEIGHT_1 ) ; gui . print ( g , "level  : " + selectedTowerDef . level , TEXT_HEIGHT_1 ) ; gui . print ( g , "damage : " + getComparingString ( selectedTowerDef . damage , selectedTower . def . damage ) , TEXT_HEIGHT_1 ) ; gui . print ( g , "area   : " + getComparingString ( selectedTowerDef . damageRadius , selectedTower . def . damageRadius ) , TEXT_HEIGHT_1 ) ; gui . print ( g , "range  : " + getComparingString ( selectedTowerDef . range , selectedTower . def . range ) , TEXT_HEIGHT_1 ) ; gui . print ( g , "reload : " + getComparingString ( selectedTowerDef . reloadTime , selectedTower . def . reloadTime ) , TEXT_HEIGHT_1 ) ; if ( selectedTower . def . instantEffects . length + selectedTower . def . timedEffects . length > 0 ) { gui . print ( g , "old effects:" , TEXT_HEIGHT_1 ) ; for ( InstantEffect e : selectedTower . def . instantEffects ) { gui . print ( g , " " + e , TEXT_HEIGHT_1 ) ; } for ( TimedEffectDef e : selectedTower . def . timedEffects ) { gui . print ( g , " " + e , TEXT_HEIGHT_1 ) ; } } if ( selectedTowerDef . instantEffects . length + selectedTowerDef . timedEffects . length > 0 ) { gui . print ( g , "new effects:" , TEXT_HEIGHT_1 ) ; for ( InstantEffect e : selectedTowerDef . instantEffects ) { gui . print ( g , " " + e , TEXT_HEIGHT_1 ) ; } for ( TimedEffectDef e : selectedTowerDef . timedEffects ) { gui . print ( g , " " + e , TEXT_HEIGHT_1 ) ; } } }
tr	5	public PrimitiveHashMap ( int initialCapacity , final float loadFactor ) { if ( initialCapacity < 0 ) { throw new IllegalArgumentException ( "Illegal initial capacity: " + initialCapacity ) ; } if ( initialCapacity > MAXIMUM_CAPACITY ) { initialCapacity = MAXIMUM_CAPACITY ; } if ( loadFactor <= 0 || float . isNaN ( loadFactor ) ) { throw new IllegalArgumentException ( "Illegal load factor: " + loadFactor ) ; } int capacity = 1 ; while ( capacity < initialCapacity ) { capacity <<= 1 ; } this . loadFactor = loadFactor ; this . threshold = ( int ) ( capacity * loadFactor ) ; this . table = new Entry [ capacity ] ; this . tableSizeMinusOne = capacity - 1 ; }
tr	0	public LogException ( ) { super ( ) ; }
tr	0	@ Test public void breadthFirstEmpty ( ) { final Iterable < String > traverser = Traversals . breadthFirst ( "A" , adjacencyFor ( empty ) ) ; assertTraversalContains ( traverser , "A" ) ; }
tr	4	public static ArrayList < String > getCluster ( String token ) { if ( singleton == null ) { singleton = new BrownFeaturizer ( ) ; singleton . init ( new Model ( ) ) ; } ArrayList < String > list = new ArrayList < String > ( ) ; String cluster = singleton . mappingS . get ( token ) ; if ( cluster == null ) { cluster = "NONE" ; } else { for ( int len : LEN ) { if ( cluster . length ( ) >= len ) { String pf = cluster . substring ( 0 , len ) ; list . add ( "CLUST_" + len + "_" + pf ) ; } } list . add ( "CLUST_ALL_" + cluster ) ; } return list ; }
tr	7	public void Solve ( ) { ArrayList < HashMap < String , List < String >>> polygonals = new ArrayList < HashMap < String , List < String >>> ( ) ; for ( int i = 0 ; i < 6 ; i ++ ) { polygonals . add ( new HashMap < String , List < String >> ( ) ) ; } int n = 1 ; int minValue = 0 ; while ( minValue < _max ) { int triangle = Triangle ( n ) ; CheckAndAdd ( triangle , polygonals . get ( 0 ) ) ; minValue = triangle ; int square = Square ( n ) ; CheckAndAdd ( square , polygonals . get ( 1 ) ) ; minValue = Math . min ( minValue , square ) ; int pentagonal = Pentagonal ( n ) ; CheckAndAdd ( pentagonal , polygonals . get ( 2 ) ) ; minValue = Math . min ( minValue , pentagonal ) ; int hexagonal = Hexagonal ( n ) ; CheckAndAdd ( hexagonal , polygonals . get ( 3 ) ) ; minValue = Math . min ( minValue , hexagonal ) ; int heptagonal = Heptagonal ( n ) ; CheckAndAdd ( heptagonal , polygonals . get ( 4 ) ) ; minValue = Math . min ( minValue , heptagonal ) ; int octagonal = Octagonal ( n ) ; CheckAndAdd ( octagonal , polygonals . get ( 5 ) ) ; minValue = Math . min ( minValue , octagonal ) ; n ++ ; } System . out . println ( "Initialization complete" ) ; for ( int i = 0 ; i < polygonals . size ( ) ; i ++ ) { System . out . println ( "Size for polygonal " + i + "= " + polygonals . get ( i ) . size ( ) ) ; } System . out . println ( ) ; ArrayList < HashMap < String , List < String >>> list = new ArrayList < HashMap < String , List < String >>> ( polygonals ) ; list . remove ( 0 ) ; for ( Iterator < Map . Entry < String , List < String >>> it = polygonals . get ( 0 ) . entrySet ( ) . iterator ( ) ; it . hasNext ( ) ; ) { Map . Entry < String , List < String >> entry = it . next ( ) ; for ( Iterator < String > it1 = entry . getValue ( ) . iterator ( ) ; it1 . hasNext ( ) ; ) { String n1 = it1 . next ( ) ; System . out . println ( "Processing n1=" + n1 ) ; ArrayList < String > initials = new ArrayList < String > ( ) ; initials . add ( n1 ) ; List < String > result = DoProcess ( initials , list ) ; if ( result != null ) { System . out . print ( "Result= " ) ; int sum = 0 ; for ( int i = 0 ; i < result . size ( ) ; i ++ ) { System . out . print ( result . get ( i ) + "  " ) ; sum += Integer . valueOf ( result . get ( i ) ) ; } System . out . println ( "Sum= " + sum ) ; return ; } } } }
tr	6	public static void flatten ( TreeNode root ) { if ( root == null ) { return ; } Queue < TreeNode > currentLevel = new LinkedList < TreeNode > ( ) ; TreeNode newNode = new TreeNode ( root . val ) ; TreeNode head = newNode ; TreeNode empty = new TreeNode ( 0 ) ; currentLevel . add ( root ) ; while ( ! currentLevel . isEmpty ( ) ) { Queue < TreeNode > nextLevel = new LinkedList < TreeNode > ( ) ; while ( ! currentLevel . isEmpty ( ) ) { TreeNode node = currentLevel . poll ( ) ; if ( newNode . right != null ) { newNode = newNode . right ; } newNode . left = null ; newNode . right = node ; if ( node . left != null ) nextLevel . add ( node . left ) ; if ( node . right != null ) nextLevel . add ( node . right ) ; } currentLevel = nextLevel ; } root = head . right ; }
tr	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( GUI_ModificarUsuario . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( GUI_ModificarUsuario . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( GUI_ModificarUsuario . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( GUI_ModificarUsuario . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { new GUI_ModificarUsuario ( ) . setVisible ( true ) ; } } ) ; }
tr	5	public int read ( byte [ ] paramArrayOfByte , int paramInt1 , int paramInt2 ) throws IOException { if ( isClosed ) { throw new IOException ( "stream closed" ) ; } if ( ( paramInt1 | paramInt2 | paramInt1 + paramInt2 | paramArrayOfByte . length - ( paramInt1 + paramInt2 ) ) < 0 ) { throw new IndexOutOfBoundsException ( ) ; } if ( paramInt2 == 0 ) { return 0 ; } if ( uncompressed_offset == uncompressed_size ) fill_buffer ( ) ; if ( uncompressed_offset == uncompressed_size ) { return - 1 ; } int i = Math . min ( paramInt2 , uncompressed_size - uncompressed_offset ) ; System . arraycopy ( uncompressed_buffer , uncompressed_offset , paramArrayOfByte , paramInt1 , i ) ; uncompressed_offset += i ; return i ; }
tr	3	public static Node reverseK ( Node head , int k ) { Node current = head ; Node next = null ; Node prev = null ; int count = 0 ; while ( current != null && count < k ) { next = current . getNext ( ) ; current . setNext ( prev ) ; prev = current ; current = next ; count ++ ; } if ( next != null ) { head . setNext ( reverseK ( next , k ) ) ; } return prev ; }
tr	9	public void processMousePress ( int x , int y ) { if ( state == PoseurState . CREATE_SHAPE_STATE ) { selectedShape = null ; } Rectangle2D poseArea = zoomableCanvasState . getPoseArea ( ) ; float zoomLevel = zoomableCanvasState . getZoomLevel ( ) ; int poseSpaceX = ( int ) ( ( x - poseArea . getX ( ) ) / zoomLevel ) ; int poseSpaceY = ( int ) ( ( y - poseArea . getY ( ) ) / zoomLevel ) ; lastMouseDraggedX = x ; lastMouseDraggedY = y ; if ( ( poseSpaceX < 0 ) || ( poseSpaceY < 0 ) || ( poseSpaceX > poseArea . getWidth ( ) ) || ( poseSpaceY > poseArea . getHeight ( ) ) ) { return ; } if ( state == PoseurState . SELECT_SHAPE_STATE || state == PoseurState . SHAPE_SELECTED_STATE ) { Iterator < PoseurShape > it = pose . getShapesIterator ( ) ; PoseurShape sh ; while ( it . hasNext ( ) ) { sh = it . next ( ) ; if ( sh . containsPoint ( new Point ( poseSpaceX , poseSpaceY ) ) ) { selectedShape = sh ; setState ( PoseurState . SHAPE_SELECTED_STATE ) ; } } } if ( state == PoseurState . SHAPE_SELECTED_STATE ) { if ( selectedShape . containsPoint ( new Point ( poseSpaceX , poseSpaceY ) ) ) { setState ( PoseurState . DRAG_SHAPE_STATE ) ; } } if ( state == PoseurState . CREATE_SHAPE_STATE ) { if ( shapeInProgressType == PoseurShapeType . RECTANGLE ) { shapeInProgress = PoseurRectangle . factoryBuildRectangle ( poseSpaceX , poseSpaceY ) ; } if ( shapeInProgressType == PoseurShapeType . ELLIPSE ) { shapeInProgress = PoseurEllipse . factoryBuildEllipse ( poseSpaceX , poseSpaceY ) ; } if ( shapeInProgressType == PoseurShapeType . LINE ) { shapeInProgress = PoseurLine . factoryBuildLine ( poseSpaceX , poseSpaceY ) ; } setState ( PoseurState . COMPLETE_SHAPE_STATE ) ; } }
tr	4	private QueryMapHelper ( ) { Properties p = new Properties ( ) ; URL url = null ; String filePath = "dq.properties" ; File file = new File ( filePath ) ; if ( file . exists ( ) ) { try { url = file . toURI ( ) . toURL ( ) ; } catch ( MalformedURLException e ) { e . printStackTrace ( ) ; return ; } } else { url = this . getClass ( ) . getClassLoader ( ) . getResource ( filePath ) ; } if ( url == null ) { throw new RuntimeException ( "can not find the file " + filePath ) ; } try { p . load ( url . openStream ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; return ; } loadFiles ( p ) ; }
tr	5	public static String getPrefix ( final String name ) { try { String s = "" ; if ( MonsterIRC . getHookManager ( ) != null ) { if ( MonsterIRC . getHookManager ( ) . getChatHook ( ) != null ) { if ( MonsterIRC . getHookManager ( ) . getChatHook ( ) . isEnabled ( ) ) { if ( MonsterIRC . getHookManager ( ) . getChatHook ( ) . getPlayerPrefix ( "" , name ) != null ) { s = MonsterIRC . getHookManager ( ) . getChatHook ( ) . getPlayerPrefix ( "" , name ) ; } } } } return s ; } catch ( final Exception e ) { return "" ; } }
tr	3	public void write ( Kml kml ) throws KmlException { kml . println ( "<Orientation" + getIdAndTargetIdFormatted ( kml ) + ">" , 1 ) ; if ( heading != null ) kml . println ( "<heading>" + heading + "</heading>" ) ; if ( tilt != null ) kml . println ( "<tilt>" + tilt + "</tilt>" ) ; if ( roll != null ) kml . println ( "<roll>" + roll + "</roll>" ) ; kml . println ( - 1 , "</Orientation>" ) ; }
tr	8	@ Override public void beginContact ( Contact c ) { Fixture a = c . m_fixtureA ; Fixture b = c . m_fixtureB ; if ( a . getUserData ( ) != null && a . getUserData ( ) . equals ( FOOT_SENSOR ) ) { } if ( a . m_isSensor && a . m_userData != null && a . getUserData ( ) . equals ( FOOT_SENSOR ) ) { LivingEntity e = ( LivingEntity ) a . getBody ( ) . getUserData ( ) ; e . setFootContacts ( e . getFootContacts ( ) + 1 ) ; } if ( b . m_isSensor && b . m_userData != null && b . m_userData . equals ( FOOT_SENSOR ) ) { LivingEntity e = ( LivingEntity ) b . getBody ( ) . getUserData ( ) ; e . setFootContacts ( e . getFootContacts ( ) + 1 ) ; } }
tr	9	@ Override public void run ( ) { try { while ( Settling . this . running ) { Thread . sleep ( 1 ) ; } } catch ( InterruptedException e ) { } }
tr	4	public static KeyAction [ ] compile ( String s ) { final List < KeyAction > actions = new ArrayList < KeyAction > ( ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { final char c = s . charAt ( i ) ; if ( c == K && s . substring ( i ) . startsWith ( "KeyEvent.VK_" ) ) try { final int k = s . indexOf ( . , i + "KeyEvent.VK_" . length ( ) ) ; final String vk = s . substring ( i + "KeyEvent." . length ( ) , k ) ; final int code = KeyEvent . class . getField ( vk ) . getInt ( null ) ; i = k + 1 ; actions . add ( new KeyAction ( code , Type . valueOf ( s . charAt ( i ) ) ) ) ; } catch ( Exception e ) { throw new RuntimeException ( "Compilation error: s=" + s + "  i=" + i + "  c=" + c , e ) ; } else compile ( c , actions ) ; } return actions . toArray ( new KeyAction [ actions . size ( ) ] ) ; }
tr	3	public static boolean compareImage ( BufferedImage biA , BufferedImage biB ) { DataBuffer dbA = biA . getData ( ) . getDataBuffer ( ) ; int sizeA = dbA . getSize ( ) ; DataBuffer dbB = biB . getData ( ) . getDataBuffer ( ) ; int sizeB = dbB . getSize ( ) ; if ( sizeA == sizeB ) { for ( int i = 0 ; i < sizeA ; i ++ ) { if ( dbA . getElem ( i ) != dbB . getElem ( i ) ) { return false ; } } return true ; } else { return false ; } }
tr	3	public Policy getHostelPolicy ( Integer policyId ) throws ServiceLocatorException , SQLException { Connection con = null ; Policy policy = null ; try { con = services . createConnection ( ) ; PreparedStatement stmt = con . prepareStatement ( "select * from policy where policyId = ?;" ) ; stmt . setInt ( 1 , policyId ) ; ResultSet rs = stmt . executeQuery ( ) ; if ( rs . next ( ) ) { policy = createHostelPolicyInstance ( rs ) ; } rs . close ( ) ; stmt . close ( ) ; } catch ( ServiceLocatorException | SQLException e ) { e . printStackTrace ( ) ; } finally { if ( con != null ) { con . close ( ) ; } } return policy ; }
tr	6	public static void changeBorrowState ( int copyID , boolean state ) { try { DocumentBuilderFactory docFactory = DocumentBuilderFactory . newInstance ( ) ; DocumentBuilder docBuilder = docFactory . newDocumentBuilder ( ) ; Document doc = docBuilder . parse ( new File ( "db/DBborrows.xml" ) ) ; doc . getDocumentElement ( ) . normalize ( ) ; int myItem = 0 ; NodeList borrowNodes = doc . getElementsByTagName ( "borrow" ) ; for ( int i = 0 ; i < borrowNodes . getLength ( ) ; i ++ ) { Element a = ( Element ) borrowNodes . item ( i ) ; if ( Integer . parseInt ( getNodeValue ( "borrowid" , a ) ) == copyID ) { myItem = i ; break ; } } Node copy = doc . getElementsByTagName ( "borrow" ) . item ( myItem ) ; NodeList list = copy . getChildNodes ( ) ; for ( int i = 0 ; i < list . getLength ( ) ; i ++ ) { Node node = list . item ( i ) ; if ( "active" . equals ( node . getNodeName ( ) ) ) { if ( state ) { node . setTextContent ( "true" ) ; } else { node . setTextContent ( "false" ) ; } } } TransformerFactory transformerFactory = TransformerFactory . newInstance ( ) ; Transformer transformer = transformerFactory . newTransformer ( ) ; DOMSource source = new DOMSource ( doc ) ; StreamResult result = new StreamResult ( new File ( "db/DBborrows.xml" ) ) ; transformer . transform ( source , result ) ; } catch ( ParserConfigurationException | SAXException | IOException | NumberFormatException | DOMException | AssertionError | TransformerFactoryConfigurationError | TransformerException e ) { JOptionPane . showMessageDialog ( null , e . getMessage ( ) , "" + "Error" , JOptionPane . ERROR_MESSAGE ) ; } }
tr	4	private Collection < Player > getPlayers ( File matchfile ) { String [ ] playernames = getValue ( matchfile , "players" ) . split ( " " ) ; for ( int i = 0 ; i < playernames . length ; i ++ ) { playernames [ i ] = playernames [ i ] . trim ( ) ; } LinkedList < Player > result = new LinkedList < Player > ( ) ; for ( String str : playernames ) { for ( Player p : model . getAllPlayers ( ) ) { if ( p . getName ( ) . equalsIgnoreCase ( str ) ) result . add ( p ) ; } } return result ; }
tr	0	public Column ( IndividualsGroup genotypeWithAge ) { this . genotype = null ; this . genotypeWithAge = genotypeWithAge ; }
tr	8	public void bQ2Div ( Node node ) { int indent ; String indent_buf ; while ( node != null ) { if ( node . tag == tt . tagBlockquote && node . implicit ) { indent = 1 ; while ( node . hasOneChild ( ) && node . content . tag == tt . tagBlockquote && node . implicit ) { ++ indent ; stripOnlyChild ( node ) ; } if ( node . content != null ) bQ2Div ( node . content ) ; indent_buf = "margin-left: " + ( new Integer ( 2 * indent ) ) . toString ( ) + "em" ; node . element = tt . tagDiv . name ; node . tag = tt . tagDiv ; node . addAttribute ( "style" , indent_buf ) ; } else if ( node . content != null ) bQ2Div ( node . content ) ; node = node . next ; } }
tr	7	public static boolean computeCell ( boolean [ ] [ ] world , int col , int row ) { boolean liveCell = getCell ( world , col , row ) ; int neighbours = countNeighbours ( world , col , row ) ; boolean nextCell = false ; if ( neighbours < 2 ) nextCell = false ; if ( liveCell && ( neighbours == 2 || neighbours == 3 ) ) nextCell = true ; if ( neighbours > 3 ) nextCell = false ; if ( ! liveCell && ( neighbours == 3 ) ) nextCell = true ; return nextCell ; }
tr	5	@ Override public String getValue ( String qName ) { int index = qName . indexOf ( : ) ; String prefix = ( index != - 1 ) ? qName . substring ( 0 , index ) : "" ; String localpart = ( index != - 1 ) ? qName . substring ( index + 1 ) : qName ; for ( int i = 0 ; i < attList . size ( ) ; i ++ ) { QName qname = attList . get ( i ) . qualified_name ; if ( qname . getPrefix ( ) . equals ( prefix ) && qname . getLocalPart ( ) . equals ( localpart ) ) return attList . get ( i ) . getNormalized_value ( ) ; } return null ; }
tr	8	@ Override public void write ( int theByte ) throws IOException { if ( suspendEncoding ) { this . out . write ( theByte ) ; return ; } if ( encode ) { buffer [ position ++ ] = ( byte ) theByte ; if ( position >= bufferLength ) { this . out . write ( encode3to4 ( b4 , buffer , bufferLength , options ) ) ; lineLength += 4 ; if ( breakLines && lineLength >= MAX_LINE_LENGTH ) { this . out . write ( NEW_LINE ) ; lineLength = 0 ; } position = 0 ; } } else { if ( decodabet [ theByte & 7f ] > WHITE_SPACE_ENC ) { buffer [ position ++ ] = ( byte ) theByte ; if ( position >= bufferLength ) { int len = EncFSBase64 . decode4to3 ( buffer , b4 , 0 , options ) ; out . write ( b4 , 0 , len ) ; position = 0 ; } } else if ( decodabet [ theByte & 7f ] != WHITE_SPACE_ENC ) { throw new IOException ( "Invalid character in Base64 data." ) ; } } }
tr	0	protected void setCommunicator ( Communicator communicator ) { this . communicator = communicator ; }
tr	7	protected static void addObject ( IUnknown o ) { if ( apartmentInitialized . get ( ) == false ) { ComThread . InitSTA ( false ) ; apartmentInitialized . set ( true ) ; } if ( ! AUTO_GC ) return ; ReferenceQueue < IUnknown > deadObjects = deadPool . get ( ) ; objects . put ( new PointerWeakReference ( o , deadObjects ) , false ) ; if ( GC_COUNT != - 1 && ( count % GC_COUNT ) == 0 ) { System . gc ( ) ; } if ( ( count ++ % CULL_COUNT ) == 0 ) { int numberCulled = cullDeadPool ( deadObjects , objects ) ; if ( IUnknown . isDebugEnabled ( ) ) { if ( numberCulled > 0 ) { IUnknown . debug ( "ROT: added instance of " + o . getClass ( ) . getSimpleName ( ) + "->[+1  -" + numberCulled + "] with " + objects . size ( ) + " remaining live objects" ) ; } } } }
tr	7	public static void main ( String args [ ] ) { int portNumber = 4444 ; if ( args . length < 1 ) { System . out . println ( "Usage: java MultiThreadChatServerSync <portNumber>\n" + "Now using port number=" + portNumber ) ; } else { portNumber = Integer . valueOf ( args [ 0 ] ) . intValue ( ) ; } try { serverSocket = new ServerSocket ( portNumber ) ; } catch ( IOException e ) { System . out . println ( e ) ; } while ( true ) { try { clientSocket = serverSocket . accept ( ) ; int i = 0 ; for ( i = 0 ; i < maxClientsCount ; i ++ ) { if ( threads [ i ] == null ) { threads [ i ] = new clientThread ( clientSocket , threads ) ; threads [ i ] . start ( ) ; break ; } } if ( i == maxClientsCount ) { PrintStream os = new PrintStream ( clientSocket . getOutputStream ( ) ) ; os . println ( "Server too busy. Try later." ) ; os . close ( ) ; clientSocket . close ( ) ; } } catch ( IOException e ) { System . out . println ( e ) ; } } }
tr	3	private static String [ ] getPiStar ( MarkovModel model , double [ ] [ ] logProbs , String [ ] observed ) { String [ ] piStar = new String [ observed . length ] ; for ( int x = 0 ; x < piStar . length ; x ++ ) { int index = - 1 ; double max = double . NEGATIVE_INFINITY ; for ( int y = 0 ; y < logProbs . length ; y ++ ) { double newMax = Math . max ( max , logProbs [ y ] [ x ] ) ; if ( newMax == logProbs [ y ] [ x ] ) { max = newMax ; index = y ; } } piStar [ x ] = model . getMarkovStates ( ) [ index ] . getStateName ( ) ; } return piStar ; }
tr	3	public ArrayList < Point > nextMove ( TTTBoard board ) throws Exception { ArrayList < Point > spots = board . getEmptySpots ( ) ; ArrayList < Point > winningSpots = new ArrayList < Point > ( ) ; if ( spots . size ( ) == 0 ) { throw new Exception ( "No spaces left" ) ; } else if ( board . checkWin ( ) ) { throw new Exception ( "Already won" ) ; } else if ( spots . size ( ) == 9 ) { Point point = new Point ( 1 , 1 ) ; winningSpots . add ( point ) ; return winningSpots ; } char turn = getChar ( spots . size ( ) ) ; winningSpots = checkMove ( spots , board , turn ) ; return winningSpots ; }
tr	6	@ Override public boolean equals ( Object o ) { return o instanceof RectData ? this . x == ( ( RectData ) o ) . x && this . y == ( ( RectData ) o ) . y && this . u == ( ( RectData ) o ) . u && this . v == ( ( RectData ) o ) . v && this . w == ( ( RectData ) o ) . w && this . h == ( ( RectData ) o ) . h : false ; }
tr	4	public void insertPoint ( Point p , int index ) { if ( bounds != null && ! bounds . contains ( p ) ) bounds = null ; if ( index > size || index < 0 ) throw new IndexOutOfBoundsException ( "Index: " + index + "  Size: " + size ) ; index *= 2 ; int length = points . length ; int old [ ] = points ; points = new int [ length + 2 ] ; System . arraycopy ( old , 0 , points , 0 , index ) ; System . arraycopy ( old , index , points , index + 2 , length - index ) ; points [ index ] = p . x ; points [ index + 1 ] = p . y ; size ++ ; }
tr	5	public static JLabel drawCoolLineChart ( TreeMap < String , double > data ) { String [ ] dates = new String [ data . size ( ) ] ; double [ ] values = new double [ data . size ( ) ] ; String [ ] literalValues = new String [ data . size ( ) ] ; int i = 0 ; double greatest = 0 ; for ( String str : data . keySet ( ) ) { dates [ i ] = str ; values [ i ] = data . get ( str ) ; if ( values [ i ] > greatest ) greatest = values [ i ] ; i ++ ; } greatest += greatest * 1 / 6 ; for ( int j = 0 ; j < values . length ; j ++ ) { values [ j ] = ( values [ j ] * 100 ) / greatest ; } Line line1 = Plots . newLine ( Data . newData ( values ) , Color . newColor ( "CA3D05" ) ) ; line1 . setLineStyle ( LineStyle . newLineStyle ( 3 , 1 , 0 ) ) ; line1 . addShapeMarkers ( Shape . DIAMOND , Color . newColor ( "CA3D05" ) , 12 ) ; line1 . addShapeMarkers ( Shape . DIAMOND , Color . WHITE , 8 ) ; LineChart chart = GCharts . newLineChart ( line1 ) ; chart . setSize ( 600 , 450 ) ; chart . setTitle ( "Value of the title in time" , Color . WHITE , 14 ) ; chart . setGrid ( 25 , 25 , 3 , 2 ) ; AxisStyle axisStyle = AxisStyle . newAxisStyle ( Color . WHITE , 12 , AxisTextAlignment . CENTER ) ; AxisLabels xAxis = AxisLabelsFactory . newAxisLabels ( dates ) ; xAxis . setAxisStyle ( axisStyle ) ; chart . addXAxisLabels ( xAxis ) ; AxisLabels xAxis2 = AxisLabelsFactory . newAxisLabels ( "Time" , 50.0 ) ; xAxis2 . setAxisStyle ( AxisStyle . newAxisStyle ( Color . WHITE , 14 , AxisTextAlignment . CENTER ) ) ; chart . addXAxisLabels ( xAxis2 ) ; AxisLabels yAxis = AxisLabelsFactory . newNumericRangeAxisLabels ( 0 , greatest ) ; yAxis . setAxisStyle ( AxisStyle . newAxisStyle ( Color . WHITE , 14 , AxisTextAlignment . CENTER ) ) ; yAxis . setAxisStyle ( axisStyle ) ; chart . addYAxisLabels ( yAxis ) ; AxisLabels yAxis2 = AxisLabelsFactory . newAxisLabels ( "Valu\nin\nUSD" , 50.0 ) ; yAxis2 . setAxisStyle ( AxisStyle . newAxisStyle ( Color . WHITE , 14 , AxisTextAlignment . CENTER ) ) ; yAxis2 . setAxisStyle ( axisStyle ) ; chart . addYAxisLabels ( yAxis2 ) ; chart . setBackgroundFill ( Fills . newSolidFill ( Color . newColor ( "1F1D1D" ) ) ) ; LinearGradientFill fill = Fills . newLinearGradientFill ( 0 , Color . newColor ( "363433" ) , 100 ) ; fill . addColorAndOffset ( Color . newColor ( "2E2B2A" ) , 0 ) ; chart . setAreaFill ( fill ) ; try { return new JLabel ( new ImageIcon ( ImageIO . read ( new URL ( chart . toURLString ( ) ) ) ) ) ; } catch ( MalformedURLException e ) { } catch ( IOException e ) { } return null ; }
tr	3	public void eval ( Environment e ) { switch ( type ) { case Value : e . value ( e . thing ( this ) ) ; break ; case Name : e . value ( this ) ; break ; case Call : e . call ( this ) ; break ; default : throw new Error ( String . format ( "Primitive '%s' not implemented!" , value ) ) ; } }
tr	4	private static int [ ] [ ] maxSumArea ( int m , int n , int [ ] [ ] forest ) { int [ ] [ ] res = new int [ m ] [ n ] ; int [ ] [ ] matrix = flip ( m , n , forest ) ; for ( int i = 0 ; i < res [ 0 ] . length ; i ++ ) { res [ 0 ] [ i ] = forest [ 0 ] [ i ] ; } for ( int i = 1 ; i < res . length ; i ++ ) { for ( int j = 0 ; j < res [ i ] . length ; j ++ ) { if ( forest [ i ] [ j ] == 0 ) res [ i ] [ j ] = 0 ; else res [ i ] [ j ] = res [ i - 1 ] [ j ] + forest [ i ] [ j ] ; } } return res ; }
tr	7	private void insertDatabaseOperation ( Object object , Connection connection , DatabaseOperation databaseOperation ) { try { if ( ! object . getClass ( ) . isAnnotationPresent ( Table . class ) ) { throw new JStrykerException ( "Object(" + object + ") isn't Entity" ) ; } Table table = object . getClass ( ) . getAnnotation ( Table . class ) ; StringBuilder builder = new StringBuilder ( "<?xml version=\"1.0\"?>\n<dataset>\n<" ) ; builder . append ( table . name ( ) ) . append ( " " ) ; Field [ ] fields = object . getClass ( ) . getDeclaredFields ( ) ; for ( Field field : fields ) { field . setAccessible ( true ) ; Object value = field . get ( object ) ; if ( value == null ) { continue ; } if ( field . isAnnotationPresent ( transient . class ) ) { continue ; } Column annotation = field . getAnnotation ( Column . class ) ; if ( annotation != null && ! "" . equals ( annotation . name ( ) ) ) { builder . append ( annotation . name ( ) ) ; } else { builder . append ( field . getName ( ) ) ; } builder . append ( "=\"" ) ; builder . append ( value ) ; builder . append ( "\" " ) ; } builder . append ( "/>\n</dataset>" ) ; String string = builder . toString ( ) ; execute ( null , connection , new ByteArrayInputStream ( string . getBytes ( ) ) , databaseOperation ) ; } catch ( IllegalAccessException e ) { throw new JStrykerException ( e . getMessage ( ) , e ) ; } }
tr	5	public void setCell ( int col , int row , boolean alive ) { if ( row >= 0 && row < 8 && col >= 0 && col < 8 ) { if ( alive ) { cells |= ( ( long ) 1 << ( 8 * row + col ) ) ; } else { cells &= ~ ( ( long ) 1 << ( 8 * row + col ) ) ; } } }
tr	1	public static void printlnDebug ( String debugString ) { if ( SHOW_DEBUG ) { System . out . println ( debugString ) ; } }
tr	6	public String nextTo ( char d ) { StringBuffer sb = new StringBuffer ( ) ; for ( ; ; ) { char c = next ( ) ; if ( c == d || c == 0 || c == '' || c == '' ) { if ( c != 0 ) { back ( ) ; } return sb . toString ( ) . trim ( ) ; } sb . append ( c ) ; } }
tr	3	public JSONWriter object ( ) throws JSONException { if ( this . mode == i ) { this . mode = o ; } if ( this . mode == o || this . mode == a ) { this . append ( "{" ) ; this . push ( new JSONObject ( ) ) ; this . , = false ; return this ; } throw new JSONException ( "Misplaced object." ) ; }
tr	8	private void createGame ( ) { gameName = fieldGameName . getText ( ) ; playerNameHost = fieldPlayerName . getText ( ) ; Enumeration < NetworkInterface > nets = null ; try { nets = NetworkInterface . getNetworkInterfaces ( ) ; } catch ( SocketException e1 ) { } Vector < String > l = new Vector < String > ( ) ; for ( NetworkInterface netint : Collections . list ( nets ) ) { Enumeration < InetAddress > inetAddresses = netint . getInetAddresses ( ) ; for ( InetAddress inetAddress : Collections . list ( inetAddresses ) ) { l . add ( netint . getDisplayName ( ) + " (" + inetAddress . toString ( ) . substring ( 1 ) + ")" ) ; } } Object selVal = JOptionPane . showInputDialog ( this , "Choose interface to bind" , "Input" , JOptionPane . INFORMATION_MESSAGE , null , l . toArray ( ) , l . elementAt ( 0 ) ) ; String ip = selVal . toString ( ) ; int beg = ip . lastIndexOf ( ( ) ; int end = ip . lastIndexOf ( ) ) ; String ipAddr = selVal . toString ( ) . substring ( beg + 1 , end ) ; try { addr = InetAddress . getByName ( ipAddr ) ; } catch ( UnknownHostException e1 ) { } if ( gameName == null || gameName . isEmpty ( ) ) { JOptionPane . showMessageDialog ( null , "each game needs a name" , "Game Name" , JOptionPane . ERROR_MESSAGE ) ; return ; } if ( playerNameHost == null || playerNameHost . isEmpty ( ) ) { JOptionPane . showMessageDialog ( null , "each player needs a name" , "Player Name" , JOptionPane . ERROR_MESSAGE ) ; return ; } dispose ( ) ; s = new Server ( ipAddr ) ; adapter . connectToServer ( addr , playerNameHost ) ; hostFrame . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; hostFrame . setTitle ( "Snake on Lan - Host Game" ) ; hostFrame . setVisible ( true ) ; hostFrame . setResizable ( false ) ; hostFrame . setLocationRelativeTo ( null ) ; StartSnakeGame . frame . dispose ( ) ; }
tr	2	public ArrayPriorityQueueItem < T > insert ( T item , double key ) { ArrayPriorityQueueItem < T > newItem = new ArrayPriorityQueueItem < T > ( item , key , numberOfElements ) ; if ( minItem == null || key < minItem . key ) { minItem = newItem ; } a [ numberOfElements ++ ] = newItem ; return newItem ; }
tr	2	public void setScore ( ScoreCardCategories kategorie , int score ) throws IllegalArgumentException { if ( scoreCard . get ( kategorie . toString ( ) ) >= 0 ) { throw new IllegalArgumentException ( "Wert schon gesetzt" ) ; } else { scoreCard . put ( kategorie . toString ( ) , score ) ; calculateTotales ( ) ; } Iterator < Map . Entry < String , Integer >> entries = scoreCard . entrySet ( ) . iterator ( ) ; while ( entries . hasNext ( ) ) { Map . Entry < String , Integer > entry = entries . next ( ) ; System . out . println ( "Key = " + entry . getKey ( ) + "  Value = " + entry . getValue ( ) ) ; } this . setChanged ( ) ; this . notifyObservers ( ) ; }
tr	1	private void addEntityCount ( int amount ) { this . entityCount . add ( amount ) ; while ( this . entityCount . size ( ) > maxSize ) { this . entityCount . remove ( 0 ) ; } }
tr	7	public static < E > void topKSort ( E [ ] array , Comparator < E > comparator , int k ) { if ( k >= array . length ) { k = array . length ; } if ( k < 0 ) { throw new UnsupportedOperationException ( "-k <number> number must be equal or greater than zero." ) ; } FourHeap < E > fh = new FourHeap < E > ( comparator ) ; int i = 0 ; while ( i < k ) { fh . insert ( array [ i ++ ] ) ; } if ( k != 0 ) { while ( i < array . length ) { if ( comparator . compare ( fh . findMin ( ) , array [ i ] ) < 0 ) { fh . deleteMin ( ) ; fh . insert ( array [ i ] ) ; } i ++ ; } } int v = k - 1 ; while ( ! fh . isEmpty ( ) ) { array [ v ] = fh . deleteMin ( ) ; v -- ; } }
tr	4	@ Override public class getColumnClass ( int column ) { switch ( column ) { case 0 : return String . class ; case 1 : return String . class ; case 2 : case 3 : default : return Object . class ; } }
tr	0	public TableColumnAdjuster ( JTable table ) { this ( table , 6 ) ; }
tr	2	public ArrayList < SelectableLabel > getSelectableLabels ( ) { ArrayList < SelectableLabel > list = new ArrayList < > ( ) ; for ( int i = 0 ; i < subviews . size ( ) ; i ++ ) if ( subviews . get ( i ) instanceof SelectableLabel ) list . add ( ( SelectableLabel ) subviews . get ( i ) ) ; return list ; }
tr	9	public static AbstractUIItem createItem ( FeatureType t , Panel panel ) { switch ( t ) { case Constant : return new ConstantUIItem ( panel ) ; case Sink : return new SinkUIItem ( panel ) ; case Source : return new SourceUIItem ( panel ) ; case Saddle : return new SaddleUIItem ( panel ) ; case Center : return new CenterUIItem ( panel ) ; case Focus : return new FocusUIItem ( panel ) ; case ConvergingElement : return new ConvergingElementUIItem ( panel ) ; case DivergingElement : return new DivergingElementUIItem ( panel ) ; case Generic : return new GenericUIItem ( panel ) ; } assert false : "Unhandled type: " + t ; return null ; }
tr	3	static private final int jjMoveStringLiteralDfa4_0 ( long old0 , long active0 ) { if ( ( ( active0 &= old0 ) ) == 0 ) return jjStartNfa_0 ( 2 , old0 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 3 , active0 ) ; return 4 ; } switch ( curChar ) { case 71 : return jjMoveStringLiteralDfa5_0 ( active0 , 10 ) ; default : break ; } return jjStartNfa_0 ( 3 , active0 ) ; }
tr	4	public static void main ( String args [ ] ) { if ( args . length == 0 ) { try { System . out . println ( "Enter file path:" ) ; wc ( new InputStreamReader ( System . in ) ) ; System . out . println ( lines + " " + words + " " + chars ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } ; } else { int twords = 0 , tchars = 0 , tlines = 0 ; for ( int i = 0 ; i < args . length ; i ++ ) { try { words = chars = lines = 0 ; wc ( new FileReader ( args [ i ] ) ) ; twords += words ; tchars += chars ; tlines += lines ; System . out . println ( args [ i ] + ": " + lines + " " + words + " " + chars ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; System . out . println ( args [ i ] + ": error." ) ; } } System . out . println ( "total: " + tlines + " " + twords + " " + tchars ) ; } }
tr	5	public static void flatten3 ( TreeNode root ) { if ( root == null || ( root . left == null && root . right == null ) ) return ; if ( root . left != null ) { TreeNode tmp = root . right ; root . right = root . left ; root . left = null ; TreeNode rightMost = findRightMostNode ( root . right ) ; rightMost . right = tmp ; flatten3 ( root . right ) ; } else if ( root . right != null ) { flatten3 ( root . right ) ; } }
tr	4	private LepraPost postParser ( String rawPost ) { Document doc = Jsoup . parse ( rawPost ) ; String postId = doc . select ( ".post" ) . first ( ) . attr ( "id" ) ; String postContent = doc . select ( ".dti" ) . first ( ) . html ( ) ; String userLogin = doc . select ( ".c_user" ) . first ( ) . text ( ) ; String postLink = null ; String commentsCnt = null , newCommentsCnt = null ; Element commentsCounts = doc . select ( ".b-post_comments_links" ) . first ( ) ; if ( commentsCounts != null ) { Elements cnts = commentsCounts . getElementsByTag ( "a" ) ; if ( ! cnts . isEmpty ( ) ) { commentsCnt = cnts . first ( ) . text ( ) ; postLink = cnts . first ( ) . attr ( "href" ) ; if ( cnts . size ( ) > 1 ) { newCommentsCnt = cnts . get ( 1 ) . text ( ) ; } } } String d = doc . select ( ".js-date" ) . first ( ) . attr ( "data-epoch_date" ) ; long date = long . valueOf ( d ) ; String title = doc . select ( ".ddi" ) . first ( ) . html ( ) ; if ( StringUtils . isNotBlank ( title ) ) { title = title . trim ( ) . substring ( 8 , title . indexOf ( "<a" ) ) . replaceAll ( "\\s" , " " ) . trim ( ) ; } int postIdInt = Integer . valueOf ( postId . substring ( 1 , postId . length ( ) ) ) ; return new LepraPost ( postIdInt , postLink , userLogin , title , new Date ( date * 1000 ) , commentsCnt , newCommentsCnt , postContent ) ; }
tr	8	public static Tokens2 [ ] allTokens ( String name ) { int tam ; Tokens2 allTokens [ ] = null ; String text = "" ; JTextArea Texto = new JTextArea ( ) ; String str ; tam = 0 ; try { File abrir = new File ( "..\\CompiladorToTo\\" + name + "Tokens.txt" ) ; if ( abrir != null ) { FileReader archivo = new FileReader ( abrir ) ; BufferedReader leer = new BufferedReader ( archivo ) ; while ( ( text = leer . readLine ( ) ) != null ) { Texto . append ( text + "\n" ) ; tam ++ ; } leer . close ( ) ; allTokens = new Tokens2 [ tam ] ; String lineaa ; StringTokenizer tokens = new StringTokenizer ( Texto . getText ( ) , "\n" ) ; int k = 0 ; while ( tokens . hasMoreTokens ( ) ) { lineaa = tokens . nextToken ( ) ; StringTokenizer tokenn = new StringTokenizer ( lineaa ) ; int i = 0 ; allTokens [ k ] = new Tokens2 ( ) ; while ( tokenn . hasMoreTokens ( ) ) { str = tokenn . nextToken ( ) ; if ( i == 0 ) { allTokens [ k ] . setLinea ( Integer . parseInt ( str ) ) ; } if ( i == 1 ) { allTokens [ k ] . setToken ( str ) ; } if ( i == 2 ) { allTokens [ k ] . setTipo ( Nodo . tipoToken . valueOf ( str ) ) ; } i ++ ; } k ++ ; } } } catch ( IOException ioe ) { System . out . println ( ioe ) ; } finally { return allTokens ; } }
tr	9	public static void main ( String [ ] args ) throws IOException { Scanner in = new Scanner ( System . in ) ; byte p1 = 3 ; int p1Guess ; int p1Taken ; byte p2 = 3 ; int p2Guess ; int p2Taken ; boolean p1Turn = true ; byte round = 0 ; System . out . println ( "Stone game" ) ; while ( p1 > 0 && p2 > 0 ) { System . out . println ( "------------------" ) ; System . out . println ( "Round: " + ++ round ) ; System . out . println ( " You have " + p1 + " stones; CPU has " + p2 + " stones" ) ; System . out . println ( " How much stones you're taking: " ) ; do p1Taken = in . nextInt ( ) ; while ( p1Taken > p1 || p1Taken < 0 ) ; p2Taken = Game . randInt ( 0 , p2 ) ; if ( p1Turn ) { System . out . println ( " Your guess is: " ) ; p1Guess = in . nextInt ( ) ; do { int rand_min = p1Guess - p2 ; if ( rand_min < 0 ) rand_min = 0 ; p2Guess = Game . randInt ( rand_min , p1 + p2 ) ; } while ( p2Guess == p1Guess ) ; System . out . println ( "CPU is thinking of: " + p2Guess ) ; } else { p2Guess = Game . randInt ( p2Taken , p2Taken + p1 ) ; System . out . println ( "CPU is thinking of: " + p2Guess ) ; System . out . println ( " Your guess is: " ) ; do p1Guess = in . nextInt ( ) ; while ( p1Guess == p2Guess ) ; } System . out . println ( "We took: " + p1Taken + " P2 took: " + p2Taken + " stones" ) ; if ( p1Guess == ( p1Taken + p2Taken ) ) { System . out . println ( "We won " + round + ". round" ) ; -- p1 ; p1Turn = true ; } else if ( p2Guess == ( p1Taken + p2Taken ) ) { System . out . println ( "CPU won " + round + ". round" ) ; -- p2 ; p1Turn = false ; } else p1Turn = ! p1Turn ; } System . out . println ( "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!" ) ; if ( p1 == 0 ) System . out . println ( "PLAYER 1 HAS WON" ) ; else System . out . println ( "CPU HAS WON" ) ; System . out . println ( "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!" ) ; }
tr	4	public double getActualWorkload ( int time ) { if ( time != lastActWlTime ) { double allUnits = 0 ; double workLoad = 0 ; for ( Resource r : resources . values ( ) ) { if ( time >= r . accountingGroup . insertionTime && time < r . accountingGroup . insertionTime + r . accountingGroup . maxLifeTime ) { allUnits += r . maxResourceUnits ; workLoad += r . workloadData [ time - r . accountingGroup . insertionTime ] ; } } lastActWlTime = time ; lastWl = workLoad / allUnits ; } return lastWl ; }
tr	1	public XMLReaderDOM getDOMReader ( ) { if ( domReader == null ) { domReader = new XMLReaderDOM ( ) ; } return domReader ; }
tr	2	public DefaultNeuronWithBias ( int weightNumber , double [ ] maxWeight , ActivationFunctionModel activationFunction ) { if ( weightNumber == maxWeight . length ) { Random rand = new Random ( ) ; weight = new double [ weightNumber ] ; for ( int i = 0 ; i < weightNumber ; i ++ ) { weight [ i ] = rand . nextDouble ( ) * maxWeight [ i ] ; } } this . activationFunction = activationFunction ; }
tr	1	@ Override public boolean equals ( Object o ) { if ( ! ( o instanceof BooleanWrapper ) ) { return false ; } BooleanWrapper obj = ( BooleanWrapper ) o ; return obj . getBooleanValue ( ) == this . getBooleanValue ( ) ; }
tr	3	public DictionarySet ( ) { isCounting = false ; dicts = new Dictionary [ DictionaryTypes . TYPE_END . ordinal ( ) ] ; tot = dicts . length ; for ( int i = 0 ; i < tot ; ++ i ) { dicts [ i ] = new Dictionary ( ) ; int id = dicts [ i ] . lookupIndex ( unseen ) ; Utils . assert ( id == 1 ) ; if ( i == DictionaryTypes . POS . ordinal ( ) ) initDict ( DictionaryTypes . POS , dicts [ i ] ) ; if ( i == DictionaryTypes . WORD . ordinal ( ) ) initDict ( DictionaryTypes . WORD , dicts [ i ] ) ; } }
tr	9	private static String dump ( Object thing ) { if ( thing == null ) return "null" ; else if ( thing == NO_ELEMENT ) return "NADA" ; else if ( thing instanceof EquivalentSet ) { ArrayList < Object > al = ( ( EquivalentSet ) thing ) . contents ; String res = "[" ; for ( int i = 0 , size = al . size ( ) ; i < size ; ++ i ) { if ( i > 0 ) res = res + "  " ; res = res + al . get ( i ) ; } return res + "]" ; } else if ( thing instanceof Object [ ] ) { StringBuffer str_buf = new StringBuffer ( "{" ) ; Object [ ] ary = ( Object [ ] ) thing ; for ( int i = 0 ; i < ary . length ; ++ i ) { str_buf . append ( dump ( ary [ i ] ) ) ; if ( i < ary . length - 1 ) str_buf . append ( "  " ) ; } str_buf . append ( "}" ) ; return str_buf . toString ( ) ; } else if ( thing instanceof Node ) { Node node = ( Node ) thing ; return "(" + node . size + "  " + dump ( node . element ) + ";\n" + indent ( dump ( node . left ) , "  " ) + " \n" + indent ( dump ( node . right ) , "  " ) + ")" ; } else return thing . toString ( ) ; }
tr	6	public Object [ ] [ ] rechercherEmplois ( Region reg , Set < Competence > lesComps ) { ArrayList < OffreAffiche > lesOfrAffiche = new ArrayList ( ) ; Object [ ] [ ] resultat ; OffreNoyauFonctionnel . printOutOffres ( ) ; ArrayList < Emploi > lstEmplois = OffreNoyauFonctionnel . getTblEmplois ( ) . get ( reg . getRegnom ( ) ) ; if ( lstEmplois != null ) { for ( Emploi emploi : lstEmplois ) { boolean hasComp = false ; for ( Competence comp : lesComps ) { if ( ! hasComp ) { if ( emploi . getTblComps ( ) . containsKey ( comp ) ) { OffreAffiche ofrAffiche = new OffreAffiche ( ) ; ofrAffiche . setTitre ( emploi . getTitre ( ) ) ; System . out . println ( emploi . scoreCompetencesHash ( lesComps ) ) ; ofrAffiche . setScoreTotal ( emploi . scoreCompetencesHash ( lesComps ) ) ; double score = emploi . scoreCompetencesHash ( lesComps ) ; String scoreAd = String . format ( "%.2f" , ( score / 1 ) * 100 ) + "%" ; ofrAffiche . setAdquation ( scoreAd ) ; ofrAffiche . setRegion ( emploi . getReg ( ) . getRegnom ( ) ) ; lesOfrAffiche . add ( ofrAffiche ) ; hasComp = true ; } } } } } Collections . sort ( lesOfrAffiche ) ; int afficheSize = lesOfrAffiche . size ( ) ; resultat = new Object [ afficheSize ] [ 4 ] ; for ( int i = 0 ; i < afficheSize ; i ++ ) { resultat [ i ] [ 0 ] = lesOfrAffiche . get ( i ) . getTitre ( ) ; resultat [ i ] [ 1 ] = lesOfrAffiche . get ( i ) . getScoreTotal ( ) ; resultat [ i ] [ 2 ] = lesOfrAffiche . get ( i ) . getAdquation ( ) ; resultat [ i ] [ 3 ] = lesOfrAffiche . get ( i ) . getRegion ( ) ; } return resultat ; }
tr	1	public void setCode ( CodeFragment code ) { if ( code == null ) code = new CodeFragment ( ) ; this . code = code ; }
tr	3	public Dimension getDimension ( String conceptRef ) { for ( KeyFamily keyFamily : keyFamilies ) { List < Dimension > dimensions = keyFamily . getComponents ( ) . getDimensions ( ) ; for ( Dimension dimension : dimensions ) { if ( dimension . getConceptRef ( ) . equalsIgnoreCase ( conceptRef ) ) { return dimension ; } } } return null ; }
tr	0	public OlogClientBuilder withExecutor ( ExecutorService executor ) { this . executor = executor ; return this ; }
tr	3	private void refreshObservers ( ) { if ( client . isConnect ( ) ) { Integer studentsCount = client . getStudentsCount ( ) ; if ( studentsCount == null ) { studentsCount = - 1 ; } maxObserver . setText ( Integer . toString ( studentsCount ) ) ; Integer viewSize = client . getViewSize ( ) ; if ( viewSize == null ) { viewSize = - 1 ; } observer . setText ( Integer . toString ( viewSize ) ) ; } }
tr	0	public boolean checkSwamp ( ) { return false ; }
tr	3	private String getCertificateChainDescription ( ) { final StringBuilder buf = new StringBuilder ( ) ; try { final SSLSession session = socket . getSession ( ) ; for ( final Certificate certificate : session . getLocalCertificates ( ) ) { buf . append ( certificate . toString ( ) ) ; } buf . append ( "\n--------------------------------------------------------------------------\n" ) ; for ( final X509Certificate certificate : session . getPeerCertificateChain ( ) ) { buf . append ( certificate . toString ( ) ) ; } } catch ( final Exception e ) { buf . append ( e ) ; } return buf . toString ( ) ; }
tr	6	public void checkPass ( int x , int y ) { if ( x >= 20 && y >= 30 ) { System . out . println ( "\u0E04\u0E23\u0E1A\u0E15\u0E32\u0E21\u0E2B\u0E25\u0E31\u0E01\u0E2A\u0E39\u0E15\u0E23" ) ; } else if ( x < 20 && y < 30 ) { System . out . println ( "\u0E02\u0E32\u0E14\u0E27\u0E34\u0E0A\u0E32\u0E40\u0E2D\u0E01\u0E1A\u0E31\u0E07\u0E04\u0E31\u0E1A " + ( 20 - x ) + " \u0E2B\u0E19\u0E48\u0E27\u0E22\u0E01\u0E34\u0E08\n" + "\u0E02\u0E32\u0E14\u0E27\u0E34\u0E0A\u0E32\u0E40\u0E2D\u0E01\u0E40\u0E25\u0E37\u0E2D\u0E01 " + ( 30 - y ) + " \u0E2B\u0E19\u0E48\u0E27\u0E22\u0E01\u0E34\u0E08" ) ; } else if ( x < 20 ) { System . out . println ( "\u0E02\u0E32\u0E14\u0E27\u0E34\u0E0A\u0E32\u0E40\u0E2D\u0E01\u0E1A\u0E31\u0E07\u0E04\u0E31\u0E1A " + ( 20 - x ) + " \u0E2B\u0E19\u0E48\u0E27\u0E22\u0E01\u0E34\u0E08" ) ; } else if ( y < 30 ) { System . out . println ( "\u0E02\u0E32\u0E14\u0E27\u0E34\u0E0A\u0E32\u0E40\u0E2D\u0E01\u0E40\u0E25\u0E37\u0E2D\u0E01 " + ( 30 - y ) + " \u0E2B\u0E19\u0E48\u0E27\u0E22\u0E01\u0E34\u0E08" ) ; } }
tr	1	public void update ( M m , Connection conn ) { int result = update ( m , allFields ( ) , conn , "WHERE " + Cols . getSingle ( idFields ) . sqlName + "=?" , getId ( m ) ) ; if ( result != 1 ) { throw new RuntimeException ( "Failed to update record into " + tableName + " table" ) ; } }
tr	2	public static void onReturn ( final P1 < String > p1 ) { ThreadUtil . runStrong ( new P0 ( ) { public void e ( ) { while ( true ) { try { String readLine = readLine ( ) ; p1 . e ( readLine ) ; } catch ( Exception e1 ) { return ; } } } } ) ; }
tr	8	private int InterseccionX ( double _x1 , double _w1 , double _x2 , double _w2 ) { int estado = 0 ; if ( _x1 <= _x2 + _w2 && _x2 + _w2 <= _x1 + _w1 ) { estado = 1 ; } else if ( _x1 <= _x2 && _x2 <= _x1 + _w1 ) { estado = 1 ; } else if ( _x2 <= _x1 + _w1 && _x1 + _w1 <= _x2 + _w2 ) { estado = 1 ; } else if ( _x2 <= _x1 && _x1 <= _x2 + _w2 ) { estado = 1 ; } return estado ; }
tr	2	public void generate ( ) { if ( generated ) { System . err . println ( "World " + worldName + " is already generated!" ) ; return ; } if ( loadFromFile ) { System . err . println ( "World " + worldName + " loads from a file!" ) ; return ; } tileSet = Perlin . getNoise ( rand , getTileWidth ( ) , getTileHeight ( ) , ( byte ) 4 ) ; tileSet = Perlin . roundNoise ( tileSet , ( byte ) 2 ) ; WorldUtil . parsePerlinToTiles ( this , tileSet , true ) ; fillStructList ( ) ; generated = true ; }
tr	4	@ Override public void actionPerformed ( ActionEvent e ) { int newRow = row + 1 ; if ( newRow > 20 ) newRow = 0 ; if ( ! SamuraiTableModel . isVisible ( newRow , column ) ) { if ( column < 9 || column > 11 ) newRow += 3 ; else newRow = 6 ; } moveToCell ( newRow , column ) ; }
tr	9	public void PatientDocFile ( JPanel ptPane , int loggedId ) { staffid = loggedId ; StringBuffer loggedUser = new StringBuffer ( ) ; JTextPane tpLoggedStaff = new JTextPane ( ) ; for ( int i = 0 ; i < staff . size ( ) ; i ++ ) { if ( staff . get ( i ) . getId ( ) == loggedId ) { loggedUser . append ( "<b>" + staff . get ( i ) . getLname ( ) ) ; loggedUser . append ( "  " ) ; loggedUser . append ( staff . get ( i ) . getFname ( ) + "</b>" ) ; if ( staff . get ( i ) . getPosition ( ) . equalsIgnoreCase ( "gp" ) ) loggedUser . append ( "  [logged as Dr.]" ) ; else if ( staff . get ( i ) . getPosition ( ) . equalsIgnoreCase ( "ns" ) ) loggedUser . append ( "  [logged as R.N.]" ) ; else if ( staff . get ( i ) . getPosition ( ) . equalsIgnoreCase ( "ma" ) ) loggedUser . append ( "  [logged as Med.As.]" ) ; else if ( staff . get ( i ) . getPosition ( ) . equalsIgnoreCase ( "mo" ) ) loggedUser . append ( "  [logged as Med.Of.]" ) ; } } tpLoggedStaff . setContentType ( "text/html" ) ; tpLoggedStaff . setText ( loggedUser . toString ( ) ) ; this . function . setOpacity ( tpLoggedStaff ) ; tpLoggedStaff . setEditable ( false ) ; patientList . setPreferredSize ( ( new Dimension ( 80 , 40 ) ) ) ; testList . setPreferredSize ( ( new Dimension ( 80 , 40 ) ) ) ; function . makeElementWithBorder ( patientList , "Patients" , Color . GRAY , false ) ; patientList . setOpaque ( false ) ; patientList . setSelectionMode ( ListSelectionModel . SINGLE_SELECTION ) ; patientList . setSelectedIndex ( 0 ) ; patientList . setVisibleRowCount ( 3 ) ; function . makeElementWithBorder ( testList , "Tests" , Color . GRAY , false ) ; testList . setOpaque ( false ) ; testList . setSelectionMode ( ListSelectionModel . SINGLE_SELECTION ) ; testList . setSelectedIndex ( 0 ) ; testList . setVisibleRowCount ( 3 ) ; this . patientListSP = new JScrollPane ( this . patientList ) ; this . function . setOpacity ( this . patientListSP ) ; patientListSP . setPreferredSize ( ( new Dimension ( 80 , 40 ) ) ) ; this . testListSP = new JScrollPane ( this . testList ) ; this . function . setOpacity ( this . testListSP ) ; testListSP . setPreferredSize ( ( new Dimension ( 80 , 40 ) ) ) ; JScrollPane [ ] patientSP = new JScrollPane [ patientTP . length ] ; JScrollPane testSP = new JScrollPane ( this . testTP ) ; function . makeElementWithBorder ( testSP , "Test Results" , Color . DARK_GRAY , false ) ; testSP . setVisible ( true ) ; this . function . setOpacity ( testTP ) ; this . function . setOpacity ( testSP ) ; testTP . setPreferredSize ( ( new Dimension ( 80 , 40 ) ) ) ; testSP . setPreferredSize ( ( new Dimension ( 80 , 40 ) ) ) ; final JTextPane timeTP = new JTextPane ( ) ; timeTP . setContentType ( "text/html" ) ; timeTP . setPreferredSize ( new Dimension ( 20 , 15 ) ) ; timeTP . setEditable ( false ) ; timeTP . setOpaque ( false ) ; timeTP . setBorder ( null ) ; final SimpleDateFormat dateFormat = new SimpleDateFormat ( "EEEEE  MMMMM d  yyyy | h:mm:ss a" ) ; new javax . swing . Timer ( 1000 , new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { Calendar date = Calendar . getInstance ( ) ; timeTP . setText ( "<b>" + dateFormat . format ( date . getTime ( ) ) + "</b>" ) ; } } ) . start ( ) ; String [ ] lb1 = { "Patient's General Information" , "Patient's Prescriptions" , "Patient's Anamnesis" , "Patient's Diagnosis" } ; for ( int i = 0 ; i < lb1 . length ; i ++ ) { patientTP [ i ] = new JTextPane ( ) ; patientTP [ i ] . setPreferredSize ( new Dimension ( 600 , 100 ) ) ; patientSP [ i ] = new JScrollPane ( patientTP [ i ] ) ; this . function . setOpacity ( this . patientTP [ i ] ) ; this . function . setOpacity ( patientSP [ i ] ) ; patientSP [ i ] . setPreferredSize ( new Dimension ( 600 , 100 ) ) ; function . makeElementWithBorder ( patientSP [ i ] , lb1 [ i ] , Color . DARK_GRAY , false ) ; patientSP [ i ] . setVisible ( true ) ; } String [ ] lb = { "Patient" , "Patient's birth date" } ; patientTF = new JTextField [ lb . length ] ; for ( int i = 0 ; i < lb . length ; i ++ ) { patientTF [ i ] = new JTextField ( 15 ) ; function . makeElementWithBorder ( patientTF [ i ] , lb [ i ] , Color . DARK_GRAY , false ) ; patientTF [ i ] . setOpaque ( false ) ; } patientTF [ 1 ] . setPreferredSize ( new Dimension ( 80 , 40 ) ) ; ptPane . add ( timeTP , new GridBagConstraints ( 0 , 0 , 1 , 1 , 0.5 , 0 , GridBagConstraints . CENTER , GridBagConstraints . BOTH , new Insets ( 15 , 15 , 15 , 15 ) , 0 , 0 ) ) ; ptPane . add ( tpLoggedStaff , new GridBagConstraints ( 0 , 0 , 1 , 1 , 0 , 0 , GridBagConstraints . NORTHWEST , GridBagConstraints . BOTH , new Insets ( 50 , 15 , 0 , 15 ) , 0 , 0 ) ) ; ptPane . add ( patientTF [ 0 ] , new GridBagConstraints ( 1 , 0 , 2 , 1 , 0.5 , 0 , GridBagConstraints . CENTER , GridBagConstraints . BOTH , new Insets ( 15 , 15 , 15 , 15 ) , 0 , 0 ) ) ; ptPane . add ( patientTF [ 1 ] , new GridBagConstraints ( 3 , 0 , 2 , 1 , 0.2 , 0 , GridBagConstraints . CENTER , GridBagConstraints . BOTH , new Insets ( 15 , 15 , 15 , 15 ) , 0 , 0 ) ) ; ptPane . add ( patientListSP , new GridBagConstraints ( 4 , 1 , 1 , 3 , 0.2 , 0.2 , GridBagConstraints . CENTER , GridBagConstraints . BOTH , new Insets ( 15 , 15 , 15 , 15 ) , 0 , 0 ) ) ; ptPane . add ( testListSP , new GridBagConstraints ( 4 , 4 , 1 , 1 , 0.2 , 0.2 , GridBagConstraints . CENTER , GridBagConstraints . BOTH , new Insets ( 15 , 15 , 15 , 15 ) , 0 , 0 ) ) ; int pozY = 1 ; for ( int i = 0 ; i < lb1 . length ; i ++ ) { ptPane . add ( patientSP [ i ] , new GridBagConstraints ( 0 , pozY , 4 , 2 , 0.5 , 0.5 , GridBagConstraints . CENTER , GridBagConstraints . BOTH , new Insets ( 5 , 5 , 5 , 5 ) , 0 , 0 ) ) ; pozY += 2 ; } ptPane . add ( testSP , new GridBagConstraints ( 4 , 5 , 1 , 4 , 0.5 , 0 , GridBagConstraints . CENTER , GridBagConstraints . BOTH , new Insets ( 15 , 15 , 55 , 15 ) , 0 , 0 ) ) ; this . nextB . setText ( "Next" ) ; this . nextB . addActionListener ( this ) ; ptPane . add ( nextB , new GridBagConstraints ( 4 , 8 , 1 , 1 , 0 , 0.5 , GridBagConstraints . SOUTH , GridBagConstraints . NONE , new Insets ( 0 , 15 , 5 , 15 ) , 0 , 0 ) ) ; new javax . swing . Timer ( 500000 , new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { function . fillPatient ( patient ) ; patientTP [ 0 ] . setText ( null ) ; } } ) . start ( ) ; patientTF [ 0 ] . addKeyListener ( this ) ; patientList . addListSelectionListener ( this ) ; testList . addListSelectionListener ( this ) ; }
tr	3	public static Node mostUnique ( List < Node > neighborhood ) { double greatestError = 0 ; double currentError = 0 ; Node unique = null ; for ( Node current : neighborhood ) { currentError = calculateError ( current , neighborhood ) ; if ( currentError >= greatestError ) { greatestError = currentError ; unique = current ; } } if ( unique != null ) { greatestError /= ( neighborhood . size ( ) - 1 ) ; unique . setError ( greatestError ) ; } else { System . out . println ( neighborhood . size ( ) ) ; } return unique ; }
tr	7	public void insert ( int s , int d ) { if ( s > d ) { dummy . s = s ; dummy . d = d ; } else { dummy . s = d ; dummy . d = s ; } if ( root == null ) { root = template . newNode ( s , d , NodeColor . RED , null , null ) ; insertCase1 ( root ) ; } else { LinkSetNode n = root ; while ( true ) { compResult = dummy . compareTo ( n ) ; if ( compResult == 0 ) { n . foundMatch ( dummy ) ; return ; } else if ( compResult < 0 ) { if ( n . left == null ) { n . left = template . newNode ( s , d , NodeColor . RED , null , null ) ; n . left . parent = n ; insertCase1 ( n . left ) ; break ; } else { n = n . left ; } } else { assert compResult > 0 ; if ( n . right == null ) { n . right = template . newNode ( s , d , NodeColor . RED , null , null ) ; n . right . parent = n ; insertCase1 ( n . right ) ; break ; } else { n = n . right ; } } } } size ++ ; }
tr	5	private final void isaac ( ) { int i , x , y ; b += ++ c ; for ( i = 0 ; i < SIZE ; ++ i ) { x = mem [ i ] ; switch ( i & 3 ) { case 0 : a ^= a << 13 ; break ; case 1 : a ^= a >>> 6 ; break ; case 2 : a ^= a << 2 ; break ; case 3 : a ^= a >>> 16 ; break ; } a += mem [ ( i + SIZE / 2 ) & ( SIZE - 1 ) ] ; mem [ i ] = y = mem [ ( ( x ) & MASK ) >> 2 ] + a + b ; rsl [ i ] = b = mem [ ( ( y >> SIZEL ) & MASK ) >> 2 ] + x ; } }
tr	6	protected void addSnapshot ( ) { boolean isDuplicate ; String strSnapshot ; do { strSnapshot = JOptionPane . showInputDialog ( this , "Please enter a name for this snapshot:" , "Dust & Magnet - Snapshot" , JOptionPane . QUESTION_MESSAGE ) ; if ( strSnapshot == null ) return ; isDuplicate = false ; for ( int i = 0 ; i < mnuSnapshot . getItemCount ( ) ; i ++ ) { JMenuItem m = mnuSnapshot . getItem ( i ) ; if ( m == null ) continue ; if ( strSnapshot . equalsIgnoreCase ( m . getText ( ) ) == true ) { isDuplicate = true ; break ; } } if ( isDuplicate == true ) { JOptionPane . showMessageDialog ( this , "Snapshot (\"" + strSnapshot + "\") already exist. Please try another name for a snapshot." , "Dust & Magnet - Snapshot" , JOptionPane . WARNING_MESSAGE ) ; } } while ( isDuplicate == true ) ; addSnapshot ( strSnapshot ) ; }
tr	0	public void showAddAnimalDialog ( ) { setup ( ) ; }
