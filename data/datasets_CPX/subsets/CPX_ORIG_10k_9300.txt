te	9	public static String removeDotSegments ( String path , boolean hasAuthority ) { String rval = "" ; if ( path . indexOf ( "/" ) == 0 ) { rval = "/" ; } final List < String > input = new ArrayList < String > ( Arrays . asList ( path . split ( "/" ) ) ) ; if ( path . endsWith ( "/" ) ) { input . add ( "" ) ; } final List < String > output = new ArrayList < String > ( ) ; for ( int i = 0 ; i < input . size ( ) ; i ++ ) { if ( "." . equals ( input . get ( i ) ) || ( "" . equals ( input . get ( i ) ) && input . size ( ) - i > 1 ) ) { continue ; } if ( ".." . equals ( input . get ( i ) ) ) { if ( hasAuthority || ( output . size ( ) > 0 && ! ".." . equals ( output . get ( output . size ( ) - 1 ) ) ) ) { if ( output . size ( ) > 0 ) { output . remove ( output . size ( ) - 1 ) ; } } else { output . add ( ".." ) ; } continue ; } output . add ( input . get ( i ) ) ; } if ( output . size ( ) > 0 ) { rval += output . get ( 0 ) ; for ( int i = 1 ; i < output . size ( ) ; i ++ ) { rval += "/" + output . get ( i ) ; } } return rval ; }
te	2	public void method290 ( int i , int k , int l , int i1 ) { Ground class30_sub3 = groundArray [ i1 ] [ l ] [ i ] ; if ( class30_sub3 == null ) return ; Object2 class26 = class30_sub3 . obj2 ; if ( class26 != null ) { int j1 = l * 128 + 64 ; int k1 = i * 128 + 64 ; class26 . anInt500 = j1 + ( ( class26 . anInt500 - j1 ) * k ) / 16 ; class26 . anInt501 = k1 + ( ( class26 . anInt501 - k1 ) * k ) / 16 ; } }
te	1	private boolean r_R1 ( ) { if ( ! ( I_p1 <= cursor ) ) { return false ; } return true ; }
te	0	public WordCountInputFormat ( String filename ) throws IOException { super ( filename ) ; }
te	3	private List < VcsCommit > handleFileRenamesIn ( List < VcsCommit > commits ) { List < VcsCommit > result = new ArrayList < > ( ) ; for ( VcsCommit commit : commits ) { if ( hasPotentialRenames ( commit ) ) { CommandLine commandLine = gitLogRenames ( gitPath , folder , commit . getRevision ( ) ) ; externalSubCommands . add ( commandLine ) ; commandLine . execute ( ) ; if ( isSuccessful ( commandLine ) ) { List < Change > updatedChanges = parseListOfChanges ( commandLine . stdout ( ) , commit . getRevision ( ) , commit . getRevisionBefore ( ) ) ; commit = new Commit ( commit . getRevision ( ) , commit . getRevisionBefore ( ) , commit . getDateTime ( ) , commit . getAuthor ( ) , commit . getMessage ( ) , updatedChanges ) ; } } result . add ( commit ) ; } return result ; }
te	4	@ Override protected void onDisconnect ( ) { if ( ! this . exitFlag ) { LogUtil . info ( "Unexpectedly disconnected. Trying to reconnect." ) ; while ( ! isConnected ( ) ) { try { long time = ApplicationConfig . getLongProp ( CONNECTION_RETRY_TIME ) * 1000 ; Thread . sleep ( time ) ; reconnect ( ) ; joinChannels ( ApplicationConfig . getStringProp ( CHANNELS_KEY ) ) ; } catch ( Exception e ) { LogUtil . error ( "Cannot reconnect  wait " + ( reconnectDelay / 1000 ) + " seconds..." ) ; try { Thread . sleep ( reconnectDelay ) ; } catch ( InterruptedException e1 ) { e1 . printStackTrace ( ) ; } } } } }
te	0	public ParkingSession ( int newSpot , String newusername ) { spot = newSpot ; starttime = Calendar . getInstance ( ) ; user = newusername ; }
te	9	public String find ( String word ) { String LIKES = "Likes" ; String DISLIKES = "Dislikes" ; int [ ] [ ] isContain = new int [ word . length ( ) ] [ 26 ] ; int last = - 1 ; for ( int i = 0 ; i < word . length ( ) ; i ++ ) { int charIndex = word . charAt ( i ) - A ; if ( last == charIndex ) { return DISLIKES ; } else { last = charIndex ; } for ( int j = 0 ; j < i ; j ++ ) { isContain [ j ] [ charIndex ] ++ ; } } for ( int i = 0 ; i < word . length ( ) - 2 ; i ++ ) { for ( int j = i + 2 ; j < word . length ( ) ; j ++ ) { if ( word . charAt ( i ) == word . charAt ( j ) ) { for ( int k = 0 ; k < 26 ; k ++ ) { if ( ( isContain [ i ] [ k ] - isContain [ j - 1 ] [ k ] ) > 0 && isContain [ j ] [ k ] > 0 ) { return DISLIKES ; } } } } } return LIKES ; }
te	7	public boolean sumExists ( final int [ ] intArray , final int sum ) { if ( intArray == null ) { System . out . println ( "array is null" ) ; return false ; } if ( intArray . length == 0 || intArray . length == 1 ) { System . out . println ( "array length is :" + intArray . length ) ; return false ; } Arrays . sort ( intArray ) ; int i = 0 ; int j = intArray . length - 1 ; while ( i < j ) { if ( intArray [ i ] + intArray [ j ] == sum ) { return true ; } else { if ( intArray [ i ] + intArray [ j ] > sum ) j -- ; if ( intArray [ i ] + intArray [ j ] < sum ) i ++ ; } } return false ; }
te	4	private void addLinkTargetIDs ( ArrayList < String > targets , UnitValue uv ) { if ( uv != null ) { String linkId = uv . getLinkTargetId ( ) ; if ( linkId != null ) { targets . add ( linkId ) ; } else { for ( int i = uv . getSubUnitCount ( ) - 1 ; i >= 0 ; i -- ) { UnitValue subUv = uv . getSubUnitValue ( i ) ; if ( subUv . isLinkedDeep ( ) ) addLinkTargetIDs ( targets , subUv ) ; } } } }
te	0	public C_BuyFundAction ( Model model ) { transactionDAO = model . getTransactionDAO ( ) ; fundDAO = model . getFundDAO ( ) ; customerDAO = model . getCustomerDAO ( ) ; }
te	9	private static void decode ( ByteList messageBytes , Object messageObject , List < Method > methods ) throws Exception { class c = messageObject . getClass ( ) ; for ( Method method : methods ) { Deserializer . addTraceLog ( "Deserialize\n\tLooking at method: " + method . getName ( ) ) ; if ( "get" . equals ( method . getName ( ) . substring ( 0 , 3 ) ) ) { Method getMethod = method ; Object returned = Deserializer . invokeGetter ( messageObject , getMethod ) ; class getReturnType = getMethod . getReturnType ( ) ; if ( Deserializer . isIgnoredMessage ( method . getName ( ) ) ) { Deserializer . addTraceLog ( "decode\n\tSkipped method: " + method . getName ( ) ) ; continue ; } Method setMethod = Deserializer . findCorrespondingSet ( c , getMethod , getReturnType ) ; if ( setMethod == null ) { continue ; } Type type = getMethod . getReturnType ( ) ; if ( type == Integer . TYPE ) { int i = messageBytes . getInt ( ) ; Deserializer . invokeSetter ( messageObject , setMethod , i ) ; Deserializer . addTraceLog ( "decode\n\tDeserializing int: " + i ) ; } else if ( type == boolean . TYPE ) { boolean b = messageBytes . getBool ( ) ; Deserializer . invokeSetter ( messageObject , setMethod , b ) ; Deserializer . addTraceLog ( "decode\n\tDeserializing boolean: " + b ) ; } else if ( type == short . TYPE ) { short s = messageBytes . getShort ( ) ; Deserializer . invokeSetter ( messageObject , setMethod , s ) ; Deserializer . addTraceLog ( "decode\n\tDeserializing short: " + s ) ; } else if ( type == String . class ) { String string = messageBytes . getString ( ) ; Deserializer . invokeSetter ( messageObject , setMethod , string ) ; Deserializer . addTraceLog ( "decode\n\tDeserializing String: " + string ) ; } else if ( type == Shell . class ) { Shell shell = Shell . Create ( messageBytes ) ; Deserializer . invokeSetter ( messageObject , setMethod , shell ) ; Deserializer . addTraceLog ( "decode\n\tDeserializing Shell: " + shell ) ; } else if ( type == Fight . class ) { Fight fight = Fight . Create ( messageBytes ) ; Deserializer . invokeSetter ( messageObject , setMethod , fight ) ; Deserializer . addTraceLog ( "decode\n\tDeserializing Fight: " + fight ) ; } else if ( type == Location . class ) { Location location = Location . Create ( messageBytes ) ; Deserializer . invokeSetter ( messageObject , setMethod , location ) ; Deserializer . addTraceLog ( "decode\n\tDeserializing Location: " + location ) ; } else if ( type == Player . class ) { Player player = Player . Create ( messageBytes ) ; Deserializer . invokeSetter ( messageObject , setMethod , player ) ; Deserializer . addTraceLog ( "decode\n\tDeserializing Player: " + player ) ; } else if ( type == Rate . class ) { Rate rate = Rate . Create ( messageBytes ) ; Deserializer . invokeSetter ( messageObject , setMethod , rate ) ; Deserializer . addTraceLog ( "decode\n\tDeserializing Rate: " + rate ) ; } else if ( type == MessageNumber . class ) { MessageNumber messageNumber = MessageNumber . Create ( messageBytes ) ; Deserializer . invokeSetter ( messageObject , setMethod , messageNumber ) ; Deserializer . addTraceLog ( "decode\n\tDeserializing MessageNumber: " + messageNumber ) ; } else if ( returned instanceof DeterminableEnum ) { DeterminableEnum a = messageBytes . getEnum ( ( DeterminableEnum ) returned ) ; Deserializer . invokeSetter ( messageObject , setMethod , a ) ; Deserializer . addTraceLog ( "decode\n\tDeserializing DeterminableEnum: " + a ) ; } else { Deserializer . getLogger ( ) . error ( "Deserializer decode\n\tCannot determine the type of returned" ) ; } } } }
te	4	int get ( int i ) { switch ( i ) { case 1 : return IL ; case 2 : return IS ; case 3 : return JL ; case 4 : return JS ; default : throw new IllegalArgumentException ( "Argument must be from 1 to 4." ) ; } }
te	8	public long GetLargestPrimeFactor ( long maxValue ) { if ( knownPrimes . size ( ) > 0 ) { if ( maxValue < ( knownPrimes . get ( knownPrimes . size ( ) - 1 ) ) ) { for ( int knowPrimeIndex = knownPrimes . size ( ) - 1 ; knowPrimeIndex > 0 ; knowPrimeIndex -- ) { if ( ( knownPrimes . get ( knowPrimeIndex ) <= maxValue ) && ( ( maxValue % ( knownPrimes . get ( knowPrimeIndex ) ) ) == 0 ) ) return knownPrimes . get ( knowPrimeIndex ) ; } } } for ( int i = 2 ; i < maxValue ; i ++ ) { if ( IsPrime ( i ) ) { if ( maxValue % i == 0 ) { return GetLargestPrimeFactor ( maxValue / i ) ; } } } return maxValue ; }
te	9	@ Override public boolean equals ( Object obj ) { if ( obj == null ) { return false ; } if ( getClass ( ) != obj . getClass ( ) ) { return false ; } final Field other = ( Field ) obj ; if ( this . name != other . name && ( this . name == null || ! this . name . equals ( other . name ) ) ) { return false ; } if ( this . supportedTypes != other . supportedTypes && ( this . supportedTypes == null || ! this . supportedTypes . equals ( other . supportedTypes ) ) ) { return false ; } if ( this . required != other . required ) { return false ; } if ( this . notNull != other . notNull ) { return false ; } if ( this . tail != other . tail ) { return false ; } return true ; }
te	8	public boolean isScramble ( String s1 , String s2 ) { if ( s1 . equals ( s2 ) ) return true ; int len = s1 . length ( ) ; int v1 = 0 , v2 = 0 ; for ( int i = 0 ; i < len ; i ++ ) { v1 = v1 + ( int ) s1 . charAt ( i ) ; v2 = v2 + ( int ) s2 . charAt ( i ) ; } if ( v1 != v2 ) return false ; for ( int i = 0 ; i < len - 1 ; i ++ ) { if ( isScramble ( s1 . substring ( 0 , i + 1 ) , s2 . substring ( 0 , i + 1 ) ) && isScramble ( s1 . substring ( i + 1 , len ) , s2 . substring ( i + 1 , len ) ) ) return true ; if ( isScramble ( s1 . substring ( 0 , i + 1 ) , s2 . substring ( len - i - 1 , len ) ) && isScramble ( s1 . substring ( i + 1 , len ) , s2 . substring ( 0 , len - i - 1 ) ) ) return true ; } return false ; }
te	2	public String openDocument ( ) { JFileChooser fc ; if ( currentFile != null ) { fc = new JFileChooser ( currentFile ) ; } else { fc = new JFileChooser ( new File ( defaultPath ) ) ; } int returnVal = fc . showOpenDialog ( null ) ; if ( returnVal == JFileChooser . APPROVE_OPTION ) { currentFile = fc . getSelectedFile ( ) ; return fc . getSelectedFile ( ) . getAbsolutePath ( ) ; } return null ; }
te	1	@ Test public void testWhereFirstAndLastFalse ( ) { Integer [ ] sourceArray = new Integer [ ] { 1 , 2 , 3 , 4 , 5 } ; Enumerable < Integer > enumerable = Enumerable . create ( sourceArray ) . where ( new UnaryFunction < Integer , boolean > ( ) { @ Override public boolean invoke ( Integer arg ) { return ! ( arg == 1 || arg == 5 ) ; } } ) ; List < Integer > resultList = enumerable . toList ( ) ; assertEquals ( resultList . size ( ) , 3 ) ; assertEquals ( resultList . get ( 0 ) . intValue ( ) , 2 ) ; assertEquals ( resultList . get ( 1 ) . intValue ( ) , 3 ) ; assertEquals ( resultList . get ( 2 ) . intValue ( ) , 4 ) ; }
te	7	private static float maximum ( float a , float b , float c , float d ) { if ( a > b ) { if ( a > c ) { return a > d ? a : d ; } else { return c > d ? c : d ; } } else if ( b > c ) { return b > d ? b : d ; } else { return c > d ? c : d ; } }
te	5	public static void mergeTwoArrays ( int [ ] arrA , int [ ] arrB ) { int lengthB = arrB . length - 1 ; int lengthA = 0 ; int i = 0 ; while ( arrA [ i ] != 0 ) i ++ ; lengthA = i - 1 ; System . out . println ( lengthA ) ; int mergedIndex = lengthA + lengthB + 1 ; while ( lengthA >= 0 && lengthB >= 0 ) { if ( arrA [ lengthA ] > arrB [ lengthB ] ) { arrA [ mergedIndex ] = arrA [ lengthA ] ; lengthA -- ; } else { arrA [ mergedIndex ] = arrB [ lengthB ] ; lengthB -- ; } mergedIndex -- ; } while ( lengthB >= 0 ) { arrA [ mergedIndex ] = arrB [ lengthB ] ; mergedIndex -- ; lengthB -- ; } }
te	5	public static String encodeParameters ( PostParameter [ ] httpParams ) { if ( null == httpParams ) { return "" ; } StringBuffer buf = new StringBuffer ( ) ; for ( int j = 0 ; j < httpParams . length ; j ++ ) { if ( httpParams [ j ] . isFile ( ) ) { throw new IllegalArgumentException ( "parameter [" + httpParams [ j ] . name + "]should be text" ) ; } if ( j != 0 ) { buf . append ( "&" ) ; } try { buf . append ( URLEncoder . encode ( httpParams [ j ] . name , "UTF-8" ) ) . append ( "=" ) . append ( URLEncoder . encode ( httpParams [ j ] . value , "UTF-8" ) ) ; } catch ( java . io . UnsupportedEncodingException neverHappen ) { } } return buf . toString ( ) ; }
te	0	public void setCategory ( Category category ) { this . category = category ; }
te	2	public ArrayList < T > getIncidentEdges ( int v ) { if ( v < 0 || v >= numberOfVertices ) { String errorMessage = "Allows vertex indizes are 0.." + ( numberOfVertices - 1 ) + "." ; throw new IllegalArgumentException ( errorMessage ) ; } return adjacencyList [ v ] ; }
te	6	private boolean r_main_suffix ( ) { int among_var ; int v_1 ; int v_2 ; v_1 = limit - cursor ; if ( cursor < I_p1 ) { return false ; } cursor = I_p1 ; v_2 = limit_backward ; limit_backward = cursor ; cursor = limit - v_1 ; ket = cursor ; among_var = find_among_b ( a_0 , 37 ) ; if ( among_var == 0 ) { limit_backward = v_2 ; return false ; } bra = cursor ; limit_backward = v_2 ; switch ( among_var ) { case 0 : return false ; case 1 : slice_del ( ) ; break ; case 2 : if ( ! ( in_grouping_b ( g_s_ending , 98 , 121 ) ) ) { return false ; } slice_del ( ) ; break ; } return true ; }
te	8	public void testMismatchedScopes ( ) { try { new JSONStringer ( ) . key ( "a" ) ; fail ( ) ; } catch ( JSONException e ) { } try { new JSONStringer ( ) . value ( "a" ) ; fail ( ) ; } catch ( JSONException e ) { } try { new JSONStringer ( ) . endObject ( ) ; fail ( ) ; } catch ( JSONException e ) { } try { new JSONStringer ( ) . endArray ( ) ; fail ( ) ; } catch ( JSONException e ) { } try { new JSONStringer ( ) . array ( ) . endObject ( ) ; fail ( ) ; } catch ( JSONException e ) { } try { new JSONStringer ( ) . object ( ) . endArray ( ) ; fail ( ) ; } catch ( JSONException e ) { } try { new JSONStringer ( ) . object ( ) . key ( "a" ) . key ( "a" ) ; fail ( ) ; } catch ( JSONException e ) { } try { new JSONStringer ( ) . object ( ) . value ( false ) ; fail ( ) ; } catch ( JSONException e ) { } }
te	0	@ Test public void testMessageWithTextComma ( ) throws IOException , TemplateException { parseExpression ( "~$message[$firstname \"$last $na:'me\"]~" ) ; assertTokensEquals ( identifier ( "$message" , p ( 1 , 2 ) ) , bracket ( [ , p ( 1 , 10 ) ) , identifier ( "$firstname" , p ( 1 , 11 ) ) , , ( p ( 1 , 21 ) ) , text ( "$last $na:'me" , p ( 1 , 22 ) ) , bracket ( ] , p ( 1 , 37 ) ) ) ; assertElementEquals ( message ( identifier ( "$message" , p ( 1 , 2 ) ) , list ( identifier ( "$firstname" , p ( 1 , 11 ) ) , text ( "$last $na:'me" , p ( 1 , 22 ) ) ) ) ) ; }
te	5	private int getIntCookie ( HttpServletRequest request , String key ) { String value = getCookie ( request , key ) ; if ( value == null || value . length ( ) == 0 ) { return 0 ; } if ( ! StringUtils . isInteger ( value ) ) { if ( "true" . equalsIgnoreCase ( value ) || "yes" . equalsIgnoreCase ( value ) ) { return 1 ; } else { return 0 ; } } return Integer . parseInt ( value ) ; }
te	8	public static int assemble ( int op , int arg1 , int arg2 ) { switch ( op ) { case CHKI : case BEQ : case BNE : case BLT : case BGE : case BLE : case BGT : return F1 ( op , arg1 , 0 , arg2 ) ; case CHK : return F2 ( op , arg1 , 0 , arg2 ) ; default : System . out . println ( "DLX.assemble: wrong opcode for two arg instruction!" ) ; bug ( 1 ) ; return - 1 ; } }
te	2	public Attribute readAttribute ( String line ) { line = line . replaceAll ( "\\t" , " " ) ; line = line . substring ( 10 ) . trim ( ) ; String name ; if ( line . startsWith ( "\"" ) ) { int begin = line . indexOf ( " ) ; int last = line . lastIndexOf ( " ) ; name = line . substring ( begin + 1 , last ) ; } else { name = line . split ( " " ) [ 0 ] ; } line = line . replaceFirst ( name , "" ) . trim ( ) ; Attribute attribute = new Attribute ( name ) ; if ( line . startsWith ( "{" ) ) { line = line . replaceAll ( "\"" , "" ) ; String [ ] values = line . replaceAll ( "\\{" , "" ) . replaceAll ( "\\}" , "" ) . split ( " " ) ; attribute . setType ( Attribute . Type . NOMINAL ) ; attribute . setValues ( Arrays . asList ( values ) ) ; } else { attribute . setType ( Attribute . Type . valueOf ( line . toUpperCase ( ) ) ) ; } return attribute ; }
te	4	public int getAge ( int year , int born ) { int leapDays = 0 ; for ( int i = born + 1 ; i <= year ; i ++ ) { if ( i % 4 == 0 ) { if ( i % 100 == 0 && i % 400 != 0 ) { continue ; } else { leapDays ++ ; } } } return leapDays ; }
te	1	public static void verifyGrav ( Entity ent , AvaloneGLAPI glapi ) { applyGrav ( ent ) ; secureScroll ( glapi , ent , 0 , ent . vitY ) ; if ( ent . vitY <= 0 ) { checkCollisionFromGravity ( ent , glapi , ent . cAround [ 7 ] ) ; } else { checkCollisionFromJump ( ent , glapi , ent . cAround [ 1 ] ) ; } }
te	8	private int jjMoveStringLiteralDfa8_0 ( long old0 , long active0 ) { if ( ( ( active0 &= old0 ) ) == 0 ) return jjMoveNfa_0 ( 0 , 7 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { return jjMoveNfa_0 ( 0 , 7 ) ; } switch ( curChar ) { case 65 : if ( ( active0 & 100000000 ) != 0 ) { jjmatchedKind = 32 ; jjmatchedPos = 8 ; } break ; case 69 : return jjMoveStringLiteralDfa9_0 ( active0 , 2000 ) ; case 97 : if ( ( active0 & 100000000 ) != 0 ) { jjmatchedKind = 32 ; jjmatchedPos = 8 ; } break ; case 101 : return jjMoveStringLiteralDfa9_0 ( active0 , 2000 ) ; default : break ; } return jjMoveNfa_0 ( 0 , 8 ) ; }
te	8	private boolean r_instrum ( ) { int among_var ; ket = cursor ; among_var = find_among_b ( a_3 , 2 ) ; if ( among_var == 0 ) { return false ; } bra = cursor ; if ( ! r_R1 ( ) ) { return false ; } switch ( among_var ) { case 0 : return false ; case 1 : if ( ! r_double ( ) ) { return false ; } break ; case 2 : if ( ! r_double ( ) ) { return false ; } break ; } slice_del ( ) ; if ( ! r_undouble ( ) ) { return false ; } return true ; }
te	2	public void reciveMapsFromServer ( int number_maps ) { try { Socket socket = new Socket ( currentGame . currentGame . ip , Integer . parseInt ( currentGame . currentGame . port ) ) ; OutputStream os = socket . getOutputStream ( ) ; PrintWriter pw = new PrintWriter ( os , true ) ; pw . println ( "REQUEST_MAPS " + number_maps ) ; System . out . println ( "Request for maps sent" ) ; try { InputStream is = socket . getInputStream ( ) ; BufferedReader bufor = new BufferedReader ( new InputStreamReader ( is ) ) ; this . loadMaps ( bufor ) ; bufor . close ( ) ; is . close ( ) ; } catch ( IOException e ) { System . err . println ( "Server exception: " + e ) ; } pw . close ( ) ; os . close ( ) ; socket . close ( ) ; } catch ( IOException e ) { System . out . println ( "B\u0142\u0105d nawi\u0105zania po\u0142\u0105czenia z serwerem. Mapa pobrana z lokalnych \u017Ar\u00F3de\u0142 :)" ) ; System . out . println ( number_maps ) ; currentGame . currentGame . ip = "OFFLINE" ; reciveMapsFromLocalArea ( number_maps ) ; } }
te	0	public boolean release ( Job job , int priority , int delay ) throws BeanstalkcException { return release ( job . getId ( ) , priority , delay ) ; }
te	8	public CreateAccountResult unmarshall ( StaxUnmarshallerContext context ) throws Exception { CreateAccountResult createAccountResult = new CreateAccountResult ( ) ; int originalDepth = context . getCurrentDepth ( ) ; int targetDepth = originalDepth + 1 ; if ( context . isStartOfDocument ( ) ) targetDepth += 2 ; while ( true ) { XMLEvent xmlEvent = context . nextEvent ( ) ; if ( xmlEvent . isEndDocument ( ) ) return createAccountResult ; if ( xmlEvent . isAttribute ( ) || xmlEvent . isStartElement ( ) ) { if ( context . testExpression ( "Account" , targetDepth ) ) { createAccountResult . setAccount ( AccountStaxUnmarshaller . getInstance ( ) . unmarshall ( context ) ) ; continue ; } } else if ( xmlEvent . isEndElement ( ) ) { if ( context . getCurrentDepth ( ) < originalDepth ) { return createAccountResult ; } } } }
te	7	@ Test public void process ( ) { TestProcessor processor = new TestProcessor ( ) ; processor . start ( ) ; Event < String > event1 = new Event < String > ( ) ; event1 . trigger ( "pre-subscribe" ) ; assertThat ( processor . getProcessedEvents ( ) . size ( ) , is ( 0 ) ) ; processor . subscribe ( event1 ) ; event1 . trigger ( "post-subscribe" ) ; synchronized ( processor ) { try { processor . wait ( ) ; } catch ( InterruptedException e ) { } } assertThat ( processor . getProcessedEvents ( ) . size ( ) , is ( 1 ) ) ; assertThat ( processor . getProcessedEvents ( ) . get ( 0 ) , is ( "post-subscribe" ) ) ; processor . getProcessedEvents ( ) . clear ( ) ; event1 . trigger ( "trigger1" ) ; event1 . trigger ( "trigger2" ) ; event1 . trigger ( "trigger3" ) ; synchronized ( processor ) { try { processor . wait ( ) ; } catch ( InterruptedException e ) { } } assertThat ( processor . getProcessedEvents ( ) . size ( ) , is ( 3 ) ) ; assertThat ( processor . getProcessedEvents ( ) . get ( 0 ) , is ( "trigger1" ) ) ; assertThat ( processor . getProcessedEvents ( ) . get ( 1 ) , is ( "trigger2" ) ) ; assertThat ( processor . getProcessedEvents ( ) . get ( 2 ) , is ( "trigger3" ) ) ; processor . getProcessedEvents ( ) . clear ( ) ; Event < String > event2 = new Event < String > ( ) ; processor . subscribe ( event2 ) ; Event < String > event3 = new Event < String > ( ) ; processor . subscribe ( event3 ) ; event1 . trigger ( "event-1-A" ) ; event2 . trigger ( "event-2-A" ) ; event3 . trigger ( "event-3-A" ) ; event1 . trigger ( "event-1-B" ) ; synchronized ( processor ) { try { processor . wait ( ) ; } catch ( InterruptedException e ) { } } assertThat ( processor . getProcessedEvents ( ) . size ( ) , is ( 4 ) ) ; assertThat ( processor . getProcessedEvents ( ) . get ( 0 ) , is ( "event-1-A" ) ) ; assertThat ( processor . getProcessedEvents ( ) . get ( 1 ) , is ( "event-2-A" ) ) ; assertThat ( processor . getProcessedEvents ( ) . get ( 2 ) , is ( "event-3-A" ) ) ; assertThat ( processor . getProcessedEvents ( ) . get ( 3 ) , is ( "event-1-B" ) ) ; processor . getProcessedEvents ( ) . clear ( ) ; processor . unsubscribe ( event1 ) ; event1 . trigger ( "event-1-C" ) ; event2 . trigger ( "event-2-B" ) ; event3 . trigger ( "event-3-B" ) ; synchronized ( processor ) { try { processor . wait ( ) ; } catch ( InterruptedException e ) { } } assertThat ( processor . getProcessedEvents ( ) . size ( ) , is ( 2 ) ) ; assertThat ( processor . getProcessedEvents ( ) . get ( 0 ) , is ( "event-2-B" ) ) ; assertThat ( processor . getProcessedEvents ( ) . get ( 1 ) , is ( "event-3-B" ) ) ; processor . getProcessedEvents ( ) . clear ( ) ; processor . unsubscribe ( event2 ) ; event1 . trigger ( "event-1-D" ) ; event2 . trigger ( "event-2-C" ) ; event3 . trigger ( "event-3-C" ) ; synchronized ( processor ) { try { processor . wait ( ) ; } catch ( InterruptedException e ) { } } assertThat ( processor . getProcessedEvents ( ) . size ( ) , is ( 1 ) ) ; assertThat ( processor . getProcessedEvents ( ) . get ( 0 ) , is ( "event-3-C" ) ) ; processor . getProcessedEvents ( ) . clear ( ) ; processor . unsubscribe ( event3 ) ; event1 . trigger ( "event-1-E" ) ; event2 . trigger ( "event-2-D" ) ; event3 . trigger ( "event-3-D" ) ; Thread . yield ( ) ; assertThat ( processor . getProcessedEvents ( ) . size ( ) , is ( 0 ) ) ; processor . unsubscribe ( event1 ) ; processor . subscribe ( event1 ) ; event1 . trigger ( "pre-halt" ) ; try { Thread . sleep ( 10 ) ; } catch ( InterruptedException e ) { } processor . halt ( ) ; try { processor . join ( ) ; } catch ( InterruptedException e ) { } event1 . trigger ( "post-halt" ) ; assertThat ( processor . getProcessedEvents ( ) . size ( ) , is ( 1 ) ) ; assertThat ( processor . getProcessedEvents ( ) . get ( 0 ) , is ( "pre-halt" ) ) ; }
te	3	public Set < String > filterOutDescriptors ( Set < String > rNouns , Set < String > rDescriptors ) { Set < String > filtedNouns = new HashSet < String > ( ) ; Iterator < String > iter = rNouns . iterator ( ) ; while ( iter . hasNext ( ) ) { String noun = iter . next ( ) ; noun = noun . toLowerCase ( ) ; Pattern p = Pattern . compile ( "\\b(" + this . myLearnerUtility . getConstant ( ) . PREPOSITION + "|" + this . myLearnerUtility . getConstant ( ) . STOP + ")\\b" , Pattern . CASE_INSENSITIVE ) ; Matcher m = p . matcher ( noun ) ; if ( ( ! m . lookingAt ( ) ) && ( ! rDescriptors . contains ( noun ) ) ) { filtedNouns . add ( noun ) ; } } return filtedNouns ; }
te	0	public Object getElementAt ( int index ) { return model . toArray ( ) [ index ] ; }
te	1	@ Override public boolean cancel ( boolean mayInterruptIfRunning ) { lock . lock ( ) ; try { if ( cancelled ) { return false ; } cancelled = true ; dataReady . signalAll ( ) ; } finally { lock . unlock ( ) ; } return true ; }
te	5	public < U > Enumerable < U > selectMany ( final UnaryFunction < T , Enumerable < U >> selector ) { return new Enumerable < U > ( ) { Enumerable < U > buffer = null ; @ Override public boolean hasNext ( ) { while ( ( buffer == null || ! buffer . hasNext ( ) ) && Enumerable . this . hasNext ( ) ) { buffer = selector . invoke ( Enumerable . this . next ( ) ) ; } return buffer != null && buffer . hasNext ( ) ; } @ Override public U next ( ) { if ( ! hasNext ( ) ) { throw new NoSuchElementException ( ) ; } return buffer . next ( ) ; } @ Override public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; }
te	2	public Question getQuestion ( int questionNumber ) { Question res = null ; if ( ( questionNumber >= 0 ) && ( questionNumber < questions . size ( ) ) ) { res = this . questions . get ( questionNumber ) ; } return res ; }
te	3	public static Throwable unwrap ( Throwable e ) { Throwable unwrapp = e ; while ( true ) { if ( unwrapp instanceof InvocationTargetException ) { unwrapp = ( ( InvocationTargetException ) unwrapp ) . getTargetException ( ) ; } else if ( unwrapp instanceof UndeclaredThrowableException ) { unwrapp = ( ( UndeclaredThrowableException ) unwrapp ) . getUndeclaredThrowable ( ) ; } else { return unwrapp ; } } }
te	4	public ProfesorBean get ( ProfesorBean oProfesorBean ) throws Exception { if ( oProfesorBean . getId ( ) > 0 ) { try { oMysql . conexion ( enumTipoConexion ) ; if ( ! oMysql . existsOne ( "profesor" , oProfesorBean . getId ( ) ) ) { oProfesorBean . setId ( 0 ) ; } else { oProfesorBean . setId_usuario ( Integer . parseInt ( oMysql . getOne ( "profesor" , "id_usuario" , oProfesorBean . getId ( ) ) ) ) ; oProfesorBean . setDni ( oMysql . getOne ( "profesor" , "dni" , oProfesorBean . getId ( ) ) ) ; oProfesorBean . setNombre ( oMysql . getOne ( "profesor" , "nombre" , oProfesorBean . getId ( ) ) ) ; oProfesorBean . setApe1 ( oMysql . getOne ( "profesor" , "ape1" , oProfesorBean . getId ( ) ) ) ; oProfesorBean . setApe2 ( oMysql . getOne ( "profesor" , "ape2" , oProfesorBean . getId ( ) ) ) ; oProfesorBean . setSexo ( oMysql . getOne ( "profesor" , "sexo" , oProfesorBean . getId ( ) ) ) ; oProfesorBean . setTelefono ( oMysql . getOne ( "profesor" , "telefono" , oProfesorBean . getId ( ) ) ) ; oProfesorBean . setEmail ( oMysql . getOne ( "profesor" , "email" , oProfesorBean . getId ( ) ) ) ; String strId_usuario = oMysql . getOne ( "profesor" , "id_usuario" , oProfesorBean . getId ( ) ) ; if ( strId_usuario != null ) { UsuarioBean oUsuarioBean = new UsuarioBean ( ) ; oProfesorBean . setUsuario ( oUsuarioBean ) ; oProfesorBean . getUsuario ( ) . setId ( Integer . parseInt ( strId_usuario ) ) ; UsuarioDao oUsuarioDao = new UsuarioDao ( enumTipoConexion ) ; oProfesorBean . setUsuario ( oUsuarioDao . get ( oProfesorBean . getUsuario ( ) ) ) ; } } } catch ( Exception e ) { throw new Exception ( "ProfesorDao.getoProfesor: Error: " + e . getMessage ( ) ) ; } finally { oMysql . desconexion ( ) ; } } else { oProfesorBean . setId ( 0 ) ; } return oProfesorBean ; }
te	5	public LinkedList < State > bfs ( ) { LinkedList < Node > frontier = new LinkedList < Node > ( ) ; LinkedList < State > solution = new LinkedList < State > ( ) ; frontier . addLast ( new Node ( new State ( ) , null , 0 ) ) ; visited = new HashSet < Integer > ( ) ; while ( ! frontier . isEmpty ( ) ) { Node current = frontier . removeFirst ( ) ; if ( goalTest ( current . state ) ) { for ( Node node = current ; node != null ; node = node . parent ) { solution . addFirst ( node . state ) ; } return solution ; } ArrayList < State > childs = findChildren ( current . state ) ; for ( int i = 0 ; i < childs . size ( ) ; i ++ ) { if ( ! visited . contains ( childs . get ( i ) . get ( ) ) ) { frontier . addLast ( new Node ( childs . get ( i ) , current , current . distance + 1 ) ) ; visited . add ( childs . get ( i ) . get ( ) ) ; } } } return null ; }
te	6	public char next ( ) throws JSONException { int c ; if ( this . usePrevious ) { this . usePrevious = false ; c = this . previous ; } else { try { c = this . reader . read ( ) ; } catch ( IOException exception ) { throw new JSONException ( exception ) ; } if ( c <= 0 ) { this . eof = true ; c = 0 ; } } this . index += 1 ; if ( this . previous == '' ) { this . line += 1 ; this . character = c == '' ? 0 : 1 ; } else if ( c == '' ) { this . line += 1 ; this . character = 0 ; } else { this . character += 1 ; } this . previous = ( char ) c ; return this . previous ; }
te	8	@ Override public void addColumn ( TableColumn column ) { super . addColumn ( column ) ; switch ( getColumnCount ( ) ) { case 1 : column . setPreferredWidth ( 400 ) ; break ; case 2 : column . setPreferredWidth ( 80 ) ; break ; case 3 : column . setPreferredWidth ( 50 ) ; break ; case 4 : column . setPreferredWidth ( 40 ) ; break ; case 5 : column . setPreferredWidth ( 40 ) ; break ; case 6 : column . setPreferredWidth ( 80 ) ; break ; case 7 : column . setPreferredWidth ( 80 ) ; break ; case 8 : column . setPreferredWidth ( 80 ) ; break ; } }
te	1	@ Override public int getRowCount ( ) { if ( levels == null ) return 0 ; return levels . size ( ) ; }
te	0	private int getAbilityBonus ( int score ) { return ( score / 2 ) - 5 ; }
te	9	public void patientHistoryC ( JPanel ptPane , int loggedId ) { StringBuffer loggedUser = new StringBuffer ( ) ; JTextPane tpLoggedStaff = new JTextPane ( ) ; for ( int i = 0 ; i < staff . size ( ) ; i ++ ) { if ( staff . get ( i ) . getId ( ) == loggedId ) { loggedUser . append ( "<b>" + staff . get ( i ) . getLname ( ) ) ; loggedUser . append ( "  " ) ; loggedUser . append ( staff . get ( i ) . getFname ( ) + "</b>" ) ; if ( staff . get ( i ) . getPosition ( ) . equalsIgnoreCase ( "gp" ) ) loggedUser . append ( "  [logged as Dr.]" ) ; else if ( staff . get ( i ) . getPosition ( ) . equalsIgnoreCase ( "ns" ) ) loggedUser . append ( "  [logged as R.N.]" ) ; else if ( staff . get ( i ) . getPosition ( ) . equalsIgnoreCase ( "ma" ) ) loggedUser . append ( "  [logged as Med.As.]" ) ; else if ( staff . get ( i ) . getPosition ( ) . equalsIgnoreCase ( "mo" ) ) loggedUser . append ( "  [logged as Med.Of.]" ) ; } } tpLoggedStaff . setContentType ( "text/html" ) ; tpLoggedStaff . setText ( loggedUser . toString ( ) ) ; this . function . setOpacity ( tpLoggedStaff ) ; tpLoggedStaff . setEditable ( false ) ; for ( int i = 0 ; i < labels . length ; i ++ ) { medTF [ i ] = new JTextField ( 15 ) ; function . makeElementWithBorder ( medTF [ i ] , labels [ i ] , Color . DARK_GRAY , false ) ; medTF [ i ] . setOpaque ( false ) ; } for ( int i = 0 ; i < labelsL . length ; i ++ ) { medL [ i ] = new JLabel ( labelsL [ i ] ) ; } for ( int i = 0 ; i < rbstr . length ; i ++ ) { rb [ i ] = new JRadioButton ( rbstr [ i ] ) ; rb [ i ] . setActionCommand ( Integer . toString ( i ) ) ; rb [ i ] . addItemListener ( this ) ; rb [ i ] . addActionListener ( this ) ; rb [ i ] . setSelected ( false ) ; } for ( int i = 0 ; i < 9 ; i ++ ) { group [ i ] = new ButtonGroup ( ) ; } int j = 0 ; for ( int i = 0 ; i < group . length ; i ++ ) { group [ i ] . add ( rb [ j ++ ] ) ; group [ i ] . add ( rb [ j ++ ] ) ; } final JTextPane timeTP = new JTextPane ( ) ; timeTP . setContentType ( "text/html" ) ; timeTP . setPreferredSize ( new Dimension ( 20 , 15 ) ) ; timeTP . setEditable ( false ) ; timeTP . setOpaque ( false ) ; timeTP . setBorder ( null ) ; final SimpleDateFormat dateFormat = new SimpleDateFormat ( "EEEEE  MMMMM d  yyyy | h:mm:ss a" ) ; new javax . swing . Timer ( 1000 , new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { Calendar date = Calendar . getInstance ( ) ; timeTP . setText ( "<b>" + dateFormat . format ( date . getTime ( ) ) + "</b>" ) ; } } ) . start ( ) ; ptPane . add ( timeTP , new GridBagConstraints ( 0 , 0 , 1 , 1 , 0.5 , 0 , GridBagConstraints . CENTER , GridBagConstraints . BOTH , new Insets ( 15 , 15 , 15 , 15 ) , 0 , 0 ) ) ; ptPane . add ( tpLoggedStaff , new GridBagConstraints ( 0 , 0 , 1 , 1 , 0 , 0 , GridBagConstraints . NORTHWEST , GridBagConstraints . BOTH , new Insets ( 50 , 15 , 0 , 15 ) , 0 , 0 ) ) ; ptPane . add ( medTF [ 0 ] , new GridBagConstraints ( 1 , 0 , 2 , 1 , 0.5 , 0 , GridBagConstraints . CENTER , GridBagConstraints . BOTH , new Insets ( 15 , 15 , 15 , 15 ) , 0 , 0 ) ) ; ptPane . add ( medTF [ 1 ] , new GridBagConstraints ( 3 , 0 , 1 , 1 , 0.5 , 0 , GridBagConstraints . CENTER , GridBagConstraints . BOTH , new Insets ( 15 , 15 , 15 , 15 ) , 0 , 0 ) ) ; ptPane . add ( medL [ 0 ] , new GridBagConstraints ( 0 , 1 , 1 , 1 , 0 , 0.5 , GridBagConstraints . EAST , GridBagConstraints . NONE , new Insets ( 15 , 15 , 15 , 15 ) , 0 , 0 ) ) ; ptPane . add ( rb [ 0 ] , new GridBagConstraints ( 1 , 1 , 1 , 1 , 0 , 0.5 , GridBagConstraints . CENTER , GridBagConstraints . NONE , new Insets ( 15 , 15 , 15 , 15 ) , 0 , 0 ) ) ; ptPane . add ( rb [ 1 ] , new GridBagConstraints ( 1 , 1 , 1 , 1 , 0 , 0.5 , GridBagConstraints . EAST , GridBagConstraints . NONE , new Insets ( 15 , 15 , 15 , 15 ) , 0 , 0 ) ) ; ptPane . add ( medL [ 1 ] , new GridBagConstraints ( 2 , 1 , 1 , 1 , 0.5 , 0.5 , GridBagConstraints . EAST , GridBagConstraints . NONE , new Insets ( 15 , 15 , 15 , 15 ) , 0 , 0 ) ) ; ptPane . add ( rb [ 2 ] , new GridBagConstraints ( 3 , 1 , 1 , 1 , 0 , 0.5 , GridBagConstraints . CENTER , GridBagConstraints . NONE , new Insets ( 15 , 15 , 15 , 15 ) , 0 , 0 ) ) ; ptPane . add ( rb [ 3 ] , new GridBagConstraints ( 3 , 1 , 1 , 1 , 0 , 0.5 , GridBagConstraints . EAST , GridBagConstraints . NONE , new Insets ( 15 , 15 , 15 , 15 ) , 0 , 0 ) ) ; ptPane . add ( medTF [ 2 ] , new GridBagConstraints ( 0 , 2 , 2 , 1 , 0 , 0.5 , GridBagConstraints . NORTHWEST , GridBagConstraints . HORIZONTAL , new Insets ( 15 , 15 , 5 , 15 ) , 0 , 0 ) ) ; ptPane . add ( medTF [ 3 ] , new GridBagConstraints ( 2 , 2 , 2 , 1 , 0 , 0.5 , GridBagConstraints . NORTHWEST , GridBagConstraints . HORIZONTAL , new Insets ( 15 , 15 , 5 , 15 ) , 0 , 0 ) ) ; ptPane . add ( medL [ 2 ] , new GridBagConstraints ( 0 , 3 , 1 , 1 , 0 , 0.5 , GridBagConstraints . EAST , GridBagConstraints . NONE , new Insets ( 15 , 15 , 15 , 15 ) , 0 , 0 ) ) ; ptPane . add ( rb [ 4 ] , new GridBagConstraints ( 1 , 3 , 1 , 1 , 0 , 0.5 , GridBagConstraints . CENTER , GridBagConstraints . NONE , new Insets ( 15 , 15 , 15 , 15 ) , 0 , 0 ) ) ; ptPane . add ( rb [ 5 ] , new GridBagConstraints ( 1 , 3 , 1 , 1 , 0 , 0.5 , GridBagConstraints . EAST , GridBagConstraints . NONE , new Insets ( 15 , 15 , 15 , 15 ) , 0 , 0 ) ) ; ptPane . add ( medL [ 3 ] , new GridBagConstraints ( 2 , 3 , 1 , 1 , 0 , 0 , GridBagConstraints . EAST , GridBagConstraints . NONE , new Insets ( 15 , 15 , 15 , 15 ) , 0 , 0 ) ) ; ptPane . add ( rb [ 6 ] , new GridBagConstraints ( 3 , 3 , 1 , 1 , 0 , 0.5 , GridBagConstraints . CENTER , GridBagConstraints . NONE , new Insets ( 15 , 15 , 15 , 15 ) , 0 , 0 ) ) ; ptPane . add ( rb [ 7 ] , new GridBagConstraints ( 3 , 3 , 1 , 1 , 0 , 0.5 , GridBagConstraints . EAST , GridBagConstraints . NONE , new Insets ( 15 , 15 , 15 , 15 ) , 0 , 0 ) ) ; ptPane . add ( medTF [ 4 ] , new GridBagConstraints ( 0 , 4 , 2 , 1 , 0 , 0.5 , GridBagConstraints . NORTHWEST , GridBagConstraints . HORIZONTAL , new Insets ( 15 , 15 , 5 , 15 ) , 0 , 0 ) ) ; ptPane . add ( medTF [ 5 ] , new GridBagConstraints ( 2 , 4 , 2 , 1 , 0 , 0.5 , GridBagConstraints . NORTHWEST , GridBagConstraints . HORIZONTAL , new Insets ( 15 , 15 , 5 , 15 ) , 0 , 0 ) ) ; ptPane . add ( medL [ 4 ] , new GridBagConstraints ( 0 , 5 , 1 , 1 , 0 , 0.5 , GridBagConstraints . EAST , GridBagConstraints . NONE , new Insets ( 15 , 15 , 15 , 15 ) , 0 , 0 ) ) ; ptPane . add ( rb [ 8 ] , new GridBagConstraints ( 1 , 5 , 1 , 1 , 0 , 0.5 , GridBagConstraints . CENTER , GridBagConstraints . NONE , new Insets ( 15 , 15 , 15 , 15 ) , 0 , 0 ) ) ; ptPane . add ( rb [ 9 ] , new GridBagConstraints ( 1 , 5 , 1 , 1 , 0 , 0.5 , GridBagConstraints . EAST , GridBagConstraints . NONE , new Insets ( 15 , 15 , 15 , 15 ) , 0 , 0 ) ) ; ptPane . add ( medL [ 5 ] , new GridBagConstraints ( 2 , 5 , 1 , 1 , 0 , 0.5 , GridBagConstraints . EAST , GridBagConstraints . NONE , new Insets ( 15 , 15 , 15 , 15 ) , 0 , 0 ) ) ; ptPane . add ( rb [ 10 ] , new GridBagConstraints ( 3 , 5 , 1 , 1 , 0 , 0.5 , GridBagConstraints . WEST , GridBagConstraints . NONE , new Insets ( 15 , 15 , 15 , 15 ) , 0 , 0 ) ) ; ptPane . add ( rb [ 11 ] , new GridBagConstraints ( 3 , 5 , 1 , 1 , 0 , 0.5 , GridBagConstraints . EAST , GridBagConstraints . NONE , new Insets ( 15 , 15 , 15 , 15 ) , 0 , 0 ) ) ; ptPane . add ( medL [ 6 ] , new GridBagConstraints ( 0 , 6 , 1 , 1 , 0 , 0.5 , GridBagConstraints . EAST , GridBagConstraints . NONE , new Insets ( 15 , 15 , 15 , 15 ) , 0 , 0 ) ) ; ptPane . add ( rb [ 12 ] , new GridBagConstraints ( 1 , 6 , 1 , 1 , 0 , 0.5 , GridBagConstraints . CENTER , GridBagConstraints . NONE , new Insets ( 15 , 15 , 15 , 15 ) , 0 , 0 ) ) ; ptPane . add ( rb [ 13 ] , new GridBagConstraints ( 1 , 6 , 1 , 1 , 0 , 0.5 , GridBagConstraints . EAST , GridBagConstraints . NONE , new Insets ( 15 , 15 , 15 , 15 ) , 0 , 0 ) ) ; ptPane . add ( medL [ 7 ] , new GridBagConstraints ( 2 , 6 , 1 , 1 , 0 , 0.5 , GridBagConstraints . EAST , GridBagConstraints . NONE , new Insets ( 15 , 15 , 15 , 15 ) , 0 , 0 ) ) ; ptPane . add ( rb [ 14 ] , new GridBagConstraints ( 3 , 6 , 1 , 1 , 0 , 0.5 , GridBagConstraints . WEST , GridBagConstraints . NONE , new Insets ( 15 , 15 , 15 , 15 ) , 0 , 0 ) ) ; ptPane . add ( rb [ 15 ] , new GridBagConstraints ( 3 , 6 , 1 , 1 , 0 , 0.5 , GridBagConstraints . EAST , GridBagConstraints . NONE , new Insets ( 15 , 15 , 15 , 15 ) , 0 , 0 ) ) ; ptPane . add ( medL [ 8 ] , new GridBagConstraints ( 0 , 7 , 1 , 1 , 0 , 0.5 , GridBagConstraints . EAST , GridBagConstraints . NONE , new Insets ( 15 , 15 , 15 , 15 ) , 0 , 0 ) ) ; ptPane . add ( rb [ 16 ] , new GridBagConstraints ( 1 , 7 , 1 , 1 , 0 , 0.5 , GridBagConstraints . CENTER , GridBagConstraints . NONE , new Insets ( 15 , 15 , 15 , 15 ) , 0 , 0 ) ) ; ptPane . add ( rb [ 17 ] , new GridBagConstraints ( 1 , 7 , 1 , 1 , 0 , 0.5 , GridBagConstraints . EAST , GridBagConstraints . NONE , new Insets ( 15 , 15 , 15 , 15 ) , 0 , 0 ) ) ; ptPane . add ( medL [ 9 ] , new GridBagConstraints ( 0 , 8 , 4 , 1 , 0 , 0.5 , GridBagConstraints . NORTHWEST , GridBagConstraints . NONE , new Insets ( 15 , 15 , 15 , 15 ) , 0 , 0 ) ) ; int pozY = 9 , pozX = - 1 ; for ( int i = 7 ; i < labels . length ; i ++ ) { ptPane . add ( medTF [ i ] , new GridBagConstraints ( ++ pozX , pozY , 1 , 1 , 1 , 1 , GridBagConstraints . NORTHWEST , GridBagConstraints . HORIZONTAL , new Insets ( 5 , 15 , 5 , 15 ) , 0 , 0 ) ) ; if ( ( i + 2 ) % 4 == 0 ) { pozY ++ ; pozX = - 1 ; } } submitB . setText ( "Submit" ) ; submitB . addActionListener ( this ) ; ptPane . add ( submitB , new GridBagConstraints ( 3 , 11 , 1 , 1 , 0 , 0.5 , GridBagConstraints . LAST_LINE_END , GridBagConstraints . NONE , new Insets ( 5 , 15 , 15 , 15 ) , 0 , 0 ) ) ; this . PFPanel . addChangeListener ( this ) ; }
te	5	public static Frame getOwningFrame ( Object o ) { if ( o instanceof EventObject ) { o = ( ( EventObject ) o ) . getSource ( ) ; } if ( ! ( o instanceof Component ) ) { throw new IllegalArgumentException ( "o did not yield a Component" ) ; } do { if ( o instanceof JPopupMenu ) { o = ( ( JPopupMenu ) o ) . getInvoker ( ) ; } if ( o instanceof Frame ) { return ( Frame ) o ; } o = ( ( Component ) o ) . getParent ( ) ; } while ( o != null ) ; throw new IllegalArgumentException ( "o is not a child of any Frame" ) ; }
te	9	private void adjustMinPrefForSpanningComps ( DimConstraint [ ] specs , float [ ] defPush , FlowSizeSpec fss , ArrayList < LinkedDimGroup > [ ] groupsLists ) { for ( int r = groupsLists . length - 1 ; r >= 0 ; r -- ) { ArrayList < LinkedDimGroup > groups = groupsLists [ r ] ; for ( LinkedDimGroup group : groups ) { if ( group . span == 1 ) continue ; int [ ] sizes = group . getMinPrefMax ( ) ; for ( int s = LayoutUtil . MIN ; s <= LayoutUtil . PREF ; s ++ ) { int cSize = sizes [ s ] ; if ( cSize == LayoutUtil . NOT_SET ) continue ; int rowSize = 0 ; int sIx = ( r << 1 ) + 1 ; int len = Math . min ( ( group . span << 1 ) , fss . sizes . length - sIx ) - 1 ; for ( int j = sIx ; j < sIx + len ; j ++ ) { int sz = fss . sizes [ j ] [ s ] ; if ( sz != LayoutUtil . NOT_SET ) rowSize += sz ; } if ( rowSize < cSize && len > 0 ) { for ( int eagerness = 0 , newRowSize = 0 ; eagerness < 4 && newRowSize < cSize ; eagerness ++ ) newRowSize = fss . expandSizes ( specs , defPush , cSize , sIx , len , s , eagerness ) ; } } } } }
te	2	@ Override public void keyPressed ( KeyEvent e ) { int key = e . getKeyCode ( ) ; if ( key == KeyEvent . VK_LEFT ) { mb . body . applyForceToCenter ( new Vec2 ( - 1000 , 0 ) ) ; } if ( key == KeyEvent . VK_RIGHT ) { mb . body . applyForceToCenter ( new Vec2 ( 1000 , 0 ) ) ; } }
te	3	public boolean isSet ( String key ) { if ( key == null ) throw new IllegalArgumentException ( class + ": key may not be null" ) ; if ( ! keys . containsKey ( key ) ) throw new IllegalArgumentException ( class + ": unknown key: " + key ) ; return keys . get ( key ) . getResultCount ( ) > 0 ? true : false ; }
te	3	@ Override public int indexOf ( Object o ) { if ( o == null ) { throw new RuntimeException ( "Wrong parameter: null" ) ; } Node position = this . head ; int i = 0 ; while ( position . getNextNode ( ) != this . tail ) { position = position . getNextNode ( ) ; if ( o == position . getValue ( ) ) return i ; i ++ ; } return - 1 ; }
te	7	public IGraph add ( IPath path , Object value , String type ) { IGraph node = this , tmpNode ; while ( path . next ( ) ) { String e = path . getElement ( ) ; tmpNode = node . getNode ( e ) ; if ( tmpNode == null ) { path . previous ( ) ; break ; } node = tmpNode ; } while ( path . next ( ) ) { String e = path . getElement ( ) ; Graph g = new Graph ( e ) ; node . add ( g ) ; node = g ; } if ( value instanceof IGraph ) { tmpNode = ( IGraph ) value ; if ( ! _NULL . equals ( tmpNode . getName ( ) ) ) node . add ( tmpNode ) ; else for ( int i = 0 ; i < tmpNode . size ( ) ; i ++ ) { node . add ( tmpNode . get ( i ) ) ; } } else if ( value instanceof String ) node . add ( ( String ) value ) ; else node . add ( _OBJ ) . setValue ( value ) ; return node ; }
te	2	public Quiz retrieveQuiz ( int quizID ) { DBConnection connection = DBConnection . sharedInstance ( ) ; ResultSet result = connection . performQuery ( "SELECT * FROM quizzes WHERE id=" + quizID ) ; try { if ( result . next ( ) ) { ; return getQuizFromResult ( result ) ; } else { return null ; } } catch ( SQLException e ) { e . printStackTrace ( ) ; } return null ; }
te	9	protected JPopupMenu createPopup ( final int row , final int col ) { final JPopupMenu popmen = new JPopupMenu ( ) ; final JMenuItem menu1 = new JMenuItem ( Messages . getString ( "MainFrame.AddSchoolclass" ) ) ; final JMenuItem menu2 = new JMenuItem ( Messages . getString ( "MainFrame.RemoveSchoolclass" ) ) ; final JMenuItem menu3 = new JMenuItem ( Messages . getString ( "MainFrame.AddSubject" ) ) ; final JMenuItem menu4 = new JMenuItem ( Messages . getString ( "MainFrame.RemoveSubject" ) ) ; final JMenuItem menu5 = new JMenuItem ( Messages . getString ( "MainFrame.EditSubject" ) ) ; menu1 . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( final ActionEvent event ) { addSchoolclassDialog . setTimeslot ( Weekday . values ( ) [ col ] , row , teacher ) ; addSchoolclassDialog . setVisible ( true ) ; } } ) ; menu2 . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( final ActionEvent event ) { teacher . addWorkingHours ( - Timeslot . LENGTH / 60 ) ; try { Timeslot timeslot = TimetableManager . getTimeslotAt ( Weekday . values ( ) [ col ] , row , teacher ) ; boolean deleted = false ; for ( Schoolclass sc : timeslot . getSchoolclasses ( ) ) { Timeslot ts = Data . getDayTableForWeekday ( Weekday . values ( ) [ col ] , sc ) . getTimeslot ( row ) ; for ( Teacher t : ts . getTeachers ( ) ) { if ( t . getName ( ) == teacher . getName ( ) ) ts . getTeachers ( ) . clear ( ) ; timeslot . getSchoolclasses ( ) . clear ( ) ; deleted = true ; break ; } if ( deleted == true ) { break ; } } } catch ( DatasetException e ) { e . printStackTrace ( ) ; } } } ) ; menu3 . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( final ActionEvent event ) { try { Timeslot timeslot = TimetableManager . getTimeslotAt ( Weekday . values ( ) [ col ] , row , teacher ) ; if ( ! timeslot . getSubjectAcronymList ( ) . equals ( "" ) ) { JOptionPane . showMessageDialog ( menu1 , "Dort ist bereits ein Fach eingetragen!" , "Fehler" , JOptionPane . PLAIN_MESSAGE ) ; } else { addSubjectDialog . setTimeslot ( Weekday . values ( ) [ col ] , row , teacher ) ; addSubjectDialog . setVisible ( true ) ; } } catch ( DatasetException e ) { e . printStackTrace ( ) ; } } } ) ; menu4 . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( final ActionEvent event ) { try { Timeslot timeslot = TimetableManager . getTimeslotAt ( Weekday . values ( ) [ col ] , row , teacher ) ; boolean deleted = false ; for ( Schoolclass sc : timeslot . getSchoolclasses ( ) ) { Timeslot ts = Data . getDayTableForWeekday ( Weekday . values ( ) [ col ] , sc ) . getTimeslot ( row ) ; for ( Teacher t : ts . getTeachers ( ) ) { if ( t . getName ( ) == teacher . getName ( ) ) ts . getSubjects ( ) . clear ( ) ; timeslot . getSubjects ( ) . clear ( ) ; deleted = true ; break ; } if ( deleted == true ) { break ; } } } catch ( DatasetException e ) { e . printStackTrace ( ) ; } } } ) ; menu5 . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( final ActionEvent event ) { try { Timeslot timeslot = TimetableManager . getTimeslotAt ( Weekday . values ( ) [ col ] , row , teacher ) ; if ( timeslot . getSubjectAcronymList ( ) == null ) { JOptionPane . showMessageDialog ( menu4 , "Dort ist kein Fach zum editieren!" , "Fehler" , JOptionPane . PLAIN_MESSAGE ) ; } else { editSubjectDialog . setTimeslot ( Weekday . values ( ) [ col ] , row , teacher ) ; editSubjectDialog . setVisible ( true ) ; } } catch ( DatasetException e ) { e . printStackTrace ( ) ; } } } ) ; popmen . add ( menu1 ) ; popmen . add ( menu2 ) ; popmen . add ( menu3 ) ; popmen . add ( menu4 ) ; popmen . add ( menu5 ) ; popmen . setVisible ( true ) ; return popmen ; }
te	8	@ Override public void run ( ) { CountDownLatch latch = null ; long lastExtraRequestTime = 0 ; try { while ( fetchStatus ) { if ( System . currentTimeMillis ( ) - lastExtraRequestTime >= EXTRA_INFO_DELAY ) { lastExtraRequestTime = System . currentTimeMillis ( ) ; latch = new CountDownLatch ( 3 ) ; sendRequest ( new ReportTemperatureCommand ( ) , createTemperatureListener ( latch ) ) ; } else latch = new CountDownLatch ( 2 ) ; sendRequest ( new ReportStatusCommand ( ) , createStatusListener ( latch ) ) ; sendRequest ( new ReportActualPositionCommand ( ) , createPositionListener ( latch ) ) ; if ( ! latch . await ( ROBOT_TIMEOUT , TimeUnit . MILLISECONDS ) ) throw new TimeoutException ( ) ; else if ( ! connected ) { connected = true ; if ( connectionlistener != null ) connectionlistener . onConnect ( ) ; } } } catch ( Exception ex ) { if ( ex . getClass ( ) == TimeoutException . class ) { if ( connected ) System . err . println ( "Connection to the motors timed out" ) ; } else ex . printStackTrace ( ) ; reset ( ) ; } }
te	0	@ JsonProperty ( "HealthState" ) public Endpoint . HealthState getHealthState ( ) { return HealthState ; }
te	5	public String getProperty ( String var ) { for ( String line : this . lines ) { if ( line . trim ( ) . length ( ) == 0 ) { continue ; } if ( line . charAt ( 0 ) == # ) { continue ; } if ( line . contains ( "=" ) ) { int delimPosition = line . indexOf ( = ) ; String key = line . substring ( 0 , delimPosition ) . trim ( ) ; String value = line . substring ( delimPosition + 1 ) ; if ( key . equals ( var ) ) { return value ; } } else { continue ; } } return "" ; }
te	7	public void joinGroup ( ) { try { this . multicastSocket = new MulticastSocket ( port ) ; InetAddress group = InetAddress . getByName ( this . group ) ; this . multicastSocket . joinGroup ( group ) ; this . isClosed = false ; new Thread ( new Runnable ( ) { @ Override public void run ( ) { System . out . println ( "multicast listener getting ready..." ) ; while ( true ) { if ( ! multicastSocket . isClosed ( ) ) { byte buf [ ] = new byte [ 1024 ] ; DatagramPacket pack = new DatagramPacket ( buf , buf . length ) ; try { multicastSocket . receive ( pack ) ; System . out . println ( "received a packet from multisocket in multicastlistener" ) ; ReliableMessage request = ( ReliableMessage ) MessageTransformer . deserializeMessage ( pack . getData ( ) ) ; Message replyMsg = onMessage ( request ) ; if ( replyMsg . isReply ( ) && replyMsg . isReplyToThisMessage ( ) ) { UDPClient . INSTANCE . send ( replyMsg , 3000 ) ; } } catch ( IOException e ) { e . printStackTrace ( ) ; } catch ( TimeoutException e ) { e . printStackTrace ( ) ; } } } } } ) . start ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }
te	1	public boolean inBounds ( MouseEvent e ) { return ( e . getX ( ) < ( 680 - ( width - size ) ) && e . getY ( ) < ( 680 - ( height - size ) ) ) ; }
te	6	public Set < String > getOrgans ( DataHolder dataholderHandler ) { Set < String > oSet = new HashSet < String > ( ) ; Iterator < SentenceStructure > iterSentence = dataholderHandler . getSentenceHolder ( ) . iterator ( ) ; while ( iterSentence . hasNext ( ) ) { SentenceStructure sentence = iterSentence . next ( ) ; String tag = sentence . getTag ( ) ; if ( tag != null ) { if ( ( ! StringUtils . equals ( tag , "ignore" ) ) && ( ! StringUtility . createMatcher ( tag , ".* .*" ) . find ( ) ) && ( ! StringUtility . createMatcher ( tag , ".*\\[.*" ) . find ( ) ) ) { if ( StringUtility . createMatcher ( tag , "^[a-zA-Z0-9_-]+$" ) . find ( ) ) { oSet . add ( tag ) ; } } } } return oSet ; }
te	1	public void start ( ) { try { ss . accept ( ) ; } catch ( IOException e ) { } }
te	3	public Matrix getH ( ) { Matrix X = new Matrix ( m , n ) ; double [ ] [ ] H = X . getArray ( ) ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i >= j ) { H [ i ] [ j ] = QR [ i ] [ j ] ; } else { H [ i ] [ j ] = 0.0 ; } } } return X ; }
te	1	public static String decodeError ( byte [ ] data ) { String error = "" ; int pos = 1 ; while ( data [ pos ] != 0 ) { error += ( char ) data [ pos ++ ] ; } return error ; }
te	2	public Contact getContactByName ( String aName ) { Contact foundContact = null ; for ( int i = 0 ; i < this . numContacts ; i ++ ) { if ( contacts [ i ] . getName ( ) . trim ( ) . equalsIgnoreCase ( aName ) ) { foundContact = contacts [ i ] ; return foundContact ; } } return null ; }
te	7	public static ChecksumData readChecksum ( String [ ] lines , int index ) { ChecksumData checkSum = new ChecksumData ( ) ; int localIndex = index ; while ( ! lines [ localIndex ] . startsWith ( "SCORE" ) && localIndex < lines . length ) { if ( lines [ localIndex ] . startsWith ( "CHECKSUM=" ) ) { String [ ] kv = lines [ localIndex ] . split ( "=" ) ; String [ ] checksumsString = kv [ 1 ] . split ( " " ) ; if ( checksumsString . length > 0 ) { checkSum . checksums [ 0 ] = long . parseLong ( checksumsString [ 0 ] ) ; if ( checksumsString . length > 1 ) { checkSum . checksums [ 1 ] = long . parseLong ( checksumsString [ 1 ] ) ; } else { checkSum . checksums [ 1 ] = - 1 ; } checkSum . found = true ; } else { checkSum . checksums [ 0 ] = - 1 ; checkSum . checksums [ 1 ] = - 1 ; } } localIndex ++ ; lines [ localIndex ] = lines [ localIndex ] . trim ( ) ; } if ( ! checkSum . found ) { if ( lines [ localIndex ] . startsWith ( "SCORE" ) ) { checkSum . checksums [ 0 ] = - 1 ; checkSum . checksums [ 1 ] = - 1 ; checkSum . found = true ; } } checkSum . index = localIndex ; return checkSum ; }
te	6	@ Override public void process ( Scanner s , CodeParser cp , IfNode n ) { if ( ! Parser . gobble ( Parser . OPENPAREN , s ) ) Parser . fail ( "No opening ( in if" , s ) ; n . setConditional ( new Conditional ( ) . parse ( s , cp , this ) ) ; if ( ! Parser . gobble ( Parser . CLOSEPAREN , s ) ) Parser . fail ( "No closing parenthesis in if statement" , s ) ; n . setBlock ( ( BlockNode ) new BlockNode ( ) . parse ( s , cp , this ) ) ; while ( Parser . gobble ( elseIfPattern , s ) ) { if ( ! Parser . gobble ( Parser . OPENPAREN , s ) ) Parser . fail ( "No opening parenthesis on elif" , s ) ; IfNode elif = new IfNode ( ) ; elif . setConditional ( new Conditional ( ) . parse ( s , cp , this ) ) ; if ( ! Parser . gobble ( Parser . CLOSEPAREN , s ) ) Parser . fail ( "No closing parenthesis in elif statement" , s ) ; elif . setBlock ( ( BlockNode ) new BlockNode ( ) . parse ( s , cp , this ) ) ; n . addElif ( elif ) ; } if ( Parser . gobble ( elsePattern , s ) ) { n . setElse ( ( BlockNode ) new BlockNode ( ) . parse ( s , cp , this ) ) ; } }
te	2	public int cantDiasQueIncluye ( Rango rango ) { int aux = 0 ; int ret = 0 ; Calendar fechaAux = rango . getFechaInicio ( ) ; while ( aux < rango . cantDias ( ) ) { if ( this . incluyeA ( fechaAux ) ) { ret = ret + 1 ; } fechaAux . add ( Calendar . DATE , 1 ) ; aux = aux + 1 ; } return ret ; }
te	5	protected void drawPie ( Graphics2D g , boolean drawLabels ) { if ( ! isValuesFilled ( ) ) { return ; } double startAngle = 0.0 ; double arcAngle = 0.0 ; double xChart ; double yChart ; double chartWidth ; double chartHeight ; chartWidth = getPieWidth ( ) ; chartHeight = getPieHeight ( ) ; if ( chartWidth > chartHeight ) { chartWidth = chartHeight ; } else { chartHeight = chartWidth ; } xChart = getCenterPoint ( getWidth ( ) , chartWidth ) ; yChart = getCenterPoint ( getHeight ( ) , chartHeight ) ; for ( int i = 0 ; i < getValues ( ) . length ; i ++ ) { startAngle = startAngle + arcAngle ; arcAngle = getAngle ( getValues ( ) [ i ] . getValue ( ) ) ; g . setColor ( getColor ( i ) ) ; g . fillArc ( round ( xChart ) , round ( yChart ) , round ( chartWidth ) , round ( chartHeight ) , round ( startAngle ) , round ( arcAngle ) ) ; drawTipsWithArrow ( g , getValues ( ) [ i ] , startAngle , arcAngle , drawLabels ) ; if ( showLegend ) { drawLegend ( g , i ) ; } } if ( getValues ( ) . length > 0 ) { g . setColor ( tipsArrowColor ) ; g . drawOval ( round ( xChart ) , round ( yChart ) , round ( chartWidth ) , round ( chartHeight ) ) ; } }
te	5	@ Override public void run ( ) { this . isRunning = true ; ServerSocket ss = null ; conns = new LinkedList < MapServerConnection > ( ) ; try { ss = new ServerSocket ( port ) ; ss . setSoTimeout ( 1000 ) ; System . out . println ( "Listening..." ) ; while ( isRunning ) { try { Socket connSocket = ss . accept ( ) ; System . out . println ( "Got connection." ) ; MapServerConnection conn = new MapServerConnection ( connSocket , saver , mapViewer ) ; conn . start ( ) ; Map map = mapViewer . getMap ( ) ; if ( map != null ) { conn . onMapEvent ( new MapEvent < Serializable > ( EventType . NEW_MAP , map ) ) ; } conns . add ( conn ) ; } catch ( SocketTimeoutException stoe ) { } } } catch ( Exception ex ) { ex . printStackTrace ( ) ; } System . out . println ( "Stopping..." ) ; for ( MapServerConnection conn : conns ) { conn . close ( ) ; } System . out . println ( "Stopped." ) ; }
te	3	@ Override public boolean hasConnectionTo ( INeuron neuron ) { if ( neuron == null ) throw new IllegalArgumentException ( "Neuron can't be null" ) ; for ( ISynapse synapse : outputSynapses ) if ( synapse . getPostsynaptic ( ) == neuron ) return true ; return false ; }
te	8	public UndirectedGraphNode cloneGraphII ( UndirectedGraphNode node ) { if ( node == null ) return node ; Set < UndirectedGraphNode > set = new HashSet < > ( ) ; Stack < UndirectedGraphNode > unvisited = new Stack < > ( ) ; unvisited . add ( node ) ; while ( ! unvisited . isEmpty ( ) ) { UndirectedGraphNode current = unvisited . pop ( ) ; set . add ( current ) ; for ( UndirectedGraphNode n : current . neighbors ) { if ( n != null && ! set . contains ( n ) ) { unvisited . add ( n ) ; } } } Map < UndirectedGraphNode , UndirectedGraphNode > old2NewMapping = new HashMap < > ( ) ; for ( UndirectedGraphNode old : set ) { UndirectedGraphNode newNode = new UndirectedGraphNode ( old . label ) ; old2NewMapping . put ( old , newNode ) ; } for ( UndirectedGraphNode old : set ) { UndirectedGraphNode newNode = old2NewMapping . get ( old ) ; for ( UndirectedGraphNode neighbor : old . neighbors ) { newNode . neighbors . add ( old2NewMapping . get ( neighbor ) ) ; } } return old2NewMapping . get ( node ) ; }
te	4	private void notifySearchListeners ( ) { String recipeName = recipeList . getSelectedValue ( ) ; boolean match = false ; Recipe foundRecipe = null ; for ( Recipe recipe : recipes ) { if ( recipe . getName ( ) . equals ( recipeName ) ) { foundRecipe = recipe ; match = true ; break ; } } if ( match ) { for ( SearchCompletedListener listener : listeners ) { listener . searchCompleted ( foundRecipe ) ; } } else { showErrorMessage ( "The recipe matching \"" + recipeName + "\" is no longer available  try and open up a new search." , "Recipe unavailable" ) ; } }
te	3	@ CallerMustSynchronize protected void notifySendListeners ( K key , V value ) { Map < SendListener < V > , ListenerValue > listeners = sendListeners . get ( key ) ; if ( listeners == null ) return ; for ( Entry < SendListener < V > , ListenerValue > entry : listeners . entrySet ( ) ) { ListenerValue listenerValue = entry . getValue ( ) ; if ( listenerValue . isAsynchronous ( ) ) { async ( ( ) -> { entry . getKey ( ) . accept ( new SendEvent < > ( mapName , key , value , listenerValue . nextInvocationCount ( ) ) ) ; } ) ; } else { entry . getKey ( ) . accept ( new SendEvent < > ( mapName , key , value , listenerValue . nextInvocationCount ( ) ) ) ; } } }
te	0	public boolean isZero ( ) { return compareTo ( ZERO ) == 0 ; }
te	2	private void checkMove ( final PathSource pathSource , final HashSet < Point > marks , final ArrayList < Node > queue , final Node p , final int w , final int h ) { final int dx = p . x + w ; final int dy = p . y + h ; final Point pos = new Point ( dx , dy ) ; if ( pathSource . isMoveAllowed ( p . x , p . y , dx , dy ) && marks . contains ( pos ) == false ) { queue . add ( new Node ( dx , dy , p ) ) ; marks . add ( pos ) ; } }
te	4	public boolean startGame ( ) { if ( isStarted ( ) ) return false ; while ( ! isReady ( ) ) { setBuffers ( ) ; } ArrayList < Point > positions = new ArrayList < Point > ( ) ; for ( Player player : playerList ) positions . add ( player . getBoardPosition ( ) ) ; board . generateBoard ( positions ) ; start = new Date ( ) ; do { setBuffers ( ) ; update ( ) ; } while ( ! isOver ( ) ) ; end = new Date ( ) ; return true ; }
te	4	private AVLNode rotateRightLeft ( AVLNode parent ) { AVLNode parentNode = parent ; AVLNode current = ( AVLNode ) parentNode . right ; AVLNode moveToTop = ( AVLNode ) current . left ; AVLNode RLR = ( AVLNode ) moveToTop . right ; AVLNode RLL = ( AVLNode ) moveToTop . left ; if ( parent . parent == null ) { this . overallRoot = moveToTop ; ; moveToTop . parent = null ; } else if ( parent . parent . right == parent ) { parent . parent . right = moveToTop ; moveToTop . parent = parent . parent ; } else { parent . parent . left = moveToTop ; moveToTop . parent = parent . parent ; } current . left = RLR ; if ( RLR != null ) { RLR . parent = current ; } parent . right = RLL ; if ( RLL != null ) { RLL . parent = parent ; } moveToTop . right = current ; moveToTop . left = parent ; current . parent = moveToTop ; parent . parent = moveToTop ; return moveToTop ; }
te	0	public void setHolesAllowedInFiles ( boolean holesAllowedInFiles ) { this . holesAllowedInFiles = holesAllowedInFiles ; }
te	9	public Coordinate move ( Direction dir , Coordinate coor ) { switch ( dir ) { case NORTH : { Coordinate newCoord = new Coordinate ( coor . getRow ( ) - 1 , coor . getCol ( ) ) ; if ( validCoordinate ( newCoord ) ) { return newCoord ; } } case SOUTH : { Coordinate newCoord = new Coordinate ( coor . getRow ( ) + 1 , coor . getCol ( ) ) ; if ( validCoordinate ( newCoord ) ) { return newCoord ; } } case EAST : { Coordinate newCoord = new Coordinate ( coor . getRow ( ) , coor . getCol ( ) + 1 ) ; if ( validCoordinate ( newCoord ) ) { return newCoord ; } } case WEST : { Coordinate newCoord = new Coordinate ( coor . getRow ( ) , coor . getCol ( ) - 1 ) ; if ( validCoordinate ( newCoord ) ) { return newCoord ; } } case STOP : { return coor ; } } return null ; }
te	6	public synchronized void insert ( Topic topic ) throws ContentStoreException , DBConnectionException { while ( true ) { try { for ( Post post : topic . getPosts ( ) ) { int c = 1 ; updateStmt . setString ( c ++ , post . getComment ( ) ) ; updateStmt . setBoolean ( c ++ , post . isDeleted ( ) ) ; updateStmt . setString ( c ++ , post . getMediaFilename ( ) ) ; updateStmt . setBoolean ( c ++ , post . isSticky ( ) ) ; updateStmt . setBoolean ( c ++ , post . isClosed ( ) ) ; updateStmt . setInt ( c ++ , post . getNum ( ) ) ; updateStmt . setInt ( c , post . getSubnum ( ) ) ; updateStmt . addBatch ( ) ; c = 1 ; insertStmt . setInt ( c ++ , post . getPosterIp ( ) ) ; insertStmt . setInt ( c ++ , post . getNum ( ) ) ; insertStmt . setInt ( c ++ , post . getSubnum ( ) ) ; insertStmt . setInt ( c ++ , post . getThreadNum ( ) ) ; insertStmt . setBoolean ( c ++ , post . isOp ( ) ) ; insertStmt . setInt ( c ++ , ( int ) post . getDate ( ) ) ; insertStmt . setString ( c ++ , post . getPreviewOrig ( ) ) ; insertStmt . setInt ( c ++ , post . getPreviewW ( ) ) ; insertStmt . setInt ( c ++ , post . getPreviewH ( ) ) ; insertStmt . setString ( c ++ , post . getMediaFilename ( ) ) ; insertStmt . setInt ( c ++ , post . getMediaW ( ) ) ; insertStmt . setInt ( c ++ , post . getMediaH ( ) ) ; insertStmt . setInt ( c ++ , post . getMediaSize ( ) ) ; insertStmt . setString ( c ++ , post . getMediaHash ( ) ) ; insertStmt . setString ( c ++ , post . getMediaOrig ( ) ) ; insertStmt . setBoolean ( c ++ , post . isSpoiler ( ) ) ; insertStmt . setBoolean ( c ++ , post . isDeleted ( ) ) ; insertStmt . setString ( c ++ , ( post . getCapcode ( ) != null ) ? post . getCapcode ( ) : "N" ) ; insertStmt . setString ( c ++ , post . getEmail ( ) ) ; insertStmt . setString ( c ++ , post . getName ( ) ) ; insertStmt . setString ( c ++ , post . getTrip ( ) ) ; insertStmt . setString ( c ++ , post . getTitle ( ) ) ; insertStmt . setString ( c ++ , post . getComment ( ) ) ; insertStmt . setString ( c ++ , post . getDelpass ( ) ) ; insertStmt . setBoolean ( c ++ , post . isSticky ( ) ) ; insertStmt . setBoolean ( c ++ , post . isClosed ( ) ) ; insertStmt . setString ( c ++ , post . getPosterHash ( ) ) ; insertStmt . setString ( c ++ , post . getPosterCountry ( ) ) ; insertStmt . setString ( c ++ , post . getExif ( ) ) ; insertStmt . setInt ( c ++ , post . getNum ( ) ) ; insertStmt . setInt ( c ++ , post . getSubnum ( ) ) ; insertStmt . setInt ( c ++ , post . getNum ( ) ) ; insertStmt . setInt ( c , post . getSubnum ( ) ) ; insertStmt . addBatch ( ) ; } insertStmt . executeBatch ( ) ; updateStmt . executeBatch ( ) ; conn . commit ( ) ; break ; } catch ( SQLException e ) { if ( e . getCause ( ) instanceof SQLRecoverableException ) { this . reconnect ( ) ; continue ; } try { conn . rollback ( ) ; } catch ( SQLException e1 ) { e1 . setNextException ( e ) ; throw new ContentStoreException ( e1 ) ; } throw new ContentStoreException ( e ) ; } } }
te	0	public CellEvent ( View v , EventObject aEv ) { super ( v ) ; this . action = aEv ; }
te	5	private boolean createTempTable ( String tmpname , String statement ) { boolean ok = true ; dropTable ( tmpname ) ; if ( useAlternate ) { String helpstr = statement . toLowerCase ( ) ; if ( helpstr . startsWith ( "create temporary table" ) ) { statement = "CREATE TABLE" + statement . substring ( 22 ) ; } for ( int i = 0 ; i < dbList . size ( ) ; i ++ ) { Statement remDB = ( Statement ) dbList . get ( i ) ; try { remDB . execute ( statement ) ; } catch ( SQLException e ) { output += "<p>Error while creating remote temporary table " + ( i + 1 ) + " for request." ; output += "<p>" + e . getSQLState ( ) + "<p>" + e . getMessage ( ) + "<br>" + statement + "<p>" ; ok = false ; } } } try { int pos = statement . toLowerCase ( ) . indexOf ( "table" ) + 5 ; statement = statement . substring ( 0 , pos ) + " IF NOT EXISTS " + statement . substring ( pos ) ; tempDB . execute ( statement ) ; } catch ( SQLException e ) { output += "<p>Error while creating temporary table in local database for request." ; output += "<p>" + e . getSQLState ( ) + "<p>" + e . getMessage ( ) + "<br>" + statement + "<p>" ; ok = false ; } return ok ; }
te	5	@ Override public void setCell ( int col , int row , boolean alive ) { if ( row >= 0 && row < 8 && col >= 0 && col < 8 ) { if ( alive ) { cells |= ( ( long ) 1 << ( 8 * row + col ) ) ; } else { cells &= ~ ( ( long ) 1 << ( 8 * row + col ) ) ; } } }
te	3	@ Override public void writeObject ( Product obj ) throws IOException { if ( ! connectionOutStatus ) { startOutputConnection ( ) ; } if ( connectionOutStatus ) { try { os . writeObject ( obj ) ; System . out . println ( "Das Produkt mit dem Namen : " + obj . getName ( ) + " wurde gespeichert!" ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } }
te	1	static private FuncInfo getFuncInfo ( Method method ) throws IncompleteAnnotationException { FuncInfo annotation = method . getAnnotation ( FuncInfo . class ) ; if ( annotation != null ) return annotation ; throw new IncompleteAnnotationException ( FuncInfo . class , "Method " + method . getName ( ) ) ; }
te	2	@ Override public boolean equals ( Object obj ) { if ( ! ( obj instanceof Tuple ) ) return false ; Tuple tup = ( Tuple ) obj ; return direction == tup . direction && playable . equals ( tup . playable ) ; }
te	4	public static class < ? > [ ] toClassArray ( Collection < class < ? >> collection ) { if ( collection == null ) { return null ; } return collection . toArray ( new class < ? > [ collection . size ( ) ] ) ; }
te	7	public synchronized int logUpload ( String userKey , String testId , String logName , String buff , String dataType ) { if ( userKey == null || userKey . trim ( ) . isEmpty ( ) ) { BmLog . debug ( "Log cannot be uploaded  userKey is empty" ) ; return - 1 ; } if ( testId == null || testId . trim ( ) . isEmpty ( ) ) { BmLog . debug ( "Log cannot be uploaded  testId is empty" ) ; return - 1 ; } Integer fileSize = - 1 ; logName = logName . trim ( ) . isEmpty ( ) ? "log" : logName ; String url = this . urlManager . logUpload ( Constants . APP_KEY , userKey , testId , logName , dataType ) ; JSONObject obj = new JSONObject ( ) ; try { obj . put ( Constants . DATA , buff ) ; JSONObject jo = getJson ( Methods . POST , url , obj ) ; if ( jo . has ( "file_size" ) ) fileSize = ( Integer ) jo . get ( "file_size" ) ; else BmLog . error ( "Failed to upload " + logName ) ; } catch ( JSONException e ) { BmLog . error ( e ) ; } return fileSize ; }
te	7	public static WinCombination GenerateMockWinSequentialCombination ( int count , String symName , boolean isLR , boolean sortPriorAndBasePayNull , boolean sortPriorLessThanBasePay , boolean hasBothIndexAndCount , boolean bothIndexAndCountNull ) { WinCombination winCombination = new WinCombination ( ) ; if ( sortPriorAndBasePayNull ) { winCombination . basepay = null ; } else if ( sortPriorLessThanBasePay ) { winCombination . basepay = count * 100 ; winCombination . sortpriority = winCombination . basepay - 1 ; } else { winCombination . basepay = count * 100 ; winCombination . sortpriority = null ; } winCombination . name = count + " " + symName + " line" + ( isLR ? " LR" : " RL" ) ; winCombination . payMultiplicationType = "BetMult" ; winCombination . trigger = null ; winCombination . symbolWinElement = new ArrayList < SymbolWinElement > ( ) ; for ( int i = 0 ; i < count ; i ++ ) { int index = i ; if ( ! isLR ) { index = 4 - i ; } SymbolWinElement symbolWinElement = new SymbolWinElement ( ) ; if ( hasBothIndexAndCount ) { symbolWinElement . count = 1 ; symbolWinElement . index = index ; } else if ( bothIndexAndCountNull ) { symbolWinElement . index = null ; symbolWinElement . count = null ; } else { symbolWinElement . index = index ; symbolWinElement . count = null ; } symbolWinElement . symbol = symName ; winCombination . symbolWinElement . add ( symbolWinElement ) ; } return winCombination ; }
te	4	private int computeNumberOfSemiPrimesInRange ( final int [ ] primes , final int minBound , final int maxBound ) { int nbSemiPrimes = 0 ; final int nbPrimes = primes . length ; for ( int i = 0 ; i < nbPrimes ; i ++ ) { for ( int j = i ; j < nbPrimes ; j ++ ) { final int product = primes [ i ] * primes [ j ] ; if ( product >= minBound && product <= maxBound ) { nbSemiPrimes ++ ; } } } return nbSemiPrimes ; }
te	3	public double [ ] selectSeeds ( String goodSeedFilename , AdjacencyGraph g , int L ) { double [ ] rankScores = runner . run ( g ) ; Set < String > goodSeedSet = readSeedFile ( goodSeedFilename ) ; List < Rank > rankList = TopNAlgorithm . run ( rankScores , L ) ; double [ ] seeds = new double [ g . getNodeNum ( ) ] ; Arrays . fill ( seeds , 0.0 ) ; int goodSeedNum = 0 ; for ( Rank rank : rankList ) { if ( goodSeedSet . contains ( g . getNodeName ( rank . index ) ) ) { seeds [ rank . index ] = 1.0 ; ++ goodSeedNum ; } else { } } MyLogger . log ( goodSeedFilename + "]: " + goodSeedSet . size ( ) + "  " + goodSeedNum ) ; for ( int i = 0 ; i < seeds . length ; ++ i ) { seeds [ i ] /= goodSeedNum ; } return seeds ; }
te	2	public static void pairwiseMultiply ( float [ ] a , float [ ] b , float [ ] result ) { if ( a . length != b . length ) { throw new RuntimeException ( ) ; } for ( int i = 0 ; i < result . length ; i ++ ) { result [ i ] = a [ i ] * b [ i ] ; } }
te	6	public static String supportedGlyphs ( Font font , int cols ) { StringBuilder s = new StringBuilder ( ) ; int count = 0 ; for ( int i = 0 ; i < FFFF ; i ++ ) { if ( i == '' || i == '' ) { continue ; } if ( font . canDisplay ( i ) ) { s . append ( ( char ) i ) ; if ( cols > 0 && ++ count >= cols ) { s . append ( '' ) ; count = 0 ; } } } return s . toString ( ) ; }
te	9	@ Override public void draw ( Graphics g ) { int width = getWidth ( ) ; int height = getHeight ( ) ; if ( width == - 1 || height == - 1 ) return ; g . setClip ( getRealX ( ) , getRealY ( ) , width , height ) ; if ( this . hasBackground ( ) ) g . setColor ( getBackground ( ) ) ; else g . setColor ( Color . darkGray ) ; g . fillRect ( getRealX ( ) , getRealY ( ) , width , height ) ; if ( this . hasBorder ( ) ) g . setColor ( getBorder ( ) . getColor ( ) ) ; else g . setColor ( new Color ( 150 , 150 , 150 ) ) ; g . drawRect ( getRealX ( ) , getRealY ( ) , width - 1 , height - 1 ) ; if ( hasText ( ) ) { g . setColor ( getTextColor ( ) ) ; int x = getRealX ( ) , y = getRealY ( ) ; if ( textcenterx ) { x -= g . getFont ( ) . getWidth ( getDisplayText ( ) ) / 2 ; if ( hasWidth ( ) ) x += getWidth ( ) / 2 ; } if ( textcentery ) { y -= g . getFont ( ) . getHeight ( getDisplayText ( ) ) / 2 ; if ( hasHeight ( ) ) y += getHeight ( ) / 2 ; } g . drawString ( getDisplayText ( ) , x , y ) ; } g . clearClip ( ) ; }
te	2	public String readString ( ) { StringBuilder buffer = new StringBuilder ( ) ; int read ; while ( ( read = readUnsignedByte ( ) ) != '' && super . available ( ) != 0 ) { buffer . append ( ( char ) read ) ; } return buffer . toString ( ) ; }
te	5	private void bfsTravel ( TreeNode root , int level , List < List < Integer >> result ) { Queue < TreeNode > maintain = new LinkedList < TreeNode > ( ) ; Queue < TreeNode > visited = new LinkedList < TreeNode > ( ) ; List < Integer > list = null ; TreeNode tmp = null ; maintain . offer ( root ) ; while ( ! maintain . isEmpty ( ) ) { list = new ArrayList < Integer > ( ) ; while ( ! maintain . isEmpty ( ) ) { list . add ( maintain . peek ( ) . val ) ; visited . offer ( maintain . poll ( ) ) ; } result . add ( list ) ; while ( ! visited . isEmpty ( ) ) { tmp = visited . poll ( ) ; if ( tmp . left != null ) maintain . offer ( tmp . left ) ; if ( tmp . right != null ) maintain . offer ( tmp . right ) ; } } }
