tr	5	private PhysicalNode getSuitableNode ( VirtualMachine vm ) { PhysicalNode suitable = null ; double maxUtility = - 1 ; for ( PhysicalNode pn : drp . getAllNodes ( ) ) { if ( ! pn . isFailure ( ) && pn . isFitting ( vm ) ) { double utility ; if ( hm . getObjective ( ) == HolisticManager . Objective . ECO_MAX ) { utility = hm . getTrec ( ) . getEcoIfDeployment ( pn , vm ) ; } else { utility = TrecApi . MAX_RISK - hm . getTrec ( ) . getRiskIfDeployment ( pn , vm ) ; } assert utility >= 0 ; if ( utility > maxUtility ) { maxUtility = utility ; suitable = pn ; } } } return suitable ; }
tr	6	private void setComponentConstraintsImpl ( Component comp , Object constr , boolean noCheck ) { Container parent = comp . getParent ( ) ; synchronized ( parent != null ? parent . getTreeLock ( ) : new Object ( ) ) { if ( noCheck == false && scrConstrMap . containsKey ( comp ) == false ) throw new IllegalArgumentException ( "Component must already be added to parent!" ) ; ComponentWrapper cw = new SwingComponentWrapper ( comp ) ; if ( constr == null || constr instanceof String ) { String cStr = ConstraintParser . prepare ( ( String ) constr ) ; scrConstrMap . put ( comp , constr ) ; ccMap . put ( cw , ConstraintParser . parseComponentConstraint ( cStr ) ) ; } else if ( constr instanceof CC ) { scrConstrMap . put ( comp , constr ) ; ccMap . put ( cw , ( CC ) constr ) ; } else { throw new IllegalArgumentException ( "Constraint must be String or ComponentConstraint: " + constr . getClass ( ) . toString ( ) ) ; } dirty = true ; } }
tr	1	private void resetImageProducers2 ( ) { if ( aRSImageProducer_1166 != null ) return ; nullLoader ( ) ; super . fullGameScreen = null ; aRSImageProducer_1107 = null ; aRSImageProducer_1108 = null ; aRSImageProducer_1109 = null ; aRSImageProducer_1110 = null ; aRSImageProducer_1111 = null ; aRSImageProducer_1112 = null ; aRSImageProducer_1113 = null ; aRSImageProducer_1114 = null ; aRSImageProducer_1115 = null ; aRSImageProducer_1166 = new RSImageProducer ( 479 , 96 , getGameComponent ( ) ) ; aRSImageProducer_1164 = new RSImageProducer ( 172 , 156 , getGameComponent ( ) ) ; DrawingArea . setAllPixelsToZero ( ) ; mapBack . method361 ( 0 , 0 ) ; aRSImageProducer_1163 = new RSImageProducer ( 190 , 261 , getGameComponent ( ) ) ; aRSImageProducer_1165 = new RSImageProducer ( 512 , 334 , getGameComponent ( ) ) ; DrawingArea . setAllPixelsToZero ( ) ; aRSImageProducer_1123 = new RSImageProducer ( 496 , 50 , getGameComponent ( ) ) ; aRSImageProducer_1124 = new RSImageProducer ( 269 , 37 , getGameComponent ( ) ) ; aRSImageProducer_1125 = new RSImageProducer ( 249 , 45 , getGameComponent ( ) ) ; welcomeScreenRaised = true ; }
tr	4	public static float pcaAngle ( Collection < Vector2f > points ) { final float size = points . size ( ) ; if ( size < 2 ) return 0.0f ; final Vector2f mean = mean ( points ) ; double cov00 = 0.0 ; double cov01 = 0.0 ; double cov11 = 0.0 ; for ( Vector2f p : points ) { final float x = mean . x - p . x ; final float y = mean . y - p . y ; cov00 += ( x * x ) ; cov01 += ( x * y ) ; cov11 += ( y * y ) ; } final double in = ( size > 0.0f ) ? ( 1.0f / size ) : ( 0.0f ) ; cov00 *= ( in ) ; cov01 *= ( in ) ; cov11 *= ( in ) ; final double covd = ( cov00 - cov11 ) ; if ( covd == 0.0 ) return 0.0f ; final double theta = 0.5 * Math . atan ( ( 2.0 * cov01 ) / covd ) ; return ( float ) theta ; }
tr	9	private static boolean parseInvBool ( String s , String option ) { boolean b = false ; if ( s != null && s . length ( ) > 0 ) { char c = s . charAt ( 0 ) ; if ( ( c == t ) || ( c == T ) || ( c == Y ) || ( c == y ) ) b = true ; else if ( ( c == f ) || ( c == F ) || ( c == N ) || ( c == n ) ) b = false ; else Report . badArgument ( option ) ; } return ! b ; }
tr	0	@ Override public void releaseSavepoint ( Savepoint savepoint ) throws SQLException { }
tr	4	public static boolean readUsers ( DecisionLineEvent readEvent , int playableEdges ) { if ( ! isConnected ( ) ) if ( ! connect ( ) ) { System . out . println ( "Error  database connection could not be created" ) ; System . exit ( 0 ) ; } try { PreparedStatement pstmt = getConnection ( ) . prepareStatement ( "SELECT userName  userPassword  position from user where eventId=(?) ORDER BY position ASC" ) ; pstmt . setString ( 1 , readEvent . getUniqueId ( ) ) ; ResultSet myRS = pstmt . executeQuery ( ) ; User newUser ; String name , password ; int position ; while ( myRS . next ( ) ) { name = new String ( myRS . getString ( "userName" ) ) ; password = new String ( myRS . getString ( "userPassword" ) ) ; position = myRS . getInt ( "position" ) ; newUser = new User ( name , password , position , playableEdges ) ; readEvent . getUsers ( ) . add ( newUser ) ; } return true ; } catch ( SQLException e ) { System . out . println ( "error executing SQL statement!" ) ; } return false ; }
tr	8	@ Test public void testPertenece2 ( ) { boolean expected = false ; boolean actual = arbolito . pertenece ( 8 ) && arbolito . pertenece ( 3 ) && arbolito . pertenece ( 6 ) && arbolito . pertenece ( 1 ) && arbolito . pertenece ( 16 ) && arbolito . pertenece ( 4 ) && arbolito . pertenece ( 7 ) && arbolito . pertenece ( 14 ) && arbolito . pertenece ( 13 ) ; assertEquals ( expected , actual ) ; }
tr	7	HubNode ( Device dev , TreeNode parent ) throws IOException { super ( dev , parent ) ; hub = new Hub ( dev ) ; addr = dev . getAddress ( ) ; if ( isFlatTree ) { if ( hub . isRootHub ( ) ) { Bus bus = dev . getBus ( ) ; children = new USBNode [ 127 ] ; last = 0 ; for ( int i = 1 ; i <= 127 ; i ++ ) { Device d = bus . getDevice ( i ) ; if ( d != null && d != dev ) deviceAdded ( d , null ) ; } } else children = null ; } else { children = new USBNode [ hub . getNumPorts ( ) ] ; last = 0 ; for ( int i = 1 ; i <= children . length ; i ++ ) { Device d = dev . getChild ( i ) ; if ( d != null ) deviceAdded ( d , null ) ; } } }
tr	4	public static int getHeuristicDistance ( final int w , final int h , final String b ) { int ret = 0 ; final String string = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" ; for ( int i = 0 ; i < h ; i ++ ) { for ( int j = 0 ; j < w ; j ++ ) { final int index = i * w + j ; if ( index > 0 ) { final char c = b . charAt ( index ) ; if ( c != = ) { final int number = ( string . indexOf ( c ) + w * h - 1 ) % ( w * h ) ; ret += Math . abs ( number / w - i ) + Math . abs ( number % w - j ) ; } } } } return ret ; }
tr	8	public static ArrayList < Integer > spiralOrderHelper ( int [ ] [ ] matrix , int x , int y , int [ ] [ ] matrixHelper ) { ArrayList < Integer > newList = new ArrayList < Integer > ( ) ; for ( int i = x ; i < matrix [ 0 ] . length - x ; i ++ ) { if ( matrixHelper [ y ] [ i ] == 1 ) return newList ; newList . add ( matrix [ y ] [ i ] ) ; matrixHelper [ y ] [ i ] = 1 ; } for ( int i = y + 1 ; i < matrix . length - y ; i ++ ) { if ( matrixHelper [ i ] [ matrix [ 0 ] . length - x - 1 ] == 1 ) return newList ; newList . add ( matrix [ i ] [ matrix [ 0 ] . length - x - 1 ] ) ; matrixHelper [ i ] [ matrix [ 0 ] . length - x - 1 ] = 1 ; } for ( int i = matrix [ 0 ] . length - x - 1 - 1 ; i > x - 1 ; i -- ) { if ( matrixHelper [ matrix . length - y - 1 ] [ i ] == 1 ) return newList ; newList . add ( matrix [ matrix . length - y - 1 ] [ i ] ) ; matrixHelper [ matrix . length - y - 1 ] [ i ] = 1 ; } for ( int i = matrix . length - y - 1 - 1 ; i > y ; i -- ) { if ( matrixHelper [ i ] [ x ] == 1 ) return newList ; newList . add ( matrix [ i ] [ x ] ) ; matrixHelper [ i ] [ x ] = 1 ; } return newList ; }
tr	2	public void verify ( FileInputStream ciphertext , FileInputStream cleartext ) { int bitLen = q . bitLength ( ) ; int blockLen = ( bitLen - 1 ) / 8 ; BigInteger cipher = readCipher ( ciphertext ) ; BigInteger clear = readClear ( cleartext , blockLen ) ; while ( cipher != null ) { if ( ! verifyBlock ( clear , cipher ) ) { System . out . println ( "Wrong signature!" ) ; return ; } cipher = readCipher ( ciphertext ) ; clear = readClear ( cleartext , blockLen ) ; } System . out . println ( "Correct signature!" ) ; }
tr	4	public void update ( final Observable obj , final Object arg ) { final String line = ( String ) arg ; final int startOfTag = line . indexOf (   ) + 1 ; final int endOfTag = line . indexOf (   , startOfTag + 1 ) ; if ( startOfTag < 1 || endOfTag < 1 ) { return ; } final String strTimeTag = line . substring ( startOfTag , endOfTag ) ; try { final double timeLong = double . parseDouble ( strTimeTag ) ; final Date timeTag = new Date ( ( long ) timeLong . doubleValue ( ) * 1000 ) ; if ( timeTag . getTime ( ) > lastSeen . getTime ( ) ) { lastSeen = timeTag ; parent . setLastDateTag ( dataVisualizer . format ( lastSeen ) ) ; } } catch ( Exception ex ) { ex . printStackTrace ( ) ; } }
tr	3	public void setValue ( final DATA newValue ) { if ( newValue == null ) return ; if ( this . possibleValues . isEmpty ( ) || this . possibleValues . contains ( newValue ) ) this . model . setValue ( newValue ) ; else throw new IllegalArgumentException ( "Invalid value \"" + newValue + "\"\nAllowed values are: " + this . possibleValues . toArray ( ) . toString ( ) ) ; }
tr	2	public EnumResource getTopImport ( ) { EnumResource topImport = null ; int importValue = 0 ; for ( Map . Entry < EnumResource , Integer [ ] > entry : resourceImportExport . entrySet ( ) ) { if ( entry . getValue ( ) [ 0 ] > importValue ) { importValue = entry . getValue ( ) [ 0 ] ; topImport = entry . getKey ( ) ; } } return topImport ; }
tr	6	private int [ ] getToken ( String line , int startingPoint ) { int [ ] ret = new int [ 3 ] ; if ( splitter != null ) { int nextSplit = line . indexOf ( splitter , startingPoint ) ; ret [ 0 ] = startingPoint ; ret [ 1 ] = nextSplit >= 0 ? nextSplit : line . length ( ) ; ret [ 2 ] = nextSplit >= 0 ? nextSplit + splitter . length ( ) : line . length ( ) - 1 ; } else { int startBeginner = line . indexOf ( fieldStarter , startingPoint ) ; ret [ 0 ] = startBeginner >= 0 ? startBeginner + fieldStarter . length ( ) : line . length ( ) ; int startEnder = line . indexOf ( fieldStopper , ret [ 0 ] ) ; ret [ 1 ] = startEnder >= 0 ? startEnder : line . length ( ) - 1 ; ret [ 2 ] = startEnder >= 0 ? startEnder + fieldStopper . length ( ) : line . length ( ) - 1 ; } return ret ; }
tr	9	public void setDimension ( String dimension ) { if ( dimension == null ) dimensionGroup . clearSelection ( ) ; else if ( dimension . equals ( AData . D1 ) ) d1 . setSelected ( true ) ; else if ( dimension . equals ( AData . D2 ) ) d2 . setSelected ( true ) ; else if ( dimension . equals ( AData . D3 ) ) d3 . setSelected ( true ) ; else if ( dimension . equals ( AData . D4 ) ) d4 . setSelected ( true ) ; else if ( dimension . equals ( AData . ODNOMERNOST ) ) odno . setSelected ( true ) ; else if ( dimension . equals ( AData . MALOMERNOST ) ) malo . setSelected ( true ) ; else if ( dimension . equals ( AData . MNOGOMERNOST ) ) mnogo . setSelected ( true ) ; else if ( dimension . equals ( AData . INDIVIDUALNOST ) ) indi . setSelected ( true ) ; if ( dimensionGroup . getSelection ( ) != null ) clearDimensionSelection . setEnabled ( true ) ; else clearDimensionSelection . setEnabled ( false ) ; }
tr	5	static int [ ] [ ] minPaths ( int [ ] [ ] triangle ) { int [ ] [ ] newTriangle = triangle . clone ( ) ; for ( int i = 1 ; i < newTriangle . length ; i ++ ) { int previousLevelMinPath = 20000 * SIZE ; for ( int n = 0 ; n < i ; n ++ ) if ( newTriangle [ i - n - 1 ] [ n ] < previousLevelMinPath ) previousLevelMinPath = newTriangle [ i - n - 1 ] [ n ] ; for ( int n = 0 ; n <= i ; n ++ ) { int currentHeight = i - n ; int currentWidth = n ; int currentMinPath ; if ( n < ( i + 1 ) / 2 ) currentMinPath = newTriangle [ currentHeight - 1 ] [ currentWidth ] ; else currentMinPath = newTriangle [ currentHeight ] [ currentWidth - 1 ] ; currentMinPath = minPathLength ( i - 1 , currentHeight , currentWidth , currentMinPath , previousLevelMinPath , 0 , newTriangle ) ; newTriangle [ currentHeight ] [ currentWidth ] += currentMinPath ; } } return newTriangle ; }
tr	2	public RateLimitStatus ( Response res ) throws WeiboException { super ( res ) ; JSONObject json = res . asJSONObject ( ) ; try { JSONArray list = json . getJSONArray ( "api_rate_limits" ) ; int size = list . length ( ) ; apiRateLimit = new ArrayList < ApiRateLimits > ( size ) ; for ( int i = 0 ; i < size ; i ++ ) { apiRateLimit . add ( new ApiRateLimits ( list . getJSONObject ( i ) ) ) ; } ipLimit = json . getInt ( "ip_limit" ) ; remainingIpHits = json . getInt ( "remaining_ip_hits" ) ; remainingUserHits = json . getLong ( "remaining_user_hits" ) ; resetTime = json . getString ( "reset_time" ) ; resetTimeInSeconds = json . getInt ( "reset_time_in_seconds" ) ; userLimit = json . getLong ( "user_limit" ) ; } catch ( JSONException jsone ) { throw new WeiboException ( jsone . getMessage ( ) + ":" + json . toString ( ) , jsone ) ; } }
tr	9	@ SuppressWarnings ( { "static-access" } ) private static void getConfig ( ) throws IOException { File file = new File ( "C:\\temp\\config.txt" ) ; BufferedReader br = new BufferedReader ( new InputStreamReader ( new FileInputStream ( file ) , "UTF-8" ) ) ; String line = null ; Phone . AllExtensions = new ArrayList < String > ( ) ; Phone . usualExtensions = new ArrayList < String > ( ) ; while ( ( line = br . readLine ( ) ) != null ) { line = line . trim ( ) ; if ( line . startsWith ( "Speaker" ) ) { Phone . MainExtension = line . substring ( 22 ) . trim ( ) ; Phone . AllExtensions . add ( line . substring ( 22 ) . trim ( ) ) ; } if ( line . startsWith ( "Phone number" ) ) { Phone . usualExtensions . add ( line . substring ( 14 ) . trim ( ) ) ; Phone . AllExtensions . add ( line . substring ( 14 ) . trim ( ) ) ; } if ( line . startsWith ( "Ip adress" ) ) Phone . AsteriskIp = line . substring ( 20 ) . trim ( ) ; else if ( line . startsWith ( "WriteUser" ) ) Phone . WriteUser = line . substring ( 11 ) . trim ( ) ; else if ( line . startsWith ( "WritePassword" ) ) Phone . WriteUserPassword = line . substring ( 15 ) . trim ( ) ; else if ( line . startsWith ( "Context" ) ) Phone . Context = line . substring ( 9 ) . trim ( ) ; else if ( line . startsWith ( "Skin" ) ) skin = line . substring ( 7 ) . trim ( ) ; else if ( line . startsWith ( "ReadUser" ) ) Phone . ReadUser = line . substring ( 10 ) . trim ( ) ; else if ( line . startsWith ( "ReadPassword" ) ) Phone . ReadUserPassword = line . substring ( 14 ) . trim ( ) ; else if ( line . startsWith ( "UsersInfoFile" ) ) UsersInfoFile = line . substring ( 15 ) . trim ( ) ; else if ( line . startsWith ( "PhotoFolder" ) ) Phone . PhotoFolder = line . substring ( 13 ) . trim ( ) ; else if ( line . startsWith ( "DefaultPhoto" ) ) Phone . DefaultPhoto = line . substring ( 14 ) . trim ( ) ; } br . close ( ) ; }
tr	0	public int getVersion ( ) { return version ; }
tr	3	@ Override public void paintComponent ( Graphics g ) { ChineseStroke points = UniversalDataStorage . points ; Graphics2D g2 = ( Graphics2D ) g ; if ( firstTime ) { Dimension dim = getSize ( ) ; bi = ( BufferedImage ) createImage ( dim . width , dim . height ) ; big = ( Graphics2D ) bi . createGraphics ( ) ; big . clearRect ( 0 , 0 , bi . getWidth ( ) , bi . getHeight ( ) ) ; big . setStroke ( new BasicStroke ( 3 , BasicStroke . CAP_SQUARE , BasicStroke . JOIN_ROUND , 1.0f , new float [ ] { 10 , 10 , 10 , 10 , 10 } , 0 ) ) ; big . setPaint ( Color . LIGHT_GRAY ) ; big . drawLine ( 0 , dim . height / 2 , dim . width , dim . height / 2 ) ; big . drawLine ( dim . width / 2 , 0 , dim . width / 2 , dim . height ) ; big . setStroke ( new BasicStroke ( 1 ) ) ; big . setPaint ( Color . BLACK ) ; firstTime = false ; } if ( points . size ( ) > 1 ) { for ( int i = 1 ; i < points . size ( ) ; i ++ ) { big . setPaint ( Color . BLACK ) ; big . drawLine ( points . get ( i - 1 ) [ 0 ] , points . get ( i - 1 ) [ 1 ] , points . get ( i ) [ 0 ] , points . get ( i ) [ 1 ] ) ; big . setPaint ( Color . LIGHT_GRAY ) ; } } g2 . drawImage ( bi , 0 , 0 , this ) ; }
tr	1	private static boolean isNegativeKeyword ( String str ) { return str . equals ( "\u10D0\u10E0\u10D0" ) || str . equals ( "\u10D0\u10E0" ) ; }
tr	8	private static int getPrecedence ( String s ) { switch ( s . charAt ( 0 ) ) { case ( : case ) : return 1 ; case _ : return 4 ; case * : case / : return 3 ; case + : case - : return 2 ; case ^ : return 5 ; default : return 0 ; } }
tr	4	public QPixmap requestMinimap ( String mapName , MapManagerCb runnable ) { File file ; byte [ ] bbuf ; QPixmap img ; mapName = mapName . replace (   , _ ) ; if ( cache . get ( mapName ) != null ) { return cache . get ( mapName ) ; } file = new File ( String . format ( "~/qsl/miniMapCache/%s.jpg" , mapName ) ) ; if ( file . exists ( ) ) { RandomAccessFile raf ; try { raf = new RandomAccessFile ( file , "rw" ) ; bbuf = new byte [ ( int ) raf . length ( ) ] ; raf . read ( bbuf ) ; raf . close ( ) ; img = new QPixmap ( ) ; img . loadFromData ( bbuf ) ; return img ; } catch ( FileNotFoundException ex ) { System . out . printf ( "warning: could not access minimap in ~/qsl/miniMapCache/" ) ; } catch ( IOException ex ) { System . out . printf ( "warning: could not access minimap in ~/qsl/miniMapCache/" ) ; } } requests . add ( new Pair ( mapName , runnable ) ) ; synchronized ( requests ) { requests . notify ( ) ; } return null ; }
tr	9	private static boolean method523 ( char ac [ ] ) { boolean flag = true ; for ( int i = 0 ; i < ac . length ; i ++ ) if ( ! isDigit ( ac [ i ] ) && ac [ i ] != 0 ) flag = false ; if ( flag ) return true ; int j = method524 ( ac ) ; int k = 0 ; int l = fragments . length - 1 ; if ( j == fragments [ k ] || j == fragments [ l ] ) return true ; do { int i1 = ( k + l ) / 2 ; if ( j == fragments [ i1 ] ) return true ; if ( j < fragments [ i1 ] ) l = i1 ; else k = i1 ; } while ( k != l && k + 1 != l ) ; return false ; }
tr	4	@ Deprecated private String getLayerAttacks ( String layer ) throws IOException { String query = query_pre ; if ( layer . equals ( InfoEnum . Layer . BUSINESS . toString ( ) ) ) { query = query + "let $ap1 := $domain//capec:Attack_Pattern_Catalog/capec:Categories/capec:Category[@Name = '" + d_social + "']" + "/capec:Relationships/capec:Relationship/capec:Relationship_Target_ID " + "let $ap2 := $domain//capec:Attack_Pattern_Catalog/capec:Categories/capec:Category[@Name = '" + d_supply + "']" + "/capec:Relationships/capec:Relationship/capec:Relationship_Target_ID " + "let $all := ($ap1 $ap2)" + "return data($all)" ; } else if ( layer . equals ( InfoEnum . Layer . APPLICATION . toString ( ) ) ) { query = query + "let $ap1 := $domain//capec:Attack_Pattern_Catalog/capec:Categories/capec:Category[@Name = '" + d_software + "']" + "/capec:Relationships/capec:Relationship/capec:Relationship_Target_ID " + "let $ap2 := $domain//capec:Attack_Pattern_Catalog/capec:Categories/capec:Category[@Name = '" + d_commu + "']" + "/capec:Relationships/capec:Relationship/capec:Relationship_Target_ID " + "let $ap3 := $domain//capec:Attack_Pattern_Catalog/capec:Categories/capec:Category[@Name = '" + d_supply + "']" + "/capec:Relationships/capec:Relationship/capec:Relationship_Target_ID " + "let $all := ($ap1 $ap2 $ap3)" + "return data($all)" ; } else if ( layer . equals ( InfoEnum . Layer . PHYSICAL . toString ( ) ) ) { query = query + "let $ap1 := $domain//capec:Attack_Pattern_Catalog/capec:Categories/capec:Category[@Name = '" + d_hardware + "']" + "/capec:Relationships/capec:Relationship/capec:Relationship_Target_ID " + "let $ap2 := $domain//capec:Attack_Pattern_Catalog/capec:Categories/capec:Category[@Name = '" + d_physical + "']" + "/capec:Relationships/capec:Relationship/capec:Relationship_Target_ID " + "let $ap3 := $domain//capec:Attack_Pattern_Catalog/capec:Categories/capec:Category[@Name = '" + d_supply + "']" + "/capec:Relationships/capec:Relationship/capec:Relationship_Target_ID " + "let $all := ($ap1 $ap2 $ap3)" + "return data($all)" ; } else if ( layer . equals ( InfoEnum . Layer . ALL . toString ( ) ) ) { query = query + "let $ap := $domain//capec:Attack_Pattern_Catalog/capec:Categories/capec:Category" + "/capec:Relationships/capec:Relationship/capec:Relationship_Target_ID " + "return data($ap)" ; } else { CommandPanel . logger . warning ( "Incorrect layer for obtaining attack patterns!" ) ; } String result = session . execute ( query ) ; return result ; }
tr	1	public void printRes ( ) { for ( int i = 0 ; i < n ; i ++ ) { Vertex v = res . get ( i ) ; System . out . println ( v . vertex + " : " + v . timestamp1 + " / " + v . timestamp2 ) ; } }
tr	3	@ Override public String execute ( ) throws Exception { try { Map session = ActionContext . getContext ( ) . getSession ( ) ; User user = ( User ) session . get ( "User" ) ; Campaign camp ; lc = ( long ) long . parseLong ( campaid ) ; System . out . println ( "campaignlong id is" + getLc ( ) ) ; camp = ( Campaign ) myDao . getDbsession ( ) . get ( Campaign . class , lc ) ; camp . setCampaignId ( long . parseLong ( campaid ) ) ; camp . setCampaignName ( campaignname ) ; camp . setStartDate ( startdate ) ; camp . setEndDate ( enddate ) ; camp . setDialyBudget ( dailybdgt ) ; camp . setDeliveryMethod ( deliverytype ) ; camp . setNote ( note ) ; getMyDao ( ) . getDbsession ( ) . update ( camp ) ; setCamplist ( ( List < Campaign > ) myDao . getDbsession ( ) . createQuery ( "from Campaign" ) . list ( ) ) ; Criteria crit = myDao . getDbsession ( ) . createCriteria ( Campaign . class ) ; crit . add ( Restrictions . like ( "user" , user ) ) ; crit . setMaxResults ( 20 ) ; setCamplist ( ( List < Campaign > ) crit . list ( ) ) ; addActionMessage ( "Campaign " + camp . getCampaignName ( ) + " Successfully Updated" ) ; return "success" ; } catch ( HibernateException e ) { addActionError ( "Server  Error Please Recheck All Fields " ) ; e . printStackTrace ( ) ; return "error" ; } catch ( NullPointerException ne ) { addActionError ( "Server  Error Please Recheck All Fields " ) ; ne . printStackTrace ( ) ; return "error" ; } catch ( Exception e ) { addActionError ( "Server  Error Please Recheck All Fields " ) ; e . printStackTrace ( ) ; return "error" ; } }
tr	0	@ Test public void test ( ) { Simulator sim = new Simulator ( ) ; ConfigController c = new ConfigController ( sim ) ; c . getButtons ( ) ; }
tr	6	@ Override protected boolean PosValidEntity ( Entity entity , int newX , int newY ) { if ( this != entity && entity != null && ! entity . isDead ( ) && entity . canCollide && entity . collides ( newX , newY , width , height ) && ! ( entity instanceof Item ) ) { EntityCollision entityCol = new EntityCollision ( this , entity ) ; EntityCollision . entityCollisionList . push ( entityCol ) ; return true ; } return true ; }
tr	1	public void restoreDecks ( ) { int k = OPEN_DECK_SIZE - open_deck . size ( ) ; if ( deck . size ( ) < k ) { deck . addAll ( discarded ) ; discardeds . push ( discarded ) ; discarded = new CardBag ( ) ; } else { discardeds . push ( null ) ; } CardBag cs = deck . draw ( k , random ) ; deck_restorations . push ( cs ) ; open_deck . addAll ( cs ) ; }
tr	9	@ Override public String checkDatabases ( int year ) { MyDatabase sgdClone = new MyDatabase ( sgd . getConBean ( ) ) ; boolean connect = sgdClone . connect ( ) ; if ( ! connect ) { return "ERROR: no database connection" ; } String result = "" ; this . checkedYear = year ; this . compareStructure1 = null ; this . compareStructure2 = null ; if ( configDB != null && ! configDB . isEmpty ( ) ) { boolean doesSchemaExists = sgdClone . doesSchemaExists ( configDB ) ; if ( ! doesSchemaExists ) { System . out . println ( "Creating configDB" ) ; sgdClone . executeUpdate ( "CREATE DATABASE " + configDB ) ; sgdClone . setCatalog ( configDB ) ; InputStream istream = getClass ( ) . getResourceAsStream ( "/org/iesapp/clients/sgd7/sql/config.sql" ) ; ScriptRunner srun = new ScriptRunner ( sgdClone . getConnection ( ) , true , false ) ; try { srun . runScript ( new InputStreamReader ( istream ) ) ; } catch ( IOException ex ) { Logger . getLogger ( SgdClient . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( SQLException ex ) { Logger . getLogger ( SgdClient . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } } else { String tmpDB = "tmp" + Math . round ( Math . random ( ) * 1e8 ) ; sgdClone . executeUpdate ( "CREATE DATABASE " + tmpDB ) ; System . out . println ( "Creating " + tmpDB ) ; sgdClone . setCatalog ( tmpDB ) ; InputStream istream = getClass ( ) . getResourceAsStream ( "/org/iesapp/clients/sgd7/sql/config.sql" ) ; ScriptRunner srun = new ScriptRunner ( sgdClone . getConnection ( ) , false , false ) ; try { srun . runScript ( new InputStreamReader ( istream ) ) ; } catch ( IOException ex ) { Logger . getLogger ( SgdClient . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( SQLException ex ) { Logger . getLogger ( SgdClient . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } Compare compare = new Compare ( sgdClone , tmpDB , sgd , this . configDB ) ; compareStructure1 = compare . compareStructure ( ) ; for ( CompareIncidence ci : compareStructure1 ) { result += ci . toString ( ) ; } sgdClone . executeUpdate ( "DROP DATABASE " + tmpDB ) ; } } boolean doesSchemaExists = sgdClone . doesSchemaExists ( currentDBPrefix + year ) ; if ( ! doesSchemaExists ) { System . out . println ( "Creating " + currentDBPrefix + year ) ; sgdClone . executeUpdate ( "CREATE DATABASE " + currentDBPrefix + year ) ; sgdClone . setCatalog ( currentDBPrefix + year ) ; InputStream istream = getClass ( ) . getResourceAsStream ( "/org/iesapp/clients/sgd7/sql/cursoxxxx.sql" ) ; ScriptRunner srun = new ScriptRunner ( sgdClone . getConnection ( ) , true , false ) ; try { srun . runScript ( new InputStreamReader ( istream ) ) ; } catch ( IOException ex ) { Logger . getLogger ( SgdClient . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( SQLException ex ) { Logger . getLogger ( SgdClient . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } } else { String tmpDB = "tmp" + Math . round ( Math . random ( ) * 1e8 ) ; sgdClone . executeUpdate ( "CREATE DATABASE " + tmpDB ) ; System . out . println ( "Creating " + tmpDB ) ; sgdClone . setCatalog ( tmpDB ) ; InputStream istream = getClass ( ) . getResourceAsStream ( "/org/iesapp/clients/sgd7/sql/cursoxxxx.sql" ) ; ScriptRunner srun = new ScriptRunner ( sgdClone . getConnection ( ) , false , false ) ; try { srun . runScript ( new InputStreamReader ( istream ) ) ; } catch ( IOException ex ) { Logger . getLogger ( SgdClient . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( SQLException ex ) { Logger . getLogger ( SgdClient . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } Compare compare = new Compare ( sgdClone , tmpDB , sgd , this . currentDBPrefix + year ) ; compareStructure2 = compare . compareStructure ( ) ; for ( CompareIncidence ci : compareStructure2 ) { result += ci . toString ( ) ; } sgdClone . executeUpdate ( "DROP DATABASE " + tmpDB ) ; } sgdClone . close ( ) ; return result ; }
tr	9	private void doBounds ( List < Timeslot > slots , boolean isLabs , boolean hasLabs , boolean hasTuts ) { if ( ! alreadyRUN ) { if ( isLabs && ! hasTuts ) alreadyRUN = true ; else if ( ! isLabs && hasTuts ) { alreadyRUN = true ; } save . setEnabled ( true ) ; int startRow ; if ( isLabs ) { startRow = 0 ; } else startRow = sessionBoundsLabs . size ( ) + 5 ; ArrayList < Bounds > sessionBounds = new ArrayList < Bounds > ( ) ; GridBagConstraints c = new GridBagConstraints ( ) ; c . insets = new Insets ( 2 , 2 , 2 , 2 ) ; c . fill = GridBagConstraints . VERTICAL ; JPanel panel ; if ( isLabs ) panel = innerLabsPanel ; else panel = innerTutorialsPanel ; panel . removeAll ( ) ; c . weightx = 0.5 ; c . gridx = 0 ; c . gridy = 0 + startRow ; panel . add ( new JLabel ( "Session Name " ) ) ; c . gridx = 1 ; c . gridy = 0 + startRow ; panel . add ( new JLabel ( "Min      " ) ) ; c . gridx = 2 ; c . gridy = 0 + startRow ; panel . add ( new JLabel ( "Max      " ) ) ; c . gridx = 3 ; c . gridy = 0 + startRow ; panel . add ( new JLabel ( "Pref. Min" ) ) ; c . gridx = 4 ; c . gridy = 0 + startRow ; panel . add ( new JLabel ( "Pref. Max" ) ) ; String sectionTitle = "" ; if ( isLabs ) { sectionTitle = "LABS" ; } else { sectionTitle = "TUTS" ; } createTitleRow ( panel , 3 + startRow , sectionTitle ) ; for ( int i = 0 ; i < slots . size ( ) ; i ++ ) { Bounds timeslotBounds = new Bounds ( slots . get ( i ) ) ; sessionBounds . add ( timeslotBounds ) ; String slotTitle = slots . get ( i ) . toString ( ) ; timeslotBounds . createInputBoxes ( panel , i + 4 + startRow , slotTitle ) ; } if ( isLabs ) sessionBoundsLabs = sessionBounds ; else sessionBoundsTuts = sessionBounds ; } innerLabsPanel . setOpaque ( false ) ; innerTutorialsPanel . setOpaque ( false ) ; labsPanel . setOpaque ( false ) ; tutorialsPanel . setOpaque ( false ) ; labsPanel . setPreferredSize ( new Dimension ( innerLabsPanel . getWidth ( ) , ( int ) ( heightOfBounds ) ) ) ; tutorialsPanel . setPreferredSize ( new Dimension ( innerTutorialsPanel . getWidth ( ) , ( int ) ( heightOfBounds ) ) ) ; frame . validate ( ) ; frame . pack ( ) ; }
tr	9	public String toUpdateKML ( boolean suppressEnclosingTags ) { if ( ! isDirty ( ) ) { return "" ; } String change = "" ; boolean isPrimDirty = isPrimitiveDirty ( ) ; if ( isPrimDirty && ! suppressEnclosingTags ) { change += "<Polygon" ; if ( this . id != null ) { change += " id=\"" + this . getId ( ) + "\"" ; } if ( this . targetId != null ) { change += " targetId=\"" + this . getTargetId ( ) + "\"" ; } change += ">\n" ; } change += super . toUpdateKML ( true ) ; if ( this . isExtrudeDirty ) { change += "<extrude>" + this . extrude + "</extrude>\n" ; this . isExtrudeDirty = false ; } if ( this . isTessellateDirty ) { change += "<tessellate>" + this . tessellate + "</tessellate>\n" ; this . isTessellateDirty = false ; } if ( this . altitudeMode != null && this . isAltitudeModeDirty ) { change += "<altitudeMode>" + SpecialCaseFormatter . toKMLString ( this . altitudeMode ) + "</altitudeMode>\n" ; this . isAltitudeModeDirty = false ; } if ( this . outerBoundaryIs != null && this . outerBoundaryIs . isDirty ( ) ) { change += this . outerBoundaryIs . toUpdateKML ( ) ; } for ( Iterator iter = this . innerBoundaryIs . iterator ( ) ; iter . hasNext ( ) ; ) { boundary cur = ( boundary ) iter . next ( ) ; if ( cur . isDirty ( ) ) { change += cur . toUpdateKML ( ) ; } } if ( isPrimDirty && ! suppressEnclosingTags ) { change += "</Polygon>\n" ; } setNotDirty ( ) ; return change ; }
tr	2	public void select ( ) { switch ( current ) { case 0 : case 1 : } }
tr	2	public static void main ( String [ ] args ) { TreeSet < Integer > set2 = new TreeSet < Integer > ( ) ; set2 . add ( 4 ) ; set2 . add ( 100 ) ; set2 . add ( 45 ) ; set2 . add ( 19 ) ; set2 . add ( 33 ) ; ArrayList < TreeSet < Integer >> totalSubSets = findSubSets ( set2 , 0 ) ; if ( totalSubSets == null ) System . out . println ( "No possible subsets" ) ; else for ( TreeSet < Integer > ts : totalSubSets ) { System . out . println ( ts ) ; } }
tr	4	@ Override public void add ( E pdato , int index ) { if ( 0 > index || _lenght < index ) { throw new IndexOutOfBoundsException ( "Fuera de rango: " + index ) ; } else if ( index == 0 ) { addi ( pdato ) ; } else if ( index == _lenght ) { add ( pdato ) ; } else { NodeDouble < E > tmp = getIndex ( index ) ; NodeDouble < E > tmp2 = new NodeDouble < E > ( pdato ) ; tmp . getPrev ( ) . setNext ( tmp2 ) ; tmp2 . setPrev ( tmp . getPrev ( ) ) ; tmp . setPrev ( tmp2 ) ; tmp2 . setNext ( tmp ) ; _lenght ++ ; } }
tr	3	public static boolean isBase64 ( byte octet ) { return octet == PAD || ( octet >= 0 && octet < base64ToInt . length && base64ToInt [ octet ] != - 1 ) ; }
tr	2	public static void changeSize ( final File file , final long newSize ) { try { RandomAccessFile randomAccessFile = new RandomAccessFile ( file , "rw" ) ; randomAccessFile . setLength ( newSize ) ; randomAccessFile . close ( ) ; } catch ( FileNotFoundException ex ) { Logger . getLogger ( files . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( IOException ex ) { Logger . getLogger ( files . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } }
tr	5	@ SuppressWarnings ( "static-access" ) public Component getTableCellRendererComponent ( JTable table , Object value , boolean isSelected , boolean hasFocus , int row , int column ) { JLabel label = ( JLabel ) super . getTableCellRendererComponent ( table , value , isSelected , hasFocus , row , column ) ; label . setIcon ( null ) ; if ( table . getColumnName ( column ) . equals ( "Nom" ) || table . getColumnName ( column ) . equals ( "Ville" ) || table . getColumnName ( column ) . equals ( "Province" ) ) { label . setText ( value . toString ( ) ) ; } else if ( table . getColumnName ( column ) . equals ( "Ferm\u00E9" ) ) { label . setText ( "" ) ; if ( value . toString ( ) . equals ( "true" ) ) { label . setIcon ( ConfigIcon . getInstance ( ) . CLOSED ) ; } else { label . setIcon ( ConfigIcon . getInstance ( ) . EMPTY_16 ) ; } } label . setOpaque ( true ) ; label . setHorizontalAlignment ( CENTER ) ; return label ; }
tr	8	private Node cleanNode ( Lexer lexer , Node node ) { Node next = null ; MutableObject o = new MutableObject ( ) ; boolean b = false ; for ( next = node ; node . isElement ( ) ; node = next ) { o . setObject ( next ) ; b = dir2Div ( lexer , node , o ) ; next = ( Node ) o . getObject ( ) ; if ( b ) continue ; b = nestedList ( lexer , node , o ) ; next = ( Node ) o . getObject ( ) ; if ( b ) continue ; b = center2Div ( lexer , node , o ) ; next = ( Node ) o . getObject ( ) ; if ( b ) continue ; b = mergeDivs ( lexer , node , o ) ; next = ( Node ) o . getObject ( ) ; if ( b ) continue ; b = blockStyle ( lexer , node , o ) ; next = ( Node ) o . getObject ( ) ; if ( b ) continue ; b = inlineStyle ( lexer , node , o ) ; next = ( Node ) o . getObject ( ) ; if ( b ) continue ; b = font2Span ( lexer , node , o ) ; next = ( Node ) o . getObject ( ) ; if ( b ) continue ; break ; } return next ; }
tr	4	public void connect ( ) { String shortName = protocol . nameOfTheGame ( ) ; minPlayer = protocol . minPlayer ( ) ; maxPlayer = protocol . maxPlayer ( ) ; System . out . println ( "Try to connect to " + host + ":" + port ) ; log ( "Try to connect to " + host + ":" + port ) ; myGUI . printOutput ( "Versuche zu verbinden mit " + host + ":" + port ) ; try { myCom = new Communicator ( host , port , shortName , minPlayer , maxPlayer , this ) ; protocol . setCommunicator ( myCom ) ; myGUI . enableConnectToServer ( false ) ; log ( "Connected to Server  player number: " + myCom . myNumber ( ) ) ; System . out . println ( "Wait for Players!" ) ; log ( "Wait for Players!" ) ; myGUI . printOutput ( "Warte auf weitere Spieler!" ) ; boolean connected = true ; if ( myCom . waitForPlayers ( ) ) { System . out . println ( "game startet!" ) ; log ( "game startet!" ) ; myGUI . printOutput ( "Spiel wird gestartet!" ) ; myGUI . setVisible ( false ) ; if ( myCom . myNumber ( ) > 0 ) protocol . receiveFirst ( ) ; else protocol . sendFirst ( ) ; System . out . println ( "game ended!" ) ; log ( "game ended!" ) ; myGUI . printOutput ( "Spiel ist zuende!" ) ; myGUI . setVisible ( true ) ; myCom . sendTo ( - 2 , String . valueOf ( 0 ) ) ; disconnect ( ) ; myGUI . enableConnectToServer ( true ) ; } } catch ( UnknownHostException ex ) { myGUI . printOutput ( host + " nicht gefunden!" ) ; System . err . println ( ex ) ; log ( ex + " : " + host ) ; } catch ( IOException ex ) { myGUI . printOutput ( "Verbindung fehlgeschlagen!" ) ; System . err . println ( ex ) ; log ( ex + " : " + host ) ; } }
tr	1	private void processTruncatedNormal ( String name , Node node ) { NamedNodeMap attrs = node . getAttributes ( ) ; Node nMean = attrs . getNamedItem ( "mean" ) ; double mean = double . parseDouble ( nMean . getNodeValue ( ) . trim ( ) ) ; Node nVariance = attrs . getNamedItem ( "variance" ) ; double variance = double . parseDouble ( nVariance . getNodeValue ( ) . trim ( ) ) ; Node nScalingFactor = attrs . getNamedItem ( "scalingFactor" ) ; double scalingFactor = 1.0 ; if ( nScalingFactor != null ) { scalingFactor = double . parseDouble ( nScalingFactor . getNodeValue ( ) . trim ( ) ) ; } else { this . vars . put ( name , Distribution . getTruncatedNormalDistribution ( mean , variance , scalingFactor ) ) ; } }
tr	1	public static boolean invertM ( float [ ] mInv , int mInvOffset , float [ ] m , int mOffset ) { final float src0 = m [ mOffset + 0 ] ; final float src4 = m [ mOffset + 1 ] ; final float src8 = m [ mOffset + 2 ] ; final float src12 = m [ mOffset + 3 ] ; final float src1 = m [ mOffset + 4 ] ; final float src5 = m [ mOffset + 5 ] ; final float src9 = m [ mOffset + 6 ] ; final float src13 = m [ mOffset + 7 ] ; final float src2 = m [ mOffset + 8 ] ; final float src6 = m [ mOffset + 9 ] ; final float src10 = m [ mOffset + 10 ] ; final float src14 = m [ mOffset + 11 ] ; final float src3 = m [ mOffset + 12 ] ; final float src7 = m [ mOffset + 13 ] ; final float src11 = m [ mOffset + 14 ] ; final float src15 = m [ mOffset + 15 ] ; final float atmp0 = src10 * src15 ; final float atmp1 = src11 * src14 ; final float atmp2 = src9 * src15 ; final float atmp3 = src11 * src13 ; final float atmp4 = src9 * src14 ; final float atmp5 = src10 * src13 ; final float atmp6 = src8 * src15 ; final float atmp7 = src11 * src12 ; final float atmp8 = src8 * src14 ; final float atmp9 = src10 * src12 ; final float atmp10 = src8 * src13 ; final float atmp11 = src9 * src12 ; final float dst0 = ( atmp0 * src5 + atmp3 * src6 + atmp4 * src7 ) - ( atmp1 * src5 + atmp2 * src6 + atmp5 * src7 ) ; final float dst1 = ( atmp1 * src4 + atmp6 * src6 + atmp9 * src7 ) - ( atmp0 * src4 + atmp7 * src6 + atmp8 * src7 ) ; final float dst2 = ( atmp2 * src4 + atmp7 * src5 + atmp10 * src7 ) - ( atmp3 * src4 + atmp6 * src5 + atmp11 * src7 ) ; final float dst3 = ( atmp5 * src4 + atmp8 * src5 + atmp11 * src6 ) - ( atmp4 * src4 + atmp9 * src5 + atmp10 * src6 ) ; final float det = src0 * dst0 + src1 * dst1 + src2 * dst2 + src3 * dst3 ; if ( det == 0.0f ) { return false ; } final float dst4 = ( atmp1 * src1 + atmp2 * src2 + atmp5 * src3 ) - ( atmp0 * src1 + atmp3 * src2 + atmp4 * src3 ) ; final float dst5 = ( atmp0 * src0 + atmp7 * src2 + atmp8 * src3 ) - ( atmp1 * src0 + atmp6 * src2 + atmp9 * src3 ) ; final float dst6 = ( atmp3 * src0 + atmp6 * src1 + atmp11 * src3 ) - ( atmp2 * src0 + atmp7 * src1 + atmp10 * src3 ) ; final float dst7 = ( atmp4 * src0 + atmp9 * src1 + atmp10 * src2 ) - ( atmp5 * src0 + atmp8 * src1 + atmp11 * src2 ) ; final float btmp0 = src2 * src7 ; final float btmp1 = src3 * src6 ; final float btmp2 = src1 * src7 ; final float btmp3 = src3 * src5 ; final float btmp4 = src1 * src6 ; final float btmp5 = src2 * src5 ; final float btmp6 = src0 * src7 ; final float btmp7 = src3 * src4 ; final float btmp8 = src0 * src6 ; final float btmp9 = src2 * src4 ; final float btmp10 = src0 * src5 ; final float btmp11 = src1 * src4 ; final float dst8 = ( btmp0 * src13 + btmp3 * src14 + btmp4 * src15 ) - ( btmp1 * src13 + btmp2 * src14 + btmp5 * src15 ) ; final float dst9 = ( btmp1 * src12 + btmp6 * src14 + btmp9 * src15 ) - ( btmp0 * src12 + btmp7 * src14 + btmp8 * src15 ) ; final float dst10 = ( btmp2 * src12 + btmp7 * src13 + btmp10 * src15 ) - ( btmp3 * src12 + btmp6 * src13 + btmp11 * src15 ) ; final float dst11 = ( btmp5 * src12 + btmp8 * src13 + btmp11 * src14 ) - ( btmp4 * src12 + btmp9 * src13 + btmp10 * src14 ) ; final float dst12 = ( btmp2 * src10 + btmp5 * src11 + btmp1 * src9 ) - ( btmp4 * src11 + btmp0 * src9 + btmp3 * src10 ) ; final float dst13 = ( btmp8 * src11 + btmp0 * src8 + btmp7 * src10 ) - ( btmp6 * src10 + btmp9 * src11 + btmp1 * src8 ) ; final float dst14 = ( btmp6 * src9 + btmp11 * src11 + btmp3 * src8 ) - ( btmp10 * src11 + btmp2 * src8 + btmp7 * src9 ) ; final float dst15 = ( btmp10 * src10 + btmp4 * src8 + btmp9 * src9 ) - ( btmp8 * src9 + btmp11 * src10 + btmp5 * src8 ) ; final float invdet = 1.0f / det ; mInv [ mInvOffset ] = dst0 * invdet ; mInv [ 1 + mInvOffset ] = dst1 * invdet ; mInv [ 2 + mInvOffset ] = dst2 * invdet ; mInv [ 3 + mInvOffset ] = dst3 * invdet ; mInv [ 4 + mInvOffset ] = dst4 * invdet ; mInv [ 5 + mInvOffset ] = dst5 * invdet ; mInv [ 6 + mInvOffset ] = dst6 * invdet ; mInv [ 7 + mInvOffset ] = dst7 * invdet ; mInv [ 8 + mInvOffset ] = dst8 * invdet ; mInv [ 9 + mInvOffset ] = dst9 * invdet ; mInv [ 10 + mInvOffset ] = dst10 * invdet ; mInv [ 11 + mInvOffset ] = dst11 * invdet ; mInv [ 12 + mInvOffset ] = dst12 * invdet ; mInv [ 13 + mInvOffset ] = dst13 * invdet ; mInv [ 14 + mInvOffset ] = dst14 * invdet ; mInv [ 15 + mInvOffset ] = dst15 * invdet ; return true ; }
tr	5	private void btnLearnCompleteActionPerformed ( java . awt . event . ActionEvent evt ) { ScienceTool . clearAll ( ) ; while ( lstTypes . getSelectedIndex ( ) < lstTypes . getModel ( ) . getSize ( ) - 1 ) { System . out . println ( "learning " + txtFile . getText ( ) ) ; File file = new File ( "data/" + txtFile . getText ( ) ) ; if ( file . exists ( ) ) { for ( LinkKNN knn : knns ) { knn . learnType ( ( String ) lstTypes . getSelectedValue ( ) ) ; } Datasource . getInstance ( ) . playRecording ( file ) ; for ( LinkKNN knn : knns ) { knn . stopLearning ( ) ; } } if ( lstTypes . getSelectedIndex ( ) < lstTypes . getModel ( ) . getSize ( ) ) { lstTypes . setSelectedIndex ( lstTypes . getSelectedIndex ( ) + 1 ) ; } } jlDatas . updateUI ( ) ; jlDatas . setSelectionInterval ( 0 , jlDatas . getModel ( ) . getSize ( ) ) ; }
tr	3	public Animable_Sub5 ( int i , int j , int k , int l , int i1 , int j1 , int k1 , int l1 , boolean flag ) { anInt1610 = i ; anInt1611 = k ; anInt1612 = j ; anInt1603 = j1 ; anInt1604 = l ; anInt1605 = i1 ; anInt1606 = k1 ; if ( l1 != - 1 ) { aAnimation_1607 = Animation . anims [ l1 ] ; anInt1599 = 0 ; anInt1608 = client . loopCycle ; if ( flag && aAnimation_1607 . anInt356 != - 1 ) { anInt1599 = ( int ) ( Math . random ( ) * ( double ) aAnimation_1607 . anInt352 ) ; anInt1608 -= ( int ) ( Math . random ( ) * ( double ) aAnimation_1607 . method258 ( anInt1599 ) ) ; } } ObjectDef class46 = ObjectDef . forID ( anInt1610 ) ; anInt1601 = class46 . anInt774 ; anInt1602 = class46 . anInt749 ; anIntArray1600 = class46 . childrenIDs ; }
tr	6	public void removePriceStep ( double startPrice , double endPrice ) throws RemoteException { startPrice = round ( startPrice ) ; endPrice = round ( endPrice ) ; if ( startPrice < 0 || endPrice < 0 ) throw new PriceStepNegativeArgumentException ( ) ; PriceStep removeStep = null ; for ( PriceStep storedStep : priceSteps ) { if ( storedStep . getStartPrice ( ) == startPrice && storedStep . getEndPrice ( ) == endPrice ) { removeStep = storedStep ; } } if ( removeStep == null ) { throw new PriceStepIntervalNotFoundException ( ) ; } else { priceSteps . remove ( removeStep ) ; } }
tr	0	public BuilderException ( ) { super ( ) ; }
tr	2	@ Override public void mouseDragged ( int oldx , int oldy , int newx , int newy ) { mousePos . x = newx ; mousePos . y = newy ; switch ( interactionState ) { case scrolling : double dx = - transformLengthBack ( scrollMouseStart . x - newx ) ; double dy = - transformLengthBack ( scrollMouseStart . y - newy ) ; renderOffset . x = scrollOffsetStart . x + dx ; renderOffset . y = scrollOffsetStart . y + dy ; correctRenderOffset ( ) ; break ; case normal : searchSelectedTower ( newx , newy ) ; break ; } }
tr	3	private void mostrarCidades ( List < Cidades > cidades ) { while ( tmCidades . getRowCount ( ) > 0 ) { tmCidades . removeRow ( 0 ) ; } if ( cidades . isEmpty ( ) ) { JOptionPane . showMessageDialog ( this , "Nenhuma cidade encontrada!" , "Erro de Busca" , JOptionPane . ERROR_MESSAGE , icones . getIconeErro ( ) ) ; } else { String [ ] campos = new String [ ] { null , null , null , null } ; for ( int i = 0 ; i < cidades . size ( ) ; i ++ ) { tmCidades . addRow ( campos ) ; tmCidades . setValueAt ( cidades . get ( i ) . getCodigo ( ) , i , 0 ) ; tmCidades . setValueAt ( cidades . get ( i ) . getNome ( ) , i , 1 ) ; tmCidades . setValueAt ( cidades . get ( i ) . getUf ( ) , i , 2 ) ; tmCidades . setValueAt ( cidades . get ( i ) . getDdd ( ) , i , 3 ) ; } } }
tr	8	protected long skipBytes ( long bytes ) throws BasicPlayerException { long totalSkipped = 0 ; if ( m_dataSource instanceof File ) { int previousStatus = m_status ; m_status = SEEKING ; long skipped = 0 ; try { synchronized ( m_audioInputStream ) { notifyEvent ( BasicPlayerEvent . SEEKING , getEncodedStreamPosition ( ) , - 1 , null ) ; initAudioInputStream ( ) ; if ( m_audioInputStream != null ) { while ( totalSkipped < ( bytes - SKIP_INACCURACY_SIZE ) ) { skipped = m_audioInputStream . skip ( bytes - totalSkipped ) ; if ( skipped == 0 ) break ; totalSkipped = totalSkipped + skipped ; if ( totalSkipped == - 1 ) throw new BasicPlayerException ( BasicPlayerException . SKIPNOTSUPPORTED ) ; } } } notifyEvent ( BasicPlayerEvent . SEEKED , getEncodedStreamPosition ( ) , - 1 , null ) ; m_status = OPENED ; if ( previousStatus == PLAYING ) startPlayback ( ) ; else if ( previousStatus == PAUSED ) { startPlayback ( ) ; pausePlayback ( ) ; } } catch ( IOException e ) { throw new BasicPlayerException ( e ) ; } } return totalSkipped ; }
tr	7	public boolean equivalentWasStartedBys ( WasStartedBy description1 , WasStartedBy description2 ) { return bothNull ( description1 , description2 ) || ( neitherNull ( description1 , description2 ) && equivalentIdentifiers ( description1 , description2 ) && equivalentAttributes ( description1 , description2 ) && equivalentEventArguments ( description1 , description2 ) && equivalentEntities ( description1 . getTrigger ( ) , description2 . getTrigger ( ) ) && equivalentActivities ( description1 . getStarted ( ) , description2 . getStarted ( ) ) && equivalentActivities ( description1 . getStarter ( ) , description2 . getStarter ( ) ) ) ; }
tr	6	public void go ( ) { new Thread ( new Runnable ( ) { public void run ( ) { try { for ( SimonButton button : buttons ) { button . setEnabled ( false ) ; } for ( int button_num : computerButtonPresses ) { Thread . sleep ( 400 ) ; SimonButton button = buttons [ button_num ] ; Color buttonColor = button . getBackground ( ) ; button . setBackground ( Color . WHITE ) ; startMidi ( ) ; Thread . sleep ( 150 ) ; button . setBackground ( buttonColor ) ; } for ( SimonButton button : buttons ) { button . setEnabled ( true ) ; } } catch ( InterruptedException ex ) { ex . printStackTrace ( ) ; } } } ) . start ( ) ; LevelTimer ( ) ; if ( computerButtonPresses . size ( ) == 1 && lives == 3 ) { buttons [ 0 ] . addActionListener ( new GreenPushListener ( ) ) ; buttons [ 1 ] . addActionListener ( new RedPushListener ( ) ) ; buttons [ 2 ] . addActionListener ( new YellowPushListener ( ) ) ; buttons [ 3 ] . addActionListener ( new BluePushListener ( ) ) ; buttons [ 4 ] . addActionListener ( new PinkPushListener ( ) ) ; buttons [ 5 ] . addActionListener ( new GrayPushListener ( ) ) ; } }
tr	6	private boolean isValidBins ( int bx , int by , int bz ) { if ( ( bx >= 0 && bx <= xAxis . getNBins ( ) ) && ( by >= 0 && by <= yAxis . getNBins ( ) ) && ( bz >= 0 && bz <= zAxis . getNBins ( ) ) ) { return true ; } return false ; }
tr	6	public void update ( ) { Board board = Board . getInstance ( ) ; int x = board . getIntX ( ) + ( board . getIntWidth ( ) - 11 * BoardEntity . FIELD_SIZE ) / 2 ; int y = board . getIntY ( ) + ( board . getIntHeight ( ) - 11 * BoardEntity . FIELD_SIZE ) / 2 ; switch ( getType ( ) ) { case RED_PLAYER : y += BoardEntity . FIELD_SIZE ; break ; case BLUE_PLAYER : x += BoardEntity . FIELD_SIZE * 7 ; y += BoardEntity . FIELD_SIZE ; break ; case GREEN_PLAYER : x += BoardEntity . FIELD_SIZE * 7 ; y += BoardEntity . FIELD_SIZE * 9 ; break ; case YELLOW_PLAYER : y += BoardEntity . FIELD_SIZE * 9 ; break ; } nameLabel . verticalAlignCenter ( x , x + 4 * BoardEntity . FIELD_SIZE ) ; nameLabel . setY ( y ) ; nameLabel . update ( ) ; if ( position != 0 ) { nameLabel . setText ( scoreLabelStr ( ) ) ; } else if ( isActive ( ) ) { nameLabel . setText ( String . format ( "%s (%d)" , this . name , this . rollCount ) ) ; } else { nameLabel . setText ( this . name ) ; } }
tr	3	public static void insertionSort ( int [ ] xs ) { for ( int j = 1 ; j < xs . length ; j ++ ) { int key = xs [ j ] ; int i = j - 1 ; while ( i >= 0 && key < xs [ i ] ) { xs [ i + 1 ] = xs [ i ] ; i -- ; } xs [ i + 1 ] = key ; } return ; }
tr	6	public void action ( ) { boolean terminationFlag = false ; while ( ! terminationFlag ) { MessageTemplate informTemplate = MessageTemplate . MatchPerformative ( ACLMessage . INFORM ) ; ACLMessage informMessage = myAgent . receive ( informTemplate ) ; if ( informMessage != null ) { if ( informMessage . getContent ( ) . matches ( "REREGISTER" ) ) { terminationFlag = true ; registerService ( ) ; } else if ( informMessage . getContent ( ) . matches ( "UPDATE-REREGISTER-BE-HAPPY" ) ) { updateRequestedInventory ( this . order ) ; terminationFlag = true ; registerService ( ) ; } else if ( informMessage . getContent ( ) . matches ( "YOU-ARE-THE-ONE" ) ) { try { String sName = informMessage . getLanguage ( ) ; AID orderID = new AID ( sName , AID . ISGUID ) ; ACLMessage notify = new ACLMessage ( ACLMessage . REQUEST ) ; notify . setOntology ( "Check Part List" ) ; notify . addReceiver ( orderID ) ; HashMap < String , Integer > copyInventory = new HashMap < String , Integer > ( ) ; copyInventory = copyHM ( inventory ) ; notify . setContentObject ( copyInventory ) ; send ( notify ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } } else { block ( ) ; } } }
tr	2	public synchronized void delete ( ) { if ( swigCPtr != 0 ) { if ( swigCMemOwn ) { swigCMemOwn = false ; otapiJNI . delete_Storable ( swigCPtr ) ; } swigCPtr = 0 ; } }
tr	7	public synchronized void tick ( ) { handleEvents ( ) ; updateWorkers ( ) ; for ( Sponsor sponsor : new ArrayList < Sponsor > ( sponsors ) ) { if ( sponsor . getMSLeft ( ) <= 0 ) sponsors . remove ( sponsor ) ; } Random r = new Random ( ) ; if ( sponsors . size ( ) < MAX_SPONSORS && r . nextInt ( ( int ) ( 1500 / Math . log ( getRenown ( ) + 2 ) ) ) == 0 ) { addSponsor ( ) ; } if ( getRenown ( ) <= 0 ) { showWindow ( null , new GameOverWindow ( ) ) ; } if ( r . nextInt ( DIFFICULTY ) == 0 ) { setRenown ( getRenown ( ) - 1 ) ; } if ( firstTick ) showWindow ( null , new HelpWindow ( ) ) ; firstTick = false ; }
tr	0	public MarkovState [ ] getMarkovStates ( ) { return STATES ; }
tr	0	public void windowDeiconified ( WindowEvent e ) { }
tr	5	private File loadXmlResource ( ) { File nodesFile = null ; String resource = "/cz/cvut/fit/nodes.xml" ; URL res = getClass ( ) . getResource ( resource ) ; if ( res . toString ( ) . startsWith ( "jar:" ) ) { try { InputStream input = getClass ( ) . getResourceAsStream ( resource ) ; nodesFile = File . createTempFile ( "nodesfile" , ".tmp" ) ; OutputStream out = new FileOutputStream ( nodesFile ) ; int read ; byte [ ] bytes = new byte [ 1024 ] ; while ( ( read = input . read ( bytes ) ) != - 1 ) { out . write ( bytes , 0 , read ) ; } nodesFile . deleteOnExit ( ) ; } catch ( IOException ex ) { Exceptions . printStackTrace ( ex ) ; } } else { nodesFile = new File ( res . getFile ( ) ) ; } if ( nodesFile != null && ! nodesFile . exists ( ) ) { throw new RuntimeException ( "Error: File " + nodesFile + " not found!" ) ; } return nodesFile ; }
tr	1	private void jTextField1FocusGained ( java . awt . event . FocusEvent evt ) { if ( jTextField1 . getText ( ) . equals ( "Enter Login" ) ) jTextField1 . setText ( "" ) ; }
tr	1	@ Test public void reverseWithNull ( ) { try { instance . reverse ( null ) ; fail ( "Expected exception not thrown." ) ; } catch ( NullPointerException e ) { } }
tr	2	public void setMV ( String s ) throws ADataException { if ( s == null ) { mv = null ; return ; } if ( ! ( s . equals ( MENTAL ) | s . equals ( VITAL ) | s . equals ( SUPEREGO ) | s . equals ( SUPERID ) ) ) throw new ADataException ( ) ; this . mv = s ; }
tr	6	public void actionPerformed ( ActionEvent action ) { if ( action . getSource ( ) . equals ( connect ) ) { int desired = 48 ; int latency = 0 ; try { pf . setString ( "connect_hostname" , serverName . getText ( ) ) ; pf . setInt ( "connect_port" , Integer . parseInt ( portNum . getText ( ) ) ) ; pf . setInt ( "listen_port" , Integer . parseInt ( localServerPortnum . getText ( ) ) ) ; try { desired = Integer . parseInt ( desiredSize . getText ( ) ) ; } catch ( NumberFormatException nfe ) { desired = 48 ; desiredSize . setText ( "48" ) ; } try { latency = Integer . parseInt ( latencyBox . getText ( ) ) ; } catch ( NumberFormatException nfe ) { latency = 0 ; latencyBox . setText ( "0" ) ; } pf . setInt ( "cache_size" , desired ) ; pf . setInt ( "buffer_latency" , latency ) ; desiredSize . setEditable ( false ) ; latencyBox . setEditable ( false ) ; pf . save ( ) ; } catch ( NumberFormatException nfe ) { } if ( serverMainThread == null || ! serverMainThread . isAlive ( ) ) { safeSetButton ( "Stop" ) ; final String distantServer = serverName . getText ( ) + ":" + portNum . getText ( ) ; final String localServer = localServerPortnum . getText ( ) ; final String cacheSize = Integer . toString ( desired * 1024 * 1024 ) ; final String latencyString = Integer . toString ( latency ) ; serverMainThread = new Thread ( new Runnable ( ) { public void run ( ) { String [ ] args = { localServer , distantServer , "local_cache" , "quiet" , "bridge_connection" , "auth_off" , "cache_limit" , cacheSize , "bufferlatency" , latencyString } ; Main . main ( args , false ) ; } } ) ; serverMainThread . start ( ) ; } else { safeSetButton ( "Stopping" ) ; serverMainThread . interrupt ( ) ; desiredSize . setEditable ( true ) ; latencyBox . setEditable ( true ) ; } } }
tr	6	public void checkForWin ( ) { if ( this . playerScore >= this . maxScore || this . computerScore >= this . maxScore ) { this . gameOn = false ; this . stopTimers ( ) ; if ( this . playerScore >= this . maxScore ) { if ( this . level < this . maxLevel ) { this . initNextLevel ( ) ; } else { this . gameOver = true ; this . gameWin = true ; } } else if ( this . computerScore >= this . maxScore ) { if ( -- this . lives > 0 ) { this . initLevel ( ) ; } else { this . gameOver = true ; this . gameWin = false ; } } } }
tr	8	public static void BitFilter ( BufferedWrapper bw , int type ) { BufferedImage temp = bw . Clone ( ) ; int w_Squares , h_Squares , s ; Color c ; switch ( type ) { case SixteenBit : int pixels = temp . getWidth ( ) * temp . getHeight ( ) ; if ( pixels < 1000000 ) { s = 4 ; } else { s = 8 ; } w_Squares = temp . getWidth ( ) / s ; h_Squares = temp . getHeight ( ) / s ; for ( int i = 0 ; i < w_Squares ; i ++ ) { for ( int j = 0 ; j < h_Squares ; j ++ ) { c = GetColor ( temp , i , j , s ) ; if ( c . getRGB ( ) == Color . BLACK . getRGB ( ) ) { continue ; } for ( int k = 0 ; k < s ; k ++ ) { for ( int m = 0 ; m < s ; m ++ ) { temp . setRGB ( ( i * s ) + k , ( j * s ) + m , c . getRGB ( ) ) ; } } } } bw . img = temp ; break ; case EightBit : break ; } }
tr	8	public long findMinimumValue ( long x , long y ) { long turns = Math . round ( Math . sqrt ( x + y ) ) ; if ( turns * turns != x + y || x == 2 || y == 2 ) { return - 1 ; } else if ( x == 0 ) { return 0 ; } else if ( x <= 2 * turns ) { return ( x % 2 == 0 ? 2 : 1 ) ; } else if ( x == 2 * turns + 1 ) { return 3 ; } else { int i = 0 ; for ( ; x > 2 * turns + 1 ; i ++ ) { x -= 2 * turns - 1 ; turns -- ; } return i + findMinimumValue ( x , y ) ; } }
tr	9	@ Override protected boolean inLineOfSight ( Point x , Point Abs ) { dx = ( x . x == 0 ) ? 0 : ( x . x > 0 ) ? 1 : - 1 ; dy = ( x . y == 0 ) ? 0 : ( x . y > 0 ) ? 1 : - 1 ; if ( x . x == 1 && x . y == 0 || x . y == 1 && x . x == 0 || x . x == - 1 && x . y == 0 || x . y == - 1 && x . x == 0 ) return true ; if ( C . isFigure ( new Point ( Abs . x - dx , Abs . y - dy ) ) ) return false ; return inLineOfSight ( new Point ( x . x - dx , x . y - dy ) , new Point ( Abs . x - dx , Abs . y - dy ) ) ; }
tr	3	public ArithmeticParser ( String [ ] programSource ) throws ParserParsingException { super ( programSource [ programSource . length - 1 ] ) ; this . context = new EvaluationContext ( ) ; for ( int i = 0 ; i < programSource . length - 1 ; i ++ ) { String [ ] parts = programSource [ i ] . replace ( " " , "" ) . split ( "=" ) ; Tree tree = new ExpressionsTreeParser ( parts [ 1 ] ) . getRootTree ( ) ; if ( parts [ 0 ] . contains ( "(" ) ) { Matcher matcher = FUNCTION_DEFINITION_PATTERN . matcher ( parts [ 0 ] ) ; if ( ! matcher . find ( ) ) throw new RuntimeException ( "Wrong definition" ) ; String functionName = matcher . group ( 1 ) ; String argumentName = matcher . group ( 2 ) ; context . addFunctionValue ( functionName , argumentName , tree ) ; } else { context . addVarValue ( parts [ 0 ] , tree ) ; } } }
tr	6	public String perform ( HttpServletRequest request ) { List < String > errors = new ArrayList < String > ( ) ; request . setAttribute ( "errors" , errors ) ; try { SearchCustomerName form = formBeanFactory . create ( request ) ; request . setAttribute ( "form" , form ) ; Transaction . begin ( ) ; int customer_id = customerDAO . getCustomerId ( form . getUsername ( ) ) ; CustomerBean cb = customerDAO . getCustomerInfo ( customer_id ) ; if ( ! form . isPresent ( ) ) { Transaction . commit ( ) ; return "e_reset-pwd.jsp" ; } errors . addAll ( form . getValidationErrors ( ) ) ; if ( errors . size ( ) != 0 ) { Transaction . commit ( ) ; return "e_reset-pwd.jsp" ; } CustomerBean customer = ( CustomerBean ) request . getAttribute ( "userName" ) ; request . setAttribute ( "customer" , cb ) ; HttpSession session = request . getSession ( ) ; session . setAttribute ( "customer" , cb ) ; Transaction . commit ( ) ; return "e_reset-pfc.do" ; } catch ( RollbackException e ) { errors . add ( e . toString ( ) ) ; return "e_reset-pwd.jsp" ; } catch ( FormBeanException e ) { errors . add ( e . toString ( ) ) ; return "e_reset-pwd.jsp" ; } catch ( Exception e ) { errors . add ( e . getMessage ( ) ) ; return "e_reset-pwd.jsp" ; } finally { if ( Transaction . isActive ( ) ) Transaction . rollback ( ) ; } }
tr	8	public void run ( ) { ParallelWarteClass paraWait = new ParallelWarteClass ( 10000 ) ; paraWait . start ( ) ; while ( ! ( HWaccess . readInt ( Adressen . LaufbandEingang . ordinal ( ) ) == 1 ) && paraWait . isAlive ( ) ) { try { Thread . sleep ( 150 ) ; } catch ( InterruptedException e ) { interrupt ( ) ; } } if ( ! paraWait . isAlive ( ) ) { interrupt ( ) ; return ; } else { paraWait . interrupt ( ) ; } paraWait = new ParallelWarteClass ( 10000 ) ; paraWait . start ( ) ; while ( ! ( HWaccess . readInt ( Adressen . LaufbandEingang . ordinal ( ) ) == 0 ) && paraWait . isAlive ( ) ) { try { Thread . sleep ( 150 ) ; } catch ( InterruptedException e ) { this . interrupt ( ) ; } } if ( ! paraWait . isAlive ( ) ) { interrupt ( ) ; } else { paraWait . interrupt ( ) ; } result = true ; }
tr	6	private boolean publish ( Uri topic_uri , Object data , boolean exclude_me , String [ ] exclude , String [ ] eligible ) { ArrayNode request = json_mapper_ . createArrayNode ( ) ; request . add ( is_server_ ? kEvent : kPublish ) ; request . add ( topic_uri . toString ( ) ) ; request . addPOJO ( data ) ; if ( exclude_me ) { request . add ( exclude_me ) ; } else if ( exclude != null ) { request . addPOJO ( exclude ) ; } if ( eligible != null ) { if ( request . size ( ) < 4 ) { request . addPOJO ( new String [ ] { } ) ; } request . addPOJO ( eligible ) ; } try { return sender_ . sendText ( json_mapper_ . writeValueAsString ( request ) ) ; } catch ( JsonProcessingException e ) { return false ; } }
tr	9	public boolean skipPast ( String to ) throws JSONException { boolean b ; char c ; int i ; int j ; int offset = 0 ; int length = to . length ( ) ; char [ ] circle = new char [ length ] ; for ( i = 0 ; i < length ; i += 1 ) { c = next ( ) ; if ( c == 0 ) { return false ; } circle [ i ] = c ; } for ( ; ; ) { j = offset ; b = true ; for ( i = 0 ; i < length ; i += 1 ) { if ( circle [ j ] != to . charAt ( i ) ) { b = false ; break ; } j += 1 ; if ( j >= length ) { j -= length ; } } if ( b ) { return true ; } c = next ( ) ; if ( c == 0 ) { return false ; } circle [ offset ] = c ; offset += 1 ; if ( offset >= length ) { offset -= length ; } } }
tr	6	public String nextTo ( String delimiters ) throws JSONException { char c ; StringBuffer sb = new StringBuffer ( ) ; for ( ; ; ) { c = this . next ( ) ; if ( delimiters . indexOf ( c ) >= 0 || c == 0 || c == '' || c == '' ) { if ( c != 0 ) { this . back ( ) ; } return sb . toString ( ) . trim ( ) ; } sb . append ( c ) ; } }
tr	0	public Vector2f add ( Vector2f r ) { return new Vector2f ( x + r . getX ( ) , y + r . getY ( ) ) ; }
tr	9	private Tuile showTuile ( int x , int y ) { Tuile t = null ; Point p = new Point ( x , y ) ; Personnage pers ; for ( int i = 0 ; i < nbTuiles ; i ++ ) { if ( tuilesActivees [ i ] && jtuiles [ i ] . getTuile ( ) . collision ( p ) ) { jtuiles [ i ] . setVisible ( true ) ; t = jtuiles [ i ] . getTuile ( ) ; if ( perso != null && getTuileNumero ( perso . getPosX ( ) , perso . getPosY ( ) ) == i ) { perso . afficherPseudo ( ) ; } else if ( perso != null ) { perso . cacherPseudo ( ) ; } for ( int j = 0 , l = personnagesPresents . size ( ) ; j < l ; j ++ ) { pers = personnagesPresents . get ( j ) ; if ( pers != null && getTuileNumero ( pers . getPosX ( ) , pers . getPosY ( ) ) == i ) { pers . afficherPseudo ( ) ; } else if ( pers != null ) { pers . cacherPseudo ( ) ; } } } else { jtuiles [ i ] . setVisible ( false ) ; } } repaint ( ) ; return t ; }
tr	7	public static boolean copyFile ( File from , File to , byte [ ] buf ) { if ( buf == null ) buf = new byte [ BUFFER_SIZE ] ; FileInputStream from_s = null ; FileOutputStream to_s = null ; try { from_s = new FileInputStream ( from ) ; to_s = new FileOutputStream ( to ) ; for ( int bytesRead = from_s . read ( buf ) ; bytesRead > 0 ; bytesRead = from_s . read ( buf ) ) { to_s . write ( buf , 0 , bytesRead ) ; } to_s . getFD ( ) . sync ( ) ; } catch ( IOException ioe ) { return false ; } finally { if ( from_s != null ) { try { from_s . close ( ) ; from_s = null ; } catch ( IOException ioe ) { } } if ( to_s != null ) { try { to_s . close ( ) ; to_s = null ; } catch ( IOException ioe ) { } } } return true ; }
tr	2	public final CC grow ( float ... widthHeight ) { switch ( widthHeight . length ) { default : throw new IllegalArgumentException ( "Illegal argument count: " + widthHeight . length ) ; case 2 : growY ( widthHeight [ 1 ] ) ; case 1 : growX ( widthHeight [ 0 ] ) ; } return this ; }
tr	5	public static int diasMes ( String mesInt ) { int result ; String mes = mesInt . toLowerCase ( ) ; switch ( mes ) { case "febrero" : result = 28 ; break ; case "abril" : case "junio" : case "septiembre" : case "noviembre" : result = 30 ; break ; default : result = 31 ; break ; } return result ; }
tr	3	public String getMimetype ( String paramString ) { int i = paramString . lastIndexOf ( "." ) ; if ( ( i > 0 ) && ( i + 1 < paramString . length ( ) ) ) { String str1 = paramString . substring ( i + 1 ) ; if ( this . extensionToMimetypeMap . keySet ( ) . contains ( str1 ) ) { String str2 = ( String ) this . extensionToMimetypeMap . get ( str1 ) ; logger . info ( "Recognised extension '" + str1 + "'  mimetype is: '" + str2 + "'" ) ; return str2 ; } logger . info ( "Extension '" + str1 + "' is unrecognized in mime type listing" + "  using default mime type: '" + "application/octet-stream" + "'" ) ; } else { logger . info ( "File name has no extension  mime type cannot be recognised for: " + paramString ) ; } return "application/octet-stream" ; }
tr	2	@ Override public String toString ( ) { final StringBuilder bld = new StringBuilder ( this . getClass ( ) . getSimpleName ( ) ) . append ( ": " ) ; if ( ! PRIMITIVES . contains ( this . name ) ) { bld . append ( this . packageName != null ? this . packageName : "[default package]" ) . append ( "." ) ; } return bld . append ( this . name ) . toString ( ) ; }
tr	6	public boolean showEventMessage ( final List < CalendarEventData > calendarEventList ) { if ( SwingUtilities . isEventDispatchThread ( ) ) { Message message = createCalendarEventDataMessage ( calendarEventList ) ; trayIcon . setToolTip ( message . getString ( ) ) ; int ret = 0 ; String dialogMessage = createCalendarEventDataMessageForDialog ( message . getString ( ) ) ; String title = getNotificationTitleString ( ) ; int option = JOptionPane . YES_NO_OPTION ; int messageType = 0 ; ImageIcon icon = null ; if ( message . isWarning ( ) ) { messageType = JOptionPane . WARNING_MESSAGE ; icon = getWarningIcon ( ) ; } else { messageType = JOptionPane . INFORMATION_MESSAGE ; icon = getNoticeIcon ( ) ; } frame . setVisible ( true ) ; System . out . println ( "\u307B\u3052\u3089" + Thread . currentThread ( ) . getName ( ) ) ; ret = JOptionPane . showConfirmDialog ( frame , dialogMessage , title , option , messageType , icon ) ; frame . setVisible ( false ) ; if ( ret == 0 ) { return true ; } else { return false ; } } else { final List < boolean > result = new ArrayList < boolean > ( ) ; try { SwingUtilities . invokeAndWait ( new Runnable ( ) { @ Override public void run ( ) { result . add ( showEventMessage ( calendarEventList ) ) ; } } ) ; } catch ( InterruptedException e ) { } catch ( InvocationTargetException e ) { } if ( result . size ( ) != 0 ) { return result . get ( 0 ) ; } return true ; } }
tr	3	public List < Node > findPath ( int xStart , int yStart , int xGoal , int yGoal , ALGO algo , Squadron squad ) { List < Node > path = null ; Node start = new Node ( xStart , yStart ) ; Node goal = new Node ( xGoal , yGoal ) ; switch ( algo ) { case ASTAR : PathFinding aStar = new AStar ( start , goal , bwapi ) ; path = aStar . calc ( Integer . MAX_VALUE , Integer . MAX_VALUE ) ; break ; case TBASTAR : PathFinding tbaStar = new TBAStar ( start , goal , bwapi , squad ) ; path = tbaStar . calc ( 100 , 100 ) ; break ; case LRTASTAR : LRTAStar lrtaStar = new LRTAStar ( start , goal , bwapi ) ; path = lrtaStar . calc ( - 1 , - 1 ) ; break ; default : aStar = new AStar ( start , goal , bwapi ) ; path = aStar . calc ( Integer . MAX_VALUE , Integer . MAX_VALUE ) ; break ; } return path ; }
tr	5	protected void drawBackground ( Graphics2D g , double x , double y , double w , double h ) { double l = box . getLeftMargin ( ) != null ? box . getLeftMargin ( ) . getValue ( Unit . PT ) : 0 ; double r = box . getRightMargin ( ) != null ? box . getRightMargin ( ) . getValue ( Unit . PT ) : 0 ; double t = box . getTopMargin ( ) != null ? box . getTopMargin ( ) . getValue ( Unit . PT ) : 0 ; double b = box . getBottomMargin ( ) != null ? box . getBottomMargin ( ) . getValue ( Unit . PT ) : 0 ; x += l ; y += t ; w -= l + r ; h -= t + b ; if ( box . getBackground ( ) != null ) { Color savedColor = g . getColor ( ) ; g . setColor ( box . getBackground ( ) ) ; g . fill ( new Rectangle2D . double ( x , y , w , h ) ) ; g . setColor ( savedColor ) ; } }
tr	0	public String toString ( ) { return "Expert Attack:\t" + getDescription ( ) ; }
tr	7	public boolean equals ( Object o ) { if ( this == o ) { return true ; } if ( o == null || getClass ( ) != o . getClass ( ) ) { return false ; } Option option = ( Option ) o ; if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) { return false ; } return true ; }
tr	0	public void cargarDialogoCrearPersona ( ) { dialogoCrearPersona . setVisible ( true ) ; }
tr	0	public ContentStoreException ( String s ) { super ( s ) ; }
tr	5	public void changeChunk ( Chunk newC , int n , AvaloneGLAPI glapi ) { const . debug ( "(Player:changeChunk): oldChunkX = " + currentChunk . pos . x ) ; const . debug ( "(Player:changeChunk): oldChunkY = " + currentChunk . pos . y ) ; currentChunk . playerList . remove ( this ) ; super . changeChunk ( newC , n , glapi ) ; currentChunk . playerList . add ( this ) ; const . debug ( "(Player:changeChunk): newChunkX = " + currentChunk . pos . x ) ; const . debug ( "(Player:changeChunk): newChunkY = " + currentChunk . pos . y ) ; Map . allowedToDraw = false ; if ( newC instanceof SurfaceChunk ) { const . debug ( "(Player:changeChunk): biome id = " + ( ( SurfaceChunk ) newC ) . biome ) ; } int centerX = const . tailleFenX / 2 ; int centerY = const . tailleFenY / 2 ; if ( n == 1 ) { glapi . setView ( centerX - const . tailleCase , pos . y - centerY ) ; } else if ( n == 2 ) { glapi . setView ( - centerX , pos . y - centerY ) ; } else if ( n == 3 ) { glapi . setView ( pos . x - centerX , centerY - const . tailleCase ) ; } else if ( n == 4 ) { glapi . setView ( pos . x - centerX , - centerY ) ; } }
tr	5	public void selectWall ( int node1 , int node2 ) { if ( ! this . doors . edgeExists ( node1 , node2 ) && ! this . exits . edgeExists ( node1 , node2 ) ) { if ( this . walls . edgeExists ( node1 , node2 ) ) { this . removeWall ( node1 , node2 ) ; } else if ( node1 != 0 && node2 != 0 ) { this . addWall ( node1 , node2 ) ; } } }
tr	2	public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; int n = 0 , cnt = 1 ; HDOJ1069 hdoj1069 = new HDOJ1069 ( ) ; while ( ( n = scanner . nextInt ( ) ) > 0 ) { hdoj1069 . init ( ) ; while ( n -- > 0 ) { hdoj1069 . handleInput ( scanner . nextInt ( ) , scanner . nextInt ( ) , scanner . nextInt ( ) ) ; } System . out . println ( String . format ( "Case %s: maximum height = %s" , cnt ++ , hdoj1069 . entrance ( ) ) ) ; } }
tr	8	public Location getFirstSquareNeighborLocation ( int row , int col , int dist , int id ) { for ( int x = row - dist ; x <= row + dist ; x ++ ) { if ( isInBounds ( x ) ) { for ( int y = col - dist ; y <= col + dist ; y ++ ) { if ( isInBounds ( y ) && thisTick [ x ] [ y ] != null && ! ( x == row && y == col ) && thisTick [ x ] [ y ] . id == id ) { return new Location ( x , y ) ; } } } } return null ; }
tr	1	@ Override public boolean isYesFromBinaryChoice ( String message ) { int response = - 1 ; while ( response < 0 ) { response = JOptionPane . showConfirmDialog ( boardGameDisplay , message , "Choose" , JOptionPane . YES_NO_OPTION ) ; } return response == 0 ; }
tr	0	@ Override public void onWeaponFired ( int id , Weapon weapon ) { }
tr	7	public void disconnect ( ) { if ( socket != null && socket . isConnected ( ) && ! socket . isClosed ( ) ) { if ( writer != null ) { try { writer . write ( ":tmi.twitch.tv QUIT :disconnected" ) ; writer . newLine ( ) ; writer . flush ( ) ; socket . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } if ( receiveThread != null ) { try { receiveThread . join ( ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } receiveThread = null ; } socket = null ; writer = null ; reader = null ; } }
tr	5	public static Method findVisitMethod ( MatchProcessor visitor , Match node ) { Method visitMethod = null ; class < ? > visitorClass = visitor . getClass ( ) ; Map < String , Method > visitMethods = __visitMethodCache . get ( visitorClass ) ; if ( visitMethods == null ) __visitMethodCache . put ( visitorClass , visitMethods = new HashMap < String , Method > ( ) ) ; String methodName = node . getParser ( ) . getLabel ( ) ; methodName = "process" + methodName . substring ( 0 , 1 ) . toUpperCase ( ) + methodName . substring ( 1 ) ; visitMethod = visitMethods . get ( methodName ) ; if ( visitMethod == null ) { try { visitMethod = visitorClass . getMethod ( methodName , Match . class ) ; visitMethods . put ( methodName , visitMethod ) ; } catch ( Exception e ) { } } if ( visitMethod == null ) return __defaultVisitMethod ; return visitMethod ; }
tr	6	private JPopupMenu createPopupEntry ( ) { JPopupMenu popup = new JPopupMenu ( ) ; popup . add ( addAction ) ; popup . add ( editAction ) ; popup . add ( delAction ) ; popup . addSeparator ( ) ; popup . add ( cutAction ) ; popup . add ( copyAction ) ; popup . add ( pasteAction ) ; popup . addSeparator ( ) ; ActionListener al = new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { JMenuItem m = ( JMenuItem ) e . getSource ( ) ; ZamokView view = getTab ( ) ; PasswordEntry entry = view . getSelectedEntry ( ) ; if ( entry == null ) { return ; } String retval = "" ; if ( m . getText ( ) . equals ( "Username" ) ) { retval = entry . getLogin ( ) ; } else if ( m . getText ( ) . equals ( "Password" ) ) { retval = entry . getPassword ( false ) ; } else if ( m . getText ( ) . equals ( "URL" ) ) { retval = entry . getURL ( ) ; } else if ( m . getText ( ) . equals ( "eMail" ) ) { retval = entry . getEmail ( ) ; } if ( ! "" . equals ( retval ) ) { StringSelection selection = new StringSelection ( retval ) ; Clipboard clipboard = Toolkit . getDefaultToolkit ( ) . getSystemClipboard ( ) ; clipboard . setContents ( selection , null ) ; } } } ; JMenuItem mi ; JMenu menuCopy = ( JMenu ) popup . add ( new JMenu ( UIHelper . getString ( "Menu.Copy" ) ) ) ; mi = createPopupCopyMenuItem ( "username.png" , "Username" , al ) ; menuCopy . add ( mi ) ; mi = createPopupCopyMenuItem ( "password.png" , "Password" , al ) ; menuCopy . add ( mi ) ; mi = createPopupCopyMenuItem ( "url.png" , "URL" , al ) ; menuCopy . add ( mi ) ; mi = createPopupCopyMenuItem ( "mail.png" , "eMail" , al ) ; menuCopy . add ( mi ) ; return popup ; }
