va	8	private void parseStatus ( UserState status , Map < String , Object > pageVariables ) { switch ( status ) { case EMPTY_DATA : case FAILED_AUTH : case NO_SUCH_USER_FOUND : case SQL_ERROR : case USER_ALREADY_EXISTS : pageVariables . put ( "errorMsg" , status . getMessage ( ) ) ; break ; case WAIT_AUTH : case WAIT_USER_REG : case USER_ADDED : pageVariables . put ( "infoMsg" , status . getMessage ( ) ) ; break ; default : pageVariables . put ( "userStatus" , status . getMessage ( ) ) ; break ; } }
va	4	private int findNextStartIndex ( String [ ] words , int start , int L , List < String > lines ) { int i = start ; List < String > lineWords = new ArrayList < String > ( ) ; int len = 0 ; while ( len < L && i < words . length ) { String word = words [ i ] ; if ( len + word . length ( ) <= L ) { lineWords . add ( word ) ; len += 1 + word . length ( ) ; i ++ ; } else { break ; } } lines . add ( formatLine ( lineWords , L , i == words . length || lineWords . size ( ) == 1 ) ) ; return i ; }
va	4	public static void removeImageToAllEntities ( String name , GrandView reference ) { ArrayList < GameEntity > entities = reference . getLevel ( ) . getEntities ( ) ; ArrayList < SavedEntityState > saved = reference . getConfigs ( ) ; for ( int i = 0 ; i < saved . size ( ) ; i ++ ) saved . get ( i ) . getImages ( ) . remove ( name ) ; for ( int i = 0 ; i < entities . size ( ) ; i ++ ) { EntityState state = entities . get ( i ) . getState ( ) ; for ( int f = 0 ; f < state . getImages ( ) . size ( ) ; f ++ ) if ( state . getImages ( ) . get ( f ) . getKey ( ) . equals ( name ) ) state . getImages ( ) . remove ( f -- ) ; } }
va	3	public static String getWebPageSource ( String url ) throws IOException { URL u ; InputStream is = null ; BufferedReader br ; String line ; StringBuilder sb = new StringBuilder ( ) ; try { u = new URL ( url ) ; is = u . openStream ( ) ; br = new BufferedReader ( new InputStreamReader ( new BufferedInputStream ( is ) ) ) ; while ( ( line = br . readLine ( ) ) != null ) { sb . append ( line ) . append ( "\n" ) ; } return sb . toString ( ) ; } finally { try { if ( is != null ) is . close ( ) ; } catch ( IOException ioe ) { ioe . printStackTrace ( ) ; } } }
va	3	@ Override public void onAddTourist ( long userTime , String imsi , Accout . Status preStatus ) { if ( preStatus == Accout . Status . Tourist ) return ; if ( ! accout8 . isWorker ( ) && ! accout18 . isWorker ( ) ) { listener . onAddTourist ( userTime , imsi , status ) ; status = Accout . Status . Tourist ; } }
va	9	private void displayEntrancesAndDoors ( ) { for ( final Entrance entrance : cage . getEntrances ( ) . values ( ) ) { JPanel entrancePanel = new JPanel ( ) ; JLabel entranceLabel = new JLabel ( "Entrance:" ) ; entranceLabel . setForeground ( Color . WHITE ) ; entrancePanel . setBackground ( new Color ( 0 , 0 , 0 , 80 ) ) ; entrancePanel . add ( entranceLabel ) ; lowerLowerDisplay . add ( entrancePanel ) ; JButton deleteEntranceButton = new JButton ( "Delete Entrance" ) ; entrancePanel . add ( deleteEntranceButton ) ; deleteEntranceButton . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent ae ) { int result = JOptionPane . showConfirmDialog ( null , "Are you sure you want to delete this entrance?" , "Warning!" , JOptionPane . OK_CANCEL_OPTION , JOptionPane . WARNING_MESSAGE ) ; if ( result == JOptionPane . OK_OPTION ) { for ( Door door : entrance . getDoors ( ) . values ( ) ) { query1 . deleteDoor ( door . getId ( ) ) ; } query2 . deleteEntrance ( entrance . getId ( ) ) ; refresh ( ) ; } } } ) ; final LinkedHashMap < Integer , Door > doors = entrance . getDoors ( ) ; for ( final Door door : doors . values ( ) ) { try { final int doorId = door . getId ( ) ; JPanel doorPanel = new JPanel ( new BorderLayout ( ) ) ; ImagePanel picturePanel = new ImagePanel ( ) ; picturePanel . setLayout ( new BorderLayout ( ) ) ; if ( door . isOpen ( ) ) { picturePanel . setImage ( OPEN_IMAGE ) ; } else if ( ! door . isOpen ( ) ) { if ( door . isLocked ( ) ) { picturePanel . setImage ( LOCKED_IMAGE ) ; } else { picturePanel . setImage ( CLOSED_IMAGE ) ; } } picturePanel . setPreferredSize ( new Dimension ( 134 , 123 ) ) ; JButton deleteDoorButton = new JButton ( "Delete" ) ; deleteDoorButton . setFont ( new Font ( "Arial" , 0 , 10 ) ) ; deleteDoorButton . setSize ( new Dimension ( 67 , 100 ) ) ; JPanel buttonPanel = new JPanel ( new BorderLayout ( ) ) ; buttonPanel . setBackground ( new Color ( 0 , 0 , 0 , 0 ) ) ; buttonPanel . add ( deleteDoorButton , BorderLayout . CENTER ) ; doorPanel . add ( buttonPanel , BorderLayout . SOUTH ) ; doorPanel . add ( picturePanel , BorderLayout . NORTH ) ; doorPanel . setBackground ( new Color ( 0 , 0 , 0 , 0 ) ) ; entrancePanel . add ( doorPanel ) ; deleteDoorButton . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent ae ) { int result = JOptionPane . showConfirmDialog ( null , "Are you sure you want to delete this door?" , "Warning!" , JOptionPane . OK_CANCEL_OPTION , JOptionPane . WARNING_MESSAGE ) ; if ( result == JOptionPane . OK_OPTION ) { System . err . println ( doorId ) ; query1 . deleteDoor ( doorId ) ; refresh ( ) ; } } } ) ; } catch ( IOException ex ) { System . out . println ( ex ) ; } } JButton newDoorButton = new JButton ( "Add Door" ) ; entrancePanel . add ( newDoorButton ) ; if ( entrance . getDoors ( ) . size ( ) == 2 ) { newDoorButton . setVisible ( false ) ; } newDoorButton . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent ae ) { query1 . addNewDoor ( entrance . getId ( ) ) ; refresh ( ) ; } } ) ; } JButton newEntranceButton = new JButton ( "Add Entrance" ) ; lowerLowerDisplay . add ( newEntranceButton ) ; if ( cage . getEntrances ( ) . size ( ) == 2 ) { newEntranceButton . setVisible ( false ) ; } newEntranceButton . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent ae ) { query1 . addNewEntrance ( cage . getId ( ) ) ; refresh ( ) ; } } ) ; }
va	3	@ Override public String process ( String content ) throws ProcessorException { pipeline = new SimpleAuthenticationPipeline ( ) ; context = new AuthenticateContext ( ) ; pipeline . setBasic ( new LoginEntryValve ( ) ) ; pipeline . addValve ( new FlushValve ( ) ) ; pipeline . addValve ( new EncodeValve ( ) ) ; pipeline . addValve ( new GetTokenValve ( ) ) ; pipeline . addValve ( new AuthenticateValve ( ) ) ; pipeline . addValve ( new ValidationValve ( ) ) ; pipeline . addValve ( new DecoderValve ( ) ) ; pipeline . setContext ( context ) ; try { pipeline . invoke ( context . getRequest ( ) , context . getResponse ( ) , null ) ; } catch ( ValveException e ) { e . printStackTrace ( ) ; User user = context . getRequest ( ) . getCurrentUser ( ) ; String response = "" ; if ( user == null || user . getUserName ( ) == null ) { response = ExceptionWrapper . toJSON ( 503 , "Internal Error" ) ; } else { response = ExceptionWrapper . toJSON ( user , e . getCode ( ) , e . getMessage ( ) ) ; } return response ; } return context . getResponse ( ) . getResponse ( ) ; }
va	7	public static void main ( String [ ] args ) throws NoSuchAlgorithmException , UnsupportedEncodingException { Serveur serveur ; try { serveur = new Serveur ( ) ; serveur . getServeur ( ) . inscription ( "momo" , "jojo" ) ; serveur . getServeur ( ) . inscription ( "jojo" , "momo" ) ; Client c = new Client ( "momo" , "jojo" ) ; Client c1 = new Client ( "jojo" , "momo" ) ; try { c . telecharger ( new File ( "/home/b/brocarcl/git/miage_projet_framework/docServeur/image.jpg" ) , new File ( "/home/b/brocarcl/Bureau/download.jpg" ) ) ; } catch ( IOException e2 ) { e2 . printStackTrace ( ) ; } ArrayList < Utilisateur > utilisateurs = new ArrayList < Utilisateur > ( ) ; ArrayList < Groupe > groupes = new ArrayList < Groupe > ( ) ; DateFormat df = new SimpleDateFormat ( "dd-MM-yyyy" ) ; Date date = null ; try { date = df . parse ( "25-12-2010" ) ; } catch ( ParseException e1 ) { e1 . printStackTrace ( ) ; } ArrayList < Publication > publications = c . getPublications ( ) ; ArrayList < Publication > publicationsvisiblesC1 = c1 . getPublicationsVisibles ( ) ; System . out . println ( "fichier(s) visible(s) pour : " + c1 . getUtilisateur ( ) . getLogin ( ) ) ; for ( Publication pub : publicationsvisiblesC1 ) { System . out . println ( "" + pub . getDocument ( ) . getEmplacement ( ) ) ; } System . out . println ( "publications de  : " + c . getUtilisateur ( ) . getLogin ( ) ) ; for ( Publication pub : publications ) { System . out . println ( "" + pub . getDocument ( ) . getEmplacement ( ) ) ; } System . out . println ( "Autorisation a c1 " ) ; c . autoriserPublicationUtilisateur ( c . getPublications ( ) . get ( 0 ) , c1 . getUtilisateur ( ) ) ; publicationsvisiblesC1 = c1 . getPublicationsVisibles ( ) ; System . out . println ( "fichier(s) visible(s) pour : " + c1 . getUtilisateur ( ) . getLogin ( ) ) ; for ( Publication pub : publicationsvisiblesC1 ) { System . out . println ( "" + pub . getDocument ( ) . getEmplacement ( ) ) ; } System . out . println ( "Retrait de l'autorisation" ) ; c . retirerUnePublicationutilisateur ( c . getPublications ( ) . get ( 0 ) , c1 . getUtilisateur ( ) ) ; System . out . println ( "fichier(s) visible(s) pour : " + c1 . getUtilisateur ( ) . getLogin ( ) ) ; publicationsvisiblesC1 = c1 . getPublicationsVisibles ( ) ; for ( Publication pub : publicationsvisiblesC1 ) { System . out . println ( "" + pub . getDocument ( ) . getEmplacement ( ) ) ; } } catch ( RemoteException e ) { e . printStackTrace ( ) ; } }
va	4	public boolean FindAugmentingPath ( Vertex vertex ) { for ( Vertex vertexD : vertex . adjList ) { if ( ! vertexD . visited ) { vertexD . visited = true ; if ( vertexD . matched == null || FindAugmentingPath ( vertexD . matched ) ) { vertex . matched = vertexD ; vertexD . matched = vertex ; return true ; } } } return false ; }
va	5	private static boolean CheckAllStable ( int count ) { int index = 0 ; for ( Map . Entry < ABObject , boolean > _entry : StabilityDictionary . entrySet ( ) ) { if ( _entry . getValue ( ) ) { index ++ ; } } if ( count == index ) return false ; for ( Map . Entry < ABObject , boolean > _entry : StabilityDictionary . entrySet ( ) ) { if ( ! _entry . getValue ( ) ) { return true ; } } return false ; }
va	4	private void setClosestEnemies ( ) { closestEnemies . clear ( ) ; for ( Ship mine : ClientGame . getMyShips ( ) ) { Coordinate c = mine . getLocation ( ) ; Ship closest = null ; double dist = - 1 ; for ( Ship enemy : ClientGame . getOpponentShips ( ) ) { double temp = c . distanceTo ( enemy . getLocation ( ) ) ; if ( closest == null || temp < dist ) { closest = enemy ; dist = temp ; } } closestEnemies . put ( mine , closest . getLocation ( ) ) ; } }
va	7	private static TspPopulation [ ] generate ( ) { Graph g = new Graph ( INDIVIDUAL_SIZE ) ; TspPopulation [ ] h = new TspPopulation [ GLOBAL_STEPS ] ; for ( int i = 0 ; i < GLOBAL_STEPS ; ++ i ) { h [ i ] = new TspPopulation ( POPULATION_SIZE , INDIVIDUAL_SIZE , g . getGraph ( ) ) ; } resultsRandom = new long [ GLOBAL_STEPS ] ; Arrays . fill ( resultsRandom , long . MAX_VALUE ) ; for ( int i = 0 ; i < GLOBAL_STEPS ; ++ i ) { if ( i % 100 == 0 ) { System . out . println ( "random " + i ) ; } TspPopulation populationRandom = new TspPopulation ( h [ i ] ) ; InverseOperator randomIO = new InverseOperator ( populationRandom , RNG ) ; SwapOperator randomSWO = new SwapOperator ( populationRandom , RNG ) ; ScrambleOperator randomSCO = new ScrambleOperator ( populationRandom , RNG ) ; MPX1 randomMPX1 = new MPX1 ( populationRandom , RNG ) ; MPX2 randomMPX2 = new MPX2 ( populationRandom , RNG ) ; for ( int step = 0 ; step < MAX_STEPS ; ++ step ) { double r ; synchronized ( RNG ) { r = RNG . nextDouble ( ) ; } if ( r < 0.33 ) { randomIO . mutate ( ) ; } else if ( r < 0.66 ) { randomSWO . mutate ( ) ; } else if ( r < 1.1 ) { randomSCO . mutate ( ) ; } } resultsRandom [ i ] = populationRandom . getFittest ( ) ; } Arrays . sort ( resultsRandom ) ; return h ; }
va	4	protected void dispatchEvent ( AWTEvent event ) { super . dispatchEvent ( event ) ; if ( ! ( event instanceof MouseEvent ) ) return ; MouseEvent me = ( MouseEvent ) event ; if ( ! me . isPopupTrigger ( ) ) return ; Component comp = SwingUtilities . getDeepestComponentAt ( me . getComponent ( ) , me . getX ( ) , me . getY ( ) ) ; if ( ! ( comp instanceof JTextPane ) ) return ; if ( MenuSelectionManager . defaultManager ( ) . getSelectedPath ( ) . length > 0 ) return ; Point pt = SwingUtilities . convertPoint ( me . getComponent ( ) , me . getPoint ( ) , textPane ) ; popupMenu . show ( textPane , pt . x , pt . y ) ; }
va	2	public static Object intersect ( Line a , Line b ) { double a1 = a . getA ( ) , b1 = a . getB ( ) , c1 = a . getC ( ) ; double a2 = b . getA ( ) , b2 = b . getB ( ) , c2 = b . getC ( ) ; double d = a1 * b2 - a2 * b1 ; double dX = b1 * c2 - b2 * c1 ; double dY = a2 * c1 - a1 * c2 ; if ( Utils . cmp ( d , 0. ) == 0 ) { if ( Utils . cmp ( c1 , c2 ) == 0 ) return a ; return null ; } else { return new Point ( dX / d , dY / d ) ; } }
va	5	public String getComplementString ( String stringToComplement ) { String complement = "" ; for ( int i = 0 ; i < stringToComplement . length ( ) ; i ++ ) { Character complementChar = stringToComplement . charAt ( i ) ; if ( complementChar . equals ( A ) ) { complement = complement + "T" ; } else if ( complementChar . equals ( T ) ) { complement = complement + "A" ; } else if ( complementChar . equals ( C ) ) { complement = complement + "G" ; } else if ( complementChar . equals ( G ) ) { complement = complement + "C" ; } } return complement ; }
va	2	public boolean update ( BaseSetting bs ) { Connection connection = bs . getConnection ( ) ; try { if ( this . id_s < 0 ) { String query = "UPDATE Screen SET name_s = ? WHERE id_s = ?" ; PreparedStatement p_statement = connection . prepareStatement ( query ) ; p_statement . setString ( 1 , this . name_s ) ; p_statement . setInt ( 2 , this . id_s ) ; p_statement . executeUpdate ( ) ; } } catch ( SQLException sqle ) { System . out . println ( "ERREUR" ) ; sqle . printStackTrace ( ) ; } return true ; }
va	0	private void unlinkMRUNodes ( ) { ObjectDef . mruNodes1 . unlinkAll ( ) ; ObjectDef . mruNodes2 . unlinkAll ( ) ; EntityDef . mruNodes . unlinkAll ( ) ; ItemDef . mruNodes2 . unlinkAll ( ) ; ItemDef . mruNodes1 . unlinkAll ( ) ; Player . mruNodes . unlinkAll ( ) ; SpotAnim . aMRUNodes_415 . unlinkAll ( ) ; }
va	5	public void addItem ( int s , int t , int comp , int r , int type , double value , ParseForestItem left , ParseForestItem right ) { if ( chart [ s ] [ t ] [ comp ] [ K - 1 ] == null || value > chart [ s ] [ t ] [ comp ] [ K - 1 ] . score ) { ParseForestItem item = new ParseForestItem ( s , t , comp , r , type , value , left , right ) ; int i = K - 1 ; while ( i > 0 && ( chart [ s ] [ t ] [ comp ] [ i - 1 ] == null || value > chart [ s ] [ t ] [ comp ] [ i - 1 ] . score ) ) { chart [ s ] [ t ] [ comp ] [ i ] = chart [ s ] [ t ] [ comp ] [ i - 1 ] ; -- i ; } chart [ s ] [ t ] [ comp ] [ i ] = item ; } }
va	8	@ Override public Validator < ResourceModel > getValidator ( ) { return new Validator < ResourceModel > ( ) { @ Override public Set < ConstraintViolation > validate ( ResourceModel item ) { Set < ConstraintViolation > constraints = new HashSet < ConstraintViolation > ( ) ; Map < String , ResourceParameter > params = item . getParametersMap ( ) ; ResourceParameter param = params . get ( "exoBool" ) ; String value = param . getValue ( ) ; if ( value == null || value . equals ( "" ) ) { ConstraintViolation constraint = new ConstraintViolation ( ) ; constraint . setMessage ( "The boolean exoBool must be set." ) ; constraint . setLevel ( ConstraintViolationLevel . CRITICAL ) ; constraint . setValueName ( param . getName ( ) ) ; constraints . add ( constraint ) ; } param = params . get ( "raCol" ) ; value = param . getValue ( ) ; if ( value == null || value . equals ( "" ) ) { ConstraintViolation constraint = new ConstraintViolation ( ) ; constraint . setMessage ( "The attribute for RA must be set." ) ; constraint . setLevel ( ConstraintViolationLevel . CRITICAL ) ; constraint . setValueName ( param . getName ( ) ) ; constraints . add ( constraint ) ; } param = params . get ( "decCol" ) ; value = param . getValue ( ) ; if ( value == null || value . equals ( "" ) ) { ConstraintViolation constraint = new ConstraintViolation ( ) ; constraint . setMessage ( "The attribute for DEC must be set." ) ; constraint . setLevel ( ConstraintViolationLevel . CRITICAL ) ; constraint . setValueName ( param . getName ( ) ) ; constraints . add ( constraint ) ; } param = params . get ( "corotIdCol" ) ; value = param . getValue ( ) ; if ( value == null || value . equals ( "" ) ) { ConstraintViolation constraint = new ConstraintViolation ( ) ; constraint . setMessage ( "The attribute for CorotID must be set." ) ; constraint . setLevel ( ConstraintViolationLevel . CRITICAL ) ; constraint . setValueName ( param . getName ( ) ) ; constraints . add ( constraint ) ; } return constraints ; } } ; }
va	1	public static long pack ( long big , int little , int bits ) { assert bits > 32 && bits < 64 ; assert big < ( 1 << bits ) ; assert little < ( 1 << ( 64 - bits ) ) ; int ls = bits & 7 ; int bm = ( 1 << ls ) - 1 ; long res = ( big & ~ bm ) << ( 64 - bits ) ; res |= ( little & ( ( 1 << ( 64 - bits ) ) - 1 ) ) << ls ; res |= big & bm ; return res ; }
va	1	public static void display ( int [ ] array , int arraySize ) { for ( int element : array ) { System . out . print ( element + " " ) ; } System . out . println ( "" ) ; }
va	4	public void run ( ) { alive = true ; for ( Player player : players ) distributeNewDice ( player , 2 * state . getCountries ( player ) . size ( ) ) ; publishStartOfGame ( state ) ; int turn = 0 ; while ( alive && ! state . isFinished ( ) && ++ turn < MAX_NUMBER_OF_TURNS ) step ( ) ; publishEndOfGame ( state ) ; }
va	9	private double computeVoracity ( int age , GenotypeViability genotypeViability ) { switch ( age + 1 ) { case 1 : return genotypeViability . voracity01 ; case 2 : return genotypeViability . voracity02 ; case 3 : return genotypeViability . voracity03 ; case 4 : return genotypeViability . voracity04 ; case 5 : return genotypeViability . voracity05 ; case 6 : return genotypeViability . voracity06 ; case 7 : return genotypeViability . voracity07 ; case 8 : return genotypeViability . voracity08 ; case 9 : return genotypeViability . voracity09 ; case 10 : return genotypeViability . voracity10 ; default : return genotypeViability . voracity10 ; } }
va	7	public void read ( BufferedReader reader ) throws IOException { modContainer . clear ( ) ; String line ; line = reader . readLine ( ) ; if ( ! "Individual Item" . equals ( line ) ) { throw new IOException ( "Wrong header: " + line ) ; } line = reader . readLine ( ) ; if ( ! "v.1" . equals ( line ) ) { throw new IOException ( "Wrong version: " + line ) ; } key = reader . readLine ( ) ; do { line = reader . readLine ( ) ; if ( "End Of Item" . equals ( line ) == false ) { String tkey = line ; if ( tkey . startsWith ( "S" ) ) { line = reader . readLine ( ) ; modContainer . put ( tkey , line ) ; } if ( tkey . startsWith ( "I" ) ) { line = reader . readLine ( ) ; modContainer . put ( tkey , new Integer ( Integer . parseInt ( line ) ) ) ; } if ( tkey . startsWith ( "T" ) ) { Triplet tri = new Triplet ( reader ) ; modContainer . put ( tkey , tri ) ; } } else { break ; } } while ( true ) ; }
va	0	StringInputBuffer ( String name , String code ) { super ( toURI ( name ) , Kind . SOURCE ) ; this . code = code ; }
va	8	private void writeBuffer ( long timeout , long startTime , ByteBuffer queryBuffer ) throws IOException { SelectionKey writeKey = socketChannel . register ( selector , SelectionKey . OP_WRITE ) ; boolean firstTime = true ; while ( queryBuffer . hasRemaining ( ) && currentTime ( ) - startTime < timeout ) { if ( ! firstTime ) { long waitDuration = startTime + timeout - currentTime ( ) ; if ( waitDuration > 0 ) { selector . select ( waitDuration ) ; } } if ( firstTime || selector . selectedKeys ( ) . size ( ) > 0 ) { int written ; do { written = socketChannel . write ( queryBuffer ) ; } while ( written > 0 ) ; if ( firstTime ) { firstTime = false ; } else { selector . selectedKeys ( ) . remove ( writeKey ) ; } } } }
va	1	public Object deserialize ( String data ) { AbstractParser adapter = ( AbstractParser ) adapters . get ( getMessageIdentifier ( data ) ) ; if ( adapter == null ) { throw new ParseException ( "Not registered message identifier" ) ; } SegmentReader segmentReader = new SegmentReaderImpl ( data , "\r\n" ) ; segmentReader . readSegment ( ) ; return adapter . deserialize ( segmentReader ) ; }
va	0	@ Override public void shareMemberData ( String key , Object object ) { }
va	1	List < Row > fit ( Row row ) { List < String > options = piecesOf ( row . option , optionWidth ) ; List < String > descriptions = piecesOf ( row . description , descriptionWidth ) ; List < Row > rows = new ArrayList < Row > ( ) ; for ( int i = 0 ; i < Math . max ( options . size ( ) , descriptions . size ( ) ) ; ++ i ) rows . add ( new Row ( itemOrEmpty ( options , i ) , itemOrEmpty ( descriptions , i ) ) ) ; return rows ; }
va	6	private void initMapping ( Field embeddedIn , class < ? > clazz ) throws Exception { List < Field > fields = new ArrayList < > ( Arrays . asList ( clazz . getDeclaredFields ( ) ) ) ; for ( Field field : fields ) { if ( checkEmbeddables ( field ) ) { continue ; } if ( ignoreFiled ( field ) ) { continue ; } boolean id = isId ( field ) ; boolean generatedValue = isGeneratedValue ( field ) ; boolean fk = isForeignKey ( field ) ; ColumnType columnType = getAssociatedType ( fk , field ) ; if ( columnType == null || columnType == ColumnType . UNKNOWN ) { throw new Error ( "Unknown column type for field " + field . getName ( ) + " in " + clazz . getSimpleName ( ) ) ; } String columnName = naming . getColumnName ( columnType , field . getName ( ) ) ; Column column = columnType . createColumn ( columnName , field , embeddedIn , id , generatedValue , fk ) ; addColumn ( column ) ; } }
va	6	public ArrayList < Borrow > getBorrows ( ) { CopyDAL objCopyDAL = new CopyDAL ( ) ; ArrayList < Copy > copyList = objCopyDAL . getCopies ( ) ; ArrayList < Borrow > borrowList = new ArrayList ( ) ; try { DocumentBuilderFactory docFactory = DocumentBuilderFactory . newInstance ( ) ; DocumentBuilder docBuilder = docFactory . newDocumentBuilder ( ) ; Document doc = docBuilder . parse ( new File ( "db/DBborrows.xml" ) ) ; doc . getDocumentElement ( ) . normalize ( ) ; NodeList borrowNodes = doc . getElementsByTagName ( "borrow" ) ; if ( borrowNodes . getLength ( ) != - 1 ) { for ( int i = 0 ; i < borrowNodes . getLength ( ) ; i ++ ) { Node borrow = borrowNodes . item ( i ) ; if ( borrow . getNodeType ( ) == Node . ELEMENT_NODE ) { Element anElement = ( Element ) borrow ; Borrow objBorrow = new Borrow ( ) ; objBorrow . setBorrowID ( Integer . parseInt ( getNodeValue ( "borrowid" , anElement ) ) ) ; int copyCode = Integer . parseInt ( getNodeValue ( "copycode" , anElement ) ) ; if ( getNodeValue ( "active" , anElement ) . equals ( "true" ) ) { objBorrow . setActive ( true ) ; } else { objBorrow . setActive ( false ) ; } Copy myCopy = new Copy ( ) ; myCopy . setBookCode ( copyCode ) ; int comparation = copyList . indexOf ( myCopy ) ; if ( comparation != - 1 ) { myCopy . setState ( copyList . get ( comparation ) . getState ( ) ) ; myCopy . setBook ( copyList . get ( comparation ) . getBook ( ) ) ; objBorrow . setBorrowedCopy ( myCopy ) ; } String myDate = getNodeValue ( "datefirst" , anElement ) ; Date theDate = new Date ( myDate ) ; objBorrow . setBorrowDate ( theDate ) ; myDate = getNodeValue ( "datelast" , anElement ) ; theDate = new Date ( myDate ) ; objBorrow . setLimitDate ( theDate ) ; borrowList . add ( objBorrow ) ; } } } } catch ( ParserConfigurationException | SAXException | IOException parseE ) { } return borrowList ; }
va	5	public void run ( ) { byte [ ] buff = new byte [ 1024 ] ; try { while ( inputStream . read ( buff ) > 0 ) { String t = new String ( buff ) ; String [ ] tokens = t . split ( "\n" ) ; for ( String s : tokens ) { if ( isErrorStream ) System . out . println ( "ERROR-STREAM: " + s ) ; else System . out . println ( s ) ; } Arrays . fill ( buff , ( byte ) 0 ) ; } inputStream . close ( ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; } if ( isErrorStream ) System . out . println ( "Output Stream finished." ) ; else System . out . println ( "Error Stream finished." ) ; }
va	5	public static void generarProgramasHTML ( Programa programa ) throws NegocioPaooException { if ( programa != null ) { if ( ! programa . getNombre ( ) . isEmpty ( ) ) { try { IPaginaDAO paginaDAO = Factory . getPaginaDAO ( ) ; if ( ! existeDirectorio ( programa . getNombre ( ) ) ) { crearDirectorio ( programa . getNombre ( ) ) ; } for ( Pagina pagina : programa . getPaginas ( ) ) { File f = crearArchivoHtml ( programa . getNombre ( ) , pagina . getBody ( ) , pagina . getNombre ( ) ) ; pagina . setLineas ( obtenerLineasArchivo ( f ) ) ; pagina . setPeso ( f . length ( ) ) ; paginaDAO . save ( pagina ) ; } } catch ( DatosPaooException ex ) { throw new NegocioPaooException ( ex . getMessage ( ) ) ; } } } else { throw new NegocioPaooException ( "No existe el programa que intenta convertir. Verifique y vuelta a intentar." ) ; } }
va	1	public Set < Suit > getAllUniqueSuits ( ) { Set < Suit > suitSet = new HashSet < Suit > ( ) ; for ( Card c : cards ) { suitSet . add ( c . suit ) ; } return suitSet ; }
va	4	protected boolean isCollision ( double x , double y ) { for ( int corner = 0 ; corner < 4 ; corner ++ ) { double xc = ( x - corner % 2 * 16 ) / 16 ; double yc = ( y - corner / 2 * 16 ) / 16 ; int xi = ( corner % 2 == 0 ) ? ( int ) Math . floor ( xc ) : ( int ) Math . ceil ( xc ) ; int yi = ( corner / 2 == 0 ) ? ( int ) Math . floor ( yc ) : ( int ) Math . ceil ( yc ) ; if ( Game . level . getTile ( xi , yi ) . isSolid ( ) ) { return true ; } } return false ; }
va	9	public List < class < ? >> getClassesFromLocation ( File location ) { final List < class < ? >> classes = new ArrayList < class < ? >> ( ) ; if ( location . isDirectory ( ) ) { for ( File file : Arrays . asList ( location . listFiles ( ) ) ) { try { ClassLoader classLoader = new URLClassLoader ( new URL [ ] { file . toURI ( ) . toURL ( ) } , this . getClass ( ) . getClassLoader ( ) ) ; if ( file . getName ( ) . toLowerCase ( ) . trim ( ) . endsWith ( ".class" ) ) { classes . add ( classLoader . loadClass ( file . getName ( ) . replace ( ".class" , "" ) . replace ( "/" , "." ) ) ) ; } else if ( file . getName ( ) . toLowerCase ( ) . trim ( ) . endsWith ( ".jar" ) ) { classes . addAll ( getClassesFromJar ( file , classLoader ) ) ; } else if ( file . isDirectory ( ) ) { classes . addAll ( getClassesFromLocation ( file ) ) ; } } catch ( MalformedURLException e ) { e . printStackTrace ( ) ; } catch ( ClassNotFoundException e ) { e . printStackTrace ( ) ; } } } else { try { ClassLoader classLoader = new URLClassLoader ( new URL [ ] { location . toURI ( ) . toURL ( ) } , this . getClass ( ) . getClassLoader ( ) ) ; if ( location . getName ( ) . toLowerCase ( ) . trim ( ) . endsWith ( ".class" ) ) { classes . add ( classLoader . loadClass ( location . getName ( ) . replace ( ".class" , "" ) . replace ( "/" , "." ) ) ) ; } if ( location . getName ( ) . toLowerCase ( ) . trim ( ) . endsWith ( ".jar" ) ) { classes . addAll ( getClassesFromJar ( location , classLoader ) ) ; } if ( location . isDirectory ( ) ) { classes . addAll ( getClassesFromLocation ( location ) ) ; } } catch ( MalformedURLException e ) { e . printStackTrace ( ) ; } catch ( ClassNotFoundException e ) { e . printStackTrace ( ) ; } } return classes ; }
va	9	private static int [ ] method371 ( int i ) { anIntArray1480 [ i ] = anInt1481 ++ ; if ( anIntArrayArray1479 [ i ] != null ) return anIntArrayArray1479 [ i ] ; int ai [ ] ; if ( anInt1477 > 0 ) { ai = anIntArrayArray1478 [ -- anInt1477 ] ; anIntArrayArray1478 [ anInt1477 ] = null ; } else { int j = 0 ; int k = - 1 ; for ( int l = 0 ; l < anInt1473 ; l ++ ) if ( anIntArrayArray1479 [ l ] != null && ( anIntArray1480 [ l ] < j || k == - 1 ) ) { j = anIntArray1480 [ l ] ; k = l ; } ai = anIntArrayArray1479 [ k ] ; anIntArrayArray1479 [ k ] = null ; } anIntArrayArray1479 [ i ] = ai ; Background background = aBackgroundArray1474s [ i ] ; int ai1 [ ] = anIntArrayArray1483 [ i ] ; if ( lowMem ) { aBooleanArray1475 [ i ] = false ; for ( int i1 = 0 ; i1 < 4096 ; i1 ++ ) { int i2 = ai [ i1 ] = ai1 [ background . aByteArray1450 [ i1 ] ] & f8f8ff ; if ( i2 == 0 ) aBooleanArray1475 [ i ] = true ; ai [ 4096 + i1 ] = i2 - ( i2 >>> 3 ) & f8f8ff ; ai [ 8192 + i1 ] = i2 - ( i2 >>> 2 ) & f8f8ff ; ai [ 12288 + i1 ] = i2 - ( i2 >>> 2 ) - ( i2 >>> 3 ) & f8f8ff ; } } else { if ( background . anInt1452 == 64 ) { for ( int j1 = 0 ; j1 < 128 ; j1 ++ ) { for ( int j2 = 0 ; j2 < 128 ; j2 ++ ) ai [ j2 + ( j1 << 7 ) ] = ai1 [ background . aByteArray1450 [ ( j2 >> 1 ) + ( ( j1 >> 1 ) << 6 ) ] ] ; } } else { for ( int k1 = 0 ; k1 < 16384 ; k1 ++ ) ai [ k1 ] = ai1 [ background . aByteArray1450 [ k1 ] ] ; } aBooleanArray1475 [ i ] = false ; for ( int l1 = 0 ; l1 < 16384 ; l1 ++ ) { ai [ l1 ] &= f8f8ff ; int k2 = ai [ l1 ] ; if ( k2 == 0 ) aBooleanArray1475 [ i ] = true ; ai [ 16384 + l1 ] = k2 - ( k2 >>> 3 ) & f8f8ff ; ai [ 32768 + l1 ] = k2 - ( k2 >>> 2 ) & f8f8ff ; ai [ 49152 + l1 ] = k2 - ( k2 >>> 2 ) - ( k2 >>> 3 ) & f8f8ff ; } } return ai ; }
va	3	public boolean tryScrollToReference ( String reference ) { Element dst = findElementToScroll ( reference , getDocument ( ) . getDefaultRootElement ( ) ) ; if ( dst != null ) { try { Rectangle bottom = new Rectangle ( 0 , getHeight ( ) - 1 , 1 , 1 ) ; Rectangle rec = modelToView ( dst . getStartOffset ( ) ) ; if ( rec != null ) { scrollRectToVisible ( bottom ) ; scrollRectToVisible ( rec ) ; } return true ; } catch ( BadLocationException e ) { UIManager . getLookAndFeel ( ) . provideErrorFeedback ( this ) ; return false ; } } else return false ; }
va	7	private void swap ( int [ ] tree , int m , int n ) { int tmp = tree [ m ] ; for ( int i = 0 ; i < tree . length ; i ++ ) { if ( i != m && i != n ) { tree [ i ] = tree [ i ] == m ? n : tree [ i ] == n ? m : tree [ i ] ; } } tree [ m ] = tree [ n ] != m ? tree [ n ] : n ; tree [ n ] = tmp != n ? tmp : m ; }
va	8	public boolean equals ( NamedEntity that ) { if ( that == null ) return false ; boolean this_present_nameEntity = true && this . isSetNameEntity ( ) ; boolean that_present_nameEntity = true && that . isSetNameEntity ( ) ; if ( this_present_nameEntity || that_present_nameEntity ) { if ( ! ( this_present_nameEntity && that_present_nameEntity ) ) return false ; if ( ! this . nameEntity . equals ( that . nameEntity ) ) return false ; } return true ; }
va	2	public String AdjList ( ) { String L = ( id + ")" ) ; Link l = link ; int counter = 0 ; while ( l != null ) { counter ++ ; L += " " + l . node . id ; l = l . next ; } if ( counter != degree ) { System . out . println ( "Whohaa  my degree and list no longer agree!" ) ; } return L ; }
va	2	public static void pairwiseAddInPlace ( double [ ] to , double [ ] from ) { if ( to . length != from . length ) { throw new RuntimeException ( ) ; } for ( int i = 0 ; i < to . length ; i ++ ) { to [ i ] = to [ i ] + from [ i ] ; } }
va	8	@ Override protected void put ( Message request , Message response ) { request . put ( Document . ID , request . get ( Profile . ID ) ) ; Message origProfile = new Message ( request . getContext ( ) ) ; new PersistentDocumentService ( ) . doGet ( request , origProfile ) ; Message updateReq = new Message ( request . getContext ( ) ) ; updateReq . putAllFields ( origProfile . getFields ( ) ) ; updateReq . putAllReferences ( origProfile . getReferences ( ) ) ; if ( request . containsField ( Profile . DESCRIPTION ) ) { updateReq . put ( Profile . DESCRIPTION , request . get ( Profile . DESCRIPTION ) ) ; } if ( request . containsField ( Profile . LOCATION ) ) { updateReq . put ( Profile . LOCATION , request . get ( Profile . LOCATION ) ) ; } if ( request . containsField ( Profile . IMAGE_KEY ) ) { updateReq . put ( Profile . IMAGE_KEY , request . get ( Profile . IMAGE_KEY ) ) ; } if ( request . containsField ( Profile . POINTS ) ) { int currentPoints = new Integer ( origProfile . get ( Profile . POINTS ) ) ; if ( ! request . get ( Profile . POINTS ) . equals ( "" ) ) { currentPoints += new Integer ( request . get ( Profile . POINTS ) ) ; updateReq . put ( Profile . POINTS , "" + currentPoints ) ; } } if ( request . containsField ( Profile . IMAGE_KEY ) ) { if ( ! request . get ( Profile . IMAGE_KEY ) . equals ( origProfile . get ( Profile . IMAGE_KEY ) ) ) { BlobstoreService blobstoreService = BlobstoreServiceFactory . getBlobstoreService ( ) ; try { blobstoreService . delete ( new BlobKey ( origProfile . get ( Profile . IMAGE_KEY ) ) ) ; } catch ( Exception e ) { } } } new PersistentDocumentService ( ) . doPut ( updateReq , response ) ; }
va	3	private ArrayList < Integer > getIncidenciesIds ( String label ) { ArrayList < Integer > aux = new ArrayList < Integer > ( ) ; String SQL1 = "SELECT id FROM " + sgdDB + ".tipoincidencias WHERE simbolo='" + label + "'" ; try { Statement st = client . getSgd ( ) . createStatement ( ) ; ResultSet rs1 = client . getSgd ( ) . getResultSet ( SQL1 , st ) ; while ( rs1 . next ( ) ) { aux . add ( rs1 . getInt ( "id" ) ) ; } if ( rs1 != null ) { rs1 . close ( ) ; st . close ( ) ; } } catch ( SQLException ex ) { Logger . getLogger ( SGDImporter . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } return aux ; }
va	8	private void addProperty ( final String strPropertyName , final StringBuilder sbPropertyValue ) { if ( strPropertyName != null && sbPropertyValue != null ) { while ( true ) { int iLen = sbPropertyValue . length ( ) ; if ( iLen > 0 ) { final char ch = sbPropertyValue . charAt ( iLen - 1 ) ; if ( ch == '' || ch == '' || ch == 	 ) { sbPropertyValue . setLength ( -- iLen ) ; } else { break ; } } else { break ; } } if ( sbPropertyValue . length ( ) > 0 ) { put ( strPropertyName , sbPropertyValue . toString ( ) ) ; } } }
va	8	public double getMax ( ) { if ( type == 0 ) { for ( int i = 0 ; i < valueCount && i < values . length ; i ++ ) { if ( values [ i ] > max ) { max = values [ i ] ; } } if ( lable != null ) { lable . setMax ( max ) ; } return max ; } if ( type == 1 ) { for ( int i = 0 ; i < graphValues . length ; i ++ ) { if ( graphValues [ i ] . getMax ( ) > max ) { max = graphValues [ i ] . getMax ( ) ; } } return max ; } return max ; }
va	5	private static char [ ] compression ( String str ) { char [ ] arr = str . toCharArray ( ) ; int current = 0 , insert = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( arr [ current ] ==   ) { current ++ ; } else { if ( insert < current ) { arr [ insert ] = arr [ current ] ; } current ++ ; insert ++ ; } } arr [ insert ] =  ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i ] ==  ) { break ; } } String ans = new String ( arr ) ; System . out . println ( ans . charAt ( insert ) ) ; return arr ; }
va	7	public void update ( Input input ) { if ( ! input . oldButtons [ Input . ESCAPE ] && input . buttons [ Input . ESCAPE ] ) { setScreen ( parent ) ; return ; } if ( delay > 0 ) delay -- ; if ( delay == 0 && input . buttons [ Input . ACTION ] && ! input . oldButtons [ Input . ACTION ] ) { input . releaseAllKeys ( ) ; if ( e . special ) { e . level . specials ( e . xSpot , e . ySpot , e ) ; } else { setScreen ( parent ) ; } } }
va	8	public void write ( Kml kml ) throws KmlException { if ( coordinates == null || coordinates . size ( ) < 2 ) { throw new KmlException ( "LineString must contain at least 2 points" ) ; } kml . println ( "<LineString" + getIdAndTargetIdFormatted ( kml ) + ">" , 1 ) ; if ( extrude != null ) { kml . println ( "<extrude>" + booleanToInt ( extrude ) + "</extrude>" ) ; } if ( tessellate != null ) { kml . println ( "<tessellate>" + booleanToInt ( tessellate ) + "</tessellate>" ) ; } if ( altitudeMode != null ) { kml . println ( "<altitudeMode>" + altitudeMode + "</altitudeMode>" ) ; } if ( coordinates != null ) { kml . print ( "<coordinates>" ) ; boolean firstLoop = true ; for ( Point point : coordinates ) { if ( firstLoop ) { firstLoop = false ; } else { kml . printNoIndent ( " " ) ; } kml . printNoIndent ( point . getLongitudeLatitudeAltitudeString ( ) ) ; } kml . println ( "</coordinates>" ) ; } kml . println ( - 1 , "</LineString>" ) ; }
va	8	public void boxClick ( String name ) { if ( name . equals ( "zoomOut" ) ) { parent . zoom ( 1.1 ) ; } else if ( name . equals ( "zoomIn" ) ) { parent . zoom ( 0.9 ) ; } else if ( name . equals ( "left" ) ) { parent . translate ( - 7.0 , 0.0 ) ; } else if ( name . equals ( "right" ) ) { parent . translate ( 7.0 , 0.0 ) ; } else if ( name . equals ( "up" ) ) { parent . translate ( 0.0 , 7.0 ) ; } else if ( name . equals ( "down" ) ) { parent . translate ( 0.0 , - 7.0 ) ; } else if ( name . equals ( "zoomBox" ) ) { parent . setZoomBoxMode ( ) ; } else if ( name . equals ( "zoomReset" ) ) { parent . defaultWindow ( ) ; } }
va	7	public void keyReleased ( KeyEvent e ) { if ( this . PFPanel . getSelectedIndex ( ) == 2 && ( ( e . getKeyChar ( ) >= 65 && e . getKeyChar ( ) <= 90 ) || ( e . getKeyChar ( ) >= 97 && e . getKeyChar ( ) <= 122 ) || ( ! medhTF [ 0 ] . getText ( ) . isEmpty ( ) && ( e . getKeyCode ( ) == KeyEvent . VK_BACK_SPACE ) ) ) ) { function . patientList ( patient , medhTF [ 0 ] , listMode ) ; } }
va	4	private TabuleiroXadrez estadoAndar ( Jogada jogada , TipoCorJogador corJogador , TabuleiroXadrez copiaTabuleiro ) throws CasaOcupadaException { Peca peca = copiaTabuleiro . espiarPeca ( jogada . getOrigem ( ) ) ; TabuleiroXadrez tabuleiroNovo = copiaTabuleiro . tabuleiroClonado ( ) ; tabuleiroNovo . retirarPeca ( jogada . getOrigem ( ) ) ; if ( jogada . ehPromocao ( ) ) { Peca rainha = new Rainha ( corJogador ) ; rainha . setJaMoveu ( ) ; tabuleiroNovo . colocarPeca ( jogada . getDestino ( ) , rainha ) ; } else if ( peca . getTipoPeca ( ) == TipoPeca . PEAO && peca . medeDeslocamentoPeca ( jogada . getOrigem ( ) . getLinha ( ) , jogada . getDestino ( ) . getLinha ( ) ) == 2 ) { Peao peaoVitima = ( Peao ) peca . clone ( ) ; peaoVitima . setPodeEnPassant ( true ) ; peaoVitima . setJaMoveu ( ) ; tabuleiroNovo . colocarPeca ( jogada . getDestino ( ) , peaoVitima ) ; } else { if ( peca . getJaMoveu ( ) == true ) tabuleiroNovo . colocarPeca ( jogada . getDestino ( ) , peca ) ; else { Peca novaPeca = peca . clone ( ) ; novaPeca . setJaMoveu ( ) ; tabuleiroNovo . colocarPeca ( jogada . getDestino ( ) , novaPeca ) ; } } return tabuleiroNovo ; }
va	3	@ Override public boolean equals ( Object o ) { if ( o == null ) return false ; if ( ! ( o instanceof Course ) ) return false ; Course c = ( Course ) o ; return c . velocityX == velocityX && c . velocityY == velocityY ; }
va	8	public static void unzipFolder ( File zipFile , File destFolder ) { try { BufferedOutputStream dest = null ; FileInputStream fis = new FileInputStream ( zipFile ) ; ZipInputStream zis = new ZipInputStream ( new BufferedInputStream ( fis ) ) ; ZipEntry entry ; while ( ( entry = zis . getNextEntry ( ) ) != null ) { System . out . println ( "Extracting: " + entry ) ; byte [ ] data = new byte [ 2048 ] ; File f = new File ( destFolder + File . separator + entry . getName ( ) ) ; if ( ( f . getParentFile ( ) != null ) && ( ! f . getParentFile ( ) . exists ( ) ) ) { f . getParentFile ( ) . mkdirs ( ) ; } boolean isDir = entry . isDirectory ( ) ; if ( ! f . exists ( ) ) { if ( isDir ) { f . mkdirs ( ) ; } else { DebugUtils . info ( "f: " + f . toString ( ) ) ; f . createNewFile ( ) ; f . getParent ( ) ; } } if ( ! isDir ) { FileOutputStream fos = new FileOutputStream ( f ) ; dest = new BufferedOutputStream ( fos , 2048 ) ; int count ; while ( ( count = zis . read ( data , 0 , 2048 ) ) != - 1 ) { dest . write ( data , 0 , count ) ; } dest . flush ( ) ; dest . close ( ) ; } } zis . close ( ) ; } catch ( Exception e ) { DebugUtils . error ( e . getMessage ( ) ) ; e . printStackTrace ( ) ; } }
va	2	private void crearLista ( int [ ] datos , boolean ordenado ) { for ( int i : datos ) { if ( ordenado ) this . insertarOrdenado ( i ) ; else this . insertarInicio ( i ) ; } }
va	9	public void handleUpdateUserInfo ( Packet10UpdateUserInfo packet , InetAddress address , int port ) { Player player = null ; if ( packet . getRace ( ) . equalsIgnoreCase ( "human" ) ) player = new Human ( game , packet . getName ( ) , address , port ) ; else if ( packet . getRace ( ) . equalsIgnoreCase ( "cyborg" ) && packet . getColor ( ) . equalsIgnoreCase ( " " ) ) player = new Cyborg ( game , packet . getName ( ) , - 1 , address , port ) ; else if ( packet . getRace ( ) . equalsIgnoreCase ( "cyborg" ) && ! packet . getColor ( ) . equalsIgnoreCase ( " " ) ) player = new Cyborg ( game , packet . getColor ( ) , packet . getName ( ) , address , port ) ; else player = new Human ( game , packet . getName ( ) , address , port ) ; Weapon melee = null ; if ( packet . getMeleeWeapon ( ) . equalsIgnoreCase ( "sword" ) ) { melee = new Sword ( player ) ; player . setMelee ( melee ) ; } else { melee = new Sword ( player ) ; player . setMelee ( melee ) ; } player . setInHand ( melee ) ; if ( packet . getRangedWeapon ( ) . equalsIgnoreCase ( "bow" ) ) player . setRanged ( new Bow ( player ) ) ; else player . setRanged ( new Bow ( player ) ) ; for ( int i = 0 ; i < game . getPlayers ( ) . size ( ) ; i ++ ) if ( game . getPlayers ( ) . get ( i ) . getName ( ) . equalsIgnoreCase ( player . getName ( ) ) ) game . getPlayers ( ) . set ( i , player ) ; }
va	9	public FTPFile ( String file ) { boolean filenameHasSpace = false ; String after = file . replaceAll ( " +" , " " ) ; String [ ] part = after . split ( " " ) ; if ( part . length > 9 ) { filenameHasSpace = true ; } if ( part [ 0 ] . contains ( "d" ) ) isDirectory = true ; for ( int i = 1 ; i < part [ 0 ] . length ( ) ; i ++ ) { if ( String . valueOf ( part [ 0 ] . charAt ( i ) ) . equals ( "r" ) ) { if ( i < 4 ) userRights += 4 ; else if ( i < 7 ) groupRights += 4 ; else othersRights += 4 ; } if ( String . valueOf ( part [ 0 ] . charAt ( i ) ) . equals ( "w" ) ) { if ( i < 4 ) userRights += 2 ; else if ( i < 7 ) groupRights += 2 ; else othersRights += 2 ; } if ( String . valueOf ( part [ 0 ] . charAt ( i ) ) . equals ( "x" ) ) { if ( i < 4 ) userRights += 1 ; else if ( i < 7 ) groupRights += 1 ; else othersRights += 1 ; } } rights = part [ 0 ] ; owner = part [ 2 ] ; group = part [ 3 ] ; size = Integer . parseInt ( part [ 4 ] ) ; date = part [ 5 ] + " " + part [ 6 ] + " " + part [ 7 ] ; if ( filenameHasSpace ) { int indexOfBeginOfFilename = file . indexOf ( part [ 8 ] ) ; filename = file . substring ( indexOfBeginOfFilename ) ; } else filename = part [ 8 ] ; }
va	4	protected boolean in_grouping_b ( char [ ] s , int min , int max ) { if ( cursor <= limit_backward ) return false ; char ch = current . charAt ( cursor - 1 ) ; if ( ch > max || ch < min ) return false ; ch -= min ; if ( ( s [ ch >> 3 ] & ( 1 << ( ch & 7 ) ) ) == 0 ) return false ; cursor -- ; return true ; }
va	4	private void updateConfig ( ButtonEvent event ) { for ( OptionsField field : gui . getOptionsMenu ( ) . getOptionFields ( ) ) switch ( field . getOption ( ) ) { case HOSTNAME : setHostname ( field . submit ( ) ) ; break ; case PORT : setPort ( field . submit ( ) ) ; break ; case NICKNAME : setNick ( field . submit ( ) ) ; break ; } }
va	9	private static void populateReport ( Workbook workbook , List objects , Report report ) { DataFormat df = workbook . createDataFormat ( ) ; CellStyle dateCellStyle = workbook . createCellStyle ( ) ; dateCellStyle . setDataFormat ( df . getFormat ( "d-MMM-yy" ) ) ; CellStyle bodyCellStyle = workbook . createCellStyle ( ) ; bodyCellStyle . setAlignment ( CellStyle . ALIGN_CENTER ) ; bodyCellStyle . setWrapText ( true ) ; List < Report . ReportSheet > sheetList = report . getSheets ( ) ; int [ ] sheetCountList = new int [ report . getSheets ( ) . size ( ) ] ; for ( int m = 0 ; m < sheetCountList . length ; m ++ ) { sheetCountList [ m ] = 3 ; } String classType = report . getClassType ( ) ; class reportBaseClass = Util . loadClass ( classType ) ; if ( reportBaseClass == null ) { return ; } for ( int i = 0 ; i < objects . size ( ) ; i ++ ) { Object form = objects . get ( i ) ; if ( ! form . getClass ( ) . equals ( reportBaseClass ) ) { return ; } for ( int k = 0 ; k < sheetList . size ( ) ; k ++ ) { int sheetCounter = sheetCountList [ k ] ; Report . ReportSheet sheet = sheetList . get ( k ) ; List < String > fieldPaths = sheet . getFieldPaths ( ) ; if ( ! Util . nullOrEmptyOrBlank ( sheet . getBaseFieldPath ( ) ) ) { Object sheetForm = Util . getDottedFieldValue ( sheet . getBaseFieldPath ( ) , form ) ; if ( sheetForm instanceof Collection ) { Collection collection = ( Collection ) sheetForm ; Iterator itr = collection . iterator ( ) ; while ( itr . hasNext ( ) ) { Object sheetObj = itr . next ( ) ; populateSheet ( workbook , dateCellStyle , bodyCellStyle , sheetCounter , sheetObj , sheet , sheet . getFieldPaths ( ) ) ; sheetCounter ++ ; } } else { String sheetClassType = sheet . getClassType ( ) ; if ( ! Util . nullOrEmptyOrBlank ( sheetClassType ) && ! form . getClass ( ) . getName ( ) . equals ( sheetClassType ) ) { return ; } populateSheet ( workbook , dateCellStyle , bodyCellStyle , sheetCounter , sheetForm , sheet , sheet . getFieldPaths ( ) ) ; sheetCounter ++ ; } } else { populateSheet ( workbook , dateCellStyle , bodyCellStyle , sheetCounter , form , sheet , fieldPaths ) ; sheetCounter ++ ; } sheetCountList [ k ] = sheetCounter ; } } }
va	6	public MsgStatus [ ] findByDynamicWhere ( String sql , Object [ ] sqlParams ) throws MsgStatusDaoException { final boolean isConnSupplied = ( userConn != null ) ; Connection conn = null ; PreparedStatement stmt = null ; ResultSet rs = null ; try { conn = isConnSupplied ? userConn : ResourceManager . getConnection ( ) ; final String SQL = SQL_SELECT + " WHERE " + sql ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Executing " + SQL ) ; } stmt = conn . prepareStatement ( SQL ) ; stmt . setMaxRows ( maxRows ) ; for ( int i = 0 ; sqlParams != null && i < sqlParams . length ; i ++ ) { stmt . setObject ( i + 1 , sqlParams [ i ] ) ; } rs = stmt . executeQuery ( ) ; return fetchMultiResults ( rs ) ; } catch ( Exception _e ) { logger . error ( "Exception: " + _e . getMessage ( ) , _e ) ; throw new MsgStatusDaoException ( "Exception: " + _e . getMessage ( ) , _e ) ; } finally { ResourceManager . close ( rs ) ; ResourceManager . close ( stmt ) ; if ( ! isConnSupplied ) { ResourceManager . close ( conn ) ; } } }
va	2	private void auditarMovieEstado ( int pos ) { if ( pos < items . size ( ) ) { BlockBusterItem bi = items . get ( pos ) ; if ( bi instanceof MovieItem ) ( ( MovieItem ) bi ) . evaluarEstado ( ) ; auditarMovieEstado ( pos + 1 ) ; } }
va	3	private void printVehicleStats ( final Vehicle vehicle , final PrintStream out ) { if ( showStages ) { for ( final Stage stage : vehicle . getStagesFromTop ( ) ) { final int stageNumber = stage . getNumber ( ) ; out . println ( ) ; out . println ( "Stage " + stageNumber + ":" ) ; printStageStats ( out , stage ) ; } } else { out . println ( "Bottom stage:" ) ; printStageStats ( out , vehicle . getStagesFromBottom ( ) . get ( 0 ) ) ; } out . println ( ) ; double totalDeltaV = 0 ; for ( final Stage stage : vehicle . getStagesFromTop ( ) ) { totalDeltaV += stage . getDeltaV ( ) ; } out . printf ( "Total delta V = %.1f m/s%n" , totalDeltaV ) ; }
va	7	public Object getFieldValue ( _Fields field ) { switch ( field ) { case HEAD_ITEM : return get_head_item ( ) ; case ITEMS : return long . valueOf ( get_items ( ) ) ; case BYTES : return long . valueOf ( get_bytes ( ) ) ; case JOURNAL_BYTES : return long . valueOf ( get_journal_bytes ( ) ) ; case AGE : return long . valueOf ( get_age ( ) ) ; case WAITERS : return Integer . valueOf ( get_waiters ( ) ) ; case OPEN_TRANSACTIONS : return Integer . valueOf ( get_open_transactions ( ) ) ; } throw new IllegalStateException ( ) ; }
va	6	public Tree parseVariable ( final int flags ) { boolean modifiable ; boolean forced = false ; if ( poll ( kVar ) ) { modifiable = true ; } else if ( poll ( kVal ) ) { modifiable = false ; } else { return syntaxError ( InvalidSyntaxReport . kExpectVariable ) ; } final Name name = parseName ( ) ; Optional < Tree > type = Optional . empty ( ) ; if ( poll ( kColon ) ) { type = Optional . of ( parseType ( ) ) ; } Optional < Tree > init = Optional . empty ( ) ; if ( poll ( kAssign ) ) { forced = poll ( kForce ) ; init = Optional . of ( parseExpression ( ) ) ; } return init ( new Variable ( name , type , init ) ) . withFlags ( flags | ( modifiable ? 0 : Tree . ACC_IMMUTABLE ) | ( forced ? Tree . ACC_FORCE : 0 ) ) ; }
va	9	public static Object [ ] findGoalRoute ( Level l , Agent agent , Box box , Field agentFromField , Field agentToField , Field boxFromField , Field boxToField , HashMap < Field , ArrayList < Object >> conflictingHashMap ) { dir boxDir = null ; if ( agentFromField == null || agentToField == null || boxFromField == null || boxToField == null ) { System . err . println ( "Null argument in pathfinding" ) ; return null ; } GoalSequenceNode root = new GoalSequenceNode ( boxFromField , agentFromField , null ) ; LinkedList < GoalSequenceNode > queue = new LinkedList < GoalSequenceNode > ( ) ; HashMap < Field , ArrayList < Field >> closedSet = new HashMap < Field , ArrayList < Field >> ( ) ; ArrayList < Field > tempList = new ArrayList < Field > ( ) ; tempList . add ( boxFromField ) ; closedSet . put ( agentFromField , tempList ) ; queue . add ( root ) ; GoalSequenceNode currentNode = queue . poll ( ) ; while ( currentNode != null && ( currentNode . boxLocation != boxToField || currentNode . agentLocation != agentToField ) ) { boxDir = Agent . getBoxDirection ( currentNode . agentLocation , currentNode . boxLocation ) ; ArrayList < Command > foundCommands = addPossibleBoxCommandsForDirection ( boxDir , currentNode . agentLocation , currentNode . boxLocation , l , conflictingHashMap ) ; for ( Command command : foundCommands ) { Field boxLocation = null ; Field agentLocation = null ; if ( command . cmd . equals ( "Push" ) ) { agentLocation = currentNode . boxLocation ; boxLocation = currentNode . boxLocation . neighbors [ command . dir2 . ordinal ( ) ] ; } else { boxLocation = currentNode . agentLocation ; agentLocation = currentNode . agentLocation . neighbors [ command . dir1 . ordinal ( ) ] ; } if ( closedSet . containsKey ( agentLocation ) ) { if ( closedSet . get ( agentLocation ) . contains ( boxLocation ) ) { continue ; } else { closedSet . get ( agentLocation ) . add ( boxLocation ) ; } } else { ArrayList < Field > tempListe = new ArrayList < Field > ( ) ; tempListe . add ( boxLocation ) ; closedSet . put ( agentLocation , tempListe ) ; } GoalSequenceNode node = new GoalSequenceNode ( boxLocation , agentLocation , command ) ; node . parent = currentNode ; queue . add ( node ) ; } if ( queue . isEmpty ( ) ) { System . err . println ( "Returning null goalRoute" ) ; Object [ ] returnObjects = new Object [ 2 ] ; returnObjects [ 0 ] = null ; returnObjects [ 1 ] = null ; return returnObjects ; } currentNode = queue . poll ( ) ; } LinkedList < Command > commands = new LinkedList < Command > ( ) ; ArrayList < Field > usedFields = new ArrayList < Field > ( ) ; while ( currentNode . parent != null ) { commands . addFirst ( currentNode . action ) ; usedFields . add ( 0 , currentNode . agentLocation ) ; usedFields . add ( 0 , currentNode . boxLocation ) ; currentNode = currentNode . parent ; } Object [ ] returnObjects = new Object [ 2 ] ; returnObjects [ 0 ] = commands ; returnObjects [ 1 ] = usedFields ; return returnObjects ; }
va	4	private static int getuid ( String s ) { try { File file = new File ( s + "uid.dat" ) ; if ( ! file . exists ( ) || file . length ( ) < 4 ) { DataOutputStream dataoutputstream = new DataOutputStream ( new FileOutputStream ( s + "uid.dat" ) ) ; dataoutputstream . writeInt ( ( int ) ( Math . random ( ) * 99999999D ) ) ; dataoutputstream . close ( ) ; } } catch ( Exception _ex ) { } try { DataInputStream datainputstream = new DataInputStream ( new FileInputStream ( s + "uid.dat" ) ) ; int i = datainputstream . readInt ( ) ; datainputstream . close ( ) ; return i + 1 ; } catch ( Exception _ex ) { return 0 ; } }
va	9	@ Override public boolean removeAll ( Collection < ? > other ) { if ( other . size ( ) == 0 || this . size == 0 ) return false ; int initialMySize = this . size ; int initialOtherSize = other . size ( ) ; Container < T > thisOld = this . head ; Container < T > thisCurrent = this . head . next ; Iterator < ? > otherIt = other . iterator ( ) ; Object otherEl = otherIt . next ( ) ; int removed = 0 ; while ( true ) { int result = this . compare ( thisCurrent . el , otherEl ) ; if ( result == 0 ) { thisCurrent = thisCurrent . next ; thisOld . next = thisCurrent ; this . size -- ; removed ++ ; if ( thisCurrent == null ) { this . tail = thisOld ; break ; } if ( otherIt . hasNext ( ) ) { otherEl = otherIt . next ( ) ; } else { break ; } } else if ( result > 0 ) { if ( otherIt . hasNext ( ) ) { otherEl = otherIt . next ( ) ; } else { break ; } } else { if ( thisCurrent . next != null ) { thisOld = thisCurrent ; thisCurrent = thisCurrent . next ; } else { break ; } } } assert ( this . size + removed == initialMySize ) ; assert ( other . size ( ) == initialOtherSize ) ; assert ( this . size != 0 || this . head . next == null ) ; assert ( this . tail . next == null ) ; return removed > 0 ; }
va	6	public static OfficeObject getOfficeObject ( Integer objectId ) { OfficeObject result = null ; ResultSet rs = null ; PreparedStatement ps = null ; try { con = ConnectionManager . getConnection ( ) ; if ( con == null ) { return null ; } String sql = "SELECT id  name  office_object_type_id FROM office_object WHERE id = " . concat ( objectId . toString ( ) ) ; ps = con . prepareStatement ( sql ) ; rs = ps . executeQuery ( ) ; if ( rs . next ( ) ) { result = OfficeObject . loadOfficeObject ( rs . getInt ( 1 ) , rs . getString ( 2 ) , rs . getInt ( 3 ) ) ; } con . close ( ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; logger . error ( "SQL query execution errors. Error: " + e . getSQLState ( ) + " | " + e . getErrorCode ( ) ) ; } finally { try { if ( ps != null ) ps . close ( ) ; if ( rs != null ) rs . close ( ) ; } catch ( Exception e ) { logger . warn ( "Connection was closed with errors." ) ; } } return result ; }
va	7	static int [ ] bellmanFord ( MatrixGraph g , int s ) { int [ ] dists = new int [ g . n ] ; Arrays . fill ( dists , INF ) ; dists [ s ] = 0 ; for ( int i = 0 ; i < g . n ; i ++ ) { for ( int u = 0 ; u < g . n ; u ++ ) { for ( int v = 0 ; v < g . n ; v ++ ) { Edge e = g . edges [ u ] [ v ] ; if ( e != null && dists [ u ] != INF && dists [ v ] > dists [ u ] + e . cost ) { dists [ v ] = dists [ u ] + e . cost ; if ( i == g . n - 1 ) throw new IllegalPathStateException ( "negative loop exists" ) ; } } } } return dists ; }
va	2	public static boolean isTomorrow ( Date when ) { ShortDate today = ShortDate . newForToday ( ) ; ShortDate scheduled = ShortDate . newDateFor ( when ) ; return today . year == scheduled . year && today . month == scheduled . month && today . day + 1 == scheduled . day ; }
va	5	public void eot ( ) { if ( getReadyState ( ) == READYSTATE . NOT_YET_CONNECTED ) { closeConnection ( CloseFrame . NEVER_CONNECTED , true ) ; } else if ( flushandclosestate ) { closeConnection ( closecode , closemessage , closedremotely ) ; } else if ( draft . getCloseHandshakeType ( ) == CloseHandshakeType . NONE ) { closeConnection ( CloseFrame . NORMAL , true ) ; } else if ( draft . getCloseHandshakeType ( ) == CloseHandshakeType . ONEWAY ) { if ( role == Role . SERVER ) closeConnection ( CloseFrame . ABNORMAL_CLOSE , true ) ; else closeConnection ( CloseFrame . NORMAL , true ) ; } else { closeConnection ( CloseFrame . ABNORMAL_CLOSE , true ) ; } }
va	7	private void closeRequest ( OnDemandData onDemandData ) { try { if ( socket == null ) { long l = System . currentTimeMillis ( ) ; if ( l - openSocketTime < 4000 ) return ; openSocketTime = l ; socket = clientInstance . openSocket ( 43594 + client . portOff ) ; inputStream = socket . getInputStream ( ) ; outputStream = socket . getOutputStream ( ) ; outputStream . write ( 15 ) ; for ( int j = 0 ; j < 8 ; j ++ ) inputStream . read ( ) ; loopCycle = 0 ; } ioBuffer [ 0 ] = ( byte ) onDemandData . dataType ; ioBuffer [ 1 ] = ( byte ) ( onDemandData . ID >> 8 ) ; ioBuffer [ 2 ] = ( byte ) onDemandData . ID ; if ( onDemandData . incomplete ) ioBuffer [ 3 ] = 2 ; else if ( ! clientInstance . loggedIn ) ioBuffer [ 3 ] = 1 ; else ioBuffer [ 3 ] = 0 ; outputStream . write ( ioBuffer , 0 , 4 ) ; writeLoopCycle = 0 ; anInt1349 = - 10000 ; return ; } catch ( IOException ioexception ) { } try { socket . close ( ) ; } catch ( Exception _ex ) { } socket = null ; inputStream = null ; outputStream = null ; expectedSize = 0 ; anInt1349 ++ ; }
va	7	@ Override protected void setHasTimeLeft ( boolean hasTimeLeft ) { if ( hasTimeLeft ) { int x = maze . getPlayer ( ) . getX ( ) / Map . SQUARE_SIZE ; int y = maze . getPlayer ( ) . getY ( ) / Map . SQUARE_SIZE ; for ( int i = 0 ; i < maze . getMap ( ) . doors . size ( ) ; i ++ ) { Door d = maze . getMap ( ) . doors . get ( i ) ; if ( d . isClosed ( ) ) { if ( ( d . getGridX ( ) == x || d . getGridX ( ) == x - 1 ) && ( d . getGridY ( ) == y || d . getGridY ( ) == y - 1 ) ) { d . setClosed ( false ) ; return ; } } } incrementQuantity ( ) ; } }
va	5	protected void normalizeVertices ( ) { List < float [ ] > normalizedVertices = new ArrayList < float [ ] > ( ) ; float max = float . MIN_VALUE ; for ( float [ ] vertice : vertices ) { if ( Math . abs ( vertice [ 0 ] ) > max ) { max = vertice [ 0 ] ; } if ( Math . abs ( vertice [ 1 ] ) > max ) { max = vertice [ 1 ] ; } if ( Math . abs ( vertice [ 2 ] ) > max ) { max = vertice [ 2 ] ; } } for ( float [ ] vertice : vertices ) { vertice [ 0 ] /= max ; vertice [ 1 ] /= max ; vertice [ 2 ] /= max ; normalizedVertices . add ( vertice ) ; } vertices . clear ( ) ; vertices . addAll ( normalizedVertices ) ; }
va	8	public static PostingsList andMerge ( PostingsList posting1 , PostingsList posting2 ) { PostingsList merged = new PostingsList ( ) ; if ( posting1 != null && posting2 != null && posting1 . size ( ) > 0 && posting2 . size ( ) > 0 ) { Node p1 = posting1 . head ; Node p2 = posting2 . head ; while ( p1 != null && p2 != null ) { if ( p1 . docID ( ) == p2 . docID ( ) ) { merged . addDoc ( p1 . docID ( ) ) ; p1 = p1 . next ( ) ; p2 = p2 . next ( ) ; } else if ( p1 . docID ( ) < p2 . docID ( ) ) { p1 = p1 . next ( ) ; } else { p2 = p2 . next ( ) ; } } } return merged ; }
va	7	@ Override public synchronized void receive ( MulticastReceiveEvent event ) { SLCP receiver = new SLCP ( SLCP . VERSION_V1 ) ; try { final AbstractChatResponse resp = receiver . parse ( event . getData ( ) ) ; if ( resp instanceof ChatMessage ) { ChatMessage chatMessage = ( ChatMessage ) resp ; chatMessage . getChatMessage ( ) . setMessage ( SmileyUtil . parseSmileysInString ( chatMessage . getChatMessage ( ) . getMessage ( ) ) ) ; model . addEntry ( chatMessage ) ; view . getTray ( ) . setIncomingTrayIcon ( ) ; if ( ! view . getMainframe ( ) . isActive ( ) ) view . getMainframe ( ) . setIncomingAppIcon ( ) ; if ( ! model . isMute ( ) ) { view . getTray ( ) . showTrayMessageDialog ( "incoming message" , model . getLastEntry ( ) . getChatMessage ( ) . getMessage ( ) ) ; playSound ( getClass ( ) . getResource ( PropertiesUtil . getLanchatPropertyString ( "SOUND_INCOMING" ) ) ) ; } } if ( resp instanceof ChatPing ) { model . addUserListEntry ( resp . getID ( ) , resp . getChatName ( ) ) ; model . setPingChange ( true ) ; } } catch ( ParseException ex ) { JLoggerUtil . getLogger ( ) . warn ( "ParseException in receive. Invalid input detected  continue receiving." ) ; } catch ( IllegalAccessException e ) { JLoggerUtil . getLogger ( ) . warn ( "IllegalAccessException in receive. Tray not supported." ) ; } catch ( NullPointerException ex ) { JLoggerUtil . getLogger ( ) . warn ( "NullPointerException in receive. Empty message detected  continue receiving." ) ; } }
va	3	private void calculateHighestBid ( ) { for ( JavaFestivalPlayer player : players ) { if ( player . checkIfInFestival ( ) ) { if ( highestBid < player . getFestivalBid ( ) ) { highestBid = player . getFestivalBid ( ) ; } } } }
va	9	@ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; Bus other = ( Bus ) obj ; if ( id == null ) { if ( other . id != null ) return false ; } else if ( ! id . equals ( other . id ) ) return false ; if ( plate == null ) { if ( other . plate != null ) return false ; } else if ( ! plate . equals ( other . plate ) ) return false ; return true ; }
va	8	public double [ ] getMinMax ( ) { double min = double . MAX_VALUE ; double max = - double . MAX_VALUE ; if ( multiTrace ) { for ( int i = 0 ; i < multiColumnData . length ; i ++ ) { ArrayList < double > l = ( ArrayList < double > ) multiColumnData [ i ] ; for ( double d : l ) { min = min < d ? min : d ; max = max > d ? max : d ; } } } else { for ( double d : columnData ) { min = min < d ? min : d ; max = max > d ? max : d ; } } return new double [ ] { min , max } ; }
va	4	public String patientCheckSearch ( String searchText ) { String patientId = "" ; String patientName = "" ; String checkStatus = "" ; String str = "select  w.patient_id p.patient_name w.check_status from patient p ward w  where p.patient_id=w.patient_id and  p.patient_name like '%" + searchText + "%';" ; System . out . println ( str ) ; try { conn = dbConn . getConn ( ) ; pstmt = conn . prepareStatement ( str ) ; ResultSet num = pstmt . executeQuery ( ) ; while ( num . next ( ) ) { patientId = num . getString ( "patient_id" ) ; patientName = num . getString ( "patient_name" ) ; checkStatus = num . getString ( "check_status" ) ; sb . append ( "<tr> <td><a href=\"bodycheckdetial.jsp?patientId=" + patientId + "\">" + patientId + "</a></td> <td>" + patientName + "</td>" ) ; if ( checkStatus . equals ( "1" ) ) { sb . append ( " <td>\u672A\u68C0\u67E5</td>  </tr> " ) ; } else if ( checkStatus . equals ( "2" ) ) { sb . append ( " <td>\u5DF2\u68C0\u67E5</td>  </tr> " ) ; } } pstmt . close ( ) ; dbConn . close ( conn ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; } return sb . toString ( ) ; }
va	4	public boolean checkIfGameOver ( final boolean [ ] [ ] activityMock , final boolean [ ] [ ] visibilityMock ) { for ( int xCurrent = 0 ; xCurrent < boardSize ; xCurrent ++ ) for ( int yCurrent = 0 ; yCurrent < boardSize ; yCurrent ++ ) { if ( activityMock [ xCurrent ] [ yCurrent ] . equals ( true ) && ( visibilityMock [ xCurrent ] [ yCurrent ] . equals ( true ) ) ) { return false ; } } view . sendBoardEvent ( new GameOverEvent ( ) ) ; return true ; }
va	7	@ Override public boolean equals ( Object other ) { if ( other == this ) return true ; if ( other instanceof PDUHeader ) { PDUHeader asPDUHeader = ( PDUHeader ) other ; if ( asPDUHeader . protocolVersion == this . protocolVersion && asPDUHeader . exerciseIdentifier == this . exerciseIdentifier && asPDUHeader . pduType == this . pduType && asPDUHeader . protocolFamily == this . protocolFamily && asPDUHeader . timestamp == this . timestamp ) { return true ; } } return false ; }
va	5	public static void sort ( String [ ] a , int w ) { int R = 256 ; int N = a . length ; String [ ] aux = new String [ N ] ; for ( int i = w - 1 ; i >= 0 ; i -- ) { int [ ] count = new int [ R + 1 ] ; for ( int j = 0 ; j < N ; j ++ ) { count [ a [ j ] . charAt ( i ) + 1 ] ++ ; } for ( int k = 0 ; k < R ; k ++ ) { count [ k + 1 ] += count [ k ] ; } for ( int l = 0 ; l < N ; l ++ ) { aux [ count [ a [ l ] . charAt ( i ) ] ++ ] = a [ l ] ; } for ( int m = 0 ; m < N ; m ++ ) { a [ m ] = aux [ m ] ; } } }
va	3	private String getMonstersString ( ) { String ret = "Monsters in room:\n" ; Set < String > keys = walls . keySet ( ) ; for ( String monster : keys ) { if ( walls . get ( monster ) . getMonster ( ) != null ) { if ( walls . get ( monster ) . getMonster ( ) . isAlive ( ) ) { ret += "- Name : " + walls . get ( monster ) . getMonster ( ) . getName ( ) + " (" + walls . get ( monster ) . getMonster ( ) . getHealth ( ) + ")\n" ; } else { ret += "- Name : " + walls . get ( monster ) . getMonster ( ) . getName ( ) + " (DEAD)\n" ; } } } return ret ; }
va	6	public static boolean isWritable ( Inode srcInode ) { if ( godMode ) { return true ; } else { boolean writable = false ; int [ ] perm = srcInode . getPermissions ( ) ; if ( perm [ 2 ] >= 6 ) writable = true ; else if ( perm [ 1 ] >= 6 ) { if ( TransSystem . getUser ( ) . getGrpId ( ) == srcInode . getGrpId ( ) ) writable = true ; } else if ( perm [ 0 ] >= 6 ) { if ( TransSystem . getUser ( ) . getUserId ( ) == srcInode . getUserId ( ) ) writable = true ; } return writable ; } }
va	0	private void drawLabel ( Label l ) { this . g . drawString ( l . getLabel ( ) , l . getX ( ) , l . getY ( ) ) ; }
va	2	@ Test public void testMultipleRowsAreBuiltFromPokemonStats ( ) { int columns = 3 ; PokemonStats pokemonStats1 = mock ( PokemonStats . class ) ; PokemonStats pokemonStats2 = mock ( PokemonStats . class ) ; PokemonStats pokemonStats3 = mock ( PokemonStats . class ) ; Object [ ] row1 = { 3 , 2 , 1 } ; Object [ ] row2 = { 3 , 2 , 1 } ; Object [ ] row3 = { 0 , 4 , 9 } ; when ( rowBuilder . buildRow ( pokemonStats1 ) ) . thenReturn ( row1 ) ; when ( rowBuilder . buildRow ( pokemonStats2 ) ) . thenReturn ( row2 ) ; when ( rowBuilder . buildRow ( pokemonStats3 ) ) . thenReturn ( row3 ) ; when ( rowBuilder . getColumnCount ( ) ) . thenReturn ( 3 ) ; List < PokemonStats > statsCollection = Arrays . asList ( pokemonStats1 , pokemonStats2 , pokemonStats3 ) ; tableModel . setPokemonStats ( statsCollection ) ; assertEquals ( columns , tableModel . getColumnCount ( ) ) ; Object [ ] [ ] grid = { row1 , row2 , row3 } ; for ( int r = 0 ; r < 3 ; ++ r ) { for ( int c = 0 ; c < columns ; ++ c ) { assertEquals ( grid [ r ] [ c ] , tableModel . getValueAt ( r , c ) ) ; } } }
va	5	@ Override public String rChooseFile ( final Rengine re , final int newFile ) { final FileDialog fd = new FileDialog ( new Frame ( ) , ( newFile == 0 ) ? "Select a file" : "Select a new file" , ( newFile == 0 ) ? FileDialog . LOAD : FileDialog . SAVE ) ; fd . show ( ) ; String res = null ; if ( fd . getDirectory ( ) != null ) { res = fd . getDirectory ( ) ; } if ( fd . getFile ( ) != null ) { res = ( res == null ) ? fd . getFile ( ) : ( res + fd . getFile ( ) ) ; } return res ; }
va	6	public void method480 ( int i , int j , int k , int l , int i1 ) { for ( int j1 = 0 ; j1 < anInt1630 ; j1 ++ ) { int k1 = anIntArray1631 [ j1 ] ; int i2 = anIntArray1632 [ j1 ] ; int j2 = anIntArray1633 [ j1 ] ; if ( anIntArray1637 == null ) { int i3 = anIntArray1640 [ j1 ] ; Class33 class33 = super . aClass33Array1425 [ k1 ] ; int k2 = i + ( k * class33 . anInt602 + l * class33 . anInt603 + i1 * class33 . anInt604 ) / ( j * class33 . anInt605 ) ; anIntArray1634 [ j1 ] = method481 ( i3 , k2 , 0 ) ; class33 = super . aClass33Array1425 [ i2 ] ; k2 = i + ( k * class33 . anInt602 + l * class33 . anInt603 + i1 * class33 . anInt604 ) / ( j * class33 . anInt605 ) ; anIntArray1635 [ j1 ] = method481 ( i3 , k2 , 0 ) ; class33 = super . aClass33Array1425 [ j2 ] ; k2 = i + ( k * class33 . anInt602 + l * class33 . anInt603 + i1 * class33 . anInt604 ) / ( j * class33 . anInt605 ) ; anIntArray1636 [ j1 ] = method481 ( i3 , k2 , 0 ) ; } else if ( ( anIntArray1637 [ j1 ] & 1 ) == 0 ) { int j3 = anIntArray1640 [ j1 ] ; int k3 = anIntArray1637 [ j1 ] ; Class33 class33_1 = super . aClass33Array1425 [ k1 ] ; int l2 = i + ( k * class33_1 . anInt602 + l * class33_1 . anInt603 + i1 * class33_1 . anInt604 ) / ( j * class33_1 . anInt605 ) ; anIntArray1634 [ j1 ] = method481 ( j3 , l2 , k3 ) ; class33_1 = super . aClass33Array1425 [ i2 ] ; l2 = i + ( k * class33_1 . anInt602 + l * class33_1 . anInt603 + i1 * class33_1 . anInt604 ) / ( j * class33_1 . anInt605 ) ; anIntArray1635 [ j1 ] = method481 ( j3 , l2 , k3 ) ; class33_1 = super . aClass33Array1425 [ j2 ] ; l2 = i + ( k * class33_1 . anInt602 + l * class33_1 . anInt603 + i1 * class33_1 . anInt604 ) / ( j * class33_1 . anInt605 ) ; anIntArray1636 [ j1 ] = method481 ( j3 , l2 , k3 ) ; } } super . aClass33Array1425 = null ; aClass33Array1660 = null ; anIntArray1655 = null ; anIntArray1656 = null ; if ( anIntArray1637 != null ) { for ( int l1 = 0 ; l1 < anInt1630 ; l1 ++ ) if ( ( anIntArray1637 [ l1 ] & 2 ) == 2 ) return ; } anIntArray1640 = null ; }
va	7	public int getTimeIndex ( Time time ) { int index = - 1 ; if ( time . getIdTime ( ) > - 1 ) { index = times . indexOf ( time ) ; } else { for ( Time t : times ) { boolean actId = t . getIdActivity ( ) == time . getIdActivity ( ) ; boolean sTime = t . getStartTime ( ) . equals ( time . getStartTime ( ) ) ; boolean eTime = t . getEndTime ( ) . equals ( time . getEndTime ( ) ) ; boolean dur = t . getDuration ( ) == time . getDuration ( ) ; boolean desc = t . getDescription ( ) . equals ( time . getDescription ( ) ) ; if ( actId == true && sTime == true && eTime == true && dur == true && desc == true ) { index = times . indexOf ( t ) ; break ; } } } return index ; }
va	1	protected static long getCPtr ( Storable obj ) { return ( obj == null ) ? 0 : obj . swigCPtr ; }
va	7	private static boolean compareArray ( final String value , final int comparator , final Object [ ] array ) { for ( int i = 0 ; i < array . length ; i ++ ) { final Object obj = array [ i ] ; if ( obj instanceof String ) { if ( compareString ( value , comparator , ( String ) obj ) ) { return true ; } } else if ( obj instanceof Number ) { if ( compareNumber ( value , comparator , ( Number ) obj ) ) { return true ; } } else if ( obj instanceof Comparable ) { if ( compareReflective ( value , comparator , ( Comparable ) obj ) ) { return true ; } } } return false ; }
va	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( registro_estudiante . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( registro_estudiante . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( registro_estudiante . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( registro_estudiante . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { new registro_estudiante ( ) . setVisible ( true ) ; } } ) ; }
va	5	public void addFilter ( String filter , Object ... p ) throws RemoteException { if ( this . initialized ) return ; if ( filter == null ) return ; if ( "" . equals ( this . filter ) ) { this . filter = filter ; } else { this . filter += " and " + filter ; } if ( p != null ) { for ( Object o : p ) { this . params . add ( o ) ; } } }
va	0	public Exception getException ( ) { return this . infoList . get ( infoList . size ( ) - 1 ) . getException ( ) ; }
va	2	public boolean delete ( BaseSetting bs ) { Connection connection = bs . getConnection ( ) ; try { if ( Wording . findById ( this . getId ( ) , bs ) != null ) { String query = "DELETE FROM Wording WHERE id_w = ?" ; PreparedStatement p_statement = connection . prepareStatement ( query ) ; p_statement . setInt ( 1 , this . id ) ; p_statement . executeUpdate ( ) ; } } catch ( SQLException sqle ) { System . out . println ( "ERREUR" ) ; sqle . printStackTrace ( ) ; } return true ; }
va	6	public static void main ( final String [ ] args ) { final int x = 1000 ; for ( int i = 1 ; i < ( x + 1 ) ; i ++ ) for ( int j = 1 ; j < ( x + 1 ) ; j ++ ) for ( int z = 0 ; z < x ; z ++ ) { final int k = j + z ; if ( ( ( ( i * i ) + ( j * j ) ) == ( k * k ) ) && ( i < j ) ) if ( ( i + j + k ) == x ) System . out . println ( i * j * k ) ; } }
va	4	@ SuppressWarnings ( "null" ) public static String generateStringSHA256 ( String content ) { MessageDigest md = null ; try { md = MessageDigest . getInstance ( "SHA-256" ) ; } catch ( NoSuchAlgorithmException ex ) { Logger . getLogger ( files . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } md . update ( content . getBytes ( ) ) ; byte byteData [ ] = md . digest ( ) ; @ SuppressWarnings ( "StringBufferMayBeStringBuilder" ) StringBuffer sb = new StringBuffer ( ) ; for ( int i = 0 ; i < byteData . length ; i ++ ) { sb . append ( Integer . toString ( ( byteData [ i ] & ff ) + 100 , 16 ) . substring ( 1 ) ) ; } @ SuppressWarnings ( "StringBufferMayBeStringBuilder" ) StringBuffer hexString = new StringBuffer ( ) ; for ( int i = 0 ; i < byteData . length ; i ++ ) { String hex = Integer . toHexString ( ff & byteData [ i ] ) ; if ( hex . length ( ) == 1 ) hexString . append ( 0 ) ; hexString . append ( hex ) ; } return hexString . toString ( ) ; }
va	6	private LocalVarList localDec ( Type type ) { LocalVarList localVarList = new LocalVarList ( ) ; if ( lexer . token != Symbol . IDENT ) { error . show ( "Identifier expected" ) ; } Variable variable = symbolTable . getInLocal ( lexer . getStringValue ( ) ) ; if ( variable != null ) { error . show ( "Redeclaration of variable '" + lexer . getStringValue ( ) + "'" ) ; } localVarList . addElement ( new Variable ( lexer . getStringValue ( ) , type ) ) ; symbolTable . putInLocal ( lexer . getStringValue ( ) , new Variable ( lexer . getStringValue ( ) , type ) ) ; lexer . nextToken ( ) ; while ( lexer . token == Symbol . , ) { lexer . nextToken ( ) ; if ( lexer . token != Symbol . IDENT ) { error . show ( "Identifier expected" ) ; } if ( symbolTable . getInLocal ( lexer . getStringValue ( ) ) != null ) { error . show ( "Redeclaration of variable '" + lexer . getStringValue ( ) + "'" ) ; } localVarList . addElement ( new Variable ( lexer . getStringValue ( ) , type ) ) ; symbolTable . putInLocal ( lexer . getStringValue ( ) , new Variable ( lexer . getStringValue ( ) , type ) ) ; lexer . nextToken ( ) ; } if ( lexer . token != Symbol . SEMICOLON ) { error . show ( "';' expected" ) ; } return localVarList ; }
