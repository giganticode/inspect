tr	7	@ Override public void combine ( int [ ] rows , int [ ] columns ) { if ( isOutOfBounds ( rows , columns ) ) { return ; } int rowSpan = rows . length ; int columnSpan = columns . length ; int startRow = rows [ 0 ] ; int startColumn = columns [ 0 ] ; for ( int i = 0 ; i < rowSpan ; i ++ ) { for ( int j = 0 ; j < columnSpan ; j ++ ) { if ( ( span [ startRow + i ] [ startColumn + j ] [ CellSpan . COLUMN ] != 1 ) || ( span [ startRow + i ] [ startColumn + j ] [ CellSpan . ROW ] != 1 ) ) { return ; } } } for ( int i = 0 , ii = 0 ; i < rowSpan ; i ++ , ii -- ) { for ( int j = 0 , jj = 0 ; j < columnSpan ; j ++ , jj -- ) { span [ startRow + i ] [ startColumn + j ] [ CellSpan . COLUMN ] = jj ; span [ startRow + i ] [ startColumn + j ] [ CellSpan . ROW ] = ii ; } } span [ startRow ] [ startColumn ] [ CellSpan . COLUMN ] = columnSpan ; span [ startRow ] [ startColumn ] [ CellSpan . ROW ] = rowSpan ; }
tr	2	private void listAllEmail ( List < Email > emailList , POP3Session session ) { String responseStr = null ; for ( int i = 0 ; i < emailList . size ( ) ; i ++ ) { if ( emailList . get ( i ) . isDeleted ( ) == false ) { responseStr = i + 1 + " " + EmailUtil . getEmailSize ( emailList . get ( i ) ) ; session . sendResponse ( responseStr ) ; } } }
tr	9	@ Override public ByteBuffer createBinaryFrame ( Framedata framedata ) { ByteBuffer mes = framedata . getPayloadData ( ) ; boolean mask = role == Role . CLIENT ; int sizebytes = mes . remaining ( ) <= 125 ? 1 : mes . remaining ( ) <= 65535 ? 2 : 8 ; ByteBuffer buf = ByteBuffer . allocate ( 1 + ( sizebytes > 1 ? sizebytes + 1 : sizebytes ) + ( mask ? 4 : 0 ) + mes . remaining ( ) ) ; byte optcode = fromOpcode ( framedata . getOpcode ( ) ) ; byte one = ( byte ) ( framedata . isFin ( ) ? - 128 : 0 ) ; one |= optcode ; buf . put ( one ) ; byte [ ] payloadlengthbytes = toByteArray ( mes . remaining ( ) , sizebytes ) ; assert ( payloadlengthbytes . length == sizebytes ) ; if ( sizebytes == 1 ) { buf . put ( ( byte ) ( ( byte ) payloadlengthbytes [ 0 ] | ( mask ? ( byte ) - 128 : 0 ) ) ) ; } else if ( sizebytes == 2 ) { buf . put ( ( byte ) ( ( byte ) 126 | ( mask ? ( byte ) - 128 : 0 ) ) ) ; buf . put ( payloadlengthbytes ) ; } else if ( sizebytes == 8 ) { buf . put ( ( byte ) ( ( byte ) 127 | ( mask ? ( byte ) - 128 : 0 ) ) ) ; buf . put ( payloadlengthbytes ) ; } else throw new RuntimeException ( "Size representation not supported/specified" ) ; if ( mask ) { ByteBuffer maskkey = ByteBuffer . allocate ( 4 ) ; maskkey . putInt ( reuseableRandom . nextInt ( ) ) ; buf . put ( maskkey . array ( ) ) ; for ( int i = 0 ; i < mes . limit ( ) ; i ++ ) { buf . put ( ( byte ) ( mes . get ( ) ^ maskkey . get ( i % 4 ) ) ) ; } } else buf . put ( mes ) ; assert ( buf . remaining ( ) == 0 ) : buf . remaining ( ) ; buf . flip ( ) ; return buf ; }
tr	0	protected void disableAuthorizationHeader ( ) { requestHeaders . remove ( "Authorization" ) ; }
tr	9	@ Override public void run ( ) { String line = null ; while ( true ) { try { line = readLine ( ) ; if ( line . startsWith ( EGame . START . toString ( ) ) ) controller . setPlayer ( Integer . parseInt ( line . substring ( EGame . START . toString ( ) . length ( ) ) ) == 1 ? EPlayer . P1 : EPlayer . P2 ) ; else if ( line . startsWith ( EGame . REQUEST_TURN . toString ( ) ) ) { new RequestTurn ( ) . start ( ) ; } else if ( line . startsWith ( EGame . REQUEST_CHOICE . toString ( ) ) ) { new RequestChoice ( ) . start ( ) ; } else if ( line . startsWith ( EGame . OTHER_TURN . toString ( ) ) ) controller . addTurn ( new Turn ( ) . fromString ( line . substring ( EGame . OTHER_TURN . toString ( ) . length ( ) ) ) ) ; else if ( line . startsWith ( EGame . OTHER_CHOICE . toString ( ) ) ) controller . addChoice ( Integer . parseInt ( line . substring ( EGame . OTHER_CHOICE . toString ( ) . length ( ) ) ) ) ; else if ( line . startsWith ( EGame . FINISHED . toString ( ) ) ) { break ; } else if ( line . startsWith ( EGame . INTERRUPTED . toString ( ) ) ) { break ; } } catch ( InterruptedException e ) { break ; } } controller . toLobby ( ) ; }
tr	4	@ Override protected ArrayList < PossibleTile > getLazyTiles ( Board b ) { ArrayList < PossibleTile > possibleTiles = new ArrayList < PossibleTile > ( ) ; int i = 1 ; boolean canSearch = true ; Rook clone = this . clone ( ) ; while ( canSearch ) { PossibleTile pt = new PossibleTile ( clone . getX ( ) - i , clone . getY ( ) , clone ) ; canSearch = decideToAddTile ( b , possibleTiles , pt ) ; i ++ ; } i = 1 ; canSearch = true ; while ( canSearch ) { PossibleTile pt = new PossibleTile ( clone . getX ( ) + i , clone . getY ( ) , clone ) ; canSearch = decideToAddTile ( b , possibleTiles , pt ) ; i ++ ; } i = 1 ; canSearch = true ; while ( canSearch ) { PossibleTile pt = new PossibleTile ( clone . getX ( ) , clone . getY ( ) - i , clone ) ; canSearch = decideToAddTile ( b , possibleTiles , pt ) ; i ++ ; } i = 1 ; canSearch = true ; while ( canSearch ) { PossibleTile pt = new PossibleTile ( clone . getX ( ) , clone . getY ( ) + i , clone ) ; canSearch = decideToAddTile ( b , possibleTiles , pt ) ; i ++ ; } return possibleTiles ; }
tr	3	private ArraySchema parseArraySchema ( JsonNode rawSchema , URL schemaLocation ) { ArraySchema result = new ArraySchema ( ) ; JsonNode rawItems = rawSchema . get ( "items" ) ; if ( rawItems != null ) { result . setItems ( parse ( rawItems , schemaLocation ) ) ; } JsonNode rawMinItems = rawSchema . get ( "minItems" ) ; if ( rawMinItems != null ) { result . setMinItems ( rawMinItems . intValue ( ) ) ; } JsonNode rawMaxItems = rawSchema . get ( "maxItems" ) ; if ( rawMaxItems != null ) { result . setMaxItems ( rawMaxItems . intValue ( ) ) ; } return result ; }
tr	9	public void updateUI ( ArrayList < Comparable > list ) { tglbtnLeuchte . setSelected ( ( boolean ) list . get ( Automat . Adressen . Leuchte . ordinal ( ) ) ) ; tglbtnEingangslichtschranke . setSelected ( ( boolean ) list . get ( Automat . Adressen . Eingangslichtschranke . ordinal ( ) ) ) ; ; tglbtnJustierlichtschranke . setSelected ( ( boolean ) list . get ( Automat . Adressen . Justierlichtschranke . ordinal ( ) ) ) ; ; tglbtnAusgangslichtschranke . setSelected ( ( boolean ) list . get ( Automat . Adressen . Ausgangslichtschranke . ordinal ( ) ) ) ; ; tglbtnEingangAuswahlklappe . setSelected ( ( boolean ) list . get ( Automat . Adressen . AuswahlklappeEingangslichtschranke . ordinal ( ) ) ) ; ; tglbtnLichtschrankepet . setSelected ( ( boolean ) list . get ( Automat . Adressen . UebergabelichtschrankePET . ordinal ( ) ) ) ; ; tglbtnLichtschrankemehrweg . setSelected ( ( boolean ) list . get ( Automat . Adressen . UebergabelichtschrankeMehrweg . ordinal ( ) ) ) ; ; tglbtnTrte . setSelected ( ( boolean ) list . get ( Automat . Adressen . Troete . ordinal ( ) ) ) ; ; tglbtnMehrwegBehlter . setSelected ( ( boolean ) list . get ( Automat . Adressen . FuellstandMehrweg . ordinal ( ) ) ) ; ; tglbtnPetBehlter . setSelected ( ( boolean ) list . get ( Automat . Adressen . FuellstandPET . ordinal ( ) ) ) ; ; switch ( ( Integer ) list . get ( Automat . Adressen . LaufbandEingang . ordinal ( ) ) ) { default : chckbxVorderesGesperrt . setSelected ( true ) ; case 0 : rdbtnVorderesStop . setSelected ( true ) ; break ; case 1 : rdbtnVorderesVorwaerts . setSelected ( true ) ; break ; case - 1 : rdbtnVorderesRueckwaerts . setSelected ( true ) ; break ; } switch ( ( Integer ) list . get ( Automat . Adressen . LaufbandDrehen . ordinal ( ) ) ) { default : chckbxDrehGesperrt . setSelected ( true ) ; case 0 : rdbtnDrehStop . setSelected ( true ) ; break ; case 1 : rdbtnDrehRechts . setSelected ( true ) ; break ; case - 1 : rdbtnDrehLinks . setSelected ( true ) ; break ; } switch ( ( Integer ) list . get ( Automat . Adressen . LaufbandAusgang . ordinal ( ) ) ) { default : chckbxHinteresGesperrt . setSelected ( true ) ; case 0 : rdbtnHinteresStop . setSelected ( true ) ; break ; case 1 : rdbtnHinteresVorwaerts . setSelected ( true ) ; break ; case - 1 : rdbtnHinteresRueckwaerts . setSelected ( true ) ; break ; } }
tr	1	public boolean contains ( long x ) { return ( x >= start ) && ( x < ( start + length ) ) ; }
tr	5	private boolean verificarMovimiento ( JPanelJuego jPanelJuego ) { if ( entroALaPuerta ) return false ; boolean movimiento = true ; if ( teclado . teclaPresionada ( gamePad . getBoton ( Botones . ARRIBA ) ) ) { setEstadoActual ( Estado . ARRIBA ) ; Sonidos . getInstance ( ) . getSonido ( Sonidos . UP ) . play ( ) ; movimientoArriba ( ) ; } else if ( teclado . teclaPresionada ( gamePad . getBoton ( Botones . ABAJO ) ) ) { Sonidos . getInstance ( ) . getSonido ( Sonidos . UP ) . stop ( ) ; setEstadoActual ( Estado . ABAJO ) ; Sonidos . getInstance ( ) . getSonido ( Sonidos . DOWN ) . play ( ) ; movimientoAbajo ( ) ; } else { Sonidos . getInstance ( ) . detenerSonidos ( Sonidos . UP , Sonidos . DOWN ) ; movimiento = false ; } if ( teclado . teclaPresionada ( gamePad . getBoton ( Botones . DERECHA ) ) ) { setEstadoActual ( Estado . DERECHA ) ; Sonidos . getInstance ( ) . getSonido ( Sonidos . LEFT ) . play ( ) ; movimientoDerecha ( ) ; movimiento = true ; } else if ( teclado . teclaPresionada ( gamePad . getBoton ( Botones . IZQUIERDA ) ) ) { Sonidos . getInstance ( ) . getSonido ( Sonidos . LEFT ) . stop ( ) ; setEstadoActual ( Estado . IZQUIERDA ) ; Sonidos . getInstance ( ) . getSonido ( Sonidos . RIGHT ) . play ( ) ; movimientoIzquierda ( ) ; movimiento = true ; } else { Sonidos . getInstance ( ) . detenerSonidos ( Sonidos . LEFT , Sonidos . RIGHT ) ; } return movimiento ; }
tr	5	@ Override public void paint ( Graphics g ) { setBackground ( Color . decode ( preferences . getGuiBoxColor ( ) ) ) ; setForeground ( Color . decode ( preferences . getGuiBoxLabelColor ( ) ) ) ; int width = getWidth ( ) ; int height = getHeight ( ) ; if ( width < preferences . getGuiPixelsPerMeter ( ) && ( width < height / 2 ) ) { paintHere ( g , 0 , 0 , width , height ) ; } else { super . paint ( g ) ; } if ( rotated ) { int w = preferences . getRotationImage ( ) . getWidth ( null ) ; int h = preferences . getRotationImage ( ) . getHeight ( null ) ; g . drawImage ( preferences . getRotationImage ( ) , width - w - 3 , height - h - 3 , null ) ; } if ( mandatory ) { g . drawImage ( preferences . getMandatoryImage ( ) , 3 , 3 , null ) ; } if ( selected ) { g . fillRect ( 1 , 1 , 5 , 5 ) ; g . fillRect ( 1 , height - 6 , 5 , 5 ) ; g . fillRect ( width - 6 , 1 , 5 , 5 ) ; g . fillRect ( width - 6 , height - 6 , 5 , 5 ) ; } }
tr	9	public void evaluateDependencies ( DependencyInstance gold , DependencyInstance pred , boolean evalWithPunc ) { ++ nsents ; int tt = 0 , ua = 0 , la = 0 ; for ( int i = 1 , N = gold . length ; i < N ; ++ i ) { if ( ! evalWithPunc ) if ( gold . forms [ i ] . matches ( "[-!\"%&'()* ./:;?@\\[\\]_{}\u3001]+" ) ) continue ; ++ tt ; if ( gold . heads [ i ] == pred . heads [ i ] ) { ++ ua ; if ( learnLabel && gold . deplbids [ i ] == pred . deplbids [ i ] ) ++ la ; } } tot += tt ; uas += ua ; las += la ; whole += ( tt == ua ) && ( tt == la || ! learnLabel ) ? 1 : 0 ; }
tr	2	public void setValue ( int value ) { if ( value < this . minValue ) { this . value = minValue ; } else if ( value > maxValue ) { this . value = maxValue ; } else { this . value = value ; } this . slider . reactToChanges ( new CustomSliderEvent ( slider , this . value ) ) ; this . textField . reactToChanges ( new CustomTextFieldEvent ( textField , Integer . toString ( this . value ) ) ) ; }
tr	5	public void query ( CollectionTraverser < E > callback , Rect region ) { int beginx = ( int ) ( region . x - region . w2 ) / width ; int beginy = ( int ) ( region . y - region . h2 ) / height ; int endx = ( int ) ( region . x + region . w2 ) / width ; int endy = ( int ) ( region . y + region . h2 ) / height ; Vec2i pos = new Vec2i ( 0 , 0 ) ; for ( int y = beginy ; y <= endy ; y ++ ) { for ( int x = beginx ; x <= endx ; x ++ ) { pos . set ( x , y ) ; ArrayList < E > elements = map . get ( pos ) ; if ( elements != null ) { for ( int i = 0 ; i < elements . size ( ) ; i ++ ) { boolean continueSearching = callback . handleElement ( x , y , elements . get ( i ) ) ; if ( ! continueSearching ) { return ; } } } } } }
tr	1	public boolean equals ( int x , int y ) { return this . x == x && this . y == y ; }
tr	6	public static void main ( String [ ] args ) throws Exception { long start = System . currentTimeMillis ( ) ; Scanner in = new Scanner ( new File ( "d:\\ProgramDATA\\2013\\Fair and Square\\C-large-practice-1.in" ) ) ; System . setOut ( new PrintStream ( new File ( "d:\\ProgramDATA\\2013\\Fair and Square\\C-large-practice1.out" ) ) ) ; int NumCase = in . nextInt ( ) ; in . nextLine ( ) ; for ( int curCase = 1 ; curCase <= NumCase ; curCase ++ ) { long min , max ; min = in . nextLong ( ) ; max = in . nextLong ( ) ; int count = 0 ; long sqrt_min = ( long ) Math . sqrt ( min ) , sqrt_max = ( long ) Math . sqrt ( max ) ; if ( min > 1 && min < 4 ) sqrt_min += 1 ; for ( long i = sqrt_min ; i <= sqrt_max ; i ++ ) { if ( IsPalin ( i ) && IsPalin ( i * i ) ) { count ++ ; } } System . out . println ( " Case #" + curCase + ": " + count ) ; } long end = System . currentTimeMillis ( ) ; System . out . println ( "\u8FD0\u884C\u65F6\u95F4\uFF1A" + ( end - start ) + "ms" ) ; }
tr	2	public void testNorthwindDrools ( ) throws Exception { Engine engine = new Engine ( ) ; StatefulKnowledgeSession session = engine . getKnowledgeSession ( RESOURCE_FILE_NAME ) ; PropertiesLoader props = PropertiesLoaderFactory . getPropertiesLoader ( "northwind_queries.properties" ) ; Set < String > keys = props . getProperties ( ) . stringPropertyNames ( ) ; Map < String , SqlQuery > args = new HashMap < > ( ) ; for ( Iterator < String > it = keys . iterator ( ) ; it . hasNext ( ) ; ) { String ds = DAOConstants . NORTHWIND ; String queryName = it . next ( ) ; SqlQuery query = new SqlQuery ( props . getProperty ( queryName ) , ds ) ; args . put ( queryName , query ) ; } IDynamicDAO dao = DAOFactory . getDynamicDAO ( args ) ; session . setGlobal ( "dao" , dao ) ; Response response = new Response ( ) ; session . setGlobal ( "response" , response ) ; session . fireAllRules ( ) ; ObjectFilter filter = new MatchFilter ( ) ; Collection < FactHandle > factHandles = session . getFactHandles ( filter ) ; Iterator < FactHandle > factHandleIterator = factHandles . iterator ( ) ; while ( factHandleIterator . hasNext ( ) ) { System . out . println ( "Found " + ( session . getObject ( factHandleIterator . next ( ) ) ) ) ; } System . out . println ( "Response : " + response ) ; session . dispose ( ) ; }
tr	1	private static void assertNotNull ( Object o ) { if ( o == null ) { throw new RuntimeException ( "expected no null value" ) ; } }
tr	9	private void drawMenu ( ) { int i = menuOffsetX ; int j = menuOffsetY ; int k = menuWidth ; int l = menuHeight + 1 ; DrawingArea . method338 ( menuOffsetY + 2 , menuHeight - 4 , 250 , 706a5e , menuWidth , menuOffsetX ) ; DrawingArea . method338 ( menuOffsetY + 1 , menuHeight - 2 , 250 , 706a5e , menuWidth - 2 , menuOffsetX + 1 ) ; DrawingArea . method338 ( menuOffsetY , menuHeight , 200 , 706a5e , menuWidth - 4 , menuOffsetX + 2 ) ; DrawingArea . method338 ( menuOffsetY + 1 , menuHeight - 2 , 250 , 2d2822 , menuWidth - 6 , menuOffsetX + 3 ) ; DrawingArea . method338 ( menuOffsetY + 2 , menuHeight - 4 , 250 , 2d2822 , menuWidth - 4 , menuOffsetX + 2 ) ; DrawingArea . method338 ( menuOffsetY + 3 , menuHeight - 6 , 250 , 2d2822 , menuWidth - 2 , menuOffsetX + 1 ) ; DrawingArea . method338 ( menuOffsetY + 19 , menuHeight - 22 , 250 , 524a3d , menuWidth - 4 , menuOffsetX + 2 ) ; DrawingArea . method338 ( menuOffsetY + 20 , menuHeight - 22 , 250 , 524a3d , menuWidth - 6 , menuOffsetX + 3 ) ; DrawingArea . method335 ( 112329 , j + 20 , k - 6 , l - 23 , 170 , i + 3 ) ; DrawingArea . fillPixels ( menuOffsetX + 3 , menuWidth - 6 , 1 , 2a291b , menuOffsetY + 2 ) ; DrawingArea . fillPixels ( menuOffsetX + 2 , menuWidth - 4 , 1 , 2a261b , menuOffsetY + 3 ) ; DrawingArea . fillPixels ( menuOffsetX + 2 , menuWidth - 4 , 1 , 252116 , menuOffsetY + 4 ) ; DrawingArea . fillPixels ( menuOffsetX + 2 , menuWidth - 4 , 1 , 211e15 , menuOffsetY + 5 ) ; DrawingArea . fillPixels ( menuOffsetX + 2 , menuWidth - 4 , 1 , 1e1b12 , menuOffsetY + 6 ) ; DrawingArea . fillPixels ( menuOffsetX + 2 , menuWidth - 4 , 1 , 1a170e , menuOffsetY + 7 ) ; DrawingArea . fillPixels ( menuOffsetX + 2 , menuWidth - 4 , 2 , 15120b , menuOffsetY + 8 ) ; DrawingArea . fillPixels ( menuOffsetX + 2 , menuWidth - 4 , 1 , 100d08 , menuOffsetY + 10 ) ; DrawingArea . fillPixels ( menuOffsetX + 2 , menuWidth - 4 , 1 , 090a04 , menuOffsetY + 11 ) ; DrawingArea . fillPixels ( menuOffsetX + 2 , menuWidth - 4 , 1 , 080703 , menuOffsetY + 12 ) ; DrawingArea . fillPixels ( menuOffsetX + 2 , menuWidth - 4 , 1 , 090a04 , menuOffsetY + 13 ) ; DrawingArea . fillPixels ( menuOffsetX + 2 , menuWidth - 4 , 1 , 070802 , menuOffsetY + 14 ) ; DrawingArea . fillPixels ( menuOffsetX + 2 , menuWidth - 4 , 1 , 090a04 , menuOffsetY + 15 ) ; DrawingArea . fillPixels ( menuOffsetX + 2 , menuWidth - 4 , 1 , 070802 , menuOffsetY + 16 ) ; DrawingArea . fillPixels ( menuOffsetX + 2 , menuWidth - 4 , 1 , 090a04 , menuOffsetY + 17 ) ; DrawingArea . fillPixels ( menuOffsetX + 2 , menuWidth - 4 , 1 , 2a291b , menuOffsetY + 18 ) ; DrawingArea . fillPixels ( menuOffsetX + 3 , menuWidth - 6 , 1 , 564943 , menuOffsetY + 19 ) ; chatTextDrawingArea . method385 ( c6b895 , "Choose Option" , menuOffsetY + 14 , menuOffsetX + 3 ) ; int j1 = super . mouseX ; int k1 = super . mouseY ; if ( menuScreenArea == 0 ) { j1 -= 4 ; k1 -= 4 ; } if ( menuScreenArea == 1 ) { j1 -= 519 ; k1 -= 168 ; } if ( menuScreenArea == 2 ) { j1 -= 17 ; k1 -= 338 ; } if ( menuScreenArea == 3 ) { j1 -= 516 ; k1 -= 0 ; } for ( int l1 = 0 ; l1 < menuActionRow ; l1 ++ ) { int i2 = j + 31 + ( menuActionRow - 1 - l1 ) * 15 ; int j2 = c6b895 ; if ( j1 > i && j1 < i + k && k1 > i2 - 13 && k1 < i2 + 3 ) { DrawingArea . drawPixels ( 15 , i2 - 11 , i + 3 , 26566C , menuWidth - 6 ) ; j2 = eee5c6 ; } chatTextDrawingArea . method389 ( true , i + 4 , AAA184 , menuActionName [ l1 ] , i2 + 1 ) ; } }
tr	7	Writer write ( Writer writer , int indentFactor , int indent ) throws JSONException { try { boolean commanate = false ; int length = this . length ( ) ; writer . write ( [ ) ; if ( length == 1 ) { JSONObject . writeValue ( writer , this . myArrayList . get ( 0 ) , indentFactor , indent ) ; } else if ( length != 0 ) { final int newindent = indent + indentFactor ; for ( int i = 0 ; i < length ; i += 1 ) { if ( commanate ) { writer . write (   ) ; } if ( indentFactor > 0 ) { writer . write ( '' ) ; } JSONObject . indent ( writer , newindent ) ; JSONObject . writeValue ( writer , this . myArrayList . get ( i ) , indentFactor , newindent ) ; commanate = true ; } if ( indentFactor > 0 ) { writer . write ( '' ) ; } JSONObject . indent ( writer , indent ) ; } writer . write ( ] ) ; return writer ; } catch ( IOException e ) { throw new JSONException ( e ) ; } }
tr	4	@ Override public String toString ( ) { switch ( type ) { case BLANK_ENGLISH : return "blank english" ; case BLANK_LOCAL : return "blank local" ; case EQUAL : return "equal" ; case DIFFERENT : default : return "different" ; } }
tr	8	public static void main ( String [ ] args ) { if ( args . length < 1 ) { System . err . println ( "Usage: java FollowPointers input-file" ) ; return ; } String filename = args [ 0 ] ; Scanner scanner = null ; int [ ] array = null ; int size = 0 ; try { scanner = new Scanner ( new FileInputStream ( filename ) ) ; int i = 0 ; while ( scanner . hasNextLine ( ) ) { String line = scanner . nextLine ( ) ; if ( null == line || line . length ( ) == 0 ) break ; if ( 0 == i ) { size = Integer . parseInt ( line ) ; array = new int [ size ] ; } else { int val = Integer . parseInt ( line ) ; array [ i - 1 ] = val ; } i ++ ; } if ( 0 == array . length ) { System . err . println ( "Cannot process pointers" ) ; return ; } int result = followPointers ( array ) ; System . out . println ( result ) ; } catch ( Exception e ) { System . err . println ( "Error processing input file " + filename ) ; e . printStackTrace ( ) ; } finally { if ( null != scanner ) { scanner . close ( ) ; } } }
tr	1	public LinkSetNode ( int s , int d , NodeColor nodeColor , LinkSetNode left , LinkSetNode right ) { if ( s > d ) { this . s = s ; this . d = d ; } else { this . s = d ; this . d = s ; } this . color = nodeColor ; this . left = left ; this . right = right ; }
tr	1	public static int valuePositive ( ) { int value = Integer . MIN_VALUE ; if ( value < 0 ) value = - value ; System . out . println ( "value: " + value ) ; assert ( value >= 0 ) : "value is negative" ; return value ; }
tr	1	public void loadColorPalletState ( Color [ ] initColorPalletColors , int initColorPalletRows , int initNumberOfFixedColors , Color initUnassignedCustomColor ) { colorPalletColors = initColorPalletColors ; colorPalletRows = initColorPalletRows ; numberOfFixedColors = initNumberOfFixedColors ; customColorIndex = numberOfFixedColors ; unassignedCustomColor = initUnassignedCustomColor ; for ( int i = numberOfFixedColors ; i < colorPalletColors . length ; i ++ ) { colorPalletColors [ i ] = unassignedCustomColor ; } }
tr	6	public static String unescape ( String string ) { int length = string . length ( ) ; StringBuffer sb = new StringBuffer ( ) ; for ( int i = 0 ; i < length ; ++ i ) { char c = string . charAt ( i ) ; if ( c == + ) { c =   ; } else if ( c == % && i + 2 < length ) { int d = JSONTokener . dehexchar ( string . charAt ( i + 1 ) ) ; int e = JSONTokener . dehexchar ( string . charAt ( i + 2 ) ) ; if ( d >= 0 && e >= 0 ) { c = ( char ) ( d * 16 + e ) ; i += 2 ; } } sb . append ( c ) ; } return sb . toString ( ) ; }
tr	5	public void update ( byte [ ] data ) { int j = this . dataLen % SLIDING_WND_SIZE ; int fedLen = this . dataLen ; if ( this . aBucket == null ) { this . aBucket = new int [ BUCKETS ] ; } for ( int i = 0 ; i < data . length ; i ++ ) { slideWindow [ j ] = ( int ) data [ i ] & ff ; if ( fedLen >= 4 ) { int j1 = ( j + SLIDING_WND_SIZE - 1 ) % SLIDING_WND_SIZE ; int j2 = ( j + SLIDING_WND_SIZE - 2 ) % SLIDING_WND_SIZE ; int j3 = ( j + SLIDING_WND_SIZE - 3 ) % SLIDING_WND_SIZE ; int j4 = ( j + SLIDING_WND_SIZE - 4 ) % SLIDING_WND_SIZE ; for ( int k = 0 ; k < TLSH_CHECKSUM_LEN ; k ++ ) { if ( k == 0 ) { this . lshBin . checksum [ k ] = bMapping ( 0 , slideWindow [ j ] , slideWindow [ j1 ] , this . lshBin . checksum [ k ] ) ; } else { this . lshBin . checksum [ k ] = bMapping ( this . lshBin . checksum [ k - 1 ] , slideWindow [ j ] , slideWindow [ j1 ] , this . lshBin . checksum [ k ] ) ; } } int r ; r = bMapping ( ( int ) 2 , slideWindow [ j ] , slideWindow [ j1 ] , slideWindow [ j2 ] ) ; this . aBucket [ r ] ++ ; r = bMapping ( ( int ) 3 , slideWindow [ j ] , slideWindow [ j1 ] , slideWindow [ j3 ] ) ; this . aBucket [ r ] ++ ; r = bMapping ( ( int ) 5 , slideWindow [ j ] , slideWindow [ j2 ] , slideWindow [ j3 ] ) ; this . aBucket [ r ] ++ ; r = bMapping ( ( int ) 7 , slideWindow [ j ] , slideWindow [ j2 ] , slideWindow [ j4 ] ) ; this . aBucket [ r ] ++ ; r = bMapping ( ( int ) 11 , slideWindow [ j ] , slideWindow [ j1 ] , slideWindow [ j4 ] ) ; this . aBucket [ r ] ++ ; r = bMapping ( ( int ) 13 , slideWindow [ j ] , slideWindow [ j3 ] , slideWindow [ j4 ] ) ; this . aBucket [ r ] ++ ; } fedLen ++ ; j = ( j + SLIDING_WND_SIZE + 1 ) % SLIDING_WND_SIZE ; } this . dataLen += data . length ; }
tr	1	@ Override public String repr ( int d , boolean displayPosition ) { return ( displayPosition ? "@" + cursor . getPosition ( ) + pref ( d ) : "" ) + "Array" ; }
tr	6	public static List < Integer > detectColorsWithThr ( DigitInput in , double thr1 , double thr2 ) { List < ColorsUtils . Color > colors ; Integer [ ] [ ] [ ] image ; if ( in . options [ Opts . oColorsDetectOn . id ] . is ( Opts . oColorsDetectOn . LEGEND ) && in . legend != null ) image = ImageUtils . bitmapToArray ( in . legend ) ; else image = ImageUtils . bitmapToArray ( in . graph ) ; List < Integer > set = ColorsUtils . getColorSet ( image , true ) ; List < Integer > cols = new ArrayList < > ( ) ; for ( Integer x : set ) { if ( CIELab . delta ( in . background , x ) > 10 ) cols . add ( x ) ; } colors = ColorsUtils . detectColors ( cols , thr1 ) ; cols . clear ( ) ; for ( ColorsUtils . Color c : colors ) { cols . add ( c . mean ) ; } colors = ColorsUtils . detectColorsBetter ( cols , thr2 ) ; List < Integer > result = new ArrayList < > ( ) ; for ( ColorsUtils . Color colRes : colors ) result . add ( colRes . mean ) ; return result ; }
tr	3	public void setColorO ( int colorO ) { this . colorO = colorO ; try { Color c = ColorDP . getOne ( colorO ) ; if ( ( perfil != null ) && ( c != null ) ) { this . colorOrigen = c ; this . stockColorOrigen = StockDP . getStockPerfilColor ( perfil , c ) ; this . enProcesoColorOrigen = OrdenPinturaDetalleDP . getProcesoOrigen ( perfil . getIdperf ( ) , c . getId ( ) ) ; } } catch ( SQLException ex ) { Logger . getLogger ( OrdenPinturaDetalle . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } }
tr	1	public void init ( ) { chat = new XChatPa ( View . aChatInput , View . aChatBut , View . aChatTextArea , this ) ; mySide = ! xNet . isServer ( ) ; Fig . clear ( ) ; FigDw . clear ( ) ; FigDb . clear ( ) ; AddFig ( 5 , 1 , 4 , mySide , 1 ) ; AddFig ( 4 , 1 , 5 , ! mySide , 1 ) ; AddFig ( 0 , 2 , 3 , ! mySide , 1 ) ; for ( int i = 0 ; i < 10 ; i ++ ) Arrays . fill ( Map [ i ] , - 2 ) ; initFigures ( ) ; imgDB . loadAll ( ) ; }
tr	8	public void printSquares ( List < Point2D > list , Point2D p1 , Point2D p2 , Game game ) { Square origin = squareAt ( p1 ) ; Square goal = squareAt ( p2 ) ; System . out . println ( " == MAP SIZE: " + ( xArraySize * TILE_SIZE ) + "x" + ( yArraySize * TILE_SIZE ) + " == " ) ; for ( int y = 0 ; y < yArraySize ; y ++ ) { for ( int x = 0 ; x < xArraySize ; x ++ ) { String printChar = "\u001B[31m" + "0" + "\u001B[0m" ; if ( sqGrid [ x ] [ y ] . isOccupiable ( ) ) printChar = "1" ; if ( sqGrid [ x ] [ y ] . getTerrainCost ( ) > 0 ) printChar = "\u001B[35m" + "1" + "\u001B[0m" ; if ( getTreasureSquares ( game ) . contains ( sqGrid [ x ] [ y ] ) ) printChar = "\u001B[33m" + "T" + "\u001B[0m" ; if ( list . contains ( sqGrid [ x ] [ y ] . getCenter ( ) ) ) printChar = "\u001B[32m" + "X" + "\u001B[0m" ; if ( sqGrid [ x ] [ y ] . equals ( origin ) ) printChar = "\u001B[34m" + "O" + "\u001B[0m" ; if ( sqGrid [ x ] [ y ] . equals ( goal ) ) printChar = "\u001B[34m" + "G" + "\u001B[0m" ; System . out . print ( printChar ) ; } System . out . println ( ) ; } }
tr	9	public String toUpdateKML ( boolean suppressEnclosingTags ) { if ( ! isDirty ( ) ) { return "" ; } String change = "" ; boolean isPrimDirty = isPrimitiveDirty ( ) ; if ( isPrimDirty && ! suppressEnclosingTags ) { change += "<Icon" ; if ( this . id != null ) { change += " id=\"" + this . getId ( ) + "\"" ; } if ( this . targetId != null ) { change += " targetId=\"" + this . getTargetId ( ) + "\"" ; } change += ">\n" ; } change += super . toUpdateKML ( true ) ; if ( this . isXDirty ) { change += "<x>" + this . x + "</x>\n" ; this . isXDirty = false ; } if ( this . isYDirty ) { change += "<y>" + this . y + "</y>\n" ; this . isYDirty = false ; } if ( this . isWDirty ) { change += "<w>" + this . w + "</w>\n" ; this . isWDirty = false ; } if ( this . isHDirty ) { change += "<h>" + this . h + "</h>\n" ; this . isHDirty = false ; } if ( isPrimDirty && ! suppressEnclosingTags ) { change += "</Icon>\n" ; } setNotDirty ( ) ; return change ; }
tr	6	@ Test public void testEncodingSchemeCompleteSerialisationVoice ( ) { try { ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; DISOutputStream dos = new DISOutputStream ( baos ) ; EncodingScheme scheme = new EncodingScheme ( ) ; scheme . setEncodingClass ( EncodingClass . ENCODED_VOICE ) ; scheme . setEncodingType ( EncodingType . MULAW_8 ) ; scheme . write ( dos ) ; byte [ ] asBytes = baos . toByteArray ( ) ; assert . assertEquals ( asBytes [ 0 ] , ( byte ) 00 ) ; assert . assertEquals ( asBytes [ 1 ] , ( byte ) 01 ) ; } catch ( Exception e ) { assert . fail ( "Unexpected exception while serialising a Voice/MuLaw-8 Encoding Scheme record" , e ) ; } try { ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; DISOutputStream dos = new DISOutputStream ( baos ) ; EncodingScheme scheme = new EncodingScheme ( ) ; scheme . setEncodingClass ( EncodingClass . ENCODED_VOICE ) ; scheme . setEncodingType ( EncodingType . CVSD ) ; scheme . write ( dos ) ; byte [ ] asBytes = baos . toByteArray ( ) ; assert . assertEquals ( asBytes [ 0 ] , ( byte ) 00 ) ; assert . assertEquals ( asBytes [ 1 ] , ( byte ) 02 ) ; } catch ( Exception e ) { assert . fail ( "Unexpected exception while serialising a Voice/CVSD Encoding Scheme record" , e ) ; } try { ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; DISOutputStream dos = new DISOutputStream ( baos ) ; EncodingScheme scheme = new EncodingScheme ( ) ; scheme . setEncodingClass ( EncodingClass . ENCODED_VOICE ) ; scheme . setEncodingType ( EncodingType . ADPCM ) ; scheme . write ( dos ) ; byte [ ] asBytes = baos . toByteArray ( ) ; assert . assertEquals ( asBytes [ 0 ] , ( byte ) 00 ) ; assert . assertEquals ( asBytes [ 1 ] , ( byte ) 03 ) ; } catch ( Exception e ) { assert . fail ( "Unexpected exception while serialising a Voice/ADPCM Encoding Scheme record" , e ) ; } try { ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; DISOutputStream dos = new DISOutputStream ( baos ) ; EncodingScheme scheme = new EncodingScheme ( ) ; scheme . setEncodingClass ( EncodingClass . ENCODED_VOICE ) ; scheme . setEncodingType ( EncodingType . PCM_16 ) ; scheme . write ( dos ) ; byte [ ] asBytes = baos . toByteArray ( ) ; assert . assertEquals ( asBytes [ 0 ] , ( byte ) 00 ) ; assert . assertEquals ( asBytes [ 1 ] , ( byte ) 04 ) ; } catch ( Exception e ) { assert . fail ( "Unexpected exception while serialising a Voice/PCM-16 Encoding Scheme record" , e ) ; } try { ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; DISOutputStream dos = new DISOutputStream ( baos ) ; EncodingScheme scheme = new EncodingScheme ( ) ; scheme . setEncodingClass ( EncodingClass . ENCODED_VOICE ) ; scheme . setEncodingType ( EncodingType . PCM_8 ) ; scheme . write ( dos ) ; byte [ ] asBytes = baos . toByteArray ( ) ; assert . assertEquals ( asBytes [ 0 ] , ( byte ) 00 ) ; assert . assertEquals ( asBytes [ 1 ] , ( byte ) 05 ) ; } catch ( Exception e ) { assert . fail ( "Unexpected exception while serialising a Voice/PCM-8 Encoding Scheme record" , e ) ; } try { ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; DISOutputStream dos = new DISOutputStream ( baos ) ; EncodingScheme scheme = new EncodingScheme ( ) ; scheme . setEncodingClass ( EncodingClass . ENCODED_VOICE ) ; scheme . setEncodingType ( EncodingType . VQ ) ; scheme . write ( dos ) ; byte [ ] asBytes = baos . toByteArray ( ) ; assert . assertEquals ( asBytes [ 0 ] , ( byte ) 00 ) ; assert . assertEquals ( asBytes [ 1 ] , ( byte ) 06 ) ; } catch ( Exception e ) { assert . fail ( "Unexpected exception while serialising a Voice/VQ Encoding Scheme record" , e ) ; } }
tr	2	private static void checkSort ( Integer [ ] a ) { for ( int i = 0 ; i < a . length ; i ++ ) if ( a [ i ] != i ) System . out . println ( "Error at " + i ) ; System . out . println ( "Finished checksort" ) ; }
tr	2	public static boolean isPalindrome ( String s , int l , int r ) { while ( l < r ) { if ( s . charAt ( l ) != s . charAt ( r ) ) { return false ; } l ++ ; r -- ; } return true ; }
tr	7	public String getPlayerClass ( Player p ) { if ( perm == null ) { RegisteredServiceProvider < Permission > permissionProvider = getServer ( ) . getServicesManager ( ) . getRegistration ( net . milkbowl . vault . permission . Permission . class ) ; if ( permissionProvider == null ) { System . out . println ( "Vault plugin was not detected. Please install it or else we can not properly format chat." ) ; } else { perm = permissionProvider . getProvider ( ) ; } } if ( perm != null ) { String [ ] groups ; try { groups = perm . getPlayerGroups ( p ) ; } catch ( UnsupportedOperationException e ) { getLogger ( ) . info ( "Valut Exception: " + e . getMessage ( ) ) ; groups = new String [ 0 ] ; } List < String > classes = getConfig ( ) . getStringList ( "classes" ) ; if ( groups . length > 1 ) for ( String grp : groups ) { if ( classes . contains ( grp . toLowerCase ( ) ) ) { return grp ; } } } return getConfig ( ) . getString ( "global.defaultClass" , "Awakened" ) ; }
tr	2	void updateStep6 ( ) { double totalBudget = lg . getBudget ( ) ; double totalExpenses = lg . getHotelBudgetSpent ( ) + lg . getExpenseSpent ( ) ; double remainingBudget = totalBudget - totalExpenses ; textPane6_TotalBudget . setText ( String . valueOf ( "$" + totalBudget ) ) ; textPane6_Spent . setText ( String . valueOf ( "$" + totalExpenses ) ) ; textPane6_Remaining . setText ( String . valueOf ( "$" + remainingBudget ) ) ; if ( lg . getGuestList ( ) . size ( ) != 0 ) { lg . setCostPerHead ( ) ; DecimalFormat df = new DecimalFormat ( "0.00" ) ; df . setGroupingUsed ( false ) ; double costPerHead = lg . getCostPerHead ( ) ; String costPerHeadStr = df . format ( costPerHead ) ; textPane6_CostPerHead . setText ( String . valueOf ( "$" + costPerHeadStr ) ) ; } if ( lg . completedExpenseFields ( ) ) chckbx6_ExpensesFinalised . setEnabled ( true ) ; chckbx6_ExpensesFinalised . setSelected ( lg . getExpenseFinalised ( ) ) ; panel6 . remove ( scrollPane6 ) ; createTable6 ( lg . getExpenseList ( ) , expensesCols ) ; }
tr	6	public void changePanel ( ) { this . removeAll ( ) ; switch ( this . status ) { case 0 : break ; case 1 : this . add ( label [ 0 ] ) ; this . add ( label [ 1 ] ) ; this . add ( label [ 2 ] ) ; this . add ( label [ 3 ] ) ; this . add ( label [ 4 ] ) ; break ; case 2 : textField [ 0 ] . setText ( "" ) ; this . add ( textField [ 0 ] ) ; this . add ( btn [ 1 ] ) ; this . add ( btn [ 2 ] ) ; break ; case 3 : textField [ 1 ] . setText ( "" ) ; files . removeAllElements ( ) ; this . add ( textField [ 1 ] ) ; this . add ( btn [ 0 ] ) ; this . add ( btn [ 1 ] ) ; this . add ( btn [ 2 ] ) ; break ; case 4 : textField [ 2 ] . setText ( ClientLauncher . getFileMgr ( ) . getDownloadPath ( ) ) ; selectedFiles1 . setText ( ClientLauncher . getFrame ( ) . getFileListPanel ( ) . getSelectedNodes ( ) . length + "" ) ; this . add ( textField [ 2 ] ) ; this . add ( selectedFiles1 ) ; this . add ( btn [ 1 ] ) ; this . add ( btn [ 2 ] ) ; break ; case 5 : selectedFiles2 . setText ( ClientLauncher . getFrame ( ) . getFileListPanel ( ) . getSelectedNodes ( ) . length + "" ) ; this . add ( selectedFiles2 ) ; this . add ( btn [ 1 ] ) ; this . add ( btn [ 2 ] ) ; break ; default : break ; } this . add ( bgImg [ status ] ) ; this . repaint ( ) ; }
tr	3	public String [ ] getDisclosedSensitiveColumnNames ( ) { List < String > tmpList = new ArrayList < String > ( ) ; for ( int i = 0 ; i < this . MY_COLUMNS . size ( ) ; i ++ ) { if ( ! this . MY_COLUMNS . get ( i ) . getIsHide ( ) && this . MY_COLUMNS . get ( i ) . getColumnType ( ) == ColumnType . SENSITIVE ) { tmpList . add ( this . MY_COLUMNS . get ( i ) . getName ( ) ) ; } } return ( String [ ] ) tmpList . toArray ( new String [ tmpList . size ( ) ] ) ; }
tr	1	private static CC getCC ( ComponentWrapper comp , Map < ComponentWrapper , CC > ccMap ) { CC cc = ccMap . get ( comp ) ; return cc != null ? cc : new CC ( ) ; }
tr	7	private JSONWriter append ( String string ) throws JSONException { if ( string == null ) { throw new JSONException ( "Null pointer" ) ; } if ( this . mode == o || this . mode == a ) { try { if ( this . , && this . mode == a ) { this . writer . write (   ) ; } this . writer . write ( string ) ; } catch ( IOException e ) { throw new JSONException ( e ) ; } if ( this . mode == o ) { this . mode = k ; } this . , = true ; return this ; } throw new JSONException ( "Value out of sequence." ) ; }
tr	2	private static void = ( int n , String a , String b ) { if ( a != null && a . equals ( b ) ) System . err . println ( "Case " + n + " passed." ) ; else System . err . println ( "Case " + n + " failed: expected \"" + b + "\"  received \"" + a + "\"." ) ; }
tr	5	public int [ ] compute ( int source ) { ZippedArray arr = ZippedArray . arrayWithDefaultValue ( 1000 ) ; int n = graph . getVerticesCount ( ) ; arr . set ( 0 , 0 , source ) ; for ( int i = 1 ; i < n ; i ++ ) { for ( int v = 0 ; v < n ; v ++ ) { int oldValue = ( Integer ) arr . get ( i - 1 , v ) ; int minValue = Integer . MAX_VALUE ; List < Edge > edges = graph . getEdgesTo ( v ) ; for ( Edge edge : edges ) { int x = edge . getX ( ) ; int w = edge . getWeight ( ) ; int t = ( Integer ) arr . get ( i - 1 , x ) + w ; if ( t < minValue ) minValue = t ; } arr . set ( Math . min ( oldValue , minValue ) , i , v ) ; } } int [ ] result = new int [ graph . getVerticesCount ( ) ] ; for ( int i = 0 ; i < graph . getVerticesCount ( ) ; i ++ ) { result [ i ] = ( Integer ) arr . get ( n - 1 , i ) ; } return result ; }
tr	3	@ Override public int storeProject ( String name , String description ) { Connection conn = null ; StringBuffer query = new StringBuffer ( ) ; int newProjectId = 0 ; try { conn = getConnection ( ) ; query . append ( "INSERT INTO " ) . append ( super . getPrimaryTableName ( ) ) . append ( " (name  description)" ) . append ( " VALUES " ) . append ( "('" + name + "'  '" + description + "')" ) ; ResultSet rs = executeUpdateGetKeys ( conn , query . toString ( ) ) ; if ( rs . next ( ) ) { newProjectId = rs . getInt ( 1 ) ; } rs . getStatement ( ) . close ( ) ; rs . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { if ( conn != null ) { close ( conn ) ; } } return newProjectId ; }
tr	1	public void mouseDragged ( MouseEvent mouseEvent ) { if ( paintType == null ) return ; paintType . mouseDragged ( mouseEvent ) ; }
tr	0	public boolean isEnableSound ( ) { return enableSound ; }
tr	7	private String constructHttpHeader ( int code , int fileType ) { String s = "HTTP/1.0 " ; switch ( code ) { case 200 : s = s + "200 OK" ; break ; case 400 : s = s + "400 Bad Request" ; break ; case 403 : s = s + "403 Forbidden" ; break ; case 404 : s = s + "404 Not Found" ; break ; case 500 : s = s + "500 Internal Server Error" ; break ; case 501 : s = s + "501 Not Implemented" ; break ; } s = s + "\r\n" ; s = s + "Connection: close\r\n" ; s = s + "Server: WTBBackend GPS Input\r\n" ; switch ( fileType ) { case 0 : break ; default : s = s + "Content-Type: text/html\r\n" ; break ; } s = s + "\r\n" ; return s ; }
tr	3	private void resetLinkValues ( boolean parentSize , boolean compLinks ) { Object lay = container . getLayout ( ) ; if ( compLinks ) LinkHandler . clearTemporaryBounds ( lay ) ; boolean defIns = ! hasDocks ( ) ; int parW = parentSize ? lc . getWidth ( ) . constrain ( container . getWidth ( ) , getParentSize ( container , true ) , container ) : 0 ; int parH = parentSize ? lc . getHeight ( ) . constrain ( container . getHeight ( ) , getParentSize ( container , false ) , container ) : 0 ; int insX = LayoutUtil . getInsets ( lc , 0 , defIns ) . getPixels ( 0 , container , null ) ; int insY = LayoutUtil . getInsets ( lc , 1 , defIns ) . getPixels ( 0 , container , null ) ; int visW = parW - insX - LayoutUtil . getInsets ( lc , 2 , defIns ) . getPixels ( 0 , container , null ) ; int visH = parH - insY - LayoutUtil . getInsets ( lc , 3 , defIns ) . getPixels ( 0 , container , null ) ; LinkHandler . setBounds ( lay , "visual" , insX , insY , visW , visH , true , false ) ; LinkHandler . setBounds ( lay , "container" , 0 , 0 , parW , parH , true , false ) ; }
tr	3	private void arrangeOptions ( Collection < String > unarranged ) { if ( unarranged . size ( ) == 1 ) { options . addAll ( unarranged ) ; return ; } List < String > shortOptions = new ArrayList < String > ( ) ; List < String > longOptions = new ArrayList < String > ( ) ; for ( String each : unarranged ) { if ( each . length ( ) == 1 ) shortOptions . add ( each ) ; else longOptions . add ( each ) ; } sort ( shortOptions ) ; sort ( longOptions ) ; options . addAll ( shortOptions ) ; options . addAll ( longOptions ) ; }
tr	9	private static boolean afterSpace ( Node node ) { Node prev ; int c ; if ( node == null || node . tag == null || ! ( ( node . tag . model & Dict . CM_INLINE ) != 0 ) ) return true ; prev = node . prev ; if ( prev != null ) { if ( prev . type == Node . TextNode && prev . end > prev . start ) { c = ( ( int ) prev . textarray [ prev . end - 1 ] ) & FF ; if ( c == 160 || c ==   || c == '' ) return true ; } return false ; } return afterSpace ( node . parent ) ; }
tr	6	public Object [ ] resume ( Coroutine thread , Object ... args ) { if ( thread . isDead ( ) ) throw new IllegalStateException ( "Cannot resume a dead coroutine!" ) ; int top = coroutine . getTop ( ) ; coroutine . pushJavaFrame ( null , top , top , 0 ) ; thread . thread = this ; thread . parent = this . coroutine ; CallFrame nextFrame = thread . getCurrentFrame ( ) ; int argCount = args . length ; if ( nextFrame . argCount == - 1 ) nextFrame . setTop ( argCount ) ; for ( int index = 0 ; index < argCount ; index ++ ) nextFrame . push ( args [ index ] ) ; if ( nextFrame . argCount == - 1 ) { nextFrame . argCount = argCount ; nextFrame . init ( ) ; } if ( nextFrame . restoreTop ) nextFrame . setTop ( nextFrame . closure . proto . maxStacksize ) ; this . coroutine = thread ; luaMainloop ( ) ; CallFrame frame = coroutine . getCurrentFrame ( ) ; int retCount = frame . getTop ( ) ; Object [ ] returns = new Object [ retCount ] ; for ( int index = 0 ; index < retCount ; index ++ ) returns [ index ] = frame . get ( index ) ; coroutine . setTop ( top ) ; coroutine . popCallFrame ( ) ; return returns ; }
tr	6	@ SuppressWarnings ( "unchecked" ) private Map < OrderPreviewField , String > getMarketPreviewOrderPaths ( Document doc ) throws UtilityException { Map < OrderPreviewField , String > toReturn = new HashMap < OrderPreviewField , String > ( ) ; for ( OrderPreviewField f : OrderPreviewField . values ( ) ) { String path = f . getPath ( ) ; if ( f . equals ( OrderPreviewField . ERROR ) ) { if ( path != null ) { List < DefaultElement > list = doc . selectNodes ( path ) ; for ( Iterator < DefaultElement > iter = list . iterator ( ) ; iter . hasNext ( ) ; ) { DefaultElement attribute = iter . next ( ) ; String url = attribute . getText ( ) ; throw new UtilityException ( url ) ; } } } if ( path != null ) { List < DefaultElement > list = doc . selectNodes ( path ) ; for ( Iterator < DefaultElement > iter = list . iterator ( ) ; iter . hasNext ( ) ; ) { DefaultElement attribute = iter . next ( ) ; String url = attribute . getText ( ) ; toReturn . put ( f , url ) ; } } } return toReturn ; }
tr	8	private SemanticFrame sequentialSampling ( SemanticFrame goldFrame , int [ ] goldlbids , SRLFeatureData sfd , int p , TIntArrayList args ) { SemanticFrame predict = new SemanticFrame ( goldFrame ) ; predict . arglbids = new int [ goldlbids . length ] ; for ( int i = 0 , L = predict . arglbids . length ; i < L ; ++ i ) predict . arglbids [ i ] = - 1 ; int N = args . size ( ) , M = sfd . L ; int T = N + M ; boolean [ ] usedRel = new boolean [ T ] ; double [ ] score = new double [ T ] ; for ( int a = 0 ; a < N ; ++ a ) { for ( int r = 0 ; r < T ; ++ r ) { if ( usedRel [ r ] ) { score [ r ] = - double . MAX_VALUE ; } else { score [ r ] = r < M ? sfd . getArcScore ( goldFrame . predid , args . get ( a ) , r ) : nullWeight ; if ( addLoss ) score [ r ] += loss ( goldlbids [ args . get ( a ) ] , r < M ? r : - 1 ) ; } } int sample = samplePoint ( score , usedRel ) ; usedRel [ sample ] = true ; predict . arglbids [ args . get ( a ) ] = sample < M ? sample : - 1 ; } return predict ; }
tr	3	public Map < String , Set < String >> readRoleToWords ( ) { if ( this . myDataHolder == null ) { return null ; } Map < String , Set < String >> roleToWords = new HashMap < String , Set < String >> ( ) ; Iterator < Entry < StringPair , String >> iter = this . getDataHolder ( ) . getWordRoleHolder ( ) . entrySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { Entry < StringPair , String > wordRoleObject = iter . next ( ) ; String word = wordRoleObject . getKey ( ) . getHead ( ) ; word = word . replaceAll ( "_" , "-" ) ; String semanticRole = wordRoleObject . getKey ( ) . getTail ( ) ; if ( ! roleToWords . containsKey ( semanticRole ) ) roleToWords . put ( semanticRole , new HashSet < String > ( ) ) ; roleToWords . get ( semanticRole ) . add ( word ) ; } return roleToWords ; }
tr	1	@ Override public void addColumn ( TableColumn column ) { if ( tableColumns . size ( ) == 4 ) { column . setCellRenderer ( renderer ) ; column . setCellEditor ( editor ) ; } super . addColumn ( column ) ; }
tr	3	private void setVariable ( String [ ] parts ) { if ( parts . length < 2 ) { System . out . println ( "Syntax: SET <variable> <value or expression>" ) ; return ; } final String identifier = parts [ 0 ] ; final String value = StringUtils . join ( ArrayUtils . subarray ( parts , 1 , parts . length ) , " " ) ; ASTNode parsedValue = parser . unwrap ( parser . parse ( value , true ) ) ; if ( parsedValue instanceof TermNode && parsedValue . hasChildren ( ) ) { parsedValue = parsedValue . child ( 0 ) ; } context . set ( new Identifier ( identifier ) , parsedValue ) ; System . out . println ( "SET " + identifier + " = " + toString ( parsedValue ) ) ; }
tr	3	public void addPlayer ( Socket conn ) { if ( conn != null ) { waitingPlayers . add ( new ServerPlayer ( conn , playerCount ++ ) ) ; while ( waitingPlayers . size ( ) >= GameManagerWindow . numberOfPlayers ( ) ) { List < ServerPlayer > players = new LinkedList < ServerPlayer > ( ) ; for ( int i = 0 ; i < GameManagerWindow . numberOfPlayers ( ) ; i ++ ) players . add ( waitingPlayers . poll ( ) ) ; games . add ( new Game ( players , this ) ) ; } } }
tr	3	public Map < String , String > getGrades ( ) { if ( studentData == null ) return null ; Map < long , String > tmp = new HashMap < long , String > ( ) ; Map < String , String > map = new HashMap < String , String > ( ) ; for ( AssignmentVO asmt : studentData . getAssignments ( ) ) tmp . put ( asmt . getId ( ) , asmt . getName ( ) ) ; for ( AssignmentScoreVO score : studentData . getAssignmentScores ( ) ) map . put ( tmp . get ( score . getAssignmentId ( ) ) , score . getPercent ( ) ) ; return map ; }
tr	6	static public int convert ( int id ) { switch ( id ) { case CRIT_MELEE : case CRIT_RANGE : case CRIT_SPELL : return CRIT ; case HASTE_MELEE : case HASTE_SPELL : case HASTE_RANGE : return HASTE ; default : return id ; } }
tr	2	@ Override public void addPos ( int elem , int pos ) { checkPosRange ( pos ) ; if ( size + 1 >= capacity ) { resize ( ) ; } for ( int i = size - 1 ; i >= pos ; -- i ) { array [ i + 1 ] = array [ i ] ; } array [ pos ] = elem ; ++ size ; }
tr	4	public void scheduledTask ( InspectorOpenTask task ) { List < State > allowedParents = new ArrayList < > ( ) ; allowedParents . add ( State . SCHEDULED_TASKS_HEADER ) ; allowedParents . add ( State . SCHEDULED_TASK ) ; traverseUp ( allowedParents ) ; if ( this . hierarchy . peek ( ) != State . SCHEDULED_TASK ) this . hierarchy . push ( State . SCHEDULED_TASK ) ; printString ( new StringBuilder ( ) . append ( "<span style=color:" ) . append ( task . isAsync ( ) ? "#3072aa;>" : "#000;>" ) . append ( " [" ) . append ( task . getPluginName ( ) ) . append ( "] (ID: " ) . append ( task . getId ( ) ) . append ( ") " ) . append ( task . isAsync ( ) ? "Async" : "NotAsync" ) . append ( task . isRecurring ( ) ? "  Repeating: " + task . getRecurringPeriod ( ) + " ticks - " : " - " ) . append ( task . getClassName ( ) ) . append ( "</span>" ) . toString ( ) ) ; }
tr	9	public static long longForName ( String s ) { long l = 0 ; for ( int i = 0 ; i < s . length ( ) && i < 12 ; i ++ ) { char c = s . charAt ( i ) ; l *= 37 ; if ( c >= A && c <= Z ) l += ( 1 + c ) - 65 ; else if ( c >= a && c <= z ) l += ( 1 + c ) - 97 ; else if ( c >= 0 && c <= 9 ) l += ( 27 + c ) - 48 ; } for ( ; l % 37 == 0 && l != 0 ; l /= 37 ) ; return l ; }
tr	1	@ Override default GCompany C ( List < GDept > gDepts ) { return new GCompany ( ) { public < Company , Dept , SubUnit , Employee , Person , Salary > Company accept ( SybAlg < Company , Dept , SubUnit , Employee , Person , Salary > alg ) { List < Dept > v = new ArrayList < Dept > ( ) ; for ( GDept o : gDepts ) { v . add ( o . accept ( alg ) ) ; } return alg . C ( v ) ; } } ; }
tr	7	private static void createSet ( int cat , boolean test ) { try { String fieldString = "job_type   opening   contractor  " + "interview_client  interview_contractor  english  hourly_rate  " + "availability_hrs   contr_country   " + "hourly_agency_rate   total_tests  yrs_exp  no_qualifications   " + "total_hours  adjusted_score   " + "adjusted_score_recent  total_last_90_days   " + " pref_english_score   " + "pref_feedback_score  interview_prc " + "pref_test   pref_has_portfolio  " + "number_prev_openings  contr_timezone  client_timezone   " + "cover_unigram_score  order_of_application  client_country  " + "job_unigram_score  number_prev_applications  client" ; String selectString = "select  " + fieldString + " from panagiotis.marios_train_test_cat" + cat + " where  to_timestamp(date_created  / 1000)  " + ( test ? ">" : "<" ) + testSet + "order by date_created" + " " ; PreparedStatement stmt = q . getConn ( ) . prepareStatement ( selectString ) ; stmt . execute ( ) ; ResultSet rs = stmt . getResultSet ( ) ; String [ ] fields = fieldString . split ( " " ) ; System . out . println ( "Writting file..." ) ; PrintToFile pf = new PrintToFile ( ) ; pf . openFile ( "/Users/mkokkodi/git/nudge/data/rawData/" + ( test ? "test" : "train" ) + cat + ".csv" ) ; fields [ 0 ] = fields [ 0 ] . trim ( ) ; String str = fields [ 0 ] ; for ( int i = 1 ; i < fields . length ; i ++ ) { fields [ i ] = fields [ i ] . trim ( ) ; str += " " + fields [ i ] ; } pf . writeToFile ( str ) ; while ( rs . next ( ) ) { String values = "\"" + rs . getString ( fields [ 0 ] ) + "\"" ; for ( int i = 1 ; i < fields . length ; i ++ ) { String curValue = rs . getString ( fields [ i ] ) ; values += " \"" ; if ( curValue != null ) values += curValue ; values += "\"" ; } pf . writeToFile ( values ) ; } System . out . println ( "File written." ) ; } catch ( SQLException sqle ) { sqle . printStackTrace ( ) ; } }
tr	4	@ Override public int addPC ( int vector_index , PopulationChangeVector n , int _class ) throws BTFMatrixErrorException , InternalErrorException { int col = basis . indexOf ( n , 1 ) ; col -= position . col ; if ( col < 0 || col >= array . length ) throw new BTFMatrixErrorException ( "Column not in micro block  when considering n:" + n + " class: " + _class ) ; if ( col + qnm . M - 1 >= array . length ) throw new BTFMatrixErrorException ( "PC will not fit  when considering:" + n + " class: " + _class ) ; for ( int k = 1 ; k <= qnm . M ; k ++ ) { array [ row ] [ col ] = qnm . getDemandAsBigRational ( k - 1 , _class - 1 ) . negate ( ) ; col ++ ; } int inserted_at_row = row ; row ++ ; return inserted_at_row + position . row ; }
tr	4	public static BitSet fromByteArray ( byte [ ] bytes ) { BitSet bits = new BitSet ( ) ; for ( int i = 0 ; i < bytes . length * 8 ; i ++ ) { if ( ( bytes [ bytes . length - i / 8 - 1 ] & ( 1 << ( i % 8 ) ) ) > 0 ) { bits . set ( i ) ; } } for ( int k = bits . size ( ) - 1 ; k >= 0 ; k -- ) { System . out . print ( ( bits . get ( k ) ) ? "1" : "0" ) ; } System . out . println ( ) ; return bits ; }
tr	0	public void setWeight ( int weight ) { this . weight = weight ; }
tr	9	public Subscription ( Socket in_sock , iKPIC_subscribeHandler2 hand ) { final iKPIC_subscribeHandler2 f_eh = hand ; final Socket ft_kpSocket = in_sock ; InputStream reader = null ; try { reader = in_sock . getInputStream ( ) ; } catch ( IOException e2 ) { e2 . printStackTrace ( ) ; } final BufferedReader ft_in = new BufferedReader ( new InputStreamReader ( reader ) ) ; System . out . println ( "Subscription: going to start thread" ) ; Thread eventThread = new Thread ( ) { public void run ( ) { SSAP_XMLTools xmlTools = new SSAP_XMLTools ( null , null , null ) ; String msg_event = "" ; String restOfTheMessage = "" ; int buffsize = 4 * 1024 ; StringBuilder builder = new StringBuilder ( ) ; char [ ] buffer = new char [ buffsize ] ; int charRead = 0 ; try { while ( ( ( charRead = ft_in . read ( buffer , 0 , buffer . length ) ) != ( - 1 ) ) || ( ! restOfTheMessage . isEmpty ( ) ) ) { if ( ! restOfTheMessage . equals ( "" ) ) { builder . append ( restOfTheMessage ) ; restOfTheMessage = "" ; } if ( charRead != - 1 ) { builder . append ( buffer , 0 , charRead ) ; } msg_event = builder . toString ( ) ; if ( msg_event . contains ( "<SSAP_message>" ) && msg_event . contains ( "</SSAP_message>" ) ) { int index = msg_event . indexOf ( "</SSAP_message>" ) + 15 ; restOfTheMessage = msg_event . substring ( index ) ; msg_event = msg_event . substring ( 0 , index ) ; String subID = xmlTools . getSubscriptionID ( msg_event ) ; if ( xmlTools . isUnSubscriptionConfirmed ( msg_event ) ) { f_eh . kpic_UnsubscribeEventHandler ( subID ) ; return ; } else { String indSequence = xmlTools . getSSAPmsgIndicationSequence ( msg_event ) ; if ( xmlTools . isRDFNotification ( msg_event ) ) { Vector < Vector < String >> triples_n = new Vector < Vector < String >> ( ) ; triples_n = xmlTools . getNewResultEventTriple ( msg_event ) ; Vector < Vector < String >> triples_o = new Vector < Vector < String >> ( ) ; triples_o = xmlTools . getObsoleteResultEventTriple ( msg_event ) ; f_eh . kpic_RDFEventHandler ( triples_n , triples_o , indSequence , subID ) ; } else { SSAP_sparql_response resp_new = xmlTools . get_SPARQL_indication_new_results ( msg_event ) ; SSAP_sparql_response resp_old = xmlTools . get_SPARQL_indication_obsolete_results ( msg_event ) ; f_eh . kpic_SPARQLEventHandler ( resp_new , resp_old , indSequence , subID ) ; } if ( restOfTheMessage . contains ( "<SSAP_message>" ) && restOfTheMessage . contains ( "</SSAP_message>" ) ) { String test = restOfTheMessage . substring ( 0 , restOfTheMessage . indexOf ( "</SSAP_message>" ) + 15 ) ; if ( xmlTools . isUnSubscriptionConfirmed ( test ) ) { System . out . println ( "I should never print this please check" ) ; return ; } } buffer = new char [ buffsize ] ; charRead = 0 ; msg_event = "" ; builder = new StringBuilder ( ) ; } } } try { System . out . println ( "I should not go here untili unsubscribe" ) ; ft_in . close ( ) ; ft_kpSocket . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; f_eh . kpic_ExceptionEventHandler ( e ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; f_eh . kpic_ExceptionEventHandler ( e ) ; } } } ; eventThread . start ( ) ; }
tr	5	public ListNode deleteDuplicates ( ListNode head ) { if ( head == null ) return null ; ListNode cur = head ; ListNode last = head ; int value = head . val ; while ( cur . next != null ) { cur = cur . next ; if ( cur . val != value ) { if ( last . next != cur ) last . next = cur ; last = cur ; value = cur . val ; } } if ( last != cur ) { last . next = null ; } return head ; }
tr	3	public static boolean createTable ( Connection con , TableInfo tableInfo ) { System . out . println ( "Creating table " + tableInfo . tableName ) ; String tableCreate = "CREATE TABLE " + tableInfo . tableName + " ( " ; for ( String i : tableInfo . columns ) { String [ ] tmp = i . split ( " " ) ; tableCreate += " " + tmp [ 0 ] + " " + tmp [ 1 ] + "   " ; } for ( String i : tableInfo . foreignKeys ) { String [ ] tmp = i . split ( " " ) ; tableCreate += " FOREIGN KEY (" + tmp [ 0 ] + ") REFERENCES  " + tmp [ 1 ] + "   " ; } tableCreate += " PRIMARY KEY (ID) )" ; try { Statement stmt = con . createStatement ( ) ; stmt . execute ( tableCreate ) ; stmt . close ( ) ; } catch ( SQLException sqle ) { System . out . println ( "DBObject createTable(" + tableInfo . tableName + "): " + "Unhandled SQLException  create string:\n" + tableCreate + "\n\n Exception: \n" + sqle + "\n\n" ) ; return false ; } return true ; }
tr	8	private PhoneId initPhoneIdParams ( ) { if ( CUSTOMER_ID . isEmpty ( ) || SECRET_KEY . isEmpty ( ) ) { fail ( "CUSTOMER_ID and SECRET_KEY must be set to pass this test" ) ; } PhoneId pid ; if ( ! timeouts && ! isHttpsProtocolSet ) pid = new PhoneId ( CUSTOMER_ID , SECRET_KEY ) ; else if ( timeouts && ! isHttpsProtocolSet ) pid = new PhoneId ( CUSTOMER_ID , SECRET_KEY , connectTimeout , readTimeout ) ; else if ( ! timeouts && isHttpsProtocolSet ) pid = new PhoneId ( CUSTOMER_ID , SECRET_KEY , HTTPS_PROTOCOL ) ; else pid = new PhoneId ( CUSTOMER_ID , SECRET_KEY , connectTimeout , readTimeout , HTTPS_PROTOCOL ) ; return pid ; }
tr	2	public static JSONArray listById ( long [ ] aId ) { JSONArray ja = new JSONArray ( ) ; for ( long l : aId ) { User user = User . findById ( l ) ; if ( user != null ) ja . put ( user . toJson ( ) ) ; } return ja ; }
tr	0	public PaintScreenGridManager ( final double width , final double height ) { update ( width , height ) ; }
tr	1	private int getNextIndicator ( ) throws IOException { if ( this . indicator == 0 ) { this . indicator = in . read ( ) ; } return this . indicator ; }
tr	3	public static Element [ ] getElementChildren ( Element element , String name ) { Element [ ] elements = getElementChildren ( element ) ; List < Element > taggedElements = new ArrayList < Element > ( ) ; for ( int i = 0 ; i < elements . length ; i ++ ) { if ( elements [ i ] . getLocalName ( ) . equals ( name ) && elements [ i ] . getNamespaceURI ( ) == null ) { taggedElements . add ( elements [ i ] ) ; } } return taggedElements . toArray ( new Element [ 0 ] ) ; }
tr	2	public InputField ( ) { super ( ) ; setText ( "Type Here!" ) ; setColumns ( 10 ) ; addMouseListener ( new MouseListener ( ) { @ Override public void mouseClicked ( MouseEvent e ) { if ( getText ( ) . equals ( "Type Here!" ) ) setText ( "" ) ; requestFocusInWindow ( ) ; } @ Override public void mousePressed ( MouseEvent e ) { } @ Override public void mouseReleased ( MouseEvent e ) { } @ Override public void mouseEntered ( MouseEvent e ) { } @ Override public void mouseExited ( MouseEvent e ) { } } ) ; addKeyListener ( new KeyListener ( ) { @ Override public void keyTyped ( KeyEvent e ) { } @ Override public void keyPressed ( KeyEvent e ) { if ( e . getKeyCode ( ) == 10 ) { sendMessage ( ) ; setText ( "" ) ; } } @ Override public void keyReleased ( KeyEvent e ) { } } ) ; }
tr	3	public static boolean submitProjectsToDB ( String s_id , ArrayList < Integer > projects , ArrayList < float > scores ) { try { Connection conn = global . getConnection ( ) ; PreparedStatement pStmt = conn . prepareStatement ( "update takes_project set score = ? where student_id = ? and project_id = ?" ) ; pStmt . setString ( 2 , s_id ) ; for ( int i = 0 ; i < projects . size ( ) ; i ++ ) { pStmt . setInt ( 3 , projects . get ( i ) ) ; pStmt . setFloat ( 1 , scores . get ( i ) ) ; pStmt . executeUpdate ( ) ; } pStmt . close ( ) ; conn . close ( ) ; return true ; } catch ( ClassNotFoundException cnfe ) { System . err . println ( "CNFE: " + cnfe ) ; return false ; } catch ( SQLException sqle ) { System . err . println ( "SQLE: " + sqle ) ; return false ; } }
tr	5	public SLA checkSLAAllocationCostMin ( SLA slaTemplate ) { SLA slaAllocation = ( SLA ) slaTemplate . clone ( ) ; Map < String , Type [ ] > allocations = new HashMap < String , Type [ ] > ( ) ; Set < Type > allTypes = slaAllocation . getHeadNode ( ) . getConnectedTypes ( ) ; Type someType = allTypes . iterator ( ) . next ( ) ; List < Resource > orderedResources = new ArrayList < Resource > ( ) ; orderedResources . addAll ( resources . values ( ) ) ; Collections . sort ( orderedResources , new CostMinComparator ( someType . getStartTime ( ) , someType . getDuration ( ) ) ) ; Iterator < Resource > resourceIterator = orderedResources . iterator ( ) ; Iterator < Type > typeIterator = allTypes . iterator ( ) ; Resource r = resourceIterator . next ( ) ; List < Type > typesForAResource = new ArrayList < Type > ( ) ; while ( typeIterator . hasNext ( ) ) { Type t = typeIterator . next ( ) ; typesForAResource . add ( t ) ; while ( ! r . isTypesFitting ( typesForAResource . toArray ( new Type [ typesForAResource . size ( ) ] ) ) ) { typesForAResource . remove ( t ) ; if ( resourceIterator . hasNext ( ) ) { if ( typesForAResource . size ( ) > 0 ) { allocations . put ( r . getId ( ) , typesForAResource . toArray ( new Type [ typesForAResource . size ( ) ] ) ) ; typesForAResource = new ArrayList < Type > ( ) ; } typesForAResource . add ( t ) ; r = resourceIterator . next ( ) ; } else { return null ; } } } if ( typesForAResource . size ( ) > 0 ) { allocations . put ( r . getId ( ) , typesForAResource . toArray ( new Type [ typesForAResource . size ( ) ] ) ) ; } slaAllocation . setAllocation ( allocations ) ; return slaAllocation ; }
tr	4	public void testFileContent ( ) throws IOException { long start = System . currentTimeMillis ( ) ; byte [ ] buf1 = new byte [ 1024 ] ; byte [ ] buf2 = new byte [ 1024 ] ; int size1 , size2 ; String fileName1 = "test1.class" ; String fileName2 = "test2.class" ; File file1 = new File ( fileName1 ) ; File file2 = new File ( fileName2 ) ; BufferedInputStream bis1 = new BufferedInputStream ( new FileInputStream ( file1 ) ) ; BufferedInputStream bis2 = new BufferedInputStream ( new FileInputStream ( file2 ) ) ; Polynomial polynomial = Polynomial . createIrreducible ( 53 ) ; Fingerprint < Polynomial > rabin1 = new RabinFingerprintLong ( polynomial ) ; Fingerprint < Polynomial > rabin2 = new RabinFingerprintLong ( polynomial ) ; while ( ( ( size1 = bis1 . read ( buf1 ) ) != - 1 ) && ( ( size2 = bis2 . read ( buf2 ) ) != - 1 ) ) { rabin1 . pushBytes ( buf1 ) ; rabin2 . pushBytes ( buf2 ) ; String s1 = new String ( buf1 ) ; String s2 = new String ( buf2 ) ; if ( rabin1 . getFingerprint ( ) . compareTo ( rabin2 . getFingerprint ( ) ) != 0 ) { System . out . println ( "file 1 and file 2 are different!" ) ; break ; } } if ( rabin1 . getFingerprint ( ) . compareTo ( rabin2 . getFingerprint ( ) ) == 0 ) System . out . println ( "file 1 and file 2 are the same!" ) ; long end = System . currentTimeMillis ( ) ; System . out . println ( "Time: " + ( end - start ) + "ms." ) ; assertEquals ( 0 , rabin1 . getFingerprint ( ) . compareTo ( rabin2 . getFingerprint ( ) ) ) ; }
tr	2	public boolean isAlive ( ) { if ( ! isAlive ) { if ( location != null ) { field . clear ( location ) ; location = null ; field = null ; } } return isAlive ; }
tr	1	public void testFloatLargeArrayConstant ( ) { FloatLargeArray a = new FloatLargeArray ( 1 << 33 , 2.5f ) ; assertEquals ( 2.5f , a . getFloat ( 0 ) ) ; assertEquals ( 2.5f , a . getFloat ( a . length ( ) - 1 ) ) ; Throwable e = null ; try { a . setFloat ( 0 , 3.5f ) ; } catch ( IllegalAccessError ex ) { e = ex ; } assertTrue ( e instanceof IllegalAccessError ) ; assertNull ( a . getData ( ) ) ; }
tr	0	private int valueRanges ( Situation s ) { return valueSolution ( s , 0 ) ; }
tr	7	@ Override public void Lands ( Player P ) { if ( Owner == - 1 ) { Game . requestBuy ( P , this ) ; } else if ( Owner != Game . players . indexOf ( P ) ) { if ( ( Game . players . get ( Owner ) ) . InPrison == false ) { int Pay = 0 ; int cnt = CountShippingLines ( ) ; Player OPlayer = Game . players . get ( Owner ) ; if ( cnt == 1 ) { Pay = 500 ; JOptionPane . showMessageDialog ( null , "Du betaler leje: " + Pay + " til ejeren" ) ; P . ChangeMoney ( - Pay ) ; OPlayer . ChangeMoney ( Pay ) ; } else if ( cnt == 2 ) { Pay = 1000 ; JOptionPane . showMessageDialog ( null , "Du betaler leje: " + Pay + " til ejeren" ) ; P . ChangeMoney ( - Pay ) ; OPlayer . ChangeMoney ( Pay ) ; } else if ( cnt == 3 ) { Pay = 2000 ; JOptionPane . showMessageDialog ( null , "Du betaler leje: " + Pay + " til ejeren" ) ; P . ChangeMoney ( - Pay ) ; OPlayer . ChangeMoney ( Pay ) ; } else if ( cnt == 4 ) { Pay = 4000 ; JOptionPane . showMessageDialog ( null , "Du betaler leje: " + Pay + " til ejeren" ) ; P . ChangeMoney ( - Pay ) ; OPlayer . ChangeMoney ( Pay ) ; } } } }
tr	0	public int getPeopleOnStation ( ) { return peopleOnStation ; }
tr	4	private boolean makeHostNameUnique ( DNSRecord . Address host ) { final String originalName = host . getName ( ) ; System . currentTimeMillis ( ) ; boolean collision ; do { collision = false ; for ( DNSCache . CacheNode j = cache . find ( host . getName ( ) . toLowerCase ( ) ) ; j != null ; j = j . next ( ) ) { if ( false ) { host . name = incrementName ( host . getName ( ) ) ; collision = true ; break ; } } } while ( collision ) ; if ( originalName . equals ( host . getName ( ) ) ) { return false ; } else { return true ; } }
tr	8	public static void main ( String args [ ] ) throws IOException { Scanner obj = new Scanner ( System . in ) ; System . out . print ( " " ) ; int n = obj . nextInt ( ) ; int m = obj . nextInt ( ) ; int p = obj . nextInt ( ) ; int [ ] [ ] arr = new int [ n ] [ m ] ; int [ ] brr = new int [ n ] ; for ( int i = 0 ; i < n ; ++ i ) { for ( int j = 0 ; j < m ; ++ j ) { arr [ i ] [ j ] = j ; } } while ( p -- > 0 ) { int i = obj . nextInt ( ) ; int j = obj . nextInt ( ) ; arr [ i - 1 ] [ j - 1 ] += 1 ; } for ( int i = 0 ; i < m ; ++ i ) { int j ; for ( j = m - 1 ; j > 0 ; -- j ) { if ( arr [ i ] [ j ] >= arr [ i ] [ j - 1 ] ) { brr [ i ] += arr [ i ] [ j ] - arr [ i ] [ j - 1 ] ; } else { break ; } } if ( j != 0 ) { brr [ i ] = - 1 ; } } for ( int i = 0 ; i < n ; ++ i ) { System . out . println ( brr [ i ] ) ; } }
tr	6	public static String unescape ( String string ) { int length = string . length ( ) ; StringBuffer sb = new StringBuffer ( ) ; for ( int i = 0 ; i < length ; ++ i ) { char c = string . charAt ( i ) ; if ( c == + ) { c =   ; } else if ( c == % && i + 2 < length ) { int d = JSONTokener . dehexchar ( string . charAt ( i + 1 ) ) ; int e = JSONTokener . dehexchar ( string . charAt ( i + 2 ) ) ; if ( d >= 0 && e >= 0 ) { c = ( char ) ( d * 16 + e ) ; i += 2 ; } } sb . append ( c ) ; } return sb . toString ( ) ; }
tr	0	public List < String > complete ( String string , int position ) { return CompletionUtil . completeStrings ( strings , string ) ; }
tr	8	private boolean r_tidy_up ( ) { int among_var ; ket = cursor ; among_var = find_among_b ( a_7 , 4 ) ; if ( among_var == 0 ) { return false ; } bra = cursor ; switch ( among_var ) { case 0 : return false ; case 1 : slice_del ( ) ; ket = cursor ; if ( ! ( eq_s_b ( 1 , "\u043D" ) ) ) { return false ; } bra = cursor ; if ( ! ( eq_s_b ( 1 , "\u043D" ) ) ) { return false ; } slice_del ( ) ; break ; case 2 : if ( ! ( eq_s_b ( 1 , "\u043D" ) ) ) { return false ; } slice_del ( ) ; break ; case 3 : slice_del ( ) ; break ; } return true ; }
tr	3	public static JSONObject toJSONObject ( String string ) throws JSONException { String n ; JSONObject o = new JSONObject ( ) ; Object v ; JSONTokener x = new JSONTokener ( string ) ; o . put ( "name" , x . nextTo ( = ) ) ; x . next ( = ) ; o . put ( "value" , x . nextTo ( ; ) ) ; x . next ( ) ; while ( x . more ( ) ) { n = unescape ( x . nextTo ( "=;" ) ) ; if ( x . next ( ) != = ) { if ( n . equals ( "secure" ) ) { v = boolean . true ; } else { throw x . syntaxError ( "Missing '=' in cookie parameter." ) ; } } else { v = unescape ( x . nextTo ( ; ) ) ; x . next ( ) ; } o . put ( n , v ) ; } return o ; }
tr	9	public JSONArray ( JSONTokener x ) throws JSONException { this ( ) ; char c = x . nextClean ( ) ; char q ; if ( c == [ ) { q = ] ; } else if ( c == ( ) { q = ) ; } else { throw x . syntaxError ( "A JSONArray text must start with '['" ) ; } if ( x . nextClean ( ) == ] ) { return ; } x . back ( ) ; for ( ; ; ) { if ( x . nextClean ( ) ==   ) { x . back ( ) ; this . myArrayList . add ( null ) ; } else { x . back ( ) ; this . myArrayList . add ( x . nextValue ( ) ) ; } c = x . nextClean ( ) ; switch ( c ) { case ; : case   : if ( x . nextClean ( ) == ] ) { return ; } x . back ( ) ; break ; case ] : case ) : if ( q != c ) { throw x . syntaxError ( "Expected a '" + new Character ( q ) + "'" ) ; } return ; default : throw x . syntaxError ( "Expected a ' ' or ']'" ) ; } } }
tr	4	public int getChoice ( ) { Turn turn = null ; int choice = - 1 ; synchronized ( lastSelected ) { needTurn = false ; turn = lastSelected ; view . enableOnly ( turn ) ; while ( squareSelected != 1 ) { try { lastSelected . wait ( ) ; } catch ( InterruptedException e ) { return - 1 ; } } squareSelected = 0 ; if ( turn . pos [ 1 ] . equals ( lastSelected . pos [ 0 ] ) ) choice = 1 ; else if ( turn . pos [ 0 ] . equals ( lastSelected . pos [ 0 ] ) ) choice = 0 ; view . enableSquares ( false ) ; } return choice ; }
tr	5	public int generateDurability ( int blockY ) { int durability = baseDurability_ ; if ( variance_ > 0 ) { durability += Citadel . getRandom ( ) . nextInt ( ) % ( variance_ * 2 + 1 ) ; durability -= variance_ ; } if ( yAdjustment_ < 0.00001 || yAdjustment_ > 0.00001 ) { durability += ( int ) ( ( float ) blockY * yAdjustment_ ) ; } if ( durability < minDurability_ ) { return minDurability_ ; } if ( durability > maxDurability_ ) { return maxDurability_ ; } return durability ; }
tr	4	void moveDownSItem_actionPerformed ( ActionEvent e ) { if ( currentElementShape == null || currentFractalShape == null ) return ; ArrayList < ElementShape > list = currentFractalShape . elementShapes ; int index = list . indexOf ( currentElementShape ) ; if ( index == - 1 || index == list . size ( ) - 1 ) return ; list . remove ( index ) ; list . add ( index + 1 , currentElementShape ) ; updateShapes ( ) ; FractalShapeMaker . viewer . redraw ( ) ; }
tr	8	public void checkOut ( Vector < Integer > callNumbers , int bid ) { PreparedStatement ps = null ; Statement stmt ; ResultSet rs , rs2 , rs3 ; int copyNumber ; try { stmt = con . con . createStatement ( ) ; rs = stmt . executeQuery ( "select * from (Select * from borrower where bid = " + bid + " AND expiryDate < sysdate) b FULL JOIN (select bid from fine f borrowing b where b.borid = f.borid AND b.bid = " + bid + " AND f.paidDate IS NULL) c on b.bid = c.bid" ) ; int c = 0 ; while ( rs . next ( ) ) { c ++ ; } System . out . println ( c ) ; if ( c == 0 ) { rs2 = stmt . executeQuery ( "select bookTimeLimit from borrower b  borrower_type bt where bt.type LIKE b.type AND b.bid = " + bid ) ; if ( rs2 . next ( ) ) { int limit = rs2 . getInt ( "bookTimeLimit" ) ; for ( int i = 0 ; i < callNumbers . size ( ) ; i ++ ) { rs3 = null ; Statement stm1 = con . con . createStatement ( ) ; rs3 = stm1 . executeQuery ( "select * from bookcopy where callNumber = " + callNumbers . get ( i ) . toString ( ) + " AND (status LIKE 'in' or status LIKE 'on-hold')" ) ; if ( rs3 . next ( ) ) { copyNumber = rs3 . getInt ( "copyNo" ) ; ps = con . con . prepareStatement ( "INSERT INTO borrowing VALUES (borid_sequence.nextval ? ? ? ? null)" ) ; java . util . Date today = new java . util . Date ( ) ; java . sql . Date todaysql2 = new java . sql . Date ( today . getTime ( ) ) ; ps . setInt ( 1 , bid ) ; ps . setInt ( 2 , callNumbers . get ( i ) ) ; System . out . println ( callNumbers . get ( i ) ) ; System . out . println ( copyNumber ) ; ps . setInt ( 3 , copyNumber ) ; ps . setDate ( 4 , todaysql2 ) ; ps . executeUpdate ( ) ; ps . close ( ) ; System . out . println ( callNumbers . get ( i ) . toString ( ) + " checked out!\n" ) ; ps = con . con . prepareStatement ( "UPDATE bookcopy SET status='out' WHERE callNumber = ? AND copyNo = ?" ) ; ps . setInt ( 1 , callNumbers . get ( i ) ) ; ps . setInt ( 2 , copyNumber ) ; ps . executeUpdate ( ) ; ps . close ( ) ; con . con . commit ( ) ; System . out . println ( "executed update" ) ; ResultSet returnTime ; Statement stm = con . con . createStatement ( ) ; returnTime = stm . executeQuery ( "SELECT bc.callNumber  (bc.outDate + t.bookTimeLimit)duedate FROM borrower_type t  (SELECT * FROM borrower b  (SELECT * FROM borrowing WHERE callNumber = " + callNumbers . get ( i ) + " AND copyNo = " + copyNumber + " AND INDATE IS NULL) c WHERE b.bid = c.bid) bc WHERE bc.type like t.type" ) ; if ( returnTime . next ( ) ) { new NotificationDialog ( null , "Checked out!" , "Book: " + returnTime . getInt ( "callNumber" ) + " Copy No: " + copyNumber + "\n Due: " + returnTime . getDate ( "duedate" ) . toString ( ) ) ; } rs3 . close ( ) ; stm . close ( ) ; stm1 . close ( ) ; } else { new NotificationDialog ( null , "ERROR!" , "No more copies available for Call Number " + callNumbers . get ( i ) + "! Unable to check out." ) ; } } con . con . commit ( ) ; } else { new NotificationDialog ( null , "ERROR!" , "The borrower does not exist  or his/her account is expired." ) ; } } else { new NotificationDialog ( null , "ERROR!" , "This borrower has outstanding unpaid fines or his account is expired. " ) ; } } catch ( SQLException e ) { new NotificationDialog ( null , "ERROR!" , "Something went wrong somewhere in the Database Handler  method: check out. Damn. " + e . getMessage ( ) ) ; e . printStackTrace ( ) ; System . out . println ( "Message: " + e . getMessage ( ) ) ; try { con . con . rollback ( ) ; } catch ( SQLException ex2 ) { System . out . println ( "Message: " + ex2 . getMessage ( ) ) ; System . exit ( - 1 ) ; } } }
tr	8	public ListNode addTwoNumbers ( ListNode l1 , ListNode l2 ) { ListNode list = null , tail = null ; int carry = 0 ; while ( l1 != null || l2 != null || carry != 0 ) { int num1 = l1 == null ? 0 : l1 . val ; int num2 = l2 == null ? 0 : l2 . val ; int sum = num1 + num2 + carry ; carry = sum / 10 ; sum %= 10 ; if ( list == null ) { list = new ListNode ( sum ) ; tail = list ; } else { tail . next = new ListNode ( sum ) ; tail = tail . next ; } l1 = l1 == null ? null : l1 . next ; l2 = l2 == null ? null : l2 . next ; } return list ; }
tr	4	public static void main ( String [ ] args ) { try { getConfig ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { try { SubstanceLookAndFeel laf = new SubstanceMarinerLookAndFeel ( ) ; UIManager . setLookAndFeel ( laf ) ; String skinClassName = "org.pushingpixels.substance.api.skin." + skin + "Skin" ; SubstanceLookAndFeel . setSkin ( skinClassName ) ; JDialog . setDefaultLookAndFeelDecorated ( true ) ; } catch ( UnsupportedLookAndFeelException e ) { throw new RuntimeException ( e ) ; } } } ) ; java . awt . EventQueue . invokeLater ( new Runnable ( ) { @ SuppressWarnings ( "static-access" ) public void run ( ) { frame = new MainFrame ( ) ; frame . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; frame . setVisible ( true ) ; try { @ SuppressWarnings ( "resource" ) Socket telnet = new Socket ( Phone . AsteriskIp , 5038 ) ; telnet . setKeepAlive ( true ) ; telnetWriter = new PrintWriter ( telnet . getOutputStream ( ) ) ; telnetReader = new BufferedReader ( new InputStreamReader ( telnet . getInputStream ( ) ) ) ; telnetWriter . print ( "Action: login\r\n" ) ; telnetWriter . print ( "UserName: " + Phone . ReadUser + "\r\n" ) ; telnetWriter . print ( "Secret: " + Phone . ReadUserPassword + "\r\n\r\n" ) ; telnetWriter . flush ( ) ; } catch ( SocketException e1 ) { e1 . printStackTrace ( ) ; } catch ( IOException e1 ) { e1 . printStackTrace ( ) ; } AsteriskThread = new AsteriskThread ( ) ; AsteriskThread . start ( ) ; } } ) ; }
tr	2	@ Override public String stringValue ( byte [ ] val ) { if ( val == null ) { return "" ; } else { Object obj = decode ( val ) ; if ( obj != null ) return obj . toString ( ) ; else return "" ; } }
tr	7	private JSONWriter append ( String string ) throws JSONException { if ( string == null ) { throw new JSONException ( "Null pointer" ) ; } if ( this . mode == o || this . mode == a ) { try { if ( this . , && this . mode == a ) { this . writer . write (   ) ; } this . writer . write ( string ) ; } catch ( IOException e ) { throw new JSONException ( e ) ; } if ( this . mode == o ) { this . mode = k ; } this . , = true ; return this ; } throw new JSONException ( "Value out of sequence." ) ; }
