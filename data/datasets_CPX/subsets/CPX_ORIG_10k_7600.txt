va	1	@ SuppressWarnings ( "CallToThreadDumpStack" ) private void criaXML ( String ip , String caminho ) { try { File db = new File ( "config.xml" ) ; db . createNewFile ( ) ; FileWriter fileW = new FileWriter ( db . getAbsolutePath ( ) ) ; try ( BufferedWriter buffW = new BufferedWriter ( fileW ) ) { buffW . write ( "<ipServidor>" + ip + "</ipServidor>" ) ; buffW . newLine ( ) ; buffW . write ( "<caminhoBanco>" + caminho + "</caminhoBanco>" ) ; } } catch ( IOException | HeadlessException e ) { e . printStackTrace ( ) ; } }
va	0	public int getHeight ( ) { return size . getY ( ) ; }
va	2	public void Imprimir ( ) { for ( int f = 0 ; f < 3 ; f ++ ) { for ( int c = 0 ; c < 5 ; c ++ ) { System . out . print ( matriz [ f ] [ c ] + " " ) ; } System . out . println ( ) ; } }
va	8	private void advance ( ) throws IOException { next = null ; while ( ( next == null ) && ( null != rdr ) ) { final String line = rdr . readLine ( ) ; if ( null == line ) { rdr . close ( ) ; rdr = null ; } else { if ( line . trim ( ) . length ( ) > 0 ) { final Map < String , Object > map = new LinkedHashMap < String , Object > ( ) ; final int lineLen = line . length ( ) ; boolean gotOne = false ; for ( final FixedFieldDef fi : fields ) { if ( ( fi . l < lineLen ) && ( fi . r > fi . l ) ) { final String val = line . substring ( fi . l , Math . min ( fi . r , lineLen ) ) . trim ( ) ; gotOne |= val . length ( ) > 0 ; map . put ( fi . name , val ) ; } else { map . put ( fi . name , null ) ; } } if ( gotOne ) { next = new BurstMap ( line , map ) ; } } } } }
va	8	private void paramCompare ( Method aMethod , ExprList exprList ) { if ( aMethod . getParamList ( ) . getSize ( ) == 0 && exprList == null ) { return ; } if ( ( aMethod . getParamList ( ) . getSize ( ) == 0 && exprList == null ) || ( aMethod . getParamList ( ) . getSize ( ) != exprList . getSize ( ) ) ) { error . show ( "Param count mismatch" ) ; } for ( int i = 0 ; i < exprList . getSize ( ) ; i ++ ) { Variable expParam = aMethod . getParamList ( ) . get ( i ) ; Expr pasParam = exprList . getElement ( i ) ; if ( ( pasParam . getType ( ) instanceof ClassDec ) && ! ( ( ClassDec ) pasParam . getType ( ) ) . isChildOf ( expParam . getType ( ) . getName ( ) ) ) { error . show ( "Param type mismatch: '" + expParam . getType ( ) . getName ( ) + "' expected. '" + pasParam . getType ( ) . getName ( ) + "' given." ) ; } } }
va	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( Succes . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( Succes . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( Succes . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( Succes . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { Dimension dim = Toolkit . getDefaultToolkit ( ) . getScreenSize ( ) ; int w = succ . getSize ( ) . width ; int h = succ . getSize ( ) . height ; int x = ( dim . width - w ) / 2 ; int y = ( dim . height - h ) / 2 ; succ . setLocation ( x , y ) ; succ . setVisible ( true ) ; } } ) ; }
va	1	public static byte renderBooleanByte ( final boolean value ) { return ( byte ) ( value ? 1 : 0 ) ; }
va	7	public static void main ( String args [ ] ) { System . out . print ( "Enter the string:" ) ; Scanner obj = new Scanner ( System . in ) ; String s = obj . next ( ) ; String s1 = "" ; for ( int i = 0 ; i < s . length ( ) ; ++ i ) { char ch = s . charAt ( i ) ; if ( ch != a && ch != e && ch != i && ch != o && ch != u ) { s1 = s1 + ch ; } } if ( s1 == null ) { System . out . println ( "The string is empty" ) ; } else { System . out . println ( s1 ) ; } }
va	4	public static void dump ( Node node ) { if ( node instanceof Comment ) { System . out . print ( node ) ; } else if ( node instanceof PrintBold ) { System . out . print ( node ) ; } else if ( node instanceof Print ) { System . out . print ( node ) ; } else if ( node instanceof Block ) { System . out . print ( ( Block ) node + ":" ) ; dump ( ( ( Block ) node ) . first ) ; System . out . print (   ) ; dump ( ( ( Block ) node ) . second ) ; } else { System . err . println ( "ERR: no match for node." ) ; System . exit ( 42 ) ; } }
va	0	public int getValue ( ) { return val ; }
va	7	@ Override public void widgetSelected ( SelectionEvent e ) { QResults results = null ; String tempname = _USuname_tbox . getText ( ) ; if ( _US_radio . getSelection ( ) ) { if ( gethist_radio . getSelection ( ) && Sanitizer . isCleanInput ( tempname ) ) { results = new QResults ( display , "history" , tempname , portclient , session ) ; results . open ( ) ; } else if ( getinfo_radio . getSelection ( ) && Sanitizer . isCleanInput ( tempname ) ) { results = new QResults ( display , "getinfo" , tempname , portclient , session ) ; results . open ( ) ; } else { MessageBox messageBox = new MessageBox ( shlPortunesAdministrator , SWT . ICON_ERROR ) ; messageBox . setMessage ( "Invalid Input(s)." ) ; messageBox . open ( ) ; } } else if ( list_radio . getSelection ( ) ) { results = new QResults ( display , "list" , tempname , portclient , session ) ; results . open ( ) ; } else if ( _DB_radio . getSelection ( ) ) { results = new QResults ( display , "arb" , query , portclient , session ) ; results . open ( ) ; } }
va	0	public IRCPluginHandler getPluginHandler ( ) { return ph ; }
va	7	public static int findShortestDistance ( String [ ] words , String word1 , String word2 ) { int min = Integer . MAX_VALUE ; int lastWord1Position = - 1 ; int lastWord2Position = - 1 ; for ( int i = 0 ; i < words . length ; ++ i ) { if ( words [ i ] . equals ( word1 ) ) { if ( lastWord2Position != - 1 ) { if ( ( i - lastWord2Position ) < min ) { min = i - lastWord2Position ; } } lastWord1Position = i ; } if ( words [ i ] . equals ( word2 ) ) { if ( lastWord1Position != - 1 ) { if ( ( i - lastWord1Position ) < min ) { min = i - lastWord1Position ; } } lastWord2Position = i ; } } return min ; }
va	0	private static void jj_la1_init_0 ( ) { jj_la1_0 = new int [ ] { 1a40 , 60 , 60 , 180 , 180 , 1240 , 1200 , } ; }
va	1	@ Override public List < Framedata > createFrames ( String text , boolean mask ) { FrameBuilder curframe = new FramedataImpl1 ( ) ; try { curframe . setPayload ( ByteBuffer . wrap ( Charsetfunctions . utf8Bytes ( text ) ) ) ; } catch ( InvalidDataException e ) { throw new NotSendableException ( e ) ; } curframe . setFin ( true ) ; curframe . setOptcode ( Opcode . TEXT ) ; curframe . setTransferemasked ( mask ) ; return Collections . singletonList ( ( Framedata ) curframe ) ; }
va	8	public JSONObject ( Map copyFrom ) { this ( ) ; Map < ? , ? > contentsTyped = ( Map < ? , ? > ) copyFrom ; for ( Map . Entry < ? , ? > entry : contentsTyped . entrySet ( ) ) { String key = ( String ) entry . getKey ( ) ; if ( key == null ) { throw new NullPointerException ( "key == null" ) ; } nameValuePairs . put ( key , wrap ( entry . getValue ( ) ) ) ; } }
va	5	public String getWuXingJuNum ( ) { String num = "" ; if ( wuXingNum == 2 ) num = "\u4E8C" ; else if ( wuXingNum == 3 ) num = "\u4E09" ; else if ( wuXingNum == 4 ) num = "\u56DB" ; else if ( wuXingNum == 5 ) num = "\u4E94" ; else if ( wuXingNum == 6 ) num = "\u516D" ; return num ; }
va	0	public OneSpaceTileAction ( ) { }
va	1	public void test ( ) throws JavaLayerException { try { open ( new AudioFormat ( 22050 , 16 , 1 , true , false ) ) ; short [ ] data = new short [ 22050 / 10 ] ; write ( data , 0 , data . length ) ; flush ( ) ; close ( ) ; } catch ( RuntimeException ex ) { throw new JavaLayerException ( "Device test failed: " + ex ) ; } }
va	8	public static boolean validarFormatoFecha ( String formato ) { boolean valida = true ; String patron1 = "0[1-9]-[0-2][0-9]-[0-9][0-9][0-9][0-9]" ; String patron2 = "1[0-2]-[0-2][0-9]-[0-9][0-9][0-9][0-9]" ; valida = formato . matches ( patron1 ) || formato . matches ( patron2 ) || valida ; patron1 = "0[1-9]-31-[0-9][0-9][0-9][0-9]" ; patron2 = "1[0-2]-31-[0-9][0-9][0-9][0-9]" ; valida = formato . matches ( patron1 ) || formato . matches ( patron2 ) || valida ; patron1 = "[1-9]-[1-9]-[0-9][0-9][0-9][0-9]" ; patron2 = "1[0-2]-[1-9]-[0-9][0-9][0-9][0-9]" ; valida = formato . matches ( patron1 ) || formato . matches ( patron2 ) || valida ; patron1 = "[1-9]-31-[1-9][0-9][0-9]" ; patron2 = "1[0-2]-31-[1-9][0-9][0-9]" ; valida = formato . matches ( patron1 ) || formato . matches ( patron2 ) || valida ; return valida ; }
va	4	public static int recursion ( int n , int m , int step ) { if ( n == m ) { return m + step - 1 ; } if ( n % 2 == 0 && ( n / 2 + step ) % m == 0 ) { return n / 2 + step ; } else { if ( n < m ) { return - 1 ; } else { return recursion ( n - 1 , m , ++ step ) ; } } }
va	1	public StringBuilder streamOut ( ) { double left = center_x - radius ; double right = center_x + radius ; double top = center_y + radius ; double bot = center_y - radius ; StringBuilder circOut = new StringBuilder ( ) ; circOut . append ( ".5 w\n" ) ; if ( fillColor . equals ( GoColor . WHITE ) ) { circOut . append ( "1.000 1.000 1.000 rg\n" ) ; } else { circOut . append ( "0.000 0.000 0.000 rg\n" ) ; } circOut . append ( center_x ) . append ( " " ) . append ( bot ) . append ( " m\n" ) ; circOut . append ( center_x + bmod ) . append ( " " ) . append ( bot ) . append ( " " ) . append ( right ) . append ( " " ) . append ( center_y - bmod ) . append ( " " ) . append ( right ) . append ( " " ) . append ( center_y ) . append ( " c\n" ) ; circOut . append ( right ) . append ( " " ) . append ( center_y + bmod ) . append ( " " ) . append ( center_x + bmod ) . append ( " " ) . append ( top ) . append ( " " ) . append ( center_x ) . append ( " " ) . append ( top ) . append ( " c\n" ) ; circOut . append ( center_x - bmod ) . append ( " " ) . append ( top ) . append ( " " ) . append ( left ) . append ( " " ) . append ( center_y + bmod ) . append ( " " ) . append ( left ) . append ( " " ) . append ( center_y ) . append ( " c\n" ) ; circOut . append ( left ) . append ( " " ) . append ( center_y - bmod ) . append ( " " ) . append ( center_x - bmod ) . append ( " " ) . append ( bot ) . append ( " " ) . append ( center_x ) . append ( " " ) . append ( bot ) . append ( " c\n" ) ; circOut . append ( "B\n" ) ; return circOut ; }
va	9	public void method216 ( int i , int j , int k , int l , int i1 , boolean flag ) { int j1 = 256 ; if ( flag ) j1 += 20000 ; k -= anInt290 ; l -= anInt291 ; if ( i == 1 || i == 3 ) { int k1 = j ; j = i1 ; i1 = k1 ; } for ( int l1 = k ; l1 < k + j ; l1 ++ ) if ( l1 >= 0 && l1 < anInt292 ) { for ( int i2 = l ; i2 < l + i1 ; i2 ++ ) if ( i2 >= 0 && i2 < anInt293 ) method217 ( j1 , l1 , i2 ) ; } }
va	4	public com . novativa . www . ws . streamsterapi . | [ ] getBars ( java . lang . String instrument , java . lang . String period , java . lang . String options ) throws java . rmi . RemoteException { if ( super . cachedEndpoint == null ) { throw new org . apache . axis . NoEndPointException ( ) ; } org . apache . axis . client . Call _call = createCall ( ) ; _call . setOperation ( _operations [ 10 ] ) ; _call . setUseSOAPAction ( true ) ; _call . setSOAPActionURI ( "GetBars" ) ; _call . setEncodingStyle ( null ) ; _call . setProperty ( org . apache . axis . client . Call . SEND_TYPE_ATTR , boolean . false ) ; _call . setProperty ( org . apache . axis . AxisEngine . PROP_DOMULTIREFS , boolean . false ) ; _call . setSOAPVersion ( org . apache . axis . soap . SOAPConstants . SOAP11_CONSTANTS ) ; _call . setOperationName ( new javax . xml . namespace . QName ( "" , "GetBars" ) ) ; setRequestHeaders ( _call ) ; setAttachments ( _call ) ; try { java . lang . Object _resp = _call . invoke ( new java . lang . Object [ ] { instrument , period , options } ) ; if ( _resp instanceof java . rmi . RemoteException ) { throw ( java . rmi . RemoteException ) _resp ; } else { extractAttachments ( _call ) ; try { return ( com . novativa . www . ws . streamsterapi . | [ ] ) _resp ; } catch ( java . lang . Exception _exception ) { return ( com . novativa . www . ws . streamsterapi . | [ ] ) org . apache . axis . utils . JavaUtils . convert ( _resp , com . novativa . www . ws . streamsterapi . | [ ] . class ) ; } } } catch ( org . apache . axis . AxisFault axisFaultException ) { throw axisFaultException ; } }
va	5	public List < String > anagrams ( String [ ] strs ) { List < String > result = new ArrayList < > ( ) ; if ( strs == null || strs . length < 2 ) return result ; HashMap < String , Integer > map = new HashMap < > ( ) ; for ( int i = 0 ; i < strs . length ; i ++ ) { char [ ] sortedChars = strs [ i ] . toCharArray ( ) ; Arrays . sort ( sortedChars ) ; String sortedStr = new String ( sortedChars ) ; if ( map . containsKey ( sortedStr ) ) { int idx = map . get ( sortedStr ) ; if ( idx == - 1 ) { result . add ( strs [ i ] ) ; } else { result . add ( strs [ idx ] ) ; result . add ( strs [ i ] ) ; map . put ( sortedStr , - 1 ) ; } } else { map . put ( sortedStr , i ) ; } } return result ; }
va	5	public Entry < K > [ ] getEntries ( ) { EntryObjectInt < K > next = null ; int index = 0 , index2 = 0 ; EntryObjectInt < K > [ ] t = table ; Entry < K > [ ] result = new Entry [ size ] ; while ( index < t . length ) { if ( next == null ) while ( index < t . length && ( next = t [ index ++ ] ) == null ) ; while ( next != null ) { result [ index2 ++ ] = next ; next = next . next ; } } return result ; }
va	6	@ Override public void run ( ) { while ( true ) { int result = - 1 ; for ( Task t : taskQueue ) { try { if ( t instanceof MapperTask ) { result = ( ( MapperTask ) t ) . performOperation ( ) ; } else if ( t instanceof ReducerTask ) { result = ( ( ReducerTask ) t ) . performOperation ( ) ; } } finally { if ( result == 0 ) taskQueue . remove ( t ) ; else Logger . log ( "Error while executing task " + t . taskId ) ; } } try { Thread . sleep ( 1000 ) ; } catch ( InterruptedException e ) { Logger . log ( "Task Queue interrupted" ) ; } } }
va	8	private Object newInstance ( Properties config , String key ) throws ServletException { try { class < ? > clazz = ( class < ? > ) ClassUtils . forName ( config . getProperty ( key ) ) ; Object instance = clazz . newInstance ( ) ; try { clazz . getMethod ( "setProperties" , new class < ? > [ ] { Properties . class } ) . invoke ( instance , new Object [ ] { config } ) ; clazz . getMethod ( "setServletContext" , new class < ? > [ ] { ServletContext . class } ) . invoke ( instance , new Object [ ] { getServletContext ( ) } ) ; clazz . getMethod ( "setModel" , new class < ? > [ ] { Model . class } ) . invoke ( instance , new Object [ ] { MODEL } ) ; clazz . getMethod ( "setView" , new class < ? > [ ] { View . class } ) . invoke ( instance , new Object [ ] { VIEW } ) ; } catch ( NoSuchMethodException e ) { } return instance ; } catch ( Exception e ) { throw new ServletException ( e . getMessage ( ) , e ) ; } }
va	7	public void check ( Lexer lexer , Node node , AttVal attval ) { String value ; if ( node . tag != null && ( ( node . tag . model & Dict . CM_IMG ) != 0 ) ) { getCheckValign ( ) . check ( lexer , node , attval ) ; return ; } value = attval . value ; if ( value == null ) Report . attrError ( lexer , node , attval . attribute , Report . MISSING_ATTR_VALUE ) ; else if ( ! ( Lexer . wstrcasecmp ( value , "left" ) == 0 || Lexer . wstrcasecmp ( value , "center" ) == 0 || Lexer . wstrcasecmp ( value , "right" ) == 0 || Lexer . wstrcasecmp ( value , "justify" ) == 0 ) ) Report . attrError ( lexer , node , attval . value , Report . BAD_ATTRIBUTE_VALUE ) ; }
va	7	public static void main ( String [ ] args ) { boolean all_right ; all_right = true ; String p0 ; int p1 ; p0 = "A" ; p1 = 1 ; all_right = KawigiEdit_RunTest ( 0 , p0 , true , p1 ) && all_right ; p0 = "ABC" ; p1 = 6 ; all_right = KawigiEdit_RunTest ( 1 , p0 , true , p1 ) && all_right ; p0 = "VAMOSGIMNASIA" ; p1 = 143 ; all_right = KawigiEdit_RunTest ( 2 , p0 , true , p1 ) && all_right ; p0 = "TOPCODER" ; p1 = 96 ; all_right = KawigiEdit_RunTest ( 3 , p0 , true , p1 ) && all_right ; p0 = "SINGLEROUNDMATCH" ; p1 = 183 ; all_right = KawigiEdit_RunTest ( 4 , p0 , true , p1 ) && all_right ; p0 = "ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ" ; p1 = 1300 ; all_right = KawigiEdit_RunTest ( 5 , p0 , true , p1 ) && all_right ; if ( all_right ) { System . out . println ( "You're a stud (at least on the example cases)!" ) ; } else { System . out . println ( "Some of the test cases had errors." ) ; } }
va	4	private static int [ ] [ ] getSums ( ) { int [ ] [ ] sums = new int [ LENGTH ] [ LENGTH ] ; sums [ 0 ] [ 0 ] = matrix [ 0 ] [ 0 ] ; for ( int row = 1 ; row < LENGTH ; row ++ ) { for ( int diagonal = 0 ; diagonal < row + 1 ; diagonal ++ ) { if ( diagonal == 0 ) { sums [ row ] [ 0 ] = sums [ row - 1 ] [ 0 ] + matrix [ row ] [ 0 ] ; } else if ( diagonal == row ) { sums [ 0 ] [ row ] = sums [ 0 ] [ row - 1 ] + matrix [ 0 ] [ row - 1 ] ; } else { int i = row - diagonal ; int j = diagonal ; sums [ i ] [ j ] = sums [ i ] [ j - 1 ] + sums [ i - 1 ] [ j ] - sums [ i - 1 ] [ j - 1 ] + matrix [ i ] [ j ] ; } } } return sums ; }
va	6	private int [ ] [ ] multiplicar ( int [ ] [ ] llave , int [ ] [ ] datos ) { if ( llave [ 0 ] . length != datos . length ) { throw new IllegalArgumentException ( "Llave Columnas: " + llave [ 0 ] . length + " =/= Dato Filas: " + datos . length ) ; } int numF = llave . length ; int numC = datos [ 0 ] . length ; int numO = datos . length ; int [ ] [ ] salida = new int [ numF ] [ numC ] ; for ( int f = 0 ; f < numF ; f ++ ) { for ( int c = 0 ; c < numC ; c ++ ) { salida [ f ] [ c ] = 0 ; } } for ( int f = 0 ; f < numF ; f ++ ) { for ( int c = 0 ; c < numC ; c ++ ) { for ( int o = 0 ; o < numO ; o ++ ) { salida [ f ] [ c ] += llave [ o ] [ f ] * datos [ o ] [ c ] ; } } } return salida ; }
va	4	public PDU createPDU ( PDUHeader header ) { PDU asPDU = null ; switch ( header . getPDUType ( ) ) { case PDUType . TRANSMITTER : asPDU = new TransmitterPDU ( header ) ; break ; case PDUType . SIGNAL : asPDU = new SignalPDU ( header ) ; break ; case PDUType . COMMENT : asPDU = new CommentPDU ( header ) ; break ; case PDUType . SET_DATA : asPDU = new SetDataPDU ( header ) ; break ; } return asPDU ; }
va	2	@ Override public void entityInitialTick ( ) { for ( int i = 0 ; i < def . initialParticleFactories . length ; i ++ ) { ParticleFactory f = def . initialParticleFactories [ i ] ; for ( int n = 0 ; n < def . initialParticleCounts [ i ] ; n ++ ) { GameCtrl . get ( ) . addParticle ( f , loc . clone ( ) , initialDirection ) ; } } }
va	5	@ Override public void run ( ) { Message response = null ; try { response = responseQueue . poll ( 1 , TimeUnit . MINUTES ) ; } catch ( InterruptedException e ) { return ; } if ( response != null ) { if ( response . getFileResponse ( ) . equals ( "yes" ) ) { JDialog dialog = new JDialog ( ( JFrame ) null , "File transfer request" , false ) ; JPanel pane = new JPanel ( ) ; final JProgressBar progressbar = new JProgressBar ( 0 , ( int ) file . length ( ) ) ; progressbar . setValue ( 0 ) ; progressbar . setStringPainted ( true ) ; final JTextArea statusPane = new JTextArea ( 5 , 20 ) ; JScrollPane scrollPane = new JScrollPane ( statusPane ) ; statusPane . setEditable ( false ) ; statusPane . append ( response . getSender ( ) + " accepted the file. \nMessage: " + response . getFileResponseMessage ( ) + "\n" ) ; pane . add ( progressbar ) ; pane . add ( scrollPane ) ; dialog . add ( pane ) ; dialog . setAlwaysOnTop ( true ) ; dialog . setLocationRelativeTo ( null ) ; dialog . setPreferredSize ( new Dimension ( 300 , 100 ) ) ; dialog . setMinimumSize ( new Dimension ( 300 , 100 ) ) ; dialog . setVisible ( true ) ; statusPane . append ( "Opening socket on address " + ip + ":" + response . getFilePort ( ) + "\n" ) ; Socket skt ; BufferedOutputStream output ; BufferedInputStream input ; try { skt = new Socket ( ip , response . getFilePort ( ) ) ; output = new BufferedOutputStream ( skt . getOutputStream ( ) ) ; input = new BufferedInputStream ( new FileInputStream ( this . file ) ) ; int data ; int i = 0 ; statusPane . append ( "Transferring file...\n" ) ; while ( ( data = input . read ( ) ) != - 1 ) { output . write ( data ) ; i ++ ; final int p = i ; SwingUtilities . invokeLater ( new Runnable ( ) { @ Override public void run ( ) { progressbar . setValue ( p ) ; } } ) ; output . flush ( ) ; } output . close ( ) ; input . close ( ) ; skt . close ( ) ; statusPane . append ( "Done. All streams closed" ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } else { JOptionPane . showMessageDialog ( null , response . getSender ( ) + " did not accept the file.\nReason: " + response . getFileResponseMessage ( ) , "File request rejected" , JOptionPane . INFORMATION_MESSAGE ) ; } } else { JOptionPane . showMessageDialog ( null , "File request timed out" , "File request rejected" , JOptionPane . INFORMATION_MESSAGE ) ; } }
va	0	@ Override public float getBlockOutPerSec ( ) { return BlockOutPerSec ; }
va	0	public void doWork ( ) { System . out . println ( "and now  working hard" ) ; doMessage ( ) ; }
va	7	public static < T > int binary ( T [ ] a , T t , Comparator < T > c ) { if ( a == null || t == null || c == null ) { throw new IllegalArgumentException ( ) ; } if ( a . length == 0 ) { return - 1 ; } int low = 0 ; int high = a . length - 1 ; int i = a . length / 2 ; while ( low <= high ) { int x = c . compare ( t , a [ i ] ) ; if ( x == 0 ) { return i ; } if ( x < 0 ) { high = i - 1 ; } else { low = i + 1 ; } i = ( ( high - low ) / 2 ) + low ; } return - 1 ; }
va	2	public void pintar ( Graphics g ) { if ( ! activo || getEstadoActual ( ) == Estado . ELIMINADO ) return ; imagen . actualizar ( getEstadoActual ( ) . ordinal ( ) , animaciones . get ( getEstadoActual ( ) . ordinal ( ) ) . getCuadroActual ( ) ) ; imagen . pintar ( g ) ; }
va	1	public static < T > Enumeration < T > cast ( Enumeration < ? > p , class < T > cls ) { return ( Enumeration < T > ) p ; }
va	3	private void jButton1ActionPerformed ( java . awt . event . ActionEvent evt ) { String region ; String field ; String value ; region = jList1 . getSelectedValue ( ) . toString ( ) ; field = jList2 . getSelectedValue ( ) . toString ( ) ; value = jTextField1 . getText ( ) ; System . out . println ( region + " " + field + " " + value ) ; if ( region == null ) { Component component = ( Component ) evt . getSource ( ) ; JFrame frame = ( JFrame ) SwingUtilities . getRoot ( component ) ; JOptionPane . showMessageDialog ( frame , "Please select one region for update!" , "Warning" , JOptionPane . WARNING_MESSAGE ) ; } if ( field == null ) { Component component = ( Component ) evt . getSource ( ) ; JFrame frame = ( JFrame ) SwingUtilities . getRoot ( component ) ; JOptionPane . showMessageDialog ( frame , "Please select one field for update!" , "Warning" , JOptionPane . WARNING_MESSAGE ) ; } if ( double . isNaN ( double . parseDouble ( value ) ) ) { Component component = ( Component ) evt . getSource ( ) ; JFrame frame = ( JFrame ) SwingUtilities . getRoot ( component ) ; JOptionPane . showMessageDialog ( frame , "Please input a valid number!" , "Warning" , JOptionPane . WARNING_MESSAGE ) ; } else { DataManipulationUtilities . updateRecords ( region , field , value ) ; dispose ( ) ; } }
va	3	public static void main ( String [ ] args ) { try { SearchEngine . parseCommandLine ( args ) ; checkParameters ( ) ; switch ( SearchEngine . MODE ) { case INDEX : startIndexing ( ) ; break ; case SERVE : startServing ( ) ; break ; default : _logger . error ( "Wrong mode for SearchEngine!" ) ; } } catch ( Exception e ) { _logger . error ( e . getMessage ( ) , e ) ; } }
va	9	private HttpURLConnection getConnection ( String url ) throws IOException { HttpURLConnection con = null ; if ( proxyHost != null && ! proxyHost . equals ( "" ) ) { if ( proxyAuthUser != null && ! proxyAuthUser . equals ( "" ) ) { log ( "Proxy AuthUser: " + proxyAuthUser ) ; log ( "Proxy AuthPassword: " + proxyAuthPassword ) ; Authenticator . setDefault ( new Authenticator ( ) { @ Override protected PasswordAuthentication getPasswordAuthentication ( ) { if ( getRequestorType ( ) . equals ( RequestorType . PROXY ) ) { return new PasswordAuthentication ( proxyAuthUser , proxyAuthPassword . toCharArray ( ) ) ; } else { return null ; } } } ) ; } final Proxy proxy = new Proxy ( Type . HTTP , InetSocketAddress . createUnresolved ( proxyHost , proxyPort ) ) ; if ( DEBUG ) { log ( "Opening proxied connection(" + proxyHost + ":" + proxyPort + ")" ) ; } con = ( HttpURLConnection ) new URL ( url ) . openConnection ( proxy ) ; } else { con = ( HttpURLConnection ) new URL ( url ) . openConnection ( ) ; } if ( connectionTimeout > 0 && ! isJDK14orEarlier ) { con . setConnectTimeout ( connectionTimeout ) ; } if ( readTimeout > 0 && ! isJDK14orEarlier ) { con . setReadTimeout ( readTimeout ) ; } return con ; }
va	4	public int modify ( String relation , String [ ] constrains , String ... modifications ) { int itWorked = - 1 ; Statement statement = null ; String where = whereCreator ( constrains ) ; String set = setCreator ( modifications ) ; if ( set . equals ( "" ) ) { return - 2 ; } try { statement = db . createStatement ( ) ; String query = "UPDATE " + relation + " " + set + " " + where + ";" ; System . out . println ( query ) ; itWorked = statement . executeUpdate ( query ) ; } catch ( SQLException e ) { } finally { if ( statement != null ) { try { statement . close ( ) ; } catch ( SQLException e ) { } } } return itWorked ; }
va	1	private void addList ( List < Integer > scores ) { for ( int i = 0 ; i < teamList . size ( ) ; i ++ ) { JLabel lblTeam = new JLabel ( teamList . get ( i ) ) ; centerZone . add ( lblTeam ) ; JLabel lblScore = new JLabel ( scores . get ( i ) . toString ( ) ) ; eastZone . add ( lblScore ) ; } }
va	2	private static byte [ ] constructorHelper ( byte color , int ... indexes ) { byte [ ] colors = new byte [ ValueDefinitions . VALUE_COUNT_MAX ] ; for ( int i = 0 ; i < ValueDefinitions . VALUE_COUNT_MAX ; ++ i ) { colors [ i ] = Colors . BAR_DEFAULT ; } for ( int index : indexes ) colors [ index ] = color ; return colors ; }
va	5	public void act ( List < Actor > newRabbits ) { if ( isZiek ) { timeToDie -- ; if ( timeToDie < 0 ) { setDead ( ) ; } } incrementAge ( ) ; if ( isAlive ( ) ) { giveBirth ( newRabbits ) ; if ( isZiek ) { Location location = getLocation ( ) ; Location newLocation = besmetKonijntjes ( location ) ; } Location newLocation = getField ( ) . freeAdjacentLocation ( getLocation ( ) ) ; if ( newLocation != null ) { setLocation ( newLocation ) ; } else { setDead ( ) ; } } }
va	6	public void decreaseKey ( Position < T > pos , T newVal ) { if ( pos == null ) throw new IllegalArgumentException ( "null Position passed to decreaseKey" ) ; PairNode < T > p = ( PairNode < T > ) pos ; if ( p . element == null ) throw new IllegalArgumentException ( "pos already deleted" ) ; if ( p . element . compareTo ( newVal ) < 0 ) throw new IllegalArgumentException ( "newVal/oldval: " + newVal + " /" + p . element ) ; p . element = newVal ; if ( p != root ) { if ( p . nextSibling != null ) p . nextSibling . prev = p . prev ; if ( p . prev . leftChild == p ) p . prev . leftChild = p . nextSibling ; else p . prev . nextSibling = p . nextSibling ; p . nextSibling = null ; root = compareAndLink ( root , p ) ; } }
va	4	private String getNextLine ( ) throws IOException { if ( ! this . linesSkiped ) { for ( int i = 0 ; i < skipLines ; i ++ ) { br . readLine ( ) ; } this . linesSkiped = true ; } String nextLine = br . readLine ( ) ; if ( nextLine == null ) { hasNext = false ; } return hasNext ? nextLine : null ; }
va	3	public T last ( UnaryFunction < T , boolean > predicate ) { boolean hasResult = false ; T result = null ; while ( hasNext ( ) ) { final T value = next ( ) ; if ( predicate . invoke ( value ) ) { hasResult = true ; result = value ; } } if ( ! hasResult ) { throw new NoSuchElementException ( ) ; } return result ; }
va	7	public void equipArmour ( ) { String [ ] playerItems = player . getInventory ( ) . getArmourTexts ( ) ; if ( playerItems . length == 0 ) { log . println ( "You have nothing to put on." ) ; } else { JPanel panel = new JPanel ( ) ; panel . setLayout ( new GridLayout ( 0 , 1 ) ) ; final JRadioButton [ ] radioButtons = new JRadioButton [ playerItems . length ] ; final String idsString = descriptionsToIDString ( playerItems ) ; ButtonGroup buttons = new ButtonGroup ( ) ; Action charAction = new AbstractAction ( ) { public void actionPerformed ( ActionEvent e ) { int index = idsString . indexOf ( e . getActionCommand ( ) ) ; if ( index != - 1 ) { JRadioButton button = radioButtons [ index ] ; button . setSelected ( ! button . isSelected ( ) ) ; } else { println ( e . getActionCommand ( ) + " is not a valid ID  do you have capslock on?" ) ; } } } ; int itemCount = 0 ; panel . add ( new JLabel ( "INVENTORY" ) ) ; for ( String f : playerItems ) { JRadioButton newButton = new JRadioButton ( f ) ; newButton . getInputMap ( JComponent . WHEN_IN_FOCUSED_WINDOW ) . put ( KeyStroke . getKeyStroke ( idsString . substring ( itemCount , itemCount + 1 ) . toUpperCase ( ) ) , f ) ; newButton . getActionMap ( ) . put ( f , charAction ) ; radioButtons [ itemCount ] = newButton ; panel . add ( newButton ) ; itemCount ++ ; } JOptionPane . showMessageDialog ( null , panel , "What would you like to put on?" , JOptionPane . PLAIN_MESSAGE ) ; for ( JRadioButton button : radioButtons ) { if ( button . isSelected ( ) ) { Character id = button . getText ( ) . charAt ( 0 ) ; Armour armour ; armour = ( Armour ) player . getInventory ( ) . getItem ( id ) ; if ( player . getEquippedArmour ( ) != null ) { if ( ! player . getEquippedArmour ( ) . equals ( armour ) ) { unequipArmour ( ) ; println ( "You put on the " + armour . properName ( ) ) ; } else { println ( "You've already put on the " + armour . properName ( ) ) ; } } else { println ( "You put on the " + armour . properName ( ) ) ; } player . setEquippedArmour ( armour ) ; } } } }
va	6	@ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( ! ( o instanceof Symbol ) ) return false ; Symbol symbol = ( Symbol ) o ; if ( bitMaskValue != symbol . bitMaskValue ) return false ; if ( id != symbol . id ) return false ; if ( name != null ? ! name . equals ( symbol . name ) : symbol . name != null ) return false ; return true ; }
va	8	public void sendToServer ( final File fileToSend , final boolean isDirectory ) { new Thread ( ) { @ Override public void run ( ) { try { boolean haveToShowDialog = false ; boolean appendFile = false ; for ( FTPFile f : ftpFiles ) { if ( fileToSend . getName ( ) . equals ( f . getFilename ( ) ) ) haveToShowDialog = true ; } if ( haveToShowDialog ) { Object [ ] options = { "Overwrite" , "Append" , "Cancel" } ; int n = JOptionPane . showOptionDialog ( frmFtpClient , "File already exists" , "A Silly Question" , JOptionPane . YES_NO_CANCEL_OPTION , JOptionPane . QUESTION_MESSAGE , null , options , options [ 2 ] ) ; if ( n == 2 ) return ; if ( n == 1 ) appendFile = true ; } if ( isDirectory ) serverConnect . sendDirectory ( fileToSend ) ; else { if ( appendFile ) serverConnect . sendFile ( fileToSend , false ) ; else serverConnect . sendFile ( fileToSend , true ) ; } refreshFTPDirectory ( ) ; } catch ( IOException | ConnectionException e ) { throwException ( e ) ; } } } . start ( ) ; }
va	7	@ Override public int read ( byte [ ] output , int offset , int size ) throws IOException { int bytesRead = 0 ; int destOffset = offset ; int bytesToCopy ; int ret ; while ( bytesRead < size ) { if ( ( blockBuf == null ) || ( bufCursor == ( blockBuf . length ) ) ) { try { ret = readBlock ( ) ; } catch ( EncFSCorruptDataException e ) { throw new IOException ( e ) ; } catch ( EncFSUnsupportedException e ) { throw new IOException ( e ) ; } if ( ret < 0 ) { if ( bytesRead == 0 ) { return - 1 ; } else { return bytesRead ; } } } bytesToCopy = Math . min ( blockBuf . length - bufCursor , size - bytesRead ) ; System . arraycopy ( blockBuf , bufCursor , output , destOffset , bytesToCopy ) ; bufCursor += bytesToCopy ; bytesRead += bytesToCopy ; destOffset += bytesToCopy ; } return bytesRead ; }
va	1	private void die ( ) { dead = true ; Clock . createTimer ( 2000 , new Functor ( ) { @ Override public void execute ( ) { if ( ( ( Player ) modify ) . getContainer ( ) != null ) { ( ( Player ) modify ) . getContainer ( ) . dropItems ( ) ; } modify . getLevel ( ) . removeMember ( modify ) ; } @ Override public void execute ( Object o ) { } } ) ; }
va	3	public static String relativePrefix ( String name ) { if ( name == null ) { return "" ; } String res = "" ; if ( name != null ) { int c = countOccurrences ( name , / ) ; for ( int i = 0 ; i < c ; i ++ ) { res = "../" + res ; } } return res ; }
va	9	public Data retriveData ( int i , int j ) { Node mover = start ; if ( j < 0 ) { while ( mover . getCol ( ) != j ) { mover = mover . getPrev ( ) ; } } else { while ( mover . getCol ( ) != j ) { mover = mover . getNext ( ) ; } } if ( i < 0 ) { do { mover = mover . getUp ( ) ; } while ( mover . getRow ( ) != i && mover . getRow ( ) != 0 ) ; } else { do { mover = mover . getDown ( ) ; } while ( mover . getRow ( ) != i && mover . getRow ( ) != 0 ) ; } if ( mover . getRow ( ) == i && mover . getCol ( ) == j ) { return ( Data ) mover . getData ( ) ; } return null ; }
va	5	public void run ( ) { int currCmd = 0 ; long prevTicks = System . currentTimeMillis ( ) ; while ( currCmd != DIE ) { boolean update = false ; synchronized ( cmd ) { currCmd = cmd . getArg ( 0 ) ; switch ( currCmd ) { case RUN : panel . evolve ( ) ; update = ( System . currentTimeMillis ( ) - prevTicks > 150 ) ; break ; case STEP : panel . evolve ( ) ; update = true ; cmd . setArg ( 0 , 0 ) ; break ; } } if ( update ) { prevTicks = System . currentTimeMillis ( ) ; panel . updateDisplay ( ) ; } if ( currCmd != RUN ) cmd . sleep ( 100 ) ; } }
va	6	public int [ ] twoSum ( int [ ] numbers , int target ) { HashMap < Integer , List < Integer >> indices = new HashMap < Integer , List < Integer >> ( ) ; for ( int i = 0 ; i < numbers . length ; i ++ ) { if ( indices . containsKey ( numbers [ i ] ) ) { indices . get ( numbers [ i ] ) . add ( i + 1 ) ; } else { List < Integer > newList = new ArrayList < Integer > ( ) ; newList . add ( i + 1 ) ; indices . put ( numbers [ i ] , newList ) ; } } Arrays . sort ( numbers ) ; int i = 0 ; int j = numbers . length - 1 ; while ( i < j ) { if ( numbers [ i ] + numbers [ j ] < target ) { i ++ ; } else if ( numbers [ i ] + numbers [ j ] > target ) { j -- ; } else { int oldIndex1 = indices . get ( numbers [ i ] ) . get ( 0 ) ; List < Integer > oldIndexList = indices . get ( numbers [ j ] ) ; int oldIndex2 = oldIndexList . get ( oldIndexList . size ( ) - 1 ) ; if ( oldIndex1 < oldIndex2 ) { return new int [ ] { oldIndex1 , oldIndex2 } ; } else { return new int [ ] { oldIndex2 , oldIndex1 } ; } } } return new int [ 0 ] ; }
va	0	public Vat ( Integer vatId ) { this . vatId = vatId ; }
va	2	public List < Position > getPositions ( ) { List < Position > positions = new ArrayList < Position > ( ) ; positions . add ( getPosition ( ) ) ; for ( int i = 1 ; i <= getLength ( ) ; i ++ ) { Position pos = null ; if ( getDirection ( ) == Direction . HORIZONTAL ) { pos = new Position ( getPosition ( ) . getxCoordinate ( ) + i , getPosition ( ) . getyCoordinate ( ) ) ; } else { pos = new Position ( getPosition ( ) . getxCoordinate ( ) , getPosition ( ) . getyCoordinate ( ) + i ) ; } positions . add ( pos ) ; } return positions ; }
va	2	@ Override public CodeFragment visitVar_def ( MagicParser . Var_defContext ctx ) { CodeFragment code = new CodeFragment ( ) ; Type type = visit ( ctx . type ( ) ) . getType ( ) ; String id = ctx . ID ( ) . getText ( ) ; MagicParser . ExpressionContext exp = ctx . expression ( ) ; CodeFragment var_code = declVar ( id , type , new CodePosition ( ctx ) ) ; code . addCode ( var_code ) ; code . setRegister ( var_code . getRegister ( ) ) ; code . setType ( var_code . getType ( ) ) ; CodeFragment val ; Variable var = getVar ( id , new CodePosition ( ctx ) ) ; if ( exp != null ) { val = visit ( exp ) ; } else { if ( var . getType ( ) instanceof ListType ) { val = generateListConstant ( ( ( ListType ) var . getType ( ) ) . getSubtype ( ) , new ArgListCodeFragment ( ) ) ; } else { val = generateConstant ( var . getType ( ) , var . getType ( ) . getDefaultValue ( ) ) ; } } CodeFragment assign = generateAssignCode ( var , val , new CodePosition ( ctx ) ) ; code . appendCodeFragment ( assign ) ; return code ; }
va	3	private void calcTangents ( Vertex [ ] vertices , int [ ] indices ) { for ( int i = 0 ; i < indices . length ; i += 3 ) { int i0 = indices [ i ] ; int i1 = indices [ i + 1 ] ; int i2 = indices [ i + 2 ] ; Vector3f edge1 = vertices [ i1 ] . getPos ( ) . - ( vertices [ i0 ] . getPos ( ) ) ; Vector3f edge2 = vertices [ i2 ] . getPos ( ) . - ( vertices [ i0 ] . getPos ( ) ) ; float deltaU1 = vertices [ i1 ] . getTexCoord ( ) . getX ( ) - vertices [ i0 ] . getTexCoord ( ) . getX ( ) ; float deltaV1 = vertices [ i1 ] . getTexCoord ( ) . getY ( ) - vertices [ i0 ] . getTexCoord ( ) . getY ( ) ; float deltaU2 = vertices [ i2 ] . getTexCoord ( ) . getX ( ) - vertices [ i0 ] . getTexCoord ( ) . getX ( ) ; float deltaV2 = vertices [ i2 ] . getTexCoord ( ) . getY ( ) - vertices [ i0 ] . getTexCoord ( ) . getY ( ) ; float fDividend = ( deltaU1 * deltaV2 - deltaU2 * deltaV1 ) ; float f = fDividend == 0 ? 0.1f : 1.0f / fDividend ; Vector3f tangent = new Vector3f ( 0 , 0 , 0 ) ; tangent . setX ( f * ( deltaV2 * edge1 . getX ( ) - deltaV1 * edge2 . getX ( ) ) ) ; tangent . setY ( f * ( deltaV2 * edge1 . getY ( ) - deltaV1 * edge2 . getY ( ) ) ) ; tangent . setZ ( f * ( deltaV2 * edge1 . getZ ( ) - deltaV1 * edge2 . getZ ( ) ) ) ; vertices [ i0 ] . getTangent ( ) . set ( tangent ) ; vertices [ i1 ] . getTangent ( ) . set ( tangent ) ; vertices [ i2 ] . getTangent ( ) . set ( tangent ) ; } for ( int i = 0 ; i < vertices . length ; i ++ ) vertices [ i ] . getTangent ( ) . set ( vertices [ i ] . getTangent ( ) . normalized ( ) ) ; }
va	0	public SimpleResponseBody ( ) { }
va	4	public void setLogFile ( File f ) { String fName = f . getName ( ) + "-" + new SimpleDateFormat ( "MMM-dd-EEE.hh-mm-ss" ) . format ( new Date ( ) ) + fileExtension ; f = new File ( f . getParent ( ) + System . getProperty ( "file.separator" ) + fName ) ; logFile = f ; if ( ! f . exists ( ) ) try { if ( ! f . getParentFile ( ) . exists ( ) ) f . getParentFile ( ) . mkdirs ( ) ; f . createNewFile ( ) ; } catch ( IOException e ) { System . err . println ( "Error creating new logfile" ) ; e . printStackTrace ( ) ; } try { wr = new BufferedWriter ( new FileWriter ( f ) ) ; } catch ( IOException e ) { System . err . println ( "Failed to open log file for writing" ) ; e . printStackTrace ( ) ; } }
va	0	public void setPlotWidth ( float plotWidth ) { this . plotWidth = plotWidth ; }
va	4	public terminal_set check_first_set ( ) throws internal_error { int part ; symbol sym ; for ( part = 0 ; part < rhs_length ( ) ; part ++ ) { if ( ! rhs ( part ) . is_action ( ) ) { sym = ( ( symbol_part ) rhs ( part ) ) . the_symbol ( ) ; if ( sym . is_non_term ( ) ) { _first_set . add ( ( ( non_terminal ) sym ) . first_set ( ) ) ; if ( ! ( ( non_terminal ) sym ) . nullable ( ) ) break ; } else { _first_set . add ( ( terminal ) sym ) ; break ; } } } return first_set ( ) ; }
va	9	WavInputStream ( FileHandle file ) { super ( file . read ( ) ) ; try { if ( read ( ) != R || read ( ) != I || read ( ) != F || read ( ) != F ) { throw new GdxRuntimeException ( "RIFF header not found: " + file ) ; } skipFully ( 4 ) ; if ( read ( ) != W || read ( ) != A || read ( ) != V || read ( ) != E ) { throw new GdxRuntimeException ( "Invalid wave file header: " + file ) ; } int fmtChunkLength = seekToChunk ( f , m , t ,   ) ; int type = read ( ) & ff | ( read ( ) & ff ) << 8 ; if ( type != 1 ) { throw new GdxRuntimeException ( "WAV files must be PCM: " + type ) ; } channels = read ( ) & ff | ( read ( ) & ff ) << 8 ; if ( channels != 1 && channels != 2 ) { throw new GdxRuntimeException ( "WAV files must have 1 or 2 channels: " + channels ) ; } sampleRate = read ( ) & ff | ( read ( ) & ff ) << 8 | ( read ( ) & ff ) << 16 | ( read ( ) & ff ) << 24 ; skipFully ( 6 ) ; int bitsPerSample = read ( ) & ff | ( read ( ) & ff ) << 8 ; if ( bitsPerSample != 16 ) { throw new GdxRuntimeException ( "WAV files must have 16 bits per sample: " + bitsPerSample ) ; } skipFully ( fmtChunkLength - 16 ) ; dataRemaining = seekToChunk ( d , a , t , a ) ; } catch ( Throwable ex ) { StreamUtils . closeQuietly ( this ) ; throw new GdxRuntimeException ( "Error reading WAV file: " + file , ex ) ; } }
va	2	public static boolean is_valid ( String text ) { if ( text . length ( ) <= 25 ) { return false ; } if ( text . length ( ) % 25 == 0 ) return true ; else { return false ; } }
va	6	@ Override public void actionPerformed ( ActionEvent e ) { JFileChooser c = new JFileChooser ( ) ; if ( newWorkspace != null ) c . setCurrentDirectory ( newWorkspace ) ; else if ( settings . hasWorkspace ( ) && settings . getEvaluator ( ) . getWorkspace ( ) != null ) c . setCurrentDirectory ( evaluator . getWorkspace ( ) ) ; c . setFileFilter ( new GenericFileFilter ( settings . getFileExtention ( ) , settings . getLanguageName ( ) , true ) ) ; int rVal = c . showOpenDialog ( frame ) ; if ( rVal == JFileChooser . APPROVE_OPTION ) { String file = c . getSelectedFile ( ) . getAbsolutePath ( ) ; if ( imported . contains ( file ) ) return ; addedImports . add ( file ) ; if ( ok != null ) { container . remove ( ok ) ; container . remove ( cancel ) ; } createImportAdressField ( file , 2 + imported . size ( ) ) ; createOkCancelButtons ( 2 + imported . size ( ) + 1 ) ; container . invalidate ( ) ; container . repaint ( ) ; frame . pack ( ) ; } }
va	9	@ Override public void actionPerformed ( ActionEvent arg0 ) { if ( arg0 . getSource ( ) == this . laden ) { JFileChooser fileChooser = new JFileChooser ( ) ; File f = new File ( Main . class . getResource ( "/ressources/maps/" ) . getPath ( ) ) ; fileChooser . setCurrentDirectory ( f ) ; int returnVal = fileChooser . showOpenDialog ( this . editorframe ) ; if ( returnVal == JFileChooser . APPROVE_OPTION ) { this . loadMap ( fileChooser . getSelectedFile ( ) . getName ( ) ) ; } } if ( arg0 . getSource ( ) == this . speichern ) { JFileChooser fileChooser = new JFileChooser ( ) ; File f = new File ( Main . class . getResource ( "/ressources/maps/" ) . getPath ( ) ) ; fileChooser . setCurrentDirectory ( f ) ; int returnVal = fileChooser . showSaveDialog ( this . editorframe ) ; if ( returnVal == JFileChooser . APPROVE_OPTION ) { this . saveMap ( ) ; } if ( arg0 . getSource ( ) == this . neu ) { this . loadMap ( "Map1" ) ; } if ( arg0 . getSource ( ) == this . unbreakable ) { this . element = 2 ; } if ( arg0 . getSource ( ) == this . breakable ) { this . element = 1 ; } if ( arg0 . getSource ( ) == this . player ) { this . element = 3 ; } if ( arg0 . getSource ( ) == this . empty ) { this . element = 0 ; } if ( arg0 . getSource ( ) == this . finish ) { this . element = 4 ; } } }
va	2	public String sendMessageWaitResponse ( String message ) throws InterruptedException { waitingForResponse = true ; timeout = new Timer ( ( int ) TIME_OUT_WAIT , new ActionListener ( ) { public void actionPerformed ( ActionEvent arg0 ) { if ( waitingForResponse ) { response = JabriscaModel . WAIT_TIME_OUT + "@" ; waitingForResponse = false ; } timeout . stop ( ) ; } } ) ; timeout . start ( ) ; while ( waitingForResponse ) { Thread . currentThread ( ) . sleep ( TIME_OUT_WAIT / 4 ) ; out . println ( message ) ; } timeout . stop ( ) ; return response ; }
va	4	public Object [ ] nextRecord ( ) throws JDBFException { if ( ! hasNextRecord ( ) ) throw new JDBFException ( "No more records available." ) ; Object aobj [ ] = new Object [ nFieldCount ] ; int i = 1 ; for ( int j = 0 ; j < aobj . length ; j ++ ) { int k = fields [ j ] . getLength ( ) ; StringBuffer stringbuffer = new StringBuffer ( k ) ; stringbuffer . append ( new String ( nextRecord , i , k ) ) ; aobj [ j ] = fields [ j ] . parse ( stringbuffer . toString ( ) ) ; i += fields [ j ] . getLength ( ) ; } try { stream . readFully ( nextRecord ) ; } catch ( EOFException eofexception ) { nextRecord = null ; } catch ( IOException ioexception ) { throw new JDBFException ( ioexception ) ; } return aobj ; }
va	3	public Block chooseBlock ( int posX , int posY ) { surfaceModifier = chunkBuffer [ 1 ] . surfaceModifRegister [ posX ] + const . tailleChunkY ; surfaceModifRegister [ posX ] = chunkBuffer [ 1 ] . surfaceModifRegister [ posX ] + const . tailleChunkY ; int a = rand . nextInt ( 2 ) ; if ( posY == surfaceModifier || posY == surfaceModifier - a ) { return Block . sand ; } else if ( posY > surfaceModifier ) { return Block . water ; } return Block . stone ; }
va	1	@ Override public String getFormalName ( ) { String expression = "" ; if ( this . name != null ) { expression = this . getId ( ) ; } else { CommandPanel . logger . warning ( "Element's name is null! Type:" + this . type + " " + this . Id ) ; return "null" ; } expression = Func . prepareFormalExpression ( expression ) ; return expression ; }
va	1	public static DBHandler getInstance ( ) { if ( instance == null ) instance = new DBHandler ( ) ; return DBHandler . instance ; }
va	9	private void initPanels ( ArrayList < JavaFestivalPlayer > festivalPlayers , int currentPlayerIndex , String festivalHashKey ) { centerPanel = new JPanel ( ) ; centerPanel . setPreferredSize ( new Dimension ( 560 , 560 ) ) ; centerPanel . setLayout ( new BorderLayout ( ) ) ; centerPanel . setBackground ( new Color ( 61 , 114 , 15 ) ) ; add ( centerPanel , BorderLayout . CENTER ) ; JLabel festivalCard = palaceLabel ( imageSourceHashMap . get ( "label_" + festivalHashKey ) ) ; festivalCard . setBorder ( BorderFactory . createEmptyBorder ( 0 , 125 , 0 , 125 ) ) ; centerPanel . add ( festivalCard , BorderLayout . CENTER ) ; int size = festivalPlayers . size ( ) ; players = new ArrayList < HoldFestivalPlayerPanel > ( size ) ; playedCardsPanels = new JPanel [ 4 ] ; for ( int i = 0 ; i < size ; ++ i ) { players . add ( new HoldFestivalPlayerPanel ( this , i , festivalPlayers . get ( i ) . getName ( ) , festivalPlayers . get ( i ) . getColor ( ) , festivalPlayers . get ( i ) . getNumPalaceCards ( ) , imageSourceHashMap ) ) ; if ( i == 0 ) { playedCardsPanels [ i ] = new JPanel ( ) ; add ( players . get ( i ) , BorderLayout . NORTH ) ; playedCardsPanels [ i ] . setPreferredSize ( new Dimension ( 500 , 120 ) ) ; centerPanel . add ( playedCardsPanels [ i ] , BorderLayout . NORTH ) ; playedCardsPanels [ i ] . setBackground ( new Color ( 79 , 148 , 19 ) ) ; } else if ( i == 1 ) { playedCardsPanels [ i ] = new JPanel ( ) ; add ( players . get ( i ) , BorderLayout . EAST ) ; playedCardsPanels [ i ] . setPreferredSize ( new Dimension ( 120 , 500 ) ) ; centerPanel . add ( playedCardsPanels [ i ] , BorderLayout . EAST ) ; playedCardsPanels [ i ] . setBackground ( new Color ( 79 , 148 , 19 ) ) ; } else if ( i == 2 ) { playedCardsPanels [ i ] = new JPanel ( ) ; add ( players . get ( i ) , BorderLayout . SOUTH ) ; playedCardsPanels [ i ] . setPreferredSize ( new Dimension ( 500 , 120 ) ) ; centerPanel . add ( playedCardsPanels [ i ] , BorderLayout . SOUTH ) ; playedCardsPanels [ i ] . setBackground ( new Color ( 79 , 148 , 19 ) ) ; } else if ( i == 3 ) { playedCardsPanels [ i ] = new JPanel ( ) ; add ( players . get ( i ) , BorderLayout . WEST ) ; playedCardsPanels [ i ] . setPreferredSize ( new Dimension ( 120 , 500 ) ) ; centerPanel . add ( playedCardsPanels [ i ] , BorderLayout . WEST ) ; playedCardsPanels [ i ] . setBackground ( new Color ( 79 , 148 , 19 ) ) ; } } if ( size < 4 ) { for ( int i = 1 ; i < 4 ; i ++ ) { if ( playedCardsPanels [ i ] == null ) { JPanel emptyPlayer = new HoldFestivalPlayerPanel ( i ) ; playedCardsPanels [ i ] = new JPanel ( ) ; if ( i == 1 ) { add ( emptyPlayer , BorderLayout . EAST ) ; playedCardsPanels [ i ] . setPreferredSize ( new Dimension ( 120 , 500 ) ) ; centerPanel . add ( playedCardsPanels [ i ] , BorderLayout . EAST ) ; } else if ( i == 2 ) { add ( emptyPlayer , BorderLayout . SOUTH ) ; playedCardsPanels [ i ] . setPreferredSize ( new Dimension ( 500 , 120 ) ) ; centerPanel . add ( playedCardsPanels [ i ] , BorderLayout . SOUTH ) ; } else { add ( emptyPlayer , BorderLayout . WEST ) ; playedCardsPanels [ i ] . setPreferredSize ( new Dimension ( 120 , 500 ) ) ; centerPanel . add ( playedCardsPanels [ i ] , BorderLayout . WEST ) ; } playedCardsPanels [ i ] . setBackground ( new Color ( 79 , 148 , 19 ) ) ; } } } if ( currentPlayerIndex > - 1 ) players . get ( currentPlayerIndex ) . setCurrentPlayer ( ) ; else { System . out . println ( "cannot start festival" ) ; } }
va	3	public Rabbit ( boolean randomAge , Field field , Location location ) { super ( field , location ) ; if ( randomAge ) { setAge ( rand . nextInt ( MAX_AGE ) ) ; } else { setAge ( 0 ) ; } Random generator = new Random ( ) ; if ( ( generator . nextInt ( 100 ) + 1 ) < populatieDeel ) { ziekteGen = true ; if ( generator . nextDouble ( ) < rabbit_sickness_probability ) { setZiek ( ) ; } } else { ziekteGen = false ; } }
va	9	@ Override protected void paintComponent ( Graphics g ) { super . paintComponent ( g ) ; updateFogOfWar ( 2 ) ; for ( int y = 0 ; y < visibleHeight ; y ++ ) { for ( int x = 0 ; x < visibleWidth ; x ++ ) { if ( area . isInArea ( x + panelOrigin . getX ( ) , y + panelOrigin . getY ( ) ) ) { DungeonTile tile = area . selectTile ( x , y , panelOrigin ) ; if ( ! tile . isWasSeenByPlayer ( ) ) { draw ( g , x , y ) ; } else { switch ( tile . getTileType ( ) ) { case OpenedDoor : drawImage ( g , x , y , TileImages . getImageFor ( Empty ) ) ; case Wall : case Entry : case Empty : case ClosedDoor : default : drawImage ( g , x , y , TileImages . getImageFor ( tile . getTileType ( ) ) ) ; } if ( area . selectContentAt ( x , y , panelOrigin ) != null ) { Iterator < Item > i = tile . getTileContent ( ) . iterator ( ) ; while ( i . hasNext ( ) ) { Item item = i . next ( ) ; if ( item instanceof ItemContainer ) { drawImage ( g , x , y , images . getChestImg ( ) ) ; } } } } } else { draw ( g , x , y ) ; } } drawPlayer ( g ) ; } }
va	1	private void buttonDownActionPerformed ( java . awt . event . ActionEvent evt ) { int index = listFiles . getSelectedIndex ( ) ; if ( index < listFiles . getItemCount ( ) - 1 ) { listFiles . add ( listFiles . getItem ( index ) , index + 2 ) ; listFiles . remove ( index ) ; listFiles . select ( index + 1 ) ; } }
va	4	public static void moveBeforeTable ( Node row , Node node , TagTable tt ) { Node table ; for ( table = row . parent ; table != null ; table = table . parent ) { if ( table . tag == tt . tagTable ) { if ( table . parent . content == table ) table . parent . content = node ; node . prev = table . prev ; node . next = table ; table . prev = node ; node . parent = table . parent ; if ( node . prev != null ) node . prev . next = node ; break ; } } }
va	3	public void load ( String fileName ) { try { InputStream file = new FileInputStream ( fileName ) ; InputStream buffer = new BufferedInputStream ( file ) ; ObjectInput input = new ObjectInputStream ( buffer ) ; GameData gd = ( GameData ) input . readObject ( ) ; input . close ( ) ; buffer . close ( ) ; file . close ( ) ; init ( ) ; map . setData ( gd ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } catch ( ClassNotFoundException e ) { e . printStackTrace ( ) ; } }
va	6	private void createNodes ( ) { nodeKategorie = new DefaultMutableTreeNode [ 9 ] ; top = new DefaultMutableTreeNode ( "Quiz" ) ; int kategorieMax = - 1 ; int id = 0 ; for ( int i = 0 ; i < mc . questionList . size ( ) ; i ++ ) { id = Integer . parseInt ( mc . questionList . get ( i ) . get ( "id" ) ) ; int kat = ( ( int ) ( ( id % 10000 ) / 1000 ) ) ; if ( kat > kategorieMax || i == 0 ) { kategorieMax = kat ; } if ( nodeKategorie [ kat ] == null ) nodeKategorie [ kat ] = new DefaultMutableTreeNode ( "Kategorie " + kat ) ; DefaultMutableTreeNode quest = new DefaultMutableTreeNode ( ) ; quest . setUserObject ( id ) ; nodeKategorie [ kat ] . add ( quest ) ; } for ( int i = 0 ; i <= kategorieMax ; i ++ ) { if ( nodeKategorie [ i ] != null ) { top . add ( nodeKategorie [ i ] ) ; } } }
va	0	Context ( String originalText , Position position ) { this . originalText = originalText ; this . position = position ; }
va	2	public Object getValueAt ( int row , int col ) { int i = ( ( 7 * row ) + ( col + 1 ) - offset ) ; return ( i <= days && i > 0 ) ? i : null ; }
va	0	public int process_id ( ) { return 2 ; }
va	1	public static Field [ ] getAllFields ( class c ) { List < Field > fields = new ArrayList < Field > ( ) ; while ( c != Object . class ) { List < Field > classFields = new ArrayList < Field > ( Arrays . asList ( c . getDeclaredFields ( ) ) ) ; Collections . reverse ( classFields ) ; fields . addAll ( classFields ) ; c = c . getSuperclass ( ) ; } Collections . reverse ( fields ) ; return fields . toArray ( new Field [ 0 ] ) ; }
va	5	public Option getOptionByLongName ( String string ) { for ( Option option : this . options ) { if ( option . isLongNameCaseSensitive ( ) && option . getLongName ( ) . equals ( string ) ) return option ; else if ( ! option . isLongNameCaseSensitive ( ) && option . getLongName ( ) . equalsIgnoreCase ( string ) ) return option ; } return null ; }
va	8	public IndexedModel toIndexedModel ( ) { IndexedModel result = new IndexedModel ( ) ; IndexedModel normalModel = new IndexedModel ( ) ; HashMap < OBJIndex , Integer > resultIndexMap = new HashMap < OBJIndex , Integer > ( ) ; HashMap < Integer , Integer > normalIndexMap = new HashMap < Integer , Integer > ( ) ; HashMap < Integer , Integer > indexMap = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < indices . size ( ) ; i ++ ) { OBJIndex currentIndex = indices . get ( i ) ; Vector3f currentPosition = positions . get ( currentIndex . vertexIndex ) ; Vector2f currentTexCoord ; Vector3f currentNormal ; if ( hasTexCoords ) currentTexCoord = texCoords . get ( currentIndex . texCoordIndex ) ; else currentTexCoord = new Vector2f ( 0 , 0 ) ; if ( hasNormals ) currentNormal = normals . get ( currentIndex . normalIndex ) ; else currentNormal = new Vector3f ( 0 , 0 , 0 ) ; Integer modelVertexIndex = resultIndexMap . get ( currentIndex ) ; if ( modelVertexIndex == null ) { modelVertexIndex = result . getPositions ( ) . size ( ) ; resultIndexMap . put ( currentIndex , modelVertexIndex ) ; result . getPositions ( ) . add ( currentPosition ) ; result . getTexCoords ( ) . add ( currentTexCoord ) ; if ( hasNormals ) result . getNormals ( ) . add ( currentNormal ) ; } Integer normalModelIndex = normalIndexMap . get ( currentIndex . vertexIndex ) ; if ( normalModelIndex == null ) { normalModelIndex = normalModel . getPositions ( ) . size ( ) ; normalIndexMap . put ( currentIndex . vertexIndex , normalModelIndex ) ; normalModel . getPositions ( ) . add ( currentPosition ) ; normalModel . getTexCoords ( ) . add ( currentTexCoord ) ; normalModel . getNormals ( ) . add ( currentNormal ) ; } result . getIndices ( ) . add ( modelVertexIndex ) ; normalModel . getIndices ( ) . add ( normalModelIndex ) ; indexMap . put ( modelVertexIndex , normalModelIndex ) ; } if ( ! hasNormals ) { normalModel . calcNormals ( ) ; for ( int i = 0 ; i < result . getPositions ( ) . size ( ) ; i ++ ) result . getNormals ( ) . add ( normalModel . getNormals ( ) . get ( indexMap . get ( i ) ) ) ; } return result ; }
va	5	@ Override public Document nextDoc ( int docid ) { if ( terms . isEmpty ( ) ) { return null ; } while ( true ) { Set < Integer > docIds = new HashSet < Integer > ( ) ; for ( Term term : terms ) { docid = term . next ( docid ) ; if ( docid == - 1 ) { resetTerms ( ) ; return null ; } docIds . add ( docid ) ; docid -= 1 ; } if ( docIds . size ( ) == 1 ) { return corpus . getDocument ( docid + 1 ) ; } } }
va	1	public ColorRGB trace ( Scene scene , Jay jay ) { Hit hit = cast ( scene , jay ) ; if ( hit . isHit ( ) ) { return shade ( scene , jay , hit ) ; } return scene . getBackgroundColor ( ) ; }
va	6	private void process ( Node node ) { if ( node == null ) { return ; } String name = ( ( Element ) node ) . getTagName ( ) . trim ( ) ; if ( name . equals ( "distributions" ) ) { NodeList children = node . getChildNodes ( ) ; for ( int i = 0 ; i < children . getLength ( ) ; i ++ ) { Node child = children . item ( i ) ; process ( child ) ; } } else { NamedNodeMap attrs = node . getAttributes ( ) ; Node nType = attrs . getNamedItem ( "type" ) ; String type = nType . getNodeValue ( ) . trim ( ) ; if ( type . equals ( "constant" ) ) { processConstant ( name , node ) ; } else if ( type . equals ( "uniform" ) ) { processUniform ( name , node ) ; } else if ( type . equals ( "truncatednormal" ) ) { processTruncatedNormal ( name , node ) ; } } }
va	5	private Location findFood ( ) { Field field = getField ( ) ; List < Location > adjacent = field . adjacentLocations ( getLocation ( ) ) ; Iterator < Location > it = adjacent . iterator ( ) ; while ( it . hasNext ( ) ) { Location where = it . next ( ) ; Object animal = field . getObjectAt ( where ) ; if ( animal instanceof Rabbit ) { Rabbit rabbit = ( Rabbit ) animal ; if ( rabbit . isAlive ( ) ) { rabbit . setDead ( ) ; setFoodLevel ( RABBIT_FOOD_VALUE ) ; return where ; } } else if ( animal instanceof Fox ) { Fox fox = ( Fox ) animal ; if ( fox . isAlive ( ) ) { fox . setDead ( ) ; setFoodLevel ( FOX_FOOD_VALUE ) ; return where ; } } } return null ; }
va	9	public int uniquePathsWithObstacles ( int [ ] [ ] obstacleGrid ) { int m = obstacleGrid . length ; if ( m == 0 ) return 0 ; int n = obstacleGrid [ 0 ] . length ; int [ ] [ ] a = new int [ m ] [ n ] ; int i = 0 , j = 0 , left = 0 , right = 0 ; a [ 0 ] [ 0 ] = 1 ; for ( i = 1 ; i < m ; i ++ ) { if ( a [ i - 1 ] [ 0 ] == 1 && obstacleGrid [ i ] [ 0 ] != 1 ) a [ i ] [ 0 ] = 1 ; else a [ i ] [ 0 ] = 0 ; } for ( i = 1 ; i < n ; i ++ ) { if ( a [ 0 ] [ i - 1 ] == 1 && obstacleGrid [ 0 ] [ i ] != 1 ) a [ 0 ] [ i ] = 1 ; else a [ 0 ] [ i ] = 0 ; } for ( i = 1 ; i < m ; i ++ ) { for ( j = 1 ; j < n ; j ++ ) { if ( obstacleGrid [ i ] [ j ] == 1 ) { a [ i ] [ j ] = 0 ; continue ; } a [ i ] [ j ] = a [ i - 1 ] [ j ] + a [ i ] [ j - 1 ] ; } } return a [ m - 1 ] [ n - 1 ] ; }
va	0	public final void println ( boolean x ) { println ( "" + x ) ; }
va	6	public static void main ( String [ ] args ) { OdeskDBQueries q = new OdeskDBQueries ( ) ; q . connect ( ) ; HashMap < Integer , ArrayList < TextHolder >> hm ; int index = 0 ; System . out . println ( "Starting..." ) ; while ( true ) { if ( ( hm = q . getCoversByContractorByApplication ( ) ) . size ( ) > 0 ) { String insertString = "" ; index ++ ; for ( Entry < Integer , ArrayList < TextHolder >> contractoreEntry : hm . entrySet ( ) ) { int contractor = contractoreEntry . getKey ( ) ; UserUnigram uniLM = new UserUnigram ( ) ; for ( TextHolder coverHolder : contractoreEntry . getValue ( ) ) { String coverLetter = coverHolder . getText ( ) . get ( 0 ) ; ArrayList < String > words = uniLM . preProcess ( coverLetter , null ) ; if ( UserUnigram . wordCounter . size ( ) > 1 ) { double score = uniLM . computePerplexity ( words ) ; insertString += "('" + coverHolder . getApplication ( ) + "' '" + Math . round ( score ) + "' '" + contractor + "') " ; } else { insertString += "('" + coverHolder . getApplication ( ) + "' '" + - 1 + "' '" + contractor + "') " ; } uniLM . generateUnigramLM ( words ) ; } } if ( insertString . length ( ) > 0 ) q . insertScores ( insertString . substring ( 0 , insertString . length ( ) - 1 ) , "marios_application_cover_scores" ) ; System . out . println ( "Iteration " + index + " completed." ) ; } else break ; } }
va	8	private void getResponse ( ) throws IOException { byte [ ] b = new byte [ 4096 ] ; int off , val , endcode = 0 ; for ( off = 0 ; off < 4096 && endcode != 0d0a0d0a ; off ++ ) { if ( ( val = instream . read ( ) ) == - 1 ) break ; b [ off ] = ( byte ) val ; endcode <<= 8 ; endcode |= val ; } if ( endcode != 0d0a0d0a ) throw new IOException ( "HTTP response header not found." ) ; response = new String ( b , 0 , off ) ; String [ ] header = response . split ( "\r\n" ) ; if ( header . length < 1 ) throw new IOException ( "Illegal response header." ) ; StatusLine = header [ 0 ] ; parseStatusLine ( ) ; String [ ] pair ; for ( String line : header ) { pair = line . split ( ": " ) ; if ( pair . length == 2 ) map . put ( pair [ 0 ] , pair [ 1 ] ) ; } try { ContentLength = long . parseLong ( map . get ( "Content-Length" ) ) ; } catch ( NumberFormatException e ) { ContentLength = - 1 ; } }
va	2	public void setSender ( int id ) throws NetworkMessageException { if ( id < 0 || id > byte . MAX_VALUE ) { throw new NetworkMessageException ( "SenderID out of range" ) ; } data [ 1 ] = ( byte ) id ; }
va	4	public Impresion2 ( ) { initComponents ( ) ; BotEliminar . setEnabled ( false ) ; BotMod . setEnabled ( false ) ; BoxTipo . setEnabled ( false ) ; BloquearCampos ( false ) ; BotonesNuevo ( true ) ; desde . getDateEditor ( ) . setEnabled ( false ) ; hasta . getDateEditor ( ) . setEnabled ( false ) ; fecha . getDateEditor ( ) . setEnabled ( false ) ; tablaMovDefault = ( DefaultTableModel ) tablaGastos . getModel ( ) ; abrirBase ( ) ; LazyList < Categoria > categoriasBase = Categoria . findAll ( ) ; Iterator < Categoria > it = categoriasBase . iterator ( ) ; categorias . addItem ( "Todos" ) ; while ( it . hasNext ( ) ) { Categoria cate = it . next ( ) ; categorias . addItem ( cate . get ( "nombre" ) ) ; } categorias . setSelectedItem ( "Todos" ) ; Calendar cal = Calendar . getInstance ( ) ; Date date = cal . getTime ( ) ; date . setDate ( cal . getActualMinimum ( Calendar . DAY_OF_MONTH ) ) ; ; desde . setDate ( date ) ; Date dateH = cal . getTime ( ) ; dateH . setDate ( cal . getActualMaximum ( Calendar . DAY_OF_MONTH ) ) ; hasta . setDate ( dateH ) ; try { reporte = new ControladorJReport ( ( "contadora.jasper" ) ) ; } catch ( JRException ex ) { Logger . getLogger ( Impresion . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( ClassNotFoundException ex ) { Logger . getLogger ( Impresion . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( SQLException ex ) { Logger . getLogger ( Impresion . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } }
va	8	public String getFileContent ( ) { String content = "" ; for ( int i = 0 ; i < 4 ; i ++ ) { try { if ( this . blockPointers [ i ] != 0 ) { Block tempBlock = new Block ( this . blockPointers [ i ] , "r" ) ; content += tempBlock . getContent ( ) ; tempBlock . close ( ) ; } } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } if ( this . blockPointers [ 4 ] != 0 ) { try { Block indirectPtBlock = new Block ( this . blockPointers [ 4 ] , "r" ) ; String blkBuffer ; while ( ( blkBuffer = indirectPtBlock . readLine ( ) ) != null ) { Block tempBlock = new Block ( Integer . parseInt ( blkBuffer ) , "r" ) ; content += tempBlock . getContent ( ) ; tempBlock . close ( ) ; } indirectPtBlock . close ( ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } return content ; }
