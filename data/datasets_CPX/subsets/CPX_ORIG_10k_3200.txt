tr	4	@ Override public void call ( ) throws IOException { boolean online = true ; while ( online ) { selector . select ( ) ; Iterator < SelectionKey > it = selector . selectedKeys ( ) . iterator ( ) ; while ( it . hasNext ( ) ) { SelectionKey key = it . next ( ) ; it . remove ( ) ; SocketChannel channel = ( SocketChannel ) key . channel ( ) ; MessageHandler handler = handlers . get ( channel ) ; if ( key . isReadable ( ) ) { DataUnit message ; try { message = mp . read ( p , channel ) ; handler . handleMessage ( message ) ; } catch ( IOException e ) { handler . notifyDisconnect ( ) ; handlers . remove ( channel ) ; key . cancel ( ) ; } } } } return null ; }
tr	4	private Node getNext ( Node u ) { if ( u . right == null ) { Node n = u ; do { u = n ; n = n . parent ; if ( n == null ) return null ; } while ( u == n . right ) ; return n ; } Node n = u . right ; while ( n . left != null ) n = n . left ; return n ; }
tr	5	public void edit ( Room room ) throws NonexistentEntityException , Exception { EntityManager em = null ; try { em = getEntityManager ( ) ; em . getTransaction ( ) . begin ( ) ; room = em . merge ( room ) ; em . getTransaction ( ) . commit ( ) ; } catch ( Exception ex ) { String msg = ex . getLocalizedMessage ( ) ; if ( msg == null || msg . length ( ) == 0 ) { long id = room . getId ( ) ; if ( findRoom ( id ) == null ) { throw new NonexistentEntityException ( "The room with id " + id + " no longer exists." ) ; } } throw ex ; } finally { if ( em != null ) { em . close ( ) ; } } }
tr	2	public static double max ( double [ ] flag ) { double max = flag [ 0 ] ; for ( int i = 1 ; i < flag . length ; i ++ ) { if ( flag [ i ] > max ) max = flag [ i ] ; } return max ; }
tr	7	private Object difference ( Object subtree1 , Object subtree2 , Object lo , Object hi ) { if ( subtree1 == null || subtree1 == subtree2 ) return null ; else if ( subtree2 == null ) return split ( subtree1 , lo , hi ) ; else if ( ! ( subtree1 instanceof Node ) ) { if ( ! ( subtree2 instanceof Node ) ) return difference ( ( Object [ ] ) subtree1 , ( Object [ ] ) subtree2 , lo , hi ) ; else { Node n2 = ( Node ) subtree2 ; Object elt2 = n2 . element ; Object elt1 = findEquiv ( subtree1 , elt2 ) ; Object new_left = difference ( trim ( subtree1 , lo , elt2 ) , trim ( n2 . left , lo , elt2 ) , lo , elt2 ) ; Object new_right = difference ( trim ( subtree1 , elt2 , hi ) , trim ( n2 . right , elt2 , hi ) , elt2 , hi ) ; Object diff = equivDiff ( elt1 , elt2 ) ; if ( diff == NO_ELEMENT ) return join ( new_left , new_right ) ; else return concat ( diff , new_left , new_right ) ; } } else { Node n1 = ( Node ) subtree1 ; Object elt1 = n1 . element ; Object elt2 = findEquiv ( subtree2 , elt1 ) ; Object new_left = difference ( n1 . left , trim ( subtree2 , lo , elt1 ) , lo , elt1 ) ; Object new_right = difference ( n1 . right , trim ( subtree2 , elt1 , hi ) , elt1 , hi ) ; Object diff = equivDiff ( elt1 , elt2 ) ; if ( diff == NO_ELEMENT ) return join ( new_left , new_right ) ; else return concat ( diff , new_left , new_right ) ; } }
tr	5	@ Override public void run ( ) { try { while ( ! Thread . interrupted ( ) ) { Object msg ; synchronized ( guard ) { while ( queue . isEmpty ( ) ) { guard . wait ( ) ; } msg = queue . removeFirst ( ) ; } if ( msg instanceof R ) { process ( ( R ) msg ) ; } else if ( msg instanceof Runnable ) { ( ( Runnable ) msg ) . run ( ) ; } } } catch ( InterruptedException err ) { } System . err . println ( this + " death" ) ; }
tr	0	public void setHero ( Hero hero ) { this . hero = hero ; }
tr	1	public GameController ( ) { this . level = START_LEVEL ; if ( START_LEVEL > - 1 ) { this . playerHealth = 4 ; this . playerRange = 4 ; this . playerPower = this . level ; } this . enemyFactory = new EnemyFactory ( this ) ; }
tr	0	public static void updateFile ( String filename , WeatherData wd , DBStore db ) throws IOException , ClassNotFoundException , SQLException { HourlyPredTable hpt = new HourlyPredTable ( wd . temps , wd . precips , wd . forecastTimes , wd . date , wd . forecastDate , wd . zipCode ) ; DailyPredTable dpt = new DailyPredTable ( wd . forecast , wd . date , wd . forecastDate , wd . zipCode ) ; HourlyActualTable hat = new HourlyActualTable ( wd . tempsPast , wd . precipPast , wd . conditionsPast , wd . pastTimes , wd . date , wd . pastDate , wd . zipCode ) ; DailyActualTable dat = new DailyActualTable ( wd . overallPast , wd . date , wd . pastDate , wd . zipCode ) ; HourlyPredTable hpt3 = new HourlyPredTable ( wd . threeDayTemps , wd . threeDayPrecips , wd . forecastTimes3 , wd . date , wd . threeDayDate , wd . zipCode ) ; DailyPredTable dpt3 = new DailyPredTable ( wd . threeDayForecast , wd . date , wd . threeDayDate , wd . zipCode ) ; FileWriter fileWriter = new FileWriter ( filename , true ) ; PrintWriter out = new PrintWriter ( fileWriter , true ) ; out . println ( hpt ) ; out . println ( dpt ) ; out . println ( hat ) ; out . println ( dat ) ; out . println ( hpt3 ) ; out . println ( dpt3 ) ; SimpleDateFormat format = getDateFormatter ( ) ; Date now = new Date ( ) ; out . println ( "#finished " + format . format ( now ) ) ; out . close ( ) ; String timestamp = format . format ( now ) . split ( "T" ) [ 1 ] ; timestamp = timestamp . substring ( 0 , timestamp . length ( ) - 4 ) ; hpt . updateDB ( timestamp ) ; dpt . updateDB ( timestamp ) ; hat . updateDB ( now , db ) ; dat . updateDB ( now , db ) ; hpt3 . updateDB ( timestamp ) ; dpt3 . updateDB ( timestamp ) ; db . commit ( ) ; }
tr	6	@ Override public AATileGenerator getAATileGenerator ( Shape s , AffineTransform at , Region clip , BasicStroke bs , boolean thin , boolean normalize , int [ ] bbox ) { MarlinTileGenerator ptg = null ; Renderer r = null ; final RendererContext rdrCtx = getRendererContext ( ) ; try { final AffineTransform _at = ( at != null && ! at . isIdentity ( ) ) ? at : null ; final NormMode norm = ( normalize ) ? NormMode . ON_WITH_AA : NormMode . OFF ; if ( bs == null ) { final PathIterator pi = getNormalizingPathIterator ( rdrCtx , norm , s . getPathIterator ( _at ) ) ; r = rdrCtx . renderer . init ( clip . getLoX ( ) , clip . getLoY ( ) , clip . getWidth ( ) , clip . getHeight ( ) , pi . getWindingRule ( ) ) ; pathTo ( rdrCtx , pi , r ) ; } else { r = rdrCtx . renderer . init ( clip . getLoX ( ) , clip . getLoY ( ) , clip . getWidth ( ) , clip . getHeight ( ) , PathIterator . WIND_NON_ZERO ) ; strokeTo ( rdrCtx , s , _at , bs , thin , norm , true , r ) ; } if ( r . endRendering ( ) ) { ptg = rdrCtx . ptg . init ( ) ; ptg . getBbox ( bbox ) ; r = null ; } } finally { if ( r != null ) { r . dispose ( ) ; MarlinRenderingEngine . returnRendererContext ( rdrCtx ) ; } } return ptg ; }
tr	4	@ Test public void inorderZero ( ) { BinarySearchTree < Integer , Integer > b = new BinarySearchTree < Integer , Integer > ( ) ; Iterator < Integer > i = b . iterator ( ) ; assertFalse ( "hasNext" , i . hasNext ( ) ) ; try { i . next ( ) ; fail ( IllegalStateException . class ) ; } catch ( IllegalStateException e ) { } catch ( Exception e ) { fail ( IllegalStateException . class , e ) ; } try { i . remove ( ) ; fail ( UnsupportedOperationException . class ) ; } catch ( UnsupportedOperationException e ) { } catch ( Exception e ) { fail ( UnsupportedOperationException . class , e ) ; } }
tr	7	private boolean center2Div ( Lexer lexer , Node node , MutableObject pnode ) { if ( node . tag == tt . tagCenter ) { if ( lexer . configuration . DropFontTags ) { if ( node . content != null ) { Node last = node . last ; Node parent = node . parent ; discardContainer ( node , pnode ) ; node = lexer . inferredTag ( "br" ) ; if ( last . next != null ) last . next . prev = node ; node . next = last . next ; last . next = node ; node . prev = last ; if ( parent . last == last ) parent . last = node ; node . parent = parent ; } else { Node prev = node . prev ; Node next = node . next ; Node parent = node . parent ; discardContainer ( node , pnode ) ; node = lexer . inferredTag ( "br" ) ; node . next = next ; node . prev = prev ; node . parent = parent ; if ( next != null ) next . prev = node ; else parent . last = node ; if ( prev != null ) prev . next = node ; else parent . content = node ; } return true ; } node . tag = tt . tagDiv ; node . element = "div" ; addStyleProperty ( node , "text-align: center" ) ; return true ; } return false ; }
tr	3	@ Override public String toString ( ) { String result = null ; for ( SNode < E > nodeIt = this . frontNode ; nodeIt != null ; nodeIt = nodeIt . nextNode ) { if ( result == null ) { result = "[" + nodeIt . getElement ( ) . toString ( ) + "]" ; } else { result += " " + nodeIt . getElement ( ) . toString ( ) ; } } return result == null ? "empty" : result ; }
tr	5	public void dbReadItem ( Connection aconn , String agroup , String atest ) { try { testgroupid = agroup ; testid = atest ; String qstr = "Select TestTitle TestDesc TestNotes BugReqID CaseSource " + "LastName FirstName AgeYrs AgeMos AgeWks AgeDays BirthDate AgeEntryMethod GenderCd CreateBy CreationDate ModDate BaseDate TestResult ResultNotes" + " From TestCaseTbl" + " Where TestGroupId='" + agroup + "' and TestId='" + atest + "'" ; Statement qstmt = aconn . createStatement ( ) ; ResultSet rset = qstmt . executeQuery ( qstr ) ; if ( rset . next ( ) ) { testtitle = rset . getString ( 1 ) ; testdesc = rset . getString ( 2 ) ; testnote = rset . getString ( 3 ) ; testreqid = rset . getString ( 4 ) == null ? "" : rset . getString ( 4 ) ; casesource = rset . getString ( 5 ) == null ? "" : rset . getString ( 5 ) ; lastname = rset . getString ( 6 ) ; firstname = rset . getString ( 7 ) ; ageyears = rset . getInt ( 8 ) ; agemonths = rset . getInt ( 9 ) ; ageweeks = rset . getInt ( 10 ) ; agedays = rset . getInt ( 11 ) ; birthdate = rset . getDate ( 12 ) ; agemethod = rset . getString ( 13 ) == null ? "" : rset . getString ( 13 ) ; gendercd = rset . getString ( 14 ) ; createby = rset . getString ( 15 ) ; createdate = rset . getDate ( 16 ) ; moddate = rset . getDate ( 17 ) ; basedate = rset . getDate ( 18 ) ; testresult = rset . getString ( 19 ) ; resultnotes = rset . getString ( 20 ) ; } rset . close ( ) ; qstmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CTestItem.dbReadItem cannot read item. " , ex ) ; } }
tr	3	public void update ( UserGroup userGroup ) { Session session = null ; try { session = HibernateUtil . getSessionFactory ( ) . openSession ( ) ; session . beginTransaction ( ) ; session . update ( userGroup ) ; session . getTransaction ( ) . commit ( ) ; } catch ( Exception e ) { System . err . println ( "\u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u0432\u0441\u0442\u0430\u0432\u043A\u0435" + e . getMessage ( ) ) ; } finally { if ( session != null && session . isOpen ( ) ) { session . close ( ) ; } } }
tr	6	public static String numberToString ( Number number ) throws JSONException { if ( number == null ) { throw new JSONException ( "Null pointer" ) ; } testValidity ( number ) ; String string = number . toString ( ) ; if ( string . indexOf ( . ) > 0 && string . indexOf ( e ) < 0 && string . indexOf ( E ) < 0 ) { while ( string . endsWith ( "0" ) ) { string = string . substring ( 0 , string . length ( ) - 1 ) ; } if ( string . endsWith ( "." ) ) { string = string . substring ( 0 , string . length ( ) - 1 ) ; } } return string ; }
tr	9	@ Override public double [ ] getDoubleData ( double [ ] a , long startPos , long endPos , long step ) { if ( startPos < 0 || startPos >= length ) { throw new ArrayIndexOutOfBoundsException ( "startPos < 0 || startPos >= length" ) ; } if ( endPos < 0 || endPos > length || endPos < startPos ) { throw new ArrayIndexOutOfBoundsException ( "endPos < 0 || endPos > length || endPos < startPos" ) ; } if ( step < 1 ) { throw new IllegalArgumentException ( "step < 1" ) ; } long len = ( long ) Math . ceil ( ( endPos - startPos ) / ( double ) step ) ; if ( len > getMaxSizeOf32bitArray ( ) ) { return null ; } else { double [ ] out ; if ( a != null && a . length >= len ) { out = a ; } else { out = new double [ ( int ) len ] ; } int idx = 0 ; if ( ptr != 0 ) { for ( long i = startPos ; i < endPos ; i += step ) { out [ idx ++ ] = ( double ) Utilities . UNSAFE . getByte ( ptr + i ) ; } } else { if ( isConstant ( ) ) { for ( long i = startPos ; i < endPos ; i += step ) { out [ idx ++ ] = data [ 0 ] ; } } else { for ( long i = startPos ; i < endPos ; i += step ) { out [ idx ++ ] = ( double ) data [ ( int ) i ] ; } } } return out ; } }
tr	4	public static void Print ( String Text ) { if ( verbose_level >= 2 ) { StackTraceElement [ ] ste = Thread . currentThread ( ) . getStackTrace ( ) ; System . out . println ( ">>>>> " + ste [ 2 ] + ": " + Text ) ; if ( verbose_level >= 4 ) { System . out . print ( "Stacktrace: " ) ; for ( int i = 2 ; i < ste . length ; i ++ ) { System . out . print ( ste [ i ] ) ; if ( ! ( i == ste . length - 1 ) ) System . out . print ( " -> " ) ; } System . out . println ( "" ) ; } } }
tr	7	private static boolean KawigiEdit_RunTest ( int testNum , int [ ] p0 , int p1 , boolean hasAnswer , int p2 ) { System . out . print ( "Test " + testNum + ": [" + "{" ) ; for ( int i = 0 ; p0 . length > i ; ++ i ) { if ( i > 0 ) { System . out . print ( " " ) ; } System . out . print ( p0 [ i ] ) ; } System . out . print ( "}" + " " + p1 ) ; System . out . println ( "]" ) ; AmebaDiv2 obj ; int answer ; obj = new AmebaDiv2 ( ) ; long startTime = System . currentTimeMillis ( ) ; answer = obj . simulate ( p0 , p1 ) ; long endTime = System . currentTimeMillis ( ) ; boolean res ; res = true ; System . out . println ( "Time: " + ( endTime - startTime ) / 1000.0 + " seconds" ) ; if ( hasAnswer ) { System . out . println ( "Desired answer:" ) ; System . out . println ( "\t" + p2 ) ; } System . out . println ( "Your answer:" ) ; System . out . println ( "\t" + answer ) ; if ( hasAnswer ) { res = answer == p2 ; } if ( ! res ) { System . out . println ( "DOESN'T MATCH!!!!" ) ; } else if ( ( endTime - startTime ) / 1000.0 >= 2 ) { System . out . println ( "FAIL the timeout" ) ; res = false ; } else if ( hasAnswer ) { System . out . println ( "Match :-)" ) ; } else { System . out . println ( "OK  but is it right?" ) ; } System . out . println ( "" ) ; return res ; }
tr	7	private CompilerToken makeToken ( final String token , final String state ) throws LexicalException { if ( state . equalsIgnoreCase ( "identifier" ) ) { return processIdentifier ( token ) ; } else if ( state . equalsIgnoreCase ( "integer" ) ) { return processInteger ( token ) ; } else if ( state . equalsIgnoreCase ( "realexponent" ) ) { return processFloat ( token , state ) ; } else if ( state . equalsIgnoreCase ( "real" ) ) { return processFloat ( token , state ) ; } else if ( state . equalsIgnoreCase ( "realexponentzero" ) ) { return processFloat ( token , state ) ; } else if ( state . equalsIgnoreCase ( "zerointeger" ) ) { return processInteger ( token ) ; } else if ( state . equalsIgnoreCase ( "bang" ) ) { throw new LexicalException ( "Invalid modifier ! found." ) ; } else { return new CompilerToken ( tokenStateMap . get ( state ) , token ) ; } }
tr	5	private boolean equals ( List < TestStorable > list , TestStorable [ ] array ) { if ( list . size ( ) != array . length ) { return false ; } for ( TestStorable arrayEntry : array ) { boolean isFound = false ; for ( TestStorable listEntry : list ) { if ( Arrays . equals ( arrayEntry . getKey ( ) , listEntry . getKey ( ) ) ) { isFound = true ; break ; } } if ( ! isFound ) { return false ; } } return true ; }
tr	1	public String toString ( ) { String out = "" ; for ( int k = 1 ; k <= size ; k ++ ) out += heap [ k ] + " " ; return out ; }
tr	8	private void initDataBase ( boolean clearOldDateBase ) throws SQLException { Statement s = null ; try { s = conn . createStatement ( ) ; for ( class < ? > daoClass : DaoClassList ) { BaseDao < ? > dao = ( BaseDao < ? > ) daoClass . getField ( "manager" ) . get ( null ) ; String sql = String . format ( "SELECT COUNT(*) as CNT FROM sqlite_master where type='table' and name='%s';" , dao . getTableName ( ) ) ; ResultSet rs = s . executeQuery ( sql ) ; rs . next ( ) ; int tableCount = rs . getInt ( "CNT" ) ; if ( tableCount > 0 && clearOldDateBase ) { s . executeUpdate ( "drop table if exists " + dao . getTableName ( ) + ";" ) ; tableCount = 0 ; } if ( tableCount == 0 ) { String sqlCreateTable = dao . createTableSql ( ) ; String sqlCreateIndex = String . format ( "CREATE UNIQUE INDEX %s ON %s (id)" , dao . getTableName ( ) + "_index" , dao . getTableName ( ) ) ; printSql ( sqlCreateTable ) ; s . execute ( sqlCreateTable ) ; printSql ( sqlCreateIndex ) ; s . execute ( sqlCreateIndex ) ; } } } catch ( Exception e ) { throw new RuntimeException ( e ) ; } finally { s . close ( ) ; } }
tr	5	private String generateRandomId ( ) { StringBuilder sb = new StringBuilder ( ) ; int retry = 0 ; do { while ( sb . length ( ) < idLength ) { char ch = ( char ) rnd . nextInt ( ) ; if ( Utils . isUriLetterOrDigit ( ch ) ) { sb . append ( ch ) ; } } if ( tokens . containsKey ( sb . toString ( ) ) ) { sb . delete ( 0 , idLength ) ; } retry ++ ; } while ( sb . length ( ) == 0 || retry > RETRY_COUNT ) ; return sb . toString ( ) ; }
tr	4	@ Override public void run ( ) { try { String hostname = NetBase . theNetBase ( ) . hostname ( ) ; if ( hostname != null ) { if ( hostname . isEmpty ( ) ) System . out . println ( "Host: root" ) ; else System . out . println ( "Host: '" + hostname + "'" ) ; } else System . out . println ( "Host: none" ) ; RPCService rpcService = ( RPCService ) NetBase . theNetBase ( ) . getService ( "rpc" ) ; if ( rpcService != null ) System . out . println ( "IP: " + IPFinder . localIP ( ) + "  Port: " + rpcService . localPort ( ) ) ; else System . out . println ( "No RPC service is running on this node." ) ; } catch ( Exception e ) { System . out . println ( "Caught exception: " + e . getMessage ( ) ) ; } }
tr	4	@ Override public int hashCode ( ) { int result = con != null ? con . hashCode ( ) : 0 ; result = 31 * result + ( type != null ? type . hashCode ( ) : 0 ) ; result = 31 * result + ( var != null ? var . hashCode ( ) : 0 ) ; result = 31 * result + ( proc != null ? proc . hashCode ( ) : 0 ) ; return result ; }
tr	3	private void switchMap ( StairTile stairs ) { Point oldPt = stairs . getpA ( ) ; Point nextPt = stairs . getpB ( ) ; Map nextMap = stairs . getMapB ( ) ; Tile nextLocation = nextMap . getTile ( nextPt . x , nextPt . y ) ; player . setLocation ( nextLocation ) ; stairs . getMapA ( ) . getTile ( oldPt . x , oldPt . y ) . removeOccupant ( ) ; stairs . getMapB ( ) . getTile ( nextPt . x , nextPt . y ) . setOccupant ( player ) ; if ( player . getFuturesightCounter ( ) > 0 ) this . revealMap ( false ) ; this . map = nextMap ; messenger . drawMap ( nextMap ) ; messenger . updateTile ( nextPt ) ; resetTimeQueue ( ) ; if ( player . getFuturesightCounter ( ) > 0 ) this . revealMap ( true ) ; if ( nextMap . getTag ( ) != null ) { messenger . showTextDialog ( GameText . getText ( nextMap . getTag ( ) ) , nextMap . getTag ( ) ) ; player . setTextCollected ( player . getTextCollected ( ) + 1 ) ; nextMap . setTag ( null ) ; } messenger . centerMap ( nextPt ) ; }
tr	1	private void fixUpCase1 ( RBNode < T > node ) { if ( node . equals ( root ) ) { node . setColour ( Colour . BLACK ) ; } else { fixUpCase2 ( node ) ; } }
tr	4	@ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; while ( ! strings . isEmpty ( ) ) { String string = strings . remove ( 0 ) ; PaddingSection section = sections . remove ( 0 ) ; if ( section . rightPad ) { sb . append ( string ) ; } for ( int i = 0 ; i < section . length - string . length ( ) ; i ++ ) { sb . append ( " " ) ; } if ( ! section . rightPad ) { sb . append ( string ) ; } } return sb . toString ( ) ; }
tr	1	public RBTree ( LinkSetNode _template ) { template = _template ; if ( template instanceof TimedLinkSetNode ) { dummy = ( ( TimedLinkSetNode ) template ) . newNode ( 0 , 0 , NodeColor . RED , null , null , 0 ) ; } else { dummy = template . newNode ( 0 , 0 , NodeColor . RED , null , null ) ; } root = null ; }
tr	7	public static String readSeatNumbers ( ) { boolean tryAgain ; do { tryAgain = false ; str = scan . nextLine ( ) ; for ( String s : str . split ( " " ) ) { if ( s . length ( ) < 2 ) { tryAgain = true ; } else if ( s . charAt ( 0 ) < A && s . charAt ( 0 ) > Z ) { tryAgain = true ; } else { try { Integer . parseInt ( s . substring ( 1 , s . length ( ) ) ) ; } catch ( NumberFormatException exception ) { tryAgain = true ; } } if ( tryAgain ) { System . out . print ( "Seats No input is invalid! Try again: " ) ; break ; } } } while ( tryAgain ) ; return str ; }
tr	6	public String nextTo ( char d ) { StringBuffer sb = new StringBuffer ( ) ; for ( ; ; ) { char c = next ( ) ; if ( c == d || c == 0 || c == '' || c == '' ) { if ( c != 0 ) { back ( ) ; } return sb . toString ( ) . trim ( ) ; } sb . append ( c ) ; } }
tr	3	public void initializeGrid ( int [ ] [ ] exportedGrid ) { int rows = b . numRows ; int columns = b . numColumns ; for ( int y = 0 ; y < rows ; y ++ ) { for ( int x = 0 ; x < columns ; x ++ ) { int state = exportedGrid [ y ] [ x ] ; b . setGameGridCircle ( x , y , state ) ; if ( state != 0 ) { b . setDrawCounter ( b . getDrawCounter ( ) + 1 ) ; } } } }
tr	4	public static String unescapeHtmlAndCapitalizeAndReplaceDash ( String inputText ) { if ( StringUtils . isEmpty ( inputText ) ) { return inputText ; } String cleanText ; cleanText = StringEscapeUtils . unescapeHtml ( inputText ) ; cleanText = cleanText . replaceAll ( "-" , " " ) ; cleanText = cleanText . replaceFirst ( "^\\s" , "" ) ; if ( Character . isLetter ( cleanText . charAt ( 0 ) ) ) { cleanText = StringUtils . capitalize ( cleanText ) ; } else { char [ ] stringArray = cleanText . toCharArray ( ) ; for ( int i = 0 ; i < cleanText . length ( ) ; i ++ ) { if ( Character . isLetter ( cleanText . charAt ( i ) ) ) { stringArray [ i ] = Character . toUpperCase ( stringArray [ i ] ) ; cleanText = new String ( stringArray ) ; break ; } } } return cleanText ; }
tr	1	private static void comparable ( ) { Set < DayOfTheWeek > dayOfTheWeeks = new TreeSet < > ( ) ; dayOfTheWeeks . add ( FRIDAY ) ; dayOfTheWeeks . add ( MONDAY ) ; dayOfTheWeeks . add ( SATURDAY ) ; for ( DayOfTheWeek dayOfTheWeek : dayOfTheWeeks ) { System . out . println ( dayOfTheWeek . display ( ) ) ; } }
tr	8	public void run ( ) { HWaccess . write ( Adressen . AuswahlklappeEingangslichtschranke . ordinal ( ) , true ) ; try { Thread . sleep ( 500 ) ; } catch ( InterruptedException e ) { } HWaccess . write ( Adressen . AuswahlklappeEingangslichtschranke . ordinal ( ) , false ) ; try { Thread . sleep ( 500 ) ; } catch ( InterruptedException e ) { } if ( type == FlaschenType . Mehrweg ) { HWaccess . write ( Adressen . UebergabelichtschrankeMehrweg . ordinal ( ) , true ) ; try { Thread . sleep ( 500 ) ; } catch ( InterruptedException e ) { } HWaccess . write ( Adressen . UebergabelichtschrankeMehrweg . ordinal ( ) , false ) ; try { Thread . sleep ( 500 ) ; } catch ( InterruptedException e ) { } } if ( type == FlaschenType . PET ) { HWaccess . write ( Adressen . UebergabelichtschrankePET . ordinal ( ) , true ) ; try { Thread . sleep ( 500 ) ; } catch ( InterruptedException e ) { } HWaccess . write ( Adressen . UebergabelichtschrankePET . ordinal ( ) , false ) ; try { Thread . sleep ( 500 ) ; } catch ( InterruptedException e ) { } } }
tr	9	public static void phdStudentInsert ( JSONObject data ) { String firstName = ( String ) data . get ( "firstName" ) ; String surName = ( String ) data . get ( "surName" ) ; String lastName = ( String ) data . get ( "lastName" ) ; String personalId = ( String ) data . get ( "personalId" ) ; String phone = ( String ) data . get ( "phone" ) ; String email = ( String ) data . get ( "email" ) ; String type = ( String ) data . get ( "type" ) ; String form = ( String ) data . get ( "form" ) ; PhdStudentType studentType = null ; StudyForm studyForm = null ; if ( form . contains ( "self_training" ) ) studyForm = StudyForm . SELF_TRAINING ; else studyForm = StudyForm . REGULAR_TRAINING ; if ( type . contains ( "creative" ) ) studentType = PhdStudentType . CREATIVE ; else studentType = PhdStudentType . RESEARCH ; Student student = new Student ( firstName , surName , lastName , personalId , phone , email , studentType , studyForm ) ; SqlInsert . insertStudent ( student ) ; boolean assigned = boolean . parseBoolean ( ( String ) data . get ( "assigned" ) ) ; String assignedDate = ( String ) data . get ( "assignedDate" ) ; String supervisor = ( String ) data . get ( "supervisor" ) ; String thesis = ( String ) data . get ( "thesis" ) ; boolean individualPlan = boolean . parseBoolean ( ( String ) data . get ( "individualPlan" ) ) ; String approvalDate = ( String ) data . get ( "approvalDate" ) ; String monitoringDate = ( String ) data . get ( "monitoringDate" ) ; String evaluation_raw = ( String ) data . get ( "evaluation" ) ; Evaluation evaluation = null ; if ( evaluation_raw . equals ( "positive" ) ) evaluation = Evaluation . POSITIVE ; else if ( evaluation_raw . equals ( "negative" ) ) evaluation = Evaluation . NEGATIVE ; else evaluation = Evaluation . CRITICAL ; Monitoring monitoring = new Monitoring ( monitoringDate ) ; TrainingStatus trainingStatus = new TrainingStatus ( assigned , assignedDate , supervisor , thesis , individualPlan , approvalDate , monitoring , evaluation ) ; SqlInsert . insertTrainingStatus ( trainingStatus , student ) ; String facultyName = ( String ) data . get ( "facultyName" ) ; int specialtyCode = Integer . parseInt ( ( String ) data . get ( "specialtyCode" ) ) ; Faculty faculty = new Faculty ( facultyName , specialtyCode , trainingStatus , student ) ; SqlInsert . insertFaculty ( faculty , student , trainingStatus ) ; String specialtyExam = ( String ) data . get ( "specialtyExam" ) ; String publicProtection = ( String ) data . get ( "publicProtection" ) ; Curriculum studentCurriculum = new Curriculum ( specialtyExam , publicProtection ) ; SqlInsert . insertStudentCurriculum ( studentCurriculum , student ) ; JSONArray courses = ( JSONArray ) data . get ( "courses" ) ; for ( int i = 0 ; i < courses . size ( ) ; i ++ ) { JSONObject course = ( JSONObject ) courses . get ( i ) ; String courseName = ( String ) course . get ( "courseName" ) ; String courseEstimate = ( String ) course . get ( "courseEstimate" ) ; String courseType = ( String ) course . get ( "courseType" ) ; String courseProtocol = ( String ) course . get ( "courseProtocol" ) ; CourseProtocols protocol = new CourseProtocols ( courseProtocol ) ; CourseType ctype = null ; if ( courseType . equals ( "compulsory" ) ) ctype = CourseType . COMPULSORY ; else ctype = CourseType . ELECTIVE ; Course studentCourse = new Course ( courseEstimate , courseName , ctype , protocol ) ; SqlInsert . insertCourseProtocol ( protocol ) ; SqlInsert . insertCourses ( studentCourse , student , studentCurriculum ) ; } JSONArray eduActivities = ( JSONArray ) data . get ( "activities" ) ; for ( int i = 0 ; i < eduActivities . size ( ) ; i ++ ) { JSONObject eduActivity = ( JSONObject ) eduActivities . get ( i ) ; String activityName = ( String ) eduActivity . get ( "activityName" ) ; String activityType = ( String ) eduActivity . get ( "activityType" ) ; EduActivityType eduType = null ; if ( activityType . equals ( "lecture" ) ) eduType = EduActivityType . LECTURE ; else eduType = EduActivityType . SEMINAR ; EduActivities activity = new EduActivities ( activityName , eduType ) ; SqlInsert . insertEduActivities ( activity , student , studentCurriculum ) ; } JSONArray artisticEvents = ( JSONArray ) data . get ( "events" ) ; for ( int i = 0 ; i < artisticEvents . size ( ) ; i ++ ) { JSONObject artEvent = ( JSONObject ) artisticEvents . get ( i ) ; String eventName = ( String ) artEvent . get ( "eventName" ) ; String eventDate = ( String ) artEvent . get ( "eventDate" ) ; ArtisticEvents event = new ArtisticEvents ( eventDate , eventName ) ; SqlInsert . insertArtisticEvents ( event , student , studentCurriculum ) ; } JSONArray scientificProds = ( JSONArray ) data . get ( "productions" ) ; for ( int i = 0 ; i < scientificProds . size ( ) ; i ++ ) { JSONObject scProd = ( JSONObject ) scientificProds . get ( i ) ; String productionName = ( String ) scProd . get ( "productionName" ) ; String productionType = ( String ) scProd . get ( "productionType" ) ; ScientificProductions production = new ScientificProductions ( productionName , productionType ) ; SqlInsert . insertScProd ( production , student , studentCurriculum ) ; } }
tr	5	public static < T > boolean bfs ( BinaryTreeNode < T > root , T target ) { if ( root == null ) { return false ; } LinkedList < BinaryTreeNode > list = new LinkedList < BinaryTreeNode > ( ) ; list . add ( root ) ; BinaryTreeNode < Integer > current ; while ( list . size ( ) > 0 ) { current = list . remove ( ) ; if ( target . equals ( current . data ) ) { return true ; } if ( current . left != null ) { list . add ( current . left ) ; } if ( current . right != null ) { list . add ( current . right ) ; } } return false ; }
tr	4	public static boolean isAncestorOf ( Node node , Node descendant ) { if ( node == null || descendant == null ) { return false ; } for ( Node currentNode = descendant . getParentNode ( ) ; currentNode != null ; currentNode = currentNode . getParentNode ( ) ) { if ( currentNode == node ) { return true ; } } return false ; }
tr	9	private String getDirectionState ( Direction direction ) { String tmp ; switch ( direction . toString ( ) ) { case "EAST" : tmp = "EAST" ; break ; case "NORTH" : case "NORTHWEST" : case "NORTHEAST" : case "NONE" : tmp = "NORTH" ; break ; case "SOUTH" : case "SOUTHWEST" : case "SOUTHEAST" : tmp = "SOUTH" ; break ; case "WEST" : tmp = "WEST" ; break ; default : tmp = "ERROR" ; break ; } return tmp ; }
tr	1	public void tradeElGamal ( boolean first ) { { p = new BigInteger ( "4988735951183711405443349413015910122453507015594895638933838601555750189585703700647655985269637551634513770201277370413860951650702374379627998821919409" ) ; BigInteger g = new BigInteger ( "4403105895869798297264918950735787070665047406714785361037216842427722734684061748868589917485012596281820467352001338223691996653533143166890875549812531" ) ; BigInteger y = new BigInteger ( "3670294064109445804998782973709772470002041046377612489028768098078250713079795031354099562309432613560558383306865142781216201315104971340333690591679721" ) ; BigInteger x = new BigInteger ( "4589946301809196862611751989088793376762175950291076147544077975213763218505486754450017554342955014202444667772016113058406939298289857995054770609176615" ) ; elGamalC_own = new ElGamalCipher ( p , g , y , x ) ; elGamalS_own = new ElGamalSignature ( p , g , y , x ) ; } if ( first ) { com . sendTo ( 1 , p . toString ( 16 ) ) ; com . sendTo ( 1 , elGamalC_own . g . toString ( 16 ) ) ; com . sendTo ( 1 , elGamalC_own . y . toString ( 16 ) ) ; { BigInteger p = new BigInteger ( com . receive ( ) , 16 ) ; BigInteger g = new BigInteger ( com . receive ( ) , 16 ) ; BigInteger y = new BigInteger ( com . receive ( ) , 16 ) ; elGamalC_other = new ElGamalCipher ( p , g , y ) ; elGamalS_other = new ElGamalSignature ( p , g , y ) ; } } else { { BigInteger p = new BigInteger ( com . receive ( ) , 16 ) ; BigInteger g = new BigInteger ( com . receive ( ) , 16 ) ; BigInteger y = new BigInteger ( com . receive ( ) , 16 ) ; elGamalC_other = new ElGamalCipher ( p , g , y ) ; elGamalS_other = new ElGamalSignature ( p , g , y ) ; } com . sendTo ( 0 , p . toString ( 16 ) ) ; com . sendTo ( 0 , elGamalC_own . g . toString ( 16 ) ) ; com . sendTo ( 0 , elGamalC_own . y . toString ( 16 ) ) ; } }
tr	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( AssistantPromotion . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( AssistantPromotion . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( AssistantPromotion . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( AssistantPromotion . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { new AssistantPromotion ( ) . setVisible ( true ) ; } } ) ; }
tr	8	public MainToolBar ( ) { upButton . setMargin ( new Insets ( 0 , 0 , 0 , 0 ) ) ; upButton . setBorder ( null ) ; upButton . setOpaque ( false ) ; upButton . setContentAreaFilled ( false ) ; upButton . setBorderPainted ( false ) ; upButton . setEnabled ( false ) ; upButton . setFocusPainted ( false ) ; refreshButton . setMargin ( new Insets ( 0 , 0 , 0 , 0 ) ) ; refreshButton . setBorder ( null ) ; refreshButton . setOpaque ( false ) ; refreshButton . setContentAreaFilled ( false ) ; refreshButton . setBorderPainted ( false ) ; refreshButton . setFocusPainted ( false ) ; upButton . setToolTipText ( "Go up a folder" ) ; refreshButton . setToolTipText ( "Refresh" ) ; locationBar . setToolTipText ( "The current path  relative to the backup directory" ) ; locationBar . setDisabledTextColor ( new Color ( 0.2f , 0.2f , 0.2f ) ) ; refreshButton . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { MainFrame . getInstance ( ) . menubar . copyToOption . setEnabled ( false ) ; MainFrame . getInstance ( ) . menubar . revisionsOption . setEnabled ( false ) ; MainFrame . getInstance ( ) . redrawTable ( MainFrame . getInstance ( ) . currentDirectory ) ; } } ) ; upButton . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { MainFrame . getInstance ( ) . currentDirectory = MainFrame . getInstance ( ) . currentDirectory . resolve ( ".." ) . normalize ( ) ; if ( MainFrame . getInstance ( ) . currentDirectory . equals ( Main . backupDirectory ) ) { MainFrame . getInstance ( ) . toolbar . upButton . setEnabled ( false ) ; } MainFrame . getInstance ( ) . menubar . copyToOption . setEnabled ( false ) ; MainFrame . getInstance ( ) . menubar . revisionsOption . setEnabled ( false ) ; MainFrame . getInstance ( ) . redrawTable ( MainFrame . getInstance ( ) . currentDirectory ) ; } } ) ; locationBar . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { String text = locationBar . getText ( ) ; if ( ! text . equals ( "" ) && text . charAt ( 0 ) == File . separatorChar ) { text = text . substring ( 1 ) ; } Path enteredPath = null ; try { enteredPath = Main . backupDirectory . resolve ( text ) . toFile ( ) . getCanonicalFile ( ) . toPath ( ) ; } catch ( IOException e1 ) { Errors . nonfatalError ( "Could not interpret entered path." , e1 ) ; } if ( enteredPath . toFile ( ) . isDirectory ( ) && ( ! Main . backupDirectory . startsWith ( enteredPath . normalize ( ) ) || Main . backupDirectory . equals ( enteredPath . normalize ( ) ) ) ) { MainFrame . getInstance ( ) . redrawTable ( enteredPath . normalize ( ) ) ; MainFrame . getInstance ( ) . currentDirectory = enteredPath . normalize ( ) ; } else { JOptionPane . showMessageDialog ( MainFrame . getInstance ( ) , "The entered directory does not exist or is outside of the backup directory." ) ; } if ( MainFrame . getInstance ( ) . currentDirectory . equals ( Main . backupDirectory ) ) { MainFrame . getInstance ( ) . toolbar . upButton . setEnabled ( false ) ; } else { MainFrame . getInstance ( ) . toolbar . upButton . setEnabled ( true ) ; } } } ) ; this . setFloatable ( false ) ; this . add ( upButton ) ; this . addSeparator ( ) ; this . add ( refreshButton ) ; this . addSeparator ( ) ; this . add ( locationBar ) ; }
tr	0	@ Parameters ( { "url" , "Jenkins_job" , "sale" } ) @ Test public void Test_case_verification_of_Latin_America_locales ( String url , String Jenkins_job , String sale ) throws InterruptedException { page_locales = new Page_Locales ( ) ; page_css = new Pages_Css ( ) ; test_case_starter ( "verification_of_Latin_America_locales" , "" ) ; Locales_smoke ( url , page_locales . icon_argentina , page_locales . title_page_locales_argentina , Jenkins_job , sale ) ; Locales_smoke ( url , page_locales . icon_brazil , page_locales . title_page_locales_brasil , Jenkins_job , sale ) ; Locales_smoke ( url , page_locales . icon_chili , page_locales . title_page_locales_chile , Jenkins_job , sale ) ; Locales_smoke ( url , page_locales . icon_mexico , page_locales . title_page_locales_mexico , Jenkins_job , sale ) ; Locales_smoke ( url , page_locales . icon_other_latin , page_locales . title_page_locales_other_latin , Jenkins_job , sale ) ; test_case_ends ( ) ; }
tr	5	@ Override public void run ( ) { while ( true ) { try { Thread . sleep ( 1000 ) ; } catch ( InterruptedException ex ) { Logger . getLogger ( UP4DARbroadcastRX . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } boolean somethingChanged = false ; synchronized ( m . clients ) { int i = m . clients . size ( ) - 1 ; while ( i >= 0 ) { Client c = m . clients . get ( i ) ; c . timeToLive -- ; if ( c . timeToLive <= 0 ) { m . clients . remove ( i ) ; somethingChanged = true ; } i -- ; } } if ( somethingChanged ) { m . fireContentsChanged ( m , 0 , 0 ) ; } } }
tr	7	static void testValidity ( Object o ) throws JSONException { if ( o != null ) { if ( o instanceof double ) { if ( ( ( double ) o ) . isInfinite ( ) || ( ( double ) o ) . isNaN ( ) ) { throw new JSONException ( "JSON does not allow non-finite numbers" ) ; } } else if ( o instanceof float ) { if ( ( ( float ) o ) . isInfinite ( ) || ( ( float ) o ) . isNaN ( ) ) { throw new JSONException ( "JSON does not allow non-finite numbers." ) ; } } } }
tr	1	protected void fireChangeEvent ( ) { for ( ChangeListener l : getChangeListeners ( ) ) { l . stateChanged ( changeEvent ) ; } }
tr	5	public boolean method192 ( int j ) { int k = anInt175 ; int l = anInt166 ; if ( j == 1 ) { k = anInt197 ; l = anInt173 ; } if ( k == - 1 ) return true ; boolean flag = true ; if ( ! Model . method463 ( k ) ) flag = false ; if ( l != - 1 && ! Model . method463 ( l ) ) flag = false ; return flag ; }
tr	4	public FirstChoicePercent ( AlgorithmOutput output ) { int total = 0 ; int firsts = 0 ; for ( Timeslot t : output . keySet ( ) ) { for ( Student s : output . get ( t ) ) { total ++ ; if ( s . getFirstChoiceLabs ( ) . contains ( s . getAssignedLab ( ) ) ) { firsts ++ ; } } } this . fitness = ( double ) 100 * ( ( double ) firsts / ( double ) total ) ; if ( DEBUG ) { System . out . println ( fitness ) ; } output . addFitness ( "FirstChoicePercent" , fitness ) ; }
tr	5	static String getCallerInfo ( String className ) { String sourceClassName = null ; String sourceMethodName = null ; JavaLangAccess access = SharedSecrets . getJavaLangAccess ( ) ; Throwable throwable = new Throwable ( ) ; int depth = access . getStackTraceDepth ( throwable ) ; boolean lookingForClassName = true ; for ( int ix = 0 ; ix < depth ; ix ++ ) { StackTraceElement frame = access . getStackTraceElement ( throwable , ix ) ; String cname = frame . getClassName ( ) ; if ( lookingForClassName ) { if ( cname . equals ( className ) ) { lookingForClassName = false ; } } else { if ( ! cname . equals ( className ) ) { sourceClassName = cname ; sourceMethodName = frame . getMethodName ( ) ; break ; } } } if ( sourceClassName != null ) { return sourceClassName + " " + sourceMethodName ; } else { return "unknown" ; } }
tr	2	private void initializeClusterFactors ( BayesNet net , final List < List < Integer >> clusters , int [ ] homeClusters ) { nodePotentials = new AbstractFactor [ clusters . size ( ) ] ; Map < Integer , List < AbstractFactor >> multiplicationPartners = findMultiplicationPartners ( net , homeClusters ) ; for ( final ListIterator < List < Integer >> cliqueIt = clusters . listIterator ( ) ; cliqueIt . hasNext ( ) ; ) { final List < Integer > cluster = cliqueIt . next ( ) ; int current = cliqueIt . nextIndex ( ) - 1 ; List < AbstractFactor > multiplicationPartnerList = multiplicationPartners . get ( current ) ; final AbstractFactor cliqueFactor = factory . create ( cluster , multiplicationPartnerList == null ? Collections . < AbstractFactor > emptyList ( ) : multiplicationPartnerList ) ; nodePotentials [ current ] = cliqueFactor ; } }
tr	9	@ Override public void stateChanged ( ChangeEvent e ) { switch ( ( ( JTabbedPane ) e . getSource ( ) ) . getSelectedIndex ( ) ) { case MY_HISTORY : if ( ! changed [ MY_HISTORY ] ) { changed [ MY_HISTORY ] = true ; } break ; case MY_STEPS : if ( ! changed [ MY_STEPS ] ) { changed [ MY_STEPS ] = true ; steps . renewChart ( ) ; } break ; case MY_ACHIEVEMENT : if ( ! changed [ MY_ACHIEVEMENT ] ) { changed [ MY_ACHIEVEMENT ] = true ; achievement . update ( ) ; } break ; case OUR_DIFFERENCE : if ( difference . getOppID ( ) == null ) difference . askForUserID ( ) ; break ; case SUBONLINE : submit . askForProID ( ) ; break ; default : break ; } }
tr	8	public boolean isSuperset ( Collection < ? > coll ) { if ( coll == this ) return true ; else if ( size ( ) < coll . size ( ) ) return false ; else if ( coll instanceof FLinkedHashSet ) { FLinkedHashSet < Object > flhs = ( FLinkedHashSet < Object > ) coll ; return FHashSet . isSubset ( flhs . set_tree , set_tree ) ; } else if ( coll instanceof FHashSet ) { FHashSet fhs = ( FHashSet ) coll ; return FHashSet . isSubset ( fhs . tree , set_tree ) ; } else if ( ! ( coll instanceof Set ) ) return false ; else { for ( Object elt : coll ) if ( ! FHashSet . contains ( set_tree , elt , hashCode ( elt ) ) ) return false ; return true ; } }
tr	8	public void setRect ( int x1 , int y1 , int x2 , int y2 , Tile tile ) { int temp ; if ( x1 > x2 ) { temp = x1 ; x1 = x2 ; x2 = temp ; } if ( y1 > y2 ) { temp = y1 ; y1 = y2 ; y2 = temp ; } if ( y1 < 0 || y2 >= height || x1 < 0 || x2 >= width ) { throw new IllegalArgumentException ( "Cannot set tiles outside of the world bounds" ) ; } for ( int x = x1 ; x <= x2 ; x ++ ) { for ( int y = y1 ; y <= y2 ; y ++ ) { tiles [ x ] [ y ] = tile ; tileMeta [ x ] [ y ] = new TileMetadata ( ) ; } } }
tr	5	public byte [ ] readControl ( byte type , byte request , short value , short index , short length ) throws IOException { byte data [ ] = new byte [ length & ffff ] ; int status ; if ( length >= MAX_CONTROL_LENGTH || ( type & ControlMessage . DIR_TO_HOST ) == 0 ) throw new IllegalArgumentException ( ) ; if ( Linux . trace ) System . out . println ( "Dev.readControl  rqt 0x" + Integer . toHexString ( ff & type ) + "  req 0x" + Integer . toHexString ( ff & request ) + "  value 0x" + Integer . toHexString ( ffff & value ) + "  index 0x" + Integer . toHexString ( ffff & index ) + "  len " + Integer . toString ( ffff & length ) ) ; status = controlMsg ( fd , type , request , value , index , data , 0 , ( short ) data . length ) ; if ( status >= 0 ) { if ( status != data . length ) { byte temp [ ] = new byte [ status ] ; System . arraycopy ( data , 0 , temp , 0 , status ) ; data = temp ; } return data ; } throw new USBException ( "control read error" , - status ) ; }
tr	2	@ Override public int getBucketId ( String dbFilename ) { for ( int i = 0 ; i < filenames . length ; i ++ ) { if ( filenames [ i ] . equals ( dbFilename ) ) { return i ; } } return - 1 ; }
tr	8	public double getHammingDis ( int [ ] actDeps , int [ ] actLabs , int [ ] predDeps , int [ ] predLabs ) { double dis = 0 ; for ( int i = 1 ; i < actDeps . length ; ++ i ) if ( options . learnLabel ) { if ( labelLossType == 0 ) { if ( actDeps [ i ] != predDeps [ i ] ) dis += 0.5 ; if ( actLabs [ i ] != predLabs [ i ] ) dis += 0.5 ; } else if ( actDeps [ i ] != predDeps [ i ] || actLabs [ i ] != predLabs [ i ] ) dis += 1 ; } else { if ( actDeps [ i ] != predDeps [ i ] ) dis += 1 ; } return dis ; }
tr	3	public static boolean areAnagrams ( String s1 , String s2 ) { if ( s1 . length ( ) != s2 . length ( ) ) { return false ; } else { char [ ] b1 = s1 . toCharArray ( ) ; char [ ] b2 = s2 . toCharArray ( ) ; Arrays . sort ( b1 ) ; Arrays . sort ( b2 ) ; for ( int i = 0 ; i < s1 . length ( ) ; i ++ ) { if ( b1 [ i ] != b2 [ i ] ) { return false ; } } } return true ; }
tr	4	@ Override public void draw ( Graphics2D g2d ) { final AffineTransform transform = g2d . getTransform ( ) ; g2d . translate ( ( x * CELL_SIZE * 2 ) , ( y * CELL_SIZE * 2 ) ) ; if ( count > 0 ) { atoms [ 0 ] . draw ( g2d ) ; } drawLeavingAtoms ( g2d , 0 ) ; g2d . translate ( ( double ) CELL_SIZE , 0d ) ; if ( count > 1 ) { atoms [ 1 ] . draw ( g2d ) ; } drawLeavingAtoms ( g2d , 1 ) ; g2d . translate ( ( double ) - CELL_SIZE , ( double ) CELL_SIZE ) ; if ( count > 2 ) { atoms [ 2 ] . draw ( g2d ) ; } drawLeavingAtoms ( g2d , 2 ) ; g2d . translate ( ( double ) CELL_SIZE , 0d ) ; if ( count > 3 ) { atoms [ 3 ] . draw ( g2d ) ; } drawLeavingAtoms ( g2d , 3 ) ; g2d . setTransform ( transform ) ; }
tr	4	public static int addReview ( String course_id , String content , boolean showAuthor , String authorName ) { try { PreparedStatement pstmt ; pstmt = conn . prepareStatement ( "select * from course where course_id = ?" ) ; pstmt . setString ( 1 , course_id ) ; ResultSet rset = pstmt . executeQuery ( ) ; if ( ! ( rset . next ( ) ) ) { return 0 ; } pstmt = conn . prepareStatement ( "insert into review(course_id  mytime  content  author) values(?  ?  ?  ?)" ) ; pstmt . setString ( 1 , course_id ) ; pstmt . setTimestamp ( 2 , null ) ; pstmt . setString ( 3 , content ) ; if ( ! showAuthor ) { pstmt . setString ( 4 , "Anonymous" ) ; } else { PreparedStatement pstmt2 = conn . prepareStatement ( "select name from student where student_id = ?" ) ; pstmt2 . setString ( 1 , authorName ) ; ResultSet rset2 = pstmt2 . executeQuery ( ) ; if ( rset2 . next ( ) ) { pstmt . setString ( 4 , rset2 . getString ( "name" ) ) ; } } pstmt . executeUpdate ( ) ; return 1 ; } catch ( SQLException sqle ) { System . out . println ( "SQLException : " + sqle ) ; return 0 ; } }
tr	5	public static void main ( String [ ] args ) { init ( ) ; if ( args . length < 2 ) { System . err . println ( "Expected args: <cmd> <config_file> ....\n" + "\t cmd = create  compare" ) ; System . exit ( 1 ) ; } cmd = args [ 0 ] . toLowerCase ( ) ; String configFile = args [ 1 ] ; try { initVSL ( configFile ) ; } catch ( Exception e ) { System . err . println ( "Caught exception: " + e . toString ( ) ) ; e . printStackTrace ( ) ; System . exit ( 1 ) ; } Integer cmdint = ( Integer ) cmds . get ( cmd ) ; if ( cmdint == null ) { System . err . println ( "Expected args: <cmd> <dbfile> ....\n" + "\t cmd = create  compare  list  read" ) ; System . exit ( 1 ) ; } switch ( cmdint ) { case 1 : create ( args ) ; break ; case 3 : compare ( args ) ; break ; } System . exit ( 0 ) ; }
tr	5	protected IndexedJavaClassDescriptor addToStoredClassDescriptors ( class < ? > clazz ) { final String name = JavaClassDescriptor . getClassName ( clazz ) ; if ( debug ) debug ( "addToStoredClassDescriptors(clazz=" , clazz , ")" ) ; if ( storedClassDescriptors . containsKey ( name ) ) throw new RuntimeException ( "Descriptor of \"" + name + "\" is already stored at index: " + getFromStoredClassDescriptors ( clazz ) . getIndex ( ) ) ; JavaClassDescriptor desc = null ; if ( desc == null ) desc = new DefaultJavaClassDescriptor ( clazz ) ; IndexedJavaClassDescriptor iDesc = new IndexedJavaClassDescriptor ( storedClassDescriptors . size ( ) , desc ) ; if ( debug ) debug ( "addToStoredClassDescriptors() - putting: name=" , name , "  iDesc=" , iDesc ) ; storedClassDescriptors . put ( name , iDesc ) ; return iDesc ; }
tr	9	public String strStr ( String haystack , String needle ) { if ( needle . length ( ) > haystack . length ( ) ) return null ; int diff = 0 ; int len = needle . length ( ) ; String output = null ; while ( diff + len <= haystack . length ( ) ) { boolean match = true ; int tempdiff = 0 ; for ( int i = len - 1 ; i >= 0 ; i -- ) { if ( match ) { if ( haystack . charAt ( diff + i ) == needle . charAt ( i ) ) { } else match = false ; } else if ( tempdiff > 0 ) break ; if ( tempdiff == 0 ) { if ( haystack . charAt ( diff + len - 1 ) == needle . charAt ( i ) ) { tempdiff = len - 1 - i ; } } } if ( match ) { return haystack . substring ( diff ) ; } else if ( tempdiff > 0 ) { diff += tempdiff ; } else diff += len ; } return output ; }
tr	3	public boolean method537 ( ) { if ( anIntArray658 == null ) return true ; boolean flag = true ; for ( int j = 0 ; j < anIntArray658 . length ; j ++ ) if ( ! Model . method463 ( anIntArray658 [ j ] ) ) flag = false ; return flag ; }
tr	2	@ SuppressWarnings ( "unchecked" ) public void registerRemoved ( DomainObject obj ) { if ( newObjects . remove ( obj ) ) return ; dirtyObjects . remove ( obj ) ; if ( ! removedObjects . contains ( obj ) ) { removedObjects . add ( obj ) ; } }
tr	9	@ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( obj instanceof GetAccountPolicyRequest == false ) return false ; GetAccountPolicyRequest other = ( GetAccountPolicyRequest ) obj ; if ( other . getAccountName ( ) == null ^ this . getAccountName ( ) == null ) return false ; if ( other . getAccountName ( ) != null && other . getAccountName ( ) . equals ( this . getAccountName ( ) ) == false ) return false ; if ( other . getPolicyName ( ) == null ^ this . getPolicyName ( ) == null ) return false ; if ( other . getPolicyName ( ) != null && other . getPolicyName ( ) . equals ( this . getPolicyName ( ) ) == false ) return false ; return true ; }
tr	6	private void create ( String resource ) { InputStream input = getClass ( ) . getResourceAsStream ( resource ) ; if ( input != null ) { FileOutputStream output = null ; try { out . getParentFile ( ) . mkdirs ( ) ; output = new FileOutputStream ( out ) ; byte [ ] buf = new byte [ 8192 ] ; int length ; while ( ( length = input . read ( buf ) ) > 0 ) { output . write ( buf , 0 , length ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { try { input . close ( ) ; } catch ( Exception ignored ) { } try { if ( output != null ) output . close ( ) ; } catch ( Exception ignored ) { } } } }
tr	7	public static void testValidity ( Object o ) throws JSONException { if ( o != null ) { if ( o instanceof double ) { if ( ( ( double ) o ) . isInfinite ( ) || ( ( double ) o ) . isNaN ( ) ) { throw new JSONException ( "JSON does not allow non-finite numbers." ) ; } } else if ( o instanceof float ) { if ( ( ( float ) o ) . isInfinite ( ) || ( ( float ) o ) . isNaN ( ) ) { throw new JSONException ( "JSON does not allow non-finite numbers." ) ; } } } }
tr	6	public Vector4 clamp ( double min , double max ) { double newX = x ; double newY = y ; double newZ = z ; if ( newX < min ) { newX = min ; } else if ( newX > max ) { newX = max ; } if ( newY < min ) { newY = min ; } else if ( newY > max ) { newY = max ; } if ( newZ < min ) { newZ = min ; } else if ( newZ > max ) { newZ = max ; } return new Vector4 ( newX , newY , newZ ) ; }
tr	6	public boolean cqualifier ( char type ) throws Exception { int c = read ( ) ; if ( c != type ) { unread ( ) ; return false ; } handler . event ( type == [ ? Types . INDEX : Types . SELECTOR ) ; handler . inc ( ) ; space ( ) ; expression ( ) ; space ( ) ; handler . dec ( ) ; handler . dec ( ) ; c = read ( ) ; if ( type == [ && c != ] ) throw new SyntaxException ( "missing ]" ) ; else if ( type == { && c != } ) throw new SyntaxException ( "missing }" ) ; return true ; }
tr	4	private static Node < Integer > partitionList2 ( Node < Integer > node , int x ) { Node < Integer > before = null ; Node < Integer > after = null ; while ( node != null ) { Node < Integer > next = node . getNext ( ) ; if ( node . getData ( ) < x ) { node . setNext ( before ) ; before = node ; } else { node . setNext ( after ) ; after = node ; } node = next ; } if ( before == null ) { return after ; } Node < Integer > head = before ; while ( before . getNext ( ) != null ) { before = before . getNext ( ) ; } before . setNext ( after ) ; return head ; }
tr	8	public static void mouseClicked ( MouseEvent mouseEvent ) { Iterator < PComponent > it = components . iterator ( ) ; while ( it . hasNext ( ) ) { PComponent comp = it . next ( ) ; if ( comp == null ) continue ; if ( shouldHandleMouse ) { if ( comp . shouldHandleMouse ( ) ) comp . mouseClicked ( mouseEvent ) ; } else { if ( comp instanceof PFrame ) { for ( PComponent component : ( ( PFrame ) comp ) . getComponents ( ) ) if ( component . forceMouse ( ) ) component . mouseClicked ( mouseEvent ) ; } else if ( comp . forceMouse ( ) ) comp . mouseClicked ( mouseEvent ) ; } } }
tr	1	@ Override public double getOutputError ( double [ ] outputError ) { double squareErrorSum = 0d ; for ( double error : outputError ) squareErrorSum += ( error * error ) * 0.5 ; return squareErrorSum ; }
tr	1	@ Test public void testIfProviderExists ( ) { Store store = null ; try { store = Session . getDefaultInstance ( System . getProperties ( ) ) . getStore ( _urlDstStore ) ; } catch ( NoSuchProviderException e ) { assert . fail ( e . getMessage ( ) ) ; } assert . assertNotNull ( store ) ; }
tr	2	public Rectangle union ( Rectangle rect ) { if ( rect == null || rect . isEmpty ( ) ) return this ; return union ( rect . x , rect . y , rect . width , rect . height ) ; }
tr	0	public void testFirstExposed ( ) throws Exception { Entity firstElement = executeString ( "(first (list 1 2 3))" ) ; assertEquals ( SparseInt . valueOf ( 1 ) , firstElement ) ; }
tr	6	public static Replacer getInstance ( ReplacerType type , Map < AttributeKey , Object > attributes ) { if ( type == ReplacerType . PATTERN ) { return new PatternReplacerImpl ( attributes ) ; } else if ( type == ReplacerType . ALL_LOWER_CASE ) { return new AllLowerCaseReplacerImpl ( ) ; } else if ( type == ReplacerType . ALL_UPPER_CASE ) { return new AllUpperCaseReplacerImpl ( ) ; } else if ( type == ReplacerType . FIRST_CHAR_UPPER_CASE ) { return new FirstCharUpperCaseReplacerImpl ( ) ; } else if ( type == ReplacerType . SEQUENCE_NUMBER ) { return new SequenceNumberReplacerImpl ( attributes ) ; } else if ( type == ReplacerType . CHARACTERS ) { return new CharactersReplacerImpl ( attributes ) ; } else { throw new FileRenamerException ( "Invalid ReplacerType" ) ; } }
tr	8	@ Override public void emitCode ( ) { Address address = null ; if ( isDigit ( firstParam . charAt ( 0 ) ) ) { System . out . println ( lineNumber ++ + ":   LDC  0 " + firstParam + ZERO_REGISTER ) ; } else { address = manager . getAddressOfVar ( firstParam ) ; System . out . println ( lineNumber ++ + ":    LD  0 " + address . getOffset ( ) + address . getRegisterValue ( ) ) ; } if ( isDigit ( secondParam . charAt ( 0 ) ) ) { System . out . println ( lineNumber ++ + ":   LDC  1 " + secondParam + ZERO_REGISTER ) ; } else { address = manager . getAddressOfVar ( secondParam ) ; System . out . println ( lineNumber ++ + ":    LD  1 " + address . getOffset ( ) + address . getRegisterValue ( ) ) ; } System . out . println ( lineNumber ++ + ":    SUB 0 0 1" ) ; if ( thirdParam . equals ( "<" ) ) { System . out . println ( lineNumber ++ + ":    JGE 0" + " " + thenSize + "(7)" ) ; } else if ( thirdParam . equals ( ">" ) ) { System . out . println ( lineNumber ++ + ":    JLE 0" + " " + thenSize + "(7)" ) ; } else if ( thirdParam . equals ( "=" ) ) { System . out . println ( lineNumber ++ + ":    JNE 0" + " " + thenSize + "(7)" ) ; } else if ( thirdParam . equals ( "<=" ) ) { System . out . println ( lineNumber ++ + ":    JGT 0" + " " + thenSize + "(7)" ) ; } else if ( thirdParam . equals ( ">=" ) ) { System . out . println ( lineNumber ++ + ":    JLT 0" + " " + thenSize + "(7)" ) ; } else if ( thirdParam . equals ( "!=" ) ) { System . out . println ( lineNumber ++ + ":    JEQ 0" + " " + thenSize + "(7)" ) ; } }
tr	0	@ Override public synchronized void removeNotify ( ) { this . applet . shutdown ( ) ; super . removeNotify ( ) ; }
tr	0	public Shader build ( ) { String vsh = _vsh . build ( ) ; String fsh = _fsh . build ( ) ; int vID = createShader ( GL20 . GL_VERTEX_SHADER , vsh ) ; int fID = createShader ( GL20 . GL_FRAGMENT_SHADER , fsh ) ; int pID = linkShader ( vID , fID ) ; return new Shader ( pID , _manager ) ; }
tr	4	@ Override public void write ( byte [ ] data , int offset , int length ) throws IOException { if ( data == null ) throw new IllegalArgumentException ( "data cannot be null" ) ; if ( offset < 0 || length < 0 || ( offset + length ) > data . length ) throw new IllegalArgumentException ( "offset [" + offset + "] and length [" + length + "] must be >= 0 and (offset + length)[" + ( offset + length ) + "] must be <= data.length [" + data . length + "]" ) ; ensureCapacity ( i + length ) ; System . arraycopy ( data , offset , bbuffer , i , length ) ; i += length ; }
tr	2	public Session createSession ( String uriString , String params , ClientProxy proxy , Map < String , Object > httpParams ) { try { URI uri = new URI ( uriString ) ; SessionFactory found = registry . get ( uri . getScheme ( ) ) ; if ( found == null ) throw new ClientError ( "Could not open URI '" + uriString + "'. Unknown scheme - '" + uri . getScheme ( ) + "'." + "Make sure you have registered your SessionFactory with this transport." ) ; return found . newSession ( uri , params , proxy , httpParams ) ; } catch ( URISyntaxException e ) { throw new ClientError ( e ) ; } }
tr	2	public DefaultSettingsModifierPanel ( GCT gctarg , boolean [ ] editedarg ) { gct = gctarg ; edited = editedarg ; setLayout ( new BorderLayout ( ) ) ; useCode = new JCheckBox ( "Include Default Settings Modifier" , findDSMInstance ( ) ) ; useCode . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent arg0 ) { edited [ 0 ] = true ; if ( dsm != null ) { gct . deleteDynamicCode ( dsm ) ; dsm = null ; } else { dsm = new DSM ( ) ; gct . addDynamicCode ( dsm ) ; } initialize ( ) ; } } ) ; add ( useCode , BorderLayout . NORTH ) ; container = new JPanel ( ) ; container . setLayout ( new BoxLayout ( container , BoxLayout . Y_AXIS ) ) ; JPanel [ ] rows = { new JPanel ( ) , new JPanel ( ) , new JPanel ( ) } ; for ( JPanel p : rows ) { p . setLayout ( new BoxLayout ( p , BoxLayout . X_AXIS ) ) ; container . add ( p ) ; } add ( container , BorderLayout . CENTER ) ; gameType = new JComboBox ( ) ; gameType . addItem ( "Time" ) ; gameType . addItem ( "Stock" ) ; gameType . addItem ( "Coin" ) ; gameType . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent arg0 ) { dsm . setGameType ( ( byte ) gameType . getSelectedIndex ( ) ) ; } } ) ; rows [ 0 ] . add ( new JLabel ( "Game Type: " ) ) ; rows [ 0 ] . add ( gameType ) ; time = new SpinnerNumberModel ( 4 , 0 , 99 , 1 ) ; time . addChangeListener ( new ChangeListener ( ) { public void stateChanged ( ChangeEvent arg0 ) { byte b = time . getNumber ( ) . byteValue ( ) ; dsm . setTimeLimit ( b ) ; edited [ 0 ] = true ; } } ) ; rows [ 0 ] . add ( new JLabel ( "Time (min): " ) ) ; rows [ 0 ] . add ( new JSpinner ( time ) ) ; stock = new SpinnerNumberModel ( 4 , 1 , 99 , 1 ) ; stock . addChangeListener ( new ChangeListener ( ) { public void stateChanged ( ChangeEvent arg0 ) { byte b = stock . getNumber ( ) . byteValue ( ) ; dsm . setStock ( b ) ; edited [ 0 ] = true ; } } ) ; rows [ 0 ] . add ( new JLabel ( "Stock: " ) ) ; rows [ 0 ] . add ( new JSpinner ( stock ) ) ; stocktime = new SpinnerNumberModel ( 8 , 0 , 99 , 1 ) ; stocktime . addChangeListener ( new ChangeListener ( ) { public void stateChanged ( ChangeEvent arg0 ) { byte b = stocktime . getNumber ( ) . byteValue ( ) ; dsm . setStockTimeLimit ( b ) ; edited [ 0 ] = true ; } } ) ; rows [ 0 ] . add ( new JLabel ( "Stock-mode time: " ) ) ; rows [ 0 ] . add ( new JSpinner ( stocktime ) ) ; handicap = new JComboBox ( ) ; handicap . addItem ( "Off" ) ; handicap . addItem ( "Auto" ) ; handicap . addItem ( "On" ) ; handicap . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent arg0 ) { dsm . setHandicap ( ( byte ) handicap . getSelectedIndex ( ) ) ; edited [ 0 ] = true ; } } ) ; rows [ 1 ] . add ( new JLabel ( "Handicap: " ) ) ; rows [ 1 ] . add ( handicap ) ; damageRatio = new SpinnerNumberModel ( 1.0 , 0.5 , 2.0 , .1 ) ; damageRatio . addChangeListener ( new ChangeListener ( ) { public void stateChanged ( ChangeEvent arg0 ) { double d = 10 * damageRatio . getNumber ( ) . doubleValue ( ) ; dsm . setDamageRatio ( d ) ; edited [ 0 ] = true ; } } ) ; rows [ 1 ] . add ( new JLabel ( "Damage ratio: " ) ) ; rows [ 1 ] . add ( new JSpinner ( damageRatio ) ) ; stageMethod = new JComboBox ( ) ; stageMethod . addItem ( "Choose" ) ; stageMethod . addItem ( "Random" ) ; stageMethod . addItem ( "Take turns" ) ; stageMethod . addItem ( "Ordered" ) ; stageMethod . addItem ( "Loser's pick" ) ; stageMethod . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent arg0 ) { dsm . setStageMethod ( ( byte ) stageMethod . getSelectedIndex ( ) ) ; edited [ 0 ] = true ; } } ) ; rows [ 1 ] . add ( new JLabel ( "Stage method: " ) ) ; rows [ 1 ] . add ( stageMethod ) ; teamAttack = new JCheckBox ( "Team attack" ) ; teamAttack . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent arg0 ) { dsm . setTeamAttack ( teamAttack . isSelected ( ) ) ; edited [ 0 ] = true ; } } ) ; rows [ 2 ] . add ( teamAttack ) ; pause = new JCheckBox ( "Pause" ) ; pause . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent arg0 ) { dsm . setPause ( pause . isSelected ( ) ) ; edited [ 0 ] = true ; } } ) ; rows [ 2 ] . add ( pause ) ; scoreDisplay = new JCheckBox ( "scoreDisplay" ) ; scoreDisplay . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent arg0 ) { dsm . setScoreDisplay ( scoreDisplay . isSelected ( ) ) ; edited [ 0 ] = true ; } } ) ; rows [ 2 ] . add ( scoreDisplay ) ; damageGauge = new JCheckBox ( "damageGauge" ) ; damageGauge . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent arg0 ) { dsm . setDamageGauge ( damageGauge . isSelected ( ) ) ; edited [ 0 ] = true ; } } ) ; rows [ 2 ] . add ( damageGauge ) ; initialize ( ) ; }
tr	1	public void serverCutText ( String str ) { if ( viewer . acceptClipboard . getValue ( ) ) clipboardDialog . serverCutText ( str ) ; }
tr	8	public List < Qso > read ( ) throws Exception { ADIFParser parser = new ADIFParser ( ) ; BufferedReader r = new BufferedReader ( new FileReader ( file ) ) ; String line ; int i = 1 ; boolean read = false ; boolean gotRecord = false ; StringBuffer record = new StringBuffer ( ) ; while ( ( line = r . readLine ( ) ) != null ) { line = line . trim ( ) ; if ( line . toUpperCase ( ) . indexOf ( "<EOH>" ) > - 1 ) { read = true ; } else { if ( read ) { record . append ( line ) ; if ( line . indexOf ( "<EOR>" ) > - 1 ) { gotRecord = true ; } } } if ( gotRecord ) { try { Qso qso = parser . parseLine ( record . toString ( ) . replaceAll ( "\n" , "\\n" ) ) ; if ( ( qso != null ) && ( qso . getCall ( ) != null ) ) { list . add ( qso ) ; setOtherBandsIfExist ( qso ) ; } else { log . error ( "Qso With null call found  possible paser error" ) ; } } catch ( Exception e ) { log . error ( "Error" , e ) ; } finally { record = new StringBuffer ( ) ; gotRecord = false ; } } } return list ; }
tr	6	public PodBuyerBehaviour ( Agent a ) { super ( a ) ; msg . setOntology ( "buyer_seller" ) ; ParallelBehaviour enquiry = new ParallelBehaviour ( ParallelBehaviour . WHEN_ALL ) ; for ( int i = 0 ; i < stationList . size ( ) ; i ++ ) { if ( ! myAgent . getAID ( ) . equals ( stationList . get ( i ) ) ) { msg . addReceiver ( stationList . get ( i ) ) ; enquiry . addSubBehaviour ( new MyReceiver ( myAgent , - 1 , template ) { @ Override public void handle ( ACLMessage msg ) { if ( msg != null ) { double offer = double . parseDouble ( msg . getUserDefinedParameter ( "price" ) ) ; if ( offer < bestPrice ) { bestPrice = offer ; bestOffer = msg ; } offers . add ( msg ) ; } } } ) ; } } addSubBehaviour ( enquiry ) ; addSubBehaviour ( new OneShotBehaviour ( myAgent ) { @ Override public void action ( ) { for ( ACLMessage offer : offers ) { ACLMessage reply = offer . createReply ( ) ; if ( offer == bestOffer ) { reply . setPerformative ( ACLMessage . REQUEST ) ; reply . setContent ( "" ) ; } else { reply . setPerformative ( ACLMessage . REFUSE ) ; } myAgent . send ( reply ) ; } } } ) ; myAgent . send ( msg ) ; }
tr	6	public static int dehexchar ( char c ) { if ( c >= 0 && c <= 9 ) { return c - 0 ; } if ( c >= A && c <= F ) { return c - ( A - 10 ) ; } if ( c >= a && c <= f ) { return c - ( a - 10 ) ; } return - 1 ; }
tr	2	@ NotNull @ Override public FileContent fileContentBefore ( ) { if ( filePathBefore . equals ( noFilePath ) ) return FileContent . none ; LogFileContentResult logFileContentResult = vcsRoot . get ( ) . logFileContent ( filePathBefore , revisionBefore ) ; return logFileContentResult . isSuccessful ( ) ? new FileContent ( logFileContentResult . text ( ) ) : FileContent . failedToLoad ; }
tr	4	public ListNode swapPairs ( ListNode head ) { if ( head == null || head . next == null ) return head ; ListNode dummy = new ListNode ( 0 ) ; dummy . next = head ; ListNode ptr1 = dummy ; ListNode ptr2 = head ; while ( ptr2 != null && ptr2 . next != null ) { ListNode next = ptr2 . next . next ; ptr2 . next . next = ptr1 . next ; ptr1 . next = ptr2 . next ; ptr2 . next = next ; ptr1 = ptr2 ; ptr2 = ptr1 . next ; } return dummy . next ; }
tr	3	public static boolean isText ( int c ) { if ( isEnd ( c ) || isBreak ( c ) || isSpecial ( c ) ) return false ; return true ; }
tr	7	public void AnalyseDirectory ( String dir ) { File F = new File ( dir ) ; String [ ] fi = F . list ( ) ; String of ; File fil = new File ( dir + "/dist/" ) ; if ( ! fil . exists ( ) ) { fil . mkdir ( ) ; } for ( String f : fi ) { if ( new File ( f ) . isDirectory ( ) ) continue ; if ( ! f . endsWith ( ".res" ) ) continue ; of = dir + "/dist/" + f . substring ( 0 , f . length ( ) - 4 ) + "_dist.txt" ; StreamedLinkSet L = new StreamedLinkSet ( dir + "/" + f ) ; LinkSetNode n ; L . initTreeTraversal ( ) ; Frequency Fr = new Frequency ( ) ; Set < Integer > S = new HashSet < Integer > ( ) ; System . out . println ( "Processing " + f ) ; while ( ( n = L . getNextInOrder ( ) ) != null ) { Fr . addValue ( n . w ) ; S . add ( n . w ) ; } List < Integer > k = General . asSortedList ( S ) ; try { FileWriter out = new FileWriter ( of ) ; System . out . println ( "Writing to: " + of ) ; for ( int i : k ) { out . write ( i + " " + Fr . getCumPct ( i ) + " " + Fr . getPct ( i ) + " " + Fr . getCount ( i ) + " \n" ) ; } out . flush ( ) ; out . close ( ) ; } catch ( IOException ex ) { Logger . getLogger ( LinkSetAnalyser . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } } }
tr	2	public Manager ( int ID ) { if ( ID < 0 || ID > 25 ) { ID = 0 ; } this . ID = ID ; setManagerID ( ID ) ; surveyed = new HashSet ( ) ; }
tr	1	public Type isFieldDefined ( String id , Type type ) { if ( ! ( type instanceof StructType ) ) return null ; StructType structType = ( StructType ) type ; return structType . getType ( id ) ; }
tr	1	public Human ( Game game , InetAddress ip , int port ) { super ( game , ip , port ) ; try { this . setPlayerSpriteSheet ( ImageIO . read ( new File ( "res/img/human_male.png" ) ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } this . setPlayerSprite ( getPlayerSpriteSheet ( ) . getSubimage ( getSpriteX ( ) * 32 , getSpriteY ( ) * 32 , getSpriteWidth ( ) , getSpriteHeight ( ) ) ) ; this . setHeight ( 47 ) ; this . setStandingLeftHandX ( 14 ) ; this . setStandingLeftHandY ( 35 ) ; this . setWalkingLeftHandX ( 11 ) ; this . setWalkingLeftHandY ( 33 ) ; this . setStandingRightHandX ( 18 ) ; this . setStandingRightHandY ( 35 ) ; this . setWalkingRightHandX ( 22 ) ; this . setWalkingRightHandY ( 33 ) ; this . setWeaponXTweak ( getStandingLeftHandX ( ) ) ; this . setWeaponYTweak ( getStandingLeftHandY ( ) ) ; }
tr	6	public static void main ( String [ ] args ) { int LENGTH = 5 ; int [ ] sort = new int [ LENGTH ] ; for ( int i = 0 ; i < LENGTH ; i ++ ) { sort [ i ] = ( int ) ( Math . random ( ) * 40 ) ; } String s = "" ; for ( int nr : sort ) { s += nr + " " ; } System . out . println ( "sorting table: " + s ) ; for ( int i = 1 ; i < sort . length ; i ++ ) { int key = sort [ i ] ; int j = i - 1 ; while ( j >= 0 && sort [ j ] > key ) { sort [ j + 1 ] = sort [ j ] ; j -= 1 ; } sort [ j + 1 ] = key ; } String ss = "" ; for ( int nr : sort ) { ss += nr + " " ; } System . out . println ( "sorted table: " + ss ) ; }
tr	3	private void processPassword ( String password ) { try { dout . writeUTF ( "\uA739" + password ) ; String serverReply = din . readUTF ( ) ; switch ( serverReply ) { case "\uA739accepted" : MainGUI . chatGUI2 . setGUIConnected ( ) ; MainGUI . chatGUI2 . displayMessage ( "Connected" , ChatGUI . MESSAGE ) ; sendingConnectionInfo = true ; processMessage ( "\uA7391" + nickname ) ; break ; case "\uA739denied" : MainGUI . chatGUI2 . displayMessage ( "Incorrect password.  " , ChatGUI . ERRORMESSAGE ) ; disconnect ( ) ; break ; default : MainGUI . chatGUI2 . displayMessage ( "The server gave an unknown responce for the given password.  ERROR CODE 485." , ChatGUI . ERRORMESSAGE ) ; disconnect ( ) ; break ; } } catch ( IOException ex ) { MainGUI . chatGUI2 . displayMessage ( "An error ocurred while sending the password to the server." , ChatGUI . ERRORMESSAGE ) ; } }
tr	2	public void paint ( Graphics g , int width ) { int xpos = ( width - 251 ) / 2 ; g . setColor ( Color . black ) ; g . draw3DRect ( xpos , 420 , 251 , 20 , true ) ; for ( int tmp = 0 ; tmp < this . points ; tmp = tmp + 10 ) { if ( tmp < 100 ) { g . setColor ( new Color ( 60 + ( tmp + 10 ) / 2 , 26 , 26 ) ) ; } else { g . setColor ( new Color ( 110 , 26 + ( tmp - 90 ) / 2 , 26 ) ) ; } g . fillRect ( xpos + 1 + tmp / 2 , 421 , 5 , 19 ) ; } }
tr	2	public synchronized void togglePause ( ) { if ( pause == 0 ) { pause = 999999 ; } else { pause = 0 ; if ( inpause ) { gcodepainter . interrupt ( ) ; } } }
tr	9	public File getFileChoice ( Component parent ) { if ( chooser . showSaveDialog ( parent ) == JFileChooser . APPROVE_OPTION ) { File newFile = chooser . getSelectedFile ( ) ; if ( chooser . getFileFilter ( ) == zipFilter ) { if ( ! newFile . getName ( ) . toUpperCase ( ) . endsWith ( ".ZIP" ) ) { newFile = new File ( newFile . getAbsoluteFile ( ) + ".zip" ) ; } } if ( newFile . exists ( ) ) { int confirmChoice = JOptionPane . showConfirmDialog ( parent , "File already exists. Do you want to replace it?" ) ; if ( confirmChoice == JOptionPane . YES_OPTION ) { newFile . delete ( ) ; } else if ( confirmChoice == JOptionPane . NO_OPTION ) { return getFileChoice ( parent ) ; } else { return null ; } } if ( ! newFile . exists ( ) ) { boolean fileCreated = false ; try { fileCreated = newFile . createNewFile ( ) ; } catch ( Exception e ) { } finally { if ( ! fileCreated ) { JOptionPane . showMessageDialog ( parent , "An Error Occurred" ) ; return null ; } } } return newFile ; } else { return null ; } }
tr	9	@ Override protected void doPost ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { request . setCharacterEncoding ( "utf-8" ) ; response . setContentType ( "text/xml;charset=UTF-8" ) ; String pillName = request . getParameter ( "pillName" ) ; String pillNum = request . getParameter ( "pillNum" ) ; String pillId = request . getParameter ( "pillId" ) ; String standard = request . getParameter ( "standard" ) ; String price = request . getParameter ( "price" ) ; String number = request . getParameter ( "number" ) ; String pillType = request . getParameter ( "pillType" ) ; double priceo = 0.00 ; int numbero = 0 ; infoReg ptreg = new infoReg ( ) ; boolean result = false ; if ( pillNum == null || pillNum . equals ( "" ) ) { if ( price == null || price . equals ( "" ) ) { } else { priceo = double . parseDouble ( request . getParameter ( "price" ) ) ; } if ( number == null || number . equals ( "" ) ) { } else { numbero = Integer . parseInt ( request . getParameter ( "number" ) ) ; } result = ptreg . pillInsert ( pillName , standard , priceo , numbero , pillId , pillType ) ; PrintWriter out = response . getWriter ( ) ; if ( result ) { response . sendRedirect ( request . getContextPath ( ) + "/infoSearch/commonSearch/pillSearch.jsp" ) ; } else { out . print ( "\u6CE8\u518C\u5931\u8D25" ) ; return ; } } else { if ( price == null || price . equals ( "" ) ) { } else { priceo = double . parseDouble ( request . getParameter ( "price" ) ) ; } if ( number == null || number . equals ( "" ) ) { } else { numbero = Integer . parseInt ( request . getParameter ( "number" ) ) ; } result = ptreg . pillUpdate ( pillNum , pillName , standard , priceo , numbero , pillId , pillType ) ; PrintWriter out = response . getWriter ( ) ; if ( result ) { response . sendRedirect ( request . getContextPath ( ) + "/infoSearch/commonSearch/pillSearch.jsp" ) ; } else { out . print ( "\u6CE8\u518C\u5931\u8D25" ) ; return ; } } }
