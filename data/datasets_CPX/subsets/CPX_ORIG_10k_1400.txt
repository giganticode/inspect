tr	7	public static boolean searchAndAdd ( TrieNode root , TrieNode prev , char [ ] str , int index ) { if ( root == null ) { return false ; } if ( root . childLinks == null ) { insertNode ( root , str , 0 ) ; return false ; } if ( index < str . length ) { for ( TrieNode child : root . childLinks ) { if ( child . alphabet == str [ index ] ) { return searchAndAdd ( child , root , str , ++ index ) ; } } } if ( index == str . length && prev . endOfWord ) { return true ; } else { insertNode ( prev , str , index ) ; return false ; } }
tr	0	public UnitOfWork with ( Object [ ] contextObjectArray ) { this . ctx = new business . Context ( contextObjectArray ) ; return this ; }
tr	3	public static Shader createShader ( String name ) { BufferedReader vertex ; try { vertex = new BufferedReader ( new FileReader ( new File ( ShaderLoader . class . getResource ( "/shaders/" + name + ".vert" ) . toURI ( ) ) ) ) ; } catch ( Exception e ) { return null ; } BufferedReader fragment ; try { fragment = new BufferedReader ( new FileReader ( new File ( ShaderLoader . class . getResource ( "/shaders/" + name + ".vert" ) . toURI ( ) ) ) ) ; } catch ( Exception e ) { try { vertex . close ( ) ; } catch ( IOException e2 ) { } return null ; } return createShader ( name , vertex , fragment ) ; }
tr	6	public String pillcaseSearch ( String pillId ) { String status = "" ; String payer = "" ; String pillAmount = "" ; String number = "" ; String pillName = "" ; String pillNum = "" ; String str = "select distinct pl.payer p.pill_num rl.status pl.pill_amount p.number p.pill_name from pill p pill_list pl recepit_list rl where pl.id='" + pillId + "' and  p.pill_num=pl.pill_id and rl.receipt_id=pl.id and rl.pillOrEquip='1' order by p.pill_name;" ; System . out . println ( "pillcaseSearch________________" + str ) ; try { conn = dbConn . getConn ( ) ; pstmt = conn . prepareStatement ( str ) ; ResultSet num = pstmt . executeQuery ( ) ; sb . append ( "<tr> <td>\u836F\u54C1\u540D\u79F0</td> <td>\u6570\u91CF</td> <td>\u5E93\u5B58\u6570\u91CF</td> </tr> " ) ; while ( num . next ( ) ) { pillNum = num . getString ( "pill_num" ) ; status = num . getString ( "status" ) ; payer = num . getString ( "payer" ) ; pillAmount = num . getString ( "pill_amount" ) ; number = num . getString ( "number" ) ; pillName = num . getString ( "pill_name" ) ; sb . append ( " <tr><td><input type=\"text\" value=\"" + pillName + "\" readonly><input type=\"text\" value=\"" + pillNum + "\" style=\"display:none\" name=\"pillid\"></td>" ) ; sb . append ( "<td><input type=\"text\" value=\"" + pillAmount + "\" name=\"pillAmount\" readonly> </td><td><input type=\"text\" value=\"" + number + "\" name=\"pillNum\" readonly></td></tr>" ) ; sb . append ( "<input type=\"text\"  value=\"" + pillId + "\" name=\"id\" style=\"display:none\">" ) ; } if ( status . equals ( "1" ) ) { sb . append ( "<tr> <td>\u4EA4\u6B3E\u72B6\u6001</td> <td colspan=\"2\"><input type=\"text\" value=\"\u672A\u4EA4\u6B3E\" readonly></td> </tr>" ) ; } else if ( status . equals ( "2" ) ) { sb . append ( "<tr> <td>\u4EA4\u6B3E\u72B6\u6001</td> <td colspan=\"2\"><input type=\"text\" value=\"\u5DF2\u4EA4\u6B3E\" readonly></td> </tr>" ) ; } if ( payer == null ) { sb . append ( "<tr> <td>\u4ED8\u836F\u72B6\u6001</td> <td colspan=\"2\" id=\"fyzt\">\u672A\u4ED8\u836F</td> </tr>" ) ; } else if ( payer != null ) { sb . append ( "<tr> <td>\u4ED8\u836F\u72B6\u6001</td> <td colspan=\"2\" id=\"fyzt\">\u5DF2\u4ED8\u836F</td> </tr>" ) ; } pstmt . close ( ) ; dbConn . close ( conn ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; } return sb . toString ( ) ; }
tr	7	public static double qnorm ( double p , boolean upper ) { if ( p < 0 || p > 1 ) throw new IllegalArgumentException ( "Illegal argument " + p + " for qnorm(p)." ) ; double split = 0.42 , a0 = 2.50662823884 , a1 = - 18.61500062529 , a2 = 41.39119773534 , a3 = - 25.44106049637 , b1 = - 8.47351093090 , b2 = 23.08336743743 , b3 = - 21.06224101826 , b4 = 3.13082909833 , c0 = - 2.78718931138 , c1 = - 2.29796479134 , c2 = 4.85014127135 , c3 = 2.32121276858 , d1 = 3.54388924762 , d2 = 1.63706781897 , q = p - 0.5 ; double r , ppnd ; if ( Math . abs ( q ) <= split ) { r = q * q ; ppnd = q * ( ( ( a3 * r + a2 ) * r + a1 ) * r + a0 ) / ( ( ( ( b4 * r + b3 ) * r + b2 ) * r + b1 ) * r + 1 ) ; } else { r = p ; if ( q > 0 ) r = 1 - p ; if ( r > 0 ) { r = Math . sqrt ( - Math . log ( r ) ) ; ppnd = ( ( ( c3 * r + c2 ) * r + c1 ) * r + c0 ) / ( ( d2 * r + d1 ) * r + 1 ) ; if ( q < 0 ) ppnd = - ppnd ; } else { ppnd = 0 ; } } if ( upper ) ppnd = 1 - ppnd ; return ( ppnd ) ; }
tr	8	@ Override public String replace ( String [ ] args , Page page ) { String image = "" ; String link = "" ; String alt = "image" ; for ( String arg : args ) { if ( arg . startsWith ( "img=" ) ) { image = arg . substring ( "img=" . length ( ) ) ; } else if ( arg . startsWith ( "link=" ) ) { link = arg . substring ( "link=" . length ( ) ) ; } else if ( arg . startsWith ( "alt=" ) ) { alt = arg . substring ( "alt=" . length ( ) ) ; } else if ( arg . startsWith ( "http:" ) ) { image = arg ; } else if ( arg . endsWith ( ".gif" ) || arg . endsWith ( ".png" ) ) { image = arg ; } else { throw new UnsupportedOperationException ( "Unknown image parameter: >" + arg + "<" ) ; } } return "![" + alt + "](" + image + ")" + ( link . length ( ) > 0 ? "(" + link + ")" : "" ) ; }
tr	4	public boolean checkSave ( ) { if ( hasChanged ( ) ) { int c = JOptionPane . showConfirmDialog ( frame , Resources . getString ( "Jeie.UNSAVED_MESSAGE" ) , Resources . getString ( "Jeie.UNSAVED_TITLE" ) , JOptionPane . YES_NO_CANCEL_OPTION ) ; if ( c == JOptionPane . CANCEL_OPTION ) return false ; if ( c == JOptionPane . YES_OPTION ) return doSave ( false ) ; if ( c == JOptionPane . NO_OPTION ) return true ; } return true ; }
tr	3	public static long addContact ( Contact contact , long sessionID ) throws SessionException { if ( sessionID <= NO_SESSION_ID ) { sessionID = getSessionID ( ) ; } if ( contacts . indexOf ( contact ) != - 1 ) { if ( ! editContacts . containsValue ( contact ) ) { editContacts . put ( new long ( sessionID ) , contact ) ; } else { throw new SessionException ( "This contact is currently being edited by another user." , SessionException . CONTACT_BEING_EDITED ) ; } } else { contacts . add ( contact ) ; editContacts . put ( new long ( sessionID ) , contact ) ; } return sessionID ; }
tr	9	public String nextToken ( ) throws JSONException { char c ; char q ; StringBuffer sb = new StringBuffer ( ) ; do { c = next ( ) ; } while ( Character . isWhitespace ( c ) ) ; if ( c == " || c == ' ) { q = c ; for ( ; ; ) { c = next ( ) ; if ( c <   ) { throw syntaxError ( "Unterminated string." ) ; } if ( c == q ) { return sb . toString ( ) ; } sb . append ( c ) ; } } for ( ; ; ) { if ( c == 0 || Character . isWhitespace ( c ) ) { return sb . toString ( ) ; } sb . append ( c ) ; c = next ( ) ; } }
tr	6	public static OS getPlatform ( ) { String osName = System . getProperty ( "os.name" ) . toLowerCase ( ) ; if ( osName . contains ( "win" ) ) return OS . windows ; if ( osName . contains ( "mac" ) ) return OS . macos ; if ( osName . contains ( "solaris" ) ) return OS . solaris ; if ( osName . contains ( "sunos" ) ) return OS . solaris ; if ( osName . contains ( "linux" ) ) return OS . linux ; if ( osName . contains ( "unix" ) ) return OS . linux ; return OS . unknown ; }
tr	8	public void read ( org . apache . thrift . protocol . TProtocol iprot , MentionEntity struct ) throws org . apache . thrift . TException { org . apache . thrift . protocol . TField schemeField ; iprot . readStructBegin ( ) ; while ( true ) { schemeField = iprot . readFieldBegin ( ) ; if ( schemeField . type == org . apache . thrift . protocol . TType . STOP ) { break ; } switch ( schemeField . id ) { case 1 : if ( schemeField . type == org . apache . thrift . protocol . TType . I64 ) { struct . id = iprot . readI64 ( ) ; struct . setIdIsSet ( true ) ; } else { org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } break ; case 2 : if ( schemeField . type == org . apache . thrift . protocol . TType . STRING ) { struct . name = iprot . readString ( ) ; struct . setNameIsSet ( true ) ; } else { org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } break ; case 3 : if ( schemeField . type == org . apache . thrift . protocol . TType . STRING ) { struct . screen_name = iprot . readString ( ) ; struct . setScreen_nameIsSet ( true ) ; } else { org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } break ; default : org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } iprot . readFieldEnd ( ) ; } iprot . readStructEnd ( ) ; struct . validate ( ) ; }
tr	2	public AdditionalGradeEntries read ( Integer id ) { log . debug ( "reading " + entitySimpleName + " instance with id: " + id ) ; AdditionalGradeEntries instance = null ; try { instance = ( AdditionalGradeEntries ) super . read ( entityFullName , id ) ; log . debug ( entitySimpleName + " read successful  instance found" ) ; } catch ( EntityNotFoundException ex ) { log . error ( entitySimpleName + " read successful  no instance found" , ex ) ; } catch ( RuntimeException re ) { log . error ( entitySimpleName + " read failed" , re ) ; throw re ; } return instance ; }
tr	6	@ Override public void loadListOfPlugins ( PluginList plugins , String folderPath , String language , boolean isIntern ) { File downloadDir = new File ( getRepositoryFolderName ( ) + "/" + folderPath ) ; if ( downloadDir . exists ( ) ) { for ( File f : downloadDir . listFiles ( ) ) { if ( f . isDirectory ( ) ) { Plugin p = new Plugin ( f . getName ( ) , language ) ; if ( folderPath . contains ( "plugins" ) ) { if ( p . getType ( ) . equals ( PluginType . template ) ) { p . setType ( PluginType . event ) ; } } p . setRepository ( this ) ; if ( folderPath . length ( ) > 0 ) { p . setFolderInRepository ( folderPath + "/" + f . getName ( ) ) ; } else { p . setFolderInRepository ( f . getName ( ) ) ; } plugins . add ( p ) ; } } } }
tr	4	public static int getAge ( Date birthday ) { Calendar cal = Calendar . getInstance ( ) ; if ( cal . before ( birthday ) ) { return 0 ; } int yearNow = cal . get ( Calendar . YEAR ) ; int monthNow = cal . get ( Calendar . MONTH ) ; int dayOfMonthNow = cal . get ( Calendar . DAY_OF_MONTH ) ; cal . setTime ( birthday ) ; int yearBirth = cal . get ( Calendar . YEAR ) ; int monthBirth = cal . get ( Calendar . MONTH ) ; int dayOfMonthBirth = cal . get ( Calendar . DAY_OF_MONTH ) ; int age = yearNow - yearBirth ; if ( monthNow <= monthBirth ) { if ( monthNow == monthBirth ) { if ( dayOfMonthNow < dayOfMonthBirth ) { age -- ; } } else { age -- ; } } return age ; }
tr	1	public int count ( final DataFrame frame ) { final List < DataField > retval = new ArrayList < DataField > ( ) ; if ( frame != null ) { recurseFields ( frame , null , retval ) ; } return retval . size ( ) ; }
tr	7	String toString ( int indentFactor , int indent ) throws JSONException { int j ; int n = length ( ) ; if ( n == 0 ) { return "{}" ; } Iterator keys = sortedKeys ( ) ; StringBuffer sb = new StringBuffer ( "{" ) ; int newindent = indent + indentFactor ; Object o ; if ( n == 1 ) { o = keys . next ( ) ; sb . append ( quote ( o . toString ( ) ) ) ; sb . append ( ": " ) ; sb . append ( valueToString ( this . map . get ( o ) , indentFactor , indent ) ) ; } else { while ( keys . hasNext ( ) ) { o = keys . next ( ) ; if ( sb . length ( ) > 1 ) { sb . append ( " \n" ) ; } else { sb . append ( '' ) ; } for ( j = 0 ; j < newindent ; j += 1 ) { sb . append (   ) ; } sb . append ( quote ( o . toString ( ) ) ) ; sb . append ( ": " ) ; sb . append ( valueToString ( this . map . get ( o ) , indentFactor , newindent ) ) ; } if ( sb . length ( ) > 1 ) { sb . append ( '' ) ; for ( j = 0 ; j < indent ; j += 1 ) { sb . append (   ) ; } } } sb . append ( } ) ; return sb . toString ( ) ; }
tr	6	@ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; SpeciesReference other = ( SpeciesReference ) obj ; if ( species == null ) { if ( other . species != null ) return false ; } else if ( ! species . equals ( other . species ) ) return false ; return true ; }
tr	1	public void addMouseListener ( MouseListener mouseListener ) { super . addMouseListener ( mouseListener ) ; for ( Component component : getComponents ( ) ) { component . addMouseListener ( mouseListener ) ; } }
tr	0	@ Override public String getPermission ( ) { return "irc.leave" ; }
tr	5	public static void print ( JTextComponent textComponent ) throws TextComponentUtilException { InputStream is = null ; try { PrintService [ ] printServices = PrintServiceLookup . lookupPrintServices ( DocFlavor . INPUT_STREAM . AUTOSENSE , null ) ; if ( printServices . length > 0 ) { PrintRequestAttributeSet printRequestAttributeSet = new HashPrintRequestAttributeSet ( ) ; printRequestAttributeSet . add ( new JobName ( "JAligner" , null ) ) ; PrintService service = ServiceUI . printDialog ( null , 50 , 50 , printServices , PrintServiceLookup . lookupDefaultPrintService ( ) , DocFlavor . INPUT_STREAM . AUTOSENSE , printRequestAttributeSet ) ; if ( service != null ) { DocPrintJob printJob = service . createPrintJob ( ) ; PrintJobMointor printJobMointor = new PrintJobMointor ( printJob ) ; is = new ByteArrayInputStream ( textComponent . getText ( ) . getBytes ( ) ) ; DocumentName documentName = new DocumentName ( "JAligner" , null ) ; HashDocAttributeSet docAttributeSet = new HashDocAttributeSet ( ) ; docAttributeSet . add ( documentName ) ; Doc doc = new SimpleDoc ( is , DocFlavor . INPUT_STREAM . AUTOSENSE , docAttributeSet ) ; printJob . print ( doc , printRequestAttributeSet ) ; printJobMointor . waitForPrintJob ( ) ; } } else { throw new TextComponentUtilException ( "No print service found!" ) ; } } catch ( Exception e ) { throw new TextComponentUtilException ( e . getMessage ( ) ) ; } finally { if ( is != null ) { try { is . close ( ) ; } catch ( IOException e ) { logger . log ( Level . WARNING , "Failed closing input stream: " + e . getMessage ( ) , e ) ; } } } }
tr	2	public List < Player > getPlayersOnPlace ( ) { final List < Player > players = new ArrayList < Player > ( ) ; for ( final Player player : Monopoly . getInstance ( ) . getPlayers ( ) ) { if ( player . position == this . placeID ) { players . add ( player ) ; } } return players ; }
tr	5	public Model method194 ( int j ) { int k = anInt175 ; int l = anInt166 ; if ( j == 1 ) { k = anInt197 ; l = anInt173 ; } if ( k == - 1 ) return null ; Model model = Model . method462 ( k ) ; if ( l != - 1 ) { Model model_1 = Model . method462 ( l ) ; Model aclass30_sub2_sub4_sub6s [ ] = { model , model_1 } ; model = new Model ( 2 , aclass30_sub2_sub4_sub6s ) ; } if ( modifiedModelColors != null ) { for ( int i1 = 0 ; i1 < modifiedModelColors . length ; i1 ++ ) model . method476 ( modifiedModelColors [ i1 ] , originalModelColors [ i1 ] ) ; } return model ; }
tr	8	private String handleRequest ( String input ) throws IOException , IllegalArgumentException { System . out . println ( input ) ; String nameReg = "[a-zA-Z0-9\\.]+" ; String regex = "(boards)|(newBoard " + nameReg + ")|" + "(switch " + nameReg + " " + nameReg + " " + nameReg + ")|" + "(exit " + nameReg + ")|(users " + nameReg + ")|" + "(checkAndAddUser " + nameReg + " " + nameReg + ")|" + "(draw " + nameReg + "( " + nameReg + ")+)" ; if ( ! input . matches ( regex ) ) { System . out . println ( "Invalid input: " + input ) ; return null ; } String [ ] tokens = input . split ( " " ) ; if ( tokens [ 0 ] . equals ( "boards" ) ) { return boards ( tokens ) ; } else if ( tokens [ 0 ] . equals ( "newBoard" ) ) { return newBoard ( tokens ) ; } else if ( tokens [ 0 ] . equals ( "switch" ) ) { return switchBoard ( tokens ) ; } else if ( tokens [ 0 ] . equals ( "exit" ) ) { return exit ( tokens ) ; } else if ( tokens [ 0 ] . equals ( "draw" ) ) { return draw ( tokens ) ; } else if ( tokens [ 0 ] . equals ( "checkAndAddUser" ) ) { return checkAndAddUser ( tokens ) ; } else if ( tokens [ 0 ] . equals ( "users" ) ) { return users ( tokens ) ; } throw new UnsupportedOperationException ( ) ; }
tr	2	@ Override public void paintAfter ( Graphics g ) { if ( foundPoint != null ) { g . setColor ( Color . BLACK ) ; getDraw ( ) . drawPoint ( g , foundPoint . point ) ; } if ( foundSegment != null ) { g . setColor ( Color . BLACK ) ; getDraw ( ) . drawSegment ( g , foundSegment . segment ) ; } super . paintAfter ( g ) ; }
tr	7	@ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; ProcedureHeadingNode that = ( ProcedureHeadingNode ) o ; if ( fparams != null ? ! fparams . equals ( that . fparams ) : that . fparams != null ) return false ; if ( subject != null ? ! subject . equals ( that . subject ) : that . subject != null ) return false ; return true ; }
tr	9	static char type ( String s ) { if ( s == null || s . length ( ) == 0 ) return 0 ; char c = s . charAt ( 0 ) ; if ( c == ' || c == " ) return s ; if ( Character . isDigit ( c ) ) { if ( s . indexOf ( . ) != - 1 ) return f ; else return i ; } if ( s . length ( ) > 1 && c == ! && Character . isLetter ( s . charAt ( 1 ) ) ) return y ; if ( Characters . isOperator ( c ) ) return o ; if ( s . equals ( "true" ) || s . equals ( "false" ) ) return b ; return p ; }
tr	7	private JSONWriter append ( String string ) throws JSONException { if ( string == null ) { throw new JSONException ( "Null pointer" ) ; } if ( this . mode == o || this . mode == a ) { try { if ( this . , && this . mode == a ) { this . writer . write (   ) ; } this . writer . write ( string ) ; } catch ( IOException e ) { throw new JSONException ( e ) ; } if ( this . mode == o ) { this . mode = k ; } this . , = true ; return this ; } throw new JSONException ( "Value out of sequence." ) ; }
tr	7	public Vector < String > enumDatabases ( ) { Vector < String > instances = new Vector < String > ( ) ; Connection session = null ; try { session = connect ( "postgres" , "postgres" , "postgres" ) ; if ( session == null ) { errMsg = "Can't connect to management database" ; return instances ; } Statement stmt = session . createStatement ( ) ; if ( stmt . execute ( "select datname from pg_database;" ) ) { ResultSet r = stmt . getResultSet ( ) ; if ( r != null ) { while ( r . next ( ) ) { String name = r . getString ( "datname" ) ; instances . add ( name ) ; } } } errMsg = null ; } catch ( SQLException e ) { errMsg = e . getMessage ( ) ; } finally { if ( session != null ) try { session . close ( ) ; } catch ( SQLException e ) { } } return instances ; }
tr	4	@ Override public void makeInput ( String condId ) throws YSpecBuildException { if ( condId == null ) throw new YSpecBuildException ( "condId must not be null." ) ; if ( ! elems . contains ( condId ) ) throw new YSpecBuildException ( "condId does not correspond" + " to an existing element" ) ; if ( kinds . get ( condId ) != null ) { if ( ! kinds . get ( condId ) . promotes ( ElemTypes . ICOND ) ) { throw new YSpecBuildException ( "The id allready belongs " + "to an element that cannot be promoted to a condition" ) ; } } assert containerNet . get ( condId ) != null : "Consistency check failed: the condition has been created" + " but its container net was not set. " ; iconds . put ( containerNet . get ( condId ) , condId ) ; kinds . put ( condId , ElemTypes . ICOND ) ; }
tr	2	private void clearTopInterfaces ( ) { stream . putOpcode ( 130 ) ; if ( inventoryOverlayInterfaceID != - 1 ) { inventoryOverlayInterfaceID = - 1 ; redrawTab = true ; continuedDialogue = false ; drawTabIcons = true ; } if ( chatboxInterfaceId != - 1 ) { chatboxInterfaceId = - 1 ; redrawChatbox = true ; continuedDialogue = false ; } openInterfaceId = - 1 ; }
tr	0	public void setInicio ( java . sql . Time inicio ) { this . inicio = inicio ; }
tr	5	public User validateUser ( String username , String password ) { try { if ( username . length ( ) > 40 ) return null ; if ( password . length ( ) > 40 ) return null ; select1 . setString ( 1 , username ) ; ResultSet rs = select1 . executeQuery ( ) ; while ( rs . next ( ) ) { if ( rs . getString ( "password" ) . equals ( password ) ) { return new User ( rs . getString ( "username" ) , rs . getString ( "password" ) , rs . getString ( "displayname" ) , PermissionsList . fromByteArray ( rs . getBytes ( "permissions" ) ) ) ; } } rs = null ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return null ; }
tr	9	public void run ( ) { while ( isWriter ) { int i ; int j ; synchronized ( this ) { if ( buffIndex == writeIndex ) try { wait ( ) ; } catch ( InterruptedException _ex ) { } if ( ! isWriter ) return ; j = writeIndex ; if ( buffIndex >= writeIndex ) i = buffIndex - writeIndex ; else i = 5000 - writeIndex ; } if ( i > 0 ) { try { outputStream . write ( buffer , j , i ) ; } catch ( IOException _ex ) { hasIOError = true ; } writeIndex = ( writeIndex + i ) % 5000 ; try { if ( buffIndex == writeIndex ) outputStream . flush ( ) ; } catch ( IOException _ex ) { hasIOError = true ; } } } }
tr	0	public Arctg ( double acc ) { super ( acc ) ; }
tr	4	public static void updateUtilisateur ( Utilisateur utilisateur ) { PreparedStatement stat ; try { stat = ConnexionDB . getConnection ( ) . prepareStatement ( "select * from utilisateur where id_utilisateur=?" , ResultSet . TYPE_SCROLL_INSENSITIVE , ResultSet . CONCUR_UPDATABLE ) ; stat . setInt ( 1 , utilisateur . getId_utilisateur ( ) ) ; ResultSet res = stat . executeQuery ( ) ; if ( res . next ( ) ) { res . updateString ( "prenom" , utilisateur . getPrenom ( ) ) ; res . updateString ( "nom" , utilisateur . getNom ( ) ) ; res . updateString ( "dateNaissance" , utilisateur . getDateNaissance ( ) ) ; res . updateString ( "adresse" , utilisateur . getAdresse ( ) ) ; res . updateString ( "codePostal" , utilisateur . getCodePostal ( ) ) ; res . updateString ( "ville" , utilisateur . getVille ( ) ) ; res . updateString ( "carteBancaire" , utilisateur . getCarteBancaire ( ) ) ; res . updateString ( "dateValiditeCarteBancaire" , utilisateur . getDateValiditeCarteBancaire ( ) ) ; res . updateString ( "rib" , utilisateur . getRib ( ) ) ; res . updateString ( "iban" , utilisateur . getIban ( ) ) ; res . updateString ( "dateCreation" , utilisateur . getDateCreation ( ) ) ; res . updateString ( "login" , utilisateur . getLogin ( ) ) ; res . updateString ( "password" , utilisateur . getPassword ( ) ) ; res . updateInt ( "fk_id_carte" , utilisateur . getFk_id_carte ( ) ) ; if ( utilisateur . getFk_id_velo ( ) == - 1 ) { res . updateNull ( "fk_id_velo" ) ; } else { res . updateInt ( "fk_id_velo" , utilisateur . getFk_id_velo ( ) ) ; } res . updateRow ( ) ; } } catch ( SQLException e ) { while ( e != null ) { System . out . println ( e . getErrorCode ( ) ) ; System . out . println ( e . getMessage ( ) ) ; System . out . println ( e . getSQLState ( ) ) ; e . printStackTrace ( ) ; e = e . getNextException ( ) ; } } }
tr	7	public void mousePress ( MouseEvent e , Canvas canvas , Palette p ) { if ( active != null ) { if ( e . getButton ( ) == button ) finish ( canvas , p ) ; else cancel ( canvas ) ; return ; } if ( ! isValid ( e , canvas , p ) ) return ; button = e . getButton ( ) ; mouseTime = e . getWhen ( ) ; Color c1 = p . getLeft ( ) ; Color c2 = p . getRight ( ) ; if ( button != MouseEvent . BUTTON1 ) { c1 = c2 ; c2 = p . getLeft ( ) ; } switch ( type ) { case OUTLINE : canvas . active = active = new RoundRectangleAction ( canvas , e . getPoint ( ) , c1 , null ) ; break ; case BOTH : canvas . active = active = new RoundRectangleAction ( canvas , e . getPoint ( ) , c1 , c2 ) ; break ; case FILL : canvas . active = active = new RoundRectangleAction ( canvas , e . getPoint ( ) , c1 , c1 ) ; break ; } canvas . repaint ( ) ; }
tr	3	private void remove ( BSTNode < T > node ) { if ( ! node . getLeft ( ) . isEmpty ( ) ) { transplant ( node , ( BSTNode < T > ) node . getRight ( ) ) ; } else if ( node . getRight ( ) . isEmpty ( ) ) { transplant ( node , ( BSTNode < T > ) node . getLeft ( ) ) ; } else { BSTNode < T > y = minimum ( ( BSTNode < T > ) node . getRight ( ) ) ; if ( ! y . getParent ( ) . equals ( node ) ) { transplant ( y , ( BSTNode < T > ) y . getRight ( ) ) ; y . setRight ( node . getRight ( ) ) ; y . getRight ( ) . setParent ( y ) ; } transplant ( node , y ) ; y . setLeft ( node . getLeft ( ) ) ; y . getLeft ( ) . setParent ( y ) ; } size -- ; }
tr	4	public void setVolume ( int channel , int volume ) { if ( channel < 0 || channel >= channelCount ) throw new IllegalArgumentException ( "Channel must be in legal range!" ) ; if ( volume < 0 || volume > short . MAX_VALUE ) throw new IllegalArgumentException ( "Volume must be in legal range!" ) ; vol [ channel ] = ( short ) volume ; }
tr	2	protected boolean isKeyPressed ( int key ) { return ( key < 1024 && key >= 0 ) && keys [ key ] ; }
tr	2	@ Override public InputStream getInputStream ( ) throws IOException { switch ( failValue ) { case 0 : return new InputStream ( ) { @ Override public int read ( ) throws IOException { return 1 ; } } ; case 1 : return null ; default : throw new IOException ( ) ; } }
tr	8	private MoveInfo IterativeDeepeningRoot2 ( GameState position ) { current_best_score = - SCORE_INFINITY ; current_search_depth = 0 ; ArimaaMove best_move = null ; this . initial_position = position ; GameState initial_gs = position ; resetStats ( ) ; enable_search ( ) ; GameState new_position = new GameState ( ) ; eval . PreProcessRootPosition ( position ) ; MoveList root_moves = genRootMoves ( initial_gs ) ; ProcessRootMoves ( initial_position , root_moves ) ; int offset = setup_search ( initial_gs ) ; LogFile . message ( "Score Offset: " + offset ) ; try { for ( int depth = initial_search_depth ; depth <= max_search_depth ; depth ++ ) { current_search_depth = depth ; int iteration_best_score = - SCORE_INFINITY ; int new_beta = SCORE_INFINITY ; root_moves . sort ( ) ; for ( ArimaaMove move : root_moves ) { int temp_score ; if ( move . move_ordering_value >= 30000 || move . move_ordering_value <= - 30000 ) { temp_score = move . move_ordering_value ; } else { new_position . play ( move , initial_position ) ; temp_score = SearchPosition ( new_position , depth , iteration_best_score , new_beta ) ; } move . move_ordering_value = temp_score ; if ( temp_score > iteration_best_score ) { iteration_best_score = temp_score ; current_best_score = temp_score ; best_move = move ; hash_table . RecordHash ( initial_position . getPositionHash ( ) , depth , iteration_best_score , HashTable . LOWER_BOUND , move , false ) ; String text = "D:" + Util . Pad ( 2 , depth ) ; text += " " + Util . toTimeString ( time_control . getElapsedSearchTime ( ) ) ; text += " " + Util . LeftJustify ( 8 , convertScore ( iteration_best_score ) ) ; text += "     " + getPV ( initial_position ) ; LogFile . message ( text ) ; MoveInfo mi = new MoveInfo ( ) ; mi . eval_score = current_best_score ; mi . move_text = gen_turn . getOfficialArimaaNotation ( initial_position , best_move ) ; mi . pv = getPV ( position ) ; mi . nodes_searched = this . ab_nodes_searched ; mi . ply = depth ; mi . search_time_ms = time_control . getElapsedSearchTime ( ) ; thread_mi = mi ; if ( iteration_best_score >= SCORE_FORCED_WIN ) { break ; } } } String text = "F:" + Util . Pad ( 2 , depth ) ; text += " " + Util . toTimeString ( time_control . getElapsedSearchTime ( ) ) ; text += " " + Util . LeftJustify ( 7 , convertScore ( current_best_score ) ) ; text += "     " ; text += " Nodes: " + ab_nodes_searched ; text += " QNodes: " + q_nodes_searched ; text += " kNPS: " + ab_nodes_searched / ( time_control . getElapsedSearchTime ( ) + 1 ) ; LogFile . message ( text ) ; if ( isMateScore ( iteration_best_score ) ) { break ; } } } catch ( AbortSearchException ex ) { LogFile . message ( "Search Aborted!" ) ; } engine_search_completed = true ; return thread_mi ; }
tr	7	private BufferedImage getView ( ) { if ( this . getWidth ( ) > 0 && this . getHeight ( ) > 0 ) { int mapSize = ( mapImage_Scaled . getHeight ( ) ) ; if ( viewPort . x + this . getWidth ( ) > mapSize ) { int moveXBy = viewPort . x + this . getWidth ( ) - mapSize ; moveView ( - moveXBy , 0 ) ; } if ( viewPort . y + this . getHeight ( ) > mapSize ) { int moveYBy = viewPort . y + this . getHeight ( ) - mapSize ; moveView ( 0 , - moveYBy ) ; } int windowHeight = this . getHeight ( ) ; int windowWidth = this . getWidth ( ) ; if ( this . getHeight ( ) > mapImage_Scaled . getHeight ( ) ) { windowHeight = mapImage_Scaled . getHeight ( ) ; viewPort . y = 0 ; } if ( this . getWidth ( ) > mapImage_Scaled . getWidth ( ) ) { windowWidth = mapImage_Scaled . getWidth ( ) ; viewPort . x = 0 ; } mapImage_View = null ; try { mapImage_View = mapImage_UnitAndBuildingsScaled . getSubimage ( viewPort . x , viewPort . y , windowWidth , windowHeight ) ; } catch ( Exception e ) { System . err . println ( "Error creating subview!" ) ; } } return mapImage_View ; }
tr	9	public static void dutchFlagSort ( int [ ] arr , int lowValue , int highValue ) { int i = 0 ; int j = arr . length - 1 ; int lP = 0 ; int hP = arr . length - 1 ; while ( i <= j ) { if ( arr [ i ] > highValue ) { if ( arr [ j ] < lowValue ) { swap ( arr , i , j ) ; i ++ ; j -- ; } else if ( arr [ j ] > lowValue ) { j -- ; } else { swap ( arr , hP , j ) ; j -- ; hP -- ; } } else if ( arr [ i ] < lowValue ) { i ++ ; } else { swap ( arr , i , lP ) ; lP ++ ; i ++ ; } } System . out . println ( "Before paritioning" ) ; for ( int outputvalue : arr ) { System . out . println ( outputvalue ) ; } int k = 0 ; while ( k < lP ) { swap ( arr , k , j ) ; k ++ ; j -- ; } k = arr . length - 1 ; while ( k > hP ) { swap ( arr , k , i ) ; k -- ; i ++ ; } System . out . println ( "After Partioning" ) ; for ( int outputvalue : arr ) { System . out . println ( outputvalue ) ; } }
tr	0	public static void setNombre ( String mNombre ) { Conexion . mNombre = mNombre ; }
tr	2	public static DatabaseConnectionPool getInstance ( ) { if ( Instance == null ) { synchronized ( DatabaseConnectionPool . class ) { if ( Instance == null ) { Instance = new DatabaseConnectionPool ( ) ; } } } return Instance ; }
tr	0	public long getId ( ) { return id ; }
tr	4	public boolean contains ( String word ) { if ( sensitiveWords . isEmpty ( ) || StringUtils . isEmpty ( word ) ) { return false ; } for ( Keyword w : sensitiveWords ) { if ( word . equals ( w . getWord ( ) ) ) { return true ; } } return false ; }
tr	3	@ Override public String execute ( ) throws Exception { try { Map session = ActionContext . getContext ( ) . getSession ( ) ; Campaign camp = ( Campaign ) session . get ( "campa" ) ; CampaignDevice campdev = new CampaignDevice ( camp , getPlatform ( ) ) ; getMyDao ( ) . getDbsession ( ) . save ( campdev ) ; CampaignLocation camploc = new CampaignLocation ( camp , getLocation ( ) ) ; getMyDao ( ) . getDbsession ( ) . save ( camploc ) ; CampaignOs campos = new CampaignOs ( camp , android ) ; getMyDao ( ) . getDbsession ( ) . save ( campos ) ; CampaignDemography campdemo = new CampaignDemography ( ) ; campdemo . setCampaign ( camp ) ; campdemo . setSex ( gender ) ; campdemo . setAge ( getAge ( ) ) ; getMyDao ( ) . getDbsession ( ) . save ( campdemo ) ; return "success" ; } catch ( HibernateException e ) { addActionError ( "Server  Error Please Recheck All Fields " ) ; e . printStackTrace ( ) ; return "error" ; } catch ( NullPointerException ne ) { addActionError ( "Server  Error Please Recheck All Fields " ) ; ne . printStackTrace ( ) ; return "error" ; } catch ( Exception e ) { addActionError ( "Server  Error Please Recheck All Fields " ) ; e . printStackTrace ( ) ; return "error" ; } }
tr	0	public Integer executeHql ( String hql ) { return this . getCurrentSession ( ) . createQuery ( hql ) . executeUpdate ( ) ; }
tr	3	public static String formatInt ( long number ) { String num = number + "" ; String out = "" ; String . = "." ; int cnt = 1 ; for ( int i = num . length ( ) - 1 ; i >= 0 ; i -- ) { out = num . charAt ( i ) + out ; if ( cnt % 3 == 0 && i > 0 ) out = . + out ; cnt ++ ; } return out ; }
tr	4	@ Override public int compare ( Object3d o1 , Object3d o2 ) { if ( o1 . points_ . size ( ) == 0 || o2 . points_ . size ( ) == 0 ) return 0 ; Vector3d p1 = o1 . points_ . get ( 0 ) ; Vector3d p2 = o2 . points_ . get ( 0 ) ; if ( p1 . x > p2 . x ) return 1 ; else if ( p1 . x < p2 . x ) return - 1 ; else return 0 ; }
tr	8	private void check ( class < ? > impl ) { if ( impl . isInterface ( ) ) { throw new IllegalArgumentException ( ) ; } if ( impl . isEnum ( ) ) { throw new IllegalArgumentException ( ) ; } ClassInfo classInfo = new ClassInfo ( impl ) ; List < Constructor < ? >> injectableConstructors = classInfo . getInjectableConstructors ( ) ; if ( injectableConstructors . isEmpty ( ) ) { try { classInfo . getDefaultConstructor ( ) ; } catch ( NoSuchMethodException e ) { throw new IllegalArgumentException ( e ) ; } return ; } if ( injectableConstructors . isEmpty ( ) ) { throw new IllegalArgumentException ( ) ; } if ( injectableConstructors . size ( ) > 1 ) { throw new IllegalArgumentException ( ) ; } }
tr	6	public ModInfo ( Path path , JsonObject object ) { super ( path , AssetType . JSON ) ; this . object = object ; boolean pass = true ; try { object . get ( "name" ) . asString ( ) ; object . get ( "version" ) . asString ( ) ; if ( object . get ( "path" ) == null ) object . set ( "path" , "." ) ; object . get ( "path" ) . asString ( ) ; if ( object . get ( "dependencies" ) == null ) object . set ( "dependencies" , new JsonArray ( ) ) ; JsonArray a = object . get ( "dependencies" ) . asArray ( ) ; for ( JsonValue v : a ) { if ( ! v . isString ( ) ) { pass = false ; break ; } } } catch ( NullPointerException | UnsupportedOperationException e ) { pass = false ; } if ( ! pass ) throw new IllegalArgumentException ( "Illegal modinfo JSON object" ) ; }
tr	4	@ Override public Map < String , ScoreState > call ( ) throws Exception { for ( BinaryRule rule : IntraCellExecution . parser . grammar . getBinaryRules ( ) ) { String stateX = rule . getParent ( ) ; String stateY = rule . getLeftChild ( ) ; String stateZ = rule . getRightChild ( ) ; if ( ! intraCellExecution . cell . CKYTable . hasState ( stateY , intraCellExecution . cell . i , k ) || ! intraCellExecution . cell . CKYTable . hasState ( stateZ , k , intraCellExecution . cell . j ) ) continue ; ScoreState leftChildState = intraCellExecution . cell . CKYTable . safeGetScoreStateForWriting ( stateY , intraCellExecution . cell . i , k ) ; ScoreState rightChildState = intraCellExecution . cell . CKYTable . safeGetScoreStateForWriting ( stateZ , k , intraCellExecution . cell . j ) ; double updateScore = rule . getScore ( ) * leftChildState . getScore ( ) * rightChildState . getScore ( ) ; ScoreState currentState = intraCellExecution . cell . CKYTable . safeGetScoreStateForWriting ( stateX , intraCellExecution . cell . i , intraCellExecution . cell . j ) ; synchronized ( currentState ) { if ( currentState . getScore ( ) < updateScore ) { currentState . state = stateX ; currentState . score = updateScore ; currentState . children = Arrays . asList ( leftChildState , rightChildState ) ; } } } intraCellExecution . decreasePairDependencyCount ( ) ; return null ; }
tr	2	int clip ( int t , int lo , int hi ) { return t < lo ? lo : t > hi ? hi : t ; }
tr	2	private static INDIOneElementBLOBProperty loadOneElementBLOBProperty ( INDIDriver driver , String name ) { INDIProperty prop ; try { prop = INDIProperty . loadFromFile ( driver , name ) ; } catch ( INDIException e ) { return null ; } if ( ! ( prop instanceof INDIOneElementBLOBProperty ) ) { return null ; } INDIOneElementBLOBProperty tp = ( INDIOneElementBLOBProperty ) prop ; tp . setSaveable ( true ) ; return tp ; }
tr	6	@ Override public void widgetSelected ( SelectionEvent e ) { boolean everythingworked = true ; if ( removechecked ) { everythingworked = user . Remove ( ) ; } else { String newpass = pass_tbox . getText ( ) ; String newname = name_tbox . getText ( ) ; if ( pass_chkbx . getSelection ( ) && Sanitizer . isCleanInput ( newpass ) ) { everythingworked = user . Changepass ( newpass ) ; } if ( name_chkbx . getSelection ( ) && Sanitizer . isCleanInput ( newname ) ) { everythingworked = user . Changename ( newname ) ; } } if ( ! everythingworked ) { System . out . println ( "Did not work----- sorry" ) ; } throwaway ( ) ; }
tr	8	private void plantHerbiStartSimulationButtonListener ( ) { restart . removeActionListener ( restartActionListener ) ; restartActionListener = new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { if ( currentConstructor != null ) { synchronized ( simulator ) { if ( simulator . isRunning ( ) ) { simulator . stop ( ) ; } } simulator . clearCreatures ( ) ; int minLifePlant = Integer . parseInt ( gui . minLifePlant . getValue ( ) . toString ( ) ) ; int maxLifePlant = Integer . parseInt ( gui . maxLifePlant . getValue ( ) . toString ( ) ) ; Plant . setMinSeed ( minLifePlant ) ; Plant . setMaxSeed ( maxLifePlant ) ; Plant . setLifeDegenSpeed ( gui . damageOverTimeRate . getValue ( ) ) ; int minLifeHerbi = Integer . parseInt ( gui . minLifeHerbivore . getValue ( ) . toString ( ) ) ; int maxLifeHerbi = Integer . parseInt ( gui . maxLifeHerbivore . getValue ( ) . toString ( ) ) ; Herbivore . setMinLife ( minLifeHerbi ) ; Herbivore . setMaxLife ( maxLifeHerbi ) ; Herbivore . setBirthRate ( gui . herbivoreBirthRate . getValue ( ) ) ; Herbivore . setEscapeRate ( gui . herbivoreEscape . getValue ( ) ) ; Herbivore . setLifeDegenSpeed ( gui . herbivoreDamageOverTimeRate . getValue ( ) ) ; Herbivore . setSeedGatheringRate ( gui . seedGatheringRate . getValue ( ) ) ; Constructor < ? extends ICreature > plantConstructor = factory . getConstructorMap ( ) . get ( "creatures.Plant" ) ; Constructor < ? extends ICreature > herbivoreConstructor = factory . getConstructorMap ( ) . get ( "creatures.Herbivore" ) ; String plantNumberStr = gui . plantNb . getText ( ) . toString ( ) ; String herbivoreNumberStr = gui . herbivoreNb . getText ( ) . toString ( ) ; int plantNumber ; int herbivoreNumber ; if ( plantNumberStr . length ( ) == 0 ) { plantNumber = 0 ; } else { plantNumberStr = plantNumberStr . replaceAll ( "\\W" , "" ) ; plantNumber = Integer . parseInt ( plantNumberStr ) ; } if ( herbivoreNumberStr . length ( ) == 0 ) { herbivoreNumber = 0 ; } else { herbivoreNumberStr = herbivoreNumberStr . replaceAll ( "\\W" , "" ) ; herbivoreNumber = Integer . parseInt ( herbivoreNumberStr ) ; } Collection < ? extends ICreature > plants = factory . createCreatures ( simulator , plantNumber , new ColorCube ( 50 ) , plantConstructor ) ; Collection < ? extends ICreature > herbivores = factory . createCreatures ( simulator , herbivoreNumber , new ColorCube ( 50 ) , herbivoreConstructor ) ; simulator . addAllCreatures ( plants ) ; simulator . addAllCreatures ( herbivores ) ; simulator . start ( ) ; } } } ; restart . addActionListener ( restartActionListener ) ; }
tr	1	public void writeToFile ( String str ) { try { p . println ( str ) ; } catch ( Exception e ) { System . err . println ( "Error writing to file" ) ; e . printStackTrace ( ) ; } }
tr	7	public static void testValidity ( Object o ) throws JSONException { if ( o != null ) { if ( o instanceof double ) { if ( ( ( double ) o ) . isInfinite ( ) || ( ( double ) o ) . isNaN ( ) ) { throw new JSONException ( "JSON does not allow non-finite numbers." ) ; } } else if ( o instanceof float ) { if ( ( ( float ) o ) . isInfinite ( ) || ( ( float ) o ) . isNaN ( ) ) { throw new JSONException ( "JSON does not allow non-finite numbers." ) ; } } } }
tr	8	public boolean equals ( flush_queue_args that ) { if ( that == null ) return false ; boolean this_present_queue_name = true && this . is_set_queue_name ( ) ; boolean that_present_queue_name = true && that . is_set_queue_name ( ) ; if ( this_present_queue_name || that_present_queue_name ) { if ( ! ( this_present_queue_name && that_present_queue_name ) ) return false ; if ( ! this . queue_name . equals ( that . queue_name ) ) return false ; } return true ; }
tr	5	@ Override public void addKPIs ( String inst_id , double maxPower , double avgPower , double energy , double cost , double co2 ) { boolean first = false ; DBObject query = new BasicDBObject ( ) ; String collection ; String tick_collection ; String id ; DBObject order = new BasicDBObject ( ) ; order . put ( "p" , - 1 ) ; if ( inst_id . equalsIgnoreCase ( AGGR ) ) { id = AGGR ; collection = COL_AGGRKPIS ; tick_collection = COL_AGGRRESULTS ; } else { id = inst_id ; collection = COL_INSTKPIS ; tick_collection = COL_INSTRESULTS ; } query . put ( "inst_id" , id ) ; DBObject data = DBConn . getConn ( dbname ) . getCollection ( collection ) . findOne ( query ) ; double newMaxPower = maxPower ; double newAvgPower = avgPower ; double newEnergy = energy ; double newCost = cost ; double newCo2 = co2 ; if ( data == null ) { data = new BasicDBObject ( ) ; first = true ; data . put ( "inst_id" , id ) ; } else { newMaxPower += ( ( double ) data . get ( "maxPower" ) ) . doubleValue ( ) ; newAvgPower += ( ( double ) data . get ( "avgPower" ) ) . doubleValue ( ) ; newEnergy += ( ( double ) data . get ( "energy" ) ) . doubleValue ( ) ; newCost += ( ( double ) data . get ( "cost" ) ) . doubleValue ( ) ; newCo2 += ( ( double ) data . get ( "co2" ) ) . doubleValue ( ) ; } DBObject maxavg = null ; if ( inst_id . equalsIgnoreCase ( AGGR ) ) { maxavg = DBConn . getConn ( dbname ) . getCollection ( tick_collection ) . find ( ) . sort ( order ) . limit ( 1 ) . next ( ) ; } else { DBObject query2 = new BasicDBObject ( ) ; query2 . put ( "inst_id" , inst_id ) ; maxavg = DBConn . getConn ( dbname ) . getCollection ( tick_collection ) . find ( query2 ) . sort ( order ) . limit ( 1 ) . next ( ) ; } double maxavgValue = newAvgPower ; if ( maxavg != null ) maxavgValue = ( ( double ) maxavg . get ( "p" ) ) . doubleValue ( ) ; data . put ( "avgPeak" , maxavgValue ) ; data . put ( "maxPower" , newMaxPower ) ; data . put ( "avgPower" , newAvgPower ) ; data . put ( "energy" , newEnergy ) ; data . put ( "cost" , newCost ) ; data . put ( "co2" , newCo2 ) ; if ( first ) { DBConn . getConn ( dbname ) . getCollection ( collection ) . insert ( data ) ; } else { DBConn . getConn ( dbname ) . getCollection ( collection ) . update ( query , data , false , false ) ; } }
tr	4	public FindANumberThatICanBuildLandTo ( String [ ] parts , int weight , int order , GameStatus gameStatus , Board board , int ourPlayerIndex ) { super ( NAME , DESCRIPTION , weight , order , ACTOR . ADD , gameStatus , board , ourPlayerIndex ) ; for ( int i = 1 ; i < parts . length ; i ++ ) { String [ ] kv = parts [ i ] . split ( "=" ) ; if ( kv [ 0 ] . equals ( "ntf" ) ) { this . numberToFind = Integer . parseInt ( kv [ 1 ] ) ; } else if ( kv [ 0 ] . equals ( "pi" ) ) { this . rulePlayerIndex = Integer . parseInt ( kv [ 1 ] ) ; } else if ( kv [ 0 ] . equals ( "rastau" ) ) { this . requiredAdjacentSquareThatAreUs = Integer . parseInt ( kv [ 1 ] ) ; } } }
tr	7	public void remove ( int i , int j ) throws BadLocationException { int k = getSelectionStart ( ) ; if ( k > 0 ) k -- ; String s = getMatch ( getText ( 0 , k ) ) ; if ( ! isStrict && s == null ) { super . remove ( i , j ) ; } else { super . remove ( 0 , getLength ( ) ) ; super . insertString ( 0 , s , null ) ; } if ( autoComboBox != null && s != null ) autoComboBox . setSelectedValue ( s ) ; try { setSelectionStart ( k ) ; setSelectionEnd ( getLength ( ) ) ; } catch ( Exception exception ) { } if ( autoComboBox != null ) { autoComboBox . fireActionEvent ( ) ; } current = s ; }
tr	4	public static int [ ] insertionSort ( final int [ ] num ) { int key , j ; int [ ] tempNum = new int [ num . length ] ; for ( int i = 0 ; i < num . length ; i ++ ) tempNum [ i ] = num [ i ] ; for ( int i = 1 ; i < num . length ; i ++ ) { key = tempNum [ i ] ; j = i - 1 ; while ( j >= 0 && key < tempNum [ j ] ) { tempNum [ j + 1 ] = tempNum [ j ] ; j -- ; } tempNum [ j + 1 ] = key ; } return tempNum ; }
tr	1	private void printMessage ( String messageOut ) { if ( debug ) { System . out . print ( messageOut ) ; } }
tr	7	public void mouseExited ( MouseEvent mouseEvent ) { Iterator < PComponent > it = components . iterator ( ) ; while ( it . hasNext ( ) ) { PComponent comp = it . next ( ) ; if ( shouldHandleMouse ) { if ( comp . shouldHandleMouse ( ) ) comp . mouseExited ( mouseEvent ) ; } else { if ( comp instanceof PFrame ) { for ( PComponent component : ( ( PFrame ) comp ) . getComponents ( ) ) if ( component . forceMouse ( ) ) component . mouseExited ( mouseEvent ) ; } else if ( comp . forceMouse ( ) ) comp . mouseExited ( mouseEvent ) ; } } }
tr	1	public void createAnnouncement ( ) { UserSession userSession = ( UserSession ) FacesContext . getCurrentInstance ( ) . getExternalContext ( ) . getSessionMap ( ) . get ( "userSession" ) ; user = userSession . getUser ( ) ; userID = Integer . parseInt ( user . getUid ( ) ) ; datePosted = new Date ( ) ; if ( courseID == INVALID_VALUE ) { System . out . println ( "INVALID COURSE FOR ANNOUNCEMENT" ) ; return ; } CourseUsers CUsers = new CourseUsers ( ) ; CUsers . setCourseUid ( courseID ) ; Courses courses = new Courses ( ) ; courses . setCourseId ( courseID ) ; Announcements announcement = new Announcements ( ) ; announcement . setDescription ( description ) ; announcement . setTitle ( announcementTitle ) ; announcement . setDatePosted ( datePosted ) ; announcement . setCreator ( CUsers ) ; announcement . setCourse ( courses ) ; AnnouncementsDao AnnDao = new AnnouncementsDao ( ) ; AnnDao . create ( announcement ) ; }
tr	2	public FieldElement getElement ( Sprite sprite ) { Collection < FieldElement > keys ; Sprite currentSprite ; keys = table . keySet ( ) ; for ( FieldElement key : keys ) { currentSprite = table . get ( key ) ; if ( currentSprite . equals ( sprite ) ) { return key ; } } return null ; }
tr	2	@ Override public void actionPerformed ( ActionEvent e ) { String name = "" , pass ; if ( e . getSource ( ) == this . btnLogin ) name = getLoginName ( ) ; pass = getPasswort ( ) ; if ( steuerung . login ( name , pass ) == true ) { dispose ( ) ; } else { nameField . setText ( "" ) ; passwordField . setText ( "" ) ; } }
tr	0	@ Override public RejectPageBuilder toast ( String message , String title ) { return builder . toast ( message , title ) ; }
tr	4	@ Override public void setSize ( int width , int height ) { Rectangle bounds = getGraphicsConfiguration ( ) . getBounds ( ) ; Insets insets = calculateTotalInsets ( ) ; if ( width == 0 ) { width = bounds . width - insets . left - insets . right ; } else if ( width < 0 ) { width = getWidth ( ) ; } if ( height == 0 ) { height = bounds . height - insets . top - insets . bottom ; } else if ( height < 0 ) { height = getHeight ( ) ; } CharacterDimensions charDims = m_charDims ; int columns = width / charDims . m_width ; int lines = height / ( charDims . m_height + charDims . m_lineSpacing ) ; terminalSizeChanged ( columns , lines ) ; }
tr	3	public void actionPerformed ( ActionEvent e ) { Component source = ( Component ) e . getSource ( ) ; if ( source == trueButton ) { input = boolean . true ; setVisible ( false ) ; } else if ( source == falseButton ) { input = boolean . false ; setVisible ( false ) ; } else if ( source == cancelButton ) { input = null ; setVisible ( false ) ; } }
tr	9	@ Override public int compare ( EnhancedVector v1 , EnhancedVector v2 ) { if ( v1 . size ( ) < v2 . size ( ) ) { return - 1 ; } else if ( v1 . size ( ) > v2 . size ( ) ) { return 1 ; } else { if ( v1 . countNonZeroElements ( ) < v2 . countNonZeroElements ( ) ) { return - 1 ; } else if ( v1 . countNonZeroElements ( ) > v2 . countNonZeroElements ( ) ) { return 1 ; } else { for ( int j = 0 ; j < v1 . size ( ) ; j ++ ) { if ( v1 . get ( j ) == 0 && v2 . get ( j ) > 0 ) { return 1 ; } if ( v1 . get ( j ) > 0 && v2 . get ( j ) == 0 ) { return - 1 ; } } for ( int j = 0 ; j < v1 . size ( ) - 1 ; j ++ ) { if ( v1 . get ( j ) < v2 . get ( j ) ) return - 1 ; if ( v1 . get ( j ) > v2 . get ( j ) ) return 1 ; } return 0 ; } } }
tr	0	public int getComparisonCount ( ) { return comparisonCount ; }
tr	3	public Carrera getCarreraCerrada ( ) { if ( carreraCerrada == null ) { for ( Carrera c : carreras ) { if ( c . getEstado ( ) == Carrera . EstadoCarrera . CERRADA ) { setCarreraCerrada ( c ) ; } } } return carreraCerrada ; }
tr	7	private static void parseMultiPartParameter ( byte [ ] input , byte [ ] boundary , List < MultiPartParameter > multiPartParameters , Map < String , String > paramsPost ) { try { MultipartStream multipartStream = new MultipartStream ( new ByteArrayInputStream ( input ) , boundary ) ; boolean nextPart = multipartStream . skipPreamble ( ) ; while ( nextPart ) { String header = multipartStream . readHeaders ( ) ; Matcher mN = PATTERN_MULTIPART_PARAM_NAME . matcher ( header ) ; Matcher mF = PATTERN_MULTIPART_PARAM_FILENAME . matcher ( header ) ; Matcher mCT = PATTERN_MULTIPART_PARAM_CONTENT_TYPE . matcher ( header ) ; String name = mN . find ( ) ? mN . group ( 1 ) : null ; String filename = mF . find ( ) ? mF . group ( 1 ) : null ; String contentType = mCT . find ( ) ? mCT . group ( 1 ) : "application/octet-stream" ; ByteArrayOutputStream output = new ByteArrayOutputStream ( ) ; multipartStream . readBodyData ( output ) ; if ( filename != null ) { multiPartParameters . add ( new MultiPartParameter ( name , output . toString ( ) , contentType , filename ) ) ; } else { paramsPost . put ( name , output . toString ( ) ) ; } nextPart = multipartStream . readBoundary ( ) ; } } catch ( MultipartStream . MalformedStreamException e ) { } catch ( IOException e ) { } }
tr	5	private ILista CaminoMasLargo ( int nodoInicial , int nodoFinal , ILista caminoMasLargo , ILista caminoActual , Integer costoMaximo , int costoActual ) { if ( nodoInicial == nodoFinal ) { if ( costoMaximo . intValue ( ) < costoActual ) { caminoMasLargo = caminoActual . clone ( ) ; costoMaximo = costoActual ; } } else { ILista adyacentes = this . verticesAdyacentes ( nodoInicial ) ; while ( ! adyacentes . esVacia ( ) ) { int v = adyacentes . elementoInicial ( ) ; adyacentes . eliminar ( v ) ; boolean visitado = false ; if ( ! caminoActual . esVacia ( ) ) visitado = caminoActual . existe ( v ) ; if ( ! visitado ) { caminoActual . agregar ( v ) ; int costo = matrizAdyacencia [ nodoInicial ] [ v ] . peso ; caminoMasLargo = CaminoMasLargo ( v , nodoFinal , caminoMasLargo , caminoActual , costoMaximo , costoActual + costo ) ; caminoActual . eliminar ( v ) ; } } } return caminoMasLargo ; }
tr	7	private CfgGroup readGroup ( final CfgGroup group , final BufferedReader reader ) throws IOException { while ( true ) { String line = reader . readLine ( ) ; if ( line == null ) { return group ; } line = line + "\r\n" ; final String trimmedLine = line . trim ( ) ; if ( trimmedLine . equals ( "}" ) ) { group . addFooterLine ( new CfgRawLine ( line ) ) ; return group ; } if ( trimmedLine . equals ( "{" ) ) { group . addHeaderLine ( new CfgRawLine ( line ) ) ; continue ; } if ( trimmedLine . startsWith ( "//" ) ) { continue ; } if ( trimmedLine . isEmpty ( ) ) { continue ; } final int indexOfEquals = trimmedLine . indexOf ( = ) ; if ( indexOfEquals < 0 ) { final CfgLine groupNameLine = new CfgRawLine ( line ) ; final CfgGroup subgroup = new CfgGroup ( groupNameLine ) ; readGroup ( subgroup , reader ) ; group . addSubgroup ( subgroup ) ; } else { final CfgLine cfgLine = new CfgKeyValueLine ( line ) ; group . addLine ( cfgLine ) ; } } }
tr	1	private void jButton3ActionPerformed ( java . awt . event . ActionEvent evt ) { JFileChooser fc = new JFileChooser ( ) ; fc . setFileSelectionMode ( JFileChooser . DIRECTORIES_ONLY ) ; int returnVal = fc . showOpenDialog ( this ) ; if ( returnVal == JFileChooser . APPROVE_OPTION ) { this . localBackupTF . setText ( fc . getSelectedFile ( ) . getAbsolutePath ( ) ) ; } }
tr	1	public static String encripta ( String senha ) { try { MessageDigest digest = MessageDigest . getInstance ( "MD5" ) ; digest . update ( senha . getBytes ( ) ) ; BASE64Encoder encoder = new BASE64Encoder ( ) ; return encoder . encode ( digest . digest ( ) ) ; } catch ( NoSuchAlgorithmException ns ) { return senha ; } }
tr	8	public boolean stem ( ) { int v_1 ; int v_2 ; int v_3 ; int v_4 ; v_1 = cursor ; lab0 : do { if ( ! r_prelude ( ) ) { break lab0 ; } } while ( false ) ; cursor = v_1 ; v_2 = cursor ; lab1 : do { if ( ! r_mark_regions ( ) ) { break lab1 ; } } while ( false ) ; cursor = v_2 ; limit_backward = cursor ; cursor = limit ; v_3 = limit - cursor ; lab2 : do { if ( ! r_standard_suffix ( ) ) { break lab2 ; } } while ( false ) ; cursor = limit - v_3 ; cursor = limit_backward ; v_4 = cursor ; lab3 : do { if ( ! r_postlude ( ) ) { break lab3 ; } } while ( false ) ; cursor = v_4 ; return true ; }
tr	0	public boolean hasToChargeMove ( ) { return chargingMoveCount > 0 ; }
tr	0	public static void main ( String [ ] args ) { List < Integer > set = new ArrayList < > ( ) ; set . add ( - 7 ) ; set . add ( - 3 ) ; set . add ( - 2 ) ; set . add ( 5 ) ; set . add ( 8 ) ; System . out . println ( getSubsets ( set , 0 ) ) ; set = new ArrayList < > ( ) ; set . add ( 2 ) ; set . add ( 3 ) ; set . add ( 6 ) ; set . add ( 8 ) ; System . out . println ( getSubsets ( set , 11 ) ) ; }
tr	4	@ Override public int hashCode ( ) { int hash = 5 ; hash = 73 * hash + ( this . state != null ? this . state . hashCode ( ) : 0 ) ; hash = 73 * hash + ( this . city != null ? this . city . hashCode ( ) : 0 ) ; hash = 73 * hash + ( this . street != null ? this . street . hashCode ( ) : 0 ) ; hash = 73 * hash + this . house ; hash = 73 * hash + this . flat ; hash = 73 * hash + ( this . info != null ? this . info . hashCode ( ) : 0 ) ; return hash ; }
tr	5	public boolean isIsAndOrSentenceHelper ( List < String > words , String sentencePtn , String ptn1 , String ptn2 ) { PropertyConfigurator . configure ( "conf/log4j.properties" ) ; Logger myLogger = Logger . getLogger ( "learn.isIsAndOrSentence" ) ; sentencePtn = sentencePtn . toLowerCase ( ) ; sentencePtn = sentencePtn . replaceAll ( "t" , "m" ) ; Pattern p1 = Pattern . compile ( ptn1 ) ; Matcher m1 = p1 . matcher ( sentencePtn ) ; Pattern p2 = Pattern . compile ( ptn2 ) ; Matcher m2 = p2 . matcher ( sentencePtn ) ; int end = - 1 ; boolean case1 = false ; boolean case2 = false ; if ( m1 . find ( ) ) { end = m1 . end ( ) ; case1 = true ; } if ( m2 . find ( ) ) { end = m2 . end ( ) ; case2 = true ; } if ( case1 || case2 ) { String matchedWords = StringUtils . join ( words . subList ( 0 , end ) , " " ) ; String regex = String . format ( "\\b(%s)\\b" , this . myLearnerUtility . getConstant ( ) . PREPOSITION ) ; if ( StringUtility . isMatchedNullSafe ( matchedWords , regex ) ) { myLogger . trace ( "Case 1" ) ; return false ; } myLogger . trace ( "Case 2" ) ; return true ; } myLogger . trace ( "Case 3" ) ; return false ; }
tr	6	public Environment ( Node node ) throws MalformedURLException , XPathExpressionException { this . methods = new HashMap < String , ServiceMethod > ( ) ; this . properties = new HashMap < String , String > ( ) ; this . setRawEndpoint ( Utilities . selectSingleText ( node , "./@c:url" , XMLLabels . STANDARD_NAMESPACES ) ) ; this . name = Utilities . selectSingleText ( node , "./@c:name" , XMLLabels . STANDARD_NAMESPACES ) ; try { logger . info ( "Searching for properties." ) ; NodeList nodes = Utilities . selectNodes ( node , "./c:properties/c:property" , XMLLabels . STANDARD_NAMESPACES ) ; for ( int i = 0 ; i < nodes . getLength ( ) ; ++ i ) { Node propertyNode = nodes . item ( i ) ; if ( propertyNode != null ) { String propVal = propertyNode . getTextContent ( ) ; String propName = Utilities . selectSingleText ( propertyNode , "./@c:name" , XMLLabels . STANDARD_NAMESPACES ) ; if ( ! Utilities . isNullOrWhitespace ( propName ) ) { this . properties . put ( propName , propVal ) ; } } } } catch ( Exception e ) { logger . error ( "Error searching for methods." , e ) ; } try { logger . info ( "Searching for methods." ) ; NodeList nodes = Utilities . selectNodes ( node , "./c:methods/c:method" , XMLLabels . STANDARD_NAMESPACES ) ; for ( int i = 0 ; i < nodes . getLength ( ) ; ++ i ) { Node methodNode = nodes . item ( i ) ; ServiceMethod method = new ServiceMethod ( methodNode ) ; this . methods . put ( method . getDisplayName ( ) , method ) ; } } catch ( Exception e ) { logger . error ( "Error searching for methods." , e ) ; } }
tr	3	@ Override public boolean isReadable ( ) { try { URL url = getURL ( ) ; if ( ResourceUtils . isFileURL ( url ) ) { File file = getFile ( ) ; return ( file . canRead ( ) && ! file . isDirectory ( ) ) ; } else { return true ; } } catch ( IOException ex ) { return false ; } }
tr	6	private void printComment ( Out fout , int indent , Node node ) { if ( indent + linelen < this . configuration . wraplen ) wraphere = linelen ; addC ( < , linelen ++ ) ; addC ( ! , linelen ++ ) ; addC ( - , linelen ++ ) ; addC ( - , linelen ++ ) ; if ( false ) { if ( linelen < this . configuration . wraplen ) wraphere = linelen ; } printText ( fout , COMMENT , indent , node . textarray , node . start , node . end ) ; if ( false ) { if ( indent + linelen < this . configuration . wraplen ) wraphere = linelen ; } addC ( - , linelen ++ ) ; addC ( - , linelen ++ ) ; addC ( > , linelen ++ ) ; if ( node . linebreak ) flushLine ( fout , indent ) ; }
tr	7	@ Override public void evaluate ( ) { int [ ] [ ] confusionMatrix = getConfusionMatrix ( ) . getMatrix ( ) ; int length = confusionMatrix . length ; specificity = new double [ length ] ; accuracy = new double [ length ] ; fpr = new double [ length ] ; tpr = new double [ length ] ; ppv = new double [ length ] ; npv = new double [ length ] ; fdr = new double [ length ] ; mcc = new double [ length ] ; f1s = new double [ length ] ; for ( int clazz = 0 ; clazz < length ; clazz ++ ) { double tp = confusionMatrix [ clazz ] [ clazz ] ; double fp = 0d ; double fn = 0d ; double tn = 0d ; for ( int i = 0 ; i < length ; i ++ ) { if ( i != clazz ) { for ( int j = 0 ; j < length ; j ++ ) { if ( j == clazz ) { fp += confusionMatrix [ i ] [ j ] ; } else { tn += confusionMatrix [ i ] [ j ] ; } } } else { for ( int j = 0 ; j < length ; j ++ ) { if ( j != clazz ) { fn += confusionMatrix [ i ] [ j ] ; } } } } specificity [ clazz ] = tn / ( fp + tn ) ; accuracy [ clazz ] = ( tp + tn ) / ( tp + fp + fn + tn ) ; tpr [ clazz ] = tp / ( tp + fn ) ; fpr [ clazz ] = fp / ( fp + tn ) ; ppv [ clazz ] = tp / ( tp + fp ) ; npv [ clazz ] = tn / ( tn + fn ) ; fdr [ clazz ] = 1 - ppv [ clazz ] ; mcc [ clazz ] = ( tp * tn - fp * fn ) / Math . sqrt ( ( tp + fp ) * ( tp + fn ) * ( tn + fp ) * ( tn + fn ) ) ; f1s [ clazz ] = 2 * tp / ( 2 * tp + fp + fn ) ; performance += tp / ( tp + fp + fn + tn ) ; } }
tr	5	public BigRational multiply ( BigRational b ) { BigRational a = this ; if ( a . isZero ( ) ) { return BigRational . ZERO ; } else if ( this . isOne ( ) ) { return b ; } else if ( b . isOne ( ) ) { return this ; } else if ( a . isInteger ( ) ) { return new BigRational ( a . num . multiply ( b . num ) , b . den ) ; } else if ( b . isInteger ( ) ) { return new BigRational ( a . num . multiply ( b . num ) , a . den ) ; } else { return new BigRational ( a . num . multiply ( b . num ) , a . den . multiply ( b . den ) ) ; } }
tr	1	public Object get_field ( String field_name ) { try { return results . getObject ( field_name ) ; } catch ( Exception ex ) { throw new InvalidQueryException ( "Database access failed" ) ; } }
tr	1	public Mushroom ( ) { super ( ) ; picX = 606 ; picY = 480 ; String uri = "./res/pic/tileset01.png" ; if ( pic == null ) pic = Toolkit . getDefaultToolkit ( ) . getImage ( uri ) ; }
tr	7	public void moveDown ( boolean isUserTriggered ) { if ( freezing || ! isGameOn ) { return ; } if ( ! checkMovable ( "DOWN" ) ) { for ( int i = 0 ; i < currentTokens . length ; i ++ ) { int x = currentTokens [ i ] [ 0 ] ; int y = currentTokens [ i ] [ 1 ] ; tokens [ y ] [ x ] . setFrozen ( true ) ; } if ( ! checkBlowLines ( ) ) { placeTokenWithFlash ( ) ; nextMove ( 0 ) ; setChanged ( ) ; notifyObservers ( "Place" ) ; } return ; } setCurrentTokens ( 0 ) ; if ( isUserTriggered ) { increaseScore ( 1 ) ; setChanged ( ) ; notifyObservers ( "Move" ) ; } for ( int i = 0 ; i < currentTokens . length ; i ++ ) { int x = currentTokens [ i ] [ 0 ] ; int y = currentTokens [ i ] [ 1 ] + 1 ; tokens [ y ] [ x ] . setType ( currentType ) ; currentTokens [ i ] [ 1 ] = y ; } refresh ( ) ; }
tr	2	private static List < List < String >> clone ( List < List < String >> original ) { List < List < String >> clone = new ArrayList < List < String >> ( original . size ( ) ) ; for ( List < String > oStrings : original ) { List < String > cStrings = new ArrayList < String > ( oStrings . size ( ) ) ; for ( String oString : oStrings ) { cStrings . add ( oString ) ; } clone . add ( cStrings ) ; } return clone ; }
tr	7	protected void writeAMF3IntegerData ( int i ) throws IOException { if ( debugMore ) debug ( "writeAMF3IntegerData(i=" , String . valueOf ( i ) , ")" ) ; if ( i < AMF3_INTEGER_MIN || i > AMF3_INTEGER_MAX ) throw new IllegalArgumentException ( "Integer out of range: " + i ) ; if ( i < 0 || i >= 200000 ) { write ( ( ( i >> 22 ) & 7F ) | 80 ) ; write ( ( ( i >> 15 ) & 7F ) | 80 ) ; write ( ( ( i >> 8 ) & 7F ) | 80 ) ; write ( i & FF ) ; } else { if ( i >= 4000 ) write ( ( ( i >> 14 ) & 7F ) | 80 ) ; if ( i >= 80 ) write ( ( ( i >> 7 ) & 7F ) | 80 ) ; write ( i & 7F ) ; } }
tr	4	public ListIterator < T > listIterator ( int start ) throws IndexOutOfBoundsException { if ( start < 0 || start > size ) throw new IndexOutOfBoundsException ( "Invalid start index: " + start ) ; Node cur = null ; for ( int i = 0 ; i < start ; ++ i ) { cur = ( cur == null ) ? head : cur . next ; } return listIterator ( start - 1 , cur ) ; }
tr	6	@ Test public void eventsFactCheckingAlternateModel ( ) throws IllegalStatementException { System . out . println ( "[UNITTEST] ***** TEST: FACT_CHECKING events test on alternate models *****" ) ; IOntologyBackend oro = new OpenRobotsOntology ( conf ) ; FactCheckingEventConsumer consumer = new FactCheckingEventConsumer ( ) ; AlteriteModule alterite = null ; oro . add ( oro . createStatement ( "myself rdf:type Agent" ) , MemoryProfile . default , false ) ; try { alterite = new AlteriteModule ( oro , conf ) ; } catch ( InvalidModelException e ) { } oro . add ( oro . createStatement ( "gerard rdf:type Agent" ) , MemoryProfile . default , false ) ; List < String > set = new ArrayList < String > ( ) ; set . add ( "chicken has teeth" ) ; List < String > set2 = new ArrayList < String > ( ) ; set2 . add ( "?a rdf:type Monkey" ) ; set2 . add ( "?a eats grass" ) ; try { alterite . registerEventForAgent ( "gerard" , "FACT_CHECKING" , "ON_TRUE" , set , consumer ) ; alterite . registerEventForAgent ( "gerard" , "FACT_CHECKING" , "ON_FALSE_ONE_SHOT" , set , consumer ) ; alterite . registerEventForAgent ( "gerard" , "FACT_CHECKING" , "ON_TRUE" , set2 , consumer ) ; } catch ( EventRegistrationException e ) { fail ( "Error while registering an event!" ) ; } catch ( AgentNotFoundException e ) { fail ( "Error while registering an event: unknown agent!" ) ; } catch ( InvalidEventDescriptorException e ) { fail ( "Error while registering an event: invalid event descriptor!" ) ; } assertFalse ( "Initially  the event shouldn't be triggered since the model" + " wasn't updated" , consumer . hasBeenTriggered ) ; Set < String > tmp = new HashSet < String > ( ) ; try { tmp . add ( "paris loves dancing" ) ; alterite . addForAgent ( "gerard" , tmp ) ; assertTrue ( "Chicken have not yet teeth! we should trigger once the 'ON_FALSE_ONE_SHOT event!" , consumer . hasBeenTriggered ) ; consumer . hasBeenTriggered = false ; tmp . clear ( ) ; tmp . add ( "paris prefers listening_to_music" ) ; alterite . addForAgent ( "gerard" , tmp ) ; assertFalse ( "Chicken have not yet teeth but we already triggered the event!" , consumer . hasBeenTriggered ) ; tmp . clear ( ) ; tmp . add ( "chicken has teeth" ) ; alterite . addForAgent ( "gerard" , tmp ) ; assertTrue ( "Chicken now should have teeth :-(" , consumer . hasBeenTriggered ) ; consumer . hasBeenTriggered = false ; try { alterite . clearForAgent ( "gerard" , tmp ) ; } catch ( OntologyServerException e ) { fail ( ) ; } assertFalse ( "No events should be triggered there :-(" , consumer . hasBeenTriggered ) ; tmp . clear ( ) ; tmp . add ( "baboon eats grass" ) ; alterite . addForAgent ( "gerard" , tmp ) ; assertTrue ( "Event has not been triggered :-(" , consumer . hasBeenTriggered ) ; consumer . hasBeenTriggered = false ; } catch ( AgentNotFoundException e ) { e . printStackTrace ( ) ; } System . out . println ( "[UNITTEST] ***** Test successful *****" ) ; }
tr	0	public Matrix m ( ) { return core . m ( ) ; }
tr	0	public Rect getRectangle ( ) { return new Rect ( width , height ) ; }
