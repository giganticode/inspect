tr	1	public void displayPlayer ( ) { Iterator < PlayerID > iter = activePlayers . iterator ( ) ; PlayerID p ; System . out . println ( "--- PlayerIDs ---" ) ; while ( iter . hasNext ( ) ) { p = iter . next ( ) ; System . out . println ( "PlayerID: " + p . getPID ( ) + "  ConnectionID: " + p . getCID ( ) ) ; } }
tr	5	@ Override public void run ( ) { if ( input == null ) { try { input = new DataInputStream ( socket . getInputStream ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } while ( true ) { try { if ( ( buff = input . readUTF ( ) ) != null ) { consumer . consume ( buff ) ; } } catch ( IOException e ) { e . printStackTrace ( ) ; } } }
tr	4	public static void main ( String [ ] args ) { SelectionSort ss = new SelectionSort ( 10 ) ; System . out . println ( ss . toString ( ) ) ; for ( int i = 0 ; i < ss . sort . length ; i ++ ) { int min = ss . sort [ i ] ; int nr = 0 ; boolean changed = false ; for ( int j = i + 1 ; j < ss . sort . length ; j ++ ) { if ( ss . sort [ j ] < min ) { min = ss . sort [ j ] ; nr = j ; changed = true ; } } if ( changed ) { ss . sort [ nr ] = ss . sort [ i ] ; ss . sort [ i ] = min ; } ss . sorted ( ss . sort ) ; } ss . sorted ( ss . sort ) ; System . out . println ( ss . toString ( ) ) ; }
tr	4	private static HashMap < String , Integer > addToEndGroup ( HashMap < String , Integer > endGroups , String endGroup , int end ) { if ( endGroup != null ) { if ( endGroups == null ) endGroups = new HashMap < String , Integer > ( 2 ) ; Integer oldEnd = endGroups . get ( endGroup ) ; if ( oldEnd == null || end > oldEnd ) endGroups . put ( endGroup , end ) ; } return endGroups ; }
tr	6	public void method346 ( int i , int j ) { i += anInt1442 ; j += anInt1443 ; int l = i + j * DrawingArea . width ; int i1 = 0 ; int j1 = myHeight ; int k1 = myWidth ; int l1 = DrawingArea . width - k1 ; int i2 = 0 ; if ( j < DrawingArea . topY ) { int j2 = DrawingArea . topY - j ; j1 -= j2 ; j = DrawingArea . topY ; i1 += j2 * k1 ; l += j2 * DrawingArea . width ; } if ( j + j1 > DrawingArea . bottomY ) j1 -= ( j + j1 ) - DrawingArea . bottomY ; if ( i < DrawingArea . topX ) { int k2 = DrawingArea . topX - i ; k1 -= k2 ; i = DrawingArea . topX ; i1 += k2 ; l += k2 ; i2 += k2 ; l1 += k2 ; } if ( i + k1 > DrawingArea . bottomX ) { int l2 = ( i + k1 ) - DrawingArea . bottomX ; k1 -= l2 ; i2 += l2 ; l1 += l2 ; } if ( k1 <= 0 || j1 <= 0 ) { } else { method347 ( l , k1 , j1 , i2 , i1 , l1 , myPixels , DrawingArea . pixels ) ; } }
tr	3	public JSONWriter object ( ) throws JSONException { if ( this . mode == i ) { this . mode = o ; } if ( this . mode == o || this . mode == a ) { this . append ( "{" ) ; this . push ( new JSONObject ( ) ) ; this . , = false ; return this ; } throw new JSONException ( "Misplaced object." ) ; }
tr	5	public void synchronizeMod ( final ModModel modModel , final int rowIndex ) { try { LOGGER . log ( Level . INFO , Localization . translate ( "ModTableModel.synchronizeMod.synchronizing" , modModel ) ) ; final IMod mod = modModel . getMod ( ) ; final File f = new File ( Config . getModsFolder ( ) , mod . getId ( ) + ".zip" ) ; if ( ! f . exists ( ) ) { if ( modModel . isInstalled ( ) ) { modModel . setVersion ( null ) ; modModel . setInstalled ( false ) ; fireTableRowsUpdated ( rowIndex , rowIndex ) ; } } else { try { final FullVersion version = Utils . getVersion ( f ) ; final IUpdate u = mod . getUpdate ( version ) ; if ( ! u . equals ( modModel . getVersion ( ) ) ) { modModel . setVersion ( u ) ; modModel . setInstalled ( true ) ; fireTableRowsUpdated ( rowIndex , rowIndex ) ; } } catch ( final Exception e ) { f . delete ( ) ; modModel . setVersion ( null ) ; modModel . setInstalled ( false ) ; fireTableRowsUpdated ( rowIndex , rowIndex ) ; } } } catch ( final Exception e ) { LOGGER . log ( Level . SEVERE , Localization . translate ( "ModTableModel.synchronizeMod.Exception" ) , e ) ; } }
tr	0	public int hashCode ( ) { return Cafe123 ; }
tr	2	@ Override public int compareTo ( PathNode o ) { if ( cost < o . cost ) return - 1 ; if ( cost > o . cost ) return 1 ; return 0 ; }
tr	0	@ Test public void answerTest2 ( ) { Recommendation rec = new Recommendation ( ) ; rec . setSelf ( false ) ; rec . setSender ( first ) ; rec . setWriter ( second ) ; rec . setSubject ( third ) ; recommendationsDao . putQuery ( rec ) ; recommendationsDao . processAnswer ( 1 , "blablabla" ) ; assert . assertEquals ( "blablabla" , ( ( Recommendation ) recommendationsDao . getInbox ( 1 ) . iterator ( ) . next ( ) ) . getMessage ( ) ) ; }
tr	5	private void calcEntityScreenPos ( int i , int j , int l ) { if ( i < 128 || l < 128 || i > 13056 || l > 13056 ) { spriteDrawX = - 1 ; spriteDrawY = - 1 ; return ; } int i1 = method42 ( plane , l , i ) - j ; i -= xCameraPos ; i1 -= zCameraPos ; l -= yCameraPos ; int j1 = Model . modelIntArray1 [ yCameraCurve ] ; int k1 = Model . modelIntArray2 [ yCameraCurve ] ; int l1 = Model . modelIntArray1 [ xCameraCurve ] ; int i2 = Model . modelIntArray2 [ xCameraCurve ] ; int j2 = l * l1 + i * i2 >> 16 ; l = l * i2 - i * l1 >> 16 ; i = j2 ; j2 = i1 * k1 - l * j1 >> 16 ; l = i1 * j1 + l * k1 >> 16 ; i1 = j2 ; if ( l >= 50 ) { spriteDrawX = Texture . textureInt1 + ( i << 9 ) / l ; spriteDrawY = Texture . textureInt2 + ( i1 << 9 ) / l ; } else { spriteDrawX = - 1 ; spriteDrawY = - 1 ; } }
tr	1	@ Override public Position < E > parent ( Position < E > v ) throws InvalidPositionException , BoundaryViolationException { LCRSNode < E > node = this . checkPosition ( v ) ; Position < E > parentPos = node . getParent ( ) ; if ( parentPos == null ) { throw new BoundaryViolationException ( "No parent" ) ; } return parentPos ; }
tr	2	public static String joinPretty ( byte [ ] bytes ) { F < byte , String > f = new PrettyF ( ) ; StringBuffer buffer = new StringBuffer ( bytes . length * 2 ) ; if ( bytes . length == 0 ) { return "" ; } buffer . append ( f . f ( bytes [ 0 ] ) ) ; int bytesLength = bytes . length ; for ( int i = 1 ; i < bytesLength ; i ++ ) { byte b = bytes [ i ] ; buffer . append ( "  " ) . append ( f . f ( b ) ) ; } return buffer . toString ( ) ; }
tr	9	public String checkDataEntry ( ) { if ( panel6 . large . getText ( ) . equals ( "" ) || panel6 . small . getText ( ) . equals ( "" ) || panel6 . medium . getText ( ) . equals ( "" ) || panel6 . largeDiffIndicator . getText ( ) . equals ( "" ) ) { return "Error on Parameter Data Entry. Make sure all the boxes have been completed" ; } else { try { double large = double . parseDouble ( panel6 . large . getText ( ) ) ; double small = double . parseDouble ( panel6 . small . getText ( ) ) ; double medium = double . parseDouble ( panel6 . medium . getText ( ) ) ; double largeDiff = double . parseDouble ( panel6 . largeDiffIndicator . getText ( ) ) ; if ( large > 1 || small > 1 || medium > 1 || largeDiff > 1 || large < 0 || small < 0 || medium < 0 || largeDiff < 0 ) { return "A-Test significance levels must be doubles between zero and one" ; } else { return null ; } } catch ( NumberFormatException e ) { return "A-Test significance levels must be doubles less than one" ; } } }
tr	0	@ Override public String getGrammarFileName ( ) { return "Enquanto.g4" ; }
tr	0	@ Override public double calculateDiscount ( double price , int qty ) { return ( qty * dollarAmt ) ; }
tr	3	public void addLoggedInUser ( InetAddress ip , String username ) { boolean alreadyAdded = false ; for ( WebUser w : loggedInUsers ) { if ( w . getUsername ( ) . equalsIgnoreCase ( username ) ) { alreadyAdded = true ; } } if ( ! alreadyAdded ) { this . loggedInUsers . add ( new WebUser ( ip , username ) ) ; } }
tr	7	public void iniciar ( ) { JPanel panel = new JPanel ( ) ; getContentPane ( ) . add ( panel ) ; panel . setLayout ( null ) ; JLabel vermelho = new JLabel ( "Vermelho:" ) ; vermelho . setBounds ( 5 , 0 , 80 , 30 ) ; vermelho . setFont ( new Font ( "Arial" , 1 , 14 ) ) ; JLabel amarelo = new JLabel ( "Laranja:" ) ; amarelo . setBounds ( 5 , 80 , 80 , 30 ) ; amarelo . setFont ( new Font ( "Arial" , 1 , 14 ) ) ; JLabel verde = new JLabel ( "Verde: " ) ; verde . setBounds ( 5 , 160 , 80 , 30 ) ; verde . setFont ( new Font ( "Arial" , 1 , 14 ) ) ; panel . add ( vermelho ) ; panel . add ( amarelo ) ; panel . add ( verde ) ; final JLabel vermelho1 = new JLabel ( "0" ) ; vermelho1 . setBounds ( 80 , 0 , 80 , 30 ) ; vermelho1 . setFont ( new Font ( "Arial" , 1 , 14 ) ) ; final JLabel amarelo1 = new JLabel ( "0" ) ; amarelo1 . setBounds ( 80 , 80 , 80 , 30 ) ; amarelo1 . setFont ( new Font ( "Arial" , 1 , 14 ) ) ; final JLabel verde1 = new JLabel ( "0" ) ; verde1 . setBounds ( 80 , 160 , 80 , 30 ) ; verde1 . setFont ( new Font ( "Arial" , 1 , 14 ) ) ; panel . add ( vermelho1 ) ; panel . add ( amarelo1 ) ; panel . add ( verde1 ) ; final JLabel vermelho2 = new JLabel ( "0" ) ; vermelho2 . setBounds ( 120 , 0 , 80 , 30 ) ; vermelho2 . setFont ( new Font ( "Arial" , 1 , 14 ) ) ; final JLabel amarelo2 = new JLabel ( "0" ) ; amarelo2 . setBounds ( 120 , 80 , 80 , 30 ) ; amarelo2 . setFont ( new Font ( "Arial" , 1 , 14 ) ) ; final JLabel verde2 = new JLabel ( "0" ) ; verde2 . setBounds ( 120 , 160 , 80 , 30 ) ; verde2 . setFont ( new Font ( "Arial" , 1 , 14 ) ) ; panel . add ( vermelho2 ) ; panel . add ( amarelo2 ) ; panel . add ( verde2 ) ; final JLabel vermelho3 = new JLabel ( "0" ) ; vermelho3 . setBounds ( 160 , 0 , 80 , 30 ) ; vermelho3 . setFont ( new Font ( "Arial" , 1 , 14 ) ) ; final JLabel amarelo3 = new JLabel ( "0" ) ; amarelo3 . setBounds ( 160 , 80 , 80 , 30 ) ; amarelo3 . setFont ( new Font ( "Arial" , 1 , 14 ) ) ; final JLabel verde3 = new JLabel ( "0" ) ; verde3 . setBounds ( 160 , 160 , 80 , 30 ) ; verde3 . setFont ( new Font ( "Arial" , 1 , 14 ) ) ; panel . add ( vermelho3 ) ; panel . add ( amarelo3 ) ; panel . add ( verde3 ) ; final JLabel vermelho4 = new JLabel ( "0" ) ; vermelho4 . setBounds ( 200 , 0 , 80 , 30 ) ; vermelho4 . setFont ( new Font ( "Arial" , 1 , 14 ) ) ; final JLabel amarelo4 = new JLabel ( "0" ) ; amarelo4 . setBounds ( 200 , 80 , 80 , 30 ) ; amarelo4 . setFont ( new Font ( "Arial" , 1 , 14 ) ) ; final JLabel verde4 = new JLabel ( "0" ) ; verde4 . setBounds ( 200 , 160 , 80 , 30 ) ; verde4 . setFont ( new Font ( "Arial" , 1 , 14 ) ) ; panel . add ( vermelho4 ) ; panel . add ( amarelo4 ) ; panel . add ( verde4 ) ; setTitle ( "Semaforos" ) ; setSize ( 400 , 400 ) ; setLocationRelativeTo ( null ) ; setDefaultCloseOperation ( EXIT_ON_CLOSE ) ; Semaforo semaforo1 = new Semaforo ( ) ; semaforo1 . setRedText ( vermelho1 ) ; semaforo1 . setOrangeText ( amarelo1 ) ; semaforo1 . setGreenText ( verde1 ) ; semaforo1 . setStatus ( 0 ) ; semaforo1 . start ( ) ; Semaforo semaforo2 = new Semaforo ( ) ; semaforo2 . setRedText ( vermelho2 ) ; semaforo2 . setOrangeText ( amarelo2 ) ; semaforo2 . setGreenText ( verde2 ) ; semaforo2 . setStatus ( 0 ) ; semaforo2 . start ( ) ; Semaforo semaforo3 = new Semaforo ( ) ; semaforo3 . setRedText ( vermelho3 ) ; semaforo3 . setOrangeText ( amarelo3 ) ; semaforo3 . setGreenText ( verde3 ) ; semaforo3 . setStatus ( 0 ) ; semaforo3 . start ( ) ; Semaforo semaforo4 = new Semaforo ( ) ; semaforo4 . setRedText ( vermelho4 ) ; semaforo4 . setOrangeText ( amarelo4 ) ; semaforo4 . setGreenText ( verde4 ) ; semaforo4 . setStatus ( 2 ) ; semaforo4 . start ( ) ; long secondLast = 0 ; int currentSign = 1 ; while ( true ) { long secondNow = System . currentTimeMillis ( ) / 1000 ; if ( secondNow - secondLast >= 10 ) { switch ( currentSign ) { case 1 : semaforo4 . change ( ) ; semaforo1 . change ( ) ; break ; case 2 : semaforo1 . change ( ) ; semaforo2 . change ( ) ; break ; case 3 : semaforo2 . change ( ) ; semaforo3 . change ( ) ; break ; case 4 : semaforo3 . change ( ) ; semaforo4 . change ( ) ; break ; default : break ; } secondLast = secondNow ; currentSign ++ ; if ( currentSign == 5 ) currentSign = 1 ; } } }
tr	1	public static void main ( String [ ] args ) { new ActionRobot ( ) ; while ( true ) { long time = System . nanoTime ( ) ; BufferedImage image = ActionRobot . doScreenShot ( ) ; Vision vision = new Vision ( image ) ; vision . findBlocksMBR ( ) ; log ( ( System . nanoTime ( ) - time ) + "" ) ; } }
tr	3	public LinkedList < Vertex > _processGroupsOfParallelNodes ( LinkedList < Vertex > currentLL ) { if ( successStores . containsKey ( currentLL . toString ( ) . trim ( ) ) ) { return successStores . get ( currentLL . toString ( ) . trim ( ) ) ; } LinkedList < LinkedList < Vertex >> newLL = new LinkedList < LinkedList < Vertex >> ( ) ; LinkedList < LinkedList < Vertex >> newLL2 = new LinkedList < LinkedList < Vertex >> ( ) ; newLL . add ( currentLL ) ; newLL2 = processGroupsOfParallelNodes ( newLL ) ; if ( newLL2 . size ( ) == 0 ) { if ( successStores . containsKey ( currentLL . toString ( ) . trim ( ) ) ) return successStores . get ( currentLL . toString ( ) . trim ( ) ) ; return currentLL ; } successStores . put ( currentLL . toString ( ) . trim ( ) , newLL2 . getFirst ( ) ) ; return newLL2 . getFirst ( ) ; }
tr	6	public signalObject generateOrderSignal ( orderObject lastSale , orderObject lastBuy ) { signalObject result = new signalObject ( - 1 , - 1 , "nothing" ) ; if ( mode == BUY_MODE && arrayIsFull ) { if ( average < ( - epsilon ) ) { result = new signalObject ( lastSale . getQauntity ( ) , Math . max ( lastSale . getPrice ( ) , lastBuy . getPrice ( ) ) + 0.001 , "buy" ) ; mode = SELL_MODE ; } } else if ( mode == SELL_MODE && arrayIsFull ) { if ( average > epsilon ) { result = new signalObject ( lastBuy . getQauntity ( ) , Math . min ( lastSale . getPrice ( ) , lastBuy . getPrice ( ) ) - 0.001 , "sell" ) ; mode = BUY_MODE ; } } return result ; }
tr	6	private void persist ( PersistAction persistAction , String successMessage ) { if ( selected != null ) { setEmbeddableKeys ( ) ; try { if ( persistAction != PersistAction . DELETE ) { getFacade ( ) . edit ( selected ) ; } else { getFacade ( ) . remove ( selected ) ; } JsfUtil . addSuccessMessage ( successMessage ) ; } catch ( EJBException ex ) { String msg = "" ; Throwable cause = ex . getCause ( ) ; if ( cause != null ) { msg = cause . getLocalizedMessage ( ) ; } if ( msg . length ( ) > 0 ) { JsfUtil . addErrorMessage ( msg ) ; } else { JsfUtil . addErrorMessage ( ex , ResourceBundle . getBundle ( "/resoruces/Bundle" ) . getString ( "PersistenceErrorOccured" ) ) ; } } catch ( Exception ex ) { Logger . getLogger ( this . getClass ( ) . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; JsfUtil . addErrorMessage ( ex , ResourceBundle . getBundle ( "/resoruces/Bundle" ) . getString ( "PersistenceErrorOccured" ) ) ; } } }
tr	0	public static float getArea ( Vec3f v0 , Vec3f v1 , Vec3f v2 ) { float dx1 = v1 . x - v0 . x , dy1 = v1 . y - v0 . y , dz1 = v1 . z - v0 . z , dx2 = v2 . x - v0 . x , dy2 = v2 . y - v0 . y , dz2 = v2 . z - v0 . z ; float x = dy1 * dz2 - dz1 * dy2 , y = dz1 * dx2 - dx1 * dz2 , z = dx1 * dy2 - dy1 * dx2 ; return ( float ) Math . sqrt ( x * x + y * y + z * z ) / 2 ; }
tr	9	public boolean skipPast ( String to ) throws JSONException { boolean b ; char c ; int i ; int j ; int offset = 0 ; int length = to . length ( ) ; char [ ] circle = new char [ length ] ; for ( i = 0 ; i < length ; i += 1 ) { c = next ( ) ; if ( c == 0 ) { return false ; } circle [ i ] = c ; } for ( ; ; ) { j = offset ; b = true ; for ( i = 0 ; i < length ; i += 1 ) { if ( circle [ j ] != to . charAt ( i ) ) { b = false ; break ; } j += 1 ; if ( j >= length ) { j -= length ; } } if ( b ) { return true ; } c = next ( ) ; if ( c == 0 ) { return false ; } circle [ offset ] = c ; offset += 1 ; if ( offset >= length ) { offset -= length ; } } }
tr	5	public boolean ehEnPassant ( Posicao posicaoPeca , Posicao lado ) { if ( this . espiarPeca ( posicaoPeca ) . getTipoPeca ( ) == TipoPeca . PEAO ) { if ( ! estaForaDoTabuleiro ( lado ) ) if ( this . estaInimigo ( this . espiarPeca ( posicaoPeca ) . getCorJogador ( ) , lado ) ) if ( this . espiarPeca ( lado ) . getTipoPeca ( ) == TipoPeca . PEAO ) { Peao peaoInimigo = ( Peao ) this . espiarPeca ( lado ) ; if ( peaoInimigo . isPodeEnPassant ( ) ) return true ; } } return false ; }
tr	4	@ Override public void keyReleased ( KeyEvent evt ) { if ( evt . getKeyCode ( ) == KeyEvent . VK_UP ) upPressed = false ; else if ( evt . getKeyCode ( ) == KeyEvent . VK_RIGHT ) rightPressed = false ; else if ( evt . getKeyCode ( ) == KeyEvent . VK_DOWN ) downPressed = false ; else if ( evt . getKeyCode ( ) == KeyEvent . VK_LEFT ) leftPressed = false ; }
tr	4	public static void solve ( int k , int ct ) { int i , j ; if ( k < ct && k >= 0 ) { i = blan [ k ] / 9 ; j = blan [ k ] % 9 ; for ( int fill = 1 ; fill <= 9 ; fill ++ ) { if ( checkitnow ( i , j , fill ) ) { sudoku [ i ] [ j ] = fill ; solve ( ++ k , ct ) ; k -- ; } } sudoku [ i ] [ j ] = 0 ; } else { answer ++ ; printsudoku ( ) ; } }
tr	5	@ Override public boolean equals ( Object obj ) { if ( obj == null ) { return false ; } if ( getClass ( ) != obj . getClass ( ) ) { return false ; } final SondageReponse other = ( SondageReponse ) obj ; if ( this . id != other . id ) { return false ; } if ( this . id_sondage != other . id_sondage ) { return false ; } if ( this . choix != other . choix ) { return false ; } return true ; }
tr	3	private void checkHorizontalScrollBar ( BasicComboPopup popup ) { JViewport viewport = scrollPane . getViewport ( ) ; Point p = viewport . getViewPosition ( ) ; p . x = 0 ; viewport . setViewPosition ( p ) ; if ( ! scrollBarRequired ) { scrollPane . setHorizontalScrollBar ( null ) ; return ; } JScrollBar horizontal = scrollPane . getHorizontalScrollBar ( ) ; if ( horizontal == null ) { horizontal = new JScrollBar ( JScrollBar . HORIZONTAL ) ; scrollPane . setHorizontalScrollBar ( horizontal ) ; scrollPane . setHorizontalScrollBarPolicy ( JScrollPane . HORIZONTAL_SCROLLBAR_AS_NEEDED ) ; } if ( horizontalScrollBarWillBeVisible ( popup , scrollPane ) ) { Dimension scrollPaneSize = scrollPane . getPreferredSize ( ) ; scrollPaneSize . height += horizontal . getPreferredSize ( ) . height ; scrollPane . setPreferredSize ( scrollPaneSize ) ; scrollPane . setMaximumSize ( scrollPaneSize ) ; scrollPane . revalidate ( ) ; } }
tr	8	private void method117 ( Stream stream ) { stream . initBitAccess ( ) ; int j = stream . readBits ( 1 ) ; if ( j == 0 ) return ; int k = stream . readBits ( 2 ) ; if ( k == 0 ) { anIntArray894 [ anInt893 ++ ] = myPlayerIndex ; return ; } if ( k == 1 ) { int l = stream . readBits ( 3 ) ; myPlayer . moveInDir ( false , l ) ; int k1 = stream . readBits ( 1 ) ; if ( k1 == 1 ) anIntArray894 [ anInt893 ++ ] = myPlayerIndex ; return ; } if ( k == 2 ) { int i1 = stream . readBits ( 3 ) ; myPlayer . moveInDir ( true , i1 ) ; int l1 = stream . readBits ( 3 ) ; myPlayer . moveInDir ( true , l1 ) ; int j2 = stream . readBits ( 1 ) ; if ( j2 == 1 ) anIntArray894 [ anInt893 ++ ] = myPlayerIndex ; return ; } if ( k == 3 ) { plane = stream . readBits ( 2 ) ; int j1 = stream . readBits ( 1 ) ; int i2 = stream . readBits ( 1 ) ; if ( i2 == 1 ) anIntArray894 [ anInt893 ++ ] = myPlayerIndex ; int k2 = stream . readBits ( 7 ) ; int l2 = stream . readBits ( 7 ) ; myPlayer . setPos ( l2 , k2 , j1 == 1 ) ; } }
tr	4	@ Override protected void imprimirTabuleiro ( TabuleiroXadrez tabuleiro ) { imprimirLinha ( "      1        2        3        4        5        6        7        8     " ) ; for ( int linha = 8 ; linha >= 1 ; linha -- ) { imprimirLinha ( "  -------------------------------------------------------------------------" ) ; imprimir ( linha + " " ) ; for ( int coluna = 1 ; coluna <= 8 ; coluna ++ ) { imprimir ( "|" ) ; Peca peca = tabuleiro . espiarPeca ( new Posicao ( coluna , linha ) ) ; imprimir ( PecaToString ( peca ) ) ; if ( peca == null ) imprimir ( "       " ) ; else if ( peca . getCorJogador ( ) == TipoCorJogador . BRANCO ) imprimir ( " branco" ) ; else imprimir ( " preto " ) ; } imprimirLinha ( "| " + linha ) ; } imprimirLinha ( "  -------------------------------------------------------------------------" ) ; imprimirLinha ( "      1        2        3        4        5        6        7        8     " ) ; }
tr	0	@ Column ( name = "PRP_MOA_TIPO" ) @ Id public String getPrpMoaTipo ( ) { return prpMoaTipo ; }
tr	1	@ Override public String toString ( ) { StringBuilder buffer = new StringBuilder ( ) ; for ( int i = 0 ; i < xAxis . getNBins ( ) ; i ++ ) { buffer . append ( String . format ( "%12.6f %12.6f %12.6f\n" , xAxis . getBinCenter ( i ) , this . getBinContent ( i ) , this . getBinError ( i ) ) ) ; } return buffer . toString ( ) ; }
tr	6	public void nextPermutation ( int [ ] nums ) { if ( nums . length <= 1 ) { return ; } int i = nums . length - 2 ; for ( ; i >= 0 ; i -- ) { if ( nums [ i + 1 ] > nums [ i ] ) { break ; } } if ( i == - 1 ) { reverse ( nums , 0 , nums . length - 1 ) ; return ; } for ( int j = nums . length - 1 ; j > i ; j -- ) { if ( nums [ j ] > nums [ i ] ) { swap ( nums , i , j ) ; break ; } } reverse ( nums , i + 1 , nums . length - 1 ) ; }
tr	0	public void paintComponent ( Graphics g2 ) { g2 . drawImage ( bgImage , 0 , 0 , null ) ; }
tr	2	public static GameResult fromInt ( int val ) { for ( GameResult gr : list ) { if ( gr . getValue ( ) == val ) { return gr ; } } return null ; }
tr	0	public IntAdder ( JBlockingQueue < Integer > q ) { this . q = q ; }
tr	8	public AccountQuota accountQuota ( String accountName ) throws MultiCloudException , OAuth2SettingsException , InterruptedException { synchronized ( lock ) { if ( op != null ) { throw new MultiCloudException ( "Concurrent operation forbidden." ) ; } } AccountSettings account = accountManager . getAccountSettings ( accountName ) ; if ( account == null ) { throw new MultiCloudException ( "User account not found." ) ; } if ( ! account . isAuthorized ( ) ) { throw new MultiCloudException ( "User account not authorized." ) ; } CloudSettings settings = cloudManager . getCloudSettings ( account . getSettingsId ( ) ) ; if ( settings == null ) { throw new MultiCloudException ( "Cloud storage settings not found." ) ; } OAuth2Token token = credentialStore . retrieveCredential ( account . getTokenId ( ) ) ; if ( token == null ) { account . setTokenId ( null ) ; throw new MultiCloudException ( "Access token not found." ) ; } if ( token . isExpired ( ) ) { refreshAccount ( accountName , null ) ; } synchronized ( lock ) { op = new AccountQuotaOp ( token , settings . getAccountQuotaRequest ( ) ) ; } try { op . execute ( ) ; } catch ( MultiCloudException e ) { synchronized ( lock ) { op = null ; } throw e ; } lastError = op . getError ( ) ; if ( op . isAborted ( ) ) { synchronized ( lock ) { op = null ; } throw new AbortedException ( "Operation aborted." ) ; } AccountQuota result = ( ( AccountQuotaOp ) op ) . getResult ( ) ; synchronized ( lock ) { op = null ; } return result ; }
tr	0	public int [ ] [ ] getGraph ( ) { return graph ; }
tr	3	public static List < Integer > parseIntList ( String list ) { if ( list == null ) { return null ; } String [ ] parts = list . split ( " " ) ; ArrayList < Integer > intList = new ArrayList < Integer > ( ) ; for ( String part : parts ) { try { intList . add ( Integer . parseInt ( part ) ) ; } catch ( NumberFormatException e ) { } } return intList ; }
tr	6	public static Rule COUNT ( final Rule rule , final int from , final int to ) { return new Rule ( ) { @ Override public Object exec ( GenericMatcher matcher ) { ArrayList < Object > result = new ArrayList < Object > ( ) ; int i = 0 ; for ( ; ; ) { Object m = rule . exec ( matcher ) ; if ( m == null ) { if ( from == - 1 || i >= from ) return result ; return null ; } result . add ( m ) ; i ++ ; if ( to != - 1 && i == to ) return result ; } } } ; }
tr	5	public void sendDataToClient ( ) throws IOException { if ( sock instanceof SSLSocket ) { SSLSocket sslSock = ( SSLSocket ) sock ; if ( sslSock == null || resp == null ) { return ; } sslSock . getOutputStream ( ) . write ( resp . byteContents ( ) ) ; } else { this . sock . getOutputStream ( ) . write ( resp . byteContents ( ) ) ; this . sock . getOutputStream ( ) . flush ( ) ; } if ( version . equals ( "1.0" ) && ! cached ) { this . sock . close ( ) ; } this . sent = true ; }
tr	7	public Object getValueAt ( Object node , int column ) { FileNode fn = ( FileNode ) node ; try { switch ( column ) { case 0 : return fn . getFile ( ) . getName ( ) ; case 1 : if ( fn . isTotalSizeValid ( ) ) { return new Integer ( ( int ) ( ( FileNode ) node ) . totalSize ( ) ) ; } return null ; case 2 : return fn . isLeaf ( ) ? "File" : "Directory" ; case 3 : return fn . lastModified ( ) ; } } catch ( SecurityException se ) { } return null ; }
tr	0	private void gestionePrenotazione ( int uType , int id , Agenzia ag ) { panelVista . removeAll ( ) ; panelVista . add ( new VistaGestionePrenotazioni ( uType , id , ag ) ) ; this . invalidate ( ) ; this . validate ( ) ; this . repaint ( ) ; }
tr	3	public List < VariableAppearance > getAltAppearances ( ParsingContext context ) { List < VariableAppearance > result = new ArrayList < VariableAppearance > ( ) ; for ( String variableName : detectedVariableNames ) { for ( int i = 0 ; i < altPrefixRegexps . size ( ) ; i ++ ) { String completeRegexp = altPrefixRegexps . get ( i ) + variableName + altSuffixRegexps . get ( i ) ; Matcher matcher = Pattern . compile ( completeRegexp ) . matcher ( context . getContent ( ) ) ; while ( matcher . find ( ) ) { result . add ( new VariableAppearance ( matcher . group ( ) , variableName , globalContext , context , "" ) ) ; } } } return result ; }
tr	8	public static long [ ] setup ( String moves_text ) { LogFile . message ( moves_text ) ; ArrayList < long > banned_positions = new ArrayList < long > ( ) ; moves_text = moves_text . replaceAll ( "%13" , "@" ) ; StringTokenizer tokenizer = new StringTokenizer ( moves_text , "@" ) ; if ( tokenizer . countTokens ( ) < 2 ) { return new long [ 0 ] ; } GameState gs = new GameState ( tokenizer . nextToken ( ) , tokenizer . nextToken ( ) ) ; ArrayList < long > hash_codes = new ArrayList < long > ( ) ; hash_codes . add ( new long ( gs . getPositionHash ( ) ) ) ; while ( tokenizer . hasMoreTokens ( ) ) { String move_token = tokenizer . nextToken ( ) ; StringTokenizer temp = new StringTokenizer ( move_token ) ; temp . nextToken ( ) ; String move = "" ; int steps = 0 ; while ( temp . hasMoreTokens ( ) ) { String step_token = temp . nextToken ( ) ; move += step_token + " " ; steps ++ ; } if ( steps == 0 ) { continue ; } if ( steps < 4 ) { move += "pass" ; } ArimaaMove temp_move = new ArimaaMove ( move ) ; gs . play ( temp_move , gs ) ; hash_codes . add ( new long ( gs . getPositionHash ( ) ) ) ; } while ( ! hash_codes . isEmpty ( ) ) { long test = ( long ) hash_codes . get ( hash_codes . size ( ) - 1 ) ; hash_codes . remove ( hash_codes . size ( ) - 1 ) ; if ( hash_codes . contains ( test ) ) { banned_positions . add ( test ) ; LogFile . message ( "Duplicate hash value: " + test ) ; } } long result [ ] = new long [ banned_positions . size ( ) ] ; for ( int i = 0 ; i < banned_positions . size ( ) ; i ++ ) { result [ i ] = banned_positions . get ( i ) . longValue ( ) ; } return result ; }
tr	2	@ Override public boolean readResponse ( String [ ] first_line , InputStream in ) throws BeanstalkcException , IOException { if ( first_line [ 0 ] . equals ( "BURIED" ) ) { return true ; } else if ( first_line [ 0 ] . equals ( "NOT_FOUND" ) ) { throw new JobNotFoundException ( String . format ( "Job %d not found  it may not exist or not be reserved by this client" , job_id ) ) ; } return false ; }
tr	9	public void paint ( Graphics g2 ) { if ( applet != null ) return ; int w = getWidth ( ) / 2 ; int h = getHeight ( ) / 2 ; if ( ( img == null ) || ( img . getWidth ( ) != w ) || ( img . getHeight ( ) != h ) ) { img = createVolatileImage ( w , h ) ; } Graphics g = img . getGraphics ( ) ; g . drawImage ( bgImage , 0 , 0 , null ) ; if ( gameUpdater . pauseAskUpdate ) { if ( ! hasMouseListener ) { hasMouseListener = true ; addMouseListener ( this ) ; } g . setColor ( Color . LIGHT_GRAY ) ; String msg = "\u0414\u043E\u0441\u0442\u0443\u043F\u043D\u043E \u043D\u043E\u0432\u043E\u0435 \u043E\u0431\u043D\u043E\u0432\u043B\u0435\u043D\u0438\u0435" ; g . setFont ( new Font ( null , 1 , 20 ) ) ; FontMetrics fm = g . getFontMetrics ( ) ; g . drawString ( msg , w / 2 - fm . stringWidth ( msg ) / 2 , h / 2 - fm . getHeight ( ) * 2 ) ; g . setFont ( new Font ( null , 0 , 12 ) ) ; fm = g . getFontMetrics ( ) ; g . fill3DRect ( w / 2 - 56 - 8 , h / 2 , 56 , 20 , true ) ; g . fill3DRect ( w / 2 + 8 , h / 2 , 56 , 20 , true ) ; msg = "\u0417\u0430\u0433\u0440\u0443\u0437\u0438\u0442\u044C \u0441\u0435\u0439\u0447\u0430\u0441?" ; g . drawString ( msg , w / 2 - fm . stringWidth ( msg ) / 2 , h / 2 - 8 ) ; g . setColor ( Color . BLACK ) ; msg = "\u0414\u0430" ; g . drawString ( msg , w / 2 - 56 - 8 - fm . stringWidth ( msg ) / 2 + 28 , h / 2 + 14 ) ; msg = "\u041D\u0435\u0442" ; g . drawString ( msg , w / 2 + 8 - fm . stringWidth ( msg ) / 2 + 28 , h / 2 + 14 ) ; } else { g . setColor ( Color . LIGHT_GRAY ) ; String msg = "Updating Minecraft" ; if ( gameUpdater . fatalError ) { msg = "Failed to launch" ; } g . setFont ( new Font ( null , 1 , 20 ) ) ; FontMetrics fm = g . getFontMetrics ( ) ; g . drawString ( msg , w / 2 - fm . stringWidth ( msg ) / 2 , h / 2 - fm . getHeight ( ) * 2 ) ; g . setFont ( new Font ( null , 0 , 12 ) ) ; fm = g . getFontMetrics ( ) ; msg = gameUpdater . getDescriptionForState ( ) ; if ( gameUpdater . fatalError ) { msg = gameUpdater . fatalErrorDescription ; } g . drawString ( msg , w / 2 - fm . stringWidth ( msg ) / 2 , h / 2 + fm . getHeight ( ) * 1 ) ; msg = gameUpdater . subtaskMessage ; g . drawString ( msg , w / 2 - fm . stringWidth ( msg ) / 2 , h / 2 + fm . getHeight ( ) * 2 ) ; if ( ! gameUpdater . fatalError ) { g . setColor ( Color . black ) ; g . fillRect ( 64 , h - 64 , w - 128 + 1 , 5 ) ; g . setColor ( new Color ( 32768 ) ) ; g . fillRect ( 64 , h - 64 , gameUpdater . percentage * ( w - 128 ) / 100 , 4 ) ; g . setColor ( new Color ( 2138144 ) ) ; g . fillRect ( 65 , h - 64 + 1 , gameUpdater . percentage * ( w - 128 ) / 100 - 2 , 1 ) ; } } g . dispose ( ) ; g2 . drawImage ( img , 0 , 0 , w * 2 , h * 2 , null ) ; }
tr	2	@ Override public Object invoke ( Object proxy , Method method , Object [ ] args ) throws Throwable { Vector < SerializableObject > deSerList = new Vector < SerializableObject > ( ) ; if ( "writeObj" . equals ( method . getName ( ) ) ) { Object obj = args [ 0 ] ; serializer . serialize ( pWriter , obj ) ; } else if ( "readObj" . equals ( method . getName ( ) ) ) { deSerList = deSerializer . deSerialize ( ) ; return deSerList ; } return null ; }
tr	9	public void handleGameData ( int [ ] data ) { if ( data . length == 0 ) { return ; } for ( int i = 0 ; i < data . length ; i ++ ) { if ( data [ i ] == START_UPDATE_MOVEABLE ) { for ( int j = i + 1 ; j < data . length ; j ++ ) { if ( data [ j ] == END_UPDATE_MOVEABLE ) { int length = j - i ; if ( length != 3 ) { throw new RuntimeException ( "Invalid formatted data. Update moveable data not correct: " + length ) ; } else { acceptUpdatedMoveable ( data [ j - 2 ] , data [ j - 1 ] ) ; } } } } else if ( data [ i ] == START_DROP_BOMB ) { for ( int j = i + 1 ; j < data . length ; j ++ ) { if ( data [ j ] == END_DROP_BOMB ) { int length = j - i ; if ( length != 5 ) { throw new RuntimeException ( "Invalid formatted data. Drop bomb data not correct: " + length ) ; } else { acceptDroppedBomb ( data [ j - 4 ] , data [ j - 3 ] , data [ j - 2 ] , data [ j - 1 ] ) ; } } } } } }
tr	5	private void jButton16ActionPerformed ( java . awt . event . ActionEvent evt ) { String s = ( String ) listaElevi . getSelectedValue ( ) ; liceu . Administrator admin = new liceu . Administrator ( ) ; admin . delUser ( s ) ; BufferedReader fisier ; try { fisier = new BufferedReader ( new FileReader ( "credentials" ) ) ; ArrayList < String > vector = new ArrayList < > ( ) ; for ( String line ; ( line = fisier . readLine ( ) ) != null ; ) { vector . add ( line ) ; } listModelElevi . clear ( ) ; for ( int i = 0 ; i < vector . size ( ) ; i = i + 5 ) { if ( vector . get ( i + 4 ) . equals ( "Elev" ) ) listModelElevi . addElement ( vector . get ( i ) ) ; } } catch ( FileNotFoundException ex ) { Logger . getLogger ( Administratorapp . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( IOException ex ) { Logger . getLogger ( Administratorapp . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } }
tr	3	private void doPrint ( String s ) { for ( int newline = s . indexOf ( '' ) ; newline >= 0 ; newline = s . indexOf ( '' ) ) { if ( newline > 0 ) { indent ( ) ; writer . println ( protect ( s . substring ( 0 , newline ) ) ) ; } else { writer . println ( ) ; } begin_line = true ; s = s . substring ( newline + 1 ) ; } if ( s . length ( ) > 0 ) { indent ( ) ; writer . print ( protect ( s ) ) ; } }
tr	7	public boolean TeclaTexto ( KeyEvent e ) { char c = e . getKeyChar ( ) ; if ( ( c < a || c > z ) && ( c < A || c > Z ) && c != e . VK_BACK_SPACE && c != e . VK_ENTER && c != e . VK_DELETE ) { validacion = false ; } else { validacion = true ; } return validacion ; }
tr	8	public void method545 ( Stream stream , Class29 class29 ) { int i = stream . readUnsignedByte ( ) ; anIntArray665 [ 0 ] = i >> 4 ; anIntArray665 [ 1 ] = i & f ; if ( i != 0 ) { anIntArray668 [ 0 ] = stream . readUnsignedWord ( ) ; anIntArray668 [ 1 ] = stream . readUnsignedWord ( ) ; int j = stream . readUnsignedByte ( ) ; for ( int k = 0 ; k < 2 ; k ++ ) { for ( int l = 0 ; l < anIntArray665 [ k ] ; l ++ ) { anIntArrayArrayArray666 [ k ] [ 0 ] [ l ] = stream . readUnsignedWord ( ) ; anIntArrayArrayArray667 [ k ] [ 0 ] [ l ] = stream . readUnsignedWord ( ) ; } } for ( int i1 = 0 ; i1 < 2 ; i1 ++ ) { for ( int j1 = 0 ; j1 < anIntArray665 [ i1 ] ; j1 ++ ) if ( ( j & 1 << i1 * 4 << j1 ) != 0 ) { anIntArrayArrayArray666 [ i1 ] [ 1 ] [ j1 ] = stream . readUnsignedWord ( ) ; anIntArrayArrayArray667 [ i1 ] [ 1 ] [ j1 ] = stream . readUnsignedWord ( ) ; } else { anIntArrayArrayArray666 [ i1 ] [ 1 ] [ j1 ] = anIntArrayArrayArray666 [ i1 ] [ 0 ] [ j1 ] ; anIntArrayArrayArray667 [ i1 ] [ 1 ] [ j1 ] = anIntArrayArrayArray667 [ i1 ] [ 0 ] [ j1 ] ; } } if ( j != 0 || anIntArray668 [ 1 ] != anIntArray668 [ 0 ] ) class29 . method326 ( stream ) ; } else { anIntArray668 [ 0 ] = anIntArray668 [ 1 ] = 0 ; } }
tr	1	public static Image [ ] loadStills ( int numSprites , String imgPath ) { Image [ ] stills = new Image [ numSprites ] ; String path = Item . charPath + imgPath ; for ( int i = 0 ; i < numSprites ; i ++ ) { stills [ i ] = Item . loadImage ( path + i + "/0.png" ) ; } return stills ; }
tr	0	public InviteDaoException ( String message , Throwable cause ) { super ( message , cause ) ; }
tr	5	public void applyTurn ( int player1Choice , int player2Choice ) { omnidexter . setChoice ( player1Choice ) ; opponent . setChoice ( player2Choice ) ; Team [ ] speedOrder = PokemonMath . getFasterPoke ( omnidexter , opponent ) ; Team first = speedOrder [ 0 ] ; Team second = speedOrder [ 1 ] ; if ( first . getChoice ( ) < 0 ) { first . switchActivePokemon ( first . getActivePokemon ( ) . getMove ( first . getChoice ( ) ) ) ; } if ( second . getChoice ( ) < 0 ) { second . switchActivePokemon ( second . getActivePokemon ( ) . getMove ( second . getChoice ( ) ) ) ; } if ( first . getChoice ( ) >= 0 ) { attack ( first . getTeamId ( ) , first . getChoice ( ) ) ; } if ( second . getChoice ( ) >= 0 && ! second . getActivePokemon ( ) . hasFainted ( ) ) { attack ( second . getTeamId ( ) , second . getChoice ( ) ) ; } }
tr	1	public void setUser ( String user ) { if ( user == null ) return ; this . user = user ; }
tr	0	public String getSendTime ( ) { return sendTime ; }
tr	5	private void toggleSelected ( Card c ) { for ( int index = 0 ; index < selected . length ; index ++ ) { if ( selected [ index ] != null ) { if ( selected [ index ] . equals ( c ) ) { selected [ index ] = null ; return ; } } } for ( int index = 0 ; index < selected . length ; index ++ ) { if ( selected [ index ] == null ) { selected [ index ] = c ; return ; } } }
tr	9	public final void append ( PathIterator pi , boolean connect ) { double [ ] coords = new double [ 6 ] ; while ( ! pi . isDone ( ) ) { switch ( pi . currentSegment ( coords ) ) { case SEG_MOVETO : if ( ! connect || numTypes < 1 || numCoords < 1 ) { moveTo ( coords [ 0 ] , coords [ 1 ] ) ; break ; } if ( pointTypes [ numTypes - 1 ] != SEG_CLOSE && doubleCoords [ numCoords - 2 ] == coords [ 0 ] && doubleCoords [ numCoords - 1 ] == coords [ 1 ] ) { break ; } lineTo ( coords [ 0 ] , coords [ 1 ] ) ; break ; case SEG_LINETO : lineTo ( coords [ 0 ] , coords [ 1 ] ) ; break ; case SEG_QUADTO : quadTo ( coords [ 0 ] , coords [ 1 ] , coords [ 2 ] , coords [ 3 ] ) ; break ; case SEG_CUBICTO : curveTo ( coords [ 0 ] , coords [ 1 ] , coords [ 2 ] , coords [ 3 ] , coords [ 4 ] , coords [ 5 ] ) ; break ; case SEG_CLOSE : closePath ( ) ; break ; } pi . next ( ) ; connect = false ; } }
tr	6	private void sotilaanKorottaminen ( int korMista , int levMista , int korMinne , int levMinne , List < int [ ] > mahdollisetSiirrot ) { if ( nappula [ korMista ] [ levMista ] . nimi ( ) == s ) { for ( int [ ] s : mahdollisetSiirrot ) { if ( s [ 0 ] == korMinne && s [ 1 ] == levMinne && ( korMinne == 0 || korMinne == 7 ) ) { PELILAUTA [ korMista ] [ levMista ] = new Kuningatar ( nappula [ korMista ] [ levMista ] . vari ( ) , korMista , levMista ) ; paivita = true ; } } } }
tr	2	private void addRemainBActionPerformed ( java . awt . event . ActionEvent evt ) { if ( searchDrugTable . getSelectedRow ( ) != - 1 ) { try { String drugId = searchDrugTable . getValueAt ( searchDrugTable . getSelectedRow ( ) , 0 ) . toString ( ) ; addRemainDrugId . setText ( drugId ) ; addRemainNum . setText ( "" ) ; addRemainWindow . setVisible ( true ) ; } catch ( NumberFormatException e ) { alarmText . setText ( "\u8BF7\u9009\u62E9\u6B63\u786E\u7684\u884C" ) ; alarmWindow . setVisible ( true ) ; } } }
tr	7	public static void readHash ( String type_map , HashMap < String , String > typeMap ) { ArrayList < String > types = new ArrayList < String > ( ) ; ArrayList < String > tokens = new ArrayList < String > ( ) ; if ( type_map != null ) { readLines ( type_map , types ) ; for ( int i = 0 ; i < types . size ( ) ; i ++ ) { if ( ! types . get ( i ) . isEmpty ( ) ) { FileUtil . tokenize ( types . get ( i ) , tokens ) ; if ( tokens . size ( ) != 0 ) { if ( tokens . size ( ) != 2 ) { for ( int j = 0 ; j < tokens . size ( ) ; j ++ ) { System . out . print ( tokens . get ( j ) + " " ) ; } System . err . println ( type_map + " Error ! Not two elements in one line !" ) ; return ; } if ( ! typeMap . containsKey ( tokens . get ( 0 ) ) ) typeMap . put ( tokens . get ( 0 ) , tokens . get ( 1 ) ) ; else { System . out . println ( tokens . get ( 0 ) + " " + tokens . get ( 1 ) ) ; System . err . println ( type_map + " Error ! Same type in first column !" ) ; return ; } } tokens . clear ( ) ; } } } }
tr	5	public void handle ( Connection connection , Request request ) { logger . debug ( "NickCommand handler : " + request ) ; if ( StringUtils . isEmpty ( request . getArgs ( ) ) ) { connection . serverSendCommandToMe ( "431 ERR_NONICKNAMEGIVEN :No nickname given" ) ; return ; } String newNickname = request . getArgs ( ) . trim ( ) ; String oldNickName = connection . getNickname ( ) ; if ( newNickname . startsWith ( ":" ) ) { newNickname = newNickname . substring ( 1 ) ; } if ( ! isNickCorrectlyFormat ( newNickname ) ) { connection . serverSendCommandToMe ( "432 ERR_ERRONEUSNICKNAME " + newNickname + " :Erroneus nickname" ) ; return ; } if ( connection . isNickExist ( newNickname ) ) { connection . serverSendCommandToMe ( "433 ERR_NICKNAMEINUSE " + newNickname + " :Nickname is already in use" ) ; return ; } if ( StringUtils . isNotEmpty ( oldNickName ) ) { connection . meSendCommandToAll ( "NICK " + newNickname ) ; } connection . setNickname ( newNickname ) ; }
tr	2	public WishList insert ( WishList wishlist ) { if ( wishlist == null ) return null ; try { Connection connection = DataSourceUtils . getConnection ( dataSource ) ; PreparedStatement statement = connection . prepareStatement ( "INSERT INTO wishlist (idp idu) " + "VALUES (?  ?)" ) ; statement . setInt ( 1 , wishlist . getIdp ( ) ) ; statement . setInt ( 2 , wishlist . getIdu ( ) ) ; statement . executeUpdate ( ) ; } catch ( SQLException e ) { throw new RuntimeException ( e ) ; } return wishlist ; }
tr	6	private void markForUpdate ( int posX , int posY , int radius ) { int leftX = posX - radius ; int rightX = posX + radius ; int topY = posY - radius ; int bottomY = posY + radius ; if ( leftX < 0 ) leftX = 0 ; if ( rightX >= width ) rightX = width - 1 ; if ( topY < 0 ) topY = 0 ; if ( bottomY >= height ) bottomY = height - 1 ; for ( int i = leftX ; i <= rightX ; i ++ ) { for ( int j = topY ; j <= bottomY ; j ++ ) markForUpdate ( i , j ) ; } }
tr	9	public void runForecastService ( String fcserv , String fcUrl ) { Connection locconn = locconnman . getConnection ( ) ; System . out . println ( "IN RunForecastService" ) ; CTestList testlist = new CTestList ( ) ; if ( testid . equals ( CAppConsts . TagNoValue ) ) { testlist . dbReadList ( locconn , testgrpid , fc1 , fc2 ) ; } else { CTestItem otestitem = new CTestItem ( ) ; otestitem . dbReadItem ( locconn , testgrpid , testid ) ; otestitem . fc1 = fc1 ; otestitem . fc2 = fc2 ; testlist . addItem ( otestitem . makeKey ( ) , otestitem ) ; } Service service = Service . getService ( fcserv ) ; Software software = new Software ( ) ; software . setServiceUrl ( fcUrl ) ; software . setService ( service ) ; System . out . println ( "IN RunForecastService part2" ) ; try { ConnectorInterface connector = ConnectFactory . createConnecter ( software , ForecastItem . getForecastItemList ( ) ) ; int childid = 1 ; for ( int idx = 0 ; idx < testlist . getCount ( ) ; idx ++ ) { CTestItem atestitem = ( CTestItem ) testlist . getItem ( idx ) ; atestitem . dbReadDetail ( locconn ) ; TestCase testCase = new TestCase ( ) ; System . out . println ( "IN RunForecastService part3" ) ; testCase . setEvalDate ( atestitem . basedate ) ; testCase . setPatientSex ( atestitem . gendercd ) ; testCase . setTestCaseId ( childid ) ; testCase . setPatientDob ( atestitem . birthdate ) ; List < TestEvent > testEventList = new ArrayList < TestEvent > ( ) ; CShotList shotlst = atestitem . shotlist ; for ( int j = 0 ; j < shotlst . getCount ( ) ; j ++ ) { CShotItem shot = ( CShotItem ) shotlst . getItem ( j ) ; TestEvent vac = new TestEvent ( ) ; vac . setEventDate ( shot . shotdate ) ; int vacid = Integer . parseInt ( shot . vaccinecd ) ; vac . setEvent ( Event . getEvent ( vacid ) ) ; System . out . println ( "vac= " + Event . getEvent ( vacid ) . getLabel ( ) + " " + Event . getEvent ( vacid ) . getVaccineCvx ( ) ) ; Event . getEvent ( vacid ) . setVaccineMvx ( shot . mfrcd ) ; testEventList . add ( vac ) ; } testCase . setTestEventList ( testEventList ) ; System . out . println ( "QUERY FOR FORECASTER" ) ; List < ForecastActual > forecastActualList = connector . queryForForecast ( testCase ) ; childid ++ ; if ( fcserv . equals ( fc1nm ) ) { atestitem . fc1resnotes = forecastActualList . get ( 0 ) . getLogText ( ) . toString ( ) ; } if ( fcserv . equals ( fc2nm ) ) { atestitem . fc2resnotes = forecastActualList . get ( 0 ) . getLogText ( ) . toString ( ) ; } atestitem . dbWriteItem ( locconn ) ; if ( fcrunoption == CAppConsts . RunFC1 || fcrunoption == CAppConsts . RunBothFC ) { atestitem . setLastRunFC1 ( ) ; atestitem . dbWriteResult1 ( locconn ) ; } if ( fcrunoption == CAppConsts . RunFC2 || fcrunoption == CAppConsts . RunBothFC ) { atestitem . setLastRunFC2 ( ) ; atestitem . dbWriteResult2 ( locconn ) ; } System . out . println ( ) ; if ( forecastActualList . size ( ) > 0 ) { System . out . print ( forecastActualList . get ( 0 ) . getLogText ( ) . toString ( ) ) ; } } } catch ( Exception ex ) { CLogError . logError ( props . ErrorLogFile , props . ErrMsgEcho , "runForecastService error: " , ex ) ; } locconnman . returnConnection ( locconn ) ; }
tr	4	private void findPlacement ( Node tobeAdded ) { Node u = root ; while ( true ) { if ( comparator . compare ( tobeAdded . key , u . key ) < 0 ) { if ( u . left == null ) { u . left = tobeAdded ; tobeAdded . parent = u ; break ; } else u = u . left ; } else { if ( u . right == null ) { u . right = tobeAdded ; tobeAdded . parent = u ; break ; } else u = u . right ; } } }
tr	3	@ Override public boolean equals ( Object v ) { if ( ( ! ( v instanceof vslRecKey ) ) || id == null || ( ( vslRecKey ) v ) . getKey ( ) == null ) { return false ; } else { return id . equals ( ( ( vslRecKey ) v ) . getKey ( ) ) ; } }
tr	8	public String getLastLine ( ) { try ( RandomAccessFile file = new RandomAccessFile ( f , "r" ) ) { long index , length ; length = file . length ( ) ; index = length - 1 ; int ch = 0 ; while ( ch != 30 && index > 0 ) { file . seek ( index -- ) ; ch = ( file . read ( ) ) ; } if ( index == 0 ) { return null ; } file . seek ( index -- ) ; ch = ( file . read ( ) ) ; while ( ch != 30 && index > 0 ) { file . seek ( index -- ) ; ch = ( file . read ( ) ) ; } file . seek ( index ++ ) ; StringBuilder sb = new StringBuilder ( ) ; sb . append ( in . readUTF ( ) ) ; sb . append ( "\t" ) ; in . readChar ( ) ; sb . append ( in . readLong ( ) ) ; sb . append ( "\t" ) ; in . readChar ( ) ; sb . append ( df . format ( new Date ( in . readLong ( ) ) ) ) ; sb . append ( "\t" ) ; in . readChar ( ) ; sb . append ( TimeConvert . millisToDays ( in . readLong ( ) ) ) ; sb . append ( "\t" ) ; in . readChar ( ) ; sb . append ( in . readDouble ( ) ) ; sb . append ( "\t" ) ; in . readChar ( ) ; sb . append ( in . readDouble ( ) ) ; sb . append ( "\t" ) ; in . readChar ( ) ; sb . append ( in . readDouble ( ) ) ; sb . append ( "\t" ) ; in . readChar ( ) ; sb . append ( in . readDouble ( ) ) ; sb . append ( "\t" ) ; in . readChar ( ) ; String code = in . readUTF ( ) ; sb . append ( code ) ; if ( code == "S" ) { sb . append ( in . readUTF ( ) ) ; } sb . append ( "\t" ) ; in . readChar ( ) ; sb . append ( in . readBoolean ( ) ) ; sb . append ( "\t" ) ; in . readChar ( ) ; sb . append ( in . readDouble ( ) ) ; sb . append ( "\t" ) ; in . readChar ( ) ; sb . append ( in . readDouble ( ) ) ; sb . append ( "\t" ) ; in . readChar ( ) ; sb . append ( in . readDouble ( ) ) ; sb . append ( "\t" ) ; in . readChar ( ) ; sb . append ( in . readDouble ( ) ) ; sb . append ( "\t" ) ; in . readChar ( ) ; sb . append ( in . readDouble ( ) ) ; sb . append ( "\t" ) ; in . readChar ( ) ; sb . append ( in . readDouble ( ) ) ; sb . append ( "\t" ) ; in . readChar ( ) ; sb . append ( in . readDouble ( ) ) ; sb . append ( "\t" ) ; in . readChar ( ) ; return sb . toString ( ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return null ; }
tr	3	Vector < Vector < String >> getProgrammeSchedule ( ) { Vector < Programme > programmeList = event . getProgrammeSchedule ( ) ; Vector < Vector < String >> programmeVector = new Vector < Vector < String >> ( ) ; Vector < String > programmeDetail ; Programme currProgramme ; String timeStr ; for ( int i = 0 ; i < programmeList . size ( ) ; ++ i ) { programmeDetail = new Vector < String > ( ) ; currProgramme = programmeList . get ( i ) ; programmeDetail . add ( currProgramme . getProgrammeDate ( ) ) ; timeStr = String . valueOf ( currProgramme . getStartTime ( ) ) ; if ( timeStr . equals ( "-1" ) ) programmeDetail . add ( "" ) ; else programmeDetail . add ( timeStr ) ; timeStr = String . valueOf ( currProgramme . getEndTime ( ) ) ; if ( timeStr . equals ( "-1" ) ) programmeDetail . add ( "" ) ; else programmeDetail . add ( timeStr ) ; programmeDetail . add ( currProgramme . getTitle ( ) ) ; programmeDetail . add ( currProgramme . getInCharge ( ) ) ; programmeVector . add ( programmeDetail ) ; } return programmeVector ; }
tr	3	@ Override public void assignValue ( Designator d , BasicBlock cur , BasicBlock join , Environment env , Value newVal ) throws Exception { if ( global ) { used = true ; } if ( ! ( d instanceof ArrayDesignator ) ) { throw new Exception ( "Array accessed as a variable" ) ; } Value a = emitIndexingCode ( ( ArrayDesignator ) d , cur ) ; Store s = new Store ( d . getVarName ( ) , a , newVal ) ; cur . addInstruction ( s ) ; if ( join != null ) { join . addAtEndBeforeBranch ( new Kill ( d . getVarName ( ) ) ) ; } }
tr	7	public static void readHash3 ( String type_map , HashMap < String , double > hashMap ) { ArrayList < String > types = new ArrayList < String > ( ) ; ArrayList < String > tokens = new ArrayList < String > ( ) ; if ( type_map != null ) { FileUtil . readLines ( type_map , types ) ; for ( int i = 0 ; i < types . size ( ) ; i ++ ) { if ( ! types . get ( i ) . isEmpty ( ) ) { ComUtil . tokenize ( types . get ( i ) , tokens ) ; if ( tokens . size ( ) != 0 ) { if ( tokens . size ( ) != 2 ) { for ( int j = 0 ; j < tokens . size ( ) ; j ++ ) { System . out . print ( tokens . get ( j ) + " " ) ; } System . err . println ( type_map + " Error ! Not two elements in one line !" ) ; return ; } if ( ! hashMap . containsKey ( tokens . get ( 0 ) ) ) hashMap . put ( tokens . get ( 0 ) , new double ( tokens . get ( 1 ) ) ) ; else { System . out . println ( tokens . get ( 0 ) + " " + tokens . get ( 1 ) ) ; System . err . println ( type_map + " Error ! Same type in first column !" ) ; return ; } } tokens . clear ( ) ; } } } }
tr	0	public void setContext ( String value ) { this . context = value ; }
tr	7	private Observer createObserver ( ) { return new Observer ( ) { @ Override public void update ( final String event ) { switch ( event ) { case "Opened" : int count = cell . countNeighborsWithMines ( ) ; refresh ( ( count == 0 ) ? "" : Integer . toString ( count ) ) ; break ; case "Marked" : marked = true ; notifyObservers ( "marked" ) ; break ; case "errorMarked" : notifyObservers ( "errorMarked" ) ; break ; case "Locked" : notifyObservers ( "*" ) ; break ; case "Exploded" : notifyObservers ( "**" ) ; Action act = factory . createAction ( "GameOver" ) ; if ( act != null ) act . execute ( ) ; break ; default : restart ( ) ; } } } ; }
tr	0	public TransformationScaleXY ( Node node ) { NamedNodeMap attr = node . getAttributes ( ) ; scaleX = float . parseFloat ( attr . getNamedItem ( "scaleX" ) . getNodeValue ( ) ) ; scaleY = float . parseFloat ( attr . getNamedItem ( "scaleY" ) . getNodeValue ( ) ) ; transform . setToScale ( scaleX , scaleY ) ; }
tr	4	private void doTag ( Element element ) { String tagAttribute = element . getAttribute ( "tag" ) ; if ( tagAttribute == null || ! MetaHeaders . ATTRIBUTE_LIST . contains ( tagAttribute ) ) { return ; } NodeList childNodeList = element . getChildNodes ( ) ; if ( childNodeList == null || childNodeList . getLength ( ) == 0 ) { return ; } this . doSubtTag ( tagAttribute , childNodeList ) ; }
tr	9	public void mousePressed ( MouseEvent e ) { Point pt = new Point ( e . getX ( ) , e . getY ( ) ) ; if ( e . getComponent ( ) != null ) { SwingUtilities . convertPointToScreen ( pt , e . getComponent ( ) ) ; } panCurr = new PointAtTime ( pt . x , pt . y ) ; prevPanCurr = panCurr ; if ( e . getButton ( ) == 1 ) { CoverDetails temp = ctx . getSelectedAt ( e ) ; if ( ! isCtrlDown ( e ) ) { if ( editMode || ( temp != null && temp . isUndefinedPosition ( ) ) ) { if ( ! e . isShiftDown ( ) && ! ctx . isSelected ( temp ) ) { ctx . clearSelection ( ) ; } if ( e . isShiftDown ( ) && ctx . isSelected ( temp ) ) { ctx . removeSelection ( temp ) ; } else { ctx . addSelection ( temp ) ; } if ( temp != null ) { ctx . dragging = true ; } else { ctx . rubberBanding = true ; } } } ctx . dragStart = new Point ( e . getX ( ) , e . getY ( ) ) ; ctx . dragCurr = new Point ( e . getX ( ) , e . getY ( ) ) ; ctx . mainRepaint ( ) ; } }
tr	1	private JPanel makeClientListPanel ( ) { JPanel result = new JPanel ( new BorderLayout ( ) ) ; clientList = new ClientList ( ) ; clientList . addListSelectionListener ( new ListSelectionListener ( ) { @ Override public void valueChanged ( ListSelectionEvent e ) { if ( clientList . getSelectedID ( ) == - 1 ) { btKick . setEnabled ( false ) ; } else { btKick . setEnabled ( true ) ; } } } ) ; result . add ( clientList , BorderLayout . CENTER ) ; btKick = new JButton ( "Kick" ) ; btKick . setEnabled ( false ) ; btKick . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { kick ( ) ; } } ) ; btKick . addKeyListener ( new KeyAdapter ( ) { @ Override public void keyPressed ( KeyEvent e ) { kick ( ) ; } } ) ; result . add ( btKick , BorderLayout . SOUTH ) ; return result ; }
tr	8	@ Override public int [ ] generate ( ArrayList < Function > program ) throws Exception { if ( ! program . get ( program . size ( ) - 1 ) . name . getString ( ) . equals ( "__MAIN__" ) ) { throw new Exception ( "Main not found" ) ; } emit ( DLX . assemble ( DLX . ADDI , sp , zero , 0 ) ) ; emit ( DLX . assemble ( DLX . ADD , fp , zero , sp ) ) ; boolean main = true ; for ( int i = program . size ( ) - 1 ; i >= 0 ; i -- ) { Function f = program . get ( i ) ; currentFunction = f ; makeLabel ( f . name ) ; AnalyzeRegistersUsed analysis = new AnalyzeRegistersUsed ( registersAvailable , retAddr - minAvail ) ; f . entryPoint . runPass ( analysis ) ; f . locals . allocateMemoryCells ( analysis . memNeeded ) ; regStack . clear ( ) ; if ( ! main ) { push ( fp ) ; emit ( DLX . assemble ( DLX . ADD , fp , zero , sp ) ) ; } if ( f . locals . getSize ( ) > 0 ) { emit ( DLX . assemble ( DLX . ADDI , sp , sp , f . locals . getSize ( ) ) ) ; } if ( ! main ) { for ( Integer reg : analysis . registersUsed ) { int realReg = reg + minAvail ; regStack . push ( realReg ) ; push ( realReg ) ; } } emitCode ( f . entryPoint ) ; main = false ; } if ( ! fixup . isEmpty ( ) ) { throw new Exception ( "Unresolved branch location" ) ; } int spSet = code . get ( 0 ) ; spSet = setC ( spSet , 4 * code . size ( ) ) ; code . set ( 0 , spSet ) ; int [ ] rval = new int [ code . size ( ) ] ; for ( int i = 0 ; i < code . size ( ) ; i ++ ) { rval [ i ] = code . get ( i ) ; } code . clear ( ) ; return rval ; }
tr	5	public DataFrame parse ( ) throws ParseException { DataFrame retval = null ; Tag tag = null ; do { tag = readTag ( ) ; if ( tag == null ) { break ; } } while ( tag . isComment ( ) || tag . isPreamble ( ) ) ; if ( ( tag != null ) && tag . isOpenTag ( ) ) { retval = readFrame ( tag ) ; } return retval ; }
tr	1	public static void addClass ( Node node , String classname ) { AttVal classattr = node . getAttrByName ( "class" ) ; if ( classattr != null ) { classattr . value = classattr . value + " " + classname ; } else node . addAttribute ( "class" , classname ) ; }
tr	2	public void listen ( int port ) { try { server = new ServerSocket ( port ) ; listening = true ; while ( listening ) { new HTTPClient ( server . accept ( ) ) . start ( ) ; } } catch ( Exception ex ) { ex . printStackTrace ( ) ; } }
tr	4	public SubstrateNetwork readSubstrateNetwork ( String filename ) { Scanner scanner = null ; try { scanner = new Scanner ( new File ( filename ) ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } HashMap < Integer , PhysicalNode > physicalNodes = new HashMap < Integer , PhysicalNode > ( ) ; HashMap < String , PhysicalLink > physicalLinks = new HashMap < String , PhysicalLink > ( ) ; String [ ] tokens = scanner . nextLine ( ) . split ( " " ) ; int amountNodes = Integer . valueOf ( tokens [ 0 ] ) ; int amountLinks = Integer . valueOf ( tokens [ 1 ] ) ; for ( int i = 0 ; i < amountNodes ; i ++ ) { tokens = scanner . nextLine ( ) . split ( " " ) ; physicalNodes . put ( i , new PhysicalNode ( i , double . valueOf ( tokens [ 2 ] ) ) ) ; } for ( int i = 0 ; i < amountLinks ; i ++ ) { tokens = scanner . nextLine ( ) . split ( " " ) ; int sourceNodeId = Math . max ( Integer . valueOf ( tokens [ 0 ] ) , Integer . valueOf ( tokens [ 1 ] ) ) ; int destinyNodeId = Math . min ( Integer . valueOf ( tokens [ 0 ] ) , Integer . valueOf ( tokens [ 1 ] ) ) ; String linkId = String . format ( "%s:%s" , sourceNodeId , destinyNodeId ) ; if ( ! physicalLinks . containsKey ( linkId ) ) { physicalLinks . put ( linkId , new PhysicalLink ( linkId , physicalNodes . get ( sourceNodeId ) , physicalNodes . get ( destinyNodeId ) , double . valueOf ( tokens [ 2 ] ) , double . valueOf ( tokens [ 3 ] ) , 0 ) ) ; } } this . substrateNetwork = new SubstrateNetwork ( physicalNodes , physicalLinks ) ; return this . substrateNetwork ; }
tr	0	public int score ( String input ) { return Integer . parseInt ( input ) ; }
tr	8	public void addEdge ( Edge edge ) { if ( edge == null ) throw new IllegalArgumentException ( ) ; if ( edge . getX ( ) < 0 || edge . getX ( ) >= vertices . length || edge . getY ( ) < 0 || edge . getY ( ) >= vertices . length ) { throw new IllegalArgumentException ( "Wrong edge parameters" ) ; } for ( Edge e : edges ) { if ( e . equals ( edge ) ) { throw new IllegalArgumentException ( "Edge with such parameters already exists" ) ; } } edges . add ( edge ) ; if ( edge . isDirected ( ) ) { vertices [ edge . getX ( ) ] . getEdges ( ) . add ( edge ) ; } else { vertices [ edge . getX ( ) ] . getEdges ( ) . add ( edge ) ; vertices [ edge . getY ( ) ] . getEdges ( ) . add ( edge ) ; } }
tr	1	private void leesmxl ( ) throws RuntimeException { try { JAXBContext jc = JAXBContext . newInstance ( PlayerInfoLezer . class ) ; PlayerInfoLezer pi = ( PlayerInfoLezer ) jc . createUnmarshaller ( ) . unmarshal ( PlayerInfoLezer . class . getResource ( "PlayerInfo.xml" ) ) ; name = pi . getName ( ) ; points = pi . getPoints ( ) ; happiness = pi . getHappiness ( ) ; energy = pi . getEnergy ( ) ; dood = pi . isDood ( ) ; fireInvalidationEvent ( ) ; } catch ( JAXBException ex ) { throw new RuntimeException ( "JAXB:" + ex ) ; } }
tr	4	public static double stop ( String key , long dataAmount ) { if ( key == null ) throw new RuntimeException ( "ElapsedTime key can't be null" ) ; TransferRateInterval entry = mSampleSetManager . get ( key ) ; if ( entry == null || entry . mStartTime < 0 ) throw new RuntimeException ( "stop(" + key + ") called but there was no matching start" ) ; double timeSample = ( System . nanoTime ( ) - entry . mStartTime ) * MSEC_SCALE ; entry . mStartTime = - 1 ; entry . addSample ( timeSample , dataAmount ) ; return timeSample > 0.0 ? dataAmount / timeSample : double . MAX_VALUE ; }
tr	3	private void writeQNameAttribute ( java . lang . String namespace , java . lang . String attName , javax . xml . namespace . QName qname , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { java . lang . String attributeNamespace = qname . getNamespaceURI ( ) ; java . lang . String attributePrefix = xmlWriter . getPrefix ( attributeNamespace ) ; if ( attributePrefix == null ) { attributePrefix = registerPrefix ( xmlWriter , attributeNamespace ) ; } java . lang . String attributeValue ; if ( attributePrefix . trim ( ) . length ( ) > 0 ) { attributeValue = attributePrefix + ":" + qname . getLocalPart ( ) ; } else { attributeValue = qname . getLocalPart ( ) ; } if ( namespace . equals ( "" ) ) { xmlWriter . writeAttribute ( attName , attributeValue ) ; } else { registerPrefix ( xmlWriter , namespace ) ; xmlWriter . writeAttribute ( namespace , attName , attributeValue ) ; } }
tr	2	private void jButton3ActionPerformed ( java . awt . event . ActionEvent evt ) { redirectSystemStreams ( ) ; if ( ImportUtilities . getPopulationRecords ( ) . isEmpty ( ) ) { Component component = ( Component ) evt . getSource ( ) ; JFrame frame = ( JFrame ) SwingUtilities . getRoot ( component ) ; JOptionPane . showMessageDialog ( frame , "You CAN NOT deserialize population records before reading data!" , "Warning" , JOptionPane . WARNING_MESSAGE ) ; } if ( PersistentObject . isPopulationRecordsHasValue ( ) ) { System . out . println ( "Deserialization starts." ) ; System . out . println ( "." ) ; System . out . println ( "." ) ; System . out . println ( "." ) ; long timeDifference = ImportUtilities . deserializePopulationRecords ( ) ; System . out . println ( "The time difference between serialization and deserialization is " + timeDifference + " seconds" ) ; System . out . println ( "Derialization succeeded  you may perform Data Analytics now!" ) ; } else { Component component = ( Component ) evt . getSource ( ) ; JFrame frame = ( JFrame ) SwingUtilities . getRoot ( component ) ; JOptionPane . showMessageDialog ( frame , "You CAN NOT deserialize population records before serialization!" , "Warning" , JOptionPane . WARNING_MESSAGE ) ; } }
tr	5	public State nextStateTraining ( String tag ) { State next = null ; State st = null ; int numTrans = 0 ; int otherTrans = 0 ; int totalTrans = 0 ; double ratio = 0 ; current . addTransition ( tag ) ; next = current . next ( tag ) ; numTrans = current . getTransitions ( tag ) ; totalTrans = next . getAllTransitions ( ) ; otherTrans = totalTrans - numTrans ; if ( ( numTrans > condition1 ) && ( otherTrans > condition2 ) ) { st = new State ( next . getCloneName ( ) ) ; current . addConnection ( tag , st , true ) ; st . addMasterConnection ( next . getMasterConnection ( ) . getTo ( ) ) ; for ( Connection cn : next . allConnections ( ) ) { st . addConnection ( cn . getTag ( ) , cn . getTo ( ) ) ; } ratio = ( double ) ( ( ( double ) numTrans ) / ( ( double ) totalTrans ) ) ; st . copyCounters ( next , ratio ) ; estats . add ( st ) ; hashstats . put ( st . getName ( ) , st ) ; next = st ; } if ( this . backoff && ! current . hasConnection ( tag ) ) next = current . next ( tag ) . next ( tag ) ; return next ; }
tr	8	public void updateEntities ( ) { ArrayList < Entity > changed = new ArrayList < Entity > ( ) ; for ( Entity e : toRegister ) { registerEntity ( e ) ; } for ( Entity e : toCreate ) { Body body = this . createBody ( e . getBd ( ) ) ; FixtureDef fd = e . getFd ( ) ; body . createFixture ( fd ) ; e . setBody ( body ) ; body . setUserData ( e ) ; System . out . println ( body ) ; } toCreate . clear ( ) ; toRegister . clear ( ) ; for ( String s : es . keySet ( ) ) { for ( int x = 0 ; x < es . get ( s ) . size ( ) ; x ++ ) { Entity e = es . get ( s ) . get ( x ) ; e . update ( ) ; if ( ! e . getLocation ( ) . getId ( ) . equals ( s ) ) { changed . add ( e ) ; es . get ( s ) . remove ( x ) ; } } } for ( int x = 0 ; x < changed . size ( ) ; x ++ ) { Entity e = changed . get ( x ) ; String id = e . getLocation ( ) . getId ( ) ; if ( ! es . containsKey ( id ) ) es . put ( id , new ArrayList < Entity > ( ) ) ; es . get ( e . getLocation ( ) . getId ( ) ) . add ( e ) ; } for ( Entity e : removeQueue ) { removeEntity ( e ) ; } removeQueue . clear ( ) ; }
tr	6	private boolean processProduction ( Production production , Grammar grammar , FirstSets firstSets ) { if ( production . isEpsilonMove ( ) ) { return false ; } boolean result = false ; int index = 0 ; for ( final Symbol symbol : production . getRight ( ) ) { final Set < Symbol > follow = sets . get ( symbol ) ; final Set < Symbol > first = firstSets . getFirstSet ( production . getRight ( ) , index + 1 ) ; if ( ( first . remove ( grammar . getEpsilon ( ) ) || ( index == production . getRight ( ) . size ( ) - 1 ) ) && follow . addAll ( sets . get ( production . getLeft ( ) ) ) ) { result = true ; } if ( follow . addAll ( first ) ) { result = true ; } index ++ ; } return result ; }
tr	1	private List < TestStorable > readFile ( List < long > filePositions , DRUMSParameterSet < TestStorable > globalParameters ) throws Exception { HeaderIndexFile < TestStorable > file = new HeaderIndexFile < TestStorable > ( testFilename , AccessMode . READ_ONLY , 1 , globalParameters ) ; List < TestStorable > readData = new ArrayList < TestStorable > ( ) ; for ( long currentFilePosition : filePositions ) { byte [ ] buffer = new byte [ globalParameters . getPrototype ( ) . getSize ( ) ] ; file . read ( currentFilePosition , buffer ) ; TestStorable oneReadTestStorable = new TestStorable ( buffer ) ; readData . add ( oneReadTestStorable ) ; } file . close ( ) ; return readData ; }
tr	0	public JSTableDialog ( String title , String [ ] headings , int rows ) { this ( title , headings , getDefaultButtonArray ( ) , rows ) ; }
tr	4	private boolean checkIfGameOver ( final boolean [ ] [ ] activityMock , final boolean [ ] [ ] visibilityMock ) { for ( int xCurrent = 0 ; xCurrent < boardSize ; xCurrent ++ ) for ( int yCurrent = 0 ; yCurrent < boardSize ; yCurrent ++ ) { if ( activityMock [ xCurrent ] [ yCurrent ] . equals ( true ) && ( visibilityMock [ xCurrent ] [ yCurrent ] . equals ( true ) ) ) { return false ; } } return true ; }
tr	2	public void rempirListEtude ( ) { String Sreqlist ; listEtude . removeAllItems ( ) ; Sreqlist = "select * from ASSOCIATION join ETUDE " + "on ASSOCIATION.IDCONVENTION = ETUDE.IDCONVENTION " + "WHERE IDETUDIANT =" + idetudiant ; try { listEtude . addItem ( "Selectionner l'\u00E9tude \u00E0 d\u00E9tailler" ) ; openConnection ( ) ; java . sql . Statement reqlist = conn . createStatement ( ) ; java . sql . ResultSet resullist = reqlist . executeQuery ( Sreqlist ) ; while ( resullist . next ( ) ) { listEtude . addItem ( makeObj ( resullist . getInt ( "IDCONVENTION" ) + " -- " + resullist . getString ( "NOMETUDE" ) ) ) ; } reqlist . close ( ) ; resullist . close ( ) ; closeConnection ( ) ; } catch ( java . sql . SQLException e ) { ModelInfo . addElement ( "Erreur execution requete " + e . getMessage ( ) ) ; affAccompte . setModel ( ModelInfo ) ; } }
tr	7	public Level ( ) { Bitmap bmp = Art . load ( "/levels/level.png" ) ; int w = bmp . w + 8 ; int h = bmp . h + 8 ; this . w = w ; this . h = h ; xs = w ; ys = h ; blockmap = new Blockmap ( w * 16 , h * 16 , 32 ) ; tiles = new int [ xs * ys ] ; for ( int y = 0 ; y < ys ; y ++ ) { for ( int x = 0 ; x < xs ; x ++ ) { int xx = x - 4 ; int yy = y - 4 ; if ( xx < 0 || yy < 0 || xx >= bmp . w || yy >= bmp . h ) { tiles [ x + y * xs ] = 1 ; } else { int col = bmp . pixels [ xx + yy * bmp . w ] ; if ( col == ff000000 ) { tiles [ x + y * xs ] = 1 ; } else { tiles [ x + y * xs ] = 0 ; } } } } redPlayer = new Player ( this , Team . allied ) ; bluPlayer = new Player ( this , Team . soviet ) ; }
tr	8	public static void clusteNouns ( ) { DBUtil db1 = new DBUtil ( ) ; Logger . getInstance ( ) . getElapseTime ( true ) ; String sql = "select * from extractions" ; ResultSet rs1 = db1 . executeQuerySQL ( sql ) ; try { while ( rs1 . next ( ) ) { int sentIndex = rs1 . getInt ( "sentindex" ) ; String attr = rs1 . getString ( "attr" ) ; String value = rs1 . getString ( "value" ) ; if ( extractionHash . containsKey ( attr ) ) { if ( extractionHash . get ( attr ) . containsKey ( value ) ) { extractionHash . get ( attr ) . put ( value , extractionHash . get ( attr ) . get ( value ) + 1 ) ; } else { extractionHash . get ( attr ) . put ( value , 1 ) ; } } else { Map < String , Integer > tmp = new HashMap < String , Integer > ( ) ; tmp . put ( value , 1 ) ; extractionHash . put ( attr , tmp ) ; } } } catch ( SQLException e ) { e . printStackTrace ( ) ; } Logger . getInstance ( ) . getElapseTime ( true ) ; attrList = new ArrayList < String > ( ) ; sql = "select DISTINCT attr from extractions" ; rs1 = db1 . executeQuerySQL ( sql ) ; try { while ( rs1 . next ( ) ) { String attr = rs1 . getString ( "attr" ) ; attrList . add ( attr ) ; } } catch ( SQLException e ) { e . printStackTrace ( ) ; } valList = new ArrayList < String > ( ) ; sql = "select DISTINCT value from extractions" ; rs1 = db1 . executeQuerySQL ( sql ) ; try { while ( rs1 . next ( ) ) { String val = rs1 . getString ( "value" ) ; valList . add ( val ) ; } } catch ( SQLException e ) { e . printStackTrace ( ) ; } Logger . getInstance ( ) . getElapseTime ( true ) ; db1 . rundown ( ) ; OutputtoCytoscapeFile ( "output.csv" ) ; }
