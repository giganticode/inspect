tr	0	public void obtainReservations ( ) { BigDecimal [ ] reservations = { BigDecimal . valueOf ( long . valueOf ( "1" ) ) , BigDecimal . valueOf ( long . valueOf ( "2" ) ) } ; System . out . println ( "Invoking Managed Tasks" ) ; ejbFacade . getReservations ( reservations ) ; setReservationListMessage ( "The reservation report has been initated" ) ; }
tr	1	private InputStream getBufferedBody ( ) { if ( this . _bufferedOutput == null ) { return null ; } return new ByteArrayInputStream ( this . _bufferedOutput ) ; }
tr	2	public void deleteClient ( int id ) throws ClientDeleteException , ClientDoesNotExistException { try { CallableStatement callStat = _connection . prepareCall ( "{ call deleteClient(?) }" ) ; callStat . setInt ( 1 , id ) ; callStat . execute ( ) ; callStat . close ( ) ; } catch ( SQLException e ) { if ( e . getSQLState ( ) . equals ( "V2002" ) ) { throw new ClientDoesNotExistException ( e ) ; } throw new ClientDeleteException ( e ) ; } }
tr	6	private static int binarySearch ( int [ ] array , int lowIndex , int highIndex , int num ) { int mid = ( highIndex + lowIndex ) / 2 ; if ( lowIndex == highIndex && array [ lowIndex ] != num ) { if ( num < array [ lowIndex ] ) { return ( lowIndex * - 1 ) ; } else if ( num > array [ lowIndex ] ) { return ( lowIndex + 1 ) * - 1 ; } else { return ( lowIndex - 1 ) * - 1 ; } } if ( num == array [ mid ] ) { return mid ; } else if ( num < array [ mid ] ) { return binarySearch ( array , lowIndex , mid , num ) ; } return binarySearch ( array , mid + 1 , highIndex , num ) ; }
tr	4	public void unreadFrame ( ) throws BitstreamException { if ( wordpointer == - 1 && bitindex == - 1 && ( framesize > 0 ) ) { try { source . unread ( frame_bytes , 0 , framesize ) ; } catch ( IOException ex ) { throw newBitstreamException ( STREAM_ERROR ) ; } } }
tr	2	public static void main ( String [ ] args ) { DateFormat dateFormat = new SimpleDateFormat ( DateUtil . DATE_FORMAT ) ; Date birthDate = null ; try { birthDate = dateFormat . parse ( "1983-12-07" ) ; } catch ( ParseException ex ) { ex . printStackTrace ( System . err ) ; } LoginInfo loginInfo = new LoginInfo ( "shamim" , "secret" ) ; BillingInfo billingInfo = new BillingInfo ( "003-254992-001" , CreditCardType . MASTERCARD ) ; BiographicalInfo biographicalInfo = new BiographicalInfo ( "Shamim" , "Ahmed" , birthDate ) ; userCreator . setLoginInfo ( loginInfo ) ; userCreator . setBillingInfo ( billingInfo ) ; userCreator . setBiographicalInfo ( biographicalInfo ) ; boolean result = userCreator . addUser ( ) ; System . out . printf ( "User %s created successfully%n" , result ? "was" : "was not" ) ; }
tr	4	@ Override public int compareTo ( JTimePicker B ) { JTimePicker A = this ; int hourA = A . getHour ( ) ; int minA = A . getMinute ( ) ; int hourB = B . getHour ( ) ; int minB = B . getMinute ( ) ; if ( hourA < hourB ) { return - 1 ; } else if ( hourA > hourB ) { return 1 ; } if ( minA < minB ) { return - 1 ; } else if ( minA > minB ) { return 1 ; } return 0 ; }
tr	3	public Item useItem ( ) { if ( objectType [ selectedItem ] . isPlacable ( ) ) { if ( objectNumber [ selectedItem ] >= 1 ) { objectNumber [ selectedItem ] -- ; if ( objectNumber [ selectedItem ] == 0 ) { Item tmp = objectType [ selectedItem ] ; objectType [ selectedItem ] = noItem ; return tmp ; } } return objectType [ selectedItem ] ; } return noItem ; }
tr	6	@ Override public Article find ( int id ) { Article found = null ; PreparedStatement pst = null ; ResultSet rs = null ; try { pst = this . connect ( ) . prepareStatement ( "select * from Article where id= ?" ) ; pst . setInt ( 1 , id ) ; rs = pst . executeQuery ( ) ; System . out . println ( "recherche individuelle r\u00E9ussie" ) ; if ( rs . next ( ) ) { found = new Article ( rs . getInt ( "id" ) , rs . getString ( "titre" ) , rs . getString ( "resume" ) , rs . getDate ( "date" ) ) ; } } catch ( SQLException ex ) { Logger . getLogger ( ArticleDao . class . getName ( ) ) . log ( Level . SEVERE , "recherche individuelle echou\u00E9" , ex ) ; } finally { try { if ( rs != null ) rs . close ( ) ; } catch ( SQLException ex ) { Logger . getLogger ( ArticleDao . class . getName ( ) ) . log ( Level . SEVERE , "liberation result set echou\u00E9" , ex ) ; } try { if ( pst != null ) pst . close ( ) ; } catch ( SQLException ex ) { Logger . getLogger ( ArticleDao . class . getName ( ) ) . log ( Level . SEVERE , "liberation prepared statement echou\u00E9" , ex ) ; } } return found ; }
tr	3	public void stateChanged ( ChangeEvent arg0 ) { JSpinner spinner = ( JSpinner ) arg0 . getSource ( ) ; if ( ! loading && ( spinner . equals ( heightSpinner ) || spinner . equals ( widthSpinner ) ) ) { board = new Board ( ( ( Integer ) widthSpinner . getValue ( ) ) . intValue ( ) , ( ( Integer ) heightSpinner . getValue ( ) ) . intValue ( ) ) ; boardPanel . setBoard ( board , true ) ; System . out . println ( "Changed size" ) ; this . getParent ( ) . repaint ( ) ; this . repaint ( ) ; } }
tr	9	private static int method508 ( char ac [ ] , char ac1 [ ] , int i ) { if ( i + 1 == ac . length ) return 2 ; for ( int j = i + 1 ; j < ac . length ; j ++ ) { if ( ! method517 ( ac [ j ] ) ) break ; if ( ac [ j ] == \ || ac [ j ] == / ) return 3 ; } int k = 0 ; for ( int l = i + 1 ; l < ac . length ; l ++ ) { if ( ! method517 ( ac1 [ l ] ) ) break ; if ( ac1 [ l ] == * ) k ++ ; } if ( k >= 5 ) return 4 ; return ! method517 ( ac [ i + 1 ] ) ? 0 : 1 ; }
tr	8	protected Value getValueByPoint ( Point p ) { if ( valueCircles != null && p != null ) { for ( int i = 0 ; i < valueCircles . length ; i ++ ) { Point vc = valueCircles [ i ] ; if ( vc != null ) { if ( ( p . getX ( ) > vc . getX ( ) - POINT_SIZE . width ) && ( p . getX ( ) < vc . getX ( ) + POINT_SIZE . width ) ) { if ( ( p . getY ( ) > vc . getY ( ) - POINT_SIZE . height ) && ( p . getY ( ) < vc . getY ( ) + POINT_SIZE . height ) ) { return getValues ( ) [ i ] ; } } } } } return null ; }
tr	1	public void setHealth ( int health ) { if ( health <= getMaxHealth ( ) ) this . health = health ; else this . health = getMaxHealth ( ) ; }
tr	1	@ Test @ Ignore public void haveDinner ( ) throws Exception { int eatTimes = 3 ; int numPhilosophers = 5 ; CountDownLatch waitTillAllInitialized = new CountDownLatch ( numPhilosophers ) ; CountDownLatch waitTillAllDoneDining = new CountDownLatch ( numPhilosophers ) ; AtomicInteger availableForks = new AtomicInteger ( numPhilosophers ) ; List < DiningPhilosopher > philosophers = new ArrayList < > ( ) ; for ( int i = 1 ; i <= numPhilosophers ; i ++ ) { DiningPhilosopher philosopher = new DiningPhilosopher ( i , availableForks , eatTimes , waitTillAllDoneDining ) ; philosophers . add ( philosopher ) ; } ImmutableList < DiningPhilosopher > allPhilosophers = new ImmutableList < > ( philosophers ) ; philosophers . forEach ( ( DiningPhilosopher philosopher ) -> { philosopher . start ( allPhilosophers , Registry . getDefault ( ) ) ; } ) ; waitTillAllDoneDining . await ( ) ; System . out . println ( "all philosophers done each dining " + eatTimes + " times" ) ; }
tr	6	@ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; HostRef other = ( HostRef ) obj ; if ( hostId == null ) { if ( other . hostId != null ) return false ; } else if ( ! hostId . equals ( other . hostId ) ) return false ; return true ; }
tr	6	public static void main ( String [ ] args ) { AvlTree t = new AvlTree ( ) ; final int NUMS = 4000 ; final int GAP = 37 ; System . out . println ( "Checking... (no more output means success)" ) ; for ( int i = GAP ; i != 0 ; i = ( i + GAP ) % NUMS ) t . insert ( new MyInteger ( i ) ) ; if ( NUMS < 40 ) t . printTree ( ) ; if ( ( ( MyInteger ) ( t . findMin ( ) ) ) . intValue ( ) != 1 || ( ( MyInteger ) ( t . findMax ( ) ) ) . intValue ( ) != NUMS - 1 ) System . out . println ( "FindMin or FindMax error!" ) ; for ( int i = 1 ; i < NUMS ; i ++ ) if ( ( ( MyInteger ) ( t . find ( new MyInteger ( i ) ) ) ) . intValue ( ) != i ) System . out . println ( "Find error1!" ) ; }
tr	3	public User Authenticate ( String username , String password ) { DBConnection connection = DBConnection . sharedInstance ( ) ; ResultSet rs = connection . performQuery ( " SELECT * FROM users WHERE username = \"" + username + "\"" ) ; try { if ( rs . next ( ) ) { password = GenerateHash ( password ) ; if ( rs . getString ( "password" ) . equals ( password ) ) { UserFactory factory = UserFactory . sharedInstance ( ) ; User user = factory . getUserFromID ( rs . getInt ( "id" ) ) ; return user ; } } } catch ( SQLException e ) { e . printStackTrace ( ) ; return null ; } return null ; }
tr	5	@ Override public void actionPerformed ( ActionEvent e ) { name = persoName . getText ( ) . toString ( ) ; vitesse = vitesseSlider . getValue ( ) ; force = forceSlider . getValue ( ) ; if ( gestionnaire != null ) { JFileChooser filechooser = new JFileChooser ( "." ) { public void approveSelection ( ) { fileSelected = getSelectedFile ( ) ; if ( fileSelected . exists ( ) ) { int result = JOptionPane . showConfirmDialog ( this , "\u00C9craser le fichier?" , "Confirmation" , JOptionPane . YES_NO_CANCEL_OPTION ) ; switch ( result ) { case JOptionPane . YES_OPTION : super . approveSelection ( ) ; return ; default : super . cancelSelection ( ) ; } } else super . approveSelection ( ) ; } } ; if ( filechooser . showSaveDialog ( null ) == JFileChooser . APPROVE_OPTION ) { gestionnaire . ajouterPersonnage ( name , raceChoosen , force , vitesse , inclinaisonChoisie , armeChoisie , armureChoisie ) ; EntreesSorties . sauvegarderFichier ( gestionnaire . getPersonnages ( ) . toString ( ) , filechooser . getSelectedFile ( ) ) ; } } else { JOptionPane . showMessageDialog ( persoPanel , "veuillez cr\u00E9er un nouveau gestionnaire ou charger un gestionnaire existant" , "Erreur" , JOptionPane . ERROR_MESSAGE ) ; } try { gestionnaire . addToFile ( gestionnaire . getPersonnages ( ) , fileSelected ) ; GestionnaireUI . initPersonnageIntoList ( ) ; } catch ( Exception e1 ) { e1 . printStackTrace ( ) ; } revalidate ( ) ; mainframe . dispose ( ) ; }
tr	4	public StringLargeArray ( long length , int maxStringLength , boolean zeroNativeMemory ) { this . type = LargeArrayType . STRING ; this . sizeof = 1 ; if ( length <= 0 ) { throw new IllegalArgumentException ( length + " is not a positive long value." ) ; } if ( maxStringLength <= 0 ) { throw new IllegalArgumentException ( maxStringLength + " is not a positive int value." ) ; } this . length = length ; this . size = length * ( long ) maxStringLength * ( long ) CHARSET_SIZE ; this . maxStringLength = maxStringLength ; if ( length > LARGEST_32BIT_INDEX ) { System . gc ( ) ; this . ptr = Utilities . UNSAFE . allocateMemory ( this . size * this . sizeof ) ; if ( zeroNativeMemory ) { zeroNativeMemory ( this . size ) ; } Cleaner . create ( this , new Deallocator ( this . ptr , this . size , this . sizeof ) ) ; MemoryCounter . increaseCounter ( this . size * this . sizeof ) ; stringLengths = new ShortLargeArray ( length ) ; byteArray = new byte [ maxStringLength * CHARSET_SIZE ] ; } else { data = new String [ ( int ) length ] ; } }
tr	8	@ Override public Vector3f [ ] getAllMinAlongDirection ( Vector3f [ ] result , Vector3f dir , int count , float eps ) { if ( count > 0 ) { eps /= dir . length ( ) ; float dotmindir = vertices [ 0 ] . . ( dir ) ; result [ 0 ] . set ( vertices [ 0 ] ) ; int j = 1 ; for ( int i = vertices . length - 1 ; i > 0 ; i -- ) { final float dotshapedir = vertices [ i ] . . ( dir ) ; if ( dotshapedir <= dotmindir ) { if ( dotshapedir <= dotmindir - eps ) { result [ 0 ] . set ( vertices [ i ] ) ; j = 1 ; } else if ( j < count ) { result [ j ] . set ( vertices [ i ] ) ; j ++ ; } dotmindir = dotshapedir ; } else if ( j < count && dotshapedir - eps <= dotmindir ) { result [ j ] . set ( vertices [ i ] ) ; j ++ ; } } for ( ; j < count ; j ++ ) { result [ j ] . set ( 0 , 0 , 0 ) ; } } return result ; }
tr	0	public InternManImpl ( UserStore userStore ) { this . users = new UserManagementImpl ( ) ; this . adverts = new AdvertManagementImpl ( ) ; }
tr	3	public int gewtPrinter ( ) { int ret = - 1 ; try { this . lockPrinters . lock ( ) ; for ( int i = 0 ; i < this . freePrinters . length ; i ++ ) { if ( this . freePrinters [ i ] ) { ret = i ; this . freePrinters [ i ] = false ; break ; } } } catch ( Exception exc ) { exc . printStackTrace ( ) ; } finally { this . lockPrinters . unlock ( ) ; } return ret ; }
tr	1	public void makeEven ( ) { if ( population . size ( ) % 2 == 1 ) { population . remove ( 0 ) ; } }
tr	4	public String getToolTip ( int rowIndex ) { Object obj = model . getDataVector ( ) . get ( rowIndex ) . getClass ( ) ; if ( obj == Dye . class ) { return "Process/direkt" ; } if ( obj == Lakk . class ) { return "Lakk" ; } if ( obj == Metal . class ) { return "Met\u00E1l" ; } if ( obj == Fluo . class ) { return "Fluo" ; } return "???" ; }
tr	0	public Position ( ) { }
tr	9	private void planForAgent ( Agent agent ) { TaskDispenser td = agent . td ; Node node = agent . node ; if ( agent . request != null ) { if ( agent . request . requestBox . atField == agent . request . requestGoal ) { agent . request = null ; } } if ( agent . taskQueue != null && agent . taskQueue . size ( ) > 0 && ( agent . taskQueue . peek ( ) . commandQueue == null || agent . taskQueue . peek ( ) . commandQueue . size ( ) == 0 ) ) { if ( agent . taskQueue . peek ( ) instanceof DockTask ) { DockTask t = ( DockTask ) agent . taskQueue . peek ( ) ; t . box . reserved = false ; t . moveBoxTo . reserved = false ; } agent . taskQueue . poll ( ) ; } if ( agent . taskQueue . size ( ) == 0 ) { agent . taskQueue . clear ( ) ; if ( agent . td . agents . size ( ) == 1 ) { agent . taskQueue . addAll ( td . newDispenseTaskForAgent ( agent ) ) ; } else { agent . taskQueue . addAll ( td . simpleDispenseTaskForAgent ( agent ) ) ; } } }
tr	8	public String login ( User user , Map < String , Object > session ) throws ServiceException { String email = user . getEmail ( ) + SysConfig . getConfig ( SysConfig . EMAIL_SUFFIX ) ; String password = user . getUserPWD ( ) ; String relPwd = MD5 . getMD5 ( email + password ) ; User u = new User ( ) ; u . setEmail ( email ) ; u . setUserPWD ( password ) ; u . setUserState ( OtherConstants . STATE_YES ) ; User fu = this . findUserByEmail ( u ) ; if ( fu == null ) { logger . info ( "Email is not exist !" ) ; return OtherConstants . EMAIL_NOT_EXIST ; } if ( ! fu . getUserPWD ( ) . equals ( relPwd ) ) { logger . info ( "Password is error !" ) ; return OtherConstants . PASSWORD_ERROR ; } String userID = fu . getId ( ) ; try { @ SuppressWarnings ( "rawtypes" ) List list = groupDaoImpl . query ( fu , SqlConstants . GROUP_QUERY_BY_UID ) ; List < Group > groups = new ArrayList < Group > ( ) ; int temp = 0 ; for ( Object object : list ) { Group group = ( Group ) object ; int groupID = Integer . parseInt ( group . getId ( ) ) ; if ( groupID > 0 ) { temp = groupID ; } groups . add ( group ) ; } fu . setGroups ( groups ) ; fu . setAuth ( String . valueOf ( temp ) ) ; } catch ( DBException e ) { logger . error ( OtherConstants . DB_ERROR , e ) ; return OtherConstants . DB_ERROR ; } Money money = new Money ( ) ; money . setUserID ( userID ) ; try { @ SuppressWarnings ( "rawtypes" ) List list = moneyDaoImpl . query ( money , SqlConstants . MONEY_FIND_BY_UID ) ; if ( list != null && list . size ( ) > 0 ) { money = ( Money ) list . get ( 0 ) ; fu . setMoneyValue ( money . getMoneyValue ( ) ) ; } else { fu . setMoneyValue ( 0 ) ; } } catch ( DBException e ) { logger . error ( OtherConstants . DB_ERROR , e ) ; return OtherConstants . DB_ERROR ; } session . put ( OtherConstants . CURRENT_USER , fu ) ; return null ; }
tr	2	public static void onAllROute ( Individual individual ) { ProblemInstance problemInstance = individual . problemInstance ; for ( int period = 0 ; period < problemInstance . periodCount ; period ++ ) { for ( int vehicle = 0 ; vehicle < problemInstance . vehicleCount ; vehicle ++ ) { mutateRouteBy2_Opt ( individual , period , vehicle ) ; } } }
tr	2	public static long copy ( InputStream input , OutputStream output , Action1 < long > progressCallback ) throws IOException { byte [ ] buffer = new byte [ BUFFER_SIZE ] ; long count = 0 ; int n ; while ( ( n = input . read ( buffer ) ) != - 1 ) { output . write ( buffer , 0 , n ) ; count += n ; if ( progressCallback != null ) progressCallback . call ( count ) ; } return count ; }
tr	0	public MultiList ( ) { recommendedModel = new DefaultListModel < Champion > ( ) ; goodModel = new DefaultListModel < Champion > ( ) ; viableModel = new DefaultListModel < Champion > ( ) ; allModel = new DefaultListModel < Champion > ( ) ; instance = this ; submit ( ) ; EventHandler . addSlotLockListener ( new SlotLockListener ( ) { @ Override public void onSlotLock ( ) { submit ( ) ; } } ) ; EventHandler . addResetListener ( new ResetListener ( ) { @ Override public void onReset ( ) { reset ( ) ; submit ( ) ; } } ) ; }
tr	7	private void initialize ( int maxValue ) { try { for ( int x = 1 ; x <= maxValue ; x ++ ) { for ( int y = 1 ; y <= maxValue ; y ++ ) { Point p = new Point ( x , y ) ; Cell cell = new Cell ( maxValue , p ) ; getCells ( ) . put ( p , cell ) ; } } for ( int x = 1 ; x <= maxValue ; x ++ ) { Unit row = new Unit ( maxValue , String . format ( "Row %d" , x ) ) ; rows . add ( row ) ; for ( int y = 1 ; y <= maxValue ; y ++ ) { Point p = new Point ( x , y ) ; Cell cell = getCells ( ) . get ( p ) ; row . addCell ( cell ) ; } } for ( int y = 1 ; y <= maxValue ; y ++ ) { Unit column = new Unit ( maxValue , String . format ( "Column %d" , y ) ) ; columns . add ( column ) ; for ( int x = 1 ; x <= maxValue ; x ++ ) { Point p = new Point ( x , y ) ; Cell cell = getCells ( ) . get ( p ) ; column . addCell ( cell ) ; } } } catch ( AddCellException e ) { System . err . println ( "Should never happen:" + e ) ; } }
tr	3	@ Override public boolean checaTipo ( AmbienteCompilacao amb ) throws VariavelNaoDeclaradaException , VariavelJaDeclaradaException { return ( expressaoEsquerda . getTipo ( amb ) . isInteger ( ) || expressaoEsquerda . getTipo ( amb ) . isParametro ( ) ) && ( expressaoDireita . getTipo ( amb ) . isInteger ( ) || expressaoDireita . getTipo ( amb ) . isParametro ( ) ) ; }
tr	9	private static void initializeFreeSpaceMgnt ( ) { try { int noOfBlocksBitmap = 4 ; Block superBlock = new Block ( homeDir . toString ( ) + "/TransDisk/" + String . format ( "%05d" , Disk . superBlockAddress ) + ".txt" , "r" ) ; superBlock . readLine ( ) ; int [ ] freeBlockBitmapNo = new int [ noOfBlocksBitmap ] ; String tempStr = superBlock . readLine ( ) ; for ( int i = 0 ; i < noOfBlocksBitmap ; i ++ ) freeBlockBitmapNo [ i ] = Integer . parseInt ( tempStr . substring ( i , i + 1 ) ) ; byte [ ] [ ] freeSpaceBitmapContent = new byte [ 4 ] [ ] ; for ( int i = 0 ; i < 4 ; i ++ ) freeSpaceBitmapContent [ i ] = new byte [ Disk . maxBlockSize ] ; int i = 0 ; for ( int k = 0 ; k < 4 ; k ++ ) { for ( int j = i % Disk . maxBlockSize ; j < Disk . maxBlockSize ; j ++ , i ++ ) { if ( i <= Disk . inodeEndBlock ) freeSpaceBitmapContent [ k ] [ j ] = 49 ; else freeSpaceBitmapContent [ k ] [ j ] = 48 ; } } for ( i = 0 ; i < 4 ; i ++ ) { Block bitmapBlock = new Block ( homeDir . toString ( ) + "/TransDisk/" + String . format ( "%05d" , freeBlockBitmapNo [ i ] ) + ".txt" , "rw" ) ; bitmapBlock . write ( freeSpaceBitmapContent [ i ] ) ; bitmapBlock . close ( ) ; } System . out . println ( superBlock . getFilePointer ( ) ) ; int freeInodeBitmapNo = superBlock . read ( ) - 48 ; System . out . println ( superBlock . getFilePointer ( ) ) ; byte freeInodeContent [ ] = new byte [ ( Disk . inodeEndBlock - Disk . inodeStartBlock + 1 ) * 4 ] ; freeInodeContent [ 0 ] = freeInodeContent [ 1 ] = freeInodeContent [ 2 ] = 49 ; for ( i = 3 ; i < ( Disk . inodeEndBlock - Disk . inodeStartBlock + 1 ) * 4 ; i ++ ) { freeInodeContent [ i ] = 48 ; } Block freeInodeBitmapBlk = new Block ( homeDir . toString ( ) + "/TransDisk/" + String . format ( "%05d" , freeInodeBitmapNo ) + ".txt" , "rw" ) ; freeInodeBitmapBlk . write ( freeInodeContent ) ; freeInodeBitmapBlk . close ( ) ; superBlock . close ( ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }
tr	9	public void fillVarVector ( NodeList nl , Vector v ) { for ( int i = 0 ; i < nl . getLength ( ) ; ++ i ) { Element e = ( Element ) nl . item ( i ) ; String nm = e . getNodeName ( ) ; if ( nm . equals ( "Textbox" ) || nm . equals ( "ListBox" ) || nm . equals ( "Href" ) || nm . equals ( "Hidden" ) || nm . equals ( "RadioButton" ) || nm . equals ( "PasswordField" ) || nm . equals ( "FileUpload" ) || nm . equals ( "TextArea" ) || nm . equals ( "CheckBox" ) || nm . equals ( "ComboBox" ) ) { v . add ( "{" + e . getAttribute ( "Name" ) + "}" ) ; } if ( ! e . getTagName ( ) . equals ( "Connection" ) ) fillVarVector ( e . getChildNodes ( ) , v ) ; } }
tr	2	private int findMove ( int index1 , int index2 ) { int index = - 1 ; for ( int i = 0 ; i < _steps [ index1 ] [ index2 ] . theColors . length ; i ++ ) { if ( _steps [ index1 ] [ index2 ] . theColors [ i ] == Colors . BAR_SHIFT ) { index = i ; break ; } } return index ; }
tr	8	private static boolean eachFileInDir ( File path , F2 < File , String , boolean > f , ArrayList < String > relPath , F1 < File , boolean > exclude ) { if ( ! path . exists ( ) || ! path . isDirectory ( ) ) { throw new RuntimeException ( "Invalid path: " + path ) ; } for ( File child : path . listFiles ( ) ) { if ( exclude != null && exclude . e ( child ) ) { continue ; } if ( child . isFile ( ) ) { if ( ! f . e ( child , Cols . join ( relPath , File . separator ) ) ) return false ; } else { relPath . add ( child . getName ( ) ) ; if ( ! eachFileInDir ( child , f , relPath , exclude ) ) return false ; relPath . remove ( relPath . size ( ) - 1 ) ; } } return true ; }
tr	1	public synchronized void aggiorna ( ) { Iterator < Giocatore > itGiocatori = this . iterator ( ) ; while ( itGiocatori . hasNext ( ) ) { itGiocatori . next ( ) . aggiorna ( ) ; } }
tr	3	public void saveGame ( ) throws CannotSaveException { try { SaveFile saveFile = new SaveFile ( GameSaver . AUTO_SAVE_LOCATION ) ; FileOutputStream saveStream = new FileOutputStream ( saveFile . getFile ( ) ) ; ObjectOutputStream save = new ObjectOutputStream ( saveStream ) ; save . writeObject ( GameState . getInstance ( ) ) ; save . close ( ) ; } catch ( CannotCreateFileException e ) { throw new CannotSaveException ( "Cannot create file" ) ; } catch ( FileNotFoundException e ) { throw new CannotSaveException ( "File not found" ) ; } catch ( IOException e ) { throw new CannotSaveException ( "IO Exception" ) ; } }
tr	5	BufferedImage getRetroChar ( final char c , final Color color ) { int code = ( int ) c ; if ( code < 0 || c > 255 ) { code = ( int ) ? ; } final int row = code >> 4 ; final int col = code % 16 ; final BufferedImage subimg = font . getSubimage ( col << 3 , row << 3 , 8 , 8 ) ; final BufferedImage result = new BufferedImage ( subimg . getWidth ( ) , subimg . getHeight ( ) , subimg . getType ( ) ) ; subimg . copyData ( result . getRaster ( ) ) ; for ( int x = 0 ; x < result . getWidth ( ) ; ++ x ) { for ( int y = 0 ; y < result . getHeight ( ) ; ++ y ) { if ( result . getRGB ( x , y ) == FFFFFFFF ) { result . setRGB ( x , y , color . getRGB ( ) ) ; } } } return result ; }
tr	5	private ArrayList < Creature > getPossibleTargets ( ) { ArrayList < Creature > possibleTargets = new ArrayList < Creature > ( ) ; TileMap map = ( ( Ship ) parent ) . getParent ( ) . parent . getMap ( ) ; LinkedList sprites = map . getSprites ( ) ; for ( int i = 0 ; i < sprites . size ( ) ; i ++ ) { if ( distanceBetween ( ( Creature ) sprites . get ( i ) , this . parent ) < areaOfInterest ) { possibleTargets . add ( ( Creature ) sprites . get ( i ) ) ; } } ArrayList < Ship > aiShips = map . getAIShips ( ) ; for ( int i = 0 ; i < aiShips . size ( ) ; i ++ ) { if ( aiShips . get ( i ) != this . parent && distanceBetween ( aiShips . get ( i ) , this . parent ) < areaOfInterest ) { possibleTargets . add ( aiShips . get ( i ) ) ; } } return possibleTargets ; }
tr	3	@ Override public HandshakeState acceptHandshakeAsClient ( ClientHandshake request , ServerHandshake response ) throws InvalidHandshakeException { if ( ! request . hasFieldValue ( "Sec-WebSocket-Key" ) || ! response . hasFieldValue ( "Sec-WebSocket-Accept" ) ) return HandshakeState . NOT_MATCHED ; String seckey_answere = response . getFieldValue ( "Sec-WebSocket-Accept" ) ; String seckey_challenge = request . getFieldValue ( "Sec-WebSocket-Key" ) ; seckey_challenge = generateFinalKey ( seckey_challenge ) ; if ( seckey_challenge . equals ( seckey_answere ) ) return HandshakeState . MATCHED ; return HandshakeState . NOT_MATCHED ; }
tr	1	@ Override protected void validateTree ( ) { if ( ! view . isProcessing ( name ) ) super . validateTree ( ) ; }
tr	0	public DefensaTerrestre ( JLabel panel , CampoMatriz [ ] [ ] matriz , ArrayList < Guerrero > ejercito , int vida , String mainImg , int alcance , int daño ) { super ( panel , matriz , ejercito , vida , mainImg , alcance , daño ) ; }
tr	8	protected boolean isExecutorInvocable ( FunctionExecutorContext < R > executor ) { try { Method invokeMethod = executor . getExecutor ( ) . getClass ( ) . getMethod ( "invoke" , FunctionInvocation . class , Object [ ] . class ) ; if ( executor . isLocked ( ) || source . isLocked ( ) && invokeMethod . isAnnotationPresent ( Lockable . class ) ) { return false ; } } catch ( NoSuchMethodException e ) { LOGGER . log ( Level . SEVERE , "Programmer's fault: Can't find invoke() method (should be defined by interface)" , e ) ; } if ( executor . getInvocations ( ) + 1 > ( Integer ) executor . getValue ( Limit . class , "value" ) ) { return false ; } int invocation = source . getInvocations ( ) - 1 ; int firstDelay = ( Integer ) executor . getValue ( Delay . class , "firstDelay" ) ; int delay = ( Integer ) executor . getValue ( Delay . class , "delay" ) ; if ( invocation < firstDelay ) { return false ; } else if ( delay > 0 && ( invocation - firstDelay ) % ( delay + 1 ) != 0 ) { return false ; } return true ; }
tr	3	@ Override public Object getAsObject ( FacesContext facesContext , UIComponent uicomp , String value ) { try { FacesContext context = FacesContext . getCurrentInstance ( ) ; VendaBean venda = ( VendaBean ) context . getELContext ( ) . getELResolver ( ) . getValue ( context . getELContext ( ) , null , "venda" ) ; for ( Produto c : venda . getProdutos ( ) ) if ( c . getDescricao ( ) . equals ( value ) ) return c ; return null ; } catch ( Exception ex ) { return null ; } }
tr	5	public void createGameObject ( int btnval ) { System . out . println ( "Create Game Object Button pressed" ) ; GrandView grand = findGrandView ( ) ; SavedEntityState state = grand . getSavedStates ( ) . getSelectedState ( ) ; if ( state != null ) { GameEntity entity = new GameEntity ( ) ; if ( entity . getState ( ) == null ) System . out . println ( "Major Error :: EntityState null :: ModifiersView" ) ; entity . getState ( ) . setReference ( state ) ; entity . getState ( ) . initializeFromReference ( ) ; GameEntityView gev = grand . getGameEntity ( ) ; gev . setCurrent ( entity ) ; System . out . println ( "GameEntityView redraw :: ModifiersView" ) ; gev . redrawView ( ) ; } else { System . out . println ( "Minor Error :: No Saved State Selected :: ModifiersView" ) ; } for ( int i = 0 ; i < getSubviews ( ) . size ( ) ; i ++ ) if ( getSubviews ( ) . get ( i ) instanceof Button ) { Button temp = ( Button ) getSubviews ( ) . get ( i ) ; if ( temp . getIndex ( ) == btnval ) temp . setSelected ( false ) ; } }
tr	2	private static boolean canPut ( Pos pos , List < Pos > queens ) { for ( Pos queen : queens ) { if ( ! canPut ( pos , queen ) ) { return false ; } } return true ; }
tr	8	public boolean equals ( Object other ) { if ( other instanceof Tuple ) { Tuple otherTuple = ( Tuple ) other ; return ( ( this . first == otherTuple . first || ( this . first != null && otherTuple . first != null && this . first . equals ( otherTuple . first ) ) ) && ( this . second == otherTuple . second || ( this . second != null && otherTuple . second != null && this . second . equals ( otherTuple . second ) ) ) ) ; } return false ; }
tr	6	private void watchCandidate ( LeaderOffer previousOffer ) throws KeeperException , InterruptedException { LOG . info ( "{} not elected leader. Watching node {}" , leaderOffer , previousOffer ) ; Stat stat = zooKeeper . exists ( previousOffer . getOffer ( ) , new Watcher ( ) { public void process ( WatchedEvent event ) { if ( event . getType ( ) . equals ( Watcher . Event . EventType . NodeDeleted ) ) { if ( ! event . getPath ( ) . equals ( LeaderElectionService . this . leaderOffer . getOffer ( ) ) ) { LOG . debug ( "Node {} deleted. Need to run through the election process." , event . getPath ( ) ) ; try { determine ( ) ; } catch ( KeeperException e ) { failed ( e ) ; } catch ( InterruptedException e ) { failed ( e ) ; } } } } } ) ; if ( stat != null ) { LOG . info ( "Becoming follower with node {}  We're watching {}" , leaderOffer , previousOffer ) ; if ( leaderElectionAware != null ) { leaderElectionAware . onFollower ( leaderOffer ) ; } } else { LOG . debug ( "We were behind {} but it looks like died. Back to determination." , previousOffer ) ; determine ( ) ; } }
tr	2	private static boolean checkRow ( int [ ] [ ] grid , int whichRow ) { final int size = grid . length ; boolean [ ] found = new boolean [ size ] ; for ( int col = 0 ; col < size ; ++ col ) { int index = grid [ whichRow ] [ col ] - 1 ; if ( ! found [ index ] ) { found [ index ] = true ; } else { return false ; } } return true ; }
tr	9	@ Override public void calculateFitness ( List < Individual > population ) throws Exception { int warpoints = 0 ; for ( Individual fighter : population ) { BlottoPhenotype fighterPheno = ( BlottoPhenotype ) fighter . phenotype ( ) ; fighter . setFitness ( 0.0 ) ; for ( Individual opponent : population ) { if ( ! fighter . equals ( opponent ) && ! fighterPheno . fought . contains ( opponent ) ) { BlottoPhenotype opponentPheno = ( BlottoPhenotype ) opponent . phenotype ( ) ; int fighterWins = 0 ; int opponentWins = 0 ; double [ ] fighterWeights = new double [ numBattles ] ; System . arraycopy ( fighterPheno . pheno , 0 , fighterWeights , 0 , numBattles ) ; double [ ] opponentWeights = new double [ numBattles ] ; System . arraycopy ( opponentPheno . pheno , 0 , opponentWeights , 0 , numBattles ) ; for ( int battle = 0 ; battle < numBattles ; battle ++ ) { if ( fighterWeights [ battle ] > opponentWeights [ battle ] ) { fighterWins += 1 ; double redistribution = fighterWeights [ battle ] - opponentWeights [ battle ] ; int remainingBattles = numBattles - ( battle + 1 ) ; redistribution = redistribution / remainingBattles ; for ( int i = battle + 1 ; i < numBattles ; i ++ ) { fighterWeights [ i ] += redeploymentRate * redistribution ; opponentWeights [ i ] *= 1 - defectionRate ; } } else if ( fighterWeights [ battle ] > opponentWeights [ battle ] ) { opponentWins += 1 ; double redistribution = opponentWeights [ battle ] - fighterWeights [ battle ] ; int remainingBattles = numBattles - ( battle + 1 ) ; redistribution = redistribution / remainingBattles ; for ( int i = battle + 1 ; i < numBattles ; i ++ ) { opponentWeights [ i ] += redeploymentRate * redistribution ; fighterWeights [ i ] *= 1 - defectionRate ; } } } if ( fighterWins == opponentWins ) { fighterPheno . score ++ ; opponentPheno . score ++ ; } else if ( fighterWins > opponentWins ) { fighterPheno . score += 2 ; } else if ( fighterWins < opponentWins ) { opponentPheno . score += 2 ; } warpoints += 2 ; fighterPheno . fought . add ( opponent ) ; opponentPheno . fought . add ( fighter ) ; } } } int topScore = 0 ; for ( Individual individual : population ) { BlottoPhenotype ph = ( BlottoPhenotype ) individual . phenotype ( ) ; if ( ph . score > topScore ) topScore = ph . score ; } for ( Individual individual : population ) { BlottoPhenotype ph = ( BlottoPhenotype ) individual . phenotype ( ) ; individual . setFitness ( ( double ) ph . score / ( double ) topScore ) ; ph . fought = null ; } }
tr	8	@ Override public String intercept ( ActionInvocation invocation ) throws Exception { ActionContext actionContext = invocation . getInvocationContext ( ) ; HttpServletRequest request = ( HttpServletRequest ) actionContext . get ( StrutsStatics . HTTP_REQUEST ) ; System . out . println ( "interceptor is invoked" ) ; Map session = actionContext . getSession ( ) ; if ( session != null && session . get ( USER_SESSION_KEY ) != null ) { return invocation . invoke ( ) ; } Cookie [ ] cookies = request . getCookies ( ) ; if ( cookies != null ) { for ( Cookie cookie : cookies ) { if ( COOKIE_REMEMBERME_KEY . equals ( cookie . getName ( ) ) ) { String value = cookie . getValue ( ) ; if ( StringUtils . isNotBlank ( value ) ) { String [ ] split = value . split ( "==" ) ; String userName = split [ 0 ] ; String password = split [ 1 ] ; try { User user = userDao . attemptLogin ( userName , password ) ; if ( user != null ) { session . put ( USER_SESSION_KEY , user ) ; } } catch ( Exception e ) { setGoingToURL ( session , invocation ) ; return "login" ; } } else { setGoingToURL ( session , invocation ) ; return "login" ; } return invocation . invoke ( ) ; } } } setGoingToURL ( session , invocation ) ; System . out . println ( session . get ( GOING_TO_URL_KEY ) ) ; return "login" ; }
tr	0	private OrderManager ( ) { }
tr	5	private void generateElemXMLFile ( Document doc , Element elem ) { Element elements = doc . createElement ( "Elements" ) ; elem . appendChild ( elements ) ; ArrayList < Edge > edges = modelo . getEdges ( ) ; for ( Edge e : edges ) { Element element = doc . createElement ( "Element" ) ; elements . appendChild ( element ) ; Attr attr = doc . createAttribute ( "id" ) ; attr . setValue ( e . getNumber ( ) + "" ) ; element . setAttributeNode ( attr ) ; Element nodes = doc . createElement ( "Nodes" ) ; element . appendChild ( nodes ) ; Element node1 = doc . createElement ( "Node1" ) ; node1 . appendChild ( doc . createTextNode ( e . getNode1 ( ) . getNumber ( ) + "" ) ) ; nodes . appendChild ( node1 ) ; Element node2 = doc . createElement ( "Node2" ) ; node2 . appendChild ( doc . createTextNode ( e . getNode2 ( ) . getNumber ( ) + "" ) ) ; nodes . appendChild ( node2 ) ; if ( e . getPressureValue ( ) != 0 ) { int i = 0 ; String [ ] axis = { "X" , "Y" , "Z" } ; Element pressure = doc . createElement ( "Pressure" ) ; element . appendChild ( pressure ) ; Element value = doc . createElement ( "Value" ) ; value . appendChild ( doc . createTextNode ( e . getPressureValue ( ) + "" ) ) ; element . appendChild ( value ) ; for ( int vec : e . getPressureUnitVector ( ) ) { Element unit = doc . createElement ( axis [ i ] ) ; unit . appendChild ( doc . createTextNode ( vec + "" ) ) ; pressure . appendChild ( unit ) ; i ++ ; } } if ( e . getFlowVelocity ( ) != 0 ) { int i = 0 ; String [ ] axis = { "X" , "Y" , "Z" } ; Element fluid = doc . createElement ( "Fluid" ) ; element . appendChild ( fluid ) ; Element flow = doc . createElement ( "Velocity" ) ; flow . appendChild ( doc . createTextNode ( e . getFlowVelocity ( ) + "" ) ) ; element . appendChild ( flow ) ; Element density = doc . createElement ( "Density" ) ; density . appendChild ( doc . createTextNode ( e . getFluidDensity ( ) + "" ) ) ; element . appendChild ( density ) ; for ( int vec : e . getPressureUnitVector ( ) ) { Element unit = doc . createElement ( axis [ i ] ) ; unit . appendChild ( doc . createTextNode ( vec + "" ) ) ; fluid . appendChild ( unit ) ; i ++ ; } } } }
tr	2	public void open ( ) { display = Display . getDefault ( ) ; createContents ( ) ; Alogin . open ( ) ; Alogin . layout ( ) ; while ( ! Alogin . isDisposed ( ) ) { if ( ! display . readAndDispatch ( ) ) { display . sleep ( ) ; } } }
tr	6	public boolean matches ( ArrayList < Critere > criteres , ArrayList < MotClef > mots ) { ArrayList < Critere > criteresDocument = new ArrayList < Critere > ( ) ; for ( Note n : notes ) { if ( ! criteresDocument . contains ( n . getCritere ( ) ) ) { criteresDocument . add ( n . getCritere ( ) ) ; } } for ( Critere c : criteres ) { if ( ! criteresDocument . contains ( c ) ) { return false ; } } for ( MotClef m : mots ) { if ( ! motClefs . contains ( m ) ) { return false ; } } return true ; }
tr	6	@ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( ! ( o instanceof Song ) ) return false ; Song song = ( Song ) o ; if ( ! artistId . equals ( song . artistId ) ) return false ; if ( ! id . equals ( song . id ) ) return false ; if ( ! lyrics . equals ( song . lyrics ) ) return false ; if ( ! title . equals ( song . title ) ) return false ; return true ; }
tr	6	public static Set < class > getClassesInPackage ( String packageName ) { Set < class > classes = new HashSet < class > ( ) ; String packageNameSlashed = "/" + packageName . replace ( "." , "/" ) ; URL directoryURL = Thread . currentThread ( ) . getContextClassLoader ( ) . getResource ( packageNameSlashed ) ; if ( directoryURL == null ) { return classes ; } String directoryString = directoryURL . getFile ( ) ; if ( directoryString == null ) { return classes ; } File directory = new File ( directoryString ) ; if ( directory . exists ( ) ) { String [ ] files = directory . list ( ) ; for ( String fileName : files ) { if ( fileName . endsWith ( ".class" ) ) { fileName = fileName . substring ( 0 , fileName . length ( ) - 6 ) ; try { classes . add ( Reflector . classForName ( packageName + "." + fileName ) ) ; } catch ( ClassNotFoundException e ) { } } } } else { } return classes ; }
tr	0	public int getDdd ( ) { return ddd ; }
tr	5	@ Override public void sort ( ) { int min = provider . getMinIndex ( ) ; int max = provider . getMaxIndex ( ) ; boolean q = useQuick ( min , max ) ; if ( q == null ) { if ( Main . debug ) { System . out . println ( "choice: already sorted." ) ; } return ; } if ( q . booleanValue ( ) ) { if ( Main . debug ) { System . out . println ( "choice: use quick." ) ; } inplaceSortImpl = new DualPivotQuickSort ( provider ) ; } else { if ( Main . debug ) { System . out . println ( "choice: use heap." ) ; } inplaceSortImpl = new HeapSort ( provider ) ; } inplaceSortImpl . sort ( ) ; }
tr	0	public static void resetTestVars ( ) { calledMakePixel = false ; makePixelR = - 1 ; makePixelG = - 1 ; makePixelB = - 1 ; }
tr	4	@ SuppressWarnings ( "resource" ) @ Test public void testUpdateOverflow ( ) throws IOException { storageManager = new StorageManager ( testDir , 1024 * 1024 , 2 , storageMode , size ) ; assertTrue ( 2 == storageManager . getTotalBlockCount ( ) ) ; assertTrue ( 1 == storageManager . getFreeBlockCount ( ) ) ; assertTrue ( 1 == storageManager . getUsedBlockCount ( ) ) ; assertTrue ( 1024 * 1024 * 2 == storageManager . getCapacity ( ) ) ; assertTrue ( 0 == storageManager . getDirty ( ) ) ; assertTrue ( storageManager . getDirtyRatio ( ) <= 1e-6 ) ; byte [ ] sourceBytes = new byte [ 1024 ] ; IStorageBlock previousBlock = null ; Pointer pointer = null ; for ( int i = 0 ; i < 1024 ; i ++ ) { pointer = storageManager . store ( sourceBytes ) ; assertNotNull ( pointer ) ; if ( previousBlock == null ) previousBlock = pointer . getStorageBlock ( ) ; else { assertTrue ( pointer . getStorageBlock ( ) == previousBlock ) ; previousBlock = pointer . getStorageBlock ( ) ; } } assertTrue ( 1024 * 1024 == storageManager . getUsed ( ) ) ; pointer = storageManager . update ( pointer , new byte [ 512 ] ) ; assertTrue ( previousBlock == pointer . getStorageBlock ( ) ) ; assertTrue ( 1023 * 1024 + 512 == storageManager . getUsed ( ) ) ; pointer = storageManager . update ( pointer , new byte [ 1024 ] ) ; assertTrue ( previousBlock != pointer . getStorageBlock ( ) ) ; previousBlock = pointer . getStorageBlock ( ) ; assertTrue ( 2 == storageManager . getTotalBlockCount ( ) ) ; assertTrue ( 0 == storageManager . getFreeBlockCount ( ) ) ; assertTrue ( 2 == storageManager . getUsedBlockCount ( ) ) ; assertTrue ( 1024 * 1024 * 2 == storageManager . getCapacity ( ) ) ; assertTrue ( 1024 == storageManager . getDirty ( ) ) ; double expectedRatio = 1024 * 1.0 / storageManager . getCapacity ( ) ; assertTrue ( Math . abs ( expectedRatio - storageManager . getDirtyRatio ( ) ) <= 1e-6 ) ; assertTrue ( 1024 * 1024 == storageManager . getUsed ( ) ) ; for ( int i = 1 ; i < 1024 ; i ++ ) { pointer = storageManager . store ( sourceBytes ) ; assertNotNull ( pointer ) ; if ( previousBlock == null ) previousBlock = pointer . getStorageBlock ( ) ; else { assertTrue ( pointer . getStorageBlock ( ) == previousBlock ) ; previousBlock = pointer . getStorageBlock ( ) ; } } assertTrue ( 2047 * 1024 == storageManager . getUsed ( ) ) ; pointer = storageManager . update ( pointer , new byte [ 512 ] ) ; assertTrue ( previousBlock == pointer . getStorageBlock ( ) ) ; assertTrue ( 2047 * 1024 - 512 == storageManager . getUsed ( ) ) ; pointer = storageManager . update ( pointer , new byte [ 1024 ] ) ; assertTrue ( previousBlock != pointer . getStorageBlock ( ) ) ; previousBlock = pointer . getStorageBlock ( ) ; assertTrue ( 2047 * 1024 == storageManager . getUsed ( ) ) ; assertTrue ( 3 == storageManager . getTotalBlockCount ( ) ) ; assertTrue ( 0 == storageManager . getFreeBlockCount ( ) ) ; assertTrue ( 3 == storageManager . getUsedBlockCount ( ) ) ; assertTrue ( 1024 * 1024 * 3 == storageManager . getCapacity ( ) ) ; assertTrue ( 1024 * 2 == storageManager . getDirty ( ) ) ; expectedRatio = 1024 * 1.0 * 2 / storageManager . getCapacity ( ) ; assertTrue ( Math . abs ( expectedRatio - storageManager . getDirtyRatio ( ) ) <= 1e-6 ) ; }
tr	0	@ Override public String toString ( ) { String dato = this . codigo + "-" + cliente + "-" + saldo + " lps en saldo." ; return dato ; }
tr	0	public Object accept ( ASTVisitor visitor ) throws DatabaseException { return visitor . visit ( this ) ; }
tr	6	public ChannelBuffer getChunk ( int length ) throws IOException { if ( file == null || length == 0 ) { return ChannelBuffers . EMPTY_BUFFER ; } if ( fileChannel == null ) { FileInputStream inputStream = new FileInputStream ( file ) ; fileChannel = inputStream . getChannel ( ) ; } int read = 0 ; ByteBuffer byteBuffer = ByteBuffer . allocate ( length ) ; while ( read < length ) { int readnow = fileChannel . read ( byteBuffer ) ; if ( readnow == - 1 ) { fileChannel . close ( ) ; fileChannel = null ; break ; } else { read += readnow ; } } if ( read == 0 ) { return ChannelBuffers . EMPTY_BUFFER ; } byteBuffer . flip ( ) ; ChannelBuffer buffer = ChannelBuffers . wrappedBuffer ( byteBuffer ) ; buffer . readerIndex ( 0 ) ; buffer . writerIndex ( read ) ; return buffer ; }
tr	4	private ProgramMenuBar findMenuBar ( ) { for ( Component comp = console ; comp != null ; comp = comp . getParent ( ) ) { if ( comp instanceof Program ) { return ( ( Program ) comp ) . getMenuBar ( ) ; } else if ( comp instanceof JFrame ) { Object mbar = ( ( JFrame ) comp ) . getJMenuBar ( ) ; return ( mbar instanceof ProgramMenuBar ) ? ( ProgramMenuBar ) mbar : null ; } } return null ; }
tr	4	void deleteTime ( Component dialogParent , Time time ) { if ( time != null ) { if ( AlertMessages . deleteTimeConfirmation ( dialogParent , time ) ) { try { timeDao . deleteTime ( Dao . getConnection ( ) , time ) ; timeDialog . setTime ( null ) ; timeListDialog . selectPreviousRow ( ) ; timeDialog . setVisible ( false ) ; } catch ( SQLException ex ) { ErrorMessages . sqlExceptionError ( "deleteTime()" , ex ) ; } catch ( ClassNotFoundException ex ) { ErrorMessages . classNotFoundError ( "deleteTime()" , ex ) ; } } } else { AlertMessages . noTimeSelectedInTableForDeleting ( timeListDialog ) ; } }
tr	2	public double getArea ( ) { final Punto ptInt = this . getPuntoInterior ( ) ; double area = 0 ; for ( int i = 0 ; i < this . numVertices ; i ++ ) { final Punto ptSig = ( i == this . numVertices - 1 ) ? this . vertices [ 0 ] : this . vertices [ i + 1 ] ; area += Poligono . getAreaTriangulo ( this . vertices [ i ] , ptSig , ptInt ) ; } return Math . round ( area * 1000 ) / 1000.0 ; }
tr	3	public String stripZeros ( String s ) { int i ; for ( i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) != 0 ) break ; } if ( i == s . length ( ) ) return "0" ; else return s . substring ( i ) ; }
tr	7	private String GetWordsTwentyAndAbove ( int number ) { if ( number % 10 == 0 && number < 100 ) return GetDoubleDigitWord ( number ) ; if ( number < 100 ) return GetDoubleDigitWord ( number - ( number % 10 ) ) + GetWordOneThroughTwenty ( number % 10 ) ; if ( number < 1000 ) { String currentNumber = GetTripleDigitWord ( number - ( number % 100 ) ) ; if ( number % 100 != 0 ) currentNumber = currentNumber + "and" ; if ( ( number % 100 ) < 20 ) currentNumber = currentNumber + GetWordOneThroughTwenty ( number % 100 ) ; else currentNumber = currentNumber + GetDoubleDigitWord ( ( number % 100 ) - ( number % 10 ) ) + GetWordOneThroughTwenty ( number % 10 ) ; return currentNumber ; } if ( number == 1000 ) { return "onethousand" ; } return "" ; }
tr	0	public GUIButton ( String name ) { super ( name ) ; setInput ( true ) ; }
tr	5	public static JSONArray toJSONArray ( JSONArray names , JSONTokener x ) throws JSONException { if ( names == null || names . length ( ) == 0 ) { return null ; } JSONArray ja = new JSONArray ( ) ; for ( ; ; ) { JSONObject jo = rowToJSONObject ( names , x ) ; if ( jo == null ) { break ; } ja . put ( jo ) ; } if ( ja . length ( ) == 0 ) { return null ; } return ja ; }
tr	6	public MySmartCarTester ( ) throws Exception { super ( inputCount , outputCount , new IMyNeuronFunction < double > ( ) { @ Override public double process ( List < double > inData , List < double > weights , double threshold ) throws Exception { if ( inData . size ( ) != weights . size ( ) ) { throw new Exception ( "inData size doesnt match weights size" ) ; } if ( threshold == null ) { throw new Exception ( "threshold cannot be null" ) ; } double total = 0 ; for ( int i = 0 ; i < inData . size ( ) ; i ++ ) { total += inData . get ( i ) * weights . get ( i ) ; } double answer = 1 / ( 1 + Math . exp ( ( - total ) / threshold ) ) ; return answer ; } } ) ; init ( new IMyFitnessTestFunction < double > ( ) { @ Override public int testFitness ( List < double > list ) { try { resetWeightsAndThresholds ( list ) ; List < double > in = Arrays . asList ( new double [ ] { ( double ) targetPoint . getX ( ) , ( double ) targetPoint . getY ( ) , ( double ) carStart . getX ( ) , ( double ) carStart . getY ( ) } ) ; double sumDataIn = in . stream ( ) . mapToDouble ( d -> d ) . sum ( ) ; List < double > output = getNetworkOutput ( in ) ; double sumDataOut = output . stream ( ) . mapToDouble ( d -> d ) . sum ( ) ; System . out . println ( "in:" + sumDataIn + " out" + sumDataOut ) ; MyPoint distance = targetPoint . subtract ( carStart ) ; MyPoint guessLineShort = new MyPoint ( output . get ( 0 ) . floatValue ( ) , output . get ( 1 ) . floatValue ( ) ) ; MyPoint guessLine = guessLineShort . scale ( ( float ) ( distance . getX ( ) / guessLineShort . getX ( ) ) ) ; line = new MyCollidableLine ( new MyDrawablePoint ( carStart . getX ( ) , carStart . getY ( ) ) , new MyDrawablePoint ( guessLine . getX ( ) , guessLine . getY ( ) ) ) ; line . setColor ( Color . black ) ; List < MyPoint > c = line . isColliding ( targetRect ) ; if ( c != null && ! c . isEmpty ( ) ) { return 100 ; } else { return 0 ; } } catch ( Exception ex ) { Logger . getLogger ( MySmartCarTester . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } return 0 ; } } , rf ) ; }
tr	8	public String ValidarCampo ( ComprobanteVenta BEEntidades ) { Result rs = new Result ( ) ; StringBuilder sb = new StringBuilder ( ) ; sb . append ( Common . IsMinorOrEqualsZero ( BEEntidades . getNumero ( ) ) ? "Numero inv\u00E1lido " : "" ) ; sb . append ( Common . IsNullOrEmpty ( BEEntidades . getEmpresa ( ) ) ? "Empresa inv\u00E1lido " : "" ) ; sb . append ( Common . IsMinorOrEqualsZero ( BEEntidades . getMoneda ( ) ) ? "Moneda inv\u00E1lido " : "" ) ; sb . append ( Common . IsNullOrEmpty ( BEEntidades . getFecha_emision ( ) ) ? "Fecha inv\u00E1lido " : "" ) ; sb . append ( Common . IsNullOrEmpty ( BEEntidades . getFecha_vencimiento ( ) ) ? "Fecha inv\u00E1lido " : "" ) ; sb . append ( Common . IsNullOrEmpty ( BEEntidades . getFecha_pago ( ) ) ? "Fecha inv\u00E1lido " : "" ) ; sb . append ( Common . IsNullOrEmpty ( BEEntidades . getObservaciones ( ) ) ? "Observacion inv\u00E1lido " : "" ) ; sb . append ( Common . IsNullOrEmpty ( BEEntidades . getEstado ( ) ) ? "Esado inv\u00E1lido " : "" ) ; rs . SetResult ( ResultType . Advertencia , "Error de campo" , sb . toString ( ) ) ; return rs . toString ( ) ; }
tr	4	private static TextureResource loadTexture ( String fileName ) { Logger . debug ( "TEXTURE: Starting to load texture from file " + fileName ) ; String [ ] splitArray = fileName . split ( "\\." ) ; String ext = splitArray [ splitArray . length - 1 ] ; try { BufferedImage image = ImageIO . read ( new File ( "res/textures/" + fileName ) ) ; int [ ] pixels = image . getRGB ( 0 , 0 , image . getWidth ( ) , image . getHeight ( ) , null , 0 , image . getWidth ( ) ) ; ByteBuffer buffer = Util . createByteBuffer ( image . getHeight ( ) * image . getWidth ( ) * 4 ) ; boolean hasAlpha = image . getColorModel ( ) . hasAlpha ( ) ; for ( int y = 0 ; y < image . getHeight ( ) ; y ++ ) { for ( int x = 0 ; x < image . getWidth ( ) ; x ++ ) { int pixel = pixels [ y * image . getWidth ( ) + x ] ; buffer . put ( ( byte ) ( ( pixel >> 16 ) & FF ) ) ; buffer . put ( ( byte ) ( ( pixel >> 8 ) & FF ) ) ; buffer . put ( ( byte ) ( ( pixel ) & FF ) ) ; if ( hasAlpha ) buffer . put ( ( byte ) ( ( pixel >> 24 ) & FF ) ) ; else buffer . put ( ( byte ) ( FF ) ) ; } } buffer . flip ( ) ; TextureResource resource = new TextureResource ( ) ; GL13 . glActiveTexture ( GL13 . GL_TEXTURE0 ) ; GL11 . glBindTexture ( GL11 . GL_TEXTURE_2D , resource . getId ( ) ) ; GL11 . glPixelStorei ( GL11 . GL_UNPACK_ALIGNMENT , 1 ) ; GL11 . glTexImage2D ( GL11 . GL_TEXTURE_2D , 0 , GL11 . GL_RGB , image . getWidth ( ) , image . getHeight ( ) , 0 , GL11 . GL_RGBA , GL11 . GL_UNSIGNED_BYTE , buffer ) ; GL30 . glGenerateMipmap ( GL11 . GL_TEXTURE_2D ) ; GL11 . glTexParameteri ( GL11 . GL_TEXTURE_2D , GL11 . GL_TEXTURE_WRAP_S , GL11 . GL_REPEAT ) ; GL11 . glTexParameteri ( GL11 . GL_TEXTURE_2D , GL11 . GL_TEXTURE_WRAP_T , GL11 . GL_REPEAT ) ; GL11 . glTexParameteri ( GL11 . GL_TEXTURE_2D , GL11 . GL_TEXTURE_MAG_FILTER , GL11 . GL_NEAREST ) ; GL11 . glTexParameteri ( GL11 . GL_TEXTURE_2D , GL11 . GL_TEXTURE_MIN_FILTER , GL11 . GL_LINEAR_MIPMAP_LINEAR ) ; Logger . debug ( "TEXTURE: Finished to load texture from file" ) ; return resource ; } catch ( Exception e ) { Logger . error ( e ) ; System . exit ( 1 ) ; } return null ; }
tr	7	@ Test public void testNavigateShowDescending ( ) { for ( int i = MockFileSystem . NUM_SEASONS ; i > 0 ; i -- ) { for ( int j = MockFileSystem . NUM_EPISODES ; j > 0 ; j -- ) { int season = ( j == 1 ) ? i - 1 : i ; int expEp = ( j == 1 ) ? MockFileSystem . NUM_EPISODES : j - 1 ; EpisodeMatch toNavigate = new EpisodeMatch ( "Scrubs" , i , j ) ; EpisodeMatch expResult = new EpisodeMatch ( season , expEp ) ; EpisodeMatch result = episode . navigate ( toNavigate , EpisodeNavigator . Pointer . PREV ) ; if ( result == null && i == 1 && j == 1 ) { return ; } System . out . println ( "Navigating: " + toNavigate + " : to : " + expResult ) ; assertEquals ( expResult . getSeason ( ) , result . getSeason ( ) ) ; assertEquals ( expResult . getEpisodes ( ) , result . getEpisodes ( ) ) ; } } }
tr	9	public void run ( ) { searchField . setText ( "" ) ; searchField . setText ( SelectionField . SEARCHTERM ) ; TreeMap < Integer , List < Champion >> priorities = new TreeMap < Integer , List < Champion >> ( ) ; for ( Champion c : Initialiser . getChampionList ( ) ) { int priority = c . calculatePriority ( ) ; List < Champion > priorityList = priorities . get ( priority ) ; if ( priorityList == null ) { priorityList = new LinkedList < Champion > ( ) ; priorities . put ( priority , priorityList ) ; } priorityList . add ( c ) ; } Entry < Integer , List < Champion >> e = priorities . pollLastEntry ( ) ; recommendedModel . clear ( ) ; goodModel . clear ( ) ; viableModel . clear ( ) ; allModel . clear ( ) ; if ( e != null ) { for ( Champion c : e . getValue ( ) ) recommendedModel . addElement ( c ) ; e = priorities . pollLastEntry ( ) ; if ( e != null ) { for ( Champion c : e . getValue ( ) ) goodModel . addElement ( c ) ; e = priorities . pollLastEntry ( ) ; if ( e != null ) { for ( Champion c : e . getValue ( ) ) viableModel . addElement ( c ) ; e = priorities . pollLastEntry ( ) ; while ( e != null ) { for ( Champion c : e . getValue ( ) ) allModel . addElement ( c ) ; e = priorities . pollLastEntry ( ) ; } } } } reset ( ) ; scroller . revalidate ( ) ; }
tr	2	@ Override public String getAsString ( FacesContext facesContext , UIComponent component , Object object ) { if ( object == null ) { return null ; } if ( object instanceof Keystate ) { Keystate o = ( Keystate ) object ; return getStringKey ( o . getIdkeystate ( ) ) ; } else { Logger . getLogger ( this . getClass ( ) . getName ( ) ) . log ( Level . SEVERE , "object {0} is of type {1}; expected type: {2}" , new Object [ ] { object , object . getClass ( ) . getName ( ) , Keystate . class . getName ( ) } ) ; return null ; } }
tr	4	public void readFaceBundles ( String n ) throws FileNotFoundException , IOException , IllegalArgumentException , ClassNotFoundException { root_dir = new File ( n ) ; File [ ] files = root_dir . listFiles ( new ImageFilter ( ) ) ; Vector filenames = new Vector ( ) ; String [ ] set = new String [ MAGIC_SETNR ] ; int i = 0 ; for ( i = 0 ; i < files . length ; i ++ ) { filenames . addElement ( files [ i ] . getName ( ) ) ; } Collections . sort ( ( List ) filenames ) ; b = new FaceBundle [ ( files . length / MAGIC_SETNR ) + 1 ] ; for ( i = 0 ; i < b . length ; i ++ ) { for ( int j = 0 ; j < MAGIC_SETNR ; j ++ ) { if ( filenames . size ( ) > j + MAGIC_SETNR * i ) { set [ j ] = ( String ) filenames . get ( j + MAGIC_SETNR * i ) ; } } b [ i ] = submitSet ( root_dir . getAbsolutePath ( ) + "/" , set ) ; } }
tr	7	protected SQLPermissionBase getBaseClass ( PermissionType type , String name ) { switch ( type ) { case USER : return new SQLPermissionUser ( name ) ; case GROUP : return new SQLPermissionGroup ( name ) ; case WORLD : return new SQLPermissionWorld ( name ) ; case ENTITY : return new SQLPermissionEntity ( name ) ; case OP : return new SQLPermissionOp ( ) ; case CONSOLE : return new SQLPermissionConsole ( ) ; case RCON : return new SQLPermissionRcon ( ) ; default : return null ; } }
tr	4	public static void main ( String [ ] args ) { try { FieldFileReader reader = new FieldFileReader ( "./data/problem022.input.txt" , " " ) ; int row = 0 ; String [ ] fields = reader . readFields ( ) ; Arrays . sort ( fields ) ; for ( int i = 0 ; i < fields . length ; i ++ ) { fields [ i ] = fields [ i ] . replaceAll ( "\"" , "" ) . toLowerCase ( ) ; } long total = 0 ; for ( int i = 0 ; i < fields . length ; i ++ ) { final int idx = ( i + 1 ) ; final String name = fields [ i ] ; int score = 0 ; for ( char c : name . toCharArray ( ) ) { final int val = ( int ) ( c - a ) + 1 ; score += val ; } total += ( long ) ( score * idx ) ; System . out . println ( idx + "\t" + fields [ i ] + "\t" + score * idx ) ; } System . out . println ( "# total of scores = " + total ) ; } catch ( Exception ex ) { Logger . getLogger ( Problem018 . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } }
tr	5	public static void main ( String [ ] args ) { ArrayList < Integer > answers = new ArrayList < Integer > ( ) ; for ( int i = 1 ; answers . size ( ) < 124 ; i += 2 ) { int a = 1 ; int b = 1 ; int c = 1 ; boolean divisible = false ; for ( int n = 0 ; n < 1000000 && ! divisible ; n ++ ) { int temp = a + b + c ; temp %= i ; if ( temp == 0 ) divisible = true ; a = b ; b = c ; c = temp ; } if ( ! divisible ) answers . add ( i ) ; } System . out . print ( answers . get ( answers . size ( ) - 1 ) ) ; }
tr	0	public String getXlinkRole ( ) { return xlinkRole ; }
tr	2	public boolean inGameState ( String state ) { for ( int i = gamestate . size ( ) - 1 ; i >= 0 ; i -- ) { if ( ( ( String ) gamestate . elementAt ( i ) ) . equals ( state ) ) return true ; } return false ; }
tr	7	private static void _enumerateInterfaces ( NetworkInterfaceCallbackInterface callback ) { if ( callback == null ) return ; try { Enumeration < NetworkInterface > interfaces = NetworkInterface . getNetworkInterfaces ( ) ; while ( interfaces . hasMoreElements ( ) ) { NetworkInterface iface = interfaces . nextElement ( ) ; if ( callback != null && ! callback . newNetworkInterface ( iface ) ) continue ; Enumeration < InetAddress > ipVec = iface . getInetAddresses ( ) ; while ( ipVec . hasMoreElements ( ) ) { InetAddress address = ipVec . nextElement ( ) ; if ( callback != null ) callback . newInetAddress ( address ) ; } } } catch ( SocketException e ) { } }
tr	5	public synchronized boolean findSDSLInstances ( ) { knownSDSLInstances = new ArrayList < SDSL > ( ) ; boolean found = false ; ListIterator < Line > it = gct . getCodeLines ( ) . listIterator ( ) ; while ( it . hasNext ( ) ) { Line l = it . next ( ) ; if ( l . startsWith ( "28708ceb 000000" ) ) { Line [ ] code = new Line [ 4 ] ; code [ 0 ] = l ; code [ 1 ] = it . next ( ) ; if ( code [ 1 ] . startsWith ( "4A000000 90180F06" ) ) { code [ 2 ] = it . next ( ) ; if ( code [ 2 ] . startsWith ( "14000076 FF00" ) ) { code [ 3 ] = it . next ( ) ; if ( code [ 3 ] . startsWith ( "E0000000 80008000" ) ) { found = true ; SDSL sdsl = new SDSL ( code ) ; knownSDSLInstances . add ( sdsl ) ; gct . recordDynamicCode ( sdsl ) ; } } } } } return found ; }
tr	2	@ Override public final void setGeometry ( final Object geometry ) { if ( geometry instanceof String [ ] ) { final String [ ] geometryArray = ( String [ ] ) geometry ; if ( geometryArray . length != 4 ) { throw new IllegalArgumentException ( "geometry must be an array of four elements that contains racolName  decColName  timeColName and bandColName" ) ; } else { this . raCol = geometryArray [ 0 ] ; this . decCol = geometryArray [ 1 ] ; this . timeCol = geometryArray [ 2 ] ; this . bandCol = geometryArray [ 3 ] ; } } else { throw new IllegalArgumentException ( "geometry must be an array of four elements that contains racolName  decColName  timeColName and bandColName" ) ; } }
tr	1	@ Override public Object visitBooleanLiteral ( BooleanLiteral bool , Integer arg ) { if ( bool . spelling . equals ( "true" ) ) { Machine . emit ( Op . LOADL , Machine . trueRep ) ; } else { Machine . emit ( Op . LOADL , Machine . falseRep ) ; } return null ; }
tr	8	public void extractInfoFromUserData ( String user_data , RequirementGraph graph ) { List < String > user_data_set = Arrays . asList ( user_data . split ( "\" " ) ) ; for ( String temp : user_data_set ) { int separator = temp . indexOf ( ":" ) ; String key = temp . substring ( 0 , separator ) . trim ( ) . toLowerCase ( ) ; String value = temp . substring ( separator + 2 ) . replace ( "\"}" , "" ) . trim ( ) ; value . replaceAll ( "\\_" , " " ) ; if ( key . toLowerCase ( ) . contains ( "importance" ) ) { this . setImportance ( value ) ; } else if ( key . toLowerCase ( ) . contains ( "sec_property" ) ) { this . setSecurityAttribute ( value ) ; } else if ( key . toLowerCase ( ) . contains ( "asset" ) ) { this . setAsset ( value ) ; } else if ( key . toLowerCase ( ) . contains ( "interval_id" ) ) { Element elem = graph . findElementById ( value ) ; if ( elem != null ) { this . setInterval ( elem ) ; } else { this . setInterval ( null ) ; this . interval_id = value ; } } else if ( key . toLowerCase ( ) . contains ( "threat_ids" ) ) { String [ ] threat_ids = value . split ( " " ) ; for ( String id : threat_ids ) { this . threats . add ( id ) ; } } else { } } }
tr	1	public boolean addMeter ( Meter meter ) { int meterID = meter . getMeterID ( ) ; if ( meters . containsKey ( meterID ) ) { return false ; } else meters . put ( meterID , meter ) ; return true ; }
tr	8	private int buildZone ( int x , int maxLength ) { int t = random . nextInt ( totalOdds ) ; int type = 0 ; for ( int i = 0 ; i < odds . length ; i ++ ) { if ( odds [ i ] <= t ) { type = i ; } } switch ( type ) { case ODDS_STRAIGHT : return buildStraight ( x , maxLength , false ) ; case ODDS_HILL_STRAIGHT : return buildHillStraight ( x , maxLength ) ; case ODDS_TUBES : return buildTubes ( x , maxLength ) ; case ODDS_JUMP : if ( gaps < Constraints . gaps ) return buildJump ( x , maxLength ) ; else return buildStraight ( x , maxLength , false ) ; case ODDS_CANNONS : return buildCannons ( x , maxLength ) ; } return 0 ; }
tr	6	public char next ( ) throws JSONException { int c ; if ( this . usePrevious ) { this . usePrevious = false ; c = this . previous ; } else { try { c = this . reader . read ( ) ; } catch ( IOException exception ) { throw new JSONException ( exception ) ; } if ( c <= 0 ) { this . eof = true ; c = 0 ; } } this . index += 1 ; if ( this . previous == '' ) { this . line += 1 ; this . character = c == '' ? 0 : 1 ; } else if ( c == '' ) { this . line += 1 ; this . character = 0 ; } else { this . character += 1 ; } this . previous = ( char ) c ; return this . previous ; }
tr	8	private void filter ( KDTreeCell cell , ArrayList < FCECenter > candidates ) { try { ArrayList < FCECenter > input = new ArrayList < > ( ) ; input . addAll ( candidates ) ; if ( cell . isLeafNode ( ) && ! cell . isEmpty ( ) ) { Collections . sort ( input , new CenterDistanceComparator ( cell . getPoint ( ) ) ) ; input . get ( 0 ) . addToCount ( 1 ) ; input . get ( 0 ) . addToSum ( cell . getPoint ( ) ) ; } else { Collections . sort ( input , new CenterDistanceComparator ( cell . getCenter ( ) ) ) ; FCECenter closest = input . get ( 0 ) ; Iterator < FCECenter > it = input . iterator ( ) ; it . next ( ) ; while ( it . hasNext ( ) ) { FCECenter z = it . next ( ) ; Point midpoint = closest . getCenter ( ) . midpointFromPoint ( z . getCenter ( ) ) ; Vector normal = new Vector ( midpoint , closest . getCenter ( ) ) ; if ( cell . getBoundingBox ( ) . intersectWithPlane ( new Plane ( midpoint , normal ) ) == BoundingBox . BB_INFRONT ) it . remove ( ) ; } if ( input . size ( ) > 1 ) { ArrayList < FCECenter > newCandidates = new ArrayList < > ( ) ; newCandidates . addAll ( input ) ; this . filter ( cell . getChild ( 0 ) , newCandidates ) ; this . filter ( cell . getChild ( 1 ) , input ) ; } else { closest . addToCount ( cell . getPointCount ( ) ) ; closest . addToSum ( cell . getSum ( ) ) ; } } } catch ( CenterDistanceComparatorException cdce ) { } catch ( GeometryException | KDTreeCellException ge ) { } catch ( FCEException fcee ) { } }
tr	5	@ Override public boolean dispatchKeyEvent ( KeyEvent arg0 ) { if ( arg0 . getID ( ) != KeyEvent . KEY_PRESSED ) return false ; int keyPressed = arg0 . getKeyCode ( ) ; if ( keyPressed == KeyEvent . VK_U ) undoCommand ( ) ; else if ( keyPressed == KeyEvent . VK_R ) redoCommand ( ) ; else { Command c = keyToCommandMap . get ( keyPressed ) ; if ( c != null ) if ( c . execute ( ) ) saveGameState ( c ) ; } return false ; }
tr	5	@ Override public double [ ] getDoubleData ( ) { if ( ptr != 0 ) { return null ; } else { if ( isConstant ( ) ) { if ( length > getMaxSizeOf32bitArray ( ) ) return null ; double [ ] out = new double [ ( int ) length ] ; double elem = ( double ) data [ 0 ] ; for ( int i = 0 ; i < length ; i ++ ) { out [ i ] = elem ; } return out ; } else { double [ ] res = new double [ ( int ) length ] ; for ( int i = 0 ; i < length ; i ++ ) { res [ i ] = ( double ) data [ i ] ; } return res ; } } }
tr	9	private boolean r_attached_pronoun ( ) { int among_var ; ket = cursor ; if ( find_among_b ( a_1 , 13 ) == 0 ) { return false ; } bra = cursor ; among_var = find_among_b ( a_2 , 11 ) ; if ( among_var == 0 ) { return false ; } if ( ! r_RV ( ) ) { return false ; } switch ( among_var ) { case 0 : return false ; case 1 : bra = cursor ; slice_from ( "iendo" ) ; break ; case 2 : bra = cursor ; slice_from ( "ando" ) ; break ; case 3 : bra = cursor ; slice_from ( "ar" ) ; break ; case 4 : bra = cursor ; slice_from ( "er" ) ; break ; case 5 : bra = cursor ; slice_from ( "ir" ) ; break ; case 6 : slice_del ( ) ; break ; case 7 : if ( ! ( eq_s_b ( 1 , "u" ) ) ) { return false ; } slice_del ( ) ; break ; } return true ; }
tr	4	private void pushMessage ( String message , int type , String name ) { if ( type == 0 && dialogID != - 1 ) { clickToContinueString = message ; super . clickType = 0 ; } if ( chatboxInterfaceId == - 1 ) redrawChatbox = true ; for ( int m = 99 ; m > 0 ; m -- ) { chatTypes [ m ] = chatTypes [ m - 1 ] ; chatNames [ m ] = chatNames [ m - 1 ] ; chatMessages [ m ] = chatMessages [ m - 1 ] ; } chatTypes [ 0 ] = type ; chatNames [ 0 ] = name ; chatMessages [ 0 ] = message ; }
tr	8	public boolean equals ( remover_args that ) { if ( that == null ) return false ; boolean this_present_registro = true && this . isSetRegistro ( ) ; boolean that_present_registro = true && that . isSetRegistro ( ) ; if ( this_present_registro || that_present_registro ) { if ( ! ( this_present_registro && that_present_registro ) ) return false ; if ( ! this . registro . equals ( that . registro ) ) return false ; } return true ; }
tr	9	public void notifyWindowListeners ( List < EngineWindowListener > listeners ) { while ( ! windowEvents . isEmpty ( ) ) { WindowEvent event = windowEvents . poll ( ) ; switch ( event . getID ( ) ) { case WindowEvent . WINDOW_OPENED : for ( EngineWindowListener listener : listeners ) { listener . windowOpened ( event ) ; } break ; case WindowEvent . WINDOW_CLOSING : for ( EngineWindowListener listener : listeners ) { listener . windowClosing ( event ) ; } break ; case WindowEvent . WINDOW_CLOSED : for ( EngineWindowListener listener : listeners ) { listener . windowClosed ( event ) ; } break ; case WindowEvent . WINDOW_ICONIFIED : for ( EngineWindowListener listener : listeners ) { listener . windowIconified ( event ) ; } break ; case WindowEvent . WINDOW_DEICONIFIED : for ( EngineWindowListener listener : listeners ) { listener . windowDeiconified ( event ) ; } break ; case WindowEvent . WINDOW_ACTIVATED : for ( EngineWindowListener listener : listeners ) { listener . windowActivated ( event ) ; } break ; case WindowEvent . WINDOW_DEACTIVATED : for ( EngineWindowListener listener : listeners ) { listener . windowDeactivated ( event ) ; } break ; } } }
tr	2	public void exit ( ) { for ( List < GameSystem > s : systems . values ( ) ) { for ( GameSystem system : s ) { system . exit ( ) ; } } systems . clear ( ) ; }
