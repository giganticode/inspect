tr	7	public void earlyStartup ( ) { IPreferenceStore store = StartupPlugin . getDefault ( ) . getPreferenceStore ( ) ; boolean readPrefs = true ; if ( store . contains ( PreferenceInitializer . PREF_ENABLE_READ ) ) readPrefs = store . getBoolean ( PreferenceInitializer . PREF_ENABLE_READ ) ; if ( ! readPrefs ) return ; final IWorkbench workbench = PlatformUI . getWorkbench ( ) ; final boolean wsIsInitialized = store . getBoolean ( PreferenceInitializer . PREF_WS_INITIALIZED ) ; workbench . getDisplay ( ) . asyncExec ( new Runnable ( ) { public void run ( ) { IWorkbenchWindow window = workbench . getActiveWorkbenchWindow ( ) ; if ( window == null ) return ; if ( StartupPlugin . getDefault ( ) . isDebugging ( ) ) StartupPlugin . log ( new Status ( IStatus . INFO , StartupPlugin . PLUGIN_ID , "Common Preferences Plugin earlyStartup called." ) ) ; if ( ! wsIsInitialized ) { CommonPrefsHelper . saveDefaultPreferences ( ) ; } IStatus status = CommonPrefsHelper . loadPreferences ( ) ; if ( status . getChildren ( ) . length > 0 ) StartupPlugin . log ( status ) ; if ( StartupPlugin . getDefault ( ) . isDebugging ( ) ) StartupPlugin . log ( new Status ( IStatus . INFO , StartupPlugin . PLUGIN_ID , "Common Preferences Plugin earlyStartup finished." ) ) ; } } ) ; }
tr	6	public char next ( ) throws JSONException { int c ; if ( this . usePrevious ) { this . usePrevious = false ; c = this . previous ; } else { try { c = this . reader . read ( ) ; } catch ( IOException exception ) { throw new JSONException ( exception ) ; } if ( c <= 0 ) { this . eof = true ; c = 0 ; } } this . index += 1 ; if ( this . previous == '' ) { this . line += 1 ; this . character = c == '' ? 0 : 1 ; } else if ( c == '' ) { this . line += 1 ; this . character = 0 ; } else { this . character += 1 ; } this . previous = ( char ) c ; return this . previous ; }
tr	0	public List < Tuple < Integer , Integer >> allPointsInLine ( Line2D line ) { ArrayList < Tuple < Integer , Integer >> points = new ArrayList < Tuple < Integer , Integer >> ( ) ; double x1 = line . getX1 ( ) ; return points ; }
tr	7	public int minPathSum ( int [ ] [ ] grid ) { int sum = 0 ; if ( grid == null || grid . length == 0 || grid [ 0 ] . length == 0 ) return sum ; int [ ] prev = new int [ grid [ 0 ] . length ] ; int [ ] curr = new int [ grid [ 0 ] . length ] ; prev [ 0 ] = grid [ 0 ] [ 0 ] ; for ( int j = 1 ; j < grid [ 0 ] . length ; j ++ ) prev [ j ] = prev [ j - 1 ] + grid [ 0 ] [ j ] ; for ( int i = 1 ; i < grid . length ; i ++ ) { curr [ 0 ] = prev [ 0 ] + grid [ i ] [ 0 ] ; for ( int j = 1 ; j < grid [ 0 ] . length ; j ++ ) { curr [ j ] = Math . min ( prev [ j ] , curr [ j - 1 ] ) + grid [ i ] [ j ] ; } for ( int j = 0 ; j < grid [ 0 ] . length ; j ++ ) dbg ( curr [ j ] ) ; System . out . println ( ) ; int [ ] tmp = curr ; curr = prev ; prev = tmp ; } return prev [ prev . length - 1 ] ; }
tr	2	public static void findAll ( ) { try { IUTypeDao _dao = getUTypeDao ( ) ; UType _result [ ] = _dao . findAll ( ) ; for ( int i = 0 ; i < _result . length ; i ++ ) { display ( _result [ i ] ) ; } } catch ( Exception _e ) { _e . printStackTrace ( ) ; } }
tr	9	public static Op IT ( Op a , Op b ) { if ( a == null ) return null ; if ( b == null ) return a ; int at = a . getOpType ( ) , bt = b . getOpType ( ) ; if ( at == OpType . INSERT_CHAR && bt == OpType . INSERT_CHAR ) return ii ( ( Insertion ) a , ( Insertion ) b ) ; if ( at == OpType . DELETE_CHAR && bt == OpType . DELETE_CHAR ) return dd ( ( Deletion ) a , ( Deletion ) b ) ; if ( at == OpType . INSERT_CHAR && bt == OpType . DELETE_CHAR ) return id ( ( Insertion ) a , ( Deletion ) b ) ; if ( at == OpType . DELETE_CHAR && bt == OpType . INSERT_CHAR ) return di ( ( Deletion ) a , ( Insertion ) b ) ; return null ; }
tr	5	private String getShipLocationDifference ( HashMap < String , List < BoardLocation >> otherShipLocations ) throws Exception { String a = "\n" ; if ( ! otherShipLocations . keySet ( ) . equals ( playerShipLocations . keySet ( ) ) ) { for ( String s : otherShipLocations . keySet ( ) ) { System . out . println ( s ) ; } System . out . println ( "different from" ) ; for ( String s : playerShipLocations . keySet ( ) ) { System . out . println ( s ) ; } } for ( String k : otherShipLocations . keySet ( ) ) { if ( ! otherShipLocations . get ( k ) . equals ( playerShipLocations . get ( k ) ) ) { a = a . concat ( k + ":" + getListBoardLocationsDifference ( playerShipLocations . get ( k ) , otherShipLocations . get ( k ) ) + "\n" ) ; } } return a ; }
tr	6	public static void main ( String [ ] args ) { boolean all_right ; all_right = true ; int [ ] p0 ; int [ ] p1 ; String p2 ; p0 = new int [ ] { 0 } ; p1 = new int [ ] { 0 } ; p2 = "Possible" ; all_right = KawigiEdit_RunTest ( 0 , p0 , p1 , true , p2 ) && all_right ; p0 = new int [ ] { 1 , 0 } ; p1 = new int [ ] { 0 , 1 } ; p2 = "Possible" ; all_right = KawigiEdit_RunTest ( 1 , p0 , p1 , true , p2 ) && all_right ; p0 = new int [ ] { 0 , 1 } ; p1 = new int [ ] { 1 , 0 } ; p2 = "Impossible" ; all_right = KawigiEdit_RunTest ( 2 , p0 , p1 , true , p2 ) && all_right ; p0 = new int [ ] { 3 , 1 , 2 , 0 } ; p1 = new int [ ] { 0 , 2 , 1 , 3 } ; p2 = "Possible" ; all_right = KawigiEdit_RunTest ( 3 , p0 , p1 , true , p2 ) && all_right ; p0 = new int [ ] { 3 , 1 , 2 , 0 } ; p1 = new int [ ] { 3 , 2 , 0 , 1 } ; p2 = "Impossible" ; all_right = KawigiEdit_RunTest ( 4 , p0 , p1 , true , p2 ) && all_right ; if ( all_right ) { System . out . println ( "You're a stud (at least on the example cases)!" ) ; } else { System . out . println ( "Some of the test cases had errors." ) ; } }
tr	3	public void updateRollingLabel ( ) { try { if ( ! display . isDisposed ( ) ) { Runnable runnable = new Runnable ( ) { @ Override public void run ( ) { MessageQueue messageQueue = MessageQueue . getInstance ( ) ; for ( int i = 0 ; i < 4 ; i ++ ) { rollingLabels [ i ] . setText ( messageQueue . getMessage ( i ) ) ; } } } ; display . syncExec ( runnable ) ; } } catch ( SWTException e ) { System . out . println ( "swt \u7684\u7EBF\u7A0B\u771F\u8BA9\u4EBA\u4F24\u5FC3" ) ; } }
tr	5	public static int getNumber ( ChessMainMenuTerminal Menu , int maxNum ) { int num = 0 ; Scanner scan = new Scanner ( System . in ) ; while ( num < 1 || num > maxNum ) { num = 0 ; try { Menu . update ( ) ; num = scan . nextInt ( ) ; if ( num < 1 || num > maxNum ) Menu . displayMessage ( "The number must be between 1 and 3" ) ; } catch ( Exception e ) { Menu . displayMessage ( "You must enter a whole number" ) ; scan . next ( ) ; } } return num ; }
tr	1	public static < T > FunctionExecutor < T > createGet ( final FeatureDefinition < ? extends Property < T >> propertyDefinition ) { return new FunctionExecutor < T > ( ) { @ Override public T invoke ( FunctionInvocation < T > invocation , Object ... arguments ) throws ExecutorInvocationException { invocation . next ( arguments ) ; return invocation . getHolder ( ) . get ( propertyDefinition ) . get ( ) ; } } ; }
tr	4	public char [ ] minCharCutMulti ( int numOfTracks ) { Debugger . debug ( "min cut set:***************\n" , 2 , debugLevel ) ; HashSet < ArrayList < Transition >> minCutSet = minCutMulti ( numOfTracks ) ; StringBuilder b = new StringBuilder ( ) ; for ( ArrayList < Transition > tracksArray : minCutSet ) { Transition tracks [ ] = new Transition [ numOfTracks ] ; for ( int i = 0 ; i < tracksArray . size ( ) ; i ++ ) { tracks [ tracksArray . get ( i ) . track - 1 ] = tracksArray . get ( i ) ; } for ( int i = 0 ; i < tracks . length ; i ++ ) { b . append ( "track" ) . append ( i + 1 ) ; b . append ( ": [" ) ; if ( tracks [ i ] . min != tracks [ i ] . max ) { Transition . appendCharString ( tracks [ i ] . min , b ) ; b . append ( "  " ) ; Transition . appendCharString ( tracks [ i ] . max , b ) ; } else Transition . appendCharString ( tracks [ i ] . min , b ) ; b . append ( "]" ) ; b . append ( "   " ) ; } b . append ( "\n" ) ; } Debugger . debug ( b . toString ( ) , 0 , debugLevel ) ; return null ; }
tr	7	private static void argsCommand ( String [ ] args ) { for ( int i = 0 ; i < args . length ; i ++ ) { switch ( args [ i ] . toLowerCase ( ) ) { case "-ip" : if ( args [ i + 1 ] . trim ( ) . split ( ":" ) . length == 2 ) { networkIP = args [ i + 1 ] . split ( ":" , 2 ) [ 0 ] . trim ( ) ; rmiPort = Integer . parseInt ( args [ i + 1 ] . split ( ":" , 2 ) [ 1 ] . trim ( ) ) ; i ++ ; } else { System . out . println ( "Invalid arguments for -ip" ) ; } break ; case "-tcp" : tcpPort = Integer . parseInt ( args [ i + 1 ] . trim ( ) ) ; i ++ ; break ; case "-multicast" : if ( args [ i + 1 ] . trim ( ) . split ( ":" ) . length == 2 ) { multicastIP = args [ i + 1 ] . trim ( ) . split ( ":" , 2 ) [ 0 ] ; multicastPort = Integer . parseInt ( args [ i + 1 ] . trim ( ) . split ( ":" , 2 ) [ 1 ] ) ; i ++ ; } else { System . out . println ( "Invalid arguments for -multicast" ) ; } break ; case "-help" : System . out . println ( "SystemY Server application - 2014" ) ; System . out . println ( "Starts the server for connecting to SystemY. SystemY is a distributed file system for local networks." ) ; System . out . println ( "\nOptions: " ) ; System . out . println ( "\t-ip {ip}:{port}\t\tThe given ip will be used for all communication from the server to the network.\n\t\t\t\tThe ip must be the ip of the physical interface connected to the local network with SystemY." ) ; System . out . println ( "\t-tcpPort {port}\tThis feature is for future purposes." ) ; System . out . println ( "\t-multicast {ip}:{port}\tThis feature is for future purposes." ) ; System . exit ( 0 ) ; default : System . out . println ( "Unkown option '" + args [ i ] + "'" ) ; break ; } } }
tr	8	private Component cycle ( Component currentComponent , int delta ) { int index = - 1 ; loop : for ( int i = 0 ; i < m_Components . length ; i ++ ) { Component component = m_Components [ i ] ; for ( Component c = currentComponent ; c != null ; c = c . getParent ( ) ) { if ( component == c ) { index = i ; break loop ; } } } int initialIndex = index ; while ( true ) { int newIndex = indexCycle ( index , delta ) ; if ( newIndex == initialIndex ) { break ; } index = newIndex ; Component component = m_Components [ newIndex ] ; if ( component . isEnabled ( ) && component . isVisible ( ) && component . isFocusable ( ) ) { return component ; } } return currentComponent ; }
tr	2	public static final void initialize ( ) { slowSlaves = new SlaveThread [ NB_SLOWSLAVES ] ; fastSlaves = new SlaveThread [ NB_FASTSLAVES ] ; for ( int i = 0 ; i < NB_SLOWSLAVES ; i ++ ) { slowSlaves [ i ] = new SlaveThread ( ) ; slowSlaves [ i ] . start ( ) ; } for ( int i = 0 ; i < NB_FASTSLAVES ; i ++ ) { fastSlaves [ i ] = new SlaveThread ( ) ; fastSlaves [ i ] . start ( ) ; } indexSlow = 0 ; indexFast = 0 ; }
tr	5	public V checkBaseInterfaces ( class c ) { Map < class , V > possibles = new HashMap < class , V > ( ) ; for ( class base = c ; base != Object . class ; base = base . getSuperclass ( ) ) { for ( class itf : base . getInterfaces ( ) ) { V val = lookup . valAt ( itf ) ; if ( val != null ) possibles . put ( itf , val ) ; } } switch ( possibles . size ( ) ) { case 0 : return null ; case 1 : return possibles . values ( ) . iterator ( ) . next ( ) ; default : throw new RuntimeException ( "More thane one match for " + c ) ; } }
tr	2	public Node connectionMix ( ) { Connection newConnection = new Connection ( ) ; Connection oneC = ( Connection ) one ; Connection twoC = ( Connection ) two ; Random random = new Random ( ) ; newConnection . setGiveNeuron ( oneC . getGiveNeuron ( ) ) ; newConnection . setRecieveNeuron ( oneC . getRecieveNeuron ( ) ) ; newConnection . setInnovationNum ( oneC . getInnovationNum ( ) ) ; double test = random . nextDouble ( ) ; if ( test > .5 ) newConnection . setActive ( oneC . getActive ( ) ) ; else newConnection . setActive ( twoC . getActive ( ) ) ; test = random . nextDouble ( ) ; if ( test > .5 ) newConnection . setWeight ( oneC . getWeight ( ) ) ; else newConnection . setWeight ( twoC . getWeight ( ) ) ; return newConnection ; }
tr	9	public static < KEY , VALUE > Map < KEY , VALUE > runIdempotentTasks ( Collection < ? extends IDependentTask < KEY , VALUE >> tasks , ExecutorService es , int maxRounds ) throws Exception { final Map < KEY , VALUE > out = new HashMap < KEY , VALUE > ( ) ; Map < KEY , IDependentTask < KEY , VALUE >> allTasks = new HashMap < KEY , MraUtils . IDependentTask < KEY , VALUE >> ( ) ; for ( IDependentTask < KEY , VALUE > t : tasks ) { allTasks . put ( t . getTaskID ( ) , t ) ; } Set < KEY > remaining = new HashSet < KEY > ( allTasks . keySet ( ) ) ; Set < KEY > done = new HashSet < KEY > ( ) ; Map < KEY , Integer > failures = new HashMap < KEY , Integer > ( ) ; while ( remaining . size ( ) > 0 ) { Set < KEY > toRun = new HashSet < KEY > ( ) ; for ( KEY k : remaining ) { if ( done . containsAll ( allTasks . get ( k ) . getDependsOn ( ) ) ) { toRun . add ( k ) ; } } if ( toRun . size ( ) == 0 ) { throw new IllegalStateException ( "can't run any more tasks" ) ; } Map < KEY , Future < VALUE >> futures = new HashMap < KEY , Future < VALUE >> ( ) ; int submitted = 0 ; for ( KEY k : toRun ) { final IDependentTask < KEY , VALUE > t = allTasks . get ( k ) ; boolean block = false ; if ( failures . containsKey ( k ) ) { if ( failures . get ( k ) > maxRounds ) { block = true ; } } if ( ! block ) { submitted ++ ; futures . put ( k , es . submit ( new Callable < VALUE > ( ) { @ Override public VALUE call ( ) throws Exception { return t . call ( out ) ; } } ) ) ; } } if ( submitted == 0 ) { throw new IllegalStateException ( "can't run any more tasks" ) ; } for ( KEY k : futures . keySet ( ) ) { try { out . put ( k , futures . get ( k ) . get ( ) ) ; done . add ( k ) ; } catch ( Exception e ) { if ( failures . containsKey ( k ) ) { failures . put ( k , failures . get ( k ) + 1 ) ; } else { failures . put ( k , 1 ) ; } logger . warnf ( "exception running %s: %s" , k , e ) ; e . printStackTrace ( ) ; } } remaining . removeAll ( done ) ; } return out ; }
tr	2	public static int foul ( TeamMatch match ) { int x = 0 ; for ( Points p : match . getPoints ( ) ) { if ( p instanceof Points . FoulPoints ) { x += p . getPoints ( ) ; } } return x ; }
tr	6	protected byte [ ] convertPasswordToKey ( String password ) { if ( password == null ) return null ; int count = password . length ( ) ; if ( count < 8 ) password += "         " . substring ( count ) ; byte [ ] pw = password . getBytes ( ) ; count = pw . length ; int pos = 0 ; byte [ ] key = new byte [ 7 ] ; for ( ; ; ) { for ( int n = 0 ; n < 7 ; n ++ ) { int p1 = pw [ pos + n ] & FF ; p1 >>= n ; int p2 = pw [ pos + n + 1 ] & FF ; p2 <<= ( 7 - n ) ; key [ n ] = ( byte ) ( p1 + p2 ) ; } pos += 8 ; if ( pos == count ) return key ; int pending = count - pos ; if ( pending < 8 ) pos -= 8 - pending ; encrypt ( key , pw , pos , 8 ) ; } }
tr	6	public static void copyFilebyBufferedOutputStream ( File file ) throws IOException { FileInputStream fis = null ; BufferedInputStream bis = null ; FileOutputStream fos = null ; BufferedOutputStream bos = null ; try { fis = new FileInputStream ( file ) ; bis = new BufferedInputStream ( fis ) ; fos = new FileOutputStream ( file . getName ( ) + ".bak" ) ; bos = new BufferedOutputStream ( fos ) ; byte [ ] buffer = new byte [ 1024 ] ; int bytesRead = 0 ; while ( ( bytesRead = bis . read ( buffer , 0 , buffer . length ) ) != - 1 ) { bos . write ( buffer , 0 , bytesRead ) ; } bos . flush ( ) ; } catch ( Exception ex ) { System . out . println ( "Error occurs during copying " + file . getAbsoluteFile ( ) ) ; } finally { if ( fis != null ) fis . close ( ) ; if ( bis != null ) bis . close ( ) ; if ( fos != null ) fos . close ( ) ; if ( bos != null ) bos . close ( ) ; } }
tr	5	public synchronized boolean updateCheck ( ) { Scanner s = null ; try { s = new Scanner ( versionUrl . openStream ( ) ) ; remoteVersion = s . nextLine ( ) ; if ( this . compareVersions ( ) ) { upToDate . set ( false ) ; s . close ( ) ; return true ; } upToDate . set ( true ) ; } catch ( MalformedURLException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { } catch ( NoSuchElementException e ) { } finally { if ( s != null ) { s . close ( ) ; } } return false ; }
tr	4	@ Override public int hashCode ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + ( ( elseifs == null ) ? 0 : elseifs . hashCode ( ) ) ; result = prime * result + ( ( exp1 == null ) ? 0 : exp1 . hashCode ( ) ) ; result = prime * result + ( ( stateSeq1 == null ) ? 0 : stateSeq1 . hashCode ( ) ) ; result = prime * result + ( ( stateSeq2 == null ) ? 0 : stateSeq2 . hashCode ( ) ) ; return result ; }
tr	4	@ Test public final void testGetKeyEnumeration ( ) { final OrderedMap < String , String > orderedMap = new OrderedMap < String , String > ( ) ; orderedMap . put ( "key0" , "value0" ) ; orderedMap . put ( "key1" , "value1" ) ; orderedMap . put ( "key2" , "value2" ) ; final Enumeration < String > keyEnumeration = orderedMap . keyEnumeration ( ) ; int index = 0 ; while ( keyEnumeration . hasMoreElements ( ) ) { if ( index == 0 ) assertEquals ( "key0" , keyEnumeration . nextElement ( ) ) ; if ( index == 1 ) assertEquals ( "key1" , keyEnumeration . nextElement ( ) ) ; if ( index == 2 ) assertEquals ( "key2" , keyEnumeration . nextElement ( ) ) ; index ++ ; } }
tr	7	@ Override public void serialEvent ( SerialPortEvent ev ) { if ( ev . getEventType ( ) != SerialPortEvent . DATA_AVAILABLE ) return ; InputStream in = port . getInputStream ( ) ; boolean eof = false ; try { in . read ( ) ; int calculatedChkSum = 0 ; int len = in . read ( ) ; int buf = in . read ( ) ; calculatedChkSum = len + buf ; int address = buf << 8 ; buf = in . read ( ) ; calculatedChkSum += buf ; address += buf ; int type = in . read ( ) ; if ( type == IHEX8Record . Type . EOF . getCode ( ) ) eof = true ; calculatedChkSum += type ; byte [ ] data = new byte [ len ] ; if ( ! eof ) { for ( int i = 0 ; i < len ; i ++ ) { data [ i ] = ( byte ) in . read ( ) ; calculatedChkSum += data [ i ] ; } } int chksum = in . read ( ) ; logger . log ( "\u041F\u043E\u043B\u0443\u0447\u0435\u043D \u0437\u0430\u043F\u0438\u0441. \u041F\u0440\u043E\u0432\u0435\u0440\u044F\u0432\u0430\u043D\u0435 \u043D\u0430 \u0447\u0435\u043A\u0441\u0443\u043C\u0438\u0442\u0435" , LogLevel . DEBUG ) ; calculatedChkSum = ( 100 - ( FF & calculatedChkSum ) ) & FF ; if ( chksum != calculatedChkSum ) { logger . log ( "\u0427\u0435\u043A\u0441\u0443\u043C\u0438\u0442\u0435 \u043D\u0435 \u0441\u044A\u0432\u043F\u0430\u0434\u0430\u0442. \u041F\u043E\u0432\u0442\u043E\u0440\u043D\u043E \u043F\u043E\u0438\u0441\u043A\u0432\u0430\u043D\u0435" , LogLevel . DEBUG ) ; port . getOutputStream ( ) . write ( ProtocolConstants . CMD_RESEND . getBytes ( ) ) ; return ; } if ( ! eof ) { logger . log ( "\u041F\u043E\u043B\u0443\u0447\u0435\u043D\u0438\u044F\u0442 \u0437\u0430\u043F\u0438\u0441 \u0435 \u043F\u0440\u0430\u0432\u0438\u043B\u0435\u043D. \u0414\u043E\u0431\u0430\u0432\u044F\u043D\u0435 \u0432 \u043F\u0430\u043C\u0435\u0442\u0442\u0430 \u0438 \u043F\u043E\u0438\u0441\u043A\u0432\u0430\u043D\u0435 \u043D\u0430 \u0441\u043B\u0435\u0434\u0432\u0430\u0449\u0438\u044F" , LogLevel . DEBUG ) ; memory . add ( new DataRecord ( address , data , ( byte ) chksum ) ) ; currentIndex ++ ; updateProgress ( ) ; port . getOutputStream ( ) . write ( ProtocolConstants . CMD_ACKNOWLEDGE . getBytes ( ) ) ; port . getOutputStream ( ) . write ( ProtocolConstants . CMD_NEXT . getBytes ( ) ) ; } else { port . getOutputStream ( ) . write ( ProtocolConstants . CMD_ACKNOWLEDGE . getBytes ( ) ) ; logger . log ( "\u041F\u043E\u043B\u0443\u0447\u0435\u043D\u0438\u044F\u0442 \u0437\u0430\u043F\u0438\u0441 \u0435 \u043F\u0440\u0430\u0432\u0438\u043B\u0435\u043D. \u0414\u043E\u0431\u0430\u0432\u044F\u043D\u0435 \u043D\u0430 \u0437\u0430\u043F\u0438\u0441 \u0437\u0430 \u043A\u0440\u0430\u0439 \u043D\u0430 \u0444\u0430\u0439\u043B\u0430" , LogLevel . DEBUG ) ; memory . add ( new EndOfFileRecord ( ) ) ; success = true ; taskComplete ( ) ; } } catch ( IOException e ) { logger . log ( "\u0412\u044A\u0437\u043D\u0438\u043A\u043D\u0430 \u0433\u0440\u0435\u0448\u043A\u0430 \u043F\u0440\u0438 \u043F\u043E\u043B\u0443\u0447\u0430\u0432\u0430\u043D\u0435\u0442\u043E \u043D\u0430 \u0437\u0430\u043F\u0438\u0441\u0438 \u043E\u0442 \u043F\u0440\u043E\u0433\u0440\u0430\u043C\u0430\u0442\u043E\u0440\u0430" , LogLevel . ERRORS ) ; e . printStackTrace ( ) ; } }
tr	7	@ Override public boolean onResponse ( Message message ) { int hour = Calendar . getInstance ( ) . get ( Calendar . HOUR_OF_DAY ) ; if ( hour <= 9 ) { for ( String word : moringWords ) { if ( message . content . contains ( word ) ) { message . reply ( moringResponseWord [ new Random ( ) . nextInt ( moringResponseWord . length ) ] ) ; return true ; } } } else if ( hour >= 21 || hour < 3 ) { for ( String word : nigthWords ) { if ( message . content . contains ( word ) ) { message . reply ( nigthResponseWords [ new Random ( ) . nextInt ( nigthResponseWords . length ) ] ) ; return true ; } } } return false ; }
tr	1	public Editor ( ) { LOGGER . info ( "Starting Editor" ) ; try { db = MySQLConnector . getInstance ( ) ; } catch ( NotConfiguredException | DataStoreException | ConnectionException e ) { showErrorMessage ( "An error occurred while connecting to the database \n" + "please check your configuration file and the connection to the database." , "Database Error" ) ; System . exit ( - 2 ) ; } frame . setLayout ( new BorderLayout ( ) ) ; mainPanel = new JPanel ( ) ; mainPanel . setLayout ( new BoxLayout ( mainPanel , BoxLayout . Y_AXIS ) ) ; scrollPane = new JScrollPane ( mainPanel ) ; scrollPane . setVerticalScrollBarPolicy ( JScrollPane . VERTICAL_SCROLLBAR_AS_NEEDED ) ; scrollPane . setHorizontalScrollBarPolicy ( JScrollPane . HORIZONTAL_SCROLLBAR_NEVER ) ; frame . add ( informationPanel , BorderLayout . NORTH ) ; frame . add ( scrollPane , BorderLayout . CENTER ) ; setupMenu ( ) ; setupEnterActionForAllButtons ( ) ; setupListeners ( ) ; RecipeSectionPanel section = new RecipeSectionPanel ( 1 ) ; section . addChangeListener ( this ) ; sections . add ( section ) ; mainPanel . add ( section ) ; scrollPane . setPreferredSize ( new Dimension ( 767 , 600 ) ) ; frame . pack ( ) ; frame . setDefaultCloseOperation ( WindowConstants . DO_NOTHING_ON_CLOSE ) ; frame . setVisible ( true ) ; }
tr	8	private QuerySet < T > isNull ( String query ) { QuerySet < T > querySet = null ; if ( query != null && ! query . trim ( ) . isEmpty ( ) ) { querySet = new QuerySet < T > ( ) ; query = query . trim ( ) . toLowerCase ( ) ; query = query . replace ( "__isnull" , "" ) ; String [ ] queryComponents = query . split ( "=" ) ; String fieldName = queryComponents [ 0 ] ; boolean isNull = boolean . parseBoolean ( queryComponents [ 1 ] ) ; Field field = null ; try { if ( fieldName . equalsIgnoreCase ( "id" ) ) { field = this . entity . getSuperclass ( ) . getDeclaredField ( fieldName ) ; } else { field = this . entity . getDeclaredField ( fieldName ) ; } field . setAccessible ( true ) ; for ( T model : this ) { if ( isNull ) { if ( field . get ( model ) == null ) { querySet . add ( model ) ; } } else { if ( field . get ( model ) != null ) { querySet . add ( model ) ; } } } } catch ( Exception e ) { e . printStackTrace ( ) ; } } return querySet ; }
tr	7	public static Vertex convertNode ( org . yaoqiang . bpmn . model . elements . core . common . FlowNode inputNode ) { Vertex outputNode = null ; String type = inputNode . getClass ( ) . getCanonicalName ( ) ; if ( outputNode == null ) { if ( type . toLowerCase ( ) . contains ( "gateway" ) ) { outputNode = new Vertex ( "" + inputNode . getName ( ) , GraphLoader . ExclusiveGateway ) ; if ( type . toLowerCase ( ) . contains ( "exclusivegateway" ) ) { outputNode . isXOR = true ; } if ( type . toLowerCase ( ) . contains ( "parallelgateway" ) ) { outputNode . isAND = true ; } if ( type . toLowerCase ( ) . contains ( "inclusivegateway" ) ) { outputNode . isOR = true ; } if ( inputNode . getOutgoingSequenceFlows ( ) . size ( ) > 1 ) outputNode . isSplit = true ; else outputNode . isJoin = true ; } else if ( type . toLowerCase ( ) . contains ( "event" ) ) { outputNode = new Vertex ( "" + inputNode . getName ( ) , GraphLoader . IntermediateThrowEvent ) ; } else { outputNode = new Vertex ( "" + inputNode . getName ( ) , GraphLoader . Task ) ; } } outputNode . id = UUID . randomUUID ( ) . toString ( ) ; return outputNode ; }
tr	7	public static int commonTele ( TeamMatch match ) { int one , two , three ; one = two = three = 0 ; for ( Points p : match . getPoints ( ) ) { if ( p instanceof OnePointTele ) { one ++ ; } else if ( p instanceof TwoPointTele ) { two ++ ; } else if ( p instanceof ThreePointTele ) { three ++ ; } } int max = Math . max ( one , Math . max ( two , three ) ) ; return max == three ? 3 : ( max == two ? 2 : ( max == one ? 1 : 0 ) ) ; }
tr	1	private void go ( ) { addHeader ( ) ; for ( int a = 1 ; a < 6 ; a ++ ) { add ( "submission" + a + ".csv" ) ; } export ( ) ; }
tr	7	private void getChildren ( DefaultMutableTreeNode node ) { if ( node . toString ( ) . equals ( "Songs" ) ) { for ( int i = 0 ; i < node . getChildCount ( ) ; ++ i ) { if ( _song . equals ( ( ( DefaultMutableTreeNode ) node . getChildAt ( i ) ) . getUserObject ( ) ) ) { _children . add ( ( DefaultMutableTreeNode ) node . getChildAt ( i ) ) ; } } } else if ( node . toString ( ) . equals ( "Playlists" ) ) { for ( int i = 0 ; i < node . getChildCount ( ) ; ++ i ) { for ( int j = 0 ; j < node . getChildAt ( i ) . getChildCount ( ) ; ++ j ) { if ( _song . equals ( ( Song ) ( ( DefaultMutableTreeNode ) node . getChildAt ( i ) . getChildAt ( j ) ) . getUserObject ( ) ) ) _children . add ( ( DefaultMutableTreeNode ) node . getChildAt ( i ) . getChildAt ( j ) ) ; } } } }
tr	8	@ Override public String cookieLogin ( User user , Map < String , Object > session ) throws ServiceException { User fu = this . findUserByEmail ( user ) ; if ( fu == null ) { logger . info ( "Email is not exist !" ) ; return OtherConstants . EMAIL_NOT_EXIST ; } if ( ! fu . getUserPWD ( ) . equals ( user . getUserPWD ( ) ) ) { logger . info ( "Password is error !" ) ; return OtherConstants . PASSWORD_ERROR ; } String userID = fu . getId ( ) ; try { @ SuppressWarnings ( "rawtypes" ) List list = groupDaoImpl . query ( fu , SqlConstants . GROUP_QUERY_BY_UID ) ; List < Group > groups = new ArrayList < Group > ( ) ; int temp = 0 ; for ( Object object : list ) { Group group = ( Group ) object ; int groupID = Integer . parseInt ( group . getId ( ) ) ; if ( groupID > 0 ) { temp = groupID ; } groups . add ( group ) ; } fu . setGroups ( groups ) ; fu . setAuth ( String . valueOf ( temp ) ) ; } catch ( DBException e ) { logger . error ( OtherConstants . DB_ERROR , e ) ; return OtherConstants . DB_ERROR ; } Money money = new Money ( ) ; money . setUserID ( userID ) ; try { @ SuppressWarnings ( "rawtypes" ) List list = moneyDaoImpl . query ( money , SqlConstants . MONEY_FIND_BY_UID ) ; if ( list != null && list . size ( ) > 0 ) { money = ( Money ) list . get ( 0 ) ; fu . setMoneyValue ( money . getMoneyValue ( ) ) ; } else { fu . setMoneyValue ( 0 ) ; } } catch ( DBException e ) { logger . error ( OtherConstants . DB_ERROR , e ) ; return OtherConstants . DB_ERROR ; } session . put ( OtherConstants . CURRENT_USER , fu ) ; return null ; }
tr	1	@ Override public int hashCode ( ) { int hash = 0 ; hash += ( id != null ? id . hashCode ( ) : 0 ) ; return hash ; }
tr	4	public void addTile ( Vector3d [ ] corners , Color c , boolean isSolid , boolean isConcave ) { Vector < Vector3d > wire1 = new Vector < > ( ) ; Vector < Vector3d > wire2 = new Vector < > ( ) ; float h1 = corners [ 0 ] . z + corners [ 2 ] . z ; float h2 = corners [ 1 ] . z + corners [ 3 ] . z ; if ( h1 < h2 && isConcave || h1 > h2 && ! isConcave ) { wire1 . addElement ( corners [ 0 ] ) ; wire1 . addElement ( corners [ 1 ] ) ; wire1 . addElement ( corners [ 2 ] ) ; wire1 . addElement ( corners [ 0 ] ) ; wire2 . addElement ( corners [ 2 ] ) ; wire2 . addElement ( corners [ 3 ] ) ; wire2 . addElement ( corners [ 0 ] ) ; wire2 . addElement ( corners [ 2 ] ) ; } else { wire1 . addElement ( corners [ 0 ] ) ; wire1 . addElement ( corners [ 1 ] ) ; wire1 . addElement ( corners [ 3 ] ) ; wire1 . addElement ( corners [ 0 ] ) ; wire2 . addElement ( corners [ 2 ] ) ; wire2 . addElement ( corners [ 3 ] ) ; wire2 . addElement ( corners [ 1 ] ) ; wire2 . addElement ( corners [ 2 ] ) ; } addWire ( wire1 , c , isSolid , true ) ; addWire ( wire2 , c , isSolid , true ) ; }
tr	3	public int checkHorizontalLinePieces ( int row , Symbol sym ) { int flag = 0 ; int column = 0 ; while ( column < board . length ) { if ( board [ row ] [ column ] != null && board [ row ] [ column ] . getSym ( ) == sym ) column += 1 ; else { flag = - 1 ; break ; } } return flag ; }
tr	9	@ SuppressWarnings ( "unchecked" ) public static boolean isNotEmpty ( Object obj ) { if ( obj == null ) { return false ; } else if ( obj instanceof Collection ) { if ( ( ( Collection ) obj ) . size ( ) <= 0 ) return false ; } else if ( obj instanceof List ) { if ( ( ( List ) obj ) . size ( ) <= 0 ) return false ; } else if ( obj instanceof Map ) { if ( ( ( Map ) obj ) . size ( ) <= 0 ) return false ; } else if ( obj instanceof Set ) { if ( ( ( Set ) obj ) . size ( ) <= 0 ) return false ; } else if ( obj instanceof Vector ) { if ( ( ( Vector ) obj ) . size ( ) <= 0 ) return false ; } else { if ( obj . toString ( ) . trim ( ) . length ( ) <= 0 || "null" . equals ( obj . toString ( ) . trim ( ) ) ) return false ; } return true ; }
tr	0	public void setE ( float e ) { this . e = e ; }
tr	8	public void start ( ) { if ( applet != null ) { applet . start ( ) ; return ; } if ( gameUpdaterStarted ) return ; Thread t = new Thread ( ) { public void run ( ) { gameUpdater . run ( ) ; try { if ( ! gameUpdater . fatalError ) replace ( gameUpdater . createApplet ( ) ) ; } catch ( ClassNotFoundException e ) { e . printStackTrace ( ) ; } catch ( InstantiationException e ) { e . printStackTrace ( ) ; } catch ( IllegalAccessException e ) { e . printStackTrace ( ) ; } } } ; t . setDaemon ( true ) ; t . start ( ) ; t = new Thread ( ) { public void run ( ) { while ( applet == null ) { repaint ( ) ; try { Thread . sleep ( 10 ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } } } ; t . setDaemon ( true ) ; t . start ( ) ; gameUpdaterStarted = true ; }
tr	8	public static String [ ] splitbyLetter2 ( CharSequence text ) { list . clear ( ) ; int pos = 0 ; int len = text . length ( ) ; boolean first = true ; for ( int i = 0 ; i < len ; i ++ ) { char c = text . charAt ( i ) ; if ( c > 58 ) { if ( first ) { first = false ; buffer [ pos ++ ] = c ; continue ; } list . add ( new String ( buffer , 0 , pos ) ) ; pos = 0 ; buffer [ pos ++ ] = c ; } else if ( c == 32 || c == 10 || c == 47 || c == 13 || c == 9 ) { } else { buffer [ pos ++ ] = c ; } } list . add ( new String ( buffer , 0 , pos ) ) ; return list . toArray ( new String [ list . size ( ) ] ) ; }
tr	9	public void run ( ) { BufferedReader in ; try { in = new BufferedReader ( new InputStreamReader ( socket . getInputStream ( ) ) ) ; } catch ( IOException e ) { System . err . println ( "[ERROR]   Error in creating new BufferedReader" ) ; try { if ( socket != null ) socket . close ( ) ; } catch ( IOException e0 ) { System . err . println ( "[ERROR]   Error in closing socket" ) ; } return ; } while ( socket != null && ! socket . isClosed ( ) && kill == false ) { try { String s = in . readLine ( ) ; System . err . println ( "[DEBUG]   Received: " + s ) ; Map < String , Object > request = JsonParser . stringToMap ( s ) ; Map < String , Object > response = rc . processRequest ( request ) ; System . err . println ( "[DEBUG]   Response: " + response ) ; if ( response == null ) continue ; if ( response . containsKey ( "DCC_SEND_MULTIPLE" ) ) { List < Map < String , Object >> responses = ( List < Map < String , Object >> ) response . get ( "DCC_SEND_MULTIPLE" ) ; for ( Map < String , Object > sub_response : responses ) { send ( socket , sub_response ) ; } } else { send ( socket , response ) ; } } catch ( IOException e ) { System . err . println ( "[ERROR]   Error in communication with client in ConnectionHandler" ) ; try { if ( socket != null ) socket . close ( ) ; } catch ( IOException e0 ) { System . err . println ( "[ERROR]   Error in closing socket" ) ; } return ; } } try { socket . close ( ) ; } catch ( IOException e ) { System . err . println ( "[ERROR]   Error in closing socket" ) ; } }
tr	9	@ SuppressWarnings ( "SimplifiableIfStatement" ) @ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; GitLog gitLog = ( GitLog ) o ; if ( gitPath != null ? ! gitPath . equals ( gitLog . gitPath ) : gitLog . gitPath != null ) return false ; if ( folder != null ? ! folder . equals ( gitLog . folder ) : gitLog . folder != null ) return false ; if ( timeRange != null ? ! timeRange . equals ( gitLog . timeRange ) : gitLog . timeRange != null ) return false ; if ( commandLine != null ? ! commandLine . equals ( gitLog . commandLine ) : gitLog . commandLine != null ) return false ; return externalSubCommands != null ? externalSubCommands . equals ( gitLog . externalSubCommands ) : gitLog . externalSubCommands == null ; }
tr	3	static private final int jjMoveStringLiteralDfa8_0 ( long old0 , long active0 ) { if ( ( ( active0 &= old0 ) ) == 0 ) return jjStartNfa_0 ( 6 , old0 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 7 , active0 ) ; return 8 ; } switch ( curChar ) { case 76 : return jjMoveStringLiteralDfa9_0 ( active0 , 10 ) ; default : break ; } return jjStartNfa_0 ( 7 , active0 ) ; }
tr	1	public static void deletePreviousFile ( String filename , GameStatus gameStatus ) { if ( filename == null ) return ; File deleteFile = new File ( gameStatus . config . getString ( Config . KEY . BASE_COMPUTER_CONFIG_PATH . getKey ( ) ) + filename ) ; deleteFile . delete ( ) ; }
tr	7	public String queryAllOrder ( Order order , Pagination pagination , HttpServletRequest request ) throws ServiceException { if ( pagination == null ) { pagination = new Pagination ( ) ; } Map < String , Object > queryMap = new HashMap < String , Object > ( ) ; queryMap . put ( "order" , order ) ; int count = 0 ; try { count = orderDaoImpl . count ( queryMap , SqlConstants . ORDER_COUNT ) ; } catch ( DBException e ) { logger . error ( OtherConstants . DB_ERROR , e ) ; return OtherConstants . DB_ERROR ; } if ( count == 0 ) { logger . info ( OtherConstants . HAVE_NO_ORDER ) ; return OtherConstants . HAVE_NO_ORDER ; } pagination . setCount ( count ) ; queryMap . put ( OtherConstants . START_ROW , pagination . getStartRow ( ) ) ; queryMap . put ( OtherConstants . END_ROW , pagination . getEndRow ( ) ) ; List < Order > orders = new ArrayList < Order > ( ) ; try { @ SuppressWarnings ( "rawtypes" ) List list = orderDaoImpl . query ( queryMap , SqlConstants . ORDER_QUERY ) ; for ( Object object : list ) { Order o = ( Order ) object ; String userID = o . getUserID ( ) ; User user = ( User ) userDaoImpl . find ( userID , SqlConstants . USER_FIND_BY_ID ) ; if ( user != null ) { o . setLoginName ( user . getLoginName ( ) ) ; } @ SuppressWarnings ( "rawtypes" ) List list2 = detailDaoImpl . query ( o , SqlConstants . DETAIL_QUERY_BY_ORDERID ) ; List < Detail > details = new ArrayList < Detail > ( ) ; for ( Object object2 : list2 ) { Detail detail = ( Detail ) object2 ; Price price = ( Price ) orderingDaoImpl . find ( detail . getPriceID ( ) , SqlConstants . PRICE_FIND_BY_ID ) ; price . setDicName ( detail . getDicName ( ) ) ; detail . setPrice ( price ) ; details . add ( detail ) ; } o . setDetails ( details ) ; orders . add ( o ) ; } } catch ( DBException e ) { logger . error ( OtherConstants . DB_ERROR , e ) ; return OtherConstants . DB_ERROR ; } request . setAttribute ( OtherConstants . CURRENT_ORDER_LIST , orders ) ; request . setAttribute ( OtherConstants . PAGE_INFO , pagination ) ; return null ; }
tr	1	@ Override public void remove ( K key ) { if ( recursive ) { this . rootNode = removeRec ( this . rootNode , key ) ; } else { removeIt ( key ) ; } }
tr	8	private ItemStack createStack ( Objective o , QuestProgress qd ) { Material m = Material . getMaterial ( o . getItemIconId ( ) ) ; if ( m == null || m == Material . AIR ) m = Material . getMaterial ( o . getType ( ) . getItemIcon ( ) ) ; if ( m == null || m == Material . AIR ) m = Material . WRITTEN_BOOK ; ItemStack ostack = new ItemStack ( m ) ; ItemMeta im = player . getServer ( ) . getItemFactory ( ) . getItemMeta ( m ) ; boolean complete = qd . isComplete ( o . getID ( ) ) ; ArrayList < String > lore = new ArrayList < String > ( ) ; String [ ] desc = o . getDescription ( ) ; for ( String s : desc ) lore . add ( s ) ; if ( o . isOptional ( ) ) { if ( desc . length > 0 ) lore . add ( "" ) ; lore . add ( ChatColor . GOLD + "" + ChatColor . ITALIC + "Optional" ) ; } if ( complete ) { String ps = o . getType ( ) . getProgressString ( o . getTarget ( ) , o . getTarget ( ) ) ; im . setDisplayName ( ChatColor . GREEN + o . getName ( ) + " " + ps ) ; lore . add ( ChatColor . YELLOW + "" + ChatColor . ITALIC + "Completed" ) ; } else { String ps = o . getType ( ) . getProgressString ( o . getTarget ( ) , qd . getProgress ( o . getID ( ) ) ) ; im . setDisplayName ( ChatColor . YELLOW + o . getName ( ) + " " + ps ) ; } im . setLore ( lore ) ; ostack . setItemMeta ( im ) ; return ostack ; }
tr	3	private void loadShape ( Node shapeNode ) { NodeList nodeList = shapeNode . getChildNodes ( ) ; for ( int i = 0 ; i < nodeList . getLength ( ) ; i ++ ) { Node node = nodeList . item ( i ) ; XMLUtils . printType ( node ) ; if ( node . getNodeName ( ) . equals ( "GeneralPath" ) ) { shape = new SGeneralPath ( node ) ; } else if ( node . getNodeName ( ) . equals ( "Ellipse" ) ) { shape = new SEllipse2D ( node ) ; } else System . out . println ( "unused node " + node ) ; } }
tr	5	private void pop ( char c ) throws JSONException { if ( this . top <= 0 ) { throw new JSONException ( "Nesting error." ) ; } char m = this . stack [ this . top - 1 ] == null ? a : k ; if ( m != c ) { throw new JSONException ( "Nesting error." ) ; } this . top -= 1 ; this . mode = this . top == 0 ? d : this . stack [ this . top - 1 ] == null ? a : k ; }
tr	3	@ Override public void doAction ( Player player , Grid grid ) throws InvalidActionException { if ( player . getRemainingTurns ( ) <= 0 ) throw new InvalidActionException ( "The player has no turns left!" ) ; Position currentPos = player . getPosition ( ) ; Position newPos = new Position ( currentPos . getxCoordinate ( ) + 1 , currentPos . getyCoordinate ( ) - 1 ) ; if ( ! canMoveToPosition ( player , grid , newPos ) || ! canMoveDiagonal ( grid , newPos ) ) throw new InvalidActionException ( "The player can't move to the desired position!" ) ; player . setPosition ( newPos ) ; player . getLightTrail ( ) . addPosition ( currentPos ) ; player . decrementTurn ( ) ; }
tr	1	public void modificarLabor ( ) { try ( Connection conn = Conexion . obtenerConn ( ) ) { Statement st ; st = conn . createStatement ( ) ; st . executeUpdate ( "UPDATE LABOR SET OBSERVACION ='" + this . observaciones + "' WHERE HORA_INICIO ='" + this . hora_inicio + "'AND FECHA ='" + this . fecha + "'AND CARNET_LABOR ='" + this . carnet + "';" ) ; st . close ( ) ; conn . close ( ) ; } catch ( SQLException ex ) { System . err . println ( ex . getMessage ( ) ) ; } }
tr	1	@ Override public void handleDiscardPhaseCompleted ( Player winningPlayer ) { for ( GameHandler gh : gameHandlers ) { gh . handleDiscardPhaseCompleted ( winningPlayer ) ; } }
tr	2	private Set < Strategy > buildStrategies ( Strategy strategy , int breakpointNumber , int [ ] breakpoints , int [ ] [ ] actionPercentages ) { Set < Strategy > strategies = new HashSet < Strategy > ( ) ; for ( int [ ] actionPercentageSet : actionPercentages ) { Strategy s = new Strategy ( strategy ) ; Tactic nextTactic = new Tactic ( actionPercentageSet ) ; s . putNewTactic ( nextTactic ) ; if ( breakpointNumber < AISettings . DEFAULT_BREAKPOINTS . length - 1 ) { strategies . addAll ( buildStrategies ( s , breakpointNumber + 1 , breakpoints , actionPercentages ) ) ; } else { strategies . add ( s ) ; } } return strategies ; }
tr	0	public int getWidth ( ) { return width ; }
tr	0	public void updateProduct ( Integer ID , String p_name , String p_descrription ) { Product product = new Product ( ID , p_name , p_descrription ) ; product . updateProduct ( ) ; }
tr	9	synchronized Hashtable getProperties ( ) { if ( ( props == null ) && ( getText ( ) != null ) ) { Hashtable props = new Hashtable ( ) ; int off = 0 ; while ( off < getText ( ) . length ) { int len = getText ( ) [ off ++ ] & FF ; if ( ( len == 0 ) || ( off + len > getText ( ) . length ) ) { props . clear ( ) ; break ; } int i = 0 ; for ( ; ( i < len ) && ( getText ( ) [ off + i ] != = ) ; i ++ ) { ; } String name = readUTF ( getText ( ) , off , i ) ; if ( name == null ) { props . clear ( ) ; break ; } if ( i == len ) { props . put ( name , NO_VALUE ) ; } else { byte value [ ] = new byte [ len - ++ i ] ; System . arraycopy ( getText ( ) , off + i , value , 0 , len - i ) ; props . put ( name , value ) ; off += len ; } } this . props = props ; } return props ; }
tr	9	public static BufferedImage crop ( BufferedImage src , int x , int y , int width , int height , BufferedImageOp ... ops ) throws IllegalArgumentException , ImagingOpException { long t = System . currentTimeMillis ( ) ; if ( src == null ) throw new IllegalArgumentException ( "src cannot be null" ) ; if ( x < 0 || y < 0 || width < 0 || height < 0 ) throw new IllegalArgumentException ( "Invalid crop bounds: x [" + x + "]  y [" + y + "]  width [" + width + "] and height [" + height + "] must all be >= 0" ) ; int srcWidth = src . getWidth ( ) ; int srcHeight = src . getHeight ( ) ; if ( ( x + width ) > srcWidth ) throw new IllegalArgumentException ( "Invalid crop bounds: x + width [" + ( x + width ) + "] must be <= src.getWidth() [" + srcWidth + "]" ) ; if ( ( y + height ) > srcHeight ) throw new IllegalArgumentException ( "Invalid crop bounds: y + height [" + ( y + height ) + "] must be <= src.getHeight() [" + srcHeight + "]" ) ; if ( DEBUG ) log ( 0 , "Cropping Image [width=%d  height=%d] to [x=%d  y=%d  width=%d  height=%d]..." , srcWidth , srcHeight , x , y , width , height ) ; BufferedImage result = createOptimalImage ( src , width , height ) ; Graphics g = result . getGraphics ( ) ; g . drawImage ( src , 0 , 0 , width , height , x , y , ( x + width ) , ( y + height ) , null ) ; g . dispose ( ) ; if ( DEBUG ) log ( 0 , "Cropped Image in %d ms" , System . currentTimeMillis ( ) - t ) ; if ( ops != null && ops . length > 0 ) result = apply ( result , ops ) ; return result ; }
tr	5	static int quadraticRoots ( final float a , final float b , final float c , float [ ] zeroes , final int off ) { int ret = off ; float t ; if ( a != 0f ) { final float dis = b * b - 4 * a * c ; if ( dis > 0f ) { final float sqrtDis = ( float ) Math . sqrt ( dis ) ; if ( b >= 0f ) { zeroes [ ret ++ ] = ( 2f * c ) / ( - b - sqrtDis ) ; zeroes [ ret ++ ] = ( - b - sqrtDis ) / ( 2f * a ) ; } else { zeroes [ ret ++ ] = ( - b + sqrtDis ) / ( 2f * a ) ; zeroes [ ret ++ ] = ( 2f * c ) / ( - b + sqrtDis ) ; } } else if ( dis == 0f ) { t = ( - b ) / ( 2f * a ) ; zeroes [ ret ++ ] = t ; } } else { if ( b != 0f ) { t = ( - c ) / b ; zeroes [ ret ++ ] = t ; } } return ret - off ; }
tr	7	public JSONArray ( JSONTokener x ) throws JSONException { this ( ) ; if ( x . nextClean ( ) != [ ) { throw x . syntaxError ( "A JSONArray text must start with '['" ) ; } if ( x . nextClean ( ) != ] ) { x . back ( ) ; for ( ; ; ) { if ( x . nextClean ( ) ==   ) { x . back ( ) ; this . myArrayList . add ( JSONObject . null ) ; } else { x . back ( ) ; this . myArrayList . add ( x . nextValue ( ) ) ; } switch ( x . nextClean ( ) ) { case   : if ( x . nextClean ( ) == ] ) { return ; } x . back ( ) ; break ; case ] : return ; default : throw x . syntaxError ( "Expected a ' ' or ']'" ) ; } } } }
tr	9	@ Override public void set ( long i , Object o ) { if ( o == null ) { if ( ptr != 0 ) { stringLengths . setShort ( i , ( short ) - 1 ) ; } else { if ( isConstant ( ) ) { throw new IllegalAccessError ( "Constant arrays cannot be modified." ) ; } data [ ( int ) i ] = null ; } } else { if ( ! ( o instanceof String ) ) { throw new IllegalArgumentException ( o + " is not a string." ) ; } String s = ( String ) o ; if ( ptr != 0 ) { if ( s . length ( ) > maxStringLength ) { throw new IllegalArgumentException ( "String  " + s + " is too long." ) ; } byte [ ] tmp ; try { tmp = s . getBytes ( CHARSET ) ; } catch ( UnsupportedEncodingException ex ) { return ; } int strLen = tmp . length ; if ( strLen > short . MAX_VALUE ) { throw new IllegalArgumentException ( "String  " + s + " is too long." ) ; } stringLengths . setShort ( i , ( short ) strLen ) ; long offset = sizeof * i * maxStringLength * CHARSET_SIZE ; for ( int j = 0 ; j < strLen ; j ++ ) { Utilities . UNSAFE . putByte ( ptr + offset + sizeof * j , tmp [ j ] ) ; } } else { if ( isConstant ( ) ) { throw new IllegalAccessError ( "Constant arrays cannot be modified." ) ; } data [ ( int ) i ] = s ; } } }
tr	6	@ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; StatementSequenceNode other = ( StatementSequenceNode ) obj ; if ( list == null ) { if ( other . list != null ) return false ; } else if ( ! list . equals ( other . list ) ) return false ; return true ; }
tr	3	public double getDistanceAB ( ArrayList < Object > path ) { ArrayList < Object > nodes ; double distance = 0.0 ; for ( int i = 0 ; i < path . size ( ) - 1 ; i ++ ) { nodes = new ArrayList < Object > ( ) ; nodes . add ( path . get ( i ) ) ; nodes . add ( path . get ( i + 1 ) ) ; for ( Road road : roads ) { if ( road . getNodesAttached ( ) . containsAll ( nodes ) ) { distance += road . getDistance ( ) ; } } } distance = UtilCalc . round ( distance , 2 ) ; return distance ; }
tr	3	public void deleteAtPos ( int position ) { DNode cur = HEADER . next ; int size = 0 ; while ( cur != TRAILER ) { size ++ ; cur = cur . next ; } if ( position > size ) { System . out . println ( "Invalid Position cannot insert" ) ; return ; } int i = 0 ; cur = HEADER . next ; while ( i != position ) { i ++ ; cur = cur . next ; } DNode posprev = cur . prev ; DNode posnext = cur . next ; posprev . next = posnext ; posnext . prev = posprev ; }
tr	5	public boolean isDefined ( ) { return ( this . x1 != null && this . x2 != null && this . y1 != null && this . y2 != null && this . z1 != null && this . z2 != null ) ; }
tr	1	public void setPieceX ( int x ) { if ( ! m_dropping ) { m_pieceX = x ; repaint ( ) ; } }
tr	7	public boolean onTick ( Game game ) { Hero hero = ( Hero ) fHero ; if ( move ( game , hero . getMovement ( ) ) ) return true ; if ( ActionAttack . performAction ( fHero , game ) ) return true ; if ( fAutomaticPickUp ) { if ( ActionPickUp . performAction ( fHero , game ) ) return true ; } if ( fAutomaticDoors ) { if ( ActionDoor . performAction ( fHero , game ) ) return true ; } if ( move ( game ) ) return true ; return false ; }
tr	8	@ Override public void write ( int theByte ) throws java . io . IOException { if ( suspendEncoding ) { this . out . write ( theByte ) ; return ; } if ( encode ) { buffer [ position ++ ] = ( byte ) theByte ; if ( position >= bufferLength ) { this . out . write ( encode3to4 ( b4 , buffer , bufferLength , options ) ) ; lineLength += 4 ; if ( breakLines && lineLength >= MAX_LINE_LENGTH ) { this . out . write ( NEW_LINE ) ; lineLength = 0 ; } position = 0 ; } } else { if ( decodabet [ theByte & 7f ] > WHITE_SPACE_ENC ) { buffer [ position ++ ] = ( byte ) theByte ; if ( position >= bufferLength ) { int len = Base64 . decode4to3 ( buffer , 0 , b4 , 0 , options ) ; out . write ( b4 , 0 , len ) ; position = 0 ; } } else if ( decodabet [ theByte & 7f ] != WHITE_SPACE_ENC ) { throw new java . io . IOException ( "Invalid character in Base64 data." ) ; } } }
tr	7	public String getcontent ( String linestr ) { String line = linestr . substring ( 0 , 2 ) ; switch ( line ) { case "#*" : return "title" ; case "#@" : return "authors" ; case "#t" : return "year" ; case "#c" : return "publication" ; case "#i" : return "index" ; case "#%" : return "citation" ; case "#!" : return "abstract" ; default : return "" ; } }
tr	3	public static void writeIntArray ( String filename , int [ ] arr ) { try { if ( ! new File ( filename ) . exists ( ) ) { Write . to ( filename , "" ) ; } final Path path = Paths . get ( filename ) ; final ByteBuffer buf = ByteBuffer . allocateDirect ( arr . length << 2 ) ; buf . asIntBuffer ( ) . put ( arr ) . flip ( ) ; try ( final WritableByteChannel out = Files . newByteChannel ( path , StandardOpenOption . WRITE , StandardOpenOption . TRUNCATE_EXISTING ) ) { do { out . write ( buf ) ; } while ( buf . hasRemaining ( ) ) ; } } catch ( IOException e ) { e . printStackTrace ( ) ; } }
tr	7	public Object nextValue ( ) throws JSONException { char c = this . nextClean ( ) ; String string ; switch ( c ) { case " : case ' : return this . nextString ( c ) ; case { : this . back ( ) ; return new JSONObject ( this ) ; case [ : this . back ( ) ; return new JSONArray ( this ) ; } StringBuffer sb = new StringBuffer ( ) ; while ( c >=   && " :]}/\\\"[{;=#" . indexOf ( c ) < 0 ) { sb . append ( c ) ; c = this . next ( ) ; } this . back ( ) ; string = sb . toString ( ) . trim ( ) ; if ( "" . equals ( string ) ) { throw this . syntaxError ( "Missing value" ) ; } return JSONObject . stringToValue ( string ) ; }
tr	3	public void setCellScoresMatrix ( ) { int r , c , sc ; char cS1 , cS2 ; ScoredCellElement tmpCell ; for ( r = 0 ; r < m_s1_size ; ++ r ) { for ( c = 0 ; c < m_s1_size ; ++ c ) { cS1 = m_s1 . charAt ( c ) ; cS2 = m_s1 . charAt ( r ) ; tmpCell = ( ScoredCellElement ) m_dpTable . getCell ( c + 1 , r + 1 ) ; if ( r < c + 2 ) { tmpCell . setScoreVal ( m_scoreHash . getScore ( cS1 , cS2 ) ) ; } else { tmpCell . setColor ( Color . BLACK ) ; } } } }
tr	9	private boolean r_postlude ( ) { int among_var ; int v_1 ; replab0 : while ( true ) { v_1 = cursor ; lab1 : do { bra = cursor ; among_var = find_among ( a_0 , 6 ) ; if ( among_var == 0 ) { break lab1 ; } ket = cursor ; switch ( among_var ) { case 0 : break lab1 ; case 1 : slice_from ( "y" ) ; break ; case 2 : slice_from ( "u" ) ; break ; case 3 : slice_from ( "a" ) ; break ; case 4 : slice_from ( "o" ) ; break ; case 5 : slice_from ( "u" ) ; break ; case 6 : if ( cursor >= limit ) { break lab1 ; } cursor ++ ; break ; } continue replab0 ; } while ( false ) ; cursor = v_1 ; break replab0 ; } return true ; }
tr	6	public Curve center ( ) { for ( int j = 0 ; j < nCols ; j ++ ) vec [ j ] = 0 ; for ( int i = 0 ; i < nRows ( ) ; i ++ ) for ( int j = 0 ; j < nCols ( ) ; j ++ ) vec [ j ] += dd [ i ] [ j ] ; for ( int j = 0 ; j < nCols ; j ++ ) vec [ j ] /= nRows ( ) ; for ( int i = 0 ; i < nRows ( ) ; i ++ ) for ( int j = 0 ; j < nCols ( ) ; j ++ ) dd [ i ] [ j ] -= vec [ j ] ; return this ; }
tr	4	public void run ( ) { for ( int i = 0 ; i < 100 ; i ++ ) { try { Thread . sleep ( 10 ) ; } catch ( InterruptedException exception ) { } Integer [ ] snapshot = buffer . snapshot ( ) ; assert snapshot . length > 18 : "Larger trim than expected!: " + snapshot . length ; assert snapshot . length <= 20 : "Buffer is too large: " + snapshot . length ; for ( int j = 0 ; j < snapshot . length ; j ++ ) { if ( snapshot [ j ] == null ) { assert false : "Found uninitialized value in snapshot: " + j + ":\n" + Arrays . toString ( snapshot ) ; } } assert snapshot [ 0 ] < snapshot [ snapshot . length - 1 ] : "Values do not appear to be coming out in order" ; Thread . yield ( ) ; } }
tr	5	@ Override public File createFileObject ( String path ) { if ( path . length ( ) >= 2 && path . charAt ( 1 ) == : && Character . isLetter ( path . charAt ( 0 ) ) ) { if ( path . length ( ) == 2 ) { path += "\\" ; } else if ( path . charAt ( 2 ) != \ ) { path = path . substring ( 0 , 2 ) + "\\" + path . substring ( 2 ) ; } } return super . createFileObject ( path ) ; }
tr	9	@ SuppressWarnings ( "element-type-mismatch" ) public void removePart ( int i ) { if ( mouths . contains ( parts . get ( i ) ) ) { mouths . remove ( parts . get ( i ) ) ; } if ( eyes . contains ( parts . get ( i ) ) ) { eyes . remove ( parts . get ( i ) ) ; } if ( genitals . contains ( parts . get ( i ) ) ) { genitals . remove ( parts . get ( i ) ) ; } if ( legs . contains ( parts . get ( i ) ) ) { legs . remove ( parts . get ( i ) ) ; } if ( fats . contains ( parts . get ( i ) ) ) { fats . remove ( parts . get ( i ) ) ; } if ( brains . contains ( parts . get ( i ) ) ) { brains . remove ( parts . get ( i ) ) ; } if ( stomachs . contains ( parts . get ( i ) ) ) { stomachs . remove ( parts . get ( i ) ) ; } if ( stems . contains ( parts . get ( i ) ) ) { stems . remove ( parts . get ( i ) ) ; } if ( seeds . contains ( parts . get ( i ) ) ) { seeds . remove ( parts . get ( i ) ) ; } if ( leafs . contains ( parts . get ( i ) ) ) { leafs . remove ( parts . get ( i ) ) ; } parts . remove ( i ) ; }
tr	1	private void log ( String message ) { if ( DEBUG ) { System . out . println ( "[" + new java . util . Date ( ) + "]" + message ) ; } }
tr	5	public static void load ( Archive archive ) { Buffer stream = new Buffer ( archive . decompressFile ( "varbit.dat" ) ) ; int cacheSize = stream . getUnsignedLEShort ( ) ; if ( cache == null ) cache = new VarBit [ cacheSize ] ; for ( int j = 0 ; j < cacheSize ; j ++ ) { if ( cache [ j ] == null ) cache [ j ] = new VarBit ( ) ; cache [ j ] . loadDefinition ( stream ) ; if ( cache [ j ] . aBoolean651 ) Varp . cache [ cache [ j ] . configId ] . aBoolean713 = true ; } if ( stream . position != stream . buffer . length ) System . out . println ( "varbit load mismatch" ) ; }
tr	6	public void run ( ) { Message m = Parser . extractRequest ( fromClient ) ; Node child = m . contents . getFirstChild ( ) ; if ( ! child . getLocalName ( ) . equals ( Parser . connectRequest ) ) { return ; } System . out . println ( "Receiving: " + m ) ; String xmlString = Message . responseHeader ( m . id ( ) ) + "<connectResponse id='" + id + "'/></response>" ; Message r = new Message ( xmlString ) ; if ( ! sendMessage ( r ) ) { System . err . println ( "Unable to respond to connect Request from remote Client." ) ; return ; } Server . register ( id , this ) ; while ( ( m = Parser . extractRequest ( fromClient ) ) != null ) { Message response = handler . process ( this , m ) ; if ( ! sendMessage ( response ) ) { break ; } } if ( handler instanceof IShutdownHandler ) { ( ( IShutdownHandler ) handler ) . logout ( Server . getState ( id ) ) ; } Server . unregister ( id ) ; try { fromClient . close ( ) ; toClient . close ( ) ; client . close ( ) ; } catch ( IOException e ) { System . err . println ( "Unable to close connection:" + e . getMessage ( ) ) ; } }
tr	0	public Layer ( float zPosition ) { this . zPosition = zPosition ; }
tr	2	private void parseErrorFromFile ( String filename , Kind ... expectedErrorKind ) { TokenStream stream = null ; try { stream = new TokenStream ( new BufferedReader ( new FileReader ( filename ) ) ) ; } catch ( FileNotFoundException e1 ) { e1 . printStackTrace ( ) ; } Scanner s = new Scanner ( stream ) ; try { s . scan ( ) ; Parser p = new Parser ( stream ) ; p . parse ( ) ; int numErrors = p . errorList . size ( ) ; assertEquals ( expectedErrorKind . length , numErrors ) ; } catch ( LexicalException e ) { System . out . println ( "Lexical error parsing program: " ) ; System . out . println ( filename ) ; System . out . println ( e . toString ( ) ) ; System . out . println ( "---------" ) ; fail ( ) ; } }
tr	1	public ASTNode reduce ( ASTNode term , final IExpressionContext context ) { if ( term instanceof BooleanExpression ) { final BooleanExpression expr = ( BooleanExpression ) term ; ASTNode left = internalReduce ( expr . getLHS ( ) , context ) ; ASTNode right = internalReduce ( expr . getRHS ( ) , context ) ; return new BooleanExpression ( left , right ) ; } return internalReduce ( term , context ) ; }
tr	7	public double rawinterp ( final int jl , final double x ) { final double TINY = 1.0e-99 ; int m , i , ns = 0 ; double y , w , t , hh , h , dd ; double [ ] c = new double [ mm ] ; double [ ] d = new double [ mm ] ; hh = abs ( x - xx [ jl + 0 ] ) ; for ( i = 0 ; i < mm ; i ++ ) { h = abs ( x - xx [ jl + i ] ) ; if ( h == 0.0 ) { dy = 0.0 ; return yy [ jl + i ] ; } else if ( h < hh ) { ns = i ; hh = h ; } c [ i ] = yy [ jl + i ] ; d [ i ] = yy [ jl + i ] + TINY ; } y = yy [ jl + ns -- ] ; for ( m = 1 ; m < mm ; m ++ ) { for ( i = 0 ; i < mm - m ; i ++ ) { w = c [ i + 1 ] - d [ i ] ; h = xx [ jl + i + m ] - x ; t = ( xx [ jl + i ] - x ) * d [ i ] / h ; dd = t - c [ i + 1 ] ; if ( dd == 0.0 ) throw new IllegalArgumentException ( "Error in routine ratint" ) ; dd = w / dd ; d [ i ] = c [ i + 1 ] * dd ; c [ i ] = t * dd ; } y += ( dy = ( 2 * ( ns + 1 ) < ( mm - m ) ? c [ ns + 1 ] : d [ ns -- ] ) ) ; } return y ; }
tr	3	@ Test public void test ( ) { try { ClassBean bean = new ClassOperator ( ) . operClass ( ClassBean . class ) ; System . out . println ( bean . getFeature ( ) ) ; System . out . println ( bean . getName ( ) ) ; } catch ( IllegalArgumentException e ) { e . printStackTrace ( ) ; } catch ( IllegalAccessException e ) { e . printStackTrace ( ) ; } catch ( InstantiationException e ) { e . printStackTrace ( ) ; } }
tr	2	void remove ( ) { sl . size -- ; if ( sl . first == this ) sl . first = next ; else prev . next = next ; if ( sl . last == this ) sl . last = prev ; else next . prev = prev ; }
tr	8	public String execute ( DeleteCalendarObject deleteCalendarObject ) throws SQLException { String answer = "" ; resultSet = queryBuilder . selectFrom ( "Calendars" ) . where ( "CalendarName" , "=" , deleteCalendarObject . getCalendarToDelete ( ) ) . ExecuteQuery ( ) ; resultSet . next ( ) ; String calendarID = resultSet . getString ( "calendarID" ) ; resultSet = queryBuilder . selectFrom ( "Users" ) . where ( "UserName" , "=" , deleteCalendarObject . getuserID ( ) ) . ExecuteQuery ( ) ; resultSet . next ( ) ; int userID = resultSet . getInt ( "userID" ) ; boolean author = false ; boolean imported = true ; resultSet = queryBuilder . selectFrom ( "Calendars" ) . where ( "calendarID" , "=" , calendarID ) . ExecuteQuery ( ) ; if ( resultSet . next ( ) ) { if ( resultSet . getInt ( "imported" ) == 0 ) { imported = false ; } } if ( imported == false ) { resultSet = queryBuilder . selectFrom ( "AutherRights" ) . where ( "CalendarID" , "=" , calendarID ) . ExecuteQuery ( ) ; while ( resultSet . next ( ) ) { if ( resultSet . getInt ( "userID" ) == userID ) { author = true ; } } if ( author ) { resultSet = queryBuilder . selectFrom ( "Events" ) . where ( "CalendarID" , "=" , calendarID ) . ExecuteQuery ( ) ; while ( resultSet . next ( ) ) { String eventID = resultSet . getString ( "eventID" ) ; try { queryBuilder . deleteFrom ( "Notes" ) . where ( "eventID" , "=" , eventID ) ; } catch ( Exception e ) { System . err . print ( e . getStackTrace ( ) ) ; } } queryBuilder . deleteFrom ( dbConfig . getEvents ( ) ) . where ( "CalendarID" , "=" , calendarID ) . Execute ( ) ; queryBuilder . deleteFrom ( "subscription" ) . where ( "CalendarID" , "=" , calendarID ) . Execute ( ) ; queryBuilder . deleteFrom ( "autherrights" ) . where ( "CalendarID" , "=" , calendarID ) . Execute ( ) ; queryBuilder . deleteFrom ( dbConfig . getCalendar ( ) ) . where ( "CalendarID" , "=" , calendarID ) . Execute ( ) ; answer = String . format ( "Calendar " + deleteCalendarObject . getCalendarToDelete ( ) + " has been deleted  along with all associated events and notes." ) ; } else { answer = "You do not have the rights to delete this calendar." ; } } else { answer = "This is an imported calendar and cannot be deleted." ; } return answer ; }
tr	6	public boolean HasClearPath ( ChessTile Start , ChessTile End ) { int ForwardDistance ; int SideDistance ; if ( Start == null || End == null ) { return false ; } ForwardDistance = Math . abs ( End . GetPosition ( ) [ 1 ] - Start . GetPosition ( ) [ 1 ] ) ; SideDistance = Math . abs ( End . GetPosition ( ) [ 0 ] - Start . GetPosition ( ) [ 0 ] ) ; for ( int i = 1 ; i < Math . max ( ForwardDistance , SideDistance ) - 1 ; i ++ ) { int ForwardMin = Math . min ( ForwardDistance , i ) ; int SideMin = Math . min ( SideDistance , i ) ; if ( Start . GetPosition ( ) [ 0 ] > End . GetPosition ( ) [ 0 ] ) { SideMin = - SideMin ; } if ( Start . GetPosition ( ) [ 1 ] > End . GetPosition ( ) [ 1 ] ) { ForwardMin = - ForwardMin ; } if ( Board [ Start . GetPosition ( ) [ 0 ] + SideMin ] [ Start . GetPosition ( ) [ 1 ] + ForwardMin ] . GetHeldPiece ( ) != null ) { return false ; } } return true ; }
tr	6	public static String constructRequestURL ( String url ) { int index = url . indexOf ( "?" ) ; if ( - 1 != index ) { url = url . substring ( 0 , index ) ; } int slashIndex = url . indexOf ( "/" , 8 ) ; String baseURL = url . substring ( 0 , slashIndex ) . toLowerCase ( ) ; int colonIndex = baseURL . indexOf ( ":" , 8 ) ; if ( - 1 != colonIndex ) { if ( baseURL . startsWith ( "http://" ) && baseURL . endsWith ( ":80" ) ) { baseURL = baseURL . substring ( 0 , colonIndex ) ; } else if ( baseURL . startsWith ( "https://" ) && baseURL . endsWith ( ":443" ) ) { baseURL = baseURL . substring ( 0 , colonIndex ) ; } } url = baseURL + url . substring ( slashIndex ) ; return url ; }
tr	0	@ Test public void revers_on_empty_list_should_be_equals_to_itself ( ) { DoubleLinkedList list = new DoubleLinkedList ( ) ; assertEquals ( utils . reverse ( list ) , list ) ; }
tr	8	public static void changeLiveTuning ( ) { if ( kbPanel == null ) { return ; } if ( ( sineCombo . getSelectedIndex ( ) > 0 ) || ( jKeyStrings . getSelectedIndex ( ) > 0 ) ) try { kbPanel . setFrequencies ( tuningSchemes . getPitchShifts ( ( String ) jTunings . getSelectedItem ( ) , 2 , jNotes . getSelectedIndex ( ) , jTuningAdvancedPanel . getRootNote ( ) , jTuningAdvancedPanel . getFrequency ( ) ) , jNotes . getSelectedIndex ( ) , jTuningAdvancedPanel . getRootNote ( ) , jTuningAdvancedPanel . getFrequency ( ) ) ; } catch ( Exception e ) { } int program = jProgram . getSelectedIndex ( ) ; int pitchshift [ ] = { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } ; int rootnote = jNotes . getSelectedIndex ( ) ; try { pitchshift = tuningSchemes . getPitchShifts ( ( String ) jTunings . getSelectedItem ( ) , 2 , rootnote , jTuningAdvancedPanel . getRootNote ( ) , jTuningAdvancedPanel . getFrequency ( ) ) ; } catch ( Exception e ) { displayerror ( e . getMessage ( ) ) ; } kbPanel . setProgram ( program ) ; kbPanel . setPitchShifts ( pitchshift , rootnote ) ; if ( jKeyStrings . getSelectedIndex ( ) > 0 ) { updateKeyStrings ( jKeyStrings . getSelectedIndex ( ) ) ; } if ( ! ( theSequencer == null ) ) { if ( theSequencer . isRunning ( ) ) { long pos = theSequencer . getTickPosition ( ) ; startSequence ( pos ) ; } } }
tr	3	public Polygon getPolygon ( String s_nameCity ) { Polygon polygonToReturn = new Polygon ( ) ; for ( District district : model . getListDistrict ( ) ) { for ( City city : district . getListCity ( ) ) { if ( city . getS_name ( ) . equals ( s_nameCity ) ) { int i_x = district . getI_x ( ) * model . getI_nbHorizontalSquareInDistrict ( ) + city . getI_x ( ) + ( district . getI_y ( ) % 2 ) * model . getI_nbHorizontalSquareInDistrict ( ) / 2 ; int i_y = district . getI_y ( ) * model . getI_nbVerticalSquareInDistrict ( ) + city . getI_y ( ) ; Point point2D = new Point ( i_x , i_y ) ; polygonToReturn . setPoint2D ( point2D ) ; polygonToReturn . setPoint3D ( convert2DTo3D ( point2D ) ) ; return polygonToReturn ; } } } return polygonToReturn ; }
tr	0	public JSONArray put ( int index , double value ) throws JSONException { put ( index , new double ( value ) ) ; return this ; }
tr	8	private int compareHands ( String hand1 , String hand2 ) { int r1 = ( int ) ( hand1 . charAt ( 0 ) ) - 48 , r2 = ( int ) ( hand2 . charAt ( 0 ) ) - 48 ; if ( r1 > r2 ) { return 1 ; } else if ( r2 > r1 ) { return 2 ; } if ( r1 == 9 ) { return ( r2 == 9 ) ? 0 : 1 ; } else if ( r2 == 9 ) { return 2 ; } int hand_length = hand1 . length ( ) - 1 ; for ( int i = 1 ; i <= hand_length ; ++ i ) { if ( Card . getRank ( hand1 . charAt ( i ) ) > Card . getRank ( hand2 . charAt ( i ) ) ) { return 1 ; } else if ( Card . getRank ( hand1 . charAt ( i ) ) < Card . getRank ( hand2 . charAt ( i ) ) ) { return 2 ; } } return 0 ; }
tr	9	private String rec ( String S , String A , String B , int a , int b ) { if ( a == A . length ( ) && b == B . length ( ) ) return "" ; if ( visited [ a ] [ b ] ) return memo [ a ] [ b ] ; String res = null ; int cur = S . length ( ) - ( A . length ( ) - a ) - ( B . length ( ) - b ) ; if ( a < A . length ( ) && matches ( S . charAt ( cur ) , A . charAt ( a ) ) ) { String best = rec ( S , A , B , a + 1 , b ) ; if ( best != null ) { if ( res == null || res . compareTo ( A . charAt ( a ) + best ) > 0 ) res = A . charAt ( a ) + best ; System . out . println ( res ) ; } } if ( b < B . length ( ) && matches ( S . charAt ( cur ) , B . charAt ( b ) ) ) { String best = rec ( S , A , B , a , b + 1 ) ; if ( best != null ) { if ( res == null || res . compareTo ( B . charAt ( b ) + best ) > 0 ) res = B . charAt ( b ) + best ; System . out . println ( res ) ; } } memo [ a ] [ b ] = res ; visited [ a ] [ b ] = true ; return res ; }
tr	1	private JToolBar createToolBar ( ) { JToolBar tb = new JToolBar ( ) ; tb . setFloatable ( false ) ; tb . setRollover ( true ) ; tb . add ( newAction ) ; tb . add ( openAction ) ; tb . add ( saveAction ) ; tb . addSeparator ( ) ; tb . add ( cutAction ) ; tb . add ( copyAction ) ; tb . add ( pasteAction ) ; tb . addSeparator ( ) ; tb . add ( addAction ) ; tb . add ( editAction ) ; tb . add ( delAction ) ; tb . addSeparator ( ) ; tb . add ( findAction ) ; tb . addSeparator ( ) ; tb . add ( keyAction ) ; tb . add ( Box . createHorizontalGlue ( ) ) ; final JTextField searchField = new JTextField ( ) ; searchField . setMinimumSize ( new Dimension ( 120 , 21 ) ) ; searchField . setPreferredSize ( new Dimension ( 120 , 21 ) ) ; searchField . setMaximumSize ( new Dimension ( 120 , 21 ) ) ; final ActionListener searchListener = new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { ZamokView view = getTab ( ) ; if ( view != null ) view . setFilter ( searchField . getText ( ) ) ; } } ; searchField . addActionListener ( searchListener ) ; searchField . getDocument ( ) . addDocumentListener ( new DocumentListener ( ) { public void insertUpdate ( DocumentEvent e ) { searchListener . actionPerformed ( null ) ; } public void removeUpdate ( DocumentEvent e ) { searchListener . actionPerformed ( null ) ; } public void changedUpdate ( DocumentEvent e ) { } } ) ; tb . add ( searchField ) ; tb . addSeparator ( ) ; return tb ; }
tr	1	public void updatePaths ( ) { for ( int s = 1 ; s <= level . maxMobSize ; s ++ ) { pathingGraphs . get ( s - 1 ) . generate ( s , this ) ; } }
tr	1	public void onUnitDestroy ( Unit unit ) { if ( eventListener != null ) { eventListener . onUnitDestroy ( unit ) ; } }
tr	9	@ Override public String execute ( HttpServletRequest request , HttpServletResponse response ) throws Exception { String data ; try { int rpp ; if ( request . getParameter ( "rpp" ) == null ) { rpp = 10 ; } else { rpp = Integer . parseInt ( request . getParameter ( "rpp" ) ) ; } int page ; if ( request . getParameter ( "page" ) == null ) { page = 1 ; } else { page = Integer . parseInt ( request . getParameter ( "page" ) ) ; } ArrayList < FilterBean > alFilter = new ArrayList < > ( ) ; if ( request . getParameter ( "filter" ) != null ) { if ( request . getParameter ( "filteroperator" ) != null ) { if ( request . getParameter ( "filtervalue" ) != null ) { FilterBean oFilterBean = new FilterBean ( ) ; oFilterBean . setFilter ( request . getParameter ( "filter" ) ) ; oFilterBean . setFilterOperator ( request . getParameter ( "filteroperator" ) ) ; oFilterBean . setFilterValue ( request . getParameter ( "filtervalue" ) ) ; oFilterBean . setFilterOrigin ( "user" ) ; alFilter . add ( oFilterBean ) ; } } } if ( request . getParameter ( "systemfilter" ) != null ) { if ( request . getParameter ( "systemfilteroperator" ) != null ) { if ( request . getParameter ( "systemfiltervalue" ) != null ) { FilterBean oFilterBean = new FilterBean ( ) ; oFilterBean . setFilter ( request . getParameter ( "systemfilter" ) ) ; oFilterBean . setFilterOperator ( request . getParameter ( "systemfilteroperator" ) ) ; oFilterBean . setFilterValue ( request . getParameter ( "systemfiltervalue" ) ) ; oFilterBean . setFilterOrigin ( "system" ) ; alFilter . add ( oFilterBean ) ; } } } HashMap < String , String > hmOrder = new HashMap < > ( ) ; if ( request . getParameter ( "order" ) != null ) { if ( request . getParameter ( "ordervalue" ) != null ) { hmOrder . put ( request . getParameter ( "order" ) , request . getParameter ( "ordervalue" ) ) ; } else hmOrder = null ; } else hmOrder = null ; CensoDao oCensoDAO = new CensoDao ( Conexion . getConection ( ) ) ; List < CensoBean > oCensos = oCensoDAO . getPage ( rpp , page , alFilter , hmOrder ) ; GsonBuilder gsonBuilder = new GsonBuilder ( ) ; gsonBuilder . setDateFormat ( "dd/MM/yyyy" ) ; Gson gson = gsonBuilder . create ( ) ; data = gson . toJson ( oCensos ) ; data = "{\"list\":" + data + "}" ; return data ; } catch ( Exception e ) { throw new ServletException ( "CensoGetJson: View Error: " + e . getMessage ( ) ) ; } }
tr	1	public Key lastKey ( ) { if ( tree == null ) throw new NoSuchElementException ( ) ; else return ( Key ) lastKey ( tree ) ; }
tr	6	public void Solve ( ) { int [ ] initialArray = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { initialArray [ i ] = i ; } List < int [ ] > pandigitalNumbers = Enumerate ( initialArray , 0 ) ; long sum = 0 ; int [ ] divisors = new int [ ] { 2 , 3 , 5 , 7 , 11 , 13 , 17 } ; for ( Iterator < int [ ] > it = pandigitalNumbers . iterator ( ) ; it . hasNext ( ) ; ) { int [ ] numberArray = it . next ( ) ; boolean isOk = true ; for ( int i = 0 ; i < divisors . length ; i ++ ) { int divisor = divisors [ i ] ; int numberToDivide = numberArray [ i + 1 ] * 100 + numberArray [ i + 2 ] * 10 + numberArray [ i + 3 ] ; if ( numberToDivide % divisor != 0 ) { isOk = false ; break ; } } if ( isOk ) { StringBuilder stringBuilder = new StringBuilder ( ) ; for ( int i = 0 ; i < numberArray . length ; i ++ ) { stringBuilder . append ( numberArray [ i ] ) ; } System . out . println ( stringBuilder . toString ( ) ) ; sum += long . parseLong ( stringBuilder . toString ( ) ) ; } } System . out . println ( "Result=" + sum ) ; }
