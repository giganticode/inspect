tr	9	public static void startJar ( String file , String arguments ) { if ( arguments != null ) System . out . println ( "The game arguments are: " + arguments ) ; Process p = null ; try { p = Runtime . getRuntime ( ) . exec ( "java -jar \"" + file + "\" " + arguments ) ; } catch ( IOException e1 ) { e1 . printStackTrace ( ) ; return ; } if ( ( Integer ) OptionManager . getValue ( "launcherVisability" ) == Data . LAUNCHVIS_CLOSE ) System . exit ( 0 ) ; if ( ( Integer ) OptionManager . getValue ( "launcherVisability" ) == Data . LAUNCHVIS_REOPEN ) Data . launcherFrame . setVisible ( false ) ; final InputStream err = p . getErrorStream ( ) ; Thread errThread = new Thread ( new Runnable ( ) { @ Override public void run ( ) { try { BufferedReader errReader = new BufferedReader ( new InputStreamReader ( err ) ) ; String line = null ; while ( ( line = errReader . readLine ( ) ) != null ) System . err . println ( line ) ; errReader . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } } , "errThread" ) ; errThread . start ( ) ; InputStream in = p . getInputStream ( ) ; try { BufferedReader txtReader = new BufferedReader ( new InputStreamReader ( in ) ) ; String line = null ; while ( ( line = txtReader . readLine ( ) ) != null ) System . out . println ( "[game] " + line ) ; txtReader . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } while ( true ) if ( ! errThread . isAlive ( ) ) break ; try { in . close ( ) ; err . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }
tr	9	@ Override protected boolean handleEvent ( Event evt ) { if ( super . handleEvent ( evt ) ) { return true ; } if ( state != null ) { switch ( evt . getType ( ) ) { case KEY_PRESSED : state . keyPressed ( evt . getKeyCode ( ) , evt . getKeyChar ( ) ) ; break ; case KEY_RELEASED : state . keyReleased ( evt . getKeyCode ( ) , evt . getKeyChar ( ) ) ; break ; case MOUSE_BTNDOWN : state . mousePressed ( evt . getMouseButton ( ) , evt . getMouseX ( ) , evt . getMouseY ( ) ) ; break ; case MOUSE_BTNUP : state . mouseReleased ( evt . getMouseButton ( ) , evt . getMouseX ( ) , evt . getMouseY ( ) ) ; break ; case MOUSE_CLICKED : state . mouseClicked ( evt . getMouseButton ( ) , evt . getMouseX ( ) , evt . getMouseY ( ) , evt . getMouseClickCount ( ) ) ; break ; case MOUSE_ENTERED : case MOUSE_MOVED : state . mouseMoved ( oldMouseX , oldMouseY , evt . getMouseX ( ) , evt . getMouseY ( ) ) ; break ; case MOUSE_DRAGGED : state . mouseDragged ( oldMouseX , oldMouseY , evt . getMouseX ( ) , evt . getMouseY ( ) ) ; break ; case MOUSE_WHEEL : state . mouseWheelMoved ( evt . getMouseWheelDelta ( ) ) ; break ; default : break ; } } if ( evt . isMouseEvent ( ) ) { oldMouseX = evt . getMouseX ( ) ; oldMouseY = evt . getMouseY ( ) ; } return true ; }
tr	1	private GPSFunctionalityVerfiedActivity getVerifyGPSActvity ( ) { if ( gpsFunctionalityVerfiedActiviy != null ) { gpsFunctionalityVerfiedActiviy = new GPSFunctionalityVerfiedActivity ( clientFactory ) ; } return gpsFunctionalityVerfiedActiviy ; }
tr	0	public void setScaleX ( double scaleX ) { this . scaleX = scaleX ; }
tr	0	public Game ( TurnManager tm ) { this . tm = tm ; seed = ( int ) ( Math . random ( ) * 100 ) ; init ( ) ; }
tr	1	public void print ( Node node ) { if ( node != null ) { System . out . print ( node . value + " " ) ; print ( node . next ) ; } else { System . out . println ( ) ; } }
tr	0	public void addValue ( Object value ) { values_ . add ( value ) ; }
tr	5	@ Override public boolean checkHit ( GameCharacterObject target ) { if ( ! isEnable ( ) ) { return false ; } Point selfP1 = new Point ( getPixcelX ( ) - getWidth ( ) / 2 , getPixcelY ( ) + getHeight ( ) / 2 ) ; Point selfP2 = new Point ( selfP1 . x + getWidth ( ) , selfP1 . y ) ; Point selfP3 = new Point ( selfP1 . x , selfP1 . y - getHeight ( ) ) ; Point targP1 = new Point ( target . getPixcelX ( ) - target . getWidth ( ) / 2 , target . getPixcelY ( ) + target . getHeight ( ) / 2 ) ; Point targP2 = new Point ( targP1 . x + target . getWidth ( ) , targP1 . y ) ; Point targP3 = new Point ( targP1 . x , targP1 . y - target . getHeight ( ) ) ; if ( selfP2 . x >= targP1 . x && selfP1 . x <= targP2 . x ) { if ( selfP3 . y <= targP1 . y && selfP1 . y >= targP3 . y ) { return true ; } } return false ; }
tr	0	public void setIdIsSet ( boolean value ) { __isset_bitfield = EncodingUtils . setBit ( __isset_bitfield , __ID_ISSET_ID , value ) ; }
tr	8	static Line [ ] mergeSegments ( Line [ ] segsOrig ) { int n = segsOrig . length ; Line [ ] segs = new Line [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { segs [ i ] = segsOrig [ i ] . a . compareTo ( segsOrig [ i ] . b ) < 0 ? segsOrig [ i ] : new Line ( segsOrig [ i ] . b , segsOrig [ i ] . a ) ; } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { Line l1 = segs [ i ] ; Line l2 = segs [ j ] ; boolean mergable = approxEquals ( l1 . b . subtract ( l1 . a ) . cross ( l2 . b . subtract ( l2 . a ) ) , 0 ) && intersectsLP ( l1 . a , l1 . b , l2 . a ) && ccw ( l1 . a , l1 . b , l2 . b ) != 2 && ccw ( l2 . a , l2 . b , l1 . b ) != 2 ; if ( mergable ) { segs [ i -- ] = new Line ( Collections . min ( Arrays . asList ( l1 . a , l2 . a ) ) , Collections . max ( Arrays . asList ( l1 . b , l2 . b ) ) ) ; segs [ j ] = segs [ -- n ] ; break ; } } } Line [ ] ret = new Line [ n ] ; System . arraycopy ( segs , 0 , ret , 0 , n ) ; return ret ; }
tr	5	@ Override public final boolean equals ( @ Nullable final Object obj ) { if ( obj instanceof ChessMovement ) { final ChessMovement other = ( ChessMovement ) obj ; return from . equals ( other . from ) && to . equals ( other . to ) && sourcePiece . equals ( other . sourcePiece ) && Objects . equal ( attackedPiece , other . attackedPiece ) && special . equals ( other . special ) ; } return false ; }
tr	9	@ SuppressWarnings ( "RedundantIfStatement" ) @ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; GitClone gitClone = ( GitClone ) o ; if ( localPath != null ? ! localPath . equals ( gitClone . localPath ) : gitClone . localPath != null ) return false ; if ( pathToGit != null ? ! pathToGit . equals ( gitClone . pathToGit ) : gitClone . pathToGit != null ) return false ; if ( repositoryUrl != null ? ! repositoryUrl . equals ( gitClone . repositoryUrl ) : gitClone . repositoryUrl != null ) return false ; return true ; }
tr	9	public static String toJSONString ( Object value ) { if ( value == null ) return "null" ; if ( value instanceof String ) return "\"" + escape ( ( String ) value ) + "\"" ; if ( value instanceof double ) { if ( ( ( double ) value ) . isInfinite ( ) || ( ( double ) value ) . isNaN ( ) ) return "null" ; else return value . toString ( ) ; } if ( value instanceof float ) { if ( ( ( float ) value ) . isInfinite ( ) || ( ( float ) value ) . isNaN ( ) ) return "null" ; else return value . toString ( ) ; } if ( value instanceof Number ) return value . toString ( ) ; if ( value instanceof boolean ) return value . toString ( ) ; if ( ( value instanceof JSONAware ) ) return ( ( JSONAware ) value ) . toJSONString ( ) ; if ( value instanceof Map ) return JSONObject . toJSONString ( ( Map ) value ) ; if ( value instanceof List ) return JSONArray . toJSONString ( ( List ) value ) ; return value . toString ( ) ; }
tr	9	@ SuppressWarnings ( "unchecked" ) protected Object get ( String [ ] parts ) { if ( parts . length == 0 ) { return root ; } if ( ! ( root instanceof Map < ? , ? > ) ) { return null ; } Map < Object , Object > node = ( Map < Object , Object > ) root ; for ( int i = 0 ; i < parts . length ; i ++ ) { String part = parts [ i ] ; Matcher m = indexPattern . matcher ( part ) ; int index = - 1 ; if ( m . matches ( ) ) { part = part . substring ( 0 , part . length ( ) - m . group ( 1 ) . length ( ) ) ; index = Integer . parseInt ( m . group ( 1 ) ) ; } Object o = node . get ( part ) ; if ( o == null ) { return null ; } else if ( i == parts . length - 1 ) { return getIndexOf ( o , index ) ; } try { node = ( Map < Object , Object > ) getIndexOf ( o , index ) ; } catch ( ClassCastException e ) { return null ; } } return null ; }
tr	9	@ Override public void run ( ) throws Exception { try { privileges . load ( "plugins/Privileges/config.yml" ) ; setDefaultGroup ( privileges . getString ( "default_group" ) ) ; setDebug ( privileges . getBoolean ( "debug" ) ) ; privileges . load ( "plugins/Privileges/users.yml" ) ; for ( String player : plugin . getKeys ( privileges , "users" ) ) { addPlayerGroup ( player , privileges . getString ( "users." + player + ".group" ) ) ; for ( String permission : privileges . getStringList ( "users." + player + ".permissions" ) ) { addPlayerPermission ( player , permission . replace ( "-" , "" ) , ! permission . startsWith ( "-" ) ) ; } for ( String world : plugin . getKeys ( privileges , "users." + player + ".worlds" ) ) { for ( String worldpermission : privileges . getStringList ( "users." + player + ".worlds." + world ) ) { addPlayerPermission ( player , world , worldpermission . replace ( "-" , "" ) , ! worldpermission . startsWith ( "-" ) ) ; } } } privileges . load ( "plugins/Privileges/groups.yml" ) ; for ( String group : plugin . getKeys ( privileges , "groups" ) ) { for ( String permission : privileges . getStringList ( "groups." + group + ".permissions" ) ) { addGroupPermission ( group , permission . replace ( "-" , "" ) , ! permission . startsWith ( "-" ) ) ; } for ( String world : plugin . getKeys ( privileges , "groups." + group + ".worlds" ) ) { for ( String worldpermission : privileges . getStringList ( "groups." + group + ".worlds." + world ) ) { addGroupPermission ( group , world , worldpermission . replace ( "-" , "" ) , ! worldpermission . startsWith ( "-" ) ) ; } } for ( String inherit : privileges . getStringList ( "groups." + group + ".inheritance" ) ) { addGroupInheritance ( group , inherit ) ; } } } catch ( Exception e ) { throw e ; } }
tr	7	public static String readExpand ( int hkey , String key , String valueName ) throws RegistryErrorException { if ( key == null ) { throw new NullPointerException ( "Registry key cannot be null" ) ; } if ( valueName == null ) { throw new NullPointerException ( "Valuename cannot be null  because the default value is always a STRING! If you want to read a String use readValue" ) ; } if ( nativeHandler == null ) { throw new RegistryErrorException ( "NativeHandler is not initalized!" ) ; } key = addHkey ( hkey , key ) ; String ret = nativeHandler . extractAnyValue ( key , valueName , false ) ; if ( ret != null && ret . startsWith ( EXPAND_KEY_IDENT ) ) { return ret . substring ( 7 ) ; } else if ( ret != null && ( nativeHandler instanceof RegHandler ) ) { return ret ; } return null ; }
tr	2	private static final long [ ] mk_tokenSet_1 ( ) { long [ ] data = new long [ 260 ] ; data [ 0 ] = - 9224 ; for ( int i = 1 ; i <= 3 ; i ++ ) { data [ i ] = - 1 ; } for ( int i = 64 ; i <= 127 ; i ++ ) { data [ i ] = - 1 ; } return data ; }
tr	3	public void displayWinner ( ArrayList < JavaFestivalPlayer > players , int pointsWon ) { String names = players . get ( 0 ) . getName ( ) ; if ( players . size ( ) > 1 ) { for ( int i = 1 ; i < players . size ( ) ; i ++ ) { if ( i == ( players . size ( ) - 1 ) ) { names = names + " and " + players . get ( i ) . getName ( ) ; } else { names = names + "  " + players . get ( i ) . getName ( ) ; } } JOptionPane . showMessageDialog ( null , "Congrats! Players " + names + " have won this festival" , "End of Festival" , JOptionPane . INFORMATION_MESSAGE ) ; } else { JOptionPane . showMessageDialog ( null , "Congrats! Player " + names + " has won this festival" , "End of Festival" , JOptionPane . INFORMATION_MESSAGE ) ; } }
tr	8	protected void UnZip ( ) throws PrivilegedActionException { String path = ( String ) AccessController . doPrivileged ( new PrivilegedExceptionAction ( ) { public Object run ( ) throws Exception { return ( new StringBuilder ( ) ) . append ( Util . getWorkingDirectory ( ) ) . append ( File . separator ) . toString ( ) ; } final GameUpdater this$0 ; { this$0 = GameUpdater . this ; } } ) ; String szZipFilePath = ( new StringBuilder ( String . valueOf ( path ) ) ) . append ( "bin" ) . append ( File . separator ) . append ( "additional.zip" ) . toString ( ) ; File f = new File ( szZipFilePath ) ; if ( ! f . exists ( ) ) System . out . println ( ( new StringBuilder ( "\nNot found: " ) ) . append ( szZipFilePath ) . toString ( ) ) ; if ( f . isDirectory ( ) ) System . out . println ( ( new StringBuilder ( "\nNot file: " ) ) . append ( szZipFilePath ) . toString ( ) ) ; System . out . println ( "Enter path to extract files: " ) ; String szExtractPath = path ; File f1 = new File ( szExtractPath ) ; if ( ! f1 . exists ( ) ) System . out . println ( ( new StringBuilder ( "\nNot found: " ) ) . append ( szExtractPath ) . toString ( ) ) ; if ( ! f1 . isDirectory ( ) ) System . out . println ( ( new StringBuilder ( "\nNot directory: " ) ) . append ( szExtractPath ) . toString ( ) ) ; Vector zipEntries = new Vector ( ) ; try { teststring = szExtractPath + "/buildcraft" ; File fil = new File ( teststring ) ; del_cat ( fil ) ; teststring = szExtractPath + "/config" ; File fil2 = new File ( teststring ) ; del_cat ( fil2 ) ; teststring = szExtractPath + "/mods" ; File fil3 = new File ( teststring ) ; del_cat ( fil3 ) ; teststring = szExtractPath + "/redpower" ; File fil4 = new File ( teststring ) ; del_cat ( fil4 ) ; teststring = szExtractPath + "/resources" ; File fil5 = new File ( teststring ) ; del_cat ( fil5 ) ; ZipFile zf = new ZipFile ( szZipFilePath ) ; for ( Enumeration en = zf . entries ( ) ; en . hasMoreElements ( ) ; zipEntries . addElement ( ( ZipEntry ) en . nextElement ( ) ) ) ; for ( int i = 0 ; i < zipEntries . size ( ) ; i ++ ) { ZipEntry ze = ( ZipEntry ) zipEntries . elementAt ( i ) ; extractFromZip ( szZipFilePath , szExtractPath , ze . getName ( ) , zf , ze ) ; } zf . close ( ) ; if ( ! f . isDirectory ( ) ) f . delete ( ) ; System . out . println ( "Done!" ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; } }
tr	6	public static void main ( String [ ] args ) { boolean all_right ; all_right = true ; int p0 ; int p1 ; p0 = 3 ; p1 = 2 ; all_right = KawigiEdit_RunTest ( 0 , p0 , true , p1 ) && all_right ; p0 = 6 ; p1 = 6 ; all_right = KawigiEdit_RunTest ( 1 , p0 , true , p1 ) && all_right ; p0 = 10 ; p1 = 8 ; all_right = KawigiEdit_RunTest ( 2 , p0 , true , p1 ) && all_right ; p0 = 1234 ; p1 = 341 ; all_right = KawigiEdit_RunTest ( 3 , p0 , true , p1 ) && all_right ; p0 = 5000 ; p1 = 341 ; all_right = KawigiEdit_RunTest ( 3 , p0 , true , p1 ) && all_right ; if ( all_right ) { System . out . println ( "You're a stud (at least on the example cases)!" ) ; } else { System . out . println ( "Some of the test cases had errors." ) ; } }
tr	5	public static int getAge ( Date f ) { Date today = new Date ( ) ; if ( today . compareTo ( f ) < 0 ) { return - 1 ; } if ( today . get ( YEAR ) == f . get ( YEAR ) ) { return 0 ; } if ( today . get ( MONTH ) > f . get ( MONTH ) ) { return today . get ( YEAR ) - f . get ( YEAR ) ; } if ( today . get ( MONTH ) == f . get ( MONTH ) && today . get ( DAYOFMONTH ) >= f . get ( DAYOFMONTH ) ) { return today . get ( YEAR ) - f . get ( YEAR ) ; } return today . get ( YEAR ) - f . get ( YEAR ) - 1 ; }
tr	4	public graph ( String C , String type , String interval , String r ) throws SQLException { super ( "Bar Chart" ) ; connnect = new sqlConnection ( ) ; sql = new selectQueries ( ) ; sqlInsert = new insertQueries ( ) ; Connection conn = connnect . connect ( ) ; int inte = Integer . parseInt ( interval ) ; ResultSet item = sql . getGraph1 ( conn , type , inte ) ; int i = 0 ; ResultSetMetaData md = item . getMetaData ( ) ; int count = md . getColumnCount ( ) ; String [ ] list = new String [ count ] ; int i1 = 0 ; while ( item . next ( ) ) { list [ i1 ] = item . getString ( "rcm_id" ) ; i1 ++ ; } BarChart chart = new BarChart ( ) ; Object [ ] col = new Object [ ] { Color . red , Color . green , Color . blue , Color . black , Color . pink , Color . yellow , Color . DARK_GRAY } ; for ( int p = 0 ; p < count ; p ++ ) { if ( p == col . length - 1 ) { break ; } try { chart . addBar ( ( Color ) col [ p ] , Integer . parseInt ( list [ p ] ) ) ; } catch ( Exception e ) { System . out . println ( "Exception occured here" ) ; } } getContentPane ( ) . setBackground ( Color . CYAN ) ; getContentPane ( ) . add ( chart ) ; setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; pack ( ) ; setVisible ( true ) ; }
tr	0	public void setCredits ( int credits ) { this . credits = credits ; }
tr	3	public int plusPetiteDistance ( Tir t ) { int petite = 9999 ; Bloc [ ] blocs = this . champ_de_bataille . getEmplacements ( ) ; for ( int i = 0 ; i < blocs . length ; i ++ ) { if ( blocs [ i ] . getEtatBloc ( ) == EtatBloc . PAS_TOUCHE ) { int temp = t . getPosition ( ) . distance ( blocs [ i ] . getPosition ( ) ) ; if ( petite > temp ) petite = temp ; } } return petite ; }
tr	7	@ Override public void run ( ) throws Exception { try { ConfigFile importFile = new ConfigFile ( plugin ) ; ConfigSQL importSQL = new ConfigSQL ( plugin ) ; if ( ! importSQL . checkDatabase ( ) ) { throw new Exception ( "Could not connect to database !" ) ; } for ( String player : importSQL . getAllPlayers ( ) ) { for ( String group : importSQL . getPlayerGroups ( player ) ) { importFile . addPlayerGroup ( player , group ) ; } for ( Entry < String , boolean > permission : importSQL . getPlayerPermissions ( player ) . entrySet ( ) ) { importFile . addPlayerPermission ( player , permission . getKey ( ) , permission . getValue ( ) ) ; } for ( String world : importSQL . getPlayerWorlds ( player ) ) { for ( Entry < String , boolean > permission : importSQL . getPlayerPermissions ( player , world ) . entrySet ( ) ) { importFile . addPlayerPermission ( player , world , permission . getKey ( ) , permission . getValue ( ) ) ; } } } } catch ( Exception e ) { throw e ; } }
tr	7	private void applyForces ( final Iterable < Mass > masses , final Vector4 gravity , final boolean applyWindForces ) { final double deltaTSquared = params . getIntegrationTimeStep ( ) ; final Vector4 windForce = new Vector4 ( ) ; windSimulator . getCurrentWindVector ( windForce ) ; final Vector4 normalizedWindForce = new Vector4 ( windForce ) ; normalizedWindForce . normalizeInPlace ( ) ; final double maxY = params . getYResolution ( ) * 0.98 ; final GridIterator it = ( GridIterator ) masses . iterator ( ) ; while ( it . hasNext ( ) ) { final Mass mass = it . next ( ) ; if ( mass . hasFlags ( Mass . FLAG_FIXED | Mass . FLAG_SELECTED ) ) { continue ; } Vector4 sumForces = new Vector4 ( ) ; for ( Spring s : mass . springs ) { if ( s . m1 == mass ) { sumForces . plusInPlace ( s . force ) ; } else { sumForces . minusInPlace ( s . force ) ; } } if ( applyWindForces ) { final Mass rightNeighbour = it . rightNeighbour ( ) ; final Mass bottomNeighbour = it . bottomNeighbour ( ) ; if ( rightNeighbour != null & bottomNeighbour != null ) { sumForces . plusInPlace ( calculateWindForce ( mass , rightNeighbour , bottomNeighbour , normalizedWindForce , windForce ) ) ; } } sumForces . plusInPlace ( gravity ) ; final Vector4 tmp = new Vector4 ( mass . currentPosition ) ; final Vector4 posDelta = mass . currentPosition . minus ( mass . previousPosition ) ; Vector4 dampening = posDelta . multiply ( params . getSpringDampening ( ) ) ; sumForces . minusInPlace ( dampening ) ; sumForces . multiplyInPlace ( 1.0 / ( mass . mass * deltaTSquared ) ) ; posDelta . plusInPlace ( sumForces ) ; posDelta . clampMagnitudeInPlace ( params . getMaxParticleSpeed ( ) ) ; mass . currentPosition . plusInPlace ( posDelta ) ; if ( mass . currentPosition . y > maxY ) { mass . currentPosition . y = maxY ; } mass . previousPosition = tmp ; } }
tr	6	public void readScaleFactor ( IOTool stream , AudioFrameHeader header ) throws MpegAudioDecodeException { try { if ( allocation != 0 ) { super . readScaleFactor ( stream , header ) ; switch ( channel2_scfsi ) { case 0 : channel2_scalefactor1 = scalefactors [ stream . getBits ( 6 ) ] ; channel2_scalefactor2 = scalefactors [ stream . getBits ( 6 ) ] ; channel2_scalefactor3 = scalefactors [ stream . getBits ( 6 ) ] ; break ; case 1 : channel2_scalefactor1 = channel2_scalefactor2 = scalefactors [ stream . getBits ( 6 ) ] ; channel2_scalefactor3 = scalefactors [ stream . getBits ( 6 ) ] ; break ; case 2 : channel2_scalefactor1 = channel2_scalefactor2 = channel2_scalefactor3 = scalefactors [ stream . getBits ( 6 ) ] ; break ; case 3 : channel2_scalefactor1 = scalefactors [ stream . getBits ( 6 ) ] ; channel2_scalefactor2 = channel2_scalefactor3 = scalefactors [ stream . getBits ( 6 ) ] ; break ; } } } catch ( IOException e ) { throw new MpegAudioDecodeException ( e . getMessage ( ) ) ; } }
tr	5	@ Test public void addingRelativelySimilar ( ) { String [ ] cardData2 = cardData . clone ( ) ; for ( int i = 2 ; i < cardData2 . length ; i ++ ) { cardData2 [ i ] = cardData [ i ] . substring ( cardData2 [ i ] . length ( ) / 2 ) ; } try { register . createCard ( cardData ) ; } catch ( Exception ex ) { fail ( ) ; } try { register . createCard ( cardData2 ) ; fail ( ) ; } catch ( NullInputException ex ) { fail ( ) ; } catch ( AlmostSameCardExistsException ex ) { } catch ( CardAlreadyExistsException ex ) { fail ( ) ; } }
tr	0	public static List < Integer > commonDivisors ( final int a , final int b ) { notZeroCheck ( a ) ; notZeroCheck ( b ) ; return listIntersection ( divisors ( a ) , divisors ( b ) ) ; }
tr	8	private void validateRange ( JsonNode node , List < ErrorMessage > results ) { if ( this . minimum != null ) { String nodeValueAsString = type . getValue ( node ) . toString ( ) ; BigDecimal value = new BigDecimal ( nodeValueAsString ) ; BigDecimal minimum = new BigDecimal ( this . minimum . toString ( ) ) ; if ( exclusiveMinimum && ( value . compareTo ( minimum ) < 1 ) ) { results . add ( new ErrorMessage ( "" , "Value '" + nodeValueAsString + "' must be greater than " + minimum + " when exclusiveMinimum is true" ) ) ; } else if ( value . compareTo ( minimum ) < 0 ) { results . add ( new ErrorMessage ( "" , "Value '" + nodeValueAsString + "' must be greater or equal to " + minimum ) ) ; } } if ( this . maximum != null ) { String nodeValueAsString = type . getValue ( node ) . toString ( ) ; BigDecimal value = new BigDecimal ( nodeValueAsString ) ; BigDecimal maximum = new BigDecimal ( this . maximum . toString ( ) ) ; if ( exclusiveMaximum && value . compareTo ( maximum ) >= 0 ) { results . add ( new ErrorMessage ( "" , "Value '" + nodeValueAsString + "' must be less than " + maximum + " when exclusiveMaximum is true" ) ) ; } else if ( value . compareTo ( maximum ) > 0 ) { results . add ( new ErrorMessage ( "" , "Value '" + nodeValueAsString + "' must be less than or equal to " + maximum ) ) ; } } }
tr	4	public void paintComponent ( Graphics g ) { super . paintComponent ( g ) ; Graphics2D g2 = ( Graphics2D ) g ; List < List < Ship >> shipsCollection = new ArrayList < List < Ship >> ( ) ; for ( ServerPlayer p : players ) shipsCollection . add ( p . getShipsCopy ( ) ) ; updateSizeVariables ( ) ; grid = ( BufferedImage ) ( this . createImage ( this . widthPx , this . heightPx ) ) ; Graphics2D gc = grid . createGraphics ( ) ; drawGrid ( gc ) ; int colorIndex = 0 ; for ( ServerPlayer p : players ) StructurePainter . paintBase ( this , p . getBase ( ) , PLAYER_COLORS [ colorIndex ++ ] ) ; StructurePainter . paintStructures ( this , structures ) ; for ( int i = 0 ; i < players . size ( ) ; i ++ ) ShipPainter . paintShips ( this , shipsCollection . get ( i ) , PLAYER_COLORS [ i ] ) ; for ( ServerPlayer p : players ) ActionPainter . paintResults ( this , p . getLastActionResults ( ) ) ; g2 . drawImage ( grid , null , 0 , 0 ) ; }
tr	0	@ Override public String getName ( ) { return name ; }
tr	3	@ Override public Storeable deserialize ( Table table , String value ) throws ParseException { JsonArray json = ( ( new JsonParser ( ) . parse ( value ) ) ) . getAsJsonArray ( ) ; List < Object > values = new ArrayList < > ( ) ; for ( int i = 0 ; i < json . size ( ) ; ++ i ) { values . add ( json . get ( i ) ) ; } Storeable storeable ; try { storeable = createFor ( table , values ) ; } catch ( IndexOutOfBoundsException e ) { throw new ParseException ( "Invalud number of arguments!" , 0 ) ; } catch ( ColumnFormatException e ) { throw new ParseException ( e . getMessage ( ) , 0 ) ; } return storeable ; }
tr	7	public String toFirstUpperCase ( String title ) { if ( title . length ( ) == 0 ) return "" ; String upperCase = title . substring ( 0 , 1 ) . toUpperCase ( ) ; boolean isTheFirst = false ; if ( title . length ( ) > 1 ) for ( int i = 1 ; i < title . length ( ) ; i ++ ) { if ( title . charAt ( i ) ==   ) { upperCase += title . substring ( i , i + 1 ) ; if ( i + 1 < title . length ( ) && ! title . substring ( i + 1 , i + 2 ) . equals ( " " ) ) isTheFirst = true ; } else { if ( isTheFirst ) { upperCase += title . substring ( i , i + 1 ) . toUpperCase ( ) ; isTheFirst = false ; } else { upperCase += title . substring ( i , i + 1 ) ; } } } System . out . println ( upperCase ) ; return upperCase ; }
tr	7	private void writeFile ( String data , boolean isAppend ) { if ( ! exists ( ) ) { try { createNewFile ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } BufferedWriter bfWriter = null ; try { FileWriter flWriter = null ; if ( isAppend ) { flWriter = new FileWriter ( this , true ) ; } else { flWriter = new FileWriter ( this ) ; } bfWriter = new BufferedWriter ( flWriter ) ; if ( isAppend ) { bfWriter . newLine ( ) ; } bfWriter . write ( data ) ; bfWriter . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } finally { try { if ( bfWriter != null ) bfWriter . close ( ) ; } catch ( IOException ex ) { ex . printStackTrace ( ) ; } } }
tr	5	public void close ( ) { if ( ! saved ) { int choice = JOptionPane . showConfirmDialog ( this , "Modifications have been done. Do you want to save ?" , "Last Warning" , JOptionPane . INFORMATION_MESSAGE , JOptionPane . YES_NO_CANCEL_OPTION ) ; if ( choice == 0 ) { JFileChooser FCdialog = new JFileChooser ( ) ; int opt = FCdialog . showSaveDialog ( this ) ; if ( opt == JFileChooser . APPROVE_OPTION ) { try { BufferedWriter out = new BufferedWriter ( new FileWriter ( FCdialog . getSelectedFile ( ) . getPath ( ) ) ) ; out . write ( this . textPane . getText ( ) ) ; out . close ( ) ; } catch ( Exception e ) { System . out . println ( e . getMessage ( ) ) ; } this . dispose ( ) ; } } else if ( choice == 1 ) { this . dispose ( ) ; } } else this . dispose ( ) ; }
tr	0	public Set < String > getOccupantClasses ( ) { return occupantClassNames ; }
tr	3	private void putNumberInsideBox ( Integer cellValue , int row , int col ) { int centerX = 5 ; int centerY = cellSize - 10 ; int boxX = cellSize + col * cellSize ; int startX = boxX - cellSize ; int boxY = cellSize + row * cellSize ; String strNum = cellValue . toString ( ) ; if ( strNum . equals ( "0" ) ) { strNum = " " ; } if ( strNum . length ( ) > 1 ) { for ( int i = 0 ; i < strNum . length ( ) ; i ++ ) { centerX += 5 ; } } int midX = ( boxX + startX - centerX ) / 2 ; int midY = ( boxY + boxY - centerY ) / 2 ; output . drawString ( strNum , midX , midY ) ; }
tr	1	protected void loadPage ( JEditorPane pane , HyperlinkEvent evt ) { try { pane . setPage ( evt . getURL ( ) ) ; } catch ( IOException e ) { System . err . println ( e . getLocalizedMessage ( ) ) ; } }
tr	4	public static void main ( String [ ] args ) { System . out . println ( "Main menu" ) ; System . out . println ( "1. Add" ) ; System . out . println ( "2. Subtract" ) ; System . out . println ( "3. Multiply" ) ; System . out . println ( "4. Divide" ) ; System . out . print ( "Press 1  2  3 or 4 >>> " ) ; Scanner scan = new Scanner ( System . in ) ; int key = scan . nextInt ( ) ; System . out . print ( "enter first number >>> " ) ; float a = scan . nextFloat ( ) ; System . out . print ( "enter second number >>> " ) ; float b = scan . nextFloat ( ) ; switch ( key ) { case 1 : System . out . println ( "result of " + a + " + " + b + " = " + ( a + b ) ) ; break ; case 2 : System . out . println ( "result of " + a + " - " + b + " = " + ( a - b ) ) ; break ; case 3 : System . out . println ( "result of " + a + " * " + b + " = " + ( a * b ) ) ; break ; case 4 : Zero_Devide zeroDevide = new Zero_Devide ( ) ; zeroDevide . isDevideByZero ( a , b ) ; break ; default : System . out . println ( "Unknown Operator !!!" ) ; } System . out . println ( "Good bye !!!" ) ; }
tr	9	private boolean isSubset ( Object subtree1 , Object subtree2 , Object lo , Object hi ) { if ( subtree1 == subtree2 || subtree1 == null ) return true ; else if ( ! ( subtree1 instanceof Node ) ) { if ( subtree2 == null || ! ( subtree2 instanceof Node ) ) return isSubset ( ( Object [ ] ) subtree1 , ( Object [ ] ) subtree2 , lo , hi ) ; else { Node n2 = ( Node ) subtree2 ; Object elt2 = n2 . element ; if ( ! isSubset ( trim ( subtree1 , lo , elt2 ) , n2 . left , lo , elt2 ) ) return false ; else { Object elt1 = findEquiv ( subtree1 , elt2 ) ; if ( ! equivIsSubset ( elt1 , elt2 ) ) return false ; else return isSubset ( trim ( subtree1 , elt2 , hi ) , n2 . right , elt2 , hi ) ; } } } else if ( subtree2 == null ) return false ; else { Node n1 = ( Node ) subtree1 ; Object elt1 = n1 . element ; if ( ! isSubset ( n1 . left , trim ( subtree2 , lo , elt1 ) , lo , elt1 ) ) return false ; else { Object elt2 = findEquiv ( subtree2 , elt1 ) ; if ( ! equivIsSubset ( elt1 , elt2 ) ) return false ; else return isSubset ( n1 . right , trim ( subtree2 , elt1 , hi ) , elt1 , hi ) ; } } }
tr	4	private void completeCommand ( Command c , Agent a ) { if ( c != null ) { if ( c . cmd . equals ( "Move" ) ) completeMove ( c , a ) ; else if ( c . cmd . equals ( "Pull" ) ) completePull ( c , a , ( Box ) a . getAtField ( ) . neighbors [ c . dir2 . ordinal ( ) ] . object ) ; else if ( c . cmd . equals ( "Push" ) ) completePush ( c , a , ( Box ) a . getAtField ( ) . neighbors [ c . dir1 . ordinal ( ) ] . object ) ; } }
tr	7	public void run ( ) { parser = new CommandParser ( true ) ; parser . setCommandList ( new ApplicationCommandList ( ) ) ; System . out . println ( "WELCOME" ) ; System . out . println ( "READY for Input!" ) ; reader = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String input ; try { while ( ( input = reader . readLine ( ) ) != null ) { if ( input . equals ( "!end" ) ) { break ; } else { if ( input . length ( ) > 0 ) { String query = parser . parse ( input . trim ( ) ) ; if ( query . length ( ) > 1 ) { parser . parse ( query ) ; } } else System . out . println ( "" ) ; } } } catch ( IOException e ) { logger . error ( "reading input lines failed" ) ; } finally { System . out . println ( "BYE" ) ; if ( reader != null ) { try { reader . close ( ) ; } catch ( IOException e ) { logger . error ( "could not close reader" ) ; } } } }
tr	6	public void paintComponent ( Graphics g2 ) { int w = getWidth ( ) ; int h = getHeight ( ) ; if ( ( img == null ) || ( img . getWidth ( null ) != w ) || ( img . getHeight ( null ) != h ) ) { img = createImage ( w , h ) ; Graphics g = img . getGraphics ( ) ; for ( int x = 0 ; x <= w / 524 ; x ++ ) { for ( int y = 0 ; y <= h / 524 ; y ++ ) g . drawImage ( bgImage , x * 524 , y * 524 , null ) ; } if ( ( g instanceof Graphics2D ) ) { Graphics2D gg = ( Graphics2D ) g ; } g . dispose ( ) ; } g2 . drawImage ( img , 0 , 0 , w , h , null ) ; }
tr	7	private void populateData ( ) { String sharedDir = Configuration . getConfig ( Configuration . CONFIG_SHARED_FILESYSTEM_PATH ) ; String cluster = Configuration . getConfig ( Configuration . CONFIG_SGE_CLUSTER ) ; String location = Configuration . getConfig ( Configuration . CONFIG_SGE_ROOT ) ; String spoolDir = Configuration . getConfig ( Configuration . CONFIG_SGE_SPOOL_DIR ) ; String hosts = Configuration . getConfig ( Configuration . CONFIG_SGE_EXEC_HOSTS ) ; String admin = Configuration . getConfig ( Configuration . CONFIG_SGE_ADMIN_USER ) ; if ( cluster == null ) { cluster = "cluster" ; } if ( location == null ) { location = sharedDir + "sge" ; } if ( spoolDir == null ) { spoolDir = location + File . separator + "spool" ; } if ( hosts == null ) { hosts = "" ; } else { hosts = hosts . replaceAll ( " " , "\n" ) ; } if ( admin != null ) { sgeAdminLabel . setVisible ( true ) ; sgeAdminField . setVisible ( true ) ; sgeAdminField . setText ( admin ) ; sgeAdminCheckbox . setSelected ( true ) ; } else { sgeAdminLabel . setVisible ( false ) ; sgeAdminField . setVisible ( false ) ; sgeAdminField . setText ( "" ) ; sgeAdminCheckbox . setSelected ( false ) ; } sgeClusterField . setText ( cluster ) ; sgeLocationField . setText ( location ) ; sgeSpoolDirField . setText ( spoolDir ) ; sgeExecHostsArea . setText ( hosts ) ; int index = hostname . indexOf ( "." ) ; if ( index != - 1 ) { String domainName = hostname . substring ( index ) ; StringBuilder exampleBuilder = new StringBuilder ( ) ; for ( int i = 1 ; i <= 3 ; i ++ ) { exampleBuilder . append ( "   host-" ) ; exampleBuilder . append ( i ) ; exampleBuilder . append ( domainName ) ; exampleBuilder . append ( "\n" ) ; } sgeExecHostsExampleArea . setText ( exampleBuilder . toString ( ) ) ; } else { sgeExecHostsExampleArea . setText ( "   cluster-1.loni.ucla.edu\n   cluster-2.loni.ucla.edu\n   cluster-n.loni.ucla.edu" ) ; } }
tr	8	@ Override protected boolean validate ( JComponent input ) { if ( ! ( input instanceof JFormattedTextField ) ) { return true ; } JFormattedTextField field = JFormattedTextField . class . cast ( input ) ; AbstractFormatter formatter = field . getFormatter ( ) ; if ( formatter == null ) { return true ; } String text = field . getText ( ) ; try { T value = valueClass . cast ( formatter . stringToValue ( text ) ) ; if ( minimum != null && minimum . compareTo ( value ) > 0 ) { return false ; } if ( maximum != null && maximum . compareTo ( value ) < 0 ) { return false ; } return true ; } catch ( ClassCastException e ) { return true ; } catch ( ParseException e ) { return false ; } }
tr	7	private void reflectClassWrapper ( Map < Type , Set < GeneTrait >> genePool , String className , int parameterCount , List < String > parameterTypes , int parametersSet ) throws ClassNotFoundException { if ( parametersSet < parameterCount ) { for ( BreedingClassSetup classSetup : Settings . getSettings ( ) . getClasses ( ) ) { if ( ! rawTypesClassMap . containsKey ( classSetup . className ) ) { if ( parameterTypes . size ( ) >= parametersSet + 1 ) { parameterTypes . remove ( parametersSet ) ; } parameterTypes . add ( parametersSet , classSetup . className ) ; reflectClassWrapper ( genePool , className , parameterCount , parameterTypes , parametersSet + 1 ) ; } } } else { class < ? > clazz = rawTypesClassMap . get ( className ) ; if ( clazz == null ) { clazz = class . forName ( className ) ; } Type classType = Type . getType ( className + ( ( parameterCount == 0 ) ? "" : ( "<" + Tools . implode ( parameterTypes , " " ) + ">" ) ) ) ; reflectClass ( genePool , clazz , className , classType , parameterTypes ) ; } }
tr	4	@ Override protected void paintComponent ( Graphics g ) { Graphics2D g2d = ( Graphics2D ) g ; g2d . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; g2d . setRenderingHint ( RenderingHints . KEY_TEXT_ANTIALIASING , RenderingHints . VALUE_TEXT_ANTIALIAS_ON ) ; g2d . setRenderingHint ( RenderingHints . KEY_INTERPOLATION , RenderingHints . VALUE_INTERPOLATION_BICUBIC ) ; g2d . setColor ( Color . BLACK ) ; g2d . setStroke ( new BasicStroke ( 2 ) ) ; for ( int i = 0 ; i <= World . SIZE ; i ++ ) { Line2D hline = new Line2D . double ( 0 , i * GRID_SIZE , 600 , i * GRID_SIZE ) ; Line2D vline = new Line2D . double ( i * GRID_SIZE , 0 , i * GRID_SIZE , 600 ) ; g2d . draw ( hline ) ; g2d . draw ( vline ) ; } for ( Point fuel : world . getAvailableFuel ( ) ) { int x = fuel . x * GRID_SIZE + GRID_SIZE / 2 - fuelImage . getWidth ( ) / 2 ; int y = fuel . y * GRID_SIZE + GRID_SIZE / 2 - fuelImage . getHeight ( ) / 2 ; g2d . drawImage ( fuelImage , x , y , null ) ; } for ( int i = 1 ; i <= 2 ; i ++ ) { Robot rob ; if ( ( rob = world . getRobot ( i ) ) != null ) rob . draw ( g2d , getTimeRatio ( ) ) ; } }
tr	6	public int [ ] plusOne ( int [ ] digits ) { int carry = 1 ; if ( digits == null || digits . length == 0 ) { return digits ; } for ( int i = digits . length - 1 ; i >= 0 ; i -- ) { int sum = digits [ i ] + carry ; digits [ i ] = sum % 10 ; carry = sum / 10 ; if ( carry == 0 ) { break ; } } int [ ] result = null ; if ( carry > 0 ) { result = new int [ digits . length + 1 ] ; result [ 0 ] = carry ; for ( int i = 1 ; i <= digits . length ; i ++ ) { result [ i ] = digits [ i - 1 ] ; } } else { result = digits ; } return result ; }
tr	9	public void saveTraining ( String fileDict , String fileNgrams , String fileDMC , String fileHMM , String fileVLMC , boolean clear ) { if ( fileDict != null ) { trainDict ( ) ; dict . save ( fileDict ) ; if ( clear ) { dict = null ; dictTrained = false ; } } if ( fileNgrams != null ) { trainNgram ( ) ; ngrams . save ( fileNgrams ) ; if ( clear ) { ngrams = null ; ngramTrained = false ; } } if ( fileDMC != null ) { trainDMC ( ) ; dmc . save ( fileDMC ) ; if ( clear ) { dmc = null ; ngramTrained = false ; } } if ( fileHMM != null ) { trainHMM ( ) ; hmm . save ( fileHMM ) ; if ( clear ) { hmm = null ; hmmTrained = false ; } trainHMMEnd ( ) ; hmmEnd . save ( fileHMM + ".end" ) ; trainCleanHMMEnd ( ) ; hmmEnd . save ( fileHMM + ".clean.end" ) ; trainReestimatedHMMEnd ( ) ; hmmEnd . save ( fileHMM + ".reestimated.end" ) ; } if ( fileVLMC != null ) { trainVLMC ( ) ; vlmc . save ( fileVLMC ) ; if ( clear ) { vlmc = null ; vlmcTrained = false ; } } }
tr	7	private JSONWriter append ( String string ) throws JSONException { if ( string == null ) { throw new JSONException ( "Null pointer" ) ; } if ( this . mode == o || this . mode == a ) { try { if ( this . , && this . mode == a ) { this . writer . write (   ) ; } this . writer . write ( string ) ; } catch ( IOException e ) { throw new JSONException ( e ) ; } if ( this . mode == o ) { this . mode = k ; } this . , = true ; return this ; } throw new JSONException ( "Value out of sequence." ) ; }
tr	4	public void utag ( ) { if ( ParseCheckerTools . checkDate ( datumT . getText ( ) ) != null ) { meddelandeL . setText ( ParseCheckerTools . checkDate ( datumT . getText ( ) ) ) ; return ; } if ( ParseCheckerTools . checkDouble ( beloppT . getText ( ) ) != null ) { meddelandeL . setText ( ParseCheckerTools . checkDouble ( beloppT . getText ( ) ) ) ; return ; } if ( ! kalkyl . isPostName ( benomningT . getText ( ) ) ) { meddelandeL . setText ( "Du m\u00E5ste ange korrekt gruppnamn." ) ; return ; } String post = benomningT . getText ( ) ; double value = ParseUtil . parseDouble ( beloppT . getText ( ) ) ; Calendar date = CalendarUtil . parseString ( datumT . getText ( ) ) ; kalkyl . utag ( post , value , date , kommentarT . getText ( ) ) ; if ( adjustValueR . isSelected ( ) ) { kalkyl . adjustValue ( post , - 1 * value , date ) ; } meddelandeL . setText ( "Utag sparat." ) ; this . setVisible ( false ) ; }
tr	9	public final static byte [ ] decodeFast ( byte [ ] sArr ) { int sLen = sArr . length ; if ( sLen == 0 ) return new byte [ 0 ] ; int sIx = 0 , eIx = sLen - 1 ; while ( sIx < eIx && IA [ sArr [ sIx ] & ff ] < 0 ) sIx ++ ; while ( eIx > 0 && IA [ sArr [ eIx ] & ff ] < 0 ) eIx -- ; int pad = sArr [ eIx ] == = ? ( sArr [ eIx - 1 ] == = ? 2 : 1 ) : 0 ; int cCnt = eIx - sIx + 1 ; int sepCnt = sLen > 76 ? ( sArr [ 76 ] == '' ? cCnt / 78 : 0 ) << 1 : 0 ; int len = ( ( cCnt - sepCnt ) * 6 >> 3 ) - pad ; byte [ ] dArr = new byte [ len ] ; int d = 0 ; for ( int cc = 0 , eLen = ( len / 3 ) * 3 ; d < eLen ; ) { int i = IA [ sArr [ sIx ++ ] ] << 18 | IA [ sArr [ sIx ++ ] ] << 12 | IA [ sArr [ sIx ++ ] ] << 6 | IA [ sArr [ sIx ++ ] ] ; dArr [ d ++ ] = ( byte ) ( i >> 16 ) ; dArr [ d ++ ] = ( byte ) ( i >> 8 ) ; dArr [ d ++ ] = ( byte ) i ; if ( sepCnt > 0 && ++ cc == 19 ) { sIx += 2 ; cc = 0 ; } } if ( d < len ) { int i = 0 ; for ( int j = 0 ; sIx <= eIx - pad ; j ++ ) i |= IA [ sArr [ sIx ++ ] ] << ( 18 - j * 6 ) ; for ( int r = 16 ; d < len ; r -= 8 ) dArr [ d ++ ] = ( byte ) ( i >> r ) ; } return dArr ; }
tr	2	public static ArrayList < B_A_horas > consultarLabores ( String carnet ) { ArrayList < B_A_horas > labores = new ArrayList < > ( ) ; try ( Connection conn = Conexion . obtenerConn ( ) ) { Statement st ; st = conn . createStatement ( ) ; ResultSet rs = st . executeQuery ( "SELECT * FROM LABOR WHERE CARNET_LABOR = '" + String . valueOf ( carnet ) + "';" ) ; while ( rs . next ( ) ) { Hora hInicio = new Hora ( rs . getString ( 1 ) ) ; Hora hFin = new Hora ( rs . getString ( 2 ) ) ; B_A_horas labor = new B_A_horas ( carnet , hFin , hInicio , rs . getString ( 4 ) , rs . getString ( 3 ) , rs . getDouble ( 6 ) ) ; labores . add ( labor ) ; } rs . close ( ) ; conn . close ( ) ; } catch ( SQLException ex ) { System . err . println ( ex . getMessage ( ) ) ; } return labores ; }
tr	6	public ListNode rotateRight ( ListNode head , int n ) { if ( head == null || head . next == null || n == 0 ) { return head ; } ListNode tail = head ; int len = 1 ; while ( tail . next != null ) { len ++ ; tail = tail . next ; } int shift = n % len ; if ( shift == 0 ) { return head ; } ListNode p = head ; int i = 1 ; while ( i < len - shift ) { p = p . next ; i ++ ; } tail . next = head ; head = p . next ; p . next = null ; return head ; }
tr	4	public void removeAll ( final String name ) { modified = true ; if ( name != null ) { for ( int i = 0 ; i < fields . size ( ) ; i ++ ) { final DataField field = fields . get ( i ) ; if ( ( field . name != null ) && field . name . equals ( name ) ) { fields . remove ( i -- ) ; } } } }
tr	3	public Tileset load ( TilesetInfo inf ) { Tileset rv = new Tileset ( inf ) ; rv . sources . add ( inf ) ; File fh = new File ( TILESET_DIR + inf . file ) ; try { BufferedImage tilesetImg = ImageIO . read ( fh ) ; int x = inf . margin ; int y = inf . margin ; int tilesX = ( inf . width - inf . margin ) / ( inf . tilewidth + inf . spacing ) ; int tilesY = ( inf . height - inf . margin ) / ( inf . tileheight + inf . spacing ) ; int id = inf . firstid ; ImageResource tile ; for ( int j = 0 ; j < tilesY ; j ++ ) { x = inf . margin ; for ( int i = 0 ; i < tilesX ; i ++ ) { tile = new ImageResource ( tilesetImg . getSubimage ( x , y , inf . tilewidth , inf . tileheight ) ) ; rv . add ( tile , id ++ ) ; x += inf . tilewidth + inf . spacing ; } y += inf . tileheight + inf . spacing ; } } catch ( IOException e ) { Err . e ( e , "TilesetLoader.load: Failed to read from file '%s'." , inf . file ) ; } return rv ; }
tr	2	public void updateValues ( ) { speed += acceleration ; speed *= dampingFactor ; iconCoordinateY += speed ; if ( iconCoordinateY < 0 ) { speed = - speed ; } if ( ( getHeight ( ) - icon . getHeight ( null ) ) < iconCoordinateY ) { speed = - speed ; } }
tr	3	public void actionPerformed ( ActionEvent e ) { if ( noOfTestClients == 1 ) { TestClient newTC = new TestClient ( serverWindow . getWMServer ( ) . getPort ( ) ) ; newTC . start ( ) ; serverWindow . updateNoOfTestClients ( ++ countTestClients ) ; testClients . add ( newTC ) ; } else { try { noOfTestClients = Integer . valueOf ( popup . getInput ( ) . getText ( ) ) ; } catch ( NumberFormatException nfe ) { SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { popup . getInput ( ) . setText ( "100" ) ; } } ) ; } SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { popup . dispose ( ) ; } } ) ; TestClient [ ] dummy = new TestClient [ noOfTestClients ] ; for ( int i = 0 ; i < dummy . length ; i ++ ) { dummy [ i ] = new TestClient ( serverWindow . getWMServer ( ) . getPort ( ) ) ; dummy [ i ] . start ( ) ; serverWindow . updateNoOfTestClients ( ++ countTestClients ) ; testClients . add ( dummy [ i ] ) ; } SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { serverWindow . setEnabled ( true ) ; } } ) ; } }
tr	6	public static int getUTF8 ( byte [ ] str , int start , MutableInteger ch ) { int c , n , i , bytes ; c = ( ( int ) str [ start ] ) & FF ; if ( ( c & E0 ) == C0 ) { n = c & 31 ; bytes = 2 ; } else if ( ( c & F0 ) == E0 ) { n = c & 15 ; bytes = 3 ; } else if ( ( c & F8 ) == F0 ) { n = c & 7 ; bytes = 4 ; } else if ( ( c & FC ) == F8 ) { n = c & 3 ; bytes = 5 ; } else if ( ( c & FE ) == FC ) { n = c & 1 ; bytes = 6 ; } else { ch . value = c ; return 0 ; } for ( i = 1 ; i < bytes ; ++ i ) { c = ( ( int ) str [ start + i ] ) & FF ; n = ( n << 6 ) | ( c & 3F ) ; } ch . value = n ; return bytes - 1 ; }
tr	5	public void update ( ) { totalTime ++ ; if ( totalTime > 200 && ! ( component . getScreen ( ) instanceof MainMenu ) ) setScreen ( new MainMenu ( component , this , input ) ) ; boolean switchScreen = false ; if ( logoTransparancy < 1.0f ) { logoTransparancy += ( float ) RTSComponent . MS_PER_TICK / 2000 ; } else { logoTransparancy = 1.0f ; switchScreen = true ; } if ( switchScreen ) { if ( ! ( component . getScreen ( ) instanceof MainMenu ) ) setScreen ( new MainMenu ( component , this , input ) ) ; } }
tr	0	public Creditos ( ) { JOptionPane . showMessageDialog ( null , message , "About..." , JOptionPane . INFORMATION_MESSAGE ) ; }
tr	7	void refreshExcludedObstacles ( List allObstacles ) { excludedObstacles . clear ( ) ; for ( int i = 0 ; i < allObstacles . size ( ) ; i ++ ) { Obstacle o = ( Obstacle ) allObstacles . get ( i ) ; o . exclude = false ; if ( o . contains ( start ) ) { if ( o . containsProper ( start ) ) o . exclude = true ; else { } } if ( o . contains ( end ) ) { if ( o . containsProper ( end ) ) o . exclude = true ; else { } } if ( o . exclude && ! excludedObstacles . contains ( o ) ) excludedObstacles . add ( o ) ; } }
tr	1	public T createResponse ( int source , long timestamp ) { try { class < T > cl = getResponseType ( ) ; return cl . getConstructor ( Integer . TYPE , long . TYPE ) . newInstance ( source , timestamp ) ; } catch ( Exception e ) { return null ; } }
tr	6	public String perform ( HttpServletRequest request ) { List < String > errors = new ArrayList < String > ( ) ; request . setAttribute ( "errors" , errors ) ; try { ChangePwdForm form = formBeanFactory . create ( request ) ; if ( ! form . isPresent ( ) ) { return "e_change-pwd.jsp" ; } errors . addAll ( form . getValidationErrors ( ) ) ; if ( errors . size ( ) != 0 ) { return "e_change-pwd.jsp" ; } EmployeeBean employee = ( EmployeeBean ) request . getSession ( ) . getAttribute ( "employee" ) ; Transaction . begin ( ) ; employeeDAO . changePassword ( employee . getUsername ( ) , form . getNewPassword ( ) ) ; request . setAttribute ( "message" , "Password changed for " + employee . getUsername ( ) ) ; Transaction . commit ( ) ; return "e_success.jsp" ; } catch ( RollbackException e ) { errors . add ( e . toString ( ) ) ; return "e_change-pwd.jsp" ; } catch ( FormBeanException e ) { errors . add ( e . toString ( ) ) ; return "e_change-pwd.jsp" ; } catch ( Exception e ) { errors . add ( e . getMessage ( ) ) ; return "e_change-pwd.jsp" ; } finally { if ( Transaction . isActive ( ) ) Transaction . rollback ( ) ; } }
tr	5	private void analyze ( ) { double minPrice = double . POSITIVE_INFINITY ; for ( int i = 0 ; i < pricings . size ( ) ; i ++ ) { if ( pricings . get ( i ) . getType ( ) . equalsIgnoreCase ( "Base" ) ) bases . add ( i ) ; else if ( pricings . get ( i ) . getType ( ) . equalsIgnoreCase ( "Reward" ) ) rewards . add ( i ) ; else penalties . add ( i ) ; if ( minPrice > pricings . get ( i ) . getCurrentPrice ( ) ) { minPrice = pricings . get ( i ) . getCurrentPrice ( ) ; indexOfCheapest . clear ( ) ; indexOfCheapest . add ( i ) ; } else if ( minPrice == pricings . get ( i ) . getCurrentPrice ( ) ) { indexOfCheapest . add ( i ) ; } } }
tr	4	public static void registerToRmi ( ) { try { NameNodeSlaveImpl slave = new NameNodeSlaveImpl ( ) ; String local_Ipaddress = InetAddress . getLocalHost ( ) . getHostAddress ( ) ; String slaveName = SystemConstants . getConfig ( SystemConstants . NAMENODE_SLAVE_SERVICE ) ; String name = slaveName + "_" + getIdentifier ( ) ; String bindName = "rmi://" + local_Ipaddress + ":" + portNumber + "/" + name ; System . out . println ( "Registering NameNodeSlave as : " + bindName ) ; Naming . rebind ( bindName , slave ) ; System . out . println ( "NameNodeSlaveImpl: Ready..." ) ; } catch ( RemoteException e ) { System . out . println ( "Error while accessing the remote object check on the RMI." ) ; System . exit ( 0 ) ; } catch ( UnknownHostException e ) { System . out . println ( "Error while accessing the RMI  please retry" ) ; System . exit ( 0 ) ; } catch ( MalformedURLException e ) { System . out . println ( "Error while binding the slave  please retry." ) ; System . exit ( 0 ) ; } catch ( AccessControlException e ) { System . out . println ( "Error with the Access control  check the policy." ) ; System . exit ( 0 ) ; } }
tr	7	private void createFiles ( boolean test , HashMap < String , PrintToFile > filesMap , String cat ) { try { BufferedReader input = new BufferedReader ( new FileReader ( Classify . dataPath + "/rawData/train" + cat + ".csv" ) ) ; String line ; line = input . readLine ( ) ; HashMap < String , ContractorHolder > contractors = new HashMap < String , ContractorHolder > ( ) ; while ( ( line = input . readLine ( ) ) != null ) { String [ ] tmpAr = line . split ( "\" \"" ) ; for ( int i = 0 ; i < tmpAr . length ; i ++ ) { tmpAr [ i ] = tmpAr [ i ] . replaceAll ( "\"" , "" ) ; } String contractor = tmpAr [ 2 ] . trim ( ) ; ContractorHolder contractorHolder = contractors . get ( contractor ) ; if ( contractorHolder == null ) { contractorHolder = new ContractorHolder ( ) ; contractors . put ( contractor , contractorHolder ) ; } String jobType = tmpAr [ 0 ] . trim ( ) ; String opening = tmpAr [ 1 ] . trim ( ) ; String client = tmpAr [ 30 ] . trim ( ) ; ClientHolder curClientHolder = clientHistory . get ( client ) ; if ( curClientHolder == null ) { curClientHolder = new ClientHolder ( ) ; clientHistory . put ( client , curClientHolder ) ; } createInstance ( filesMap . get ( ( test ? "test" : "train" ) + jobType ) , tmpAr , contractorHolder , curClientHolder , contractor ) ; if ( test ) filesMap . get ( "testHolder" + jobType ) . writeToFile ( opening + " " + contractor ) ; } } catch ( IOException e ) { e . printStackTrace ( ) ; } }
tr	5	private static ArrayList < CoordenadasHomogeneas > criarMesh2 ( ArrayList < CoordenadasHomogeneas > listCoord , ArrayList < CoordenadasHomogeneas > listaSPCurvaParcial ) { for ( CoordenadasHomogeneas semiPonto : listaSPCurvaParcial ) { listCoord . add ( new CoordenadasNorm ( semiPonto . getXD ( ) , semiPonto . getYD ( ) , 1.0 ) ) ; } double [ ] [ ] m = new double [ 4 ] [ 3 ] ; Matrix matrizGeo = new Matrix ( m ) ; double [ ] f0 = new double [ 3 ] ; double [ ] deltaF0 = new double [ 3 ] ; double [ ] delta2F0 = new double [ 3 ] ; double [ ] delta3F0 = new double [ 3 ] ; FabricaMatriz ma = new FabricaMatriz ( ) ; Matrix gbs = ma . matrizGBS ( ) ; ArrayList < CoordenadasHomogeneas > ptsCurva = new ArrayList < CoordenadasHomogeneas > ( ) ; for ( int i = 0 ; i < listCoord . size ( ) - 3 ; i ++ ) { for ( int j = 0 ; j < matrizGeo . getRowDimension ( ) ; j ++ ) { matrizGeo . set ( j , 0 , listCoord . get ( j + i ) . getXD ( ) ) ; matrizGeo . set ( j , 1 , listCoord . get ( j + i ) . getYD ( ) ) ; matrizGeo . set ( j , 2 , listCoord . get ( j + i ) . getZD ( ) ) ; } Matrix coef = gbs . times ( matrizGeo ) ; double delta = ( 1.0 / DIVISOES ) ; for ( int k = 0 ; k < 3 ; k ++ ) { f0 [ k ] = coef . get ( 3 , k ) ; deltaF0 [ k ] = coef . get ( 0 , k ) * ( Math . pow ( delta , 3 ) ) + coef . get ( 1 , k ) * ( Math . pow ( delta , 2 ) ) + coef . get ( 2 , k ) * delta ; delta2F0 [ k ] = 6 * coef . get ( 0 , k ) * ( Math . pow ( delta , 3 ) ) + 2 * coef . get ( 1 , k ) * ( Math . pow ( delta , 2 ) ) ; delta3F0 [ k ] = 6 * coef . get ( 0 , k ) * ( Math . pow ( delta , 3 ) ) ; } CoordenadasHomogeneas p = listCoord . get ( i ) ; ArrayList < CoordenadasHomogeneas > ptsSegCurva = forwardDiferencies ( p , f0 , deltaF0 , delta2F0 , delta3F0 ) ; for ( CoordenadasHomogeneas c : ptsSegCurva ) { ptsCurva . add ( c ) ; } } return ptsCurva ; }
tr	9	public void actionPerformed ( ActionEvent ae ) { if ( ae . getSource ( ) == jRegisterPanel . getCancelButton ( ) ) { setVisible ( false ) ; jLoginFrame . setVisible ( true ) ; dispose ( ) ; } else if ( ae . getSource ( ) == jRegisterPanel . getRegisterButton ( ) ) { String szEmail = jRegisterPanel . getEmailField ( ) ; String szUsername = jRegisterPanel . getUsernameField ( ) ; String szPasscode = jRegisterPanel . getPasscodeField ( ) ; String szAnswer = jRegisterPanel . getSecurityAnswerField ( ) ; String szQuestion = jRegisterPanel . getSecurityQuestionField ( ) ; if ( ! ( szEmail . isEmpty ( ) || szUsername . isEmpty ( ) || szPasscode . isEmpty ( ) || szAnswer . isEmpty ( ) || szQuestion . isEmpty ( ) ) ) { try { if ( ! ub . register ( szUsername , szPasscode , szEmail , szQuestion , szAnswer ) ) JOptionPane . showMessageDialog ( null , "Account: " + szUsername + " already exists." , "Duplicate Username" , JOptionPane . INFORMATION_MESSAGE ) ; else { JOptionPane . showMessageDialog ( null , "Account: " + szUsername + " created successfully!" ) ; setVisible ( false ) ; jLoginFrame . setVisible ( true ) ; dispose ( ) ; } } catch ( IOException ioe ) { JOptionPane . showMessageDialog ( null , ioe . getMessage ( ) ) ; } } else JOptionPane . showMessageDialog ( null , "Registration fields can not be empty" ) ; } }
tr	4	private void lazyCopyElements ( ) { if ( datanew != null && min < data . length ) { Node < K , V > node = data [ min ] ; min ++ ; Node < K , V > p = node ; while ( p != null ) { Node < K , V > nexNode = p . next ; p . next = null ; insert ( p ) ; p = nexNode ; } data [ min - 1 ] = null ; } if ( min == data . length ) { data = datanew ; datanew = null ; min = 0 ; } }
tr	9	public static < K , T > Map < K , T > runIdempotentJobsWithRetries ( ExecutorService es , Map < K , ? extends Callable < T >> tasks , final int maxRounds , final IJobListener < K , T > jobListener ) { Map < K , T > out = new HashMap < K , T > ( ) ; Set < K > remainingTasks = new HashSet < K > ( tasks . keySet ( ) ) ; long round = 0 ; while ( remainingTasks . size ( ) > 0 && round ++ < maxRounds ) { List < K > keys = new LinkedList < K > ( remainingTasks ) ; Collections . shuffle ( keys ) ; Map < K , Future < T >> futures = new HashMap < K , Future < T >> ( ) ; for ( final K k : keys ) { final Callable < T > task = tasks . get ( k ) ; futures . put ( k , es . submit ( new Callable < T > ( ) { @ Override public T call ( ) throws Exception { try { T result = task . call ( ) ; if ( jobListener != null ) { jobListener . jobDone ( k , result ) ; } return result ; } catch ( Exception e ) { if ( jobListener != null ) { jobListener . jobException ( k , e ) ; } throw e ; } } } ) ) ; } Set < K > done = new HashSet < K > ( ) ; for ( K k : futures . keySet ( ) ) { try { T result = futures . get ( k ) . get ( ) ; out . put ( k , result ) ; done . add ( k ) ; } catch ( Exception e ) { logger . warnf ( "exception running %s: %s" , k , e ) ; e . printStackTrace ( ) ; } } for ( K d : done ) { remainingTasks . remove ( d ) ; } } if ( remainingTasks . size ( ) > 0 ) { logger . warnf ( "% d tasks not completed" , remainingTasks . size ( ) ) ; } return out ; }
tr	1	protected double [ ] calculateOutputError ( double [ ] desiredOutput , double [ ] output ) { double [ ] outputError = new double [ desiredOutput . length ] ; for ( int i = 0 ; i < output . length ; i ++ ) outputError [ i ] = desiredOutput [ i ] - output [ i ] ; return outputError ; }
tr	6	private void processScore ( ) { int youngest = Integer . MAX_VALUE ; EPlayer player = EPlayer . None ; for ( Integer oldest : gr . oldestsP1 ) { if ( oldest < youngest ) { youngest = oldest ; player = EPlayer . P1 ; } } for ( Integer oldest : gr . oldestsP2 ) { if ( oldest < youngest ) { youngest = oldest ; player = EPlayer . P2 ; } } gr . scoreP1 = gr . oldestsP1 . size ( ) / 2f ; gr . scoreP2 = gr . oldestsP2 . size ( ) / 2f ; if ( player == EPlayer . P1 ) gr . scoreP1 += 1 / 2f ; else if ( player == EPlayer . P2 ) gr . scoreP2 += 1 / 2f ; }
tr	0	public String getRowId ( ) { return rowId ; }
tr	0	public boolean RemoveContact ( long nIndexContact ) { return otapiJNI . AddressBook_RemoveContact ( swigCPtr , this , removeRefContact ( nIndexContact ) ) ; }
tr	9	@ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; Tariff other = ( Tariff ) obj ; if ( EndDate == null ) { if ( other . EndDate != null ) return false ; } else if ( ! EndDate . equals ( other . EndDate ) ) return false ; if ( Price == null ) { if ( other . Price != null ) return false ; } else if ( ! Price . equals ( other . Price ) ) return false ; if ( StartDate == null ) { if ( other . StartDate != null ) return false ; } else if ( ! StartDate . equals ( other . StartDate ) ) return false ; return true ; }
tr	2	public void setY2 ( final int y ) { if ( this . y2 != null && this . y2 == y ) return ; this . y2 = y ; this . refresh ( ) ; }
tr	8	public static Pair < Integer > traverse_spiral ( int cur_row , int cur_col , int square_len ) { int midpoint = ( square_len - 1 ) / 2 ; int next_col = cur_col ; int next_row = cur_row ; if ( cur_row == square_len / 2 && cur_col == midpoint ) { next_col = - 1 ; next_row = - 1 ; } else if ( cur_row <= midpoint ) { if ( cur_col < cur_row - 1 ) { next_row -- ; } else if ( cur_col < square_len - 1 - cur_row ) { next_col ++ ; } else if ( next_col != midpoint ) { next_row ++ ; } } else { if ( cur_col > cur_row ) { next_row ++ ; } else if ( cur_col > square_len - 1 - cur_row ) { next_col -- ; } else { next_row -- ; } } Pair < Integer > p = new Pair < Integer > ( next_row , next_col ) ; return p ; }
tr	7	public static ArrayList < String > from ( File f , boolean readBlanks ) { ArrayList < String > strings = new ArrayList < String > ( ) ; if ( ! f . exists ( ) ) { System . err . println ( "File " + f . getPath ( ) + " not found!" ) ; return strings ; } while ( true ) { try { BufferedReader reader = new BufferedReader ( new FileReader ( f ) ) ; String line ; while ( ( line = reader . readLine ( ) ) != null ) { if ( ! line . startsWith ( "#" ) && ( ! line . isEmpty ( ) || readBlanks ) ) { strings . add ( line ) ; } } reader . close ( ) ; break ; } catch ( IOException e ) { System . err . println ( "Error reading file " + f . getName ( ) + ".... attempting Again" ) ; } } return strings ; }
tr	9	@ Override public PixelArray getPixels ( int w , int h ) { PixelArray pixels = new PixelArray ( w , h ) ; int count = 0 ; for ( int y = 0 ; y < pixels . getHeight ( ) ; y += 4 ) for ( int x = 0 ; x < pixels . getWidth ( ) ; x += 4 ) { pixels . setPixel ( count ++ , x , y ) ; } for ( int y = 1 ; y < pixels . getHeight ( ) ; y += 2 ) for ( int x = 2 ; x < pixels . getWidth ( ) ; x += 4 ) { pixels . setPixel ( count ++ , x , y ) ; } for ( int y = 2 ; y < pixels . getHeight ( ) ; y += 4 ) for ( int x = 0 ; x < pixels . getWidth ( ) ; x += 4 ) { pixels . setPixel ( count ++ , x , y ) ; } for ( int y = 0 ; y < pixels . getHeight ( ) ; y += 2 ) for ( int x = 0 ; x < pixels . getWidth ( ) ; x += 4 ) { if ( x + 2 < pixels . getWidth ( ) ) pixels . setPixel ( count ++ , x + 2 , y ) ; if ( y + 1 < pixels . getHeight ( ) ) pixels . setPixel ( count ++ , x , y + 1 ) ; } for ( int y = 0 ; y < pixels . getHeight ( ) ; y += 2 ) for ( int x = 1 ; x < pixels . getWidth ( ) ; x += 2 ) { pixels . setPixel ( count ++ , x , y ) ; } for ( int y = 1 ; y < pixels . getHeight ( ) ; y += 2 ) for ( int x = 1 ; x < pixels . getWidth ( ) ; x += 2 ) { pixels . setPixel ( count ++ , x , y ) ; } return pixels ; }
tr	5	void parseOption ( String line ) { String [ ] tokens = line . split ( "=" ) ; if ( tokens . length == 2 ) { String key = tokens [ 0 ] ; String value = tokens [ 1 ] ; mPropertiesMap . put ( key , value ) ; if ( key . equals ( "clock" ) ) { if ( value . equals ( "thread-cpu" ) ) { mClockSource = ClockSource . THREAD_CPU ; } else if ( value . equals ( "wall" ) ) { mClockSource = ClockSource . WALL ; } else if ( value . equals ( "dual" ) ) { mClockSource = ClockSource . DUAL ; } } } }
tr	3	public static long receiveStream ( Socket socket , FileOutputStream fos , long fileSize ) throws IOException { BufferedOutputStream bos = new BufferedOutputStream ( fos ) ; byte [ ] bytearray = new byte [ 1024 * 1024 ] ; InputStream is = socket . getInputStream ( ) ; long bytesLeft = fileSize ; while ( bytesLeft > 0 ) { int bytesToRead = bytearray . length ; if ( bytesLeft < bytearray . length ) bytesToRead = ( int ) bytesLeft ; int bytesRead = is . read ( bytearray , 0 , bytesToRead ) ; if ( bytesRead <= 0 ) break ; bos . write ( bytearray , 0 , bytesRead ) ; bytesLeft -= bytesRead ; } bos . close ( ) ; return fileSize - bytesLeft ; }
tr	2	public String todayOrdering ( ) throws Exception { logger . info ( "init today ordering start." ) ; Param param = paramServiceImpl . findParamByCode ( OtherConstants . CODE_START_ORDERING ) ; if ( ! OtherConstants . STATE_ORDERING_YES . equals ( param . getParamValue ( ) ) ) { request . setAttribute ( OtherConstants . TODAY_ORDERING_INFO , OtherConstants . TODAY_ORDERING_STOP ) ; logger . info ( "init today ordering end." ) ; return ResultConstants . TODAY_ORDERING ; } List < Price > prices = orderingServiceImpl . todayOrdering ( ) ; param = paramServiceImpl . findParamByCode ( OtherConstants . CODE_TODAY_FOOD_INFO ) ; if ( param != null ) { request . setAttribute ( OtherConstants . TODAY_ORDERING_INFO , param . getParamDis ( ) ) ; } String [ ] numList = { "1" , "2" , "3" , "4" , "5" } ; request . setAttribute ( OtherConstants . TODAY_ORDERING , prices ) ; request . setAttribute ( OtherConstants . NUM_LIST , numList ) ; logger . info ( "init today ordering end." ) ; return ResultConstants . TODAY_ORDERING ; }
tr	5	public static void swap ( int [ ] data , int i , int j ) { if ( data == null || i < 0 || j < 0 || data . length <= i || data . length <= j ) { throw new IllegalArgumentException ( ) ; } int tmp = data [ i ] ; data [ i ] = data [ j ] ; data [ j ] = tmp ; }
tr	9	public JSONObject ( JSONTokener x ) throws JSONException { this ( ) ; char c ; String key ; if ( x . nextClean ( ) != { ) { throw x . syntaxError ( "A JSONObject text must begin with '{'" ) ; } for ( ; ; ) { c = x . nextClean ( ) ; switch ( c ) { case 0 : throw x . syntaxError ( "A JSONObject text must end with '}'" ) ; case } : return ; default : x . back ( ) ; key = x . nextValue ( ) . toString ( ) ; } c = x . nextClean ( ) ; if ( c == = ) { if ( x . next ( ) != > ) { x . back ( ) ; } } else if ( c != : ) { throw x . syntaxError ( "Expected a ':' after a key" ) ; } put ( key , x . nextValue ( ) ) ; switch ( x . nextClean ( ) ) { case ; : case   : if ( x . nextClean ( ) == } ) { return ; } x . back ( ) ; break ; case } : return ; default : throw x . syntaxError ( "Expected a ' ' or '}'" ) ; } } }
tr	7	private static void printHubDetails ( int indent , Device dev ) { try { Hub h = new Hub ( dev ) ; int ports = h . getNumPorts ( ) ; boolean indicator = h . isIndicator ( ) ; indentLine ( indent , ( h . isRootHub ( ) ? "Root " : "" ) + "Hub  " + ports + " ports" ) ; indentLine ( indent , "overcurrent protection: " + h . getOverCurrentMode ( ) ) ; indentLine ( indent , "power switching: " + h . getPowerSwitchingMode ( ) ) ; if ( indicator ) indentLine ( indent , "has port indicator LEDs" ) ; if ( h . isCompound ( ) ) indentLine ( indent , "part of a compound device" ) ; indent -= 4 ; indentLine ( indent , "" ) ; for ( int i = 1 ; i <= ports ; i ++ ) { Device child = dev . getChild ( i ) ; if ( child == null ) continue ; indentLine ( indent , "<!-- Port " + i + ( h . isRemovable ( i ) ? "" : " is built-in." ) + " -->" ) ; printDevice ( indent , child ) ; } } catch ( IOException e ) { e . printStackTrace ( System . out ) ; } }
tr	3	public case getCaseAt ( int x , int y ) throws Exception { for ( case c : this . get_cases ( ) ) { if ( c . getX ( ) == x && c . getY ( ) == y ) { return c ; } } throw new Exception ( "La case de coordonn\u00E9es (" + x + " " + y + ") n'\u00E9iste pas" ) ; }
tr	8	public String format ( Alignment alignment ) { char [ ] sequence1 = alignment . getSequence1 ( ) ; char [ ] sequence2 = alignment . getSequence2 ( ) ; char [ ] markup = alignment . getMarkupLine ( ) ; int length = sequence1 . length > sequence2 . length ? sequence2 . length : sequence1 . length ; String name1 = adjustName ( alignment . getName1 ( ) ) ; String name2 = adjustName ( alignment . getName2 ( ) ) ; StringBuffer buffer = new StringBuffer ( ) ; StringBuffer preMarkup = new StringBuffer ( ) ; for ( int j = 0 ; j < NAME_WIDTH + 1 + POSITION_WIDTH + 1 ; j ++ ) { preMarkup . append ( BLANK ) ; } int oldPosition1 , position1 = 1 + alignment . getStart1 ( ) ; int oldPosition2 , position2 = 1 + alignment . getStart2 ( ) ; char [ ] subsequence1 ; char [ ] subsequence2 ; char [ ] submarkup ; int line ; char c1 , c2 ; for ( int i = 0 ; i * SEQUENCE_WIDTH < length ; i ++ ) { oldPosition1 = position1 ; oldPosition2 = position2 ; line = ( ( i + 1 ) * SEQUENCE_WIDTH ) < length ? ( i + 1 ) * SEQUENCE_WIDTH : length ; subsequence1 = new char [ line - i * SEQUENCE_WIDTH ] ; subsequence2 = new char [ line - i * SEQUENCE_WIDTH ] ; submarkup = new char [ line - i * SEQUENCE_WIDTH ] ; for ( int j = i * SEQUENCE_WIDTH , k = 0 ; j < line ; j ++ , k ++ ) { subsequence1 [ k ] = sequence1 [ j ] ; subsequence2 [ k ] = sequence2 [ j ] ; submarkup [ k ] = markup [ j ] ; c1 = subsequence1 [ k ] ; c2 = subsequence2 [ k ] ; if ( c1 == c2 ) { position1 ++ ; position2 ++ ; } else if ( c1 == Alignment . GAP ) { position2 ++ ; } else if ( c2 == Alignment . GAP ) { position1 ++ ; } else { position1 ++ ; position2 ++ ; } } buffer . append ( name1 ) ; buffer . append ( BLANK ) ; buffer . append ( adjustPosition ( new Integer ( oldPosition1 ) . toString ( ) ) ) ; buffer . append ( BLANK ) ; buffer . append ( subsequence1 ) ; buffer . append ( BLANK ) ; buffer . append ( adjustPosition ( new Integer ( position1 - 1 ) . toString ( ) ) ) ; buffer . append ( Commons . getLineSeparator ( ) ) ; buffer . append ( preMarkup ) ; buffer . append ( submarkup ) ; buffer . append ( Commons . getLineSeparator ( ) ) ; buffer . append ( name2 ) ; buffer . append ( BLANK ) ; buffer . append ( adjustPosition ( new Integer ( oldPosition2 ) . toString ( ) ) ) ; buffer . append ( BLANK ) ; buffer . append ( subsequence2 ) ; buffer . append ( BLANK ) ; buffer . append ( adjustPosition ( new Integer ( position2 - 1 ) . toString ( ) ) ) ; buffer . append ( Commons . getLineSeparator ( ) ) ; buffer . append ( Commons . getLineSeparator ( ) ) ; } return buffer . toString ( ) ; }
tr	5	@ Override public boolean podeAtacar ( Posicao origem , Posicao destino , TabuleiroXadrez tabuleiro ) { int avanca ; if ( this . getCorJogador ( ) == TipoCorJogador . BRANCO ) avanca = 1 ; else avanca = - 1 ; if ( super . podeAtacar ( origem , destino , tabuleiro ) && tabuleiro . podeRealizarMovimentacao ( origem , destino ) ) if ( this . medeDeslocamentoPeca ( origem . getColuna ( ) , destino . getColuna ( ) ) == 1 ) if ( destino . getLinha ( ) - origem . getLinha ( ) == avanca ) return true ; return false ; }
tr	8	public static ResponseDTO execute ( RequestDTO reqObj ) throws BookingTicketException { log . debug ( "Start: execute()" ) ; PassengerDAO passengerDAO = new PassengerDAO ( ENTITY_MANAGER_FACTORY ) ; StationInRouteDAO sirDAO = new StationInRouteDAO ( ENTITY_MANAGER_FACTORY ) ; StationDAO stationDAO = new StationDAO ( ENTITY_MANAGER_FACTORY ) ; TicketDAO ticketDAO = new TicketDAO ( ENTITY_MANAGER_FACTORY ) ; TrainDAO trainDAO = new TrainDAO ( ENTITY_MANAGER_FACTORY ) ; Constants . ClientService reqService = reqObj . getService ( ) ; if ( reqService == Constants . ClientService . getScheduleFromAtoB ) { log . debug ( "Start: getScheduleFromAtoB" ) ; return StationInRouteService . scheduleFromAtoB ( reqObj , sirDAO ) ; } else if ( reqService == Constants . ClientService . scheduleForStation ) { log . debug ( "Start: scheduleForStation" ) ; return StationInRouteService . scheduleForStation ( reqObj , sirDAO ) ; } else if ( reqService == Constants . ClientService . buyTicket ) { log . debug ( "Start: buyTicket" ) ; return TicketService . bookTicket ( reqObj , passengerDAO , ticketDAO , trainDAO , sirDAO ) ; } else if ( reqService == Constants . ClientService . addTrain ) { log . debug ( "Start: buyTicket" ) ; return TrainService . addTrain ( reqObj , trainDAO ) ; } else if ( reqService == Constants . ClientService . addStation ) { log . debug ( "Start: addStation" ) ; return StationService . addStation ( reqObj , stationDAO ) ; } else if ( reqService == Constants . ClientService . addRoute ) { log . debug ( "Start: addRoute" ) ; return StationInRouteService . addRoute ( reqObj , sirDAO ) ; } else if ( reqService == Constants . ClientService . viewPassangers ) { log . debug ( "Start: viewPassangers" ) ; return PassengerService . showPassengers ( reqObj , passengerDAO ) ; } else if ( reqService == Constants . ClientService . viewTrains ) { log . debug ( "Start: viewTrains" ) ; return TrainService . viewAllTrains ( trainDAO ) ; } else return null ; }
tr	4	public static void main ( String [ ] args ) { int a [ ] = new int [ ] { 1 , 3 , 7 , 5 , 4 , 12 , 13 } ; Arrays . sort ( a ) ; int len = a . length ; int d [ ] = new int [ len ] ; for ( int i = 0 ; i < len ; i ++ ) { d [ i ] = a [ i ] * a [ i ] ; } for ( int i = len - 1 ; i > 2 ; i -- ) { int sum = d [ i ] ; int R = d [ i - 1 ] ; for ( int j = 0 ; j < i - 1 ; j ++ ) { if ( d [ j ] + R == sum ) { System . out . println ( "The Pythagorean Triplet is : " + a [ j ] + " | " + a [ i - 1 ] + " | " + a [ i ] ) ; } } } }
tr	0	public int getHeight ( ) { return render . getHeight ( ) ; }
tr	5	@ SuppressWarnings ( "unchecked" ) public static void main ( String args [ ] ) { Repl < ? , ? > repl ; if ( args . length == 0 ) { repl = new Repl < > ( FractalEvaluator . class ) ; repl . loop ( ) ; } else { try { repl = new Repl ( class . forName ( args [ 0 ] ) ) ; ArrayList < String > fileList = new ArrayList < > ( ) ; for ( int i = 1 ; i < args . length ; i ++ ) { fileList . add ( args [ i ] ) ; } repl . visitFiles ( fileList ) ; repl . loop ( ) ; } catch ( ClassNotFoundException cnfe ) { System . err . println ( cnfe . getMessage ( ) ) ; System . exit ( 1 ) ; } } }
tr	6	public void advance ( ) { timeUntilNext -- ; if ( timeUntilNext <= 0 ) { stoppingAt ( ) ; if ( ! reverse && nextStation . getNext ( ) == null ) { reverse = true ; timeUntilNext = nextStation . getPrevTime ( ) ; nextStation = nextStation . getPrev ( ) ; return ; } if ( reverse && nextStation . getPrev ( ) == null ) { reverse = false ; timeUntilNext = nextStation . getNextTime ( ) ; nextStation = nextStation . getNext ( ) ; return ; } if ( reverse ) { timeUntilNext = nextStation . getPrevTime ( ) ; nextStation = nextStation . getPrev ( ) ; } else { timeUntilNext = nextStation . getNextTime ( ) ; nextStation = nextStation . getNext ( ) ; } } }
tr	4	private static Expr resolveNoneParamExpr ( SyntaxTreeNode node ) { LexToken token = node . getToken ( ) ; String text = token . getText ( ) ; switch ( ( NagisaLexTokenType ) token . getType ( ) ) { case LITERAL_INTEGER : return new Expr ( ExprType . Integer , ExprOperator . IntegerLiteral , text ) ; case IDENTIFIER_INTEGER : return new Expr ( ExprType . Integer , ExprOperator . IntegerVariableRef , text ) ; case LITERAL_STRING : return new Expr ( ExprType . String , ExprOperator . StringLiteral , text ) ; case IDENTIFIER_STRING : return new Expr ( ExprType . String , ExprOperator . StringVariableRef , text ) ; default : throw new UnsupportedOperationException ( token . toString ( ) ) ; } }
tr	0	public void draw ( Graphics g ) { double dist = Point . distance ( origX , origY , lastX , lastY ) / panel . getMap ( ) . getPixelsPerFoot ( ) ; String distTxt = FormatUtils . formatDist ( dist ) ; statusBar . setText ( "Distance: " + distTxt ) ; g . setColor ( Color . WHITE ) ; g . drawLine ( origX , origY , lastX , lastY ) ; g . drawString ( distTxt , lastX , lastY ) ; }
tr	6	public void method354 ( Background background , int i , int j ) { j += anInt1442 ; i += anInt1443 ; int k = j + i * DrawingArea . width ; int l = 0 ; int i1 = myHeight ; int j1 = myWidth ; int k1 = DrawingArea . width - j1 ; int l1 = 0 ; if ( i < DrawingArea . topY ) { int i2 = DrawingArea . topY - i ; i1 -= i2 ; i = DrawingArea . topY ; l += i2 * j1 ; k += i2 * DrawingArea . width ; } if ( i + i1 > DrawingArea . bottomY ) i1 -= ( i + i1 ) - DrawingArea . bottomY ; if ( j < DrawingArea . topX ) { int j2 = DrawingArea . topX - j ; j1 -= j2 ; j = DrawingArea . topX ; l += j2 ; k += j2 ; l1 += j2 ; k1 += j2 ; } if ( j + j1 > DrawingArea . bottomX ) { int k2 = ( j + j1 ) - DrawingArea . bottomX ; j1 -= k2 ; l1 += k2 ; k1 += k2 ; } if ( ! ( j1 <= 0 || i1 <= 0 ) ) { method355 ( myPixels , j1 , background . aByteArray1450 , i1 , DrawingArea . pixels , 0 , k1 , k , l1 , l ) ; } }
tr	8	private static void runTourn ( String args [ ] , GameEngine engine , long seed , int n ) { Statement s ; java . net . InetAddress localMachine = null ; try { localMachine = java . net . InetAddress . getLocalHost ( ) ; } catch ( UnknownHostException e1 ) { e1 . printStackTrace ( ) ; } String hostname = localMachine . getHostName ( ) ; int tournament_id = - 1 ; try { s = conn . createStatement ( ) ; s . execute ( "INSERT INTO tournament (start source player board num_lights seed run_num)" + " VALUES (NOW() \"" + hostname + "\" \"" + args [ 0 ] + "\" \"" + args [ 2 ] + "\" \"" + args [ 1 ] + "\" \"" + seed + "\" \"" + n + "\")" , Statement . RETURN_GENERATED_KEYS ) ; ResultSet rszz = s . getGeneratedKeys ( ) ; rszz . next ( ) ; tournament_id = rszz . getInt ( 1 ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; } Tournament t = new Tournament ( engine ) ; engine . getConfig ( ) . setSelectedBoard ( new File ( "boards/" + args [ 2 ] + ".xml" ) ) ; try { engine . getConfig ( ) . setPlayerClass ( ( class < Player > ) class . forName ( args [ 0 ] ) ) ; } catch ( ClassNotFoundException e ) { e . printStackTrace ( ) ; } engine . getConfig ( ) . setNumMosquitos ( 1000 ) ; engine . getConfig ( ) . setNumLights ( Integer . valueOf ( args [ 1 ] ) ) ; engine . getConfig ( ) . setMaxRounds ( 15000 ) ; try { t . play ( ) ; } catch ( Exception e ) { System . err . println ( "Exception in Tournament " + tournament_id + "  player " + args [ 0 ] ) ; e . printStackTrace ( ) ; } if ( t . timedOut ) { System . err . println ( "Timeout in Tournament " + tournament_id + "  player " + args [ 0 ] ) ; } if ( n == 0 ) { BoardPanel pan = new BoardPanel ( engine , false ) ; BufferedImage im = new BufferedImage ( 600 , 600 , BufferedImage . TYPE_INT_RGB ) ; pan . paint ( im . getGraphics ( ) ) ; Iterator writers = ImageIO . getImageWritersByFormatName ( "png" ) ; ImageWriter writer = ( ImageWriter ) writers . next ( ) ; File f = new File ( "output/" + args [ 0 ] + "_" + args [ 2 ] + "_" + args [ 1 ] + ".png" ) ; ImageOutputStream ios ; try { ios = ImageIO . createImageOutputStream ( f ) ; writer . setOutput ( ios ) ; writer . write ( im ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } try { s = conn . createStatement ( ) ; s . execute ( "UPDATE tournament SET end=NOW()  num_caught=" + t . finalN + " time=" + t . finalTime + " where id=" + tournament_id ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; } }
tr	7	public RegisteredEventMonitor ( Method monitorMethod , Listener listener ) { EventMonitor monitorAnnotation = monitorMethod . getAnnotation ( EventMonitor . class ) ; if ( monitorAnnotation == null ) { throw new IllegalArgumentException ( "Monitor method does not have an EventMonitor annotation." ) ; } class < ? > [ ] monitorMethodParameters = monitorMethod . getParameterTypes ( ) ; if ( monitorMethodParameters . length != 2 || ! Event . class . isAssignableFrom ( monitorMethodParameters [ 0 ] ) || ! Result . class . isAssignableFrom ( monitorMethodParameters [ 1 ] ) ) { throw new IllegalArgumentException ( "Monitor method signature is invalid. Cannot accept (Event  Result)." ) ; } eventType = ( class < ? extends Event > ) monitorMethodParameters [ 0 ] ; this . monitorMethod = monitorMethod ; if ( ! monitorMethod . isAccessible ( ) ) { monitorMethod . setAccessible ( true ) ; } this . listener = listener ; }
