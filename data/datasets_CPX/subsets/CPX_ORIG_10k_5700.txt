tr	8	@ Override public boolean hasNext ( ) { if ( hasNextCalled ) return hasNext ; hasNextCalled = true ; if ( n == 0 ) return false ; if ( ! started ) { for ( int i = 0 ; ( subset [ i ] = i ) < k - 1 ; i ++ ) ; started = true ; hasNext = true ; return true ; } else { int i ; for ( i = k - 1 ; i >= 0 && subset [ i ] == n - k + i ; i -- ) ; if ( i < 0 ) { hasNext = false ; return false ; } else { subset [ i ] ++ ; for ( ++ i ; i < k ; i ++ ) subset [ i ] = subset [ i - 1 ] + 1 ; hasNext = true ; return true ; } } }
tr	8	public JPanel addNumberButtons ( JTextField DispField ) { final JTextField Field = DispField ; JPanel ButtonPanel = new JPanel ( ) ; ButtonPanel . setLayout ( new GridLayout ( 4 , 3 ) ) ; ButtonPanel . setPreferredSize ( new Dimension ( 500 , 320 ) ) ; ButtonPanel . setMaximumSize ( new Dimension ( 500 , 500 ) ) ; JButton [ ] NumButtons = new JButton [ 10 ] ; JButton StarButtons = new JButton ( "*" ) ; StarButtons . setFont ( NumButtonsFont ) ; StarButtons . setPreferredSize ( new Dimension ( 100 , 75 ) ) ; StarButtons . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent ev ) { if ( Field . getText ( ) . length ( ) < MaxChars ) Field . setText ( Field . getText ( ) + "*" ) ; if ( ! MainFrame . RedirectPanel . isVisible ( ) ) CallButton . setEnabled ( true ) ; } } ) ; JButton latticeButtons = new JButton ( "#" ) ; latticeButtons . setFont ( NumButtonsFont ) ; latticeButtons . setPreferredSize ( new Dimension ( 100 , 75 ) ) ; latticeButtons . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent ev ) { if ( Field . getText ( ) . length ( ) < MaxChars ) Field . setText ( Field . getText ( ) + "#" ) ; if ( ! MainFrame . RedirectPanel . isVisible ( ) ) CallButton . setEnabled ( true ) ; } } ) ; for ( int i = 0 ; i < 10 ; i ++ ) { final String name = "" + i ; NumButtons [ i ] = new JButton ( "" + i ) ; NumButtons [ i ] . setFont ( NumButtonsFont ) ; NumButtons [ i ] . setPreferredSize ( new Dimension ( 100 , 75 ) ) ; NumButtons [ i ] . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent ev ) { if ( Field . getText ( ) . length ( ) < MaxChars ) Field . setText ( Field . getText ( ) + name ) ; if ( ! MainFrame . RedirectPanel . isVisible ( ) ) CallButton . setEnabled ( true ) ; } } ) ; } for ( int i = 1 ; i <= 9 ; i ++ ) { ButtonPanel . add ( NumButtons [ i ] ) ; } ButtonPanel . add ( StarButtons ) ; ButtonPanel . add ( NumButtons [ 0 ] ) ; ButtonPanel . add ( latticeButtons ) ; return ButtonPanel ; }
tr	7	public RandomListNode copyRandomListII ( RandomListNode head ) { if ( head == null ) return head ; RandomListNode iter = head ; while ( iter != null ) { RandomListNode newNode = new RandomListNode ( iter . label ) ; newNode . next = iter . next ; newNode . random = iter . random ; iter . next = newNode ; iter = newNode . next ; } iter = head . next ; RandomListNode newHead = iter ; while ( iter != null ) { if ( iter . random != null ) iter . random = iter . random . next ; if ( iter . next != null ) iter = iter . next . next ; else iter = null ; } iter = head ; while ( iter != null && iter . next != null ) { RandomListNode nextIter = iter . next ; iter . next = iter . next . next ; iter = nextIter ; } return newHead ; }
tr	3	public void manageShowTimes ( ) { int index ; int choice ; int hour , minute ; String time ; ShowTime showTime ; listShowTimes ( ) ; System . out . print ( "Please select showtime (the number between '[ ]') : " ) ; index = ConsoleReader . readIntInput ( ) ; if ( index <= 0 ) { System . out . println ( "Show Time is invalid!" ) ; return ; } showTime = _showTimes . get ( index - 1 ) ; System . out . println ( "1) Update ShowTime" ) ; System . out . println ( "2) Delete ShowTime" ) ; System . out . println ( "3) Back" ) ; System . out . print ( "Please enter your choice: " ) ; choice = ConsoleReader . readIntInput ( ) ; switch ( choice ) { case 1 : System . out . print ( "Please enter time (HH:mm): " ) ; time = ConsoleReader . readTimeInput ( ) ; showTimeBL . updateShowTime ( showTime , time ) ; break ; case 2 : showTimeBL . deleteShowTime ( showTime ) ; break ; default : break ; } }
tr	8	@ Override public void update ( ) { if ( hasNoTypes ( ) ) { calcTypes ( getHome ( ) ) ; } if ( population >= maxPop ) { population -= getHome ( ) . getRand ( ) . nextInt ( 5 ) ; } else if ( ( population <= 0 ) && ( getHealth ( ) <= 0 ) ) { getHome ( ) . removeStruct ( this ) ; } if ( happyPercent >= 100 ) { happyPercent -= getHome ( ) . getRand ( ) . nextInt ( 5 ) ; } if ( isType ( Types . MINING ) ) { final Mine m = WorldUtil . getClosestMine ( getHome ( ) , getxLoc ( ) , getyLoc ( ) , ( byte ) 10 ) ; if ( m . getOwner ( ) == getOwner ( ) ) { m . setIsProducing ( true ) ; } } if ( isType ( Types . TRADE ) ) { getOwner ( ) . addMoney ( getHome ( ) . getRand ( ) . nextFloat ( ) ) ; } }
tr	6	private static void run ( ) { while ( ! finished ) { Display . update ( ) ; if ( Display . isCloseRequested ( ) ) { finished = true ; } else if ( Display . isActive ( ) ) { logic ( ) ; render ( ) ; Display . sync ( FRAMERATE ) ; } else { try { Thread . sleep ( 100 ) ; } catch ( final InterruptedException e ) { } logic ( ) ; if ( Display . isVisible ( ) || Display . isDirty ( ) ) { render ( ) ; } } } }
tr	6	public boolean getBoolean ( String key ) throws JSONException { Object object = this . get ( key ) ; if ( object . equals ( boolean . false ) || ( object instanceof String && ( ( String ) object ) . equalsIgnoreCase ( "false" ) ) ) { return false ; } else if ( object . equals ( boolean . true ) || ( object instanceof String && ( ( String ) object ) . equalsIgnoreCase ( "true" ) ) ) { return true ; } throw new JSONException ( "JSONObject[" + quote ( key ) + "] is not a Boolean." ) ; }
tr	4	public static void normalize ( double [ ] [ ] xs ) { double sum = 0 ; for ( int i = 0 ; i < xs . length ; i ++ ) for ( int j = 0 ; j < xs [ i ] . length ; j ++ ) sum += xs [ i ] [ j ] ; for ( int i = 0 ; i < xs . length ; i ++ ) for ( int j = 0 ; j < xs [ i ] . length ; j ++ ) xs [ i ] [ j ] /= sum ; }
tr	4	@ Override public Event next ( ) { try { input = br . readLine ( ) ; } catch ( IOException e1 ) { } if ( input == null || input . equals ( "" ) ) { return new UserHomeState ( as , name ) ; } else { try { as . bid ( name , long . parseLong ( input ) ) ; } catch ( Exception e ) { return new SearchResultsState ( as , name , input ) ; } return new UserHomeState ( as , name ) ; } }
tr	6	private int hexToNibble ( char hexChar ) { if ( hexChar >= 0 && hexChar <= 9 ) { return hexChar - 0 ; } if ( hexChar >= a && hexChar <= f ) { return hexChar - a + 10 ; } if ( hexChar >= A && hexChar <= F ) { return hexChar - A + 10 ; } throw new RuntimeException ( "Invalid Hex Character: " + hexChar ) ; }
tr	7	public void refreshAccount ( String accountName , AuthorizationCallback callback ) throws MultiCloudException , OAuth2SettingsException , InterruptedException { synchronized ( lock ) { if ( auth != null ) { throw new MultiCloudException ( "Concurrent authorization forbidden." ) ; } } AccountSettings account = accountManager . getAccountSettings ( accountName ) ; if ( account == null ) { throw new MultiCloudException ( "User account not found." ) ; } if ( ! account . isAuthorized ( ) ) { throw new MultiCloudException ( "User account not authorized." ) ; } CloudSettings settings = cloudManager . getCloudSettings ( account . getSettingsId ( ) ) ; if ( settings == null ) { throw new MultiCloudException ( "Cloud storage settings not found." ) ; } synchronized ( lock ) { auth = new OAuth2 ( Utils . cloudSettingsToOAuth2Settings ( settings ) , credentialStore ) ; } if ( callback != null ) { auth . setAuthCallback ( callback ) ; } OAuth2Error error = new OAuth2Error ( ) ; try { error = auth . refresh ( account . getTokenId ( ) ) ; } catch ( Exception e ) { synchronized ( lock ) { auth = null ; } throw e ; } synchronized ( lock ) { auth = null ; } if ( error . getType ( ) != OAuth2ErrorType . SUCCESS ) { throw new MultiCloudException ( "Refreshing token failed." ) ; } accountManager . saveAccountSettings ( ) ; }
tr	1	public Products asProducts ( ) throws DiffbotParseException { try { return this . getFactory ( ) . createJsonParser ( super . toString ( ) ) . parse ( Products . class ) ; } catch ( IOException e ) { throw new DiffbotParseException ( "The classified object cannot be parsed as a Products." , e ) ; } }
tr	3	@ Override public void dispell ( ) { for ( Modifier mod : mods ) { if ( mod . isDispellable ( ) ) { if ( mod . isTemporary ( ) ) { modTotal -= mod . getTotal ( ) ; } mods . remove ( mod ) ; } } }
tr	8	@ Override public List < float > getRT ( ) throws ValidationException { if ( ! this . inputFieldsChanged ) { return rtsToOptimize ; } rtsToOptimize . clear ( ) ; String eludePath = getEludePath ( ) ; String trainingPeptidesFile = getTrainingPeptides ( ) ; String insilicoPeptidesFile = getInsilicoFile ( ) ; String currentDateTime = "" + System . currentTimeMillis ( ) ; eludeErrFile = Paths . get ( eludeTmpDir ) . resolve ( "elude-" + currentDateTime + ".err" ) . toString ( ) ; eludeLogFile = Paths . get ( eludeTmpDir ) . resolve ( "elude-" + currentDateTime + ".log" ) . toString ( ) ; eludeOutFile = Paths . get ( eludeTmpDir ) . resolve ( "elude-" + currentDateTime + ".out" ) . toString ( ) ; try { String [ ] commands = { eludePath , "-t" , trainingPeptidesFile , "-e" , insilicoPeptidesFile , "-o" , eludeOutFile , "-v" , "5" } ; EludeWorker eludeWorker = new EludeWorker ( commands , eludeTmpDir , eludeErrFile , eludeLogFile ) ; eludeWorker . addPropertyChangeListener ( new PropertyChangeListener ( ) { @ Override public void propertyChange ( PropertyChangeEvent evt ) { switch ( evt . getPropertyName ( ) ) { case "state" : switch ( ( StateValue ) evt . getNewValue ( ) ) { case DONE : System . out . println ( "Elude is done (or canceled by user)" ) ; try { dialog . setVisible ( false ) ; rtsToOptimize = getRT ( eludeOutFile ) ; } catch ( Exception e ) { } break ; } break ; } } } ) ; eludeWorker . execute ( ) ; dialog . setVisible ( true ) ; String retVal = ( String ) pane . getValue ( ) ; if ( retVal . equals ( "Cancel Elude" ) ) { eludeWorker . cancel ( true ) ; eludeWorker . destroyEludeProcess ( ) ; rtsToOptimize . clear ( ) ; return rtsToOptimize ; } if ( rtsToOptimize . isEmpty ( ) ) { throw new ValidationException ( "" , "" ) ; } this . inputFieldsChanged = false ; return rtsToOptimize ; } catch ( Exception e ) { String message = "Unable to run Elude. Please make sure that:\n" ; message += "  - the software is installed correctly.\n" ; message += "  - the paths to Elude  training peptides and insilico peptides/fasta file are correct.\n" ; message += "  - the training peptides file and the in silico/fasta files have the correct format\n" ; File f = new File ( eludeErrFile ) ; if ( f . exists ( ) ) { message += "\nFor more details  please check " + eludeErrFile ; } throw new ValidationException ( message , "BAD_FILENAME" ) ; } }
tr	7	public void generateAttackPatternModel ( String pattern_ids ) { CAPECXMLProcessing xmlProcessing = new CAPECXMLProcessing ( ) ; xmlProcessing . importAttackDomainFromFile ( ) ; LinkedList < String > ids = createNonRepeatedList ( pattern_ids ) ; for ( String id : ids ) { CAPECXMLQuerying xmlQuery = new CAPECXMLQuerying ( ) ; AttackPattern ap = xmlQuery . getAttackInfoAndRelations ( id ) ; LinkedList < String > threats = ap . getAllThreats ( ) ; String target = xmlProcessing . findAttackDomainByID ( id ) ; String general_task_id = AppleScript . drawArbitraryRequirementElement ( "Model set" , "none" , "Hexagon" , InfoEnum . NORMAL_SIZE , "(300 300)" , "0" , ap . name , "0" , "1" ) ; String goal_content = "" ; if ( threats != null ) { String goal_id = "" ; for ( String threat : threats ) { goal_content = "" ; goal_content += "Threat: " + threat + "\n" ; goal_content += "Target: " + target ; goal_id = AppleScript . drawArbitraryRequirementElement ( "Model set" , "none" , "Circle" , InfoEnum . NORMAL_SIZE , "(300 300)" , "0" , goal_content , "0" , "1" ) ; AppleScript . drawArbitraryRequirementLink ( "Model set" , "none" , goal_id , general_task_id , "Arrow" , "0" , "none" , "none" ) ; } } String context_content = "" ; for ( String context : ap . contexts ) { context_content += context + "\n" ; } for ( String prerequisite : ap . prerequisites ) { context_content += prerequisite + "\n" ; } String context_id = AppleScript . drawArbitraryRequirementElement ( "Model set" , "none" , "Rectangle" , InfoEnum . NORMAL_SIZE , "(300 300)" , "0" , context_content , "0" , "0" ) ; AppleScript . drawArbitraryRequirementLink ( "Model set" , "none" , context_id , general_task_id , "" , "0" , "none" , "none" ) ; if ( ap . steps . size ( ) > 1 ) { String mid_id = AppleScript . drawArbitraryRequirementElement ( "Model set" , "none" , "Circle" , InfoEnum . POINT_SIZE , "(300 300)" , "0" , "" , "0" , "1" ) ; AppleScript . drawArbitraryRequirementLink ( "Model set" , "none" , general_task_id , mid_id , "SharpArrow" , "0" , "none" , "none" ) ; String task_id = "" ; for ( String step : ap . steps ) { task_id = AppleScript . drawArbitraryRequirementElement ( "Model set" , "none" , "Hexagon" , InfoEnum . NORMAL_SIZE , "(300 300)" , "0" , step , "0" , "1" ) ; AppleScript . drawArbitraryRequirementLink ( "Model set" , "none" , mid_id , task_id , "" , "0" , "none" , "none" ) ; } } else { } System . out . println ( "Successfully draw the model!" ) ; } }
tr	5	public static void main ( String [ ] args ) { HashMap < Integer , Integer > pfs = null ; int result = 0 ; int number = 4 ; boolean found = false ; while ( ! found ) { pfs = PrimeFactors . get ( number ) ; if ( pfs . size ( ) != 4 ) { number ++ ; continue ; } pfs = PrimeFactors . get ( number + 1 ) ; if ( pfs . size ( ) != 4 ) { number += 2 ; continue ; } pfs = PrimeFactors . get ( number + 2 ) ; if ( pfs . size ( ) != 4 ) { number += 3 ; continue ; } pfs = PrimeFactors . get ( number + 3 ) ; if ( pfs . size ( ) != 4 ) { number += 4 ; continue ; } else { result = number ; break ; } } System . out . println ( "# result = " + result ) ; System . out . println ( PrimeFactors . get ( result ) ) ; System . out . println ( PrimeFactors . get ( result + 1 ) ) ; System . out . println ( PrimeFactors . get ( result + 2 ) ) ; System . out . println ( PrimeFactors . get ( result + 3 ) ) ; }
tr	3	public void act ( List < Actor > newFoxes ) { incrementAge ( ) ; incrementHunger ( ) ; if ( isAlive ( ) ) { giveBirth ( newFoxes ) ; Location location = getLocation ( ) ; Location newLocation = findFood ( location ) ; if ( newLocation == null ) { newLocation = getField ( ) . freeAdjacentLocation ( location ) ; } if ( newLocation != null ) { setLocation ( newLocation ) ; } else { setDead ( ) ; } } }
tr	2	public boolean wordExists ( String s ) { TrieNode node = root ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { char c = s . charAt ( i ) ; Map < Character , TrieNode > characters = node . getCharacters ( ) ; if ( ! characters . containsKey ( c ) ) { return false ; } else { node = characters . get ( c ) ; } } return node . isWord ( ) ; }
tr	4	private void evaluateArray ( Object target , String basePath ) throws InterpolationException { int len = Array . getLength ( target ) ; for ( int i = 0 ; i < len ; i ++ ) { Object value = Array . get ( target , i ) ; if ( value != null ) { if ( String . class == value . getClass ( ) ) { String interpolated = interpolator . interpolate ( ( String ) value , recursionInterceptor ) ; if ( ! interpolated . equals ( value ) ) { Array . set ( target , i , interpolated ) ; } } else { interpolationTargets . add ( new InterpolationTarget ( value , basePath + "[" + i + "]" ) ) ; } } } }
tr	0	public boolean isSituacao ( ) { return situacao ; }
tr	1	public void pp ( ) { this . console . setText ( "<html>pretty printing..." ) ; if ( this . _compiler . pp ( this . textPane , this . textArea ) != - 1 ) { this . console . setText ( this . console . getText ( ) + "<br>Done !</html>" ) ; this . textPane . setFont ( new Font ( "Century Gothic" , Font . BOLD , 12 ) ) ; this . repaint ( ) ; } }
tr	1	private SerializationManager ( ) { if ( instance != null ) throw new IllegalStateException ( "Already instantiated" ) ; registerBuiltInSerializers ( ) ; }
tr	2	private static String message ( String msg , String filename , int lineno ) { final StringBuffer sb = new StringBuffer ( ) . append ( "[zuss] " ) ; if ( filename != null && filename . length ( ) > 0 ) sb . append ( filename ) . append ( : ) ; return sb . append ( "Line " ) . append ( lineno ) . append ( ": " ) . append ( msg ) . toString ( ) ; }
tr	6	@ Test ( groups = { "integration" } ) public void testConcurrentBehavior ( ) throws IOException , InterruptedException { final int QUEUE_ITEMS = 1024 ; final int THREADS = 10 ; log . trace ( "[start] PersistentQueueTest.testConcurrentBehavior" ) ; File tempfile = File . createTempFile ( "PersistentQueue" , ".test" ) ; try { tempfile . delete ( ) ; List < Thread > threads = new ArrayList < Thread > ( ) ; final AtomicInteger count = new AtomicInteger ( ) ; final PersistentQueue < Integer > queue = new PersistentQueue < Integer > ( Integer . class , tempfile , 9 , 4104 ) ; for ( int i = 0 ; i < THREADS ; i ++ ) { Thread thread = new Thread ( ) { public void run ( ) { log . trace ( "[thread] start {}" , Thread . currentThread ( ) . getId ( ) ) ; int x = 0 ; try { while ( true ) { Thread . yield ( ) ; Integer y = queue . poll ( 2 , TimeUnit . SECONDS ) ; Thread . yield ( ) ; if ( y == null ) break ; Thread . yield ( ) ; log . trace ( "[poll] {}" , y ) ; assert y >= x : "What happened?" ; Thread . yield ( ) ; x = y ; Thread . yield ( ) ; log . trace ( "[thread] count {}" , count . getAndIncrement ( ) ) ; } } catch ( InterruptedException exception ) { throw new IllegalStateException ( "Unexpectedly interrupted" , exception ) ; } } } ; thread . start ( ) ; threads . add ( thread ) ; } for ( int i = 0 ; i < QUEUE_ITEMS ; i ++ ) { log . trace ( "[put] {}" , i ) ; queue . put ( i ) ; } for ( Thread thread : threads ) { log . trace ( "[thread] joining {}" , thread . getId ( ) ) ; thread . join ( ) ; } int total = count . get ( ) ; assert total == QUEUE_ITEMS : "Expected " + QUEUE_ITEMS + "  observed " + total ; } finally { tempfile . delete ( ) ; } log . trace ( "[end] PersistentQueueTest.testConcurrentBehavior" ) ; }
tr	9	public SuffixArray ( String s ) { int n = s . length ( ) ; int logN = 32 - Integer . numberOfLeadingZeros ( n - 1 ) ; sa = new SuffixArrayEntry [ n ] ; int [ ] [ ] pos = new int [ logN + 1 ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { sa [ i ] = new SuffixArrayEntry ( ) ; pos [ 0 ] [ i ] = s . charAt ( i ) ; } for ( int t = 1 , step = 1 ; step < n ; t ++ , step *= 2 ) { for ( int i = 0 ; i < n ; i ++ ) { sa [ i ] . idx = i ; sa [ i ] . prevPos = pos [ t - 1 ] [ i ] ; sa [ i ] . pos = i + step < n ? pos [ t - 1 ] [ i + step ] : - 1 ; } Arrays . sort ( sa ) ; for ( int i = 0 ; i < n ; i ++ ) { pos [ t ] [ sa [ i ] . idx ] = ( i > 0 && sa [ i ] . compareTo ( sa [ i - 1 ] ) == 0 ) ? pos [ t ] [ sa [ i - 1 ] . idx ] : i ; } } int [ ] lcp = new int [ n ] ; for ( int i = 0 ; i < n - 1 ; i ++ ) { int x = sa [ i ] . idx , y = sa [ i + 1 ] . idx ; for ( int k = logN - 1 ; k >= 0 && x < n && y < n ; k -- ) { if ( pos [ k ] [ x ] == pos [ k ] [ y ] ) { x += 1 << k ; y += 1 << k ; lcp [ i ] += 1 << k ; } } } st = pos ; st [ 0 ] = lcp ; for ( int i = 1 ; i < logN ; i ++ ) { for ( int j = 0 ; j < n - ( 1 << i ) + 1 ; j ++ ) { st [ i ] [ j ] = Math . min ( st [ i - 1 ] [ j ] , st [ i - 1 ] [ j + ( 1 << i - 1 ) ] ) ; } } }
tr	8	@ Override public void actionPerformed ( ActionEvent event ) { String userId = textField . getText ( ) ; String userList = textArea . getText ( ) ; if ( event . getSource ( ) == btn [ 0 ] ) { if ( userList . equals ( "" ) ) { JOptionPane . showMessageDialog ( null , "Add User" ) ; } else { StringTokenizer tokenizer = new StringTokenizer ( userList , "\n" ) ; String targetId [ ] = new String [ userList . length ( ) ] ; int i = 0 ; while ( tokenizer . hasMoreTokens ( ) ) { targetId [ i ] = tokenizer . nextToken ( ) ; i ++ ; } String data = ClientLauncher . getUser ( ) . getId ( ) + "\t" + ClientLauncher . getFrame ( ) . getDirectoryListPanel ( ) . getDirectoryID ( ) + "\t" + i ; int type = Constants . PacketType . ShareRequest . getType ( ) ; for ( int j = 0 ; j < i ; j ++ ) { data += "\t" + targetId [ j ] ; } int length = data . length ( ) ; ClientLauncher . getConnector ( ) . sendPacket ( type , 0 , length , data ) ; } textField . setText ( "" ) ; } if ( event . getSource ( ) == btn [ 1 ] ) { dispose ( ) ; initialize ( ) ; } if ( event . getSource ( ) == btn [ 2 ] ) { if ( userId . equals ( "" ) ) JOptionPane . showMessageDialog ( null , "Input user ID" ) ; else if ( userId . equals ( ClientLauncher . getUser ( ) . getId ( ) ) ) JOptionPane . showMessageDialog ( null , "Can't add your ID" ) ; else { String data = userId ; int type = Constants . PacketType . IdCheckRequest . getType ( ) ; int length = data . length ( ) ; ClientLauncher . getConnector ( ) . sendPacket ( type , 0 , length , data ) ; } } }
tr	8	private void fixUpCase4 ( RBNode < T > node ) { RBNode < T > parent = ( RBNode < T > ) node . getParent ( ) ; RBNode < T > grandParent = ( RBNode < T > ) parent . getParent ( ) ; RBNode < T > next = node ; if ( ! parent . getRight ( ) . isEmpty ( ) && ! grandParent . getLeft ( ) . isEmpty ( ) ) { if ( isRightChild ( node ) && isLeftChild ( parent ) ) { leftRotation ( parent ) ; next = ( RBNode < T > ) node . getLeft ( ) ; } } else if ( ! parent . getLeft ( ) . isEmpty ( ) && ! grandParent . getRight ( ) . isEmpty ( ) ) { if ( isLeftChild ( node ) && isRightChild ( parent ) ) { rightRotation ( parent ) ; next = ( RBNode < T > ) node . getRight ( ) ; } } fixUpCase5 ( next ) ; }
tr	1	public void start ( ) { String name = getAudioFileName ( ) ; try { InputStream in = getAudioStream ( ) ; AudioDevice dev = getAudioDevice ( ) ; play ( in , dev ) ; } catch ( JavaLayerException ex ) { synchronized ( System . err ) { System . err . println ( "Unable to play " + name ) ; ex . printStackTrace ( System . err ) ; } } }
tr	3	private void initObject ( JGEngineInterface engine , String name , int collisionid ) { this . eng = engine ; this . name = name ; colid = collisionid ; if ( ( int ) expiry == suspend_off_view || ( int ) expiry == suspend_off_view_expire_off_pf ) { if ( ! isInView ( eng . getOffscreenMarginX ( ) , eng . getOffscreenMarginY ( ) ) ) suspend ( ) ; } eng . markAddObject ( this ) ; }
tr	5	public Object readObject ( boolean blocking ) throws ConnectionLostException { if ( socket == null ) throw new ConnectionLostException ( ) ; try { return bis . available ( ) > 0 || blocking ? ois . readObject ( ) : null ; } catch ( IOException e ) { System . err . println ( "Socket Exception: Cannot read from socket." ) ; socket = null ; throw new ConnectionLostException ( "Socket Exception: Cannot write to socket." ) ; } catch ( ClassNotFoundException e ) { System . err . println ( "Network Exception: Cannot receive game object from server. Check server version." ) ; } return null ; }
tr	0	public void setType ( String type ) { this . type = type ; }
tr	5	@ Override public Spieltag loadSpieltagFromFile ( final String filename ) throws PdfGeneratorException { Logger . getInstance ( ) . logInfo ( "FileImport" , "Loading Spieltag from file: " + filename ) ; final String [ ] lines = FileIO . getLinesFromFile ( filename ) ; if ( lines . length < 4 ) { throw new ParseException ( "Wrong field count in file: " + filename ) ; } final Spieltag tag = new Spieltag ( ) ; tag . setTitle ( FileIO . cleanQuotes ( lines [ 0 ] ) ) ; tag . setDatum ( FileIO . cleanQuotes ( lines [ 1 ] ) ) ; tag . setZeit ( FileIO . cleanQuotes ( lines [ 2 ] ) ) ; tag . setOrt ( FileIO . cleanQuotes ( lines [ 3 ] ) ) ; final String [ ] halle = FileIO . getFieldsFromLine ( lines [ 4 ] ) ; if ( halle . length != 4 ) { throw new ParseException ( "Wrong field count in file: " + filename ) ; } tag . setHalle_name ( halle [ 0 ] ) ; tag . setHalle_ort ( halle [ 1 ] ) ; tag . setHalle_strasse ( halle [ 2 ] ) ; tag . setHalle_tel ( halle [ 3 ] ) ; int index = 5 ; final List < String > teams = new ArrayList < String > ( ) ; while ( ! lines [ index ] . equals ( "<Spielfolge>" ) ) { final String t = FileIO . cleanQuotes ( lines [ index ] ) ; if ( ! t . equals ( "" ) ) { teams . add ( t ) ; } index ++ ; } tag . setTeams ( teams ) ; index ++ ; final List < String [ ] > games = new ArrayList < String [ ] > ( ) ; for ( int i = index ; i < lines . length ; i ++ ) { games . add ( FileIO . getSpielFromLine ( lines [ i ] ) ) ; } tag . setGames ( games ) ; Logger . getInstance ( ) . logInfo ( "FileImport" , "Loading DONE" ) ; return tag ; }
tr	6	public int [ ] getActions ( Game game , long timeDue ) { int pacmanLoc = game . getCurPacManLoc ( ) ; for ( int i = 0 ; i < dirs . length ; i ++ ) { if ( game . ghostRequiresAction ( i ) ) { if ( isCrowded ( game ) && ! closeToMsPacMan ( game , game . getCurGhostLoc ( i ) ) ) dirs [ i ] = getRetreatActions ( game , i ) ; else if ( game . getEdibleTime ( i ) > 0 || closeToPower ( game ) ) dirs [ i ] = game . getNextGhostDir ( i , pacmanLoc , false , Game . DM . PATH ) ; else dirs [ i ] = game . getNextGhostDir ( i , pacmanLoc , true , Game . DM . PATH ) ; } } return dirs ; }
tr	0	private void makeNew ( ) { Employees = new BinarySearchTree < Employee > ( ) ; currentEmployee = null ; fileName = pickSave ( ) ; changeView ( PanelType . SEARCH ) ; mnuFileSave . setEnabled ( true ) ; mnuFileSaveAs . setEnabled ( true ) ; mnuManage . setEnabled ( true ) ; }
tr	3	void initialize ( int d ) { this . matArray = new Material [ this . getNumFaces ( ) ] [ this . getDimension ( ) + 2 ] [ this . getDimension ( ) + 2 ] ; this . tileState = new int [ this . getNumFaces ( ) ] [ this . getDimension ( ) + 2 ] [ this . getDimension ( ) + 2 ] ; this . cleanColor = new Material ( ) ; this . cleanColor . setAmbient ( 0.7 , 0.7 , 0.7 ) ; this . cleanColor . setDiffuse ( 0.8 , 0.8 , 0.8 ) ; this . cleanColor . setSpecular ( 0.9 , 0.9 , 0.9 , 10 ) ; this . coveredColor = new Material ( ) ; this . coveredColor . setAmbient ( 0.1 , 0.1 , 0.1 ) ; this . coveredColor . setDiffuse ( 0.2 , 0.2 , 0.2 ) ; this . coveredColor . setSpecular ( .5 , .5 , .5 , 10 ) ; this . redColor = new Material ( ) ; this . redColor . setAmbient ( 0.9 , 0.1 , 0.1 ) ; this . redColor . setDiffuse ( 0.95 , 0.15 , 0.15 ) ; this . redColor . setSpecular ( .95 , .15 , .15 , 10 ) ; this . yellowColor = new Material ( ) ; this . yellowColor . setAmbient ( 0.9 , 0.9 , 0.1 ) ; this . yellowColor . setDiffuse ( 0.95 , 0.95 , 0.15 ) ; this . yellowColor . setSpecular ( .95 , .95 , .15 , 10 ) ; this . blueColor = new Material ( ) ; this . blueColor . setAmbient ( 0.1 , 0.1 , 0.9 ) ; this . blueColor . setDiffuse ( 0.15 , 0.15 , 0.95 ) ; this . blueColor . setSpecular ( .15 , .15 , .95 , 10 ) ; this . greenColor = new Material ( ) ; this . greenColor . setAmbient ( 0.1 , 0.9 , 0.1 ) ; this . greenColor . setDiffuse ( 0.15 , 0.95 , 0.15 ) ; this . greenColor . setSpecular ( .15 , .95 , .15 , 10 ) ; this . orangeColor = new Material ( ) ; this . orangeColor . setAmbient ( 0.98 , 0.5 , 0.25 ) ; this . orangeColor . setDiffuse ( 0.99 , 0.52 , 0.27 ) ; this . orangeColor . setSpecular ( .99 , .52 , .27 , 10 ) ; this . purpleColor = new Material ( ) ; this . purpleColor . setAmbient ( 0.9 , 0.1 , 0.9 ) ; this . purpleColor . setDiffuse ( 0.95 , 0.15 , 0.95 ) ; this . purpleColor . setSpecular ( .95 , .15 , .95 , 10 ) ; for ( int face = 0 ; face < this . getNumFaces ( ) ; face ++ ) { for ( int row = 1 ; row <= this . getDimension ( ) ; row ++ ) { for ( int column = 1 ; column <= this . getDimension ( ) ; column ++ ) { this . getFace ( face ) [ row ] [ column ] . setMaterial ( this . coveredColor ) ; this . tileState [ face ] [ row ] [ column ] = 0 ; } } } }
tr	4	public int firstMissingPositive ( int [ ] A ) { int ValPos = ShiftNonPositive ( A ) ; for ( int i = 0 ; i <= ValPos ; i ++ ) { int posi = Math . abs ( A [ i ] ) ; if ( posi - 1 <= ValPos ) { A [ posi - 1 ] = - Math . abs ( A [ posi - 1 ] ) ; } } for ( int i = 0 ; i <= ValPos ; i ++ ) { if ( A [ i ] > 0 ) return i + 1 ; } return ValPos + 2 ; }
tr	0	public CreateAccountRequest ( RequestEnvelope requestEnvelope , NameType name , AddressType address , String preferredLanguageCode ) { this . requestEnvelope = requestEnvelope ; this . name = name ; this . address = address ; this . preferredLanguageCode = preferredLanguageCode ; }
tr	7	private boolean placeRandomTeleportLocation ( int [ ] [ ] map , int [ ] randomlocation ) { if ( map == null ) throw new IllegalArgumentException ( "Invalid argument: map is null" ) ; if ( map [ 0 ] == null ) throw new IllegalArgumentException ( "Invalid argument: a row is null" ) ; if ( randomlocation . length != 2 ) throw new IllegalArgumentException ( "Invalid argument: the randomlocation array-holder is not of length 2" ) ; ArrayList < int [ ] > availableLocations = new ArrayList < > ( ) ; for ( int i = 0 ; i < map . length ; i ++ ) { for ( int j = 0 ; j < map [ 0 ] . length ; j ++ ) { if ( map [ i ] [ j ] == 0 ) { availableLocations . add ( new int [ ] { i , j } ) ; } } } if ( availableLocations . size ( ) == 0 ) { java . lang . System . out . println ( "Warning: You have a teleporter in a map with no spaces" ) ; return false ; } Random random = new Random ( ) ; random . setSeed ( java . lang . System . currentTimeMillis ( ) ) ; int index = random . nextInt ( availableLocations . size ( ) ) ; int [ ] chosen = availableLocations . get ( index ) ; randomlocation [ 0 ] = chosen [ 0 ] ; randomlocation [ 1 ] = chosen [ 1 ] ; return true ; }
tr	2	private int validateProtocol ( ) throws IOException { int resp = this . sendDummyRequest ( ) ; if ( ! this . sc . isSecureConnection ( ) ) { this . sc . setSecureConnection ( true ) ; try { resp = this . sendDummyRequest ( ) ; } catch ( SSLException e ) { this . sc . setSecureConnection ( false ) ; } } return resp ; }
tr	5	public PerlHash processDict ( XMLStreamReader reader ) { PerlHash map = new PerlHash ( ) ; XmlPullUtils . advanceToChildElement ( reader , PlistSchema . key . toString ( ) ) ; do { StringBuilder keyBuilder = new StringBuilder ( ) ; XmlPullUtils . advanceToEndOfElement ( reader , keyBuilder ) ; XmlPullUtils . advanceToNextSiblingElement ( reader ) ; PlistSchema tag = PlistSchema . valueOf ( reader . getLocalName ( ) ) ; switch ( tag ) { case array : if ( XmlPullUtils . advanceToChildElement ( reader , PlistSchema . dict . toString ( ) ) ) { PerlHash array = new PerlHash ( ) ; do { array . add ( processDict ( reader ) ) ; } while ( XmlPullUtils . advanceToNextSiblingElement ( reader ) ) ; map . put ( keyBuilder . toString ( ) , array ) ; } break ; case string : StringBuilder valueBuilder = new StringBuilder ( ) ; XmlPullUtils . advanceToEndOfElement ( reader , valueBuilder ) ; map . put ( keyBuilder . toString ( ) , valueBuilder . toString ( ) ) ; break ; default : log . warn ( "unknown element {}  dont know what to do..." , reader . getLocalName ( ) ) ; } } while ( XmlPullUtils . advanceToNextSiblingElement ( reader ) ) ; return map ; }
tr	5	public TreeNode sortedListToBST ( ListNode head ) { TreeNode median ; if ( head == null ) { return null ; } else if ( head . next == null ) { return new TreeNode ( head . val ) ; } ListNode step1 = head ; ListNode step2 = head ; ListNode preStep1 = head ; int count = 0 ; while ( step2 != null ) { if ( step2 . next == null ) break ; if ( count != 0 ) { preStep1 = preStep1 . next ; } step1 = step1 . next ; step2 = step2 . next . next ; count ++ ; } preStep1 . next = null ; median = new TreeNode ( step1 . val ) ; median . left = sortedListToBST ( head ) ; median . right = sortedListToBST ( step1 . next ) ; return median ; }
tr	4	private void showBoundingBoxV1 ( ) { if ( m_geometry == null ) { return ; } hideBoundingBox ( ) ; System . out . println ( "Showing Bounding Box Variant 1" ) ; PdVector c = m_geometry . getCenterOfGravity ( ) ; PdMatrix m = new PdMatrix ( 3 , 3 ) ; for ( int v = 0 ; v < m_geometry . getNumVertices ( ) ; ++ v ) { PdVector p = m_geometry . getVertex ( v ) ; for ( int i = 0 ; i < 3 ; ++ i ) { for ( int j = 0 ; j < 3 ; ++ j ) { double val = ( p . getEntry ( i ) - c . getEntry ( i ) ) * ( p . getEntry ( j ) - c . getEntry ( j ) ) ; m . setEntry ( i , j , m . getEntry ( i , j ) + val ) ; } } } m_boundingBox = getBoundingBox ( m ) ; m_disp . addGeometry ( m_boundingBox ) ; m_disp . update ( m_boundingBox ) ; }
tr	6	@ Override public void addCancelSet ( String taskId , LinkedList < String > cancelSetIds ) throws YSpecBuildException { if ( taskId == null ) throw new YSpecBuildException ( "taskId must not be null." ) ; if ( cancelSetIds == null ) throw new YSpecBuildException ( "cancelSetIds must not be null." ) ; if ( kinds . get ( taskId ) != null ) { if ( ! kinds . get ( taskId ) . isTask ( ) ) { throw new YSpecBuildException ( "The id allready belongs " + "to an element that is not a task" ) ; } } assert containerNet . get ( taskId ) != null ; for ( String s : cancelSetIds ) { if ( ! elems . contains ( s ) ) { this . elems . add ( s ) ; this . containerNet . put ( s , containerNet . get ( taskId ) ) ; this . kinds . put ( s , ElemTypes . _ANY ) ; } canceledBy . put ( s , taskId ) ; } cancelSets . put ( taskId , cancelSetIds ) ; }
tr	9	private boolean r_mark_regions ( ) { int v_1 ; int v_2 ; I_p1 = limit ; v_1 = cursor ; { int c = cursor + 3 ; if ( 0 > c || c > limit ) { return false ; } cursor = c ; } I_x = cursor ; cursor = v_1 ; golab0 : while ( true ) { v_2 = cursor ; lab1 : do { if ( ! ( in_grouping ( g_v , 97 , 248 ) ) ) { break lab1 ; } cursor = v_2 ; break golab0 ; } while ( false ) ; cursor = v_2 ; if ( cursor >= limit ) { return false ; } cursor ++ ; } golab2 : while ( true ) { lab3 : do { if ( ! ( out_grouping ( g_v , 97 , 248 ) ) ) { break lab3 ; } break golab2 ; } while ( false ) ; if ( cursor >= limit ) { return false ; } cursor ++ ; } I_p1 = cursor ; lab4 : do { if ( ! ( I_p1 < I_x ) ) { break lab4 ; } I_p1 = I_x ; } while ( false ) ; return true ; }
tr	9	public boolean rayIntersect ( double a [ ] , double b [ ] , double roots [ ] ) { mIinv . invert ( mI ) ; mIinv . transform ( a [ 0 ] , a [ 1 ] , a [ 2 ] , v ) ; mIinv . transform ( b [ 0 ] , b [ 1 ] , b [ 2 ] , w ) ; for ( int i = 0 ; i < 3 ; i ++ ) w [ i ] -= v [ i ] ; double A , B , C ; switch ( nQuadrics ) { case 1 : A = . ( w , w ) ; B = . ( v , w ) * 2 ; C = . ( v , v ) - 1.0 ; return quadraticRoots ( A , B , C , roots ) ; case 2 : A = w [ 0 ] * w [ 0 ] + w [ 1 ] * w [ 1 ] ; B = ( v [ 0 ] * w [ 0 ] + v [ 1 ] * w [ 1 ] ) * 2 ; C = v [ 0 ] * v [ 0 ] + v [ 1 ] * v [ 1 ] - 1 ; if ( quadraticRoots ( A , B , C , roots ) ) if ( quadraticPlaneRoots ( v [ 2 ] , w [ 2 ] , roots2 ) ) return intersect ( roots , roots2 ) ; break ; case 3 : if ( quadraticPlaneRoots ( v [ 0 ] , w [ 0 ] , roots ) ) if ( quadraticPlaneRoots ( v [ 1 ] , w [ 1 ] , roots2 ) ) if ( intersect ( roots , roots2 ) ) if ( quadraticPlaneRoots ( v [ 2 ] , w [ 2 ] , roots2 ) ) return intersect ( roots , roots2 ) ; break ; } return false ; }
tr	8	private Dimension layoutSize ( Container target , boolean preferred ) { synchronized ( target . getTreeLock ( ) ) { int targetWidth = target . getSize ( ) . width ; if ( targetWidth == 0 ) targetWidth = Integer . MAX_VALUE ; int hgap = getHgap ( ) ; int vgap = getVgap ( ) ; Insets insets = target . getInsets ( ) ; int horizontalInsetsAndGap = insets . left + insets . right + ( hgap * 2 ) ; int maxWidth = targetWidth - horizontalInsetsAndGap ; Dimension dim = new Dimension ( 0 , 0 ) ; int rowWidth = 0 ; int rowHeight = 0 ; int nmembers = target . getComponentCount ( ) ; for ( int i = 0 ; i < nmembers ; i ++ ) { Component m = target . getComponent ( i ) ; if ( m . isVisible ( ) ) { Dimension d = preferred ? m . getPreferredSize ( ) : m . getMinimumSize ( ) ; if ( rowWidth + d . width > maxWidth ) { addRow ( dim , rowWidth , rowHeight ) ; rowWidth = 0 ; rowHeight = 0 ; } if ( rowWidth != 0 ) { rowWidth += hgap ; } rowWidth += d . width ; rowHeight = Math . max ( rowHeight , d . height ) ; } } addRow ( dim , rowWidth , rowHeight ) ; dim . width += horizontalInsetsAndGap ; dim . height += insets . top + insets . bottom + vgap * 2 ; Container scrollPane = SwingUtilities . getAncestorOfClass ( JScrollPane . class , target ) ; if ( scrollPane != null && target . isValid ( ) ) { dim . width -= ( hgap + 1 ) ; } return dim ; } }
tr	6	public int getScore ( int [ ] faceValues ) throws IllegalArgumentException { int score = 0 ; int [ ] compareArray = new int [ 6 ] ; for ( int i = 0 ; i < faceValues . length ; i ++ ) { if ( faceValues [ i ] < 1 || faceValues [ i ] > 6 ) { throw new IllegalArgumentException ( "FaceValues have to be between 1 and 6." ) ; } compareArray [ faceValues [ i ] - 1 ] += 1 ; } for ( int j = 0 ; j < compareArray . length ; j ++ ) { if ( compareArray [ j ] > 2 ) { for ( int i = 0 ; i < faceValues . length ; i ++ ) { score += faceValues [ i ] ; } } } return score ; }
tr	0	public int getRowCount ( ) { return data . length ; }
tr	6	public boolean containsPlayers ( int [ ] pl ) { boolean found = false ; for ( int p : pl ) { found = false ; for ( int s : sentinel ) { if ( s == p ) { found = true ; } } for ( int s : scourge ) { if ( s == p ) { found = true ; } } if ( ! found ) return false ; } return true ; }
tr	2	public void requestOpenPose ( int id ) { boolean continueToOpen = true ; if ( ! saved ) { continueToOpen = promptToSave ( ) ; } if ( continueToOpen ) { promptToOpen ( id ) ; } }
tr	4	private static String longestWordFromOtherWords1 ( String [ ] words ) { int rl = - 1 ; String lwfow = null ; Arrays . sort ( words , new stringComparator ( ) ) ; HashMap < String , boolean > wordMap = new HashMap < String , boolean > ( ) ; for ( String w : words ) { if ( ! wordMap . containsKey ( w ) ) { wordMap . put ( w , true ) ; } } for ( String w : words ) { wordMap . remove ( w ) ; rl = longestWordFromOtherWords ( wordMap , w ) ; wordMap . put ( w , true ) ; if ( rl > 0 ) { lwfow = w ; break ; } } return lwfow ; }
tr	5	public static double inverseSensorModel_old ( Point p , Point measurement , RobotState sensorState , int z , Sensor s ) { double result ; int r = Utils . euclideanDistance ( new Point ( sensorState . x , sensorState . y ) , p ) ; if ( z == - 1 ) { result = Config . LOGODD_START ; } else if ( r > Math . min ( s . zMax , z ) + Config . GRID_CELL_SIZE ) { result = Config . LOGODD_START ; } else if ( z < s . zMax && p . equals ( measurement ) ) { result = Config . LOGODD_OCCUPIED_CORRECT ; } else if ( r < z ) { result = Config . LOGODD_OCCUPIED_WRONG ; } else { result = Config . LOGODD_START ; } return result ; }
tr	8	public static ListNode swapPairs ( ListNode head ) { if ( head == null ) return null ; if ( head . next == null ) return head ; ListNode newHead = null ; boolean start = true ; ; ListNode first ; ListNode second ; ListNode thrid ; ListNode last = null ; while ( head != null && head . next != null ) { first = head ; second = head . next ; if ( last != null ) { last . next = second ; } if ( start ) { newHead = second ; start = false ; } if ( head . next . next != null ) { thrid = head . next . next ; first . next = thrid ; second . next = first ; head = thrid ; if ( head . next == null ) { break ; } } else { first . next = null ; second . next = first ; break ; } last = first ; } return newHead ; }
tr	9	private static void saveSystemState ( String filename ) { String out = getParameterValueList ( ) + "\n" ; out += "Changed per state \n" ; out += "\t Mayority \t Confidence \t Weight \t Missfire \n" ; if ( systemStateChangeds != null ) { for ( String systemTestType : systemStateChangeds . keySet ( ) ) { for ( String meth : systemStateChangeds . get ( systemTestType ) . keySet ( ) ) { out += meth + "\t" ; } break ; } out += "\n" ; for ( String systemTestType : systemStateChangeds . keySet ( ) ) { for ( String meth : systemStateChangeds . get ( systemTestType ) . keySet ( ) ) { out += systemStateChangeds . get ( systemTestType ) . get ( meth ) + "\t" ; } out += "\n" ; } } out += "\n" ; out += "\n" ; out += "\t Mayority \t Confidence \t Weight \t Missfire \n" ; if ( lastSystemTestPoints != null ) for ( String s : lastSystemTestPoints . keySet ( ) ) { out += "\t" + s + "\t" ; out += ( String . format ( "%.3f" , ( lastSystemTestScore . get ( s ) . get ( "Mayority" ) / lastSystemTestPoints . get ( s ) ) ) ) ; out += "\t" ; out += ( String . format ( "%.3f" , ( lastSystemTestScore . get ( s ) . get ( "Confidence" ) / lastSystemTestPoints . get ( s ) ) ) ) ; out += "\t" ; out += ( String . format ( "%.3f" , ( lastSystemTestScore . get ( s ) . get ( "Weight" ) / lastSystemTestPoints . get ( s ) ) ) ) ; out += "\t" ; out += ( String . format ( "%.3f" , ( lastSystemTestScore . get ( s ) . get ( "Missfire" ) / lastSystemTestPoints . get ( s ) ) ) ) ; out += "\n" ; } File f = new File ( filename ) ; try { if ( ! f . getParentFile ( ) . exists ( ) ) f . getParentFile ( ) . mkdirs ( ) ; if ( ! f . exists ( ) ) f . createNewFile ( ) ; FileWriter w = new FileWriter ( f ) ; w . write ( out ) ; w . flush ( ) ; w . close ( ) ; } catch ( IOException ex ) { Logger . getLogger ( ScienceTool . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } }
tr	7	public static void findMinMax ( ) { Scanner kbd = new Scanner ( System . in ) ; ObjectInputStream inputStream ; Species low = null , high = null , test ; String file ; System . out . println ( "Enter file name:" ) ; file = kbd . next ( ) ; try { inputStream = new ObjectInputStream ( new FileInputStream ( file ) ) ; try { low = high = ( Species ) inputStream . readObject ( ) ; while ( true ) { test = ( Species ) inputStream . readObject ( ) ; if ( test . getPopulation ( ) < low . getPopulation ( ) ) low = test ; if ( test . getPopulation ( ) > high . getPopulation ( ) ) high = test ; } } catch ( EOFException e ) { System . out . println ( "End of file." ) ; } } catch ( ClassNotFoundException e ) { System . out . println ( "No class found" ) ; } catch ( FileNotFoundException e ) { System . out . println ( "File not found." ) ; } catch ( IOException e ) { System . out . println ( e . getMessage ( ) ) ; } System . out . println ( "The low population species:  " ) ; System . out . println ( low ) ; System . out . println ( ) ; System . out . println ( "The high population species:  " ) ; System . out . println ( high ) ; }
tr	3	@ Test public void test ( ) { BufferedReader reader = null ; try { reader = new BufferedReader ( new FileReader ( "testData/stemmerTest.txt" ) ) ; OutputStream out = new FileOutputStream ( "testData/stemmerTestResult.txt" ) ; SnowballStemmerWrapper stemmer = new SnowballStemmerWrapper ( reader , out ) ; while ( stemmer . isAlive ( ) ) { } assertTrue ( checkFiles ( ) ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; fail ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }
tr	0	public SecurityServiceException ( String code , String message ) { this ( code , message , null ) ; }
tr	1	public static boolean bothIntegers ( Number number , Number otherNumber ) { return number instanceof Integer && otherNumber instanceof Integer ; }
tr	7	@ Override public Object getValueAt ( int i , int i1 ) { Tenant t = tenants . get ( i ) ; switch ( i1 ) { case 0 : return t . getId ( ) ; case 1 : return t . getName ( ) ; case 2 : return t . getAddress ( ) ; case 3 : return t . getTel ( ) ; case 4 : return t . getRoom ( ) ; case 5 : return t . getRentDate ( ) ; case 6 : return t . getPayStatus ( ) ; default : return null ; } }
tr	7	int [ ] getRowGaps ( ContainerWrapper parent , BoundSize defGap , int refSize , boolean before ) { BoundSize gap = before ? gapBefore : gapAfter ; if ( gap == null || gap . isUnset ( ) ) gap = defGap ; if ( gap == null || gap . isUnset ( ) ) return null ; int [ ] ret = new int [ 3 ] ; for ( int i = LayoutUtil . MIN ; i <= LayoutUtil . MAX ; i ++ ) { UnitValue uv = gap . getSize ( i ) ; ret [ i ] = uv != null ? uv . getPixels ( refSize , parent , null ) : LayoutUtil . NOT_SET ; } return ret ; }
tr	3	public int numTrees ( int n ) { if ( n == 0 || n == 1 ) return 1 ; int total = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int left = i - 1 ; int right = n - i ; total += numTrees ( left ) * numTrees ( right ) ; } return total ; }
tr	3	@ Override public EditorKit getEditorKitForContentType ( String type ) { if ( type . equalsIgnoreCase ( "text/html" ) || type . equalsIgnoreCase ( "application/xhtml+xml" ) || type . equalsIgnoreCase ( "text/xhtml" ) ) { return swingBoxEditorKit ; } else { return super . getEditorKitForContentType ( type ) ; } }
tr	0	public void settable_employeeListener ( MouseListener l ) { this . table_employee . addMouseListener ( l ) ; }
tr	6	public final void levelDone ( ) { if ( ! inGameState ( "InGame" ) || inGameState ( "LevelDone" ) || inGameState ( "LifeLost" ) || inGameState ( "GameOver" ) ) return ; clearKey ( key_continuegame ) ; removeGameState ( "StartLevel" ) ; removeGameState ( "StartGame" ) ; seqtimer = 0 ; if ( leveldone_ticks > 0 ) { if ( leveldone_ingame ) addGameState ( "LevelDone" ) ; else setGameState ( "LevelDone" ) ; new JGTimer ( leveldone_ticks , true , "LevelDone" ) { public void alarm ( ) { levelDoneToStartLevel ( ) ; } } ; } else { levelDoneToStartLevel ( ) ; } }
tr	5	public void updatePlaylist ( TrackBean track ) { if ( track == null ) { displayedTracks . clear ( ) ; } else if ( ! displayedTracks . isEmpty ( ) ) { if ( displayedTracks . size ( ) != 1 ) { if ( displayedTracks . get ( 1 ) . equals ( track ) ) { displayedTracks . remove ( 0 ) ; } else if ( ! displayedTracks . get ( 0 ) . equals ( track ) ) { displayedTracks . add ( 0 , track ) ; } } } playlistTableModel . fireTableDataChanged ( ) ; }
tr	6	public void addPoint ( float p ) { if ( p < this . min || p > this . max ) return ; if ( p == this . max ) { this . bins [ count - 1 ] ++ ; return ; } float temp = ( p - this . min ) / ( this . max - this . min ) ; for ( int i = 0 ; i < this . count ; i ++ ) if ( temp >= this . h * i && temp < this . h * ( i + 1 ) ) { this . bins [ i ] ++ ; return ; } }
tr	7	private int [ ] merge ( int [ ] leftArray , int [ ] rightArray ) { int mergedLength = leftArray . length + rightArray . length ; int [ ] mergedArray = new int [ mergedLength ] ; int leftIndex = 0 ; int rightIndex = 0 ; while ( leftIndex + rightIndex < mergedLength ) { if ( leftIndex < leftArray . length && rightIndex < rightArray . length ) { if ( leftArray [ leftIndex ] <= rightArray [ rightIndex ] ) { mergedArray [ leftIndex + rightIndex ] = leftArray [ leftIndex ] ; leftIndex ++ ; } else { mergedArray [ leftIndex + rightIndex ] = rightArray [ rightIndex ] ; rightIndex ++ ; } } else if ( leftIndex < leftArray . length ) { while ( leftIndex < leftArray . length ) { mergedArray [ leftIndex + rightIndex ] = leftArray [ leftIndex ] ; leftIndex ++ ; } } else { while ( rightIndex < rightArray . length ) { mergedArray [ leftIndex + rightIndex ] = rightArray [ rightIndex ] ; rightIndex ++ ; } } } return mergedArray ; }
tr	2	public AccountPermissions read ( String id ) { log . debug ( "reading " + entitySimpleName + " instance with id: " + id ) ; AccountPermissions instance = null ; try { instance = ( AccountPermissions ) super . read ( entityFullName , id ) ; log . debug ( entitySimpleName + " read successful  instance found" ) ; } catch ( EntityNotFoundException ex ) { log . error ( entitySimpleName + " read successful  no instance found" , ex ) ; } catch ( RuntimeException re ) { log . error ( entitySimpleName + " read failed" , re ) ; throw re ; } return instance ; }
tr	7	public Object getValueAt ( int rowIndex , int columnIndex ) { Group group = groupList . get ( rowIndex ) ; switch ( columnIndex ) { case 0 : return group . getName ( ) ; case 1 : return group . getLevel ( ) . getName ( ) ; case 2 : return group . getTeacher ( ) ; case 3 : return group . getCapacity ( ) ; case 4 : String scheduleText = "" ; for ( Group_schedule s : group . getSchedule ( ) ) { scheduleText += s . getName ( ) + " | " ; } return scheduleText ; case - 1 : return group ; } return "" ; }
tr	4	private AVLNode < E > verificationRight ( AVLNode < E > pnodo ) { switch ( pnodo . getBalance ( ) ) { case 0 : pnodo . setBalance ( 1 ) ; break ; case - 1 : _increase = false ; pnodo . setBalance ( 0 ) ; case 1 : AVLNode < E > right = pnodo . getRight ( ) ; if ( right . getBalance ( ) == 1 ) { pnodo = rotationRightRight ( pnodo ) ; } else { pnodo = rotationRightLeft ( pnodo ) ; } _increase = false ; break ; } return pnodo ; }
tr	3	public Color getColour ( ) { try { String colour_name = fName . toLowerCase ( ) ; Field f = Color . class . getField ( colour_name ) ; if ( f != null ) { Color c = ( Color ) f . get ( null ) ; if ( c != null ) return c ; } } catch ( Exception ex ) { } return Color . RED ; }
tr	9	private Set < Integer > findGivenValueInCol ( int value , int startPoint , int numberOfFinds ) { Set < Integer > valueLocations = new HashSet < Integer > ( ) ; int stopPoint = ( int ) Math . pow ( this . getSize ( ) , 2 ) ; int nextColCellNumber = this . getSize ( ) ; int foundNumber = 0 ; if ( numberOfFinds == 0 ) { foundNumber -- ; } boolean stopSearching = false ; Set < Integer > currentSet = new HashSet < Integer > ( ) ; for ( int i = startPoint ; i < stopPoint && ! stopSearching ; i += nextColCellNumber ) { if ( getElementWithNumber ( i ) == EMPTY_ELEMENT_VALUE ) { currentSet . addAll ( this . validElementsCache . get ( i ) ) ; for ( int valueTest : currentSet ) { if ( value == valueTest && foundNumber < numberOfFinds ) { valueLocations . add ( i ) ; if ( numberOfFinds != 0 ) { foundNumber ++ ; } } else if ( value == valueTest ) { valueLocations . clear ( ) ; stopSearching = true ; break ; } } currentSet . clear ( ) ; } } return ( valueLocations ) ; }
tr	1	protected void check ( String method ) { if ( mAmShutdown ) throw new RuntimeException ( "NetBase." + method + " called when NetBase isn't in initialized state" ) ; }
tr	0	protected LevelCreator ( ) { level = new Level ( ) ; loaded = false ; }
tr	3	private void removeOutTransferActionPerformed ( java . awt . event . ActionEvent evt ) { int items_to_delete [ ] = null ; if ( ! outgoingTransferList . isSelectionEmpty ( ) ) { items_to_delete = outgoingTransferList . getSelectedIndices ( ) ; } else { return ; } if ( items_to_delete != null ) { for ( int i = items_to_delete . length - 1 ; i >= 0 ; i -- ) { outgoingItems . elementAt ( i ) . cancel ( ) ; outgoingItems . elementAt ( i ) . cleanup ( ) ; outgoingItems . remove ( items_to_delete [ i ] ) ; } } }
tr	0	public boolean isAlreadyExistPassenger ( Passenger passenger ) { log . debug ( "Start isAlreadyExistPassenger select" ) ; List results = em . createQuery ( "select count(*)\n" + "from Passenger passenger \n" + "where passenger.firstname = ?\n" + "and passenger.lastname = ?\n" + "and passenger.birthday = ?" ) . setParameter ( 1 , passenger . getFirstname ( ) ) . setParameter ( 2 , passenger . getLastname ( ) ) . setParameter ( 3 , passenger . getBirthday ( ) ) . getResultList ( ) ; return ( long ) results . get ( 0 ) != 0 ; }
tr	9	public boolean execute ( CommandSender sender , String [ ] args ) { String groupName = args [ 0 ] ; GroupManager groupManager = Citadel . getGroupManager ( ) ; Faction group = groupManager . getGroup ( groupName ) ; if ( group == null ) { sendMessage ( sender , ChatColor . RED , "Group doesn't exist" ) ; return true ; } String senderName = sender . getName ( ) ; if ( ! group . isFounder ( senderName ) ) { sendMessage ( sender , ChatColor . RED , "Invalid permission to transfer this group" ) ; return true ; } if ( group . isPersonalGroup ( ) ) { sendMessage ( sender , ChatColor . RED , "You cannot transfer your default group" ) ; return true ; } String targetName = args [ 1 ] ; if ( senderName . equalsIgnoreCase ( targetName ) ) { sendMessage ( sender , ChatColor . RED , "You already own this group" ) ; return true ; } int groupsAllowed = Citadel . getConfigManager ( ) . getGroupsAllowed ( ) ; if ( groupManager . getPlayerGroupsAmount ( targetName ) >= groupsAllowed ) { sendMessage ( sender , ChatColor . RED , "This player has already reached the maximum amount of groups allowed" ) ; return true ; } MemberManager memberManager = Citadel . getMemberManager ( ) ; if ( ! memberManager . isOnline ( targetName ) ) { sendMessage ( sender , ChatColor . RED , "User must be online" ) ; return true ; } Member member = memberManager . getMember ( targetName ) ; if ( member == null ) { member = new Member ( targetName ) ; memberManager . addMember ( member ) ; } if ( group . isMember ( targetName ) ) { groupManager . removeMemberFromGroup ( groupName , targetName ) ; } if ( group . isModerator ( targetName ) ) { groupManager . removeModeratorFromGroup ( groupName , targetName ) ; } group . setFounder ( targetName ) ; groupManager . addGroup ( group ) ; sendMessage ( sender , ChatColor . GREEN , "You have transferred %s to %s" , groupName , targetName ) ; if ( memberManager . isOnline ( targetName ) ) { sendMessage ( memberManager . getOnlinePlayer ( targetName ) , ChatColor . YELLOW , "%s has transferred the group %s to you" , senderName , groupName ) ; } return true ; }
tr	8	final public HelpCommandCommand HelpCommand_suffix ( ) throws ParseException { HelpCommandCommand . Type type ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case KW_CREATE : jj_consume_token ( KW_CREATE ) ; jj_consume_token ( KW_TABLE ) ; type = HelpCommandCommand . Type . CREATE_TABLE ; break ; case KW_DROP : jj_consume_token ( KW_DROP ) ; jj_consume_token ( KW_TABLE ) ; type = HelpCommandCommand . Type . DROP_TABLE ; break ; case KW_SELECT : jj_consume_token ( KW_SELECT ) ; type = HelpCommandCommand . Type . SELECT ; break ; case KW_INSERT : jj_consume_token ( KW_INSERT ) ; type = HelpCommandCommand . Type . INSERT ; break ; case KW_DELETE : jj_consume_token ( KW_DELETE ) ; type = HelpCommandCommand . Type . DELETE ; break ; case KW_UPDATE : jj_consume_token ( KW_UPDATE ) ; type = HelpCommandCommand . Type . UPDATE ; break ; default : jj_la1 [ 21 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } { if ( true ) return new HelpCommandCommand ( token , type ) ; } throw new Error ( "Missing return statement in function" ) ; }
tr	5	@ Override public String getMCstring ( ) { String s = "" ; for ( int i = 0 ; i < mc . length ; i ++ ) { if ( mc [ i ] == true ) s = s . concat ( "1" ) ; else s = s . concat ( "0" ) ; if ( i == 5 || i == 10 || i == 15 ) s = s . concat ( " " ) ; } return s ; }
tr	5	Document createDocument ( DocumentType docType , QName rootElement ) throws FastInfosetException { DocumentBuilderFactory dbf = DocumentBuilderFactory . newInstance ( ) ; dbf . setNamespaceAware ( true ) ; DOMImplementation domImplementation ; try { domImplementation = dbf . newDocumentBuilder ( ) . getDOMImplementation ( ) ; } catch ( ParserConfigurationException ex ) { throw new FastInfosetException ( ex ) ; } org . w3c . dom . DocumentType createDocumentType = null ; if ( docType != null ) createDocumentType = domImplementation . createDocumentType ( rootElement . getLocalPart ( ) , docType . publicIdentifier , docType . systemIdentifier ) ; Document doc = domImplementation . createDocument ( rootElement . getNamespaceURI ( ) , rootElement . getPrefix ( ) . isEmpty ( ) ? rootElement . getLocalPart ( ) : rootElement . getPrefix ( ) + ":" + rootElement . getLocalPart ( ) , createDocumentType ) ; for ( ProcessingInstruction pi : _pis ) { doc . insertBefore ( doc . createProcessingInstruction ( pi . target , pi . content ) , doc . getDocumentElement ( ) ) ; } for ( String str : _comments ) { doc . insertBefore ( doc . createComment ( str ) , doc . getDocumentElement ( ) ) ; } setVersionAndStandAlone ( doc ) ; return doc ; }
tr	1	public void setSlash ( ) { if ( System . getProperty ( "os.name" ) . contains ( "Window" ) ) this . / = "\\" ; else this . / = "/" ; }
tr	4	public void focusOnHour ( int hour ) { if ( hour > 23 || hour < 0 ) return ; final JScrollBar vs = weekScroll . getVerticalScrollBar ( ) ; if ( hour < SHOWHOURS / 2 ) hour = SHOWHOURS / 2 ; if ( hour > ( 23 - SHOWHOURS / 2 ) ) hour = ( 23 - SHOWHOURS / 2 ) ; hour -= SHOWHOURS / 2 ; vs . setValue ( hour * vs . getMaximum ( ) / 2 / SHOWHOURS ) ; }
tr	2	public static String timeUsedToString ( long time ) { String result ; if ( time < 1000 ) result = time + " ms" ; else if ( time < 60000 ) { long remainder = time % MILI_IN_SEC ; result = time / MILI_IN_SEC + " sec " + remainder + " ms" ; } else { long secs = time / MILI_IN_SEC ; long remainder = secs % SEC_IN_MIN ; result = secs / SEC_IN_MIN + " min " + remainder + " sec" ; } return result ; }
tr	1	@ Test public void testIsEmptyDirection ( ) { for ( Direction dir : Direction . values ( ) ) { assertFalse ( testTile . isEmpty ( dir ) ) ; } }
tr	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( MainBoard . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( MainBoard . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( MainBoard . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( MainBoard . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { new MainBoard ( ) . setVisible ( true ) ; } } ) ; }
tr	9	public void activateCode ( ) { try { xmlFile = app . getFile ( ) ; Document doc = builder . build ( xmlFile ) ; Element rootNode = doc . getRootElement ( ) ; String string = rootNode . getChildText ( "compressedThingMap" ) ; byte [ ] byteArray = Base64 . decodeBase64 ( string . getBytes ( ) ) ; for ( int i = 0 ; i < byteArray . length ; i ++ ) { if ( byteArray [ i ] == 56 || byteArray [ i ] == 57 ) { byteArray [ i ] = 0 ; } } String newCMT = new String ( Base64 . encodeBase64 ( byteArray ) ) ; rootNode . getChild ( "compressedThingMap" ) . setText ( newCMT ) ; Iterator < Element > c = rootNode . getDescendants ( new ElementFilter ( "def" ) ) ; List < Element > markedToBeRemoved = new ArrayList < Element > ( ) ; while ( c . hasNext ( ) ) { Element e = c . next ( ) ; if ( e . getValue ( ) . equalsIgnoreCase ( "SandbagRubble" ) || e . getValue ( ) . equalsIgnoreCase ( "FilthSand" ) || e . getValue ( ) . equalsIgnoreCase ( "FilthDirt" ) || e . getValue ( ) . equalsIgnoreCase ( "DebrisSlag" ) || e . getValue ( ) . equalsIgnoreCase ( "RockRubble" ) ) { if ( e . getParentElement ( ) . getName ( ) . equalsIgnoreCase ( "thing" ) ) { markedToBeRemoved . add ( e . getParentElement ( ) ) ; } } } for ( int i = 0 ; i < markedToBeRemoved . size ( ) ; i ++ ) { Element e = markedToBeRemoved . get ( i ) ; e . getParentElement ( ) . removeContent ( e ) ; } Notification . createInfoNotification ( "All rubbish has been removed" , 3000 ) ; XMLOutputter xmlOutput = new XMLOutputter ( ) ; FileWriter fw = new FileWriter ( xmlFile ) ; xmlOutput . setFormat ( Format . getRawFormat ( ) ) ; xmlOutput . output ( doc , fw ) ; fw . flush ( ) ; fw . close ( ) ; app . setFile ( xmlFile ) ; } catch ( IOException io ) { io . printStackTrace ( ) ; } catch ( JDOMException e ) { e . printStackTrace ( ) ; } }
tr	1	private void write ( Kim kim , int from , int thru , Huff huff ) throws JSONException { for ( int at = from ; at < thru ; at += 1 ) { write ( kim . get ( at ) , huff ) ; } }
tr	8	public Object getAttribute ( String fieldName ) throws RemoteException { if ( ! isInitialized ( ) ) throw new RemoteException ( "object not initialized." ) ; if ( fieldName == null ) return null ; Object o = properties . get ( fieldName ) ; if ( o == null ) { if ( fieldName . equalsIgnoreCase ( getIDField ( ) ) ) return getID ( ) ; return null ; } if ( o instanceof DBObject ) return o ; class foreign = getForeignObject ( fieldName ) ; if ( foreign != null ) { String id = o . toString ( ) ; DBObject cachedObject = ( DBObject ) foreignObjectCache . get ( foreign . getName ( ) + fieldName ) ; if ( cachedObject != null ) { if ( ! id . equals ( cachedObject . getID ( ) ) ) cachedObject . load ( id ) ; } else { cachedObject = service . createObject ( foreign , id ) ; foreignObjectCache . put ( foreign . getName ( ) + fieldName , cachedObject ) ; } return cachedObject ; } return o ; }
tr	6	public void scores ( Player player ) { switch ( player . getScore ( ) ) { case LOVE : player . setScore ( FIFTEEN ) ; break ; case FIFTEEN : player . setScore ( THIRTY ) ; break ; case THIRTY : determineFortyOrDeuce ( player ) ; break ; case DEUCE : determineAdvantageOrDeuce ( player ) ; break ; case FORTY : case ADVANTAGE : player . setScore ( WIN ) ; } }
tr	5	public void fileSave ( SimpleFrame frame ) { File tempFile = new File ( frame . tempFileName ) ; if ( tempFile . exists ( ) ) tempFile . delete ( ) ; if ( ! frame . getIsFileNameSetted ( ) ) { JFileChooser chooser = new JFileChooser ( ) ; chooser . setCurrentDirectory ( new File ( "." ) ) ; int result = chooser . showSaveDialog ( null ) ; if ( result == JFileChooser . APPROVE_OPTION ) { frame . fileName = chooser . getSelectedFile ( ) . getPath ( ) ; PrintWriter out ; try { out = new PrintWriter ( new FileWriter ( frame . fileName ) ) ; String str = frame . getText ( ) . getText ( ) ; out . print ( str ) ; out . close ( ) ; frame . setIsChanged ( false ) ; } catch ( IOException e ) { JOptionPane . showMessageDialog ( frame , "Saving error" ) ; } } } else { PrintWriter out ; try { out = new PrintWriter ( new FileWriter ( frame . fileName ) ) ; String str = frame . getText ( ) . getText ( ) ; out . print ( str ) ; out . close ( ) ; } catch ( IOException e ) { JOptionPane . showMessageDialog ( frame , "Saving error" ) ; } } frame . setIsFileNameSetted ( true ) ; frame . setTitle ( "Text Editor - " + frame . fileName ) ; }
tr	7	public String animate ( double speedmul ) { String ret = getCurrentFrame ( ) ; if ( running ) { phase += speed * speedmul ; while ( phase >= 1.0 ) { phase -= 1.0 ; framenr += increment ; if ( ! pingpong ) { if ( framenr >= frames . length ) framenr -= frames . length ; if ( framenr < 0 ) framenr += frames . length ; } else { if ( framenr >= frames . length ) { framenr -= 2 * increment ; increment = - increment ; } if ( framenr < 0 ) { framenr -= 2 * increment ; increment = - increment ; } } } } return ret ; }
tr	7	private void outputConsequenceInfo ( ) { try { String all_attacks = getAllAttacks ( ) ; Set < String > attack_ids = unify ( all_attacks . split ( " " ) ) ; CAPECXMLQuerying xmlQuery = new CAPECXMLQuerying ( ) ; LinkedList < AttackPattern > all_detailed_attacks = new LinkedList < AttackPattern > ( ) ; for ( String attack_id : attack_ids ) { AttackPattern attack = xmlQuery . getAttackInfo ( attack_id ) ; all_detailed_attacks . add ( attack ) ; } DocumentBuilderFactory docFactory = DocumentBuilderFactory . newInstance ( ) ; DocumentBuilder docBuilder = docFactory . newDocumentBuilder ( ) ; Document doc = docBuilder . newDocument ( ) ; Element rootElement = doc . createElement ( "capec:Domain_Mappings" ) ; doc . appendChild ( rootElement ) ; rootElement . setAttribute ( "xmlns:capec" , "http://capec.mitre.org/capec-2" ) ; rootElement . setAttribute ( "xmlns:xsi" , "http://www.w3.org/2001/XMLSchema-instance" ) ; rootElement . setAttribute ( "Catalog_Name" , "CAPEC" ) ; rootElement . setAttribute ( "Catalog_Version" , "2.6" ) ; rootElement . setAttribute ( "Catalog_Data" , "2014-06-23" ) ; rootElement . setAttribute ( "xsi:schemaLocation" , "http://capec.mitre.org/capec-2 " + "http://capec.mitre.org/data/xsd/ap_schema_v2.7.xsd  http://cybox.mitre.org/cybox-2 " + "http://cybox.mitre.org/XMLSchema/core/2.1/cybox_core.xsd" ) ; int count = 0 ; for ( AttackPattern single_attack : all_detailed_attacks ) { if ( ! single_attack . methods . getFirst ( ) . contains ( "empty" ) || ! single_attack . consequences . getFirst ( ) . contains ( "empty" ) ) { count ++ ; Element attack = doc . createElement ( "capec:Attack_Pattern" ) ; rootElement . appendChild ( attack ) ; attack . setAttribute ( "name" , single_attack . name ) ; attack . setAttribute ( "id" , single_attack . id ) ; Element attack_description = doc . createElement ( "capec:Attack_Pattern_Description" ) ; attack_description . setTextContent ( single_attack . description ) ; attack . appendChild ( attack_description ) ; Element attack_prerequisite = doc . createElement ( "capec:Attack_Pattern_Prerequisite" ) ; attack_prerequisite . setTextContent ( listToString ( single_attack . prerequisites . toArray ( ) ) ) ; attack . appendChild ( attack_prerequisite ) ; Element attack_method = doc . createElement ( "capec:Attack_Pattern_Method" ) ; attack_method . setTextContent ( listToString ( single_attack . methods . toArray ( ) ) ) ; attack . appendChild ( attack_method ) ; Element attack_consequence = doc . createElement ( "capec:Attack_Pattern_Consequence" ) ; attack_consequence . setTextContent ( listToString ( single_attack . consequences . toArray ( ) ) ) ; attack . appendChild ( attack_consequence ) ; } } TransformerFactory transformerFactory = TransformerFactory . newInstance ( ) ; Transformer transformer = transformerFactory . newTransformer ( ) ; DOMSource source = new DOMSource ( doc ) ; StreamResult result = new StreamResult ( new File ( "attack_methods_consequences.xml" ) ) ; transformer . transform ( source , result ) ; System . out . println ( count + " patterns are printed!" ) ; } catch ( ParserConfigurationException pce ) { pce . printStackTrace ( ) ; } catch ( TransformerException tfe ) { tfe . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }
tr	0	public scanner ( ) throws java . io . IOException { this ( System . in ) ; }
tr	8	private void writeJSON ( Object value ) throws JSONException { if ( JSONObject . null . equals ( value ) ) { write ( zipNull , 3 ) ; } else if ( boolean . false . equals ( value ) ) { write ( zipFalse , 3 ) ; } else if ( boolean . true . equals ( value ) ) { write ( zipTrue , 3 ) ; } else { if ( value instanceof Map ) { value = new JSONObject ( ( Map ) value ) ; } else if ( value instanceof Collection ) { value = new JSONArray ( ( Collection ) value ) ; } else if ( value . getClass ( ) . isArray ( ) ) { value = new JSONArray ( value ) ; } if ( value instanceof JSONObject ) { writeObject ( ( JSONObject ) value ) ; } else if ( value instanceof JSONArray ) { writeArray ( ( JSONArray ) value ) ; } else { throw new JSONException ( "Unrecognized object" ) ; } } }
tr	1	public void closeWriter ( ) { try { this . writer . flush ( ) ; this . writer . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }
tr	6	public Color getColor ( VesselType type ) { switch ( type ) { case SWIMMER : return Color . PINK ; case SPEED_BOAT : return Color . GREEN ; case FISHING_BOAT : return Color . CYAN ; case CARGO_BOAT : return Color . ORANGE ; case PASSENGER_VESSEL : return Color . MAGENTA ; case UNKNOWN : return Color . WHITE ; default : return Color . WHITE ; } }
tr	3	public static void startClient ( ) { if ( ( client != null ) && client . isAlive ( ) ) { return ; } try { client = new Client ( ( Inet4Address ) Inet4Address . getLocalHost ( ) , Constants . port ) ; client . start ( ) ; } catch ( Exception e ) { GameLog . warn ( e ) ; } }
tr	2	public void save ( String filename ) { PrintWriter pw = null ; try { pw = new PrintWriter ( new BufferedWriter ( new FileWriter ( filename ) ) ) ; pw . println ( "<?xml version=\"1.0\" encoding=\"UTF-8\"?>" ) ; pw . println ( "<dmc prob=\"" + totalProb + "\">" ) ; for ( State st : this . estats ) { st . writeMarkov ( pw ) ; } pw . println ( "</dmc>" ) ; } catch ( IOException ex ) { System . err . println ( "Error saving DMC" ) ; } finally { pw . close ( ) ; } }
tr	7	void funcargs ( ExpDesc f ) { FuncState fs = this . fs ; ExpDesc args = new ExpDesc ( ) ; int base , nparams ; int line = this . linenumber ; switch ( this . t . token ) { case ( : { if ( line != this . lastline ) this . syntaxerror ( "ambiguous syntax (function call x new statement)" ) ; this . next ( ) ; if ( this . t . token == ) ) args . k = VVOID ; else { this . explist1 ( args ) ; fs . setmultret ( args ) ; } this . check_match ( ) , ( , line ) ; break ; } case { : { this . constructor ( args ) ; break ; } case TK_STRING : { this . codestring ( args , this . t . ts ) ; this . next ( ) ; break ; } default : { this . syntaxerror ( "function arguments expected" ) ; return ; } } FuncState . _assert ( f . k == VNONRELOC ) ; base = f . info ; if ( hasmultret ( args . k ) ) nparams = FuncState . LUA_MULTRET ; else { if ( args . k != VVOID ) fs . exp2nextreg ( args ) ; nparams = fs . freereg - ( base + 1 ) ; } f . init ( VCALL , fs . codeABC ( FuncState . OP_CALL , base , nparams + 1 , 2 ) ) ; fs . fixline ( line ) ; fs . freereg = base + 1 ; }
tr	0	public InstanceList ( class < T > clazz ) { super ( ) ; this . clazz = clazz ; }
