va	5	private Command getCommand ( String path ) { final String c = path2Class ( path ) ; if ( c == null ) { return null ; } try { final class < ? > clazz = class . forName ( c ) ; if ( Command . class . isAssignableFrom ( clazz ) ) { return ( Command ) clazz . newInstance ( ) ; } } catch ( InstantiationException ie ) { } catch ( Exception e ) { Sys . warning ( e ) ; e . printStackTrace ( ) ; } return null ; }
va	0	public void removeTreeModelListener ( TreeModelListener l ) { }
va	1	private void setTitle ( ) { String intercepting = intercepting ( ) ? "intercepting" : "not intercepting" ; this . getFrame ( ) . setTitle ( "Gizmo. Proxying on [" + port + "]  " + intercepting ) ; }
va	9	protected void startDownload ( final Download download ) { download . setPath ( UserPreferences . PREF_DOWNLOAD_TARGET ) ; final Thread t = new Thread ( download ) ; t . start ( ) ; ms . changeTrayIcon ( true ) ; Runnable statusUpdater = new Runnable ( ) { @ Override public void run ( ) { try { String status ; float downloadPercent = 0.0f ; long prevSystemTime = System . currentTimeMillis ( ) , currentSystemTime ; long prevDownloadedAmount = download . getDownloadedAmount ( ) ; long currentDownloadedAmount = download . getDownloadedAmount ( ) ; LeafNode leaf ; while ( t . isAlive ( ) ) { leaf = GuiOperations . getLeaf ( ms , download . getItem ( ) ) ; if ( leaf != null ) { if ( download . getDownloadedAmount ( ) == 0 ) { status = "Starting download" ; prevSystemTime = System . currentTimeMillis ( ) ; } else if ( download . isCanceled ( ) ) { status = "Canceling download" ; downloadPercent = 0f ; } else if ( download . isCompleted ( ) ) { status = "Completing download" ; } else if ( download . isPaused ( ) ) { status = GuiOperations . getReadableSize ( currentDownloadedAmount ) + " / " + GuiOperations . getReadableSize ( download . getTotalLength ( ) ) + " (Paused)" ; download . setCurrentSpeed ( 0.0 ) ; } else { currentSystemTime = System . currentTimeMillis ( ) ; currentDownloadedAmount = download . getDownloadedAmount ( ) ; if ( currentSystemTime == prevSystemTime ) currentSystemTime ++ ; double downloadSpeed = ( ( currentDownloadedAmount - prevDownloadedAmount ) / 1048576.0 ) / ( ( currentSystemTime - prevSystemTime ) / 1000.0 ) ; download . setCurrentSpeed ( downloadSpeed ) ; double timeRemaining = Math . round ( ( download . getTotalLength ( ) - currentDownloadedAmount ) / ( download . getCurrentAvgSpeed ( ) * 1048.576 ) ) ; int seconds = ( int ) ( timeRemaining / 1000 ) % 60 ; int minutes = ( int ) ( ( timeRemaining / ( 1000 * 60 ) ) % 60 ) ; int hours = ( int ) ( ( timeRemaining / ( 1000 * 60 * 60 ) ) % 24 ) ; String timeRemainingTxt = String . format ( "%02d:%02d:%02d" , hours , minutes , seconds ) ; String readableDownloadSpeed = GuiOperations . getReadableFromMBSize ( download . getCurrentAvgSpeed ( ) ) ; prevSystemTime = currentSystemTime ; prevDownloadedAmount = currentDownloadedAmount ; downloadPercent = ( float ) currentDownloadedAmount / ( float ) download . getTotalLength ( ) ; status = GuiOperations . getReadableSize ( currentDownloadedAmount ) + " / " + GuiOperations . getReadableSize ( download . getTotalLength ( ) ) + " (" + readableDownloadSpeed + "/s)" + " ETA : " + timeRemainingTxt ; } leaf . setDownPerc ( downloadPercent ) ; leaf . setStatus ( status ) ; ms . getItemPanel ( ) . repaint ( ) ; } Thread . sleep ( 1000 ) ; } } catch ( Exception e ) { StringWriter sw = new StringWriter ( ) ; e . printStackTrace ( new PrintWriter ( sw ) ) ; System . out . println ( sw . toString ( ) ) ; } finally { synchronized ( activeDownloads ) { activeDownloads . remove ( download . getItem ( ) . getId ( ) ) ; } LeafNode leaf = GuiOperations . getLeaf ( ms , download . getItem ( ) ) ; if ( leaf != null ) { if ( ! download . isFaulty ( ) ) { leaf . setStatus ( "Completed" ) ; leaf . setDownPerc ( 1.0f ) ; download . setDownloadedAmount ( download . getTotalLength ( ) ) ; if ( ! connection . refresh ( ) || ! download . delete ( ) ) { leaf . setStatus ( "Completed (Couldn't be deleted)" ) ; } } else { if ( ! download . isCanceled ( ) ) { leaf . setStatus ( "Error : " + download . getErrorMsg ( ) ) ; } else { leaf . setStatus ( "Canceled" ) ; download . setDownloadedAmount ( 0 ) ; } } ms . getItemPanel ( ) . updateDownload ( download ) ; ms . getItemPanel ( ) . repaint ( ) ; } ms . changeTrayIcon ( activeDownloads . size ( ) > 0 ) ; } } } ; Thread ts = new Thread ( statusUpdater ) ; ts . start ( ) ; }
va	0	public static void castM3 ( final float result [ ] , final float [ ] matrix ) { result [ 0 ] = matrix [ 0 ] ; result [ 1 ] = matrix [ 1 ] ; result [ 2 ] = matrix [ 2 ] ; result [ 3 ] = matrix [ 4 ] ; result [ 4 ] = matrix [ 5 ] ; result [ 5 ] = matrix [ 6 ] ; result [ 6 ] = matrix [ 8 ] ; result [ 7 ] = matrix [ 9 ] ; result [ 8 ] = matrix [ 10 ] ; }
va	8	public static Graph < Vertex , Edge > loadModel ( String filename , int flags ) { Graph < Vertex , Edge > myModel = new Graph < Vertex , Edge > ( Edge . class ) ; Document document = null ; document = BPMNModelUtils . parseDocument ( filename , true , new LinkedList < ErrorMessage > ( ) ) ; if ( document != null ) { BPMNModelCodec myCodec = new BPMNModelCodec ( ) ; eDefinitions myDef = new eDefinitions ( ) ; myCodec . decode ( document . getDocumentElement ( ) , myDef ) ; for ( String key : myCodec . getBPMNElementMap ( ) . keySet ( ) ) { saveElement ( myCodec . getBPMNElementMap ( ) . get ( key ) , flags , "" ) ; } for ( TNode r : tNodes . values ( ) ) { myModel . addV ( r . node ) ; } for ( String key : tEdges . keySet ( ) ) { TEdge r = tEdges . get ( key ) ; if ( ! tNodes . containsKey ( r . src ) ) { System . out . println ( "Unable to find vertex reference ID " + r . src ) ; continue ; } ; if ( ! tNodes . containsKey ( r . trg ) ) { System . out . println ( "Unable to find vertex reference ID " + r . trg ) ; continue ; } ; if ( tNodes . get ( r . src ) . node == null ) { System . out . println ( "Node not added ID " + r . src ) ; continue ; } ; if ( tNodes . get ( r . trg ) . node == null ) { System . out . println ( "Node not added ID " + r . trg ) ; continue ; } ; Edge e = new Edge ( key + r . name , r . type + "" , tNodes . get ( r . src ) . node , tNodes . get ( r . trg ) . node ) ; myModel . addE ( e ) ; } } else { System . err . println ( "Can't load file." ) ; } return myModel ; }
va	9	private void postPlugin ( final boolean isPing ) throws IOException { final PluginDescriptionFile description = plugin . getDescription ( ) ; final StringBuilder data = new StringBuilder ( ) ; data . append ( encode ( "guid" ) ) . append ( = ) . append ( encode ( guid ) ) ; encodeDataPair ( data , "version" , description . getVersion ( ) ) ; encodeDataPair ( data , "server" , Bukkit . getVersion ( ) ) ; encodeDataPair ( data , "players" , Integer . toString ( Bukkit . getServer ( ) . getOnlinePlayers ( ) . length ) ) ; encodeDataPair ( data , "revision" , String . valueOf ( REVISION ) ) ; if ( isPing ) { encodeDataPair ( data , "ping" , "true" ) ; } synchronized ( graphs ) { final Iterator < Graph > iter = graphs . iterator ( ) ; while ( iter . hasNext ( ) ) { final Graph graph = iter . next ( ) ; for ( Plotter plotter : graph . getPlotters ( ) ) { final String key = String . format ( "C%s%s%s%s" , CUSTOM_DATA_SEPARATOR , graph . getName ( ) , CUSTOM_DATA_SEPARATOR , plotter . getColumnName ( ) ) ; final String value = Integer . toString ( plotter . getValue ( ) ) ; encodeDataPair ( data , key , value ) ; } } } URL url = new URL ( BASE_URL + String . format ( REPORT_URL , encode ( plugin . getDescription ( ) . getName ( ) ) ) ) ; URLConnection connection ; if ( isMineshafterPresent ( ) ) { connection = url . openConnection ( Proxy . NO_PROXY ) ; } else { connection = url . openConnection ( ) ; } connection . setDoOutput ( true ) ; final OutputStreamWriter writer = new OutputStreamWriter ( connection . getOutputStream ( ) ) ; writer . write ( data . toString ( ) ) ; writer . flush ( ) ; final BufferedReader reader = new BufferedReader ( new InputStreamReader ( connection . getInputStream ( ) ) ) ; final String response = reader . readLine ( ) ; writer . close ( ) ; reader . close ( ) ; if ( response == null || response . startsWith ( "ERR" ) ) { throw new IOException ( response ) ; } else { if ( response . contains ( "OK This is your first update this hour" ) ) { synchronized ( graphs ) { final Iterator < Graph > iter = graphs . iterator ( ) ; while ( iter . hasNext ( ) ) { final Graph graph = iter . next ( ) ; for ( Plotter plotter : graph . getPlotters ( ) ) { plotter . reset ( ) ; } } } } } }
va	2	public Kim ( byte [ ] bytes , int from , int thru ) { int sum = 1 ; int value ; this . hashcode = 0 ; this . length = thru - from ; if ( this . length > 0 ) { this . bytes = new byte [ this . length ] ; for ( int at = 0 ; at < this . length ; at += 1 ) { value = ( int ) bytes [ at + from ] & FF ; sum += value ; this . hashcode += sum ; this . bytes [ at ] = ( byte ) value ; } this . hashcode += sum << 16 ; } }
va	8	private int findNextSizedSlotAndPopulate ( int width , int height ) { for ( int u1 = 0 ; u1 < this . slotsU - width + 1 ; u1 ++ ) { for ( int v1 = 0 ; v1 < this . slotsV - height + 1 ; v1 ++ ) { boolean empty = true ; for ( int u2 = u1 ; u2 < u1 + width ; u2 ++ ) { for ( int v2 = v1 ; v2 < v1 + height ; v2 ++ ) { if ( this . slots [ u2 + v2 * this . slotsU ] == true ) { empty = false ; } } } if ( empty ) { for ( int u2 = u1 ; u2 < u1 + width ; u2 ++ ) { for ( int v2 = v1 ; v2 < v1 + height ; v2 ++ ) { this . slots [ u2 + v2 * this . slotsU ] = true ; } } return u1 + v1 * this . slotsU ; } } } return - 1 ; }
va	8	@ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; PhpposSalesItemsTaxesEntity that = ( PhpposSalesItemsTaxesEntity ) o ; if ( itemId != that . itemId ) return false ; if ( double . compare ( that . % , % ) != 0 ) return false ; if ( saleId != that . saleId ) return false ; if ( name != null ? ! name . equals ( that . name ) : that . name != null ) return false ; return true ; }
va	8	public String verifyFields ( ) { String result = "" ; final String statement = _statementTextField . getText ( ) ; boolean valid = true ; if ( statement . isEmpty ( ) ) { result += " No statement was entered." ; valid = false ; } if ( getBlanks ( _blankTextFields ) . size ( ) == 0 ) { result += " Blank field needs to be filled in." ; valid = false ; } if ( valid ) { final ArrayList < String > splits = new ArrayList < String > ( ) ; for ( String split : statement . split ( " " ) ) { splits . add ( split ) ; } final ArrayList < String > cleanedWords = StringUtilities . checkFields ( splits ) ; for ( final String blank : getBlanks ( _blankTextFields ) ) { int found = 0 ; for ( final String cleanedWord : cleanedWords ) { if ( cleanedWord . equalsIgnoreCase ( blank ) ) { ++ found ; } } if ( found == 0 ) { result += " " + blank + " not found." ; break ; } } } return result ; }
va	6	public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; n = scan . nextInt ( ) ; while ( n != 0 ) { m = scan . nextInt ( ) ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { graph [ i ] [ j ] = INF ; } } for ( int i = 0 ; i < m ; i ++ ) { int u = scan . nextInt ( ) ; int v = scan . nextInt ( ) ; int w = scan . nextInt ( ) ; graph [ u ] [ v ] = graph [ v ] [ u ] = w ; } s = 1 ; t = n ; spfa ( ) ; int sum = dist [ t ] ; if ( dist [ t ] == INF ) { System . out . println ( "Back to jail" ) ; } else { change ( t ) ; s = n ; t = 1 ; spfa ( ) ; if ( dist [ t ] == INF ) System . out . println ( "Back to jail" ) ; else System . out . println ( sum + dist [ t ] ) ; } n = scan . nextInt ( ) ; } }
va	8	public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; while ( scan . hasNext ( ) ) { int n = scan . nextInt ( ) ; int aux = n ; int max = 0 ; int max1 = n ; int max2 = n ; int max3 = n ; while ( n > 3 ) { max1 += n / 3 ; n = n / 3 + n % 3 ; } n = aux + 1 ; while ( n > 3 ) { max2 += n / 3 ; n = n / 3 + n % 3 ; } n = aux + 2 ; while ( n > 3 ) { max3 += n / 3 ; n = n / 3 + n % 3 ; } if ( n < 2 ) max2 = 0 ; if ( max1 > max2 ) if ( max1 > max3 ) max = max1 ; else max = max3 ; else if ( max2 > max3 ) max = max2 ; else max = max3 ; System . out . println ( max ) ; } }
va	6	private void cargarActionPerformed ( java . awt . event . ActionEvent evt ) { abrirBase ( ) ; LazyList < Gasto > gastos = null ; tablaMovDefault . setRowCount ( 0 ) ; LinkedList < Gasto > gastosLinked = new LinkedList < > ( ) ; if ( categorias . getSelectedItem ( ) . toString ( ) . equals ( "Todos" ) ) { gastos = Gasto . where ( "fecha >= ? and fecha <= ? " , dateToMySQLDate ( desde . getDate ( ) , false ) , dateToMySQLDate ( hasta . getDate ( ) , false ) ) ; Iterator < Gasto > it = gastos . iterator ( ) ; Gasto gasto ; while ( it . hasNext ( ) ) { gasto = it . next ( ) ; Object row [ ] = new Object [ 5 ] ; Dato padre = gasto . parent ( Dato . class ) ; Categoria papaDato = padre . parent ( Categoria . class ) ; row [ 0 ] = papaDato . getString ( "nombre" ) ; row [ 1 ] = padre . getString ( "descripcion" ) ; row [ 2 ] = gasto . getString ( "monto" ) ; row [ 3 ] = padre . getString ( "ingreso_egreso" ) ; row [ 4 ] = dateToMySQLDate ( gasto . getDate ( "fecha" ) , true ) ; tablaMovDefault . addRow ( row ) ; } } else { Categoria cat = Categoria . findFirst ( "nombre =?" , categorias . getSelectedItem ( ) . toString ( ) ) ; LazyList < Dato > datos = Dato . where ( "categoria_id =?" , cat . getId ( ) ) ; Iterator < Dato > itDatos = datos . iterator ( ) ; while ( itDatos . hasNext ( ) ) { Dato dato = itDatos . next ( ) ; gastosLinked . addAll ( dato . getAll ( Gasto . class ) ) ; } Iterator < Gasto > it = gastosLinked . iterator ( ) ; Gasto gasto ; while ( it . hasNext ( ) ) { gasto = it . next ( ) ; if ( gasto . getDate ( "fecha" ) . after ( desde . getDate ( ) ) && gasto . getDate ( "fecha" ) . before ( hasta . getDate ( ) ) ) { Object row [ ] = new Object [ 5 ] ; Dato padre = gasto . parent ( Dato . class ) ; Categoria papaDato = padre . parent ( Categoria . class ) ; row [ 0 ] = papaDato . getString ( "nombre" ) ; row [ 1 ] = padre . getString ( "descripcion" ) ; row [ 2 ] = gasto . getString ( "monto" ) ; row [ 3 ] = padre . getString ( "ingreso_egreso" ) ; row [ 4 ] = dateToMySQLDate ( gasto . getDate ( "fecha" ) , true ) ; tablaMovDefault . addRow ( row ) ; } } } DecimalFormat df = new DecimalFormat ( "0.00########" ) ; String result = df . format ( sumar ( ) ) ; total . setText ( result ) ; }
va	6	public Vector < Student > search ( final String name , final String examStr , final String botStr , final String topStr ) { final Vector < Student > studentsVector = new Vector < Student > ( ) ; final int bot = Util . isNumeric ( botStr ) ? Integer . parseInt ( botStr ) : 0 ; final int top = Util . isNumeric ( topStr ) ? Integer . parseInt ( topStr ) : 10 ; for ( final Student student : students ) { if ( student . isExam ( examStr ) >= bot && student . isExam ( examStr ) <= top ) { if ( student . getName ( ) . indexOf ( name ) != - 1 ) { studentsVector . add ( student ) ; } } } return studentsVector ; }
va	5	@ Override public boolean equals ( Object object ) { if ( ! ( object instanceof Sprinkler ) ) { return false ; } Sprinkler other = ( Sprinkler ) object ; if ( ( this . id == null && other . id != null ) || ( this . id != null && ! this . id . equals ( other . id ) ) ) { return false ; } return true ; }
va	9	protected StringBuffer renderOptions ( StringBuffer sb , int width , Options options , int leftPad , int descPad ) { final String lpad = createPadding ( leftPad ) ; final String dpad = createPadding ( descPad ) ; int max = 0 ; StringBuffer optBuf ; List prefixList = new ArrayList ( ) ; List optList = options . helpOptions ( ) ; Collections . sort ( optList , getOptionComparator ( ) ) ; for ( Iterator i = optList . iterator ( ) ; i . hasNext ( ) ; ) { Option option = ( Option ) i . next ( ) ; optBuf = new StringBuffer ( 8 ) ; if ( option . getOpt ( ) == null ) { optBuf . append ( lpad ) . append ( "   " + defaultLongOptPrefix ) . append ( option . getLongOpt ( ) ) ; } else { optBuf . append ( lpad ) . append ( defaultOptPrefix ) . append ( option . getOpt ( ) ) ; if ( option . hasLongOpt ( ) ) { optBuf . append (   ) . append ( defaultLongOptPrefix ) . append ( option . getLongOpt ( ) ) ; } } if ( option . hasArg ( ) ) { if ( option . hasArgName ( ) ) { optBuf . append ( " <" ) . append ( option . getArgName ( ) ) . append ( ">" ) ; } else { optBuf . append (   ) ; } } prefixList . add ( optBuf ) ; max = ( optBuf . length ( ) > max ) ? optBuf . length ( ) : max ; } int x = 0 ; for ( Iterator i = optList . iterator ( ) ; i . hasNext ( ) ; ) { Option option = ( Option ) i . next ( ) ; optBuf = new StringBuffer ( prefixList . get ( x ++ ) . toString ( ) ) ; if ( optBuf . length ( ) < max ) { optBuf . append ( createPadding ( max - optBuf . length ( ) ) ) ; } optBuf . append ( dpad ) ; int nextLineTabStop = max + descPad ; if ( option . getDescription ( ) != null ) { optBuf . append ( option . getDescription ( ) ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString ( ) ) ; if ( i . hasNext ( ) ) { sb . append ( defaultNewLine ) ; } } return sb ; }
va	2	public void waitUntilGuiClosed ( ) { synchronized ( gui_lock ) { try { while ( gui_open ) { gui_lock . wait ( ) ; } } catch ( InterruptedException e ) { } } }
va	7	private void generateKeys ( int doorNum ) { SolveMazeTask findKey ; Key key = new Key ( ) ; int hPadding = ( SQUARE_SIZE - key . getWidth ( ) ) / 2 ; int vPadding = ( SQUARE_SIZE - key . getHeight ( ) ) / 2 ; int [ ] [ ] keyPath = new int [ getColumns ( ) ] [ getRows ( ) ] ; int gridX = - 1 , gridY = - 1 , x = - 1 , y = - 1 ; while ( true ) { gridX = ( int ) ( Math . random ( ) * getColumns ( ) ) ; gridY = ( int ) ( Math . random ( ) * getRows ( ) ) ; x = gridX * SQUARE_SIZE + hPadding ; y = gridY * SQUARE_SIZE + vPadding ; if ( isPath ( gridX , gridY ) || hasItem ( x + SQUARE_SIZE / 2 , y + SQUARE_SIZE / 2 ) ) continue ; if ( doorNum != 0 ) findKey = new SolveMazeTask ( this , doors . get ( doorNum - 1 ) . getGridX ( ) , doors . get ( doorNum - 1 ) . getGridY ( ) , gridX , gridY ) ; else findKey = new SolveMazeTask ( this , getStartX ( ) , getStartY ( ) , gridX , gridY ) ; findKey . execute ( ) ; try { keyPath = findKey . get ( ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } catch ( ExecutionException e ) { e . printStackTrace ( ) ; } if ( keyPath [ doors . get ( doorNum ) . getGridX ( ) ] [ doors . get ( doorNum ) . getGridY ( ) ] == - 1 ) { key . setX ( x ) ; key . setY ( y ) ; items . add ( key ) ; break ; } } }
va	7	public int read ( int width ) throws IOException { if ( width == 0 ) { return 0 ; } if ( width < 0 || width > 32 ) { throw new IOException ( "Bad read width." ) ; } int result = 0 ; while ( width > 0 ) { if ( this . available == 0 ) { this . unread = this . in . read ( ) ; if ( this . unread < 0 ) { throw new IOException ( "Attempt to read past end." ) ; } this . available = 8 ; } int take = width ; if ( take > this . available ) { take = this . available ; } result |= ( ( this . unread >>> ( this . available - take ) ) & mask [ take ] ) << ( width - take ) ; this . nrBits += take ; this . available -= take ; width -= take ; } return result ; }
va	5	public static boolean isJavaIdentifier ( String name ) { if ( name == null ) { return false ; } int size = name . length ( ) ; if ( size < 1 ) { return false ; } if ( Character . isJavaIdentifierStart ( name . charAt ( 0 ) ) ) { for ( int i = 1 ; i < size ; i ++ ) { if ( ! Character . isJavaIdentifierPart ( name . charAt ( i ) ) ) { return false ; } } return true ; } return false ; }
va	5	public Object clone ( ) throws CloneNotSupportedException { Change result = ( Change ) super . clone ( ) ; if ( result . objectNode != null ) { result . objectNode = ( ObjectNode ) this . objectNode . clone ( ) ; result . objectNode . setParent ( result ) ; } if ( result . feature != null ) { result . feature = ( Feature ) this . feature . clone ( ) ; result . feature . setParent ( result ) ; } if ( result . geometry != null ) { result . geometry = ( Geometry ) this . geometry . clone ( ) ; result . geometry . setParent ( result ) ; } if ( result . styleSelector != null ) { result . styleSelector = ( StyleSelector ) this . styleSelector . clone ( ) ; result . styleSelector . setParent ( result ) ; } if ( result . timePrimitive != null ) { result . timePrimitive = ( TimePrimitive ) this . timePrimitive . clone ( ) ; result . timePrimitive . setParent ( result ) ; } return result ; }
va	9	private boolean isCellaRaggiungibile ( Coord oldCoord , Coord newCoord , int maxHops ) { if ( maxHops < 0 ) { return false ; } if ( ( getCostoSpostamento ( oldCoord , newCoord ) == 0 ) && maxHops >= 0 ) { return true ; } else { int i = - 1 ; int j = - 1 ; ArrayList < Coord > myPaths = new ArrayList < Coord > ( ) ; Coord tempCoord = null ; while ( i < 2 ) { j = - 1 ; while ( j < 2 ) { tempCoord = new Coord ( oldCoord . getX ( ) + i , oldCoord . getY ( ) + j ) ; if ( ! isCellaAcqua ( tempCoord ) ) { myPaths . add ( tempCoord ) ; } j ++ ; } i ++ ; } if ( myPaths . isEmpty ( ) ) { return false ; } Coord curCoord = null ; boolean hasPath = false ; while ( ! myPaths . isEmpty ( ) ) { curCoord = getMinimumFromCoordArrayList ( myPaths , newCoord ) ; if ( isCellaRaggiungibile ( curCoord , newCoord , ( maxHops - 1 ) ) ) { hasPath = true ; } if ( hasPath ) { return true ; } } return hasPath ; } }
va	9	public void method305 ( int i , int k , int i1 ) { int j = 100 ; int l = 5500 ; int j1 = ( int ) Math . sqrt ( k * k + i * i + i1 * i1 ) ; int k1 = l >> 4 ; for ( int l1 = 0 ; l1 < anInt437 ; l1 ++ ) { for ( int i2 = 0 ; i2 < anInt438 ; i2 ++ ) { for ( int j2 = 0 ; j2 < anInt439 ; j2 ++ ) { Ground class30_sub3 = groundArray [ l1 ] [ i2 ] [ j2 ] ; if ( class30_sub3 != null ) { Object1 class10 = class30_sub3 . obj1 ; if ( class10 != null && class10 . aClass30_Sub2_Sub4_278 != null && class10 . aClass30_Sub2_Sub4_278 . aClass33Array1425 != null ) { method307 ( l1 , 1 , 1 , i2 , j2 , ( Model ) class10 . aClass30_Sub2_Sub4_278 ) ; if ( class10 . aClass30_Sub2_Sub4_279 != null && class10 . aClass30_Sub2_Sub4_279 . aClass33Array1425 != null ) { method307 ( l1 , 1 , 1 , i2 , j2 , ( Model ) class10 . aClass30_Sub2_Sub4_279 ) ; method308 ( ( Model ) class10 . aClass30_Sub2_Sub4_278 , ( Model ) class10 . aClass30_Sub2_Sub4_279 , 0 , 0 , 0 , false ) ; ( ( Model ) class10 . aClass30_Sub2_Sub4_279 ) . method480 ( j , k1 , k , i , i1 ) ; } ( ( Model ) class10 . aClass30_Sub2_Sub4_278 ) . method480 ( j , k1 , k , i , i1 ) ; } for ( int k2 = 0 ; k2 < class30_sub3 . anInt1317 ; k2 ++ ) { Object5 class28 = class30_sub3 . obj5Array [ k2 ] ; if ( class28 != null && class28 . aClass30_Sub2_Sub4_521 != null && class28 . aClass30_Sub2_Sub4_521 . aClass33Array1425 != null ) { method307 ( l1 , ( class28 . anInt524 - class28 . anInt523 ) + 1 , ( class28 . anInt526 - class28 . anInt525 ) + 1 , i2 , j2 , ( Model ) class28 . aClass30_Sub2_Sub4_521 ) ; ( ( Model ) class28 . aClass30_Sub2_Sub4_521 ) . method480 ( j , k1 , k , i , i1 ) ; } } Object3 class49 = class30_sub3 . obj3 ; if ( class49 != null && class49 . aClass30_Sub2_Sub4_814 . aClass33Array1425 != null ) { method306 ( i2 , l1 , ( Model ) class49 . aClass30_Sub2_Sub4_814 , j2 ) ; ( ( Model ) class49 . aClass30_Sub2_Sub4_814 ) . method480 ( j , k1 , k , i , i1 ) ; } } } } } }
va	9	private CodeFragment variableTypeConvert ( Variable v , Type t , CodePosition p ) { CodeFragment code = new CodeFragment ( ) ; if ( v . getType ( ) . equals ( t ) ) { code . setType ( t ) ; code . setRegister ( v . getRegister ( ) ) ; return code ; } String instruction = "" ; String register = this . generateNewRegister ( ) ; if ( t instanceof ListType ) { ListType < = ( ListType ) t ; if ( < . getSubtype ( ) . equals ( v . getType ( ) ) ) { code . addCode ( String . format ( "%s = call %s @createList%s(%s %s)\n" , register , t . getCode ( ) , getFunctionSuffix ( < . getSubtype ( ) ) , BasicType . int . getCode ( ) , "1" ) ) ; code . addCode ( String . format ( "call %s @setListItem%s(%s %s  %s %s  %s %s)\n" , "void" , getFunctionSuffix ( < . getSubtype ( ) ) , t . getCode ( ) , register , BasicType . int . getCode ( ) , "0" , v . getType ( ) . getCode ( ) , v . getRegister ( ) ) ) ; } else if ( v . getType ( ) instanceof RangeType && ( ( RangeType ) v . getType ( ) ) . getSubtype ( ) . equals ( < . getSubtype ( ) ) ) { code . addCode ( String . format ( "%s = call %s @createListFromRange%s(%s %s)\n" , register , t . getCode ( ) , getFunctionSuffix ( < . getSubtype ( ) ) , v . getType ( ) . getCode ( ) , v . getRegister ( ) ) ) ; } } else { if ( v . getType ( ) . isInteger ( ) && t . isInteger ( ) ) { if ( Integer . parseInt ( v . getType ( ) . getCode ( ) . substring ( 1 ) ) <= Integer . parseInt ( t . getCode ( ) . substring ( 1 ) ) ) { instruction = "zext" ; } else { instruction = "trunc" ; } } else if ( v . getType ( ) . isInteger ( ) ) { instruction = "sitofp" ; } else { throw new TypeMismatchException ( p , v . getType ( ) , t ) ; } ST temp = new ST ( "<ret> = <instruction> <t1> <r> to <t2>\n" ) ; temp . add ( "r" , v . getRegister ( ) ) ; temp . add ( "t1" , v . getType ( ) . getCode ( ) ) ; temp . add ( "t2" , t . getCode ( ) ) ; temp . add ( "instruction" , instruction ) ; temp . add ( "ret" , register ) ; code . addCode ( temp . render ( ) ) ; } code . setType ( t ) ; code . setRegister ( register ) ; return code ; }
va	5	private static int findLongestCommonSubSequence ( String firstString , String secondString ) { int dpArray [ ] [ ] = new int [ firstString . length ( ) + 1 ] [ secondString . length ( ) + 1 ] ; for ( int i = 0 ; i <= firstString . length ( ) ; i ++ ) { dpArray [ i ] [ 0 ] = 0 ; } for ( int j = 0 ; j <= secondString . length ( ) ; j ++ ) { dpArray [ 0 ] [ j ] = 0 ; } for ( int i = 1 ; i <= firstString . length ( ) ; i ++ ) { for ( int j = 1 ; j <= secondString . length ( ) ; j ++ ) { if ( firstString . charAt ( i - 1 ) == secondString . charAt ( j - 1 ) ) { dpArray [ i ] [ j ] = dpArray [ i - 1 ] [ j - 1 ] + 1 ; } else { dpArray [ i ] [ j ] = Math . max ( dpArray [ i - 1 ] [ j ] , dpArray [ i ] [ j - 1 ] ) ; } } } return dpArray [ firstString . length ( ) ] [ secondString . length ( ) ] ; }
va	2	public static < C > AutomataGraph < C > createGraph ( final Collection < ? extends ITimedAutomata < C >> autos ) { AutomataGraph < C > graph = new SimpleAutomataGraph < C > ( autos ) ; for ( ITimedAutomata < C > auto : autos ) createGraph ( auto , graph ) ; return graph ; }
va	8	public boolean IsConsecutive ( ) { if ( playingCards . size ( ) < 5 ) return false ; Collections . sort ( playingCards ) ; int currentIndex = 0 ; int count = 0 ; for ( PlayingCard playingCard : playingCards ) { int thisCardIndex = playingCard . ValueOrder . indexOf ( playingCard . Value ) ; if ( currentIndex != 0 || count > 0 ) { if ( count == 4 && playingCards . get ( 0 ) . Value . equals ( "2" ) && playingCards . get ( 4 ) . Value . equals ( "A" ) ) return true ; if ( thisCardIndex - currentIndex != 1 ) return false ; } count ++ ; currentIndex = thisCardIndex ; } return true ; }
va	0	public Object getNextPanelDescriptor ( ) { return FINISH ; }
va	8	@ Override public String process ( HttpServletRequest request ) throws MissingRequiredParameter { ResultSet resultSet = null ; String farmID = request . getParameter ( "farmID" ) ; JSONArray result = new JSONArray ( ) ; try { connection = dataSource . getConnection ( ) ; statement = connection . createStatement ( ) ; String query = "SELECT * FROM productos" ; resultSet = statement . executeQuery ( query ) ; while ( resultSet . next ( ) ) { Producto prod = new Producto ( ) ; prod . setProducto ( resultSet . getString ( "nombre" ) ) ; prod . setTipo ( resultSet . getString ( "tipo" ) ) ; prod . setcantidad ( resultSet . getString ( "cantidad" ) ) ; prod . setdescripcion ( resultSet . getString ( "descripcion" ) ) ; prod . setreceta ( resultSet . getString ( "receta" ) ) ; prod . setprecio ( resultSet . getString ( "precio" ) ) ; prod . setId ( resultSet . getInt ( "id_producto" ) ) ; result . add ( prod ) ; } } catch ( SQLException e ) { return "{\"status\":\"KO\"  \"result\": \"Error en el acceso a la base de datos.\"}" ; } finally { try { if ( null != resultSet ) resultSet . close ( ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; } try { if ( null != statement ) statement . close ( ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; } try { if ( null != connection ) connection . close ( ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; } } return "{\"status\":\"OK\"  \"farmID\":" + farmID + "  \"result\":" + result . toString ( ) + "}" ; }
va	4	@ Override public class < ? > getColumnClass ( int column ) { switch ( column ) { case 0 : return Integer . class ; case 1 : return Integer . class ; case 2 : return Object . class ; default : return String . class ; } }
va	4	@ Override public void run ( ) { if ( aBank . contains ( getLocation ( ) ) ) { inBank = true ; } else { inBank = false ; } if ( aField . contains ( getLocation ( ) ) ) { inField = true ; } else { inField = false ; } if ( Inventory . isFull ( ) ) { inventoryFull = true ; } else { inventoryFull = false ; } SceneObject Gate = SceneEntities . getNearest ( new Filter < SceneObject > ( ) { public boolean accept ( SceneObject entity ) { return entity . getId ( ) == 45208 ; } } ) ; if ( Gate != null ) { gateOpen = true ; } }
va	6	public static boolean isValidShuffle ( String str1 , String str2 , String str3 ) { if ( str1 == null || str2 == null || str3 == null ) { return false ; } if ( str1 . length ( ) + str2 . length ( ) != str3 . length ( ) ) { return false ; } if ( str1 . isEmpty ( ) ) { return str2 . equals ( str3 ) ; } if ( str2 . isEmpty ( ) ) { return str1 . equals ( str3 ) ; } return isValidShuffleRecursive ( str1 , str2 , str3 , 0 , 0 , 0 ) ; }
va	1	public void recherchePeriodique ( String issn ) { Periodique p ; if ( ( p = getPeriodique ( ) . get ( issn ) ) == null ) { Message dialog = new Message ( "Ce periodique n'existe pas" ) ; } else { ( ( VueNouvelleParution ) getVue ( ) ) . alimente ( p . getNom ( ) ) ; ( ( VueNouvelleParution ) getVue ( ) ) . setEtat ( Vue . inter1 ) ; } }
va	3	public void write ( org . apache . thrift7 . protocol . TProtocol oprot ) throws org . apache . thrift7 . TException { validate ( ) ; oprot . writeStructBegin ( STRUCT_DESC ) ; if ( this . queue_name != null ) { oprot . writeFieldBegin ( QUEUE_NAME_FIELD_DESC ) ; oprot . writeString ( this . queue_name ) ; oprot . writeFieldEnd ( ) ; } if ( this . ids != null ) { oprot . writeFieldBegin ( IDS_FIELD_DESC ) ; { oprot . writeSetBegin ( new org . apache . thrift7 . protocol . TSet ( org . apache . thrift7 . protocol . TType . I64 , this . ids . size ( ) ) ) ; for ( long _iter11 : this . ids ) { oprot . writeI64 ( _iter11 ) ; } oprot . writeSetEnd ( ) ; } oprot . writeFieldEnd ( ) ; } oprot . writeFieldStop ( ) ; oprot . writeStructEnd ( ) ; }
va	4	protected boolean isOutOfBounds ( final int row , final int column ) { if ( ( row < 0 ) || ( rowSize <= row ) || ( column < 0 ) || ( columnSize <= column ) ) { return true ; } return false ; }
va	1	@ Override public XMLReader getXMLReader ( ) { XMLReader reader = super . getXMLReader ( ) ; if ( reader == null ) { reader = new SAX_FI_Decoder ( ) ; setXMLReader ( reader ) ; } return reader ; }
va	0	public void setInactive ( ) { active = false ; }
va	2	private void initMessage ( ) throws InvalidDataException { if ( code == CloseFrame . NOCODE ) { reason = Charsetfunctions . stringUtf8 ( super . getPayloadData ( ) ) ; } else { ByteBuffer b = super . getPayloadData ( ) ; int mark = b . position ( ) ; try { b . position ( b . position ( ) + 2 ) ; reason = Charsetfunctions . stringUtf8 ( b ) ; } catch ( IllegalArgumentException e ) { throw new InvalidFrameException ( e ) ; } finally { b . position ( mark ) ; } } }
va	2	private Object [ ] [ ] getAllBookTableData ( ) { if ( this . library == null ) return null ; else { List < Book > books = library . showBookList_all ( ) ; int nBooks = books . size ( ) ; Object [ ] [ ] booksData = new Object [ nBooks ] [ ] ; for ( int i = 0 ; i < nBooks ; i ++ ) { booksData [ i ] = createBookTableRowData ( books . get ( i ) ) ; } return booksData ; } }
va	6	@ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; final PlainTextPart other = ( PlainTextPart ) obj ; if ( text == null ) { if ( other . text != null ) return false ; } else if ( ! text . equals ( other . text ) ) return false ; return true ; }
va	9	public void showEditDialog ( Frame parentFrame ) { if ( functionType . contentEquals ( "output" ) ) { OutputEditorDialog eDiag = new OutputEditorDialog ( parentFrame ) ; eDiag . setLocation ( 260 , 180 ) ; eDiag . setAddress ( groupAddress ) ; eDiag . setOutputFunction ( outputFunction ) ; eDiag . setOutputFrequency ( outputFrequency ) ; eDiag . setVisible ( true ) ; if ( eDiag . getModalResult ( ) ) { groupAddress = eDiag . getAddress ( ) ; outputFunction = eDiag . getOutputFunction ( ) ; outputFrequency = eDiag . getOutputFrequency ( ) ; } eDiag . dispose ( ) ; } if ( functionType . contentEquals ( "input" ) ) { InputEditorDialog iDiag = new InputEditorDialog ( parentFrame ) ; iDiag . setLocation ( 260 , 180 ) ; iDiag . setAddress ( groupAddress ) ; iDiag . setInputFunction ( inputFunction ) ; iDiag . setInputRepetition ( inputRepetitionMode ) ; iDiag . setRepetitionRate ( repeatFrequency ) ; iDiag . setVisible ( true ) ; if ( iDiag . getModalResult ( ) ) { groupAddress = iDiag . getAddress ( ) ; inputFunction = iDiag . getInputFunction ( ) ; inputRepetitionMode = iDiag . getInputRepetition ( ) ; repeatFrequency = iDiag . getRepetitionRate ( ) ; } iDiag . dispose ( ) ; } if ( functionType . contentEquals ( "DS18S20" ) ) { DS18x20EditorDialog dDiag = new DS18x20EditorDialog ( parentFrame , "DS18S20 Options" ) ; dDiag . setLocation ( 260 , 180 ) ; dDiag . setAddress ( groupAddress ) ; dDiag . setFormat ( numberFormat ) ; dDiag . setRepetitionRate ( repeatFrequency ) ; dDiag . setTemperatureOffset ( temperatureOffset ) ; dDiag . setVisible ( true ) ; if ( dDiag . getDialogResult ( ) ) { groupAddress = dDiag . getAddress ( ) ; numberFormat = dDiag . getFormat ( ) ; repeatFrequency = dDiag . getRepetitionRate ( ) ; temperatureOffset = dDiag . getTemperatureOffset ( ) ; } dDiag . dispose ( ) ; } if ( functionType . contentEquals ( "DS18B20" ) ) { DS18x20EditorDialog dDiag = new DS18x20EditorDialog ( parentFrame , "DS18B20 Options" ) ; dDiag . setLocation ( 260 , 180 ) ; dDiag . setAddress ( groupAddress ) ; dDiag . setFormat ( numberFormat ) ; dDiag . setRepetitionRate ( repeatFrequency ) ; dDiag . setTemperatureOffset ( temperatureOffset ) ; dDiag . setVisible ( true ) ; if ( dDiag . getDialogResult ( ) ) { groupAddress = dDiag . getAddress ( ) ; numberFormat = dDiag . getFormat ( ) ; repeatFrequency = dDiag . getRepetitionRate ( ) ; temperatureOffset = dDiag . getTemperatureOffset ( ) ; } dDiag . dispose ( ) ; } if ( functionType . contentEquals ( "IR" ) ) { IREditorDialog irDiag = new IREditorDialog ( parentFrame ) ; irDiag . setLocation ( 260 , 180 ) ; irDiag . setRc5Commands ( rc5Commands ) ; irDiag . setVisible ( true ) ; if ( irDiag . getDialogResult ( ) ) { rc5Commands = irDiag . getRc5Commands ( ) ; } irDiag . dispose ( ) ; } if ( functionType . contentEquals ( "DHTxx" ) ) { DHTxxEditorDialog dDiag = new DHTxxEditorDialog ( parentFrame , "DHTxx Options" ) ; dDiag . setLocation ( 260 , 180 ) ; dDiag . setAddress ( groupAddress ) ; dDiag . setAddress2 ( groupAddress2 ) ; dDiag . setFormat ( numberFormat ) ; dDiag . setRepetitionRate ( repeatFrequency ) ; dDiag . setTemperatureOffset ( temperatureOffset ) ; dDiag . setHumidityOffset ( humidityOffset ) ; dDiag . setDhtSensorType ( dhtSensorType ) ; dDiag . setVisible ( true ) ; if ( dDiag . getDialogResult ( ) ) { groupAddress = dDiag . getAddress ( ) ; groupAddress2 = dDiag . getAddress2 ( ) ; numberFormat = dDiag . getFormat ( ) ; repeatFrequency = dDiag . getRepetitionRate ( ) ; temperatureOffset = dDiag . getTemperatureOffset ( ) ; humidityOffset = dDiag . getHumidityOffset ( ) ; dhtSensorType = dDiag . getDhtSensorType ( ) ; } dDiag . dispose ( ) ; } if ( functionType . contentEquals ( "n.a." ) ) { BacklightEditorDialog bDiag = new BacklightEditorDialog ( parentFrame ) ; bDiag . setLocation ( 260 , 180 ) ; bDiag . setAddress ( groupAddress , busControlEnabled ) ; bDiag . setFormat ( backlightNumberFormat ) ; bDiag . setDefault ( defaultBacklight ) ; bDiag . setVisible ( true ) ; if ( bDiag . getModalResult ( ) ) { groupAddress = bDiag . getAddress ( ) ; backlightNumberFormat = bDiag . getFormat ( ) ; busControlEnabled = bDiag . getBusControlEnabled ( ) ; defaultBacklight = bDiag . getDefault ( ) ; } bDiag . dispose ( ) ; } }
va	6	private void evaluateCommand ( ) { String selectedText = getSelectedText ( ) ; if ( selectedText == null || selectedText . length ( ) <= 0 ) { int curPos = getCaretPosition ( ) ; try { javax . swing . text . Document doc = getDocument ( ) ; int elemIndex = doc . getDefaultRootElement ( ) . getElementIndex ( curPos ) ; javax . swing . text . Element elem = doc . getDefaultRootElement ( ) . getElement ( elemIndex ) ; int endOffset = elem . getEndOffset ( ) ; int startOffset = elem . getStartOffset ( ) ; endOffset = ( endOffset > doc . getLength ( ) ? doc . getLength ( ) : endOffset ) ; selectedText = doc . getText ( startOffset , endOffset - startOffset ) ; } catch ( Exception ex ) { } } if ( selectedText != null && selectedText . length ( ) > 0 ) { sendCommands ( selectedText ) ; } }
va	8	private void calcGaps ( ComponentWrapper before , CC befCC , ComponentWrapper after , CC aftCC , String tag , boolean flowX , boolean isLTR ) { ContainerWrapper par = comp . getParent ( ) ; int parW = par . getWidth ( ) ; int parH = par . getHeight ( ) ; BoundSize befGap = before != null ? ( flowX ? befCC . getHorizontal ( ) : befCC . getVertical ( ) ) . getGapAfter ( ) : null ; BoundSize aftGap = after != null ? ( flowX ? aftCC . getHorizontal ( ) : aftCC . getVertical ( ) ) . getGapBefore ( ) : null ; mergeGapSizes ( cc . getVertical ( ) . getComponentGaps ( par , comp , befGap , ( flowX ? null : before ) , tag , parH , 0 , isLTR ) , false , true ) ; mergeGapSizes ( cc . getHorizontal ( ) . getComponentGaps ( par , comp , befGap , ( flowX ? before : null ) , tag , parW , 1 , isLTR ) , true , true ) ; mergeGapSizes ( cc . getVertical ( ) . getComponentGaps ( par , comp , aftGap , ( flowX ? null : after ) , tag , parH , 2 , isLTR ) , false , false ) ; mergeGapSizes ( cc . getHorizontal ( ) . getComponentGaps ( par , comp , aftGap , ( flowX ? after : null ) , tag , parW , 3 , isLTR ) , true , false ) ; }
va	3	public void createCourse ( ) { System . out . println ( "Hit here from Course.java" ) ; this . active = true ; this . creationDate = new Date ( ) ; CoursesDao dao = new CoursesDao ( ) ; Courses courses = dao . read ( Integer . parseInt ( this . courseId ) ) ; if ( courses != null ) { CourseSectionDao dao2 = new CourseSectionDao ( ) ; CourseSection courseSection = dao2 . read ( Integer . toString ( courses . getSection ( ) . getCourseSectionId ( ) ) ) ; if ( courseSection != null ) { CourseInfoDao dao3 = new CourseInfoDao ( ) ; CourseInfo courseInfo = dao3 . read ( courseSection . getCourseInfo ( ) . getCourseId ( ) ) ; if ( courseInfo != null ) { } else { courseInfo = new CourseInfo ( this . courseId , this . courseName , this . courseDescription , getDeptObjById ( ) , this . credits ) ; dao3 . create ( courseInfo ) ; } } else { CourseInfoDao dao3 = new CourseInfoDao ( ) ; CourseInfo courseInfo = new CourseInfo ( this . courseId , this . courseName , this . courseDescription , getDeptObjById ( ) , this . credits ) ; dao3 . create ( courseInfo ) ; courseSection = new CourseSection ( courseInfo , this . section ) ; dao2 . create ( courseSection ) ; } } else { CourseSectionDao dao2 = new CourseSectionDao ( ) ; CourseInfoDao dao3 = new CourseInfoDao ( ) ; CourseInfo courseInfo = new CourseInfo ( this . courseId , this . courseName , this . courseDescription , getDeptObjById ( ) , this . credits ) ; dao3 . create ( courseInfo ) ; CourseSection courseSection = new CourseSection ( courseInfo , this . section ) ; dao2 . create ( courseSection ) ; courses = new Courses ( courseSection , getSemesterObjById ( ) ) ; dao . create ( courses ) ; } }
va	5	public static String getExceptionMessage ( final Throwable e ) { if ( e . getCause ( ) != null ) { String msg = getExceptionMessage ( e . getCause ( ) ) ; if ( ! msg . equalsIgnoreCase ( e . getClass ( ) . getName ( ) ) ) { return msg ; } } if ( e . getLocalizedMessage ( ) != null ) { return e . getLocalizedMessage ( ) ; } else if ( e . getMessage ( ) != null ) { return e . getMessage ( ) ; } else if ( e . getClass ( ) . getCanonicalName ( ) != null ) { return e . getClass ( ) . getCanonicalName ( ) ; } else { return e . getClass ( ) . getName ( ) ; } }
va	3	public SceneObject getStair ( String str ) { if ( str . contains ( "top" ) ) { SceneObject Stair = SceneEntities . getNearest ( new Filter < SceneObject > ( ) { public boolean accept ( SceneObject entity ) { return entity . getId ( ) == 36775 ; } } ) ; return Stair ; } if ( str . contains ( "mid" ) ) { SceneObject Stair = SceneEntities . getNearest ( new Filter < SceneObject > ( ) { public boolean accept ( SceneObject entity ) { return entity . getId ( ) == 36774 ; } } ) ; return Stair ; } if ( str . contains ( "low" ) ) { SceneObject Stair = SceneEntities . getNearest ( new Filter < SceneObject > ( ) { public boolean accept ( SceneObject entity ) { return entity . getId ( ) == 36773 ; } } ) ; return Stair ; } return null ; }
va	3	public PartialStatement ( Resource subject , Property predicate , RDFNode object , ModelCom model ) { stmtTokens = new ArrayList < String > ( ) ; if ( subject == null ) { stmtTokens . add ( "?subject" ) ; subject = model . createResource ( "nullSubject" ) ; } else stmtTokens . add ( Namespaces . toLightString ( subject ) ) ; if ( predicate == null ) { stmtTokens . add ( "?predicate" ) ; predicate = model . createProperty ( "nullPredicate" ) ; } else stmtTokens . add ( Namespaces . toLightString ( predicate ) ) ; if ( object == null ) { stmtTokens . add ( "?object" ) ; object = model . createResource ( "nullObject" ) ; } else stmtTokens . add ( Namespaces . toLightString ( object ) ) ; baseStmt = new StatementImpl ( subject , predicate , object , model ) ; }
va	4	public Tag ( JSONObject json ) throws WeiboException , JSONException { if ( ! json . getString ( "id" ) . isEmpty ( ) ) { id = json . getString ( "id" ) ; } else if ( ! json . getString ( "tagid" ) . isEmpty ( ) ) { id = json . getString ( "tagid" ) ; } else if ( ! json . getString ( "value" ) . isEmpty ( ) ) { value = json . getString ( "value" ) ; } else { Iterator < String > keys = json . keys ( ) ; if ( keys . hasNext ( ) ) { id = keys . next ( ) ; value = json . getString ( id ) ; } } }
va	2	private static Map < String , String > readStringValues ( Preferences root , int hkey , String key ) throws IllegalArgumentException , IllegalAccessException , InvocationTargetException { HashMap < String , String > results = new HashMap < String , String > ( ) ; int [ ] handles = ( int [ ] ) regOpenKey . invoke ( root , new Object [ ] { new Integer ( hkey ) , toCstr ( key ) , new Integer ( KEY_READ ) } ) ; if ( handles [ 1 ] != REG_SUCCESS ) { return null ; } int [ ] info = ( int [ ] ) regQueryInfoKey . invoke ( root , new Object [ ] { new Integer ( handles [ 0 ] ) } ) ; int count = info [ 0 ] ; int maxlen = info [ 3 ] ; for ( int index = 0 ; index < count ; index ++ ) { byte [ ] name = ( byte [ ] ) regEnumValue . invoke ( root , new Object [ ] { new Integer ( handles [ 0 ] ) , new Integer ( index ) , new Integer ( maxlen + 1 ) } ) ; String value = readString ( hkey , key , new String ( name ) ) ; results . put ( new String ( name ) . trim ( ) , value ) ; } regCloseKey . invoke ( root , new Object [ ] { new Integer ( handles [ 0 ] ) } ) ; return results ; }
va	6	public static PgPolygonSet createFaceBasedSilhouette ( PgElementSet geometry , PdVector viewer ) { PgPolygonSet silhouette = new PgPolygonSet ( ) ; silhouette . setName ( "Face Based Silhouette of " + geometry . getName ( ) ) ; Set < Integer > visibleFaces = new HashSet < Integer > ( ) ; geometry . assureElementNormals ( ) ; assert geometry . hasElementNormals ( ) ; for ( int i = 0 ; i < geometry . getNumElements ( ) ; ++ i ) { PdVector ray = PdVector . subNew ( geometry . getCenterOfElement ( null , i ) , viewer ) ; double . = ray . . ( geometry . getElementNormal ( i ) ) ; if ( . < 0 ) { visibleFaces . add ( i ) ; } } CornerTable table = new CornerTable ( geometry ) ; for ( Corner corner : table . corners ( ) ) { if ( visibleFaces . contains ( corner . triangle ) && ( corner . opposite == null || ! visibleFaces . contains ( corner . opposite . triangle ) ) ) { int a = silhouette . addVertex ( geometry . getVertex ( corner . next . vertex ) ) ; int b = silhouette . addVertex ( geometry . getVertex ( corner . prev . vertex ) ) ; silhouette . addPolygon ( new PiVector ( a , b ) ) ; } } return silhouette ; }
va	8	@ Override public void run ( ) { System . out . println ( "Summary:\n" ) ; System . out . println ( fs . printSummary ( ) ) ; while ( running ) { try { FishPacket fp = ( FishPacket ) in . readObject ( ) ; System . out . println ( "FishPacket recived!" + fp . getHeader ( ) . getType ( ) ) ; if ( fp . getHeader ( ) . getType ( ) == PacketType . ADDFILE ) { FileList fl = ( FileList ) fp . getPayload ( ) ; ArrayList < FishFile > listOfFishFilesToAdd = getListOfFishFilesToAdd ( client , fl ) ; ArrayList < FishFile > listOfFishFilesToRemove = getListOfFishFilesToRemove ( client , fl ) ; fs . updateFilesOfClient ( listOfFishFilesToAdd , listOfFishFilesToRemove , client ) ; } else if ( fp . getHeader ( ) . getType ( ) == PacketType . SEARCH ) { ParameterToSearch par = ( ParameterToSearch ) fp . getPayload ( ) ; System . out . println ( fp . getPayload ( ) . printSummary ( ) ) ; FishPacket search = fs . search ( client , par . getParameter ( ) ) ; sendResult ( search ) ; } else if ( fp . getHeader ( ) . getType ( ) == PacketType . STATISTICS ) { ServerStatistics sts = ( ServerStatistics ) fp . getPayload ( ) ; FishPacket result = fs . getStatistics ( client ) ; sendResult ( result ) ; } else if ( fp . getHeader ( ) . getType ( ) == PacketType . LISTENINGSERVERPORT ) { ListeningServerPortNumber pn = ( ListeningServerPortNumber ) fp . getPayload ( ) ; System . out . println ( "Received: " + pn . printSummary ( ) ) ; Integer port = pn . port ; client . setListeningServerPort ( port ) ; } } catch ( IOException ex ) { running = false ; System . out . println ( "Client " + client . getNetResources ( ) . getSocket ( ) . getInetAddress ( ) + "disconnected" ) ; fs . clientDisconnected ( client ) ; } catch ( ClassNotFoundException ex ) { Logger . getLogger ( ConnectionHandler . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } } try { closeConnection ( ) ; } catch ( IOException e ) { System . out . println ( "Error while closing the connection" ) ; e . printStackTrace ( ) ; } }
va	3	private void setXmlFile ( File file ) throws IOException { if ( ( file == null ) || ( ! file . exists ( ) ) || ( ! file . canRead ( ) ) ) throw new IOException ( "The file is not accessable!" ) ; this . xmlFile = file ; }
va	2	@ Override public void walk ( CellWalker < E > walker ) { for ( int row = rowStart ; row <= rowEnd ; row ++ ) { for ( int col = colStart ; col <= colEnd ; col ++ ) { walker . hasCellData ( row - rowStart , col - colStart , grid . getCellData ( row , col ) ) ; } } }
va	0	public byte [ ] getTerminator ( ) { return terminators [ textEncoding ] ; }
va	0	public Tile ( Status iv_status ) { this . initTile ( iv_status ) ; this . shipStatus = Ship . Type . NOSHIP ; }
va	2	private CategorieMotClef findCategoryFromString ( String categorieMotClef ) { for ( CategorieMotClef c : categories ) { if ( c . getNom ( ) . equals ( categorieMotClef ) ) { return c ; } } throw new IllegalArgumentException ( "Etonnant : la cat\u00E9gorie de mot clef n'existe pas !" ) ; }
va	2	public double getCostProductQuantity ( long barcode ) { Map < Product , Integer > productList = saleRegister . getProductList ( ) ; Set < Product > products = productList . keySet ( ) ; for ( Product product : products ) { if ( product . getBarcode ( ) == barcode ) { int productQuantity = productList . get ( product ) ; return product . getPriceUnit ( ) * productQuantity ; } } return 0 ; }
va	9	public Result ModificarUsuario ( Usuario pusuario ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( ( Common . IsMinorOrEqualsZero ( pusuario . getCodigo ( ) ) ) ? ".C\u00F3digo inv\u00E1lido\n" : "" ) ; sb . append ( ( Common . IsNullOrEmpty ( pusuario . getNombre ( ) ) ) ? ".Nombre inv\u00E1lido\n" : "" ) ; sb . append ( ( Common . IsNullOrEmpty ( pusuario . getApellidoPaterno ( ) ) ) ? ".Apellido paterno inv\u00E1lido\n" : "" ) ; sb . append ( ( Common . IsNullOrEmpty ( pusuario . getApellidoMaterno ( ) ) ) ? ".Apellido materno inv\u00E1lido\n" : "" ) ; sb . append ( ( Common . IsNullOrEmpty ( pusuario . getNroDocumento ( ) ) ) ? ".N\u00FAmero de documento inv\u00E1lido\n" : "" ) ; sb . append ( ( Common . IsNullOrEmpty ( pusuario . getEmail ( ) ) ) ? ".Email inv\u00E1lido\n" : "" ) ; sb . append ( ( Common . IsNullOrEmpty ( pusuario . getCargo ( ) ) ) ? ".Cargo inv\u00E1lido\n" : "" ) ; sb . append ( ( Common . IsMinorOrEqualsZero ( pusuario . getRol ( ) . getCodigoRol ( ) ) ) ? ".Rol inv\u00E1lido\n" : "" ) ; sb . append ( ( Common . IsNullOrEmpty ( pusuario . getContrasenha ( ) ) ) ? ".Contrase\u00F1a inv\u00E1lido\n" : "" ) ; sb . append ( ( Common . IsNullOrEmpty ( pusuario . getConfirmContrasenha ( ) ) ) ? ".Confirmaci\u00F3n de contrase\u00F1a inv\u00E1lida\n" : "" ) ; if ( ! Common . IsMinorOrEqualsZero ( sb . length ( ) ) ) return new Result ( ResultType . Error , "Valide los campos antes de modificar." , sb . toString ( ) ) ; else return new Result ( ResultType . Ok , "La validaci\u00F3n pas\u00F3 sin errores." , null ) ; }
va	9	public void grassGrow ( ) { for ( int i = 0 ; i < cases . length ; i ++ ) { for ( int j = 0 ; j < cases [ 0 ] . length ; j ++ ) { if ( j + 1 < const . tailleChunkY ) { if ( cases [ i ] [ j ] . getBlockID ( ) == Block . dirt . blockID && cases [ i ] [ j + 1 ] . getBlockID ( ) == Block . air . blockID ) { if ( cases [ i ] [ j ] . light > 7 ) { cases [ i ] [ j ] . setBlock ( Block . grass ) ; } } } if ( cases [ i ] [ j ] . getBlockID ( ) == Block . grass . blockID ) { if ( j < const . tailleChunkY - 1 && cases [ i ] [ j + 1 ] . getBlockID ( ) != Block . air . blockID ) { cases [ i ] [ j ] . setBlock ( Block . dirt ) ; cases [ i ] [ j ] . subID = const . noMetaData ; } else if ( i > 0 && cases [ i - 1 ] [ j ] . getBlockID ( ) == Block . air . blockID ) { if ( i < const . tailleChunkX - 1 && cases [ i + 1 ] [ j ] . getBlockID ( ) == Block . air . blockID ) { cases [ i ] [ j ] . subID = const . upSubID ; } else { cases [ i ] [ j ] . subID = const . leftSubID ; } } else if ( i < const . tailleChunkX - 1 && cases [ i + 1 ] [ j ] . getBlockID ( ) == Block . air . blockID ) { cases [ i ] [ j ] . subID = const . rightSubID ; } else { cases [ i ] [ j ] . subID = const . defaultSubID ; } } } } }
va	3	private void createElements ( String [ ] options , int defaultOption ) { if ( defaultOption >= options . length ) { defaultOption = 0 ; } for ( int i = 0 ; i < options . length ; i ++ ) { SwitchStatus ss = SwitchStatus . OFF ; if ( i == defaultOption ) { ss = SwitchStatus . ON ; } INDISwitchElement element = new INDISwitchElement ( this , options [ i ] , ss ) ; } }
va	9	public void marshal ( Element root , Document doc ) { String metsNs = NS . METS . ns ( ) ; root . setAttribute ( "xmlns:mets" , metsNs ) ; root . setAttribute ( "xmlns:xlink" , NS . XLINK . ns ( ) ) ; root . setAttribute ( "xmlns:xsi" , NS . XSI . ns ( ) ) ; root . setAttributeNS ( NS . XSI . ns ( ) , "xsi:schemaLocation" , NS . METS . schemaLoc ( ) ) ; super . marshal ( root , doc ) ; if ( this . objid != null ) root . setAttribute ( "OBJID" , this . objid ) ; if ( this . profile != null ) root . setAttribute ( "PROFILE" , this . profile ) ; if ( this . label != null ) root . setAttribute ( "LABEL" , this . label ) ; if ( this . type != null ) root . setAttribute ( "TYPE" , this . type ) ; if ( this . metsHdr != null ) { Element metsHdr = doc . createElementNS ( metsNs , "mets:metsHdr" ) ; this . metsHdr . marshal ( metsHdr , doc ) ; root . appendChild ( metsHdr ) ; } for ( MdSec dmd : this . getDmdSec ( ) ) { Element dmdSec = doc . createElementNS ( metsNs , "mets:dmdSec" ) ; dmd . marshal ( dmdSec , doc ) ; root . appendChild ( dmdSec ) ; } for ( AmdSec amd : this . getAmdSec ( ) ) { Element amdSec = doc . createElementNS ( metsNs , "mets:amdSec" ) ; amd . marshal ( amdSec , doc ) ; root . appendChild ( amdSec ) ; } if ( this . fileSec != null ) { Element fileSec = doc . createElementNS ( metsNs , "mets:fileSec" ) ; this . fileSec . marshal ( fileSec , doc ) ; root . appendChild ( fileSec ) ; } if ( this . structMap == null ) this . getStructMap ( ) . add ( new StructMap ( ) ) ; for ( StructMap s : this . getStructMap ( ) ) { Element smap = doc . createElementNS ( metsNs , "mets:structMap" ) ; s . marshal ( smap , doc ) ; root . appendChild ( smap ) ; } if ( this . structLink != null ) { Element slink = doc . createElementNS ( metsNs , "mets:structLink" ) ; this . structLink . marshal ( slink , doc ) ; root . appendChild ( slink ) ; } }
va	1	public List < String > getReturn ( ) { if ( _return == null ) { _return = new ArrayList < String > ( ) ; } return this . _return ; }
va	1	public static List < Thread > getThreads ( ThreadGroup tg , boolean recursive , int estimate ) { Thread [ ] threads = new Thread [ estimate ] ; int count = tg . enumerate ( threads , recursive ) ; if ( count == estimate ) return getThreads ( tg , recursive , estimate + 10 ) ; else return Arrays . asList ( threads ) . subList ( 0 , count ) ; }
va	9	public TextFileParser process ( ) throws IOException { this . initProcess ( ) ; File targetFile ; if ( this . exclusiveLockOnTargetFile ) targetFile = FileUtils . getCommonFile ( new File ( this . absoluteFilePath ) ) ; else targetFile = new File ( this . absoluteFilePath ) ; synchronized ( targetFile ) { log . debug ( "Parsing " + this . absoluteFilePath ) ; if ( this . outputFile != null ) { log . debug ( "Output will be written to " + this . outputFile ) ; } this . resetReader ( ) ; String line = null ; long lineNumber = 0 ; this . parsingComments = true ; while ( ( line = this . readLine ( ) ) != null && ! this . terminated ) { try { this . currentLine ++ ; if ( line . isEmpty ( ) && this . skipEmptyLines || ! checkLine ( line ) ) { continue ; } String [ ] lineSplit = null ; try { lineSplit = this . split ( line ) ; } catch ( NullPointerException e ) { System . out . println ( "test" ) ; } final String [ ] keyEntries = this . extractKeyEntries ( lineSplit ) ; final String [ ] valueEntries = this . extractValueEntries ( lineSplit ) ; this . key = keyEntries ; this . value = valueEntries ; this . processLine ( this . key , this . value ) ; if ( this . outputFile != null && this . outputMode . equals ( OUTPUT_MODE . STREAM ) ) { this . checkForOutput ( this . key , this . value ) ; } if ( this . progress . getUpperLimit ( ) > - 1 ) this . progress . update ( lineNumber + 1 ) ; lineNumber ++ ; } catch ( IndexOutOfBoundsException e ) { log . error ( "Error while parsing line " + currentLine + " of file " + this . absoluteFilePath ) ; e . printStackTrace ( ) ; throw e ; } } if ( this . outputFile != null && this . outputMode . equals ( OUTPUT_MODE . BURST ) ) { this . checkForBurstOutput ( ) ; } this . finishProcess ( ) ; this . closeStreams ( ) ; } log . debug ( "Finished parsing " + this . absoluteFilePath ) ; return this ; }
va	8	public void mouseReleasedButton2 ( MouseEvent e ) { vxd . controller . DEBUG_STACK_TRACE ( e ) ; if ( e . getButton ( ) == MouseEvent . BUTTON2 || e . getButton ( ) == MouseEvent . BUTTON3 ) { JPopupMenu popup = new JPopupMenu ( ) ; popup . setLightWeightPopupEnabled ( true ) ; popup . setBorderPainted ( true ) ; JMenuItem del = new JMenuItem ( "Delete" ) ; del . setActionCommand ( "DELETE" ) ; del . addActionListener ( this ) ; popup . add ( del ) ; Vector v = vxd . controller . getAttributes ( element . getTagName ( ) ) ; Enumeration en = v . elements ( ) ; while ( en . hasMoreElements ( ) ) { vxdAttribute a = ( vxdAttribute ) en . nextElement ( ) ; if ( a . combo != null && a . combo . size ( ) == 2 && a . combo . contains ( "TRUE" ) && a . combo . contains ( "FALSE" ) ) { JCheckBoxMenuItem cb = new JCheckBoxMenuItem ( a . name ) ; cb . setActionCommand ( a . name ) ; cb . addActionListener ( this ) ; if ( element . getAttribute ( a . name ) . equals ( "TRUE" ) ) cb . setState ( true ) ; else cb . setState ( false ) ; popup . add ( cb ) ; } } popup . show ( this , e . getX ( ) , e . getY ( ) ) ; } }
va	8	public boolean stem ( ) { int v_1 ; int v_2 ; int v_3 ; int v_4 ; v_1 = cursor ; lab0 : do { if ( ! r_prelude ( ) ) { break lab0 ; } } while ( false ) ; cursor = v_1 ; v_2 = cursor ; lab1 : do { if ( ! r_mark_regions ( ) ) { break lab1 ; } } while ( false ) ; cursor = v_2 ; limit_backward = cursor ; cursor = limit ; v_3 = limit - cursor ; lab2 : do { if ( ! r_standard_suffix ( ) ) { break lab2 ; } } while ( false ) ; cursor = limit - v_3 ; cursor = limit_backward ; v_4 = cursor ; lab3 : do { if ( ! r_postlude ( ) ) { break lab3 ; } } while ( false ) ; cursor = v_4 ; return true ; }
va	6	private void initComponents ( ) { filtro = new FileNameExtensionFilter [ 1 ] ; jFileChooser = new JFileChooser ( ) { @ Override public void approveSelection ( ) { File f = getSelectedFile ( ) ; if ( f . exists ( ) && getDialogType ( ) == SAVE_DIALOG ) { int result = JOptionPane . showConfirmDialog ( getTopLevelAncestor ( ) , "El archivo seleccionado " + f . getName ( ) + " ya existe.\n\u00BFDesea sobreescribirlo?" , "Confirmar Guardar Como" , JOptionPane . YES_NO_OPTION , JOptionPane . WARNING_MESSAGE ) ; switch ( result ) { case JOptionPane . YES_OPTION : super . approveSelection ( ) ; return ; default : return ; } } else if ( getDialogType ( ) == SAVE_DIALOG ) { int size = f . getName ( ) . length ( ) ; if ( size > 3 ) { if ( ! f . getName ( ) . substring ( size - 4 ) . equalsIgnoreCase ( ".map" ) ) { setSelectedFile ( new File ( f + ".map" ) ) ; } } else { setSelectedFile ( new File ( f + ".map" ) ) ; } } super . approveSelection ( ) ; } } ; this . jFileChooser . removeChoosableFileFilter ( this . jFileChooser . getAcceptAllFileFilter ( ) ) ; initFiltrosArchivos ( ) ; }
va	2	public boolean encontrarele ( String nombre ) { int i = 0 ; while ( i < this . size ) { if ( nombre == this . lista [ i ] ) { return true ; } else { ++ i ; } } return false ; }
va	0	public Date getStartdate ( ) { return startdate ; }
va	3	public static String [ ] getNames ( Object object ) { if ( object == null ) { return null ; } class klass = object . getClass ( ) ; Field [ ] fields = klass . getFields ( ) ; int length = fields . length ; if ( length == 0 ) { return null ; } String [ ] names = new String [ length ] ; for ( int i = 0 ; i < length ; i += 1 ) { names [ i ] = fields [ i ] . getName ( ) ; } return names ; }
va	0	@ Override protected Entity callImplementation ( ArgumentList args , Scope scope ) { SparseString fileName = ( SparseString ) args . next ( ) ; String source = SparseSourceRunner . loadFile ( fileName . toString ( ) ) ; Code code = sparser . parseString ( source ) ; return code . execute ( scope ) ; }
va	7	@ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( "{" ) ; if ( getType ( ) != null ) sb . append ( "Type: " + getType ( ) + " " ) ; if ( getPartition ( ) != null ) sb . append ( "Partition: " + getPartition ( ) + " " ) ; if ( getName ( ) != null ) sb . append ( "Name: " + getName ( ) + " " ) ; if ( getHostName ( ) != null ) sb . append ( "HostName: " + getHostName ( ) + " " ) ; if ( getFullName ( ) != null ) sb . append ( "FullName: " + getFullName ( ) + " " ) ; if ( getState ( ) != null ) sb . append ( "State: " + getState ( ) + " " ) ; if ( getDetail ( ) != null ) sb . append ( "Detail: " + getDetail ( ) ) ; sb . append ( "}" ) ; return sb . toString ( ) ; }
va	3	public String toString ( ) { if ( this . equals ( 0 ) ) return "AS_NULL" ; if ( this . equals ( AS_TRANS ) ) return "AS_TRANS" ; if ( this . is4Byte ( ) ) return String . format ( "%d.%d" , hiWord ( ) , loWord ( ) ) ; return String . format ( "%d" , loWord ( ) ) ; }
va	8	public void progressWrite ( String line , boolean appendTime , int retry ) { synchronized ( lock ) { Thread . interrupted ( ) ; if ( progressInfoBoard != null ) { if ( appendTime ) { long t = System . currentTimeMillis ( ) - startTime ; t /= 1000 ; String m = String . valueOf ( t / 60 ) ; if ( m . length ( ) < 2 ) m = "0" + m ; String s = String . valueOf ( t % 60 ) ; if ( s . length ( ) < 2 ) s = "0" + s ; line = Messages . getString ( "WorkplacePanel.17" ) + m + ":" + s + " " + line ; } StyledDocument doc = progressInfoBoard . getStyledDocument ( ) ; try { if ( doc . getLength ( ) > 1024 * 16 ) { doc . remove ( 0 , 1024 * 8 ) ; } doc . insertString ( doc . getLength ( ) , line + "\n" , null ) ; progressInfoBoard . setCaretPosition ( doc . getLength ( ) ) ; } catch ( Throwable e ) { if ( retry > 0 ) { try { Thread . sleep ( 10 ) ; } catch ( Throwable ee ) { } progressWrite ( line , false , retry - 1 ) ; } else { e . printStackTrace ( ) ; System . out . println ( line ) ; } } } } }
va	6	public CSDS parse ( XMLEventReader eventReader , ZipFile zipFile , String derivedNamespace ) throws XMLStreamException , IOException , ExternalRefrenceNotFoundException { CSDS csds = new CSDS ( ) ; while ( eventReader . hasNext ( ) ) { XMLEvent event = eventReader . nextEvent ( ) ; switch ( event . getEventType ( ) ) { case XMLEvent . START_ELEMENT : StartElement se = event . asStartElement ( ) ; if ( se . getName ( ) . getLocalPart ( ) . equalsIgnoreCase ( "Header" ) && se . getName ( ) . getNamespaceURI ( ) . equalsIgnoreCase ( Constants . DEFAULT_NAMESPACE ) ) { HeaderParser hParser = new HeaderParser ( ) ; csds . setHeader ( hParser . parse ( eventReader , se , zipFile ) ) ; } if ( se . getName ( ) . getLocalPart ( ) . equalsIgnoreCase ( "DataSet" ) && se . getName ( ) . getNamespaceURI ( ) . equalsIgnoreCase ( derivedNamespace ) ) { DataSetParser dsParser = new DataSetParser ( ) ; csds . getDatasets ( ) . add ( dsParser . parse ( eventReader , se , zipFile , derivedNamespace ) ) ; } } } return csds ; }
va	1	public boolean end ( ) { return this . eof && ! this . usePrevious ; }
va	8	public boolean loadLevel ( String xmlFilePath ) { try { File xmlFile = new File ( xmlFilePath ) ; DocumentBuilderFactory dbFactory = DocumentBuilderFactory . newInstance ( ) ; DocumentBuilder dBuilder = dbFactory . newDocumentBuilder ( ) ; Document doc = dBuilder . parse ( xmlFile ) ; doc . getDocumentElement ( ) . normalize ( ) ; Node root = doc . getDocumentElement ( ) ; if ( root . getNodeName ( ) . equals ( XmlTag . LEVEL . toString ( ) ) ) { if ( parseTimer ( doc ) ) if ( parseGrid ( doc ) ) if ( parseRooms ( doc ) ) if ( parseExits ( doc ) ) if ( parseItems ( doc ) ) if ( parseCharacters ( doc ) ) { loaded = true ; return true ; } } } catch ( Exception e ) { System . out . println ( e . toString ( ) ) ; return false ; } return false ; }
va	1	private RectVertices drawInnerSquare ( Graphics g , RectVertices vertices ) { Square sq = new Square ( vertices ) ; RectVertices v = new RectVertices ( ) ; { if ( sq . isSlope ( ) ) { v = calculateInnerSquareVertices_OutSlope ( sq ) ; } else { v = calculateInnerSquareVertices_OutNotSlope ( sq ) ; } drawRect ( g , v ) ; } return v ; }
va	4	public boolean checkClase ( ArrayList < String > res ) { ArrayList < Clasa > cls = Centralizator . getInstance ( ) . getClasa ( ) ; for ( String s_c : res ) { boolean ok = false ; for ( Clasa c : cls ) { if ( s_c . equals ( c . getIdClasa ( ) ) ) { ok = true ; break ; } } if ( ! ok ) return false ; } return true ; }
va	9	private void getCountIncidencies ( int aval , Avaluacions avalSystem , HashMap < Integer , HashMap < String , SgdInc >> map , String identifier , ArrayList < Integer > listIds , boolean commentRequired ) { String desde ; String fins ; desde = new DataCtrl ( avalSystem . getFechaInicios ( ) . get ( "" + aval ) ) . getDataSQL ( ) ; fins = new DataCtrl ( avalSystem . getFechaFins ( ) . get ( "" + aval ) ) . getDataSQL ( ) ; String listAlumnes ; if ( doExpd > 0 ) { listAlumnes = " AND expediente+0 ='" + doExpd + "' " ; } else { listAlumnes = " AND expediente+0 IN (" + avalSystem . getListExpds ( ) + ") " ; } int nlen = listIds . size ( ) ; String condicio = "" ; if ( nlen > 0 ) { condicio = " (idTipoIncidencias=" + listIds . get ( 0 ) + " " ; for ( int i = 1 ; i < nlen ; i ++ ) { condicio += " OR idTipoIncidencias=" + listIds . get ( i ) + " " ; } condicio += " ) " ; condicio += listAlumnes ; if ( commentRequired ) { condicio += " AND NOT ((idTipoObservaciones IS NULL OR idTipoObservaciones=0) AND Comentarios='') " ; } String SQL1 = " SELECT expediente+0  sum(if(" + condicio + "   1   0)) AS totalal FROM " + sgdDB + ".faltasalumnos AS fal " + "  INNER JOIN " + sgdDB + ".alumnos AS alm ON alm.id = fal.idAlumnos " + "  WHERE dia >= '" + desde + "' AND dia <= '" + fins + "' " + "  GROUP BY expediente" ; try { Statement st = sgd . createStatement ( ) ; ResultSet rs1 = sgd . getResultSet ( SQL1 , st ) ; while ( rs1 != null && rs1 . next ( ) ) { int expd = rs1 . getInt ( 1 ) ; int count = rs1 . getInt ( 2 ) ; if ( count > 0 ) { boolean q = map . containsKey ( expd ) ; HashMap < String , SgdInc > mapInc = null ; if ( q ) { mapInc = map . get ( expd ) ; } else { mapInc = new HashMap < String , SgdInc > ( ) ; } boolean q2 = mapInc . containsKey ( identifier ) ; SgdInc sgdinc = null ; if ( q2 ) { sgdinc = mapInc . get ( identifier ) ; } else { sgdinc = new SgdInc ( ) ; sgdinc . ambit = avalSystem . getEnsenyament ( ) + " | " + avalSystem . getEstudis ( ) ; sgdinc . simbol = identifier ; mapInc . put ( identifier , sgdinc ) ; } if ( aval == 1 ) { sgdinc . n1a = count ; } else if ( aval == 2 ) { sgdinc . n2a = count ; } else if ( aval == 3 ) { sgdinc . n3a = count ; } map . put ( expd , mapInc ) ; } } if ( rs1 != null ) { rs1 . close ( ) ; st . close ( ) ; } } catch ( SQLException ex ) { Logger . getLogger ( SGDImporter . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } } }
va	1	private void jjCheckNAddStates ( int start , int end ) { do { jjCheckNAdd ( jjnextStates [ start ] ) ; } while ( start ++ != end ) ; }
va	5	public AntiGoal findExhausiveAntiGoalByAttributes ( String threat , String asset , String target , String protection ) { for ( AntiGoal ag : ag_elems ) { if ( ag . getThreat ( ) . equals ( threat ) && ag . getAsset ( ) . equals ( asset ) && ag . getTarget ( ) . equals ( target ) && ag . getProtection ( ) . equals ( protection ) ) { return ag ; } } return null ; }
va	5	void run ( ) { try { providerSocket = new ServerSocket ( 2004 , 10 ) ; System . out . println ( "Waiting for connection" ) ; connection = providerSocket . accept ( ) ; System . out . println ( "Connection received from " + connection . getInetAddress ( ) . getHostName ( ) ) ; out = new ObjectOutputStream ( connection . getOutputStream ( ) ) ; out . flush ( ) ; in = new ObjectInputStream ( connection . getInputStream ( ) ) ; sendMessage ( "Connection successful" ) ; do { try { message = ( String ) in . readObject ( ) ; System . out . println ( "client>" + message ) ; if ( message . equals ( "bye" ) ) sendMessage ( "bye" ) ; } catch ( ClassNotFoundException classnot ) { System . err . println ( "Data received in unknown format" ) ; } } while ( ! message . equals ( "bye" ) ) ; } catch ( IOException ioException ) { ioException . printStackTrace ( ) ; } finally { try { in . close ( ) ; out . close ( ) ; providerSocket . close ( ) ; } catch ( IOException ioException ) { ioException . printStackTrace ( ) ; } } }
va	0	private Singleton1 ( ) { }
va	6	protected int decodeUTF8inInternalEncodingBuffer ( byte [ ] data , int offset , int length ) throws IOException { ensureDecodingBufferSizeForUtf8String ( length ) ; int charlen = 0 , b1 ; int end = offset + length ; while ( offset < end ) { b1 = data [ offset ++ ] & FF ; if ( b1 < 80 ) _decodingBuffer [ charlen ++ ] = ( char ) b1 ; else { checkEndUTF8String ( offset , end ) ; int b2 = data [ offset ++ ] & FF ; checkContinuationUTF8octet ( b2 , offset - 1 ) ; if ( b1 < E0 ) { _decodingBuffer [ charlen ++ ] = ( char ) ( ( ( b1 & 1F ) << 6 ) | ( b2 & 3F ) ) ; } else { checkEndUTF8String ( offset , end ) ; int b3 = data [ offset ++ ] & FF ; checkContinuationUTF8octet ( b3 , offset - 1 ) ; if ( b1 < F0 ) { _decodingBuffer [ charlen ++ ] = ( char ) ( ( b1 & 0F ) << 12 | ( b2 & 3F ) << 6 | ( b3 & 3F ) ) ; } else { checkEndUTF8String ( offset , end ) ; int b4 = data [ offset ++ ] & FF ; checkContinuationUTF8octet ( b4 , offset - 1 ) ; int uc = ( ( b1 & 7 ) << 18 ) | ( ( b2 & 3f ) << 12 ) | ( ( b3 & 3f ) << 6 ) | ( b4 & 3f ) ; if ( uc < 0 || uc >= 200000 ) { throw new IOException ( "hign surrogate and low surrogate expected" ) ; } _decodingBuffer [ charlen ++ ] = ( char ) ( ( ( ( uc - 10000 ) >> 10 ) & 3FF ) + d800 ) ; _decodingBuffer [ charlen ++ ] = ( char ) ( ( ( ( uc - 10000 ) ) & 3FF ) + dc00 ) ; } } } } return charlen ; }
va	5	private void pop ( char c ) throws JSONException { if ( this . top <= 0 ) { throw new JSONException ( "Nesting error." ) ; } char m = this . stack [ this . top - 1 ] == null ? a : k ; if ( m != c ) { throw new JSONException ( "Nesting error." ) ; } this . top -= 1 ; this . mode = this . top == 0 ? d : this . stack [ this . top - 1 ] == null ? a : k ; }
va	0	public void addNewVersionListener ( NewVersionListener listener ) { listeners . add ( listener ) ; }
va	7	Writer write ( Writer writer , int indentFactor , int indent ) throws JSONException { try { boolean commanate = false ; int length = this . length ( ) ; writer . write ( [ ) ; if ( length == 1 ) { JSONObject . writeValue ( writer , this . myArrayList . get ( 0 ) , indentFactor , indent ) ; } else if ( length != 0 ) { final int newindent = indent + indentFactor ; for ( int i = 0 ; i < length ; i += 1 ) { if ( commanate ) { writer . write (   ) ; } if ( indentFactor > 0 ) { writer . write ( '' ) ; } JSONObject . indent ( writer , newindent ) ; JSONObject . writeValue ( writer , this . myArrayList . get ( i ) , indentFactor , newindent ) ; commanate = true ; } if ( indentFactor > 0 ) { writer . write ( '' ) ; } JSONObject . indent ( writer , indent ) ; } writer . write ( ] ) ; return writer ; } catch ( IOException e ) { throw new JSONException ( e ) ; } }
va	4	public Game retrieveOrCreateGameForPlayer ( String str ) { if ( str . equalsIgnoreCase ( "" ) ) { return null ; } for ( Game g : allGames ) { if ( g . getName ( ) . equalsIgnoreCase ( str ) ) { if ( debug ) { System . out . println ( "Game " + g . getName ( ) + " found." ) ; } return g ; } } System . out . println ( "Game " + str + " is not in the database! Update required." ) ; return null ; }
va	1	@ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( "{" ) ; if ( getAccount ( ) != null ) sb . append ( "Account: " + getAccount ( ) ) ; sb . append ( "}" ) ; return sb . toString ( ) ; }
va	2	public static Set < String > readSeedFile ( String goodSeedFilename ) { Set < String > goodSeedSet = new HashSet < String > ( ) ; try { BufferedReader in = new BufferedReader ( new FileReader ( new File ( goodSeedFilename ) ) ) ; String line = null ; while ( ( line = in . readLine ( ) ) != null ) { goodSeedSet . add ( line ) ; } in . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return goodSeedSet ; }
va	4	public Range ( long start , long end ) { this . from = start == null ? null : start . intValue ( ) ; this . to = end == null ? null : end . intValue ( ) ; if ( to != null && to < from ) { throw new RuntimeException ( ) ; } }
va	5	@ Deprecated @ Broken public static void bcucof ( final double [ ] y , final double [ ] y1 , final double [ ] y2 , final double [ ] y12 , final double d1 , final double d2 , final double [ ] [ ] c ) { int l , k , j , i ; double xx , d1d2 = d1 * d2 ; final double [ ] cl = doub_vec ( 16 ) , x = doub_vec ( 16 ) ; for ( i = 0 ; i < 4 ; i ++ ) { x [ i ] = y [ i ] ; x [ i + 4 ] = y1 [ i ] * d1 ; x [ i + 8 ] = y2 [ i ] * d2 ; x [ i + 12 ] = y12 [ i ] * d1d2 ; } for ( i = 0 ; i < 16 ; i ++ ) { xx = 0.0 ; for ( k = 0 ; k < 16 ; k ++ ) xx += wt [ i ] [ k ] * x [ k ] ; cl [ i ] = xx ; } l = 0 ; for ( i = 0 ; i < 4 ; i ++ ) for ( j = 0 ; j < 4 ; j ++ ) c [ i ] [ j ] = cl [ l ++ ] ; }
va	5	@ Override public int [ ] getIntData ( ) { if ( ptr != 0 ) { return null ; } else { if ( isConstant ( ) ) { if ( length > getMaxSizeOf32bitArray ( ) ) return null ; int [ ] out = new int [ ( int ) length ] ; for ( int i = 0 ; i < length ; i ++ ) { out [ i ] = data [ 0 ] ; } return out ; } else { int [ ] out = new int [ ( int ) length ] ; for ( int i = 0 ; i < length ; i ++ ) { out [ i ] = ( int ) data [ i ] ; } return out ; } } }
va	4	public boolean equals ( Object obj ) { if ( obj instanceof Parameters ) { Parameters pobj = ( Parameters ) obj ; return minX . equals ( pobj . minX ) && minY . equals ( pobj . minY ) && maxX . equals ( pobj . maxX ) && maxY . equals ( pobj . maxY ) ; } else { return false ; } }
va	4	public double asDouble ( ) { if ( Xt == XT_ARRAY_DOUBLE ) { double d [ ] = ( double [ ] ) cont ; if ( d != null && d . length > 0 ) return d [ 0 ] ; } return ( Xt == XT_DOUBLE ) ? ( ( double ) cont ) . doubleValue ( ) : double . NaN ; }
va	9	@ Override public int compare ( Card o1 , Card o2 ) { if ( o1 . isTrumpOrS ( trump ) && o2 . isTrumpOrS ( trump ) ) { return o1 . number . value - o2 . number . value ; } else if ( o1 . isTrumpOrS ( trump ) ) { return 1 ; } else if ( o2 . isTrumpOrS ( trump ) ) { return - 1 ; } else { if ( ruleSet == RuleSet . KRAEMER ) { if ( oughtOughtPlayed && ! oughtOughtLead ) { if ( o1 . isDouble ( ) && o2 . isDouble ( ) ) { return o1 . suit . value - o2 . suit . value ; } } } else { if ( oughtOughtPlayed || oughtOughtLead ) { if ( o1 . isDouble ( ) && o2 . isDouble ( ) ) { return o1 . suit . value - o2 . suit . value ; } } } int suitValDiffDiffs = o1 . suitValDiff ( ) - o2 . suitValDiff ( ) ; if ( suitValDiffDiffs == 0 ) { return - ( o1 . suit . value - o2 . suit . value ) ; } else { return - suitValDiffDiffs ; } } }
va	3	public boolean Atack ( Point x ) { if ( canAtack ( x ) ) { C . chat . AppendNotice ( ( isWhite ? "W:" : "B:" ) + Name + " A " + ( C . getFigure ( x ) . isWhite ? "W:" : "B:" ) + C . getFigure ( x ) . Name + " " + ( C . getIdSide ( Cord . x , false ) + 1 ) + ( char ) ( C . getIdSide ( Cord . y , true ) + 65 ) + ":" + ( C . getIdSide ( x . x , false ) + 1 ) + ( char ) ( C . getIdSide ( x . y , true ) + 65 ) ) ; C . delFigure ( x ) ; _Old = new Point ( Cord ) ; Cord = new Point ( x ) ; C . reMap ( _Old ) ; C . reMap ( x ) ; C . pxSel = null ; return true ; } else return false ; }
va	1	private static void errorPrint ( Throwable e ) { if ( e instanceof SQLException ) SQLExceptionPrint ( ( SQLException ) e ) ; else { System . out . println ( "A non SQL error occured." ) ; e . printStackTrace ( ) ; } }
