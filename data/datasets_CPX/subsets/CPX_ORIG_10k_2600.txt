tr	0	public final String readPropertyValue ( final String propertyName , final String defaultValue ) { return PROPERTIES . getProperty ( propertyName , defaultValue ) ; }
tr	7	private Vector [ ] buildHeaders ( JPanel panel , ColumnSet set , boolean blankOut , Vector [ ] refLabels ) { int numParents = set . getNumParents ( ) ; int numChildren = getNumChildren ( set ) ; Vector [ ] headers = new Vector [ 2 ] ; headers [ 0 ] = new Vector ( ) ; for ( int i = 0 ; i < set . getNumParents ( ) ; i ++ ) { ColumnParent parent = set . getParent ( i ) ; JLabel columnLabel = new JLabel ( ) ; int numColumns = parent . getNumChildren ( ) ; String text = parent . getText ( ) ; Color foreground = parent . getColor ( ) ; if ( blankOut ) { foreground = columnLabel . getBackground ( ) ; columnLabel . setMaximumSize ( new Dimension ( 32000 , 2 ) ) ; if ( refLabels != null ) { JLabel refLabel = ( JLabel ) refLabels [ 0 ] . get ( i ) ; columnLabel . setPreferredSize ( new Dimension ( refLabel . getPreferredSize ( ) . width , 2 ) ) ; } } columnLabel . setText ( text ) ; columnLabel . setForeground ( foreground ) ; columnLabel . setHorizontalAlignment ( SwingConstants . CENTER ) ; GridBagConstraints constraints = getParentConstraints ( numColumns , ( i == ( numParents - 1 ) ) ) ; gridbag . setConstraints ( columnLabel , constraints ) ; panel . add ( columnLabel ) ; headers [ 0 ] . add ( columnLabel ) ; } int index = 0 ; headers [ 1 ] = new Vector ( ) ; for ( int i = 0 ; i < set . getNumParents ( ) ; i ++ ) { ColumnParent parent = set . getParent ( i ) ; int numColumns = parent . getNumChildren ( ) ; for ( int j = 0 ; j < numColumns ; j ++ ) { ColumnChild child = parent . getChild ( j ) ; JLabel columnLabel = new JLabel ( ) ; String text = child . getText ( ) ; Color foreground = child . getColor ( ) ; if ( blankOut ) { foreground = columnLabel . getBackground ( ) ; columnLabel . setMaximumSize ( new Dimension ( 32000 , 2 ) ) ; if ( refLabels != null ) { JLabel refLabel = ( JLabel ) refLabels [ 1 ] . get ( index ) ; columnLabel . setPreferredSize ( new Dimension ( refLabel . getPreferredSize ( ) . width , 2 ) ) ; } } columnLabel . setText ( text ) ; columnLabel . setForeground ( foreground ) ; columnLabel . setHorizontalAlignment ( SwingConstants . CENTER ) ; GridBagConstraints constraints = getChildConstraints ( index == ( numChildren - 1 ) ) ; gridbag . setConstraints ( columnLabel , constraints ) ; panel . add ( columnLabel ) ; headers [ 1 ] . add ( columnLabel ) ; index ++ ; } } return headers ; }
tr	1	public static boolean isLinux ( String platform ) { return isLinux32 ( platform ) || isLinux64 ( platform ) ; }
tr	7	@ Override protected void performTask ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { IAction action = null ; String actionString = request . getParameter ( ConstantsJSP . ACTION ) ; if ( actionString == null ) { jump ( Constants . INDEX_JSP , request , response ) ; return ; } User user = null ; try { HttpSession session = request . getSession ( false ) ; if ( session != null ) { user = ( User ) session . getAttribute ( ConstantsJSP . USER ) ; } if ( user != null && user . getRole ( ) . ordinal ( ) >= Role . COURIER . ordinal ( ) ) { action = PlayCourierActions . valueOf ( actionString . toUpperCase ( ) ) . getAction ( ) ; } else { action = PlaysActions . valueOf ( actionString . toUpperCase ( ) ) . getAction ( ) ; } action . execute ( request , response ) ; if ( ! response . isCommitted ( ) ) { jump ( action . getDoneUrl ( ) , request , response ) ; } } catch ( IllegalArgumentException e ) { jumpError ( Constants . INDEX_JSP , Constants . INTERNAL_ERROR , request , response ) ; return ; } catch ( DAOException e ) { jumpError ( action . getErrorUrl ( ) , e . getMessage ( ) , request , response ) ; return ; } }
tr	7	public int [ ] plusOne ( int [ ] digits ) { if ( digits == null ) return null ; int carry = 0 ; for ( int i = digits . length - 1 ; i >= 0 ; i -- ) { if ( i == digits . length - 1 ) { digits [ i ] += 1 ; } else { digits [ i ] += carry ; } if ( digits [ i ] >= 10 ) { carry = 1 ; } else { carry = 0 ; } digits [ i ] = digits [ i ] % 10 ; if ( i == 0 && carry == 1 ) { int [ ] results = new int [ digits . length + 1 ] ; results [ 0 ] = 1 ; for ( int j = 1 ; j < results . length ; j ++ ) { results [ j ] = digits [ j - 1 ] ; } return results ; } } return digits ; }
tr	7	@ Override public void notificarCicloFinalizado ( ) { Tablero tablero = this . vp . obtenerTablero ( ) ; GameLoop gameLoop = this . vp . obtenerGameLoop ( ) ; ArrayList < Barco > listaBarco = tablero . getDestruidos ( ) ; for ( Barco barco : listaBarco ) { for ( Parte parte : barco . getCuerpo ( ) ) { ObjetoDibujable vista = MapaDeVistasDePartes . get ( parte ) ; if ( vista != null ) { gameLoop . remover ( vista ) ; MapaDeVistasDePartes . remove ( parte ) ; } } } ArrayList < Disparo > listaDisparo = tablero . getDisparosDetonados ( ) ; for ( Disparo disparo : listaDisparo ) { ObjetoDibujable vista = MapaDeVistasDeDisparos . get ( disparo ) ; if ( vista != null ) { gameLoop . remover ( vista ) ; MapaDeVistasDePartes . remove ( disparo ) ; } } listaDisparo . clear ( ) ; this . vp . obtenerEtiquetaPuntaje ( ) . setText ( "Puntaje: " + tablero . getPuntos ( ) ) ; if ( tablero . estaPerdido ( ) ) { JOptionPane . showMessageDialog ( null , "Lamentablemente Usted Perdio" ) ; this . reiniciarTablero ( ) ; } else if ( tablero . estaGanado ( ) ) { JOptionPane . showMessageDialog ( null , "Gano!!!!" ) ; this . reiniciarTablero ( ) ; } }
tr	6	public static Object deserialize ( final Integer type , final String string ) { if ( type == Settings_Deserializer . TYPE_TRADEABLE ) { final JSONDeserializer < ITradeable > jsondeserializer = new JSONDeserializer < ITradeable > ( ) ; ITradeable tradeable = null ; try { tradeable = jsondeserializer . deserialize ( string ) ; return tradeable ; } catch ( final Exception e ) { Printer . print ( Settings_Output . OUT_ERROR , "Deserializer error" , 0 , "Deserializer error" , "Unable to deserialize tradeable string starting with the following text:\n" + string . substring ( 0 , 100 ) + "[...]" ) ; return null ; } } else if ( type == Settings_Deserializer . TYPE_EVENT ) { final JSONDeserializer < Event > jsondeserializer = new JSONDeserializer < Event > ( ) ; Event event = null ; try { event = jsondeserializer . deserialize ( string ) ; return event ; } catch ( final Exception e ) { Printer . print ( Settings_Output . OUT_ERROR , "Deserializer error" , 0 , "Deserializer error" , "Unable to deserialize event string starting with the following text:\n" + string . substring ( 0 , 100 ) + "[...]" ) ; return null ; } } else if ( type == Settings_Deserializer . TYPE_ENVIRONMENT ) { final JSONDeserializer < IEnvironment > jsondeserializer = new JSONDeserializer < IEnvironment > ( ) ; IEnvironment environment = null ; try { environment = jsondeserializer . deserialize ( string ) ; return environment ; } catch ( final Exception e ) { Printer . print ( Settings_Output . OUT_ERROR , "Deserializer error" , 0 , "Deserializer error" , "Unable to deserialize environment string starting with the following text:\n" + string . substring ( 0 , 100 ) + "[...]" ) ; return null ; } } return null ; }
tr	3	public static String numberToString ( Number number ) throws JSONException { if ( number == null ) { throw new JSONException ( "Number must be non-null" ) ; } double doubleValue = number . doubleValue ( ) ; JSON . checkDouble ( doubleValue ) ; if ( number . equals ( NEGATIVE_ZERO ) ) { return "-0" ; } long longValue = number . longValue ( ) ; if ( doubleValue == ( double ) longValue ) { return long . toString ( longValue ) ; } return number . toString ( ) ; }
tr	3	public int randomSelect ( int p , int r , int i ) { if ( p == r ) { return data [ p ] ; } int q = randomizedPartition ( p , r ) ; int k = q - p + 1 ; if ( i == k ) { return data [ q ] ; } else if ( i < k ) { return randomSelect ( p , q - 1 , i ) ; } else { return randomSelect ( q + 1 , r , i - k ) ; } }
tr	6	public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; FileImageSource other = ( FileImageSource ) obj ; if ( file == null ) { if ( other . file != null ) return false ; } else if ( ! file . equals ( other . file ) ) return false ; return true ; }
tr	8	public GTFSPlugin getPlugin ( ) { if ( plugin == null ) { synchronized ( this ) { String pluginName = properties . getProperty ( "plugin" ) ; if ( pluginName == null ) { plugin = new DefaultPlugin ( ) ; } else { try { class < ? > pluginClass = class . forName ( pluginName ) ; boolean validPlugin = false ; for ( class < ? > c : pluginClass . getInterfaces ( ) ) { if ( c . equals ( GTFSPlugin . class ) ) { validPlugin = true ; } } if ( validPlugin ) plugin = ( GTFSPlugin ) pluginClass . newInstance ( ) ; else throw new IllegalArgumentException ( "The specified plugin is not found or not valid" ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( "The specified plugin is not found or not valid" ) ; } } } } return plugin ; }
tr	4	public Identifier BookBed ( Identifier userId , Identifier searchId ) { ArrayList < SearchBean < FreeBedDetailBean >> results = getLastSearchResult ( ) ; for ( SearchBean < FreeBedDetailBean > search : results ) { if ( search . getSearchId ( ) . equals ( searchId ) ) { FreeBedDetailBean bedDetail = search . getObjectInfo ( ) ; Identifier hostelId = search . getObjectId ( ) ; Booking booking = new Booking ( ) ; booking . setBedIds ( bedDetail . getBedIds ( ) ) ; ArrayList < Tariff > bedReservations = new ArrayList < Tariff > ( ) ; for ( int i = 0 ; i < booking . getBedIds ( ) . size ( ) ; i ++ ) { Tariff tariff = new Tariff ( bedDetail . getPrice ( ) . get ( i ) , bedDetail . getCheckIn ( ) , bedDetail . getCheckOut ( ) ) ; bedReservations . add ( tariff ) ; } booking . setBedReservations ( bedReservations ) ; booking . setBookingDate ( GenericUtility . getCurrentDateWithoutTime ( ) ) ; booking . setHostelId ( hostelId ) ; booking . setStatus ( BookingStatus . RESERVED ) ; booking . setUserId ( userId ) ; try { return Bookings . getInstance ( ) . create ( booking ) ; } catch ( DataBaseReadWriteException | IdentifierAlreadyExistsException | InvalidIdentifierException | InvalidParameterException | ConflictException | IdentifierNotFoundException e ) { } } } return null ; }
tr	6	public void paintComponent ( Graphics g2 ) { int w = getWidth ( ) / 2 + 1 ; int h = getHeight ( ) / 2 + 1 ; if ( ( img == null ) || ( img . getWidth ( null ) != w ) || ( img . getHeight ( null ) != h ) ) { img = createImage ( w , h ) ; Graphics g = img . getGraphics ( ) ; for ( int x = 0 ; x <= w / 32 ; x ++ ) { for ( int y = 0 ; y <= h / 32 ; y ++ ) g . drawImage ( bgImage , x * 32 , y * 32 , null ) ; } if ( ( g instanceof Graphics2D ) ) { Graphics2D gg = ( Graphics2D ) g ; int gh = 1 ; gg . setPaint ( new GradientPaint ( new Point2D . float ( 0.0F , 0.0F ) , new Color ( 45 , 118 , 214 ) , new Point2D . float ( 0.0F , gh ) , new Color ( 0 , true ) ) ) ; gg . fillRect ( 0 , 0 , w , gh ) ; gh = h ; gg . setPaint ( new GradientPaint ( new Point2D . float ( 0.0F , 0.0F ) , new Color ( 0 , true ) , new Point2D . float ( 0.0F , gh ) , new Color ( 553648127 , true ) ) ) ; gg . fillRect ( 0 , 0 , w , gh ) ; } g . dispose ( ) ; } g2 . drawImage ( img , 0 , 0 , w * 2 , h * 2 , null ) ; }
tr	4	private int getParticleSize ( Particle p ) { double time = p . getTime ( ) ; if ( time > 3 ) return 28 ; else if ( time > 2 ) return 20 ; else if ( time > .8 ) return 14 ; else if ( time > .4 ) return 12 ; else return 10 ; }
tr	3	public boolean transferir ( int nc1 , int nc2 , double m ) { CuentaBancaria c1 = search ( nc1 ) ; CuentaBancaria c2 = search ( nc2 ) ; if ( c1 != null && c2 != null ) { if ( c1 . retiro ( m ) ) { c2 . deposito ( m ) ; return true ; } } return false ; }
tr	4	@ SuppressWarnings ( "static-access" ) public static void main ( String [ ] args ) { Options options = new Options ( ) ; options . addOption ( OptionBuilder . withLongOpt ( OPT_IN ) . hasArg ( ) . withDescription ( "Input file (type ifolor)" ) . isRequired ( ) . create ( i ) ) ; options . addOption ( OptionBuilder . withLongOpt ( OPT_OUT ) . hasArg ( ) . withDescription ( "Output file (type scibus)" ) . isRequired ( ) . create ( o ) ) ; options . addOption ( OptionBuilder . withLongOpt ( OPT_ABSOLUTE_PATHS ) . withDescription ( "Convert resource paths (eg. images) to absolute paths" ) . create ( ) ) ; options . addOption ( OptionBuilder . withLongOpt ( OPT_TEST ) . withDescription ( "Test mode (only first 4 pages)" ) . create ( t ) ) ; CommandLineParser parser = new PosixParser ( ) ; CommandLine cmd ; try { cmd = parser . parse ( options , args ) ; } catch ( ParseException e ) { System . out . println ( "Unexpected exception:" + e . getMessage ( ) ) ; HelpFormatter formatter = new HelpFormatter ( ) ; formatter . printHelp ( IfolorToScribusMain . class . getSimpleName ( ) + " --in <file.dpp> --out <file.sla>" , options ) ; return ; } log . trace ( "infile: " + cmd . getOptionValue ( OPT_IN ) ) ; log . trace ( "outfile: " + cmd . getOptionValue ( OPT_OUT ) ) ; log . trace ( "absolutePaths: " + cmd . hasOption ( OPT_ABSOLUTE_PATHS ) ) ; log . trace ( "test: " + cmd . hasOption ( OPT_TEST ) ) ; try { File infile = new File ( cmd . getOptionValue ( OPT_IN ) ) ; if ( ! infile . exists ( ) ) { System . err . println ( "input file " + infile + " does not exist" ) ; System . exit ( 1 ) ; } ProjectPath path = new ProjectPath ( infile ) ; File outFile = new File ( cmd . getOptionValue ( OPT_OUT ) ) ; IfolorLoader loader = new IfolorLoader ( ) ; Book book = loader . load ( path ) ; if ( cmd . hasOption ( OPT_TEST ) ) book . reducePagesForTesting ( ) ; ScribusExporter f = new ScribusExporter ( ) ; f . export ( outFile , book ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } }
tr	6	public void method361 ( int i , int k ) { i += anInt1454 ; k += anInt1455 ; int l = i + k * DrawingArea . width ; int i1 = 0 ; int j1 = anInt1453 ; int k1 = anInt1452 ; int l1 = DrawingArea . width - k1 ; int i2 = 0 ; if ( k < DrawingArea . topY ) { int j2 = DrawingArea . topY - k ; j1 -= j2 ; k = DrawingArea . topY ; i1 += j2 * k1 ; l += j2 * DrawingArea . width ; } if ( k + j1 > DrawingArea . bottomY ) j1 -= ( k + j1 ) - DrawingArea . bottomY ; if ( i < DrawingArea . topX ) { int k2 = DrawingArea . topX - i ; k1 -= k2 ; i = DrawingArea . topX ; i1 += k2 ; l += k2 ; i2 += k2 ; l1 += k2 ; } if ( i + k1 > DrawingArea . bottomX ) { int l2 = ( i + k1 ) - DrawingArea . bottomX ; k1 -= l2 ; i2 += l2 ; l1 += l2 ; } if ( ! ( k1 <= 0 || j1 <= 0 ) ) { method362 ( j1 , DrawingArea . pixels , aByteArray1450 , l1 , l , k1 , i1 , anIntArray1451 , i2 ) ; } }
tr	8	public void exit ( SimpleFrame frame ) { File tempFile = new File ( frame . fileName ) ; if ( tempFile . exists ( ) ) tempFile . delete ( ) ; JFileChooser chooser = new JFileChooser ( ) ; chooser . setCurrentDirectory ( new File ( "." ) ) ; if ( frame . getIsChanged ( ) ) { int selection = JOptionPane . showConfirmDialog ( null , "Do you want save document?" , "Warrning" , JOptionPane . YES_NO_OPTION , JOptionPane . WARNING_MESSAGE ) ; if ( selection == JOptionPane . NO_OPTION ) { try { frame . getClient ( ) . close ( ) ; frame . getPtr ( ) . Disconnect ( frame . getProjName ( ) , frame . getLogin ( ) ) ; } catch ( RemoteException e1 ) { JOptionPane . showMessageDialog ( frame , "Disconect from Server" ) ; return ; } System . exit ( 0 ) ; } if ( selection == JOptionPane . YES_OPTION ) { chooser . setCurrentDirectory ( new File ( "." ) ) ; int result = chooser . showSaveDialog ( null ) ; if ( result == JFileChooser . APPROVE_OPTION ) { frame . fileName = chooser . getSelectedFile ( ) . getPath ( ) ; PrintWriter out ; try { out = new PrintWriter ( new FileWriter ( frame . fileName ) ) ; String str = frame . getText ( ) . getText ( ) ; out . print ( str ) ; out . close ( ) ; } catch ( IOException e ) { JOptionPane . showMessageDialog ( frame , "Saving error" ) ; } } else { return ; } } } else { try { frame . getClient ( ) . close ( ) ; frame . getPtr ( ) . Disconnect ( frame . getProjName ( ) , frame . getLogin ( ) ) ; } catch ( RemoteException e1 ) { JOptionPane . showMessageDialog ( frame , "Disconect from Server" ) ; return ; } System . exit ( 0 ) ; } }
tr	7	public void draw ( Graphics2D g , Player player ) { int Px = player . getScreenXpos ( ) / 32 ; int Py = ( player . getScreenYpos ( ) / 32 ) ; int arroundX = 16 ; int arroundY = 10 ; int someX = Px - arroundX ; int someXMax = Px + arroundX ; int someY = Py - arroundY ; int someYMax = Py + arroundY ; for ( int row = someY ; row < someYMax ; row ++ ) { for ( int col = someX ; col < someXMax ; col ++ ) { if ( row >= 0 && row < mapYRows ) ; else continue ; if ( col >= 0 && col < mapXRows ) ; else continue ; if ( map [ row ] [ col ] == 0 ) continue ; final int rc = map [ row ] [ col ] ; final int r = rc / numTilesAcross ; final int c = rc % numTilesAcross ; g . drawImage ( tiles [ r ] [ c ] . getImage ( ) , ( int ) x + ( col * tileSize ) , ( int ) y + ( row * tileSize ) , null ) ; } } }
tr	8	public void init ( ) { try { Level . loadBehaviors ( new DataInputStream ( ResourcesManager . class . getResourceAsStream ( "res/tiles.dat" ) ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; System . exit ( 0 ) ; } if ( level == null ) if ( isCustom ) { MyLevelGenerator clg = new MyLevelGenerator ( ) ; GamePlay gp = new GamePlay ( ) ; gp = gp . read ( "player.txt" ) ; currentLevel = ( Level ) clg . generateLevel ( gp ) ; String detailedInfo = FileHandler . readFile ( "DetailedInfo.txt" ) ; } else currentLevel = new RandomLevel ( 320 , 15 , levelSeed , levelDifficulty , levelType ) ; try { level = currentLevel . clone ( ) ; } catch ( CloneNotSupportedException e ) { e . printStackTrace ( ) ; } Art . startMusic ( 1 ) ; paused = false ; Sprite . spriteContext = this ; sprites . clear ( ) ; layer = new LevelRenderer ( level , graphicsConfiguration , 320 , 240 ) ; for ( int i = 0 ; i < 2 ; i ++ ) { int scrollSpeed = 4 >> i ; int w = ( ( level . getWidth ( ) * 16 ) - 320 ) / scrollSpeed + 320 ; int h = ( ( level . getHeight ( ) * 16 ) - 240 ) / scrollSpeed + 240 ; Level bgLevel = BgLevelGenerator . createLevel ( w / 32 + 1 , h / 32 + 1 , i == 0 , levelType ) ; bgLayer [ i ] = new BgRenderer ( bgLevel , graphicsConfiguration , 320 , 240 , scrollSpeed ) ; } double oldX = 0 ; if ( mario != null ) oldX = mario . x ; mario = new Mario ( this ) ; sprites . add ( mario ) ; startTime = 1 ; timeLeft = 200 * 15 ; tick = 0 ; switchPoints = new ArrayList < double > ( ) ; int squareSize = 16 ; int sections = 10 ; double startX = 32 ; double endX = level . getxExit ( ) * squareSize ; if ( ! isCustom && recorder == null ) recorder = new DataRecorder ( this , ( RandomLevel ) level , keys ) ; gameStarted = false ; }
tr	3	@ Override public void run ( ) { Player [ ] players = plugin . getServer ( ) . getOnlinePlayers ( ) ; Player player ; long MarkerTime = System . currentTimeMillis ( ) - ( plugin . getConfig ( ) . getInt ( "AFK_TIMER" ) * 60 * 1000 ) ; for ( int i = 0 ; ( players . length - 1 ) >= i ; i ++ ) { long afkTime = 0 ; player = players [ i ] ; UserTable ut = plugin . getDatabase ( ) . find ( UserTable . class ) . where ( ) . ieq ( "userName" , player . getName ( ) ) . findUnique ( ) ; afkTime = plugin . users . get ( player . getName ( ) ) ; if ( afkTime < MarkerTime ) { if ( ! ut . isAfk ( ) ) { ut . setAfk ( true ) ; ut . setAfkTime ( System . currentTimeMillis ( ) ) ; plugin . getDatabase ( ) . save ( ut ) ; plugin . getServer ( ) . broadcastMessage ( ChatColor . YELLOW + player . getDisplayName ( ) + " has been flaged afk" ) ; } } } }
tr	7	public boolean start ( ) { synchronized ( optOutLock ) { if ( isOptOut ( ) ) { return false ; } if ( task != null ) { return true ; } task = plugin . getServer ( ) . getScheduler ( ) . runTaskTimerAsynchronously ( plugin , new Runnable ( ) { private boolean firstPost = true ; public void run ( ) { try { synchronized ( optOutLock ) { if ( isOptOut ( ) && task != null ) { task . cancel ( ) ; task = null ; for ( Graph graph : graphs ) { graph . onOptOut ( ) ; } } } postPlugin ( ! firstPost ) ; firstPost = false ; } catch ( IOException e ) { if ( debug ) { Bukkit . getLogger ( ) . log ( Level . INFO , "[Metrics] " + e . getMessage ( ) ) ; } } } } , 0 , PING_INTERVAL * 1200 ) ; return true ; } }
tr	0	protected void setIndex ( int index ) { this . index = index ; }
tr	5	@ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; Schedule schedule = ( Schedule ) o ; if ( id != schedule . id ) return false ; if ( seqNumber != schedule . seqNumber ) return false ; return true ; }
tr	2	public T first ( UnaryFunction < T , boolean > predicate ) { while ( hasNext ( ) ) { final T value = next ( ) ; if ( predicate . invoke ( value ) ) { return value ; } } throw new NoSuchElementException ( ) ; }
tr	8	public int getResult ( ) { sqrs . add ( 1 ) ; sqrs . add ( 4 ) ; for ( int sum = 6 ; ; sum ++ ) { if ( sum % 300 == 0 ) { System . out . println ( sum + " debug " ) ; System . out . println ( sqrs . size ( ) + " siize " ) ; } for ( int i = sum - 3 ; i > sum / 2 ; i -- ) { for ( int j = i - 1 ; j > 2 ; j -- ) { int k = sum - i - j ; if ( k >= j || k <= 0 ) continue ; if ( i + j + k == sum ) { if ( checkSum ( i , j , k ) ) { System . out . println ( i + " " + j + " " + k + " sum " + sum ) ; return sum ; } } } } } }
tr	3	@ Override public boolean removeHandler ( String name ) { Handler handler = handlers_ . get ( name ) ; if ( handler == null ) { return false ; } catch_all_handlers_ . remove ( handler ) ; if ( handlers_ . remove ( name ) == null ) { return false ; } if ( handlers_ . isEmpty ( ) ) { node_ . removeHandler ( virtual_handler_ . getName ( ) ) ; } return true ; }
tr	6	private List < Student > parse ( final Document doc ) { final List < Student > students = new Vector < Student > ( ) ; if ( doc == null ) { return students ; } final Element root = doc . getDocumentElement ( ) ; final NodeList nodeStudents = root . getChildNodes ( ) ; if ( nodeStudents != null ) { if ( nodeStudents . getLength ( ) != 0 ) { for ( int i = 0 ; i < nodeStudents . getLength ( ) ; ++ i ) { final Node nodeStudent = nodeStudents . item ( i ) ; if ( nodeStudent != null ) { if ( nodeStudent . getNodeType ( ) == Node . ELEMENT_NODE ) { final Student student = parseStudent ( nodeStudent ) ; students . add ( student ) ; } } } } } return students ; }
tr	6	public void clickActionListener ( final JButton btn ) { btn . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent arg0 ) { for ( int i = 0 ; i < suggestedButtonsNames . length ; i ++ ) if ( existingBoats . contains ( suggestedButtonsNames [ i ] ) ) { System . out . println ( "Ne mozes postaviti brod na to polje!" ) ; return ; } int sifraBroda = workingFrame . updateLabels ( ) ; if ( ( sifraBroda ) != - 1 ) { for ( int i = 0 ; i < 10 ; i ++ ) for ( int j = 0 ; j < 10 ; j ++ ) { if ( myButtonGameBoard [ i ] [ j ] . isBorderPainted ( ) ) { existingBoats . add ( myButtonGameBoard [ i ] [ j ] . getName ( ) ) ; myButtonGameBoard [ i ] [ j ] . setIcon ( shipImage ) ; gameBoardMask . FillStartMatrix ( i , j , sifraBroda ) ; } } } gameBoardMask . ispisi ( ) ; logicMatrix = gameBoardMask . gameBoard ; } } ) ; }
tr	6	public static void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; int size = input . nextInt ( ) ; while ( size < 1 || size > 100 ) { System . out . println ( "Size is not within range." ) ; System . out . println ( "Size should be > 0 and < 100." ) ; size = input . nextInt ( ) ; } int [ ] [ ] array = new int [ size ] [ size ] ; for ( int row = 0 ; row < size ; row ++ ) { for ( int col = 0 ; col < size ; col ++ ) { array [ row ] [ col ] = input . nextInt ( ) ; while ( array [ row ] [ col ] > 127 || array [ row ] [ col ] < - 127 ) { System . out . println ( array [ row ] [ col ] + " is not within range." ) ; System . out . println ( "Enter a number between -127 and 127" ) ; array [ row ] [ col ] = input . nextInt ( ) ; } } } input . close ( ) ; MaxSum maxSum = new MaxSum ( array ) ; System . out . println ( maxSum . getMaxSum ( ) ) ; System . out . println ( maxSum . toString ( ) ) ; }
tr	7	public static ProbabilityDistribution respond ( ProbabilityDistribution pd , PricingPolicy policy , PricingPolicy baseline , double awareness , double sensitivity , String responseType ) { double w = 2 ; double [ ] previousHist = pd . getHistogram ( ) ; double [ ] newHist = new double [ Constants . MIN_IN_DAY ] ; double [ ] policyArr = policy . getTOUArray ( ) ; double [ ] baseArr = baseline . getTOUArray ( ) ; switch ( responseType ) { case "None" : return pd ; case "Optimal" : newHist = shiftingOptimal ( previousHist , baseArr , policyArr , w * awareness , w * sensitivity ) ; break ; case "Normal" : newHist = shiftingNormal ( previousHist , baseArr , policyArr , w * awareness , w * sensitivity ) ; break ; case "Discrete" : newHist = shiftingDiscrete ( previousHist , baseArr , policyArr , w * awareness , w * sensitivity ) ; break ; case "Daily" : newHist = shiftingDaily ( previousHist , baseArr , policyArr , awareness , sensitivity ) ; for ( int i = 0 ; i < newHist . length ; i ++ ) { if ( double . isNaN ( newHist [ i ] ) ) { newHist [ i ] = 0.0 ; } } break ; default : return pd ; } ProbabilityDistribution retPd = new Histogram ( newHist ) ; return retPd ; }
tr	7	private JSONWriter append ( String s ) throws JSONException { if ( s == null ) { throw new JSONException ( "Null pointer" ) ; } if ( this . mode == o || this . mode == a ) { try { if ( this . , && this . mode == a ) { this . writer . write (   ) ; } this . writer . write ( s ) ; } catch ( IOException e ) { throw new JSONException ( e ) ; } if ( this . mode == o ) { this . mode = k ; } this . , = true ; return this ; } throw new JSONException ( "Value out of sequence." ) ; }
tr	0	@ Override public void paintComponents ( Graphics g ) { g . setClip ( m_areaFill ) ; super . paintComponents ( g ) ; paintBorder ( g ) ; }
tr	1	public static void main ( String [ ] args ) { int numCases = in . nextInt ( ) ; for ( int i = 0 ; i < numCases ; i ++ ) { processCase ( i + 1 ) ; } }
tr	2	private Matrix4f getParentMatrix ( ) { if ( parent != null && parent . hasChanged ( ) ) parentMatrix = parent . getTransformation ( ) ; return parentMatrix ; }
tr	4	public void drive ( int start , int stop ) { if ( ! simAborted && userState == seqStarted ) { Station s1 = stations . get ( start ) ; Station s2 = stations . get ( stop ) ; if ( s1 == null || s2 == null ) { return ; } synchronized ( lock ) { mapEntries . add ( new Route ( s1 , s2 ) ) ; } } }
tr	7	public ListPanel ( CharRecord record ) { try { this . setLayout ( new BorderLayout ( ) ) ; this . setPreferredSize ( new Dimension ( 700 , 400 ) ) ; String [ ] columnNames = { "Order" , "Pinyin" , "Chinese" , "Trad" , "English" , "Book" , "Chap" } ; int [ ] widths = loadColumnWidths ( ) ; model = new RecordTableModel ( record ) ; TableSorter sorter = new TableSorter ( model ) ; table = new JTable ( sorter ) ; sorter . setTableHeader ( table . getTableHeader ( ) ) ; TableCellRenderer renderer = new MyRenderer ( ) ; for ( int i = 0 ; i < columnNames . length ; i ++ ) { TableColumn col = table . getColumnModel ( ) . getColumn ( i ) ; col . setPreferredWidth ( widths [ i ] ) ; col . setHeaderValue ( columnNames [ i ] ) ; col . setCellRenderer ( renderer ) ; } table . setRowHeight ( ROW_HEIGHT ) ; table . getTableHeader ( ) . setResizingAllowed ( true ) ; table . getTableHeader ( ) . setReorderingAllowed ( false ) ; table . getTableHeader ( ) . setBackground ( CharApp . COLOR_BG ) ; table . setRowSelectionAllowed ( true ) ; table . setAutoCreateColumnsFromModel ( false ) ; scroller = new JScrollPane ( table ) ; scroller . getVerticalScrollBar ( ) . setBackground ( CharApp . COLOR_BG ) ; scroller . getHorizontalScrollBar ( ) . setBackground ( CharApp . COLOR_BG ) ; this . add ( scroller , BorderLayout . CENTER ) ; MouseListener ml = new MouseAdapter ( ) { public void mouseClicked ( MouseEvent e ) { if ( e . getClickCount ( ) == 1 && e . getButton ( ) == MouseEvent . BUTTON3 ) { Point origin = e . getPoint ( ) ; int row = table . rowAtPoint ( origin ) ; if ( row > - 1 ) { } } else if ( e . getClickCount ( ) == 2 && e . getButton ( ) == MouseEvent . BUTTON1 ) { CharApp . getInstance ( ) . editRecord ( ) ; } } } ; table . addMouseListener ( ml ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; System . exit ( 1 ) ; } }
tr	1	public boolean sendString ( String strToSend , int client ) throws IOException { boolean success = false ; try { outData [ client ] . writeBytes ( strToSend ) ; outData [ client ] . writeByte ( 0 ) ; success = true ; } catch ( IOException e ) { System . out . println ( "Caught IOException Writing To Socket Stream!" ) ; throw ( e ) ; } return success ; }
tr	0	public int getIxBugEventLatestText ( ) { return ixBugEventLatestText ; }
tr	2	@ Test public void testResolve_when_assimilating_untrusted_thenables_should_trap_exceptions_during_assimilation ( ) throws Exception { RuntimeException t = new RuntimeException ( ) ; when . resolve ( new Thenable < Integer > ( ) { @ Override public < U > Thenable < U > then ( Function < Integer , ? extends Thenable < U >> onFulfilled , Function < Throwable , ? extends Thenable < U >> onRejected ) { throw t ; } } ) . then ( fail . onFulfilled , val -> { assertEquals ( t , val ) ; return null ; } ) . then ( done . onFulfilled , done . onRejected ) ; done . assertFulfilled ( ) ; }
tr	9	static String valueToString ( Object value , int indentFactor , int indent ) throws JSONException { if ( value == null || value . equals ( null ) ) { return "null" ; } try { if ( value instanceof JSONString ) { Object o = ( ( JSONString ) value ) . toJSONString ( ) ; if ( o instanceof String ) { return ( String ) o ; } } } catch ( Exception ignore ) { } if ( value instanceof Number ) { return numberToString ( ( Number ) value ) ; } if ( value instanceof boolean ) { return value . toString ( ) ; } if ( value instanceof JSONObject ) { return ( ( JSONObject ) value ) . toString ( indentFactor , indent ) ; } if ( value instanceof JSONArray ) { return ( ( JSONArray ) value ) . toString ( indentFactor , indent ) ; } if ( value instanceof Map ) { return new JSONObject ( ( Map ) value ) . toString ( indentFactor , indent ) ; } if ( value instanceof Collection ) { return new JSONArray ( ( Collection ) value ) . toString ( indentFactor , indent ) ; } if ( value . getClass ( ) . isArray ( ) ) { return new JSONArray ( value ) . toString ( indentFactor , indent ) ; } return quote ( value . toString ( ) ) ; }
tr	0	public void setHabs ( Set < TipusHabInformation > habs ) { this . habs = habs ; }
tr	5	public void inst_main ( String args [ ] ) { int iterations = 1000 ; String options = "" ; if ( args != null && args . length > 0 ) iterations = Integer . parseInt ( args [ 0 ] ) ; if ( args != null && args . length > 1 ) options = args [ 1 ] ; long startTime = System . currentTimeMillis ( ) ; for ( int j = 0 ; j < iterations ; ++ j ) { chainTest ( 100 ) ; projectionTest ( 100 ) ; } long endTime = System . currentTimeMillis ( ) ; total_ms = endTime - startTime ; System . out . println ( "DeltaBlue\tJava\t" + options + "\t" + iterations + "x\t" + ( ( double ) total_ms / iterations ) + " ms" ) ; }
tr	7	@ Override public void getInput ( ) { int selection = - 1 ; boolean isValid = false ; do { this . displayMenu ( ) ; Scanner input = SnakeWithPartner . getInFile ( ) ; do { try { selection = input . nextInt ( ) ; isValid = true ; } catch ( NumberFormatException numx ) { System . out . println ( "Invalid Input. Please input a valid number." ) ; isValid = false ; } } while ( ! isValid ) ; switch ( selection ) { case 1 : this . playMenuControl . playEasy ( ) ; break ; case 2 : this . playMenuControl . playMedium ( ) ; break ; case 3 : this . playMenuControl . playHard ( ) ; break ; case 0 : break ; default : System . out . println ( "Please enter a valid menu item:" ) ; continue ; } } while ( selection != 0 ) ; }
tr	4	public static void main ( String [ ] args ) { JFrame frame = new JFrame ( ) ; frame . setSize ( 1500 , 1000 ) ; frame . setLocationRelativeTo ( null ) ; frame . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; frame . setVisible ( true ) ; final TaskmgrGraph graph = new TaskmgrGraph ( new TaskmgrColors ( ) ) ; new Thread ( "Memory thread" ) { @ Override public void run ( ) { while ( true ) { Runtime rt = Runtime . getRuntime ( ) ; long current = ( rt . totalMemory ( ) - rt . freeMemory ( ) ) / 1024 / 1024 ; long max = rt . totalMemory ( ) / 1024 / 1024 ; int % = ( int ) ( ( ( float ) current / ( float ) max ) * 100 ) ; graph . setMaximum ( ( int ) max ) ; graph . addValue ( ( int ) current ) ; graph . setText ( current + " mb" ) ; System . out . println ( "Current usage: " + current + "  Maximum usage: " + max + "  Percent: " + % ) ; try { Thread . sleep ( 1000 ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } } } ; new Thread ( "Random thread" ) { @ Override public void run ( ) { while ( true ) { graph . setMaximum ( 10000 ) ; int value = new Random ( ) . nextInt ( 10000 ) ; graph . addValue ( value ) ; graph . setText ( value + "" ) ; try { Thread . sleep ( 1000 ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } } } . start ( ) ; frame . add ( graph ) ; }
tr	2	public static int [ ] idea_subkeys ( byte [ ] key ) { int [ ] encryptKeys = new int [ 52 ] ; int k1 ; for ( k1 = 0 ; k1 < 8 ; ++ k1 ) encryptKeys [ k1 ] = ( ( key [ 2 * k1 ] & ff ) << 8 ) | ( key [ 2 * k1 + 1 ] & ff ) ; for ( ; k1 < 52 ; ++ k1 ) encryptKeys [ k1 ] = ( ( encryptKeys [ k1 - 8 ] << 9 ) | ( encryptKeys [ k1 - 7 ] >>> 7 ) ) & ffff ; return encryptKeys ; }
tr	1	private boolean ButtonIconSetUp ( ) { m_ConnectFourButton = new JButton ( ) ; m_OthelloButton = new JButton ( ) ; try { Image imgOthello = ImageIO . read ( getClass ( ) . getResource ( "Othello.jpeg" ) ) ; Image imgConnectFour = ImageIO . read ( getClass ( ) . getResource ( "ConnectFour.jpeg" ) ) ; m_ConnectFourButton . setIcon ( new ImageIcon ( imgConnectFour ) ) ; m_OthelloButton . setIcon ( new ImageIcon ( imgOthello ) ) ; } catch ( IOException ex ) { ex . printStackTrace ( ) ; } return true ; }
tr	5	public void dfsIter ( String label , Function < Vertex , Vertex > action ) { boolean foundUnVisted = false ; Vertex v = getVertex ( label ) ; while ( v != null ) { foundUnVisted = false ; if ( ! v . wasVisited ( ) ) { action . apply ( v ) ; v . setVisited ( true ) ; stackVertices . push ( v ) ; } JList < Vertex > listOfAdjacent = getEdges ( mapOfVerticeIndex . get ( v . getLabel ( ) ) ) ; for ( Vertex t : listOfAdjacent ) { if ( ! t . wasVisited ( ) ) { foundUnVisted = true ; v = t ; break ; } } if ( ! foundUnVisted ) { v = stackVertices . pop ( ) ; } } }
tr	0	public void setDocumentTable ( Hashtable < String , ArrayList < String >> documentTable ) { this . documentTable = documentTable ; }
tr	3	int open_callbacks ( InputStream is , byte [ ] initial , int ibytes ) throws JOrbisException { int ret ; datasource = is ; oy . init ( ) ; if ( initial != null ) { int index = oy . buffer ( ibytes ) ; System . arraycopy ( initial , 0 , oy . data , index , ibytes ) ; oy . wrote ( ibytes ) ; } if ( is instanceof SeekableInputStream ) { ret = open_seekable ( ) ; } else { ret = open_nonseekable ( ) ; } if ( ret != 0 ) { datasource = null ; clear ( ) ; } return ret ; }
tr	6	public void condFlushLine ( Out fout , int indent ) { int i ; if ( linelen > 0 ) { if ( indent + linelen >= this . configuration . wraplen ) wrapLine ( fout , indent ) ; if ( ! inAttVal || this . configuration . IndentAttributes ) { for ( i = 0 ; i < indent ; ++ i ) fout . outc ( ( int )   ) ; } for ( i = 0 ; i < linelen ; ++ i ) fout . outc ( linebuf [ i ] ) ; fout . newline ( ) ; linelen = 0 ; wraphere = 0 ; inAttVal = false ; } }
tr	4	public static int days ( int month , int year ) { if ( month == 2 ) return 28 + ( ( year % 4 == 0 ) ? 1 : 0 ) - ( ( year % 4 == 100 ) ? 1 : 0 ) ; if ( month < 8 ) return 30 + ( month % 2 ) ; return 31 - ( month % 2 ) ; }
tr	0	public void addPOS ( POS pos ) { posArray . add ( pos ) ; }
tr	5	private void drawGhosts ( ) { for ( int index = 0 ; index < G . NUM_GHOSTS ; index ++ ) { int loc = game . getCurGhostLoc ( index ) ; int x = game . getX ( loc ) ; int y = game . getY ( loc ) ; if ( game . getEdibleTime ( index ) > 0 ) { if ( game . getEdibleTime ( index ) < _G_ . EDIBLE_ALERT && ( ( game . getTotalTime ( ) % 6 ) / 3 ) == 0 ) bufferGraphics . drawImage ( ghostsImgs [ 5 ] [ 0 ] [ ( game . getTotalTime ( ) % 6 ) / 3 ] , x * MAG - 1 , y * MAG + 3 , null ) ; else bufferGraphics . drawImage ( ghostsImgs [ 4 ] [ 0 ] [ ( game . getTotalTime ( ) % 6 ) / 3 ] , x * MAG - 1 , y * MAG + 3 , null ) ; } else { if ( game . getLairTime ( index ) > 0 ) bufferGraphics . drawImage ( ghostsImgs [ index ] [ G . UP ] [ ( game . getTotalTime ( ) % 6 ) / 3 ] , x * MAG - 1 + ( index * 5 ) , y * MAG + 3 , null ) ; else bufferGraphics . drawImage ( ghostsImgs [ index ] [ game . getCurGhostDir ( index ) ] [ ( game . getTotalTime ( ) % 6 ) / 3 ] , x * MAG - 1 , y * MAG + 3 , null ) ; } } }
tr	3	public static boolean isLeapYear ( int y ) { if ( ( y % 4 == 0 && y % 100 != 100 ) || y % 400 == 0 ) return true ; else return false ; }
tr	0	@ Override public void init ( GameContainer gc , StateBasedGame sbg ) throws SlickException { this . sbg = sbg ; logo = new Image ( "data/SVULogo.png" ) ; newgame = new Image ( "data/newgame.png" ) ; continuegame = new Image ( "data/loadgame.png" ) ; options = new Image ( "data/options.png" ) ; quit = new Image ( "data/quitgame.png" ) ; newgameroll = new Image ( "data/newgameglow.png" ) ; continuegameroll = new Image ( "data/loadgameglow.png" ) ; optionsroll = new Image ( "data/optionsglow.png" ) ; quitroll = new Image ( "data/quitgameglow.png" ) ; int logowidth = logo . getWidth ( ) ; logox = ( gc . getWidth ( ) - logowidth ) / 2 ; newgamex = ( gc . getWidth ( ) - newgame . getWidth ( ) ) / 2 ; continuex = ( gc . getWidth ( ) - continuegame . getWidth ( ) ) / 2 ; optionsx = ( gc . getWidth ( ) - options . getWidth ( ) ) / 2 ; quitx = ( gc . getWidth ( ) - quit . getWidth ( ) ) / 2 ; areas [ 0 ] = new MouseOverArea ( gc , newgame , newgamex , 300 , this ) ; areas [ 0 ] . setMouseOverImage ( newgameroll ) ; areas [ 1 ] = new MouseOverArea ( gc , continuegame , continuex , 350 , this ) ; areas [ 1 ] . setMouseOverImage ( continuegameroll ) ; areas [ 2 ] = new MouseOverArea ( gc , options , optionsx , 400 , this ) ; areas [ 2 ] . setMouseOverImage ( optionsroll ) ; areas [ 3 ] = new MouseOverArea ( gc , quit , quitx , 450 , this ) ; areas [ 3 ] . setMouseOverImage ( quitroll ) ; }
tr	8	private void runSpikingProblem ( Evolution evo ) { outputScreen . setText ( "" ) ; int populationSize = Integer . parseInt ( populationSizeField . getText ( ) ) ; int generations = Integer . parseInt ( generationsField . getText ( ) ) ; SpikingNeuronProblem sn = ( SpikingNeuronProblem ) problem ; List < Individual > individuals = problem . createPopulation ( populationSize ) ; try { long startTime = System . nanoTime ( ) ; for ( int i = 0 ; i < generations ; i ++ ) { individuals = evo . runGeneration ( individuals ) ; Individual best = individuals . get ( 0 ) ; for ( Individual ind : individuals ) { if ( ind . age ( ) > 0 ) { if ( ind . fitness ( ) > best . fitness ( ) ) { best = ind ; } } } String formattedString = outputScreen . getText ( ) ; formattedString += "Generation " + ( i + 1 ) + ": " + best . toString ( ) + "\n" ; outputScreen . setText ( formattedString ) ; Plot2DPanel plot = new Plot2DPanel ( ) ; BaseLabel title = new BaseLabel ( "Generation: " + ( i + 1 ) + "  " + problemBox . getSelectedItem ( ) . toString ( ) + "  " + adultBox . getSelectedItem ( ) . toString ( ) + "  " + parentBox . getSelectedItem ( ) . toString ( ) + "  mutation: " + mutationRateField . getText ( ) + "%  crossover: " + crossoverRateField . getText ( ) + "%" , Color . BLACK , 0.5 , 1.1 ) ; plot . addPlotable ( title ) ; plot . addLinePlot ( "Target" , Color . RED , sn . target ) ; SpikingNeuronPhenotype snPheno = ( SpikingNeuronPhenotype ) best . phenotype ( ) ; plot . addLinePlot ( "Best individual" , Color . BLUE , snPheno . spiketrain ) ; plot . addLegend ( "SOUTH" ) ; graphpanel . add ( plot ) ; CardLayout card = ( CardLayout ) graphpanel . getLayout ( ) ; card . last ( graphpanel ) ; if ( i % 10 == 0 ) System . out . println ( ( double ) ( System . nanoTime ( ) - startTime ) / 1000000000.0 ) ; } evo . drawBestFitnessPlot ( ) ; String teXLabel = "Generations: " + generations + "\\\\" + "\n" + "Population: " + populationSize + "\\\\" + "\n" + "Adult Selection: " + adultBox . getSelectedItem ( ) . toString ( ) ; if ( adultBox . getSelectedItem ( ) . toString ( ) . equals ( "Overproduction" ) ) { teXLabel += "( \\%)\\\\\n" ; } else teXLabel += "\\\\\n" ; if ( adultBox . getSelectedItem ( ) . toString ( ) . equals ( "Generational Mixing" ) ) { teXLabel += "( Adult spots: )\n" ; } else teXLabel += "\n" ; teXLabel += "Selection Method: " + parentBox . getSelectedItem ( ) . toString ( ) + "\\\\" + "\n" + "Mutation :" + mutationRateField . getText ( ) + "\\%" + "\\\\" + "\n" + "Crossover: " + crossoverRateField . getText ( ) + "\\% \\\\" + "\n" ; System . out . println ( teXLabel ) ; } catch ( Exception e ) { System . out . println ( e . getMessage ( ) ) ; } }
tr	7	private void deleteTitleOrItem ( ) { if ( categoryJComboBox . getSelectedIndex ( ) == 0 && ( ! titleNameJTextField . getText ( ) . equals ( "" ) ) ) { int option = JOptionPane . showConfirmDialog ( this , "Are you sure you want to delete the entire Title?" , "Confirm Delete" , JOptionPane . YES_NO_OPTION ) ; if ( option == JOptionPane . YES_OPTION ) deleteTitle ( ) ; } else if ( categoryJComboBox . getSelectedIndex ( ) == 1 && ( ! titleNameJTextField . getText ( ) . equals ( "" ) ) && ( ! itemNoJTextField . getText ( ) . equals ( "" ) ) ) { int option = JOptionPane . showConfirmDialog ( this , "Are you sure you want to delete the specified Item?" , "Confirm Delete" , JOptionPane . YES_NO_OPTION ) ; if ( option == JOptionPane . YES_OPTION ) { deleteItem ( ) ; } } else JOptionPane . showMessageDialog ( null , "Please fill all the required fields" , "Something went wrong" , JOptionPane . WARNING_MESSAGE ) ; }
tr	6	private static UnitValue correctAlign ( CC cc , UnitValue rowAlign , boolean isHor , boolean fromEnd ) { UnitValue align = ( isHor ? cc . getHorizontal ( ) : cc . getVertical ( ) ) . getAlign ( ) ; if ( align == null ) align = rowAlign ; if ( align == UnitValue . BASELINE_IDENTITY ) align = UnitValue . CENTER ; if ( fromEnd ) { if ( align == UnitValue . LEFT ) align = UnitValue . RIGHT ; else if ( align == UnitValue . RIGHT ) align = UnitValue . LEFT ; } return align ; }
tr	1	public static Object getExceptionCause ( Throwable err ) { if ( err instanceof LuaException ) return ( ( LuaException ) err ) . getLuaCause ( ) ; return err . getMessage ( ) ; }
tr	2	public static void createTableCompulsoryCourses ( ) { try { SqlActions . initJDBC ( ) ; dbConn = SqlActions . getDBConn ( ) ; if ( dbConn == null ) throw new SQLException ( "table CompulsoryCourses not created" ) ; dbConn . setAutoCommit ( false ) ; dbStmnt = dbConn . createStatement ( ) ; dbStmnt . executeUpdate ( "use phdStudent;" ) ; dbStmnt . executeUpdate ( "create table if not exists CompulsoryCourses" + "(id int auto_increment primary key " + "studentId int not null references Student(id) on delete cascade on update cascade " + "curriculumId int  not null references StudentCurriculum(id) on update cascade " + "courseName varchar(255) not null " + "courseType varchar(255) not null " + "estimate date not null " + "studentType varchar(255) not null " + "protocolId int not null references CourseProtocols(id) on update cascade);" ) ; dbConn . commit ( ) ; } catch ( SQLException ex ) { SqlActions . handleEx ( ex ) ; } finally { SqlActions . closeConnections ( dbConn , dbStmnt , dbRs , dbRset ) ; } }
tr	2	@ Test public void testProcessGetShellRequest ( ) { Communicator comm = new Communicator ( 12002 ) ; ShellManagerDoer doer = new ShellManagerDoer ( comm ) ; GetShellRequest request = new GetShellRequest ( ) ; Envelope envelope = Envelope . createIncomingEnvelope ( request , null ) ; comm . addToInputQueue ( envelope ) ; doer . start ( ) ; try { Thread . sleep ( 500 ) ; } catch ( InterruptedException e ) { this . getLogger ( ) . error ( "ShellManagerDoerTest testProcessGetShellRequest:\n\t could not sleep" ) ; System . err . println ( "couldn't sleep" ) ; } assertEquals ( comm . getOutputQueue ( ) . size ( ) , 1 ) ; try { doer . stop ( ) ; } catch ( Exception e ) { System . err . println ( e . getMessage ( ) ) ; this . getLogger ( ) . error ( "CommunicatorTest tearDown:\n\t could not stop comm1\n\tMessage received: " + e . getMessage ( ) ) ; } }
tr	5	public static void exportPDF ( final File pdfLaTeX , final File workingDir , final String problem , final String solution , final MainFrame mainFrame ) { final java . util . Date date = new java . util . Date ( ) ; final java . sql . Timestamp ts = new java . sql . Timestamp ( date . getTime ( ) ) ; final String timestamp = ts . toString ( ) . replaceAll ( ":" , "-" ) ; final StringBuilder fileName = new StringBuilder ( ) ; fileName . append ( workingDir . getAbsolutePath ( ) ) . append ( File . separator ) ; fileName . append ( "priklad " ) . append ( timestamp ) . append ( ".tex" ) ; final File texFile = new File ( fileName . toString ( ) ) ; writeTeXFile ( texFile , problem , solution ) ; final String errorMsgHeader = "Chyba p\u0159i exportu do PDF" ; final String errorMsg = "P\u0159eklad PDFLaTeXem zlyhal." ; try { final JLRGenerator pdfGenerator = new JLRGenerator ( ) ; pdfGenerator . deleteTempFiles ( false , true , true ) ; if ( pdfLaTeX == null ) { if ( pdfGenerator . generate ( texFile , workingDir , workingDir ) ) JLROpener . open ( pdfGenerator . getPDF ( ) ) ; } else { if ( pdfGenerator . generate ( pdfLaTeX , 1 , texFile , workingDir , workingDir ) ) JLROpener . open ( pdfGenerator . getPDF ( ) ) ; } if ( ! pdfGenerator . getErrorMessage ( ) . equals ( "No errors occurred!" ) ) { UserInputChecker . error ( mainFrame , errorMsgHeader , errorMsg ) ; System . err . println ( pdfGenerator . getErrorMessage ( ) ) ; } } catch ( IOException ex ) { UserInputChecker . error ( mainFrame , errorMsgHeader , errorMsg ) ; System . err . println ( ex . getMessage ( ) ) ; } }
tr	9	public static void main ( String [ ] args ) throws SQLException { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( mainWindow . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( mainWindow . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( mainWindow . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( mainWindow . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { try { new mainWindow ( ) . setVisible ( true ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; } } } ) ; sqlConnection connnect = new sqlConnection ( ) ; selectQueries sql = new selectQueries ( ) ; insertQueries sqlInsert = new insertQueries ( ) ; Connection conn = connnect . connect ( ) ; rcmList rcms = new rcmList ( ) ; ArrayList < Recycler > rcm = new ArrayList < Recycler > ( ) ; for ( Recycler i : rcms . getRcmList ( ) ) { System . out . println ( "RCMS Detected" ) ; System . out . println ( i . getLocation ( ) + " : " + i . getId ( ) ) ; rcm . add ( new Recycler ( i . getLocation ( ) , i . getId ( ) ) ) ; } Object [ ] r = new Object [ rcm . size ( ) ] ; int j = 0 ; for ( Recycler i : rcm ) { r [ j ] = i ; j ++ ; } for ( int k = 0 ; k < rcm . size ( ) ; k ++ ) { int k1 = k ; ( ( Recycler ) r [ k1 ] ) . recycleItem ( new item ( "paper" , 1 , 5 , 20 ) , "CASH" ) ; ( ( Recycler ) r [ k1 ] ) . recycleItem ( new item ( "cloth" , 3 , 3 , 40 ) , "CASH" ) ; ( ( Recycler ) r [ k1 ] ) . recycleItem ( new item ( "glass" , 2 , 6 , 10 ) , "CASH" ) ; ( ( Recycler ) r [ k1 ] ) . recycleItem ( new item ( "paper" , 1 , 5 , 20 ) , "CASH" ) ; ( ( Recycler ) r [ k1 ] ) . recycleItem ( new item ( "cloth" , 3 , 3 , 40 ) , "CASH" ) ; ( ( Recycler ) r [ k1 ] ) . recycleItem ( new item ( "glass" , 2 , 6 , 10 ) , "CASH" ) ; } }
tr	2	public void fireModelPagesJaukesChanged ( int i_typeChange ) { I_ModelPagesJaukesListener [ ] listenerModelPagesJaukes = ( I_ModelPagesJaukesListener [ ] ) listeners . getListeners ( I_ModelPagesJaukesListener . class ) ; for ( I_ModelPagesJaukesListener listener : listenerModelPagesJaukes ) { switch ( i_typeChange ) { case 0 : listener . criteriaPagesJaukesChange ( ) ; break ; default : System . err . println ( "ModelPagesJaukes.java - Erreur fonction criteriaPagesJaukesChange" ) ; break ; } } }
tr	3	public int compareTo ( Individual other ) { double mine = this . fitness ( ) ; double its = other . fitness ( ) ; if ( mine == its ) return 0 ; return ( fitness . maximization ( ) ? 1 : - 1 ) * ( mine > its ? 1 : - 1 ) ; }
tr	5	public Posicao encontrarRei ( TipoCorJogador cor ) { for ( int coluna = COLUNAINFERIOR ; coluna <= COLUNASUPERIOR ; coluna ++ ) { for ( int linha = LINHAINFERIOR ; linha <= LINHASUPERIOR ; linha ++ ) { Posicao posicao = new Posicao ( coluna , linha ) ; if ( estaVazio ( posicao ) ) continue ; Peca peca = espiarPeca ( posicao ) ; if ( peca . getTipoPeca ( ) == TipoPeca . REI && peca . getCorJogador ( ) == cor ) { return posicao ; } } } return null ; }
tr	6	private void getArguments ( IGraph g ) throws Exception { Object o ; nargs = 0 ; for ( int i = 0 ; i < g . size ( ) ; i ++ ) { o = Evaluate . toScalar ( g . get ( i ) ) ; if ( o instanceof double ) argClass [ i ] = double . class ; else if ( o instanceof long ) argClass [ i ] = long . class ; else if ( o instanceof boolean ) argClass [ i ] = boolean . class ; else if ( o instanceof IGraph ) argClass [ i ] = ogdl . IGraph . class ; else argClass [ i ] = o . getClass ( ) ; argObject [ i ] = o ; nargs ++ ; } aC = new class [ nargs ] ; aO = new Object [ nargs ] ; for ( int i = 0 ; i < nargs ; i ++ ) { aC [ i ] = argClass [ i ] ; aO [ i ] = argObject [ i ] ; } }
tr	0	public void updateMenu ( ) { setPanel ( _menuSelect . selectMenu ( ) ) ; }
tr	2	public final T get ( ) throws DiffbotException { if ( executed ) { return getResult ( ) ; } else { synchronized ( client ) { if ( ! executed ) { request . runBatch ( this ) ; return getResult ( ) ; } else { return getResult ( ) ; } } } }
tr	9	private void readOP ( SelectionKey key ) { try { SocketChannel socketChannel = ( SocketChannel ) key . channel ( ) ; for ( ByteBuffer byteBuffer : buffer ) { if ( byteBuffer != null ) byteBuffer . clear ( ) ; } long numRead ; numRead = readBuffer ( key , 0 ) ; if ( ! socketChannel . isOpen ( ) ) return ; if ( numRead > 0 ) { ProtocolHeader protocolHeader = null ; try { byteReceived . inc ( numRead ) ; buffer [ 0 ] . flip ( ) ; protocolHeader = ProtocolUtils . checkHeaderIntegrity ( buffer [ 0 ] ) ; } catch ( Exception e ) { log . severe ( "Check header integrity failed ! cause: " + e . getMessage ( ) ) ; } switch ( protocolHeader . getCommandType ( ) ) { case Protocol . HEADER_COMMAND_PUBLISH : case Protocol . HEADER_COMMAND_SUBSCRIBE : { if ( handleMessage ( key , socketChannel , protocolHeader ) ) return ; break ; } } } } catch ( Exception ex ) { log . severe ( "Error read operation  cause: " + ex . getMessage ( ) ) ; ex . printStackTrace ( ) ; } }
tr	3	public void addDiploma ( Diploma diploma ) { boolean notFound = true ; for ( Diploma item : diplomas ) { if ( diploma . getName ( ) . equalsIgnoreCase ( item . getName ( ) ) ) { notFound = false ; break ; } } if ( notFound ) { diplomas . add ( diploma ) ; } }
tr	0	public BlankPOIToken ( POIQuestionMarkToken reverse ) { super ( reverse ) ; }
tr	7	@ Test public void deletingOneOfManyWorks ( ) { String [ ] [ ] inputData = new String [ 10 ] [ cardData . length ] ; for ( int i = 0 ; i < 10 ; i ++ ) { inputData [ i ] [ 0 ] = "input" + i ; for ( int j = 1 ; j < cardData . length ; j ++ ) { inputData [ i ] [ j ] = cardData [ j ] ; } } for ( int i = 0 ; i < 10 ; i ++ ) { try { register . createCard ( inputData [ i ] ) ; } catch ( Exception ex ) { fail ( ) ; } } String [ ] [ ] del = new String [ 2 ] [ cardData . length ] ; del [ 0 ] = inputData [ 2 ] ; del [ 1 ] = inputData [ 5 ] ; register . deleteCards ( del ) ; assertEquals ( 8 , register . getCardData ( ) . length ) ; boolean containsFirst = false ; boolean containsSecond = false ; String [ ] [ ] retrievedData = register . getCardData ( ) ; for ( int i = 0 ; i < 8 ; i ++ ) { if ( retrievedData [ i ] [ 0 ] . equals ( del [ 0 ] [ 0 ] ) ) { containsFirst = true ; } if ( retrievedData [ i ] [ 0 ] . equals ( del [ 1 ] [ 0 ] ) ) { containsSecond = true ; } } assertFalse ( containsFirst ) ; assertFalse ( containsSecond ) ; }
tr	7	public DraftGenerator ( ) { setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; setBounds ( 100 , 100 , 450 , 399 ) ; contentPane = new JPanel ( ) ; contentPane . setBorder ( new EmptyBorder ( 5 , 5 , 5 , 5 ) ) ; setContentPane ( contentPane ) ; contentPane . setLayout ( null ) ; JLabel lblChooseTheDraft = new JLabel ( "Choose the draft file" ) ; lblChooseTheDraft . setBounds ( 38 , 26 , 175 , 16 ) ; contentPane . add ( lblChooseTheDraft ) ; addressText = new JTextField ( ) ; addressText . setBounds ( 38 , 62 , 218 , 28 ) ; contentPane . add ( addressText ) ; addressText . setColumns ( 10 ) ; JButton btnChoose = new JButton ( "Choose" ) ; btnChoose . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { JFileChooser chooser = new JFileChooser ( ) ; FileNameExtensionFilter filter1 = new FileNameExtensionFilter ( "Text file" , "txt" ) ; chooser . addChoosableFileFilter ( filter1 ) ; chooser . setFileFilter ( filter1 ) ; int returnVal = chooser . showOpenDialog ( getParent ( ) ) ; if ( returnVal == JFileChooser . APPROVE_OPTION ) { addressText . setText ( chooser . getSelectedFile ( ) . getPath ( ) ) ; } } } ) ; btnChoose . setBounds ( 291 , 63 , 117 , 29 ) ; contentPane . add ( btnChoose ) ; JButton btnGenerate = new JButton ( "Generate" ) ; btnGenerate . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { String file = addressText . getText ( ) ; int x = 0 , y = 0 ; int length = 3000 ; int x_distance = 200 ; int y_distance = 150 ; String position = "{" + x + " " + y + "}" ; BufferedReader input ; try { input = new BufferedReader ( new FileReader ( file ) ) ; } catch ( FileNotFoundException e1 ) { JOptionPane . showMessageDialog ( getParent ( ) , "File is not found!" ) ; return ; } String line = "" ; String tag = "" ; String shape = "" ; String canvas = canvasText . getText ( ) ; String layer = layerText . getText ( ) ; try { while ( ( line = input . readLine ( ) ) != null ) { if ( line . startsWith ( "%" ) ) { tag = line . substring ( 1 ) ; continue ; } else if ( line . equals ( "" ) ) { continue ; } else { shape = InfoEnum . reverse_req_elem_type_map . get ( tag ) ; AppleScript . drawArbitraryRequirementElement ( canvas , layer , shape , InfoEnum . NORMAL_SIZE , position , "0" , line , "0" , "1" ) ; if ( x < length ) { x += x_distance ; } else { x = 0 ; y += y_distance ; } position = "{" + x + " " + y + "}" ; } } } catch ( IOException e1 ) { e1 . printStackTrace ( ) ; } JOptionPane . showMessageDialog ( getParent ( ) , "Successfully generate graphs!" ) ; } } ) ; btnGenerate . setBounds ( 291 , 130 , 117 , 29 ) ; contentPane . add ( btnGenerate ) ; JLabel lblCanvas = new JLabel ( "Canvas" ) ; lblCanvas . setBounds ( 24 , 135 , 61 , 16 ) ; contentPane . add ( lblCanvas ) ; canvasText = new JTextField ( ) ; canvasText . setText ( "Test" ) ; canvasText . setBounds ( 79 , 130 , 77 , 28 ) ; contentPane . add ( canvasText ) ; canvasText . setColumns ( 10 ) ; JLabel lblLayer = new JLabel ( "Layer" ) ; lblLayer . setBounds ( 24 , 189 , 61 , 16 ) ; contentPane . add ( lblLayer ) ; layerText = new JTextField ( ) ; layerText . setText ( "none" ) ; layerText . setBounds ( 79 , 183 , 134 , 28 ) ; contentPane . add ( layerText ) ; layerText . setColumns ( 10 ) ; JLabel lblTargetAttackPattern = new JLabel ( "Target Attack Pattern" ) ; lblTargetAttackPattern . setBounds ( 38 , 294 , 156 , 16 ) ; contentPane . add ( lblTargetAttackPattern ) ; txtPatternid = new JTextField ( ) ; txtPatternid . setBounds ( 38 , 322 , 134 , 28 ) ; contentPane . add ( txtPatternid ) ; txtPatternid . setColumns ( 10 ) ; JButton btnGenerateTree = new JButton ( "Generate tree" ) ; btnGenerateTree . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { CAPECModelGeneration model = new CAPECModelGeneration ( ) ; model . generatePatternHierarchyModel ( txtPatternid . getText ( ) ) ; JOptionPane . showMessageDialog ( getParent ( ) , "Successfully generate graphs!" ) ; } } ) ; btnGenerateTree . setBounds ( 218 , 323 , 117 , 29 ) ; contentPane . add ( btnGenerateTree ) ; }
tr	8	private void addPanelInit ( ) { addPanel = new JPanel ( ) ; generator . createRigidSpace ( addPanel , 40 ) ; final JLabel testLabel = generator . createLabel ( addPanel , "" ) ; JLabel fNameLabel = generator . createLabel ( addPanel , "First Name" ) ; final JTextField fNameInput = generator . createTextField ( addPanel , "" ) ; JLabel lNameLabel = generator . createLabel ( addPanel , "Last Name" ) ; final JTextField lNameInput = generator . createTextField ( addPanel , "" ) ; JLabel companyLabel = generator . createLabel ( addPanel , "Company" ) ; final JTextField companyInput = generator . createTextField ( addPanel , "" ) ; JLabel emailLabel = generator . createLabel ( addPanel , "Email" ) ; final JTextField emailInput = generator . createTextField ( addPanel , "" ) ; JLabel phoneLabel = generator . createLabel ( addPanel , "Phone (xxx-xxx-xxxx)" ) ; final JTextField phoneInput = generator . createTextField ( addPanel , "" ) ; JLabel addressLabel = generator . createLabel ( addPanel , "Address" ) ; final JTextField addressInput = generator . createTextField ( addPanel , "" ) ; generator . createRigidSpace ( addPanel , 10 ) ; final JLabel resultLabel = generator . createLabel ( addPanel , " " , "" ) ; JButton doneButton = generator . createButton ( addPanel , "Add client" , 15 ) ; JButton backButton = generator . createButton ( addPanel , "Back" , mainViewName , 5 ) ; addPanel . setLayout ( new BoxLayout ( addPanel , BoxLayout . Y_AXIS ) ) ; doneButton . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { resultLabel . setText ( " " ) ; boolean result = false ; ClientClass newClient ; if ( fNameInput . getText ( ) . matches ( "" ) || lNameInput . getText ( ) . matches ( "" ) || emailInput . getText ( ) . matches ( "" ) || companyInput . getText ( ) . matches ( "" ) || phoneInput . getText ( ) . matches ( "" ) || addressInput . getText ( ) . matches ( "" ) ) { resultLabel . setText ( "Please fill out the empty fields" ) ; return ; } newClient = new ClientClass ( fNameInput . getText ( ) , lNameInput . getText ( ) , emailInput . getText ( ) , companyInput . getText ( ) , phoneInput . getText ( ) , addressInput . getText ( ) ) ; result = newClient . verifyInput ( ) ; if ( result == true ) { result = ClientControllerClass . getInstance ( ) . addClient ( newClient , UIControllerClass . currentUser ) ; Object [ ] data = new Object [ 8 ] ; data [ 0 ] = newClient . getClientId ( ) ; data [ 1 ] = newClient . getFirstName ( ) ; data [ 2 ] = newClient . getLastName ( ) ; data [ 3 ] = newClient . getCompany ( ) ; data [ 4 ] = newClient . getEmail ( ) ; data [ 5 ] = newClient . getPhone ( ) ; data [ 6 ] = newClient . getAddress ( ) ; if ( result == true ) { resultLabel . setText ( "Successfully added the client!" ) ; allClientsModel . addRow ( data ) ; fNameInput . setText ( "" ) ; lNameInput . setText ( "" ) ; emailInput . setText ( "" ) ; companyInput . setText ( "" ) ; phoneInput . setText ( "" ) ; addressInput . setText ( "" ) ; } else { resultLabel . setText ( "Error adding client to the database  Please try again..." ) ; } } else { resultLabel . setText ( "Invalid Input  Please try again..." ) ; } } } ) ; }
tr	1	private ArgListCodeFragment convertParamList ( ArgListCodeFragment paramList , Function f , CodePosition p ) { ArgListCodeFragment code = new ArgListCodeFragment ( ) ; code . appendCodeFragment ( paramList ) ; for ( int i = 0 ; i < paramList . getArgs ( ) . size ( ) ; i ++ ) { Variable v = paramList . getArgs ( ) . get ( i ) ; Type t = f . getParams ( ) . get ( i ) . getType ( ) ; code . appendCodeFragment ( variableTypeConvert ( v , t , p ) ) ; code . addArg ( new Variable ( code . getInfo ( ) , code . getRegister ( ) , code . getType ( ) ) ) ; } return code ; }
tr	8	public boolean placeTile ( int xC , int yC , Tile tile , JavaPlayer player , LinkedList < Developer > gameDevelopers ) { JavaCell [ ] [ ] miniMap = createTestMap ( xC , yC ) ; TileType [ ] [ ] tileCells = tile . getTileCells ( ) ; if ( checkValidTilePlacement ( xC , yC , tile , player , miniMap , gameDevelopers ) ) { int number ; if ( tile . getType ( ) == "two" ) { number = 2 ; } else if ( tile . getType ( ) == "three" ) { number = 3 ; } else if ( tile . getType ( ) == "one" ) { number = 1 ; } else { number = 0 ; } cellId ++ ; for ( int i = 0 ; i < tileCells . length ; i ++ ) for ( int j = 0 ; j < tileCells [ i ] . length ; j ++ ) if ( tileCells [ i ] [ j ] != null ) { map [ miniMap [ i ] [ j ] . getX ( ) ] [ miniMap [ i ] [ j ] . getY ( ) ] . setNumOriginalSpaces ( tile . numOfSpaces ( ) ) ; map [ miniMap [ i ] [ j ] . getX ( ) ] [ miniMap [ i ] [ j ] . getY ( ) ] . setCellType ( tileCells [ i ] [ j ] ) ; map [ miniMap [ i ] [ j ] . getX ( ) ] [ miniMap [ i ] [ j ] . getY ( ) ] . setCellId ( cellId ) ; map [ miniMap [ i ] [ j ] . getX ( ) ] [ miniMap [ i ] [ j ] . getY ( ) ] . setElevation ( map [ miniMap [ i ] [ j ] . getX ( ) ] [ miniMap [ i ] [ j ] . getY ( ) ] . getElevation ( ) + 1 ) ; map [ miniMap [ i ] [ j ] . getX ( ) ] [ miniMap [ i ] [ j ] . getY ( ) ] . setNumOriginalSpaces ( number ) ; irrigationMap [ miniMap [ i ] [ j ] . getX ( ) ] [ miniMap [ i ] [ j ] . getY ( ) ] . setNumOriginalSpaces ( tile . numOfSpaces ( ) ) ; irrigationMap [ miniMap [ i ] [ j ] . getX ( ) ] [ miniMap [ i ] [ j ] . getY ( ) ] . setCellType ( tileCells [ i ] [ j ] ) ; irrigationMap [ miniMap [ i ] [ j ] . getX ( ) ] [ miniMap [ i ] [ j ] . getY ( ) ] . setCellId ( cellId ) ; irrigationMap [ miniMap [ i ] [ j ] . getX ( ) ] [ miniMap [ i ] [ j ] . getY ( ) ] . setElevation ( map [ miniMap [ i ] [ j ] . getX ( ) ] [ miniMap [ i ] [ j ] . getY ( ) ] . getElevation ( ) + 1 ) ; irrigationMap [ miniMap [ i ] [ j ] . getX ( ) ] [ miniMap [ i ] [ j ] . getY ( ) ] . setNumOriginalSpaces ( number ) ; } checkForSurroundedIrrigationCells ( xC , yC , tile , gameDevelopers ) ; if ( placedLandTile ( xC , yC ) ) player . placedLandTile ( ) ; bodiesOfWater . clear ( ) ; return true ; } return false ; }
tr	2	public double totalCount ( ) { if ( currentModCount != cacheModCount ) { double total = 0.0 ; for ( Map . Entry < K , Counter < V >> entry : counterMap . entrySet ( ) ) { Counter < V > counter = entry . getValue ( ) ; total += counter . totalCount ( ) ; } cacheTotalCount = total ; cacheModCount = currentModCount ; } return cacheTotalCount ; }
tr	5	public int call ( CallFrame frame , int argCount ) { LuaTable table = frame . getArg ( 0 , LuaTable . class ) ; String sep = frame . getArgNull ( 1 , String . class ) ; int start = frame . getIntArg ( 2 , 1 ) ; int limit = frame . getIntArg ( 3 , table . size ( ) ) ; if ( limit == 0 || limit < start ) { frame . push ( "" ) ; return 1 ; } StringBuilder result = new StringBuilder ( ) ; for ( int index = start ; index <= limit ; index ++ ) { result . append ( LuaUtil . rawToString ( table . rawget ( index ) ) ) ; if ( sep != null && index != limit ) result . append ( sep ) ; } frame . push ( result . toString ( ) ) ; return 1 ; }
tr	4	public boolean holdsMaekawaTheorem ( ) { int mountainCount = 0 ; int valleyCount = 0 ; for ( LineType type : lines ) { if ( isEmpty ( type ) ) { continue ; } switch ( type ) { case MOUNTAIN : mountainCount ++ ; break ; case VALLEY : valleyCount ++ ; default : break ; } } return Math . abs ( mountainCount - valleyCount ) == 2 ; }
tr	1	public void awaitTermination ( ) { try { latch . await ( ) ; } catch ( InterruptedException e ) { String message = "awaitTermination() method was interrupted!" ; throw new UnsupportedOperationException ( message , e ) ; } }
tr	2	private Set < String > getExcludes ( ) { Set < String > result = new HashSet < String > ( ) ; for ( String exclude : kp . getExcludes ( ) ) { String name = exclude + ".class" ; String renamed = renames . get ( name ) ; result . add ( ( renamed != null ) ? renamed : name ) ; } return result ; }
tr	8	public boolean equals ( Date that ) { if ( that == null ) return false ; boolean this_present_cratedAt = true && this . isSetCratedAt ( ) ; boolean that_present_cratedAt = true && that . isSetCratedAt ( ) ; if ( this_present_cratedAt || that_present_cratedAt ) { if ( ! ( this_present_cratedAt && that_present_cratedAt ) ) return false ; if ( ! this . cratedAt . equals ( that . cratedAt ) ) return false ; } return true ; }
tr	9	Vector < Integer > crossCheck ( Vector < Integer > possibilities , Vector < Integer > confirmations ) { Vector < Integer > result = new Vector < > ( 6 ) ; if ( possibilities . size ( ) == 0 ) { for ( int cellId : confirmations ) { if ( cellId >= 0 ) { result . add ( cellId ) ; } } } else if ( confirmations . size ( ) == 0 ) { for ( int cellId : possibilities ) { if ( cellId >= 0 ) { result . add ( cellId ) ; } } } else { for ( int cellId : confirmations ) { if ( ( possibilities . contains ( cellId ) ) && ( cellId >= 0 ) ) { result . add ( cellId ) ; } } } result . trimToSize ( ) ; return result ; }
tr	9	public static void main ( String [ ] args ) { EraSieve sieve = new EraSieve ( ) ; long lastPrime = 1 ; long last2Sqr = 0 ; long last2Base = 0 ; ArrayList < long > squareBy2 = new ArrayList < long > ( ) ; for ( int i = 1 ; true ; i += 2 ) { while ( lastPrime < i ) lastPrime = sieve . nextPrime ( ) ; if ( i == lastPrime ) { System . out . println ( i + ":was prime" ) ; continue ; } while ( last2Sqr < i ) { last2Base ++ ; last2Sqr = 2 * last2Base * last2Base ; squareBy2 . add ( last2Sqr ) ; } System . out . println ( i + ":not prime" ) ; long x ; boolean found = false ; for ( long prime : sieve . primes ) { for ( long square2 : squareBy2 ) { if ( ( prime + square2 ) == i ) { found = true ; System . out . println ( "..." + prime + "  " + square2 ) ; break ; } if ( ( prime + square2 ) > i ) { break ; } } if ( found ) { break ; } } if ( ! found ) { System . out . println ( "...not found" ) ; return ; } } }
tr	7	public static Method findServiceMethod ( final class objectClass , final String methodName , final Object [ ] params ) throws NoSuchMethodException { Method serviceMethod = null ; if ( params == null || params . length == 0 ) serviceMethod = objectClass . getMethod ( methodName , ( class [ ] ) null ) ; else { for ( Method method : objectClass . getMethods ( ) ) { if ( ! methodName . equals ( method . getName ( ) ) ) continue ; Type [ ] paramTypes = method . getGenericParameterTypes ( ) ; if ( paramTypes . length != params . length ) continue ; if ( canConvertForMethodInvocation ( params , paramTypes ) ) { serviceMethod = method ; break ; } } } if ( serviceMethod == null ) throw new NoSuchMethodException ( objectClass . getName ( ) + . + methodName + StringUtil . toString ( params ) ) ; return serviceMethod ; }
tr	9	public static void fillFieldAccess ( class clazz ) { if ( _classFieldAccessFactory == null ) { _classFieldAccessFactory = new HashMap < String , FieldAccess > ( ) ; } if ( ! _classFieldAccessFactory . containsKey ( clazz . getName ( ) ) ) { FieldAccess access = FieldAccess . get ( clazz ) ; _classFieldAccessFactory . put ( clazz . getName ( ) , access ) ; } else { return ; } Field [ ] fields = clazz . getDeclaredFields ( ) ; for ( Field field : fields ) { class fieldType = field . getType ( ) ; if ( fieldType != double . class && fieldType != double . class && fieldType != float . class && fieldType != float . class && fieldType != String . class && fieldType != short . class && fieldType != short . class && fieldType != int . class && fieldType != Integer . class && fieldType != long . class && fieldType != long . class ) { fillFieldAccess ( fieldType ) ; } } }
tr	2	@ Override public void nextFrame ( ) { if ( images . size ( ) <= 1 || ! playing ) { return ; } frame ++ ; frame %= images . size ( ) ; }
tr	3	@ SuppressWarnings ( "unchecked" ) private void initprocedureArray ( ) { procedureArray = ( Action < TerminalEnum , ProductionEnum , VersionEnum > [ ] ) new Action < ? , ? , ? > [ ] { reduceitem_star_0_empty , branch0 , branch0 , shift4 , branch0 , branch0 , branch0 , branch0 , branch0 , branch0 , branch0 , branch0 , branch0 , branch0 , branch0 , reduceblock , reduceinstr_end , reduceinstr_break , branch0 , branch0 , branch0 , branch0 , branch0 , branch0 , branch0 , branch0 , branch0 , branch0 , branch0 , branch0 , branch0 , branch0 , branch0 , branch0 , branch0 , branch0 , reducefuncall , branch0 , branch0 , branch0 , branch0 , branch0 , reduceinstr_if , branch0 , reduceinstr_if_else , branch0 , branch0 , branch0 , branch0 , branch0 , reduceinstr_repeat , branch0 , branch0 , branch0 , branch0 , reduceinstr_repeat_while , branch0 , reduceinstr_funcall , branch0 , reduceproc , reduceitem_proc , reduceitem_instr , reduceitem_star_0_rec } ; }
tr	3	public void setSearchScope ( SearchScope scope ) { switch ( scope ) { case OBJECT : this . searchScope = SearchControls . OBJECT_SCOPE ; break ; case ONE_LEVEL : this . searchScope = SearchControls . ONELEVEL_SCOPE ; break ; case SUBTREE : this . searchScope = SearchControls . SUBTREE_SCOPE ; break ; } }
tr	3	public int getInt ( String key ) throws JSONException { Object o = get ( key ) ; if ( o == null || o == null ) return 0 ; return o instanceof Number ? ( ( Number ) o ) . intValue ( ) : ( int ) getDouble ( key ) ; }
tr	8	private Line generateLine ( Scanner inFile ) { Point s = null , e = null ; int thickness = 0 ; Color c = null ; String current = inFile . next ( ) ; while ( inFile . hasNext ( ) && ! ( isCloseTag ( current ) && parseTag ( current ) == LegalTag . Line ) ) { if ( isOpenTag ( current ) ) { switch ( parseTag ( current ) ) { case Start : s = new Point ( inFile . nextInt ( ) , inFile . nextInt ( ) ) ; break ; case End : e = new Point ( inFile . nextInt ( ) , inFile . nextInt ( ) ) ; break ; case Color : c = new Color ( inFile . nextInt ( ) , inFile . nextInt ( ) , inFile . nextInt ( ) ) ; break ; case Thickness : thickness = inFile . nextInt ( ) ; break ; default : break ; } } current = inFile . next ( ) ; } Line l = new Line ( s , e , thickness , c ) ; return l ; }
tr	3	@ Override public boolean overlaps ( R other ) { return other != null && ( other . contains ( start ) || other . contains ( end ) || this . contains ( other ) ) ; }
tr	1	private List < Account > findAccountEntities ( boolean all , int maxResults , int firstResult ) { EntityManager em = getEntityManager ( ) ; try { CriteriaQuery cq = em . getCriteriaBuilder ( ) . createQuery ( ) ; cq . select ( cq . from ( Account . class ) ) ; Query q = em . createQuery ( cq ) ; if ( ! all ) { q . setMaxResults ( maxResults ) ; q . setFirstResult ( firstResult ) ; } return q . getResultList ( ) ; } finally { em . close ( ) ; } }
tr	8	private Method method ( String name , class < ? > ... argTypes ) { try { if ( null == argTypes || argTypes . length == 0 ) { return clazz . getMethod ( name ) ; } for ( Method method : clazz . getMethods ( ) ) { if ( ! method . getName ( ) . equals ( name ) ) { continue ; } class < ? > [ ] paramsTypes = method . getParameterTypes ( ) ; if ( isMatchArgTypes ( argTypes , paramsTypes ) ) { return method ; } } throw new NoSuchMethodException ( ) ; } catch ( Exception e ) { throw Lang . uncheck ( e ) ; } }
tr	5	public < H , S > void dispatch ( Event < H , S > event , S source ) { event . setSource ( source ) ; try { for ( H handler : this . < H > getQueueForType ( registeredHandlers , event . getType ( ) ) ) { try { event . dispatch ( handler ) ; } catch ( Throwable t ) { LoggerFactory . getLogger ( handler . getClass ( ) ) . error ( "Unhandled exception while dispatching event" , t ) ; } } for ( Reference < Waiter < Event < H , S >>> ref : this . < Reference < Waiter < Event < H , S >>> > getQueueForType ( registeredWaiters , event . getType ( ) ) ) { Waiter < Event < H , S >> waiter = ref . get ( ) ; if ( waiter != null ) { waiter . offer ( event ) ; } } if ( ! ( event instanceof EventEvent ) ) { dispatch ( new EventEvent ( ) , event ) ; } } finally { event . setSource ( null ) ; } }
tr	8	@ Override public void init ( ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( AppletMCQForm . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( AppletMCQForm . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( AppletMCQForm . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( AppletMCQForm . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } try { java . awt . EventQueue . invokeAndWait ( new Runnable ( ) { public void run ( ) { initComponents ( ) ; optionHidden . setVisible ( false ) ; question . setEnabled ( false ) ; labelUser . setText ( "Hello" ) ; MakeGroup ( ) ; count = 0 ; last = 4 ; quesNo . setText ( "Q " + count + 1 + "." ) ; DataConnection mcq = new DataConnection ( ) ; myConnection = mcq . GetConnection ( ) ; try { selectStmt = myConnection . createStatement ( ) ; ExecuteQuery ( "ABCD" ) ; } catch ( Exception e ) { } } } ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; } }
tr	9	public static PokerHandComparer resolveTieHand ( ArrayList < PokerCard > cards , ArrayList < PokerCard > newCards , int rank ) { Map < Integer , String > pokerHelper = PokerHelper . getPokerRank ( ) ; String rankDescription = pokerHelper . get ( rank ) ; if ( rankDescription == PokerRankingCatalog . CARTA_ALTA ) { return highCard ( cards , newCards ) ; } if ( rankDescription == PokerRankingCatalog . PAREJA ) { return pair ( cards , newCards ) ; } if ( rankDescription == PokerRankingCatalog . DOBLE_PAREJA ) { return doublePair ( cards , newCards ) ; } if ( rankDescription == PokerRankingCatalog . TRIO ) { return threeOfAKind ( cards , newCards ) ; } if ( rankDescription == PokerRankingCatalog . ESCALERA ) { return straight ( cards , newCards ) ; } if ( rankDescription == PokerRankingCatalog . COLOR ) { return color ( cards , newCards ) ; } if ( rankDescription == PokerRankingCatalog . FULL_HOUSE ) { return threeOfAKind ( cards , newCards ) ; } if ( rankDescription == PokerRankingCatalog . POKER ) { return poker ( cards , newCards ) ; } if ( rankDescription == PokerRankingCatalog . ESCALERA_DE_COLOR ) { return straight ( cards , newCards ) ; } if ( rankDescription == PokerRankingCatalog . ESCALERA_REAL ) { return straight ( cards , newCards ) ; } return null ; }
tr	0	public BIOSwitch ( String onString , String offString ) { super ( onString ) ; create ( ) ; setOffString ( offString ) ; }
