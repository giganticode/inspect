tr	8	private boolean interpolateCollection ( Object obj , String basePath , Field field ) throws IllegalAccessException , InterpolationException { Collection c = ( Collection ) field . get ( obj ) ; if ( c != null && ! c . isEmpty ( ) ) { List originalValues = new ArrayList ( c ) ; try { c . clear ( ) ; } catch ( UnsupportedOperationException e ) { warningCollector . add ( new ObjectInterpolationWarning ( "Field is an unmodifiable collection. Skipping interpolation." , basePath + "." + field . getName ( ) , e ) ) ; return true ; } for ( Object value : originalValues ) { if ( value != null ) { if ( String . class == value . getClass ( ) ) { String interpolated = interpolator . interpolate ( ( String ) value , recursionInterceptor ) ; if ( ! interpolated . equals ( value ) ) { c . add ( interpolated ) ; } else { c . add ( value ) ; } } else { c . add ( value ) ; if ( value . getClass ( ) . isArray ( ) ) { evaluateArray ( value , basePath + "." + field . getName ( ) ) ; } else { interpolationTargets . add ( new InterpolationTarget ( value , basePath + "." + field . getName ( ) ) ) ; } } } else { c . add ( value ) ; } } } return false ; }
tr	5	private static String extractFollowingParaContaining ( String document , String containing , int begin ) { Matcher paragraph = Pattern . compile ( "<p[\\s\\S]*?</p>" ) . matcher ( document ) ; int start = begin ; int first = 0 ; int last = start ; while ( paragraph . find ( start ) ) { start = paragraph . end ( ) ; if ( paragraph . group ( ) . matches ( "<p[^>]*>[\\s\u00A0]*</p>" ) ) { continue ; } if ( ! paragraph . group ( ) . matches ( containing ) ) { break ; } if ( first == 0 ) { first = paragraph . start ( ) ; } last = paragraph . end ( ) ; } return first != 0 ? document . substring ( first , last ) : null ; }
tr	4	public static String readFile ( String filePath ) throws FileNotExistException { File file = new File ( filePath ) ; StringBuilder builder = new StringBuilder ( ) ; if ( ! file . exists ( ) ) { throw new FileNotExistException ( filePath ) ; } try { BufferedReader buffer = new BufferedReader ( new FileReader ( file ) ) ; String tmp = buffer . readLine ( ) ; while ( tmp != null ) { builder . append ( tmp ) ; tmp = buffer . readLine ( ) ; if ( tmp != null ) builder . append (  ) ; } } catch ( IOException e ) { e . printStackTrace ( ) ; } return builder . toString ( ) ; }
tr	8	private SemanticFrame sequentialSampling ( SemanticFrame goldFrame , int [ ] goldlbids , SRLFeatureData sfd , int p , TIntArrayList args ) { SemanticFrame predict = new SemanticFrame ( goldFrame ) ; predict . arglbids = new int [ goldlbids . length ] ; for ( int i = 0 , L = predict . arglbids . length ; i < L ; ++ i ) predict . arglbids [ i ] = - 1 ; int N = args . size ( ) , M = sfd . L ; int T = N + M ; boolean [ ] usedRel = new boolean [ T ] ; double [ ] score = new double [ T ] ; for ( int a = 0 ; a < N ; ++ a ) { for ( int r = 0 ; r < T ; ++ r ) { if ( usedRel [ r ] ) { score [ r ] = - double . MAX_VALUE ; } else { score [ r ] = r < M ? sfd . getArcScore ( goldFrame . predid , args . get ( a ) , r ) : nullWeight ; if ( addLoss ) score [ r ] += loss ( goldlbids [ args . get ( a ) ] , r < M ? r : - 1 ) ; } } int sample = samplePoint ( score , usedRel ) ; usedRel [ sample ] = true ; predict . arglbids [ args . get ( a ) ] = sample < M ? sample : - 1 ; } return predict ; }
tr	6	@ Override public void doTurn ( ) { getLocation ( ) . world . clearTileVisibility ( ) ; for ( int y = getLocation ( ) . y + getViewDistance ( ) ; y >= getLocation ( ) . y - getViewDistance ( ) ; y -- ) { int deltaX = getViewDistance ( ) - Math . abs ( y - getLocation ( ) . y ) ; for ( int x = getLocation ( ) . x + deltaX ; x >= getLocation ( ) . x - deltaX ; x -- ) { if ( AIController . checkVisibility ( getLocation ( ) , new WorldLocation ( null , x , y ) ) ) { getLocation ( ) . world . setTileVisible ( x , y , true ) ; } if ( new WorldLocation ( getLocation ( ) . world , x , y ) . getTile ( ) instanceof TileSecretDoor ) { int chance = 30 - getStats ( ) . getIntelligence ( ) ; if ( chance <= 0 || new Random ( ) . nextInt ( chance ) == 0 ) { logMessage ( "Something about one of the walls nearby seems off to you" ) ; } } } } }
tr	4	private void evaluateArray ( Object target , String basePath ) throws InterpolationException { int len = Array . getLength ( target ) ; for ( int i = 0 ; i < len ; i ++ ) { Object value = Array . get ( target , i ) ; if ( value != null ) { if ( String . class == value . getClass ( ) ) { String interpolated = interpolator . interpolate ( ( String ) value , recursionInterceptor ) ; if ( ! interpolated . equals ( value ) ) { Array . set ( target , i , interpolated ) ; } } else { interpolationTargets . add ( new InterpolationTarget ( value , basePath + "[" + i + "]" ) ) ; } } } }
tr	4	@ Override public void write ( byte [ ] data , int offset , int length ) throws IOException { if ( data == null ) throw new IllegalArgumentException ( "data cannot be null" ) ; if ( offset < 0 || length < 0 || ( offset + length ) > data . length ) throw new IllegalArgumentException ( "offset [" + offset + "] and length [" + length + "] must be >= 0 and (offset + length)[" + ( offset + length ) + "] must be <= data.length [" + data . length + "]" ) ; ensureCapacity ( i + length ) ; System . arraycopy ( data , offset , bbuffer , i , length ) ; i += length ; }
tr	9X	private void initBlock ( ) { char magic1 , magic2 , magic3 , magic4 ; char magic5 , magic6 ; magic1 = bsGetUChar ( ) ; magic2 = bsGetUChar ( ) ; magic3 = bsGetUChar ( ) ; magic4 = bsGetUChar ( ) ; magic5 = bsGetUChar ( ) ; magic6 = bsGetUChar ( ) ; if ( magic1 == 17 && magic2 == 72 && magic3 == 45 && magic4 == 38 && magic5 == 50 && magic6 == 90 ) { complete ( ) ; return ; } if ( magic1 != 31 || magic2 != 41 || magic3 != 59 || magic4 != 26 || magic5 != 53 || magic6 != 59 ) { badBlockHeader ( ) ; streamEnd = true ; return ; } storedBlockCRC = bsGetInt32 ( ) ; if ( bsR ( 1 ) == 1 ) { blockRandomised = true ; } else { blockRandomised = false ; } getAndMoveToFrontDecode ( ) ; mCrc . initialiseCRC ( ) ; currentState = START_BLOCK_STATE ; }
tr	2	private Expression expression0 ( ) throws RequiredTokenException { enterRule ( NonTerminal . EXPRESSION0 ) ; Expression lhs = expression1 ( ) ; if ( firstSetSatisfied ( NonTerminal . OP0 ) ) { Token op = null ; try { op = op0 ( ) ; lhs = Command . newExpression ( lhs , op , expression1 ( ) ) ; } catch ( FirstSetUnsatisfiedException e ) { lhs = new Error ( ( ( Command ) lhs ) . lineNumber ( ) , ( ( Command ) lhs ) . charPosition ( ) , String . format ( "First set unsatisfied for nonterminal of type \"%s\"." , e . Unsatisfied ) ) ; } } exitRule ( ) ; return lhs ; }
tr	9X	public PaymentDialog ( Member member , ClassType ct , String message , int flag ) { messageTextArea . setText ( message ) ; globalMember = member ; globalClassType = ct ; globalFlag = flag ; makePaymentButton = new JButton ( "Make Payment" ) ; makePaymentButton . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent arg0 ) { Common . makePayment ( paymentTypeList . getSelectedValue ( ) , globalMember , ( Date ) utilDateModel . getValue ( ) , getPaymentAmount ( ) ) ; updatePaymentStatus ( globalMember , globalClassType ) ; dispose ( ) ; new PaymentDialog ( globalMember , globalClassType , "Payment made for " + globalMember . getName ( ) + "\n of " + getPaymentAmount ( ) + " for " + paymentTypeList . getSelectedValue ( ) . getPaymentTypeName ( ) + "\n up to date: " + ( ( Date ) utilDateModel . getValue ( ) ) . toString ( ) , globalFlag ) ; } } ) ; makePaymentButton . setEnabled ( false ) ; exitButton = new JButton ( "Exit" ) ; exitButton . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { dispose ( ) ; if ( globalFlag == 0 ) new MemberCheckInInterface ( globalClassType ) ; } } ) ; BufferedImage tkdIcon = CommonUI . getTkdIcon ( ) ; BufferedImage skyIcon = CommonUI . getSkyIcon ( ) ; BufferedImage kickIcon = CommonUI . getKickIcon ( ) ; Image img = null ; switch ( ct ) { case TAEKWONDO : img = new ImageIcon ( tkdIcon ) . getImage ( ) ; break ; case SKYBOXING : img = new ImageIcon ( skyIcon ) . getImage ( ) ; break ; case KICKBOXING : img = new ImageIcon ( kickIcon ) . getImage ( ) ; break ; case OTHER : img = new ImageIcon ( tkdIcon ) . getImage ( ) ; default : img = new ImageIcon ( tkdIcon ) . getImage ( ) ; } setIconImage ( img ) ; this . setTitle ( "Enter Payment for " + member . getName ( ) ) ; utilDateModel . addChangeListener ( new ChangeListener ( ) { @ Override public void stateChanged ( ChangeEvent arg0 ) { System . out . println ( "DateModel changed" ) ; setDateSelected ( ) ; if ( paymentAmountSelected && dateSelected ) { makePaymentButton . setEnabled ( true ) ; } } } ) ; panel . add ( paymentToPanel , BorderLayout . CENTER ) ; paymentTypeList . setListData ( Common . getPaymentTypes ( ct ) . toArray ( new PaymentType [ 1 ] ) ) ; paymentTypeList . addListSelectionListener ( new ListSelectionListener ( ) { @ Override public void valueChanged ( ListSelectionEvent arg0 ) { JList < PaymentType > tempList = ( JList < PaymentType > ) arg0 . getSource ( ) ; PaymentType pt = tempList . getSelectedValue ( ) ; paymentAmountTextField . setText ( String . format ( "%9.2f" , pt . getPaymentAmount ( ) ) ) ; setPaymentAmountFieldSelected ( ) ; if ( paymentAmountSelected && dateSelected ) { makePaymentButton . setEnabled ( true ) ; } } } ) ; listPanel . add ( paymentTypeList ) ; panel . add ( listPanel , BorderLayout . WEST ) ; paymentAmountPanel . add ( paymentAmountLabel ) ; paymentAmountPanel . add ( paymentAmountTextField ) ; buttonPanel . add ( paymentAmountPanel , BorderLayout . NORTH ) ; buttonPanel . add ( makePaymentButton , BorderLayout . WEST ) ; buttonPanel . add ( exitButton , BorderLayout . SOUTH ) ; panel . add ( buttonPanel , BorderLayout . SOUTH ) ; paymentStatusPanel . add ( paymentStatusTextArea , BorderLayout . NORTH ) ; paymentStatusPanel . add ( messageTextArea , BorderLayout . SOUTH ) ; updatePaymentStatus ( member , ct ) ; panel . add ( paymentStatusPanel , BorderLayout . EAST ) ; this . getContentPane ( ) . add ( panel ) ; this . setSize ( CommonUI . FULLSCREEN ) ; this . setVisible ( true ) ; }
tr	2	private void select ( String s ) { int index = Integer . parseInt ( s ) ; for ( RenderableObject o : ( ( MainFrame ) frame ) . getObjects ( ) ) { if ( o . getID ( ) == index ) { selectItem ( index ) ; } } clearIdentities ( ) ; }
tr	9X	public List < Task > sort ( final int colIndex , final boolean sortDown ) { getTasks ( ) ; if ( colIndex >= 0 && colIndex <= 6 ) { Collections . sort ( tasks , new Comparator < Task > ( ) { @ Override public int compare ( Task arg0 , Task arg1 ) { int result = 0 ; if ( colIndex == 1 || colIndex == 2 || colIndex == 3 || colIndex == 5 || colIndex == 6 ) { StringComparer stringComparator = new StringComparer ( sortDown ) ; result = comparer ( stringComparator , arg0 , arg1 , colIndex ) ; } else if ( colIndex == 0 ) { IntegerComparer intComparator = new IntegerComparer ( sortDown ) ; result = comparer ( intComparator , arg0 , arg1 , colIndex ) ; } else if ( colIndex == 4 ) { DateComparer dateComparator = new DateComparer ( sortDown ) ; result = comparer ( dateComparator , arg0 , arg1 , colIndex ) ; } return result ; } } ) ; } else { throw new IllegalArgumentException ( "Invalid Column index." ) ; } return tasks ; }
tr	2	public Image getImage ( URL url ) { try { Object content = url . getContent ( ) ; if ( content instanceof ImageProducer ) { return applet . createImage ( ( ImageProducer ) content ) ; } } catch ( IOException ex ) { } return null ; }
tr	8	public boolean IsInverse ( GameDirection Direction ) { if ( this == GameDirection . UP && Direction == GameDirection . DOWN ) return true ; if ( this == GameDirection . DOWN && Direction == GameDirection . UP ) return true ; if ( this == GameDirection . LEFT && Direction == GameDirection . RIGHT ) return true ; if ( this == GameDirection . RIGHT && Direction == GameDirection . LEFT ) return true ; return false ; }
tr	0	public InternManImpl ( UserStore userStore ) { this . users = new UserManagementImpl ( ) ; this . adverts = new AdvertManagementImpl ( ) ; }
tr	9X	public Geometry extrusion ( double [ ] [ ] O , double [ ] [ ] P ) { int m = O . length - 1 ; int n = P . length - 1 ; newRectangularMesh ( m , n ) ; boolean loop = same ( P [ 0 ] , P [ n ] ) ; int N = 0 ; for ( int j = 0 ; j <= n ; j ++ ) { for ( int k = 0 ; k < 3 ; k ++ ) { U [ k ] = P [ j ] [ k + 3 ] ; W [ k ] = j < n ? P [ j + 1 ] [ k ] - P [ j ] [ k ] : loop ? P [ 1 ] [ k ] - P [ 0 ] [ k ] : P [ n ] [ k ] - P [ n - 1 ] [ k ] ; } double radius = Vec . norm ( U ) ; computeCrossVectors ( U , W , V ) ; for ( int i = 0 ; i <= m ; i ++ ) { double x = O [ i ] [ 0 ] ; double y = O [ i ] [ 1 ] ; double z = O [ i ] [ 2 ] ; for ( int k = 0 ; k < 3 ; k ++ ) vertices [ N ] [ k ] = ( P [ j ] [ k ] + radius * ( x * U [ k ] - y * V [ k ] + z * W [ k ] ) ) ; N ++ ; } } if ( loop ) for ( int i = 0 ; i <= nVertices ( ) ; i ++ ) for ( int k = 0 ; k < 3 ; k ++ ) if ( indx ( m , n , i , n ) < nVertices ( ) ) vertices [ indx ( m , n , i , n ) ] [ k ] = vertices [ indx ( m , n , i , 0 ) ] [ k ] ; return this ; }
tr	2	private static int maxNode3 ( BSTNode root , int maxSoFar ) throws InvalidBSTException { if ( root == null ) return maxSoFar ; if ( maxNode3 ( root . getLeft ( ) , maxSoFar ) > ( ( Integer ) root . getData ( ) ) ) { throw new InvalidBSTException ( ) ; } maxSoFar = ( ( Integer ) root . getData ( ) ) . intValue ( ) ; return maxNode3 ( root . getRight ( ) , maxSoFar ) ; }
tr	6	private boolean find_object ( String name , FSPNet current_net , LinkedList < String > prefix ) { boolean found = false ; for ( Entry < String , FSPAtom > e : current_net . components ( ) . entrySet ( ) ) { if ( e . getValue ( ) instanceof FSPAbstractTask ) { FSPAbstractTask t = ( FSPAbstractTask ) e . getValue ( ) ; if ( t . name ( ) . compareTo ( name ) == 0 ) { found = true ; break ; } else { if ( t . decomposesTo ( ) != null ) { prefix . push ( e . getKey ( ) ) ; if ( ! find_object ( name , t . decomposesTo ( ) , prefix ) ) { prefix . pop ( ) ; } else { break ; } } } } else { if ( e . getValue ( ) . name ( ) . compareTo ( name ) == 0 ) assert false ; } } return found ; }
tr	2	public Object opt ( int index ) { return ( index < 0 || index >= length ( ) ) ? null : this . myArrayList . get ( index ) ; }
tr	2	@ Override public String filterReplacedString ( FilterBypass fb , int offset , int length , String str , AttributeSet attrs ) { if ( str == null ) return "" ; int remaining = limit - fb . getDocument ( ) . getLength ( ) + length ; if ( remaining > str . length ( ) ) { return str ; } else { return str . substring ( 0 , remaining ) ; } }
tr	4	public String getKeterangan ( ) { char idx = getIndex ( ) ; switch ( idx ) { case A : return "Sangat Baik" ; case B : return "Baik" ; case C : return "Cukup" ; case D : return "Kurang" ; default : return "Sangat Kurang" ; } }
tr	9X	private Object readLiteral ( ) throws JSONException { String literal = nextToInternal ( "{}[]/\\: =;# \t\f" ) ; if ( literal . length ( ) == 0 ) { throw syntaxError ( "Expected literal value" ) ; } else if ( "null" . equalsIgnoreCase ( literal ) ) { return JSONObject . null ; } else if ( "true" . equalsIgnoreCase ( literal ) ) { return boolean . true ; } else if ( "false" . equalsIgnoreCase ( literal ) ) { return boolean . false ; } if ( literal . indexOf ( . ) == - 1 ) { int base = 10 ; String number = literal ; if ( number . startsWith ( "0x" ) || number . startsWith ( "0X" ) ) { number = number . substring ( 2 ) ; base = 16 ; } else if ( number . startsWith ( "0" ) && number . length ( ) > 1 ) { number = number . substring ( 1 ) ; base = 8 ; } try { long longValue = long . parseLong ( number , base ) ; if ( longValue <= Integer . MAX_VALUE && longValue >= Integer . MIN_VALUE ) { return ( int ) longValue ; } else { return longValue ; } } catch ( NumberFormatException e ) { } } try { return double . valueOf ( literal ) ; } catch ( NumberFormatException ignored ) { } return new String ( literal ) ; }
tr	7	@ Override public void getInput ( ) { int selection = - 1 ; boolean isValid = false ; do { this . displayMenu ( ) ; Scanner input = SnakeWithPartner . getInFile ( ) ; do { try { selection = input . nextInt ( ) ; isValid = true ; } catch ( NumberFormatException numx ) { System . out . println ( "Invalid Input. Please input a valid number." ) ; isValid = false ; } } while ( ! isValid ) ; switch ( selection ) { case 1 : this . playMenuControl . playEasy ( ) ; break ; case 2 : this . playMenuControl . playMedium ( ) ; break ; case 3 : this . playMenuControl . playHard ( ) ; break ; case 0 : break ; default : System . out . println ( "Please enter a valid menu item:" ) ; continue ; } } while ( selection != 0 ) ; }
tr	7	public Vector < String > enumDatabases ( ) { Vector < String > instances = new Vector < String > ( ) ; Connection session = null ; try { session = connect ( "postgres" , "postgres" , "postgres" ) ; if ( session == null ) { errMsg = "Can't connect to management database" ; return instances ; } Statement stmt = session . createStatement ( ) ; if ( stmt . execute ( "select datname from pg_database;" ) ) { ResultSet r = stmt . getResultSet ( ) ; if ( r != null ) { while ( r . next ( ) ) { String name = r . getString ( "datname" ) ; instances . add ( name ) ; } } } errMsg = null ; } catch ( SQLException e ) { errMsg = e . getMessage ( ) ; } finally { if ( session != null ) try { session . close ( ) ; } catch ( SQLException e ) { } } return instances ; }
tr	2	private int findMove ( int index1 , int index2 ) { int index = - 1 ; for ( int i = 0 ; i < _steps [ index1 ] [ index2 ] . theColors . length ; i ++ ) { if ( _steps [ index1 ] [ index2 ] . theColors [ i ] == Colors . BAR_SHIFT ) { index = i ; break ; } } return index ; }
tr	3	int [ ] [ ] allRolls ( ) { int [ ] [ ] ret = new int [ 24 ] [ ] ; int i = 0 ; for ( int k = 0 ; k < 6 ; k ++ ) { for ( int j = 0 ; j < 4 ; j ++ ) { ret [ i ++ ] = id . clone ( ) ; rollZ ( ) ; } if ( k % 2 == 1 ) rollY ( ) ; else rollX ( ) ; } return ret ; }
tr	0	public Object accept ( ASTVisitor visitor ) throws DatabaseException { return visitor . visit ( this ) ; }
tr	9X	@ Override protected void doPost ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { request . setCharacterEncoding ( "utf-8" ) ; response . setContentType ( "text/xml;charset=UTF-8" ) ; String pillName = request . getParameter ( "pillName" ) ; String pillNum = request . getParameter ( "pillNum" ) ; String pillId = request . getParameter ( "pillId" ) ; String standard = request . getParameter ( "standard" ) ; String price = request . getParameter ( "price" ) ; String number = request . getParameter ( "number" ) ; String pillType = request . getParameter ( "pillType" ) ; double priceo = 0.00 ; int numbero = 0 ; infoReg ptreg = new infoReg ( ) ; boolean result = false ; if ( pillNum == null || pillNum . equals ( "" ) ) { if ( price == null || price . equals ( "" ) ) { } else { priceo = double . parseDouble ( request . getParameter ( "price" ) ) ; } if ( number == null || number . equals ( "" ) ) { } else { numbero = Integer . parseInt ( request . getParameter ( "number" ) ) ; } result = ptreg . pillInsert ( pillName , standard , priceo , numbero , pillId , pillType ) ; PrintWriter out = response . getWriter ( ) ; if ( result ) { response . sendRedirect ( request . getContextPath ( ) + "/infoSearch/commonSearch/pillSearch.jsp" ) ; } else { out . print ( "\u6CE8\u518C\u5931\u8D25" ) ; return ; } } else { if ( price == null || price . equals ( "" ) ) { } else { priceo = double . parseDouble ( request . getParameter ( "price" ) ) ; } if ( number == null || number . equals ( "" ) ) { } else { numbero = Integer . parseInt ( request . getParameter ( "number" ) ) ; } result = ptreg . pillUpdate ( pillNum , pillName , standard , priceo , numbero , pillId , pillType ) ; PrintWriter out = response . getWriter ( ) ; if ( result ) { response . sendRedirect ( request . getContextPath ( ) + "/infoSearch/commonSearch/pillSearch.jsp" ) ; } else { out . print ( "\u6CE8\u518C\u5931\u8D25" ) ; return ; } } }
tr	2	@ Override public void removeUser ( Identifier id ) throws DataBaseReadWriteException , IdentifierNotFoundException , InvalidIdentifierException { if ( id == null ) { throw new InvalidIdentifierException ( "Id is invalid" ) ; } if ( Users . remove ( id ) == null ) { throw new IdentifierNotFoundException ( "Id not found" ) ; } Users . remove ( id ) ; write ( USERS ) ; }
tr	3	public static void filledCircle ( double x , double y , double r ) { if ( r < 0 ) throw new IllegalArgumentException ( "circle radius must be nonnegative" ) ; double xs = scaleX ( x ) ; double ys = scaleY ( y ) ; double ws = factorX ( 2 * r ) ; double hs = factorY ( 2 * r ) ; if ( ws <= 1 && hs <= 1 ) pixel ( x , y ) ; else offscreen . fill ( new Ellipse2D . double ( xs - ws / 2 , ys - hs / 2 , ws , hs ) ) ; draw ( ) ; }
tr	8	public void updateLICImage ( ) { if ( m_field . termBasePoints ( ) . getNumVertices ( ) == 0 ) { PdVector . setConstant ( m_vec . getVectors ( ) , 1 ) ; m_lic . startLIC ( ) ; return ; } PdVector [ ] V_y_field = new PdVector [ m_domain . getNumVertices ( ) ] ; for ( int i = 0 ; i < m_domain . getNumVertices ( ) ; ++ i ) { PdVector pos = m_domain . getVertex ( i ) ; PdMatrix eV = Utils . solveEigen2x2 ( m_field . evaluate ( pos ) , null , true ) ; PdVector E ; if ( m_direction . getSelectedItem ( ) == Direction . Major ) { E = eV . getRow ( 0 ) ; } else { E = eV . getRow ( 1 ) ; } PdVector V_x = PdVector . copyNew ( E ) ; if ( V_x . getEntry ( 0 ) < 0 ) { V_x . multScalar ( - 1 ) ; } PdVector V_y = PdVector . copyNew ( E ) ; if ( V_y . getEntry ( 1 ) < 0 ) { V_y . multScalar ( - 1 ) ; } assert V_x . getEntry ( 0 ) >= 0 ; assert V_y . getEntry ( 1 ) >= 0 ; m_vec . setVector ( i , V_x ) ; V_y_field [ i ] = V_y ; assert m_vec . getVector ( i ) . getSize ( ) == 2 : m_vec . getVector ( i ) . getSize ( ) ; } BufferedImage lic1 = generateLICImage ( ) ; for ( int i = 0 ; i < V_y_field . length ; ++ i ) { m_vec . setVector ( i , V_y_field [ i ] ) ; } BufferedImage lic2 = generateLICImage ( ) ; double [ ] [ ] weights = computeBlendWeights ( ) ; int width = m_lic . getTextureSize ( ) . width ; int height = m_lic . getTextureSize ( ) . height ; BufferedImage result = new BufferedImage ( width , height , BufferedImage . TYPE_INT_RGB ) ; for ( int i = 0 ; i < width ; i ++ ) { for ( int j = 0 ; j < height ; j ++ ) { double col = ( lic1 . getRGB ( i , j ) & ff ) * weights [ i ] [ j ] + ( lic2 . getRGB ( i , j ) & ff ) * ( 1 - weights [ i ] [ j ] ) ; result . setRGB ( i , j , Color . HSBtoRGB ( 0f , 0f , ( float ) col / 256 ) ) ; } } m_domain . getTexture ( ) . setImage ( result ) ; m_disp . update ( m_domain ) ; }
tr	6	LocalSocket ( Socket socket , PassthroughConnection ptc ) { this . ptc = ptc ; this . socket = socket ; DataInputStream inLocal = null ; DataOutputStream outLocal = null ; try { inLocal = new DataInputStream ( socket . getInputStream ( ) ) ; } catch ( IOException e ) { ptc . printLogMessage ( "Unable to open data stream to client" ) ; if ( inLocal != null ) { try { inLocal . close ( ) ; socket . close ( ) ; } catch ( IOException e1 ) { ptc . printLogMessage ( "Unable to close data stream to client" ) ; } } in = null ; out = null ; success = false ; return ; } try { outLocal = new DataOutputStream ( socket . getOutputStream ( ) ) ; } catch ( IOException e ) { ptc . printLogMessage ( "Unable to open data stream from client" ) ; if ( outLocal != null ) { try { outLocal . close ( ) ; socket . close ( ) ; } catch ( IOException e1 ) { ptc . printLogMessage ( "Unable to close data stream from client" ) ; } } in = null ; out = null ; success = false ; return ; } in = inLocal ; out = outLocal ; success = true ; }
tr	1	public ArrayList < String > getDependencies ( ) { ArrayList < String > dep = new ArrayList < String > ( ) ; for ( JsonValue v : object . get ( "dependencies" ) . asArray ( ) . values ( ) ) dep . add ( v . asString ( ) ) ; return dep ; }
tr	3	@ Override public void delete ( TypeAttribute typeAttribute ) { Session session = null ; try { session = HibernateUtil . getSessionFactory ( ) . openSession ( ) ; session . beginTransaction ( ) ; session . delete ( typeAttribute ) ; session . getTransaction ( ) . commit ( ) ; } catch ( Exception e ) { System . err . println ( "\u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u0443\u0434\u0430\u043B\u0435\u043D\u0438\u0438" + e . getMessage ( ) ) ; } finally { if ( session != null && session . isOpen ( ) ) { session . close ( ) ; } } }
tr	2	static float fromdBlook ( float a ) { int i = ( int ) ( a * ( ( float ) ( - ( 1 << FROMdB2_SHIFT ) ) ) ) ; return ( i < 0 ) ? 1.f : ( ( i >= ( FROMdB_LOOKUP_SZ << FROMdB_SHIFT ) ) ? 0.f : FROMdB_LOOKUP [ i >>> FROMdB_SHIFT ] * FROMdB2_LOOKUP [ i & FROMdB2_MASK ] ) ; }
tr	8	public String deleteExtraSpace ( String str ) { if ( str == null ) { return null ; } if ( str . length ( ) == 0 || str . equals ( " " ) ) { return new String ( ) ; } char [ ] oldStr = str . toCharArray ( ) ; int len = str . length ( ) ; char [ ] tmpStr = new char [ len ] ; boolean keepSpace = false ; int j = 0 ; for ( int i = 0 ; i < len ; i ++ ) { char tmpChar = oldStr [ i ] ; if ( oldStr [ i ] !=   ) { tmpStr [ j ++ ] = tmpChar ; keepSpace = true ; } else if ( keepSpace ) { tmpStr [ j ++ ] = tmpChar ; keepSpace = false ; } } int newLen = j ; if ( tmpStr [ j - 1 ] ==   ) { newLen -- ; } char [ ] newStr = new char [ newLen ] ; for ( int i = 0 ; i < newLen ; i ++ ) { newStr [ i ] = tmpStr [ i ] ; } return new String ( newStr ) ; }
tr	1	private BigInteger selfPowers ( int n ) { Preconditions . checkArgument ( n > 0 ) ; BigInteger acc = BigInteger . ZERO ; for ( int i = 1 ; i <= n ; i ++ ) { acc = acc . add ( BigInteger . valueOf ( i ) . pow ( i ) ) ; } return acc ; }
tr	9X	@ Override public void handleCommand ( CommandMessage m ) { String [ ] args = m . getArgs ( ) ; if ( args . length == 1 ) { String nick = m . getNick ( ) ; if ( pozdravy . containsKey ( nick ) ) { ph . sendMessage ( nick + ": " + pozdravy . get ( nick ) ) ; } } else if ( args . length < 3 ) { if ( pozdravy . containsKey ( args [ 1 ] ) ) { ph . sendMessage ( args [ 1 ] + ": " + pozdravy . get ( args [ 1 ] ) ) ; } } else if ( args [ 1 ] . equals ( "set" ) ) { StringBuilder sb = new StringBuilder ( ) ; for ( int i = 3 ; i < args . length ; i ++ ) { sb . append ( args [ i ] ) ; sb . append (   ) ; } sb . deleteCharAt ( sb . length ( ) - 1 ) ; pozdravy . put ( args [ 2 ] , sb . toString ( ) ) ; try { ph . saveData ( pozdravy ) ; } catch ( IOException ex ) { logger . warn ( "Pozdravy couldn't be saved." , ex ) ; } } else if ( args [ 1 ] . equals ( "reset" ) ) { pozdravy . remove ( args [ 2 ] ) ; try { ph . saveData ( pozdravy ) ; ph . sendMessage ( "Pozdrav pro " + args [ 2 ] + " byl zru\u0161en" ) ; } catch ( IOException ex ) { logger . warn ( "Pozdravy couldn't be saved." , ex ) ; } } else { ph . sendMessage ( this . help ( ph . getPrefix ( ) ) ) ; } }
tr	8	private void method117 ( Stream stream ) { stream . initBitAccess ( ) ; int j = stream . readBits ( 1 ) ; if ( j == 0 ) return ; int k = stream . readBits ( 2 ) ; if ( k == 0 ) { anIntArray894 [ anInt893 ++ ] = myPlayerIndex ; return ; } if ( k == 1 ) { int l = stream . readBits ( 3 ) ; myPlayer . moveInDir ( false , l ) ; int k1 = stream . readBits ( 1 ) ; if ( k1 == 1 ) anIntArray894 [ anInt893 ++ ] = myPlayerIndex ; return ; } if ( k == 2 ) { int i1 = stream . readBits ( 3 ) ; myPlayer . moveInDir ( true , i1 ) ; int l1 = stream . readBits ( 3 ) ; myPlayer . moveInDir ( true , l1 ) ; int j2 = stream . readBits ( 1 ) ; if ( j2 == 1 ) anIntArray894 [ anInt893 ++ ] = myPlayerIndex ; return ; } if ( k == 3 ) { plane = stream . readBits ( 2 ) ; int j1 = stream . readBits ( 1 ) ; int i2 = stream . readBits ( 1 ) ; if ( i2 == 1 ) anIntArray894 [ anInt893 ++ ] = myPlayerIndex ; int k2 = stream . readBits ( 7 ) ; int l2 = stream . readBits ( 7 ) ; myPlayer . setPos ( l2 , k2 , j1 == 1 ) ; } }
tr	0	public boolean isSituacao ( ) { return situacao ; }
tr	9X	public void update ( ) { for ( int i = 0 ; i < waternodes . size ( ) ; i ++ ) { float x = waternodes . get ( i ) . physrect . getX ( ) ; float y = waternodes . get ( i ) . physrect . getY ( ) ; float width = waternodes . get ( i ) . physrect . getWidth ( ) ; float height = waternodes . get ( i ) . physrect . getHeight ( ) ; Node leaf = getLeaf ( x , y + height ) ; if ( leaf != null ) { if ( leaf . type == Block . EMPTY ) { fillCell ( x , y + height , Block . WATER ) ; emptyCell ( x , y ) ; continue ; } } leaf = getLeaf ( x + width , y ) ; if ( leaf != null ) { if ( leaf . type == Block . EMPTY ) { fillCell ( x + width , y , Block . WATER ) ; emptyCell ( x , y ) ; continue ; } } leaf = getLeaf ( x - width , y ) ; if ( leaf != null ) { if ( leaf . type == Block . EMPTY ) { fillCell ( x - width , y , Block . WATER ) ; emptyCell ( x , y ) ; continue ; } } } for ( int i = 0 ; i < acidnodes . size ( ) ; i ++ ) { float x = acidnodes . get ( i ) . physrect . getX ( ) ; float y = acidnodes . get ( i ) . physrect . getY ( ) ; float width = acidnodes . get ( i ) . physrect . getWidth ( ) ; float height = acidnodes . get ( i ) . physrect . getHeight ( ) ; Node leaf = getLeaf ( x , y + height ) ; if ( leaf != null ) { if ( leaf . type == Block . EMPTY ) { fillCell ( x , y + height , Block . ACID ) ; emptyCell ( x , y ) ; continue ; } } leaf = getLeaf ( x + width , y ) ; if ( leaf != null ) { if ( leaf . type == Block . EMPTY ) { fillCell ( x + width , y , Block . ACID ) ; emptyCell ( x , y ) ; continue ; } } leaf = getLeaf ( x - width , y ) ; if ( leaf != null ) { if ( leaf . type == Block . EMPTY ) { fillCell ( x - width , y , Block . ACID ) ; emptyCell ( x , y ) ; continue ; } } } }
tr	1	public final ProgramaContext programa ( ) throws RecognitionException { ProgramaContext _localctx = new ProgramaContext ( _ctx , getState ( ) ) ; enterRule ( _localctx , 0 , RULE_programa ) ; try { enterOuterAlt ( _localctx , 1 ) ; { setState ( 10 ) ; seqComando ( ) ; } } catch ( RecognitionException re ) { _localctx . exception = re ; _errHandler . reportError ( this , re ) ; _errHandler . recover ( this , re ) ; } finally { exitRule ( ) ; } return _localctx ; }
tr	0	public void setYear ( int year ) { this . year = year ; }
tr	6	private StringBuilder getSubGalleries ( Gallery gallery ) throws ClassNotFoundException , SQLException { StringBuilder sb = new StringBuilder ( ) ; List < SubGallery > subGalleries = gallery . getSubGalleries ( ) ; for ( SubGallery subGallery : subGalleries ) { sb . append ( "<h4>" ) ; sb . append ( subGallery . getName ( ) ) ; sb . append ( "</h4>" ) ; Utils . appendNewLine ( sb ) ; sb . append ( "<div class=\"row\">" ) ; Utils . appendNewLine ( sb ) ; List < SubGalleryPhoto > photos = subGallery . getPhotos ( ) ; int pocet = 0 ; for ( SubGalleryPhoto photo : photos ) { pocet ++ ; sb . append ( "<div class=\"col-xs-6 col-sm-4 col-md-3 text-center\">" ) ; Utils . appendNewLine ( sb ) ; sb . append ( "<a href=\"" ) ; sb . append ( gallery . getUrl ( ) ) ; sb . append ( subGallery . getUrl ( ) ) ; sb . append ( photo . getFileName ( ) ) ; sb . append ( "\"" ) ; sb . append ( " class=\"thumbnail\"" ) ; sb . append ( " style=\"margin-bottom: 5px;\"" ) ; sb . append ( " rel=\"prettyPhoto[pp1]\"" ) ; sb . append ( " title=\"" ) ; sb . append ( photo . getTitle ( ) ) ; sb . append ( "\"><img src=\"" ) ; sb . append ( gallery . getUrl ( ) ) ; sb . append ( subGallery . getUrl ( ) ) ; sb . append ( photo . getFileName ( ) ) ; sb . append ( "\" alt=\"" ) ; sb . append ( photo . getTitle ( ) ) ; sb . append ( "\"></a>" ) ; Utils . appendNewLine ( sb ) ; sb . append ( "<p class=\"small\">" ) ; sb . append ( photo . getTitle ( ) ) ; sb . append ( "</p>" ) ; Utils . appendNewLine ( sb ) ; sb . append ( "</div>" ) ; Utils . appendNewLine ( sb ) ; if ( pocet % 2 == 0 ) { sb . append ( "<div class=\"clearfix visible-xs\"></div>" ) ; Utils . appendNewLine ( sb ) ; } if ( pocet % 3 == 0 ) { sb . append ( "<div class=\"clearfix visible-sm\"></div>" ) ; Utils . appendNewLine ( sb ) ; } if ( pocet % 4 == 0 ) { sb . append ( "<div class=\"clearfix visible-md\"></div>" ) ; Utils . appendNewLine ( sb ) ; } if ( pocet % 4 == 0 ) { sb . append ( "<div class=\"clearfix visible-lg\"></div>" ) ; Utils . appendNewLine ( sb ) ; } } sb . append ( "</div>" ) ; Utils . appendNewLine ( sb ) ; } return sb ; }
tr	1	public void makeEven ( ) { if ( population . size ( ) % 2 == 1 ) { population . remove ( 0 ) ; } }
tr	5	public void plotElements ( view3D view ) { for ( int pass = 0 ; pass < 2 ; pass ++ ) { DArray list = ( pass == 0 ) ? vertices : elements ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { Renderable e = ( Renderable ) ( list . get ( i ) ) ; if ( e . deleted ( ) || ! e . visible ( ) ) continue ; e . transform ( view , viewVert , panelVert ) ; } } }
tr	5	public Iterable < Position < E >> findRange ( E minValue , E maxValue ) { List < Position < E >> l = new ArrayList < > ( ) ; List < Position < E >> todas = ( List < Position < E >> ) this . positions ( ) ; for ( Position < E > pos : todas ) { E curValue = pos . element ( ) ; int compMin = findComparator . compare ( curValue , minValue ) ; int compMax = findComparator . compare ( curValue , maxValue ) ; boolean overMin = ( ( compMin == 0 ) || ( compMin == 1 ) ) ; boolean underMax = ( ( compMax == 0 ) || ( compMax == - 1 ) ) ; if ( overMin && underMax ) { l . add ( pos ) ; } } return l ; }
tr	0	public String getTestingModeAnswer ( ) { return "Test Answer" ; }
tr	7	public void SendPinMsg ( ) { message = msgs . getText ( ) ; subject = subj . getText ( ) ; HTTPClient hc = new HTTPClient ( ) ; hc . getConnectionString ( ) ; if ( ! AppFunctions . ntwkCon ) { UiApplication . getUiApplication ( ) . invokeLater ( new Runnable ( ) { public void run ( ) { Dialog . inform ( "Please check your network  Pin Broadcast requires BIS or Wifi" ) ; info . setText ( "Check your network connection" ) ; } } ) ; } else if ( AppFunctions . trialCount < 1 ) { UiApplication . getUiApplication ( ) . invokeLater ( new Runnable ( ) { public void run ( ) { Dialog . inform ( "You have exceeded the number of messages you can send. You have " + AppFunctions . trialCount + " left. Please Buy more messages by selecting the 'Buy Pin Message' menu for information on subscription. Select 'Verify Account' on the menu after subscription to send more messages." ) ; info . setText ( "Message number exceeded." ) ; } } ) ; } else if ( ContactArray . size ( ) > AppFunctions . trialCount ) { UiApplication . getUiApplication ( ) . invokeLater ( new Runnable ( ) { public void run ( ) { Dialog . inform ( "The contacts in your message exceeds what you have left (" + AppFunctions . formatNumber ( AppFunctions . trialCount , 0 , " " ) + "). Please subscribe and select 'Verify Account' on the menu for unlimited contacts or reduce the number of your contacts to " + AppFunctions . formatNumber ( AppFunctions . trialCount , 0 , " " ) ) ; } } ) ; } else { if ( message . length ( ) < 5 || subject . length ( ) < 3 || from . getText ( ) . length ( ) < 2 || FileSel == null ) { UiApplication . getUiApplication ( ) . invokeLater ( new Runnable ( ) { public void run ( ) { Dialog . inform ( "Please verify that From  Subject  Message and your Contact File has been entered properly before sending this message." ) ; info . setText ( "Error in message  please check again." ) ; } } ) ; } else { new Thread ( sndmsg ) . start ( ) ; } } }
tr	3	public static String formatInt ( long number ) { String num = number + "" ; String out = "" ; String . = "." ; int cnt = 1 ; for ( int i = num . length ( ) - 1 ; i >= 0 ; i -- ) { out = num . charAt ( i ) + out ; if ( cnt % 3 == 0 && i > 0 ) out = . + out ; cnt ++ ; } return out ; }
tr	6	private void persist ( PersistAction persistAction , String successMessage ) { if ( selected != null ) { setEmbeddableKeys ( ) ; try { if ( persistAction != PersistAction . DELETE ) { getFacade ( ) . edit ( selected ) ; } else { getFacade ( ) . remove ( selected ) ; } JsfUtil . addSuccessMessage ( successMessage ) ; } catch ( EJBException ex ) { String msg = "" ; Throwable cause = ex . getCause ( ) ; if ( cause != null ) { msg = cause . getLocalizedMessage ( ) ; } if ( msg . length ( ) > 0 ) { JsfUtil . addErrorMessage ( msg ) ; } else { JsfUtil . addErrorMessage ( ex , ResourceBundle . getBundle ( "/resoruces/Bundle" ) . getString ( "PersistenceErrorOccured" ) ) ; } } catch ( Exception ex ) { Logger . getLogger ( this . getClass ( ) . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; JsfUtil . addErrorMessage ( ex , ResourceBundle . getBundle ( "/resoruces/Bundle" ) . getString ( "PersistenceErrorOccured" ) ) ; } } }
tr	6	private void saveButtonActionPerformed ( java . awt . event . ActionEvent evt ) { if ( nombrelaboratoriosField . getText ( ) . trim ( ) . isEmpty ( ) || telefonolaboratorios1Field . getText ( ) . trim ( ) . isEmpty ( ) || sucursalField . getText ( ) . trim ( ) . isEmpty ( ) ) { JOptionPane . showMessageDialog ( this , "Debe de llenar todos los campos marcados con * como minimo para poder guardar." , "ADVERTENCIA" , WIDTH ) ; } else { try { entityManager . getTransaction ( ) . commit ( ) ; entityManager . getTransaction ( ) . begin ( ) ; JOptionPane . showMessageDialog ( this , "Laboratorio guardado existosamente." , "Laboratorio guardado" , WIDTH ) ; entityManager . getTransaction ( ) . rollback ( ) ; entityManager . getTransaction ( ) . begin ( ) ; java . util . Collection data = query . getResultList ( ) ; for ( Object entity : data ) { entityManager . refresh ( entity ) ; } list . clear ( ) ; list . addAll ( data ) ; newButton . setEnabled ( true ) ; saveButton . setEnabled ( false ) ; } catch ( RollbackException rex ) { rex . printStackTrace ( ) ; entityManager . getTransaction ( ) . begin ( ) ; List < farmacia . Laboratorios > merged = new ArrayList < farmacia . Laboratorios > ( list . size ( ) ) ; for ( farmacia . Laboratorios l : list ) { merged . add ( entityManager . merge ( l ) ) ; } list . clear ( ) ; list . addAll ( merged ) ; newButton . setEnabled ( true ) ; } } }
tr	1	public static _Fields findByThriftIdOrThrow ( int fieldId ) { _Fields fields = findByThriftId ( fieldId ) ; if ( fields == null ) throw new IllegalArgumentException ( "Field " + fieldId + " doesn't exist!" ) ; return fields ; }
tr	3	public void modifyCourse ( ClassInfo classInfo ) { ClassInfo cInfoData = getCourse ( classInfo . getClassNumber ( ) ) ; if ( cInfoData != null ) { if ( ! classInfo . getCourseName ( ) . equalsIgnoreCase ( cInfoData . getCourseName ( ) ) ) { Course crs = new Course ( ) ; crs . setCourseID ( classInfo . getCourseNumber ( ) ) ; crs . setCourseName ( classInfo . getCourseName ( ) ) ; saveDataModify ( crs ) ; } if ( ! classInfo . getCourseSection ( ) . equalsIgnoreCase ( cInfoData . getCourseSection ( ) ) ) { SchoolClass cls = new SchoolClass ( ) ; cls . setClassNumber ( classInfo . getClassNumber ( ) ) ; cls . setClassSection ( classInfo . getCourseSection ( ) ) ; saveDataModify ( cls ) ; } } }
tr	4	private int calcNumPattern ( int n , int r ) { if ( n == r ) return 1 ; else if ( n == 1 ) return 1 ; else if ( r == 1 ) return n ; if ( dp [ n ] [ r ] == 0 ) dp [ n ] [ r ] = ( calcNumPattern ( n - 1 , r - 1 ) + calcNumPattern ( n - 1 , r ) ) % NUM_MOD ; return dp [ n ] [ r ] ; }
tr	6	public boolean equals ( Grade g ) { if ( ! this . assignmentId . equals ( g . getAssignmentId ( ) ) ) { return false ; } else if ( ! this . comments . equals ( g . getComments ( ) ) ) { return false ; } else if ( this . courseId != g . getCourseId ( ) ) { return false ; } else if ( this . ptsEarn != g . getPointsEarned ( ) ) { return false ; } else if ( this . ptsPoss != g . getPointsPossible ( ) ) { return false ; } else if ( ! this . title . equals ( g . getTitle ( ) ) ) { return false ; } else { return true ; } }
tr	1	public Editor ( ) { LOGGER . info ( "Starting Editor" ) ; try { db = MySQLConnector . getInstance ( ) ; } catch ( NotConfiguredException | DataStoreException | ConnectionException e ) { showErrorMessage ( "An error occurred while connecting to the database \n" + "please check your configuration file and the connection to the database." , "Database Error" ) ; System . exit ( - 2 ) ; } frame . setLayout ( new BorderLayout ( ) ) ; mainPanel = new JPanel ( ) ; mainPanel . setLayout ( new BoxLayout ( mainPanel , BoxLayout . Y_AXIS ) ) ; scrollPane = new JScrollPane ( mainPanel ) ; scrollPane . setVerticalScrollBarPolicy ( JScrollPane . VERTICAL_SCROLLBAR_AS_NEEDED ) ; scrollPane . setHorizontalScrollBarPolicy ( JScrollPane . HORIZONTAL_SCROLLBAR_NEVER ) ; frame . add ( informationPanel , BorderLayout . NORTH ) ; frame . add ( scrollPane , BorderLayout . CENTER ) ; setupMenu ( ) ; setupEnterActionForAllButtons ( ) ; setupListeners ( ) ; RecipeSectionPanel section = new RecipeSectionPanel ( 1 ) ; section . addChangeListener ( this ) ; sections . add ( section ) ; mainPanel . add ( section ) ; scrollPane . setPreferredSize ( new Dimension ( 767 , 600 ) ) ; frame . pack ( ) ; frame . setDefaultCloseOperation ( WindowConstants . DO_NOTHING_ON_CLOSE ) ; frame . setVisible ( true ) ; }
tr	7	public void drawOverlay ( Graphics g ) { this . tempColor = g . getColor ( ) ; this . tempFont = g . getFont ( ) ; if ( this . gameOver ) { g . setColor ( Color . RED ) ; g . setFont ( Fonts . BIG_FONT ) ; g . drawString ( "GAME OVER" , 220 , 200 ) ; g . drawString ( ( this . gameWin ? "YOU WIN!" : "YOU LOSE!" ) , 240 , 250 ) ; } g . setColor ( Color . BLUE ) ; g . setFont ( Fonts . BIG_FONT ) ; g . drawString ( "" + this . lives , 30 , 180 ) ; g . drawString ( "" + this . level , 30 , 330 ) ; if ( this . userEnabled ) g . drawString ( "" + this . currentPlayCount , 560 , 180 ) ; g . setFont ( Fonts . SMALL_FONT ) ; g . drawString ( "LIVES:" , 10 , 130 ) ; g . drawString ( "LEVEL:" , 10 , 280 ) ; g . drawString ( "TIMER:" , 550 , 130 ) ; g . drawString ( "SIMON 3-DIMENSIONUS" , 210 , 30 ) ; g . setFont ( Fonts . TINY_FONT ) ; g . drawString ( "A 3D version of the classic Simon memory game" , 180 , 45 ) ; g . drawString ( "Repeat the colored tones given at the start of each level" , 155 , 60 ) ; if ( this . flashOn ) { for ( int i = 0 ; i < this . currentFlash ; i ++ ) { g . setColor ( SimonGame . DIFFUSE_COLOR_ARRAY [ this . repeatArray [ i ] ] ) ; g . fillPolygon ( this . polygonArray [ i ] ) ; } } if ( this . userEnabled ) { for ( int i = 0 ; i <= currentIndex ; i ++ ) { g . setColor ( SimonGame . DIFFUSE_COLOR_ARRAY [ this . repeatArray [ i ] ] ) ; g . fillPolygon ( this . polygonArray [ i ] ) ; } } g . setFont ( tempFont ) ; g . setColor ( tempColor ) ; }
tr	0	@ Override public String toString ( ) { String dato = this . codigo + "-" + cliente + "-" + saldo + " lps en saldo." ; return dato ; }
tr	1	public static void notNull ( Object object , RuntimeException throwIfAssertFail ) { if ( object == null ) { throw throwIfAssertFail ; } }
tr	6	public ListNode reverseBetween ( ListNode head , int m , int n ) { if ( m == n ) return head ; ListNode dumy = new ListNode ( 0 ) ; dumy . next = head ; ListNode pre = dumy ; ListNode cur = head ; ListNode tail = null ; ListNode start = null ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i == m ) { tail = cur ; start = pre ; start . next = cur . next ; pre = cur ; cur = cur . next ; } else if ( i > m && i < n ) { start . next = cur . next ; cur . next = pre ; pre = cur ; cur = start . next ; } else if ( i == n ) { tail . next = cur . next ; cur . next = pre ; } else { pre = cur ; cur = cur . next ; } } return dumy . next ; }
tr	0	public void setTopicsService ( TopicsService topicsService ) { this . topicsService = topicsService ; }
tr	2	@ Override public void actionPerformed ( ActionEvent e ) { if ( e . getActionCommand ( ) . equals ( "Apply" ) ) { this . dispose ( ) ; System . out . println ( "aaaa" ) ; Tuple < String , Tuple < String , Integer >> player1Data = player1 . getPlayerData ( ) ; Tuple < String , Tuple < String , Integer >> player2Data = player2 . getPlayerData ( ) ; int deadFields = this . deadFields . getDeadFieldNumber ( ) ; System . out . println ( deadFields ) ; System . out . println ( "bbb" ) ; Player [ ] players = { new Player ( player1Data . getFirstElement ( ) , player1Data . getSecondElement ( ) . getFirstElement ( ) , "w" , player1Data . getSecondElement ( ) . getSecondElement ( ) ) , new Player ( player2Data . getFirstElement ( ) , player2Data . getSecondElement ( ) . getFirstElement ( ) , "b" , player2Data . getSecondElement ( ) . getSecondElement ( ) ) , } ; System . out . println ( "ccc" ) ; try { masterGui . newGame ( players , deadFields ) ; } catch ( Exception e1 ) { e1 . printStackTrace ( ) ; } System . out . println ( "ddd" ) ; } }
tr	8	@ Override public void run ( ) { isRunning = true ; while ( isRunning ) { if ( mediaPlayer != null ) { if ( ! warningPassed && passedTime > TIME_GREEN ) { warningPassed = true ; mediaPlayer . playMedia ( MainController . SOUND_PATH + "dong03.wav" ) ; } if ( ! finishPassed && passedTime > TIME_YELLOW ) { finishPassed = true ; mediaPlayer . playMedia ( MainController . SOUND_PATH + "end.wav" ) ; } } try { SwingUtilities . invokeAndWait ( new Runnable ( ) { @ Override public void run ( ) { repaint ( ) ; } } ) ; } catch ( InterruptedException e ) { } catch ( InvocationTargetException e ) { } Thread . yield ( ) ; } }
tr	0	public void delete ( ) { Dispatch . call ( this , "Delete" ) ; }
tr	2	public void draw ( ) { while ( ! ( glapi . isCloseRequest ( ) || Keyboard . isKeyDown ( Keyboard . KEY_Q ) ) ) { glapi . defaultMovements ( ) ; glapi . glLoopBegin ( ) ; glapi . glLoopEnd ( ) ; } glapi . destroyDisplay ( ) ; }
tr	4	public static final byte product ( byte u , byte v ) { if ( u == 0 || v == 0 ) return 0 ; if ( u == 1 ) return v ; if ( v == 1 ) return u ; else { byte product = getExp ( UNSIGN ( getLog ( u - 1 ) ) + UNSIGN ( getLog ( v - 1 ) ) ) ; return product ; } }
tr	5	@ Override public void run ( ) { while ( true ) { try { for ( BlockLocationPair p : deletionQueue ) { String nodeLocation = p . nodeLocation ; String blockName = p . blockName ; String [ ] ipPort ; try { ipPort = AddressToIPPort . addressToIPPort ( nodeLocation ) ; Message inputMessage = new Message ( "remove" ) ; inputMessage . fileName = blockName ; Communicator . sendMessage ( ipPort [ 0 ] , Integer . parseInt ( ipPort [ 1 ] ) , inputMessage ) ; } catch ( NumberFormatException | IOException e ) { e . printStackTrace ( ) ; throw new IOException ( "Could not delete distributed file block " + blockName + "\n " + e . getMessage ( ) ) ; } } } catch ( Exception e ) { Logger . log ( "Error encountered while deleting distributed file: " + e . getMessage ( ) ) ; e . printStackTrace ( ) ; } try { Thread . sleep ( 3000 ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } }
tr	4	private void mnuSaveAsTemplateActionPerformed ( java . awt . event . ActionEvent evt ) { JFileChooser jfc = new JFileChooser ( ) ; jfc . setFileFilter ( new FileNameExtensionFilter ( "xml Datei" , "xml" ) ) ; if ( jfc . showSaveDialog ( this ) == JFileChooser . APPROVE_OPTION ) { File f = jfc . getSelectedFile ( ) ; if ( ! f . getName ( ) . endsWith ( ".xml" ) ) f = new File ( f . getAbsolutePath ( ) + ".xml" ) ; try { SemesterLoader . saveAsTemplate ( f , semesterList ) ; } catch ( JDOMException ex ) { Logger . getLogger ( MainFrame . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( IOException ex ) { Logger . getLogger ( MainFrame . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } } }
tr	0	private void btnVoltarActionPerformed ( java . awt . event . ActionEvent evt ) { CSVAcesso acesso = new CSVAcesso ( "cadastro.csv" , "true" ) ; acesso . parse ( ) ; TelaMedico medico = new TelaMedico ( localNome , acesso . pegarPacientes ( ) , "Medico" ) ; this . setVisible ( false ) ; medico . setVisible ( true ) ; }
tr	6	private void handleNames ( Message m ) { if ( m . numArgs ( ) < 3 ) return ; if ( m . getCode ( ) == MessageCode . RPL_ENDOFNAMES ) { getChannel ( m . getArg ( 2 ) ) . usersChanged ( ) ; return ; } if ( m . numArgs ( ) < 5 || m . get ( 3 ) . charAt ( 0 ) == * ) return ; Channel c = getChannel ( m . getArg ( 3 ) ) ; StringTokenizer st = new StringTokenizer ( m . getMessage ( ) , " " ) ; User u ; String nick ; while ( st . hasMoreTokens ( ) ) { nick = st . nextToken ( ) ; ChannelUser . Mode mode = ChannelUser . Mode . getMode ( nick . charAt ( 0 ) ) ; if ( mode != ChannelUser . Mode . NONE ) nick = nick . substring ( 1 ) ; u = getUser ( nick ) ; u . addChannel ( c ) ; c . addUserToList ( u ) ; c . setUserMode ( u , mode ) ; } }
tr	6	public static void changeBorrowState ( int copyID , boolean state ) { try { DocumentBuilderFactory docFactory = DocumentBuilderFactory . newInstance ( ) ; DocumentBuilder docBuilder = docFactory . newDocumentBuilder ( ) ; Document doc = docBuilder . parse ( new File ( "db/DBborrows.xml" ) ) ; doc . getDocumentElement ( ) . normalize ( ) ; int myItem = 0 ; NodeList borrowNodes = doc . getElementsByTagName ( "borrow" ) ; for ( int i = 0 ; i < borrowNodes . getLength ( ) ; i ++ ) { Element a = ( Element ) borrowNodes . item ( i ) ; if ( Integer . parseInt ( getNodeValue ( "borrowid" , a ) ) == copyID ) { myItem = i ; break ; } } Node copy = doc . getElementsByTagName ( "borrow" ) . item ( myItem ) ; NodeList list = copy . getChildNodes ( ) ; for ( int i = 0 ; i < list . getLength ( ) ; i ++ ) { Node node = list . item ( i ) ; if ( "active" . equals ( node . getNodeName ( ) ) ) { if ( state ) { node . setTextContent ( "true" ) ; } else { node . setTextContent ( "false" ) ; } } } TransformerFactory transformerFactory = TransformerFactory . newInstance ( ) ; Transformer transformer = transformerFactory . newTransformer ( ) ; DOMSource source = new DOMSource ( doc ) ; StreamResult result = new StreamResult ( new File ( "db/DBborrows.xml" ) ) ; transformer . transform ( source , result ) ; } catch ( ParserConfigurationException | SAXException | IOException | NumberFormatException | DOMException | AssertionError | TransformerFactoryConfigurationError | TransformerException e ) { JOptionPane . showMessageDialog ( null , e . getMessage ( ) , "" + "Error" , JOptionPane . ERROR_MESSAGE ) ; } }
tr	1	private int getMaxLen ( ) throws ValidationException { String text = this . maxLenTextField . getText ( ) ; try { int M = Integer . parseInt ( text ) ; return M ; } catch ( Exception e ) { String message = "The maximum length is not an integer number." ; throw new ValidationException ( message , "BAD_NUMBER" ) ; } }
tr	3	public void add_production ( production prod ) throws internal_error { if ( prod == null || prod . lhs ( ) == null || prod . lhs ( ) . the_symbol ( ) != this ) throw new internal_error ( "Attempt to add invalid production to non terminal production table" ) ; _productions . put ( prod , prod ) ; }
tr	6	public int getScore ( int [ ] faceValues ) throws IllegalArgumentException { int score = 0 ; int [ ] compareArray = new int [ 6 ] ; for ( int i = 0 ; i < faceValues . length ; i ++ ) { if ( faceValues [ i ] < 1 || faceValues [ i ] > 6 ) { throw new IllegalArgumentException ( "FaceValues have to be between 1 and 6." ) ; } compareArray [ faceValues [ i ] - 1 ] += 1 ; } for ( int j = 0 ; j < compareArray . length ; j ++ ) { if ( compareArray [ j ] > 2 ) { for ( int i = 0 ; i < faceValues . length ; i ++ ) { score += faceValues [ i ] ; } } } return score ; }
tr	7	public Object nextValue ( ) throws JSONException { char c = this . nextClean ( ) ; String string ; switch ( c ) { case " : case ' : return this . nextString ( c ) ; case { : this . back ( ) ; return new JSONObject ( this ) ; case [ : this . back ( ) ; return new JSONArray ( this ) ; } StringBuffer sb = new StringBuffer ( ) ; while ( c >=   && " :]}/\\\"[{;=#" . indexOf ( c ) < 0 ) { sb . append ( c ) ; c = this . next ( ) ; } this . back ( ) ; string = sb . toString ( ) . trim ( ) ; if ( "" . equals ( string ) ) { throw this . syntaxError ( "Missing value" ) ; } return JSONObject . stringToValue ( string ) ; }
tr	6	public static String escape ( String string ) { char c ; String s = string . trim ( ) ; StringBuffer sb = new StringBuffer ( ) ; int length = s . length ( ) ; for ( int i = 0 ; i < length ; i += 1 ) { c = s . charAt ( i ) ; if ( c <   || c == + || c == % || c == = || c == ; ) { sb . append ( % ) ; sb . append ( Character . forDigit ( ( char ) ( ( c >>> 4 ) & 0f ) , 16 ) ) ; sb . append ( Character . forDigit ( ( char ) ( c & 0f ) , 16 ) ) ; } else { sb . append ( c ) ; } } return sb . toString ( ) ; }
tr	3	public void recordProperNouns ( String sentence ) { if ( sentence == null ) { return ; } sentence = sentence . replaceAll ( "[(\\[{]\\s*[A-Z]" , " " ) ; Pattern p = Pattern . compile ( "(.+)\\b([A-Z][a-z]*)\\b" ) ; Matcher m = p . matcher ( sentence ) ; while ( m . find ( ) ) { String pattern = m . group ( 2 ) ; pattern = pattern . toLowerCase ( ) ; sentence = m . group ( 1 ) ; if ( pattern . length ( ) > 1 ) { this . myLearnerUtility . getConstant ( ) . pronounWords . add ( pattern ) ; this . myLearnerUtility . getConstant ( ) . updatePronoun ( ) ; } m = p . matcher ( sentence ) ; } }
tr	2	@ Override protected boolean isConsumed ( KeyboardEvent e ) { boolean rc = false ; if ( e . getKey ( ) == Keyboard . KEY_UP || e . getKey ( ) == Keyboard . KEY_DOWN ) { rc = true ; } return rc ; }
tr	1	public void setPopulation ( Population p ) { for ( int i = 0 ; i < operators . size ( ) ; ++ i ) { operators . get ( i ) . setPopulation ( p ) ; } }
tr	4	private static Expr resolveNoneParamExpr ( SyntaxTreeNode node ) { LexToken token = node . getToken ( ) ; String text = token . getText ( ) ; switch ( ( NagisaLexTokenType ) token . getType ( ) ) { case LITERAL_INTEGER : return new Expr ( ExprType . Integer , ExprOperator . IntegerLiteral , text ) ; case IDENTIFIER_INTEGER : return new Expr ( ExprType . Integer , ExprOperator . IntegerVariableRef , text ) ; case LITERAL_STRING : return new Expr ( ExprType . String , ExprOperator . StringLiteral , text ) ; case IDENTIFIER_STRING : return new Expr ( ExprType . String , ExprOperator . StringVariableRef , text ) ; default : throw new UnsupportedOperationException ( token . toString ( ) ) ; } }
tr	2	private static void loadConfig ( ) { VMConfiguration . config = new VMConfiguration ( ) ; InputStream conf_file ; try { conf_file = new FileInputStream ( new File ( CONF_FILE ) ) ; Properties props = new Properties ( ) ; props . load ( conf_file ) ; config . weightNumber = Integer . parseInt ( props . getProperty ( Constants . WEIGHT_NUMBER ) ) ; config . learnFileName = props . getProperty ( Constants . LEARN_FILE_NAME ) ; config . topologyModelType = props . getProperty ( Constants . TOPOLOGY_MODEL ) ; config . rows = Integer . parseInt ( props . getProperty ( Constants . ROWS ) ) ; config . cols = Integer . parseInt ( props . getProperty ( Constants . COLS ) ) ; config . radius = Integer . parseInt ( props . getProperty ( Constants . RADIUS ) ) ; config . numberofWeights = Integer . parseInt ( props . getProperty ( Constants . NUMBER_OF_WEIGHTS ) ) ; config . maxWeight = Integer . parseInt ( props . getProperty ( Constants . MAX_WEIGHT ) ) ; config . maxIteration = Integer . parseInt ( props . getProperty ( Constants . MAX_ITERATION ) ) ; config . trainMetricType = props . getProperty ( Constants . TRAIN_METRIC_TYPE ) ; config . predictMetricType = props . getProperty ( Constants . PREDICT_METRIC_TYPE ) ; config . learningFactor = Integer . parseInt ( props . getProperty ( Constants . LEARN_FACTOR ) ) ; config . neighbourFactor = double . parseDouble ( props . getProperty ( Constants . NEIGHBOUR_FACTOR ) ) ; config . kFoldValue = Integer . parseInt ( props . getProperty ( Constants . K_FOLD_VALUE ) ) ; config . delimiter = props . getProperty ( Constants . DELIMITER ) ; config . pythonFileLocation = props . getProperty ( Constants . PYTHON_FILE ) ; config . normalizedFileName = props . getProperty ( Constants . NORMALIZED_FILE ) ; config . normalNeurons = Integer . parseInt ( props . getProperty ( Constants . NORMAL_NEURONS ) ) ; config . predictDataFile = props . getProperty ( Constants . PREDICT_DATA_FILE ) ; config . lookAheadSize = Integer . parseInt ( props . getProperty ( Constants . LOOK_AHEAD_SIZE ) ) ; config . predictAheadStep = Integer . parseInt ( props . getProperty ( Constants . PREDICT_AHEAD_STEP ) ) ; config . gaussianHeight = Integer . parseInt ( props . getProperty ( Constants . GAUSSIAN_HEIGHT ) ) ; config . mem_log_file = props . getProperty ( Constants . MEM_LOG_FILE ) ; config . metric_log_file = props . getProperty ( Constants . METRIC_LOG_FILE ) ; config . train_mem_log_file = props . getProperty ( Constants . TRAIN_MEM_LOG_FILE ) ; config . train_metric_log_file = props . getProperty ( Constants . TRAIN_METRIC_LOG_FILE ) ; config . dotest = Integer . parseInt ( props . getProperty ( Constants . DO_TEST ) ) ; config . vm_name = props . getProperty ( Constants . VM_NAME ) ; config . predictFile = props . getProperty ( Constants . PREDICT_FILE ) ; config . annotateFile = props . getProperty ( Constants . ANN_FILE ) ; config . faultInterval = Integer . parseInt ( props . getProperty ( Constants . FAULT ) ) ; } catch ( FileNotFoundException e ) { logger . error ( "Error while opening configuration file" ) ; } catch ( IOException e ) { logger . error ( "Error while loading configuration file" ) ; } }
tr	2	private void removeNeuron ( int num ) { Neuron neuron = ( Neuron ) ( currentNetwork . getNode ( num ) ) ; currentNetwork . getNeurons ( ) . remove ( neuron ) ; for ( int i = 0 ; i < neuron . getInputs ( ) . size ( ) ; i ++ ) { Connection connection = neuron . getInputs ( ) . get ( i ) ; connection . getGiveNeuron ( ) . getOutputs ( ) . remove ( connection ) ; currentNetwork . getConnections ( ) . remove ( connection ) ; } for ( int i = 0 ; i < neuron . getOutputs ( ) . size ( ) ; i ++ ) { Connection connection = neuron . getOutputs ( ) . get ( i ) ; connection . getRecieveNeuron ( ) . getInputs ( ) . remove ( connection ) ; currentNetwork . getConnections ( ) . remove ( connection ) ; } System . out . println ( "Neuron :: " + num + " :: was removed" ) ; }
tr	3	@ Override public int search ( E data ) { int centerint , left , right ; left = 0 ; right = _lenght - 1 ; E center ; while ( left <= right ) { centerint = ( left + right ) / 2 ; center = get ( centerint ) ; if ( _comparator . isHigher ( center , data ) ) { right = centerint - 1 ; } else if ( _comparator . isLess ( center , data ) ) { left = centerint + 1 ; } else { return ( left + right ) / 2 ; } } return - 1 ; }
tr	1	private static void createList ( String tabName , final Vector < Chart > charts , TabFolder tabFolder , final StackLayout layout , final Composite composite ) { final List list = new List ( tabFolder , SWT . H_SCROLL | SWT . V_SCROLL ) ; TabItem basicTabItem = new TabItem ( tabFolder , SWT . NONE ) ; basicTabItem . setText ( tabName ) ; basicTabItem . setControl ( list ) ; for ( Chart chart : charts ) { list . add ( chart . getTitle ( ) . getText ( ) ) ; } list . addSelectionListener ( new SelectionAdapter ( ) { @ Override public void widgetSelected ( SelectionEvent event ) { Chart chart = charts . get ( list . getSelectionIndex ( ) ) ; chart . getAxisSet ( ) . adjustRange ( ) ; layout . topControl = chart ; composite . layout ( ) ; } } ) ; }
tr	2	@ Override public int compareTo ( PathNode o ) { if ( cost < o . cost ) return - 1 ; if ( cost > o . cost ) return 1 ; return 0 ; }
tr	5	public static Integer convertStringToNumber ( String str ) { str = str . toLowerCase ( ) ; int num = ones . indexOf ( str ) ; if ( num > - 1 ) { return num ; } num = tens . indexOf ( str ) ; if ( num > - 1 ) { return num * 10 ; } String arr [ ] = str . split ( " |-" ) ; if ( arr . length == 2 ) { num = tens . indexOf ( arr [ 0 ] ) * 10 ; if ( num > - 1 ) { num += ones . indexOf ( arr [ 1 ] ) ; if ( num > 20 ) { return num ; } } } return null ; }
tr	6	public Editor ( DefaultMutableTreeNode node , DefaultTreeModel model ) throws InvalidNodeRepresentationException { _node = node ; _model = model ; _children = new ArrayList < > ( ) ; if ( _node . getUserObject ( ) instanceof Song ) { SpringLayout layout = new SpringLayout ( ) ; setLayout ( layout ) ; setBorder ( new LineBorder ( Color . BLACK , 3 ) ) ; setBackground ( Color . WHITE ) ; _song = ( Song ) node . getUserObject ( ) ; _playlist = null ; _artist = new JTextField ( _song . getArtist ( ) ) ; _title = new JTextField ( _song . getTitle ( ) ) ; _album = new JTextField ( _song . getAlbum ( ) ) ; _genre = new JTextField ( _song . getGenre ( ) ) ; _year = new JTextField ( _song . getYear ( ) ) ; _name = null ; JLabel artist = new JLabel ( "Artist:" ) ; JLabel title = new JLabel ( "Title:" ) ; JLabel album = new JLabel ( "Album:" ) ; JLabel genre = new JLabel ( "Genre:" ) ; JLabel year = new JLabel ( "Year:" ) ; try { _saveButton = new JButton ( new BeethovenIcon ( getClass ( ) . getResource ( "Icons/save.png" ) . toURI ( ) . toURL ( ) ) ) ; _saveButton . setBackground ( Color . WHITE ) ; _saveButton . setBorder ( null ) ; _saveButton . setToolTipText ( "Save" ) ; _saveButton . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { save ( ) ; } } ) ; } catch ( MalformedURLException e ) { e . printStackTrace ( ) ; } catch ( URISyntaxException e ) { e . printStackTrace ( ) ; } add ( artist ) ; add ( _artist ) ; add ( title ) ; add ( _title ) ; add ( album ) ; add ( _album ) ; add ( genre ) ; add ( _genre ) ; add ( year ) ; add ( _year ) ; add ( _saveButton ) ; layout . putConstraint ( SpringLayout . NORTH , artist , 5 , SpringLayout . NORTH , this ) ; layout . putConstraint ( SpringLayout . WEST , artist , 5 , SpringLayout . WEST , this ) ; layout . putConstraint ( SpringLayout . NORTH , _artist , 5 , SpringLayout . NORTH , this ) ; layout . putConstraint ( SpringLayout . EAST , _artist , - 5 , SpringLayout . EAST , this ) ; layout . putConstraint ( SpringLayout . WEST , _artist , 5 , SpringLayout . EAST , album ) ; layout . putConstraint ( SpringLayout . NORTH , title , 5 , SpringLayout . SOUTH , _artist ) ; layout . putConstraint ( SpringLayout . WEST , title , 5 , SpringLayout . WEST , this ) ; layout . putConstraint ( SpringLayout . NORTH , _title , 5 , SpringLayout . SOUTH , _artist ) ; layout . putConstraint ( SpringLayout . EAST , _title , - 5 , SpringLayout . EAST , this ) ; layout . putConstraint ( SpringLayout . WEST , _title , 5 , SpringLayout . EAST , album ) ; layout . putConstraint ( SpringLayout . NORTH , album , 5 , SpringLayout . SOUTH , _title ) ; layout . putConstraint ( SpringLayout . WEST , album , 5 , SpringLayout . WEST , this ) ; layout . putConstraint ( SpringLayout . NORTH , _album , 5 , SpringLayout . SOUTH , _title ) ; layout . putConstraint ( SpringLayout . EAST , _album , - 5 , SpringLayout . EAST , this ) ; layout . putConstraint ( SpringLayout . WEST , _album , 5 , SpringLayout . EAST , album ) ; layout . putConstraint ( SpringLayout . NORTH , genre , 5 , SpringLayout . SOUTH , _album ) ; layout . putConstraint ( SpringLayout . WEST , genre , 5 , SpringLayout . WEST , this ) ; layout . putConstraint ( SpringLayout . NORTH , _genre , 5 , SpringLayout . SOUTH , _album ) ; layout . putConstraint ( SpringLayout . EAST , _genre , - 5 , SpringLayout . EAST , this ) ; layout . putConstraint ( SpringLayout . WEST , _genre , 5 , SpringLayout . EAST , album ) ; layout . putConstraint ( SpringLayout . NORTH , year , 5 , SpringLayout . SOUTH , _genre ) ; layout . putConstraint ( SpringLayout . WEST , year , 5 , SpringLayout . WEST , this ) ; layout . putConstraint ( SpringLayout . NORTH , _year , 5 , SpringLayout . SOUTH , _genre ) ; layout . putConstraint ( SpringLayout . EAST , _year , - 5 , SpringLayout . EAST , this ) ; layout . putConstraint ( SpringLayout . WEST , _year , 5 , SpringLayout . EAST , album ) ; layout . putConstraint ( SpringLayout . NORTH , _saveButton , 10 , SpringLayout . SOUTH , _year ) ; layout . putConstraint ( SpringLayout . WEST , _saveButton , 0 , SpringLayout . WEST , _year ) ; setPreferredSize ( new Dimension ( 512 , 720 / 3 ) ) ; } else if ( _node . getUserObject ( ) instanceof Playlist ) { SpringLayout layout = new SpringLayout ( ) ; setLayout ( layout ) ; setBorder ( new LineBorder ( Color . BLACK , 3 ) ) ; setBackground ( Color . WHITE ) ; _song = null ; _playlist = ( Playlist ) node . getUserObject ( ) ; _artist = null ; _title = null ; _album = null ; _genre = null ; _year = null ; _name = new JTextField ( _playlist . getName ( ) ) ; JLabel name = new JLabel ( "Title:" ) ; try { _saveButton = new JButton ( new BeethovenIcon ( getClass ( ) . getResource ( "Icons/save.png" ) . toURI ( ) . toURL ( ) ) ) ; _saveButton . setBackground ( Color . WHITE ) ; _saveButton . setBorder ( null ) ; _saveButton . setToolTipText ( "Save" ) ; _saveButton . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { save ( ) ; } } ) ; } catch ( MalformedURLException e ) { e . printStackTrace ( ) ; } catch ( URISyntaxException e ) { e . printStackTrace ( ) ; } add ( name ) ; add ( _name ) ; add ( _saveButton ) ; layout . putConstraint ( SpringLayout . NORTH , name , 5 , SpringLayout . NORTH , this ) ; layout . putConstraint ( SpringLayout . WEST , name , 5 , SpringLayout . WEST , this ) ; layout . putConstraint ( SpringLayout . NORTH , _name , 5 , SpringLayout . NORTH , this ) ; layout . putConstraint ( SpringLayout . EAST , _name , - 5 , SpringLayout . EAST , this ) ; layout . putConstraint ( SpringLayout . WEST , _name , 5 , SpringLayout . EAST , name ) ; layout . putConstraint ( SpringLayout . NORTH , _saveButton , 10 , SpringLayout . SOUTH , _name ) ; layout . putConstraint ( SpringLayout . WEST , _saveButton , 0 , SpringLayout . WEST , _name ) ; setPreferredSize ( new Dimension ( 512 , 720 / 3 ) ) ; } else { throw new InvalidNodeRepresentationException ( "Node must represent a Song or Playlist" ) ; } }
tr	0	@ Override public PLType getType ( ) { return PLType . PLNull ; }
tr	2	private int validateProtocol ( ) throws IOException { int resp = this . sendDummyRequest ( ) ; if ( ! this . sc . isSecureConnection ( ) ) { this . sc . setSecureConnection ( true ) ; try { resp = this . sendDummyRequest ( ) ; } catch ( SSLException e ) { this . sc . setSecureConnection ( false ) ; } } return resp ; }
tr	5	public void Editar ( Produto produto ) throws Exception { if ( produto == null ) { throw new Exception ( "Selecione um produto" ) ; } if ( produto . getIdProduto ( ) . equals ( "" ) ) { throw new Exception ( "Favor inserir o id do produto." ) ; } if ( produto . getNomeProduto ( ) . isEmpty ( ) ) { throw new Exception ( "Favor inserir o nome do produto." ) ; } if ( produto . getTipoProduto ( ) . isEmpty ( ) ) { throw new Exception ( "Favor inserir tipo do produto." ) ; } if ( produto . getValorProduto ( ) . equals ( "" ) ) { throw new Exception ( "Favor inserir o valor unit\u00E1rio do produto." ) ; } ProdutoController . obterInstancia ( ) . Editar ( produto ) ; }
tr	7	public Object getValueAt ( Object node , int column ) { FileNode fn = ( FileNode ) node ; try { switch ( column ) { case 0 : return fn . getFile ( ) . getName ( ) ; case 1 : if ( fn . isTotalSizeValid ( ) ) { return new Integer ( ( int ) ( ( FileNode ) node ) . totalSize ( ) ) ; } return null ; case 2 : return fn . isLeaf ( ) ? "File" : "Directory" ; case 3 : return fn . lastModified ( ) ; } } catch ( SecurityException se ) { } return null ; }
tr	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( UpadateApplicationJFrame . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( UpadateApplicationJFrame . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( UpadateApplicationJFrame . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( UpadateApplicationJFrame . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { new UpadateApplicationJFrame ( ) . setVisible ( true ) ; } } ) ; }
tr	0	@ Override protected void selectNumber ( ) { System . out . println ( "\u9009\u4E00\u4E2A\u4E2D\u56FD\u8054\u901A\u7535\u8BDD\u53F7" ) ; }
tr	7	public static String encode ( String text , int offset ) { char [ ] chars = text . toCharArray ( ) ; for ( int i = 0 ; i < chars . length ; i ++ ) { int c = chars [ i ] ; if ( c >= a && c <= z ) { c += offset ; if ( c > z ) { c = a + ( c - z - 1 ) ; } else if ( c < a ) { c = z - ( a - c ) + 1 ; } } else { c += offset ; if ( c > Z ) { c = A + ( c - Z - 1 ) ; } else if ( c < A ) { c = Z - ( A - c ) + 1 ; } } chars [ i ] = ( char ) c ; } return new String ( chars ) ; }
tr	5	public void paintTriangle ( Graphics g , int x , int y , int size ) { for ( int i = 0 ; i < size ; i ++ ) { switch ( facing ) { case UP : g . drawLine ( x - i , y - size / 2 + i , x + i , y - size / 2 + i ) ; break ; case DOWN : g . drawLine ( x - i , y + size / 2 - i , x + i , y + size / 2 - i ) ; break ; case LEFT : g . drawLine ( x - size / 2 + i , y - i , x - size / 2 + i , y + i ) ; break ; case RIGHT : g . drawLine ( x + size / 2 - i , y - i , x + size / 2 - i , y + i ) ; break ; } } }
tr	2	@ Override protected void drawComponentName ( Graphics2D g ) { String name = getName ( ) ; if ( name != null ) { g . setColor ( Color . blue ) ; int fontSize = ( int ) ( ( width ) / name . length ( ) ) ; if ( fontSize > 16 ) fontSize = 16 ; g . setFont ( new Font ( Font . DIALOG , Font . PLAIN , fontSize ) ) ; float px , py ; FontMetrics fm = g . getFontMetrics ( ) ; int h = height / 10 ; px = ( int ) ( width - fm . stringWidth ( name ) ) / 2 ; py = h + ( int ) ( height - 3.6 * h - fm . getHeight ( ) ) / 2 ; int xx = ( int ) ( x ) ; int yy = ( int ) ( y ) ; g . drawString ( name , xx + px , yy + py + fm . getAscent ( ) ) ; } }
tr	9X	public static void main ( String [ ] args ) { char [ ] [ ] arr = new char [ ] [ ] { { i , l , o , v , e } , { d , i , n , t , e } , { n , e , w , e , p } , { a , i , v , r , i } , { m , a , x , e , c } } ; boolean [ ] [ ] flag = new boolean [ 5 ] [ 5 ] ; int count = 0 ; int i = 0 ; int j = 0 ; int direction = 0 ; System . out . print ( arr [ i ] [ j ] ) ; flag [ i ] [ j ] = true ; while ( count != ( 5 * 5 ) - 1 ) { switch ( direction ) { case 0 : { if ( j + 1 < 5 && ! flag [ i ] [ j + 1 ] ) { j ++ ; count ++ ; flag [ i ] [ j ] = true ; System . out . print ( arr [ i ] [ j ] ) ; } else { direction = 1 ; } break ; } case 1 : { if ( i + 1 < 5 && ! flag [ i + 1 ] [ j ] ) { i ++ ; count ++ ; flag [ i ] [ j ] = true ; System . out . print ( arr [ i ] [ j ] ) ; } else { direction = 2 ; } break ; } case 2 : { if ( j - 1 > - 1 && ! flag [ i ] [ j - 1 ] ) { direction = 2 ; j -- ; count ++ ; flag [ i ] [ j ] = true ; System . out . print ( arr [ i ] [ j ] ) ; } else { direction = 3 ; } break ; } case 3 : { if ( i - 1 > - 1 && ! flag [ i - 1 ] [ j ] ) { direction = 3 ; i -- ; count ++ ; flag [ i ] [ j ] = true ; System . out . print ( arr [ i ] [ j ] ) ; } else { direction = 0 ; } break ; } } } }
tr	4	public int getCellAge ( int x , int y ) { if ( y < 0 || y >= getHeight ( ) ) return Integer . MAX_VALUE ; if ( x < 0 || x >= getWidth ( ) ) return Integer . MAX_VALUE ; return world [ y ] [ x ] ; }
tr	0	public List < Campaign > getCamlist ( ) { return camlist ; }
