va	0	public static boolean isCreateServer ( ) { return createServer ; }
va	0	public Pizza getPizza ( ) { return pizzabuilder . getPizza ( ) ; }
va	6	public String nextTo ( char delimiter ) throws JSONException { StringBuilder sb = new StringBuilder ( ) ; for ( ; ; ) { char c = this . next ( ) ; if ( c == delimiter || c == 0 || c == '' || c == '' ) { if ( c != 0 ) { this . back ( ) ; } return sb . toString ( ) . trim ( ) ; } sb . append ( c ) ; } }
va	2	public void addStopTime ( int in ) { if ( in == 0 ) { return ; } if ( mStartTime == 0 ) { mStartTime = in ; } mEndTime = in ; }
va	8	@ Override public void unmarshal ( Element e ) { super . unmarshal ( e ) ; NamedNodeMap attrs = e . getAttributes ( ) ; for ( int i = 0 ; i < attrs . getLength ( ) ; i ++ ) { Attr attr = ( Attr ) attrs . item ( i ) ; String name = attr . getName ( ) ; String value = attr . getNodeValue ( ) ; if ( name . equals ( "ROLE" ) ) this . role = ROLE . fromValue ( value ) ; if ( name . equals ( "AGENTTYPE" ) ) this . agenttype = AGENTTYPE . fromValue ( value ) ; if ( name . equals ( "OTHERROLE" ) ) this . otherrole = value ; if ( name . equals ( "OTHERTYPE" ) ) this . othertype = value ; } List < Element > children = DOMHelp . getChildElements ( e ) ; for ( Element child : children ) { String localName = child . getLocalName ( ) ; if ( localName . equals ( "note" ) ) this . getNote ( ) . add ( child . getTextContent ( ) ) ; if ( localName . equals ( "name" ) ) this . name = child . getTextContent ( ) ; } }
va	0	public PLDictionary ( HashMap < String , PLObject > value ) { _value = value ; }
va	1	public int getRowCount ( ) { if ( pluginList == null ) { return 0 ; } else { return pluginList . size ( ) ; } }
va	9	public char getMax ( ) { char max ; if ( hp . size ( ) == 0 ) { return _ ; } else if ( hp . size ( ) == 1 ) { char tmp = hp . get ( 0 ) ; hp . remove ( 0 ) ; return tmp ; } else if ( hp . size ( ) == 2 ) { char tmp = hp . get ( 0 ) ; hp . set ( 0 , hp . get ( 1 ) ) ; hp . remove ( 1 ) ; return tmp ; } else { max = hp . get ( 0 ) ; hp . set ( 0 , hp . get ( hp . size ( ) - 1 ) ) ; hp . remove ( hp . size ( ) - 1 ) ; int i = 0 ; while ( i <= ( hp . size ( ) - 2 ) / 2 ) { if ( ( i != ( hp . size ( ) - 2 ) / 2 || hp . size ( ) % 2 == 1 ) && ( hp . get ( i ) < hp . get ( 2 * i + 1 ) || hp . get ( i ) < hp . get ( 2 * i + 2 ) ) ) { if ( hp . get ( 2 * i + 1 ) > hp . get ( 2 * i + 2 ) ) { swapL ( i ) ; i = 2 * i + 1 ; } else { swapR ( i ) ; i = 2 * i + 2 ; } } else if ( hp . get ( i ) < hp . get ( 2 * i + 1 ) ) { swapL ( i ) ; i = 2 * i + 1 ; } else { return max ; } } return max ; } }
va	9	Writer write ( Writer writer , int indentFactor , int indent ) throws JSONException { try { boolean commanate = false ; final int length = this . length ( ) ; Iterator keys = this . keys ( ) ; writer . write ( { ) ; if ( length == 1 ) { Object key = keys . next ( ) ; writer . write ( quote ( key . toString ( ) ) ) ; writer . write ( : ) ; if ( indentFactor > 0 ) { writer . write (   ) ; } writeValue ( writer , this . map . get ( key ) , indentFactor , indent ) ; } else if ( length != 0 ) { final int newindent = indent + indentFactor ; while ( keys . hasNext ( ) ) { Object key = keys . next ( ) ; if ( commanate ) { writer . write (   ) ; } if ( indentFactor > 0 ) { writer . write ( '' ) ; } indent ( writer , newindent ) ; writer . write ( quote ( key . toString ( ) ) ) ; writer . write ( : ) ; if ( indentFactor > 0 ) { writer . write (   ) ; } writeValue ( writer , this . map . get ( key ) , indentFactor , newindent ) ; commanate = true ; } if ( indentFactor > 0 ) { writer . write ( '' ) ; } indent ( writer , indent ) ; } writer . write ( } ) ; return writer ; } catch ( IOException exception ) { throw new JSONException ( exception ) ; } }
va	8	public boolean applyTechniqueXWing ( ) { int currentCell = 0 ; Set < Integer > valuesCheckForRow = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < this . getSize ( ) ; i ++ ) { valuesCheckForRow . clear ( ) ; for ( int j = 0 ; j < this . getSize ( ) ; j ++ ) { currentCell = i * this . getSize ( ) + j ; if ( getElementWithNumber ( currentCell ) == EMPTY_ELEMENT_VALUE ) { for ( int value : this . validElementsCache . get ( currentCell ) ) { if ( ! valuesCheckForRow . contains ( value ) && ! rowXwing ( currentCell , value ) ) { if ( colXwing ( currentCell , value ) ) { return ( true ) ; } } else if ( ! valuesCheckForRow . contains ( value ) ) { return ( true ) ; } valuesCheckForRow . add ( value ) ; } } } } return ( false ) ; }
va	0	public String getDocumentNumber ( ) { return documentNumber ; }
va	1	private void orderPaths ( ) { for ( int i = 0 ; i < workingPaths . size ( ) ; i ++ ) { Path path = ( Path ) workingPaths . get ( i ) ; orderPath ( path ) ; } }
va	5	public String readLine ( String prompt ) { if ( myConsole != null && myConsole . getInputScript ( ) != null ) { return myConsole . readLine ( prompt ) ; } prompt = ( prompt == null ) ? outputLine : outputLine + prompt ; outputLine = "" ; String line ; while ( ( line = model . popupLineInputDialog ( prompt , allowCancel ) ) == null ) { if ( allowCancel ) throw new CancelledException ( ) ; } return line ; }
va	4	public void initTokenClasses ( ) { table . println ( "package lexer;" ) ; table . println ( " " ) ; table . println ( "/**" ) ; table . println ( " *  This file is automatically generated<br>" ) ; table . println ( " *  it contains the table of mappings from token" ) ; table . println ( " *  constants to their Symbols" ) ; table . println ( "*/" ) ; table . println ( "public class TokenType {" ) ; table . println ( "   public static java.util.HashMap<Tokens Symbol> tokens = new java.util.HashMap<Tokens Symbol>();" ) ; table . println ( "   public TokenType() {" ) ; symbols . println ( "package lexer;" ) ; symbols . println ( " " ) ; symbols . println ( "/**" ) ; symbols . println ( " *  This file is automatically generated<br>" ) ; symbols . println ( " *  - it contains the enumberation of all of the tokens" ) ; symbols . println ( "*/" ) ; symbols . println ( "public enum Tokens {" ) ; symbols . print ( "  BogusToken" ) ; while ( true ) { try { getNextToken ( ) ; } catch ( IOException e ) { break ; } String symType = "Tokens." + type ; table . println ( "     tokens.put(" + symType + "  Symbol.symbol(\"" + value + "\" " + symType + "));" ) ; if ( tokenCount % 5 == 0 ) { symbols . print ( " \n    " + type ) ; } else { symbols . print ( " " + type ) ; } } table . println ( "   }" ) ; table . println ( "}" ) ; table . close ( ) ; symbols . println ( "\n}" ) ; symbols . close ( ) ; try { in . close ( ) ; } catch ( IOException e ) { } }
va	5	private String extractHeaderBlock ( byte [ ] blist ) { int pos = 0 ; for ( int ii = 0 ; ii < blist . length - 4 ; ii ++ ) { if ( blist [ ii ] == 13 && blist [ ii + 1 ] == 10 && blist [ ii + 2 ] == 13 && blist [ ii + 3 ] == 10 ) { pos = ii ; break ; } } byte [ ] buf = new byte [ pos + 4 ] ; System . arraycopy ( blist , 0 , buf , 0 , pos + 4 ) ; return new String ( buf ) ; }
va	2	public void testStringConstructorParseFail ( ) { try { new JSONArray ( "[" ) ; fail ( ) ; } catch ( JSONException e ) { } catch ( StackOverflowError e ) { fail ( "Stack overflowed on input: \"[\"" ) ; } }
va	3	@ Override public boolean supprimerFourmi ( int nombre ) { if ( nombre > 0 ) { if ( this . getListeFourmis ( ) . isEmpty ( ) ) { return false ; } else { int taille = 0 ; for ( int i = 0 ; i < nombre ; i ++ ) { taille = this . getListeFourmis ( ) . size ( ) - 1 ; this . getListeFourmis ( ) . remove ( taille ) ; } return true ; } } return false ; }
va	0	public void loadSettingsPage ( Game game , JFrame frame ) { frame . setSize ( menu_width , menu_height ) ; frame . getContentPane ( ) . removeAll ( ) ; SettingsMenu nextMenu = new SettingsMenu ( game , frame ) ; frame . getContentPane ( ) . add ( nextMenu ) ; frame . revalidate ( ) ; frame . repaint ( ) ; frame . setVisible ( true ) ; }
va	1	@ Override public int getPopulation ( ) { int counter = 0 ; for ( Region r : regions ) counter += r . getPopulation ( ) ; return counter ; }
va	9	public void method389 ( boolean flag1 , int i , int j , String s , int k ) { aBoolean1499 = false ; int l = i ; if ( s == null ) return ; k -= anInt1497 ; for ( int i1 = 0 ; i1 < s . length ( ) ; i1 ++ ) if ( s . charAt ( i1 ) == @ && i1 + 4 < s . length ( ) && s . charAt ( i1 + 4 ) == @ ) { int j1 = getColorByName ( s . substring ( i1 + 1 , i1 + 4 ) ) ; if ( j1 != - 1 ) j = j1 ; i1 += 4 ; } else { char c = s . charAt ( i1 ) ; if ( c !=   ) { if ( flag1 ) method392 ( aByteArrayArray1491 [ c ] , i + anIntArray1494 [ c ] + 1 , k + anIntArray1495 [ c ] + 1 , anIntArray1492 [ c ] , anIntArray1493 [ c ] , 0 ) ; method392 ( aByteArrayArray1491 [ c ] , i + anIntArray1494 [ c ] , k + anIntArray1495 [ c ] , anIntArray1492 [ c ] , anIntArray1493 [ c ] , j ) ; } i += anIntArray1496 [ c ] ; } if ( aBoolean1499 ) DrawingArea . method339 ( k + ( int ) ( ( double ) anInt1497 * 0.69999999999999996D ) , 800000 , i - l , l ) ; }
va	0	public void testUserSetAwayThenCleanup ( ) { roomCmd ( "neel" , "!play 5" ) ; roomCmd ( "grue" , "!play 4" ) ; List < Message > responses = roomCmd ( "id10t" , "!away" ) ; Game ata = gameManager . getGameByChan ( "#channel" ) ; assertEquals ( 3 , ata . m_activePlayers . size ( ) ) ; assertEquals ( 0 , ata . m_waiting . size ( ) ) ; assertMessage ( "#channel" , "id10t has been marked as away.  Use !back to rejoin." , responses . get ( 0 ) ) ; assertMessage ( "bees" , "!botchoose #channel" , responses . get ( 1 ) ) ; }
va	8	@ Override public List < ErrorMessage > validate ( JsonNode jsonDocumentToValidate ) { List < ErrorMessage > results = new ArrayList < > ( ) ; if ( ! isAcceptableType ( jsonDocumentToValidate ) ) { return singleError ( "" , "Invalid type: must be an object" ) ; } Set < String > visitedPropertyNames = new HashSet < > ( ) ; for ( Property property : properties ) { if ( ! jsonDocumentToValidate . has ( property . getName ( ) ) ) { if ( property . isRequired ( ) ) { results . add ( new ErrorMessage ( property . getName ( ) , "Missing required property " + property . getName ( ) ) ) ; } } else { JsonNode propertyValue = jsonDocumentToValidate . get ( property . getName ( ) ) ; for ( ErrorMessage nestedMessage : property . getNestedSchema ( ) . validate ( propertyValue ) ) { results . add ( new ErrorMessage ( property . getName ( ) , nestedMessage ) ) ; } } visitedPropertyNames . add ( property . getName ( ) ) ; } for ( Iterator < Map . Entry < String , JsonNode >> iterator = jsonDocumentToValidate . fields ( ) ; iterator . hasNext ( ) ; ) { Map . Entry < String , JsonNode > entry = iterator . next ( ) ; if ( ! visitedPropertyNames . contains ( entry . getKey ( ) ) ) { for ( ErrorMessage it : additionalProperties . validate ( entry . getValue ( ) ) ) { results . add ( new ErrorMessage ( entry . getKey ( ) , it ) ) ; } } } return results ; }
va	0	public void setNumItems ( final int numItems ) { this . numItems = numItems ; }
va	4	@ Override public ParkReservation call ( ) throws Exception { Connection conn = null ; ParkReservation reservation = null ; try { DataSource ds = ( DataSource ) new InitialContext ( ) . lookup ( "jdbc/acmeworld" ) ; conn = ds . getConnection ( ) ; String qry = "select id  first_name  last_name  num_adults  " + "num_child  num_days  trip_start_date  enter_date " + "from Park_Reservation " + "where id = ?" ; PreparedStatement pstmt = conn . prepareStatement ( qry ) ; pstmt . setBigDecimal ( 1 , reservationId ) ; ResultSet rset = pstmt . executeQuery ( ) ; while ( rset . next ( ) ) { reservation = new ParkReservation ( ) ; reservation . setId ( rset . getBigDecimal ( "id" ) ) ; reservation . setFirstName ( rset . getString ( "first_name" ) ) ; reservation . setLastName ( rset . getString ( "last_name" ) ) ; reservation . setNumAdults ( rset . getInt ( "num_adults" ) ) ; reservation . setNumChild ( rset . getInt ( "num_child" ) ) ; reservation . setTripStartDate ( rset . getDate ( "trip_start_date" ) ) ; reservation . setEnterDate ( rset . getDate ( "enter_date" ) ) ; } } catch ( SQLException ex ) { System . out . println ( "Exception: " + ex ) ; } finally { if ( conn != null ) { try { conn . close ( ) ; } catch ( SQLException ex ) { Logger . getLogger ( AcmeSingleReservation . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } } } return reservation ; }
va	2	private static void __trustAllHttpsCertificates ( ) { com . sun . net . ssl . SSLContext context ; if ( __trustManagers == null ) { __trustManagers = new com . sun . net . ssl . TrustManager [ ] { new _FakeX509TrustManager ( ) } ; } try { context = com . sun . net . ssl . SSLContext . getInstance ( "SSL" ) ; context . init ( null , __trustManagers , new SecureRandom ( ) ) ; } catch ( GeneralSecurityException gse ) { throw new IllegalStateException ( gse . getMessage ( ) ) ; } com . sun . net . ssl . HttpsURLConnection . setDefaultSSLSocketFactory ( context . getSocketFactory ( ) ) ; }
va	7	private void paintGrid ( Graphics g , int w , int h ) { Color c = UIManager . getColor ( LookAndFeelSetter . waveGraphGrid ) ; g . setColor ( c == null ? getForeground ( ) : c ) ; if ( gridVerticalLines > 0 ) for ( int i = 1 ; i <= gridVerticalLines ; i ++ ) { int relW = ( w * i ) / ( gridVerticalLines + 1 ) ; g . drawLine ( relW , 0 , relW , h ) ; } if ( gridVerticalLines > 0 ) for ( int i = 1 ; i <= gridHorizontalLines ; i ++ ) { int relH = ( h * i ) / ( gridHorizontalLines + 1 ) ; g . drawLine ( 0 , relH , w , relH ) ; } c = UIManager . getColor ( LookAndFeelSetter . waveGraphGridCenterLine ) ; if ( isCenterShown ( ) ) { g . setColor ( c == null ? getForeground ( ) : c ) ; g . drawLine ( 0 , h / 2 , w , h / 2 ) ; } }
va	8	boolean timelineMouseDrag ( int x , int y ) { if ( isPauseControl ) { if ( pauseAtMouse >= 0 ) { pauseData [ pauseAtMouse ] = false ; pauseAtMouse = x - sx ; pauseData [ pauseAtMouse ] = true ; isDamage = true ; } return true ; } if ( isCommandMode ) { cxLo = Math . max ( sx , Math . min ( sx + sw , Math . min ( cxLo , x ) ) ) ; cxHi = Math . max ( sx , Math . min ( sx + sw , Math . max ( cxHi , x ) ) ) ; return true ; } if ( x >= cxLo && x < cxHi ) { int dx = x - cx ; if ( dx < 0 ) for ( int f = cxLo - sx ; f < cxHi - sx ; f ++ ) copyData ( f , f + dx ) ; else for ( int f = cxHi - sx - 1 ; f >= cxLo - sx ; f -- ) copyData ( f , f + dx ) ; cx += dx ; cxLo = Math . max ( sx , Math . min ( sx + sw , cxLo + dx ) ) ; cxHi = Math . max ( sx , Math . min ( sx + sw , cxHi + dx ) ) ; isDamage = true ; return true ; } sxLo = Math . max ( sx , Math . min ( sx + sw , Math . min ( sxLo , x ) ) ) ; sxHi = Math . max ( sx , Math . min ( sx + sw , Math . max ( sxHi , x ) ) ) ; return true ; }
va	5	private void update ( DocumentEvent event ) { String newValue = "" ; try { Document doc = event . getDocument ( ) ; newValue = doc . getText ( 0 , doc . getLength ( ) ) ; } catch ( BadLocationException e ) { e . printStackTrace ( ) ; } if ( newValue . length ( ) > 0 ) { int index = targetList . getNextMatch ( newValue , 0 , Position . Bias . Forward ) ; if ( index < 0 ) { index = 0 ; } targetList . ensureIndexIsVisible ( index ) ; String matchedName = targetList . getModel ( ) . getElementAt ( index ) . toString ( ) ; if ( newValue . equalsIgnoreCase ( matchedName ) ) { if ( index != targetList . getSelectedIndex ( ) ) { SwingUtilities . invokeLater ( new ListSelector ( index ) ) ; } } } }
va	0	@ Override public String getKey ( ) { return id ; }
va	5	public static void main ( String [ ] args ) { try { String input = null , output = "out.s" ; for ( int i = 0 ; i < args . length ; i ++ ) { switch ( args [ i ] ) { case "-o" : i ++ ; output = args [ i ] ; break ; default : input = args [ i ] ; break ; } } if ( input == null ) { System . out . println ( "No input file provided" ) ; System . exit ( 1 ) ; } int [ ] code = DLXutil . readCode ( input ) ; FileWriter w = new FileWriter ( output ) ; for ( int i : code ) { w . write ( DLX . disassemble ( i ) ) ; } w . close ( ) ; System . exit ( 0 ) ; } catch ( Exception e ) { System . out . println ( "An error occured" ) ; System . exit ( - 1 ) ; } }
va	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( dlgAccesoSistema . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( dlgAccesoSistema . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( dlgAccesoSistema . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( dlgAccesoSistema . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { dlgAccesoSistema dialog = new dlgAccesoSistema ( new javax . swing . JFrame ( ) , true ) ; dialog . addWindowListener ( new java . awt . event . WindowAdapter ( ) { @ Override public void windowClosing ( java . awt . event . WindowEvent e ) { System . exit ( 0 ) ; } } ) ; dialog . setVisible ( true ) ; } } ) ; }
va	8	private ArrayList < Posicion > posicionesRadioUno ( Posicion posicion ) { ArrayList < Posicion > posiciones = new ArrayList < Posicion > ( ) ; Posicion pos = posicion . getSiguiente ( 1 ) ; if ( posicionValida ( pos ) ) posiciones . add ( pos ) ; pos = posicion . getSiguiente ( 5 ) ; if ( posicionValida ( pos ) ) posiciones . add ( pos ) ; pos = posicion . getSiguiente ( 4 ) ; if ( posicionValida ( pos ) ) posiciones . add ( pos ) ; pos = posicion . getSiguiente ( 7 ) ; if ( posicionValida ( pos ) ) posiciones . add ( pos ) ; pos = posicion . getSiguiente ( 11 ) ; if ( posicionValida ( pos ) ) posiciones . add ( pos ) ; pos = posicion . getSiguiente ( 15 ) ; if ( posicionValida ( pos ) ) posiciones . add ( pos ) ; pos = posicion . getSiguiente ( 14 ) ; if ( posicionValida ( pos ) ) posiciones . add ( pos ) ; pos = posicion . getSiguiente ( 13 ) ; if ( posicionValida ( pos ) ) posiciones . add ( pos ) ; return posiciones ; }
va	9	public List < UsuarioSistema > Buscar ( UsuarioSistema filtro ) throws ErroValidacaoException , Exception { try { String sql = "select p.id as Id_Pessoa Nome CPF RG " + "Data_Nascimento u.id as idusuario  Usuario from Pessoa " + "p inner join Usuarios_Sistema u on u.id_pessoa = p.id" ; String where = "" ; if ( ! filtro . getNome ( ) . isEmpty ( ) ) { where = "Nome like'%" + filtro . getNome ( ) + "%'" ; } if ( filtro . getCpf ( ) != 0 ) { if ( where . length ( ) > 0 ) { where = where + " AND " ; } where = where + " CPF = " + filtro . getCpf ( ) ; } if ( ! filtro . getRg ( ) . isEmpty ( ) ) { if ( where . length ( ) > 0 ) { where = where + " AND " ; } where = where + " RG = " + filtro . getRg ( ) ; } if ( ! filtro . getUsuario ( ) . isEmpty ( ) ) { if ( where . length ( ) > 0 ) { where = where + " AND " ; } where = where + " usuario = " + filtro . getUsuario ( ) ; } if ( filtro . getId ( ) != 0 ) { if ( where . length ( ) > 0 ) { where = where + " AND " ; } where = where + " Id_Usuario = " + filtro . getId ( ) ; } Statement comando = banco . getConexao ( ) . createStatement ( ) ; ResultSet consulta = comando . executeQuery ( sql ) ; comando . getConnection ( ) . commit ( ) ; List < UsuarioSistema > lista = null ; if ( consulta . first ( ) ) { lista = new LinkedList < > ( ) ; while ( consulta . next ( ) ) { UsuarioSistema tmp = new UsuarioSistema ( ) ; tmp . setCpf ( consulta . getInt ( "CPF" ) ) ; tmp . setDataNascimento ( consulta . getDate ( "Data_Nascimento" ) ) ; tmp . setNome ( consulta . getString ( "Nome" ) ) ; tmp . setId ( consulta . getInt ( "Id_Pessoa" ) ) ; tmp . setId ( consulta . getInt ( "IdUsuario" ) ) ; tmp . setRg ( consulta . getString ( "RG" ) ) ; tmp . setUsuario ( consulta . getString ( "Usuario" ) ) ; lista . add ( tmp ) ; } } return lista ; } catch ( SQLException ex ) { ex . printStackTrace ( ) ; return null ; } }
va	3	public static void agregarCuentasActivas ( ) { cuentasActivas = new String [ totalCuentasActivas ( ) ] ; configArchivoGerencia ( ) ; crearRandom ( ) ; int cont = 0 ; try { registros . seek ( 0 ) ; while ( registros . getFilePointer ( ) < registros . length ( ) ) { String c = registros . readUTF ( ) ; registros . readUTF ( ) ; boolean b = registros . readBoolean ( ) ; if ( b ) { cuentasActivas [ cont ] = c ; cont ++ ; } } registros . close ( ) ; } catch ( IOException ex ) { ex . printStackTrace ( ) ; } }
va	6	public char next ( ) throws JSONException { int c ; if ( this . usePrevious ) { this . usePrevious = false ; c = this . previous ; } else { try { c = this . reader . read ( ) ; } catch ( IOException exception ) { throw new JSONException ( exception ) ; } if ( c <= 0 ) { this . eof = true ; c = 0 ; } } this . index += 1 ; if ( this . previous == '' ) { this . line += 1 ; this . character = c == '' ? 0 : 1 ; } else if ( c == '' ) { this . line += 1 ; this . character = 0 ; } else { this . character += 1 ; } this . previous = ( char ) c ; return this . previous ; }
va	8	public static void keyTyped ( KeyEvent keyEvent ) { Iterator < PComponent > it = components . iterator ( ) ; while ( it . hasNext ( ) ) { PComponent comp = it . next ( ) ; if ( comp == null ) continue ; if ( shouldHandleKeys ) { if ( comp . shouldHandleKeys ( ) ) comp . keyTyped ( keyEvent ) ; } else { if ( comp instanceof PFrame ) { for ( PComponent component : ( ( PFrame ) comp ) . getComponents ( ) ) if ( component . forceKeys ( ) ) component . keyTyped ( keyEvent ) ; } else if ( comp . forceKeys ( ) ) comp . keyTyped ( keyEvent ) ; } } }
va	2	public boolean searchAnyField ( String search ) { for ( int i = 0 ; i < NUMBER_OF_FIELDS ; i ++ ) { if ( content [ i ] . toLowerCase ( ) . contains ( search . trim ( ) . toLowerCase ( ) ) ) { return true ; } } return false ; }
va	1	public static void main ( String [ ] args ) { for ( String url : section ) { byte [ ] bytes = url . getBytes ( ) ; encodeString ( bytes ) ; String encryped = new String ( bytes ) ; System . out . println ( decodeString ( encryped ) ) ; } }
va	8	public void validate ( ) throws org . apache . thrift . TException { if ( user == null ) { throw new org . apache . thrift . protocol . TProtocolException ( "Required field 'user' was not present! Struct: " + toString ( ) ) ; } if ( type == null ) { throw new org . apache . thrift . protocol . TProtocolException ( "Required field 'type' was not present! Struct: " + toString ( ) ) ; } if ( date == null ) { throw new org . apache . thrift . protocol . TProtocolException ( "Required field 'date' was not present! Struct: " + toString ( ) ) ; } if ( user != null ) { user . validate ( ) ; } if ( date != null ) { date . validate ( ) ; } if ( text != null ) { text . validate ( ) ; } if ( language != null ) { language . validate ( ) ; } if ( location != null ) { location . validate ( ) ; } }
va	3	public boolean addNewArtist ( ArtistInfoBean artistInfoBean ) { try { connection = new DatabaseConnection ( ) . getConnection ( ) ; String addTrack_Query = "INSERT into artistinfo (artistid  artistname)  VALUES (? ?)" ; PreparedStatement prepareStatement = connection . prepareStatement ( addTrack_Query ) ; prepareStatement . setString ( 1 , artistInfoBean . getArtist_id ( ) ) ; prepareStatement . setString ( 2 , artistInfoBean . getArtist_name ( ) ) ; boolean checkArtistId = checkArtistId ( artistInfoBean ) ; if ( checkArtistId ) { return true ; } else { int executeUpdate = prepareStatement . executeUpdate ( ) ; if ( executeUpdate > 0 ) { return true ; } else { return false ; } } } catch ( SQLException ex ) { Logger . getLogger ( ArtistInfo . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } return false ; }
va	5	protected void reindexFacesAndVertices ( ) { for ( int i = 0 ; i < numPoints ; i ++ ) { pointBuffer [ i ] . index = - 1 ; } numFaces = 0 ; for ( Iterator it = faces . iterator ( ) ; it . hasNext ( ) ; ) { Face face = ( Face ) it . next ( ) ; if ( face . mark != Face . VISIBLE ) { it . remove ( ) ; } else { markFaceVertices ( face , 0 ) ; numFaces ++ ; } } numVertices = 0 ; for ( int i = 0 ; i < numPoints ; i ++ ) { Vertex vtx = pointBuffer [ i ] ; if ( vtx . index == 0 ) { vertexPointIndices [ numVertices ] = i ; vtx . index = numVertices ++ ; } } }
va	4	public static double getPercentileOfValue ( Collection < ? extends Number > c , double value ) { Number [ ] array = c . toArray ( new Number [ c . size ( ) ] ) ; Arrays . sort ( array ) ; int index = - 1 ; for ( int i = 0 ; i < array . length && index < 0 ; i ++ ) { if ( value <= array [ i ] . doubleValue ( ) ) { index = i ; } } return 100.0 * index / ( c . size ( ) - 1 ) ; }
va	4	@ Override public void actionPerformed ( ActionEvent e ) { String lastSavePath = AppManager . getInstance ( ) . getUserPrefs ( ) . getLastPresetExportPath ( ) ; JFileChooser dialog = new JFileChooser ( lastSavePath ) ; dialog . setFileFilter ( new FileNameExtensionFilter ( "JSON File" , "json" ) ) ; int ret = dialog . showOpenDialog ( null ) ; if ( ret == JFileChooser . APPROVE_OPTION ) { File f = dialog . getSelectedFile ( ) ; PresetsCollection pc = new PresetsCollection ( ) ; boolean res = pc . loadFromJsonFile ( f ) ; if ( ! res ) { JOptionPane . showMessageDialog ( null , "Unable to import presets from JSON file." , "Error" , JOptionPane . ERROR_MESSAGE ) ; } else { ret = JOptionPane . showConfirmDialog ( null , "Do you want to append the presets (no for replace)?" , "Append/Override" , JOptionPane . YES_NO_CANCEL_OPTION ) ; if ( ret == JOptionPane . YES_OPTION ) { AppManager . getInstance ( ) . getPresets ( ) . appendPresets ( pc ) ; } else if ( ret == JOptionPane . NO_OPTION ) { AppManager . getInstance ( ) . getPresets ( ) . replacePresets ( pc ) ; } AppManager . getInstance ( ) . getUserPrefs ( ) . setLastPresetExportPath ( f . getParent ( ) ) ; } } }
va	3	public void addVertices ( final List < IColumnVector < float >> vertices , final List < Map < String , Object >> attributes , final int index ) { if ( vertices == null ) { throw new NullPointerException ( "'vertices' must not be 'null'" ) ; } if ( attributes == null ) { throw new NullPointerException ( "'attributes' must not be 'null'" ) ; } if ( index >= vertices . size ( ) ) { throw new IndexOutOfBoundsException ( "'index' must not be greater than amount of polygon vertices" ) ; } this . vertices . addAll ( index , vertices ) ; this . attributes . addAll ( index , attributes ) ; calcNonConvexPoints ( ) ; kong ( ) ; }
va	8	public Player2ColorSelectMenu ( Game game , JFrame frame , int stateToNotShow ) { super ( game , frame ) ; this . stateToNotShow = stateToNotShow ; this . setLayout ( new BoxLayout ( this , BoxLayout . Y_AXIS ) ) ; header = new JLabel ( "    Player 2: Choose Color" ) ; header . setFont ( smallFont ) ; blackButton = new JButton ( "Black" ) ; blackButton . addActionListener ( new blackButtonListener ( ) ) ; blackButton . setFont ( largeFont ) ; blueButton = new JButton ( "Blue" ) ; blueButton . addActionListener ( new blueButtonListener ( ) ) ; blueButton . setFont ( largeFont ) ; magentaButton = new JButton ( "Magenta" ) ; magentaButton . addActionListener ( new magentaButtonListener ( ) ) ; magentaButton . setFont ( largeFont ) ; brownButton = new JButton ( "Brown" ) ; brownButton . addActionListener ( new brownButtonListener ( ) ) ; brownButton . setFont ( largeFont ) ; pinkButton = new JButton ( "Pink" ) ; pinkButton . addActionListener ( new pinkButtonListener ( ) ) ; pinkButton . setFont ( largeFont ) ; redButton = new JButton ( "Red" ) ; redButton . addActionListener ( new redButtonListener ( ) ) ; redButton . setFont ( largeFont ) ; yellowButton = new JButton ( "Yellow" ) ; yellowButton . addActionListener ( new yellowButtonListener ( ) ) ; yellowButton . setFont ( largeFont ) ; if ( game . getGameMode ( ) == 1 ) { nameInst = new JLabel ( "Enter Player 2 name:" ) ; } else { nameInst = new JLabel ( "Enter Computer name:" ) ; } nameInst . setFont ( smallFont ) ; nameText = new JTextField ( "Player 2" ) ; nameText . setFont ( smallFont ) ; nameText . setFocusable ( true ) ; nameText . requestFocus ( ) ; this . add ( header ) ; if ( stateToNotShow != 1 ) { this . add ( redButton ) ; } if ( stateToNotShow != 2 ) { this . add ( yellowButton ) ; } if ( stateToNotShow != 4 ) { this . add ( blackButton ) ; } if ( stateToNotShow != 5 ) { this . add ( blueButton ) ; } if ( stateToNotShow != 6 ) { this . add ( magentaButton ) ; } if ( stateToNotShow != 7 ) { this . add ( brownButton ) ; } if ( stateToNotShow != 8 ) { this . add ( pinkButton ) ; } this . add ( nameInst ) ; this . add ( nameText ) ; }
va	0	public List < StateKeyboard > getStatesKeyboard ( ) { return statesKeyboards ; }
va	2	public KyuremW ( ) { baseHealth = 125 ; baseAttack = 120 ; baseDefense = 90 ; baseSpecialAttack = 170 ; baseSpecialDefense = 100 ; baseSpeed = 95 ; natureAtk = 1.0 ; natureDef = 1.0 ; natureSpa = 1.0 ; natureSdf = 1.0 ; natureSpeed = 1.0 ; IVHP = 31 ; IVATK = 31 ; IVDEF = 31 ; IVSPA = 31 ; IVSPD = 31 ; IVSPEED = 31 ; EVHP = 6 ; EVATK = 0 ; EVDEF = 0 ; EVSPA = 252 ; EVSDF = 0 ; EVSPEED = 252 ; statBoostATK = 1 ; statBoostDEF = 1 ; statBoostSPA = 1 ; statBoostSDF = 1 ; statBoostSPEED = 1 ; level = 100 ; finalHp = ( int ) ( ( ( ( IVHP + ( 2 * baseHealth ) + ( EVHP / 4 ) ) * level ) / 100 ) + 10 ) ; finalAtk = ( int ) ( ( ( ( ( IVATK + ( 2 * baseAttack ) + ( EVATK / 4 ) ) * level ) / 100 ) + 5 ) * natureAtk ) ; finalDef = ( int ) ( ( ( ( ( IVDEF + ( 2 * baseDefense ) + ( EVDEF / 4 ) ) * level ) / 100 ) + 5 ) * natureDef ) ; finalSpa = ( int ) ( ( ( ( ( IVSPA + ( 2 * baseSpecialAttack ) + ( EVSPA / 4 ) ) * level ) / 100 ) + 5 ) * natureSpa ) ; finalSdf = ( int ) ( ( ( ( ( IVSPD + ( 2 * baseSpecialDefense ) + ( EVSDF / 4 ) ) * level ) / 100 ) + 5 ) * natureSdf ) ; finalSpeed = ( int ) ( ( ( ( ( IVSPEED + ( 2 * baseSpeed ) + ( EVSPEED / 4 ) ) * level ) / 100 ) + 5 ) * natureSpeed ) ; name = "Kyurem-W" ; primary = new Dragon ( ) ; secondary = new Ice ( ) ; moveLibrary = new HashMap < String , Move > ( ) ; Move m1 = new DragonPulse ( ) ; Move m2 = new FocusBlast ( ) ; Move m3 = new EarthPower ( ) ; Move m4 = new FusionFlare ( ) ; Move m5 = new IceBeam ( ) ; Move m6 = new Blizzard ( ) ; Move m7 = new ShadowBall ( ) ; Move m8 = new DracoMeteor ( ) ; moveLibrary . put ( "dragon pulse" , m1 ) ; moveLibrary . put ( "focus blast" , m2 ) ; moveLibrary . put ( "earth power" , m3 ) ; moveLibrary . put ( "fusion flare" , m4 ) ; moveLibrary . put ( "ice beam" , m5 ) ; moveLibrary . put ( "blizzard" , m6 ) ; moveLibrary . put ( "shadow ball" , m7 ) ; moveLibrary . put ( "draco meteor" , m8 ) ; potentials = new ArrayList < String > ( ) ; potentials . add ( "dragon pulse" ) ; potentials . add ( "focus blast" ) ; potentials . add ( "earth power" ) ; potentials . add ( "fusion flare" ) ; potentials . add ( "ice beam" ) ; potentials . add ( "blizzard" ) ; potentials . add ( "shadow ball" ) ; potentials . add ( "draco meteor" ) ; circumvent = new ArrayList < String > ( ) ; battleReady = new HashMap < String , Move > ( ) ; for ( int i = 0 ; i < 4 ; i ++ ) { int randomIndex = ( int ) ( Math . random ( ) * potentials . size ( ) ) ; String key = potentials . get ( randomIndex ) ; while ( circumvent . contains ( key ) ) { int nextRandom = ( int ) ( Math . random ( ) * potentials . size ( ) ) ; key = potentials . get ( nextRandom ) ; } battleReady . put ( key , moveLibrary . get ( key ) ) ; circumvent . add ( key ) ; } }
va	0	public int getCurrentDefence ( ) { return this . currentDefence ; }
va	2	@ Override public int fitness ( EvolvingProblemSet < CharArrayWrapper , BooleanWrapper > problemSet ) { AUTOMATON obj = getObj ( ) ; int c = 0 ; int i = 0 ; for ( CharArrayWrapper problem : problemSet . getProblemSet ( ) ) { State state = null ; state = obj . process ( problem . getData ( ) ) ; boolean isAccepting = obj . isAcceptingState ( state ) ; if ( problemSet . checkSolution ( problem , new BooleanWrapper ( isAccepting ) ) ) { c ++ ; } i ++ ; } return c ; }
va	9	static Object less ( Object subtree , Object elt , int ehash ) { if ( subtree == null ) return null ; else if ( ! ( subtree instanceof Node ) ) { Object [ ] ary = ( Object [ ] ) subtree ; int bin_srch_res = binarySearch ( ary , ehash ) ; int found = bin_srch_res & BIN_SEARCH_FOUND_MASK ; int idx = bin_srch_res >> BIN_SEARCH_INDEX_SHIFT ; if ( found == BIN_SEARCH_FOUND ) { Object e = ary [ idx ] ; if ( eql ( elt , e ) ) return remove ( ary , idx ) ; else return subtree ; } else return subtree ; } else { Node node = ( Node ) subtree ; Object nelt = node . element ; int nhash = node . ehash ; if ( ehash == nhash ) { if ( ! ( nelt instanceof EquivalentSet ) ) { if ( ! eql ( elt , nelt ) ) return subtree ; else return join ( node . left , node . right ) ; } else { Object diff = equivDiff ( nelt , elt ) ; return buildNode ( diff , ehash , node . left , node . right ) ; } } else if ( ehash < nhash ) { Object new_left = less ( node . left , elt , ehash ) ; if ( new_left == node . left ) return subtree ; else return buildNode ( nelt , nhash , new_left , node . right ) ; } else { Object new_right = less ( node . right , elt , ehash ) ; if ( new_right == node . right ) return subtree ; else return buildNode ( nelt , nhash , node . left , new_right ) ; } } }
va	5	@ Override public boolean execute ( final CommandSender sender , final String [ ] split ) { if ( sender instanceof Player ) { if ( MonsterIRC . getHandleManager ( ) . getPermissionsHandler ( ) != null ) { if ( ! MonsterIRC . getHandleManager ( ) . getPermissionsHandler ( ) . hasCommandPerms ( ( Player ) sender , this ) ) { sender . sendMessage ( "[IRC] You don't have permission to preform that command." ) ; return true ; } } else { sender . sendMessage ( "[IRC] PEX not detected  unable to run any IRC commands." ) ; return true ; } } if ( split . length <= 2 ) { sender . sendMessage ( "Invalid usage!" ) ; sender . sendMessage ( "Type /help raw for more help!" ) ; return true ; } final StringBuffer result = new StringBuffer ( ) ; for ( int i = 2 ; i < split . length ; i ++ ) { result . append ( split [ i ] ) ; result . append ( " " ) ; } IRC . sendRawLine ( result . toString ( ) ) ; IRC . log ( result . toString ( ) ) ; sender . sendMessage ( ColorUtils . BLUE . getMinecraftColor ( ) + "Raw message sent!" ) ; return true ; }
va	6	private void findPrograms ( ) { Instrument [ ] theinstruments = synth . getAvailableInstruments ( ) ; int i = 0 ; for ( i = 0 ; i < theinstruments . length ; i ++ ) { if ( i > 127 ) break ; String program = new String ( theinstruments [ i ] . toString ( ) ) ; if ( program . startsWith ( "Drum" ) ) { continue ; } if ( program . startsWith ( "Instrument: " ) ) { program = program . substring ( 11 ) ; } int pos = program . indexOf ( "bank" ) ; if ( pos > 0 ) { program = program . substring ( 0 , pos - 1 ) ; } GMPrograms . add ( Integer . toString ( i + 1 ) + ": " + program ) ; } for ( ; i < 128 ; i ++ ) { GMPrograms . add ( Integer . toString ( i + 1 ) ) ; } }
va	7	public void cluster ( ) { if ( graph == null ) { this . graph = new Graph ( ) ; for ( DataPoint point : data ) { graph . addVertex ( new Node ( point ) ) ; } } numFeatures = 0 ; for ( Node node : graph . getVertices ( ) ) { DataPoint datapoint = node . getDataPoint ( ) ; if ( useVirtualLocations ) numFeatures = node . getLocationVector ( ) . size ( ) ; else numFeatures = datapoint . getFeatures ( ) . size ( ) ; break ; } double bestFitness = 0 ; int bestK = 0 ; for ( int k = 2 ; k <= maxK ; k ++ ) { this . k = k ; runCluster ( ) ; try { double fitness = fitnessEvaluation . getFitness ( clusters ) ; if ( fitness > bestFitness ) { bestFitness = fitness ; bestK = k ; } } catch ( Exception e ) { break ; } } this . k = bestK ; runCluster ( ) ; double fitness = fitnessEvaluation . getFitness ( clusters ) ; }
va	6	public static void normalizeSize ( Geometry g ) { double v [ ] [ ] = g . vertices ; for ( int j = 0 ; j < 3 ; j ++ ) { lo [ j ] = HUGE ; hi [ j ] = - HUGE ; } for ( int n = 0 ; n < v . length ; n ++ ) for ( int j = 0 ; j < 3 ; j ++ ) { lo [ j ] = Math . min ( lo [ j ] , v [ n ] [ j ] ) ; hi [ j ] = Math . max ( hi [ j ] , v [ n ] [ j ] ) ; } double radius = 0.5 * Math . max ( hi [ 0 ] - lo [ 0 ] , Math . max ( hi [ 1 ] - lo [ 1 ] , hi [ 2 ] - lo [ 2 ] ) ) ; for ( int j = 0 ; j < 3 ; j ++ ) avg [ j ] = ( lo [ j ] + hi [ j ] ) / 2 ; for ( int n = 0 ; n < v . length ; n ++ ) for ( int j = 0 ; j < 3 ; j ++ ) g . vertices [ n ] [ j ] = ( g . vertices [ n ] [ j ] - avg [ j ] ) / radius ; }
va	0	@ Override public Area getNextSibling ( ) { return ( Area ) getNextSiblingNode ( ) ; }
va	0	public Ast ( CC4Parser archivo ) throws Exception { miParser = archivo . Parser ( ) ; miParser . reset ( ) ; tree = miParser . start ( ) ; treeString = new String ( tree . toStringTree ( miParser ) ) ; AstVisitor visitor = new AstVisitor ( ) ; root = ( Root ) visitor . visit ( tree ) ; }
va	9	public CgiArguments ( String uriQuery ) { System . out . println ( uriQuery ) ; String [ ] params = uriQuery . split ( "&" ) ; for ( String param : params ) { String [ ] keyval = param . split ( "=" , 2 ) ; if ( keyval . length < 2 ) { continue ; } String key = keyval [ 0 ] . toLowerCase ( ) ; String val = keyval [ 1 ] ; if ( key . equals ( "query" ) ) { _query = val ; } else if ( key . equals ( "num" ) ) { try { _numResults = Integer . parseInt ( val ) ; } catch ( NumberFormatException e ) { } } else if ( key . equals ( "ranker" ) ) { try { _rankerType = RankerType . valueOf ( val . toUpperCase ( ) ) ; } catch ( IllegalArgumentException e ) { } } else if ( key . equals ( "format" ) ) { try { _outputFormat = OutputFormat . valueOf ( val . toUpperCase ( ) ) ; } catch ( IllegalArgumentException e ) { } } else if ( key . equals ( "numdocs" ) ) { try { _numdocs = Integer . parseInt ( val ) ; } catch ( IllegalArgumentException e ) { } } else if ( key . equals ( "numterms" ) ) { try { _numterms = Integer . parseInt ( val ) ; } catch ( IllegalArgumentException e ) { } } } }
va	2	@ Override public long getLong ( long i ) { if ( ptr != 0 ) { return ( long ) ( Utilities . UNSAFE . getFloat ( ptr + sizeof * i ) ) ; } else { if ( isConstant ( ) ) { return ( long ) data [ 0 ] ; } else { return ( long ) data [ ( int ) i ] ; } } }
va	4	@ Override public Object mutation ( Object genotype ) { if ( ! ( genotype instanceof String ) ) { try { throw new Exception ( genotype . getClass ( ) . getSimpleName ( ) + "not a string! Input type: " + genotype . getClass ( ) . getSimpleName ( ) ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } String genotypeString = ( String ) genotype ; Random rand = new Random ( ) ; int mutatedBit = rand . nextInt ( genotypeString . length ( ) ) ; char [ ] genoArray = genotypeString . toCharArray ( ) ; if ( genoArray [ mutatedBit ] == 1 ) genoArray [ mutatedBit ] = 0 ; else genoArray [ mutatedBit ] = 1 ; String newGenotype = "" ; for ( int i = 0 ; i < genoArray . length ; i ++ ) { newGenotype += genoArray [ i ] ; } return newGenotype ; }
va	4	@ Override public int hashCode ( ) { int result = novCedula != null ? novCedula . hashCode ( ) : 0 ; result = 31 * result + ( novCodigoConcepto != null ? novCodigoConcepto . hashCode ( ) : 0 ) ; result = 31 * result + ( novUnidad != null ? novUnidad . hashCode ( ) : 0 ) ; result = 31 * result + ( novAaaamm != null ? novAaaamm . hashCode ( ) : 0 ) ; return result ; }
va	1	private void printSpaces ( int num ) { String s = "" ; for ( int i = 0 ; i < num ; i ++ ) { s +=   ; } System . out . print ( s ) ; }
va	3	public boolean putNextSample ( int channels , SynthesisFilter filter1 , SynthesisFilter filter2 ) throws MpegAudioDecodeException { if ( allocation != 0 ) { sample = FP . mul ( sample , factor ) + offset ; if ( channels == OutputChannels . BOTH_CHANNELS ) { int sample1 = FP . mul ( sample , scalefactor ) ; int sample2 = FP . mul ( sample , channel2_scalefactor ) ; filter1 . input_sample ( sample1 , subbandnumber ) ; filter2 . input_sample ( sample2 , subbandnumber ) ; } else if ( channels == OutputChannels . LEFT_CHANNEL ) { int sample1 = FP . mul ( sample , scalefactor ) ; filter1 . input_sample ( sample1 , subbandnumber ) ; } else { int sample2 = FP . mul ( sample , channel2_scalefactor ) ; filter1 . input_sample ( sample2 , subbandnumber ) ; } } return true ; }
va	8	public void initContentPanel ( ) { JPanel panel = new JPanel ( ) ; scrollContentPane = new JScrollPane ( panel ) ; scrollContentPane . setBounds ( 0 , 0 , 500 , 660 ) ; scrollContentPane . getVerticalScrollBar ( ) . setUnitIncrement ( 20 ) ; int i = 0 ; for ( final File file : files ) { boolean includeFlag = false ; for ( String include : this . include . split ( SEPERATED_SYMBOL ) ) { if ( file . getAbsolutePath ( ) . endsWith ( include . trim ( ) ) ) { includeFlag = true ; break ; } } if ( ! includeFlag ) { continue ; } boolean nonIncludeFlag = false ; for ( String nonInclude : this . nonInclude . split ( SEPERATED_SYMBOL ) ) { if ( file . getAbsolutePath ( ) . contains ( nonInclude . trim ( ) ) ) { nonIncludeFlag = true ; break ; } } if ( nonIncludeFlag ) { continue ; } final JCheckBox checkBox = new JCheckBox ( ) ; final JButton fileButton = new JButton ( file . getName ( ) ) ; if ( i % 2 == 0 ) { fileButton . setBackground ( Color . GRAY ) ; } else { fileButton . setBackground ( Color . WHITE ) ; } checkBox . setSize ( 50 , 50 ) ; fileButton . setSize ( 380 , 20 ) ; fileButton . setToolTipText ( file . getAbsolutePath ( ) ) ; fileButton . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { new PageSourceCounter ( file ) ; } } ) ; Box fileBox = Box . createHorizontalBox ( ) ; JLabel index = new JLabel ( ) ; index . setText ( String . valueOf ( i + 1 ) ) ; fileBox . add ( index ) ; fileBox . add ( checkBox ) ; fileBox . add ( fileButton ) ; fileBox . setBackground ( Color . GRAY ) ; panel . add ( fileBox ) ; final Map < Integer , String > map = new HashMap < Integer , String > ( ) ; CheckedCache . cache . add ( new FileCheckbox ( file , checkBox , map ) ) ; i ++ ; } panel . setLayout ( new GridLayout ( i , 1 ) ) ; contentPanel = new JPanel ( ) ; contentPanel . setBounds ( 0 , 0 , 500 , 670 ) ; contentPanel . setBackground ( new Color ( 77 , 195 , 239 ) ) ; contentPanel . setLayout ( null ) ; contentPanel . add ( scrollContentPane ) ; this . add ( contentPanel ) ; }
va	6	private void drawWeaponFrame ( Graphics2D g2d , Player player , Weapon w , BufferedImage brbt ) { FontMetrics metrics = g2d . getFontMetrics ( ) ; int x = ( int ) ( this . weaponFrames . get ( w . getName ( ) ) . get ( 0 ) . x + 18 ) ; int y = ( int ) ( this . weaponFrames . get ( w . getName ( ) ) . get ( 0 ) . y + 17.2 ) ; g2d . drawImage ( brbt , x , y , null ) ; g2d . setColor ( Color . WHITE ) ; g2d . drawString ( w . getName ( ) , ( x + 58 ) , ( y + 12 ) ) ; g2d . drawString ( ( "Automatic? " + ( ( w . isAutomatic ( ) ) ? "Yes" : "No" ) ) , ( x + 58 ) , ( y + 26 ) ) ; g2d . drawString ( ( "Capacity: " + w . getMaxAmmo ( ) ) , ( x + 58 ) , ( y + 40 ) ) ; String pS = "Purchase : $" + w . getWeaponPrice ( ) ; Rectangle2D . double purchase = this . weaponFrames . get ( w . getName ( ) ) . get ( 1 ) ; if ( ! player . hasWeapon ( w . getName ( ) ) && ( player . getCash ( ) >= w . getWeaponPrice ( ) ) ) g2d . setColor ( new Color ( 8 , 84 , 22 ) ) ; else g2d . setColor ( Color . DARK_GRAY ) ; g2d . fill ( purchase ) ; g2d . setColor ( Color . BLACK ) ; g2d . draw ( purchase ) ; g2d . setColor ( Color . WHITE ) ; g2d . drawString ( pS , ( int ) ( ( purchase . x + ( purchase . width / 2 ) ) - ( metrics . stringWidth ( pS ) / 2 ) ) , ( int ) ( ( purchase . y + ( purchase . height / 2 ) ) + ( ( metrics . getHeight ( ) / 2 ) - 3 ) ) ) ; String bS = "Buy Ammo: $" + w . getAmmoPrice ( ) ; Rectangle2D . double buyAmmo = this . weaponFrames . get ( w . getName ( ) ) . get ( 2 ) ; if ( player . hasWeapon ( w . getName ( ) ) && ! w . ammoFull ( ) && ( player . getCash ( ) >= w . getAmmoPrice ( ) ) ) g2d . setColor ( new Color ( 8 , 84 , 22 ) ) ; else g2d . setColor ( Color . DARK_GRAY ) ; g2d . fill ( buyAmmo ) ; g2d . setColor ( Color . BLACK ) ; g2d . draw ( buyAmmo ) ; g2d . setColor ( Color . WHITE ) ; g2d . drawString ( bS , ( int ) ( ( buyAmmo . x + ( buyAmmo . width / 2 ) ) - ( metrics . stringWidth ( bS ) / 2 ) ) , ( int ) ( ( buyAmmo . y + ( buyAmmo . height / 2 ) ) + ( ( metrics . getHeight ( ) / 2 ) - 3 ) ) ) ; }
va	6	public void update ( Observable o , Object arg ) { labelUpdate ( ) ; if ( model . getState ( ) . equals ( State . GAMEOVER ) && ! newGameButtonCard . isVisible ( ) ) { int choise = JOptionPane . showConfirmDialog ( null , "Do you want to restart?" , "GAME OVER" , JOptionPane . YES_NO_OPTION , 0 , new ImageIcon ( getClass ( ) . getResource ( "/images/boom.png" ) ) ) ; if ( choise == 0 ) { restart ( ) ; } else { CardLayout tmp = ( CardLayout ) buttonCardPanel . getLayout ( ) ; tmp . show ( buttonCardPanel , "newGame" ) ; } } else if ( model . getState ( ) . equals ( State . FINISHED ) && ! nextLevelButtonCard . isVisible ( ) ) { int choise = JOptionPane . showConfirmDialog ( null , "Start level " + ( model . getLevel ( ) + 1 ) + "?" , "Level " + model . getLevel ( ) + " cleared!" , JOptionPane . YES_NO_OPTION , 0 , new ImageIcon ( getClass ( ) . getResource ( "/images/win.png" ) ) ) ; if ( choise == 0 ) { model . nextLevel ( ) ; board . renewBoard ( this ) ; } else { CardLayout tmp = ( CardLayout ) buttonCardPanel . getLayout ( ) ; tmp . show ( buttonCardPanel , "continue" ) ; } } labelUpdate ( ) ; }
va	7	public static < C extends Collection < E > , E > FunctionExecutor < C > createGet ( final FeatureDefinition < ? extends Property < ? extends C >> propertyDefinition , final CriteriumMatcher < E > matcher ) { return new FunctionExecutor < C > ( ) { @ SuppressWarnings ( "unchecked" ) @ Override public C invoke ( FunctionInvocation < C > invocation , Object ... arguments ) throws ExecutorInvocationException { C originalCollection = invocation . getHolder ( ) . get ( propertyDefinition ) . get ( ) ; Collection < E > collection = new ArrayList < E > ( ) ; for ( E element : originalCollection ) { if ( matcher . matches ( element , arguments ) ) { collection . add ( element ) ; } } if ( originalCollection instanceof List ) { return ( C ) Collections . unmodifiableList ( new ArrayList < E > ( collection ) ) ; } else if ( originalCollection instanceof Set ) { return ( C ) Collections . unmodifiableSet ( new HashSet < E > ( collection ) ) ; } else if ( originalCollection instanceof SortedSet ) { return ( C ) Collections . unmodifiableSortedSet ( new TreeSet < E > ( collection ) ) ; } else { return ( C ) Collections . unmodifiableCollection ( collection ) ; } } } ; }
va	6	public boolean getBoolean ( String key ) throws JSONException { Object object = this . get ( key ) ; if ( object . equals ( boolean . false ) || ( object instanceof String && ( ( String ) object ) . equalsIgnoreCase ( "false" ) ) ) { return false ; } else if ( object . equals ( boolean . true ) || ( object instanceof String && ( ( String ) object ) . equalsIgnoreCase ( "true" ) ) ) { return true ; } throw new JSONException ( "JSONObject[" + quote ( key ) + "] is not a Boolean." ) ; }
va	4	public void run ( ) { init ( ) ; long start , elapsed , wait ; while ( GlobalController . running ) { if ( GlobalController . headless ) { update ( ) ; } else { start = System . nanoTime ( ) ; update ( ) ; draw ( ) ; drawToScreen ( ) ; elapsed = System . nanoTime ( ) - start ; wait = targetTime - elapsed / 1000000 ; if ( wait < 0 ) wait = 5 ; try { Thread . sleep ( wait ) ; } catch ( InterruptedException e ) { } } } }
va	5	public void run ( ) { m_mpegControl . start ( ) ; }
va	7	static String getNextIP ( ) { int high , low ; synchronized ( counter ) { do { do { high = ( counter >> 8 ) & 00FF ; if ( high < 10 || high > 200 ) { counter += 256 ; } } while ( high < 10 ) ; low = counter & 00FF ; counter ++ ; } while ( high < 10 || high > 200 || low < 10 || low > 200 ) ; } return "127.0." + high + "." + low ; }
va	1	private void close ( boolean restart ) { bot . close ( ) ; if ( ! restart ) { dispose ( ) ; bots . remove ( bot ) ; return ; } }
va	9	public Set < String > getCommonStructures ( DataHolder dataholderHandler ) { Set < String > PSTags = new HashSet < String > ( Arrays . asList ( "s p" . split ( " " ) ) ) ; Set < String > BTags = new HashSet < String > ( ) ; BTags . add ( "b" ) ; Set < String > PSWords = dataholderHandler . getWordsFromWordPOSByPOSs ( PSTags ) ; Set < String > BWords = dataholderHandler . getWordsFromWordPOSByPOSs ( BTags ) ; Set < String > allStructures = StringUtility . setSubtraction ( PSWords , BWords ) ; Set < String > commonTags = new HashSet < String > ( ) ; Map < String , Set < String >> tagToModifiers = new HashMap < String , Set < String >> ( ) ; for ( SentenceStructure sentenceItem : dataholderHandler . getSentenceHolder ( ) ) { String tag = sentenceItem . getTag ( ) ; String modifier = sentenceItem . getModifier ( ) ; boolean c1 = StringUtils . equals ( tag , "ignore" ) ; boolean c2 = ( tag == null ) ; boolean c3 = StringUtility . isMatchedNullSafe ( tag , " " ) ; boolean c4 = StringUtility . isMatchedNullSafe ( tag , "\\[" ) ; if ( ( ! c1 || c2 ) && ! c3 && ! c4 ) { if ( allStructures . contains ( modifier ) ) { if ( tagToModifiers . containsKey ( tag ) ) { tagToModifiers . get ( tag ) . add ( modifier ) ; } else { HashSet < String > modifiers = new HashSet < String > ( ) ; modifiers . add ( modifier ) ; tagToModifiers . put ( tag , modifiers ) ; } } } } Iterator < String > iter = tagToModifiers . keySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { String key = iter . next ( ) ; if ( tagToModifiers . get ( key ) . size ( ) > 1 ) { String commonTag = new String ( key ) ; commonTag = commonTag . replaceAll ( "\\|+" , "\\|" ) ; commonTag = commonTag . replaceAll ( "\\|+$" , "" ) ; commonTags . add ( key ) ; } } return commonTags ; }
va	1	public char charValue ( ) throws OtpErlangRangeException { final long l = longValue ( ) ; final char i = ( char ) l ; if ( i != l ) { throw new OtpErlangRangeException ( "Value too large for char: " + val ) ; } return i ; }
va	4	public void pit ( int cx , int cy , int cz ) { int x = cx / 64 ; int y = cy / 64 ; for ( int j = 3 ; j < 10 ; j ++ ) { if ( r . nextInt ( j ) == 0 ) { int vx = r . nextInt ( j ) - j / 2 ; int vy = r . nextInt ( j ) - j / 2 ; Point p = point ( x + vx , y + vy ) ; if ( types [ type [ p . x ] [ p . y ] ] . g ( "pit" ) . equals ( "yes" ) && levels [ p . x ] [ p . y ] > 0 ) { levels [ p . x ] [ p . y ] -- ; type [ p . x ] [ p . y ] = ( byte ) types [ type [ p . x ] [ p . y ] ] . gi ( "next" ) ; } } } }
va	5	public boolean searchMatrix ( int [ ] [ ] matrix , int target ) { if ( matrix . length == 0 || matrix [ 0 ] . length == 0 ) { return false ; } int xLength = matrix [ 0 ] . length ; int min = 0 ; int max = matrix [ 0 ] . length * matrix . length - 1 ; int y , x , current ; while ( min <= max ) { current = ( min + max ) / 2 ; x = current / xLength ; y = current % xLength ; if ( matrix [ x ] [ y ] == target ) { return true ; } else if ( target < matrix [ x ] [ y ] ) { max = current - 1 ; } else { min = current + 1 ; } } return false ; }
va	5	public LoginScreen ( JPanel panel , DriverlessCar mainLayout ) { contentPane = panel ; setOpaque ( true ) ; setBackground ( Color . gray . brighter ( ) ) ; submitButton = new JButton ( "Log in" ) ; submitButton . setFont ( new Font ( "Sans Serif" , Font . BOLD , 30 ) ) ; JPanel loginForm = new JPanel ( new GridLayout ( 7 , 1 , 0 , 15 ) ) ; loginForm . setPreferredSize ( new Dimension ( 600 , 700 ) ) ; loginForm . setBackground ( Color . gray . brighter ( ) ) ; userLabel = new JLabel ( "User ID" ) ; userField = new JTextField ( ) ; passwordLabel = new JLabel ( "Password" ) ; passwordField = new JPasswordField ( ) ; userLabel . setFont ( new Font ( "Sans Serif" , Font . BOLD , 48 ) ) ; userField . setFont ( new Font ( "Sans Serif" , Font . PLAIN , 48 ) ) ; userField . setForeground ( Color . BLUE ) ; passwordLabel . setFont ( new Font ( "Sans Serif" , Font . BOLD , 48 ) ) ; passwordField . setFont ( new Font ( "Sans Serif" , Font . PLAIN , 48 ) ) ; passwordField . setForeground ( Color . BLUE ) ; passwordField . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { char pw [ ] = { t , e , s , t } ; char userEnter [ ] = passwordField . getPassword ( ) ; if ( Arrays . equals ( userEnter , pw ) ) { userField . setText ( "" ) ; passwordField . setText ( "" ) ; CardLayout cardLayout = ( CardLayout ) contentPane . getLayout ( ) ; cardLayout . invalidateLayout ( contentPane ) ; cardLayout . show ( contentPane , "Main Menu" ) ; } else { JOptionPane . showMessageDialog ( null , "Please enter in your correct User ID and Password." , "Wrong Credentials" , JOptionPane . ERROR_MESSAGE ) ; } } } ) ; JPanel title = new JPanel ( new GridLayout ( 2 , 0 ) ) ; title . setBackground ( Color . gray . brighter ( ) ) ; JLabel t2 = new JLabel ( "(TEST DEPLOYMENT: Username=test  Password=test)" , JLabel . CENTER ) ; t2 . setFont ( new Font ( "Sans Serif" , Font . BOLD , 14 ) ) ; title . add ( new JLabel ( "Please enter your credentials." , JLabel . CENTER ) ) ; title . add ( t2 ) ; keyboard = new JPanel ( new GridLayout ( 4 , 0 ) ) ; final JButton tab = new JButton ( "TAB" ) ; keyboard . add ( tab ) ; enter = new JButton ( "ENTER" ) ; enter . setActionCommand ( "Enter" ) ; enter . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { passwordField . setText ( "test" ) ; passwordField . requestFocusInWindow ( ) ; try { Robot robot = new Robot ( ) ; robot . delay ( 1000 ) ; robot . keyPress ( KeyEvent . VK_ENTER ) ; } catch ( AWTException a ) { a . printStackTrace ( ) ; } } } ) ; for ( int i = 0 ; i <= 25 ; i ++ ) { final String temp = "" + keystrokes . charAt ( i ) ; JButton btn = new JButton ( temp ) ; btn . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { if ( e . getSource ( ) != enter ) { String actionCommand = e . getActionCommand ( ) . toLowerCase ( ) ; userField . setText ( userField . getText ( ) + actionCommand ) ; } } } ) ; keyboard . add ( btn ) ; keyboard . add ( enter ) ; } loginForm . add ( title ) ; loginForm . add ( userLabel ) ; loginForm . add ( userField ) ; loginForm . add ( passwordLabel ) ; loginForm . add ( passwordField ) ; loginForm . add ( submitButton ) ; loginForm . add ( keyboard ) ; submitButton . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { char pw [ ] = { t , e , s , t } ; char userEnter [ ] = passwordField . getPassword ( ) ; if ( Arrays . equals ( userEnter , pw ) ) { userField . setText ( "" ) ; passwordField . setText ( "" ) ; CardLayout cardLayout = ( CardLayout ) contentPane . getLayout ( ) ; cardLayout . invalidateLayout ( contentPane ) ; cardLayout . show ( contentPane , "Main Menu" ) ; } else { JOptionPane . showMessageDialog ( null , "Please enter in your correct User ID and Password." , "Wrong Credentials" , JOptionPane . ERROR_MESSAGE ) ; } } } ) ; add ( loginForm ) ; }
va	6	public String asString ( ) throws TBlogException { if ( null == responseAsString ) { BufferedReader br ; try { InputStream stream = asStream ( ) ; if ( null == stream ) { return null ; } br = new BufferedReader ( new InputStreamReader ( stream , "UTF-8" ) ) ; StringBuffer buf = new StringBuffer ( ) ; String line ; while ( null != ( line = br . readLine ( ) ) ) { buf . append ( line ) . append ( "\n" ) ; } this . responseAsString = buf . toString ( ) ; if ( Configuration . isDalvik ( ) ) { this . responseAsString = unescape ( responseAsString ) ; } stream . close ( ) ; con . disconnect ( ) ; streamConsumed = true ; } catch ( NullPointerException npe ) { throw new TBlogException ( npe . getMessage ( ) , npe ) ; } catch ( IOException ioe ) { throw new TBlogException ( ioe . getMessage ( ) , ioe ) ; } } log ( responseAsString ) ; return responseAsString ; }
va	0	@ Override public void pickInitial ( PvPickEvent pos ) { TensorTerm term = m_tensorPanel . createTerm ( pos . getVertex ( ) ) ; m_field . addTerm ( term ) ; m_tensorPanel . setTerm ( term ) ; }
va	6	static int fullHouse ( int [ ] player ) { int [ ] valueCount = new int [ 13 ] ; for ( int i = 0 ; i < 5 ; i ++ ) valueCount [ player [ i ] / 4 ] ++ ; int three = 13 ; int two = 13 ; for ( int i = 0 ; i < 13 ; i ++ ) { if ( valueCount [ i ] == 3 ) three = i ; if ( valueCount [ i ] == 2 ) two = i ; } if ( three < 13 && two < 13 ) return three * 13 + two ; else return - 1 ; }
va	4	public String generateContent ( ) { File dir = new File ( "C:\\tmp\\test_data\\" ) ; if ( ! dir . exists ( ) ) dir . mkdir ( ) ; else { if ( isFirst ) { File [ ] files = dir . listFiles ( ) ; for ( int i = 0 ; i < files . length ; i ++ ) { files [ i ] . delete ( ) ; } dir . delete ( ) ; dir . mkdir ( ) ; isFirst = false ; } } try { File f = File . createTempFile ( "att." , ".pdf" , dir ) ; FileOutputStream fos = new FileOutputStream ( f ) ; EnglishStringContentDef cd = new EnglishStringContentDef ( ) ; cd . setMaxSize ( 200 ) ; Document document = new Document ( ) ; PdfWriter . getInstance ( document , fos ) ; document . open ( ) ; document . add ( new Paragraph ( cd . generateContent ( ) ) ) ; document . close ( ) ; return f . getName ( ) ; } catch ( Exception e ) { Logger l = Logger . getLogger ( PdfFile . class ) ; l . error ( "caught exception" , e ) ; System . out . println ( "caught exception: " + e . getMessage ( ) ) ; } return "" ; }
va	5	private boolean zzRefill ( ) throws java . io . IOException { if ( zzStartRead > 0 ) { System . arraycopy ( zzBuffer , zzStartRead , zzBuffer , 0 , zzEndRead - zzStartRead ) ; zzEndRead -= zzStartRead ; zzCurrentPos -= zzStartRead ; zzMarkedPos -= zzStartRead ; zzStartRead = 0 ; } if ( zzCurrentPos >= zzBuffer . length ) { char newBuffer [ ] = new char [ zzCurrentPos * 2 ] ; System . arraycopy ( zzBuffer , 0 , newBuffer , 0 , zzBuffer . length ) ; zzBuffer = newBuffer ; } int numRead = zzReader . read ( zzBuffer , zzEndRead , zzBuffer . length - zzEndRead ) ; if ( numRead > 0 ) { zzEndRead += numRead ; return false ; } if ( numRead == 0 ) { int c = zzReader . read ( ) ; if ( c == - 1 ) { return true ; } else { zzBuffer [ zzEndRead ++ ] = ( char ) c ; return false ; } } return true ; }
va	2	public String monsterAttack ( Player p ) { StringBuffer s = new StringBuffer ( ) ; for ( Monster m : monsters ) { if ( ! m . isDead ( ) ) { s . append ( m . getName ( ) ) ; s . append ( " attacks  " ) ; s . append ( m . attack ( p ) ) ; } } return s . toString ( ) ; }
va	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( FormCliente . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( FormCliente . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( FormCliente . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( FormCliente . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { new FormCliente ( ) . setVisible ( true ) ; } } ) ; }
va	8	@ Override public void write ( int theByte ) throws java . io . IOException { if ( suspendEncoding ) { this . out . write ( theByte ) ; return ; } if ( encode ) { buffer [ position ++ ] = ( byte ) theByte ; if ( position >= bufferLength ) { this . out . write ( encode3to4 ( b4 , buffer , bufferLength , options ) ) ; lineLength += 4 ; if ( breakLines && lineLength >= MAX_LINE_LENGTH ) { this . out . write ( NEW_LINE ) ; lineLength = 0 ; } position = 0 ; } } else { if ( decodabet [ theByte & 7f ] > WHITE_SPACE_ENC ) { buffer [ position ++ ] = ( byte ) theByte ; if ( position >= bufferLength ) { int len = Base64 . decode4to3 ( buffer , 0 , b4 , 0 , options ) ; out . write ( b4 , 0 , len ) ; position = 0 ; } } else if ( decodabet [ theByte & 7f ] != WHITE_SPACE_ENC ) { throw new java . io . IOException ( "Invalid character in Base64 data." ) ; } } }
va	7	private void preencherCampos ( ) { ArrayList < String > telefones ; ArrayList < Premiacao > premiacoes ; jTextFieldAltura . setText ( double . toString ( piloto . getAltura ( ) ) ) ; jTextFieldBairro . setText ( piloto . getEndereco ( ) . getBairro ( ) ) ; jTextFieldCategoriaPeso . setText ( double . toString ( piloto . getPeso ( ) ) ) ; jTextFieldCep . setText ( piloto . getEndereco ( ) . getCep ( ) ) ; jTextFieldCidade . setText ( piloto . getEndereco ( ) . getCidade ( ) ) ; jTextFieldComplemento . setText ( piloto . getEndereco ( ) . getComplemento ( ) ) ; jTextFieldCpf . setText ( piloto . getCpf ( ) ) ; if ( piloto . getDataNascimento ( ) == null ) { jTextFieldDataNascimento . setText ( null ) ; } else { jTextFieldDataNascimento . setText ( dateFormat . format ( piloto . getDataNascimento ( ) ) ) ; } jComboBoxEstado . setSelectedItem ( piloto . getEndereco ( ) . getEstado ( ) ) ; jTextFieldLogradouro . setText ( piloto . getEndereco ( ) . getLogradouro ( ) ) ; jTextFieldNome . setText ( piloto . getNome ( ) ) ; jTextFieldNomeMae . setText ( piloto . getNomeMae ( ) ) ; jTextFieldNomePai . setText ( piloto . getNomePai ( ) ) ; jTextFieldNumero . setText ( piloto . getEndereco ( ) . getNumero ( ) . toString ( ) ) ; jTextFieldPais . setText ( piloto . getEndereco ( ) . getPais ( ) ) ; jTextFieldPeso . setText ( double . toString ( piloto . getPeso ( ) ) ) ; jTextFieldRg . setText ( piloto . getRg ( ) ) ; telefonesListModel . clear ( ) ; telefones = piloto . getTelefones ( ) ; for ( String t : telefones ) { telefonesListModel . addElement ( t ) ; } premiacaoListModel . clear ( ) ; premiacoes = piloto . getPremiacoes ( ) ; for ( Premiacao p : premiacoes ) { premiacaoListModel . addElement ( p ) ; } switch ( piloto . getSexo ( ) ) { case SEXO_MASCULINO_VALOR : jComboBoxSexo . setSelectedIndex ( SEXO_MASCULINO_INDICE ) ; break ; case SEXO_FEMININO_VALOR : jComboBoxSexo . setSelectedIndex ( SEXO_FEMININO_INDICE ) ; break ; } switch ( piloto . getCategoria ( ) ) { case CATEGORIA_AMADOR_VALOR : jComboBoxCategoria . setSelectedIndex ( CATEGORIA_AMADOR_INDICE ) ; break ; case CATEGORIA_PROFISSIONAL_VALOR : jComboBoxCategoria . setSelectedIndex ( CATEGORIA_PROFISSIONAL_INDICE ) ; break ; } this . atualizarCategoriaPeso ( ) ; }
va	6	public Object getParameter ( String key ) { if ( key . contains ( GameSocketServer . BLACKHAND_KEY ) ) return blackhand ; if ( key . contains ( GameSocketServer . SURRENDER_KEY ) ) return surrender ; if ( key . contains ( GameSocketServer . TEAMS ) ) return teams ; if ( key . contains ( GameSocketServer . CARD_SWAP ) ) return cardswap ; if ( key . contains ( BriscaGameFactory . TOURNAMENT_GAME ) ) return tournament ; if ( key . contains ( GameSocketServer . LIFECARD_KEY ) ) return life ; return null ; }
va	8	private void controlarPartida ( AplJogo apl ) { String aviso = "" ; while ( ! apl . isSairPartida ( ) ) { if ( aviso == "" ) cli . atualizar ( apl . getTabuleiro ( ) , apl . getJogadorBrancas ( ) , apl . getJogadorPretas ( ) ) ; else cli . atualizar ( apl . getTabuleiro ( ) , apl . getJogadorBrancas ( ) , apl . getJogadorPretas ( ) , aviso ) ; aviso = "" ; Jogada jogada = null ; if ( apl . getJogadorTurnoAtual ( ) . getTipoJogador ( ) == TipoJogador . PESSOA ) { jogada = acaoRealizadaPessoa ( apl ) ; if ( jogada != null ) if ( apl . getTabuleiro ( ) . jogadaSuicida ( jogada , apl . getJogadorTurnoAtual ( ) . getCor ( ) ) ) { cli . exibirAlerta ( "Rei se encontra amea\u00E7ado" ) ; jogada = null ; } } else { jogada = acaoRealizadaMaquina ( apl ) ; } if ( jogada != null ) { try { apl . executarJogadaTurno ( jogada ) ; apl . trocarTurno ( ) ; } catch ( JogadaInvalidaException e ) { aviso = e . getMessage ( ) ; } catch ( CasaOcupadaException e ) { aviso = e . getMessage ( ) ; } } } encerrarPartida ( apl ) ; }
va	0	public void queuePlayerJoinedForSend ( Player p ) { queueForSend ( new PlayerJoinedCmd ( p , p . getName ( ) . compareTo ( player . getName ( ) ) == 0 ) ) ; }
va	2	public void createMosquitos ( int n ) { mosquitos = new HashSet < Mosquito > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { Point2D p = new Point2D . double ( 1 + GameConfig . random . nextDouble ( ) * 98 , 1 + GameConfig . random . nextDouble ( ) * 98 ) ; while ( collidesWithWall ( p ) ) p = new Point2D . double ( 1 + GameConfig . random . nextDouble ( ) * 98 , 1 + GameConfig . random . nextDouble ( ) * 98 ) ; mosquitos . add ( new Mosquito ( p ) ) ; } }
va	4	@ Override public String execute ( ) { try { if ( ( databaseContext . table != null ) && databaseContext . table . getName ( ) . equals ( arguments . get ( 1 ) ) ) { databaseContext . table = null ; } databaseContext . provider . removeTable ( arguments . get ( 1 ) ) ; return "dropped" ; } catch ( IllegalStateException e ) { return arguments . get ( 1 ) + " not exists" ; } catch ( IOException e ) { return e . getMessage ( ) ; } }
va	2	@ Override public JSONObject getJson ( ) throws JSONException { JSONObject json = new JSONObject ( ) ; json . put ( "name" , name ) ; json . put ( "value" , value ) ; json . put ( "groupName" , groupName ) ; JSONArray jHappenings = new JSONArray ( ) ; for ( Happening happening : happenings ) { jHappenings . put ( happening . getJson ( ) ) ; } json . put ( "happenings" , jHappenings ) ; json . put ( "lastUpdateDate" , lastUppdateDate . getTimeInMillis ( ) ) ; JSONArray jMilestones = new JSONArray ( ) ; for ( MileStone milestone : mMilestones ) { jMilestones . put ( milestone . getJson ( ) ) ; } json . put ( "milestones" , jMilestones ) ; json . put ( "kurs" , kurs ) ; json . put ( "antal" , antal ) ; json . put ( "uppdateringsUrl" , uppdateringsUrl . toString ( ) ) ; json . put ( "class" , "AktiePost" ) ; return json ; }
va	8	public Jogada escolherJogada ( TabuleiroXadrez tabuleiroAtual ) throws CasaOcupadaException , JogadaInvalidaException { List < NoArvore > listaNos = new ArrayList < NoArvore > ( ) ; NoArvore raiz = new NoArvore ( this . cor , this . nivel , new Estado ( null , tabuleiroAtual ) ) ; List < Jogada > possivelJogada = new ArrayList < Jogada > ( ) ; if ( ! raiz . isXequeMate ( ) ) { listaNos . add ( raiz ) ; inicio = System . currentTimeMillis ( ) ; boolean atingiuTempoMaximo = false ; for ( int camada = 1 ; camada <= ALCANCE_MAQUINA && atingiuTempoMaximo == false ; camada ++ ) { try { listaNos = criaCamada ( listaNos ) ; long fim = System . currentTimeMillis ( ) ; if ( ( fim - inicio ) / 1000 > this . TEMPO_MAXIMO ) atingiuTempoMaximo = true ; } catch ( InterruptedException e ) { return suporte ( tabuleiroAtual ) ; } } inserirValorFolhas ( listaNos ) ; RealizaBusca busca = new RealizaBusca ( ) ; busca . buscaEmProfundidade ( raiz ) ; for ( int indice = 1 ; indice < raiz . getListaAdjacencia ( ) . size ( ) ; indice ++ ) if ( raiz . getValor ( ) == raiz . getListaAdjacencia ( ) . get ( indice ) . getValor ( ) ) { possivelJogada . add ( raiz . getListaAdjacencia ( ) . get ( indice ) . getEstado ( ) . getJogada ( ) ) ; } } else { return null ; } if ( ! possivelJogada . isEmpty ( ) ) { Random random = new Random ( ) ; return possivelJogada . get ( random . nextInt ( possivelJogada . size ( ) ) ) ; } else { return suporte ( tabuleiroAtual ) ; } }
va	5	public void handle ( int token , int start , int end , IJavaElement owner ) throws JavaModelException { boolean collapseComments = FoldingPlugin . getPrefs ( ) . getBoolean ( PreferenceKeys . COLLAPSE_COMMENT_BLOCKS ) ; boolean collapseJavadoc = FoldingPlugin . getPrefs ( ) . getBoolean ( PreferenceKeys . COLLAPSE_JAVADOCS ) ; switch ( token ) { case ITerminalSymbols . TokenNameLBRACE : { pushBrace ( start ) ; helper . end ( ) ; break ; } case ITerminalSymbols . TokenNameRBRACE : { if ( hasUsablePeer ( ) ) { int oldStart = popBrace ( ) ; helper . end ( ) ; if ( shouldFold ( owner , token ) ) { boolean doCollapse = shouldCollapse ( owner , token ) ; boolean shouldNegate = shouldFilterLastLine ( owner , token ) ; addRegion ( new EnhancedPosition ( oldStart , end - oldStart , new JavaPositionMetadata ( false , shouldNegate , doCollapse , true , getClass ( ) . getName ( ) ) ) ) ; } } else { System . out . println ( "Bad brace found... omitting!" ) ; } break ; } default : { if ( digestComments ) helper . handle ( token , start , end , owner ) ; } } }
va	5	public void ban ( final String nick , final String channel ) { if ( this . isConnected ( ) ) { try { IRCClient client ; if ( ( client = IRC . getChannel ( channel ) . getUser ( nick ) ) != null ) { if ( client . getHostmask ( ) != null ) { if ( ! client . getHostmask ( ) . equalsIgnoreCase ( "" ) ) { this . kick ( nick , channel , "Bye." ) ; this . write ( "MODE " + channel + " +b " + client . getHostmask ( ) ) ; return ; } } } this . kick ( nick , channel , "Bye." ) ; this . write ( "MODE " + channel + " +b " + nick ) ; } catch ( final IOException e ) { IRC . debug ( e ) ; } } }
va	7	public void processMouseReleased ( int x , int y ) { if ( state == PoseurState . COMPLETE_SHAPE_STATE ) { Rectangle2D poseArea = zoomableCanvasState . getPoseArea ( ) ; float zoomLevel = zoomableCanvasState . getZoomLevel ( ) ; int poseSpaceX = ( int ) ( ( x - poseArea . getX ( ) ) / zoomLevel ) ; int poseSpaceY = ( int ) ( ( y - poseArea . getY ( ) ) / zoomLevel ) ; lastMouseDraggedX = x ; lastMouseDraggedY = y ; if ( ( poseSpaceX < 0 ) || ( poseSpaceY < 0 ) || ( poseSpaceX > poseArea . getWidth ( ) ) || ( poseSpaceY > poseArea . getHeight ( ) ) ) { setState ( PoseurState . CREATE_SHAPE_STATE ) ; shapeInProgress = null ; return ; } if ( ! shapeInProgress . completesValidShape ( poseSpaceX , poseSpaceY ) ) { shapeInProgress = null ; setState ( PoseurState . CREATE_SHAPE_STATE ) ; } else { pose . addShape ( shapeInProgress ) ; selectedShape = shapeInProgress ; shapeInProgress = null ; setState ( PoseurState . CREATE_SHAPE_STATE ) ; repaintCanvases ( ) ; } } else if ( state == PoseurState . DRAG_SHAPE_STATE ) { setState ( PoseurState . SHAPE_SELECTED_STATE ) ; } }
va	4	private void localAreaKeyReleased ( java . awt . event . KeyEvent evt ) { int selRow = translateTable . getSelectedRow ( ) ; if ( selRow != - 1 && evt . getKeyCode ( ) != KeyEvent . VK_ENTER ) { tableModel . setValueAt ( localArea . getText ( ) , translateTable . getSelectedRow ( ) , 2 ) ; } if ( selRow != - 1 && evt . getKeyCode ( ) == KeyEvent . VK_ENTER ) { localArea . setText ( localArea . getText ( ) . trim ( ) ) ; } }
va	8	@ Override public String getGenreDescription ( ) { ID3v2TextFrameData frameData = extractTextFrameData ( obseleteFormat ? ID_GENRE_OBSELETE : ID_GENRE ) ; if ( frameData == null || frameData . getText ( ) == null ) { return null ; } String text = frameData . getText ( ) . toString ( ) ; if ( text != null ) { int genreNum = getGenre ( text ) ; if ( genreNum >= 0 && genreNum < ID3v1Genres . GENRES . length ) { return ID3v1Genres . GENRES [ genreNum ] ; } else { String description = extractGenreDescription ( text ) ; if ( description != null && description . length ( ) > 0 ) { return description ; } } } return null ; }
va	6	boolean parseIgnore ( String ignoreFile ) { String line = null ; BufferedReader in = null ; Pattern p = null ; try { in = new BufferedReader ( new FileReader ( ignoreFile ) ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; return false ; } mIgnoreList = new ArrayList < Pattern > ( ) ; do { try { line = in . readLine ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } if ( line == null ) { break ; } try { p = Pattern . compile ( line ) ; } catch ( PatternSyntaxException e ) { e . printStackTrace ( ) ; return false ; } if ( p != null ) { mIgnoreList . add ( p ) ; } } while ( line != null ) ; return true ; }
va	8	public void assembleFile ( ) { File source = null ; File outputExe = null ; JFileChooser chooser = new JFileChooser ( sourceDir ) ; FileNameExtensionFilter filter = new FileNameExtensionFilter ( "Pippin Source Files" , "pips" ) ; chooser . setFileFilter ( filter ) ; int openOK = chooser . showOpenDialog ( null ) ; if ( openOK == JFileChooser . APPROVE_OPTION ) { source = chooser . getSelectedFile ( ) ; } if ( source != null && source . exists ( ) ) { sourceDir = source . getAbsolutePath ( ) ; sourceDir = sourceDir . replace ( \ , / ) ; int lastDot = sourceDir . lastIndexOf ( . ) ; String outName = sourceDir . substring ( 0 , lastDot + 1 ) + "pipe" ; int lastSlash = sourceDir . lastIndexOf ( / ) ; sourceDir = sourceDir . substring ( 0 , lastSlash + 1 ) ; outName = outName . substring ( lastSlash + 1 ) ; filter = new FileNameExtensionFilter ( "Pippin Executable Files" , "pipe" ) ; if ( executableDir . equals ( eclipseDir ) ) { chooser = new JFileChooser ( sourceDir ) ; } else { System . out . println ( executableDir ) ; System . out . println ( outName ) ; chooser = new JFileChooser ( executableDir ) ; } chooser . setFileFilter ( filter ) ; chooser . setSelectedFile ( new File ( outName ) ) ; int saveOK = chooser . showSaveDialog ( null ) ; if ( saveOK == JFileChooser . APPROVE_OPTION ) { outputExe = chooser . getSelectedFile ( ) ; } if ( outputExe != null ) { executableDir = outputExe . getAbsolutePath ( ) ; executableDir = executableDir . replace ( \ , / ) ; lastSlash = executableDir . lastIndexOf ( / ) ; executableDir = executableDir . substring ( 0 , lastSlash + 1 ) ; try { properties . setProperty ( "SourceDirectory" , sourceDir ) ; properties . setProperty ( "ExecutableDirectory" , executableDir ) ; properties . store ( new FileOutputStream ( "propertyfile.txt" ) , "File locations" ) ; } catch ( Exception e ) { System . out . println ( "Error writing properties file" ) ; } if ( Assembler . assembleFile ( source , outputExe ) ) { JOptionPane . showMessageDialog ( frame , "The source was assembled to an executable" , "Success" , JOptionPane . INFORMATION_MESSAGE ) ; } } else { JOptionPane . showMessageDialog ( frame , "The output file has problems.\n" + "Cannot assemble the program" , "Warning" , JOptionPane . OK_OPTION ) ; } } else { JOptionPane . showMessageDialog ( frame , "The source file has problems.\n" + "Cannot assemble the program" , "Warning" , JOptionPane . OK_OPTION ) ; } }
va	6	private static boolean method496 ( char c ) { return c >=   && c <=  || c ==   || c == '' || c == 	 || c == £ || c == € ; }
