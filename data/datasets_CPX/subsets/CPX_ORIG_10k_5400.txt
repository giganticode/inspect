tr	7	@ Override public int hashCode ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + ( ( addressLine1 == null ) ? 0 : addressLine1 . hashCode ( ) ) ; result = prime * result + ( ( city == null ) ? 0 : city . hashCode ( ) ) ; result = prime * result + ( ( country == null ) ? 0 : country . hashCode ( ) ) ; result = prime * result + ( ( emailAddress == null ) ? 0 : emailAddress . hashCode ( ) ) ; result = prime * result + ( ( phoneNumber == null ) ? 0 : phoneNumber . hashCode ( ) ) ; result = prime * result + ( ( postalCode == null ) ? 0 : postalCode . hashCode ( ) ) ; result = prime * result + ( ( province == null ) ? 0 : province . hashCode ( ) ) ; return result ; }
tr	8	public void setPos ( ChessPosition pos ) { if ( state != GameState . PLAYING ) { System . out . println ( "finish game: " + state ) ; return ; } if ( isChooseForMove ( pos ) ) { if ( board . getPiece ( pos ) == 0 ) return ; oldPos = pos ; newPos = null ; updatePosCanMove ( ) ; } else if ( oldPos != null ) { boolean validPos = false ; for ( ChessPosition posCM : posCanMove ) { if ( posCM . getRow ( ) == pos . getRow ( ) && posCM . getCol ( ) == pos . getCol ( ) ) { validPos = true ; break ; } } if ( validPos == false ) return ; newPos = pos ; this . move ( oldPos , newPos ) ; } }
tr	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( CadAluno . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( CadAluno . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( CadAluno . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( CadAluno . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { CadAluno dialog = new CadAluno ( new javax . swing . JFrame ( ) , true ) ; dialog . addWindowListener ( new java . awt . event . WindowAdapter ( ) { @ Override public void windowClosing ( java . awt . event . WindowEvent e ) { System . exit ( 0 ) ; } } ) ; dialog . setVisible ( true ) ; } } ) ; }
tr	0	public int numberOfPhotosBelongingTo ( ) { return this . photosInAlbum . size ( ) ; }
tr	5	public List < Point > getWinningMovesForPattern ( int matchPattern , int matchCount , int emptyIndicator , int [ ] [ ] board ) { List < Point > result = new ArrayList < Point > ( ) ; for ( int i = 0 ; i < board . length ; i ++ ) { for ( int j = 0 ; j < board [ i ] . length ; j ++ ) { if ( board [ i ] [ j ] == emptyIndicator ) { int oldSymbol = board [ i ] [ j ] ; board [ i ] [ j ] = matchPattern ; if ( findPatternsEqualTo ( matchPattern , matchCount , board ) . size ( ) > 0 ) { Point newPoint = new Point ( j , i ) ; if ( ! result . contains ( newPoint ) ) { result . add ( newPoint ) ; } } board [ i ] [ j ] = oldSymbol ; } } } return result ; }
tr	7	@ Override public YamlPermissionBase get ( PermissionType type , UUID uuid ) throws DataLoadFailedException { switch ( type ) { case USER : return getUser ( uuid ) ; case GROUP : return getGroup ( uuid ) ; case WORLD : return getWorld ( uuid ) ; case ENTITY : return getEntity ( uuid ) ; case OP : return getOP ( ) ; case CONSOLE : return getConsole ( ) ; case RCON : return getRcon ( ) ; default : return null ; } }
tr	9	public boolean simulate ( ) { if ( change_angle != 0 || force ) { angle += change_angle * rotateSpeed ; direction [ 0 ] = - Math . sin ( angle ) ; direction [ 1 ] = Math . cos ( angle ) ; if ( angle > Math . PI ) angle -= Math . PI * 2 ; if ( angle < - Math . PI ) angle += Math . PI * 2 ; } if ( change_speed != 0 || force ) { speed += change_speed * acc ; if ( speed > maxSpeed ) speed = maxSpeed ; if ( speed < - maxSpeed ) speed = - maxSpeed ; } else { if ( speed != 0 ) { if ( Math . abs ( speed ) <= stopAcc * 1.5 ) { speed = 0 ; immediateUpdate = true ; } else if ( speed < 0 ) speed += stopAcc ; else { speed -= stopAcc ; } } } vector [ 0 ] += direction [ 0 ] * speed ; vector [ 1 ] += direction [ 1 ] * speed ; force = false ; return true ; }
tr	2	public String toString ( ) { return "CREATE " + ( temporary ? "TEMPORARY " : "" ) + "TABLE " + ( exists ? "IF NOT EXISTS " : "" ) + name ; }
tr	4	private Nodo buscarNodo ( String padre ) { Nodo tmp1 = this . raiz ; Nodo tmp2 = tmp1 ; StringTokenizer path = new StringTokenizer ( padre , "/" ) ; String s ; while ( path . hasMoreTokens ( ) ) { s = path . nextToken ( ) ; while ( tmp1 != null ) { if ( s . equals ( tmp1 . dato ) ) break ; else { tmp2 = tmp1 = tmp1 . primerHijo ; } } if ( tmp1 == null ) return tmp1 ; else { tmp2 = tmp1 ; tmp1 = tmp1 . siguienteHermano ; } } return tmp2 ; }
tr	4	public synchronized void move ( double dx , double dy ) { x += dx ; y += dy ; Rectangle r1 = getBounds ( ) ; if ( x < 0 ) x = 2 ; else if ( ( x + r1 . width ) >= FileIconsWindow . WIDTH ) { x = FileIconsWindow . WIDTH - r1 . width - 2 ; } if ( y < 0 ) y = 2 ; else if ( ( y + r1 . height ) >= FileIconsWindow . HEIGHT ) { y = FileIconsWindow . HEIGHT - r1 . height - 2 ; } }
tr	0	public void setId ( Integer id ) { this . id = id ; }
tr	7	public DeviceGUI ( ) { setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; setBounds ( 100 , 100 , 544 , 402 ) ; contentPane = new JPanel ( ) ; contentPane . setBorder ( new EmptyBorder ( 5 , 5 , 5 , 5 ) ) ; setContentPane ( contentPane ) ; contentPane . setLayout ( null ) ; JPanel panel = new JPanel ( ) ; panel . setBounds ( 0 , 0 , 542 , 373 ) ; contentPane . add ( panel ) ; panel . setLayout ( null ) ; JLabel lblAddNewDevice = new JLabel ( "Add new Device" ) ; lblAddNewDevice . setFont ( new Font ( "Dialog" , Font . BOLD , 16 ) ) ; lblAddNewDevice . setBounds ( 188 , 12 , 169 , 15 ) ; panel . add ( lblAddNewDevice ) ; JLabel lblDeviceName = new JLabel ( "Device Name:" ) ; lblDeviceName . setBounds ( 12 , 55 , 125 , 15 ) ; panel . add ( lblDeviceName ) ; txt_D_name = new JTextField ( ) ; txt_D_name . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { update . update ( nameTBL , "devicename" , txt_D_name . getText ( ) , nameID , currentID ) ; } } ) ; txt_D_name . setBounds ( 167 , 53 , 265 , 19 ) ; panel . add ( txt_D_name ) ; txt_D_name . setColumns ( 10 ) ; txt_D_price = new JTextField ( ) ; txt_D_price . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { update . update ( nameTBL , "unitprice" , txt_D_price . getText ( ) , nameID , currentID ) ; } } ) ; txt_D_price . setColumns ( 10 ) ; txt_D_price . setBounds ( 167 , 82 , 265 , 19 ) ; panel . add ( txt_D_price ) ; JLabel lblUnitPrice = new JLabel ( "Unit Price" ) ; lblUnitPrice . setBounds ( 12 , 84 , 125 , 15 ) ; panel . add ( lblUnitPrice ) ; JLabel lblDeviceType = new JLabel ( "Device Type:" ) ; lblDeviceType . setBounds ( 12 , 229 , 125 , 15 ) ; panel . add ( lblDeviceType ) ; JLabel lblProducer = new JLabel ( "Producer:" ) ; lblProducer . setBounds ( 12 , 260 , 125 , 15 ) ; panel . add ( lblProducer ) ; JButton btn_D_first = new JButton ( "<<" ) ; btn_D_first . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { result = query . query ( nameTBL , 1 , nameID ) ; insertValues ( result ) ; currentID = 1 ; } } ) ; btn_D_first . setBounds ( 8 , 299 , 54 , 25 ) ; panel . add ( btn_D_first ) ; JButton btn_D_back = new JButton ( "<" ) ; btn_D_back . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { if ( currentID > 1 ) { currentID -- ; result = query . query ( nameTBL , currentID , nameID ) ; while ( result [ 1 ] == null ) { currentID -- ; result = query . query ( nameTBL , currentID , nameID ) ; } insertValues ( result ) ; } } } ) ; btn_D_back . setBounds ( 62 , 299 , 54 , 25 ) ; panel . add ( btn_D_back ) ; JButton btn_D_forward = new JButton ( ">" ) ; btn_D_forward . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { currentID ++ ; if ( currentID > 1 && currentID <= maxID ) { result = query . query ( nameTBL , currentID , nameID ) ; while ( result [ 1 ] == null && currentID <= maxID ) { currentID ++ ; result = query . query ( nameTBL , currentID , nameID ) ; } insertValues ( result ) ; } } } ) ; btn_D_forward . setBounds ( 114 , 299 , 54 , 25 ) ; panel . add ( btn_D_forward ) ; JButton btn_D_last = new JButton ( ">>" ) ; btn_D_last . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { while ( currentID < maxID ) { currentID ++ ; } result = query . query ( nameTBL , currentID , nameID ) ; insertValues ( result ) ; } } ) ; btn_D_last . setBounds ( 169 , 299 , 54 , 25 ) ; panel . add ( btn_D_last ) ; JButton btn_D_new = new JButton ( "New" ) ; btn_D_new . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { currentID = maxID + 1 ; frame . txt_D_name . setText ( "" ) ; frame . txt_D_name . requestFocusInWindow ( ) ; frame . txt_D_desc . setText ( "" ) ; frame . txt_D_price . setText ( "" ) ; } } ) ; btn_D_new . setBounds ( 224 , 299 , 70 , 25 ) ; panel . add ( btn_D_new ) ; JButton btn_D_save = new JButton ( "Save" ) ; btn_D_save . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { newValues [ 0 ] = "" + txt_D_name . getText ( ) ; newValues [ 1 ] = "" + txt_D_desc . getText ( ) ; newValues [ 2 ] = "" + txt_D_price . getText ( ) ; insert . insert ( nameTBL , nameTxtF , newValues ) ; update . updateFK ( nameTBL , devicetFK , cbx_device . getSelectedIndex ( ) , "devicetype_ID" , currentID ) ; update . updateFK ( nameTBL , producerFK , cbx_producer . getSelectedIndex ( ) , "producer_ID" , currentID ) ; maxID = query . maxID ( nameTBL , nameID ) ; } } ) ; btn_D_save . setBounds ( 292 , 299 , 68 , 25 ) ; panel . add ( btn_D_save ) ; JButton btn_D_del = new JButton ( "Del" ) ; btn_D_del . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { delete . delete ( nameTBL , nameID , currentID ) ; } } ) ; btn_D_del . setBounds ( 362 , 299 , 70 , 25 ) ; panel . add ( btn_D_del ) ; JLabel lblDescription = new JLabel ( "Description" ) ; lblDescription . setBounds ( 12 , 115 , 125 , 15 ) ; panel . add ( lblDescription ) ; txt_D_desc = new JTextArea ( ) ; txt_D_desc . setBounds ( 167 , 113 , 265 , 101 ) ; panel . add ( txt_D_desc ) ; int lengthDev = query . maxID ( devT , "Devicetype_ID" ) ; String [ ] cbx_d_values = new String [ lengthDev ] ; cbx_d_values = query . queryColumn ( devT , "name" , lengthDev ) ; DefaultComboBoxModel < String > model = new DefaultComboBoxModel ( cbx_d_values ) ; cbx_device = new JComboBox ( model ) ; cbx_device . addItemListener ( new ItemListener ( ) { public void itemStateChanged ( ItemEvent e ) { update . updateFK ( nameTBL , devicetFK , cbx_device . getSelectedIndex ( ) , "device_ID" , currentID ) ; } } ) ; cbx_device . setBounds ( 167 , 224 , 265 , 24 ) ; panel . add ( cbx_device ) ; int lengthProd = query . maxID ( producer , "producer_ID" ) ; String [ ] cbx_p_values = new String [ lengthProd ] ; cbx_p_values = query . queryColumn ( producer , "name" , lengthProd ) ; DefaultComboBoxModel < String > modelPro = new DefaultComboBoxModel ( cbx_p_values ) ; cbx_producer = new JComboBox ( modelPro ) ; cbx_producer . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { update . updateFK ( nameTBL , producerFK , cbx_producer . getSelectedIndex ( ) , "producer_ID" , currentID ) ; } } ) ; cbx_producer . setBounds ( 167 , 255 , 265 , 24 ) ; panel . add ( cbx_producer ) ; JButton btnAddDeviceType = new JButton ( "Device Type" ) ; btnAddDeviceType . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { DeviceTypeGUI dtGui = new DeviceTypeGUI ( ) ; dtGui . openDeviceTypeGUI ( ) ; } } ) ; btnAddDeviceType . setBounds ( 18 , 336 , 169 , 25 ) ; panel . add ( btnAddDeviceType ) ; JButton btnNewProducer = new JButton ( "Producer" ) ; btnNewProducer . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { ProducerGUI pGui = new ProducerGUI ( ) ; pGui . openProducerGUI ( ) ; frame . revalidate ( ) ; frame . repaint ( ) ; } } ) ; btnNewProducer . setBounds ( 199 , 336 , 169 , 25 ) ; panel . add ( btnNewProducer ) ; setDefaultCloseOperation ( WindowConstants . DISPOSE_ON_CLOSE ) ; }
tr	8	public static boolean hasAtLeastOneMethodWithName ( class < ? > clazz , String methodName ) { assert . notNull ( clazz , "Class must not be null" ) ; assert . notNull ( methodName , "Method name must not be null" ) ; Method [ ] declaredMethods = clazz . getDeclaredMethods ( ) ; for ( Method method : declaredMethods ) { if ( method . getName ( ) . equals ( methodName ) ) { return true ; } } class < ? > [ ] ifcs = clazz . getInterfaces ( ) ; for ( class < ? > ifc : ifcs ) { if ( hasAtLeastOneMethodWithName ( ifc , methodName ) ) { return true ; } } return ( clazz . getSuperclass ( ) != null && hasAtLeastOneMethodWithName ( clazz . getSuperclass ( ) , methodName ) ) ; }
tr	1	public static void main ( String [ ] args ) { Font font = new Font ( "Dialog" , Font . PLAIN , 18 ) ; UIManager . put ( "Button.font" , font ) ; UIManager . put ( "Label.font" , font ) ; int option ; do { option = JOptionPane . showConfirmDialog ( null , "Had enough?" , " A Stubborn Dialog" , JOptionPane . YES_NO_OPTION ) ; } while ( option == JOptionPane . NO_OPTION ) ; }
tr	1	public void testService ( ) throws Exception { System . out . println ( "locating service:osgi" ) ; int count = 0 ; for ( ServiceLocationEnumeration services = TestActivator . locator . findServices ( new ServiceType ( "service:osgi" ) , null , null ) ; services . hasMoreElements ( ) ; ) { assertEquals ( services . next ( ) . toString ( ) , "service:osgi://gantenbein:123" ) ; count ++ ; } assertEquals ( count , 1 ) ; }
tr	5	public String formatMessage ( String msg ) { ArrayList < String > messages = new ArrayList < String > ( ) ; StringTokenizer tokenizer = new StringTokenizer ( msg ) ; while ( tokenizer . hasMoreTokens ( ) ) { messages . add ( tokenizer . nextToken ( ) ) ; } String name = messages . get ( 1 ) ; if ( messages . get ( 0 ) . equalsIgnoreCase ( "SAY" ) ) { msg = name + ": " ; for ( int i = 2 ; i < messages . size ( ) ; i ++ ) { msg += messages . get ( i ) + " " ; } } else if ( messages . get ( 0 ) . equalsIgnoreCase ( "JOIN" ) ) { msg = name + " HAS JOINED" ; } else if ( messages . get ( 0 ) . equalsIgnoreCase ( "LEAVE" ) ) { msg = name + " HAS LEFT" ; } return msg ; }
tr	4	public boolean collides ( double PointX , double PointY ) { CVector2D ThisStart = this . getCompensatedStartPosition ( ) ; CVector2D ThisEnd = this . getEndPosition ( ) ; if ( PointX > ThisEnd . getX ( ) ) return false ; if ( PointX < ThisStart . getX ( ) ) return false ; if ( PointY > ThisEnd . getY ( ) ) return false ; if ( PointY < ThisStart . getY ( ) ) return false ; return true ; }
tr	6	public static boolean canWriteLetterFromMagazine6 ( String letter , String magazine ) { HashMap < Character , MutableInt > letterChars = new HashMap < Character , MutableInt > ( 512 ) ; char [ ] letterCharArray = letter . toCharArray ( ) ; char [ ] magazineCharArray = magazine . toCharArray ( ) ; for ( int i = 0 ; i < letterCharArray . length ; i ++ ) { char chr = letterCharArray [ i ] ; MutableInt currentCountForChar = letterChars . get ( chr ) ; if ( currentCountForChar != null ) { currentCountForChar . increment ( ) ; } else { letterChars . put ( chr , new MutableInt ( 1 ) ) ; } } for ( int i = 0 ; i < magazineCharArray . length ; i ++ ) { char chr = magazineCharArray [ i ] ; MutableInt currentCountForChar = letterChars . get ( chr ) ; if ( currentCountForChar != null && currentCountForChar . decrement ( ) <= 0 ) { letterChars . remove ( chr ) ; if ( letterChars . isEmpty ( ) ) return true ; } } return false ; }
tr	3	public void set ( PreparedStatement stmt , int index , Object value ) throws SQLException { if ( value == null ) stmt . setNull ( index , Types . null ) ; else { if ( value instanceof double ) stmt . setDouble ( index , ( ( Number ) value ) . doubleValue ( ) ) ; else if ( value instanceof BigDecimal ) stmt . setBigDecimal ( index , ( BigDecimal ) value ) ; else stmt . setObject ( index , value ) ; } }
tr	0	public SelectTwoTileAction ( String imageKey ) { super ( imageKey ) ; }
tr	7	public void creerRessources ( ) { if ( this . ressources_spawns == null ) { this . ressources_spawns = new ArrayList < case > ( ) ; List < case > availables = new ArrayList < case > ( ) ; for ( case c : this . get_cases ( ) ) { if ( c . getNiveau_obstacle ( ) == 0 ) { availables . add ( c ) ; } } if ( ConfigurationLoader . MAX_RESSOURCES_SPAWNS < availables . size ( ) ) { for ( int i = 0 ; i < ConfigurationLoader . MAX_RESSOURCES_SPAWNS ; i ++ ) { if ( availables . size ( ) > 0 ) { case c = availables . get ( new Random ( ) . nextInt ( availables . size ( ) ) ) ; availables . remove ( c ) ; this . ressources_spawns . add ( c ) ; } } } else { this . ressources_spawns = availables ; } } case where = this . ressources_spawns . get ( new Random ( ) . nextInt ( this . ressources_spawns . size ( ) ) ) ; int quantite = ( this . abondance / ( new Random ( ) . nextInt ( 5 ) + 1 ) ) * ConfigurationLoader . ABONDANCE_MULTIPLICATOR ; if ( quantite > 0 ) { where . ajouterRessource ( new Ressource ( quantite ) ) ; } }
tr	3	public static long addAddress ( Address address , long sessionID ) throws SessionException { if ( sessionID <= NO_SESSION_ID ) { throw new SessionException ( "A valid session ID is required to add an address" , SessionException . SESSION_ID_REQUIRED ) ; } Contact contact = ( Contact ) editContacts . get ( new long ( sessionID ) ) ; if ( contact == null ) { throw new SessionException ( "You must select a contact before adding an address" , SessionException . CONTACT_SELECT_REQUIRED ) ; } if ( addresses . indexOf ( address ) == - 1 ) { addresses . add ( address ) ; } contact . addAddress ( address ) ; return sessionID ; }
tr	8	@ Override public void run ( ) { int whatdo = Random . nextInt ( 0 , 10 ) ; switch ( whatdo ) { case 0 : case 1 : Mouse . move ( Random . nextInt ( 0 , 750 ) , Random . nextInt ( 16 , 500 ) ) ; break ; case 2 : case 3 : case 5 : case 4 : case 7 : case 8 : Camera . setAngle ( Random . nextInt ( 0 , 360 ) ) ; break ; default : Camera . setAngle ( Random . nextInt ( 0 , 360 ) ) ; break ; } }
tr	3	public void mergeSort ( int [ ] data , int begin , int end ) { if ( data == null || begin > end ) { throw new NullPointerException ( "Error input." ) ; } else if ( begin == end ) { return ; } else { int mid = ( begin + end ) / 2 ; mergeSort ( data , begin , mid ) ; mergeSort ( data , mid + 1 , end ) ; merge ( data , begin , mid , end ) ; } }
tr	9	public static void testGeneticAlgorithmInteger ( ) { IMyRandomDataFunction < Integer > rFunc = new IMyRandomDataFunction ( ) { private final Random r = new Random ( ) ; @ Override public Integer getRandom ( ) { return r . nextInt ( ) ; } } ; IMyFitnessTestFunction < Integer > tFunc = new IMyFitnessTestFunction < Integer > ( ) { @ Override public int testFitness ( List < Integer > list ) { return ( int ) list . stream ( ) . mapToInt ( i -> evaluate ( i ) ) . sum ( ) / list . size ( ) ; } private int evaluate ( int given ) { if ( given % 2 == 0 ) { return 100 ; } else { return 0 ; } } } ; IMyNeuronFunction < Integer > calcFunc = new IMyNeuronFunction < Integer > ( ) { @ Override public Integer process ( List < Integer > inData , List < Integer > weights , Integer threshold ) throws Exception { if ( inData . size ( ) != weights . size ( ) ) { throw new Exception ( "inData size doesnt match weights size" ) ; } if ( threshold == null ) { throw new Exception ( "threshold cannot be null" ) ; } double total = 0 ; for ( int i = 0 ; i < inData . size ( ) ; i ++ ) { total += mapIntegerToSpecialDouble ( inData . get ( i ) ) * mapIntegerToSpecialDouble ( weights . get ( i ) ) ; } return mapSpecialDoubleToInteger ( 1 / ( 1 + Math . exp ( ( - total ) / mapIntegerToSpecialDouble ( threshold ) ) ) ) ; } private double mapIntegerToSpecialDouble ( Integer in ) { if ( in >= 0 ) { return in / Integer . MAX_VALUE ; } else { return in / Integer . MIN_VALUE ; } } private int mapSpecialDoubleToInteger ( double in ) { if ( in >= 0 ) { return ( int ) ( Integer . MAX_VALUE * in ) ; } else { return ( int ) ( Integer . MIN_VALUE * in ) ; } } } ; try { MyDrawableGraph dg = new MyDrawableGraph ( MyDrawableGraph . SortByAxis . xAxis , MyDrawableGraph . SortDirection . asc , 800 , 600 ) ; MyCanvasWindow graphWindow = new MyCanvasWindow ( 800 , 600 , dg ) ; graphWindow . startWindow ( ) ; MyPopulation < Integer > pop = new MyPopulation ( 50 , 10 , tFunc , rFunc , false ) ; for ( int i = 0 ; i < 1000 ; i ++ ) { try { pop . nextGeneration ( ) ; int avgFitness = pop . getAverageFitness ( ) ; List < MyGraphPoint < Integer , Integer >> graphPoints = pop . getPopulation ( ) . stream ( ) . map ( p -> new MyGraphPoint < > ( pop . getGenerationCount ( ) , avgFitness ) ) . collect ( Collectors . toList ( ) ) ; graphPoints . stream ( ) . forEach ( si -> { try { dg . addGraphItem ( si ) ; } catch ( Exception ex ) { Logger . getLogger ( MyStartClass . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } } ) ; System . out . println ( "Population #" + i ) ; System . out . println ( "-average fitnes:" + avgFitness ) ; if ( avgFitness >= 99 ) { break ; } } catch ( Exception ex ) { Logger . getLogger ( MyStartClass . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } } pop . getMostFitIndividual ( ) . getData ( ) . forEach ( i -> { System . out . println ( "" + i ) ; } ) ; } catch ( Exception ex ) { Logger . getLogger ( MyStartClass . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } }
tr	5	public String format ( LogRecord r ) { StringBuffer sb = new StringBuffer ( ) ; sb . append ( r . getLevel ( ) . getName ( ) + "\t" ) ; sb . append ( MessageFormat . format ( "{0  date  yy-MM-dd} {0  time  kk:mm:ss.SSSS} " , new Object [ ] { new Date ( r . getMillis ( ) ) } ) + "\t" ) ; String cnm = r . getSourceClassName ( ) ; String cn = "" ; if ( cnm != null ) { int cnl = cnm . length ( ) ; if ( cnl > 20 ) { cn = r . getSourceClassName ( ) . substring ( cnl - 19 ) ; } else { char sp [ ] = {   } ; StringBuffer sb1 = new StringBuffer ( ) . append ( cnm ) ; cn = sb1 . append ( sp , 0 , 1 ) . toString ( ) ; } } sb . append ( cn + "\t" ) . append ( " " ) ; sb . append ( left ( r . getSourceMethodName ( ) , 23 ,   ) + "\t" ) ; sb . append ( r . getThreadID ( ) + "\t" ) ; sb . append ( formatMessage ( r ) ) . append ( ls ) ; if ( null != r . getThrown ( ) ) { sb . append ( "Throwable occurred: " ) ; Throwable t = r . getThrown ( ) ; PrintWriter pw = null ; try { StringWriter sw = new StringWriter ( ) ; pw = new PrintWriter ( sw ) ; t . printStackTrace ( pw ) ; sb . append ( sw . toString ( ) ) ; } finally { if ( pw != null ) { try { pw . close ( ) ; } catch ( Exception e ) { } } } } return sb . toString ( ) ; }
tr	9	private void addFriend ( long l ) { try { if ( l == 0 ) return ; if ( friendsCount >= 100 && anInt1046 != 1 ) { pushMessage ( "Your friendlist is full. Max of 100 for free users  and 200 for members" , 0 , "" ) ; return ; } if ( friendsCount >= 200 ) { pushMessage ( "Your friendlist is full. Max of 100 for free users  and 200 for members" , 0 , "" ) ; return ; } String s = TextClass . fixName ( TextClass . nameForLong ( l ) ) ; for ( int i = 0 ; i < friendsCount ; i ++ ) if ( friendsListAsLongs [ i ] == l ) { pushMessage ( s + " is already on your friend list" , 0 , "" ) ; return ; } for ( int j = 0 ; j < ignoreCount ; j ++ ) if ( ignoreListAsLongs [ j ] == l ) { pushMessage ( "Please remove " + s + " from your ignore list first" , 0 , "" ) ; return ; } if ( s . equals ( myPlayer . name ) ) { return ; } else { friendsList [ friendsCount ] = s ; friendsListAsLongs [ friendsCount ] = l ; friendsNodeIDs [ friendsCount ] = 0 ; friendsCount ++ ; needDrawTabArea = true ; outStream1 . createFrame ( 188 ) ; outStream1 . writeQWord ( l ) ; return ; } } catch ( RuntimeException runtimeexception ) { signlink . reporterror ( "15283  " + ( byte ) 68 + "  " + l + "  " + runtimeexception . toString ( ) ) ; } throw new RuntimeException ( ) ; }
tr	2	public void actionPerformed ( ActionEvent e ) { if ( e . getSource ( ) == avbrytB ) { this . setVisible ( false ) ; return ; } else if ( e . getSource ( ) == sparastangB ) { transaction ( true ) ; return ; } }
tr	3	public static void RemoveMesh ( String name ) { Mesh del = null ; for ( Mesh m : models ) { if ( m . name . equals ( name ) ) { del = m ; break ; } } if ( del != null ) { models . remove ( del ) ; } }
tr	3	public static byte [ ] calculateSignature ( final String signatureBaseString , final String key , final String signingAlgorithm ) { try { final Mac mac = Mac . getInstance ( signingAlgorithm ) ; final SecretKeySpec spec = new SecretKeySpec ( key . getBytes ( Charsets . UTF_8 ) , signingAlgorithm ) ; mac . init ( spec ) ; final byte [ ] text = signatureBaseString . getBytes ( Charsets . UTF_8 . name ( ) ) ; final byte [ ] signatureBytes = mac . doFinal ( text ) ; return signatureBytes ; } catch ( final NoSuchAlgorithmException e ) { throw new IllegalStateException ( e ) ; } catch ( final InvalidKeyException e ) { throw new IllegalStateException ( e ) ; } catch ( final UnsupportedEncodingException shouldntHappen ) { throw new IllegalStateException ( shouldntHappen ) ; } }
tr	1	public JSTextFileUtility ( String filename ) { this . filename = filename ; if ( ! fileExists ( filename ) ) createNewFile ( filename ) ; }
tr	4	public void write ( ) throws IOException { if ( ( reportTrigger != null ) && reportTrigger . isUsed ( ) ) { bufferedWriter . write ( "|" ) ; bufferedWriter . newLine ( ) ; if ( getReportLine ( ) . getNumberLine ( ) == 0 ) { bufferedWriter . write ( "|    " + RessourceReporting . getString ( "ERROR_TRIGGER_START_FILE" ) + " :" ) ; } else { bufferedWriter . write ( "|    " + RessourceReporting . getString ( "ERROR_TRIGGER_ON_LINE" ) + " : " + getReportLine ( ) . getNumberLine ( ) + " :" ) ; } reportTrigger . write ( ) ; bufferedWriter . flush ( ) ; } if ( reportLine . isUsed ( ) ) { reportLine . write ( ) ; } bufferedWriter . flush ( ) ; }
tr	4	@ Override public boolean doCommand ( final CommandSender sender , final Command command , final String cmd , final String [ ] args ) { if ( ! canUseCommand ( sender , cmd , false , true ) ) { return true ; } String players = null ; synchronized ( AllAdmin . getUserList ( ) ) { final TreeMap < String , IUser > onlinePlayers = new TreeMap < String , IUser > ( ) ; onlinePlayers . putAll ( AllAdmin . getUserList ( ) ) ; for ( final String player : onlinePlayers . keySet ( ) ) { if ( players == null ) { players = "There are " + onlinePlayers . size ( ) + " player online: " + player + "  " ; continue ; } players += player + "  " ; } if ( players == null ) { sender . sendMessage ( AllAdmin . getMessages ( "noPlayersOn" ) ) ; return true ; } sender . sendMessage ( ChatColor . AQUA + players ) ; } return true ; }
tr	3	public static void initConfig ( String path ) { FileInputStream fis = null ; try { fis = new FileInputStream ( path ) ; SYSTEM_CONFIG . load ( fis ) ; } catch ( Exception e ) { logger . error ( "System config file init fail !" , e ) ; } finally { if ( fis != null ) { try { fis . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } } }
tr	9	static private OctNode recurseParse ( Integer currentDepth , ByteBuffer buffer , float [ ] origin , float length ) throws IOException , OctreeException { byte type = buffer . get ( ) ; try { switch ( type ) { case OctNode . OCTNODE_EMPTY : byte value = buffer . get ( ) ; return new OctNode ( currentDepth , ( value == 0 ) ? false : true , origin , length ) ; case OctNode . OCTNODE_LEAF : byte signs = buffer . get ( ) ; float coords [ ] = new float [ 3 ] ; coords [ 0 ] = buffer . getFloat ( ) ; coords [ 1 ] = buffer . getFloat ( ) ; coords [ 2 ] = buffer . getFloat ( ) ; return new OctNode ( currentDepth , signs , coords , origin , length ) ; case OctNode . OCTNODE_INTERMEDIATE : OctNode children [ ] = new OctNode [ 8 ] ; for ( int i = 0 ; i < 8 ; i ++ ) { float [ ] newOrigin = new float [ 3 ] ; newOrigin [ 2 ] = origin [ 2 ] + ( ( i % 2 == 1 ) ? length / 2 : 0 ) ; newOrigin [ 1 ] = origin [ 1 ] + ( ( ( i >> 1 ) % 2 == 1 ) ? length / 2 : 0 ) ; newOrigin [ 0 ] = origin [ 0 ] + ( ( ( i >> 2 ) % 2 == 1 ) ? length / 2 : 0 ) ; children [ i ] = recurseParse ( currentDepth + 1 , buffer , newOrigin , length / 2 ) ; } return new OctNode ( currentDepth , children , origin , length ) ; default : throw new InvalidSOGFileSyntaxOctreeException ( ) ; } } catch ( OctNodeException one ) { throw new InvalidSOGFileSyntaxOctreeException ( ) ; } }
tr	4	public boolean autoCheckSibMessage ( String xml , String id [ ] , String ref [ ] ) { Hashtable hashtable = SibXMLMessageParser ( xml , id ) ; if ( hashtable == null ) return false ; if ( hashtable . size ( ) < id . length ) return false ; for ( int i = 0 ; i < hashtable . size ( ) ; i ++ ) if ( ! ref [ i ] . equals ( ( String ) hashtable . get ( id [ i ] ) ) ) return false ; return true ; }
tr	0	public static void main ( String [ ] args ) { int numbers [ ] = { 1 , 2 , 3 , 5 , 8 , 13 } ; System . out . println ( "First member of this array is " + numbers [ 0 ] ) ; System . out . println ( "Last member of this array is " + numbers [ numbers . length - 1 ] ) ; }
tr	0	public static void setHour ( int hora , int minuto , int segundo , String time ) { double horas = ( hora * 30 ) - 90 + ( minuto / 2 ) ; double minutos = ( minuto * 6 ) - 90 ; double segundos = ( segundo * 6 ) - 90 ; Hora . setRotate ( horas ) ; Min . setRotate ( minutos ) ; Sec . setRotate ( segundos ) ; tiempo . setText ( time ) ; tiempo . toFront ( ) ; }
tr	7	public void drawPolygon ( double [ ] x , double [ ] y , JGColor [ ] col , int len , boolean filled , boolean pf_relative ) { if ( buf_gfx == null ) return ; int [ ] xpos = new int [ 3 ] ; int [ ] ypos = new int [ 3 ] ; xpos [ 0 ] = el . scaleXPos ( x [ 0 ] , pf_relative ) ; ypos [ 0 ] = el . scaleYPos ( y [ 0 ] , pf_relative ) ; xpos [ 1 ] = el . scaleXPos ( x [ 1 ] , pf_relative ) ; ypos [ 1 ] = el . scaleYPos ( y [ 1 ] , pf_relative ) ; xpos [ 2 ] = el . scaleXPos ( x [ len - 1 ] , pf_relative ) ; ypos [ 2 ] = el . scaleYPos ( y [ len - 1 ] , pf_relative ) ; if ( ! filled ) { if ( col != null ) setColor ( buf_gfx , col [ 1 ] ) ; buf_gfx . drawLine ( xpos [ 0 ] , ypos [ 0 ] , xpos [ 1 ] , ypos [ 1 ] ) ; if ( col != null ) setColor ( buf_gfx , col [ 0 ] ) ; buf_gfx . drawLine ( xpos [ 2 ] , ypos [ 2 ] , xpos [ 0 ] , ypos [ 0 ] ) ; } for ( int i = 2 ; i < len ; i ++ ) { xpos [ 2 ] = el . scaleXPos ( x [ i ] , pf_relative ) ; ypos [ 2 ] = el . scaleYPos ( y [ i ] , pf_relative ) ; if ( col != null ) setColor ( buf_gfx , col [ i ] ) ; if ( filled ) { buf_gfx . fillPolygon ( xpos , ypos , 3 ) ; } else { buf_gfx . drawLine ( xpos [ 1 ] , ypos [ 1 ] , xpos [ 2 ] , ypos [ 2 ] ) ; } xpos [ 1 ] = xpos [ 2 ] ; ypos [ 1 ] = ypos [ 2 ] ; } }
tr	1	@ Override public boolean equals ( Object other ) { if ( other instanceof NewId ) { return this . equals ( ( NewId ) other ) ; } return false ; }
tr	2	private List < Integer > getSelection ( ) { final List < Integer > sel = new LinkedList < > ( ) ; for ( int i = 0 ; i < cardList . size ( ) ; i ++ ) { if ( cardList . get ( i ) . selected ) { sel . add ( i ) ; } } return sel ; }
tr	0	public Player [ ] getPlayers ( ) { return this . players ; }
tr	1	public int get ( long index ) { if ( ! map . containsKey ( index ) ) throw new ArrayIndexOutOfBoundsException ( "index is " + index ) ; return map . get ( index ) ; }
tr	9	@ Override public void actionPerformed ( ActionEvent e ) { Vastaustyyppi tyyppi = null ; String kysymysTekstina = kysymys . getText ( ) ; int tyyppiIndeksi = vastaustyyppi . getSelectedIndex ( ) ; if ( tyyppiIndeksi == 0 ) { tyyppi = Vastaustyyppi . AVOIN ; } else if ( tyyppiIndeksi == 1 ) { tyyppi = Vastaustyyppi . LIKERT ; } else if ( tyyppiIndeksi == 2 ) { tyyppi = Vastaustyyppi . ASTEIKKO ; } else if ( tyyppiIndeksi == 3 ) { tyyppi = Vastaustyyppi . KOLMIKENTTA ; } if ( e . getSource ( ) == valmis ) { if ( ! kysymysTekstina . isEmpty ( ) ) { valikko . lisaaKysymys ( kysymysTekstina , tyyppi ) ; } if ( valikko . annaKyselynKoko ( ) == 0 ) { lisaystieto . setText ( "Lis\u00E4\u00E4 ensin kysymys!" ) ; return ; } valikko . vaihdaValikko ( Valikko . LUONTILOPETUS ) ; } if ( e . getSource ( ) == lisaa ) { if ( kysymysTekstina . isEmpty ( ) ) { lisaystieto . setText ( "T\u00E4yt\u00E4 kysymys!" ) ; return ; } valikko . lisaaKysymys ( kysymysTekstina , tyyppi ) ; lisaystieto . setText ( "Lis\u00E4tty! Kysymyksi\u00E4: " + valikko . annaKyselynKoko ( ) ) ; kysymys . setText ( "" ) ; } }
tr	7	@ Test public void testAllTheThings ( ) throws Exception { Server server = Helper . serverSetup ( 4444 ) ; Client client1 = new Client ( "localhost" , 4444 ) ; client1 . startGUI ( ) ; ClientGUI client1GUI = client1 . getClientGUI ( ) ; Client client2 = new Client ( "localhost" , 4444 ) ; client2 . startGUI ( ) ; ClientGUI client2GUI = client2 . getClientGUI ( ) ; client1 . newBoard ( "board1" ) ; client1 . newBoard ( "board2" ) ; assertTrue ( client1 . createUser ( "josh" , "board1" ) ) ; assertFalse ( client2 . createUser ( "josh" , "board2" ) ) ; assertTrue ( client2 . createUser ( "juan" , "board1" ) ) ; client1GUI . setupCanvas ( ) ; client2GUI . setupCanvas ( ) ; String [ ] users = client1 . getUsers ( ) ; boolean containsJosh = false ; boolean containsJuan = false ; for ( String user : users ) { if ( user . equals ( "josh" ) ) containsJosh = true ; else if ( user . equals ( "juan" ) ) containsJuan = true ; } assertTrue ( containsJosh && containsJuan ) ; new Command ( "draw board1 drawLineSegment 50 50 60 60 0 10.0" . split ( " " ) ) . invokeCommand ( client1 . getCanvas ( ) ) ; client1 . makeDrawRequest ( "drawLineSegment 50 50 60 60 0 10.0" ) ; BufferedImage imageDrawn = client1 . getDrawingBuffer ( ) ; BufferedImage imageInvoked = client2 . getDrawingBuffer ( ) ; boolean same = true ; for ( int x = 0 ; x < imageInvoked . getWidth ( ) ; x ++ ) { for ( int y = 0 ; y < imageInvoked . getHeight ( ) ; y ++ ) { if ( imageInvoked . getRGB ( x , y ) != imageDrawn . getRGB ( x , y ) ) same = false ; } } assertTrue ( same ) ; client1 . switchBoard ( "board2" ) ; String [ ] board2users = client1 . getUsers ( ) ; String [ ] expected1 = { "josh" } ; assertArrayEquals ( board2users , expected1 ) ; String [ ] board1users = client2 . getUsers ( ) ; String [ ] expected2 = { "juan" } ; assertArrayEquals ( board1users , expected2 ) ; client1 . kill ( ) ; client2 . kill ( ) ; server . shutDown ( ) ; Thread . sleep ( 100 ) ; }
tr	1	public void setZin ( String zin ) { if ( ! zin . equals ( this . zin ) ) { this . zin = zin ; fireInvalidationEvent ( ) ; } }
tr	7	public boolean method195 ( int j ) { int k = anInt165 ; int l = anInt188 ; int i1 = anInt185 ; if ( j == 1 ) { k = anInt200 ; l = anInt164 ; i1 = anInt162 ; } if ( k == - 1 ) return true ; boolean flag = true ; if ( ! Model . method463 ( k ) ) flag = false ; if ( l != - 1 && ! Model . method463 ( l ) ) flag = false ; if ( i1 != - 1 && ! Model . method463 ( i1 ) ) flag = false ; return flag ; }
tr	0	@ XmlElementDecl ( namespace = "" , name = "terms-discount-due-days" ) public JAXBElement < String > createTermsDiscountDueDays ( String value ) { return new JAXBElement < String > ( _TermsDiscountDueDays_QNAME , String . class , null , value ) ; }
tr	9	@ Override public Object intercept ( Object obj , Method method , Object [ ] args , MethodProxy proxy ) throws Throwable { Object sourceResult = proxy . invokeSuper ( obj , args ) ; if ( sourceResult != null ) { return sourceResult ; } ConnectionHolder conn = null ; Object result = null ; try { conn = cm . getNewConnection ( ) ; for ( SelectModel s : select ) { if ( s . containsMethod ( method . getName ( ) ) ) { Object [ ] parameters = null ; SimpleProperty [ ] ps = s . getRefProperties ( ) ; if ( ps != null ) { parameters = new Object [ ps . length ] ; for ( int i = 0 ; i < ps . length ; i ++ ) { parameters [ i ] = ps [ i ] . invokeRead ( obj ) ; } } if ( s . isReturnList ( ) ) { result = localExecutor . selectList ( new SelectListContext ( s . getTargetType ( ) , s . getSql ( ) , s . getOffset ( ) , s . getLimit ( ) , parameters ) , conn ) ; SimpleProperty p = s . getProperty ( ) ; p . invokeWrite ( obj , result ) ; } else if ( s . isHasRef ( ) ) { Object [ ] propertyResult = ( Object [ ] ) localExecutor . selectOne ( new SelectContext ( Object [ ] . class , s . getSql ( ) , parameters ) , conn ) ; for ( int i = 0 ; i < propertyResult . length ; i ++ ) { SimpleProperty p = s . getProperty ( i + 1 ) ; if ( p . getReadName ( ) . equals ( method . getName ( ) ) ) { result = propertyResult [ i ] ; } p . invokeWrite ( obj , propertyResult [ i ] ) ; } } else { result = localExecutor . selectOne ( new SelectContext ( s . getTargetType ( ) , s . getSql ( ) , parameters ) , conn ) ; SimpleProperty p = s . getProperty ( ) ; p . invokeWrite ( obj , result ) ; } break ; } } } catch ( Exception e ) { throw new SQLException ( e ) ; } finally { if ( conn != null ) cm . releaseConnection ( conn ) ; } return result ; }
tr	9	@ Override public boolean [ ] getBooleanData ( boolean [ ] a , long startPos , long endPos , long step ) { if ( startPos < 0 || startPos >= length ) { throw new ArrayIndexOutOfBoundsException ( "startPos < 0 || startPos >= length" ) ; } if ( endPos < 0 || endPos > length || endPos < startPos ) { throw new ArrayIndexOutOfBoundsException ( "endPos < 0 || endPos > length || endPos < startPos" ) ; } if ( step < 1 ) { throw new IllegalArgumentException ( "step < 1" ) ; } long len = ( long ) Math . ceil ( ( endPos - startPos ) / ( double ) step ) ; if ( len > getMaxSizeOf32bitArray ( ) ) { return null ; } else { boolean [ ] out ; if ( a != null && a . length >= len ) { out = a ; } else { out = new boolean [ ( int ) len ] ; } int idx = 0 ; if ( ptr != 0 ) { for ( long i = startPos ; i < endPos ; i += step ) { byte v = Utilities . UNSAFE . getByte ( ptr + i ) ; out [ idx ++ ] = v == 1 ; } } else { if ( isConstant ( ) ) { boolean elem = data [ 0 ] != 0 ; for ( long i = startPos ; i < endPos ; i += step ) { out [ idx ++ ] = elem ; } } else { for ( long i = startPos ; i < endPos ; i += step ) { byte v = data [ ( int ) i ] ; out [ idx ++ ] = v != 0 ; } } } return out ; } }
tr	0	public void incrementNodeQuantity ( int increment ) { nodeQuantity += increment ; }
tr	1	private Meter getSelectedMeter ( ) { Account temp = getSelectedAccount ( ) ; if ( temp != null ) { Meter m = temp . getMeter ( getSelectedMeterID ( ) ) ; return m ; } else return null ; }
tr	7	public void print ( Player owner ) { _boardController . clear_gridpane ( ) ; _boardController . clear_pieceTable ( ) ; int row , col ; int height = _height ; int width = _width ; for ( row = 0 ; row < height ; row ++ ) { for ( col = 0 ; col < width ; col ++ ) { Building b = _cells [ row ] [ col ] . get_building ( ) ; if ( b != null ) { _boardController . set_piece ( row , col , b ) ; if ( b . get_owner ( ) == owner ) { _boardController . add_piece ( b ) ; } } Terrain t = _cells [ row ] [ col ] . get_terrain ( ) ; if ( t != null ) { _boardController . set_terrain ( row , col , t ) ; } else { throw new IllegalStateException ( "[Map] null terrain" ) ; } Unit u = _cells [ row ] [ col ] . get_unit ( ) ; if ( u != null && u . get_owner ( ) == owner ) { _boardController . add_piece ( u ) ; _boardController . set_piece ( row , col , u ) ; } } } _boardController . print_unitTable ( ) ; }
tr	0	@ Override public void setText ( String Text ) { this . SetText ( Text , Color . white ) ; }
tr	8	public static boolean isWord ( int c ) { if ( c > 127 ) return true ; if ( c > 47 && c < 58 ) return true ; if ( c > 64 && c < 91 ) return true ; if ( c > 96 && c < 123 ) return true ; if ( c == _ ) return true ; return false ; }
tr	7	static public Automaton concatenate ( Automaton a1 , Automaton a2 ) { if ( a1 . isSingleton ( ) && a2 . isSingleton ( ) ) return BasicAutomata . makeString ( a1 . singleton + a2 . singleton ) ; if ( isEmpty ( a1 ) || isEmpty ( a2 ) ) return BasicAutomata . makeEmpty ( ) ; boolean deterministic = a1 . isSingleton ( ) && a2 . isDeterministic ( ) ; if ( a1 == a2 ) { a1 = a1 . cloneExpanded ( ) ; a2 = a2 . cloneExpanded ( ) ; } else { a1 = a1 . cloneExpandedIfRequired ( ) ; a2 = a2 . cloneExpandedIfRequired ( ) ; } for ( State s : a1 . getAcceptStates ( ) ) { s . accept = false ; s . addEpsilon ( a2 . initial ) ; } a1 . deterministic = deterministic ; a1 . clearHashCode ( ) ; a1 . checkMinimizeAlways ( ) ; return a1 ; }
tr	4	@ Override public Tipo validarSemantica ( ) throws Exception { Tipo izq , der ; izq = izquierdo . validarSemantica ( ) ; der = derecho . validarSemantica ( ) ; if ( izq instanceof TipoInt || der instanceof TipoFloat ) { if ( der instanceof TipoInt || der instanceof TipoFloat ) { return new TipoBooleano ( ) ; } else { throw new Exception ( "Error Semantico no se puede comparar un Tipo Int o Float con un Tipo " + der . toString ( ) ) ; } } else { throw new Exception ( "Error Semantico no se puede comparar un Tipo Int o Float con un Tipo " + der . toString ( ) ) ; } }
tr	8	public void addMenuPanelInit ( ) { addMenuPanel = new JPanel ( ) ; JLabel menuInstructionLabel = generator . createLabel ( addMenuPanel , "Please Choose an Item from each Menu Below" , "" ) ; menuInstructionLabel . setFont ( new Font ( "Dialog" , 1 , 20 ) ) ; JLabel mainMenuAppChoiceLabel = generator . createLabel ( addMenuPanel , "Main Menu Appetizer Choice" , "" ) ; final JTable allMainApp = new JTable ( allMainAppModel . getSpecificMealTable ( false , "appetizer" ) ) ; allMainApp . removeColumn ( allMainApp . getColumn ( "ID Number" ) ) ; allMainApp . setPreferredScrollableViewportSize ( new Dimension ( 450 , 70 ) ) ; allMainApp . setFillsViewportHeight ( true ) ; allMainApp . setSelectionMode ( ListSelectionModel . SINGLE_SELECTION ) ; JScrollPane scrollMainApp = new JScrollPane ( allMainApp ) ; scrollMainApp . setMaximumSize ( new Dimension ( 200 , 300 ) ) ; addMenuPanel . add ( scrollMainApp ) ; JLabel mainMenuMainChoiceLabel = generator . createLabel ( addMenuPanel , "Main Menu Main Choice" , "" ) ; final JTable allMainMain = new JTable ( allMainMainModel . getSpecificMealTable ( false , "main" ) ) ; allMainMain . removeColumn ( allMainMain . getColumn ( "ID Number" ) ) ; allMainMain . setPreferredScrollableViewportSize ( new Dimension ( 450 , 70 ) ) ; allMainMain . setFillsViewportHeight ( true ) ; allMainMain . setSelectionMode ( ListSelectionModel . SINGLE_SELECTION ) ; JScrollPane scrollMainMain = new JScrollPane ( allMainMain ) ; scrollMainMain . setMaximumSize ( new Dimension ( 200 , 300 ) ) ; addMenuPanel . add ( scrollMainMain ) ; JLabel mainMenuDessChoiceLabel = generator . createLabel ( addMenuPanel , "Main Menu Dessert Choice" , "" ) ; final JTable allMainDess = new JTable ( allMainDessModel . getSpecificMealTable ( false , "dessert" ) ) ; allMainDess . removeColumn ( allMainDess . getColumn ( "ID Number" ) ) ; allMainDess . setPreferredScrollableViewportSize ( new Dimension ( 450 , 70 ) ) ; allMainDess . setFillsViewportHeight ( true ) ; allMainDess . setSelectionMode ( ListSelectionModel . SINGLE_SELECTION ) ; JScrollPane scrollMainDess = new JScrollPane ( allMainDess ) ; scrollMainDess . setMaximumSize ( new Dimension ( 200 , 300 ) ) ; addMenuPanel . add ( scrollMainDess ) ; JLabel vegMenuAppChoiceLabel = generator . createLabel ( addMenuPanel , "Vegetarian Menu Appetizer Choice" , "" ) ; final JTable allVegApp = new JTable ( allVegAppModel . getSpecificMealTable ( true , "appetizer" ) ) ; allVegApp . removeColumn ( allVegApp . getColumn ( "ID Number" ) ) ; allVegApp . setPreferredScrollableViewportSize ( new Dimension ( 450 , 70 ) ) ; allVegApp . setFillsViewportHeight ( true ) ; allVegApp . setSelectionMode ( ListSelectionModel . SINGLE_SELECTION ) ; JScrollPane scrollVegApp = new JScrollPane ( allVegApp ) ; scrollVegApp . setMaximumSize ( new Dimension ( 200 , 300 ) ) ; addMenuPanel . add ( scrollVegApp ) ; JLabel vegMenuMainChoiceLabel = generator . createLabel ( addMenuPanel , "Vegetarian Menu Main Choice" , "" ) ; final JTable allVegMain = new JTable ( allVegMainModel . getSpecificMealTable ( true , "main" ) ) ; allVegMain . removeColumn ( allVegMain . getColumn ( "ID Number" ) ) ; allVegMain . setPreferredScrollableViewportSize ( new Dimension ( 450 , 70 ) ) ; allVegMain . setFillsViewportHeight ( true ) ; allVegMain . setSelectionMode ( ListSelectionModel . SINGLE_SELECTION ) ; JScrollPane scrollVegMain = new JScrollPane ( allVegMain ) ; scrollVegMain . setMaximumSize ( new Dimension ( 200 , 300 ) ) ; addMenuPanel . add ( scrollVegMain ) ; JLabel vegMenuDessChoiceLabel = generator . createLabel ( addMenuPanel , "Vegetarian Menu Dessert Choice" , "" ) ; final JTable allVegDess = new JTable ( allVegDessModel . getSpecificMealTable ( true , "dessert" ) ) ; allVegDess . removeColumn ( allVegDess . getColumn ( "ID Number" ) ) ; allVegDess . setPreferredScrollableViewportSize ( new Dimension ( 450 , 70 ) ) ; allVegDess . setFillsViewportHeight ( true ) ; allVegDess . setSelectionMode ( ListSelectionModel . SINGLE_SELECTION ) ; JScrollPane scrollVegDess = new JScrollPane ( allVegDess ) ; scrollVegDess . setMaximumSize ( new Dimension ( 200 , 300 ) ) ; addMenuPanel . add ( scrollVegDess ) ; final JLabel resultLabel = generator . createLabel ( addMenuPanel , " " , "" ) ; final JButton continueButton = generator . createButton ( addMenuPanel , "Continue" , 10 ) ; JButton backButton = generator . createButton ( addMenuPanel , "Back" , 5 ) ; addMenuPanel . setLayout ( new BoxLayout ( addMenuPanel , BoxLayout . Y_AXIS ) ) ; addMenuPanel . addComponentListener ( new ComponentAdapter ( ) { public void componentShown ( ComponentEvent ce ) { if ( eventCreationComplete == true ) { continueButton . setText ( "Update" ) ; if ( vegMenuPanelMenuId != 99999 && mainMenuPanelMenuId != 99999 ) { MenuClass vegMenu = MenuControllerClass . getInstance ( ) . getMenu ( vegMenuPanelMenuId ) ; MenuClass mainMenu = MenuControllerClass . getInstance ( ) . getMenu ( mainMenuPanelMenuId ) ; int mainApp = allMainAppModel . getRowFromID ( mainMenu . getAppetizerMealId ( ) ) ; int mainMain = allMainMainModel . getRowFromID ( mainMenu . getMainMealId ( ) ) ; int mainDess = allMainDessModel . getRowFromID ( mainMenu . getDessertMealId ( ) ) ; int vegApp = allVegAppModel . getRowFromID ( vegMenu . getAppetizerMealId ( ) ) ; int vegMain = allVegMainModel . getRowFromID ( vegMenu . getMainMealId ( ) ) ; int vegDess = allVegDessModel . getRowFromID ( vegMenu . getDessertMealId ( ) ) ; allMainApp . setRowSelectionInterval ( mainApp , mainApp ) ; allMainMain . setRowSelectionInterval ( mainMain , mainMain ) ; allMainDess . setRowSelectionInterval ( mainDess , mainDess ) ; allVegApp . setRowSelectionInterval ( vegApp , vegApp ) ; allVegMain . setRowSelectionInterval ( vegMain , vegMain ) ; allVegDess . setRowSelectionInterval ( vegDess , vegDess ) ; } else { allMainApp . setRowSelectionInterval ( 0 , 0 ) ; allMainMain . setRowSelectionInterval ( 0 , 0 ) ; allMainDess . setRowSelectionInterval ( 0 , 0 ) ; allVegApp . setRowSelectionInterval ( 0 , 0 ) ; allVegMain . setRowSelectionInterval ( 0 , 0 ) ; allVegDess . setRowSelectionInterval ( 0 , 0 ) ; } } } } ) ; backButton . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { if ( eventCreationComplete == false ) { CardLayout cLayout = ( CardLayout ) cardHolder . getLayout ( ) ; cLayout . show ( cardHolder , addViewName ) ; } else { continueButton . setText ( "Continue" ) ; CardLayout cLayout = ( CardLayout ) cardHolder . getLayout ( ) ; cLayout . show ( cardHolder , modifyViewName ) ; } } } ) ; continueButton . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { boolean result = true ; int menuIDs [ ] = new int [ 6 ] ; try { menuIDs [ 0 ] = allMainAppModel . getIDFromRow ( allMainApp . getSelectedRow ( ) ) ; menuIDs [ 1 ] = allMainMainModel . getIDFromRow ( allMainMain . getSelectedRow ( ) ) ; menuIDs [ 2 ] = allMainDessModel . getIDFromRow ( allMainDess . getSelectedRow ( ) ) ; menuIDs [ 3 ] = allVegAppModel . getIDFromRow ( allVegApp . getSelectedRow ( ) ) ; menuIDs [ 4 ] = allVegMainModel . getIDFromRow ( allVegMain . getSelectedRow ( ) ) ; menuIDs [ 5 ] = allVegDessModel . getIDFromRow ( allVegDess . getSelectedRow ( ) ) ; } catch ( ArrayIndexOutOfBoundsException e1 ) { resultLabel . setText ( "Please choose an option from each menu listed" ) ; result = false ; } if ( result == true ) { MenuClass newMainMenu = new MenuClass ( menuIDs [ 0 ] , menuIDs [ 1 ] , menuIDs [ 2 ] ) ; MenuControllerClass . getInstance ( ) . addMenu ( newMainMenu , UIControllerClass . currentUser ) ; MenuClass newVegMenu = new MenuClass ( menuIDs [ 3 ] , menuIDs [ 4 ] , menuIDs [ 5 ] ) ; MenuControllerClass . getInstance ( ) . addMenu ( newVegMenu , UIControllerClass . currentUser ) ; currentEvent . setMainMenu ( newMainMenu ) ; currentEvent . setVegMenu ( newVegMenu ) ; currentEvent . setMainMenuId ( newMainMenu . getMenuId ( ) ) ; currentEvent . setVegMenuId ( newVegMenu . getMenuId ( ) ) ; if ( eventCreationComplete == false ) { CardLayout cLayout = ( CardLayout ) cardHolder . getLayout ( ) ; cLayout . show ( cardHolder , addConfirmViewName ) ; } else { result = EventControllerClass . getInstance ( ) . modifyEvent ( currentEvent ) ; if ( result == true ) { eventMenuChanged = true ; } continueButton . setText ( "Continue" ) ; CardLayout cLayout = ( CardLayout ) cardHolder . getLayout ( ) ; cLayout . show ( cardHolder , modifyViewName ) ; } } } } ) ; }
tr	3	public boolean contains ( int val ) { System . out . printf ( "Looking for %d:%n" , val ) ; Node c = root ; while ( c != null ) if ( c . value == val ) { System . out . println ( " -> Requested value was found." ) ; return true ; } else if ( val < c . value ) { c = c . left ; System . out . printf ( " -> Requested value is smaller than %d : Going left." , c . value ) ; } else { c = c . right ; System . out . printf ( " -> Requested value is bigger than %d : Going right." , c . value ) ; } System . out . println ( " -> Requested value was not found." ) ; return false ; }
tr	0	@ Override public void draw ( ) { glTranslatef ( Display . getWidth ( ) - width - 1 , ( Display . getHeight ( ) / 2 ) - ( height / 2 ) , 0.0f ) ; glColor4f ( 0.25f , 0.25f , 0.25f , 1.0f ) ; glBegin ( GL_QUADS ) ; glVertex3f ( 0.0f , 0.0f , 0.0f ) ; glVertex3f ( width , 0.0f , 0.0f ) ; glVertex3f ( width , height , 0.0f ) ; glVertex3f ( 0.0f , height , 0.0f ) ; glEnd ( ) ; glPushMatrix ( ) ; this . drawItems ( ) ; glPopMatrix ( ) ; glColor4f ( 1.0f , 1.0f , 1.0f , 1.0f ) ; glBegin ( GL_LINES ) ; glVertex3f ( 0.0f , 0.0f , 0.0f ) ; glVertex3f ( width , 0.0f , 0.0f ) ; glVertex3f ( 0.0f , 0.0f , 0.0f ) ; glVertex3f ( 0.0f , height , 0.0f ) ; glVertex3f ( 0.0f , height , 0.0f ) ; glVertex3f ( width , height , 0.0f ) ; glVertex3f ( width , height , 0.0f ) ; glVertex3f ( width , 0.0f , 0.0f ) ; glEnd ( ) ; }
tr	3	private boolean expressao_sempred ( ExpressaoContext _localctx , int predIndex ) { switch ( predIndex ) { case 0 : return 4 >= _localctx . _p ; case 1 : return 3 >= _localctx . _p ; case 2 : return 2 >= _localctx . _p ; } return true ; }
tr	0	public int getEmpNo ( ) { return empNo ; }
tr	0	@ Test public void testGetBedReservations_1 ( ) throws Exception { Booking fixture = new Booking ( new Identifier ( "" ) , new Identifier ( "" ) , new ArrayList ( ) , new ArrayList ( ) , new Date ( ) , hostel . core . Booking . BookingStatus . CANCELLED ) ; ArrayList < Tariff > result = fixture . getBedReservations ( ) ; assertNotNull ( result ) ; assertEquals ( 0 , result . size ( ) ) ; }
tr	8	public Object getValueAt ( int row , int column ) { if ( column < 30 ) { return 100000 * column + row ; } else if ( column < 60 ) { return row * 2.333333 ; } else if ( column < 90 ) { if ( row % 2 == 0 ) return boolean . true ; return boolean . false ; } else if ( column < 120 ) { return "row " + ( getRowCount ( ) - row ) + "  column=" + column ; } else if ( column < 150 ) { return "irow " + ( getRowCount ( ) - row ) ; } else if ( column < 180 ) { Calendar calendar = Calendar . getInstance ( ) ; calendar . roll ( Calendar . DAY_OF_YEAR , row ) ; return calendar . getTime ( ) ; } else if ( column < 210 ) { return row * 10 + 900000000000000000 ; } return null ; }
tr	9	@ Override public void update ( ) { if ( getStopDuration ( ) > 0 ) { stopMove ( ) ; setStopDuration ( getStopDuration ( ) - 1 ) ; } if ( isMoving ( ) ) { Direction dir = getDirection ( ) ; int distance = getSpeed ( ) ; if ( dir . getX ( ) != 0 && dir . getY ( ) != 0 ) { double dist = distance ; dist = dist / Math . sqrt ( 2 ) ; distance = ( int ) Math . round ( dist ) ; } while ( distance > 0 ) { if ( BlastModel . isFree ( this , dir , 1 ) ) { move ( dir ) ; } else if ( dir . getX ( ) != 0 && dir . getY ( ) != 0 ) { if ( BlastModel . isFree ( this , Direction . getDirection ( dir . getX ( ) , 0 ) , 1 ) ) { move ( Direction . getDirection ( dir . getX ( ) , 0 ) ) ; } else if ( BlastModel . isFree ( this , Direction . getDirection ( 0 , dir . getY ( ) ) , 1 ) ) { move ( Direction . getDirection ( 0 , dir . getY ( ) ) ) ; } } else { stopMove ( ) ; } distance -- ; } } }
tr	5	public void setTestInfo ( TestInfo testInfo ) { if ( testInfo == null ) testInfo = new TestInfo ( ) ; try { this . setProperty ( Constants . TEST_NAME , testInfo . getName ( ) ) ; this . setProperty ( Constants . TEST_ID , testInfo . getId ( ) ) ; this . setProperty ( Constants . TEST_NUMBER_OF_USERS , testInfo . getNumberOfUsers ( ) ) ; if ( ! BmTestManager . getInstance ( ) . getIsLocalRunMode ( ) ) { String location = testInfo . getLocation ( ) ; if ( location != null ) { this . setProperty ( Constants . TEST_LOCATION , testInfo . getLocation ( ) ) ; } Overrides overrides = testInfo . getOverrides ( ) ; if ( overrides != null ) { overrides . setThreads ( testInfo . getNumberOfUsers ( ) ) ; this . setProperty ( Constants . TEST_DURATION , overrides . getDuration ( ) ) ; this . setProperty ( Constants . TEST_ITERATIONS , overrides . getIterations ( ) ) ; this . setProperty ( Constants . TEST_RAMP_UP , overrides . getRampup ( ) ) ; this . setProperty ( Constants . TEST_THREADS , overrides . getThreads ( ) ) ; } } } catch ( NullPointerException npe ) { BmLog . error ( "Failed to set " + testInfo . toString ( ) + " to RemoteTestRunner" ) ; } }
tr	4	@ Override public IBSTree < T > delete ( T value ) { BSTree < T > parent = null ; BSTree < T > curr = this ; for ( int cmp = value . compareTo ( curr . data ) ; cmp != 0 ; cmp = value . compareTo ( curr . data ) ) { if ( cmp < 0 ) { if ( curr . left == null ) { return null ; } parent = curr ; curr = curr . getTypedLeft ( ) ; } else { if ( curr . right == null ) { return null ; } parent = curr ; curr = curr . getTypedRight ( ) ; } } return curr . delete ( parent ) ; }
tr	9	private void method134 ( Stream stream ) { int j = stream . readBits ( 8 ) ; if ( j < playerCount ) { for ( int k = j ; k < playerCount ; k ++ ) anIntArray840 [ anInt839 ++ ] = playerIndices [ k ] ; } if ( j > playerCount ) { signlink . reporterror ( myUsername + " Too many players" ) ; throw new RuntimeException ( "eek" ) ; } playerCount = 0 ; for ( int l = 0 ; l < j ; l ++ ) { int i1 = playerIndices [ l ] ; Player player = playerArray [ i1 ] ; int j1 = stream . readBits ( 1 ) ; if ( j1 == 0 ) { playerIndices [ playerCount ++ ] = i1 ; player . anInt1537 = loopCycle ; } else { int k1 = stream . readBits ( 2 ) ; if ( k1 == 0 ) { playerIndices [ playerCount ++ ] = i1 ; player . anInt1537 = loopCycle ; anIntArray894 [ anInt893 ++ ] = i1 ; } else if ( k1 == 1 ) { playerIndices [ playerCount ++ ] = i1 ; player . anInt1537 = loopCycle ; int l1 = stream . readBits ( 3 ) ; player . moveInDir ( false , l1 ) ; int j2 = stream . readBits ( 1 ) ; if ( j2 == 1 ) anIntArray894 [ anInt893 ++ ] = i1 ; } else if ( k1 == 2 ) { playerIndices [ playerCount ++ ] = i1 ; player . anInt1537 = loopCycle ; int i2 = stream . readBits ( 3 ) ; player . moveInDir ( true , i2 ) ; int k2 = stream . readBits ( 3 ) ; player . moveInDir ( true , k2 ) ; int l2 = stream . readBits ( 1 ) ; if ( l2 == 1 ) anIntArray894 [ anInt893 ++ ] = i1 ; } else if ( k1 == 3 ) anIntArray840 [ anInt839 ++ ] = i1 ; } } }
tr	8	public static void main ( String [ ] args ) { String traceFile , ignoreFile , knownFile , tmp ; int stackLimit = 50 ; CommandLine cmd = null ; Options options = new Options ( ) ; options . addOption ( "f" , "trace_file" , true , "dalvik method profiling trace file" ) ; options . addOption ( "i" , "ignore_pattern_list" , true , "file containing patterns of classes to be ignored" ) ; options . addOption ( "k" , "known_method_list" , true , "file containing methods whose details are to be hidden" ) ; options . addOption ( "s" , "stack_limit" , true , "maximum number of stacks to be printed" ) ; CommandLineParser parser = new PosixParser ( ) ; try { cmd = parser . parse ( options , args ) ; } catch ( ParseException e ) { System . out . println ( e . getMessage ( ) ) ; printHelp ( options ) ; return ; } traceFile = cmd . getOptionValue ( "f" ) ; if ( traceFile == null ) { System . out . println ( "please specify trace file" ) ; printHelp ( options ) ; return ; } ignoreFile = cmd . getOptionValue ( "i" ) ; knownFile = cmd . getOptionValue ( "k" ) ; tmp = cmd . getOptionValue ( "s" ) ; if ( tmp != null ) { stackLimit = Integer . parseInt ( tmp ) ; } tracedump d = new tracedump ( ) ; if ( ignoreFile != null ) { if ( ! d . parseIgnore ( ignoreFile ) ) { System . out . println ( "failed to parse " + ignoreFile ) ; return ; } } if ( knownFile != null ) { if ( ! d . parseKnown ( ( knownFile ) ) ) { System . out . println ( "failed to parse " + knownFile ) ; return ; } } if ( ! d . parseTrace ( traceFile ) ) { System . out . println ( "failed to parse " + traceFile ) ; return ; } d . dump ( stackLimit ) ; }
tr	5	public String testCorpus ( CmdOptions parser , Option corpus , boolean stdin ) { String corpusValue = ( String ) parser . getOptionValue ( corpus ) ; if ( corpusValue == null ) { System . err . println ( "BAD USAGE. Corpus must be defined: {-c | --corpus} file" ) ; System . exit ( 0 ) ; } if ( stdin && corpusValue . equalsIgnoreCase ( "-" ) ) return null ; boolean cpok = true ; File cpfile = new File ( corpusValue ) ; if ( ! cpfile . exists ( ) ) { cpok = false ; } if ( ! cpok ) { System . err . println ( "BAD USAGE. Corpus file must be an existing file [" + corpusValue + "]" ) ; System . exit ( 0 ) ; } return corpusValue ; }
tr	4	private void addContent ( ) { ScheduleDAO sdao = new ScheduleDAO ( db . connection ) ; for ( String day : StaticRes . WEEK_DAY_LIST ) { List < Schedule > list = sdao . getScheduleByDayList ( day ) ; TableModel model = new ScheduleTableModel ( list ) ; table = new JTable ( model ) ; table . setSelectionMode ( ListSelectionModel . SINGLE_SELECTION ) ; table . getColumnModel ( ) . getColumn ( 0 ) . setPreferredWidth ( 100 ) ; table . getColumnModel ( ) . getColumn ( 1 ) . setPreferredWidth ( 17 ) ; table . setRowHeight ( 20 ) ; table . addMouseListener ( new java . awt . event . MouseAdapter ( ) { @ Override public void mouseClicked ( java . awt . event . MouseEvent evt ) { if ( evt . getClickCount ( ) == 2 && evt . getButton ( ) == MouseEvent . BUTTON1 ) { int row = ( ( JTable ) evt . getSource ( ) ) . rowAtPoint ( evt . getPoint ( ) ) ; ; if ( row >= 0 ) { Schedule schedule = ( Schedule ) ( ( JTable ) evt . getSource ( ) ) . getValueAt ( row , - 1 ) ; Teacher teacher = ( Teacher ) cbTeacher . getSelectedItem ( ) ; submit ( schedule , teacher ) ; } } } } ) ; tabbedPane . addTab ( day , new JScrollPane ( table ) ) ; } }
tr	6	public String asString ( ) { return ( Xt == XT_STR || Xt == XT_SYMNAME ) ? ( String ) cont : ( ( ( Xt == XT_ARRAY_STR || Xt == XT_VECTOR_STR ) && cont != null && ( ( String [ ] ) cont ) . length > 0 ) ? ( ( String [ ] ) cont ) [ 0 ] : null ) ; }
tr	7	private boolean r_Step_5a ( ) { int v_1 ; int v_2 ; ket = cursor ; if ( ! ( eq_s_b ( 1 , "e" ) ) ) { return false ; } bra = cursor ; lab0 : do { v_1 = limit - cursor ; lab1 : do { if ( ! r_R2 ( ) ) { break lab1 ; } break lab0 ; } while ( false ) ; cursor = limit - v_1 ; if ( ! r_R1 ( ) ) { return false ; } { v_2 = limit - cursor ; lab2 : do { if ( ! r_shortv ( ) ) { break lab2 ; } return false ; } while ( false ) ; cursor = limit - v_2 ; } } while ( false ) ; slice_del ( ) ; return true ; }
tr	4	public TowerLevelEditor ( ) { super ( ) ; setLayout ( cl = new CardLayout ( ) ) ; JLabel lblNothing = new JLabel ( "[ No upgrade level selected ]" ) ; lblNothing . setHorizontalAlignment ( JLabel . CENTER ) ; add ( lblNothing , boolean . toString ( false ) ) ; JPanel pnlEditor = new JPanel ( new BorderLayout ( ) ) ; add ( pnlEditor , boolean . toString ( true ) ) ; PropertySet ps = new PropertySet ( ) ; final FileProperty fpImage = new FileProperty ( "Image (64 \u00D7 64)" , null ) ; final CounterProperty cpCost = new CounterProperty ( "Cost" , 0 , 100 , Integer . MAX_VALUE ) ; final CounterProperty cpFireDelay = new CounterProperty ( "Fire delay" , 0 , 48 , Integer . MAX_VALUE ) ; final CounterProperty cpRange = new CounterProperty ( "Tower range" , 1 , 250 , Integer . MAX_VALUE ) ; final TextProperty tpProjectileType = new TextProperty ( "Projectile type" , null ) ; final CounterProperty cpLaunchSpeed = new CounterProperty ( "Launch speed" , 1 , 10 , Integer . MAX_VALUE ) ; ps . add ( fpImage ) ; ps . add ( null ) ; ps . add ( cpCost ) ; ps . add ( cpFireDelay ) ; ps . add ( cpRange ) ; ps . add ( null ) ; fpImage . setFilter ( ffImage ) ; ps . add ( tpProjectileType ) ; ps . add ( cpLaunchSpeed ) ; cpCost . setDescription ( "The cost to purchase the turret or upgrade to this level." ) ; cpFireDelay . setDescription ( "The delay (in frames) between firings." ) ; cpRange . setDescription ( "The range of this tower (in pixels)." ) ; tpProjectileType . setDescription ( "The type of projectile fired by this tower. This must match the name of one of the projectiles on the Projectile configuration page." ) ; cpLaunchSpeed . setDescription ( "The speed (in pixels/frame) at which the projectiles move after being fired." ) ; ChangeListener cl = new ChangeListener ( ) { @ Override public void stateChanged ( ChangeEvent ce ) { if ( ! isUpdating ( ) ) { contents . image = fpImage . getValue ( ) ; contents . cost = cpCost . getValue ( ) ; contents . fireDelay = cpFireDelay . getValue ( ) ; contents . range = cpRange . getValue ( ) ; contents . projectileType = tpProjectileType . getValue ( ) ; contents . launchSpeed = cpLaunchSpeed . getValue ( ) ; } } } ; for ( AbstractProperty < ? > p : ps ) { if ( p != null ) { p . addChangeListener ( cl ) ; } } pnlEditor . add ( new PropertyPanel ( ps , true , false ) , BorderLayout . CENTER ) ; rUpdate = new Runnable ( ) { @ Override public void run ( ) { fpImage . setValue ( contents . image ) ; cpCost . setValue ( contents . cost ) ; cpFireDelay . setValue ( contents . fireDelay ) ; cpRange . setValue ( contents . range ) ; tpProjectileType . setValue ( contents . projectileType ) ; cpLaunchSpeed . setValue ( contents . launchSpeed ) ; } } ; }
tr	8	public void paint ( Graphics g ) { Rectangle r = new Rectangle ( p1 ) ; r . add ( p2 ) ; if ( in != null ) { g . setColor ( in ) ; if ( canvas . renderMode != RenderMode . TILED ) g . fillRoundRect ( r . x , r . y , r . width , r . height , 16 , 16 ) ; else { Dimension img = canvas . getImageSize ( ) ; for ( int dx = 0 ; r . x + r . width - dx >= 0 ; dx += img . width ) for ( int dy = 0 ; r . y + r . height - dy >= 0 ; dy += img . height ) g . fillRoundRect ( r . x - dx , r . y - dy , r . width , r . height , 16 , 16 ) ; } } if ( out != null ) { g . setColor ( out ) ; if ( canvas . renderMode != RenderMode . TILED ) g . drawRoundRect ( r . x , r . y , r . width , r . height , 16 , 16 ) ; else { Dimension img = canvas . getImageSize ( ) ; for ( int dx = 0 ; r . x + r . width - dx >= 0 ; dx += img . width ) for ( int dy = 0 ; r . y + r . height - dy >= 0 ; dy += img . height ) g . drawRoundRect ( r . x - dx , r . y - dy , r . width , r . height , 16 , 16 ) ; } } }
tr	6	public static void main ( final String [ ] args ) { int value = 0 ; for ( int i = 1 ; i < 10000 ; i ++ ) { if ( i == 6 || i == 28 || i == 496 || i == 8128 ) continue ; if ( isAmicable ( i ) ) { value += i ; } } System . out . println ( value ) ; uptime ( ) ; }
tr	1	public double [ ] getDoubleRandArray ( int size , int scope ) { double [ ] array = new double [ size ] ; Random r = new Random ( ) ; for ( int i = 0 ; i < size ; i ++ ) { array [ i ] = new double ( r . nextDouble ( ) * scope ) ; } return array ; }
tr	7	private double niceNum ( double range , boolean round ) { double exponent ; double fraction ; double niceFraction ; exponent = Math . floor ( Math . log10 ( range ) ) ; fraction = range / Math . pow ( 10 , exponent ) ; if ( round ) { if ( fraction < 1.5 ) niceFraction = 1 ; else if ( fraction < 3 ) niceFraction = 2 ; else if ( fraction < 7 ) niceFraction = 5 ; else niceFraction = 10 ; } else { if ( fraction <= 1 ) niceFraction = 1 ; else if ( fraction <= 2 ) niceFraction = 2 ; else if ( fraction <= 5 ) niceFraction = 5 ; else niceFraction = 10 ; } return niceFraction * Math . pow ( 10 , exponent ) ; }
tr	5	public void updateLocation ( int id , List < Object > list ) { if ( ! handler_location . initialize ( ) ) { System . out . println ( "LocationServer : failed to initialize location handler!" ) ; return ; } int result = 0 , min_rssi = 1000 ; for ( int i = 0 ; i < list . size ( ) ; i += 2 ) { String mac = ( String ) list . get ( i ) ; LocationNode node = handler_location . getLocationNode ( mac ) ; if ( node != null ) { int rssi = ( int ) list . get ( i + 1 ) - node . rssi ; if ( rssi < min_rssi ) { min_rssi = rssi ; result = node . area ; } } } if ( result != 0 ) { handler_location . updateLocation ( id , result ) ; } handler_location . close ( ) ; }
tr	2	public UnitGroupElementOrderProblem ( final String difficulty ) { easyBounds = new Pair ( 5 , 11 ) ; mediumBounds = new Pair ( 11 , 37 ) ; hardBounds = new Pair ( 37 , 97 ) ; final Pair < Integer , Integer > bounds = initBounds ( difficulty ) ; final int lowerBound = bounds . getFirst ( ) ; final int upperBound = bounds . getSecond ( ) ; int element1 = 0 ; int n1 = 0 ; while ( ( ! Algorithms . isCoprime ( element1 , n1 ) ) || ( element1 > n1 ) ) { element1 = Algorithms . randInt ( 2 , 9 ) ; n1 = Algorithms . randInt ( lowerBound , upperBound ) ; } setVariables ( element1 , n1 ) ; }
tr	8	public static Level validateLevel ( String level ) throws DiscoException { if ( level . equalsIgnoreCase ( "ALL" ) ) return Level . ALL ; else if ( level . equalsIgnoreCase ( "TRACE" ) ) return Level . TRACE ; else if ( level . equalsIgnoreCase ( "DEBUG" ) ) return Level . DEBUG ; else if ( level . equalsIgnoreCase ( "INFO" ) ) return Level . INFO ; else if ( level . equalsIgnoreCase ( "WARN" ) ) return Level . WARN ; else if ( level . equalsIgnoreCase ( "ERROR" ) ) return Level . ERROR ; else if ( level . equalsIgnoreCase ( "FATAL" ) ) return Level . FATAL ; else if ( level . equalsIgnoreCase ( "OFF" ) ) return Level . OFF ; else throw new DiscoException ( "Log Level [" + level + "] not valid" ) ; }
tr	9	public TicTacToeGameGUI ( String [ ] playerOne , String [ ] playerTwo ) { super ( WINDOW_TITLE , WINDOW_WIDTH , WINDOW_HEIGHT ) ; if ( playerOne [ 2 ] . equals ( "Cross" ) ) { if ( playerOne [ 1 ] . equals ( "Human" ) ) { setPlayerOne ( new HumanPlayer ( playerOne [ 0 ] , Piece . TicTacToePieceColour . CROSS ) ) ; } else { setPlayerOne ( new TicTacToeComputerPlayer ( playerOne [ 0 ] , Piece . TicTacToePieceColour . CROSS ) ) ; } if ( playerTwo [ 1 ] . equals ( "Human" ) ) { setPlayerTwo ( new HumanPlayer ( playerTwo [ 0 ] , Piece . TicTacToePieceColour . NOUGHT ) ) ; } else { setPlayerTwo ( new TicTacToeComputerPlayer ( playerTwo [ 0 ] , Piece . TicTacToePieceColour . NOUGHT ) ) ; } setPlayerLabel ( playerOne [ 0 ] , "Cross" , playerTwo [ 0 ] , "Nought" ) ; } else { if ( playerOne [ 1 ] . equals ( "Human" ) ) { setPlayerOne ( new HumanPlayer ( playerOne [ 0 ] , Piece . TicTacToePieceColour . NOUGHT ) ) ; } else { setPlayerOne ( new TicTacToeComputerPlayer ( playerOne [ 0 ] , Piece . TicTacToePieceColour . NOUGHT ) ) ; } if ( playerTwo [ 1 ] . equals ( "Human" ) ) { setPlayerTwo ( new HumanPlayer ( playerTwo [ 0 ] , Piece . TicTacToePieceColour . CROSS ) ) ; } else { setPlayerTwo ( new TicTacToeComputerPlayer ( playerTwo [ 0 ] , Piece . TicTacToePieceColour . CROSS ) ) ; } setPlayerLabel ( playerOne [ 0 ] , "Nought" , playerTwo [ 0 ] , "Cross" ) ; } JMenu menu = new JMenu ( "Menu" ) ; add ( menu ) ; JMenuItem newGameButton = new JMenuItem ( "New Game" ) ; JMenuItem saveGameButton = new JMenuItem ( "Save Game" ) ; JMenuItem loadGameButton = new JMenuItem ( "Load Game" ) ; menu . add ( newGameButton ) ; menu . add ( saveGameButton ) ; menu . add ( loadGameButton ) ; JMenuBar menuBar = new JMenuBar ( ) ; menuBar . add ( menu ) ; setJMenuBar ( menuBar ) ; newGameButton . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent event ) { System . out . println ( "new game clicked" ) ; displayPlayAgain ( "Start new game?" ) ; } } ) ; saveGameButton . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent event ) { System . out . println ( "save game clicked" ) ; String saveGame = JOptionPane . showInputDialog ( "Enter save name:" ) ; Date dNow = new Date ( ) ; SimpleDateFormat timeStamp = new SimpleDateFormat ( "H.mm dd.MM.yy" ) ; System . out . println ( "Current Date: " + timeStamp . format ( dNow ) ) ; new TicTacToeGameSaver ( "saves\\tictactoesaves\\" + saveGame + "  [" + timeStamp . format ( dNow ) + "]" + ".xml" ) ; } } ) ; loadGameButton . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent event ) { System . out . println ( "load game clicked" ) ; String saveFile = "" ; String fileExtension = "" ; JFileChooser chooser = new JFileChooser ( ) ; chooser . setCurrentDirectory ( new File ( ".\\saves\\tictactoesaves\\" ) ) ; FileNameExtensionFilter filter = new FileNameExtensionFilter ( "Game saves only" , "xml" ) ; chooser . setFileFilter ( filter ) ; int returnVal = chooser . showOpenDialog ( TicTacToeGameGUI . this ) ; if ( returnVal == JFileChooser . APPROVE_OPTION ) { saveFile = chooser . getSelectedFile ( ) . getName ( ) ; fileExtension = saveFile . substring ( saveFile . lastIndexOf ( "." ) + 1 , saveFile . length ( ) ) ; } if ( fileExtension . equals ( "xml" ) ) { if ( saveFile != "" ) { try { new TicTacToeGameLoader ( "saves\\tictactoesaves\\" + saveFile ) ; } catch ( Exception e ) { System . out . println ( "Corrupted file type." ) ; } } } else { JOptionPane . showMessageDialog ( null , "You have not chosen a game save" ) ; } } } ) ; addWindowListener ( new WindowAdapter ( ) { public void windowClosing ( WindowEvent e ) { int confirmed = JOptionPane . showConfirmDialog ( null , "Are you sure you want to exit the program?" , "Exit Program Message Box" , JOptionPane . YES_NO_OPTION ) ; if ( confirmed == JOptionPane . YES_OPTION ) { dispose ( ) ; } } } ) ; init ( ) ; setDefaultCloseOperation ( JFrame . DO_NOTHING_ON_CLOSE ) ; setSize ( WINDOW_WIDTH , WINDOW_HEIGHT ) ; setLocationRelativeTo ( null ) ; setVisible ( true ) ; setResizable ( false ) ; setIconImage ( new ImageIcon ( this . getClass ( ) . getResource ( "TicTacToe.jpg" ) ) . getImage ( ) ) ; }
tr	8	protected static byte discoverPortal ( IShape shape1 , IShape shape2 ) { getOriginRayDirection ( shape1 , shape2 ) ; MinkowskiDifference . getMinSupport ( e1 , shape1 , shape2 , e0 . v ) ; if ( e1 . v . . ( e0 . v ) >= 0 ) return - 1 ; dir . setCross ( e0 . v , e1 . v ) ; if ( dir . isZero ( ) ) { return 2 ; } MinkowskiDifference . getMaxSupport ( e2 , shape1 , shape2 , dir ) ; if ( e2 . v . . ( dir ) <= 0 ) return - 1 ; v1v0 . setSubtract ( e1 . v , e0 . v ) ; v2v0 . setSubtract ( e2 . v , e0 . v ) ; dir . setCross ( v1v0 , v2v0 ) ; if ( dir . . ( e0 . v ) > 0 ) { final Element e = e1 ; e1 = e2 ; e2 = e ; dir . invert ( ) ; Vector3f s = v1v0 ; v1v0 = v2v0 ; v2v0 = s ; } while ( true ) { MinkowskiDifference . getMaxSupport ( e3 , shape1 , shape2 , dir ) ; if ( e3 . v . . ( dir ) <= 0 ) return - 1 ; if ( temp . setCross ( e1 . v , e3 . v ) . . ( e0 . v ) < 0 ) { set ( e2 , e3 ) ; v2v0 . setSubtract ( e2 . v , e0 . v ) ; } else if ( temp . setCross ( e3 . v , e2 . v ) . . ( e0 . v ) < 0 ) { set ( e1 , e3 ) ; v1v0 . setSubtract ( e1 . v , e0 . v ) ; } else { return 0 ; } dir . setCross ( v1v0 , v2v0 ) ; } }
tr	0	public void setEstudis ( String estudis ) { this . estudis = estudis ; }
tr	8	public static Object subtract ( Object val0 , Object val1 ) { val0 = guess ( val0 ) ; val1 = guess ( val1 ) ; if ( val0 instanceof Color ) return ( ( Color ) val0 ) . subtract ( val1 ) ; if ( val0 instanceof Size ) return ( ( Size ) val0 ) . subtract ( val1 ) ; if ( val0 instanceof Number && val1 instanceof Number ) { if ( val0 instanceof double || val1 instanceof double ) return ( ( Number ) val0 ) . doubleValue ( ) - ( ( Number ) val1 ) . doubleValue ( ) ; return ( ( Number ) val0 ) . intValue ( ) - ( ( Number ) val1 ) . intValue ( ) ; } return val0 == null ? null : val1 == null ? val0 : Classes . toString ( val0 ) . replace ( Classes . toString ( val1 ) , "" ) ; }
tr	5	@ Override public void drawMidground ( Graphics g ) { double scaledImageHeight = ( double ) width / body . getWidth ( ) * body . getHeight ( ) ; double currentX = x ; double currentY = y ; double usableHeight = height ; if ( started ) { currentY += width / 2.0 ; usableHeight -= width / 2.0 ; } if ( ended && started ) { usableHeight -= width / 2.0 ; } int numberOfFullImages = ( int ) ( usableHeight / scaledImageHeight ) ; for ( int i = 0 ; i < numberOfFullImages ; i ++ ) { g . drawImage ( body , ( int ) currentX , ( int ) currentY , ( int ) currentX + width , ( int ) ( currentY + scaledImageHeight ) , 0 , 0 , body . getWidth ( ) , body . getHeight ( ) , null ) ; currentY += scaledImageHeight ; } double leftOverHeight = usableHeight - numberOfFullImages * scaledImageHeight ; double fractionHeight = leftOverHeight / scaledImageHeight ; g . drawImage ( body , ( int ) currentX , ( int ) currentY , ( int ) currentX + width , ( int ) ( currentY + leftOverHeight ) , 0 , 0 , body . getWidth ( ) , ( int ) ( body . getHeight ( ) * fractionHeight ) , null ) ; currentY += leftOverHeight ; if ( ended ) { g . drawImage ( end , ( int ) currentX , ( int ) currentY , ( int ) currentX + width , ( int ) ( currentY + scaledImageHeight ) , 0 , 0 , end . getWidth ( ) , end . getHeight ( ) , null ) ; } }
tr	0	public void setCertmapMgId ( int certmapMgId ) { this . certmapMgId = certmapMgId ; }
tr	4	public void saveFolderDialog ( ) { if ( ! open . exists ( ) ) { int sel = fc . showSaveDialog ( this ) ; if ( sel == JFileChooser . CANCEL_OPTION ) return ; else if ( sel == JFileChooser . APPROVE_OPTION ) { open = fc . getSelectedFile ( ) ; } } open . delete ( ) ; open . mkdir ( ) ; try { fm . saveData ( open , qm ) ; JOptionPane . showMessageDialog ( this , "Data saved to " + open . getAbsolutePath ( ) + "!" , "SkyQuest Utility" , JOptionPane . INFORMATION_MESSAGE ) ; } catch ( IOException e ) { JOptionPane . showMessageDialog ( this , "An error has occurred: " + e . getMessage ( ) , "SkyQuest Utility" , JOptionPane . ERROR_MESSAGE ) ; e . printStackTrace ( ) ; } changed = false ; setTitle ( "SkyQuest Utility - " + open . getPath ( ) ) ; }
tr	4	public String hash ( ) { if ( this . lshCode != null ) { return this . lshCode ; } if ( ! this . lshCodeValid ) { return null ; } LshBinStruct tmp = new LshBinStruct ( ) ; for ( int k = 0 ; k < TLSH_CHECKSUM_LEN ; k ++ ) { tmp . checksum [ k ] = swapByte ( this . lshBin . checksum [ k ] ) ; } tmp . lValue = swapByte ( this . lshBin . lValue ) ; tmp . Q = swapByte ( this . lshBin . Q ) ; for ( int i = 0 ; i < CODE_SIZE ; i ++ ) { tmp . tmpCode [ i ] = this . lshBin . tmpCode [ CODE_SIZE - 1 - i ] ; } this . lshCode = toHex ( tmp . checksum ) ; this . lshCode += toHex ( new int [ ] { tmp . lValue } ) ; this . lshCode += toHex ( new int [ ] { tmp . Q } ) ; this . lshCode += toHex ( tmp . tmpCode ) ; return this . lshCode ; }
tr	1	public double getRadius ( ) { if ( launched ) return 0 ; return 15 ; }
tr	2	static float fromdBlook ( float a ) { int i = ( int ) ( a * ( ( float ) ( - ( 1 << FROMdB2_SHIFT ) ) ) ) ; return ( i < 0 ) ? 1.f : ( ( i >= ( FROMdB_LOOKUP_SZ << FROMdB_SHIFT ) ) ? 0.f : FROMdB_LOOKUP [ i >>> FROMdB_SHIFT ] * FROMdB2_LOOKUP [ i & FROMdB2_MASK ] ) ; }
tr	7	public void check_reductions ( ) throws internal_error { parse_action act ; production prod ; for ( int row = 0 ; row < num_states ( ) ; row ++ ) { for ( int col = 0 ; col < under_state [ row ] . size ( ) ; col ++ ) { act = under_state [ row ] . under_term [ col ] ; if ( act != null && act . kind ( ) == parse_action . REDUCE ) { ( ( reduce_action ) act ) . reduce_with ( ) . note_reduction_use ( ) ; } } } for ( Enumeration p = production . all ( ) ; p . hasMoreElements ( ) ; ) { prod = ( production ) p . nextElement ( ) ; if ( prod . num_reductions ( ) == 0 ) { if ( ! emit . nowarn ) { System . err . println ( "*** Production \"" + prod . to_simple_string ( ) + "\" never reduced" ) ; lexer . warning_count ++ ; } } } }
tr	9	public static JSONArray rowToJSONArray ( JSONTokener x ) throws JSONException { JSONArray ja = new JSONArray ( ) ; for ( ; ; ) { String value = getValue ( x ) ; char c = x . next ( ) ; if ( value == null || ( ja . length ( ) == 0 && value . length ( ) == 0 && c !=   ) ) { return null ; } ja . put ( value ) ; for ( ; ; ) { if ( c ==   ) { break ; } if ( c !=   ) { if ( c == '' || c == '' || c == 0 ) { return ja ; } throw x . syntaxError ( "Bad character '" + c + "' (" + ( int ) c + ")." ) ; } c = x . next ( ) ; } } }
tr	5	public vslVersion ( Vector < vslVersion > prev , Vector < ? extends vslChunk > oldChunks , Vector < ? extends vslChunk > newChunks ) { if ( prev != null ) { this . prev . addAll ( prev ) ; } if ( oldChunks != null ) { this . oldChunks . addAll ( oldChunks ) ; } if ( newChunks != null ) { this . newChunks . addAll ( newChunks ) ; } createTime = new vslDate ( ) ; }
tr	7	@ Override public void init ( ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( PokemonMoveset . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( PokemonMoveset . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( PokemonMoveset . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( PokemonMoveset . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } try { java . awt . EventQueue . invokeAndWait ( new Runnable ( ) { public void run ( ) { initComponents ( ) ; } } ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; } }
tr	0	public boolean inGameStateNextFrame ( String state ) { return el . inGameStateNextFrame ( state ) ; }
tr	8	@ Override public List < ChessPosition > getTargetPos ( ChessPosition current ) { List < ChessPosition > pos = new ArrayList < ChessPosition > ( ) ; int x , y , upBound , lowBound , leftBound , rightBound , value , cy , cx ; int Tdx [ ] = { 0 , - 1 , 1 , 2 , 2 , 1 , - 1 , - 2 , - 2 } ; int Tdy [ ] = { 0 , - 2 , - 2 , - 1 , 1 , 2 , 2 , 1 , - 1 } ; int dx [ ] = { 0 , 0 , 1 , 0 , - 1 } ; int dy [ ] = { 0 , - 1 , 0 , 1 , 0 } ; ChessPosition CpTemp ; x = current . getCol ( ) ; y = current . getRow ( ) ; value = board . getTable ( ) [ y ] [ x ] ; x = current . getCol ( ) ; y = current . getRow ( ) ; value = board . getTable ( ) [ y ] [ x ] ; upBound = 0 ; lowBound = 9 ; leftBound = 0 ; rightBound = 8 ; for ( int i = 1 ; i <= 8 ; i ++ ) { x = current . getCol ( ) + Tdx [ i ] ; y = current . getRow ( ) + Tdy [ i ] ; cx = current . getCol ( ) + dx [ ( i + 1 ) / 2 ] ; cy = current . getRow ( ) + dy [ ( i + 1 ) / 2 ] ; if ( ( ( x >= leftBound ) && ( x <= rightBound ) ) && ( ( y >= upBound ) && ( y <= lowBound ) ) ) { if ( ( board . getTable ( ) [ y ] [ x ] != 0 ) && ( board . getTable ( ) [ cy ] [ cx ] == 0 ) ) { if ( board . getTable ( ) [ y ] [ x ] * value < 0 ) { CpTemp = new ChessPosition ( x , y , true ) ; } else { CpTemp = new ChessPosition ( x , y , false ) ; } pos . add ( CpTemp ) ; } } } return pos ; }
tr	1	public Set < Pheromone > getPheromonesSupprimeesAt ( int tour ) { Set < Pheromone > supprimees = this . pheromonesSupprimees . get ( tour ) ; if ( supprimees == null ) { return new HashSet < Pheromone > ( ) ; } else { return supprimees ; } }
tr	0	Packet ( Packet link , int id , int kind ) { this . link = link ; this . id = id ; this . kind = kind ; }
tr	2	public boolean mustProceedSecondScan ( ) { for ( IStringAnalyser analyzer : stringAnalysers ) { if ( analyzer . isTwoScansAnalyzer ( ) ) { return true ; } } return false ; }
