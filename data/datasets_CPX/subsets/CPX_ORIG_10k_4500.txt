tr	3	public void recenter ( Location loc ) { originRow = loc . getRow ( ) ; originCol = loc . getCol ( ) ; repaint ( ) ; JViewport vp = getEnclosingViewport ( ) ; if ( vp != null ) { if ( ! isPannableUnbounded ( ) || ! ( vp instanceof PseudoInfiniteViewport ) ) vp . setViewPosition ( pointForLocation ( loc ) ) ; else showPanTip ( ) ; } }
tr	0	public List < AST > getChild ( ) { return child ; }
tr	2	@ Override public Product readObject ( ) throws IOException { if ( receivedProducts == null ) { receivedProducts = openJpaCon . getProductsfromDB ( 10 ) ; } if ( ! receivedProducts . isEmpty ( ) ) { Product receivedProduct = receivedProducts . get ( 0 ) ; System . out . println ( receivedProduct . getId ( ) ) ; receivedProducts . remove ( 0 ) ; return receivedProduct ; } else receivedProducts = null ; return null ; }
tr	7	public void withdraw ( ) { String number = currentAccountNumber ( ) ; if ( number != null ) { String s = JOptionPane . showInputDialog ( this , "Enter amount to draw:" , "Draw Money" , JOptionPane . QUESTION_MESSAGE ) ; if ( s != null ) { try { double amount = double . parseDouble ( s ) ; Account a = accounts . get ( number ) ; a . withdraw ( amount ) ; fld_balance . setText ( currencyFormat ( a . getBalance ( ) ) ) ; } catch ( NumberFormatException e ) { JOptionPane . showMessageDialog ( this , "Illegal Value" , "Error" , JOptionPane . ERROR_MESSAGE ) ; } catch ( IllegalArgumentException e ) { JOptionPane . showMessageDialog ( this , "Illegal Argument" , "Error" , JOptionPane . ERROR_MESSAGE ) ; } catch ( InactiveException e ) { JOptionPane . showMessageDialog ( this , "Account is inactive" , "Error" , JOptionPane . ERROR_MESSAGE ) ; } catch ( OverdrawException e ) { JOptionPane . showMessageDialog ( this , "Account must not be overdrawn" , "Error" , JOptionPane . ERROR_MESSAGE ) ; } catch ( Exception e ) { error ( e ) ; } } } }
tr	8	public static void main ( String args [ ] ) throws Exception { if ( ( args . length < 2 ) || ( args . length > 3 ) ) throw new IllegalArgumentException ( "\u53C2\u6570\u4E0D\u6B63\u786E" ) ; String server = args [ 0 ] ; byte [ ] argument = args [ 1 ] . getBytes ( ) ; int servPort = ( args . length == 3 ) ? Integer . parseInt ( args [ 2 ] ) : 7 ; SocketChannel clntChan = SocketChannel . open ( ) ; clntChan . configureBlocking ( false ) ; if ( ! clntChan . connect ( new InetSocketAddress ( server , servPort ) ) ) { while ( ! clntChan . finishConnect ( ) ) { System . out . print ( "." ) ; } } System . out . print ( "\n" ) ; ByteBuffer writeBuf = ByteBuffer . wrap ( argument ) ; ByteBuffer readBuf = ByteBuffer . allocate ( argument . length ) ; int totalBytesRcvd = 0 ; int bytesRcvd ; while ( totalBytesRcvd < argument . length ) { if ( writeBuf . hasRemaining ( ) ) { clntChan . write ( writeBuf ) ; } if ( ( bytesRcvd = clntChan . read ( readBuf ) ) == - 1 ) { throw new SocketException ( "Connection closed prematurely" ) ; } totalBytesRcvd += bytesRcvd ; System . out . print ( "." ) ; } System . out . println ( "Received: " + new String ( readBuf . array ( ) , 0 , totalBytesRcvd ) ) ; clntChan . close ( ) ; }
tr	0	public IntersectionInfo ( HashMap < String , Integer [ ] > roadIntersections ) { this . roadIntersections = roadIntersections ; }
tr	9	@ Override public boolean equals ( Object obj ) { Media m = ( Media ) obj ; return ( uri . equals ( m . uri ) && title . equals ( m . title ) && ( width == m . width ) && height == ( m . height ) && format . equals ( m . format ) && ( duration == m . duration ) && ( size == m . size ) && ( bitrate == m . bitrate ) && persons [ 0 ] . equals ( m . persons [ 0 ] ) && persons [ 1 ] . equals ( m . persons [ 1 ] ) && player . equals ( m . player ) && ( copyright == m . copyright ) ) ; }
tr	0	public void setId ( long value ) { this . id = value ; }
tr	7	private String [ ] getStringArray ( JComponent comp ) { if ( comp instanceof JComboBox ) { JComboBox comboBox = ( JComboBox ) comp ; List < String > list = new ArrayList < String > ( ) ; if ( comboBox . getItemCount ( ) > 0 ) { for ( int i = 0 ; i < comboBox . getItemCount ( ) ; i ++ ) { if ( ! isEmpty ( comboBox . getItemAt ( i ) ) ) { add ( list , comboBox . getItemAt ( i ) ) ; } else if ( ! isEmpty ( comboBox . getSelectedItem ( ) ) ) { add ( list , comboBox . getSelectedItem ( ) ) ; } } if ( list . size ( ) > 0 ) { return list . toArray ( new String [ 1 ] ) ; } else { return null ; } } else { if ( ! isEmpty ( comboBox . getSelectedItem ( ) ) ) { add ( list , comboBox . getSelectedItem ( ) ) ; return list . toArray ( new String [ 1 ] ) ; } } } return null ; }
tr	9	public Board checkPawnPromotion ( ) { for ( Piece p : this . gm . getBoard ( ) . getPieces ( ) ) { if ( p instanceof Pawn && p . isWhite ( ) == isWhite ) { Pawn pawn = ( Pawn ) p ; if ( pawn . canPromote ( ) && ! pawn . isPromoted ( ) ) { pawn . setHasPromoted ( true ) ; JPanel panel = new JPanel ( new GridLayout ( 2 , 1 ) ) ; JLabel label = new JLabel ( "What would you like to promote your pawn to?" ) ; JComboBox < String > selection = new JComboBox < String > ( new String [ ] { "Queen" , "Knight" , "Bishop" , "Rook" } ) ; String [ ] options = new String [ ] { "OK" } ; panel . add ( label ) ; panel . add ( selection ) ; int hasClosed = JOptionPane . CLOSED_OPTION ; while ( hasClosed == JOptionPane . CLOSED_OPTION ) { hasClosed = JOptionPane . showOptionDialog ( null , panel , "Pawn Promotion" , JOptionPane . DEFAULT_OPTION , JOptionPane . QUESTION_MESSAGE , null , options , options [ 0 ] ) ; } Board bClone = gm . getBoard ( ) . clone ( ) ; Piece newPiece = null ; switch ( selection . getSelectedIndex ( ) ) { case 0 : newPiece = new Queen ( p ) ; bClone . addMove ( new int [ ] { newPiece . getUID ( ) , newPiece . getX ( ) , newPiece . getY ( ) , - 100 } ) ; break ; case 1 : newPiece = new Knight ( p ) ; bClone . addMove ( new int [ ] { newPiece . getUID ( ) , newPiece . getX ( ) , newPiece . getY ( ) , - 200 } ) ; break ; case 2 : newPiece = new Bishop ( p ) ; bClone . addMove ( new int [ ] { newPiece . getUID ( ) , newPiece . getX ( ) , newPiece . getY ( ) , - 300 } ) ; break ; case 3 : newPiece = new Rook ( p ) ; bClone . addMove ( new int [ ] { newPiece . getUID ( ) , newPiece . getX ( ) , newPiece . getY ( ) , - 400 } ) ; break ; default : newPiece = p ; bClone . addMove ( new int [ ] { newPiece . getUID ( ) , newPiece . getX ( ) , newPiece . getY ( ) } ) ; break ; } bClone . removePiece ( p ) ; bClone . addPiece ( newPiece ) ; bClone . setPrevTiles ( gm . getBoard ( ) . getPrevTiles ( ) ) ; return bClone ; } } } return null ; }
tr	8	public static DatabaseType insertBroker ( JFrame frame ) { JPanel panel = new JPanel ( new BorderLayout ( 5 , 5 ) ) ; JPanel label = new JPanel ( new GridLayout ( 3 , 1 , 2 , 2 ) ) ; label . add ( new JLabel ( "Broker Number" , SwingConstants . RIGHT ) ) ; label . add ( new JLabel ( "Rating" , SwingConstants . RIGHT ) ) ; label . add ( new JLabel ( "Bank market code" , SwingConstants . RIGHT ) ) ; panel . add ( label , BorderLayout . WEST ) ; JPanel controls = new JPanel ( new GridLayout ( 3 , 1 , 2 , 2 ) ) ; JTextField relationF = new JTextField ( ) ; relationF . setToolTipText ( "Insert the broker's id  which should be an integer number!" ) ; TextPrompt relationP = new TextPrompt ( "12345" , relationF ) ; relationP . setForeground ( Color . RED ) ; relationP . changeAlpha ( 0.5f ) ; relationP . changeStyle ( Font . BOLD + Font . ITALIC ) ; controls . add ( relationF ) ; JTextField ratingF = new JTextField ( ) ; ratingF . setToolTipText ( "Insert the rating for the Broker  which should be an integer between 0 and 10" ) ; TextPrompt ratingP = new TextPrompt ( "7" , ratingF ) ; ratingP . setForeground ( Color . RED ) ; ratingP . changeAlpha ( 0.5f ) ; ratingP . changeStyle ( Font . BOLD + Font . ITALIC ) ; controls . add ( ratingF ) ; JTextField market_codeF = new JTextField ( ) ; market_codeF . setToolTipText ( "Type the market code of the bank where this account is stored at. Like RT.b" ) ; TextPrompt market_codeP = new TextPrompt ( "RBS.L" , market_codeF ) ; market_codeP . setForeground ( Color . RED ) ; market_codeP . changeAlpha ( 0.5f ) ; market_codeP . changeStyle ( Font . BOLD + Font . ITALIC ) ; controls . add ( market_codeF ) ; controls . setPreferredSize ( new Dimension ( 300 , 100 ) ) ; panel . add ( controls , BorderLayout . CENTER ) ; while ( JOptionPane . showConfirmDialog ( frame , panel , "Add" , JOptionPane . OK_CANCEL_OPTION ) == 0 ) { String id = relationF . getText ( ) ; String rating = ratingF . getText ( ) ; String market_code = market_codeF . getText ( ) . toUpperCase ( ) ; boolean validData = true ; try { Integer . parseInt ( id ) ; } catch ( Exception e ) { validData = false ; JOptionPane . showMessageDialog ( frame , "Broker id must be integer number!" ) ; } try { int i = Integer . parseInt ( rating ) ; if ( i < 0 || i > 10 ) throw new Exception ( ) ; } catch ( Exception e ) { validData = false ; JOptionPane . showMessageDialog ( frame , "Rating should be integer between 0 and 10!" ) ; } if ( market_code . length ( ) > 10 || ! market_code . matches ( "[A-z]+|[A-z]+.[A-z]+" ) ) { JOptionPane . showMessageDialog ( frame , "Market code maximum allowed 10 alphabetical characters + the dot (.) sign!" ) ; validData = false ; } if ( validData ) { return new Broker ( Integer . parseInt ( id ) , Integer . parseInt ( rating ) , market_code ) ; } } return null ; }
tr	0	@ AfterClass public static void tearDownClass ( ) { }
tr	5	private static void undo ( Change c ) { switch ( c . type ) { case AMBIENCE : c . block . setAmbienceIndex ( ( int ) c . before ) ; break ; case MUSIC : c . block . setMusicIndex ( ( int ) c . before ) ; break ; case MAPICON : c . block . setMapIcon ( ( MapIcon ) c . before ) ; break ; case COLLISION_TILE : c . block . setCollisionLayer ( ( CollisionLayer ) c . before ) ; break ; case LAYER_CHANGE : c . block . replaceLayer ( ( Layer ) c . after , ( Layer ) c . before ) ; editor . layerPanel . updateLayerListSelection ( ( Layer ) c . before ) ; break ; default : ZettaUtil . log ( "Unknown Change " + c ) ; return ; } }
tr	3	public String getResultDetail ( int index ) { if ( ! detail ) return null ; if ( index < 0 || index >= getResultCount ( ) ) throw new IllegalArgumentException ( class + ": illegal value for index" ) ; return details . get ( index ) ; }
tr	5	private static String normalized ( String s ) { if ( s == null ) return null ; StringBuffer buf = new StringBuffer ( ) ; boolean seenCR = false ; for ( int i = 0 ; i < s . length ( ) ; ++ i ) { char ch = s . charAt ( i ) ; if ( ch == '' ) { buf . append ( '' ) ; seenCR = true ; } else if ( ch == '' ) { if ( ! seenCR ) { buf . append ( ch ) ; } seenCR = false ; } else { buf . append ( ch ) ; seenCR = false ; } } s = buf . toString ( ) ; return s ; }
tr	0	@ Override public List < POS [ ] > getPOSPairs ( ) { return posPairs ; }
tr	3	@ Override public String execute ( ) throws Exception { try { Map session = ActionContext . getContext ( ) . getSession ( ) ; user = ( User ) session . get ( "User" ) ; Criteria ucri = myDao . getDbsession ( ) . createCriteria ( User . class ) ; ucri . add ( Restrictions . not ( Restrictions . = ( "emailId" , "admin@adzappy.com" ) ) ) ; ucri . add ( Restrictions . or ( Restrictions . like ( "emailId" , s + "%" ) , Restrictions . like ( "userName" , s + "%" ) ) ) ; ucri . setMaxResults ( 50 ) ; setAlluserlist ( ( List < User > ) ucri . list ( ) ) ; addActionMessage ( getAlluserlist ( ) . size ( ) + "\t\tResults Found" ) ; return "success" ; } catch ( HibernateException e ) { addActionError ( "Server  Error Please Try Again " ) ; e . printStackTrace ( ) ; return "error" ; } catch ( NullPointerException ne ) { addActionError ( "Server  Error Please Try Agains " ) ; ne . printStackTrace ( ) ; return "error" ; } catch ( Exception e ) { addActionError ( "Server  Error Please Try Again " ) ; e . printStackTrace ( ) ; return "error" ; } }
tr	5	private Point chooseRandomLocation ( ) { Point randomLocation ; ArrayList < Point > listOfEmptyLocations = new ArrayList < > ( ) ; Location [ ] [ ] locations = this . board . getBoardLocations ( ) ; for ( int row = 0 ; row < locations . length ; row ++ ) { Location [ ] rowLocations = locations [ row ] ; for ( int col = 0 ; col < rowLocations . length ; col ++ ) { Player playerAtLocation = rowLocations [ col ] . getPlayer ( ) ; if ( playerAtLocation == null ) { listOfEmptyLocations . add ( new Point ( row , col ) ) ; } } } int noOfEmptyLocations = listOfEmptyLocations . size ( ) ; if ( noOfEmptyLocations == 0 ) { return null ; } else if ( listOfEmptyLocations . size ( ) == 1 ) { randomLocation = listOfEmptyLocations . get ( 0 ) ; return randomLocation ; } else { int randomNumber = new Random ( ) . nextInt ( noOfEmptyLocations ) ; randomLocation = listOfEmptyLocations . get ( randomNumber ) ; return randomLocation ; } }
tr	9	@ Override public PaginationSupport < T > handle ( ResultSet rs ) throws SQLException { PaginationSupport < T > ps = new PaginationSupport < T > ( ) ; int cur = rsl . getStartPage ( ) * rsl . getPageSize ( ) + 1 ; boolean atLast = false ; if ( cur > 1 ) { if ( ! rs . absolute ( cur - 1 ) ) { atLast = true ; } } List < T > ls = new ArrayList < T > ( ) ; int count = 0 ; if ( atLast ) { count = - 1 ; } else { atLast = true ; while ( rs . next ( ) ) { ls . add ( rowProcessor . toBean ( rs , pojoType ) ) ; if ( ls . size ( ) >= rsl . getPageSize ( ) ) { atLast = false ; break ; } } } if ( atLast ) { if ( count == - 1 ) { count = 0 ; } else { count = cur - 1 + ls . size ( ) ; } } else { if ( rs . last ( ) ) { count = rs . getRow ( ) ; } else { count = 0 ; } } ps . setObject ( ls ) ; ps . setCurrentPage ( rsl . getStartPage ( ) ) ; ps . setPageCount ( ( int ) ( count / rsl . getPageSize ( ) + ( count % rsl . getPageSize ( ) > 0 ? 1 : 0 ) ) ) ; ps . setPageSize ( rsl . getPageSize ( ) ) ; ps . setTotalCount ( count ) ; return ps ; }
tr	5	public Image getTileImage ( int x , int y ) { switch ( level . fields [ y ] [ x ] ) { case dest : return iDest ; case floor : return iFloor ; case grass : return iGrass ; case src : return iSrc ; case wall : return iWall ; default : return null ; } }
tr	8	public String toKML ( boolean suppressEnclosingTags ) { String kml = "" ; if ( ! suppressEnclosingTags ) { kml += "<BalloonStyle" ; if ( this . id != null ) { kml += " id=\"" + this . getId ( ) + "\"" ; } if ( this . targetId != null ) { kml += " targetId=\"" + this . getTargetId ( ) + "\"" ; } kml += ">\n" ; } kml += super . toKML ( true ) ; if ( this . color != null ) { kml += "<color>" + SpecialCaseFormatter . toKMLString ( this . color ) + "</color>\n" ; } if ( this . bgColor != null ) { kml += "<bgColor>" + SpecialCaseFormatter . toKMLString ( this . bgColor ) + "</bgColor>\n" ; } if ( this . textColor != null ) { kml += "<textColor>" + SpecialCaseFormatter . toKMLString ( this . textColor ) + "</textColor>\n" ; } if ( this . text != null ) { kml += "<text>" + SpecialCaseFormatter . toKMLString ( this . text ) + "</text>\n" ; } if ( ! suppressEnclosingTags ) { kml += "</BalloonStyle>\n" ; } return kml ; }
tr	4	public void run ( ) { if ( Logger . getDebugValue ( ) == 3 ) { System . out . println ( "run() of " + Thread . currentThread ( ) . getName ( ) + " is called." ) ; } String word ; Set < MusicInfo > info_found ; while ( ( word = readFile . readWordFromSearchFile ( ) ) != null ) { info_found = store . find ( word ) ; if ( info_found != null ) { Iterator < MusicInfo > iter = info_found . iterator ( ) ; while ( iter . hasNext ( ) ) { results . add ( iter . next ( ) ) ; } } } }
tr	2	public Map < long , Map < long , long >> read ( File f ) throws IOException { Map < long , Map < long , long >> fm = new TreeMap < long , Map < long , long >> ( ) ; BufferedReader br = new BufferedReader ( new FileReader ( f ) ) ; String ln = br . readLine ( ) ; StringTokenizer stk ; long key1 ; while ( ln != null ) { stk = new StringTokenizer ( ln ) ; key1 = long . parseLong ( stk . nextToken ( ) ) ; if ( ! fm . containsKey ( key1 ) ) { fm . put ( key1 , new TreeMap < long , long > ( ) ) ; } fm . get ( key1 ) . put ( long . parseLong ( stk . nextToken ( ) ) , long . parseLong ( stk . nextToken ( ) ) ) ; } br . close ( ) ; return fm ; }
tr	6	public String toString ( ) { if ( toStr != null ) return toStr ; toStr = new String ( ) ; for ( int i = MRTConstants . ATTRIBUTE_AS_PATH ; i <= MRTConstants . ATTRIBUTE_AGGREGATOR ; i ++ ) { if ( attributes . elementAt ( i ) != null ) toStr = toStr . concat ( attributes . elementAt ( i ) . toString ( ) ) ; else { if ( i == MRTConstants . ATTRIBUTE_LOCAL_PREF || i == MRTConstants . ATTRIBUTE_MULTI_EXIT ) toStr = toStr . concat ( "0" ) ; else if ( i == MRTConstants . ATTRIBUTE_ATOMIC_AGGREGATE ) toStr = toStr . concat ( "NAG" ) ; } toStr = toStr . concat ( "|" ) ; } return toStr ; }
tr	7	public static void bubbleSortImproved ( int [ ] a ) { System . out . println ( "Array before sorting" ) ; for ( int i : a ) System . out . print ( i + " " ) ; System . out . println ( ) ; System . out . println ( "Sorting sequences after each iteration" ) ; int n = a . length ; boolean swapped = true ; for ( int i = 0 ; i < n && swapped ; i ++ ) { swapped = false ; for ( int j = 0 ; j < ( n - i - 1 ) ; j ++ ) { if ( a [ j ] > a [ j + 1 ] ) { int temp = a [ j ] ; a [ j ] = a [ j + 1 ] ; a [ j + 1 ] = temp ; swapped = true ; } } for ( int k : a ) System . out . print ( k + " " ) ; System . out . println ( ) ; } System . out . println ( "Array after sorting" ) ; for ( int i : a ) System . out . print ( i + " " ) ; }
tr	4	public static void compute_first_sets ( ) throws internal_error { boolean change = true ; Enumeration n ; Enumeration p ; non_terminal nt ; production prod ; terminal_set prod_first ; while ( change ) { change = false ; for ( n = all ( ) ; n . hasMoreElements ( ) ; ) { nt = ( non_terminal ) n . nextElement ( ) ; for ( p = nt . productions ( ) ; p . hasMoreElements ( ) ; ) { prod = ( production ) p . nextElement ( ) ; prod_first = prod . check_first_set ( ) ; if ( ! prod_first . is_subset_of ( nt . _first_set ) ) { change = true ; nt . _first_set . add ( prod_first ) ; } } } } }
tr	1	public void insertGmedHistory ( String gmedhistory , Integer patientId ) { this . openConnection ( ) ; try { StringBuffer st = new StringBuffer ( ) ; st . append ( "UPDATE patient SET gmedhistory = ?" ) ; st . append ( "WHERE id = ?" ) ; PreparedStatement ins = c . prepareStatement ( st . toString ( ) ) ; ins . setString ( 1 , gmedhistory ) ; ins . setInt ( 2 , patientId ) ; ins . executeUpdate ( ) ; this . close ( ) ; } catch ( SQLException ex ) { Logger . getLogger ( DB . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; DB . db . close ( ) ; } }
tr	2	private static < T > boolean isAllElementsNull ( List < T > list ) { for ( Object object : list ) { if ( object != null ) return false ; } return true ; }
tr	6	@ Override public void validate ( ) { Algorithm algorithm = getAlgorithm ( ) ; for ( int foldIndex = 0 ; foldIndex < k ; foldIndex ++ ) { Set < Pattern > testSet = new HashSet < Pattern > ( folds [ foldIndex ] ) ; Set < Pattern > trainingSet = new DataSet ( getDataSet ( ) ) ; for ( int fold = 0 ; fold < k ; fold ++ ) { if ( fold != foldIndex ) { trainingSet . addAll ( folds [ fold ] ) ; } } algorithm . setTrainSet ( ( DataSet ) trainingSet ) ; algorithm . train ( ) ; for ( Pattern instance : testSet ) { if ( algorithm instanceof Classifier ) { int calculated = ( ( Classifier ) algorithm ) . classify ( instance ) ; int correct = instance . getClassIndex ( ) ; super . evaluate ( calculated , correct ) ; } else if ( algorithm instanceof Recuperator ) { Pattern recuperated = ( ( Recuperator ) algorithm ) . recover ( instance ) ; super . evaluate ( recuperated , instance ) ; } } } }
tr	1	public Giaoducphothong merge ( Giaoducphothong detachedInstance ) { log . debug ( "merging Giaoducphothong instance" ) ; try { Giaoducphothong result = ( Giaoducphothong ) sessionFactory . getCurrentSession ( ) . merge ( detachedInstance ) ; log . debug ( "merge successful" ) ; return result ; } catch ( RuntimeException re ) { log . error ( "merge failed" , re ) ; throw re ; } }
tr	6	FilterProperties ( Frame f , FilterBox parent ) { super ( f , "Filter Properties" , parent ) ; pa = parent ; Panel p = new Panel ( ) ; GridBagLayout gbl = new GridBagLayout ( ) ; p . setLayout ( gbl ) ; GridBagConstraints c = new GridBagConstraints ( ) ; Label l = new Label ( "a(i) = " ) ; c . insets = new Insets ( 2 , 2 , 2 , 0 ) ; gbl . setConstraints ( l , c ) ; p . add ( l ) ; aField = new TextField ( 48 ) ; if ( pa . a != null && pa . a . length > 0 ) { StringBuffer s = new StringBuffer ( double . toString ( pa . a [ 0 ] ) ) ; for ( int i = 1 ; i < pa . a . length ; i ++ ) { s . append ( "  " ) ; s . append ( double . toString ( pa . a [ i ] ) ) ; } aField . setText ( s . toString ( ) ) ; } c . gridwidth = GridBagConstraints . REMAINDER ; c . weightx = 1 ; c . fill = GridBagConstraints . BOTH ; c . insets . left = 0 ; c . insets . right = 2 ; gbl . setConstraints ( aField , c ) ; p . add ( aField ) ; l = new Label ( "b(i) = " ) ; c . gridwidth = 1 ; c . weightx = 0 ; c . insets . left = 2 ; c . insets . right = 0 ; c . fill = GridBagConstraints . NONE ; gbl . setConstraints ( l , c ) ; p . add ( l ) ; bField = new TextField ( 48 ) ; if ( pa . b != null && pa . b . length > 0 ) { StringBuffer s = new StringBuffer ( double . toString ( pa . b [ 0 ] ) ) ; for ( int i = 1 ; i < pa . b . length ; i ++ ) { s . append ( "  " ) ; s . append ( double . toString ( pa . b [ i ] ) ) ; } bField . setText ( s . toString ( ) ) ; } c . gridwidth = GridBagConstraints . REMAINDER ; c . insets . left = 0 ; c . insets . right = 2 ; c . fill = GridBagConstraints . BOTH ; gbl . setConstraints ( bField , c ) ; p . add ( bField ) ; add ( "Center" , p ) ; }
tr	0	public long getTimeToWait ( ) { return this . timeToWait ; }
tr	4	private < T extends Rdp4jListener > void notifyListeners ( class < T > listenerType , Notifier < T > notifier ) throws InterruptedException { for ( Rdp4jListener listener : listeners ) { if ( isInstanceOf ( listener , listenerType ) ) { @ SuppressWarnings ( "unchecked" ) T listener2 = ( T ) listener ; try { notifier . notify ( listener2 ) ; } catch ( InterruptedException e ) { throw e ; } catch ( Throwable e ) { logErrorMessage ( e ) ; } } } }
tr	9	@ Override public void actionPerformed ( ActionEvent ae ) { if ( ae . getActionCommand ( ) . compareTo ( "comboBoxChanged" ) == 0 ) { if ( ae . getSource ( ) == combo_url ) { loadUrlData ( ) ; } else if ( ae . getSource ( ) == combo_grantType ) { if ( combo_grantType . getSelectedIndex ( ) == AUTHORIZATION_GRANT_INDEX ) { OAuthPropertyBean . getInstance ( ) . setGrantType ( OAuthPropertyBean . AUTHORIZATION_GRANT ) ; setupPanels ( ) ; } else if ( combo_grantType . getSelectedIndex ( ) == PASSWORD_GRANT_INDEX ) { OAuthPropertyBean . getInstance ( ) . setGrantType ( OAuthPropertyBean . PASWORD_GRANT ) ; setupPanels ( ) ; } else if ( combo_grantType . getSelectedIndex ( ) == CLIENT_GRANT_INDEX ) { OAuthPropertyBean . getInstance ( ) . setGrantType ( OAuthPropertyBean . CLIENT_CREDENTIALS_GRANT ) ; setupPanels ( ) ; } } } else if ( ae . getActionCommand ( ) . compareTo ( ABOUT_MENUITEM ) == 0 ) { JOptionPane . showMessageDialog ( applicationFrame , "OAuthTestClient\nAn OAuth 2.0 Test Application\nWritten by Ronnie Mitra.\n\nhttps://github.com/mitraman/OAuthTestClient    \n\n" , "About OAuthTestClient" , JOptionPane . QUESTION_MESSAGE ) ; } else if ( ae . getActionCommand ( ) . compareTo ( SETTINGS_MENUITEM ) == 0 ) { SettingsDialog settingsDialog = new SettingsDialog ( applicationFrame ) ; settingsDialog . setVisible ( true ) ; } else if ( ae . getActionCommand ( ) . compareTo ( SAVE_CONFIG_MENUITEM ) == 0 ) { JFileChooser fileChooser = new JFileChooser ( "./OAuthTestClient.cfg" ) ; if ( fileChooser . showSaveDialog ( this ) == JFileChooser . APPROVE_OPTION ) { File file = fileChooser . getSelectedFile ( ) ; ConfigManager . saveProperties ( file ) ; } } else if ( ae . getActionCommand ( ) . compareTo ( LOAD_CONFIG_MENUITEM ) == 0 ) { JFileChooser fileChooser = new JFileChooser ( ) ; if ( fileChooser . showOpenDialog ( this ) == JFileChooser . APPROVE_OPTION ) { File file = fileChooser . getSelectedFile ( ) ; ConfigManager . loadProperties ( file ) ; } } else { System . out . println ( ae . getActionCommand ( ) + " " + ae . getID ( ) ) ; } }
tr	7	public int compareTo ( abort_args other ) { if ( ! getClass ( ) . equals ( other . getClass ( ) ) ) { return getClass ( ) . getName ( ) . compareTo ( other . getClass ( ) . getName ( ) ) ; } int lastComparison = 0 ; abort_args typedOther = ( abort_args ) other ; lastComparison = boolean . valueOf ( is_set_queue_name ( ) ) . compareTo ( typedOther . is_set_queue_name ( ) ) ; if ( lastComparison != 0 ) { return lastComparison ; } if ( is_set_queue_name ( ) ) { lastComparison = org . apache . thrift7 . TBaseHelper . compareTo ( this . queue_name , typedOther . queue_name ) ; if ( lastComparison != 0 ) { return lastComparison ; } } lastComparison = boolean . valueOf ( is_set_ids ( ) ) . compareTo ( typedOther . is_set_ids ( ) ) ; if ( lastComparison != 0 ) { return lastComparison ; } if ( is_set_ids ( ) ) { lastComparison = org . apache . thrift7 . TBaseHelper . compareTo ( this . ids , typedOther . ids ) ; if ( lastComparison != 0 ) { return lastComparison ; } } return 0 ; }
tr	1	public String getString ( String key ) throws JSONException { Object object = get ( key ) ; if ( object instanceof String ) { return ( String ) object ; } throw new JSONException ( "JSONObject[" + quote ( key ) + "] not a string." ) ; }
tr	2	public void Insertar ( String dato , String cuentaBancaria ) { NodoDeLista nuevo ; nuevo = new NodoDeLista ( ) ; nuevo . setDato ( dato ) ; nuevo . setCuentaBancaria ( cuentaBancaria ) ; if ( raiz == null ) { nuevo . setSiguiente ( null ) ; raiz = nuevo ; } else { NodoDeLista auxiliar = raiz ; while ( auxiliar . getSiguiente ( ) != null ) { auxiliar = auxiliar . getSiguiente ( ) ; } auxiliar . setSiguiente ( nuevo ) ; } }
tr	6	public void mouseExited ( MouseEvent e ) { for ( int i = 0 ; i < TOTALHEIGHT ; i ++ ) { for ( int j = 0 ; j < TOTALWIDTH ; j ++ ) { if ( e . getSource ( ) == m_gridButtons [ i ] [ j ] ) { if ( m_board . getPiece ( i , j ) . getPieceColour ( ) . equals ( Piece . OthelloPieceColour . NONE ) ) { m_gridButtons [ i ] [ j ] . setIcon ( m_backgroundTile ) ; } else if ( m_board . getPiece ( i , j ) . getPieceColour ( ) . equals ( Piece . OthelloPieceColour . BLACK ) ) { m_gridButtons [ i ] [ j ] . setIcon ( m_blackPiece ) ; } else if ( m_board . getPiece ( i , j ) . getPieceColour ( ) . equals ( Piece . OthelloPieceColour . WHITE ) ) { m_gridButtons [ i ] [ j ] . setIcon ( m_whitePiece ) ; } } } } }
tr	8	public IReinforcement save ( IReinforcement r ) { if ( r . getDurability ( ) <= 0 ) { delete ( r ) ; return null ; } PlayerReinforcement pr = null ; if ( r instanceof PlayerReinforcement ) { pr = ( PlayerReinforcement ) r ; } IReinforcement old_rein = null ; if ( cache . contains ( r ) ) { old_rein = cache . floor ( r ) ; cache . remove ( old_rein ) ; } else if ( pr != null && pendingDbUpdate . contains ( pr ) ) { old_rein = ( IReinforcement ) pendingDbUpdate . floor ( pr ) ; } if ( pr == null || old_rein == null ) { cache . add ( r ) ; if ( pr != null ) { pendingDbUpdate . add ( pr ) ; } return r ; } ( ( PlayerReinforcement ) old_rein ) . updateFrom ( pr ) ; cache . add ( old_rein ) ; pendingDbUpdate . add ( ( PlayerReinforcement ) old_rein ) ; return old_rein ; }
tr	4	public CombIterator ( final Map < ? extends K , ? extends Iterable < ? extends V >> origin ) throws NullPointerException , IllegalArgumentException { this . iterators = new HashMap < > ( origin . size ( ) ) ; this . template = new LinkedHashMap < > ( origin . size ( ) ) ; for ( final K key : origin . keySet ( ) ) { resume ( key , origin . get ( key ) . iterator ( ) ) ; } this . origin = origin ; }
tr	3	public < T > boolean checkInexactFail ( T actual , T expected , double tolerance , String testname ) { String result = "actual:                                 expected:\n" + Printer . combineActualExpected ( Printer . produceString ( actual ) , Printer . produceString ( expected ) ) + "\n" ; if ( tolerance < 0 ) return this . report ( true , testname + " Failure expected: \n" + "\n Test failed because the provided tolerance is < 0" , result ) ; if ( this . isExactType ( actual . getClass ( ) . getName ( ) ) || this . isExactType ( expected . getClass ( ) . getName ( ) ) ) return report ( true , testname + " Failure expected: \n" + "\nTest failed because we cannot make inexact comparison of " + "exact primitive or wrapper data" , result ) ; setTolerance ( tolerance ) ; this . testname = testname ; return this . report ( ! this . inspector . isSame ( actual , expected ) , "Failure expected: \n" + testname , result ) ; }
tr	1	private void drawCheckerboard ( Graphics2D g ) { Color backupColor = g . getColor ( ) ; Stroke backupStroke = g . getStroke ( ) ; g . setColor ( Color . RED ) ; g . setStroke ( new BasicStroke ( 1.0f ) ) ; g . drawRect ( 0 , 0 , _canvasBackground . getWidth ( ) - 1 , _canvasBackground . getHeight ( ) - 1 ) ; for ( int i = 0 ; i < _imageList . size ( ) ; i ++ ) { IPLNode node = _imageList . get ( i ) ; g . drawRect ( node . getX ( ) , node . getY ( ) , node . getScaleWidth ( ) , node . getScaleHeight ( ) ) ; } g . setColor ( backupColor ) ; g . setStroke ( backupStroke ) ; }
tr	0	public Response delete ( String url , boolean authenticated ) throws WeiboException { return httpRequest ( url , null , authenticated , "DELETE" ) ; }
tr	0	public void setAgility ( int agi ) { this . agility = agi ; }
tr	5	public int findCVTIndex ( String methodName , boolean reverse ) { if ( reverse ) { for ( int i = vt . size ( ) - 1 ; i >= 0 ; i -- ) { if ( vt . get ( i ) . equals ( methodName ) ) { return i ; } } } else { for ( int i = 0 ; i < vt . size ( ) ; i ++ ) { if ( vt . get ( i ) . equals ( methodName ) ) { return i ; } } } return - 1 ; }
tr	5	public static void countLeft2 ( ArrayList < Integer > list , TreeNode node , String s ) { if ( node == null ) return ; StringBuilder sb = new StringBuilder ( ) ; sb . append ( s ) ; while ( node != null ) { sb . append ( String . valueOf ( node . val ) ) ; if ( node . right == null && node . left == null ) { list . add ( Integer . parseInt ( sb . toString ( ) ) ) ; } if ( node . right != null ) { countRight2 ( list , node . right , sb . toString ( ) ) ; } node = node . left ; } }
tr	3	public static String join ( String delim , List < ? > lst ) { StringBuilder ret = new StringBuilder ( ) ; for ( int i = 0 , len = lst . size ( ) ; i < len ; ++ i ) { ret . append ( lst . get ( i ) ) ; if ( i < len - 1 ) { ret . append ( delim ) ; } } return ret . toString ( ) ; }
tr	3	@ Override public boolean canImport ( TransferHandler . TransferSupport info ) { boolean b = ( info . getComponent ( ) == this . table ) && info . isDrop ( ) && info . isDataFlavorSupported ( this . localObjectFlavor ) ; this . table . setCursor ( b ? DragSource . DefaultMoveDrop : DragSource . DefaultMoveNoDrop ) ; return b ; }
tr	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( ListaDinamica . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( ListaDinamica . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( ListaDinamica . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( ListaDinamica . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { new ListaDinamica ( ) . setVisible ( true ) ; } } ) ; }
tr	4	void setupBuffer ( byte [ ] buffer ) { if ( value == null || value . length < length ) { if ( buffer == null || buffer . length < length ) { value = new byte [ length ] ; } else { value = buffer ; } } }
tr	5	@ Override public String toString ( ) { StringBuilder string = new StringBuilder ( game . name ) . append ( " - (" ) . append ( game . getTick ( ) ) . append ( ":" ) . append ( String . format ( "%.3f" , ( double ) game . getFrames ( ) / game . getTick ( ) ) ) . append ( "): " ) ; Alliance no1 = null ; for ( Alliance alliance : this ) { if ( no1 == null || no1 . getScore ( ) < alliance . getScore ( ) ) { no1 = alliance ; } string . append ( alliance . name ) . append ( ": " ) . append ( alliance . getScore ( ) ) . append ( "  " ) ; } return no1 == null ? string . toString ( ) : string . append ( no1 . name ) . append ( no1 . name . endsWith ( "s" ) ? " are" : " is" ) . append ( " winning" ) . toString ( ) ; }
tr	7	public static void main ( String [ ] args ) { boolean all_right ; all_right = true ; int p0 ; int [ ] p1 ; p0 = 6 ; p1 = new int [ ] { 2 , 2 , 2 } ; all_right = KawigiEdit_RunTest ( 0 , p0 , true , p1 ) && all_right ; p0 = 11 ; p1 = new int [ ] { 2 , 3 , 5 } ; all_right = KawigiEdit_RunTest ( 1 , p0 , true , p1 ) && all_right ; p0 = 0 ; p1 = new int [ ] { 7 , 10 , - 70 } ; all_right = KawigiEdit_RunTest ( 2 , p0 , true , p1 ) && all_right ; p0 = 500 ; p1 = new int [ ] { - 400 , - 3 , - 700 } ; all_right = KawigiEdit_RunTest ( 3 , p0 , true , p1 ) && all_right ; p0 = 2 ; p1 = new int [ ] { 2 , 2 , - 2 } ; all_right = KawigiEdit_RunTest ( 4 , p0 , true , p1 ) && all_right ; p0 = 5 ; p1 = new int [ ] { 5 , 2 , - 5 } ; all_right = KawigiEdit_RunTest ( 5 , p0 , true , p1 ) && all_right ; if ( all_right ) { System . out . println ( "You're a stud (at least on the example cases)!" ) ; } else { System . out . println ( "Some of the test cases had errors." ) ; } }
tr	1	public void renderLow ( Parameters params ) { if ( renderer == null ) { throw new IllegalStateException ( "renderer not set" ) ; } image = newImage ( ) ; showImage ( image ) ; int width = image . getWidth ( null ) ; int height = image . getHeight ( null ) ; params . adjustAspect ( width , height ) ; setParameters ( params ) ; imageComponent . setCursor ( waitCursor ) ; renderThread = new Thread ( new RenderRunner ( image , params , renderer ) ) ; renderThread . start ( ) ; }
tr	1	public void send ( ) { try { this . sendMsgs ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; this . close ( ) ; } }
tr	9	@ Override public TIPO_OBJETO get ( TIPO_OBJETO oBean ) throws Exception { class < TIPO_OBJETO > tipo = ( class < TIPO_OBJETO > ) ( ( ParameterizedType ) getClass ( ) . getGenericSuperclass ( ) ) . getActualTypeArguments ( ) [ 0 ] ; Method metodo_getId = tipo . getMethod ( "getId" ) ; Method metodo_setId = tipo . getMethod ( "setId" , Integer . class ) ; if ( ( Integer ) metodo_getId . invoke ( oBean ) > 0 ) { try { oMysql . conexion ( enumTipoConexion ) ; if ( ! oMysql . existsOne ( strTabla , ( Integer ) metodo_getId . invoke ( oBean ) ) ) { metodo_setId . invoke ( oBean , 0 ) ; } else { for ( Method method : tipo . getMethods ( ) ) { if ( ! method . getName ( ) . substring ( 3 ) . equalsIgnoreCase ( "id" ) ) { if ( method . getName ( ) . substring ( 0 , 3 ) . equalsIgnoreCase ( "set" ) ) { final class < ? > strTipoParamMetodoSet = method . getParameterTypes ( ) [ 0 ] ; String strValor = oMysql . getOne ( strTabla , method . getName ( ) . substring ( 3 ) . toLowerCase ( Locale . ENGLISH ) , ( Integer ) metodo_getId . invoke ( oBean ) ) ; if ( strValor != null ) { switch ( strTipoParamMetodoSet . getName ( ) ) { case "java.lang.Double" : method . invoke ( oBean , double . parseDouble ( strValor ) ) ; break ; case "java.lang.Integer" : method . invoke ( oBean , Integer . parseInt ( strValor ) ) ; break ; case "java.util.Date" : SimpleDateFormat format = new SimpleDateFormat ( "yyyy-MM-dd" ) ; method . invoke ( oBean , format . parse ( strValor ) ) ; break ; default : method . invoke ( oBean , strValor ) ; break ; } } } } } } } catch ( Exception e ) { throw new Exception ( "GenericDao.get: Error: " + e . getMessage ( ) ) ; } finally { oMysql . desconexion ( ) ; } } else { metodo_setId . invoke ( oBean , 0 ) ; } return oBean ; }
tr	9	public static void copy ( int [ ] source , int [ ] destination , int sourceIndex , int destinationIndex , int length ) { if ( source == null || destination == null || length < 0 ) { throw new IllegalArgumentException ( ) ; } if ( length == 0 ) { return ; } int sourceLength = source . length ; int destinationLength = destination . length ; if ( sourceIndex >= sourceLength || destinationIndex >= destinationLength ) { throw new IndexOutOfBoundsException ( ) ; } if ( sourceIndex + length > sourceLength || destinationIndex + length > destinationLength ) { throw new IllegalArgumentException ( ) ; } for ( int i = 0 ; i < length ; ++ i ) { destination [ destinationIndex + i ] = source [ sourceIndex + i ] ; } }
tr	0	public UserSessionVO getUserSessionVO ( ) { return userSessionVO ; }
tr	2	public static void main ( String [ ] args ) { HashMap < String , String > hashMap = new HashMap < String , String > ( 4 ) ; hashMap . put ( "andhrapradesh" , "hyderabad" ) ; hashMap . put ( "uttarpradesh" , "allahabad" ) ; hashMap . put ( "karnataka" , "benguluru" ) ; Set < String > s = hashMap . keySet ( ) ; Iterator < String > it = s . iterator ( ) ; while ( it . hasNext ( ) ) { System . out . println ( it . next ( ) . toString ( ) ) ; } hashMap . put ( "tamilnadu" , "chennai" ) ; hashMap . put ( "maharastra" , "mumbai" ) ; hashMap . put ( "gujarat" , "gandhinagar" ) ; hashMap . put ( "punjab" , "chandigarh" ) ; hashMap . put ( "kerala" , "trivendram" ) ; System . out . println ( "after table doubling" ) ; Set < String > s1 = hashMap . keySet ( ) ; Iterator < String > it1 = s . iterator ( ) ; while ( it1 . hasNext ( ) ) { System . out . println ( it1 . next ( ) . toString ( ) ) ; } }
tr	3	public void addIntForKey ( String key ) { ints . add ( key ) ; if ( reference != null ) { ArrayList < GameEntity > entities = reference . getEntities ( ) ; for ( int i = 0 ; i < entities . size ( ) ; i ++ ) { EntityState state = entities . get ( i ) . getState ( ) ; if ( this == state . getReference ( ) ) { StringToInt temp = new StringToInt ( ) ; temp . setKey ( key ) ; state . getInts ( ) . add ( temp ) ; } } } else { System . out . println ( "Major Error :: LevelContainer null :: SavedEntityState" ) ; } }
tr	2	public static String getDate ( String content ) { String header = getHeader ( content ) ; String str [ ] = header . split ( "\n" ) ; for ( int i = 0 ; i < str . length ; i ++ ) { if ( str [ i ] . startsWith ( "Date" ) ) { String str2 [ ] = str [ i ] . split ( ":" , 2 ) ; return str2 [ 1 ] . trim ( ) ; } } return null ; }
tr	2	private int getBaseScore ( Sequence sequence ) { int length = sequence . getSequence ( ) . length ( ) ; if ( length < 4 ) return 10 ; if ( length < 7 ) return 20 ; else return 40 ; }
tr	1	public String [ ] splitByCommas ( String rowToParse ) { StringTokenizer tokenizer = new StringTokenizer ( rowToParse , " " ) ; String [ ] tokens = new String [ tokenizer . countTokens ( ) ] ; for ( int i = 0 ; i < tokens . length ; i ++ ) { tokens [ i ] = tokenizer . nextToken ( ) ; } return tokens ; }
tr	1	public void onAttack ( AttackComponent p ) { if ( ! dead ) { } }
tr	1	public Muckyluat merge ( Muckyluat detachedInstance ) { log . debug ( "merging Muckyluat instance" ) ; try { Muckyluat result = ( Muckyluat ) sessionFactory . getCurrentSession ( ) . merge ( detachedInstance ) ; log . debug ( "merge successful" ) ; return result ; } catch ( RuntimeException re ) { log . error ( "merge failed" , re ) ; throw re ; } }
tr	6	boolean line ( ) throws IOException { int lev = integer ( ) - 1 ; if ( lev == - 1 ) return false ; int c = read ( ) ; if ( c == 1 ) { int len ; bb . reset ( ) ; while ( ( len = integer ( ) ) > 0 ) { bb . extend ( len ) ; for ( int i = 0 ; i < len ; i ++ ) { bb . put ( ( byte ) read ( ) ) ; } } event . level ( lev ) ; event . event ( bb . clone ( ) ) ; return true ; } else if ( c > 1 ) { bb . reset ( ) ; bb . extend ( 64 ) ; bb . put ( ( byte ) c ) ; while ( ( c = read ( ) ) != 0 ) bb . put ( ( byte ) c ) ; event . level ( lev ) ; event . event ( new String ( bb . getBuffer ( ) , 0 , bb . length ( ) , "UTF-8" ) ) ; return true ; } else { event . level ( lev ) ; event . event ( "" ) ; } return true ; }
tr	3	public double max ( ) { if ( count ( ) == 0 ) return 0 ; double max = data . get ( 0 ) ; for ( double value : data ) if ( value > max ) max = value ; return max ; }
tr	9	private void parseDocument ( int docNumber ) { Element docEle = docs . get ( docNumber ) . getDocumentElement ( ) ; NodeList nodelist = docEle . getElementsByTagName ( "room" ) ; if ( nodelist != null && nodelist . getLength ( ) > 0 ) { for ( int i = 0 ; i < nodelist . getLength ( ) ; i ++ ) { Element el = ( Element ) nodelist . item ( i ) ; String fileName = el . getTextContent ( ) ; parseXmlFile ( new File ( fileName ) ) ; } } for ( int i = 1 ; i < docs . size ( ) ; i ++ ) { Element roomdocEle = docs . get ( i ) . getDocumentElement ( ) ; NodeList roomnodelist = roomdocEle . getElementsByTagName ( "room" ) ; if ( roomnodelist != null && roomnodelist . getLength ( ) > 0 ) { for ( int j = 0 ; j < roomnodelist . getLength ( ) ; j ++ ) { Element roomElement = ( Element ) roomnodelist . item ( j ) ; getRoom ( roomElement ) ; } } } nodelist = docEle . getElementsByTagName ( "connect" ) ; if ( nodelist != null && nodelist . getLength ( ) > 0 ) { for ( int i = 0 ; i < nodelist . getLength ( ) ; i ++ ) { Element el = ( Element ) nodelist . item ( i ) ; getConnection ( el ) ; } } nodelist = docEle . getElementsByTagName ( "player" ) ; if ( nodelist != null && nodelist . getLength ( ) > 0 ) { for ( int i = 0 ; i < nodelist . getLength ( ) ; i ++ ) { Element el = ( Element ) nodelist . item ( 0 ) ; mc = getPlayer ( el ) ; } } }
tr	8	private boolean r_verb ( ) { int among_var ; int v_1 ; ket = cursor ; among_var = find_among_b ( a_4 , 46 ) ; if ( among_var == 0 ) { return false ; } bra = cursor ; switch ( among_var ) { case 0 : return false ; case 1 : lab0 : do { v_1 = limit - cursor ; lab1 : do { if ( ! ( eq_s_b ( 1 , "\u0430" ) ) ) { break lab1 ; } break lab0 ; } while ( false ) ; cursor = limit - v_1 ; if ( ! ( eq_s_b ( 1 , "\u044F" ) ) ) { return false ; } } while ( false ) ; slice_del ( ) ; break ; case 2 : slice_del ( ) ; break ; } return true ; }
tr	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( jfSelColor . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( jfSelColor . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( jfSelColor . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( jfSelColor . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { jfSelColor dialog = new jfSelColor ( new javax . swing . JFrame ( ) , true ) ; dialog . addWindowListener ( new java . awt . event . WindowAdapter ( ) { @ Override public void windowClosing ( java . awt . event . WindowEvent e ) { System . exit ( 0 ) ; } } ) ; dialog . setVisible ( true ) ; } } ) ; }
tr	3	public static UnitType getPreType ( int value ) { UnitType [ ] list = UnitType . values ( ) ; if ( list != null ) { for ( UnitType obj : list ) { if ( obj . getValue ( ) == value ) { return obj ; } } } return null ; }
tr	0	public int getId ( ) { return id ; }
tr	2	private void packField ( byte [ ] bytes , String value , int maxLength , int offset ) { if ( value != null ) { try { BufferTools . stringIntoByteBuffer ( value , 0 , Math . min ( value . length ( ) , maxLength ) , bytes , offset ) ; } catch ( UnsupportedEncodingException e ) { } } }
tr	2	@ Override public String toString ( ) { final StringBuilder sb = new StringBuilder ( "{\n" ) ; for ( final Map . Entry < String , Value < ? >> me : value . entrySet ( ) ) { sb . append ( "  \"" ) ; sb . append ( me . getKey ( ) ) ; sb . append ( "\":" ) ; sb . append ( me . getValue ( ) . toString ( ) . replace ( "\n" , "\n  " ) ) ; sb . append ( " \n" ) ; } return sb . append ( } ) . toString ( ) ; }
tr	0	public Connection getConnection ( ) { Database . start ( ) ; Database . login ( "guest" , "guest" ) ; Connection connection = Database . getConnection ( Database . SOFTWARE_FACTORY_SCHEMA_NAME ) ; return connection ; }
tr	1	public final void setHeight ( BoundSize size ) { this . height = size != null ? size : BoundSize . NULL_SIZE ; }
tr	4	public double getDeltaV ( ) { double totalDeltaV = 0 ; final double stageMass = getMass ( ) ; int totalLiquidEngines = 0 ; for ( final Engine engine : activeEngines ) { if ( engine . getSolidFuelMass ( ) == 0 ) { ++ totalLiquidEngines ; } } final double g = environment . getGravity ( vehicle . getAltitude ( ) ) ; for ( final Engine engine : activeEngines ) { double burnedFuelMass ; if ( engine . getSolidFuelMass ( ) > 0 ) { burnedFuelMass = engine . getSolidFuelMass ( ) ; } else { burnedFuelMass = getLOXFuelMass ( ) / totalLiquidEngines ; } final double deltaV = g * engine . getIsp ( ) * Math . log ( stageMass / ( stageMass - burnedFuelMass ) ) ; totalDeltaV += deltaV ; } return totalDeltaV ; }
tr	9	private boolean r_prelude ( ) { int v_1 ; int v_2 ; int v_3 ; replab0 : while ( true ) { v_1 = cursor ; lab1 : do { golab2 : while ( true ) { v_2 = cursor ; lab3 : do { if ( ! ( in_grouping ( g_v , 97 , 259 ) ) ) { break lab3 ; } bra = cursor ; lab4 : do { v_3 = cursor ; lab5 : do { if ( ! ( eq_s ( 1 , "u" ) ) ) { break lab5 ; } ket = cursor ; if ( ! ( in_grouping ( g_v , 97 , 259 ) ) ) { break lab5 ; } slice_from ( "U" ) ; break lab4 ; } while ( false ) ; cursor = v_3 ; if ( ! ( eq_s ( 1 , "i" ) ) ) { break lab3 ; } ket = cursor ; if ( ! ( in_grouping ( g_v , 97 , 259 ) ) ) { break lab3 ; } slice_from ( "I" ) ; } while ( false ) ; cursor = v_2 ; break golab2 ; } while ( false ) ; cursor = v_2 ; if ( cursor >= limit ) { break lab1 ; } cursor ++ ; } continue replab0 ; } while ( false ) ; cursor = v_1 ; break replab0 ; } return true ; }
tr	8	public < T > Put insert ( T instance ) { try { Field key = clazz . getField ( "key" ) ; byte [ ] keyRow = ( byte [ ] ) key . get ( instance ) ; Put update = new Put ( keyRow ) ; Field [ ] fields = clazz . getDeclaredFields ( ) ; for ( Field f : fields ) { if ( f . isAnnotationPresent ( HRowKey . class ) ) { continue ; } else if ( f . isAnnotationPresent ( HMapFamily . class ) ) { Map m = ( Map ) f . get ( instance ) ; HMapFamily annotation = f . getAnnotation ( HMapFamily . class ) ; update = insertMapFamily ( update , m , annotation ) ; } else if ( f . isAnnotationPresent ( HProperty . class ) ) { byte [ ] value = convertToBytes ( f . get ( instance ) ) ; HProperty annotation = f . getAnnotation ( HProperty . class ) ; update . add ( annotation . family ( ) . getBytes ( ) , annotation . identifier ( ) . getBytes ( ) , value ) ; } else if ( f . isAnnotationPresent ( HMapProperty . class ) ) { byte [ ] value = convertToBytes ( f . get ( instance ) ) ; HMapProperty annotation = f . getAnnotation ( HMapProperty . class ) ; update . add ( annotation . family ( ) . getBytes ( ) , annotation . identifier ( ) . getBytes ( ) , value ) ; } else if ( f . isAnnotationPresent ( HListProperty . class ) ) { byte [ ] value = convertToBytes ( f . get ( instance ) ) ; HListProperty annotation = f . getAnnotation ( HListProperty . class ) ; update . add ( annotation . family ( ) . getBytes ( ) , annotation . identifier ( ) . getBytes ( ) , value ) ; } else { log . debug ( String . format ( "Skipping field %s as it has no supported annotations" , f . getName ( ) ) ) ; } } return update ; } catch ( NoSuchFieldException e ) { log . error ( "Field not found" , e ) ; return null ; } catch ( IllegalAccessException e ) { log . error ( "Access exception" , e ) ; return null ; } }
tr	5	@ Override public void run ( ) { try { if ( percentagetimebeforefade == 100 ) { return ; } int framerate = 100 ; int timeinterval = 1000 / framerate ; int iterations = ( int ) ( ( double ) lifespan / ( double ) timeinterval * ( 100 - percentagetimebeforefade ) / 100 ) ; try { Thread . sleep ( ( int ) ( ( ( double ) percentagetimebeforefade / 100 ) * lifespan ) ) ; } catch ( Exception e ) { } for ( int i = 0 ; i < iterations ; i ++ ) { transparency = ( float ) ( initialtransparency - ( ( double ) i / ( double ) iterations ) * initialtransparency ) ; try { Thread . sleep ( timeinterval ) ; } catch ( Exception e ) { } } } catch ( Exception e ) { } }
tr	1	@ SuppressWarnings ( "unchecked" ) @ Override protected T generateInternal ( ) { T generatedObject ; try { generatedObject = ( T ) getGeneratedClass ( ) . newInstance ( ) ; } catch ( Exception e ) { throw new RuntimeException ( "Class generated by " + this . getClass ( ) . getSimpleName ( ) + " must have a public no argument constructor" , e ) ; } return generatedObject ; }
tr	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( Window3 . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( Window3 . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( Window3 . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( Window3 . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { @ Override public void run ( ) { new Window3 ( ) . setVisible ( true ) ; } } ) ; }
tr	4	@ Override public boolean checkMember ( String memberName , String memberPassword ) { conn = DB . getConn ( ) ; try { pstmt = conn . prepareStatement ( "select MemberName MemberPassword from T_Member" ) ; rs = pstmt . executeQuery ( ) ; while ( rs . next ( ) ) { if ( memberName . equals ( rs . getString ( 1 ) ) || memberPassword . equals ( rs . getString ( 2 ) ) ) { return true ; } } return false ; } catch ( SQLException e ) { e . printStackTrace ( ) ; } return false ; }
tr	3	public void addFAB ( NodeFAB f , boolean clear ) { if ( clear ) fabs . clear ( ) ; int numB = 5 ; fabs . add ( f . make ( ) ) ; for ( Node N : network ) { if ( clear ) { N . clearFABS ( ) ; } N . addFAB ( f . make ( ) ) ; N . initFAB ( N . getNumFab ( ) - 1 , 0 ) ; } }
tr	7	private JSONWriter append ( String s ) throws JSONException { if ( s == null ) { throw new JSONException ( "Null pointer" ) ; } if ( this . mode == o || this . mode == a ) { try { if ( this . , && this . mode == a ) { this . writer . write (   ) ; } this . writer . write ( s ) ; } catch ( IOException e ) { throw new JSONException ( e ) ; } if ( this . mode == o ) { this . mode = k ; } this . , = true ; return this ; } throw new JSONException ( "Value out of sequence." ) ; }
tr	7	protected void action ( Source source , Map < String , Object > map , int i ) throws Exception { log . debug ( String . format ( "Loop [%s] step %d." , getName ( ) , i ) ) ; map . put ( "position" , i ) ; if ( source != null ) { map . put ( "value" , source . pickOne ( "value" , "base" ) ) ; } if ( getBeforeAction ( ) == null || getBeforeAction ( ) . invoke ( getContext ( ) , this , i ) ) { for ( Insert insert : getInserts ( ) ) { log . debug ( String . format ( "Loop [%s] step %d  insert %s" , getName ( ) , i , insert . getName ( ) ) ) ; insert . execute ( ) ; } for ( Loop loop : getLoops ( ) ) { log . debug ( String . format ( "Loop [%s] step %d  loop %s" , getName ( ) , i , loop . getName ( ) ) ) ; loop . execute ( ) ; } if ( getAction ( ) != null ) { getAction ( ) . invoke ( getContext ( ) , this , i ) ; } if ( getAfterAction ( ) != null ) { getAfterAction ( ) . invoke ( getContext ( ) , this , i ) ; } } }
tr	2	public static void main ( String [ ] args ) { try { UIManager . setLookAndFeel ( "org.pushingpixels.substance.api.skin.SubstanceGraphiteAquaLookAndFeel" ) ; } catch ( Exception e ) { } final XbpadPresetContainer container = new XbpadPresetContainer ( ) ; final XbpadLogic logic = new XbpadLogic ( container ) ; InputStream is = new BufferedInputStream ( XbpadGUI . class . getResourceAsStream ( "/assets/icon.jpg" ) ) ; Image image = null ; try { image = ImageIO . read ( is ) ; } catch ( IOException e1 ) { e1 . printStackTrace ( ) ; } final XbpadFrame frame = new XbpadFrame ( logic , image ) ; final XbpadGUI ui = new XbpadGUI ( frame , container ) ; ui . xgetMinimalize ( ) . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent arg0 ) { frame . setState ( Frame . ICONIFIED ) ; } } ) ; ui . xgetQuit ( ) . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { logic . clean ( ) ; System . exit ( 0 ) ; } } ) ; frame . setTitle ( "Xbpad - ver 1.0_alpha" ) ; frame . setResizable ( false ) ; frame . setContentPane ( ui ) ; frame . setIconImage ( image ) ; frame . pack ( ) ; frame . setVisible ( true ) ; }
tr	7	private void jButtonAddCustomerActionPerformed ( java . awt . event . ActionEvent evt ) { if ( "" . equals ( Fnamefield . getText ( ) ) || "" . equals ( Snamefield . getText ( ) ) || "" . equals ( Countryfield . getText ( ) ) || "" . equals ( Emailfield . getText ( ) ) || "" . equals ( Phonefield . getText ( ) ) || "" . equals ( Addressfield . getText ( ) ) ) { JOptionPane . showMessageDialog ( rootPane , "One or more fields are left empty. Please make sure all fields are filled properly" ) ; } else { con . createNewCustomer ( Fnamefield . getText ( ) , Snamefield . getText ( ) , Countryfield . getText ( ) , Emailfield . getText ( ) , Integer . parseInt ( Phonefield . getText ( ) ) , Addressfield . getText ( ) ) ; boolean status = con . saveCustomer ( ) ; if ( status ) { Statuslabel . setText ( "Customer saved" ) ; } else { Statuslabel . setText ( "Customer could not be saved!" ) ; } } }
tr	8	private boolean r_instrum ( ) { int among_var ; ket = cursor ; among_var = find_among_b ( a_3 , 2 ) ; if ( among_var == 0 ) { return false ; } bra = cursor ; if ( ! r_R1 ( ) ) { return false ; } switch ( among_var ) { case 0 : return false ; case 1 : if ( ! r_double ( ) ) { return false ; } break ; case 2 : if ( ! r_double ( ) ) { return false ; } break ; } slice_del ( ) ; if ( ! r_undouble ( ) ) { return false ; } return true ; }
tr	1	public void delete ( Tongiao persistentInstance ) { log . debug ( "deleting Tongiao instance" ) ; try { sessionFactory . getCurrentSession ( ) . delete ( persistentInstance ) ; log . debug ( "delete successful" ) ; } catch ( RuntimeException re ) { log . error ( "delete failed" , re ) ; throw re ; } }
tr	0	@ Override public String execute ( ) throws Exception { String consequence = ERROR ; long id = input . getLong ( "id" ) ; CategoriaDespesa categoriaDespesa = ServiceLocator . getCategoriaDespesaService ( ) . readById ( id ) ; ServiceLocator . getCategoriaDespesaService ( ) . delete ( id ) ; consequence = SUCCESS ; return consequence ; }
tr	9	private boolean r_prelude ( ) { int v_1 ; int v_2 ; int v_3 ; int v_4 ; int v_5 ; B_Y_found = false ; v_1 = cursor ; lab0 : do { bra = cursor ; if ( ! ( eq_s ( 1 , "'" ) ) ) { break lab0 ; } ket = cursor ; slice_del ( ) ; } while ( false ) ; cursor = v_1 ; v_2 = cursor ; lab1 : do { bra = cursor ; if ( ! ( eq_s ( 1 , "y" ) ) ) { break lab1 ; } ket = cursor ; slice_from ( "Y" ) ; B_Y_found = true ; } while ( false ) ; cursor = v_2 ; v_3 = cursor ; lab2 : do { replab3 : while ( true ) { v_4 = cursor ; lab4 : do { golab5 : while ( true ) { v_5 = cursor ; lab6 : do { if ( ! ( in_grouping ( g_v , 97 , 121 ) ) ) { break lab6 ; } bra = cursor ; if ( ! ( eq_s ( 1 , "y" ) ) ) { break lab6 ; } ket = cursor ; cursor = v_5 ; break golab5 ; } while ( false ) ; cursor = v_5 ; if ( cursor >= limit ) { break lab4 ; } cursor ++ ; } slice_from ( "Y" ) ; B_Y_found = true ; continue replab3 ; } while ( false ) ; cursor = v_4 ; break replab3 ; } } while ( false ) ; cursor = v_3 ; return true ; }
tr	9	private void fillRoomCorridor ( int x , int y , boolean vRight , MapTile tile ) { if ( ( ( x >= 0 ) && ( x < width ) ) && ( ( y >= 0 ) && ( y < height ) ) ) { if ( grid [ x ] [ y ] == MapTile . WALL_H ) { grid [ x ] [ y ] = MapTile . DOOR_FRONT ; } else if ( ( grid [ x ] [ y ] == MapTile . WALL_V ) && ( vRight == true ) ) { grid [ x ] [ y ] = MapTile . DOOR_RIGHT ; } else if ( ( grid [ x ] [ y ] == MapTile . WALL_V ) && ( vRight == false ) ) { grid [ x ] [ y ] = MapTile . DOOR_LEFT ; } else if ( grid [ x ] [ y ] != MapTile . ROOM_FLOOR ) { grid [ x ] [ y ] = tile ; } } }
tr	5	public static void main ( String [ ] args ) { double ran = Math . random ( ) ; if ( ran < .33 ) { f = new File ( "dungeon.wav" ) ; s = new SoundPlayer ( f ) ; } else if ( ran > .66 ) { f = new File ( "angel.wav" ) ; s = new SoundPlayer ( f ) ; } else { f = new File ( "battle.wav" ) ; s = new SoundPlayer ( f ) ; } BufferedImage img = null ; try { img = ImageIO . read ( new File ( "currentMap.gif" ) ) ; } catch ( IOException e ) { } RPGWorld world = new RPGWorld ( new RPGGrid ( img . getHeight ( ) / 16 , img . getWidth ( ) / 16 ) , s ) ; ArrayList < Location > locs = new ArrayList < Location > ( ) ; Grid g = world . getGrid ( ) ; for ( int r = 0 ; r < g . getNumRows ( ) ; r ++ ) { for ( int c = 0 ; c < g . getNumCols ( ) ; c ++ ) { locs . add ( new Location ( r , c ) ) ; world . add ( new Location ( r , c ) , new EmptySpaceDungeon ( ) ) ; } } world . add ( locs . get ( 0 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 1 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 2 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 3 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 4 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 5 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 19 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 20 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 21 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 22 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 23 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 24 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 25 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 26 ) , new GridItem ( new Armor ( 4 ) ) ) ; world . add ( locs . get ( 31 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 43 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 47 ) , new GridItem ( new Weapon ( 1 ) ) ) ; world . add ( locs . get ( 49 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 50 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 51 ) , new GridItem ( new Armor ( 3 ) ) ) ; world . add ( locs . get ( 56 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 68 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 74 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 75 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 76 ) , new GridItem ( new Weapon ( 2 ) ) ) ; world . add ( locs . get ( 81 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 82 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 83 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 84 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 85 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 86 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 87 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 88 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 89 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 90 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 91 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 92 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 93 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 99 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 100 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 124 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 125 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 126 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 127 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 131 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 132 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 133 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 134 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 135 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 136 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 137 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 138 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 139 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 140 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 141 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 142 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 143 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 144 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 145 ) , new Door ( "Ordeal" ) ) ; world . add ( locs . get ( 146 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 147 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 148 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 149 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 152 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 156 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 169 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 171 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 177 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 181 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 194 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 196 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 202 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 206 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 219 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 221 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 227 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 231 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 244 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 246 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 252 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 256 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 269 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 271 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 277 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 281 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 294 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 296 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 302 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 306 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 319 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 321 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 327 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 331 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 344 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 346 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 352 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 356 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 369 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 371 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 377 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 381 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 389 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 390 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 391 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 392 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 393 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 394 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 396 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 402 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 406 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 413 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 419 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 421 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 427 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 431 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 438 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 444 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 446 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 452 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 456 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 463 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 469 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 471 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 475 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 476 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 477 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 481 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 482 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 483 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 484 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 485 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 486 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 487 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 488 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 494 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 497 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 498 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 499 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 500 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 519 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 524 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 525 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 531 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 532 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 533 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 534 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 535 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 536 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 537 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 538 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 539 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 540 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 541 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 542 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 543 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 544 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 549 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 550 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 551 ) , new GridItem ( new Key ( "Ordeal" ) ) ) ; world . add ( locs . get ( 552 ) , new GridItem ( new Armor ( 2 ) ) ) ; world . add ( locs . get ( 553 ) , new GridItem ( new Weapon ( 5 ) ) ) ; world . add ( locs . get ( 554 ) , new GridItem ( new Armor ( 1 ) ) ) ; world . add ( locs . get ( 556 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 569 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 572 ) , new Portal ( null ) ) ; world . add ( locs . get ( 574 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 575 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 581 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 594 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 599 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 600 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 601 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 602 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 603 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 604 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 605 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 619 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 620 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 621 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 622 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 623 ) , new Obstacle ( ) ) ; world . add ( locs . get ( 624 ) , new Obstacle ( ) ) ; Location playerLoc = new Location ( 19 , 18 ) ; ThePlayer p = new ThePlayer ( world , new FFCharacter ( ) ) ; world . add ( playerLoc , p ) ; world . show ( ) ; RPGListner mover = new RPGListner ( world ) ; world . getJFrame ( ) . getDisplay ( ) . moveLocation ( playerLoc . getRow ( ) , playerLoc . getCol ( ) ) ; System . out . println ( "Usith thine W  A  S  and D keys to moveith thine self about" ) ; s . play ( ) ; }
tr	3	private boolean r_Step_5b ( ) { ket = cursor ; if ( ! ( eq_s_b ( 1 , "l" ) ) ) { return false ; } bra = cursor ; if ( ! r_R2 ( ) ) { return false ; } if ( ! ( eq_s_b ( 1 , "l" ) ) ) { return false ; } slice_del ( ) ; return true ; }
tr	9	public void checkCollision ( JGEngineInterface eng , int srccid , int dstcid ) { if ( in_parallel_upd ) throw new JGameError ( "Recursive call" , true ) ; in_parallel_upd = true ; if ( objects . size > srcobj . length ) { srcobj = new JGObject [ objects . size + 50 ] ; dstobj = new JGObject [ objects . size + 50 ] ; } int srcsize = 0 ; int dstsize = 0 ; JGRectangle sr = tmprect1 ; JGRectangle dr = tmprect2 ; for ( int i = 0 ; i < objects . size ; i ++ ) { JGObject o = ( JGObject ) objects . values [ i ] ; if ( o . is_suspended ) continue ; if ( ! o . getBBox ( sr ) ) continue ; if ( ( o . colid & srccid ) != 0 ) { srcobj [ srcsize ++ ] = o ; } if ( ( o . colid & dstcid ) != 0 ) { dstobj [ dstsize ++ ] = o ; } } for ( int si = 0 ; si < srcsize ; si ++ ) { JGObject srco = srcobj [ si ] ; if ( ! srco . getBBox ( sr ) ) continue ; for ( int di = 0 ; di < dstsize ; di ++ ) { JGObject dsto = dstobj [ di ] ; if ( dsto == srco ) continue ; if ( ! dsto . getBBox ( dr ) ) continue ; if ( sr . intersects ( dr ) ) { try { dsto . hit ( srco ) ; } catch ( JGameError ex ) { eng . exitEngine ( eng . dbgExceptionToString ( ex ) ) ; } catch ( Exception ex ) { eng . dbgShowException ( dsto . getName ( ) , ex ) ; } } } } flushRemoveList ( ) ; in_parallel_upd = false ; }
tr	4	public static boolean getActionState ( int player , ACTION a ) { if ( player < 0 || player + 1 > KeyboardInput . number_players ) { DebugConsole . PrintError ( "Invalid player number: " + player ) ; return false ; } if ( KeyboardInput . action [ player ] [ a . ordinal ( ) ] [ 0 ] == true && KeyboardInput . action [ player ] [ a . ordinal ( ) ] [ 1 ] == true ) { KeyboardInput . action [ player ] [ a . ordinal ( ) ] [ 0 ] = false ; KeyboardInput . action [ player ] [ a . ordinal ( ) ] [ 1 ] = false ; return true ; } else return false ; }
tr	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( viewNGram . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( viewNGram . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( viewNGram . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( viewNGram . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { new viewNGram ( ) . setVisible ( true ) ; } } ) ; }
tr	7	@ SuppressWarnings ( { "unchecked" , "rawtypes" } ) public void dispatchTask ( final String supportedService , final Task t ) { List < ProductLine < ? >> lines = getProductLinesBySupportedService ( supportedService ) ; if ( lines == null ) { lines = new ArrayList < ProductLine < ? >> ( ) ; for ( ProductLineFactory factory : factoryList ) { ProductLine < ? > productLine = factory . newProductLine ( supportedService ) ; if ( productLine != null ) lines . add ( productLine ) ; } mProductLinesNameMap . put ( supportedService , lines ) ; } for ( ProductLine line : lines ) { line . appendTask ( t ) ; } }
tr	0	protected static Container getPanel_1 ( ) { return null ; }
tr	6	@ Override public void playerPassOnHere ( Player passer , Game game ) { if ( isPointsEnoughToBuyAllTool ( passer . getPoints ( ) ) && isNumberOfTotalToolsNotBeyondLimits ( passer . getTools ( ) . getTotalNumberOfTools ( ) ) ) { System . out . println ( ( new ToolInfo ( ) ) . toolInfoShow ( ) ) ; System . out . println ( GlobalSettings . WELCOME_TO_TOOLROOM ) ; while ( true ) { String input = Input . getString ( ) ; if ( input . matches ( GlobalSettings . QUIT_TOOLROOM ) ) { return ; } if ( ! Input . isInputAnIntegerInArea ( input , GlobalSettings . MIN_TOOL_NUMBER , GlobalSettings . MAX_TOOL_NUMBER ) ) { continue ; } if ( isPointsEnoughToBuyToolWithNumber ( passer . getPoints ( ) , Tool . createTool ( Integer . valueOf ( input ) ) ) ) { passer . buyTool ( Tool . createTool ( Integer . valueOf ( input ) ) ) ; System . out . println ( "\u8D2D\u4E70\u9053\u5177\u6210\u529F\uFF01" ) ; return ; } else { System . out . println ( "\u60A8\u5F53\u524D\u5269\u4F59\u7684\u70B9\u6570\u4E3A" + passer . getPoints ( ) + "\uFF0C\u4E0D\u8DB3\u4EE5\u8D2D\u4E70" + Integer . valueOf ( input ) + "\u9053\u5177" + "\n" ) ; } } } }
