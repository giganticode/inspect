tr	6	private void handleIOException ( SelectionKey key , WebSocket conn , IOException ex ) { if ( conn != null ) { conn . closeConnection ( CloseFrame . ABNORMAL_CLOSE , ex . getMessage ( ) ) ; } else if ( key != null ) { SelectableChannel channel = key . channel ( ) ; if ( channel != null && channel . isOpen ( ) ) { try { channel . close ( ) ; } catch ( IOException e ) { } if ( WebSocketImpl . DEBUG ) System . out . println ( "Connection closed because of" + ex ) ; } } }
tr	2	public static void debug ( Connection con ) throws Exception { System . out . println ( "\nDUMP OF TABLE GEOLOC:" ) ; Statement stmt = con . createStatement ( ) ; ResultSet rs = stmt . executeQuery ( "SELECT geohash  subject  predicate  lat_lon_object  lat  lon FROM geoloc" ) ; while ( rs . next ( ) ) System . out . println ( "geoloc row: " + rs . getString ( "geohash" ) + " " + rs . getString ( "subject" ) + " " + rs . getString ( "predicate" ) + " " + rs . getString ( "lat_lon_object" ) + " " + rs . getFloat ( "lat" ) + " " + rs . getFloat ( "lon" ) ) ; System . out . println ( ) ; System . out . println ( "\nDUMP OF TABLE FREE TEXT PREDICATES:" ) ; stmt = con . createStatement ( ) ; rs = stmt . executeQuery ( "SELECT predicate FROM free_text_predicates" ) ; while ( rs . next ( ) ) System . out . println ( "free_text_predicates row: " + rs . getString ( "predicate" ) ) ; System . out . println ( ) ; }
tr	0	@ Override public String toString ( ) { return name + ": " + score ; }
tr	9	public static Object stringToValue ( String string ) { double d ; if ( string . equals ( "" ) ) { return string ; } if ( string . equalsIgnoreCase ( "true" ) ) { return boolean . true ; } if ( string . equalsIgnoreCase ( "false" ) ) { return boolean . false ; } if ( string . equalsIgnoreCase ( "null" ) ) { return JSONObject . null ; } char b = string . charAt ( 0 ) ; if ( ( b >= 0 && b <= 9 ) || b == - ) { try { if ( string . indexOf ( . ) > - 1 || string . indexOf ( e ) > - 1 || string . indexOf ( E ) > - 1 ) { d = double . valueOf ( string ) ; if ( ! d . isInfinite ( ) && ! d . isNaN ( ) ) { return d ; } } else { long myLong = new long ( string ) ; if ( string . equals ( myLong . toString ( ) ) ) { if ( myLong . longValue ( ) == myLong . intValue ( ) ) { return new Integer ( myLong . intValue ( ) ) ; } else { return myLong ; } } } } catch ( Exception ignore ) { } } return string ; }
tr	9	void actionInitialize ( ) throws CardServiceException { byte [ ] authKeyId = pi . getPrivateKeyPane ( ) . getKeyId ( 0 ) ; byte [ ] signKeyId = pi . getPrivateKeyPane ( ) . getKeyId ( 1 ) ; byte [ ] decKeyId = pi . getPrivateKeyPane ( ) . getKeyId ( 2 ) ; String authKeyPath = pi . getPrivateKeyPane ( ) . getKeyPath ( 0 ) ; String signKeyPath = pi . getPrivateKeyPane ( ) . getKeyPath ( 1 ) ; String decKeyPath = pi . getPrivateKeyPane ( ) . getKeyPath ( 2 ) ; if ( authKeyId == null || signKeyId == null || decKeyId == null || authKeyPath == null || signKeyPath == null || decKeyPath == null ) { return ; } RSAPrivateCrtKey authKey = ( RSAPrivateCrtKey ) CryptoUtils . readPrivateKeyFromDER ( authKeyPath ) ; RSAPrivateCrtKey signKey = ( RSAPrivateCrtKey ) CryptoUtils . readPrivateKeyFromDER ( signKeyPath ) ; RSAPrivateCrtKey decKey = ( RSAPrivateCrtKey ) CryptoUtils . readPrivateKeyFromDER ( decKeyPath ) ; if ( authKey == null ) { apduLog . log ( "Invalid auth key file." ) ; } else if ( signKey == null ) { apduLog . log ( "Invalid sign key file." ) ; } else if ( decKey == null ) { apduLog . log ( "Invalid dec key file." ) ; } X509Certificate [ ] certs = new X509Certificate [ 4 ] ; for ( int i = 0 ; i < 4 ; i ++ ) { String fileName = pi . getCertificatesPane ( ) . getPath ( i ) ; if ( fileName == null ) { return ; } X509Certificate cert = CryptoUtils . readCertFromDER ( fileName ) ; if ( cert == null ) { apduLog . log ( "Invalid certificate file \"" + fileName + "\"." ) ; return ; } certs [ i ] = cert ; } service . initializeApplet ( certs [ 3 ] , certs [ 0 ] , certs [ 1 ] , certs [ 2 ] , authKey , signKey , decKey , authKeyId , signKeyId , decKeyId , pi . getPUC ( ) ) ; }
tr	9	private void parseCommandHeader ( String filename , BufferedInputStream bufin , BufferedOutputStream bufout ) throws IOException { int flags = bufin . read ( ) ; System . out . println ( "NetworkReceiver MAGIC detected :" + flags ) ; if ( ( flags & DISCONNECT ) != 0 ) { gp . printrecv_setconnected ( false ) ; } if ( ( flags & CONNECT ) != 0 ) { gp . printrecv_setconnected ( true ) ; } if ( ( flags & STOP_PRINT ) != 0 ) { gp . printrecv_stopprint ( ) ; } if ( ( flags & RECEIVE_GCODE ) != 0 ) { boolean autostart = false ; boolean savefile = false ; int filesize = 0 ; if ( ( flags & FILENAME_SPECIFIED ) != 0 ) { int namelen = bufin . read ( ) ; byte [ ] name = new byte [ namelen ] ; int rlen = bufin . read ( name ) ; filename = new String ( name , 0 , rlen ) ; } if ( ( flags & FILESIZE_SPECIFIED ) != 0 ) { byte [ ] size = new byte [ 4 ] ; int rlen = bufin . read ( size ) ; if ( rlen == 4 ) { filesize = Constants . bytetoInt ( size ) ; } } if ( ( flags & AUTOSTART_PRINT ) != 0 ) { autostart = true ; System . out . println ( "netrec: autostart" ) ; } if ( ( flags & AUTOSAVE_MODEL ) != 0 ) { savefile = true ; System . out . println ( "netrec: autosave" ) ; } int finish = bufin . read ( ) ; int version = 0 ; if ( finish == 11 ) { version = 1 ; } else if ( finish == Constants . newlineb ) { version = 0 ; } else { System . out . println ( "Error: wrong finish byte received: " + finish ) ; } System . out . println ( "Client Version:" + version + "(" + finish + ")" ) ; boolean succ = gp . printreceived ( filename , bufin , autostart , savefile , filesize ) ; if ( ! succ ) { System . out . println ( "receive error" ) ; } } else { byte [ ] gcode = new byte [ 256 ] ; int len1 = bufin . read ( gcode ) ; if ( len1 > 0 ) { String gc = new String ( gcode , 0 , len1 ) ; gp . printrecv_executeGcode ( gc ) ; } } }
tr	2	@ Override public void paintComponent ( Graphics g ) { g . setColor ( DEF_BACKGROUND_COLOUR ) ; g . fillRect ( 0 , 0 , Util . IMAGE_SIZE , Util . IMAGE_SIZE ) ; Graphics2D g2d = ( Graphics2D ) g ; if ( image != null ) { g2d . drawImage ( image , 0 , 0 , Util . IMAGE_SIZE , Util . IMAGE_SIZE , 0 , 0 , Util . IMAGE_SIZE , Util . IMAGE_SIZE , null ) ; } if ( gridVisible ) { drawGrid ( g ) ; } g2d . drawImage ( selector , selectorLocation . x , selectorLocation . y , selectorLocation . x + Util . GRID_SECTIONS , selectorLocation . y + Util . GRID_SECTIONS , 0 , 0 , Util . GRID_SECTIONS , Util . GRID_SECTIONS , null ) ; }
tr	2	public List < CommitFamily > getCommitFamilyFromCommit ( String commitID ) { try { String sql = "SELECT parent  child FROM commit_family NATURAL JOIN commits WHERE " + "(branch_id=? or branch_id is NULL) and " + "commit_date >= " + "(SELECT commit_date from commits where commit_id=? and (branch_id=? OR branch_id is NULL) limit 1)" + " AND commit_id=child ORDER BY commit_date desc;" ; List < CommitFamily > rawFamilyList = new ArrayList < CommitFamily > ( ) ; ISetter [ ] params = { new StringSetter ( 1 , this . branchID ) , new StringSetter ( 2 , commitID ) , new StringSetter ( 3 , this . branchID ) } ; PreparedStatementExecutionItem ei = new PreparedStatementExecutionItem ( sql , params ) ; addExecutionItem ( ei ) ; ei . waitUntilExecuted ( ) ; ResultSet rs = ei . getResult ( ) ; while ( rs . next ( ) ) { String parentId = rs . getString ( "parent" ) ; String childId = rs . getString ( "child" ) ; rawFamilyList . add ( new CommitFamily ( parentId , childId ) ) ; } return rawFamilyList ; } catch ( SQLException e ) { e . printStackTrace ( ) ; return null ; } }
tr	3	@ Override public void actionPerformed ( InputEvent evt ) { if ( ! hasTimeLeft ( ) && isUsable ) { if ( maze . getPlayer ( ) . getMana ( ) >= getCost ( ) ) { setDuration ( cooldown ) ; maze . getPlayer ( ) . drain ( getCost ( ) ) ; } } }
tr	5	public void update ( Observable o , Object arg ) { final String line = ( String ) arg ; final String thisLine = line . substring ( line . indexOf ( "Text [" ) + "Text [" . length ( ) , line . indexOf ( "]" , line . indexOf ( "Text [" ) ) ) ; if ( thisLine . contains ( "CLP" ) ) { int clp_start = thisLine . indexOf ( ClustersPrefix ) + ClustersPrefix . length ( ) ; int clp_end = thisLine . lastIndexOf ( ";" ) ; String clpevent = thisLine . substring ( clp_start , clp_end ) ; String [ ] a = clpevent . split ( ";" ) ; int type = Integer . parseInt ( a [ 2 ] ) ; int nodeid = Integer . parseInt ( a [ 1 ] . substring ( 2 ) , 16 ) ; if ( type == 2 ) { set_head ( nodeid ) ; log . info ( "added head" ) ; } else if ( type != 0 ) { set_simple ( nodeid ) ; log . info ( "added simple" ) ; } final Millisecond now = new Millisecond ( new Date ( ) ) ; try { Thread . sleep ( 1 ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } log . info ( "head:" + heads ( ) + " simple:" + simples ( ) ) ; if ( heads ( ) > 0 ) { clusters_series . add ( now , heads ( ) ) ; cluster_size_series . add ( now , total ( ) / heads ( ) ) ; } else { clusters_series . add ( now , 0 ) ; cluster_size_series . add ( now , 0 ) ; } } }
tr	9	public static int getAtomLength ( String sexpStr ) { int kakkoCnt = 0 ; int i ; for ( i = 0 ; i < sexpStr . length ( ) ; i ++ ) { String s = sexpStr . substring ( i , i + 1 ) ; if ( s . equals ( "(" ) ) { kakkoCnt ++ ; } else if ( s . equals ( ")" ) ) { kakkoCnt -- ; } if ( ! sexpStr . startsWith ( "(" ) && ( s . equals ( "(" ) || s . equals ( ")" ) || s . equals ( " " ) ) ) { i -= 1 ; break ; } else { if ( kakkoCnt == 0 && ( s . equals ( "(" ) || s . equals ( ")" ) || s . equals ( " " ) ) ) { break ; } } } return i ; }
tr	1	public int jjtGetNumChildren ( ) { return ( children == null ) ? 0 : children . length ; }
tr	5	public static void unpackConfig ( StreamLoader streamLoader ) { Stream stream = new Stream ( streamLoader . getDataForName ( "varbit.dat" ) ) ; int cacheSize = stream . readUnsignedWord ( ) ; if ( cache == null ) cache = new VarBit [ cacheSize ] ; for ( int j = 0 ; j < cacheSize ; j ++ ) { if ( cache [ j ] == null ) cache [ j ] = new VarBit ( ) ; cache [ j ] . readValues ( stream ) ; if ( cache [ j ] . aBoolean651 ) Varp . cache [ cache [ j ] . anInt648 ] . aBoolean713 = true ; } if ( stream . offset != stream . buffer . length ) System . out . println ( "varbit load mismatch" ) ; }
tr	4	private String getOrientationString ( Orientations o ) { if ( o == Orientations . horizontal ) return "horizontal" ; if ( o == Orientations . left ) return "90\u00B0 left" ; if ( o == Orientations . right ) return "90\u00B0 right" ; if ( o == Orientations . upside ) return "180\u00B0" ; return "unknown" ; }
tr	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( LauncherGUI . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( LauncherGUI . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( LauncherGUI . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( LauncherGUI . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { new LauncherGUI ( ) . setVisible ( true ) ; } } ) ; }
tr	8	public static void main ( String [ ] args ) throws Exception { Scanner in = new Scanner ( new File ( "D:\\ProgramDATA\\Alien Language\\A-small-practice.in" ) ) ; System . setOut ( new PrintStream ( new File ( "d:\\programDATA\\Alien Language\\A-small-practice.out" ) ) ) ; int L = in . nextInt ( ) , D = in . nextInt ( ) , N = in . nextInt ( ) ; String [ ] Dict = new String [ D ] ; for ( int i = 0 ; i < Dict . length ; i ++ ) { Dict [ i ] = in . next ( ) ; } in . nextLine ( ) ; for ( int cur = 0 ; cur < N ; cur ++ ) { String str = in . nextLine ( ) ; String [ ] choices = new String [ L ] ; Arrays . fill ( choices , "" ) ; for ( int i = 0 , j = 0 ; i < str . length ( ) ; i ++ , j ++ ) { if ( str . charAt ( i ) == ( ) { for ( i += 1 ; j < str . length ( ) && str . charAt ( i ) != ) ; i ++ ) { choices [ j ] += str . charAt ( i ) ; } } else choices [ j ] += str . charAt ( i ) ; } int count = 0 ; for ( int i = 0 ; i < D ; i ++ ) { if ( Valid ( Dict [ i ] , choices ) ) count ++ ; } System . out . println ( "Case #" + ( cur + 1 ) + ": " + count ) ; } }
tr	3	protected byte getMessageInfo ( ) { byte info = ( byte ) ( message . getQos ( ) << 1 ) ; if ( message . isRetained ( ) ) { info |= 01 ; } if ( message . isDuplicate ( ) || duplicate ) { info |= 08 ; } return info ; }
tr	7	public static Object findValueOfType ( Collection < ? > collection , class < ? > [ ] types ) { if ( isEmpty ( collection ) || ObjectUtils . isEmpty ( types ) ) { return null ; } for ( class < ? > type : types ) { Object value = findValueOfType ( collection , type ) ; if ( value != null ) { return value ; } } return null ; }
tr	4	public static void getNum ( ) { long n = 2 * 3 * 5 * 7 * 11 ; while ( true ) { long sq = n * n ; int count = 2 ; for ( int i = 2 ; i < n ; i ++ ) { if ( sq % i == 0 ) { count ++ ; } } if ( count > 1000 ) { System . out . println ( n + " " + count ) ; break ; } n += 2 * 3 * 5 * 7 * 11 ; } }
tr	1	public Color getTabUnselectedColor ( ) { return ( blackTabbedPaneUI . colorUnSel == null ) ? new Color ( 192 , 192 , 192 ) : blackTabbedPaneUI . colorUnSel ; }
tr	7	public static String RegexExtraction ( String patternStr , String data ) { Pattern pattern ; if ( patternStr == null || patternStr . length ( ) == 0 || patternStr . isEmpty ( ) ) return null ; if ( RegexManager . getInstance ( ) . patternList . containsKey ( patternStr ) ) { pattern = RegexManager . getInstance ( ) . patternList . get ( patternStr ) ; } else { pattern = Pattern . compile ( patternStr ) ; RegexManager . getInstance ( ) . patternList . put ( patternStr , pattern ) ; } Matcher matcher = pattern . matcher ( data ) ; String res = "" ; if ( matcher . find ( ) ) { if ( patternStr . startsWith ( ParameterSetting . REGXWORDPATTERN_V2 ) ) { String [ ] array = matcher . group ( 1 ) . split ( " " ) ; res = array [ array . length - 1 ] . replace (   ,   ) . trim ( ) ; } else { String [ ] array = matcher . group ( 1 ) . split ( " " ) ; res = array [ 0 ] . replace (   ,   ) . trim ( ) ; } } if ( StopwordsFilter . getInstance ( ) . isStopWords ( res ) ) return null ; else return res ; }
tr	6	@ Override public byte [ ] toBytes ( Object value ) { String string = ( String ) value ; string = Normalizer . normalize ( string , Normalizer . Form . NFC ) ; if ( ! caseSensitive ) { string = string . toLowerCase ( locale ) ; } byte [ ] bytes = ENCODERS . get ( byteEncodeMode ) . toBytes ( string , locale ) ; for ( int i = 0 ; i <= bytes . length - 4 ; i ++ ) { if ( bytes [ i ] == 0 && bytes [ i + 1 ] == 0 && bytes [ i + 2 ] == 0 && bytes [ i + 3 ] == 0 ) { throw new RuntimeException ( "Encoded string value contains the end-of-field marker (zero byte)." ) ; } } return bytes ; }
tr	4	public void setFieldValue ( _Fields field , Object value ) { switch ( field ) { case ORIGNAL_TEXT : if ( value == null ) { unsetOrignalText ( ) ; } else { setOrignalText ( ( String ) value ) ; } break ; case CLEAN_TEXT : if ( value == null ) { unsetCleanText ( ) ; } else { setCleanText ( ( String ) value ) ; } break ; } }
tr	6	private boolean r_Step_3 ( ) { int among_var ; ket = cursor ; among_var = find_among_b ( a_4 , 7 ) ; if ( among_var == 0 ) { return false ; } bra = cursor ; if ( ! r_R1 ( ) ) { return false ; } switch ( among_var ) { case 0 : return false ; case 1 : slice_from ( "al" ) ; break ; case 2 : slice_from ( "ic" ) ; break ; case 3 : slice_del ( ) ; break ; } return true ; }
tr	4	private void back ( ) { switch ( _current ) { case PAUSE : case PLAY : _index -- ; if ( _index < 0 ) { _index = 0 ; } else { _player . stop ( ) ; playSong ( _myList . getModel ( ) . getElementAt ( _index ) ) ; } break ; case STOP : break ; } }
tr	1	public ModificationException ( final class < ? > classTriedToChange , final String fieldTryingToChange ) { super ( createMessage ( classTriedToChange , fieldTryingToChange , null , null ) ) ; }
tr	4	public static boolean maybeTwoPairs ( List < Card > sourceCards , HandCombinationSink handCombinationSink ) { final Holder < Hand > bestHandHolder = new Holder < Hand > ( ) ; CardCombinator . iterate ( sourceCards , new CardCombinationCallback ( ) { @ Override public boolean process ( List < Card > cards ) { Collections . sort ( cards , new RankComparator ( ) ) ; final Rank rank0 = cards . get ( 0 ) . getRank ( ) ; if ( rank0 != cards . get ( 1 ) . getRank ( ) ) { return false ; } final Rank rank1 = cards . get ( 2 ) . getRank ( ) ; if ( rank1 != cards . get ( 3 ) . getRank ( ) ) { return false ; } final int rating = RATING_FLAG_MAP . get ( rank0 ) | RATING_FLAG_MAP . get ( rank1 ) ; if ( bestHandHolder . value == null || bestHandHolder . value . getRating ( ) < rating ) { bestHandHolder . value = new DefaultHand ( rating , HandRank . TWO_PAIRS , cards ) ; } return false ; } } , TWO_PAIRS_HAND_SIZE ) ; return provideBestHand ( bestHandHolder , handCombinationSink ) ; }
tr	5	private static void print ( int [ ] [ ] m , int rows , int cols ) { if ( rows > 25 || cols > 25 ) { return ; } for ( int r = 0 ; r < rows ; r ++ ) { for ( int c = 0 ; c < cols ; c ++ ) { final StringBuilder sb = new StringBuilder ( ) ; final String str = String . valueOf ( m [ r ] [ c ] ) ; while ( sb . length ( ) + str . length ( ) < 4 ) { sb . append ( " " ) ; } sb . append ( str ) ; System . out . print ( sb . toString ( ) ) ; } System . out . println ( ) ; } }
tr	8	private Section processSection ( StartElement se , XMLEventReader eventReader , String derivedNamespace ) throws XMLStreamException { Section s = new Section ( ) ; Iterator < Attribute > attributes = se . getAttributes ( ) ; while ( attributes . hasNext ( ) ) { Attribute attr = attributes . next ( ) ; s . addAttribute ( attr . getName ( ) . getLocalPart ( ) , attr . getValue ( ) ) ; } boolean endTagReached = false ; while ( ! endTagReached ) { XMLEvent event = eventReader . nextTag ( ) ; if ( event . isStartElement ( ) ) { se = event . asStartElement ( ) ; if ( se . getName ( ) . getLocalPart ( ) . equalsIgnoreCase ( "Obs" ) && se . getName ( ) . getNamespaceURI ( ) . equalsIgnoreCase ( derivedNamespace ) ) { Obs o = processObs ( se , eventReader ) ; s . getObs ( ) . add ( o ) ; } } else if ( event . isEndElement ( ) ) { EndElement ee = event . asEndElement ( ) ; if ( ee . getName ( ) . getLocalPart ( ) . equalsIgnoreCase ( "Section" ) && ee . getName ( ) . getNamespaceURI ( ) . equalsIgnoreCase ( derivedNamespace ) ) { endTagReached = true ; } } } return s ; }
tr	5	public List < Vak > getVakkenVanStudent ( long studentId ) { List < Vak > vakken = new ArrayList < Vak > ( ) ; List < long > klasIds = new ArrayList < long > ( ) ; List < long > vakIds = new ArrayList < long > ( ) ; try { PreparedStatement prepareStatement = manager . prepareStatement ( "SELECT klas_id FROM leerling_klas WHERE leerling_id = ?" ) ; prepareStatement . setLong ( 1 , studentId ) ; ResultSet resultSet = prepareStatement . executeQuery ( ) ; while ( resultSet . next ( ) ) { klasIds . add ( resultSet . getLong ( 1 ) ) ; } PreparedStatement prepareStatement2 = manager . prepareStatement ( "SELECT vak_id FROM vak_klas WHERE klas_id = ?" ) ; for ( long klasId : klasIds ) { prepareStatement2 . setLong ( 1 , klasId ) ; ResultSet resultSet2 = prepareStatement2 . executeQuery ( ) ; while ( resultSet2 . next ( ) ) { vakIds . add ( resultSet2 . getLong ( 1 ) ) ; } } for ( long vakId : vakIds ) { vakken . add ( getVak ( vakId ) ) ; } return vakken ; } catch ( SQLException e ) { e . printStackTrace ( ) ; return vakken ; } }
tr	5	protected DRUMS ( AbstractHashFunction hashFunction , AccessMode accessMode , DRUMSParameterSet < Data > gp ) throws IOException { this . prototype = gp . getPrototype ( ) ; this . hashFunction = hashFunction ; this . gp = gp ; DynamicMemoryAllocater . instantiate ( gp ) ; gp . MIN_ELEMENT_IN_BUCKET_BEFORE_SYNC = ( int ) ( ( gp . BUCKET_MEMORY - gp . BUCKET_MEMORY % gp . MEMORY_CHUNK ) / hashFunction . getNumberOfBuckets ( ) / prototype . getSize ( ) / 2 ) ; logger . info ( "Setted MIN_ELEMENT_IN_BUCKET_BEFORE_SYNC to {}" , gp . MIN_ELEMENT_IN_BUCKET_BEFORE_SYNC ) ; if ( accessMode == AccessMode . READ_WRITE ) { @ SuppressWarnings ( "unchecked" ) Bucket < Data > [ ] tmp = new Bucket [ hashFunction . getNumberOfBuckets ( ) ] ; buckets = tmp ; for ( int i = 0 ; i < hashFunction . getNumberOfBuckets ( ) ; i ++ ) { buckets [ i ] = new Bucket < Data > ( i , gp ) ; String tmpFileName = gp . DATABASE_DIRECTORY + "/" + hashFunction . getFilename ( i ) ; if ( ! new File ( tmpFileName ) . exists ( ) ) { HeaderIndexFile < Data > tmpFile ; try { tmpFile = new HeaderIndexFile < Data > ( tmpFileName , HeaderIndexFile . AccessMode . READ_WRITE , 1 , gp ) ; tmpFile . close ( ) ; } catch ( FileLockException e ) { logger . error ( "Can't create file {}  because file is locked by another process." , tmpFileName ) ; } catch ( IOException e ) { logger . error ( "Can't create file {}. {}" , tmpFileName , e ) ; throw e ; } } } bucketContainer = new BucketContainer < Data > ( buckets , hashFunction ) ; synchronizerFactory = new SynchronizerFactory < Data > ( ) ; syncManager = new SyncManager < Data > ( bucketContainer , synchronizerFactory , gp ) ; syncManager . start ( ) ; } }
tr	3	public RoutePath ( String inLine , HashMap < String , Trip > tripMap ) { mID = sNextID ; sNextID ++ ; sRoutePathMap . put ( mID , this ) ; mPath = new ArrayList < > ( ) ; String [ ] f = CSVParser . parseLine ( inLine ) ; for ( String s : f ) { s = s . replaceAll ( "\"" , "" ) ; if ( tripMap . get ( s ) != null ) { mPath . add ( tripMap . get ( s ) ) ; } } if ( mPath . size ( ) > 0 ) { mRoute = mPath . get ( 0 ) . getRoute ( ) ; } else { mRoute = null ; } mStartTimecode = - 1 ; mEndTimecode = Integer . MIN_VALUE ; buildStopList ( ) ; }
tr	9	public static void saveComputerPlayer ( ComputerPlay saveComp , GameStatus gameStatus , Board board , boolean force , boolean noCurrentScore , boolean checkForDuplicateFiles ) { if ( gameStatus . players [ saveComp . getPlayerIndex ( ) ] . getType ( ) != TYPE . COMPUTER ) return ; double lowScoreThreshold = board . getHeight ( ) * board . getWidth ( ) / ( gameStatus . config . getInt ( Config . KEY . NUMBER_PLAYERS . getKey ( ) ) ) ; double highScoreThreshold = lowScoreThreshold * 11.0 ; lowScoreThreshold *= 9.0 ; int compScore = saveComp . getAverageScore ( noCurrentScore ) ; if ( ! force && saveComp . filename == null && ! saveComp . winner && compScore < highScoreThreshold ) { Logger . info ( "Not saving " + gameStatus . players [ saveComp . getPlayerIndex ( ) ] . getName ( ) + " as it didn't win and score was below hi threashold of " + highScoreThreshold + "." ) ; return ; } if ( ! force && compScore < lowScoreThreshold ) { Logger . info ( "Not saving " + gameStatus . players [ saveComp . getPlayerIndex ( ) ] . getName ( ) + " as the score was below " + lowScoreThreshold + "." ) ; return ; } ArrayList < String > deleteFiles = new ArrayList < String > ( ) ; if ( checkForDuplicateFiles ) { Logger . info ( "Checking for duplicates" ) ; File [ ] allFiles = FileManager . listAllFiles ( gameStatus ) ; int i = 0 ; for ( File file : allFiles ) { if ( ! possibleMatchingComputerConfig ( gameStatus , file , saveComp ) ) { i ++ ; continue ; } ComputerPlay compareComputer = FileManager . loadComputerPlayer ( file . getName ( ) , 0 , gameStatus , board , false ) ; if ( compareComputer == null ) continue ; Logger . info ( "Loading file " + ( i + 1 ) + " of " + allFiles . length + ": " + file . getName ( ) ) ; if ( saveComp . sameConfig ( compareComputer ) ) { saveComp . mergeScores ( compareComputer ) ; deleteFiles . add ( compareComputer . filename ) ; } i ++ ; } } String config = saveComp . getConfigFileContents ( noCurrentScore ) ; String computerConfigFolder = gameStatus . config . getString ( Config . KEY . BASE_COMPUTER_CONFIG_PATH . getKey ( ) ) ; File f = new File ( computerConfigFolder + saveComp . getConfigFilename ( noCurrentScore ) ) ; Logger . info ( "Saving as: " + f . getName ( ) ) ; FileOutputStream ostr ; try { ostr = new FileOutputStream ( f ) ; } catch ( FileNotFoundException e1 ) { Logger . error ( "Unable to open output ComputerPlay file: " + f . getAbsolutePath ( ) ) ; e1 . printStackTrace ( ) ; return ; } OutputStreamWriter owtr = new OutputStreamWriter ( ostr ) ; try { owtr . write ( config , 0 , config . length ( ) ) ; owtr . close ( ) ; } catch ( IOException e ) { Logger . error ( "Unable to save ComputerPlay file: " + f . getAbsolutePath ( ) ) ; e . printStackTrace ( ) ; return ; } saveComp . filename = f . getName ( ) ; for ( String filename : deleteFiles ) { Logger . info ( "Deleting duplicate " + filename ) ; deletePreviousFile ( filename , gameStatus ) ; } }
tr	9	public void booking ( ) { int movieCode ; int showTime_index ; String seats ; Movie movie ; ShowTime showTime = null ; MovieGoer movieGoer ; boolean tryAgain ; do { tryAgain = false ; System . out . println ( ) ; System . out . print ( "Please enter movie code (-1 to go back) : " ) ; movieCode = ConsoleReader . readIntInput ( ) ; if ( movieCode == - 1 ) { return ; } movie = movieBL . getMovie ( movieCode ) ; if ( movie == null ) { tryAgain = true ; System . out . println ( "Invalid Movie Code. Try again." ) ; System . out . println ( ) ; } } while ( tryAgain ) ; printMovieInfo ( movie ) ; do { tryAgain = false ; System . out . print ( "Please select showtime (the number between '[ ]') (-1 to go back) : " ) ; showTime_index = ConsoleReader . readIntInput ( ) ; if ( showTime_index == - 1 ) { return ; } if ( showTime_index < 1 || showTime_index > _showTimes . size ( ) ) { tryAgain = true ; System . out . println ( "Invalid number. Try again." ) ; } else { showTime = _showTimes . get ( showTime_index - 1 ) ; if ( showTimeBL . isFullyBooked ( showTime ) ) { System . out . println ( ) ; System . out . println ( "===========================================================================" ) ; System . out . println ( "| We're sorry  the selected session is sold out. Please pick another one! |" ) ; System . out . println ( "===========================================================================" ) ; System . out . println ( ) ; tryAgain = true ; continue ; } printSeats ( showTime ) ; } } while ( tryAgain ) ; boolean isValidSeatNos ; do { System . out . print ( "Please enter seat no. (e.g. G1 G2 ...) : " ) ; seats = ConsoleReader . readSeatNumbers ( ) ; String [ ] _seats = seats . split ( " " ) ; isValidSeatNos = seatBL . validateSeatNumbers ( showTime , _seats ) ; if ( ! isValidSeatNos ) { System . out . println ( "Invalid seat numbers. Please choose again." ) ; } else if ( _seats . length > 10 ) { System . out . println ( "You cannot book more than 10 tickets per transaction. Please select seats again." ) ; isValidSeatNos = false ; } System . out . println ( ) ; } while ( ! isValidSeatNos ) ; String movieGoerName ; String movieGoerMobileNo ; String movieGoerEmail ; Date dateOfBirth = null ; System . out . println ( ) ; System . out . println ( "Please Enter Your Details" ) ; System . out . println ( "=========================" ) ; System . out . print ( "Name : " ) ; movieGoerName = ConsoleReader . readString ( ) ; System . out . print ( "Date of Birth (DD/MM/YYYY) : " ) ; dateOfBirth = ConsoleReader . readDateInput ( ) ; System . out . print ( "Email : " ) ; movieGoerEmail = ConsoleReader . readString ( ) ; System . out . print ( "Mobile No : " ) ; movieGoerMobileNo = ConsoleReader . readString ( ) ; movieGoer = movieGoerBL . createMovieGoer ( movieGoerName , movieGoerEmail , movieGoerMobileNo , dateOfBirth ) ; printBookingSummary ( showTime , movieGoer , seats ) ; }
tr	7	private void btnApostarActionPerformed ( java . awt . event . ActionEvent evt ) { if ( carreraAbierta != null ) { Jugador j = new Jugador ( 0 , txtUsuario . getText ( ) . toString ( ) , txtPass . getText ( ) . toString ( ) ) ; j = fachada . login ( j ) ; if ( j != null ) { if ( validarMonto ( ) ) { CaballoEnCarrera caballo = ( CaballoEnCarrera ) lstCaballos . getSelectedValue ( ) ; Apuesta a = new Apuesta ( Integer . parseInt ( txtMonto . getText ( ) ) , j ) ; if ( a . validar ( ) ) { ErroresApuesta ret = caballo . agregarApuesta ( a ) ; switch ( ret ) { case OK : messageBox ( "Apuesta realizada correctamente" ) ; borrarDatosJugador ( ) ; break ; case SaldoInsuficiente : messageBox ( "Saldo insuficiente" ) ; break ; case ErrorGenerico : messageBox ( "Error inesperado" ) ; break ; } } else { messageBox ( "El monto debe ser mayor que cero" ) ; } } else { messageBox ( "El monto debe ser num\u00E9rico" ) ; } } else { messageBox ( "Login incorrecto" ) ; } } else { messageBox ( "No hay carreras abiertas" ) ; } }
tr	3	public static Texture [ ] [ ] replaceColors ( Texture [ ] [ ] textures , int [ ] fromColors , int [ ] toColors ) { if ( textures . length == 0 ) return null ; Texture [ ] [ ] newTextures = new Texture [ textures . length ] [ textures [ 1 ] . length ] ; for ( int i = 0 ; i < textures . length ; i ++ ) for ( int j = 0 ; j < textures [ 1 ] . length ; j ++ ) newTextures [ i ] [ j ] = textures [ i ] [ j ] . replaceColors ( fromColors , toColors ) ; return newTextures ; }
tr	7	public void registerSerializer ( Serializer s ) throws Exception { class classes [ ] = s . getSerializableClasses ( ) ; Serializer exists ; synchronized ( serializerSet ) { if ( serializableMap == null ) { serializableMap = new HashMap ( ) ; } for ( int i = 0 ; i < classes . length ; i ++ ) { exists = ( Serializer ) serializableMap . get ( classes [ i ] ) ; if ( exists != null && exists . getClass ( ) != s . getClass ( ) ) { throw new Exception ( "different serializer already registered for " + classes [ i ] . getName ( ) ) ; } } if ( ! serializerSet . contains ( s ) ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "registered serializer " + s . getClass ( ) . getName ( ) ) ; } s . setOwner ( this ) ; serializerSet . add ( s ) ; serializerList . add ( 0 , s ) ; for ( int j = 0 ; j < classes . length ; j ++ ) { serializableMap . put ( classes [ j ] , s ) ; } } } }
tr	9	private Booking getBooking ( CommandLine cmd ) throws IOException { Booking booking = null ; if ( cmd . hasOption ( "hostel_id" ) || cmd . hasOption ( "booking_date" ) || cmd . hasOption ( "booking_status" ) || cmd . hasOption ( "user_id" ) ) { booking = new Booking ( ) ; booking . setBedIds ( null ) ; booking . setBedReservations ( null ) ; booking . setBookingDate ( GenericUtility . getDate ( cmd . getOptionValue ( "booking_date" ) ) ) ; String statusAsString = cmd . getOptionValue ( "booking_status" ) ; BookingStatus status = BookingStatus . UNKNOWN ; if ( statusAsString != null ) { if ( statusAsString . equalsIgnoreCase ( BookingStatus . RESERVED . toString ( ) ) ) { status = BookingStatus . RESERVED ; } else if ( statusAsString . equalsIgnoreCase ( BookingStatus . CANCELLED . toString ( ) ) ) { status = BookingStatus . CANCELLED ; } else if ( statusAsString . equalsIgnoreCase ( BookingStatus . CLOSED . toString ( ) ) ) { status = BookingStatus . CLOSED ; } } booking . setStatus ( status ) ; if ( cmd . hasOption ( "hostel_id" ) ) { booking . setHostelId ( new Identifier ( cmd . getOptionValue ( "hostel_id" ) ) ) ; } if ( cmd . hasOption ( "user_id" ) ) { booking . setUserId ( new Identifier ( cmd . getOptionValue ( "user_id" ) ) ) ; } } return booking ; }
tr	5	public final void mSL_COMMENT ( boolean _createToken ) throws RecognitionException , CharStreamException , TokenStreamException { int _ttype ; Token _token = null ; int _begin = text . length ( ) ; _ttype = SL_COMMENT ; int _saveIndex ; match ( "//" ) ; { _loop594 : do { if ( ( _tokenSet_1 . member ( LA ( 1 ) ) ) ) { { match ( _tokenSet_1 ) ; } } else { break _loop594 ; } } while ( true ) ; } if ( _createToken && _token == null && _ttype != Token . SKIP ) { _token = makeToken ( _ttype ) ; _token . setText ( new String ( text . getBuffer ( ) , _begin , text . length ( ) - _begin ) ) ; } _returnToken = _token ; }
tr	0	public void setAddressId ( int value ) { addressId = value ; }
tr	4	public void print ( GroupedWriter fout ) { super . print ( fout ) ; fout . print ( "alphabet " ) ; fout . printlnGroup ( alphabet ) ; if ( guard != null && guard . length ( ) > 0 ) { fout . print ( "guard " ) ; fout . printlnGroup ( guard ) ; } if ( clocksToReset != null && clocksToReset . length > 0 ) { fout . print ( "clocksToReset " ) ; fout . printlnGroup ( Arrays . toString ( clocksToReset ) ) ; } fout . print ( "offset " ) ; fout . printlnGroup ( double . toString ( offset_theta ) ) ; }
tr	2	public String getDemoteGroup ( String before ) { Set < String > keys = mapping . keySet ( ) ; for ( String key : keys ) { if ( mapping . get ( key ) . equalsIgnoreCase ( before ) ) { return key ; } } return null ; }
tr	5	static private Vector < double [ ] > sampleResults ( Vector < Future < Vector < double [ ] >>> results , int bins ) throws Exception { int nDescriptors = results . get ( 0 ) . get ( ) . get ( 0 ) . length ; System . out . println ( "Printing for " + nDescriptors + " descriptors" ) ; Vector < double [ ] > descriptors = new Vector < double [ ] > ( nDescriptors ) ; for ( int d = 0 ; d < nDescriptors ; ++ d ) { double [ ] averages = new double [ bins ] ; for ( Future < Vector < double [ ] >> result : results ) { Vector < double [ ] > samples = result . get ( ) ; int samplesPerBin = samples . size ( ) / bins ; for ( int b = 0 ; b < bins ; ++ b ) { double sum = 0 ; int counted = 0 ; for ( int s = 0 ; s < samplesPerBin && b * samplesPerBin + s < samples . size ( ) ; ++ s ) { sum += samples . get ( b * samplesPerBin + s ) [ d ] ; counted += 1 ; } averages [ b ] = sum / counted ; } } descriptors . add ( averages ) ; } return descriptors ; }
tr	2	@ Override public int compare ( String o1 , String o2 ) { if ( o1 . length ( ) < o2 . length ( ) ) return 1 ; else if ( o1 . length ( ) > o2 . length ( ) ) return - 1 ; return o1 . compareTo ( o2 ) ; }
tr	4	protected void showClassInfo ( StringBuffer buf ) { try { buf . append ( "<b>Rio Status</b><br>\n" ) ; if ( getRio ( ) == null ) { buf . append ( "<em>Device claimed by another driver.</em>" ) ; buf . append ( "<br><br>\n" ) ; return ; } rio . start ( ) ; showStorage ( buf , false ) ; if ( rio . hasExternalMemory ( ) ) showStorage ( buf , true ) ; } catch ( IOException e ) { buf . append ( "\n<br>" ) ; buf . append ( e . getClass ( ) . getName ( ) ) ; buf . append ( ": " ) ; buf . append ( e . getMessage ( ) ) ; buf . append ( "<br>\n" ) ; } finally { if ( rio != null ) rio . finish ( ) ; } }
tr	6	@ Override public Object getValueAt ( int rowIndex , int columnIndex ) { switch ( columnIndex ) { case 0 : return listStock . get ( rowIndex ) . getId ( ) ; case 1 : return listStock . get ( rowIndex ) . getLibelle ( ) ; case 2 : return listStock . get ( rowIndex ) . getType ( ) ; case 3 : return listStock . get ( rowIndex ) . getQtiteStock ( ) ; case 4 : return listStock . get ( rowIndex ) . getPrix ( ) ; case 5 : return listStock . get ( rowIndex ) . getDepot ( ) . getAdresse ( ) ; default : throw new IllegalArgumentException ( ) ; } }
tr	0	RenderLayer ( int x ) { }
tr	7	@ Override public Iterator < T > iterator ( ) { return new Iterator < T > ( ) { private Node < T > current = head ; private Node < T > prev = null ; @ Override public boolean hasNext ( ) { return current != null ; } @ Override public T next ( ) { prev = current ; if ( current != null ) { current = current . getNext ( ) ; } if ( prev != null ) { return prev . getData ( ) ; } else { return null ; } } @ Override public void remove ( ) { if ( prev == null ) { return ; } if ( prev . getNext ( ) != null ) { prev . getNext ( ) . setPrev ( prev . getPrev ( ) ) ; } if ( prev . getPrev ( ) != null ) { prev . getPrev ( ) . setNext ( prev . getNext ( ) ) ; } if ( head == prev ) { head = prev . getNext ( ) ; } if ( tail == prev ) { tail = prev . getPrev ( ) ; } prev = prev . getPrev ( ) ; len -- ; } } ; }
tr	0	@ Override public T evaluate ( T x , T y , T z ) throws AbstractException { T resFirst = first . evaluate ( x , y , z ) ; T resSecond = second . evaluate ( x , y , z ) ; return resFirst . sum ( resSecond ) ; }
tr	8	private void createFullMatchPanel ( ) { LabelPanel . setPreferredSize ( new Dimension ( 450 , 35 ) ) ; LabelPanel . setMaximumSize ( new Dimension ( 20000 , 35 ) ) ; FullPanel . setLayout ( new BoxLayout ( FullPanel , BoxLayout . Y_AXIS ) ) ; JPanel titlePanel = new JPanel ( ) ; buildTotalTitlePanel ( titlePanel ) ; FullPanel . add ( titlePanel ) ; JTabbedPane setPanel = new JTabbedPane ( ) ; JScrollPane singleSetScroller = new JScrollPane ( ) ; int [ ] [ ] setInfo = getSetInfo ( ) ; if ( setInfo == null ) return ; for ( int i = 0 ; i < setInfo . length ; i ++ ) { int firstMatch = setInfo [ i ] [ 0 ] ; int lastMatch = setInfo [ i ] [ 1 ] ; JScrollPane scroller = new JScrollPane ( ) ; scroller . setPreferredSize ( new Dimension ( 300 , 200 ) ) ; scroller . setMinimumSize ( new Dimension ( 300 , 200 ) ) ; JLabel [ ] columnHeaders = null ; JPanel headPanel = new JPanel ( ) ; scroller . setColumnHeaderView ( headPanel ) ; initLayout ( headPanel ) ; for ( int match = firstMatch ; match < lastMatch ; match ++ ) { if ( match == firstMatch ) columnHeaders = buildMatchHeaders ( match , headPanel , false , null ) ; buildMatchHistory ( match , headPanel , 0 ) ; } JViewport headerView = scroller . getColumnHeader ( ) ; headerView . setPreferredSize ( new Dimension ( 300 , getLargestHeight ( columnHeaders ) ) ) ; int maxRounds = 0 ; JPanel infoPanel = new JPanel ( ) ; scroller . setViewportView ( infoPanel ) ; initLayout ( infoPanel ) ; for ( int match = lastMatch - 1 ; match >= 0 ; match -- ) { if ( match == firstMatch ) { buildMatchHeaders ( match , infoPanel , true , columnHeaders ) ; } maxRounds += buildMatchHistory ( match , infoPanel , maxRounds ) ; } JPanel filler = new JPanel ( ) ; gridbag . setConstraints ( filler , fillerConstraints ) ; infoPanel . add ( filler ) ; scroller . getVerticalScrollBar ( ) . setMaximum ( infoPanel . getPreferredSize ( ) . height ) ; if ( setInfo . length > 1 ) setPanel . add ( "Set " + ( i + 1 ) , scroller ) ; else singleSetScroller = scroller ; } if ( setInfo . length > 1 ) { FullPanel . add ( setPanel ) ; setPanel . setSelectedIndex ( setPanel . getComponentCount ( ) - 1 ) ; } else FullPanel . add ( singleSetScroller ) ; }
tr	3	public static List < Card > getAllPossiblePlayableCards ( Suit s , Suit trump ) { List < Card > cardList = new LinkedList < Card > ( ) ; Suit sSuit = new Suit ( "s" ) ; cardList . addAll ( Card . getAllCardsInSuit ( s ) ) ; if ( ! s . equals ( sSuit ) ) { cardList . addAll ( Card . getAllCardsInSuit ( sSuit ) ) ; } if ( ! trump . equals ( s ) && ! trump . equals ( sSuit ) ) { cardList . addAll ( Card . getAllCardsInSuit ( trump ) ) ; } return cardList ; }
tr	5	private void addFileDropTarget ( Composite parent ) { final FileTransfer fileTransfer = FileTransfer . getInstance ( ) ; DropTarget target = new DropTarget ( parent , DND . DROP_COPY | DND . DROP_DEFAULT ) ; target . setTransfer ( new Transfer [ ] { fileTransfer } ) ; target . addDropListener ( new DropTargetListener ( ) { public void dragEnter ( DropTargetEvent event ) { if ( event . detail == DND . DROP_DEFAULT ) { if ( ( event . operations & DND . DROP_COPY ) > 0 ) { event . detail = DND . DROP_COPY ; } else { event . detail = DND . DROP_NONE ; } } } public void drop ( DropTargetEvent event ) { if ( fileTransfer . isSupportedType ( event . currentDataType ) ) { String [ ] files = ( String [ ] ) event . data ; for ( String file : files ) { try { controller . openFile ( file ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; displayErrorMessage ( "Error loading file: " + e . getMessage ( ) ) ; } } } } public void dropAccept ( DropTargetEvent event ) { } public void dragOver ( DropTargetEvent event ) { } public void dragOperationChanged ( DropTargetEvent event ) { } public void dragLeave ( DropTargetEvent event ) { } } ) ; }
tr	0	@ Override public IGameController getController ( ) { return controller ; }
tr	2	public Hierarchy getHierarchy ( String id ) { for ( Hierarchy h : hierarchys ) { if ( h . getId ( ) . equalsIgnoreCase ( id ) ) { return h ; } } return null ; }
tr	5	private void calculateMissing ( ) { if ( totalBytes > - 1 ) { if ( usedBytes > - 1 && freeBytes == - 1 ) { freeBytes = totalBytes - usedBytes ; } else if ( usedBytes == - 1 && freeBytes > - 1 ) { usedBytes = totalBytes - freeBytes ; } } }
tr	1	private Activity getCompassActivity ( ) { if ( compassFunctionalityVerfiedActivity == null ) { compassFunctionalityVerfiedActivity = new CompassFunctionalityVerfiedActivity ( clientFactory ) ; } return compassFunctionalityVerfiedActivity ; }
tr	5	@ Override public String toString ( ) { String a = "" ; String b ; if ( ! playerScoreMinerals . keySet ( ) . equals ( playerShipLocations . keySet ( ) ) ) { for ( String s : playerScoreMinerals . keySet ( ) ) { System . out . println ( s ) ; } System . out . println ( "different from" ) ; for ( String s : playerShipLocations . keySet ( ) ) { System . out . println ( s ) ; } a = "\nthere seems to be an issue with the game state\n" ; } for ( String k : playerShipLocations . keySet ( ) ) { b = "" ; for ( BoardLocation bl : playerShipLocations . get ( k ) ) { b = b . concat ( " " + bl . row + " " + bl . col ) ; } a = a . concat ( k + ":" + b + "\n" ) ; a = a . concat ( k + " score:" + playerScoreMinerals . get ( k ) [ 0 ] + "\n" ) ; a = a . concat ( k + " minerals:" + playerScoreMinerals . get ( k ) [ 1 ] + "\n" ) ; } return a . concat ( separator ) ; }
tr	2	private ParserRuleMatcher token ( final TokenType tokenType ) { return new ParserRuleMatcher ( ) { @ Override public SyntaxNode match ( int tokenIndex , boolean throwFailure ) { tokenIndex = findToken ( tokenIndex , tokenType , null ) ; if ( tokenIndex == - 1 ) { if ( throwFailure ) throw new ParserError ( tokenIndex ) ; return null ; } return new SyntaxNode ( tokenIndex , tokenIndex + 1 ) ; } } ; }
tr	5	@ Override public void marshal ( Element agent , Document doc ) { super . marshal ( agent , doc ) ; agent . setAttribute ( "ROLE" , this . role . value ( ) ) ; if ( this . agenttype != null ) agent . setAttribute ( "AGENTTYPE" , this . agenttype . value ( ) ) ; if ( this . otherrole != null ) agent . setAttribute ( "OTHERROLE" , this . otherrole ) ; if ( this . othertype != null ) agent . setAttribute ( "OTHERTYPE" , this . othertype ) ; Element name = doc . createElementNS ( NS . METS . ns ( ) , "mets:name" ) ; name . setTextContent ( this . name ) ; agent . appendChild ( name ) ; if ( this . note != null ) { for ( String n : this . note ) { Element note ; note = doc . createElementNS ( NS . METS . ns ( ) , "mets:note" ) ; note . setTextContent ( n ) ; agent . appendChild ( note ) ; } } }
tr	5	private static void Merge ( int [ ] A , int p , int q , int r ) { int L1 = q - p + 1 ; int L2 = r - q ; int [ ] A1 = new int [ L1 + 1 ] ; int [ ] A2 = new int [ L2 + 1 ] ; for ( int i = 0 ; i < L1 ; i ++ ) { A1 [ i ] = A [ p + i ] ; } for ( int i = 0 ; i < L2 ; i ++ ) { A2 [ i ] = A [ q + i + 1 ] ; } A1 [ L1 ] = Integer . MAX_VALUE ; A2 [ L2 ] = Integer . MAX_VALUE ; int k = 0 , j = 0 ; for ( int i = p ; i <= r ; i ++ ) { if ( A1 [ k ] < A2 [ j ] ) { A [ i ] = A1 [ k ] ; k ++ ; } else { A [ i ] = A2 [ j ] ; j ++ ; } } System . out . println ( "" ) ; for ( int i : A ) { System . out . print ( i + "#" ) ; } System . out . println ( "" ) ; }
tr	0	public String getDescription ( ) { return description ; }
tr	6	protected Shape createTriangle ( float fx , float fy , float tx , float ty , boolean rot ) { int size = 15 ; float dx = tx - fx ; float dy = ty - fy ; float D = ( float ) Math . sqrt ( dx * dx + dy * dy ) ; float z = ( dx <= 0 ) ? fx - D : fx + D ; float mid = ( dx <= 0 ) ? fx - D / 2 : fx + D / 2 ; float dec = ( dx <= 0 ) ? size : - size ; GeneralPath gp = new GeneralPath ( ) ; gp . moveTo ( z , fy ) ; gp . lineTo ( z + dec , fy - size / 2 ) ; gp . moveTo ( z , fy ) ; gp . lineTo ( z + dec , fy + size / 2 ) ; gp . lineTo ( z + dec , fy - size / 2 ) ; if ( rot ) { gp . moveTo ( mid + dec , fy - size / 2 ) ; gp . curveTo ( mid , fy - size , mid , fy + size , mid + dec , fy + size / 2 ) ; } double alpha = ( dx > 0 ) ? Math . asin ( dy / D ) : - Math . asin ( dy / D ) ; return alpha != 0 ? gp . createTransformedShape ( AffineTransform . getRotateInstance ( alpha , fx , fy ) ) : gp ; }
tr	3	@ Override public Vector < ScoredDocument > runQuery ( Query query , int numResults ) { Queue < ScoredDocument > rankQueue = new PriorityQueue < ScoredDocument > ( ) ; AbstractSearcher searcher = indexer . createSearcher ( query ) ; Document doc = null ; int docid = - 1 ; while ( ( doc = searcher . nextDoc ( docid ) ) != null ) { ScoredDocument scoredDoc = runquery ( query , doc ) ; rankQueue . add ( scoredDoc ) ; if ( rankQueue . size ( ) > numResults ) { rankQueue . poll ( ) ; } docid = doc . docId ; } Vector < ScoredDocument > results = new Vector < ScoredDocument > ( ) ; ScoredDocument scoredDoc = null ; while ( ( scoredDoc = rankQueue . poll ( ) ) != null ) { results . add ( scoredDoc ) ; } Collections . sort ( results , Collections . reverseOrder ( ) ) ; return results ; }
tr	1	public static TileObjectDisplayData getWeaponDisplayData ( Weapon w ) { TileObjectDisplayData data = getItemDisplayData ( w ) ; data . type = "Weapon" ; if ( w == null ) { data . addDatum ( "Attack" , "1" , true ) ; } else { data . addDatum ( "Attack" , Integer . toString ( w . getAttackValue ( ) ) , true ) ; } return data ; }
tr	8	private void wundergroundPast ( Date date ) throws Exception { for ( int tries = 0 ; tries < 7 ; tries ++ ) { File outfile = null ; FileWriter fileWriter = null ; PrintWriter out = null ; if ( debug ) { SimpleDateFormat format = new SimpleDateFormat ( "yyyyMMdd'T'kkmmssSSS" ) ; outfile = new File ( "test\\test" + format . format ( Calendar . getInstance ( ) . getTime ( ) ) + ".html" ) ; fileWriter = new FileWriter ( outfile , false ) ; out = new PrintWriter ( fileWriter , true ) ; out . println ( MakeURL . pastWundergroundURL ( zip , date ) ) ; } InputStreamReader webStream = null ; URL url = null ; try { url = new URL ( MakeURL . pastWundergroundURL ( zip , date ) ) ; webStream = new InputStreamReader ( url . openStream ( ) ) ; LineReader lr = new LineReader ( webStream , out ) ; try { lr . skipTo ( "history data available" ) ; System . out . println ( "no history data available for " + this . zip ) ; webStream . close ( ) ; this . op = null ; this . hp = null ; return ; } catch ( NullPointerException e ) { } webStream = new InputStreamReader ( url . openStream ( ) ) ; getPastWData ( new LineReader ( webStream , out ) ) ; this . past = new PastData ( this . zip , new SimpleDateFormat ( "yyyy-MM-dd" ) . format ( date ) , this . op , this . hp ) ; webStream . close ( ) ; if ( debug ) { out . close ( ) ; fileWriter . close ( ) ; outfile . delete ( ) ; } return ; } catch ( NullPointerException e ) { if ( webStream != null ) webStream . close ( ) ; System . out . println ( "Reading past weather data failed for " + this . zip + "." ) ; System . out . println ( url ) ; if ( debug ) { out . close ( ) ; fileWriter . close ( ) ; } Thread . sleep ( 1000 ) ; if ( this . op == null ) { this . op = new OverallPast ( ) ; } } } }
tr	1	@ Override public boolean removeLogicable ( Logical logicable ) { if ( logicable != null ) { return logicablesToChange . add ( new Tuple < Logical , boolean > ( logicable , false ) ) ; } return false ; }
tr	1	public List < Frequencia > getFrequenciaFuncionario ( Integer mes , Integer ano , Integer idFuncionario ) throws SQLException { List < Frequencia > frequencia = new ArrayList < Frequencia > ( ) ; con = cp . getconection ( ) ; String sql = "SELECT z.dia  z.data  z.idFuncionario  f.nome  f.portaria  z.presenca FROM funcionario f  (frequencia fr join (Select data as dt  Extract('Day' From data) as dia From frequencia where idFuncionario = 13) x ON x.dt = fr.data) z WHERE f.id = z.idFuncionario AND z.idFuncionario = ? AND z.data between ? AND ? order by z.data asc" ; PreparedStatement ps = con . prepareStatement ( sql , ResultSet . TYPE_SCROLL_SENSITIVE , ResultSet . CONCUR_UPDATABLE ) ; ps . setInt ( 1 , idFuncionario ) ; Calendar c = Calendar . getInstance ( ) ; c . set ( ano , ( mes - 2 ) , 21 ) ; Date dataInicial = new Date ( c . getTimeInMillis ( ) ) ; ps . setDate ( 2 , dataInicial ) ; UtilFrequencia utilFrequencia = new UtilFrequencia ( ) ; c . set ( ano , mes , 20 ) ; Date dataFinal = new Date ( c . getTimeInMillis ( ) ) ; ps . setDate ( 3 , dataFinal ) ; Frequencia f ; ResultSet rs = ps . executeQuery ( ) ; while ( rs . next ( ) ) { f = new Frequencia ( ) ; f . setData ( rs . getDate ( "data" ) ) ; f . setPresenca ( rs . getBoolean ( "presenca" ) ) ; f . setFuncionario ( new FuncionarioDao ( ) . getfuncionario ( rs . getInt ( "idFuncionario" ) ) ) ; f . setAux ( ( int ) rs . getDouble ( "dia" ) ) ; frequencia . add ( f ) ; } return frequencia ; }
tr	9	private void GUI1 ( ) { panel1 = new JPanel ( ) ; jtp . addTab ( "<html><body marginwidth=15 marginheight=15><b>Step 1:</b><br>Event Details</body></html>" , null , panel1 , "Manage the event details." ) ; panel1 . setLayout ( null ) ; JLabel lbl1_EventDetails = new JLabel ( "Event Details" ) ; lbl1_EventDetails . setFont ( new Font ( "Tahoma" , Font . BOLD , 16 ) ) ; lbl1_EventDetails . setBounds ( 10 , 10 , 126 , 30 ) ; panel1 . add ( lbl1_EventDetails ) ; JLabel lbl1_EventType = new JLabel ( "Event Type:" ) ; lbl1_EventType . setFont ( new Font ( "Tahoma" , Font . PLAIN , 12 ) ) ; lbl1_EventType . setBounds ( 10 , 59 , 100 , 14 ) ; panel1 . add ( lbl1_EventType ) ; comboBox1_EventType = new JComboBox < String > ( ) ; comboBox1_EventType . setBounds ( 120 , 56 , 195 , 20 ) ; panel1 . add ( comboBox1_EventType ) ; comboBox1_EventType . addItem ( "Select Event Type..." ) ; comboBox1_EventType . addItem ( "Anniversary" ) ; comboBox1_EventType . addItem ( "Award Ceremony" ) ; comboBox1_EventType . addItem ( "Birthday Party" ) ; comboBox1_EventType . addItem ( "Dinner and Dance" ) ; comboBox1_EventType . addItem ( "Festive Party" ) ; comboBox1_EventType . addItem ( "Seminar" ) ; comboBox1_EventType . addItem ( "Social Event" ) ; comboBox1_EventType . addItem ( "Talk / Speech" ) ; comboBox1_EventType . addItem ( "Wedding" ) ; comboBox1_EventType . addItem ( "Workshop" ) ; comboBox1_EventType . addActionListener ( new ComboBox1_EventType_Listener ( ) ) ; JLabel lbl1_EventName = new JLabel ( "Event Name:" ) ; lbl1_EventName . setFont ( new Font ( "Tahoma" , Font . PLAIN , 12 ) ) ; lbl1_EventName . setBounds ( 10 , 100 , 100 , 14 ) ; panel1 . add ( lbl1_EventName ) ; textField1_EventName = new JTextField ( ) ; textField1_EventName . setBounds ( 120 , 97 , 435 , 20 ) ; panel1 . add ( textField1_EventName ) ; textField1_EventName . setColumns ( 10 ) ; textField1_EventName . addFocusListener ( this ) ; JLabel lbl1_EventDate = new JLabel ( "Start Date:" ) ; lbl1_EventDate . setFont ( new Font ( "Tahoma" , Font . PLAIN , 12 ) ) ; lbl1_EventDate . setBounds ( 10 , 142 , 73 , 14 ) ; panel1 . add ( lbl1_EventDate ) ; dateChooser1_StartDate = new JDateChooser ( ) ; dateChooser1_StartDate . addPropertyChangeListener ( new PropertyChangeListener ( ) { public void propertyChange ( PropertyChangeEvent evt ) { if ( dateChooser1_StartDate . getDate ( ) != null ) { Date StartDate = dateChooser1_StartDate . getDate ( ) ; lg . setEventStartDate ( StartDate ) ; if ( lg . checkDate ( ) == false ) { JOptionPane . showMessageDialog ( new JFrame ( ) , "Start Date cannot " + "be after End Date!" , "Start Date Error" , JOptionPane . ERROR_MESSAGE ) ; dateChooser1_StartDate . setDate ( dateChooser1_EndDate . getDate ( ) ) ; } else { if ( lg . getEventEndDate ( ) != null ) { lg . setDateList ( lg . getEventStartDate ( ) , lg . getEventEndDate ( ) ) ; lg . checkProgrammeDates ( ) ; updateStep3 ( ) ; } } } comboBox1_MealDates . removeActionListener ( comboBoxActionListener ) ; if ( ! lg . getDateList ( ) . isEmpty ( ) ) { comboBox1_MealDates . removeAllItems ( ) ; Iterator < String > itr = lg . getDateList ( ) . iterator ( ) ; while ( itr . hasNext ( ) ) { comboBox1_MealDates . addItem ( itr . next ( ) ) ; } } comboBox1_MealDates . addActionListener ( comboBoxActionListener ) ; enableMealRaidoButtons ( ) ; } } ) ; dateChooser1_StartDate . setBounds ( 120 , 142 , 117 , 20 ) ; panel1 . add ( dateChooser1_StartDate ) ; JLabel lbl1_StartTime = new JLabel ( "Start Time:" ) ; lbl1_StartTime . setFont ( new Font ( "Tahoma" , Font . PLAIN , 12 ) ) ; lbl1_StartTime . setBounds ( 264 , 142 , 68 , 14 ) ; panel1 . add ( lbl1_StartTime ) ; JLabel lbl1_StartTimeH = new JLabel ( "H" ) ; lbl1_StartTimeH . setFont ( new Font ( "Tahoma" , Font . PLAIN , 12 ) ) ; lbl1_StartTimeH . setBounds ( 342 , 142 , 14 , 14 ) ; panel1 . add ( lbl1_StartTimeH ) ; spinner1_StartTimeH = new JSpinner ( ) ; spinner1_StartTimeH . setModel ( new SpinnerNumberModel ( 0 , 0 , 23 , 1 ) ) ; spinner1_StartTimeH . setBounds ( 357 , 140 , 40 , 20 ) ; panel1 . add ( spinner1_StartTimeH ) ; spinner1_StartTimeH . addChangeListener ( new SpinnerListeners ( ) ) ; JLabel lbl1_StartTimeM = new JLabel ( "M" ) ; lbl1_StartTimeM . setFont ( new Font ( "Tahoma" , Font . PLAIN , 12 ) ) ; lbl1_StartTimeM . setBounds ( 401 , 143 , 14 , 14 ) ; panel1 . add ( lbl1_StartTimeM ) ; spinner1_StartTimeM = new JSpinner ( ) ; spinner1_StartTimeM . setModel ( new SpinnerNumberModel ( 0 , 0 , 59 , 1 ) ) ; spinner1_StartTimeM . setBounds ( 417 , 140 , 40 , 20 ) ; panel1 . add ( spinner1_StartTimeM ) ; spinner1_StartTimeM . addChangeListener ( new SpinnerListeners ( ) ) ; JLabel lbl1_EndDate = new JLabel ( "End Date:" ) ; lbl1_EndDate . setFont ( new Font ( "Tahoma" , Font . PLAIN , 12 ) ) ; lbl1_EndDate . setBounds ( 10 , 182 , 60 , 14 ) ; panel1 . add ( lbl1_EndDate ) ; dateChooser1_EndDate = new JDateChooser ( ) ; dateChooser1_EndDate . addPropertyChangeListener ( new PropertyChangeListener ( ) { public void propertyChange ( PropertyChangeEvent evt ) { if ( dateChooser1_EndDate . getDate ( ) != null ) { Date EndDate = dateChooser1_EndDate . getDate ( ) ; lg . setEventEndDate ( EndDate ) ; if ( lg . checkDate ( ) == false ) { JOptionPane . showMessageDialog ( new JFrame ( ) , "End Date cannot " + "be before Start Date!" , "End Date Error" , JOptionPane . ERROR_MESSAGE ) ; dateChooser1_EndDate . setDate ( dateChooser1_StartDate . getDate ( ) ) ; } else { if ( lg . getEventStartDate ( ) != null ) { lg . setDateList ( lg . getEventStartDate ( ) , lg . getEventEndDate ( ) ) ; lg . checkProgrammeDates ( ) ; updateStep3 ( ) ; } } } comboBox1_MealDates . removeActionListener ( comboBoxActionListener ) ; if ( ! lg . getDateList ( ) . isEmpty ( ) ) { comboBox1_MealDates . removeAllItems ( ) ; Iterator < String > itr = lg . getDateList ( ) . iterator ( ) ; while ( itr . hasNext ( ) ) { comboBox1_MealDates . addItem ( itr . next ( ) ) ; } } comboBox1_MealDates . addActionListener ( comboBoxActionListener ) ; enableMealRaidoButtons ( ) ; } } ) ; dateChooser1_EndDate . setBounds ( 120 , 182 , 117 , 20 ) ; panel1 . add ( dateChooser1_EndDate ) ; JLabel lbl1_EndTime = new JLabel ( "End Time:" ) ; lbl1_EndTime . setFont ( new Font ( "Tahoma" , Font . PLAIN , 12 ) ) ; lbl1_EndTime . setBounds ( 264 , 183 , 60 , 14 ) ; panel1 . add ( lbl1_EndTime ) ; JLabel label1_EndTimeH = new JLabel ( "H" ) ; label1_EndTimeH . setFont ( new Font ( "Tahoma" , Font . PLAIN , 12 ) ) ; label1_EndTimeH . setBounds ( 342 , 184 , 14 , 14 ) ; panel1 . add ( label1_EndTimeH ) ; spinner1_EndTimeH = new JSpinner ( ) ; spinner1_EndTimeH . setModel ( new SpinnerNumberModel ( 0 , 0 , 23 , 1 ) ) ; spinner1_EndTimeH . setBounds ( 357 , 182 , 40 , 20 ) ; panel1 . add ( spinner1_EndTimeH ) ; spinner1_EndTimeH . addChangeListener ( new SpinnerListeners ( ) ) ; JLabel label1_EndTimeM = new JLabel ( "M" ) ; label1_EndTimeM . setFont ( new Font ( "Tahoma" , Font . PLAIN , 12 ) ) ; label1_EndTimeM . setBounds ( 401 , 185 , 14 , 14 ) ; panel1 . add ( label1_EndTimeM ) ; spinner1_EndTimeM = new JSpinner ( ) ; spinner1_EndTimeM . setModel ( new SpinnerNumberModel ( 0 , 0 , 59 , 1 ) ) ; spinner1_EndTimeM . setBounds ( 417 , 182 , 40 , 20 ) ; panel1 . add ( spinner1_EndTimeM ) ; spinner1_EndTimeM . addChangeListener ( new SpinnerListeners ( ) ) ; JLabel lbl1_EventDescription = new JLabel ( "Event Description:" ) ; lbl1_EventDescription . setFont ( new Font ( "Tahoma" , Font . PLAIN , 12 ) ) ; lbl1_EventDescription . setBounds ( 10 , 264 , 100 , 14 ) ; panel1 . add ( lbl1_EventDescription ) ; JScrollPane scrollPane1 = new JScrollPane ( ) ; scrollPane1 . setBounds ( 120 , 260 , 435 , 171 ) ; panel1 . add ( scrollPane1 ) ; textArea1_EventDescription = new JTextArea ( ) ; scrollPane1 . setViewportView ( textArea1_EventDescription ) ; textArea1_EventDescription . setDragEnabled ( true ) ; textArea1_EventDescription . setLineWrap ( true ) ; textArea1_EventDescription . setWrapStyleWord ( true ) ; textArea1_EventDescription . addFocusListener ( this ) ; JLabel lbl1_Budget = new JLabel ( "Budget:          $" ) ; lbl1_Budget . setFont ( new Font ( "Tahoma" , Font . BOLD , 12 ) ) ; lbl1_Budget . setBounds ( 10 , 451 , 100 , 14 ) ; panel1 . add ( lbl1_Budget ) ; textField1_budget = new JTextField ( ) ; textField1_budget . setToolTipText ( "" ) ; textField1_budget . setColumns ( 10 ) ; textField1_budget . setBounds ( 120 , 449 , 117 , 20 ) ; panel1 . add ( textField1_budget ) ; textField1_budget . addFocusListener ( this ) ; JButton btn1_Next = new JButton ( "Next" ) ; btn1_Next . addMouseListener ( this ) ; btn1_Next . setFont ( new Font ( "Tahoma" , Font . BOLD , 12 ) ) ; btn1_Next . setBounds ( 560 , 490 , 80 , 30 ) ; panel1 . add ( btn1_Next ) ; JLabel lbl1_MealDate = new JLabel ( "Meal Date:" ) ; lbl1_MealDate . setFont ( new Font ( "Tahoma" , Font . PLAIN , 12 ) ) ; lbl1_MealDate . setBounds ( 10 , 224 , 70 , 14 ) ; panel1 . add ( lbl1_MealDate ) ; comboBox1_MealDates = new JComboBox < String > ( ) ; comboBox1_MealDates . setBounds ( 120 , 222 , 117 , 20 ) ; panel1 . add ( comboBox1_MealDates ) ; comboBox1_MealDates . addActionListener ( comboBoxActionListener ) ; JLabel lbl1_MealType = new JLabel ( "Meal Type:" ) ; lbl1_MealType . setFont ( new Font ( "Tahoma" , Font . PLAIN , 12 ) ) ; lbl1_MealType . setBounds ( 264 , 224 , 68 , 14 ) ; panel1 . add ( lbl1_MealType ) ; rdbtn1_Lunch = new JRadioButton ( "Lunch" ) ; rdbtn1_Lunch . setEnabled ( false ) ; lg . setMealRadioButtons ( 0 , false ) ; rdbtn1_Lunch . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent arg0 ) { lg . setMealType ( 0 ) ; } } ) ; buttonGroup1 . add ( rdbtn1_Lunch ) ; rdbtn1_Lunch . setBounds ( 342 , 221 , 55 , 23 ) ; panel1 . add ( rdbtn1_Lunch ) ; rdbtn1_Dinner = new JRadioButton ( "Dinner" ) ; rdbtn1_Dinner . setEnabled ( false ) ; lg . setMealRadioButtons ( 1 , false ) ; rdbtn1_Dinner . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { lg . setMealType ( 1 ) ; } } ) ; buttonGroup1 . add ( rdbtn1_Dinner ) ; rdbtn1_Dinner . setBounds ( 417 , 221 , 60 , 23 ) ; panel1 . add ( rdbtn1_Dinner ) ; }
tr	5	private static < E > void merge ( E [ ] array , E [ ] temp , int begin , int end , Comparator < E > comparator ) { int i = begin ; int tracker = begin ; int middex = ( begin + end ) / 2 ; int rightstart = middex + 1 ; while ( i <= middex && rightstart <= end ) { if ( comparator . compare ( array [ i ] , array [ rightstart ] ) <= 0 ) { temp [ tracker ++ ] = array [ i ++ ] ; } else { temp [ tracker ++ ] = array [ rightstart ++ ] ; } } while ( i <= middex ) { temp [ tracker ++ ] = array [ i ++ ] ; } int elements = tracker - begin ; for ( int j = 0 ; j < elements ; j ++ ) { array [ begin + j ] = temp [ begin + j ] ; } }
tr	1	public int getMaxQuantity ( int quantity ) { if ( currentQuantity + quantity > maxQuantity ) { throw new StoreProblemException ( ) ; } return currentQuantity + quantity ; }
tr	4	@ SuppressWarnings ( "unchecked" ) public Component getTableCellEditorComponent ( JTable table , Object value , boolean isSelected , int row , int column ) { String serviceName = ( String ) table . getValueAt ( row , column - 1 ) ; HashMap < String , String > userStatusAssoc ; User user = instanceGUI . getUser ( ) ; if ( user . getServiceTransfer ( serviceName ) != null ) return null ; if ( user . isEmptyServiceList ( ) || user . isEmptyService ( serviceName ) ) { JLabel label = new JLabel ( StatusMessages . inactive . toUpperCase ( ) ) ; label . setHorizontalAlignment ( SwingConstants . CENTER ) ; return label ; } JComboBox < String > combo = ( JComboBox < String > ) super . getTableCellEditorComponent ( table , value , isSelected , row , column ) ; userStatusAssoc = instanceGUI . getUser ( ) . getServiceProviders ( serviceName ) ; Set < String > keySet = userStatusAssoc . keySet ( ) ; Iterator < String > userNameIt = keySet . iterator ( ) ; ( ( JLabel ) combo . getRenderer ( ) ) . setHorizontalAlignment ( SwingConstants . CENTER ) ; combo . removeAllItems ( ) ; while ( userNameIt . hasNext ( ) ) { String userName = userNameIt . next ( ) ; String status = userStatusAssoc . get ( userName ) ; combo . addItem ( userName + "   " + status . toUpperCase ( ) ) ; } Object element = combo . getItemAt ( 0 ) ; combo . getModel ( ) . setSelectedItem ( element ) ; return combo ; }
tr	3	public JSONObject accumulate ( String key , Object value ) throws JSONException { testValidity ( value ) ; Object object = opt ( key ) ; if ( object == null ) { put ( key , value instanceof JSONArray ? new JSONArray ( ) . put ( value ) : value ) ; } else if ( object instanceof JSONArray ) { ( ( JSONArray ) object ) . put ( value ) ; } else { put ( key , new JSONArray ( ) . put ( object ) . put ( value ) ) ; } return this ; }
tr	4	protected final void measure ( int width , int height ) { Debug . log ( "MEASURING %s" , this ) ; if ( width == LayoutParameters . MATCH_PARENT ) { width = getParentWidth ( ) ; } if ( height == LayoutParameters . MATCH_PARENT ) { height = getParentHeight ( ) ; } onMeasure ( width , height ) ; if ( measuredWidth == NOT_SET || measuredHeight == NOT_SET ) { throw new IllegalStateException ( "View subclass (" + this + ") does not properly set the measured width or height." ) ; } Debug . log ( "MEASURED DIMENSIONS FOR (%s): width=%s  height=%s" , this , measuredWidth , measuredHeight ) ; }
tr	6	public void mergeScores ( ComputerPlay computer ) { int thisMatchScoresUntil = previousScores . length - 1 ; int themMatchScoresUntil = computer . previousScores . length - 1 ; Vector < Integer > newScores = new Vector < Integer > ( ) ; while ( thisMatchScoresUntil >= 0 && themMatchScoresUntil >= 0 && previousScores [ thisMatchScoresUntil ] == computer . previousScores [ themMatchScoresUntil ] ) { newScores . add ( previousScores [ thisMatchScoresUntil ] ) ; themMatchScoresUntil -- ; thisMatchScoresUntil -- ; } for ( ; thisMatchScoresUntil >= 0 ; thisMatchScoresUntil -- ) { newScores . add ( previousScores [ thisMatchScoresUntil ] ) ; } for ( ; themMatchScoresUntil >= 0 ; themMatchScoresUntil -- ) { newScores . add ( computer . previousScores [ themMatchScoresUntil ] ) ; } previousScores = new int [ newScores . size ( ) ] ; for ( int i = 0 ; i < newScores . size ( ) ; i ++ ) { previousScores [ ( newScores . size ( ) - i ) - 1 ] = newScores . get ( i ) ; } }
tr	8	private void parseConfLine ( SBConfig conf , String str ) { String delim = "[ ]" ; String [ ] tokens = str . split ( delim ) ; List < String > list = new ArrayList < String > ( ) ; for ( String s : tokens ) { if ( s != null && s . length ( ) > 0 ) { list . add ( s ) ; } } tokens = list . toArray ( new String [ list . size ( ) ] ) ; try { if ( tokens [ 0 ] . equals ( "FPAdder" ) ) { int i = Integer . parseInt ( tokens [ 1 ] ) ; conf . setNoOfFPAdder ( i ) ; } else if ( tokens [ 0 ] . equals ( "FPMultiplier" ) ) { int i = Integer . parseInt ( tokens [ 1 ] ) ; conf . setNoOfFPMultiplier ( i ) ; } else if ( tokens [ 0 ] . equals ( "FPDivider" ) ) { int i = Integer . parseInt ( tokens [ 1 ] ) ; conf . setNoOfFPDivider ( i ) ; } else if ( tokens [ 0 ] . equals ( "IntegerUnit" ) ) { int i = Integer . parseInt ( tokens [ 1 ] ) ; conf . setNoOfIntegerUnit ( i ) ; } else { log . error ( "Invalid config option provided" ) ; } } catch ( NumberFormatException e ) { log . error ( "Invalid config value provided" ) ; } }
tr	6	protected static void setEnvironment ( boolean disableHttp , boolean eagerHttpFallback , boolean disableDirectSocket , boolean enableDirectHTTP , boolean disablePlainHTTP , boolean useProxy , long connectionTimeout , boolean logging ) { System . setProperty ( "java.rmi.dgc.leaseValue" , Integer . toString ( GC_TIMEOUT ) ) ; System . setProperty ( "java.rmi.server.disableHttp" , boolean . toString ( disableHttp ) ) ; System . setProperty ( "harmony.rmi.transport.toProxy.eagerHttpFallback" , boolean . toString ( eagerHttpFallback ) ) ; System . setProperty ( "harmony.rmi.transport.disableDirectSocket" , boolean . toString ( disableDirectSocket ) ) ; System . setProperty ( "harmony.rmi.transport.toProxy.enableDirectHTTP" , boolean . toString ( enableDirectHTTP ) ) ; System . setProperty ( "harmony.rmi.transport.toProxy.disablePlainHTTP" , boolean . toString ( disablePlainHTTP ) ) ; System . setProperty ( "http.proxyHost" , ( useProxy ? PROXY_HOST : "" ) ) ; System . setProperty ( "http.proxyPort" , ( useProxy ? Integer . toString ( PROXY_PORT ) : "" ) ) ; System . setProperty ( "harmony.rmi.transport.connectionTimeout" , ( ( connectionTimeout > 0 ) ? long . toString ( connectionTimeout ) : "" ) ) ; System . setProperty ( "harmony.rmi.dgc.logLevel" , "VERBOSE" ) ; System . setProperty ( "harmony.rmi.transport.logLevel" , ( logging ? "VERBOSE" : "" ) ) ; System . setProperty ( "harmony.rmi.transport.tcp.logLevel" , ( logging ? "VERBOSE" : "" ) ) ; System . setProperty ( "harmony.rmi.transport.toProxy.logLevel" , ( logging ? "VERBOSE" : "" ) ) ; }
tr	6	private void saveButtonActionPerformed ( java . awt . event . ActionEvent evt ) { if ( nombrelaboratoriosField . getText ( ) . trim ( ) . isEmpty ( ) || telefonolaboratorios1Field . getText ( ) . trim ( ) . isEmpty ( ) || sucursalField . getText ( ) . trim ( ) . isEmpty ( ) ) { JOptionPane . showMessageDialog ( this , "Debe de llenar todos los campos marcados con * como minimo para poder guardar." , "ADVERTENCIA" , WIDTH ) ; } else { try { entityManager . getTransaction ( ) . commit ( ) ; entityManager . getTransaction ( ) . begin ( ) ; JOptionPane . showMessageDialog ( this , "Laboratorio guardado existosamente." , "Laboratorio guardado" , WIDTH ) ; entityManager . getTransaction ( ) . rollback ( ) ; entityManager . getTransaction ( ) . begin ( ) ; java . util . Collection data = query . getResultList ( ) ; for ( Object entity : data ) { entityManager . refresh ( entity ) ; } list . clear ( ) ; list . addAll ( data ) ; newButton . setEnabled ( true ) ; saveButton . setEnabled ( false ) ; } catch ( RollbackException rex ) { rex . printStackTrace ( ) ; entityManager . getTransaction ( ) . begin ( ) ; List < farmacia . Laboratorios > merged = new ArrayList < farmacia . Laboratorios > ( list . size ( ) ) ; for ( farmacia . Laboratorios l : list ) { merged . add ( entityManager . merge ( l ) ) ; } list . clear ( ) ; list . addAll ( merged ) ; newButton . setEnabled ( true ) ; } } }
tr	8	public static void main ( String [ ] args ) { final Random rnd = new Random ( System . currentTimeMillis ( ) ) ; final int input = 2 ; final int hidden = 8 ; final int trainset_size = 5000 ; final int testset_size = 100 ; final int epochs = 4000 ; final double learningrate = 0.004 ; final double momentum = 0.9 ; final MLPGenerator gen = new MLPGenerator ( ) ; gen . inputLayer ( input ) ; gen . hiddenLayer ( hidden , CellType . SIGMOID , true , - 1.0 ) ; gen . outputLayer ( 1 , CellType . SIGMOID ) ; final Net mlp = gen . generate ( ) ; mlp . initializeWeights ( rnd ) ; final SampleSet trainset = generateData ( trainset_size + testset_size , 0.5f , rnd ) ; final SampleSet testset = trainset . split ( testset_size , rnd ) ; GradientDescent trainer = new GradientDescent ( ) ; trainer . setEpochs ( epochs ) ; trainer . setLearningRate ( learningrate ) ; trainer . setMomentum ( momentum ) ; trainer . setPermute ( true ) ; trainer . setRnd ( rnd ) ; trainer . setTargetError ( 10E-5 ) ; trainer . setNet ( mlp ) ; trainer . setTrainingSet ( trainset ) ; trainer . addListener ( new NetTrainerListener ( ) { @ Override public void started ( NetTrainer trainer ) { } @ Override public void finished ( NetTrainer trainer ) { } @ Override public void epoch ( NetTrainer trainer ) { final int ep = trainer . getEpoch ( ) + 1 ; if ( ( ep ) % ( epochs / 16 ) != 0 && ep != 1 ) return ; final BufferedImage img = new BufferedImage ( 800 , 800 , BufferedImage . TYPE_INT_RGB ) ; double [ ] p = new double [ 2 ] ; double [ ] o = new double [ 2 ] ; for ( int y = 0 ; y < img . getHeight ( ) ; y ++ ) { for ( int x = 0 ; x < img . getWidth ( ) ; x ++ ) { p [ 0 ] = ( ( double ) x ) / ( ( double ) ( img . getWidth ( ) ) ) ; p [ 1 ] = ( ( double ) y ) / ( ( double ) ( img . getHeight ( ) ) ) ; mlp . reset ( ) ; mlp . input ( p , 0 ) ; mlp . compute ( ) ; mlp . output ( o , 0 ) ; int v = ( ( int ) ( o [ 0 ] * 255 ) ) ; img . setRGB ( x , y , ( ( v >> 1 ) << 8 ) | v ) ; } } final Graphics2D g = ( Graphics2D ) img . getGraphics ( ) ; g . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; for ( Sample s : trainset ) { int x = ( int ) ( ( double ) ( img . getWidth ( ) - 1 ) * s . getInput ( ) [ 0 ] ) ; int y = ( int ) ( ( double ) ( img . getHeight ( ) - 1 ) * s . getInput ( ) [ 1 ] ) ; if ( s . getTarget ( ) [ 0 ] > 0.5 ) { g . setColor ( CLASS_1 ) ; } else { g . setColor ( CLASS_2 ) ; } g . fillOval ( x - 2 , y - 2 , 5 , 5 ) ; } JFrame frame = new JFrame ( "Geometry Learning - Epoch: " + ep ) ; frame . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; JPanel panel = new JPanel ( ) { private static final long serialVersionUID = - 4307908552010057652 ; @ Override protected void paintComponent ( Graphics gfx ) { super . paintComponent ( gfx ) ; gfx . drawImage ( img , 0 , 0 , img . getWidth ( ) , img . getHeight ( ) , null ) ; } } ; panel . setPreferredSize ( new Dimension ( img . getWidth ( ) , img . getHeight ( ) ) ) ; frame . add ( panel ) ; frame . setResizable ( false ) ; frame . pack ( ) ; frame . setVisible ( true ) ; } } ) ; trainer . train ( ) ; System . out . println ( ) ; ClassificationValidator val = new ClassificationValidator ( mlp ) ; for ( Sample s : trainset ) { val . apply ( s ) ; } System . out . println ( "recognition accuracy on trainset: " + ( val . ratio ( ) * 100.0 ) + "%" ) ; val . reset ( ) ; for ( Sample s : testset ) { val . apply ( s ) ; } System . out . println ( "recognition accuracy on testset: " + ( val . ratio ( ) * 100.0 ) + "%" ) ; }
tr	7	private String getOrientationString ( Orientations o ) { String os = "unknown" ; if ( o == Orientations . horizontal ) os = "horizontal" ; if ( o == Orientations . left ) os = "90\u00B0 left" ; if ( o == Orientations . right ) os = "90\u00B0 right" ; if ( o == Orientations . upside ) os = "180\u00B0" ; if ( myTFTType == TFTTypes . tft_320_240 ) { os = os + " (320x240)" ; } if ( myTFTType == TFTTypes . tft_800_480 ) { os = os + " (800x480)" ; } if ( myTFTType == TFTTypes . tft_480_272 ) { os = os + " (480x272)" ; } return os ; }
tr	8	private void makeOrderButtonActionPerformed ( java . awt . event . ActionEvent evt ) { request . setService ( Constants . ClientService . buyTicket ) ; if ( orderFromUser . getFirstName ( ) == null || orderFromUser . getFirstName ( ) . equals ( "" ) ) { JOptionPane . showMessageDialog ( null , "\u041D\u0435\u043A\u043E\u0440\u0440\u0435\u043A\u0442\u043D\u043E \u0432\u0432\u0435\u0434\u0435\u043D\u043E \u0438\u043C\u044F. \u041F\u043E\u0432\u0442\u043E\u0440\u0438\u0442\u0435 \u0432\u0432\u043E\u0434" ) ; return ; } else if ( orderFromUser . getSecondName ( ) == null || orderFromUser . getSecondName ( ) . equals ( "" ) ) { JOptionPane . showMessageDialog ( null , "\u041D\u0435\u043A\u043E\u0440\u0440\u0435\u043A\u0442\u043D\u043E \u0432\u0432\u0435\u0434\u0435\u043D\u0430 \u0444\u0430\u043C\u0438\u043B\u0438\u044F. \u041F\u043E\u0432\u0442\u043E\u0440\u0438\u0442\u0435 \u0432\u0432\u043E\u0434" ) ; return ; } else if ( orderFromUser . getDateOfBirth ( ) == null ) { JOptionPane . showMessageDialog ( null , "\u041D\u0435\u043A\u043E\u0440\u0440\u0435\u043A\u0442\u043D\u043E \u0432\u0432\u0435\u0434\u0435\u043D\u0430 \u0434\u0430\u0442\u0430 \u0440\u043E\u0436\u0434\u0435\u043D\u0438\u044F. \u041F\u043E\u0432\u0442\u043E\u0440\u0438\u0442\u0435 \u0432\u0432\u043E\u0434" ) ; return ; } orderFromUser . setTrainNumber ( scheduleList . get ( row ) . getNumber ( ) ) ; orderFromUser . setFromStation ( scheduleList . get ( row ) . getFromStation ( ) ) ; request . setObject ( orderFromUser ) ; log . debug ( "Request object is prepared -> send data to server." ) ; try { response = ClientConnectionManager . connect ( request ) ; } catch ( ConnectToServerException ex ) { JOptionPane . showMessageDialog ( null , ex . getMessage ( ) ) ; } log . debug ( "Response object from server is obtained." ) ; if ( response . getStatus ( ) == Constants . StatusOfExecutedService . success ) infoTextPane . setText ( ( ( String ) response . getObject ( ) ) ) ; else if ( response . getStatus ( ) == Constants . StatusOfExecutedService . error ) infoTextPane . setText ( ( String ) response . getObject ( ) ) ; }
tr	2	@ Override public void write ( byte [ ] theBytes , int off , int len ) throws java . io . IOException { if ( suspendEncoding ) { this . out . write ( theBytes , off , len ) ; return ; } for ( int i = 0 ; i < len ; i ++ ) { write ( theBytes [ off + i ] ) ; } }
tr	3	@ Override protected byte [ ] encryptConcrete ( EncFSVolume volume , byte [ ] paddedDecFileName , byte [ ] fileIv ) throws EncFSCorruptDataException { try { return BlockCrypto . blockEncrypt ( volume , fileIv , paddedDecFileName ) ; } catch ( InvalidAlgorithmParameterException e ) { throw new EncFSCorruptDataException ( e ) ; } catch ( IllegalBlockSizeException e ) { throw new EncFSCorruptDataException ( e ) ; } catch ( BadPaddingException e ) { throw new EncFSCorruptDataException ( e ) ; } }
tr	2	public static byte max ( byte ... values ) { Precondition . checkNotEmptyOrNull ( values ) ; byte max = values [ 0 ] ; for ( byte b : values ) { if ( max < b ) { max = b ; } } return max ; }
tr	2	public static void pairsAndValues ( ) { int [ ] arr = { 1 , 2 , 3 } ; for ( int i = 0 ; i < arr . length ; i ++ ) for ( int j = 0 ; j < arr . length ; j ++ ) { System . out . print ( "Value : " + ( arr [ i ] + arr [ j ] ) ) ; System . out . println ( "  Pair : " + arr [ i ] + " and " + arr [ j ] ) ; } }
tr	1	private static File findFile ( String filePath , File classPath ) { File file = new File ( classPath , filePath ) ; return file . exists ( ) ? file : null ; }
tr	7	public static UnitOfWork create ( class < ? > workClass , TransactionPolicy policyGraph ) { UnitOfWork u = null ; try { Constructor < ? > c = workClass . getDeclaredConstructor ( ) ; c . setAccessible ( true ) ; u = ( UnitOfWork ) c . newInstance ( ) ; for ( Transaction t : policyGraph . getTransaction ( ) ) { if ( workClass . getName ( ) . equalsIgnoreCase ( t . getId ( ) ) ) { for ( Policy polInfo : t . getPolicy ( ) ) { class < ? > policy = class . forName ( polInfo . getId ( ) ) ; business . policy . Policy bp = ( business . policy . Policy ) policy . getDeclaredConstructor ( ) . newInstance ( ) ; bp . setPolicyInfo ( polInfo ) ; u . policies . add ( bp ) ; } break ; } } } catch ( NoSuchMethodException | SecurityException | InstantiationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException | ClassNotFoundException e ) { e . printStackTrace ( ) ; } return u ; }
tr	9	@ Override public Party getEnemyParty ( int level ) { Party party = new Party ( ) ; Random gen = new Random ( ) ; if ( level == 1 ) { if ( gen . nextInt ( 2 ) == 0 ) party . add ( new Goblin ( ) ) ; else party . add ( new Rat ( ) ) ; } else if ( level == 2 ) { if ( gen . nextInt ( 2 ) == 0 ) party . add ( new Orc ( ) ) ; else party . add ( new Zombie ( ) ) ; } else if ( level == 3 ) { party . add ( new Spider ( ) ) ; } else if ( level == 5 ) { party . add ( new Ogre ( ) ) ; } else if ( level == 7 ) { party . add ( new Gargoyle ( ) ) ; } else if ( level == 15 ) { party . add ( new Dragon ( ) ) ; } else { do { int enemy = gen . nextInt ( level ) + 1 ; party . addAll ( getEnemyParty ( enemy ) ) ; level = level - enemy ; } while ( level != 0 ) ; } return party ; }
tr	3	public static int getSizeSafe ( int [ ] sizes , int sizeType ) { if ( sizes == null || sizes [ sizeType ] == NOT_SET ) return sizeType == MAX ? LayoutUtil . INF : 0 ; return sizes [ sizeType ] ; }
tr	7	public FeatureVector createCC2FeatureVector ( DependencyInstance inst , int arg , int head , int child ) { FeatureVector fv = new FeatureVector ( numArcFeats ) ; int [ ] pos = inst . postagids ; int [ ] word = inst . formids ; int [ ] posA = inst . cpostagids ; int [ ] lemma = inst . lemmaids != null ? inst . lemmaids : inst . formids ; int [ ] [ ] feats = inst . featids ; int CP = pos [ arg ] ; int CW = word [ arg ] ; int HC = posA [ head ] ; int HL = lemma [ head ] ; int AC = posA [ child ] ; int AL = lemma [ child ] ; long code = 0 ; code = createArcCodePPP ( CC_CP_HC_AC , CP , HC , AC ) ; addArcFeature ( code , fv ) ; code = createArcCodeWWP ( CC_CP_HL_AL , HL , AL , CP ) ; addArcFeature ( code , fv ) ; code = createArcCodeWPP ( CC_CW_HC_AC , CW , HC , AC ) ; addArcFeature ( code , fv ) ; code = createArcCodePP ( HP_MP , pos [ head ] , pos [ child ] ) ; addArcFeature ( code , fv ) ; code = createArcCodePP ( HP_MP , posA [ head ] , posA [ child ] ) ; addArcFeature ( code , fv ) ; code = createArcCodeWP ( HW_MP , lemma [ head ] , pos [ child ] ) ; addArcFeature ( code , fv ) ; code = createArcCodeWP ( MW_HP , lemma [ child ] , pos [ head ] ) ; addArcFeature ( code , fv ) ; code = createArcCodeWW ( HW_MW , lemma [ head ] , lemma [ child ] ) ; addArcFeature ( code , fv ) ; if ( feats [ head ] != null && feats [ child ] != null ) { for ( int fh = 0 ; fh < feats [ head ] . length ; ++ fh ) { if ( feats [ head ] [ fh ] <= 0 ) continue ; for ( int fc = 0 ; fc < feats [ child ] . length ; ++ fc ) { if ( feats [ child ] [ fc ] <= 0 ) continue ; int IDH = feats [ head ] [ fh ] ; int IDM = feats [ child ] [ fc ] ; code = createArcCodePP ( HP_MP , IDH , IDM ) ; addArcFeature ( code , fv ) ; } } } return fv ; }
tr	7	@ Override public Type getType ( ) { switch ( presence . getType ( ) ) { case available : return Type . available ; case error : return Type . error ; case subscribe : return Type . subscribe ; case subscribed : return Type . subscribed ; case unavailable : return Type . unavailable ; case unsubscribe : return Type . unsubscribe ; case unsubscribed : return Type . unsubscribed ; default : throw new RuntimeException ( "Unknown type of presence: " + presence . getType ( ) ) ; } }
tr	2	public OptionSet getMatchingSet ( boolean ignoreUnmatched , boolean requireDataLast ) { for ( String setName : optionSets . keySet ( ) ) if ( check ( setName , ignoreUnmatched , requireDataLast ) ) return optionSets . get ( setName ) ; return null ; }
tr	1	public static JFrame makePreferencesWindow ( boolean alwaysOnTop , UIPreferences prefs , UIPreferencesChangeListener listener , ApplicationController controller ) { JFrame window = WindowUtils . getVisibleWindowByName ( NAME_PREFS ) ; if ( window == null ) { window = new ApplicationWindow ( "app.settings" , NAME_PREFS , new PreferencesPanel ( prefs , listener , controller ) , alwaysOnTop ) ; } return window ; }
tr	3	private int compareInputStreams ( InputStream encfsIs , InputStream decFsIs , String decodedFsFileName ) throws IOException { int bytesRead = 0 ; int bytesRead2 ; while ( bytesRead >= 0 ) { byte [ ] readBuf = new byte [ 128 ] ; byte [ ] readBuf2 = new byte [ 128 ] ; bytesRead = encfsIs . read ( readBuf ) ; bytesRead2 = decFsIs . read ( readBuf2 ) ; if ( bytesRead != bytesRead2 ) { logger . error ( "File bytes read missmatch {} ({}  {})" , new Object [ ] { decodedFsFileName , bytesRead , bytesRead2 } ) ; return - 1 ; } if ( ! Arrays . equals ( readBuf , readBuf2 ) ) { logger . error ( "File bytes missmatch {}" , decodedFsFileName ) ; return - 1 ; } } return 0 ; }
tr	6	public int iConomyversion ( ) { if ( iConomyversion == 0 ) { try { if ( packageExists ( new String [ ] { "net.milkbowl.vault.economy.Economy" } ) ) { iConomyversion = 2 ; plugin . getLogger ( ) . info ( "hooked into Vault" ) ; } else if ( packageExists ( new String [ ] { "com.nijikokun.register.payment.Methods" } ) ) { iConomyversion = 1 ; plugin . getLogger ( ) . info ( "hooked into Register" ) ; } else if ( packageExists ( new String [ ] { "com.iConomy.iConomy" , "com.iConomy.system.Account" , "com.iConomy.system.Holdings" } ) ) { iConomyversion = 5 ; plugin . getLogger ( ) . info ( "hooked into iConomy5" ) ; } else if ( packageExists ( new String [ ] { "com.iCo6.system.Accounts" } ) ) { iConomyversion = 6 ; plugin . getLogger ( ) . info ( "hooked into iConomy6" ) ; } else { plugin . getLogger ( ) . severe ( "cant hook into iConomy5  iConomy6  Vault or Register. Downloading Vault!" ) ; plugin . getLogger ( ) . severe ( " ************ Please download and configure Vault!!!!! **********" ) ; } } catch ( Exception E ) { E . printStackTrace ( ) ; iConomyversion = 0 ; } return iConomyversion ; } else { return 2 ; } }
tr	4	public void act ( int delta ) { for ( Method action : actions ) { try { action . invoke ( this , delta ) ; } catch ( IllegalArgumentException e ) { e . printStackTrace ( ) ; } catch ( IllegalAccessException e ) { e . printStackTrace ( ) ; } catch ( InvocationTargetException e ) { e . printStackTrace ( ) ; } } }
tr	9	public static String rowToString ( JSONArray ja ) { StringBuffer sb = new StringBuffer ( ) ; for ( int i = 0 ; i < ja . length ( ) ; i += 1 ) { if ( i > 0 ) { sb . append (   ) ; } Object object = ja . opt ( i ) ; if ( object != null ) { String string = object . toString ( ) ; if ( string . length ( ) > 0 && ( string . indexOf (   ) >= 0 || string . indexOf ( '' ) >= 0 || string . indexOf ( '' ) >= 0 || string . indexOf ( 0 ) >= 0 || string . charAt ( 0 ) == " ) ) { sb . append ( " ) ; int length = string . length ( ) ; for ( int j = 0 ; j < length ; j += 1 ) { char c = string . charAt ( j ) ; if ( c >=   && c != " ) { sb . append ( c ) ; } } sb . append ( " ) ; } else { sb . append ( string ) ; } } } sb . append ( '' ) ; return sb . toString ( ) ; }
tr	0	@ Override public FullVersion getVersion ( ) { return version ; }
tr	7	public void __doGet ( HttpServletRequest req , HttpServletResponse resp ) throws IOException , ServletException { Context ctx = ( Context ) req . getSession ( ) . getAttribute ( Authtoken . TOKEN ) ; if ( ctx == null ) { ctx = new Context ( ) ; } String questionId = new String ( ) ; if ( req . getPathInfo ( ) != null ) { questionId = "/" + Question . RESOURCE_NAME + "/" + req . getPathInfo ( ) . replaceAll ( "/" , "" ) ; } if ( ! questionId . equals ( "" ) ) { Message request = new Message ( ctx ) ; request . put ( Question . ID , questionId ) ; Message response = new Message ( ctx ) ; new QuestionService ( ) . doGet ( request , response ) ; Message profileReq = new Message ( ctx ) ; Message profileResp = new Message ( ctx ) ; profileReq . put ( Profile . ID , response . get ( Document . AUTHOR ) ) ; new ProfileService ( ) . doGet ( profileReq , profileResp ) ; response . put ( Profile . FULL_NAME , profileResp . get ( Profile . FULL_NAME ) ) ; req . setAttribute ( Question . RESOURCE_NAME , response ) ; List < Map < String , String >> answers = new ArrayList < Map < String , String >> ( ) ; Message answerResp , voteResp ; for ( Map < String , String > ref : response . getReferences ( Question . ANSWERS ) ) { request = new Message ( ctx ) ; request . put ( Answer . ID , ref . get ( Answer . ID ) ) ; answerResp = new Message ( ctx ) ; new AnswerService ( ) . doGet ( request , answerResp ) ; Map < String , String > answer = new HashMap < String , String > ( ) ; answer . put ( Answer . ID , answerResp . get ( Answer . ID ) ) ; answer . put ( Answer . CONTENT , answerResp . get ( Answer . CONTENT ) ) ; answer . put ( Answer . VOTES , answerResp . get ( Answer . VOTES ) ) ; answer . put ( Document . AUTHOR , answerResp . get ( Document . AUTHOR ) ) ; answer . put ( System . TIMESTAMP , answerResp . get ( System . TIMESTAMP ) ) ; profileReq = new Message ( ctx ) ; profileResp = new Message ( ctx ) ; profileReq . put ( Profile . ID , answerResp . get ( Document . AUTHOR ) ) ; new ProfileService ( ) . doGet ( profileReq , profileResp ) ; answer . put ( Profile . FULL_NAME , profileResp . get ( Profile . FULL_NAME ) ) ; if ( ctx != null ) { request = new Message ( ctx ) ; request . put ( Profile . ID , ctx . getLoggedInUserProfileId ( ) ) ; request . put ( Answer . ID , ref . get ( Answer . ID ) ) ; voteResp = new Message ( ctx ) ; new VoteService ( ) . doGet ( request , voteResp ) ; if ( voteResp . containsField ( Vote . ID ) ) { answer . put ( Vote . ID , voteResp . get ( Vote . ID ) ) ; answer . put ( Vote . VOTE , voteResp . get ( Vote . VOTE ) ) ; } } answers . add ( answer ) ; } req . setAttribute ( Answer . RESOURCE_NAME , answers ) ; Message eventRequest = new Message ( request . getContext ( ) ) ; eventRequest . put ( Event . DOCUMENT_TYPE , Question . RESOURCE_NAME ) ; eventRequest . put ( Event . TYPE , "GET" ) ; eventRequest . put ( Event . DESCRIPTION , "View Question" ) ; eventRequest . put ( Event . OBJECT , questionId ) ; eventRequest . put ( Event . USER , ctx . getLoggedInUserProfileId ( ) ) ; eventRequest . put ( Event . TIMESTAMP , request . get ( System . TIMESTAMP ) ) ; EventPublisherService pub = new EventPublisherService ( ) ; pub . doPost ( eventRequest , response ) ; super . forward ( QUESTION_VIEW , req , resp ) ; } else { Message request = new Message ( ctx ) ; if ( req . getParameter ( QuestionSearchIndex . QUERY_STRING ) != null ) { request . put ( QuestionSearchIndex . QUERY_STRING , req . getParameter ( QuestionSearchIndex . QUERY_STRING ) ) ; } else { request . put ( QuestionSearchIndex . QUERY_STRING , "" ) ; } Message response = new Message ( ctx ) ; new QuestionService ( ) . doGet ( request , response ) ; response . put ( QuestionSearchIndex . QUERY_STRING , request . get ( QuestionSearchIndex . QUERY_STRING ) ) ; req . setAttribute ( Question . RESOURCE_NAME , response ) ; Message eventRequest = new Message ( request . getContext ( ) ) ; eventRequest . put ( Event . DOCUMENT_TYPE , QuestionSearchIndex . RESOURCE_NAME ) ; eventRequest . put ( Event . TYPE , "GET" ) ; eventRequest . put ( Event . DESCRIPTION , "Search Question" ) ; eventRequest . put ( Event . OBJECT , request . get ( QuestionSearchIndex . QUERY_STRING ) ) ; eventRequest . put ( Event . USER , ctx . getLoggedInUserProfileId ( ) ) ; eventRequest . put ( Event . TIMESTAMP , request . get ( System . TIMESTAMP ) ) ; EventPublisherService pub = new EventPublisherService ( ) ; pub . doPost ( eventRequest , response ) ; super . forward ( QUESTION_SEARCH_VIEW , req , resp ) ; } }
tr	0	@ Test public void testCloneSimpleBean ( ) { Bank bankFrom = new LocalBank ( ) ; bankFrom . setId ( 1 ) ; bankFrom . setName ( "Alfabank" ) ; Subject payer = new Subject ( ) ; payer . setBank ( bankFrom ) ; payer . setId ( "payer" ) ; payer . setName ( "Alice" ) ; Bank bankTo = new ForeignBank ( ) ; bankTo . setId ( 2 ) ; bankTo . setName ( "Citibank" ) ; Subject receiver = new Subject ( ) ; receiver . setBank ( bankTo ) ; receiver . setId ( "receiver" ) ; receiver . setName ( "Alice" ) ; Payment pay = new Payment ( 100 ) ; pay . setAmount ( new BigDecimal ( "123.45" ) ) ; pay . setPayer ( payer ) ; pay . setReceiver ( receiver ) ; pay . setTimestamp ( Instant . now ( ) ) ; Payment copy = BeanHelper . cloneOf ( pay ) ; assertNotSame ( pay , copy ) ; assertNotSame ( pay . getPayer ( ) , copy . getPayer ( ) ) ; assertNotSame ( pay . getReceiver ( ) , copy . getReceiver ( ) ) ; assertNotSame ( pay . getPayer ( ) . getBank ( ) , copy . getPayer ( ) . getBank ( ) ) ; assertNotSame ( pay . getReceiver ( ) . getBank ( ) , copy . getReceiver ( ) . getBank ( ) ) ; assertEquals ( pay . getAmount ( ) , copy . getAmount ( ) ) ; assertEquals ( pay . getId ( ) , copy . getId ( ) ) ; assertEquals ( pay . getTimestamp ( ) , copy . getTimestamp ( ) ) ; Subject cPayer = copy . getPayer ( ) ; Subject cReceiver = copy . getReceiver ( ) ; Bank cBankFrom = cPayer . getBank ( ) ; Bank cBankTo = cReceiver . getBank ( ) ; assertEquals ( payer . getId ( ) , cPayer . getId ( ) ) ; assertEquals ( payer . getName ( ) , cPayer . getName ( ) ) ; assertEquals ( bankFrom . getId ( ) , cBankFrom . getId ( ) ) ; assertEquals ( bankFrom . getName ( ) , cBankFrom . getName ( ) ) ; assertSame ( bankFrom . getClass ( ) , cBankFrom . getClass ( ) ) ; assertEquals ( receiver . getId ( ) , cReceiver . getId ( ) ) ; assertEquals ( receiver . getName ( ) , cReceiver . getName ( ) ) ; assertEquals ( bankTo . getId ( ) , cBankTo . getId ( ) ) ; assertEquals ( bankTo . getName ( ) , cBankTo . getName ( ) ) ; assertSame ( bankTo . getClass ( ) , cBankTo . getClass ( ) ) ; }
tr	7	private static void load ( final ClassLoader loader , final LinkedList < IRCPluginDefinition > plugins , final File file , final String prefix ) { if ( file . isDirectory ( ) ) { if ( ! file . getName ( ) . startsWith ( "." ) ) { for ( final File f : file . listFiles ( ) ) { FilePluginSource . load ( loader , plugins , f , prefix + file . getName ( ) + "." ) ; } } } else { String name = prefix + file . getName ( ) ; final String ext = ".class" ; if ( name . endsWith ( ext ) && ! name . startsWith ( "." ) && ! name . contains ( "!" ) && ! name . contains ( "$" ) ) { name = name . substring ( 0 , name . length ( ) - ext . length ( ) ) ; FilePluginSource . load ( loader , plugins , name , file . getAbsolutePath ( ) ) ; } } }
