te	2	private static void loadDomains ( char domains [ ] [ ] , Buffer stream ) { for ( int d = 0 ; d < domains . length ; d ++ ) { char domain [ ] = new char [ stream . getUnsignedByte ( ) ] ; for ( int c = 0 ; c < domain . length ; c ++ ) domain [ c ] = ( char ) stream . getUnsignedByte ( ) ; domains [ d ] = domain ; } }
te	9	public int getMonthNumber ( String month ) { if ( month . equals ( "January" ) ) { return 1 ; } else if ( month . equals ( "February" ) ) { return 2 ; } else if ( month . equals ( "March" ) ) { return 3 ; } else if ( month . equals ( "April" ) ) { return 4 ; } else if ( month . equals ( "May" ) ) { return 5 ; } else if ( month . equals ( "June" ) ) { return 6 ; } else if ( month . equals ( "July" ) ) { return 7 ; } else if ( month . equals ( "August" ) ) { return 8 ; } else if ( month . equals ( "September" ) ) { return 9 ; } else if ( month . equals ( "October" ) ) { return 10 ; } else if ( month . equals ( "November" ) ) { return 11 ; } else if ( month . equals ( "December" ) ) { return 12 ; } else { return 13 ; } }
te	4	private ClientApp ( DataInputStream in , DataOutputStream out ) { super ( new GridLayout ( ) ) ; this . in = in ; this . out = out ; try { out . writeUTF ( "SELECT_PRODUKTY" ) ; out . flush ( ) ; int size = in . readInt ( ) ; if ( size <= 0 ) data = null ; else { int size2 = in . readInt ( ) - 1 ; for ( int i = 0 ; i < size ; i ++ ) { Object [ ] w = new Object [ size2 ] ; for ( int j = 0 ; j < 4 ; j ++ ) { w [ j ] = in . readUTF ( ) ; } data . add ( w ) ; } } } catch ( IOException e ) { e . printStackTrace ( ) ; } model = new SerachList ( data ) ; JTable table = new JTable ( model ) ; Dimension screenSize = Toolkit . getDefaultToolkit ( ) . getScreenSize ( ) ; table . setPreferredScrollableViewportSize ( new Dimension ( screenSize . width / 6 , screenSize . height / 2 ) ) ; table . setFillsViewportHeight ( true ) ; table . setAutoCreateRowSorter ( true ) ; table . getSelectionModel ( ) . addListSelectionListener ( new RowListener ( ) ) ; JScrollPane scrollPane = new JScrollPane ( table ) ; add ( scrollPane ) ; table . setSelectionMode ( ListSelectionModel . SINGLE_SELECTION ) ; JButton b1 = new JButton ( "Dodaj do koszyka" ) ; b1 . setVerticalTextPosition ( AbstractButton . BOTTOM ) ; b1 . setHorizontalTextPosition ( AbstractButton . LEFT ) ; b1 . setMnemonic ( KeyEvent . VK_M ) ; b1 . addActionListener ( this ) ; JLabel label = new JLabel ( "Menu" , JLabel . CENTER ) ; label . setVerticalTextPosition ( JLabel . BOTTOM ) ; label . setHorizontalTextPosition ( JLabel . CENTER ) ; JButton b2 = new JButton ( "Wyszukaj" ) ; b2 . setVerticalTextPosition ( AbstractButton . BOTTOM ) ; b2 . setHorizontalTextPosition ( AbstractButton . LEFT ) ; b2 . setMnemonic ( KeyEvent . VK_M ) ; b2 . addActionListener ( this ) ; JButton b3 = new JButton ( "Wyczysc liste zakupow" ) ; b3 . setVerticalTextPosition ( AbstractButton . VERTICAL ) ; b3 . setHorizontalTextPosition ( AbstractButton . CENTER ) ; b3 . setMnemonic ( KeyEvent . VK_M ) ; b3 . addActionListener ( this ) ; JButton b4 = new JButton ( "Usun" ) ; b4 . setVerticalTextPosition ( AbstractButton . VERTICAL ) ; b4 . setHorizontalTextPosition ( AbstractButton . CENTER ) ; b4 . setMnemonic ( KeyEvent . VK_M ) ; b4 . addActionListener ( this ) ; JButton b5 = new JButton ( "Opinie" ) ; b5 . setAction ( action ) ; b5 . setVerticalTextPosition ( AbstractButton . VERTICAL ) ; b5 . setHorizontalTextPosition ( AbstractButton . CENTER ) ; b5 . setMnemonic ( KeyEvent . VK_M ) ; b5 . addActionListener ( this ) ; JButton b6 = new JButton ( "Recenzje" ) ; b6 . setVerticalTextPosition ( AbstractButton . VERTICAL ) ; b6 . setHorizontalTextPosition ( AbstractButton . CENTER ) ; b6 . setMnemonic ( KeyEvent . VK_M ) ; b6 . addActionListener ( this ) ; JPanel panel = new JPanel ( ) ; panel . setLayout ( new BoxLayout ( panel , BoxLayout . Y_AXIS ) ) ; JPanel firstPanel = new JPanel ( ) ; firstPanel . setLayout ( new GridLayout ( 4 , 4 ) ) ; firstPanel . setMaximumSize ( new Dimension ( 400 , 400 ) ) ; b1 . setAlignmentX ( Component . CENTER_ALIGNMENT ) ; b2 . setAlignmentX ( Component . CENTER_ALIGNMENT ) ; b3 . setAlignmentX ( Component . CENTER_ALIGNMENT ) ; b4 . setAlignmentX ( Component . CENTER_ALIGNMENT ) ; b5 . setAlignmentX ( Component . CENTER_ALIGNMENT ) ; b6 . setAlignmentX ( Component . CENTER_ALIGNMENT ) ; firstPanel . add ( b1 ) ; firstPanel . add ( b2 ) ; firstPanel . add ( b3 ) ; firstPanel . add ( b4 ) ; firstPanel . add ( b5 ) ; firstPanel . add ( b6 ) ; panel . setOpaque ( false ) ; panel . add ( firstPanel ) ; add ( panel ) ; modelKoszyk = new Koszyk ( dataKoszyk ) ; JTable koszyk = new JTable ( modelKoszyk ) ; koszyk . setFillsViewportHeight ( true ) ; koszyk . setAutoCreateRowSorter ( true ) ; koszyk . getSelectionModel ( ) . addListSelectionListener ( new RowListener2 ( ) ) ; add ( koszyk ) ; }
te	1	@ Override public String toString ( ) { String resp = "[" + sigPosLibre + "]:" ; for ( int i = 0 ; i < sigPosLibre ; i ++ ) { resp += elems [ i ] + "-" ; } return resp ; }
te	9	static void drfti1 ( int n , float [ ] wa , int index , int [ ] ifac ) { float arg , argh , argld , fi ; int ntry = 0 , i , j = - 1 ; int k1 , l1 , l2 , ib ; int ld , ii , ip , is , nq , nr ; int ido , ipm , nfm1 ; int nl = n ; int nf = 0 ; int state = 101 ; loop : while ( true ) { switch ( state ) { case 101 : j ++ ; if ( j < 4 ) ntry = ntryh [ j ] ; else ntry += 2 ; case 104 : nq = nl / ntry ; nr = nl - ntry * nq ; if ( nr != 0 ) { state = 101 ; break ; } nf ++ ; ifac [ nf + 1 ] = ntry ; nl = nq ; if ( ntry != 2 ) { state = 107 ; break ; } if ( nf == 1 ) { state = 107 ; break ; } for ( i = 1 ; i < nf ; i ++ ) { ib = nf - i + 1 ; ifac [ ib + 1 ] = ifac [ ib ] ; } ifac [ 2 ] = 2 ; case 107 : if ( nl != 1 ) { state = 104 ; break ; } ifac [ 0 ] = n ; ifac [ 1 ] = nf ; argh = tpi / n ; is = 0 ; nfm1 = nf - 1 ; l1 = 1 ; if ( nfm1 == 0 ) return ; for ( k1 = 0 ; k1 < nfm1 ; k1 ++ ) { ip = ifac [ k1 + 2 ] ; ld = 0 ; l2 = l1 * ip ; ido = n / l2 ; ipm = ip - 1 ; for ( j = 0 ; j < ipm ; j ++ ) { ld += l1 ; i = is ; argld = ( float ) ld * argh ; fi = 0.f ; for ( ii = 2 ; ii < ido ; ii += 2 ) { fi += 1.f ; arg = fi * argld ; wa [ index + i ++ ] = ( float ) Math . cos ( arg ) ; wa [ index + i ++ ] = ( float ) Math . sin ( arg ) ; } is += ido ; } l1 = l2 ; } break loop ; } } }
te	1	@ Override protected void process ( Envelope envelope ) { this . getLogger ( ) . info ( "FightManagerDoer process\n\tstarting to detect what type this is" ) ; Message m = envelope . getMessage ( ) ; if ( m instanceof GetShellRequest ) { this . getLogger ( ) . info ( "FightManagerDoer process\n\tdetected GetShellRequest" ) ; Envelope reply = this . processGetShellRequest ( envelope , ( GetShellRequest ) m ) ; this . getCommunicator ( ) . addToOutputQueue ( reply ) ; } }
te	4	@ Test public void testGetContactsByType ( ) throws FileNotFoundException { AddressBook a = new AddressBook ( ) ; Random v = new Random ( ) ; a . populateAddressBook ( ) ; for ( int i = 0 ; i < a . getNumContacts ( ) ; i ++ ) { a . getAllContacts ( ) [ i ] . setContactType ( ContactType . values ( ) [ v . nextInt ( 3 ) ] ) ; } Contact [ ] d = a . listByContactType ( ContactType . FAMILY ) ; for ( int i = 0 ; i < a . getNumContacts ( ) ; i ++ ) { System . out . println ( a . getAllContacts ( ) [ i ] . toString ( ) + a . getAllContacts ( ) [ i ] . getContactType ( ) ) ; } System . out . println ( "Array Length: " + d . length ) ; for ( int i = 0 ; i < d . length ; i ++ ) { if ( d [ i ] != null ) { System . out . println ( Integer . valueOf ( i + 1 ) + " " + d [ i ] . toString ( ) ) ; } } }
te	8	private static VcsChange . Type parseChangeType ( String s ) { char added = A ; char copied = C ; char modified = M ; char typeChanged = T ; char unmerged = U ; char unknown = X ; char deleted = D ; char renamed = R ; char c = s . charAt ( 0 ) ; if ( c == added || c == copied ) { return Added ; } else if ( c == modified || c == typeChanged || c == unmerged || c == unknown ) { return Modified ; } else if ( c == deleted ) { return Deleted ; } else if ( c == renamed ) { return Moved ; } else { throw new IllegalStateException ( "Unknown git change type: " + s ) ; } }
te	7	public static Object $get ( Object content , Object defaultValue ) { if ( content == null ) { throw new IllegalArgumentException ( "Content must not be null" ) ; } if ( content instanceof mVar ) { try { content = ( ( mVar ) content ) . get ( ) ; } catch ( Exception e ) { content = null ; } } if ( content == null && defaultValue != null ) { return defaultValue ; } else if ( content == null && defaultValue == null ) { return "" ; } else { return content ; } }
te	4	@ Override public void draw ( int x , int y ) { glColor4f ( 1f , 1f , 1f , 1f ) ; x = x - Standards . TILE_SIZE ; y = y - Standards . TILE_SIZE ; Boot . getTexHandler ( ) . bindTexture ( "player" ) ; float rotation = this . getOrientation ( ) * 90 ; float rotXOffset = 0 ; float rotYOffset = 0 ; switch ( this . getOrientation ( ) ) { case Standards . NORTH : break ; case Standards . SOUTH : rotXOffset = Standards . TILE_SIZE ; rotYOffset = Standards . TILE_SIZE ; break ; case Standards . EAST : rotXOffset = Standards . TILE_SIZE ; break ; case Standards . WEST : rotYOffset = Standards . TILE_SIZE ; break ; } glPushMatrix ( ) ; glTranslatef ( x + rotXOffset , y + rotYOffset , 0f ) ; glRotatef ( rotation , 0.0f , 0.0f , 1.0f ) ; glBegin ( GL_QUADS ) ; { glTexCoord2f ( 0 , 0 ) ; glVertex2i ( 0 , 0 ) ; glTexCoord2f ( 1 , 0 ) ; glVertex2i ( 0 + Standards . TILE_SIZE , 0 ) ; glTexCoord2f ( 1 , 1 ) ; glVertex2i ( 0 + Standards . TILE_SIZE , 0 + Standards . TILE_SIZE ) ; glTexCoord2f ( 0 , 1 ) ; glVertex2i ( 0 , 0 + Standards . TILE_SIZE ) ; } glEnd ( ) ; glPopMatrix ( ) ; }
te	1	public void addPlot ( Plot plot ) { if ( plots . contains ( plot ) ) return ; plots . add ( plot ) ; panel . add ( plot ) ; }
te	5	public String [ ] getFeatures ( ) { if ( indexToCountriesProduct == null ) readContriesProducts ( ) ; String headings = "english hourly_rate (or agency rate) " + "availability_hrs total_tests yrs_exp  no_qualifications " + "total_hours adjusted_score adjusted_score_recent total_last_90_days " + "english_score_diff  pref_feedback_score_diff  prc_interviewed " + "timezoneDiff  contr_location  " + "cover_unigram_score " + "order_of_application client_country same_client_contr_country  pref_has_portfolio number_prev_openings " + "job_unigram_score pref_test_diff  number_prev_applications  " + "contractor_hired_from_current_country  worked_together_before" ; String [ ] tmpAr = headings . split ( " " ) ; for ( int ind : Classify . featuresToRemove ) { System . out . println ( "we are removing feature " + tmpAr [ ind - 1 ] + " with index " + ind ) ; tmpAr [ ind - 1 ] = null ; } String [ ] res = new String [ tmpAr . length - Classify . featuresToRemove . size ( ) + indexToCountriesProduct . size ( ) + 1 ] ; int j = 0 ; for ( int i = 0 ; i < tmpAr . length ; i ++ ) { if ( tmpAr [ i ] != null ) { res [ j ] = tmpAr [ i ] ; j ++ ; } } int startingInd = tmpAr . length - Classify . featuresToRemove . size ( ) ; for ( int i = startingInd ; i < res . length ; i ++ ) { res [ i ] = indexToCountriesProduct . get ( i - startingInd ) ; } res [ res . length - 1 ] = "intercept" ; return res ; }
te	8	private void printFlags ( final Tree tree ) { if ( tree . isVirtual ( ) ) { print ( "virtual " ) ; } if ( tree . isPartial ( ) ) { print ( "partial " ) ; } if ( tree . isSealed ( ) ) { print ( "sealed " ) ; } if ( tree . isImmutable ( ) ) { print ( "immutable " ) ; } if ( tree . isPure ( ) ) { print ( "pure " ) ; } if ( tree . isIdempotent ( ) ) { print ( "idempotent " ) ; } if ( tree . isForced ( ) ) { print ( "force " ) ; } if ( tree . isNative ( ) ) { print ( "native " ) ; } }
te	1	public void processEvent ( AWTEvent e ) { if ( e . getID ( ) == Event . WINDOW_DESTROY ) { dispose ( ) ; } else { super . processEvent ( e ) ; } }
te	1	public T darAnterior ( ) { return hayAnterior ( ) ? elems [ -- posActual ] : null ; }
te	4	@ Override public void actionPerformed ( ActionEvent e ) { Object myObj = e . getSource ( ) ; if ( myObj . equals ( positionFrame . getButtonUpdate ( ) ) ) { doUpdate ( ) ; } else if ( myObj . equals ( positionFrame . getComboBoxTitle ( ) ) ) { doFillSalary ( ) ; } else if ( myObj . equals ( positionFrame . getButtonSave ( ) ) ) { doSave ( ) ; } else if ( myObj . equals ( positionFrame . getButtonExit ( ) ) ) { doExit ( ) ; } }
te	9	@ Override public byte [ ] pass ( DataInputStream in , DataOutputStream out , PassthroughConnection ptc , KillableThread thread , boolean serverToClient , byte [ ] buffer , DownlinkState linkState ) { length = lengthUnit . read ( in , ptc , thread , serverToClient , linkState ) ; if ( length == null ) { return null ; } length = lengthUnit . write ( out , ptc , thread , serverToClient ) ; if ( length == null ) { return null ; } length = length * 3 ; if ( length > 16384 ) { ptc . printLogMessage ( "Explosion to large " + length + "   breaking connection" ) ; return null ; } if ( buffer == null ) { setupBuffer ( buffer ) ; } else if ( value == null ) { value = buffer ; } buffer = value ; int pos = 0 ; int bufLength = buffer . length ; incrementCounter ( serverToClient , length , ptc ) ; while ( pos < length ) { int read ; bufLength = Math . min ( bufLength , length - pos ) ; try { read = in . read ( value , 0 , bufLength ) ; } catch ( SocketTimeoutException ste ) { if ( ! thread . killed ( ) ) { timeout ++ ; if ( timeout > 225 ) { ptc . printLogMessage ( "Connection timed out" ) ; return null ; } continue ; } return null ; } catch ( IOException e ) { ptc . printLogMessage ( "Unable to read from socket" ) ; return null ; } try { out . write ( value , 0 , read ) ; } catch ( SocketTimeoutException ste ) { if ( ! thread . killed ( ) ) { timeout ++ ; if ( timeout > 225 ) { ptc . printLogMessage ( "Connection timed out" ) ; return null ; } continue ; } return null ; } catch ( IOException e ) { ptc . printLogMessage ( "Unable to read from socket" ) ; return null ; } pos += read ; } return buffer ; }
te	8	public static void main ( String args [ ] ) throws XmlPullParserException , IOException { XmlPullParserFactory factory = XmlPullParserFactory . newInstance ( System . getProperty ( XmlPullParserFactory . PROPERTY_NAME ) , null ) ; XmlSerializer serializer = factory . newSerializer ( ) ; System . out . println ( "serializer implementation class is " + serializer . getClass ( ) ) ; boolean addNewLine = false ; int argPos = 0 ; while ( argPos < args . length ) { String arg = args [ argPos ] ; if ( "-n" . equals ( arg ) ) { addNewLine = true ; } else if ( "-i" . equals ( arg ) ) { String s = args [ ++ argPos ] ; int indentSize = Integer . parseInt ( s ) ; StringBuffer buf = new StringBuffer ( indentSize ) ; for ( int i = 0 ; i < indentSize ; i ++ ) { buf . append (   ) ; } String indent = buf . toString ( ) ; serializer . setProperty ( "http://xmlpull.org/v1/doc/properties.html#serializer-indentation" , indent ) ; } ++ argPos ; } serializer . setOutput ( new PrintWriter ( System . out ) ) ; serializer . startDocument ( null , null ) ; serializer . ignorableWhitespace ( "\n\n" ) ; serializer . setPrefix ( "" , NAMESPACE ) ; serializer . startTag ( NAMESPACE , "poem" ) ; if ( addNewLine ) serializer . text ( "\n" ) ; serializer . startTag ( NAMESPACE , "title" ) ; serializer . text ( "Roses are Red" ) ; serializer . endTag ( NAMESPACE , "title" ) ; if ( addNewLine ) serializer . text ( "\n" ) ; serializer . startTag ( NAMESPACE , "l" ) . text ( "Roses are red " ) . endTag ( NAMESPACE , "l" ) ; if ( addNewLine ) serializer . text ( "\n" ) ; serializer . startTag ( NAMESPACE , "l" ) . text ( "Violets are blue;" ) . endTag ( NAMESPACE , "l" ) ; if ( addNewLine ) serializer . text ( "\n" ) ; writeLine ( serializer , "Sugar is sweet " , addNewLine ) ; writeLine ( serializer , "And I love you. " , addNewLine ) ; serializer . endTag ( NAMESPACE , "poem" ) ; serializer . endDocument ( ) ; }
te	7	public boolean keyDown ( Event event , int key ) { if ( wave == null ) return false ; if ( key >= a && key <= z ) key += A - a ; if ( key < 0 || key > Z ) return false ; int f = keyFrequencies [ key - 0 ] ; if ( f == 0 ) return false ; byte [ ] s = wave . getUlaw ( ) ; byte [ ] d = new byte [ s . length * 8000 / f ] ; double inc = f / 8000.0 ; double pos = 0 ; for ( int i = 0 ; i < d . length ; i ++ ) { d [ i ] = s [ ( int ) pos ] ; pos += inc ; } AudioPlayer . player . start ( new AudioDataStream ( new AudioData ( d ) ) ) ; return true ; }
te	6	public static int [ ] [ ] generateTable ( ) { int [ ] [ ] result = new int [ 256 ] [ 256 ] ; for ( int i = 0 ; i < 256 ; i ++ ) { for ( int j = 0 ; j < 256 ; j ++ ) { int x = i , y = j , d , diff = 0 ; d = Math . abs ( x % 4 - y % 4 ) ; diff += ( d == 3 ? 6 : d ) ; x /= 4 ; y /= 4 ; d = Math . abs ( x % 4 - y % 4 ) ; diff += ( d == 3 ? 6 : d ) ; x /= 4 ; y /= 4 ; d = Math . abs ( x % 4 - y % 4 ) ; diff += ( d == 3 ? 6 : d ) ; x /= 4 ; y /= 4 ; d = Math . abs ( x % 4 - y % 4 ) ; diff += ( d == 3 ? 6 : d ) ; result [ i ] [ j ] = diff ; } } return result ; }
te	6	@ Override public void run ( ) { for ( FileListener listener : task . getFile ( ) . getListeners ( ) ) { listener . error ( e ) ; } }
te	0	public void OnMenuBar ( boolean menuBar ) { received ( "OnMenuBlur" , menuBar ) ; }
te	7	private void jBListarIncidentesActionPerformed ( java . awt . event . ActionEvent evt ) { int comuna = combo_comuna_reportedoble . getSelectedIndex ( ) ; int tipo = combo_tipo_reportedoble . getSelectedIndex ( ) ; if ( comuna != 0 && tipo != 0 ) { Comuna codigocomuna = controlador . buscarComuna ( combo_comuna_reportedoble . getSelectedItem ( ) . toString ( ) ) ; TipoInscidente codigotipo = controlador . buscarTipoIncidente ( combo_tipo_reportedoble . getSelectedItem ( ) . toString ( ) ) ; getControlador ( ) . cargarIncidentesPorComunaYTipo ( codigocomuna . getCom_codigo ( ) , codigotipo . getTipinc_codigo ( ) ) ; DefaultTableModel lstIncidente = ( DefaultTableModel ) tableListaIncidente . getModel ( ) ; if ( ! getControlador ( ) . getListaIncicomunaytipo ( ) . isEmpty ( ) ) { JOptionPane . showMessageDialog ( null , "Se tienen " + getControlador ( ) . getListaIncicomunaytipo ( ) . size ( ) + " Incidentes Registrados en la comuna " + codigocomuna . getCom_nombre ( ) + " Y con el tipo de incidente " + codigotipo . getTipinc_descripcion ( ) ) ; tableListaIncidente . removeAll ( ) ; int rowCount = lstIncidente . getRowCount ( ) ; for ( int i = 0 ; i < rowCount ; i ++ ) { lstIncidente . removeRow ( i ) ; } for ( int i = 0 ; i < getControlador ( ) . getListaIncicomunaytipo ( ) . size ( ) ; i ++ ) { lstIncidente . addRow ( new Object [ ] { getControlador ( ) . getListaIncicomunaytipo ( ) . get ( i ) . getComuna ( ) . getCom_nombre ( ) , getControlador ( ) . getListaIncicomunaytipo ( ) . get ( i ) . getBarrio ( ) . getBar_nombre ( ) , getControlador ( ) . getListaIncicomunaytipo ( ) . get ( i ) . getTipo_incidente ( ) . getTipinc_descripcion ( ) , getControlador ( ) . getListaIncicomunaytipo ( ) . get ( i ) . getInc_codigoIncidente ( ) , getControlador ( ) . getListaIncicomunaytipo ( ) . get ( i ) . getInc_descripcionIncidente ( ) , getControlador ( ) . getListaIncicomunaytipo ( ) . get ( i ) . getInc_fechaIncidente ( ) , getControlador ( ) . getListaIncicomunaytipo ( ) . get ( i ) . getUsuario ( ) . getTelefono ( ) , } ) ; } } else { JOptionPane . showMessageDialog ( null , "No tiene Se Tienen Incidentes en la comuna " + codigocomuna . getCom_nombre ( ) + " Y con el tipo de incidente " + codigotipo . getTipinc_descripcion ( ) ) ; int rowCount = lstIncidente . getRowCount ( ) ; for ( int i = 0 ; i < rowCount ; i ++ ) { lstIncidente . removeRow ( i ) ; } if ( lstIncidente . getRowCount ( ) > 0 ) { lstIncidente . removeRow ( tableListaIncidente . getSelectedRow ( ) ) ; } } } else { JOptionPane . showMessageDialog ( null , "Debe Seleccionar Una Comuna y un Tipo de Incidente" ) ; } }
te	0	public static Point2D parsePoint ( String point2D ) { String [ ] coords = point2D . split ( " " ) ; return new Point2D ( double . parseDouble ( coords [ 0 ] ) , double . parseDouble ( coords [ 1 ] ) ) ; }
te	8	public void update ( GameContainer gc , int delta ) { Input input = gc . getInput ( ) ; if ( input . isKeyDown ( Input . KEY_W ) ) { position . add ( new Vector2f ( 0 , - MOTION_SPEED * delta ) ) ; body . setPosition ( position . getX ( ) , position . getY ( ) ) ; if ( sprites . get ( "reverse" ) != null ) curImage = sprites . get ( "reverse" ) ; } if ( input . isKeyDown ( Input . KEY_A ) ) { position . add ( new Vector2f ( - MOTION_SPEED * delta , 0 ) ) ; body . setPosition ( position . getX ( ) , position . getY ( ) ) ; if ( sprites . get ( "side" ) != null ) curImage = sprites . get ( "side" ) ; } if ( input . isKeyDown ( Input . KEY_S ) ) { position . add ( new Vector2f ( 0 , MOTION_SPEED * delta ) ) ; body . setPosition ( position . getX ( ) , position . getY ( ) ) ; if ( sprites . get ( "forward" ) != null ) curImage = sprites . get ( "forward" ) ; } if ( input . isKeyDown ( Input . KEY_D ) ) { position . add ( new Vector2f ( MOTION_SPEED * delta , 0 ) ) ; body . setPosition ( position . getX ( ) , position . getY ( ) ) ; if ( sprites . get ( "side" ) != null ) curImage = sprites . get ( "side" ) ; } }
te	4	private Object invoke ( String signature , Object [ ] args ) throws Throwable { Method method = methods . get ( signature ) ; if ( method == null ) { throw new UnmarshalException ( "The remote object does contain the method: " + signature ) ; } ClassLoader original = Thread . currentThread ( ) . getContextClassLoader ( ) ; Thread . currentThread ( ) . setContextClassLoader ( getTargetClassLoader ( ) ) ; try { return method . invoke ( target , args ) ; } catch ( InvocationTargetException e ) { throw e . getTargetException ( ) ; } catch ( IllegalAccessException e ) { throw new UnmarshalException ( "Could not invoke method: " + signature , e ) ; } catch ( Exception e ) { throw new UnexpectedException ( e . toString ( ) , e ) ; } finally { Thread . currentThread ( ) . setContextClassLoader ( original ) ; } }
te	2	public boolean isBlocksInArea ( TBox box ) { boolean ret = false ; for ( TBlock blk : blks ) { TBox virtualBox4Blk = blk . getBlkVirtualBox ( ) ; ret = this . isInBox ( virtualBox4Blk ) ; if ( ret ) { break ; } } return ret ; }
te	3	private void signatureCompare ( Method oldMethod , Method newMethod ) { if ( oldMethod . getParamList ( ) . getSize ( ) != newMethod . getParamList ( ) . getSize ( ) ) { error . show ( "Cannot redefine method. Param count doesn't match with superclass" ) ; } for ( int i = 0 ; i < oldMethod . getParamList ( ) . getSize ( ) ; i ++ ) { if ( ! oldMethod . getParamList ( ) . get ( i ) . getType ( ) . getName ( ) . equals ( newMethod . getParamList ( ) . get ( i ) . getType ( ) . getName ( ) ) ) { error . show ( "Cannot redefine method. Parameters don't match" ) ; } } }
te	2	public int [ ] createTileArrays1 ( int numTiles , boolean fixed ) { arrTiles = new int [ numTiles ] ; arrTilesCount = new int [ numTiles ] ; int c = 0 ; try { for ( int n = 0 ; n < ( numTiles ) ; n ++ ) { arrTiles [ n ] = n + 1 ; } } catch ( Exception x ) { System . out . println ( "Error: " + x + "\n" ) ; } return ( arrTiles ) ; }
te	4	@ Override public Menu select ( Menu menu , int index ) { for ( Menu m : menu . _children ) { if ( m . _index == index ) return m ; } for ( Selection s : menu . _selectionList ) { if ( s . _index == index ) { Piece piece = menu . _pieces . get ( 0 ) ; return new Menu ( menu , menu . _player , index , s . _text , piece , menu . _player . get_board ( ) ) ; } } System . out . println ( "[Menu] The menu option you have selected is not valid!" ) ; return menu ; }
te	1	public static String [ ] consultarLaboresStrings ( String carnet ) { Object [ ] labores = ( B_A_horas . consultarLabores ( carnet ) . toArray ( ) ) ; String [ ] cadenas = new String [ labores . length ] ; for ( int iterador = 0 ; iterador < labores . length ; iterador ++ ) cadenas [ iterador ] = ( ( String ) labores [ iterador ] . toString ( ) ) ; return cadenas ; }
te	9	public String nextToken ( ) throws JSONException { char c ; char q ; StringBuffer sb = new StringBuffer ( ) ; do { c = next ( ) ; } while ( Character . isWhitespace ( c ) ) ; if ( c == " || c == ' ) { q = c ; for ( ; ; ) { c = next ( ) ; if ( c <   ) { throw syntaxError ( "Unterminated string." ) ; } if ( c == q ) { return sb . toString ( ) ; } sb . append ( c ) ; } } for ( ; ; ) { if ( c == 0 || Character . isWhitespace ( c ) ) { return sb . toString ( ) ; } sb . append ( c ) ; c = next ( ) ; } }
te	7	private String readElement ( List < String > operators , List < String > operands , String s , int i ) { String s2 = s . substring ( i ) . trim ( ) , ret = "" ; for ( String tmp : operands ) { if ( s2 . startsWith ( tmp ) && tmp . length ( ) > ret . length ( ) ) { ret = tmp ; } } if ( ret . equals ( "" ) ) { for ( String tmp : operators ) { if ( s2 . startsWith ( tmp ) ) { ret = tmp ; break ; } } } if ( ret . equals ( "" ) ) { return null ; } return ret ; }
te	9	private static void ajouter_cases_adjacentes ( Tuple n , Tuple boiteTravailHG , Tuple boiteTravailBD , Tuple arrivee , PriorityQueue < NoeudPCC > listeOuverte , ArrayList < NoeudPCC > listeFermee , Map map ) { NoeudPCC tmp = new NoeudPCC ( ) ; for ( int i = n . x - 1 ; i <= n . x + 1 ; i ++ ) { if ( ( i < boiteTravailHG . x ) || ( i > boiteTravailBD . x ) ) continue ; for ( int j = n . y - 1 ; j <= n . y + 1 ; j ++ ) { if ( ( j < boiteTravailHG . y ) || ( j > boiteTravailBD . y ) ) continue ; if ( j - n . y != 0 && i - n . x != 0 ) continue ; if ( j - n . y == 0 && i - n . x == 0 ) continue ; if ( ! InfoCase . isPassable ( map . getCase ( j , i ) . numTile ) ) continue ; tmp . coord = new Tuple ( i , j ) ; Tuple it = new Tuple ( i , j ) ; NoeudPCC noeud = deja_dans_liste ( it , listeFermee ) ; if ( noeud == null ) { noeud = deja_dans_liste ( n , listeFermee ) ; tmp . cout_g = noeud . cout_g + 1 ; tmp . cout_h = arrivee . distance ( new Tuple ( i , j ) ) ; tmp . cout_f = tmp . cout_g + tmp . cout_h ; tmp . parent = n ; noeud = deja_dans_liste ( it , listeOuverte ) ; if ( noeud != null ) { if ( tmp . cout_f < noeud . cout_f ) { listeOuverte . remove ( noeud ) ; noeud = tmp ; listeOuverte . add ( noeud ) ; } } else { listeOuverte . add ( tmp . clone ( ) ) ; } } } } }
te	8	private void createPatternsImpl ( final AngleUnitFlapPattern seed , final int indexToAdd , final Collection < Piece > pieces ) { trace ( seed ) ; if ( indexToAdd == tailIndex ) { if ( acceptablePatternCondition . holds ( seed ) ) { trace ( "accepted" ) ; patterns . add ( seed . cloneInstance ( ) ) ; } return ; } if ( indexToAdd > tailIndex ) { trace ( "recursion stopped: overlength" ) ; return ; } if ( pieces . isEmpty ( ) ) { trace ( "recurtion stopped: empty candidates" ) ; return ; } if ( LOGGER . isDebugEnabled ( ) ) { LOGGER . debug ( "seed: " + seed ) ; LOGGER . debug ( "indexToAdd: " + indexToAdd ) ; LOGGER . debug ( "pieces: " + pieces ) ; } for ( Piece piece : pieces ) { trace ( piece ) ; if ( ! isAppendable ( seed , indexToAdd , piece ) ) { continue ; } int nextIndex = appendTo ( seed , indexToAdd , piece ) ; if ( ! pruningCondition . holds ( seed ) ) { createPatternsImpl ( seed , nextIndex , pieceMap . get ( piece . getLast ( ) ) ) ; } undo ( seed , indexToAdd , piece ) ; } }
te	2	public boolean ForceCacheFlush ( ConsoleCommandSender sender , String [ ] args ) { int flushCount = 5 ; if ( args . length >= 2 ) { flushCount = Integer . parseInt ( args [ 1 ] ) ; } CitadelDao std_dao = Citadel . getDao ( ) ; if ( ! ( std_dao instanceof CitadelCachingDao ) ) { sendMessage ( sender , ChatColor . RED , "Sorry  the Caching DAO is not being used." ) ; return true ; } CitadelCachingDao dao = ( CitadelCachingDao ) std_dao ; dao . ForceCacheFlush ( flushCount ) ; sendMessage ( sender , ChatColor . YELLOW , "Flush complete." ) ; return true ; }
te	8	public void highlightBloc ( Point bloc ) { Point baseCell = new Point ( ) ; baseCell . x = ( m_t - 1 ) * bloc . x + 1 ; baseCell . y = ( m_t - 1 ) * bloc . y + 1 ; int c , r ; this . clearHighlightColors ( ) ; FRCellElement tmpCell ; for ( c = 1 ; c < m_t ; ++ c ) { for ( r = 1 ; r < m_t ; ++ r ) { tmpCell = ( FRCellElement ) this . getCell ( baseCell . x + c , baseCell . y + r ) ; tmpCell . setHLColor ( Color . yellow ) ; } } for ( c = 1 ; c < m_t ; ++ c ) { tmpCell = ( FRCellElement ) this . getCell ( baseCell . x + c , 0 ) ; tmpCell . setHLColor ( PARAMS_COLOR ) ; } for ( r = 1 ; r < m_t ; ++ r ) { tmpCell = ( FRCellElement ) this . getCell ( 0 , baseCell . y + r ) ; tmpCell . setHLColor ( PARAMS_COLOR ) ; } for ( c = 1 ; c < m_t ; ++ c ) { tmpCell = ( FRCellElement ) this . getCell ( baseCell . x + c , baseCell . y ) ; if ( ! tmpCell . hasAlternativeVal ( ) ) { tmpCell . setHLColor ( PARAMS_COLOR ) ; } else { tmpCell . setDividedHLColors ( Color . white , PARAMS_COLOR ) ; } } for ( r = 1 ; r < m_t ; ++ r ) { tmpCell = ( FRCellElement ) this . getCell ( baseCell . x , baseCell . y + r ) ; if ( ! tmpCell . hasAlternativeVal ( ) ) { tmpCell . setHLColor ( PARAMS_COLOR ) ; } else { tmpCell . setDividedHLColors ( PARAMS_COLOR , Color . white ) ; } } }
te	4	public Method [ ] factoryMethods ( ) { Set < Method > methods = new HashSet < Method > ( ) ; for ( Method m : clazz . getMethods ( ) ) { if ( Modifier . isPrivate ( m . getModifiers ( ) ) ) { continue ; } if ( ! Modifier . isStatic ( m . getModifiers ( ) ) ) { continue ; } if ( m . getReturnType ( ) != clazz ) { continue ; } methods . add ( m ) ; } return methods . toArray ( new Method [ methods . size ( ) ] ) ; }
te	5	public static int countABC ( String str ) { int zmCount = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { char c = str . charAt ( i ) ; if ( ( c >= a && c <= z ) || ( c >= A && c <= Z ) ) zmCount ++ ; } return zmCount ; }
te	0	public void each ( P1 < M > p1 , Connection conn ) { each ( p1 , conn , null ) ; }
te	5	public static int numberOfCrossingsInRank ( Rank rank ) { int crossings = 0 ; for ( int i = 0 ; i < rank . size ( ) - 1 ; i ++ ) { Node currentNode = rank . getNode ( i ) ; Node nextNode ; for ( int j = i + 1 ; j < rank . size ( ) ; j ++ ) { nextNode = rank . getNode ( j ) ; EdgeList currentOutgoing = currentNode . outgoing ; EdgeList nextOutgoing = nextNode . outgoing ; for ( int k = 0 ; k < currentOutgoing . size ( ) ; k ++ ) { Edge currentEdge = currentOutgoing . getEdge ( k ) ; for ( int l = 0 ; l < nextOutgoing . size ( ) ; l ++ ) { if ( nextOutgoing . getEdge ( l ) . getIndexForRank ( currentNode . rank + 1 ) < currentEdge . getIndexForRank ( currentNode . rank + 1 ) ) crossings ++ ; } } } } return crossings ; }
te	5	private boolean findDSMInstance ( ) { int index ; if ( dsm == null ) { index = - 1 ; int i = 0 ; ListIterator < Line > it = gct . getCodeLines ( ) . listIterator ( ) ; Line [ ] finalCode = new Line [ 9 ] ; int pointInCode = 0 ; while ( it . hasNext ( ) ) { Line l = it . next ( ) ; if ( ! l . startsWith ( DSM . SEARCH [ pointInCode ] ) ) { pointInCode = 0 ; } else { finalCode [ pointInCode ] = l ; pointInCode ++ ; if ( pointInCode == DSM . SEARCH . length ) { if ( index == - 1 ) { index = new Integer ( i - DSM . SEARCH . length + 1 ) ; dsm = new DSM ( finalCode ) ; gct . recordDynamicCode ( dsm ) ; } else { System . err . println ( "Error: the Default Settings Modifier code was found more than once in the GCT. The second instance will be ignored." ) ; } pointInCode = 0 ; } } i ++ ; } } return ( dsm != null ) ; }
te	0	@ Test public void testParseWithIllegalCloser ( ) throws ParserConfigurationException , SAXException , IOException , XPathExpressionException { Document doc = DomParser . parse ( new InputSource ( new StringReader ( "<html><head><title>hallo</hans></head><body>du</body>" ) ) ) ; assertNotNull ( doc ) ; XPath xpath = XPathFactory . newInstance ( ) . newXPath ( ) ; assertNotNull ( xpath . evaluate ( "/html" , doc , XPathConstants . NODE ) ) ; assertEquals ( 2. , xpath . evaluate ( "count(/html/*)" , doc , XPathConstants . NUMBER ) ) ; assertNotNull ( xpath . evaluate ( "/html/head" , doc , XPathConstants . NODE ) ) ; assertEquals ( "hallo" , xpath . evaluate ( "/html/head/title/text()" , doc , XPathConstants . STRING ) ) ; assertNotNull ( xpath . evaluate ( "/html/body" , doc , XPathConstants . NODE ) ) ; assertNotNull ( xpath . evaluate ( "/html/body/text()" , doc , XPathConstants . NODE ) ) ; assertEquals ( "du" , xpath . evaluate ( "/html/body/text()" , doc , XPathConstants . STRING ) ) ; }
te	0	@ Override public String toString ( ) { return toString ( 0 ) ; }
te	3	private void setLayer ( int layer ) throws InvalidDataException { switch ( layer ) { case 1 : this . layer = 3 ; break ; case 2 : this . layer = 2 ; break ; case 3 : this . layer = 1 ; break ; default : throw new InvalidDataException ( "Invalid mpeg layer description in frame header" ) ; } }
te	7	public void update ( Observable arg0 , Object arg1 ) { if ( arg1 instanceof String ) { } if ( arg1 instanceof EditorUpdateObject ) { EditorUpdateObject update = ( EditorUpdateObject ) arg1 ; x = update . getSelectedX ( ) ; y = update . getSelectedY ( ) ; roomsArray = update . getRoomsArray ( ) ; rooms = update . getRooms ( ) ; player = update . getPlayer ( ) ; } if ( x >= 0 && x < maxX && y >= 0 && y < maxY ) { if ( roomsArray [ x ] [ y ] != null ) { currentRoom = ( FirstPersonRoom ) rooms . get ( roomsArray [ x ] [ y ] ) ; } else { currentRoom = null ; } } map . update ( this , arg1 ) ; refreshView ( ) ; }
te	5	public void ConsultarPacientes ( String Dato , int Limpiar ) { Paciente paciente ; ArrayList < Paciente > pacientes = null ; int i , tam ; String query = null , query2 = null ; tam = Dato . length ( ) ; if ( tam == 0 ) { pt . TablaPacientes1 ( jtPacientes ) ; } else { pt . TablaPacientes1 ( jtPacientes ) ; paciente = new Paciente ( ) ; switch ( Limpiar ) { case 0 : query = "SELECT p.dni  p.\"ApPaterno\"  p.\"ApMaterno\"  p.\"Nombres\" hc.\"codHistoria\"  hc.\"codCarpeta\" hc.\"histAntigua\"\n" + "  FROM \"Paciente\" as p inner join \"HistoriaClinica\" hc on hc.id=p.id where p.dni like '" + Dato + "%';" ; break ; case 1 : limpiarSiNumCarpeta ( ) ; query = "SELECT p.dni  p.\"ApPaterno\"  p.\"ApMaterno\"  p.\"Nombres\" hc.\"codHistoria\"  hc.\"codCarpeta\" hc.\"histAntigua\"\n" + "  FROM \"Paciente\" as p inner join \"HistoriaClinica\" hc on hc.id=p.id where hc.\"codCarpeta\"='" + Dato + "';" ; break ; case 2 : limpiarSiHistClinica ( ) ; query = "SELECT p.dni  p.\"ApPaterno\"  p.\"ApMaterno\"  p.\"Nombres\" hc.\"codHistoria\"  hc.\"codCarpeta\" hc.\"histAntigua\"\n" + "  FROM \"Paciente\" as p inner join \"HistoriaClinica\" hc on hc.id=p.id where hc.\"codHistoria\" like '" + Dato + "%';" ; break ; case 3 : limpiarSiHistAnt ( ) ; query = "SELECT p.dni  p.\"ApPaterno\"  p.\"ApMaterno\"  p.\"Nombres\" hc.\"codHistoria\"  hc.\"codCarpeta\" hc.\"histAntigua\"\n" + "  FROM \"Paciente\" as p inner join \"HistoriaClinica\" hc on hc.id=p.id where hc.\"histAntigua\" like '" + Dato + "%';" ; break ; } } }
te	8	@ Override public int compareTo ( NewId other ) { if ( _a != other . _a ) return ( _a < other . _a ) ? - 1 : 1 ; if ( _b != other . _b ) return ( _b < other . _b ) ? - 1 : 1 ; if ( _c != other . _c ) return ( _c < other . _c ) ? - 1 : 1 ; if ( _d != other . _d ) return ( _d < other . _d ) ? - 1 : 1 ; return 0 ; }
te	1	public static boolean isDouble ( String s ) { try { double x = double . parseDouble ( s ) ; return true ; } catch ( NumberFormatException e ) { return false ; } }
te	2	private Map parseMapFamily ( JsonObject joFamily , HMapFamily annotation ) { if ( joFamily == null ) { return null ; } Map result = new HashMap ( ) ; for ( Map . Entry < String , JsonElement > pairs : joFamily . entrySet ( ) ) { Object key = convertFromString ( pairs . getKey ( ) , annotation . keyType ( ) ) ; Object value = convertFromElement ( pairs . getValue ( ) , annotation . valueType ( ) ) ; result . put ( key , value ) ; } return result ; }
te	7	protected void writeObject ( Object object ) throws IOException { if ( log . isDebugEnabled ( ) ) { if ( object == null ) { log . debug ( "Writing object  object param == null" ) ; } else { log . debug ( "Writing object  class = " + object . getClass ( ) ) ; } } outputStream . writeByte ( AMF0Body . DATA_TYPE_OBJECT ) ; try { PropertyDescriptor [ ] properties = PropertyUtils . getPropertyDescriptors ( object ) ; for ( int i = 0 ; i < properties . length ; i ++ ) { if ( ! properties [ i ] . getName ( ) . equals ( "class" ) ) { String propertyName = properties [ i ] . getName ( ) ; Method readMethod = properties [ i ] . getReadMethod ( ) ; Object propertyValue = null ; if ( readMethod == null ) { log . error ( "unable to find readMethod for : " + propertyName + " writing null!" ) ; } else { log . debug ( "invoking readMethod " + readMethod ) ; propertyValue = readMethod . invoke ( object , new Object [ 0 ] ) ; } log . debug ( propertyName + " = " + propertyValue ) ; outputStream . writeUTF ( propertyName ) ; writeData ( propertyValue ) ; } } outputStream . writeShort ( 0 ) ; outputStream . writeByte ( AMF0Body . DATA_TYPE_OBJECT_END ) ; } catch ( RuntimeException e ) { throw e ; } catch ( Exception e ) { log . error ( e , e ) ; throw new IOException ( e . getMessage ( ) ) ; } }
te	8	public void extract ( String text , int length , boolean stopWords , boolean overlap ) throws FileNotFoundException , IOException { this . text = text ; this . length = length ; this . stopWords = stopWords ; this . overlap = overlap ; nGrams = new LinkedList < String > ( ) ; uniqueNGrams = new LinkedList < String > ( ) ; nGramFreqs = new HashMap < String , Integer > ( ) ; if ( length == 1 ) { if ( this . stopWords ) { analyzer = new StandardAnalyzer ( Version . LUCENE_36 ) ; } else { analyzer = new SimpleAnalyzer ( Version . LUCENE_36 ) ; } } else { if ( this . stopWords ) { analyzer = new ShingleAnalyzerWrapper ( new StopAnalyzer ( Version . LUCENE_24 ) , length , length , " " , false , false ) ; } else { analyzer = new ShingleAnalyzerWrapper ( new SimpleAnalyzer ( Version . LUCENE_36 ) , length , length , " " , false , false ) ; } } TokenStream tokenStream = analyzer . tokenStream ( "text" , new StringReader ( this . text ) ) ; OffsetAttribute offsetAttribute = tokenStream . addAttribute ( OffsetAttribute . class ) ; CharTermAttribute charTermAttribute = tokenStream . addAttribute ( CharTermAttribute . class ) ; int tokenCount = 0 ; while ( tokenStream . incrementToken ( ) ) { int startOffset = offsetAttribute . startOffset ( ) ; int endOffset = offsetAttribute . endOffset ( ) ; String termToken = charTermAttribute . toString ( ) ; nGrams . add ( termToken ) ; if ( ! overlap ) { for ( int i = 0 ; i < length - 1 ; i ++ ) { tokenStream . incrementToken ( ) ; } } } for ( String nGram : nGrams ) { if ( nGramFreqs . containsKey ( nGram ) ) { nGramFreqs . put ( nGram , nGramFreqs . get ( nGram ) + 1 ) ; } else { nGramFreqs . put ( nGram , 1 ) ; uniqueNGrams . add ( nGram ) ; } } }
te	4	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException | InstantiationException | IllegalAccessException | javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( AddCredit_frame . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { @ Override public void run ( ) { try { new AddCredit_frame ( testProject ) . setVisible ( true ) ; } catch ( SQLException | ClassNotFoundException ex ) { Logger . getLogger ( AddCredit_frame . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } } } ) ; }
te	4	private static void swap ( int [ ] array , int offset1 , int offset2 ) { if ( offset1 < 0 || offset1 >= array . length || offset2 < 0 || offset2 >= array . length ) { System . err . println ( "out of range; " + array . length + "; " + offset1 + "; " + offset2 ) ; return ; } final int tmp = array [ offset1 ] ; array [ offset1 ] = array [ offset2 ] ; array [ offset2 ] = tmp ; }
te	8	protected void setType ( int type ) { this . type = type ; switch ( Math . abs ( type ) ) { case 1 : backgroundColor = new Color ( 255 , 87 , 107 ) ; color2 = new Color ( 255 , 176 , 185 ) ; borderColor = new Color ( 158 , 12 , 41 ) ; break ; case 2 : backgroundColor = new Color ( 89 , 249 , 255 ) ; color2 = new Color ( 168 , 252 , 255 ) ; borderColor = new Color ( 2 , 138 , 143 ) ; break ; case 3 : backgroundColor = new Color ( 58 , 115 , 250 ) ; color2 = new Color ( 130 , 168 , 255 ) ; borderColor = new Color ( 1 , 36 , 118 ) ; break ; case 4 : backgroundColor = new Color ( 252 , 255 , 69 ) ; color2 = new Color ( 253 , 255 , 135 ) ; borderColor = new Color ( 153 , 102 , 0 ) ; break ; case 5 : backgroundColor = new Color ( 130 , 255 , 20 ) ; color2 = new Color ( 182 , 252 , 121 ) ; borderColor = new Color ( 2 , 92 , 1 ) ; break ; case 6 : backgroundColor = new Color ( 255 , 97 , 242 ) ; color2 = new Color ( 255 , 168 , 248 ) ; borderColor = new Color ( 102 , 0 , 102 ) ; break ; case 7 : backgroundColor = new Color ( 255 , 162 , 0 ) ; color2 = new Color ( 255 , 199 , 102 ) ; borderColor = new Color ( 153 , 51 , 0 ) ; break ; default : backgroundColor = new Color ( 1 , 1 , 1 ) ; borderColor = new Color ( 25 , 25 , 25 ) ; } if ( type < 0 ) { color2 = backgroundColor . darker ( ) . darker ( ) ; backgroundColor = backgroundColor . darker ( ) . darker ( ) . darker ( ) ; borderColor = borderColor . darker ( ) . darker ( ) . darker ( ) ; } setBorder ( new LineBorder ( borderColor ) ) ; }
te	8	@ Override public boolean equals ( final Object obj ) { if ( obj == null ) { return false ; } if ( getClass ( ) != obj . getClass ( ) ) { return false ; } final Pair < ? , ? > other = ( Pair < ? , ? > ) ( obj ) ; if ( ! Objects . equals ( this . first , other . first ) ) { return false ; } if ( ! Objects . equals ( this . second , other . second ) ) { return false ; } return true ; }
te	5	public int nextClearBit ( int fromIndex ) { if ( fromIndex < 0 ) throw new IndexOutOfBoundsException ( "fromIndex < 0: " + fromIndex ) ; checkInvariants ( ) ; int u = wordIndex ( fromIndex ) ; if ( u >= wordsInUse ) return fromIndex ; long word = ~ words [ u ] & ( WORD_MASK << fromIndex ) ; while ( true ) { if ( word != 0 ) return ( u * BITS_PER_WORD ) + long . numberOfTrailingZeros ( word ) ; if ( ++ u == wordsInUse ) return wordsInUse * BITS_PER_WORD ; word = ~ words [ u ] ; } }
te	5	public static void droptables ( String ... tables ) { setForeignKeyChecks ( ) ; if ( tables != null && tables . length > 0 ) { if ( JediORMEngine . DEBUG ) { System . out . println ( "" ) ; } for ( String table : tables ) { if ( JediORMEngine . DEBUG ) { System . out . println ( String . format ( "DROP TABLE %s;" , table ) ) ; } SQLManager . raw ( String . format ( "DROP TABLE %s" , table ) ) ; } } }
te	2	protected void computeMinMax ( ) { max_y = min_y = max_x = min_x = 0.0 ; for ( int i = 0 ; i < y_values . length ; i ++ ) { for ( int j = 0 ; j < y_values [ i ] . length ; j ++ ) { max_y = Math . max ( max_y , y_values [ i ] [ j ] ) ; min_y = Math . min ( min_y , y_values [ i ] [ j ] ) ; max_x = Math . max ( max_x , x_values [ i ] [ j ] ) ; min_x = Math . min ( min_x , x_values [ i ] [ j ] ) ; } } }
te	2	public void fillRect ( int x , int y , int w , int h , int pix ) { int bytesPerPixel = getPF ( ) . bpp / 8 ; int bytesPerRow = bytesPerPixel * getStride ( ) ; for ( int ry = y ; ry < y + h ; ry ++ ) { for ( int rx = x ; rx < x + w ; rx ++ ) data [ ry * bytesPerRow + rx ] = ( byte ) pix ; } }
te	0	@ AfterClass public static void cleanupTempRoot ( ) { cleanupDirectory ( tempRoot ) ; tempRoot . delete ( ) ; }
te	1	public String [ ] getNumeClase ( ) { ArrayList < String > clase = profesor . getClase ( ) ; String [ ] num_clase = new String [ clase . size ( ) ] ; int i = 0 ; for ( String c : clase ) { num_clase [ i ++ ] = c ; } return num_clase ; }
te	5	public void run ( ) throws IOException { try { remoteProcessClient . writeToken ( token ) ; int teamSize = remoteProcessClient . readTeamSize ( ) ; remoteProcessClient . writeProtocolVersion ( ) ; Game game = remoteProcessClient . readGameContext ( ) ; Strategy [ ] strategies = new Strategy [ teamSize ] ; for ( int strategyIndex = 0 ; strategyIndex < teamSize ; ++ strategyIndex ) { strategies [ strategyIndex ] = new MyStrategy ( ) ; } PlayerContext playerContext ; while ( ( playerContext = remoteProcessClient . readPlayerContext ( ) ) != null ) { Hockeyist [ ] playerHockeyists = playerContext . getHockeyists ( ) ; if ( playerHockeyists == null || playerHockeyists . length != teamSize ) { break ; } Move [ ] moves = new Move [ teamSize ] ; for ( int hockeyistIndex = 0 ; hockeyistIndex < teamSize ; ++ hockeyistIndex ) { Hockeyist playerHockeyist = playerHockeyists [ hockeyistIndex ] ; Move move = new Move ( ) ; moves [ hockeyistIndex ] = move ; strategies [ playerHockeyist . getTeammateIndex ( ) ] . move ( playerHockeyist , playerContext . getWorld ( ) , game , move ) ; } remoteProcessClient . writeMoves ( moves ) ; } } finally { remoteProcessClient . close ( ) ; } }
te	2	public String getOperator ( ) { if ( operator == null ) { synchronized ( this ) { operator = properties . getProperty ( "operator" ) ; if ( operator == null ) throw new IllegalArgumentException ( "Please set a valid operator." ) ; } } return operator ; }
te	0	public Object getNextPanelDescriptor ( ) { return OAT_Analysis_Panel3_Descriptor . IDENTIFIER ; }
te	2	public void method358 ( ) { byte abyte0 [ ] = new byte [ anInt1452 * anInt1453 ] ; int j = 0 ; for ( int k = 0 ; k < anInt1453 ; k ++ ) { for ( int l = anInt1452 - 1 ; l >= 0 ; l -- ) abyte0 [ j ++ ] = aByteArray1450 [ l + k * anInt1452 ] ; } aByteArray1450 = abyte0 ; anInt1454 = anInt1456 - anInt1452 - anInt1454 ; }
te	4	public static void PrintError ( String Text ) { if ( verbose_level >= 1 ) { StackTraceElement [ ] ste = Thread . currentThread ( ) . getStackTrace ( ) ; System . out . println ( ">>>>> ERROR " + ste [ 2 ] + ": " + Text ) ; if ( verbose_level >= 3 ) { System . out . print ( "Stacktrace: " ) ; for ( int i = 2 ; i < ste . length ; i ++ ) { System . out . print ( ste [ i ] ) ; if ( ! ( i == ste . length - 1 ) ) System . out . print ( " -> " ) ; } System . out . println ( "" ) ; } } }
te	7	public int method544 ( int i , float f ) { if ( i == 0 ) { float f1 = ( float ) anIntArray668 [ 0 ] + ( float ) ( anIntArray668 [ 1 ] - anIntArray668 [ 0 ] ) * f ; f1 *= 0.003051758F ; aFloat671 = ( float ) Math . pow ( 0.10000000000000001D , f1 / 20F ) ; anInt672 = ( int ) ( aFloat671 * 65536F ) ; } if ( anIntArray665 [ i ] == 0 ) return 0 ; float f2 = method541 ( i , 0 , f ) ; aFloatArrayArray669 [ i ] [ 0 ] = - 2F * f2 * ( float ) Math . cos ( method543 ( f , 0 , i ) ) ; aFloatArrayArray669 [ i ] [ 1 ] = f2 * f2 ; for ( int k = 1 ; k < anIntArray665 [ i ] ; k ++ ) { float f3 = method541 ( i , k , f ) ; float f4 = - 2F * f3 * ( float ) Math . cos ( method543 ( f , k , i ) ) ; float f5 = f3 * f3 ; aFloatArrayArray669 [ i ] [ k * 2 + 1 ] = aFloatArrayArray669 [ i ] [ k * 2 - 1 ] * f5 ; aFloatArrayArray669 [ i ] [ k * 2 ] = aFloatArrayArray669 [ i ] [ k * 2 - 1 ] * f4 + aFloatArrayArray669 [ i ] [ k * 2 - 2 ] * f5 ; for ( int j1 = k * 2 - 1 ; j1 >= 2 ; j1 -- ) aFloatArrayArray669 [ i ] [ j1 ] += aFloatArrayArray669 [ i ] [ j1 - 1 ] * f4 + aFloatArrayArray669 [ i ] [ j1 - 2 ] * f5 ; aFloatArrayArray669 [ i ] [ 1 ] += aFloatArrayArray669 [ i ] [ 0 ] * f4 + f5 ; aFloatArrayArray669 [ i ] [ 0 ] += f4 ; } if ( i == 0 ) { for ( int l = 0 ; l < anIntArray665 [ 0 ] * 2 ; l ++ ) aFloatArrayArray669 [ 0 ] [ l ] *= aFloat671 ; } for ( int i1 = 0 ; i1 < anIntArray665 [ i ] * 2 ; i1 ++ ) anIntArrayArray670 [ i ] [ i1 ] = ( int ) ( aFloatArrayArray669 [ i ] [ i1 ] * 65536F ) ; return anIntArray665 [ i ] * 2 ; }
te	1	private short readClassId ( ) { switch ( classIntType ) { case byte : return byteBuffer . get ( ) ; default : return byteBuffer . getShort ( ) ; } }
te	5	public void checkOptions ( String [ ] options ) { if ( options [ 0 ] . equals ( "store" ) ) { if ( options . length > 2 ) { Error . err ( Error . COMMAND_NO_EXTENSIONS ) ; } else if ( options . length == 1 ) { Error . err ( Error . EXTENSION_NEEDS_PARAMETERS ) ; } else { variables . put ( currentVariable , options [ 1 ] ) ; System . out . println ( "Stored under " + currentVariable ) ; currentVariable ++ ; } } else if ( options [ 0 ] . equals ( "get" ) ) { System . out . println ( variables . get ( options [ 1 ] . toCharArray ( ) [ 0 ] ) ) ; } else if ( Command . commandCalls . contains ( options [ 0 ] ) ) { Command . commands . get ( Command . commandCalls . indexOf ( options [ 0 ] ) ) . execute ( ( Object [ ] ) options ) ; } else { Error . err ( Error . COMMAND_NO_INSTANCE ) ; } }
te	2	public static double min ( double [ ] flag ) { double min = flag [ 0 ] ; for ( int i = 1 ; i < flag . length ; i ++ ) { if ( flag [ i ] < min ) min = flag [ i ] ; } return min ; }
te	7	public static boolean isValidPermutation ( final byte [ ] state ) { final int numOfTiles = state . length , dim = ( int ) Math . sqrt ( numOfTiles ) ; int inversions = 0 ; for ( int i = 0 ; i < numOfTiles ; ++ i ) { final byte iTile = state [ i ] ; if ( iTile != 0 ) { for ( int j = i + 1 ; j < numOfTiles ; ++ j ) { final byte jTile = state [ j ] ; if ( jTile != 0 && jTile < iTile ) { ++ inversions ; } } } else { if ( ( dim & 1 ) == 0 ) { inversions += ( 1 + i / dim ) ; } } } if ( ( inversions & 1 ) == 1 ) return false ; return true ; }
te	7	private ArrayList < BeanFieldReport > loadReports ( int idSubRule ) { ArrayList < BeanFieldReport > list = new ArrayList < BeanFieldReport > ( ) ; String SQL1 = "SELECT * FROM tuta_actuacions_reports WHERE idSubRule=" + idSubRule + " ORDER by important desc" ; try { Statement st = client . getMysql ( ) . createStatement ( ) ; ResultSet rs1 = client . getMysql ( ) . getResultSet ( SQL1 , st ) ; while ( rs1 != null && rs1 . next ( ) ) { BeanFieldReport bfr = new BeanFieldReport ( ) ; bfr . idReport = rs1 . getString ( "id" ) ; bfr . important = rs1 . getString ( "important" ) . equalsIgnoreCase ( "S" ) ; bfr . reportPath = rs1 . getString ( "reportPath" ) ; bfr . popupInstructions = rs1 . getString ( "popupInstructions" ) ; bfr . reportDescription = rs1 . getString ( "reportDescription" ) ; if ( bfr . reportDescription == null ) { bfr . reportDescription = bfr . reportPath ; } bfr . visibilitat = rs1 . getString ( "visibilitat" ) ; bfr . setIncludeSubReport ( rs1 . getString ( "includeSubReport" ) ) ; bfr . limitInc = rs1 . getInt ( "limitInc" ) ; bfr . lang = rs1 . getString ( "lang" ) ; if ( bfr . reportPath != null && ! bfr . reportPath . isEmpty ( ) ) { list . add ( bfr ) ; } } if ( rs1 != null ) { rs1 . close ( ) ; st . close ( ) ; } } catch ( SQLException ex ) { Logger . getLogger ( FactoryRules . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } return list ; }
te	9	private void writeToken ( int eventType ) throws XmlPullParserException , IOException { switch ( eventType ) { case XmlPullParser . START_DOCUMENT : boolean standalone = ( boolean ) parser . getProperty ( PROPERTY_XMLDECL_STANDALONE ) ; serializer . startDocument ( parser . getInputEncoding ( ) , standalone ) ; break ; case XmlPullParser . END_DOCUMENT : serializer . endDocument ( ) ; break ; case XmlPullParser . START_TAG : writeStartTag ( ) ; break ; case XmlPullParser . END_TAG : serializer . endTag ( parser . getNamespace ( ) , parser . getName ( ) ) ; break ; case XmlPullParser . IGNORABLE_WHITESPACE : String s = parser . getText ( ) ; serializer . ignorableWhitespace ( s ) ; break ; case XmlPullParser . TEXT : serializer . text ( parser . getText ( ) ) ; break ; case XmlPullParser . ENTITY_REF : serializer . entityRef ( parser . getName ( ) ) ; break ; case XmlPullParser . CDSECT : serializer . cdsect ( parser . getText ( ) ) ; break ; case XmlPullParser . PROCESSING_INSTRUCTION : serializer . processingInstruction ( parser . getText ( ) ) ; break ; case XmlPullParser . COMMENT : serializer . comment ( parser . getText ( ) ) ; break ; case XmlPullParser . DOCDECL : serializer . docdecl ( parser . getText ( ) ) ; break ; } }
te	1	public byte getLanguageIndicator ( ) { if ( languageIndicator . getText ( ) . length ( ) == 0 ) { return null ; } return byte . valueOf ( languageIndicator . getText ( ) ) ; }
te	6	public static String escape ( String string ) { char c ; String s = string . trim ( ) ; StringBuffer sb = new StringBuffer ( ) ; int length = s . length ( ) ; for ( int i = 0 ; i < length ; i += 1 ) { c = s . charAt ( i ) ; if ( c <   || c == + || c == % || c == = || c == ; ) { sb . append ( % ) ; sb . append ( Character . forDigit ( ( char ) ( ( c >>> 4 ) & 0f ) , 16 ) ) ; sb . append ( Character . forDigit ( ( char ) ( c & 0f ) , 16 ) ) ; } else { sb . append ( c ) ; } } return sb . toString ( ) ; }
te	8	public Vector < Action > succesor ( State state ) { Vector < Action > actions = new Vector < Action > ( ) ; NaiveSudokuBoardState sudoku_state = ( NaiveSudokuBoardState ) state ; int n = sudoku_state . n ; int i = 0 ; int j = 0 ; boolean filled = true ; while ( i < n && filled ) { j = 0 ; while ( j < n && filled ) { filled = ( sudoku_state . board . get ( i , j ) != 0 ) ; if ( filled ) { j ++ ; } } if ( filled ) { i ++ ; } } if ( ! filled ) { for ( int k = 0 ; k < n ; k ++ ) { actions . add ( new Action ( "<" + i + " " + j + " " + ( k + 1 ) + ">" ) ) ; } } return actions ; }
te	9	@ Override public boolean equals ( Object obj ) { if ( ! ( obj instanceof SimilarityMatrix ) ) return false ; SimilarityMatrix other = ( SimilarityMatrix ) obj ; return ( ( this . ids == null && other . ids == null ) || this . ids . equals ( other . ids ) ) && ( ( this . similarities == null && other . similarities == null || this . similarities . equals ( other . similarities ) ) ) && ( ( this . sparseSimilarities == null && other . sparseSimilarities == null || this . sparseSimilarities . equals ( other . sparseSimilarities ) ) ) ; }
te	2	private boolean horizontalRowWin ( ) { boolean won = false ; for ( int row = 0 ; row < 3 ; row ++ ) { if ( checkHorizontalRow ( row ) ) { won = true ; break ; } } return won ; }
te	0	private static void addParametrizedService ( String id , ParametrizedOperation op ) { parametrizedServices . put ( id , op ) ; }
te	1	@ Override protected void processWindowEvent ( WindowEvent e ) { if ( e . getID ( ) == WindowEvent . WINDOW_CLOSING ) { buttonLock . setEnabled ( true ) ; buttonLock . doClick ( ) ; } }
te	0	public static void main ( String [ ] args ) { Log . set ( Log . LEVEL_DEBUG ) ; HttpRequestInfo req = HttpRequestInfoFixtures . getPostMultiPartRequest ( ) ; new ReissueRequestScripter ( req ) . openDialogWindow ( ) ; }
te	9	private MethodDec methodDec ( Type type , String name , Symbol qualifier , boolean isStatic , ClassDec classDec ) { MethodDec methodDec = new MethodDec ( name , type , qualifier , isStatic , classDec ) ; MethodDec aMethod = null ; currentMethod = methodDec ; lexer . nextToken ( ) ; if ( lexer . token != Symbol . RIGHTPAR ) { methodDec . setParamList ( formalParamDec ( ) ) ; } if ( currentClass . getVariable ( name ) != null ) { error . show ( "Redeclaration of member '" + name + "'" ) ; } aMethod = currentClass . checkOverrideMethod ( name ) ; if ( aMethod != null ) { if ( ! ( aMethod . isIsStatic ( ) && methodDec . isIsStatic ( ) ) ) { if ( ! methodDec . getType ( ) . equals ( aMethod . getType ( ) ) ) { error . show ( "Cannot override method. Superclass' method '" + aMethod . getName ( ) + "' has return type '" + aMethod . getType ( ) . getName ( ) + "' and redefined as '" + methodDec . getType ( ) . getName ( ) + "'" ) ; } signatureCompare ( aMethod , methodDec ) ; } } aMethod = currentClass . getMethod ( name , true , false , true ) ; if ( aMethod != null ) { if ( aMethod . isIsStatic ( ) == methodDec . isIsStatic ( ) ) error . show ( "Redeclaration of method '" + name + "'" ) ; } if ( lexer . token != Symbol . RIGHTPAR ) { error . show ( ") expected" ) ; } lexer . nextToken ( ) ; if ( lexer . token != Symbol . LEFTCURBRACKET ) { error . show ( "{ expected" ) ; } lexer . nextToken ( ) ; methodDec . setStatementList ( statementList ( ) ) ; if ( ! ( type instanceof VoidType ) && returnStatement == null ) { error . show ( "Return statement missing" ) ; } if ( ( type instanceof VoidType ) && returnStatement != null ) { error . show ( "Return statement inside method without return type" ) ; } returnStatement = null ; if ( lexer . token != Symbol . RIGHTCURBRACKET ) { error . show ( "} expected" ) ; } lexer . nextToken ( ) ; symbolTable . removeLocalIdent ( ) ; return methodDec ; }
te	6	public static String numberToString ( Number number ) throws JSONException { if ( number == null ) { throw new JSONException ( "Null pointer" ) ; } testValidity ( number ) ; String string = number . toString ( ) ; if ( string . indexOf ( . ) > 0 && string . indexOf ( e ) < 0 && string . indexOf ( E ) < 0 ) { while ( string . endsWith ( "0" ) ) { string = string . substring ( 0 , string . length ( ) - 1 ) ; } if ( string . endsWith ( "." ) ) { string = string . substring ( 0 , string . length ( ) - 1 ) ; } } return string ; }
te	9	public void invers_dct ( int ai [ ] ) { int i19 = 0 ; int j19 = 0 ; int k19 = 0 ; int l19 = 0 ; int l21 ; int i22 = l21 = 0 ; int matr1 [ ] = this . matr1 ; int matr2 [ ] = this . matr2 ; for ( ; l21 < 64 ; l21 += 8 ) { matr1 [ i22 ++ ] = ai [ l21 ] ; matr1 [ i22 ++ ] = ai [ l21 + 4 ] ; int i8 ; int l11 ; matr1 [ i22 ++ ] = ( i8 = ai [ l21 + 2 ] ) - ( l11 = ai [ l21 + 6 ] ) ; matr1 [ i22 ++ ] = i8 + l11 ; int j9 ; int k10 ; matr1 [ i22 ++ ] = - ( j9 = ai [ l21 + 3 ] ) + ( k10 = ai [ l21 + 5 ] ) ; int l6 ; int i13 ; int j14 ; int k15 ; matr1 [ i22 ++ ] = ( k15 = l6 = ai [ l21 + 1 ] + ( i13 = ai [ l21 + 7 ] ) ) - ( j14 = j9 + k10 ) ; matr1 [ i22 ++ ] = l6 - i13 ; matr1 [ i22 ++ ] = k15 + j14 ; } int i21 ; i22 = i21 = 0 ; for ( ; i21 < 8 ; i21 ++ ) switch ( i21 ) { case 0 : case 1 : case 3 : case 7 : int k9 ; int l10 ; int k1 = ( k9 = matr1 [ 24 + i21 ] ) - ( l10 = matr1 [ 40 + i21 ] ) ; int i7 ; int j13 ; int j3 = ( i7 = matr1 [ 8 + i21 ] ) - ( j13 = matr1 [ 56 + i21 ] ) ; int j18 = 1567 * ( j3 - k1 ) ; matr2 [ i22 ++ ] = matr1 [ i21 ] << 11 ; matr2 [ i22 ++ ] = matr1 [ 32 + i21 ] << 11 ; int j8 ; int i12 ; matr2 [ i22 ++ ] = ( ( j8 = matr1 [ 16 + i21 ] ) - ( i12 = matr1 [ 48 + i21 ] ) ) * 2896 ; matr2 [ i22 ++ ] = j8 + i12 << 11 ; matr2 [ i22 ++ ] = 2217 * k1 - j18 ; int k14 ; int l15 ; matr2 [ i22 ++ ] = ( ( l15 = i7 + j13 ) - ( k14 = k9 + l10 ) ) * 2896 ; matr2 [ i22 ++ ] = 5352 * j3 - j18 ; matr2 [ i22 ++ ] = l15 + k14 << 11 ; break ; case 2 : case 5 : int l9 ; int i11 ; int l1 = ( l9 = matr1 [ 24 + i21 ] ) - ( i11 = matr1 [ 40 + i21 ] ) ; int j7 ; int k13 ; int k3 = ( j7 = matr1 [ 8 + i21 ] ) - ( k13 = matr1 [ 56 + i21 ] ) ; int k18 = 2217 * ( k3 - l1 ) ; matr2 [ i22 ++ ] = 2896 * matr1 [ i21 ] ; matr2 [ i22 ++ ] = 2896 * matr1 [ i21 + 32 ] ; int k8 ; int j12 ; matr2 [ i22 ++ ] = ( k8 = matr1 [ 16 + i21 ] ) - ( j12 = matr1 [ 48 + i21 ] ) << 12 ; matr2 [ i22 ++ ] = 2896 * ( k8 + j12 ) ; matr2 [ i22 ++ ] = 3135 * l1 - k18 ; int l14 ; int i16 ; matr2 [ i22 ++ ] = ( i16 = j7 + k13 ) - ( l14 = l9 + i11 ) << 12 ; matr2 [ i22 ++ ] = 7568 * k3 - k18 ; matr2 [ i22 ++ ] = 2896 * ( i16 + l14 ) ; break ; case 4 : matr2 [ i22 ++ ] = matr1 [ i21 ] ; matr2 [ i22 ++ ] = matr1 [ 32 + i21 ] ; int l8 ; int k12 ; matr2 [ i22 ++ ] = ( l8 = matr1 [ 16 + i21 ] ) - ( k12 = matr1 [ 48 + i21 ] ) ; matr2 [ i22 ] = l8 + k12 ; int i10 ; int j11 ; i19 = k19 = - ( i10 = matr1 [ 24 + i21 ] ) + ( j11 = matr1 [ 40 + i21 ] ) ; i22 += 2 ; int k7 ; int l13 ; int i15 ; int j16 ; matr2 [ i22 ] = ( j16 = ( k7 = matr1 [ 8 + i21 ] ) + ( l13 = matr1 [ 56 + i21 ] ) ) - ( i15 = i10 + j11 ) ; l19 = - ( j19 = k7 - l13 ) ; i22 += 2 ; matr2 [ i22 ++ ] = j16 + i15 ; break ; case 6 : matr2 [ i22 ++ ] = matr1 [ i21 ] ; matr2 [ i22 ++ ] = matr1 [ 32 + i21 ] ; int i9 ; int l12 ; matr2 [ i22 ++ ] = ( i9 = matr1 [ 16 + i21 ] ) - ( l12 = matr1 [ 48 + i21 ] ) ; matr2 [ i22 ] = i9 + l12 ; int i2 ; int j10 ; int k11 ; j19 += i2 = - ( j10 = matr1 [ 24 + i21 ] ) + ( k11 = matr1 [ 40 + i21 ] ) ; l19 += i2 ; i22 += 2 ; int l7 ; int i14 ; int j15 ; int k16 ; matr2 [ i22 ] = ( k16 = ( l7 = matr1 [ 8 + i21 ] ) + ( i14 = matr1 [ 56 + i21 ] ) ) - ( j15 = j10 + k11 ) ; int l3 ; k19 += l3 = l7 - i14 ; i19 -= l3 ; i22 += 2 ; matr2 [ i22 ++ ] = k16 + j15 ; break ; } int i20 = 2896 * ( i19 + j19 ) ; int j20 = 2896 * ( i19 - j19 ) ; int k20 = k19 << 12 ; int l20 = l19 << 12 ; matr2 [ 36 ] = i20 + k20 ; matr2 [ 38 ] = j20 + l20 ; matr2 [ 52 ] = j20 - l20 ; matr2 [ 54 ] = k20 - i20 ; int l18 = 1567 * ( matr2 [ 32 ] + matr2 [ 48 ] ) ; matr2 [ 32 ] = - 2217 * matr2 [ 32 ] - l18 ; matr2 [ 48 ] = 5352 * matr2 [ 48 ] - l18 ; l18 = 1567 * ( matr2 [ 33 ] + matr2 [ 49 ] ) ; matr2 [ 33 ] = - 2217 * matr2 [ 33 ] - l18 ; matr2 [ 49 ] = 5352 * matr2 [ 49 ] - l18 ; l18 = 2217 * ( matr2 [ 34 ] + matr2 [ 50 ] ) ; matr2 [ 34 ] = - 3135 * matr2 [ 34 ] - l18 ; matr2 [ 50 ] = 7568 * matr2 [ 50 ] - l18 ; l18 = 1567 * ( matr2 [ 35 ] + matr2 [ 51 ] ) ; matr2 [ 35 ] = - 2217 * matr2 [ 35 ] - l18 ; matr2 [ 51 ] = 5352 * matr2 [ 51 ] - l18 ; l18 = 2217 * ( matr2 [ 37 ] + matr2 [ 53 ] ) ; matr2 [ 37 ] = - 3135 * matr2 [ 37 ] - l18 ; matr2 [ 53 ] = 7568 * matr2 [ 53 ] - l18 ; l18 = 1567 * ( matr2 [ 39 ] + matr2 [ 55 ] ) ; matr2 [ 39 ] = - 2217 * matr2 [ 39 ] - l18 ; matr2 [ 55 ] = 5352 * matr2 [ 55 ] - l18 ; int j21 ; for ( int j22 = j21 = 0 ; j21 < 8 ; j22 += 8 ) { int j2 ; int l17 ; matr1 [ j22 ] = ( j2 = ( l17 = matr2 [ j22 ] + matr2 [ j22 + 1 ] ) + matr2 [ j22 + 3 ] ) + matr2 [ j22 + 7 ] ; int i ; int k ; int i4 ; int k4 ; matr1 [ j22 + 3 ] = ( i4 = l17 - matr2 [ j22 + 3 ] ) - ( k4 = matr2 [ j22 + 4 ] - ( i = ( k = matr2 [ j22 + 6 ] - matr2 [ j22 + 7 ] ) - matr2 [ j22 + 5 ] ) ) ; matr1 [ j22 + 4 ] = i4 + k4 ; int i1 ; int l16 ; int j17 ; matr1 [ j22 + 1 ] = ( i1 = ( l16 = matr2 [ j22 ] - matr2 [ j22 + 1 ] ) + ( j17 = matr2 [ j22 + 2 ] - matr2 [ j22 + 3 ] ) ) + k ; int l2 ; matr1 [ j22 + 2 ] = ( l2 = l16 - j17 ) - i ; matr1 [ j22 + 5 ] = l2 + i ; matr1 [ j22 + 6 ] = i1 - k ; matr1 [ j22 + 7 ] = j2 - matr2 [ j22 + 7 ] ; j21 ++ ; } int i5 = 8 ; int j5 = 16 ; int k5 = 24 ; int l5 = 32 ; int i6 = 40 ; int j6 = 48 ; int k6 = 56 ; int k21 ; for ( int k22 = k21 = 0 ; k22 < 64 ; k22 += 8 ) { int k2 ; int i18 ; ai [ k22 ] = ( k2 = ( i18 = matr1 [ k21 ] + matr1 [ i5 ] ) + matr1 [ k5 ] ) + matr1 [ k6 ] >> 22 ; int j ; int l ; int j4 ; int l4 ; ai [ k22 + 3 ] = ( j4 = i18 - matr1 [ k5 ] ) - ( l4 = matr1 [ l5 ++ ] - ( j = ( l = matr1 [ j6 ++ ] - matr1 [ k6 ] ) - matr1 [ i6 ++ ] ) ) >> 22 ; ai [ k22 + 4 ] = j4 + l4 >> 22 ; int j1 ; int i17 ; int k17 ; ai [ k22 + 1 ] = ( j1 = ( i17 = matr1 [ k21 ++ ] - matr1 [ i5 ++ ] ) + ( k17 = matr1 [ j5 ++ ] - matr1 [ k5 ++ ] ) ) + l >> 22 ; int i3 ; ai [ k22 + 2 ] = ( i3 = i17 - k17 ) - j >> 22 ; ai [ k22 + 5 ] = i3 + j >> 22 ; ai [ k22 + 6 ] = j1 - l >> 22 ; ai [ k22 + 7 ] = k2 - matr1 [ k6 ++ ] >> 22 ; } }
te	8	void writeUTF ( String str , int off , int len ) throws IOException { int utflen = 0 ; for ( int i = 0 ; i < len ; i ++ ) { int ch = str . charAt ( off + i ) ; if ( ( ch >= 0001 ) && ( ch <= 007F ) ) { utflen += 1 ; } else { if ( ch > 07FF ) { utflen += 3 ; } else { utflen += 2 ; } } } writeByte ( utflen ) ; for ( int i = 0 ; i < len ; i ++ ) { int ch = str . charAt ( off + i ) ; if ( ( ch >= 0001 ) && ( ch <= 007F ) ) { writeByte ( ch ) ; } else { if ( ch > 07FF ) { writeByte ( E0 | ( ( ch >> 12 ) & 0F ) ) ; writeByte ( 80 | ( ( ch >> 6 ) & 3F ) ) ; writeByte ( 80 | ( ( ch >> 0 ) & 3F ) ) ; } else { writeByte ( C0 | ( ( ch >> 6 ) & 1F ) ) ; writeByte ( 80 | ( ( ch >> 0 ) & 3F ) ) ; } } } }
te	7	protected void stepFWDCalc ( boolean showSteps ) { if ( m_currentStep == 0 ) { m_btnSetOne . setEnabled ( false ) ; m_btnSetTwo . setEnabled ( false ) ; m_btnSetGapOne . setEnabled ( false ) ; m_btnSetGapTwo . setEnabled ( false ) ; m_btnScoreTable . setEnabled ( false ) ; m_btnPrev . setEnabled ( true ) ; m_btnBeginning . setEnabled ( true ) ; } Point realD = getCoordsByStep ( m_currentStep ) ; Point D = new Point ( realD . x - 1 , realD . y - 1 ) ; m_l1Choiche . setBackground ( SystemColor . control ) ; m_l2Choiche . setBackground ( SystemColor . control ) ; m_l3Choiche . setBackground ( SystemColor . control ) ; m_l4Choiche . setBackground ( SystemColor . control ) ; CellElement leftCell = m_dpTable . getCell ( realD . x - 1 , realD . y ) ; CellElement topCell = m_dpTable . getCell ( realD . x , realD . y - 1 ) ; CellElement topLeftCell = m_dpTable . getCell ( realD . x - 1 , realD . y - 1 ) ; ScoredCellElement currentCell = ( ScoredCellElement ) m_dpTable . getCell ( realD . x , realD . y ) ; ScoredCellElement gapLeftCell = ( ScoredCellElement ) m_dpTable . getCell ( 1 , realD . y ) ; ScoredCellElement gapTopCell = ( ScoredCellElement ) m_dpTable . getCell ( realD . x , 1 ) ; int scoreCurrent = Integer . parseInt ( currentCell . getScoreVal ( ) ) ; int scoreGapLeft = Integer . parseInt ( gapLeftCell . getScoreVal ( ) ) ; int scoreGapTop = Integer . parseInt ( gapTopCell . getScoreVal ( ) ) ; if ( showSteps ) { String DEqual = "D(" + ( D . y ) + "  " + ( D . x ) + ")= Max" ; String DLeft = "D(" + ( D . y ) + "  " + ( D . x - 1 ) + ") + sc.= " + leftCell . getVal ( ) + " + " + scoreGapLeft + " = " + ( leftCell . getIntVal ( ) + scoreGapLeft ) ; String DTop = "D(" + ( D . y - 1 ) + "  " + ( D . x ) + ") + sc.= " + topCell . getVal ( ) + " + " + scoreGapTop + " = " + ( topCell . getIntVal ( ) + scoreGapTop ) ; String DTopLeft = "D(" + ( D . y - 1 ) + "  " + ( D . x - 1 ) + ") + sc.= " + topLeftCell . getVal ( ) + " + " + scoreCurrent + " = " + ( topLeftCell . getIntVal ( ) + scoreCurrent ) ; m_lDEqual . setText ( DEqual ) ; m_l1Choiche . setText ( DLeft ) ; m_l2Choiche . setText ( DTop ) ; m_l3Choiche . setText ( DTopLeft ) ; } int fromLeftVal = leftCell . getIntVal ( ) + scoreGapLeft ; int fromTopVal = topCell . getIntVal ( ) + scoreGapTop ; int fromTopLeftVal = topLeftCell . getIntVal ( ) + scoreCurrent ; int zero = 0 ; int max = Math . max ( Math . max ( fromLeftVal , Math . max ( fromTopVal , fromTopLeftVal ) ) , 0 ) ; LinkedList highlightList = new LinkedList ( ) ; if ( fromLeftVal == max ) { m_l1Choiche . setBackground ( Color . yellow ) ; currentCell . addLeftPointer ( leftCell ) ; highlightList . add ( leftCell ) ; highlightList . add ( gapLeftCell ) ; } if ( fromTopVal == max ) { m_l2Choiche . setBackground ( Color . yellow ) ; currentCell . addTopPointer ( topCell ) ; highlightList . add ( topCell ) ; highlightList . add ( gapTopCell ) ; } if ( fromTopLeftVal == max ) { m_l3Choiche . setBackground ( Color . yellow ) ; currentCell . addDiagPointer ( topLeftCell ) ; highlightList . add ( topLeftCell ) ; } if ( max == 0 ) { m_l4Choiche . setBackground ( Color . yellow ) ; } currentCell . setIntVal ( max ) ; if ( showSteps ) { m_dpTable . setSideHighlight ( currentCell , new Color ( 0 , 255 , 255 ) ) ; m_dpTable . setTriArrows ( currentCell , true ) ; m_dpTable . setMultipleCellHighlight ( highlightList ) ; m_dpTable . paint ( m_dpTable . getGraphics ( ) ) ; } m_currentStep ++ ; }
te	2	private byte [ ] generateIntermediateSymbols ( ) { int Ki = SystematicIndices . getKIndex ( Kprime ) ; int S = SystematicIndices . S ( Ki ) ; int H = SystematicIndices . H ( Ki ) ; int L = Kprime + S + H ; int T = fecParams . symbolSize ( ) ; byte [ ] [ ] constraint_matrix = LinearSystem . generateConstraintMatrix ( Kprime , T ) ; byte [ ] [ ] D = new byte [ L ] [ T ] ; for ( int row = S + H , index = 0 ; row < K + S + H ; row ++ , index ++ ) D [ row ] = sourceSymbols [ index ] . data ( ) ; byte [ ] C = null ; try { C = LinearSystem . PInactivationDecoding ( constraint_matrix , D , T , Kprime ) ; } catch ( SingularMatrixException e ) { throw new RuntimeException ( "FATAL ERROR: Singular matrix for the encoding process. This should never happen." ) ; } return C ; }
te	3	public void process ( ) { Stack < Integer > stack = new Stack < Integer > ( ) ; InputReader in = new InputReader ( getClass ( ) . getResourceAsStream ( "/stack.txt" ) ) ; int push = in . readInt ( ) ; for ( int i = 0 ; i < push ; i ++ ) { stack . push ( in . readInt ( ) ) ; } for ( int item : stack ) System . out . print ( item + " " ) ; reverseStack ( stack ) ; System . out . println ( "" ) ; for ( int item : stack ) System . out . print ( item + " " ) ; }
te	4	@ Override public void doLayout ( ) { super . doLayout ( ) ; int maxHeightInRow = 0 ; int currentRowHeight = 0 ; JLabel cellRenderer ; for ( int row = 0 ; row < getRowCount ( ) ; row ++ ) { maxHeightInRow = 0 ; currentRowHeight = 0 ; for ( int column = 0 ; column < getColumnCount ( ) ; column ++ ) { cellRenderer = ( JLabel ) prepareRenderer ( getDefaultRenderer ( ScheduleElementViewWrapper . class ) , row , column ) ; currentRowHeight = cellRenderer . getPreferredSize ( ) . height + getIntercellSpacing ( ) . height + 20 ; if ( currentRowHeight > maxHeightInRow ) { maxHeightInRow = currentRowHeight ; } } setRowHeight ( row , maxHeightInRow > defaultRowHeight ? maxHeightInRow : defaultRowHeight ) ; } }
te	3	private static Endpoint getEndpointByAddress ( String ip , int port ) { for ( Endpoint e : endpoints ) { if ( e . getIp ( ) . equals ( ip ) && e . getPort ( ) == port ) { return e ; } } return null ; }
te	7	private int displayMenuOfAmounts ( ) { int userChoice = 0 ; Screen screen = getScreen ( ) ; int [ ] amounts = { 0 , 20 , 40 , 60 , 100 , 200 } ; while ( userChoice == 0 ) { screen . displayMessageLine ( "\nWithdrawal Menu:" ) ; screen . displayMessageLine ( "1 - $20" ) ; screen . displayMessageLine ( "2 - $40" ) ; screen . displayMessageLine ( "3 - $60" ) ; screen . displayMessageLine ( "4 - $100" ) ; screen . displayMessageLine ( "5 - $200" ) ; screen . displayMessageLine ( "6 - Cancel transaction" ) ; screen . displayMessage ( "\nChoose a withdrawal amount: " ) ; int input = keypad . getInput ( ) ; switch ( input ) { case 1 : case 2 : case 3 : case 4 : case 5 : userChoice = amounts [ input ] ; break ; case CANCELED : userChoice = CANCELED ; break ; default : screen . displayMessageLine ( "\nInvalid selection. Try again." ) ; } } return userChoice ; }
te	3	public List < PersistentFieldMeta > inspect ( class < ? > c ) { List < PersistentFieldMeta > meta = new ArrayList < PersistentFieldMeta > ( ) ; for ( Field f : ReflectionUtil . getAllFields ( c ) ) { if ( hasGetterAndSetter ( c , f ) ) meta . add ( new SimplePersistentFieldMeta ( f . getName ( ) , f . getType ( ) ) ) ; } return meta ; }
te	8	@ Override public void validarSemantica ( ) { Tipo var = null ; if ( InfSemantica . getInstancia ( ) . tablaGlobal . containsKey ( id ) ) { var = InfSemantica . getInstancia ( ) . tablaGlobal . get ( id ) ; } else { try { throw new Exception ( "Error Semantico  la variable" + id + " no a sido declarada" ) ; } catch ( Exception ex ) { Logger . getLogger ( SentenciaAsignacion . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } } Tipo val = null ; try { val = condicion . validarSemantica ( ) ; } catch ( Exception ex ) { Logger . getLogger ( SentenciaAsignacion . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } if ( ! val . esEquivalente ( var ) ) { try { StringBuilder message = new StringBuilder ( "Error Semantico  el tipo " ) ; message . append ( var . toString ( ) ) ; message . append ( " no coincide con el valor asignado" ) ; throw new Exception ( message . toString ( ) ) ; } catch ( Exception ex ) { Logger . getLogger ( SentenciaAsignacion . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } } Tipo val1 = null ; try { val1 = condicion2 . validarSemantica ( ) ; } catch ( Exception ex ) { Logger . getLogger ( SentenciaAsignacion . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } if ( val1 instanceof TipoBooleano ) { Sentencia tmp = compound ; while ( tmp != null ) { tmp . validarSemantica ( ) ; tmp = tmp . getSiguiente ( ) ; } } }
te	2	public void run ( ) { int quantity = Integer . parseInt ( howMany . getText ( ) ) ; int numPrimes = 0 ; int candidate = 2 ; primes . append ( "First " + quantity + " primes:" ) ; while ( numPrimes < quantity ) { if ( isPrime ( candidate ) ) { primes . append ( candidate + " " ) ; numPrimes ++ ; } candidate ++ ; } }
te	3	private String getTipo ( Usuario e ) { String tipo = "" ; if ( e instanceof Financeiro ) { tipo = TIPO_FINANCEIRO ; } else { if ( e instanceof Solicitante ) { tipo = TIPO_SOLICITANTE ; } else { if ( e instanceof Administrador ) { tipo = TIPO_ADMINISTRADOR ; } } } return tipo ; }
te	6	private static void method495 ( char ac [ ] ) { int i = 0 ; for ( int j = 0 ; j < ac . length ; j ++ ) { if ( method496 ( ac [ j ] ) ) ac [ i ] = ac [ j ] ; else ac [ i ] =   ; if ( i == 0 || ac [ i ] !=   || ac [ i - 1 ] !=   ) i ++ ; } for ( int k = i ; k < ac . length ; k ++ ) ac [ k ] =   ; }
te	6	@ Override public boolean equals ( Object o ) { if ( o == this ) return true ; if ( o == null || ! ( o instanceof TIPPCreator ) ) return false ; TIPPCreator c = ( TIPPCreator ) o ; return Objects . equals ( name , c . name ) && Objects . equals ( id , c . id ) && Objects . equals ( date , c . date ) && Objects . equals ( tool , c . tool ) ; }
te	6	public Automaton minus ( Automaton a ) { if ( isEmpty ( ) || a == this ) return Automaton . makeEmpty ( ) ; if ( a . isEmpty ( ) ) return clone ( ) ; if ( a == this ) return Automaton . makeEmpty ( ) ; if ( isSingleton ( ) ) { if ( a . run ( singleton ) ) return makeEmpty ( ) ; else return clone ( ) ; } return intersection ( a . complement ( ) ) ; }
te	8	private boolean isValidVertMove ( int r1 , int c1 , int r2 , int c2 ) { if ( c1 != c2 ) { return false ; } int step = r1 - r2 < 0 ? 1 : - 1 ; if ( step > 0 ) { for ( int r = r1 + step ; r < r2 ; r += step ) { if ( board [ r ] [ c1 ] != EMPTY ) { return false ; } } } else if ( step < 0 ) { for ( int r = r1 + step ; r > r2 ; r += step ) { if ( board [ r ] [ c1 ] != EMPTY ) { return false ; } } } return true ; }
