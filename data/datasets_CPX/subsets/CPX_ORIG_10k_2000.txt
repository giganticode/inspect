tr	6	public boolean check ( PrintStream ps , double tol ) { double dist ; double pointTol = 10 * tol ; if ( ! checkFaces ( tolerance , ps ) ) { return false ; } for ( int i = 0 ; i < numPoints ; i ++ ) { Point3d pnt = pointBuffer [ i ] . pnt ; for ( Iterator it = faces . iterator ( ) ; it . hasNext ( ) ; ) { Face face = ( Face ) it . next ( ) ; if ( face . mark == Face . VISIBLE ) { dist = face . distanceToPlane ( pnt ) ; if ( dist > pointTol ) { if ( ps != null ) { ps . println ( "Point " + i + " " + dist + " above face " + face . getVertexString ( ) ) ; } return false ; } } } } return true ; }
tr	7	public Response multPartURL ( String url , PostParameter [ ] params , ImageItem item , boolean authenticated ) throws WeiboException { PostMethod post = new PostMethod ( url ) ; try { org . apache . commons . httpclient . HttpClient client = getHttpClient ( ) ; long t = System . currentTimeMillis ( ) ; Part [ ] parts = null ; if ( params == null ) { parts = new Part [ 1 ] ; } else { parts = new Part [ params . length + 1 ] ; } if ( params != null ) { int i = 0 ; for ( PostParameter entry : params ) { parts [ i ++ ] = new StringPart ( entry . getName ( ) , ( String ) entry . getValue ( ) ) ; } parts [ parts . length - 1 ] = new ByteArrayPart ( item . getContent ( ) , item . getName ( ) , item . getContentType ( ) ) ; } post . setRequestEntity ( new MultipartRequestEntity ( parts , post . getParams ( ) ) ) ; List < Header > headers = new ArrayList < Header > ( ) ; if ( authenticated ) { if ( oauth == null ) { } String authorization = null ; if ( null != oauth ) { authorization = oauth . generateAuthorizationHeader ( "POST" , url , params , oauthToken ) ; } else { throw new IllegalStateException ( "Neither user ID/password combination nor OAuth consumer key/secret combination supplied" ) ; } headers . add ( new Header ( "Authorization" , authorization ) ) ; log ( "Authorization: " + authorization ) ; } client . getHostConfiguration ( ) . getParams ( ) . setParameter ( "http.default-headers" , headers ) ; client . executeMethod ( post ) ; Response response = new Response ( ) ; response . setResponseAsString ( post . getResponseBodyAsString ( ) ) ; response . setStatusCode ( post . getStatusCode ( ) ) ; log ( "multPartURL URL:" + url + "  result:" + response + "  time:" + ( System . currentTimeMillis ( ) - t ) ) ; return response ; } catch ( Exception ex ) { throw new WeiboException ( ex . getMessage ( ) , ex , - 1 ) ; } finally { post . releaseConnection ( ) ; } }
tr	5	public boolean equals ( Object o ) { if ( o == this ) return true ; if ( ! ( o instanceof Card ) ) return false ; Card aCard = ( Card ) o ; if ( ( aCard . suitID == this . suitID ) && ( aCard . nonTrumpCardValue == this . nonTrumpCardValue ) && ( aCard . trumpCardValue == this . trumpCardValue ) ) return true ; return false ; }
tr	4	public User getCreatorOfColour ( ColourRef cref ) { ClientResponse cresp ; try { cresp = service . path ( cref . getRef ( ) ) . type ( MediaType . APPLICATION_XML ) . get ( ClientResponse . class ) ; } catch ( ClientHandlerException che ) { return null ; } if ( cresp . getStatus ( ) == 200 ) { ClientResponse u_cresp ; try { u_cresp = service . path ( cresp . getEntity ( Colour . class ) . getCreator ( ) . getRef ( ) ) . type ( MediaType . APPLICATION_XML ) . get ( ClientResponse . class ) ; } catch ( ClientHandlerException che ) { return null ; } if ( u_cresp . getStatus ( ) == 200 ) { return u_cresp . getEntity ( User . class ) ; } } return null ; }
tr	4	public void equipWeapon ( Survivor survivor , Weapon weapon ) throws CantEquipWeaponException { if ( ! this . survivors . contains ( survivor ) ) { throw new CantEquipWeaponException ( CantEquipWeaponException . notInTheTeam ( survivor ) ) ; } else if ( ! this . mainBase . getAvailableWeapons ( ) . contains ( weapon ) ) { throw new CantEquipWeaponException ( "Weapon must be one of those stored in base to equip" ) ; } else { Survivor owner = this . alreadyEquipped ( weapon ) ; if ( owner != null ) { throw new CantEquipWeaponException ( "Weapon is already equipped by " + owner . getName ( ) ) ; } else { Weapon oldWeapon = survivor . getWeapon ( ) ; this . mainBase . getAvailableWeapons ( ) . remove ( weapon ) ; survivor . setWeapon ( weapon ) ; if ( oldWeapon != null ) { this . mainBase . getAvailableWeapons ( ) . add ( oldWeapon ) ; } } } }
tr	6	public boolean isSameTree ( TreeNode p , TreeNode q ) { if ( p == null && q == null ) return true ; if ( p == null || q == null ) return false ; if ( p . val != q . val ) return false ; return isSameTree ( p . left , q . left ) && isSameTree ( p . right , q . right ) ; }
tr	4	public TDirectory mkdir ( String path , boolean recursive ) { if ( recursive ) { String [ ] pathElements = parsePath ( path ) ; TDirectory current = this ; for ( String element : pathElements ) { TDirectory next = current . findDir ( element , false ) ; if ( next == null ) { next = current . mkdir ( element , false ) ; } current = next ; } return current ; } else { if ( subdirectories . containsKey ( path ) ) { throw new IllegalArgumentException ( "Directory " + path + " already exists" ) ; } TDirectory newDir = new TDirectory ( path , "" , this ) ; newDir . addOwnRecords ( fSeekDir ) ; keyList . add ( newDir . directoryRecord ) ; subdirectories . put ( path , newDir ) ; return newDir ; } }
tr	5	public static Pair < Integer , Integer > linearCongruence ( int a , int b , final int n ) { positiveCheck ( n ) ; a = normalizeIntModulo ( a , n ) ; b = normalizeIntModulo ( b , n ) ; if ( ( ( a == 0 ) && ( b == 0 ) ) || ( n == 1 ) ) return new Pair < > ( 0 , 1 ) ; final int numberOfSolutions = gcd ( a , n ) ; if ( b % numberOfSolutions != 0 ) return new Pair < > ( ) ; int bezoutCoefficientA ; if ( a > n ) bezoutCoefficientA = bezout ( a , n ) . get ( 1 ) ; else bezoutCoefficientA = bezout ( n , a ) . get ( 2 ) ; final int shiftedModulus = n / numberOfSolutions ; int x = ( bezoutCoefficientA * b ) / numberOfSolutions ; x = normalizeIntModulo ( x , shiftedModulus ) ; return new Pair < > ( x , shiftedModulus ) ; }
tr	9	public static String toString ( JSONArray ja ) throws JSONException { int i ; JSONObject jo ; String key ; Iterator keys ; int length ; Object object ; StringBuffer sb = new StringBuffer ( ) ; String tagName ; String value ; tagName = ja . getString ( 0 ) ; XML . noSpace ( tagName ) ; tagName = XML . escape ( tagName ) ; sb . append ( < ) ; sb . append ( tagName ) ; object = ja . opt ( 1 ) ; if ( object instanceof JSONObject ) { i = 2 ; jo = ( JSONObject ) object ; keys = jo . keys ( ) ; while ( keys . hasNext ( ) ) { key = keys . next ( ) . toString ( ) ; XML . noSpace ( key ) ; value = jo . optString ( key ) ; if ( value != null ) { sb . append (   ) ; sb . append ( XML . escape ( key ) ) ; sb . append ( = ) ; sb . append ( " ) ; sb . append ( XML . escape ( value ) ) ; sb . append ( " ) ; } } } else { i = 1 ; } length = ja . length ( ) ; if ( i >= length ) { sb . append ( / ) ; sb . append ( > ) ; } else { sb . append ( > ) ; do { object = ja . get ( i ) ; i += 1 ; if ( object != null ) { if ( object instanceof String ) { sb . append ( XML . escape ( object . toString ( ) ) ) ; } else if ( object instanceof JSONObject ) { sb . append ( toString ( ( JSONObject ) object ) ) ; } else if ( object instanceof JSONArray ) { sb . append ( toString ( ( JSONArray ) object ) ) ; } } } while ( i < length ) ; sb . append ( < ) ; sb . append ( / ) ; sb . append ( tagName ) ; sb . append ( > ) ; } return sb . toString ( ) ; }
tr	9	private boolean createHostel ( Element hostel ) { NodeList nameList = hostel . getElementsByTagName ( "name" ) ; NodeList addressList = hostel . getElementsByTagName ( "address" ) ; NodeList contactList = hostel . getElementsByTagName ( "contact" ) ; NodeList policyList = hostel . getElementsByTagName ( "restrictions" ) ; NodeList bedList = hostel . getElementsByTagName ( "availability" ) ; if ( nameList == null || nameList . getLength ( ) != 1 || addressList == null || addressList . getLength ( ) != 1 || contactList == null || contactList . getLength ( ) != 1 || policyList == null || policyList . getLength ( ) != 1 ) { return false ; } Node nameNode = nameList . item ( 0 ) ; Node addressNode = addressList . item ( 0 ) ; Node contactNode = contactList . item ( 0 ) ; Node policyNode = policyList . item ( 0 ) ; if ( nameNode . getNodeType ( ) != Node . ELEMENT_NODE || addressNode . getNodeType ( ) != Node . ELEMENT_NODE || contactNode . getNodeType ( ) != Node . ELEMENT_NODE || policyNode . getNodeType ( ) != Node . ELEMENT_NODE ) { return false ; } Address address = createAddress ( ( Element ) addressNode ) ; Contact contact = createContact ( ( Element ) contactNode ) ; Policy policy = createPolicy ( ( Element ) policyNode ) ; Identifier hostelId ; ArrayList < Identifier > bedIds = new ArrayList < Identifier > ( ) ; Hostel hostelInfo = new Hostel ( nameNode . getTextContent ( ) , address , contact , policy , bedIds ) ; try { hostelId = Hostels . getInstance ( ) . create ( hostelInfo ) ; } catch ( DataBaseReadWriteException | IdentifierAlreadyExistsException | InvalidParameterException e ) { e . printStackTrace ( ) ; return false ; } for ( int bedCount = 0 ; bedCount < bedList . getLength ( ) ; bedCount ++ ) { Node bedNode = bedList . item ( bedCount ) ; if ( bedNode . getNodeType ( ) == Node . ELEMENT_NODE ) { createBed ( ( Element ) bedNode , hostelId ) ; } } return true ; }
tr	8	public static boolean find ( String s , String f ) { if ( s . length ( ) < f . length ( ) ) { return false ; } char c [ ] = s . toCharArray ( ) ; char c1 [ ] = f . toCharArray ( ) ; for ( int i = 0 ; i < c . length ; i ++ ) { for ( int j = 0 ; j < c1 . length ; j ++ ) { if ( ( c [ i ] == c1 [ j ] ) && ( j == ( c1 . length - 1 ) ) ) { return true ; } else if ( ( c [ i ] == c1 [ j ] ) && ( i == ( c . length - 1 ) ) ) { return false ; } else if ( c [ i ] == c1 [ j ] ) { i ++ ; } } } return false ; }
tr	9	public static void main ( String argv [ ] ) { try { if ( argv . length != 1 ) { System . err . println ( "USBD [ start | stop ]" ) ; System . exit ( 1 ) ; } if ( "start" . equals ( argv [ 0 ] ) ) { Host host = HostFactory . getHost ( ) ; if ( host == null ) { System . err . println ( "USBD:  USB is not available." ) ; System . exit ( 1 ) ; } if ( host instanceof Remote ) { System . err . println ( "USBD: proxy already registered" ) ; System . exit ( 1 ) ; } try { HostProxy proxy = new HostProxy ( host ) ; Naming . bind ( rmiName , proxy ) ; System . err . println ( "USBD:  Bound RMI name " + rmiName ) ; } catch ( Exception e ) { System . err . println ( "USBD:  Couldn't bind to: " + rmiName ) ; if ( debug ) e . printStackTrace ( ) ; else System . err . println ( e . getMessage ( ) ) ; } } else if ( "stop" . equals ( argv [ 0 ] ) ) { System . err . println ( "USBD: no 'stop' yet ... " + "use 'ps' and 'kill' for now" ) ; } else { System . err . println ( "USBD: no '" + argv [ 0 ] + "' command" ) ; System . exit ( 1 ) ; } } catch ( Exception e ) { if ( debug ) e . printStackTrace ( ) ; else System . err . println ( e . getMessage ( ) ) ; } }
tr	1	public static void inorder ( BSTNode current ) { if ( current == null ) return ; inorder ( current . getLeft ( ) ) ; System . out . print ( current . getData ( ) + " " ) ; inorder ( current . getRight ( ) ) ; }
tr	3	public static List < FavoritesTag > constructTag ( Response res ) throws WeiboException { try { JSONArray list = res . asJSONObject ( ) . getJSONArray ( "tags" ) ; int size = list . length ( ) ; List < FavoritesTag > tags = new ArrayList < FavoritesTag > ( size ) ; for ( int i = 0 ; i < size ; i ++ ) { tags . add ( new FavoritesTag ( list . getJSONObject ( i ) ) ) ; } return tags ; } catch ( JSONException jsone ) { throw new WeiboException ( jsone ) ; } catch ( WeiboException te ) { throw te ; } }
tr	7	private static boolean fieldsLegit ( Level level , Field currentField , Field currentFieldNeighbour , List < Field > bannedFields ) { if ( currentField == null || currentFieldNeighbour == null ) return false ; if ( bannedFields . contains ( currentField ) || bannedFields . contains ( currentFieldNeighbour ) ) return false ; if ( currentField . object != null || currentFieldNeighbour . object != null ) return false ; if ( isNeighbours ( currentField , currentFieldNeighbour ) ) ; return true ; }
tr	2	public FTreeMap ( Map < ? extends Key , ? extends Val > map ) { comp = null ; tree = fromMap ( ( Map < Key , Val > ) map ) ; dflt = null ; }
tr	9	public static double qt ( double p , double ndf , boolean lower_tail ) { if ( p <= 0 || p >= 1 || ndf < 1 ) throw new IllegalArgumentException ( "Invalid p or df in call to qt(double double boolean)." ) ; double eps = 1e-12 ; double M_PI_2 = 1.570796326794896619231321691640 ; boolean neg ; double P , q , prob , a , b , c , d , y , x ; if ( ( lower_tail && p > 0.5 ) || ( ! lower_tail && p < 0.5 ) ) { neg = false ; P = 2 * ( lower_tail ? ( 1 - p ) : p ) ; } else { neg = true ; P = 2 * ( lower_tail ? p : ( 1 - p ) ) ; } if ( Math . abs ( ndf - 2 ) < eps ) { q = Math . sqrt ( 2 / ( P * ( 2 - P ) ) - 2 ) ; } else if ( ndf < 1 + eps ) { prob = P * M_PI_2 ; q = Math . cos ( prob ) / Math . sin ( prob ) ; } else { a = 1 / ( ndf - 0.5 ) ; b = 48 / ( a * a ) ; c = ( ( 20700 * a / b - 98 ) * a - 16 ) * a + 96.36 ; d = ( ( 94.5 / ( b + c ) - 3 ) / b + 1 ) * Math . sqrt ( a * M_PI_2 ) * ndf ; y = Math . pow ( d * P , 2 / ndf ) ; if ( y > 0.05 + a ) { x = qnorm ( 0.5 * P , false ) ; y = x * x ; if ( ndf < 5 ) c += 0.3 * ( ndf - 4.5 ) * ( x + 0.6 ) ; c = ( ( ( 0.05 * d * x - 5 ) * x - 7 ) * x - 2 ) * x + b + c ; y = ( ( ( ( ( 0.4 * y + 6.3 ) * y + 36 ) * y + 94.5 ) / c - y - 3 ) / b + 1 ) * x ; y = a * y * y ; if ( y > 0.002 ) y = Math . exp ( y ) - 1 ; else { y = ( 0.5 * y + 1 ) * y ; } } else { y = ( ( 1 / ( ( ( ndf + 6 ) / ( ndf * y ) - 0.089 * d - 0.822 ) * ( ndf + 2 ) * 3 ) + 0.5 / ( ndf + 4 ) ) * y - 1 ) * ( ndf + 1 ) / ( ndf + 2 ) + 1 / y ; } q = Math . sqrt ( ndf * y ) ; } if ( neg ) q = - q ; return q ; }
tr	5	public static String [ ] parseCSVLine ( String line ) { List < String > strlist = new LinkedList < String > ( ) ; String [ ] array = line . split ( " " ) ; String curr = "" ; boolean connect = false ; for ( String s : array ) { if ( s . startsWith ( "\"" ) ) { connect = true ; curr = s . substring ( 1 ) ; } else if ( connect == true ) { if ( s . endsWith ( "\"" ) ) { curr += s . substring ( 0 , s . length ( ) - 1 ) ; strlist . add ( curr ) ; curr = "" ; connect = false ; } else { curr += s ; } } else if ( connect == false ) { strlist . add ( s ) ; } } return strlist . toArray ( new String [ 0 ] ) ; }
tr	2	public Map < String , Map < String , Object >> loadAsMap ( String key ) throws IOException { Map < String , Map < String , Object >> map = new HashMap < String , Map < String , Object >> ( ) ; LineIterator iterator = new LineIterator ( new FileReader ( file ) ) ; while ( iterator . hasNext ( ) ) { Map < String , Object > json = JsonOutput . MAPPER . readValue ( iterator . nextLine ( ) , Map . class ) ; if ( json . containsKey ( key ) ) { map . put ( json . get ( key ) . toString ( ) , json ) ; } } return map ; }
tr	3	@ Override public PoolEntry < T > borrowEntry ( boolean createNew , long timeout , TimeUnit unit ) throws InterruptedException , TimeoutException , PoolException { try { if ( config . isWaitUnlimitOnBorrow ( ) ) { borrowingSemaphore . acquire ( ) ; } else { boolean acquireSuccess = borrowingSemaphore . tryAcquire ( timeout , unit ) ; if ( ! acquireSuccess ) { throw new TimeoutException ( "borrowEntry timed out." ) ; } } } catch ( InterruptedException e ) { throw e ; } return innerBorrowEntry ( createNew ) ; }
tr	0	public void setVersionName ( String value ) { this . versionName = value ; }
tr	8	private int [ ] initLineBreaks ( ) { int [ ] tmp = new int [ inputChars . length ] ; if ( inputChars . length == 0 ) return tmp ; tmp [ 0 ] = - 1 ; int lineCnt = 1 ; char prev = 0 ; for ( int i = 1 ; i != inputChars . length ; i ++ ) { char ch = inputChars [ i ] ; if ( ( ch == '' && prev != '' ) || ch == '' || ch ==  || ch ==   || ch ==   ) { tmp [ lineCnt ++ ] = i ; prev = ch ; } } return Arrays . copyOf ( tmp , lineCnt ) ; }
tr	3	public static void main ( String [ ] args ) { StackList stackList1 = new StackList ( ) ; int i = 0 ; for ( i = 0 ; i < 10 ; i ++ ) { stackList1 . push ( i * i ) ; System . out . print ( stackList1 . peek ( ) + " " + stackList1 . getSize ( ) + "; " ) ; } System . out . println ( ) ; stackList1 . printStackList ( ) ; Object obj = stackList1 . pop ( ) ; while ( obj != null ) { System . out . print ( obj + " " + stackList1 . getSize ( ) + "; " ) ; obj = stackList1 . pop ( ) ; } System . out . println ( ) ; for ( i = 0 ; i < 11 ; i ++ ) { System . out . print ( stackList1 . pop ( ) + " " + stackList1 . getSize ( ) + "; " ) ; } System . out . println ( ) ; stackList1 . printStackList ( ) ; }
tr	4	@ Override public void updatePosition ( final IUpdateInfo uInfo ) { super . updatePosition ( uInfo ) ; if ( angularVelocity . x != 0 || angularVelocity . y != 0 || angularVelocity . z != 0 ) { affineTransform . getOrientation ( ) . integrateRotationScaled ( angularVelocity , uInfo . getRate ( ) ) ; updateOrientation = true ; } if ( updateOrientation ) { affineTransform . getOrientation ( ) . getRotationMatrix3 ( rot ) ; MatrixExt . multiplyM3D3MT3 ( inverseInertiaTensor , rot , diagI ) ; } }
tr	4	public TrainingSet ( String line ) { String [ ] values = line . split ( " " ) ; int [ ] [ ] startBoard = new int [ GameOfLife . HEIGHT ] [ GameOfLife . WIDTH ] ; for ( int a = GameOfLife . HEIGHT ; a -- > 0 ; ) { for ( int b = GameOfLife . WIDTH ; b -- > 0 ; ) { startBoard [ a ] [ b ] = Integer . parseInt ( values [ b * GameOfLife . HEIGHT + a + 2 ] . trim ( ) ) ; } } int readOffset = 2 + GameOfLife . HEIGHT * GameOfLife . WIDTH ; int [ ] [ ] endBoard = new int [ GameOfLife . HEIGHT ] [ GameOfLife . WIDTH ] ; for ( int a = GameOfLife . HEIGHT ; a -- > 0 ; ) { for ( int b = GameOfLife . WIDTH ; b -- > 0 ; ) { endBoard [ a ] [ b ] = Integer . parseInt ( values [ b * GameOfLife . HEIGHT + a + readOffset ] . trim ( ) ) ; } } this . startBoard = new Board ( startBoard ) ; this . endBoard = new Board ( endBoard ) ; this . id = Integer . parseInt ( values [ 0 ] ) ; this . delta = Integer . parseInt ( values [ 1 ] ) ; }
tr	0	public final String getText ( Level level ) { return this . iterator . getUTF8Text ( level . value ) ; }
tr	1	@ Override public void save ( Pagina entity ) throws HibernatePaooException { try { iniciarOperacion ( ) ; sesion . saveOrUpdate ( entity ) ; tx . commit ( ) ; } catch ( HibernateException he ) { throw new HibernatePaooException ( he . getMessage ( ) ) ; } finally { sesion . close ( ) ; } }
tr	6	private static void findNearestMissFor ( int n ) { double ninv = 1d / n ; int max = 100000 ; double minDiff = double . MAX_VALUE ; Result result = null ; for ( int x = 3 ; x < max ; x ++ ) { double xn = pow ( x , n ) ; for ( int y = x ; y < max ; y ++ ) { double sum = xn + pow ( y , n ) ; double z = pow ( sum , ninv ) ; int intz = ( int ) round ( z ) ; double diff = abs ( z - intz ) ; if ( diff < THRESHOLD && intz != x && intz != y ) { double zn = pow ( intz , n ) ; double zndiff = abs ( sum - zn ) ; if ( zndiff < minDiff ) { minDiff = zndiff ; result = new Result ( x , y , n ) ; System . out . println ( result ) ; } } } } System . err . println ( result ) ; }
tr	5	static public boolean test ( int id ) { switch ( id ) { case BAG : case AMMO : case THROWN : case QUIVER : case RELIC : return true ; default : return false ; } }
tr	5	public void attack ( Player p ) { if ( dead ) { return ; } if ( ! ( p . get ( AttackComponent . class ) ) . isDead ( ) ) { if ( ( System . currentTimeMillis ( ) - lastAttack ) > stats . speed * 1000 ) { Random r = new Random ( ) ; int i = r . nextInt ( 100 ) ; if ( i <= p . getStats ( ) . def ) { Console . log ( "Player " + modify . getName ( ) + " missed attack against " + p . getName ( ) , in . INFO ) ; } else { int attack = ( ( Player ) modify ) . getStats ( ) . attack ; if ( attack < 0 ) { attack = 0 ; } ( p . get ( AttackComponent . class ) ) . addHealth ( - 1 * attack ) ; Console . log ( "THis player attacked " + p . getName ( ) , in . INFO ) ; } lastAttack = System . currentTimeMillis ( ) ; } } }
tr	4	public void printHolder ( byte holderID ) { if ( holderID == DataHolder . SENTENCE ) { printHolder ( holderID , 0 , this . sentenceTable . size ( ) - 1 ) ; } if ( holderID == DataHolder . SINGULAR_PLURAL ) { printHolder ( holderID , 0 , this . singularPluralTable . size ( ) - 1 ) ; } if ( holderID == DataHolder . UNKNOWNWORD ) { printHolder ( holderID , 0 , this . unknownWordTable . size ( ) - 1 ) ; } if ( holderID == DataHolder . WORDPOS ) { printHolder ( holderID , 0 , this . wordPOSTable . size ( ) - 1 ) ; } }
tr	1	public T getValue ( ) { if ( available == false ) { throw new RuntimeException ( "Value not available" ) ; } return value ; }
tr	8	boolean handleQuery ( JmDNSImpl dns , long expirationTime ) { ServiceInfoImpl info = ( ServiceInfoImpl ) dns . getServices ( ) . get ( name . toLowerCase ( ) ) ; if ( info != null && ( port != info . port || ! server . equalsIgnoreCase ( dns . getLocalHost ( ) . getName ( ) ) ) ) { logger . finer ( "handleQuery() Conflicting probe detected from: " + getRecordSource ( ) ) ; DNSRecord . Service localService = new DNSRecord . Service ( info . getQualifiedName ( ) , DNSConstants . TYPE_SRV , DNSConstants . CLASS_IN | DNSConstants . CLASS_UNIQUE , DNSConstants . DNS_TTL , info . priority , info . weight , info . port , dns . getLocalHost ( ) . getName ( ) ) ; try { if ( dns . getInterface ( ) . equals ( getRecordSource ( ) ) ) { logger . warning ( "Got conflicting probe from ourselves\n" + "incoming: " + this . toString ( ) + "\n" + "local   : " + localService . toString ( ) ) ; } } catch ( IOException e ) { e . printStackTrace ( ) ; } int comparison = lexCompare ( localService ) ; if ( comparison == 0 ) { logger . finer ( "handleQuery() Ignoring a identical service query" ) ; return false ; } if ( info . getState ( ) . isProbing ( ) && comparison > 0 ) { String oldName = info . getQualifiedName ( ) . toLowerCase ( ) ; info . setName ( dns . incrementName ( info . getName ( ) ) ) ; dns . getServices ( ) . remove ( oldName ) ; dns . getServices ( ) . put ( info . getQualifiedName ( ) . toLowerCase ( ) , info ) ; logger . finer ( "handleQuery() Lost tie break: new unique name chosen:" + info . getName ( ) ) ; info . revertState ( ) ; } else { return false ; } return true ; } return false ; }
tr	6	public static void main ( String [ ] args ) { int N = 4 ; int gC [ ] = { 1 , 5 , 3 , 6 } ; int d [ ] = { 2 , 3 , 2 , 7 } ; int rF [ ] = { 0 , 0 , 0 , 0 } ; int l , i ; for ( l = 0 ; l < N ; l ++ ) { for ( i = 0 ; i < N ; i ++ ) { if ( rF [ i ] >= 0 ) rF [ i ] += gC [ ( l + i ) % N ] - d [ ( l + i ) % N ] ; } } for ( i = 0 ; i < N ; i ++ ) { if ( rF [ i ] >= 0 ) break ; } if ( i < N ) { System . out . println ( "The Starting point is:" + i ) ; } else { System . out . println ( "There is no Starting point" ) ; } }
tr	7	public void writeSetEncodings ( int preferredEncoding , boolean useCopyRect ) { int nEncodings = 0 ; int [ ] encodings = new int [ Encodings . max + 2 ] ; if ( cp . supportsLocalCursor ) encodings [ nEncodings ++ ] = Encodings . pseudoEncodingCursor ; if ( cp . supportsDesktopResize ) encodings [ nEncodings ++ ] = Encodings . pseudoEncodingDesktopSize ; if ( Decoder . supported ( preferredEncoding ) ) { encodings [ nEncodings ++ ] = preferredEncoding ; } if ( useCopyRect ) { encodings [ nEncodings ++ ] = Encodings . copyRect ; } for ( int i = Encodings . max ; i >= 0 ; i -- ) { if ( i != preferredEncoding && Decoder . supported ( i ) ) { encodings [ nEncodings ++ ] = i ; } } writeSetEncodings ( nEncodings , encodings ) ; }
tr	3	public void shoot ( double xa , double ya , double za ) { super . shoot ( xa , ya , za ) ; for ( int i = 0 ; i < bombs . size ( ) ; i ++ ) { if ( bombs . get ( i ) . removed ) bombs . remove ( i -- ) ; } if ( bombs . size ( ) == 8 ) { bombs . remove ( 0 ) . detonate ( ) ; } StickyBomb bomb = new StickyBomb ( owner , this , xa , ya , za , 90 ) ; bombs . add ( bomb ) ; owner . level . add ( bomb ) ; shootDelay = shootDelayTime ; }
tr	5	public static void appendListFromJar ( String path , Hashtable map ) { try { for ( Enumeration entries = new ZipFile ( path ) . entries ( ) ; entries . hasMoreElements ( ) ; ) { String entry = entries . nextElement ( ) . toString ( ) ; int len = entry . length ( ) ; if ( entry . endsWith ( ".class" ) && entry . indexOf ( $ ) == - 1 ) { int slashpos = entry . lastIndexOf ( / ) ; String parent = entry . substring ( 0 , slashpos ) ; String child = entry . substring ( slashpos + 1 , len - 6 ) ; putItem ( map , parent , child , INDEX_CLASS ) ; slashpos = parent . lastIndexOf ( / ) ; if ( slashpos != - 1 ) { AddToParent ( map , parent . substring ( 0 , slashpos ) , parent . substring ( slashpos + 1 ) ) ; } } } } catch ( Throwable e ) { } }
tr	7	public void insertAndIndexDocument ( Document doc ) throws IOException , ClassNotFoundException { Node currentNode = null ; Node previousNode = null ; int sentenceNumber = 0 ; int wordNumber = 0 ; Transaction tx = graphDb . beginTx ( ) ; try { ArrayList < Sentence > sentences = doc . getSentences ( ) ; for ( Sentence sentence : sentences ) { wordNumber = 0 ; ArrayList < Word > words = sentence . getWords ( ) ; for ( Word word : words ) { currentNode = findNodeByProperty ( Neo4jNode . WORD_PROPERTY , word . getContent ( ) ) ; if ( currentNode == null ) { Neo4jNode newNode = new Neo4jNode ( word . getContent ( ) ) ; ArrayList < String > documentEntity = new ArrayList < String > ( ) ; documentEntity . add ( "1" ) ; documentEntity . add ( String . valueOf ( sentenceNumber ) + "_" + String . valueOf ( wordNumber ) ) ; newNode . addToDocumentTable ( doc . getId ( ) , documentEntity ) ; insertAndIndexNode ( newNode ) ; currentNode = findNodeByProperty ( Neo4jNode . WORD_PROPERTY , word . getContent ( ) ) ; } else { Neo4jNode existingNode = convertToNeo4jNode ( currentNode ) ; if ( existingNode . isInDocumentTable ( doc . getId ( ) ) ) { ArrayList < String > documentEntity = existingNode . getDocumentEntity ( doc . getId ( ) ) ; int tf = Integer . parseInt ( documentEntity . get ( 0 ) ) + 1 ; documentEntity . set ( 0 , String . valueOf ( tf ) ) ; documentEntity . add ( String . valueOf ( sentenceNumber ) + "_" + String . valueOf ( wordNumber ) ) ; existingNode . addToDocumentTable ( doc . getId ( ) , documentEntity ) ; } else { ArrayList < String > documentEntity = new ArrayList < String > ( ) ; documentEntity . add ( "1" ) ; documentEntity . add ( String . valueOf ( sentenceNumber ) + "_" + String . valueOf ( wordNumber ) ) ; existingNode . addToDocumentTable ( doc . getId ( ) , documentEntity ) ; } modifyAndIndexNode ( existingNode , currentNode ) ; currentNode = findNodeByProperty ( Neo4jNode . WORD_PROPERTY , word . getContent ( ) ) ; } if ( currentNode != null && previousNode != null && ! doesRelationsExist ( previousNode , currentNode , "document_" + doc . getId ( ) ) ) { createRelationship ( previousNode , currentNode , "document_" + doc . getId ( ) ) ; } previousNode = currentNode ; wordNumber ++ ; } sentenceNumber ++ ; } tx . success ( ) ; } finally { tx . finish ( ) ; } }
tr	5	@ Override public void run ( ) { int nrOfLoops = ( maxY - minY ) * ( maxX - minX ) ; double cx , cy ; FractFunctionResult res ; FractCalcerProgressData pdata = new FractCalcerProgressData ( ) ; pdata . threadNr = this . threadNr ; pdata . threadName = this . getName ( ) ; for ( int y = minY ; y <= maxY ; y ++ ) { cy = fractParam . min_cy + ( maxY - y ) * fractParam . punkt_abstand ; for ( int x = minX ; x <= maxX ; x ++ ) { if ( isCancelled ( ) ) { return ; } cx = fractParam . min_cx + x * fractParam . punkt_abstand ; res = fractParam . iterFunc . fractIterFunc ( cx , cy , fractParam . maxBetragQuadrat , fractParam . maxIterations , fractParam . juliaKr , fractParam . juliaKi ) ; if ( fractParam . smoothColors == true ) { iterValues [ x ] [ y ] = res . iterValue - Math . log ( Math . log ( res . bailoutValue ) / Math . log ( 4 ) ) / Math . log ( 2 ) ; ; } else { iterValues [ x ] [ y ] = res . iterValue ; } double percentualIterValue = iterValues [ x ] [ y ] / fractParam . maxIterations ; colorizer . colorizeRasterPixel ( raster , x , y , palette , percentualIterValue ) ; } if ( y % 50 == 0 ) { pdata . threadProgress = ( y * ( maxX - minX ) ) / ( double ) nrOfLoops ; FractCalcer . this . publish ( pdata ) ; } } pdata . threadProgress = 1 ; FractCalcer . this . publish ( pdata ) ; }
tr	5	private T createTerminalWithFeatures ( List < String > featureList ) { T result = new T ( ) ; if ( featureList == null ) return result ; String featureName , featureValue ; int namelessFeatureCounter = 1 ; String [ ] featureParts ; for ( String item : featureList ) { if ( item . equals ( "" ) ) continue ; featureParts = item . split ( FEATS_PART_SPLIT_EXPRESSION ) ; if ( featureParts . length > 1 ) { featureName = featureParts [ 0 ] ; featureValue = featureParts [ 1 ] ; } else { featureName = "other" + ( namelessFeatureCounter ++ > 1 ? "_" + namelessFeatureCounter : "" ) ; featureValue = item ; } result . setFeature ( featureName , featureValue ) ; registerFeaturevalueToFeature ( featureValue , featureName , TERMINAL_FEATURE_DOMAIN ) ; } return result ; }
tr	0	private void loadKeyActions ( ) { replPanel . addKeyAction ( "F1" , new HelpAction ( ) ) ; replPanel . addKeyAction ( "ctrl S" , new SaveAction ( ) ) ; replPanel . addKeyAction ( "ctrl O" , new LoadAction ( ) ) ; }
tr	9	static final Writer writeValue ( Writer writer , Object value , int indentFactor , int indent ) throws JSONException , IOException { if ( value == null || value . equals ( null ) ) { writer . write ( "null" ) ; } else if ( value instanceof JSONObject ) { ( ( JSONObject ) value ) . write ( writer , indentFactor , indent ) ; } else if ( value instanceof JSONArray ) { ( ( JSONArray ) value ) . write ( writer , indentFactor , indent ) ; } else if ( value instanceof Map ) { new JSONObject ( ( Map ) value ) . write ( writer , indentFactor , indent ) ; } else if ( value instanceof Collection ) { new JSONArray ( ( Collection ) value ) . write ( writer , indentFactor , indent ) ; } else if ( value . getClass ( ) . isArray ( ) ) { new JSONArray ( value ) . write ( writer , indentFactor , indent ) ; } else if ( value instanceof Number ) { writer . write ( numberToString ( ( Number ) value ) ) ; } else if ( value instanceof boolean ) { writer . write ( value . toString ( ) ) ; } else if ( value instanceof JSONString ) { Object o ; try { o = ( ( JSONString ) value ) . toJSONString ( ) ; } catch ( Exception e ) { throw new JSONException ( e ) ; } writer . write ( o != null ? o . toString ( ) : quote ( value . toString ( ) ) ) ; } else { quote ( value . toString ( ) , writer ) ; } return writer ; }
tr	0	public ScoreLevel ( ) { this . Id = 0 ; this . message = "" ; this . whole = true ; this . half = true ; this . dottedhalf = false ; this . quarter = false ; this . eighth = false ; this . silence = true ; this . triplet = false ; this . currentKey = "treble" ; this . randomtonality = false ; this . currenttonality = new Tonality ( 0 , "" ) ; this . pitcheslist = new ArrayList < Integer > ( ) ; this . notetype = "notes" ; this . nbnotes = 9 ; this . timeSignNumerator = 4 ; this . timeSignDenominator = 4 ; this . timeDivision = 1 ; this . speed = 28 ; this . metronome = true ; this . beats = false ; }
tr	0	public int getLineNumber ( ) { return TokenStream . this . getLineNumber ( beg ) ; }
tr	9	void moveDown ( int i , boolean min ) { int size = heap . size ( ) ; while ( i < size ) { int p = highDescendant ( i , min ) ; if ( p < 0 ) { return ; } int cmp = compare ( heap . get ( p ) , heap . get ( i ) ) ; if ( i == grandParent ( p ) ) { if ( min ? cmp < 0 : cmp > 0 ) { swap ( i , p ) ; int pr = parent ( p ) ; int c = compare ( heap . get ( p ) , heap . get ( pr ) ) ; if ( min ? c > 0 : c < 0 ) { swap ( p , pr ) ; } } } else { if ( min ? cmp < 0 : cmp > 0 ) { swap ( i , p ) ; return ; } } i = p ; } }
tr	0	public void setProjectId ( int projectId ) { this . projectId = projectId ; }
tr	6	void checkNotLinked ( ) { if ( min != null && min . isLinkedDeep ( ) || pref != null && pref . isLinkedDeep ( ) || max != null && max . isLinkedDeep ( ) ) throw new IllegalArgumentException ( "Size may not contain links" ) ; }
tr	2	public List < WishList > find ( int idu ) throws InstanceNotFoundException { List < WishList > list = new ArrayList < WishList > ( ) ; try { Connection connection = DataSourceUtils . getConnection ( dataSource ) ; PreparedStatement statement = connection . prepareStatement ( "SELECT idu  idp FROM wishlist WHERE idu=?" ) ; statement . setInt ( 1 , idu ) ; ResultSet resultSet = statement . executeQuery ( ) ; while ( resultSet . next ( ) ) { list . add ( new WishList ( resultSet . getInt ( 2 ) , resultSet . getInt ( 1 ) ) ) ; } } catch ( SQLException e ) { throw new RuntimeException ( e ) ; } return list ; }
tr	6	public void disablePlugin ( CommandSender sender , String [ ] args ) { if ( args . length == 1 ) { sender . sendMessage ( pre + red + specifyPlugin ) ; return ; } if ( "all" . equalsIgnoreCase ( args [ 1 ] ) || "*" . equalsIgnoreCase ( args [ 1 ] ) ) { for ( Plugin pl : Bukkit . getPluginManager ( ) . getPlugins ( ) ) { Bukkit . getPluginManager ( ) . disablePlugin ( pl ) ; } sender . sendMessage ( pre + red + "All plugins disabled!" ) ; return ; } String pl = consolidateArgs ( args ) ; if ( getPlugin ( pl ) == null ) { sender . sendMessage ( pre + red + pluginNotFound ) ; return ; } if ( ! getPlugin ( pl ) . isEnabled ( ) ) { sender . sendMessage ( pre + red + "Plugin already disabled!" ) ; return ; } Plugin targetPlugin = getPlugin ( pl ) ; Bukkit . getPluginManager ( ) . disablePlugin ( targetPlugin ) ; sender . sendMessage ( pre + red + targetPlugin . getName ( ) + " Disabled!" ) ; }
tr	5	public boolean fireballCollideCheck ( Fireball fireball ) { if ( deadTime != 0 ) return false ; float xD = fireball . x - x ; float yD = fireball . y - y ; if ( xD > - 16 && xD < 16 ) { if ( yD > - height && yD < fireball . height ) { return true ; } } return false ; }
tr	0	@ Override public boolean esProducto ( ) { return false ; }
tr	2	@ Override public String toString ( ) { if ( pad_bits == 0 ) { return "#Bin<" + bin . length + ">" ; } if ( bin . length == 0 ) { throw new java . lang . IllegalStateException ( "Impossible length" ) ; } return "#Bin<" + bin . length + "-" + pad_bits + ">" ; }
tr	6	@ SuppressWarnings ( "deprecation" ) public static void insertTestData ( Connection databaseConnection ) throws SQLException { List < Student > studentList = new ArrayList < Student > ( ) ; studentList . add ( new Student ( "firstname_1" , "lastname_1" , new Date ( 80 , 1 , 1 ) , 2.1 ) ) ; studentList . add ( new Student ( "firstname_2" , "lastname_2" , new Date ( 80 , 1 , 2 ) , 2.2 ) ) ; studentList . add ( new Student ( "firstname_3" , "lastname_3" , new Date ( 80 , 1 , 3 ) , 2.3 ) ) ; studentList . add ( new Student ( "firstname_4" , "lastname_4" , new Date ( 80 , 1 , 4 ) , 2.4 ) ) ; studentList . add ( new Student ( "firstname_5" , "lastname_5" , new Date ( 80 , 1 , 5 ) , 2.5 ) ) ; studentList . add ( new Student ( "firstname_6" , "lastname_6" , new Date ( 80 , 1 , 6 ) , 2.6 ) ) ; studentList . add ( new Student ( "firstname_7" , "lastname_7" , new Date ( 80 , 1 , 7 ) , 2.7 ) ) ; studentList . add ( new Student ( "firstname_8" , "lastname_8" , new Date ( 80 , 1 , 8 ) , 2.8 ) ) ; PreparedStatement preparedStatement = databaseConnection . prepareStatement ( "INSERT INTO STUDENT (FIRSTNAME  LASTNAME  BIRTHDATE  GPA) VALUES (? ? ? ?)" , PreparedStatement . RETURN_GENERATED_KEYS ) ; for ( Student student : studentList ) { preparedStatement . setString ( 1 , student . firstname ) ; preparedStatement . setString ( 2 , student . lastname ) ; preparedStatement . setDate ( 3 , student . birthdate ) ; preparedStatement . setDouble ( 4 , student . gpa ) ; preparedStatement . executeUpdate ( ) ; ResultSet resultSet = preparedStatement . getGeneratedKeys ( ) ; if ( resultSet . next ( ) ) { student . id = resultSet . getInt ( 1 ) ; } } List < Course > courseList = new ArrayList < Course > ( ) ; courseList . add ( new Course ( "course_1" ) ) ; courseList . add ( new Course ( "course_2" ) ) ; courseList . add ( new Course ( "course_3" ) ) ; courseList . add ( new Course ( "course_4" ) ) ; preparedStatement = databaseConnection . prepareStatement ( "INSERT INTO COURSE (NAME) VALUES (?)" , PreparedStatement . RETURN_GENERATED_KEYS ) ; for ( Course course : courseList ) { preparedStatement . setString ( 1 , course . name ) ; preparedStatement . executeUpdate ( ) ; ResultSet resultSet = preparedStatement . getGeneratedKeys ( ) ; if ( resultSet . next ( ) ) { course . id = resultSet . getInt ( 1 ) ; } } Map < Integer , String > studentGradeMap = new HashMap < Integer , String > ( ) ; studentGradeMap . put ( 1 , "A" ) ; studentGradeMap . put ( 2 , "A-" ) ; studentGradeMap . put ( 3 , "B+" ) ; studentGradeMap . put ( 4 , "B" ) ; preparedStatement = databaseConnection . prepareStatement ( "INSERT INTO GRADE (STUDENT_ID  COURSE_ID  GRADE) VALUES (? ? ?)" ) ; for ( int i = 0 ; i < courseList . size ( ) ; i ++ ) { for ( int j = 0 ; j < ( i + 1 ) * 2 ; j ++ ) { int studentID = studentList . get ( j ) . id ; int courseID = courseList . get ( i ) . id ; String grade = studentGradeMap . get ( i + 1 ) ; preparedStatement . setInt ( 1 , studentID ) ; preparedStatement . setInt ( 2 , courseID ) ; preparedStatement . setString ( 3 , grade ) ; preparedStatement . executeUpdate ( ) ; } } }
tr	3	public static boolean writeObj ( Serializable src , String absPath ) { ObjectOutputStream oos = null ; try { oos = new ObjectOutputStream ( new BufferedOutputStream ( new FileOutputStream ( absPath ) ) ) ; oos . writeObject ( src ) ; oos . flush ( ) ; return true ; } catch ( IOException e ) { e . printStackTrace ( ) ; } finally { try { if ( oos != null ) oos . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } return false ; }
tr	5	public void add ( Object element ) { int freeIndex = - 1 ; for ( int i = 0 ; i < set . length ; ++ i ) { if ( null == set [ i ] ) { freeIndex = i ; } else if ( set [ i ] . equals ( element ) ) { return ; } } if ( - 1 == freeIndex ) { freeIndex = set . length ; set = Arrays . copyOf ( set , 2 * set . length ) ; } if ( 0 <= freeIndex ) { set [ freeIndex ] = element ; ++ occupied ; } }
tr	5	public boolean equals ( Object _other ) { if ( _other == null ) { return false ; } if ( _other == this ) { return true ; } if ( ! ( _other instanceof InviteRes ) ) { return false ; } final InviteRes _cast = ( InviteRes ) _other ; if ( inviteRes == null ? _cast . inviteRes != inviteRes : ! inviteRes . equals ( _cast . inviteRes ) ) { return false ; } return true ; }
tr	7	public String toString ( ) { String str = "" ; if ( frameData != null ) { for ( int s = 0 ; s < getNumSignals ( ) ; s ++ ) { String st = "" ; for ( int f = 0 ; f < frameData . length ; f ++ ) if ( frameData [ f ] [ s ] >= 0 ) st += ( st . length ( ) == 0 ? "" : " " ) + f + "=" + frameData [ f ] [ s ] ; str += "(" + st + ")" ; } for ( int f = 0 ; f < pauseData . length ; f ++ ) if ( pauseData [ f ] ) str += " " + f ; } return str ; }
tr	7	private void calculateScores ( ) { resetScores ( ) ; Champion [ ] champions = getChampions ( ) ; Strategy [ ] strategies = Strategy . values ( ) ; for ( int i = 0 ; i < strategies . length ; i ++ ) { for ( int j = 0 ; j < 10 ; j ++ ) { if ( champions [ j ] != null && ( Initialiser . getMainFrame ( ) . getButtonPanel ( ) . isTacticEnabled ( i ) || j > 4 ) ) { float score = champions [ j ] . getScoreForStrategy ( strategies [ i ] ) ; if ( score > 0 ) scores [ ( j < 5 ) ? i : i + 5 ] += score ; } } } }
tr	4	public void setFromXmlString ( String s ) { if ( s . equals ( "horizontal" ) ) { setOrientation ( Orientations . horizontal ) ; return ; } if ( s . equals ( "90left" ) ) { setOrientation ( Orientations . left ) ; return ; } if ( s . equals ( "90right" ) ) { setOrientation ( Orientations . right ) ; return ; } if ( s . equals ( "180" ) ) { setOrientation ( Orientations . upside ) ; return ; } }
tr	3	@ Override public int corpusTermFrequency ( String term ) { int count = 0 ; HashMap < Integer , ArrayList < Integer >> docMap = null ; if ( term . contains ( " " ) ) { docMap = getPhraseDocMap ( term ) ; } else { if ( ! _dictionary . containsKey ( term ) ) return 0 ; int idx = _dictionary . get ( term ) ; docMap = getDocMap ( idx ) ; } Set < Integer > keySet = docMap . keySet ( ) ; for ( Integer key : keySet ) { count += docMap . get ( key ) . size ( ) ; } return count ; }
tr	2	public synchronized static int insert ( Integer supplierID , double price , String productName , String productDescription , boolean inStock ) throws SQLException { Connection connection = null ; PreparedStatement prepStmt = null ; try { connection = DB . getConnection ( ) ; connection . setAutoCommit ( true ) ; int insertedID = - 1 ; String sql = "INSERT INTO Product (SupplierID  Price  ProductName  ProductDescription  InStock) VALUES (? ? ? ? ?);" ; prepStmt = connection . prepareStatement ( sql , Statement . RETURN_GENERATED_KEYS ) ; prepStmt . setInt ( 1 , supplierID ) ; prepStmt . setDouble ( 2 , price ) ; prepStmt . setString ( 3 , productName ) ; prepStmt . setString ( 4 , productDescription ) ; prepStmt . setBoolean ( 5 , inStock ) ; prepStmt . executeUpdate ( ) ; ResultSet rs = prepStmt . getGeneratedKeys ( ) ; if ( rs . next ( ) ) { insertedID = rs . getInt ( 1 ) ; } prepStmt . close ( ) ; DB . closeConnection ( ) ; return insertedID ; } catch ( Exception e ) { throw e ; } }
tr	1	private BatchResponse [ ] parseBatchResponse ( final HttpResponse response ) throws DiffbotParseException { try { return response . parseAs ( BatchResponse [ ] . class ) ; } catch ( IOException e ) { throw new DiffbotParseException ( bundle . getString ( "response.not.parsed" ) , e ) ; } }
tr	8	public void run ( ) { ParallelWarteClass paraWait = new ParallelWarteClass ( 10000 ) ; paraWait . start ( ) ; while ( ! ( HWaccess . readInt ( Adressen . LaufbandEingang . ordinal ( ) ) == 1 ) && paraWait . isAlive ( ) ) { try { Thread . sleep ( 150 ) ; } catch ( InterruptedException e ) { interrupt ( ) ; } } if ( ! paraWait . isAlive ( ) ) { interrupt ( ) ; return ; } else { paraWait . interrupt ( ) ; } paraWait = new ParallelWarteClass ( 10000 ) ; paraWait . start ( ) ; while ( ! ( HWaccess . readInt ( Adressen . LaufbandEingang . ordinal ( ) ) == 0 ) && paraWait . isAlive ( ) ) { try { Thread . sleep ( 150 ) ; } catch ( InterruptedException e ) { this . interrupt ( ) ; } } if ( ! paraWait . isAlive ( ) ) { interrupt ( ) ; } else { paraWait . interrupt ( ) ; } result = true ; }
tr	8	@ Override public void actionPerformed ( ActionEvent e ) { Object o = e . getSource ( ) ; if ( o instanceof JButton ) { if ( ( ( JButton ) o ) . equals ( adauga_absenta ) ) { String nume_prenume = elev_selectat . getNume ( ) + " " + elev_selectat . getPrenume ( ) ; getElevAndClasa ( nume_prenume , profesor . getSelectedClasa ( ) . getIdClasa ( ) ) ; String data_de_formatat = an . getSelectedItem ( ) . toString ( ) + "-" + luna . getSelectedItem ( ) . toString ( ) + "-" + zi . getSelectedItem ( ) ; String tipul_absentei = tip_absenta_de_adaugat . getSelectedItem ( ) . toString ( ) ; TipAbsenta tip_real = null ; switch ( tipul_absentei ) { case "motivata" : tip_real = TipAbsenta . motivata ; break ; case "nemotivata" : tip_real = TipAbsenta . nemotivata ; break ; case "nedeterminat" : tip_real = TipAbsenta . nedeterminat ; break ; } Date d = null ; try { SimpleDateFormat form = new SimpleDateFormat ( "yyyy-MM-dd" ) ; d = form . parse ( data_de_formatat ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; } String [ ] arr_data = d . toString ( ) . split ( " " ) ; String data_de_adaugat = arr_data [ 0 ] + "-" + arr_data [ 1 ] + "-" + arr_data [ 2 ] ; if ( ! map_abs . containsKey ( data_de_adaugat ) ) { profesor . addAbsenta ( elev_selectat , tip_real , d ) ; addRow ( tip_real , d ) ; map_abs . put ( data_de_adaugat , tip_real . toString ( ) ) ; } else { JOptionPane . showMessageDialog ( this , "Exista deja o absenta pe data respectiva" ) ; return ; } } else if ( e . getSource ( ) . equals ( back ) ) { dispose ( ) ; Centralizator cen2 = Centralizator . getInstance ( ) ; cen2 . saveCentralizator ( ) ; new ProfesorEditare ( profesor ) ; } } }
tr	7	private static void test8 ( ) throws FileNotFoundException { String input = "new\n" + "pick up cell key\n" + "unlock cell door with cell key\n" + "quit\n" + "y\n" ; HashMap < Integer , String > output = new HashMap < Integer , String > ( ) ; boolean passed = true ; try { in = new ByteArrayInputStream ( input . getBytes ( ) ) ; System . setIn ( in ) ; out = new PrintStream ( "testing.txt" ) ; System . setOut ( out ) ; Game . main ( null ) ; } catch ( ExitException se ) { } catch ( Exception e ) { System . setOut ( stdout ) ; System . out . println ( "Error: " ) ; e . printStackTrace ( ) ; passed = false ; } finally { System . setOut ( stdout ) ; @ SuppressWarnings ( "resource" ) Scanner sc = new Scanner ( new File ( "testing.txt" ) ) ; ArrayList < String > testOutput = new ArrayList < String > ( ) ; while ( sc . hasNextLine ( ) ) { testOutput . add ( sc . nextLine ( ) ) ; } output . put ( 13 , "The guard walks toward your cell." ) ; output . put ( 14 , ">> You unlock the cell door." ) ; output . put ( 15 , "The guard peers into the cell  checking that the door is secured." ) ; output . put ( 16 , "The door swings open." ) ; output . put ( 17 , "You have been caught." ) ; output . put ( 18 , "YOU LOSE!" ) ; output . put ( testOutput . size ( ) - 1 , ">>" ) ; if ( passed ) { for ( Map . Entry < Integer , String > entry : output . entrySet ( ) ) { if ( ! testOutput . get ( entry . getKey ( ) ) . equals ( entry . getValue ( ) ) ) { passed = false ; System . out . println ( "test8 failed: Line " + entry . getKey ( ) ) ; System . out . println ( "\tExpected: " + entry . getValue ( ) ) ; System . out . println ( "\tReceived: " + testOutput . get ( entry . getKey ( ) ) ) ; } } if ( passed ) { System . out . println ( "test8 passed" ) ; } } else { System . out . println ( "test8 failed: error" ) ; } } }
tr	0	@ Override protected final V convert ( String argument ) { return convertWith ( converter , argument ) ; }
tr	2	public static ReversalIndType fromValue ( String v ) { for ( ReversalIndType c : ReversalIndType . values ( ) ) { if ( c . value . equals ( v ) ) { return c ; } } throw new IllegalArgumentException ( v ) ; }
tr	5	public boolean recordLogin ( InetAddress origin , String userName ) { boolean ret = false ; Watch time = new Watch ( ) ; String incQuery = "UPDATE History SET lastLoginIndex = lastLoginIndex + 1 MOD length WHERE userName = '" + userName + "';" ; String delQuery = "DELETE LogIn FROM LogIn JOIN History ON(LogIn.hid = History.hid) WHERE LogIn.index = ((History.lastLoginIndex + 1) MOD length) AND History.userName = '" + userName + "';" ; String query = "INSERT INTO LogIn(hid  ip  month  day  year  `index`  hours  minutes)" + " SELECT hid  INET_ATON('" + origin . getHostAddress ( ) + "')  " + time . getMonth ( ) + "  " + time . getDate ( ) + "  " + time . getYear ( ) + "  lastLoginIndex MOD length  " + time . getHours ( ) + "  " + time . getMinutes ( ) + " " + "FROM History " + "WHERE userName = '" + userName + "';" ; try { connect ( ) ; Statement stmt = connection . createStatement ( ) ; stmt . executeUpdate ( delQuery ) ; connection . setAutoCommit ( false ) ; stmt . executeUpdate ( incQuery ) ; stmt . executeUpdate ( query ) ; connection . commit ( ) ; ret = true ; } catch ( SQLException e ) { e . printStackTrace ( ) ; ret = false ; try { if ( connection != null ) connection . rollback ( ) ; } catch ( SQLException e1 ) { e1 . printStackTrace ( ) ; } } finally { if ( connection != null ) try { connection . setAutoCommit ( true ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; } } return ret ; }
tr	2	private String [ ] parseImgNames ( File inFile ) { String [ ] imgStingTemp = new String [ 0 ] ; if ( inFile . isDirectory ( ) ) { File [ ] curDirectory = inFile . listFiles ( ) ; imgStingTemp = new String [ curDirectory . length ] ; for ( int i = 0 ; i < curDirectory . length ; i ++ ) { imgStingTemp [ i ] = curDirectory [ i ] . getName ( ) ; } } return imgStingTemp ; }
tr	2	public static IOSIcons createOSIcons ( IOSIconsAdapter adapter ) { IOSIcons osIcons ; if ( OSDetector . isWindows ( ) ) { osIcons = adapter . getWindows ( ) ; } else if ( OSDetector . isMac ( ) ) { osIcons = adapter . getMac ( ) ; } else { osIcons = adapter . getLinux ( ) ; } return osIcons ; }
tr	6	private void persist ( PersistAction persistAction , String successMessage ) { if ( selected != null ) { setEmbeddableKeys ( ) ; try { if ( persistAction != PersistAction . DELETE ) { getFacade ( ) . edit ( selected ) ; } else { getFacade ( ) . remove ( selected ) ; } JsfUtil . addSuccessMessage ( successMessage ) ; } catch ( EJBException ex ) { String msg = "" ; Throwable cause = ex . getCause ( ) ; if ( cause != null ) { msg = cause . getLocalizedMessage ( ) ; } if ( msg . length ( ) > 0 ) { JsfUtil . addErrorMessage ( msg ) ; } else { JsfUtil . addErrorMessage ( ex , ResourceBundle . getBundle ( "/resoruces/Bundle" ) . getString ( "PersistenceErrorOccured" ) ) ; } } catch ( Exception ex ) { Logger . getLogger ( this . getClass ( ) . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; JsfUtil . addErrorMessage ( ex , ResourceBundle . getBundle ( "/resoruces/Bundle" ) . getString ( "PersistenceErrorOccured" ) ) ; } } }
tr	6	LatexExporter ( Component parent , List < FontHandle > fonts , JFileChooser chooser ) { if ( chooser != null ) { mChooser = chooser ; } else { String path = System . getProperty ( "user.home" ) ; if ( path != null ) { File file = new File ( path , "Desktop" ) ; if ( ! file . exists ( ) ) { file = new File ( path ) ; } mChooser = new JFileChooser ( file ) ; } else { mChooser = new JFileChooser ( ) ; } } mFamilyLabel = new JLabel ( "Name" ) ; mFamilyLabel . setHorizontalAlignment ( JLabel . RIGHT ) ; mFamilyField = new JTextField ( "" ) ; mNoticeLabel = new JLabel ( "Note that Latex maps \"\\textbf\"\nto BOLD_EXTENDED  not BOLD." ) ; add ( mFamilyLabel ) ; add ( mFamilyField ) ; add ( mNoticeLabel ) ; mFontStacker = new ComponentStacker ( ) ; mFontStacker . setStackDirection ( ComponentStacker . STACK_VERTICAL ) ; mFontStacker . setStretch ( true ) ; mFontStacker . setMargins ( 0 , 0 ) ; mFontStacker . setBorder ( BorderFactory . createTitledBorder ( "Fonts" ) ) ; mFontStacker . setBackground ( Color . WHITE ) ; add ( mFontStacker ) ; int i = 0 ; mFontPanels = new ArrayList < FontPanel > ( ) ; for ( FontHandle f : fonts ) { FontPanel p = new FontPanel ( f ) ; p . setSize ( 50 , 75 ) ; if ( i ++ % 2 == 0 ) { p . setBackground ( Palette . ODD_COLOR ) ; } else { p . setBackground ( Palette . EVEN_COLOR ) ; } mFontStacker . add ( p ) ; mFontPanels . add ( p ) ; } while ( parent . getParent ( ) != null ) { parent = parent . getParent ( ) ; } mCancelButton = new JButton ( "Cancel" ) ; mOkButton = new JButton ( "OK" ) ; add ( mCancelButton ) ; add ( mOkButton ) ; mCancelButton . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { doCancel ( ) ; } } ) ; mOkButton . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { doOkay ( ) ; } } ) ; setLayout ( new Layout ( ) ) ; setOpaque ( true ) ; mDialog = new JDialog ( ( Window ) parent , "Configure Tex Typeface" , ModalityType . APPLICATION_MODAL ) ; mDialog . setContentPane ( this ) ; mDialog . setSize ( 550 , 650 ) ; mDialog . setLocationRelativeTo ( null ) ; mDialog . setVisible ( true ) ; }
tr	0	public int toInt ( ) { return mInt ; }
tr	6	private void initialize ( ) { mnButtons = new HashMap < MenuContent , JMenu > ( ) ; mnItems = new HashMap < MenuItem , JMenuItem > ( ) ; for ( final MenuContent menu : MenuContent . values ( ) ) { final JMenu mnButton = new JMenu ( Window . geti18nString ( menu . getSection ( ) ) ) ; mnButtons . put ( menu , mnButton ) ; add ( mnButton ) ; final List < MenuItem > items = menu . getItems ( ) ; for ( final MenuItem item : items ) { final JMenuItem mnItem = new ExtJMenuItem ( Window . geti18nString ( item . getName ( ) ) , parent ) ; mnItems . put ( item , mnItem ) ; mnButton . add ( mnItem ) ; try { switch ( menu ) { case FILE : mnItem . addActionListener ( new FileButtonsListener ( item ) ) ; break ; case EDIT : mnItem . addActionListener ( new EditButtonsListener ( item ) ) ; break ; case ABOUT : mnItem . addActionListener ( new AboutButtonActionListener ( ) ) ; break ; } } catch ( final IllegalParametrs e ) { e . printStackTrace ( ) ; } } } }
tr	3	@ Subscribe public void unitCommand ( UnitCommandEvent e ) { if ( System . currentTimeMillis ( ) - lastCmdSnd < CMD_SND_DELAY ) { return ; } UnitCommand cmd = e . getCommand ( ) ; int snd ; if ( cmd . getType ( ) == UnitCommandType . MOVE ) { snd = ( int ) ( Math . random ( ) * 4 ) ; playSound ( "go" + snd + ".wav" , 0.8f ) ; } else if ( cmd . getType ( ) . isAttack ( ) ) { snd = ( int ) ( Math . random ( ) * 2 ) ; playSound ( "attack" + snd + ".wav" , 0.8f ) ; } lastCmdSnd = System . currentTimeMillis ( ) ; }
tr	8	private void scoreRound ( ) { HashMap < String , ArrayList < Integer >> theScores = new HashMap < String , ArrayList < Integer >> ( ) ; ArrayList < Integer > pars = new ArrayList < Integer > ( ) ; ArrayList < Integer > score = new ArrayList < Integer > ( ) ; for ( int column = 1 ; column < tblScorecard . getColumnCount ( ) ; column ++ ) { score = new ArrayList < Integer > ( ) ; for ( int row = 0 ; row < currentCourse . getNumberOfHoles ( ) ; row ++ ) { Object obj = tblScorecard . getModel ( ) . getValueAt ( row , column ) ; int cell = 0 ; if ( obj instanceof Integer ) { cell = ( int ) obj ; } else { cell = Integer . parseInt ( ( String ) obj ) ; } if ( column == 1 ) { pars . add ( cell ) ; } else { score . add ( cell ) ; } } String username = ( String ) tblScorecard . getColumnModel ( ) . getColumn ( column ) . getHeaderValue ( ) ; if ( column != 1 ) { theScores . put ( username , score ) ; } } Scorecard scorecard = new Scorecard ( currentCourse . getName ( ) , theScores , pars ) ; HashMap < String , ScorecardSummary > summaries = scorecard . getSummaries ( ) ; for ( String player : summaries . keySet ( ) ) { if ( Manager . getInstance ( ) . getProfiles ( ) . containsKey ( player ) ) { Manager . getInstance ( ) . getProfiles ( ) . get ( player ) . updateFromScorecard ( summaries . get ( player ) ) ; System . out . println ( Manager . getInstance ( ) . getProfiles ( ) . get ( player ) . getProfileSummary ( ) ) ; } else { int reply = JOptionPane . showConfirmDialog ( null , "No profile was found for " + player + "  would you like to create one?" , "Profile not found" , JOptionPane . YES_NO_OPTION ) ; if ( reply == JOptionPane . YES_OPTION ) { java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { new NewProfile ( ) . setVisible ( true ) ; } } ) ; } } } clearScorecard ( ) ; }
tr	5	public static void sort ( int [ ] a ) { int N = a . length ; int h = 1 ; while ( h < N / 3 ) h = 3 * h + 1 ; while ( h >= 1 ) { for ( int i = h ; i < N ; i ++ ) { for ( int j = i ; j >= h && less ( a [ j ] , a [ j - h ] ) ; j -= h ) { exchange ( a , j , j - h ) ; } } assert isHsorted ( a , h ) ; h /= 3 ; } assert isSorted ( a ) ; }
tr	6	@ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; Cohort other = ( Cohort ) obj ; if ( yearOfAdmission == null ) { if ( other . yearOfAdmission != null ) return false ; } else if ( ! yearOfAdmission . equals ( other . yearOfAdmission ) ) return false ; return true ; }
tr	4	public JSONWriter key ( String string ) throws JSONException { if ( string == null ) { throw new JSONException ( "Null key." ) ; } if ( this . mode == k ) { try { this . stack [ this . top - 1 ] . putOnce ( string , boolean . true ) ; if ( this . , ) { this . writer . write (   ) ; } this . writer . write ( JSONObject . quote ( string ) ) ; this . writer . write ( : ) ; this . , = false ; this . mode = o ; return this ; } catch ( IOException e ) { throw new JSONException ( e ) ; } } throw new JSONException ( "Misplaced key." ) ; }
tr	4	public void printBoard ( ) { int rowEnd = g . getBoard ( ) . numRows ; int colEnd = g . getBoard ( ) . numColumns ; System . out . println ( "{" ) ; for ( int j = 0 ; j < rowEnd ; j ++ ) { System . out . print ( "{ " ) ; for ( int i = 0 ; i < colEnd ; i ++ ) { System . out . printf ( "%1d " , g . getBoard ( ) . getGameGrid ( ) [ i ] [ j ] . getState ( ) ) ; if ( ! ( i == colEnd - 1 ) ) { System . out . print ( " " ) ; } } System . out . print ( " }" ) ; if ( ! ( j == rowEnd - 1 ) ) { System . out . println ( " " ) ; } else { System . out . println ( ) ; } } System . out . println ( "}" ) ; }
tr	9	private void move ( ACTION action2 ) { int newposX = posX ; int newposY = posY ; System . out . println ( "pos:" + posX / 32 + ":" + posY / 32 ) ; if ( currentAction == action2 ) { showFrame = ( showFrame + 1 ) % 9 ; } else { showFrame = 0 ; } switch ( action2 ) { case GODOWN : newposY = ( int ) ( posY + spead ) ; facing = DIRECTION . SOUTH ; break ; case GOUP : facing = DIRECTION . NORTH ; newposY = ( int ) ( posY - spead ) ; break ; case GOLEFT : newposX = ( int ) ( posX - spead ) ; facing = DIRECTION . WEST ; break ; case GORIGTH : newposX = ( int ) ( posX + spead ) ; facing = DIRECTION . EAST ; break ; case RUNUP : facing = DIRECTION . NORTH ; newposY = ( int ) ( posY - ( spead * 3 ) ) ; break ; case RUNDOWN : newposY = ( int ) ( posY + ( spead * 3 ) ) ; facing = DIRECTION . SOUTH ; break ; case RUNRIGTH : newposX = ( int ) ( posX + ( spead * 3 ) ) ; facing = DIRECTION . EAST ; break ; case RUNLEFT : newposX = ( int ) ( posX - ( spead * 3 ) ) ; facing = DIRECTION . WEST ; break ; default : break ; } if ( GameModel . GetWorldMap ( ) . checkPositionIsOk ( newposX + 16 , newposY + 46 , newposX + 44 , newposY + 64 - 5 ) ) { posX = newposX ; posY = newposY ; } }
tr	2	public String getLongVersion ( ) { if ( false == "UNKNOWN" . equals ( getName ( ) ) && false == "UNKNOWN" . equals ( getVersion ( ) ) ) { return String . format ( "<info>%s</info> version <comment>%s</comment>" , getName ( ) , getVersion ( ) ) ; } return "<info>Console Tool</info>" ; }
tr	7	protected INDIProperty ( INDIDriver driver , String name , String label , String group , PropertyStates state , PropertyPermissions permission , int timeout ) throws IllegalArgumentException { this . driver = driver ; if ( name == null ) { throw new IllegalArgumentException ( "No name for the Property" ) ; } name = name . trim ( ) ; if ( name . length ( ) == 0 ) { throw new IllegalArgumentException ( "No name for the Property" ) ; } this . name = name ; if ( label == null ) { this . label = name ; } else { label = label . trim ( ) ; if ( label . length ( ) == 0 ) { this . label = name ; } else { this . label = label ; } } if ( group == null ) { group = "Unsorted" ; } group = group . trim ( ) ; if ( group . length ( ) == 0 ) { group = "Unsorted" ; } this . group = group ; this . state = state ; this . permission = permission ; if ( timeout < 0 ) { this . timeout = 0 ; } else { this . timeout = timeout ; } this . elements = new LinkedHashMap < String , INDIElement > ( ) ; this . saveable = false ; isInit = false ; }
tr	8	private boolean r_postlude ( ) { int among_var ; int v_1 ; replab0 : while ( true ) { v_1 = cursor ; lab1 : do { bra = cursor ; among_var = find_among ( a_0 , 3 ) ; if ( among_var == 0 ) { break lab1 ; } ket = cursor ; switch ( among_var ) { case 0 : break lab1 ; case 1 : slice_from ( "i" ) ; break ; case 2 : slice_from ( "u" ) ; break ; case 3 : if ( cursor >= limit ) { break lab1 ; } cursor ++ ; break ; } continue replab0 ; } while ( false ) ; cursor = v_1 ; break replab0 ; } return true ; }
tr	8	@ Override public void paint ( Graphics g ) { int thisWidth = getWidth ( ) ; int thisHeight = getHeight ( ) ; g . setColor ( Color . BLACK ) ; g . fillRect ( 0 , 0 , thisWidth , thisHeight ) ; if ( image == null ) return ; Graphics2D g2 = ( Graphics2D ) g ; final int renderedWidth ; final int renderedHeight ; Dimension renderedDim = getRenderedDimension ( image , thisWidth , thisHeight ) ; renderedWidth = renderedDim . width ; renderedHeight = renderedDim . height ; int left = ( thisWidth - renderedWidth ) / 2 ; int top = ( thisHeight - renderedHeight ) / 2 ; if ( scaledImages . get ( photo ) == null || scaledImages . get ( photo ) . get ( ) == null || scaledImages . get ( photo ) . get ( ) . getWidth ( null ) != renderedWidth || scaledImages . get ( photo ) . get ( ) . getHeight ( null ) != renderedHeight ) { scaledImages . remove ( photo ) ; scalrThreadExecutor . submit ( new ScalePhotoThread ( photo , renderedWidth , renderedHeight ) ) ; } if ( scaledImages . get ( photo ) != null && scaledImages . get ( photo ) . get ( ) != null ) g . drawImage ( scaledImages . get ( photo ) . get ( ) , left , top , null ) ; else g . drawImage ( this . image , left , top , renderedWidth , renderedHeight , null ) ; if ( ! flickrFrame . isFullscreen ( ) ) { g . setColor ( Color . GRAY ) ; g . setFont ( ComponentDecorator . FONT_SMALL ) ; String count = ( currentIndex + 1 ) + " / " + photos . size ( ) ; g . drawString ( count , BORDER_SIZE , thisHeight - 16 ) ; int titleWidth = g . getFontMetrics ( ) . stringWidth ( photos . get ( currentIndex ) . title ) ; g . drawString ( photos . get ( currentIndex ) . title , thisWidth - BORDER_SIZE - titleWidth , thisHeight - 16 ) ; } }
tr	4	public void startGame ( long noPlayers ) throws MenuException { if ( noPlayers != 1 && noPlayers != 2 ) { throw new MenuException ( ErrorType . ERROR105 . getMessage ( ) ) ; } Game game ; try { if ( noPlayers == 1 ) { game = this . createGame ( GameType . ONE_PLAYER ) ; } else { game = this . createGame ( GameType . TWO_PLAYER ) ; } } catch ( MenuException ex ) { throw ex ; } GameFrame gamePlayFrame = new GameFrame ( game ) ; gamePlayFrame . setVisible ( true ) ; }
tr	0	@ Override public void Lands ( Player P ) { }
tr	9	public static String msToString ( long ms ) { long days = TimeUnit . MILLISECONDS . toDays ( ms ) ; long hours = TimeUnit . MILLISECONDS . toHours ( ms ) % 24 ; long minutes = TimeUnit . MILLISECONDS . toMinutes ( ms ) % 60 ; long seconds = TimeUnit . MILLISECONDS . toSeconds ( ms ) % 60 ; StringBuffer sb = new StringBuffer ( ) ; boolean secondsCondition = true ; boolean minutesCondition = seconds != 0 ; boolean hoursCondition = minutes != 0 || minutesCondition ; boolean daysCondition = hours != 0 || hoursCondition ; boolean usedDays = appendToBuffer ( sb , days , "%d day" + ( days != 1 ? "s" : "" ) + "  " , daysCondition ) ; boolean usedHours = appendToBuffer ( sb , hours , "%d hour" + ( hours != 1 ? "s" : "" ) + "  " , hoursCondition ) ; boolean usedMinutes = appendToBuffer ( sb , minutes , "%d minute" + ( minutes != 1 ? "s" : "" ) + "  " , minutesCondition ) ; appendToBuffer ( sb , seconds , "%d second" + ( seconds != 1 ? "s" : "" ) , secondsCondition ) ; String timeStamp = sb . toString ( ) ; if ( usedDays ) return String . format ( timeStamp , days , hours , minutes , seconds ) ; if ( usedHours ) return String . format ( timeStamp , hours , minutes , seconds ) ; if ( usedMinutes ) return String . format ( timeStamp , minutes , seconds ) ; return String . format ( timeStamp , seconds ) ; }
tr	7	@ Test public void consistency ( ) { System . out . println ( "[UNITTEST] ***** TEST: Ontology consistency checking *****" ) ; IOntologyBackend onto = new OpenRobotsOntology ( conf ) ; BaseModule oro = new BaseModule ( onto ) ; assertTrue ( "Initial ontology should be detected as consistent!" , oro . checkConsistency ( ) ) ; try { Statement s = onto . createStatement ( "cow rdf:type Plant" ) ; onto . add ( s , MemoryProfile . default , false ) ; } catch ( IllegalStatementException e ) { fail ( "Error while adding a set of statements in testConsistency!" ) ; } assertFalse ( "Ontology should be detected as inconsistent! Cows are not plants!" , oro . checkConsistency ( ) ) ; Set < String > stmtsToRemove = new HashSet < String > ( ) ; try { stmtsToRemove . add ( "cow rdf:type Plant" ) ; oro . clear ( stmtsToRemove ) ; assertTrue ( oro . checkConsistency ( ) ) ; } catch ( IllegalStatementException e ) { fail ( ) ; } catch ( OntologyServerException e ) { e . printStackTrace ( ) ; } try { onto . add ( onto . createStatement ( "cow climbsOn banana_tree" ) , MemoryProfile . default , false ) ; assertFalse ( "Ontology should be detected as inconsistent! Cows can not climb on banana trees because they are explicitely not monkeys!" , oro . checkConsistency ( ) ) ; stmtsToRemove . clear ( ) ; stmtsToRemove . add ( "cow climbsOn banana_tree" ) ; oro . clear ( stmtsToRemove ) ; assertTrue ( "Ontology should now be back to consistency" , oro . checkConsistency ( ) ) ; } catch ( IllegalStatementException e ) { fail ( "Error while adding a set of statements in testConsistency!" ) ; } catch ( OntologyServerException e ) { fail ( ) ; } Set < String > updatedStmts = new HashSet < String > ( ) ; try { updatedStmts . add ( "gorilla age 12" ) ; updatedStmts . add ( "gorilla weight 100.2" ) ; oro . clear ( updatedStmts ) ; assertTrue ( "The 'clear' was not successful: a functional property has now 2 values." , oro . checkConsistency ( ) ) ; updatedStmts . clear ( ) ; updatedStmts . add ( "gorilla age 21" ) ; updatedStmts . add ( "gorilla weight 99.5" ) ; oro . add ( updatedStmts ) ; assertTrue ( "'add' shouldn't cause any inconsistency  since previous statements have been cleared." , oro . checkConsistency ( ) ) ; } catch ( IllegalStatementException e ) { fail ( ) ; } catch ( OntologyServerException e ) { fail ( ) ; } System . out . println ( "[UNITTEST] ***** Test successful *****" ) ; }
tr	4	@ Test public void testTokenPayment ( ) { Gateway beanstream = new Gateway ( "v1" , 300200578 , "4BaD82D9197b4cc4b70a221911eE9f70" ) ; HttpsConnector connector = new HttpsConnector ( 300200578 , "4BaD82D9197b4cc4b70a221911eE9f70" ) ; LegatoTokenRequest legatoTokenRequest = new LegatoTokenRequest ( ) ; legatoTokenRequest . number = "5100000010001004" ; legatoTokenRequest . expiryMonth = 12 ; legatoTokenRequest . expiryYear = 18 ; legatoTokenRequest . cvd = "123" ; String url = "https://www.beanstream.com/scripts/tokenization/tokens" ; String output = "" ; try { output = connector . ProcessTransaction ( HttpMethod . post , url , legatoTokenRequest ) ; } catch ( BeanstreamApiException ex ) { Logger . getLogger ( SampleTransactions . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; assert . fail ( ex . getMessage ( ) ) ; } Gson gson = new Gson ( ) ; LegatoTokenResponse tokenResponse = gson . fromJson ( output , LegatoTokenResponse . class ) ; System . out . println ( "token: " + output ) ; TokenPaymentRequest tokenReq = new TokenPaymentRequest ( ) ; tokenReq . setAmount ( 100.00 ) ; tokenReq . setOrderNumber ( getRandomOrderId ( "token" ) ) ; tokenReq . getToken ( ) . setName ( "John Doe" ) . setCode ( tokenResponse . getToken ( ) ) ; try { PaymentResponse response = beanstream . payments ( ) . makePayment ( tokenReq ) ; System . out . println ( "Token Payment Approved? " + response . isApproved ( ) ) ; } catch ( BeanstreamApiException ex ) { Logger . getLogger ( this . getClass ( ) . getName ( ) ) . log ( Level . SEVERE , "An error occurred" , ex ) ; assert . fail ( ex . getMessage ( ) ) ; } try { output = connector . ProcessTransaction ( HttpMethod . post , url , legatoTokenRequest ) ; } catch ( BeanstreamApiException ex ) { Logger . getLogger ( SampleTransactions . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; assert . fail ( ex . getMessage ( ) ) ; } tokenResponse = gson . fromJson ( output , LegatoTokenResponse . class ) ; System . out . println ( "Token pre-auth: " + tokenResponse . getToken ( ) ) ; TokenPaymentRequest req = new TokenPaymentRequest ( ) ; req . setAmount ( 80.00 ) ; req . setOrderNumber ( getRandomOrderId ( "token" ) ) ; req . getToken ( ) . setName ( "John Doe" ) . setCode ( tokenResponse . getToken ( ) ) ; try { PaymentResponse response = beanstream . payments ( ) . preAuth ( req ) ; System . out . println ( "Token Payment Approved? " + response . isApproved ( ) ) ; response = beanstream . payments ( ) . preAuthCompletion ( response . id , 55.30 ) ; assert . assertTrue ( response . isApproved ( ) ) ; assert . assertEquals ( "PAC" , response . type ) ; } catch ( BeanstreamApiException ex ) { Logger . getLogger ( this . getClass ( ) . getName ( ) ) . log ( Level . SEVERE , "An error occurred" , ex ) ; assert . fail ( ex . getMessage ( ) ) ; } }
tr	2	@ Override public void visit ( FSP_AndJoin g ) { dot_program . append ( "\t" + g . name ( ) + "[shape=triangle  color=red];\n" ) ; for ( int i = 0 ; i < g . all_names ( ) . size ( ) ; i ++ ) { String nm = g . all_names ( ) . get ( i ) ; FSPLink l = g . get_link ( nm ) ; if ( l != null ) { dot_program . append ( "\t" + g . name ( ) + "->" + l . name ( ) + "[label=" + nm . replace ( [ , _ ) . replace ( ] , _ ) + "];\n" ) ; } } }
tr	4	private void parseDisplayBPM ( String bpmValues , SimFile accumulator ) { final String [ ] bpmCodes = bpmValues . split ( " " ) ; double min = Integer . MAX_VALUE ; String minText = "" ; double max = Integer . MIN_VALUE ; String maxText = "" ; for ( String bpmCode : bpmCodes ) { String bpmText = bpmCode . substring ( bpmCode . indexOf ( = ) + 1 ) ; double bpm = double . parseDouble ( bpmText ) ; if ( bpm < min ) { min = bpm ; minText = bpmText ; } if ( bpm > max ) { max = bpm ; maxText = bpmText ; } } String displayBPM ; if ( max == min ) { displayBPM = minText ; } else { displayBPM = minText + " - " + maxText ; } accumulator . setDisplayBPM ( displayBPM ) ; }
tr	0	public void clear ( ) { listModel . clear ( ) ; }
tr	9	public static int SentsToSQL ( File input ) { if ( ! input . exists ( ) ) return 0 ; ArrayList < SentenceEntry > res = new ArrayList < SentenceEntry > ( ) ; ArrayList < String > validation = new ArrayList < String > ( ) ; try { BufferedReader buReader = new BufferedReader ( new InputStreamReader ( new FileInputStream ( input ) , "UTF-8" ) ) ; String tmp = "" ; double currating = - 1 ; int revIndex = 0 ; for ( String s = buReader . readLine ( ) ; s != null ; s = buReader . readLine ( ) ) { if ( s . startsWith ( "###" ) ) { if ( tmp . length ( ) == 0 ) { currating = double . valueOf ( s . split ( "\t" ) [ 3 ] ) ; continue ; } ArrayList < String > sentences = SentenceSplitter . getInstance ( ) . sentence_split ( tmp ) ; validation . addAll ( sentences ) ; for ( String sent : sentences ) { SentenceEntry curSent = new SentenceEntry ( sent , sentsCounter , input . getName ( ) ) ; curSent . RevIndex = revIndex ; curSent . RevRating = currating ; sentsCounter ++ ; res . add ( curSent ) ; } revIndex ++ ; tmp = "" ; if ( s . split ( "\t" ) . length != 13 ) { System . out . println ( s . split ( "\t" ) . length + "\t" + s ) ; currating = 4.0 ; } else { currating = double . valueOf ( s . split ( "\t" ) [ 3 ] ) ; } } else { tmp += s ; } } if ( ! tmp . isEmpty ( ) ) { ArrayList < String > sentences = SentenceSplitter . getInstance ( ) . sentence_split ( tmp ) ; for ( String sent : sentences ) { SentenceEntry curSent = new SentenceEntry ( sent , sentsCounter , input . getName ( ) ) ; curSent . RevIndex = revIndex ; curSent . RevRating = currating ; sentsCounter ++ ; res . add ( curSent ) ; } validation . addAll ( sentences ) ; tmp = "" ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } for ( SentenceEntry sentEntry : res ) { String sql = "INSERT INTO sentences (sent_index   sent_txt   revindex   revrating  filename )" + " VALUES ( " + sentEntry . UniqueID + "  '" + TextUtil . Encode ( sentEntry . get_senttxt ( ) ) + "'  " + sentEntry . RevIndex + "   " + sentEntry . RevRating + "  '" + TextUtil . Encode ( sentEntry . FileName ) + "');" ; db1 . executeUpdateSQL ( sql ) ; } System . err . println ( "% end..." + sentsCounter + "\t" + validation . size ( ) + "." ) ; return sentsCounter ; }
tr	2	@ Override public void insertContent ( int pos , Line line ) { if ( pos > this . length ( ) || pos < 0 ) { throw new DocumentException ( "Impossible to insert something in this line at this position!" ) ; } this . getContent ( ) . insert ( pos , line . getContent ( ) ) ; }
tr	6	private boolean find_object ( String name , FSPNet current_net , LinkedList < String > prefix ) { boolean found = false ; for ( Entry < String , FSPAtom > e : current_net . components ( ) . entrySet ( ) ) { if ( e . getValue ( ) instanceof FSPAbstractTask ) { FSPAbstractTask t = ( FSPAbstractTask ) e . getValue ( ) ; if ( t . name ( ) . compareTo ( name ) == 0 ) { found = true ; break ; } else { if ( t . decomposesTo ( ) != null ) { prefix . push ( e . getKey ( ) ) ; if ( ! find_object ( name , t . decomposesTo ( ) , prefix ) ) { prefix . pop ( ) ; } else { break ; } } } } else { if ( e . getValue ( ) . name ( ) . compareTo ( name ) == 0 ) assert false ; } } return found ; }
tr	5	private boolean checkValidInput ( List < PlayerInputData > playerData ) { Set < String > names = new HashSet < String > ( ) ; Set < Color > colours = new HashSet < Color > ( ) ; try { for ( PlayerInputData p : playerData ) { if ( p . name . equals ( "" ) ) { throw new IllegalArgumentException ( "No name provided" ) ; } if ( names . contains ( p . name ) ) { throw new IllegalArgumentException ( "Non-unique name" ) ; } if ( colours . contains ( p . colour ) ) { throw new IllegalArgumentException ( "Non-unique name" ) ; } names . add ( p . name ) ; colours . add ( p . colour ) ; } } catch ( IllegalArgumentException e ) { return false ; } return true ; }
tr	7	public void paintComponent ( Graphics g ) { super . paintComponent ( g ) ; Graphics2D g2d = ( Graphics2D ) g ; g2d . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; Stroke defaultStroke = g2d . getStroke ( ) ; Stroke fatStroke = new BasicStroke ( 2 ) ; if ( state == null ) return ; for ( Country country : state . getCountries ( ) ) { Color fillColor = country . getPlayer ( ) . getColor ( ) ; if ( highlights . size ( ) != 0 && ! highlights . contains ( country ) ) fillColor = new Color ( fillColor . getRed ( ) , fillColor . getGreen ( ) , fillColor . getBlue ( ) , 96 ) ; g2d . setStroke ( highlights . contains ( country ) ? fatStroke : defaultStroke ) ; Hexagon center = findCentermostHexagon ( country . getHexagons ( ) ) ; for ( Hexagon hexagon : country . getHexagons ( ) ) drawHexagon ( g2d , country , hexagon , hexagon . equals ( center ) ? fillColor . darker ( ) : fillColor ) ; drawDiceOnHexagon ( g2d , country . getDice ( ) , center ) ; } }
tr	1	void dispatch ( SelectionKey key ) { Runnable r = ( Runnable ) key . attachment ( ) ; if ( r != null ) { r . run ( ) ; } }
tr	3	@ SuppressWarnings ( "unchecked" ) public T nextConcrete ( ) { T genObj = null ; try { initFieldGenerators ( ) ; genObj = ( T ) Utils . getDummyObject ( this . type ) ; Reflector r1 = new Reflector ( genObj ) ; Field [ ] fields = r1 . getFields ( genObj ) ; for ( Field f : fields ) { f . set ( genObj , fieldGenerators . get ( f ) . next ( ) ) ; } } catch ( InstantiationException e ) { e . printStackTrace ( ) ; } catch ( IllegalAccessException e ) { e . printStackTrace ( ) ; } return genObj ; }
