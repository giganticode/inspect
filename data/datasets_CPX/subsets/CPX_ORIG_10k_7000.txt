va	0	public jedi . db . models . query . QuerySet < Emprestimo > getEmprestimoSet ( ) { return Emprestimo . objects . getSet ( Servidor . class , this . id ) ; }
va	5	public Object clone ( ) throws CloneNotSupportedException { Update result = ( Update ) super . clone ( ) ; if ( result . create != null ) { result . create = ( Create ) this . create . clone ( ) ; result . create . setParent ( result ) ; } if ( result . delete != null ) { result . delete = ( Delete ) this . delete . clone ( ) ; result . delete . setParent ( result ) ; } if ( result . change != null ) { result . change = new ArrayList ( ) ; for ( Iterator iter = this . change . iterator ( ) ; iter . hasNext ( ) ; ) { Change element = ( Change ) iter . next ( ) ; Change elementClone = ( Change ) element . clone ( ) ; elementClone . setParent ( result ) ; result . change . add ( elementClone ) ; } } if ( result . replace != null ) { result . replace = ( Replace ) this . replace . clone ( ) ; result . replace . setParent ( result ) ; } return result ; }
va	2	public void importQuote ( ) throws SQLException { String json = null ; try { json = readUrl ( "http://dist-sso.it-kartellet.dk/quote/" ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } quote = ( QuoteObject ) gson . fromJson ( json , QuoteObject . class ) ; String [ ] fields = { "quote" , "author" , "topic" , "lastupdate" } ; String [ ] values = { quote . getQuote ( ) , quote . getAuthor ( ) , quote . getTopic ( ) , String . valueOf ( date . getTime ( ) ) } ; resultSet = qb . selectFrom ( "quote" ) . all ( ) . ExecuteQuery ( ) ; if ( resultSet . next ( ) ) { qb . update ( "quote" , fields , values ) . where ( "quoteid" , "=" , "1" ) . Execute ( ) ; } else { qb . insertInto ( "quote" , fields ) . values ( values ) . Execute ( ) ; } }
va	7	@ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( ! super . equals ( obj ) ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; ID3v2PopmFrameData other = ( ID3v2PopmFrameData ) obj ; if ( address == null ) { if ( other . address != null ) return false ; } else if ( ! address . equals ( other . address ) ) return false ; if ( rating != other . rating ) return false ; return true ; }
va	2	public String jsUrlParam ( Map < String , String > map ) { StringBuilder buffer = new StringBuilder ( ) ; boolean first = true ; for ( Map . Entry < String , String > param : map . entrySet ( ) ) { if ( ! first ) { buffer . append ( "&" ) ; } buffer . append ( jsUrlEncode ( param . getKey ( ) ) ) ; buffer . append ( "=" ) ; buffer . append ( jsUrlEncode ( param . getValue ( ) ) ) ; first = false ; } return buffer . toString ( ) ; }
va	6	private void setBtnAlta ( ) { btnAlta . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent ae ) { try { if ( "" . equals ( txtNom . getText ( ) ) ) { throw new NullPointerException ( ) ; } objFI . altaEstacion ( txtNom . getText ( ) , Integer . parseInt ( comboCP . getSelectedItem ( ) . toString ( ) ) ) ; JOptionPane . showMessageDialog ( lblCP , "Operaci\u00F3n Exitosa" ) ; try { setTableEstaciones ( ) ; } catch ( ParseException ex ) { Logger . getLogger ( MantenimientoEstacion . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } } catch ( NoExisteCPException | NombreRepetidoException ex ) { JOptionPane . showMessageDialog ( rootPane , ex . getMessage ( ) ) ; } catch ( NumberFormatException ex ) { if ( "" . equals ( comboCP . getSelectedItem ( ) . toString ( ) ) ) { JOptionPane . showMessageDialog ( rootPane , "No se ha ingresado el codigo postal" , null , WIDTH ) ; } else { JOptionPane . showMessageDialog ( rootPane , "El codigo postal posee un formato incorrecto" , null , WIDTH ) ; } } catch ( NullPointerException ex ) { JOptionPane . showMessageDialog ( rootPane , "No se ha ingresado nombre de la estaci\u00F3n" ) ; } } } ) ; }
va	8	public static void corner ( Component comp , final byte CORNER ) { screenOffset ( ) ; Rectangle DEST ; switch ( CORNER ) { default : case TOP_LEFT : DEST = new Rectangle ( offset , 0 , ( int ) comp . getSize ( ) . getWidth ( ) , ( int ) comp . getSize ( ) . getHeight ( ) ) ; break ; case TOP_RIGHT : DEST = new Rectangle ( ( int ) ( ( noOffset ? screenBounds : maxWinBounds ) . getWidth ( ) - comp . getSize ( ) . getWidth ( ) ) + offset , 0 , ( int ) comp . getSize ( ) . getWidth ( ) , ( int ) comp . getSize ( ) . getHeight ( ) ) ; break ; case BOTTOM_RIGHT : DEST = new Rectangle ( ( int ) ( ( noOffset ? screenBounds : maxWinBounds ) . getWidth ( ) - comp . getSize ( ) . getWidth ( ) ) + offset , ( int ) ( ( noOffset ? screenBounds : maxWinBounds ) . getHeight ( ) - comp . getSize ( ) . getHeight ( ) ) , ( int ) comp . getSize ( ) . getWidth ( ) , ( int ) comp . getSize ( ) . getHeight ( ) ) ; break ; case BOTTOM_LEFT : DEST = new Rectangle ( offset , ( int ) ( ( noOffset ? screenBounds : maxWinBounds ) . getHeight ( ) - comp . getSize ( ) . getHeight ( ) ) , ( int ) comp . getSize ( ) . getWidth ( ) , ( int ) comp . getSize ( ) . getHeight ( ) ) ; break ; } location ( comp , DEST ) ; }
va	3	public static ArrayList getAssistItems ( String textLeftOfCursor ) { ArrayList proposals = new ArrayList ( ) ; if ( textLeftOfCursor . endsWith ( "\\" ) ) { proposals . add ( new Proposal ( "\\A" , "Beginning input \\A" , 1 ) ) ; proposals . add ( new Proposal ( "\\b" , "Word boundary \\b" , 1 ) ) ; proposals . add ( new Proposal ( "\\B" , "Non-word boundary \\B" , 1 ) ) ; proposals . add ( new Proposal ( "\\d" , "Digit \\d" , 1 ) ) ; proposals . add ( new Proposal ( "\\D" , "Non-digit \\D" , 1 ) ) ; proposals . add ( new Proposal ( "\\G" , "End of previous match \\G" , 1 ) ) ; proposals . add ( new Proposal ( "\\n" , "Newline \\n" , 1 ) ) ; proposals . add ( new Proposal ( "\\r" , "Carriage-return \\r" , 1 ) ) ; proposals . add ( new Proposal ( "\\s" , "Whitespace \\s" , 1 ) ) ; proposals . add ( new Proposal ( "\\S" , "Non-whitespace \\S" , 1 ) ) ; proposals . add ( new Proposal ( "\\t" , "Tab \\t" , 1 ) ) ; proposals . add ( new Proposal ( "\\w" , "Word \\w" , 1 ) ) ; proposals . add ( new Proposal ( "\\W" , "Non-word \\W" , 1 ) ) ; proposals . add ( new Proposal ( "\\z" , "End of input \\z" , 1 ) ) ; } if ( textLeftOfCursor . endsWith ( "(?" ) ) { proposals . add ( new Proposal ( "(?:" , "Non-capturing group (?:" , 2 ) ) ; proposals . add ( new Proposal ( "(?=" , "Positive lookahead (?=" , 2 ) ) ; proposals . add ( new Proposal ( "(?!" , "Negative lookahead (?!" , 2 ) ) ; proposals . add ( new Proposal ( "(?<=" , "Positive lookbehind (?<=" , 2 ) ) ; proposals . add ( new Proposal ( "(?<!" , "Negative lookbehind (?<!" , 2 ) ) ; } if ( textLeftOfCursor . endsWith ( "[" ) ) { proposals . add ( new Proposal ( "[0-9]" , "[0-9]" , 1 ) ) ; proposals . add ( new Proposal ( "[a-z]" , "[a-z]" , 1 ) ) ; proposals . add ( new Proposal ( "[A-Z]" , "[A-Z]" , 1 ) ) ; proposals . add ( new Proposal ( "[a-zA-Z]" , "[a-zA-Z]" , 1 ) ) ; proposals . add ( new Proposal ( "[a-zA-Z0-9]" , "[a-zA-Z0-9]" , 1 ) ) ; } return proposals ; }
va	3	private void mainLoop ( ) { BufferedReader bf = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String sentence ; try { context . displayPrompt ( ) ; while ( ( sentence = bf . readLine ( ) ) != null ) { parser . parse ( sentence , context , context . getConsole ( ) ) ; context . displayPrompt ( ) ; } } catch ( IOException e ) { e . printStackTrace ( ) ; } catch ( EvaluationException e ) { e . printStackTrace ( ) ; } }
va	4	public static MapDescription getMapDescription ( File f ) { try { Scanner scan = new Scanner ( f ) ; String [ ] header = scan . nextLine ( ) . split ( " " ) ; int width = Integer . parseInt ( header [ 0 ] . trim ( ) ) ; int height = Integer . parseInt ( header [ 1 ] . trim ( ) ) ; int numPlayers = Integer . parseInt ( header [ 2 ] . trim ( ) ) ; StringBuilder map = new StringBuilder ( "\n" ) ; for ( int i = 0 ; i < height ; i ++ ) map . append ( "  " ) . append ( scan . nextLine ( ) ) . append ( "  \n" ) ; return new MapDescription ( f . getName ( ) , f . getAbsolutePath ( ) , numPlayers , width , height , map . toString ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } catch ( NumberFormatException e ) { e . printStackTrace ( ) ; } catch ( IndexOutOfBoundsException e ) { e . printStackTrace ( ) ; } return null ; }
va	4	@ Override public ByteBuffer getMessage ( ) { buffer . clear ( ) ; buffer . order ( ByteOrder . LITTLE_ENDIAN ) ; buffer . putShort ( ( short ) aaa6 ) ; buffer . putShort ( ( short ) 40 ) ; buffer . put ( ( byte ) 1 ) ; buffer . put ( ( byte ) 0 ) ; for ( short val : pwm ) { buffer . putShort ( val ) ; } for ( byte val : relay ) { buffer . put ( val ) ; } for ( byte val : solenoid ) { buffer . put ( val ) ; } for ( byte val : led ) { buffer . put ( val ) ; } buffer . put ( ( byte ) 0 ) ; short checksum = ( short ) Utilities . checksum ( buffer , 0 , 38 ) ; buffer . putShort ( checksum ) ; return buffer ; }
va	6	public void update ( ) { inUpdate = true ; workerList . setListData ( game . getWorkers ( ) ) ; workerList . setSelectedIndex ( game . getSelectedWorkerIndex ( ) - 1 ) ; moneyLabel . setText ( "Money: $" + Integer . toString ( game . getMoney ( ) ) ) ; renownLabel . setText ( "Notoriety: " + Integer . toString ( game . getRenown ( ) ) ) ; if ( game . getRenown ( ) < 10 ) { renownLabel . setForeground ( Color . RED ) ; } else if ( game . getRenown ( ) > 900 ) { renownLabel . setForeground ( Color . GREEN ) ; } else { renownLabel . setForeground ( Color . BLACK ) ; } Worker sel = game . getSelectedWorker ( ) ; if ( sel != null ) { add ( detailPanel , BorderLayout . SOUTH ) ; selectionNameLabel . setText ( sel . getName ( ) ) ; String status = "<html>" + sel . getJobDescription ( ) + "<br/><br/>" ; if ( sel . getJob ( ) != null && sel . getJob ( ) . getProgress ( ) != 0.0 ) status += "<b>Progress</b>: " + ( int ) ( sel . getJob ( ) . getProgress ( ) * 100 ) + "%</br>" ; if ( sel . getHolding ( ) != null ) status += "<b>Holding</b>: " + sel . getHolding ( ) . name + "<br/>" ; status += "</html>" ; selectionStatusLabel . setText ( status ) ; selectionCancelJobButton . setVisible ( sel . getJob ( ) != null ) ; } else { remove ( detailPanel ) ; } applet . validate ( ) ; inUpdate = false ; }
va	9	private static String getValue ( JSONTokener x ) throws JSONException { char c ; char q ; StringBuffer sb ; do { c = x . next ( ) ; } while ( c ==   || c == 	 ) ; switch ( c ) { case 0 : return null ; case " : case ' : q = c ; sb = new StringBuffer ( ) ; for ( ; ; ) { c = x . next ( ) ; if ( c == q ) { break ; } if ( c == 0 || c == '' || c == '' ) { throw x . syntaxError ( "Missing close quote '" + q + "'." ) ; } sb . append ( c ) ; } return sb . toString ( ) ; case   : x . back ( ) ; return "" ; default : x . back ( ) ; return x . nextTo (   ) ; } }
va	1	public void enablePartyMode ( ) { try { String sqlStatement = "UPDATE doors SET open = 'true'" ; statement . executeUpdate ( sqlStatement ) ; System . out . println ( "DOORS ARE OPEN!" ) ; } catch ( SQLException ex ) { System . out . println ( "Party mode activation failed" ) ; } }
va	3	public void cliqueDeclin ( ) { if ( etape == 0 && joueurEnCours . getPeupleDeclin ( ) == null && Game . getInstance ( ) . askConf ( "Confirmer le passage en d\u00E9clin ?" ) ) { tempEnDeclin = true ; setEtape ( 2 ) ; miseEnMain ( ) ; Game . getInstance ( ) . showTemp ( joueurEnCours . getNom ( ) + " se red\u00E9ploie." ) ; } Game . getInstance ( ) . majInfos ( ) ; }
va	6	private void persist ( PersistAction persistAction , String successMessage ) { if ( selected != null ) { setEmbeddableKeys ( ) ; try { if ( persistAction != PersistAction . DELETE ) { getFacade ( ) . edit ( selected ) ; } else { getFacade ( ) . remove ( selected ) ; } JsfUtil . addSuccessMessage ( successMessage ) ; } catch ( EJBException ex ) { String msg = "" ; Throwable cause = ex . getCause ( ) ; if ( cause != null ) { msg = cause . getLocalizedMessage ( ) ; } if ( msg . length ( ) > 0 ) { JsfUtil . addErrorMessage ( msg ) ; } else { JsfUtil . addErrorMessage ( ex , ResourceBundle . getBundle ( "/resoruces/Bundle" ) . getString ( "PersistenceErrorOccured" ) ) ; } } catch ( Exception ex ) { Logger . getLogger ( this . getClass ( ) . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; JsfUtil . addErrorMessage ( ex , ResourceBundle . getBundle ( "/resoruces/Bundle" ) . getString ( "PersistenceErrorOccured" ) ) ; } } }
va	7	private void calcNormalizedDirection ( Point result , int x1 , int y1 , int x2 , int y2 ) { int dxn = ( x1 == x2 ) ? 0 : ( x1 < x2 ) ? 1 : - 1 ; int dyn = ( y1 == y2 ) ? 0 : ( y1 < y2 ) ? 1 : - 1 ; if ( dxn != 0 && dyn != 0 ) { if ( rand . nextInt ( 1000 ) > 500 ) { result . x = dxn ; result . y = 0 ; } else { result . x = 0 ; result . y = dyn ; } } else { result . x = dxn ; result . y = dyn ; } }
va	6	public static void main ( String [ ] args ) { boolean all_right ; all_right = true ; int p0 ; int p1 ; int p2 ; int p3 ; int p4 ; p0 = 3 ; p1 = 1 ; p2 = 1 ; p3 = 1 ; p4 = 6 ; all_right = KawigiEdit_RunTest ( 0 , p0 , p1 , p2 , p3 , true , p4 ) && all_right ; p0 = 3 ; p1 = 3 ; p2 = 1 ; p3 = 1 ; p4 = 9 ; all_right = KawigiEdit_RunTest ( 1 , p0 , p1 , p2 , p3 , true , p4 ) && all_right ; p0 = 50 ; p1 = 10 ; p2 = 10 ; p3 = 10 ; p4 = 0 ; all_right = KawigiEdit_RunTest ( 2 , p0 , p1 , p2 , p3 , true , p4 ) && all_right ; p0 = 18 ; p1 = 12 ; p2 = 8 ; p3 = 9 ; p4 = 81451692 ; all_right = KawigiEdit_RunTest ( 3 , p0 , p1 , p2 , p3 , true , p4 ) && all_right ; p0 = 50 ; p1 = 25 ; p2 = 25 ; p3 = 25 ; p4 = 198591037 ; all_right = KawigiEdit_RunTest ( 4 , p0 , p1 , p2 , p3 , true , p4 ) && all_right ; if ( all_right ) { System . out . println ( "You're a stud (at least on the example cases)!" ) ; } else { System . out . println ( "Some of the test cases had errors." ) ; } }
va	6	public TestInfo runInTheCloud ( String userKey , String testId ) { TestInfo testInfo = null ; String error = null ; if ( userKey == null || userKey . trim ( ) . isEmpty ( ) ) { error = "Test cannot be started in the cloud  userKey is empty" ; BmLog . debug ( error ) ; testInfo = new TestInfo ( ) ; testInfo . setError ( error ) ; return testInfo ; } if ( testId == null || testId . trim ( ) . isEmpty ( ) ) { error = "Test cannot be started in the cloud  testId is empty" ; BmLog . debug ( error ) ; testInfo = new TestInfo ( ) ; testInfo . setError ( error ) ; return testInfo ; } String url = this . urlManager . testStart ( Constants . APP_KEY , userKey , testId ) ; JSONObject jo = getJson ( Methods . POST , url , null ) ; testInfo = TestInfoProcessor . parseTestInfo ( jo ) ; try { testInfo . setStatus ( jo . getInt ( "response_code" ) == 200 ? TestStatus . Running : TestStatus . NotRunning ) ; } catch ( JSONException je ) { BmLog . debug ( "Failed to set test status: " + je . getMessage ( ) ) ; } return testInfo ; }
va	5	@ Override public Object instantiate ( class < ? > clazz , CreationMode mode ) { Objects . requireNonNull ( clazz ) ; Object set = null ; if ( clazz . isInterface ( ) ) { if ( clazz == Set . class ) { } if ( clazz == SortedSet . class ) { } if ( clazz == NavigableSet . class ) { } } else { set = null ; } return set ; }
va	5	public static int getWuXingNumByWuXing ( String wuxing ) { if ( wuxing . endsWith ( "\u91D1" ) ) return 4 ; else if ( wuxing . endsWith ( "\u6728" ) ) return 3 ; else if ( wuxing . endsWith ( "\u6C34" ) ) return 2 ; else if ( wuxing . endsWith ( "\u706B" ) ) return 6 ; else if ( wuxing . endsWith ( "\u571F" ) ) return 5 ; return - 1 ; }
va	0	public static Word resume ( int index , String str ) { int p = str . lastIndexOf ( / ) ; return new Word ( index , str . substring ( 0 , p ) , str . substring ( p + 1 ) ) ; }
va	7	private void addToBucketMap ( Map < Integer , List < Integer >> bucketMap , int ibucket , int element ) { List < Integer > list ; if ( bucketMap . containsKey ( ibucket ) ) { list = bucketMap . get ( ibucket ) ; } else { list = new ArrayList < Integer > ( ) ; bucketMap . put ( ibucket , list ) ; } if ( list . isEmpty ( ) ) { list . add ( element ) ; } else if ( list . size ( ) == 1 ) { if ( element > list . get ( 0 ) ) { list . add ( element ) ; } if ( element < list . get ( 0 ) ) { list . add ( 0 , element ) ; } } else { if ( element < list . get ( 0 ) ) { list . set ( 0 , element ) ; } else if ( element > list . get ( 1 ) ) { list . set ( 1 , element ) ; } } }
va	0	@ XmlTransient public Collection < Keyvalue > getKeyvalueCollection ( ) { return keyvalueCollection ; }
va	1	public int print ( Graphics graphics , PageFormat pageFormat , int pageIndex ) throws PrinterException { if ( pageIndex >= 1 ) return Printable . NO_SUCH_PAGE ; Graphics2D g2d = ( Graphics2D ) graphics ; double h = pageFormat . getImageableHeight ( ) ; double w = pageFormat . getImageableWidth ( ) ; double x = pageFormat . getImageableX ( ) ; double y = pageFormat . getImageableY ( ) ; System . out . println ( "pf:" + x + " " + y + " " + w + " " + h ) ; g2d . translate ( x , y ) ; Dimension size = new Dimension ( ( int ) w , ( int ) h ) ; paintIt ( g2d , size ) ; return Printable . PAGE_EXISTS ; }
va	9	public void submit ( Integer partId ) { System . out . println ( String . format ( "==\n== [nlp] Submitting Solutions" + " | Programming Exercise %s\n==" , homework_id ( ) ) ) ; partId = promptPart ( ) ; List < String > partNames = validParts ( ) ; if ( ! isValidPartId ( partId ) ) { System . err . println ( "!! Invalid homework part selected." ) ; System . err . println ( String . format ( "!! Expected an integer from 1 to %d." , partNames . size ( ) + 1 ) ) ; System . err . println ( "!! Submission Cancelled" ) ; return ; } String [ ] loginPassword = loginPrompt ( ) ; String login = loginPassword [ 0 ] ; String password = loginPassword [ 1 ] ; if ( login == null || login . equals ( "" ) ) { System . out . println ( "!! Submission Cancelled" ) ; return ; } System . out . print ( "\n== Connecting to Coursera ... " ) ; List < Integer > submitParts = new ArrayList < Integer > ( ) ; if ( partId == partNames . size ( ) + 1 ) { for ( int i = 1 ; i < partNames . size ( ) + 1 ; i ++ ) { submitParts . add ( new Integer ( i ) ) ; } } else { submitParts . add ( new Integer ( partId ) ) ; } for ( Integer part : submitParts ) { String [ ] loginChSignature = getChallenge ( login , part ) ; if ( loginChSignature == null ) { return ; } login = loginChSignature [ 0 ] ; String ch = loginChSignature [ 1 ] ; String signature = loginChSignature [ 2 ] ; String ch_aux = loginChSignature [ 3 ] ; String ch_resp = challengeResponse ( login , password , ch ) ; String result = submitSolution ( login , ch_resp , part . intValue ( ) , output ( part , ch_aux ) , source ( part ) , signature ) ; if ( result == null ) { result = "NULL RESPONSE" ; } if ( result . trim ( ) . equals ( "Exception: We could not verify your username / password  please try again. (Note that your password is case-sensitive.)" ) ) { System . out . println ( "== The password is not your login  but a 10 character alphanumeric string displayed on the top of the Assignments page." ) ; } else { System . out . println ( String . format ( "\n== [nlp] Submitted Homework %s - Part %d - %s" , homework_id ( ) , part , partNames . get ( part - 1 ) ) ) ; System . out . println ( "== " + result . trim ( ) ) ; } } }
va	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( Options . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( Options . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( Options . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( Options . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { new Options ( ) . setVisible ( true ) ; } } ) ; }
va	2	public void hireAssistantByArray ( Assistant [ ] array ) { Utility . randomizeArray ( array ) ; int n = array . length ; this . assistant = new Assistant ( 0 ) ; for ( int i = 0 ; i < n ; i ++ ) { interviewAssistant ( array [ i ] ) ; if ( isLatestCandidateBetter ( ) ) { setAssistant ( array [ i ] ) ; } } }
va	1	@ Override public void onUpdate ( Object updated ) { if ( lastMap != panel . getMap ( ) ) { lastMap = panel . getMap ( ) ; mapImg = null ; } makeImage ( ) ; repaint ( ) ; }
va	8	@ Override public void focusLost ( FocusEvent ev ) { if ( ev . getSource ( ) . equals ( groupAddrField ) ) { groupAddress . setAddr ( AddrTranslator . getAdrValue ( groupAddrField . getText ( ) ) ) ; groupAddrField . setText ( AddrTranslator . getAdrString ( groupAddress ) ) ; } if ( ev . getSource ( ) . equals ( groupAddrField2 ) ) { groupAddress2 . setAddr ( AddrTranslator . getAdrValue ( groupAddrField2 . getText ( ) ) ) ; groupAddrField2 . setText ( AddrTranslator . getAdrString ( groupAddress2 ) ) ; } if ( ev . getSource ( ) . equals ( tempOffsetField ) ) { temperatureOffset = float . valueOf ( tempOffsetField . getText ( ) ) ; temperatureOffset = ( ( float ) Math . round ( 10 * temperatureOffset ) ) / 10 ; if ( temperatureOffset > 12.7 ) temperatureOffset = ( float ) 12.7 ; if ( temperatureOffset < - 12.7 ) temperatureOffset = ( float ) - 12.7 ; tempOffsetField . setText ( temperatureOffset . toString ( ) ) ; } if ( ev . getSource ( ) . equals ( humidityOffsetField ) ) { humidityOffset = float . valueOf ( humidityOffsetField . getText ( ) ) ; humidityOffset = ( ( float ) Math . round ( 10 * humidityOffset ) ) / 10 ; if ( humidityOffset > 12.7 ) humidityOffset = ( float ) 12.7 ; if ( humidityOffset < - 12.7 ) humidityOffset = ( float ) - 12.7 ; humidityOffsetField . setText ( humidityOffset . toString ( ) ) ; } }
va	9	public int maxDepth ( TreeNode root ) { if ( root == null ) { return 0 ; } int maxDepth = 0 ; Stack < TreeNode > stack = new Stack < TreeNode > ( ) ; HashMap < TreeNode , Integer > marked = new HashMap < TreeNode , Integer > ( ) ; stack . push ( root ) ; marked . put ( root , 1 ) ; while ( ! stack . isEmpty ( ) ) { TreeNode node = stack . pop ( ) ; if ( node . left != null ) { if ( marked . get ( node . left ) == null ) { stack . push ( node . left ) ; marked . put ( node . left , marked . get ( node ) + 1 ) ; } } if ( node . right != null ) { if ( marked . get ( node . right ) == null ) { stack . push ( node . right ) ; marked . put ( node . right , marked . get ( node ) + 1 ) ; } } if ( node . left == null && node . right == null ) { int depth = marked . get ( node ) ; if ( depth > maxDepth ) { maxDepth = depth ; } } } return maxDepth ; }
va	2	public List < String > getSubscribedNodes ( ) { List < String > entries = new ArrayList < String > ( ) ; try { List < Subscription > subs = pubsub_man . getSubscriptions ( ) ; for ( Subscription curr : subs ) { entries . add ( curr . getNode ( ) ) ; } } catch ( XMPPException e ) { e . printStackTrace ( ) ; } return entries ; }
va	2	private void survivalSelection ( ) { sortPopulation ( ) ; while ( population . size ( ) > ( popSize + RANDOM_SURVIVAL ) ) { population . remove ( population . size ( ) - 1 ) ; } while ( population . size ( ) > popSize ) { population . remove ( rg . nextInt ( population . size ( ) - 1 ) + 1 ) ; } }
va	7	public static Query restore ( byte [ ] bytes ) throws MalformedMessageException { try { ByteBuffer buffer = ByteBuffer . wrap ( bytes , 4 , bytes . length - 4 ) ; byte typeAsByte = buffer . get ( ) ; Query . Type type = null ; for ( Query . Type possibleType : Query . Type . values ( ) ) { if ( typeAsByte == possibleType . code ( ) ) { type = possibleType ; } } if ( type == null ) { throw new MalformedMessageException ( "No such type code: " + type ) ; } if ( type == Type . STOP ) { return Query . create ( type ) ; } int keySizeAsBytes = buffer . getInt ( ) ; String key = new String ( bytes , buffer . position ( ) , keySizeAsBytes ) ; buffer . position ( buffer . position ( ) + keySizeAsBytes ) ; if ( type == Type . GET || type == Type . DELETE ) { return Query . create ( type , key ) ; } int valueSizeAsBytes = buffer . getInt ( ) ; String value = new String ( bytes , buffer . position ( ) , valueSizeAsBytes ) ; return Query . create ( type , key , value ) ; } catch ( RuntimeException e ) { throw new MalformedMessageException ( "Impossible to restore message" ) ; } }
va	3	public synchronized void addItem ( String astr , Object aobj ) { int idx ; if ( issorted ) { idx = findIndex ( astr ) ; if ( wasfound ) { myobjects . set ( idx , aobj ) ; } else { mystrings . add ( idx , astr ) ; myobjects . add ( idx , aobj ) ; } } else { idx = getIndex ( astr ) ; if ( idx < 0 ) { mystrings . add ( astr ) ; myobjects . add ( aobj ) ; } else { myobjects . set ( idx , aobj ) ; } } }
va	0	public LocaleEditor ( ) { locale = Locale . getDefault ( ) ; locales = Calendar . getAvailableLocales ( ) ; length = locales . length ; localeStrings = new String [ length ] ; }
va	4	@ Override public void executeCommand ( String c ) { if ( c . equals ( "" + this . getCommandChar ( ) ) ) { this . insertChar ( c . charAt ( 0 ) ) ; return ; } int i = 0 ; while ( i < this . commands . size ( ) && ! this . commands . get ( i ) . match ( c ) ) { i ++ ; } if ( i >= this . commands . size ( ) ) throw new CommandNotFoundException ( c ) ; else this . commands . get ( i ) . execute ( c ) ; }
va	0	public void getMoney ( long amount ) { System . out . println ( "\u5411\u62DB\u5546\u94F6\u884C\u53D6\u51FA\u91D1\u989D:" + amount ) ; }
va	7	public Integer costFrom ( Node from , ElementPanel panel , Point target ) { for ( Component c : panel . getElements ( ) ) if ( c . intersects ( p , from . p ) ) return null ; if ( panel . getHvLines ( ) != null && Node . dist ( p , from . p ) > 20 ) for ( HVLine hvl : panel . getHvLines ( ) ) if ( hvl . contains ( p , from . p ) ) return null ; int vDist = Math . abs ( p . y - from . p . y ) ; int hDist = Math . abs ( p . x - from . p . x ) ; int turn = from . getTurn ( ) ; if ( isTurn ( from ) ) turn ++ ; int tDist = turn * dist ( p , target ) ; return vDist + hDist + tDist ; }
va	6	public void testManyThreadedInit ( ) { VariantInitTestThread threads [ ] = new VariantInitTestThread [ 75 ] ; System . out . println ( "Starting thread test (" + threads . length + " threads each creating 10000 objects)." + " This may take 30 seconds or more." ) ; for ( int i = 0 ; i < threads . length ; i ++ ) { threads [ i ] = new VariantInitTestThread ( "thread-" + i , 10000 ) ; } for ( int i = 0 ; i < threads . length ; i ++ ) { threads [ i ] . start ( ) ; } int numComplete = 0 ; while ( numComplete < threads . length ) { try { Thread . sleep ( 333 ) ; } catch ( InterruptedException ie ) { } numComplete = 0 ; for ( int i = 0 ; i < threads . length ; i ++ ) { if ( threads [ i ] . isComplete ) { numComplete ++ ; } } } System . out . println ( "Finished thread test" ) ; }
va	4	private Object idGen ( String descriptive , String ... attributes ) { for ( String attribute : attributes ) { if ( attribute . indexOf ( = ) < 0 && ! attribute . startsWith ( "*" ) ) { return _idgen . generateID ( attribute ) ; } } if ( descriptive == null ) { return null ; } else { return _idgen . generateID ( descriptive ) ; } }
va	6	@ Override public void actionPerformed ( ActionEvent e ) { String cmd = e . getActionCommand ( ) ; switch ( cmd ) { case APTO_ACTUALIZAR : ctrlApartamentos . cargarDialogoActualizarApartamento ( ) ; break ; case APTO_AGREGAR : ctrlApartamentos . cargarDialogoNuevoApartamento ( ) ; break ; case APTO_BORRAR : ctrlApartamentos . eliminarApartamentos ( ) ; break ; case TORRE_ACTUALIZAR : ctrlApartamentos . cargarDialogoActualizarTorre ( ) ; break ; case TORRE_AGREGAR : ctrlApartamentos . nuevaTorre ( ) ; break ; case TORRE_BORRAR : ctrlApartamentos . eliminarTorre ( ) ; break ; } }
va	9	public void fillMissing ( ) { if ( parents == null ) { parents = new ArrayList < > ( ) ; } if ( content == null ) { content = new ArrayList < > ( ) ; } if ( path != null ) { if ( name == null && path . contains ( PATH_SEPARATOR ) ) { name = path . substring ( path . lastIndexOf ( PATH_SEPARATOR ) + 1 ) ; } if ( parents . isEmpty ( ) ) { if ( path . contains ( PATH_SEPARATOR ) ) { ParentInfo parent = new ParentInfo ( ) ; parent . setPath ( path . substring ( 0 , path . lastIndexOf ( PATH_SEPARATOR ) + 1 ) ) ; if ( parent . getPath ( ) . equals ( PATH_SEPARATOR ) ) { parent . setIsRoot ( true ) ; } parents . add ( parent ) ; } } } if ( fileType == null ) { if ( mimeType != null ) { for ( String folderType : FOLDER_MIME_TYPES ) { if ( mimeType . equalsIgnoreCase ( folderType ) ) { fileType = FileType . FOLDER ; break ; } } if ( fileType == null ) { fileType = FileType . FILE ; } } else { fileType = FileType . FOLDER ; } } }
va	1	public static int numberOf2Between0AndN ( int n ) { int index = String . valueOf ( n ) . length ( ) ; int k = 0 ; for ( int i = 0 ; i < index ; i ++ ) { k += NumberOf2Between . count2InDigits ( n , i ) ; } return k ; }
va	8	public void setFieldValue ( _Fields field , Object value ) { switch ( field ) { case URL : if ( value == null ) { unsetUrl ( ) ; } else { setUrl ( ( String ) value ) ; } break ; case DISPLAY_URL : if ( value == null ) { unsetDisplayUrl ( ) ; } else { setDisplayUrl ( ( String ) value ) ; } break ; case EXPANDED_URL : if ( value == null ) { unsetExpandedUrl ( ) ; } else { setExpandedUrl ( ( String ) value ) ; } break ; case ACCESSED_URL : if ( value == null ) { unsetAccessedUrl ( ) ; } else { setAccessedUrl ( ( String ) value ) ; } break ; } }
va	6	@ SuppressWarnings ( "unchecked" ) @ Override protected void mergePartialIndex ( int lastRound ) { ObjectInputStream reader = null ; for ( int idx = 0 ; idx < MAXCORPUS ; idx ++ ) { Map < Integer , Vector < Integer >> finalIndex = new HashMap < Integer , Vector < Integer >> ( ) ; for ( int round = 1 ; round <= lastRound ; round ++ ) { File partialIdx = new File ( getPartialIndexName ( idx , round ) ) ; if ( partialIdx . exists ( ) ) { System . out . println ( "Merging partial index " + idx + " of round " + round ) ; reader = createObjInStream ( partialIdx . getAbsolutePath ( ) ) ; try { Map < Integer , Vector < Integer >> pIdx = ( Map < Integer , Vector < Integer >> ) reader . readObject ( ) ; for ( int wordId : pIdx . keySet ( ) ) { if ( finalIndex . containsKey ( wordId ) ) { Vector < Integer > old = finalIndex . get ( wordId ) ; Vector < Integer > curr = pIdx . get ( wordId ) ; old . addAll ( curr ) ; finalIndex . put ( wordId , old ) ; } else { finalIndex . put ( wordId , pIdx . get ( wordId ) ) ; } } } catch ( Exception e ) { e . printStackTrace ( ) ; throw new RuntimeException ( "Error during reading partial index" ) ; } } } writeFinalIndex ( idx , finalIndex ) ; cleaningPartialIndex ( idx , lastRound ) ; } }
va	1	public boolean recepitUpdate ( String recepiter , String recepitId , String no , String patientid ) { boolean result = false ; String str = "update recepit_list set receipter='" + recepiter + "'  status='2'   patient_id= '" + patientid + "' where receipt_id='" + recepitId + "' and no='" + no + "';" ; System . out . println ( str ) ; try { conn = dbConn . getConn ( ) ; pstmt = conn . prepareStatement ( str ) ; pstmt . executeUpdate ( ) ; result = true ; dbConn . close ( conn ) ; return result ; } catch ( SQLException e ) { e . printStackTrace ( ) ; } return result ; }
va	9	public static void connect ( TreeLinkNode root ) { if ( root == null ) return ; if ( root . left != null ) { if ( root . right != null ) { root . left . next = root . right ; } else { TreeLinkNode temp = root . next ; while ( temp != null && temp . right == null && temp . left == null ) { temp = temp . next ; } if ( temp != null ) { if ( temp . left != null ) root . left . next = temp . left ; else root . left . next = temp . right ; } } } if ( root . right != null ) { TreeLinkNode temp = root . next ; while ( temp != null && temp . right == null && temp . left == null ) { temp = temp . next ; } if ( temp != null ) { if ( temp . left != null ) root . right . next = temp . left ; else root . right . next = temp . right ; } } connect ( root . right ) ; connect ( root . left ) ; }
va	6	private int mixLightnessSigned ( int hsl , int lightness ) { if ( hsl == - 2 ) return bc614e ; if ( hsl == - 1 ) { if ( lightness < 0 ) lightness = 0 ; else if ( lightness > 127 ) lightness = 127 ; lightness = 127 - lightness ; return lightness ; } lightness = ( lightness * ( hsl & 7f ) ) / 128 ; if ( lightness < 2 ) lightness = 2 ; else if ( lightness > 126 ) lightness = 126 ; return ( hsl & ff80 ) + lightness ; }
va	1	public synchronized void put ( T val ) { Link < T > link = new Link ( val ) ; if ( first == null ) { first = last = link ; } else { last . next = link ; last = link ; } this . notify ( ) ; }
va	9	private static String getValue ( JSONTokener x ) throws JSONException { char c ; char q ; StringBuffer sb ; do { c = x . next ( ) ; } while ( c ==   || c == 	 ) ; switch ( c ) { case 0 : return null ; case " : case ' : q = c ; sb = new StringBuffer ( ) ; for ( ; ; ) { c = x . next ( ) ; if ( c == q ) { break ; } if ( c == 0 || c == '' || c == '' ) { throw x . syntaxError ( "Missing close quote '" + q + "'." ) ; } sb . append ( c ) ; } return sb . toString ( ) ; case   : x . back ( ) ; return "" ; default : x . back ( ) ; return x . nextTo (   ) ; } }
va	0	public AgentObserver getObserver ( ) { return this . observer ; }
va	7	static private Point [ ] dodecahedron ( ) { Point [ ] ret = new Point [ 20 ] ; final double GOLDEN = ( 1 + sqrt ( 5 ) ) / 2 ; int i = 0 ; for ( int x = - 1 ; x <= + 1 ; x ++ ) { for ( int y = - 1 ; y <= + 1 ; y ++ ) { for ( int z = - 1 ; z <= + 1 ; z ++ ) { if ( x * y * z != 0 ) ret [ i ++ ] = p ( x , y , z ) ; else if ( y * z != 0 ) ret [ i ++ ] = p ( 0 , y / GOLDEN , z * GOLDEN ) ; else if ( z * x != 0 ) ret [ i ++ ] = p ( x * GOLDEN , 0 , z / GOLDEN ) ; else if ( x * y != 0 ) ret [ i ++ ] = p ( x / GOLDEN , y * GOLDEN , 0 ) ; } } } return ret ; }
va	2	public void initSetting ( String key , Object def ) { try { if ( BeanUtils . getProperty ( this , key ) == null ) BeanUtils . setProperty ( this , key , def ) ; } catch ( Exception e ) { throw new AssertionError ( "Error initing settings in BoardSettings" ) ; } }
va	0	public void mouseExited ( final MouseEvent mouseEvent ) { }
va	1	public T deleteMin ( ) { if ( isEmpty ( ) ) return null ; T minItem = root . element ; root = merge ( root . left , root . right ) ; return minItem ; }
va	1	public LongLargeArray ( long length , long constantValue ) { this . type = LargeArrayType . double ; this . sizeof = 8 ; if ( length <= 0 ) { throw new IllegalArgumentException ( length + " is not a positive long value" ) ; } this . length = length ; this . isConstant = true ; this . data = new long [ ] { constantValue } ; }
va	2	public int numTimesLetterAppears ( ArrayList < Character > list , char c ) { int i = 0 ; for ( char each : list ) { if ( each == c ) { i ++ ; } } return i ; }
va	6	public boolean isEar ( final IColumnVector < float > p1 , final IColumnVector < float > p2 , final IColumnVector < float > p3 ) { if ( p1 == null ) { throw new NullPointerException ( "'p1' must not be 'null'" ) ; } if ( p2 == null ) { throw new NullPointerException ( "'p2' must not be 'null'" ) ; } if ( p3 == null ) { throw new NullPointerException ( "'p3' must not be 'null'" ) ; } if ( ! ( isConvex ( p1 , p2 , p3 ) ) ) { return false ; } for ( int i = 0 ; i < nonConvexVertices . size ( ) ; i ++ ) { if ( Triangle . isInside ( p1 , p2 , p3 , nonConvexVertices . get ( i ) ) ) { return false ; } } return true ; }
va	0	public Dictionary ( String path ) throws FileNotFoundException , IOException { loadDictionary ( path ) ; }
va	5	private void evalDerivativeState ( ) { try { ArrayList < String > vars = new ArrayList < String > ( ) ; vars . add ( input2Box . getText ( ) . trim ( ) ) ; Function f = TokenizedFunctionFactory . createFunction ( expressionBox . getText ( ) , vars ) ; double diff = 0.0 ; String meth = ( String ) input1Box . getSelectedItem ( ) ; if ( meth . equals ( "Forward Diff." ) ) { diff = Derivatives . forwardDifference ( f , double . parseDouble ( input3Box . getText ( ) ) , optionFrame . getParam ( "DerivStep" ) ) ; } else if ( meth . equals ( "Backward Diff." ) ) { diff = Derivatives . backwardDifference ( f , double . parseDouble ( input3Box . getText ( ) ) , optionFrame . getParam ( "DerivStep" ) ) ; } else if ( meth . equals ( "Centered Diff." ) ) { diff = Derivatives . centeredDifference ( f , double . parseDouble ( input3Box . getText ( ) ) , optionFrame . getParam ( "DerivStep" ) ) ; } displayOutput ( "Derivative: " + diff + "\n" ) ; } catch ( MalformedFunctionException e ) { displayOutput ( "Could not evaluate: " + e . getMessage ( ) + "\n" ) ; } catch ( NumberFormatException e ) { displayOutput ( "Invalid numerical input\n" ) ; } }
va	4	public void render ( Graphics g ) { int yOffs = ( int ) ( 480 - time * 100 ) ; if ( yOffs < 0 ) yOffs = 0 ; g . drawImage ( Art . title_bg , 0 , - yOffs / 2 , null ) ; g . drawImage ( Art . titleScreen , 10 , - yOffs , null ) ; g . drawImage ( ( eyesOpen ? Art . titleSprites [ 0 ] [ 0 ] : Art . titleSprites [ 1 ] [ 0 ] ) , 210 , - yOffs + 140 , null ) ; if ( time > 5 ) { String msg = "PRESS X TO START" ; Art . drawString ( msg , g , 160 - msg . length ( ) * 3 , 140 - 3 - ( int ) ( Math . abs ( Math . sin ( time ) * 10 ) ) ) ; } if ( time >= 0 ) { String msg = "COPYRIGHT DOMINIK SCHROETER 2011" ; Art . drawString ( msg , g , 2 , 240 - 6 - 2 ) ; } }
va	6	public boolean getBoolean ( int index ) throws JSONException { Object object = this . get ( index ) ; if ( object . equals ( boolean . false ) || ( object instanceof String && ( ( String ) object ) . equalsIgnoreCase ( "false" ) ) ) { return false ; } else if ( object . equals ( boolean . true ) || ( object instanceof String && ( ( String ) object ) . equalsIgnoreCase ( "true" ) ) ) { return true ; } throw new JSONException ( "JSONArray[" + index + "] is not a boolean." ) ; }
va	1	public Object autoUnmap ( Map < String , ? > map ) { ReMapperMeta meta = extractMeta ( map ) ; return unmap ( map , meta . getType ( ) ) ; }
va	5	public static boolean [ ] [ ] maskClip ( final boolean [ ] [ ] mask ) { int rows = maskRows ( mask ) ; int cols = maskCols ( mask ) ; int minRow = 0 , maxRow = rows - 1 ; int minCol = 0 , maxCol = cols - 1 ; for ( int row = 0 ; row < rows ; ++ row ) { for ( int col = 0 ; col < cols ; ++ col ) { if ( mask [ row ] [ col ] ) { minRow = Math . min ( minRow , row ) ; maxRow = Math . max ( maxRow , row ) ; minCol = Math . min ( minCol , col ) ; maxCol = Math . max ( maxCol , col ) ; } } } boolean [ ] [ ] result = new boolean [ maxRow + 1 - minRow ] [ maxCol + 1 - minCol ] ; for ( int row = minRow ; row <= maxRow ; ++ row ) { for ( int col = minCol ; col <= maxCol ; ++ col ) { result [ row - minRow ] [ col - minCol ] = mask [ row ] [ col ] ; } } return result ; }
va	8	private boolean r_un_accent ( ) { int v_3 ; { int v_1 = 1 ; replab0 : while ( true ) { lab1 : do { if ( ! ( out_grouping_b ( g_v , 97 , 251 ) ) ) { break lab1 ; } v_1 -- ; continue replab0 ; } while ( false ) ; break replab0 ; } if ( v_1 > 0 ) { return false ; } } ket = cursor ; lab2 : do { v_3 = limit - cursor ; lab3 : do { if ( ! ( eq_s_b ( 1 , "\u00E9" ) ) ) { break lab3 ; } break lab2 ; } while ( false ) ; cursor = limit - v_3 ; if ( ! ( eq_s_b ( 1 , "\u00E8" ) ) ) { return false ; } } while ( false ) ; bra = cursor ; slice_from ( "e" ) ; return true ; }
va	2	public boolean ghostRequiresAction ( int whichGhost ) { return ( isJunction ( curGhostLocs [ whichGhost ] ) && ( edibleTimes [ whichGhost ] == 0 || edibleTimes [ whichGhost ] % GHOST_SPEED_REDUCTION != 0 ) ) ; }
va	2	public static void reloadTexture ( BufferedImage image , int textureID ) { int [ ] pixels = new int [ image . getWidth ( ) * image . getHeight ( ) ] ; image . getRGB ( 0 , 0 , image . getWidth ( ) , image . getHeight ( ) , pixels , 0 , image . getWidth ( ) ) ; ByteBuffer buffer = BufferUtils . createByteBuffer ( image . getWidth ( ) * image . getHeight ( ) * BYTES_PER_PIXEL ) ; for ( int y = image . getHeight ( ) - 1 ; y >= 0 ; y -- ) { for ( int x = 0 ; x < image . getWidth ( ) ; x ++ ) { int pixel = pixels [ y * image . getWidth ( ) + x ] ; buffer . put ( ( byte ) ( ( pixel >> 16 ) & FF ) ) ; buffer . put ( ( byte ) ( ( pixel >> 8 ) & FF ) ) ; buffer . put ( ( byte ) ( pixel & FF ) ) ; buffer . put ( ( byte ) ( ( pixel >> 24 ) & FF ) ) ; } } buffer . flip ( ) ; glBindTexture ( GL_TEXTURE_2D , textureID ) ; glTexParameteri ( GL_TEXTURE_2D , GL_TEXTURE_WRAP_S , GL12 . GL_CLAMP_TO_EDGE ) ; glTexParameteri ( GL_TEXTURE_2D , GL_TEXTURE_WRAP_T , GL12 . GL_CLAMP_TO_EDGE ) ; glTexParameteri ( GL_TEXTURE_2D , GL_TEXTURE_MIN_FILTER , GL_NEAREST ) ; glTexParameteri ( GL_TEXTURE_2D , GL_TEXTURE_MAG_FILTER , GL_NEAREST ) ; glTexImage2D ( GL_TEXTURE_2D , 0 , GL_RGBA8 , image . getWidth ( ) , image . getHeight ( ) , 0 , GL_RGBA , GL_UNSIGNED_BYTE , buffer ) ; }
va	1	private void resetFinishInformation ( ) { for ( Map . Entry < String , PlayerData > e : PlayersDataHolder . getInstance ( ) . getPlayerData ( ) . entrySet ( ) ) { e . getValue ( ) . setFinished ( false ) ; } }
va	7	protected void loadJarURLs ( ) throws Exception { state = 2 ; String jarList = "lwjgl.jar  jinput.jar  lwjgl_util.jar  additional.zip  " + mainGameUrl ; jarList = trimExtensionByCapabilities ( jarList ) ; StringTokenizer jar = new StringTokenizer ( jarList , "  " ) ; int jarCount = jar . countTokens ( ) + 1 ; urlList = new URL [ jarCount ] ; URL path = new URL ( "http://srv1.dcserver.ru:8050/update/" ) ; for ( int i = 0 ; i < jarCount - 1 ; i ++ ) { urlList [ i ] = new URL ( path , jar . nextToken ( ) ) ; } String osName = System . getProperty ( "os.name" ) ; String nativeJar = null ; if ( osName . startsWith ( "Win" ) ) nativeJar = "windows_natives.jar.lzma" ; else if ( osName . startsWith ( "Linux" ) ) nativeJar = "linux_natives.jar.lzma" ; else if ( osName . startsWith ( "Mac" ) ) nativeJar = "macosx_natives.jar.lzma" ; else if ( ( osName . startsWith ( "Solaris" ) ) || ( osName . startsWith ( "SunOS" ) ) ) nativeJar = "solaris_natives.jar.lzma" ; else { fatalErrorOccured ( "OS (" + osName + ") \u043D\u0435 \u043F\u043E\u0434\u0434\u0435\u0440\u0436\u0438\u0432\u0430\u0435\u0442\u0441\u044F" , null ) ; } if ( nativeJar == null ) { fatalErrorOccured ( "lwjgl \u0444\u0430\u0439\u043B\u044B \u043D\u0435 \u043D\u0430\u0439\u0434\u0435\u043D\u044B" , null ) ; } else { nativeJar = trimExtensionByCapabilities ( nativeJar ) ; urlList [ ( jarCount - 1 ) ] = new URL ( path , nativeJar ) ; } }
va	5	private static void resetDatabase ( ) throws DataStoreException { try { if ( ! Configuration . isConfigured ( ) ) { URL testFile = MySQLConnectorTest . class . getResource ( "test.conf" ) ; Configuration . load ( new File ( testFile . toURI ( ) ) ) ; } loadDBConfiguration ( ) ; } catch ( NotConfiguredException | URISyntaxException | IOException e ) { throw new RuntimeException ( e ) ; } try ( Connection conn = DriverManager . getConnection ( "jdbc:mysql://" + host + ":" + port + "/" + database + "?user=" + username + "&password=" + password + "&default-character-set=utf8" ) ) { Statement resetStatement = conn . createStatement ( ) ; for ( String statement : sqlResetBatch ) { resetStatement . addBatch ( statement ) ; } for ( String statement : sqlInsertBatch ) { resetStatement . addBatch ( statement ) ; } resetStatement . executeBatch ( ) ; MySQLConnector . getInstance ( ) . invalidateCaches ( ) ; } catch ( SQLException | NotConfiguredException | ConnectionException e ) { throw new RuntimeException ( e ) ; } }
va	8	private boolean isPrime ( int n ) { if ( n < 2 ) { return false ; } else if ( n == 2 || n == 3 ) { return true ; } else if ( n % 2 == 0 || n % 3 == 0 ) { return false ; } else { double max_divisor = Math . sqrt ( n ) ; int divisor = 5 ; while ( divisor <= max_divisor ) { if ( n % divisor == 0 || n % ( divisor + 2 ) == 0 ) { return false ; } divisor += 6 ; } return true ; } }
va	2	@ Override public int compareTo ( BalanceEntry o ) { if ( price >= o . getPrice ( ) ) { return - 1 ; } else if ( price < o . getPrice ( ) ) { return 1 ; } else return 0 ; }
va	0	public PlayerDifficulty getPlayerDifficulty ( ) { return this . gameState . playerDifficulty ; }
va	5	private static Change parseChange ( String s , String revision , String revisionBefore ) { if ( s . trim ( ) . isEmpty ( ) ) return null ; List < String > values = split ( s , "\t" ) ; VcsChange . Type changeType = parseChangeType ( values . get ( 0 ) ) ; boolean hasRenames = values . size ( ) > 2 ; String filePath = unescapeQuotes ( hasRenames ? values . get ( 2 ) : values . get ( 1 ) ) ; String filePathBefore = unescapeQuotes ( hasRenames ? values . get ( 1 ) : filePath ) ; if ( changeType == Added ) { filePathBefore = VcsChange . noFilePath ; revisionBefore = VcsChange . noRevision ; } else if ( changeType == Deleted ) { filePathBefore = filePath ; filePath = VcsChange . noFilePath ; } return new Change ( changeType , filePath , filePathBefore , revision , revisionBefore ) ; }
va	8	public DescribeComponentsResult unmarshall ( StaxUnmarshallerContext context ) throws Exception { DescribeComponentsResult describeComponentsResult = new DescribeComponentsResult ( ) ; int originalDepth = context . getCurrentDepth ( ) ; int targetDepth = originalDepth + 1 ; if ( context . isStartOfDocument ( ) ) targetDepth += 1 ; while ( true ) { XMLEvent xmlEvent = context . nextEvent ( ) ; if ( xmlEvent . isEndDocument ( ) ) return describeComponentsResult ; if ( xmlEvent . isAttribute ( ) || xmlEvent . isStartElement ( ) ) { if ( context . testExpression ( "registered/item" , targetDepth ) ) { describeComponentsResult . getComponentInfos ( ) . add ( ComponentInfoStaxUnmarshaller . getInstance ( ) . unmarshall ( context ) ) ; continue ; } } else if ( xmlEvent . isEndElement ( ) ) { if ( context . getCurrentDepth ( ) < originalDepth ) { return describeComponentsResult ; } } } }
va	0	public long getElapsedInclusiveCpuTime ( ) { return mElapsedInclusiveCpuTime ; }
va	8	public static void main ( String [ ] args ) { boolean validar = true ; double valor1 = 0 ; double valor2 = 0 ; double resultado ; char continuar ; int opcion = 0 ; Scanner teclado = new Scanner ( System . in ) ; Operaciones oOperaciones = new Operaciones ( ) ; do { System . out . println ( "Digite la operacion a evaluar" ) ; System . out . println ( "1. Suma" ) ; System . out . println ( "2. Resta" ) ; System . out . println ( "3. Division" ) ; System . out . println ( "4. Multiplicacion" ) ; System . out . println ( "5. Raiz" ) ; System . out . println ( "6. Potencia" ) ; opcion = Integer . parseInt ( teclado . nextLine ( ) ) ; switch ( opcion ) { case 1 : System . out . println ( "Digite el valor del primer digito" ) ; valor1 = double . parseDouble ( teclado . nextLine ( ) ) ; System . out . println ( "Digite el valor del segundo digito" ) ; valor2 = double . parseDouble ( teclado . nextLine ( ) ) ; resultado = oOperaciones . sumar ( valor1 , valor2 ) ; System . out . println ( resultado ) ; break ; case 2 : System . out . println ( "Digite el valor del primer digito" ) ; valor1 = double . parseDouble ( teclado . nextLine ( ) ) ; System . out . println ( "Digite el valor del segundo digito" ) ; valor2 = double . parseDouble ( teclado . nextLine ( ) ) ; resultado = oOperaciones . resta ( valor1 , valor2 ) ; System . out . println ( resultado ) ; break ; case 3 : System . out . println ( "Digite el valor del primer digito" ) ; valor1 = double . parseDouble ( teclado . nextLine ( ) ) ; System . out . println ( "Digite el valor del segundo digito" ) ; valor2 = double . parseDouble ( teclado . nextLine ( ) ) ; resultado = oOperaciones . dividir ( valor1 , valor2 ) ; System . out . println ( resultado ) ; break ; case 4 : System . out . println ( "Digite el valor del primer digito" ) ; valor1 = double . parseDouble ( teclado . nextLine ( ) ) ; System . out . println ( "Digite el valor del segundo digito" ) ; valor2 = double . parseDouble ( teclado . nextLine ( ) ) ; resultado = oOperaciones . multiplicar ( valor1 , valor2 ) ; System . out . println ( resultado ) ; break ; case 5 : System . out . println ( "Digite el valor del primer digito" ) ; valor1 = double . parseDouble ( teclado . nextLine ( ) ) ; resultado = oOperaciones . raiz ( valor1 ) ; System . out . println ( resultado ) ; break ; case 6 : System . out . println ( "Digite el valor del primer digito" ) ; valor1 = double . parseDouble ( teclado . nextLine ( ) ) ; System . out . println ( "Digite el valor del segundo digito" ) ; valor2 = double . parseDouble ( teclado . nextLine ( ) ) ; resultado = oOperaciones . potencia ( valor1 , valor2 ) ; System . out . println ( resultado ) ; break ; } System . out . println ( "Desea continuar con otra operacion S/N" ) ; continuar = teclado . nextLine ( ) . charAt ( 0 ) ; if ( Character . toUpperCase ( continuar ) == S ) { validar = true ; } else { validar = false ; } } while ( validar ) ; }
va	1	public static boolean isEmpty ( CharSequence s ) { return s == null || s . length ( ) == 0 ; }
va	0	public FeatureDataItem ( FeatureVector fv , double score ) { this . fv = fv ; this . score = score ; }
va	1	public void setHasSelectedTrain ( boolean hasSelectedTrain ) { this . hasSelectedTrain = hasSelectedTrain ; if ( ! hasAlreadyChangedCriteria ) { f_pdvWay = - 1 ; listPointToDraw = null ; fireModelGPSChanged ( 6 ) ; } }
va	5	public ArrayList < Integer > getRow ( int rowIndex ) { int i , j , k ; int left , right ; ArrayList < Integer > ret = new ArrayList < Integer > ( ) ; ret . add ( 1 ) ; if ( rowIndex == 0 ) return ret ; ret . add ( 1 ) ; for ( i = 1 ; i < rowIndex ; i ++ ) { for ( j = ret . size ( ) - 1 ; j >= 0 ; j -- ) { if ( j == ret . size ( ) - 1 ) { ret . add ( 1 ) ; ret . set ( j , ret . get ( j ) + ret . get ( j - 1 ) ) ; } else if ( j == 0 ) { ret . set ( 0 , 1 ) ; } else { ret . set ( j , ret . get ( j ) + ret . get ( j - 1 ) ) ; } } } return ret ; }
va	8	@ Override public void addTransportMarker ( final String name , final Coordinates situated , final Coordinates destination , final String status ) { Platform . runLater ( new Runnable ( ) { @ Override public void run ( ) { try { if ( situated == null && destination == null ) { TransportAgentUi ui = transports . get ( name ) ; ui . changeStatus ( status ) ; return ; } if ( nodes . containsKey ( situated ) && nodes . containsKey ( destination ) ) { if ( transports . containsKey ( name ) ) { TransportAgentUi ui = transports . get ( name ) ; ui . changeStatus ( status ) ; } else { TransportAgentUi ui = new TransportAgentUi ( name , situated , destination , nodes . get ( destination ) . getName ( ) ) ; ui . getTransportImage ( ) . setOnMouseClicked ( new EventHandler < MouseEvent > ( ) { @ Override public void handle ( MouseEvent paramT ) { if ( paramT . isShiftDown ( ) ) { handler . removeTransport ( paramT . getSource ( ) ) ; } } } ) ; ui . changeStatus ( status ) ; transports . put ( name , ui ) ; boolean flag = transportGr . getChildren ( ) . add ( ui . getTransportImage ( ) ) ; if ( flag ) { transportsByImage . put ( ui . getTransportImage ( ) , ui ) ; } transportGr . getChildren ( ) . add ( ui . getTransportVector ( ) ) ; } } else { throw new Throwable ( "not existing node" ) ; } } catch ( Throwable t ) { ExceptionUtils . handleException ( t ) ; } } } ) ; }
va	1	@ Override public void enqueue ( E element ) { values [ index ( last ++ ) ] = element ; count ++ ; if ( count == values . length ) { resize ( count * 2 ) ; } }
va	5	public User ( String name , Image avatar , Color c , boolean local ) { setLayout ( new GridLayout ( 1 , 2 ) ) ; this . name = new JLabel ( name , JLabel . CENTER ) ; this . score = new JLabel ( "89" , JLabel . CENTER ) ; this . color = c ; this . wins = new JLabel ( "Wins: N/A" , JLabel . CENTER ) ; this . loses = new JLabel ( "Losses: N/A" , JLabel . CENTER ) ; this . avg = new JLabel ( "Avg Score: N/A" , JLabel . CENTER ) ; stats = new JPanel ( new GridLayout ( 5 , 1 ) ) ; Color col = Color . WHITE . brighter ( ) ; if ( c == Color . YELLOW || c == Color . GREEN ) col = Color . DARK_GRAY ; this . name . setForeground ( col ) ; this . score . setForeground ( col ) ; this . wins . setForeground ( col ) ; this . loses . setForeground ( col ) ; this . avg . setForeground ( col ) ; stats . add ( this . name ) ; stats . add ( this . score ) ; if ( ! local ) { stats . add ( this . wins ) ; stats . add ( this . loses ) ; stats . add ( this . avg ) ; } stats . setBackground ( c ) ; if ( avatar != null ) this . avatar = avatar . getScaledInstance ( Frame . PLAYERWIDTH / 2 , Frame . PLAYERWIDTH / 2 , Image . SCALE_DEFAULT ) ; new JPanel ( new FlowLayout ( ) ) ; if ( avatar != null ) add ( new JLabel ( new ImageIcon ( this . avatar ) ) ) ; setBorder ( ( BorderFactory . createLineBorder ( Color . DARK_GRAY , 3 ) ) ) ; add ( stats ) ; }
va	4	public void close ( ) { if ( paragraphs . size ( ) > 0 || ( lines . size ( ) > lastLine || ( buffer . size ( ) > 0 ) ) ) { addParagraph ( ) ; for ( FingerPrint fing : paragraphs ) { fp . add ( fing ) ; fp . lines += fing . lines ; } fp . pars = paragraphs . size ( ) ; } }
va	6	private Comparator < Tuple > parseOrderBy ( PeekableIterator < String > parts ) { if ( consumeIfPresent ( "order" , parts ) ) { assertNextToken ( "by" , parts ) ; Comparator < Tuple > comp = columnComparator ( parts . next ( ) ) ; if ( parts . hasNext ( ) ) { String dir = parts . next ( ) ; switch ( dir ) { case "asc" : case "ascending" : break ; case "desc" : case "descending" : comp = comp . reversed ( ) ; break ; default : throw new SqlParseException ( "Illegal modifier for ORDER BY: " + dir ) ; } } return comp ; } return null ; }
va	5	public static double klDivergence ( double [ ] p1 , double [ ] p2 ) { if ( p1 . length != p2 . length ) return - 1 ; double klDiv = 0.0 ; for ( int i = 0 ; i < p1 . length ; ++ i ) { if ( p1 [ i ] == 0 ) { continue ; } if ( p2 [ i ] == 0.0 ) { continue ; } klDiv += p1 [ i ] * Math . log ( p1 [ i ] / p2 [ i ] ) ; } if ( klDiv == 0 ) klDiv = double . MAX_VALUE ; return klDiv / log2 ; }
va	6	private void initialise ( ) throws BTFMatrixErrorException { if ( rows % block_rows != 0 || cols % block_cols != 0 ) { throw new BTFMatrixErrorException ( "Block matrix of size " + rows + " x " + cols + " cannot be divided into " + block_rows + "rows and " + block_cols + "columns" ) ; } rows_in_blocks = rows / block_rows ; cols_in_blocks = cols / block_cols ; int block_starting_col = 0 ; int block_starting_row = 0 ; matrix = new SparseBlock [ block_rows ] [ block_cols ] ; for ( int i = 0 ; i < block_rows ; i ++ ) { block_starting_row = i * rows_in_blocks ; for ( int j = 0 ; j < block_cols ; j ++ ) { block_starting_col = j * cols_in_blocks ; matrix [ i ] [ j ] = new SparseBlock ( basis , new Position ( position . row + block_starting_row , position . col + block_starting_col ) , rows_in_blocks , cols_in_blocks ) ; } } for ( int x = 0 ; x < rows ; x ++ ) { for ( int y = 0 ; y < cols ; y ++ ) { write ( x , y , BigRational . ZERO ) ; } } }
va	9	public void save ( ) { float HSB [ ] = Color . RGBtoHSB ( 255 , 0 , 0 , null ) ; Color red = Color . getHSBColor ( HSB [ 0 ] , HSB [ 1 ] / 5 , HSB [ 2 ] ) ; if ( _song != null ) { boolean valid = true ; if ( _artist . getText ( ) . isEmpty ( ) ) { _artist . setBackground ( red ) ; valid = false ; } else { _artist . setBackground ( Color . WHITE ) ; } if ( _title . getText ( ) . isEmpty ( ) ) { _title . setBackground ( red ) ; valid = false ; } else { _title . setBackground ( Color . WHITE ) ; } if ( _album . getText ( ) . isEmpty ( ) ) { _title . setBackground ( red ) ; valid = false ; } else { _title . setBackground ( Color . WHITE ) ; } if ( _genre . getText ( ) . isEmpty ( ) ) { _genre . setBackground ( red ) ; valid = false ; } else { _genre . setBackground ( Color . WHITE ) ; } if ( _year . getText ( ) . isEmpty ( ) ) { _year . setBackground ( red ) ; valid = false ; } try { Integer . parseInt ( _year . getText ( ) ) ; _year . setBackground ( Color . WHITE ) ; } catch ( NumberFormatException e ) { _year . setBackground ( red ) ; valid = false ; } if ( valid ) { getChildren ( ( DefaultMutableTreeNode ) ( ( DefaultMutableTreeNode ) _model . getRoot ( ) ) . getChildAt ( 0 ) ) ; getChildren ( ( DefaultMutableTreeNode ) ( ( DefaultMutableTreeNode ) _model . getRoot ( ) ) . getChildAt ( 1 ) ) ; System . out . println ( _children . size ( ) ) ; for ( DefaultMutableTreeNode child : _children ) { ( ( Song ) child . getUserObject ( ) ) . setArtist ( _artist . getText ( ) ) ; ( ( Song ) child . getUserObject ( ) ) . setTitle ( _title . getText ( ) ) ; ( ( Song ) child . getUserObject ( ) ) . setAlbum ( _album . getText ( ) ) ; ( ( Song ) child . getUserObject ( ) ) . setGenre ( _genre . getText ( ) ) ; ( ( Song ) child . getUserObject ( ) ) . setYear ( _year . getText ( ) ) ; ( ( Song ) child . getUserObject ( ) ) . save ( ) ; _model . nodeChanged ( child ) ; } _children . clear ( ) ; } } else { if ( _name . getText ( ) . isEmpty ( ) ) { _name . setBackground ( red ) ; } Enumeration < TreeNode > playlists = _node . getParent ( ) . children ( ) ; boolean exists = false ; while ( playlists . hasMoreElements ( ) ) { Playlist temp = ( Playlist ) ( ( DefaultMutableTreeNode ) playlists . nextElement ( ) ) . getUserObject ( ) ; if ( temp . equals ( new Playlist ( _name . getText ( ) ) ) && ! temp . equals ( _playlist ) ) exists = true ; } if ( ! exists ) { _name . setBackground ( Color . WHITE ) ; _playlist . setName ( _name . getText ( ) ) ; _model . nodeChanged ( _node ) ; } else { _name . setBackground ( red ) ; } } }
va	3	@ Test public void testWhacks ( ) { int minWhack = insetMap . getMinWhack ( ) ; int maxWhack = insetMap . getMaxWhack ( ) ; int numWhacks = insetMap . countWhacks ( ) ; assert . assertEquals ( maxWhack - minWhack + 1 , numWhacks , "Expected " + numWhacks + " whacks." ) ; int tally = 0 ; for ( int whack = minWhack ; whack < maxWhack + 1 ; whack ++ ) { int maxRow = insetMap . getMaxRowOfWhack ( whack ) ; assert . assertTrue ( maxRow < numRows , "Expected whack " + whack + " to not extend past row" + ( numRows - 1 ) ) ; int minRow = insetMap . getMinRowOfWhack ( whack ) ; assert . assertTrue ( minRow >= 0 , "Expected whack " + whack + " to not include negative rows." ) ; int current = maxRow - minRow + 1 ; assert . assertTrue ( current >= 1 , "Expected whack " + whack + " to include at least one row." ) ; if ( whack == minWhack ) { assert . assertTrue ( current <= 2 , "Expected first whack to not be longer than two rows." ) ; } if ( whack == maxWhack ) { assert . assertTrue ( current <= 2 , "Expected last whack to not be longer than two rows." ) ; } tally = tally + current ; } assert . assertEquals ( tally , insetMap . countCells ( ) , "Expected total cells in all whacks to equal total cells in all rows." ) ; }
va	0	public void setXzView ( boolean value ) { this . xzView = value ; }
va	2	public Collection < ? extends UIObject > getStyledChildren ( ) { Collection < UIObject > children = new HashSet < UIObject > ( ) ; for ( Sprite sprite : drawnSprites . values ( ) ) { children . add ( sprite . instance ) ; } return children ; }
va	8	public void Initialize ( ) { try { FileInputStream fstream = new FileInputStream ( "graph.txt" ) ; DataInputStream in = new DataInputStream ( fstream ) ; BufferedReader br = new BufferedReader ( new InputStreamReader ( in ) ) ; String strLine ; String str ; String max = "MAX" ; String node = "NODE" ; int j = 0 ; int source ; int target ; int distance ; while ( ( strLine = br . readLine ( ) ) != null ) { StringTokenizer tokens = new StringTokenizer ( strLine ) ; str = tokens . nextToken ( ) ; if ( max . equals ( str ) ) { str = tokens . nextToken ( ) ; MaxSize = Integer . parseInt ( str ) ; vertices = new Vertex [ MaxSize ] ; for ( int i = 0 ; i < MaxSize ; i ++ ) { vertices [ i ] = new Vertex ( ) ; vertices [ i ] . adjacencies = new ArrayList < Edge > ( ) ; } } else { if ( node . equals ( str ) ) { str = tokens . nextToken ( ) ; int id = Integer . parseInt ( str ) ; str = tokens . nextToken ( ) ; vertices [ j ] . set ( str , id ) ; j ++ ; } else { str = tokens . nextToken ( ) ; source = Integer . parseInt ( str ) ; str = tokens . nextToken ( ) ; target = Integer . parseInt ( str ) ; str = tokens . nextToken ( ) ; distance = Integer . parseInt ( str ) ; int sourceIdx = 0 ; int targetIdx = 0 ; for ( int i = 0 ; i < MaxSize ; i ++ ) { if ( vertices [ i ] . id == source ) sourceIdx = i ; if ( vertices [ i ] . id == target ) targetIdx = i ; } vertices [ sourceIdx ] . adjacencies . add ( new Edge ( vertices [ targetIdx ] , distance ) ) ; vertices [ sourceIdx ] . outdegree ++ ; } } } } catch ( Exception e ) { System . err . println ( "Error!: " + e ) ; } }
va	2	@ Override public boolean visit ( FlaggedCommand x ) { out = detailLevel ; Method method = x . getMethod ( ) ; Command cmd = method . getAnnotation ( Command . class ) ; if ( ! cmd . displayed ( ) && ! showHidden ) { return false ; } out . println ( ) ; out . println ( "%s : %s" , method . getName ( ) , cmd . help ( ) ) ; currentCommand = x ; return true ; }
va	4	public void placePlayerIntoList ( Player player ) { boolean wasInList = false ; for ( Quester quester : theQuesterList ) { if ( quester . theQuestersName . equalsIgnoreCase ( player . getName ( ) ) ) { wasInList = true ; } } if ( wasInList == false ) { Quester q = null ; if ( ! ( questPlayerStorage . keyExists ( player . getName ( ) ) ) ) { questPlayerStorage . setString ( player . getName ( ) , questDefaultPlayer ) ; q = new Quester ( questDefaultPlayer . split ( ":" ) , player ) ; } q = new Quester ( questPlayerStorage . getString ( player . getName ( ) ) . split ( ":" ) , player ) ; theQuesterList . add ( q ) ; placePlayerIntoRankedList ( q ) ; } }
va	1	public static int abs ( final int x ) { return ( x < 0 ) ? - x : x ; }
va	1	public static float distanceBetween ( Turret t , Object o2 ) { float x1 , x2 , y1 , y2 ; x1 = t . getX ( ) ; y1 = t . getY ( ) ; if ( o2 instanceof Ship ) { Ship s = ( Ship ) o2 ; x2 = s . getX ( ) ; y2 = s . getY ( ) ; } else { Sprite s = ( Sprite ) o2 ; x2 = s . getX ( ) ; y2 = s . getY ( ) ; } return distanceBetween ( x1 , y1 , x2 , y2 ) ; }
va	5	public FileInfo getFileInfo ( DefaultMutableTreeNode temp ) { FileInfo fileInfo = null ; fileInfoList = ClientLauncher . getFileMgr ( ) . getFileInfoList ( ) ; if ( temp . getLevel ( ) == 0 ) { return fileInfoList . get ( 0 ) ; } String name = temp . toString ( ) ; String parent = temp . getParent ( ) . toString ( ) ; String level = temp . getLevel ( ) + "" ; for ( FileInfo item : fileInfoList ) { if ( name . equals ( item . getName ( ) ) && parent . equals ( item . getParent ( ) ) && level . equals ( item . getDepth ( ) ) ) { return item ; } } return fileInfo ; }
va	6	public boolean getBoolean ( int index ) throws JSONException { Object object = this . get ( index ) ; if ( object . equals ( boolean . false ) || ( object instanceof String && ( ( String ) object ) . equalsIgnoreCase ( "false" ) ) ) { return false ; } else if ( object . equals ( boolean . true ) || ( object instanceof String && ( ( String ) object ) . equalsIgnoreCase ( "true" ) ) ) { return true ; } throw new JSONException ( "JSONArray[" + index + "] is not a boolean." ) ; }
