va	6	public String pillcaseSearch ( String pillId ) { String status = "" ; String payer = "" ; String pillAmount = "" ; String number = "" ; String pillName = "" ; String pillNum = "" ; String str = "select distinct pl.payer p.pill_num rl.status pl.pill_amount p.number p.pill_name from pill p pill_list pl recepit_list rl where pl.id='" + pillId + "' and  p.pill_num=pl.pill_id and rl.receipt_id=pl.id and rl.pillOrEquip='1' order by p.pill_name;" ; System . out . println ( "pillcaseSearch________________" + str ) ; try { conn = dbConn . getConn ( ) ; pstmt = conn . prepareStatement ( str ) ; ResultSet num = pstmt . executeQuery ( ) ; sb . append ( "<tr> <td>\u836F\u54C1\u540D\u79F0</td> <td>\u6570\u91CF</td> <td>\u5E93\u5B58\u6570\u91CF</td> </tr> " ) ; while ( num . next ( ) ) { pillNum = num . getString ( "pill_num" ) ; status = num . getString ( "status" ) ; payer = num . getString ( "payer" ) ; pillAmount = num . getString ( "pill_amount" ) ; number = num . getString ( "number" ) ; pillName = num . getString ( "pill_name" ) ; sb . append ( " <tr><td><input type=\"text\" value=\"" + pillName + "\" readonly><input type=\"text\" value=\"" + pillNum + "\" style=\"display:none\" name=\"pillid\"></td>" ) ; sb . append ( "<td><input type=\"text\" value=\"" + pillAmount + "\" name=\"pillAmount\" readonly> </td><td><input type=\"text\" value=\"" + number + "\" name=\"pillNum\" readonly></td></tr>" ) ; sb . append ( "<input type=\"text\"  value=\"" + pillId + "\" name=\"id\" style=\"display:none\">" ) ; } if ( status . equals ( "1" ) ) { sb . append ( "<tr> <td>\u4EA4\u6B3E\u72B6\u6001</td> <td colspan=\"2\"><input type=\"text\" value=\"\u672A\u4EA4\u6B3E\" readonly></td> </tr>" ) ; } else if ( status . equals ( "2" ) ) { sb . append ( "<tr> <td>\u4EA4\u6B3E\u72B6\u6001</td> <td colspan=\"2\"><input type=\"text\" value=\"\u5DF2\u4EA4\u6B3E\" readonly></td> </tr>" ) ; } if ( payer == null ) { sb . append ( "<tr> <td>\u4ED8\u836F\u72B6\u6001</td> <td colspan=\"2\" id=\"fyzt\">\u672A\u4ED8\u836F</td> </tr>" ) ; } else if ( payer != null ) { sb . append ( "<tr> <td>\u4ED8\u836F\u72B6\u6001</td> <td colspan=\"2\" id=\"fyzt\">\u5DF2\u4ED8\u836F</td> </tr>" ) ; } pstmt . close ( ) ; dbConn . close ( conn ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; } return sb . toString ( ) ; }
va	3	public static DummyKVStorable [ ] merge ( DummyKVStorable [ ] ... arrays ) { int size = 0 ; for ( DummyKVStorable [ ] A : arrays ) size += A . length ; DummyKVStorable [ ] all = new DummyKVStorable [ size ] ; int k = 0 ; for ( DummyKVStorable [ ] A : arrays ) { for ( DummyKVStorable d : A ) { all [ k ++ ] = d ; } } return all ; }
va	2	protected void pausePlayback ( ) { if ( m_line != null ) { if ( m_status == PLAYING ) { m_line . stop ( ) ; m_status = PAUSED ; notifyEvent ( BasicPlayerEvent . PAUSED , getEncodedStreamPosition ( ) , - 1 , null ) ; m_line . drain ( ) ; } } }
va	9X	public void checkCollisionsWithEnemies ( ArrayList < Enemy > list , Level1State state ) { for ( int i = 0 ; i < list . size ( ) ; i ++ ) { double w = .5 * ( list . get ( i ) . getCWidth ( ) + getWidth ( ) ) ; double h = .5 * ( list . get ( i ) . getCHeight ( ) + getHeight ( ) ) ; double dx = list . get ( i ) . getCCenterX ( ) - getCenterX ( ) ; double dy = list . get ( i ) . getCCenterY ( ) - getCenterY ( ) ; if ( Math . abs ( dx ) <= w && Math . abs ( dy ) <= h ) { boolean hack = false ; double wy = w * dy ; double hx = h * dx ; if ( wy > hx ) { if ( wy > - hx ) { if ( list . get ( i ) . getKilledByTop ( ) ) { hack = true ; if ( list . get ( i ) . hit ( state . getPlayerState ( ) , this ) ) { } } else hit ( ) ; } else { if ( ! hack ) hit ( ) ; } } else { if ( wy > - hx ) { if ( ! hack ) hit ( ) ; } else { if ( ! hack ) hit ( ) ; } } } } }
va	8	public void decode ( InputStream stream , int length , CharBuffer buffer ) throws IllegalArgumentException , IOException { if ( stream == null ) throw new IllegalArgumentException ( "stream cannot be null" ) ; if ( length < 0 ) throw new IllegalArgumentException ( "length [" + length + "] must be >= 0." ) ; if ( buffer == null ) throw new IllegalArgumentException ( "buffer cannot be null and must be a CharBuffer with a large enough capacity to hold at least 'length' (" + length + ") characters." ) ; if ( length > buffer . capacity ( ) ) throw new IllegalArgumentException ( "length [" + length + "] is larger than the capacity [" + buffer . capacity ( ) + "] of the given buffer; the CharBuffer must be big enough to contain all the characters decoded from the given InputStream." ) ; if ( length == 0 ) buffer . clear ( ) ; else { bBuffer . clear ( ) ; buffer . clear ( ) ; decoder . reset ( ) ; int read = 0 ; while ( length > 0 && ( read = stream . read ( rBuffer , 0 , length ) ) != - 1 ) { length -= read ; bBuffer . position ( 0 ) ; bBuffer . limit ( read ) ; decoder . decode ( bBuffer , buffer , ( length == 0 ) ) ; } if ( length > 0 ) throw new IOException ( "End of Stream encountered before all requested bytes [" + ( length + read ) + "] could be read. Unable to read the last " + length + " remaining bytes." ) ; decoder . flush ( buffer ) ; } }
va	0	public void setProduto ( Produto produto ) { this . produto = produto ; }
va	6	private void startLevel ( ) { if ( currentlesson . isNoteLevel ( ) ) { if ( ! noteLevel . isMessageEmpty ( ) ) { levelMessage . setTitle ( bundle . getString ( "_information" ) ) ; textlevelMessage . setText ( "  " + noteLevel . getMessage ( ) + "  " ) ; levelMessage . pack ( ) ; levelMessage . setLocationRelativeTo ( this ) ; levelMessage . setVisible ( true ) ; } else { startButton . doClick ( ) ; } } else if ( currentlesson . isRhythmLevel ( ) ) { if ( ! rhythmLevel . isMessageEmpty ( ) ) { levelMessage . setTitle ( bundle . getString ( "_information" ) ) ; textlevelMessage . setText ( "  " + rhythmLevel . getMessage ( ) + "  " ) ; levelMessage . pack ( ) ; levelMessage . setLocationRelativeTo ( this ) ; levelMessage . setVisible ( true ) ; } else { startButton . doClick ( ) ; } } else if ( currentlesson . isScoreLevel ( ) ) { if ( ! scoreLevel . isMessageEmpty ( ) ) { levelMessage . setTitle ( bundle . getString ( "_information" ) ) ; textlevelMessage . setText ( "  " + scoreLevel . getMessage ( ) + "  " ) ; levelMessage . pack ( ) ; levelMessage . setLocationRelativeTo ( this ) ; levelMessage . setVisible ( true ) ; } else { startButton . doClick ( ) ; } } }
va	6	protected KeyboardEventListener parseKeyboardListener ( String keyboardListenerString ) { KeyboardEventListener rc = null ; if ( ! "" . equals ( keyboardListenerString ) ) { switch ( keyboardListenerString ) { case ( "SplashScreenKeyboardEventListener" ) : rc = new SplashScreenKeyboardEventListener ( ) ; break ; case ( "MenuKeyboardEventListener" ) : rc = new MenuKeyboardEventListener ( ) ; break ; case ( "OptionsMenuItemKeyboardEventListener" ) : rc = new OptionsMenuItemKeyboardEventListener ( ) ; break ; case ( "ExitMenuItemKeyboardEventListener" ) : rc = new ExitMenuItemKeyboardEventListener ( ) ; break ; case ( "OptionsMenuBackKeyboardEventListener" ) : rc = new OptionsMenuBackKeyboardEventListener ( ) ; break ; default : } } return rc ; }
va	4	private List < Word > getCandidates ( Word word , Map < Character , Character > l2lEncrypt ) { List < Word > candidates = new LinkedList < Word > ( ) ; Map < Integer , List < Word >> wordsMap = dict . get ( word . getLength ( ) ) ; if ( wordsMap == null ) { return candidates ; } List < Word > words = wordsMap . get ( word . getNbrSimilarLetters ( ) ) ; if ( words == null ) { return candidates ; } for ( Word w : words ) { if ( w . equals ( word , l2lEncrypt ) ) { candidates . add ( w ) ; } } return candidates ; }
va	7	public static void main ( String [ ] args ) { boolean all_right ; all_right = true ; String [ ] p0 ; int p1 ; int p2 ; p0 = new String [ ] { "kenta" , "kentaro" , "ken" } ; p1 = 2 ; p2 = 3 ; all_right = KawigiEdit_RunTest ( 0 , p0 , p1 , true , p2 ) && all_right ; p0 = new String [ ] { "hideo" , "hideto" , "hideki" , "hide" } ; p1 = 2 ; p2 = 6 ; all_right = KawigiEdit_RunTest ( 1 , p0 , p1 , true , p2 ) && all_right ; p0 = new String [ ] { "aya" , "saku" , "emi" , "ayane" , "sakura" , "emika" , "sakurako" } ; p1 = 3 ; p2 = 24 ; all_right = KawigiEdit_RunTest ( 2 , p0 , p1 , true , p2 ) && all_right ; p0 = new String [ ] { "taro" , "jiro" , "hanako" } ; p1 = 2 ; p2 = 0 ; all_right = KawigiEdit_RunTest ( 3 , p0 , p1 , true , p2 ) && all_right ; p0 = new String [ ] { "alice" , "bob" , "charlie" } ; p1 = 1 ; p2 = 6 ; all_right = KawigiEdit_RunTest ( 4 , p0 , p1 , true , p2 ) && all_right ; p0 = new String [ ] { "ryota" , "ryohei" , "ryotaro" , "ryo" , "ryoga" , "ryoma" , "ryoko" , "ryosuke" , "ciel" , "lun" , "ryuta" , "ryuji" , "ryuma" , "ryujiro" , "ryusuke" , "ryutaro" , "ryu" , "ryuhei" , "ryuichi" , "evima" } ; p1 = 3 ; p2 = 276818566 ; all_right = KawigiEdit_RunTest ( 5 , p0 , p1 , true , p2 ) && all_right ; if ( all_right ) { System . out . println ( "You're a stud (at least on the example cases)!" ) ; } else { System . out . println ( "Some of the test cases had errors." ) ; } }
va	8	private String subscribe ( String msg , iKPIC_subscribeHandler2 handler ) { deb_print ( "KpCore:subscribe method" ) ; int ret = 0 ; System . out . println ( "HERE!" ) ; if ( handler == null ) { this . KP_ERROR_ID = this . ERR_EVENT_HANDLER_NULL ; err_print ( "EVENT HANDLER IS NULL!!!" ) ; return null ; } deb_print ( "KpCore:SSAP:XML MESSAGE:\n" + msg ) ; deb_print ( "KpCore:SSAP:Open connection..." ) ; ret = openConnect ( ) ; if ( ret != this . ERR_Conected ) { this . KP_ERROR_ID = ret ; err_print ( "ERROR:subscribeRDF:connection error:" + this . getErrMess ( ) ) ; return null ; } deb_print ( "KpCore:SSAP:Send message..." ) ; ret = send ( msg ) ; if ( ret != this . ERR_MsgSent ) { this . KP_ERROR_ID = ret ; err_print ( "ERROR:subscribeRDF:send error:" + this . getErrMess ( ) ) ; return null ; } deb_print ( "KpCore:SSAP:Message Sent..." ) ; int buffsize = 4 * 1024 ; StringBuilder builder = new StringBuilder ( ) ; char [ ] buffer = new char [ buffsize ] ; msg = "" ; int charRead = 0 ; try { while ( ( charRead = in . read ( buffer , 0 , buffer . length ) ) != ( - 1 ) ) { builder . append ( buffer , 0 , charRead ) ; msg = builder . toString ( ) ; if ( msg . contains ( "<SSAP_message>" ) && msg . contains ( "</SSAP_message>" ) ) { if ( this . xmlTools . isSubscriptionConfirmed ( msg ) ) { this . KP_ERROR_ID = this . ERR_Subscription_DONE ; System . out . println ( "1" ) ; kpSocket . setKeepAlive ( true ) ; Subscription s = new Subscription ( kpSocket , handler ) ; return msg ; } else { System . out . println ( "[90] UNKNOW MESSAGE:" + msg ) ; break ; } } } deb_print ( "KpCore:readByteXByteSIBmsg:READ LOOP TERMINATED" ) ; closeConnection ( ) ; } catch ( Exception e ) { err_print ( "KPICore:readByteXByteSIBmsg:Exception on EVENT HANDLER:RECEIVE:\n" + e ) ; this . KP_ERROR_ID = this . ERR_SOCKET_TIMEOUT ; } this . KP_ERROR_ID = this . ERR_Subscription_NOT_DONE ; deb_print ( "KpCore:SSAP:Message received:(" + msg + ")" ) ; return msg ; }
va	2	public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; int current = first ; while ( current != last ) { sb . append ( arr [ current ] . toString ( ) + " " ) ; if ( ++ current >= arr . length ) { current = 0 ; } } return sb . toString ( ) ; }
va	4	public char [ ] minCharCutMulti ( int numOfTracks ) { Debugger . debug ( "min cut set:***************\n" , 2 , debugLevel ) ; HashSet < ArrayList < Transition >> minCutSet = minCutMulti ( numOfTracks ) ; StringBuilder b = new StringBuilder ( ) ; for ( ArrayList < Transition > tracksArray : minCutSet ) { Transition tracks [ ] = new Transition [ numOfTracks ] ; for ( int i = 0 ; i < tracksArray . size ( ) ; i ++ ) { tracks [ tracksArray . get ( i ) . track - 1 ] = tracksArray . get ( i ) ; } for ( int i = 0 ; i < tracks . length ; i ++ ) { b . append ( "track" ) . append ( i + 1 ) ; b . append ( ": [" ) ; if ( tracks [ i ] . min != tracks [ i ] . max ) { Transition . appendCharString ( tracks [ i ] . min , b ) ; b . append ( "  " ) ; Transition . appendCharString ( tracks [ i ] . max , b ) ; } else Transition . appendCharString ( tracks [ i ] . min , b ) ; b . append ( "]" ) ; b . append ( "   " ) ; } b . append ( "\n" ) ; } Debugger . debug ( b . toString ( ) , 0 , debugLevel ) ; return null ; }
va	6	public int partitionIt ( int left , int right , long pivot ) { int leftptr = left - 1 ; int rightptr = right + 1 ; while ( true ) { while ( leftptr < right && theArray [ ++ leftptr ] < pivot ) { } while ( rightptr > left && theArray [ -- rightptr ] > pivot ) { } if ( leftptr >= rightptr ) { break ; } else { swap ( leftptr , rightptr ) ; } } return leftptr ; }
va	3	public static void insertTrainingStatus ( TrainingStatus status , Student student ) { boolean assigned = status . getAssigned ( ) ; String assignedDate = null ; if ( assigned == true ) assignedDate = status . getAssignedDate ( ) ; String supervisor = status . getSupervisor ( ) ; String thesis = status . getThesisTopic ( ) ; boolean plan = status . getIndividualPlan ( ) ; String approvalDate = status . getApprovalDate ( ) ; long studentId = student . getStudentId ( ) ; String insertSQL = "insert into Monitoring " + "(Date) " + "values (?)" ; try { SqlActions . initJDBC ( ) ; dbConn = SqlActions . getDBConn ( ) ; if ( dbConn == null ) throw new SQLException ( "TrainingStatus not inserted" ) ; dbPrepStmnt = dbConn . prepareStatement ( "use phdStudent;" ) ; dbPrepStmnt . executeUpdate ( ) ; dbPrepStmnt = dbConn . prepareStatement ( insertSQL , Statement . RETURN_GENERATED_KEYS ) ; dbPrepStmnt . setString ( 1 , status . getMonitoring ( ) . getMonitoringDate ( ) ) ; dbPrepStmnt . executeUpdate ( ) ; dbRset = dbPrepStmnt . getGeneratedKeys ( ) ; dbRset . next ( ) ; status . getMonitoring ( ) . setMonitoringId ( dbRset . getLong ( 1 ) ) ; insertSQL = "insert into TrainingStatus " + "(studentId  assigned  assignedDate  supervisor  thesis " + "individualPlan  approvalDate  monitoringId) " + "values (?  ?  ?  ?  ?  ?  ?  ?)" ; dbPrepStmnt = dbConn . prepareStatement ( insertSQL , Statement . RETURN_GENERATED_KEYS ) ; dbPrepStmnt . setLong ( 1 , studentId ) ; dbPrepStmnt . setBoolean ( 2 , assigned ) ; dbPrepStmnt . setString ( 3 , assignedDate ) ; dbPrepStmnt . setString ( 4 , supervisor ) ; dbPrepStmnt . setString ( 5 , thesis ) ; dbPrepStmnt . setBoolean ( 6 , plan ) ; dbPrepStmnt . setString ( 7 , approvalDate ) ; dbPrepStmnt . setLong ( 8 , status . getMonitoring ( ) . getMonitoringId ( ) ) ; dbPrepStmnt . executeUpdate ( ) ; dbRset = dbPrepStmnt . getGeneratedKeys ( ) ; dbRset . next ( ) ; status . setTrainingStatusId ( dbRset . getLong ( 1 ) ) ; } catch ( SQLException ex ) { SqlActions . handleEx ( ex ) ; } finally { SqlActions . closeConnections ( dbConn , dbStmnt , dbRs , dbRset ) ; } }
va	6	public static void LoadReviewsFromSQL ( ) { DBUtil db1 = new DBUtil ( ) ; Logger . getInstance ( ) . getElapseTime ( true ) ; String sql = "select * from sentences" ; ResultSet rs1 = db1 . executeQuerySQL ( sql ) ; try { while ( rs1 . next ( ) ) { String filename = TextUtil . decode ( rs1 . getString ( "filename" ) ) ; int curSentIndex = rs1 . getInt ( "sent_index" ) ; if ( ! dataHash . containsKey ( filename ) ) { RestaurantEntry tmp = new RestaurantEntry ( ) ; tmp . StartSentIndex = curSentIndex ; dataHash . put ( filename , tmp ) ; } else { dataHash . get ( filename ) . EndSentIndex = curSentIndex ; } int revIndex = rs1 . getInt ( "revindex" ) ; double rating = rs1 . getDouble ( "revrating" ) ; if ( dataHash . get ( filename ) . ReviewMap . get ( revIndex ) == null ) { ReviewEntry tmp = new ReviewEntry ( ) ; tmp . setStartSentIndex ( curSentIndex ) ; tmp . setRating ( rating ) ; dataHash . get ( filename ) . ReviewMap . put ( revIndex , tmp ) ; } else { dataHash . get ( filename ) . ReviewMap . get ( revIndex ) . setEndSentIndex ( curSentIndex ) ; } } } catch ( SQLException e ) { e . printStackTrace ( ) ; } Logger . getInstance ( ) . getElapseTime ( true ) ; sql = "select * from extractions" ; rs1 = db1 . executeQuerySQL ( sql ) ; try { while ( rs1 . next ( ) ) { int sentIndex = rs1 . getInt ( "sentindex" ) ; String attr = rs1 . getString ( "attr" ) ; stemmer . setCurrent ( attr ) ; stemmer . stem ( ) ; attr = stemmer . getCurrent ( ) ; String value = rs1 . getString ( "value" ) ; Extraction tmp = new Extraction ( value , attr , 0 ) ; tmp . setSentIndex ( sentIndex ) ; insertIntoHash ( tmp , sentIndex ) ; } } catch ( SQLException e ) { e . printStackTrace ( ) ; } Logger . getInstance ( ) . getElapseTime ( true ) ; db1 . rundown ( ) ; }
va	6	public void scores ( Player player ) { switch ( player . getScore ( ) ) { case LOVE : player . setScore ( FIFTEEN ) ; break ; case FIFTEEN : player . setScore ( THIRTY ) ; break ; case THIRTY : determineFortyOrDeuce ( player ) ; break ; case DEUCE : determineAdvantageOrDeuce ( player ) ; break ; case FORTY : case ADVANTAGE : player . setScore ( WIN ) ; } }
va	7	public void actionPerformed ( ActionEvent ae ) { ADocument aDoc = ( ADocument ) textPane . getDocument ( ) ; Clipboard clipboard = Toolkit . getDefaultToolkit ( ) . getSystemClipboard ( ) ; ^ ^ = textPane . getCaret ( ) ; int . = ^ . getDot ( ) ; int mark = ^ . getMark ( ) ; if ( . != mark ) return ; ADocumentFragment fragment = null ; try { Transferable tr = clipboard . getContents ( this ) ; DataFlavor flavor = new DataFlavor ( ADocumentFragment . MIME_TYPE ) ; if ( tr . isDataFlavorSupported ( flavor ) ) fragment = ( ADocumentFragment ) tr . getTransferData ( flavor ) ; else { flavor = new DataFlavor ( "application/x-java-serialized-object; class=java.lang.String" ) ; if ( tr . isDataFlavorSupported ( flavor ) ) { String s = new String ( ( ( ( String ) tr . getTransferData ( flavor ) ) ) ) ; fragment = new ADocumentFragment ( s , null , null ) ; } } } catch ( UnsupportedFlavorException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } catch ( ClassNotFoundException e ) { e . printStackTrace ( ) ; } if ( fragment == null ) return ; aDoc . startCompoundEdit ( ) ; ADocument . pasteADocFragment ( aDoc , . , fragment ) ; aDoc . endCompoundEdit ( null ) ; aDoc . fireADocumentChanged ( ) ; }
va	2	public void setAttributes ( Point leftest , Point rightest ) { if ( leftest != null ) { leftAngle = Tools . round ( src . getDirection ( leftest ) , 10000 ) ; leftDist = src . getDistance ( leftest ) ; } if ( rightest != null ) { rightAngle = Tools . round ( src . getDirection ( rightest ) , 10000 ) ; rightDist = src . getDistance ( rightest ) ; } }
va	8	@ Override public void visit ( CannyEvent cannyEvent ) { try { if ( model . getCurrentImagePath ( ) == null || model . getCurrentImagePath ( ) . isEmpty ( ) ) { throw new Exception ( "Brak pliku wej\u015Bciowego!" ) ; } String low_treshold_str = defaultViewChanger . showCannyParametersDialog ( true ) ; float low_treshold = 0.0f ; try { if ( low_treshold_str == null ) throw new NumberFormatException ( ) ; low_treshold = new float ( low_treshold_str ) ; } catch ( NumberFormatException e ) { System . out . println ( "Przyjmuje warto\u015B\u0107 domy\u015Bln\u0105 low_treshold: " + 0.5f ) ; errorDialog . showErrorDialog ( "B\u0142\u0119dnie wpisania warto\u015B\u0107! Przyjmuje warto\u015B\u0107 domy\u015Bln\u0105 low_treshold: " + 0.5f ) ; low_treshold = 0.5f ; } String high_treshold_str = defaultViewChanger . showCannyParametersDialog ( false ) ; float high_treshold = 1.0f ; try { if ( high_treshold_str == null ) throw new NumberFormatException ( ) ; high_treshold = new float ( high_treshold_str ) ; } catch ( NumberFormatException e ) { System . out . println ( "Przyjmuje warto\u015B\u0107 domy\u015Bln\u0105 high_treshold: " + 1.0f ) ; errorDialog . showErrorDialog ( "B\u0142\u0119dnie wpisania warto\u015B\u0107! Przyjmuje warto\u015B\u0107 domy\u015Bln\u0105 high_treshold: " + 1.0f ) ; high_treshold = 1.0f ; } Canny canny = new Canny ( low_treshold , high_treshold ) ; BufferedImage source ; System . out . println ( "Wczytuje plik \u017Ar\u00F3d\u0142owy..." ) ; source = ImageIO . read ( new File ( model . getCurrentImagePath ( ) ) ) ; System . out . println ( "Uruchamiam algorytm..." ) ; BufferedImage canny_image = canny . process ( source ) ; String output_name = "output/canny.png" ; saveImageToFile ( output_name , canny_image ) ; System . out . println ( "Wy\u015Bwietlam zdj\u0119cie..." ) ; defaultViewChanger . showModImage ( output_name ) ; } catch ( Exception e ) { if ( defaultViewChanger != null ) defaultViewChanger . showInformationDialog ( e . getMessage ( ) , "B\u0142\u0105d" , JOptionPane . ERROR_MESSAGE ) ; e . printStackTrace ( ) ; } }
va	6	@ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; PairImpl < ? > other = ( PairImpl < ? > ) obj ; return Tuples . equals ( _first , other . _first ) && Tuples . equals ( _second , other . _second ) ; }
va	3	private String findTag ( String text , String startToken , String endToken , int fromIndex ) { int startIndex = text . indexOf ( startToken , fromIndex ) ; int endIndex = text . indexOf ( endToken , startIndex ) ; if ( startIndex >= 0 && endIndex > 0 && endIndex > startIndex ) return text . substring ( startIndex , endIndex + endToken . length ( ) ) ; return null ; }
va	7	private void createFiles ( boolean test , HashMap < String , PrintToFile > filesMap , String cat ) { try { BufferedReader input = new BufferedReader ( new FileReader ( Classify . dataPath + "/rawData/train" + cat + ".csv" ) ) ; String line ; line = input . readLine ( ) ; HashMap < String , ContractorHolder > contractors = new HashMap < String , ContractorHolder > ( ) ; while ( ( line = input . readLine ( ) ) != null ) { String [ ] tmpAr = line . split ( "\" \"" ) ; for ( int i = 0 ; i < tmpAr . length ; i ++ ) { tmpAr [ i ] = tmpAr [ i ] . replaceAll ( "\"" , "" ) ; } String contractor = tmpAr [ 2 ] . trim ( ) ; ContractorHolder contractorHolder = contractors . get ( contractor ) ; if ( contractorHolder == null ) { contractorHolder = new ContractorHolder ( ) ; contractors . put ( contractor , contractorHolder ) ; } String jobType = tmpAr [ 0 ] . trim ( ) ; String opening = tmpAr [ 1 ] . trim ( ) ; String client = tmpAr [ 30 ] . trim ( ) ; ClientHolder curClientHolder = clientHistory . get ( client ) ; if ( curClientHolder == null ) { curClientHolder = new ClientHolder ( ) ; clientHistory . put ( client , curClientHolder ) ; } createInstance ( filesMap . get ( ( test ? "test" : "train" ) + jobType ) , tmpAr , contractorHolder , curClientHolder , contractor ) ; if ( test ) filesMap . get ( "testHolder" + jobType ) . writeToFile ( opening + " " + contractor ) ; } } catch ( IOException e ) { e . printStackTrace ( ) ; } }
va	2	public void open ( URL location , String referer ) throws IOException { String host = location . getHost ( ) ; if ( referer == null ) referer = "http://" + host + "/" ; String path = location . getPath ( ) + "?" + location . getQuery ( ) ; int port = location . getPort ( ) ; if ( port == - 1 ) port = 80 ; socket . setSoTimeout ( 5000 ) ; socket . connect ( new InetSocketAddress ( host , port ) , 5000 ) ; PrintWriter pw = new PrintWriter ( socket . getOutputStream ( ) , true ) ; pw . println ( "GET " + path + " HTTP/1.1" ) ; pw . println ( "Host: " + host ) ; pw . println ( "Referer: " + referer ) ; pw . println ( "Accept: */*" ) ; pw . println ( "User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)" ) ; pw . println ( "Connection: Keep-Alive" ) ; pw . println ( ) ; instream = socket . getInputStream ( ) ; getResponse ( ) ; }
va	8	public void importGraphInfo ( String result ) throws IOException { if ( this . getType ( ) == InfoEnum . ModelCategory . ATTACK_MODEL . name ( ) ) { List < String > elements = Arrays . asList ( result . split ( "\n" ) ) ; for ( String element : elements ) { if ( element . startsWith ( "element" ) ) { List < String > factors = Arrays . asList ( element . split ( ";" ) ) ; if ( this . findElementById ( factors . get ( 1 ) ) == null ) { RequirementElement elem = parseAttackElementInfo ( factors ) ; this . getElements ( ) . add ( elem ) ; } } } for ( String element : elements ) { if ( element . startsWith ( "link" ) ) { List < String > factors = Arrays . asList ( element . split ( ";" ) ) ; if ( this . findLinkById ( factors . get ( 1 ) ) == null ) { RequirementLink link = parseAttackModelLinkInfo ( factors ) ; this . getLinks ( ) . add ( link ) ; } } } } for ( Element elem : this . getElements ( ) ) { reprocessRequirementElement ( ( RequirementElement ) elem ) ; } }
va	8	public static void changeProtocolMetadataFile ( String tmpMetadataFile , String identifier ) { String newMetadataFile = "/tmp/PRO" + System . currentTimeMillis ( ) + ".xml" ; FileWriter fichero = null ; PrintWriter pw = null ; File archivo = new File ( tmpMetadataFile ) ; try { fichero = new FileWriter ( newMetadataFile ) ; BufferedReader in = new BufferedReader ( new FileReader ( archivo ) ) ; pw = new PrintWriter ( fichero ) ; String data = "" ; data = in . readLine ( ) ; String spaces = "" ; boolean secId = false ; while ( data != null ) { if ( data . indexOf ( "<identifier>" ) != - 1 ) { secId = true ; } int s = data . indexOf ( "<entry>" ) ; if ( s != - 1 && secId ) { secId = false ; for ( int i = 0 ; i < s ; i ++ ) spaces += " " ; data = spaces + "<entry>" + identifier + "</entry>" ; } pw . println ( data ) ; data = in . readLine ( ) ; } in . close ( ) ; } catch ( IOException e ) { System . out . println ( "unable to find file" ) ; } finally { try { if ( null != fichero ) { fichero . close ( ) ; Process proc = Runtime . getRuntime ( ) . exec ( "cp " + newMetadataFile + " " + tmpMetadataFile ) ; } } catch ( Exception e2 ) { e2 . printStackTrace ( ) ; } } }
va	9X	final public void edgeRHS ( ) throws ParseException { ASTedgeRHS jjtn000 = new ASTedgeRHS ( JJTEDGERHS ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; try { edgeop ( ) ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case ID : node_id ( ) ; break ; case SUBGRAPH : case { : subgraph ( ) ; break ; default : jj_la1 [ 11 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case EDGE_UNDIRECTED : case EDGE_DIRECTED : edgeRHS ( ) ; break ; default : jj_la1 [ 12 ] = jj_gen ; ; } } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; } } }
va	2	public ArrayList < Tile > getAdjacentTiles ( Tile tile ) { ArrayList < Tile > adjacentTiles = new ArrayList < Tile > ( ) ; for ( Direction direction : Direction . values ( ) ) { Tile nextTile = getTile ( tile . getGridX ( ) + direction . getXOffset ( ) , tile . getGridY ( ) + direction . getYOffset ( ) ) ; if ( nextTile != null ) { adjacentTiles . add ( nextTile ) ; } } return adjacentTiles ; }
va	0	public JButton getButtonClose ( ) { return btnClose ; }
va	7	public void insertAndIndexDocument ( Document doc ) throws IOException , ClassNotFoundException { Node currentNode = null ; Node previousNode = null ; int sentenceNumber = 0 ; int wordNumber = 0 ; Transaction tx = graphDb . beginTx ( ) ; try { ArrayList < Sentence > sentences = doc . getSentences ( ) ; for ( Sentence sentence : sentences ) { wordNumber = 0 ; ArrayList < Word > words = sentence . getWords ( ) ; for ( Word word : words ) { currentNode = findNodeByProperty ( Neo4jNode . WORD_PROPERTY , word . getContent ( ) ) ; if ( currentNode == null ) { Neo4jNode newNode = new Neo4jNode ( word . getContent ( ) ) ; ArrayList < String > documentEntity = new ArrayList < String > ( ) ; documentEntity . add ( "1" ) ; documentEntity . add ( String . valueOf ( sentenceNumber ) + "_" + String . valueOf ( wordNumber ) ) ; newNode . addToDocumentTable ( doc . getId ( ) , documentEntity ) ; insertAndIndexNode ( newNode ) ; currentNode = findNodeByProperty ( Neo4jNode . WORD_PROPERTY , word . getContent ( ) ) ; } else { Neo4jNode existingNode = convertToNeo4jNode ( currentNode ) ; if ( existingNode . isInDocumentTable ( doc . getId ( ) ) ) { ArrayList < String > documentEntity = existingNode . getDocumentEntity ( doc . getId ( ) ) ; int tf = Integer . parseInt ( documentEntity . get ( 0 ) ) + 1 ; documentEntity . set ( 0 , String . valueOf ( tf ) ) ; documentEntity . add ( String . valueOf ( sentenceNumber ) + "_" + String . valueOf ( wordNumber ) ) ; existingNode . addToDocumentTable ( doc . getId ( ) , documentEntity ) ; } else { ArrayList < String > documentEntity = new ArrayList < String > ( ) ; documentEntity . add ( "1" ) ; documentEntity . add ( String . valueOf ( sentenceNumber ) + "_" + String . valueOf ( wordNumber ) ) ; existingNode . addToDocumentTable ( doc . getId ( ) , documentEntity ) ; } modifyAndIndexNode ( existingNode , currentNode ) ; currentNode = findNodeByProperty ( Neo4jNode . WORD_PROPERTY , word . getContent ( ) ) ; } if ( currentNode != null && previousNode != null && ! doesRelationsExist ( previousNode , currentNode , "document_" + doc . getId ( ) ) ) { createRelationship ( previousNode , currentNode , "document_" + doc . getId ( ) ) ; } previousNode = currentNode ; wordNumber ++ ; } sentenceNumber ++ ; } tx . success ( ) ; } finally { tx . finish ( ) ; } }
va	0	public ScoreLevel ( ) { this . Id = 0 ; this . message = "" ; this . whole = true ; this . half = true ; this . dottedhalf = false ; this . quarter = false ; this . eighth = false ; this . silence = true ; this . triplet = false ; this . currentKey = "treble" ; this . randomtonality = false ; this . currenttonality = new Tonality ( 0 , "" ) ; this . pitcheslist = new ArrayList < Integer > ( ) ; this . notetype = "notes" ; this . nbnotes = 9 ; this . timeSignNumerator = 4 ; this . timeSignDenominator = 4 ; this . timeDivision = 1 ; this . speed = 28 ; this . metronome = true ; this . beats = false ; }
va	2	public static Kind find ( String lowerCase ) { for ( Kind k : Kind . values ( ) ) { if ( k . name . equalsIgnoreCase ( lowerCase ) ) { return k ; } } return null ; }
va	7	@ Override public void run ( ) throws Exception { try { ConfigFile importFile = new ConfigFile ( plugin ) ; ConfigSQL importSQL = new ConfigSQL ( plugin ) ; if ( ! importSQL . checkDatabase ( ) ) { throw new Exception ( "Could not connect to database !" ) ; } for ( String player : importFile . getAllPlayers ( ) ) { for ( String group : importFile . getPlayerGroups ( player ) ) { importSQL . addPlayerGroup ( player , group ) ; } for ( Entry < String , boolean > permission : importFile . getPlayerPermissions ( player ) . entrySet ( ) ) { importSQL . addPlayerPermission ( player , permission . getKey ( ) , permission . getValue ( ) ) ; } for ( String world : importFile . getPlayerWorlds ( player ) ) { for ( Entry < String , boolean > permission : importFile . getPlayerPermissions ( player , world ) . entrySet ( ) ) { importSQL . addPlayerPermission ( player , world , permission . getKey ( ) , permission . getValue ( ) ) ; } } } } catch ( Exception e ) { throw e ; } }
va	5	@ Override public boolean equals ( Object obj ) { if ( obj == null ) { return false ; } if ( getClass ( ) != obj . getClass ( ) ) { return false ; } final SondageReponse other = ( SondageReponse ) obj ; if ( this . id != other . id ) { return false ; } if ( this . id_sondage != other . id_sondage ) { return false ; } if ( this . choix != other . choix ) { return false ; } return true ; }
va	3	protected Backpropagation calculateErrorAndUpdateHiddenNeurons ( ) { for ( int i = this . network . getLayersNum ( ) - 2 ; i > 0 ; i -- ) for ( INeuron neuron : this . network . getLayerAt ( i ) . getNeurons ( ) ) if ( neuron instanceof ErrorNeuron ) { ErrorNeuron errorNeuron = ( ErrorNeuron ) neuron ; this . updateNeuronWeights ( errorNeuron . setError ( this . calculateHiddenNeuronError ( errorNeuron ) ) ) ; } return this ; }
va	6	@ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( "OAuth 2.0 Token:" ) ; sb . append ( "\n  type: " ) ; sb . append ( type . toString ( ) ) ; if ( accessToken != null ) { sb . append ( "\n  access token: " ) ; sb . append ( accessToken ) ; } if ( refreshToken != null ) { sb . append ( "\n  refresh token: " ) ; sb . append ( refreshToken ) ; } if ( keyId != null ) { sb . append ( "\n  kid: " ) ; sb . append ( keyId ) ; } if ( macKey != null ) { sb . append ( "\n  mac key: " ) ; sb . append ( macKey ) ; } if ( macAlgorithm != null ) { sb . append ( "\n  mac algorithm: " ) ; sb . append ( macAlgorithm ) ; } if ( expiresIn != - 1 ) { sb . append ( "\n  expires in: " ) ; sb . append ( expiresIn ) ; } return sb . toString ( ) ; }
va	7	public Object nextValue ( ) throws JSONException { char c = this . nextClean ( ) ; String string ; switch ( c ) { case " : case ' : return this . nextString ( c ) ; case { : this . back ( ) ; return new JSONObject ( this ) ; case [ : this . back ( ) ; return new JSONArray ( this ) ; } StringBuffer sb = new StringBuffer ( ) ; while ( c >=   && " :]}/\\\"[{;=#" . indexOf ( c ) < 0 ) { sb . append ( c ) ; c = this . next ( ) ; } this . back ( ) ; string = sb . toString ( ) . trim ( ) ; if ( "" . equals ( string ) ) { throw this . syntaxError ( "Missing value" ) ; } return JSONObject . stringToValue ( string ) ; }
va	7	public static boolean logIn ( String username , String password , JFrame frame ) { try { System . out . println ( "Checking username and password with my boss..." ) ; if ( username . equals ( "" ) || username . contains ( " " ) ) { JOptionPane . showMessageDialog ( frame , "The username is invalid  please try an other one." , "Invalid Username" , JOptionPane . ERROR_MESSAGE ) ; return false ; } if ( password . equals ( "" ) || password . contains ( " " ) ) { JOptionPane . showMessageDialog ( frame , "The password is invalid  please try an other one." , "Invalid Password" , JOptionPane . ERROR_MESSAGE ) ; return false ; } if ( ! getReturnString ( "req=existsPlayer&name=" + username ) ) { JOptionPane . showMessageDialog ( frame , "The player does not exits." + "Please try an other username." , "Player does not exist" , JOptionPane . ERROR_MESSAGE ) ; return false ; } if ( ! getReturnString ( "req=login&name=" + username + "&pass=" + password ) ) { JOptionPane . showMessageDialog ( frame , "The combination of username and passowrd is incorrect." + System . lineSeparator ( ) + "Please try again.'" + System . lineSeparator ( ) + "If you have forgotten your password  visit sinius15.com." , "Invalid login" , JOptionPane . ERROR_MESSAGE ) ; return false ; } } catch ( IOException e ) { e . printStackTrace ( ) ; JOptionPane . showMessageDialog ( frame , "There seems to be a problem with the connection to the server" + System . lineSeparator ( ) + "You can start the game in offline mode if you still want to play." + System . lineSeparator ( ) + "We are verry sorry for the inconvenience caused." , "Problem" , JOptionPane . ERROR_MESSAGE ) ; return false ; } return true ; }
va	6	@ Override protected void fillComponentsInEditorPanel ( int rowSelected ) { nameTextField . setText ( getValueAt ( rowSelected , 1 ) . toString ( ) ) ; yearSpinner . setValue ( short . valueOf ( getValueAt ( rowSelected , 2 ) . toString ( ) ) ) ; strengthSpinner . setValue ( getValueAt ( rowSelected , 3 ) ) ; String speciality = getValueAt ( rowSelected , 4 ) . toString ( ) ; int index = 0 ; for ( int i = 0 ; i < specialities . length ; i ++ ) { if ( speciality . endsWith ( specialities [ i ] . getName ( ) ) ) { index = i ; } } specialityComboBox . setSelectedIndex ( index ) ; String department = getValueAt ( rowSelected , 5 ) . toString ( ) ; index = 0 ; for ( int i = 0 ; i < departments . length ; i ++ ) { if ( department . endsWith ( departments [ i ] . getName ( ) ) ) { index = i ; } } departmentComboBox . setSelectedIndex ( index ) ; String form = getValueAt ( rowSelected , 3 ) . toString ( ) ; index = 0 ; for ( int i = 0 ; i < educationForms . length ; i ++ ) { if ( form . endsWith ( educationForms [ i ] . getType ( ) ) ) { index = i ; } } educationFormComboBox . setSelectedIndex ( index ) ; }
va	4	public static String readAsString ( File file ) { final long length = file . length ( ) ; final byte [ ] bytes = new byte [ ( int ) length ] ; InputStream is = null ; try { is = new FileInputStream ( file ) ; is . read ( bytes ) ; } catch ( IOException e ) { } finally { try { if ( is != null ) { is . close ( ) ; } } catch ( IOException ex ) { return null ; } } try { return new String ( bytes , "UTF-8" ) ; } catch ( UnsupportedEncodingException e ) { return null ; } }
va	8	public boolean baca ( String no_beli ) { boolean adaKesalahan = false ; Connection cn = null ; this . no_beli = no_beli ; listKwitansi = null ; try { class . forName ( Koneksi . driver ) ; } catch ( Exception ex ) { adaKesalahan = true ; JOptionPane . showMessageDialog ( null , "JDBC Driver tidak ditemukan atau rusak\n" + ex , "Kesalahan" , JOptionPane . ERROR_MESSAGE ) ; } if ( ! adaKesalahan ) { try { cn = DriverManager . getConnection ( Koneksi . database + "?user=" + Koneksi . user + "&password=" + Koneksi . password + "" ) ; } catch ( Exception ex ) { adaKesalahan = true ; JOptionPane . showMessageDialog ( null , "Koneksi ke " + Koneksi . database + " gagal\n" + ex , "Kesalahan" , JOptionPane . ERROR_MESSAGE ) ; } if ( ! adaKesalahan ) { String SQLStatemen ; Statement sta ; ResultSet rset ; try { SQLStatemen = "select * from kwitansi where no_beli='" + no_beli + "'" ; sta = cn . createStatement ( ) ; rset = sta . executeQuery ( SQLStatemen ) ; rset . next ( ) ; rset . last ( ) ; listKwitansi = new Object [ rset . getRow ( ) ] [ 4 ] ; rset . first ( ) ; int i = 0 ; do { if ( ! rset . getString ( "kode_buku" ) . equals ( "" ) ) { listKwitansi [ i ] = new Object [ ] { rset . getString ( "kode_buku" ) , rset . getInt ( "jumlah" ) , rset . getInt ( "harga" ) } ; } i ++ ; } while ( rset . next ( ) ) ; sta . close ( ) ; rset . close ( ) ; if ( listKwitansi . length > 0 ) { adaKesalahan = false ; } } catch ( Exception ex ) { adaKesalahan = true ; } } } return ! adaKesalahan ; }
va	1	public static void writeStringToFile ( String content , String filename , boolean append ) { FileWriter fw ; try { fw = new FileWriter ( filename , append ) ; fw . append ( content ) ; fw . flush ( ) ; fw . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }
va	0	private static void testWriteUnsignedInt ( ByteArrayTool baa ) { byte [ ] b = new byte [ 128 ] ; baa . putUnsignedInt ( b , 43 , fedaabed ) ; assertEquals ( ( byte ) ed , b [ 43 ] ) ; assertEquals ( ( byte ) ab , b [ 44 ] ) ; assertEquals ( ( byte ) da , b [ 45 ] ) ; assertEquals ( ( byte ) fe , b [ 46 ] ) ; baa . putUnsignedInt ( b , 47 , 2a ) ; assertEquals ( ( byte ) 2a , b [ 47 ] ) ; assertEquals ( ( byte ) 00 , b [ 48 ] ) ; assertEquals ( ( byte ) 00 , b [ 49 ] ) ; assertEquals ( ( byte ) 00 , b [ 50 ] ) ; }
va	9X	public int bitrate ( int i ) { if ( i >= links ) return ( - 1 ) ; if ( ! seekable && i != 0 ) return ( bitrate ( 0 ) ) ; if ( i < 0 ) { long bits = 0 ; for ( int j = 0 ; j < links ; j ++ ) { bits += ( offsets [ j + 1 ] - dataoffsets [ j ] ) * 8 ; } return ( ( int ) Math . rint ( bits / time_total ( - 1 ) ) ) ; } else { if ( seekable ) { return ( ( int ) Math . rint ( ( offsets [ i + 1 ] - dataoffsets [ i ] ) * 8 / time_total ( i ) ) ) ; } else { if ( vi [ i ] . bitrate_nominal > 0 ) { return vi [ i ] . bitrate_nominal ; } else { if ( vi [ i ] . bitrate_upper > 0 ) { if ( vi [ i ] . bitrate_lower > 0 ) { return ( vi [ i ] . bitrate_upper + vi [ i ] . bitrate_lower ) / 2 ; } else { return vi [ i ] . bitrate_upper ; } } return ( - 1 ) ; } } } }
va	2	public int priseTerritoire ( Territoire t , int nbUnite ) { if ( this . nbUniteBonus >= nbUnite - 1 ) { this . nbUniteBonus -= nbUnite - 1 ; nbUnite = 1 ; } else { nbUnite -= this . nbUniteBonus ; this . nbUniteBonus = 0 ; } this . nbUniteEnMain -= nbUnite ; t . setNbUnite ( nbUnite ) ; t . setOccupant ( this ) ; this . territoiresOccupes . add ( t ) ; this . actionPriseTerritoire ( t ) ; if ( hasPower ( ) ) { this . pouvoir . actionPriseTerritoire ( t ) ; } return nbUnite ; }
va	7	public RegisterFrame ( ServerManager theServer , String theUrl , int thePort , int theListenPort ) { super ( "Registrar Usuario" ) ; controller = new RegisterController ( theServer , theUrl , thePort ) ; server = theServer ; url = theUrl ; port = thePort ; listenPort = theListenPort ; addWindowListener ( new WindowAdapter ( ) { @ Override public void windowClosing ( WindowEvent e ) { createLoginFrame ( ) ; } } ) ; setBounds ( 100 , 100 , 661 , 403 ) ; contentPane = new JPanel ( ) ; contentPane . setBackground ( Color . WHITE ) ; contentPane . setBorder ( new EmptyBorder ( 5 , 5 , 5 , 5 ) ) ; setContentPane ( contentPane ) ; contentPane . setLayout ( new BorderLayout ( 0 , 10 ) ) ; JLabel lblRegistrarUsuario = new JLabel ( "Registrar Usuario" ) ; lblRegistrarUsuario . setFont ( new Font ( "Tahoma" , Font . BOLD , 18 ) ) ; lblRegistrarUsuario . setHorizontalAlignment ( SwingConstants . CENTER ) ; contentPane . add ( lblRegistrarUsuario , BorderLayout . NORTH ) ; JPanel panelBotton = new JPanel ( ) ; panelBotton . setBackground ( Color . WHITE ) ; contentPane . add ( panelBotton , BorderLayout . SOUTH ) ; panelBotton . setLayout ( new FlowLayout ( FlowLayout . RIGHT , 5 , 5 ) ) ; JButton btnRegister = new JButton ( "Registrarse" ) ; btnRegister . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent arg0 ) { try { controller . register ( usernameTxt . getText ( ) , new String ( passwordTxt . getPassword ( ) ) , new String ( rePasswordTxt . getPassword ( ) ) , firstNameTxt . getText ( ) , lastNameTxt . getText ( ) , emailTxt . getText ( ) ) ; JOptionPane . showMessageDialog ( null , "Registro exitoso!  ahora podra usar el servicio de chat" , "Registro exitoso" , JOptionPane . INFORMATION_MESSAGE ) ; createLoginFrame ( ) ; } catch ( RegisterException e ) { JOptionPane . showMessageDialog ( null , e . getMessage ( ) , "Error" , JOptionPane . ERROR_MESSAGE ) ; } } } ) ; btnRegister . setIcon ( new ImageIcon ( RegisterFrame . class . getResource ( "/chat/client/view/resources/registerIcon.png" ) ) ) ; panelBotton . add ( btnRegister ) ; JButton btnCancel = new JButton ( "Cancelar" ) ; btnCancel . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { createLoginFrame ( ) ; } } ) ; panelBotton . add ( btnCancel ) ; JPanel panel = new JPanel ( ) ; contentPane . add ( panel , BorderLayout . CENTER ) ; panel . setLayout ( new GridLayout ( 0 , 2 , 0 , 0 ) ) ; ImagePanel imagePanel = new ImagePanel ( Toolkit . getDefaultToolkit ( ) . getImage ( RegisterFrame . class . getResource ( "/chat/client/view/resources/ico2.jpg" ) ) ) ; panel . add ( imagePanel ) ; JPanel panel_1 = new JPanel ( ) ; panel_1 . setBackground ( Color . WHITE ) ; panel . add ( panel_1 ) ; GridBagLayout gbl_panel_1 = new GridBagLayout ( ) ; gbl_panel_1 . columnWidths = new int [ ] { 0 , 150 , 10 } ; gbl_panel_1 . rowHeights = new int [ ] { 0 , 0 , 0 , 0 , 0 , 0 , 20 } ; gbl_panel_1 . columnWeights = new double [ ] { 0.0 , 1.0 , 0.0 } ; gbl_panel_1 . rowWeights = new double [ ] { 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 } ; panel_1 . setLayout ( gbl_panel_1 ) ; JLabel label = new JLabel ( "Nombre de Usuario:" ) ; label . setFont ( new Font ( "Tahoma" , Font . PLAIN , 12 ) ) ; GridBagConstraints gbc_label = new GridBagConstraints ( ) ; gbc_label . anchor = GridBagConstraints . EAST ; gbc_label . insets = new Insets ( 0 , 0 , 5 , 5 ) ; gbc_label . gridx = 0 ; gbc_label . gridy = 0 ; panel_1 . add ( label , gbc_label ) ; usernameTxt = new JTextField ( ) ; usernameTxt . addFocusListener ( new FocusAdapter ( ) { @ Override public void focusLost ( FocusEvent e ) { if ( ! controller . isValidUsername ( usernameTxt . getText ( ) ) ) { lblUserNameError . setText ( "*" ) ; lblError . setText ( "El nombre de usuario es invalido" ) ; } else { lblUserNameError . setText ( "" ) ; lblError . setText ( "" ) ; } } } ) ; usernameTxt . setFont ( new Font ( "Tahoma" , Font . PLAIN , 12 ) ) ; usernameTxt . setColumns ( 20 ) ; GridBagConstraints gbc_usernameTxt = new GridBagConstraints ( ) ; gbc_usernameTxt . fill = GridBagConstraints . HORIZONTAL ; gbc_usernameTxt . insets = new Insets ( 0 , 0 , 5 , 5 ) ; gbc_usernameTxt . gridx = 1 ; gbc_usernameTxt . gridy = 0 ; panel_1 . add ( usernameTxt , gbc_usernameTxt ) ; lblUserNameError = new JLabel ( "" ) ; lblUserNameError . setForeground ( Color . RED ) ; GridBagConstraints gbc_lblUserNameError = new GridBagConstraints ( ) ; gbc_lblUserNameError . insets = new Insets ( 0 , 0 , 5 , 0 ) ; gbc_lblUserNameError . gridx = 2 ; gbc_lblUserNameError . gridy = 0 ; panel_1 . add ( lblUserNameError , gbc_lblUserNameError ) ; JLabel label_1 = new JLabel ( "Contrase\u00F1a:" ) ; label_1 . setFont ( new Font ( "Tahoma" , Font . PLAIN , 12 ) ) ; GridBagConstraints gbc_label_1 = new GridBagConstraints ( ) ; gbc_label_1 . anchor = GridBagConstraints . EAST ; gbc_label_1 . insets = new Insets ( 0 , 0 , 5 , 5 ) ; gbc_label_1 . gridx = 0 ; gbc_label_1 . gridy = 1 ; panel_1 . add ( label_1 , gbc_label_1 ) ; passwordTxt = new JPasswordField ( ) ; passwordTxt . addFocusListener ( new FocusAdapter ( ) { @ Override public void focusLost ( FocusEvent arg0 ) { if ( ! controller . isValidPassword ( new String ( passwordTxt . getPassword ( ) ) ) ) { lblPasswordError . setText ( "*" ) ; lblError . setText ( "La contrase\uFFFDa es invalida" ) ; } else { lblPasswordError . setText ( "" ) ; lblError . setText ( "" ) ; } } } ) ; passwordTxt . setColumns ( 20 ) ; passwordTxt . setFont ( new Font ( "Tahoma" , Font . PLAIN , 12 ) ) ; GridBagConstraints gbc_passwordTxt = new GridBagConstraints ( ) ; gbc_passwordTxt . fill = GridBagConstraints . HORIZONTAL ; gbc_passwordTxt . insets = new Insets ( 0 , 0 , 5 , 5 ) ; gbc_passwordTxt . gridx = 1 ; gbc_passwordTxt . gridy = 1 ; panel_1 . add ( passwordTxt , gbc_passwordTxt ) ; lblPasswordError = new JLabel ( "" ) ; lblPasswordError . setForeground ( Color . RED ) ; GridBagConstraints gbc_lblPasswordError = new GridBagConstraints ( ) ; gbc_lblPasswordError . insets = new Insets ( 0 , 0 , 5 , 0 ) ; gbc_lblPasswordError . gridx = 2 ; gbc_lblPasswordError . gridy = 1 ; panel_1 . add ( lblPasswordError , gbc_lblPasswordError ) ; JLabel label_2 = new JLabel ( "Repetir contrase\u00F1a:" ) ; label_2 . setFont ( new Font ( "Tahoma" , Font . PLAIN , 12 ) ) ; GridBagConstraints gbc_label_2 = new GridBagConstraints ( ) ; gbc_label_2 . anchor = GridBagConstraints . EAST ; gbc_label_2 . insets = new Insets ( 0 , 0 , 5 , 5 ) ; gbc_label_2 . gridx = 0 ; gbc_label_2 . gridy = 2 ; panel_1 . add ( label_2 , gbc_label_2 ) ; rePasswordTxt = new JPasswordField ( ) ; rePasswordTxt . addFocusListener ( new FocusAdapter ( ) { @ Override public void focusLost ( FocusEvent e ) { if ( ! controller . isRePasswordEqualToPassword ( new String ( passwordTxt . getPassword ( ) ) , new String ( rePasswordTxt . getPassword ( ) ) ) ) { lblRepasswordError . setText ( "*" ) ; lblError . setText ( "La contrase\uFFFDa es invalida" ) ; } else { lblRepasswordError . setText ( "" ) ; lblError . setText ( "" ) ; } } } ) ; rePasswordTxt . setColumns ( 20 ) ; rePasswordTxt . setFont ( new Font ( "Tahoma" , Font . PLAIN , 12 ) ) ; GridBagConstraints gbc_rePasswordTxt = new GridBagConstraints ( ) ; gbc_rePasswordTxt . fill = GridBagConstraints . HORIZONTAL ; gbc_rePasswordTxt . insets = new Insets ( 0 , 0 , 5 , 5 ) ; gbc_rePasswordTxt . gridx = 1 ; gbc_rePasswordTxt . gridy = 2 ; panel_1 . add ( rePasswordTxt , gbc_rePasswordTxt ) ; lblRepasswordError = new JLabel ( "" ) ; lblRepasswordError . setForeground ( Color . RED ) ; GridBagConstraints gbc_lblRepasswordError = new GridBagConstraints ( ) ; gbc_lblRepasswordError . insets = new Insets ( 0 , 0 , 5 , 0 ) ; gbc_lblRepasswordError . gridx = 2 ; gbc_lblRepasswordError . gridy = 2 ; panel_1 . add ( lblRepasswordError , gbc_lblRepasswordError ) ; JLabel label_3 = new JLabel ( "Nombre(s):" ) ; label_3 . setFont ( new Font ( "Tahoma" , Font . PLAIN , 12 ) ) ; GridBagConstraints gbc_label_3 = new GridBagConstraints ( ) ; gbc_label_3 . anchor = GridBagConstraints . EAST ; gbc_label_3 . insets = new Insets ( 0 , 0 , 5 , 5 ) ; gbc_label_3 . gridx = 0 ; gbc_label_3 . gridy = 3 ; panel_1 . add ( label_3 , gbc_label_3 ) ; firstNameTxt = new JTextField ( ) ; firstNameTxt . addFocusListener ( new FocusAdapter ( ) { @ Override public void focusLost ( FocusEvent e ) { if ( ! controller . isValidFirstName ( firstNameTxt . getText ( ) ) ) { lblFirstNameError . setText ( "*" ) ; lblError . setText ( "El nombre de usuario es invalido" ) ; } else { lblFirstNameError . setText ( "" ) ; lblError . setText ( "" ) ; } } } ) ; firstNameTxt . setFont ( new Font ( "Tahoma" , Font . PLAIN , 12 ) ) ; firstNameTxt . setColumns ( 30 ) ; GridBagConstraints gbc_firstNameTxt = new GridBagConstraints ( ) ; gbc_firstNameTxt . fill = GridBagConstraints . HORIZONTAL ; gbc_firstNameTxt . insets = new Insets ( 0 , 0 , 5 , 5 ) ; gbc_firstNameTxt . gridx = 1 ; gbc_firstNameTxt . gridy = 3 ; panel_1 . add ( firstNameTxt , gbc_firstNameTxt ) ; lblFirstNameError = new JLabel ( "" ) ; lblFirstNameError . setForeground ( Color . RED ) ; GridBagConstraints gbc_lblFirstNameError = new GridBagConstraints ( ) ; gbc_lblFirstNameError . insets = new Insets ( 0 , 0 , 5 , 0 ) ; gbc_lblFirstNameError . gridx = 2 ; gbc_lblFirstNameError . gridy = 3 ; panel_1 . add ( lblFirstNameError , gbc_lblFirstNameError ) ; JLabel label_4 = new JLabel ( "Apellido(s):" ) ; label_4 . setFont ( new Font ( "Tahoma" , Font . PLAIN , 12 ) ) ; GridBagConstraints gbc_label_4 = new GridBagConstraints ( ) ; gbc_label_4 . anchor = GridBagConstraints . EAST ; gbc_label_4 . insets = new Insets ( 0 , 0 , 5 , 5 ) ; gbc_label_4 . gridx = 0 ; gbc_label_4 . gridy = 4 ; panel_1 . add ( label_4 , gbc_label_4 ) ; lastNameTxt = new JTextField ( ) ; lastNameTxt . addFocusListener ( new FocusAdapter ( ) { @ Override public void focusLost ( FocusEvent e ) { if ( ! controller . isValidLastName ( lastNameTxt . getText ( ) ) ) { lblLastNameError . setText ( "*" ) ; lblError . setText ( "El nombre de usuario es invalido" ) ; } else { lblLastNameError . setText ( "" ) ; lblError . setText ( "" ) ; } } } ) ; lastNameTxt . setFont ( new Font ( "Tahoma" , Font . PLAIN , 12 ) ) ; lastNameTxt . setColumns ( 30 ) ; GridBagConstraints gbc_lastNameTxt = new GridBagConstraints ( ) ; gbc_lastNameTxt . fill = GridBagConstraints . HORIZONTAL ; gbc_lastNameTxt . insets = new Insets ( 0 , 0 , 5 , 5 ) ; gbc_lastNameTxt . gridx = 1 ; gbc_lastNameTxt . gridy = 4 ; panel_1 . add ( lastNameTxt , gbc_lastNameTxt ) ; lblLastNameError = new JLabel ( "" ) ; lblLastNameError . setForeground ( Color . RED ) ; GridBagConstraints gbc_lblLastNameError = new GridBagConstraints ( ) ; gbc_lblLastNameError . insets = new Insets ( 0 , 0 , 5 , 0 ) ; gbc_lblLastNameError . gridx = 2 ; gbc_lblLastNameError . gridy = 4 ; panel_1 . add ( lblLastNameError , gbc_lblLastNameError ) ; JLabel label_5 = new JLabel ( "E-mail:" ) ; label_5 . setFont ( new Font ( "Tahoma" , Font . PLAIN , 12 ) ) ; GridBagConstraints gbc_label_5 = new GridBagConstraints ( ) ; gbc_label_5 . anchor = GridBagConstraints . EAST ; gbc_label_5 . insets = new Insets ( 0 , 0 , 5 , 5 ) ; gbc_label_5 . gridx = 0 ; gbc_label_5 . gridy = 5 ; panel_1 . add ( label_5 , gbc_label_5 ) ; emailTxt = new JTextField ( ) ; emailTxt . addFocusListener ( new FocusAdapter ( ) { @ Override public void focusLost ( FocusEvent e ) { if ( ! controller . isValidEmail ( emailTxt . getText ( ) ) ) { lblEmailError . setText ( "*" ) ; lblError . setText ( "El nombre de usuario es invalido" ) ; } else { lblEmailError . setText ( "" ) ; lblError . setText ( "" ) ; } } } ) ; emailTxt . setFont ( new Font ( "Tahoma" , Font . PLAIN , 12 ) ) ; emailTxt . setColumns ( 50 ) ; GridBagConstraints gbc_emailTxt = new GridBagConstraints ( ) ; gbc_emailTxt . insets = new Insets ( 0 , 0 , 5 , 5 ) ; gbc_emailTxt . fill = GridBagConstraints . HORIZONTAL ; gbc_emailTxt . gridx = 1 ; gbc_emailTxt . gridy = 5 ; panel_1 . add ( emailTxt , gbc_emailTxt ) ; lblEmailError = new JLabel ( "" ) ; lblEmailError . setForeground ( Color . RED ) ; GridBagConstraints gbc_lblEmailError = new GridBagConstraints ( ) ; gbc_lblEmailError . insets = new Insets ( 0 , 0 , 5 , 0 ) ; gbc_lblEmailError . gridx = 2 ; gbc_lblEmailError . gridy = 5 ; panel_1 . add ( lblEmailError , gbc_lblEmailError ) ; lblError = new JLabel ( "" ) ; lblError . setForeground ( Color . RED ) ; GridBagConstraints gbc_lblError = new GridBagConstraints ( ) ; gbc_lblError . gridwidth = 3 ; gbc_lblError . insets = new Insets ( 0 , 0 , 0 , 5 ) ; gbc_lblError . gridx = 0 ; gbc_lblError . gridy = 6 ; panel_1 . add ( lblError , gbc_lblError ) ; }
va	1	public boolean createAccount ( String login , String password ) { if ( logins . containsKey ( login + password ) ) { return false ; } else { logins . put ( login + password , null ) ; return true ; } }
va	1	public void drawButtons ( ) { for ( int x = 0 ; x < buttons . size ( ) ; x ++ ) { buttons . get ( x ) . draw ( ScreenX , ScreenY ) ; } }
va	1	public void awaitTermination ( ) { try { latch . await ( ) ; } catch ( InterruptedException e ) { String message = "awaitTermination() method was interrupted!" ; throw new UnsupportedOperationException ( message , e ) ; } }
va	0	public void setRing ( boolean ring ) { this . ring = ring ; }
va	9X	private void execute ( ) { boolean running = true ; WatchKey key ; String dir = readProperties ( ) ; InboundWatcher watch = new InboundWatcher ( dir ) ; System . out . println ( "Starting the directory monitoring" ) ; System . out . println ( "Directory being monitored is: " + dir ) ; while ( running ) { try { key = watch . watcher . take ( ) ; } catch ( InterruptedException ie ) { return ; } for ( WatchEvent < ? > event : key . pollEvents ( ) ) { WatchEvent . Kind < ? > kind = event . kind ( ) ; if ( kind == StandardWatchEventKinds . ENTRY_CREATE ) { WatchEvent < Path > watchEventPath = ( WatchEvent < Path > ) event ; Path entry = watchEventPath . context ( ) ; if ( Pattern . matches ( "[so]{0 1}.+[\\.xml]" , entry . toString ( ) ) ) { SalesOrder . unmarshal ( dir , entry . toString ( ) ) ; } else if ( Pattern . matches ( "[sr]{0 1}.+[\\.xml]" , entry . toString ( ) ) ) { StandardResponse . unmarshal ( dir , entry . toString ( ) ) ; } else if ( Pattern . matches ( ".+[\\.trg]" , entry . toString ( ) ) ) { File f = entry . toFile ( ) ; ShipAdvice . marshal ( f ) ; } } } key . reset ( ) ; if ( ! key . isValid ( ) ) { running = false ; } } }
va	4	private void setUsersState ( int state ) { final int columnId = 0 ; if ( tableUsers . getSelectedRow ( ) != - 1 ) { int userId = ( Integer ) tableUsers . getValueAt ( tableUsers . getSelectedRow ( ) , columnId ) ; Statement statement = null ; ResultSet result = null ; try { statement = usersDAO . getConnection ( ) . createStatement ( ResultSet . TYPE_SCROLL_SENSITIVE , ResultSet . CONCUR_UPDATABLE ) ; result = statement . executeQuery ( usersDAO . getAllQuery ( ) ) ; while ( result . next ( ) ) { if ( result . getInt ( "ID" ) == userId ) { break ; } } result . updateInt ( "USERSTATE" , state ) ; result . updateRow ( ) ; usersDAO = new UsersDAO ( ) ; usersDAO . initTableModel ( tableUsers , usersDAO . listAll ( ) ) ; } catch ( SQLException exc ) { JOptionPane . showMessageDialog ( this , "\u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u043E\u0431\u043D\u043E\u0432\u043B\u0435\u043D\u0438\u0438 \u0434\u0430\u043D\u043D\u044B\u0445" ) ; } } else { JOptionPane . showMessageDialog ( this , "\u041D\u0435 \u0432\u044B\u0431\u0440\u0430\u043D \u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u0435\u043B\u044C \u0432 \u0442\u0430\u0431\u043B\u0438\u0446\u0435!" ) ; return ; } }
va	2	public void setValue ( int value ) { if ( value < this . minValue ) { this . value = minValue ; } else if ( value > maxValue ) { this . value = maxValue ; } else { this . value = value ; } this . slider . reactToChanges ( new CustomSliderEvent ( slider , this . value ) ) ; this . textField . reactToChanges ( new CustomTextFieldEvent ( textField , Integer . toString ( this . value ) ) ) ; }
va	0	public JSONArray put ( int index , double value ) throws JSONException { put ( index , new double ( value ) ) ; return this ; }
va	4	private Constant simplifySub ( AbstractBinaryOperator binaryOperator , AbstractMutableFormula left , AbstractMutableFormula right ) { if ( binaryOperator instanceof SubOperator && left instanceof Variable && right instanceof Variable && ( ( Variable ) left ) . getName ( ) . equals ( ( ( Variable ) right ) . getName ( ) ) ) { return new Constant ( 0 ) ; } return null ; }
va	5	public Type get ( int index ) { if ( index >= length ) return new BooleanValue ( false ) ; else if ( index < 0 && Math . abs ( index ) <= length ) return elements [ length + index ] ; else if ( index < 0 && Math . abs ( index ) > length ) return new BooleanValue ( false ) ; return elements [ index ] ; }
va	8	public void executePowerUp ( PowerupNode node ) { PowerupPlayer powerup = node . powerup ; if ( powerup == null ) return ; switch ( powerup . addsFeature ) { case BOMB_MAX_COUNT : combatSystem . updateBombLayer ( node . entity_target , null , null , powerup . amount , null ) ; break ; case BOMB_TEMP_COUNT : combatSystem . updateBombLayer ( node . entity_target , null , null , null , powerup . amount ) ; break ; case CAN_JUMP : break ; case CAN_PUSH : break ; case FLAME_LENGTH : combatSystem . updateBombLayer ( node . entity_target , powerup . amount , null , null , null ) ; break ; case SPEED : movementSystem . updateMoveable ( node . entity_target , powerup . amount ) ; break ; case DAMAGE : combatSystem . updateBombLayer ( node . entity_target , null , powerup . amount , null , null ) ; } }
va	5	private int [ ] setDistancePriority ( int xdiff , int ydiff ) { int priority [ ] = { - 1 , - 1 , - 1 , - 1 } ; if ( ( Math . abs ( xdiff ) > ( Math . abs ( ydiff ) ) ) ) { if ( ( xdiff ) > 0 ) { priority [ 0 ] = 180 ; priority [ 3 ] = 0 ; } else { priority [ 0 ] = 0 ; priority [ 3 ] = 180 ; } if ( ( ydiff ) > 0 ) { priority [ 1 ] = 90 ; priority [ 2 ] = 270 ; } else { priority [ 1 ] = 270 ; priority [ 2 ] = 90 ; } } else { if ( ( ydiff ) > 0 ) { priority [ 0 ] = 90 ; priority [ 3 ] = 270 ; } else { priority [ 0 ] = 270 ; priority [ 3 ] = 90 ; } if ( ( xdiff ) > 0 ) { priority [ 1 ] = 180 ; priority [ 2 ] = 0 ; } else { priority [ 1 ] = 0 ; priority [ 2 ] = 180 ; } } return priority ; }
va	9X	public static String nullSafeToString ( Object obj ) { if ( obj == null ) { return NULL_STRING ; } if ( obj instanceof String ) { return ( String ) obj ; } if ( obj instanceof Object [ ] ) { return nullSafeToString ( ( Object [ ] ) obj ) ; } if ( obj instanceof boolean [ ] ) { return nullSafeToString ( ( boolean [ ] ) obj ) ; } if ( obj instanceof byte [ ] ) { return nullSafeToString ( ( byte [ ] ) obj ) ; } if ( obj instanceof char [ ] ) { return nullSafeToString ( ( char [ ] ) obj ) ; } if ( obj instanceof double [ ] ) { return nullSafeToString ( ( double [ ] ) obj ) ; } if ( obj instanceof float [ ] ) { return nullSafeToString ( ( float [ ] ) obj ) ; } if ( obj instanceof int [ ] ) { return nullSafeToString ( ( int [ ] ) obj ) ; } if ( obj instanceof long [ ] ) { return nullSafeToString ( ( long [ ] ) obj ) ; } if ( obj instanceof short [ ] ) { return nullSafeToString ( ( short [ ] ) obj ) ; } String str = obj . toString ( ) ; return ( str != null ? str : EMPTY_STRING ) ; }
va	3	public static final void closeWindow ( ) { if ( clickListener != null ) { clickListener . removeHandler ( ) ; } if ( keyPressListener != null ) { keyPressListener . removeHandler ( ) ; } if ( blurListener != null ) { blurListener . removeHandler ( ) ; } Alerts . closeWindow ( ) ; }
va	2	public void run ( ) { while ( true ) { try { Socket cli = serversocket . accept ( ) ; playback = new Playback ( cli ) ; playback . start ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } }
va	9X	public static int testPublic ( int testNum ) { String inputFilename = String . format ( "tests/test%02d.crx" , testNum ) ; String outputFilename = String . format ( "tests/test%02d.rea" , testNum ) ; String expectedFilename = String . format ( "tests/test%02d.out" , testNum ) ; String astFilename = String . format ( "tests/test%02d.ast" , testNum ) ; Scanner s = null ; try { s = new Scanner ( new FileReader ( inputFilename ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; return NOT_ACCESSABLE ; } Parser p = new Parser ( s ) ; ast . Command syntaxTree = p . parse ( ) ; try { PrintStream outputStream = new PrintStream ( outputFilename ) ; PrintStream astStream = new PrintStream ( astFilename ) ; if ( p . hasError ( ) ) { outputStream . println ( "Error parsing file." ) ; outputStream . println ( p . errorReport ( ) ) ; outputStream . close ( ) ; astStream . println ( "Error parsing file." ) ; astStream . println ( p . errorReport ( ) ) ; astStream . close ( ) ; } else { PrettyPrinter pretty = new PrettyPrinter ( ) ; syntaxTree . accept ( pretty ) ; astStream . println ( pretty . toString ( ) ) ; astStream . close ( ) ; types . TypeChecker tc = new types . TypeChecker ( ) ; tc . check ( syntaxTree ) ; if ( tc . hasError ( ) ) { outputStream . println ( "Error type-checking file." ) ; outputStream . println ( tc . errorReport ( ) ) ; outputStream . close ( ) ; } else { outputStream . println ( "Crux Program has no type errors." ) ; } } } catch ( IOException e ) { System . err . println ( "Error opening output file: \"" + outputFilename + "\"" ) ; e . printStackTrace ( ) ; return IO_ERROR ; } BufferedReader bufferedexpected ; BufferedReader bufferedoutput ; String lineExpected ; String lineOutput ; try { bufferedexpected = new BufferedReader ( new FileReader ( expectedFilename ) ) ; bufferedoutput = new BufferedReader ( new FileReader ( outputFilename ) ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; return IO_ERROR ; } int result = PASS ; try { while ( ( lineExpected = bufferedexpected . readLine ( ) ) != null ) { lineOutput = bufferedoutput . readLine ( ) ; if ( lineOutput == null ) { result = FAIL ; break ; } lineExpected = lineExpected . replaceAll ( "\\s+$" , "" ) ; lineOutput = lineOutput . replaceAll ( "\\s+$" , "" ) ; if ( ! lineExpected . equals ( lineOutput ) ) { result = FAIL ; break ; } } } catch ( IOException e ) { e . printStackTrace ( ) ; result = IO_ERROR ; } try { bufferedoutput . close ( ) ; bufferedexpected . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return result ; }
va	7	public static void main ( String [ ] args ) throws Exception { ApplicationContext context = new ClassPathXmlApplicationContext ( "spring-module.xml" ) ; UserService userservice = ( UserService ) context . getBean ( "userServiceBean" ) ; System . out . println ( "-------- --- USER --- ---------" ) ; User user = userservice . findUserByEmailPassword ( "martinpucheu@udec.cl" , "cresposexy" ) ; System . out . println ( "El usuario encontrado tiene como apellido: " + user . getlastName ( ) ) ; MovieService movieService = ( MovieService ) context . getBean ( "movieServiceBean" ) ; Movie m = new Movie ( "American Hustle" , 2013 , "Pel\u00EDcula de esta estafadores" , "David O. Russell" ) ; movieService . insert ( m ) ; System . out . println ( "-------- --- MOVIES --- ---------" ) ; Movie _movie = movieService . findMovieById ( 3 ) ; System . out . println ( "La pel\u00EDcula encontrada es: " + _movie . getName ( ) ) ; System . out . println ( " -.-.-.-" ) ; List < Movie > _movie2 = movieService . findMovieByTitle ( "Twilight" ) ; for ( int i = 0 ; i < _movie2 . size ( ) ; i ++ ) { System . out . println ( "Econtre la pel\u00EDcula que buscabas  es: " + _movie2 . get ( i ) . getName ( ) + " verdad?" ) ; } ActorService actorService = ( ActorService ) context . getBean ( "actorServiceBean" ) ; System . out . println ( "-------- --- ACTOR --- ---------" ) ; Actor _actor = actorService . findActorById ( 1 ) ; System . out . println ( "El actor encontrado es: " + _actor . getName ( ) + " " + _actor . getLName ( ) ) ; ActorService actsService = ( ActorService ) context . getBean ( "actsServiceBean" ) ; System . out . println ( "-------- --- ACTS --- ---------" ) ; List < Acts > _acts = actsService . findActsByMoiveId ( 1 ) ; for ( int i = 0 ; i < _acts . size ( ) ; i ++ ) System . out . println ( "En la pel\u00EDcula de id:1 actua el actor con id:[" + _acts . get ( i ) . getIda ( ) + "]" ) ; MovieService categoryService = ( MovieService ) context . getBean ( "categoryServiceBean" ) ; System . out . println ( "-------- --- CATEGORY --- ---------" ) ; Category _category = categoryService . findCategoryByGenre ( "Thriller" ) ; System . out . println ( "La categoria encontrada fue: " + _category . getGenre ( ) ) ; UserService doeslikeService = ( UserService ) context . getBean ( "doeslikeServiceBean" ) ; System . out . println ( "-------- --- DOESLIKE--- ---------" ) ; List < DoesLike > _doeslike = doeslikeService . findDoesLikeById ( 1 ) ; for ( int i = 0 ; i < _doeslike . size ( ) ; i ++ ) System . out . println ( "Al usuario 1 le gusta el genero: " + _doeslike . get ( i ) . getGenre ( ) ) ; UserService doesnotlikeService = ( UserService ) context . getBean ( "doesnotlikeServiceBean" ) ; System . out . println ( "-------- --- DOESNOTLIKE--- ---------" ) ; List < DoesNotLike > _doesnotlike = doesnotlikeService . findDoesNotLikeById ( 1 ) ; for ( int i = 0 ; i < _doesnotlike . size ( ) ; i ++ ) System . out . println ( "Al usuario 1 no le gusta el genero: " + _doesnotlike . get ( i ) . getGenre ( ) ) ; MovieService idiomService = ( MovieService ) context . getBean ( "idiomServiceBean" ) ; System . out . println ( "-------- --- IDIOM --- ---------" ) ; Idiom _idiom = idiomService . findIdiomByLanguage ( "Espanol" ) ; System . out . println ( "El idioma encontrado es: " + _idiom . getLanguage ( ) ) ; UserService idiompService = ( UserService ) context . getBean ( "idiompServiceBean" ) ; System . out . println ( "-------- --- IDIOMP --- ---------" ) ; List < Idiomp > _idiomp = idiompService . findByUserId ( 3 ) ; for ( int i = 0 ; i < _idiomp . size ( ) ; i ++ ) System . out . println ( "Al usuario 3 le gustan las peliculas en idioma: " + _idiomp . get ( i ) . getLanguage ( ) ) ; MovieService moviecategoryService = ( MovieService ) context . getBean ( "moviecategoryServiceBean" ) ; System . out . println ( "-------- --- MOVIECATEGORY --- ---------" ) ; List < MovieCategory > _moviecategory = moviecategoryService . findMoviesByGendre ( "Thriller" ) ; for ( int i = 0 ; i < _moviecategory . size ( ) ; i ++ ) System . out . println ( "Los ID de las pel\u00EDculas del genero Thriller son: " + _moviecategory . get ( i ) . getIdp ( ) ) ; MovieService ratingService = ( MovieService ) context . getBean ( "ratingServiceBean" ) ; System . out . println ( "-------- --- RATING --- ---------" ) ; Rating _rating = ratingService . findRatingById ( 1 , 1 ) ; System . out . println ( "La calificaci\u00F3n que le dio el usuario 2 a la pel\u00EDcula 3 es: [" + _rating . getMark ( ) + "]" ) ; MovieService speakService = ( MovieService ) context . getBean ( "speakServiceBean" ) ; Speak _speak2 = new Speak ( 2 , "Frances" ) ; System . out . println ( "-------- --- SPEAK --- ---------" ) ; Speak _speak = speakService . findSpeakByIdp ( 4 ) ; System . out . println ( "EL idioma de la pel\u00EDcula 4 es: " + _speak . getLengua ( ) ) ; UserService wishlistService = ( UserService ) context . getBean ( "wishlistServiceBean" ) ; WishList wishlist = new WishList ( 5 , 1 ) ; System . out . println ( "-------- --- WISHLIST --- ---------" ) ; List < WishList > _wishlist = wishlistService . findWishListById ( 1 ) ; for ( int i = 0 ; i < _wishlist . size ( ) ; i ++ ) System . out . println ( "La pel\u00EDcula con id:" + _wishlist . get ( i ) . getIdp ( ) + " est\u00E1 en la Wishlist del usuario 1 " ) ; }
va	3	public void update ( User user ) { Session session = null ; try { session = HibernateUtil . getSessionFactory ( ) . openSession ( ) ; session . beginTransaction ( ) ; session . update ( user ) ; session . getTransaction ( ) . commit ( ) ; } catch ( Exception e ) { System . err . println ( "\u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u0432\u0441\u0442\u0430\u0432\u043A\u0435" + e . getMessage ( ) ) ; } finally { if ( session != null && session . isOpen ( ) ) { session . close ( ) ; } } }
va	4	public void paint ( Graphics g ) { if ( key == null ) return ; Graphics2D g2d = ( Graphics2D ) g ; int rectWidth = getWidth ( ) / table . getSpecs ( ) . getCollectionRows ( ) ; int rectHeight = getHeight ( ) / table . getSpecs ( ) . getCollectionCols ( ) ; for ( int a = 0 ; a < table . getSpecs ( ) . getCollectionCols ( ) ; a ++ ) { for ( int b = 0 ; b < table . getSpecs ( ) . getCollectionRows ( ) ; b ++ ) { if ( key . print ( 100 , 50 ) . charAt ( b * table . getSpecs ( ) . getCollectionRows ( ) + a ) == 1 ) { g2d . setColor ( Color . BLACK ) ; } else { g2d . setColor ( Color . WHITE ) ; } g2d . fillRect ( b * rectWidth , a * rectHeight , ( b + 1 ) * rectWidth , ( a + 1 ) * rectHeight ) ; } } updateUI ( ) ; }
va	5	static void updatestatus ( int m ) { switch ( m ) { case 1 : status . setText ( "Drag to create an entity" ) ; break ; case 2 : status . setText ( "Drag to create an bubble" ) ; break ; case 3 : status . setText ( "Drag to create an data store" ) ; break ; case 4 : status . setText ( "Drag to create an data flow arrow" ) ; break ; case 6 : status . setText ( "Drag to create an control flow arrow" ) ; break ; default : status . setText ( "" ) ; } }
va	1	public static void main ( String args [ ] ) { LinkedListBST b = new LinkedListBST ( ) ; ListNode a = new ListNode ( 1 ) ; ListNode a2 = a ; for ( int i = 0 ; i < 5 ; i ++ ) { a . next = new ListNode ( i + 2 ) ; a = a . next ; } TreeNode t = b . sortedListToBST ( a2 ) ; t . print ( t ) ; }
va	3	private Object firstKey ( Object subtree ) { if ( ! ( subtree instanceof Node ) ) { Object [ ] ary = ( Object [ ] ) subtree ; return ary [ 0 ] ; } else { Node node = ( Node ) subtree ; if ( node . left == null ) { if ( node . key instanceof EquivalentMap ) return ( ( EquivalentMap ) node . key ) . contents . get ( 0 ) . key ; else return node . key ; } else return firstKey ( node . left ) ; } }
va	0	public UserDaoImpl ( final java . sql . Connection userConn ) { this . userConn = userConn ; }
va	1	public void removeAll ( ) { for ( int i = getRowCount ( ) - 1 ; i >= 0 ; i -- ) { removeRow ( i ) ; } }
va	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( Window3 . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( Window3 . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( Window3 . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( Window3 . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { @ Override public void run ( ) { new Window3 ( ) . setVisible ( true ) ; } } ) ; }
va	0	public int getLineNumber ( ) { return TokenStream . this . getLineNumber ( beg ) ; }
va	7	@ Override public void setFailState ( int failState ) { if ( this . failstate == Fallible . DEAD && failState != Fallible . DEAD ) throw new IllegalStateException ( "Cannot change fail state: node is already DEAD" ) ; switch ( failState ) { case OK : this . failstate = Fallible . OK ; break ; case DEAD : this . index = - 1 ; this . failstate = Fallible . DEAD ; for ( int i = 0 ; i < this . protocol . length ; ++ i ) if ( this . protocol [ i ] instanceof Cleanable ) { ( ( Cleanable ) this . protocol [ i ] ) . onKill ( ) ; } break ; case DOWN : this . failstate = Fallible . DOWN ; break ; default : throw new IllegalArgumentException ( "failState=" + failState ) ; } }
va	2	@ Override public String toString ( ) { final StringBuilder bld = new StringBuilder ( this . getClass ( ) . getSimpleName ( ) ) . append ( ": " ) ; if ( ! PRIMITIVES . contains ( this . name ) ) { bld . append ( this . packageName != null ? this . packageName : "[default package]" ) . append ( "." ) ; } return bld . append ( this . name ) . toString ( ) ; }
va	8	public void run ( ) { while ( ! mServerDisconnected ) { ArrayList < NetworkMessage > messages = GetMessages ( mUnsanitizedMessages ) ; for ( int i = 0 ; i < messages . size ( ) ; i ++ ) { NetworkMessage current = messages . get ( i ) ; current . Sanatize ( ) ; String message = current . GetMessage ( ) ; StringTokenizer st = new StringTokenizer ( message ) ; try { int id = Integer . parseInt ( st . nextToken ( ) ) ; ConnectedClient client = GetClient ( id ) ; if ( client != null ) { client . MessageRecieved ( ) ; } String command = st . nextToken ( ) ; if ( command . equalsIgnoreCase ( "ping" ) ) { client . PingRecieved ( ) ; } else if ( command . equalsIgnoreCase ( "connect" ) ) { if ( client == null ) { System . out . println ( "someone connected" ) ; ConnectedClient newClient = new ConnectedClient ( GetNextID ( ) , current . GetAddress ( ) , current . GetPort ( ) ) ; mClients . add ( newClient ) ; } } else { throw new Exception ( ) ; } } catch ( Exception e ) { AddMessage ( message , current . GetAddress ( ) , current . GetPort ( ) , mMessages ) ; } } try { Thread . sleep ( 10 ) ; } catch ( Exception e ) { } } }
va	1	public static SoundManager create ( class < ? > clazz ) throws IllegalArgumentException { return create ( clazz , new String ( ) ) ; }
va	0	public short [ ] [ ] action_table ( ) { return _action_table ; }
va	9X	@ Override public boolean run ( ) { int i ; int j = - 1 ; int k ; int [ ] path ; int step ; int current = game . getCurPacManLoc ( ) ; if ( game . isJunction ( current ) ) { visitedJunctions . add ( current ) ; } int [ ] junction = game . getJunctionIndices ( ) ; int [ ] array ; ArrayList < Integer > list = new ArrayList < Integer > ( ) ; for ( i = 0 ; i < junction . length ; i ++ ) { list . add ( junction [ i ] ) ; } list . removeAll ( visitedJunctions ) ; boolean foundPath = false ; boolean foundGhost = false ; while ( ! foundPath && ! list . isEmpty ( ) ) { array = new int [ list . size ( ) ] ; for ( i = 0 ; i < array . length ; i ++ ) { array [ i ] = list . get ( i ) ; } j = game . getTarget ( current , array , true , Game . DM . PATH ) ; path = game . getPath ( current , j ) ; foundGhost = false ; for ( step = 0 ; step < path . length && ! foundGhost ; step ++ ) { for ( k = 0 ; k < Game . NUM_GHOSTS ; k ++ ) { int ghostDist = game . getGhostPathDistance ( k , path [ step ] ) ; int myDist = game . getPathDistance ( current , path [ step ] ) ; if ( ghostDist > 0 && ghostDist < MyPacMan . JUNC_DIST && ( ghostDist < myDist ) ) { foundGhost = true ; list . remove ( new Integer ( j ) ) ; break ; } } } foundPath = ! foundGhost ; } if ( foundPath ) { GameView . addPoints ( game , Color . LIGHT_GRAY , game . getPath ( current , j ) ) ; setTarget ( game . getNextPacManDir ( j , true , Game . DM . PATH ) ) ; return true ; } return false ; }
va	2	public JSONArray ( Collection collection ) { this . myArrayList = new ArrayList ( ) ; if ( collection != null ) { Iterator iter = collection . iterator ( ) ; while ( iter . hasNext ( ) ) { this . myArrayList . add ( JSONObject . wrap ( iter . next ( ) ) ) ; } } }
va	5	@ Override public final void instantiate ( ) { instanceId = generateInstanceId ( ) ; if ( this instanceof ParentTrait ) { ParentTrait parentThis = ( ParentTrait ) this ; for ( int i = 0 ; i < parentThis . getChildCount ( ) ; i ++ ) { if ( ! ( parentThis instanceof ReferenceTrait ) || ! ( ( ReferenceTrait ) parentThis ) . isBackReference ( i ) ) { GeneTrait childGene = parentThis . getChild ( i ) ; if ( childGene != null ) { childGene . instantiate ( ) ; } } } } }
va	1	public void saveLang ( ) { try { lang . save ( langFile ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }
va	0	public void paintComponent ( Graphics g2 ) { g2 . drawImage ( bgImage , 0 , 0 , null ) ; }
va	8	public int getResult ( ) { sqrs . add ( 1 ) ; sqrs . add ( 4 ) ; for ( int sum = 6 ; ; sum ++ ) { if ( sum % 300 == 0 ) { System . out . println ( sum + " debug " ) ; System . out . println ( sqrs . size ( ) + " siize " ) ; } for ( int i = sum - 3 ; i > sum / 2 ; i -- ) { for ( int j = i - 1 ; j > 2 ; j -- ) { int k = sum - i - j ; if ( k >= j || k <= 0 ) continue ; if ( i + j + k == sum ) { if ( checkSum ( i , j , k ) ) { System . out . println ( i + " " + j + " " + k + " sum " + sum ) ; return sum ; } } } } } }
va	8	public static String getAFullMessage ( String [ ] finalWords , SocketChannel s ) throws IOException { ByteBuffer b = ByteBuffer . allocateDirect ( Global . BUFFER_LENGTH ) ; String retour = "" ; String m ; String token ; int i = 0 ; boolean continuer = true ; while ( continuer && i < Global . BUFFER_LENGTH ) { if ( s . read ( b ) == - 1 ) { Utilitaires . out ( "Fr\u00E9quence 2" , 2 , true ) ; continuer = false ; } if ( s . socket ( ) . isClosed ( ) ) { Utilitaires . out ( "Socket ferm\u00E9e !" ) ; throw new IOException ( ) ; } i ++ ; b . flip ( ) ; m = buffToString ( b ) ; retour += m ; b . clear ( ) ; Scanner sc = new Scanner ( m ) ; while ( sc . hasNext ( ) && continuer ) { token = sc . next ( ) ; for ( String w : finalWords ) { if ( token . equals ( w ) ) { continuer = false ; break ; } } } sc . close ( ) ; } return retour ; }
va	6	public void removePriceStep ( double startPrice , double endPrice ) throws RemoteException { startPrice = round ( startPrice ) ; endPrice = round ( endPrice ) ; if ( startPrice < 0 || endPrice < 0 ) throw new PriceStepNegativeArgumentException ( ) ; PriceStep removeStep = null ; for ( PriceStep storedStep : priceSteps ) { if ( storedStep . getStartPrice ( ) == startPrice && storedStep . getEndPrice ( ) == endPrice ) { removeStep = storedStep ; } } if ( removeStep == null ) { throw new PriceStepIntervalNotFoundException ( ) ; } else { priceSteps . remove ( removeStep ) ; } }
va	6	public boolean shellCollideCheck ( Shell shell ) { if ( deadTime != 0 ) return false ; float xD = shell . x - x ; float yD = shell . y - y ; if ( xD > - 16 && xD < 16 ) { if ( yD > - height && yD < shell . height ) { world . sound . play ( Art . samples [ Art . SAMPLE_MARIO_KICK ] , this , 1 , 1 , 1 ) ; dead = true ; xa = 0 ; ya = 1 ; deadTime = 100 ; if ( world . recorder != null ) world . recorder . shellKillRecord ( this ) ; return true ; } } return false ; }
va	4	public void testFileContent ( ) throws IOException { long start = System . currentTimeMillis ( ) ; byte [ ] buf1 = new byte [ 1024 ] ; byte [ ] buf2 = new byte [ 1024 ] ; int size1 , size2 ; String fileName1 = "test1.class" ; String fileName2 = "test2.class" ; File file1 = new File ( fileName1 ) ; File file2 = new File ( fileName2 ) ; BufferedInputStream bis1 = new BufferedInputStream ( new FileInputStream ( file1 ) ) ; BufferedInputStream bis2 = new BufferedInputStream ( new FileInputStream ( file2 ) ) ; Polynomial polynomial = Polynomial . createIrreducible ( 53 ) ; Fingerprint < Polynomial > rabin1 = new RabinFingerprintLong ( polynomial ) ; Fingerprint < Polynomial > rabin2 = new RabinFingerprintLong ( polynomial ) ; while ( ( ( size1 = bis1 . read ( buf1 ) ) != - 1 ) && ( ( size2 = bis2 . read ( buf2 ) ) != - 1 ) ) { rabin1 . pushBytes ( buf1 ) ; rabin2 . pushBytes ( buf2 ) ; String s1 = new String ( buf1 ) ; String s2 = new String ( buf2 ) ; if ( rabin1 . getFingerprint ( ) . compareTo ( rabin2 . getFingerprint ( ) ) != 0 ) { System . out . println ( "file 1 and file 2 are different!" ) ; break ; } } if ( rabin1 . getFingerprint ( ) . compareTo ( rabin2 . getFingerprint ( ) ) == 0 ) System . out . println ( "file 1 and file 2 are the same!" ) ; long end = System . currentTimeMillis ( ) ; System . out . println ( "Time: " + ( end - start ) + "ms." ) ; assertEquals ( 0 , rabin1 . getFingerprint ( ) . compareTo ( rabin2 . getFingerprint ( ) ) ) ; }
va	5	@ Override public void actionPerformed ( ActionEvent e ) { JMenuItem popup = ( JMenuItem ) e . getSource ( ) ; String name = popup . getName ( ) ; switch ( name ) { case "add track" : List < TrackBean > selectedTracks = view . getSelectedTracks ( ) ; model . addTracksToPlaylist ( selectedTracks ) ; view . setDisplayedPlaylist ( model . getPlaylist ( ) ) ; break ; case "add album" : AlbumBean selectedAlbum = view . getSelectedAlbum ( ) ; model . addTracksToPlaylist ( selectedAlbum . getTracks ( ) ) ; view . setDisplayedPlaylist ( model . getPlaylist ( ) ) ; break ; case "clear playlist" : model . stopSong ( false ) ; view . setDisplayedPlaylist ( model . getPlaylist ( ) ) ; break ; case "remove track" : removeTracks ( ) ; break ; case "get info" : view . displayInfoDialog ( view . getSelectedTracks ( ) . get ( 0 ) ) ; break ; } }
va	0	public boolean get ( int value ) { assertValue ( value ) ; return ( bitset & 1 << value ) > 0 ; }
va	4	public Rectangle2D getDrawableArea ( Unit unit ) { double w = paperWidth . getValue ( unit ) ; double x = 0 ; if ( leftMargin != null ) { x = leftMargin . getValue ( unit ) ; w -= x ; } if ( rightMargin != null ) { w -= rightMargin . getValue ( unit ) ; } double h = paperHeight . getValue ( unit ) ; double y = 0 ; if ( topMargin != null ) { y = topMargin . getValue ( unit ) ; h -= y ; } if ( bottomMargin != null ) { h -= bottomMargin . getValue ( unit ) ; } return new Rectangle2D . double ( x , y , w , h ) ; }
va	5	public boolean isIsAndOrSentenceHelper ( List < String > words , String sentencePtn , String ptn1 , String ptn2 ) { PropertyConfigurator . configure ( "conf/log4j.properties" ) ; Logger myLogger = Logger . getLogger ( "learn.isIsAndOrSentence" ) ; sentencePtn = sentencePtn . toLowerCase ( ) ; sentencePtn = sentencePtn . replaceAll ( "t" , "m" ) ; Pattern p1 = Pattern . compile ( ptn1 ) ; Matcher m1 = p1 . matcher ( sentencePtn ) ; Pattern p2 = Pattern . compile ( ptn2 ) ; Matcher m2 = p2 . matcher ( sentencePtn ) ; int end = - 1 ; boolean case1 = false ; boolean case2 = false ; if ( m1 . find ( ) ) { end = m1 . end ( ) ; case1 = true ; } if ( m2 . find ( ) ) { end = m2 . end ( ) ; case2 = true ; } if ( case1 || case2 ) { String matchedWords = StringUtils . join ( words . subList ( 0 , end ) , " " ) ; String regex = String . format ( "\\b(%s)\\b" , this . myLearnerUtility . getConstant ( ) . PREPOSITION ) ; if ( StringUtility . isMatchedNullSafe ( matchedWords , regex ) ) { myLogger . trace ( "Case 1" ) ; return false ; } myLogger . trace ( "Case 2" ) ; return true ; } myLogger . trace ( "Case 3" ) ; return false ; }
va	5	public Identifier AddUser ( User info ) { try { if ( info . getContact ( ) == null || info . getContact ( ) . getEmail ( ) == null || info . getFirstName ( ) == null || info . getLastName ( ) == null ) { return null ; } return Users . getInstance ( ) . create ( info ) ; } catch ( DataBaseReadWriteException | IdentifierAlreadyExistsException | InvalidParameterException e ) { System . err . println ( "Failed to Add user. " + e . getMessage ( ) ) ; return null ; } }
va	1	public static StroopTest createOneColourTest ( int wordSize ) { List < Word > words = new ArrayList < Word > ( wordSize ) ; for ( int i = 0 ; i < wordSize ; i ++ ) { words . add ( WordFactory . createRandomColourWord ( ) ) ; } return new StroopTest ( words , TestType . TEST_WORD ) ; }
va	4	private static String readLine ( int lineNumber ) { BufferedReader reader = null ; String line = "" ; try { reader = new BufferedReader ( new FileReader ( file ) ) ; int i = 0 ; for ( String curLine ; ( curLine = reader . readLine ( ) ) != null ; i ++ ) { if ( i == lineNumber ) line = curLine ; } } catch ( IOException e ) { } finally { try { reader . close ( ) ; } catch ( Exception e ) { } } return line ; }
va	3	private void reverseGraph ( ) { for ( int i = 0 ; i < n ; i ++ ) { graphT . add ( new ArrayList < Integer > ( ) ) ; } for ( int i = 0 ; i < n ; i ++ ) { ArrayList < Integer > list = graph . get ( i ) ; for ( int j = 0 ; j < list . size ( ) ; j ++ ) { int vertex = list . get ( j ) ; graphT . get ( vertex ) . add ( i ) ; } } }
va	5	public int getPerceptIndex ( String percept ) { if ( percept . equals ( SOLVED ) ) { return ( getPerceptsNumber ( ) - 1 ) ; } else { int [ ] values = new int [ 2 ] ; int k = 0 ; try { StreamTokenizer tokenizer = new StreamTokenizer ( new StringReader ( percept ) ) ; while ( k < 2 && tokenizer . nextToken ( ) != StreamTokenizer . TT_EOF ) { if ( tokenizer . ttype == StreamTokenizer . TT_NUMBER ) { values [ k ] = ( int ) ( tokenizer . nval ) ; k ++ ; } } return values [ 0 ] * DIGITS + values [ 1 ] ; } catch ( Exception e ) { return - 1 ; } } }
va	1	public Labels getLabels ( ) { if ( labels == null ) { labels = new Labels ( ) ; } return labels ; }
va	9X	public static void main ( String [ ] args ) throws IOException { Scanner in = new Scanner ( System . in ) ; byte p1 = 3 ; int p1Guess ; int p1Taken ; byte p2 = 3 ; int p2Guess ; int p2Taken ; boolean p1Turn = true ; byte round = 0 ; System . out . println ( "Stone game" ) ; while ( p1 > 0 && p2 > 0 ) { System . out . println ( "------------------" ) ; System . out . println ( "Round: " + ++ round ) ; System . out . println ( " You have " + p1 + " stones; CPU has " + p2 + " stones" ) ; System . out . println ( " How much stones you're taking: " ) ; do p1Taken = in . nextInt ( ) ; while ( p1Taken > p1 || p1Taken < 0 ) ; p2Taken = Game . randInt ( 0 , p2 ) ; if ( p1Turn ) { System . out . println ( " Your guess is: " ) ; p1Guess = in . nextInt ( ) ; do { int rand_min = p1Guess - p2 ; if ( rand_min < 0 ) rand_min = 0 ; p2Guess = Game . randInt ( rand_min , p1 + p2 ) ; } while ( p2Guess == p1Guess ) ; System . out . println ( "CPU is thinking of: " + p2Guess ) ; } else { p2Guess = Game . randInt ( p2Taken , p2Taken + p1 ) ; System . out . println ( "CPU is thinking of: " + p2Guess ) ; System . out . println ( " Your guess is: " ) ; do p1Guess = in . nextInt ( ) ; while ( p1Guess == p2Guess ) ; } System . out . println ( "We took: " + p1Taken + " P2 took: " + p2Taken + " stones" ) ; if ( p1Guess == ( p1Taken + p2Taken ) ) { System . out . println ( "We won " + round + ". round" ) ; -- p1 ; p1Turn = true ; } else if ( p2Guess == ( p1Taken + p2Taken ) ) { System . out . println ( "CPU won " + round + ". round" ) ; -- p2 ; p1Turn = false ; } else p1Turn = ! p1Turn ; } System . out . println ( "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!" ) ; if ( p1 == 0 ) System . out . println ( "PLAYER 1 HAS WON" ) ; else System . out . println ( "CPU HAS WON" ) ; System . out . println ( "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!" ) ; }
va	8	public void connect1 ( TreeLinkNode root ) { if ( root == null ) return ; Queue < TreeLinkNode > curLev = new LinkedList < TreeLinkNode > ( ) ; curLev . add ( root ) ; while ( ! curLev . isEmpty ( ) ) { Queue < TreeLinkNode > nextLev = new LinkedList < TreeLinkNode > ( ) ; while ( ! curLev . isEmpty ( ) ) { TreeLinkNode cur = curLev . poll ( ) ; if ( cur . left != null ) nextLev . add ( cur . left ) ; if ( cur . right != null ) nextLev . add ( cur . right ) ; if ( ! curLev . isEmpty ( ) ) { TreeLinkNode curNext = curLev . peek ( ) ; if ( curNext . left != null ) nextLev . add ( cur . left ) ; if ( curNext . right != null ) nextLev . add ( cur . right ) ; cur . next = curNext ; } } curLev = nextLev ; } }
va	3	private int compareInputStreams ( InputStream encfsIs , InputStream decFsIs , String decodedFsFileName ) throws IOException { int bytesRead = 0 ; int bytesRead2 ; while ( bytesRead >= 0 ) { byte [ ] readBuf = new byte [ 128 ] ; byte [ ] readBuf2 = new byte [ 128 ] ; bytesRead = encfsIs . read ( readBuf ) ; bytesRead2 = decFsIs . read ( readBuf2 ) ; if ( bytesRead != bytesRead2 ) { logger . error ( "File bytes read missmatch {} ({}  {})" , new Object [ ] { decodedFsFileName , bytesRead , bytesRead2 } ) ; return - 1 ; } if ( ! Arrays . equals ( readBuf , readBuf2 ) ) { logger . error ( "File bytes missmatch {}" , decodedFsFileName ) ; return - 1 ; } } return 0 ; }
