tr	3	@ Override public void run ( ) { while ( isRunning ) { try { msgProto . newInboundMsg ( activeConnections . getIdByOIS ( ois ) , ( Message ) ois . readObject ( ) ) ; } catch ( ClassNotFoundException | IOException e1 ) { System . out . println ( "Could not retriev ObjectInputStream" ) ; activeConnections . unregisterByOIS ( ois ) ; break ; } try { Thread . sleep ( SPEED ) ; } catch ( InterruptedException e ) { } } }
tr	5	static synchronized HashMap < Object , int [ ] > getGridPositions ( Object parComp ) { if ( PARENT_GRIDPOS_MAP == null ) return null ; LinkedHashMap < Integer , Cell > grid = PARENT_GRIDPOS_MAP . get ( parComp ) ; if ( grid == null ) return null ; HashMap < Object , int [ ] > retMap = new HashMap < Object , int [ ] > ( ) ; for ( Map . Entry < Integer , Cell > e : grid . entrySet ( ) ) { Cell cell = e . getValue ( ) ; Integer xyInt = e . getKey ( ) ; if ( xyInt != null ) { int x = xyInt & 0000ffff ; int y = xyInt >> 16 ; for ( CompWrap cw : cell . compWraps ) retMap . put ( cw . comp . getComponent ( ) , new int [ ] { x , y , cell . spanx , cell . spany } ) ; } } return retMap ; }
tr	9	public static void sprstp ( int [ ] sa , int [ ] ija , double [ ] sb , int [ ] ijb ) throws NRException { int j , jl , jm , jp , ju , k , m , n2 , noff , inc , iv ; double v ; n2 = ija [ 0 ] ; for ( j = 0 ; j < n2 - 1 ; j ++ ) sb [ j ] = sa [ j ] ; int [ ] ija_vec = nfill ( ija [ n2 ] , ija [ n2 - 1 ] - ija [ 0 ] ) ; int [ ] ijb_vec = new int [ ija [ n2 - 1 ] - ija [ 0 ] ] ; indexx ( ija_vec , ijb_vec ) ; for ( j = n2 , k = 0 ; j < ija [ n2 - 1 ] ; j ++ , k ++ ) { ijb [ j ] = ijb_vec [ k ] ; } jp = 0 ; for ( k = ija [ 0 ] ; k < ija [ n2 - 1 ] ; k ++ ) { m = ijb [ k ] + n2 ; sb [ k ] = sa [ m ] ; for ( j = jp ; j < ija [ m ] + 1 ; j ++ ) ijb [ j ] = k ; jp = ija [ m ] + 1 ; jl = 0 ; ju = n2 - 1 ; while ( ju - jl > 1 ) { jm = ( ju + jl ) / 2 ; if ( ija [ jm ] > m ) ju = jm ; else jl = jm ; } ijb [ k ] = jl ; } for ( j = jp ; j < n2 ; j ++ ) ijb [ j ] = ija [ n2 - 1 ] ; for ( j = 0 ; j < n2 - 1 ; j ++ ) { jl = ijb [ j + 1 ] - ijb [ j ] ; noff = ijb [ j ] ; inc = 1 ; do { inc *= 3 ; inc ++ ; } while ( inc <= jl ) ; do { inc /= 3 ; for ( k = noff + inc ; k < noff + jl ; k ++ ) { iv = ijb [ k ] ; v = sb [ k ] ; m = k ; while ( ijb [ m - inc ] > iv ) { ijb [ m ] = ijb [ m - inc ] ; sb [ m ] = sb [ m - inc ] ; m -= inc ; if ( m - noff + 1 <= inc ) break ; } ijb [ m ] = iv ; sb [ m ] = v ; } } while ( inc > 1 ) ; } }
tr	2	public FileChooseElement ( final FileChooser fileChooser ) { init ( new EventHandler < ActionEvent > ( ) { @ Override public void handle ( ActionEvent actionEvent ) { if ( mChosenFile . get ( ) != null ) fileChooser . setInitialDirectory ( mChosenFile . get ( ) . toFile ( ) . getParentFile ( ) ) ; File chosen = fileChooser . showSaveDialog ( getScene ( ) . getWindow ( ) ) ; if ( chosen != null ) setChosenFile ( chosen . toPath ( ) ) ; } } ) ; }
tr	8	public void updateList ( ) { listModel . clear ( ) ; ArrayList < String > a = new ArrayList < > ( ) ; for ( Course co : aList ) { if ( co . getInstructor ( ) == null && co . getLab ( ) == null ) { listModel . addElement ( co . getClassCode ( ) + " " + co . getSection ( ) + " : " + "n/a" ) ; } else if ( co . getInstructor ( ) != null && co . getLab ( ) != null ) { a . add ( co . getClassCode ( ) + " " + co . getSection ( ) + " : " + co . getInstructor ( ) . getName ( ) + " (Lab)" ) ; } else if ( co . getInstructor ( ) != null && co . getLab ( ) == null ) { a . add ( co . getClassCode ( ) + " " + co . getSection ( ) + " : " + co . getInstructor ( ) . getName ( ) ) ; } else { listModel . addElement ( co . getClassCode ( ) + " " + co . getSection ( ) + " : " + "n/a" + " (Lab)" ) ; } } Collections . sort ( a ) ; for ( int i = 0 ; i < a . size ( ) ; i ++ ) { listModel . add ( i , a . get ( i ) ) ; } }
tr	1	public String getMapType ( SwarmSymbolTable symbolTable ) { try { SwarmSymbolMap map = symbolTable . lookupMap ( myIdentifier . getIdentifierName ( ) ) ; return map . getTypeName ( ) ; } catch ( SwarmSymbolNotFoundException e ) { return null ; } }
tr	2	public void changeLink ( State origin , Character character , State target ) { if ( states . contains ( origin ) && states . contains ( target ) ) { origin . getTransitionTable ( ) . updateTransition ( character , target ) ; } }
tr	8	@ Override public void keyPressed ( KeyEvent e ) { traceKeyEvents ( e ) ; switch ( e . getKeyCode ( ) ) { case KeyEvent . VK_LEFT : case KeyEvent . VK_NUMPAD4 : case KeyEvent . VK_A : deltaX -- ; xPosition = xPosition + deltaX ; if ( xPosition < 0 ) xPosition = canvasWidth ; repaint ( ) ; break ; case KeyEvent . VK_RIGHT : case KeyEvent . VK_NUMPAD6 : case KeyEvent . VK_D : deltaX ++ ; xPosition = xPosition + deltaX ; if ( xPosition > canvasWidth ) xPosition = 0 ; repaint ( ) ; break ; } }
tr	1	public CoverDetails deserialize ( JSONObject json ) throws Exception { Integer id = ( Integer ) json . get ( id_key ) ; String artist = ( String ) json . get ( artist_key ) ; String album = ( String ) json . get ( album_key ) ; Integer discNumber = ( Integer ) json . get ( disc_key ) ; boolean noImage = ( boolean ) json . get ( noImage_key ) ; JSONArray tracks = ( JSONArray ) json . get ( tracks_key ) ; int len = tracks . length ( ) ; List < TrackDetails > trackNames = new ArrayList < TrackDetails > ( len ) ; for ( int i = 0 ; i < len ; i ++ ) { JSONObject trackJson = ( JSONObject ) tracks . get ( i ) ; String title = ( String ) trackJson . get ( title_key ) ; Integer lengthSeconds = ( Integer ) trackJson . get ( length_key ) ; trackNames . add ( new TrackDetails ( title , lengthSeconds . intValue ( ) ) ) ; } Image image = null ; CoverDetails cover = new CoverDetails ( id . intValue ( ) , artist , album , image , discNumber . intValue ( ) , noImage . booleanValue ( ) ) ; cover . setTrackNames ( trackNames ) ; return cover ; }
tr	8	public void drawAlphaTextWithShadow ( String text , int x , int y , int currentColour , int seed ) { if ( text == null ) return ; random . setSeed ( seed ) ; int alpha = 192 + ( random . nextInt ( ) & 1f ) ; y -= fontHeight ; for ( int c = 0 ; c < text . length ( ) ; c ++ ) { if ( text . charAt ( c ) == @ && c + 4 < text . length ( ) && text . charAt ( c + 4 ) == @ ) { int colour = handleEmbeddedEffect ( text . substring ( c + 1 , c + 4 ) ) ; if ( colour != - 1 ) currentColour = colour ; c += 4 ; } else { char character = text . charAt ( c ) ; if ( character !=   ) { drawGlyphAlpha ( glyphPixels [ character ] , x + horizontalKerning [ character ] + 1 , y + verticalKerning [ character ] + 1 , glyphWidth [ character ] , glyphHeight [ character ] , 0 , 192 ) ; drawGlyphAlpha ( glyphPixels [ character ] , x + horizontalKerning [ character ] , y + verticalKerning [ character ] , glyphWidth [ character ] , glyphHeight [ character ] , currentColour , alpha ) ; } x += glyphDisplayWidth [ character ] ; if ( ( random . nextInt ( ) & 3 ) == 0 ) x ++ ; } } }
tr	9	public boolean isMatching ( StringBuffer word , int wordPos ) { boolean matching = true , inMulti = false , multiMatch = false ; char matchCh ; for ( int matchPos = 0 ; matchPos < match . length ; matchPos ++ ) { matchCh = match [ matchPos ] ; if ( matchCh == STARTMULTI || matchCh == ENDMULTI ) { inMulti = ! inMulti ; if ( ! inMulti ) matching = matching & multiMatch ; else multiMatch = false ; } else { if ( matchCh != word . charAt ( wordPos ) ) { if ( inMulti ) multiMatch = multiMatch | false ; else matching = false ; } else { if ( inMulti ) multiMatch = multiMatch | true ; else matching = true ; } if ( ! inMulti ) wordPos ++ ; if ( ! matching ) break ; } } if ( end && wordPos != word . length ( ) ) matching = false ; return matching ; }
tr	0	public boolean blocksLineOfSight ( ) { return false ; }
tr	3	public boolean storeMove ( String moveMessage , String ip , int port ) { int playerIndex ; boolean isValidMove = false , moveCompleted = false ; String rejReason = "" ; Card cardPlayed = new Card ( moveMessage ) ; playerIndex = pg . getPlayerIndex ( ip , port ) ; Card [ ] hand = pg . getPlayer ( playerIndex ) . getHand ( ) ; if ( this . cardPlayedCounter == 0 ) { if ( this . currGameState != Game . GAME_PLAY ) this . currGameState = Game . GAME_PLAY ; moveCompleted = doMove ( playerIndex , cardPlayed , hand ) ; this . ledCard = cardPlayed ; } else { rejReason = checkForValidMove ( cardPlayed , playerIndex , ip , port , hand ) ; if ( rejReason . equals ( "" ) ) moveCompleted = doMove ( playerIndex , cardPlayed , hand ) ; else { pg . privateMessage ( "sCardRej " + rejReason , ip , port ) ; } } return moveCompleted ; }
tr	7	public static void main ( String [ ] args ) { boolean all_right ; all_right = true ; int [ ] p0 ; int p1 ; p0 = new int [ ] { 5 , 1 , 2 } ; p1 = 4 ; all_right = KawigiEdit_RunTest ( 0 , p0 , true , p1 ) && all_right ; p0 = new int [ ] { 2 , 1 , 4 } ; p1 = 8 ; all_right = KawigiEdit_RunTest ( 1 , p0 , true , p1 ) && all_right ; p0 = new int [ ] { 2 , 1 , 2 , 7 } ; p1 = 6 ; all_right = KawigiEdit_RunTest ( 2 , p0 , true , p1 ) && all_right ; p0 = new int [ ] { 94512 , 2 , 87654 , 81316 , 6 , 5 , 6 , 37151 , 6 , 139 , 1 , 36 , 307 , 1 , 377 , 101 , 8 , 37 , 58 , 1 } ; p1 = 1092 ; all_right = KawigiEdit_RunTest ( 3 , p0 , true , p1 ) && all_right ; p0 = new int [ ] { 883 , 66392 , 3531 , 28257 , 1 , 14131 , 57 , 1 , 25 , 88474 , 4 , 1 , 110 , 6 , 1769 , 220 , 442 , 7064 , 7 , 13 } ; p1 = 56523 ; all_right = KawigiEdit_RunTest ( 4 , p0 , true , p1 ) && all_right ; p0 = new int [ ] { 2 , 3 } ; p1 = 1 ; all_right = KawigiEdit_RunTest ( 4 , p0 , true , p1 ) && all_right ; if ( all_right ) { System . out . println ( "You're a stud (at least on the example cases)!" ) ; } else { System . out . println ( "Some of the test cases had errors." ) ; } }
tr	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( EditStajFrame . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( EditStajFrame . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( EditStajFrame . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( EditStajFrame . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { new EditStajFrame ( ) . setVisible ( true ) ; } } ) ; }
tr	8	public boolean remove_special ( String s , String p , String o , String s_type , String o_type ) { String ret ; deb_print ( "<remove_special>\n" ) ; deb_print ( "Perform the QUERY\n" ) ; ret = queryRDF ( s . equals ( "*" ) ? null : s , p . equals ( "*" ) ? null : p , o . equals ( "*" ) ? null : o , s_type , o_type ) ; deb_print ( "KP-CORE MESSAGE:" + getErrMess ( ) + "(" + getErrID ( ) + ")\n" ) ; deb_print ( "RDFQuery confirmed:" + ( this . xmlTools . isQueryConfirmed ( ret ) ? "YES" : "NO" ) + "\n" ) ; deb_print ( "*** SSAP message status:" + xmlTools . getSSAPmsgStatus ( ret ) + "\n" ) ; if ( ! this . xmlTools . isQueryConfirmed ( ret ) ) return false ; Vector < Vector < String >> triples = null ; if ( ret != null ) triples = this . xmlTools . getQueryTriple ( ret ) ; if ( triples != null ) { deb_print ( "Triple to remove:\n" ) ; for ( int i = 0 ; i < triples . size ( ) ; i ++ ) { Vector < String > t = triples . get ( i ) ; String st = "  S:[" + t . get ( 0 ) + "] P:[" + t . get ( 1 ) + "] O:[" + t . get ( 2 ) + "] Otype:[" + t . get ( 3 ) + "]" ; deb_print ( st + "\n" ) ; ret = remove ( t . get ( 0 ) , t . get ( 1 ) , t . get ( 2 ) , "uri" , t . get ( 3 ) ) ; deb_print ( "KP-CORE MESSAGE:" + getErrMess ( ) + "(" + getErrID ( ) + ")\n" ) ; deb_print ( "*** SSAP message status:" + xmlTools . getSSAPmsgStatus ( ret ) + "\n" ) ; } } deb_print ( "</remove_special>\n" ) ; return true ; }
tr	6	public static String getDescription ( int value ) { String description = "Undefined" ; switch ( value ) { case OTHER : description = "Other" ; break ; case KY_28 : description = "KY-28" ; break ; case KY_58 : description = "KY-58" ; break ; case NSVE : description = "Narrow Spectrum Secure Voice" ; break ; case WSVE : description = "Wide Spectrum Secure Voice" ; break ; case SINCGARS_ICOM : description = "SINCGARS ICOM" ; break ; } return description ; }
tr	2	private Player getWinner ( ) { for ( Player player : playerList . getPlayers ( ) ) { if ( ! player . isBankrupt ( ) ) { return player ; } } return null ; }
tr	2	public ResultSet getResults ( Connection conn , String sql ) { try { stmt = conn . createStatement ( ) ; } catch ( SQLException ex ) { Logger . getLogger ( HelpDeskMainFrame . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } try { rs = stmt . executeQuery ( sql ) ; } catch ( SQLException ex ) { Logger . getLogger ( HelpDeskMainFrame . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } return rs ; }
tr	9	private Description deserialise ( SingleDescriptionTriples buffer , List < Description > additional ) throws DeserialisationException { if ( buffer . hasBeenDeserialised ( ) ) { return buffer . getDeserialisation ( ) ; } URI type = getSpecificType ( buffer ) ; Description description ; if ( type == null ) { type = getImpliedType ( buffer . getSubject ( ) ) ; if ( type == null ) { return null ; } } description = ProvConstructer . create ( type , buffer . getIdentifier ( ) ) ; buffer . setDeserialisation ( description ) ; for ( URI predicate : buffer . getPredicates ( ) ) { if ( ! predicate . equals ( RDF . typeURI ( ) ) ) { if ( Term . isProvTerm ( predicate ) ) { deserialise ( predicate , buffer , description , additional ) ; } else { if ( description instanceof AttributeHolder ) { for ( Literal object : buffer . getLiteralObjects ( predicate ) ) { ( ( AttributeHolder ) description ) . addAttribute ( predicate , object . _value ) ; } for ( URI object : buffer . getURIObjects ( predicate ) ) { ( ( AttributeHolder ) description ) . addAttribute ( predicate , object ) ; } } } } } return description ; }
tr	2	public Image getImage ( URL url ) { try { Object content = url . getContent ( ) ; if ( content instanceof ImageProducer ) { return applet . createImage ( ( ImageProducer ) content ) ; } } catch ( IOException ex ) { } return null ; }
tr	5	Message writeFailureResponse ( String reason ) { String xmlString ; if ( myDLE == null ) { xmlString = Message . responseHeader ( clientIdToServer , reason ) + "<signInResponse id='" + myEventId + "' type='closed' behavior='roundRobin' question='question' " + "numChoices='0' numRounds='1' position='0'/></response>" ; } else { xmlString = Message . responseHeader ( clientIdToServer , reason ) + "<signInResponse id='" + myDLE . getUniqueId ( ) + "' " ; if ( myDLE . getEventType ( ) == EventType . CLOSED || myDLE . getEventType ( ) == EventType . FINISHED ) xmlString = xmlString + "type='closed' " ; else xmlString = xmlString + "type='open' " ; if ( myDLE . getBehavior ( ) == Behavior . ROUNDROBIN ) xmlString = xmlString + "behavior='roundRobin' " ; else xmlString = xmlString + "behavior='asynchronous' " ; xmlString = xmlString + "question='" + myDLE . getQuestion ( ) + "' " + " numChoices='" + myDLE . getNumberOfChoices ( ) + "' numRounds='" + myDLE . getNumberOfEdges ( ) + "' " + "position='" + newUser . getPosition ( ) + "'>" ; for ( int i = 0 ; i < myDLE . getChoices ( ) . size ( ) ; i ++ ) { Choice tmpChoice = myDLE . getChoices ( ) . get ( i ) ; xmlString = xmlString + "<choice value='" + tmpChoice . getName ( ) + "' index='" + tmpChoice . getOrder ( ) + "'/>" ; } xmlString = xmlString + "</signInResponse></response>" ; } System . out . println ( "Error Response: " + xmlString ) ; return new Message ( xmlString ) ; }
tr	9	private void order ( long time , boolean inside ) { do { if ( lastInside ) { if ( start == 8 * ONE_HOUR ) { long delta = Math . max ( ( Math . min ( time , lastStart + 10 * ONE_HOUR ) - lastTime ) , 0 ) ; lastRecentDays [ 9 ] += delta ; System . out . println ( "add delta:" + delta + " on time:" + time + "/" + getTime ( time ) + " lastStart:" + getTime ( lastStart ) + " lastTime:" + getTime ( lastTime ) ) ; } else if ( start == 18 * ONE_HOUR ) { long delta = Math . max ( ( Math . min ( time , lastStart + 14 * ONE_HOUR ) - lastTime ) , 0 ) ; lastRecentDays [ 9 ] += delta ; System . out . println ( "add delta:" + delta + " on time:" + time + "/" + getTime ( time ) + " lastStart:" + getTime ( lastStart ) + " lastTime:" + getTime ( lastTime ) ) ; } } if ( time < lastStart + ONE_DAY ) { lastTime = time ; } else { lastTime = lastStart + ONE_DAY ; for ( int i = 0 ; i < lastRecentDays . length - 1 ; i ++ ) { lastRecentDays [ i ] = lastRecentDays [ i + 1 ] ; } lastRecentDays [ 9 ] = 0 ; lastStart += ONE_DAY ; if ( lastInside && time < lastStart + ONE_DAY ) { if ( start == 8 * ONE_HOUR ) { long delta = Math . max ( ( Math . min ( time , lastStart + 10 * ONE_HOUR ) - lastTime ) , 0 ) ; lastRecentDays [ 9 ] += delta ; System . out . println ( "add delta:" + delta + " on time:" + time + "/" + getTime ( time ) + " lastStart:" + getTime ( lastStart ) + " lastTime:" + getTime ( lastTime ) ) ; } else if ( start == 18 * ONE_HOUR ) { long delta = Math . max ( ( Math . min ( time , lastStart + 14 * ONE_HOUR ) - lastTime ) , 0 ) ; lastRecentDays [ 9 ] += delta ; System . out . println ( "add delta:" + delta + " on time:" + time + "/" + getTime ( time ) + " lastStart:" + getTime ( lastStart ) + " lastTime:" + getTime ( lastTime ) ) ; } } } } while ( time > lastStart + ONE_DAY - 1 ) ; lastInside = inside ; lastTime = time ; System . out . println ( ArrayUtils . toString ( lastRecentDays ) ) ; }
tr	2	public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; int current = first ; while ( current != last ) { sb . append ( arr [ current ] . toString ( ) + " " ) ; if ( ++ current >= arr . length ) { current = 0 ; } } return sb . toString ( ) ; }
tr	4	public static double [ ] [ ] produitMat ( double [ ] [ ] m1 , double [ ] [ ] m2 ) { int n1 = m1 . length ; int l1 = m1 [ 0 ] . length ; int n2 = m2 . length ; int l2 = m2 [ 0 ] . length ; double [ ] [ ] res = new double [ n1 ] [ l2 ] ; if ( ! ( l1 == n2 ) ) { System . out . println ( "Tailles non concordantes" ) ; } else { for ( int i = 0 ; i < n1 ; i ++ ) { for ( int j = 0 ; j < l2 ; j ++ ) { res [ i ] [ j ] = 0 ; for ( int l = 0 ; l < l1 ; l ++ ) { res [ i ] [ j ] += m1 [ i ] [ l ] * m2 [ l ] [ j ] ; } } } } return res ; }
tr	9	public double noise ( double xin , double yin , double zin ) { double n0 , n1 , n2 , n3 ; double s = ( xin + yin + zin ) * F3 ; int i = fastfloor ( xin + s ) ; int j = fastfloor ( yin + s ) ; int k = fastfloor ( zin + s ) ; double t = ( i + j + k ) * G3 ; double X0 = i - t ; double Y0 = j - t ; double Z0 = k - t ; double x0 = xin - X0 ; double y0 = yin - Y0 ; double z0 = zin - Z0 ; int i1 , j1 , k1 ; int i2 , j2 , k2 ; if ( x0 >= y0 ) { if ( y0 >= z0 ) { i1 = 1 ; j1 = 0 ; k1 = 0 ; i2 = 1 ; j2 = 1 ; k2 = 0 ; } else if ( x0 >= z0 ) { i1 = 1 ; j1 = 0 ; k1 = 0 ; i2 = 1 ; j2 = 0 ; k2 = 1 ; } else { i1 = 0 ; j1 = 0 ; k1 = 1 ; i2 = 1 ; j2 = 0 ; k2 = 1 ; } } else { if ( y0 < z0 ) { i1 = 0 ; j1 = 0 ; k1 = 1 ; i2 = 0 ; j2 = 1 ; k2 = 1 ; } else if ( x0 < z0 ) { i1 = 0 ; j1 = 1 ; k1 = 0 ; i2 = 0 ; j2 = 1 ; k2 = 1 ; } else { i1 = 0 ; j1 = 1 ; k1 = 0 ; i2 = 1 ; j2 = 1 ; k2 = 0 ; } } double x1 = x0 - i1 + G3 ; double y1 = y0 - j1 + G3 ; double z1 = z0 - k1 + G3 ; double x2 = x0 - i2 + 2.0 * G3 ; double y2 = y0 - j2 + 2.0 * G3 ; double z2 = z0 - k2 + 2.0 * G3 ; double x3 = x0 - 1.0 + 3.0 * G3 ; double y3 = y0 - 1.0 + 3.0 * G3 ; double z3 = z0 - 1.0 + 3.0 * G3 ; int ii = i & 255 ; int jj = j & 255 ; int kk = k & 255 ; int gi0 = permMod12 [ ii + perm [ jj + perm [ kk ] ] ] ; int gi1 = permMod12 [ ii + i1 + perm [ jj + j1 + perm [ kk + k1 ] ] ] ; int gi2 = permMod12 [ ii + i2 + perm [ jj + j2 + perm [ kk + k2 ] ] ] ; int gi3 = permMod12 [ ii + 1 + perm [ jj + 1 + perm [ kk + 1 ] ] ] ; double t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0 ; if ( t0 < 0 ) n0 = 0.0 ; else { t0 *= t0 ; n0 = t0 * t0 * . ( grad3 [ gi0 ] , x0 , y0 , z0 ) ; } double t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1 ; if ( t1 < 0 ) n1 = 0.0 ; else { t1 *= t1 ; n1 = t1 * t1 * . ( grad3 [ gi1 ] , x1 , y1 , z1 ) ; } double t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2 ; if ( t2 < 0 ) n2 = 0.0 ; else { t2 *= t2 ; n2 = t2 * t2 * . ( grad3 [ gi2 ] , x2 , y2 , z2 ) ; } double t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3 ; if ( t3 < 0 ) n3 = 0.0 ; else { t3 *= t3 ; n3 = t3 * t3 * . ( grad3 [ gi3 ] , x3 , y3 , z3 ) ; } return 32.0 * ( n0 + n1 + n2 + n3 ) ; }
tr	6	public static double asinh ( double a ) { boolean negative = false ; if ( a < 0 ) { negative = true ; a = - a ; } double absAsinh ; if ( a > 0.167 ) { absAsinh = FastMath . log ( FastMath . sqrt ( a * a + 1 ) + a ) ; } else { final double a2 = a * a ; if ( a > 0.097 ) { absAsinh = a * ( 1 - a2 * ( 1 / 3.0 - a2 * ( 1 / 5.0 - a2 * ( 1 / 7.0 - a2 * ( 1 / 9.0 - a2 * ( 1.0 / 11.0 - a2 * ( 1.0 / 13.0 - a2 * ( 1.0 / 15.0 - a2 * ( 1.0 / 17.0 ) * 15.0 / 16.0 ) * 13.0 / 14.0 ) * 11.0 / 12.0 ) * 9.0 / 10.0 ) * 7.0 / 8.0 ) * 5.0 / 6.0 ) * 3.0 / 4.0 ) / 2.0 ) ; } else if ( a > 0.036 ) { absAsinh = a * ( 1 - a2 * ( 1 / 3.0 - a2 * ( 1 / 5.0 - a2 * ( 1 / 7.0 - a2 * ( 1 / 9.0 - a2 * ( 1.0 / 11.0 - a2 * ( 1.0 / 13.0 ) * 11.0 / 12.0 ) * 9.0 / 10.0 ) * 7.0 / 8.0 ) * 5.0 / 6.0 ) * 3.0 / 4.0 ) / 2.0 ) ; } else if ( a > 0.0036 ) { absAsinh = a * ( 1 - a2 * ( 1 / 3.0 - a2 * ( 1 / 5.0 - a2 * ( 1 / 7.0 - a2 * ( 1 / 9.0 ) * 7.0 / 8.0 ) * 5.0 / 6.0 ) * 3.0 / 4.0 ) / 2.0 ) ; } else { absAsinh = a * ( 1 - a2 * ( 1 / 3.0 - a2 * ( 1 / 5.0 ) * 3.0 / 4.0 ) / 2.0 ) ; } } return negative ? - absAsinh : absAsinh ; }
tr	6	@ Override public ArrayList < Sign > getSigns ( Location loc ) { Location sloc ; List < BlockFace > checklist = new ArrayList < BlockFace > ( ) ; checklist . add ( BlockFace . NORTH ) ; checklist . add ( BlockFace . EAST ) ; checklist . add ( BlockFace . SOUTH ) ; checklist . add ( BlockFace . WEST ) ; ArrayList < Sign > signList = new ArrayList < Sign > ( ) ; loc . setY ( loc . getBlockY ( ) - 2 ) ; if ( loc . getBlock ( ) . getState ( ) instanceof Sign ) { signList . add ( ( Sign ) loc . getBlock ( ) . getState ( ) ) ; } loc . setY ( loc . getBlockY ( ) + 1 ) ; for ( BlockFace bf : checklist ) { sloc = loc . getBlock ( ) . getRelative ( bf ) . getLocation ( ) ; if ( sloc . getBlock ( ) . getState ( ) instanceof Sign ) { signList . add ( ( Sign ) sloc . getBlock ( ) . getState ( ) ) ; } } loc . setY ( loc . getBlockY ( ) + 1 ) ; for ( BlockFace bf : checklist ) { sloc = loc . getBlock ( ) . getRelative ( bf ) . getLocation ( ) ; if ( sloc . getBlock ( ) . getState ( ) instanceof Sign ) { signList . add ( ( Sign ) sloc . getBlock ( ) . getState ( ) ) ; } } loc . setY ( loc . getBlockY ( ) + 1 ) ; if ( loc . getBlock ( ) . getState ( ) instanceof Sign ) { signList . add ( ( Sign ) loc . getBlock ( ) . getState ( ) ) ; } return signList ; }
tr	1	protected String [ ] getFontStyleNames ( ) { if ( fontStyleNames == null ) { int i = 0 ; fontStyleNames = new String [ 4 ] ; fontStyleNames [ i ++ ] = ( "Plain" ) ; fontStyleNames [ i ++ ] = ( "Bold" ) ; fontStyleNames [ i ++ ] = ( "Italic" ) ; fontStyleNames [ i ++ ] = ( "BoldItalic" ) ; } return fontStyleNames ; }
tr	1	private void addShortOption ( String shortcut , String value ) throws RuntimeException { if ( ! definition . hasShortcut ( shortcut ) ) { throw new RuntimeException ( String . format ( "The \"-%s\" option does not exist." , shortcut ) ) ; } addLongOption ( definition . getOptionForShortcut ( shortcut ) . getName ( ) , value ) ; }
tr	9	@ Override public void paintComponent ( Graphics g ) { this . g = ( Graphics2D ) g ; super . paintComponent ( g ) ; for ( int i = 0 ; i < ( this . size * this . size ) ; i ++ ) { this . g . drawLine ( getNodeX ( i ) , getNodeY ( i ) , getNodeX ( i ) , getNodeY ( i ) ) ; } Fire fire = this . loadedEnv . getLevel ( this . level ) . getFire ( ) ; int [ ] [ ] fireArray = fire . getArray ( ) ; for ( int i = 0 ; i < this . size ; i ++ ) { for ( int j = 0 ; j < this . size ; j ++ ) { if ( fireArray [ i ] [ j ] != 0 ) this . drawFire ( i * this . size + j , fireArray [ i ] [ j ] ) ; } } UndirectedGraph walls = this . loadedEnv . getLevel ( this . level ) . getWalls ( ) ; Iterator it = walls . getGraph ( ) . keySet ( ) . iterator ( ) ; while ( it . hasNext ( ) ) { int tempNode = Integer . parseInt ( it . next ( ) . toString ( ) ) ; Iterator it2 = ( ( ArrayList ) walls . getGraph ( ) . get ( tempNode ) ) . iterator ( ) ; while ( it2 . hasNext ( ) ) { int tempNode2 = Integer . parseInt ( it2 . next ( ) . toString ( ) ) ; this . drawWall ( tempNode , tempNode2 ) ; } } UndirectedGraph doors = this . loadedEnv . getLevel ( this . level ) . getDoors ( ) ; it = doors . getGraph ( ) . keySet ( ) . iterator ( ) ; while ( it . hasNext ( ) ) { int tempNode = Integer . parseInt ( it . next ( ) . toString ( ) ) ; Iterator it2 = ( ( ArrayList ) doors . getGraph ( ) . get ( tempNode ) ) . iterator ( ) ; while ( it2 . hasNext ( ) ) { int tempNode2 = Integer . parseInt ( it2 . next ( ) . toString ( ) ) ; this . drawDoor ( tempNode , tempNode2 ) ; } } UndirectedGraph exits = this . loadedEnv . getLevel ( this . level ) . getExits ( ) ; it = exits . getGraph ( ) . keySet ( ) . iterator ( ) ; while ( it . hasNext ( ) ) { int tempNode = Integer . parseInt ( it . next ( ) . toString ( ) ) ; Iterator it2 = ( ( ArrayList ) exits . getGraph ( ) . get ( tempNode ) ) . iterator ( ) ; while ( it2 . hasNext ( ) ) { int tempNode2 = Integer . parseInt ( it2 . next ( ) . toString ( ) ) ; this . drawExit ( tempNode , tempNode2 ) ; } } ArrayList agents = this . loadedEnv . getAgents ( ) ; it = agents . iterator ( ) ; while ( it . hasNext ( ) ) { Agent a = ( Agent ) it . next ( ) ; if ( a . getLevel ( ) == this . level ) this . drawAgent ( a ) ; } ArrayList labels = this . loadedEnv . getLevel ( this . level ) . getLabels ( ) ; it = labels . iterator ( ) ; while ( it . hasNext ( ) ) { Label l = ( Label ) it . next ( ) ; this . drawLabel ( l ) ; } if ( this . hNode1 != 0 && this . hNode2 != 0 ) this . drawHighlight ( ) ; }
tr	0	public final void set ( double xl , double yl , double xh , double yh ) { boundaryLowX = xl ; boundaryLowY = yl ; boundaryHiX = xh ; boundaryHiY = yh ; }
tr	6	public K [ ] getKeysInOrder ( K [ ] k , int startindex ) { HashMapObjectInt . Entry < K > [ ] entries = getEntries ( ) ; Arrays . sort ( entries , new Comparator < HashMapObjectInt . Entry < K >> ( ) { @ Override public int compare ( HashMapObjectInt . Entry < K > o1 , HashMapObjectInt . Entry < K > o2 ) { return o1 . getInt ( ) - o2 . getInt ( ) ; } } ) ; if ( startindex > 0 ) { int j = 0 ; for ( j = 0 ; j < entries . length && entries [ j ] . getInt ( ) < startindex ; j ++ ) ; entries = Arrays . copyOfRange ( entries , j , entries . length ) ; } K [ ] result = ( k . length >= entries . length ) ? k : ( K [ ] ) java . lang . reflect . Array . newInstance ( k . getClass ( ) . getComponentType ( ) , entries . length ) ; int i ; for ( i = 0 ; i < entries . length ; i ++ ) result [ i ] = entries [ i ] . getKey ( ) ; if ( i < result . length ) result [ i ] = null ; return result ; }
tr	9	public void select ( int start , int end ) { if ( ! selected || start != selectStart || end != selectEnd ) { if ( selectEnd < selectStart ) { selectNone ( ) ; } else { if ( selectStart >= wave . length ( ) ) selectStart = wave . length ( ) - 1 ; if ( selectEnd >= wave . length ( ) ) selectEnd = wave . length ( ) - 1 ; if ( selectStart < 0 ) selectStart = 0 ; if ( selectEnd < 0 ) selectEnd = 0 ; selectStart = start ; selectEnd = end ; selected = true ; if ( observer != null ) observer . waveCanvasEvent ( this , SELECT ) ; } } }
tr	8	DlgAddBooks ( Library lib ) { this . library = lib ; this . setDefaultCloseOperation ( JFrame . DISPOSE_ON_CLOSE ) ; this . setTitle ( "Add book" ) ; choosePic = new JButton ( "Choose picture" ) ; choosePic . setBounds ( 300 , 50 , 150 , 50 ) ; add = new JButton ( "Add" ) ; add . setBounds ( 75 , 500 , 100 , 30 ) ; close = new JButton ( "Cancel" ) ; close . setBounds ( 325 , 500 , 100 , 30 ) ; picturePanel = new JPanel ( ) ; picturePanel . setBackground ( Color . BLACK ) ; picturePanel . setBounds ( 50 , 20 , 210 , 280 ) ; picLabel = new JLabel ( ) ; picLabel . setSize ( 210 , 280 ) ; picturePanel . add ( picLabel ) ; jtf_isbn = new JTextField ( ) ; jtf_isbn . setBounds ( 120 , 330 , 300 , 25 ) ; jl_isbn = new JLabel ( "ISBN" ) ; jl_isbn . setBounds ( 40 , 330 , 100 , 25 ) ; jtf_name = new JTextField ( ) ; jtf_name . setBounds ( 120 , 370 , 300 , 25 ) ; jl_name = new JLabel ( "Name" ) ; jl_name . setBounds ( 40 , 370 , 100 , 25 ) ; jtf_author = new JTextField ( ) ; jtf_author . setBounds ( 120 , 410 , 300 , 25 ) ; jl_author = new JLabel ( "Author" ) ; jl_author . setBounds ( 40 , 410 , 100 , 25 ) ; String [ ] categoryStrings = { "Children" , "Cooking" , "History" , "Travel" } ; cb_category = new JComboBox ( categoryStrings ) ; cb_category . setBounds ( 120 , 450 , 300 , 25 ) ; jl_category = new JLabel ( "Category" ) ; jl_category . setBounds ( 40 , 450 , 100 , 25 ) ; this . add ( choosePic ) ; this . add ( add ) ; this . add ( close ) ; this . add ( picturePanel ) ; this . add ( jtf_isbn ) ; this . add ( jtf_name ) ; this . add ( jtf_author ) ; this . add ( jl_isbn ) ; this . add ( jl_name ) ; this . add ( jl_author ) ; this . add ( cb_category ) ; this . add ( jl_category ) ; this . setSize ( 500 , 600 ) ; this . setLayout ( null ) ; choosePic . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { FileDialog readFD = new FileDialog ( new Frame ( ) , "Choose a file" , FileDialog . LOAD ) ; readFD . setVisible ( true ) ; picDirectory = readFD . getDirectory ( ) ; picFileName = readFD . getFile ( ) ; picPath = picDirectory + picFileName ; ImageIcon bookImgIcon = CreateStretchImageIcon ( picPath , picturePanel . getWidth ( ) , picturePanel . getHeight ( ) ) ; DlgAddBooks . this . picLabel . setIcon ( bookImgIcon ) ; } } ) ; add . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { Validator test = new Validator ( ) ; String currentISBN = jtf_isbn . getText ( ) ; String currentBookName = jtf_name . getText ( ) ; String currentAuthor = jtf_author . getText ( ) ; String currentCategoryString = ( String ) cb_category . getSelectedItem ( ) ; Category currentCategory ; switch ( currentCategoryString ) { case "Children" : { currentCategory = Category . CHILDREN ; break ; } case "Cooking" : { currentCategory = Category . COOKING ; break ; } case "History" : { currentCategory = Category . HISTORY ; break ; } case "Travel" : { currentCategory = Category . TRAVEL ; break ; } default : currentCategory = null ; } if ( test . isBookIsbnValid ( currentISBN ) && test . isContentValid ( currentBookName ) && test . isContentValid ( currentAuthor ) ) { Book currentNewBook = new Book ( ) ; currentNewBook . setBookName ( currentBookName ) ; currentNewBook . setAuthor ( currentAuthor ) ; currentNewBook . setIsbn ( currentISBN ) ; currentNewBook . setLastRented ( null ) ; currentNewBook . setAddedDate ( new Date ( ) ) ; currentNewBook . setRented ( false ) ; currentNewBook . setOwnerId ( Library . LIBRARY_OWNER_ID ) ; currentNewBook . setCategory ( currentCategory ) ; library . addBook ( currentNewBook ) ; try { library . copyBookImage ( picDirectory , picFileName , currentISBN ) ; } catch ( Exception ex ) { System . out . println ( "No picture selected." ) ; } finally { JOptionPane . showMessageDialog ( DlgAddBooks . this , "New book added." , "OK" , JOptionPane . PLAIN_MESSAGE ) ; DlgAddBooks . this . dispose ( ) ; } } else { JOptionPane . showMessageDialog ( DlgAddBooks . this , "Invaild book information!" , "Error" , JOptionPane . ERROR_MESSAGE ) ; } } } ) ; close . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { DlgAddBooks . this . dispose ( ) ; } } ) ; }
tr	5	@ Override public void actionENTER ( ) { if ( Fenetre . _state == StateFen . Level && _currentBird . getTakeOff ( ) != 0 && ! _currentBird . isDestructing ( ) ) { if ( Fenetre . _list_birds . size ( ) != 0 && _currentBird . getEggLeft ( ) > 0 ) { Fenetre . _list_egg . add ( _currentBird . lay_egg ( ) ) ; } } }
tr	9	@ SuppressWarnings ( "unchecked" ) public List < JZSequenceFile > partition ( List < String > inputFiles , int numPartitions , Comparator < K > comparator , String jobTaskTrackerID ) { final Comparator < K > tempComparator = comparator ; List < JZSequenceFile > inFiles = new ArrayList < JZSequenceFile > ( ) ; Comparator < Object [ ] > com = new Comparator < Object [ ] > ( ) { @ Override public int compare ( Object [ ] o1 , Object [ ] o2 ) { return tempComparator . compare ( ( K ) o1 [ 0 ] , ( K ) o2 [ 0 ] ) ; } } ; PriorityQueue < Object [ ] > keyQueue = new PriorityQueue < Object [ ] > ( 1 , com ) ; for ( int i = 0 ; i < inputFiles . size ( ) ; i ++ ) { JZSequenceFile file = new JZSequenceFile ( JZFile . LocalFileSystem , inputFiles . get ( i ) , 0 , 0 ) ; inFiles . add ( file ) ; JZSequenceFile . Reader < K , List < V >> reader = new JZSequenceFile . Reader < > ( file ) ; if ( reader . nextKeyValue ( ) ) { Object [ ] entry = new Object [ ] { reader . getCurrentKey ( ) , reader } ; keyQueue . offer ( entry ) ; } } List < JZSequenceFile > outFiles = new ArrayList < JZSequenceFile > ( ) ; List < JZSequenceFile . Writer < K , List < V >>> writers = new ArrayList < JZSequenceFile . Writer < K , List < V >>> ( ) ; for ( int i = 0 ; i < numPartitions ; i ++ ) { String fileName = createPartitionFileName ( jobTaskTrackerID , i ) ; JZSequenceFile file = new JZSequenceFile ( JZFile . JZFileSystem , fileName , 0 , 0 ) ; outFiles . add ( file ) ; writers . add ( new JZSequenceFile . Writer < K , List < V >> ( file ) ) ; } List < V > list = new ArrayList < V > ( ) ; Object [ ] firstEntry = keyQueue . peek ( ) ; K preKey = ( K ) firstEntry [ 0 ] ; JZSequenceFile . Reader < K , List < V >> reader = ( JZSequenceFile . Reader < K , List < V >> ) firstEntry [ 1 ] ; while ( ! keyQueue . isEmpty ( ) ) { Object [ ] entry = keyQueue . poll ( ) ; K key = ( K ) entry [ 0 ] ; reader = ( JZSequenceFile . Reader < K , List < V >> ) entry [ 1 ] ; List < V > value = ( List < V > ) reader . getCurrentValue ( ) ; if ( preKey . equals ( key ) ) { list . addAll ( value ) ; } else { writers . get ( getPartition ( preKey , null , numPartitions ) ) . write ( preKey , list ) ; System . out . print ( "\n" + preKey + ":" ) ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { System . out . print ( " " + list . get ( i ) ) ; } preKey = key ; list = new ArrayList < V > ( value ) ; } if ( reader . nextKeyValue ( ) ) { K newKey = ( K ) reader . getCurrentKey ( ) ; entry [ 0 ] = newKey ; keyQueue . offer ( entry ) ; } else { reader . close ( ) ; } } if ( ! list . isEmpty ( ) ) { writers . get ( getPartition ( preKey , null , numPartitions ) ) . write ( preKey , list ) ; System . out . print ( preKey + ":" ) ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { System . out . print ( " " + list . get ( i ) ) ; } System . out . println ( "\n" ) ; } for ( int i = 0 ; i < numPartitions ; i ++ ) { writers . get ( i ) . close ( ) ; } return outFiles ; }
tr	4	public void setSpriteTemplate ( int x , int y , SpriteTemplate spriteTemplate ) { if ( x < 0 ) return ; if ( y < 0 ) return ; if ( x >= map . length ) return ; if ( y >= map [ 0 ] . length ) return ; sprites [ x ] [ y ] = spriteTemplate ; }
tr	5	public List < Dimension > getAllIndicatorDimensions ( String keyFamilyId ) { List < Dimension > dimensions = new ArrayList < Dimension > ( ) ; List < String > addedDimensions = new ArrayList < String > ( ) ; for ( LocalizedString indicatorName : getIndicatorNames ( keyFamilyId ) ) { List < DimensionWrapper > dimensionHierarchy = getDimensionHierarchy ( indicatorName . getDefaultStr ( ) , keyFamilyId ) ; if ( dimensionHierarchy != null ) { for ( DimensionWrapper dw : dimensionHierarchy ) { List < Dimension > hierarchyDimensions = dw . getAllDimensions ( ) ; for ( Dimension d : hierarchyDimensions ) { if ( ! addedDimensions . contains ( d . getConceptRef ( ) ) ) { dimensions . add ( d ) ; addedDimensions . add ( d . getConceptRef ( ) ) ; } } } } } return dimensions ; }
tr	2	public void add_bits ( int bitstring , int length ) { int bitmask = 1 << ( length - 1 ) ; do if ( ( ( crc & 8000 ) == 0 ) ^ ( ( bitstring & bitmask ) == 0 ) ) { crc <<= 1 ; crc ^= polynomial ; } else crc <<= 1 ; while ( ( bitmask >>>= 1 ) != 0 ) ; }
tr	0	public String getErrorMeg ( ) { return errorMsg ; }
tr	5	@ Override public void gameChanged ( final GameControllerEvent event ) { switch ( event . currentState ) { case GAME_STATE_RUNNING : for ( final Cell cell : event . changes ) { final int x = cell . x - 1 ; final int y = cell . y - 1 ; elements [ y ] [ x ] . setIcon ( event . map . get ( cell ) . getGraphics ( ) ) ; } break ; default : if ( event . currentState != state ) { System . out . println ( event . currentScore ) ; } } if ( state == null || state != event . currentState ) { state = event . currentState ; } }
tr	1	Node ( int deg ) { if ( deg < 1 ) { throw new IllegalArgumentException ( "Degree must be greater than or equal to 1." ) ; } this . deg = deg ; this . keys = new ArrayList < E > ( deg * 2 - 1 ) ; this . children = new ArrayList < AbsNode < E >> ( deg * 2 ) ; }
tr	2	public void add ( Address address ) { if ( addressBook != null ) { addressBook . add ( address ) ; } else if ( ! localAddresses . contains ( address ) ) { localAddresses . add ( address ) ; } }
tr	5	@ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; TestClass testClass = ( TestClass ) o ; if ( x != testClass . x ) return false ; if ( y != testClass . y ) return false ; return true ; }
tr	3	void read ( ByteBuffer bf , long offset ) throws IOException { int size = 0 ; int l = 0 ; while ( bf . hasRemaining ( ) ) { l = this . fc . read ( bf , offset + size ) ; if ( l < 0 ) { if ( offset < this . currentPos ) { continue ; } else { break ; } } size += l ; } }
tr	2	public void showError ( Throwable t , String resource ) { String text ; try { text = resources . getString ( resource + ".text" ) ; } catch ( MissingResourceException e ) { text = resources . getString ( "error.text" ) ; } String title ; try { title = resources . getString ( resource + ".title" ) ; } catch ( MissingResourceException e ) { title = resources . getString ( "error.title" ) ; } String reason = resources . getString ( "error.reason" ) ; String message = text + "\n" + MessageFormat . format ( reason , new Object [ ] { t } ) ; JOptionPane . showMessageDialog ( this , message , title , JOptionPane . ERROR_MESSAGE ) ; }
tr	1	@ Override public E read ( Input input ) { switch ( enumIntType ) { case byte : return constants [ input . readByte ( ) ] ; default : return constants [ input . readShort ( ) ] ; } }
tr	2	@ Override public void mousePressed ( MouseEvent e ) { if ( direction == 0 ) return ; resizing = true ; Component source = e . getComponent ( ) ; pressed = e . getPoint ( ) ; SwingUtilities . convertPointToScreen ( pressed , source ) ; bounds = source . getBounds ( ) ; if ( source instanceof JComponent ) { JComponent jc = ( JComponent ) source ; autoscrolls = jc . getAutoscrolls ( ) ; jc . setAutoscrolls ( false ) ; } }
tr	0	public String getUserAgent ( ) { return this . userAgent ; }
tr	9	@ Override public boolean equals ( Object obj ) { boolean result = false ; if ( this == obj ) { result = true ; } else if ( obj != null && obj instanceof Contributor ) { Contributor other = ( Contributor ) obj ; if ( ( this . domain == null && this . domain == other . domain ) || ( this . domain != null && this . domain . equals ( other . domain ) ) ) { if ( ( this . name == null && this . name == other . name ) || ( this . name != null && this . name . equals ( other . name ) ) ) { result = true ; } } } return result ; }
tr	8	private void spider ( String starting_url , int spider_depth ) throws Exception { System . out . println ( "** spider(" + starting_url + "  " + spider_depth + ")" ) ; WebSpider ws = new WebSpider ( starting_url , spider_depth ) ; Map < String , Set < String >> for_shared_properties = new HashMap < String , Set < String >> ( ) ; for ( List < String > ls : ws . url_content_lists ) { String url = ls . get ( 0 ) ; String text = ls . get ( 1 ) ; System . out . println ( "\n\n\n----URL:\n" + url + "\n    content:\n" + text ) ; if ( text . length ( ) > 120 ) { Map < String , List < String >> results = new OpenCalaisClient ( ) . getPropertyNamesAndValues ( text ) ; out . println ( "<" + url + "> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <http://knowledgebooks.com/rdf/webpage> ." ) ; out . println ( "<" + url + "> <http://knowledgebooks.com/rdf/contents> \"" + text . replaceAll ( "\"" , "'" ) + "\" ." ) ; if ( results . get ( "Person" ) != null ) for ( String person : results . get ( "Person" ) ) { out . println ( "<" + url + "> <http://knowledgebooks.com/rdf/containsPerson> \"" + person . replaceAll ( "\"" , "'" ) + "\" ." ) ; } for ( String key : results . keySet ( ) ) { System . out . println ( "  " + key + ": " + results . get ( key ) ) ; for ( Object val : results . get ( key ) ) { String property = "<http://knowledgebooks.com/rdf/" + key + ">" ; if ( ( "" + val ) . length ( ) > 0 ) { out . println ( "<" + url + "> <http://knowledgebooks.com/rdf/" + key + "> \"" + val + "\" ." ) ; HashSet < String > hs = ( HashSet < String > ) for_shared_properties . get ( property ) ; if ( hs == null ) hs = new HashSet < String > ( ) ; hs . add ( "\"" + val + "\"" ) ; for_shared_properties . put ( "<http://knowledgebooks.com/rdf/" + key + ">" , hs ) ; } } } } interpage_shared_properties . put ( url , for_shared_properties ) ; } process_interpage_shared_properties ( ) ; }
tr	3	private String getReadMeContents ( ) { InputStream is = null ; is = Loader . class . getResourceAsStream ( "/info/usmans/QuranProject/resources/infos/README.md" ) ; if ( is == null ) { JOptionPane . showMessageDialog ( this , "Unable to acquire InputStream for reading README file" , "null InputStream" , JOptionPane . ERROR_MESSAGE ) ; return "" ; } java . util . Scanner s = new java . util . Scanner ( is ) ; s . useDelimiter ( "\\A" ) ; String data = s . hasNext ( ) ? s . next ( ) : "" ; try { s . close ( ) ; is . close ( ) ; } catch ( IOException e ) { JOptionPane . showMessageDialog ( this , "Unable to close InputStream for README file" , "Error InputStream close" , JOptionPane . ERROR_MESSAGE ) ; } return data ; }
tr	8	@ Override public void actionPerformed ( ActionEvent actionEvent ) { Object source = actionEvent . getSource ( ) ; if ( source == jButtonExtendPanel ) { isExtended = ! isExtended ; displayExtendedPanel ( ) ; } else if ( source == jComponentBegin ) { if ( ( ( JButton ) jComponentBegin ) . getIcon ( ) == ConfigIcon . COLUMN_NOT_ALL_SELECTED ) { for ( int i_idFilter = 0 ; i_idFilter < tabModel . getListFilter ( ) . length ; i_idFilter ++ ) { tabModel . getColumnHider ( ) . show ( tabModel . getListFilter ( ) [ i_idFilter ] . getS_name ( ) ) ; } for ( Filter filterTmp : tabModel . getListFilter ( ) ) { filterTmp . setColumnVisible ( true ) ; } updateButtonColumn ( ) ; updateCheckBoxColumn ( ) ; } } else { for ( int i_idFilter = 0 ; i_idFilter < tabModel . getListFilter ( ) . length ; i_idFilter ++ ) { if ( source == listComponent [ i_idFilter ] ) { tabModel . getListFilter ( ) [ i_idFilter ] . setColumnVisible ( ! tabModel . getListFilter ( ) [ i_idFilter ] . isColumnVisible ( ) ) ; updateButtonColumn ( ) ; if ( tabModel . getListFilter ( ) [ i_idFilter ] . isColumnVisible ( ) ) { tabModel . getColumnHider ( ) . show ( tabModel . getListFilter ( ) [ i_idFilter ] . getS_name ( ) ) ; } else { tabModel . getColumnHider ( ) . hide ( tabModel . getListFilter ( ) [ i_idFilter ] . getS_name ( ) ) ; } break ; } } } }
tr	9	public SourceBlock [ ] partition ( ) { Partition KZ = new Partition ( Kt , Z ) ; int KL = KZ . get ( 1 ) ; int KS = KZ . get ( 2 ) ; int ZL = KZ . get ( 3 ) ; Partition TN = new Partition ( T / ALIGN_PARAM , N ) ; int TL = TN . get ( 1 ) ; int TS = TN . get ( 2 ) ; int NL = TN . get ( 3 ) ; SourceBlock [ ] object = new SourceBlock [ Z ] ; int i ; int index_master = 0 ; for ( i = 0 ; i < ZL ; i ++ ) { byte [ ] symbols = new byte [ KL * T ] ; int index_symbols = 0 ; int aux_master = index_master ; for ( int k = 0 ; k < KL ; k ++ ) { int j = 0 ; int index_data = aux_master ; for ( ; j < NL ; j ++ , index_data += KL * TL * ALIGN_PARAM , index_symbols += TL * ALIGN_PARAM ) { System . arraycopy ( data , index_data , symbols , index_symbols , TL * ALIGN_PARAM ) ; } for ( ; j < N ; j ++ , index_data += KL * TS * ALIGN_PARAM , index_symbols += TS * ALIGN_PARAM ) { System . arraycopy ( data , index_data , symbols , index_symbols , TS * ALIGN_PARAM ) ; } if ( NL > 0 ) { aux_master += TL * ALIGN_PARAM ; } else { aux_master += TS * ALIGN_PARAM ; } } object [ i ] = new SourceBlock ( i , symbols , T , KL ) ; index_master += ( KL * T ) ; } for ( ; i < Z ; i ++ ) { byte [ ] symbols = new byte [ KS * T ] ; int index_symbols = 0 ; int aux_master = index_master ; for ( int k = 0 ; k < KS ; k ++ ) { int j = 0 ; int index_data = aux_master ; for ( ; j < NL ; j ++ , index_data += KS * TL * ALIGN_PARAM , index_symbols += TL * ALIGN_PARAM ) { System . arraycopy ( data , index_data , symbols , index_symbols , TL * ALIGN_PARAM ) ; } for ( ; j < N ; j ++ , index_data += KS * TS * ALIGN_PARAM , index_symbols += TS * ALIGN_PARAM ) { System . arraycopy ( data , index_data , symbols , index_symbols , TS * ALIGN_PARAM ) ; } if ( NL > 0 ) { aux_master += TL * ALIGN_PARAM ; } else { aux_master += TS * ALIGN_PARAM ; } } object [ i ] = new SourceBlock ( i , symbols , T , KS ) ; index_master += ( KS * T ) ; } return object ; }
tr	5	private boolean promptForNew ( ) { PoseurGUI gui = Poseur . getPoseur ( ) . getGUI ( ) ; AnimatedSpriteViewer viewer = gui . getAnimametedViewerPanel ( ) ; String nameOfSprite ; String nameOfState ; String path = "./data/sprite_types/" ; try { String spriteTypeName = viewer . getJlist ( ) . getSelectedValue ( ) . toString ( ) ; String spriteState = viewer . getCombo ( ) . getSelectedItem ( ) . toString ( ) ; HashMap < String , SpriteType > spriteTypes = viewer . getSpriteTypes ( ) ; SpriteType spriteType = spriteTypes . get ( spriteTypeName ) ; String xsdFile = SPRITES_DATA_PATH + SPRITE_TYPE_SCHEMA_FILE ; int size = 0 ; Iterator < String > states = spriteType . getAnimationStates ( ) ; while ( states . hasNext ( ) ) { spriteState = states . next ( ) ; PoseList poseList = spriteType . getPoseList ( spriteState ) ; Iterator < Pose > poseIterator = poseList . getPoseIterator ( ) ; for ( int i = 0 ; i < poseList . getNumOfPoses ( ) ; i ++ ) { Pose p1 = poseIterator . next ( ) ; int id = p1 . getImageID ( ) ; if ( id == 1000 ) { size = 0 ; break ; } else { } if ( id > size ) { size = id ; } } } spriteState = viewer . getCombo ( ) . getSelectedItem ( ) . toString ( ) ; size ++ ; path = path + spriteTypeName + "/" + spriteTypeName + "_" + ( spriteState + "_" + size ) . toUpperCase ( ) + ".pose" ; gui . setID ( size ) ; size = 0 ; SpriteType sprite = viewer . getSpriteTypes ( ) . get ( spriteTypeName ) ; } catch ( NullPointerException e ) { } currentFile = new File ( path ) ; poseIO . savePose ( currentFile ) ; saved = true ; String appName = gui . getAppName ( ) ; gui . setTitle ( appName + APP_NAME_FILE_NAME_SEPARATOR + currentFile ) ; JOptionPane . showConfirmDialog ( viewer , "New Pose Editor Canvas Created" ) ; return true ; }
tr	5	@ Override public void onCommand ( POP3Session session , String argument1 , String argument2 ) throws POP3Exception { if ( session . getState ( ) != POP3State . AUTHORIZATION_USERSET || argument1 == null || argument2 != null ) { throw new POP3Exception ( "-ERR syntax error" ) ; } String loginUserName = session . getLoginUserName ( ) ; String password = argument1 ; UserListManager userListManager = UserListManager . getInstance ( ) ; if ( ! userListManager . checkUserLogin ( loginUserName , password ) ) { session . setState ( POP3State . AUTHORIZATION_READY ) ; throw new POP3Exception ( "-ERR authentication failed" ) ; } if ( ! userListManager . isUserLocked ( loginUserName , LockType . POP3 ) ) { userListManager . lockUser ( loginUserName , LockType . POP3 ) ; session . setUser ( userListManager . getUser ( loginUserName ) ) ; session . setState ( POP3State . TRANSACTION ) ; session . sendResponse ( "+OK welcome " + loginUserName ) ; session . getLogger ( ) . debug ( "pop3:" + loginUserName + " login successfully" ) ; } else { session . setState ( POP3State . AUTHORIZATION_READY ) ; throw new POP3Exception ( "-ERR user has logined" ) ; } }
tr	8	private String toString ( String separator , boolean braces ) { if ( size == 0 ) { return braces ? "{}" : "" ; } StringBuilder buffer = new StringBuilder ( 32 ) ; if ( braces ) { buffer . append ( { ) ; } K [ ] keyTable = this . keyTable ; V [ ] valueTable = this . valueTable ; int i = keyTable . length ; while ( i -- > 0 ) { K key = keyTable [ i ] ; if ( key == null ) { continue ; } buffer . append ( key ) ; buffer . append ( = ) ; buffer . append ( valueTable [ i ] ) ; break ; } while ( i -- > 0 ) { K key = keyTable [ i ] ; if ( key == null ) { continue ; } buffer . append ( separator ) ; buffer . append ( key ) ; buffer . append ( = ) ; buffer . append ( valueTable [ i ] ) ; } if ( braces ) { buffer . append ( } ) ; } return buffer . toString ( ) ; }
tr	6	public String nextTo ( char delimiter ) throws JSONException { StringBuffer sb = new StringBuffer ( ) ; for ( ; ; ) { char c = this . next ( ) ; if ( c == delimiter || c == 0 || c == '' || c == '' ) { if ( c != 0 ) { this . back ( ) ; } return sb . toString ( ) . trim ( ) ; } sb . append ( c ) ; } }
tr	3	public static void main ( String [ ] args ) { double mass , height , BMI ; mass = double . parseDouble ( args [ 0 ] ) ; height = double . parseDouble ( args [ 1 ] ) ; BMI = mass / Math . pow ( height , 2 ) ; if ( BMI < 18.5 ) System . out . println ( "Underweight" ) ; else if ( BMI < 25 ) System . out . println ( "Normal weight" ) ; else if ( BMI < 30 ) System . out . println ( "Overweight" ) ; else System . out . println ( "Obses" ) ; }
tr	3	public String getHealthText ( ) { double health = getHealth ( ) ; if ( health > 0.75 ) { return "excellently" ; } else if ( health > 0.50 ) { return "well" ; } else if ( health > 0.25 ) { return "decently" ; } else { return "poorly" ; } }
tr	9	public static final String unescape ( String str ) { StringBuffer retval = new StringBuffer ( ) ; char ch ; for ( int i = 0 ; i < str . length ( ) ; ) { ch = str . charAt ( i ++ ) ; if ( ch != \ ) retval . append ( ch ) ; else { ch = str . charAt ( i ++ ) ; switch ( ch ) { case 0 : continue ; case b : retval . append ( "\b" ) ; continue ; case t : retval . append ( "\t" ) ; continue ; case n : retval . append ( "\n" ) ; continue ; case f : retval . append ( "\f" ) ; continue ; case r : retval . append ( "\r" ) ; continue ; case " : retval . append ( "\"" ) ; continue ; case ' : retval . append ( "'" ) ; continue ; case \ : retval . append ( "\\" ) ; continue ; default : retval . append ( "\\" ) ; retval . append ( ch ) ; continue ; } } } return retval . toString ( ) ; }
tr	9	@ SuppressWarnings ( "unused" ) private void displayTestGraph ( ) { Graph g = new Graph ( this ) ; for ( double x = this . m_xMin ; x < this . m_xMax ; x += this . m_xInc ) { for ( double y = this . m_yMin ; y < this . m_yMax ; y += this . m_yInc ) { double z = x * x - y * y ; if ( this . m_zMin <= z && z <= this . m_zMax ) { double nextX = x + this . m_xInc ; double zNextXCurrY = nextX * nextX - y * y ; if ( this . m_zMin <= zNextXCurrY && zNextXCurrY <= this . m_zMax ) { double nextY = y + this . m_yInc ; double zNextXNextY = nextX * nextX - nextY * nextY ; if ( this . m_zMin <= zNextXNextY && zNextXNextY <= this . m_zMax ) { double zCurrXNextY = x * x - nextY * nextY ; if ( this . m_zMin <= zCurrXNextY && zCurrXNextY <= this . m_zMax ) { Point3D p1 = convertCartesianToPixel ( new CartesianPoint ( x , y , z ) ) . toPoint3D ( ) ; Point3D p2 = convertCartesianToPixel ( new CartesianPoint ( nextX , y , zNextXCurrY ) ) . toPoint3D ( ) ; Point3D p3 = convertCartesianToPixel ( new CartesianPoint ( nextX , nextY , zNextXNextY ) ) . toPoint3D ( ) ; Point3D p4 = convertCartesianToPixel ( new CartesianPoint ( x , nextY , zCurrXNextY ) ) . toPoint3D ( ) ; g . plotQuadrilateral ( p1 . getX ( ) , p1 . getY ( ) , p1 . getZ ( ) , p2 . getX ( ) , p2 . getY ( ) , p2 . getZ ( ) , p3 . getX ( ) , p3 . getY ( ) , p3 . getZ ( ) , p4 . getX ( ) , p4 . getY ( ) , p4 . getZ ( ) , Materials . YELLOW . m_material ) ; } } } } } } drawGraph ( g ) ; }
tr	5	@ Override public void run ( ) { String author = item . getAuthor ( ) ; String title = item . getTitle ( ) ; String dir = "./cache" ; String localCover = dir + "/cover/" + title + "-" + author + ".jpg" ; String localSong = dir + "/song/" + title + "-" + author + ".mp3" ; try { if ( item . getCover ( ) != null && item . getCover ( ) . startsWith ( "http" ) ) { HttpUtil . downloadByByte ( localCover , item . getCover ( ) ) ; item . setCover ( localCover ) ; } onCoverComplete ( item ) ; if ( item . getCover ( ) != null && item . getPath ( ) . startsWith ( "http" ) ) { HttpUtil . downloadByByte ( localSong , item . getPath ( ) ) ; item . setPath ( localSong ) ; item . setLocal ( true ) ; } onSongComplete ( item ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }
tr	5	public void loadLinearGradient ( String infile ) throws IOException { BufferedReader br = new BufferedReader ( new FileReader ( infile ) ) ; String line ; String [ ] tmp ; while ( ( line = br . readLine ( ) ) != null ) { if ( ! line . startsWith ( "#" ) && line . startsWith ( "start_gradient" ) ) { tmp = line . split ( "=" ) [ 1 ] . split ( " " ) ; this . lcTimes . add ( 0 , float . parseFloat ( tmp [ 0 ] ) ) ; this . percB . add ( 0 , float . parseFloat ( tmp [ 1 ] ) ) ; } if ( ! line . startsWith ( "#" ) && line . startsWith ( "end_gradient" ) ) { tmp = line . split ( "=" ) [ 1 ] . split ( " " ) ; this . lcTimes . add ( float . parseFloat ( tmp [ 0 ] ) ) ; this . percB . add ( float . parseFloat ( tmp [ 1 ] ) ) ; } } br . close ( ) ; }
tr	3	@ Override public void visit ( YCompositeTask t ) { visited . add ( t ) ; if ( phase == 1 ) { FSPTask c = new FSPTask ( t . name ( ) ) ; c . container ( _current_net ) ; _current_net . components ( ) . put ( c . name ( ) , c ) ; _components . put ( t , c ) ; assert t . name ( ) == c . name ( ) ; process_gates ( t , c ) ; } else if ( phase == 2 ) { ( ( FSPAbstractTask ) _components . get ( t ) ) . decomposesTo ( _nets . get ( t . decomposesTo ( ) ) ) ; process_outgoing_links ( t ) ; } else if ( phase == 3 ) { } else { } }
tr	9	public String toString ( ) { String s = "" ; Node n = this ; while ( n != null ) { s += "[Node type=" ; s += nodeTypeString [ n . type ] ; s += " element=" ; if ( n . element != null ) s += n . element ; else s += "null" ; if ( n . type == TextNode || n . type == CommentTag || n . type == ProcInsTag ) { s += " text=" ; if ( n . textarray != null && n . start <= n . end ) { s += "\"" ; s += Lexer . getString ( n . textarray , n . start , n . end - n . start ) ; s += "\"" ; } else { s += "null" ; } } s += " content=" ; if ( n . content != null ) s += n . content . toString ( ) ; else s += "null" ; s += "]" ; if ( n . next != null ) s += " " ; n = n . next ; } return s ; }
tr	6	public double [ ] [ ] forwardDCTExtreme ( float input [ ] [ ] ) { double output [ ] [ ] = new double [ N ] [ N ] ; double tmp0 , tmp1 , tmp2 , tmp3 , tmp4 , tmp5 , tmp6 , tmp7 ; double tmp10 , tmp11 , tmp12 , tmp13 ; double z1 , z2 , z3 , z4 , z5 , z11 , z13 ; int i ; int j ; int v , u , x , y ; for ( v = 0 ; v < 8 ; v ++ ) { for ( u = 0 ; u < 8 ; u ++ ) { for ( x = 0 ; x < 8 ; x ++ ) { for ( y = 0 ; y < 8 ; y ++ ) { output [ v ] [ u ] += ( ( double ) input [ x ] [ y ] ) * Math . cos ( ( ( double ) ( 2 * x + 1 ) * ( double ) u * Math . PI ) / ( double ) 16 ) * Math . cos ( ( ( double ) ( 2 * y + 1 ) * ( double ) v * Math . PI ) / ( double ) 16 ) ; } } output [ v ] [ u ] *= ( double ) ( 0.25 ) * ( ( u == 0 ) ? ( ( double ) 1.0 / Math . sqrt ( 2 ) ) : ( double ) 1.0 ) * ( ( v == 0 ) ? ( ( double ) 1.0 / Math . sqrt ( 2 ) ) : ( double ) 1.0 ) ; } } return output ; }
tr	1	public < T > T getInstance ( class < T > c , String [ ] args ) throws Exception { AnnotatedConstructor ctor = ctors . get ( c ) ; AnnotatedCLI . ParsedCLI cli = parse ( args ) ; T obj ; if ( ctor != null ) { obj = ( T ) ctor . newInstance ( cli ) ; } else { obj = ( T ) c . newInstance ( ) ; } cli . inject ( obj ) ; return obj ; }
tr	7	public static String getAST ( InputStream stream ) { Scanner scan = new Scanner ( stream ) ; String ast = null ; while ( scan . hasNextLine ( ) ) { String line = scan . nextLine ( ) ; if ( line . equals ( "======= AST Display =========================" ) ) { line = scan . nextLine ( ) ; while ( scan . hasNext ( ) && ! line . equals ( "=============================================" ) ) { ast += line + "\n" ; line = scan . nextLine ( ) ; } } if ( line . startsWith ( "*** " ) ) System . out . println ( line ) ; if ( line . startsWith ( "ERROR" ) ) { System . out . println ( line ) ; while ( scan . hasNext ( ) ) System . out . println ( scan . next ( ) ) ; } } scan . close ( ) ; return ast ; }
tr	2	@ Override public int hashCode ( ) { int result = key != null ? key . hashCode ( ) : 0 ; result = 31 * result + ( value != null ? value . hashCode ( ) : 0 ) ; return result ; }
tr	6	public synchronized void doRanking ( ) { calculate_tf_idf_q ( ) ; Query q ; for ( String term : queryTerms . keySet ( ) ) { term = term . trim ( ) ; q = queryTerms . get ( term ) ; q . setPostings ( getPostingsFor ( term ) ) ; if ( q . getPostings ( ) == null ) { System . out . println ( "sry. no postings found" ) ; continue ; } for ( Posting p : q . getPostings ( ) . getPostings ( ) ) { float value = ( float ) ( q . getTf_idf ( ) * calculate_tf_idf_d ( p , q . getPostings ( ) . getOverallFrequency ( ) ) ) ; Score s = new Score ( ) ; s . setScore ( value ) ; s . setId ( p . getDocID ( ) ) ; if ( ! scores . containsKey ( p . getDocID ( ) ) ) { scores . put ( p . getDocID ( ) , s ) ; } else { Score sc = scores . get ( p . getDocID ( ) ) ; float score = sc . getScore ( ) ; score += value ; sc . setScore ( score ) ; scores . put ( p . getDocID ( ) , sc ) ; } } } float newScore , lengthV ; Score s ; for ( String id : scores . keySet ( ) ) { s = scores . get ( id ) ; try { newScore = s . getScore ( ) / length . get ( id ) . floatValue ( ) ; s . setScore ( newScore ) ; scores . put ( id , s ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } }
tr	6	private StringWrapper step5 ( StringWrapper w ) { Matcher m5_1 = p5_1 . matcher ( w . word ) ; if ( m5_1 . find ( ) ) { if ( m_gt_1 . matcher ( m5_1 . group ( 1 ) ) . find ( ) || ( m_eq_1 . matcher ( m5_1 . group ( 1 ) ) . find ( ) && pO . matcher ( m5_1 . group ( 1 ) ) . find ( ) ) ) { w . word = m5_1 . group ( 1 ) ; } } Matcher m5_2 = p5_2 . matcher ( w . word ) ; if ( m5_2 . find ( ) ) { if ( m_gt_1 . matcher ( w . word ) . find ( ) ) { w . word = w . word . substring ( 0 , w . word . length ( ) - 1 ) ; } } return w ; }
tr	6	public Settings ( JPanel content ) { JPanel theContent = new JPanel ( new GridLayout ( 12 , 1 , 0 , 5 ) ) ; auxButton . setFocusPainted ( false ) ; radButton . setFocusPainted ( false ) ; cdButton . setFocusPainted ( false ) ; climateLabel = new JLabel ( "Climate" ) ; climateLabel . setFont ( new Font ( "Sans Serif" , Font . BOLD , 30 ) ) ; climateControl . setMinorTickSpacing ( 1 ) ; Hashtable labelTable = new Hashtable ( ) ; labelTable . put ( new Integer ( 0 ) , new JLabel ( "Cold" ) ) ; labelTable . put ( new Integer ( CLIMATE_MAX ) , new JLabel ( "Hot" ) ) ; climateControl . setLabelTable ( labelTable ) ; climateControl . setPaintLabels ( true ) ; ventLabel = new JLabel ( "Ventilation Fan" ) ; ventLabel . setFont ( new Font ( "Sans Serif" , Font . BOLD , 30 ) ) ; ventButton . setText ( "Off" ) ; ventButton . setBackground ( Color . decode ( "#FF3333" ) ) ; ventButton . addActionListener ( new ActionListener ( ) { boolean active = false ; public void actionPerformed ( ActionEvent e ) { active = active == true ? false : true ; if ( active == true ) { ventButton . setText ( "On" ) ; ventButton . setBackground ( Color . decode ( "#92CD00" ) ) ; } else { ventButton . setText ( "Off" ) ; ventButton . setBackground ( Color . decode ( "#FF3333" ) ) ; } } } ) ; soundLabel = new JLabel ( "Sound" ) ; soundLabel . setFont ( new Font ( "Sans Serif" , Font . BOLD , 30 ) ) ; radioLabel = new JLabel ( "Volume" ) ; radioLabel . setFont ( new Font ( "Sans Serif" , Font . BOLD , 16 ) ) ; frequency . setText ( "107.10" ) ; musicCards . add ( radioCard , "Radio controller" ) ; musicCards . add ( cdCard , "CD controller" ) ; musicCards . add ( auxCard , "AUX controller" ) ; Hashtable volLabelTable = new Hashtable ( ) ; volLabelTable . put ( new Integer ( 0 ) , new JLabel ( "0" ) ) ; volLabelTable . put ( new Integer ( 10 ) , new JLabel ( "1" ) ) ; volLabelTable . put ( new Integer ( 20 ) , new JLabel ( "2" ) ) ; volLabelTable . put ( new Integer ( 30 ) , new JLabel ( "3" ) ) ; volLabelTable . put ( new Integer ( 40 ) , new JLabel ( "4" ) ) ; volLabelTable . put ( new Integer ( 50 ) , new JLabel ( "5" ) ) ; volLabelTable . put ( new Integer ( 60 ) , new JLabel ( "6" ) ) ; volLabelTable . put ( new Integer ( 70 ) , new JLabel ( "7" ) ) ; volLabelTable . put ( new Integer ( 80 ) , new JLabel ( "8" ) ) ; volLabelTable . put ( new Integer ( 90 ) , new JLabel ( "9" ) ) ; volLabelTable . put ( new Integer ( 100 ) , new JLabel ( "10" ) ) ; volLabelTable . put ( new Integer ( 110 ) , new JLabel ( "11" ) ) ; radVolControl . setLabelTable ( volLabelTable ) ; radVolControl . setPaintLabels ( true ) ; freqButton . setText ( "AM" ) ; freqButton . setFocusPainted ( false ) ; freqButton . setBackground ( Color . decode ( "#393939" ) ) ; freqButton . setForeground ( Color . decode ( "#FFFFFF" ) ) ; freqButton . addActionListener ( new ActionListener ( ) { boolean active = false ; public void actionPerformed ( ActionEvent e ) { active = active == true ? false : true ; if ( active == true ) { freqButton . setText ( "FM" ) ; } else { freqButton . setText ( "AM" ) ; } } } ) ; radButton . setBackground ( Color . decode ( "#92CD00" ) ) ; auxButton . setBackground ( Color . decode ( "#FF3333" ) ) ; cdButton . setBackground ( Color . decode ( "#FF3333" ) ) ; freqLabel = new JLabel ( "Frequency:" ) ; freqLabel . setFont ( new Font ( "Sans Serif" , Font . BOLD , 16 ) ) ; JPanel musicButtons = new JPanel ( new GridLayout ( 1 , 3 ) ) ; radButton . setText ( "RADIO" ) ; radButton . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { radButton . setBackground ( Color . decode ( "#92CD00" ) ) ; auxButton . setBackground ( Color . decode ( "#FF3333" ) ) ; cdButton . setBackground ( Color . decode ( "#FF3333" ) ) ; CardLayout cl = ( CardLayout ) ( musicCards . getLayout ( ) ) ; cl . show ( musicCards , "Radio controller" ) ; } } ) ; musicButtons . add ( radButton ) ; auxButton . setText ( "AUX" ) ; auxButton . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { auxButton . setBackground ( Color . decode ( "#92CD00" ) ) ; radButton . setBackground ( Color . decode ( "#FF3333" ) ) ; cdButton . setBackground ( Color . decode ( "#FF3333" ) ) ; CardLayout cl = ( CardLayout ) ( musicCards . getLayout ( ) ) ; cl . show ( musicCards , "AUX controller" ) ; } } ) ; musicButtons . add ( auxButton ) ; cdButton . setText ( "CD" ) ; cdButton . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { cdButton . setBackground ( Color . decode ( "#92CD00" ) ) ; auxButton . setBackground ( Color . decode ( "#FF3333" ) ) ; radButton . setBackground ( Color . decode ( "#FF3333" ) ) ; CardLayout cl = ( CardLayout ) ( musicCards . getLayout ( ) ) ; cl . show ( musicCards , "CD controller" ) ; } } ) ; musicButtons . add ( cdButton ) ; radioCard . add ( freqLabel ) ; radioCard . add ( frequency ) ; radioCard . add ( freqButton ) ; auxCard . add ( new JLabel ( "AUX Connected..." ) ) ; JPanel cdButtons = new JPanel ( new GridLayout ( 1 , 6 ) ) ; JButton playBtn = new JButton ( "Play" ) ; playBtn . setFocusPainted ( false ) ; playBtn . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { cdStatusLabel . setText ( "Playing " + currentSongStr + "..." ) ; } } ) ; cdButtons . add ( playBtn ) ; JButton pauseBtn = new JButton ( "Pause" ) ; pauseBtn . setFocusPainted ( false ) ; pauseBtn . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { cdStatusLabel . setText ( currentSongStr + " Paused" ) ; } } ) ; cdButtons . add ( pauseBtn ) ; JButton stopBtn = new JButton ( "Stop" ) ; stopBtn . setFocusPainted ( false ) ; stopBtn . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { cdStatusLabel . setText ( currentSongStr + " Stopped" ) ; } } ) ; cdButtons . add ( stopBtn ) ; JButton prevBtn = new JButton ( "PREV" ) ; prevBtn . setFocusPainted ( false ) ; prevBtn . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { if ( currentSongStr . equals ( "Funky Town" ) ) { currentSongStr = "Bohemian Rhapsody" ; } else { currentSongStr = "Funky Town" ; } cdStatusLabel . setText ( "Playing " + currentSongStr + "..." ) ; } } ) ; cdButtons . add ( prevBtn ) ; JButton nextBtn = new JButton ( "next" ) ; nextBtn . setFocusPainted ( false ) ; nextBtn . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { if ( currentSongStr . equals ( "Funky Town" ) ) { currentSongStr = "Bohemian Rhapsody" ; } else { currentSongStr = "Funky Town" ; } cdStatusLabel . setText ( "Playing " + currentSongStr + "..." ) ; } } ) ; cdButtons . add ( nextBtn ) ; JButton eject = new JButton ( "Eject" ) ; eject . setFocusPainted ( false ) ; cdButtons . add ( eject ) ; cdCard . add ( cdButtons ) ; cdCard . add ( cdStatusLabel ) ; settings . setFont ( new Font ( "Sans Serif" , Font . BOLD , 30 ) ) ; theContent . add ( settings ) ; theContent . add ( climateLabel ) ; theContent . add ( climateControl ) ; theContent . add ( ventLabel ) ; theContent . add ( ventButton ) ; theContent . add ( soundLabel ) ; theContent . add ( radioLabel ) ; theContent . add ( radVolControl ) ; theContent . add ( musicButtons ) ; theContent . add ( musicCards ) ; add ( theContent ) ; }
tr	2	public static JSONObject toJSONObject ( String string ) throws JSONException { JSONObject jo = new JSONObject ( ) ; HTTPTokener x = new HTTPTokener ( string ) ; String token ; token = x . nextToken ( ) ; if ( token . toUpperCase ( ) . startsWith ( "HTTP" ) ) { jo . put ( "HTTP-Version" , token ) ; jo . put ( "Status-Code" , x . nextToken ( ) ) ; jo . put ( "Reason-Phrase" , x . nextTo (  ) ) ; x . next ( ) ; } else { jo . put ( "Method" , token ) ; jo . put ( "Request-URI" , x . nextToken ( ) ) ; jo . put ( "HTTP-Version" , x . nextToken ( ) ) ; } while ( x . more ( ) ) { String name = x . nextTo ( : ) ; x . next ( : ) ; jo . put ( name , x . nextTo (  ) ) ; x . next ( ) ; } return jo ; }
tr	4	private void updateEstimatedParameters ( ) { for ( int k = 0 ; k < K ; k ++ ) { for ( int t = 0 ; t < V ; t ++ ) { phi [ k ] [ t ] = ( nkt [ k ] [ t ] + beta ) / ( nktSum [ k ] + V * beta ) ; } } for ( int m = 0 ; m < M ; m ++ ) { for ( int k = 0 ; k < K ; k ++ ) { theta [ m ] [ k ] = ( nmk [ m ] [ k ] + alpha ) / ( nmkSum [ m ] + K * alpha ) ; } } }
tr	7	public static void sendData ( byte [ ] packet ) throws IOException { Socket socket = new Socket ( ) ; socket . connect ( new InetSocketAddress ( serverAddr , 1939 ) ) ; socket . getOutputStream ( ) . write ( packet ) ; byte [ ] data = new byte [ 1024 ] ; int size = socket . getInputStream ( ) . read ( data ) ; System . out . print ( "Received data: " ) ; data = Arrays . copyOf ( data , size ) ; @ SuppressWarnings ( "resource" ) HexOutputStream hexOut = new HexOutputStream ( System . out ) ; hexOut . write ( data ) ; hexOut . flush ( ) ; socket . close ( ) ; System . out . println ( ) ; switch ( data [ 0 ] ) { case 01 : System . out . println ( "PACKET: OK packet." ) ; break ; case 00 : System . out . println ( "PACKET: Fail packet." ) ; break ; case 02 : System . out . println ( "PACKET: Flavor list packet." ) ; parseFlavorsPacket ( data ) ; break ; case 03 : System . out . println ( "PACKET: Top combo list packet." ) ; parseTopComboList ( data ) ; break ; case 04 : System . out . println ( "PACKET: Combo info packet." ) ; parseComboInfoPacket ( data ) ; break ; case ( byte ) FE : System . out . println ( "PACKET: Error message packet." ) ; parseErrorMessagePacket ( data ) ; break ; case ( byte ) FF : System . out . println ( "PACKET: Client sent bad packet." ) ; break ; } }
tr	5	protected void reindexFacesAndVertices ( ) { for ( int i = 0 ; i < numPoints ; i ++ ) { pointBuffer [ i ] . index = - 1 ; } numFaces = 0 ; for ( Iterator it = faces . iterator ( ) ; it . hasNext ( ) ; ) { Face face = ( Face ) it . next ( ) ; if ( face . mark != Face . VISIBLE ) { it . remove ( ) ; } else { markFaceVertices ( face , 0 ) ; numFaces ++ ; } } numVertices = 0 ; for ( int i = 0 ; i < numPoints ; i ++ ) { Vertex vtx = pointBuffer [ i ] ; if ( vtx . index == 0 ) { vertexPointIndices [ numVertices ] = i ; vtx . index = numVertices ++ ; } } }
tr	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( FormVendedor . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( FormVendedor . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( FormVendedor . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( FormVendedor . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { new FormVendedor ( ) . setVisible ( true ) ; } } ) ; }
tr	3	public Ouvrage rechOuvrage ( String isbn ) { Ouvrage ouv = this . getOuvrage ( isbn ) ; if ( ouv == null ) { Message dialog = new Message ( "Ouvrage inconnu" ) ; } else { if ( this . getVue ( ) instanceof VueSaisieExemplaire ) { ouv . addObserver ( this . getVue ( ) ) ; this . getVue ( ) . setEtat ( Vue . inter1 ) ; ( ( VueSaisieExemplaire ) this . getVue ( ) ) . alimente ( ouv ) ; } if ( this . getVue ( ) instanceof VueConsultOuvrage ) { this . getVue ( ) . setEtat ( Vue . finale ) ; ( ( VueConsultOuvrage ) this . getVue ( ) ) . alimente ( ouv ) ; } } return ouv ; }
tr	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( WindowAdd . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( WindowAdd . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( WindowAdd . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( WindowAdd . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { WindowAdd dialog = new WindowAdd ( new javax . swing . JFrame ( ) , true ) ; dialog . addWindowListener ( new java . awt . event . WindowAdapter ( ) { @ Override public void windowClosing ( java . awt . event . WindowEvent e ) { System . exit ( 0 ) ; } } ) ; dialog . setVisible ( true ) ; } } ) ; }
tr	2	@ Override public void getRequirements ( GameManager gameManager , Game ata , MessageInfo msgInfo , List < Requirement > requirements ) { boolean req = ( ata . m_state == State . PLAY && ! ata . m_waiting . isEmpty ( ) ) || ata . m_state == State . CHOOSE ; requirements . add ( REQ ( req , BLANK_MESSAGE ) ) ; requirements . add ( REQ ( ! ata . m_warning , BLANK_MESSAGE ) ) ; }
tr	0	public void setC ( float C ) { this . C = C ; }
tr	9	public static boolean isValidMonthCode ( final int code ) { switch ( code ) { case JANUARY : case FEBRUARY : case MARCH : case APRIL : case MAY : case JUNE : case JULY : case AUGUST : case SEPTEMBER : case OCTOBER : case NOVEMBER : case DECEMBER : return true ; default : return false ; } }
tr	9	public IndexedModel toIndexedModel ( ) { IndexedModel result = new IndexedModel ( ) ; IndexedModel normalModel = new IndexedModel ( ) ; HashMap < OBJIndex , Integer > resultIndexMap = new HashMap < OBJIndex , Integer > ( ) ; HashMap < Integer , Integer > normalIndexMap = new HashMap < Integer , Integer > ( ) ; HashMap < Integer , Integer > indexMap = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < indices . size ( ) ; i ++ ) { OBJIndex currentIndex = indices . get ( i ) ; Vector3f currentPosition = positions . get ( currentIndex . vertexIndex ) ; Vector2f currentTexCoord ; Vector3f currentNormal ; if ( hasTexCoords ) currentTexCoord = texCoords . get ( currentIndex . texCoordIndex ) ; else currentTexCoord = new Vector2f ( 0 , 0 ) ; if ( hasNormals ) currentNormal = normals . get ( currentIndex . normalIndex ) ; else currentNormal = new Vector3f ( 0 , 0 , 0 ) ; Integer modelVertexIndex = resultIndexMap . get ( currentIndex ) ; if ( modelVertexIndex == null ) { modelVertexIndex = result . getPositions ( ) . size ( ) ; resultIndexMap . put ( currentIndex , modelVertexIndex ) ; result . getPositions ( ) . add ( currentPosition ) ; result . getTexCoords ( ) . add ( currentTexCoord ) ; if ( hasNormals ) result . getNormals ( ) . add ( currentNormal ) ; result . getTangents ( ) . add ( new Vector3f ( 0 , 0 , 0 ) ) ; } Integer normalModelIndex = normalIndexMap . get ( currentIndex . vertexIndex ) ; if ( normalModelIndex == null ) { normalModelIndex = normalModel . getPositions ( ) . size ( ) ; normalIndexMap . put ( currentIndex . vertexIndex , normalModelIndex ) ; normalModel . getPositions ( ) . add ( currentPosition ) ; normalModel . getTexCoords ( ) . add ( currentTexCoord ) ; normalModel . getNormals ( ) . add ( currentNormal ) ; normalModel . getTangents ( ) . add ( new Vector3f ( 0 , 0 , 0 ) ) ; } result . getIndices ( ) . add ( modelVertexIndex ) ; normalModel . getIndices ( ) . add ( normalModelIndex ) ; indexMap . put ( modelVertexIndex , normalModelIndex ) ; } if ( ! hasNormals ) { normalModel . calcNormals ( ) ; for ( int i = 0 ; i < result . getPositions ( ) . size ( ) ; i ++ ) result . getNormals ( ) . add ( normalModel . getNormals ( ) . get ( indexMap . get ( i ) ) ) ; } normalModel . calcTangents ( ) ; for ( int i = 0 ; i < result . getPositions ( ) . size ( ) ; i ++ ) result . getTangents ( ) . add ( normalModel . getTangents ( ) . get ( indexMap . get ( i ) ) ) ; return result ; }
tr	8	public void searchContacts ( String search ) { try { ArrayList < Contact > results = new ArrayList < > ( 1 ) ; String [ ] searchArray = search . split ( " " ) ; for ( Contact c : contacts ) { if ( c . getFirstName ( ) . contains ( searchArray [ 0 ] ) ) results . add ( c ) ; else if ( c . getLastName ( ) . contains ( searchArray [ searchArray . length - 1 ] ) ) results . add ( c ) ; else if ( c . getPhone ( ) . contains ( search ) ) results . add ( c ) ; else if ( c . getEmail ( ) . contains ( search ) ) results . add ( c ) ; } if ( results . size ( ) < 1 ) throw new ContactNotFoundException ( ) ; System . out . println ( "Search results:" ) ; for ( Contact c : results ) { System . out . println ( c ) ; } confirmDeleteRecords ( results ) ; } catch ( ContactNotFoundException e ) { System . out . println ( e . getMessage ( ) ) ; return ; } }
tr	1	private void setupServerEnvironment ( ) { if ( ssl ) HTTPSSession . register ( TransportRegistry . getTransportRegistryInstance ( ) ) ; else HTTPSessionApache . register ( TransportRegistry . getTransportRegistryInstance ( ) ) ; }
tr	1	public static void require ( final boolean requirement , final String message ) { if ( ! requirement ) { throw new IllegalArgumentException ( message ) ; } }
tr	6	protected boolean isValid ( ) { if ( hasCharacter ( ) ) { if ( ! characterData . isValid ( ) ) { return false ; } } for ( TileObjectDisplayData data : itemData ) { if ( ! data . isValid ( ) ) { return false ; } } for ( TileObjectDisplayData data : edgeData . values ( ) ) { if ( ! data . isValid ( ) ) { return false ; } } return true ; }
tr	5	public static boolean findIfThereIsAPart_hashmap ( List < Stock > stocks , int target ) { Map < Integer , Integer > map = new HashMap < > ( ) ; for ( int i = 0 ; i < stocks . size ( ) ; i ++ ) { Integer value = stocks . get ( i ) . getValue ( ) ; if ( ! map . containsKey ( value ) ) { map . put ( value , 0 ) ; } Integer t = map . get ( value ) ; t += 1 ; map . put ( value , t ) ; } for ( int i = 0 ; i < stocks . size ( ) ; i ++ ) { int current = stocks . get ( i ) . getValue ( ) ; int another = target - current ; if ( map . get ( another ) >= ( current == another ? 2 : 1 ) ) { return true ; } } return false ; }
tr	8	public void setFieldValue ( _Fields field , Object value ) { switch ( field ) { case QUEUE_NAME : if ( value == null ) { unset_queue_name ( ) ; } else { set_queue_name ( ( String ) value ) ; } break ; case MAX_ITEMS : if ( value == null ) { unset_max_items ( ) ; } else { set_max_items ( ( Integer ) value ) ; } break ; case TIMEOUT_MSEC : if ( value == null ) { unset_timeout_msec ( ) ; } else { set_timeout_msec ( ( Integer ) value ) ; } break ; case AUTO_ABORT_MSEC : if ( value == null ) { unset_auto_abort_msec ( ) ; } else { set_auto_abort_msec ( ( Integer ) value ) ; } break ; } }
tr	5	public static void benchmark ( ) throws Exception { int N = 10000 ; String [ ] methodsToCompare = { "approxSort1" , "approxSort2" } ; int k = 10 ; int [ ] arr = new int [ 1000 ] ; for ( int i = 0 ; i < 1000 ; i ++ ) { arr [ i ] = ( int ) ( i * 1000 + Math . floor ( Math . random ( ) * 100 ) ) ; int offset = ( int ) ( Math . floor ( Math . random ( ) * 2 * k ) - k ) ; if ( i + offset > 0 && i + offset < arr . length ) { swap ( arr , i , i + offset ) ; } } for ( String methodName : methodsToCompare ) { class clazz = class . forName ( "book.chapter.ten.Problem10_06" ) ; Method method = clazz . getDeclaredMethod ( methodName , int [ ] . class , int . class ) ; double totalTime = 0.0 ; for ( int i = 0 ; i < N ; i ++ ) { int [ ] arrClone = arr . clone ( ) ; long startTime = System . nanoTime ( ) ; method . invoke ( null , arrClone , k ) ; long endTime = System . nanoTime ( ) ; totalTime += ( endTime - startTime ) / 1000000000.0 ; } System . out . println ( "Elapsed time for " + methodName + ": " + totalTime + " seconds" ) ; } }
tr	3	private boolean promptShiftRight ( ) { String spriteTypeName = null ; String selectedState = null ; PoseurGUI gui = Poseur . getPoseur ( ) . getGUI ( ) ; AnimatedSpriteViewer view = gui . getAnimametedViewerPanel ( ) ; try { spriteTypeName = view . getJlist ( ) . getSelectedValue ( ) . toString ( ) ; selectedState = view . getCombo ( ) . getSelectedItem ( ) . toString ( ) ; if ( view . getCombo ( ) . getSelectedItem ( ) . toString ( ) . equals ( "NULL" ) || view . getCombo ( ) . getSelectedItem ( ) . toString ( ) . equals ( "Select Animation State" ) ) { throw new NullPointerException ( ) ; } } catch ( NullPointerException e ) { JOptionPane . showMessageDialog ( view , "You did not select either state or sprite type" ) ; return false ; } currentSpriteName = spriteTypeName ; currentFileName = spriteTypeName + SPRITE_FILE_EXTENSION ; currentFile = new File ( SPRITES_PATH + currentFileName ) ; String path = "./data/sprite_types/" + spriteTypeName ; File currentFile3 = new File ( path + "/" + currentFileName ) ; spriteIO . poseShiftRight ( gui . getID ( ) ) ; saved = true ; String appName = gui . getAppName ( ) ; gui . setTitle ( appName + APP_NAME_FILE_NAME_SEPARATOR + currentFile ) ; Poseur singleton = Poseur . getPoseur ( ) ; return false ; }
tr	3	public synchronized void shutdown ( ) { if ( mAmShutdown ) return ; Log . d ( TAG , "NetBase shutting down..." ) ; mAmShutdown = true ; try { for ( String serviceName : serviceMap . keySet ( ) ) { NetLoadableService service = serviceMap . get ( serviceName ) ; service . shutdown ( ) ; } serviceMap . clear ( ) ; } catch ( Exception e ) { Log . e ( TAG , "Error shutting down services: " + e . getMessage ( ) ) ; throw new RuntimeException ( e . getMessage ( ) ) ; } theNetBaseInstance = null ; }
tr	2	@ Override public void put ( Point point , double value ) { if ( value != 0.5 ) cells . put ( point , value ) ; else if ( cells . containsKey ( point ) ) { cells . remove ( point ) ; } }
tr	1	@ Override public void setIsMondayFirstDayOfWeek ( boolean isMondayFirstDayOfWeek ) { if ( isMondayFirstDayOfWeek == true ) { weekDaysMap . put ( 0 , MONDAY ) ; weekDaysMap . put ( 1 , TUESDAY ) ; weekDaysMap . put ( 2 , WEDNESDAY ) ; weekDaysMap . put ( 3 , THURSDAY ) ; weekDaysMap . put ( 4 , FRIDAY ) ; weekDaysMap . put ( 5 , SATURDAY ) ; weekDaysMap . put ( 6 , SUNDAY ) ; } else { weekDaysMap . put ( 0 , SUNDAY ) ; weekDaysMap . put ( 1 , MONDAY ) ; weekDaysMap . put ( 2 , TUESDAY ) ; weekDaysMap . put ( 3 , WEDNESDAY ) ; weekDaysMap . put ( 4 , THURSDAY ) ; weekDaysMap . put ( 5 , FRIDAY ) ; weekDaysMap . put ( 6 , SATURDAY ) ; } super . setIsMondayFirstDayOfWeek ( isMondayFirstDayOfWeek ) ; }
tr	1	public static int getHoursThisYear ( int driver ) { if ( driver == 0 ) throw new InvalidQueryException ( "Nonexistent driver" ) ; return database . busDatabase . get_int ( "driver" , driver , "hours_this_year" ) ; }
tr	7	public static String formatSize ( long size , UnitsFormat format ) { String s = null ; double decimalSize = size ; int index = 0 ; switch ( format ) { case DECIMAL : while ( decimalSize >= SIZE_DECIMAL_STEP ) { decimalSize /= SIZE_DECIMAL_STEP ; index ++ ; } if ( index >= SIZE_DECIMAL_UNITS . length ) { index = SIZE_DECIMAL_UNITS . length - 1 ; } s = String . format ( "%.2f %s" , decimalSize , SIZE_DECIMAL_UNITS [ index ] ) ; break ; case BINARY : while ( decimalSize >= SIZE_BINARY_STEP ) { decimalSize /= SIZE_BINARY_STEP ; index ++ ; } if ( decimalSize >= SIZE_DECIMAL_STEP ) { decimalSize /= SIZE_BINARY_STEP ; index ++ ; } if ( index >= SIZE_BINARY_UNITS . length ) { index = SIZE_BINARY_UNITS . length - 1 ; } s = String . format ( "%.2f %s" , decimalSize , SIZE_BINARY_UNITS [ index ] ) ; break ; } return s ; }
tr	9	private boolean method486 ( int i , int j , int k , int l , int i1 , int j1 , int k1 , int l1 ) { if ( j < k && j < l && j < i1 ) return false ; if ( j > k && j > l && j > i1 ) return false ; return ! ( i < j1 && i < k1 && i < l1 ) && ( i <= j1 || i <= k1 || i <= l1 ) ; }
tr	9	private boolean r_prelude ( ) { int v_1 ; int v_2 ; int v_3 ; int v_4 ; int v_5 ; B_Y_found = false ; v_1 = cursor ; lab0 : do { bra = cursor ; if ( ! ( eq_s ( 1 , "'" ) ) ) { break lab0 ; } ket = cursor ; slice_del ( ) ; } while ( false ) ; cursor = v_1 ; v_2 = cursor ; lab1 : do { bra = cursor ; if ( ! ( eq_s ( 1 , "y" ) ) ) { break lab1 ; } ket = cursor ; slice_from ( "Y" ) ; B_Y_found = true ; } while ( false ) ; cursor = v_2 ; v_3 = cursor ; lab2 : do { replab3 : while ( true ) { v_4 = cursor ; lab4 : do { golab5 : while ( true ) { v_5 = cursor ; lab6 : do { if ( ! ( in_grouping ( g_v , 97 , 121 ) ) ) { break lab6 ; } bra = cursor ; if ( ! ( eq_s ( 1 , "y" ) ) ) { break lab6 ; } ket = cursor ; cursor = v_5 ; break golab5 ; } while ( false ) ; cursor = v_5 ; if ( cursor >= limit ) { break lab4 ; } cursor ++ ; } slice_from ( "Y" ) ; B_Y_found = true ; continue replab3 ; } while ( false ) ; cursor = v_4 ; break replab3 ; } } while ( false ) ; cursor = v_3 ; return true ; }
