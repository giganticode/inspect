tr	6	private static byte [ ] encode3to4 ( byte [ ] source , int srcOffset , int numSigBytes , byte [ ] destination , int destOffset , int options ) { byte [ ] ALPHABET = getAlphabet ( options ) ; int inBuff = ( numSigBytes > 0 ? ( ( source [ srcOffset ] << 24 ) >>> 8 ) : 0 ) | ( numSigBytes > 1 ? ( ( source [ srcOffset + 1 ] << 24 ) >>> 16 ) : 0 ) | ( numSigBytes > 2 ? ( ( source [ srcOffset + 2 ] << 24 ) >>> 24 ) : 0 ) ; switch ( numSigBytes ) { case 3 : destination [ destOffset ] = ALPHABET [ ( inBuff >>> 18 ) ] ; destination [ destOffset + 1 ] = ALPHABET [ ( inBuff >>> 12 ) & 3f ] ; destination [ destOffset + 2 ] = ALPHABET [ ( inBuff >>> 6 ) & 3f ] ; destination [ destOffset + 3 ] = ALPHABET [ ( inBuff ) & 3f ] ; return destination ; case 2 : destination [ destOffset ] = ALPHABET [ ( inBuff >>> 18 ) ] ; destination [ destOffset + 1 ] = ALPHABET [ ( inBuff >>> 12 ) & 3f ] ; destination [ destOffset + 2 ] = ALPHABET [ ( inBuff >>> 6 ) & 3f ] ; destination [ destOffset + 3 ] = EQUALS_SIGN ; return destination ; case 1 : destination [ destOffset ] = ALPHABET [ ( inBuff >>> 18 ) ] ; destination [ destOffset + 1 ] = ALPHABET [ ( inBuff >>> 12 ) & 3f ] ; destination [ destOffset + 2 ] = EQUALS_SIGN ; destination [ destOffset + 3 ] = EQUALS_SIGN ; return destination ; default : return destination ; } }
tr	2	private synchronized void sendPlain ( String text ) { if ( getState ( ) == STATE_READY ) try { transport . send ( text ) ; } catch ( Exception e ) { outputBuffer . add ( text ) ; } else { outputBuffer . add ( text ) ; } }
tr	7	public boolean next ( int charToChoose ) throws IOException { System . out . println ( wordsSoFar ) ; ArrayList < Character > charsSoFar = new ArrayList < Character > ( ) ; for ( String s : wordsSoFar ) { for ( char c : s . toCharArray ( ) ) { charsSoFar . add ( c ) ; } } ArrayList < Character > tilesCopy = copyExclusiveLetters ( tilesList , charsSoFar ) ; if ( tilesCopy . size ( ) == 0 ) { return true ; } char c = charsSoFar . get ( charToChoose ) ; char [ ] newArray = new char [ tilesCopy . size ( ) + 1 ] ; int i = 0 ; for ( i = 0 ; i < tilesCopy . size ( ) ; i ++ ) { newArray [ i ] = tilesCopy . get ( i ) ; } newArray [ i ] = c ; FormWordsWithTiles f2 = new FormWordsWithTiles ( convertToList ( newArray ) ) ; ArrayList < String > words = f2 . getWordsThatCanBeFormedWithTiles ( ) ; for ( int j = 0 ; j < words . size ( ) ; j ++ ) { if ( ! containsChar ( words . get ( j ) , c ) ) { words . remove ( j ) ; j -- ; } } if ( words . isEmpty ( ) ) { System . out . println ( "no more words to make" ) ; return false ; } else { String str = words . get ( 0 ) ; wordsSoFar . add ( str ) ; next ( ++ charToChoose ) ; } return false ; }
tr	3	private void constructTextOutput ( final Vector < ScoredDocument > docs , StringBuffer response ) { for ( ScoredDocument doc : docs ) { response . append ( response . length ( ) > 0 ? "\n" : "" ) ; response . append ( doc . asTextResult ( ) ) ; } response . append ( response . length ( ) > 0 ? "\n" : "" ) ; }
tr	7	public String dTDetailSearch ( String id ) { String docName = "" ; String docTellContent = "" ; String excuteDate = "" ; String stopDate = "" ; String docTellStatus = "" ; String docTellType = "" ; String sd = "" ; String pn = "" ; String str = "select u.user_name dt.doc_tell_content dt.excute_date dt.stop_date dt.doc_tell_type dt.doc_tell_status from doc_tell dt user u where dt.id='" + id + "' and dt.doc_id=u.user_id;" ; System . out . println ( "docTellDetailSearch_______________________" + str ) ; try { conn = dbConn . getConn ( ) ; pstmt = conn . prepareStatement ( str ) ; ResultSet num = pstmt . executeQuery ( ) ; while ( num . next ( ) ) { excuteDate = num . getString ( "excute_date" ) ; stopDate = num . getString ( "stop_date" ) ; docName = num . getString ( "user_name" ) ; docTellStatus = num . getString ( "doc_tell_status" ) ; docTellType = num . getString ( "doc_tell_type" ) ; docTellContent = num . getString ( "doc_tell_content" ) ; sb . append ( " <tr><input type=\"text\" value=\"<%=session.getAttribute('userId') %>\" style=\"display:none\" id=\"excuteId\"/><input type=\"text\" value=\"" + id + "\" id=\"id\" style=\"display:none\"/> <td>\u4E3B\u6CBB\u533B\u751F:" + docName + "</td>  <td>\u4F5C\u7528\u65F6\u95F4:" + excuteDate + "~" + stopDate + "</td> </tr>" ) ; sb . append ( "<tr> <td colspan=\"2\">\u533B\u5631\u5185\u5BB9\uFF1A <textarea readonly rows=\"6\" cols=\"80\" name=\"docTellContent\" id=\"docTellContent\" onpropertychange=\"if(this.scrollHeight>80) this.style.posHeight=this.scrollHeight+5\">" + docTellContent + "</textarea></td> </tr><td colspan=\"2\">" ) ; if ( docTellType . equals ( "1" ) ) { switch ( Integer . parseInt ( docTellStatus ) ) { case 1 : sb . append ( "<input type=button  id=\"nurseCheck\" onclick=\"save(2)\" value=\"\u62A4\u58EB\u6821\u5BF9\" class=\"btn blue\"/>" ) ; break ; case 2 : sb . append ( "<input type=button id=\"docStop\"  onclick=\"save(3)\" value=\"\u505C\u6B62\u533B\u5631\"  class=\"btn blue\"/>" ) ; break ; case 3 : sb . append ( "<input type=button  id=\"nurseConfirm\" onclick=\"save(4)\"  value=\"\u62A4\u58EB\u786E\u8BA4\"   class=\"btn blue\"/>" ) ; break ; } } else if ( docTellType . equals ( "2" ) ) { sb . append ( "<input type=button  id=\"nurseConfirm\"  value=\"\u62A4\u58EB\u786E\u8BA4\" onclick=\"save(4)\"  class=\"btn blue\"/>" ) ; } sb . append ( "</td>  </tr>" ) ; } pstmt . close ( ) ; dbConn . close ( conn ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; } return sb . toString ( ) ; }
tr	2	public void handle ( ) throws PacketException { byte respHeader = response [ 0 ] ; if ( respHeader == SERVER_PACKET_HEADER_OK ) return ; if ( respHeader == SERVER_PACKET_HEADER_FAIL ) { throw new PacketException ( "Failed to request version info." ) ; } }
tr	9	public static BufferedImage getImage ( String url , String refer , EventCallback callback ) { BufferedImage image = null ; HttpURLConnection conn = null ; InputStream is = null ; try { URL serverUrl = new URL ( url ) ; conn = ( HttpURLConnection ) serverUrl . openConnection ( ) ; conn . setRequestMethod ( "GET" ) ; if ( refer != null ) { conn . addRequestProperty ( "Referer" , refer ) ; } else { conn . addRequestProperty ( "Referer" , URL_REFER_Q ) ; } conn . addRequestProperty ( "Cookie" , getCookie ( ) ) ; conn . addRequestProperty ( "Accept-Charset" , "UTF-8;" ) ; conn . addRequestProperty ( "Accept" , "text/html application/xhtml+xml application/xml;q=0.9 image/webp */*;q=0.8" ) ; conn . addRequestProperty ( "Connection" , "keep-alive" ) ; conn . addRequestProperty ( "User-Agent" , "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_0) AppleWebKit/537.36 (KHTML  like Gecko) Chrome/36.0.1985.125 Safari/537.36" ) ; conn . connect ( ) ; if ( conn . getHeaderFields ( ) . get ( "Set-Cookie" ) != null ) { for ( String s : conn . getHeaderFields ( ) . get ( "Set-Cookie" ) ) { addCookie ( new BotCookie ( s ) ) ; } } is = conn . getInputStream ( ) ; image = ImageIO . read ( is ) ; } catch ( Exception e ) { if ( callback != null ) { callback . exec ( false ) ; } } finally { if ( is != null ) { try { is . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } finally { is = null ; } } } String verifyString = HttpHelper . getCookie ( "verifysession" ) ; if ( verifyString != null ) { Bot . getInstance ( ) . setVerifySession ( verifyString ) ; HttpHelper . addCookie ( new BotCookie ( "ptvfsession" , verifyString ) ) ; } if ( callback != null ) { callback . exec ( true ) ; } return image ; }
tr	1	@ Override public void init ( ) { qidtf = new JTextField ( ) ; label = new JLabel ( ) ; setLayout ( new BorderLayout ( ) ) ; add ( "North" , new JLabel ( "Quest ID" ) ) ; add ( "Center" , qidtf ) ; add ( "South" , label ) ; label . setForeground ( Color . RED ) ; qidtf . getDocument ( ) . addDocumentListener ( new QuestExistsListener ( getFinishButton ( ) ) { public boolean update ( DocumentEvent e ) { boolean a = super . update ( e ) ; if ( a == false ) label . setText ( "This quest doesn't exist." ) ; else label . setText ( "" ) ; return a ; } } ) ; }
tr	4	public void run ( ) { boolean running = true ; long lastTime = System . nanoTime ( ) ; double nsPerTick = 1000000000D / 60D ; int ticks = 0 ; int frames = 0 ; long lastTimer = System . currentTimeMillis ( ) ; double delta = 0 ; while ( running ) { long now = System . nanoTime ( ) ; delta += ( now - lastTime ) / nsPerTick ; lastTime = now ; boolean shouldRender = false ; while ( delta >= 1 ) { ticks ++ ; update ( ) ; delta -= 1 ; shouldRender = true ; } if ( shouldRender ) { frames ++ ; paint ( reference . getWindow ( ) . getGraphics ( ) ) ; } if ( System . currentTimeMillis ( ) - lastTimer >= 1000 ) { lastTimer += 1000 ; frames = 0 ; ticks = 0 ; } } repaint ( ) ; }
tr	2	@ Override public void onMoveTick ( int x , int y , Game game ) { SinglePlayerGame spg = ( SinglePlayerGame ) game ; if ( filterByID ( spg . getSquareNeighbors ( x , y , 1 ) , juggernaut . id ) . isEmpty ( ) ) { Location loc = spg . getFirstSquareNeighborLocation ( x , y , 2 , zombie . id ) ; spg . moveEntity ( x , y , loc == null ? Location . wander ( x , y , 1 ) : Location . away ( x , y , loc , 2 ) ) ; } }
tr	0	public int getBlackTime ( ) { return this . blackTime ; }
tr	9	public void move ( ) { if ( xdir < 0 ) setGraphic ( "engineer_l" ) ; if ( xdir > 0 ) setGraphic ( "engineer_r" ) ; if ( x < 0 && xdir < 0 ) xdir = - xdir ; if ( y < 0 && ydir < 0 ) ydir = - ydir ; if ( x > game . pfWidth ( ) - 16 && xdir > 0 ) xdir = - xdir ; if ( y > game . pfHeight ( ) - 16 && ydir > 0 ) ydir = - ydir ; if ( buildingBunker == 0 ) { if ( game . countObjects ( "engineer" , 0 ) < 15 ) { if ( game . random ( 0 , 100 , 1 ) == 1 ) new Engineer ( x - 8 , y - 8 , - xspeed , yspeed - 0.05 , game ) ; } } else buildingBunker -- ; }
tr	3	private void setUIDesign ( ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Metal" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException | InstantiationException | IllegalAccessException | javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( MantenimientoUsuario . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } }
tr	8	public ArrayList < ArrayList < State >> printTrace ( String string , ArrayList < Automaton > disTA ) { String actions [ ] = string . split ( " " ) ; ArrayList < ArrayList < State >> states ; for ( ArrayList < State > state : startStates ) { states = new ArrayList < ArrayList < State >> ( ) ; ArrayList < State > searchState = state ; states . add ( searchState ) ; for ( String action : actions ) { boolean matchFound = false ; if ( adjList != null ) { Set < EdgeOfZoneGraph > edges = adjList . get ( searchState ) ; if ( edges != null ) { Iterator < EdgeOfZoneGraph > it = edges . iterator ( ) ; while ( it . hasNext ( ) ) { EdgeOfZoneGraph edge = ( EdgeOfZoneGraph ) it . next ( ) ; if ( edge . getAction ( ) . equals ( action ) ) { states . add ( edge . getEndState ( ) ) ; searchState = edge . getEndState ( ) ; matchFound = true ; break ; } } } } if ( ! matchFound ) { return null ; } } if ( isFinal ( states . get ( states . size ( ) - 1 ) , disTA ) ) { return states ; } } return null ; }
tr	2	private void btn_ok_pressed ( java . awt . event . ActionEvent evt ) { tf_authorName . requestFocus ( false ) ; tf_email . requestFocus ( false ) ; _author . setName ( tf_authorName . getText ( ) ) ; if ( ! _author . setEmail ( tf_email . getText ( ) ) ) { tf_email . setText ( "destek@kade.com.tr" ) ; JOptionPane . showMessageDialog ( null , "Please enter a valid email." , "Email is not valid!" , JOptionPane . ERROR_MESSAGE ) ; return ; } if ( _selectedIndex == - 1 ) { MainFrame . installation . getInformationModel ( ) . getAuthors ( ) . remove ( _author ) ; MainFrame . installation . getInformationModel ( ) . getAuthors ( ) . add ( _author ) ; } else { MainFrame . installation . getInformationModel ( ) . getAuthors ( ) . remove ( _author ) ; MainFrame . installation . getInformationModel ( ) . getAuthors ( ) . add ( _selectedIndex , _author ) ; } this . setVisible ( false ) ; }
tr	5	@ Override public void work ( ) { try { Vertex v = getClickedVertex ( ) ; if ( v == null ) { gui . console ( "Choose a vertex" ) ; return ; } doFillVertex = true ; Queue < Vertex > q = new LinkedList < Vertex > ( ) ; v . visited = true ; q . add ( v ) ; while ( ! q . isEmpty ( ) ) { v = q . poll ( ) ; v . vColor = Color . RED ; for ( Edge e : v . adj ) { Vertex w = e . dest ; if ( ! w . visited ) { w . visited = true ; q . add ( w ) ; } } repaint ( ) ; sleep ( GUI_EXECUTION_PAUSE ) ; } } catch ( Exception e ) { } clearAll ( ) ; repaint ( ) ; }
tr	0	public void setProduto ( Produto produto ) { this . produto = produto ; }
tr	2	@ Override public synchronized boolean checkToken ( Token token ) { for ( Token to : tokens ) { if ( token . equals ( to ) ) { return true ; } } return false ; }
tr	6	public List < Entity > getEntities ( int x , int y ) { if ( x < 0 || x >= width || y < 0 || y >= height ) { throw new IllegalArgumentException ( "Location is out of bounds!" ) ; } ArrayList < Entity > presentEntities = new ArrayList < Entity > ( ) ; for ( Entry < Integer , Entity > e : entities . entrySet ( ) ) { if ( e . getValue ( ) . getLocation ( ) . equals ( new WorldLocation ( this , x , y ) ) ) { presentEntities . add ( e . getValue ( ) ) ; } } Collections . sort ( presentEntities ) ; return presentEntities ; }
tr	3	static int readFully ( InputStream in , byte buffer [ ] , int offset , int len ) throws java . io . IOException { for ( int i = 0 ; i < len ; i ++ ) { int q = in . read ( ) ; if ( q == - 1 ) return ( ( i == 0 ) ? - 1 : i ) ; buffer [ i + offset ] = ( byte ) q ; } return len ; }
tr	6	@ SuppressWarnings ( "unchecked" ) public static String getText ( GenericTreeNode < LayoutParserTreeElement > element ) { if ( element . getData ( ) . elementType . toString ( ) . compareTo ( "String" ) == 0 ) { return element . getData ( ) . text ; } List < GenericTreeNode < LayoutParserTreeElement >> children = element . getChildren ( ) ; Collections . sort ( children , new ElementComparator ( ) ) ; String text = "" ; for ( GenericTreeNode < LayoutParserTreeElement > child : children ) { text = text . concat ( getText ( child ) ) ; if ( child . getData ( ) . elementType . toString ( ) . compareTo ( "TextLine" ) == 0 ) { text = text . concat ( "\n" ) ; } else if ( child . getData ( ) . elementType . toString ( ) . compareTo ( "String" ) == 0 ) { text = text . concat ( " " ) ; } } text = text . replaceAll ( " $" , "" ) ; if ( element . getData ( ) . elementType . toString ( ) . compareTo ( "TextBlock" ) == 0 && text . length ( ) > 0 ) { text = text . substring ( 0 , text . length ( ) - 1 ) ; } return text ; }
tr	9	@ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; Contact other = ( Contact ) obj ; if ( Email == null ) { if ( other . Email != null ) return false ; } else if ( ! Email . equals ( other . Email ) ) return false ; if ( FaceBook == null ) { if ( other . FaceBook != null ) return false ; } else if ( ! FaceBook . equals ( other . FaceBook ) ) return false ; if ( Phone == null ) { if ( other . Phone != null ) return false ; } else if ( ! Phone . equals ( other . Phone ) ) return false ; if ( WebUrl == null ) { if ( other . WebUrl != null ) return false ; } else if ( ! WebUrl . equals ( other . WebUrl ) ) return false ; return true ; }
tr	7	private void GUI4 ( ) { JPanel panel4 = new JPanel ( ) ; jtp . addTab ( "<html><body marginwidth=15 marginheight=8><b>Step 4:</b><br>Hotel<br>Suggestions&nbsp;</body></html>" , null , panel4 , "View hotel suggestions" ) ; panel4 . setLayout ( null ) ; JLabel lbl4_LocationSelection = new JLabel ( "Hotel Selection" ) ; lbl4_LocationSelection . setFont ( new Font ( "Tahoma" , Font . BOLD , 16 ) ) ; lbl4_LocationSelection . setBounds ( 10 , 10 , 159 , 30 ) ; panel4 . add ( lbl4_LocationSelection ) ; JLabel lbl4_Preference = new JLabel ( "Preference: " ) ; lbl4_Preference . setFont ( new Font ( "Tahoma" , Font . PLAIN , 12 ) ) ; lbl4_Preference . setBounds ( 10 , 42 , 82 , 20 ) ; panel4 . add ( lbl4_Preference ) ; chckbx4_5Star = new JCheckBox ( "5 Star" ) ; chckbx4_5Star . setSelected ( true ) ; chckbx4_5Star . setFont ( new Font ( "Tahoma" , Font . PLAIN , 12 ) ) ; chckbx4_5Star . setBounds ( 102 , 42 , 65 , 20 ) ; panel4 . add ( chckbx4_5Star ) ; chckbx4_4Star = new JCheckBox ( "4 Star" ) ; chckbx4_4Star . setSelected ( true ) ; chckbx4_4Star . setFont ( new Font ( "Tahoma" , Font . PLAIN , 12 ) ) ; chckbx4_4Star . setBounds ( 202 , 42 , 65 , 20 ) ; panel4 . add ( chckbx4_4Star ) ; chckbx4_3Star = new JCheckBox ( "3 Star" ) ; chckbx4_3Star . setSelected ( true ) ; chckbx4_3Star . setFont ( new Font ( "Tahoma" , Font . PLAIN , 12 ) ) ; chckbx4_3Star . setBounds ( 302 , 42 , 65 , 20 ) ; panel4 . add ( chckbx4_3Star ) ; textPane4_Guests = new JTextPane ( ) ; textPane4_Guests . setEditable ( false ) ; textPane4_Guests . setBorder ( new MatteBorder ( 1 , 1 , 1 , 1 , ( Color ) new Color ( 0 , 0 , 0 ) ) ) ; textPane4_Guests . setBounds ( 533 , 42 , 107 , 20 ) ; panel4 . add ( textPane4_Guests ) ; JLabel lbl4_BudgetRatio = new JLabel ( "Budget Ratio: " ) ; lbl4_BudgetRatio . setFont ( new Font ( "Tahoma" , Font . PLAIN , 12 ) ) ; lbl4_BudgetRatio . setBounds ( 10 , 109 , 82 , 20 ) ; panel4 . add ( lbl4_BudgetRatio ) ; slider4 = new JSlider ( ) ; slider4 . setPaintLabels ( true ) ; slider4 . setPaintTicks ( true ) ; slider4 . setMinorTickSpacing ( 5 ) ; slider4 . setCursor ( Cursor . getPredefinedCursor ( Cursor . DEFAULT_CURSOR ) ) ; slider4 . setSnapToTicks ( true ) ; slider4 . setMajorTickSpacing ( 10 ) ; slider4 . setBounds ( 102 , 101 , 421 , 45 ) ; panel4 . add ( slider4 ) ; slider4 . addChangeListener ( new ChangeListener ( ) { public void stateChanged ( ChangeEvent e ) { lg . setBudgetRatio ( slider4 . getValue ( ) ) ; double hotelBudgetSpent = lg . calculateHotelBudget ( ) ; textPane4_Budget . setText ( String . valueOf ( "$" + hotelBudgetSpent ) ) ; } } ) ; textPane4_Budget = new JTextPane ( ) ; textPane4_Budget . setEditable ( false ) ; textPane4_Budget . setBorder ( new MatteBorder ( 1 , 1 , 1 , 1 , ( Color ) new Color ( 0 , 0 , 0 ) ) ) ; textPane4_Budget . setBounds ( 533 , 109 , 107 , 20 ) ; panel4 . add ( textPane4_Budget ) ; btn4_Suggest = new JButton ( "Suggest" ) ; btn4_Suggest . setFont ( new Font ( "Tahoma" , Font . BOLD , 12 ) ) ; btn4_Suggest . setBounds ( 550 , 167 , 90 , 30 ) ; panel4 . add ( btn4_Suggest ) ; btn4_Suggest . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { lg . clearHotelSuggestions ( ) ; boolean checkbox3Star = chckbx4_3Star . isSelected ( ) ; boolean checkbox4Star = chckbx4_4Star . isSelected ( ) ; boolean checkbox5Star = chckbx4_5Star . isSelected ( ) ; boolean [ ] checkbox = new boolean [ 3 ] ; try { if ( checkbox3Star == true ) { lg . hotelSuggest ( 3 ) ; } else { checkbox3Star = false ; } if ( checkbox4Star == true ) { lg . hotelSuggest ( 4 ) ; } else { checkbox4Star = false ; } if ( checkbox5Star == true ) { lg . hotelSuggest ( 5 ) ; } else { checkbox5Star = false ; } checkbox [ 0 ] = checkbox3Star ; checkbox [ 1 ] = checkbox4Star ; checkbox [ 2 ] = checkbox5Star ; lg . setcheckBox ( checkbox ) ; } catch ( IOException io ) { JOptionPane . showMessageDialog ( new JFrame ( ) , "Hotel data file could not be found. Please ensure " + "'hotelData' is found in the Data directory in your program folder." ) ; } catch ( Exception ex ) { JOptionPane . showMessageDialog ( new JFrame ( ) , ex . getMessage ( ) ) ; } list4 . removeAll ( ) ; textPane4_HotelDetails . setText ( "" ) ; list4 . setListData ( lg . getSuggestedHotelsNames ( ) ) ; } } ) ; JPanel panel4_SuggestedList = new JPanel ( ) ; panel4_SuggestedList . setBorder ( new TitledBorder ( UIManager . getBorder ( "TitledBorder.border" ) , "Suggested List of Hotels" , TitledBorder . LEADING , TitledBorder . TOP , null , null ) ) ; panel4_SuggestedList . setBounds ( 10 , 220 , 246 , 250 ) ; panel4 . add ( panel4_SuggestedList ) ; panel4_SuggestedList . setLayout ( null ) ; JScrollPane scrollPane4 = new JScrollPane ( ) ; scrollPane4 . setBounds ( 6 , 16 , 234 , 226 ) ; panel4_SuggestedList . add ( scrollPane4 ) ; list4 = new JList < String > ( ) ; list4 . setSelectionMode ( ListSelectionModel . SINGLE_SELECTION ) ; scrollPane4 . setViewportView ( list4 ) ; list4 . addListSelectionListener ( new ListSelectionListener ( ) { @ Override public void valueChanged ( ListSelectionEvent e ) { Object obj = e . getSource ( ) ; @ SuppressWarnings ( "unchecked" ) JList < String > list = ( JList < String > ) obj ; Object selectedObj = list . getSelectedValue ( ) ; if ( selectedObj == null ) return ; if ( ( ( String ) selectedObj ) . equals ( "No hotels match your criteria!" ) ) { list . clearSelection ( ) ; return ; } textPane4_HotelDetails . setText ( lg . getHotelInformation ( list . getSelectedIndex ( ) ) ) ; lg . setSelectedHotelIdx ( list4 . getSelectedIndex ( ) ) ; updateStep6 ( ) ; } } ) ; textPane4_HotelDetails = new JTextPane ( ) ; textPane4_HotelDetails . setEditable ( false ) ; textPane4_HotelDetails . setBorder ( new MatteBorder ( 1 , 1 , 1 , 1 , ( Color ) new Color ( 0 , 0 , 0 ) ) ) ; textPane4_HotelDetails . setBounds ( 266 , 220 , 374 , 250 ) ; panel4 . add ( textPane4_HotelDetails ) ; JLabel lbl4_NoOfGuest = new JLabel ( "No. of Guests" ) ; lbl4_NoOfGuest . setFont ( new Font ( "Tahoma" , Font . PLAIN , 12 ) ) ; lbl4_NoOfGuest . setBounds ( 533 , 20 , 82 , 20 ) ; panel4 . add ( lbl4_NoOfGuest ) ; btn4_Next = new JButton ( "Next" ) ; btn4_Next . setFont ( new Font ( "Tahoma" , Font . BOLD , 12 ) ) ; btn4_Next . setBounds ( 560 , 490 , 80 , 30 ) ; panel4 . add ( btn4_Next ) ; btn4_Next . addMouseListener ( this ) ; }
tr	4	private static String toJavaQuantifier ( String cacheQuantifier ) { if ( cacheQuantifier . equals ( "." ) ) { return "*" ; } if ( cacheQuantifier . contains ( "." ) ) { String [ ] partes = cacheQuantifier . split ( "\\." ) ; String min = partes [ 0 ] ; if ( min . length ( ) == 0 ) { min = "0" ; } String max = "" ; if ( partes . length > 1 ) { max = partes [ 1 ] ; } return "{" . concat ( min ) . concat ( " " ) . concat ( max ) . concat ( "}" ) ; } return "{" . concat ( cacheQuantifier ) . concat ( "}" ) ; }
tr	8	public void validateLists ( ) { Iterator < Path > createdIterator = createdFiles . iterator ( ) ; while ( createdIterator . hasNext ( ) ) { if ( ! createdIterator . next ( ) . toFile ( ) . exists ( ) ) { createdIterator . remove ( ) ; } } Iterator < Path > modifiedIterator = modifiedFiles . iterator ( ) ; while ( modifiedIterator . hasNext ( ) ) { if ( ! modifiedIterator . next ( ) . toFile ( ) . exists ( ) ) { modifiedIterator . remove ( ) ; } } Iterator < RenamedFile > renamedIterator = renamedFiles . iterator ( ) ; while ( renamedIterator . hasNext ( ) ) { if ( ! renamedIterator . next ( ) . newName . toFile ( ) . exists ( ) ) { renamedIterator . remove ( ) ; } } Iterator < Path > deletedIterator = deletedFiles . iterator ( ) ; while ( deletedIterator . hasNext ( ) ) { if ( ! deletedIterator . next ( ) . toFile ( ) . exists ( ) ) { deletedIterator . remove ( ) ; } } }
tr	2	public void getStopWordSet ( ) { try { BufferedReader in = new BufferedReader ( new FileReader ( STOPWORDS_PATH ) ) ; String s ; while ( ( s = in . readLine ( ) ) != null ) stopWordSet . add ( s ) ; in . close ( ) ; } catch ( IOException e ) { System . err . println ( e ) ; } }
tr	2	public static Spell toSpell ( String [ ] args ) throws Exception { String nargs [ ] = new String [ args . length - 1 ] ; System . arraycopy ( args , 1 , nargs , 0 , nargs . length ) ; class < ? extends Spell > c = Spells . getSpell ( args [ 0 ] ) ; if ( c == null ) { throw new IllegalArgumentException ( String . format ( "unknown spell %s" , args [ 0 ] ) ) ; } AnnotatedCLI cli = AnnotatedCLI . getMagicCLI ( c ) ; Spell spell = cli . getInstance ( c , nargs ) ; return spell ; }
tr	1	public void leaveFeedback ( ) { try { BrowserLauncher launcher = new BrowserLauncher ( ) ; launcher . openURLinBrowser ( "http://createacity.org/2013/05/demo-now-available/" ) ; } catch ( BrowserLaunchingInitializingException | UnsupportedOperatingSystemException ex ) { Logger . getLogger ( PauseState . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } app . stop ( ) ; }
tr	1	@ Override public void enterRule ( ParseTreeListener listener ) { if ( listener instanceof EnquantoListener ) ( ( EnquantoListener ) listener ) . enterPrograma ( this ) ; }
tr	9	@ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( ! ( o instanceof PlayerState ) ) return false ; PlayerState that = ( PlayerState ) o ; if ( this . ncars != that . ncars ) return false ; if ( this . score != that . score ) return false ; if ( ! this . hand . equals ( that . hand ) ) return false ; if ( ! this . missions . equals ( that . missions ) ) return false ; if ( ! this . railways . equals ( that . railways ) ) return false ; if ( this . drawn_card != that . drawn_card ) return false ; if ( this . drawn_missions == null && that . drawn_missions != null ) return false ; if ( this . drawn_missions != null && ! this . drawn_missions . equals ( that . drawn_missions ) ) return false ; return true ; }
tr	5	public PlayerModificationDialog ( LB2Kview view ) { super ( null , JOptionPane . QUESTION_MESSAGE , JOptionPane . YES_NO_OPTION ) ; this . label = new JLabel ( "asdad" ) ; this . view = view ; this . setMinimumSize ( new Dimension ( 300 , 100 ) ) ; final JDialog dialog = new JDialog ( view , "Click a button" , true ) ; dialog . setContentPane ( this ) ; dialog . setDefaultCloseOperation ( JDialog . DO_NOTHING_ON_CLOSE ) ; dialog . pack ( ) ; dialog . setLocationRelativeTo ( view ) ; dialog . setVisible ( true ) ; this . addPropertyChangeListener ( new PropertyChangeListener ( ) { public void propertyChange ( PropertyChangeEvent e ) { String prop = e . getPropertyName ( ) ; if ( dialog . isVisible ( ) && ( e . getSource ( ) == this ) && ( JOptionPane . VALUE_PROPERTY . equals ( prop ) ) ) { System . out . println ( "hi" ) ; dialog . setVisible ( false ) ; } } } ) ; int value = ( ( Integer ) this . getValue ( ) ) . intValue ( ) ; System . out . println ( value ) ; if ( value == JOptionPane . YES_OPTION ) { this . label = new JLabel ( "asd" ) ; } else if ( value == JOptionPane . NO_OPTION ) { System . out . println ( "n" ) ; } else { } }
tr	5	@ Override public boolean equals ( Object other ) { if ( other == null ) { return false ; } else if ( this == other ) { return true ; } else if ( ! ( other instanceof RecipeIngredient ) ) { return false ; } String ownPrefix = adjustUnitsInString ( prefix , 1 ) ; String otherPrefix = adjustUnitsInString ( ( ( RecipeIngredient ) other ) . getPrefix ( ) , 1 ) ; String ownSuffix = adjustUnitsInString ( suffix , 1 ) ; String otherSuffix = adjustUnitsInString ( ( ( RecipeIngredient ) other ) . getSuffix ( ) , 1 ) ; return ownPrefix . equals ( otherPrefix ) && ownSuffix . equals ( ( otherSuffix ) ) && ingredient . equals ( ( ( RecipeIngredient ) other ) . getIngredient ( ) ) ; }
tr	9	private String generateObject ( Object object , String sep , boolean hasNext , int indentation , int lineLength ) { String rval = "" ; String obj ; if ( object instanceof String ) { obj = getURI ( ( String ) object ) ; } else if ( object instanceof RDFDataset . Literal ) { obj = ( ( RDFDataset . Literal ) object ) . getValue ( ) ; final String dt = ( ( RDFDataset . Literal ) object ) . getDatatype ( ) ; if ( dt != null ) { if ( ! ( XSD_DOUBLE . equals ( dt ) || XSD_INTEGER . equals ( dt ) || XSD_FLOAT . equals ( dt ) || XSD_BOOLEAN . equals ( dt ) ) ) { obj = "\"" + obj + "\"" ; if ( ! XSD_STRING . equals ( dt ) ) { obj += "^^" + getURI ( dt ) ; } } } else { obj = "\"" + obj + "\"" ; final String lang = ( ( RDFDataset . Literal ) object ) . getLanguage ( ) ; if ( lang != null ) { obj += "@" + lang ; } } } else { final Map < String , Map < String , List < Object >>> tmp = new LinkedHashMap < String , Map < String , List < Object >>> ( ) ; tmp . put ( "_:x" , ( Map < String , List < Object >> ) object ) ; obj = generateTurtle ( tmp , indentation + 1 , lineLength , true ) ; } final int idxofcr = obj . indexOf ( "\n" ) ; if ( ( hasNext ? 1 : 0 ) + lineLength + ( idxofcr != - 1 ? idxofcr : obj . length ( ) ) > MAX_LINE_LENGTH ) { rval += "\n" + tabs ( indentation + 1 ) ; lineLength = ( indentation + 1 ) * TAB_SPACES ; } rval += obj ; if ( idxofcr != - 1 ) { lineLength += ( obj . length ( ) - obj . lastIndexOf ( "\n" ) ) ; } else { lineLength += obj . length ( ) ; } if ( hasNext ) { rval += sep ; lineLength += sep . length ( ) ; if ( lineLength < MAX_LINE_LENGTH ) { rval += " " ; lineLength ++ ; } else { rval += "\n" ; } } return rval ; }
tr	7	public Question ( HashMap < String , String > options ) { this . id = Integer . parseInt ( options . get ( "id" ) ) ; this . title = options . get ( "title" ) ; this . type = options . get ( "type" ) ; try { this . filename = options . get ( "filename" ) ; } catch ( Exception e ) { this . filename = "" ; } try { this . loop = boolean . parseBoolean ( options . get ( "loop" ) ) ; } catch ( Exception e ) { this . loop = false ; } try { this . answers = options . get ( "answers" ) ; } catch ( Exception e ) { this . answers = "0;0;0;0" ; } try { this . values = options . get ( "values" ) ; } catch ( Exception e ) { this . values = "0;0;0;0" ; } try { this . correctAnswerID = Integer . parseInt ( options . get ( "correct" ) ) ; } catch ( Exception e ) { correctAnswerID = 0 ; } try { this . fontsize = Integer . parseInt ( options . get ( "font" ) ) ; } catch ( Exception e ) { fontsize = 40 ; } try { this . mcfont = Integer . parseInt ( options . get ( "mcfont" ) ) ; } catch ( Exception e ) { mcfont = 30 ; } createMedia ( ) ; }
tr	7	public static double checkEnergyfactor ( String sMet ) { final int MIN = 1 ; final int MAX = 30 ; double dMet = 0 ; if ( sMet == null || sMet . trim ( ) . length ( ) == 0 ) JOptionPane . showMessageDialog ( null , "Bitte  geben Sie einen MET ein: MET Wert unbekannt vielleicht werden sie hier f\u00FCndig http://www.startblog-f.de/2008/12/23/tabelle-kalorienverbrauch-laufen/" , "Energyfaktor MET nicht eingegeben" , JOptionPane . ERROR_MESSAGE ) ; else try { dMet = double . parseDouble ( sMet ) ; } catch ( NumberFormatException nfe ) { JOptionPane . showMessageDialog ( null , "Bitte  geben Sie den MET nur mit Zahlen ein! \n Vewenden sie einen Punkt statt Komma!!!" , "MET/ Energyfaktoreingabe falsch" , JOptionPane . ERROR_MESSAGE ) ; } if ( dMet < MIN ) JOptionPane . showMessageDialog ( null , "Der MET sollte gr\u00F6\u00DFer als 0 sein" , "Energyfaktor MET zu klein" , JOptionPane . ERROR_MESSAGE ) ; else if ( dMet > MAX ) JOptionPane . showMessageDialog ( null , "Der MET sollte kleiner als 30 sein" , "Energyfaktor MET zu gro\u00DF" , JOptionPane . ERROR_MESSAGE ) ; else if ( dMet < MIN && dMet > MAX ) return dMet ; return dMet ; }
tr	9	@ Override protected BigRational compute ( MultiplicitiesVector finalm , PopulationVector finalp ) throws InternalErrorException { boolean firstVisit = true , secondVisit = false ; BigRational curG ; PopulationVector p = new PopulationVector ( 0 , qnm . R ) ; MultiplicitiesVector mBase = finalm . copy ( ) ; int Ntot = finalp . sum ( ) ; for ( int r = 0 ; r < qnm . R ; r ++ ) { for ( int nr = ( r == 0 ) ? 0 : 1 ; nr <= finalp . get ( r ) ; nr ++ ) { Map < PopulationVector , Map < MultiplicitiesVector , BigRational >> curMap = new HashMap < PopulationVector , Map < MultiplicitiesVector , BigRational >> ( ) ; p . set ( r , nr ) ; boolean isPZeroVector = p . isZeroVector ( ) , pContainsMinusOne = p . containsMinusOne ( ) ; for ( MultiplicitiesVector mDelta : mvcalc . findMulVectorsSummingUpTo ( Ntot ) ) { MultiplicitiesVector m = mBase . addVec ( mDelta ) ; if ( ! isPZeroVector ) { curG = BigRational . ZERO ; if ( pContainsMinusOne ) { continue ; } else if ( m . isZeroVector ( ) ) { continue ; } else { p . minusOne ( r + 1 ) ; BigRational delay = qnm . getDelayAsBigRational ( r ) ; if ( ! delay . isZero ( ) ) { curG = curG . add ( recallG ( m , p ) ) . multiply ( delay ) ; } for ( int k = 0 ; k < qnm . M ; k ++ ) { m . plusOne ( k + 1 ) ; BigRational toAdd = qnm . getDemandAsBigRational ( k , r ) . multiply ( new BigRational ( m . get ( k ) - 1 ) ) ; toAdd = toAdd . multiply ( recallG ( m , p ) ) ; curG = curG . add ( toAdd ) ; m . restore ( ) ; } curG = curG . divide ( new BigRational ( nr ) ) ; p . restore ( ) ; } } else { continue ; } storeG ( m , p , curG , curMap ) ; } Ntot -- ; Gmap . clear ( ) ; Gmap = curMap ; if ( firstVisit ) { secondVisit = true ; firstVisit = false ; } else { if ( secondVisit ) { secondVisit = false ; totalTimer . pause ( ) ; memUsage = MiscFunctions . memoryUsage ( ) ; totalTimer . start ( ) ; } } } } return recallG ( finalm , finalp ) ; }
tr	5	public static int [ ] getSwimTimes ( int [ ] distances , int [ ] speeds , int current ) { int [ ] times = new int [ speeds . length ] ; for ( int i = 0 ; i < speeds . length ; i ++ ) { double vGo = speeds [ i ] + current ; double vBack = speeds [ i ] - current ; double tGo = 0 ; double tBack = 0 ; if ( vGo > 0 && vBack > 0 ) { tGo = distances [ i ] / vGo ; tBack = distances [ i ] / vBack ; times [ i ] = ( int ) ( tGo + tBack ) ; } else if ( distances [ i ] == 0 ) { times [ i ] = 0 ; } else if ( vBack <= 0 ) { times [ i ] = - 1 ; } } return times ; }
tr	0	@ JsonProperty ( "WaitingJobs" ) public void setWaitingJobs ( long WaitingJobs ) { this . WaitingJobs = WaitingJobs ; }
tr	5	public static void main ( String [ ] args ) throws Exception { System . out . println ( "***************************************************" ) ; System . out . println ( "  Using Hybrid MapReduce 3D Convex Hull Algorithm  " ) ; System . out . println ( "***************************************************" ) ; int count = 0 ; long CurrentCount = - 3 ; long PreviousCount = - 6 ; boolean FastPass = false ; String TempDir1 = "/input" ; String TempDir2 = "/QH" ; while ( CurrentCount != PreviousCount ) { count ++ ; PreviousCount = CurrentCount ; System . out . println ( "***************************************************" ) ; System . out . println ( "Hybird MapReduce 3D Convex Hull Iteration >> " + count ) ; System . out . println ( "***************************************************" ) ; JobConf conf7 = new JobConf ( ) ; conf7 . setInt ( "n.lines.records.token" , 100 ) ; conf7 . setNumTasksToExecutePerJvm ( - 1 ) ; Job job7 = new Job ( conf7 , "QH" ) ; job7 . setJarByClass ( HMR3DConvexHull . class ) ; job7 . setMapperClass ( QHMapper . class ) ; job7 . setInputFormatClass ( NLinesInputFormat . class ) ; job7 . setReducerClass ( QHReducer . class ) ; job7 . setMapOutputKeyClass ( Text . class ) ; job7 . setMapOutputValueClass ( Text . class ) ; FileInputFormat . addInputPath ( job7 , new Path ( TempDir1 ) ) ; FileOutputFormat . setOutputPath ( job7 , new Path ( TempDir2 ) ) ; job7 . waitForCompletion ( true ) ; if ( count != 1 ) { FileSystem fs = FileSystem . get ( new Configuration ( ) ) ; fs . delete ( new Path ( "hdfs://192.168.0.206:9000" + TempDir1 + "/" ) , true ) ; } TempDir1 = TempDir2 ; TempDir2 = "/QH" + "-" + count ; org . apache . hadoop . mapreduce . Counters counters = job7 . getCounters ( ) ; long OutputRec = counters . findCounter ( "org.apache.hadoop.mapred.Task$Counter" , "REDUCE_OUTPUT_RECORDS" ) . getValue ( ) ; CurrentCount = OutputRec ; if ( ( OutputRec <= 10000000 ) && ( OutputRec != 0 ) ) { FastPass = true ; break ; } } if ( FastPass == true ) { JobConf conf8 = new JobConf ( ) ; conf8 . setInt ( "n.lines.records.token" , 1 ) ; conf8 . setNumTasksToExecutePerJvm ( - 1 ) ; Job job8 = new Job ( conf8 , "FinalQH" ) ; job8 . setJarByClass ( HMR3DConvexHull . class ) ; job8 . setMapperClass ( FinalQHMapper . class ) ; job8 . setInputFormatClass ( NLinesInputFormat . class ) ; job8 . setReducerClass ( FinalQHReducer . class ) ; job8 . setMapOutputKeyClass ( Text . class ) ; job8 . setMapOutputValueClass ( Text . class ) ; FileInputFormat . addInputPath ( job8 , new Path ( TempDir1 ) ) ; FileOutputFormat . setOutputPath ( job8 , new Path ( "/Convex-Hull-Faces" ) ) ; job8 . waitForCompletion ( true ) ; } else { System . out . println ( "Sorry !!! The data set is too big !!! Try to increase the threshold." ) ; } }
tr	8	public Explosion ( Level level , Vector2f position , final float distance , final float force ) { this . level = level ; this . position = position ; this . distance = distance / 30 ; this . force = force * 5 ; final Vec2 posit2 = new Vec2 ( position . x / 30f , position . y / 30f ) ; Vec2 lowerVertex = new Vec2 ( posit2 . x - distance , posit2 . y - distance ) ; Vec2 upperVertex = new Vec2 ( posit2 . x + distance , posit2 . y + distance ) ; AABB aabb = new AABB ( lowerVertex , upperVertex ) ; QueryCallback callback = new QueryCallback ( ) { @ Override public boolean reportFixture ( Fixture arg0 ) { Vec2 fixturePosition = arg0 . m_body . getWorldCenter ( ) ; float dx = fixturePosition . x - posit2 . x ; float dy = fixturePosition . y - posit2 . y ; float pr = 0.2f ; if ( dx < pr && dx > 0 ) dx = pr ; if ( dy < pr && dy > 0 ) dy = pr ; if ( dx > - pr && dx < 0 ) dx = - pr ; if ( dy > - pr && dy < 0 ) dy = - pr ; Vec2 forceVec = new Vec2 ( distance / dx , distance / dy ) ; arg0 . m_body . applyForce ( forceVec . mul ( force ) , fixturePosition ) ; return true ; } } ; level . getWorld ( ) . queryAABB ( callback , aabb ) ; }
tr	5	public static String toString ( float [ ] a , NumberFormat nf ) { if ( a == null ) return null ; if ( a . length == 0 ) return "[]" ; StringBuilder b = new StringBuilder ( ) ; b . append ( "[" ) ; for ( int i = 0 ; i < a . length - 1 ; i ++ ) { String s ; if ( nf == null ) { s = String . valueOf ( a [ i ] ) ; } else { s = nf . format ( a [ i ] ) ; } b . append ( s ) ; b . append ( "  " ) ; } String s ; if ( nf == null ) { s = String . valueOf ( a [ a . length - 1 ] ) ; } else { s = nf . format ( a [ a . length - 1 ] ) ; } b . append ( s ) ; b . append ( ] ) ; return b . toString ( ) ; }
tr	4	protected int countT ( Geometry s ) { int n = transparencyOf ( s ) == 0 ? 0 : 1 ; if ( s . child != null ) for ( int i = 0 ; i < s . child . length && s . child [ i ] != null ; i ++ ) n += countT ( s . child [ i ] ) ; return n ; }
tr	7	private String expresion ( Nodo chk ) { String tem = new String ( ) ; Iterator e = chk . getNodo ( ) . iterator ( ) ; switch ( chk . getToken ( ) ) { case Suma : tem += this . expresion ( ( ( Nodo ) e . next ( ) ) ) ; tem += this . expresion ( ( ( Nodo ) e . next ( ) ) ) ; tem += "\nadi" ; break ; case Resta : tem += this . expresion ( ( ( Nodo ) e . next ( ) ) ) ; tem += this . expresion ( ( ( Nodo ) e . next ( ) ) ) ; tem += "\nsbi" ; break ; case Division : tem += this . expresion ( ( ( Nodo ) e . next ( ) ) ) ; tem += this . expresion ( ( ( Nodo ) e . next ( ) ) ) ; tem += "\ndvi" ; break ; case Multiplicacion : tem += this . expresion ( ( ( Nodo ) e . next ( ) ) ) ; tem += this . expresion ( ( ( Nodo ) e . next ( ) ) ) ; tem += "\nmpi" ; break ; case Numero : if ( chk . getTipoDato ( ) . equals ( "int" ) ) { tem += "\nldc " + chk . getValorNumInt ( ) ; } else { tem += "\nldc " + chk . getValorNumFloat ( ) ; } break ; case Identificador : tem += "\nlod " + chk . getDato ( ) ; break ; } return tem ; }
tr	6	protected final Object computeRange ( ) { final List < double [ ] > raRange = new ArrayList < double [ ] > ( ) ; final double [ ] decRange = new double [ 2 ] ; if ( this . isPolesCollision ( ) ) { decRange [ MIN ] = SimpleSpectralAccessProtocolLibrary . MIN_VALUE_FOR_DECLINATION ; decRange [ MAX ] = SimpleSpectralAccessProtocolLibrary . MAX_VALUE_FOR_DECLINATION ; raRange . add ( new double [ ] { SimpleSpectralAccessProtocolLibrary . MIN_VALUE_FOR_RIGHT_ASCENSION , SimpleSpectralAccessProtocolLibrary . MAX_VALUE_FOR_RIGHT_ASCENSION } ) ; } else if ( this . isNorthPoleCollision ( ) ) { decRange [ MIN ] = decUser - sizeArray [ 1 ] / 2.0 ; decRange [ MAX ] = SimpleSpectralAccessProtocolLibrary . MAX_VALUE_FOR_DECLINATION ; raRange . add ( new double [ ] { SimpleSpectralAccessProtocolLibrary . MIN_VALUE_FOR_RIGHT_ASCENSION , SimpleSpectralAccessProtocolLibrary . MAX_VALUE_FOR_RIGHT_ASCENSION } ) ; } else if ( this . isSouthPoleCollision ( ) ) { decRange [ MIN ] = SimpleSpectralAccessProtocolLibrary . MIN_VALUE_FOR_DECLINATION ; decRange [ MAX ] = decUser + sizeArray [ 1 ] / 2.0 ; raRange . add ( new double [ ] { SimpleSpectralAccessProtocolLibrary . MIN_VALUE_FOR_RIGHT_ASCENSION , SimpleSpectralAccessProtocolLibrary . MAX_VALUE_FOR_RIGHT_ASCENSION } ) ; } else { decRange [ MIN ] = decUser - sizeArray [ 1 ] / 2.0 ; decRange [ MAX ] = decUser + sizeArray [ 1 ] / 2.0 ; if ( this . isBorderRaCollision ( ) ) { raRange . add ( new double [ ] { SimpleSpectralAccessProtocolLibrary . MIN_VALUE_FOR_RIGHT_ASCENSION , SimpleSpectralAccessProtocolLibrary . MAX_VALUE_FOR_RIGHT_ASCENSION } ) ; } else if ( this . isMaxRaCollision ( ) ) { raRange . add ( new double [ ] { raUser - sizeArray [ 0 ] / 2.0 , SimpleSpectralAccessProtocolLibrary . MAX_VALUE_FOR_RIGHT_ASCENSION } ) ; raRange . add ( new double [ ] { SimpleSpectralAccessProtocolLibrary . MIN_VALUE_FOR_RIGHT_ASCENSION , ( raUser + sizeArray [ 0 ] / 2.0 + SimpleSpectralAccessProtocolLibrary . MAX_VALUE_FOR_RIGHT_ASCENSION ) % SimpleSpectralAccessProtocolLibrary . MAX_VALUE_FOR_RIGHT_ASCENSION } ) ; } else if ( this . isMinRaCollision ( ) ) { raRange . add ( new double [ ] { SimpleSpectralAccessProtocolLibrary . MIN_VALUE_FOR_RIGHT_ASCENSION , raUser + sizeArray [ 0 ] / 2.0 } ) ; raRange . add ( new double [ ] { ( raUser - sizeArray [ 0 ] / 2.0 + SimpleSpectralAccessProtocolLibrary . MAX_VALUE_FOR_RIGHT_ASCENSION ) % SimpleSpectralAccessProtocolLibrary . MAX_VALUE_FOR_RIGHT_ASCENSION , SimpleSpectralAccessProtocolLibrary . MAX_VALUE_FOR_RIGHT_ASCENSION } ) ; } else { raRange . add ( new double [ ] { ( raUser - sizeArray [ 0 ] / 2.0 + SimpleSpectralAccessProtocolLibrary . MAX_VALUE_FOR_RIGHT_ASCENSION ) % SimpleSpectralAccessProtocolLibrary . MAX_VALUE_FOR_RIGHT_ASCENSION , ( raUser + sizeArray [ 0 ] / 2.0 + SimpleSpectralAccessProtocolLibrary . MAX_VALUE_FOR_RIGHT_ASCENSION ) % SimpleSpectralAccessProtocolLibrary . MAX_VALUE_FOR_RIGHT_ASCENSION } ) ; } } return Arrays . asList ( raRange , decRange ) ; }
tr	0	public StudentInfo getStdInfo ( ) { return stdInfo ; }
tr	9	public static void arraycopy ( final ObjectLargeArray src , final long srcPos , final ObjectLargeArray dest , final long destPos , final long length ) { if ( srcPos < 0 || srcPos >= src . length ( ) ) { throw new ArrayIndexOutOfBoundsException ( "srcPos < 0 || srcPos >= src.length()" ) ; } if ( destPos < 0 || destPos >= dest . length ( ) ) { throw new ArrayIndexOutOfBoundsException ( "destPos < 0 || destPos >= dest.length()" ) ; } if ( length < 0 ) { throw new IllegalArgumentException ( "length < 0" ) ; } if ( dest . isConstant ( ) ) { throw new IllegalArgumentException ( "Constant arrays cannot be modified." ) ; } int nthreads = ( int ) Math . min ( length , Runtime . getRuntime ( ) . availableProcessors ( ) ) ; if ( nthreads < 2 || length < 100000 ) { for ( long i = srcPos , j = destPos ; i < srcPos + length ; i ++ , j ++ ) { dest . set ( j , src . get ( i ) ) ; } } else { long k = length / nthreads ; Thread [ ] threads = new Thread [ nthreads ] ; for ( int j = 0 ; j < nthreads ; j ++ ) { final long firstIdx = j * k ; final long lastIdx = ( j == nthreads - 1 ) ? length : firstIdx + k ; threads [ j ] = new Thread ( new Runnable ( ) { @ Override public void run ( ) { for ( long k = firstIdx ; k < lastIdx ; k ++ ) { dest . set ( destPos + k , src . get ( srcPos + k ) ) ; } } } ) ; threads [ j ] . start ( ) ; } try { for ( int j = 0 ; j < nthreads ; j ++ ) { threads [ j ] . join ( ) ; threads [ j ] = null ; } } catch ( InterruptedException ex ) { for ( long i = srcPos , j = destPos ; i < srcPos + length ; i ++ , j ++ ) { dest . set ( j , src . get ( i ) ) ; } } } }
tr	0	static public String nowAsString ( ) { return formatDate ( TIME_FORMAT , new Date ( ) ) ; }
tr	3	private static boolean hasAccess ( IGraph g , IGraph access ) { for ( int i = 0 ; i < g . size ( ) ; i ++ ) { for ( int j = 0 ; j < access . size ( ) ; j ++ ) { String a = g . get ( i ) . getName ( ) ; String b = access . get ( j ) . getName ( ) ; if ( a . equals ( b ) ) return true ; } } return false ; }
tr	4	public void read ( org . apache . thrift . protocol . TProtocol iprot , inserir_result struct ) throws org . apache . thrift . TException { org . apache . thrift . protocol . TField schemeField ; iprot . readStructBegin ( ) ; while ( true ) { schemeField = iprot . readFieldBegin ( ) ; if ( schemeField . type == org . apache . thrift . protocol . TType . STOP ) { break ; } switch ( schemeField . id ) { case 0 : if ( schemeField . type == org . apache . thrift . protocol . TType . STRUCT ) { struct . success = new Registro ( ) ; struct . success . read ( iprot ) ; struct . setSuccessIsSet ( true ) ; } else { org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } break ; default : org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } iprot . readFieldEnd ( ) ; } iprot . readStructEnd ( ) ; struct . validate ( ) ; }
tr	4	public static String [ ] mergeStringArrays ( String [ ] array1 , String [ ] array2 ) { if ( ObjectUtils . isEmpty ( array1 ) ) { return array2 ; } if ( ObjectUtils . isEmpty ( array2 ) ) { return array1 ; } List < String > result = new ArrayList < String > ( ) ; result . addAll ( Arrays . asList ( array1 ) ) ; for ( String str : array2 ) { if ( ! result . contains ( str ) ) { result . add ( str ) ; } } return toStringArray ( result ) ; }
tr	4	private void select ( ) { if ( currentChoice == 0 ) { world . displayGui ( null ) ; } else if ( currentChoice == 1 ) { saveGame ( ) ; showMessageSaved = true ; alpha = 1.0F ; } else if ( currentChoice == 2 ) { saveGame ( ) ; world . gsm . setState ( GameStateManager . MENUSTATE ) ; } else if ( currentChoice == 3 ) { saveGame ( ) ; System . exit ( 0 ) ; } }
tr	8	@ Override protected void paintContentBorder ( Graphics g , int tabPlacement , int selectedIndex ) { int width = tabPane . getWidth ( ) ; int height = tabPane . getHeight ( ) ; Insets insets = tabPane . getInsets ( ) ; int x = insets . left ; int y = insets . top ; int w = width - insets . right - insets . left ; int h = height - insets . top - insets . bottom ; switch ( tabPlacement ) { case LEFT : x += calculateTabAreaWidth ( tabPlacement , runCount , maxTabWidth ) ; x -= tabAreaInsets . right ; w -= ( x - insets . left ) ; break ; case RIGHT : w -= calculateTabAreaWidth ( tabPlacement , runCount , maxTabWidth ) ; w += tabAreaInsets . left ; break ; case BOTTOM : h -= calculateTabAreaHeight ( tabPlacement , runCount , maxTabHeight ) ; h += tabAreaInsets . top ; break ; case TOP : default : y += calculateTabAreaHeight ( tabPlacement , runCount , maxTabHeight ) ; y -= tabAreaInsets . bottom ; h -= ( y - insets . top ) ; } if ( tabPane . getTabCount ( ) > 0 ) { Color color = UIManager . getColor ( "TabbedPane.contentAreaColor" ) ; if ( color != null ) { g . setColor ( color ) ; } else if ( colorContentBorder == null || selectedIndex == - 1 ) { g . setColor ( tabPane . getBackground ( ) ) ; } else { g . setColor ( colorContentBorder ) ; } g . fillRect ( x , y , w , h ) ; } }
tr	6	public static String escape ( String string ) { StringBuffer sb = new StringBuffer ( ) ; for ( int i = 0 , length = string . length ( ) ; i < length ; i ++ ) { char c = string . charAt ( i ) ; switch ( c ) { case & : sb . append ( "&amp;" ) ; break ; case < : sb . append ( "&lt;" ) ; break ; case > : sb . append ( "&gt;" ) ; break ; case " : sb . append ( "&quot;" ) ; break ; case ' : sb . append ( "&apos;" ) ; break ; default : sb . append ( c ) ; } } return sb . toString ( ) ; }
tr	9	protected void tallennaActionPerformed ( ) { if ( kayttajatunnus . getOppilas ( ) != null ) { String etunimi = etunimiField . getText ( ) . trim ( ) ; String sukunimi = sukunimiField . getText ( ) . trim ( ) ; Ryhma ryhma = ( Ryhma ) ryhmaComboBox . getModel ( ) . getSelectedItem ( ) ; if ( "" . equals ( etunimi ) ) { JOptionPane . showMessageDialog ( this , "Etunimi ei voi olla tyhj\u00E4." , "Virhe" , JOptionPane . ERROR_MESSAGE ) ; return ; } if ( etunimi . length ( ) > 20 ) { JOptionPane . showMessageDialog ( this , "Etunimi ei voi olla yli 20 merkki\u00E4 pitk\u00E4." , "Virhe" , JOptionPane . ERROR_MESSAGE ) ; return ; } if ( "" . equals ( sukunimi ) ) { JOptionPane . showMessageDialog ( this , "Sukunimi ei voi olla tyhj\u00E4." , "Virhe" , JOptionPane . ERROR_MESSAGE ) ; return ; } if ( sukunimi . length ( ) > 30 ) { JOptionPane . showMessageDialog ( this , "Sukunimi ei voi olla yli 30 merkki\u00E4 pitk\u00E4." , "Virhe" , JOptionPane . ERROR_MESSAGE ) ; return ; } if ( ryhma == null ) { JOptionPane . showMessageDialog ( this , "Oppilaalla pit\u00E4\u00E4 olla ryhm\u00E4." , "Virhe" , JOptionPane . ERROR_MESSAGE ) ; return ; } Oppilas o = kayttajatunnus . getOppilas ( ) ; o . setEtunimi ( etunimi ) ; o . setSukunimi ( sukunimi ) ; o . setRyhma ( ryhma ) ; } String kayttajanimi = kayttajatunnusField . getText ( ) . trim ( ) ; String salasana = salasanaField . getText ( ) . trim ( ) ; if ( "" . equals ( kayttajanimi ) ) { JOptionPane . showMessageDialog ( this , "K\u00E4ytt\u00E4j\u00E4nimi ei voi olla tyhj\u00E4." , "Virhe" , JOptionPane . ERROR_MESSAGE ) ; return ; } if ( kayttajanimi . length ( ) > 15 ) { JOptionPane . showMessageDialog ( this , "K\u00E4ytt\u00E4j\u00E4nimi ei voi olla yli 15 merkki\u00E4 pitk\u00E4." , "Virhe" , JOptionPane . ERROR_MESSAGE ) ; return ; } if ( "" . equals ( salasana ) ) { JOptionPane . showMessageDialog ( this , "Salasana ei voi olla tyhj\u00E4." , "Virhe" , JOptionPane . ERROR_MESSAGE ) ; return ; } if ( salasana . length ( ) > 30 ) { JOptionPane . showMessageDialog ( this , "Salasana ei voi olla yli 30 merkki\u00E4 pitk\u00E4." , "Virhe" , JOptionPane . ERROR_MESSAGE ) ; return ; } kayttajatunnus . setKayttajanimi ( kayttajanimi ) ; kayttajatunnus . setSalasana ( salasana ) ; boolean onnistui = Database . updateKayttajatunnus ( kayttajatunnus ) ; if ( onnistui ) { JOptionPane . showMessageDialog ( this , "Tietojen p\u00E4ivitys onnistui" ) ; paaikkuna . edellinenPaneeli ( ) ; } else { JOptionPane . showMessageDialog ( this , "Tietojen p\u00E4ivitys ep\u00E4onnistui" ) ; } }
tr	3	@ Override public void dispose ( ) { for ( ObjectMap < String , Object > entry : data . values ( ) ) { for ( Object resource : entry . values ( ) ) { if ( resource instanceof Disposable ) ( ( Disposable ) resource ) . dispose ( ) ; } } }
tr	3	private void tbServeMuKeyTyped ( java . awt . event . KeyEvent evt ) { char c = evt . getKeyChar ( ) ; if ( ! ( Character . isDigit ( c ) || ( c == KeyEvent . VK_BACK_SPACE ) || ( c == KeyEvent . VK_DELETE ) ) ) { evt . consume ( ) ; } }
tr	9	public boolean isValid ( String s ) { Stack < Character > stack = new Stack < Character > ( ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { char curChar = s . charAt ( i ) ; switch ( curChar ) { case ) : if ( stack . isEmpty ( ) || stack . pop ( ) != ( ) { return false ; } break ; case ] : if ( stack . isEmpty ( ) || stack . pop ( ) != [ ) { return false ; } break ; case } : if ( stack . isEmpty ( ) || stack . pop ( ) != { ) { return false ; } break ; default : stack . push ( curChar ) ; } } return stack . isEmpty ( ) ; }
tr	1	public static Singleton1 getInstance ( ) { if ( uniqueInstance == null ) { uniqueInstance = new Singleton1 ( ) ; } return uniqueInstance ; }
tr	7	public static void main ( String [ ] args ) { boolean all_right ; all_right = true ; String [ ] p0 ; int p1 ; int p2 ; p0 = new String [ ] { "kenta" , "kentaro" , "ken" } ; p1 = 2 ; p2 = 3 ; all_right = KawigiEdit_RunTest ( 0 , p0 , p1 , true , p2 ) && all_right ; p0 = new String [ ] { "hideo" , "hideto" , "hideki" , "hide" } ; p1 = 2 ; p2 = 6 ; all_right = KawigiEdit_RunTest ( 1 , p0 , p1 , true , p2 ) && all_right ; p0 = new String [ ] { "aya" , "saku" , "emi" , "ayane" , "sakura" , "emika" , "sakurako" } ; p1 = 3 ; p2 = 24 ; all_right = KawigiEdit_RunTest ( 2 , p0 , p1 , true , p2 ) && all_right ; p0 = new String [ ] { "taro" , "jiro" , "hanako" } ; p1 = 2 ; p2 = 0 ; all_right = KawigiEdit_RunTest ( 3 , p0 , p1 , true , p2 ) && all_right ; p0 = new String [ ] { "alice" , "bob" , "charlie" } ; p1 = 1 ; p2 = 6 ; all_right = KawigiEdit_RunTest ( 4 , p0 , p1 , true , p2 ) && all_right ; p0 = new String [ ] { "ryota" , "ryohei" , "ryotaro" , "ryo" , "ryoga" , "ryoma" , "ryoko" , "ryosuke" , "ciel" , "lun" , "ryuta" , "ryuji" , "ryuma" , "ryujiro" , "ryusuke" , "ryutaro" , "ryu" , "ryuhei" , "ryuichi" , "evima" } ; p1 = 3 ; p2 = 276818566 ; all_right = KawigiEdit_RunTest ( 5 , p0 , p1 , true , p2 ) && all_right ; if ( all_right ) { System . out . println ( "You're a stud (at least on the example cases)!" ) ; } else { System . out . println ( "Some of the test cases had errors." ) ; } }
tr	6	protected List < String > getData ( ) { List < String > dataFields = new LinkedList < String > ( ) ; StringBuilder dataBuff = new StringBuilder ( ) ; char c = nextChar ( ) ; while ( c == [ ) { char prev = contents . charAt ( index ) ; c = nextChar ( ) ; while ( ( c != ] || ( c == ] && prev == \ ) ) && index < contents . length ( ) ) { dataBuff . append ( c ) ; prev = c ; c = nextChar ( ) ; } String buffValue = dataBuff . toString ( ) ; if ( buffValue . length ( ) != 0 ) { dataFields . add ( buffValue ) ; dataBuff = new StringBuilder ( ) ; } c = nextChar ( ) ; } pushChar ( ) ; return dataFields ; }
tr	9	public class findClass ( String className ) { final class aClass = handleGenaratedClass ( className ) ; if ( aClass != null ) { return aClass ; } byte classByte [ ] ; class result = null ; result = ( class ) classes . get ( className ) ; if ( result != null ) { return result ; } try { return findSystemClass ( className ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } try { if ( jarFiles . size ( ) > 0 ) { for ( LibraryEntity jarFile : jarFiles ) { final String [ ] libNames = jarFile . getLibNames ( ) ; for ( String libName : libNames ) { JarFile jar = new JarFile ( ApplicationSettings . getInstance ( ) . getLibraryBasePath ( ) + libName ) ; final Enumeration < JarEntry > entries = jar . entries ( ) ; while ( entries . hasMoreElements ( ) ) { JarEntry element = entries . nextElement ( ) ; final String accClassName = element . getName ( ) . replaceAll ( "/" , "." ) ; if ( ( className + ".class" ) . equals ( accClassName ) ) { InputStream is = jar . getInputStream ( element ) ; ByteArrayOutputStream byteStream = new ByteArrayOutputStream ( ) ; int nextValue = is . read ( ) ; while ( - 1 != nextValue ) { byteStream . write ( nextValue ) ; nextValue = is . read ( ) ; } classByte = byteStream . toByteArray ( ) ; result = defineClass ( className , classByte , 0 , classByte . length , null ) ; classes . put ( className , result ) ; return result ; } } } } } } catch ( Exception e ) { e . printStackTrace ( ) ; } return null ; }
tr	6	private void matchFieldStateChanged ( javax . swing . event . ChangeEvent evt ) { int value = Integer . parseInt ( matchField . getValue ( ) . toString ( ) ) ; int totalValue = Integer . parseInt ( numberOfMatchesField . getValue ( ) . toString ( ) ) ; if ( value <= 0 ) { matchField . setValue ( 1 ) ; } if ( value > totalValue ) { matchField . setValue ( totalValue ) ; } try { if ( Competition . getThisMatchHasData ( value ) ) { for ( int i = 0 ; i < 6 ; i ++ ) { teamArray [ i ] . setText ( String . valueOf ( Competition . getMatchTeamNumbers ( value , i ) ) ) ; } } else { for ( int i = 0 ; i < 6 ; i ++ ) { teamArray [ i ] . setText ( "" ) ; } } } catch ( NullPointerException ex ) { } saveMatchesButton . setEnabled ( areFieldsFull ( ) ) ; }
tr	1	public SubjectID addSubject ( String organization , String id ) { Contributor contributor = Contributor . findContributor ( organization ) ; SubjectID sid = null ; if ( contributor != null ) { sid = this . addSubject ( contributor , id ) ; } else { logger . warn ( "Unknown contributor: " + organization ) ; } return sid ; }
tr	6	public void doSample ( File baseFreqFile , File sampleFreqDir , File sizeFile , File outFile , double rate , byte mode ) throws IOException { TreeMap < String , Integer > sizes = this . readSizeFile ( sizeFile ) ; SampleComposition composition = null ; if ( mode == RANDOM_SAMPLE ) { composition = new RandomSampleComposition ( ) ; } else if ( mode == GREEDY_SAMPLE ) { composition = new GreedySampleComposition ( ) ; } else { } MLEDistribution mleBase = new MLEDistribution ( ) ; mleBase . readFreqFile ( baseFreqFile ) ; File [ ] samples = sampleFreqDir . listFiles ( new FileFilter ( ) { @ Override public boolean accept ( File pathname ) { return pathname . getName ( ) . endsWith ( "-freq.txt.zip" ) ; } } ) ; for ( File sample : samples ) { String name = sample . getName ( ) . substring ( 0 , sample . getName ( ) . indexOf ( ".gz" ) ) ; if ( sizes . containsKey ( name ) ) { MLEDistribution sampleDist = new MLEDistribution ( ) ; sampleDist . readFreqFile ( sample ) ; int sampleSize = sizes . get ( name ) ; composition . addSample ( name , sampleDist , sampleSize ) ; } else { System . err . println ( "Size for file " + name + " not known!" ) ; } } int maxSize = ( int ) ( rate * sizes . get ( "base" ) ) ; System . out . println ( "Sampling using " + ( mode == RANDOM_SAMPLE ? "RANDOM" : "GREEDY" ) + " mode and maxsize of" + maxSize ) ; Set < String > selection = composition . composeSample ( mleBase , maxSize ) ; PrintStream out = new PrintStream ( outFile ) ; for ( String selected : selection ) { out . println ( selected ) ; } out . close ( ) ; }
tr	7	private void toggleRemoveSelection ( TreePath path ) { Stack stack = new Stack ( ) ; TreePath parent = path . getParentPath ( ) ; while ( parent != null && ! isPathSelected ( parent ) ) { stack . push ( parent ) ; parent = parent . getParentPath ( ) ; } if ( parent != null ) { stack . push ( parent ) ; } else { super . removeSelectionPaths ( new TreePath [ ] { path } ) ; return ; } while ( ! stack . isEmpty ( ) ) { TreePath temp = ( TreePath ) stack . pop ( ) ; TreePath peekPath = stack . isEmpty ( ) ? path : ( TreePath ) stack . peek ( ) ; Object node = temp . getLastPathComponent ( ) ; Object peekNode = peekPath . getLastPathComponent ( ) ; int childCount = model . getChildCount ( node ) ; for ( int i = 0 ; i < childCount ; i ++ ) { Object childNode = model . getChild ( node , i ) ; if ( childNode != peekNode ) { super . addSelectionPaths ( new TreePath [ ] { temp . pathByAddingChild ( childNode ) } ) ; } } } super . removeSelectionPaths ( new TreePath [ ] { parent } ) ; }
tr	4	private void start ( ) { boolean portFailed = false ; int port = - 1 ; try { port = Integer . parseInt ( tfPort . getText ( ) ) ; if ( port < 0 || port > 49151 ) { portFailed = true ; } } catch ( NumberFormatException ex ) { portFailed = true ; } if ( portFailed ) { JOptionPane . showMessageDialog ( this , "Illegal port number" , "Error" , JOptionPane . ERROR_MESSAGE ) ; return ; } int maxClients = ( int ) cbMaxClients . getSelectedItem ( ) ; config = new ServerStartupConfig ( ) ; config . port = port ; config . maxClients = maxClients ; dispose ( ) ; }
tr	7	@ Override public void paint ( Graphics g ) { if ( tower . isInFog ( ) ) { if ( getTower ( ) instanceof DefTower ) g . drawImage ( defFog , x , y , null ) ; else if ( getTower ( ) instanceof DmgTower ) g . drawImage ( dmgFog , x , y , null ) ; else if ( getTower ( ) instanceof SpdTower ) g . drawImage ( spdFog , x , y , null ) ; } else { if ( getTower ( ) instanceof DefTower ) g . drawImage ( defImage , x , y , null ) ; else if ( getTower ( ) instanceof DmgTower ) g . drawImage ( dmgImage , x , y , null ) ; else if ( getTower ( ) instanceof SpdTower ) g . drawImage ( spdImage , x , y , null ) ; } }
tr	5	@ SuppressWarnings ( "unchecked" ) private void initComponents ( ) { jScrollPane = new javax . swing . JScrollPane ( ) ; DefaultMutableTreeNode top = new DefaultMutableTreeNode ( "HelpDesk" ) ; createNodes ( top ) ; tree = new javax . swing . JTree ( top ) ; ExitButton = new javax . swing . JButton ( ) ; ReplyButton = new javax . swing . JButton ( ) ; htmlView = new javax . swing . JScrollPane ( ) ; htmlPane = new javax . swing . JEditorPane ( ) ; viewScheduleButton = new javax . swing . JButton ( ) ; setAssistantsButton = new javax . swing . JButton ( ) ; controlFormsButton = new javax . swing . JButton ( ) ; accessScheduleButton = new javax . swing . JButton ( ) ; accessFormsButton = new javax . swing . JButton ( ) ; PostButton = new javax . swing . JButton ( ) ; setDefaultCloseOperation ( javax . swing . WindowConstants . EXIT_ON_CLOSE ) ; tree . getSelectionModel ( ) . setSelectionMode ( TreeSelectionModel . SINGLE_TREE_SELECTION ) ; tree . addTreeSelectionListener ( this ) ; jScrollPane . setViewportView ( tree ) ; ExitButton . setText ( "Sign Off" ) ; ExitButton . addActionListener ( new java . awt . event . ActionListener ( ) { public void actionPerformed ( java . awt . event . ActionEvent evt ) { ExitButtonActionPerformed ( evt ) ; } } ) ; ReplyButton . setText ( "Reply" ) ; ReplyButton . addActionListener ( new java . awt . event . ActionListener ( ) { public void actionPerformed ( java . awt . event . ActionEvent evt ) { ReplyButtonActionPerformed ( evt ) ; } } ) ; htmlPane . setEditable ( false ) ; initHelp ( ) ; htmlPane . setCursor ( new java . awt . Cursor ( java . awt . Cursor . TEXT_CURSOR ) ) ; htmlView . setViewportView ( htmlPane ) ; if ( userType == 3 ) { } else { viewScheduleButton . setVisible ( false ) ; } viewScheduleButton . setText ( "Schedule Control" ) ; viewScheduleButton . addActionListener ( new java . awt . event . ActionListener ( ) { public void actionPerformed ( java . awt . event . ActionEvent evt ) { viewScheduleButtonActionPerformed ( evt ) ; } } ) ; if ( userType == 3 ) { } else { setAssistantsButton . setVisible ( false ) ; } setAssistantsButton . setText ( "Set Assistants" ) ; setAssistantsButton . addActionListener ( new java . awt . event . ActionListener ( ) { public void actionPerformed ( java . awt . event . ActionEvent evt ) { setAssistantsButtonActionPerformed ( evt ) ; } } ) ; if ( userType == 2 ) { } else { controlFormsButton . setVisible ( false ) ; } controlFormsButton . setText ( "Forms" ) ; controlFormsButton . addActionListener ( new java . awt . event . ActionListener ( ) { public void actionPerformed ( java . awt . event . ActionEvent evt ) { controlFormsButtonActionPerformed ( evt ) ; } } ) ; if ( userType == 2 ) { } else { accessScheduleButton . setVisible ( false ) ; } accessScheduleButton . setText ( "My Schedule" ) ; accessScheduleButton . addActionListener ( new java . awt . event . ActionListener ( ) { public void actionPerformed ( java . awt . event . ActionEvent evt ) { accessScheduleButtonActionPerformed ( evt ) ; } } ) ; if ( userType == 1 ) { } else { accessFormsButton . setVisible ( false ) ; } accessFormsButton . setText ( "My Forms" ) ; accessFormsButton . addActionListener ( new java . awt . event . ActionListener ( ) { public void actionPerformed ( java . awt . event . ActionEvent evt ) { accessFormsButtonActionPerformed ( evt ) ; } } ) ; PostButton . setText ( "Post" ) ; PostButton . addActionListener ( new java . awt . event . ActionListener ( ) { public void actionPerformed ( java . awt . event . ActionEvent evt ) { PostButtonActionPerformed ( evt ) ; } } ) ; javax . swing . GroupLayout layout = new javax . swing . GroupLayout ( getContentPane ( ) ) ; getContentPane ( ) . setLayout ( layout ) ; layout . setHorizontalGroup ( layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( layout . createSequentialGroup ( ) . addContainerGap ( ) . addGroup ( layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( layout . createSequentialGroup ( ) . addGap ( 0 , 0 , short . MAX_VALUE ) . addComponent ( PostButton ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . UNRELATED ) . addComponent ( ReplyButton ) ) . addComponent ( htmlView ) . addComponent ( jScrollPane ) ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addGroup ( layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( layout . createSequentialGroup ( ) . addComponent ( ExitButton ) . addGap ( 42 , 42 , 42 ) ) . addGroup ( javax . swing . GroupLayout . Alignment . TRAILING , layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addComponent ( accessFormsButton ) . addComponent ( accessScheduleButton ) . addComponent ( controlFormsButton ) . addComponent ( setAssistantsButton ) . addComponent ( viewScheduleButton ) ) ) . addGap ( 22 , 22 , 22 ) ) ) ; layout . setVerticalGroup ( layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( layout . createSequentialGroup ( ) . addContainerGap ( ) . addGroup ( layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( layout . createSequentialGroup ( ) . addComponent ( jScrollPane , javax . swing . GroupLayout . PREFERRED_SIZE , 149 , javax . swing . GroupLayout . PREFERRED_SIZE ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addComponent ( htmlView , javax . swing . GroupLayout . DEFAULT_SIZE , 331 , short . MAX_VALUE ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addGroup ( layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . BASELINE ) . addComponent ( ReplyButton ) . addComponent ( PostButton ) ) . addGap ( 77 , 77 , 77 ) ) . addGroup ( layout . createSequentialGroup ( ) . addComponent ( ExitButton ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addComponent ( accessFormsButton ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addComponent ( accessScheduleButton ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addComponent ( controlFormsButton ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addComponent ( setAssistantsButton ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addComponent ( viewScheduleButton ) . addContainerGap ( 424 , short . MAX_VALUE ) ) ) ) ) ; pack ( ) ; }
tr	0	@ Override public String toString ( ) { return getName ( ) ; }
tr	4	@ Override public boolean parseField ( String name , String value ) { if ( super . parseField ( name , value ) ) { return true ; } if ( name != null && value != null ) { StorageFieldHandler handler = EnumUtils . lookup ( StorageFieldHandler . class , name ) ; if ( handler != null ) { return handler . handle ( device , value ) ; } else { return false ; } } return false ; }
tr	8	public void render ( Map map ) { if ( updateSenses ) { long startTime = System . currentTimeMillis ( ) ; playerSenses = map . getPlayerSenses ( ) ; long endTime = System . currentTimeMillis ( ) ; Log . print ( "Shadowcasting time: " + ( endTime - startTime ) ) ; updateSenses = false ; } HashMap < Integer , Tile > tileHashMap = playerSenses . getTiles ( ) ; HashMap < Integer , Actor > actorHashMap = playerSenses . getActors ( ) ; HashMap < Integer , ArrayList < Entity >> entities = playerSenses . getEntities ( ) ; Point top_left = new Point ( playerpos . getX ( ) - tilesx , playerpos . getY ( ) - tilesy ) ; for ( int x = top_left . getX ( ) ; x <= playerpos . getX ( ) + tilesx ; x ++ ) { for ( int y = top_left . getY ( ) ; y <= playerpos . getY ( ) + tilesy ; y ++ ) { if ( map . inBounds ( x , y ) ) { Tile tile = tileHashMap . get ( map . genKey ( x , y ) ) ; if ( tile != null ) { Image image = environment . getSprite ( tile . getSpriteID ( ) ) ; image . draw ( ( float ) ( ( x - top_left . getX ( ) ) * ppt ) , ( float ) ( ( y - top_left . getY ( ) ) * ppt ) , scale ) ; } ArrayList < Entity > ents = entities . get ( map . genKey ( x , y ) ) ; if ( ents != null && ents . size ( ) > 0 ) { Entity entity = ents . get ( 0 ) ; Image image = environment . getSprite ( entity . getSpriteID ( ) ) ; image . draw ( ( float ) ( ( x - top_left . getX ( ) ) * ppt ) , ( float ) ( ( y - top_left . getY ( ) ) * ppt ) , scale ) ; } Actor actor = actorHashMap . get ( map . genKey ( x , y ) ) ; if ( actor != null ) { Image image = actor_sprites . getSprite ( actor . getSpriteID ( ) ) ; image . draw ( ( float ) ( ( x - top_left . getX ( ) ) * ppt ) , ( float ) ( ( y - top_left . getY ( ) ) * ppt ) , scale ) ; } } } } Image player = actor_sprites . getSprite ( ActorSprite . player ) ; player . draw ( ( float ) ( ( playerpos . getX ( ) - top_left . getX ( ) ) * ppt ) , ( float ) ( ( playerpos . getY ( ) - top_left . getY ( ) ) * ppt ) , scale ) ; messageBox . render ( ) ; }
tr	6	@ Subscribe public void handle ( Event ev ) { boolean sortedOut = false ; if ( ev instanceof AbstractTickEvent ) { sortedOut = true ; } else if ( ev instanceof InputEvent ) { InputEvent e = ( InputEvent ) ev ; if ( e . isMouseMovedEvent ( ) || e . isMouseDraggedEvent ( ) ) { sortedOut = true ; } } else if ( ev instanceof UnitEvent ) { sortedOut = true ; } if ( ! sortedOut ) { System . out . println ( "# " + ev . toString ( ) ) ; } }
tr	4	public static int [ ] swap ( int [ ] a , int i , int j ) { if ( i < 0 || j < 0 || i > a . length || j > a . length ) { throw new IllegalArgumentException ( "Illegal argument!" ) ; } else { int temp = a [ i ] ; a [ i ] = a [ j ] ; a [ j ] = temp ; } System . out . println ( "swap : " + QuickSort . toString ( a ) ) ; return a ; }
tr	7	public RegisterFrame ( ServerManager theServer , String theUrl , int thePort , int theListenPort ) { super ( "Registrar Usuario" ) ; controller = new RegisterController ( theServer , theUrl , thePort ) ; server = theServer ; url = theUrl ; port = thePort ; listenPort = theListenPort ; addWindowListener ( new WindowAdapter ( ) { @ Override public void windowClosing ( WindowEvent e ) { createLoginFrame ( ) ; } } ) ; setBounds ( 100 , 100 , 661 , 403 ) ; contentPane = new JPanel ( ) ; contentPane . setBackground ( Color . WHITE ) ; contentPane . setBorder ( new EmptyBorder ( 5 , 5 , 5 , 5 ) ) ; setContentPane ( contentPane ) ; contentPane . setLayout ( new BorderLayout ( 0 , 10 ) ) ; JLabel lblRegistrarUsuario = new JLabel ( "Registrar Usuario" ) ; lblRegistrarUsuario . setFont ( new Font ( "Tahoma" , Font . BOLD , 18 ) ) ; lblRegistrarUsuario . setHorizontalAlignment ( SwingConstants . CENTER ) ; contentPane . add ( lblRegistrarUsuario , BorderLayout . NORTH ) ; JPanel panelBotton = new JPanel ( ) ; panelBotton . setBackground ( Color . WHITE ) ; contentPane . add ( panelBotton , BorderLayout . SOUTH ) ; panelBotton . setLayout ( new FlowLayout ( FlowLayout . RIGHT , 5 , 5 ) ) ; JButton btnRegister = new JButton ( "Registrarse" ) ; btnRegister . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent arg0 ) { try { controller . register ( usernameTxt . getText ( ) , new String ( passwordTxt . getPassword ( ) ) , new String ( rePasswordTxt . getPassword ( ) ) , firstNameTxt . getText ( ) , lastNameTxt . getText ( ) , emailTxt . getText ( ) ) ; JOptionPane . showMessageDialog ( null , "Registro exitoso!  ahora podra usar el servicio de chat" , "Registro exitoso" , JOptionPane . INFORMATION_MESSAGE ) ; createLoginFrame ( ) ; } catch ( RegisterException e ) { JOptionPane . showMessageDialog ( null , e . getMessage ( ) , "Error" , JOptionPane . ERROR_MESSAGE ) ; } } } ) ; btnRegister . setIcon ( new ImageIcon ( RegisterFrame . class . getResource ( "/chat/client/view/resources/registerIcon.png" ) ) ) ; panelBotton . add ( btnRegister ) ; JButton btnCancel = new JButton ( "Cancelar" ) ; btnCancel . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { createLoginFrame ( ) ; } } ) ; panelBotton . add ( btnCancel ) ; JPanel panel = new JPanel ( ) ; contentPane . add ( panel , BorderLayout . CENTER ) ; panel . setLayout ( new GridLayout ( 0 , 2 , 0 , 0 ) ) ; ImagePanel imagePanel = new ImagePanel ( Toolkit . getDefaultToolkit ( ) . getImage ( RegisterFrame . class . getResource ( "/chat/client/view/resources/ico2.jpg" ) ) ) ; panel . add ( imagePanel ) ; JPanel panel_1 = new JPanel ( ) ; panel_1 . setBackground ( Color . WHITE ) ; panel . add ( panel_1 ) ; GridBagLayout gbl_panel_1 = new GridBagLayout ( ) ; gbl_panel_1 . columnWidths = new int [ ] { 0 , 150 , 10 } ; gbl_panel_1 . rowHeights = new int [ ] { 0 , 0 , 0 , 0 , 0 , 0 , 20 } ; gbl_panel_1 . columnWeights = new double [ ] { 0.0 , 1.0 , 0.0 } ; gbl_panel_1 . rowWeights = new double [ ] { 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 } ; panel_1 . setLayout ( gbl_panel_1 ) ; JLabel label = new JLabel ( "Nombre de Usuario:" ) ; label . setFont ( new Font ( "Tahoma" , Font . PLAIN , 12 ) ) ; GridBagConstraints gbc_label = new GridBagConstraints ( ) ; gbc_label . anchor = GridBagConstraints . EAST ; gbc_label . insets = new Insets ( 0 , 0 , 5 , 5 ) ; gbc_label . gridx = 0 ; gbc_label . gridy = 0 ; panel_1 . add ( label , gbc_label ) ; usernameTxt = new JTextField ( ) ; usernameTxt . addFocusListener ( new FocusAdapter ( ) { @ Override public void focusLost ( FocusEvent e ) { if ( ! controller . isValidUsername ( usernameTxt . getText ( ) ) ) { lblUserNameError . setText ( "*" ) ; lblError . setText ( "El nombre de usuario es invalido" ) ; } else { lblUserNameError . setText ( "" ) ; lblError . setText ( "" ) ; } } } ) ; usernameTxt . setFont ( new Font ( "Tahoma" , Font . PLAIN , 12 ) ) ; usernameTxt . setColumns ( 20 ) ; GridBagConstraints gbc_usernameTxt = new GridBagConstraints ( ) ; gbc_usernameTxt . fill = GridBagConstraints . HORIZONTAL ; gbc_usernameTxt . insets = new Insets ( 0 , 0 , 5 , 5 ) ; gbc_usernameTxt . gridx = 1 ; gbc_usernameTxt . gridy = 0 ; panel_1 . add ( usernameTxt , gbc_usernameTxt ) ; lblUserNameError = new JLabel ( "" ) ; lblUserNameError . setForeground ( Color . RED ) ; GridBagConstraints gbc_lblUserNameError = new GridBagConstraints ( ) ; gbc_lblUserNameError . insets = new Insets ( 0 , 0 , 5 , 0 ) ; gbc_lblUserNameError . gridx = 2 ; gbc_lblUserNameError . gridy = 0 ; panel_1 . add ( lblUserNameError , gbc_lblUserNameError ) ; JLabel label_1 = new JLabel ( "Contrase\u00F1a:" ) ; label_1 . setFont ( new Font ( "Tahoma" , Font . PLAIN , 12 ) ) ; GridBagConstraints gbc_label_1 = new GridBagConstraints ( ) ; gbc_label_1 . anchor = GridBagConstraints . EAST ; gbc_label_1 . insets = new Insets ( 0 , 0 , 5 , 5 ) ; gbc_label_1 . gridx = 0 ; gbc_label_1 . gridy = 1 ; panel_1 . add ( label_1 , gbc_label_1 ) ; passwordTxt = new JPasswordField ( ) ; passwordTxt . addFocusListener ( new FocusAdapter ( ) { @ Override public void focusLost ( FocusEvent arg0 ) { if ( ! controller . isValidPassword ( new String ( passwordTxt . getPassword ( ) ) ) ) { lblPasswordError . setText ( "*" ) ; lblError . setText ( "La contrase\uFFFDa es invalida" ) ; } else { lblPasswordError . setText ( "" ) ; lblError . setText ( "" ) ; } } } ) ; passwordTxt . setColumns ( 20 ) ; passwordTxt . setFont ( new Font ( "Tahoma" , Font . PLAIN , 12 ) ) ; GridBagConstraints gbc_passwordTxt = new GridBagConstraints ( ) ; gbc_passwordTxt . fill = GridBagConstraints . HORIZONTAL ; gbc_passwordTxt . insets = new Insets ( 0 , 0 , 5 , 5 ) ; gbc_passwordTxt . gridx = 1 ; gbc_passwordTxt . gridy = 1 ; panel_1 . add ( passwordTxt , gbc_passwordTxt ) ; lblPasswordError = new JLabel ( "" ) ; lblPasswordError . setForeground ( Color . RED ) ; GridBagConstraints gbc_lblPasswordError = new GridBagConstraints ( ) ; gbc_lblPasswordError . insets = new Insets ( 0 , 0 , 5 , 0 ) ; gbc_lblPasswordError . gridx = 2 ; gbc_lblPasswordError . gridy = 1 ; panel_1 . add ( lblPasswordError , gbc_lblPasswordError ) ; JLabel label_2 = new JLabel ( "Repetir contrase\u00F1a:" ) ; label_2 . setFont ( new Font ( "Tahoma" , Font . PLAIN , 12 ) ) ; GridBagConstraints gbc_label_2 = new GridBagConstraints ( ) ; gbc_label_2 . anchor = GridBagConstraints . EAST ; gbc_label_2 . insets = new Insets ( 0 , 0 , 5 , 5 ) ; gbc_label_2 . gridx = 0 ; gbc_label_2 . gridy = 2 ; panel_1 . add ( label_2 , gbc_label_2 ) ; rePasswordTxt = new JPasswordField ( ) ; rePasswordTxt . addFocusListener ( new FocusAdapter ( ) { @ Override public void focusLost ( FocusEvent e ) { if ( ! controller . isRePasswordEqualToPassword ( new String ( passwordTxt . getPassword ( ) ) , new String ( rePasswordTxt . getPassword ( ) ) ) ) { lblRepasswordError . setText ( "*" ) ; lblError . setText ( "La contrase\uFFFDa es invalida" ) ; } else { lblRepasswordError . setText ( "" ) ; lblError . setText ( "" ) ; } } } ) ; rePasswordTxt . setColumns ( 20 ) ; rePasswordTxt . setFont ( new Font ( "Tahoma" , Font . PLAIN , 12 ) ) ; GridBagConstraints gbc_rePasswordTxt = new GridBagConstraints ( ) ; gbc_rePasswordTxt . fill = GridBagConstraints . HORIZONTAL ; gbc_rePasswordTxt . insets = new Insets ( 0 , 0 , 5 , 5 ) ; gbc_rePasswordTxt . gridx = 1 ; gbc_rePasswordTxt . gridy = 2 ; panel_1 . add ( rePasswordTxt , gbc_rePasswordTxt ) ; lblRepasswordError = new JLabel ( "" ) ; lblRepasswordError . setForeground ( Color . RED ) ; GridBagConstraints gbc_lblRepasswordError = new GridBagConstraints ( ) ; gbc_lblRepasswordError . insets = new Insets ( 0 , 0 , 5 , 0 ) ; gbc_lblRepasswordError . gridx = 2 ; gbc_lblRepasswordError . gridy = 2 ; panel_1 . add ( lblRepasswordError , gbc_lblRepasswordError ) ; JLabel label_3 = new JLabel ( "Nombre(s):" ) ; label_3 . setFont ( new Font ( "Tahoma" , Font . PLAIN , 12 ) ) ; GridBagConstraints gbc_label_3 = new GridBagConstraints ( ) ; gbc_label_3 . anchor = GridBagConstraints . EAST ; gbc_label_3 . insets = new Insets ( 0 , 0 , 5 , 5 ) ; gbc_label_3 . gridx = 0 ; gbc_label_3 . gridy = 3 ; panel_1 . add ( label_3 , gbc_label_3 ) ; firstNameTxt = new JTextField ( ) ; firstNameTxt . addFocusListener ( new FocusAdapter ( ) { @ Override public void focusLost ( FocusEvent e ) { if ( ! controller . isValidFirstName ( firstNameTxt . getText ( ) ) ) { lblFirstNameError . setText ( "*" ) ; lblError . setText ( "El nombre de usuario es invalido" ) ; } else { lblFirstNameError . setText ( "" ) ; lblError . setText ( "" ) ; } } } ) ; firstNameTxt . setFont ( new Font ( "Tahoma" , Font . PLAIN , 12 ) ) ; firstNameTxt . setColumns ( 30 ) ; GridBagConstraints gbc_firstNameTxt = new GridBagConstraints ( ) ; gbc_firstNameTxt . fill = GridBagConstraints . HORIZONTAL ; gbc_firstNameTxt . insets = new Insets ( 0 , 0 , 5 , 5 ) ; gbc_firstNameTxt . gridx = 1 ; gbc_firstNameTxt . gridy = 3 ; panel_1 . add ( firstNameTxt , gbc_firstNameTxt ) ; lblFirstNameError = new JLabel ( "" ) ; lblFirstNameError . setForeground ( Color . RED ) ; GridBagConstraints gbc_lblFirstNameError = new GridBagConstraints ( ) ; gbc_lblFirstNameError . insets = new Insets ( 0 , 0 , 5 , 0 ) ; gbc_lblFirstNameError . gridx = 2 ; gbc_lblFirstNameError . gridy = 3 ; panel_1 . add ( lblFirstNameError , gbc_lblFirstNameError ) ; JLabel label_4 = new JLabel ( "Apellido(s):" ) ; label_4 . setFont ( new Font ( "Tahoma" , Font . PLAIN , 12 ) ) ; GridBagConstraints gbc_label_4 = new GridBagConstraints ( ) ; gbc_label_4 . anchor = GridBagConstraints . EAST ; gbc_label_4 . insets = new Insets ( 0 , 0 , 5 , 5 ) ; gbc_label_4 . gridx = 0 ; gbc_label_4 . gridy = 4 ; panel_1 . add ( label_4 , gbc_label_4 ) ; lastNameTxt = new JTextField ( ) ; lastNameTxt . addFocusListener ( new FocusAdapter ( ) { @ Override public void focusLost ( FocusEvent e ) { if ( ! controller . isValidLastName ( lastNameTxt . getText ( ) ) ) { lblLastNameError . setText ( "*" ) ; lblError . setText ( "El nombre de usuario es invalido" ) ; } else { lblLastNameError . setText ( "" ) ; lblError . setText ( "" ) ; } } } ) ; lastNameTxt . setFont ( new Font ( "Tahoma" , Font . PLAIN , 12 ) ) ; lastNameTxt . setColumns ( 30 ) ; GridBagConstraints gbc_lastNameTxt = new GridBagConstraints ( ) ; gbc_lastNameTxt . fill = GridBagConstraints . HORIZONTAL ; gbc_lastNameTxt . insets = new Insets ( 0 , 0 , 5 , 5 ) ; gbc_lastNameTxt . gridx = 1 ; gbc_lastNameTxt . gridy = 4 ; panel_1 . add ( lastNameTxt , gbc_lastNameTxt ) ; lblLastNameError = new JLabel ( "" ) ; lblLastNameError . setForeground ( Color . RED ) ; GridBagConstraints gbc_lblLastNameError = new GridBagConstraints ( ) ; gbc_lblLastNameError . insets = new Insets ( 0 , 0 , 5 , 0 ) ; gbc_lblLastNameError . gridx = 2 ; gbc_lblLastNameError . gridy = 4 ; panel_1 . add ( lblLastNameError , gbc_lblLastNameError ) ; JLabel label_5 = new JLabel ( "E-mail:" ) ; label_5 . setFont ( new Font ( "Tahoma" , Font . PLAIN , 12 ) ) ; GridBagConstraints gbc_label_5 = new GridBagConstraints ( ) ; gbc_label_5 . anchor = GridBagConstraints . EAST ; gbc_label_5 . insets = new Insets ( 0 , 0 , 5 , 5 ) ; gbc_label_5 . gridx = 0 ; gbc_label_5 . gridy = 5 ; panel_1 . add ( label_5 , gbc_label_5 ) ; emailTxt = new JTextField ( ) ; emailTxt . addFocusListener ( new FocusAdapter ( ) { @ Override public void focusLost ( FocusEvent e ) { if ( ! controller . isValidEmail ( emailTxt . getText ( ) ) ) { lblEmailError . setText ( "*" ) ; lblError . setText ( "El nombre de usuario es invalido" ) ; } else { lblEmailError . setText ( "" ) ; lblError . setText ( "" ) ; } } } ) ; emailTxt . setFont ( new Font ( "Tahoma" , Font . PLAIN , 12 ) ) ; emailTxt . setColumns ( 50 ) ; GridBagConstraints gbc_emailTxt = new GridBagConstraints ( ) ; gbc_emailTxt . insets = new Insets ( 0 , 0 , 5 , 5 ) ; gbc_emailTxt . fill = GridBagConstraints . HORIZONTAL ; gbc_emailTxt . gridx = 1 ; gbc_emailTxt . gridy = 5 ; panel_1 . add ( emailTxt , gbc_emailTxt ) ; lblEmailError = new JLabel ( "" ) ; lblEmailError . setForeground ( Color . RED ) ; GridBagConstraints gbc_lblEmailError = new GridBagConstraints ( ) ; gbc_lblEmailError . insets = new Insets ( 0 , 0 , 5 , 0 ) ; gbc_lblEmailError . gridx = 2 ; gbc_lblEmailError . gridy = 5 ; panel_1 . add ( lblEmailError , gbc_lblEmailError ) ; lblError = new JLabel ( "" ) ; lblError . setForeground ( Color . RED ) ; GridBagConstraints gbc_lblError = new GridBagConstraints ( ) ; gbc_lblError . gridwidth = 3 ; gbc_lblError . insets = new Insets ( 0 , 0 , 0 , 5 ) ; gbc_lblError . gridx = 0 ; gbc_lblError . gridy = 6 ; panel_1 . add ( lblError , gbc_lblError ) ; }
tr	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( FishMainFrame . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( FishMainFrame . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( FishMainFrame . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( FishMainFrame . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { @ Override public void run ( ) { ClientController client = new ClientController ( ) ; new FishMainFrame ( ) . setVisible ( true ) ; } } ) ; }
tr	5	public void movePhoto ( ) { if ( newAlbumName != null && ! newAlbumName . equals ( "" ) ) { int code = this . control . movePhoto ( this . photo . getFilename ( ) , this . album , this . newAlbumName ) ; if ( code == - 1 ) { final JFrame error = new JFrame ( "Important Message!" ) ; JOptionPane . showMessageDialog ( error , "Photo Already in that album." ) ; } else if ( code == 1 ) { final JFrame error = new JFrame ( "Important Message!" ) ; JOptionPane . showMessageDialog ( error , "Photo Correctly Moved." ) ; this . movePopUp . setVisible ( false ) ; try { this . photosScreen . reDrawPhotos ( ) ; } catch ( Exception e1 ) { e1 . printStackTrace ( ) ; } } } else { final JFrame error = new JFrame ( "Important Message!" ) ; JOptionPane . showMessageDialog ( error , "No Album Selected." ) ; } }
tr	7	public static void ast ( IGraph g ) { int i , ipre = 0 , pre , prepre ; IGraph node ; if ( g . size ( ) == 0 ) return ; for ( i = 0 ; i < g . size ( ) ; i ++ ) ast ( g . get ( i ) ) ; while ( true ) { prepre = 0 ; for ( i = 0 ; i < g . size ( ) ; i ++ ) { node = g . get ( i ) ; String name = node . getName ( ) ; pre = _precedence ( name ) ; if ( node . getNode ( "__dirty" ) != null ) pre = 0 ; if ( pre > prepre ) { prepre = pre ; ipre = i ; } } if ( prepre > 0 ) { node = g . get ( ipre ) ; node . addNode ( "__dirty" ) ; node . add ( g . get ( ipre - 1 ) ) ; node . add ( g . get ( ipre + 1 ) ) ; g . remove ( ipre - 1 ) ; g . remove ( ipre ) ; } else break ; } }
tr	0	public ParserException ( String message ) { super ( message ) ; }
tr	7	public static void recoverTree ( TreeNode root ) { int preValue = Integer . MIN_VALUE ; int currentValue = Integer . MIN_VALUE ; Stack < TreeNode > stack = new Stack < TreeNode > ( ) ; TreeNode pre1 = null ; TreeNode pre2 = null ; TreeNode cur = root ; TreeNode preNode = null ; while ( cur != null || ! stack . isEmpty ( ) ) { while ( cur != null ) { stack . push ( cur ) ; cur = cur . left ; } cur = stack . pop ( ) ; System . out . println ( stack . size ( ) ) ; currentValue = cur . val ; if ( currentValue < preValue ) { if ( pre1 == null ) { pre1 = preNode ; pre2 = cur ; } else { pre2 = cur ; break ; } } preNode = cur ; preValue = currentValue ; cur = cur . right ; } if ( pre1 != null && pre2 != null ) { int temp = pre1 . val ; pre1 . val = pre2 . val ; pre2 . val = temp ; } }
tr	5	public TreeNode buildTree ( int [ ] inorder , int [ ] postorder ) { if ( inorder == null || postorder == null || inorder . length == 0 || postorder . length == 0 ) return null ; Map < Integer , Integer > map = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < inorder . length ; i ++ ) { map . put ( inorder [ i ] , i ) ; } return buildTreeHelper ( postorder , map , 0 , postorder . length , 0 ) ; }
tr	5	public int [ ] getIntArrayFileArgument ( String name , int start , int stop , boolean required ) { if ( M . containsKey ( name ) ) { String [ ] content = readFileContents ( M . get ( name ) ) ; if ( stop > content . length - 1 ) { if ( stop != Integer . MAX_VALUE ) { System . err . println ( "Warning requested array position does not exist" ) ; } stop = content . length - 1 ; } int [ ] res = new int [ ( stop - start ) + 1 ] ; for ( int i = start ; i <= stop ; i ++ ) { res [ i - start ] = Integer . parseInt ( content [ i ] ) ; } return res ; } else { if ( required ) { argumentMissing ( name ) ; } } return null ; }
tr	5	public static void main ( String Arg [ ] ) { int theMost = 0 ; for ( int p = 120 ; p < 1000 ; p ++ ) { int counter = 0 ; for ( int a = 1 ; a < p ; a ++ ) for ( int b = 1 ; b < a ; b ++ ) { int c = p - a - b ; if ( a * a + b * b == c * c ) counter ++ ; } if ( counter > theMost ) { theMost = counter ; System . out . println ( "p=" + p + " generates " + counter + " triangles" ) ; } } uptime ( ) ; }
tr	3	public static double getFloat ( Object o , float def ) { try { if ( o == null ) return def ; if ( o instanceof Number ) return ( ( Number ) o ) . floatValue ( ) ; } catch ( NumberFormatException e ) { } Log . w ( "Object cast error - cannot cast " + o + " to Float." ) ; return def ; }
tr	9	@ Override public void work ( ) { try { Vertex v = graph . getVertex ( source ) ; if ( v == null ) { print ( "Select a vertex" ) ; return ; } doFillVertex = true ; PairingHeap < Path > ph = new PairingHeap < Path > ( ) ; v . dist = 0 ; v . pos = ph . insert ( new Path ( v , v . dist ) ) ; int nodesSeen = 0 ; int nrSteps = 0 ; while ( ! ph . isEmpty ( ) && nodesSeen < graph . size ( ) ) { Path p = ph . deleteMin ( ) ; v = p . dest ; if ( v . visited ) { continue ; } v . visited = true ; nodesSeen ++ ; v . vColor = Color . RED ; for ( Edge e : v . adj ) { nrSteps ++ ; Vertex w = e . dest ; int uwv = e . cost ; if ( w . dist > uwv + v . dist ) { e . eColor = Color . RED ; w . dist = uwv + v . dist ; w . prev = v ; Path newPath = new Path ( w , w . dist ) ; if ( w . pos == null ) { ph . insert ( newPath ) ; } else { ph . decreaseKey ( w . pos , newPath ) ; } repaint ( ) ; sleep ( GUI_EXECUTION_PAUSE ) ; } } } gui . console ( "Path cost: " + graph . getVertex ( dest ) . dist ) ; gui . console ( "Steps: " + nrSteps ) ; graph . resetGraphColors ( ) ; List < Vertex > shortestPath = new ArrayList < Vertex > ( ) ; Vertex vv = graph . getVertex ( dest ) ; while ( vv != null ) { shortestPath . add ( vv ) ; vv = vv . prev ; } for ( int i = shortestPath . size ( ) - 1 ; i >= 0 ; i -- ) { shortestPath . get ( i ) . vColor = Color . RED ; for ( Edge e : shortestPath . get ( i ) . adj ) { if ( i - 1 >= 0 && e . dest . equals ( shortestPath . get ( i - 1 ) ) ) { e . eColor = Color . RED ; break ; } } repaint ( ) ; sleep ( GUI_EXECUTION_PAUSE ) ; } sleep ( GUI_RESULT_PAUSE ) ; clearAll ( ) ; repaint ( ) ; } catch ( Exception e ) { } }
tr	3	private static void doLoop ( IPreferenceStore store , int mode ) { Map values = new HashMap ( ) ; values . put ( PreferenceKeys . COLLAPSE_COMMENT_BLOCKS , COLLAPSE_COMMENT_BLOCKS ) ; values . put ( PreferenceKeys . FOLD_COMMENT_BLOCKS , FOLD_COMMENT_BLOCKS ) ; values . put ( PreferenceKeys . COLLAPSE_LINE_COMMENTS , COLLAPSE_LINE_COMMENTS ) ; values . put ( PreferenceKeys . FOLD_LINE_COMMENTS , FOLD_LINE_COMMENTS ) ; values . put ( PreferenceKeys . COLLAPSE_JAVADOCS , COLLAPSE_JAVADOCS ) ; values . put ( PreferenceKeys . FOLD_JAVADOCS , FOLD_JAVADOCS ) ; values . put ( PreferenceKeys . COLLAPSE_HEADER , COLLAPSE_HEADER ) ; values . put ( PreferenceKeys . FOLD_HEADER , FOLD_HEADER ) ; values . put ( PreferenceKeys . COLLAPSE_IMPORTS , COLLAPSE_IMPORTS ) ; values . put ( PreferenceKeys . FOLD_IMPORTS , FOLD_IMPORTS ) ; values . put ( PreferenceKeys . COLLAPSE_INNER_TYPES , COLLAPSE_INNER_TYPES ) ; values . put ( PreferenceKeys . FOLD_INNER_TYPES , FOLD_INNER_TYPES ) ; values . put ( PreferenceKeys . COLLAPSE_STATICS , COLLAPSE_STATICS ) ; values . put ( PreferenceKeys . FOLD_STATICS , FOLD_STATICS ) ; values . put ( PreferenceKeys . COLLAPSE_METHODS , COLLAPSE_METHODS ) ; values . put ( PreferenceKeys . FOLD_METHODS , FOLD_METHODS ) ; values . put ( PreferenceKeys . COLLAPSE_TOP_TYPES , COLLAPSE_TOP_TYPES ) ; values . put ( PreferenceKeys . FOLD_TOP_TYPES , FOLD_TOP_TYPES ) ; values . put ( PreferenceKeys . FOLD_MAIN_METHODS , FOLD_MAIN_METHODS ) ; values . put ( PreferenceKeys . COLLAPSE_MAIN_METHODS , COLLAPSE_MAIN_METHODS ) ; values . put ( PreferenceKeys . COLLAPSE_CONSTRUCTORS , COLLAPSE_CONSTRUCTORS ) ; values . put ( PreferenceKeys . FOLD_CONSTRUCTORS , FOLD_CONSTRUCTORS ) ; values . put ( PreferenceKeys . FOLD_USER_DEFINED , FOLD_USER_DEFINED ) ; values . put ( PreferenceKeys . COLLAPSE_USER_DEFINED , COLLAPSE_USER_DEFINED ) ; Iterator entries = values . entrySet ( ) . iterator ( ) ; while ( entries . hasNext ( ) ) { Map . Entry entry = ( Map . Entry ) entries . next ( ) ; String key = ( String ) entry . getKey ( ) ; boolean val = ( boolean ) entry . getValue ( ) ; if ( mode == RESTORE ) { store . setToDefault ( key ) ; } else { store . setDefault ( key , val . booleanValue ( ) ) ; } } if ( mode == RESTORE ) { store . setToDefault ( PreferenceKeys . MINIMUM_SIZE ) ; store . setToDefault ( PreferenceKeys . USER_DEFINED_START ) ; store . setToDefault ( PreferenceKeys . USER_DEFINED_END ) ; store . setToDefault ( PreferenceKeys . LAST_LINE_COMMENTS ) ; store . setToDefault ( PreferenceKeys . LAST_LINE_CONTROLS ) ; store . setToDefault ( PreferenceKeys . LAST_LINE_TYPES ) ; store . setToDefault ( PreferenceKeys . LAST_LINE_METHODS ) ; store . setToDefault ( PreferenceKeys . FOLDING_ICONS ) ; } else { store . setDefault ( PreferenceKeys . MINIMUM_SIZE , MINIMUM_SIZE ) ; store . setDefault ( PreferenceKeys . USER_DEFINED_START , USER_DEFINED_START ) ; store . setDefault ( PreferenceKeys . USER_DEFINED_END , USER_DEFINED_END ) ; store . setDefault ( PreferenceKeys . LAST_LINE_COMMENTS , LAST_LINE_COMMENT . booleanValue ( ) ) ; store . setDefault ( PreferenceKeys . LAST_LINE_CONTROLS , LAST_LINE_CONTROL . booleanValue ( ) ) ; store . setDefault ( PreferenceKeys . LAST_LINE_TYPES , LAST_LINE_TYPE . booleanValue ( ) ) ; store . setDefault ( PreferenceKeys . LAST_LINE_METHODS , LAST_LINE_METHOD . booleanValue ( ) ) ; store . setDefault ( PreferenceKeys . FOLDING_ICONS , FoldingPlugin . getMessage ( "default.icons.title" ) ) ; } }
tr	3	private void add ( char [ ] w , int wLen ) { if ( i + wLen >= b . length ) { char [ ] new_b = new char [ i + wLen + INC ] ; for ( int c = 0 ; c < i ; c ++ ) new_b [ c ] = b [ c ] ; b = new_b ; } for ( int c = 0 ; c < wLen ; c ++ ) b [ i ++ ] = w [ c ] ; }
tr	4	public void showMenu ( ) { int choice ; do { System . out . println ( ) ; System . out . println ( "ShowTimes Management" ) ; System . out . println ( "====================" ) ; System . out . println ( "1) List ShowTimes" ) ; System . out . println ( "2) Create ShowTimes" ) ; System . out . println ( "3) Manage ShowTimes" ) ; System . out . println ( "4) Back" ) ; System . out . print ( "Please enter your choice: " ) ; choice = ConsoleReader . readIntInput ( ) ; System . out . println ( ) ; switch ( choice ) { case 1 : listShowTimes ( ) ; System . out . println ( ) ; break ; case 2 : createShowTimes ( ) ; System . out . println ( ) ; break ; case 3 : manageShowTimes ( ) ; System . out . println ( ) ; break ; default : break ; } } while ( choice != 4 ) ; }
tr	3	@ Override public Object getAsObject ( FacesContext facesContext , UIComponent component , String value ) { if ( value == null || value . length ( ) == 0 || JsfUtil . isDummySelectItem ( component , value ) ) { return null ; } return this . ejbFacade . find ( getKey ( value ) ) ; }
tr	8	public boolean wordBreak2 ( String s , Set < String > dict ) { if ( s == null || s . length ( ) == 0 || dict == null ) { return true ; } int length = s . length ( ) ; boolean [ ] dp = new boolean [ length + 1 ] ; for ( boolean b : dp ) { b = false ; } dp [ length ] = true ; for ( int i = length - 1 ; i >= 0 ; i -- ) { for ( int j = i ; j < length ; j ++ ) { String - = s . substring ( i , j + 1 ) ; if ( dict . contains ( - ) == true && dp [ j + 1 ] == true ) { dp [ i ] = true ; break ; } } } return dp [ 0 ] ; }
tr	4	public ListNode partition ( ListNode head , int x ) { ListNode p1 = null , p2 = head , p2Prev = null ; while ( p2 != null ) { if ( p2 . val < x ) { if ( p1 == p2Prev ) { p1 = p2 ; p2 = p2 . next ; p2Prev = p1 ; } else { p2Prev . next = p2 . next ; if ( p1 == null ) { p2 . next = head ; head = p2 ; } else { p2 . next = p1 . next ; p1 . next = p2 ; } p1 = p2 ; p2 = p2Prev . next ; } } else { p2Prev = p2 ; p2 = p2 . next ; } } return head ; }
tr	6	private boolean isFormValid ( ) { boolean isFormValid = true ; if ( ! Validation . isStringNotEmpty ( this . timeSerieNameTextField . getText ( ) ) ) { isFormValid &= false ; this . markJTextFieldAsInvalid ( this . timeSerieNameTextField ) ; } else { this . markJTextFieldAsValid ( this . timeSerieNameTextField ) ; } if ( ! Validation . isValidDouble ( this . startXTextField . getText ( ) ) ) { isFormValid &= false ; this . markJTextFieldAsInvalid ( this . startXTextField ) ; } else { this . markJTextFieldAsValid ( this . startXTextField ) ; } if ( ! Validation . isValidDouble ( this . endXTextField . getText ( ) ) ) { isFormValid &= false ; this . markJTextFieldAsInvalid ( this . endXTextField ) ; } else { this . markJTextFieldAsValid ( this . endXTextField ) ; } if ( ! Validation . isValidDouble ( this . iterationStepTextField . getText ( ) ) ) { isFormValid &= false ; this . markJTextFieldAsInvalid ( this . iterationStepTextField ) ; } else { this . markJTextFieldAsValid ( this . iterationStepTextField ) ; } if ( this . useNoiseCheckBox . isSelected ( ) ) { if ( ! Validation . isValidDouble ( this . noiseTextField . getText ( ) ) ) { isFormValid &= false ; this . markJTextFieldAsInvalid ( this . noiseTextField ) ; } else { this . markJTextFieldAsValid ( this . noiseTextField ) ; } } else { this . markJTextFieldAsValid ( this . noiseTextField ) ; } return isFormValid ; }
tr	7	@ Override public V remove ( K key ) { if ( key == null ) { throw new IllegalArgumentException ( ) ; } int i ; for ( i = index ( key ) ; keys [ i ] != null && ! key . equals ( keys [ i ] ) ; i = ( i + 1 ) % keys . length ) ; if ( keys [ i ] == null ) { return null ; } V value = values [ i ] ; keys [ i ] = null ; values [ i ] = null ; -- size ; i = ( i + 1 ) % keys . length ; while ( keys [ i ] != null ) { K k = keys [ i ] ; V v = values [ i ] ; keys [ i ] = null ; values [ i ] = null ; -- size ; add ( k , v ) ; i = ( i + 1 ) % keys . length ; } if ( size <= keys . length / 8 && keys . length / 2 > size ) { resize ( keys . length / 2 ) ; } return value ; }
tr	8	public void method344 ( int i , int j , int k ) { for ( int i1 = 0 ; i1 < myPixels . length ; i1 ++ ) { int j1 = myPixels [ i1 ] ; if ( j1 != 0 ) { int k1 = j1 >> 16 & ff ; k1 += i ; if ( k1 < 1 ) k1 = 1 ; else if ( k1 > 255 ) k1 = 255 ; int l1 = j1 >> 8 & ff ; l1 += j ; if ( l1 < 1 ) l1 = 1 ; else if ( l1 > 255 ) l1 = 255 ; int i2 = j1 & ff ; i2 += k ; if ( i2 < 1 ) i2 = 1 ; else if ( i2 > 255 ) i2 = 255 ; myPixels [ i1 ] = ( k1 << 16 ) + ( l1 << 8 ) + i2 ; } } }
tr	4	public ToolTRow ( TransformationSequence ts ) { try { jbInit ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } this . ts = ts ; label . setText ( ts . name ) ; if ( FractalShapeMaker . toolsFrame != null && ts == FractalShapeMaker . toolsFrame . getCurrentTransform ( ) ) { label . setForeground ( Color . white ) ; setBackground ( Color . darkGray ) ; } if ( ts . color == null ) setColorButtonColor ( noColor ) ; else setColorButtonColor ( ts . color ) ; recurseButton . setSelected ( ts . recurse ) ; }
tr	8	static boolean isCongruent ( class < ? > [ ] params , Object [ ] args ) { boolean ret = false ; if ( args == null ) return params . length == 0 ; if ( params . length == args . length ) { ret = true ; for ( int i = 0 ; ret && i < params . length ; i ++ ) { Object arg = args [ i ] ; class < ? > argType = ( arg == null ) ? null : arg . getClass ( ) ; class < ? > paramType = params [ i ] ; ret = paramArgTypeMatch ( paramType , argType ) ; } } return ret ; }
tr	3	@ Test public void addPayment ( ) { testAddClaim ( ) ; Claim claim = instance . getClaim ( claims . get ( claims . size ( ) == 1 ? 0 : ( random . nextInt ( claims . size ( ) - 1 ) ) ) ) ; int id = instance . addPayment ( claim . getCustomerId ( ) , claim . getId ( ) , claim . getDamageCost ( ) , "Nordea: 235425 648" ) ; ArrayList < Payment > payments = instance . getPayments ( ) ; Payment payment = null ; for ( Payment p : payments ) { if ( p . getId ( ) == id ) { payment = p ; break ; } } assertFalse ( payment == null ) ; assertEquals ( payment . getId ( ) , id ) ; assertEquals ( ( int ) payment . getCustomerId ( ) , ( int ) claim . getCustomerId ( ) ) ; assertEquals ( payment . getClaimId ( ) , claim . getId ( ) ) ; assertEquals ( ( int ) payment . getAmount ( ) , ( int ) claim . getDamageCost ( ) ) ; }
tr	6	private void write ( SelectionKey key ) throws IOException { SocketChannel socketChannel = ( SocketChannel ) key . channel ( ) ; synchronized ( pendingData ) { BlockingQueue < ByteBuffer > queue = pendingData . get ( socketChannel ) ; while ( queue != null && ! queue . isEmpty ( ) ) { ByteBuffer buffer ; try { buffer = queue . take ( ) ; socketChannel . write ( buffer ) ; if ( buffer . remaining ( ) > 0 ) { break ; } } catch ( InterruptedException e ) { log . error ( "" , e ) ; } } if ( queue != null && queue . isEmpty ( ) ) { key . interestOps ( SelectionKey . OP_READ ) ; } } }
tr	8	@ Override public Vector3f [ ] getAllMaxAlongDirection ( Vector3f [ ] result , Vector3f dir , int count , float eps ) { if ( count > 0 ) { eps /= dir . length ( ) ; float dotmaxdir = vertices [ 0 ] . . ( dir ) ; result [ 0 ] . set ( vertices [ 0 ] ) ; int j = 1 ; for ( int i = vertices . length - 1 ; i > 0 ; i -- ) { final float dotshapedir = vertices [ i ] . . ( dir ) ; if ( dotshapedir >= dotmaxdir ) { if ( dotshapedir >= dotmaxdir + eps ) { result [ 0 ] . set ( vertices [ i ] ) ; j = 1 ; } else if ( j < count ) { result [ j ] . set ( vertices [ i ] ) ; j ++ ; } dotmaxdir = dotshapedir ; } else if ( j < count && dotshapedir + eps >= dotmaxdir ) { result [ j ] . set ( vertices [ i ] ) ; j ++ ; } } for ( ; j < count ; j ++ ) { result [ j ] . set ( 0 , 0 , 0 ) ; } } return result ; }
tr	1	public SimulatorView ( Simulator sim ) { super ( sim ) ; colors = new LinkedHashMap < class < ? > , Color > ( ) ; fieldView = new FieldView ( 100 , 100 ) ; }
tr	6	static void populate ( Game game , Vector < Floor > rooms , Random rnd ) { int orc_count = rnd . nextInt ( rooms . size ( ) * 4 ) ; int orc_added = 0 ; while ( orc_added != orc_count ) { place_item ( new Orc ( ) , null , game , rnd ) ; orc_added += 1 ; } int ogre_count = rnd . nextInt ( rooms . size ( ) / 2 ) ; int ogre_added = 0 ; while ( ogre_added != ogre_count ) { place_item ( new Ogre ( ) , null , game , rnd ) ; ogre_added += 1 ; } int key_count = count_locked_doors ( game . getMap ( ) ) ; int key_added = 0 ; while ( key_added != key_count ) { place_item ( new Key ( ) , null , game , rnd ) ; key_added += 1 ; } int gold_count = rnd . nextInt ( rooms . size ( ) * 2 ) ; int gold_added = 0 ; while ( gold_added != gold_count ) { int worth = 10 * ( 1 + rnd . nextInt ( 20 ) ) ; place_item ( new Gold ( worth ) , null , game , rnd ) ; gold_added += 1 ; } int potion_count = rnd . nextInt ( rooms . size ( ) * 2 ) ; int potion_added = 0 ; while ( potion_added != potion_count ) { int type = ( rnd . nextBoolean ( ) ? Potion . POTION_HEALTH : Potion . POTION_ENERGY ) ; place_item ( new Potion ( type ) , null , game , rnd ) ; potion_added += 1 ; } place_item ( new Hero ( ) , null , game , rnd ) ; }
