tr	4	private static boolean [ ] getComponentGapPush ( ArrayList < CompWrap > compWraps , boolean isHor ) { boolean [ ] barr = new boolean [ compWraps . size ( ) + 1 ] ; for ( int i = 0 ; i < barr . length ; i ++ ) { boolean push = i > 0 && compWraps . get ( i - 1 ) . isPushGap ( isHor , false ) ; if ( push == false && i < ( barr . length - 1 ) ) push = compWraps . get ( i ) . isPushGap ( isHor , true ) ; barr [ i ] = push ; } return barr ; }
tr	9	private String [ ] parseLine ( String nextLine ) throws IOException { if ( nextLine == null ) { return null ; } List tokensOnThisLine = new ArrayList ( ) ; StringBuffer sb = new StringBuffer ( ) ; boolean inQuotes = false ; do { if ( inQuotes ) { sb . append ( "\n" ) ; nextLine = getNextLine ( ) ; if ( nextLine == null ) break ; } for ( int i = 0 ; i < nextLine . length ( ) ; i ++ ) { char c = nextLine . charAt ( i ) ; if ( c == quotechar ) { if ( inQuotes && nextLine . length ( ) > ( i + 1 ) && nextLine . charAt ( i + 1 ) == quotechar ) { sb . append ( nextLine . charAt ( i + 1 ) ) ; i ++ ; } else { inQuotes = ! inQuotes ; if ( i > 2 && nextLine . charAt ( i - 1 ) != this . separator && nextLine . length ( ) > ( i + 1 ) && nextLine . charAt ( i + 1 ) != this . separator ) { sb . append ( c ) ; } } } else if ( c == separator && ! inQuotes ) { tokensOnThisLine . add ( sb . toString ( ) ) ; sb = new StringBuffer ( ) ; } else { sb . append ( c ) ; } } } while ( inQuotes ) ; tokensOnThisLine . add ( sb . toString ( ) ) ; return ( String [ ] ) tokensOnThisLine . toArray ( new String [ 0 ] ) ; }
tr	1	public int getCount ( ArrayList < FilterBean > hmFilter ) throws Exception { int pages ; try { oMysql . conexion ( enumTipoConexion ) ; pages = oMysql . getCount ( "hilo" , hmFilter ) ; oMysql . desconexion ( ) ; return pages ; } catch ( Exception e ) { throw new Exception ( "HiloDao.getCount: Error: " + e . getMessage ( ) ) ; } }
tr	3	protected void closeStreams ( ) throws IOException { if ( this . fileReader != null ) { this . fileReader . close ( ) ; this . fileReader = null ; } if ( this . outputFile != null ) { if ( this . outputWriter != null ) { this . outputWriter . close ( ) ; this . outputWriter = null ; } } }
tr	4	public static int checkDuplicatesBruteForce ( int [ ] a ) { int n = a . length ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { count ++ ; if ( a [ i ] == a [ j ] && i != j ) { System . out . println ( "No.of comparisons BruteForce" + count ) ; return a [ i ] ; } } } System . out . println ( "No.of comparisons BruteForce" + count ) ; return - 1 ; }
tr	3	public static void resetVersion ( ) { DataOutputStream dos = null ; try { File dir = new File ( getWorkingDirectory ( ) + File . separator + "bin" + File . separator ) ; File versionFile = new File ( dir , "version" ) ; dos = new DataOutputStream ( new FileOutputStream ( versionFile ) ) ; dos . writeUTF ( "0" ) ; dos . close ( ) ; } catch ( FileNotFoundException ex ) { Logger . getLogger ( Util . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( IOException ex ) { Logger . getLogger ( Util . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } finally { try { dos . close ( ) ; } catch ( IOException ex ) { Logger . getLogger ( Util . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } } }
tr	9	public static String getResultXMLString ( SimulationFinalResult result ) { if ( result == null ) { return "" ; } StringBuilder xml = new StringBuilder ( ) ; xml . append ( "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\" ?>" ) . append ( LINE_END ) . append ( "<simulation>" ) . append ( LINE_END ) . append ( getNestingCharacters ( 1 ) ) . append ( "<meta>" ) . append ( LINE_END ) . append ( getNestingCharacters ( 2 ) ) . append ( "<playercount>" ) . append ( result . getNrOfPlayers ( ) ) . append ( "</playercount>" ) . append ( LINE_END ) . append ( getNestingCharacters ( 2 ) ) . append ( "<rounds>" ) . append ( result . getRounds ( ) ) . append ( "</rounds>" ) . append ( LINE_END ) . append ( getNestingCharacters ( 2 ) ) . append ( "<type>" ) . append ( result . getPokerType ( ) . toString ( ) ) . append ( "</type>" ) . append ( LINE_END ) . append ( getNestingCharacters ( 2 ) ) . append ( "<threads>" ) . append ( result . getNrOfThreads ( ) ) . append ( "</threads>" ) . append ( LINE_END ) . append ( getNestingCharacters ( 2 ) ) . append ( "<duration unit=\"milliseconds\">" ) . append ( result . getDuration ( ) ) . append ( "</duration>" ) . append ( LINE_END ) . append ( getNestingCharacters ( 1 ) ) . append ( "</meta>" ) . append ( LINE_END ) . append ( getNestingCharacters ( 1 ) ) . append ( "<players>" ) . append ( LINE_END ) ; for ( int i = 1 ; i <= result . getNrOfPlayers ( ) ; i ++ ) { xml . append ( getNestingCharacters ( 2 ) ) . append ( "<player id=\"" ) . append ( i ) . append ( "\">" ) . append ( LINE_END ) . append ( getNestingCharacters ( 3 ) ) ; PlayerProfile profile = result . getPlayer ( i - 1 ) ; xml . append ( "<handtype>" ) ; xml . append ( profile . getHandType ( ) . toString ( ) ) ; xml . append ( "</handtype>" ) ; xml . append ( LINE_END ) ; if ( profile . getHandType ( ) == HandType . EXACTCARDS ) { Card [ ] cards = profile . getCards ( ) ; for ( Card card : cards ) { xml . append ( getNestingCharacters ( 3 ) ) . append ( "<card>" ) . append ( card . toString ( ) ) . append ( "</card>" ) . append ( LINE_END ) ; } } else if ( profile . getHandType ( ) == HandType . RANGE ) { Range range = profile . getRange ( ) ; for ( int row = 0 ; row < 13 ; row ++ ) { for ( int col = 0 ; col < 13 ; col ++ ) { if ( range . getValue ( row , col ) ) { xml . append ( getNestingCharacters ( 3 ) ) ; xml . append ( "<cardtype>" ) ; xml . append ( Range . rangeNames [ row ] [ col ] ) ; xml . append ( "</cardtype>" ) ; xml . append ( LINE_END ) ; } } } } xml . append ( getNestingCharacters ( 2 ) ) ; xml . append ( "</player>" ) ; xml . append ( LINE_END ) ; } xml . append ( getNestingCharacters ( 1 ) ) ; xml . append ( "</players>" ) ; xml . append ( LINE_END ) ; Card [ ] flop = result . getFlop ( ) ; Card turn = result . getTurn ( ) ; Card river = result . getRiver ( ) ; if ( flop != null || turn != null || river != null ) { xml . append ( getNestingCharacters ( 1 ) ) ; xml . append ( "<community>" ) ; xml . append ( LINE_END ) ; if ( flop != null ) { xml . append ( getNestingCharacters ( 2 ) ) . append ( "<flop id=\"1\">" ) . append ( flop [ 0 ] . toString ( ) ) . append ( "</flop>" ) . append ( LINE_END ) . append ( getNestingCharacters ( 2 ) ) . append ( "<flop id=\"2\">" ) . append ( flop [ 1 ] . toString ( ) ) . append ( "</flop>" ) . append ( LINE_END ) . append ( getNestingCharacters ( 2 ) ) . append ( "<flop id=\"3\">" ) . append ( flop [ 2 ] . toString ( ) ) . append ( "</flop>" ) . append ( LINE_END ) ; } if ( turn != null ) { xml . append ( getNestingCharacters ( 2 ) ) . append ( "<turn>" ) . append ( turn . toString ( ) ) . append ( "</turn>" ) . append ( LINE_END ) ; } if ( river != null ) { xml . append ( getNestingCharacters ( 2 ) ) . append ( "<river>" ) . append ( river . toString ( ) ) . append ( "</river>" ) . append ( LINE_END ) ; } xml . append ( getNestingCharacters ( 1 ) ) . append ( "</community>" ) . append ( LINE_END ) ; } xml . append ( getNestingCharacters ( 1 ) ) . append ( "<result>" ) . append ( LINE_END ) ; for ( int i = 1 ; i <= result . getNrOfPlayers ( ) ; i ++ ) { xml . append ( getNestingCharacters ( 2 ) ) . append ( "<player id=\"" ) . append ( i ) . append ( "\">" ) . append ( LINE_END ) . append ( getNestingCharacters ( 3 ) ) . append ( "<wins>" ) . append ( result . getFormattedWinPercentage ( i - 1 ) ) . append ( "</wins>" ) . append ( LINE_END ) . append ( getNestingCharacters ( 3 ) ) . append ( "<loses>" ) . append ( result . getFormattedLosePercentage ( i - 1 ) ) . append ( "</loses>" ) . append ( LINE_END ) . append ( getNestingCharacters ( 3 ) ) . append ( "<ties>" ) . append ( result . getFormattedTiePercentage ( i - 1 ) ) . append ( "</ties>" ) . append ( LINE_END ) . append ( getNestingCharacters ( 2 ) ) . append ( "</player>" ) . append ( LINE_END ) ; } xml . append ( getNestingCharacters ( 1 ) ) . append ( "</result>" ) . append ( LINE_END ) . append ( "</simulation>" ) ; return xml . toString ( ) ; }
tr	5	public HttpResponseStatus ( int code , String reasonPhrase ) { if ( code < 0 ) { throw new IllegalArgumentException ( "code: " + code + " (expected: 0+)" ) ; } if ( reasonPhrase == null ) { throw new NullPointerException ( "reasonPhrase" ) ; } for ( int i = 0 ; i < reasonPhrase . length ( ) ; i ++ ) { char c = reasonPhrase . charAt ( i ) ; switch ( c ) { case '' : case '' : throw new IllegalArgumentException ( "reasonPhrase contains one of the following prohibited characters: " + "\\r\\n: " + reasonPhrase ) ; } } this . code = code ; this . reasonPhrase = reasonPhrase ; }
tr	2	public synchronized void processSteps ( ) { if ( processing ) { return ; } try { processing = true ; while ( steps . size ( ) > 0 ) { processStepsGuarded ( ) ; } } finally { processing = false ; } }
tr	3	private void createTable ( ORMHash ht , ORMTable table ) throws SQLException { String createSQL = ht . createSQL ( ) ; String tableName = table . tableName ( ) ; int hashSize = ht . hashSize ( ) ; if ( hashSize < 1 ) { hashSize = 1 ; } List < String > alreadyExistTableList = dao . queryForSimpObjectList ( "show tables like '" + tableName + "%'" , new Object [ ] { } , String . class ) ; MessageFormat mf = new MessageFormat ( createSQL ) ; String hashTableName = null ; for ( int i = 0 ; i < hashSize ; i ++ ) { hashTableName = tableName + "_" + DBUtils . getInstance ( ) . hash ( i , hashSize ) ; if ( alreadyExistTableList . contains ( hashTableName ) ) { logger . trace ( "Hash Table[{}] is already exist!" , hashTableName ) ; } else { logger . info ( "Init hash table:{};" , hashTableName ) ; dao . update ( mf . format ( new Object [ ] { hashTableName } ) ) ; logger . info ( "Init hash table[{}] finish." , hashTableName ) ; } } }
tr	5	public Calendar getMaxDueDate ( ) { Calendar result = Calendar . getInstance ( ) ; Calendar max = null ; Calendar toCheck ; if ( tasks != null && tasks . size ( ) > 0 ) { for ( Task t : tasks ) { toCheck = t . getDueDate ( ) ; if ( max == null || toCheck . compareTo ( max ) > 0 ) { max = toCheck ; } } result . set ( Calendar . YEAR , max . get ( Calendar . YEAR ) ) ; result . set ( Calendar . MONTH , max . get ( Calendar . MONTH ) ) ; result . set ( Calendar . DAY_OF_MONTH , max . get ( Calendar . DAY_OF_MONTH ) ) ; } return result ; }
tr	7	public void read ( org . apache . thrift7 . protocol . TProtocol iprot ) throws org . apache . thrift7 . TException { org . apache . thrift7 . protocol . TField field ; iprot . readStructBegin ( ) ; while ( true ) { field = iprot . readFieldBegin ( ) ; if ( field . type == org . apache . thrift7 . protocol . TType . STOP ) { break ; } switch ( field . id ) { case 1 : if ( field . type == org . apache . thrift7 . protocol . TType . STRING ) { this . queue_name = iprot . readString ( ) ; } else { org . apache . thrift7 . protocol . TProtocolUtil . skip ( iprot , field . type ) ; } break ; case 2 : if ( field . type == org . apache . thrift7 . protocol . TType . SET ) { { org . apache . thrift7 . protocol . TSet _set12 = iprot . readSetBegin ( ) ; this . ids = new HashSet < long > ( 2 * _set12 . size ) ; for ( int _i13 = 0 ; _i13 < _set12 . size ; ++ _i13 ) { long _elem14 ; _elem14 = iprot . readI64 ( ) ; this . ids . add ( _elem14 ) ; } iprot . readSetEnd ( ) ; } } else { org . apache . thrift7 . protocol . TProtocolUtil . skip ( iprot , field . type ) ; } break ; default : org . apache . thrift7 . protocol . TProtocolUtil . skip ( iprot , field . type ) ; } iprot . readFieldEnd ( ) ; } iprot . readStructEnd ( ) ; validate ( ) ; }
tr	0	@ Override public ArrayList < String > getInsertSQL ( ) { ArrayList < String > ret = new ArrayList < > ( ) ; String sql = "INSERT INTO caballoscarrera VALUES (" ; sql += getOid ( ) + "  " ; sql += caballo . getCaballo ( ) . getOid ( ) + "  " ; sql += carrera . getOid ( ) + "  " ; sql += caballo . getNumero ( ) + "  " ; sql += caballo . getDividendo ( ) + "  " ; sql += caballo . getTipoApuesta ( ) . getCodigo ( ) ; sql += ");" ; ret . add ( sql ) ; return ret ; }
tr	7	public static AbstractTensorUIItem createItem ( TensorFeatureType t , Panel panel ) { switch ( t ) { case Constant : return new ConstantTensorUIItem ( panel ) ; case Wedge : return new WedgeUIItem ( panel ) ; case Center : return new CenterTensorUIItem ( panel ) ; case Node : return new NodeTensorUIItem ( panel ) ; case Saddle : return new SaddleTensorUIItem ( panel ) ; case Trisector : return new TrisectorUIItem ( panel ) ; case Generic : return new GenericTensorUIItem ( panel ) ; } assert false : "Unhandled type: " + t ; return null ; }
tr	1	public static INDIBLOBProperty createSaveableBLOBProperty ( INDIDriver driver , String name , PropertyStates state , PropertyPermissions permission ) throws IllegalArgumentException { INDIBLOBProperty bp = loadBLOBProperty ( driver , name ) ; if ( bp == null ) { bp = new INDIBLOBProperty ( driver , name , state , permission ) ; bp . setSaveable ( true ) ; } return bp ; }
tr	9	@ Override public Vector < SerializableObject > deSerialize ( ) throws Exception { Vector < SerializableObject > deSerList = new Vector < SerializableObject > ( ) ; DocumentBuilderFactory factory = DocumentBuilderFactory . newInstance ( ) ; DocumentBuilder builder = factory . newDocumentBuilder ( ) ; FileInputStream fis = null ; try { fis = new FileInputStream ( fileName ) ; } catch ( FileNotFoundException fnfe ) { System . out . println ( "File not found.If you did not run ser option first please run it first before running deser option" ) ; return null ; } Document document = builder . parse ( fis ) ; NodeList nodeList = document . getElementsByTagName ( "DPSerialization" ) ; for ( int i = 0 ; i < nodeList . getLength ( ) ; i ++ ) { Node node = nodeList . item ( i ) ; if ( node instanceof Element ) { class < ? extends SerializableObject > classDefinition = null ; Object instance = null ; Node complexTypeNode = ( ( Element ) node ) . getElementsByTagName ( "complexType" ) . item ( 0 ) ; String className = "" ; if ( complexTypeNode instanceof Element ) { Element e = ( Element ) complexTypeNode ; className = e . getAttribute ( "xsi:type" ) ; classDefinition = class . forName ( className ) . asSubclass ( SerializableObject . class ) ; instance = classDefinition . newInstance ( ) ; } NodeList childNodes = complexTypeNode . getChildNodes ( ) ; for ( int j = 0 ; j < childNodes . getLength ( ) ; j ++ ) { Node cNode = childNodes . item ( j ) ; if ( cNode instanceof Element ) { String content = cNode . getLastChild ( ) . getTextContent ( ) . trim ( ) ; Element propNode = ( Element ) cNode ; String propType = propNode . getAttribute ( "xsi:type" ) ; String propName = cNode . getNodeName ( ) ; Field field = classDefinition . getDeclaredField ( propName ) ; field . setAccessible ( true ) ; switch ( propType ) { case "xsd:int" : field . setInt ( instance , Integer . parseInt ( content ) ) ; break ; case "xsd:string" : field . set ( instance , content ) ; break ; case "xsd:double" : field . setDouble ( instance , double . parseDouble ( content ) ) ; break ; case "xsd:long" : field . setLong ( instance , long . parseLong ( content ) ) ; break ; case "xsd:char" : if ( content . length ( ) > 1 ) { System . out . println ( "character should be of length only 1" ) ; return null ; } field . setChar ( instance , content . charAt ( 0 ) ) ; } } } deSerList . add ( ( SerializableObject ) instance ) ; } } return deSerList ; }
tr	7	public String reverseWords ( String s ) { if ( s . length ( ) == 0 ) return s ; String [ ] arr = s . split ( " " ) ; ArrayList < String > aa = new ArrayList < String > ( ) ; if ( arr . length == 0 ) return "" ; int i = 0 ; while ( i < arr . length ) { if ( ! ( arr [ i ] . equals ( " " ) || arr [ i ] . equals ( "" ) ) ) { aa . add ( arr [ i ] ) ; } i ++ ; } if ( aa . size ( ) == 0 ) return "" ; String ret = aa . get ( aa . size ( ) - 1 ) ; for ( i = aa . size ( ) - 2 ; i > - 1 ; i -- ) { ret = ret + " " + aa . get ( i ) ; } return ret ; }
tr	0	public void setCreatedDate ( Date createdDate ) { this . createdDate = createdDate ; }
tr	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( Consulta_datos . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( Consulta_datos . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( Consulta_datos . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( Consulta_datos . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { new Consulta_datos ( ) . setVisible ( true ) ; } } ) ; }
tr	7	public static void main ( String [ ] args ) { boolean [ ] primes = new boolean [ SIZE ] ; for ( int i = 2 ; i < SIZE ; i ++ ) primes [ i ] = true ; for ( int i = 2 ; i < SIZE ; i ++ ) if ( primes [ i ] ) for ( int j = 2 ; i * j < SIZE ; j ++ ) primes [ i * j ] = false ; ArrayList < Integer > primeList = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < SIZE ; i ++ ) if ( primes [ i ] ) primeList . add ( i ) ; ArrayList < Radical > radicals = new ArrayList < Radical > ( ) ; for ( int i = 0 ; i <= SIZE ; i ++ ) radicals . add ( new Radical ( i , primeList ) ) ; radicals = sort ( radicals ) ; System . out . print ( radicals . get ( SIZE / 10 ) . num ) ; }
tr	4	private boolean isHelpOptionPresent ( OptionSet options ) { boolean helpOptionPresent = false ; for ( AbstractOptionSpec < ? > each : recognizedOptions . toJavaUtilMap ( ) . values ( ) ) { if ( each . isForHelp ( ) && options . has ( each ) ) { helpOptionPresent = true ; break ; } } return helpOptionPresent ; }
tr	6	public static class getType ( class c ) { if ( c == null ) { Logger . warn ( "no (typed) class given" ) ; return null ; } class ct = getActualType ( c . getGenericSuperclass ( ) ) ; if ( ct != null ) return ct ; Type [ ] interfaces = c . getGenericInterfaces ( ) ; if ( interfaces == null || interfaces . length == 0 ) return null ; for ( Type t : interfaces ) { ct = getActualType ( t ) ; if ( ct != null ) return ct ; } return null ; }
tr	4	private void processNode ( ) { Edge minEdge = null ; int minDijkstraCriterion = Integer . MAX_VALUE ; Set < Edge > frontierEdges = getFrontierEdges ( ) ; if ( frontierEdges . isEmpty ( ) ) { noFrontierEdges = true ; return ; } for ( Edge edge : frontierEdges ) { int dijkstraGreedyCriterion = dijkstraGreedyCriterion ( edge ) ; if ( dijkstraGreedyCriterion < minDijkstraCriterion ) { minDijkstraCriterion = dijkstraGreedyCriterion ; minEdge = edge ; } } assert minEdge != null : "No edges to remaining nodes" ; Node processedNode = null ; if ( ! minEdge . getTargetNode ( ) . isExplored ( ) ) { processedNode = minEdge . getTargetNode ( ) ; } else { processedNode = minEdge . getSourceNode ( ) ; } markProcessed ( processedNode ) ; shortestPathLengths . put ( processedNode , minDijkstraCriterion ) ; }
tr	2	@ Override public final Impl append ( Content content ) { final int size = size ( ) ; for ( int matchIndex = 0 ; matchIndex < size ; matchIndex ++ ) { Element match = get ( matchIndex ) ; Document doc = match . getOwnerDocument ( ) ; String text = nonNull ( content . content ( context ( match , matchIndex , size ) ) ) ; DocumentFragment imported = Util . createContent ( doc , text ) ; if ( imported != null ) { match . appendChild ( imported ) ; } else { match . appendChild ( doc . createTextNode ( text ) ) ; } } return this ; }
tr	6	private String getModelName ( TransferableModel model ) { if ( model instanceof MeetingModel ) { return "MeetingModel" ; } else if ( model instanceof ActiveUserModel ) { return "ActiveUserModel" ; } else if ( model instanceof UserModel ) { return "UserModel" ; } else if ( model instanceof MeetingRoomModel ) { return "MeetingRoomModel" ; } else if ( model instanceof InvitationModel ) { return "InvitationModel" ; } else if ( model instanceof NotificationModel ) { return "NotificationModel" ; } throw new IllegalArgumentException ( "Unknown model type passed to getModelName" + " " + model . getClass ( ) . getName ( ) ) ; }
tr	1	public boolean isChecksumValid ( ) { byte msg [ ] = toByteArray ( ) ; int i = 0 ; for ( int j = 1 ; j < msg . length - 1 ; j ++ ) i += msg [ j ] ; byte byte0 = ( byte ) ( 256 - i % 256 ) ; return byte0 == mChecksum ; }
tr	4	public Tree parseCall ( final Tree callee ) { if ( poll ( kLParen ) ) { final Call result = init ( new Call ( callee ) ) ; if ( ! peek ( kRParen ) ) { parseArgumentList ( result . arguments ) ; } if ( ! poll ( kRParen ) ) { return expected ( kRParen ) ; } return result ; } else if ( peek ( kIdentifier ) ) { final Name name = parseName ( ) ; final Select select = init ( new Select ( callee , name ) ) ; final Call result = init ( new Call ( select ) ) ; result . arguments . add ( parseSingleArgument ( ) ) ; return result ; } else { return expected ( kLParen ) ; } }
tr	8	@ SuppressWarnings ( "unchecked" ) @ Transactional public List < Merchant > getMerchantList ( String merchantName , String sortBy , String sortOrder ) throws Exception { List < Merchant > lstMerchants = new ArrayList < Merchant > ( ) ; Session session = null ; Criteria criteriaObj = null ; logger . info ( "merchantName---------->" + merchantName ) ; logger . info ( "sortBy--------------->" + sortBy ) ; logger . info ( "sortOrder------------>" + sortOrder ) ; String sName = merchantName ; try { session = sessionFactory . getCurrentSession ( ) ; logger . info ( "Entered into getMerchantList()--->" ) ; logger . info ( "Retrieving all merchants" ) ; if ( session != null ) { criteriaObj = session . createCriteria ( Merchant . class ) ; if ( merchantName != null ) { logger . info ( "Retrieving  merchants based on name" ) ; criteriaObj . add ( Restrictions . ilike ( "sName" , "%" + sName + "%" ) ) ; criteriaObj . add ( Restrictions . = ( "bdeletedFlag" , false ) ) ; } lstMerchants = criteriaObj . list ( ) ; logger . info ( "lstMerchants from DAO----------->" + lstMerchants . size ( ) ) ; } if ( sortBy != null && sortOrder == "asc" ) { logger . info ( "Retrieving  merchants based on Ascending sort order for " + sortBy ) ; lstMerchants = criteriaObj . addOrder ( Order . asc ( sortBy ) ) . list ( ) ; logger . info ( "lstMerchants size-------->" + lstMerchants . size ( ) ) ; } if ( sortBy != null && sortOrder == "desc" ) { logger . info ( "Retrieving  merchants based on Descending sort order for " + sortBy ) ; lstMerchants = criteriaObj . addOrder ( Order . desc ( sortBy ) ) . list ( ) ; logger . info ( "lstMerchants size-------->" + lstMerchants . size ( ) ) ; } Iterator < Merchant > it = lstMerchants . iterator ( ) ; while ( it . hasNext ( ) ) { Merchant merchant = it . next ( ) ; System . out . println ( "dao......." + merchant ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; logger . error ( "Exception occured in getMerchantList()--->" + e . getMessage ( ) ) ; throw new Exception ( "Exception occured in getMerchantList()--->" + e . getMessage ( ) ) ; } return lstMerchants ; }
tr	1	public void clearFeedback ( ) { for ( ValueSource vs : valueSources ) { vs . clearFeedback ( ) ; } }
tr	9	@ Override public Orientation getStepOrientation ( int lineIndex ) { switch ( lineIndex ) { case 0 : case 5 : return Orientation . DOWN_LEFT ; case 1 : case 6 : return Orientation . UP_LEFT ; case 2 : case 7 : return Orientation . CENTER ; case 3 : case 8 : return Orientation . UP_RIGHT ; case 4 : case 9 : return Orientation . DOWN_RIGHT ; default : return Orientation . NONE ; } }
tr	4	public static void createOfficeObject ( OfficeObject officeObject ) { PreparedStatement ps = null ; try { con = ConnectionManager . getConnection ( ) ; if ( con == null ) { return ; } String insertTableSQL = "INSERT INTO office_object(id  name  office_object_type_id  office_object_status_id)" + " VALUES (? ? ? ?)" ; ps = con . prepareStatement ( insertTableSQL ) ; ps . setInt ( 1 , officeObject . getId ( ) ) ; ps . setString ( 2 , officeObject . getName ( ) ) ; ps . setInt ( 3 , officeObject . getType ( ) ) ; ps . setInt ( 4 , officeObject . getOfficeObjectStatusId ( ) ) ; ps . executeUpdate ( ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; logger . error ( "SQL query execution errors. Error: " + e . getSQLState ( ) + " | " + e . getErrorCode ( ) ) ; } finally { try { if ( ps != null ) ps . close ( ) ; } catch ( Exception e ) { logger . warn ( "Connection was closed with errors." ) ; } } }
tr	5	public static int diasMes ( String mesInt ) { int result ; String mes = mesInt . toLowerCase ( ) ; switch ( mes ) { case "febrero" : result = 28 ; break ; case "abril" : case "junio" : case "septiembre" : case "noviembre" : result = 30 ; break ; default : result = 31 ; break ; } return result ; }
tr	6	private void parseMapLayout ( ) throws IOException , InvalidTerrainException , ExpectedTokenException { String line ; line = reader . readLine ( ) ; if ( ! line . equals ( "START" ) ) { throw new ExpectedTokenException ( "START" , line ) ; } int width = map . getWidth ( ) ; int height = map . getHeight ( ) ; for ( int i = 0 ; i < height ; i ++ ) { line = reader . readLine ( ) ; scanner = new Scanner ( line ) ; for ( int j = 0 ; j < width ; j ++ ) { String code = scanner . findInLine ( Pattern . compile ( ".." ) ) ; if ( code == null ) { throw new ExpectedTokenException ( "<code>" , line ) ; } Terrain terrain = terrains . get ( code ) ; if ( terrain == null ) { throw new InvalidTerrainException ( code , line ) ; } Terrain newTerrain = new Terrain ( terrain ) ; newTerrain . setPosition ( new Vec2f ( j * SQUARE_SIZE , i * SQUARE_SIZE ) ) ; map . addTerrain ( newTerrain , new Vec2i ( j , i ) ) ; } } line = reader . readLine ( ) ; if ( ! line . equals ( "END" ) ) { throw new ExpectedTokenException ( "END" , line ) ; } }
tr	8	protected void handleKeyboard ( ) { if ( keyPoller . isKeyDown ( KeyEvent . VK_LEFT ) ) { player2 . Direction ( - bLevel . getTileDim ( ) / player2 . getStepsize ( ) , 0 ) ; stepCount ++ ; } else if ( keyPoller . isKeyDown ( KeyEvent . VK_RIGHT ) ) { player2 . Direction ( bLevel . getTileDim ( ) / player2 . getStepsize ( ) , 0 ) ; stepCount ++ ; } if ( keyPoller . isKeyDown ( KeyEvent . VK_UP ) ) { player2 . Direction ( 0 , - bLevel . getTileDim ( ) / player2 . getStepsize ( ) ) ; stepCount ++ ; } else if ( keyPoller . isKeyDown ( KeyEvent . VK_DOWN ) ) { player2 . Direction ( 0 , bLevel . getTileDim ( ) / player2 . getStepsize ( ) ) ; stepCount ++ ; } if ( keyReceiver . isKeyDown ( KeyEvent . VK_LEFT ) ) { player1 . Direction ( - bLevel . getTileDim ( ) / player1 . getStepsize ( ) , 0 ) ; stepCount ++ ; } else if ( keyReceiver . isKeyDown ( KeyEvent . VK_RIGHT ) ) { player1 . Direction ( bLevel . getTileDim ( ) / player1 . getStepsize ( ) , 0 ) ; stepCount ++ ; } if ( keyReceiver . isKeyDown ( KeyEvent . VK_UP ) ) { player1 . Direction ( 0 , - bLevel . getTileDim ( ) / player1 . getStepsize ( ) ) ; stepCount ++ ; } else if ( keyReceiver . isKeyDown ( KeyEvent . VK_DOWN ) ) { player1 . Direction ( 0 , bLevel . getTileDim ( ) / player1 . getStepsize ( ) ) ; stepCount ++ ; } }
tr	2	public synchronized boolean doLogin ( String nomeGiocatore , String suppliedPassword ) throws UserAuthenticationFailedException { if ( getPMan ( ) . exists ( nomeGiocatore ) ) { Giocatore tempGiocatore = getPMan ( ) . getPlayer ( nomeGiocatore ) ; if ( tempGiocatore . passwordIsValid ( suppliedPassword ) ) { getCMan ( ) . collega ( nomeGiocatore , CommonUtils . getNewToken ( ) ) ; return true ; } else throw new UserAuthenticationFailedException ( ) ; } else return false ; }
tr	2	@ Override public int compare ( Field f1 , Field f2 ) { if ( ! f1 . getName ( ) . equals ( f2 . getName ( ) ) ) { return f1 . getName ( ) . compareTo ( f2 . getName ( ) ) ; } else if ( ! f1 . getType ( ) . equals ( f2 . getType ( ) ) ) { return f1 . getType ( ) . getName ( ) . compareTo ( f2 . getType ( ) . getName ( ) ) ; } return 0 ; }
tr	9	public QuestionPanel getQuestionPanel ( ) { if ( mediaPanel . hasFinished ( ) ) createMedia ( ) ; if ( type . equals ( "plain" ) ) { HashMap < String , String > text = new HashMap < String , String > ( ) ; text . put ( "frage" , title ) ; questionPanel = new QuestionPanel ( text , mediaPanel , fontsize ) ; } else if ( type . equals ( "mchoice" ) ) { String [ ] split = answers . split ( ";" ) ; MultipleChoicePanel panel = new MultipleChoicePanel ( split , mcfont ) ; HashMap < String , String > text = new HashMap < String , String > ( ) ; text . put ( "frage" , title ) ; questionPanel = new QuestionPanel ( text , mediaPanel , panel , fontsize ) ; } else if ( type . equals ( "mchoice-img" ) || type . equals ( "mchoice_img" ) ) { String [ ] split = answers . split ( ";" ) ; JLabel [ ] labels = new JLabel [ 4 ] ; BufferedImage bufferedImage ; Image image ; for ( int i = 0 ; i < labels . length ; i ++ ) { prefHeight = Math . max ( PREF_HEIGHT , mcfont ) ; try { bufferedImage = ImageIO . read ( new File ( split [ i ] ) ) ; if ( bufferedImage . getHeight ( ) > prefHeight ) { image = bufferedImage . getScaledInstance ( bufferedImage . getWidth ( ) * prefHeight / bufferedImage . getHeight ( ) , prefHeight , BufferedImage . SCALE_SMOOTH ) ; } else { image = bufferedImage ; } } catch ( IOException e ) { bufferedImage = null ; image = null ; e . printStackTrace ( ) ; System . out . println ( "Image path: " + split [ i ] ) ; } labels [ i ] = new JLabel ( new ImageIcon ( image ) ) ; } MultipleChoicePanel panel = new MultipleChoicePanel ( labels , mcfont ) ; HashMap < String , String > text = new HashMap < String , String > ( ) ; text . put ( "frage" , title ) ; questionPanel = new QuestionPanel ( text , mediaPanel , panel , fontsize ) ; } else if ( type . equals ( "list" ) ) { HashMap < String , String > text = new HashMap < String , String > ( ) ; text . put ( "frage" , title ) ; String [ ] answerArray = answers . split ( ";" ) ; System . out . println ( "Create question list" ) ; questionPanel = new QuestionPanel ( text , answerArray , fontsize ) ; } else { System . out . println ( "failed to read file" ) ; System . exit ( 0 ) ; } return questionPanel ; }
tr	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( MainForm . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( MainForm . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( MainForm . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( MainForm . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { new MainForm ( ) . setVisible ( true ) ; } } ) ; }
tr	0	@ Override public int length ( ) { return contents . length ( ) ; }
tr	7	@ Override public String execute ( HttpServletRequest request , HttpServletResponse response ) throws Exception { String data ; try { ArrayList < FilterBean > alFilter = new ArrayList < > ( ) ; if ( request . getParameter ( "filter" ) != null ) { if ( request . getParameter ( "filteroperator" ) != null ) { if ( request . getParameter ( "filtervalue" ) != null ) { FilterBean oFilterBean = new FilterBean ( ) ; oFilterBean . setFilter ( request . getParameter ( "filter" ) ) ; oFilterBean . setFilterOperator ( request . getParameter ( "filteroperator" ) ) ; oFilterBean . setFilterValue ( request . getParameter ( "filtervalue" ) ) ; oFilterBean . setFilterOrigin ( "user" ) ; alFilter . add ( oFilterBean ) ; } } } if ( request . getParameter ( "systemfilter" ) != null ) { if ( request . getParameter ( "systemfilteroperator" ) != null ) { if ( request . getParameter ( "systemfiltervalue" ) != null ) { FilterBean oFilterBean = new FilterBean ( ) ; oFilterBean . setFilter ( request . getParameter ( "systemfilter" ) ) ; oFilterBean . setFilterOperator ( request . getParameter ( "systemfilteroperator" ) ) ; oFilterBean . setFilterValue ( request . getParameter ( "systemfiltervalue" ) ) ; oFilterBean . setFilterOrigin ( "system" ) ; alFilter . add ( oFilterBean ) ; } } } RecompensaDao oRecompensaDAO = new RecompensaDao ( Conexion . getConection ( ) ) ; int pages = oRecompensaDAO . getCount ( alFilter ) ; data = "{\"data\":\"" + Integer . toString ( pages ) + "\"}" ; return data ; } catch ( Exception e ) { throw new ServletException ( "RecompensaGetregistersJson: View Error: " + e . getMessage ( ) ) ; } }
tr	9	public void run ( Source source , String [ ] args ) { if ( args . length == 1 ) { if ( args [ 0 ] . contains ( "#" ) ) { if ( Server . getServer ( ) . getChannelHandler ( ) . getChannel ( args [ 0 ] ) != null ) { source . send ( new ModeChannelCodec ( args [ 0 ] , Server . getServer ( ) . getChannelHandler ( ) . getChannel ( args [ 0 ] ) . getModes ( ) ) ) ; } } } else if ( args . length == 2 ) { if ( args [ 0 ] . contains ( "#" ) && Server . getServer ( ) . getChannelHandler ( ) . getChannel ( args [ 0 ] ) != null ) { Channel chan = Server . getServer ( ) . getChannelHandler ( ) . getChannel ( args [ 0 ] ) ; if ( args [ 1 ] . contains ( "+" ) ) { modifyChannelMode ( args , chan , source , true ) ; } else if ( args [ 1 ] . contains ( "-" ) ) { modifyChannelMode ( args , chan , source , false ) ; } } } else if ( args . length >= 3 ) { if ( args [ 0 ] . contains ( "#" ) && Server . getServer ( ) . getChannelHandler ( ) . getChannel ( args [ 0 ] ) != null ) { Channel chan = Server . getServer ( ) . getChannelHandler ( ) . getChannel ( args [ 0 ] ) ; if ( chan . getUserList ( ) . containsKey ( source ) && chan . getUserList ( ) . get ( source ) . getUserModes ( ) . contains ( ChannelUserMode . OP ) ) { if ( args [ 1 ] . contains ( "+" ) ) { addRemoveModeChannel ( args , chan , source , true ) ; } else if ( args [ 1 ] . contains ( "-" ) ) { addRemoveModeChannel ( args , chan , source , false ) ; } } } } }
tr	9	public Geometry patch ( int m , int n , double basisMatrix [ ] [ ] , double data [ ] ) { newRectangularMesh ( m + 2 , n + 2 ) ; faces = new int [ m * n ] [ 4 ] ; for ( int k = 1 ; k < n + 1 ; k ++ ) for ( int j = 1 ; j < m + 1 ; j ++ ) { int f = ( k - 1 ) * m + j - 1 ; int v = k * ( m + 3 ) + j ; faces [ f ] [ 0 ] = v ; faces [ f ] [ 1 ] = v + 1 ; faces [ f ] [ 2 ] = v + m + 3 + 1 ; faces [ f ] [ 3 ] = v + m + 3 ; } double G [ ] [ ] [ ] = new double [ 3 ] [ 4 ] [ 4 ] ; for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) for ( int k = 0 ; k < 3 ; k ++ ) G [ k ] [ i ] [ j ] = data [ 12 * i + 3 * j + k ] ; Coefs = new double [ 3 ] [ 4 ] [ 4 ] ; for ( int k = 0 ; k < 3 ; k ++ ) constructBicubicCoefficients ( G [ k ] , basisMatrix , Coefs [ k ] ) ; int N = 0 ; for ( int j = - 1 ; j <= n + 1 ; j ++ ) { double v = ( double ) j / n ; for ( int i = - 1 ; i <= m + 1 ; i ++ ) { double u = ( double ) i / m ; for ( int k = 0 ; k < 3 ; k ++ ) vertices [ N ] [ k ] = evalBicubic ( Coefs [ k ] , u , v ) ; N ++ ; } } computedMeshNormals = false ; return this ; }
tr	0	public void doPassaTurno ( ) { turnoConfermato = false ; }
tr	8	public SocketThread ( Socket skt ) { this . socket = skt ; this . reader = new Thread ( new Runnable ( ) { @ Override public void run ( ) { try { input = new XMLReader ( new BufferedReader ( new InputStreamReader ( socket . getInputStream ( ) , "UTF-8" ) ) ) ; } catch ( XMLStreamException | IOException e ) { e . printStackTrace ( ) ; return ; } while ( true ) { try { messages . add ( input . readMessage ( ) ) ; fireEvent ( ) ; } catch ( XMLStreamException e ) { if ( Thread . interrupted ( ) ) { System . out . println ( "Reader closed." ) ; return ; } else { e . printStackTrace ( ) ; } } } } } ) ; this . writer = new Thread ( new Runnable ( ) { @ Override public void run ( ) { try { output = new XMLWriter ( new PrintWriter ( new OutputStreamWriter ( socket . getOutputStream ( ) , "UTF-8" ) ) ) ; } catch ( XMLStreamException | IOException e ) { e . printStackTrace ( ) ; return ; } while ( true ) { try { Message m = msgQueue . take ( ) ; output . writeMessage ( m ) ; } catch ( InterruptedException e ) { System . out . println ( "Writer closed." ) ; return ; } catch ( XMLStreamException e ) { e . printStackTrace ( ) ; } } } } ) ; }
tr	9	private boolean isConflict ( List < Rectangle > bounds , List < ContainerComponent > selectedComponents ) { for ( Rectangle r : bounds ) { if ( r . x < 0 ) return true ; if ( r . y < 0 ) return true ; for ( ContainerComponent c2 : workplaceComponents ) { if ( selectedComponents != null && ! notIn ( c2 , selectedComponents ) ) continue ; Rectangle r2 = c2 . getBounds ( ) ; if ( r2 . intersects ( r ) ) { return true ; } } Rectangle truckBounds = truck . getBounds ( ) ; if ( truckBounds . intersects ( r ) && ! truckBounds . contains ( r ) ) { return true ; } } return false ; }
tr	2	@ Override public void removeUser ( Identifier id ) throws DataBaseReadWriteException , IdentifierNotFoundException , InvalidIdentifierException { if ( id == null ) { throw new InvalidIdentifierException ( "Id is invalid" ) ; } if ( Users . remove ( id ) == null ) { throw new IdentifierNotFoundException ( "Id not found" ) ; } Users . remove ( id ) ; write ( USERS ) ; }
tr	9	@ Override public String execute ( HttpServletRequest request , HttpServletResponse response ) throws Exception { String data ; try { int rpp ; if ( request . getParameter ( "rpp" ) == null ) { rpp = 10 ; } else { rpp = Integer . parseInt ( request . getParameter ( "rpp" ) ) ; } ArrayList < FilterBean > alFilter = new ArrayList < > ( ) ; if ( request . getParameter ( "filter" ) != null ) { if ( request . getParameter ( "filteroperator" ) != null ) { if ( request . getParameter ( "filtervalue" ) != null ) { FilterBean oFilterBean = new FilterBean ( ) ; oFilterBean . setFilter ( request . getParameter ( "filter" ) ) ; oFilterBean . setFilterOperator ( request . getParameter ( "filteroperator" ) ) ; oFilterBean . setFilterValue ( request . getParameter ( "filtervalue" ) ) ; oFilterBean . setFilterOrigin ( "user" ) ; alFilter . add ( oFilterBean ) ; } } } if ( request . getParameter ( "systemfilter" ) != null ) { if ( request . getParameter ( "systemfilteroperator" ) != null ) { if ( request . getParameter ( "systemfiltervalue" ) != null ) { FilterBean oFilterBean = new FilterBean ( ) ; oFilterBean . setFilter ( request . getParameter ( "systemfilter" ) ) ; oFilterBean . setFilterOperator ( request . getParameter ( "systemfilteroperator" ) ) ; oFilterBean . setFilterValue ( request . getParameter ( "systemfiltervalue" ) ) ; oFilterBean . setFilterOrigin ( "system" ) ; alFilter . add ( oFilterBean ) ; } } } HashMap < String , String > hmOrder = new HashMap < > ( ) ; if ( request . getParameter ( "order" ) != null ) { if ( request . getParameter ( "ordervalue" ) != null ) { hmOrder . put ( request . getParameter ( "order" ) , request . getParameter ( "ordervalue" ) ) ; } else { hmOrder = null ; } } else { hmOrder = null ; } RecompensaDao oRecompensaDAO = new RecompensaDao ( Conexion . getConection ( ) ) ; int pages = oRecompensaDAO . getPages ( rpp , alFilter , hmOrder ) ; data = "{\"data\":\"" + Integer . toString ( pages ) + "\"}" ; return data ; } catch ( Exception e ) { throw new ServletException ( "RecompensaGetpagesJson: View Error: " + e . getMessage ( ) ) ; } }
tr	6	@ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; Ticket other = ( Ticket ) obj ; if ( code == null ) { if ( other . code != null ) return false ; } else if ( ! code . equals ( other . code ) ) return false ; return true ; }
tr	0	@ Override public < S , T > T visit ( Visitor < S , T > v , S state ) throws FractalException { return v . visitASTFracVar ( this , state ) ; }
tr	9	private void outOther ( Scope scope , List < String > outerSels , NodeInfo node ) throws IOException { if ( node instanceof VariableDefinition ) { final VariableDefinition vdef = ( VariableDefinition ) node ; scope . setVariable ( vdef . getName ( ) , evalDefinition ( scope , vdef ) ) ; } else if ( node instanceof FunctionDefinition ) { final FunctionDefinition fd = ( FunctionDefinition ) node ; scope . setVariable ( fd . getName ( ) , fd ) ; } else if ( node instanceof MixinDefinition ) { final MixinDefinition fd = ( MixinDefinition ) node ; scope . setVariable ( fd . getName ( ) , fd ) ; } else if ( node instanceof IfDefinition ) { for ( NodeInfo child : node . getChildren ( ) ) { final BlockDefinition block = ( BlockDefinition ) child ; final Expression expr = block . getCondition ( ) ; if ( expr == null || isTrue ( scope , expr ) ) { outChildren ( scope , outerSels , block ) ; break ; } } } else if ( node instanceof MediaDefinition ) { write ( "@media " ) ; write ( ( ( MediaDefinition ) node ) . getRange ( ) ) ; write ( "{\n" ) ; outChildren ( scope , outerSels , node ) ; write ( "}\n" ) ; } else if ( node instanceof RawValue ) { write ( ( ( RawValue ) node ) . getValue ( ) ) ; } else { throw error ( "unknown " + node , node ) ; } }
tr	9	private static String getValue ( JSONTokener x ) throws JSONException { char c ; char q ; StringBuffer sb ; do { c = x . next ( ) ; } while ( c ==   || c == 	 ) ; switch ( c ) { case 0 : return null ; case " : case ' : q = c ; sb = new StringBuffer ( ) ; for ( ; ; ) { c = x . next ( ) ; if ( c == q ) { break ; } if ( c == 0 || c == '' || c == '' ) { throw x . syntaxError ( "Missing close quote '" + q + "'." ) ; } sb . append ( c ) ; } return sb . toString ( ) ; case   : x . back ( ) ; return "" ; default : x . back ( ) ; return x . nextTo (   ) ; } }
tr	0	public void arrayToTable ( Type type ) { int array = newLocal ( type ) ; int table = newLocal ( OBJ_TABLE ) ; int limit = newLocal ( INT_TYPE ) ; int counter = newLocal ( INT_TYPE ) ; Type entry = getEntryType ( type ) ; Label loopBody = new Label ( ) ; Label loopEnd = new Label ( ) ; dup ( ) ; storeLocal ( array ) ; arrayLength ( ) ; storeLocal ( limit ) ; push0 ( ) ; storeLocal ( counter ) ; newInstance ( OBJ_TABLE ) ; dup ( ) ; visitMethodInsn ( INVOKESPECIAL , TABLE , "<init>" , "()V" ) ; storeLocal ( table ) ; goto ( loopEnd ) ; visitLabel ( loopBody ) ; loadLocal ( table ) ; loadLocal ( counter ) ; push1 ( ) ; math ( ADD , INT_TYPE ) ; loadLocal ( array ) ; loadLocal ( counter ) ; arrayLoad ( entry ) ; varToLua ( entry ) ; visitMethodInsn ( INVOKEVIRTUAL , TABLE , "rawset" , "(ILjava/lang/Object;)V" ) ; iinc ( counter , 1 ) ; visitLabel ( loopEnd ) ; loadLocal ( counter ) ; loadLocal ( array ) ; arrayLength ( ) ; ifICmp ( < , loopBody ) ; loadLocal ( table ) ; }
tr	7	@ Override public byte [ ] getByteData ( ) { if ( ptr != 0 ) { return null ; } else { if ( isConstant ( ) ) { if ( length > getMaxSizeOf32bitArray ( ) ) return null ; byte [ ] out = new byte [ ( int ) length ] ; byte elem = ( byte ) ( data [ 0 ] != null ? data [ 0 ] . length ( ) : 0 ) ; for ( int i = 0 ; i < length ; i ++ ) { out [ i ] = elem ; } return out ; } else { byte [ ] res = new byte [ ( int ) length ] ; for ( int i = 0 ; i < length ; i ++ ) { res [ i ] = ( byte ) ( data [ i ] != null ? data [ i ] . length ( ) : 0 ) ; } return res ; } } }
tr	5	public static List < NewsFeedEntry > getMostRecentEntries ( String currentUser , int maxEntries ) { String query = "SELECT * FROM newsFeed ORDER BY time DESC;" ; ResultSet rs = MyDB . queryDatabase ( query ) ; List < NewsFeedEntry > toReturn = new ArrayList < NewsFeedEntry > ( ) ; try { int i = 0 ; while ( rs . next ( ) && i < maxEntries ) { NewsFeedEntry entry = new NewsFeedEntry ( rs ) ; String user = entry . getUser ( ) ; if ( user . equals ( currentUser ) || FriendUtils . areFriends ( user , currentUser ) ) { toReturn . add ( entry ) ; i ++ ; } } } catch ( SQLException e ) { e . printStackTrace ( ) ; } return toReturn ; }
tr	7	static public Chart createChart ( Composite parent ) { final Chart chart = new Chart ( parent , SWT . NONE ) ; chart . getTitle ( ) . setText ( "Bar Bounds" ) ; IBarSeries series1 = ( IBarSeries ) chart . getSeriesSet ( ) . createSeries ( SeriesType . | , "series 1" ) ; series1 . setYSeries ( ySeries1 ) ; IBarSeries series2 = ( IBarSeries ) chart . getSeriesSet ( ) . createSeries ( SeriesType . | , "series 2" ) ; series2 . setYSeries ( ySeries2 ) ; series2 . setBarColor ( Display . getDefault ( ) . getSystemColor ( SWT . COLOR_GREEN ) ) ; chart . getAxisSet ( ) . adjustRange ( ) ; chart . getPlotArea ( ) . addMouseMoveListener ( new MouseMoveListener ( ) { public void mouseMove ( MouseEvent e ) { for ( ISeries series : chart . getSeriesSet ( ) . getSeries ( ) ) { Rectangle [ ] rs = ( ( IBarSeries ) series ) . getBounds ( ) ; for ( int i = 0 ; i < rs . length ; i ++ ) { if ( rs [ i ] != null ) { if ( rs [ i ] . x < e . x && e . x < rs [ i ] . x + rs [ i ] . width && rs [ i ] . y < e . y && e . y < rs [ i ] . y + rs [ i ] . height ) { setToolTipText ( series , i ) ; return ; } } } } chart . getPlotArea ( ) . setToolTipText ( null ) ; } private void setToolTipText ( ISeries series , int index ) { chart . getPlotArea ( ) . setToolTipText ( "Series: " + series . getId ( ) + "\nValue: " + series . getYSeries ( ) [ index ] ) ; } } ) ; return chart ; }
tr	9	public void DesativaCampos ( ) { for ( Component c : tela . getjPFicha ( ) . getComponents ( ) ) { if ( c instanceof JComboBox ) { ( ( JComboBox ) c ) . setEnabled ( false ) ; } if ( c instanceof JCheckBox ) { ( ( JCheckBox ) c ) . setEnabled ( false ) ; } if ( c instanceof JTextField ) { ( ( JTextField ) c ) . setEnabled ( false ) ; } if ( c instanceof JDateChooser ) { ( ( JDateChooser ) c ) . setEnabled ( false ) ; } if ( c instanceof JScrollPane ) { for ( Component co : ( ( JScrollPane ) c ) . getComponents ( ) ) { if ( co instanceof JViewport ) { for ( Component com : ( ( JViewport ) co ) . getComponents ( ) ) { if ( com instanceof JTextArea ) { ( ( JTextArea ) com ) . setEnabled ( false ) ; } } } } } } }
tr	2	public static void printWarnings ( Connection conn , PrintWriter pw ) { if ( conn != null ) { try { printStackTrace ( conn . getWarnings ( ) , pw ) ; } catch ( SQLException e ) { printStackTrace ( e , pw ) ; } } }
tr	8	private void generateItems ( double density ) { double candleDensity = 0.05 ; for ( int column = 0 ; column < getColumns ( ) ; column ++ ) { for ( int row = 0 ; row < getRows ( ) ; row ++ ) { if ( isPath ( column , row ) && Math . random ( ) < candleDensity ) { Candle c = new Candle ( ) ; int hPadding = ( SQUARE_SIZE - c . getWidth ( ) ) / 2 ; int vPadding = ( SQUARE_SIZE - c . getHeight ( ) ) / 2 ; c . setX ( column * SQUARE_SIZE + hPadding ) ; c . setY ( row * SQUARE_SIZE + vPadding ) ; lights . add ( c ) ; items . add ( c ) ; } } } for ( int x = SQUARE_SIZE ; x < ( columns - 1 ) * SQUARE_SIZE ; x += SQUARE_SIZE ) { for ( int y = SQUARE_SIZE ; y < ( rows - 1 ) * SQUARE_SIZE ; y += SQUARE_SIZE ) { if ( ! hasItem ( x + SQUARE_SIZE / 2 , y + SQUARE_SIZE / 2 ) && Math . random ( ) < density ) { Item item = Item . randomItem ( x , y ) ; int hPadding = ( SQUARE_SIZE - item . getWidth ( ) ) / 2 ; int vPadding = ( SQUARE_SIZE - item . getHeight ( ) ) / 2 ; item . setX ( x + hPadding ) ; item . setY ( y + vPadding ) ; items . add ( item ) ; } } } }
tr	1	private IGameMap createGameMap ( String path ) { IGameMap map = injector . getInstance ( IGameMap . class ) ; try ( InputStream in = getClass ( ) . getResourceAsStream ( path ) ) { map . readMap ( in ) ; } catch ( IOException ex ) { assert . fail ( ex . getMessage ( ) ) ; } return map ; }
tr	2	public boolean load ( ) { try { Path path = savePath . resolve ( getName ( ) ) ; if ( ! Files . exists ( path ) ) { return false ; } BufferedReader in = new BufferedReader ( new InputStreamReader ( Files . newInputStream ( path ) ) ) ; password = in . readLine ( ) ; return true ; } catch ( IOException e ) { return false ; } }
tr	7	public static char getAdrValue ( String s ) { int main = 0 ; int mid = 0 ; int - = 0 ; String [ ] result = s . split ( "/" ) ; if ( result . length == 3 ) { main = Integer . parseInt ( result [ 0 ] ) ; mid = Integer . parseInt ( result [ 1 ] ) ; - = Integer . parseInt ( result [ 2 ] ) ; } if ( ( main >= 0 ) && ( main < 16 ) && ( mid >= 0 ) && ( mid < 8 ) && ( - >= 0 ) && ( - < 256 ) ) return ( char ) ( ( main << 11 ) + ( mid << 8 ) + - ) ; return 0 ; }
tr	7	public MainProcessor ( List < PatternElement > patterns , boolean verbose , boolean skipManifest ) { this . verbose = verbose ; List < Zap > zapList = new ArrayList < Zap > ( ) ; List < Rule > ruleList = new ArrayList < Rule > ( ) ; List < Keep > keepList = new ArrayList < Keep > ( ) ; for ( PatternElement pattern : patterns ) { if ( pattern instanceof Zap ) { zapList . add ( ( Zap ) pattern ) ; } else if ( pattern instanceof Rule ) { ruleList . add ( ( Rule ) pattern ) ; } else if ( pattern instanceof Keep ) { keepList . add ( ( Keep ) pattern ) ; } } PackageRemapper pr = new PackageRemapper ( ruleList , verbose ) ; kp = keepList . isEmpty ( ) ? null : new KeepProcessor ( keepList ) ; List < JarProcessor > processors = new ArrayList < JarProcessor > ( ) ; if ( skipManifest ) { processors . add ( ManifestProcessor . getInstance ( ) ) ; } if ( kp != null ) { processors . add ( kp ) ; } processors . add ( new ZapProcessor ( zapList ) ) ; processors . add ( new JarTransformerChain ( new ClassTransformer [ ] { new RemappingClassTransformer ( pr ) } ) ) ; processors . add ( new ResourceProcessor ( pr ) ) ; chain = new JarProcessorChain ( processors . toArray ( new JarProcessor [ processors . size ( ) ] ) ) ; }
tr	9	public boolean isValidSudoku ( char [ ] [ ] board ) { int [ ] filled = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) filled [ i ] = 1 ; for ( int i = 0 ; i < 9 ; i ++ ) { int [ ] check = Arrays . copyOf ( filled , 10 ) ; for ( int j = 0 ; j < 9 ; j ++ ) { if ( board [ i ] [ j ] == . ) continue ; int a = Character . getNumericValue ( board [ i ] [ j ] ) ; check [ a ] -- ; if ( check [ a ] < 0 ) return false ; } } for ( int i = 0 ; i < 9 ; i ++ ) { int [ ] check = Arrays . copyOf ( filled , 10 ) ; for ( int j = 0 ; j < 9 ; j ++ ) { if ( board [ j ] [ i ] == . ) continue ; int a = Character . getNumericValue ( board [ j ] [ i ] ) ; check [ a ] -- ; if ( check [ a ] < 0 ) return false ; } } for ( int i = 0 ; i < 3 ; i ++ ) { for ( int j = 0 ; j < 3 ; j ++ ) { int [ ] check = Arrays . copyOf ( filled , 10 ) ; for ( int ii = i * 3 ; ii < ( i + 1 ) * 3 ; ii ++ ) { for ( int jj = j * 3 ; jj < ( j + 1 ) * 3 ; jj ++ ) { if ( board [ ii ] [ jj ] == . ) continue ; int a = Character . getNumericValue ( board [ ii ] [ jj ] ) ; check [ a ] -- ; if ( check [ a ] < 0 ) return false ; } } } } return true ; }
tr	4	public void testMapAllNodesAndLinks ( ) { for ( Request request : requests ) { Mapping mapping = mapper . map ( request , substrateNetwork ) ; if ( mapping != null ) { for ( VirtualNode virtualNode : request . getVirtualNodes ( ) . values ( ) ) { assertTrue ( mapping . isNodeMapped ( virtualNode ) ) ; } for ( VirtualLink virtualLink : request . getVirtualLinks ( ) . values ( ) ) { assertTrue ( mapping . isLinkMapped ( virtualLink ) ) ; } } } }
tr	7	private final boolean cvc ( int i ) { if ( i < 2 || ! cons ( i ) || cons ( i - 1 ) || ! cons ( i - 2 ) ) return false ; { int ch = b [ i ] ; if ( ch == w || ch == x || ch == y ) return false ; } return true ; }
tr	7	public void open ( int row , int col ) { validate ( row ) ; validate ( col ) ; int idx = index ( row , col ) ; if ( ! isOpenV ( idx ) ) { open [ idx ] = true ; if ( row == 1 ) { if ( toBottom [ idx ] ) { percolates = true ; } ufTop . union ( idx , theTOP ) ; } else { connectIfDestOpen ( idx , row - 1 , col ) ; } if ( col > 1 ) { connectIfDestOpen ( idx , row , col - 1 ) ; } if ( col < N ) { connectIfDestOpen ( idx , row , col + 1 ) ; } if ( row == N ) { if ( toTop [ idx ] ) { percolates = true ; } } else { connectIfDestOpen ( idx , row + 1 , col ) ; } } }
tr	9	public void generate ( Point start ) { Stack < Point > waysToExpand = new Stack < > ( ) ; exitFound = false ; final List < Point > nextOptions = new ArrayList < > ( 4 ) ; waysToExpand . add ( start ) ; while ( ! waysToExpand . isEmpty ( ) ) { Point p = waysToExpand . pop ( ) ; if ( canBecomeWhite ( p ) ) { arr . setWhite ( p ) ; if ( onTheEdge ( p ) && p . differsFrom ( start ) ) { exitFound = true ; } if ( isBlack ( p . up ( ) ) && canBecomeWhite ( p . up ( ) ) ) nextOptions . add ( p . up ( ) ) ; if ( isBlack ( p . down ( ) ) && canBecomeWhite ( p . down ( ) ) ) nextOptions . add ( p . down ( ) ) ; if ( isBlack ( p . left ( ) ) && canBecomeWhite ( p . left ( ) ) ) nextOptions . add ( p . left ( ) ) ; if ( isBlack ( p . right ( ) ) && canBecomeWhite ( p . right ( ) ) ) nextOptions . add ( p . right ( ) ) ; Collections . shuffle ( nextOptions ) ; int c = 0 ; for ( Point t : nextOptions ) { waysToExpand . push ( t ) ; c ++ ; if ( c == 2 ) break ; } nextOptions . clear ( ) ; } } }
tr	3	public void testMapBranch ( ) { Mapping mapping = new Mapping ( ) ; VirtualNode virtualNode = requests . get ( 0 ) . getVirtualNodes ( ) . get ( 0 ) ; VirtualLink virtualLink = ( VirtualLink ) virtualNode . getAttachedLinks ( ) . get ( 0 ) ; VirtualNode virtualDestinyNode = ( VirtualNode ) virtualLink . getNodeAttachedTo ( virtualNode ) ; for ( PhysicalNode physicalNode : substrateNetwork . getHashNodes ( ) . values ( ) ) { if ( ! mapping . isNodeMapped ( virtualNode ) && physicalNode . canHost ( virtualNode ) ) { mapping . addNodeMapping ( virtualNode , physicalNode ) ; } } assertTrue ( mapper . mapBranch ( virtualNode , virtualDestinyNode , virtualLink , substrateNetwork , mapping ) ) ; }
tr	5	public String createOrder ( Map < Integer , Price > priceMap , User user ) throws ServiceException { if ( priceMap == null ) { return OtherConstants . SELECTED_ORDERING_NULL ; } float total = 0f ; for ( Map . Entry < Integer , Price > map : priceMap . entrySet ( ) ) { Price price = map . getValue ( ) ; int num = price . getPriceNum ( ) ; total = total + num * price . getPriceValue ( ) ; } Order order = new Order ( ) ; order . setUserID ( user . getId ( ) ) ; order . setOrderTotle ( total ) ; String orderSeq = MD5 . getMD5 ( user . getId ( ) + total + OtherConstants . STATE_NO ) + System . currentTimeMillis ( ) ; order . setOrderSeq ( orderSeq ) ; order . setOrderState ( OtherConstants . STATE_NO ) ; try { String orderID = orderDaoImpl . add ( order , SqlConstants . ORDER_ADD ) ; Detail detail = new Detail ( ) ; for ( Map . Entry < Integer , Price > map : priceMap . entrySet ( ) ) { Price price = map . getValue ( ) ; detail . setOrderID ( orderID ) ; detail . setPriceID ( price . getId ( ) ) ; detail . setOrderDetailNum ( price . getPriceNum ( ) ) ; String detailID = detailDaoImpl . add ( detail , SqlConstants . DETAIL_ADD ) ; Food food = new Food ( ) ; List < Dic > dics = price . getDics ( ) ; for ( Dic dic : dics ) { food . setDicID ( dic . getId ( ) ) ; food . setOrderDetailID ( detailID ) ; food . setFoodNum ( 1 ) ; foodDaoImpl . insert ( food , SqlConstants . FOOD_ADD ) ; } } } catch ( DBException e ) { logger . error ( OtherConstants . DB_ERROR , e ) ; return OtherConstants . DB_ERROR ; } return null ; }
tr	0	public AsnRange to ( long end ) { return to ( Asn . of ( end ) ) ; }
tr	3	protected boolean isSameDouble ( double d1 , double d2 ) { if ( d1 - d2 == 0.0 ) return true ; else { INEXACT_COMPARED = true ; if ( d1 == 0.0 ) return Math . abs ( d2 ) < TOLERANCE ; if ( d2 == 0.0 ) return Math . abs ( d1 ) < TOLERANCE ; else return Math . abs ( d1 - d2 ) / ( Math . abs ( ( d1 + d2 ) / 2 ) ) < TOLERANCE ; } }
tr	3	public void testContinue ( ) { outer : for ( int j = 0 ; j < 5 ; j ++ ) { System . out . println ( "Starting main loop j=" + j ) ; for ( int i = 0 ; i < 10000 ; i ++ ) { int num = ( int ) ( Math . random ( ) * 100 ) ; if ( num == 0 ) { System . out . println ( "********** Got 0" ) ; break outer ; } System . out . println ( i / num ) ; } } }
tr	3	public JSONObject accumulate ( String key , Object value ) throws JSONException { testValidity ( value ) ; Object object = this . opt ( key ) ; if ( object == null ) { this . put ( key , value instanceof JSONArray ? new JSONArray ( ) . put ( value ) : value ) ; } else if ( object instanceof JSONArray ) { ( ( JSONArray ) object ) . put ( value ) ; } else { this . put ( key , new JSONArray ( ) . put ( object ) . put ( value ) ) ; } return this ; }
tr	9	public void elemSelected ( ) { DefaultMutableTreeNode node = ( DefaultMutableTreeNode ) optionsTree . getLastSelectedPathComponent ( ) ; if ( node == null ) { return ; } if ( model . getSelectedNodes ( ) . isEmpty ( ) && model . getSelectedEdges ( ) . isEmpty ( ) ) { return ; } String name = node . toString ( ) ; switch ( name ) { case ( "Constraint" ) : model . addConstraint ( ) ; break ; case ( "Support Parameters" ) : model . addSupport ( ) ; break ; case ( "Force" ) : model . addForce ( ) ; break ; case ( "Pressure" ) : model . addPressure ( ) ; break ; case ( "Spring" ) : model . addSpring ( ) ; break ; case ( "Add Group" ) : model . addFluidFlow ( ) ; break ; default : System . out . println ( name ) ; break ; } model . setSelectedNodes ( new ArrayList < > ( ) ) ; model . setSelectedEdges ( new ArrayList < > ( ) ) ; }
tr	2	public void delete ( long id ) throws SQLException { try { connection . setAutoCommit ( false ) ; grupRepository . delete ( id ) ; connection . commit ( ) ; connection . setAutoCommit ( true ) ; } catch ( SQLException ex ) { try { connection . rollback ( ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; } throw new SQLException ( ex . toString ( ) ) ; } }
tr	0	public void setRunning ( boolean state ) { running = state ; }
tr	1	private String averageGrade ( final Student student ) { double averageGrade = student . averageGrade ( ) ; if ( averageGrade == - 1 ) { return "-" ; } return String . format ( "%.02f" , averageGrade ) ; }
tr	9	@ Override public boolean equals ( Object other ) { if ( ( this == other ) ) return true ; if ( ( other == null ) ) return false ; if ( ! ( other instanceof ComentariId ) ) return false ; ComentariId castOther = ( ComentariId ) other ; return ( ( this . getNomHotel ( ) == castOther . getNomHotel ( ) ) || ( this . getNomHotel ( ) != null && castOther . getNomHotel ( ) != null && this . getNomHotel ( ) . equals ( castOther . getNomHotel ( ) ) ) ) && ( ( this . getDniClient ( ) == castOther . getDniClient ( ) ) || ( this . getDniClient ( ) != null && castOther . getDniClient ( ) != null && this . getDniClient ( ) . equals ( castOther . getDniClient ( ) ) ) ) && ( ( this . getData ( ) == castOther . getData ( ) ) || ( this . getData ( ) != null && castOther . getData ( ) != null && this . getData ( ) . equals ( castOther . getData ( ) ) ) ) ; }
tr	4	protected static boolean refinePortal ( IShape shape1 , IShape shape2 ) { v2v1 . setSubtract ( e2 . v , e1 . v ) ; v3v1 . setSubtract ( e3 . v , e1 . v ) ; while ( true ) { dir . setCross ( v2v1 , v3v1 ) ; if ( dir . . ( e1 . v ) >= 0 ) return true ; MinkowskiDifference . getMaxSupport ( e4 , shape1 , shape2 , dir ) ; if ( dir . . ( e4 . v ) < 0 || portalReachTolerance ( dir ) ) { return false ; } expandPortal ( e4 ) ; } }
tr	9	private Object readValue ( ) throws JSONException { switch ( read ( 2 ) ) { case 0 : return new Integer ( read ( ! bit ( ) ? 4 : ! bit ( ) ? 7 : 14 ) ) ; case 1 : byte [ ] bytes = new byte [ 256 ] ; int length = 0 ; while ( true ) { int c = read ( 4 ) ; if ( c == endOfNumber ) { break ; } bytes [ length ] = bcd [ c ] ; length += 1 ; } Object value ; try { value = JSONObject . stringToValue ( new String ( bytes , 0 , length , "US-ASCII" ) ) ; } catch ( UnsupportedEncodingException e ) { throw new JSONException ( e ) ; } this . values . register ( value ) ; return value ; case 2 : return getAndTick ( this . values , this . bitreader ) ; case 3 : return readJSON ( ) ; default : throw new JSONException ( "Impossible." ) ; } }
tr	2	public ContextMenu getContextMenu ( final Modelverzameling mv ) { if ( contextMenu == null ) { contextMenu = new ContextMenu ( ) ; MenuItem menuItem1 = new MenuItem ( "Wat is het" ) ; menuItem1 . setOnAction ( new EventHandler < ActionEvent > ( ) { @ Override public void handle ( ActionEvent event ) { mv . getTekstVakModel ( ) . setText ( "Dit is een " + getName ( ) ) ; } } ) ; contextMenu . getItems ( ) . add ( menuItem1 ) ; if ( isEetbaar ( ) ) { MenuItem menuItem2 = new MenuItem ( "Eet" ) ; menuItem2 . setOnAction ( new EventHandler < ActionEvent > ( ) { @ Override public void handle ( ActionEvent event ) { eet ( mv ) ; } } ) ; contextMenu . getItems ( ) . add ( menuItem2 ) ; } } return contextMenu ; }
tr	7	private final void step6 ( ) { j = k ; if ( b [ k ] == e ) { int a = m ( ) ; if ( a > 1 || a == 1 && ! cvc ( k - 1 ) ) k -- ; } if ( b [ k ] == l && doublec ( k ) && m ( ) > 1 ) k -- ; }
tr	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( FormUtama . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( FormUtama . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( FormUtama . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( FormUtama . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { new FormUtama ( ) . setVisible ( true ) ; } } ) ; }
tr	2	@ Override public List < Service > getAllServices ( String clusterName ) { ServiceList serviceItems = http . get ( SERVICES_URL , ServiceList . class , clusterName ) ; if ( serviceItems == null || serviceItems . getItems ( ) == null ) { return new ArrayList < Service > ( ) ; } return serviceItems . getItems ( ) ; }
tr	9	public static void main ( String [ ] args ) { try { if ( args . length > 0 ) { for ( String arg : args ) { arg = arg . trim ( ) ; if ( arg . matches ( "app_root_dir=\\s*\\w+\\s*" ) ) { JediORMEngine . APP_ROOT_DIR = arg ; } else { JediORMEngine . APP_ROOT_DIR = System . getProperty ( "user.dir" ) ; } if ( arg . equals ( "web_app" ) ) { JediORMEngine . WEB_APP = true ; } if ( arg . matches ( "debug=\\s*true\\s*" ) ) { JediORMEngine . DEBUG = true ; } else if ( arg . matches ( "debug=\\s*false\\s*" ) ) { JediORMEngine . DEBUG = false ; } else { } } } else { JediORMEngine . APP_ROOT_DIR = System . getProperty ( "user.dir" ) ; } if ( JediORMEngine . WEB_APP ) { JediORMEngine . APP_SRC_DIR = String . format ( "%s%sweb%sWEB-INF%ssrc" , JediORMEngine . APP_ROOT_DIR , File . separator , File . separator , File . separator ) ; JediORMEngine . APP_DB_CONFIG_FILE = String . format ( "%s%sweb%sWEB-INF%sconfig%sdatabase.properties" , JediORMEngine . APP_ROOT_DIR , File . separator , File . separator , File . separator , File . separator ) ; File dbConfigFile = new File ( JediORMEngine . APP_DB_CONFIG_FILE ) ; if ( ! dbConfigFile . exists ( ) ) { JediORMEngine . APP_DB_CONFIG_FILE = String . format ( "%s%sweb%sWEB-INF%sdatabase.properties" , JediORMEngine . APP_ROOT_DIR , File . separator , File . separator , File . separator ) ; } } else { JediORMEngine . APP_SRC_DIR = String . format ( "%s%ssrc" , JediORMEngine . APP_ROOT_DIR , File . separator ) ; JediORMEngine . APP_DB_CONFIG_FILE = String . format ( "%s%sdatabase.properties" , JediORMEngine . APP_ROOT_DIR , File . separator ) ; } JediORMEngine . syncdb ( JediORMEngine . APP_SRC_DIR ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } }
tr	4	public boolean intersectsScreenSpace ( double x0 , double y0 , double x1 , double y1 ) { double xx = ( int ) ( Math . floor ( ( x - y ) * SCALE_X ) ) ; double yy = ( int ) ( Math . floor ( ( y + x - 6 ) * SCALE_Y ) ) ; int ww = 4 ; int hh = 6 ; if ( x1 <= xx - ww || x0 > xx + ww || y1 <= yy - hh || y0 > yy + hh ) return false ; return true ; }
tr	7	public static String getDayOfWeek ( int i ) { switch ( i ) { case 1 : return "Sunday" ; case 2 : return "Monday" ; case 3 : return "Tuesday" ; case 4 : return "Wednesday" ; case 5 : return "Thursday" ; case 6 : return "Friday" ; case 7 : return "Saturday" ; default : return ( "Invalid Day Number" ) ; } }
tr	5	private boolean load ( ) { if ( ! loc . exists ( ) ) { System . err . println ( "File " + loc . getAbsolutePath ( ) + " does not exist!" ) ; return false ; } if ( ! loc . getName ( ) . endsWith ( ".png" ) ) { System . err . println ( "File " + loc . getAbsolutePath ( ) + " is not a supported format!" ) ; return false ; } BufferedImage img = null ; try { img = ImageIO . read ( loc ) ; } catch ( Exception e ) { System . err . println ( e . getMessage ( ) ) ; return false ; } if ( img != null ) { size . set ( img . getWidth ( ) , img . getHeight ( ) ) ; pixels = img . getRGB ( 0 , 0 , getWidth ( ) , getHeight ( ) , pixels , 0 , getWidth ( ) ) ; for ( int i = 0 ; i < pixels . length ; i ++ ) { pixels [ i ] = pixels [ i ] & 00FFFFFF ; } } return true ; }
tr	9	public void run ( ) { if ( canceled . get ( ) ) return ; ObjectMessage msg = null ; if ( ! oneway ) { remoteSystem . requests . put ( request . requestId , this ) ; } try { while ( ! canceled . get ( ) && remoteSystem . running . get ( ) ) { try { if ( msg == null ) { Session session = remoteSystem . sendTemplate . getSession ( ) ; msg = session . createObjectMessage ( ) ; try { msg . setObject ( request ) ; msg . setLongProperty ( JMSRemoteSystem . MSG_PROP_OBJECT , request . objectId ) ; if ( oneway ) { msg . setJMSType ( JMSRemoteSystem . MSG_TYPE_ONEWAY ) ; } else { msg . setJMSType ( JMSRemoteSystem . MSG_TYPE_REQUEST ) ; msg . setLongProperty ( JMSRemoteSystem . MSG_PROP_REQUEST , request . requestId ) ; msg . setJMSReplyTo ( remoteSystem . sendTemplate . getLocalSystemQueue ( ) ) ; } } catch ( JMSException e ) { throw new MarshalException ( "Could not marshall request: " + e . getMessage ( ) , e ) ; } } Destination destination = remoteRef . getDestination ( ) ; MessageProducer producer = remoteSystem . sendTemplate . getMessageProducer ( ) ; producer . send ( destination , msg , deliveryMode , priority , timeout ) ; return ; } catch ( RemoteException e ) { setResponse ( new Response ( request . requestId , null , e ) ) ; return ; } catch ( TemplateClosedException tce ) { setResponse ( new Response ( request . requestId , null , tce ) ) ; return ; } catch ( Exception e ) { Throwable cause = e . getCause ( ) ; if ( cause != null && cause instanceof NotSerializableException ) { setResponse ( new Response ( request . requestId , null , e . getCause ( ) ) ) ; return ; } e . printStackTrace ( ) ; remoteSystem . sendTemplate . reset ( ) ; } } } finally { if ( oneway ) { setResponse ( new Response ( 0 , null , null ) ) ; } } if ( canceled . get ( ) ) { if ( ! oneway ) { remoteSystem . requests . remove ( request . requestId ) ; } } }
tr	4	private boolean isValidDatabasePath ( final String databasePath ) { final String methodName = "isValidDatabasePath" ; ControllerLogger . entering ( CLASS_NAME , methodName , databasePath ) ; try { if ( ( databasePath == null ) || ( "" . equals ( databasePath . trim ( ) ) ) ) { ControllerLogger . warning ( CLASS_NAME , methodName , "Database file path empty" ) ; return false ; } final File databaseFile = new File ( databasePath ) ; if ( ( databaseFile . exists ( ) ) && ( databaseFile . isFile ( ) ) ) { return databaseFile . getName ( ) . endsWith ( GUIConstants . DATABASE_FILE_EXTENSION ) ; } else { ControllerLogger . warning ( CLASS_NAME , methodName , "Database file path is not a file or a non-existing file: " + databasePath ) ; return false ; } } finally { ControllerLogger . exiting ( CLASS_NAME , methodName ) ; } }
tr	0	public ColorIndexesThreeColors ( int paintTime , byte [ ] values , byte color1 , byte color2 , byte color3 , int index1 , int index2 , int index3 ) { super ( paintTime , values , constructorHelperShift ( color1 , color2 , color3 , index1 , index2 , index3 ) ) ; }
tr	6	public char next ( ) throws JSONException { int c ; if ( this . usePrevious ) { this . usePrevious = false ; c = this . previous ; } else { try { c = this . reader . read ( ) ; } catch ( IOException exception ) { throw new JSONException ( exception ) ; } if ( c <= 0 ) { this . eof = true ; c = 0 ; } } this . index += 1 ; if ( this . previous == '' ) { this . line += 1 ; this . character = c == '' ? 0 : 1 ; } else if ( c == '' ) { this . line += 1 ; this . character = 0 ; } else { this . character += 1 ; } this . previous = ( char ) c ; return this . previous ; }
tr	3	public static boolean checkFileSizeExist ( String fn , long size ) { File file = new File ( fn ) ; if ( file . exists ( ) == true && file . isFile ( ) && file . length ( ) == size ) return true ; else return false ; }
tr	2	public void updateOrderDetails ( ) { BigDecimal total = BigDecimal . ZERO ; Iterator < OrderDetail > details = this . orderDetails . iterator ( ) ; while ( details . hasNext ( ) ) { OrderDetail detail = details . next ( ) ; if ( detail . getQuantity ( ) <= 0 ) { details . remove ( ) ; } else { total = total . add ( detail . getPrice ( ) ) ; } } total . setScale ( 2 , RoundingMode . HALF_UP ) ; this . totalOrderPrice = total ; }
tr	8	public String evaluateRiskColumn_innerMethod ( TransferredFile dbSQLDumpFileToTransfer , Context initialContext , long gid ) { System . err . println ( "Method evaluatePolicy_RiskinnerMethod  gid:" + gid + "  thread number:" + Thread . currentThread ( ) . getId ( ) ) ; logger . writeLog ( Level . ALL , "Method evaluatePolicy_RiskinnerMethod  gid:" + gid + "  thread number:" + Thread . currentThread ( ) . getId ( ) ) ; logger . writeLog ( Level . ALL , ( "DBA_utils-Instance #" + this . toString ( ) ) ) ; this . gid = gid ; DataHandler dbDumpFileDataHandler ; try { dbDumpFileDataHandler = convertZipFile ( dbSQLDumpFileToTransfer , dbSQLDumpFileToTransfer . getFileName ( ) ) ; } catch ( ZipException e2 ) { e2 . printStackTrace ( ) ; return "-1  Error: The given file is not a Zip file" ; } catch ( FileNotFoundException e2 ) { e2 . printStackTrace ( ) ; return "-2  Error: Impossible to find the specified file" ; } catch ( IOException e2 ) { e2 . printStackTrace ( ) ; return "-3  I/O Error" ; } Context initContext = null ; if ( initialContext == null ) { try { initContext = new InitialContext ( ) ; } catch ( NamingException e1 ) { e1 . printStackTrace ( ) ; } } else { initContext = initialContext ; } if ( initContext == null ) { return "-4  Error: Null context" ; } MySQLQueryFactory mySQLFactory = null ; try { mySQLFactory = setupAndApplyDBDump ( initContext , dbDumpFileDataHandler . getInputStream ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; return "-5  Problem with input DB dump" ; } if ( mySQLFactory == null ) { return "-5  Problem with input DB dump" ; } String result = columnRiskEvaluator ( mySQLFactory ) ; return result ; }
tr	1	public static void fecharConexao ( Connection con , Statement stm ) { try { con . close ( ) ; stm . close ( ) ; } catch ( SQLException ex ) { Logger . getLogger ( FabricaDeConexoes . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } }
tr	0	public Location ( int x , int y ) { this . x = x ; this . y = y ; }
tr	4	public static double sigLevelByApproxRand ( int [ ] A , int [ ] B , int iterations ) { if ( A . length == 0 ) throw new IllegalArgumentException ( "Input arrays must not be empty!" ) ; if ( A . length != B . length ) throw new IllegalArgumentException ( "Input arrays must have equal length!" ) ; if ( iterations <= 0 ) throw new IllegalArgumentException ( "Number of iterations must be positive!" ) ; double [ ] X = new double [ A . length ] ; double [ ] Y = new double [ B . length ] ; for ( int i = 0 ; i < A . length ; i ++ ) { X [ i ] = A [ i ] ; Y [ i ] = B [ i ] ; } return sigLevelByApproxRand ( X , Y , iterations ) ; }
tr	6	protected KeyboardEventListener parseKeyboardListener ( String keyboardListenerString ) { KeyboardEventListener rc = null ; if ( ! "" . equals ( keyboardListenerString ) ) { switch ( keyboardListenerString ) { case ( "SplashScreenKeyboardEventListener" ) : rc = new SplashScreenKeyboardEventListener ( ) ; break ; case ( "MenuKeyboardEventListener" ) : rc = new MenuKeyboardEventListener ( ) ; break ; case ( "OptionsMenuItemKeyboardEventListener" ) : rc = new OptionsMenuItemKeyboardEventListener ( ) ; break ; case ( "ExitMenuItemKeyboardEventListener" ) : rc = new ExitMenuItemKeyboardEventListener ( ) ; break ; case ( "OptionsMenuBackKeyboardEventListener" ) : rc = new OptionsMenuBackKeyboardEventListener ( ) ; break ; default : } } return rc ; }
tr	8	public void updateLICImage ( ) { if ( m_field . termBasePoints ( ) . getNumVertices ( ) == 0 ) { PdVector . setConstant ( m_vec . getVectors ( ) , 1 ) ; m_lic . startLIC ( ) ; return ; } PdVector [ ] V_y_field = new PdVector [ m_domain . getNumVertices ( ) ] ; for ( int i = 0 ; i < m_domain . getNumVertices ( ) ; ++ i ) { PdVector pos = m_domain . getVertex ( i ) ; PdMatrix eV = Utils . solveEigen2x2 ( m_field . evaluate ( pos ) , null , true ) ; PdVector E ; if ( m_direction . getSelectedItem ( ) == Direction . Major ) { E = eV . getRow ( 0 ) ; } else { E = eV . getRow ( 1 ) ; } PdVector V_x = PdVector . copyNew ( E ) ; if ( V_x . getEntry ( 0 ) < 0 ) { V_x . multScalar ( - 1 ) ; } PdVector V_y = PdVector . copyNew ( E ) ; if ( V_y . getEntry ( 1 ) < 0 ) { V_y . multScalar ( - 1 ) ; } assert V_x . getEntry ( 0 ) >= 0 ; assert V_y . getEntry ( 1 ) >= 0 ; m_vec . setVector ( i , V_x ) ; V_y_field [ i ] = V_y ; assert m_vec . getVector ( i ) . getSize ( ) == 2 : m_vec . getVector ( i ) . getSize ( ) ; } BufferedImage lic1 = generateLICImage ( ) ; for ( int i = 0 ; i < V_y_field . length ; ++ i ) { m_vec . setVector ( i , V_y_field [ i ] ) ; } BufferedImage lic2 = generateLICImage ( ) ; double [ ] [ ] weights = computeBlendWeights ( ) ; int width = m_lic . getTextureSize ( ) . width ; int height = m_lic . getTextureSize ( ) . height ; BufferedImage result = new BufferedImage ( width , height , BufferedImage . TYPE_INT_RGB ) ; for ( int i = 0 ; i < width ; i ++ ) { for ( int j = 0 ; j < height ; j ++ ) { double col = ( lic1 . getRGB ( i , j ) & ff ) * weights [ i ] [ j ] + ( lic2 . getRGB ( i , j ) & ff ) * ( 1 - weights [ i ] [ j ] ) ; result . setRGB ( i , j , Color . HSBtoRGB ( 0f , 0f , ( float ) col / 256 ) ) ; } } m_domain . getTexture ( ) . setImage ( result ) ; m_disp . update ( m_domain ) ; }
