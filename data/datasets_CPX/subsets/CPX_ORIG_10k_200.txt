tr	6	public int generalTree ( Set < Keyword > sensitiveWords , Map < String , Map > wordsTree ) { int len = 0 ; if ( sensitiveWords == null || sensitiveWords . isEmpty ( ) || wordsTree == null ) { return len ; } wordsTreeTmp . clear ( ) ; for ( Keyword w : sensitiveWords ) { if ( len == 0 ) { len = w . getWordLength ( ) ; } else if ( w . getWordLength ( ) < len ) { len = w . getWordLength ( ) ; } AnalysisUtils . makeTreeByWord ( wordsTreeTmp , w . getWord ( ) , w ) ; } wordsTree . clear ( ) ; wordsTree . putAll ( wordsTreeTmp ) ; return len ; }
tr	2	private void initNodes ( Object [ ] arguments ) { if ( arguments . length <= 0 || ! ( arguments [ 2 ] instanceof Map ) ) { return ; } nodeAgents = ( HashMap < AID , Coordinates > ) arguments [ 0 ] ; }
tr	4	public void merge ( final Object [ ] destSubs , final Object [ ] origSubs ) { Node origNode = findNode ( origSubs ) ; Node destNode = findNode ( destSubs ) ; if ( destNode == null ) { destNode = setting ( destSubs , null ) ; } if ( origNode == null ) { origNode = setting ( origSubs , null ) ; } if ( origNode . getValue ( ) != null ) { destNode . setValue ( origNode . getValue ( ) ) ; } if ( origNode . hasSubnodes ( ) ) { mergeSubnodesOperation . set ( destSubs , origSubs ) ; operateOverSubnodes ( origNode . getSubnode ( ) , mergeSubnodesOperation ) ; } }
tr	2	@ Override public int getInt ( long i ) { if ( ptr != 0 ) { return ( int ) ( Utilities . UNSAFE . getShort ( ptr + sizeof * i ) ) ; } else { if ( isConstant ( ) ) { return ( int ) data [ 0 ] ; } else { return ( int ) data [ ( int ) i ] ; } } }
tr	0	public String getBranch_id ( ) { retrieve ( ) ; return branch_id ; }
tr	8	public String toString ( ) { StringBuffer sb = new StringBuffer ( ) ; switch ( type ) { case TYPE_VALUE : sb . append ( "VALUE(" ) . append ( value ) . append ( ")" ) ; break ; case TYPE_LEFT_BRACE : sb . append ( "LEFT BRACE({)" ) ; break ; case TYPE_RIGHT_BRACE : sb . append ( "RIGHT BRACE(})" ) ; break ; case TYPE_LEFT_SQUARE : sb . append ( "LEFT SQUARE([)" ) ; break ; case TYPE_RIGHT_SQUARE : sb . append ( "RIGHT SQUARE(])" ) ; break ; case TYPE_COMMA : sb . append ( "COMMA( )" ) ; break ; case TYPE_COLON : sb . append ( "COLON(:)" ) ; break ; case TYPE_EOF : sb . append ( "END OF FILE" ) ; break ; } return sb . toString ( ) ; }
tr	6	public static void main ( String [ ] args ) { File file ; Scanner scan = null ; try { file = new File ( "workAreas.wrk" ) ; scan = new Scanner ( file ) ; HashMap < String , String > workAreaList = new HashMap < String , String > ( ) ; String area = null ; while ( scan . hasNext ( ) ) { String line = scan . nextLine ( ) ; if ( line . equals ( "" ) ) { area = null ; } else { if ( area == null ) { area = line ; } else { String [ ] split = line . replaceAll ( "[() ]" , "" ) . split ( " " ) ; for ( int i = 1 ; i < split . length ; i ++ ) { workAreaList . put ( "" + split [ 0 ] + split [ i ] , area ) ; } } } } System . out . print ( workAreaList ) ; } catch ( IOException e ) { } finally { if ( scan != null ) { scan . close ( ) ; } } }
tr	3	private void createList ( class < ? > c ) { if ( map . containsKey ( c ) ) { if ( map . get ( c ) == null ) { map . put ( c , new ArrayList < Listener > ( ) ) ; } } else { map . put ( c , new ArrayList < Listener > ( ) ) ; } }
tr	0	@ Override public List < Cliente > getByProperty ( String prop , Object val ) { return null ; }
tr	9	private void generateProblems ( StringBuilder builder , BookSettings settings , Map < String , List < String >> cached ) { int maxProblemColumns = settings . getProblemColumns ( ) ; int maxProblemRows = settings . getProblemRows ( ) ; int maxAnswerColumns = settings . getAnswerColumns ( ) ; int maxAnswerRows = settings . getAnswerRows ( ) ; for ( BookSettings . BookSection section : settings . getSections ( ) ) { StringBuilder problemPage = new StringBuilder ( ) ; StringBuilder problemRow = new StringBuilder ( ) ; StringBuilder problemRowComments = new StringBuilder ( ) ; StringBuilder answerPagesBuffer = new StringBuilder ( ) ; StringBuilder answerPage = new StringBuilder ( ) ; StringBuilder answerRow = new StringBuilder ( ) ; StringBuilder answerRowComments = new StringBuilder ( ) ; if ( section . getHeader ( ) != null ) { problemPage . append ( generateSubHeader ( section . getHeader ( ) ) ) ; answerPage . append ( generateSubHeader ( "Answers" , true ) ) ; } startPage ( problemPage , maxProblemColumns ) ; startPage ( answerPage , maxAnswerColumns ) ; int curProblemColumn = 0 ; int curProblemRow = 0 ; int curAnswerColumn = 0 ; int curAnswerRow = 0 ; int numAnswers = 0 ; int numProblems = 0 ; int totalNumProblems = 1 ; for ( String sgf : section . getProblems ( ) ) { List < String > generated = cached . get ( sgf ) ; String problem = generated . get ( 0 ) ; includeGraphics ( problemRow , problem ) ; addTableCell ( problemRow , curProblemColumn , maxProblemColumns ) ; includeComments ( problemRowComments , addProblemPrefix ( pdfInfo . getVariationComments ( problem ) , totalNumProblems ) ) ; addTableCell ( problemRowComments , curProblemColumn , maxProblemColumns ) ; if ( curProblemColumn == maxProblemColumns - 1 ) { problemPage . append ( problemRow ) . append ( problemRowComments ) ; problemRow = new StringBuilder ( ) ; problemRowComments = new StringBuilder ( ) ; } curProblemColumn = ( curProblemColumn + 1 ) % maxProblemColumns ; numProblems ++ ; for ( int i = 1 ; i <= settings . getVarsPerProblem ( ) && i < generated . size ( ) ; i ++ ) { String answer = generated . get ( i ) ; includeGraphics ( answerRow , answer ) ; addTableCell ( answerRow , curAnswerColumn , maxAnswerColumns ) ; includeComments ( answerRowComments , addProblemPrefix ( pdfInfo . getVariationComments ( answer ) , totalNumProblems ) ) ; addTableCell ( answerRowComments , curAnswerColumn , maxAnswerColumns ) ; if ( curAnswerColumn == maxAnswerColumns - 1 ) { answerPage . append ( answerRow ) . append ( answerRowComments ) ; answerRow = new StringBuilder ( ) ; answerRowComments = new StringBuilder ( ) ; } curAnswerColumn = ( curAnswerColumn + 1 ) % maxAnswerColumns ; numAnswers ++ ; if ( numAnswers == maxAnswerRows * maxAnswerColumns ) { finishPageWithTrailer ( answerPagesBuffer , answerPage ) ; answerPage = startNewPage ( maxAnswerColumns ) ; numAnswers = 0 ; } } totalNumProblems ++ ; if ( numProblems == maxProblemRows * maxProblemColumns ) { finishPageWithTrailer ( answerPagesBuffer , answerPage ) ; finishPageWithTrailer ( builder , problemPage ) ; finishPage ( builder , answerPagesBuffer ) ; answerPage = startNewPage ( maxAnswerColumns ) ; problemPage = startNewPage ( maxProblemColumns ) ; answerPagesBuffer = new StringBuilder ( ) ; numProblems = 0 ; numAnswers = 0 ; } } if ( answerPage . length ( ) != 0 ) { finishPageWithTrailer ( answerPagesBuffer , answerPage ) ; } if ( problemPage . length ( ) != 0 ) { finishPageWithTrailer ( builder , problemPage ) ; } finishPage ( builder , answerPagesBuffer ) ; } }
tr	8	public ListNode rotateRight ( ListNode head , int n ) { ListNode front = head ; ListNode end = head ; if ( n == 0 || head == null ) return head ; while ( n > 0 ) { if ( end == null ) end = head ; end = end . next ; n -- ; } if ( end == null ) { return head ; } while ( true ) { if ( end . next == null ) { end . next = head ; ListNode newHead = front . next ; front . next = null ; return newHead ; } if ( front == end ) { return null ; } front = front . next ; end = end . next ; } }
tr	3	public void method386 ( int i , String s , int j , int k , int l ) { if ( s == null ) return ; j -= getStringWidth ( s ) / 2 ; l -= charHeight ; for ( int i1 = 0 ; i1 < s . length ( ) ; i1 ++ ) { char c = s . charAt ( i1 ) ; if ( c !=   ) method392 ( aByteArrayArray1491 [ c ] , j + anIntArray1494 [ c ] , l + anIntArray1495 [ c ] + ( int ) ( Math . sin ( ( double ) i1 / 2D + ( double ) k / 5D ) * 5D ) , anIntArray1492 [ c ] , anIntArray1493 [ c ] , i ) ; j += anIntArray1496 [ c ] ; } }
tr	5	public static void main ( String [ ] args ) { Figura [ ] figuras = generaArrayFiguras ( 0.5 , 100 , 4 ) ; try { ObjectOutputStream writer = new ObjectOutputStream ( new FileOutputStream ( "test.dat" ) ) ; for ( Figura fig : figuras ) writer . writeObject ( fig ) ; writer . close ( ) ; } catch ( IOException ex ) { System . err . println ( ex . getMessage ( ) ) ; } List < Figura > nuevaFiguras = new ArrayList < > ( ) ; ObjectInputStream reader = null ; try { reader = new ObjectInputStream ( new FileInputStream ( "test.dat" ) ) ; while ( true ) nuevaFiguras . add ( ( Figura ) reader . readObject ( ) ) ; } catch ( IOException | ClassNotFoundException ex ) { } System . out . println ( "Figuras:" ) ; for ( Figura fig : nuevaFiguras ) System . out . println ( fig ) ; }
tr	4	private List < Player > getActivePlayers ( boolean skipSelf ) { List < Player > activePlayers = new ArrayList < > ( ) ; for ( Player player : players ) { if ( player . isActive ( ) ) { if ( skipSelf && player . getId ( ) == ownPlayer . getId ( ) ) { continue ; } activePlayers . add ( player ) ; } } return activePlayers ; }
tr	3	private void initAlleles ( ) { for ( int acIndex = 0 ; acIndex < accessionCount ; acIndex ++ ) { for ( int mIndex = 0 ; mIndex < markerCount ; mIndex ++ ) { int alCnt = alleleName . get ( mIndex ) . size ( ) ; dataMatrix . get ( acIndex ) . set ( mIndex , new ArrayList < double > ( alCnt ) ) ; for ( int alIndex = 0 ; alIndex < alCnt ; alIndex ++ ) { dataMatrix . get ( acIndex ) . get ( mIndex ) . add ( null ) ; } } } }
tr	6	@ Override public String getMessage ( ) { if ( this . server != null && this . server2 != null ) { return String . format ( "%s %s %s" , this . getCommandName ( ) , this . server , this . server2 ) ; } if ( this . server != null && this . server2 == null ) { return String . format ( "%s %s" , this . getCommandName ( ) , this . server ) ; } if ( this . server == null && this . server2 != null ) { return String . format ( "%s :%s" , this . getCommandName ( ) , this . server2 ) ; } throw new RuntimeException ( "This state should not happen. There is probably a bug in a constructor." ) ; }
tr	8	@ Override public void transform ( double [ ] src , double [ ] dst ) { for ( int i = 0 ; i < 3 ; i ++ ) temp2 [ i ] = src [ i ] ; temp2 [ 3 ] = 1 ; for ( int i = 0 ; i < 3 ; i ++ ) { dst [ i ] = 0 ; for ( int j = 0 ; j < 4 ; j ++ ) { dst [ i ] += matrix [ i ] [ j ] * temp2 [ j ] ; } } for ( int i = 0 ; i < 4 ; i ++ ) { for ( int j = 0 ; j < 4 ; j ++ ) { copy [ i ] [ j ] = matrix [ i ] [ j ] ; } } Invert . invert ( copy , inverseMatrix ) ; transpose ( inverseMatrix , inverseMatrixTranspose ) ; for ( int i = 0 ; i < 3 ; i ++ ) temp2 [ i ] = src [ i + 3 ] ; temp2 [ 3 ] = 0 ; for ( int i = 0 ; i < 3 ; i ++ ) { dst [ i + 3 ] = 0 ; for ( int j = 0 ; j < 4 ; j ++ ) { dst [ i + 3 ] += inverseMatrixTranspose [ i ] [ j ] * temp2 [ j ] ; } } }
tr	7	public static boolean searchMatrix ( int [ ] [ ] matrix , int target ) { if ( matrix == null || matrix . length == 0 || matrix [ 0 ] . length == 0 ) return false ; if ( target < matrix [ 0 ] [ 0 ] ) return false ; int row = search ( matrix , target ) ; int i = 0 ; int j = matrix [ row ] . length - 1 ; while ( i <= j ) { int mid = ( i + j ) / 2 ; if ( matrix [ row ] [ mid ] == target ) { return true ; } else if ( matrix [ row ] [ mid ] < target ) { i = mid + 1 ; } else { j = mid - 1 ; } } return false ; }
tr	7	public boolean verifyInput ( ) { name = name . replace ( "'" , "" ) ; location = location . replace ( "'" , "" ) ; if ( mainMenu_id < 0 || vegMenu_id < 0 || client_id < 0 ) { return false ; } if ( numGuests < 0 || totalLengthOfEvent < 0 ) { return false ; } if ( ! status . matches ( "pending" ) && ! status . matches ( "confirmed" ) ) { return false ; } return true ; }
tr	4	private void txtEdgeCostKeyPressed ( java . awt . event . KeyEvent evt ) { if ( evt . getKeyCode ( ) == 10 ) { if ( ! txtVertexName . getText ( ) . isEmpty ( ) && txtVertexName . getText ( ) . length ( ) != 0 ) { drawing . addVertex ( txtVertexName . getText ( ) ) ; txtVertexName . setText ( "" ) ; } int cost = 1 ; if ( ! txtEdgeCost . getText ( ) . isEmpty ( ) ) { cost = Integer . parseInt ( txtEdgeCost . getText ( ) ) ; } drawing . addEdge ( cost ) ; txtEdgeCost . setText ( "" ) ; txtVertexName . requestFocus ( ) ; } }
tr	2	private void selectElement ( MouseEvent e ) { if ( e . getButton ( ) == MouseEvent . BUTTON1 && e . getSource ( ) != table ) table . clearSelection ( ) ; }
tr	7	public void run ( ) { try { while ( true ) { EntityTable e = ( EntityTable ) in . readObject ( ) ; if ( e . getType ( ) . equals ( "update" ) ) { historyList . clear ( ) ; listElement . clear ( ) ; while ( true ) { EntityTable e1 = ( EntityTable ) in . readObject ( ) ; if ( e1 . getType ( ) . equals ( "end" ) ) { break ; } else if ( e1 . getType ( ) . equals ( "HistoryInfo" ) ) { HistoryInfo hi = ( HistoryInfo ) e1 ; historyList . add ( hi ) ; listElement . add ( hi . getHistoryId ( ) ) ; } } historyIdList . setListData ( listElement ) ; historyIdList . updateUI ( ) ; } historyIdList . setSelectedIndex ( - 1 ) ; } } catch ( IOException ex ) { Logger . getLogger ( DeliverClient . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( ClassNotFoundException ex ) { Logger . getLogger ( DeliverClient . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } }
tr	3	public void setNumberType ( int type ) { if ( renderer != null ) { renderer . removeListener ( this ) ; } if ( type == BenoitNumber . DOUBLE_TYPE ) { renderer = new FastDoublesRenderer ( ) ; } else if ( type == BenoitNumber . BIG_TYPE ) { renderer = new BigDecimalRenderer ( ) ; } else { throw new IllegalArgumentException ( "invalid number type" ) ; } numericType = type ; getParameters ( ) . setType ( type ) ; renderer . addListener ( this ) ; fireChange ( RENDERER_CHANGED ) ; }
tr	1	public String showDisplay ( Connection aconn ) { CCodeDesc series = new CCodeDesc ( aconn , "SeriesTbl" , "SeriesCd" , "SeriesNm" , "SeriesCd" ) ; CCodeDesc results = new CCodeDesc ( aconn , "EvalResultTbl" , "ResultCd" , "ResultNm" , "ResultCd" ) ; String retstr = " <table class=\"result\" >" ; retstr = retstr + "<tr>" ; retstr = retstr + "<td class=\"restitleleft\" >&nbsp;&nbsp;Evaluation Results</td> </tr> </table>" ; retstr = retstr + "<table class='factors' summary='next dose evaluation'>\n" ; retstr = retstr + "<col style='width:20%'><col style='width:15%'><col style='width:5%'>" ; retstr = retstr + "<col style='width:3%'><col style='width:3%'><col style='width:3%'><col style='width:3%'><col style='width:8%'>" ; retstr = retstr + "<col style='width:3%'><col style='width:3%'><col style='width:3%'><col style='width:3%'><col style='width:8%'>" ; retstr = retstr + "<col style='width:3%'><col style='width:3%'><col style='width:3%'><col style='width:3%'><col style='width:8%'>" ; retstr = retstr + "<tr>\n" ; retstr = retstr + " <td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td class='subtitle' style='border-bottom-color: #0066FF;' colspan='5'>Accelerated Schedule</td><td class='subtitle' style='border-bottom-color: #00CC00;' colspan='5'>Recommended Schedule</td><td class='subtitle'  style='border-bottom-color: #FF6600;' colspan='5'>Overdue Schedule</td></tr><tr>" ; retstr = retstr + "<th class='factors' scope='col'>Series</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Status</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Dose</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Yrs</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Mos</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Wks</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Dys</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Acc Date</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Yrs</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Mos</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Wks</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Dys</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Rec Date</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Yrs</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Mos</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Wks</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Dys</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Ovr Date</th></tr>\n" ; for ( int idx = 0 ; idx < this . getCount ( ) ; idx ++ ) { CEvalItem myitem = ( CEvalItem ) this . getItem ( idx ) ; retstr = retstr + "<tr>\n" ; retstr = retstr + "<td class='result'>" + series . getDescByCode ( myitem . seriescd ) + "</td>\n" ; retstr = retstr + "<td class='result'>" + results . getDescByCode ( myitem . resultcd ) + "</td>\n" ; retstr = retstr + "<td class='factors'>" + Integer . toString ( myitem . doseord ) + "</td>\n" ; retstr = retstr + "<td class='factors' name='EAyrs" + idx + "' id='EAyrs" + idx + "'></td>\n" ; retstr = retstr + "<td class='factors' name='EAmos" + idx + "' id='EAmos" + idx + "'></td>\n" ; retstr = retstr + "<td class='factors' name='EAwks" + idx + "' id='EAwks" + idx + "'></td>\n" ; retstr = retstr + "<td class='factors' name='EAdys" + idx + "' id='EAdys" + idx + "'></td>\n" ; retstr = retstr + "<td class='factors' name='EAdate" + idx + "' id='EAdate" + idx + "'>" + myitem . getAccelDateStr ( ) + "</td>\n" ; retstr = retstr + "<td class='factors' name='ERyrs" + idx + "' id='ERyrs" + idx + "'></td>\n" ; retstr = retstr + "<td class='factors' name='ERmos" + idx + "' id='ERmos" + idx + "'></td>\n" ; retstr = retstr + "<td class='factors' name='ERwks" + idx + "' id='ERwks" + idx + "'></td>\n" ; retstr = retstr + "<td class='factors' name='ERdys" + idx + "' id='ERdys" + idx + "'></td>\n" ; retstr = retstr + "<td class='factors' name='ERdate" + idx + "' id='ERdate" + idx + "'>" + myitem . getRecomDateStr ( ) + "</td>\n" ; retstr = retstr + "<td class='factors' name='EOyrs" + idx + "' id='EOyrs" + idx + "'></td>\n" ; retstr = retstr + "<td class='factors' name='EOmos" + idx + "' id='EOmos" + idx + "'></td>\n" ; retstr = retstr + "<td class='factors' name='EOwks" + idx + "' id='EOwks" + idx + "'></td>\n" ; retstr = retstr + "<td class='factors' name='EOdys" + idx + "' id='EOdys" + idx + "'></td>\n" ; retstr = retstr + "<td class='factors' name='EOdate" + idx + "' id='EOdate" + idx + "'>" + myitem . getOverdueDateStr ( ) + "</td>\n" ; retstr = retstr + "</tr>\n" ; } retstr = retstr + "</table><br>\n" ; return ( retstr ) ; }
tr	8	protected void containerItemSwappingLogic ( ) { if ( secondairyInventory != null ) if ( KeyHandler . isValidationKeyPressed ( ) ) if ( isNotPlayerInventory ( ) && secondairyInventory != null ) { System . out . println ( slot_index ) ; if ( secondairyInventory . getStackInSlot ( slot_index ) != null ) if ( playerInventory . setStackInNextAvailableSlot ( secondairyInventory . getStackInSlot ( slot_index ) ) ) secondairyInventory . setStackInSlot ( slot_index , null ) ; } else { int slot = slotIndex [ 0 ] + ( slotIndex [ 1 ] * ( rowsX ( ) ) ) ; System . out . println ( slot ) ; if ( playerInventory . getStackInSlot ( slot ) != null ) if ( secondairyInventory . setStackInNextAvailableSlot ( playerInventory . getStackInSlot ( slot ) ) ) playerInventory . setStackInSlot ( slot , null ) ; } }
tr	1	public void test_playing_media ( ) { if ( mediaplayer != null ) { destroy ( ) ; use_video . reset_controls ( ) ; use_video . reset_video ( ) ; use_video . reset_flags ( ) ; } }
tr	3	private void initComponents ( ) { GridLayout layout = new GridLayout ( rows , cols , 1 , 1 ) ; this . setLayout ( layout ) ; MouseListener listener = new MouseListener ( ) { @ Override public void mouseClicked ( MouseEvent e ) { JLabel tile = ( JLabel ) e . getSource ( ) ; tile . setBorder ( UNSELECTED_BORDER ) ; color = tile . getBackground ( ) ; fireActionPerformed ( new ActionEvent ( this , ActionEvent . ACTION_PERFORMED , tile . getBackground ( ) . toString ( ) ) ) ; } @ Override public void mousePressed ( MouseEvent e ) { } @ Override public void mouseReleased ( MouseEvent e ) { } @ Override public void mouseEntered ( MouseEvent e ) { JLabel tile = ( JLabel ) e . getSource ( ) ; tile . setBorder ( SELECTED_BORDER ) ; } @ Override public void mouseExited ( MouseEvent e ) { JLabel tile = ( JLabel ) e . getSource ( ) ; tile . setBorder ( UNSELECTED_BORDER ) ; } } ; for ( int i = 0 ; i < cols ; i ++ ) { JLabel tile = new JLabel ( ) ; tile . setOpaque ( true ) ; tile . setBorder ( UNSELECTED_BORDER ) ; int rgb = ( int ) ( i * 255 / ( cols - 1 ) ) ; tile . setBackground ( new Color ( rgb , rgb , rgb ) ) ; tile . setToolTipText ( "R:" + rgb + "  G:" + rgb + "  B:" + rgb ) ; tile . addMouseListener ( listener ) ; add ( tile ) ; } for ( float i = 0 ; i < rows - 1 ; i ++ ) { for ( float j = 0 ; j <= 0.8f ; j += 0.8f / ( cols - 1 ) ) { JLabel tile = new JLabel ( ) ; tile . setOpaque ( true ) ; tile . setBorder ( UNSELECTED_BORDER ) ; Color tileColor = Color . getHSBColor ( i / rows , 1.0f - j , 1 ) ; tile . setBackground ( tileColor ) ; tile . setToolTipText ( "R:" + tileColor . getRed ( ) + "  G:" + tileColor . getGreen ( ) + "  B:" + tileColor . getBlue ( ) ) ; tile . addMouseListener ( listener ) ; add ( tile ) ; } } setPreferredSize ( new Dimension ( tileSize * cols , tileSize * rows ) ) ; }
tr	0	public JTextField getTextNombre ( ) { return TextNombre ; }
tr	8	void setPendingViewOffset ( int xofs , int yofs ) { if ( ! pf_wrapx ) { if ( xofs < 0 ) xofs = 0 ; if ( xofs > tilex * ( nrtilesx - viewnrtilesx ) ) xofs = tilex * ( nrtilesx - viewnrtilesx ) ; } if ( ! pf_wrapy ) { if ( yofs < 0 ) yofs = 0 ; if ( yofs > tiley * ( nrtilesy - viewnrtilesy ) ) yofs = tiley * ( nrtilesy - viewnrtilesy ) ; } pendingxofs = xofs ; pendingyofs = yofs ; for ( int i = 0 ; i < bg_images . size ( ) ; i ++ ) { BGImage bgimg = ( BGImage ) bg_images . elementAt ( i ) ; if ( bgimg != null ) { bgimg . xofs = xofs ; bgimg . yofs = yofs ; } } }
tr	4	private int getGameScore ( Game game ) { int result = 0 ; int tagworth = 1 ; int gameworth = 3 ; for ( Player p : activePlayers ) { if ( p . doesLikeGame ( game ) ) { result += gameworth ; } for ( Tag tag : game . getTags ( ) ) { if ( p . doesLikeTag ( tag ) ) { result += tagworth ; } } } return result ; }
tr	7	private void populate ( ) { Random rand = Randomizer . getRandom ( ) ; field . clear ( ) ; int Number_of_foxes = 0 ; int Number_of_rabbits = 0 ; int Number_of_korenwolfs = 0 ; for ( int row = 0 ; row < field . getDepth ( ) ; row ++ ) { for ( int col = 0 ; col < field . getWidth ( ) ; col ++ ) { if ( rand . nextDouble ( ) <= KORENWOLF_CREATION_PROBABILITY ) { Location location = new Location ( row , col ) ; Korenwolf korenwolf = new Korenwolf ( true , field , location ) ; actors . add ( korenwolf ) ; Number_of_korenwolfs ++ ; } else if ( rand . nextDouble ( ) <= FOX_CREATION_PROBABILITY ) { Location location = new Location ( row , col ) ; Fox fox = new Fox ( true , field , location ) ; actors . add ( fox ) ; Number_of_foxes ++ ; } else if ( rand . nextDouble ( ) <= RABBIT_CREATION_PROBABILITY ) { Location location = new Location ( row , col ) ; Rabbit rabbit = new Rabbit ( true , field , location ) ; actors . add ( rabbit ) ; Number_of_rabbits ++ ; } else if ( rand . nextDouble ( ) <= HUNTER_CREATION_PROBABILITY ) { Location location = new Location ( row , col ) ; Hunter hunter = new Hunter ( field , location ) ; actors . add ( hunter ) ; } else if ( rand . nextDouble ( ) <= 0.03 ) { Location location = new Location ( row , col ) ; Grass grass = new Grass ( field , location ) ; actors . add ( grass ) ; } } } Rabbit . PERFECT_NUMBER_OF_RABBITS = Number_of_rabbits ; Fox . PERFECT_NUMBER_OF_FOXES = Number_of_foxes ; Korenwolf . PERFECT_NUMBER_OF_KORENWOLFS = Number_of_korenwolfs ; }
tr	3	@ Override public void actionPerformed ( ActionEvent e ) { Object src = e . getSource ( ) ; if ( src . equals ( newGame ) ) { } else if ( src . equals ( continueBtn ) ) { } else if ( src . equals ( instructionsBtn ) ) { ( ( CardLayout ) getLayout ( ) ) . show ( this , "instructions" ) ; } }
tr	3	@ Override public void setValue ( final Map < String , Value < ? >> value ) { if ( value == null ) { throw new NullPointerException ( ) ; } this . value = new TreeMap < String , Value < ? >> ( value ) ; }
tr	1	@ AfterClass public static void tearDownClass ( ) throws Exception { if ( session != null ) { AbsoluteDiscountPreuStrategy adps = ( AbsoluteDiscountPreuStrategy ) session . get ( AbsoluteDiscountPreuStrategy . class , new PreuTipusHabitacioId ( nomHotel , nomTipus ) ) ; session . delete ( adps ) ; PreuTipusHabitacio pth = ( PreuTipusHabitacio ) session . get ( PreuTipusHabitacio . class , new PreuTipusHabitacioId ( nomHotel , nomTipus ) ) ; session . delete ( pth ) ; Hotel hotel = ( Hotel ) session . get ( Hotel . class , nomHotel ) ; session . delete ( hotel ) ; TipusHabitacio tipus = ( TipusHabitacio ) session . get ( TipusHabitacio . class , nomTipus ) ; session . delete ( tipus ) ; session . getTransaction ( ) . commit ( ) ; } }
tr	7	public char leerDato ( ) { char dato ; if ( isESTA_EN_RAM ( ) ) { if ( pos < data . length ( ) ) { dato = data . charAt ( pos ) ; } else { throw new IndexOutOfBoundsException ( ) ; } } else { if ( "" . equals ( prox ) && lector . hasNext ( ) ) { prox = lector . next ( ) ; } else if ( "" . equals ( prox ) ) { throw new IndexOutOfBoundsException ( ) ; } else if ( pos >= prox . length ( ) ) { pos = 0 ; if ( lector . hasNext ( ) ) { prox = lector . next ( ) ; } else { throw new IndexOutOfBoundsException ( ) ; } } dato = prox . charAt ( pos ) ; } pos ++ ; return dato ; }
tr	7	public static Object decodeToObject ( String encodedObject , int options , final ClassLoader loader ) throws java . io . IOException , java . lang . ClassNotFoundException { byte [ ] objBytes = decode ( encodedObject , options ) ; java . io . ByteArrayInputStream bais = null ; java . io . ObjectInputStream ois = null ; Object obj = null ; try { bais = new java . io . ByteArrayInputStream ( objBytes ) ; if ( loader == null ) { ois = new java . io . ObjectInputStream ( bais ) ; } else { ois = new java . io . ObjectInputStream ( bais ) { @ Override public class < ? > resolveClass ( java . io . ObjectStreamClass streamClass ) throws java . io . IOException , ClassNotFoundException { class c = class . forName ( streamClass . getName ( ) , false , loader ) ; if ( c == null ) { return super . resolveClass ( streamClass ) ; } else { return c ; } } } ; } obj = ois . readObject ( ) ; } catch ( java . io . IOException e ) { throw e ; } catch ( java . lang . ClassNotFoundException e ) { throw e ; } finally { try { bais . close ( ) ; } catch ( Exception e ) { } try { ois . close ( ) ; } catch ( Exception e ) { } } return obj ; }
tr	5	public void read_scalefactor ( Bitstream stream , Header header ) { super . read_scalefactor ( stream , header ) ; if ( channel2_allocation != 0 ) { switch ( channel2_scfsi ) { case 0 : channel2_scalefactor1 = scalefactors [ stream . get_bits ( 6 ) ] ; channel2_scalefactor2 = scalefactors [ stream . get_bits ( 6 ) ] ; channel2_scalefactor3 = scalefactors [ stream . get_bits ( 6 ) ] ; break ; case 1 : channel2_scalefactor1 = channel2_scalefactor2 = scalefactors [ stream . get_bits ( 6 ) ] ; channel2_scalefactor3 = scalefactors [ stream . get_bits ( 6 ) ] ; break ; case 2 : channel2_scalefactor1 = channel2_scalefactor2 = channel2_scalefactor3 = scalefactors [ stream . get_bits ( 6 ) ] ; break ; case 3 : channel2_scalefactor1 = scalefactors [ stream . get_bits ( 6 ) ] ; channel2_scalefactor2 = channel2_scalefactor3 = scalefactors [ stream . get_bits ( 6 ) ] ; break ; } prepare_sample_reading ( header , channel2_allocation , 1 , channel2_factor , channel2_codelength , channel2_c , channel2_d ) ; } }
tr	0	public Object [ ] formatoTabela ( FonteFinanciamento fontefinanciamento ) { return new Object [ ] { fontefinanciamento . getId ( ) , fontefinanciamento . getNome ( ) } ; }
tr	1	public List < long > getStudentIDs ( ) { if ( studentIDs == null ) { studentIDs = new ArrayList < long > ( ) ; } return this . studentIDs ; }
tr	0	public boolean isFinished ( ) { return isFinished ; }
tr	5	public ArrayList < ClosedTransaction > closeLong ( TransactionHistory th ) { int closeAmount = th . getAmount ( ) * - 1 ; if ( this . openAmount <= 0 || closeAmount <= 0 ) { throw new InvalidCloseAction ( ) ; } double closePrice = th . getPrice ( ) ; Date closeTime = th . getTime ( ) ; if ( closeAmount > this . openAmount ) { throw new NotEnoughAmountToClose ( closeAmount ) ; } this . openAmount -= closeAmount ; ArrayList < ClosedTransaction > closed = new ArrayList < ClosedTransaction > ( ) ; int remainToClose = closeAmount ; while ( remainToClose > 0 ) { OpenTransaction node = this . openList . getFirst ( ) ; int nodeAmount = node . getOpenAmount ( ) ; if ( remainToClose >= nodeAmount ) { ClosedTransaction ct = node . close ( closeTime , closePrice , nodeAmount ) ; closed . add ( ct ) ; this . openList . removeFirst ( ) ; remainToClose -= nodeAmount ; } else { ClosedTransaction ct = node . close ( closeTime , closePrice , remainToClose ) ; closed . add ( ct ) ; node . setOpenAmount ( nodeAmount - remainToClose ) ; remainToClose = 0 ; } } return closed ; }
tr	4	public Builder touPricing ( String [ ] froms , String [ ] tos , double [ ] prices ) { if ( ! type . equals ( "TOUPricing" ) ) { System . err . println ( "PricingPolicy type mismatch: method only applicable to the TOUPricing scheme" ) ; return this ; } if ( ! ( froms . length == tos . length && tos . length == prices . length ) ) { System . err . println ( "PricingPolicy initialization error: all input tables must have the same length" ) ; return this ; } for ( int i = 0 ; i < froms . length ; i ++ ) { String from = froms [ i ] ; String to = tos [ i ] ; double price = prices [ i ] ; Period p = new Period ( from , to , price ) ; periods . add ( p ) ; } return this ; }
tr	6	public void convertItemToHtml ( XmlPullParser parser , XmlSerializer writer ) throws IOException , XmlPullParserException { writer . startTag ( null , "p" ) ; String title = null , link = null , description = null ; while ( parser . nextTag ( ) != XmlPullParser . END_TAG ) { if ( parser . getName ( ) . equals ( "title" ) ) { title = parser . nextText ( ) ; } else if ( parser . getName ( ) . equals ( "link" ) ) { link = parser . nextText ( ) ; } else if ( parser . getName ( ) . equals ( "description" ) ) { description = parser . nextText ( ) ; } } writer . startTag ( null , "a" ) ; writer . attribute ( null , "href" , link ) ; if ( title != null ) { writer . text ( title ) ; } else { writer . text ( link ) ; } writer . endTag ( null , "a" ) ; writer . startTag ( null , "br" ) . endTag ( null , "br" ) ; if ( description != null ) writer . text ( description ) ; writer . endTag ( null , "p" ) ; }
tr	3	public static void applyShading ( Mesh m , view3D view ) { m . ensureVertBuffers ( ) ; m . transformVertices ( m . getMatrix ( ) , null ) ; for ( int i = 0 ; i < m . elements . size ( ) ; i ++ ) { Renderable e = m . elem ( i ) ; if ( e . type != RENDERABLE_FACE ) continue ; Face f = ( Face ) e ; { int a = f . v0 * 3 , b = f . v1 * 3 , c = f . v2 * 3 ; sVect . x = m . viewVert [ a + 0 ] - m . viewVert [ c + 0 ] ; sVect . y = m . viewVert [ a + 1 ] - m . viewVert [ c + 1 ] ; sVect . z = m . viewVert [ a + 2 ] - m . viewVert [ c + 2 ] ; tVect . x = m . viewVert [ b + 0 ] - m . viewVert [ c + 0 ] ; tVect . y = m . viewVert [ b + 1 ] - m . viewVert [ c + 1 ] ; tVect . z = m . viewVert [ b + 2 ] - m . viewVert [ c + 2 ] ; FPoint3 . crossProduct ( sVect , tVect , cProd ) ; cProd . normalize ( ) ; double sine = - FPoint3 . dotProduct ( cProd , view . lightDir ( ) ) ; double currLevel = f . getShade ( ) * .75 ; if ( sine > 0 ) { currLevel = ( 1.0 + sine ) * currLevel ; } f . setShade ( ( int ) currLevel ) ; } } }
tr	2	public boolean isSet ( _Fields field ) { if ( field == null ) { throw new IllegalArgumentException ( ) ; } switch ( field ) { case GET_LANG : return isSetGetLang ( ) ; } throw new IllegalStateException ( ) ; }
tr	1	public void handlePorterCommand ( CreateGame command ) { if ( this . gameThread != null ) { sendResponse ( new Err_Badcommand ( ) ) ; return ; } this . gameThread = new GameThread ( this ) ; System . out . println ( "New game created with gameID: " + this . gameThread . getGameID ( ) ) ; GameThreadMap . getInstance ( ) . put ( gameThread . getGameID ( ) , gameThread ) ; Server . pool . execute ( this . gameThread ) ; sendResponse ( new Rpl_Gamecreated ( ) ) ; }
tr	2	public GameBoard ( int mines , int height , int width ) { board = new Square [ height ] [ width ] ; for ( int i = 0 ; i < height ; i ++ ) { for ( int j = 0 ; j < width ; j ++ ) { board [ i ] [ j ] = new Square ( ) ; } } this . mines = mines ; this . height = height ; this . width = width ; }
tr	3	public Decision askDecision ( Player p , State s ) { PlayerState ps = s . currentPlayerState ( ) ; System . out . println ( "---" ) ; System . out . println ( "player: " + p . name ( ) ) ; System . out . println ( "railways: " + ps . railways ) ; System . out . println ( "missions: " + ps . missions ) ; System . out . println ( "hand: " + ps . hand ) ; System . out . println ( "open deck: " + s . openCards ( ) ) ; if ( ps . drawn_card != null ) System . out . println ( "you just drew a " + ps . drawn_card + "  you must choose from where to draw your second card" ) ; if ( ps . drawn_missions != null ) System . out . println ( "you just drew missions " + ps . drawn_missions + "  you must decide which to keep" ) ; Decision d = null ; do { System . out . print ( "? " ) ; String [ ] words = get_words ( ) ; d = interpret ( words , ps . handle ) ; } while ( d == null ) ; return d ; }
tr	8	public boolean equals ( delete_queue_args that ) { if ( that == null ) return false ; boolean this_present_queue_name = true && this . is_set_queue_name ( ) ; boolean that_present_queue_name = true && that . is_set_queue_name ( ) ; if ( this_present_queue_name || that_present_queue_name ) { if ( ! ( this_present_queue_name && that_present_queue_name ) ) return false ; if ( ! this . queue_name . equals ( that . queue_name ) ) return false ; } return true ; }
tr	9	public void actionPerformed ( ActionEvent e ) { if ( GridButton . class . isInstance ( e . getSource ( ) ) ) { GridButton b = ( GridButton ) e . getSource ( ) ; switch ( b . getColumn ( ) ) { case ( 0 ) : { client . openFile ( networkFiles . get ( b . getRow ( ) ) ) ; break ; } case ( 1 ) : { int n = JOptionPane . showConfirmDialog ( this , "Delete " + networkFiles . get ( b . getRow ( ) ) + " from the network?" , "Are you sure?" , JOptionPane . YES_NO_OPTION ) ; if ( n == 0 ) client . deleteFileFromNetwork ( networkFiles . get ( b . getRow ( ) ) ) ; break ; } case ( 2 ) : { int n = JOptionPane . showConfirmDialog ( this , "Delete " + networkFiles . get ( b . getRow ( ) ) + " locally?" , "Are you sure?" , JOptionPane . YES_NO_OPTION ) ; if ( n == 0 ) client . deleteLocalFile ( networkFiles . get ( b . getRow ( ) ) ) ; break ; } default : { break ; } } } else if ( JButton . class . isInstance ( e . getSource ( ) ) ) { JButton b = ( JButton ) e . getSource ( ) ; if ( b == loginButton ) { this . updateStatusLabel ( "Logging into the system. Please wait..." ) ; client . loginSystem ( ) ; } else if ( b == logoutButton ) { this . updateStatusLabel ( "Logging out the system. Please wait..." ) ; logoutStatusWindow = new LogoutStatusWindow ( this ) ; new Thread ( new Runnable ( ) { @ Override public void run ( ) { client . logoutSystem ( ) ; } } ) . start ( ) ; } else if ( b == addFileButton ) { if ( client . getSessionState ( ) ) { int returnValue = fileChooser . showOpenDialog ( this ) ; if ( returnValue == JFileChooser . APPROVE_OPTION ) { client . importFile ( fileChooser . getSelectedFile ( ) ) ; } } } else if ( b == infoButton ) { LinkedNodesWindow l = new LinkedNodesWindow ( this ) ; client . TESTprintOwnerFiles ( ) ; } else if ( b == settingsButton ) { SettingsWindow s = new SettingsWindow ( this ) ; } } }
tr	1	private Request getBaseRequest ( Iterator < String > titles ) { try { Request ret = new Request ( BASE ) ; String joinedTitles = combineStrings ( titles , 50 ) ; ret . addQuery ( TITLES_KEY , joinedTitles ) ; return ret ; } catch ( MalformedURLException impossible ) { impossible . printStackTrace ( ) ; return null ; } }
tr	3	public boolean writeObject ( Object o ) throws ConnectionLostException { if ( socket == null ) throw new ConnectionLostException ( ) ; if ( o != null ) { try { oos . reset ( ) ; oos . writeObject ( o ) ; oos . flush ( ) ; return true ; } catch ( IOException e ) { System . err . println ( "Socket Exception: Cannot write to socket." ) ; socket = null ; throw new ConnectionLostException ( "Socket Exception: Cannot write to socket." ) ; } } return false ; }
tr	7	boolean testAndSet ( Obstacle obs ) { if ( isDirty ) return false ; if ( excludedObstacles . contains ( obs ) ) return false ; Segment seg1 = new Segment ( obs . topLeft , obs . bottomRight ) ; Segment seg2 = new Segment ( obs . topRight , obs . bottomLeft ) ; for ( int s = 0 ; s < points . size ( ) - 1 ; s ++ ) { points . getPoint ( CURRENT , s ) ; points . getPoint ( NEXT , s + 1 ) ; if ( seg1 . intersects ( CURRENT , NEXT ) || seg2 . intersects ( CURRENT , NEXT ) || obs . contains ( CURRENT ) || obs . contains ( NEXT ) ) { isDirty = true ; return true ; } } return false ; }
tr	5	private static List < ABObject > GetSupporteeShel ( List < ABObject > left , ABObject roof ) { List < ABObject > temp = new ArrayList < ABObject > ( ) ; ABObject leftRoof = null ; for ( int i = 0 ; i < left . size ( ) ; i ++ ) { if ( left . get ( i ) . id == roof . id ) { leftRoof = left . get ( i ) ; break ; } } if ( leftRoof == null ) { leftRoof = roof ; } for ( int i = 0 ; i < left . size ( ) ; i ++ ) { if ( left . get ( i ) . depth < leftRoof . depth ) { temp . add ( left . get ( i ) ) ; } } return temp ; }
tr	2	private static final String resolvePath ( final String path ) { if ( path != null ) return path . endsWith ( "" + separatorChar ) ? path . substring ( 0 , path . length ( ) - 1 ) : path ; else return CURRENT_DIR + separatorChar + DEFAULT_FILE_NAME ; }
tr	9	private void execute ( ) { boolean running = true ; WatchKey key ; String dir = readProperties ( ) ; InboundWatcher watch = new InboundWatcher ( dir ) ; System . out . println ( "Starting the directory monitoring" ) ; System . out . println ( "Directory being monitored is: " + dir ) ; while ( running ) { try { key = watch . watcher . take ( ) ; } catch ( InterruptedException ie ) { return ; } for ( WatchEvent < ? > event : key . pollEvents ( ) ) { WatchEvent . Kind < ? > kind = event . kind ( ) ; if ( kind == StandardWatchEventKinds . ENTRY_CREATE ) { WatchEvent < Path > watchEventPath = ( WatchEvent < Path > ) event ; Path entry = watchEventPath . context ( ) ; if ( Pattern . matches ( "[so]{0 1}.+[\\.xml]" , entry . toString ( ) ) ) { SalesOrder . unmarshal ( dir , entry . toString ( ) ) ; } else if ( Pattern . matches ( "[sr]{0 1}.+[\\.xml]" , entry . toString ( ) ) ) { StandardResponse . unmarshal ( dir , entry . toString ( ) ) ; } else if ( Pattern . matches ( ".+[\\.trg]" , entry . toString ( ) ) ) { File f = entry . toFile ( ) ; ShipAdvice . marshal ( f ) ; } } } key . reset ( ) ; if ( ! key . isValid ( ) ) { running = false ; } } }
tr	5	@ Override public void initResources ( ) { playfield = new PlayField ( ) ; ballGroup = new SpriteGroup ( "Balls" ) ; brickGroup = new SpriteGroup ( "Bricks" ) ; playfield . addGroup ( ballGroup ) ; playfield . addGroup ( brickGroup ) ; BufferedImage ballImage = getImage ( "img/ball.png" ) ; BufferedImage brickImage = getImage ( "img/brick.png" ) ; Sprite ball = new Sprite ( ballImage , firstPoint . x , firstPoint . y ) ; Sprite brick1 = new Sprite ( brickImage , secondPoint . x , secondPoint . y ) ; Sprite brick2 = null ; if ( thirdPoint != null ) { brick2 = new Sprite ( brickImage , thirdPoint . x , thirdPoint . y ) ; } Ball ballElement = new Ball ( table ) ; DestroyableBrick brickElement1 = new DestroyableBrick ( table ) ; DestroyableBrick brickElement2 = new DestroyableBrick ( table ) ; table . addPair ( ballElement , ball ) ; table . addPair ( brickElement1 , brick1 ) ; if ( thirdPoint != null ) { table . addPair ( brickElement2 , brick2 ) ; } field . addElement ( ballElement ) ; field . addElement ( brickElement1 ) ; if ( thirdPoint != null ) { field . addElement ( brickElement2 ) ; } ballElement . addCollisionHandleEndListener ( this ) ; ball . setSpeed ( speedVector . x ( ) , speedVector . y ( ) ) ; ballGroup . add ( ball ) ; brickGroup . add ( brick1 ) ; if ( thirdPoint != null ) { brickGroup . add ( brick2 ) ; } CollisionHandler handler = new CollisionHandler ( table ) ; handler . addHandleEndListener ( this ) ; collision = new CollisionObjectWithObject ( ) ; collision . addSpritesCollidedListener ( handler ) ; playfield . addCollisionGroup ( ballGroup , brickGroup , collision ) ; cloneBall = ballElement . clone ( ) ; cloneBrick1 = brickElement1 . clone ( ) ; if ( thirdPoint != null ) { cloneBrick2 = brickElement2 . clone ( ) ; } }
tr	0	public void _fatal ( Object context ) { }
tr	2	@ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj instanceof CategoryModel ) { CategoryModel other = ( CategoryModel ) obj ; return id == other . id ; } return false ; }
tr	7	public static DoubleLinkedList intersection ( DoubleLinkedList first , DoubleLinkedList second ) { if ( null == first || null == second ) { return null ; } else if ( 0 == first . size ( ) || 0 == second . size ( ) ) { return new DoubleLinkedList ( ) ; } else { DoubleLinkedList intersection = new DoubleLinkedList ( ) ; if ( first . size ( ) > second . size ( ) ) { intersection = first ; first = second ; second = intersection ; } for ( int i = 0 ; i < first . size ( ) ; ++ i ) { if ( second . find ( first . get ( i ) ) != - 1 ) { intersection . add ( first . get ( i ) ) ; } } return intersection ; } }
tr	1	public void setTile ( final Tile t , final short x , final short y ) { if ( isOutOfBounds ( x , y ) ) { System . err . println ( t . getName ( ) + " can not be set!" + x + " " + y + " is not a valid world tile location!" ) ; return ; } getChunk ( ( byte ) ( x / 32 ) , ( byte ) ( y / 32 ) ) . setTile ( t , ( short ) ( x % 32 ) , ( short ) ( y % 32 ) ) ; }
tr	8	private boolean swap ( SemanticFrame frame , int N , int M , int [ ] match , int [ ] invMatch , int p , int b , TIntArrayList args ) { int a = match [ p ] ; int q = invMatch [ b ] ; if ( p >= N && q >= N ) { return false ; } else if ( a >= M && b >= M ) { return false ; } if ( p < N ) frame . arglbids [ args . get ( p ) ] = b < M ? b : - 1 ; if ( q < N ) frame . arglbids [ args . get ( q ) ] = a < M ? a : - 1 ; match [ p ] = b ; invMatch [ b ] = p ; match [ q ] = a ; invMatch [ a ] = q ; return true ; }
tr	8	private void pivot ( int p , int q ) { for ( int i = 0 ; i < N ; i ++ ) { double alpha = a [ i ] [ q ] / a [ p ] [ q ] ; for ( int j = 0 ; j <= N + N ; j ++ ) { if ( i != p && j != q ) a [ i ] [ j ] -= alpha * a [ p ] [ j ] ; } } for ( int i = 0 ; i < N ; i ++ ) if ( i != p ) a [ i ] [ q ] = 0.0 ; for ( int j = 0 ; j <= N + N ; j ++ ) if ( j != q ) a [ p ] [ j ] /= a [ p ] [ q ] ; a [ p ] [ q ] = 1.0 ; }
tr	0	@ Override public MessageType getMessageType ( ) { return MessageType . EXITCHATROOM ; }
tr	3	String txtToken ( int token ) { switch ( token ) { case TK_NAME : case TK_STRING : case TK_NUMBER : return new String ( buff , 0 , nbuff ) ; default : return token2str ( token ) ; } }
tr	0	@ Override public DataEntry clone ( ) { DataEntry retval = new DataEntry ( this . x . clone ( ) , this . y ) ; retval . extra = this . extra ; return retval ; }
tr	7	@ Override public void combine ( final int [ ] rows , final int [ ] columns ) { if ( isOutOfBounds ( rows , columns ) ) { return ; } final int rowSpan = rows . length ; final int columnSpan = columns . length ; final int startRow = rows [ 0 ] ; final int startColumn = columns [ 0 ] ; for ( int i = 0 ; i < rowSpan ; i ++ ) { for ( int j = 0 ; j < columnSpan ; j ++ ) { if ( ( span [ startRow + i ] [ startColumn + j ] [ CellSpan . COLUMN ] != 1 ) || ( span [ startRow + i ] [ startColumn + j ] [ CellSpan . ROW ] != 1 ) ) { return ; } } } for ( int i = 0 , ii = 0 ; i < rowSpan ; i ++ , ii -- ) { for ( int j = 0 , jj = 0 ; j < columnSpan ; j ++ , jj -- ) { span [ startRow + i ] [ startColumn + j ] [ CellSpan . COLUMN ] = jj ; span [ startRow + i ] [ startColumn + j ] [ CellSpan . ROW ] = ii ; } } span [ startRow ] [ startColumn ] [ CellSpan . COLUMN ] = columnSpan ; span [ startRow ] [ startColumn ] [ CellSpan . ROW ] = rowSpan ; }
tr	6	@ Override public void run ( ) { log . info ( "New incoming request" ) ; try { while ( this . mClientConnected ) { if ( this . mClientSocket . isOutputShutdown ( ) ) { this . mClientConnected = false ; } else { BufferedReader inFromClient = new BufferedReader ( new InputStreamReader ( this . mClientSocket . getInputStream ( ) ) ) ; DataOutputStream outToClient = new DataOutputStream ( this . mClientSocket . getOutputStream ( ) ) ; String xml = inFromClient . readLine ( ) ; log . info ( "<< incoming request: " + xml ) ; String response = processRequest ( xml ) ; outToClient . writeBytes ( response ) ; log . info ( ">> outgoing response: " + response ) ; this . mClientConnected = false ; this . mClientSocket . close ( ) ; } } } catch ( Exception e ) { this . log . error ( e . getMessage ( ) , e ) ; } finally { try { if ( this . mClientSocket != null && this . mClientSocket . isClosed ( ) == false ) this . mClientSocket . close ( ) ; } catch ( IOException e ) { log . error ( "Failed to free socket resource" , e ) ; } } }
tr	7	@ Override public boolean nextKeyValue ( ) throws IOException , InterruptedException { if ( key == null ) { key = new LongWritable ( ) ; } key . set ( pos ) ; if ( value == null ) { value = new Text ( ) ; } value . clear ( ) ; final Text endline = new Text ( "\n" ) ; int newSize = 0 ; for ( int i = 0 ; i < NLINESTOPROCESS ; i ++ ) { Text v = new Text ( ) ; while ( pos < end ) { newSize = in . readLine ( v , maxLineLength , Math . max ( ( int ) Math . min ( Integer . MAX_VALUE , end - pos ) , maxLineLength ) ) ; value . append ( v . getBytes ( ) , 0 , v . getLength ( ) ) ; value . append ( endline . getBytes ( ) , 0 , endline . getLength ( ) ) ; if ( newSize == 0 ) { break ; } pos += newSize ; if ( newSize < maxLineLength ) { break ; } } } if ( newSize == 0 ) { key = null ; value = null ; return false ; } else { return true ; } }
tr	8	public void setFieldValue ( _Fields field , Object value ) { switch ( field ) { case ID : if ( value == null ) { unsetId ( ) ; } else { setId ( ( Integer ) value ) ; } break ; case NOME : if ( value == null ) { unsetNome ( ) ; } else { setNome ( ( String ) value ) ; } break ; case EMAIL : if ( value == null ) { unsetEmail ( ) ; } else { setEmail ( ( String ) value ) ; } break ; case DATA : if ( value == null ) { unsetData ( ) ; } else { setData ( ( String ) value ) ; } break ; } }
tr	0	public Integer getAudienceId ( ) { return audienceId ; }
tr	8	private void expand ( Node crt ) { while ( crt != null && ! crt . isVisited ( ) ) { crt . setVisited ( true ) ; for ( Cord c : crt . getNb ( ) ) { if ( c == null ) continue ; Node nd = nodes [ c . i ] [ c . j ] ; if ( nd == null ) continue ; Integer dist = nd . costFrom ( crt , panel , to . getDirectP ( ) ) ; if ( dist == null ) continue ; int nc = crt . getCost ( ) + dist ; if ( nd . getCost ( ) == null || nd . getCost ( ) > nc ) { nd . update ( crt , nc ) ; } } crt = getNextToExpand ( ) ; } }
tr	1	private int getLastPageNumber ( ) { return elements . size ( ) / pageSize + ( ( elements . size ( ) % pageSize != 0 ) ? 1 : 0 ) ; }
tr	8	static void setCurrentTab ( boolean isSelection , int tabId , String url , JavaScriptObject tab ) { BrowserTab t = getById ( tabId ) ; t . url = url ; AppState . isWebUrl = WebContent . isWebUrl ( url ) ; AppState . isInPearltrees = AppState . isWebUrl && WebContent . isInPearltrees ( url ) ; MainButton . setIcon ( false , false ) ; if ( isSelection && AppState . isInPearltrees && AppState . getSelectedTree ( ) != null && AppState . lastPearled != null && t . creation . before ( AppState . lastPearled ) ) { AppState . reveal ( AppState . getSelectedTree ( ) , AppState . getSelectedAsso ( ) , tabId , url ) ; } else if ( AppState . isInPearltrees ) { String tree = WebContent . getCurrentTree ( url ) ; if ( tree != null ) { AppState . setSelectedTree ( tree , "" ) ; } } }
tr	1	@ Override public void onFatalRejection ( RejectedHandler < ? > rejection , Object context ) { onFatalRejectionConsumer . accept ( rejection , context ) ; }
tr	6	static OffHeapDisposableIterator < byte [ ] > sortedIterator ( ExecutorService executor , int threads , OffHeapStructCollection a , long fromIndex , long toIndex , Comparator < OffHeapStructAccessor > comparator ) { if ( null == comparator ) throw new IllegalArgumentException ( "Provided comparator is null" ) ; if ( fromIndex < 0 || fromIndex > toIndex || toIndex > a . size ( ) ) { throw new IllegalArgumentException ( "Illegal input  collection size: [" + a . size ( ) + "]  " + "fromIndex: [" + fromIndex + "]  toIndex: [" + toIndex + "]" ) ; } int len = a . structLength ( ) ; long step = ( toIndex - 1 - fromIndex ) / threads ; if ( 0 == step ) { doSort ( a , fromIndex , toIndex - 1 , new OffHeapStructComparator ( a , comparator ) , new byte [ len ] , new byte [ len ] , new byte [ len ] , new byte [ len ] , new byte [ len ] , new byte [ len ] , new byte [ len ] ) ; return a . iterator ( ) ; } else { List < Worker > workers = new ArrayList < Worker > ( ) ; for ( int start = 0 ; start < toIndex ; start += step ) { Worker worker = new Worker ( a , start , Math . min ( start + step - 1 , toIndex - 1 ) , new OffHeapStructComparator ( a , comparator ) , new byte [ len ] , new byte [ len ] , new byte [ len ] , new byte [ len ] , new byte [ len ] , new byte [ len ] , new byte [ len ] ) ; workers . add ( worker ) ; } invokeAndWait ( executor , workers ) ; return new MergeIter ( a , new OffHeapStructComparator ( a , comparator ) , workers ) ; } }
tr	7	public K advise ( Set < K > currentSet , long position ) { K advice = null ; long max = long . MIN_VALUE ; for ( K inMem : currentSet ) { if ( evicted . contains ( inMem ) ) { continue ; } List < long > current = distances . get ( inMem ) ; if ( current == null ) { advice = inMem ; System . err . println ( "Not met" ) ; break ; } while ( current . size ( ) > 0 && current . get ( 0 ) < position ) { current . remove ( 0 ) ; } if ( current . size ( ) == 0 ) { System . out . println ( inMem + " was already skipped at position " + position ) ; distances . remove ( inMem ) ; advice = inMem ; break ; } long closestForCurrent = current . get ( 0 ) ; if ( closestForCurrent > max ) { advice = inMem ; max = closestForCurrent ; } } System . out . println ( "Suggested for eviction " + advice + " that is at " + max + " with current position being " + position ) ; return advice ; }
tr	5	public static int ElectroBall ( ActivePokemon attacker , ActivePokemon target ) { double n = ( int ) ( target . getCurrSpe ( ) / attacker . getCurrSpe ( ) ) * 100 ; if ( n <= 0.25 ) { return 150 ; } else if ( n > 0.25 && n < 1 / ( double ) 3 ) { return 120 ; } else if ( n > 1 / ( double ) 3 && n < 0.5 ) { return 80 ; } else { return 60 ; } }
tr	9	public boolean setRobot ( final int robot , final int position , final boolean allowSwapRobots ) { if ( ( robot < 0 ) || ( robot >= this . robots . length ) || ( position < 0 ) || ( position >= this . size ) || this . isObstacle ( position ) || ( ( false == allowSwapRobots ) && ( this . getRobotNum ( position ) >= 0 ) && ( this . getRobotNum ( position ) != robot ) ) ) { return false ; } else { final int otherRobot = this . getRobotNum ( position ) ; final int oldPosition = this . robots [ robot ] ; if ( ( otherRobot >= 0 ) && ( otherRobot != robot ) && ( oldPosition >= 0 ) ) { this . robots [ otherRobot ] = oldPosition ; } this . robots [ robot ] = position ; return true ; } }
tr	3	protected JSONRPCBridge findBridge ( HttpServletRequest request ) { HttpSession session = request . getSession ( false ) ; JSONRPCBridge json_bridge = null ; if ( session != null ) { json_bridge = ( JSONRPCBridge ) session . getAttribute ( "JSONRPCBridge" ) ; } if ( json_bridge == null ) { json_bridge = JSONRPCBridge . getGlobalBridge ( ) ; if ( log . isDebugEnabled ( ) ) { log . debug ( "Using global bridge." ) ; } } return json_bridge ; }
tr	9	public void tick ( ) { int l = mouseButtons . length ; for ( int i = 0 ; i < l ; i ++ ) { boolean b = Mouse . isButtonDown ( i ) ; if ( b && ! mouseButtons [ i ] ) mostRecentClicks [ i ] = new Point ( Mouse . getX ( ) , Mouse . getY ( ) ) ; mouseButtons [ i ] = b ; if ( ! b ) consumedMouseButton [ i ] = false ; } while ( Mouse . next ( ) ) { int key = Mouse . getEventButton ( ) ; if ( ( key == - 1 ) || ( key >= mouseButtons . length ) ) continue ; boolean state = Mouse . getEventButtonState ( ) ; if ( state ) mouseButtons [ key ] = true ; else consumedMouseButton [ key ] = false ; } l = keys . length ; for ( int i = 0 ; i < l ; i ++ ) { boolean b = Keyboard . isKeyDown ( i ) ; keys [ i ] = b ; if ( ! b ) consumedKeys [ i ] = false ; } while ( Keyboard . next ( ) ) { int key = Keyboard . getEventKey ( ) ; if ( ( key < 0 ) || ( key >= keys . length ) ) continue ; boolean state = Keyboard . getEventKeyState ( ) ; if ( state ) keys [ key ] = true ; else consumedKeys [ key ] = false ; } dx = Mouse . getDX ( ) ; dy = - Mouse . getDY ( ) ; x = Mouse . getX ( ) ; y = ( height - 1 ) - Mouse . getY ( ) ; }
tr	6	public static Integer valueOf ( Object o ) { if ( o == null ) { return null ; } else if ( o instanceof byte ) { return ( int ) ( byte ) o ; } else if ( o instanceof Integer ) { return ( Integer ) o ; } else if ( o instanceof double ) { return ( int ) ( double ) ( double ) o ; } else if ( o instanceof float ) { return ( int ) ( float ) ( float ) o ; } else if ( o instanceof long ) { return ( int ) ( long ) ( long ) o ; } else { return null ; } }
tr	4	protected Object getFieldValue ( Map < String , ? > item , String field , String mode ) throws Exception { Object value = item . get ( field ) ; if ( ! item . containsKey ( field ) ) { throw new RuntimeException ( String . format ( "Field [%s] not found in [%s]!" , field , toString ( ) ) ) ; } if ( value == null && isStrict ( ) ) { throw new RuntimeException ( String . format ( "Field [%s] is null in [%s]!" , field , toString ( ) ) ) ; } return value ; }
tr	7	@ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; Type other = ( Type ) obj ; if ( collectionType != other . collectionType ) return false ; if ( javaClass == null ) { if ( other . javaClass != null ) return false ; } else if ( ! javaClass . equals ( other . javaClass ) ) return false ; return true ; }
tr	5	public Wave getSection ( int start , int end ) { if ( start < 0 ) start = 0 ; if ( start >= wave . length ) start = wave . length - 1 ; if ( end >= wave . length ) end = wave . length - 1 ; if ( end < 0 ) end = 0 ; double [ ] w = new double [ end - start + 1 ] ; int i = 0 ; while ( start <= end ) w [ i ++ ] = wave [ start ++ ] ; return new Wave ( w , samplingRate , maxAmplitude ) ; }
tr	3	public String choose ( int num , Supplier < String > first , Supplier < String > second , Supplier < String > third ) { switch ( num ) { case 1 : return first . get ( ) ; case 2 : return second . get ( ) ; case 3 : return third . get ( ) ; default : throw new IllegalArgumentException ( "Illegal num " + num ) ; } }
tr	1	private void buttonGetResultActionPerformed ( java . awt . event . ActionEvent evt ) { System . out . println ( "inside Result Action Performed" ) ; try { new ResultWindow ( textUName . getText ( ) ) . setVisible ( true ) ; } catch ( Exception e ) { } }
tr	5	@ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; Square square = ( Square ) o ; if ( x != square . x ) return false ; if ( y != square . y ) return false ; return true ; }
tr	3	public final int getPreferredWidth ( int sz ) { if ( c . getWidth ( ) == 0 && c . getHeight ( ) == 0 && sz != - 1 ) c . setBounds ( c . getX ( ) , c . getY ( ) , 1 , sz ) ; return c . getPreferredSize ( ) . width ; }
tr	8	public boolean group ( int indentation ) throws IOException , SyntaxException { int c = read ( ) ; if ( c != ( ) { unread ( ) ; return false ; } int lev = level ; space ( ) ; while ( true ) { String s = null ; if ( ( s = string ( ) ) != null ) { handler . event ( s ) ; handler . level ( ++ lev ) ; lev ++ ; } else if ( space ( ) > 0 ) { } else if ( ( s = quoted ( indentation ) ) != null ) { handler . event ( s ) ; handler . level ( ++ lev ) ; lev ++ ; } else if ( , ( ) ) { lev = level ; handler . level ( lev ) ; } else if ( ! group ( indentation ) ) break ; } space ( ) ; c = read ( ) ; if ( c != ) ) throw new SyntaxException ( "missing ): " + ( char ) c ) ; level = lev ; handler . level ( level ) ; return true ; }
tr	9	public void bindTexture ( String key ) { if ( ! key . equals ( sCurrentlyBound ) || currentlyBound == null ) { sCurrentlyBound = key ; glEnable ( GL_TEXTURE_2D ) ; switch ( key ) { case "null" : glDisable ( GL_TEXTURE_2D ) ; currentlyBound = null ; break ; case "terrain" : terrain . bind ( ) ; currentlyBound = terrain ; break ; case "player" : player . bind ( ) ; currentlyBound = player ; break ; case "debug" : debug . bind ( ) ; currentlyBound = debug ; break ; case "text" : text . bind ( ) ; currentlyBound = text ; break ; case "constructionMenu" : constructionMenu . bind ( ) ; currentlyBound = constructionMenu ; break ; case "debugmenu" : debugMenu . bind ( ) ; currentlyBound = debugMenu ; break ; case "panes" : panes . bind ( ) ; currentlyBound = panes ; break ; case "zed" : zed . bind ( ) ; currentlyBound = zed ; break ; case "entities" : entities . bind ( ) ; currentlyBound = entities ; break ; case "items" : items . bind ( ) ; currentlyBound = items ; break ; case "playerpane" : playerpane . bind ( ) ; currentlyBound = playerpane ; break ; default : System . out . println ( "Tried to bind a texture that doesn't exist" ) ; System . out . println ( key ) ; Boot . shutdownGracefully ( ) ; } glTexParameteri ( GL_TEXTURE_2D , GL_TEXTURE_MIN_FILTER , GL_NEAREST ) ; glTexParameteri ( GL_TEXTURE_2D , GL_TEXTURE_MAG_FILTER , GL_NEAREST ) ; } }
tr	2	public void mousePressed ( Graphics g , MouseEvent e ) { int x = e . getX ( ) ; int y = e . getY ( ) ; current = MainFrame . getCurrentCanvas ( ) . getAutomaton ( ) . findState ( x , y , g ) ; if ( current != null ) { current . expose ( g ) ; current . move ( x , y ) ; current . expose ( g ) ; } else { current = MainFrame . getCurrentCanvas ( ) . getAutomaton ( ) . addState ( ) . move ( x , y ) ; if ( MainFrame . getCurrentCanvas ( ) . getAutomaton ( ) . getInitialStates ( ) . size ( ) == 0 ) { current . setInitial ( true ) ; } current . expose ( g ) ; } MainFrame . getCurrentCanvas ( ) . commitTransaction ( true ) ; }
tr	1	private int insert ( final BeanMissatge bean ) { String SQL1 = "INSERT INTO sig_missatgeria (idEntrevista destinatari idMateria materia actitud notes feina comentaris dataContestat idMensajeProfesor) " + " VALUES(? ? ? ? ? ? ? ? ? ?)" ; Object [ ] objs = new Object [ ] { bean . idEntrevista , bean . destinatari_abrev , bean . idMateria , bean . materia , bean . actitud , bean . notes , bean . feina , bean . comentari , bean . dataContestat , bean . idMensajeProfesor } ; int nup = client . getMysql ( ) . preparedUpdateID ( SQL1 , objs ) ; if ( nup > 0 ) { bean . setId ( nup ) ; } return nup ; }
tr	1	Type getType ( ) { return type == Type . kAny ? Type . kBase : type ; }
tr	3	private class < ? > toBeanType ( int type ) { class < ? > clz = typesMap . get ( type ) ; return clz == null ? String . class : clz ; }
tr	2	public String getInitText ( ) { if ( options == null || options . length < 1 ) return null ; return options [ 1 ] ; }
tr	5	public Point getClickedPoint ( int x , int y ) { Point p ; for ( Iterator < Point > iter = polypoints . iterator ( ) ; iter . hasNext ( ) ; ) { p = iter . next ( ) ; if ( x >= p . x - POINTSIZE2 && x <= p . x + POINTSIZE2 && y >= p . y - POINTSIZE2 && y <= p . y + POINTSIZE2 ) return p ; } return null ; }
tr	3	static String stripLeadingHyphens ( String str ) { if ( str == null ) { return null ; } if ( str . startsWith ( "--" ) ) { return str . substring ( 2 , str . length ( ) ) ; } else if ( str . startsWith ( "-" ) ) { return str . substring ( 1 , str . length ( ) ) ; } return str ; }
tr	7	public int findLCM ( int m , int n ) { if ( m <= 0 || n <= 0 ) { return 0 ; } if ( m % n == 0 ) { return m ; } if ( n % m == 0 ) { return n ; } int a = m ; int b = n ; while ( a != b ) { if ( a < b ) { a = a + m ; } else if ( a > b ) { b = b + n ; } } return a ; }
tr	3	public int set ( final AbstractQuestion aq ) { final Database connect = new Database ( _databaseName ) ; final Hashtable < enum < ? > , Object > vals = new Hashtable < enum < ? > , Object > ( ) ; vals . put ( Column . TYPE , aq . getType ( ) . toString ( ) ) ; vals . put ( Column . SHOW , "" + aq . getShowQuestion ( ) ) ; final ResultSet rs = connect . insert ( TABLE_NAME , vals ) ; int questionNumber = - 1 ; try { questionNumber = rs . getInt ( 1 ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; final int error = - 2 ; questionNumber = error ; } connect . disconnect ( ) ; final DatabaseLocation dl = new DatabaseLocation ( _databaseName ) ; dl . set ( questionNumber , aq . getLocation ( ) ) ; final DatabaseStatistics ds = new DatabaseStatistics ( _databaseName ) ; final int correct = aq . getCorrectlyAnswered ( ) ; final int total = aq . getTotalTimesAnswered ( ) ; final int difficulty = aq . getDifficulty ( ) ; ds . set ( questionNumber , new Statistics ( difficulty , correct , total ) ) ; return questionNumber ; }
