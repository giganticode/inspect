tr	2	public void removeBogusLegs ( ) { Iterator < Leg > it = legs . iterator ( ) ; while ( it . hasNext ( ) ) { Leg leg = it . next ( ) ; if ( leg . isBogusNonTransitLeg ( ) ) { it . remove ( ) ; } } }
tr	0	@ Override public Sexp eval ( IPair cons , Map < AtomSymbol , Sexp > env ) throws FunctionException { super . checkArgmunet ( cons , 2 ) ; Sexp [ ] list = cons . getCdr ( ) . getList ( ) ; Sexp sexpA = MyLisp . apply ( list [ 0 ] , env ) ; Sexp sexpB = MyLisp . apply ( list [ 1 ] , env ) ; return Atom . newAtom ( sexpA . equals ( sexpB ) ) ; }
tr	5	@ Override public boolean equals ( Object object ) { if ( ! ( object instanceof Users ) ) { return false ; } Users other = ( Users ) object ; if ( ( this . iduser == null && other . iduser != null ) || ( this . iduser != null && ! this . iduser . equals ( other . iduser ) ) ) { return false ; } return true ; }
tr	8	public AccountInfo accountInfo ( String accountName ) throws MultiCloudException , OAuth2SettingsException , InterruptedException { synchronized ( lock ) { if ( op != null ) { throw new MultiCloudException ( "Concurrent operation forbidden." ) ; } } AccountSettings account = accountManager . getAccountSettings ( accountName ) ; if ( account == null ) { throw new MultiCloudException ( "User account not found." ) ; } if ( ! account . isAuthorized ( ) ) { throw new MultiCloudException ( "User account not authorized." ) ; } CloudSettings settings = cloudManager . getCloudSettings ( account . getSettingsId ( ) ) ; if ( settings == null ) { throw new MultiCloudException ( "Cloud storage settings not found." ) ; } OAuth2Token token = credentialStore . retrieveCredential ( account . getTokenId ( ) ) ; if ( token == null ) { account . setTokenId ( null ) ; throw new MultiCloudException ( "Access token not found." ) ; } if ( token . isExpired ( ) ) { refreshAccount ( accountName , null ) ; } synchronized ( lock ) { op = new AccountInfoOp ( token , settings . getAccountInfoRequest ( ) ) ; } try { op . execute ( ) ; } catch ( MultiCloudException e ) { synchronized ( lock ) { op = null ; } throw e ; } lastError = op . getError ( ) ; if ( op . isAborted ( ) ) { synchronized ( lock ) { op = null ; } throw new AbortedException ( "Operation aborted." ) ; } AccountInfo result = ( ( AccountInfoOp ) op ) . getResult ( ) ; synchronized ( lock ) { op = null ; } return result ; }
tr	2	public JSONObject ( JSONObject jo , String [ ] names ) { this ( ) ; for ( int i = 0 ; i < names . length ; i += 1 ) { try { this . putOnce ( names [ i ] , jo . opt ( names [ i ] ) ) ; } catch ( Exception ignore ) { } } }
tr	0	public temporaire ( ) { scfsi = new int [ 4 ] ; gr = new gr_info_s [ 2 ] ; gr [ 0 ] = new gr_info_s ( ) ; gr [ 1 ] = new gr_info_s ( ) ; }
tr	6	private void readPolar ( ) throws IOException { long currTime ; while ( isRead ) { currTime = System . currentTimeMillis ( ) ; int msg = inputStream . read ( ) ; if ( msg == 254 ) { printMessage ( "\n" + System . currentTimeMillis ( ) + ": " ) ; polarMessageTmp = new PolarMessage ( System . currentTimeMillis ( ) ) ; } else if ( msg == - 1 ) { System . out . println ( "Roz\u0142\u0105czono" ) ; stopRead ( ) ; break ; } else if ( polarMessageTmp != null && polarMessageTmp . setNextValue ( msg ) ) { message = new PolarMessage ( System . currentTimeMillis ( ) ) ; message . setHr ( polarMessageTmp . getHr ( ) ) ; } if ( currTime - System . currentTimeMillis ( ) > 3000 ) { System . out . println ( "Zbyt d\u0142ugi czas oczekiwania" ) ; } printMessage ( " " + msg ) ; } }
tr	0	public void setId ( long id ) { this . id = id ; }
tr	6	boolean addIncomingClusters ( NodeCluster seed ) { for ( int i = 0 ; i < seed . leftCount ; i ++ ) { NodeCluster neighbor = seed . leftNeighbors [ i ] ; if ( neighbor . isSetMember ) continue ; CollapsedEdges edges = seed . leftLinks [ i ] ; if ( ! edges . isTight ( ) ) continue ; if ( ( ! isRight || neighbor . getPull ( ) > 0 ) && addCluster ( neighbor ) ) return true ; } return false ; }
tr	9	private boolean check ( double [ ] [ ] A , double [ ] b ) { if ( isFeasible ( ) ) { double [ ] x = primal ( ) ; for ( int i = 0 ; i < N ; i ++ ) { double sum = 0.0 ; for ( int j = 0 ; j < N ; j ++ ) { sum += A [ i ] [ j ] * x [ j ] ; } if ( Math . abs ( sum - b [ i ] ) > EPSILON ) { System . out . println ( "not feasible" ) ; System . out . printf ( "b[%d] = %8.3f  sum = %8.3f\n" , i , b [ i ] , sum ) ; return false ; } } return true ; } else { double [ ] y = dual ( ) ; for ( int j = 0 ; j < N ; j ++ ) { double sum = 0.0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += A [ i ] [ j ] * y [ i ] ; } if ( Math . abs ( sum ) > EPSILON ) { System . out . println ( "invalid certificate of infeasibility" ) ; System . out . printf ( "sum = %8.3f\n" , sum ) ; return false ; } } double sum = 0.0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += y [ i ] * b [ i ] ; } if ( Math . abs ( sum ) < EPSILON ) { System . out . println ( "invalid certificate of infeasibility" ) ; System . out . printf ( "yb  = %8.3f\n" , sum ) ; return false ; } return true ; } }
tr	1	public Image getImage ( int i , int j , String Tag ) { String Image = recupererPropriete ( i , j , Tag ) ; assert ( ! Image . equals ( "NOT_FOUND" ) ) ; Image image_box = null ; try { image_box = new Image ( Image ) ; } catch ( SlickException e ) { e . printStackTrace ( ) ; } return image_box ; }
tr	8	public void merger ( ) { String line1 = "" , line2 = "" ; BufferedReader reader1 = null , reader2 = null ; String content = "" ; File output = null ; String prevline1 = "" , prevline2 = "" ; try { reader1 = new BufferedReader ( new InputStreamReader ( new FileInputStream ( file1name + "\\ValueSum.dat" ) ) ) ; reader2 = new BufferedReader ( new InputStreamReader ( new FileInputStream ( file2name + "\\ValueSum.dat" ) ) ) ; File directory = new File ( "compare Algorithm" ) ; if ( ! directory . exists ( ) ) { directory . mkdir ( ) ; ; } output = new File ( "compare Algorithm\\comparedata.dat" ) ; File output2 = new File ( "compare Algorithm\\compareval.jpeg" ) ; File ouput3 = new File ( "compare Algorithm\\comapre_Script.gnu" ) ; if ( output . exists ( ) ) { output . delete ( ) ; ; } output . createNewFile ( ) ; int count = 0 ; while ( ( ( ( line1 = reader1 . readLine ( ) ) != null ) | ( ( line2 = reader2 . readLine ( ) ) != null ) ) && count < 15 ) { if ( line1 == null ) { content += prevline1 + " " ; count ++ ; } else { content += line1 + " " ; prevline1 = line1 ; } if ( line2 == null ) { content += prevline2 + "\n" ; count ++ ; } else { content += line2 ; prevline2 = line2 ; content += "\n" ; } } FileWriter fw = new FileWriter ( output . getAbsoluteFile ( ) ) ; BufferedWriter bw = new BufferedWriter ( fw ) ; bw . write ( content ) ; bw . close ( ) ; } catch ( FileNotFoundException ex ) { Logger . getLogger ( FileMerger . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( IOException ex ) { Logger . getLogger ( FileMerger . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } }
tr	9	public static Block getBlock ( int id ) { switch ( id ) { case 0 : return air ; case 1 : return grass ; case 2 : return dirt ; case 3 : return stone ; case 4 : return wood ; case 5 : return leaves ; case 6 : return water ; case 7 : return redstone ; case 8 : return sand ; case 9 : return plank ; case 10 : return snow ; default : return undefined ; } }
tr	4	public String toNVPString ( String prefix ) throws UnsupportedEncodingException { StringBuilder sb = new StringBuilder ( ) ; if ( this . requestEnvelope != null ) { String newPrefix = prefix + "requestEnvelope." ; sb . append ( this . requestEnvelope . toNVPString ( newPrefix ) ) ; } if ( this . createAccountKey != null ) { sb . append ( prefix ) . append ( "createAccountKey=" ) . append ( NVPUtil . encodeUrl ( this . createAccountKey ) ) ; sb . append ( "&" ) ; } if ( this . countryCode != null ) { sb . append ( prefix ) . append ( "countryCode=" ) . append ( NVPUtil . encodeUrl ( this . countryCode ) ) ; sb . append ( "&" ) ; } if ( this . languageCode != null ) { sb . append ( prefix ) . append ( "languageCode=" ) . append ( NVPUtil . encodeUrl ( this . languageCode ) ) ; sb . append ( "&" ) ; } return sb . toString ( ) ; }
tr	0	@ XmlElementDecl ( namespace = "http://www.akamon.com/slots/gameconfigdata.xsd" , name = "GameConfigData" ) public JAXBElement < GameConfigData > createGameConfigData ( GameConfigData value ) { return new JAXBElement < GameConfigData > ( _GameConfigData_QNAME , GameConfigData . class , null , value ) ; }
tr	9	protected void readRequest ( ) throws IOException { String type = null ; String type1 = fRequest . getContentType ( ) ; String type2 = fRequest . getHeader ( "Content-Type" ) ; if ( type1 == null && type2 != null ) type = type2 ; else if ( type2 == null && type1 != null ) type = type1 ; else if ( type1 != null && type2 != null ) type = ( type1 . length ( ) > type2 . length ( ) ? type1 : type2 ) ; if ( type == null ) throw new IOException ( "Content type is null" ) ; else if ( ! type . toLowerCase ( ) . startsWith ( "multipart/form-data" ) ) throw new IOException ( "Content not multipart/form-data: " + type ) ; int length = fRequest . getContentLength ( ) ; if ( length > fMaxSize ) throw new IOException ( "Content length " + length + " exceeds limit " + fMaxSize ) ; String boundary = extractBoundary ( type ) ; if ( boundary == null ) throw new IOException ( "Separation boundary not found" ) ; MultipartStreamHandler in = new MultipartStreamHandler ( fRequest . getInputStream ( ) , boundary , length ) ; String line = in . readLine ( ) ; if ( line == null ) throw new IOException ( "Corrupt form data:  premature end" ) ; if ( ! line . startsWith ( boundary ) ) throw new IOException ( "Corrupt form data:  missing leading boundary" ) ; boolean done = false ; while ( ! done ) { done = readNextPart ( in , boundary ) ; } }
tr	9	private static void calcAjacent ( ) { int numColumns = entries . size ( ) ; int numRows = entries . get ( 0 ) . size ( ) ; for ( int x = 0 ; x < numColumns ; x ++ ) { for ( int y = 0 ; y < numRows ; y ++ ) { if ( x == 0 ) { if ( y == 0 ) { Location [ ] ajacent = { entries . get ( x ) . get ( y + 1 ) , entries . get ( x + 1 ) . get ( y ) } ; entries . get ( x ) . get ( y ) . setAjacent ( ajacent ) ; } else if ( y == numRows - 1 ) { Location [ ] ajacent = { entries . get ( x ) . get ( y - 1 ) , entries . get ( x + 1 ) . get ( y ) } ; entries . get ( x ) . get ( y ) . setAjacent ( ajacent ) ; } else { Location [ ] ajacent = { entries . get ( x ) . get ( y + 1 ) , entries . get ( x + 1 ) . get ( y + 1 ) , entries . get ( x + 1 ) . get ( y ) , entries . get ( x ) . get ( y - 1 ) } ; entries . get ( x ) . get ( y ) . setAjacent ( ajacent ) ; } } else if ( x == numColumns - 1 ) { if ( y == 0 ) { Location [ ] ajacent = { entries . get ( x ) . get ( y + 1 ) , entries . get ( x - 1 ) . get ( y ) } ; entries . get ( x ) . get ( y ) . setAjacent ( ajacent ) ; } else if ( y == numRows - 1 ) { Location [ ] ajacent = { entries . get ( x ) . get ( y - 1 ) , entries . get ( x - 1 ) . get ( y ) } ; entries . get ( x ) . get ( y ) . setAjacent ( ajacent ) ; } else { Location [ ] ajacent = { entries . get ( x ) . get ( y + 1 ) , entries . get ( x - 1 ) . get ( y + 1 ) , entries . get ( x - 1 ) . get ( y ) , entries . get ( x ) . get ( y - 1 ) } ; entries . get ( x ) . get ( y ) . setAjacent ( ajacent ) ; } } else if ( y == 0 ) { if ( x % 2 == 0 ) { Location [ ] ajacent = { entries . get ( x - 1 ) . get ( y ) , entries . get ( x ) . get ( y ) , entries . get ( x + 1 ) . get ( y ) } ; entries . get ( x ) . get ( y ) . setAjacent ( ajacent ) ; } else { Location [ ] ajacent = { entries . get ( x - 1 ) . get ( y + 1 ) , entries . get ( x - 1 ) . get ( y ) , entries . get ( x ) . get ( y + 1 ) , entries . get ( x + 1 ) . get ( y ) , entries . get ( x + 1 ) . get ( y + 1 ) } ; entries . get ( x ) . get ( y ) . setAjacent ( ajacent ) ; } } else if ( y == numRows - 1 ) { if ( x % 2 == 0 ) { Location [ ] ajacent = { entries . get ( x - 1 ) . get ( y - 1 ) , entries . get ( x - 1 ) . get ( y ) , entries . get ( x ) . get ( y - 1 ) , entries . get ( x + 1 ) . get ( y ) , entries . get ( x + 1 ) . get ( y - 1 ) } ; entries . get ( x ) . get ( y ) . setAjacent ( ajacent ) ; } else { Location [ ] ajacent = { entries . get ( x - 1 ) . get ( y ) , entries . get ( x ) . get ( y ) , entries . get ( x + 1 ) . get ( y ) } ; entries . get ( x ) . get ( y ) . setAjacent ( ajacent ) ; } } else { if ( x % 2 == 0 ) { Location [ ] ajacent = { entries . get ( x - 1 ) . get ( y - 1 ) , entries . get ( x - 1 ) . get ( y ) , entries . get ( x ) . get ( y - 1 ) , entries . get ( x ) . get ( y + 1 ) , entries . get ( x + 1 ) . get ( y - 1 ) , entries . get ( x + 1 ) . get ( y ) } ; entries . get ( x ) . get ( y ) . setAjacent ( ajacent ) ; } else { Location [ ] ajacent = { entries . get ( x - 1 ) . get ( y + 1 ) , entries . get ( x - 1 ) . get ( y ) , entries . get ( x ) . get ( y - 1 ) , entries . get ( x ) . get ( y + 1 ) , entries . get ( x + 1 ) . get ( y + 1 ) , entries . get ( x + 1 ) . get ( y ) } ; entries . get ( x ) . get ( y ) . setAjacent ( ajacent ) ; } } } } }
tr	1	public void run ( ) { if ( program != null ) { program . execute ( this ) ; } else { defaultProgram ( ) ; } }
tr	5	private boolean haveCompleteNode ( JTree tree ) { int [ ] selRows = tree . getSelectionRows ( ) ; TreePath path = tree . getPathForRow ( selRows [ 0 ] ) ; JSONObjectTreeNode first = ( JSONObjectTreeNode ) path . getLastPathComponent ( ) ; int childCount = first . getChildCount ( ) ; if ( childCount > 0 && selRows . length == 1 ) { return false ; } for ( int i = 1 ; i < selRows . length ; i ++ ) { path = tree . getPathForRow ( selRows [ i ] ) ; JSONObjectTreeNode next = ( JSONObjectTreeNode ) path . getLastPathComponent ( ) ; if ( first . isNodeChild ( next ) ) { if ( childCount > selRows . length - 1 ) { return false ; } } } return true ; }
tr	2	public List < MultiplicitiesVector > findMulVectorsSummingExactlyTo ( int level ) { if ( vecsOfLevelEndAt . containsKey ( level ) ) { int startFrom ; if ( level > 0 ) { startFrom = vecsOfLevelEndAt . get ( level - 1 ) ; } else { startFrom = 0 ; } return storedVectors . subList ( startFrom , vecsOfLevelEndAt . get ( level ) ) ; } else { findMulVectorsSummingUpTo ( level ) ; List < MultiplicitiesVector > toRet = findMulVectorsSummingExactlyTo ( level ) ; return toRet ; } }
tr	1	public boolean noun2Modifier ( DataHolder dataholderHandler , String word ) { boolean isUpdated = false ; ArrayList < String > deletedPOSs = new ArrayList < String > ( ) ; deletedPOSs . add ( "s" ) ; deletedPOSs . add ( "p" ) ; deletedPOSs . add ( "n" ) ; for ( String POS : deletedPOSs ) { dataholderHandler . deleteWordPOS ( true , word , true , POS ) ; } dataholderHandler . updateDataHolder ( word , "m" , "" , "modifiers" , 1 ) ; String oldPattern = String . format ( "(^%s$|^.* %s$)" , word , word ) ; dataholderHandler . updateSentenceTag ( oldPattern , null ) ; return isUpdated ; }
tr	1	@ Override public void enterRule ( ParseTreeListener listener ) { if ( listener instanceof DecafParserListener ) ( ( DecafParserListener ) listener ) . enterId1 ( this ) ; }
tr	0	protected BombImage ( Content parent , Game game , Point position , int range , Date end ) { super ( parent , game , position , range , end ) ; }
tr	3	public static void saveDefaultConfig ( ) { Properties prop = new Properties ( ) ; OutputStream output = null ; try { output = new FileOutputStream ( "config.properties" ) ; prop . setProperty ( "deviceAddress" , "0022D000F0A7" ) ; prop . setProperty ( "deviceName" , "Polar iWL" ) ; prop . setProperty ( "deviceType" , "Polar Wear-Link" ) ; prop . setProperty ( "localeLanguage" , "pl" ) ; prop . setProperty ( "localeCountry" , "PL" ) ; prop . store ( output , null ) ; } catch ( IOException io ) { io . printStackTrace ( ) ; } finally { if ( output != null ) { try { output . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } } }
tr	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( GestionParticipant . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( GestionParticipant . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( GestionParticipant . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( GestionParticipant . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { GestionParticipant dialog = new GestionParticipant ( new javax . swing . JFrame ( ) , true ) ; dialog . addWindowListener ( new java . awt . event . WindowAdapter ( ) { @ Override public void windowClosing ( java . awt . event . WindowEvent e ) { System . exit ( 0 ) ; } } ) ; dialog . setVisible ( true ) ; } } ) ; }
tr	2	@ Override public void editMaterieFromClasa ( Materie m , Clasa c ) { ArrayList < Materie > list = c . getMaterii ( ) ; int index = 0 ; for ( Iterator < Materie > it = list . iterator ( ) ; it . hasNext ( ) ; ) { Materie materie = it . next ( ) ; if ( materie . getNume ( ) . endsWith ( m . getNume ( ) ) ) { index = list . indexOf ( materie ) ; it . remove ( ) ; } } list . add ( index , m ) ; c . setMaterii ( list ) ; }
tr	8	public String ReadFile ( String filename ) throws IOException { FileConnection fc = ( FileConnection ) Connector . open ( filename ) ; boolean bFileExists = fc . exists ( ) ; if ( bFileExists ) { filesize = fc . fileSize ( ) ; } if ( bFileExists && filesize < 319488 ) { InputStream stream = fc . openInputStream ( ) ; LineReader lineReader = new LineReader ( stream ) ; for ( ; ; ) { try { String line = new String ( lineReader . readLine ( ) ) ; PinSender ps = new PinSender ( ) ; verifypin = ps . VerifyPin ( line ) ; if ( verifypin == false ) { badpins ++ ; continue ; } PinScreen . ContactArray . addElement ( line ) ; countpin ++ ; } catch ( EOFException eof ) { fileResponse = countpin + " contacts selected  " + badpins + " invalid PINS" ; break ; } catch ( IOException ioe ) { fileResponse = "An error occured while reading file." ; } } PinScreen . info . setText ( "Contacts selected!" ) ; if ( countpin < 1 ) { PinScreen . FileSel = null ; PinScreen . info . setText ( "No Contacts selected!" ) ; PinScreen . ContactArray . removeAllElements ( ) ; } fc . close ( ) ; System . out . println ( PinScreen . ContactArray . capacity ( ) ) ; System . out . println ( PinScreen . ContactArray . size ( ) ) ; } else { fileResponse = "Please select a file less than 300KB" ; } return fileResponse ; }
tr	5	public void rotate ( final int i , final double a , final double b ) { int j ; double c , fact , s , w , y ; if ( a == 0.0 ) { c = 0.0 ; s = ( b >= 0.0 ? 1.0 : - 1.0 ) ; } else if ( abs ( a ) > abs ( b ) ) { fact = b / a ; c = SIGN ( 1.0 / sqrt ( 1.0 + ( fact * fact ) ) , a ) ; s = fact * c ; } else { fact = a / b ; s = SIGN ( 1.0 / sqrt ( 1.0 + ( fact * fact ) ) , b ) ; c = fact * s ; } for ( j = i ; j < n ; j ++ ) { y = r [ i ] [ j ] ; w = r [ i + 1 ] [ j ] ; r [ i ] [ j ] = c * y - s * w ; r [ i + 1 ] [ j ] = s * y + c * w ; } for ( j = 0 ; j < n ; j ++ ) { y = qt [ i ] [ j ] ; w = qt [ i + 1 ] [ j ] ; qt [ i ] [ j ] = c * y - s * w ; qt [ i + 1 ] [ j ] = s * y + c * w ; } }
tr	5	void deleteActivity ( Component dialogParent , Activity activity ) { if ( activity != null ) { if ( AlertMessages . deleteActivityConfirmation ( dialogParent , activity ) ) { try { Connection conn = Dao . getConnection ( ) ; for ( Time t : timeDao . getTimesByActivity ( conn , activity ) ) { timeDao . deleteTime ( conn , t ) ; } activityDao . deleteActivity ( conn , activity ) ; activityDialog . setActivity ( null ) ; activityListDialog . selectPreviousRow ( ) ; activityDialog . setVisible ( false ) ; } catch ( SQLException ex ) { ErrorMessages . sqlExceptionError ( "deleteActivity()" , ex ) ; } catch ( ClassNotFoundException ex ) { ErrorMessages . classNotFoundError ( "deleteActivity()" , ex ) ; } } } else { AlertMessages . noActivitySelectedInTableForDeleting ( activityListDialog ) ; } }
tr	1	public YSpecification parseSpecification ( ) throws Exception { try { SAXParserFactory factory = SAXParserFactory . newInstance ( ) ; SAXParser saxParser = factory . newSAXParser ( ) ; YSpecificationHandler handler = new YSpecificationHandler ( ) ; YSAXHandler preliminar_info_handler = new YPreliminarInfoHandler ( ) ; saxParser . parse ( this . yawl_file , preliminar_info_handler ) ; handler . references ( ) . put ( "decomposition_types" , preliminar_info_handler . values ( ) ) ; saxParser . parse ( this . yawl_file , handler ) ; YSpecification s = handler . builder ( ) . buildSpecification ( ) ; t_info = handler . builder ( ) . translation_info ( ) ; return s ; } catch ( Exception e ) { throw new Exception ( "Error attempting to parse specification." , e ) ; } }
tr	5	void setProgrammeInfo ( int index , String field , String data ) { saved = false ; switch ( field ) { case "Date" : event . getProgrammeSchedule ( ) . get ( index ) . setProgrammeDate ( data ) ; break ; case "Start Time" : event . getProgrammeSchedule ( ) . get ( index ) . setStartTime ( Integer . parseInt ( data ) ) ; break ; case "End Time" : event . getProgrammeSchedule ( ) . get ( index ) . setEndTime ( Integer . parseInt ( data ) ) ; break ; case "Programme" : event . getProgrammeSchedule ( ) . get ( index ) . setTitle ( data ) ; break ; case "In-Charge" : event . getProgrammeSchedule ( ) . get ( index ) . setInCharge ( data ) ; break ; } }
tr	5	@ SuppressWarnings ( "unchecked" ) @ Override public < T extends Resource > T getOrLoadResource ( class < ? extends Resource > clazz , String resourceId , String filePath ) throws MapletResourceLoadException { if ( resources . containsKey ( resourceId ) ) { return ( T ) resources . get ( resourceId ) ; } else { ResourceType resourceType = clazz . getAnnotation ( ResourceType . class ) ; String [ ] fileExtensions = resourceType . extensions ( ) ; File resourceFile = null ; for ( String extension : fileExtensions ) { File file = new File ( MapletAPI . ROOT_DIRECTORY + filePath , resourceId + "." + extension ) ; if ( file . exists ( ) ) { resourceFile = file ; break ; } } if ( resourceFile != null ) { return loadResourceFromClass ( clazz , resourceId , resourceFile ) ; } else { throw new MapletResourceLoadException ( "Could not load resource file with ID '%s' in directory '%s'." , resourceId , filePath ) ; } } }
tr	9	public String toUpdateKML ( boolean suppressEnclosingTags ) { if ( ! isDirty ( ) ) { return "" ; } String change = "" ; boolean isPrimDirty = isPrimitiveDirty ( ) ; if ( isPrimDirty && ! suppressEnclosingTags ) { change += "<Point" ; if ( this . id != null ) { change += " id=\"" + this . getId ( ) + "\"" ; } if ( this . targetId != null ) { change += " targetId=\"" + this . getTargetId ( ) + "\"" ; } change += ">\n" ; } change += super . toUpdateKML ( true ) ; if ( this . isExtrudeDirty ) { change += "<extrude>" + this . extrude + "</extrude>\n" ; this . isExtrudeDirty = false ; } if ( this . isTessellateDirty ) { change += "<tessellate>" + this . tessellate + "</tessellate>\n" ; this . isTessellateDirty = false ; } if ( this . altitudeMode != null && this . isAltitudeModeDirty ) { change += "<altitudeMode>" + SpecialCaseFormatter . toKMLString ( this . altitudeMode ) + "</altitudeMode>\n" ; this . isAltitudeModeDirty = false ; } if ( this . coordinates != null && this . isCoordinatesDirty ) { change += "<coordinates>" + SpecialCaseFormatter . toKMLString ( this . getCoordinates ( ) ) + "</coordinates>\n" ; this . isCoordinatesDirty = false ; } if ( isPrimDirty && ! suppressEnclosingTags ) { change += "</Point>\n" ; } setNotDirty ( ) ; return change ; }
tr	1	public static final double performClassification ( final Net net , final SampleSet samples ) { ClassificationValidator val = new ClassificationValidator ( net ) ; for ( Sample s : samples ) { val . apply ( s ) ; } return val . ratio ( ) ; }
tr	4	public static double getMaximum ( Array array ) { if ( array . type ( ) != DataTypes . NUMERIC ) throw new IllegalArgumentException ( "Cannot compute minimum value of CHARACTER array." ) ; if ( array . size ( ) == 0 ) return Numeric . null ; double maximum = - double . MAX_VALUE ; for ( int i = 0 ; i < array . size ( ) ; i ++ ) { Numeric element = ( Numeric ) array . get ( i ) ; if ( element . get ( ) > maximum ) maximum = element . get ( ) ; } return maximum ; }
tr	3	public Comparator < Mob > getComparator ( ) { switch ( targetingMode ) { case leatHealth : return LEAST_HEALTH_COMPARATOR ; case nearest : return NEAREST_COMPARATOR ; case random : return RANDOM_COMPARATOR ; default : return null ; } }
tr	7	private static boolean KawigiEdit_RunTest ( int testNum , String [ ] p0 , int p1 , boolean hasAnswer , int p2 ) { System . out . print ( "Test " + testNum + ": [" + "{" ) ; for ( int i = 0 ; p0 . length > i ; ++ i ) { if ( i > 0 ) { System . out . print ( " " ) ; } System . out . print ( "\"" + p0 [ i ] + "\"" ) ; } System . out . print ( "}" + " " + p1 ) ; System . out . println ( "]" ) ; SimilarNames2 obj ; int answer ; obj = new SimilarNames2 ( ) ; long startTime = System . currentTimeMillis ( ) ; answer = obj . count ( p0 , p1 ) ; long endTime = System . currentTimeMillis ( ) ; boolean res ; res = true ; System . out . println ( "Time: " + ( endTime - startTime ) / 1000.0 + " seconds" ) ; if ( hasAnswer ) { System . out . println ( "Desired answer:" ) ; System . out . println ( "\t" + p2 ) ; } System . out . println ( "Your answer:" ) ; System . out . println ( "\t" + answer ) ; if ( hasAnswer ) { res = answer == p2 ; } if ( ! res ) { System . out . println ( "DOESN'T MATCH!!!!" ) ; } else if ( ( endTime - startTime ) / 1000.0 >= 2 ) { System . out . println ( "FAIL the timeout" ) ; res = false ; } else if ( hasAnswer ) { System . out . println ( "Match :-)" ) ; } else { System . out . println ( "OK  but is it right?" ) ; } System . out . println ( "" ) ; return res ; }
tr	2	public static List < Field > getFieldsByType ( Object object , class type ) { List < Field > list = new ArrayList < Field > ( ) ; Field [ ] fields = object . getClass ( ) . getDeclaredFields ( ) ; for ( Field field : fields ) { if ( field . getType ( ) . isAssignableFrom ( type ) ) { list . add ( field ) ; } } return list ; }
tr	9	public int getConfig ( int uid , int x , int y , int z ) { Ground tile = groundArray [ z ] [ x ] [ y ] ; if ( tile == null ) return - 1 ; if ( tile . wallObject != null && tile . wallObject . uid == uid ) return tile . wallObject . objConf & ff ; if ( tile . wallDecoration != null && tile . wallDecoration . uid == uid ) return tile . wallDecoration . objConf & ff ; if ( tile . groundDecoration != null && tile . groundDecoration . uid == uid ) return tile . groundDecoration . objConf & ff ; for ( int e = 0 ; e < tile . entityCount ; e ++ ) if ( tile . interactiveObjects [ e ] . uid == uid ) return tile . interactiveObjects [ e ] . objConf & ff ; return - 1 ; }
tr	1	public String displayFileChooserDialog ( ) { String pathToSelection ; chooser = new JFileChooser ( ) ; chooser . setCurrentDirectory ( new java . io . File ( "." ) ) ; chooser . setDialogTitle ( choosertitle ) ; chooser . setFileSelectionMode ( JFileChooser . FILES_ONLY ) ; chooser . setAcceptAllFileFilterUsed ( false ) ; if ( chooser . showOpenDialog ( this ) == JFileChooser . APPROVE_OPTION ) { pathToSelection = chooser . getSelectedFile ( ) . toString ( ) ; } else { pathToSelection = null ; } return pathToSelection ; }
tr	8	public static void main ( String [ ] args ) { int numElementos = leeNumero ( "Introduzca el n\u00FAmero de elementos a procesar (m\u00E1ximo 100): " ) ; if ( numElementos < 0 ) { System . out . println ( "\u00A1Ha de ser positivo!" ) ; return ; } else if ( numElementos > 100 ) { System . out . println ( "\u00A1Ha de ser menor o igual a 100!" ) ; return ; } int [ ] elementos = new int [ numElementos ] ; for ( int i = 0 ; i < numElementos ; i ++ ) elementos [ i ] = leeNumero ( ( i + 1 ) + ": " ) ; System . out . println ( ) ; ArrayList < Integer > noRepetidos = new ArrayList < Integer > ( numElementos ) ; for ( int i = 0 ; i < numElementos ; i ++ ) { if ( ! noRepetidos . contains ( elementos [ i ] ) ) noRepetidos . add ( elementos [ i ] ) ; } if ( numElementos == 0 ) { System . out . println ( "\u00A1No hay elementos a ordenar!" ) ; } else { System . out . println ( "Vector original:" ) ; for ( int a : elementos ) System . out . print ( a + " " ) ; System . out . println ( ) ; System . out . println ( "Vector sin repetidos:" ) ; for ( int a : noRepetidos ) System . out . print ( a + " " ) ; System . out . println ( ) ; } }
tr	2	public synchronized boolean checkUser ( String username , String boardName ) { for ( String board : boards . keySet ( ) ) { if ( ! boards . get ( board ) . checkUsernameAvailable ( username ) ) { return false ; } } enter ( username , boardName ) ; return true ; }
tr	3	public Queue getQueueById ( long queueId ) { Session session = null ; Queue queue = null ; try { session = HibernateUtil . getSessionFactory ( ) . openSession ( ) ; queue = ( Queue ) session . load ( Queue . class , queueId ) ; } catch ( Exception e ) { System . err . println ( "\u041E\u0448\u0438\u0431\u043A\u0430 'findById'" + e . getMessage ( ) ) ; } finally { if ( session != null && session . isOpen ( ) ) { session . close ( ) ; } } return queue ; }
tr	7	private static boolean KawigiEdit_RunTest ( int testNum , String [ ] p0 , boolean hasAnswer , int p1 ) { System . out . print ( "Test " + testNum + ": [" + "{" ) ; for ( int i = 0 ; p0 . length > i ; ++ i ) { if ( i > 0 ) { System . out . print ( " " ) ; } System . out . print ( "\"" + p0 [ i ] + "\"" ) ; } System . out . print ( "}" ) ; System . out . println ( "]" ) ; AlienAndGame obj ; int answer ; obj = new AlienAndGame ( ) ; long startTime = System . currentTimeMillis ( ) ; answer = obj . getNumber ( p0 ) ; long endTime = System . currentTimeMillis ( ) ; boolean res ; res = true ; System . out . println ( "Time: " + ( endTime - startTime ) / 1000.0 + " seconds" ) ; if ( hasAnswer ) { System . out . println ( "Desired answer:" ) ; System . out . println ( "\t" + p1 ) ; } System . out . println ( "Your answer:" ) ; System . out . println ( "\t" + answer ) ; if ( hasAnswer ) { res = answer == p1 ; } if ( ! res ) { System . out . println ( "DOESN'T MATCH!!!!" ) ; } else if ( ( endTime - startTime ) / 1000.0 >= 2 ) { System . out . println ( "FAIL the timeout" ) ; res = false ; } else if ( hasAnswer ) { System . out . println ( "Match :-)" ) ; } else { System . out . println ( "OK  but is it right?" ) ; } System . out . println ( "" ) ; return res ; }
tr	7	public boolean action ( Event event , Object arg ) { if ( event . target == okButton ) { ok = true ; if ( cb != null ) cb . getOptions ( ) ; endDialog ( ) ; } else if ( event . target == cancelButton ) { ok = false ; endDialog ( ) ; } else if ( event . target == autoSelect ) { zrle . setEnabled ( ! autoSelect . getState ( ) ) ; hextile . setEnabled ( ! autoSelect . getState ( ) ) ; raw . setEnabled ( ! autoSelect . getState ( ) ) ; } else if ( event . target == encodingSel ) { ( ( CardLayout ) cardPanel . getLayout ( ) ) . show ( cardPanel , "Encoding and Colour Level:" ) ; makeBold ( encodingSel ) ; } else if ( event . target == inputSel ) { ( ( CardLayout ) cardPanel . getLayout ( ) ) . show ( cardPanel , "Inputs:" ) ; makeBold ( inputSel ) ; } else if ( event . target == miscSel ) { ( ( CardLayout ) cardPanel . getLayout ( ) ) . show ( cardPanel , "Misc:" ) ; makeBold ( miscSel ) ; } return true ; }
tr	0	public String getName ( ) { return getClass ( ) . getName ( ) ; }
tr	6	public static void main ( String [ ] args ) { int choice = 0 ; int select = 0 ; boolean exit = false ; Scanner input = new Scanner ( System . in ) ; System . out . println ( "Welcome  Please select your role in the resturant?" ) ; System . out . println ( "Menu Role" ) ; System . out . println ( ) ; System . out . println ( "0. Customer" ) ; System . out . println ( "1. Manager" ) ; System . out . println ( "2. Cook" ) ; System . out . println ( "3. Waitperson" ) ; System . out . println ( "4. Staff Member" ) ; System . out . println ( "5. Exit" ) ; choice = input . nextInt ( ) ; switch ( choice ) { case 0 : Customer guest = new Customer ( ) ; guest . displayMenu ( ) ; break ; case 1 : Manager m = new Manager ( ) ; m . displayMenu ( ) ; break ; case 2 : Cook c = new Cook ( ) ; c . displayMenu ( ) ; break ; case 3 : Waitperson w = new Waitperson ( ) ; w . displayMenu ( ) ; break ; case 4 : StaffMember s = new StaffMember ( ) ; s . displayMenu ( ) ; break ; case 5 : exit = true ; break ; default : System . out . println ( "Invalid Entry!" ) ; } }
tr	0	public boolean jogador1EhVencedor ( ) { return jogador1 . ehVencedor ( ) ; }
tr	1	public String toString ( ) { StringBuilder out = new StringBuilder ( ) ; for ( ArrayPlace arrayPlace : arrayPlaces ) out . append ( arrayPlace ) . append ( "=" ) ; out . append ( expression ) ; return out . toString ( ) ; }
tr	8	public String getColumnName ( int colIndex ) { String name ; int index = colIndex + firstDayOfWeek ; if ( index > Calendar . SATURDAY ) { index = Calendar . SUNDAY ; } switch ( index ) { case Calendar . SUNDAY : name = NAMES_OF_DAYS [ 0 ] ; break ; case Calendar . MONDAY : name = NAMES_OF_DAYS [ 1 ] ; break ; case Calendar . TUESDAY : name = NAMES_OF_DAYS [ 2 ] ; break ; case Calendar . WEDNESDAY : name = NAMES_OF_DAYS [ 3 ] ; break ; case Calendar . THURSDAY : name = NAMES_OF_DAYS [ 4 ] ; break ; case Calendar . FRIDAY : name = NAMES_OF_DAYS [ 5 ] ; break ; case Calendar . SATURDAY : name = NAMES_OF_DAYS [ 6 ] ; break ; default : name = "" ; } return name ; }
tr	0	public final void testGetName ( ) { Player player = new Player ( "Fred" ) ; assert . assertEquals ( player . getName ( ) , "Fred" ) ; }
tr	6	@ Override public void run ( ) { String [ ] hosts = execHosts . split ( " " ) ; int numHosts = hosts . length ; int currentHost = 0 ; sgeExecHostsExampleScrollPane . setVisible ( false ) ; validatingHostsLabel . setVisible ( true ) ; sif . setNextEnabled ( false ) ; sif . setBackEnabled ( false ) ; List < String > checkedHosts = new LinkedList < String > ( ) ; for ( String host : hosts ) { host = host . trim ( ) ; if ( checkedHosts . contains ( host ) ) { finished ( "The host " + host + " has been entered more than\n" + "once. Each entry line has to be unique.\n" , "Duplicate execution hosts found" ) ; return ; } if ( host . equals ( hostname ) ) { checkedHosts . add ( host ) ; continue ; } validatingHostsLabel . setText ( "Validating hosts..." + ( currentHost * 100 / numHosts ) + "%" ) ; Process p = null ; try { p = Runtime . getRuntime ( ) . exec ( "install_files/checkHost.sh " + host ) ; p . waitFor ( ) ; if ( p . exitValue ( ) != 0 ) { finished ( "Please make sure that the host " + host + "\n" + "      - exists AND\n" + "      - accepts ssh connections AND\n" + "      - allows this host to log in without specifying password." , "Invalid host found " + host ) ; return ; } } catch ( Exception ex ) { ex . printStackTrace ( ) ; } finally { if ( p != null ) NativeCalls . releaseProcess ( p ) ; } checkedHosts . add ( host ) ; currentHost ++ ; validatingHostsLabel . setText ( "Validating hosts..." + ( currentHost * 100 / numHosts ) + "%" ) ; } sgeExecHostsExampleScrollPane . setVisible ( true ) ; validatingHostsLabel . setText ( "" ) ; validatingHostsLabel . setVisible ( false ) ; sif . setNextEnabled ( true ) ; sif . setBackEnabled ( true ) ; hostValidationPassed = true ; sif . nextButtonAction ( ) ; }
tr	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( Modificar_observaciones_front . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( Modificar_observaciones_front . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( Modificar_observaciones_front . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( Modificar_observaciones_front . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { new Modificar_observaciones_front ( ) . setVisible ( true ) ; } } ) ; }
tr	5	private boolean haveFreeRouteLine ( float x1 , float y1 , float x2 , float y2 ) { if ( Math . abs ( x1 - x2 ) <= 1 && Math . abs ( y1 - y2 ) <= 1 ) { int line = y2 >= map . getNumLines ( ) - 1 ? map . getNumLines ( ) - 1 : ( int ) y2 ; int col = x2 >= map . getNumColumns ( ) - 1 ? map . getNumColumns ( ) - 1 : ( int ) x2 ; boolean a = map . getPosition ( line , col ) == map . getFREE ( ) ; return a ; } float diff_x = Math . abs ( x1 - x2 ) ; float middle_x = ( float ) ( diff_x / 2 + Math . min ( x1 , x2 ) ) ; float diff_y = ( float ) Math . abs ( y1 - y2 ) ; float middle_y = ( float ) ( diff_y / 2 + Math . min ( y1 , y2 ) ) ; boolean b = haveFreeRouteLine ( x1 , y1 , middle_x , middle_y ) ? haveFreeRouteLine ( middle_x , middle_y , x2 , y2 ) : false ; return b ; }
tr	3	public List < Hostel > getAvailableBedsInAllHostels ( Date startDate , Date endDate ) { List < Hostel > hostels = null ; if ( startDate . after ( endDate ) ) { return null ; } Calendar cal = Calendar . getInstance ( ) ; cal . setTime ( new java . util . Date ( ) ) ; if ( startDate . before ( cal . getTime ( ) ) ) { return null ; } try { hostels = hostelDAOImpl . getAvailableBedsInAllHostels ( startDate , endDate ) ; } catch ( ServiceLocatorException | SQLException e ) { e . printStackTrace ( ) ; } return hostels ; }
tr	9	public LepraUser parseContent ( String content ) throws LepraException { if ( StringUtils . isBlank ( content ) || "null" . equalsIgnoreCase ( content . trim ( ) ) ) { throw new LepraLoginException ( ) ; } JSONObject obj = new JSONObject ( content ) ; String status = obj . getString ( "status" ) ; if ( status == null || ! "OK" . equalsIgnoreCase ( status ) ) { JSONArray errors = obj . optJSONArray ( "errors" ) ; if ( errors != null && errors . length ( ) > 0 ) { for ( int i = 0 ; i < errors . length ( ) ; i ++ ) { JSONObject error = errors . getJSONObject ( i ) ; if ( error != null && StringUtils . equalsIgnoreCase ( error . getString ( "code" ) , "invalid_password" ) ) { throw new LepraInvalidLoginPasswordException ( ) ; } if ( error != null && StringUtils . equalsIgnoreCase ( error . getString ( "code" ) , "captcha_required" ) ) { throw new LepraCaptchaRequired ( ) ; } } } throw new LepraLoginException ( ) ; } JSONObject user = obj . getJSONObject ( "user" ) ; return new LepraUser ( user . getInt ( "id" ) , user . getString ( "login" ) , user . getString ( "gender" ) , user . getInt ( "karma" ) ) ; }
tr	6	public boolean check ( PrintStream ps , double tol ) { double dist ; double pointTol = 10 * tol ; if ( ! checkFaces ( tolerance , ps ) ) { return false ; } for ( int i = 0 ; i < numPoints ; i ++ ) { Point3d pnt = pointBuffer [ i ] . pnt ; for ( Iterator it = faces . iterator ( ) ; it . hasNext ( ) ; ) { Face face = ( Face ) it . next ( ) ; if ( face . mark == Face . VISIBLE ) { dist = face . distanceToPlane ( pnt ) ; if ( dist > pointTol ) { if ( ps != null ) { ps . println ( "Point " + i + " " + dist + " above face " + face . getVertexString ( ) ) ; } return false ; } } } } return true ; }
tr	2	public static BankAccount searchAccountInDb ( String userName ) { BankAccount konto = null ; String namn ; int balance ; try { makeConnectionDb ( ) ; String searchQuery = "SELECT `UserName`  `Balance` FROM `bankaccount` WHERE (`UserName` = '" + userName + "')" ; ResultSet result = stmt . executeQuery ( searchQuery ) ; while ( result . next ( ) ) { namn = result . getString ( "UserName" ) ; balance = result . getInt ( "Balance" ) ; konto = new BankAccount ( namn , balance ) ; } stmt . close ( ) ; con . close ( ) ; } catch ( SQLException ex ) { dialogBoxEvent ( "Fel vid DB search" , 1 ) ; } return konto ; }
tr	5	@ Override public int hashCode ( ) { int result = iduser ; result = 31 * result + ( firstName != null ? firstName . hashCode ( ) : 0 ) ; result = 31 * result + ( lastName != null ? lastName . hashCode ( ) : 0 ) ; result = 31 * result + ( email != null ? email . hashCode ( ) : 0 ) ; result = 31 * result + ( password != null ? password . hashCode ( ) : 0 ) ; result = 31 * result + ( activateKey != null ? activateKey . hashCode ( ) : 0 ) ; return result ; }
tr	5	@ Override public void unmarshal ( Element fileGrp ) { super . unmarshal ( fileGrp ) ; if ( fileGrp . hasAttribute ( "VERSDATE" ) ) { DatatypeFactory dtf = MetsIO . getDataTypeFactory ( ) ; String value = fileGrp . getAttribute ( "VERSDATE" ) ; this . versdate = dtf . newXMLGregorianCalendar ( value ) ; } if ( fileGrp . hasAttribute ( "USE" ) ) this . use = fileGrp . getAttribute ( "USE" ) ; List < Element > children = DOMHelp . getChildElements ( fileGrp ) ; for ( Element child : children ) { String localName = child . getLocalName ( ) ; if ( localName . equals ( "fileGrp" ) ) { FileGrp subFileGrp = new FileGrp ( ) ; subFileGrp . unmarshal ( child ) ; this . getFileGrp ( ) . add ( subFileGrp ) ; } if ( localName . equals ( "file" ) ) { File file = new File ( ) ; file . unmarshal ( child ) ; this . getFile ( ) . add ( file ) ; } } }
tr	1	public String toString ( ) { NumberFormat nf = NumberFormat . getCurrencyInstance ( Locale . US ) ; StringBuilder buffer = new StringBuilder ( ) ; if ( tipo ) { buffer . append ( nf . format ( monto ) ) . append ( " " ) . append ( fecha . getDate ( ) ) ; } else { buffer . append ( fecha . getDate ( ) ) . append ( " " ) . append ( nf . format ( monto ) ) ; } return buffer . toString ( ) ; }
tr	7	public String toUpdateKML ( boolean suppressEnclosingTags ) { if ( ! isDirty ( ) ) { return "" ; } String change = "" ; boolean isPrimDirty = isPrimitiveDirty ( ) ; if ( isPrimDirty && ! suppressEnclosingTags ) { change += "<Create" ; change += ">\n" ; } change += super . toUpdateKML ( true ) ; if ( this . folder != null && this . folder . isDirty ( ) ) { change += this . folder . toUpdateKML ( ) ; } if ( isPrimDirty && ! suppressEnclosingTags ) { change += "</Create>\n" ; } setNotDirty ( ) ; return change ; }
tr	4	public void calMinCoins ( ) { C [ 0 ] = 0 ; S [ 0 ] = - 1 ; for ( int i = 1 ; i <= n ; i ++ ) { int min = Integer . MAX_VALUE ; int index = - 1 ; for ( int j = 0 ; j < V . length ; j ++ ) { if ( i >= V [ j ] ) { if ( 1 + C [ i - V [ j ] ] <= min ) { min = 1 + C [ i - V [ j ] ] ; index = j ; } } } C [ i ] = min ; S [ i ] = index ; } }
tr	4	OptionSet ( Map < String , AbstractOptionSpec < ? >> recognizedSpecs ) { detectedSpecs = new ArrayList < OptionSpec < ? >> ( ) ; detectedOptions = new HashMap < String , AbstractOptionSpec < ? >> ( ) ; optionsToArguments = new IdentityHashMap < AbstractOptionSpec < ? > , List < String >> ( ) ; defaultValues = defaultValues ( recognizedSpecs ) ; this . recognizedSpecs = recognizedSpecs ; }
tr	1	public void run ( ) { boolean autoFlushStream = true ; try { in = new BufferedReader ( new InputStreamReader ( clientSocket . getInputStream ( ) ) ) ; out = new PrintWriter ( clientSocket . getOutputStream ( ) , autoFlushStream ) ; out . println ( "sWait" ) ; processPlayer ( ) ; } catch ( IOException ioe ) { System . out . println ( "Some I/O error occured..." + ioe . getMessage ( ) ) ; } }
tr	0	public void setRing ( boolean ring ) { this . ring = ring ; }
tr	1	@ Override public void update ( ) { AIHockeyist puckOwner = manager . getPuckOwner ( ) ; AIRectangle myZone = manager . getMyZone ( ) ; int currentTick = manager . getCurrentTick ( ) ; init ( ) ; for ( Map . Entry < long , AIRole > p : roles . entrySet ( ) ) { moves . put ( p . getKey ( ) , p . getValue ( ) . move ( ) ) ; } }
tr	9	public void InitializeGameWorld ( int numEnemyTanks , int numRocks , int numTrees ) { listObjects = new LinkedList < GameObject > ( ) ; tanks = new LinkedList < Tank > ( ) ; landscape = new LinkedList < LandscapeGameObject > ( ) ; projectiles = new LinkedList < Projectile > ( ) ; playerTank = getRandomPlayerTank ( 0 ) ; for ( int i = 0 ; i < numEnemyTanks ; i ++ ) { Tank tank = getRandomTank ( ) ; while ( collidesWithWorld ( tank ) ) { if ( Game . debug ) { System . out . println ( "tank placement collision" ) ; } tank = getRandomTank ( ) ; } addTank ( tank ) ; } for ( int j = 0 ; j < numRocks ; j ++ ) { Rock rock = getRandomRock ( j ) ; while ( collidesWithWorld ( rock ) ) { if ( Game . debug ) { System . out . println ( "rock placement collision" ) ; } rock = getRandomRock ( j ) ; } addLandscapeObject ( rock ) ; } for ( int k = 0 ; k < numTrees ; k ++ ) { Tree tree = getRandomTree ( k ) ; while ( collidesWithWorld ( tree ) ) { if ( Game . debug ) { System . out . println ( "tree placement collision" ) ; } tree = getRandomTree ( k ) ; } addLandscapeObject ( tree ) ; } addTank ( playerTank ) ; lives = startingLives ; score = 0 ; gameClock = 0 ; gameOver = false ; TotaltankCount = 0 ; notifyObservers ( ) ; }
tr	7	public String getPopulationDetails ( Field field ) { StringBuffer buffer = new StringBuffer ( ) ; if ( ! countsValid ) { generateCounts ( field ) ; } for ( class key : counters . keySet ( ) ) { Counter info = counters . get ( key ) ; int stringLength = info . getName ( ) . length ( ) ; buffer . append ( info . getName ( ) . substring ( 10 , stringLength ) ) ; buffer . append ( ": " ) ; buffer . append ( info . getCount ( ) ) ; buffer . append (   ) ; if ( info . getName ( ) . equals ( "bin.model.Fox" ) ) { foxCount = info . getCount ( ) ; } if ( info . getName ( ) . equals ( "bin.model.Bear" ) ) { bearCount = info . getCount ( ) ; } if ( info . getName ( ) . equals ( "bin.model.Rabbit" ) ) { rabbitCount = info . getCount ( ) ; } if ( info . getName ( ) . equals ( "bin.model.Wolf" ) ) { wolfCount = info . getCount ( ) ; } if ( info . getName ( ) . equals ( "bin.model.Grass" ) ) { grassCount = info . getCount ( ) ; } } return buffer . toString ( ) ; }
tr	6	@ Override public boolean doCommand ( final CommandSender sender , final Command command , final String cmd , final String [ ] args ) { if ( ! canUseCommand ( sender , cmd , true , true ) ) { return true ; } final AllAdminUser user = ( AllAdminUser ) AllAdmin . getUser ( sender . getName ( ) ) ; String homeName = null ; if ( user . getBukkitPlayer ( ) . hasPermission ( "alladmin.multihome" ) ) { if ( args . length == 1 ) { homeName = args [ 0 ] ; } } final Location homeLoc = user . getHome ( homeName == null ? homeName : "home" ) ; if ( homeLoc == null ) { user . getBukkitPlayer ( ) . sendMessage ( AllAdmin . getMessages ( "notSetHome" ) ) ; return true ; } user . getBukkitPlayer ( ) . teleport ( user . getHome ( homeName == null ? homeName : "home" ) ) ; return true ; }
tr	4	protected BigRational recallG ( MultiplicitiesVector m , PopulationVector p ) { if ( p . isZeroVector ( ) ) { return BigRational . ONE ; } else if ( p . containsMinusOne ( ) ) { return BigRational . ZERO ; } else if ( m . isZeroVector ( ) ) { return initialConditionFor ( p ) ; } else { Map < MultiplicitiesVector , BigRational > step1 = Gmap . get ( p ) ; if ( step1 != null ) { BigRational toReturn = step1 . get ( m ) ; return toReturn ; } else { return null ; } } }
tr	1	@ Override public DataUnit read ( Protocol p , ReadableByteChannel channel ) throws IOException { ReadableByteChannel currentChannel = channel ; DataUnit dataUnit = headerProcessor . read ( p , currentChannel ) ; int totalLength = ProtocolUtil . getTotalLength ( dataUnit , p ) ; if ( totalLength != - 1 ) { int toRead = totalLength - ProtocolUtil . getHeaderBytes ( p ) ; byte [ ] bytes = IoUtil . readBytes ( toRead , currentChannel ) ; currentChannel = Channels . newChannel ( new ByteArrayInputStream ( bytes ) ) ; } dataUnit = unitProcessor . fromStream ( dataUnit , p , currentChannel ) ; currentChannel = channel ; return dataUnit ; }
tr	2	public Set < Point > getPossibleMoves ( PlayerToken player ) { Set < Point > result = new HashSet < Point > ( ) ; Point loc = tokenLocs . get ( player ) ; for ( Point p : getAdjacentSquares ( player ) ) { if ( isMovable ( loc , p ) ) { result . add ( p ) ; } } return result ; }
tr	2	public void eliminarUsuario ( Usuario u ) { if ( this . seguridad . permitidoAdministrarUsuarios ( ) && this . existeUsuarioConCodigo ( u . getCodigo ( ) ) ) { this . usuarios . remove ( u ) ; this . destruccionUsuario ( u ) ; } }
tr	2	public void paint ( Graphics g ) { if ( vertexList . size ( ) == 0 ) return ; Polygon p = getPolygon ( ) ; if ( isFilled ( ) ) { g . setColor ( getFillColor ( ) ) ; g . fillPolygon ( p . xpoints , p . ypoints , p . npoints ) ; g . setColor ( getColor ( ) ) ; } g . drawPolygon ( p . xpoints , p . ypoints , p . npoints ) ; }
tr	0	public Date getDTransactionDate ( ) { return dTransactionDate ; }
tr	9	public void setRecursiveNotDirty ( ) { super . setRecursiveNotDirty ( ) ; if ( this . iconStyle != null && this . iconStyle . isDirty ( ) ) { this . iconStyle . setRecursiveNotDirty ( ) ; } if ( this . labelStyle != null && this . labelStyle . isDirty ( ) ) { this . labelStyle . setRecursiveNotDirty ( ) ; } if ( this . lineStyle != null && this . lineStyle . isDirty ( ) ) { this . lineStyle . setRecursiveNotDirty ( ) ; } if ( this . polyStyle != null && this . polyStyle . isDirty ( ) ) { this . polyStyle . setRecursiveNotDirty ( ) ; } if ( this . balloonStyle != null && this . balloonStyle . isDirty ( ) ) { this . balloonStyle . setRecursiveNotDirty ( ) ; } if ( this . listStyle != null && this . listStyle . isDirty ( ) ) { this . listStyle . setRecursiveNotDirty ( ) ; } }
tr	8	private static MessageType decodeMessageType ( byte messageType ) { switch ( messageType ) { case Packet . MESSAGE_TYPE_APPLICATION : return MessageType . APPLICATION ; case Packet . MESSAGE_TYPE_PING : return MessageType . PING ; case Packet . MESSAGE_TYPE_PING_RESPONSE : return MessageType . PING_RESPONSE ; case Packet . MESSAGE_TYPE_CONNECT_REQUEST : return MessageType . CONNECT_REQUEST ; case Packet . MESSAGE_TYPE_CONNECTION_ACCEPTED : return MessageType . CONNECTION_ACCEPTED ; case Packet . MESSAGE_TYPE_CONNECTION_REFUSED : return MessageType . CONNECTION_REFUSED ; case Packet . MESSAGE_TYPE_FORCE_DISCONNECT : return MessageType . FORCE_DISCONNECT ; case Packet . MESSAGE_TYPE_CLIENT_DISCONNECT : return MessageType . CLIENT_DISCONNECT ; default : return MessageType . INVALID ; } }
tr	5	private void fixHeap ( ) { s += "\n" + "before fix: " + elements . toString ( ) ; Comparable < Object > root = elements . get ( 1 ) ; int lastIndex = elements . size ( ) - 1 ; int index = 1 ; boolean more = true ; while ( more ) { int childIndex = getLeftChildIndex ( index ) ; s += "\n" + "fix childIndex: " + childIndex ; if ( childIndex <= lastIndex ) { Comparable < Object > child = getLeftChild ( index ) ; s += "\n" + "fix child: " + child + " ROOT: " + root ; if ( getRightChildIndex ( index ) <= lastIndex && getRightChild ( index ) . compareTo ( child ) < 0 ) { childIndex = getRightChildIndex ( index ) ; child = getRightChild ( index ) ; s += "\n" + "fix -childIndex: " + childIndex ; s += "\n" + "fix -child: " + child + " ROOT: " + root ; } if ( child . compareTo ( root ) < 0 ) { elements . set ( index , child ) ; index = childIndex ; s += "\n" + "fix : " + elements . toString ( ) + " index: " + index + " ROOT: " + root ; } else { more = false ; } } else { more = false ; } } elements . set ( index , root ) ; s += "\n" + "Fix: " + elements . toString ( ) ; }
tr	4	public static String nullSafeToString ( double [ ] array ) { if ( array == null ) { return NULL_STRING ; } int length = array . length ; if ( length == 0 ) { return EMPTY_ARRAY ; } StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < length ; i ++ ) { if ( i == 0 ) { sb . append ( ARRAY_START ) ; } else { sb . append ( ARRAY_ELEMENT_SEPARATOR ) ; } sb . append ( array [ i ] ) ; } sb . append ( ARRAY_END ) ; return sb . toString ( ) ; }
tr	8	public static void main ( String [ ] args ) { int X , m ; int a1 , a2 , a3 ; int m1 , m2 , m3 ; int M1 , M2 , M3 ; int y1 , y2 , y3 ; y1 = y2 = y3 = 1 ; Scanner in = new Scanner ( System . in ) ; a1 = in . nextInt ( ) ; m1 = in . nextInt ( ) ; a2 = in . nextInt ( ) ; m2 = in . nextInt ( ) ; a3 = in . nextInt ( ) ; m3 = in . nextInt ( ) ; m = m1 * m2 * m3 ; M1 = m / m1 ; M2 = m / m2 ; M3 = m / m3 ; for ( int i = 1 ; i <= M1 ; i ++ ) { if ( congruent ( M1 * i , 1 , m1 ) ) { y1 = i ; break ; } } for ( int i = 1 ; i <= M2 ; i ++ ) { if ( congruent ( M2 * i , 1 , m2 ) ) { y2 = i ; break ; } } for ( int i = 1 ; i <= M3 ; i ++ ) { if ( congruent ( M3 * i , 1 , m3 ) ) { y3 = i ; break ; } } X = a1 * M1 * y1 + a2 * M2 * y2 + a3 * M3 * y3 ; int answer = 1 ; for ( int i = 1 ; i <= X ; i ++ ) { if ( congruent ( X , i , m ) ) { answer = i ; break ; } } System . out . println ( "A resposta \u00E9 " + answer ) ; System . out . println ( "Se a resposta dada n\u00E3o est\u00E1 num intervalo dado pelo problema  apenas adicione " + m + " \u00E0 resposta at\u00E9 que esteja" ) ; }
tr	4	final public CreateSubschemaCommand CreateSubschema_suffix ( ) throws ParseException { String tableName ; List < String > attrNames = new ArrayList < String > ( ) ; String attrName ; jj_consume_token ( KW_SUBSCHEMA ) ; tableName = Identifier ( ) ; attrName = Identifier ( ) ; attrNames . add ( attrName ) ; label_1 : while ( true ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case 51 : ; break ; default : jj_la1 [ 5 ] = jj_gen ; break label_1 ; } jj_consume_token ( 51 ) ; attrName = Identifier ( ) ; attrNames . add ( attrName ) ; } { if ( true ) return new CreateSubschemaCommand ( token , tableName , attrNames ) ; } throw new Error ( "Missing return statement in function" ) ; }
tr	9	final public void edgeRHS ( ) throws ParseException { ASTedgeRHS jjtn000 = new ASTedgeRHS ( JJTEDGERHS ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; try { edgeop ( ) ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case ID : node_id ( ) ; break ; case SUBGRAPH : case { : subgraph ( ) ; break ; default : jj_la1 [ 11 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case EDGE_UNDIRECTED : case EDGE_DIRECTED : edgeRHS ( ) ; break ; default : jj_la1 [ 12 ] = jj_gen ; ; } } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; } } }
tr	2	public JSONArray ( Collection collection ) { this . myArrayList = new ArrayList ( ) ; if ( collection != null ) { Iterator iter = collection . iterator ( ) ; while ( iter . hasNext ( ) ) { this . myArrayList . add ( JSONObject . wrap ( iter . next ( ) ) ) ; } } }
tr	6	public static void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; while ( true ) { System . out . print ( "Choose a map (1 2 3) or 0 to quit (4 at your own risk): " ) ; int which = input . nextInt ( ) ; MMap . MapSet map = MMap . MapSet . MAP1 ; switch ( which ) { case 1 : map = MMap . MapSet . MAP1 ; break ; case 2 : map = MMap . MapSet . MAP2 ; break ; case 3 : map = MMap . MapSet . MAP3 ; break ; case 4 : map = MMap . MapSet . MAP4 ; break ; default : System . out . println ( "bailing!" ) ; System . exit ( 1 ) ; } System . out . println ( "solving this map:" ) ; SenselessSolver rs = new SenselessSolver ( new MMap ( map ) ) ; for ( int i = 0 ; i < rs . map . gridSize ; i ++ ) { System . out . println ( rs . map . current_map [ i ] ) ; } rs . Solve ( ) ; } }
tr	5	protected com . akamon . slots . model . BetClass ParseBetClass ( BetClass xmlBetClass ) throws SlotModelException { int baseBet = xmlBetClass . basebet ; String betMultList = xmlBetClass . betMultList ; if ( betMultList . equals ( "*" ) || betMultList . toUpperCase ( ) . equals ( "ALL" ) ) return new com . akamon . slots . model . BetClass ( baseBet ) ; else { HashSet < Integer > betMults = new HashSet < Integer > ( ) ; String [ ] splitBetMultList = betMultList . split ( " " ) ; for ( int i = 0 ; i < splitBetMultList . length ; i ++ ) { try { int betMult = Integer . parseInt ( splitBetMultList [ i ] ) ; if ( betMults . contains ( betMult ) ) throw new com . akamon . slots . model . SlotModelException ( "Bet class has duplicate bet multipliers: " + betMultList ) ; betMults . add ( betMult ) ; } catch ( Exception e ) { throw new com . akamon . slots . model . SlotModelException ( "Invalid bet class value: " + splitBetMultList [ i ] ) ; } } return new com . akamon . slots . model . BetClass ( baseBet , betMults ) ; } }
tr	2	@ Override public void onPairFailed ( ) { synchronized ( mListeners ) { for ( DiscoveryListener listener : mListeners ) { try { listener . onPairFailed ( ) ; } catch ( RuntimeException e ) { System . out . println ( "Error notifying listener." ) ; } } } System . out . println ( "onPairFailed" ) ; }
tr	0	@ Override public double getRotationDeg ( ) { return rotation ; }
tr	8	@ SuppressWarnings ( { "unchecked" } ) @ Override public List < R > exclude ( R other ) { if ( ! overlaps ( other ) ) { return Collections . singletonList ( ( R ) this ) ; } else if ( other . contains ( ( R ) this ) ) { return Collections . emptyList ( ) ; } else if ( ! this . contains ( other . start ( ) ) && this . contains ( other . end ( ) ) ) { return Collections . singletonList ( newInstance ( other . end ( ) . next ( ) , this . end ) ) ; } else if ( this . contains ( other . start ( ) ) && ! this . contains ( other . end ( ) ) ) { return Collections . singletonList ( newInstance ( this . start , other . start ( ) . previous ( ) ) ) ; } else { if ( this . hasSameStart ( other ) ) { return Collections . singletonList ( newInstance ( other . end ( ) . next ( ) , this . end ) ) ; } else if ( this . hasSameEnd ( other ) ) { return Collections . singletonList ( newInstance ( this . start , other . start ( ) . previous ( ) ) ) ; } else { ArrayList < R > rs = new ArrayList < R > ( 2 ) ; rs . add ( newInstance ( this . start , other . start ( ) . previous ( ) ) ) ; rs . add ( newInstance ( other . end ( ) . next ( ) , this . end ) ) ; return rs ; } } }
tr	3	private void initCustomTag ( RandomAccessFile file ) throws IOException { int bufferLength = ( int ) ( getLength ( ) - ( endOffset + 1 ) ) ; if ( hasId3v1Tag ( ) ) bufferLength -= ID3v1Tag . TAG_LENGTH ; if ( bufferLength <= 0 ) { customTag = null ; } else { customTag = new byte [ bufferLength ] ; file . seek ( endOffset + 1 ) ; int bytesRead = file . read ( customTag , 0 , bufferLength ) ; if ( bytesRead < bufferLength ) throw new IOException ( "Not enough bytes read" ) ; } }
tr	6	private Initializer ( ServletContext servletContext ) { try { readCredentials ( servletContext ) ; JAXBContext context = JAXBContext . newInstance ( WorkUnit . class ) ; workUnitMarshaller = context . createMarshaller ( ) ; workUnitMarshaller . setProperty ( Marshaller . JAXB_ENCODING , "UTF-8" ) ; sqsClient = new AmazonSQSClient ( this . credentials ) ; unitsOnServer = createUnitsOnServer ( ) ; try { dispatchQueue = createQueue ( sqsClient , Constants . dispatchQueueName ) ; returnQueue = createQueue ( sqsClient , Constants . returnQueueName ) ; } catch ( AmazonServiceException ase2 ) { if ( ase2 . getErrorCode ( ) . equals ( "AWS.SimpleQueueService.QueueDeletedRecently" ) ) { logger . info ( "Waiting 60s to respawn SQS queues" ) ; System . out . println ( "Waiting 60 to respawn SQS queues" ) ; Thread . sleep ( 60000 ) ; dispatchQueue = createQueue ( sqsClient , Constants . dispatchQueueName ) ; returnQueue = createQueue ( sqsClient , Constants . returnQueueName ) ; } else { throw ase2 ; } } } catch ( AmazonServiceException ase ) { System . err . println ( "Caught an AmazonServiceException  which means your request made it " + "to Amazon AWS  but was rejected with an error response for some reason." ) ; System . err . println ( "Error Message:    " + ase . getMessage ( ) ) ; System . err . println ( "HTTP Status Code: " + ase . getStatusCode ( ) ) ; System . err . println ( "AWS Error Code:   " + ase . getErrorCode ( ) ) ; System . err . println ( "Error Type:       " + ase . getErrorType ( ) ) ; System . err . println ( "Request ID:       " + ase . getRequestId ( ) ) ; } catch ( AmazonClientException ace ) { System . err . println ( "Caught an AmazonClientException  which means the client encountered " + "a serious internal problem while trying to communicate with AWS  such as not " + "being able to access the network." ) ; System . err . println ( "Error Message: " + ace . getMessage ( ) ) ; } catch ( NullPointerException npee ) { System . err . println ( "Couldn't find credentials file\n" ) ; } catch ( Exception e ) { System . err . println ( e ) ; } sqsListener = new Thread ( new SqsListener ( this ) ) ; sqsListener . setName ( "sqsListener" ) ; sqsListener . start ( ) ; gridManager = new Thread ( new GridManager ( this ) ) ; gridManager . setName ( "gridManager" ) ; gridManager . start ( ) ; }
tr	1	public IValue peek ( ) { if ( _stack . isEmpty ( ) ) { return null ; } return _stack . peek ( ) ; }
tr	0	public void setPhoneNum ( PhoneNumber phoneNum ) { this . phoneNum = phoneNum ; }
tr	5	private static interface getHID ( Device dev ) throws IOException { Configuration config ; interface retval = null ; DeviceDescriptor info = dev . getDeviceDescriptor ( ) ; if ( info . getDeviceClass ( ) != 0 ) throw new IllegalArgumentException ( "dev class" ) ; config = dev . getConfiguration ( ) ; for ( int i = config . getNumInterfaces ( ) ; i -- != 0 ; ) { interface intf = config . getInterface ( i , 0 ) ; if ( intf . getInterfaceClass ( ) == intf . CLASS_HID ) { if ( retval != null ) throw new IllegalArgumentException ( "multi-hid" ) ; retval = intf ; } } if ( retval == null ) throw new IllegalArgumentException ( "not hid" ) ; return retval ; }
tr	8	private int getKingAxisVal ( int loc ) { switch ( loc ) { case 0 : case 7 : return - 4 ; case 1 : case 6 : return - 2 ; case 2 : case 5 : return 2 ; case 3 : case 4 : return 4 ; default : return 0 ; } }
tr	5	private void addGuestToBookingButtonActionPerformed ( java . awt . event . ActionEvent evt ) { boolean addGuestSuccess ; Booking currentBooking = ctr . getCurrentBooking ( ) ; if ( currentBooking != null && guestJList2 . getSelectedValue ( ) != null ) { Guest guest = ( Guest ) guestJList2 . getSelectedValue ( ) ; if ( ! addedGuestsModel . contains ( guest ) ) { if ( ctr . checkRoomAvailability ( currentBooking , addedGuestsModel . getSize ( ) ) > 0 ) { addGuestSuccess = ctr . createBookingDetail ( guest , currentBooking ) ; if ( addGuestSuccess ) { addedGuestsModel . addElement ( guest ) ; addedGuestsJList . setModel ( addedGuestsModel ) ; jOptionPane . showMessageDialog ( this , guest . getFirstName ( ) + " " + guest . getLastName ( ) + " added to roomNo " + currentBooking . getRoomNo ( ) ) ; } else { jOptionPane . showMessageDialog ( this , "Could not add guest to room.\nGuest might already be booked to a room in that period." , "Error." , jOptionPane . INFORMATION_MESSAGE ) ; } } else { jOptionPane . showMessageDialog ( this , "Cannot add guest because room is full!" , "Room is full." , jOptionPane . INFORMATION_MESSAGE ) ; } } else { jOptionPane . showMessageDialog ( this , "Guest already added!" , "Error." , jOptionPane . INFORMATION_MESSAGE ) ; } } }
tr	2	@ Override public void addStart ( int elem ) { if ( size + 1 >= capacity ) { resize ( ) ; } for ( int i = size - 1 ; i >= 0 ; -- i ) { array [ i + 1 ] = array [ i ] ; } array [ 0 ] = elem ; ++ size ; }
tr	4	@ Override public synchronized boolean add ( Plugin plugin ) { Iterator < Plugin > iter = this . iterator ( ) ; while ( iter . hasNext ( ) ) { if ( iter . next ( ) . getName ( ) . equals ( plugin . getName ( ) ) ) { return false ; } } plugin . addPropertyChangeListener ( new PropertyChangeListener ( ) { public void propertyChange ( PropertyChangeEvent evt ) { if ( evt . getPropertyName ( ) . equals ( "plugin_files_compared" ) ) { int pos = PluginList . this . indexOf ( evt . getNewValue ( ) ) ; propertyChange . firePropertyChange ( "plugin_status_changed" , null , pos ) ; } } } ) ; if ( messageDatabase != null ) { plugin . setMessageDatabase ( messageDatabase ) ; } return super . add ( plugin ) ; }
tr	6	public AudioDevice createAudioDevice ( ) throws JavaLayerException { AudioDevice device = null ; AudioDeviceFactory [ ] factories = getFactoriesPriority ( ) ; if ( factories == null ) throw new JavaLayerException ( this + ": no factories registered" ) ; JavaLayerException lastEx = null ; for ( int i = 0 ; ( device == null ) && ( i < factories . length ) ; i ++ ) { try { device = factories [ i ] . createAudioDevice ( ) ; } catch ( JavaLayerException ex ) { lastEx = ex ; } } if ( device == null && lastEx != null ) { throw new JavaLayerException ( "Cannot create AudioDevice" , lastEx ) ; } return device ; }
tr	6	@ SuppressWarnings ( "static-access" ) public Component getTableCellRendererComponent ( JTable table , Object value , boolean isSelected , boolean hasFocus , int row , int column ) { JLabel label = ( JLabel ) super . getTableCellRendererComponent ( table , value , isSelected , hasFocus , row , column ) ; label . setIcon ( null ) ; if ( table . getColumnName ( column ) . equals ( "Nom" ) || table . getColumnName ( column ) . equals ( "Ville" ) || table . getColumnName ( column ) . equals ( "Province" ) || table . getColumnName ( column ) . equals ( "Proprietaire" ) ) { label . setText ( value . toString ( ) ) ; } else if ( table . getColumnName ( column ) . equals ( "Vente R\u00E9serv\u00E9e" ) ) { label . setText ( "" ) ; if ( value . toString ( ) . equals ( "true" ) ) { label . setIcon ( ConfigIcon . getInstance ( ) . RESERVED ) ; } else { label . setIcon ( ConfigIcon . getInstance ( ) . EMPTY_16 ) ; } } label . setOpaque ( true ) ; label . setHorizontalAlignment ( CENTER ) ; return label ; }
