tr	3	private void clear ( ) { where = new ArrayList < String > ( ) ; comboBoxPanel . removeAll ( ) ; labelPanel . removeAll ( ) ; textFieldPanel . removeAll ( ) ; HashMap < String , ArrayList < String >> query = db . get ( "*" , relation . getSelectedItem ( ) . toString ( ) ) ; columns = query . keySet ( ) . toArray ( new String [ 0 ] ) ; constrains = new JComboBox [ columns . length ] ; JLabel [ ] labels = new JLabel [ columns . length ] ; modifications = new JTextField [ columns . length ] ; comboBoxPanel . setLayout ( new GridLayout ( 1 , columns . length ) ) ; labelPanel . setLayout ( new GridLayout ( 1 , columns . length ) ) ; textFieldPanel . setLayout ( new GridLayout ( 1 , columns . length ) ) ; matchTable = new JTable ( db . convert ( query ) , query . keySet ( ) . toArray ( ) ) { @ Override public boolean isCellEditable ( int row , int column ) { return false ; } } ; JScrollPane scrollPane = new JScrollPane ( matchTable ) ; scrollPane . setPreferredSize ( new Dimension ( 720 , 170 ) ) ; matchTable . setFillsViewportHeight ( true ) ; int i = 0 ; for ( String column : columns ) { ArrayList < String > list = query . get ( column ) ; list . add ( "ALL" ) ; Collections . reverse ( list ) ; constrains [ i ] = new JComboBox ( new LinkedHashSet ( list ) . toArray ( ) ) ; constrains [ i ] . setSelectedItem ( "ALL" ) ; constrains [ i ] . addActionListener ( optionListener ) ; labels [ i ] = new JLabel ( "Set " + columns [ i ] + ":" ) ; modifications [ i ] = new JTextField ( ) ; comboBoxPanel . add ( constrains [ i ] ) ; labelPanel . add ( labels [ i ] ) ; textFieldPanel . add ( modifications [ i ] ) ; i ++ ; } tablePanel . removeAll ( ) ; tablePanel . add ( scrollPane ) ; comboBoxPanel . updateUI ( ) ; labelPanel . updateUI ( ) ; textFieldPanel . updateUI ( ) ; tablePanel . updateUI ( ) ; if ( ! delete . isEnabled ( ) ) delete . setEnabled ( true ) ; if ( ! modify . isEnabled ( ) ) modify . setEnabled ( true ) ; }
tr	9	public boolean connect ( SharingPeer peer ) { boolean retry = false ; boolean sentObfuscatedHandshake = false ; do { Socket socket = new Socket ( ) ; InetSocketAddress address = new InetSocketAddress ( peer . getIp ( ) , peer . getPort ( ) ) ; logger . info ( "Connecting to " + peer + "..." ) ; try { socket . connect ( address , 3 * 1000 ) ; } catch ( IOException ioe ) { logger . warn ( "Could not connect to " + peer + ": " + ioe . getMessage ( ) ) ; return false ; } try { byte [ ] remotePeerId = ( peer . hasPeerId ( ) ? peer . getPeerId ( ) . array ( ) : null ) ; if ( this . forceObfuscation ) sentObfuscatedHandshake = this . sendObfuscatedHandshake ( socket , remotePeerId , this . forceObfuscation ) ; else sentObfuscatedHandshake = this . sendHandshake ( socket , remotePeerId , peer . supportsObfuscation ( ) ) ; Handshake hs = this . validateHandshake ( socket , ( peer . hasPeerId ( ) ? peer . getPeerId ( ) . array ( ) : null ) ) ; this . fireNewPeerConnection ( socket , hs . getPeerId ( ) ) ; return true ; } catch ( ParseException pe ) { logger . info ( "Invalid handshake from " + this . socketRepr ( socket ) + ": " + pe . getMessage ( ) ) ; if ( sentObfuscatedHandshake && peer . supportsObfuscation ( ) ) { peer . supportsObfuscation ( false ) ; retry = true ; } try { socket . close ( ) ; } catch ( IOException e ) { } } catch ( IOException ioe ) { logger . info ( "An error occured while reading an incoming " + "handshake: " + ioe . getMessage ( ) ) ; try { if ( ! socket . isClosed ( ) ) socket . close ( ) ; } catch ( IOException e ) { } } } while ( retry ) ; return false ; }
tr	2	public boolean isCheck ( Player player ) { switch ( player ) { case BLACK : return this . blackCheck ; case WHITE : return this . whiteCheck ; default : throw new IllegalArgumentException ( ) ; } }
tr	9	public String executeRequest ( ) throws IOException { setSigningMethod ( auth ) ; String signingString = getSigningString ( customer_id ) ; String signature ; String url_output = "" ; StringBuffer full_url = new StringBuffer ( base ) . append ( resource ) ; if ( params . size ( ) > 0 ) { full_url . append ( "?" ) ; int i = 0 ; for ( String key : params . keySet ( ) ) { if ( ++ i != 0 ) { full_url . append ( "&" ) ; } full_url . append ( URLEncoder . encode ( key , "UTF-8" ) ) . append ( "=" ) . append ( URLEncoder . encode ( params . get ( key ) , "UTF-8" ) ) ; } } url = new URL ( full_url . toString ( ) ) ; try { signature = encode ( signingString , secret_key ) ; } catch ( SignatureException e ) { System . err . println ( "Error signing request " + e . getMessage ( ) ) ; return null ; } String auth_header = "TSA " + customer_id + ":" + signature ; connection = ( HttpURLConnection ) url . openConnection ( ) ; connection . setConnectTimeout ( connectTimeout ) ; connection . setReadTimeout ( readTimeout ) ; connection . setRequestProperty ( "Authorization" , auth_header ) ; setTLSProtocol ( ) ; if ( post ) { connection . setRequestProperty ( "Content-Length" , Integer . toString ( body . length ( ) ) ) ; } for ( String key : ts_headers . keySet ( ) ) { connection . setRequestProperty ( key , ts_headers . get ( key ) ) ; } for ( String key : headers . keySet ( ) ) { connection . setRequestProperty ( key , headers . get ( key ) ) ; } if ( post ) { connection . setDoOutput ( true ) ; DataOutputStream wr = new DataOutputStream ( connection . getOutputStream ( ) ) ; wr . writeBytes ( body ) ; wr . flush ( ) ; wr . close ( ) ; } int response = connection . getResponseCode ( ) ; BufferedReader in ; try { InputStream isr = ( response == 200 ) ? connection . getInputStream ( ) : connection . getErrorStream ( ) ; in = new BufferedReader ( new InputStreamReader ( isr ) ) ; String urlReturn ; while ( ( urlReturn = in . readLine ( ) ) != null ) { url_output += urlReturn ; } in . close ( ) ; } catch ( IOException e ) { System . err . println ( "IOException while reading from input stream " + e . getMessage ( ) ) ; throw new RuntimeException ( e ) ; } return url_output ; }
tr	4	public WebSocketClient ( URI serverUri , Draft draft , Map < String , String > headers , int connecttimeout ) { if ( serverUri == null ) { throw new IllegalArgumentException ( ) ; } if ( draft == null ) { throw new IllegalArgumentException ( "null as draft is permitted for `WebSocketServer` only!" ) ; } this . uri = serverUri ; this . draft = draft ; this . headers = headers ; this . timeout = connecttimeout ; try { channel = SelectorProvider . provider ( ) . openSocketChannel ( ) ; channel . configureBlocking ( true ) ; } catch ( IOException e ) { channel = null ; onWebsocketError ( null , e ) ; } if ( channel == null ) { conn = ( WebSocketImpl ) wsfactory . createWebSocket ( this , draft , null ) ; conn . close ( CloseFrame . NEVER_CONNECTED , "Failed to create or configure SocketChannel." ) ; } else { conn = ( WebSocketImpl ) wsfactory . createWebSocket ( this , draft , channel . socket ( ) ) ; } }
tr	4	private double [ ] encodeYToDoubleArray ( Object y ) { if ( y instanceof double [ ] ) return ( double [ ] ) y ; if ( y instanceof double ) return new double [ ] { double . valueOf ( y . toString ( ) ) } ; double [ ] retval = new double [ this . classes . length ] ; int i = 0 ; for ( Object o : this . classes ) { if ( o . equals ( y ) ) { retval [ i ] = 1 ; break ; } i ++ ; } return retval ; }
tr	5	public Posicion obtenerPosicionRelativa ( final Posicion posicion , final int offset ) { int indice = - 1 ; for ( int i = 0 ; i < posiciones . size ( ) && indice == - 1 ; i ++ ) { if ( posiciones . get ( i ) == posicion ) { indice = i ; } } int posicionRelativa = indice + offset ; if ( posicionRelativa < 0 || posicionRelativa > posiciones . size ( ) - 1 ) { return new PosicionInexistente ( ) ; } return posiciones . get ( posicionRelativa ) ; }
tr	3	public void setup ( ) { String host = "206.87.3.136" ; int port = 9999 ; try { skt = new Socket ( host , port ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } try { myInput = new BufferedReader ( new InputStreamReader ( skt . getInputStream ( ) ) ) ; } catch ( IOException e1 ) { e1 . printStackTrace ( ) ; } try { myOutput = new PrintStream ( skt . getOutputStream ( ) ) ; } catch ( IOException e1 ) { e1 . printStackTrace ( ) ; } }
tr	8	@ EventHandler ( priority = EventPriority . HIGH ) public void join ( PlayerJoinEvent event ) { if ( ! plugin . toggle ) { try { final Player player = event . getPlayer ( ) ; plugin . Logger ( "Player " + event . getPlayer ( ) . getTotalExperience ( ) + " XP: " + event . getPlayer ( ) . getTotalExperience ( ) + " Level: " + event . getPlayer ( ) . getLevel ( ) , "Debug" ) ; double t = plugin . getLevelXP ( player . getLevel ( ) ) + ( xpShop . nextLevelAt ( player . getLevel ( ) ) * player . getExp ( ) ) ; player . setTotalExperience ( ( int ) t ) ; plugin . getServer ( ) . getScheduler ( ) . runTaskLaterAsynchronously ( plugin , new Runnable ( ) { @ Override public void run ( ) { try { ArrayList < XPSend > xpSends = plugin . getSendDatabase ( ) . getOpenTransactions ( player . getName ( ) ) ; for ( XPSend send : xpSends ) { plugin . PlayerLogger ( player , send . getMessage ( ) , "" ) ; plugin . UpdateXP ( player , send . getSendedXP ( ) , "sendxp" ) ; player . saveData ( ) ; plugin . getSendDatabase ( ) . setStatus ( player . getName ( ) , send . getId ( ) , 1 ) ; } } catch ( SQLException e ) { e . printStackTrace ( ) ; } } } , 20 ) ; plugin . Logger ( "After calculating: Player " + event . getPlayer ( ) . getTotalExperience ( ) + " XP: " + event . getPlayer ( ) . getTotalExperience ( ) + " Level: " + event . getPlayer ( ) . getLevel ( ) , "Debug" ) ; if ( ! plugin . Blacklistcode . startsWith ( "1" ) ) { if ( plugin . PermissionsHandler . checkpermissionssilent ( event . getPlayer ( ) , "xpShop.admin" ) ) { if ( xpShop . updateaviable ) { plugin . PlayerLogger ( event . getPlayer ( ) , "installed xpShop version: " + plugin . Version + "  latest version: " + plugin . newversion , "Warning" ) ; plugin . PlayerLogger ( event . getPlayer ( ) , "New xpShop update aviable: type \"/xpShop update\" to install!" , "Warning" ) ; if ( ! plugin . getConfig ( ) . getBoolean ( "installondownload" ) ) { plugin . PlayerLogger ( event . getPlayer ( ) , "Please edit the config.yml if you wish that the plugin updates itself atomatically!" , "Warning" ) ; } } } } } catch ( Exception e ) { plugin . report . report ( 334 , "join event failed" , e . getMessage ( ) , "xpShopListener" , e ) ; } } }
tr	8	private ChatRemoteManager ( ) { addListener ( new ActionListener ( ) { @ Override protected TaskAction getListenAction ( ) { return TaskAction . QUIT ; } @ Override protected void onAction ( HashMap < String , String > params ) { if ( connection != null ) { connection . close ( ) ; } interrupt ( ) ; } } ) ; addListener ( new ActionListener ( ) { @ Override protected TaskAction getListenAction ( ) { return TaskAction . CONNECT_REQUEST ; } @ Override protected void onAction ( HashMap < String , String > params ) { if ( params != null && params . containsKey ( "host" ) ) { try { connection = new ServerConnection ( params . get ( "host" ) , Main . TCP_SERVERPORT ) ; Manager . getInstance ( ) . publishTask ( new Task ( ) { @ Override public TaskAction getAction ( ) { return TaskAction . CONNECT_SUCCESS ; } @ Override public HashMap < String , String > getParameters ( ) { return null ; } } ) ; } catch ( NetworkException e ) { e . printStackTrace ( ) ; Manager . getInstance ( ) . publishTask ( new Task ( ) { @ Override public TaskAction getAction ( ) { return TaskAction . CONNECT_FAILED ; } @ Override public HashMap < String , String > getParameters ( ) { return null ; } } ) ; } } } } ) ; addListener ( new ActionListener ( ) { @ Override protected TaskAction getListenAction ( ) { return TaskAction . CUSER_REQUESTNAMECHANGE ; } @ Override protected void onAction ( final HashMap < String , String > params ) { if ( params != null && params . containsKey ( "username" ) ) { if ( connection . auth ( params . get ( "username" ) ) ) { Manager . getInstance ( ) . publishTask ( new Task ( ) { @ Override public TaskAction getAction ( ) { return TaskAction . CUSER_NAMECHANGE ; } @ Override public HashMap < String , String > getParameters ( ) { return params ; } } ) ; } else { Manager . getInstance ( ) . publishTask ( new Task ( ) { @ Override public TaskAction getAction ( ) { return TaskAction . CUSER_REQUESTNAMECHANGEFAILED ; } @ Override public HashMap < String , String > getParameters ( ) { return params ; } } ) ; } } } } ) ; addListener ( new ActionListener ( ) { @ Override protected TaskAction getListenAction ( ) { return TaskAction . FETCHUSER_REQUEST ; } @ Override protected void onAction ( HashMap < String , String > params ) { try { String response = connection . requestUserList ( ) ; final HashMap < String , String > userList = InfoParser . parseInfoResponse ( response ) ; Manager . getInstance ( ) . publishTask ( new Task ( ) { @ Override public TaskAction getAction ( ) { return TaskAction . FETCHUSER_PROCESS ; } @ Override public HashMap < String , String > getParameters ( ) { return userList ; } } ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } } ) ; }
tr	1	public void setPanelEnabled ( boolean enabled ) { if ( ! enabled ) { dimensionGroup . clearSelection ( ) ; clearDimensionSelection . setEnabled ( false ) ; } d1 . setEnabled ( enabled ) ; d2 . setEnabled ( enabled ) ; d3 . setEnabled ( enabled ) ; d4 . setEnabled ( enabled ) ; odno . setEnabled ( enabled ) ; mnogo . setEnabled ( enabled ) ; malo . setEnabled ( enabled ) ; indi . setEnabled ( enabled ) ; }
tr	4	public ArrayList < Integer > taydetRivit ( ) { ArrayList < Integer > taydetRivit = new ArrayList < Integer > ( ) ; int k = 0 ; for ( int j = 0 ; j < korkeus ; j ++ ) { boolean taysi = true ; for ( int i = 0 ; i < leveys ; i ++ ) { if ( alueMatriisi [ i ] [ j ] == 0 ) { taysi = false ; break ; } } if ( taysi ) { taydetRivit . add ( k , j ) ; k ++ ; } } return taydetRivit ; }
tr	3	protected Backpropagation calculateErrorAndUpdateHiddenNeurons ( ) { for ( int i = this . network . getLayersNum ( ) - 2 ; i > 0 ; i -- ) for ( INeuron neuron : this . network . getLayerAt ( i ) . getNeurons ( ) ) if ( neuron instanceof ErrorNeuron ) { ErrorNeuron errorNeuron = ( ErrorNeuron ) neuron ; this . updateNeuronWeights ( errorNeuron . setError ( this . calculateHiddenNeuronError ( errorNeuron ) ) ) ; } return this ; }
tr	3	public String [ ] getParametersTypeOf ( String view , String viewMethod ) { for ( int i = 0 ; i < relations . size ( ) ; i ++ ) { if ( relations . get ( i ) . getView ( ) . equals ( view ) && relations . get ( i ) . getViewMethod ( ) . equals ( viewMethod ) ) return relations . get ( i ) . getParametersTypeAsArray ( ) ; } return null ; }
tr	9	public void playRecording ( File file ) { if ( slave != null ) { int amount = 0 ; try { liveData = false ; FileInputStream fis = new FileInputStream ( file ) ; ObjectInputStream inSize = new ObjectInputStream ( fis ) ; while ( true ) { inSize . readObject ( ) ; amount ++ ; } } catch ( Exception e ) { } try { System . out . println ( amount ) ; FileInputStream fis = new FileInputStream ( file ) ; ObjectInputStream in = new ObjectInputStream ( fis ) ; Packet p = null ; int count = 0 ; int start ; int border ; if ( ! ScienceTool . _SPLIT_VALUES ) { if ( ScienceTool . getParameter ( "Slittpart" ) == 1.0 ) { start = 0 ; border = amount / 2 ; } else { start = amount / 2 ; border = amount ; } } else { start = 0 ; border = amount ; } while ( true ) { p = ( Packet ) in . readObject ( ) ; count ++ ; if ( count >= start && count < border ) this . messageReceivedWithTimestamp ( p . adress , new SnoopBCMsg ( p . data , 8 ) , p . time , true ) ; } } catch ( EOFException e ) { } catch ( ClassNotFoundException ex ) { Logger . getLogger ( Datasource . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( IOException e ) { System . out . println ( file . getPath ( ) ) ; e . printStackTrace ( ) ; } liveData = true ; } }
tr	1	public void print ( TreeNode root ) { if ( root == null ) { System . out . print ( " # " ) ; return ; } else { System . out . print ( " " + root . val + " " ) ; } print ( root . left ) ; print ( root . right ) ; }
tr	2	public SchemeObject doWhile ( SchemeObject exp , SchemeObject env ) { SchemeObject predicate = whilePredicate ( exp ) ; SchemeObject body = whileBody ( exp ) ; SchemeObject result = SchemeObject . THE_EMPTY_LIST ; while ( SchemeObject . isTrue ( eval ( predicate , env ) ) ) { SchemeObject exps = body ; while ( ! isLastExp ( exps ) ) { eval ( firstExp ( exps ) , env ) ; exps = exps . getCdr ( ) ; } result = eval ( firstExp ( exps ) , env ) ; } return result ; }
tr	9	@ Override public int moveAlongPath ( Road road ) { this . setCurrentRoad ( road ) ; while ( this . isStopped ( ) == true ) { try { Thread . currentThread ( ) . sleep ( 100 ) ; } catch ( InterruptedException ex ) { Logger . getLogger ( Figure . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } } if ( getWhereOnPath ( ) == road . getLength ( ) ) return 0 ; if ( getWhereOnPath ( ) < road . getLength ( ) - 2 ) { if ( road . changeField ( getWhereOnPath ( ) + 1 ) . getFieldType ( ) == MyField . FieldType . EMPTY ) if ( road . changeField ( getWhereOnPath ( ) + 2 ) . getFieldType ( ) == MyField . FieldType . EMPTY ) { synchronized ( road . getFields ( ) . get ( getWhereOnPath ( ) + 1 ) ) { road . changeField ( getWhereOnPath ( ) + 1 ) . setFieldType ( MyField . FieldType . TROOPERS ) ; setX ( road . changeField ( getWhereOnPath ( ) + 1 ) . getX ( ) ) ; setY ( road . changeField ( getWhereOnPath ( ) + 1 ) . getY ( ) ) ; if ( getWhereOnPath ( ) >= 0 ) road . changeField ( getWhereOnPath ( ) ) . setFieldType ( MyField . FieldType . EMPTY ) ; setWhereOnPath ( getWhereOnPath ( ) + 1 ) ; } } else if ( road . changeField ( getWhereOnPath ( ) + 1 ) . getFieldType ( ) == MyField . FieldType . ALIENS || road . changeField ( getWhereOnPath ( ) + 2 ) . getFieldType ( ) == MyField . FieldType . ALIENS ) { this . setStopped ( true ) ; for ( Aliens a : EmpireGUI . getInstance ( ) . getEmpire ( ) . getAliens ( ) ) { if ( a . getCurrentRoad ( ) == this . getCurrentRoad ( ) ) a . disappear ( ) ; } this . disappear ( ) ; } } else if ( getWhereOnPath ( ) < road . getLength ( ) - 1 ) { synchronized ( road . getFields ( ) . get ( getWhereOnPath ( ) + 1 ) ) { road . changeField ( getWhereOnPath ( ) + 1 ) . setFieldType ( MyField . FieldType . TROOPERS ) ; setX ( road . changeField ( getWhereOnPath ( ) + 1 ) . getX ( ) ) ; setY ( road . changeField ( getWhereOnPath ( ) + 1 ) . getY ( ) ) ; road . changeField ( getWhereOnPath ( ) ) . setFieldType ( MyField . FieldType . EMPTY ) ; setWhereOnPath ( getWhereOnPath ( ) + 1 ) ; } } else { road . changeField ( getWhereOnPath ( ) ) . setFieldType ( FieldType . EMPTY ) ; setWhereOnPath ( getWhereOnPath ( ) + 1 ) ; } return road . getFields ( ) . size ( ) - getWhereOnPath ( ) ; }
tr	3	private void timeButtonMouseClicked ( java . awt . event . MouseEvent evt ) { JOptionPane infoPopup = new JOptionPane ( ) ; int n = JOptionPane . showConfirmDialog ( null , "Are you sure you want to quit?" , "End game" , JOptionPane . YES_NO_OPTION ) ; Result r = new Result ( ) ; ResultContainer cont = new ResultContainer ( ) ; String s = new String ( ) ; if ( n == JOptionPane . YES_OPTION ) { s = JOptionPane . showInputDialog ( null , "Please type your name below: " , "Type your name" , JOptionPane . PLAIN_MESSAGE ) ; System . out . println ( s ) ; if ( s != null ) r . setName ( s ) ; if ( this . empire . getTotalSeconds ( ) > 0 ) r . setSeconds ( this . empire . getTotalSeconds ( ) ) ; infoPopup . setVisible ( false ) ; cont . addAndSerialize ( r ) ; System . exit ( 0 ) ; } }
tr	9	public boolean addDye ( DyeParent dyeParent ) { if ( dyeParent . getClass ( ) . equals ( Lakk . class ) && lakkNum < MAX_NUMBER_OF_LAKKS ) { if ( ! isDyeAlreadyAdded ( dyeParent . getName ( ) ) ) { addedDyes . add ( dyeParent ) ; lakkNum ++ ; return true ; } return false ; } else if ( dyeParent . getClass ( ) . equals ( Metal . class ) && metalNum < MAX_NUMBER_OF_METALS && metalNum + dyeNum < MAX_NUMBER_OF_DYES ) { if ( ! isDyeAlreadyAdded ( dyeParent . getName ( ) ) ) { addedDyes . add ( dyeParent ) ; metalNum ++ ; return true ; } return false ; } else if ( dyeParent . getClass ( ) . equals ( Dye . class ) && metalNum + dyeNum < MAX_NUMBER_OF_DYES ) { if ( ! isDyeAlreadyAdded ( dyeParent . getName ( ) ) ) { addedDyes . add ( dyeParent ) ; dyeNum ++ ; return true ; } return false ; } else if ( dyeParent . getClass ( ) . equals ( Fluo . class ) ) { if ( ! isDyeAlreadyAdded ( dyeParent . getName ( ) ) ) { addedDyes . add ( dyeParent ) ; fluoNum ++ ; return true ; } return false ; } return false ; }
tr	4	public KeySettingsDialog ( KeySettings oldSettings , EventBusService eventBusService ) { eventBusService . register ( this ) ; KeySettingsController controller = new KeySettingsController ( this , oldSettings , eventBusService ) ; textFieldMapping = new HashMap < ColourType , JTextField > ( ) ; changeButtonMapping = new HashMap < ColourType , JButton > ( ) ; colourBoxMapping = new HashMap < ColourType , JPanel > ( ) ; for ( ColourType colour : ColourType . values ( ) ) { JPanel boxPanel = new JPanel ( ) ; boxPanel . setBackground ( SystemProperties . COLOUR_MAP . get ( colour ) ) ; boxPanel . setBorder ( BorderFactory . createLineBorder ( new java . awt . Color ( 0 , 0 , 0 ) ) ) ; boxPanel . setPreferredSize ( new Dimension ( 30 , 30 ) ) ; colourBoxMapping . put ( colour , boxPanel ) ; JTextField field = new JTextField ( String . valueOf ( oldSettings . getColorKey ( colour ) . getKeyCharacter ( ) ) ) ; field . setEditable ( false ) ; field . setPreferredSize ( new Dimension ( 70 , 30 ) ) ; field . setHorizontalAlignment ( SwingConstants . CENTER ) ; field . setBorder ( BorderFactory . createLineBorder ( Color . BLACK ) ) ; textFieldMapping . put ( colour , field ) ; JButton changeButton = new JButton ( ae + "ndern" ) ; changeButton . setActionCommand ( colour . getColourTypeName ( ) ) ; changeButton . addActionListener ( controller ) ; changeButtonMapping . put ( colour , changeButton ) ; } this . colourPanel = new JPanel ( ) ; this . keyFieldPanel = new JPanel ( ) ; this . changeKeyPanel = new JPanel ( ) ; this . cancelButton = new JButton ( "Abbrechen" ) ; this . cancelButton . setActionCommand ( "CANCEL" ) ; this . cancelButton . addActionListener ( controller ) ; this . acceptButton = new JButton ( Ue + "bernehmen" ) ; this . acceptButton . setActionCommand ( "ACCEPT" ) ; this . acceptButton . addActionListener ( controller ) ; this . defaultButton = new JButton ( "Zur" + ue + "cksetzen" ) ; this . defaultButton . setActionCommand ( "DEFAULT" ) ; this . defaultButton . addActionListener ( controller ) ; this . colourPanel . setLayout ( new GridLayout ( 6 , 1 , 5 , 10 ) ) ; for ( ColourType colour : ColourType . values ( ) ) { this . colourPanel . add ( colourBoxMapping . get ( colour ) ) ; } this . keyFieldPanel . setLayout ( new GridLayout ( 6 , 1 , 5 , 10 ) ) ; for ( ColourType colour : ColourType . values ( ) ) { this . keyFieldPanel . add ( textFieldMapping . get ( colour ) ) ; } this . changeKeyPanel . setLayout ( new GridLayout ( 6 , 1 , 0 , 17 ) ) ; for ( ColourType colour : ColourType . values ( ) ) { this . changeKeyPanel . add ( changeButtonMapping . get ( colour ) ) ; } this . setLayout ( new GridBagLayout ( ) ) ; GridBagConstraints c = new GridBagConstraints ( ) ; c . gridx = 0 ; c . gridy = 0 ; c . insets = new Insets ( 0 , 5 , 0 , 5 ) ; this . add ( this . colourPanel , c ) ; c . gridx = 1 ; c . gridy = 0 ; this . add ( this . keyFieldPanel , c ) ; c . gridx = 2 ; c . gridy = 0 ; c . insets = new Insets ( 15 , 15 , 15 , 15 ) ; c . fill = GridBagConstraints . HORIZONTAL ; this . add ( this . changeKeyPanel , c ) ; c . gridx = 0 ; c . gridy = 1 ; c . insets = new Insets ( 30 , 5 , 0 , 5 ) ; this . add ( this . acceptButton , c ) ; c . gridx = 1 ; c . gridy = 1 ; c . insets = new Insets ( 30 , 5 , 0 , 5 ) ; this . add ( this . defaultButton , c ) ; c . gridx = 2 ; c . gridy = 1 ; this . add ( this . cancelButton , c ) ; this . setDefaultCloseOperation ( JDialog . DO_NOTHING_ON_CLOSE ) ; this . setResizable ( false ) ; this . setTitle ( "Tastatureinstellungen" ) ; this . setModal ( true ) ; this . setSize ( 370 , 370 ) ; this . setLocation ( ( SystemProperties . SCREEN_WIDTH / 2 ) - 185 , ( SystemProperties . SCREEN_HEIGHT / 2 ) - 185 ) ; }
tr	3	public void backPropagate ( double [ ] target , double learningSpeed ) { double [ ] oError = calculateError ( getOutput ( ) , target , learningSpeed ) ; for ( double n : oError ) if ( double . isNaN ( n ) ) throw new RuntimeException ( "calculateError resulted in NaN" ) ; for ( int l = layers . size ( ) - 2 ; l >= 0 ; -- l ) { double [ ] iError = backPropagateLayer ( layers . get ( l ) , layers . get ( l + 1 ) , weights . get ( l ) , oError , learningSpeed ) ; updateBias ( weights . get ( l ) , oError ) ; oError = iError ; } }
tr	7	public static void shutDown ( ) { Block superBlock = null ; try { superBlock = new Block ( Disk . homeDir . toString ( ) + "/TransDisk/" + String . format ( "%05d" , Disk . superBlockAddress ) + ".txt" , "r" ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } if ( dirtyBuffer [ 1 ] == 1 ) { int noOfBlocksBitmap = 4 ; try { superBlock . readLine ( ) ; int [ ] freeBlockBitmapNo = new int [ noOfBlocksBitmap ] ; String tempStr = superBlock . readLine ( ) ; for ( int i = 0 ; i < noOfBlocksBitmap ; i ++ ) freeBlockBitmapNo [ i ] = Integer . parseInt ( tempStr . substring ( i , i + 1 ) ) ; byte [ ] bitmapPieces ; for ( int i = 0 , off = 0 ; i < 4 ; i ++ , off += 500 ) { Block bitmapBlock = new Block ( Disk . homeDir . toString ( ) + "/TransDisk/" + String . format ( "%05d" , freeBlockBitmapNo [ i ] ) + ".txt" , "rw" ) ; bitmapPieces = FreeSpaceMgnt . prepBuffer ( Arrays . copyOfRange ( freeBlockBitmap , off , off + 500 ) ) ; bitmapBlock . write ( bitmapPieces ) ; bitmapBlock . close ( ) ; } } catch ( IOException e ) { e . printStackTrace ( ) ; } } if ( dirtyBuffer [ 0 ] == 1 ) { try { superBlock . seek ( 0 ) ; superBlock . readLine ( ) ; superBlock . readLine ( ) ; int freeInodeBitmapNo = Integer . parseInt ( superBlock . readLine ( ) ) ; Block freeInodeBitmapBlk = new Block ( Disk . homeDir . toString ( ) + "/TransDisk/" + String . format ( "%05d" , freeInodeBitmapNo ) + ".txt" , "rw" ) ; freeInodeBitmapBlk . write ( prepBuffer ( freeInodeBitmap ) ) ; freeInodeBitmapBlk . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } }
tr	2	private static byte [ ] constructorValueHelper ( byte [ ] left , byte [ ] right ) { byte [ ] value = new byte [ left . length + right . length ] ; for ( int i = 0 ; i < left . length ; i ++ ) { value [ i ] = left [ i ] ; } for ( int j = left . length ; j < value . length ; j ++ ) { value [ j ] = right [ j - left . length ] ; } return value ; }
tr	8	@ Override public void actionPerformed ( ActionEvent e ) { final JToggleButton sourceBtn = ( JToggleButton ) e . getSource ( ) ; if ( sourceBtn . isSelected ( ) ) { final String host = cbxCfgAddress . getEditor ( ) . getItem ( ) . toString ( ) . trim ( ) ; final String port = cbxCfgPort . getEditor ( ) . getItem ( ) . toString ( ) . trim ( ) ; final String name = cbxCfgName . getEditor ( ) . getItem ( ) . toString ( ) . trim ( ) ; ConfigHistory . addEntry ( host , port , name ) ; cbxCfgAddress . addItem ( host ) ; cbxCfgPort . addItem ( port ) ; cbxCfgName . addItem ( name ) ; try { final Registry reg = LocateRegistry . getRegistry ( host , Integer . parseInt ( port ) ) ; final ServerControl remoteControl = ( ServerControl ) reg . lookup ( BINDING_ID ) ; if ( name . equals ( "" ) ) { JOptionPane . showMessageDialog ( ConnectionDialog . this , "Please enter your name!" , "Naming error" , JOptionPane . ERROR_MESSAGE ) ; sourceBtn . setSelected ( false ) ; } else if ( ! remoteControl . isJoinable ( ) ) { JOptionPane . showMessageDialog ( ConnectionDialog . this , "The selected server is busy!" , "Network error" , JOptionPane . ERROR_MESSAGE ) ; sourceBtn . setSelected ( false ) ; } else if ( ! remoteControl . register ( name ) ) { JOptionPane . showMessageDialog ( ConnectionDialog . this , "Please choose another name!" , "Naming error" , JOptionPane . ERROR_MESSAGE ) ; sourceBtn . setSelected ( false ) ; } else { cbxCfgAddress . setEnabled ( false ) ; cbxCfgName . setEnabled ( false ) ; cbxCfgPort . setEnabled ( false ) ; lblTitle . setText ( "Waiting for host..." ) ; target . setName ( name ) ; target . setController ( remoteControl ) ; registerThread = new Thread ( new Runnable ( ) { @ Override public void run ( ) { try { while ( ! remoteControl . isRunning ( ) ) { Thread . sleep ( 500 ) ; } ConnectionDialog . this . dispose ( ) ; } catch ( InterruptedException | RemoteException e ) { try { remoteControl . unregister ( name ) ; } catch ( Exception e1 ) { } } } } ) ; registerThread . start ( ) ; } } catch ( RemoteException | NotBoundException ex ) { JOptionPane . showMessageDialog ( ConnectionDialog . this , "Host cannot be found!" , "Network error" , JOptionPane . ERROR_MESSAGE ) ; sourceBtn . setSelected ( false ) ; } } else { registerThread . interrupt ( ) ; cbxCfgAddress . setEnabled ( true ) ; cbxCfgName . setEnabled ( true ) ; cbxCfgPort . setEnabled ( true ) ; lblTitle . setText ( "Connect to host..." ) ; } }
tr	1	public void start ( ) { if ( isRunning ) return ; run ( ) ; }
tr	5	void expand ( ) throws IOException { try ( ZipInputStream zis = FileUtil . getZipInputStream ( inputStream ) ) { for ( ZipEntry entry = zis . getNextEntry ( ) ; entry != null ; entry = zis . getNextEntry ( ) ) { if ( entry . isDirectory ( ) ) { continue ; } String name = entry . getName ( ) ; if ( name . equals ( PackageBase . MANIFEST ) ) { manifest = FileUtil . copyToTemp ( zis , "manifest" , ".xml" ) ; } else if ( name . equals ( PackageBase . PAYLOAD_FILE ) ) { expandPayload ( zis ) ; } else { errorHandler . reportError ( TIPPErrorType . UNEXPECTED_PACKAGE_CONTENTS , "Unexpected package contents: " + name , null ) ; } } } catch ( IOException e ) { errorHandler . reportError ( TIPPErrorType . INVALID_PACKAGE_ZIP , "Could not read package zip" , e ) ; throw new ReportedException ( e ) ; } }
tr	0	public Henkilo valitaHenkiloOlio ( String nimi ) { return henkilo = henkilot . get ( nimi ) ; }
tr	5	private static void parseAuthority ( URL parsed ) { if ( parsed . href . indexOf ( ":" ) == - 1 && parsed . href . indexOf ( "//" ) == 0 && "" . equals ( parsed . host ) ) { parsed . pathname = parsed . pathname . substring ( 2 ) ; final int idx = parsed . pathname . indexOf ( "/" ) ; if ( idx == - 1 ) { parsed . authority = parsed . pathname ; parsed . pathname = "" ; } else { parsed . authority = parsed . pathname . substring ( 0 , idx ) ; parsed . pathname = parsed . pathname . substring ( idx ) ; } } else { parsed . authority = parsed . host ; if ( ! "" . equals ( parsed . auth ) ) { parsed . authority = parsed . auth + "@" + parsed . authority ; } } }
tr	0	public String getDescription ( ) { return description ; }
tr	0	protected FalloverTargetingStrategy ( TargetingStrategy ... strategies ) { this . strategies = strategies ; }
tr	1	public CashOffice registerCashOffice ( CashOffice cashOffice ) { int index = cashOffices . indexOf ( cashOffice ) ; if ( index == - 1 ) { addCashOffice ( cashOffice ) ; return cashOffice ; } else { CashOffice foundedCashOffice = cashOffices . get ( index ) ; return foundedCashOffice ; } }
tr	2	public void aiUp ( ) { if ( Realm . player . x == x && Realm . player . y == ( y - 1 ) ) { attack ( ) ; } else { walkUp ( ) ; } }
tr	6	@ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; Triplet triplet = ( Triplet ) o ; if ( i != triplet . i ) return false ; if ( j != triplet . j ) return false ; if ( k != triplet . k ) return false ; return true ; }
tr	2	public boolean removePrefFile ( CommonPrefEPFResource pfRem ) { if ( pfRem == null || pfRem . isConfig ( ) ) return false ; return prefFiles . remove ( pfRem ) ; }
tr	1	public boolean execute ( CommandSender sender , String [ ] args ) { String status = PlayerState . get ( ( Player ) sender ) . toggleBypassMode ( ) ? "enabled" : "disabled" ; sendMessage ( sender , ChatColor . GREEN , "Bypass mode %s" , status ) ; return true ; }
tr	2	private boolean isMatchingRightChild ( ASTNode rightChild ) { if ( rightChildMatcher == null ) { return true ; } if ( rightChild == null ) { return false ; } return rightChildMatcher . matches ( this , rightChild ) ; }
tr	3	@ Override public < T > T accept ( ParseTreeVisitor < ? extends T > visitor ) { if ( visitor instanceof SSTVisitor ) return ( ( SSTVisitor < ? extends T > ) visitor ) . visitComparesignals ( this ) ; else return visitor . visitChildren ( this ) ; }
tr	2	public static String getFile ( String FileName ) { StringBuffer buffer = new StringBuffer ( ) ; try { BufferedReader dataInput = new BufferedReader ( new FileReader ( new File ( FileName ) ) ) ; String line ; while ( ( line = dataInput . readLine ( ) ) != null ) { buffer . append ( line ) ; buffer . append ( '' ) ; } dataInput . close ( ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; } return buffer . toString ( ) ; }
tr	7	@ Override public void onNIOEvent ( SelectionKey key ) { if ( key . isWritable ( ) ) { boolean removeEvent = false ; ChannelEvent event = writeQueue . peek ( ) ; try { if ( removeEvent = ( event != null && handleOutgoingEvent ( event ) ) ) event . getFuture ( ) . onSuccess ( ) ; } catch ( Exception e ) { removeEvent = true ; if ( event != null ) event . getFuture ( ) . onException ( e ) ; } if ( removeEvent ) { writeQueue . remove ( ) ; if ( writeQueue . isEmpty ( ) ) dispatcher . setInterestOps ( this , dispatcher . getInterestOps ( this ) ^ SelectionKey . OP_WRITE ) ; } } }
tr	1	public static SimpleObject getInstance ( ) { if ( simpleObject == null ) simpleObject = new SimpleObject ( ) ; return simpleObject ; }
tr	8	public static Matrix read ( BufferedReader input ) throws java . io . IOException { StreamTokenizer tokenizer = new StreamTokenizer ( input ) ; tokenizer . resetSyntax ( ) ; tokenizer . wordChars ( 0 , 255 ) ; tokenizer . whitespaceChars ( 0 ,   ) ; tokenizer . eolIsSignificant ( true ) ; java . util . Vector v = new java . util . Vector ( ) ; while ( tokenizer . nextToken ( ) == StreamTokenizer . TT_EOL ) ; if ( tokenizer . ttype == StreamTokenizer . TT_EOF ) throw new java . io . IOException ( "Unexpected EOF on matrix read." ) ; do { v . addElement ( double . valueOf ( tokenizer . sval ) ) ; } while ( tokenizer . nextToken ( ) == StreamTokenizer . TT_WORD ) ; int n = v . size ( ) ; double row [ ] = new double [ n ] ; for ( int j = 0 ; j < n ; j ++ ) row [ j ] = ( ( double ) v . elementAt ( j ) ) . doubleValue ( ) ; v . removeAllElements ( ) ; v . addElement ( row ) ; while ( tokenizer . nextToken ( ) == StreamTokenizer . TT_WORD ) { v . addElement ( row = new double [ n ] ) ; int j = 0 ; do { if ( j >= n ) throw new java . io . IOException ( "Row " + v . size ( ) + " is too long." ) ; row [ j ++ ] = double . valueOf ( tokenizer . sval ) . doubleValue ( ) ; } while ( tokenizer . nextToken ( ) == StreamTokenizer . TT_WORD ) ; if ( j < n ) throw new java . io . IOException ( "Row " + v . size ( ) + " is too short." ) ; } int m = v . size ( ) ; double [ ] [ ] A = new double [ m ] [ ] ; v . copyInto ( A ) ; return new Matrix ( A ) ; }
tr	7	public void delete ( K key ) { BinaryTreeNode < K , V > node = search ( key ) ; BinaryTreeNode < K , V > parent = node . getParent ( ) ; if ( node == null ) return ; if ( node . hasLeft ( ) && node . hasRight ( ) ) { BinaryTreeNode < K , V > successor = node . getNext ( ) ; if ( node . getRight ( ) . equals ( successor ) ) { successor . moveTo ( node ) ; } else { successor . getParent ( ) . setLeft ( successor . getRight ( ) ) ; successor . setRight ( null ) ; successor . transplant ( node ) ; } } else if ( node . hasLeft ( ) ) { node . getLeft ( ) . moveTo ( node ) ; } else if ( node . hasRight ( ) ) { node . getRight ( ) . moveTo ( node ) ; } else { if ( parent . isLeftChild ( this ) ) { parent . setLeft ( null ) ; } else { parent . setRight ( null ) ; } } }
tr	7	public synchronized boolean reAuthenticateSession ( ) throws SaploClientException { lock . lock ( ) ; try { long now = System . currentTimeMillis ( ) ; if ( ( now - lastReconnectAttempt ) < reconnectTimeout * maxReconnectCount || reconnectCount > maxReconnectCount ) return false ; if ( ( now - lastSuccessfulReconnect ) < 10000 && reconnectCount == 0 ) return true ; logger . info ( "Trying to reconnect to the API.." ) ; while ( reconnectCount <= maxReconnectCount ) { try { logger . info ( "attempt #" + reconnectCount ) ; long toSleep = ( reconnectCount + 1 ) * reconnectTimeout ; sleeping . await ( toSleep , TimeUnit . MILLISECONDS ) ; authenticateSession ( ) ; reconnectCount = 0 ; lastReconnectAttempt = 0 ; lastSuccessfulReconnect = System . currentTimeMillis ( ) ; logger . info ( "Successfully reconnected to the API.." ) ; return true ; } catch ( SaploClientException e ) { reconnectCount ++ ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; return false ; } } lastReconnectAttempt = System . currentTimeMillis ( ) ; logger . warn ( "Could not reconnect to the API after {} attempts." , reconnectCount ) ; throw new SaploClientException ( ResponseCodes . MSG_ERR_NOSESSION , ResponseCodes . CODE_ERR_NOSESSION ) ; } finally { lock . unlock ( ) ; } }
tr	7	void prune ( File [ ] files ) { int size = 0 ; for ( File file : files ) { if ( file . isFile ( ) && ! file . getName ( ) . equals ( "FAT" ) ) { size += file . length ( ) ; } } int cnt = 0 ; int limit = Globals . getCacheLimit ( ) ; while ( size > limit && cnt < files . length ) { File current = files [ cnt ++ ] ; if ( current . isFile ( ) && ! current . getName ( ) . equals ( "FAT" ) ) { size -= current . length ( ) ; current . delete ( ) ; } } fileUse . set ( size ) ; updateGUIDisk ( ) ; }
tr	2	public void closeUpvalues ( int index ) { int loopIndex = upvalues . size ( ) ; while ( -- loopIndex >= 0 ) { UpValue upvalue = upvalues . elementAt ( loopIndex ) ; if ( upvalue . getIndex ( ) < index ) return ; upvalue . close ( ) ; upvalues . removeElementAt ( loopIndex ) ; } }
tr	8	public String request ( String method , String resource , LinkedHashMap < String , String > parameters ) throws PlivoException { HttpResponse response = new BasicHttpResponse ( new ProtocolVersion ( "HTTP" , 1 , 1 ) , HttpStatus . SC_OK , "OK" ) ; String json = "" ; try { if ( method == "GET" ) { String getparams = "?" ; for ( Entry < String , String > pair : parameters . entrySet ( ) ) getparams += pair . getKey ( ) + "=" + URLEncoder . encode ( pair . getValue ( ) , "UTF-8" ) + "&" ; getparams = getparams . substring ( 0 , getparams . length ( ) - 1 ) ; HttpGet httpget = new HttpGet ( this . BaseURI + resource + getparams ) ; response = this . Client . execute ( httpget ) ; } else if ( method == "POST" ) { HttpPost httpost = new HttpPost ( this . BaseURI + resource ) ; Gson gson = new GsonBuilder ( ) . serializeNulls ( ) . create ( ) ; StringEntity se = new StringEntity ( gson . toJson ( parameters ) , "utf-8" ) ; se . setContentType ( new BasicHeader ( HTTP . CONTENT_TYPE , "application/json" ) ) ; httpost . setEntity ( se ) ; response = this . Client . execute ( httpost ) ; } else if ( method == "DELETE" ) { HttpDelete httpdelete = new HttpDelete ( this . BaseURI + resource ) ; response = this . Client . execute ( httpdelete ) ; } Integer serverCode = response . getStatusLine ( ) . getStatusCode ( ) ; if ( response . getEntity ( ) != null ) { json = this . convertStreamToString ( response . getEntity ( ) . getContent ( ) ) . replaceFirst ( "\\{" , String . format ( "{ \"server_code\": %s  " , serverCode . toString ( ) ) ) ; } else { json = String . format ( "{\"message\":\"no response\" \"api_id\":\"unknown\"  \"server_code\":%s}" , serverCode . toString ( ) ) ; } } catch ( ClientProtocolException e ) { throw new PlivoException ( e . getLocalizedMessage ( ) ) ; } catch ( IOException e ) { throw new PlivoException ( e . getLocalizedMessage ( ) ) ; } catch ( IllegalStateException e ) { throw new PlivoException ( e . getLocalizedMessage ( ) ) ; } finally { this . Client . getConnectionManager ( ) . shutdown ( ) ; } return json ; }
tr	2	public static ProcessorLayer createProcessorLayerWithProcessorNeuron ( int neuronsNum , boolean bias ) { ProcessorLayer layer = new ProcessorLayer ( ) ; if ( bias ) { layer . addNeuron ( new BiasNeuron ( ) ) ; } for ( int i = 0 ; i < neuronsNum ; i ++ ) layer . addNeuron ( new ProcessorNeuron ( ) ) ; return layer ; }
tr	8	private void getConnection ( Element connectElement ) { String room1Name = "" ; String room2Name = "" ; String exit1 = "" ; String exit2 = "" ; Element el ; NodeList nl = connectElement . getElementsByTagName ( "room1" ) ; if ( nl != null && nl . getLength ( ) > 0 ) { el = ( Element ) nl . item ( 0 ) ; room1Name = el . getAttribute ( "name" ) ; nl = el . getElementsByTagName ( "exit" ) ; if ( nl != null && nl . getLength ( ) > 0 ) { el = ( Element ) nl . item ( 0 ) ; exit1 = el . getAttribute ( "type" ) ; } } nl = connectElement . getElementsByTagName ( "room2" ) ; if ( nl != null && nl . getLength ( ) > 0 ) { el = ( Element ) nl . item ( 0 ) ; room2Name = el . getAttribute ( "name" ) ; nl = el . getElementsByTagName ( "exit" ) ; if ( nl != null && nl . getLength ( ) > 0 ) { el = ( Element ) nl . item ( 0 ) ; exit2 = el . getAttribute ( "type" ) ; } } Room room1 = rooms . get ( room1Name ) ; Room room2 = rooms . get ( room2Name ) ; room1 . addExit ( ExitDirection . parse ( exit1 ) , room2 ) ; room2 . addExit ( ExitDirection . parse ( exit2 ) , room1 ) ; }
tr	6	public < T extends DBObject > T createObject ( class < ? extends DBObject > c , String identifier ) throws RemoteException { checkStarted ( ) ; try { Logger . debug ( "try to create new DBObject. request from host: " + getClientHost ( ) ) ; } catch ( ServerNotActiveException soe ) { } try { T o = create ( c ) ; o . load ( identifier ) ; return o ; } catch ( RemoteException re ) { throw re ; } catch ( Exception e ) { Logger . error ( "unable to create object " + ( c == null ? "unknown" : c . getName ( ) ) , e ) ; throw new RemoteException ( "unable to create object " + ( c == null ? "unknown" : c . getName ( ) ) , e ) ; } }
tr	9	@ Override public int hashCode ( ) { Method [ ] methods = ( Method [ ] ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { return annotationType . getDeclaredMethods ( ) ; } } ) ; int hashCode = 0 ; for ( Method method : methods ) { int name = 127 * method . getName ( ) . hashCode ( ) ; Object object = callMethod ( this , method ) ; int value = 0 ; if ( object . getClass ( ) . isArray ( ) ) { class < ? > type = object . getClass ( ) . getComponentType ( ) ; if ( type . isPrimitive ( ) ) { if ( long . TYPE == type ) { value = Arrays . hashCode ( ( long [ ] ) object ) ; } else if ( Integer . TYPE == type ) { value = Arrays . hashCode ( ( Integer [ ] ) object ) ; } else if ( short . TYPE == type ) { value = Arrays . hashCode ( ( short [ ] ) object ) ; } else if ( double . TYPE == type ) { value = Arrays . hashCode ( ( double [ ] ) object ) ; } else if ( float . TYPE == type ) { value = Arrays . hashCode ( ( float [ ] ) object ) ; } else if ( boolean . TYPE == type ) { value = Arrays . hashCode ( ( long [ ] ) object ) ; } else if ( byte . TYPE == type ) { value = Arrays . hashCode ( ( byte [ ] ) object ) ; } else if ( Character . TYPE == type ) { value = Arrays . hashCode ( ( Character [ ] ) object ) ; } } else { value = Arrays . hashCode ( ( Object [ ] ) object ) ; } } else { value = object . hashCode ( ) ; } hashCode += name ^ value ; } return hashCode ; }
tr	2	void updateStep2 ( ) { panel2 . remove ( scrollPane2 ) ; createTable2 ( lg . getGuestNameList ( ) , guestCols ) ; if ( lg . completedGuestFields ( ) ) chckbx2_GuestListFinalised . setEnabled ( true ) ; if ( lg . getGuestListFinalised ( ) == true ) chckbx2_GuestListFinalised . setSelected ( true ) ; }
tr	1	@ Override public void act1 ( ) { Object obj = capabilities . get ( Cap1 . class ) ; if ( obj != null ) { ( ( Cap1 ) obj ) . act1 ( ) ; } else { throw new UnsupportedOperationException ( "We do not have Cap1 capability yet" ) ; } }
tr	0	public String getTopDownCenterIntersection ( ) { return topDownCenterIntersection ; }
tr	0	public char nextChar ( ) { return ( char ) ( next ( 16 ) ) ; }
tr	0	public Builder buying ( double price ) { this . price = price ; return this ; }
tr	4	private void initializeTokens ( ) { tokens = new Token [ 21 ] [ 10 ] ; for ( int i = 0 ; i < tokens . length ; i ++ ) { for ( int j = 0 ; j < tokens [ i ] . length ; j ++ ) { tokens [ i ] [ j ] = new Token ( ) ; } } nextTokens1 = new TokenNext [ 2 ] [ 4 ] ; nextTokens2 = new TokenNext [ 2 ] [ 4 ] ; nextTokens3 = new TokenNext [ 2 ] [ 4 ] ; holdTokens = new TokenNext [ 2 ] [ 4 ] ; for ( int i = 0 ; i < nextTokens1 . length ; i ++ ) { for ( int j = 0 ; j < nextTokens1 [ i ] . length ; j ++ ) { nextTokens1 [ i ] [ j ] = new TokenNext ( ) ; nextTokens2 [ i ] [ j ] = new TokenNext ( ) ; nextTokens3 [ i ] [ j ] = new TokenNext ( ) ; holdTokens [ i ] [ j ] = new TokenNext ( ) ; } } currentTokens = new int [ 4 ] [ 2 ] ; directingTokens = new int [ 4 ] [ 2 ] ; nextTokens3Position = new int [ 4 ] [ 2 ] ; nextTokens2Position = new int [ 4 ] [ 2 ] ; nextTokens1Position = new int [ 4 ] [ 2 ] ; holdTokensPosition = new int [ 4 ] [ 2 ] ; }
tr	2	public boolean verifyStudentFields ( ) { if ( studentNameField . getText ( ) . length ( ) == 0 || ! Util . isNumeric ( studentGroupField . getText ( ) ) ) { JOptionPane . showMessageDialog ( null , Window . geti18nString ( ADialog . STUDENT_NAME_OR_GROUP_ISN_T_CORRECT ) ) ; return false ; } return true ; }
tr	2	@ Override public GameState clone ( ) { try { GameState state = ( GameState ) super . clone ( ) ; state . bonusMap = new HashMap < MappingField , BonusType > ( bonusMap ) ; state . playableMap = new HashMap < Playable , PlayableState > ( playableMap . size ( ) ) ; for ( Map . Entry < Playable , PlayableState > e : playableMap . entrySet ( ) ) { state . playableMap . put ( e . getKey ( ) , e . getValue ( ) . clone ( ) ) ; } return state ; } catch ( CloneNotSupportedException e ) { throw new InternalError ( e . toString ( ) ) ; } }
tr	1	protected Icon getHeaderRendererIcon ( int column , int size ) { Directive directive = getDirective ( column ) ; if ( directive == EMPTY_DIRECTIVE ) { return null ; } return new -> ( directive . direction == DESCENDING , size , sortingColumns . indexOf ( directive ) ) ; }
tr	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( Principal . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( Principal . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( Principal . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( Principal . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { getInstace ( null ) . setVisible ( true ) ; } } ) ; }
tr	9	@ Override public int hashCode ( ) { int result ; long temp ; result = ( int ) ( id ^ ( id >>> 32 ) ) ; result = 31 * result + ( int ) ( version ^ ( version >>> 32 ) ) ; result = 31 * result + ( int ) ( problemId ^ ( problemId >>> 32 ) ) ; result = 31 * result + ( submission != null ? submission . hashCode ( ) : 0 ) ; result = 31 * result + ( int ) evaluation ; result = 31 * result + ( submissionDate != null ? submissionDate . hashCode ( ) : 0 ) ; result = 31 * result + ( detailedLog ? 1 : 0 ) ; result = 31 * result + ( diffFile != null ? diffFile . hashCode ( ) : 0 ) ; result = 31 * result + ( int ) ( languageId ^ ( languageId >>> 32 ) ) ; result = 31 * result + tries ; result = 31 * result + ( output != null ? output . hashCode ( ) : 0 ) ; result = 31 * result + ( int ) ( userId ^ ( userId >>> 32 ) ) ; temp = double . doubleToLongBits ( time ) ; result = 31 * result + ( int ) ( temp ^ ( temp >>> 32 ) ) ; result = 31 * result + ( problem != null ? problem . hashCode ( ) : 0 ) ; result = 31 * result + ( language != null ? language . hashCode ( ) : 0 ) ; result = 31 * result + ( inputTestCase != null ? inputTestCase . hashCode ( ) : 0 ) ; result = 31 * result + ( errorMsg != null ? errorMsg . hashCode ( ) : 0 ) ; result = 31 * result + ( int ) ( idTestCase ^ ( idTestCase >>> 32 ) ) ; return result ; }
tr	0	public FenetreSupprimer ( ListeObjet listeObjets ) { this . setTitle ( Langue . getTraduction ( "delete_confirmation" ) ) ; JPanel fenetre = new JPanel ( new BorderLayout ( ) ) ; fenetre . setBorder ( BorderFactory . createEmptyBorder ( 10 , 10 , 5 , 10 ) ) ; this . add ( fenetre ) ; JButton buttonAnnuler = new JButton ( new AnnulerAction ( this , Langue . getTraduction ( "cancel" ) ) ) ; JButton buttonSupprimer = new JButton ( new ValiderSupprimerAction ( listeObjets , this ) ) ; JPanel panelSouth = new JPanel ( ) ; panelSouth . add ( buttonSupprimer ) ; panelSouth . add ( buttonAnnuler ) ; fenetre . add ( panelSouth , "South" ) ; JLabel label = new JLabel ( Langue . getTraduction ( "delete_query" ) ) ; fenetre . add ( label , "Center" ) ; this . afficherDialog ( ) ; }
tr	8	@ Override public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( ! super . equals ( obj ) ) { return false ; } if ( getClass ( ) != obj . getClass ( ) ) { return false ; } ReferenceProperty < ? > other = ( ReferenceProperty < ? > ) obj ; if ( reference == null ) { if ( other . reference != null ) { return false ; } } else if ( ! reference . equals ( other . reference ) ) { return false ; } return true ; }
tr	2	private Expression expression0 ( ) throws RequiredTokenException { enterRule ( NonTerminal . EXPRESSION0 ) ; Expression lhs = expression1 ( ) ; if ( firstSetSatisfied ( NonTerminal . OP0 ) ) { Token op = null ; try { op = op0 ( ) ; lhs = Command . newExpression ( lhs , op , expression1 ( ) ) ; } catch ( FirstSetUnsatisfiedException e ) { lhs = new Error ( ( ( Command ) lhs ) . lineNumber ( ) , ( ( Command ) lhs ) . charPosition ( ) , String . format ( "First set unsatisfied for nonterminal of type \"%s\"." , e . Unsatisfied ) ) ; } } exitRule ( ) ; return lhs ; }
tr	4	private void populateDto ( Msg dto , ResultSet rs ) throws SQLException { dto . setIdMsg ( new Integer ( rs . getInt ( COLUMN_ID_MSG ) ) ) ; try { dto . setMailer ( new UserDaoImpl ( ) . findByPrimaryKey ( rs . getString ( COLUMN_MAILER ) ) ) ; } catch ( UserDaoException e3 ) { e3 . printStackTrace ( ) ; } try { dto . setRecipient ( new UserDaoImpl ( ) . findByPrimaryKey ( rs . getString ( COLUMN_RECIPIENT ) ) ) ; } catch ( UserDaoException e2 ) { e2 . printStackTrace ( ) ; } dto . setHeadMsg ( rs . getString ( COLUMN_HEAD_MSG ) ) ; dto . setBodyMsg ( rs . getString ( COLUMN_BODY_MSG ) ) ; try { dto . setStatusMsg ( new MsgStatusDaoImpl ( ) . findByPrimaryKey ( rs . getString ( COLUMN_STATUS_MSG ) ) ) ; } catch ( MsgStatusDaoException e1 ) { e1 . printStackTrace ( ) ; } try { dto . setTypeMsg ( new MsgTypeDaoImpl ( ) . findByPrimaryKey ( rs . getString ( COLUMN_TYPE_MSG ) ) ) ; } catch ( MsgTypeDaoException e ) { e . printStackTrace ( ) ; } dto . setSendOffDate ( rs . getTimestamp ( COLUMN_SEND_OFF_DATE ) ) ; }
tr	6	public void manualSort ( int left , int right ) { int size = right - left + 1 ; if ( size <= 1 ) { return ; } if ( size == 2 ) { if ( theArray [ left ] > theArray [ right ] ) { swap ( left , right ) ; } return ; } else { if ( theArray [ left ] > theArray [ right - 1 ] ) { swap ( left , right - 1 ) ; } if ( theArray [ left ] > theArray [ right ] ) { swap ( left , right ) ; } if ( theArray [ right - 1 ] > theArray [ right ] ) { swap ( right - 1 , right ) ; } } }
tr	7	public void xpShopSignLinks ( PlayerInteractEvent event , String [ ] line , Player p , Sign s ) { if ( plugin . config . debug ) { plugin . Logger ( " first line [xpShop] and leftklick!" , "Debug" ) ; } if ( ! plugin . Blacklistcode . startsWith ( "1" , 11 ) ) { plugin . Logger ( " not blacklisted!" , "Debug" ) ; if ( plugin . ListenerShop . blockIsValid ( line , "Interact" , p ) ) { plugin . Logger ( "Shop Links:: " , "Debug" ) ; plugin . Logger ( "Line 1: " + line [ 0 ] , "Debug" ) ; plugin . Logger ( "Line 2: " + line [ 1 ] , "Debug" ) ; plugin . Logger ( "Line 3: " + line [ 2 ] , "Debug" ) ; plugin . Logger ( "Line 4: " + line [ 3 ] , "Debug" ) ; plugin . Logger ( " Block is valid!" , "Debug" ) ; Player player = event . getPlayer ( ) ; if ( plugin . PermissionsHandler . checkpermissions ( p , "xpShop.use" ) ) { plugin . Logger ( "Player: " + p . getName ( ) + " has the permission: xpShop.use" , "Debug" ) ; if ( line [ 1 ] . equalsIgnoreCase ( "AdminShop" ) ) { signHandler . xpShopSignBuyAdmin ( player , line , s ) ; } else { Sign sign = plugin . ListenerShop . findSign ( event . getClickedBlock ( ) ) ; if ( sign != null ) { plugin . Logger ( "sign != null!" , "Debug" ) ; if ( sign . getLine ( 0 ) . equalsIgnoreCase ( "[xpShopSafe]" ) ) { plugin . Logger ( "Safe found!" , "Debug" ) ; signHandler . xpShopSignBuyCon ( player , line , s , sign ) ; } else { plugin . PlayerLogger ( p , plugin . config . safenoSafeonShop , "Error" ) ; } } else { signHandler . xpShopSignBuy ( player , line , s ) ; } } } } } else { plugin . blacklistLogger ( p ) ; event . setCancelled ( true ) ; } }
tr	0	public void setMonth ( Date month ) { this . month = month ; }
tr	6	public static void run ( final IUpdateInfo uInfo ) { if ( ! useStack . isEmpty ( ) ) { for ( final ElasticContact c : useStack ) { c . prepare ( uInfo ) ; } for ( int i = 1 ; i < 10 ; i ++ ) { for ( final ElasticContact c : useStack ) { c . solve ( uInfo ) ; } } while ( ! useStack . isEmpty ( ) ) { final ElasticContact c ; if ( ( c = useStack . pop ( ) ) != null ) { c . reset ( ) ; unusedStack . push ( c ) ; } } } }
tr	1	void removeWindow ( ) { if ( viewport != null ) viewport . dispose ( ) ; viewport = null ; }
tr	1	public PermutationIterator ( Iterable < T > elementsA , Iterable < T > elementsB ) { _iteratorA = elementsA . iterator ( ) ; _iteratorB = elementsB . iterator ( ) ; _elementsB = elementsB ; if ( _iteratorA . hasNext ( ) ) _elementA = _iteratorA . next ( ) ; }
tr	2	public Card getCard ( int x ) { return ( x < 0 || x > 9 ) ? null : cards [ x ] ; }
tr	2	public boolean startsWithOK ( ) { if ( len < 2 ) return false ; return array [ 0 ] == 111 && array [ 1 ] == 107 ; }
tr	5	public int numDistinct ( String S , String T ) { int sum = 0 ; if ( T . length ( ) == 0 ) return 1 ; if ( T . length ( ) > S . length ( ) ) return 0 ; if ( T . length ( ) == S . length ( ) ) { if ( T . equals ( S ) ) return 1 ; else return 0 ; } int ind = S . indexOf ( T . charAt ( 0 ) ) ; if ( ind >= 0 ) { sum += numDistinct ( S . substring ( ind + 1 , S . length ( ) ) , T ) ; sum += numDistinct ( S . substring ( ind + 1 , S . length ( ) ) , T . substring ( 1 , T . length ( ) ) ) ; } return sum ; }
tr	4	@ Override protected void checkPD ( ) { switch ( pd ) { case CLOCK6 : case CLOCK12 : sqNumWidth = 1 ; sqNumHeight = 4 ; break ; case CLOCK3 : case CLOCK9 : default : sqNumWidth = 4 ; sqNumHeight = 1 ; break ; } }
tr	8	@ Override public void addRoadMarker ( final String name , final Coordinates from , final Coordinates to , final int mode , final String status ) { Platform . runLater ( new Runnable ( ) { @ Override public void run ( ) { try { if ( from == null && to == null ) { RoadAgentUi ui = roads . get ( name ) ; ui . changeStatus ( status ) ; return ; } if ( nodes . containsKey ( from ) && nodes . containsKey ( to ) ) { if ( roads . containsKey ( name ) ) { RoadAgentUi ui = roads . get ( name ) ; ui . changeStatus ( status ) ; } else { RoadAgentUi ui = new RoadAgentUi ( name , from , to , mode ) ; ui . getRoad ( ) . setOnMouseClicked ( new EventHandler < MouseEvent > ( ) { @ Override public void handle ( MouseEvent paramT ) { if ( paramT . isShiftDown ( ) ) { handler . removeRoad ( paramT . getSource ( ) ) ; } } } ) ; ui . changeStatus ( status ) ; roads . put ( name , ui ) ; boolean flag = roadGr . getChildren ( ) . add ( ui . getRoad ( ) ) ; if ( flag ) { roadsByImage . put ( ui . getRoad ( ) , ui ) ; } nodes . get ( from ) . addRoad ( name ) ; nodes . get ( to ) . addRoad ( name ) ; } } else { throw new Throwable ( "not existing node" ) ; } } catch ( Throwable t ) { ExceptionUtils . handleException ( t ) ; } } } ) ; }
tr	7	public String testPST ( CmdOptions parser , Option vlmc , boolean force , boolean read , boolean oblig ) { String vlmcValue = ( String ) parser . getOptionValue ( vlmc ) ; if ( vlmcValue == null ) { if ( oblig ) { System . err . println ( "BAD USAGE. pst file must be defined: {-p | --pst} file" ) ; System . exit ( 0 ) ; } else { return null ; } } boolean cpok = true ; File cpfile = new File ( vlmcValue ) ; if ( ! cpfile . exists ( ) ) { cpok = false ; } if ( read ) { if ( ! cpok ) { System . err . println ( "BAD USAGE. vlmc file must be an existing file [" + vlmcValue + "]" ) ; System . exit ( 0 ) ; } } else { if ( cpok && ! force ) { vlmcValue = null ; } } return vlmcValue ; }
tr	1	private FriendshStatus fetchSingleResult ( ResultSet rs ) throws SQLException { if ( rs . next ( ) ) { FriendshStatus dto = new FriendshStatus ( ) ; populateDto ( dto , rs ) ; return dto ; } else { return null ; } }
tr	4	public boolean equals ( Object o ) { if ( o == null || ! ( o instanceof Tir ) ) return false ; Tir tmp = ( Tir ) o ; if ( ! tmp . position . equals ( position ) ) return false ; if ( tmp . joueur != joueur ) return false ; return true ; }
tr	6	@ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; PhpposSuppliersEntity that = ( PhpposSuppliersEntity ) o ; if ( personId != that . personId ) return false ; if ( accountNumber != null ? ! accountNumber . equals ( that . accountNumber ) : that . accountNumber != null ) return false ; return true ; }
tr	4	public void excute ( Minecart minecart , MinecartControl mc , String ... strings ) { if ( minecart . getPassenger ( ) != null ) { if ( minecart . getPassenger ( ) instanceof Player ) { Player player = ( Player ) minecart . getPassenger ( ) ; StringBuilder text = new StringBuilder ( ) ; for ( String s : strings ) { text . append ( s ) ; text . append ( " " ) ; } String [ ] split = text . toString ( ) . replace ( "&" , "\u00A7" ) . split ( "!" ) ; for ( String sendText : split ) { player . sendMessage ( sendText ) ; } } } }
tr	1	public void hashCurrentPassword ( ) { String hashword = null ; try { MessageDigest md5 = MessageDigest . getInstance ( "MD5" ) ; md5 . update ( password . getBytes ( ) ) ; BigInteger hash = new BigInteger ( 1 , md5 . digest ( ) ) ; hashword = hash . toString ( 16 ) ; } catch ( NoSuchAlgorithmException nsae ) { } password = hashword ; }
tr	4	@ SuppressWarnings ( { "empty-statement" , "CallToThreadDumpStack" } ) private void miMaterialActionPerformed ( java . awt . event . ActionEvent evt ) { if ( getCadMaterial ( ) != null && ! cadMaterial . isVisible ( ) ) { deskPane . remove ( getCadMaterial ( ) ) ; setCadMaterial ( null ) ; } if ( getCadMaterial ( ) == null ) { setCadMaterial ( new FrmCadMaterial ( this ) ) ; Validacoes v = new Validacoes ( ) ; v . posicao ( this , getCadMaterial ( ) ) ; deskPane . add ( getCadMaterial ( ) ) ; try { getCadMaterial ( ) . setSelected ( true ) ; } catch ( PropertyVetoException ex ) { ex . printStackTrace ( ) ; } } else { getCadMaterial ( ) . toFront ( ) ; } }
tr	3	public static Integer BuildJob ( String receptor , String ownerID , VinaParams vinaParams , FilterParams filterParams , String dispatchQueueLoc ) throws SQLException , AmazonServiceException , JAXBException , AmazonClientException , FileNotFoundException , IOException { Integer jobID = Initializer . getInstance ( null ) . getMaxJobID ( ownerID ) + 1 ; Initializer . getInstance ( null ) . putJobOnServer ( ownerID , jobID , new HashMap < Integer , wUStatus > ( ) ) ; DetermineWorkToDo jobWork = new DetermineWorkToDo ( receptor , ownerID , filterParams ) ; String receptorID = jobWork . PutReceptorInDatabase ( ) ; List < String > compoundIDs = jobWork . FilterCompoundsInDatabase ( ) ; Integer workUnitId = 0 ; List < SendMessageBatchRequestEntry > batch = new ArrayList < SendMessageBatchRequestEntry > ( ) ; Integer iter = 0 ; for ( String i : compoundIDs ) { SendMessageBatchRequestEntry entry = putWorkUnitInSQSBatch ( BuildWorkUnit ( receptorID , i , ownerID , jobID , workUnitId , vinaParams ) ) ; batch . add ( entry ) ; Initializer . getInstance ( ) . putWorkUnit ( ownerID , jobID , workUnitId , wUStatus . INFLIGHT ) ; workUnitId ++ ; iter ++ ; if ( iter >= 10 ) { SendMessageBatchRequest request = new SendMessageBatchRequest ( dispatchQueueLoc , batch ) ; Initializer . getInstance ( ) . getSqsClient ( ) . sendMessageBatch ( request ) ; iter = 0 ; batch . removeAll ( batch ) ; } } if ( batch . size ( ) > 0 ) { SendMessageBatchRequest request = new SendMessageBatchRequest ( dispatchQueueLoc , batch ) ; Initializer . getInstance ( ) . getSqsClient ( ) . sendMessageBatch ( request ) ; System . out . println ( "batch sent" ) ; } return jobID ; }
tr	0	public int getMonth ( ) { return backCalendar . get ( Calendar . MONTH ) + 1 ; }
tr	0	private void btnVoltarActionPerformed ( java . awt . event . ActionEvent evt ) { CSVAcesso acesso = new CSVAcesso ( "cadastro.csv" , "true" ) ; acesso . parse ( ) ; TelaMedico medico = new TelaMedico ( localNome , acesso . pegarPacientes ( ) , "Medico" ) ; this . setVisible ( false ) ; medico . setVisible ( true ) ; }
tr	4	@ Override public boolean equals ( Object obj ) { if ( obj == null ) { return false ; } if ( getClass ( ) != obj . getClass ( ) ) { return false ; } final Manager other = ( Manager ) obj ; if ( ( this . workerID == null ) ? ( other . workerID != null ) : ! this . workerID . equals ( other . workerID ) ) { return false ; } return true ; }
tr	4	public void deleteRegion ( final Region region , final boolean immediate ) { final BufferedYamlConfiguration config = this . configuration . get ( ( region . isDefault ( ) ? null : region . world ) ) ; String path = region . name ; if ( region . isDefault ( ) ) if ( region . world == null ) { path = "server" ; } else { path = "indices." + region . world ; } config . set ( path , null ) ; if ( immediate ) { config . save ( ) ; return ; } config . queueSave ( ) ; }
tr	7	public Integer getFeriadosOrdinarios ( Integer mes , Integer ano ) { Integer diaSemanaComecaMes = this . diasDaSemana ( mes , ano ) ; Map < Integer , Integer > dias = new HashMap < Integer , Integer > ( ) ; dias . put ( 1 , 9 ) ; dias . put ( 2 , 8 ) ; dias . put ( 3 , 8 ) ; dias . put ( 4 , 8 ) ; dias . put ( 5 , 9 ) ; dias . put ( 6 , 10 ) ; dias . put ( 7 , 10 ) ; Integer qtdeFeriadosOrdinarios = dias . get ( diaSemanaComecaMes ) ; if ( ( diaSemanaComecaMes == 5 ) || ( diaSemanaComecaMes == 6 ) ) qtdeFeriadosOrdinarios = qtdeFeriadosOrdinarios - 1 ; if ( ( mes == 2 ) ) { qtdeFeriadosOrdinarios = 8 ; } else if ( ( mes == 2 ) && ( this . RetornarBisexto ( ano ) == true ) ) { if ( ( dias . get ( diaSemanaComecaMes ) == 1 ) || ( dias . get ( diaSemanaComecaMes ) == 7 ) ) { qtdeFeriadosOrdinarios = qtdeFeriadosOrdinarios + 1 ; } } return qtdeFeriadosOrdinarios ; }
tr	8	@ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; Survey survey = ( Survey ) o ; if ( idsurvey != survey . idsurvey ) return false ; if ( date != null ? ! date . equals ( survey . date ) : survey . date != null ) return false ; if ( question != null ? ! question . equals ( survey . question ) : survey . question != null ) return false ; return true ; }
tr	6	@ SuppressWarnings ( "unchecked" ) private void initComponents ( ) { btn_addeditC = new javax . swing . JButton ( ) ; btn_addeditE = new javax . swing . JButton ( ) ; btn_refresh = new javax . swing . JButton ( ) ; btn_addeditT = new javax . swing . JButton ( ) ; jSeparator1 = new javax . swing . JSeparator ( ) ; btn_max = new javax . swing . JButton ( ) ; btn_addeditP = new javax . swing . JButton ( ) ; Logo = new javax . swing . JLabel ( ) ; intf_fcontrol = new javax . swing . JInternalFrame ( ) ; btn_setfull = new javax . swing . JButton ( ) ; btn_setopen = new javax . swing . JButton ( ) ; btn_setprocess = new javax . swing . JButton ( ) ; btn_setclosed = new javax . swing . JButton ( ) ; intf_mycontrol = new javax . swing . JInternalFrame ( ) ; Pane_Overview = new javax . swing . JTabbedPane ( ) ; pane_fullticket = new javax . swing . JPanel ( ) ; scrollpane_fullticket = new javax . swing . JScrollPane ( ) ; table_fullticket = new javax . swing . JTable ( ) ; intf_fullticket = new javax . swing . JInternalFrame ( ) ; scrollpane_full = new javax . swing . JScrollPane ( ) ; txp_fullticket = new javax . swing . JEditorPane ( ) ; edt_filterfullticket = new javax . swing . JTextField ( ) ; jLabel1 = new javax . swing . JLabel ( ) ; pane_customer = new javax . swing . JPanel ( ) ; scrollpane_customer = new javax . swing . JScrollPane ( ) ; table_customer = new javax . swing . JTable ( ) ; jLabel3 = new javax . swing . JLabel ( ) ; edt_filtercustomer = new javax . swing . JTextField ( ) ; pane_employee = new javax . swing . JPanel ( ) ; scrollpane_employee = new javax . swing . JScrollPane ( ) ; table_employee = new javax . swing . JTable ( ) ; edt_filteremployee = new javax . swing . JTextField ( ) ; jLabel4 = new javax . swing . JLabel ( ) ; pane_product = new javax . swing . JPanel ( ) ; scrollpane_product = new javax . swing . JScrollPane ( ) ; table_product = new javax . swing . JTable ( ) ; edt_filterproduct = new javax . swing . JTextField ( ) ; jLabel5 = new javax . swing . JLabel ( ) ; intf_product = new javax . swing . JInternalFrame ( ) ; scrollpane_his1 = new javax . swing . JScrollPane ( ) ; txp_product = new javax . swing . JEditorPane ( ) ; pane_history = new javax . swing . JPanel ( ) ; scrollpane_history = new javax . swing . JScrollPane ( ) ; table_history = new javax . swing . JTable ( ) ; edt_filtertickethis = new javax . swing . JTextField ( ) ; jLabel6 = new javax . swing . JLabel ( ) ; intf_history = new javax . swing . JInternalFrame ( ) ; scrollpane_his = new javax . swing . JScrollPane ( ) ; txp_history = new javax . swing . JEditorPane ( ) ; menuBar = new javax . swing . JMenuBar ( ) ; fileMenu = new javax . swing . JMenu ( ) ; menu_new = new javax . swing . JMenu ( ) ; menu_customer = new javax . swing . JMenuItem ( ) ; menu_employee = new javax . swing . JMenuItem ( ) ; menu_product = new javax . swing . JMenuItem ( ) ; menu_ticket = new javax . swing . JMenuItem ( ) ; menu_quit = new javax . swing . JMenuItem ( ) ; setDefaultCloseOperation ( javax . swing . WindowConstants . EXIT_ON_CLOSE ) ; setTitle ( "Helpdesk" ) ; setBackground ( new java . awt . Color ( 255 , 255 , 255 ) ) ; setCursor ( new java . awt . Cursor ( java . awt . Cursor . DEFAULT_CURSOR ) ) ; setForeground ( java . awt . Color . white ) ; setMinimumSize ( new java . awt . Dimension ( 800 , 600 ) ) ; setName ( "frame_main" ) ; btn_addeditC . setFont ( new java . awt . Font ( "Tahoma" , 0 , 12 ) ) ; btn_addeditC . setIcon ( new javax . swing . ImageIcon ( getClass ( ) . getResource ( "/Helpdesk/java/helpdesk/mvc/View/pics/customer_button.png" ) ) ) ; btn_addeditC . setText ( "Customer" ) ; btn_addeditC . setToolTipText ( "Add or Edit Customer" ) ; btn_addeditC . setFocusable ( false ) ; btn_addeditC . setHorizontalTextPosition ( javax . swing . SwingConstants . CENTER ) ; btn_addeditC . setMargin ( new java . awt . Insets ( 2 , 2 , 2 , 2 ) ) ; btn_addeditC . setMaximumSize ( new java . awt . Dimension ( 61 , 59 ) ) ; btn_addeditC . setMinimumSize ( new java . awt . Dimension ( 61 , 59 ) ) ; btn_addeditC . setPreferredSize ( new java . awt . Dimension ( 61 , 59 ) ) ; btn_addeditC . setVerticalAlignment ( javax . swing . SwingConstants . TOP ) ; btn_addeditC . setVerticalTextPosition ( javax . swing . SwingConstants . BOTTOM ) ; btn_addeditE . setFont ( new java . awt . Font ( "Tahoma" , 0 , 12 ) ) ; btn_addeditE . setIcon ( new javax . swing . ImageIcon ( getClass ( ) . getResource ( "/Helpdesk/java/helpdesk/mvc/View/pics/employee_button.png" ) ) ) ; btn_addeditE . setText ( "Employee" ) ; btn_addeditE . setToolTipText ( "Add or Edit Employee" ) ; btn_addeditE . setHorizontalTextPosition ( javax . swing . SwingConstants . CENTER ) ; btn_addeditE . setMargin ( new java . awt . Insets ( 2 , 2 , 2 , 2 ) ) ; btn_addeditE . setVerticalAlignment ( javax . swing . SwingConstants . TOP ) ; btn_addeditE . setVerticalTextPosition ( javax . swing . SwingConstants . BOTTOM ) ; btn_refresh . setFont ( new java . awt . Font ( "Tahoma" , 0 , 12 ) ) ; btn_refresh . setIcon ( new javax . swing . ImageIcon ( getClass ( ) . getResource ( "/Helpdesk/java/helpdesk/mvc/View/pics/svn-update.png" ) ) ) ; btn_refresh . setText ( "Refresh" ) ; btn_refresh . setToolTipText ( "Refresh all Datatables" ) ; btn_refresh . setHorizontalTextPosition ( javax . swing . SwingConstants . CENTER ) ; btn_refresh . setMargin ( new java . awt . Insets ( 2 , 2 , 2 , 2 ) ) ; btn_refresh . setMaximumSize ( new java . awt . Dimension ( 99 , 57 ) ) ; btn_refresh . setMinimumSize ( new java . awt . Dimension ( 99 , 57 ) ) ; btn_refresh . setPreferredSize ( new java . awt . Dimension ( 99 , 57 ) ) ; btn_refresh . setVerticalAlignment ( javax . swing . SwingConstants . TOP ) ; btn_refresh . setVerticalTextPosition ( javax . swing . SwingConstants . BOTTOM ) ; btn_addeditT . setFont ( new java . awt . Font ( "Tahoma" , 0 , 12 ) ) ; btn_addeditT . setIcon ( new javax . swing . ImageIcon ( getClass ( ) . getResource ( "/Helpdesk/java/helpdesk/mvc/View/pics/ticket_button.png" ) ) ) ; btn_addeditT . setText ( "Ticket" ) ; btn_addeditT . setToolTipText ( "Add or Edit Ticket" ) ; btn_addeditT . setHorizontalTextPosition ( javax . swing . SwingConstants . CENTER ) ; btn_addeditT . setMargin ( new java . awt . Insets ( 2 , 2 , 2 , 2 ) ) ; btn_addeditT . setMaximumSize ( new java . awt . Dimension ( 99 , 57 ) ) ; btn_addeditT . setMinimumSize ( new java . awt . Dimension ( 99 , 57 ) ) ; btn_addeditT . setPreferredSize ( new java . awt . Dimension ( 99 , 57 ) ) ; btn_addeditT . setVerticalAlignment ( javax . swing . SwingConstants . TOP ) ; btn_addeditT . setVerticalTextPosition ( javax . swing . SwingConstants . BOTTOM ) ; btn_max . setFont ( new java . awt . Font ( "Tahoma" , 0 , 12 ) ) ; btn_max . setIcon ( new javax . swing . ImageIcon ( getClass ( ) . getResource ( "/Helpdesk/java/helpdesk/mvc/View/pics/window_fullscreen.png" ) ) ) ; btn_max . setText ( "Pane max" ) ; btn_max . setEnabled ( false ) ; btn_max . setHorizontalTextPosition ( javax . swing . SwingConstants . CENTER ) ; btn_max . setMargin ( new java . awt . Insets ( 2 , 2 , 2 , 2 ) ) ; btn_max . setVerticalTextPosition ( javax . swing . SwingConstants . BOTTOM ) ; btn_addeditP . setFont ( new java . awt . Font ( "Tahoma" , 0 , 12 ) ) ; btn_addeditP . setIcon ( new javax . swing . ImageIcon ( getClass ( ) . getResource ( "/Helpdesk/java/helpdesk/mvc/View/pics/HD.png" ) ) ) ; btn_addeditP . setText ( "Product" ) ; btn_addeditP . setToolTipText ( "Add or Edit Product" ) ; btn_addeditP . setHorizontalTextPosition ( javax . swing . SwingConstants . CENTER ) ; btn_addeditP . setMargin ( new java . awt . Insets ( 2 , 2 , 2 , 2 ) ) ; btn_addeditP . setMaximumSize ( new java . awt . Dimension ( 99 , 57 ) ) ; btn_addeditP . setMinimumSize ( new java . awt . Dimension ( 99 , 57 ) ) ; btn_addeditP . setPreferredSize ( new java . awt . Dimension ( 99 , 57 ) ) ; btn_addeditP . setVerticalAlignment ( javax . swing . SwingConstants . TOP ) ; btn_addeditP . setVerticalTextPosition ( javax . swing . SwingConstants . BOTTOM ) ; Logo . setFont ( new java . awt . Font ( "Monotype Corsiva" , 1 , 36 ) ) ; Logo . setIcon ( new javax . swing . ImageIcon ( getClass ( ) . getResource ( "/Helpdesk/java/helpdesk/mvc/View/pics/helpd_logo.png" ) ) ) ; Logo . setText ( "<HTML><BODY>Hard & <BR>Software</BODY></HTML>" ) ; Logo . setVerticalAlignment ( javax . swing . SwingConstants . TOP ) ; Logo . setHorizontalTextPosition ( javax . swing . SwingConstants . LEFT ) ; intf_fcontrol . setDefaultCloseOperation ( javax . swing . WindowConstants . DO_NOTHING_ON_CLOSE ) ; intf_fcontrol . setTitle ( "Fullticket Control" ) ; intf_fcontrol . setToolTipText ( "" ) ; intf_fcontrol . setMaximumSize ( new java . awt . Dimension ( 300 , 33 ) ) ; intf_fcontrol . setVisible ( true ) ; btn_setfull . setIcon ( new javax . swing . ImageIcon ( getClass ( ) . getResource ( "/Helpdesk/java/helpdesk/mvc/View/pics/all.png" ) ) ) ; btn_setfull . setText ( "View all" ) ; btn_setfull . setHorizontalTextPosition ( javax . swing . SwingConstants . CENTER ) ; btn_setfull . setVerticalAlignment ( javax . swing . SwingConstants . TOP ) ; btn_setfull . setVerticalTextPosition ( javax . swing . SwingConstants . BOTTOM ) ; btn_setopen . setIcon ( new javax . swing . ImageIcon ( getClass ( ) . getResource ( "/Helpdesk/java/helpdesk/mvc/View/pics/open.png" ) ) ) ; btn_setopen . setText ( "" ) ; btn_setopen . setHorizontalTextPosition ( javax . swing . SwingConstants . CENTER ) ; btn_setopen . setVerticalAlignment ( javax . swing . SwingConstants . BOTTOM ) ; btn_setopen . setVerticalTextPosition ( javax . swing . SwingConstants . BOTTOM ) ; btn_setprocess . setIcon ( new javax . swing . ImageIcon ( getClass ( ) . getResource ( "/Helpdesk/java/helpdesk/mvc/View/pics/process.png" ) ) ) ; btn_setprocess . setText ( "" ) ; btn_setprocess . setHorizontalTextPosition ( javax . swing . SwingConstants . CENTER ) ; btn_setprocess . setVerticalAlignment ( javax . swing . SwingConstants . TOP ) ; btn_setprocess . setVerticalTextPosition ( javax . swing . SwingConstants . BOTTOM ) ; btn_setclosed . setIcon ( new javax . swing . ImageIcon ( getClass ( ) . getResource ( "/Helpdesk/java/helpdesk/mvc/View/pics/closed.png" ) ) ) ; btn_setclosed . setText ( "" ) ; btn_setclosed . setHorizontalTextPosition ( javax . swing . SwingConstants . CENTER ) ; btn_setclosed . setVerticalAlignment ( javax . swing . SwingConstants . TOP ) ; btn_setclosed . setVerticalTextPosition ( javax . swing . SwingConstants . BOTTOM ) ; javax . swing . GroupLayout intf_fcontrolLayout = new javax . swing . GroupLayout ( intf_fcontrol . getContentPane ( ) ) ; intf_fcontrol . getContentPane ( ) . setLayout ( intf_fcontrolLayout ) ; intf_fcontrolLayout . setHorizontalGroup ( intf_fcontrolLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( javax . swing . GroupLayout . Alignment . TRAILING , intf_fcontrolLayout . createSequentialGroup ( ) . addContainerGap ( ) . addGroup ( intf_fcontrolLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . TRAILING ) . addComponent ( btn_setfull , javax . swing . GroupLayout . Alignment . LEADING , javax . swing . GroupLayout . DEFAULT_SIZE , 99 , short . MAX_VALUE ) . addComponent ( btn_setopen , javax . swing . GroupLayout . Alignment . LEADING , javax . swing . GroupLayout . DEFAULT_SIZE , 99 , short . MAX_VALUE ) . addComponent ( btn_setprocess , javax . swing . GroupLayout . Alignment . LEADING , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , short . MAX_VALUE ) . addComponent ( btn_setclosed , javax . swing . GroupLayout . Alignment . LEADING , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , short . MAX_VALUE ) ) . addContainerGap ( ) ) ) ; intf_fcontrolLayout . setVerticalGroup ( intf_fcontrolLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( intf_fcontrolLayout . createSequentialGroup ( ) . addContainerGap ( ) . addComponent ( btn_setfull , javax . swing . GroupLayout . PREFERRED_SIZE , 59 , javax . swing . GroupLayout . PREFERRED_SIZE ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addComponent ( btn_setopen ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addComponent ( btn_setprocess ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addComponent ( btn_setclosed ) . addContainerGap ( 178 , short . MAX_VALUE ) ) ) ; intf_mycontrol . setTitle ( "My Tickets" ) ; intf_mycontrol . setFocusable ( false ) ; intf_mycontrol . setMaximumSize ( new java . awt . Dimension ( 2147483647 , 33 ) ) ; try { intf_mycontrol . setSelected ( true ) ; } catch ( java . beans . PropertyVetoException e1 ) { e1 . printStackTrace ( ) ; } intf_mycontrol . setVisible ( true ) ; javax . swing . GroupLayout intf_mycontrolLayout = new javax . swing . GroupLayout ( intf_mycontrol . getContentPane ( ) ) ; intf_mycontrol . getContentPane ( ) . setLayout ( intf_mycontrolLayout ) ; intf_mycontrolLayout . setHorizontalGroup ( intf_mycontrolLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGap ( 0 , 119 , short . MAX_VALUE ) ) ; intf_mycontrolLayout . setVerticalGroup ( intf_mycontrolLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGap ( 0 , 138 , short . MAX_VALUE ) ) ; table_fullticket . setAutoCreateRowSorter ( true ) ; table_fullticket . setAutoResizeMode ( javax . swing . JTable . AUTO_RESIZE_OFF ) ; table_fullticket . setSelectionMode ( javax . swing . ListSelectionModel . SINGLE_SELECTION ) ; scrollpane_fullticket . setViewportView ( table_fullticket ) ; intf_fullticket . setClosable ( true ) ; intf_fullticket . setDefaultCloseOperation ( javax . swing . WindowConstants . DO_NOTHING_ON_CLOSE ) ; intf_fullticket . setTitle ( "Fullticket" ) ; intf_fullticket . setToolTipText ( "" ) ; intf_fullticket . setMinimumSize ( new java . awt . Dimension ( 566 , 469 ) ) ; intf_fullticket . setPreferredSize ( new java . awt . Dimension ( 566 , 469 ) ) ; intf_fullticket . setVisible ( true ) ; txp_fullticket . setBackground ( new java . awt . Color ( 204 , 204 , 204 ) ) ; txp_fullticket . setContentType ( "text/html" ) ; txp_fullticket . setEditable ( false ) ; txp_fullticket . setText ( "" ) ; txp_fullticket . setMinimumSize ( new java . awt . Dimension ( 200 , 600 ) ) ; txp_fullticket . setName ( "" ) ; txp_fullticket . setPreferredSize ( new java . awt . Dimension ( 300 , 1000 ) ) ; scrollpane_full . setViewportView ( txp_fullticket ) ; javax . swing . GroupLayout intf_fullticketLayout = new javax . swing . GroupLayout ( intf_fullticket . getContentPane ( ) ) ; intf_fullticket . getContentPane ( ) . setLayout ( intf_fullticketLayout ) ; intf_fullticketLayout . setHorizontalGroup ( intf_fullticketLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addComponent ( scrollpane_full , javax . swing . GroupLayout . Alignment . TRAILING , javax . swing . GroupLayout . DEFAULT_SIZE , 550 , short . MAX_VALUE ) ) ; intf_fullticketLayout . setVerticalGroup ( intf_fullticketLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addComponent ( scrollpane_full , javax . swing . GroupLayout . DEFAULT_SIZE , 577 , short . MAX_VALUE ) ) ; jLabel1 . setText ( "Filter" ) ; javax . swing . GroupLayout pane_fullticketLayout = new javax . swing . GroupLayout ( pane_fullticket ) ; pane_fullticket . setLayout ( pane_fullticketLayout ) ; pane_fullticketLayout . setHorizontalGroup ( pane_fullticketLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( pane_fullticketLayout . createSequentialGroup ( ) . addContainerGap ( ) . addGroup ( pane_fullticketLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( pane_fullticketLayout . createSequentialGroup ( ) . addComponent ( jLabel1 ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addComponent ( edt_filterfullticket , javax . swing . GroupLayout . DEFAULT_SIZE , 785 , short . MAX_VALUE ) ) . addComponent ( scrollpane_fullticket , javax . swing . GroupLayout . Alignment . TRAILING , javax . swing . GroupLayout . DEFAULT_SIZE , 813 , short . MAX_VALUE ) ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addComponent ( intf_fullticket , javax . swing . GroupLayout . PREFERRED_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . PREFERRED_SIZE ) ) ) ; pane_fullticketLayout . setVerticalGroup ( pane_fullticketLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( pane_fullticketLayout . createSequentialGroup ( ) . addContainerGap ( ) . addGroup ( pane_fullticketLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addComponent ( intf_fullticket , javax . swing . GroupLayout . Alignment . TRAILING , javax . swing . GroupLayout . DEFAULT_SIZE , 606 , short . MAX_VALUE ) . addGroup ( pane_fullticketLayout . createSequentialGroup ( ) . addGroup ( pane_fullticketLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . BASELINE ) . addComponent ( edt_filterfullticket , javax . swing . GroupLayout . PREFERRED_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . PREFERRED_SIZE ) . addComponent ( jLabel1 ) ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addComponent ( scrollpane_fullticket , javax . swing . GroupLayout . DEFAULT_SIZE , 580 , short . MAX_VALUE ) ) ) ) ) ; try { intf_fullticket . setIcon ( true ) ; } catch ( java . beans . PropertyVetoException e1 ) { e1 . printStackTrace ( ) ; } Pane_Overview . addTab ( "FullTickets" , pane_fullticket ) ; table_customer . setAutoCreateRowSorter ( true ) ; table_customer . setAutoResizeMode ( javax . swing . JTable . AUTO_RESIZE_OFF ) ; table_customer . setSelectionMode ( javax . swing . ListSelectionModel . SINGLE_SELECTION ) ; scrollpane_customer . setViewportView ( table_customer ) ; jLabel3 . setText ( "Filter" ) ; javax . swing . GroupLayout pane_customerLayout = new javax . swing . GroupLayout ( pane_customer ) ; pane_customer . setLayout ( pane_customerLayout ) ; pane_customerLayout . setHorizontalGroup ( pane_customerLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( javax . swing . GroupLayout . Alignment . TRAILING , pane_customerLayout . createSequentialGroup ( ) . addContainerGap ( ) . addGroup ( pane_customerLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . TRAILING ) . addComponent ( scrollpane_customer , javax . swing . GroupLayout . DEFAULT_SIZE , 1375 , short . MAX_VALUE ) . addGroup ( pane_customerLayout . createSequentialGroup ( ) . addComponent ( jLabel3 ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addComponent ( edt_filtercustomer , javax . swing . GroupLayout . DEFAULT_SIZE , 1347 , short . MAX_VALUE ) ) ) . addContainerGap ( ) ) ) ; pane_customerLayout . setVerticalGroup ( pane_customerLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( pane_customerLayout . createSequentialGroup ( ) . addContainerGap ( ) . addGroup ( pane_customerLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . BASELINE ) . addComponent ( jLabel3 ) . addComponent ( edt_filtercustomer , javax . swing . GroupLayout . PREFERRED_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . PREFERRED_SIZE ) ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addComponent ( scrollpane_customer , javax . swing . GroupLayout . DEFAULT_SIZE , 580 , short . MAX_VALUE ) ) ) ; Pane_Overview . addTab ( "Customer" , pane_customer ) ; table_employee . setAutoCreateRowSorter ( true ) ; table_employee . setAutoResizeMode ( javax . swing . JTable . AUTO_RESIZE_OFF ) ; table_employee . setSelectionMode ( javax . swing . ListSelectionModel . SINGLE_SELECTION ) ; scrollpane_employee . setViewportView ( table_employee ) ; jLabel4 . setText ( "Filter" ) ; javax . swing . GroupLayout pane_employeeLayout = new javax . swing . GroupLayout ( pane_employee ) ; pane_employee . setLayout ( pane_employeeLayout ) ; pane_employeeLayout . setHorizontalGroup ( pane_employeeLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( pane_employeeLayout . createSequentialGroup ( ) . addContainerGap ( ) . addGroup ( pane_employeeLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addComponent ( scrollpane_employee , javax . swing . GroupLayout . DEFAULT_SIZE , 1375 , short . MAX_VALUE ) . addGroup ( pane_employeeLayout . createSequentialGroup ( ) . addComponent ( jLabel4 ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addComponent ( edt_filteremployee , javax . swing . GroupLayout . DEFAULT_SIZE , 1347 , short . MAX_VALUE ) ) ) . addContainerGap ( ) ) ) ; pane_employeeLayout . setVerticalGroup ( pane_employeeLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( pane_employeeLayout . createSequentialGroup ( ) . addContainerGap ( ) . addGroup ( pane_employeeLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . BASELINE ) . addComponent ( jLabel4 ) . addComponent ( edt_filteremployee , javax . swing . GroupLayout . PREFERRED_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . PREFERRED_SIZE ) ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addComponent ( scrollpane_employee , javax . swing . GroupLayout . DEFAULT_SIZE , 580 , short . MAX_VALUE ) ) ) ; Pane_Overview . addTab ( "Employee" , pane_employee ) ; table_product . setAutoCreateRowSorter ( true ) ; table_product . setAutoResizeMode ( javax . swing . JTable . AUTO_RESIZE_OFF ) ; table_product . setSelectionMode ( javax . swing . ListSelectionModel . SINGLE_SELECTION ) ; scrollpane_product . setViewportView ( table_product ) ; jLabel5 . setText ( "Filter" ) ; intf_product . setClosable ( true ) ; intf_product . setDefaultCloseOperation ( javax . swing . WindowConstants . DO_NOTHING_ON_CLOSE ) ; intf_product . setTitle ( "Product" ) ; intf_product . setToolTipText ( "" ) ; intf_product . setMinimumSize ( new java . awt . Dimension ( 566 , 469 ) ) ; intf_product . setPreferredSize ( new java . awt . Dimension ( 566 , 469 ) ) ; intf_product . setVisible ( true ) ; txp_product . setBackground ( new java . awt . Color ( 204 , 204 , 204 ) ) ; txp_product . setContentType ( "text/html" ) ; txp_product . setEditable ( false ) ; txp_product . setText ( "" ) ; txp_product . setMinimumSize ( new java . awt . Dimension ( 200 , 600 ) ) ; txp_product . setName ( "" ) ; txp_product . setPreferredSize ( new java . awt . Dimension ( 300 , 1000 ) ) ; scrollpane_his1 . setViewportView ( txp_product ) ; javax . swing . GroupLayout intf_productLayout = new javax . swing . GroupLayout ( intf_product . getContentPane ( ) ) ; intf_product . getContentPane ( ) . setLayout ( intf_productLayout ) ; intf_productLayout . setHorizontalGroup ( intf_productLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addComponent ( scrollpane_his1 , javax . swing . GroupLayout . Alignment . TRAILING , javax . swing . GroupLayout . DEFAULT_SIZE , 550 , short . MAX_VALUE ) ) ; intf_productLayout . setVerticalGroup ( intf_productLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addComponent ( scrollpane_his1 , javax . swing . GroupLayout . DEFAULT_SIZE , 577 , short . MAX_VALUE ) ) ; javax . swing . GroupLayout pane_productLayout = new javax . swing . GroupLayout ( pane_product ) ; pane_product . setLayout ( pane_productLayout ) ; pane_productLayout . setHorizontalGroup ( pane_productLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( pane_productLayout . createSequentialGroup ( ) . addContainerGap ( ) . addGroup ( pane_productLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( pane_productLayout . createSequentialGroup ( ) . addComponent ( jLabel5 ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addComponent ( edt_filterproduct , javax . swing . GroupLayout . DEFAULT_SIZE , 785 , short . MAX_VALUE ) ) . addComponent ( scrollpane_product , javax . swing . GroupLayout . DEFAULT_SIZE , 813 , short . MAX_VALUE ) ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addComponent ( intf_product , javax . swing . GroupLayout . PREFERRED_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . PREFERRED_SIZE ) ) ) ; pane_productLayout . setVerticalGroup ( pane_productLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( pane_productLayout . createSequentialGroup ( ) . addContainerGap ( ) . addGroup ( pane_productLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addComponent ( intf_product , javax . swing . GroupLayout . DEFAULT_SIZE , 606 , short . MAX_VALUE ) . addGroup ( pane_productLayout . createSequentialGroup ( ) . addGroup ( pane_productLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . BASELINE ) . addComponent ( jLabel5 ) . addComponent ( edt_filterproduct , javax . swing . GroupLayout . PREFERRED_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . PREFERRED_SIZE ) ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addComponent ( scrollpane_product , javax . swing . GroupLayout . DEFAULT_SIZE , 580 , short . MAX_VALUE ) ) ) ) ) ; try { intf_product . setIcon ( true ) ; } catch ( java . beans . PropertyVetoException e1 ) { e1 . printStackTrace ( ) ; } Pane_Overview . addTab ( "Product" , pane_product ) ; table_history . setAutoCreateRowSorter ( true ) ; table_history . setAutoResizeMode ( javax . swing . JTable . AUTO_RESIZE_OFF ) ; table_history . setSelectionMode ( javax . swing . ListSelectionModel . SINGLE_SELECTION ) ; scrollpane_history . setViewportView ( table_history ) ; jLabel6 . setText ( "Filter" ) ; intf_history . setClosable ( true ) ; intf_history . setDefaultCloseOperation ( javax . swing . WindowConstants . DO_NOTHING_ON_CLOSE ) ; intf_history . setTitle ( "History" ) ; intf_history . setToolTipText ( "" ) ; intf_history . setMinimumSize ( new java . awt . Dimension ( 566 , 469 ) ) ; intf_history . setPreferredSize ( new java . awt . Dimension ( 566 , 469 ) ) ; intf_history . setVisible ( true ) ; txp_history . setBackground ( new java . awt . Color ( 204 , 204 , 204 ) ) ; txp_history . setContentType ( "text/html" ) ; txp_history . setEditable ( false ) ; txp_history . setText ( "" ) ; txp_history . setMinimumSize ( new java . awt . Dimension ( 200 , 600 ) ) ; txp_history . setName ( "" ) ; txp_history . setPreferredSize ( new java . awt . Dimension ( 300 , 1000 ) ) ; scrollpane_his . setViewportView ( txp_history ) ; javax . swing . GroupLayout intf_historyLayout = new javax . swing . GroupLayout ( intf_history . getContentPane ( ) ) ; intf_history . getContentPane ( ) . setLayout ( intf_historyLayout ) ; intf_historyLayout . setHorizontalGroup ( intf_historyLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addComponent ( scrollpane_his , javax . swing . GroupLayout . Alignment . TRAILING , javax . swing . GroupLayout . DEFAULT_SIZE , 550 , short . MAX_VALUE ) ) ; intf_historyLayout . setVerticalGroup ( intf_historyLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addComponent ( scrollpane_his , javax . swing . GroupLayout . DEFAULT_SIZE , 577 , short . MAX_VALUE ) ) ; javax . swing . GroupLayout pane_historyLayout = new javax . swing . GroupLayout ( pane_history ) ; pane_history . setLayout ( pane_historyLayout ) ; pane_historyLayout . setHorizontalGroup ( pane_historyLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( pane_historyLayout . createSequentialGroup ( ) . addContainerGap ( ) . addGroup ( pane_historyLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( pane_historyLayout . createSequentialGroup ( ) . addComponent ( jLabel6 ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addComponent ( edt_filtertickethis , javax . swing . GroupLayout . DEFAULT_SIZE , 785 , short . MAX_VALUE ) ) . addComponent ( scrollpane_history , javax . swing . GroupLayout . Alignment . TRAILING , javax . swing . GroupLayout . DEFAULT_SIZE , 813 , short . MAX_VALUE ) ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addComponent ( intf_history , javax . swing . GroupLayout . PREFERRED_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . PREFERRED_SIZE ) ) ) ; pane_historyLayout . setVerticalGroup ( pane_historyLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( pane_historyLayout . createSequentialGroup ( ) . addContainerGap ( ) . addGroup ( pane_historyLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addComponent ( intf_history , javax . swing . GroupLayout . DEFAULT_SIZE , 606 , short . MAX_VALUE ) . addGroup ( pane_historyLayout . createSequentialGroup ( ) . addGroup ( pane_historyLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . BASELINE ) . addComponent ( jLabel6 ) . addComponent ( edt_filtertickethis , javax . swing . GroupLayout . PREFERRED_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . PREFERRED_SIZE ) ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addComponent ( scrollpane_history , javax . swing . GroupLayout . DEFAULT_SIZE , 580 , short . MAX_VALUE ) ) ) ) ) ; try { intf_history . setIcon ( true ) ; } catch ( java . beans . PropertyVetoException e1 ) { e1 . printStackTrace ( ) ; } Pane_Overview . addTab ( "Ticket History" , pane_history ) ; menuBar . setNextFocusableComponent ( btn_addeditC ) ; fileMenu . setMnemonic ( KeyEvent . VK_ALT ) ; fileMenu . setText ( "File" ) ; fileMenu . setToolTipText ( "" ) ; fileMenu . setContentAreaFilled ( false ) ; fileMenu . setNextFocusableComponent ( btn_addeditC ) ; menu_new . setText ( "New" ) ; menu_customer . setText ( "Add Customer" ) ; menu_new . add ( menu_customer ) ; menu_customer . getAccessibleContext ( ) . setAccessibleParent ( menu_new ) ; menu_employee . setText ( "Add Employee" ) ; menu_new . add ( menu_employee ) ; menu_employee . getAccessibleContext ( ) . setAccessibleParent ( menu_new ) ; menu_product . setText ( "Add Product" ) ; menu_new . add ( menu_product ) ; menu_product . getAccessibleContext ( ) . setAccessibleParent ( menu_new ) ; menu_ticket . setText ( "Add Ticket" ) ; menu_new . add ( menu_ticket ) ; menu_ticket . getAccessibleContext ( ) . setAccessibleParent ( menu_new ) ; fileMenu . add ( menu_new ) ; menu_new . getAccessibleContext ( ) . setAccessibleParent ( fileMenu ) ; menu_quit . setText ( "Quit" ) ; fileMenu . add ( menu_quit ) ; menu_quit . getAccessibleContext ( ) . setAccessibleParent ( fileMenu ) ; menuBar . add ( fileMenu ) ; fileMenu . getAccessibleContext ( ) . setAccessibleParent ( null ) ; setJMenuBar ( menuBar ) ; javax . swing . GroupLayout layout = new javax . swing . GroupLayout ( getContentPane ( ) ) ; getContentPane ( ) . setLayout ( layout ) ; layout . setHorizontalGroup ( layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( javax . swing . GroupLayout . Alignment . TRAILING , layout . createSequentialGroup ( ) . addContainerGap ( ) . addGroup ( layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . TRAILING ) . addGroup ( javax . swing . GroupLayout . Alignment . LEADING , layout . createSequentialGroup ( ) . addGroup ( layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING , false ) . addComponent ( intf_mycontrol , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , short . MAX_VALUE ) . addComponent ( intf_fcontrol , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , short . MAX_VALUE ) ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addComponent ( Pane_Overview , javax . swing . GroupLayout . DEFAULT_SIZE , 1400 , short . MAX_VALUE ) ) . addGroup ( layout . createSequentialGroup ( ) . addGroup ( layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . TRAILING , false ) . addComponent ( jSeparator1 , javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( javax . swing . GroupLayout . Alignment . LEADING , layout . createSequentialGroup ( ) . addComponent ( btn_addeditC , javax . swing . GroupLayout . PREFERRED_SIZE , 90 , javax . swing . GroupLayout . PREFERRED_SIZE ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . UNRELATED ) . addComponent ( btn_addeditE , javax . swing . GroupLayout . PREFERRED_SIZE , 90 , javax . swing . GroupLayout . PREFERRED_SIZE ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . UNRELATED ) . addComponent ( btn_addeditP , javax . swing . GroupLayout . PREFERRED_SIZE , 90 , javax . swing . GroupLayout . PREFERRED_SIZE ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . UNRELATED ) . addComponent ( btn_addeditT , javax . swing . GroupLayout . PREFERRED_SIZE , 90 , javax . swing . GroupLayout . PREFERRED_SIZE ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . UNRELATED ) . addComponent ( btn_refresh , javax . swing . GroupLayout . PREFERRED_SIZE , 90 , javax . swing . GroupLayout . PREFERRED_SIZE ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . UNRELATED ) . addComponent ( btn_max , javax . swing . GroupLayout . PREFERRED_SIZE , 90 , javax . swing . GroupLayout . PREFERRED_SIZE ) ) ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED , 686 , short . MAX_VALUE ) . addComponent ( Logo , javax . swing . GroupLayout . PREFERRED_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . PREFERRED_SIZE ) ) ) . addContainerGap ( ) ) ) ; layout . setVerticalGroup ( layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( layout . createSequentialGroup ( ) . addContainerGap ( ) . addGroup ( layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( layout . createSequentialGroup ( ) . addGroup ( layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addComponent ( btn_addeditC , javax . swing . GroupLayout . PREFERRED_SIZE , 65 , javax . swing . GroupLayout . PREFERRED_SIZE ) . addComponent ( btn_addeditE , javax . swing . GroupLayout . PREFERRED_SIZE , 65 , javax . swing . GroupLayout . PREFERRED_SIZE ) . addComponent ( btn_addeditP , javax . swing . GroupLayout . PREFERRED_SIZE , 65 , javax . swing . GroupLayout . PREFERRED_SIZE ) . addComponent ( btn_addeditT , javax . swing . GroupLayout . PREFERRED_SIZE , 65 , javax . swing . GroupLayout . PREFERRED_SIZE ) . addComponent ( btn_refresh , javax . swing . GroupLayout . PREFERRED_SIZE , 65 , javax . swing . GroupLayout . PREFERRED_SIZE ) . addComponent ( btn_max , javax . swing . GroupLayout . PREFERRED_SIZE , 65 , javax . swing . GroupLayout . PREFERRED_SIZE ) ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addComponent ( jSeparator1 , javax . swing . GroupLayout . PREFERRED_SIZE , 11 , javax . swing . GroupLayout . PREFERRED_SIZE ) ) . addComponent ( Logo , javax . swing . GroupLayout . PREFERRED_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . PREFERRED_SIZE ) ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addGroup ( layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . TRAILING ) . addGroup ( layout . createSequentialGroup ( ) . addComponent ( intf_fcontrol , javax . swing . GroupLayout . PREFERRED_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . PREFERRED_SIZE ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addComponent ( intf_mycontrol , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , short . MAX_VALUE ) ) . addComponent ( Pane_Overview , javax . swing . GroupLayout . DEFAULT_SIZE , 645 , short . MAX_VALUE ) ) . addContainerGap ( ) ) ) ; try { intf_fcontrol . setIcon ( true ) ; } catch ( java . beans . PropertyVetoException e1 ) { e1 . printStackTrace ( ) ; } try { intf_mycontrol . setIcon ( true ) ; } catch ( java . beans . PropertyVetoException e1 ) { e1 . printStackTrace ( ) ; } pack ( ) ; }
tr	4	Vector < Integer > getCoil ( ) { int numCells = countCells ( ) ; Vector < Integer > result = new Vector < > ( numCells ) ; Util . initialize ( result , - 2 ) ; int i = 0 ; int j = 0 ; int ring = 0 ; while ( i < numCells ) { int index = tryToGetIndex ( ring , j ) ; if ( index >= 0 ) { result . set ( i , index ) ; i ++ ; } j = j + 1 ; if ( j >= 6 * ring ) { ring = ring + 1 ; j = 0 ; } if ( ring > numRows + numColumns ) { return result ; } } return result ; }
tr	7	@ Override public String getMCstring ( ) { String s = "" ; for ( int i = 0 ; i < mc . length ; i ++ ) { if ( mc [ i ] == true ) s = s . concat ( "1" ) ; else s = s . concat ( "0" ) ; if ( i == 5 || i == 10 || i == 15 || i == 20 || i == 25 ) s = s . concat ( " " ) ; } return s ; }
tr	2	protected static void handleRunImpulse ( ) { ImpulseDialog dialog = new ImpulseDialog ( mainWindow , true ) ; if ( dialog . getAnswer ( ) ) { double v1 = double . valueOf ( dialog . getVal1 ( ) . getText ( ) ) ; double p1 = double . valueOf ( dialog . getP1 ( ) . getText ( ) ) ; double v2 = double . valueOf ( dialog . getVal2 ( ) . getText ( ) ) ; double p2 = double . valueOf ( dialog . getP2 ( ) . getText ( ) ) ; boolean isSerial = boolean . valueOf ( dialog . getSerialGeneration ( ) . isSelected ( ) ) ; BufferedImage input = ( ( ContentPane ) mainWindow . getContentPane ( ) ) . getInput ( ) ; String title = ( ( ContentPane ) mainWindow . getContentPane ( ) ) . getInputTitle ( ) ; if ( isSerial ) { int numberOfPictures = Integer . valueOf ( dialog . getNumberOfPictures ( ) . getText ( ) ) ; double v1Step = double . valueOf ( dialog . getVal1Step ( ) . getText ( ) ) ; double p1Step = double . valueOf ( dialog . getP1Step ( ) . getText ( ) ) ; double v2Step = double . valueOf ( dialog . getVal2Step ( ) . getText ( ) ) ; double p2Step = double . valueOf ( dialog . getP2Step ( ) . getText ( ) ) ; Controller . generateImpulseNoise ( input , title , p1 , ( int ) v1 , p2 , ( int ) v2 , numberOfPictures , p1Step , ( int ) v1Step , p2Step , ( int ) v2Step ) ; } else { Controller . generateImpulseNoise ( input , title , p1 , ( int ) v1 , p2 , ( int ) v2 ) ; } } }
tr	3	public void shiftDown ( int btnval ) { System . out . println ( "Shift Down Button pressed" ) ; GrandView grand = ( GrandView ) getSuperview ( ) ; LevelView level = grand . getLevel ( ) ; level . setLevelY ( level . getLevelY ( ) - 40 ) ; level . refactorLocations ( 0 , - 40 ) ; for ( int i = 0 ; i < getSubviews ( ) . size ( ) ; i ++ ) if ( getSubviews ( ) . get ( i ) instanceof Button ) { Button temp = ( Button ) getSubviews ( ) . get ( i ) ; if ( temp . getIndex ( ) == btnval ) temp . setSelected ( false ) ; } }
tr	5	public static List < Trends > constructTrendsList ( Response res ) throws WeiboException { JSONObject json = res . asJSONObject ( ) ; List < Trends > trends ; try { Date asOf = parseDate ( json . getString ( "as_of" ) ) ; JSONObject trendsJson = json . getJSONObject ( "trends" ) ; trends = new ArrayList < Trends > ( trendsJson . length ( ) ) ; Iterator ite = trendsJson . keys ( ) ; while ( ite . hasNext ( ) ) { String key = ( String ) ite . next ( ) ; JSONArray array = trendsJson . getJSONArray ( key ) ; Trend [ ] trendsArray = jsonArrayToTrendArray ( array ) ; if ( key . length ( ) == 19 ) { trends . add ( new Trends ( res , asOf , parseDate ( key , "yyyy-MM-dd HH:mm:ss" ) , trendsArray ) ) ; } else if ( key . length ( ) == 16 ) { trends . add ( new Trends ( res , asOf , parseDate ( key , "yyyy-MM-dd HH:mm" ) , trendsArray ) ) ; } else if ( key . length ( ) == 10 ) { trends . add ( new Trends ( res , asOf , parseDate ( key , "yyyy-MM-dd" ) , trendsArray ) ) ; } } Collections . sort ( trends ) ; return trends ; } catch ( JSONException jsone ) { throw new WeiboException ( jsone . getMessage ( ) + ":" + res . asString ( ) , jsone ) ; } }
tr	4	public int dittoHelper ( DataHolder dataholderHandler , int sentenceID , String sentence , String nPhrasePattern , String mPhrasePattern ) { int res = 0 ; String sentenceCopy = "" + sentence ; sentenceCopy = sentenceCopy . replaceAll ( "></?" , "" ) ; String modifier = "" ; Matcher m2 = StringUtility . createMatcher ( sentenceCopy , "(.*?)" + nPhrasePattern ) ; if ( ! StringUtility . isMatchedNullSafe ( sentence , "<[NO]>" ) ) { String tag = "ditto" ; dataholderHandler . tagSentenceWithMT ( sentenceID , sentence , "" , tag , "ditto-no-N" ) ; res = 1 ; } else if ( m2 . find ( ) ) { String head = m2 . group ( 1 ) ; String pattern21 = String . format ( "\\b(%s)\\b" , this . myLearnerUtility . getConstant ( ) . PREPOSITION ) ; if ( StringUtility . isMatchedNullSafe ( head , pattern21 ) ) { String tag = "ditto" ; dataholderHandler . tagSentenceWithMT ( sentenceID , sentence , modifier , tag , "ditto-proposition" ) ; res = 21 ; } else if ( StringUtility . isMatchedNullSafe ( head , " <\\/B>\\s*$" ) ) { String tag = "ditto" ; dataholderHandler . tagSentenceWithMT ( sentenceID , sentence , modifier , tag , "ditto- -N" ) ; res = 22 ; } } return res ; }
tr	4	public String exec ( String command_string , String [ ] env , byte [ ] requestBuf ) { StringBuffer display_text = new StringBuffer ( ) ; String out = "" ; try { String shell = defaultShellField . getText ( ) ; Process proc = null ; command_string = apply_macros ( command_string ) ; if ( System . getProperty ( "os.name" ) . toUpperCase ( ) . contains ( "WINDOWS" ) ) { String [ ] args = translateCommandline ( shell + " " + command_string ) ; proc = Runtime . getRuntime ( ) . exec ( args , env ) ; } else { String [ ] shell_pieces = shell . split ( "\\s+" ) ; String args [ ] = new String [ shell_pieces . length + 1 ] ; System . arraycopy ( shell_pieces , 0 , args , 0 , shell_pieces . length ) ; args [ args . length - 1 ] = command_string ; proc = Runtime . getRuntime ( ) . exec ( args , env ) ; } out = readOutput ( proc ) ; String err = readError ( proc ) ; proc . waitFor ( ) ; proc . destroy ( ) ; display_text . append ( "\n\n" + out + err ) ; appendToOutputArea ( display_text . toString ( ) ) ; } catch ( InterruptedException ex ) { Logger . getLogger ( FourthIdea . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( IOException ex ) { Logger . getLogger ( FourthIdea . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( Exception e ) { GizmoView . log ( e . toString ( ) ) ; } return out ; }
tr	3	@ Override public boolean equals ( Object obj ) { if ( obj == null ) { return false ; } if ( getClass ( ) != obj . getClass ( ) ) { return false ; } final FormadePagamento other = ( FormadePagamento ) obj ; if ( ! Objects . equals ( this . nome , other . nome ) ) { return false ; } return true ; }
