tr	6	@ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( ! ( o instanceof OAuthToken ) ) return false ; OAuthToken that = ( OAuthToken ) o ; if ( secretKeySpec != null ? ! secretKeySpec . equals ( that . secretKeySpec ) : that . secretKeySpec != null ) return false ; if ( ! token . equals ( that . token ) ) return false ; if ( ! tokenSecret . equals ( that . tokenSecret ) ) return false ; return true ; }
tr	8	public static File getRelativeFile ( File target , File base ) throws IOException { String [ ] baseComponents = base . getCanonicalPath ( ) . split ( Pattern . quote ( File . separator ) ) ; String [ ] targetComponents = target . getCanonicalPath ( ) . split ( Pattern . quote ( File . separator ) ) ; int index = 0 ; for ( ; index < targetComponents . length && index < baseComponents . length ; ++ index ) { if ( ! targetComponents [ index ] . equals ( baseComponents [ index ] ) ) break ; } StringBuilder result = new StringBuilder ( ) ; if ( index != baseComponents . length ) { for ( int i = index ; i < baseComponents . length ; ++ i ) result . append ( ".." + File . separator ) ; } for ( ; index < targetComponents . length ; ++ index ) result . append ( targetComponents [ index ] + File . separator ) ; if ( ! target . getPath ( ) . endsWith ( "/" ) && ! target . getPath ( ) . endsWith ( "\\" ) ) { result . delete ( result . length ( ) - File . separator . length ( ) , result . length ( ) ) ; } return new File ( result . toString ( ) ) ; }
tr	8	private static void showEAGsInCanvas ( RequirementGraph req_model , int visualization ) throws ScriptException { for ( AntiGoal ag : req_model . ag_elems ) { String element_id = AppleScript . drawArbitraryRequirementElement ( InfoEnum . eag_canvas_mapping . get ( req_model . getLayer ( ) ) , "All" , InfoEnum . reverse_req_elem_type_map . get ( InfoEnum . RequirementElementType . ANTI_GOAL . name ( ) ) , InfoEnum . NORMAL_SIZE , "{500 500}" , "0" , ag . getName ( ) , "0" , "1" ) ; ag . setId ( element_id ) ; if ( visualization == InfoEnum . HIGHLIGHT_VIEW && ag . isCriticality ( ) ) { AppleScript . changeAttributeOfElement ( InfoEnum . eag_canvas_mapping . get ( req_model . getLayer ( ) ) , "none" , element_id , "5" , "Red" , "Simple" ) ; } else if ( visualization == InfoEnum . HIGHLIGHT_VIEW && ag . getRemark ( ) . equals ( InfoEnum . ElementRemark . BESTPATH . name ( ) ) ) { AppleScript . changeAttributeOfElement ( InfoEnum . esg_canvas_mapping . get ( req_model . getLayer ( ) ) , "none" , element_id , "5" , "Blue" , "Simple" ) ; } } for ( RequirementLink rl : req_model . ag_links ) { String link_id = AppleScript . drawExhaustiveRefinementLink ( rl ) ; rl . setId ( link_id ) ; AppleScript . changeAttributeOfLink ( InfoEnum . eag_canvas_mapping . get ( rl . getSource ( ) . getLayer ( ) ) , "none" , rl . getId ( ) , "1" , "none" , "All" ) ; if ( visualization == InfoEnum . HIGHLIGHT_VIEW && rl . getRemark ( ) . equals ( InfoEnum . LinkRemark . BESTPATH . name ( ) ) ) { AppleScript . changeAttributeOfLink ( InfoEnum . eag_canvas_mapping . get ( rl . getSource ( ) . getLayer ( ) ) , "none" , rl . getId ( ) , "3" , "Blue" , "Simple" ) ; } } }
tr	7	public static CharacterMatcher newCharacterMatcher ( BitSet characterSet ) { if ( characterSet . isEmpty ( ) ) return new CharacterMatcher ( ) { @ Override public boolean match ( int c ) { return false ; } @ Override public String toString ( ) { return "()" ; } } ; if ( characterSet . nextClearBit ( 0 ) == 110000 ) return new CharacterMatcher ( ) { @ Override public boolean match ( int c ) { return true ; } @ Override public String toString ( ) { return "(0-10ffff)" ; } } ; LinkedList < CharacterMatcher > result = new LinkedList < > ( ) ; LinkedList < Integer > set = null ; for ( int i = characterSet . nextSetBit ( 0 ) ; i >= 0 ; i = characterSet . nextSetBit ( i + 1 ) ) { int j = characterSet . nextClearBit ( i ) ; if ( ( j - i ) > 1 ) { if ( set != null ) { result . add ( toCharMatcher ( set ) ) ; set = null ; } result . add ( new RangeMatcher ( i , j - 1 ) ) ; i = j ; } else { if ( set == null ) set = new LinkedList < > ( ) ; set . add ( i ) ; } } if ( set != null ) result . add ( toCharMatcher ( set ) ) ; return compose ( result ) ; }
tr	1	public ClientCode ( ) { setBounds ( 20 , 20 , 600 , 180 ) ; setVisible ( true ) ; setDefaultCloseOperation ( DISPOSE_ON_CLOSE ) ; handler = new ButtonHandler ( ) ; getcontainer ( ) ; String result = JOptionPane . showInputDialog ( message ) ; try { socket = new Socket ( result , 8765 ) ; socket1 = new Socket ( result , 8766 ) ; getconnected ( ) ; } catch ( Exception e ) { } }
tr	6	static public boolean openFile ( Object obj ) { File f = coerceFile ( obj ) ; if ( f == null ) { return false ; } else if ( WIN && f . isDirectory ( ) ) { try { Process proc = Runtime . getRuntime ( ) . exec ( "explorer /root " + f . getAbsolutePath ( ) ) ; try { proc . waitFor ( ) ; } catch ( InterruptedException stfu ) { } return true ; } catch ( IOException err ) { return false ; } } else { try { Desktop . getDesktop ( ) . open ( f ) ; return true ; } catch ( Exception err ) { return false ; } } }
tr	9	private Map < String , List < String >> decodeParams ( String s ) { Map < String , List < String >> params = new LinkedHashMap < String , List < String >> ( ) ; String name = null ; int pos = 0 ; int i ; char c = 0 ; for ( i = 0 ; i < s . length ( ) ; i ++ ) { c = s . charAt ( i ) ; if ( c == = && name == null ) { if ( pos != i ) { name = decodeComponent ( s . substring ( pos , i ) , charset ) ; } pos = i + 1 ; } else if ( c == & ) { if ( name == null && pos != i ) { addParam ( params , decodeComponent ( s . substring ( pos , i ) , charset ) , "" ) ; } else if ( name != null ) { addParam ( params , name , decodeComponent ( s . substring ( pos , i ) , charset ) ) ; name = null ; } pos = i + 1 ; } } if ( pos != i ) { if ( name == null ) { addParam ( params , decodeComponent ( s . substring ( pos , i ) , charset ) , "" ) ; } else { addParam ( params , name , decodeComponent ( s . substring ( pos , i ) , charset ) ) ; } } else if ( name != null ) { addParam ( params , name , "" ) ; } return params ; }
tr	4	public void update ( final long newCurrent , final String optStatus ) { if ( this . upperLimit == - 1 ) { throw new IllegalArgumentException ( "This progress printer has not been initialized" ) ; } this . ownPos = newCurrent ; long sumOfSubProgresses = 0 ; this . currentPos = 0 ; for ( final ProgressPrinter subProgress : this . subProgress . keySet ( ) ) { double percentFinishedSubProgress = subProgress . getPercent ( ) / 100.0 ; long totalNumberStepsSubProgress = this . subProgress . get ( subProgress ) ; this . currentPos += ( percentFinishedSubProgress * totalNumberStepsSubProgress ) ; sumOfSubProgresses += totalNumberStepsSubProgress ; } final long remainingPart = this . upperLimit - sumOfSubProgresses ; if ( remainingPart < 0 ) { throw new IllegalArgumentException ( "Invalid part-sums of sub progresses" ) ; } this . currentPos += this . ownPos ; final float newPercent = this . currentPos > 0 ? ( ( float ) ( this . currentPos ) / this . upperLimit * 100.0f ) : 0.0f ; this . optStatus = optStatus ; this . % = newPercent ; this . fireChangeListener ( ) ; }
tr	2	@ Override public void defaultTick ( ) { Mob m = getMobInRadius ( radius ) ; if ( m != null ) { lookAtInstance ( m ) ; if ( shootTimer > 0 ) { shootTimer -= 1 ; } else { isShooting = true ; shoot ( direction , 7 ) ; shootTimer = SHOOT_TIME ; } } else { isShooting = false ; } }
tr	1	public static void update ( ) { for ( String key : settings . keySet ( ) ) { settings . get ( key ) . update ( ) ; } }
tr	0	@ ManyToOne ( fetch = FetchType . LAZY ) @ JoinColumn ( name = "mg_id" , nullable = false ) public MappingGroup getMappingGroup ( ) { return this . mappingGroup ; }
tr	9	public int divide ( int dividend , int divisor ) { if ( divisor == 0 || ( dividend == Integer . MIN_VALUE && divisor == - 1 ) ) { return Integer . MAX_VALUE ; } boolean negative = false ; if ( dividend < 0 ) { negative = ! negative ; } else { dividend = - dividend ; } if ( divisor < 0 ) { negative = ! negative ; } else { divisor = - divisor ; } int ret = 0 ; int bits = - 1 ; for ( int i = divisor ; i > dividend >> 1 ; i <<= 1 ) { bits ++ ; } if ( bits == - 1 && dividend <= divisor ) { bits = 0 ; } while ( bits >= 0 ) { int subtractor = divisor << bits ; while ( dividend <= subtractor ) { dividend -= subtractor ; ret += 1 << bits ; } bits -- ; } return negative ? - ret : ret ; }
tr	4	public static TMDrillModel TMgetAllTweetsByKeyword ( String keywords ) { ArrayList < tweetModel > results = new ArrayList < tweetModel > ( ) ; tweetModel t ; TMDrillModel tmDrillModel = new TMDrillModel ( ) ; String tablename = "temp-" + keywords ; tablename = tablename . replaceAll ( " " , "|" ) ; tablename = tablename . replaceAll ( ";" , "|" ) ; tablename = tablename . replaceAll ( " " , "" ) ; System . out . println ( tablename ) ; keywords = keywords . replaceAll ( " " , "%' and message like '%" ) ; keywords = keywords . replaceAll ( ";" , "%' or message like '%" ) ; System . out . println ( keywords ) ; try { Connection c = DBFactory . getConnection ( ) ; PreparedStatement ps = c . prepareStatement ( "DROP TABLE IF EXISTS `" + tablename + "`; " ) ; ps . execute ( ) ; System . out . println ( ps ) ; ps = c . prepareStatement ( "CREATE TABLE `" + tablename + "` (" + "`username` varchar(20) NOT NULL " + "`date` varchar(30) NOT NULL " + "`message` varchar(180) NOT NULL" + ")ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;" ) ; ps . execute ( ) ; System . out . println ( ps ) ; ps = c . prepareStatement ( "INSERT INTO `" + tablename + "` (username  date  message) " + "SELECT username  date  message FROM `tweets` " + "WHERE message like '%" + keywords + "%';" ) ; ps . execute ( ) ; System . out . println ( ps ) ; ps = c . prepareStatement ( "SELECT * from `" + tablename + "`;" ) ; ResultSet rs = ps . executeQuery ( ) ; while ( rs . next ( ) ) { t = new tweetModel ( ) ; t . setUsername ( rs . getString ( "username" ) ) ; t . setDate ( rs . getString ( "date" ) ) ; t . setMessage ( cleanTweet ( rs . getString ( "message" ) ) ) ; results . add ( t ) ; } rs . close ( ) ; ps . close ( ) ; c . close ( ) ; System . out . println ( "******************************* " ) ; TopicModel tm = new TopicModel ( ) ; if ( results . isEmpty ( ) ) { tmDrillModel = new TMDrillModel ( - 1 ) ; } else { tm . importData ( results ) ; tm . trainTopics ( ) ; tmDrillModel = new TMDrillModel ( 0 , tablename , tm . getAllTopics ( ) ) ; } } catch ( ClassNotFoundException ex ) { Logger . getLogger ( tweetHandler . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( SQLException ex ) { Logger . getLogger ( tweetHandler . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } return tmDrillModel ; }
tr	5	private int findShortestPath ( ) throws IllegalStateException { int min = Integer . MAX_VALUE ; for ( int i = 1 ; i <= graph . V ( ) ; i ++ ) { for ( int j = 1 ; j <= graph . V ( ) ; j ++ ) { if ( i == j && d [ i ] [ j ] [ graph . V ( ) ] < 0 ) { throw new IllegalStateException ( "Negative cycle!" ) ; } if ( d [ i ] [ j ] [ graph . V ( ) ] < min ) { min = d [ i ] [ j ] [ graph . V ( ) ] ; } } } return min ; }
tr	9	public List < Node > findPath ( Vector2i start , Vector2i finish ) { List < Node > openList = new ArrayList < Node > ( ) ; List < Node > closedList = new ArrayList < Node > ( ) ; Node current = new Node ( start , null , 0 , start . getDistance ( finish ) ) ; openList . add ( current ) ; int iterations = 0 ; while ( openList . size ( ) > 0 ) { if ( iterations > 100 ) { break ; } iterations ++ ; Collections . sort ( openList , nodeSort ) ; current = openList . get ( 0 ) ; openList . remove ( current ) ; if ( current . tile . equals ( finish ) ) { List < Node > path = new ArrayList < Node > ( ) ; while ( current . parent != null ) { path . add ( current ) ; current = current . parent ; } openList . clear ( ) ; closedList . clear ( ) ; return path ; } else { closedList . add ( current ) ; int cX = current . tile . getX ( ) ; int cY = current . tile . getY ( ) ; for ( int i = 0 ; i < 9 ; i ++ ) { if ( i == 4 ) { continue ; } int nbX = ( i % 3 ) - 1 ; int nbY = ( i / 3 ) - 1 ; if ( getTile ( cX + nbX , cY + nbY ) == null || getTile ( cX + nbX , cY + nbY ) . isSolid ( ) ) { continue ; } Vector2i nbV = new Vector2i ( cX + nbX , cY + nbY ) ; if ( getNodeFromList ( nbV , closedList ) != null ) { continue ; } double gCost = current . gCost + current . tile . getDistance ( nbV ) ; Node nbN = getNodeFromList ( nbV , openList ) ; if ( nbN == null || nbN . gCost > gCost ) { double hCost = nbV . getDistance ( finish ) ; if ( nbN != null ) { nbN . parent = current ; nbN . gCost = gCost ; nbN . hCost = hCost ; nbN . fCost = gCost + hCost ; } else { nbN = new Node ( nbV , current , gCost , hCost ) ; openList . add ( nbN ) ; } } } } } closedList . clear ( ) ; return null ; }
tr	9	public void initOpenedXMLTree ( NodeList childEls , Point parentPoint ) { try { Runnable r = new Runnable ( ) { NodeList childEls ; Point pt ; public void setArgs ( NodeList childEls , Point p ) { this . childEls = childEls ; pt = p ; } public void run ( ) { vxd . controller . refreshXMLViews ( ) ; try { Runnable r = new Runnable ( ) { NodeList childEls ; Point grandPoint ; public void setArgs ( NodeList childEls , Point p ) { this . childEls = childEls ; grandPoint = p ; } public void run ( ) { for ( int l = 0 ; l < childEls . getLength ( ) ; ++ l ) { Node childNd = childEls . item ( l ) ; if ( childNd instanceof Element ) { Element childEl = ( Element ) childNd ; if ( vxd . DEBUG ) System . out . println ( "Child: " + childEl . getTagName ( ) ) ; vxd . controller . addLoadedElementIcon ( childEl , grandPoint . x , grandPoint . y ) ; try { Runnable r = new Runnable ( ) { Element childEl ; public void setArgs ( Element childEl ) { this . childEl = childEl ; } public void run ( ) { NodeList grandEls = childEl . getChildNodes ( ) ; if ( childEl . getAttribute ( "XPos" ) != null && childEl . getAttribute ( "YPos" ) != null ) { try { int x = Integer . parseInt ( childEl . getAttribute ( "XPos" ) ) ; int y = Integer . parseInt ( childEl . getAttribute ( "YPos" ) ) ; Point greatPoint = new Point ( x , y ) ; initOpenedXMLTree ( grandEls , greatPoint ) ; } catch ( NumberFormatException nfe ) { ; } } } } ; class [ ] args = new class [ 1 ] ; args [ 0 ] = Element . class ; Object [ ] prms = new Object [ 1 ] ; prms [ 0 ] = childEl ; r . getClass ( ) . getMethod ( "setArgs" , args ) . invoke ( r , prms ) ; SwingUtilities . invokeLater ( r ) ; } catch ( Exception grgdex ) { grgdex . printStackTrace ( ) ; } } } } } ; class [ ] args = new class [ 2 ] ; args [ 0 ] = NodeList . class ; args [ 1 ] = Point . class ; Object [ ] prms = new Object [ 2 ] ; prms [ 0 ] = childEls ; prms [ 1 ] = pt ; r . getClass ( ) . getMethod ( "setArgs" , args ) . invoke ( r , prms ) ; SwingUtilities . invokeLater ( r ) ; } catch ( Exception rex ) { rex . printStackTrace ( ) ; } ; } } ; class [ ] args = new class [ 2 ] ; args [ 0 ] = NodeList . class ; args [ 1 ] = Point . class ; Object [ ] prms = new Object [ 2 ] ; prms [ 0 ] = childEls ; prms [ 1 ] = parentPoint ; r . getClass ( ) . getMethod ( "setArgs" , args ) . invoke ( r , prms ) ; SwingUtilities . invokeLater ( r ) ; } catch ( Exception rex ) { rex . printStackTrace ( ) ; } }
tr	3	private void checkBoxCollisions ( ) { for ( ImageView r : model . getBoxes ( ) ) { if ( r . isVisible ( ) && ball . intersects ( r . getBoundsInParent ( ) ) ) { model . getBoxesLeft ( ) . set ( model . getBoxesLeft ( ) . get ( ) - 1 ) ; r . setVisible ( false ) ; } } }
tr	2	@ Override public void run ( ) { while ( this . Console . isVisible ( ) ) { try { this . Console . ConsoleArea . setCaretPosition ( this . Console . ConsoleArea . getDocument ( ) . getLength ( ) ) ; } catch ( IllegalArgumentException e ) { this . Console . ConsoleArea . SetText ( "" ) ; this . Console . ConsoleArea . setCaretPosition ( 0 ) ; } } }
tr	2	public void preorderPositions ( Position < E > v , List < Position < E >> pos ) throws InvalidPositionException { pos . add ( v ) ; if ( hasLeft ( v ) ) { preorderPositions ( left ( v ) , pos ) ; } if ( hasRight ( v ) ) { preorderPositions ( right ( v ) , pos ) ; } }
tr	2	private static int findSmallest ( int remA , int remB , int remC ) { int smallest = remC ; if ( remB <= smallest ) { smallest = remB ; } if ( remA <= smallest ) { smallest = remA ; } return smallest ; }
tr	3	private static char getNrMinesCornerCase ( char [ ] [ ] m , int r , int c , int rAdjInd , int cAdjInd ) { int n = 0 ; if ( m [ r ] [ c + cAdjInd ] == MINE ) { n ++ ; } if ( m [ r + rAdjInd ] [ c ] == MINE ) { n ++ ; } if ( m [ r + rAdjInd ] [ c + cAdjInd ] == MINE ) { n ++ ; } return ( char ) ( 0 + n ) ; }
tr	6	@ SuppressWarnings ( "static-access" ) private void randomJoueur ( ) { Thread th ; for ( int i = 1 ; i < 2 ; i ++ ) { indexTabI = ( int ) ( Math . random ( ) * ( ( ie . tab . length ) - 0 ) + 0 ) ; indexTabJ = ( int ) ( Math . random ( ) * ( ( ie . tab . length ) - 0 ) + 0 ) ; salleRandomJoueur = InterfaceEditeur . tab [ indexTabI ] [ indexTabJ ] ; if ( salleRandomJoueur . verifierAccessible ( ) && ! salleRandomJoueur . verifierSortie ( ) && salleRandomJoueur . perso_dans_salle . isEmpty ( ) && ! persoJoueur . getPresent ( ) ) { salleRandomJoueur . entreePerso ( persoJoueur ) ; th = new Thread ( this ) ; th . start ( ) ; } else if ( persoJoueur . getPresent ( ) ) { th = new Thread ( this ) ; th . start ( ) ; } else { i -- ; } } }
tr	4	protected void init ( ) { String handlerPkgs = System . getProperty ( "java.protocol.handler.pkgs" ) ; if ( ( handlerPkgs != null ) && ! ( handlerPkgs . isEmpty ( ) ) ) { handlerPkgs = handlerPkgs + "|com.sun.net.ssl.internal.www.protocol" ; } else { handlerPkgs = "com.sun.net.ssl.internal.www.protocol" ; } System . setProperty ( "java.protocol.handler.pkgs" , handlerPkgs ) ; java . security . Security . addProvider ( new com . sun . net . ssl . internal . ssl . Provider ( ) ) ; if ( swingBoxEditorKit == null ) { swingBoxEditorKit = new SwingBoxEditorKit ( ) ; } setEditable ( false ) ; setContentType ( "text/html" ) ; activateTooltip ( true ) ; ^ ^ = getCaret ( ) ; if ( ^ instanceof DefaultCaret ) ( ( DefaultCaret ) ^ ) . setUpdatePolicy ( DefaultCaret . NEVER_UPDATE ) ; }
tr	9	@ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; Option option = ( Option ) o ; if ( idoption != option . idoption ) return false ; if ( surveyIdsurvey != option . surveyIdsurvey ) return false ; if ( content != null ? ! content . equals ( option . content ) : option . content != null ) return false ; if ( number != null ? ! number . equals ( option . number ) : option . number != null ) return false ; return true ; }
tr	3	@ Override public void print ( String pages , String extension , String fileName ) { if ( extension . equals ( "doc" ) ) { System . out . println ( "Printing documento doc with " + pages ) ; } else if ( extension . equals ( "pdf" ) || extension . equals ( "mdi" ) ) { printerAdapter = new PrinterWorkAdapter ( extension ) ; printerAdapter . print ( pages , extension , fileName ) ; } else { System . out . println ( "Extension not compatible" ) ; } }
tr	4	@ Override public int compare ( Match m1 , Match m2 ) { int score11 = participantCounts . get ( m1 . getParticipantA ( ) . getFirstName ( ) ) != null ? participantCounts . get ( m1 . getParticipantA ( ) . getFirstName ( ) ) : 0 ; int score12 = participantCounts . get ( m1 . getParticipantB ( ) . getFirstName ( ) ) != null ? participantCounts . get ( m1 . getParticipantB ( ) . getFirstName ( ) ) : 0 ; int score21 = participantCounts . get ( m2 . getParticipantA ( ) . getFirstName ( ) ) != null ? participantCounts . get ( m2 . getParticipantA ( ) . getFirstName ( ) ) : 0 ; int score22 = participantCounts . get ( m2 . getParticipantB ( ) . getFirstName ( ) ) != null ? participantCounts . get ( m2 . getParticipantB ( ) . getFirstName ( ) ) : 0 ; int score1 = score11 + score12 ; int score2 = score21 + score22 ; return score1 - score2 ; }
tr	2	public void resolveClick ( int x , int y ) { if ( x > columns * ( tileSizeX + HGAP ) - 1 ) { ZettaUtil . log ( "Scroll bar click!" ) ; if ( y < rows * tileSizeY / 2 ) { hiddenRows = Math . max ( hiddenRows - 1 , 0 ) ; } else { hiddenRows ++ ; } } else { int tileIndex = x / ( tileSizeX + HGAP ) + ( y / ( tileSizeY + VGAP ) + hiddenRows ) * columns ; this . selected = tileIndex ; this . selectionChanged ( ) ; } this . repaint ( ) ; }
tr	2	public boolean checkStatic ( ) { boolean result = true ; double [ ] values = getValues ( ) ; for ( int i = 0 ; i < values . length - 1 ; i ++ ) { if ( values [ i ] . doubleValue ( ) != values [ i + 1 ] . doubleValue ( ) ) { result = false ; break ; } } return result ; }
tr	8	@ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; PersistentVector < ? > other = ( PersistentVector < ? > ) obj ; if ( ls == null ) { if ( other . ls != null ) return false ; } else if ( ! ls . equals ( other . ls ) ) return false ; return true ; }
tr	9	private boolean testGateways ( Graph < Vertex , Edge > g ) { int openAND = 0 ; int closeAND = 0 ; for ( Vertex v : g . vertexSet ( ) ) { if ( v . isGateway ) { if ( v . getCorresponding ( ) == null && ! v . isXOR ) { if ( __DEBUG ) a . e . println ( "Didn't find a corresponding gate for " + v . toString ( ) ) ; return false ; } else { if ( ! v . isXOR ) if ( v . getCorresponding ( ) . getCorresponding ( ) . id . toString ( ) . compareTo ( v . id . toString ( ) ) != 0 ) { if ( __DEBUG ) a . e . println ( "Corresponding gate has been associated to something else " + v . toString ( ) + "; " + v . getCorresponding ( ) . toString ( ) ) ; if ( __DEBUG ) a . e . println ( "Corresponding gate has been associated to something else " + v . getCorresponding ( ) . toString ( ) + "; " + v . getCorresponding ( ) . getCorresponding ( ) . toString ( ) ) ; return false ; } } if ( g . inDegreeOf ( v ) > 1 ) closeAND ++ ; if ( g . outDegreeOf ( v ) > 1 ) openAND ++ ; } } if ( openAND == closeAND ) { return true ; } return false ; }
tr	9	@ Test public void shouldFailIfIpv4PartExceedsBounds ( ) { try { Ipv6 . parse ( "::400.2.3.4" ) ; fail ( ) ; } catch ( IllegalArgumentException ignored ) { } try { Ipv6 . parse ( "::260.2.3.4" ) ; fail ( ) ; } catch ( IllegalArgumentException ignored ) { } try { Ipv6 . parse ( "::256.2.3.4" ) ; fail ( ) ; } catch ( IllegalArgumentException ignored ) { } try { Ipv6 . parse ( "::1.256.3.4" ) ; fail ( ) ; } catch ( IllegalArgumentException ignored ) { } try { Ipv6 . parse ( "::1.2.256.4" ) ; fail ( ) ; } catch ( IllegalArgumentException ignored ) { } try { Ipv6 . parse ( "::1.2.256.256" ) ; fail ( ) ; } catch ( IllegalArgumentException ignored ) { } try { Ipv6 . parse ( "::300.2.3.4" ) ; fail ( ) ; } catch ( IllegalArgumentException ignored ) { } try { Ipv6 . parse ( "::1.300.3.4" ) ; fail ( ) ; } catch ( IllegalArgumentException ignored ) { } try { Ipv6 . parse ( "::1.2.300.4" ) ; fail ( ) ; } catch ( IllegalArgumentException ignored ) { } try { Ipv6 . parse ( "::1.2.3.300" ) ; fail ( ) ; } catch ( IllegalArgumentException ignored ) { } try { Ipv6 . parse ( "::256.256.256.256" ) ; fail ( ) ; } catch ( IllegalArgumentException ignored ) { } }
tr	7	private void verifyForeignKeyConstraints ( Tuple tuple ) throws DatabaseException { for ( Schema . ForeignKey fk : schema . getForeignKeys ( ) ) { Table refTable = fk . getRefTable ( ) ; int [ ] localKeyPositions = fk . getForeignKeyPositions ( ) ; Object [ ] localKeyValues = new Object [ localKeyPositions . length ] ; Attribute . Type [ ] localKeyTypes = new Attribute . Type [ localKeyPositions . length ] ; for ( int i = 0 ; i < localKeyPositions . length ; ++ i ) { localKeyValues [ i ] = tuple . getValueAt ( localKeyPositions [ i ] ) ; localKeyTypes [ i ] = schema . getAttributes ( ) [ localKeyPositions [ i ] ] . getType ( ) ; } int [ ] refKeyPositions = refTable . getSchema ( ) . getPrimaryKeyPositions ( ) ; boolean matchFound = false ; for ( Tuple refTuple : refTable . getTuples ( ) ) { matchFound = true ; for ( int i = 0 ; i < localKeyPositions . length ; ++ i ) { if ( ! Tuple . valuesEqual ( localKeyTypes [ i ] , localKeyValues [ i ] , refTuple . getValueAt ( refKeyPositions [ i ] ) ) ) { matchFound = false ; break ; } } if ( matchFound ) break ; } if ( ! matchFound ) { throw new DatabaseException ( "Referential constraint to table '" + refTable . getName ( ) + "' not met." ) ; } } }
tr	1	@ Override public Set < java . util . Map . Entry < K , V >> entrySet ( ) { if ( this . entrySet == null ) { this . entrySet = new EntrySet ( ) ; } return this . entrySet ; }
tr	8	public static File createFile ( File file ) throws Exception { File parent = file . getParentFile ( ) ; if ( ! parent . exists ( ) ) { List < File > dirs = new ArrayList < File > ( ) ; dirs . add ( parent ) ; while ( true ) { parent = parent . getParentFile ( ) ; if ( parent == null ) { break ; } if ( parent . exists ( ) ) { break ; } dirs . add ( parent ) ; } Collections . reverse ( dirs ) ; for ( File dir : dirs ) { if ( ! dir . mkdir ( ) ) { throw new Exception ( "Unable to create directory: " + dir ) ; } dir . setReadable ( true , true ) ; dir . setWritable ( true , true ) ; dir . setExecutable ( true , true ) ; } } if ( ! file . exists ( ) ) { if ( ! file . createNewFile ( ) ) { throw new Exception ( "Unable to create file: " + file ) ; } } file . setWritable ( true , true ) ; file . setReadable ( true , true ) ; return file ; }
tr	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( MainFrame . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( MainFrame . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( MainFrame . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( MainFrame . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { new MainFrame ( ) . setVisible ( true ) ; } } ) ; }
tr	7	public static List < Tile > loadMap ( String filename ) { ArrayList < String > lines = new ArrayList < String > ( ) ; int width = 0 ; InputStream is = MapLoader . class . getClassLoader ( ) . getResourceAsStream ( filename ) ; System . out . println ( is . toString ( ) ) ; BufferedReader reader = new BufferedReader ( new InputStreamReader ( is ) ) ; while ( true ) { String line ; try { line = reader . readLine ( ) ; if ( line == null ) { reader . close ( ) ; break ; } if ( ! line . startsWith ( "!" ) ) { lines . add ( line ) ; width = Math . max ( width , line . length ( ) ) ; } } catch ( IOException e ) { System . out . println ( e . getMessage ( ) ) ; System . out . println ( e ) ; } } List < Tile > tiles = new ArrayList < Tile > ( ) ; for ( int j = 0 ; j < 12 ; j ++ ) { String line = lines . get ( j ) ; for ( int i = 0 ; i < width ; i ++ ) { if ( i < line . length ( ) ) { char ch = line . charAt ( i ) ; Tile t = new Tile ( i , j , Character . getNumericValue ( ch ) ) ; tiles . add ( t ) ; } } } return tiles ; }
tr	1	public void registerComponent ( Component ... components ) { for ( Component component : components ) { registerComponent ( component ) ; } }
tr	8	public void connect1 ( TreeLinkNode root ) { if ( root == null ) return ; Queue < TreeLinkNode > curLev = new LinkedList < TreeLinkNode > ( ) ; curLev . add ( root ) ; while ( ! curLev . isEmpty ( ) ) { Queue < TreeLinkNode > nextLev = new LinkedList < TreeLinkNode > ( ) ; while ( ! curLev . isEmpty ( ) ) { TreeLinkNode cur = curLev . poll ( ) ; if ( cur . left != null ) nextLev . add ( cur . left ) ; if ( cur . right != null ) nextLev . add ( cur . right ) ; if ( ! curLev . isEmpty ( ) ) { TreeLinkNode curNext = curLev . peek ( ) ; if ( curNext . left != null ) nextLev . add ( cur . left ) ; if ( curNext . right != null ) nextLev . add ( cur . right ) ; cur . next = curNext ; } } curLev = nextLev ; } }
tr	5	public void setUser ( User newUser ) { if ( newUser == null || ( user != null && newUser . getID ( ) . equals ( user . getID ( ) ) ) ) return ; if ( ( newUser . lastLog == null ) || ( System . currentTimeMillis ( ) - newUser . lastLog . getTime ( ) ) > 600000 ) { newUser . logins ++ ; } mainFrame . setTitle ( "User: " + newUser . name + " - Logins: " + newUser . logins + " - LastLogin: " + TimeCalc . calcPrettyTime ( newUser . lastLog ) ) ; newUser . lastLog = new java . sql . Timestamp ( System . currentTimeMillis ( ) ) ; newUser . saveToDB ( ) ; this . user = newUser ; updateCorePhrases ( ) ; mainFrame . updateUserBtnText ( ) ; mainFrame . nextPhrase ( ) ; }
tr	0	public DepthFirstPaths ( Graph g , int s ) { marked = new boolean [ g . V ( ) ] ; edgeTo = new int [ g . V ( ) ] ; this . s = s ; dfs ( g , s ) ; }
tr	8	private boolean r_un_accent ( ) { int v_3 ; { int v_1 = 1 ; replab0 : while ( true ) { lab1 : do { if ( ! ( out_grouping_b ( g_v , 97 , 251 ) ) ) { break lab1 ; } v_1 -- ; continue replab0 ; } while ( false ) ; break replab0 ; } if ( v_1 > 0 ) { return false ; } } ket = cursor ; lab2 : do { v_3 = limit - cursor ; lab3 : do { if ( ! ( eq_s_b ( 1 , "\u00E9" ) ) ) { break lab3 ; } break lab2 ; } while ( false ) ; cursor = limit - v_3 ; if ( ! ( eq_s_b ( 1 , "\u00E8" ) ) ) { return false ; } } while ( false ) ; bra = cursor ; slice_from ( "e" ) ; return true ; }
tr	6	subMapIterator ( Coord startCoord , int rangeX , int rangeY ) { this . latoDellaMappaIterator = getLatoDellaMappa ( ) ; if ( ! ( 0 <= startCoord . getX ( ) ) || ! ( 0 <= startCoord . getY ( ) ) || ! ( startCoord . getX ( ) < latoDellaMappaIterator ) || ! ( startCoord . getY ( ) < latoDellaMappaIterator ) || ! ( 0 <= rangeX ) || ! ( 0 <= rangeY ) ) throw new IndexOutOfBoundsException ( ) ; this . startRow = startCoord . getY ( ) ; this . startColumn = startCoord . getX ( ) ; this . rowRange = rangeY ; this . columnRange = rangeX ; this . latoDellaMappaIterator = getLatoDellaMappa ( ) ; curCoord = new Coord ( startColumn , startRow ) ; }
tr	6	public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; int n = scan . nextInt ( ) ; while ( n != 0 ) { int [ ] code = new int [ n ] ; String decoded = "" ; for ( int i = 0 ; i < n ; i ++ ) code [ i ] = scan . nextInt ( ) ; String backcode = encode ( code , n - 5 , n ) ; backcode = new StringBuffer ( backcode ) . reverse ( ) . toString ( ) ; backcode = translate ( backcode ) ; String frontcode = encode ( code , 0 , 5 ) ; frontcode = translate ( frontcode ) ; if ( backcode . equals ( "start/stop" ) ) { code = reverse ( code ) ; decoded = decode ( code ) ; } else decoded = decode ( code ) ; for ( int a : code ) System . out . print ( a + " " ) ; System . out . println ( ) ; for ( int i = 0 ; i < n ; i ++ ) if ( i < 10 ) System . out . print ( " " + i + " " ) ; else System . out . print ( i + " " ) ; System . out . println ( ) ; System . out . println ( decoded ) ; n = scan . nextInt ( ) ; } }
tr	8	@ EventHandler ( priority = EventPriority . HIGHEST ) public void onServerListPingEvent ( ServerListPingEvent event ) { if ( getConfig ( ) . getBoolean ( "global.motd_enabled" ) ) { String motd = "&5" ; int maxSlots = 200 ; Player [ ] players = getServer ( ) . getOnlinePlayers ( ) ; motd_pre = getConfig ( ) . getString ( "global.motd_prefix" , "UFoH" ) ; motd_suf = getConfig ( ) . getString ( "global.motd_suffix" , "<-- 20% Bonus Size! (http://ufharmony.com)" ) ; motd += ( motd_pre == null ) ? event . getMotd ( ) : motd_pre ; motd += " &2[ " ; for ( Entry < String , Integer > slot : slotQue . entrySet ( ) ) { int online = 0 ; for ( Player p : players ) { if ( ! isStaff ( p ) && p . hasPermission ( "inations." + slot . getKey ( ) ) ) { online ++ ; players = ( Player [ ] ) ArrayUtils . removeElement ( players , p ) ; } } motd += slot . getKey ( ) . substring ( 0 , 1 ) . toUpperCase ( ) + online + "/" + slot . getValue ( ) + "  " ; maxSlots += slot . getValue ( ) ; } motd = motd + players . length + " ] " ; if ( motd_suf != null || ! motd_suf . isEmpty ( ) ) motd += StringUtils . repeat ( " " , 50 - motd . length ( ) ) + "&f" + motd_suf ; event . setMotd ( motd . replaceAll ( "(&([a-f0-9]))" , "\u00A7$2" ) ) ; event . setMaxPlayers ( maxSlots ) ; } }
tr	6	private static void replaceUnaryMinus ( ArrayList < String > parts ) { for ( int i = 0 ; i < parts . size ( ) ; i ++ ) { if ( parts . get ( i ) . equals ( "-" ) ) { if ( i == 0 ) { parts . set ( i , "_" ) ; } else { if ( isOperator ( parts . get ( i - 1 ) ) || parts . get ( i - 1 ) . equals ( "(" ) || parts . get ( i - 1 ) . equals ( " " ) ) { parts . set ( i , "_" ) ; } } } } }
tr	7	public ArrayList < ArrayList < Integer >> threeSum ( int [ ] num ) { HashMap < Integer , Integer > HM = new HashMap < Integer , Integer > ( ) ; HashMap < ArrayList < Integer > , Integer > HMList = new HashMap < ArrayList < Integer > , Integer > ( ) ; ArrayList < ArrayList < Integer >> reList = new ArrayList < ArrayList < Integer >> ( ) ; for ( int i = 0 ; i < num . length ; i ++ ) { if ( HM . containsKey ( num [ i ] ) ) HM . put ( num [ i ] , HM . get ( num [ i ] ) + 1 ) ; else HM . put ( num [ i ] , 1 ) ; } for ( int i = 0 ; i < num . length ; i ++ ) { HM . put ( num [ i ] , HM . get ( num [ i ] ) - 1 ) ; int first = num [ i ] ; for ( int j = i + 1 ; j < num . length ; j ++ ) { HM . put ( num [ j ] , HM . get ( num [ j ] ) - 1 ) ; int second = num [ j ] ; int third = 0 - first - second ; if ( HM . containsKey ( third ) && HM . get ( third ) > 0 ) { ArrayList < Integer > b = new ArrayList < Integer > ( ) ; b . add ( first ) ; b . add ( second ) ; b . add ( third ) ; Collections . sort ( b ) ; HMList . put ( b , 1 ) ; } HM . put ( num [ j ] , HM . get ( num [ j ] ) + 1 ) ; } HM . put ( num [ i ] , HM . get ( num [ i ] ) + 1 ) ; } for ( ArrayList < Integer > c : HMList . keySet ( ) ) { reList . add ( c ) ; } return reList ; }
tr	7	public static Packet read ( ByteBuffer buffer ) { byte packetId = buffer . get ( ) ; if ( packetId == ID_HELLO_PACKET ) return new HelloPacket ( buffer ) ; if ( packetId == ID_WORLD_UPDATE_PACKET ) return new WorldUpdatesPacket ( buffer ) ; if ( packetId == ID_WINDOW_PACKET ) return new WindowPacket ( buffer ) ; if ( packetId == ID_WORLD_REGION_PACKET ) return new WorldRegionPacket ( buffer ) ; if ( packetId == ID_ENTITIES_PACKET ) return new EntitiesPacket ( buffer ) ; if ( packetId == ID_DWARF_REQUEST_PACKET ) return new DwarfRequestPacket ( buffer ) ; if ( packetId == ID_PLAYER_UPDATE_PACKET ) return new PlayerUpdatePacket ( buffer ) ; throw new RuntimeException ( "Unknown packet id: " + packetId ) ; }
tr	0	public String getId ( ) { return id ; }
tr	1	public static String translate ( String fieldname ) { if ( fieldname == null ) fieldname = "" ; String key = String . format ( "Field.%s" , fieldname . toLowerCase ( ) ) ; String name = properties . getProperty ( key , fieldname ) ; return name ; }
tr	3	private void drawLines ( Graphics g , treeNode [ ] nodes ) { Graphics2D g2d = ( Graphics2D ) g ; g2d . setColor ( Color . black ) ; g2d . setStroke ( new BasicStroke ( LINE_THICKNESS ) ) ; for ( int i = 1 ; i < nodes . length ; i ++ ) { try { g2d . drawLine ( nodes [ i ] . CenterX , nodes [ i ] . CenterY , nodes [ 2 * i ] . CenterX , nodes [ 2 * i ] . CenterY ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { } try { g2d . drawLine ( nodes [ i ] . CenterX , nodes [ i ] . CenterY , nodes [ 2 * i + 1 ] . CenterX , nodes [ 2 * i + 1 ] . CenterY ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { } } }
tr	4	@ Override public void add ( E pdato , int index ) { if ( 0 > index || _lenght < index ) { throw new IndexOutOfBoundsException ( "Fuera de rango: " + index ) ; } else if ( index == 0 ) { addi ( pdato ) ; } else if ( index == _lenght ) { add ( pdato ) ; } else { NodeDouble < E > tmp = getIndex ( index ) ; NodeDouble < E > tmp2 = new NodeDouble < E > ( pdato ) ; tmp . getPrev ( ) . setNext ( tmp2 ) ; tmp2 . setPrev ( tmp . getPrev ( ) ) ; tmp . setPrev ( tmp2 ) ; tmp2 . setNext ( tmp ) ; _lenght ++ ; } }
tr	3	@ Override public void solve ( BigRational [ ] rhs ) { if ( _class > current_class ) { for ( int i = 0 ; i < size . row ; i ++ ) { basis . setValue ( BigRational . ZERO , array [ i ] [ 0 ] ) ; } } else { for ( int i = 0 ; i < size . row ; i ++ ) { basis . setValue ( carryForwardValue ( i ) , array [ i ] [ 0 ] ) ; } } }
tr	8	private double [ ] [ ] inverso ( int [ ] [ ] llave ) { double [ ] [ ] inverso = new double [ llave . length ] [ llave [ 0 ] . length ] ; boolean signo = false ; for ( int f = 0 ; f < llave . length ; f ++ ) { for ( int c = 0 ; c < llave [ f ] . length ; c ++ ) { int [ ] [ ] matriz_de_adentro = new int [ llave . length - 1 ] [ llave [ f ] . length - 1 ] ; int fda = 0 , cda = 0 ; for ( int f2 = 0 ; f2 < llave . length ; f2 ++ ) { for ( int c2 = 0 ; c2 < llave [ f2 ] . length ; c2 ++ ) { if ( f2 != f && c2 != c ) { matriz_de_adentro [ fda ] [ cda ] = llave [ f2 ] [ c2 ] ; cda ++ ; if ( cda == matriz_de_adentro [ fda ] . length ) { cda = 0 ; fda ++ ; } } } } int dda = calcular_determinante ( matriz_de_adentro ) ; if ( signo ) { dda *= - 1 ; } signo = ! signo ; inverso [ f ] [ c ] = ( ( double ) dda ) / ( ( double ) DET ) ; } } return inverso ; }
tr	6	private void input ( ) { while ( Keyboard . next ( ) ) { if ( Keyboard . isKeyDown ( Keyboard . KEY_Q ) && Keyboard . getEventKeyState ( ) ) { this . stop ( ) ; } } if ( Mouse . getX ( ) != mpos . x || Mouse . getY ( ) != mpos . y ) { mpos . x = Mouse . getX ( ) ; mpos . y = Mouse . getY ( ) ; changed = true ; } if ( Mouse . isButtonDown ( 0 ) ) { changed = true ; } }
tr	1	public void actionPerformed ( ActionEvent e ) { if ( try_to_register ( textField_nazw . getText ( ) , textField_imie . getText ( ) , textField_wiek . getText ( ) , textField_adres . getText ( ) , textField_miasto . getText ( ) , textField_kod . getText ( ) , textField_nick . getText ( ) , passwordField . getPassword ( ) , passwordField_1 . getPassword ( ) , textField_e_m . getText ( ) ) ) { SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { JOptionPane . showMessageDialog ( Register . this , "Rejestracja przebieg\u0142a pomy\u015Blnie" ) ; } } ) ; } }
tr	5	public < E > Printer join ( Collection < ? extends E > collection , String separator , Applier < ? super E > mapper ) { if ( collection . isEmpty ( ) ) { return this ; } for ( E element : collection ) { if ( mapper != null ) { mapper . apply ( element ) ; } else { append ( element ) ; } builder . append ( separator ) ; } builder . setLength ( builder . length ( ) - separator . length ( ) ) ; return this ; }
tr	1	protected void setRedoText ( String arg ) { if ( ! cmdRedo . getToolTipText ( ) . equals ( arg ) ) { cmdRedo . setToolTipText ( arg ) ; } }
tr	5	protected String [ ] splitBlockComment ( TokenizerProperty prop , String image ) { String [ ] images = prop . getImages ( ) ; String start = images [ 0 ] ; String end = images [ 1 ] ; boolean noCase = isFlagSet ( prop , Flags . F_NO_CASE ) ; if ( image . length ( ) - start . length ( ) >= end . length ( ) && ( ( ! noCase && end . equals ( image . substring ( image . length ( ) - end . length ( ) ) ) ) || ( noCase && end . equalsIgnoreCase ( image . substring ( image . length ( ) - end . length ( ) ) ) ) ) ) { return splitIntoLines ( image . substring ( start . length ( ) , image . length ( ) - end . length ( ) ) ) ; } else { return splitIntoLines ( image . substring ( start . length ( ) ) ) ; } }
tr	8	private void addToTable ( File [ ] file , ArrayList < String > durations , String cmd ) { DefaultTableModel defaultTableModel = ( DefaultTableModel ) PlayListjTable . getModel ( ) ; if ( cmd . equalsIgnoreCase ( "Open" ) ) { defaultTableModel . getDataVector ( ) . removeAllElements ( ) ; Object [ ] cols = new Object [ 2 ] ; if ( file != null && durations != null ) { for ( int i = 0 ; i < file . length ; i ++ ) { cols [ 0 ] = file [ i ] ; cols [ 1 ] = durations . get ( i ) ; defaultTableModel . addRow ( cols ) ; } } } else if ( cmd . equalsIgnoreCase ( "AddToList" ) ) { Object [ ] cols = new Object [ 2 ] ; if ( file != null && durations != null ) { for ( int i = 0 ; i < file . length ; i ++ ) { cols [ 0 ] = file [ i ] ; cols [ 1 ] = durations . get ( i ) ; defaultTableModel . addRow ( cols ) ; } } } java . awt . EventQueue . invokeLater ( new Runnable ( ) { @ Override public void run ( ) { PlayListjTable . updateUI ( ) ; } } ) ; }
tr	5	@ Override public void remove ( int index ) { if ( index < 0 || _lenght <= index ) { if ( 0 == _lenght ) { return ; } throw new IndexOutOfBoundsException ( "No se puede remover el dato \n " + "pues esta fuera de los limites de la lista" ) ; } else if ( index == 0 ) { removeFirst ( ) ; } else if ( index == _lenght - 1 ) { removeLast ( ) ; } else { Node < E > tmp = getIndex ( index - 1 ) ; tmp . setNext ( tmp . getNext ( ) . getNext ( ) ) ; _lenght -- ; } }
tr	2	public State safeNext ( Character c , boolean v ) { if ( next ( c ) == null ) { State st = new State ( "" + c ) ; st . setParent ( this ) ; next . put ( c , st ) ; } State nx = next ( c ) ; if ( v ) nx . visit ( ) ; return nx ; }
tr	7	public MainFrame ( ) { setTitle ( "\u90AE\u4EF6\u670D\u52A1\u5668" ) ; setResizable ( false ) ; addWindowListener ( new WindowAdapter ( ) { @ Override public void windowOpened ( WindowEvent e ) { loadProp ( ) ; } } ) ; setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; setBounds ( 100 , 100 , 634 , 561 ) ; contentPane = new JPanel ( ) ; contentPane . setBorder ( new EmptyBorder ( 5 , 5 , 5 , 5 ) ) ; setContentPane ( contentPane ) ; contentPane . setLayout ( new GridLayout ( 1 , 0 , 0 , 0 ) ) ; final JTabbedPane tabbedPane = new JTabbedPane ( JTabbedPane . TOP ) ; contentPane . add ( tabbedPane ) ; JPanel tap1 = new JPanel ( ) ; tabbedPane . addTab ( "\u57FA\u672C\u8BBE\u7F6E" , null , tap1 , null ) ; GridBagLayout gbl_tap1 = new GridBagLayout ( ) ; gbl_tap1 . columnWidths = new int [ ] { 343 , 0 } ; gbl_tap1 . rowHeights = new int [ ] { 100 , 100 , 100 , 100 , 56 , 0 } ; gbl_tap1 . columnWeights = new double [ ] { 1.0 , double . MIN_VALUE } ; gbl_tap1 . rowWeights = new double [ ] { 0.0 , 1.0 , 1.0 , 1.0 , 1.0 , double . MIN_VALUE } ; tap1 . setLayout ( gbl_tap1 ) ; JPanel setPort = new JPanel ( ) ; setPort . setBorder ( new TitledBorder ( null , "\u7AEF\u53E3\u8BBE\u7F6E" , TitledBorder . LEADING , TitledBorder . TOP , null , null ) ) ; GridBagConstraints gbc_setPort = new GridBagConstraints ( ) ; gbc_setPort . fill = GridBagConstraints . BOTH ; gbc_setPort . insets = new Insets ( 0 , 0 , 5 , 0 ) ; gbc_setPort . gridx = 0 ; gbc_setPort . gridy = 0 ; tap1 . add ( setPort , gbc_setPort ) ; GridBagLayout gbl_setPort = new GridBagLayout ( ) ; gbl_setPort . columnWidths = new int [ ] { 80 , 293 , 0 } ; gbl_setPort . rowHeights = new int [ ] { 41 , 0 , 0 } ; gbl_setPort . columnWeights = new double [ ] { 0.0 , 1.0 , double . MIN_VALUE } ; gbl_setPort . rowWeights = new double [ ] { 0.0 , 1.0 , double . MIN_VALUE } ; setPort . setLayout ( gbl_setPort ) ; JLabel lblSmtp = new JLabel ( "SMTP\u7AEF\u53E3" ) ; GridBagConstraints gbc_lblSmtp = new GridBagConstraints ( ) ; gbc_lblSmtp . insets = new Insets ( 0 , 0 , 5 , 5 ) ; gbc_lblSmtp . gridx = 0 ; gbc_lblSmtp . gridy = 0 ; setPort . add ( lblSmtp , gbc_lblSmtp ) ; smtpPortText = new JTextField ( ) ; GridBagConstraints gbc_smtpPortText = new GridBagConstraints ( ) ; gbc_smtpPortText . fill = GridBagConstraints . HORIZONTAL ; gbc_smtpPortText . insets = new Insets ( 0 , 0 , 5 , 0 ) ; gbc_smtpPortText . gridx = 1 ; gbc_smtpPortText . gridy = 0 ; setPort . add ( smtpPortText , gbc_smtpPortText ) ; smtpPortText . setColumns ( 10 ) ; JLabel lblPop = new JLabel ( "POP3\u7AEF\u53E3" ) ; GridBagConstraints gbc_lblPop = new GridBagConstraints ( ) ; gbc_lblPop . insets = new Insets ( 0 , 0 , 0 , 5 ) ; gbc_lblPop . gridx = 0 ; gbc_lblPop . gridy = 1 ; setPort . add ( lblPop , gbc_lblPop ) ; pop3PortText = new JTextField ( ) ; GridBagConstraints gbc_pop3PortText = new GridBagConstraints ( ) ; gbc_pop3PortText . fill = GridBagConstraints . HORIZONTAL ; gbc_pop3PortText . gridx = 1 ; gbc_pop3PortText . gridy = 1 ; setPort . add ( pop3PortText , gbc_pop3PortText ) ; pop3PortText . setColumns ( 10 ) ; JPanel setDomain = new JPanel ( ) ; setDomain . setBorder ( new TitledBorder ( null , "\u57DF\u540D\u8BBE\u7F6E" , TitledBorder . LEADING , TitledBorder . TOP , null , null ) ) ; GridBagConstraints gbc_setDomain = new GridBagConstraints ( ) ; gbc_setDomain . fill = GridBagConstraints . BOTH ; gbc_setDomain . insets = new Insets ( 0 , 0 , 5 , 0 ) ; gbc_setDomain . gridx = 0 ; gbc_setDomain . gridy = 1 ; tap1 . add ( setDomain , gbc_setDomain ) ; GridBagLayout gbl_setDomain = new GridBagLayout ( ) ; gbl_setDomain . columnWidths = new int [ ] { 79 , 0 , 0 } ; gbl_setDomain . rowHeights = new int [ ] { 41 , 0 , 0 } ; gbl_setDomain . columnWeights = new double [ ] { 0.0 , 1.0 , double . MIN_VALUE } ; gbl_setDomain . rowWeights = new double [ ] { 0.0 , 1.0 , double . MIN_VALUE } ; setDomain . setLayout ( gbl_setDomain ) ; JLabel lblNewLabel = new JLabel ( "\u670D\u52A1\u5668\u57DF\u540D" ) ; GridBagConstraints gbc_lblNewLabel = new GridBagConstraints ( ) ; gbc_lblNewLabel . insets = new Insets ( 0 , 0 , 5 , 5 ) ; gbc_lblNewLabel . gridx = 0 ; gbc_lblNewLabel . gridy = 0 ; setDomain . add ( lblNewLabel , gbc_lblNewLabel ) ; localDomainText = new JTextField ( ) ; GridBagConstraints gbc_localDomainText = new GridBagConstraints ( ) ; gbc_localDomainText . insets = new Insets ( 0 , 0 , 5 , 0 ) ; gbc_localDomainText . fill = GridBagConstraints . HORIZONTAL ; gbc_localDomainText . gridx = 1 ; gbc_localDomainText . gridy = 0 ; setDomain . add ( localDomainText , gbc_localDomainText ) ; localDomainText . setColumns ( 10 ) ; JLabel lblNewLabel_1 = new JLabel ( "\u670D\u52A1\u5668\u4E3B\u673A\u540D" ) ; GridBagConstraints gbc_lblNewLabel_1 = new GridBagConstraints ( ) ; gbc_lblNewLabel_1 . anchor = GridBagConstraints . EAST ; gbc_lblNewLabel_1 . insets = new Insets ( 0 , 0 , 0 , 5 ) ; gbc_lblNewLabel_1 . gridx = 0 ; gbc_lblNewLabel_1 . gridy = 1 ; setDomain . add ( lblNewLabel_1 , gbc_lblNewLabel_1 ) ; localHostNameText = new JTextField ( ) ; GridBagConstraints gbc_localHostNameText = new GridBagConstraints ( ) ; gbc_localHostNameText . fill = GridBagConstraints . HORIZONTAL ; gbc_localHostNameText . gridx = 1 ; gbc_localHostNameText . gridy = 1 ; setDomain . add ( localHostNameText , gbc_localHostNameText ) ; localHostNameText . setColumns ( 10 ) ; JPanel setConnect = new JPanel ( ) ; setConnect . setBorder ( new TitledBorder ( null , "\u8FDE\u63A5\u8BBE\u7F6E" , TitledBorder . LEADING , TitledBorder . TOP , null , null ) ) ; GridBagConstraints gbc_setConnect = new GridBagConstraints ( ) ; gbc_setConnect . fill = GridBagConstraints . BOTH ; gbc_setConnect . insets = new Insets ( 0 , 0 , 5 , 0 ) ; gbc_setConnect . gridx = 0 ; gbc_setConnect . gridy = 2 ; tap1 . add ( setConnect , gbc_setConnect ) ; GridBagLayout gbl_setConnect = new GridBagLayout ( ) ; gbl_setConnect . columnWidths = new int [ ] { 81 , 0 , 0 } ; gbl_setConnect . rowHeights = new int [ ] { 46 , 0 , 0 } ; gbl_setConnect . columnWeights = new double [ ] { 0.0 , 1.0 , double . MIN_VALUE } ; gbl_setConnect . rowWeights = new double [ ] { 0.0 , 1.0 , double . MIN_VALUE } ; setConnect . setLayout ( gbl_setConnect ) ; JLabel lblNewLabel_2 = new JLabel ( "\u7B49\u5F85\u8FDE\u63A5\u65F6\u95F4" ) ; GridBagConstraints gbc_lblNewLabel_2 = new GridBagConstraints ( ) ; gbc_lblNewLabel_2 . anchor = GridBagConstraints . EAST ; gbc_lblNewLabel_2 . insets = new Insets ( 0 , 0 , 5 , 5 ) ; gbc_lblNewLabel_2 . gridx = 0 ; gbc_lblNewLabel_2 . gridy = 0 ; setConnect . add ( lblNewLabel_2 , gbc_lblNewLabel_2 ) ; connectLostTimeText = new JTextField ( ) ; GridBagConstraints gbc_connectLostTimeText = new GridBagConstraints ( ) ; gbc_connectLostTimeText . insets = new Insets ( 0 , 0 , 5 , 0 ) ; gbc_connectLostTimeText . fill = GridBagConstraints . HORIZONTAL ; gbc_connectLostTimeText . gridx = 1 ; gbc_connectLostTimeText . gridy = 0 ; setConnect . add ( connectLostTimeText , gbc_connectLostTimeText ) ; connectLostTimeText . setColumns ( 10 ) ; JLabel lblNewLabel_3 = new JLabel ( "\u54CD\u5E94\u65F6\u95F4" ) ; GridBagConstraints gbc_lblNewLabel_3 = new GridBagConstraints ( ) ; gbc_lblNewLabel_3 . insets = new Insets ( 0 , 0 , 0 , 5 ) ; gbc_lblNewLabel_3 . gridx = 0 ; gbc_lblNewLabel_3 . gridy = 1 ; setConnect . add ( lblNewLabel_3 , gbc_lblNewLabel_3 ) ; connectResponseTimeText = new JTextField ( ) ; GridBagConstraints gbc_connectResponseTimeText = new GridBagConstraints ( ) ; gbc_connectResponseTimeText . fill = GridBagConstraints . HORIZONTAL ; gbc_connectResponseTimeText . gridx = 1 ; gbc_connectResponseTimeText . gridy = 1 ; setConnect . add ( connectResponseTimeText , gbc_connectResponseTimeText ) ; connectResponseTimeText . setColumns ( 10 ) ; JPanel setEmail = new JPanel ( ) ; setEmail . setBorder ( new TitledBorder ( null , "\u90AE\u4EF6\u8BBE\u7F6E" , TitledBorder . LEADING , TitledBorder . TOP , null , null ) ) ; GridBagConstraints gbc_setEmail = new GridBagConstraints ( ) ; gbc_setEmail . fill = GridBagConstraints . BOTH ; gbc_setEmail . insets = new Insets ( 0 , 0 , 5 , 0 ) ; gbc_setEmail . gridx = 0 ; gbc_setEmail . gridy = 3 ; tap1 . add ( setEmail , gbc_setEmail ) ; GridBagLayout gbl_setEmail = new GridBagLayout ( ) ; gbl_setEmail . columnWidths = new int [ ] { 0 , 0 , 0 } ; gbl_setEmail . rowHeights = new int [ ] { 25 , 0 } ; gbl_setEmail . columnWeights = new double [ ] { 0.0 , 1.0 , double . MIN_VALUE } ; gbl_setEmail . rowWeights = new double [ ] { 0.0 , double . MIN_VALUE } ; setEmail . setLayout ( gbl_setEmail ) ; JLabel label = new JLabel ( "\u90AE\u4EF6\u5927\u5C0F\u9650\u5236" ) ; GridBagConstraints gbc_label = new GridBagConstraints ( ) ; gbc_label . insets = new Insets ( 0 , 0 , 0 , 5 ) ; gbc_label . anchor = GridBagConstraints . EAST ; gbc_label . gridx = 0 ; gbc_label . gridy = 0 ; setEmail . add ( label , gbc_label ) ; emailSizeText = new JTextField ( ) ; GridBagConstraints gbc_emailSizeText = new GridBagConstraints ( ) ; gbc_emailSizeText . fill = GridBagConstraints . HORIZONTAL ; gbc_emailSizeText . gridx = 1 ; gbc_emailSizeText . gridy = 0 ; setEmail . add ( emailSizeText , gbc_emailSizeText ) ; emailSizeText . setColumns ( 10 ) ; JPanel setButton = new JPanel ( ) ; startButton = new JButton ( "\u542F\u52A8\u670D\u52A1\u5668" ) ; startButton . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { saveProp ( ) ; ServerManager . getServerManager ( ) . startServer ( ) ; startButton . setEnabled ( false ) ; tabbedPane . setEnabledAt ( 1 , true ) ; } } ) ; JButton savePropButton = new JButton ( "\u4FDD\u5B58\u8BBE\u7F6E" ) ; savePropButton . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { saveProp ( ) ; JOptionPane . showMessageDialog ( null , "\u4FDD\u5B58\u6210\u529F" ) ; } } ) ; setButton . add ( savePropButton ) ; JButton readPropButton = new JButton ( "\u8BFB\u53D6\u8BBE\u7F6E" ) ; readPropButton . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { loadProp ( ) ; } } ) ; setButton . add ( readPropButton ) ; setButton . add ( startButton ) ; GridBagConstraints gbc_setButton = new GridBagConstraints ( ) ; gbc_setButton . anchor = GridBagConstraints . WEST ; gbc_setButton . gridx = 0 ; gbc_setButton . gridy = 4 ; tap1 . add ( setButton , gbc_setButton ) ; JPanel tap3 = new JPanel ( ) ; tabbedPane . addTab ( "\u8D26\u53F7\u7BA1\u7406" , null , tap3 , null ) ; tabbedPane . setEnabledAt ( 1 , false ) ; GridBagLayout gbl_tap3 = new GridBagLayout ( ) ; gbl_tap3 . columnWidths = new int [ ] { 306 , 0 } ; gbl_tap3 . rowHeights = new int [ ] { 1 , 0 , 0 } ; gbl_tap3 . columnWeights = new double [ ] { 1.0 , double . MIN_VALUE } ; gbl_tap3 . rowWeights = new double [ ] { 1.0 , 0.0 , double . MIN_VALUE } ; tap3 . setLayout ( gbl_tap3 ) ; final JTextArea textArea = new JTextArea ( ) ; textArea . setFont ( new Font ( "Monospaced" , Font . PLAIN , 18 ) ) ; textArea . setEditable ( false ) ; textArea . setLineWrap ( true ) ; GridBagConstraints gbc_textArea = new GridBagConstraints ( ) ; gbc_textArea . insets = new Insets ( 0 , 0 , 5 , 0 ) ; gbc_textArea . fill = GridBagConstraints . BOTH ; gbc_textArea . gridx = 0 ; gbc_textArea . gridy = 0 ; tap3 . add ( textArea , gbc_textArea ) ; JPanel panel_1 = new JPanel ( ) ; GridBagConstraints gbc_panel_1 = new GridBagConstraints ( ) ; gbc_panel_1 . fill = GridBagConstraints . BOTH ; gbc_panel_1 . gridx = 0 ; gbc_panel_1 . gridy = 1 ; tap3 . add ( panel_1 , gbc_panel_1 ) ; JButton btnNewButton = new JButton ( "\u663E\u793A\u8D26\u53F7" ) ; btnNewButton . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { UserListManager userListManager = UserListManager . getInstance ( ) ; List < User > userList = userListManager . getUserList ( ) ; textArea . setText ( "" ) ; for ( User user : userList ) { textArea . append ( "\u8D26\u53F7\uFF1A" + user . getUserName ( ) + " \u90AE\u4EF6\u6570\u91CF" + user . getEmailNumber ( ) + "\n" ) ; } } } ) ; panel_1 . add ( btnNewButton ) ; JButton btnNewButton_1 = new JButton ( "\u6DFB\u52A0\u8D26\u53F7" ) ; btnNewButton_1 . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { AddUserDialog addUserDialog = new AddUserDialog ( ) ; addUserDialog . setVisible ( true ) ; } } ) ; panel_1 . add ( btnNewButton_1 ) ; JPanel tap2 = new JPanel ( ) ; tabbedPane . addTab ( "\u65E5\u5FD7" , null , tap2 , null ) ; tabbedPane . setEnabledAt ( 2 , true ) ; GridBagLayout gbl_tap2 = new GridBagLayout ( ) ; gbl_tap2 . columnWidths = new int [ ] { 4 , 0 } ; gbl_tap2 . rowHeights = new int [ ] { 24 , 0 , 0 } ; gbl_tap2 . columnWeights = new double [ ] { 1.0 , double . MIN_VALUE } ; gbl_tap2 . rowWeights = new double [ ] { 1.0 , 0.0 , double . MIN_VALUE } ; tap2 . setLayout ( gbl_tap2 ) ; JScrollPane scrollPane = new JScrollPane ( ) ; GridBagConstraints gbc_scrollPane = new GridBagConstraints ( ) ; gbc_scrollPane . fill = GridBagConstraints . BOTH ; gbc_scrollPane . insets = new Insets ( 0 , 0 , 5 , 0 ) ; gbc_scrollPane . gridx = 0 ; gbc_scrollPane . gridy = 0 ; tap2 . add ( scrollPane , gbc_scrollPane ) ; final JTextArea logTextArea = new JTextArea ( ) ; scrollPane . setViewportView ( logTextArea ) ; logTextArea . setLineWrap ( true ) ; logTextArea . setEditable ( false ) ; JPanel panel = new JPanel ( ) ; GridBagConstraints gbc_panel = new GridBagConstraints ( ) ; gbc_panel . fill = GridBagConstraints . BOTH ; gbc_panel . gridx = 0 ; gbc_panel . gridy = 1 ; tap2 . add ( panel , gbc_panel ) ; JButton btnNewButton_2 = new JButton ( "\u8BFB\u53D6log_debug.log" ) ; btnNewButton_2 . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { logTextArea . setText ( "" ) ; BufferedReader reader = null ; String content = null ; try { File logFile = new File ( "src/server/log/log_debug.log" ) ; if ( logFile . exists ( ) ) { reader = new BufferedReader ( new FileReader ( logFile ) ) ; while ( ( content = reader . readLine ( ) ) != null ) { logTextArea . append ( content + "\n" ) ; } } else { logTextArea . setText ( "file not found!" ) ; } } catch ( FileNotFoundException e3 ) { e3 . printStackTrace ( ) ; } catch ( IOException e1 ) { e1 . printStackTrace ( ) ; } finally { try { if ( reader != null ) { reader . close ( ) ; } } catch ( IOException e1 ) { e1 . printStackTrace ( ) ; } } } } ) ; panel . add ( btnNewButton_2 ) ; }
tr	4	public static String substring ( String origin , String begin , String end ) { if ( origin == null ) { return origin ; } int beginIndex = begin == null ? 0 : origin . indexOf ( begin ) + begin . length ( ) ; int endIndex = end == null ? origin . length ( ) : origin . indexOf ( end , beginIndex ) ; if ( endIndex == - 1 ) { return origin . substring ( beginIndex ) ; } return origin . substring ( beginIndex , endIndex ) ; }
tr	1	public static void main ( String [ ] args ) { kmpNext ( "ABCDABD" ) ; if ( kmp ( "ABC ABCDAB ABCDABCDABDE" , "ABCDABD" ) ) System . out . println ( "YES" ) ; else System . out . println ( "NO" ) ; }
tr	4	public static void main ( String [ ] args ) { Conn con = PoolManager . getInstance ( ) . getConnection ( ) ; Connection conn = con . getConn ( ) ; Statement stmt = null ; ResultSet rs = null ; try { stmt = conn . createStatement ( ) ; rs = stmt . executeQuery ( "select * from article " ) ; int c = rs . getMetaData ( ) . getColumnCount ( ) ; for ( int i = 1 ; i <= c ; ++ i ) { System . out . println ( rs . getMetaData ( ) . getColumnName ( i ) ) ; } while ( rs . next ( ) ) { System . out . print ( rs . getString ( "title" ) ) ; System . out . print ( rs . getString ( "author" ) ) ; System . out . println ( ) ; } } catch ( SQLException e ) { e . printStackTrace ( ) ; } finally { try { stmt . close ( ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; } PoolManager . getInstance ( ) . releaseConnection ( con ) ; } }
tr	8	private void populateSubSet ( ArrayList < ArrayList < Integer >> arrayLists , int [ ] candidateCount , int startIndex , int endIndex , int [ ] candidates , int target ) { if ( startIndex >= ( endIndex + 1 ) ) { ArrayList < Integer > currentCombination = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i <= endIndex ; i ++ ) { if ( candidateCount [ i ] != 0 ) { for ( int j = 0 ; j < candidateCount [ i ] ; j ++ ) { currentCombination . add ( candidates [ i ] ) ; } } } if ( currentCombination . size ( ) > 0 ) { arrayLists . add ( currentCombination ) ; } return ; } if ( startIndex == endIndex ) { if ( target % candidates [ startIndex ] == 0 ) { candidateCount [ startIndex ] = target / candidates [ startIndex ] ; populateSubSet ( arrayLists , candidateCount , startIndex + 1 , endIndex , candidates , 0 ) ; } } else { int iterateUpTo = target / candidates [ startIndex ] ; for ( int i = 0 ; i <= iterateUpTo ; i ++ ) { candidateCount [ startIndex ] = i ; populateSubSet ( arrayLists , candidateCount , startIndex + 1 , endIndex , candidates , target - candidates [ startIndex ] * i ) ; } } }
tr	0	public PortException ( String message ) { super ( message ) ; }
tr	6	private void initPanels ( ) { if ( attribs == null ) { attribs = new MyInternalFrame ( this , 1 ) ; jDesktopPane1 . add ( attribs , new Integer ( 10 ) ) ; } try { attribs . setIcon ( true ) ; } catch ( java . beans . PropertyVetoException e ) { } attribs . setVisible ( true ) ; if ( tools == null ) { tools = new MyInternalFrame ( this , 0 ) ; jDesktopPane1 . add ( tools , new Integer ( 10 ) ) ; } tools . setVisible ( true ) ; try { tools . setIcon ( true ) ; } catch ( java . beans . PropertyVetoException e ) { } if ( opers == null ) { opers = new MyInternalFrame ( this , 2 ) ; jDesktopPane1 . add ( opers , new Integer ( 10 ) ) ; } try { opers . setIcon ( true ) ; } catch ( java . beans . PropertyVetoException e ) { } opers . setVisible ( true ) ; }
tr	6	@ Override public int send ( Message message , Actor from , String category ) { int count = 0 ; Map < String , Actor > xactors = cloneActors ( ) ; List < Actor > catMembers = new LinkedList < Actor > ( ) ; for ( String key : xactors . keySet ( ) ) { Actor to = xactors . get ( key ) ; if ( category . equals ( to . getCategory ( ) ) && ( to . getMessageCount ( ) < to . getMaxMessageCount ( ) ) ) { catMembers . add ( to ) ; } } int min = Integer . MAX_VALUE ; Actor amin = null ; for ( Actor a : catMembers ) { int mcount = a . getMessageCount ( ) ; if ( mcount < min ) { min = mcount ; amin = a ; } } if ( amin != null ) { count += send ( message , from , amin ) ; } return count ; }
tr	0	public String getStoreg ( ) { return storeg ; }
tr	4	public static void main ( String args [ ] ) { int i = Integer . parseInt ( args [ 0 ] ) ; switch ( i ) { case 1 : System . out . println ( "one" ) ; break ; case 2 : System . out . println ( "two" ) ; break ; case 3 : System . out . println ( "three" ) ; break ; case 4 : System . out . println ( "four" ) ; break ; default : System . out . println ( "Unrecoginized Number" ) ; break ; } }
tr	6	public boolean act ( Agent agent , Action action ) { if ( energy_level <= 0 ) { agent . die ( ) ; updateViews ( msg ) ; return false ; } boolean flag = ( action != null ) ; if ( flag ) { SimulatedAgent a = ( SimulatedAgent ) agent ; int x = ( ( Integer ) a . getAttribute ( X ) ) . intValue ( ) ; int y = ( ( Integer ) a . getAttribute ( Y ) ) . intValue ( ) ; Percept p = sense ( a ) ; String msg = null ; String act = action . getCode ( ) ; int actionID = language . getActionIndex ( act ) ; switch ( actionID ) { case 4 : if ( ( ( boolean ) p . getAttribute ( language . getPercept ( 5 ) ) ) . booleanValue ( ) ) { structure [ x ] [ y ] |= ( 1 << 15 ) ; int bit_flag = ( 1 << 10 ) ; if ( ( structure [ x ] [ y ] & bit_flag ) == bit_flag ) { System . out . println ( "Eating good food..." ) ; energy_level = Math . min ( energy_level + INC_ENERGY_LEVEL , MAX_ENERGY_LEVEL ) ; } else { System . out . println ( "Eating bad food..." ) ; energy_level = Math . max ( energy_level - DEC_ENERGY_LEVEL , 0 ) ; } } else { msg = SimpleView . ERROR + "[There is not food. Eat action not executed]" ; } updateViews ( msg ) ; break ; default : if ( actionID == 2 ) { energy_level -- ; System . out . println ( energy_level ) ; } super . act ( agent , action ) ; break ; } } return flag ; }
tr	2	private void assignContent ( ) throws SAXException { try { int lastObject = buildObjects . size ( ) - 1 ; if ( lastObject >= 0 ) { Object obj = buildObjects . get ( lastObject ) ; this . setAttribute ( obj , this . setterName , content . toString ( ) ) ; } else { logger . trace ( "No objects in build queue." ) ; } } catch ( FogBugzException e ) { logger . trace ( "Throwing exception upwards." , e ) ; throw new SAXException ( e ) ; } content . delete ( 0 , content . length ( ) ) ; content . setLength ( 0 ) ; }
tr	3	private static String calcularPorc ( double x1 , double x2 , ArrayList < Segmento > Lista , DecimalFormat f ) { double por = 1.0 ; for ( Segmento seg : Lista ) { if ( x1 >= seg . x1 && x2 <= seg . x2 ) por *= seg . r ; } return f . format ( por ) ; }
tr	5	public void update ( final String data ) { int j = this . dataLen % SLIDING_WND_SIZE ; int fedLen = this . dataLen ; if ( this . aBucket == null ) { this . aBucket = new int [ BUCKETS ] ; } for ( int i = 0 ; i < data . length ( ) ; i ++ ) { slideWindow [ j ] = ( int ) ( data . charAt ( i ) & ff ) ; if ( fedLen >= 4 ) { int j1 = ( j + SLIDING_WND_SIZE - 1 ) % SLIDING_WND_SIZE ; int j2 = ( j + SLIDING_WND_SIZE - 2 ) % SLIDING_WND_SIZE ; int j3 = ( j + SLIDING_WND_SIZE - 3 ) % SLIDING_WND_SIZE ; int j4 = ( j + SLIDING_WND_SIZE - 4 ) % SLIDING_WND_SIZE ; for ( int k = 0 ; k < TLSH_CHECKSUM_LEN ; k ++ ) { if ( k == 0 ) { this . lshBin . checksum [ k ] = bMapping ( ( int ) 0 , slideWindow [ j ] , slideWindow [ j1 ] , this . lshBin . checksum [ k ] ) ; } else { this . lshBin . checksum [ k ] = bMapping ( this . lshBin . checksum [ k - 1 ] , slideWindow [ j ] , slideWindow [ j1 ] , this . lshBin . checksum [ k ] ) ; } } int r ; r = bMapping ( ( int ) 2 , slideWindow [ j ] , slideWindow [ j1 ] , slideWindow [ j2 ] ) ; this . aBucket [ r ] ++ ; r = bMapping ( ( int ) 3 , slideWindow [ j ] , slideWindow [ j1 ] , slideWindow [ j3 ] ) ; this . aBucket [ r ] ++ ; r = bMapping ( ( int ) 5 , slideWindow [ j ] , slideWindow [ j2 ] , slideWindow [ j3 ] ) ; this . aBucket [ r ] ++ ; r = bMapping ( ( int ) 7 , slideWindow [ j ] , slideWindow [ j2 ] , slideWindow [ j4 ] ) ; this . aBucket [ r ] ++ ; r = bMapping ( ( int ) 11 , slideWindow [ j ] , slideWindow [ j1 ] , slideWindow [ j4 ] ) ; this . aBucket [ r ] ++ ; r = bMapping ( ( int ) 13 , slideWindow [ j ] , slideWindow [ j3 ] , slideWindow [ j4 ] ) ; this . aBucket [ r ] ++ ; } fedLen ++ ; j = ( j + SLIDING_WND_SIZE + 1 ) % SLIDING_WND_SIZE ; } this . dataLen += data . length ( ) ; }
tr	7	private Node remove ( Node node , Integer dataToRemove ) { if ( node == null ) { return null ; } else if ( node . data . compareTo ( dataToRemove ) > 0 ) { node . left = remove ( node . left , dataToRemove ) ; } else if ( node . data . compareTo ( dataToRemove ) < 0 ) { node . right = remove ( node . right , dataToRemove ) ; } else { if ( node . left != null && node . right != null ) { Node rightSubTreeMinNode = findMinimum ( node . right ) ; node . data = rightSubTreeMinNode . data ; remove ( node . right , node . data ) ; } else if ( node . left == null ) { node = ( node . left != null ) ? node . left : node . right ; } } return node ; }
tr	6	public static Type [ ] getTypeParams ( class < ? > klass ) { if ( klass == null || "java.lang.Object" . equals ( klass . getName ( ) ) ) { return null ; } Type superclass = klass . getGenericSuperclass ( ) ; if ( superclass instanceof ParameterizedType ) { return ( ( ParameterizedType ) superclass ) . getActualTypeArguments ( ) ; } Type [ ] interfaces = klass . getGenericInterfaces ( ) ; for ( Type inf : interfaces ) { if ( inf instanceof ParameterizedType ) { return ( ( ParameterizedType ) inf ) . getActualTypeArguments ( ) ; } } return getTypeParams ( klass . getSuperclass ( ) ) ; }
tr	0	@ Override public String toString ( ) { return getName ( ) + "=" + getValue ( ) ; }
tr	9	public static void MoveToLocal ( String localFilePath , String HDFSFilePath ) { File file = new File ( localFilePath ) ; if ( ! file . canWrite ( ) ) { Logger . log ( "Invalid output file location" ) ; } try { try { FileOutputStream fos = new FileOutputStream ( localFilePath ) ; fos . close ( ) ; } catch ( FileNotFoundException e ) { Logger . log ( "Invalid output file location:" + localFilePath ) ; return ; } FileBlock [ ] fileBlocks = DataNode . nameNode . getFileBlocks ( DataNode . key , HDFSFilePath ) ; if ( fileBlocks == null ) { Logger . log ( "Invalid input file location: " + HDFSFilePath ) ; return ; } int counter = 0 ; String files [ ] = new String [ fileBlocks . length ] ; for ( FileBlock block : fileBlocks ) { boolean success = false ; String tempFileName = DataNode . rootPath + ( FileSystem . DIRECTORYSEPARATOR + "__TEMP" + counter ) ; files [ counter ] = tempFileName ; for ( String location : block . getNodeLocations ( ) ) { try { Message m = new Message ( "sendMeFile" ) ; m . fileName = block . getBlockFileName ( ) ; m . sendLocation = null ; Socket socket = Communicator . CreateDataSocket ( location ) ; Logger . log ( "sending message" ) ; Message fileSizeMessage = Communicator . sendAndReceiveMessage ( socket , m ) ; Logger . log ( "received message:" + fileSizeMessage . fileSize + ":" + block . getSize ( ) ) ; if ( Communicator . receiveFile ( socket , tempFileName , fileSizeMessage . fileSize ) != fileSizeMessage . fileSize ) throw new IOException ( "Received file size not expected" ) ; socket . close ( ) ; success = true ; break ; } catch ( IOException | ClassNotFoundException e ) { Logger . log ( "one node failed! trying another: " + e . getMessage ( ) ) ; e . printStackTrace ( ) ; break ; } } if ( success == false ) throw new IOException ( "File Copy Failed! Try again!" ) ; counter ++ ; } FileMerge . mergeFiles ( files , localFilePath ) ; } catch ( IOException | FileSystemException e ) { Logger . log ( e . getMessage ( ) ) ; e . printStackTrace ( ) ; } catch ( InvalidDataNodeException e ) { DataNode . reset ( ) ; } }
tr	4	public void render ( Graphics g ) { i ++ ; if ( i >= 8 ) { animationStep ++ ; animationStep %= 9 ; image = sheet . getSprite ( "monster_0" + animationStep + ".png" ) ; if ( getDirectionDroite ( ) ) { image = image . getFlippedCopy ( true , false ) ; } i = 0 ; } if ( toucherDmg ) { image . setAlpha ( 0.001f ) ; if ( i >= 5 ) { image . setAlpha ( 1.f ) ; toucherDmg = false ; } } image . drawCentered ( getX ( ) , getY ( ) ) ; renderVie ( g ) ; }
tr	2	@ Override public MemberAddressBook getMemberAddressBook ( int memberID ) { conn = DB . getConn ( ) ; try { pstmt = conn . prepareStatement ( "select * from T_MemberAddressBook where MemberID = ?" ) ; pstmt . setInt ( 1 , memberID ) ; rs = pstmt . executeQuery ( ) ; if ( rs . next ( ) ) { MemberAddressBook memberAddressBook = new MemberAddressBook ( ) ; memberAddressBook . setId ( rs . getInt ( 1 ) ) ; memberAddressBook . setMemberID ( rs . getInt ( 2 ) ) ; memberAddressBook . setMemberTrueName ( rs . getString ( 3 ) ) ; memberAddressBook . setMemberAddress ( rs . getString ( 4 ) ) ; memberAddressBook . setProvinceCode ( rs . getString ( 5 ) ) ; memberAddressBook . setCityCode ( rs . getString ( 6 ) ) ; memberAddressBook . setAreaCode ( rs . getString ( 7 ) ) ; memberAddressBook . setMemberPostcode ( rs . getString ( 8 ) ) ; memberAddressBook . setMemberTelephone ( rs . getString ( 9 ) ) ; memberAddressBook . setCreateDate ( rs . getDate ( 10 ) ) ; memberAddressBook . setUpdateDate ( rs . getDate ( 11 ) ) ; return memberAddressBook ; } else { return null ; } } catch ( SQLException e ) { e . printStackTrace ( ) ; return null ; } }
tr	7	protected void prepare_sample_reading ( Header header , int allocation , int channel , float [ ] factor , int [ ] codelength , float [ ] c , float [ ] d ) { int channel_bitrate = header . bitrate_index ( ) ; if ( header . mode ( ) != Header . SINGLE_CHANNEL ) if ( channel_bitrate == 4 ) channel_bitrate = 1 ; else channel_bitrate -= 4 ; if ( channel_bitrate == 1 || channel_bitrate == 2 ) { groupingtable [ channel ] = table_cd_groupingtables [ allocation ] ; factor [ 0 ] = table_cd_factor [ allocation ] ; codelength [ 0 ] = table_cd_codelength [ allocation ] ; c [ 0 ] = table_cd_c [ allocation ] ; d [ 0 ] = table_cd_d [ allocation ] ; } else { if ( subbandnumber <= 2 ) { groupingtable [ channel ] = table_ab1_groupingtables [ allocation ] ; factor [ 0 ] = table_ab1_factor [ allocation ] ; codelength [ 0 ] = table_ab1_codelength [ allocation ] ; c [ 0 ] = table_ab1_c [ allocation ] ; d [ 0 ] = table_ab1_d [ allocation ] ; } else { groupingtable [ channel ] = table_ab234_groupingtables [ allocation ] ; if ( subbandnumber <= 10 ) { factor [ 0 ] = table_ab2_factor [ allocation ] ; codelength [ 0 ] = table_ab2_codelength [ allocation ] ; c [ 0 ] = table_ab2_c [ allocation ] ; d [ 0 ] = table_ab2_d [ allocation ] ; } else if ( subbandnumber <= 22 ) { factor [ 0 ] = table_ab3_factor [ allocation ] ; codelength [ 0 ] = table_ab3_codelength [ allocation ] ; c [ 0 ] = table_ab3_c [ allocation ] ; d [ 0 ] = table_ab3_d [ allocation ] ; } else { factor [ 0 ] = table_ab4_factor [ allocation ] ; codelength [ 0 ] = table_ab4_codelength [ allocation ] ; c [ 0 ] = table_ab4_c [ allocation ] ; d [ 0 ] = table_ab4_d [ allocation ] ; } } } }
tr	2	public TestClient ( int port , String name ) { try { count ++ ; socket = new Socket ( InetAddress . getLocalHost ( ) , port ) ; this . name = name ; this . setName ( "TestClientThread-" + count ) ; } catch ( UnknownHostException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }
tr	2	protected void pausePlayback ( ) { if ( m_line != null ) { if ( m_status == PLAYING ) { m_line . stop ( ) ; m_status = PAUSED ; notifyEvent ( BasicPlayerEvent . PAUSED , getEncodedStreamPosition ( ) , - 1 , null ) ; m_line . drain ( ) ; } } }
tr	9	protected void setFromQhull ( double [ ] coords , int nump , boolean triangulate ) { String commandStr = "./qhull i" ; if ( triangulate ) { commandStr += " -Qt" ; } try { Process proc = Runtime . getRuntime ( ) . exec ( commandStr ) ; PrintStream ps = new PrintStream ( proc . getOutputStream ( ) ) ; StreamTokenizer stok = new StreamTokenizer ( new InputStreamReader ( proc . getInputStream ( ) ) ) ; ps . println ( "3 " + nump ) ; for ( int i = 0 ; i < nump ; i ++ ) { ps . println ( coords [ i * 3 + 0 ] + " " + coords [ i * 3 + 1 ] + " " + coords [ i * 3 + 2 ] ) ; } ps . flush ( ) ; ps . close ( ) ; Vector indexList = new Vector ( 3 ) ; stok . eolIsSignificant ( true ) ; printQhullErrors ( proc ) ; do { stok . nextToken ( ) ; } while ( stok . sval == null || ! stok . sval . startsWith ( "MERGEexact" ) ) ; for ( int i = 0 ; i < 4 ; i ++ ) { stok . nextToken ( ) ; } if ( stok . ttype != StreamTokenizer . TT_NUMBER ) { System . out . println ( "Expecting number of faces" ) ; System . exit ( 1 ) ; } int numf = ( int ) stok . nval ; stok . nextToken ( ) ; int [ ] [ ] faceIndices = new int [ numf ] [ ] ; for ( int i = 0 ; i < numf ; i ++ ) { indexList . clear ( ) ; while ( stok . nextToken ( ) != StreamTokenizer . TT_EOL ) { if ( stok . ttype != StreamTokenizer . TT_NUMBER ) { System . out . println ( "Expecting face index" ) ; System . exit ( 1 ) ; } indexList . add ( 0 , new Integer ( ( int ) stok . nval ) ) ; } faceIndices [ i ] = new int [ indexList . size ( ) ] ; int k = 0 ; for ( Iterator it = indexList . iterator ( ) ; it . hasNext ( ) ; ) { faceIndices [ i ] [ k ++ ] = ( ( Integer ) it . next ( ) ) . intValue ( ) ; } } setHull ( coords , nump , faceIndices , numf ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; System . exit ( 1 ) ; } }
tr	0	public final boolean isRegistered ( BytesKey key ) { return map . containsKey ( key ) ; }
tr	9	public static String rowToString ( JSONArray ja ) { StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < ja . length ( ) ; i += 1 ) { if ( i > 0 ) { sb . append (   ) ; } Object object = ja . opt ( i ) ; if ( object != null ) { String string = object . toString ( ) ; if ( string . length ( ) > 0 && ( string . indexOf (   ) >= 0 || string . indexOf ( '' ) >= 0 || string . indexOf ( '' ) >= 0 || string . indexOf ( 0 ) >= 0 || string . charAt ( 0 ) == " ) ) { sb . append ( " ) ; int length = string . length ( ) ; for ( int j = 0 ; j < length ; j += 1 ) { char c = string . charAt ( j ) ; if ( c >=   && c != " ) { sb . append ( c ) ; } } sb . append ( " ) ; } else { sb . append ( string ) ; } } } sb . append ( '' ) ; return sb . toString ( ) ; }
tr	7	@ Override public void setFailState ( int failState ) { if ( this . failstate == Fallible . DEAD && failState != Fallible . DEAD ) throw new IllegalStateException ( "Cannot change fail state: node is already DEAD" ) ; switch ( failState ) { case OK : this . failstate = Fallible . OK ; break ; case DEAD : this . index = - 1 ; this . failstate = Fallible . DEAD ; for ( int i = 0 ; i < this . protocol . length ; ++ i ) if ( this . protocol [ i ] instanceof Cleanable ) { ( ( Cleanable ) this . protocol [ i ] ) . onKill ( ) ; } break ; case DOWN : this . failstate = Fallible . DOWN ; break ; default : throw new IllegalArgumentException ( "failState=" + failState ) ; } }
tr	1	public void update ( double ad [ ] , double d ) { for ( int i = 0 ; i < mFilters . length ; i ++ ) { mFilters [ i ] . update ( ad [ i ] , d ) ; } }
tr	5	private void setLocale ( Locale l , boolean select ) { Locale oldLocale = locale ; locale = l ; int n = 0 ; if ( select ) { for ( int i = 0 ; i < localeCount ; i ++ ) { if ( locales [ i ] . getCountry ( ) . length ( ) > 0 ) { if ( locales [ i ] . equals ( locale ) ) setSelectedIndex ( n ) ; n += 1 ; } } } firePropertyChange ( "locale" , oldLocale , locale ) ; if ( component != null ) { component . setLocale ( l ) ; } }
tr	5	private ByteBuffer convertImageData ( final BufferedImage bufferedImage , final Texture texture ) { ByteBuffer imageBuffer ; WritableRaster raster ; BufferedImage texImage ; int texWidth = texture . getTextureWidth ( ) ; int texHeight = texture . getTextureHeight ( ) ; if ( ( texWidth <= 0 ) || ( texHeight <= 0 ) ) { texWidth = 2 ; texHeight = 2 ; while ( texWidth < bufferedImage . getWidth ( ) ) { texWidth *= 2 ; } while ( texHeight < bufferedImage . getHeight ( ) ) { texHeight *= 2 ; } texture . setTextureHeight ( texHeight ) ; texture . setTextureWidth ( texWidth ) ; } if ( bufferedImage . getColorModel ( ) . hasAlpha ( ) ) { raster = Raster . createInterleavedRaster ( DataBuffer . TYPE_BYTE , texWidth , texHeight , 4 , null ) ; texImage = new BufferedImage ( glAlphaColorModel , raster , false , new Hashtable < Object , Object > ( ) ) ; } else { raster = Raster . createInterleavedRaster ( DataBuffer . TYPE_BYTE , texWidth , texHeight , 3 , null ) ; texImage = new BufferedImage ( glColorModel , raster , false , new Hashtable < Object , Object > ( ) ) ; } texture . setAlphaPremultiplied ( ( bufferedImage . getType ( ) == BufferedImage . TYPE_4BYTE_ABGR_PRE ) ) ; Graphics g = texImage . getGraphics ( ) ; g . setColor ( new Color ( 0f , 0f , 0f , 0f ) ) ; g . fillRect ( 0 , 0 , texWidth , texHeight ) ; g . drawImage ( bufferedImage , 0 , 0 , null ) ; g . dispose ( ) ; bufferedImage . flush ( ) ; byte [ ] data = ( ( DataBufferByte ) texImage . getRaster ( ) . getDataBuffer ( ) ) . getData ( ) ; texImage . flush ( ) ; imageBuffer = ByteBuffer . allocateDirect ( data . length ) ; imageBuffer . order ( ByteOrder . nativeOrder ( ) ) ; imageBuffer . put ( data , 0 , data . length ) ; imageBuffer . flip ( ) ; return imageBuffer ; }
tr	0	public UserDaoImpl ( final java . sql . Connection userConn ) { this . userConn = userConn ; }
tr	2	public int priseTerritoire ( Territoire t , int nbUnite ) { if ( this . nbUniteBonus >= nbUnite - 1 ) { this . nbUniteBonus -= nbUnite - 1 ; nbUnite = 1 ; } else { nbUnite -= this . nbUniteBonus ; this . nbUniteBonus = 0 ; } this . nbUniteEnMain -= nbUnite ; t . setNbUnite ( nbUnite ) ; t . setOccupant ( this ) ; this . territoiresOccupes . add ( t ) ; this . actionPriseTerritoire ( t ) ; if ( hasPower ( ) ) { this . pouvoir . actionPriseTerritoire ( t ) ; } return nbUnite ; }
tr	6	@ Override public void validate ( ) { if ( sitename == null ) { addActionError ( "Please Enter Site Name" ) ; } if ( siteurl == null && siteurl . equals ( "http://" ) ) { addActionError ( "Please Enter Web Site Url" ) ; } if ( txtcolor == null ) { addActionError ( "Please Enter Text Color" ) ; } if ( bgcolor == null ) { addActionError ( "Please Enter Background Color" ) ; } if ( catgry . equals ( "Please select" ) ) { addActionError ( "Please Select a Category" ) ; } }
tr	7	public synchronized void toggleSpeed ( boolean faster ) { if ( faster && speedup >= 1 ) { if ( speedup >= 99 ) return ; speedup ++ ; } else if ( faster && speedup < 1 ) { speedup += 0.1 ; } else if ( speedup > 1 ) { speedup -- ; } else if ( speedup > 0.10f ) { speedup -= 0.10f ; } updateSpeedupLabel ( ) ; setCmd ( Commands . REPAINTLABEL ) ; }
tr	4	@ Override public void run ( ) { PingMessage ping ; int i ; while ( ! servent . mustHalt ) { synchronized ( servent . connections ) { for ( i = 0 ; i < servent . connections . size ( ) && ! servent . mustHalt ; i ++ ) { ping = new PingMessage ( servent . connectPort , receiveSocket . getLocalPort ( ) ) ; forward ( ping , servent . connections . get ( i ) ) ; setSeen ( ping , servent . fakeConnection ) ; } } try { sleep ( Util . PING_SENDING_INTERVAL ) ; } catch ( InterruptedException e ) { continue ; } } }
tr	0	public int getDoubleInJail ( ) { return this . doubleInWormhole ; }
tr	9	public List < String > getValidationErrors ( ) { List < String > errors = new ArrayList < String > ( ) ; if ( fundname == null || fundname . length ( ) == 0 ) { errors . add ( "Fund name is required" ) ; } if ( symbol == null || symbol . length ( ) == 0 ) { errors . add ( "Ticker name is required" ) ; } if ( symbol == null || symbol . length ( ) > 5 ) { errors . add ( "Length of Ticker should not be greater than 5" ) ; } if ( fundname . matches ( ".*[<>\"].*" ) ) { errors . add ( "Fund name may not contain angle brackets or quotes" ) ; } if ( symbol . matches ( ".*[<>\"].*" ) ) { errors . add ( "Ticker name may not contain angle brackets or quotes" ) ; } if ( ! dataConversion . validStringLength ( fundname ) ) { errors . add ( "Fund name should be no longer than 30 characters" ) ; } if ( ! dataConversion . validStringLength ( symbol ) ) { errors . add ( "Ticker name should be no longer than 30 characters" ) ; } return errors ; }
tr	5	public AList < Song > getTracksByGenre ( Genre g ) { AList < Song > tracksByGenre = new AList < Song > ( ) ; for ( SListIterator < Record > iterator = createIterator ( ) ; iterator . isValid ( ) ; iterator . moveNext ( ) ) { for ( int j = 0 ; j < 2 ; j ++ ) { for ( AListIterator < Song > iterator2 = iterator . getCurrentElem ( ) . getSide ( j ) . getSideTracklist ( ) . createIterator ( ) ; iterator2 . isValid ( ) ; iterator2 . moveNext ( ) ) { if ( iterator2 . getCurrentElem ( ) . getGenre ( ) . equals ( g ) ) { tracksByGenre . addLast ( iterator2 . getCurrentElem ( ) ) ; } } } } if ( tracksByGenre . isEmpty ( ) ) { return null ; } else { return tracksByGenre ; } }
tr	7	public static void main ( String [ ] args ) { if ( ! ApplicationHelper . SHOW_ERROR ) { System . err . close ( ) ; } boolean color = false ; if ( args . length > 0 && args [ 0 ] . equals ( "-color" ) ) { color = true ; } BufferedReader br = null ; List < String > questions = new ArrayList < String > ( ) ; List < String > answers = new ArrayList < String > ( ) ; try { String line ; br = new BufferedReader ( new FileReader ( new File ( Settings . get ( "TEST_PATH" ) ) ) ) ; while ( ( line = br . readLine ( ) ) != null ) { questions . add ( ApplicationHelper . stripPunctuation ( line ) ) ; } br = new BufferedReader ( new FileReader ( new File ( Settings . get ( "TEST_RESULT_PATH" ) ) ) ) ; Integer i = 1 ; while ( ( line = br . readLine ( ) ) != null ) { if ( line . startsWith ( i . toString ( ) ) ) { answers . add ( line ) ; i ++ ; } else { answers . set ( i - 2 , answers . get ( i - 2 ) . concat ( " / " + line ) ) ; } } br . close ( ) ; String [ ] appArgs = new String [ questions . size ( ) ] ; questions . toArray ( appArgs ) ; System . out . printf ( "Test data: %d questions\n" , appArgs . length ) ; Application . answer ( appArgs , answers , color ) ; } catch ( IOException e ) { ApplicationHelper . printError ( "Unable to load test file" , e ) ; } }
