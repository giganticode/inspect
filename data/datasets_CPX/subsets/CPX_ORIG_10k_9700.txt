te	1	private void assertRejected ( State < ? > s , Throwable reason ) { assertEquals ( REJECTED , s . getState ( ) ) ; assertEquals ( reason , s . getReason ( ) ) ; }
te	2	public char readChar ( String prompt ) { while ( true ) { String response = readLine ( prompt ) ; if ( response . length ( ) == 1 ) return response . charAt ( 0 ) ; println ( "You must enter exactly one letter." ) ; } }
te	1	public void setClz ( class < ? > clz ) { this . clz = clz ; }
te	4	public void enableAudio ( ) { if ( audioenabled == true ) return ; audioenabled = true ; for ( Enumeration e = channels . keys ( ) ; e . hasMoreElements ( ) ; ) { String channel = ( String ) e . nextElement ( ) ; String lastclipid = ( String ) islooping . get ( channel ) ; if ( lastclipid == null ) continue ; Hashtable chan = ( Hashtable ) channels . get ( channel ) ; AudioClip clip = ( AudioClip ) chan . get ( lastclipid ) ; if ( clip != null ) clip . loop ( ) ; } }
te	2	protected Map < ? , ? > getAttributes ( ) { return Collections . emptyMap ( ) ; }
te	3	ListObject sublist ( int init , int end ) { final ListObject l = new ListObject ( ) ; if ( init < 0 ) { init = 0 ; } if ( end > this . list . size ( ) ) { end = this . list . size ( ) ; } if ( init > end ) { init = end ; } l . list . addAll ( this . list . subList ( init , end ) ) ; return l ; }
te	8	public void paintBorder ( Color color , Graphics g , int width , int height , boolean offset ) { Color oldColor = g . getColor ( ) ; g . setColor ( color ) ; Graphics2D g2 = ( Graphics2D ) g ; Stroke oldStroke = g2 . getStroke ( ) ; Stroke stroke = new BasicStroke ( 0.5f , BasicStroke . CAP_SQUARE , BasicStroke . JOIN_MITER , 10.0f , new float [ ] { 2.0f , 4.0f , } , 0.0f ) ; g2 . setStroke ( stroke ) ; for ( int i = preferences . getGuiPixelsPerMeter ( ) / ( offset ? 2 : 1 ) ; i < width ; i += preferences . getGuiPixelsPerMeter ( ) ) { g2 . drawLine ( i , 0 , i , height ) ; } for ( int i = preferences . getGuiPixelsPerMeter ( ) / ( offset ? 2 : 1 ) ; i < height ; i += preferences . getGuiPixelsPerMeter ( ) ) { g2 . drawLine ( 0 , i , width , i ) ; } g . setColor ( Color . decode ( "#d1d1d1" ) ) ; for ( int i = preferences . getGuiPixelsPerMeter ( ) / ( offset ? 1 : 2 ) ; i < width ; i += preferences . getGuiPixelsPerMeter ( ) ) { g2 . drawLine ( i , 0 , i , height ) ; g2 . drawLine ( i , 0 , i , height ) ; } for ( int i = preferences . getGuiPixelsPerMeter ( ) / ( offset ? 1 : 2 ) ; i < height ; i += preferences . getGuiPixelsPerMeter ( ) ) { g2 . drawLine ( 0 , i , width , i ) ; g2 . drawLine ( 0 , i , width , i ) ; } g2 . setStroke ( oldStroke ) ; g2 . setColor ( oldColor ) ; }
te	6	private void FindObjectInRow ( ABObject target , List < ABObject > objects , List < ABObject > directList ) { for ( int i = 0 ; i < objects . size ( ) ; i ++ ) { if ( directList . size ( ) <= 3 ) { ABObject x = objects . get ( i ) ; if ( x . getCenterX ( ) >= target . getMaxX ( ) && x . getCenterX ( ) <= target . getMaxX ( ) + 10 ) { if ( x . getCenterY ( ) >= target . getMinY ( ) - 10 && x . getCenterY ( ) <= target . getMaxY ( ) + 10 ) { directList . add ( x ) ; } } } else break ; } }
te	4	@ Override public double valueOf ( double [ ] pars ) { double chi2 = 0.0 ; function . setParameters ( pars ) ; for ( int loop = 0 ; loop < vectorX . getSize ( ) ; loop ++ ) { double xv = vectorX . getValue ( loop ) ; double yv = vectorY . getValue ( loop ) ; if ( xv >= function . getMin ( ) && xv <= function . getMax ( ) ) { double fv = function . eval ( xv ) ; if ( yv != 0 ) { chi2 += ( yv - fv ) * ( yv - fv ) / yv ; } } } return chi2 ; }
te	4	private PosTagger ( ) { boolean instantiated = false ; while ( ! instantiated ) { try { String modelPath = Settings . get ( "POS_TAGGER_MODEL_PATH" ) ; try { tagger = new MaxentTagger ( modelPath ) ; instantiated = true ; } catch ( ClassNotFoundException e ) { ApplicationHelper . printError ( "" , e ) ; } catch ( IOException e ) { ApplicationHelper . printError ( "POS Tagger: Unable to load model file" , e ) ; } } catch ( java . lang . OutOfMemoryError e ) { ApplicationHelper . printError ( "POS Tagger: Out of memory" ) ; } } }
te	5	public static final < T extends Comparable < ? super T >> int findMaximum ( final T [ ] array ) { if ( array == null || array . length == 0 ) { return INDEX_NOT_FOUND ; } T max = array [ 0 ] ; int index = INDEX_NOT_FOUND ; for ( int i = 1 ; i < array . length ; ++ i ) { final T current = array [ i ] ; if ( max . compareTo ( current ) < 0 ) { max = current ; index = i ; } } return index ; }
te	0	@ BeforeClass public static void before ( ) throws Exception { a = new Account ( ) ; }
te	5	public Decision decideBySampling ( State s ) { player . setVerbose ( false ) ; player . setDecisionTime ( ( int ) Math . round ( decision_time * 1.0 / sample_size ) ) ; Map < Decision , double [ ] > evaluations = new LinkedHashMap < Decision , double [ ] > ( ) ; Set < Decision > decisions = s . allPossibleDecisions ( ) ; for ( Decision d : decisions ) evaluations . put ( d , new double [ sample_size ] ) ; for ( int i = 0 ; i < sample_size ; i ++ ) { State t = belief . sample ( s ) ; for ( EvaluatedDecision ed : player . evaluateDecisions ( decisions , t ) ) evaluations . get ( ed . decision ) [ i ] = ed . utility ; } Decision dbest = null ; double ubest = double . NEGATIVE_INFINITY ; for ( Map . Entry < Decision , double [ ] > entry : evaluations . entrySet ( ) ) { double u = Util . mean ( entry . getValue ( ) ) ; if ( u > ubest ) { dbest = entry . getKey ( ) ; ubest = u ; } } return dbest ; }
te	3	protected enum getAction ( MonitorAction action ) throws MonitisException { switch ( action ) { case getMonitors : return MemoryMonitorAction . agentMemory ; case getMonitorInfo : return MemoryMonitorAction . memoryInfo ; case getMonitorResults : return MemoryMonitorAction . memoryResult ; } throw new MonitisException ( "Action is not supported" ) ; }
te	1	public void dbgShowGameState ( boolean enabled ) { if ( enabled ) debugflags |= GAMESTATE_DEBUG ; else debugflags &= ~ GAMESTATE_DEBUG ; }
te	5	public static void activitythread ( ) { while ( worker ) { java . sql . Connection conn = DbController . dbconnect ( ) ; loggedin = DbController . getactivity ( conn , m_loggedas ) ; try { conn . close ( ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; } int length = loggedin . size ( ) ; for ( int i = 0 ; i < length ; i ++ ) { if ( loggedin . get ( i ) == 0 ) jTable1 . setValueAt ( "Not LoggedIn" , i , 1 ) ; else jTable1 . setValueAt ( "LoggedIn" , i , 1 ) ; } try { Thread . sleep ( 5000 ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } }
te	7	@ Override public void process ( Scanner s , CodeParser cp , OperationNode n ) { if ( Parser . gobble ( add , s ) ) n . setType ( OperationType . ADD ) ; else if ( Parser . gobble ( subtract , s ) ) n . setType ( OperationType . SUBTRACT ) ; else if ( Parser . gobble ( multiply , s ) ) n . setType ( OperationType . MULTIPLY ) ; else if ( Parser . gobble ( divide , s ) ) n . setType ( OperationType . DIVIDE ) ; else Parser . fail ( "Invalid operation type" , s ) ; if ( ! Parser . gobble ( Parser . OPENPAREN , s ) ) Parser . fail ( "No opening parenthesis in operation" , s ) ; n . setArgOne ( parseExpression ( program , s , cp , this ) ) ; if ( ! Parser . gobble ( , , s ) ) Parser . fail ( "No comma in operation" , s ) ; n . setArgTwo ( parseExpression ( program , s , cp , this ) ) ; if ( ! Parser . gobble ( Parser . CLOSEPAREN , s ) ) Parser . fail ( "No closing ) in operation" , s ) ; }
te	0	@ Override public void render ( final Render rend ) { exit . render ( rend ) ; play . render ( rend ) ; options . render ( rend ) ; rend . renderTxt ( Constants . gameName , white , Constants . getCenter ( Constants . gameName , rend , Render . bigFont ) , ( short ) 30 , false ) ; rend . renderTxt ( "Version:" + GameVersion . getVersion ( ) , white , ( short ) 0 , Constants . windowHeight , true ) ; }
te	2	void write ( long offset , ByteBuffer bf ) throws IOException { int size = 0 ; while ( bf . hasRemaining ( ) ) { int l = this . fc . write ( bf , offset + size ) ; size += l ; if ( l < 0 ) { break ; } } }
te	9	public static int tally ( int [ ] parValues , String [ ] scoreSheet ) { int score = 0 ; for ( int i = 0 ; i < parValues . length ; i ++ ) { int stroke ; switch ( scoreSheet [ i ] ) { case "triple bogey" : stroke = 3 ; break ; case "double bogey" : stroke = 2 ; break ; case "bogey" : stroke = 1 ; break ; case "par" : stroke = 0 ; break ; case "birdie" : stroke = - 1 ; break ; case "eagle" : stroke = - 2 ; break ; case "albatross" : stroke = - 3 ; break ; case "hole in one" : stroke = - 1 * ( parValues [ i ] - 1 ) ; break ; default : stroke = Integer . MIN_VALUE ; } score += parValues [ i ] + stroke ; } return score ; }
te	8	public boolean reload ( ) { if ( folder . lastModified ( ) != lastReload ) { File [ ] fa = folder . listFiles ( ) ; List < Script > scripts = new ArrayList < Script > ( ) ; for ( File f : fa ) { if ( f . isDirectory ( ) || ! f . getName ( ) . endsWith ( ".script" ) ) { continue ; } scripts . add ( getScript ( f ) ) ; } lastReload = folder . lastModified ( ) ; for ( Script script : this . scripts ) { if ( script instanceof ValidScript ) { ( ( ValidScript ) script ) . onUnload ( ) ; } } this . scripts = scripts ; for ( Script script : this . scripts ) { if ( script instanceof ValidScript ) { ( ( ValidScript ) script ) . onLoad ( ) ; } } return true ; } else { return false ; } }
te	9	private String replaceByDelimiter ( String p , MLDelimiterTypes type ) { StringBuilder target = new StringBuilder ( ) ; String [ ] splits ; switch ( type ) { case BOLD : { splits = p . split ( "'''" ) ; } break ; case ITALICS : { splits = p . split ( "''" ) ; } break ; default : { throw new RuntimeException ( "Unknown delimiter type! " + type ) ; } } if ( splits == null || splits . length < 3 ) return p ; boolean open = true ; for ( int i = 1 ; i < splits . length ; ++ i ) { String split = splits [ i ] ; if ( i == 1 ) { target . append ( splits [ 0 ] ) ; } if ( open ) { open = false ; switch ( type ) { case BOLD : { target . append ( " \\textbf{" ) ; } break ; case ITALICS : { target . append ( " \\textsl{" ) ; } } } else { open = true ; target . append ( "}" ) ; } target . append ( split ) ; } if ( ! open ) target . append ( "}" ) ; return target . toString ( ) ; }
te	9	void deleteSelected ( ) { int conNo ; int genNo ; int inNo ; Connection con ; GeneratorBox gen ; Input in ; conNo = 0 ; while ( conNo < connections . size ( ) ) { con = ( Connection ) connections . elementAt ( conNo ) ; if ( con . isSelected ( ) ) connections . removeElement ( con ) ; else conNo ++ ; } genNo = 0 ; while ( genNo < generators . size ( ) ) { gen = ( GeneratorBox ) generators . elementAt ( genNo ) ; if ( gen . isSelected ( ) ) { conNo = 0 ; while ( conNo < connections . size ( ) ) { con = ( Connection ) connections . elementAt ( conNo ) ; if ( gen == con . source ) connections . removeElement ( con ) ; else conNo ++ ; } conNo = 0 ; while ( conNo < connections . size ( ) ) { con = ( Connection ) connections . elementAt ( conNo ) ; inNo = 0 ; while ( inNo < gen . inputs . size ( ) ) { in = ( Input ) gen . inputs . elementAt ( inNo ) ; if ( in == con . dest ) { connections . removeElement ( con ) ; break ; } inNo ++ ; } if ( inNo == gen . inputs . size ( ) ) conNo ++ ; } gen . dispose ( ) ; generators . removeElement ( gen ) ; } else genNo ++ ; } repaint ( ) ; }
te	7	public static char [ ] [ ] build_block ( String plain , int row , int period , int direction ) { String plain_u = plain . toUpperCase ( ) ; if ( row == - 1 ) { row = plain_u . length ( ) / period ; } if ( plain_u . length ( ) % period != 0 ) { row ++ ; } char [ ] [ ] result = new char [ row ] [ period ] ; if ( direction == 1 ) { int cur_row = 0 ; int cur_col = 0 ; for ( int i = 0 ; i < plain_u . length ( ) ; i ++ ) { result [ cur_row ] [ cur_col ] = plain_u . charAt ( i ) ; if ( cur_row == row - 1 ) { cur_row = 0 ; cur_col ++ ; } else { cur_row ++ ; } } } else { int cur_row = 0 ; int cur_col = 0 ; for ( int i = 0 ; i < plain_u . length ( ) ; i ++ ) { result [ cur_row ] [ cur_col ] = plain_u . charAt ( i ) ; if ( cur_col == period - 1 ) { cur_row ++ ; cur_col = 0 ; } else { cur_col ++ ; } } } return result ; }
te	5	public GetMarkerControl ( String player1Marker , String player2Marker ) throws GameException { if ( player1Marker == null || player1Marker . length ( ) < 1 ) { throw new GameException ( ErrorType . ERROR105 . getMessage ( ) ) ; } player1Marker = player1Marker . substring ( 0 , 1 ) . toUpperCase ( ) ; if ( player2Marker == null || player2Marker . length ( ) < 1 ) { throw new GameException ( ErrorType . ERROR105 . getMessage ( ) ) ; } player2Marker = player2Marker . substring ( 0 , 1 ) . toUpperCase ( ) ; if ( player1Marker . equals ( player2Marker ) ) { throw new GameException ( ErrorType . ERROR106 . getMessage ( ) ) ; } this . game . getPlayer1 ( ) . setMarker ( player1Marker ) ; this . game . getPlayer2 ( ) . setMarker ( player2Marker ) ; }
te	8	public int characterAt ( int at ) throws JSONException { int c = get ( at ) ; if ( ( c & 80 ) == 0 ) { return c ; } int character ; int c1 = get ( at + 1 ) ; if ( ( c1 & 80 ) == 0 ) { character = ( ( c & 7F ) << 7 ) | c1 ; if ( character > 7F ) { return character ; } } else { int c2 = get ( at + 2 ) ; character = ( ( c & 7F ) << 14 ) | ( ( c1 & 7F ) << 7 ) | c2 ; if ( ( c2 & 80 ) == 0 && character > 3FFF && character <= 10FFFF && ( character < D800 || character > DFFF ) ) { return character ; } } throw new JSONException ( "Bad character at " + at ) ; }
te	6	@ Override public void run ( ) { while ( Server . run ) { String input = null ; try { if ( useJline ) input = reader . readLine ( ) ; else { scanner = new Scanner ( System . in ) ; input = scanner . next ( ) ; } } catch ( IOException e ) { Server . getServer ( ) . getLogger ( ) . info ( "Could not handle line!" ) ; } if ( input != null ) { if ( input . equalsIgnoreCase ( "stop" ) ) { if ( scanner != null ) scanner . close ( ) ; Server . run = false ; } } } }
te	0	public MqttConnack ( ) { super ( MqttProtocalFixedHeader . MSG_TYPE_CONNACK ) ; }
te	2	public Semester read ( String id ) { log . debug ( "reading " + entitySimpleName + " instance with id: " + id ) ; Semester instance = null ; try { instance = ( Semester ) super . read ( entityFullName , id ) ; log . debug ( entitySimpleName + " read successful  instance found" ) ; } catch ( EntityNotFoundException ex ) { log . error ( entitySimpleName + " read successful  no instance found" , ex ) ; } catch ( RuntimeException re ) { log . error ( entitySimpleName + " read failed" , re ) ; throw re ; } return instance ; }
te	3	public static void writeFile ( String fileName , String string , String charsetName , boolean append ) throws IOException { File file = new File ( fileName ) ; if ( ! file . exists ( ) && file . getParentFile ( ) != null ) { file . getParentFile ( ) . mkdirs ( ) ; } FileOutputStream fos = null ; try { fos = new FileOutputStream ( fileName , append ) ; fos . write ( string . getBytes ( charsetName ) ) ; } finally { if ( fos != null ) { fos . close ( ) ; } } }
te	6	public static void main ( String [ ] args ) { if ( args . length < 2 ) { showUsage ( ) ; } TestCore1 tester = new TestCore1 ( ) ; try { if ( args [ 0 ] . equals ( "store" ) ) { tester . store ( args ) ; } else if ( args [ 0 ] . equals ( "printMap" ) ) { tester . printMap ( args ) ; } else if ( args [ 0 ] . equals ( "update" ) ) { tester . update ( args ) ; } else if ( args [ 0 ] . equals ( "show" ) ) { tester . show ( args ) ; } else { showUsage ( ) ; } } catch ( Exception e ) { System . err . println ( "Exception caught: " + e . toString ( ) ) ; e . printStackTrace ( ) ; } }
te	8	private void updateWorkerDay ( ACTION action , String imsi , long startTime , Set days ) { int oldSize = days . size ( ) ; switch ( action ) { case ADD : days . add ( startTime ) ; break ; case REMOVE : days . remove ( startTime ) ; break ; } int newSize = days . size ( ) ; if ( ( oldSize < metrics . daysThreshold ^ newSize < metrics . daysThreshold ) || ( oldSize == metrics . daysThreshold ^ newSize == metrics . daysThreshold ) ) { listener . onChange ( imsi , newSize , metrics . daysThreshold ) ; } if ( logger . isInfoEnabled ( ) ) { if ( logger . isDebugEnabled ( ) ) { StringBuilder sb = new StringBuilder ( ) ; for ( Object start : days ) { if ( start instanceof long ) { String time = TimeUtil . getTime ( ( ( long ) start ) . longValue ( ) ) ; time = time . substring ( 0 , time . indexOf ( " " ) ) ; sb . append ( time ) ; sb . append ( " " ) ; } } logger . info ( format ( "worker days change:imsi:[%s] in [%s~%s] get days:[%s]" , imsi , time2HHMMSS ( metrics . startOfDay ) , time2HHMMSS ( metrics . endOfDay ) , sb . toString ( ) ) ) ; } else { logger . info ( format ( "worker days change:imsi:[%s] days:[%d]" , imsi , newSize ) ) ; } } }
te	0	private void setLookAndFeel ( Object laf ) { }
te	1	@ Override public void keepParametersFilter ( List < Object > listParameters ) { if ( listParameters . size ( ) == 2 ) { setI_valueMin ( ( Integer ) listParameters . get ( 0 ) ) ; setI_valueMax ( ( Integer ) listParameters . get ( 1 ) ) ; } else { System . out . println ( "Erreur de taille" ) ; } }
te	5	private void importHorizonalRelations ( int size , char [ ] [ ] hor_rel ) throws IllegalFileFormatException { for ( int row = 0 ; row < size ; row ++ ) { for ( int col = 0 ; col < size - 1 ; col ++ ) { char val = hor_rel [ row ] [ col ] ; if ( val != - ) { Point from = new Point ( row + 1 , col + 1 ) ; Point to = new Point ( row + 1 , col + 2 ) ; Cell source = getCells ( ) . get ( from ) ; Cell target = getCells ( ) . get ( to ) ; Relation forward ; Relation back ; if ( val == > ) { forward = new GreaterThan ( source , target , size ) ; back = new LessThan ( target , source , size ) ; } else if ( val == < ) { forward = new LessThan ( source , target , size ) ; back = new GreaterThan ( target , source , size ) ; } else { throw new IllegalFileFormatException ( "Illegal relation '" + val + "' in row " + row + " col " + col ) ; } source . addConstraint ( forward ) ; target . addConstraint ( back ) ; relations . put ( new Tuple ( from , to ) , forward ) ; relations . put ( new Tuple ( to , from ) , back ) ; } } } }
te	8	@ Override public void visit ( LiteralIntegral tree ) { print ( long . toString ( tree . value ) ) ; switch ( tree . numericKind ) { case LiteralNumeric . kInt8 : print ( b ) ; break ; case LiteralNumeric . kInt16 : print ( s ) ; break ; case LiteralNumeric . kInt32 : break ; case LiteralNumeric . kInt64 : print ( l ) ; break ; case LiteralNumeric . kUInt8 : print ( "ub" ) ; break ; case LiteralNumeric . kUInt16 : print ( "us" ) ; break ; case LiteralNumeric . kUInt32 : print ( u ) ; break ; case LiteralNumeric . kUInt64 : print ( "ul" ) ; break ; } }
te	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( VerPrecios . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( VerPrecios . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( VerPrecios . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( VerPrecios . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { VerPrecios dialog = new VerPrecios ( new javax . swing . JFrame ( ) , true ) ; dialog . addWindowListener ( new java . awt . event . WindowAdapter ( ) { @ Override public void windowClosing ( java . awt . event . WindowEvent e ) { System . exit ( 0 ) ; } } ) ; dialog . setVisible ( true ) ; } } ) ; }
te	2	public static _Fields findByThriftId ( int fieldId ) { switch ( fieldId ) { case 1 : return DATA ; case 2 : return ID ; default : return null ; } }
te	5	private void consumeFutureUninterruptible ( Future < ? > f ) { try { boolean interrupted = false ; while ( true ) { try { f . get ( ) ; break ; } catch ( InterruptedException e ) { interrupted = true ; } } if ( interrupted ) Thread . currentThread ( ) . interrupt ( ) ; } catch ( ExecutionException e ) { throw new RuntimeException ( e ) ; } }
te	5	private boolean findPath ( int u ) { visx [ u ] = true ; for ( int v = 0 ; v < T ; ++ v ) { Utils . assert ( x [ u ] + y [ v ] + eps >= f [ u * T + v ] ) ; if ( visy [ v ] == false && x [ u ] + y [ v ] <= f [ u * T + v ] + eps ) { visy [ v ] = true ; int w = find [ v ] ; find [ v ] = u ; if ( w == - 1 || findPath ( w ) ) return true ; find [ v ] = w ; } } return false ; }
te	0	@ Test ( expected = InvalidParameterException . class ) public void testUpdateBedKeyMismatch1 ( ) throws DataBaseReadWriteException , IdentifierNotFoundException , InvalidIdentifierException , IdentifierAlreadyExistsException , InvalidParameterException { Hostel hostelInfo = new Hostel ( ) ; hostelInfo . setName ( "test" ) ; Identifier hostelId = db . addHostel ( hostelInfo ) ; Bed info1 = new Bed ( ) ; info1 . setNumber ( 1 ) ; info1 . setRoomNo ( 1 ) ; info1 . setHostelId ( hostelId ) ; Identifier id = db . addBed ( info1 ) ; info1 . setNumber ( 2 ) ; db . updateBed ( id , info1 ) ; }
te	1	public synchronized boolean update ( ) throws SQLException { Connection connection = null ; PreparedStatement prepStmt = null ; try { connection = DB . getConnection ( ) ; connection . setAutoCommit ( true ) ; int affectedRows = 0 ; String sql = "UPDATE Product SET SupplierID = ?  Price = ?  ProductName = ?  ProductDescription = ?  InStock = ? WHERE ProductID = ?" ; prepStmt = connection . prepareStatement ( sql ) ; prepStmt . setInt ( 1 , this . SupplierID ) ; prepStmt . setDouble ( 2 , this . Price ) ; prepStmt . setString ( 3 , this . ProductName ) ; prepStmt . setString ( 4 , this . ProductDescription ) ; prepStmt . setBoolean ( 5 , this . InStock ) ; prepStmt . setInt ( 6 , this . ProductID ) ; affectedRows = prepStmt . executeUpdate ( ) ; prepStmt . close ( ) ; DB . closeConnection ( ) ; return affectedRows > 0 ; } catch ( Exception e ) { throw e ; } }
te	5	@ Override public double [ ] getDoubleData ( ) { if ( ptr != 0 ) { return null ; } else { if ( isConstant ( ) ) { if ( length > getMaxSizeOf32bitArray ( ) ) return null ; double [ ] out = new double [ ( int ) length ] ; double elem = ( double ) data [ 0 ] ; for ( int i = 0 ; i < length ; i ++ ) { out [ i ] = elem ; } return out ; } else { double [ ] out = new double [ ( int ) length ] ; for ( int i = 0 ; i < length ; i ++ ) { out [ i ] = ( double ) data [ i ] ; } return out ; } } }
te	8	public void criarObjetoObj ( ) throws IOException { ArrayList < CoordenadasHomogeneas > listaCoords = new ArrayList < CoordenadasHomogeneas > ( ) ; ArrayList < CoordenadasHomogeneas > subListaCoords = null ; BufferedReader br = new BufferedReader ( new FileReader ( file ) ) ; String linha ; ArrayList < ArrayList < CoordenadasHomogeneas >> listaDeFaces = new ArrayList < > ( ) ; while ( ( linha = br . readLine ( ) ) != null ) { String [ ] campos = linha . split ( " " ) ; String tipo = campos [ 0 ] ; CoordenadasHomogeneas coord ; if ( tipo . equals ( "v" ) ) { coord = new CoordenadasHomogeneas ( ( escal * double . parseDouble ( campos [ 1 ] ) ) , escal * double . parseDouble ( campos [ 2 ] ) , escal * double . parseDouble ( campos [ 3 ] ) ) ; listaCoords . add ( coord ) ; } if ( tipo . equals ( "f" ) ) { subListaCoords = new ArrayList < CoordenadasHomogeneas > ( ) ; boolean o3d = false ; for ( CoordenadasHomogeneas c : listaCoords ) { if ( c . getZD ( ) != 1.0 ) { o3d = true ; } } for ( int i = 1 ; i < campos . length ; i ++ ) { subListaCoords . add ( listaCoords . get ( Integer . parseInt ( ( campos [ i ] . split ( "/" ) [ 0 ] ) ) - 1 ) ) ; } if ( o3d ) { for ( int i = 1 ; i < campos . length ; i ++ ) { subListaCoords . add ( listaCoords . get ( Integer . parseInt ( ( campos [ i ] . split ( "/" ) [ 0 ] ) ) - 1 ) ) ; } listaDeFaces . add ( subListaCoords ) ; Mundo . getInstance ( ) . incluirPoliedro ( listaDeFaces , cor , false ) ; } else { Mundo . getInstance ( ) . incluirObjeto ( subListaCoords , cor , false ) ; } } } br . close ( ) ; InterfaceGrafica . getInstance ( ) . exibirObjetos ( ) ; }
te	1	public FHashMap < Key , Val > with ( Key key , Val value , BinaryOp < Val > valCombiner ) { Object t = with ( tree , key , hashCode ( key ) , value , valCombiner ) ; if ( t == tree ) return this ; else return new FHashMap < Key , Val > ( t , dflt ) ; }
te	8	private int addRhythm ( double duration , int pitch , boolean stemup , int currentTick , int row , int newXPos ) { int tick = currentTick ; int velocity = 71 ; boolean silence = false ; final int TEXT = 01 ; String text = "off" ; int tmpdiv = 1 ; int tmpnum = 4 ; if ( selectedGame == RHYTHMREADING ) { silence = rhythmLevel . getSilence ( ) ; tmpdiv = rhythmLevel . getTimeDivision ( ) ; tmpnum = rhythmLevel . getTimeSignNumerator ( ) ; rhythmLevel . getTimeSignDenominator ( ) ; } else if ( selectedGame == SCOREREADING ) { silence = scoreLevel . getSilence ( ) ; tmpdiv = scoreLevel . getTimeDivision ( ) ; tmpnum = scoreLevel . getTimeSignNumerator ( ) ; scoreLevel . getTimeSignDenominator ( ) ; } if ( duration == 0.333 ) { silence = false ; } System . out . println ( "[addRhythm] pitch: " + pitch + "duration: " + duration + "stemup " + stemup ) ; double tmpsilence = Math . random ( ) ; if ( ! silence || ( silence && tmpsilence < 0.85 ) || ( duration == 3 && tmpnum != 3 ) ) { rhythms . add ( new Rhythm ( duration , newXPos , pitch , row , stemup , false , false , 0 ) ) ; track . add ( createNoteOnEvent ( pitch , velocity , tick ) ) ; mutetrack . add ( createNoteOnEvent ( pitch , 0 , tick ) ) ; tick += ( int ) ( ( duration * tmpdiv ) * ppq ) ; addEvent ( track , TEXT , text . getBytes ( ) , tick ) ; addEvent ( mutetrack , TEXT , text . getBytes ( ) , tick ) ; track . add ( createNoteOffEvent ( pitch , tick ) ) ; mutetrack . add ( createNoteOffEvent ( pitch , tick ) ) ; } else { rhythms . add ( new Rhythm ( duration , newXPos , pitch , row , false , false , true , 0 ) ) ; track . add ( createNoteOffEvent ( pitch , tick ) ) ; mutetrack . add ( createNoteOffEvent ( pitch , tick ) ) ; tick += ( int ) ( ( duration * tmpdiv ) * ppq ) ; addEvent ( track , TEXT , text . getBytes ( ) , tick ) ; addEvent ( mutetrack , TEXT , text . getBytes ( ) , tick ) ; } return tick ; }
te	0	public ActionListener buildExitActionListener ( ) { return new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { System . exit ( 0 ) ; } } ; }
te	7	public Node [ ] naiveER ( int n , int l ) { double p = ( double ) ( 2 * l ) / ( double ) ( n * ( n - 1 ) ) ; System . out . println ( "Value for p: " + p ) ; Random gen = new Random ( ) ; Set [ ] nodes = new Set [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { nodes [ i ] = new HashSet < Integer > ( ) ; } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( gen . nextDouble ( ) <= p ) { nodes [ i ] . add ( j ) ; nodes [ j ] . add ( i ) ; } } } Node [ ] network = new Node [ n ] ; for ( int i = 0 ; i < network . length ; i ++ ) { network [ i ] = new Node ( i , nodes [ i ] . size ( ) ) ; } int lc = 0 ; for ( int i = 0 ; i < network . length ; i ++ ) { for ( int j : ( Set < Integer > ) nodes [ i ] ) { network [ i ] . addLink ( network [ j ] ) ; lc ++ ; } } System . out . println ( "Network has " + n + " nodes and " + lc / 2 + " links" ) ; return network ; }
te	8	public static void getBounds ( AABB aabb , Vector3f [ ] vertices ) { if ( vertices != null ) { float minX = float . POSITIVE_INFINITY ; float minY = float . POSITIVE_INFINITY ; float minZ = float . POSITIVE_INFINITY ; float maxX = float . NEGATIVE_INFINITY ; float maxY = float . NEGATIVE_INFINITY ; float maxZ = float . NEGATIVE_INFINITY ; for ( final Vector3f vertex : vertices ) { if ( vertex . x < minX ) { minX = vertex . x ; } else if ( vertex . x > maxX ) { maxX = vertex . x ; } if ( vertex . y < minY ) { minY = vertex . y ; } else if ( vertex . y > maxY ) { maxY = vertex . y ; } if ( vertex . z < minZ ) { minZ = vertex . z ; } else if ( vertex . z > maxZ ) { maxZ = vertex . z ; } } final float hx = Math . abs ( maxX - minX ) / 2 ; final float hy = Math . abs ( maxY - minY ) / 2 ; final float hz = Math . abs ( maxZ - minZ ) / 2 ; aabb . setPosition ( maxX - hx , maxY - hy , maxZ - hz ) ; aabb . setHalfsize ( hx + 0.001f , hy + 0.001f , hz + 0.001f ) ; } }
te	1	public void startOutputConnection ( ) { try { fWriter = new FileWriter ( "xStreamProducts" ) ; os = xstream . createObjectOutputStream ( fWriter , "waren" ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } connectionOutStatus = true ; }
te	0	public void setServer_id ( String value ) { otapiJNI . ContactAcct_server_id_set ( swigCPtr , this , value ) ; }
te	9	public int minDistance ( String word1 , String word2 ) { if ( word1 == null || word2 == null ) return 0 ; int m = word1 . length ( ) ; int n = word2 . length ( ) ; if ( m == 0 ) return n ; if ( n == 0 ) return m ; int d [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ; d [ 0 ] [ 0 ] = 0 ; for ( int i = 1 ; i <= m ; i ++ ) { d [ i ] [ 0 ] = i ; } for ( int j = 1 ; j <= n ; j ++ ) d [ 0 ] [ j ] = j ; for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { int del = d [ i - 1 ] [ j ] + 1 ; int ins = d [ i ] [ j - 1 ] + 1 ; int - = d [ i - 1 ] [ j - 1 ] ; if ( word1 . charAt ( i - 1 ) != word2 . charAt ( j - 1 ) ) - += 1 ; int min = del < ins ? del : ins ; min = - < min ? - : min ; d [ i ] [ j ] = min ; } } return d [ m ] [ n ] ; }
te	1	public ObjectMatch tryUnmarshall ( SerializerState state , class clazz , Object jso ) throws UnmarshallException { try { toPrimitive ( clazz , jso ) ; } catch ( NumberFormatException e ) { throw new UnmarshallException ( "not a primitive" , e ) ; } state . setSerialized ( jso , ObjectMatch . OKAY ) ; return ObjectMatch . OKAY ; }
te	6	public static String unescape ( String string ) { int length = string . length ( ) ; StringBuffer sb = new StringBuffer ( ) ; for ( int i = 0 ; i < length ; ++ i ) { char c = string . charAt ( i ) ; if ( c == + ) { c =   ; } else if ( c == % && i + 2 < length ) { int d = JSONTokener . dehexchar ( string . charAt ( i + 1 ) ) ; int e = JSONTokener . dehexchar ( string . charAt ( i + 2 ) ) ; if ( d >= 0 && e >= 0 ) { c = ( char ) ( d * 16 + e ) ; i += 2 ; } } sb . append ( c ) ; } return sb . toString ( ) ; }
te	3	@ Override public ByteBuffer getMessage ( ) { for ( int i = 16 ; i < 20 ; i ++ ) { uiMode [ i ] = ( short ) ffff ; } uiSetVoltage [ 1 ] = ( short ) 1999 ; ByteBuffer buffer = ByteBuffer . allocate ( 86 ) ; buffer . order ( ByteOrder . LITTLE_ENDIAN ) ; buffer . putShort ( ( short ) aaa0 ) ; buffer . putShort ( ( short ) 86 ) ; for ( short val : uiMode ) { buffer . putShort ( val ) ; } for ( short val : uiSetVoltage ) { buffer . putShort ( val ) ; } short checksum = ( short ) Utilities . checksum ( buffer , 0 , 84 ) ; buffer . putShort ( checksum ) ; return buffer ; }
te	6	public void explore ( ) { if ( ! isDirectory ( ) ) return ; if ( ! isExplored ( ) ) { File file = getFile ( ) ; File [ ] children = file . listFiles ( ) ; for ( int i = 0 ; i < children . length ; ++ i ) { if ( children [ i ] . isDirectory ( ) ) add ( new FileNode ( children [ i ] ) ) ; } for ( int i = 0 ; i < children . length ; ++ i ) { if ( ! children [ i ] . isDirectory ( ) ) add ( new FileNode ( children [ i ] ) ) ; } explored = true ; } }
te	8	public String execute ( String s ) { if ( s . matches ( "OUVRIR.* COFFRE" ) ) { if ( coffreOuvert ) return "Le coffre est d\u00E9j\u00E0 ouvert." ; coffreOuvert = true ; return "Le coffre s'ouvre et un \u00E9pais nuage de poussi\u00E8re en sort. Il y a une cl\u00E9 dans le fond." ; } else if ( s . matches ( "PRENDRE.* CL.*" ) ) { if ( coffreOuvert && ! InventoryManager . getInstance ( ) . hasItem ( "Cl\u00E9" ) ) { InventoryManager . getInstance ( ) . addItem ( "Cl\u00E9" ) ; return "Vous ramassez la cl\u00E9." ; } } else if ( s . matches ( "UTILISER.* CL.* PORTE" ) ) { if ( InventoryManager . getInstance ( ) . hasItem ( "Cl\u00E9" ) ) { isPorteOuverte = true ; InventoryManager . getInstance ( ) . removeItem ( "Cl\u00E9" ) ; return "La porte est maintenant ouverte." ; } } else if ( s . matches ( "MOURIR" ) ) { PlayerManager . getInstance ( ) . dropLife ( 1000000000 ) ; return "Tu est mort" ; } return null ; }
te	0	public Date getDate ( int columnIndex ) throws SQLException { throw new UnsupportedOperationException ( "Not supported yet." ) ; }
te	0	public MultipleNetwork ( BasicNetwork n ) { super ( n ) ; }
te	5	@ Override public Object invoke ( Object proxy , Method method , Object [ ] args ) throws Throwable { if ( method . isDefault ( ) ) { final class < ? > declaringClass = method . getDeclaringClass ( ) ; final MethodHandles . Lookup lookup = MethodHandles . publicLookup ( ) . in ( declaringClass ) ; final Field f = MethodHandles . Lookup . class . getDeclaredField ( "allowedModes" ) ; final int modifiers = f . getModifiers ( ) ; if ( Modifier . isFinal ( modifiers ) ) { final Field modifiersField = Field . class . getDeclaredField ( "modifiers" ) ; modifiersField . setAccessible ( true ) ; modifiersField . setInt ( f , modifiers & ~ Modifier . final ) ; f . setAccessible ( true ) ; f . set ( lookup , MethodHandles . Lookup . private ) ; } return lookup . unreflectSpecial ( method , declaringClass ) . bindTo ( proxy ) . invokeWithArguments ( args ) ; } if ( args . length == 0 ) { return ( ( QueryMonoid ) proxy ) . empty ( ) ; } else if ( args . length == 1 ) { return ( ( QueryMonoid ) proxy ) . unit ( args [ 0 ] ) ; } else { return ( ( QueryMonoid ) proxy ) . fold ( Arrays . asList ( args ) ) ; } }
te	3	public static String toString ( JSONObject jo ) throws JSONException { boolean b = false ; Iterator keys = jo . keys ( ) ; String string ; StringBuffer sb = new StringBuffer ( ) ; while ( keys . hasNext ( ) ) { string = keys . next ( ) . toString ( ) ; if ( ! jo . isNull ( string ) ) { if ( b ) { sb . append ( ; ) ; } sb . append ( Cookie . escape ( string ) ) ; sb . append ( "=" ) ; sb . append ( Cookie . escape ( jo . getString ( string ) ) ) ; b = true ; } } return sb . toString ( ) ; }
te	6	public void setPrint ( Speedtype tp ) { switch ( tp ) { case PRINT : if ( type == Speedtype . TRAVEL || type == Speedtype . BOTH ) { type = Speedtype . BOTH ; } else { type = Speedtype . PRINT ; } break ; case TRAVEL : if ( type == Speedtype . PRINT || type == Speedtype . BOTH ) { type = Speedtype . BOTH ; } else { type = Speedtype . TRAVEL ; } break ; default : type = tp ; break ; } }
te	5	private void createAndShowGUI ( ) { final JFrame frame = new JFrame ( "EDASOMIND" ) ; frame . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; frame . setExtendedState ( java . awt . Frame . MAXIMIZED_BOTH ) ; frame . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; JButton button = new JButton ( "Select File" ) ; button . setSize ( 300 , 100 ) ; button . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent ae ) { FileDialog dialog = new FileDialog ( frame , "Load Java-File" , FileDialog . LOAD ) ; dialog . setFile ( "*.java" ) ; dialog . setVisible ( true ) ; File f = new File ( dialog . getDirectory ( ) + dialog . getFile ( ) ) ; if ( f . exists ( ) ) try { EdasomindResultList result = EdasomindAccessFactory . getHome ( ) . analyzeFile ( f ) ; dh . setResult ( result ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } } ) ; GridLayout l = new GridLayout ( 2 , 1 ) ; frame . setLayout ( l ) ; Container c = frame . getContentPane ( ) ; EDASOMINDTableModel tm = new EDASOMINDTableModel ( dh ) ; JTable table = new JTable ( tm ) ; TableCellRenderer ren = new EDASOMINDTableCellRenderer ( dh ) ; table . setDefaultRenderer ( Object . class , ren ) ; c . add ( button ) ; c . add ( new JScrollPane ( table ) ) ; String className = "com.apple.eawt.FullScreenUtilities" ; String methodName = "setWindowCanFullScreen" ; try { class < ? > clazz = class . forName ( className ) ; Method method = clazz . getMethod ( methodName , new class < ? > [ ] { Window . class , boolean . class } ) ; method . invoke ( null , frame , true ) ; } catch ( Throwable t ) { System . err . println ( "Full screen mode is not supported" ) ; } frame . pack ( ) ; frame . setVisible ( true ) ; }
te	3	public static int count123 ( String str ) { int szCount = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { char c = str . charAt ( i ) ; if ( c >= 0 && c <= 9 ) { szCount ++ ; } } System . out . println ( "\u6570\u5B57\uFF1A" + szCount ) ; return szCount ; }
te	1	public void setComposite ( final int k ) { assert ( k >= 3 ) && ( ( k % 2 ) == 1 ) ; sieve . set ( ( k - 3 ) / 2 ) ; }
te	3	public List < Vuelo > getVuelos ( ) { final ArrayList < Vuelo > vuelos = new ArrayList < Vuelo > ( ) ; for ( int i = 0 ; i < maximo ; i ++ ) for ( int j = 0 ; j < maximo ; j ++ ) { if ( this . existeVuelo ( getCiudad ( i ) , getCiudad ( j ) ) ) { Vuelo v = new Vuelo ( getCiudad ( i ) , getCiudad ( j ) , this . obtenerPrecio ( getCiudad ( i ) , getCiudad ( j ) ) ) ; vuelos . add ( v ) ; } } return vuelos ; }
te	9	public static JSONArray rowToJSONArray ( JSONTokener x ) throws JSONException { JSONArray ja = new JSONArray ( ) ; for ( ; ; ) { String value = getValue ( x ) ; char c = x . next ( ) ; if ( value == null || ( ja . length ( ) == 0 && value . length ( ) == 0 && c !=   ) ) { return null ; } ja . put ( value ) ; for ( ; ; ) { if ( c ==   ) { break ; } if ( c !=   ) { if ( c == '' || c == '' || c == 0 ) { return ja ; } throw x . syntaxError ( "Bad character '" + c + "' (" + ( int ) c + ")." ) ; } c = x . next ( ) ; } } }
te	1	public void openAction ( ActionEvent actionEvent ) { if ( AppCore . ports . open ) { AppCore . ports . closePort ( ) ; } else { AppCore . ports . openPort ( ) ; } }
te	8	void codenot ( ExpDesc e ) { this . dischargevars ( e ) ; switch ( e . k ) { case LexState . VNIL : case LexState . VFALSE : { e . k = LexState . VTRUE ; break ; } case LexState . VK : case LexState . VKNUM : case LexState . VTRUE : { e . k = LexState . VFALSE ; break ; } case LexState . VJMP : { this . invertjump ( e ) ; break ; } case LexState . VRELOCABLE : case LexState . VNONRELOC : { this . discharge2anyreg ( e ) ; this . freeexp ( e ) ; e . info = this . codeABC ( OP_NOT , 0 , e . info , 0 ) ; e . k = LexState . VRELOCABLE ; break ; } default : { _assert ( false ) ; break ; } } { int temp = e . f ; e . f = e . t ; e . t = temp ; } this . removevalues ( e . f ) ; this . removevalues ( e . t ) ; }
te	4	public void fillPrimalCoefficients ( ) { setPrimalCoefficientsDimensions ( ) ; int currentState = 0 ; int currentAction = 0 ; int count = mdpData . getStateList ( ) . get ( currentState ) . getNoOfActions ( ) ; for ( int i = 0 ; i < mdpData . getNoOfActions ( ) ; i ++ ) { if ( count == 0 ) { currentState ++ ; count = mdpData . getStateList ( ) . get ( currentState ) . getNoOfActions ( ) ; currentAction = 0 ; } for ( int j = 0 ; j < mdpData . getNoOfStates ( ) ; j ++ ) { if ( j == currentState ) { primalCoefficients [ i ] [ j ] = 1 - mdpData . getGamma ( ) * ( mdpData . getStateList ( ) . get ( currentState ) . getActionList ( ) . get ( currentAction ) . getTransitionFunc ( ) . get ( j ) ) ; } else primalCoefficients [ i ] [ j ] = ( - 1 ) * mdpData . getGamma ( ) * ( mdpData . getStateList ( ) . get ( currentState ) . getActionList ( ) . get ( currentAction ) . getTransitionFunc ( ) . get ( j ) ) ; } currentAction ++ ; count -- ; } }
te	2	public MainFrame ( ) { setIconImage ( Toolkit . getDefaultToolkit ( ) . getImage ( MainFrame . class . getResource ( "/de/tr0llhoehle/buschtrommel/gui/res/djembe.png" ) ) ) ; setTitle ( "Bongo" ) ; initComponents ( ) ; String hostname = String . valueOf ( Math . random ( ) ) ; try { hostname = java . net . InetAddress . getLocalHost ( ) . getHostName ( ) ; } catch ( UnknownHostException e ) { LoggerWrapper . logError ( "Couldn't get hostname" ) ; } buschtrommel = new Buschtrommel ( this , "Bongo@" + hostname ) ; try { buschtrommel . start ( ) ; } catch ( IOException ex ) { Logger . getLogger ( MainFrame . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; JOptionPane . showMessageDialog ( null , ex ) ; } filesHostsTable . setAutoCreateRowSorter ( true ) ; localSharesTable . setModel ( sharesModel ) ; localSharesTable . setAutoCreateRowSorter ( true ) ; downloadFolder . setText ( Config . defaultDownloadFolder ) ; viewFilelistTransfersBox . setSelected ( Config . showFileListTransfers ) ; v4Checkbox . setSelected ( Config . useIPv4 ) ; v6Checkbox . setSelected ( Config . useIPv6 ) ; enableHashCheckBox . setSelected ( Config . hashCheckEnabled ) ; readOldLocalShares ( ) ; setupTimer ( ) ; }
te	3	public void alustaTeema ( ) { switch ( teemaNum ) { case 0 : teemaBlackWhite ( ) ; break ; case 1 : teemaOceanBlue ( ) ; break ; case 2 : teemaGrandCanyon ( ) ; break ; } }
te	9	public Character nextCharacter ( int playerId , Character selectedDwarf ) { if ( mapping . isEmpty ( ) ) return null ; ArrayList < Character > options = new ArrayList < Character > ( ) ; for ( Character character : mapping . values ( ) ) if ( character . playerId ( ) == playerId ) options . add ( character ) ; if ( options . size ( ) == 0 ) return null ; if ( ( selectedDwarf != null ) && ( ! mapping . containsKey ( selectedDwarf . id ( ) ) ) ) selectedDwarf = null ; if ( selectedDwarf == null ) { Random random = new Random ( ) ; return options . get ( random . nextInt ( options . size ( ) ) ) ; } Collections . sort ( options , new Comparator < Character > ( ) { public int compare ( Character o1 , Character o2 ) { return o1 . id ( ) . compareTo ( o2 . id ( ) ) ; } } ) ; int idx = 0 ; for ( int i = 0 ; i < options . size ( ) ; ++ i ) { if ( options . get ( i ) . id ( ) . equals ( selectedDwarf . id ( ) ) ) idx = i ; } idx = ( idx + 1 ) % options . size ( ) ; return options . get ( idx ) ; }
te	5	public void run ( ) { if ( fcrunoption == CAppConsts . RunFC1 || fcrunoption == CAppConsts . RunBothFC ) { if ( fc1 . equals ( CAppConsts . DefaultForecaster ) ) { runmcir ( ) ; } else { fc1nm = CForecasters . getFCname ( fc1 ) ; fc1url = CForecasters . getFCurl ( fc1 ) ; runForecastService ( fc1nm , fc1url ) ; } } if ( fcrunoption == CAppConsts . RunFC2 || fcrunoption == CAppConsts . RunBothFC ) { fc2nm = CForecasters . getFCname ( fc2 ) ; fc2url = CForecasters . getFCurl ( fc2 ) ; runForecastService ( fc2nm , fc2url ) ; } }
te	7	public int solution ( final int [ ] input ) { final int N = input . length ; int candidate = 0 ; int candidateIndex = - 1 ; int candidateOccurrences = 0 ; for ( int i = 0 ; i < N ; i ++ ) { final int value = input [ i ] ; if ( candidateOccurrences == 0 ) { candidate = value ; candidateIndex = i ; candidateOccurrences ++ ; } else if ( value == candidate ) { candidateOccurrences ++ ; } else { candidateOccurrences -- ; } } candidateOccurrences = 0 ; final double minNbOccurrences = N / 2.0 ; for ( int i = 0 ; i < input . length ; i ++ ) { final int value = input [ i ] ; if ( value == candidate ) { candidateIndex = i ; candidateOccurrences ++ ; if ( candidateOccurrences > minNbOccurrences ) { break ; } } } return candidateOccurrences > minNbOccurrences ? candidateIndex : - 1 ; }
te	4	private void showChildren ( final DefaultMutableTreeNode node ) { tree . setEnabled ( false ) ; progressBar . setVisible ( true ) ; progressBar . setIndeterminate ( true ) ; SwingWorker < void , File > worker = new SwingWorker < void , File > ( ) { @ Override public void doInBackground ( ) { File file = ( File ) node . getUserObject ( ) ; if ( file . isDirectory ( ) ) { File [ ] files = fileSystemView . getFiles ( file , true ) ; for ( File child : files ) { if ( child . isDirectory ( ) ) { publish ( child ) ; } } setTableData ( files ) ; } return null ; } @ Override protected void process ( List < File > chunks ) { System . out . println ( "cool story bro !" ) ; node . removeAllChildren ( ) ; for ( File child : chunks ) { System . out . println ( "FILE NAME: " + child . getName ( ) ) ; node . add ( new DefaultMutableTreeNode ( child ) ) ; } treeModel . nodeStructureChanged ( node ) ; } @ Override protected void done ( ) { progressBar . setIndeterminate ( false ) ; progressBar . setVisible ( false ) ; tree . setEnabled ( true ) ; } } ; worker . execute ( ) ; }
te	2	@ Override public int hashCode ( ) { int result = svnPath != null ? svnPath . hashCode ( ) : 0 ; result = 31 * result + ( repositoryUrl != null ? repositoryUrl . hashCode ( ) : 0 ) ; return result ; }
te	0	@ Override protected void configure ( ) { }
te	2	@ Override protected void handleKeyDownEvent ( KeyboardEvent e ) { if ( e . getKey ( ) == Keyboard . KEY_RETURN || e . getKey ( ) == Keyboard . KEY_SPACE ) { Menu optionsMenu = ( Menu ) ServiceManager . getInstance ( ) . getGUIManager ( ) . getNamedComponent ( "optionsMenu" ) ; optionsMenu . setHidden ( true ) ; ServiceManager . getInstance ( ) . getGUIManager ( ) . popComponentFromFocusStack ( ) ; } }
te	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( InsertBook . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( InsertBook . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( InsertBook . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( InsertBook . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { new InsertBook ( ) . setVisible ( true ) ; } } ) ; }
te	0	public ControllerFreeMove ( float speed , int RYAxis , int RXAxis , int speedbutton ) { this . speed = speed ; this . RYAxis = RYAxis ; this . RXAxis = RXAxis ; this . speedbutton = speedbutton ; }
te	0	public int getY ( ) { return yCoordinate ; }
te	0	public double getDomesticMig2010 ( ) { return domesticMig2010 ; }
te	7	public void genC ( PW pw ) { pw . printIdent ( "" ) ; pw . print ( getType ( ) . getCName ( ( getType ( ) instanceof ClassDec ) ) ) ; pw . print ( " " ) ; if ( isIsStatic ( ) ) { pw . print ( "_static" ) ; } pw . print ( "_" + getClassDec ( ) . getName ( ) + "_" + getName ( ) ) ; pw . print ( "(" ) ; if ( ! isIsStatic ( ) ) { pw . print ( "_class_" + getClassDec ( ) . getName ( ) + " *this" ) ; } if ( getParamList ( ) != null && getParamList ( ) . getSize ( ) > 0 ) { if ( ! isIsStatic ( ) ) pw . print ( " " ) ; getParamList ( ) . genC ( pw ) ; } pw . println ( "){" ) ; if ( getStatementList ( ) != null ) { for ( int i = 0 ; i < getStatementList ( ) . size ( ) ; i ++ ) { Statement statement = getStatementList ( ) . get ( i ) ; statement . genC ( pw ) ; } } pw . printIdent ( "}\n" ) ; }
te	2	private void txmsgTextFieldActionPerformed ( java . awt . event . ActionEvent evt ) { try { snmp . snmpSetString ( "770" , txmsgTextField . getText ( ) ) ; } catch ( Exception ex ) { } try { txmsgTextField . setText ( snmp . snmpGetString ( "770" ) ) ; } catch ( Exception ex ) { Logger . getLogger ( UP4DAR_Configurator . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } }
te	1	public BigInteger degree ( ) { if ( degrees . isEmpty ( ) ) return BigInteger . ONE . negate ( ) ; return degrees . first ( ) ; }
te	3	public boolean contains ( R range ) { R leftmost = set . floor ( range ) ; R rightmost = set . ceiling ( range ) ; return ( leftmost != null && leftmost . contains ( range ) ) || ( rightmost != null && rightmost . contains ( range ) ) ; }
te	7	static void dradf2 ( int ido , int l1 , float [ ] cc , float [ ] ch , float [ ] wa1 , int index ) { int i , k ; float ti2 , tr2 ; int t0 , t1 , t2 , t3 , t4 , t5 , t6 ; t1 = 0 ; t0 = ( t2 = l1 * ido ) ; t3 = ido << 1 ; for ( k = 0 ; k < l1 ; k ++ ) { ch [ t1 << 1 ] = cc [ t1 ] + cc [ t2 ] ; ch [ ( t1 << 1 ) + t3 - 1 ] = cc [ t1 ] - cc [ t2 ] ; t1 += ido ; t2 += ido ; } if ( ido < 2 ) return ; if ( ido != 2 ) { t1 = 0 ; t2 = t0 ; for ( k = 0 ; k < l1 ; k ++ ) { t3 = t2 ; t4 = ( t1 << 1 ) + ( ido << 1 ) ; t5 = t1 ; t6 = t1 + t1 ; for ( i = 2 ; i < ido ; i += 2 ) { t3 += 2 ; t4 -= 2 ; t5 += 2 ; t6 += 2 ; tr2 = wa1 [ index + i - 2 ] * cc [ t3 - 1 ] + wa1 [ index + i - 1 ] * cc [ t3 ] ; ti2 = wa1 [ index + i - 2 ] * cc [ t3 ] - wa1 [ index + i - 1 ] * cc [ t3 - 1 ] ; ch [ t6 ] = cc [ t5 ] + ti2 ; ch [ t4 ] = ti2 - cc [ t5 ] ; ch [ t6 - 1 ] = cc [ t5 - 1 ] + tr2 ; ch [ t4 - 1 ] = cc [ t5 - 1 ] - tr2 ; } t1 += ido ; t2 += ido ; } if ( ido % 2 == 1 ) return ; } t3 = ( t2 = ( t1 = ido ) - 1 ) ; t2 += t0 ; for ( k = 0 ; k < l1 ; k ++ ) { ch [ t1 ] = - cc [ t2 ] ; ch [ t1 - 1 ] = cc [ t3 ] ; t1 += ido << 1 ; t2 += ido ; t3 += ido ; } }
te	9	public int transfer ( InputStream in , OutputStream out , int numberOfBytes , int offset ) throws IOException { if ( offset < 0 && numberOfBytes < - 1 ) { throw new IllegalArgumentException ( ) ; } in . skip ( offset ) ; if ( numberOfBytes == - 1 ) { while ( ( readBytes = in . read ( buff ) ) != - 1 ) { out . write ( buff , 0 , readBytes ) ; byteCounter += readBytes ; } return byteCounter ; } if ( buff . length >= numberOfBytes ) { in . read ( buff , 0 , numberOfBytes ) ; out . write ( buff , 0 , numberOfBytes ) ; return numberOfBytes ; } while ( ( readBytes = in . read ( buff ) ) != - 1 ) { if ( numberOfBytes > 0 && ( ( readBytes = in . read ( buff , 0 , buff . length ) ) != - 1 ) ) { byteCounter += readBytes ; out . write ( buff , 0 , readBytes ) ; } if ( readBytes + byteCounter > numberOfBytes ) { availableBytes = numberOfBytes - byteCounter ; byteCounter += availableBytes ; } in . read ( buff , 0 , readBytes ) ; out . write ( buff , 0 , availableBytes ) ; if ( numberOfBytes == byteCounter ) { return numberOfBytes ; } } return numberOfBytes ; }
te	4	@ Override public String getAsString ( FacesContext facesContext , UIComponent component , Object object ) { if ( object == null || ( object instanceof String && ( ( String ) object ) . length ( ) == 0 ) ) { return null ; } if ( object instanceof Actor ) { Actor o = ( Actor ) object ; return getStringKey ( o . getIdActor ( ) ) ; } else { Logger . getLogger ( this . getClass ( ) . getName ( ) ) . log ( Level . SEVERE , "object {0} is of type {1}; expected type: {2}" , new Object [ ] { object , object . getClass ( ) . getName ( ) , Actor . class . getName ( ) } ) ; return null ; } }
te	6	public void superquadric ( Matrix mat , double p , double h ) { if ( child != null ) { for ( int i = 0 ; i < child . length ; i ++ ) if ( child [ i ] != null ) { Matrix tmp = new Matrix ( ) ; tmp . copy ( mat ) ; tmp . preMultiply ( child [ i ] . matrix ) ; child [ i ] . superquadric ( tmp , p , h ) ; } return ; } double v [ ] [ ] = vertices , x , y , z ; if ( inv == null ) inv = new Matrix ( ) ; inv . invert ( mat ) ; for ( int k = 0 ; k < v . length ; k ++ ) { transform ( v [ k ] , mat , w ) ; x = Math . abs ( w [ 0 ] ) ; y = Math . abs ( w [ 1 ] ) ; z = Math . abs ( w [ 2 ] ) ; double t = Math . pow ( Math . pow ( x , p ) + Math . pow ( y , p ) + Math . pow ( z , p ) , 1 / p ) ; w [ 0 ] /= t ; w [ 1 ] /= t ; w [ 2 ] /= t ; if ( h > 0 ) { t = Math . pow ( w [ 0 ] * w [ 0 ] + w [ 1 ] * w [ 1 ] + w [ 2 ] * w [ 2 ] , h ) ; w [ 0 ] *= t ; w [ 1 ] *= t ; w [ 2 ] *= t ; } transform ( w , inv , v [ k ] ) ; } computedMeshNormals = false ; }
te	0	public ArrayList < Integer > getPrice ( ) { return Price ; }
te	5	public int minDepth ( TreeNode root ) { if ( root == null ) return 0 ; if ( root . left == null && root . right == null ) return 1 ; if ( root . left == null ) return 1 + minDepth ( root . right ) ; if ( root . right == null ) return 1 + minDepth ( root . left ) ; return 1 + Math . min ( minDepth ( root . left ) , minDepth ( root . right ) ) ; }
te	9	@ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; try { appendLB ( sb , getPackageName ( ) ) ; if ( hasAnnotations ( ) ) for ( JPAnnotation anno : getAnnotations ( ) ) { appendLB ( sb , "@" + anno . getType ( ) ) ; for ( String s : anno . getAttributes ( ) . keySet ( ) ) appendLB ( sb , "  " + s + "=" + anno . getAttributes ( ) . get ( s ) ) ; } appendLB ( sb , getClassName ( ) + "{" ) ; for ( JPField field : getFields ( ) ) { if ( field . hasAnnotations ( ) ) for ( JPAnnotation anno : field . getAnnotations ( ) ) { appendLB ( sb , "   " + "@" + anno . getType ( ) ) ; if ( anno . hasAttributes ( ) ) for ( String s : anno . getAttributes ( ) . keySet ( ) ) appendLB ( sb , "   " + "  " + s + "=" + anno . getAttributes ( ) . get ( s ) ) ; } appendLB ( sb , "   " + field . getType ( ) + " " + field . getName ( ) ) ; } appendLB ( sb , "}" ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return sb . toString ( ) ; }
te	8	@ Override public void predict ( Instance inst , Hashtable < TIntList , String > pool , TIntList entity , Model m ) { ArrayList < Prediction > preds = infer . findPredictions ( inst , m ) ; ArrayList < Label > predLabels = ( ( MultiLabelLogisticRegression ) m ) . makePredictions ( preds ) ; if ( X . getBoolean ( "printLabels" ) ) { int numFeatures = m . featureFactory . allFeatures . size ( ) ; for ( int i = 0 ; i < preds . size ( ) ; i ++ ) { if ( ! predLabels . contains ( preds . get ( i ) . label ) ) { continue ; } logger . debug ( preds . get ( i ) . label + "@" + preds . get ( i ) . prob ) ; if ( X . getBoolean ( "printWeights" ) ) { int idxLabel = preds . get ( i ) . label . id ; double [ ] lambda = ( ( LRParameter ) ( ( MultiLabelLogisticRegression ) m ) . para ) . lambda ; for ( int j = 0 ; j < inst . getFeatureIndex ( ) . size ( ) ; j ++ ) { logger . debug ( m . featureFactory . allFeatures . get ( inst . getIndex ( j ) ) + ":" + lambda [ inst . getIndex ( j ) + idxLabel * numFeatures ] + "\t" ) ; } } } } StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < preds . size ( ) ; i ++ ) { if ( ! predLabels . contains ( preds . get ( i ) . label ) ) { continue ; } if ( X . getBoolean ( "printLabelWithScore" ) ) { sb . append ( preds . get ( i ) . label . name + "@" + preds . get ( i ) . prob + " " ) ; } else { sb . append ( preds . get ( i ) . label . name + " " ) ; } } sb . deleteCharAt ( sb . length ( ) - 1 ) ; pool . put ( entity , sb . toString ( ) ) ; }
te	3	public Expression negate ( ) { if ( clauses . size ( ) == 0 ) return this ; else { Expression expr = new Expression ( ) ; for ( Clause clause : clauses ) { Expression neg = clause . negate ( ) ; Expression iexpr = new Expression ( ) ; for ( Clause iclause : neg . clauses ) { iexpr = iexpr . or ( iclause ) ; } expr = expr . and ( iexpr ) ; } return expr ; } }
te	6	@ Test public void canGetAllProducts ( ) { ProductModel addedProduct1 = ProductModel . builder ( "Night Visions" , 1 ) . description ( "Imagine Dragons" ) . cost ( 149 ) . rrp ( 400 ) . build ( ) ; ProductModel addedProduct2 = ProductModel . builder ( "Night Visions" , 1 ) . description ( "Imagine Dragons" ) . cost ( 149 ) . rrp ( 400 ) . build ( ) ; List < ProductModel > products = null ; boolean isProduct1 = false ; boolean isProduct2 = false ; try { addedProduct1 = new ProductModel ( insertProduct ( addedProduct1 ) , addedProduct1 ) ; addedProduct2 = new ProductModel ( insertProduct ( addedProduct2 ) , addedProduct2 ) ; products = pd . getAllProducts ( ) ; deleteProduct ( addedProduct1 . getId ( ) ) ; deleteProduct ( addedProduct2 . getId ( ) ) ; } catch ( WebshopAppException e ) { e . printStackTrace ( ) ; } for ( ProductModel product : products ) { if ( addedProduct1 . equals ( product ) ) { isProduct1 = true ; } if ( addedProduct2 . equals ( product ) ) { isProduct2 = true ; } } assertTrue ( products . size ( ) >= 2 && isProduct1 && isProduct2 ) ; }
te	6	@ Override public final boolean doCommand ( final CommandSender sender , final Command command , final String cmd , final String [ ] args ) { if ( ! canUseCommand ( sender , cmd , false , true ) ) { return true ; } if ( ! ( sender instanceof Player ) && args . length < 1 ) { sender . sendMessage ( AllAdmin . getMessages ( "noArguments" ) ) ; return true ; } if ( args . length == 1 ) { if ( ! AllAdmin . getUser ( sender . getName ( ) ) . canUseCommand ( cmd + ".others" ) ) { sender . sendMessage ( AllAdmin . getMessages ( "noPermissions" ) ) ; return true ; } final Player toHeal = MatchUser . matchOnlineUser ( args [ 0 ] ) ; if ( toHeal == null ) { sender . sendMessage ( AllAdmin . getMessages ( "noPlayer" ) ) ; return true ; } Heal . heal ( toHeal ) ; return true ; } Heal . heal ( ( ( AllAdminUser ) AllAdmin . getUser ( sender . getName ( ) ) ) . getBukkitPlayer ( ) ) ; return true ; }
te	5	public static ArrayList < Node > merge ( ArrayList < Node > one , ArrayList < Node > two ) { ArrayList < Node > merged = new ArrayList < > ( ) ; while ( ! one . isEmpty ( ) && ! two . isEmpty ( ) ) { if ( one . get ( 0 ) . getInnovationNum ( ) < two . get ( 0 ) . getInnovationNum ( ) ) merged . add ( one . remove ( 0 ) ) ; else merged . add ( two . remove ( 0 ) ) ; } while ( ! one . isEmpty ( ) ) merged . add ( one . remove ( 0 ) ) ; while ( ! two . isEmpty ( ) ) merged . add ( two . remove ( 0 ) ) ; return merged ; }
te	1	@ Test public void testPatternFilter ( ) throws IOException , TransformerException , ParserConfigurationException , SAXException , XPathExpressionException { File noTitleNoName = File . createTempFile ( "noTitleNoName" , null ) ; PrintWriter pw = new PrintWriter ( noTitleNoName ) ; try { pw . println ( "<Person>" ) ; pw . println ( "    <Gender>Male</Gender>" ) ; pw . println ( "</Person>" ) ; } finally { pw . close ( ) ; } @ SuppressWarnings ( "serial" ) Set < String > patternFilter = new HashSet < String > ( ) { { add ( "Check structure" ) ; } } ; Validator validator = new ValidatorFactory ( ) . newValidator ( schemaFile . getPath ( ) , patternFilter ) ; validator . validate ( new StreamSource ( noTitleNoName ) ) ; Map < String , ? extends Map < String , Integer >> report = validator . getReport ( ) ; Map < String , Integer > structureAsserts = report . get ( "Check structure" ) ; assertThat ( structureAsserts . size ( ) , equalTo ( 3 ) ) ; assertThat ( structureAsserts . get ( "The element Person must have a Title attribute" ) , equalTo ( 1 ) ) ; assertThat ( structureAsserts . get ( "The element Person should have the child elements Name and Gender." ) , equalTo ( 1 ) ) ; assertThat ( structureAsserts . get ( "The element Name must appear before element Gender." ) , equalTo ( 1 ) ) ; Map < String , Integer > coOccurrenceConstraints = report . get ( "Check co-occurrence constraints" ) ; assertThat ( coOccurrenceConstraints , equalTo ( null ) ) ; assertFalse ( validator . resultIsValid ( ) ) ; }
