tr	4	@ Test public void testLinearAssociator ( ) throws Exception { EvaluationManager evaluationManager = new EvaluationManager ( ) ; evaluationManager . setDataSet ( dataSet ) ; evaluationManager . setAlgorithm ( new LinearAssociator ( ) ) ; evaluationManager . setValidationMethod ( new LeaveOneOutValidation ( ) ) ; evaluationManager . evaluate ( ) ; for ( EvaluationMetric metric : evaluationManager . getMetrics ( ) ) { if ( metric instanceof BasicsMetric ) { System . out . println ( "\nTPR" ) ; double [ ] tpr = ( ( BasicsMetric ) metric ) . getTpr ( ) ; for ( double s : tpr ) { System . out . printf ( "%.3f\n" , s ) ; } System . out . println ( "\nFPR" ) ; double [ ] fpr = ( ( BasicsMetric ) metric ) . getFpr ( ) ; for ( double s : fpr ) { System . out . printf ( "%.3f\n" , s ) ; } } } }
tr	0	private void setMinBreak ( Integer minBreak ) { this . minChangingTime = minBreak ; }
tr	3	private void carregaPreuTipusHabitacions ( ) { String [ ] nomsHotels = { "Palace" , "Hilton" , "Metropolitan" , "Arts" , "Catalunya" , "Pensi\u00F3n Pepe" , "Bonjour" , "Oulala" } ; String [ ] nomsTipus = { "Individual" , "Doble" , "Matrimoni" } ; float [ ] preus = { 100 , 200 , 250 } ; for ( int i = 0 ; i < nomsHotels . length ; ++ i ) { for ( int j = 0 ; j < nomsTipus . length ; ++ j ) { PreuTipusHabitacio pth = new PreuTipusHabitacio ( ) ; pth . setId ( new PreuTipusHabitacioId ( nomsHotels [ i ] , nomsTipus [ j ] ) ) ; pth . setPreu ( preus [ j ] ) ; if ( j == 0 ) { AbsoluteDiscountPreuStrategy adps = new AbsoluteDiscountPreuStrategy ( ) ; adps . setId ( new PreuTipusHabitacioId ( nomsHotels [ i ] , nomsTipus [ j ] ) ) ; adps . setDescompte ( 30 ) ; pth . setStrategy ( adps ) ; session . saveOrUpdate ( pth ) ; session . saveOrUpdate ( adps ) ; } else { PercentDiscountPreuStrategy pdps = new PercentDiscountPreuStrategy ( ) ; pdps . setId ( new PreuTipusHabitacioId ( nomsHotels [ i ] , nomsTipus [ j ] ) ) ; pdps . setPerc ( 0.7F ) ; pth . setStrategy ( pdps ) ; session . saveOrUpdate ( pth ) ; session . saveOrUpdate ( pdps ) ; } } } }
tr	5	public static Object evaluate ( String expression , Object root , boolean trimRootToken ) throws Exception { if ( trimRootToken ) { expression = expression . substring ( expression . indexOf ( . ) + 1 ) ; } Object value = root ; StringTokenizer parser = new StringTokenizer ( expression , "." ) ; while ( parser . hasMoreTokens ( ) ) { String token = parser . nextToken ( ) ; if ( value == null ) { return null ; } ClassMap classMap = getClassMap ( value . getClass ( ) ) ; String methodBase = StringUtils . capitalizeFirstLetter ( token ) ; String methodName = "get" + methodBase ; Method method = classMap . findMethod ( methodName , CLASS_ARGS ) ; if ( method == null ) { methodName = "is" + methodBase ; method = classMap . findMethod ( methodName , CLASS_ARGS ) ; } if ( method == null ) { return null ; } value = method . invoke ( value , OBJECT_ARGS ) ; } return value ; }
tr	9	protected void stepForward ( boolean showSteps ) { switch ( m_currentPhase ) { case PHASE_PREPROCESSING : long precSize = getNumPrecomputedBlocs ( ) ; if ( precSize > Integer . MAX_VALUE ) { JOptionPane . showMessageDialog ( null , "Number of precompiled matrix too large!" , "Error" , JOptionPane . ERROR_MESSAGE ) ; return ; } int megs = ( int ) ( ( double ) ( 550 * precSize ) / 1000000.0 ) ; NumberFormat nf = NumberFormat . getInstance ( ) ; String precSizeStr = nf . format ( precSize ) ; if ( precSize > PRECOMPILED_WARNING_LIMIT ) { int retVal = JOptionPane . showConfirmDialog ( null , "Warning! The number of blocs to compute will be very large (" + precSizeStr + ").\n You will need a huge amount of memory (~" + megs + " MB).\n Do you still want to continue?" , "Warning!" , JOptionPane . YES_NO_OPTION ) ; if ( retVal != JOptionPane . YES_OPTION ) { return ; } } try { m_preprocTable = new Hashtable ( ( int ) precSize ) ; m_orderedKeys = new ArrayList ( ( int ) precSize ) ; } catch ( java . lang . OutOfMemoryError e ) { m_preprocTable = null ; m_orderedKeys = null ; Runtime . getRuntime ( ) . gc ( ) ; JOptionPane . showMessageDialog ( null , "Out of memory!\n (Please give " + "a second to the garbage collector " + "to clean this mess..).\n" + "Note: Il could be unstable anyway" , "Didn't I tell you? :)" , JOptionPane . ERROR_MESSAGE ) ; Runtime . getRuntime ( ) . gc ( ) ; Runtime . getRuntime ( ) . gc ( ) ; return ; } PreprocessingFrame prFrm = new PreprocessingFrame ( m_preprocTable , m_orderedKeys , m_t , m_encodedAlphSize , this ) ; prFrm . show ( ) ; m_currentStep = 0 ; m_currentPhase = PHASE_CALC_GRID ; break ; case PHASE_CALC_GRID : if ( m_currentStep >= m_nHBlocs * m_nVBlocs ) { m_backtrackLastSel = m_dpTable . getLastCell ( ) ; for ( int i = 0 ; i < 3 ; i ++ ) { m_resLine [ i ] = "" ; } setInfoMessage ( "Backtracking Pointers. Policy used: " + CellElement . getPolicyName ( m_backtrackingPolicy ) + "." ) ; m_currentPhase = PHASE_BACKTRACK ; ( ( FRTable ) m_dpTable ) . setShowBackgroundIndexes ( false ) ; m_dpTable . clearHighlightColors ( ) ; m_dwPanel . setVisible ( true ) ; m_l1Choiche . setVisible ( true ) ; m_l2Choiche . setVisible ( true ) ; m_l3Choiche . setVisible ( true ) ; stepFWDBackTrack ( showSteps ) ; } else { setInfoMessage ( "Applying preprocessed blocs. Step: " + m_currentStep ) ; this . stepFWDCalc ( showSteps ) ; } break ; case PHASE_BACKTRACK : stepFWDBackTrack ( showSteps ) ; break ; } }
tr	2	@ Override public void actionPerformed ( ActionEvent event ) { String eventName = event . getActionCommand ( ) ; System . out . println ( "event:" + eventName ) ; switch ( eventName ) { case "comboBoxChanged" : String prefName = sysAdminUI . getPreferenceListBoxSelection ( ) ; String value = systemPrefs . get ( prefName ) . toString ( ) ; sysAdminUI . setPreferenceField ( value ) ; break ; case "Set Preference" : String preference = sysAdminUI . getPreferenceListBoxSelection ( ) ; String valueField = sysAdminUI . getPreferenceField ( ) ; systemPrefs . put ( preference , valueField ) ; setChanged ( ) ; notifyObservers ( ) ; break ; } }
tr	1	public void showHideDeleteBtn ( ) { if ( ! btnVisible ) { deletePanel . setVisible ( true ) ; this . repaint ( ) ; btnVisible = true ; } else { deletePanel . setVisible ( false ) ; this . repaint ( ) ; btnVisible = false ; } }
tr	5	public static String replaceVariablesWithKeyword ( final String line ) { String text = line ; Pattern pattern = Pattern . compile ( "([_A-Za-z0-9\\.]{1 50})(?=(| )[\\;\\ \\+-\\=\\<\\>\\)\\[\\!])" ) ; Matcher matcher = pattern . matcher ( text ) ; while ( matcher . find ( ) ) { final String match = matcher . group ( ) ; String result = "\u00BAV" ; if ( utils . text . equals ( match , "true" ) ) { result = "\u00BATE" ; } else if ( utils . text . equals ( match , "false" ) ) { result = "\u00BAF" ; } else if ( utils . text . equals ( match , "null" ) ) { result = "\u00BANU" ; } else if ( utils . text . equals ( match , "return" ) ) { result = "\u00BAR" ; } text = text . replace ( matcher . group ( ) , result ) ; } return text ; }
tr	6	@ Override public int hashCode ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + ( ( AlcoholPolicy == null ) ? 0 : AlcoholPolicy . hashCode ( ) ) ; result = prime * result + ( ( CancellationDeadLine == null ) ? 0 : CancellationDeadLine . hashCode ( ) ) ; result = prime * result + ( ( CancellationPenalty == null ) ? 0 : CancellationPenalty . hashCode ( ) ) ; result = prime * result + ( ( CheckInTime == null ) ? 0 : CheckInTime . hashCode ( ) ) ; result = prime * result + ( ( CheckOutTime == null ) ? 0 : CheckOutTime . hashCode ( ) ) ; result = prime * result + ( ( SmokingPolicy == null ) ? 0 : SmokingPolicy . hashCode ( ) ) ; return result ; }
tr	2	public static Set < Set < Integer >> allSubSet ( Set < Integer > s ) { Set < Set < Integer >> pre = new HashSet < > ( ) ; for ( Integer e : s ) { Set < Set < Integer >> dup = new HashSet < > ( ) ; for ( Set < Integer > ss : pre ) { dup . add ( new HashSet < Integer > ( ss ) ) ; ss . add ( e ) ; } pre . addAll ( dup ) ; pre . add ( new HashSet < Integer > ( Arrays . asList ( e ) ) ) ; } return pre ; }
tr	2	public static boolean isPrime ( int checkNumber ) { double root = Math . sqrt ( checkNumber ) ; for ( int i = 2 ; i <= root ; i ++ ) { if ( checkNumber % i == 0 ) { return false ; } } return true ; }
tr	5	public StringBuilder render ( ) { builder = new StringBuilder ( ) ; append ( "<table class='cubics' cellspacing='0'>\n" ) ; append ( "<tr>" ) ; append ( "<th rowspan='2'>" , dimensionsOptions . getLabel ( "all" ) , "</th>" ) ; for ( String dimension : dimensions ) { append ( "<th rowspan='2'>" , dimensionsOptions . getLabel ( dimension ) , "</th>" ) ; } Options < T > aggregatesOptions ; int hm = 0 ; for ( String measure : measuresOptions . getAttributes ( ) ) { aggregatesOptions = getAggregatesOptions ( measure ) ; append ( "<th colspan='" , aggregatesOptions . getAttributes ( ) . size ( ) , "' id='hm-" , hm , "'>" , measuresOptions . getLabel ( measure ) , "</th>" ) ; hm ++ ; } append ( "</tr>\n" ) ; append ( "<tr>\n" ) ; int am = 0 ; hm = 0 ; for ( String measure : measuresOptions . getAttributes ( ) ) { aggregatesOptions = getAggregatesOptions ( measure ) ; for ( String aggregate : aggregatesOptions . getAttributes ( ) ) { append ( "<th class='am-" , am , " hm-" , hm , "'>" ) ; append ( aggregatesOptions . getLabel ( aggregate ) , "</th>" ) ; am ++ ; } hm ++ ; } append ( "</tr>\n" ) ; Hierarchy < T > root = cube . getRoot ( ) ; append ( "<tr><td id='ix' class='x c-e' rowspan='" , ( root . getSizeWithTotals ( ) - 1 ) , "'>all</td>" ) ; renderHierarchy ( root , - 1 , "x" ) ; if ( root . getChildren ( ) . size ( ) > 0 ) { deleteFromEnd ( "<tr>" . length ( ) ) ; } append ( "</table>" ) ; return builder ; }
tr	9	private void backpropagate ( double [ ] exp ) { int i = 0 ; for ( Neuron outputNeuron : this . output ) { outputNeuron . setError ( ( exp [ i ] - outputNeuron . getLatestOutput ( ) ) ) ; outputNeuron . addBiasChange ( outputNeuron . getError ( ) ) ; i ++ ; } for ( i = this . hidden . size ( ) - 1 ; i >= 0 ; i -- ) { for ( Neuron h : this . hidden . get ( i ) ) { double p = this . functions . derivative ( h . getLatestSum ( ) ) ; double k = 0 ; for ( Synaps s : h . getconnectedTo ( ) ) { k += s . getTo ( ) . getError ( ) * s . getweight ( ) ; } h . setError ( p * k ) ; } for ( Neuron neuron : this . hidden . get ( i ) ) { neuron . addBiasChange ( neuron . getError ( ) ) ; } } for ( Neuron n : this . input ) { for ( Synaps s : n . getconnectedTo ( ) ) { s . addWeightChange ( s . getTo ( ) . getError ( ) * n . getLatestInput ( ) ) ; } } for ( List < Neuron > l : this . hidden ) { for ( Neuron n : l ) { for ( Synaps s : n . getconnectedTo ( ) ) { s . addWeightChange ( s . getTo ( ) . getError ( ) * n . getLatestOutput ( ) ) ; } } } }
tr	4	public static < T > List < T > select ( String query , ReadGetter < T > rg , ReadFilter < T > rf ) { List < T > container = new LinkedList < T > ( ) ; try { ResultSet result = Database . getConnection ( ) . prepareStatement ( query ) . executeQuery ( ) ; rg . takeResultSet ( result ) ; T ref ; while ( result . next ( ) ) { ref = rg . read ( ) ; if ( rf == null || rf . accept ( ref ) ) container . add ( ref ) ; } } catch ( SQLException e ) { e . printStackTrace ( ) ; return null ; } Database . closeConnection ( ) ; return container ; }
tr	2	private static int posOfElement ( final byte element , final byte [ ] state ) { for ( int i = state . length - 1 ; i >= 0 ; -- i ) { if ( state [ i ] == element ) { return i ; } } return - 1 ; }
tr	8	private JScrollPane buildFieldsTablePanel ( ) { fieldsTable = new JTable ( new AbstractTableModel ( ) { private static final long serialVersionUID = 5347188337180793036 ; private String [ ] columnNames = new String [ ] { "Id" , "Type" , "Value" } ; public int getColumnCount ( ) { return 3 ; } public int getRowCount ( ) { try { return s3270 . getScreen ( ) . getFields ( ) . size ( ) ; } catch ( Exception e ) { return 0 ; } } @ Override public String getColumnName ( final int column ) { return columnNames [ column ] ; } public Object getValueAt ( final int rowIndex , final int columnIndex ) { if ( columnIndex == 0 ) { return rowIndex ; } Field f ; try { f = s3270 . getScreen ( ) . getFields ( ) . get ( rowIndex ) ; } catch ( Exception e ) { return "" ; } if ( columnIndex == 1 ) { return ( ( f instanceof InputField ) ? "in" : "out" ) + ( ( ( f instanceof InputField ) && ( ( InputField ) f ) . isChanged ( ) ) ? " *" : "" ) ; } if ( columnIndex == 2 ) { return "[" + f . getValue ( ) . replace (  ,   ) + "]" ; } throw new RuntimeException ( "unknown column index " + columnIndex ) ; } public boolean isCellEditable ( final int rowIndex , final int columnIndex ) { return columnIndex == 2 ; } } ) ; fieldsTable . getColumnModel ( ) . getColumn ( 0 ) . setPreferredWidth ( 25 ) ; fieldsTable . getColumnModel ( ) . getColumn ( 1 ) . setPreferredWidth ( 35 ) ; fieldsTable . getColumnModel ( ) . getColumn ( 2 ) . setPreferredWidth ( 600 ) ; final JScrollPane tableScroller = new JScrollPane ( fieldsTable ) ; return tableScroller ; }
tr	6	public static TimeQualifier parseString ( String value ) { if ( REAL_TIME . representation . equals ( value ) ) { return REAL_TIME ; } else if ( BY_SCHEDULE . representation . equals ( value ) ) { return BY_SCHEDULE ; } else if ( HOURLY . representation . equals ( value ) ) { return HOURLY ; } else if ( DAILY . representation . equals ( value ) ) { return DAILY ; } else if ( MONTHLY . representation . equals ( value ) ) { return MONTHLY ; } else if ( YEARLY . representation . equals ( value ) ) { return YEARLY ; } else { throw new IllegalArgumentException ( "Can not find match for: " + value ) ; } }
tr	7	private class < ? > [ ] resolveBoundClasses ( List < String > classNames ) { List < class < ? >> classObjects = new ArrayList < class < ? >> ( ) ; for ( String className : classNames ) { ClassLoader cl = getClassLoader ( ) ; try { class < ? > c = class . forName ( className , true , cl ) ; classObjects . add ( c ) ; } catch ( ClassNotFoundException e ) { CheckedExceptions . throwAsUnchecked ( e ) ; } } return classObjects . toArray ( new class < ? > [ classObjects . size ( ) ] ) ; }
tr	8	public String perform ( HttpServletRequest request ) { List < String > errors = new ArrayList < String > ( ) ; request . setAttribute ( "errors" , errors ) ; try { DepositCheckForm form = formBeanFactory . create ( request ) ; request . setAttribute ( "form" , form ) ; if ( ! form . isPresent ( ) ) { return "e_depositCheck.jsp" ; } errors . addAll ( form . getValidationErrors ( ) ) ; if ( errors . size ( ) != 0 ) { return "e_depositCheck.jsp" ; } int customerId = - 1 ; Transaction . begin ( ) ; customerId = customerDAO . getCustomerId ( form . getCustomer ( ) ) ; if ( customerId == - 1 ) { Transaction . commit ( ) ; errors . add ( "cannot find customerId with customerName" ) ; return "e_depositCheck.jsp" ; } TransactionBean tb = new TransactionBean ( ) ; tb . setTransaction_type ( "deposit" ) ; tb . setAmount ( dataConversion . convertFromStringToThreeDigitLong ( form . getAmount ( ) ) ) ; tb . setCustomer_id ( customerId ) ; transactionDAO . createNewTransaction ( tb ) ; request . setAttribute ( "message" , "the transaction is in process" ) ; Transaction . commit ( ) ; return "e_success.jsp" ; } catch ( RollbackException e ) { errors . add ( e . getMessage ( ) ) ; return "e_depositCheck.jsp" ; } catch ( FormBeanException e ) { errors . add ( e . getMessage ( ) ) ; return "e_depositCheck.jsp" ; } catch ( NumberFormatException e ) { System . out . print ( "catched" ) ; errors . add ( "Input Amount is too large" ) ; return "e_depositCheck.jsp" ; } catch ( Exception e ) { errors . add ( e . getMessage ( ) ) ; return "e_depositCheck.jsp" ; } finally { if ( Transaction . isActive ( ) ) Transaction . rollback ( ) ; } }
tr	2	public void seek_notify ( ) { frame_start = 0 ; for ( int ch = 0 ; ch < 2 ; ch ++ ) for ( int j = 0 ; j < 576 ; j ++ ) prevblck [ ch ] [ j ] = 0.0f ; br = new BitReserve ( ) ; }
tr	0	public String toString ( ) { return "Fruit-" + ( id ) ; }
tr	2	@ Override public Object createObject ( ResultSet rs ) { EnsemblDBs edbs = null ; int id = 0 ; String dbName = null ; String label = null ; int version = 0 ; try { if ( rs . next ( ) ) { id = rs . getInt ( 1 ) ; dbName = rs . getString ( 2 ) ; label = rs . getString ( 3 ) ; version = rs . getInt ( 4 ) ; edbs = new EnsemblDBs ( id , dbName , label , version ) ; } } catch ( SQLException e ) { e . printStackTrace ( ) ; } return edbs ; }
tr	2	public double processInstruction ( Instruction toExecute ) { try { return toExecute . process ( myMap ) ; } catch ( IndexOutOfBoundsException e ) { showErrorMsg ( "IncorrectFormat" ) ; return 0 ; } catch ( IllegalArgumentException e ) { showErrorMsg ( "BlockError" ) ; return 0 ; } }
tr	8	void loadObjects ( Document xmlDoc ) throws Exception { Rectangle truck = panelWorkplace . truck . getBounds ( ) ; panelLibrary . destroyLiraryTable ( ) ; boolean libraryModified = false ; NodeList nodeList = xmlDoc . getElementsByTagName ( "container" ) ; for ( int i = 0 ; i < nodeList . getLength ( ) ; i ++ ) { Element e = ( Element ) nodeList . item ( i ) ; String size1 = ( ( Element ) e . getElementsByTagName ( "size1" ) . item ( 0 ) ) . getTextContent ( ) ; String size2 = ( ( Element ) e . getElementsByTagName ( "size2" ) . item ( 0 ) ) . getTextContent ( ) ; String name = ( ( Element ) e . getElementsByTagName ( "name" ) . item ( 0 ) ) . getTextContent ( ) ; String sap = ( ( Element ) e . getElementsByTagName ( "sap" ) . item ( 0 ) ) . getTextContent ( ) ; String weight = ( ( Element ) e . getElementsByTagName ( "weight" ) . item ( 0 ) ) . getTextContent ( ) ; String rotated = ( ( Element ) e . getElementsByTagName ( "rotated" ) . item ( 0 ) ) . getTextContent ( ) ; String mandatory = ( ( Element ) e . getElementsByTagName ( "mandatory" ) . item ( 0 ) ) . getTextContent ( ) ; String x = ( ( Element ) e . getElementsByTagName ( "x" ) . item ( 0 ) ) . getTextContent ( ) ; String y = ( ( Element ) e . getElementsByTagName ( "y" ) . item ( 0 ) ) . getTextContent ( ) ; Container c1 = new Container ( name , sap , new Dimension ( Integer . parseInt ( size1 ) , Integer . parseInt ( size2 ) ) , Integer . parseInt ( weight ) ) ; ContainerComponent component = null ; for ( Container c2 : Library . getContainers ( ) ) { if ( c2 . toXml ( ) . equals ( c1 . toXml ( ) ) ) { component = panelWorkplace . addContainer ( c2 , true ) ; break ; } } if ( component == null ) { libraryModified = true ; Library . getContainers ( ) . add ( c1 ) ; component = panelWorkplace . addContainer ( c1 , true ) ; } if ( new boolean ( rotated ) . booleanValue ( ) ) { component . rotate ( ) ; } if ( new boolean ( mandatory ) . booleanValue ( ) ) { component . mandatory = true ; } double xPos = new double ( x ) . doubleValue ( ) ; double yPos = new double ( y ) . doubleValue ( ) ; xPos = xPos * preferences . getGuiPixelsPerMeter ( ) / 1000 ; yPos = yPos * preferences . getGuiPixelsPerMeter ( ) / 1000 ; xPos += truck . x ; yPos += truck . y ; component . setLocation ( ( int ) xPos , ( int ) yPos ) ; } panelLibrary . createLibraryTable ( ) ; if ( libraryModified ) { for ( DocumentFrame doc : loadOrganizer . openDocuments ) { doc . panelLibrary . destroyLiraryTable ( ) ; doc . panelLibrary . createLibraryTable ( ) ; } } panelWorkplace . computeInfo ( ) ; panelWorkplace . getVerticalScrollBar ( ) . setValue ( 0 ) ; panelWorkplace . getHorizontalScrollBar ( ) . setValue ( 0 ) ; }
tr	3	@ Override public void writeAVLData ( OutputStream out ) { PrintStream ps = new PrintStream ( out ) ; ps . print ( "BODY\n" ) ; ps . printf ( locale , "%1$s\n" , this . getName ( ) ) ; ps . printf ( locale , "#Nbody  Bspace\n" + formatInteger ( 1 ) + formatFloat ( 1 , 2 ) , this . getNbody ( ) , this . getBspace ( ) ) ; ps . print ( "\n" ) ; ps . print ( "YDUPLICATE\n" ) ; ps . printf ( locale , formatFloat ( 1 ) + "\n" , this . getYdupl ( ) ) ; if ( this . getdX ( ) != 0 || this . getdY ( ) != 0 || this . getdZ ( ) != 0 ) { ps . print ( "TRANSLATE\n" ) ; ps . printf ( locale , "#dX  dY  dZ\n" + formatFloat ( 3 ) + "\n" , this . getdX ( ) , this . getdY ( ) , this . getdZ ( ) ) ; } ps . print ( "BFILE\n" ) ; ps . print ( this . getBFILE ( ) + "\n" ) ; }
tr	0	public void setMinMwt ( float value ) { this . minMwt = value ; }
tr	0	public String getReturn ( ) { return _return ; }
tr	2	static public void ReInit ( java . io . InputStream stream , String encoding ) { try { jj_input_stream . ReInit ( stream , encoding , 1 , 1 ) ; } catch ( java . io . UnsupportedEncodingException e ) { throw new RuntimeException ( e ) ; } token_source . ReInit ( jj_input_stream ) ; token = new Token ( ) ; jj_ntk = - 1 ; jj_gen = 0 ; for ( int i = 0 ; i < 7 ; i ++ ) jj_la1 [ i ] = - 1 ; }
tr	0	private Vector < Arete > ajoute ( int p , Vector < Arete > v ) { DoubletVect < Arete > dVect = separe ( ens . elementAt ( p ) , v ) ; int [ ] tab = compte ( dVect . v1 , p ) ; Vector < Arete > vEnPlus = nouvellesAretes ( p , tab , p ) ; return concat ( dVect . v2 , vEnPlus ) ; }
tr	6	@ Override public int updateByLogic ( Object ... pojos ) throws DataAccessException { int r = 0 ; for ( Object obj : pojos ) { SqlUpdGenerator sqlGenerator = new SqlUpdGenerator ( obj , false ) ; try { r += execute ( sqlGenerator . getSql ( ) , sqlGenerator . getArgs ( ) ) ; } catch ( IllegalArgumentException e ) { logger . error ( "init update sql error! exec number : {}" , r , e ) ; throw new DataAccessException ( "init update sql error!" , e ) ; } catch ( IllegalAccessException e ) { logger . error ( "init update sql error! exec number : {}" , r , e ) ; throw new DataAccessException ( "init update sql error!" , e ) ; } catch ( NoSuchFieldException e ) { logger . error ( "init update sql error! exec number : {}" , r , e ) ; throw new DataAccessException ( "init update sql error!" , e ) ; } catch ( SecurityException e ) { logger . error ( "init update sql error! exec number : {}" , r , e ) ; throw new DataAccessException ( "init update sql error!" , e ) ; } catch ( ParseException e ) { logger . error ( "init update sql error! exec number : {}" , r , e ) ; throw new DataAccessException ( "init update sql error!" , e ) ; } } return r ; }
tr	2	public int min_number_of_frames ( int streamsize ) { if ( h_vbr == true ) return h_vbr_frames ; else { if ( ( framesize + 5 - h_padding_bit ) == 0 ) return 0 ; else return ( streamsize / ( framesize + 5 - h_padding_bit ) ) ; } }
tr	6	public Vector < Vector < Object >> getFolderContentsTable ( ) { Vector < Vector < Object >> tableData = new Vector < > ( ) ; List < FileInfo > files = getFolderContents ( ) ; logger . debug ( "Found " + files . size ( ) + " entries for " + path . toString ( ) ) ; for ( FileInfo file : files ) { Vector < Object > row = null ; if ( file . folder ) { row = new Vector < > ( ) ; if ( FileOp . convertPath ( path . resolve ( file . fileName ) ) . toFile ( ) . exists ( ) ) { row . add ( new ImageIcon ( "res/folder.png" ) ) ; } else { row . add ( new ImageIcon ( "res/folder_deleted.png" ) ) ; } row . add ( file . fileName ) ; row . add ( GuiUtility . humanReadableBytes ( file . fileSize , false ) ) ; row . add ( GuiUtility . formatDate ( file . createdDate ) ) ; row . add ( GuiUtility . formatDate ( file . lastAccessedDate ) ) ; row . add ( GuiUtility . formatDate ( file . lastModifiedDate ) ) ; row . add ( Integer . toString ( file . numberOfRevisions ) ) ; row . add ( GuiUtility . humanReadableBytes ( file . revisionSizes , false ) ) ; tableData . add ( row ) ; } } for ( FileInfo file : files ) { Vector < Object > row = null ; if ( ! file . folder ) { row = new Vector < > ( ) ; if ( FileOp . convertPath ( path . resolve ( file . fileName ) ) . toFile ( ) . exists ( ) ) { row . add ( new ImageIcon ( "res/file.png" ) ) ; } else { row . add ( new ImageIcon ( "res/file_deleted.png" ) ) ; } row . add ( file . fileName ) ; row . add ( GuiUtility . humanReadableBytes ( file . fileSize , false ) ) ; row . add ( GuiUtility . formatDate ( file . createdDate ) ) ; row . add ( GuiUtility . formatDate ( file . lastAccessedDate ) ) ; row . add ( GuiUtility . formatDate ( file . lastModifiedDate ) ) ; row . add ( Integer . toString ( file . numberOfRevisions ) ) ; row . add ( GuiUtility . humanReadableBytes ( file . revisionSizes , false ) ) ; tableData . add ( row ) ; } } return tableData ; }
tr	9	public static void main ( String [ ] args ) { RotateListProblem problem1 = new RotateListProblem ( Arrays . asList ( 1 , 2 , 4 , 8 , 16 , 32 ) ) ; RotateListProblem problem2 = new RotateListProblem ( Arrays . asList ( 0 , 1 , 1 , 2 , 3 , 5 , 8 , 13 , 21 , 34 ) ) ; Genejector . getSettings ( ) . setScoreLimit ( 4 ) ; Genejector . getSettings ( ) . setPrintAllIndividuals ( true ) ; Genejector . getSettings ( ) . addClass ( "int" , false ) ; Genejector . getSettings ( ) . addClass ( "java.util.ArrayList" , false ) ; while ( ! Genejector . isSolutionFound ( ) ) { Genejector . geneject ( RotateListProblem . class ) ; long score = 0 ; Genejector . execute ( problem1 ) ; if ( problem1 . list != null && problem1 . list . equals ( Arrays . asList ( 2 , 4 , 8 , 16 , 32 , 1 ) ) ) { score += 2 ; } else if ( problem1 . list != null && ( problem1 . list . equals ( Arrays . asList ( 2 , 4 , 8 , 16 , 32 ) ) || problem1 . list . equals ( Arrays . asList ( 1 , 2 , 4 , 8 , 16 , 32 , 1 ) ) ) ) { score += 1 ; } Genejector . execute ( problem2 ) ; if ( problem2 . list != null && problem2 . list . equals ( Arrays . asList ( 1 , 1 , 2 , 3 , 5 , 8 , 13 , 21 , 34 , 0 ) ) ) { score += 2 ; } else if ( problem2 . list != null && ( problem2 . list . equals ( Arrays . asList ( 1 , 1 , 2 , 3 , 5 , 8 , 13 , 21 , 34 ) ) || problem2 . list . equals ( Arrays . asList ( 0 , 1 , 1 , 2 , 3 , 5 , 8 , 13 , 21 , 34 , 0 ) ) ) ) { score += 1 ; } Genejector . submitScore ( score ) ; } System . out . println ( "Solution: " + Genejector . getSolutionSourceCode ( ) ) ; }
tr	6	public boolean loadLevel ( int i ) { if ( i > 21 ) { if ( i == 22 || i == 43 ) pageSwitch = true ; i = ( ( i % 21 ) == 0 ) ? 21 : i % 21 ; } loadLevel ( StateUtil . getGameState ( proxy ) , i ) ; GameState state = StateUtil . getGameState ( proxy ) ; while ( state != GameState . PLAYING ) { System . out . println ( " In state:   " + state + " Try reloading..." ) ; loadLevel ( state , i ) ; try { Thread . sleep ( 12000 ) ; } catch ( InterruptedException e1 ) { e1 . printStackTrace ( ) ; } state = StateUtil . getGameState ( proxy ) ; } return true ; }
tr	5	public URI toUri ( ) { try { return new URI ( protocol_ . length ( ) > 0 ? protocol_ : null , user_ . length ( ) > 0 ? user_ : null , server_ . length ( ) > 0 ? server_ : null , port_ , path_ , getQueryString ( ) , fragment_ . length ( ) > 0 ? fragment_ : null ) ; } catch ( URISyntaxException e ) { return null ; } }
tr	4	public void setPixels ( int x , int y , int width , int height , ColorModel model , int pixels [ ] , int offset , int scansize ) { if ( srcPixels == null ) { srcPixels = new int [ srcWidth * srcHeight ] ; } for ( int row = 0 , destRow = y * srcWidth ; row < height ; row ++ , destRow += srcWidth ) { int rowOff = offset + row * scansize ; for ( int col = 0 ; col < width ; col ++ ) { srcPixels [ destRow + x + col ] = model == null ? pixels [ rowOff + col ] : model . getRGB ( pixels [ rowOff + col ] ) ; } } }
tr	5	public double coerce ( String s ) { try { Date date = format . parse ( s ) ; calendar . setTime ( date ) ; long timeInMillis = calendar . getTimeInMillis ( ) ; switch ( timeUnit ) { case SECONDS : return timeInMillis / 1000d ; case MINUTES : return timeInMillis / 1000d / 60d ; case HOURS : return timeInMillis / 1000d / 60d / 60d ; case DAYS : return timeInMillis / 1000d / 60d / 60d / 24d ; } throw new RuntimeException ( "Unsupported TimeUnit '" + timeUnit + "'. Use one of: SECONDS  MINUTES  HOURS  DAYS." ) ; } catch ( ParseException e ) { throw new RuntimeException ( "Couldn't coerce '" + s + "' to date using '" + pattern + "' format pattern." , e ) ; } }
tr	7	public static void parse_literal_facts ( String path ) throws ClassNotFoundException , SQLException , IOException { BufferedReader reader = new BufferedReader ( new FileReader ( path + "yagoLiteralFacts.tsv" ) ) ; int j = 0 ; int gdp = 0 , population = 1 , area = 2 , creation_date = 3 , birth_date = 4 ; String line = null ; String [ ] data = null ; while ( ( line = reader . readLine ( ) ) != null ) { if ( j % 100000 == 0 ) System . out . println ( "l_facts: " + j ) ; j ++ ; data = line . split ( "\t" ) ; if ( "<hasGDP>" . equals ( data [ 2 ] ) ) MakeTheLink . db . Load_yago . insert_literal_facts ( data , gdp ) ; if ( "<hasNumberOfPeople>" . equals ( data [ 2 ] ) ) MakeTheLink . db . Load_yago . insert_literal_facts ( data , population ) ; if ( "<hasArea>" . equals ( data [ 2 ] ) ) MakeTheLink . db . Load_yago . insert_literal_facts ( data , area ) ; if ( "<wasCreatedOnDate>" . equals ( data [ 2 ] ) ) MakeTheLink . db . Load_yago . insert_literal_facts ( data , creation_date ) ; if ( "<wasBornOnDate>" . equals ( data [ 2 ] ) ) MakeTheLink . db . Load_yago . insert_literal_facts ( data , birth_date ) ; } reader . close ( ) ; }
tr	3	private Element findNext ( ) { if ( next == null ) { while ( i < length ) { Node node = elements . item ( i ++ ) ; if ( node . getNodeType ( ) == Node . ELEMENT_NODE ) { next = ( Element ) node ; break ; } } } return next ; }
tr	3	private boolean r_noun ( ) { int among_var ; ket = cursor ; among_var = find_among_b ( a_5 , 36 ) ; if ( among_var == 0 ) { return false ; } bra = cursor ; switch ( among_var ) { case 0 : return false ; case 1 : slice_del ( ) ; break ; } return true ; }
tr	4	public static void main ( String [ ] args ) throws IOException { if ( args . length >= 5 ) { File baseFreqFile = new File ( args [ 0 ] ) ; File sampleFreqDir = new File ( args [ 1 ] ) ; File sizeFile = new File ( args [ 2 ] ) ; File outFile = new File ( args [ 3 ] ) ; double rate = double . parseDouble ( args [ 4 ] ) ; byte mode = GREEDY_SAMPLE ; if ( args . length >= 6 ) { String modeString = args [ 5 ] ; if ( modeString . equalsIgnoreCase ( "random" ) ) { mode = RANDOM_SAMPLE ; } else if ( modeString . equalsIgnoreCase ( "greedy" ) ) { mode = GREEDY_SAMPLE ; } } ComposeSample composer = new ComposeSample ( ) ; composer . doSample ( baseFreqFile , sampleFreqDir , sizeFile , outFile , rate , mode ) ; } else { System . out . println ( "Missing parameters ... " ) ; IndexBuilder . printHelp ( ) ; } }
tr	7	public static String encode ( String text , int offset ) { char [ ] chars = text . toCharArray ( ) ; for ( int i = 0 ; i < chars . length ; i ++ ) { int c = chars [ i ] ; if ( c >= a && c <= z ) { c += offset ; if ( c > z ) { c = a + ( c - z - 1 ) ; } else if ( c < a ) { c = z - ( a - c ) + 1 ; } } else { c += offset ; if ( c > Z ) { c = A + ( c - Z - 1 ) ; } else if ( c < A ) { c = Z - ( A - c ) + 1 ; } } chars [ i ] = ( char ) c ; } return new String ( chars ) ; }
tr	0	public BaseLight ( Vector3f color , float intensity ) { this . color = color ; this . intensity = intensity ; }
tr	5	private static Set < String > parenthesis ( int i ) { if ( i == 0 ) { Set < String > list = new HashSet < > ( ) ; list . add ( "" ) ; return list ; } Set < String > list = parenthesis ( i - 1 ) ; Set < String > compList = new HashSet < > ( ) ; for ( String paren : list ) { for ( int index = 0 ; index < paren . length ( ) ; index ++ ) { if ( paren . charAt ( index ) == ( ) { String str = insertChar ( paren , index ) ; compList . add ( str ) ; } } if ( ! compList . contains ( "()" + paren ) ) { compList . add ( "()" + paren ) ; } } return compList ; }
tr	1	public static void main ( String [ ] args ) { try { = ( 0 , ( new PalindromePhrases ( ) ) . getAmount ( new String [ ] { "a" , "ba" } ) , 2 ) ; = ( 1 , ( new PalindromePhrases ( ) ) . getAmount ( new String [ ] { "ab" , "bcd" , "efg" } ) , 0 ) ; = ( 2 , ( new PalindromePhrases ( ) ) . getAmount ( new String [ ] { "a" , "bba" , "abb" } ) , 7 ) ; = ( 3 , ( new PalindromePhrases ( ) ) . getAmount ( new String [ ] { "aabccc" , "ccbbca" , "a" , "acaabb" , "aaa" , "aab" , "c" , "babb" , "aacaa" , "b" } ) , 47 ) ; } catch ( Exception exx ) { System . err . println ( exx ) ; exx . printStackTrace ( System . err ) ; } }
tr	1	public static void main ( String args [ ] ) { LinkedListBST b = new LinkedListBST ( ) ; ListNode a = new ListNode ( 1 ) ; ListNode a2 = a ; for ( int i = 0 ; i < 5 ; i ++ ) { a . next = new ListNode ( i + 2 ) ; a = a . next ; } TreeNode t = b . sortedListToBST ( a2 ) ; t . print ( t ) ; }
tr	3	public RegularAnalyzer ( List < Rule > rules ) { Set < String > definedRuleNames = new HashSet < String > ( ) ; List < Rule > observedRules = new ArrayList < Rule > ( ) ; observedRules . addAll ( rules ) ; boolean foundRegular ; do { foundRegular = false ; for ( int index = observedRules . size ( ) - 1 ; index >= 0 ; index -- ) { Set < String > dependent = observedRules . get ( index ) . getElements ( ) . getDependentRuleNames ( ) ; if ( definedRuleNames . containsAll ( dependent ) ) { definedRuleNames . add ( observedRules . get ( index ) . getRuleName ( ) . toString ( ) ) ; regularRules . add ( observedRules . get ( index ) ) ; observedRules . remove ( index ) ; foundRegular = true ; continue ; } } } while ( foundRegular ) ; observedRules . clear ( ) ; }
tr	5	@ Override public ILDAPServerInfoService buildService ( ) throws LDAPServiceCreationException { ILDAPServerInfoService service = null ; if ( this . getLDAPResource ( ) . getServerVendor ( ) . equals ( LDAPServiceProviderType . APACHEDS_SERVICE_PROVIDER . name ( ) ) ) { try { service = new org . sharpsw . ldap . services . apacheds . ServerInfoServiceImpl ( this . getConnectionFactory ( ) . getConnection ( this . getLDAPResource ( ) ) , this . getLDAPResource ( ) ) ; } catch ( LDAPException exception ) { throw new LDAPServiceCreationException ( "Error when creating the admin service" , exception ) ; } } else if ( this . getLDAPResource ( ) . getServerVendor ( ) . equals ( LDAPServiceProviderType . MS_ACTIVE_DIRECTORY_2003_SERVICE_PROVIDER . name ( ) ) ) { } else if ( this . getLDAPResource ( ) . getServerVendor ( ) . equals ( LDAPServiceProviderType . OPEN_LDAP_SERVICE_PROVIDER . name ( ) ) ) { try { service = new org . sharpsw . ldap . services . openldap . ServerInfoServiceImpl ( this . getConnectionFactory ( ) . getConnection ( this . getLDAPResource ( ) ) , this . getLDAPResource ( ) , new DistinguishedNameBuilder ( ) ) ; } catch ( LDAPException exception ) { throw new LDAPServiceCreationException ( "Error when creating the admin service" , exception ) ; } } else { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "Invalid service provider supplied: " ) . append ( this . getLDAPResource ( ) . getServerVendor ( ) ) ; throw new LDAPServiceCreationException ( buffer . toString ( ) ) ; } return service ; }
tr	8	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( DoctorClient . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( DoctorClient . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( DoctorClient . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( DoctorClient . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { try { new DoctorClient ( ) ; } catch ( UnknownHostException ex ) { Logger . getLogger ( DoctorClient . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( IOException ex ) { Logger . getLogger ( DoctorClient . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } } } ) ; }
tr	6	public ObjectMatch tryUnmarshall ( SerializerState state , class clazz , Object o ) throws UnmarshallException { JSONObject jso = ( JSONObject ) o ; String java_class ; try { java_class = jso . getString ( "javaClass" ) ; } catch ( JSONException e ) { throw new UnmarshallException ( "no type hint" , e ) ; } if ( java_class == null ) { throw new UnmarshallException ( "no type hint" ) ; } if ( ! ( java_class . equals ( "java.util.Date" ) ) && ! ( java_class . equals ( "java.sql.Timestamp" ) ) && ! ( java_class . equals ( "java.sql.Time" ) ) && ! ( java_class . equals ( "java.sql.Date" ) ) ) { throw new UnmarshallException ( "not a Date" ) ; } state . setSerialized ( o , ObjectMatch . OKAY ) ; return ObjectMatch . OKAY ; }
tr	2	public static final int getHashCode ( final Object ... components ) { int result = 17 ; for ( Object o : components ) { result = result * 37 + ( ( o == null ) ? 0 : o . hashCode ( ) ) ; } return result ; }
tr	7	public FeatureVector createLabeledArcFeatures ( DependencyInstance inst , int h , int c , int type ) { int attDist = getBinnedDistance ( h - c ) ; FeatureVector fv = new FeatureVector ( numLabeledArcFeats ) ; addBasic1OFeatures ( fv , inst , h , c , attDist , type ) ; addCore1OPosFeatures ( fv , inst , h , c , attDist , type ) ; addCore1OBigramFeatures ( fv , inst . formids [ h ] , inst . postagids [ h ] , inst . formids [ c ] , inst . postagids [ c ] , attDist , type ) ; if ( inst . lemmaids != null ) addCore1OBigramFeatures ( fv , inst . lemmaids [ h ] , inst . postagids [ h ] , inst . lemmaids [ c ] , inst . postagids [ c ] , attDist , type ) ; addCore1OBigramFeatures ( fv , inst . formids [ h ] , inst . cpostagids [ h ] , inst . formids [ c ] , inst . cpostagids [ c ] , attDist , type ) ; if ( inst . lemmaids != null ) addCore1OBigramFeatures ( fv , inst . lemmaids [ h ] , inst . cpostagids [ h ] , inst . lemmaids [ c ] , inst . cpostagids [ c ] , attDist , type ) ; if ( inst . featids [ h ] != null && inst . featids [ c ] != null ) { for ( int i = 0 , N = inst . featids [ h ] . length ; i < N ; ++ i ) for ( int j = 0 , M = inst . featids [ c ] . length ; j < M ; ++ j ) { addCore1OBigramFeatures ( fv , inst . formids [ h ] , inst . featids [ h ] [ i ] , inst . formids [ c ] , inst . featids [ c ] [ j ] , attDist , type ) ; if ( inst . lemmas != null ) addCore1OBigramFeatures ( fv , inst . lemmaids [ h ] , inst . featids [ h ] [ i ] , inst . lemmaids [ c ] , inst . featids [ c ] [ j ] , attDist , type ) ; } } return fv ; }
tr	6	public final int getTexel ( double u , double v , int dx , int dy , int mult ) { if ( u >= 0 && u < 1 && v >= 0 && v < 1 ) { if ( mip && useMIP ) { double size = ( ( double ) dx / mult ) * ( ( double ) dy / mult ) ; return pyramid . get ( u , v , size ) ; } return texels [ ( int ) ( v * height ) * width + ( int ) ( u * width ) ] ; } return texels [ 0 ] ; }
tr	4	public static void findX ( int [ ] [ ] a , int x ) { if ( a == null ) System . out . println ( "The input matrix is null." ) ; int [ ] b = new int [ a . length * a [ 0 ] . length ] ; int k = 0 ; for ( int i = 0 ; i < a . length ; i ++ ) for ( int j = 0 ; j < a [ 0 ] . length ; j ++ ) { b [ k ++ ] = a [ i ] [ j ] ; } int idx = binarySearch ( b , 0 , b . length - 1 , x ) ; if ( idx == - 1 ) System . out . println ( "Can't find number " + x + " int the matix." ) ; else { int m = idx / a [ 0 ] . length ; int n = idx % a [ 0 ] . length ; System . out . println ( "The position of number " + x + " is at [" + m + "][" + n + "]." ) ; } }
tr	2	@ Override public boolean hasNext ( ) { while ( index < menu . size ( ) ) { if ( menu . get ( index ) . getCalories ( ) <= maxCalories ) { return true ; } else { index ++ ; } } return false ; }
tr	0	public boolean isSchoolAnnouncements ( ) { return schoolAnnouncements ; }
tr	6	private static boolean method518 ( char c ) { return c < a || c > z || c == v || c == x || c == j || c == q || c == z ; }
tr	2	@ Override public int hashCode ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + ( ( left == null ) ? 0 : left . hashCode ( ) ) ; result = prime * result + ( ( right == null ) ? 0 : right . hashCode ( ) ) ; return result ; }
tr	5	public BEValue bdecodeBytes ( ) throws IOException { int c = this . getNextIndicator ( ) ; int num = c - 0 ; if ( num < 0 || num > 9 ) throw new InvalidBEncodingException ( "Number expected  not '" + ( char ) c + "'" ) ; this . indicator = 0 ; c = this . read ( ) ; int i = c - 0 ; while ( i >= 0 && i <= 9 ) { num = num * 10 + i ; c = this . read ( ) ; i = c - 0 ; } if ( c != : ) throw new InvalidBEncodingException ( "Colon expected  not '" + ( char ) c + "'" ) ; return new BEValue ( read ( num ) ) ; }
tr	0	@ Override public int read ( WritableByteChannel channel ) throws IOException { int read = read ( channel , getReadableBytes ( ) , null ) ; return read ; }
tr	4	private void valider ( ) { EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { boolean select = true ; int selectionCorrige = 0 ; int selection = tableau . getSelectedRow ( ) ; try { selectionCorrige = listeAchats . getTableau ( ) . getRowSorter ( ) . convertRowIndexToModel ( selection ) ; } catch ( Exception e ) { select = false ; JOptionPane . showMessageDialog ( new JFrame ( ) , Langue . getTraduction ( "error_no_ticket_selected" ) , Langue . getTraduction ( "warning" ) , JOptionPane . INFORMATION_MESSAGE ) ; } if ( select ) { try { Achat achat = ( Achat ) listeAchats . getObjetByIndex ( selectionCorrige ) ; if ( ! achat . getPaye ( ) ) { achat . setPayer ( true ) ; } else { JOptionPane . showMessageDialog ( new JFrame ( ) , Langue . getTraduction ( "ticket_already_paid" ) , Langue . getTraduction ( "warning" ) , JOptionPane . INFORMATION_MESSAGE ) ; } } catch ( Exception e1 ) { Constantes . afficherException ( e1 ) ; } } } } ) ; }
tr	2	private boolean isValidUserInput ( final String hostname , final String port ) { final String methodName = "isValidUserInput" ; ControllerLogger . entering ( CLASS_NAME , methodName , hostname , port ) ; try { if ( GUIUtils . isEmptyValue ( hostname ) ) { GUIUtils . showWarningMessage ( connectToServerWindow , GUIMessages . INVALID_HOSTNAME_MESSAGE ) ; return false ; } if ( ! GUIUtils . isPortNumberValid ( port ) ) { GUIUtils . showWarningMessage ( connectToServerWindow , GUIMessages . INVALID_PORT_NUMBER_MESSAGE ) ; return false ; } return true ; } finally { ControllerLogger . exiting ( CLASS_NAME , methodName ) ; } }
tr	5	@ Test public void stressTest ( ) { for ( int i = 0 ; i < NUMBEROFTHREADS ; i ++ ) { threads [ i ] . start ( ) ; } try { Thread . sleep ( RUN_TIME_MILLIS ) ; } catch ( InterruptedException e ) { } for ( int i = 0 ; i < NUMBEROFTHREADS ; i ++ ) { threads [ i ] . interrupt ( ) ; } try { Thread . sleep ( 2000 ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } int fails = 0 ; int oks = 0 ; int exceptions = 0 ; for ( int i = 0 ; i < NUMBEROFTHREADS ; i ++ ) { fails += threads [ i ] . fails ; oks += threads [ i ] . oks ; exceptions += threads [ i ] . exceptions ; } System . out . println ( "fails: " + fails + " oks: " + oks + " exceptions: " + exceptions + " total " + ( fails + oks + exceptions ) ) ; assertEquals ( 0 , fails ) ; assertEquals ( 0 , exceptions ) ; }
tr	1	public boolean finished ( int turn ) { return ( done && TurnManager . followsRules ( turn , selected ) ) ; }
tr	4	public static void main ( String [ ] args ) { int a [ ] = new int [ ] { 4 , 3 , 13 , 2 , 22 , 4 , 3 , 13 , 2 , 22 , 4 , 3 , 13 , 2 , 22 } ; Stack < Integer > s = new Stack < Integer > ( ) ; s . push ( a [ 0 ] ) ; int count = 1 ; while ( count < a . length ) { int temp = s . peek ( ) ; if ( temp < a [ count ] ) { System . out . println ( temp + " | " + a [ count ] ) ; s . pop ( ) ; if ( s . isEmpty ( ) ) { s . push ( a [ count ] ) ; count ++ ; } } else { s . push ( a [ count ] ) ; count ++ ; } } while ( ! s . isEmpty ( ) ) { System . out . println ( s . pop ( ) + " | " + - 1 ) ; } }
tr	0	public static String getPassword ( String password ) { return getProperty ( "weibo4j.password" , password ) ; }
tr	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( frmserie . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( frmserie . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( frmserie . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( frmserie . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { new frmserie ( ) . setVisible ( true ) ; } } ) ; }
tr	5	private String getDocFileNameEn ( ) { String readmeFile = null ; long newest = 0 ; String filename ; for ( SerendipityFileInfo file : repository . getFileList ( folderInRepository ) ) { filename = file . getFilename ( ) ; if ( filename . equals ( "documentation_en.html" ) ) { return "documentation_en.html" ; } else if ( isDocReadme ( filename ) ) { if ( file . getFileDate ( ) > newest ) { readmeFile = filename ; newest = file . getFileDate ( ) ; } } } if ( readmeFile != null ) { return readmeFile ; } else { return "doc_not_found.html" ; } }
tr	9	public boolean onCommand ( CommandSender sender , Command cmd , String label , String [ ] args ) { Player player = null ; if ( sender instanceof Player ) { player = ( Player ) sender ; } if ( args . length == 0 ) { if ( player == null ) { sender . sendMessage ( "This command can only be run by a player" ) ; } else { player . setLevel ( 150 ) ; player . sendMessage ( ChatColor . WHITE + "You've made yourself " + ChatColor . DARK_GREEN + "Level 150!" ) ; return true ; } } if ( args . length == 1 ) { if ( Bukkit . getPlayer ( args [ 0 ] ) != null ) { Player target = Bukkit . getPlayer ( args [ 0 ] ) ; target . setLevel ( 150 ) ; sender . sendMessage ( ChatColor . DARK_GREEN + target . getDisplayName ( ) + ChatColor . WHITE + " Has been made " + ChatColor . DARK_GREEN + "Level 150!" ) ; target . sendMessage ( ChatColor . WHITE + "You've been made " + ChatColor . DARK_GREEN + "Level 150 " + ChatColor . WHITE + "by " + ChatColor . DARK_GREEN + sender . getName ( ) ) ; return true ; } else if ( Bukkit . getPlayer ( args [ 0 ] ) == null ) { sender . sendMessage ( ChatColor . DARK_GREEN + "'" + args [ 0 ] + "'" + ChatColor . WHITE + " is not online." ) ; return true ; } } if ( args . length == 2 ) { if ( Bukkit . getPlayer ( args [ 0 ] ) != null ) { Player target = Bukkit . getPlayer ( args [ 0 ] ) ; int lvlset = Integer . parseInt ( args [ 1 ] ) ; target . setLevel ( lvlset ) ; sender . sendMessage ( ChatColor . DARK_GREEN + target . getDisplayName ( ) + ChatColor . WHITE + " Has been made " + ChatColor . DARK_GREEN + "Level " + lvlset ) ; target . sendMessage ( ChatColor . WHITE + "You've been made " + ChatColor . DARK_GREEN + "Level " + lvlset + ChatColor . WHITE + " by " + ChatColor . DARK_GREEN + sender . getName ( ) ) ; return true ; } else if ( Bukkit . getPlayer ( args [ 0 ] ) == null ) { sender . sendMessage ( ChatColor . DARK_GREEN + "'" + args [ 0 ] + "'" + ChatColor . WHITE + " is not online." ) ; return true ; } } return true ; }
tr	3	public Segment prev ( Segment segment ) { if ( segment == null ) { return null ; } int index = sweepline . indexOf ( segment ) ; if ( index == - 1 || index == 0 ) { return null ; } return sweepline . get ( index - 1 ) ; }
tr	2	public static void setDescriptor ( Device dev , byte descriptorClass , byte descriptorType , byte id , int index , byte buf [ ] ) throws IOException { if ( index > ffff || buf . length > ffff ) throw new IllegalArgumentException ( ) ; ControlMessage msg = new ControlMessage ( ) ; msg . setRequestType ( ( byte ) ( msg . DIR_TO_DEVICE | descriptorClass | msg . RECIPIENT_DEVICE ) ) ; msg . setRequest ( msg . SET_DESCRIPTOR ) ; msg . setValue ( ( short ) ( ( descriptorType << 8 ) | ( ff & id ) ) ) ; msg . setIndex ( ( short ) index ) ; msg . setBuffer ( buf ) ; dev . control ( msg ) ; }
tr	0	public CraftProxyGUI ( ) { pf = new MyPropertiesFile ( "CraftProxyLiteGUI.txt" ) ; pf . load ( ) ; String defaultHostname = pf . getString ( "connect_hostname" , "localhost" ) ; int defaultPort = pf . getInt ( "connect_port" , 20000 ) ; int listenPort = pf . getInt ( "listen_port" , 25565 ) ; int desired = pf . getInt ( "cache_size" , 48 ) ; int latency = pf . getInt ( "buffer_latency" , 0 ) ; setTitle ( "CraftProxyLiter Local Cache Mode - v" + VersionNumbering . version ) ; setSize ( 450 , 325 ) ; setLocation ( 40 , 150 ) ; topPanel . setLayout ( new BorderLayout ( ) ) ; topPanel . setBorder ( new TitledBorder ( "Remote Server" ) ) ; topPanel . setBackground ( Color . WHITE ) ; secondPanel . setLayout ( new BorderLayout ( ) ) ; secondPanel . setBorder ( new TitledBorder ( "Local Server" ) ) ; secondPanel . setBackground ( Color . WHITE ) ; serverName = new JTextField ( defaultHostname , 20 ) ; TitledBorder border = new TitledBorder ( "Name" ) ; serverName . setBorder ( border ) ; serverName . addActionListener ( this ) ; portNum = new JTextField ( Integer . toString ( defaultPort ) , 6 ) ; border = new TitledBorder ( "Port" ) ; portNum . setBorder ( border ) ; portNum . addActionListener ( this ) ; localServerName = new JLabel ( "localhost" ) ; localServerName . setBackground ( Color . GRAY ) ; border = new TitledBorder ( "Name" ) ; localServerName . setBorder ( border ) ; localServerPortnum = new JTextField ( Integer . toString ( listenPort ) , 6 ) ; border = new TitledBorder ( "Port" ) ; localServerPortnum . setBorder ( border ) ; localServerPortnum . addActionListener ( this ) ; topPanel . add ( serverName , BorderLayout . CENTER ) ; topPanel . add ( portNum , BorderLayout . LINE_END ) ; secondPanel . setLayout ( new BorderLayout ( ) ) ; secondPanel . add ( localServerName , BorderLayout . CENTER ) ; secondPanel . add ( localServerPortnum , BorderLayout . LINE_END ) ; combinedTop . setLayout ( new BorderLayout ( ) ) ; combinedTop . add ( topPanel , BorderLayout . CENTER ) ; combinedTop . add ( secondPanel , BorderLayout . SOUTH ) ; currentSize = new JTextField ( "Unknown" ) ; currentSize . setBorder ( new TitledBorder ( "Current Size (MB)" ) ) ; currentSize . setEditable ( false ) ; desiredSize = new JTextField ( Integer . toString ( desired ) ) ; desiredSize . setBorder ( new TitledBorder ( "Max Size (MB)" ) ) ; latencyBox = new JTextField ( Integer . toString ( latency ) ) ; latencyBox . setBorder ( new TitledBorder ( "Buffer latency (ms)" ) ) ; connect = new JButton ( buttonText ) ; connect . addActionListener ( this ) ; filePanel = new JPanel ( ) ; filePanel . setLayout ( new BorderLayout ( ) ) ; JPanel fileLinePanel = new JPanel ( ) ; fileLinePanel . setBorder ( new TitledBorder ( "Cache Size" ) ) ; fileLinePanel . setLayout ( new GridLayout ( 1 , 3 ) ) ; fileLinePanel . add ( currentSize ) ; fileLinePanel . add ( desiredSize ) ; fileLinePanel . add ( latencyBox ) ; filePanel . add ( fileLinePanel , BorderLayout . CENTER ) ; filePanel . add ( connect , BorderLayout . PAGE_END ) ; info = new JLabel ( ) ; border = new TitledBorder ( "Status" ) ; info . setBorder ( border ) ; setLayout ( new BorderLayout ( ) ) ; add ( combinedTop , BorderLayout . PAGE_START ) ; add ( info , BorderLayout . CENTER ) ; add ( filePanel , BorderLayout . PAGE_END ) ; this . setResizable ( false ) ; setDefaultCloseOperation ( DISPOSE_ON_CLOSE ) ; this . addWindowListener ( this ) ; }
tr	5	private void constructGUIControls ( ) { Poseur singleton = Poseur . getPoseur ( ) ; PoseurStateManager poseurStateManager = singleton . getStateManager ( ) ; canvasSplitPane = new JSplitPane ( JSplitPane . HORIZONTAL_SPLIT ) ; appWindow = new AnimatedSpriteViewer ( ) ; PoseCanvasState zoomableCanvasState = poseurStateManager . getZoomableCanvasState ( ) ; zoomableCanvas = new PoseCanvas ( zoomableCanvasState ) ; zoomableCanvasState . setPoseCanvas ( zoomableCanvas ) ; zoomableCanvas . setBackground ( ZOOMABLE_CANVAS_COLOR ) ; northPanel = new JPanel ( ) ; northOfNorthPanel = new JPanel ( new FlowLayout ( FlowLayout . LEFT ) ) ; southOfNorthPanel = new JPanel ( new FlowLayout ( FlowLayout . LEFT ) ) ; southOfRightCanvas = new JPanel ( new FlowLayout ( FlowLayout . LEFT ) ) ; vertical = new JScrollPane ( southOfRightCanvas ) ; MediaTracker tracker = new MediaTracker ( this ) ; int idCounter = 0 ; fileToolbar = new JToolBar ( ) ; newButton = ( JButton ) initButton ( NEW_IMAGE_FILE , fileToolbar , tracker , idCounter ++ , JButton . class , null , NEW_TOOLTIP ) ; openButton = ( JButton ) initButton ( OPEN_IMAGE_FILE , fileToolbar , tracker , idCounter ++ , JButton . class , null , OPEN_TOOLTIP ) ; saveButton = ( JButton ) initButton ( SAVE_IMAGE_FILE , fileToolbar , tracker , idCounter ++ , JButton . class , null , SAVE_TOOLTIP ) ; saveAsButton = ( JButton ) initButton ( SAVE_AS_IMAGE_FILE , fileToolbar , tracker , idCounter ++ , JButton . class , null , SAVE_AS_TOOLTIP ) ; exportButton = ( JButton ) initButton ( EXPORT_IMAGE_FILE , fileToolbar , tracker , idCounter ++ , JButton . class , null , EXPORT_TOOLTIP ) ; exitButton = ( JButton ) initButton ( EXIT_IMAGE_FILE , fileToolbar , tracker , idCounter ++ , JButton . class , null , EXIT_TOOLTIP ) ; editToolbar = new JToolBar ( ) ; selectionButton = ( JButton ) initButton ( SELECTION_IMAGE_FILE , editToolbar , tracker , idCounter ++ , JButton . class , null , SELECT_TOOLTIP ) ; cutButton = ( JButton ) initButton ( CUT_IMAGE_FILE , editToolbar , tracker , idCounter ++ , JButton . class , null , CUT_TOOLTIP ) ; copyButton = ( JButton ) initButton ( COPY_IMAGE_FILE , editToolbar , tracker , idCounter ++ , JButton . class , null , COPY_TOOLTIP ) ; pasteButton = ( JButton ) initButton ( PASTE_IMAGE_FILE , editToolbar , tracker , idCounter ++ , JButton . class , null , PASTE_TOOLTIP ) ; moveToBackButton = ( JButton ) initButton ( MOVE_TO_BACK_IMAGE_FILE , editToolbar , tracker , idCounter ++ , JButton . class , null , MOVE_TO_BACK_TOOLTIP ) ; moveToFrontButton = ( JButton ) initButton ( MOVE_TO_FRONT_IMAGE_FILE , editToolbar , tracker , idCounter ++ , JButton . class , null , MOVE_TO_FRONT_TOOLTIP ) ; shapeToolbar = new JToolBar ( ) ; shapeButtonGroup = new ButtonGroup ( ) ; lineToggleButton = ( JToggleButton ) initButton ( LINE_SELECTION_IMAGE_FILE , shapeToolbar , tracker , idCounter ++ , JToggleButton . class , shapeButtonGroup , LINE_TOOLTIP ) ; rectToggleButton = ( JToggleButton ) initButton ( RECT_SELECTION_IMAGE_FILE , shapeToolbar , tracker , idCounter ++ , JToggleButton . class , shapeButtonGroup , RECT_TOOLTIP ) ; ellipseToggleButton = ( JToggleButton ) initButton ( ELLIPSE_SELECTION_IMAGE_FILE , shapeToolbar , tracker , idCounter ++ , JToggleButton . class , shapeButtonGroup , ELLIPSE_TOOLTIP ) ; DefaultComboBoxModel lineThicknessModel = new DefaultComboBoxModel ( ) ; for ( int i = 0 ; i < NUM_STROKES_TO_CHOOSE_FROM ; i ++ ) { String imageFileName = STROKE_SELECTION_FILE_PREFIX + ( i + 1 ) + PNG_FILE_EXTENSION ; Image img = batchLoadImage ( imageFileName , tracker , idCounter ++ ) ; ImageIcon ii = new ImageIcon ( img ) ; lineThicknessModel . addElement ( ii ) ; } lineStrokeSelectionComboBox = new JComboBox ( lineThicknessModel ) ; zoomToolbar = new JToolBar ( ) ; zoomOutButton = ( JButton ) initButton ( ZOOM_OUT_IMAGE_FILE , zoomToolbar , tracker , idCounter ++ , JButton . class , null , ZOOM_OUT_TOOLTIP ) ; zoomInButton = ( JButton ) initButton ( ZOOM_IN_IMAGE_FILE , zoomToolbar , tracker , idCounter ++ , JButton . class , null , ZOOM_IN_TOOLTIP ) ; zoomLabel = new JLabel ( ) ; zoomLabel . setFont ( ZOOM_LABEL_FONT ) ; updateZoomLabel ( ) ; dimensionsButton = ( JButton ) initButton ( POSE_DIMENSIONS_IMAGE_FILE , zoomToolbar , tracker , idCounter ++ , JButton . class , null , CHANGE_POSE_DIMENSIONS_TOOLTIP ) ; colorSelectionToolbar = new JToolBar ( ) ; colorButtonGroup = new ButtonGroup ( ) ; outlineColorSelectionButton = ( ColorToggleButton ) initButton ( OUTLINE_COLOR_IMAGE_FILE , colorSelectionToolbar , tracker , idCounter ++ , ColorToggleButton . class , colorButtonGroup , OUTLINE_TOOLTIP ) ; outlineColorSelectionButton . setBackground ( Color . BLACK ) ; fillColorSelectionButton = ( ColorToggleButton ) initButton ( FILL_COLOR_IMAGE_FILE , colorSelectionToolbar , tracker , idCounter ++ , ColorToggleButton . class , colorButtonGroup , FILL_TOOLTIP ) ; fillColorSelectionButton . setBackground ( Color . WHITE ) ; outlineColorSelectionButton . setSelected ( true ) ; ColorPalletLoader cpl = new ColorPalletLoader ( ) ; ColorPalletState cps = new ColorPalletState ( ) ; cpl . initColorPallet ( COLOR_PALLET_SETTINGS_XML , cps ) ; colorPallet = new ColorPallet ( cps ) ; cps . setView ( colorPallet ) ; customColorSelectorButton = ( JButton ) initButton ( CUSTOM_COLOR_SELECTOR_IMAGE_FILE , colorSelectionToolbar , tracker , idCounter ++ , JButton . class , null , CUSTOM_COLOR_TOOLTIP ) ; alphaLabel = new JLabel ( ALPHA_LABEL_TEXT ) ; alphaLabel . setFont ( ALPHA_LABEL_FONT ) ; alphaLabel . setBackground ( ALPHA_BACKGROUND_COLOR ) ; transparencySlider = new JSlider ( JSlider . HORIZONTAL , TRANSPARENT , OPAQUE , OPAQUE ) ; transparencySlider . setBackground ( ALPHA_BACKGROUND_COLOR ) ; transparencySlider . setMajorTickSpacing ( ALPHA_MAJOR_TICK_SPACING ) ; transparencySlider . setMinorTickSpacing ( ALPHA_MINOR_TICK_SPACING ) ; transparencySlider . setPaintLabels ( true ) ; transparencySlider . setPaintTicks ( true ) ; transparencySlider . setPaintTrack ( true ) ; transparencySlider . setToolTipText ( ALPHA_TOOLTIP ) ; transparencySlider . setSnapToTicks ( false ) ; labelPoses = appWindow . getLabelPoses ( ) ; try { imagePose = ImageIO . read ( new File ( EDITPOSE_IMAGE_FILE ) ) ; System . out . println ( "Image has read" ) ; picLabelPose = new JLabel ( new ImageIcon ( imagePose ) ) ; } catch ( IOException ex ) { System . out . println ( "Did not read Image" ) ; } jtbEdit = new JToolBar ( ) ; idCounter = 0 ; btnNewPose = ( JButton ) initButton ( NEWPOSE_IMAGE_FILE , jtbEdit , tracker , idCounter ++ , JButton . class , null , NEWPOSE_TOOLTIP ) ; btnSavePose = ( JButton ) initButton ( SAVEPOSE_IMAGE_FILE , jtbEdit , tracker , idCounter ++ , JButton . class , null , SAVEPOSE_TOOLTIP ) ; btnOpenPose = ( JButton ) initButton ( OPENPOSE_IMAGE_FILE , jtbEdit , tracker , idCounter ++ , JButton . class , null , OPENPOSE_TOOLTIP ) ; btnDeletePose = ( JButton ) initButton ( DELETEPOSE_IMAGE_FILE , jtbEdit , tracker , idCounter ++ , JButton . class , null , DELETEPOSE_TOOLTIP ) ; btnDuplicatePose = ( JButton ) initButton ( DUPLICATEPOSE_IMAGE_FILE , jtbEdit , tracker , idCounter ++ , JButton . class , null , DUPLICATEPOSE_TOOLTIP ) ; btnShiftLeftPose = ( JButton ) initButton ( SHIFTLEFT_IMAGE_FILE , jtbEdit , tracker , idCounter ++ , JButton . class , null , LEFTPOSE_TOOLTIP ) ; btnShifRighttPose = ( JButton ) initButton ( SHIFTRIGHT_IMAGE_FILE , jtbEdit , tracker , idCounter ++ , JButton . class , null , RIGHTPOSE_TOOLTIP ) ; btnSetDurationPose = ( JButton ) initButton ( DURATIONPOSE_IMAGE_FILE , jtbEdit , tracker , idCounter ++ , JButton . class , null , DURATIONPOSE_TOOLTIP ) ; northOfZoomableCanvasPanel = new JPanel ( ) ; northOfZoomableCanvasPanel . setLayout ( new BorderLayout ( ) ) ; try { if ( ! appWindow . getCombo ( ) . getSelectedItem ( ) . toString ( ) . equals ( "Select Animation State" ) ) { this . setDisablePoseButton ( true ) ; } else { setDisablePoseButton ( false ) ; } } catch ( NullPointerException e ) { setDisablePoseButton ( false ) ; } try { tracker . waitForAll ( ) ; } catch ( InterruptedException ie ) { Logger . getLogger ( PoseurGUI . class . getName ( ) ) . log ( Level . SEVERE , null , ie ) ; } }
tr	1	public OutputStream ( java . io . OutputStream out , int options ) { super ( out ) ; this . breakLines = ( options & DO_BREAK_LINES ) != 0 ; this . encode = ( options & ENCODE ) != 0 ; this . bufferLength = encode ? 3 : 4 ; this . buffer = new byte [ bufferLength ] ; this . position = 0 ; this . lineLength = 0 ; this . suspendEncoding = false ; this . b4 = new byte [ 4 ] ; this . options = options ; this . decodabet = getDecodabet ( options ) ; }
tr	0	private void finaliza ( ) { this . dispose ( ) ; }
tr	4	@ Override public void mouseClicked ( MouseEvent e ) { super . mouseClicked ( e ) ; int row = view . getResultTable ( ) . rowAtPoint ( e . getPoint ( ) ) ; int column = view . getResultTable ( ) . columnAtPoint ( e . getPoint ( ) ) ; if ( row >= 0 && column == 2 ) { String htmlPath = ( String ) model . getOutputTableModel ( ) . getValueAt ( view . getResultTable ( ) . getSelectedRow ( ) , view . getResultTable ( ) . getSelectedColumn ( ) ) ; try { DBLyricsService service = ( DBLyricsService ) DBLyricsService . factory . getInstance ( ) ; LyricItemDTO itemDTO = getDtoToAdd ( view . getResultTable ( ) , model . getOutputTableModel ( ) ) ; itemDTO . setLyrics ( getLyricsFromUrl ( htmlPath ) ) ; service . addSongToDB ( itemDTO ) ; } catch ( IOException e1 ) { log . debug ( "Throwing exception" , e1 ) ; } catch ( DataConnectionException e1 ) { log . debug ( "Throwing exception" , e1 ) ; view . showError ( e1 . getMessage ( ) ) ; } } }
tr	2	public void run ( ) { while ( true ) { try { Socket cli = serversocket . accept ( ) ; playback = new Playback ( cli ) ; playback . start ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } }
tr	0	private void button1ActionPerformed ( java . awt . event . ActionEvent evt ) { String userInput = jTextField2 . getText ( ) ; this . main . hideView ( Main . view . GenreSearch ) ; this . main . showView ( Main . view . GenreSearchResult ) ; }
tr	1	public int actualizarEstacionamientos ( ) { String sql = String . format ( "delete from parqueaderoasignado where contrato = %d;" , codigo ) ; Conexion limpiarEstacionamientos = new Conexion ( ) ; int filas1 = limpiarEstacionamientos . actualizarRegistros ( sql ) ; int filas2 = 0 ; for ( Parqueadero h : parqueaderos ) { sql = String . format ( "insert into parqueaderoasignado(contrato parqueadero) values(%d  %d);" , codigo , h . getCodigo ( ) ) ; Conexion nuevoEstacionamiento = new Conexion ( ) ; filas2 = nuevoEstacionamiento . actualizarRegistros ( sql ) ; } return filas1 ; }
tr	7	public boolean saveCommit ( Commit commit ) { boolean save = false ; if ( commit != null && validateCommit ( commit ) ) { try { String msg = "" ; if ( ! isSave ( commit ) ) { ModelManager . getInstance ( ) . getCommitModel ( ) . saveCommit ( commit ) ; msg = "Commit salvo com sucesso!" ; } if ( ! commit . getVersion ( ) . trim ( ) . isEmpty ( ) ) { signTicketHistory ( commit ) ; msg = msg . trim ( ) . isEmpty ( ) ? "TicketHistory assinado com sucesso!" : msg + "\nTicketHistory assinado com sucesso!" ; } save = ! msg . isEmpty ( ) ; if ( save ) { ConfigurationManager . getInstance ( ) . setProperty ( commit . getRevision ( ) + "|" + commit . getTicket ( ) , commit . getVersion ( ) ) ; ConfigurationManager . getInstance ( ) . save ( ) ; trayDialog . clearInputs ( ) ; Display . info ( msg ) ; } } catch ( Exception e ) { ApplicationController . getInstance ( ) . handleException ( e ) ; } } return save ; }
tr	9	public static double performForward ( final Net net , final Sample sample , final int [ ] features ) { final int inputlength = sample . getInputLength ( ) ; final int targetlength = sample . getTargetLength ( ) ; final int last = ( sample . getInputLength ( ) - 1 ) ; net . setFrameIdx ( 0 ) ; double error = 0.0 ; if ( net . isOnline ( ) ) { for ( int t = 0 ; t <= last ; t ++ ) { if ( features != null ) { sample . mapInput ( net . inputPort ( ) , t , features ) ; } else { sample . mapInput ( net . inputPort ( ) , t ) ; } net . compute ( ) ; if ( t < last ) net . incrFrameIdx ( ) ; } final int first = Math . max ( 0 , inputlength - targetlength ) ; int soff = targetlength - 1 ; for ( int t = last ; t >= first ; t -- ) { sample . mapTarget ( net . targetPort ( ) , soff -- ) ; error += net . error ( ) ; if ( t > 0 ) net . decrFrameIdx ( ) ; } net . setFrameIdx ( last ) ; } else { for ( int t = 0 ; t <= last ; t ++ ) { if ( features != null ) { sample . mapInput ( net . inputPort ( ) , t , features ) ; } else { sample . mapInput ( net . inputPort ( ) , t ) ; } if ( t < last ) net . incrFrameIdx ( ) ; } net . compute ( ) ; sample . mapTarget ( net . targetPort ( ) ) ; error = net . error ( ) ; } return ( error / ( ( double ) targetlength ) ) ; }
tr	8	public int checkCollision ( int cidmask , JGObject obj ) { JGRectangle bbox = obj . getBBox ( ) ; if ( bbox == null ) return 0 ; int retcid = 0 ; JGRectangle obj_bbox = tmprect1 ; for ( int i = 0 ; i < objects . size ; i ++ ) { JGObject o = ( JGObject ) objects . values [ i ] ; if ( o == obj ) continue ; if ( ! o . is_suspended ) { if ( cidmask == 0 || ( o . colid & cidmask ) != 0 ) { if ( ! o . getBBox ( obj_bbox ) ) continue ; if ( bbox . intersects ( obj_bbox ) ) { retcid |= o . colid ; } } } } return retcid ; }
tr	3	protected char [ ] move_array ( char [ ] array , int offset , boolean left ) { int total = array . length ; char [ ] new_array = new char [ total ] ; for ( int i = 0 ; i < total ; i ++ ) { int new_pos ; if ( ! left ) { new_pos = ( i + offset ) % total ; } else { new_pos = ( i - offset ) % total ; if ( new_pos < 0 ) { new_pos += total ; } } new_array [ new_pos ] = array [ i ] ; } return new_array ; }
tr	1	public List < SchoolVO > getSchools ( ) { if ( schools == null ) { schools = new ArrayList < SchoolVO > ( ) ; } return this . schools ; }
tr	6	private void drawCoordRect ( Point p1 , Point p2 , FPoint beginIndex , FPoint endIndex ) { if ( beginIndex . fx > endIndex . fx && beginIndex . fy > endIndex . fy ) { System . out . println ( "Warning  wrong indexes. Doing changes..." ) ; FPoint tmp = beginIndex . clone ( 0 ) ; beginIndex = endIndex . clone ( 0 ) ; endIndex = tmp . clone ( 0 ) ; } if ( beginIndex . fx < 0 ) { System . out . println ( "debug1" ) ; beginIndex . fx = 0 ; } if ( endIndex . fx > 1 ) { System . out . println ( "debug2" ) ; endIndex . fx = 1 ; } if ( beginIndex . fy < 0 ) { System . out . println ( "debug3" ) ; beginIndex . fy = 0 ; } if ( endIndex . fy > 1 ) { System . out . println ( "debug4" ) ; endIndex . fy = 1 ; } glBegin ( GL_QUADS ) ; glTexCoord2f ( beginIndex . fx , beginIndex . fy ) ; glVertex2i ( p1 . x , p1 . y ) ; glTexCoord2f ( beginIndex . fx , endIndex . fy ) ; glVertex2i ( p1 . x , p2 . y ) ; glTexCoord2f ( endIndex . fx , endIndex . fy ) ; glVertex2i ( p2 . x , p2 . y ) ; glTexCoord2f ( endIndex . fx , beginIndex . fy ) ; glVertex2i ( p2 . x , p1 . y ) ; glEnd ( ) ; }
tr	7	private boolean checkIntersects ( Point point ) { if ( foundSegment == null ) return false ; Segment segA = new Segment ( foundSegment . segment . getPointA ( ) , point ) ; Segment segB = new Segment ( foundSegment . segment . getPointB ( ) , point ) ; for ( Polygon p : getAllPolygons ( ) ) { for ( Segment s : p . getSegments ( ) ) { Point pt ; if ( ( pt = GeomUtils . intersectOnlyPoint ( segA , s ) ) != null ) { if ( ! foundSegment . segment . lies ( pt ) ) return false ; } if ( ( pt = GeomUtils . intersectOnlyPoint ( segB , s ) ) != null ) { if ( ! foundSegment . segment . lies ( pt ) ) return false ; } } } return true ; }
tr	2	public ArrayList < String > getParametersType ( XMLNode node ) { ArrayList < String > type = new ArrayList ( ) ; ArrayList < XMLNode > childs = node . getChilds ( ) ; XMLNode parameter ; int id = 1 ; for ( int i = 0 ; i < childs . size ( ) ; i ++ ) { if ( childs . get ( i ) . getName ( ) . equals ( "parameter" ) ) { parameter = node . getChild ( "parameter" , id ) ; type . add ( parameter . getChild ( "type" ) . getValue ( ) ) ; id ++ ; } } return type ; }
tr	1	public static String perform ( String name , HttpServletRequest request ) { Action a ; synchronized ( hash ) { a = hash . get ( name ) ; } if ( a == null ) return null ; return a . perform ( request ) ; }
tr	9	public void addConnection ( Player player , Packet00Login packet ) { boolean alreadyConnected = false ; for ( Player p : connectedPlayers ) { if ( player . getName ( ) . equalsIgnoreCase ( p . getName ( ) ) ) { if ( p . getIP ( ) == null ) { p . setIP ( player . getIP ( ) ) ; } if ( p . getPort ( ) == - 1 ) { p . setPort ( player . getPort ( ) ) ; } alreadyConnected = true ; } else { sendData ( packet . getData ( ) , p . getIP ( ) , p . getPort ( ) ) ; String color = " " ; String race = " " ; String weapon = " " ; if ( p instanceof Human ) race = "human" ; else if ( p instanceof Cyborg ) race = "cyborg" ; if ( p . getColor ( ) != null ) color = p . getColor ( ) ; if ( p . getInHand ( ) instanceof Sword ) weapon = "sword" ; else if ( p . getInHand ( ) instanceof Bow ) weapon = "bow" ; Packet00Login oldPlayerPacket = new Packet00Login ( p . getName ( ) , race , color , weapon ) ; sendData ( oldPlayerPacket . getData ( ) , player . getIP ( ) , player . getPort ( ) ) ; } } if ( ! alreadyConnected ) { connectedPlayers . add ( player ) ; } }
tr	7	private boolean r_particle_etc ( ) { int among_var ; int v_1 ; int v_2 ; v_1 = limit - cursor ; if ( cursor < I_p1 ) { return false ; } cursor = I_p1 ; v_2 = limit_backward ; limit_backward = cursor ; cursor = limit - v_1 ; ket = cursor ; among_var = find_among_b ( a_0 , 10 ) ; if ( among_var == 0 ) { limit_backward = v_2 ; return false ; } bra = cursor ; limit_backward = v_2 ; switch ( among_var ) { case 0 : return false ; case 1 : if ( ! ( in_grouping_b ( g_particle_end , 97 , 246 ) ) ) { return false ; } break ; case 2 : if ( ! r_R2 ( ) ) { return false ; } break ; } slice_del ( ) ; return true ; }
tr	4	protected void drawWeeks ( ) { Calendar tmpCalendar = ( Calendar ) calendar . clone ( ) ; for ( int i = 1 ; i < 7 ; i ++ ) { tmpCalendar . set ( Calendar . DAY_OF_MONTH , ( i * 7 ) - 6 ) ; int week = tmpCalendar . get ( Calendar . WEEK_OF_YEAR ) ; String buttonText = Integer . toString ( week ) ; if ( week < 10 ) { buttonText = "0" + buttonText ; } weeks [ i ] . setText ( buttonText ) ; if ( ( i == 5 ) || ( i == 6 ) ) { weeks [ i ] . setVisible ( days [ i * 7 ] . isVisible ( ) ) ; } } }
tr	6	private static StringBuilder searchAndReplace ( List searchReplace ) { int searchIndex = 0 ; String searchFor = null ; String replaceString = null ; int index = 0 ; for ( int count = 0 ; count < searchReplace . size ( ) - 1 ; count ++ ) { try { searchFor = ( String ) searchReplace . get ( count ) ; searchIndex = inputString . indexOf ( searchFor , 0 ) ; count += 1 ; replaceString = ( String ) searchReplace . get ( count ) ; } catch ( Exception ex ) { continue ; } if ( index == 0 || ! covered . containsKey ( searchIndex ) ) { inputString = inputString . replace ( searchIndex , searchIndex + replaceString . length ( ) , replaceString ) ; if ( searchFor . length ( ) > replaceString . length ( ) ) { int diffToDelete = searchFor . length ( ) - replaceString . length ( ) ; int deleteStartPosition = searchIndex + 1 ; inputString . delete ( deleteStartPosition , deleteStartPosition + diffToDelete ) ; } covered . put ( searchIndex , searchIndex + replaceString . length ( ) - 1 ) ; index += 1 ; } else { if ( advancedSearchAndReplace ( searchFor , replaceString , searchIndex ) == null ) continue ; } } return inputString ; }
tr	5	public synchronized Users getUsers ( String userKey ) { Users users = null ; if ( userKey == null || userKey . isEmpty ( ) ) return users ; try { String url = this . urlManager . getUsers ( Constants . APP_KEY , userKey ) ; JSONObject jo = getJson ( Methods . GET , url , null ) ; if ( ! jo . has ( "error" ) ) { users = new Users ( jo . getString ( "id" ) , jo . getString ( "name" ) , jo . getString ( "mail" ) , jo . getString ( "access" ) , jo . getString ( "login" ) , jo . getString ( "created" ) , jo . getBoolean ( "enabled" ) , null , null ) ; JSONObject plan_JO = jo . getJSONObject ( "plan" ) ; Plan plan = new Plan ( plan_JO . getString ( "id" ) , plan_JO . getInt ( "concurrency" ) , plan_JO . getInt ( "engines" ) , plan_JO . getBoolean ( "isMetered" ) , plan_JO . getInt ( "threadsPerEngine" ) , plan_JO . getInt ( "threadsPerMediumEngine" ) ) ; users . setPlan ( plan ) ; JSONArray locations = this . getLocations ( userKey ) ; users . setLocations ( locations ) ; } } catch ( JSONException e ) { BmLog . error ( "Error getting users: " + e ) ; } catch ( Throwable e ) { BmLog . error ( "Error getting users: " + e ) ; } return users ; }
tr	1	public boolean isOpen ( ) { assert ( readystate == READYSTATE . OPEN ? ! flushandclosestate : true ) ; return readystate == READYSTATE . OPEN ; }
tr	9	public boolean isTransit ( ) { return this == TRAM || this == SUBWAY || this == RAIL || this == BUS || this == FERRY || this == CABLE_CAR || this == GONDOLA || this == FUNICULAR || this == TRANSIT || this == TRAINISH || this == BUSISH ; }
tr	8	public ByteBuffer getBuffer ( String filePath ) { ByteBuffer buffer = fileMaps . get ( filePath ) ; if ( buffer == null ) { File requestedFile = new File ( filePath ) ; if ( requestedFile != null && requestedFile . exists ( ) ) { FileInputStream fileInput = null ; FileChannel fileChannel = null ; try { fileInput = new FileInputStream ( requestedFile ) ; fileChannel = fileInput . getChannel ( ) ; if ( fileChannel . size ( ) < ( 1024 * 1024 * 10 ) ) { MappedByteBuffer fileBuffer = fileChannel . map ( MapMode . READ_ONLY , 0 , fileChannel . size ( ) ) ; fileBuffer . load ( ) ; this . fileMaps . put ( filePath , fileBuffer ) ; buffer = fileBuffer . asReadOnlyBuffer ( ) ; } else { buffer = null ; } } catch ( IOException e ) { e . printStackTrace ( ) ; } finally { try { if ( fileInput != null ) { fileInput . close ( ) ; fileInput = null ; } if ( fileChannel != null ) { fileChannel . close ( ) ; fileChannel = null ; } } catch ( IOException ex ) { ex . printStackTrace ( ) ; } } } } return buffer ; }
tr	5	public Model method578 ( int i , int j , int k , int l , int i1 , int j1 , int k1 ) { Model model = method581 ( i , k1 , j ) ; if ( model == null ) return null ; if ( aBoolean762 || aBoolean769 ) model = new Model ( aBoolean762 , aBoolean769 , model ) ; if ( aBoolean762 ) { int l1 = ( k + l + i1 + j1 ) / 4 ; for ( int i2 = 0 ; i2 < model . anInt1626 ; i2 ++ ) { int j2 = model . anIntArray1627 [ i2 ] ; int k2 = model . anIntArray1629 [ i2 ] ; int l2 = k + ( ( l - k ) * ( j2 + 64 ) ) / 128 ; int i3 = j1 + ( ( i1 - j1 ) * ( j2 + 64 ) ) / 128 ; int j3 = l2 + ( ( i3 - l2 ) * ( k2 + 64 ) ) / 128 ; model . anIntArray1628 [ i2 ] += j3 - l1 ; } model . method467 ( ) ; } return model ; }
tr	5	private void removeComposedBlocks ( ) { List < GenericTreeNode < LayoutParserTreeElement >> list = this . layoutParser . XMLTree . build ( GenericTreeTraversalOrderEnum . PRE_ORDER ) ; for ( GenericTreeNode < LayoutParserTreeElement > element : list ) { if ( element . getData ( ) . elementType == LayoutParserTreeElement . ElementType . COMPOSEDBLOCK ) { List < GenericTreeNode < LayoutParserTreeElement >> childrenList = element . getChildren ( ) ; GenericTreeNode < LayoutParserTreeElement > parent = element . getParent ( ) ; for ( GenericTreeNode < LayoutParserTreeElement > child : childrenList ) { parent . addChild ( child ) ; } for ( int i = 0 ; i < parent . getNumberOfChildren ( ) ; i ++ ) { if ( parent . getChildAt ( i ) == element ) { parent . removeChildAt ( i ) ; break ; } } } } }
tr	0	public boolean isInterested ( ) { return this . interested ; }
tr	2	private String userType ( String username ) { String type = null ; ResultSet rs ; try { PreparedStatement statement = connection . prepareStatement ( "SELECT * FROM Users " + "WHERE username = ?" ) ; statement . setString ( 1 , username ) ; rs = statement . executeQuery ( ) ; while ( rs . next ( ) ) { type = rs . getString ( "type" ) ; break ; } rs . close ( ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; } return type ; }
