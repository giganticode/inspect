va	2	@ Override public Set < FileElement > listFiles ( ) throws IOException { Set < FileElement > result = new LinkedHashSet < FileElement > ( ) ; File [ ] files = file . listFiles ( ) ; if ( files == null ) { String message = "Unknown I/O error when listing files in directory '%s'." ; throw new IOException ( String . format ( message , file ) ) ; } for ( File child : file . listFiles ( ) ) { result . add ( new JavaIoFileAdapter ( child ) ) ; } return result ; }
va	1	private void addProductionAttribute ( Element node , ParsingTreeNode treeNode ) { final Production prod = treeNode . getProduction ( ) ; if ( prod != null ) { final Attr productionAttr = document . createAttribute ( ATTR_PRODUCTION ) ; productionAttr . setValue ( treeNode . getProduction ( ) . toString ( ) ) ; node . setAttributeNode ( productionAttr ) ; } }
va	6	public static int [ ] maxNonZeroRandomSet ( int n , int sum , int max ) { if ( sum < n ) { throw new IllegalArgumentException ( "Cannot satisfy sum." ) ; } for ( int i = 0 ; i < MAX_TRIES ; i ++ ) { boolean found = true ; int [ ] temp = randomSet ( n , sum ) ; inner : for ( int j = 0 ; j < n ; j ++ ) { if ( temp [ j ] == 0 || temp [ j ] > max ) { found = false ; break inner ; } } if ( found ) { return temp ; } } throw new RuntimeException ( "too many attempts. n  sum  max = " + n + "  " + sum + "  " + max ) ; }
va	8	public List < CoverDetails > getCovers ( MyProgressTracker logger ) { List < CoverDetails > covers = new LinkedList < CoverDetails > ( ) ; try { File coversFile = getCoversFile ( ) ; if ( coversFile . isFile ( ) ) { InputStreamReader is = new InputStreamReader ( new FileInputStream ( coversFile ) , "UTF-8" ) ; BufferedReader in = new BufferedReader ( is ) ; while ( true ) { String line = in . readLine ( ) ; if ( line == null ) { break ; } JSONObject json = new JSONObject ( new JSONTokener ( line ) ) ; CoverDetails cover = ser . deserialize ( json ) ; covers . add ( cover ) ; } CoverDetails . fixMultiDiscAlbums ( covers ) ; logger . log ( "Loading images" ) ; long start = System . currentTimeMillis ( ) ; boolean loadImages = true ; if ( loadImages ) { int count = 0 ; logger . setMinMax ( 0 , covers . size ( ) ) ; for ( CoverDetails cover : covers ) { logger . setProgress ( count ) ; if ( ( count % 50 ) == 0 ) { logger . log ( "Loaded " + count + " out of " + covers . size ( ) ) ; } count ++ ; int id = cover . getId ( ) ; File imageFile = getImageFile ( id ) ; BufferedImage image = null ; try { image = ImageIO . read ( imageFile ) ; cover . setImage ( image ) ; } catch ( IOException e ) { logger . log ( "Failed to read image from " + imageFile + " with " + e ) ; e . printStackTrace ( ) ; } } } logger . log ( "Loaded " + covers . size ( ) + " images in " + ( System . currentTimeMillis ( ) - start ) + "ms" ) ; } } catch ( Exception e ) { System . out . println ( "Failed to read back file with " + e ) ; e . printStackTrace ( ) ; } return covers ; }
va	5	@ Override public void run ( ) { String mapName ; QPixmap img ; Pair pair ; MapManagerCb runnable ; while ( true ) { synchronized ( requests ) { try { requests . wait ( 5000 ) ; } catch ( InterruptedException ex ) { } } for ( int i = 0 ; i < requests . size ( ) ; ++ i ) { pair = requests . poll ( ) ; runnable = pair . getRunnable ( ) ; mapName = pair . getMapName ( ) ; if ( cache . get ( mapName ) != null ) { runnable . run ( mapName , cache . get ( mapName ) ) ; continue ; } else { img = fetchMinimap ( mapName ) ; if ( img == null ) { requests . add ( pair ) ; continue ; } } cache . put ( mapName , img ) ; runnable . run ( mapName , img ) ; } } }
va	3	public static int getState ( int t ) { if ( t < 400 ) { return 0 ; } else if ( t < 1600 ) { return 1 ; } else if ( t < 3200 ) { return 2 ; } else { return 3 ; } }
va	4	private void updateWind ( ) { if ( ( maxWind < 0 && wind < maxWind ) || ( 0 < maxWind && maxWind < wind ) ) { wind += - maxWind / ( FPS * 2 ) ; } else { wind += maxWind / ( FPS * 2 ) ; } }
va	6	public static void main ( String [ ] args ) { Project predictiveEngine = ProjectMockBuilder . createPredictiveEngine ( ) ; TheBoss theBoss = new TheBoss ( ) ; for ( Employee employee : predictiveEngine . getTeam ( ) ) { if ( employee instanceof ProjectManager ) { theBoss . whip ( ( ProjectManager ) employee ) ; } else if ( employee instanceof Architect ) { theBoss . whip ( ( Architect ) employee ) ; } else if ( employee instanceof Analyst ) { theBoss . whip ( ( Analyst ) employee ) ; } else if ( employee instanceof Developer ) { theBoss . whip ( ( Developer ) employee ) ; } else if ( employee instanceof Tester ) { theBoss . whip ( ( Tester ) employee ) ; } } }
va	3	public static void encodeIntoImage ( File containerImg , File outputFile , byte [ ] srcBytes , String key ) { try { BufferedImage in = ImageIO . read ( containerImg ) ; BufferedImage newImage = new BufferedImage ( in . getWidth ( ) , in . getHeight ( ) , BufferedImage . TYPE_INT_ARGB ) ; Graphics2D g = newImage . createGraphics ( ) ; g . drawImage ( in , 0 , 0 , null ) ; g . dispose ( ) ; srcBytes = CompressionProvider . compressBytes ( srcBytes ) ; byte [ ] encryptedBytes = EncryptionProvider . encryptBytes ( srcBytes , key . getBytes ( ) ) ; short [ ] srcS = new short [ encryptedBytes . length ] ; for ( int i = 0 ; i < encryptedBytes . length ; i ++ ) { srcS [ i ] = ( short ) ( encryptedBytes [ i ] & FF ) ; } ImageEncoder . writeBytesToImage ( in , encryptedBytes , outputFile . toString ( ) , key ) ; System . out . println ( "[OK] Steganographic .png \"" + outputFile . toString ( ) + "\" generated." ) ; } catch ( DataFormatException ex ) { Logger . getLogger ( ImageUtils . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( NoSuchAlgorithmException | NoSuchPaddingException | InvalidKeyException | InvalidAlgorithmParameterException | IllegalBlockSizeException | BadPaddingException | ImageWriteException | IOException ex ) { Logger . getLogger ( ImageUtils . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } }
va	9	@ Override public Object getValueAt ( int rowIndex , int columnIndex ) { switch ( columnIndex ) { case 0 : return competition . getRaces ( ) . get ( rowIndex ) . getNumber ( ) ; case 1 : return competition . getRaces ( ) . get ( rowIndex ) . getJogger ( ) . getName ( ) ; case 2 : return ( competition . getStartTime ( ) != null ) ? new SimpleDateFormat ( "dd/MM/yyyy HH:mm:ss" ) . format ( competition . getStartTime ( ) ) : "--/--/---- --:--:--" ; case 3 : return ( competition . getRaces ( ) . get ( rowIndex ) . getEndTime ( ) != null ) ? new SimpleDateFormat ( "HH:mm:ss" ) . format ( competition . getRaces ( ) . get ( rowIndex ) . getEndTime ( ) ) : "--:--:--" ; case 4 : return ( competition . getStartTime ( ) == null || competition . getRaces ( ) . get ( rowIndex ) . getEndTime ( ) == null ) ? "--:--:--" : new SimpleDateFormat ( "HH:mm:ss" ) . format ( new Date ( competition . getRaces ( ) . get ( rowIndex ) . getDuration ( ) . getTime ( ) - ( 1000 * 60 * 60 ) ) ) ; default : return "Inconnu" ; } }
va	7	@ Override public void getDataAttdRecord ( ClassInfo currentCourse , List < AttdRecordMuldaysInfo > infoList ) { if ( infoList != null ) { String crsDirName = getDirName ( currentCourse ) ; File dir = new File ( crsDirName ) ; if ( dir . exists ( ) && dir . isDirectory ( ) ) { File [ ] files = dir . listFiles ( ) ; List < AttdRecordInfo > oneDayARList = null ; for ( int i = 0 ; i < files . length ; i ++ ) { String arFileName = files [ i ] . getName ( ) ; Date dt = getDate ( arFileName ) ; oneDayARList = new ArrayList < AttdRecordInfo > ( ) ; getDataAttdRecord ( currentCourse , dt , oneDayARList ) ; for ( AttdRecordInfo ar : oneDayARList ) { DateAttd da = new DateAttd ( dt , ar . isAttendant ( ) ) ; String stdId = ar . getStdInfo ( ) . getStudentId ( ) ; for ( AttdRecordMuldaysInfo arm : infoList ) { if ( arm . getStdInfo ( ) . getStudentId ( ) . equalsIgnoreCase ( stdId ) ) { arm . getAttdList ( ) . add ( da ) ; } } } } } } }
va	7	private void tallyTree ( Tree < String > tree , Counter < String > symbolCounter , Counter < UnaryRule > unaryRuleCounter , Counter < BinaryRule > binaryRuleCounter ) { if ( tree . isLeaf ( ) ) return ; if ( tree . isPreTerminal ( ) ) return ; if ( tree . getChildren ( ) . size ( ) == 1 ) { UnaryRule unaryRule = makeUnaryRule ( tree ) ; symbolCounter . incrementCount ( tree . getLabel ( ) , 1.0 ) ; unaryRuleCounter . incrementCount ( unaryRule , 1.0 ) ; } if ( tree . getChildren ( ) . size ( ) == 2 ) { BinaryRule binaryRule = makeBinaryRule ( tree ) ; symbolCounter . incrementCount ( tree . getLabel ( ) , 1.0 ) ; binaryRuleCounter . incrementCount ( binaryRule , 1.0 ) ; } if ( tree . getChildren ( ) . size ( ) < 1 || tree . getChildren ( ) . size ( ) > 2 ) { throw new RuntimeException ( "Attempted to construct a Grammar with an illegal tree (unbinarized?): " + tree ) ; } for ( Tree < String > child : tree . getChildren ( ) ) { tallyTree ( child , symbolCounter , unaryRuleCounter , binaryRuleCounter ) ; } }
va	2	public LevelLoader ( ) { levelpacks = new HashMap < String , LevelPack > ( ) ; packnames = new ArrayList < String > ( ) ; System . out . println ( "Levelpack Version: " + DataManager . readFile ( "version" ) ) ; String [ ] levels = DataManager . readFile ( "levellist" ) . split ( "\n" ) ; for ( String levelname : levels ) { System . out . println ( "Loading Levelpack " + levelname ) ; try { levelpacks . put ( levelname , new LevelPack ( levelname ) ) ; packnames . add ( levelname ) ; } catch ( Exception e ) { System . out . println ( "Levelpack " + levelname + " failed to load" ) ; } } instance = this ; }
va	5	public void replaceLetters ( String s ) { int i = findPos ( s ) ; System . out . println ( "pos detected to be " + i ) ; if ( i >= 0 ) { String newS = "" ; for ( int j = 0 ; j < i ; j ++ ) { newS = newS + name . charAt ( j ) ; } for ( int j = i ; j < i + s . length ( ) ; j ++ ) { int z = rand . nextInt ( 2 ) ; if ( z == 0 ) { newS = newS + chooseConsonne ( ) ; } else { newS = newS + chooseVoyelle ( ) ; } } for ( int j = i + s . length ( ) ; j < name . length ( ) ; j ++ ) { newS = newS + name . charAt ( j ) ; } System . out . println ( "new string = " + newS ) ; name = newS ; } }
va	1	public static BaseDeDatos GetInstance ( ) { if ( instance == null ) instance = new BaseDeDatos ( ) ; return instance ; }
va	6	@ Override public PixelArray getPixels ( int w , int h ) { PixelArray pixels = new PixelArray ( w , h ) ; int count = 0 ; for ( int y = 0 ; y < h ; y += 2 ) { for ( int x = 0 ; x < w ; x ++ ) { pixels . setPixel ( count ++ , x , y ) ; } } for ( int y = 1 ; y < h ; y += 2 ) { for ( int x = 0 ; x < w ; x += 2 ) { pixels . setPixel ( count ++ , x , y ) ; } } for ( int y = 1 ; y < h ; y += 2 ) { for ( int x = 1 ; x < w ; x += 2 ) { pixels . setPixel ( count ++ , x , y ) ; } } return pixels ; }
va	5	public static void main ( String [ ] args ) throws Exception { SMPLEnvironment environment = new SMPLEnvironment ( ) ; SMPLEvaluator visitor = new SMPLEvaluator ( ) ; System . out . println ( "SMPL Interpreter." ) ; System . out . println ( "Press Ctrl-C to exit" ) ; if ( args . length == 0 ) { while ( true ) { parseEvalShow ( System . in , visitor , environment ) ; } } else { try { parseEvalShow ( new FileInputStream ( new File ( args [ 0 ] ) ) , visitor , environment ) ; } catch ( FileNotFoundException fnfe ) { System . out . println ( "Error: File \"" + args [ 0 ] + "\" does not exist!" ) ; } while ( true ) { try { parseEvalShow ( System . in , visitor , environment ) ; } catch ( Exception e ) { System . out . println ( "SyntaxError" ) ; } } } }
va	0	public long getOffset ( ) { return offset ; }
va	9	@ Override public void rightThumb ( boolean pressed ) { if ( enabled ) { if ( ses2 != null ) { setFlagsFalse ( ) ; if ( future != null ) { future . cancel ( true ) ; } } if ( pressed == true ) { r5Flag = true ; dllProc . dll_keyPressed ( container . xgetCurrentPreset ( ) . xgetR5AssignedKeyCode ( ) ) ; if ( container . xgetCurrentPreset ( ) . isR5repetitionEnabled ( ) ) { keyTask = new KeyboardTask ( ) ; future = ses2 . scheduleAtFixedRate ( keyTask , container . xgetCurrentPreset ( ) . xgetR5InitialDelay ( ) , container . xgetCurrentPreset ( ) . xgetR5RepeatDelay ( ) , TimeUnit . MILLISECONDS ) ; } } else if ( pressed == false ) { r5Flag = false ; if ( ses2 != null ) { if ( future != null ) { future . cancel ( true ) ; } } dllProc . dll_keyRealesed ( container . xgetCurrentPreset ( ) . xgetR5AssignedKeyCode ( ) ) ; } } else { if ( future != null ) { future . cancel ( true ) ; } dllProc . dll_keyRealesed ( container . xgetCurrentPreset ( ) . xgetR5AssignedKeyCode ( ) ) ; } }
va	5	@ Override public Type getType ( ) { switch ( message . getType ( ) ) { case chat : return Type . chat ; case error : return Type . error ; case groupchat : return Type . groupchat ; case headline : return Type . normal ; case normal : return Type . normal ; default : throw new RuntimeException ( "Unknown type of message: " + message . getType ( ) ) ; } }
va	7	public static boolean advanceToChildElement ( XMLStreamReader reader , String localName ) { int depth = 0 ; try { while ( reader . hasNext ( ) ) { int code = reader . next ( ) ; if ( code == XMLStreamConstants . START_ELEMENT ) { depth ++ ; if ( depth == 1 && reader . getLocalName ( ) . equals ( localName ) ) { return true ; } } else if ( code == XMLStreamConstants . END_ELEMENT ) { if ( depth == 0 ) break ; depth -- ; } } } catch ( XMLStreamException e ) { throw new XmlPullException ( e . getMessage ( ) , e ) ; } return false ; }
va	9	public static String limit ( String sourceString , int maxLength , String more ) { String resultString = "" ; if ( sourceString == null || sourceString . equals ( "" ) || maxLength < 1 ) { return resultString ; } else if ( sourceString . length ( ) <= maxLength ) { return sourceString ; } else if ( sourceString . length ( ) > 2 * maxLength ) { } if ( sourceString . length ( ) > maxLength ) { char [ ] chr = sourceString . toCharArray ( ) ; int strNum = 0 ; int strGBKNum = 0 ; boolean isHaveDot = false ; for ( int i = 0 ; i < sourceString . length ( ) ; i ++ ) { if ( chr [ i ] >= a1 ) { strNum = strNum + 2 ; strGBKNum ++ ; } else { strNum ++ ; } if ( strNum == 2 * maxLength || strNum == 2 * maxLength + 1 ) { if ( i + 1 < sourceString . length ( ) ) { isHaveDot = true ; } break ; } } resultString = sourceString . substring ( 0 , strNum - strGBKNum ) ; if ( isHaveDot ) { resultString = resultString + more ; } } return resultString ; }
va	9	private void postPlugin ( final boolean isPing ) throws IOException { final PluginDescriptionFile description = plugin . getDescription ( ) ; final StringBuilder data = new StringBuilder ( ) ; data . append ( encode ( "guid" ) ) . append ( = ) . append ( encode ( guid ) ) ; encodeDataPair ( data , "version" , description . getVersion ( ) ) ; encodeDataPair ( data , "server" , Bukkit . getVersion ( ) ) ; encodeDataPair ( data , "players" , Integer . toString ( Bukkit . getServer ( ) . getOnlinePlayers ( ) . length ) ) ; encodeDataPair ( data , "revision" , String . valueOf ( REVISION ) ) ; if ( isPing ) { encodeDataPair ( data , "ping" , "true" ) ; } synchronized ( graphs ) { final Iterator < Graph > iter = graphs . iterator ( ) ; while ( iter . hasNext ( ) ) { final Graph graph = iter . next ( ) ; for ( Plotter plotter : graph . getPlotters ( ) ) { final String key = String . format ( "C%s%s%s%s" , CUSTOM_DATA_SEPARATOR , graph . getName ( ) , CUSTOM_DATA_SEPARATOR , plotter . getColumnName ( ) ) ; final String value = Integer . toString ( plotter . getValue ( ) ) ; encodeDataPair ( data , key , value ) ; } } } URL url = new URL ( BASE_URL + String . format ( REPORT_URL , encode ( plugin . getDescription ( ) . getName ( ) ) ) ) ; URLConnection connection ; if ( isMineshafterPresent ( ) ) { connection = url . openConnection ( Proxy . NO_PROXY ) ; } else { connection = url . openConnection ( ) ; } connection . setDoOutput ( true ) ; final OutputStreamWriter writer = new OutputStreamWriter ( connection . getOutputStream ( ) ) ; writer . write ( data . toString ( ) ) ; writer . flush ( ) ; final BufferedReader reader = new BufferedReader ( new InputStreamReader ( connection . getInputStream ( ) ) ) ; final String response = reader . readLine ( ) ; writer . close ( ) ; reader . close ( ) ; if ( response == null || response . startsWith ( "ERR" ) ) { throw new IOException ( response ) ; } else { if ( response . contains ( "OK This is your first update this hour" ) ) { synchronized ( graphs ) { final Iterator < Graph > iter = graphs . iterator ( ) ; while ( iter . hasNext ( ) ) { final Graph graph = iter . next ( ) ; for ( Plotter plotter : graph . getPlotters ( ) ) { plotter . reset ( ) ; } } } } } }
va	1	public void delete ( String filename ) { File file = new File ( filename ) ; if ( file . exists ( ) ) { file . deleteOnExit ( ) ; } }
va	3	@ Override public int hashCode ( ) { int result = nameLangKey != null ? nameLangKey . hashCode ( ) : 0 ; result = 31 * result + ( descLangKey != null ? descLangKey . hashCode ( ) : 0 ) ; result = 31 * result + sort ; result = 31 * result + ( moduleId != null ? moduleId . hashCode ( ) : 0 ) ; return result ; }
va	6	public void sortLabels ( ) { Record temp = new Record ( ) ; for ( int i = 1 ; i < 10 ; i ++ ) { for ( int j = 0 ; j < 10 - j ; j ++ ) { if ( this . recordShelf . getLabelOfSlot ( j ) == null ) { temp = this . recordShelf . getLabelOfSlot ( j ) ; this . recordShelf . setLabelOfSlot ( this . recordShelf . getLabelOfSlot ( j + 1 ) , j ) ; this . recordShelf . setLabelOfSlot ( temp , j + 1 ) ; } else if ( this . recordShelf . getLabelOfSlot ( j ) . getRecordPerformer ( ) . getName ( ) . compareTo ( this . recordShelf . getLabelOfSlot ( j + 1 ) . getRecordPerformer ( ) . getName ( ) ) > 0 ) { temp = this . recordShelf . getLabelOfSlot ( j ) ; this . recordShelf . setLabelOfSlot ( this . recordShelf . getLabelOfSlot ( j + 1 ) , j ) ; this . recordShelf . setLabelOfSlot ( temp , j + 1 ) ; } else if ( this . recordShelf . getLabelOfSlot ( j ) . getRecordPerformer ( ) . getName ( ) . compareTo ( this . recordShelf . getLabelOfSlot ( j + 1 ) . getRecordPerformer ( ) . getName ( ) ) == 0 ) { if ( this . recordShelf . getLabelOfSlot ( j ) . getEditionYear ( ) > this . recordShelf . getLabelOfSlot ( j + 1 ) . getEditionYear ( ) ) { temp = this . recordShelf . getLabelOfSlot ( j ) ; this . recordShelf . setLabelOfSlot ( this . recordShelf . getLabelOfSlot ( j + 1 ) , j ) ; this . recordShelf . setLabelOfSlot ( temp , j + 1 ) ; } } } } }
va	5	public TreeNode makeTree ( List < Integer > values ) { TreeNode root = new TreeNode ( values . get ( 0 ) , null , null ) ; Queue < TreeNode > nodes = new LinkedList < TreeNode > ( ) ; nodes . add ( root ) ; int half = values . size ( ) / 2 ; for ( int i = 0 ; i < half ; i ++ ) { if ( values . get ( i ) != null ) { TreeNode node = nodes . poll ( ) ; int left = 2 * i + 1 ; int right = 2 * i + 2 ; if ( values . get ( left ) != null ) { node . left = new TreeNode ( values . get ( left ) , null , null ) ; nodes . add ( node . left ) ; } if ( right < values . size ( ) && values . get ( right ) != null ) { node . right = new TreeNode ( values . get ( right ) , null , null ) ; nodes . add ( node . right ) ; } } } return root ; }
va	2	public Sender produce ( String type ) { if ( "mail" . equals ( type ) ) { return new MailSender ( ) ; } else if ( "sms" . equals ( type ) ) { return new SMSSender ( ) ; } else { System . out . println ( "\u8BF7\u8F93\u5165\u5408\u9002\u7684\u7C7B\u578B!!!" ) ; return null ; } }
va	3	public static int [ ] bubbleSortArray ( int [ ] arr ) { for ( int out = arr . length - 1 ; out > 0 ; out -- ) { for ( int in = 0 ; in < arr . length - 1 ; in ++ ) { if ( arr [ in ] > arr [ in + 1 ] ) { int tmp = arr [ in ] ; arr [ in ] = arr [ in + 1 ] ; arr [ in + 1 ] = tmp ; } } } return arr ; }
va	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( LoadingWindow . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( LoadingWindow . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( LoadingWindow . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( LoadingWindow . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { new LoadingWindow ( ) . setVisible ( true ) ; } } ) ; }
va	8	public Node mergeNodes ( Node node1 , Node node2 ) { Node superNode = new Node ( node1 . getId ( ) + "-" + node2 . getId ( ) ) ; addNode ( superNode ) ; List < Node > connectedNodes = new ArrayList < Node > ( ) ; for ( Node node : getAdjacentNodes ( node1 ) ) { if ( ! node . equals ( node1 ) && ! node . equals ( node2 ) ) { connectedNodes . add ( node ) ; } } for ( Node node : getAdjacentNodes ( node2 ) ) { if ( ! node . equals ( node1 ) && ! node . equals ( node2 ) ) { connectedNodes . add ( node ) ; } } Set < Edge > edgesToDelete = new HashSet < Edge > ( ) ; edgesToDelete . addAll ( edgesByNode . get ( node1 ) ) ; edgesToDelete . addAll ( edgesByNode . get ( node2 ) ) ; nodes . remove ( node1 ) ; nodes . remove ( node2 ) ; edgesByNode . remove ( node1 ) ; edgesByNode . remove ( node2 ) ; for ( Edge edge : edgesToDelete ) { removeEdge ( edge ) ; } for ( Node connectedNode : connectedNodes ) { addEdge ( superNode , connectedNode ) ; } return superNode ; }
va	4	private byte [ ] fieldToBytes ( IndexFieldDefinition fieldDef , Object value , boolean includeEndMarker ) { byte [ ] valueAsBytes ; if ( value != null ) { valueAsBytes = fieldDef . toBytes ( value ) ; } else { valueAsBytes = new byte [ 0 ] ; } byte [ ] eof = includeEndMarker ? fieldDef . getEndOfFieldMarker ( ) : EMPTY_BYTE_ARRAY ; int totalLength = FIELD_FLAGS_SIZE + valueAsBytes . length + eof . length ; byte [ ] bytes = new byte [ totalLength ] ; if ( value == null ) { bytes [ 0 ] = setNullFlag ( ( byte ) 0 ) ; } System . arraycopy ( valueAsBytes , 0 , bytes , 1 , valueAsBytes . length ) ; System . arraycopy ( eof , 0 , bytes , valueAsBytes . length + 1 , eof . length ) ; if ( fieldDef . getOrder ( ) == Order . DESCENDING ) { invertBits ( bytes , 0 , bytes . length ) ; } return bytes ; }
va	9	@ Override public int hashCode ( ) { int result = basic != null ? basic . hashCode ( ) : 0 ; result = 31 * result + retryCount ; result = 31 * result + retryIntervalMillis ; result = 31 * result + ( userId != null ? userId . hashCode ( ) : 0 ) ; result = 31 * result + ( password != null ? password . hashCode ( ) : 0 ) ; result = 31 * result + ( proxyHost != null ? proxyHost . hashCode ( ) : 0 ) ; result = 31 * result + proxyPort ; result = 31 * result + ( proxyAuthUser != null ? proxyAuthUser . hashCode ( ) : 0 ) ; result = 31 * result + ( proxyAuthPassword != null ? proxyAuthPassword . hashCode ( ) : 0 ) ; result = 31 * result + connectionTimeout ; result = 31 * result + readTimeout ; result = 31 * result + requestHeaders . hashCode ( ) ; result = 31 * result + ( oauth != null ? oauth . hashCode ( ) : 0 ) ; result = 31 * result + requestTokenURL . hashCode ( ) ; result = 31 * result + authenticationURL . hashCode ( ) ; result = 31 * result + ( accessTokenURL != null ? accessTokenURL . hashCode ( ) : 0 ) ; result = 31 * result + ( oauthToken != null ? oauthToken . hashCode ( ) : 0 ) ; return result ; }
va	3	public JSpinField ( int min , int max ) { super ( ) ; setName ( "JSpinField" ) ; this . min = min ; if ( max < min ) max = min ; this . max = max ; value = 0 ; if ( value < min ) value = min ; if ( value > max ) value = max ; darkGreen = new Color ( 0 , 150 , 0 ) ; setLayout ( new BorderLayout ( ) ) ; textField = new JTextField ( ) ; textField . addCaretListener ( this ) ; textField . addActionListener ( this ) ; textField . setHorizontalAlignment ( SwingConstants . RIGHT ) ; textField . setBorder ( BorderFactory . createEmptyBorder ( ) ) ; textField . setText ( Integer . toString ( value ) ) ; textField . addFocusListener ( this ) ; spinner = new JSpinner ( ) { private static final long serialVersionUID = - 6287709243342021172 ; private JTextField textField = new JTextField ( ) ; public Dimension getPreferredSize ( ) { Dimension size = super . getPreferredSize ( ) ; return new Dimension ( size . width , textField . getPreferredSize ( ) . height ) ; } } ; spinner . setEditor ( textField ) ; spinner . addChangeListener ( this ) ; add ( spinner , BorderLayout . CENTER ) ; }
va	8	public static float [ ] encode ( float [ ] [ ] matrix ) { float [ ] buffer = new float [ matrix . length * matrix . length ] ; boolean direction = ZigZag . ZIGZAG_FORWARD ; int x = 0 , y = 0 , index = 0 ; for ( int zigIndex = 0 ; zigIndex < ( matrix . length * 2 - 1 ) ; zigIndex ++ , direction = ! direction ) { if ( direction == ZigZag . ZIGZAG_FORWARD ) { while ( x >= 0 && y != matrix . length ) { if ( x == matrix . length ) { x -- ; y ++ ; } buffer [ index ] = matrix [ x ] [ y ] ; y ++ ; x -- ; index ++ ; } x ++ ; } else { while ( y >= 0 && x != matrix . length ) { if ( y == matrix . length ) { y -- ; x ++ ; } buffer [ index ] = matrix [ x ] [ y ] ; y -- ; x ++ ; index ++ ; } y ++ ; } } return ( buffer ) ; }
va	4	public double [ ] dual ( ) { double [ ] y = new double [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { if ( ( Math . abs ( a [ i ] [ i ] ) <= EPSILON ) && ( Math . abs ( a [ i ] [ N + N ] ) > EPSILON ) ) { for ( int j = 0 ; j < N ; j ++ ) y [ j ] = a [ i ] [ N + j ] ; return y ; } } return null ; }
va	5	public MoveCardAnimation ( String parameters ) { if ( parameters . contains ( "destinationYOffset=" ) ) { String temp = parameters . substring ( parameters . indexOf ( "destinationYOffset=" ) ) . split ( " " ) [ 0 ] ; destinationYOffset = Integer . parseInt ( temp ) ; } if ( parameters . contains ( "destinationXOffset=" ) ) { String temp = parameters . substring ( parameters . indexOf ( "destinationXOffset=" ) ) . split ( " " ) [ 0 ] ; destinationXOffset = Integer . parseInt ( temp ) ; } if ( parameters . contains ( "xStep=" ) ) { String temp = parameters . substring ( parameters . indexOf ( "xStep=" ) ) . split ( " " ) [ 0 ] ; xStep = Integer . parseInt ( temp ) ; } if ( parameters . contains ( "yStep=" ) ) { String temp = parameters . substring ( parameters . indexOf ( "yStep=" ) ) . split ( " " ) [ 0 ] ; yStep = Integer . parseInt ( temp ) ; } if ( parameters . contains ( "tStep=" ) ) { String temp = parameters . substring ( parameters . indexOf ( "tStep=" ) ) . split ( " " ) [ 0 ] ; tStep = Integer . parseInt ( temp ) ; } }
va	5	private Thread initGuardThread ( ) { return new Thread ( new Runnable ( ) { @ SuppressWarnings ( "deprecation" ) @ Override public void run ( ) { while ( threadContinue ) { try { Thread . sleep ( 1000 ) ; } catch ( InterruptedException e ) { } long curr = System . currentTimeMillis ( ) ; for ( int i = 0 ; i < threadsTaskStartTime . length ( ) ; ++ i ) { long taskTime = threadsTaskStartTime . get ( i ) ; if ( taskTime != 0 && taskTime - curr >= imageLoadTimeOut ) { threadsTaskStartTime . set ( i , 0 ) ; threads [ i ] . stop ( ) ; threads [ i ] = createNewThread ( i ) ; } } } } } ) ; }
va	4	public final ListQuery < T > foldLeft ( FoldBlock < T , T > block ) { if ( isEmpty ( ) || block == null ) { List < T > resultList = jvQuery . list ( ) ; return jvQuery ( resultList ) ; } T result = get ( 0 ) ; if ( size ( ) == 1 ) { return jvQuery ( jvQuery . list ( result ) ) ; } for ( T t : > ( 0 ) . getAll ( ) ) { result = block . call ( result , t ) ; } return jvQuery ( jvQuery . list ( result ) ) ; }
va	7	public static Type parseType ( short source ) throws UnknownTypeError { switch ( source ) { case 1 : return CHGK ; case 2 : return BRAIN ; case 4 : return SVOYAK ; case 8 : return VERSE ; case 16 : return INTERNET ; case 32 : return ERUDITE ; case 64 : return UNKNOWN ; default : throw new UnknownTypeError ( ) ; } }
va	4	public static int intersects ( Poly p , Segment s ) { boolean endPointIntersection = false ; for ( int i = 0 ; i < p . size ( ) ; i ++ ) { Segment cur = new Segment ( p . get ( i ) , p . get ( i + 1 ) ) ; int intersectCode = Geometry . intersects ( cur , s ) ; if ( intersectCode == INTERSECTS ) { return intersectCode ; } else if ( intersectCode == INTERSECTS_AT_ENDPOINT ) { endPointIntersection = true ; } } if ( endPointIntersection ) { return INTERSECTS_AT_ENDPOINT ; } return DOES_NOT_INTERSECT ; }
va	3	public void writeToXML ( TransformerHandler hd , String elementName ) { AttributesImpl atts = new AttributesImpl ( ) ; atts . addAttribute ( "" , "" , "Name" , "CDATA" , elementName ) ; atts . addAttribute ( "" , "" , "FunctionType" , "CDATA" , "IR" ) ; try { hd . startElement ( "" , "" , "HWResource" , atts ) ; } catch ( SAXException e ) { e . printStackTrace ( ) ; } for ( int i = 0 ; i < IR_FUNCTION_COUNT ; i ++ ) { rc5Commands [ i ] . writeToXML ( hd , elementName ) ; } try { hd . endElement ( "" , "" , "HWResource" ) ; } catch ( SAXException e ) { e . printStackTrace ( ) ; } }
va	5	static int [ ] getLocalIP ( ) { try { InetAddress addr = InetAddress . getLocalHost ( ) ; byte [ ] ip = addr . getAddress ( ) ; if ( ip == null || ip . length != 4 ) { return null ; } int [ ] ret = new int [ 4 ] ; for ( int cnt = 0 ; cnt < 4 ; cnt ++ ) { ret [ cnt ] = ( int ) ip [ cnt ] ; if ( ret [ cnt ] < 0 ) { ret [ cnt ] += 256 ; } } return ret ; } catch ( UnknownHostException uhe ) { return null ; } }
va	3	private void drawHeadIcon ( ) { if ( anInt855 != 2 ) return ; calcEntityScreenPos ( ( anInt934 - baseX << 7 ) + anInt937 , anInt936 * 2 , ( anInt935 - baseY << 7 ) + anInt938 ) ; if ( spriteDrawX > - 1 && loopCycle % 20 < 10 ) headIconsHint [ 0 ] . drawSprite ( spriteDrawX - 12 , spriteDrawY - 28 ) ; }
va	0	public void setSequenceNumber ( int sentSequenceNumber ) { this . sequenceNumber = sentSequenceNumber ; }
va	9	private final void interruptableRun ( ) { if ( channel == null ) { return ; } try { String host ; int port ; if ( proxyAddress != null ) { host = proxyAddress . getHostName ( ) ; port = proxyAddress . getPort ( ) ; } else { host = uri . getHost ( ) ; port = getPort ( ) ; } channel . connect ( new InetSocketAddress ( host , port ) ) ; conn . channel = wrappedchannel = createProxyChannel ( wsfactory . wrapChannel ( channel , null , host , port ) ) ; timeout = 0 ; sendHandshake ( ) ; readthread = new Thread ( new WebsocketWriteThread ( ) ) ; readthread . start ( ) ; } catch ( ClosedByInterruptException e ) { onWebsocketError ( null , e ) ; return ; } catch ( Exception e ) { onWebsocketError ( conn , e ) ; conn . closeConnection ( CloseFrame . NEVER_CONNECTED , e . getMessage ( ) ) ; return ; } ByteBuffer buff = ByteBuffer . allocate ( WebSocketImpl . RCVBUF ) ; try { while ( channel . isOpen ( ) ) { if ( SocketChannelIOHelper . read ( buff , this . conn , wrappedchannel ) ) { conn . decode ( buff ) ; } else { conn . eot ( ) ; } if ( wrappedchannel instanceof WrappedByteChannel ) { WrappedByteChannel w = ( WrappedByteChannel ) wrappedchannel ; if ( w . isNeedRead ( ) ) { while ( SocketChannelIOHelper . readMore ( buff , conn , w ) ) { conn . decode ( buff ) ; } conn . decode ( buff ) ; } } } } catch ( CancelledKeyException e ) { conn . eot ( ) ; } catch ( IOException e ) { conn . eot ( ) ; } catch ( RuntimeException e ) { onError ( e ) ; conn . closeConnection ( CloseFrame . ABNORMAL_CLOSE , e . getMessage ( ) ) ; } }
va	4	public static void main ( String [ ] args ) { PrintWriter fw = null ; Scanner scanner = null ; File file = new File ( "data.txt" ) ; String [ ] data = { "\uAE40\uD0DC\uD76C;99;98;97" , "\uC774\uBBFC\uC815;81;82;83" , "\uC218\uC9C0;77;78;79" } ; try { fw = new PrintWriter ( new BufferedWriter ( new FileWriter ( file ) ) ) ; for ( String str : data ) { fw . printf ( str + "\n" ) ; } fw . close ( ) ; scanner = new Scanner ( file ) ; while ( scanner . hasNextLine ( ) ) { String line = scanner . nextLine ( ) ; System . out . println ( line ) ; } } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } finally { scanner . close ( ) ; } }
va	2	public void stairsUp ( ) { Point stairLoc = new Point ( player . getLocation ( ) . getColumn ( ) , player . getLocation ( ) . getRow ( ) ) ; Tile currentTile = map . getTile ( stairLoc . x , stairLoc . y ) ; if ( currentTile instanceof StairTile && ( ( StairTile ) currentTile ) . getUp ( ) ) { StairTile stairs = ( StairTile ) currentTile ; switchMap ( stairs ) ; } else { messenger . println ( "There are no stairs to go up here." ) ; } }
va	4	public void update ( GameContainer container , StateBasedGame game , int delta ) { terrain . update ( ) ; backgroundparticles . update ( delta ) ; for ( int i = Main . UPDATES ; i -- > 0 ; ) world . update ( 1 / 60f ) ; for ( GameEntity entity : entities ) { entity . update ( container , game , delta ) ; } if ( viewportgoal . getX ( ) != viewport . getX ( ) || viewportgoal . getY ( ) != viewport . getY ( ) ) { viewport . setLocation ( viewport . getX ( ) - ( viewport . getX ( ) - viewportgoal . getX ( ) ) * 0.5f , viewport . getY ( ) - ( viewport . getY ( ) - viewportgoal . getY ( ) ) * 0.5f ) ; } }
va	7	public ListNode partition ( ListNode head , int x ) { if ( head == null || head . next == null ) return head ; ListNode frontHead = null ; ListNode frontTail = null ; ListNode backHead = null ; ListNode backTail = null ; ListNode cur = head ; while ( cur != null ) { ListNode next = cur . next ; cur . next = null ; if ( cur . val < x ) { if ( frontHead == null ) { frontHead = cur ; frontTail = cur ; } else { frontTail . next = cur ; frontTail = frontTail . next ; } } else { if ( backHead == null ) { backHead = cur ; backTail = cur ; } else { backTail . next = cur ; backTail = backTail . next ; } } cur = next ; } if ( frontHead == null ) return backHead ; frontTail . next = backHead ; return frontHead ; }
va	4	public static Scorecard readRoundFromFile ( File filename ) { JSONObject json = new JSONObject ( ) ; try { LOGGER . log ( Level . INFO , "Reading round JSON from file '" + filename + "'" ) ; json = ( JSONObject ) new JSONParser ( ) . parse ( new FileReader ( filename ) ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } catch ( ParseException e ) { e . printStackTrace ( ) ; } Set < String > players = json . keySet ( ) ; players . remove ( "pars" ) ; players . remove ( "course" ) ; HashMap < String , ArrayList < Integer >> scores = new HashMap < String , ArrayList < Integer >> ( ) ; for ( String player : players ) { LOGGER . log ( Level . INFO , "Reading scores for player '" + player + "'" ) ; scores . put ( player , ( ArrayList < Integer > ) json . get ( player ) ) ; } LOGGER . log ( Level . INFO , "Finished reading disc JSON '" + filename + "'" ) ; return new Scorecard ( ( String ) json . get ( "course" ) , scores , ( ArrayList < Integer > ) json . get ( "pars" ) ) ; }
va	4	public void removeRange ( int start , int end ) { if ( end >= size ) { throw new IndexOutOfBoundsException ( "end can't be >= size: " + end + " >= " + size ) ; } if ( start > end ) { throw new IndexOutOfBoundsException ( "start can't be > end: " + start + " > " + end ) ; } T [ ] items = this . items ; int count = end - start + 1 ; if ( ordered ) { System . arraycopy ( items , start + count , items , start , size - ( start + count ) ) ; } else { int lastIndex = this . size - 1 ; for ( int i = 0 ; i < count ; i ++ ) { items [ start + i ] = items [ lastIndex - i ] ; } } size -= count ; }
va	6	@ Test public void callError ( ) { final String kHomePath = "/remote_method/error" ; final String kMethod = "/error" ; final String kUserAccount = "error_user" ; Directory directory = Directory . Instance ; assert . assertTrue ( directory . createPath ( kHomePath + kMethod ) ) ; try { assert . assertTrue ( directory . addHandler ( kHomePath + kMethod , new MethodHandler ( kMethod , false , null , getClass ( ) . getDeclaredMethod ( "error" , String . class , TestBean . class ) ) ) ) ; } catch ( NoSuchMethodException e ) { assert . fail ( e . toString ( ) ) ; } Uri uri = new Uri ( "ws" , kHostname , "/remote_method_test" ) ; WampConnectionTest . TestSender client_sender = new WampConnectionTest . TestSender ( ) ; WampConnectionTest . TestSender server_sender = new WampConnectionTest . TestSender ( ) ; WampConnection client = new WampConnection ( uri , kUserAccount , "" , client_sender ) ; WampConnection server = new WampConnection ( uri , kUserAccount , kHomePath , server_sender ) ; server . welcome ( "test-session-" + kUserAccount ) ; client . process ( server_sender . getOutput ( ) ) ; RemoteMethod < TestBean > remote_method = new RemoteMethod < TestBean > ( client , kMethod , TestBean . class ) ; CallProcessor processor = new CallProcessor ( client , client_sender , server , server_sender ) ; TestBean bean = new TestBean ( 1010 , 0.1 , "details" ) ; CallThread call_thread = new CallThread ( remote_method , true , "remote method test" , bean ) ; processor . start ( ) ; call_thread . start ( ) ; synchronized ( call_thread ) { while ( call_thread . isAlive ( ) ) { try { call_thread . wait ( ) ; } catch ( InterruptedException e ) { } } } synchronized ( processor ) { while ( processor . isAlive ( ) ) { try { processor . wait ( ) ; } catch ( InterruptedException e ) { } } } RemoteMethodCall < TestBean > method_call = call_thread . getMethodCall ( ) ; assert . assertNotNull ( method_call ) ; assertThat ( method_call . getState ( ) , is ( RemoteMethodCall . State . Completed ) ) ; assert . assertFalse ( method_call . isSuccessful ( ) ) ; assertThat ( method_call . getErrorUri ( ) . toString ( ) , is ( "wamp://error_user@general.ai" + kMethod + "#logic_error" ) ) ; assertThat ( method_call . getErrorDescription ( ) , is ( "remote method test" ) ) ; ObjectMapper mapper = new ObjectMapper ( ) ; assertThat ( mapper . convertValue ( method_call . getErrorDetails ( ) , TestBean . class ) , is ( bean ) ) ; if ( call_thread . getThreadCompletionTimeMillis ( ) < processor . getThreadCompletionTimeMillis ( ) ) { assert . fail ( "Call thread completion time: " + call_thread . getThreadCompletionTimeMillis ( ) + "  Processor thread completion time: " + processor . getThreadCompletionTimeMillis ( ) ) ; } client . close ( ) ; server . close ( ) ; }
va	9	public static boolean runPreparedStatement ( String sql , CommandArgument [ ] args , boolean isSelect ) { boolean result = false ; try { PreparedStatement stat = connection . prepareStatement ( sql ) ; int i = 1 ; for ( CommandArgument arg : args ) { stat = setPreparedStatementArgument ( stat , arg , i ) ; i ++ ; } if ( ! isSelect ) { stat . executeUpdate ( ) ; result = true ; } else { ResultSet re = stat . executeQuery ( ) ; ResultSetMetaData meta = re . getMetaData ( ) ; int cols = meta . getColumnCount ( ) ; System . out . print ( "ROW NUMBER\t" ) ; for ( i = 1 ; i <= cols ; i ++ ) { System . out . print ( meta . getColumnName ( i ) ) ; int length = meta . getColumnName ( i ) . length ( ) ; while ( length % 16 != 0 ) { System . out . print ( " " ) ; length ++ ; } if ( meta . getColumnTypeName ( i ) . equals ( "DATE" ) ) System . out . print ( "        " ) ; } int cnt = 1 ; while ( re . next ( ) ) { System . out . print ( "\n" + cnt + "\t\t" ) ; for ( i = 1 ; i <= cols ; i ++ ) { String type = meta . getColumnTypeName ( i ) ; if ( type . equals ( "NUMBER" ) || ( meta . getColumnTypeName ( i ) . equals ( "VARCHAR2" ) && re . getString ( i ) . length ( ) < 8 ) ) System . out . print ( re . getString ( i ) + "\t\t" ) ; else System . out . print ( re . getString ( i ) + "\t" ) ; } cnt ++ ; } System . out . println ( ) ; result = true ; } stat . close ( ) ; return result ; } catch ( SQLException e ) { e . printStackTrace ( ) ; return false ; } }
va	5	public int paint ( Graphics g , int begin , int end ) { int idx = 0 ; int x = 0 ; int width ; int height = g . getFontMetrics ( ) . getHeight ( ) ; for ( PaintableText string : strings ) { int len = string . getText ( ) . length ( ) ; if ( idx + len < begin ) { idx += len ; continue ; } int first = 0 ; int last = len ; if ( idx < begin ) first = begin - idx ; if ( idx + len > end ) last = end - idx ; width = g . getFontMetrics ( ) . stringWidth ( string . getText ( ) . substring ( first , last ) ) ; x += string . paint ( g . create ( x , 0 , width , height ) , first , last ) ; idx += len ; if ( idx >= end ) break ; } return x ; }
va	5	public static void sanityCheckTag ( byte [ ] bytes ) throws NoSuchTagException , UnsupportedTagException { if ( bytes . length < AbstractID3v2Tag . HEADER_LENGTH ) { throw new NoSuchTagException ( "Buffer too short" ) ; } if ( ! AbstractID3v2Tag . TAG . equals ( BufferTools . byteBufferToStringIgnoringEncodingIssues ( bytes , 0 , AbstractID3v2Tag . TAG . length ( ) ) ) ) { throw new NoSuchTagException ( ) ; } int majorVersion = bytes [ AbstractID3v2Tag . MAJOR_VERSION_OFFSET ] ; if ( majorVersion != 2 && majorVersion != 3 && majorVersion != 4 ) { int minorVersion = bytes [ AbstractID3v2Tag . MINOR_VERSION_OFFSET ] ; throw new UnsupportedTagException ( "Unsupported version 2." + majorVersion + "." + minorVersion ) ; } }
va	8	public static void main ( String [ ] args ) { BufferedReader in ; try { in = new BufferedReader ( new FileReader ( "C:\\Users\\Abhishek\\Desktop\\input.txt" ) ) ; String line ; while ( ( line = in . readLine ( ) ) != null ) { String [ ] section = line . split ( ":" ) ; int W = Integer . valueOf ( section [ 0 ] . trim ( ) ) ; String [ ] data = section [ 1 ] . trim ( ) . split ( " " ) ; int N = data . length ; double [ ] v = new double [ N ] ; double [ ] w = new double [ N ] ; for ( int i = 0 ; i < data . length ; i ++ ) { String [ ] val = data [ i ] . subSequence ( 1 , data [ i ] . length ( ) - 1 ) . toString ( ) . split ( " " ) ; v [ i ] = double . valueOf ( val [ 2 ] . substring ( 1 , val [ 2 ] . length ( ) ) ) ; w [ i ] = double . valueOf ( val [ 1 ] ) ; } double [ ] [ ] sack = new double [ N + 1 ] [ W + 1 ] ; for ( int i = 0 ; i < N + 1 ; i ++ ) { for ( int j = 0 ; j < N + 1 ; j ++ ) { if ( i == 0 || j == 0 ) { sack [ i ] [ j ] = 0 ; } else { if ( j > w [ i ] ) sack [ i ] [ j ] = Math . max ( sack [ i - 1 ] [ j ] , sack [ i - 1 ] [ j - j ] + w [ i ] ) ; else sack [ i ] [ j ] = sack [ i - 1 ] [ j ] ; } } } } } catch ( Exception e ) { System . out . println ( e . getMessage ( ) ) ; } }
va	8	private JPanel toolbar ( ) { JPanel panel = new JPanel ( new FlowLayout ( FlowLayout . LEADING , 0 , 0 ) ) ; alt = new JRadioButton ( "Alt" ) ; alt . setMnemonic ( KeyEvent . VK_A ) ; ctlrShiftU = new JRadioButton ( "Ctrl-Shift-U" ) ; ctlrShiftU . setMnemonic ( KeyEvent . VK_C ) ; ButtonGroup group = new ButtonGroup ( ) ; group . add ( alt ) ; group . add ( ctlrShiftU ) ; switch ( unicodeTypingPrefix ) { case alt : alt . setSelected ( true ) ; break ; case ctlrShiftU : ctlrShiftU . setSelected ( true ) ; break ; default : throw new IllegalArgumentException ( String . valueOf ( unicodeTypingPrefix ) ) ; } delay = new JSpinner ( new SpinnerNumberModel ( typingDelay , 0 , MAX_TYPING_DELAY , 1 ) ) ; delay . setEnabled ( false ) ; help = new JButton ( "?" ) ; Font font = help . getFont ( ) ; Map < TextAttribute , Integer > fontAttributes = Collections . singletonMap ( TextAttribute . UNDERLINE , TextAttribute . UNDERLINE_ON ) ; help . setFont ( font . deriveFont ( fontAttributes ) ) ; help . setMnemonic ( KeyEvent . VK_SLASH ) ; File helpFile ; try { helpFile = resourceDiscoverer . getHelpFile ( ) ; } catch ( IOException e1 ) { helpFile = null ; } if ( helpFile != null && ! helpFile . exists ( ) ) { resourceDiscoverer . extractHelp ( ) ; } if ( helpFile != null && helpFile . exists ( ) ) { help . setEnabled ( true ) ; final URI helpFileUri = helpFile . toURI ( ) ; help . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { try { Desktop . getDesktop ( ) . browse ( helpFileUri ) ; } catch ( IOException e1 ) { UIUtil . showErrorMessage ( "Help file is unavailable" ) ; } } } ) ; } else { help . setEnabled ( false ) ; } JComponent field = ( ( JSpinner . DefaultEditor ) delay . getEditor ( ) ) ; Dimension prefSize = field . getPreferredSize ( ) ; int width = field . getFontMetrics ( field . getFont ( ) ) . stringWidth ( "" + MAX_TYPING_DELAY ) ; field . setPreferredSize ( new Dimension ( width , prefSize . height ) ) ; panel . add ( delay ) ; panel . add ( alt ) ; panel . add ( ctlrShiftU ) ; panel . add ( help ) ; alt . requestFocus ( ) ; return panel ; }
va	2	@ Override public Hashtable < String , Document > loadDocuments ( ) throws Exception { File dir = new File ( this . datasetPath ) ; String [ ] categories = dir . list ( ) ; for ( int i = 0 ; i < categories . length ; i ++ ) { String categoryName = categories [ i ] ; this . originalClasses . add ( categoryName ) ; String [ ] docsInCategory = new File ( this . datasetPath + "/" + categoryName ) . list ( ) ; this . classDocumentCount . put ( categoryName , docsInCategory . length ) ; for ( int j = 0 ; j < docsInCategory . length ; j ++ ) { this . numberOfDocument ++ ; String documentName = docsInCategory [ j ] ; File input = new File ( this . datasetPath + "/" + categoryName + "/" + documentName ) ; org . jsoup . nodes . Document doc = Jsoup . parse ( input , "UTF-8" , "" ) ; String title = categoryName + " " + doc . title ( ) . replaceAll ( "(\\r|\\n)" , ". " ) ; String body = getFirstNWords ( doc . text ( ) . replaceAll ( "(\\r|\\n)" , ". " ) . replaceAll ( "\\s+" , " " ) ) ; Document stemmedDocument = DocumentManager . createDocument ( categoryName + "_" + documentName , title , body ) ; stemmedDocument . setOrginalCluster ( categoryName ) ; this . documentHash . put ( stemmedDocument . getId ( ) , stemmedDocument ) ; this . documentsIDS . add ( stemmedDocument . getId ( ) ) ; } } return this . documentHash ; }
va	5	public void write ( Kml kml ) throws KmlException { kml . println ( "<BalloonStyle" + getIdAndTargetIdFormatted ( kml ) + ">" , 1 ) ; if ( bgColor != null ) { kml . println ( "<bgColor>" + bgColor + "</bgColor>" ) ; } if ( textColor != null ) { kml . println ( "<textColor>" + textColor + "</textColor>" ) ; } if ( text != null ) { kml . println ( "<text>" + text + "</text>" ) ; } if ( displayMode != null ) { kml . println ( "<displayMode>" + ( displayMode == DisplayModeEnum . _default ? "default" : displayMode ) + "</displayMode>" ) ; } kml . println ( - 1 , "</BalloonStyle>" ) ; }
va	9	public void run ( ) { stopped = false ; int chunk = 0 ; while ( ! stopped ) { if ( tableMode && startedBackgroundCaching && ! Renderer . isDragging ( ) && tableIndex != table . length ) for ( chunk = 0 ; chunk < 500 ; chunk ++ ) { if ( tableIndex < table . length && table [ tableIndex ] == 0 ) Renderer . renderVertex ( tableIndex , this ) ; tableIndex ++ ; if ( tableIndex >= table . length || stopped ) return ; } try { Thread . sleep ( 30 ) ; } catch ( InterruptedException e ) { } } }
va	2	public FeatureVector createGlobalFeatures ( DependencyInstance inst , boolean [ ] isPruned , int p ) { FeatureVector fv = new FeatureVector ( smnAlphabet . size ( ) ) ; long code = 0 ; SemanticFrame frame = inst . frames [ p ] ; int pid = frame . predid ; Utils . assert ( inst . voice [ pid ] < 2 && inst . voice [ pid ] >= 0 ) ; long argseq = createArgSequenceCode ( frame . arglbids , isPruned , p , pid ) ; code = createLinkCodeARGSEQP ( VOICE_ARGSEQ , argseq , inst . voice [ pid ] ) ; addLinkFeature ( code , fv ) ; int word = inst . formids [ pid ] ; if ( inst . lemmaids != null ) word = inst . lemmaids [ pid ] ; code = createLinkCodeARGSEQWP ( VOICE_LEMMA_ARGSEQ , argseq , word , inst . voice [ pid ] ) ; addLinkFeature ( code , fv ) ; argseq = createArgPosSequenceCode ( frame . arglbids , inst . postagids , isPruned , p , pid ) ; code = createLinkCodeARGSEQP ( VOICE_POSARGSEQ , argseq , inst . voice [ pid ] ) ; addLinkFeature ( code , fv ) ; code = createLinkCodeARGSEQWP ( VOICE_LEMMA_POSARGSEQ , argseq , word , inst . voice [ pid ] ) ; addLinkFeature ( code , fv ) ; argseq = createArgPredSequenceCode ( frame . arglbids , inst . predIndex , inst . voice , isPruned , p , pid ) ; code = createLinkCodeARGSEQP ( VOICE_POSARGPREDSEQ , argseq , inst . voice [ pid ] ) ; addLinkFeature ( code , fv ) ; return fv ; }
va	0	public ButtCity ( int row , int col ) { super ( IMAGE_PATH , row , col ) ; }
va	2	public void readFile ( ) { try ( BufferedReader br = new BufferedReader ( new FileReader ( "data/test.txt" ) ) ) { String sCurrentLine ; while ( ( sCurrentLine = br . readLine ( ) ) != null ) { System . out . println ( sCurrentLine ) ; } } catch ( IOException ee ) { ee . printStackTrace ( ) ; } }
va	2	private void bankItems ( ) { if ( Bank . isOpen ( ) ) { while ( Inventory . isFull ( ) ) { Bank . depositInventory ( ) ; Time . sleep ( 3000 ) ; } } else { Bank . open ( ) ; } }
va	8	public String perform ( HttpServletRequest request ) { List < String > errors = new ArrayList < String > ( ) ; request . setAttribute ( "errors" , errors ) ; try { RequestCheckForm form = formBeanFactory . create ( request ) ; request . setAttribute ( "form" , form ) ; Transaction . begin ( ) ; HttpSession session = request . getSession ( ) ; CustomerBean cb = ( CustomerBean ) session . getAttribute ( "customer" ) ; int id = cb . getCustomer_id ( ) ; CustomerBean c = customerDAO . getCustomerInfo ( id ) ; session . setAttribute ( "customer" , c ) ; if ( ! form . isPresent ( ) ) { Transaction . commit ( ) ; return "c_requestCheck.jsp" ; } errors . addAll ( form . getValidationErrors ( ) ) ; if ( errors . size ( ) != 0 ) { Transaction . commit ( ) ; return "c_requestCheck.jsp" ; } long inpuntAmount = dataConversion . convertFromStringToTwoDigitLong ( form . getCheckAmt ( ) ) ; long tmpCash = c . getTempcash ( ) ; System . out . println ( tmpCash ) ; System . out . println ( inpuntAmount ) ; if ( inpuntAmount > tmpCash ) { errors . add ( "Amount should not be greater than current cash" ) ; Transaction . commit ( ) ; return "c_requestCheck.jsp" ; } TransactionBean tb = new TransactionBean ( ) ; c . setTempcash ( tmpCash - inpuntAmount ) ; System . out . println ( c . getTempcash ( ) ) ; tb . setTransaction_type ( "request" ) ; tb . setAmount ( inpuntAmount ) ; tb . setCustomer_id ( c . getCustomer_id ( ) ) ; transactionDAO . createNewTransaction ( tb ) ; customerDAO . update ( c ) ; request . setAttribute ( "message" , "the transaction is in process" ) ; session . setAttribute ( "customer" , c ) ; Transaction . commit ( ) ; return "c_success.jsp" ; } catch ( RollbackException e ) { errors . add ( e . getMessage ( ) ) ; return "c_requestCheck.jsp" ; } catch ( FormBeanException e ) { errors . add ( e . getMessage ( ) ) ; return "c_requestCheck.jsp" ; } catch ( NumberFormatException e ) { errors . add ( "Input Amount is too large" ) ; return "c_requestCheck.jsp" ; } catch ( Exception e ) { errors . add ( e . getMessage ( ) ) ; return "c_requestCheck.jsp" ; } finally { if ( Transaction . isActive ( ) ) Transaction . rollback ( ) ; } }
va	3	private void readMethods ( ) { this . methods = new HashMap < String , Method > ( ) ; for ( Method method : beanClass . getMethods ( ) ) { String methodName = method . getName ( ) . toLowerCase ( ) ; if ( processMethod ( method , methodName , "get" ) || processMethod ( method , methodName , "is" ) ) ; } }
va	2	public void setBlock ( Item item ) { if ( ! locked ) { if ( item . isPlacable ( ) ) { layer [ 0 ] = Block . getBlock ( item . id ) ; subID = item . subID ; } else { const . debug ( "(Tile): tried to place non placable item" ) ; } } else { const . debug ( "(Tile:setBlock): couldn't change block because tile is locked" ) ; } }
va	7	public static VideoThumbnail [ ] generateThumbnails ( int idealNumber , File source , File workingDir , int w , int h ) { FfmpegFileInfo info = getFileInfo ( source , workingDir ) ; if ( info == null ) { return null ; } double duration = info . getDuration ( ) ; int width = info . getW ( ) ; int height = info . getH ( ) ; int calculatedWidth = width ; int calculatedHeight = height ; if ( calculatedWidth > w ) { calculatedWidth = w ; calculatedHeight = ( int ) Math . floor ( ( double ) calculatedHeight / ( ( double ) calculatedWidth / ( double ) w ) ) ; } if ( calculatedHeight > h ) { calculatedHeight = h ; calculatedWidth = ( int ) Math . floor ( ( double ) calculatedWidth / ( ( double ) calculatedHeight / ( double ) h ) ) ; } int interval = Math . max ( 1 , ( int ) Math . ceil ( duration / idealNumber ) ) ; int numThumbnails = ( int ) Math . floor ( duration / interval ) + 1 ; Config config = Config . getInstance ( ) ; int exitVal = RuntimeHelper . executeProgram ( new String [ ] { config . getString ( "ffmpeg.location" ) , "-y" , "-nostdin" , "-i" , source . getAbsolutePath ( ) , "-vf" , "fps=1/" + interval + " scale=" + calculatedWidth + ":" + calculatedHeight , workingDir . getAbsolutePath ( ) + System . getProperty ( "file.separator" ) + "thumb_%d.jpg" } , workingDir , null , null ) ; if ( exitVal != 0 ) { logger . warn ( "Error generating video thumbnails for '" + source . getAbsolutePath ( ) + "' with ffmpeg." ) ; return null ; } VideoThumbnail [ ] videoThumbnails = new VideoThumbnail [ numThumbnails ] ; for ( int i = 0 ; i < videoThumbnails . length ; i ++ ) { File file = new File ( workingDir . getAbsolutePath ( ) + System . getProperty ( "file.separator" ) + "thumb_" + ( i + 1 ) + ".jpg" ) ; if ( ! file . exists ( ) ) { logger . warn ( "A video thumbnail that should of been generated does not exist." ) ; return null ; } int time = interval * i ; if ( i > 0 ) { time = ( int ) Math . round ( time - ( ( double ) interval / 2 ) ) ; } videoThumbnails [ i ] = new VideoThumbnail ( time , file ) ; } return videoThumbnails ; }
va	4	public void update ( final Observable obj , final Object arg ) { final String line = ( String ) arg ; if ( line . length ( ) < 130 ) { return ; } final int startOfTag = line . indexOf (   ) - 2 ; final String strMessageType = line . substring ( 128 + startOfTag , 130 + startOfTag ) ; if ( ! strMessageType . equals ( "00" ) ) { return ; } final String strSource = "0x" + line . substring ( 38 + startOfTag , 41 + startOfTag ) . replace ( "0" , "" ) + "00" ; final VizNode thisNode = displayNode ( strSource ) ; for ( VizLink vizLink : thisNode . getLinks ( ) ) { thisNode . ucastEvent ( ) ; if ( vizLink . getTarget ( ) . getId ( ) == thisNode . getId ( ) ) { thisNode . sendPacket ( vizLink , Color . ORANGE . getRGB ( ) , 4 , thisNode , vizLink . getTarget ( ) ) ; } else { thisNode . sendPacket ( vizLink , Color . ORANGE . getRGB ( ) , 4 , thisNode , vizLink . getSource ( ) ) ; } } }
va	4	private String [ ] nonEmpty ( String [ ] strings ) { int numNonEmpty = 0 ; for ( int i = 0 ; i < strings . length ; i ++ ) { if ( strings [ i ] . trim ( ) . length ( ) != 0 ) { numNonEmpty ++ ; } } String [ ] nonEmpties = new String [ numNonEmpty ] ; int pos = 0 ; for ( int i = 0 ; i < strings . length ; i ++ ) { if ( strings [ i ] . trim ( ) . length ( ) != 0 ) { nonEmpties [ pos ] = strings [ i ] ; pos ++ ; } } return nonEmpties ; }
va	5	public void playTurn ( PokerPlayerDecision decision ) { PokerPlayer playerTurn = this . getPlayer ( ) ; if ( playerTurn != null ) { if ( decision == PokerPlayerDecision . Leave ) { playerTurn . leave ( ) ; } if ( decision == PokerPlayerDecision . Call ) { if ( this . getHighestBet ( ) != playerTurn . getBet ( ) ) { long amount = this . getHighestBet ( ) - playerTurn . getBet ( ) ; playerTurn . call ( amount ) ; this . pot += amount ; } } if ( decision == PokerPlayerDecision . AllIn ) { this . pot += playerTurn . getBalance ( ) ; this . highestBet = playerTurn . getBalance ( ) ; playerTurn . allIn ( ) ; } this . nextTurn ( decision ) ; } }
va	6	protected void onTick ( ) { DFAgentDescription template = new DFAgentDescription ( ) ; ServiceDescription sd = new ServiceDescription ( ) ; sd . setType ( "fetch" ) ; template . addServices ( sd ) ; System . out . println ( "------------------------------------" ) ; try { DFAgentDescription [ ] result = DFService . search ( myAgent , template ) ; System . out . println ( myAgent . getLocalName ( ) + ": [searching agents]." ) ; System . out . println ( "Found the following active agents:" ) ; activeAgent = new AID [ result . length ] ; if ( result . length == 0 ) { System . out . println ( "  > No free agents." ) ; System . out . println ( "------------------------------------\n" ) ; } else { for ( int i = 0 ; i < result . length ; ++ i ) { activeAgent [ i ] = result [ i ] . getName ( ) ; System . out . println ( "  > " + activeAgent [ i ] . getName ( ) ) ; } System . out . println ( "------------------------------------\n" ) ; ACLMessage query = new ACLMessage ( ACLMessage . INFORM ) ; for ( int i = 0 ; i < result . length ; ++ i ) { query . addReceiver ( result [ i ] . getName ( ) ) ; ServiceDescription temp_serv ; @ SuppressWarnings ( "rawtypes" ) Iterator s = result [ i ] . getAllServices ( ) ; while ( s . hasNext ( ) ) { temp_serv = ( ServiceDescription ) s . next ( ) ; System . out . println ( temp_serv . getName ( ) ) ; @ SuppressWarnings ( "rawtypes" ) Iterator p = temp_serv . getAllProperties ( ) ; while ( p . hasNext ( ) ) { Property temp_p = ( Property ) p . next ( ) ; String [ ] agent_pos = ( ( String ) temp_p . getValue ( ) ) . split ( " " ) ; String x = agent_pos [ 0 ] ; String y = agent_pos [ 1 ] ; System . out . print ( temp_p . getName ( ) + ": " ) ; System . out . println ( x + "  " + y ) ; } } } query . setOntology ( "fetch" ) ; query . setContent ( this . target . parsePose ( ) ) ; myAgent . send ( query ) ; } } catch ( FIPAException fe ) { System . err . println ( myAgent . getLocalName ( ) + ": Error sending the message." ) ; } }
va	4	private void convertPassword ( Properties p ) { String pw = p . getProperty ( KEYSTOREPWD ) ; if ( pw != null && ! pw . startsWith ( xorTag ) ) { String epw = obfuscate ( pw . toCharArray ( ) ) ; p . put ( KEYSTOREPWD , epw ) ; } pw = p . getProperty ( TRUSTSTOREPWD ) ; if ( pw != null && ! pw . startsWith ( xorTag ) ) { String epw = obfuscate ( pw . toCharArray ( ) ) ; p . put ( TRUSTSTOREPWD , epw ) ; } }
va	0	public VentaDAOJDBC ( Connection connection ) { logger = Logger . getLogger ( VentaDAOJDBC . class ) ; logger . info ( "-->> init with connection:" + connection ) ; conn = connection ; }
va	4	private boolean canWriteWithDefaultOriginalClassConstructor ( ) { final IType itype = getReferenceToSelectedIType ( ) ; final IMethod constructor = itype . getMethod ( getOriginalClassSimpleName ( ) , null ) ; boolean shouldAskConfirmation = ! constructor . exists ( ) ; if ( ! shouldAskConfirmation ) { try { final int flags = constructor . getFlags ( ) ; if ( Flags . isPrivate ( flags ) ) { shouldAskConfirmation = true ; } } catch ( JavaModelException ex ) { throw new IllegalStateException ( "Failed to access constructor data in the original class." , ex ) ; } } if ( shouldAskConfirmation ) { return MessageDialog . openConfirm ( getContainer ( ) , I18n . DIALOG_CONFIRM_CONSTRUCTOR_TITLE . getText ( ) , I18n . DIALOG_CONFIRM_CONSTRUCTOR_MESSAGE . getText ( ) ) ; } return true ; }
va	9	public void invert ( int invDir ) { int lown = - 1 ; int highn = - 1 ; for ( int i = 0 ; i < highnote - lownote + 1 ; i ++ ) { if ( keyon [ i ] == true ) { lown = i ; break ; } } if ( lown >= 0 ) { for ( int i = highnote - lownote ; i > lown ; i -- ) { if ( keyon [ i ] == true ) { highn = i ; break ; } } } if ( highn >= 0 ) { if ( invDir > 0 ) { stopNote ( lownote + lown ) ; while ( lown <= highn ) lown += 12 ; playNote ( lownote + lown ) ; } else { stopNote ( lownote + highn ) ; while ( highn >= lown ) highn -= 12 ; playNote ( lownote + highn ) ; } } }
va	8	public static int countNeighbours ( boolean [ ] [ ] world , int col , int row ) { int c = 0 ; if ( getCell ( world , col - 1 , row - 1 ) == true ) { c += 1 ; } if ( getCell ( world , col , row - 1 ) == true ) { c += 1 ; } if ( getCell ( world , col + 1 , row - 1 ) == true ) { c += 1 ; } if ( getCell ( world , col - 1 , row ) == true ) { c += 1 ; } if ( getCell ( world , col + 1 , row ) == true ) { c += 1 ; } if ( getCell ( world , col - 1 , row + 1 ) == true ) { c += 1 ; } if ( getCell ( world , col , row + 1 ) == true ) { c += 1 ; } if ( getCell ( world , col + 1 , row + 1 ) == true ) { c += 1 ; } return c ; }
va	4	private static void swap ( int [ ] array , int offset1 , int offset2 ) { if ( offset1 < 0 || offset1 >= array . length || offset2 < 0 || offset2 >= array . length ) { System . err . println ( "out of range; " + array . length + "; " + offset1 + "; " + offset2 ) ; return ; } final int tmp = array [ offset1 ] ; array [ offset1 ] = array [ offset2 ] ; array [ offset2 ] = tmp ; }
va	5	public void stop ( ) { stopped = true ; inboundFlag . set ( ) ; outboundFlag . set ( ) ; try { if ( socket != null ) socket . close ( ) ; } catch ( IOException e1 ) { e1 . printStackTrace ( ) ; } try { if ( inboundThread != null ) inboundThread . join ( ) ; if ( outboundThread != null ) outboundThread . join ( ) ; } catch ( InterruptedException e1 ) { e1 . printStackTrace ( ) ; } }
va	3	@ Test public void switchBoardTest ( ) throws Exception { Server server = Helper . serverSetup ( 4444 ) ; Client client = new Client ( "localhost" , 4444 ) ; client . startGUI ( ) ; client . getClientGUI ( ) . setupCanvas ( ) ; client . getCanvas ( ) . makeDrawingBuffer ( ) ; client . newBoard ( "board1" ) ; client . getCanvas ( ) . switchBoard ( "board1" ) ; assertTrue ( client . getCurrentBoardName ( ) . equals ( "board1" ) ) ; BufferedImage madeImage = new BufferedImage ( 794 , 527 , BufferedImage . TYPE_INT_RGB ) ; final Graphics2D g = ( Graphics2D ) madeImage . getGraphics ( ) ; g . setColor ( Color . WHITE ) ; g . fillRect ( 0 , 0 , 800 , 600 ) ; boolean same = true ; for ( int x = 0 ; x < madeImage . getWidth ( ) ; x ++ ) { for ( int y = 0 ; y < madeImage . getHeight ( ) ; y ++ ) { if ( madeImage . getRGB ( x , y ) != client . getDrawingBuffer ( ) . getRGB ( x , y ) ) same = false ; } } client . kill ( ) ; assertTrue ( same ) ; server . shutDown ( ) ; Thread . sleep ( 100 ) ; }
va	3	public Set < String > getNounsRule1 ( String source , String originalSentence , Map < String , boolean > descriptorMap ) { Set < String > nouns = new HashSet < String > ( ) ; if ( ( ! ( source . matches ( "^.*\\.xml_\\S+_.*$" ) ) ) && ( ! ( originalSentence . matches ( "^.*\\s.*$" ) ) ) ) { if ( ! this . isDescriptor ( originalSentence , descriptorMap ) ) { originalSentence = originalSentence . toLowerCase ( ) ; nouns . add ( originalSentence ) ; } } return nouns ; }
va	8	void checkEvents ( ) { for ( WatchKey key ; ( key = watchService . poll ( ) ) != null ; ) { for ( WatchEvent < ? > event : key . pollEvents ( ) ) { WatchEvent . Kind < ? > kind = event . kind ( ) ; if ( kind == StandardWatchEventKinds . OVERFLOW ) { continue ; } Path filePath = ( Path ) event . context ( ) ; System . err . println ( "event for class file '" + filePath + "'" ) ; if ( kind == StandardWatchEventKinds . ENTRY_CREATE ) { registerCommand ( filePath ) ; } else if ( kind == StandardWatchEventKinds . ENTRY_DELETE ) { unregisterCommand ( filePath ) ; } } if ( ! key . reset ( ) ) { throw new Error ( "Failed to reset watch key." ) ; } } }
va	8	private void calcLetter ( double grade ) { if ( finalGrade <= 100 && finalGrade >= 90 ) letter = A ; else if ( finalGrade <= 89 && finalGrade >= 80 ) letter = B ; else if ( finalGrade <= 79 && finalGrade >= 70 ) letter = C ; else if ( finalGrade <= 69 && finalGrade >= 60 ) letter = D ; else letter = F ; }
va	7	public void removeAllBackgroundHighlights ( ) { for ( Highlight h : getHighlighter ( ) . getHighlights ( ) ) { if ( getSelection ( ) == null || ( h . getStartOffset ( ) != getSelectionStart ( ) && h . getEndOffset ( ) != getSelectionEnd ( ) ) ) if ( h . getPainter ( ) != currentLinePainter && h . getPainter ( ) != highlightPainter && h . getPainter ( ) != commandBackgroundPainter ) getHighlighter ( ) . removeHighlight ( h ) ; } }
va	9	private void createKeyAdapter ( ) { addKeyListener ( new KeyAdapter ( ) { @ Override public void keyPressed ( KeyEvent e ) { switch ( e . getKeyCode ( ) ) { case KeyEvent . VK_W : case KeyEvent . VK_UP : case KeyEvent . VK_K : direction = N ; adapter . updatePos ( PLAYER_ID , direction ) ; break ; case KeyEvent . VK_S : case KeyEvent . VK_DOWN : case KeyEvent . VK_J : direction = S ; adapter . updatePos ( PLAYER_ID , direction ) ; break ; case KeyEvent . VK_A : case KeyEvent . VK_LEFT : case KeyEvent . VK_H : direction = W ; adapter . updatePos ( PLAYER_ID , direction ) ; break ; case KeyEvent . VK_D : case KeyEvent . VK_RIGHT : case KeyEvent . VK_L : direction = E ; adapter . updatePos ( PLAYER_ID , direction ) ; break ; } ; } } ) ; }
va	0	public static String getUserSize ( int UsId ) { String sUserSize = "198" ; return sUserSize ; }
va	1	public boolean isCellEditable ( int row , int col ) { if ( col < 1 ) { return false ; } else { return true ; } }
va	3	public int Expect ( String Data , int NumBytes ) { byte target = 0 ; int cnt = 0 ; try { while ( ( NumBytes -- ) != 0 ) { target = file . readByte ( ) ; if ( target != Data . charAt ( cnt ++ ) ) return DDC_FILE_ERROR ; } } catch ( IOException ioe ) { return DDC_FILE_ERROR ; } return DDC_SUCCESS ; }
va	2	@ Override protected String getCellAsString ( int x , int y ) { int age = getCellAge ( x , y ) ; if ( age > 9 ) return "_" ; if ( age == 0 ) return "#" ; return age + "" ; }
va	6	public Color getTwoColor ( ) { if ( this . previous_two == null ) { return null ; } else { if ( this . matArray [ this . previous_two . face ] [ this . previous_two . row ] [ this . previous_two . column ] == redColor ) { return Color . RED ; } else if ( this . matArray [ this . previous_two . face ] [ this . previous_two . row ] [ this . previous_two . column ] == yellowColor ) { return Color . YELLOW ; } else if ( this . matArray [ this . previous_two . face ] [ this . previous_two . row ] [ this . previous_two . column ] == greenColor ) { return Color . GREEN ; } else if ( this . matArray [ this . previous_two . face ] [ this . previous_two . row ] [ this . previous_two . column ] == blueColor ) { return Color . BLUE ; } else if ( this . matArray [ this . previous_two . face ] [ this . previous_two . row ] [ this . previous_two . column ] == orangeColor ) { return Color . ORANGE ; } else { return Color . MAGENTA ; } } }
va	4	void updateContent ( ) { Insets lblInsets = new Insets ( 0 , 5 , 0 , 5 ) ; Insets spinnerInsets = new Insets ( 0 , 5 , 0 , 5 ) ; int lblSize = labelList . size ( ) , totSize = spinnerList . size ( ) ; for ( int i = lblSize ; i < totSize ; i ++ ) labelList . add ( new JLabel ( "" + ( i + 1 ) ) ) ; while ( visibleComps . size ( ) > 0 ) remove ( visibleComps . pop ( ) ) ; for ( int i = 0 ; i < totSize && i < VISIBLE_OVERTONE_COUNT ; i ++ ) { Component comp ; constraints = new GridBagConstraints ( 0 , i + 1 , 1 , 1 , 0.5 , 0.5 , GridBagConstraints . CENTER , GridBagConstraints . BOTH , lblInsets , 0 , 0 ) ; comp = labelList . get ( i + position ) ; add ( comp , constraints ) ; visibleComps . push ( comp ) ; constraints = ( GridBagConstraints ) constraints . clone ( ) ; constraints . insets = spinnerInsets ; constraints . gridx = 1 ; comp = spinnerList . get ( i + position ) ; add ( comp , constraints ) ; visibleComps . push ( comp ) ; } revalidate ( ) ; }
va	6	void drawObject ( Graphics g , JGObject o ) { if ( ! o . is_suspended ) { drawImage ( g , ( int ) o . x , ( int ) o . y , o . getImageName ( ) , true ) ; try { o . paint ( ) ; } catch ( JGameError ex ) { exitEngine ( dbgExceptionToString ( ex ) ) ; } catch ( Exception e ) { dbgShowException ( o . getName ( ) , e ) ; } } if ( ( debugflags & JGEngine . BBOX_DEBUG ) != 0 ) { setColor ( g , el . fg_color ) ; JGRectangle bbox = o . getBBox ( ) ; if ( bbox != null ) { bbox = el . scalePos ( bbox , true ) ; g . drawRect ( bbox . x , bbox . y , bbox . width , bbox . height ) ; } bbox = o . getTileBBox ( ) ; if ( bbox != null ) { bbox = el . scalePos ( bbox , true ) ; g . drawRect ( bbox . x , bbox . y , bbox . width , bbox . height ) ; setColor ( g , debug_auxcolor1 ) ; bbox = o . getTileBBox ( ) ; bbox = getTiles ( bbox ) ; bbox . x *= el . tilex ; bbox . y *= el . tiley ; bbox . width *= el . tilex ; bbox . height *= el . tiley ; bbox = el . scalePos ( bbox , true ) ; g . drawRect ( bbox . x , bbox . y , bbox . width , bbox . height ) ; setColor ( g , debug_auxcolor2 ) ; bbox = o . getCenterTiles ( ) ; bbox . x *= el . tilex ; bbox . y *= el . tiley ; bbox . width *= el . tilex ; bbox . height *= el . tiley ; bbox = el . scalePos ( bbox , true ) ; g . drawRect ( bbox . x + 2 , bbox . y + 2 , bbox . width - 4 , bbox . height - 4 ) ; } } }
va	4	public String createMaskFromDatePattern ( String datePattern ) { String symbols = "GyMdkHmsSEDFwWahKzZ" ; String mask = "" ; for ( int i = 0 ; i < datePattern . length ( ) ; i ++ ) { char ch = datePattern . charAt ( i ) ; boolean symbolFound = false ; for ( int n = 0 ; n < symbols . length ( ) ; n ++ ) { if ( symbols . charAt ( n ) == ch ) { mask += "#" ; symbolFound = true ; break ; } } if ( ! symbolFound ) { mask += ch ; } } return mask ; }
va	5	private boolean initialize ( int numOfRows , int numOfColumns ) { if ( isInitialized ) { Iterator < List < Passenger >> rowIterator = passengerList . iterator ( ) ; while ( rowIterator . hasNext ( ) ) { List < Passenger > _passengers = rowIterator . next ( ) ; for ( int i = 0 ; i < _passengers . size ( ) ; i ++ ) { _passengers . set ( i , null ) ; } } } else { for ( int i = 0 ; i < numOfRows ; i ++ ) { List < Passenger > _passengerList = new ArrayList < > ( numOfColumns - 1 ) ; for ( int j = 0 ; j < numOfColumns ; j ++ ) { _passengerList . add ( null ) ; } passengerList . add ( _passengerList ) ; } } return true ; }
va	2	DummyX509TrustManager ( File trustStore , char [ ] password ) throws Exception { KeyStore ks = KeyStore . getInstance ( KeyStore . getDefaultType ( ) ) ; ks . load ( new FileInputStream ( trustStore ) , password ) ; TrustManagerFactory tmf = TrustManagerFactory . getInstance ( TrustManagerFactory . getDefaultAlgorithm ( ) ) ; tmf . init ( ks ) ; TrustManager tms [ ] = tmf . getTrustManagers ( ) ; for ( int i = 0 ; i < tms . length ; i ++ ) { if ( tms [ i ] instanceof X509TrustManager ) { pkixTrustManager = ( X509TrustManager ) tms [ i ] ; return ; } } throw new Exception ( "Couldn't initialize" ) ; }
va	4	public static double min ( final double a , final double b ) { if ( a > b ) { return b ; } if ( a < b ) { return a ; } if ( a != b ) { return double . NaN ; } long bits = double . doubleToRawLongBits ( a ) ; if ( bits == 8000000000000000 ) { return a ; } return b ; }
va	0	private void addScrollPane ( ) { scrollPane = new JScrollPane ( tablePanel , JScrollPane . VERTICAL_SCROLLBAR_ALWAYS , JScrollPane . HORIZONTAL_SCROLLBAR_NEVER ) ; }
va	0	public int getMoney ( ) { return money ; }
va	8	private boolean r_prelude ( ) { int among_var ; int v_1 ; replab0 : while ( true ) { v_1 = cursor ; lab1 : do { bra = cursor ; among_var = find_among ( a_0 , 3 ) ; if ( among_var == 0 ) { break lab1 ; } ket = cursor ; switch ( among_var ) { case 0 : break lab1 ; case 1 : slice_from ( "a~" ) ; break ; case 2 : slice_from ( "o~" ) ; break ; case 3 : if ( cursor >= limit ) { break lab1 ; } cursor ++ ; break ; } continue replab0 ; } while ( false ) ; cursor = v_1 ; break replab0 ; } return true ; }
