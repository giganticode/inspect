va	7	public boolean setValueAt ( boolean value , int row , int column ) { if ( ( column >= 0 ) && ( column < this . tableModel . getColumnCount ( ) ) && ( row >= 0 ) && ( row < this . tableModel . getRowCount ( ) ) ) { class < ? extends Object > cell = this . table . getValueAt ( row , column ) . getClass ( ) ; if ( cell . isInstance ( new boolean ( true ) ) ) { this . table . setValueAt ( new boolean ( value ) , row , column ) ; return true ; } String classType = cell . toString ( ) ; try { throw new JSTableDataClassException ( "Error assigning value at cell " + row + "  " + column + ". " + "Trying to assign a Boolean value of " + value + " to a cell with class " + classType . substring ( 16 , classType . length ( ) ) + "." ) ; } catch ( JSTableDataClassException e ) { e . printStackTrace ( ) ; } } return false ; }
va	3	public int getPixelDifference ( BufferedImage letter , BufferedImage template ) { int height = letter . getHeight ( ) ; int width = ( int ) ( ( double ) height / template . getHeight ( ) * template . getWidth ( ) ) ; if ( height == 0 || width == 0 ) return 0 ; template = VisionUtils . resizeImage ( template , height , width ) ; if ( width < letter . getWidth ( ) ) { int minX = ( letter . getWidth ( ) - width ) / 2 ; width = letter . getWidth ( ) ; BufferedImage temp = new BufferedImage ( width , height , BufferedImage . TYPE_INT_RGB ) ; Graphics2D g = temp . createGraphics ( ) ; g . drawImage ( template , null , minX , 0 ) ; template = temp ; } else { int minX = ( width - letter . getWidth ( ) ) / 2 ; BufferedImage temp = new BufferedImage ( width , height , BufferedImage . TYPE_INT_RGB ) ; Graphics2D g = temp . createGraphics ( ) ; g . drawImage ( letter , null , minX , 0 ) ; letter = temp ; } return VisionUtils . imageDifference ( letter , template ) ; }
va	2	private void removeIgnoredPosTags ( ArrayList < String > tokens , ArrayList < String > posTags ) { int i = 0 ; while ( i < posTags . size ( ) ) { if ( ignorePosTags . contains ( posTags . get ( i ) ) ) { tokens . remove ( i ) ; posTags . remove ( i ) ; } else { i ++ ; } } }
va	1	@ Test public void testFix ( ) { final String sep = "\\|" ; final String [ ] headerFlds = HBurster . buildHeaderFlds ( "a|a|b" . split ( sep ) ) ; final String [ ] expect = { "a" , "a_2" , "b" } ; assertNotNull ( headerFlds ) ; assertEquals ( expect . length , headerFlds . length ) ; for ( int i = 0 ; i < expect . length ; ++ i ) { assertEquals ( expect [ i ] , headerFlds [ i ] ) ; } }
va	0	public Object [ ] formatoTabela ( AreaFormacao areaformacao ) { return new Object [ ] { areaformacao . getId ( ) , areaformacao . getNome ( ) } ; }
va	5	protected void obterPontos ( ) { try { framePai . dispose ( ) ; quant = Integer . parseInt ( entryQuant . getText ( ) ) ; frame = new JFrame ( ) ; frame . setLayout ( new FlowLayout ( ) ) ; frame . setSize ( 400 , 200 ) ; frame . setTitle ( "Criar Objeto" ) ; pnlPrincipal = new JPanel ( ) ; pnlPrincipal . setLayout ( new GridLayout ( 2 , 1 ) ) ; pnlSec = new JPanel ( ) ; pnlSec . setLayout ( new GridLayout ( ( quant + 1 ) , 4 ) ) ; pnlSec . add ( new Label ( "nome" ) ) ; pnlSec . add ( new Label ( "x" ) ) ; pnlSec . add ( new Label ( "y" ) ) ; pnlSec . add ( new Label ( "z" ) ) ; listaSemiPontos = new ArrayList < SemiPonto > ( ) ; for ( int i = 1 ; i <= quant ; i ++ ) { SemiPonto3D sp = new SemiPonto3D ( new JLabel ( "P" + i ) , new JTextField ( 5 ) , new JTextField ( 5 ) , new JTextField ( 5 ) ) ; listaSemiPontos . add ( sp ) ; pnlSec . add ( sp . getNome ( ) ) ; pnlSec . add ( sp . gettFx ( ) ) ; pnlSec . add ( sp . gettFy ( ) ) ; pnlSec . add ( sp . gettFz ( ) ) ; } switch ( quant ) { case 1 : btCriarObjt = new JButton ( "Criar Ponto" ) ; break ; case 2 : btCriarObjt = new JButton ( "Criar Reta" ) ; break ; default : btCriarObjt = new JButton ( "Criar Poliedro" ) ; } ControladorDeObjetos ctrlObjetos = new ControladorDeObjetos3D ( frame , listaSemiPontos , colorChooser , checkPreenchido . isSelected ( ) ) ; btCriarObjt . addActionListener ( ctrlObjetos ) ; btCriarObjt . addKeyListener ( ctrlObjetos ) ; pnlPrincipal . add ( pnlSec ) ; frame . add ( pnlPrincipal ) ; frame . add ( btCriarObjt ) ; frame . setVisible ( true ) ; } catch ( NumberFormatException e ) { e . printStackTrace ( ) ; JOptionPane . showMessageDialog ( frame , "N\u00FAmero de pontos invalido!" ) ; } catch ( HeadlessException e ) { e . printStackTrace ( ) ; } }
va	9	public static ArrayList < String > getTo ( String content ) { String header = getHeader ( content ) ; String headerLine [ ] = header . split ( "\n" ) ; ArrayList < String > toList = new ArrayList < String > ( ) ; boolean findToMuti = false ; for ( int i = 0 ; i < headerLine . length ; i ++ ) { headerLine [ i ] = headerLine [ i ] . trim ( ) ; if ( headerLine [ i ] . startsWith ( "To" ) ) { String headerLineContent [ ] = headerLine [ i ] . split ( ":" , 2 ) ; if ( headerLineContent [ 1 ] . trim ( ) . endsWith ( " " ) ) { findToMuti = true ; toList . add ( StringUtil . getEmailFromContent ( headerLineContent [ 1 ] ) ) ; } else { String aloneEmail [ ] = headerLineContent [ 1 ] . trim ( ) . split ( " " ) ; for ( int j = 0 ; j < aloneEmail . length ; j ++ ) { String email = aloneEmail [ j ] ; if ( aloneEmail [ j ] . contains ( "<" ) && aloneEmail [ j ] . contains ( ">" ) ) { email = StringUtil . getEmailFromContent ( aloneEmail [ j ] ) ; } toList . add ( email . trim ( ) ) ; } break ; } } else if ( ! headerLine [ i ] . startsWith ( "To" ) && findToMuti == true ) { if ( ! headerLine [ i ] . endsWith ( " " ) ) { findToMuti = false ; } toList . add ( StringUtil . getEmailFromContent ( headerLine [ i ] ) ) ; if ( findToMuti == false ) { break ; } } } return toList ; }
va	8	public BoardModel ( ) { this . map = new JavaCell [ 14 ] [ 14 ] ; this . outerCells = new JavaCell [ 52 ] ; this . irrigationMap = new JavaCell [ 14 ] [ 14 ] ; this . path = new LinkedList < JavaCell > ( ) ; connectedPalaces = new ArrayList < JavaCell > ( ) ; visitedVillages = new ArrayList < JavaCell > ( ) ; bodiesOfWater = new ArrayList < ArrayList < JavaCell >> ( ) ; cellId = 0 ; int i = 0 ; for ( int x = 0 ; x < map . length ; x ++ ) { for ( int y = 0 ; y < map [ 0 ] . length ; y ++ ) { map [ x ] [ y ] = new JavaCell ( x , y , 0 ) ; irrigationMap [ x ] [ y ] = new JavaCell ( x , y , 0 ) ; if ( ( x == 0 || x == 13 ) ) { outerCells [ i ] = map [ x ] [ y ] ; i ++ ; } else if ( ( y == 0 || y == 13 ) && ( x != 0 && x != 13 ) ) { outerCells [ i ] = map [ x ] [ y ] ; i ++ ; } } } }
va	1	public final void addRole ( RoleSchool role ) { if ( roles == null ) { roles = new ArrayList ( ) ; } roles . add ( role ) ; }
va	3	private void setFocus ( View view , boolean resetIndex ) { if ( view . requestFocus ( ) ) { if ( resetIndex ) { focusIndex = 0 ; } focusLevel = viewCollection . getLevel ( view ) ; if ( focusedView != null ) { focusedView . removeFocus ( ) ; } focusedView = view ; } }
va	5	@ Override public String toString ( ) { if ( size == 0 ) { return "[]" ; } StringBuilder buffer = new StringBuilder ( 32 ) ; buffer . append ( [ ) ; long [ ] keyTable = this . keyTable ; V [ ] valueTable = this . valueTable ; int i = keyTable . length ; while ( i -- > 0 ) { long key = keyTable [ i ] ; if ( key == EMPTY ) { continue ; } buffer . append ( key ) ; buffer . append ( = ) ; buffer . append ( valueTable [ i ] ) ; break ; } while ( i -- > 0 ) { long key = keyTable [ i ] ; if ( key == EMPTY ) { continue ; } buffer . append ( "  " ) ; buffer . append ( key ) ; buffer . append ( = ) ; buffer . append ( valueTable [ i ] ) ; } buffer . append ( ] ) ; return buffer . toString ( ) ; }
va	3	public void method387 ( int i , String s , int j , int k , int l ) { if ( s == null ) return ; i -= method384 ( s ) / 2 ; k -= anInt1497 ; for ( int i1 = 0 ; i1 < s . length ( ) ; i1 ++ ) { char c = s . charAt ( i1 ) ; if ( c !=   ) method392 ( aByteArrayArray1491 [ c ] , i + anIntArray1494 [ c ] + ( int ) ( Math . sin ( ( double ) i1 / 5D + ( double ) j / 5D ) * 5D ) , k + anIntArray1495 [ c ] + ( int ) ( Math . sin ( ( double ) i1 / 3D + ( double ) j / 5D ) * 5D ) , anIntArray1492 [ c ] , anIntArray1493 [ c ] , l ) ; i += anIntArray1496 [ c ] ; } }
va	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( VistaLoading . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( VistaLoading . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( VistaLoading . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( VistaLoading . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { @ Override public void run ( ) { VistaLoading dialog = new VistaLoading ( new javax . swing . JFrame ( ) , true ) ; dialog . addWindowListener ( new java . awt . event . WindowAdapter ( ) { @ Override public void windowClosing ( java . awt . event . WindowEvent e ) { System . exit ( 0 ) ; } } ) ; dialog . setVisible ( true ) ; } } ) ; }
va	4	public void MakeTorus ( double r ) { double theta , phi ; for ( int i = 0 ; i <= m ; i ++ ) for ( int j = 0 ; j <= n ; j ++ ) { theta = 2 * Math . PI * i / m ; phi = 2 * Math . PI * j / n ; vertices [ i + ( m + 1 ) * j ] [ 0 ] = ( 1 + r * Math . cos ( phi ) ) * Math . cos ( theta ) ; vertices [ i + ( m + 1 ) * j ] [ 1 ] = ( 1 + r * Math . cos ( phi ) ) * Math . sin ( theta ) ; vertices [ i + ( m + 1 ) * j ] [ 2 ] = r * Math . sin ( phi ) ; } for ( int i = 0 ; i < m ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) { faces [ i + ( m * j ) ] [ 0 ] = i + ( m + 1 ) * j ; faces [ i + ( m * j ) ] [ 1 ] = ( i + 1 ) + ( m + 1 ) * j ; faces [ i + ( m * j ) ] [ 2 ] = ( i + 1 ) + ( m + 1 ) * ( j + 1 ) ; faces [ i + ( m * j ) ] [ 3 ] = i + ( m + 1 ) * ( j + 1 ) ; } }
va	9	Writer write ( Writer writer , int indentFactor , int indent ) throws JSONException { try { boolean commanate = false ; final int length = this . length ( ) ; Iterator keys = this . keys ( ) ; writer . write ( { ) ; if ( length == 1 ) { Object key = keys . next ( ) ; writer . write ( quote ( key . toString ( ) ) ) ; writer . write ( : ) ; if ( indentFactor > 0 ) { writer . write (   ) ; } writeValue ( writer , this . map . get ( key ) , indentFactor , indent ) ; } else if ( length != 0 ) { final int newindent = indent + indentFactor ; while ( keys . hasNext ( ) ) { Object key = keys . next ( ) ; if ( commanate ) { writer . write (   ) ; } if ( indentFactor > 0 ) { writer . write ( '' ) ; } indent ( writer , newindent ) ; writer . write ( quote ( key . toString ( ) ) ) ; writer . write ( : ) ; if ( indentFactor > 0 ) { writer . write (   ) ; } writeValue ( writer , this . map . get ( key ) , indentFactor , newindent ) ; commanate = true ; } if ( indentFactor > 0 ) { writer . write ( '' ) ; } indent ( writer , indent ) ; } writer . write ( } ) ; return writer ; } catch ( IOException exception ) { throw new JSONException ( exception ) ; } }
va	2	public JSONArray ( Collection collection ) { this . myArrayList = new ArrayList ( ) ; if ( collection != null ) { Iterator iter = collection . iterator ( ) ; while ( iter . hasNext ( ) ) { this . myArrayList . add ( JSONObject . wrap ( iter . next ( ) ) ) ; } } }
va	6	public boolean isExistSentence ( boolean isTagged , String pattern ) { boolean isExist = false ; Iterator < SentenceStructure > iter = getSentenceHolderIterator ( ) ; while ( iter . hasNext ( ) ) { SentenceStructure sentenceItem = iter . next ( ) ; String tag = sentenceItem . getTag ( ) ; boolean isTagGood = false ; if ( isTagged ) { if ( ( ! StringUtils . equals ( tag , "ignore" ) ) || ( tag == null ) ) { isTagGood = true ; } } else { isTagGood = true ; } if ( isTagGood ) { String sentence = sentenceItem . getSentence ( ) ; if ( StringUtility . isMatchedNullSafe ( sentence , pattern ) ) { isExist = true ; return isExist ; } } } return isExist ; }
va	3	public List < Bed > getSearchedBedBySearchId ( Integer searchId ) throws SQLException { Connection con = null ; List < Bed > beds = new ArrayList < Bed > ( ) ; try { con = services . createConnection ( ) ; PreparedStatement stmt = con . prepareStatement ( "select * from searched_beds where searchId = ?; " ) ; stmt . setInt ( 1 , searchId ) ; ResultSet rs = stmt . executeQuery ( ) ; Bed bed ; while ( rs . next ( ) ) { bed = createSearchedBedInstance ( rs ) ; beds . add ( bed ) ; } rs . close ( ) ; stmt . close ( ) ; } catch ( ServiceLocatorException | SQLException e ) { e . printStackTrace ( ) ; } finally { if ( con != null ) { con . close ( ) ; } } return beds ; }
va	7	public void run ( ) { try { Thread . sleep ( 1000 ) ; String s = "" ; for ( long j = 0 ; j < 1024 * 1024 ; j ++ ) { s = s + "j-" ; } } catch ( InterruptedException e ) { } }
va	9	private void postPlugin ( final boolean isPing ) throws IOException { PluginDescriptionFile description = plugin . getDescription ( ) ; String pluginName = description . getName ( ) ; boolean onlineMode = Bukkit . getServer ( ) . getOnlineMode ( ) ; String pluginVersion = description . getVersion ( ) ; String serverVersion = Bukkit . getVersion ( ) ; int playersOnline = Bukkit . getServer ( ) . getOnlinePlayers ( ) . length ; final StringBuilder data = new StringBuilder ( ) ; data . append ( encode ( "guid" ) ) . append ( = ) . append ( encode ( guid ) ) ; encodeDataPair ( data , "version" , pluginVersion ) ; encodeDataPair ( data , "server" , serverVersion ) ; encodeDataPair ( data , "players" , Integer . toString ( playersOnline ) ) ; encodeDataPair ( data , "revision" , String . valueOf ( REVISION ) ) ; String osname = System . getProperty ( "os.name" ) ; String osarch = System . getProperty ( "os.arch" ) ; String osversion = System . getProperty ( "os.version" ) ; String java_version = System . getProperty ( "java.version" ) ; int coreCount = Runtime . getRuntime ( ) . availableProcessors ( ) ; if ( osarch . equals ( "amd64" ) ) { osarch = "x86_64" ; } encodeDataPair ( data , "osname" , osname ) ; encodeDataPair ( data , "osarch" , osarch ) ; encodeDataPair ( data , "osversion" , osversion ) ; encodeDataPair ( data , "cores" , Integer . toString ( coreCount ) ) ; encodeDataPair ( data , "online-mode" , boolean . toString ( onlineMode ) ) ; encodeDataPair ( data , "java_version" , java_version ) ; if ( isPing ) { encodeDataPair ( data , "ping" , "true" ) ; } synchronized ( graphs ) { final Iterator < Graph > iter = graphs . iterator ( ) ; while ( iter . hasNext ( ) ) { final Graph graph = iter . next ( ) ; for ( Plotter plotter : graph . getPlotters ( ) ) { final String key = String . format ( "C%s%s%s%s" , CUSTOM_DATA_SEPARATOR , graph . getName ( ) , CUSTOM_DATA_SEPARATOR , plotter . getColumnName ( ) ) ; final String value = Integer . toString ( plotter . getValue ( ) ) ; encodeDataPair ( data , key , value ) ; } } } URL url = new URL ( BASE_URL + String . format ( REPORT_URL , encode ( pluginName ) ) ) ; URLConnection connection ; if ( isMineshafterPresent ( ) ) { connection = url . openConnection ( Proxy . NO_PROXY ) ; } else { connection = url . openConnection ( ) ; } connection . setDoOutput ( true ) ; final OutputStreamWriter writer = new OutputStreamWriter ( connection . getOutputStream ( ) ) ; writer . write ( data . toString ( ) ) ; writer . flush ( ) ; final BufferedReader reader = new BufferedReader ( new InputStreamReader ( connection . getInputStream ( ) ) ) ; final String response = reader . readLine ( ) ; writer . close ( ) ; reader . close ( ) ; if ( response == null || response . startsWith ( "ERR" ) ) { throw new IOException ( response ) ; } else { if ( response . contains ( "OK This is your first update this hour" ) ) { synchronized ( graphs ) { final Iterator < Graph > iter = graphs . iterator ( ) ; while ( iter . hasNext ( ) ) { final Graph graph = iter . next ( ) ; for ( Plotter plotter : graph . getPlotters ( ) ) { plotter . reset ( ) ; } } } } } }
va	5	protected void agregarEnJuego ( ) { final Disparo controllerDisparo = this ; Color color = Color . BLUE ; switch ( this . tipo ) { case CONVENCIONAL : color = Color . BLUE ; break ; case MINA_SIMPLE : color = Color . GREEN ; break ; case MINA_DOBLE : color = Color . RED ; break ; case MINA_TRIPLE : color = Color . YELLOW ; break ; case MINA_CONTACTO : color = Color . CYAN ; break ; } final Color tColor = color ; this . gameLoop . agregar ( new Elipse ( this . ladoX , this . ladoY , ( ObjetoPosicionable ) new ObjetoPosicionable ( ) { public int getX ( ) { return controllerDisparo . getX ( ) ; } public int getY ( ) { return controllerDisparo . getY ( ) ; } } ) { public Color getColor ( ) { return tColor ; } } ) ; }
va	4	public static ArrayList < ServerMeetingModel > searchByUsernamesAndPeriod ( String [ ] users , Calendar startDate , Calendar endDate , DBConnection db ) { if ( users . length == 0 ) { throw new IllegalArgumentException ( "Need atleast one user" ) ; } ArrayList < ServerMeetingModel > ret = new ArrayList < ServerMeetingModel > ( ) ; try { StringBuilder userIn = new StringBuilder ( ) ; for ( String u : users ) { userIn . append ( " '" + u + "'" ) ; } String userList = userIn . toString ( ) . substring ( 1 ) ; ResultSet rs = db . performQuery ( "SELECT DISTINCT a.* FROM appointment as a " + "LEFT JOIN user_appointment as ap ON a.id = ap.appointment_id " + "WHERE active=1 " + "AND start_date >= '" + DBConnection . getFormattedDate ( startDate ) + "' " + "AND start_date < '" + DBConnection . getFormattedDate ( endDate ) + "' " + "AND (a.owner IN (" + userList + ") OR ap.username IN (" + userList + "))" ) ; while ( rs . next ( ) ) { ret . add ( new ServerMeetingModel ( rs , db ) ) ; } rs . close ( ) ; return ret ; } catch ( SQLException e ) { e . printStackTrace ( ) ; } return null ; }
va	9	static String valueToString ( Object value , int indentFactor , int indent ) throws JSONException { if ( value == null || value . equals ( null ) ) { return "null" ; } try { if ( value instanceof JSONString ) { Object o = ( ( JSONString ) value ) . toJSONString ( ) ; if ( o instanceof String ) { return ( String ) o ; } } } catch ( Exception e ) { } if ( value instanceof Number ) { return numberToString ( ( Number ) value ) ; } if ( value instanceof boolean ) { return value . toString ( ) ; } if ( value instanceof JSONObject ) { return ( ( JSONObject ) value ) . toString ( indentFactor , indent ) ; } if ( value instanceof JSONArray ) { return ( ( JSONArray ) value ) . toString ( indentFactor , indent ) ; } if ( value instanceof Map ) { return new JSONObject ( ( Map ) value ) . toString ( indentFactor , indent ) ; } if ( value instanceof Collection ) { return new JSONArray ( ( Collection ) value ) . toString ( indentFactor , indent ) ; } if ( value . getClass ( ) . isArray ( ) ) { return new JSONArray ( value ) . toString ( indentFactor , indent ) ; } return quote ( value . toString ( ) ) ; }
va	8	private void jBListarIncidentesActionPerformed ( java . awt . event . ActionEvent evt ) { int comuna = combo_comuna_reportetriple . getSelectedIndex ( ) ; int tipo = combo_tipo_reportetriple . getSelectedIndex ( ) ; int barrio = combo_barrio_reportetriple . getSelectedIndex ( ) ; if ( comuna != 0 && tipo != 0 && barrio != 0 ) { Comuna codigocomuna = controlador . buscarComuna ( combo_comuna_reportetriple . getSelectedItem ( ) . toString ( ) ) ; TipoInscidente codigotipo = controlador . buscarTipoIncidente ( combo_tipo_reportetriple . getSelectedItem ( ) . toString ( ) ) ; Barrio codigobarrio = controlador . buscarBarrio ( combo_barrio_reportetriple . getSelectedItem ( ) . toString ( ) ) ; getControlador ( ) . cargarIncidentesPorComunaTipoYBarrio ( codigocomuna . getCom_codigo ( ) , codigotipo . getTipinc_codigo ( ) , codigobarrio . getBar_codigo ( ) ) ; DefaultTableModel lstIncidente = ( DefaultTableModel ) tableListaIncidente . getModel ( ) ; if ( ! getControlador ( ) . getListaIncicomunatipoybarrio ( ) . isEmpty ( ) ) { JOptionPane . showMessageDialog ( null , "Se tienen " + getControlador ( ) . getListaIncicomunatipoybarrio ( ) . size ( ) + " Incidentes Registrados en el barrio " + codigobarrio . getBar_nombre ( ) + " de la Comuna " + codigocomuna . getCom_nombre ( ) + " Y con el tipo de incidente " + codigotipo . getTipinc_descripcion ( ) ) ; tableListaIncidente . removeAll ( ) ; int rowCount = lstIncidente . getRowCount ( ) ; for ( int i = 0 ; i < rowCount ; i ++ ) { lstIncidente . removeRow ( i ) ; } for ( int i = 0 ; i < getControlador ( ) . getListaIncicomunatipoybarrio ( ) . size ( ) ; i ++ ) { lstIncidente . addRow ( new Object [ ] { getControlador ( ) . getListaIncicomunatipoybarrio ( ) . get ( i ) . getComuna ( ) . getCom_nombre ( ) , getControlador ( ) . getListaIncicomunatipoybarrio ( ) . get ( i ) . getBarrio ( ) . getBar_nombre ( ) , getControlador ( ) . getListaIncicomunatipoybarrio ( ) . get ( i ) . getTipo_incidente ( ) . getTipinc_descripcion ( ) , getControlador ( ) . getListaIncicomunatipoybarrio ( ) . get ( i ) . getInc_codigoIncidente ( ) , getControlador ( ) . getListaIncicomunatipoybarrio ( ) . get ( i ) . getInc_descripcionIncidente ( ) , getControlador ( ) . getListaIncicomunatipoybarrio ( ) . get ( i ) . getInc_fechaIncidente ( ) , getControlador ( ) . getListaIncicomunatipoybarrio ( ) . get ( i ) . getUsuario ( ) . getTelefono ( ) } ) ; } } else { JOptionPane . showMessageDialog ( null , "No tiene Se Tienen Incidentes en el barrio " + codigobarrio . getBar_nombre ( ) + " de la Comuna " + codigocomuna . getCom_nombre ( ) + " Y con el tipo de incidente " + codigotipo . getTipinc_descripcion ( ) ) ; int rowCount = lstIncidente . getRowCount ( ) ; for ( int i = 0 ; i < rowCount ; i ++ ) { lstIncidente . removeRow ( i ) ; } if ( lstIncidente . getRowCount ( ) > 0 ) { lstIncidente . removeRow ( tableListaIncidente . getSelectedRow ( ) ) ; } } } else { JOptionPane . showMessageDialog ( null , "Debe Seleccionar Una Comuna  un Barrio y un Tipo de Incidente" ) ; } }
va	0	public GenericResponse stopPlay ( LinkedHashMap < String , String > parameters ) throws PlivoException { String call_uuid = getKeyValue ( parameters , "call_uuid" ) ; return this . gson . fromJson ( request ( "DELETE" , String . format ( "/Call/%s/Play/" , call_uuid ) , new LinkedHashMap < String , String > ( ) ) , GenericResponse . class ) ; }
va	7	@ Override public void run ( ) { for ( Player p : players ) { if ( p . isRunning ( ) && p . getStamina ( ) >= 0.1 ) p . setStamina ( p . getStamina ( ) - 0.1 ) ; else if ( p . isRunning ( ) ) { p . setRunning ( false ) ; p . setWalking ( true ) ; if ( p . isStaminaRefilled ( ) ) p . waitForStamina ( ) ; } if ( p . getStamina ( ) + 0.075 > p . getMaxStamina ( ) ) p . setStamina ( p . getMaxStamina ( ) ) ; else if ( p . getStamina ( ) + 0.075 <= p . getMaxStamina ( ) ) p . setStamina ( p . getStamina ( ) + 0.05 ) ; } }
va	2	public JSONObject putOpt ( String key , Object value ) throws JSONException { if ( key != null && value != null ) { put ( key , value ) ; } return this ; }
va	6	protected boolean findDeleted ( Topic oldTopic , Topic newTopic , boolean markDeleted ) { boolean changed = false ; if ( oldTopic == null ) return changed ; List < Integer > oldPosts = new ArrayList < Integer > ( oldTopic . getAllPosts ( ) ) ; if ( oldTopic . getAllPosts ( ) . isEmpty ( ) ) return changed ; for ( int i = 0 ; i < oldPosts . size ( ) ; i ++ ) { int num = oldPosts . get ( i ) ; if ( ! newTopic . findPost ( num ) ) { if ( ! markDeleted ) return true ; changed = true ; oldTopic . getAllPosts ( ) . remove ( num ) ; DeletedPost post = new DeletedPost ( num , System . currentTimeMillis ( ) / 1000 ) ; deletedPosts . add ( post ) ; debug ( TALK , num + " (post): deleted" ) ; } if ( i == 0 ) i = newTopic . getOmPosts ( ) ; } return changed ; }
va	8	@ Override public void write ( int theByte ) throws java . io . IOException { if ( suspendEncoding ) { this . out . write ( theByte ) ; return ; } if ( encode ) { buffer [ position ++ ] = ( byte ) theByte ; if ( position >= bufferLength ) { this . out . write ( encode3to4 ( b4 , buffer , bufferLength , options ) ) ; lineLength += 4 ; if ( breakLines && lineLength >= MAX_LINE_LENGTH ) { this . out . write ( NEW_LINE ) ; lineLength = 0 ; } position = 0 ; } } else { if ( decodabet [ theByte & 7f ] > WHITE_SPACE_ENC ) { buffer [ position ++ ] = ( byte ) theByte ; if ( position >= bufferLength ) { int len = Base64 . decode4to3 ( buffer , 0 , b4 , 0 , options ) ; out . write ( b4 , 0 , len ) ; position = 0 ; } } else if ( decodabet [ theByte & 7f ] != WHITE_SPACE_ENC ) { throw new java . io . IOException ( "Invalid character in Base64 data." ) ; } } }
va	8	private boolean r_postlude ( ) { int among_var ; int v_1 ; replab0 : while ( true ) { v_1 = cursor ; lab1 : do { bra = cursor ; among_var = find_among ( a_1 , 3 ) ; if ( among_var == 0 ) { break lab1 ; } ket = cursor ; switch ( among_var ) { case 0 : break lab1 ; case 1 : slice_from ( "y" ) ; break ; case 2 : slice_from ( "i" ) ; break ; case 3 : if ( cursor >= limit ) { break lab1 ; } cursor ++ ; break ; } continue replab0 ; } while ( false ) ; cursor = v_1 ; break replab0 ; } return true ; }
va	7	public Image getImgSpc ( int type , int id ) { switch ( type ) { case 3 : return imgDB . getImgById ( ( ( id == 0 ) ? bgWId : bgBId ) ) ; case 0 : return imgDB . getImgById ( mySide ? NumId [ id - 1 ] : NumId [ 8 - id ] ) ; case 1 : return imgDB . getImgById ( mySide ? AlpId [ 8 - id ] : AlpId [ id - 1 ] ) ; case 2 : return imgDB . getImgById ( id ) ; } return null ; }
va	6	@ Override public boolean equals ( final Object obj ) { if ( this == obj ) { return true ; } if ( obj == null ) { return false ; } if ( getClass ( ) != obj . getClass ( ) ) { return false ; } final Point3D other = ( Point3D ) obj ; if ( x != other . x ) { return false ; } if ( y != other . y ) { return false ; } if ( z != other . z ) { return false ; } return true ; }
va	5	public void toNote ( ) { ItemDef itemDef = forID ( certTemplateID ) ; modelID = itemDef . modelID ; modelZoom = itemDef . modelZoom ; modelRotation1 = itemDef . modelRotation1 ; modelRotation2 = itemDef . modelRotation2 ; anInt204 = itemDef . anInt204 ; modelOffset1 = itemDef . modelOffset1 ; modelOffset2 = itemDef . modelOffset2 ; editedModelColor = itemDef . editedModelColor ; newModelColor = itemDef . newModelColor ; ItemDef itemDef_1 = forID ( certID ) ; name = itemDef_1 . name ; membersObject = itemDef_1 . membersObject ; value = itemDef_1 . value ; String s = "a" ; char c = itemDef_1 . name . charAt ( 0 ) ; if ( c == A || c == E || c == I || c == O || c == U ) s = "an" ; description = ( "Swap this note at any bank for " + s + " " + itemDef_1 . name + "." ) ; stackable = true ; }
va	3	public void setMatrix ( int [ ] r , int j0 , int j1 , Matrix X ) { try { for ( int i = 0 ; i < r . length ; i ++ ) { for ( int j = j0 ; j <= j1 ; j ++ ) { A [ r [ i ] ] [ j ] = X . get ( i , j - j0 ) ; } } } catch ( ArrayIndexOutOfBoundsException e ) { throw new ArrayIndexOutOfBoundsException ( "Submatrix indices" ) ; } }
va	1	protected Object getArrayFromByteArray ( byte [ ] data ) { DoubleBuffer buffer = ByteBuffer . wrap ( data ) . asDoubleBuffer ( ) ; double [ ] numbers = new double [ data . length / getSizeInOctets ( ) ] ; for ( int i = 0 ; i < numbers . length ; i ++ ) numbers [ i ] = buffer . get ( ) ; return numbers ; }
va	3	@ Override public void initialize ( URL url , ResourceBundle resourceBundle ) { System . out . println ( "started ok" ) ; data = AppCore . data ; cCreateTime . setCellValueFactory ( new PropertyValueFactory < CPTrack , String > ( "time" ) ) ; cFileName . setCellValueFactory ( new PropertyValueFactory < CPTrack , String > ( "name" ) ) ; SEvents . only . listen ( new SListener ( SListener . CPLIST_CHANGE ) { @ Override public void run ( Object o ) { initTableFileList ( ) ; } } ) ; SEvents . only . listen ( new SListener ( SListener . CP_CHANGE ) { @ Override public void run ( Object o ) { initSelection ( ) ; } } ) ; tableFiles . getSelectionModel ( ) . selectedItemProperty ( ) . addListener ( new ChangeListener ( ) { @ Override public void changed ( ObservableValue observableValue , Object o , Object o2 ) { Object obj = null ; if ( o != null ) obj = o ; if ( o2 != null ) obj = o2 ; if ( obj != null ) { cpTrack = ( CPTrack ) obj ; data . setCPTrack ( cpTrack ) ; fileName . setText ( cpTrack . name ) ; } } } ) ; initTableFileList ( ) ; }
va	0	public void addId ( ) { GridBagConstraints c = new GridBagConstraints ( ) ; c . anchor = GridBagConstraints . PAGE_END ; nume_util = new JLabel ( admin . getNumeUtil ( ) ) ; tip = new JLabel ( "Administrator" ) ; c . gridy = 4 ; back = new JButton ( "Back" ) ; back . addActionListener ( this ) ; back . setPreferredSize ( new Dimension ( 200 , 30 ) ) ; JPanel pan = new JPanel ( new GridLayout ( 2 , 1 , 5 , 5 ) ) ; pan . add ( nume_util ) ; pan . add ( tip ) ; c . gridy = 3 ; c . gridx = 1 ; this . add ( pan , c ) ; c . gridx = 0 ; pan . setBorder ( new EtchedBorder ( ) ) ; this . add ( back , c ) ; }
va	7	public void create ( SaploText saploText ) throws SaploClientException { verifyCollection ( saploText ) ; if ( ClientUtil . NULL_STRING . equals ( saploText . getBody ( ) ) ) throw new SaploClientException ( MSG_CLIENT_FIELD , CODE_CLIENT_FIELD , "text.body" ) ; JSONObject params = new JSONObject ( ) ; try { params . put ( "collection_id" , saploText . getCollection ( ) . getId ( ) ) ; params . put ( "body" , saploText . getBody ( ) ) ; if ( ! ClientUtil . NULL_STRING . equals ( saploText . getHeadline ( ) ) ) params . put ( "headline" , saploText . getHeadline ( ) ) ; if ( saploText . getPublishDate ( ) != null ) params . put ( "publish_date" , sf . format ( saploText . getPublishDate ( ) ) ) ; else params . put ( "publish_date" , sf . format ( new Date ( ) ) ) ; if ( saploText . getUrl ( ) != null ) params . put ( "url" , saploText . getUrl ( ) . toString ( ) ) ; if ( ! ClientUtil . NULL_STRING . equals ( saploText . getAuthors ( ) ) ) params . put ( "authors" , saploText . getAuthors ( ) ) ; if ( ! ClientUtil . NULL_STRING . equals ( saploText . getExtId ( ) ) ) params . put ( "ext_text_id" , saploText . getExtId ( ) ) ; params . put ( "force" , saploText . isForce ( ) ) ; } catch ( JSONException je ) { throw new SaploClientException ( CODE_JSON_EXCEPTION , je ) ; } JSONRPCRequestObject request = new JSONRPCRequestObject ( client . getNextId ( ) , "text.create" , params ) ; JSONObject jsonText = ( JSONObject ) client . sendAndReceiveAndParseResponse ( request ) ; SaploText . convertFromJSONToText ( jsonText , saploText ) ; }
va	2	public String getWinnerTeam ( ) { if ( this . homeGoals > this . awayGoals ) return this . homeTeam ; else if ( this . awayGoals > this . homeGoals ) return this . awayTeam ; else return null ; }
va	1	@ Override protected void selectionChanged ( int selectionIndex ) { Audiences au = model . getEntity ( selectionIndex ) ; String sql = "CALL au_subjects(?)" ; Object [ ] [ ] result = DBConnection . getInstance ( ) . executeQuery ( sql , new Object [ ] { au . getId ( ) } ) ; String [ ] subjects = new String [ result . length ] ; for ( int i = 0 ; i < subjects . length ; i ++ ) { subjects [ i ] = ( String ) result [ i ] [ 0 ] ; } Object [ ] params = new Object [ ] { au . getFullNumber ( ) , AudienceModel . AUDIENCE_TYPE [ au . getType ( ) ] , au . getCapacity ( ) , subjects } ; HtmlBuilder html = new HtmlBuilder ( "audiences.rep" , params ) ; setInfoText ( html . toString ( ) ) ; }
va	9	public void paint ( Graphics g ) { Graphics2D g2 = ( Graphics2D ) g . create ( ) ; g2 . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; g2 . translate ( ( int ) xLoc , ( int ) yLoc ) ; g2 . rotate ( getVelocity ( ) . getAngle ( ) + ( Math . PI / 2 ) ) ; if ( state == EXPLODING ) { int explodecount = AnimTimer . countSince ( explodetmr , 6 ) ; ExplosionEffect . paint ( g2 , 2 , new Point ( 0 , 0 ) , 25 ) ; if ( explodecount > 100 ) { explodetmr = AnimTimer . startTmr ( ) ; gp . game . resetPlayer ( ) ; } g2 . setColor ( new Color ( Color . orange . getRed ( ) , Color . orange . getGreen ( ) , Color . orange . getBlue ( ) , 255 - 2 * explodecount ) ) ; g2 . fillOval ( explodecount / - 2 , explodecount / - 2 , explodecount , explodecount ) ; return ; } if ( state == TELEPORTING ) { int teleportcount = AnimTimer . countSince ( teletmr , 2 ) ; Graphics2D g3 = ( Graphics2D ) g . create ( ) ; g3 . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; g3 . translate ( ( int ) xLoc + telOff . x , ( int ) yLoc + telOff . y ) ; g3 . rotate ( getVelocity ( ) . getAngle ( ) + ( Math . PI / 2 ) ) ; g2 . setColor ( new Color ( 20 , 250 , 90 ) ) ; g3 . setColor ( new Color ( 20 , 250 , 90 ) ) ; if ( teleportcount <= 60 ) { g2 . drawOval ( teleportcount / - 4 , teleportcount / - 4 , teleportcount / 2 , teleportcount / 2 ) ; g3 . fillOval ( teleportcount / - 4 , teleportcount / - 4 , teleportcount / 2 , teleportcount / 2 ) ; } else if ( teleportcount <= 120 ) { g3 . drawOval ( ( 120 - teleportcount ) / - 4 , ( 120 - teleportcount ) / - 4 , ( 120 - teleportcount ) / 2 , ( 120 - teleportcount ) / 2 ) ; g2 . fillOval ( ( 120 - teleportcount ) / - 4 , ( 120 - teleportcount ) / - 4 , ( 120 - teleportcount ) / 2 , ( 120 - teleportcount ) / 2 ) ; g2 = g3 ; } else { state = NORMAL ; xLoc += telOff . x ; yLoc += telOff . y ; teleportcount = 0 ; } } if ( in ) g2 . drawImage ( rocket , - 10 , - 13 , null ) ; if ( state == WARPING ) { int warpcount = AnimTimer . countSince ( warptmr , 3 ) ; if ( ! in ) warpcount = 120 - warpcount ; g2 . setColor ( new Color ( 20 , 90 , 250 ) ) ; g2 . drawOval ( warpcount / - 4 , warpcount / - 4 , warpcount / 2 , warpcount / 2 ) ; if ( warpcount > 60 ) in = false ; if ( ! in ) { g2 . fillOval ( warpcount / - 4 , warpcount / - 4 , warpcount / 2 , warpcount / 2 ) ; if ( warpcount < - 200 ) { gp . game . winLevel ( ) ; } warpcount -= 2 ; } } }
va	6	public org . w3c . dom . Attr setAttributeNode ( org . w3c . dom . Attr newAttr ) throws DOMException { if ( newAttr == null ) return null ; if ( ! ( newAttr instanceof DOMAttrImpl ) ) { throw new DOMExceptionImpl ( DOMException . WRONG_DOCUMENT_ERR , "newAttr not instanceof DOMAttrImpl" ) ; } DOMAttrImpl newatt = ( DOMAttrImpl ) newAttr ; String name = newatt . avAdaptee . attribute ; org . w3c . dom . Attr result = null ; AttVal att = this . adaptee . attributes ; while ( att != null ) { if ( att . attribute . equals ( name ) ) break ; att = att . next ; } if ( att != null ) { result = att . getAdapter ( ) ; att . adapter = newAttr ; } else { if ( this . adaptee . attributes == null ) { this . adaptee . attributes = newatt . avAdaptee ; } else { newatt . avAdaptee . next = this . adaptee . attributes ; this . adaptee . attributes = newatt . avAdaptee ; } } return result ; }
va	6	public void displaceByImprovedNoise ( double freq , double ampl ) { if ( child != null ) for ( int i = 0 ; i < child . length && child [ i ] != null ; i ++ ) child [ i ] . displaceByImprovedNoise ( freq , ampl ) ; if ( vertices != null ) { double v [ ] [ ] = vertices , x , y , z , s ; for ( int k = 0 ; k < v . length ; k ++ ) { x = freq * ( v [ k ] [ 0 ] + noiseOrigin [ 0 ] ) ; y = freq * ( v [ k ] [ 1 ] + noiseOrigin [ 1 ] ) ; z = freq * ( v [ k ] [ 2 ] + noiseOrigin [ 2 ] ) ; s = ampl * ImprovedNoise . noise ( x , y , z ) ; if ( v [ k ] [ 3 ] * v [ k ] [ 3 ] + v [ k ] [ 4 ] * v [ k ] [ 4 ] + v [ k ] [ 5 ] * v [ k ] [ 5 ] < 2 ) { v [ k ] [ 0 ] += s * v [ k ] [ 3 ] ; v [ k ] [ 1 ] += s * v [ k ] [ 4 ] ; v [ k ] [ 2 ] += s * v [ k ] [ 5 ] ; } } } computedMeshNormals = false ; }
va	0	public Player getPlayer ( ) { return player ; }
va	9	public void createGlobalAlignment ( ) { int horizontal [ ] [ ] = new int [ one . length ( ) + 1 ] [ two . length ( ) ] ; int vertical [ ] [ ] = new int [ one . length ( ) ] [ two . length ( ) + 1 ] ; int diagonal [ ] [ ] = new int [ one . length ( ) ] [ two . length ( ) ] ; int scoringMatrix [ ] [ ] = new int [ one . length ( ) + 1 ] [ two . length ( ) + 1 ] ; for ( int i = 0 ; i < one . length ( ) ; i ++ ) { for ( int j = 0 ; j < two . length ( ) ; j ++ ) { if ( one . charAt ( i ) == two . charAt ( j ) ) { diagonal [ i ] [ j ] = 0 ; } else { diagonal [ i ] [ j ] = 1 ; } } } for ( int i = 0 ; i < one . length ( ) + 1 ; i ++ ) { for ( int j = 0 ; j < two . length ( ) ; j ++ ) { horizontal [ i ] [ j ] = - penalty ; } } for ( int i = 0 ; i < one . length ( ) ; i ++ ) { for ( int j = 0 ; j < two . length ( ) + 1 ; j ++ ) { vertical [ i ] [ j ] = - penalty ; } } scoringMatrix [ 0 ] [ 0 ] = 0 ; for ( int i = 1 ; i <= one . length ( ) ; i ++ ) { scoringMatrix [ i ] [ 0 ] = - penalty * i ; } for ( int i = 1 ; i <= two . length ( ) ; i ++ ) { scoringMatrix [ 0 ] [ i ] = - penalty * i ; } for ( int i = 1 ; i < one . length ( ) + 1 ; i ++ ) { for ( int j = 1 ; j < two . length ( ) + 1 ; j ++ ) { int hori = scoringMatrix [ i ] [ j - 1 ] - penalty ; int verti = scoringMatrix [ i - 1 ] [ j ] - penalty ; int dia = scoringMatrix [ i - 1 ] [ j - 1 ] + diagonal [ i - 1 ] [ j - 1 ] ; scoringMatrix [ i ] [ j ] = min ( hori , verti , dia ) ; } } int i = one . length ( ) ; int j = two . length ( ) ; System . out . println ( scoringMatrix [ i ] [ j ] ) ; }
va	2	public int getMenuID ( MenuClass menu ) { ResultSet result = null ; int menu_id = 0 ; try { result = query ( "Select menu_id " + "From menus " + "WHERE meal_id1 = " + menu . getAppetizer ( ) . getID ( ) + " AND meal_id2=" + menu . getMainMeal ( ) . getID ( ) + " AND meal_id3=" + menu . getDessert ( ) . getID ( ) ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; return - 1 ; } try { result . next ( ) ; menu_id = result . getInt ( "menu_id" ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; return - 1 ; } return menu_id ; }
va	7	public static int [ ] getSubset ( int [ ] set , int sum ) { for ( int i = 0 ; i < set . length ; i ++ ) { for ( int j = 0 ; j < set . length ; j ++ ) { for ( int k = 0 ; k < set . length ; k ++ ) { if ( ( i != j && j != k && i != k ) && ( set [ i ] + set [ j ] + set [ k ] == sum ) ) { return new int [ ] { set [ i ] , set [ j ] , set [ k ] } ; } } } } return new int [ ] { } ; }
va	5	@ Override public String getStatAt ( int position ) { String stat = "Spe" ; if ( position == 0 ) { stat = "HP" ; } else if ( position == 1 ) { stat = "Atk" ; } else if ( position == 2 ) { stat = "Def" ; } else if ( position == 3 ) { stat = "SAtk" ; } else if ( position == 4 ) { stat = "Atk" ; } return stat ; }
va	2	public JSONObject append ( String key , Object value ) throws JSONException { testValidity ( value ) ; Object object = this . opt ( key ) ; if ( object == null ) { this . put ( key , new JSONArray ( ) . put ( value ) ) ; } else if ( object instanceof JSONArray ) { this . put ( key , ( ( JSONArray ) object ) . put ( value ) ) ; } else { throw new JSONException ( "JSONObject[" + key + "] is not a JSONArray." ) ; } return this ; }
va	8	private void adjustScale ( double v , double theta ) { int i = 0 ; while ( i < _launchVelocity . length && theta > _launchAngle [ i ] ) i ++ ; if ( i == 0 ) i = 1 ; double temp = v / _launchVelocity [ i - 1 ] ; if ( temp != temp ) return ; if ( temp > 1.1 || temp < 0.9 ) { return ; } if ( theta > Math . toRadians ( 50 ) ) _scaleFactor = temp ; else if ( theta > Math . toRadians ( 25 ) ) _scaleFactor = temp * 0.6 + _scaleFactor * 0.4 ; }
va	8	public Automaton repeat ( int min , int max ) { expandSingleton ( ) ; if ( min > max ) return makeEmpty ( ) ; max -= min ; Automaton a ; if ( min == 0 ) a = makeEmptyString ( ) ; else if ( min == 1 ) a = clone ( ) ; else { List < Automaton > as = new ArrayList < Automaton > ( ) ; while ( min -- > 0 ) as . add ( this ) ; a = concatenate ( as ) ; } if ( max == 0 ) return a ; Automaton d = clone ( ) ; while ( -- max > 0 ) { Automaton c = clone ( ) ; for ( State p : c . getAcceptStates ( ) ) p . addEpsilon ( d . initial ) ; d = c ; } for ( State p : a . getAcceptStates ( ) ) p . addEpsilon ( d . initial ) ; a . deterministic = false ; a . checkMinimizeAlways ( ) ; return a ; }
va	2	public static ByteArrayInputStream getResourceAsStream ( String path ) throws IOException { InputStream is = Thread . currentThread ( ) . getContextClassLoader ( ) . getResourceAsStream ( path ) ; if ( is == null ) throw new FileNotFoundException ( "Resource not found: " + path ) ; ByteArrayOutputStream baos = new ByteArrayOutputStream ( 512 ) ; try { int b = - 1 ; while ( ( b = is . read ( ) ) != - 1 ) baos . write ( b ) ; } finally { is . close ( ) ; } return new ByteArrayInputStream ( baos . toByteArray ( ) ) ; }
va	6	public void paintComponent ( Graphics g ) { super . paintComponent ( g ) ; if ( dimensions != null ) { dimensions . setPanelHeight ( this . getHeight ( ) ) ; dimensions . setPanelWidth ( this . getWidth ( ) ) ; updateVTM ( ) ; } Graphics2D g2d = ( Graphics2D ) g ; AffineTransform saveAT = g2d . getTransform ( ) ; if ( theVTM != null ) { g2d . transform ( theVTM ) ; } else { if ( Game . debug ) { System . out . println ( "No VTM yet" ) ; } } if ( gameWorld != null ) { Iterator < GameObject > iter = gameWorld . iterator ( ) ; GameObject go ; while ( iter . hasNext ( ) ) { go = iter . next ( ) ; if ( go != null ) { go . draw ( g ) ; } } } g2d . setTransform ( saveAT ) ; }
va	3	public static void uniformCrossoverForPeriodAssignment ( Individual child1 , Individual child2 , Individual parent1 , Individual parent2 , ProblemInstance problemInstance ) { int coin ; int client ; Individual temp1 , temp2 ; for ( client = 0 ; client < problemInstance . customerCount ; client ++ ) { coin = Utility . randomIntInclusive ( 1 ) ; if ( coin == 0 ) { temp1 = child1 ; temp2 = child2 ; } else { temp1 = child2 ; temp2 = child1 ; } temp1 . visitCombination [ client ] = parent1 . visitCombination [ client ] ; temp2 . visitCombination [ client ] = parent2 . visitCombination [ client ] ; for ( int period = 0 ; period < problemInstance . periodCount ; period ++ ) { temp1 . periodAssignment [ period ] [ client ] = parent1 . periodAssignment [ period ] [ client ] ; temp2 . periodAssignment [ period ] [ client ] = parent2 . periodAssignment [ period ] [ client ] ; } } }
va	6	public static boolean isMainDrive ( File f ) { String filePath ; try { filePath = f . getCanonicalPath ( ) ; } catch ( IOException ex ) { filePath = f . toString ( ) ; } if ( mainDrive == null ) { String sysDrive = System . getenv ( "SystemDrive" ) ; if ( sysDrive != null ) { if ( sysDrive . endsWith ( File . separator ) == false ) { sysDrive = sysDrive + File . separator ; } mainDrive = new File ( sysDrive ) ; } else { mainDrive = new File ( getDriveBegin ( getFileSystem ( ) . getHomeFolder ( ) ) ) ; } } String mainPath ; try { mainPath = mainDrive . getCanonicalPath ( ) ; } catch ( IOException ex ) { mainPath = mainDrive . toString ( ) ; } if ( filePath . equals ( mainPath ) ) { return true ; } return false ; }
va	4	@ Override public void update ( ) { for ( Dish tmp : dishs ) { if ( storage . avaiable ( tmp ) ) { if ( ! availableDishs . contains ( tmp ) ) availableDishs . add ( tmp ) ; } else { if ( availableDishs . contains ( tmp ) ) availableDishs . remove ( tmp ) ; } } }
va	0	public BoardInitException ( Throwable e ) { super ( e ) ; }
va	1	public void setEventHandlers ( final Set < EventHandler < ? >> eventHandlers ) { this . eventHandlers = eventHandlers ; }
va	4	public static String toString ( JSONArray names , JSONArray ja ) throws JSONException { if ( names == null || names . length ( ) == 0 ) { return null ; } StringBuffer sb = new StringBuffer ( ) ; for ( int i = 0 ; i < ja . length ( ) ; i += 1 ) { JSONObject jo = ja . optJSONObject ( i ) ; if ( jo != null ) { sb . append ( rowToString ( jo . toJSONArray ( names ) ) ) ; } } return sb . toString ( ) ; }
va	3	public JSONObject accumulate ( String key , Object value ) throws JSONException { testValidity ( value ) ; Object object = this . opt ( key ) ; if ( object == null ) { this . put ( key , value instanceof JSONArray ? new JSONArray ( ) . put ( value ) : value ) ; } else if ( object instanceof JSONArray ) { ( ( JSONArray ) object ) . put ( value ) ; } else { this . put ( key , new JSONArray ( ) . put ( object ) . put ( value ) ) ; } return this ; }
va	1	public Setting < ? > getDefaultSetting ( ) { return fallbackSetting ; }
va	7	private static boolean test6_1 ( ) throws FileNotFoundException { String input = "new\n" + "pick up key\n" + "lock cell door\n" + "lock cell door with key\n" + "open door\n" + "open cell door\n" + "go through door\n" + "unlock cell door\n" + "wait\n" + "unlock cell door with key\n" + "open door\n" + "go through cell door\n" + "quit\n" + "yes\n" ; HashMap < Integer , String > output = new HashMap < Integer , String > ( ) ; boolean passed = true ; try { in = new ByteArrayInputStream ( input . getBytes ( ) ) ; System . setIn ( in ) ; out = new PrintStream ( "testing.txt" ) ; System . setOut ( out ) ; Game . main ( null ) ; } catch ( ExitException se ) { } catch ( Exception e ) { System . setOut ( stdout ) ; System . out . println ( "Error: " ) ; e . printStackTrace ( ) ; passed = false ; } finally { System . setOut ( stdout ) ; @ SuppressWarnings ( "resource" ) Scanner sc = new Scanner ( new File ( "testing.txt" ) ) ; ArrayList < String > testOutput = new ArrayList < String > ( ) ; while ( sc . hasNextLine ( ) ) { testOutput . add ( sc . nextLine ( ) ) ; } output . put ( testOutput . size ( ) - 36 , ">> You need to use a key to lock this cell door." ) ; output . put ( testOutput . size ( ) - 34 , ">> You lock the cell door." ) ; output . put ( testOutput . size ( ) - 32 , ">> The door is locked." ) ; output . put ( testOutput . size ( ) - 30 , ">> The door is locked." ) ; output . put ( testOutput . size ( ) - 28 , ">> The cell door is locked." ) ; output . put ( testOutput . size ( ) - 26 , ">> You need to use a key to unlock the cell door." ) ; output . put ( testOutput . size ( ) - 22 , ">> You unlock the cell door." ) ; output . put ( testOutput . size ( ) - 20 , ">> The door swings open." ) ; output . put ( testOutput . size ( ) - 18 , ">> You walk through the cell door." ) ; output . put ( testOutput . size ( ) - 17 , "A lone torch flickers next to you  and the hallway stretches off to darkness to the north and south." ) ; output . put ( testOutput . size ( ) - 16 , "In the wall next to you is a cell door." ) ; if ( passed ) { for ( Map . Entry < Integer , String > entry : output . entrySet ( ) ) { if ( ! testOutput . get ( entry . getKey ( ) ) . equals ( entry . getValue ( ) ) ) { passed = false ; System . out . println ( "test6 failed: Line " + entry . getKey ( ) ) ; System . out . println ( "\tExpected: " + entry . getValue ( ) ) ; System . out . println ( "\tReceived: " + testOutput . get ( entry . getKey ( ) ) ) ; } } if ( passed ) { return true ; } } else { System . out . println ( "test6 failed: error" ) ; } } return false ; }
va	8	public boolean writeFormatDoc ( ) { Preferences xsdPrefs = MarsPreferences . getMarsPrefs ( ) ; String strXSDFileDir = xsdPrefs . get ( "mars.dir.XSD" , System . getProperty ( "user.dir" ) ) ; File fXSD = new File ( strXSDFileDir ) ; Schema sFD ; DocumentBuilderFactory domFactory = DocumentBuilderFactory . newInstance ( ) ; SchemaFactory xsdFactory = SchemaFactory . newInstance ( XMLConstants . W3C_XML_SCHEMA_NS_URI ) ; try { sFD = xsdFactory . newSchema ( fXSD ) ; } catch ( Exception x ) { log . finest ( "An error occurred while trying to open the FormatDoc schema" ) ; log . throwing ( parentClassName , "writeFormatDoc" , x ) ; return false ; } if ( sFD != null ) { domFactory . setSchema ( sFD ) ; domFactory . setValidating ( true ) ; try { DocumentBuilder docBuilder = domFactory . newDocumentBuilder ( ) ; docFD = docBuilder . newDocument ( ) ; writeContents ( ) ; TransformerFactory xformFactory = TransformerFactory . newInstance ( ) ; Transformer xFormer = xformFactory . newTransformer ( ) ; FileOutputStream fosFDXML ; if ( sSystem . endsWith ( ".fd.xml" ) ) { fosFDXML = new FileOutputStream ( "Out " + sSystem ) ; } else { fosFDXML = new FileOutputStream ( "Out " + sSystem + ".fd.xml" ) ; } xFormer . transform ( new DOMSource ( docFD ) , new StreamResult ( fosFDXML ) ) ; fosFDXML . flush ( ) ; fosFDXML . close ( ) ; } catch ( TransformerConfigurationException tcX ) { log . warning ( "Transformer Configuration Exception occurred while trying to write the FormatDoc to disk." ) ; log . throwing ( parentClassName , "writeFormatDoc()" , tcX ) ; } catch ( TransformerException tX ) { log . warning ( "Transformer Exception occurred while trying to write the FormatDoc to disk." ) ; log . throwing ( parentClassName , "writeFormatDoc()" , tX ) ; } catch ( ParserConfigurationException pcX ) { log . warning ( "Parser Configuration Exception occurred while trying to work with the document" ) ; log . throwing ( parentClassName , "writeFormatDoc()" , pcX ) ; } catch ( IOException ioX ) { log . warning ( "An IO error was thrown while trying to write to disk." ) ; log . throwing ( parentClassName , "writeFormatDoc()" , ioX ) ; } catch ( Exception x ) { log . warning ( "General exception caught." ) ; log . throwing ( parentClassName , "writeFormatDoc()" , x ) ; } } else { log . severe ( "The schema for validating FormatDoc XML was null yet no errors were thrown." ) ; return false ; } log . finest ( "Created FormatDoc with no problems" ) ; return true ; }
va	5	public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; char grade = in . next ( ) . charAt ( 0 ) ; switch ( grade ) { case A : case B : case C : System . out . println ( "Passes" ) ; break ; case D : case F : System . out . println ( "Fail" ) ; break ; default : System . out . println ( "Invalod" ) ; break ; } }
va	1	public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; System . out . println ( "Enter the value of n" ) ; int n = sc . nextInt ( ) ; System . out . println ( "Enter " + n + " values one by one" ) ; int inputArray [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) inputArray [ i ] = sc . nextInt ( ) ; System . out . println ( "Minimum jumps required to reach the end is : " + minJumps ( inputArray ) ) ; }
va	1	public void upgradeDomain ( String domainName ) throws CommandException { int code = new UpgradeDomainCommand ( environment , domainName ) . execute ( ) ; if ( code != 0 ) { throw new CommandException ( "Could not upgrade domain" ) ; } }
va	5	public E remove ( int index ) { assert ( index >= 0 && index < size ( ) ) ; temp = head ; if ( index == 0 ) { E elem = head . element ; head = head . next ; counter -- ; return elem ; } else if ( index == size ( ) || index == size ( ) - 1 ) { E elem = tail . element ; tail = tail . previous ; tail . next = temp ; counter -- ; return elem ; } for ( int i = 0 ; i < index - 1 ; i ++ ) temp = temp . next ; Node two = temp . next ; temp . next = two . next ; E elem = two . element ; two = null ; counter -- ; return elem ; }
va	1	public static JSONException typeMismatch ( Object indexOrName , Object actual , String requiredType ) throws JSONException { if ( actual == null ) { throw new JSONException ( "Value at " + indexOrName + " is null." ) ; } else { throw new JSONException ( "Value " + actual + " at " + indexOrName + " of type " + actual . getClass ( ) . getName ( ) + " cannot be converted to " + requiredType ) ; } }
va	2	@ Override public void update ( Observable o , Object arg ) { EventEnum event = ( EventEnum ) arg ; if ( event == EventEnum . CONNECTED ) { this . ConnectMenuItem . setEnabled ( false ) ; this . disconnectMenuItem . setEnabled ( true ) ; } else if ( event == EventEnum . DISCONNECT ) { this . ConnectMenuItem . setEnabled ( true ) ; this . disconnectMenuItem . setEnabled ( false ) ; } this . panel . update ( o , arg ) ; }
va	2	@ Override public Object execute ( HttpServletRequest request , HttpServletResponse response ) throws Exception { Contexto oContexto = ( Contexto ) request . getAttribute ( "contexto" ) ; oContexto . setVista ( "jsp/backlog/form.jsp" ) ; BacklogBean oBacklogBean ; BacklogDao oBacklogDao ; oBacklogBean = new BacklogBean ( ) ; BacklogParam oBacklog = new BacklogParam ( request ) ; oBacklogBean = oBacklog . loadId ( oBacklogBean ) ; oBacklogDao = new BacklogDao ( oContexto . getEnumTipoConexion ( ) ) ; try { oBacklogBean = oBacklogDao . get ( oBacklogBean ) ; } catch ( Exception e ) { throw new ServletException ( "BacklogController: Update Error: Phase 1: " + e . getMessage ( ) ) ; } try { oBacklogBean = oBacklog . load ( oBacklogBean ) ; } catch ( NumberFormatException e ) { oContexto . setVista ( "jsp/mensaje.jsp" ) ; return "Tipo de dato incorrecto en uno de los campos del formulario" ; } return oBacklogBean ; }
va	9	public void unknownWordBootstrappingPostprocessing ( DataHolder dataholderHandler ) { Set < String > POSTags = new HashSet < String > ( ) ; POSTags . add ( "p" ) ; POSTags . add ( "s" ) ; Set < String > nouns = dataholderHandler . getWordsFromWordPOSByPOSs ( POSTags ) ; Set < String > boundaries = new HashSet < String > ( ) ; Set < String > words = dataholderHandler . getWordsFromUnknownWord ( "^.*_.*$" , true , "^unknown$" , true ) ; Iterator < String > wordIter = words . iterator ( ) ; String pattern = "_(" + StringUtils . join ( nouns , "|" ) + ")$" ; while ( wordIter . hasNext ( ) ) { String word = wordIter . next ( ) ; Pattern p1 = Pattern . compile ( "^[a-zA-Z0-9_-]+$" ) ; Matcher m1 = p1 . matcher ( word ) ; Pattern p2 = Pattern . compile ( pattern , Pattern . CASE_INSENSITIVE ) ; Matcher m2 = p2 . matcher ( word ) ; if ( m1 . matches ( ) && ( ! m2 . matches ( ) ) ) { if ( ! StringUtility . createMatcher ( word , "\\b(" + this . myLearnerUtility . getConstant ( ) . FORBIDDEN + ")\\b" ) . find ( ) ) { boundaries . add ( word ) ; } dataholderHandler . updateDataHolder ( word , "b" , "" , "wordpos" , 1 ) ; } } if ( boundaries . size ( ) > 0 ) { Iterator < SentenceStructure > iter = dataholderHandler . getSentenceHolderIterator ( ) ; while ( iter . hasNext ( ) ) { SentenceStructure sentenceItem = iter . next ( ) ; String tag = sentenceItem . getTag ( ) ; String sentence = sentenceItem . getSentence ( ) ; int sentenceID = sentenceItem . getID ( ) ; if ( ( ! ( StringUtils . equals ( tag , "ignore" ) ) || ( tag == null ) ) && ( StringUtility . createMatcher ( sentence , "(^| )(" + StringUtils . join ( boundaries , "|" ) + ") " ) . find ( ) ) ) { KnownTagCollection tags = new KnownTagCollection ( null , null , null , boundaries , null , null ) ; sentence = this . myLearnerUtility . annotateSentence ( sentence , tags , dataholderHandler . getBMSWords ( ) ) ; SentenceStructure updatedSentence = dataholderHandler . getSentence ( sentenceID ) ; updatedSentence . setSentence ( sentence ) ; } } } }
va	6	@ Override protected HashEntryPosition findEntry ( K key ) throws InvalidKeyException { int avail = - 1 ; checkKey ( key ) ; int i = hashValue ( key ) ; final int j = i ; do { Entry < K , V > e = bucket [ i ] ; if ( e == null ) { if ( avail < 0 ) { avail = i ; } break ; } else if ( key . equals ( bucket [ i ] . getKey ( ) ) ) { return new AbstractHashTableMap . HashEntryPosition ( i , AbstractHashTableMap . OperationType . found ) ; } else if ( bucket [ i ] == AVAILABLE ) { if ( avail < 0 ) { avail = i ; } } i = ( i + 1 ) % capacity ; } while ( i != j ) ; return new AbstractHashTableMap . HashEntryPosition ( avail , AbstractHashTableMap . OperationType . notFound ) ; }
va	5	@ Override public boolean equals ( Object object ) { if ( ! ( object instanceof Location ) ) { return false ; } Location other = ( Location ) object ; if ( ( this . id == null && other . id != null ) || ( this . id != null && ! this . id . equals ( other . id ) ) ) { return false ; } return true ; }
va	7	public boolean canImport ( TransferHandler . TransferSupport support ) { if ( ! support . isDrop ( ) ) { return false ; } support . setShowDropLocation ( true ) ; if ( ! support . isDataFlavorSupported ( nodesFlavor ) ) { return false ; } JTree . DropLocation dl = ( JTree . DropLocation ) support . getDropLocation ( ) ; JTree tree = ( JTree ) support . getComponent ( ) ; int dropRow = tree . getRowForPath ( dl . getPath ( ) ) ; int [ ] selRows = tree . getSelectionRows ( ) ; for ( int i = 0 ; i < selRows . length ; i ++ ) { if ( selRows [ i ] == dropRow ) { return false ; } } int action = support . getDropAction ( ) ; if ( action == MOVE ) { return haveCompleteNode ( tree ) ; } TreePath dest = dl . getPath ( ) ; JSONObjectTreeNode target = ( JSONObjectTreeNode ) dest . getLastPathComponent ( ) ; TreePath path = tree . getPathForRow ( selRows [ 0 ] ) ; JSONObjectTreeNode firstNode = ( JSONObjectTreeNode ) path . getLastPathComponent ( ) ; if ( firstNode . getChildCount ( ) > 0 && target . getLevel ( ) < firstNode . getLevel ( ) ) { return false ; } return true ; }
va	4	public static void main ( String [ ] args ) { List < Thread > threads = new ArrayList < Thread > ( ) ; for ( int i = 0 ; i < 500 ; i ++ ) { Runnable task = new MyRunnable ( 10000000 + i ) ; Thread worker = new Thread ( task ) ; worker . setName ( String . valueOf ( i ) ) ; worker . start ( ) ; threads . add ( worker ) ; } int running = 0 ; do { running = 0 ; for ( Thread thread : threads ) { if ( thread . isAlive ( ) ) { running ++ ; } } System . out . println ( "We have " + running + " running threads. " ) ; } while ( running > 0 ) ; }
va	2	@ Override public double getDouble ( long i ) { if ( ptr != 0 ) { return ( double ) ( Utilities . UNSAFE . getShort ( ptr + sizeof * i ) ) ; } else { if ( isConstant ( ) ) { return ( double ) data [ 0 ] ; } else { return ( double ) data [ ( int ) i ] ; } } }
va	0	private Coords imageToPanelCoords ( Coords p ) { return new Coords ( ( p . x * scale ) + originX , ( p . y * scale ) + originY ) ; }
va	7	@ Override public void actionPerformed ( ActionEvent ae ) { switch ( ae . getActionCommand ( ) ) { case "Exit" : this . dispose ( ) ; return ; case "Connect" : client . disconnect ( ) ; client = new ChatClient ( Network . getConnectionDetails ( ) , this ) ; return ; case "Set Colours" : try { new StylePickerFrame ( settings , this ) ; } catch ( BadLocationException ex ) { Logger . getLogger ( ClientFrame . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } return ; case "Changeling Sheet" : new Changeling ( ) ; break ; case "Send" : if ( getSendText ( ) . length ( ) == 0 ) { return ; } Runnable listener = new Runnable ( ) { public void run ( ) { Network . ChatMessage chatMessage = new Network . ChatMessage ( ) ; chatMessage . text = getSendText ( ) ; client . getClient ( ) . sendTCP ( chatMessage ) ; } } ; listener . run ( ) ; sendText . setText ( "" ) ; sendText . requestFocus ( ) ; return ; default : throw new UnsupportedOperationException ( "Not supported yet." + '' + "Client Frame Action Command <" + ae . getActionCommand ( ) + ">" ) ; } }
va	2	void addEpsilon ( State to ) { if ( to . accept ) accept = true ; for ( Transition t : to . transitions ) transitions . add ( t ) ; }
va	4	@ SuppressWarnings ( "unchecked" ) private void change_names ( ) { this . t_info = new TranslationInfo ( ) ; String _spec = spec . toUpperCase ( ) . replace (   , _ ) ; t_info . getSpecsMap ( ) . put ( _spec , spec ) ; this . spec = _spec ; LinkedList < String > _nets = new LinkedList < String > ( ) ; for ( String n : nets ) { String _n = n . toUpperCase ( ) . replace (   , _ ) ; t_info . getNetsMap ( ) . put ( _n , n ) ; _nets . add ( _n ) ; } nets = _nets ; rootnet = pre_img ( rootnet , t_info . getNetsMap ( ) ) . getFirst ( ) ; HashSet < String > _elems = new HashSet < String > ( ) ; int ec = 0 ; int cc = 0 ; for ( String e : elems ) { String _e ; if ( kinds . get ( e ) . isTask ( ) ) { _e = "t" + ec ++ ; } else if ( kinds . get ( e ) . isCond ( ) ) { _e = "c" + cc ++ ; } else { throw new Error ( "Fatal error! consistency checks" + " has been performed and yet there are " + "elements that are neither task nor cond." ) ; } t_info . getElemsMap ( ) . put ( _e , e ) ; _elems . add ( _e ) ; } elems = _elems ; Map < String , String > e2e = t_info . getElemsMap ( ) ; Map < String , String > n2n = t_info . getNetsMap ( ) ; containerNet = compose ( compose ( e2e , containerNet ) , invert ( n2n ) ) ; decomposesTo = compose ( compose ( e2e , decomposesTo ) , invert ( n2n ) ) ; kinds = compose ( e2e , kinds ) ; iconds = compose ( compose ( n2n , iconds ) , invert ( e2e ) ) ; oconds = compose ( compose ( n2n , oconds ) , invert ( e2e ) ) ; joins = compose ( e2e , joins ) ; splits = compose ( e2e , splits ) ; canceledBy = compose ( compose ( e2e , canceledBy ) , invert ( e2e ) ) ; upperBounds = compose ( e2e , upperBounds ) ; lowerBounds = compose ( e2e , lowerBounds ) ; thresholds = compose ( e2e , thresholds ) ; multi_modes = compose ( e2e , multi_modes ) ; defaultFlows = compose ( compose ( e2e , defaultFlows ) , invert ( e2e ) ) ; flows = repalceInMultiMap ( invert ( e2e ) , flows ) ; flowsTr = repalceInMultiMap ( invert ( e2e ) , flowsTr ) ; cancelSets = repalceInMultiMap ( invert ( e2e ) , cancelSets ) ; }
va	2	ScheduledRunnable ( DirectoryPoller directoryPoller ) { dp = directoryPoller ; this . notifier = dp . notifier ; for ( PolledDirectory directory : dp . directories ) { pollers . add ( new Poller ( dp , directory ) ) ; } if ( dp . parallelDirectoryPollingEnabled ) { executor = Executors . newCachedThreadPool ( ) ; } else { executor = Executors . newSingleThreadExecutor ( ) ; } }
va	4	public JSONObject toJSONObject ( JSONArray names ) throws JSONException { if ( names == null || names . length ( ) == 0 || this . length ( ) == 0 ) { return null ; } JSONObject jo = new JSONObject ( ) ; for ( int i = 0 ; i < names . length ( ) ; i += 1 ) { jo . put ( names . getString ( i ) , this . opt ( i ) ) ; } return jo ; }
va	5	@ Override public boolean equals ( Object object ) { if ( ! ( object instanceof ItemPropertyValue ) ) { return false ; } ItemPropertyValue other = ( ItemPropertyValue ) object ; if ( ( this . itemPropertyValuePK == null && other . itemPropertyValuePK != null ) || ( this . itemPropertyValuePK != null && ! this . itemPropertyValuePK . equals ( other . itemPropertyValuePK ) ) ) { return false ; } return true ; }
va	7	public void write ( int bits , int width ) throws IOException { if ( bits == 0 && width == 0 ) { return ; } if ( width <= 0 || width > 32 ) { throw new IOException ( "Bad write width." ) ; } while ( width > 0 ) { int actual = width ; if ( actual > this . vacant ) { actual = this . vacant ; } this . unwritten |= ( ( bits >>> ( width - actual ) ) & ( ( 1 << actual ) - 1 ) ) << ( this . vacant - actual ) ; width -= actual ; nrBits += actual ; this . vacant -= actual ; if ( this . vacant == 0 ) { this . out . write ( this . unwritten ) ; this . unwritten = 0 ; this . vacant = 8 ; } } }
va	4	public Position getVisibleMapOffsetPosition ( Player player ) { int offsetXObject = player . x - ( int ) Math . ceil ( Realm . MAP_WIDTH / 2 ) ; int offsetYObject = player . y - ( int ) Math . ceil ( Realm . MAP_HEIGHT / 2 ) ; if ( offsetXObject < 0 ) offsetXObject = 0 ; if ( offsetYObject < 0 ) offsetYObject = 0 ; if ( offsetXObject > Realm . WORLD_WIDTH - Realm . MAP_WIDTH ) offsetXObject = Realm . WORLD_WIDTH - Realm . MAP_WIDTH ; if ( offsetYObject > Realm . WORLD_HEIGHT - Realm . MAP_HEIGHT ) offsetYObject = Realm . WORLD_HEIGHT - Realm . MAP_HEIGHT ; return new Position ( offsetXObject , offsetYObject ) ; }
va	4	public synchronized void removeItem ( int index ) { if ( index < 0 || index >= dataListModel . getSize ( ) ) return ; dataListModel . remove ( index ) ; if ( index == curIndex ) curIndex = - 1 ; if ( index >= dataListModel . getSize ( ) ) index = 0 ; nextIndex = index ; setSelectedIndex ( index ) ; }
va	4	@ Test public void inorderZero ( ) { AVLTree < Integer , Integer > b = new AVLTree < Integer , Integer > ( ) ; Iterator < Integer > i = b . iterator ( ) ; assertFalse ( "hasNext" , i . hasNext ( ) ) ; try { i . next ( ) ; fail ( IllegalStateException . class ) ; } catch ( IllegalStateException e ) { } catch ( Exception e ) { fail ( IllegalStateException . class , e ) ; } try { i . remove ( ) ; fail ( UnsupportedOperationException . class ) ; } catch ( UnsupportedOperationException e ) { } catch ( Exception e ) { fail ( UnsupportedOperationException . class , e ) ; } }
va	9	public Object unmarshall ( SerializerState state , class clazz , Object o ) throws UnmarshallException { JSONObject jso = ( JSONObject ) o ; String java_class ; try { java_class = jso . getString ( "javaClass" ) ; } catch ( JSONException e ) { throw new UnmarshallException ( "Could not read javaClass" , e ) ; } if ( java_class == null ) { throw new UnmarshallException ( "no type hint" ) ; } AbstractList al ; if ( java_class . equals ( "java.util.List" ) || java_class . equals ( "java.util.AbstractList" ) || java_class . equals ( "java.util.ArrayList" ) ) { al = new ArrayList ( ) ; } else if ( java_class . equals ( "java.util.LinkedList" ) ) { al = new LinkedList ( ) ; } else if ( java_class . equals ( "java.util.Vector" ) ) { al = new Vector ( ) ; } else { throw new UnmarshallException ( "not a List" ) ; } JSONArray jsonlist ; try { jsonlist = jso . getJSONArray ( "list" ) ; } catch ( JSONException e ) { throw new UnmarshallException ( "Could not read list: " + e . getMessage ( ) , e ) ; } if ( jsonlist == null ) { throw new UnmarshallException ( "list missing" ) ; } state . setSerialized ( o , al ) ; int i = 0 ; try { for ( ; i < jsonlist . length ( ) ; i ++ ) { al . add ( ser . unmarshall ( state , null , jsonlist . get ( i ) ) ) ; } } catch ( UnmarshallException e ) { throw new UnmarshallException ( "element " + i + " " + e . getMessage ( ) , e ) ; } catch ( JSONException e ) { throw new UnmarshallException ( "element " + i + " " + e . getMessage ( ) , e ) ; } return al ; }
va	1	public Trend ( JSONObject json ) throws JSONException { this . name = json . getString ( "name" ) ; if ( ! json . isNull ( "query" ) ) { this . query = json . getString ( "query" ) ; } this . amount = json . getLong ( "amount" ) ; this . delta = json . getLong ( "delta" ) ; }
va	0	public ParticipantTableModel ( ArrayList < Participant > participantList ) { this . participantList = participantList ; lastRow = new SingleParticipant ( ) ; }
va	0	public void setAavatr ( int avatar ) { this . avatar = avatar ; }
va	3	private void clickedConfirm ( ) { this . setEnabled ( false ) ; Language lang1 = ( Language ) boxLang1 . getSelectedItem ( ) ; Language lang2 = ( Language ) boxLang2 . getSelectedItem ( ) ; if ( ( lang1 . getID ( ) . equals ( lang2 . getID ( ) ) ) || txtName . getText ( ) . length ( ) == 0 || txtDescription . getText ( ) . length ( ) == 0 ) { this . setEnabled ( true ) ; return ; } coach . setDict ( Dictionary . createNew ( coach . getCon ( ) , txtName . getText ( ) , txtDescription . getText ( ) , lang1 . getID ( ) , lang2 . getID ( ) ) ) ; this . dispose ( ) ; }
va	8	private void jTextFieldSearchKeyTyped ( java . awt . event . KeyEvent evt ) { char c = evt . getKeyChar ( ) ; switch ( newSelection ) { case SEARCH_TYPE_INN : if ( ! ( Character . isDigit ( c ) || ( c == KeyEvent . VK_BACK_SPACE ) || c == KeyEvent . VK_DELETE ) ) { getToolkit ( ) . beep ( ) ; evt . consume ( ) ; } break ; case SEARCH_TYPE_FIO_DATE : if ( ! ( Character . isLetter ( c ) || ( c == KeyEvent . VK_SPACE ) || c == KeyEvent . VK_BACK_SPACE ) ) { getToolkit ( ) . beep ( ) ; evt . consume ( ) ; } break ; } }
va	0	public void setListOfSpecies ( Species [ ] listOfSpecies ) { this . listOfSpecies = listOfSpecies ; }
va	1	public static void main ( String [ ] args ) { ListNode head = new ListNode ( 0 ) ; ListNode cur = null ; ListNode pre = head ; for ( int i = 1 ; i < 10 ; i ++ ) { cur = new ListNode ( i ) ; pre . next = cur ; pre = pre . next ; } pre . next = head . next ; System . out . println ( detectCycle ( head ) ) ; }
va	7	@ Override public void unmarshal ( Element fptr ) { super . unmarshal ( fptr ) ; NamedNodeMap attrs = fptr . getAttributes ( ) ; for ( int i = 0 ; i < attrs . getLength ( ) ; i ++ ) { Attr attr = ( Attr ) attrs . item ( i ) ; String name = attr . getName ( ) ; String value = attr . getNodeValue ( ) ; if ( name . equals ( "FILEID" ) ) this . fileid = value ; if ( name . equals ( "CONTENTIDS" ) ) this . contentids = MetsReader . parseIDREFAttr ( value ) ; } List < Element > children = DOMHelp . getChildElements ( fptr ) ; for ( Element child : children ) { String localName = child . getLocalName ( ) ; if ( localName . equals ( "par" ) ) { this . par = new Par ( ) ; this . par . unmarshal ( child ) ; } if ( localName . equals ( "seq" ) ) { this . seq = new Seq ( ) ; this . seq . unmarshal ( child ) ; } if ( localName . equals ( "area" ) ) { this . area = new Area ( ) ; this . area . unmarshal ( child ) ; } } }
va	4	public static boolean isAnagram ( String s , String t ) { if ( s . length ( ) != t . length ( ) ) { return false ; } int [ ] count = new int [ 26 ] ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { count [ s . charAt ( i ) - a ] ++ ; count [ t . charAt ( i ) - a ] -- ; } for ( int i : count ) { if ( i != 0 ) { return false ; } } return true ; }
va	8	public boolean isIsomorphic ( Node root1 , Node root2 ) { if ( root1 == null && root2 == null ) return true ; else if ( root1 == null || root2 == null ) return false ; else if ( root1 . key != root2 . key ) return false ; return ( isIsomorphic ( root1 . left , root2 . left ) && isIsomorphic ( root1 . right , root2 . right ) ) || ( isIsomorphic ( root1 . left , root2 . right ) && isIsomorphic ( root1 . right , root2 . left ) ) ; }
va	1	public boolean isHigh ( ) { if ( state == NetState . HIGH ) { return true ; } else { return false ; } }
va	7	@ Override public void parseValueFromString ( String rawString ) throws ParseException { rawString = rawString . toLowerCase ( ) ; final boolean isTrue = "t" . equals ( rawString ) || "true" . equals ( rawString ) || "y" . equals ( rawString ) ; if ( ! ( isTrue || "f" . equals ( rawString ) || "false" . equals ( rawString ) || "n" . equals ( rawString ) ) ) { throw new ParseException ( "The given string is no boolean value" , 0 ) ; } this . model . setValue ( isTrue ? true : false ) ; }
