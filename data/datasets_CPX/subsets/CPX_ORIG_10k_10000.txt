te	1	public boolean isConnected ( ) { return hasOAuth ( ) && hasAccessToken ( ) ; }
te	9	public void execute ( String [ ] args ) { if ( args . length == 0 ) { console . error ( "unable to move (no name provided)." ) ; return ; } else if ( args . length == 1 ) { console . error ( "unable to move (expected two arguments)." ) ; return ; } else if ( args . length > 2 ) { console . error ( "unable to move (expected two arguments)." ) ; return ; } String name = StringUtil . applyTitleCase ( args [ 0 ] ) ; SKList list = manager . copyList ( ) ; int old_rank = list . getIndex ( name ) + 1 ; if ( old_rank == 0 ) { console . error ( playerNotFound ( name ) ) ; return ; } int new_rank ; try { new_rank = Integer . parseInt ( args [ 1 ] ) ; } catch ( NumberFormatException e ) { console . error ( "cannot move'" + name + "' ('" + args [ 1 ] + "' is not a valid rank)." ) ; return ; } if ( new_rank < 1 ) { console . error ( "cannot move'" + name + "' (rank must be positive)." ) ; return ; } if ( old_rank == new_rank ) return ; if ( new_rank > list . size ( ) ) { console . error ( "cannot move'" + name + "' (rank " + new_rank + " is too high)." ) ; return ; } if ( ! confirm ( name , old_rank , new_rank ) ) return ; Player player = list . get ( old_rank - 1 ) ; if ( new_rank < old_rank ) list . add ( new_rank - 1 , player . clone ( ) ) ; else list . add ( new_rank , player . clone ( ) ) ; list . remove ( player ) ; entry = console . event ( playerMoved ( name , old_rank , list . getIndex ( name ) + 1 ) ) ; manager . setList ( list , new EventUndoListener ( console , entry ) ) ; }
te	8	public boolean equals ( Object o ) { if ( this == o ) return true ; if ( ! ( o instanceof LabeledConstituent ) ) return false ; final LabeledConstituent < ? > labeledConstituent = ( LabeledConstituent < ? > ) o ; if ( end != labeledConstituent . end ) return false ; if ( start != labeledConstituent . start ) return false ; if ( label != null ? ! label . equals ( labeledConstituent . label ) : labeledConstituent . label != null ) return false ; return true ; }
te	9	public void fillPatient ( PatientInfo patient , int patientId ) { try { DB . db . openConnection ( ) ; ResultSet rs = DB . db . patient ( patientId ) ; while ( rs . next ( ) ) { patient . setId ( patientId ) ; patient . setAddress ( rs . getString ( "address" ) ) ; patient . setAnam ( rs . getString ( "anamnesis" ) ) ; patient . setBdate ( rs . getDate ( "bdate" ) ) ; patient . setDiagn ( rs . getString ( "diagnosis" ) ) ; patient . setEmail ( rs . getString ( "email" ) ) ; patient . setFname ( rs . getString ( "fname" ) ) ; patient . setInsurrance ( rs . getString ( "insurrance" ) ) ; patient . setLname ( rs . getString ( "lname" ) ) ; patient . setMedcard ( rs . getString ( "medcard" ) ) ; patient . setPhone ( rs . getString ( "phone" ) ) ; patient . setSsn ( rs . getString ( "ssn" ) ) ; patient . setZip ( rs . getString ( "zip" ) ) ; String tempgh = rs . getString ( "gmedhistory" ) ; if ( tempgh != null ) { tempgh . trim ( ) ; tempgh = tempgh . replaceAll ( "[|]" , "<br />" ) ; patient . setGmedhistory ( tempgh ) ; } String tempil = rs . getString ( "illnesshistory" ) ; if ( tempil != null ) { tempil . trim ( ) ; tempil = tempil . replaceAll ( "[|]" , "<br />" ) ; patient . setIllnesshistory ( tempil ) ; } String tempsp = rs . getString ( "medspechistory" ) ; if ( tempsp != null ) { tempsp = tempsp . trim ( ) ; tempsp = tempsp . replaceAll ( "[|]" , "<br />" ) ; patient . setMedspechistory ( tempsp ) ; } ResultSet res = DB . db . prescription ( ) ; int currPrescr = - 1 ; while ( res . next ( ) ) { if ( res . getInt ( "patientid" ) == patientId && res . getInt ( "id" ) > currPrescr ) { currPrescr = res . getInt ( "id" ) ; } } if ( currPrescr != - 1 ) { res = DB . db . prescription ( currPrescr ) ; String [ ] drugId = null ; Vector < String > drug = new Vector < String > ( ) ; while ( res . next ( ) ) { String t = res . getString ( "prescription" ) ; t . trim ( ) ; t = t . replaceAll ( "[\n]" , "<br />" ) ; patient . setPrescriptions ( t ) ; String tmp = res . getString ( "drugid" ) ; tmp . trim ( ) ; tmp = tmp . substring ( 1 , tmp . length ( ) - 1 ) ; drugId = tmp . split ( "[|]" ) ; } for ( int i = 0 ; i < drugId . length ; i ++ ) { res = DB . db . drugs ( Integer . parseInt ( drugId [ i ] ) ) ; while ( res . next ( ) ) { drug . add ( "<b>" + res . getString ( "name" ) + " </b>/ " + res . getString ( "dose" ) ) ; } } patient . setDrugs ( drug ) ; } DB . db . close ( ) ; } } catch ( SQLException ex ) { Logger . getLogger ( Func . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; DB . db . close ( ) ; } }
te	2	public OutputStream openOutputStream ( String dstFilePath , long outputLength ) throws IOException { File srcF = new File ( rootPath . getAbsoluteFile ( ) , dstFilePath ) ; if ( ! srcF . exists ( ) ) { try { srcF . createNewFile ( ) ; } catch ( Exception e ) { throw new IOException ( e ) ; } } return new FileOutputStream ( srcF ) ; }
te	4	public static MyPoint intersect ( float lOnePOneX , float lOnePOneY , float lOnePTwoX , float lOnePTwoY , float lTwoPOneX , float lTwoPOneY , float lTwoPTwoX , float lTwoPTwoY ) { float outPX , outPY ; float lOneSlopeX , lOneSlopeY , lTwoSlopeX , lTwoSlopeY ; lOneSlopeX = lOnePTwoX - lOnePOneX ; lOneSlopeY = lOnePTwoY - lOnePOneY ; lTwoSlopeX = lTwoPTwoX - lTwoPOneX ; lTwoSlopeY = lTwoPTwoY - lTwoPOneY ; float s , t ; float d = ( - lTwoSlopeX * lOneSlopeY + lOneSlopeX * lTwoSlopeY ) ; s = ( - lOneSlopeY * ( lOnePOneX - lTwoPOneX ) + lOneSlopeX * ( lOnePOneY - lTwoPOneY ) ) / d ; t = ( lTwoSlopeX * ( lOnePOneY - lTwoPOneY ) - lTwoSlopeY * ( lOnePOneX - lTwoPOneX ) ) / d ; if ( s >= 0 && s <= 1 && t >= 0 && t <= 1 ) { outPX = lOnePOneX + ( t * lOneSlopeX ) ; outPY = lOnePOneY + ( t * lOneSlopeY ) ; return new MyPoint ( outPX , outPY ) ; } return null ; }
te	8	public boolean closeFile ( ) { if ( current_file == null && dirty ) { int response = JOptionPane . showConfirmDialog ( this , "Save changes to '" + getListManager ( ) . getListTitle ( ) + "' before closing?" , "Save File" , JOptionPane . YES_NO_CANCEL_OPTION ) ; if ( response == JOptionPane . CANCEL_OPTION ) return false ; if ( response == JOptionPane . YES_OPTION ) return saveas ( ) ; } else if ( current_file != null && dirty ) { int response = JOptionPane . showConfirmDialog ( this , "Save changes to '" + current_file . getName ( ) + "' before closing?" , "Save File" , JOptionPane . YES_NO_CANCEL_OPTION ) ; if ( response == JOptionPane . CANCEL_OPTION ) return false ; if ( response == JOptionPane . YES_OPTION ) return save ( ) ; } return true ; }
te	4	public static Set < Integer > encIndexes ( int K , Tuple tuple ) { Set < Integer > indexes = new TreeSet < Integer > ( ) ; int Ki = SystematicIndices . getKIndex ( K ) ; int S = SystematicIndices . S ( Ki ) ; int H = SystematicIndices . H ( Ki ) ; int W = SystematicIndices . W ( Ki ) ; long L = K + S + H ; long P = L - W ; long P1 = Utilities . ceilPrime ( P ) ; long d = tuple . getD ( ) ; long a = tuple . getA ( ) ; long b = tuple . getB ( ) ; long d1 = tuple . getD1 ( ) ; long a1 = tuple . getA1 ( ) ; long b1 = tuple . getB1 ( ) ; indexes . add ( ( int ) b ) ; for ( long j = 0 ; j < d ; j ++ ) { b = ( b + a ) % W ; indexes . add ( ( int ) b ) ; } while ( b1 >= P ) { b1 = ( b1 + a1 ) % P1 ; } indexes . add ( ( int ) ( W + b1 ) ) ; for ( long j = 1 ; j < d1 ; j ++ ) { do b1 = ( b1 + a1 ) % P1 ; while ( b1 >= P ) ; indexes . add ( ( int ) ( W + b1 ) ) ; } return indexes ; }
te	7	public Object classify ( double [ ] input ) { for ( int i = 0 ; i < input . length ; i ++ ) { this . input . get ( i ) . input ( input [ i ] ) ; } for ( Neuron n : this . input ) n . propagate ( ) ; for ( List < Neuron > list : this . hidden ) { for ( Neuron n : list ) n . propagate ( ) ; } for ( Neuron n : this . output ) n . propagate ( ) ; double [ ] r = new double [ this . output . size ( ) ] ; int highestIndex = 0 ; double highestVal = double . MIN_VALUE ; for ( int i = 0 ; i < r . length ; i ++ ) { r [ i ] = this . output . get ( i ) . getLatestOutput ( ) ; if ( r [ i ] > highestVal ) { highestIndex = i ; highestVal = r [ i ] ; } } return this . classes [ highestIndex ] ; }
te	6	private void removeImplementedMethods ( final class < ? > impl , final List < Method > toImplement ) { for ( final Method implemented : impl . getDeclaredMethods ( ) ) { final String mName = implemented . getName ( ) ; final class < ? > [ ] mArgs = implemented . getParameterTypes ( ) ; final Iterator < Method > it = toImplement . iterator ( ) ; while ( it . hasNext ( ) ) { final Method absMethod = it . next ( ) ; if ( absMethod . getName ( ) . equals ( mName ) && Arrays . deepEquals ( absMethod . getParameterTypes ( ) , mArgs ) ) { it . remove ( ) ; break ; } } } }
te	1	public Axis < T > axesDefaultsInstance ( ) { if ( axesDefaults == null ) { axesDefaults = new Axis < T > ( ) ; } return axesDefaults ; }
te	0	public void setCreatedAt ( Date createdAt ) { this . createdAt = createdAt ; }
te	7	private static void processCrossLayerMechanism ( RequirementGraph up_req_model , RequirementGraph down_req_model , String result ) throws ScriptException { result = result . replaceAll ( "support_sec_mechanism\\(" , "" ) ; result = result . replaceAll ( "\\)" , "" ) ; String [ ] sg = result . split ( " " ) ; if ( sg . length == 6 ) { RequirementElement supported_mechanism = ( RequirementElement ) up_req_model . findElementByFormalName ( sg [ 4 ] ) ; SecurityGoal refined_sec_goal = ( SecurityGoal ) up_req_model . findElementByFormalName ( sg [ 5 ] ) ; String layer = null ; if ( supported_mechanism . getLayer ( ) . equals ( InfoEnum . Layer . BUSINESS . name ( ) ) ) { layer = InfoEnum . Layer . APPLICATION . name ( ) ; } else if ( supported_mechanism . getLayer ( ) . equals ( InfoEnum . Layer . APPLICATION . name ( ) ) ) { layer = InfoEnum . Layer . PHYSICAL . name ( ) ; } else { CommandPanel . logger . severe ( "Layer processing error" ) ; } Element asset = down_req_model . findElementById ( sg [ 2 ] ) ; if ( asset == null ) { CommandPanel . logger . severe ( "Asset error" ) ; } Element re = down_req_model . findElementById ( sg [ 3 ] ) ; SecurityGoal new_sg = null ; String new_sg_id , support_link_id ; if ( re != null && layer != null ) { new_sg = new SecurityGoal ( sg [ 0 ] , sg [ 1 ] , sg [ 2 ] , re , InfoEnum . RequirementElementType . SECURITY_GOAL . name ( ) , layer ) ; new_sg . setName ( ( new_sg . getImportance ( ) + " " + new_sg . getSecurityAttribute ( ) + " [" + asset . getName ( ) + "  " + new_sg . getInterval ( ) . getName ( ) + "]" ) . replaceAll ( "\\_" , " " ) ) ; new_sg . owner_text = refined_sec_goal . owner_text ; if ( refined_sec_goal . owner != null ) { refined_sec_goal . owner . getOwnedElement ( ) . add ( new_sg ) ; new_sg . owner = refined_sec_goal . owner ; } } else { CommandPanel . logger . severe ( "Security goal cannot be created: interval id-->" + sg [ 3 ] ) ; } new_sg_id = AppleScript . drawRequirementElement ( new_sg , supported_mechanism , "down" ) ; new_sg . setId ( new_sg_id ) ; AppleScript . addUserData2 ( "Model" , new_sg . getLayer ( ) , new_sg , new_sg . owner_text ) ; RequirementLink support_link = new RequirementLink ( InfoEnum . RequirementLinkType . SUPPORT . name ( ) , new_sg , supported_mechanism ) ; support_link_id = AppleScript . drawRequirementLink ( support_link , InfoEnum . CROSS_LAYERS ) ; support_link . setId ( support_link_id ) ; down_req_model . getElements ( ) . add ( new_sg ) ; down_req_model . getLinks ( ) . add ( support_link ) ; } else { CommandPanel . logger . severe ( "Parsing mechanism support has problems." ) ; } }
te	3	private static void invokeAndWait ( ExecutorService executor , List < Worker > workers ) { try { List < Future < void >> futures = executor . invokeAll ( workers ) ; for ( Future < void > fu : futures ) { fu . get ( ) ; } } catch ( InterruptedException e ) { throw new RuntimeException ( e ) ; } catch ( ExecutionException e ) { throw new RuntimeException ( e ) ; } }
te	1	public static double slope ( double x1 , double y1 , double x2 , double y2 ) throws UndefinedSlopeException { if ( x1 != x2 ) return ( y2 - y1 ) / ( x2 - x1 ) ; throw new UndefinedSlopeException ( "Slope is undefined" ) ; }
te	7	public int compareTo ( confirm_args other ) { if ( ! getClass ( ) . equals ( other . getClass ( ) ) ) { return getClass ( ) . getName ( ) . compareTo ( other . getClass ( ) . getName ( ) ) ; } int lastComparison = 0 ; confirm_args typedOther = ( confirm_args ) other ; lastComparison = boolean . valueOf ( is_set_queue_name ( ) ) . compareTo ( typedOther . is_set_queue_name ( ) ) ; if ( lastComparison != 0 ) { return lastComparison ; } if ( is_set_queue_name ( ) ) { lastComparison = org . apache . thrift7 . TBaseHelper . compareTo ( this . queue_name , typedOther . queue_name ) ; if ( lastComparison != 0 ) { return lastComparison ; } } lastComparison = boolean . valueOf ( is_set_ids ( ) ) . compareTo ( typedOther . is_set_ids ( ) ) ; if ( lastComparison != 0 ) { return lastComparison ; } if ( is_set_ids ( ) ) { lastComparison = org . apache . thrift7 . TBaseHelper . compareTo ( this . ids , typedOther . ids ) ; if ( lastComparison != 0 ) { return lastComparison ; } } return 0 ; }
te	7	private static String toEscaped ( String content ) { String result = content ; if ( ( content != null ) && ( content . length ( ) > 0 ) ) { boolean modified = false ; StringBuilder stringBuilder = new StringBuilder ( content . length ( ) ) ; for ( int i = 0 , count = content . length ( ) ; i < count ; ++ i ) { String character = content . substring ( i , i + 1 ) ; int pos = ESCAPE_CHARS . indexOf ( character ) ; if ( pos > - 1 ) { stringBuilder . append ( ESCAPE_STRINGS . get ( pos ) ) ; modified = true ; } else { if ( ( character . compareTo ( UNICODE_LOW ) > - 1 ) && ( character . compareTo ( UNICODE_HIGH ) < 1 ) ) { stringBuilder . append ( character ) ; } else { stringBuilder . append ( "&#" + ( ( int ) character . charAt ( 0 ) ) + ";" ) ; modified = true ; } } } if ( modified ) { result = stringBuilder . toString ( ) ; } } return result ; }
te	5	public boolean equals ( Bgp4Update o ) { if ( this . updateType == ( ( Bgp4Update ) o ) . updateType && this . time == ( ( Bgp4Update ) o ) . time && this . peerIP . equals ( ( ( Bgp4Update ) o ) . peerIP ) && this . prefix . equals ( ( ( Bgp4Update ) o ) . prefix ) ) { if ( this instanceof Advertisement ) return this . updateAttr . equals ( o . updateAttr ) ; return true ; } return false ; }
te	3	static MyInteger pick ( Random rand , FSet < MyInteger > s ) { if ( s . isEmpty ( ) ) throw new IllegalStateException ( ) ; while ( true ) { int r = rand . nextInt ( 200 ) ; MyInteger R = new MyInteger ( r ) ; if ( s . contains ( R ) ) return R ; } }
te	4	public static void main ( String ... args ) { Console console = System . console ( ) ; if ( console == null ) { System . err . println ( "No console found" ) ; System . exit ( 0 ) ; } while ( true ) { String inputMessage = "%nEnter the RegEx: " ; String inputRegex = console . readLine ( inputMessage ) ; String input = console . readLine ( "Enter the String to search: " ) ; Pattern pattern = Pattern . compile ( inputRegex ) ; Matcher matcher = pattern . matcher ( input ) ; boolean found = false ; while ( matcher . find ( ) ) { console . format ( "Found %s starting at %d and ending at %d.%n" , matcher . group ( ) , matcher . start ( ) , matcher . end ( ) ) ; found = true ; } if ( ! found ) { System . err . println ( "No matches found!!" ) ; } } }
te	7	public Object nextValue ( ) throws JSONException { char c = nextClean ( ) ; String string ; switch ( c ) { case " : case ' : return nextString ( c ) ; case { : back ( ) ; return new JSONObject ( this ) ; case [ : back ( ) ; return new JSONArray ( this ) ; } StringBuffer sb = new StringBuffer ( ) ; while ( c >=   && " :]}/\\\"[{;=#" . indexOf ( c ) < 0 ) { sb . append ( c ) ; c = next ( ) ; } back ( ) ; string = sb . toString ( ) . trim ( ) ; if ( string . equals ( "" ) ) { throw syntaxError ( "Missing value" ) ; } return JSONObject . stringToValue ( string ) ; }
te	7	private void popolaMappa ( ) { MappaACelle = new Cella [ getLatoDellaMappa ( ) ] [ getLatoDellaMappa ( ) ] ; int i = 0 ; int j = 0 ; while ( i < getLatoDellaMappa ( ) ) { MappaACelle [ i ] [ 0 ] = new Acqua ( ) ; MappaACelle [ i ] [ ( getLatoDellaMappa ( ) - 1 ) ] = new Acqua ( ) ; i ++ ; } j = 0 ; while ( j < getLatoDellaMappa ( ) ) { MappaACelle [ 0 ] [ j ] = new Acqua ( ) ; MappaACelle [ ( getLatoDellaMappa ( ) - 1 ) ] [ j ] = new Acqua ( ) ; j ++ ; } i = 1 ; while ( i <= ( getLatoDellaMappa ( ) - 2 ) ) { j = 1 ; while ( j <= ( getLatoDellaMappa ( ) - 2 ) ) { MappaACelle [ i ] [ j ] = new Terra ( ) ; j ++ ; } i ++ ; } System . runFinalization ( ) ; System . gc ( ) ; int curAcqua = contaAcque ( ) ; while ( curAcqua < ( conteggioAcquaStatico - ConfigurationOpts . MAX_GRUPPO_ACQUA - ConfigurationOpts . MIN_GRUPPO_ACQUA + 9 ) ) { allocaAcqua ( ConfigurationOpts . MIN_GRUPPO_ACQUA + CommonUtils . getNewRandomIntValue ( ConfigurationOpts . MAX_GRUPPO_ACQUA - ConfigurationOpts . MIN_GRUPPO_ACQUA + 1 ) ) ; curAcqua = contaAcque ( ) ; } allocaAcqua ( conteggioAcquaStatico - curAcqua ) ; int curVeg = 0 ; while ( curVeg < conteggioVegetazioneStatico ) { Coord vegCoord = CommonUtils . getNewRandomCoord ( getLatoDellaMappa ( ) ) ; if ( isCellaTerra ( vegCoord ) ) { MappaACelle [ vegCoord . getX ( ) ] [ vegCoord . getY ( ) ] = new Vegetazione ( ( 150 + CommonUtils . getNewRandomIntValue ( 201 ) ) ) ; curVeg ++ ; } } spawnCarogne ( ) ; }
te	5	private void drawChess ( Graphics g ) { if ( board == null ) return ; int [ ] [ ] table = board . getTable ( ) ; for ( int row = 0 ; row < 10 ; row ++ ) { for ( int col = 0 ; col < 9 ; col ++ ) { int value = table [ row ] [ col ] ; if ( value != 0 ) { Image img = getShape ( value ) ; if ( img != null ) { int [ ] pos = convertToXY ( new ChessPosition ( row , col ) ) ; g . drawImage ( img , pos [ 0 ] - 21 , pos [ 1 ] - 21 , null ) ; } } } } }
te	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( CargarDatosEmail . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( CargarDatosEmail . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( CargarDatosEmail . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( CargarDatosEmail . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { CargarDatosEmail dialog = new CargarDatosEmail ( new javax . swing . JFrame ( ) , true ) ; dialog . addWindowListener ( new java . awt . event . WindowAdapter ( ) { @ Override public void windowClosing ( java . awt . event . WindowEvent e ) { System . exit ( 0 ) ; } } ) ; dialog . setVisible ( true ) ; } } ) ; }
te	0	@ Test public void testGetQuestionNumbers ( ) { final int questionNumber = DatabaseCheckBoxTest . insertCheckBox ( "DatabaseTestCheckBox.testGetQuestionNumbers" ) . getQuestionNumber ( ) ; final QuestionsDatabase db = new QuestionsDatabase ( DatabaseAbstractQuestionTest . TEST_DATABASE_NAME ) ; final ArrayList < Integer > questionNumbers = db . getQuestionNumbers ( ) ; assertTrue ( "No data returned." , questionNumbers . size ( ) > 0 ) ; assertTrue ( questionNumbers . contains ( questionNumber ) ) ; DatabaseCheckBoxTest . deleteCheckBox ( questionNumber ) ; }
te	5	public Vector < String > classifyIPs ( Vector < String > validIPs , String plainPath ) throws ClientProtocolException , IOException { final String verificationURL = "http://s.weibo.com/weibo/\u674E\u96EA\u5C71hakka&nodup=1&page=1" ; Vector < String > plainIPs = new Vector < String > ( ) ; String ip ; for ( int i = 0 ; i < validIPs . size ( ) ; i ++ ) { System . out . println ( "****\u5F00\u59CB\u9A8C\u8BC1\u7B2C" + ( i + 1 ) + "\u4E2AvalidIP" ) ; ip = validIPs . get ( i ) ; String html = new HTML ( ) . getHTMLbyProxy ( verificationURL , ip . split ( ":" ) [ 0 ] , Integer . parseInt ( ip . split ( ":" ) [ 1 ] ) ) ; int iReconn = 0 ; int reConnectTimes = 5 ; while ( html . equals ( "null" ) ) { if ( iReconn == ( reConnectTimes - 1 ) ) { System . out . println ( "****\u8FDE\u7EED" + reConnectTimes + "\u6B21\u94FE\u63A5\u5FAE\u64AD\u641C\u7D22\u7AD9\u70B9(http://s.weibo.com/weibo)\u5931\u8D25\uFF0C\u653E\u5F03\u6B21IP****" ) ; break ; } html = new HTML ( ) . getHTMLbyProxy ( verificationURL , ip . split ( ":" ) [ 0 ] , Integer . parseInt ( ip . split ( ":" ) [ 1 ] ) ) ; iReconn ++ ; System . out . println ( "****" + ip + "is reconnecting the" + iReconn + " time****" ) ; } if ( html . contains ( "version=2012" ) ) { plainIPs . add ( ip ) ; System . out . println ( "\u7B2C " + ( i + 1 ) + " \u4E2AvalidIP\u662F\u53EF\u7528\u7684IP(plainIP): " + ip ) ; } else { if ( html . contains ( "version=2014" ) ) { System . out . println ( "\u7B2C" + ( i + 1 ) + " \u4E2AvalidIP: " + ip + "\u53EF\u4EE5\u7528\u4E8E2014\u7248\u672C\u7684html\uFF0C\u4F46\u662F2012\u7684\u4E0D\u884C" ) ; } else { System . out . println ( "\u7B2C " + ( i + 1 ) + " \uFFFD\uFFFDvalidIP: " + ip + " \u53EF\u7528\u4E8E2012\u7684\uFF0C\u4E5F\u5C31\u662F\u53EF\u4EE5\u5728\u6B64\u8F6F\u4EF6\u4E2D\u4F7F\u7528\u76841" ) ; } } } return plainIPs ; }
te	0	public void sendClearATOCommand ( ) { sendCommand ( "Clear ATO" , Globals . requestClearATO ) ; }
te	9	public static Matrix load ( NamedInputStream nis ) throws MatrixLoaderException { logger . info ( "Loading scoring matrix..." ) ; char [ ] acids = new char [ Matrix . SIZE ] ; for ( int i = 0 ; i < Matrix . SIZE ; i ++ ) { acids [ i ] = 0 ; } float [ ] [ ] scores = new float [ Matrix . SIZE ] [ Matrix . SIZE ] ; BufferedReader reader = new BufferedReader ( new InputStreamReader ( nis . getInputStream ( ) ) ) ; String line ; try { while ( ( line = reader . readLine ( ) ) != null && line . trim ( ) . charAt ( 0 ) == COMMENT_STARTER ) ; } catch ( Exception e ) { String message = "Failed reading from input stream: " + e . getMessage ( ) ; logger . log ( Level . SEVERE , message , e ) ; throw new MatrixLoaderException ( message ) ; } StringTokenizer tokenizer ; tokenizer = new StringTokenizer ( line . trim ( ) ) ; for ( int j = 0 ; tokenizer . hasMoreTokens ( ) ; j ++ ) { acids [ j ] = tokenizer . nextToken ( ) . charAt ( 0 ) ; } try { while ( ( line = reader . readLine ( ) ) != null ) { tokenizer = new StringTokenizer ( line . trim ( ) ) ; char acid = tokenizer . nextToken ( ) . charAt ( 0 ) ; for ( int i = 0 ; i < Matrix . SIZE ; i ++ ) { if ( acids [ i ] != 0 ) { scores [ acid ] [ acids [ i ] ] = float . parseFloat ( tokenizer . nextToken ( ) ) ; } } } } catch ( Exception e ) { String message = "Failed reading from input stream: " + e . getMessage ( ) ; logger . log ( Level . SEVERE , message , e ) ; throw new MatrixLoaderException ( message ) ; } logger . info ( "Finished loading scoring matrix" ) ; return new Matrix ( nis . getName ( ) , scores ) ; }
te	7	int pack_books ( Buffer opb ) { opb . write ( 05 , 8 ) ; opb . write ( _vorbis ) ; opb . write ( books - 1 , 8 ) ; for ( int i = 0 ; i < books ; i ++ ) { if ( book_param [ i ] . pack ( opb ) != 0 ) { return ( - 1 ) ; } } opb . write ( times - 1 , 6 ) ; for ( int i = 0 ; i < times ; i ++ ) { opb . write ( time_type [ i ] , 16 ) ; FuncTime . time_P [ time_type [ i ] ] . pack ( this . time_param [ i ] , opb ) ; } opb . write ( floors - 1 , 6 ) ; for ( int i = 0 ; i < floors ; i ++ ) { opb . write ( floor_type [ i ] , 16 ) ; FuncFloor . floor_P [ floor_type [ i ] ] . pack ( floor_param [ i ] , opb ) ; } opb . write ( residues - 1 , 6 ) ; for ( int i = 0 ; i < residues ; i ++ ) { opb . write ( residue_type [ i ] , 16 ) ; FuncResidue . residue_P [ residue_type [ i ] ] . pack ( residue_param [ i ] , opb ) ; } opb . write ( maps - 1 , 6 ) ; for ( int i = 0 ; i < maps ; i ++ ) { opb . write ( map_type [ i ] , 16 ) ; FuncMapping . mapping_P [ map_type [ i ] ] . pack ( this , map_param [ i ] , opb ) ; } opb . write ( modes - 1 , 6 ) ; for ( int i = 0 ; i < modes ; i ++ ) { opb . write ( mode_param [ i ] . blockflag , 1 ) ; opb . write ( mode_param [ i ] . windowtype , 16 ) ; opb . write ( mode_param [ i ] . transformtype , 16 ) ; opb . write ( mode_param [ i ] . mapping , 8 ) ; } opb . write ( 1 , 1 ) ; return ( 0 ) ; }
te	0	public String getName ( ) { return name ; }
te	5	public AddRouteRespondInfo addRoute ( AddRouteRequestInfo addRouteRequest ) throws IOException { log . debug ( "Start method \"addRoute\"" ) ; List < String > stationsForNewRoute = addRouteRequest . getStationsForNewRoute ( ) ; Map < String , Object [ ] > newWay = addRouteRequest . getNewWay ( ) ; String delimiter = addRouteRequest . getDelimiter ( ) ; for ( String stations : newWay . keySet ( ) ) { String stationAName = stations . split ( delimiter ) [ 0 ] ; String stationBName = stations . split ( delimiter ) [ 1 ] ; Station stationA = stationDAO . loadStationByName ( stationAName ) ; Station stationB = stationDAO . loadStationByName ( stationBName ) ; Way way = new Way ( ) ; way . setStationByIdStation1 ( stationA ) ; way . setStationByIdStation2 ( stationB ) ; way . setTime ( ( Timestamp ) newWay . get ( stations ) [ 0 ] ) ; way . setPrice ( ( double ) newWay . get ( stations ) [ 1 ] ) ; if ( ! wayDAO . saveWay ( way ) ) { AddRouteRespondInfo respond = new AddRouteRespondInfo ( AddRouteRespondInfo . SERVER_ERROR_STATUS ) ; log . debug ( "Send AddRouteRespondInfo to client with SERVER_ERROR_STATUS" ) ; return respond ; } } Route route = new Route ( ) ; route . setName ( addRouteRequest . getRouteName ( ) ) ; if ( ! routeDAO . saveRoute ( route ) ) { AddRouteRespondInfo respond = new AddRouteRespondInfo ( AddRouteRespondInfo . SERVER_ERROR_STATUS ) ; log . debug ( "Send AddRouteRespondInfo to client with SERVER_ERROR_STATUS" ) ; return respond ; } List < Schedule > schedules = new ArrayList < Schedule > ( ) ; route = routeDAO . loadRoute ( route . getName ( ) ) ; for ( int i = 1 ; i < stationsForNewRoute . size ( ) ; i ++ ) { Way way = wayDAO . loadWayByStations ( stationsForNewRoute . get ( i - 1 ) , stationsForNewRoute . get ( i ) ) ; Schedule schedule = new Schedule ( ) ; schedule . setRouteByIdRoute ( route ) ; schedule . setWayByIdWay ( way ) ; schedule . setSeqNumber ( i ) ; schedules . add ( schedule ) ; if ( ! scheduleDAO . saveSchedule ( schedule ) ) { AddRouteRespondInfo respond = new AddRouteRespondInfo ( AddRouteRespondInfo . SERVER_ERROR_STATUS ) ; log . debug ( "Send AddRouteRespondInfo to client with SERVER_ERROR_STATUS" ) ; return respond ; } } AddRouteRespondInfo respond = new AddRouteRespondInfo ( AddRouteRespondInfo . OK_STATUS ) ; log . debug ( "Send AddRouteRespondInfo to client with OK_STATUS" ) ; return respond ; }
te	7	public FeatureVector createPSCFeatureVector ( DependencyInstance inst , int par , int mod , int ch , int sib ) { FeatureVector fv = new FeatureVector ( numArcFeats ) ; int [ ] posA = inst . cpostagids ; int [ ] lemma = inst . lemmaids != null ? inst . lemmaids : inst . formids ; int type = ( mod - par ) * ( mod - sib ) > 0 ? 0 : 1 ; int dir = 0 ; if ( mod < par && sib < par ) dir = 0 ; else if ( mod > par && sib > par ) dir = 1 ; else dir = 2 ; dir = ( dir << 1 ) | ( mod < ch ? 0 : 1 ) ; dir = ( dir << 1 ) | type ; dir += 2 ; int HC = posA [ par ] ; int MC = posA [ mod ] ; int CC = posA [ ch ] ; int SC = posA [ sib ] ; int HL = lemma [ par ] ; int ML = lemma [ mod ] ; int CL = lemma [ ch ] ; int SL = lemma [ sib ] ; long code = 0 ; code = createArcCodePPPP ( HC_MC_CC_SC , HC , MC , CC , SC ) ; addArcFeature ( code | type , fv ) ; addArcFeature ( code | dir , fv ) ; code = createArcCodeWPPP ( HL_MC_CC_SC , HL , MC , CC , SC ) ; addArcFeature ( code | type , fv ) ; addArcFeature ( code | dir , fv ) ; code = createArcCodeWPPP ( HC_ML_CC_SC , ML , HC , CC , SC ) ; addArcFeature ( code | type , fv ) ; addArcFeature ( code | dir , fv ) ; code = createArcCodeWPPP ( HC_MC_CL_SC , CL , HC , MC , SC ) ; addArcFeature ( code | type , fv ) ; addArcFeature ( code | dir , fv ) ; code = createArcCodeWPPP ( HC_MC_CC_SL , SL , HC , MC , CC ) ; addArcFeature ( code | type , fv ) ; addArcFeature ( code | dir , fv ) ; code = createArcCodePPP ( HC_CC_SC , HC , CC , SC ) ; addArcFeature ( code | type , fv ) ; addArcFeature ( code | dir , fv ) ; code = createArcCodeWPP ( HL_CC_SC , HL , CC , SC ) ; addArcFeature ( code | type , fv ) ; addArcFeature ( code | dir , fv ) ; code = createArcCodeWPP ( HC_CL_SC , CL , HC , SC ) ; addArcFeature ( code | type , fv ) ; addArcFeature ( code | dir , fv ) ; code = createArcCodeWPP ( HC_CC_SL , SL , HC , CC ) ; addArcFeature ( code | type , fv ) ; addArcFeature ( code | dir , fv ) ; return fv ; }
te	3	public static SaploTag convertFromJSONToTag ( JSONObject json ) { SaploTag saploTag = new SaploTag ( ) ; if ( json . has ( "tag" ) ) saploTag . setTagWord ( json . optString ( "tag" ) ) ; if ( json . has ( "category" ) ) saploTag . setCategory ( SaploTag . TagCategory . valueOf ( ( json . optString ( "category" ) . toUpperCase ( ) ) ) ) ; if ( json . has ( "relevance" ) ) saploTag . setRelevance ( json . optDouble ( "relevance" ) ) ; return saploTag ; }
te	4	private boolean processSubscribe ( Object [ ] wamp_request ) { final int kIndexTopicUri = 1 ; if ( wamp_request . length < 2 ) { log . trace ( "invalid subscribe request" ) ; return false ; } Uri uri = createUri ( ( String ) wamp_request [ kIndexTopicUri ] ) ; if ( uri == null ) { log . trace ( "invalid topic uri: {}" , wamp_request [ kIndexTopicUri ] ) ; return false ; } String path = getHomePath ( ) + uri . getPath ( ) ; synchronized ( server_subscribed_paths_ ) { if ( ! server_subscribed_paths_ . contains ( path ) ) { Handler handler = new RelayHandler ( relayHandlerName ( path ) , this , uri ) ; if ( Directory . Instance . addHandler ( path , handler ) ) { server_subscribed_paths_ . add ( path ) ; } } } log . trace ( "Processed subscribe '{}'" , path ) ; return true ; }
te	7	private final boolean cons ( int i ) { switch ( b [ i ] ) { case a : case e : case i : case o : case u : return false ; case y : return ( i == 0 ) ? true : ! cons ( i - 1 ) ; default : return true ; } }
te	6	@ Override public void onPaint ( DrawingInterface g , int width , int height ) { if ( ! visible ) return ; g . gSetFontName ( Skin . FONT ) ; int fontSize = 1 ; while ( true ) { g . gSetFontSize ( fontSize ) ; if ( g . gGetTextHeight ( ) >= Dim . H ( h , minY ) * 0.5 || g . gGetTextWidth ( longestText ) >= Dim . W ( w , minX ) * 0.9 ) break ; fontSize ++ ; } if ( active ) g . gSetColor ( GUIMain . C_GRAY_L ) ; else g . gSetColor ( Colors . DARK_GRAY ) ; if ( ! enabled ) g . gSetColor ( g . gGetColor ( ) , 80 ) ; g . gDrawText ( getX ( ) , getY ( ) , Dim . W ( w , minX ) , Dim . H ( h , minY ) , Str . get ( text ) , textAlign ) ; }
te	3	public String toString ( ) { String _results = "" ; String p = prerequisite ; String j = justificatoin ; String c = consequence ; if ( prerequisite . compareTo ( a . e . EMPTY_FORMULA ) == 0 ) p = "[]" ; if ( justificatoin . compareTo ( a . e . EMPTY_FORMULA ) == 0 ) j = "[]" ; if ( consequence . compareTo ( a . e . EMPTY_FORMULA ) == 0 ) c = "[]" ; _results = "[(" + p + "):(" + j + ") ==> (" + c + ")]" ; return _results ; }
te	7	public void itemStateChanged ( ItemEvent event ) { Choice cb = ( Choice ) event . getSource ( ) ; double currentZoom = m_dpTable . getZoomLevel ( ) ; double newZoom = 1.0 ; switch ( cb . getSelectedIndex ( ) ) { case 0 : newZoom = 0.6 ; break ; case 1 : newZoom = 0.8 ; break ; case 2 : newZoom = 1.0 ; break ; case 3 : newZoom = 1.4 ; break ; case 4 : newZoom = 1.8 ; break ; case 5 : newZoom = 2.3 ; break ; } if ( newZoom != currentZoom ) { m_dpTable . setZoomLevel ( newZoom ) ; m_dpTable . paint ( m_dpTable . getGraphics ( ) ) ; m_gridScrollArea . doLayout ( ) ; } }
te	5	@ Override public boolean equals ( Object c ) { if ( c == null ) { return false ; } if ( c == this ) { return true ; } if ( ! getClass ( ) . equals ( c . getClass ( ) ) ) { return false ; } TexasCombination param = ( TexasCombination ) c ; for ( int i = 0 ; i < 7 ; ++ i ) { if ( ! cards [ i ] . equals ( param . getCard ( i ) ) ) { return false ; } } return true ; }
te	4	@ Override public void actionPerformed ( ActionEvent e ) { if ( e . getSource ( ) == configButton || e . getSource ( ) == okButton ) { parent . configAction . tap ( ) ; } if ( e . getSource ( ) == buildTurretButton ) { addTurret ( ) ; } if ( e . getSource ( ) == sndPlayerButton ) { } parent . screen . getFullScreenWindow ( ) . requestFocus ( ) ; }
te	6	public String nextTo ( String delimiters ) throws JSONException { char c ; StringBuffer sb = new StringBuffer ( ) ; for ( ; ; ) { c = this . next ( ) ; if ( delimiters . indexOf ( c ) >= 0 || c == 0 || c == '' || c == '' ) { if ( c != 0 ) { this . back ( ) ; } return sb . toString ( ) . trim ( ) ; } sb . append ( c ) ; } }
te	9	protected void dispatchWrite ( UBJOutputStream out , String name , Object value ) throws IOException { if ( value == null ) writeNull ( out , name ) ; else { class < ? > valType = value . getClass ( ) ; if ( isAssignable ( valType , boolean . class ) ) writeBoolean ( out , name , ( boolean ) value ) ; else if ( isAssignable ( valType , Number . class ) ) writeNumber ( out , name , valType , ( Number ) value ) ; else if ( isAssignable ( valType , String . class ) ) writeString ( out , name , ( String ) value ) ; else if ( valType . isArray ( ) ) { if ( "char" . equals ( valType . getComponentType ( ) . getName ( ) ) ) writeString ( out , name , ( char [ ] ) value ) ; else writeArray ( out , name , value ) ; } else if ( isAssignable ( valType , Collection . class ) ) writeArray ( out , name , ( Collection < ? > ) value ) ; else { switch ( mode ) { case FIELDS : writeObjectByFields ( out , valType . getSimpleName ( ) , valType , value ) ; break ; case METHODS : writeObjectByMethods ( out , valType . getSimpleName ( ) , valType , value ) ; break ; } } } }
te	7	int count ( ) { for ( int i = 0 ; i < pix . length ; i ++ ) { splitRGB ( pix [ i ] ) ; if ( tree [ rr ] == null ) { if ( overCount ( ) ) break ; tree [ rr ] = new int [ 256 ] [ ] ; tree [ rr ] [ gg ] = new int [ 256 ] ; addRGB ( true ) ; } else if ( tree [ rr ] [ gg ] == null ) { if ( overCount ( ) ) break ; tree [ rr ] [ gg ] = new int [ 256 ] ; addRGB ( true ) ; } else if ( tree [ rr ] [ gg ] [ bb ] < 0 ) { if ( overCount ( ) ) break ; addRGB ( false ) ; } } return count ; }
te	4	@ Override public void readInternal ( Environment env ) throws IOException , TypeException { while ( true ) { readChar ( env ) ; if ( ! ( env . peek ( ) instanceof VChar ) ) { return ; } int ch = ( ( VChar ) env . peek ( ) ) . getChar ( ) ; IValue v = env . getBoundObject ( Character . toString ( ( char ) ch ) ) ; if ( null == v || ! ( v instanceof VWhitespace ) ) { break ; } env . pop ( ) ; } }
te	5	private Map createMap ( ) { ImageRegistry [ ] skinWrap = { skin } ; super . setPlayerSpawn ( SPAWN_POINT ) ; Map newMap = MapInterpreter . interpretMap ( this , skinWrap , MONSTER_TIER ) ; newMap . setPlayerSpawn ( SPAWN_POINT ) ; Rectangle placement = MONSTER_RECT ; for ( int i = 0 ; i < MONSTER_COUNT ; i ++ ) { Point tempPt = MapRand . randPoint ( placement ) ; int j = 0 ; j = 0 ; while ( ( ( this . getTile ( tempPt . x , tempPt . y ) != MapTile . ROOM_FLOOR ) || ( newMap . getTile ( tempPt . x , tempPt . y ) . isOccupied ( ) ) ) && ( j < RETRY_COUNT ) ) { tempPt = MapRand . randPoint ( placement ) ; j ++ ; } Tile selected = newMap . getTile ( tempPt . x , tempPt . y ) ; if ( selected . isOccupied ( ) == false ) { Monster babyMonster = Controller . getInstance ( ) . getRandMapMonster ( MONSTER_TIER ) ; selected . setOccupant ( babyMonster ) ; newMap . addMonster ( babyMonster ) ; } } Point tempPt = TELEPORT_ITEM_POINT ; newMap . getTile ( tempPt . x , tempPt . y ) . addItem ( Controller . getInstance ( ) . creator . createArmour ( "personal teleport" ) ) ; return newMap ; }
te	4	public void restart ( ) { for ( int i = 0 ; i < tokens . length ; i ++ ) { for ( int j = 0 ; j < tokens [ i ] . length ; j ++ ) { tokens [ i ] [ j ] . setType ( 0 ) ; tokens [ i ] [ j ] . setFrozen ( false ) ; } } for ( int i = 0 ; i < nextTokens1 . length ; i ++ ) { for ( int j = 0 ; j < nextTokens1 [ i ] . length ; j ++ ) { nextTokens1 [ i ] [ j ] . setType ( 0 ) ; nextTokens2 [ i ] [ j ] . setType ( 0 ) ; nextTokens3 [ i ] [ j ] . setType ( 0 ) ; holdTokens [ i ] [ j ] . setType ( 0 ) ; } } timeCount . stop ( ) ; timeSpeed . stop ( ) ; speed = 800 ; line = 0 ; level = 1 ; time = 0 ; score = 0 ; rotateCount = 0 ; isPaused = false ; isGameOn = false ; freezing = false ; currentTokens = new int [ 4 ] [ 2 ] ; directingTokens = new int [ 4 ] [ 2 ] ; nextTokens3Position = new int [ 4 ] [ 2 ] ; nextTokens2Position = new int [ 4 ] [ 2 ] ; nextTokens1Position = new int [ 4 ] [ 2 ] ; holdTokensPosition = new int [ 4 ] [ 2 ] ; timeSpeed . setDelay ( speed ) ; bestScores = null ; setChanged ( ) ; notifyObservers ( time ) ; setChanged ( ) ; notifyObservers ( line ) ; refresh ( ) ; setChanged ( ) ; notifyObservers ( level ) ; }
te	8	public Vector < String > getInsight ( String position , int trafficType ) { Vector < Coordinate > surrounds = new Vector < Coordinate > ( ) ; surrounds . add ( CoordinateConverter . string2Value ( position ) ) ; int layerPoints = 1 ; while ( trafficType > 0 && ! surrounds . isEmpty ( ) ) { -- layerPoints ; Coordinate cur = surrounds . get ( 0 ) ; int r = cur . getRow ( ) ; int c = cur . getColumn ( ) ; if ( isValid ( r , c + 1 ) ) { surrounds . add ( new Coordinate ( r , c + 1 ) ) ; } if ( isValid ( r + 1 , c ) ) { surrounds . add ( new Coordinate ( r + 1 , c ) ) ; } if ( isValid ( r , c - 1 ) ) { surrounds . add ( new Coordinate ( r , c - 1 ) ) ; } if ( isValid ( r - 1 , c ) ) { surrounds . add ( new Coordinate ( r - 1 , c ) ) ; } if ( layerPoints == 0 ) { layerPoints = surrounds . size ( ) ; trafficType -- ; } } Vector < String > result = new Vector < String > ( ) ; for ( Coordinate c : surrounds ) { result . add ( CoordinateConverter . value2String ( c ) ) ; } return result ; }
te	1	public void paintComponent ( Graphics gr ) { if ( _graph != null ) { _graph . draw ( gr , _index1 , _index2 ) ; } }
te	9	private void dialogAction ( String str ) { if ( str == "AddPicture" ) { int state = fc . showOpenDialog ( null ) ; if ( state == JFileChooser . APPROVE_OPTION ) { config . setPictureDirectory ( fc . getCurrentDirectory ( ) ) ; File file = fc . getSelectedFile ( ) ; PictureObject newPicture = new PictureObject ( nextID ) ; if ( newPicture . importPicture ( file ) ) { pictureListModel . addElement ( newPicture ) ; pictureChoiceList . setSelectedIndex ( pictureListModel . size ( ) - 1 ) ; pictureChoiceList . requestFocusInWindow ( ) ; selectedPicture = newPicture ; nextID = nextID + 1 ; refreshDialog ( ) ; } } } if ( str == "ReloadPicture" ) { PictureObject selectedPictureObject = ( PictureObject ) pictureChoiceList . getSelectedValue ( ) ; if ( selectedPictureObject != null ) { System . out . println ( "Reloading " + selectedPictureObject . getPictureSourceFileName ( ) ) ; String pictureName = selectedPictureObject . getPictureName ( ) ; File file = new File ( selectedPictureObject . getPictureSourceFileName ( ) ) ; selectedPictureObject . importPicture ( file ) ; selectedPictureObject . setPictureName ( pictureName ) ; refreshDialog ( ) ; } } if ( str == "RemovePicture" ) { if ( selectedPicture == null ) { return ; } if ( editor . checkImageInUse ( selectedPicture . getID ( ) ) ) { JOptionPane . showMessageDialog ( null , "This picture is still in use." , "Can not remove picture" , JOptionPane . ERROR_MESSAGE ) ; return ; } int selectedElementPos = pictureChoiceList . getSelectedIndices ( ) [ 0 ] ; pictureListModel . remove ( selectedElementPos ) ; if ( selectedElementPos >= pictureListModel . size ( ) ) selectedElementPos = selectedElementPos - 1 ; if ( selectedElementPos > 0 ) pictureChoiceList . setSelectedIndex ( selectedElementPos ) ; pictureChoiceList . requestFocusInWindow ( ) ; refreshDialog ( ) ; } if ( str == "PictureUp" ) { int selectedElementPos = pictureChoiceList . getSelectedIndex ( ) ; pictureListModel . add ( selectedElementPos - 1 , pictureListModel . get ( selectedElementPos ) ) ; pictureListModel . remove ( selectedElementPos + 1 ) ; pictureChoiceList . requestFocusInWindow ( ) ; pictureChoiceList . setSelectedIndex ( selectedElementPos - 1 ) ; pictureChoiceList . grabFocus ( ) ; refreshDialog ( ) ; } if ( str == "PictureDown" ) { int selectedElementPos = pictureChoiceList . getSelectedIndex ( ) ; pictureListModel . add ( selectedElementPos + 2 , pictureListModel . get ( selectedElementPos ) ) ; pictureListModel . remove ( selectedElementPos ) ; pictureChoiceList . requestFocusInWindow ( ) ; pictureChoiceList . setSelectedIndex ( selectedElementPos + 1 ) ; pictureChoiceList . grabFocus ( ) ; refreshDialog ( ) ; } }
te	3	public void checkTailCollision ( ) { TailSection [ ] tail = snake . getTail ( ) ; for ( int i = 1 ; i < tail . length ; i ++ ) { if ( ( snake . getxPosition ( ) == tail [ i ] . getxCordinate ( ) ) && ( snake . getyPosition ( ) == tail [ i ] . getyCordinate ( ) ) ) { endGame ( ) ; } } }
te	4	public RSession voidEvalDetach ( String cmd ) throws RSrvException { if ( ! connected || rt == null ) throw new RSrvException ( this , "Not connected" ) ; Rpacket rp = rt . request ( Rtalk . CMD_detachedVoidEval , cmd + "\n" ) ; if ( rp == null || ! rp . isOk ( ) ) throw new RSrvException ( this , "detached void eval failed" , rp ) ; RSession s = new RSession ( this , rp ) ; close ( ) ; return s ; }
te	6	@ SuppressWarnings ( "unchecked" ) public Object callMethod ( Object source , String operationName , Object ... argumentValues ) throws Exception { try { class < ? > [ ] argumentTypes = new class < ? > [ argumentValues . length ] ; for ( int i = 0 ; i < argumentValues . length ; i ++ ) { argumentTypes [ i ] = argumentValues [ i ] . getClass ( ) ; } if ( source instanceof class ) { Method method = ( ( class ) source ) . getDeclaredMethod ( operationName , argumentTypes ) ; return method . invoke ( source , argumentValues ) ; } else { Method method = source . getClass ( ) . getDeclaredMethod ( operationName , argumentTypes ) ; return method . invoke ( source , argumentValues ) ; } } catch ( NoSuchMethodException e ) { if ( "allInstances" . equals ( operationName ) ) throw new OclException ( "allInstances() not supported with this context!" ) ; else throw e ; } }
te	2	public static void main ( final String [ ] args ) { final List < Integer > primes = SieveWithBitset . sieveOfEratosthenes ( 1000000 ) ; final Set < Integer > set = new HashSet < Integer > ( ) ; for ( final int i : primes ) if ( check ( primes , i ) ) set . add ( i ) ; System . out . println ( set . size ( ) ) ; uptime ( ) ; }
te	2	@ Override public void actionPerformed ( ActionEvent e ) { try { String namn = txfSearch . getText ( ) ; actualAccount = AccountDatabaseManager . searchAccountInDb ( namn ) ; if ( actualAccount != null ) { txfAccountName . setText ( actualAccount . getOwnerName ( ) ) ; txfAccountBalance . setText ( "" + actualAccount . getBalance ( ) ) ; } else { JOptionPane . showMessageDialog ( null , "Kontot du s\u00F6kte fanns ej" ) ; } } catch ( NullPointerException nex ) { JOptionPane . showMessageDialog ( null , "Du m\u00E5ste skapa ett konto f\u00F6rst" ) ; txfSearch . setText ( "" ) ; } }
te	7	@ Override public boolean registraNuevoUsuario ( String pUser , String pPass , String pEmail , String pRole ) { Conexion baseDeDatos = new Conexion ( ) ; boolean isValid = true ; int contador = 0 ; try { baseDeDatos . crearConexion ( ) ; PreparedStatement pstmt = baseDeDatos . getConexion ( ) . prepareStatement ( "{call dbo.sprVerificaUsuario(? ?)}" ) ; pstmt . setString ( 1 , pUser ) ; pstmt . setString ( 2 , pPass ) ; ResultSet rs = pstmt . executeQuery ( ) ; while ( rs . next ( ) ) { contador ++ ; } } catch ( Exception e ) { System . out . println ( "Error al tratar de establecer conexion desde el repositorio" ) ; } if ( contador > 0 ) { System . out . println ( "Ya existe el usuario" ) ; isValid = false ; } if ( isValid ) { try { PreparedStatement pstmt = baseDeDatos . getConexion ( ) . prepareStatement ( "{call dbo.sprRegistraUsuario(? ? ?)}" ) ; pstmt . setString ( 1 , pUser ) ; pstmt . setString ( 2 , pPass ) ; if ( "RolUser" . equals ( pRole ) ) { pstmt . setInt ( 3 , 1 ) ; } else { pstmt . setInt ( 3 , 0 ) ; } pstmt . executeQuery ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; System . out . println ( "Error al tratar de establecer conexion desde el repositorio 2" ) ; } } try { baseDeDatos . cerrarConexion ( ) ; } catch ( Exception e ) { System . out . println ( "Error al trata de cerrar conexion desde el repositorio" ) ; } return isValid ; }
te	7	private < T > List < Slice > splitArray ( final Mass [ ] [ ] data , final int chunkSize , boolean iteratorNeedsNeighbours ) { int horizSize = ( int ) Math . sqrt ( chunkSize ) ; if ( horizSize < 1 ) { horizSize = 1 ; } final int vertSize = horizSize ; final int horizSlices = params . getGridColumnCount ( ) / horizSize ; final int vertSlices = params . getGridRowCount ( ) / vertSize ; final int horizRest = params . getGridColumnCount ( ) - horizSlices * horizSize ; final int vertRest = params . getGridRowCount ( ) - vertSlices * vertSize ; final List < Slice > result = new ArrayList < > ( ) ; final int xEnd = horizSlices * horizSize ; final int yEnd = vertSlices * vertSize ; int x , y ; for ( y = 0 ; y < yEnd ; y += vertSize ) { final boolean isAtBottomEdge = ( y + vertSize ) >= yEnd ; for ( x = 0 ; x < xEnd ; x += horizSize ) { boolean isAtRightEdge = ( x + horizRest ) >= xEnd ; result . add ( new Slice ( x , y , horizSize , vertSize , iteratorNeedsNeighbours , isAtRightEdge , isAtBottomEdge ) ) ; } if ( horizRest > 0 ) { result . add ( new Slice ( x , y , horizRest , vertSize , iteratorNeedsNeighbours , true , isAtBottomEdge ) ) ; } } if ( vertRest > 0 ) { for ( x = 0 ; x < xEnd ; x += horizSize ) { boolean isAtRightEdge = ( x + horizRest ) >= xEnd ; result . add ( new Slice ( x , y , horizSize , vertRest , iteratorNeedsNeighbours , isAtRightEdge , true ) ) ; } if ( horizRest > 0 ) { result . add ( new Slice ( x , y , horizRest , vertRest , iteratorNeedsNeighbours , true , true ) ) ; } } return result ; }
te	3	@ Override public boolean containsAll ( Collection < ? > c ) { for ( Object o : c ) { if ( ! contains ( o ) ) return false ; } return true ; }
te	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( CambiarUsuarioGui . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( CambiarUsuarioGui . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( CambiarUsuarioGui . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( CambiarUsuarioGui . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { CambiarUsuarioGui dialog = new CambiarUsuarioGui ( new javax . swing . JFrame ( ) , true ) ; dialog . addWindowListener ( new java . awt . event . WindowAdapter ( ) { @ Override public void windowClosing ( java . awt . event . WindowEvent e ) { System . exit ( 0 ) ; } } ) ; dialog . setVisible ( true ) ; } } ) ; }
te	7	static public boolean isPartialStatement ( String lex ) { List < String > stmtTokens = Helpers . tokenize ( lex . trim ( ) ,   ) ; if ( stmtTokens . size ( ) != 3 ) return false ; if ( ! ( ( stmtTokens . get ( 0 ) . length ( ) > 0 && stmtTokens . get ( 0 ) . charAt ( 0 ) == ? ) || ( stmtTokens . get ( 1 ) . length ( ) > 0 && stmtTokens . get ( 1 ) . charAt ( 0 ) == ? ) || ( stmtTokens . get ( 2 ) . length ( ) > 0 && stmtTokens . get ( 2 ) . charAt ( 0 ) == ? ) ) ) return false ; return true ; }
te	4	@ Override public void run ( ) { while ( true ) { if ( ! pause ) { try { Log . i ( "wait to send..." ) ; Message message = messageQueue . take ( ) ; message . send ( ) ; Log . i ( "message:" + message . content + " sended...during " + ( System . currentTimeMillis ( ) - message . startRecieveTime ) / 1000f ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } catch ( Exception e ) { } } } }
te	8	public void setOptInputParamReal ( final int paramIndex , final double value ) throws IllegalArgumentException { OptInputParameterInfo param = getOptInputParameterInfo ( paramIndex ) ; if ( param . type ( ) == OptInputParameterType . TA_OptInput_RealList ) { RealList list = getOptInputRealList ( paramIndex ) ; for ( double entry : list . value ( ) ) { if ( value == entry ) { if ( callOptInputParams == null ) callOptInputParams = new Object [ getFuncInfo ( ) . nbOptInput ( ) ] ; callOptInputParams [ paramIndex ] = value ; return ; } } } else if ( param . type ( ) == OptInputParameterType . TA_OptInput_RealRange ) { RealRange range = getOptInputRealRange ( paramIndex ) ; if ( ( value >= range . min ( ) ) && ( value <= range . max ( ) ) ) { if ( callOptInputParams == null ) callOptInputParams = new Object [ getFuncInfo ( ) . nbOptInput ( ) ] ; callOptInputParams [ paramIndex ] = value ; return ; } } throw new InternalError ( CONTACT_DEVELOPERS ) ; }
te	6	@ Override public void build ( ) { TextureLoader . getInstance ( ) . drawTexture ( name ) ; GL11 . glPushMatrix ( ) ; GL11 . glScalef ( width , height , deepth ) ; final float c = 0.5f ; GL11 . glColor3f ( 1f , 1f , 1f ) ; GL11 . glNormal3f ( 0f , 0f , isInside ? 1f : - 1f ) ; Triangle efg = new Triangle ( new float [ ] { - c , - c , - c } , new float [ ] { 0f , 1f } , new float [ ] { c , - c , - c } , new float [ ] { 1f , 1f } , new float [ ] { c , c , - c } , new float [ ] { 1f , 0f } ) ; Triangle egh = new Triangle ( new float [ ] { - c , - c , - c } , new float [ ] { 0f , 1f } , new float [ ] { c , c , - c } , new float [ ] { 1f , 0f } , new float [ ] { - c , c , - c } , new float [ ] { 0f , 0f } ) ; efg . draw ( subDivisions ) ; egh . draw ( subDivisions ) ; GL11 . glNormal3f ( 0f , 0f , isInside ? - 1f : 1f ) ; Triangle abc = new Triangle ( new float [ ] { - c , - c , c } , new float [ ] { 1f , 1f } , new float [ ] { c , - c , c } , new float [ ] { 0f , 1f } , new float [ ] { c , c , c } , new float [ ] { 0f , 0f } ) ; Triangle acd = new Triangle ( new float [ ] { - c , - c , c } , new float [ ] { 1f , 1f } , new float [ ] { c , c , c } , new float [ ] { 0f , 0f } , new float [ ] { - c , c , c } , new float [ ] { 1f , 0f } ) ; abc . draw ( subDivisions ) ; acd . draw ( subDivisions ) ; GL11 . glNormal3f ( 0f , isInside ? 1f : - 1f , 0f ) ; Triangle abf = new Triangle ( new float [ ] { - c , - c , c } , new float [ ] { 1f , 0f } , new float [ ] { c , - c , c } , new float [ ] { 0f , 0f } , new float [ ] { c , - c , - c } , new float [ ] { 0f , 1f } ) ; Triangle afe = new Triangle ( new float [ ] { - c , - c , c } , new float [ ] { 1f , 0f } , new float [ ] { c , - c , - c } , new float [ ] { 0f , 1f } , new float [ ] { - c , - c , - c } , new float [ ] { 1f , 1f } ) ; abf . draw ( subDivisions ) ; afe . draw ( subDivisions ) ; GL11 . glNormal3f ( 0f , isInside ? - 1f : 1f , 0f ) ; Triangle dcg = new Triangle ( new float [ ] { - c , c , c } , new float [ ] { 1f , 1f } , new float [ ] { c , c , c } , new float [ ] { 0f , 1f } , new float [ ] { c , c , - c } , new float [ ] { 0f , 0f } ) ; Triangle dgh = new Triangle ( new float [ ] { - c , c , c } , new float [ ] { 1f , 1f } , new float [ ] { c , c , - c } , new float [ ] { 0f , 0f } , new float [ ] { - c , c , - c } , new float [ ] { 1f , 0f } ) ; dcg . draw ( subDivisions ) ; dgh . draw ( subDivisions ) ; GL11 . glNormal3f ( isInside ? - 1f : 1f , 0f , 0f ) ; Triangle bfg = new Triangle ( new float [ ] { c , - c , c } , new float [ ] { 1f , 1f } , new float [ ] { c , - c , - c } , new float [ ] { 0f , 1f } , new float [ ] { c , c , - c } , new float [ ] { 0f , 0f } ) ; Triangle bgc = new Triangle ( new float [ ] { c , - c , c } , new float [ ] { 1f , 1f } , new float [ ] { c , c , - c } , new float [ ] { 0f , 0f } , new float [ ] { c , c , c } , new float [ ] { 1f , 0f } ) ; bfg . draw ( subDivisions ) ; bgc . draw ( subDivisions ) ; GL11 . glNormal3f ( isInside ? 1f : - 1f , 0f , 0f ) ; Triangle aeh = new Triangle ( new float [ ] { - c , - c , c } , new float [ ] { 0f , 1f } , new float [ ] { - c , - c , - c } , new float [ ] { 1f , 1f } , new float [ ] { - c , c , - c } , new float [ ] { 1f , 0f } ) ; Triangle ahd = new Triangle ( new float [ ] { - c , - c , c } , new float [ ] { 0f , 1f } , new float [ ] { - c , c , - c } , new float [ ] { 1f , 0f } , new float [ ] { - c , c , c } , new float [ ] { 0f , 0f } ) ; aeh . draw ( subDivisions ) ; ahd . draw ( subDivisions ) ; GL11 . glPopMatrix ( ) ; TextureLoader . getInstance ( ) . defaultTexture ( ) ; }
te	7	private JSONWriter append ( String string ) throws JSONException { if ( string == null ) { throw new JSONException ( "Null pointer" ) ; } if ( this . mode == o || this . mode == a ) { try { if ( this . , && this . mode == a ) { this . writer . write (   ) ; } this . writer . write ( string ) ; } catch ( IOException e ) { throw new JSONException ( e ) ; } if ( this . mode == o ) { this . mode = k ; } this . , = true ; return this ; } throw new JSONException ( "Value out of sequence." ) ; }
te	4	public Message ( String xmlSource ) throws IllegalArgumentException { if ( builder == null ) { throw new RuntimeException ( "XML Protocol not configured." ) ; } try { String normalizedInput = normalizeInput ( xmlSource ) ; InputSource is = new InputSource ( new StringReader ( normalizedInput ) ) ; Document d = null ; synchronized ( builder ) { d = builder . parse ( is ) ; errorHandler . failFast ( ) ; } NodeList children = d . getChildNodes ( ) ; for ( int i = 0 ; i < children . getLength ( ) ; i ++ ) { Node n = children . item ( i ) ; if ( n . getNodeType ( ) == Node . ELEMENT_NODE ) { contents = n ; return ; } } throw new IllegalArgumentException ( "XML document has no child node" ) ; } catch ( Exception e ) { errorHandler . failFast ( ) ; throw new IllegalArgumentException ( e . getMessage ( ) ) ; } }
te	8	public void checkEnemyCollision ( ArrayList < Enemy > list ) { for ( int i = 0 ; i < list . size ( ) ; i ++ ) { double w = .5 * ( list . get ( i ) . getCWidth ( ) + getWidth ( ) ) ; double h = .5 * ( list . get ( i ) . getCHeight ( ) + getHeight ( ) ) ; double dx = list . get ( i ) . getCCenterX ( ) - getCenterX ( ) ; double dy = list . get ( i ) . getCCenterY ( ) - getCenterY ( ) ; if ( Math . abs ( dx ) <= w && Math . abs ( dy ) <= h ) { double wy = w * dy ; double hx = h * dx ; if ( wy > hx ) { if ( wy > - hx ) { System . out . println ( "Not supposed to happen :: Koopa" ) ; } else { if ( ! shell ) { turn ( ) ; list . get ( i ) . turn ( ) ; } else { list . get ( i -- ) . hitByProjectile ( this ) ; } } } else { if ( wy > - hx ) { if ( ! shell ) { turn ( ) ; list . get ( i ) . turn ( ) ; } else { list . get ( i -- ) . hitByProjectile ( this ) ; } } else { System . out . println ( "Not supposed to happen :: Koopa" ) ; } } } } }
te	1	public void addAll ( int [ ] array , int offset , int length ) { int [ ] items = this . items ; int sizeNeeded = size + length ; if ( sizeNeeded > items . length ) { items = resize ( Math . max ( 8 , ( int ) ( sizeNeeded * 1.75f ) ) ) ; } System . arraycopy ( array , offset , items , size , length ) ; size += length ; }
te	1	public SurveyDAO getSurveyDAO ( ) { if ( surveyDAO == null ) { surveyDAO = new SurveyDAO ( ) ; } return surveyDAO ; }
te	6	public Object getContextValue ( String key , String type ) { if ( key == null ) { return null ; } Object rval = null ; if ( "@language" . equals ( type ) && this . containsKey ( type ) ) { rval = this . get ( type ) ; } if ( this . mappings . containsKey ( key ) ) { final Map < String , Object > entry = ( Map < String , Object > ) this . mappings . get ( key ) ; if ( type == null ) { rval = entry ; } else if ( entry . containsKey ( type ) ) { rval = entry . get ( type ) ; } } return rval ; }
te	3	private static String indent ( String str , String prefix ) { StringBuffer res = new StringBuffer ( prefix ) ; for ( int i = 0 , len = str . length ( ) ; i < len ; ++ i ) { char c = str . charAt ( i ) ; res . append ( c ) ; if ( c == '' && i < len - 1 ) res . append ( prefix ) ; } return res . toString ( ) ; }
te	2	@ Override public void run ( ) { for ( int j = 0 ; j < 5 ; j ++ ) { try { Thread . sleep ( 1000 ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } System . out . println ( Thread . currentThread ( ) . getName ( ) + " j: " + j ) ; } }
te	3	private void prepareNextTurn ( ) { if ( turn . equals ( p1 ) ) turn = p2 ; else if ( turn . equals ( p2 ) ) if ( triple ) turn = p3 ; else { turn = p1 ; turnnumber ++ ; } else { turn = p1 ; turnnumber ++ ; } }
te	3	protected String logStackTrace ( LogLevel level , Throwable t ) { String res = null ; if ( t != null && includeStacktrace ) { StringWriter sw = new StringWriter ( ) ; t . printStackTrace ( new PrintWriter ( sw ) ) ; String text = sw . toString ( ) ; res = text ; if ( logToConsole ) { getPrintStream ( level ) . print ( text ) ; } } return res ; }
te	8	private boolean r_prelude ( ) { int among_var ; int v_1 ; replab0 : while ( true ) { v_1 = cursor ; lab1 : do { bra = cursor ; among_var = find_among ( a_0 , 3 ) ; if ( among_var == 0 ) { break lab1 ; } ket = cursor ; switch ( among_var ) { case 0 : break lab1 ; case 1 : slice_from ( "a~" ) ; break ; case 2 : slice_from ( "o~" ) ; break ; case 3 : if ( cursor >= limit ) { break lab1 ; } cursor ++ ; break ; } continue replab0 ; } while ( false ) ; cursor = v_1 ; break replab0 ; } return true ; }
te	3	public Tuple < Integer , Integer > getMove ( ) { String [ ] [ ] b = board . getState ( ) ; ArrayList < Tuple < Integer , Integer >> listOfMoves = new ArrayList < Tuple < Integer , Integer >> ( ) ; for ( int x = 0 ; x < 7 ; ++ x ) { for ( int y = 0 ; y < 7 ; ++ y ) { if ( b [ x ] [ y ] . equals ( "e" ) ) { listOfMoves . add ( new Tuple < Integer , Integer > ( x , y ) ) ; } } } Random generator = new Random ( ) ; return listOfMoves . get ( generator . nextInt ( listOfMoves . size ( ) ) ) ; }
te	5	@ Override public boolean executeTask ( TaskMetaData taskMetaData ) { if ( taskMetaData . getTaskType ( ) == SystemConstants . TaskType . MAPPER ) { synchronized ( this . taskTrackerReference . countofRunningMapperFieldAgents ) { if ( this . taskTrackerReference . countofRunningMapperFieldAgents < this . taskTrackerReference . mapperSlotCapacity ) { synchronized ( this . taskTrackerReference . countofRunningMapperFieldAgents ) { this . taskTrackerReference . countofRunningMapperFieldAgents ++ ; } String [ ] processargs = new String [ ] { MapperFieldAgent . class . getName ( ) , String . valueOf ( taskMetaData . getTaskID ( ) ) , SystemConstants . getConfig ( SystemConstants . ADFS_DIRECTORY ) + System . getProperty ( "file.separator" ) + taskMetaData . getInputPath ( ) , SystemConstants . getConfig ( SystemConstants . ADFS_DIRECTORY ) + System . getProperty ( "file.separator" ) + taskMetaData . getOutputPath ( ) , taskMetaData . getMapper ( ) , taskMetaData . getPartitioner ( ) , taskMetaData . getInputFormat ( ) , String . valueOf ( taskMetaData . getReducerNum ( ) ) } ; try { JVMUtility . startProcessinJVM ( processargs ) ; } catch ( Exception e ) { System . err . println ( "Could initiate the Map Request" ) ; e . printStackTrace ( ) ; return false ; } return true ; } else return false ; } } else { synchronized ( this . taskTrackerReference . countofRunningReducerFieldAgents ) { if ( this . taskTrackerReference . countofRunningReducerFieldAgents < this . taskTrackerReference . reducerSlotCapacity ) { synchronized ( this . taskTrackerReference . countofRunningReducerFieldAgents ) { this . taskTrackerReference . countofRunningReducerFieldAgents ++ ; } String [ ] processargs = new String [ ] { ReducerFieldAgent . class . getName ( ) , String . valueOf ( taskMetaData . getTaskID ( ) ) , SystemConstants . getConfig ( SystemConstants . ADFS_DIRECTORY ) + System . getProperty ( "file.separator" ) + taskMetaData . getOutputPath ( ) , taskMetaData . getReducer ( ) , taskMetaData . getOutputFormat ( ) , String . valueOf ( taskMetaData . getParitionNumber ( ) ) } ; try { JVMUtility . startProcessinJVM ( processargs ) ; } catch ( Exception e ) { System . err . println ( "Could initiate the Map Request" ) ; e . printStackTrace ( ) ; return false ; } return true ; } else return false ; } } }
te	3	@ Override public Object convertValue ( Object value ) { if ( value == null ) { return null ; } if ( ! ( value instanceof java . sql . Timestamp ) ) { String v = value . toString ( ) ; if ( v . trim ( ) . length ( ) == 0 ) { value = null ; } else { value = java . sql . Timestamp . valueOf ( v ) ; } } return value ; }
te	9	@ Override public void newWordAdded ( Player p , Word w , long milliseconds , WordAddedState state ) { if ( p == gameTable . getLocalPlayer ( ) ) { if ( state == WordAddedState . TIMEOUT_ELAPSED ) { lblMessages . setText ( "<html><div style=\"width: 1000\">You weren't able to insert a word</div></html>" ) ; } else if ( state == WordAddedState . NO_IN_DICTIONARY ) { lblMessages . setText ( "<html><div style=\"width: 1000\">You inserted an unknown word</div></html>" ) ; } else if ( state == WordAddedState . SYLLABE_INCORRECT ) { lblMessages . setText ( "<html><div style=\"width: 1000\">You inserted a word which doesn't start with the last syllabe of the previous word</div></html>" ) ; } else if ( state == WordAddedState . PREVIOUSLY_ADDED ) { lblMessages . setText ( "<html><div style=\"width: 1000\">The word you inserted has been already inserted</div></html>" ) ; } else if ( state == WordAddedState . OK ) { lblMessages . setText ( "<html><div style=\"width: 1000\">You inserted the word: " + w + "</div></html>" ) ; } else { assert ( false ) ; } } else { if ( state == WordAddedState . TIMEOUT_ELAPSED ) { lblMessages . setText ( "<html><div style=\"width: 1000\"><b>" + p + "</b> wasn't able to insert a word</div></html>" ) ; } else if ( state == WordAddedState . NO_IN_DICTIONARY ) { lblMessages . setText ( "<html><div style=\"width: 1000\"><b>" + p + "</b> inserted an unknown word</div></html>" ) ; } else if ( state == WordAddedState . SYLLABE_INCORRECT ) { lblMessages . setText ( "<html><div style=\"width: 1000\"><b>" + p + "</b> inserted a word which doesn't start with the last syllabe of the previous word</div></html>" ) ; } else if ( state == WordAddedState . PREVIOUSLY_ADDED ) { lblMessages . setText ( "<html><div style=\"width: 1000\"><b>" + p + "</b> inserted a word that has been previously inserted</div></html>" ) ; } else if ( state == WordAddedState . OK ) { lblMessages . setText ( "<html><div style=\"width: 1000\"><b>" + p + "</b> inserted the word: " + w + "</div></html>" ) ; } else { assert ( false ) ; } } }
te	0	public HostList ( ) { super ( ) ; }
te	8	public void addFileInfo ( String fileData ) { StringTokenizer tokenizer ; String token [ ] ; FileInfo fileInfo ; token = new String [ 100 ] ; fileInfo = new FileInfo ( ) ; tokenizer = new StringTokenizer ( fileData , " " ) ; int i = 0 ; while ( tokenizer . hasMoreTokens ( ) ) { token [ i ] = tokenizer . nextToken ( ) ; switch ( i ) { case 0 : fileInfo . setType ( token [ i ] ) ; break ; case 1 : fileInfo . setName ( token [ i ] ) ; break ; case 2 : fileInfo . setParent ( token [ i ] ) ; break ; case 3 : fileInfo . setDepth ( token [ i ] ) ; break ; case 4 : fileInfo . setRootID ( token [ i ] ) ; break ; case 5 : fileInfo . setSize ( token [ i ] ) ; break ; case 6 : fileInfo . setFileID ( token [ i ] ) ; break ; default : break ; } i ++ ; } fileInfoList . add ( fileInfo ) ; }
te	4	public void setHumphreyData ( ) { File humphrey = new File ( "humphrey-img.txt" ) ; Scanner humphreyIn = null ; try { humphreyIn = new Scanner ( humphrey ) ; int imageSize = humphreyIn . nextInt ( ) ; pixels = new int [ imageSize ] [ imageSize ] ; for ( int i = 0 ; i < pixels . length ; i ++ ) { for ( int j = 0 ; j < pixels [ i ] . length ; j ++ ) { pixels [ i ] [ j ] = humphreyIn . nextInt ( ) ; } } } catch ( FileNotFoundException fnf ) { System . out . println ( "No dice" ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { humphreyIn . close ( ) ; } }
te	4	private static int minJumps ( int [ ] inputArray ) { int [ ] outputArray = new int [ inputArray . length ] ; outputArray [ 0 ] = 0 ; for ( int i = 0 ; i < inputArray . length ; i ++ ) { outputArray [ i ] = i ; for ( int j = 0 ; j < i ; j ++ ) { if ( inputArray [ j ] + j >= i && outputArray [ i ] > outputArray [ j ] + 1 ) outputArray [ i ] = outputArray [ j ] + 1 ; } } printArray ( outputArray ) ; return outputArray [ inputArray . length - 1 ] ; }
te	6	public static String extractQuotedValue ( String value ) { if ( value != null && value . startsWith ( "\"" ) && value . endsWith ( "\"" ) ) { return value . substring ( 1 , value . length ( ) - 1 ) ; } else if ( value != null && value . startsWith ( "'" ) && value . endsWith ( "'" ) ) { return value . substring ( 1 , value . length ( ) - 1 ) ; } else { return value ; } }
te	9	@ Override public void setComponents ( ) { this . lblParam1 . setVisible ( false ) ; this . lblParam2 . setVisible ( false ) ; this . txtParam1 . setVisible ( false ) ; this . txtParam2 . setVisible ( false ) ; this . calFecha1 . setVisible ( false ) ; this . calFecha2 . setVisible ( false ) ; this . lblEMaxPromo . setVisible ( false ) ; this . txtEdadPromo . setVisible ( false ) ; this . txtParam1 . setText ( "" ) ; this . txtParam2 . setText ( "" ) ; this . txtEdadPromo . setText ( "" ) ; header = new MessageFormat ( "" ) ; footer = new MessageFormat ( "" ) ; switch ( cboxReporte . getSelectedItem ( ) . toString ( ) ) { case "Usuarios Por Edad" : this . lblParam1 . setText ( "Edad Minima" ) ; this . lblParam2 . setText ( "Edad Maxima" ) ; this . lblParam1 . setVisible ( true ) ; this . lblParam2 . setVisible ( true ) ; this . txtParam1 . setVisible ( true ) ; this . txtParam2 . setVisible ( true ) ; break ; case "Lineas y sus Estaciones" : break ; case "Listado de Estaciones" : break ; case "Consulta de Usuario" : this . lblParam1 . setText ( "Ingrese CI" ) ; this . txtParam1 . setVisible ( true ) ; this . lblParam1 . setVisible ( true ) ; break ; case "Consulta de Estacion" : this . lblParam1 . setText ( "Ingrese Nombre" ) ; this . txtParam1 . setVisible ( true ) ; this . lblParam1 . setVisible ( true ) ; break ; case "Usuarios con m\u00E1s Consumo" : this . lblParam1 . setText ( "Inicio" ) ; this . lblParam2 . setText ( "Fin" ) ; this . lblParam1 . setVisible ( true ) ; this . lblParam2 . setVisible ( true ) ; this . calFecha1 . setVisible ( true ) ; this . calFecha2 . setVisible ( true ) ; break ; case "Consulta de Promocion" : this . lblParam1 . setText ( "Dias Registrado" ) ; this . lblParam2 . setText ( "Cantidad Maxima de Usuarios" ) ; this . lblEMaxPromo . setVisible ( true ) ; this . lblParam1 . setVisible ( true ) ; this . lblParam2 . setVisible ( true ) ; this . txtParam1 . setVisible ( true ) ; this . txtParam2 . setVisible ( true ) ; this . txtEdadPromo . setVisible ( true ) ; break ; case "Convenios Antiguos" : this . lblParam1 . setText ( "A\u00F1o de Referencia" ) ; this . lblParam1 . setVisible ( true ) ; this . txtParam1 . setVisible ( true ) ; break ; case "Listado de Estaciones Cercanas" : this . lblParam1 . setText ( "Ingrese CI" ) ; this . lblParam1 . setVisible ( true ) ; this . txtParam1 . setVisible ( true ) ; break ; } }
te	4	private void drawBody ( Graphics g ) { int startOffset = valueToPixel ( currentMinValue ) ; if ( ! showGradient || gimage == null ) { g . setColor ( trackColor ) ; g . fill3DRect ( 0 , 0 , getWidth ( ) , getHeight ( ) , true ) ; } else { switch ( orientation ) { case HORIZONTAL : g . drawImage ( gimage , - startOffset , 0 , getTrackSize ( ) - startOffset , getHeight ( ) , 0 , 0 , gimage . getWidth ( null ) , 1 , this ) ; break ; case VERTICAL : g . drawImage ( gimage , 0 , - startOffset , getWidth ( ) , getTrackSize ( ) - startOffset , 0 , 0 , 1 , gimage . getHeight ( null ) , this ) ; break ; } } }
te	1	public void openFile ( File file ) { System . out . println ( file ) ; fileSelectorPanel . openFileOrDirectory ( file ) ; if ( file . isFile ( ) ) { openSimFile ( file . getAbsolutePath ( ) ) ; } }
te	1	public byte [ ] readBytes ( int amount ) { if ( this . bytes . length - this . position < amount ) { throw new IllegalStateException ( "Not enough bytes left." ) ; } byte [ ] r = new byte [ amount ] ; System . arraycopy ( this . bytes , this . position , r , 0 , amount ) ; this . position += amount ; return r ; }
te	8	@ SuppressWarnings ( "incomplete-switch" ) void processInputMessage ( BitTorrentMessage msg ) { assert msg != null ; switch ( msg . getMessageType ( ) ) { case HANDSHAKE_START : HandShakeStart hss = ( HandShakeStart ) msg ; remoteFlags . or ( hss . getFlags ( ) ) ; remoteHash = hss . getHash ( ) ; remoteProtocol = hss . getProtocolName ( ) ; remoteHandShakeStarted = true ; break ; case HANDSHAKE_END : HandShakeEnd hse = ( HandShakeEnd ) msg ; remotePeerId = hse . getPeerId ( ) ; remoteHandShakeFinished = true ; break ; case CHOKE : remoteChoking = true ; break ; case UNCHOKE : remoteChoking = false ; break ; case INTERESTED : remoteInterested = true ; break ; case UNINTERESTED : remoteInterested = false ; break ; case HAVE : remoteClaimedPieces . set ( ( ( HaveMessage ) msg ) . getPieceIndex ( ) ) ; break ; case BITFIELD : remoteClaimedPieces . or ( ( ( BitFieldMessage ) msg ) . getBitField ( ) ) ; break ; } }
te	4	public JSONObject ( String baseName , Locale locale ) throws JSONException { this ( ) ; ResourceBundle bundle = ResourceBundle . getBundle ( baseName , locale , Thread . currentThread ( ) . getContextClassLoader ( ) ) ; Enumeration keys = bundle . getKeys ( ) ; while ( keys . hasMoreElements ( ) ) { Object key = keys . nextElement ( ) ; if ( key instanceof String ) { String [ ] path = ( ( String ) key ) . split ( "\\." ) ; int last = path . length - 1 ; JSONObject target = this ; for ( int i = 0 ; i < last ; i += 1 ) { String segment = path [ i ] ; JSONObject nextTarget = target . optJSONObject ( segment ) ; if ( nextTarget == null ) { nextTarget = new JSONObject ( ) ; target . put ( segment , nextTarget ) ; } target = nextTarget ; } target . put ( path [ last ] , bundle . getString ( ( String ) key ) ) ; } } }
te	8	static int addIf ( IGraph g , int i , IGraph dest ) { IGraph node = new Graph ( Types . if ) ; node . add ( g . get ( i ) . get ( 0 ) . get ( 0 ) . get ( 0 ) ) ; IGraph tru = new Graph ( "!true" ) ; IGraph fal = new Graph ( "!false" ) ; node . add ( tru ) ; node . add ( fal ) ; dest . add ( node ) ; dest = tru ; i ++ ; for ( ; i < g . size ( ) ; i ++ ) { IGraph node2 = g . get ( i ) ; String name = node2 . getName ( ) ; if ( Types . VAR . equals ( name ) || Types . VARE . equals ( name ) ) { String s = null ; if ( node2 . size ( ) == 0 ) break ; s = node2 . get ( 0 ) . getName ( 0 ) ; if ( "if" . equals ( s ) ) { i = addIf ( g , i , dest ) ; } else if ( "for" . equals ( s ) ) { i = addFor ( g , i , dest ) ; } else if ( "else" . equals ( s ) ) { dest = fal ; } else if ( "end" . equals ( s ) ) { return i ; } else dest . add ( node2 ) ; } else dest . add ( node2 ) ; } return i ; }
te	1	private List < Integer > initializeKeys ( ) { final List < Integer > keys = Lists . newArrayList ( ) ; for ( int i = 0 ; i < this . k ; i ++ ) { keys . add ( 0 ) ; } return keys ; }
te	9	private void accumPixels ( int x , int y , int w , int h , ColorModel model , int [ ] pixels , int off , int scansize ) { reds = new long [ destWidth ] ; greens = new long [ destWidth ] ; blues = new long [ destWidth ] ; alphas = new long [ destWidth ] ; int sy = y ; int syrem = destHeight ; int dy = 0 ; int dyrem = 0 ; while ( sy < y + h ) { if ( dyrem == 0 ) { for ( int i = 0 ; i < destWidth ; i ++ ) { alphas [ i ] = reds [ i ] = greens [ i ] = blues [ i ] = 0 ; } dyrem = srcHeight ; } int amty = Math . min ( syrem , dyrem ) ; int sx = 0 ; int dx = 0 ; int sxrem = 0 ; int dxrem = srcWidth ; int a = 0 , r = 0 , g = 0 , b = 0 ; while ( sx < w ) { if ( sxrem == 0 ) { sxrem = destWidth ; int rgb = pixels [ off + sx ] ; a = rgb >>> 24 ; r = ( rgb >> 16 ) & FF ; g = ( rgb >> 8 ) & FF ; b = rgb & FF ; } int amtx = Math . min ( sxrem , dxrem ) ; long mult = ( amtx * amty ) << 32 ; alphas [ dx ] += mult * a ; reds [ dx ] += mult * r ; greens [ dx ] += mult * g ; blues [ dx ] += mult * b ; if ( ( sxrem -= amtx ) == 0 ) sx ++ ; if ( ( dxrem -= amtx ) == 0 ) { dx ++ ; dxrem = srcWidth ; } } if ( ( dyrem -= amty ) == 0 ) { int outpix [ ] = calcRow ( ) ; do { consumer . setPixels ( 0 , dy , destWidth , 1 , rgbModel , outpix , 0 , destWidth ) ; dy ++ ; } while ( ( syrem -= amty ) >= amty && amty == srcHeight ) ; } else syrem -= amty ; if ( syrem == 0 ) { syrem = destHeight ; sy ++ ; off += scansize ; } } }
te	9	@ Override public CompileResult compile ( String className , String code , LibraryEntity [ ] classPathLibs ) { JavaCompiler compiler = ToolProvider . getSystemJavaCompiler ( ) ; final StandardJavaFileManager standardFileManager = compiler . getStandardFileManager ( null , null , null ) ; JavaFileManager fileManager = new ClassFileManager ( className , standardFileManager , classPathLibs ) ; List < JavaFileObject > jfiles = new ArrayList < JavaFileObject > ( ) ; jfiles . add ( new StringJavaFileObject ( className , code ) ) ; DiagnosticCollector < JavaFileObject > diagnostics = new DiagnosticCollector < JavaFileObject > ( ) ; ArrayList < LibraryEntity > javaPlatformJars = new ArrayList < LibraryEntity > ( ) ; if ( classPathLibs != null && classPathLibs . length > 0 ) { for ( LibraryEntity entity : classPathLibs ) { if ( entity . getPlatform ( ) . equals ( Platforms . JAVA ) ) { javaPlatformJars . add ( entity ) ; } } } ArrayList < URL > classPathFiles = new ArrayList < URL > ( ) ; if ( javaPlatformJars . size ( ) > 0 ) { final String libraryBasePath = ApplicationSettings . getInstance ( ) . getLibraryBasePath ( ) ; for ( LibraryEntity entity : javaPlatformJars ) { final String [ ] libNames = entity . getLibNames ( ) ; for ( String libName : libNames ) { try { classPathFiles . add ( new File ( libraryBasePath + libName ) . toURI ( ) . toURL ( ) ) ; } catch ( MalformedURLException e ) { e . printStackTrace ( ) ; } } } } List < String > options = new ArrayList < String > ( ) ; options . add ( "-classpath" ) ; StringBuilder sb = new StringBuilder ( ) ; URLClassLoader urlClassLoader = ( URLClassLoader ) Thread . currentThread ( ) . getContextClassLoader ( ) ; for ( URL url : urlClassLoader . getURLs ( ) ) { sb . append ( url . getFile ( ) . replace ( "%20" , " " ) ) . append ( File . pathSeparator ) ; } for ( URL url : classPathFiles ) { sb . append ( url . getFile ( ) . replace ( "%20" , " " ) ) . append ( File . pathSeparator ) ; } options . add ( sb . toString ( ) ) ; final boolean call = compiler . getTask ( null , fileManager , diagnostics , options , null , jfiles ) . call ( ) ; if ( call ) { return new JavaCompileResult ( JavaCompileResult . RESULT_SUCCESS , null , fileManager ) ; } else { StringBuffer bf = new StringBuffer ( ) ; for ( Diagnostic diagnostic : diagnostics . getDiagnostics ( ) ) { bf . append ( diagnostic . toString ( ) + "\n" ) ; } return new JavaCompileResult ( JavaCompileResult . RESULT_COMPILE_ERROR , bf . toString ( ) , null ) ; } }
te	5	public void actionPerformed ( ActionEvent event ) { JButton selButton = ( JButton ) event . getSource ( ) ; JFrame frame = new JFrame ( ) ; JPanel contentPane = ( JPanel ) frame . getContentPane ( ) ; SimpleDP algo = null ; if ( selButton == m_btnSimpleDP ) { algo = new SimpleDP ( contentPane , "GTACCT" , "GGTGT" ) ; } else if ( selButton == m_btnNW ) { algo = new NeedlemanWunsch ( contentPane , "HEAGAWGHEE" , "PAWHEAE" ) ; } else if ( selButton == m_btnSW ) { algo = new SmithWaterman ( contentPane , "HEAGAWGHEE" , "PAWHEAE" ) ; } else if ( selButton == m_btnFourRussians ) { algo = new FourRussians ( contentPane , "ATGTCA" , "ATTAGTCA" ) ; } else if ( selButton == m_btnNussinov ) { algo = new Nussinov ( contentPane , "GGGAAAUCC" ) ; } frame . setTitle ( "BABA: " + algo . getAlgorithmName ( ) ) ; startNew ( frame ) ; }
te	7	public void extractInfoFromName ( ) { String sg = this . getName ( ) ; sg = sg . trim ( ) . toLowerCase ( ) ; List < String > list = Arrays . asList ( sg . split ( " " ) ) ; for ( String temp : list ) { if ( temp . contains ( "threat" ) ) { String threat = temp . substring ( temp . indexOf ( ":" ) + 1 ) . trim ( ) ; if ( threat . contains ( "(" ) ) { threat = threat . substring ( 0 , threat . indexOf ( "(" ) ) . trim ( ) ; } this . setThreat ( threat ) ; } else if ( temp . contains ( "asset" ) ) { this . setAsset ( temp . substring ( temp . indexOf ( ":" ) + 1 ) . trim ( ) ) ; } else if ( temp . contains ( "target" ) ) { this . setTarget ( temp . substring ( temp . indexOf ( ":" ) + 1 ) . trim ( ) ) ; } else if ( temp . contains ( "interval" ) ) { this . setInterval ( temp . substring ( temp . indexOf ( ":" ) + 1 ) . trim ( ) ) ; } else { System . out . println ( "There is an exception!" ) ; } } if ( this . getFormalExpressions ( ) . indexOf ( ":" ) > 0 ) { System . out . println ( "Import error ':'!" ) ; } }
te	3	@ Override public int hashCode ( ) { int result = unit != null ? unit . hashCode ( ) : 0 ; result = 31 * result + ( unitCommandType != null ? unitCommandType . hashCode ( ) : 0 ) ; result = 31 * result + ( target != null ? target . hashCode ( ) : 0 ) ; result = 31 * result + x ; result = 31 * result + y ; result = 31 * result + extra ; return result ; }
te	5	private boolean r_Step_1a ( ) { int among_var ; ket = cursor ; among_var = find_among_b ( a_0 , 4 ) ; if ( among_var == 0 ) { return false ; } bra = cursor ; switch ( among_var ) { case 0 : return false ; case 1 : slice_from ( "ss" ) ; break ; case 2 : slice_from ( "i" ) ; break ; case 3 : slice_del ( ) ; break ; } return true ; }
te	1	public static Service createService ( Integer idService ) throws ClassNotFoundException , SQLException { assert idService != null ; String abbr = null ; String name = null ; String url = null ; Connection connect = ConfigDb . getDbConnection ( ) ; PreparedStatement pstmt ; ResultSet resultSet ; pstmt = connect . prepareStatement ( "SELECT skratka  nazov  url FROM sluzba WHERE id = ?" ) ; pstmt . setInt ( 1 , idService ) ; resultSet = pstmt . executeQuery ( ) ; while ( resultSet . next ( ) ) { abbr = resultSet . getString ( "skratka" ) ; name = resultSet . getString ( "nazov" ) ; url = resultSet . getString ( "url" ) ; } resultSet . close ( ) ; pstmt . close ( ) ; connect . close ( ) ; return new MyService ( idService , abbr , name , url ) ; }
te	6	private String get_sub_ct ( char [ ] [ ] pt , int start_col , int end_col , int [ ] [ ] key_square ) { int row = pt . length ; char [ ] [ ] result_ct = new char [ row ] [ end_col - start_col ] ; StringBuilder sb = new StringBuilder ( ) ; for ( int i = start_col ; i < end_col ; i ++ ) { for ( int j = 0 ; j < row ; j ++ ) { if ( pt [ j ] [ i ] ==  ) continue ; result_ct [ key_square [ j ] [ i - start_col ] - 1 ] [ i - start_col ] = pt [ j ] [ i ] ; } } for ( int i = 0 ; i < end_col - start_col ; i ++ ) { for ( int j = 0 ; j < row ; j ++ ) { if ( result_ct [ j ] [ i ] !=  ) { sb . append ( result_ct [ j ] [ i ] ) ; } } } return sb . toString ( ) ; }
te	7	public int MarketSell ( String product , String strTime , double price , int amount ) { try { SimpleDateFormat ft = new SimpleDateFormat ( "yyyy-MM-dd HH:mm:ss" ) ; Date time = ft . parse ( strTime ) ; Transaction tx = this . session . beginTransaction ( ) ; Query q = session . createQuery ( "from Position where product = :product" ) ; q . setParameter ( "product" , product ) ; List list = q . list ( ) ; Position p = null ; if ( list . size ( ) == 0 ) { p = new Position ( this . account , product , amount * - 1 ) ; session . save ( p ) ; this . OpenSellTransaction ( time , product , price , amount ) ; } else if ( list . size ( ) == 1 ) { p = ( Position ) list . get ( 0 ) ; int totalAmount = p . getAmount ( ) - amount ; if ( p . getAmount ( ) < 0 ) { p . setAmount ( totalAmount ) ; session . update ( p ) ; this . OpenSellTransaction ( time , product , price , amount ) ; } else if ( p . getAmount ( ) > 0 ) { if ( totalAmount < 0 ) { throw new CloseMoreThanOpened ( ) ; } else if ( totalAmount == 0 ) { session . delete ( p ) ; this . CloseSellTransaction ( time , product , price , amount ) ; } else { p . setAmount ( totalAmount ) ; session . update ( p ) ; this . CloseSellTransaction ( time , product , price , amount ) ; } } } else { throw new MultiplePositions ( product ) ; } tx . commit ( ) ; System . out . println ( String . format ( "%s - sell %d mini lot %s at %f" , strTime , amount , product , price ) ) ; return p . getId ( ) ; } catch ( ParseException ex ) { System . out . println ( "Error occurred when parsing " + strTime ) ; ex . printStackTrace ( ) ; } return 0 ; }
te	0	@ Override public void mouseEntered ( MouseEvent e ) { ( ( JPanel ) e . getSource ( ) ) . setBorder ( new LineBorder ( Color . BLUE ) ) ; }
