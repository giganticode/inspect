tr	6	@ Test public void requestCreation ( ) { TeleSignRequest tr ; if ( ! timeouts && ! isHttpsProtocolSet ) tr = new TeleSignRequest ( "https://rest.telesign.com" , "/v1/phoneid/standard/15551234567" , "GET" , "customer_id" , "secret_key" ) ; else if ( timeouts && ! isHttpsProtocolSet ) tr = new TeleSignRequest ( "https://rest.telesign.com" , "/v1/phoneid/standard/15551234567" , "GET" , "customer_id" , "secret_key" , connectTimeout , readTimeout ) ; else if ( ! timeouts && isHttpsProtocolSet ) tr = new TeleSignRequest ( "https://rest.telesign.com" , "/v1/phoneid/standard/15551234567" , "GET" , "customer_id" , "secret_key" , HTTPS_PROTOCOL ) ; else tr = new TeleSignRequest ( "https://rest.telesign.com" , "/v1/phoneid/standard/15551234567" , "GET" , "customer_id" , "secret_key" , connectTimeout , readTimeout , HTTPS_PROTOCOL ) ; assertNotNull ( tr ) ; }
tr	4	@ Override public void showHints ( int level ) { for ( int x = 1 ; x <= 16 ; x ++ ) { for ( int y = 1 ; y <= 16 ; y ++ ) { Point p = new Point ( x , y ) ; if ( ! isReadOnly ( p ) ) { BitSet markUp = getHints ( p , level ) ; if ( level == 0 ) { System . out . println ( String . format ( "(%s  %s) : %s" , x , y , markUp ) ) ; } else { System . out . println ( String . format ( "(%s  %s) : %s [%s]" , x , y , markUp , getHints ( p , 0 ) ) ) ; } } } } System . out . println ( ) ; }
tr	8	public static ListNode getCycleStartNodeNonEntraSpace ( ListNode head ) { if ( head == null ) { return null ; } ListNode pointer1 = head ; ListNode pointer2 = head ; while ( pointer1 != null && pointer2 != null ) { pointer1 = pointer1 . next ; if ( pointer2 . next == null ) { return null ; } pointer2 = pointer2 . next . next ; if ( pointer1 == pointer2 ) { break ; } } if ( pointer1 == null || pointer2 == null ) { return null ; } pointer1 = head ; while ( pointer1 != pointer2 ) { pointer1 = pointer1 . next ; pointer2 = pointer2 . next ; } return pointer1 ; }
tr	8	private void method362 ( int i , int ai [ ] , byte abyte0 [ ] , int j , int k , int l , int i1 , int ai1 [ ] , int j1 ) { int k1 = - ( l >> 2 ) ; l = - ( l & 3 ) ; for ( int l1 = - i ; l1 < 0 ; l1 ++ ) { for ( int i2 = k1 ; i2 < 0 ; i2 ++ ) { byte byte1 = abyte0 [ i1 ++ ] ; if ( byte1 != 0 ) ai [ k ++ ] = ai1 [ byte1 & ff ] ; else k ++ ; byte1 = abyte0 [ i1 ++ ] ; if ( byte1 != 0 ) ai [ k ++ ] = ai1 [ byte1 & ff ] ; else k ++ ; byte1 = abyte0 [ i1 ++ ] ; if ( byte1 != 0 ) ai [ k ++ ] = ai1 [ byte1 & ff ] ; else k ++ ; byte1 = abyte0 [ i1 ++ ] ; if ( byte1 != 0 ) ai [ k ++ ] = ai1 [ byte1 & ff ] ; else k ++ ; } for ( int j2 = l ; j2 < 0 ; j2 ++ ) { byte byte2 = abyte0 [ i1 ++ ] ; if ( byte2 != 0 ) ai [ k ++ ] = ai1 [ byte2 & ff ] ; else k ++ ; } k += j ; i1 += j1 ; } }
tr	6	public void submitUnformatted ( final String data ) { assertConnected ( ) ; int index = 0 ; for ( int y = 0 ; y < screen . getHeight ( ) && index < data . length ( ) ; y ++ ) { for ( int x = 0 ; x < screen . getWidth ( ) && index < data . length ( ) ; x ++ ) { final char newCh = data . charAt ( index ) ; if ( newCh != screen . charAt ( x , y ) ) { doCommand ( "movecursor (" + y + "  " + x + ")" ) ; if ( ! Integer . toHexString ( newCh ) . equals ( "0" ) ) { doCommand ( "key (0x" + Integer . toHexString ( newCh ) + ")" ) ; } } index ++ ; } index ++ ; } }
tr	0	protected void informNextPlayerToGo ( String currentIP , int currentPort ) { int nextPlayerToGo = getNextTurnPlayerID ( pg . getPlayerIndex ( currentIP , currentPort ) ) ; srvrWaitingOnPlayerIndex = nextPlayerToGo ; pg . broadcastMessage ( "sTurn " + pg . getPlayer ( nextPlayerToGo ) . getNickName ( ) ) ; }
tr	5	protected static void validateCertificateChain ( Certificate [ ] ownCerts , Certificate [ ] native_certs ) throws Exception { if ( ownCerts == null ) return ; if ( native_certs == null ) throw new Exception ( "Unable to validate certificate chain. Native entry did not have a certificate chain at all" ) ; if ( ownCerts . length != native_certs . length ) throw new Exception ( "Unable to validate certificate chain. Chain differs in length [" + ownCerts . length + " vs " + native_certs . length + "]" ) ; for ( int i = 0 ; i < ownCerts . length ; i ++ ) if ( ! ownCerts [ i ] . equals ( native_certs [ i ] ) ) throw new Exception ( "Certificate mismatch: " + ownCerts [ i ] + " != " + native_certs [ i ] ) ; }
tr	6	private void startLevel ( ) { if ( currentlesson . isNoteLevel ( ) ) { if ( ! noteLevel . isMessageEmpty ( ) ) { levelMessage . setTitle ( bundle . getString ( "_information" ) ) ; textlevelMessage . setText ( "  " + noteLevel . getMessage ( ) + "  " ) ; levelMessage . pack ( ) ; levelMessage . setLocationRelativeTo ( this ) ; levelMessage . setVisible ( true ) ; } else { startButton . doClick ( ) ; } } else if ( currentlesson . isRhythmLevel ( ) ) { if ( ! rhythmLevel . isMessageEmpty ( ) ) { levelMessage . setTitle ( bundle . getString ( "_information" ) ) ; textlevelMessage . setText ( "  " + rhythmLevel . getMessage ( ) + "  " ) ; levelMessage . pack ( ) ; levelMessage . setLocationRelativeTo ( this ) ; levelMessage . setVisible ( true ) ; } else { startButton . doClick ( ) ; } } else if ( currentlesson . isScoreLevel ( ) ) { if ( ! scoreLevel . isMessageEmpty ( ) ) { levelMessage . setTitle ( bundle . getString ( "_information" ) ) ; textlevelMessage . setText ( "  " + scoreLevel . getMessage ( ) + "  " ) ; levelMessage . pack ( ) ; levelMessage . setLocationRelativeTo ( this ) ; levelMessage . setVisible ( true ) ; } else { startButton . doClick ( ) ; } } }
tr	2	public static void main ( String [ ] args ) { int x = 5 ; if ( x < 5 ) if ( x > 5 ) System . out . println ( b ) ; else System . out . println ( a ) ; }
tr	1	public void setEnabled ( boolean enabled ) { super . setEnabled ( enabled ) ; comboBox . setEnabled ( enabled ) ; if ( spinner != null ) { spinner . setEnabled ( enabled ) ; } }
tr	9	private void jcbParentescoItemStateChanged ( java . awt . event . ItemEvent evt ) { parentesco = jcbParentesco . getSelectedItem ( ) . toString ( ) ; codParentesco = parentesco . charAt ( 0 ) ; if ( evt . getStateChange ( ) == ItemEvent . SELECTED && i != 0 ) { if ( parentesco . equalsIgnoreCase ( "Papa" ) ) { jcbSexo . setSelectedIndex ( 0 ) ; jcbSexo . setEnabled ( false ) ; if ( RegistroTranslado . size ( ) > 0 ) { if ( Integer . parseInt ( RegistroTranslado . get ( nf ) . toString ( ) ) == 0 ) { txtHistoriaNueva . setText ( codCarpeta + "-A" ) ; } } System . out . println ( "JF es :" + jf ) ; System . out . println ( "Entro en papa itemselected" ) ; } else { if ( parentesco . equalsIgnoreCase ( "Mama" ) ) { jcbSexo . setSelectedIndex ( 1 ) ; jcbSexo . setEnabled ( false ) ; if ( RegistroTranslado . size ( ) > 0 ) { if ( Integer . parseInt ( RegistroTranslado . get ( nf ) . toString ( ) ) == 0 ) { txtHistoriaNueva . setText ( codCarpeta + "-B" ) ; } } System . out . println ( "Entro en mama itemselected" ) ; } else { if ( parentesco . equalsIgnoreCase ( "hijo(a)" ) ) { jcbSexo . setEnabled ( true ) ; if ( RegistroTranslado . size ( ) > 0 ) { if ( Integer . parseInt ( RegistroTranslado . get ( nf ) . toString ( ) ) == 0 ) { letraHis = obtener_letra ( cantHis ) ; codHistoria = codCarpeta + "-" + letraHis ; txtHistoriaNueva . setText ( codHistoria ) ; if ( FilaJefe == - 1 ) { jcheckBoxJefeCarpeta . setEnabled ( true ) ; } } } } else { jcheckBoxJefeCarpeta . setEnabled ( false ) ; jcheckBoxJefeCarpeta . setSelected ( false ) ; } } } } else i ++ ; }
tr	3	public static void main ( String [ ] args ) { Scanner cin = new Scanner ( System . in ) ; int n , d , m ; while ( ( n = cin . nextInt ( ) ) >= 0 ) { d = cin . nextInt ( ) ; m = getReverseInt ( n , d ) ; if ( isP ( n ) && isP ( m ) ) System . out . println ( "Yes" ) ; else System . out . println ( "No" ) ; } }
tr	1	private void flushMemoryTable ( ) { changeTablesLock . lock ( ) ; try { memoryTableAccessor . useAuxiliary ( ) ; } finally { changeTablesLock . unlock ( ) ; } DiskTable diskTable ; try { MemoryTable memoryTable = memoryTableAccessor . getMainDataTable ( ) ; Path newTableFile = diskTableAccessor . newPathForTable ( ) ; Flusher flusher = new Flusher ( newTableFile , diskTableAccessor . blockSize ( ) ) ; System . out . println ( "NODE: INFO: Flushing memory table to " + newTableFile ) ; diskTable = flusher . flush ( memoryTable , memoryTable . timestamp ( ) ) ; } catch ( IOException e ) { System . out . println ( "NODE: EXCEPTION: " + e ) ; throw new RuntimeException ( e ) ; } changeTablesLock . lock ( ) ; try { diskTableAccessor . addDisk ( diskTable ) ; memoryTableAccessor . stopUsingAuxiliary ( ) ; commitLog . reset ( ) ; } finally { changeTablesLock . unlock ( ) ; } }
tr	2	public static int search_str ( String [ ] s , String key ) { for ( int i = 0 ; i < s . length ; i ++ ) { if ( s [ i ] . equals ( key ) ) return i ; } return - 1 ; }
tr	7	@ Override public void execute ( CharSequence str ) { HasSubSection selectedItem = editor . getSelectedItem ( ) ; if ( selectedItem instanceof Section && ( ( Section ) selectedItem ) . getParent ( ) instanceof Section ) { Section section = ( Section ) selectedItem ; Section parent = ( Section ) section . getParent ( ) ; int index = 0 ; while ( ! parent . getSubSection ( index ) . equals ( section ) ) ++ index ; List < Section > sectionToAdd = new ArrayList < Section > ( ) ; while ( parent . getSubSectionNb ( ) > index + 1 ) { sectionToAdd . add ( parent . getSubSection ( index + 1 ) ) ; parent . removeSubSection ( index + 1 ) ; } for ( int i = 0 ; i < sectionToAdd . size ( ) ; ++ i ) { section . addSubSection ( sectionToAdd . get ( i ) ) ; } parent . removeSubSection ( index ) ; int indexParent = 0 ; while ( indexParent < parent . getParent ( ) . getSubSectionNb ( ) && ! parent . getParent ( ) . getSubSection ( indexParent ) . equals ( section ) ) ++ indexParent ; parent . getParent ( ) . insertSubSection ( section , indexParent ) ; } }
tr	4	public boolean isWalkable ( ) { return ( tileType . equals ( Empty ) || tileType . equals ( OpenedDoor ) || tileType . equals ( StairsUp ) || tileType . equals ( StairsDown ) ) && tileContent . stream ( ) . filter ( p -> p . isOccupiesWholeTile ( ) ) . count ( ) <= 0 ; }
tr	3	private void addMountanSides ( ) { for ( int i = 0 ; i < map . length - 2 ; i ++ ) { for ( int j = 0 ; j < map [ 0 ] . length - 2 ; j ++ ) { if ( map [ i ] [ j ] . existTileOfType ( new Mountains ( ) ) ) { map [ i ] [ j + 1 ] . add ( new MountainSide ( ) ) ; map [ i ] [ j + 2 ] . add ( new MountainSide ( ) ) ; } } } }
tr	4	@ Override public String toString ( ) { StringBuilder result = new StringBuilder ( ) ; boolean first = true ; for ( Map . Entry < String , LinkedHashSet < String >> pair : values . entrySet ( ) ) { if ( ! first ) result . append ( / ) ; result . append ( pair . getKey ( ) ) ; for ( String v : pair . getValue ( ) ) { if ( identRegex . matcher ( v ) . matches ( ) ) result . append ( . ) . append ( v ) ; else result . append ( ".'" ) . append ( v . replace ( "'" , "\\'" ) ) . append ( ' ) ; } first = false ; } return result . toString ( ) ; }
tr	9	public static void main ( String [ ] args ) { boolean ok = false ; long startTime , endTime ; LinkedList < Drone > mDroneArm = new LinkedList < > ( ) ; DroneQueue droneQueue = new DroneQueue ( mDroneArm ) ; Config config = Config . getInstance ( ) ; config . load ( "config.xml" ) ; clearKMLs ( ) ; String dirs [ ] = config . getOption ( Config . GTFS_DIRS ) . split ( " " ) ; int timeGap = config . getIntOption ( Config . GTFS_TIME_GAP ) ; GraphFrame gp = null ; if ( config . getBooleanOption ( Config . DEBUG_DISPLAY ) ) { gp = new GraphFrame ( ) ; } final String password = Config . getInstance ( ) . getOption ( Config . SERVER_PASSWORD ) ; final int port = Config . getInstance ( ) . getIntOption ( Config . SERVER_PORT ) ; GPSPortal g = new GPSPortal ( port , password ) ; int id = 1 ; final double busSpeed = Config . getInstance ( ) . getDoubleOption ( Config . DRONE_SPEED ) ; final double busUpdateTime = Config . getInstance ( ) . getDoubleOption ( Config . DRONE_UPDATE_SPEED ) ; boolean dronesActive = config . getBooleanOption ( Config . DRONES_ACTIVE ) ; if ( dronesActive ) { System . out . println ( "Drones Active!" ) ; } ArrayList < GTFS > gtfs = new ArrayList < > ( ) ; for ( String dir : dirs ) { dir = dir . trim ( ) ; System . out . println ( dir + "\n----------" ) ; try { startTime = System . currentTimeMillis ( ) ; GTFS current = new GTFS ( dir , timeGap ) ; gtfs . add ( current ) ; endTime = System . currentTimeMillis ( ) ; System . out . println ( dir + " loaded and parsed in " + ( ( endTime - startTime ) / 1000.0 ) + " seconds" ) ; System . out . println ( dir + " id: " + current . getID ( ) ) ; if ( config . getBooleanOption ( Config . DEBUG_DISPLAY ) ) { gp . adjustViewport ( current . getMinLon ( ) , current . getMinLat ( ) , current . getMaxLon ( ) , current . getMaxLat ( ) ) ; gp . addPaths ( current . getPaths ( ) ) ; } if ( dronesActive ) { for ( int i = 0 ; i < current . getPaths ( ) . size ( ) ; i ++ ) { int now = timeToMinutes ( new SimpleDateFormat ( "HH:mm:ss" ) . format ( new Date ( ) ) ) ; if ( current . isValidService ( current . getPaths ( ) . get ( i ) . getServiceID ( ) ) && current . getPaths ( ) . get ( i ) . getEndTimecode ( ) > now ) { System . out . println ( dir + ": " + current . getPaths ( ) . get ( i ) ) ; droneQueue . addDrone ( new Drone ( id , current . getPaths ( ) . get ( i ) , busSpeed , busUpdateTime , "http://127.0.0.1:8080" , password , false ) ) ; id ++ ; } } } ok = true ; } catch ( Exception e ) { System . out . println ( e . toString ( ) ) ; System . exit ( - 1 ) ; } System . out . println ( ) ; } if ( config . getBooleanOption ( Config . DEBUG_DISPLAY ) ) { gp . setVisible ( true ) ; } boolean running = true ; int vListTimeout = Config . getInstance ( ) . getIntOption ( Config . VEHICLE_LIST_TIMEOUT ) ; System . out . println ( "Running..." ) ; while ( running ) { int now = timeToMinutes ( new SimpleDateFormat ( "HH:mm:ss" ) . format ( new Date ( ) ) ) ; Vehicle . cleanUp ( vListTimeout ) ; droneQueue . check ( now ) ; try { Thread . sleep ( 1000 ) ; } catch ( InterruptedException ex ) { Logger . getLogger ( WTBBackend . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } System . gc ( ) ; running = ! droneQueue . isEmpty ( ) ; } }
tr	2	public static AttributeTable getDefaultAttributeTable ( ) { if ( defaultAttributeTable == null ) { defaultAttributeTable = new AttributeTable ( ) ; for ( int i = 0 ; i < attrs . length ; i ++ ) { defaultAttributeTable . install ( attrs [ i ] ) ; } attrHref = defaultAttributeTable . lookup ( "href" ) ; attrSrc = defaultAttributeTable . lookup ( "src" ) ; attrId = defaultAttributeTable . lookup ( "id" ) ; attrName = defaultAttributeTable . lookup ( "name" ) ; attrSummary = defaultAttributeTable . lookup ( "summary" ) ; attrAlt = defaultAttributeTable . lookup ( "alt" ) ; attrLongdesc = defaultAttributeTable . lookup ( "longdesc" ) ; attrUsemap = defaultAttributeTable . lookup ( "usemap" ) ; attrIsmap = defaultAttributeTable . lookup ( "ismap" ) ; attrLanguage = defaultAttributeTable . lookup ( "language" ) ; attrType = defaultAttributeTable . lookup ( "type" ) ; attrTitle = defaultAttributeTable . lookup ( "title" ) ; attrXmlns = defaultAttributeTable . lookup ( "xmlns" ) ; attrValue = defaultAttributeTable . lookup ( "value" ) ; attrContent = defaultAttributeTable . lookup ( "content" ) ; attrDatafld = defaultAttributeTable . lookup ( "datafld" ) ; ; attrWidth = defaultAttributeTable . lookup ( "width" ) ; ; attrHeight = defaultAttributeTable . lookup ( "height" ) ; ; attrAlt . nowrap = true ; attrValue . nowrap = true ; attrContent . nowrap = true ; } return defaultAttributeTable ; }
tr	9	public final void loadTerrainBlock ( byte blockData [ ] , int blockY , int blockX , int k , int l , CollisionMap collisionMap [ ] ) { for ( int plane = 0 ; plane < 4 ; plane ++ ) { for ( int tileX = 0 ; tileX < 64 ; tileX ++ ) { for ( int tileY = 0 ; tileY < 64 ; tileY ++ ) if ( blockX + tileX > 0 && blockX + tileX < 103 && blockY + tileY > 0 && blockY + tileY < 103 ) collisionMap [ plane ] . clippingData [ blockX + tileX ] [ blockY + tileY ] &= feffffff ; } } Buffer stream = new Buffer ( blockData ) ; for ( int plane = 0 ; plane < 4 ; plane ++ ) { for ( int tileX = 0 ; tileX < 64 ; tileX ++ ) { for ( int tileY = 0 ; tileY < 64 ; tileY ++ ) loadTerrainTile ( tileY + blockY , l , stream , tileX + blockX , plane , 0 , k ) ; } } }
tr	4	@ Override public void actionPerformed ( ActionEvent e ) { if ( e . getSource ( ) == btnAggiungi ) { Utente utente = new Utente ( textFieldNome . getText ( ) . trim ( ) , textFieldCognome . getText ( ) . trim ( ) , textFieldUsername . getText ( ) . trim ( ) , new String ( passwordField . getPassword ( ) ) . trim ( ) ) ; switch ( choiceUserType . getSelectedItem ( ) ) { case "Cliente" : { utente . setUserType ( Utente . CLIENTE ) ; break ; } case "Operatore" : { utente . setUserType ( Utente . OPERATORE ) ; break ; } case "Administrator" : { utente . setUserType ( Utente . ADMIN ) ; break ; } } model . addItem ( utente ) ; JOptionPane . showMessageDialog ( null , new JLabel ( "Utente inserito" ) ) ; setVisible ( false ) ; } }
tr	2	@ Override protected void _loadApps ( ) { String [ ] appClassList = config ( ) . getAsStringVec ( "console.apps" ) ; if ( appClassList == null ) return ; for ( String appClassname : appClassList ) { loadApp ( appClassname ) ; } }
tr	1	public static TextureRegion get ( int x , int y , int width , int height ) { if ( texture == null ) texture = new Texture ( "spritesheet.png" , GL_LINEAR , GL_LINEAR ) ; return new TextureRegion ( texture , x , y , width , height ) ; }
tr	6	static private final int jjMoveStringLiteralDfa13_0 ( long old0 , long active0 ) { if ( ( ( active0 &= old0 ) ) == 0 ) return jjStartNfa_0 ( 11 , old0 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 12 , active0 ) ; return 13 ; } switch ( curChar ) { case 67 : return jjMoveStringLiteralDfa14_0 ( active0 , 20 ) ; case 95 : return jjMoveStringLiteralDfa14_0 ( active0 , 1000 ) ; case 97 : return jjMoveStringLiteralDfa14_0 ( active0 , 2000 ) ; case 122 : return jjMoveStringLiteralDfa14_0 ( active0 , 40 ) ; default : break ; } return jjStartNfa_0 ( 12 , active0 ) ; }
tr	8	@ Override protected byte [ ] packFrameData ( ) { byte [ ] bytes = new byte [ getLength ( ) ] ; if ( description != null ) bytes [ 0 ] = description . getTextEncoding ( ) ; else bytes [ 0 ] = 0 ; int mimeTypeLength = 0 ; if ( mimeType != null && mimeType . length ( ) > 0 ) { mimeTypeLength = mimeType . length ( ) ; try { BufferTools . stringIntoByteBuffer ( mimeType , 0 , mimeTypeLength , bytes , 1 ) ; } catch ( UnsupportedEncodingException e ) { } } int marker = mimeTypeLength + 1 ; bytes [ marker ++ ] = 0 ; bytes [ marker ++ ] = pictureType ; if ( description != null && description . toBytes ( ) . length > 0 ) { byte [ ] descriptionBytes = description . toBytes ( true , true ) ; BufferTools . copyIntoByteBuffer ( descriptionBytes , 0 , descriptionBytes . length , bytes , marker ) ; marker += descriptionBytes . length ; } else { bytes [ marker ++ ] = 0 ; } if ( imageData != null && imageData . length > 0 ) { BufferTools . copyIntoByteBuffer ( imageData , 0 , imageData . length , bytes , marker ) ; } return bytes ; }
tr	2	@ Override public List < case > parse ( String data ) { final Scanner sc = new Scanner ( data ) ; final List < case > cases = Lists . newArrayList ( ) ; long num_cases = sc . nextLong ( ) ; for ( int case_num = 0 ; case_num < num_cases ; case_num ++ ) { final int numWords = sc . nextInt ( ) ; final List < String > words = Lists . newArrayList ( ) ; for ( int i = 0 ; i < numWords ; i ++ ) { words . add ( sc . next ( ) ) ; } case aCase = new case ( words ) ; cases . add ( aCase ) ; } return cases ; }
tr	2	private String protect ( String s ) { int cur_pos = 0 ; while ( true ) { cur_pos = findFirstIndex ( s , cur_pos , "{}\\" ) ; if ( cur_pos < 0 ) return s ; s = s . substring ( 0 , cur_pos ) + "\\" + s . substring ( cur_pos ) ; cur_pos += 2 ; } }
tr	9	private boolean r_Step_4 ( ) { int among_var ; int v_1 ; ket = cursor ; among_var = find_among_b ( a_7 , 18 ) ; if ( among_var == 0 ) { return false ; } bra = cursor ; if ( ! r_R2 ( ) ) { return false ; } switch ( among_var ) { case 0 : return false ; case 1 : slice_del ( ) ; break ; case 2 : lab0 : do { v_1 = limit - cursor ; lab1 : do { if ( ! ( eq_s_b ( 1 , "s" ) ) ) { break lab1 ; } break lab0 ; } while ( false ) ; cursor = limit - v_1 ; if ( ! ( eq_s_b ( 1 , "t" ) ) ) { return false ; } } while ( false ) ; slice_del ( ) ; break ; } return true ; }
tr	9	protected int get_allocationlength ( Header header ) { if ( header . version ( ) == Header . MPEG1 ) { int channel_bitrate = header . bitrate_index ( ) ; if ( header . mode ( ) != Header . SINGLE_CHANNEL ) if ( channel_bitrate == 4 ) channel_bitrate = 1 ; else channel_bitrate -= 4 ; if ( channel_bitrate == 1 || channel_bitrate == 2 ) if ( subbandnumber <= 1 ) return 4 ; else return 3 ; else if ( subbandnumber <= 10 ) return 4 ; else if ( subbandnumber <= 22 ) return 3 ; else return 2 ; } else { if ( subbandnumber <= 3 ) return 4 ; else if ( subbandnumber <= 10 ) return 3 ; else return 2 ; } }
tr	1	public boolean createAccount ( String login , String password ) { if ( logins . containsKey ( login + password ) ) { return false ; } else { logins . put ( login + password , null ) ; return true ; } }
tr	9	@ Override public Set < String > keySet ( ) { return new Set < String > ( ) { @ Override public int size ( ) { return size ; } @ Override public boolean isEmpty ( ) { return size == 0 ; } @ Override public boolean contains ( Object o ) { return get ( ( String ) o ) != null ; } @ Override public Iterator < String > iterator ( ) { return new Iterator < String > ( ) { private final Iterator < WrappedString > topLevelIterator = store . keySet ( ) . iterator ( ) ; private Iterator < String > currentIterator = topLevelIterator . hasNext ( ) ? store . get ( topLevelIterator . next ( ) ) . getValue ( ) . keySet ( ) . iterator ( ) : null ; @ Override public void remove ( ) { throw new UnsupportedOperationException ( "Read only data set" ) ; } @ Override public boolean hasNext ( ) { return currentIterator != null ; } @ Override public String next ( ) { String toReturn ; toReturn = currentIterator . next ( ) ; if ( currentIterator . hasNext ( ) ) { return toReturn ; } while ( topLevelIterator . hasNext ( ) && ! ( currentIterator = store . get ( topLevelIterator . next ( ) ) . getValue ( ) . keySet ( ) . iterator ( ) ) . hasNext ( ) ) ; if ( ! currentIterator . hasNext ( ) ) { currentIterator = null ; } return toReturn ; } } ; } @ Override public Object [ ] toArray ( ) { throw new UnsupportedOperationException ( "Not yet" ) ; } @ Override public < T > T [ ] toArray ( T [ ] a ) { throw new UnsupportedOperationException ( "Not yet" ) ; } @ Override public boolean add ( String e ) { throw new UnsupportedOperationException ( "Read only data set" ) ; } @ Override public boolean remove ( Object o ) { throw new UnsupportedOperationException ( "Read only data set" ) ; } @ Override public boolean containsAll ( Collection < ? > c ) { throw new UnsupportedOperationException ( "Not yet" ) ; } @ Override public boolean addAll ( Collection < ? extends String > c ) { throw new UnsupportedOperationException ( "Read only data set" ) ; } @ Override public boolean retainAll ( Collection < ? > c ) { throw new UnsupportedOperationException ( "Read only data set" ) ; } @ Override public boolean removeAll ( Collection < ? > c ) { throw new UnsupportedOperationException ( "Read only data set" ) ; } @ Override public void clear ( ) { throw new UnsupportedOperationException ( "Read only data set" ) ; } } ; }
tr	5	private static void manageArgs ( String [ ] args ) { for ( int i = 0 ; i < args . length ; i ++ ) { switch ( args [ i ] . trim ( ) . toLowerCase ( ) ) { case "nogui" : nogui = true ; break ; case "server" : startServer = true ; break ; case "port" : if ( i < args . length - 1 ) { port = parsePositiveInt ( args [ ++ i ] ) ; } else { System . err . println ( "Found argument 'port'  but no port was given" ) ; System . exit ( 1 ) ; } break ; default : System . err . println ( "Unknown command: " + args [ i ] . trim ( ) . toLowerCase ( ) ) ; System . exit ( 1 ) ; break ; } } }
tr	3	@ Override public void printOptions ( ) { if ( getSuccessors ( ) == null || getSuccessors ( ) . size ( ) == 0 ) { return ; } Printer . print ( Settings_Output . OUT_OPTION_HEAD , "Please choose an option" ) ; Integer i = 0 ; for ( final IAction action : getSuccessors ( ) ) { Printer . print ( Settings_Output . OUT_OPTION , i , action . getName ( ) , action . getDescription ( ) ) ; i ++ ; } }
tr	9	private boolean fourInARow ( int row , int col , Location [ ] [ ] boardLocations ) { int columnLength = boardLocations [ row ] . length ; int rowLength = boardLocations . length ; int startRow ; int currentRow ; int startColumn ; int currentColumn ; int matches = 0 ; boolean fourOfAKindFound = false ; int i , j , k ; for ( i = 0 ; i < rowLength ; i ++ ) { Location [ ] rowlocations = boardLocations [ i ] ; for ( j = 0 , startColumn = 0 , currentColumn = 0 , matches = 0 ; j < columnLength - 1 ; j ++ ) { if ( rowlocations [ j ] . getPlayer ( ) == rowlocations [ j + 1 ] . getPlayer ( ) ) { currentColumn ++ ; if ( rowlocations [ j ] . getPlayer ( ) != null ) matches ++ ; else startColumn = currentColumn ; } else if ( matches < 3 ) { currentColumn ++ ; startColumn = currentColumn ; matches = 0 ; } else { for ( k = startColumn ; k <= currentColumn ; k ++ ) { rowlocations [ k ] . setDeleteFlag ( ) ; } currentColumn ++ ; startColumn = currentColumn ; matches = 0 ; fourOfAKindFound = true ; } } if ( matches > 3 ) fourOfAKindFound = true ; } for ( j = 0 ; j < columnLength ; j ++ ) { for ( i = 0 , matches = 0 , startRow = 0 , currentRow = 0 ; i < rowLength - 1 ; i ++ ) { if ( boardLocations [ i ] [ j ] . getPlayer ( ) == boardLocations [ i + 1 ] [ j ] . getPlayer ( ) ) { currentRow ++ ; if ( boardLocations [ i ] [ j ] . getPlayer ( ) != null ) matches ++ ; else startRow = currentRow ; } else if ( matches < 3 ) { currentRow ++ ; startRow = currentRow ; matches = 0 ; } else { for ( k = startRow ; k <= currentRow ; k ++ ) { boardLocations [ k ] [ j ] . setDeleteFlag ( ) ; } currentRow ++ ; startRow = currentRow ; matches = 0 ; fourOfAKindFound = true ; } } if ( matches > 3 ) fourOfAKindFound = true ; } return fourOfAKindFound ; }
tr	3	public void testShortUrlGenerationWithMRUCache ( ) { MRUHashtable < String , String > mruCache = new MRUHashtable < String , String > ( 1000 ) ; ShortUrl min = ShortUrl . getMinShortUrl ( ) ; ShortUrlGenerator . instance ( ) . initialize ( min ) ; try { for ( int i = 0 ; i < 10000 ; ++ i ) { String key = "Key" + i ; String s = ShortUrlGenerator . instance ( ) . getNextShortUrl ( ) . getUrlString ( ) ; System . out . println ( "\nGenerated " + i + " short url:" + s ) ; mruCache . put ( key , s ) ; } } catch ( ShortUrlGeneratorNotInitialized e ) { System . out . println ( e . getMessage ( ) ) ; } catch ( ShortUrlGenerationFailed e ) { System . out . println ( e . getMessage ( ) ) ; } }
tr	4	public void checkCompatWith ( PipeDef spawnedPipe , int lineN , CachedCall c ) { if ( spawnedPipe instanceof GarbagePipe ) return ; Datatype spawnType = spawnedPipe . type ( ) ; PipeDef nodeInstance = this ; if ( this . isImplicit ( ) ) nodeInstance = this . getImplicitReference ( c ) ; if ( nodeInstance . isNumeric ( ) ) { ParseError . validate ( spawnedPipe . isNumeric ( ) , lineN , spawnedPipe . getLabel ( ) + " must be numeric" ) ; } else if ( ! this . isAbstract ( ) ) { RuntimeError . validate ( nodeInstance . type ( ) == spawnType , lineN , "Incompatible types: " + nodeInstance . type ( ) + " and " + spawnedPipe . type ( ) ) ; } }
tr	1	private void zero ( ) throws JSONException { if ( probe ) { log ( 0 ) ; } write ( 0 , 1 ) ; }
tr	1	public void parse ( ) { final SAXParserFactory factory = SAXParserFactory . newInstance ( ) ; try { final SAXParser saxParser = factory . newSAXParser ( ) ; final InputSource source = new InputSource ( lexicon ) ; source . setEncoding ( "UTF-8" ) ; saxParser . parse ( source , this ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } }
tr	5	public static void merge ( int [ ] a , int [ ] aux , int lo , int mid , int hi ) { assert isSorted ( a , lo , mid ) ; assert isSorted ( a , mid + 1 , hi ) ; for ( int k = lo ; k <= hi ; k ++ ) aux [ k ] = a [ k ] ; int i = lo , j = mid + 1 ; for ( int k = lo ; k <= hi ; k ++ ) { if ( i > mid ) { a [ k ] = aux [ j ++ ] ; } else if ( j > hi ) { a [ k ] = aux [ i ++ ] ; } else if ( less ( aux [ j ] , aux [ i ] ) ) { a [ k ] = aux [ j ++ ] ; } else { a [ k ] = aux [ i ++ ] ; } } assert isSorted ( a , lo , hi ) ; }
tr	5	public List < Serie > getSerieBaseInfoByName ( String name ) throws ParserConfigurationException , SAXException , IOException { List < Serie > result = new ArrayList < Serie > ( ) ; URL getSeriesByNameUrl = new URL ( String . format ( Constants . GETSERIESBYNAME_URL , name ) . replace ( " " , "+" ) ) ; DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory . newInstance ( ) ; DocumentBuilder documentBuilder = documentBuilderFactory . newDocumentBuilder ( ) ; Document document = documentBuilder . parse ( getSeriesByNameUrl . openStream ( ) ) ; Element rootElement = document . getDocumentElement ( ) ; NodeList nodes = rootElement . getChildNodes ( ) ; for ( int i = 0 ; i < nodes . getLength ( ) ; ++ i ) { Node node = nodes . item ( i ) ; if ( node . getNodeName ( ) . equals ( "Series" ) ) { Serie serie = new Serie ( ) ; NodeList childNodes = node . getChildNodes ( ) ; for ( int j = 0 ; j < childNodes . getLength ( ) ; ++ j ) { Node childNode = childNodes . item ( j ) ; if ( childNode . getNodeName ( ) . equals ( "seriesid" ) ) { serie . setId ( Integer . parseInt ( childNode . getTextContent ( ) ) ) ; } else if ( childNode . getNodeName ( ) . equals ( "SeriesName" ) ) { serie . setName ( childNode . getTextContent ( ) ) ; } } result . add ( serie ) ; } } return result ; }
tr	5	@ Override protected Relatedness calcRelatedness ( Concept synset1 , Concept synset2 ) { if ( synset1 == null || synset2 == null ) return new Relatedness ( min ) ; StringBuilder tracer = new StringBuilder ( ) ; List < SuperGloss > glosses = glossFinder . getSuperGlosses ( synset1 , synset2 ) ; int score = 0 ; for ( int i = 0 ; i < glosses . size ( ) ; i ++ ) { SuperGloss sg = glosses . get ( i ) ; double functionsScore = calcFromSuperGloss ( sg . gloss1 , sg . gloss2 ) ; functionsScore *= glosses . get ( i ) . weight ; if ( enableTrace && functionsScore > 0 ) { tracer . append ( "Functions: " + sg . link1 . trim ( ) + " - " + sg . link2 . trim ( ) + " : " + functionsScore + "\n" ) ; tracer . append ( overlapLogMax + "\n\n" ) ; } score += functionsScore ; } return new Relatedness ( score , tracer . toString ( ) , null ) ; }
tr	2	private static boolean connectToServer ( String host , int port ) { try { System . out . println ( "Connecting to RMI Registry..." ) ; ClientApp . registry = LocateRegistry . getRegistry ( host , port ) ; ClientApp . server = ( ServerInterface ) registry . lookup ( ClientApp . SERVER_NAME ) ; } catch ( RemoteException e ) { System . out . println ( "Error during connection to server. Stacktrace:" ) ; e . printStackTrace ( ) ; return false ; } catch ( NotBoundException e ) { System . out . println ( "Error during connection to server. Stacktrace:" ) ; e . printStackTrace ( ) ; return false ; } System . out . println ( "Connected." ) ; return true ; }
tr	9	public void rotateCounterClockwise ( ) { boolean temp [ ] [ ] = new boolean [ PIECE_SIZE ] [ PIECE_SIZE ] ; for ( int i = 0 ; i < PIECE_SIZE ; ++ i ) { for ( int j = 0 ; j < PIECE_SIZE ; ++ j ) { temp [ i ] [ j ] = currentShape [ j ] [ PIECE_SIZE - i - 1 ] ; } } currentShape = temp ; while ( shiftUp ( ) ) ; int tmp = width ; width = height ; height = tmp ; switch ( state ) { case 0 : state = 3 ; break ; case 1 : state = 0 ; break ; case 2 : state = 1 ; break ; case 3 : state = 2 ; break ; case 4 : state = 7 ; break ; case 5 : state = 4 ; break ; case 6 : state = 5 ; break ; case 7 : state = 6 ; break ; } }
tr	8	private boolean isScrambleCore ( String s1 , String s2 ) { boolean result = false ; List < String > key = new ArrayList < String > ( ) ; key . add ( s1 ) ; key . add ( s2 ) ; if ( cache . containsKey ( key ) ) return cache . get ( key ) ; if ( s1 . equals ( s2 ) ) { cache . put ( key , true ) ; return true ; } if ( s1 . length ( ) == 1 ) { cache . put ( key , false ) ; return false ; } int n = s1 . length ( ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { String s11 = s1 . substring ( 0 , i + 1 ) ; String s12 = s1 . substring ( i + 1 ) ; String s21 = s2 . substring ( 0 , i + 1 ) ; String s22 = s2 . substring ( i + 1 ) ; if ( isScrambleCore ( s11 , s21 ) && isScrambleCore ( s12 , s22 ) ) { result = true ; break ; } s21 = s2 . substring ( 0 , n - 1 - i ) ; s22 = s2 . substring ( n - 1 - i ) ; if ( isScrambleCore ( s11 , s22 ) && isScrambleCore ( s12 , s21 ) ) { result = true ; break ; } } cache . put ( key , result ) ; return result ; }
tr	7	public static void replicateFiles ( String dataNodeName ) { System . out . println ( "This Data node is dead  " + dataNodeName ) ; System . out . println ( "Starting the replication process." ) ; List < InputFileInfo > infoList = needValidations ( dataNodeName ) ; for ( InputFileInfo info : infoList ) { System . out . println ( "Info   " + info . getFileName ( ) ) ; for ( String file : info . filesFromDeadDataNode ( dataNodeName ) ) { System . out . println ( "This is the missing file  " + file ) ; String dataNode = info . fileExistInDataNode ( file ) ; System . out . println ( "This is where the existing file is. " + dataNode ) ; boolean found = boolean . false ; Integer counter = 0 ; while ( ! found ) { Entry < String , DataNode > entry = getNextDataNodeEntry ( ) ; if ( ! ( entry == null ) ) { try { if ( ! entry . getValue ( ) . isExist ( file ) ) { found = boolean . true ; DataNode node = list_dataNode . get ( dataNode ) ; String data = node . retrieve ( file ) ; DataNode newNode = entry . getValue ( ) ; newNode . submit ( file , data ) ; info . addFileParitionInfo ( entry . getKey ( ) , file ) ; } else { counter ++ ; if ( counter > list_dataNode . size ( ) ) { found = boolean . true ; } } } catch ( RemoteException e ) { System . out . println ( "Error while asking the remote object" ) ; } } } } info . validateFiles ( ) ; } System . out . println ( "Replication process has completed." ) ; }
tr	8	private void drawTooltip ( ) { if ( menuActionRow < 2 && itemSelected == 0 && spellSelected == 0 ) return ; String s ; if ( itemSelected == 1 && menuActionRow < 2 ) s = "Use " + selectedItemName + " with..." ; else if ( spellSelected == 1 && menuActionRow < 2 ) s = spellTooltip + "..." ; else s = menuActionName [ menuActionRow - 1 ] ; if ( menuActionRow > 2 ) s = s + "@whi@ / " + ( menuActionRow - 2 ) + " more options" ; chatTextDrawingArea . method390 ( 4 , ffffff , s , loopCycle / 1000 , 15 ) ; }
tr	4	public static String negativeAppender ( String str ) { StringBuilder sb = new StringBuilder ( ) ; StringTokenizer tk = new StringTokenizer ( str ) ; boolean withinNegation = false ; String word ; while ( tk . hasMoreTokens ( ) ) { word = tk . nextToken ( ) ; if ( withinNegation ) { sb . append ( "\u10D0\u10E0_" ) ; } if ( isNegativeKeyword ( word ) ) { withinNegation = true ; } sb . append ( word ) ; sb . append ( " " ) ; if ( endOfSentence ( word ) ) { withinNegation = false ; } } sb . deleteCharAt ( sb . length ( ) - 1 ) ; return sb . toString ( ) ; }
tr	7	protected void doPost ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { boolean canlogin = true ; Pattern pattern = Pattern . compile ( SecurityPattern . EMAIL_PATTERN ) ; Matcher matcher = pattern . matcher ( request . getParameter ( MappedNames . MAIL ) . toString ( ) ) ; if ( ! matcher . matches ( ) ) { request . setAttribute ( "error" , MappedErrors . MAIL_INVALIDE ) ; canlogin = false ; } pattern = Pattern . compile ( SecurityPattern . PASSWORD_PATTERN ) ; matcher = pattern . matcher ( request . getParameter ( MappedNames . PASSWORD ) . toString ( ) ) ; if ( ! matcher . matches ( ) ) { request . setAttribute ( "error" , MappedErrors . PASSWORD_INVALIDE ) ; canlogin = false ; } if ( canlogin ) { try { TransporteurDAO dao = new TransporteurDAO ( ) ; TrasporteurBean pojo = dao . getByMail ( request . getParameter ( MappedNames . MAIL ) . toString ( ) ) ; if ( ! pojo . getMail ( ) . equals ( null ) ) { if ( pojo . getPassword ( ) . equals ( request . getParameter ( MappedNames . PASSWORD ) . toString ( ) ) ) { HttpSession session = request . getSession ( true ) ; pojo . setPassword ( "" ) ; session . setAttribute ( "user" , pojo ) ; response . sendRedirect ( MappedJsp . HOME ) ; } else { request . setAttribute ( "error" , MappedErrors . MAUVAIS_PASSWORD ) ; this . getServletContext ( ) . getRequestDispatcher ( MappedJsp . LOGIN_JSP ) . forward ( request , response ) ; } } } catch ( NullPointerException e ) { request . setAttribute ( "error" , MappedErrors . MAUVAIS_MAIL ) ; this . getServletContext ( ) . getRequestDispatcher ( MappedJsp . LOGIN_JSP ) . forward ( request , response ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; request . setAttribute ( "error" , MappedErrors . GENERAL_ERROR ) ; this . getServletContext ( ) . getRequestDispatcher ( MappedJsp . LOGIN_JSP ) . forward ( request , response ) ; } } else { this . getServletContext ( ) . getRequestDispatcher ( MappedJsp . LOGIN_JSP ) . forward ( request , response ) ; } }
tr	3	public int indexOf ( char ch ) { if ( len < 1 ) return - 1 ; for ( int i = 0 ; i < len - 1 ; i ++ ) { if ( array [ i ] == ch ) return i ; } return - 1 ; }
tr	3	public void writeWeights ( File file ) throws IOException { PrintWriter out = new PrintWriter ( file ) ; for ( int l = 0 ; l < layers . size ( ) - 1 ; ++ l ) { double [ ] [ ] w = weights . get ( l ) ; for ( int i = 0 ; i < layers . get ( l ) . size ( ) + 1 ; ++ i ) for ( int j = 0 ; j < layers . get ( l + 1 ) . size ( ) ; ++ j ) out . print ( w [ i ] [ j ] + " " ) ; } out . close ( ) ; }
tr	3	public CalendarModel add ( MeetingModel meeting ) { if ( meetings . contains ( meeting ) ) return this ; meetings . add ( meeting ) ; if ( ! meetingsFrom . containsKey ( meeting . getTimeFrom ( ) ) ) meetingsFrom . put ( meeting . getTimeFrom ( ) , new HashSet < MeetingModel > ( ) ) ; if ( ! meetingsTo . containsKey ( meeting . getTimeTo ( ) ) ) meetingsTo . put ( meeting . getTimeTo ( ) , new HashSet < MeetingModel > ( ) ) ; meetingsFrom . get ( meeting . getTimeFrom ( ) ) . add ( meeting ) ; meetingsTo . get ( meeting . getTimeTo ( ) ) . add ( meeting ) ; meeting . addPropertyChangeListener ( this ) ; pcs . firePropertyChange ( MEETING_ADDED , null , meeting ) ; return this ; }
tr	2	public GameEntity getEntityAt ( double x , double y ) { for ( GameEntity e : entities ) { if ( e . contains ( x , y ) ) { return e ; } } return null ; }
tr	9	public void method471 ( int ai [ ] , int j , int k ) { if ( k == - 1 ) return ; if ( ai == null || j == - 1 ) { method470 ( k ) ; return ; } Class36 class36 = Class36 . method531 ( k ) ; if ( class36 == null ) return ; Class36 class36_1 = Class36 . method531 ( j ) ; if ( class36_1 == null ) { method470 ( k ) ; return ; } Class18 class18 = class36 . aClass18_637 ; anInt1681 = 0 ; anInt1682 = 0 ; anInt1683 = 0 ; int l = 0 ; int i1 = ai [ l ++ ] ; for ( int j1 = 0 ; j1 < class36 . anInt638 ; j1 ++ ) { int k1 ; for ( k1 = class36 . anIntArray639 [ j1 ] ; k1 > i1 ; i1 = ai [ l ++ ] ) ; if ( k1 != i1 || class18 . anIntArray342 [ k1 ] == 0 ) method472 ( class18 . anIntArray342 [ k1 ] , class18 . anIntArrayArray343 [ k1 ] , class36 . anIntArray640 [ j1 ] , class36 . anIntArray641 [ j1 ] , class36 . anIntArray642 [ j1 ] ) ; } anInt1681 = 0 ; anInt1682 = 0 ; anInt1683 = 0 ; l = 0 ; i1 = ai [ l ++ ] ; for ( int l1 = 0 ; l1 < class36_1 . anInt638 ; l1 ++ ) { int i2 ; for ( i2 = class36_1 . anIntArray639 [ l1 ] ; i2 > i1 ; i1 = ai [ l ++ ] ) ; if ( i2 == i1 || class18 . anIntArray342 [ i2 ] == 0 ) method472 ( class18 . anIntArray342 [ i2 ] , class18 . anIntArrayArray343 [ i2 ] , class36_1 . anIntArray640 [ l1 ] , class36_1 . anIntArray641 [ l1 ] , class36_1 . anIntArray642 [ l1 ] ) ; } }
tr	8	DeviceImpl ( USB bus , String drivername , int a ) throws IOException , SecurityException { super ( null , bus , a ) ; usb = bus ; path = drivername ; if ( ( fd = openNative ( path ) ) < 0 ) { String message ; message = "can't open device file r/w  " + path ; throw new USBException ( message , - fd ) ; } int num_descriptor_retries = 0 ; IOException descriptor_exception = null ; do { try { byte buf [ ] ; buf = ControlMessage . getStandardDescriptor ( this , Descriptor . TYPE_DEVICE , ( byte ) 0 , 0 , 18 ) ; descriptor = new DeviceDescriptor ( this , buf ) ; getConfiguration ( ) ; if ( Windows . trace ) System . err . println ( "new: " + path ) ; return ; } catch ( USBException ue ) { if ( Windows . debug ) ue . printStackTrace ( ) ; else if ( Windows . trace ) System . err . println ( "get dev descr fail:  " + path + "  " + ue . getMessage ( ) ) ; descriptor_exception = ue ; } catch ( IOException e ) { if ( Windows . debug ) System . err . println ( "get dev descr fail:  " + path + "  " + e . getMessage ( ) ) ; throw e ; } } while ( num_descriptor_retries ++ < 4 ) ; throw descriptor_exception ; }
tr	0	private void miEditarActionPerformed ( java . awt . event . ActionEvent evt ) { desbloquearCampos ( ) ; }
tr	8	public void filtrarContratosActivos ( ) { try { String filtro = panelAdminContratos . getTextoFiltro ( ) ; int tipoFiltro = panelAdminContratos . getTipoFiltro ( ) ; if ( ! filtro . trim ( ) . equals ( "" ) ) { if ( tipoFiltro == Contrato . FILTRO_ID_DUENIO || tipoFiltro == Contrato . FILTRO_ID_HABITANTE || tipoFiltro == Contrato . FILTRO_ID_RESPONSABLE ) { long id = long . parseLong ( filtro ) ; ArrayList < Contrato > lista = Contrato . getListaContratosFiltro ( Contrato . CONTRATOS_ACTIVOS , tipoFiltro , id , "" ) ; panelAdminContratos . setListaContratos ( lista ) ; } else if ( tipoFiltro == Contrato . FILTRO_NOMBRE_DUENIO || tipoFiltro == Contrato . FILTRO_NOMBRE_HABITANTE || tipoFiltro == Contrato . FILTRO_NOMBRE_RESPONSABLE ) { ArrayList < Contrato > lista = Contrato . getListaContratosFiltro ( Contrato . CONTRATOS_ACTIVOS , tipoFiltro , - 1 , filtro ) ; panelAdminContratos . setListaContratos ( lista ) ; } } else { cargarContratosActivos ( ) ; } } catch ( NumberFormatException ex ) { JOptionPane . showMessageDialog ( panelAdminContratos , "Error num\u00E9rico al buscar por el n\u00FAmero de id" , "Error num\u00E9rico" , JOptionPane . ERROR_MESSAGE ) ; } }
tr	1	@ BeforeClass public static void setUpBeforeClass ( ) throws Exception { DerbySingleton . getInstance ( ) . start ( ) ; if ( ! DerbySingleton . getInstance ( ) . isStarted ( ) ) { LOGGER . log ( Level . SEVERE , "Derby is not started !" ) ; } }
tr	8	@ Override public boolean hasNext ( ) { if ( readBuffer != null && readBuffer . remaining ( ) != 0 ) { logger . debug ( "There are still elements in the readBuffer" ) ; return true ; } else if ( actualFile != null && actualFileOffset < actualFile . getFilledUpFromContentStart ( ) ) { logger . debug ( "The end of the actual file is not reached yet." ) ; return true ; } else if ( actualBucketId < numberOfBuckets - 1 ) { logger . debug ( "Not all files were read. Trying to open next file" ) ; try { this . handleFile ( ) ; } catch ( FileLockException e ) { logger . error ( "Skipping file. Not all elements might have been iterated. {}" , e ) ; } catch ( IOException e ) { logger . error ( "Skipping file. Not all elements might have been iterated. {}" , e ) ; } return hasNext ( ) ; } if ( actualFile != null ) { actualFile . close ( ) ; } return false ; }
tr	8	public void executePowerUp ( PowerupNode node ) { PowerupPlayer powerup = node . powerup ; if ( powerup == null ) return ; switch ( powerup . addsFeature ) { case BOMB_MAX_COUNT : combatSystem . updateBombLayer ( node . entity_target , null , null , powerup . amount , null ) ; break ; case BOMB_TEMP_COUNT : combatSystem . updateBombLayer ( node . entity_target , null , null , null , powerup . amount ) ; break ; case CAN_JUMP : break ; case CAN_PUSH : break ; case FLAME_LENGTH : combatSystem . updateBombLayer ( node . entity_target , powerup . amount , null , null , null ) ; break ; case SPEED : movementSystem . updateMoveable ( node . entity_target , powerup . amount ) ; break ; case DAMAGE : combatSystem . updateBombLayer ( node . entity_target , null , powerup . amount , null , null ) ; } }
tr	7	public int hexSideInPixels ( int availableWidthForMapInPixels , int availableHeightForMapInPixels ) { int h = availableHeightForMapInPixels ; int w = availableWidthForMapInPixels ; int resultBasedOnHeight = ( int ) Drafter . roundToNearestEvenNumber ( h / getMapHeightInHexSides ( ) ) ; if ( resultBasedOnHeight * getMapHeightInHexSides ( ) > h ) { resultBasedOnHeight = resultBasedOnHeight - 2 ; } if ( resultBasedOnHeight < 2 ) { resultBasedOnHeight = 2 ; } int estimatedMaxWidth = ( int ) Drafter . roundToNearestEvenNumber ( w / getMapWidthInHexesAcrossFlats ( ) ) ; if ( estimatedMaxWidth * getMapWidthInHexesAcrossFlats ( ) > w ) { estimatedMaxWidth = estimatedMaxWidth - 2 ; } if ( estimatedMaxWidth < 4 ) { estimatedMaxWidth = 4 ; } int resultBasedOnWidth = ( int ) Drafter . roundToNearestEvenNumber ( estimatedMaxWidth / Math . sqrt ( 3.0 ) ) ; int correspondingWidth = ( int ) Drafter . roundToNearestEvenNumber ( resultBasedOnWidth * Math . sqrt ( 3.0 ) ) ; if ( correspondingWidth * getMapWidthInHexesAcrossFlats ( ) > w ) { resultBasedOnWidth = resultBasedOnWidth - 2 ; } if ( resultBasedOnWidth < 2 ) { resultBasedOnWidth = 2 ; } if ( resultBasedOnWidth < resultBasedOnHeight ) { return resultBasedOnWidth ; } return resultBasedOnHeight ; }
tr	1	public List < Expediente > getExpedientes ( Integer idFuncionario ) throws SQLException { List < Expediente > expedientes = new ArrayList < Expediente > ( ) ; con = cp . getconection ( ) ; String sql = "SELECT * FROM expedientes WHERE idFuncionario = ?" ; PreparedStatement ps = con . prepareStatement ( sql , ResultSet . TYPE_SCROLL_SENSITIVE , ResultSet . CONCUR_UPDATABLE ) ; ps . setInt ( 1 , idFuncionario ) ; ResultSet rs = ps . executeQuery ( ) ; while ( rs . next ( ) ) { Expediente expediente = new Expediente ( ) ; expediente . setId ( rs . getInt ( "id" ) ) ; expediente . setDiaSemana ( rs . getInt ( "DiaSemana" ) ) ; expedientes . add ( expediente ) ; } return expedientes ; }
tr	7	public static Document deepCloneDocument ( Document doc , DOMImplementation impl ) { Element root = doc . getDocumentElement ( ) ; Document result = impl . createDocument ( root . getNamespaceURI ( ) , root . getNodeName ( ) , null ) ; Element rroot = result . getDocumentElement ( ) ; boolean before = true ; for ( Node n = doc . getFirstChild ( ) ; n != null ; n = n . getNextSibling ( ) ) { if ( n == root ) { before = false ; if ( root . hasAttributes ( ) ) { NamedNodeMap attr = root . getAttributes ( ) ; int len = attr . getLength ( ) ; for ( int i = 0 ; i < len ; i ++ ) { rroot . setAttributeNode ( ( Attr ) result . importNode ( attr . item ( i ) , true ) ) ; } } for ( Node c = root . getFirstChild ( ) ; c != null ; c = c . getNextSibling ( ) ) { rroot . appendChild ( result . importNode ( c , true ) ) ; } } else { if ( n . getNodeType ( ) != Node . DOCUMENT_TYPE_NODE ) { if ( before ) { result . insertBefore ( result . importNode ( n , true ) , rroot ) ; } else { result . appendChild ( result . importNode ( n , true ) ) ; } } } } return result ; }
tr	5	public void move ( ) { super . move ( ) ; if ( this . clock % 10 == 0 ) { if ( this . clock % 50 == 0 ) { this . angle = Math . PI * 3 / 2 ; } PlayerShip p = game . getPlayer ( ) ; double dFromPlayer = Math . sqrt ( Math . pow ( p . x - x , 2 ) + Math . pow ( p . y - y , 2 ) ) ; if ( dFromPlayer < 128 ) { this . angle = Math . PI * 3 / 2 ; this . velocity += 1.2 ; } } if ( game . t % 10 == 0 && game . random ( 0 , 1 , 1 ) == 1 ) { shoot ( Math . PI * 3 / 2 ) ; } }
tr	6	public EntradaBean load ( EntradaBean oEntrada ) throws NumberFormatException , ParseException { try { if ( ( request . getParameter ( "titulo" ) != null ) ) { oEntrada . setTitulo ( request . getParameter ( "titulo" ) ) ; } if ( ( request . getParameter ( "contenido" ) != null ) ) { oEntrada . setContenido ( request . getParameter ( "contenido" ) ) ; } if ( ( request . getParameter ( "id_hilo" ) != null ) ) { oEntrada . getHilo ( ) . setId ( Integer . parseInt ( request . getParameter ( "id_hilo" ) ) ) ; } if ( ( request . getParameter ( "id_usuario" ) != null ) ) { oEntrada . getUsuario ( ) . setId ( Integer . parseInt ( request . getParameter ( "id_usuario" ) ) ) ; } if ( ( request . getParameter ( "fecha" ) != null ) ) { oEntrada . setFecha ( new SimpleDateFormat ( "dd-MM-yyyy" ) . parse ( request . getParameter ( "fecha" ) ) ) ; } } catch ( NumberFormatException e ) { throw new NumberFormatException ( "EntradaParam: Error: load: Formato de datos en par\u00E1metros incorrecto " + e . getMessage ( ) ) ; } return oEntrada ; }
tr	9	private void getScaleFactors_2 ( int gr , int ch ) { byte [ ] nr ; int i , band , slen , num , n = 0 , scf = 0 ; final boolean i_stereo = header . isIntensityStereo ( ) ; final ChannelInformation ci = channelInfo [ gr ] [ ch ] ; final int [ ] l = scalefacLong [ ch ] ; final int [ ] s = scalefacShort [ ch ] ; rzeroBandLong = 0 ; if ( ( ch > 0 ) && i_stereo ) slen = i_slen2 [ ci . scalefac_compress >> 1 ] ; else slen = n_slen2 [ ci . scalefac_compress ] ; ci . preflag = ( slen >> 15 ) & 1 ; ci . part2_length = 0 ; if ( ci . block_type == 2 ) { n ++ ; if ( ( ci . mixed_block_flag ) != 0 ) n ++ ; nr = nr_of_sfb [ n ] [ ( slen >> 12 ) & 7 ] ; for ( i = 0 ; i < 4 ; i ++ ) { num = slen & 7 ; slen >>= 3 ; if ( num != 0 ) { for ( band = 0 ; band < nr [ i ] ; band ++ ) s [ scf ++ ] = maindataStream . getBits17 ( num ) ; ci . part2_length += nr [ i ] * num ; } else for ( band = 0 ; band < nr [ i ] ; band ++ ) s [ scf ++ ] = 0 ; } n = ( n << 1 ) + 1 ; for ( i = 0 ; i < n ; i ++ ) s [ scf ++ ] = 0 ; } else { nr = nr_of_sfb [ n ] [ ( slen >> 12 ) & 7 ] ; for ( i = 0 ; i < 4 ; i ++ ) { num = slen & 7 ; slen >>= 3 ; if ( num != 0 ) { for ( band = 0 ; band < nr [ i ] ; band ++ ) l [ scf ++ ] = maindataStream . getBits17 ( num ) ; ci . part2_length += nr [ i ] * num ; } else for ( band = 0 ; band < nr [ i ] ; band ++ ) l [ scf ++ ] = 0 ; } n = ( n << 1 ) + 1 ; for ( i = 0 ; i < n ; i ++ ) l [ scf ++ ] = 0 ; } }
tr	7	@ EventHandler public void killObj ( EntityDeathEvent ev ) { LivingEntity ent = ev . getEntity ( ) ; if ( ent . getKiller ( ) == null ) return ; Player player = ent . getKiller ( ) ; PlayerQuestLog log = qm . getQuestLog ( player . getName ( ) ) ; for ( Quest q : log . getAssigned ( ) ) { QuestData qd = log . getProgress ( q ) ; for ( Objective o : qd . getAssignedObjectives ( ) ) { if ( o . getType ( ) != ObjectiveType . KILL ) continue ; String prog = qd . getProgress ( o . getID ( ) ) ; String targ = o . getTarget ( ) ; if ( ! ObjectiveType . KILL . isSimilarType ( targ , prog ) ) continue ; if ( ! ObjectiveType . KILL . getEntityType ( targ ) . equals ( ent . getType ( ) . name ( ) ) ) continue ; int p = ObjectiveType . KILL . getKills ( prog ) + 1 ; int t = ObjectiveType . KILL . getKills ( targ ) ; if ( o . isVisible ( ) ) player . sendMessage ( ChatColor . GREEN + o . getName ( ) + " (" + p + "/" + t + ")" ) ; qd . setProgress ( o . getID ( ) , p + " " + ent . getType ( ) . name ( ) ) ; } } }
tr	0	public List < Calificacion > getCalificaciones ( ) { return calificaciones ; }
tr	7	private boolean decideToAddPassantTile ( Board b , ArrayList < PossibleTile > pts , PossibleTile pt ) { if ( ! checkBounds ( pt . getX ( ) , pt . getY ( ) ) ) { return false ; } PossibleTile ps ; if ( isWhite ) { ps = new PossibleTile ( pt . getX ( ) , pt . getY ( ) - 1 , pt . getOriginalPiece ( ) ) ; } else { ps = new PossibleTile ( pt . getX ( ) , pt . getY ( ) + 1 , pt . getOriginalPiece ( ) ) ; } for ( Piece p : b . getPieces ( ) ) { if ( p instanceof Pawn && p . isWhite != this . isWhite ) { Pawn pawn = ( Pawn ) p ; if ( pawn . possibleToPassant ( ) ) { if ( checkSameSpace ( pawn , pt ) ) { ps . setRemovePiece ( pawn ) ; pts . add ( ps ) ; return false ; } } } } return true ; }
tr	7	private void calcNonConvexPoints ( ) { if ( points . size ( ) <= 3 ) return ; Point p ; Point v ; Point u ; int res = 0 ; for ( int i = 0 ; i < points . size ( ) - 1 ; i ++ ) { p = points . get ( i ) ; Point tmp = points . get ( i + 1 ) ; v = new Point ( ) ; v . x = tmp . x - p . x ; v . y = tmp . y - p . y ; if ( i == points . size ( ) - 2 ) u = points . get ( 0 ) ; else u = points . get ( i + 2 ) ; res = u . x * v . y - u . y * v . x + v . x * p . y - v . y * p . x ; if ( ( res > 0 && isCw ) || ( res <= 0 && ! isCw ) ) { nonconvexPoints . add ( tmp ) ; System . out . println ( "konkav point #" + ( i + 1 ) + "  Coords: " + tmp . x + "/" + tmp . y ) ; } } }
tr	3	public void add ( T item ) { Node node = new Node ( item ) ; if ( current == null ) { node . next = head ; node . prev = null ; if ( head != null ) head . prev = node ; head = node ; } else { node . next = current . next ; node . prev = current ; if ( current . next != null ) current . next . prev = node ; current . next = node ; } ++ idx ; current = node ; ++ size ; }
tr	1	protected void sendConnectionHeaderIfNotAlreadyPresent ( PrintWriter pw , Map < String , String > header ) { if ( ! headerAlreadySent ( header , "connection" ) ) { pw . print ( "Connection: keep-alive\r\n" ) ; } }
tr	3	@ Override public void run ( ) { Random rand = new Random ( System . currentTimeMillis ( ) ) ; for ( int i = 1 ; i <= 10 ; i ++ ) { try { if ( rand . nextInt ( 100 ) % 2 > 0 ) { threadMessage ( i + ". Increasing Counter1" ) ; locked . increase1 ( ) ; } else { threadMessage ( i + ". Increasing Counter2" ) ; locked . increase2 ( ) ; } } catch ( InterruptedException e ) { threadMessage ( "Received Interrupt!" ) ; return ; } } threadMessage ( "Done!" ) ; }
tr	0	public boolean isBlsSpecialBonusAvailable ( ) { return blsSpecialBonusAvailable ; }
tr	0	public static void main ( String [ ] args ) { print ( 4 ) ; }
tr	5	public void paintTriangle ( Graphics g , int x , int y , int size ) { for ( int i = 0 ; i < size ; i ++ ) { switch ( facing ) { case UP : g . drawLine ( x - i , y - size / 2 + i , x + i , y - size / 2 + i ) ; break ; case DOWN : g . drawLine ( x - i , y + size / 2 - i , x + i , y + size / 2 - i ) ; break ; case LEFT : g . drawLine ( x - size / 2 + i , y - i , x - size / 2 + i , y + i ) ; break ; case RIGHT : g . drawLine ( x + size / 2 - i , y - i , x + size / 2 - i , y + i ) ; break ; } } }
tr	1	public static void notNull ( Object object , RuntimeException throwIfAssertFail ) { if ( object == null ) { throw throwIfAssertFail ; } }
tr	7	public static Packet readPacket ( Stream s ) { try { if ( s . getInStream ( ) . available ( ) > 0 ) { int size = s . readInt ( ) ; if ( size == 0 ) return null ; Packet p ; try { byte id = s . readByte ( ) ; if ( Packet . getPacketFromId ( id ) == null ) return null ; p = Packet . getPacketFromId ( id ) . getClass ( ) . newInstance ( ) ; p . opcode = id ; p . stream = s ; } catch ( InstantiationException e ) { e . printStackTrace ( ) ; return null ; } catch ( IllegalAccessException e ) { e . printStackTrace ( ) ; return null ; } if ( size > 1 ) p . getPayLoad ( ) . construct ( s , size - 1 ) ; p . recieved = true ; return p ; } } catch ( IOException e ) { System . out . println ( "Stream closed!" ) ; } return null ; }
tr	3	private Object firstKey ( Object subtree ) { if ( ! ( subtree instanceof Node ) ) { Object [ ] ary = ( Object [ ] ) subtree ; return ary [ 0 ] ; } else { Node node = ( Node ) subtree ; if ( node . left == null ) { if ( node . key instanceof EquivalentMap ) return ( ( EquivalentMap ) node . key ) . contents . get ( 0 ) . key ; else return node . key ; } else return firstKey ( node . left ) ; } }
tr	7	@ Override public Iterator < Color > iterator ( ) { return new Iterator < Color > ( ) { private int [ ] cs = null ; private boolean finalized = false ; private int [ ] next_coordinates ( int [ ] cs ) { if ( finalized ) return null ; if ( cs == null ) { cs = new int [ ] { 0 , 0 } ; } else { cs = cs . clone ( ) ; if ( cs [ 1 ] < ks [ cs [ 0 ] ] - 1 ) { cs [ 1 ] ++ ; return cs ; } else { cs [ 1 ] = 0 ; cs [ 0 ] ++ ; } } while ( cs [ 0 ] < Color . all . length && ks [ cs [ 0 ] ] == 0 ) cs [ 0 ] ++ ; if ( cs [ 0 ] >= Color . all . length ) { finalized = true ; return null ; } return cs ; } @ Override public boolean hasNext ( ) { return next_coordinates ( cs ) != null ; } @ Override public Color next ( ) { cs = next_coordinates ( cs ) ; if ( cs == null ) throw new NoSuchElementException ( ) ; return Color . all [ cs [ 0 ] ] ; } @ Override public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; }
tr	9	public boolean checkWin ( IPlayer player ) { int numberOfMatches = 0 ; for ( int i = 0 ; i < 3 ; i ++ ) { for ( numberOfMatches = 0 ; numberOfMatches < 3 ; numberOfMatches ++ ) if ( playersPositions [ i ] [ numberOfMatches ] != player ) break ; if ( numberOfMatches == 3 ) return true ; } for ( int j = 0 ; j < 3 ; j ++ ) { for ( numberOfMatches = 0 ; numberOfMatches < 3 ; numberOfMatches ++ ) if ( playersPositions [ numberOfMatches ] [ j ] != player ) break ; if ( numberOfMatches == 3 ) return true ; } for ( numberOfMatches = 0 ; numberOfMatches < 3 ; numberOfMatches ++ ) if ( playersPositions [ numberOfMatches ] [ numberOfMatches ] != player ) break ; if ( numberOfMatches == 3 ) return true ; for ( numberOfMatches = 0 ; numberOfMatches < 3 ; numberOfMatches ++ ) if ( playersPositions [ numberOfMatches ] [ 2 - numberOfMatches ] != player ) break ; if ( numberOfMatches == 3 ) return true ; return false ; }
tr	4	public Type parse ( int i ) { switch ( i ) { case 1 : return HASHTAG ; case 2 : return USER ; case 3 : return EMOTICON ; case 4 : return URL ; } return OTHER ; }
tr	2	public static void main ( String [ ] args ) { Node n = new Node ( 30 ) ; n . setLeft ( new Node ( 8 ) ) ; n . setRight ( new Node ( 52 ) ) ; n . getLeft ( ) . setLeft ( new Node ( 3 ) ) ; n . getLeft ( ) . setRight ( new Node ( 20 ) ) ; n . getLeft ( ) . getRight ( ) . setRight ( new Node ( 29 ) ) ; n . getLeft ( ) . getRight ( ) . setLeft ( new Node ( 10 ) ) ; BufferedReader in ; try { in = new BufferedReader ( new FileReader ( "C:\\Users\\Abhishek\\Desktop\\input.txt" ) ) ; String line ; while ( ( line = in . readLine ( ) ) != null ) { String [ ] elem = line . split ( " " ) ; System . out . println ( LeastCommonAncestor ( n , Integer . valueOf ( elem [ 0 ] ) , Integer . valueOf ( elem [ 1 ] ) ) . getData ( ) ) ; } } catch ( Exception e ) { } }
tr	8	public String getPatternFlagsAsString ( ) { if ( patternFlags == 0 ) return "" ; StringBuffer out = new StringBuffer ( ) ; if ( ( patternFlags & Pattern . CANON_EQ ) != 0 ) out . append ( "Pattern.CANON_EQ+" ) ; if ( ( patternFlags & Pattern . CASE_INSENSITIVE ) != 0 ) out . append ( "Pattern.CASE_INSENSITIVE+" ) ; if ( ( patternFlags & Pattern . COMMENTS ) != 0 ) out . append ( "Pattern.COMMENTS+" ) ; if ( ( patternFlags & Pattern . DOTALL ) != 0 ) out . append ( "Pattern.DOTALL+" ) ; if ( ( patternFlags & Pattern . MULTILINE ) != 0 ) out . append ( "Pattern.MULTILINE+" ) ; if ( ( patternFlags & Pattern . UNICODE_CASE ) != 0 ) out . append ( "Pattern.UNICODE_CASE+" ) ; if ( ( patternFlags & Pattern . UNIX_LINES ) != 0 ) out . append ( "Pattern.UNIX_LINES+" ) ; String outStr = out . toString ( ) ; return outStr . substring ( 0 , outStr . length ( ) - 1 ) ; }
tr	8	public ArrayList < SearchBean < FreeBedSummaryBean >> getFreeBedSummary ( Hostel info , Date start , Date end ) { ArrayList < SearchBean < FreeBedSummaryBean >> result = new ArrayList < SearchBean < FreeBedSummaryBean >> ( ) ; if ( info == null ) { return null ; } try { ArrayList < Identifier > hostelIds = Hostels . getInstance ( ) . search ( info ) ; if ( hostelIds . size ( ) == 0 ) { return null ; } for ( Identifier hostelId : hostelIds ) { Calendar cal = Calendar . getInstance ( ) ; cal . setTime ( start ) ; for ( int days = 1 ; days <= GenericUtility . getDiffDays ( end , start ) ; days ++ ) { Date checkIn = cal . getTime ( ) ; cal . add ( Calendar . DATE , 1 ) ; Date checkOut = cal . getTime ( ) ; ArrayList < Identifier > bedIds = Hostels . getInstance ( ) . getFreeBeds ( hostelId , checkIn , checkOut ) ; int maxPrice = 0 ; int minPrice = Integer . MAX_VALUE ; for ( Identifier bedId : bedIds ) { Bed bedInfo = Beds . getInstance ( ) . get ( bedId ) ; Tariff tariff = bedInfo . getTariffForDate ( checkIn , checkOut ) ; if ( tariff . getPrice ( ) > maxPrice ) maxPrice = tariff . getPrice ( ) ; if ( tariff . getPrice ( ) < minPrice ) minPrice = tariff . getPrice ( ) ; } FreeBedSummaryBean fbsBean = new FreeBedSummaryBean ( ) ; fbsBean . setMaxPrice ( maxPrice ) ; fbsBean . setMinPrice ( minPrice ) ; fbsBean . setNoOfBeds ( bedIds . size ( ) ) ; fbsBean . setStartDate ( checkIn ) ; fbsBean . setEndDate ( checkOut ) ; SearchBean < FreeBedSummaryBean > bean = new SearchBean < FreeBedSummaryBean > ( getNextSearchId ( ) , hostelId , fbsBean ) ; result . add ( bean ) ; } } } catch ( DataBaseReadWriteException | IdentifierNotFoundException | InvalidIdentifierException | InvalidParameterException e ) { e . printStackTrace ( ) ; } write ( result ) ; return result ; }
tr	5	public Color getColorAt ( int x , int y ) { if ( image == null || x < 0 || x >= image . getWidth ( ) || y < 0 || y >= image . getHeight ( ) ) { throw new IndexOutOfBoundsException ( "(" + x + " " + y + ")" ) ; } else { int rgb = image . getRGB ( x , y ) & FFFFFF ; return new Color ( rgb / 65536 , ( rgb / 256 ) % 256 , rgb % 256 ) ; } }
tr	8	private void runButtonActionPerformed ( java . awt . event . ActionEvent evt ) throws IOException { if ( runButton . getText ( ) . equals ( "Run" ) ) { threadSwitch . setEnabled ( false ) ; debugSwitch . setEnabled ( false ) ; simRunSwitch . setEnabled ( false ) ; ignoreSwitch . setEnabled ( false ) ; forceSwitch . setEnabled ( false ) ; writeToDBSwitch . setEnabled ( false ) ; threadComboBox . setEnabled ( false ) ; debugComboBox . setEnabled ( false ) ; runButton . setText ( "Interrupt" ) ; boolean debugEnabled = debugSwitch . isSelected ( ) ; boolean simRunEnabled = simRunSwitch . isSelected ( ) ; boolean ignoreEnabled = ignoreSwitch . isSelected ( ) ; boolean forceEnabled = forceSwitch . isSelected ( ) ; int threadComboVal = threadComboBox . getSelectedIndex ( ) + 1 ; int debugComboVal = debugComboBox . getSelectedIndex ( ) + 1 ; config . setDebug ( debugEnabled ) ; if ( debugEnabled ) { config . setVerbosity ( debugComboVal ) ; } else { config . setVerbosity ( 1 ) ; } config . setRunTerminal ( false ) ; config . setPastOnly ( false ) ; config . setForceRun ( forceEnabled ) ; config . setSimRun ( simRunEnabled ) ; if ( simRunEnabled ) { config . setLOG_NAME ( "log_alt.txt" ) ; } config . setIgnoreLog ( ignoreEnabled ) ; config . setNumThreads ( threadComboVal ) ; try { if ( config . finishedToday ( ) && ! config . isIgnoreLog ( ) ) { mainOutMessage ( "Already finished today" , 1 ) ; } } catch ( IOException e ) { Util . exceptionHandler ( e , 1 , "WT.run> Unknown error  probably a problem reading logfile" , config , this ) ; } config . outputConfig ( this ) ; wr = new WeatherRecorder ( this , config ) ; wr . run ( ) ; } else if ( runButton . getText ( ) . equals ( "Interrupt" ) ) { runButton . setText ( "Press button again to interrupt" ) ; } else if ( runButton . getText ( ) . equals ( "Press button again to interrupt" ) ) { runButton . setText ( "Forcing quit..." ) ; stopProgram ( ) ; } }
tr	5	public void fileNew ( SimpleFrame frame ) { frame . setAction ( false ) ; frame . setIsFileNameSetted ( false ) ; frame . setTitle ( "Text Editor" ) ; JFileChooser chooser = new JFileChooser ( ) ; if ( frame . getIsChanged ( ) ) { int selection = JOptionPane . showConfirmDialog ( null , "Do you want save document?" , "Warrning" , JOptionPane . YES_NO_OPTION , JOptionPane . WARNING_MESSAGE ) ; if ( selection == JOptionPane . NO_OPTION ) { frame . getText ( ) . setText ( "" ) ; frame . setIsChanged ( false ) ; frame . setTitle ( "Text Editor" ) ; } if ( selection == JOptionPane . YES_OPTION ) { chooser . setCurrentDirectory ( new File ( "." ) ) ; int result = chooser . showSaveDialog ( null ) ; if ( result == JFileChooser . APPROVE_OPTION ) { frame . fileName = chooser . getSelectedFile ( ) . getPath ( ) ; PrintWriter out ; try { out = new PrintWriter ( new FileWriter ( frame . fileName ) ) ; String str = frame . getText ( ) . getText ( ) ; out . print ( str ) ; out . close ( ) ; } catch ( IOException e ) { JOptionPane . showMessageDialog ( frame , "Saving error" ) ; } } frame . getText ( ) . setText ( "" ) ; frame . setIsChanged ( false ) ; frame . setTitle ( "Text Editor" ) ; } } else { frame . getText ( ) . setText ( "" ) ; } frame . setAction ( true ) ; }
tr	8	public ArrayList < SearchBean < FreeBedDetailBean >> searchForFreeBeds ( Hostel info , Date checkIn , Date checkOut , int numberOfBeds ) { ArrayList < SearchBean < FreeBedDetailBean >> result = new ArrayList < SearchBean < FreeBedDetailBean >> ( ) ; write ( result ) ; if ( info == null ) { return null ; } try { ArrayList < Identifier > hostelIds = Hostels . getInstance ( ) . search ( info ) ; if ( hostelIds . size ( ) == 0 ) { return null ; } for ( Identifier hostelId : hostelIds ) { ArrayList < Identifier > bedIds = Hostels . getInstance ( ) . getFreeBeds ( hostelId , checkIn , checkOut ) ; if ( bedIds . size ( ) < numberOfBeds ) { continue ; } if ( numberOfBeds == 1 ) { for ( int i = 0 ; i < bedIds . size ( ) ; i ++ ) { Bed bedInfo = Beds . getInstance ( ) . get ( bedIds . get ( i ) ) ; FreeBedDetailBean bedDetail = new FreeBedDetailBean ( ) ; bedDetail . setCheckIn ( checkIn ) ; bedDetail . setCheckOut ( checkOut ) ; bedDetail . setTotalPrice ( bedInfo . getTariffForDate ( checkIn , checkOut ) . getPrice ( ) ) ; ArrayList < Identifier > topBedIds = new ArrayList < Identifier > ( ) ; ArrayList < Integer > price = new ArrayList < Integer > ( ) ; topBedIds . add ( bedIds . get ( i ) ) ; price . add ( bedInfo . getTariffForDate ( checkIn , checkOut ) . getPrice ( ) ) ; bedDetail . setBedIds ( topBedIds ) ; bedDetail . setPrice ( price ) ; SearchBean < FreeBedDetailBean > bean = new SearchBean < FreeBedDetailBean > ( getNextSearchId ( ) , hostelId , bedDetail ) ; result . add ( bean ) ; } } else { FreeBedDetailBean bedDetail = new FreeBedDetailBean ( ) ; bedDetail . setTotalPrice ( 0 ) ; ArrayList < Identifier > topBedIds = new ArrayList < Identifier > ( ) ; ArrayList < Integer > price = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < numberOfBeds ; i ++ ) { Bed bedInfo = Beds . getInstance ( ) . get ( bedIds . get ( i ) ) ; bedDetail . setCheckIn ( checkIn ) ; bedDetail . setCheckOut ( checkOut ) ; bedDetail . setTotalPrice ( bedDetail . getTotalPrice ( ) + bedInfo . getTariffForDate ( checkIn , checkOut ) . getPrice ( ) ) ; topBedIds . add ( bedIds . get ( i ) ) ; price . add ( bedInfo . getTariffForDate ( checkIn , checkOut ) . getPrice ( ) ) ; } bedDetail . setBedIds ( topBedIds ) ; bedDetail . setPrice ( price ) ; SearchBean < FreeBedDetailBean > bean = new SearchBean < FreeBedDetailBean > ( getNextSearchId ( ) , hostelId , bedDetail ) ; result . add ( bean ) ; } } } catch ( DataBaseReadWriteException | IdentifierNotFoundException | InvalidIdentifierException | InvalidParameterException e ) { e . printStackTrace ( ) ; } write ( result ) ; return result ; }
tr	9	public double pow ( double x , int n ) { if ( x == 0.0 && n > 0 ) return 0.0 ; if ( x == 0.0 && n <= 0 ) return 1.0 ; if ( n == 0 ) return 1.0 ; double out = 1.0 ; int k = 1 ; if ( n > 0 ) { while ( n > 0 ) { k = 2 ; double temp = x ; while ( k < n ) { temp = temp * temp ; k = k * 2 ; } out = out * temp ; k = k / 2 ; n = n - k ; } } else if ( n < 0 ) { n = - n ; while ( n > 0 ) { k = 2 ; double temp = 1 / x ; while ( k < n ) { temp = temp * temp ; k = k * 2 ; } out = out * temp ; k = k / 2 ; n = n - k ; } } return out ; }
tr	9	private Object readValue ( ) throws JSONException { switch ( read ( 2 ) ) { case 0 : return new Integer ( read ( ! bit ( ) ? 4 : ! bit ( ) ? 7 : 14 ) ) ; case 1 : byte [ ] bytes = new byte [ 256 ] ; int length = 0 ; while ( true ) { int c = read ( 4 ) ; if ( c == endOfNumber ) { break ; } bytes [ length ] = bcd [ c ] ; length += 1 ; } Object value ; try { value = JSONObject . stringToValue ( new String ( bytes , 0 , length , "US-ASCII" ) ) ; } catch ( UnsupportedEncodingException e ) { throw new JSONException ( e ) ; } this . values . register ( value ) ; return value ; case 2 : return getAndTick ( this . values , this . bitreader ) ; case 3 : return readJSON ( ) ; default : throw new JSONException ( "Impossible." ) ; } }
tr	3	private boolean bit ( ) throws JSONException { boolean value ; try { value = this . bitreader . bit ( ) ; if ( probe ) { log ( value ? 1 : 0 ) ; } return value ; } catch ( Throwable e ) { throw new JSONException ( e ) ; } }
tr	6	public void log ( Level level , String str ) { if ( level . intValue ( ) >= LogLevel . intValue ( ) ) { StringBuilder out = new StringBuilder ( ) ; out . append ( "[" + clazz . getName ( ) + "]" ) ; out . append ( "[" + level . getName ( ) + "]" ) ; Time currentTime ; if ( Simulator . getWorld ( ) != null && Simulator . getWorld ( ) . getCurrentTime ( ) != null ) currentTime = Simulator . getWorld ( ) . getCurrentTime ( ) ; else currentTime = null ; out . append ( "[" + ( ( currentTime != null ) ? currentTime : "no time" ) + "]" ) ; out . append ( str ) ; if ( Simulator . getGUI ( ) != null ) { if ( level . intValue ( ) > FINE . intValue ( ) ) { JTextArea text = Simulator . getGUI ( ) . getLogWindow ( ) . getTextArea ( ) ; text . append ( out . toString ( ) + "\n" ) ; text . setCaretPosition ( text . getText ( ) . length ( ) ) ; } else { System . out . println ( out ) ; } } else { System . out . println ( out ) ; } } }
tr	7	public void move ( ) { super . move ( ) ; if ( game . t % 30 == 0 ) { shoot ( Math . PI * 3 / 2 ) ; } if ( x >= 8 && x + 8 <= game . viewWidth ( ) ) { if ( y + 32 >= game . viewHeight ( ) && game . goingDown ( angle ) || y <= 32 && game . goingUp ( angle ) ) { this . angle = - this . angle ; } } }
tr	2	public ExactCoverPart ( final ExactCover puzzle , final int row ) { super ( puzzle ) ; this . puzzle = puzzle ; this . row = row ; for ( int col = 0 ; col < puzzle . matrixCols ( ) ; ++ col ) { if ( puzzle . hasPoint ( row , col ) ) { atoms . add ( puzzle . atomAt ( col ) ) ; } } }
tr	8	private boolean interpolateCollection ( Object obj , String basePath , Field field ) throws IllegalAccessException , InterpolationException { Collection c = ( Collection ) field . get ( obj ) ; if ( c != null && ! c . isEmpty ( ) ) { List originalValues = new ArrayList ( c ) ; try { c . clear ( ) ; } catch ( UnsupportedOperationException e ) { warningCollector . add ( new ObjectInterpolationWarning ( "Field is an unmodifiable collection. Skipping interpolation." , basePath + "." + field . getName ( ) , e ) ) ; return true ; } for ( Object value : originalValues ) { if ( value != null ) { if ( String . class == value . getClass ( ) ) { String interpolated = interpolator . interpolate ( ( String ) value , recursionInterceptor ) ; if ( ! interpolated . equals ( value ) ) { c . add ( interpolated ) ; } else { c . add ( value ) ; } } else { c . add ( value ) ; if ( value . getClass ( ) . isArray ( ) ) { evaluateArray ( value , basePath + "." + field . getName ( ) ) ; } else { interpolationTargets . add ( new InterpolationTarget ( value , basePath + "." + field . getName ( ) ) ) ; } } } else { c . add ( value ) ; } } } return false ; }
tr	1	public boolean isLeaf ( Object node ) { if ( asksAllowsChildren ) return ! ( ( TreeNode ) node ) . getAllowsChildren ( ) ; else return ( ( TreeNode ) node ) . isLeaf ( ) ; }
tr	1	@ Override public void windowClosing ( WindowEvent e ) { if ( ClientFrame . this . client . isConnected ( ) ) { ClientFrame . this . client . disconnect ( ) ; } }
tr	9	private void initComponents ( ) throws FileNotFoundException , IOException { String focusdevice = core_ . getFocusDevice ( ) ; String xyStage = core_ . getXYStageDevice ( ) ; String ShutterDev = core_ . getShutterDevice ( ) ; String StateDev = "Arduino_SR-Switch" ; String StateDev_FW = "Arduino_FW-Switch" ; String ShutterDev_FW = "Arduino_FW-Shutter" ; try { core_ . setProperty ( StateDev , "State" , "32" ) ; core_ . setProperty ( ShutterDev , "OnOff" , "1" ) ; core_ . setProperty ( ShutterDev , "OnOff" , "0" ) ; } catch ( Exception ex ) { Logger . getLogger ( DSLM_controlsDialog . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } RC_ = new RotationControl2 ( core_ , StateDev ) ; ShC_ = new ShutterControl ( core_ , StateDev , ShutterDev ) ; FC_ = new FilterControl ( core_ , StateDev_FW , ShutterDev_FW ) ; setDefaultCloseOperation ( javax . swing . WindowConstants . DISPOSE_ON_CLOSE ) ; setTitle ( "OPEN SPIN MICROSCOPY (SPIM/DSLM/OPT) CONTROL" ) ; setResizable ( false ) ; DSLM_controlsDialog . this . setSize ( 600 , 606 ) ; addWindowListener ( new java . awt . event . WindowAdapter ( ) { public void windowClosing ( java . awt . event . WindowEvent evt ) { formWindowClosing ( evt ) ; } } ) ; AcquireButton = new javax . swing . JButton ( ) ; ShutterButton = new javax . swing . JButton ( ) ; AcquireButton . setFont ( new java . awt . Font ( "Tahoma" , 1 , 14 ) ) ; AcquireButton . setText ( "Acquire!" ) ; ShutterButton . setFont ( new java . awt . Font ( "Tahoma" , 1 , 14 ) ) ; ShutterButton . setText ( "Shutter" ) ; ShutterButton . addActionListener ( new java . awt . event . ActionListener ( ) { public void actionPerformed ( java . awt . event . ActionEvent evt ) { try { ShutterButtonActionPerformed ( evt ) ; } catch ( Exception ex ) { Logger . getLogger ( DSLM_controlsDialog . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; MessageTextArea . setText ( "Error in Shutter" ) ; } } } ) ; ModePanel = new javax . swing . JPanel ( ) ; ModeComboBox = new javax . swing . JComboBox ( ) ; ModeLabel = new javax . swing . JLabel ( ) ; ModePanel . setBorder ( javax . swing . BorderFactory . createBevelBorder ( javax . swing . border . BevelBorder . RAISED ) ) ; ModeComboBox . setModel ( new javax . swing . DefaultComboBoxModel ( new String [ ] { "DSLM/SPIM" , "OPT" } ) ) ; ModeComboBox . addActionListener ( new java . awt . event . ActionListener ( ) { public void actionPerformed ( java . awt . event . ActionEvent evt ) { try { ModeActionPerformed ( evt ) ; } catch ( Exception ex ) { Logger . getLogger ( DSLM_controlsDialog . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; MessageTextArea . setText ( "Error in MODE" ) ; } } } ) ; ModeLabel . setFont ( new java . awt . Font ( "Tahoma" , 1 , 11 ) ) ; ModeLabel . setText ( "Mode" ) ; javax . swing . GroupLayout ModePanelLayout = new javax . swing . GroupLayout ( ModePanel ) ; ModePanel . setLayout ( ModePanelLayout ) ; ModePanelLayout . setHorizontalGroup ( ModePanelLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( javax . swing . GroupLayout . Alignment . TRAILING , ModePanelLayout . createSequentialGroup ( ) . addComponent ( ModeLabel ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED , javax . swing . GroupLayout . DEFAULT_SIZE , short . MAX_VALUE ) . addComponent ( ModeComboBox , javax . swing . GroupLayout . PREFERRED_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . PREFERRED_SIZE ) . addContainerGap ( ) ) ) ; ModePanelLayout . setVerticalGroup ( ModePanelLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( javax . swing . GroupLayout . Alignment . TRAILING , ModePanelLayout . createSequentialGroup ( ) . addContainerGap ( javax . swing . GroupLayout . DEFAULT_SIZE , short . MAX_VALUE ) . addGroup ( ModePanelLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . BASELINE ) . addComponent ( ModeComboBox , javax . swing . GroupLayout . PREFERRED_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . PREFERRED_SIZE ) . addComponent ( ModeLabel ) ) . addContainerGap ( ) ) ) ; TimeLapsePanel = new javax . swing . JPanel ( ) ; TimeLapseCheckBox = new javax . swing . JCheckBox ( ) ; TimeFrames = new javax . swing . JSpinner ( ) ; IntervalTime = new javax . swing . JTextField ( ) ; IntervalUnits = new javax . swing . JComboBox ( ) ; NumberLabel = new javax . swing . JLabel ( ) ; IntervalLabel = new javax . swing . JLabel ( ) ; TimeLapsePanel . setBorder ( javax . swing . BorderFactory . createBevelBorder ( javax . swing . border . BevelBorder . RAISED ) ) ; TimeLapseCheckBox . setFont ( new java . awt . Font ( "Tahoma" , 1 , 11 ) ) ; TimeLapseCheckBox . setSelected ( false ) ; TimeLapseCheckBox . setText ( "Time Lapse" ) ; TimeLapseCheckBox . addActionListener ( new java . awt . event . ActionListener ( ) { public void actionPerformed ( java . awt . event . ActionEvent evt ) { TimeLapseCheckBoxActionPerformed ( evt ) ; } } ) ; NumberLabel . setText ( "Number" ) ; NumberLabel . setEnabled ( false ) ; IntervalLabel . setText ( "Interval" ) ; IntervalLabel . setEnabled ( false ) ; TimeFrames . setToolTipText ( "Number of time frames" ) ; TimeFrames . setName ( "" ) ; TimeFrames . setValue ( 2 ) ; TimeFrames . setEnabled ( false ) ; IntervalTime . setHorizontalAlignment ( javax . swing . JTextField . RIGHT ) ; IntervalTime . setText ( "100" ) ; IntervalTime . setEnabled ( false ) ; IntervalTime . setToolTipText ( "Interval between stack of images (in ms  s or min)" ) ; IntervalUnits . setEnabled ( false ) ; IntervalUnits . setModel ( new javax . swing . DefaultComboBoxModel ( new String [ ] { "ms" , "s" , "min" } ) ) ; javax . swing . GroupLayout TimeLapsePanelLayout = new javax . swing . GroupLayout ( TimeLapsePanel ) ; TimeLapsePanel . setLayout ( TimeLapsePanelLayout ) ; TimeLapsePanelLayout . setHorizontalGroup ( TimeLapsePanelLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( TimeLapsePanelLayout . createSequentialGroup ( ) . addContainerGap ( ) . addGroup ( TimeLapsePanelLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . TRAILING ) . addGroup ( TimeLapsePanelLayout . createSequentialGroup ( ) . addComponent ( NumberLabel ) . addGap ( 18 , 18 , 18 ) . addComponent ( TimeFrames ) ) . addGroup ( TimeLapsePanelLayout . createSequentialGroup ( ) . addComponent ( IntervalLabel ) . addGap ( 18 , 18 , 18 ) . addComponent ( IntervalTime , javax . swing . GroupLayout . DEFAULT_SIZE , 48 , short . MAX_VALUE ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addComponent ( IntervalUnits , javax . swing . GroupLayout . PREFERRED_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . PREFERRED_SIZE ) ) ) . addGap ( 14 , 14 , 14 ) ) . addGroup ( TimeLapsePanelLayout . createSequentialGroup ( ) . addComponent ( TimeLapseCheckBox ) . addGap ( 0 , 0 , short . MAX_VALUE ) ) ) ; TimeLapsePanelLayout . setVerticalGroup ( TimeLapsePanelLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( TimeLapsePanelLayout . createSequentialGroup ( ) . addComponent ( TimeLapseCheckBox ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addGroup ( TimeLapsePanelLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( javax . swing . GroupLayout . Alignment . TRAILING , TimeLapsePanelLayout . createSequentialGroup ( ) . addComponent ( NumberLabel ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . UNRELATED ) . addComponent ( IntervalLabel ) ) . addGroup ( javax . swing . GroupLayout . Alignment . TRAILING , TimeLapsePanelLayout . createSequentialGroup ( ) . addComponent ( TimeFrames , javax . swing . GroupLayout . PREFERRED_SIZE , 26 , javax . swing . GroupLayout . PREFERRED_SIZE ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addGroup ( TimeLapsePanelLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . BASELINE ) . addComponent ( IntervalUnits , javax . swing . GroupLayout . PREFERRED_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . PREFERRED_SIZE ) . addComponent ( IntervalTime ) ) ) ) . addContainerGap ( ) ) ) ; StackPanel = new javax . swing . JPanel ( ) ; StackCheckBox = new javax . swing . JCheckBox ( ) ; StartField = new javax . swing . JTextField ( ) ; SetStartButton = new javax . swing . JButton ( ) ; EndField = new javax . swing . JTextField ( ) ; SetEndButton = new javax . swing . JButton ( ) ; StepField = new javax . swing . JTextField ( ) ; StartLabel = new javax . swing . JLabel ( ) ; EndLabel = new javax . swing . JLabel ( ) ; StepLabel = new javax . swing . JLabel ( ) ; StackComboBox = new javax . swing . JComboBox ( ) ; ShutterStackCheckBox = new javax . swing . JCheckBox ( ) ; StackPanel . setBorder ( javax . swing . BorderFactory . createBevelBorder ( javax . swing . border . BevelBorder . RAISED ) ) ; StackCheckBox . setFont ( new java . awt . Font ( "Tahoma" , 1 , 11 ) ) ; StackCheckBox . setSelected ( false ) ; StackCheckBox . setText ( "Stack of Images" ) ; StackCheckBox . addActionListener ( new java . awt . event . ActionListener ( ) { public void actionPerformed ( java . awt . event . ActionEvent evt ) { StackCheckBoxActionPerformed ( evt ) ; } } ) ; StartLabel . setText ( "Start (microns)" ) ; StartLabel . setEnabled ( false ) ; EndLabel . setText ( "End (microns)" ) ; EndLabel . setEnabled ( false ) ; StepLabel . setText ( "Steps (microns)" ) ; StepLabel . setEnabled ( false ) ; StackComboBox . setModel ( new javax . swing . DefaultComboBoxModel ( new String [ ] { "Absolute Z" , "Relative Z" } ) ) ; StackComboBox . setEnabled ( false ) ; ShutterStackCheckBox . setText ( "Use Shutter" ) ; ShutterStackCheckBox . setEnabled ( false ) ; ShutterStackCheckBox . setSelected ( false ) ; StartField . setHorizontalAlignment ( javax . swing . JTextField . RIGHT ) ; StartField . setText ( "0" ) ; String StackPosition = "ERROR" ; try { double pos = core_ . getPosition ( focusdevice ) ; NumberFormat formatter = new DecimalFormat ( "#.0000" ) ; StackPosition = formatter . format ( pos ) ; } catch ( Exception ex ) { Logger . getLogger ( DSLM_controlsDialog . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } StartField . setText ( StackPosition ) ; StartField . setEnabled ( false ) ; StartField . setToolTipText ( "Starting position the stack in microns" ) ; EndField . setHorizontalAlignment ( javax . swing . JTextField . RIGHT ) ; EndField . setText ( "10" ) ; EndField . setText ( StackPosition ) ; EndField . setEnabled ( false ) ; EndField . setToolTipText ( "Finishing position of the stack in microns" ) ; StepField . setHorizontalAlignment ( javax . swing . JTextField . RIGHT ) ; StepField . setText ( "5" ) ; StepField . setEnabled ( false ) ; StepField . setToolTipText ( "Steps in micros between images of the stack" ) ; SetEndButton . setText ( "Set" ) ; SetEndButton . setEnabled ( false ) ; SetEndButton . addActionListener ( new java . awt . event . ActionListener ( ) { public void actionPerformed ( java . awt . event . ActionEvent evt ) { SetEndButtonActionPerformed ( evt ) ; } } ) ; SetStartButton . setText ( "Set" ) ; SetStartButton . setEnabled ( false ) ; SetStartButton . addActionListener ( new java . awt . event . ActionListener ( ) { public void actionPerformed ( java . awt . event . ActionEvent evt ) { SetStartButtonActionPerformed ( evt ) ; } } ) ; javax . swing . GroupLayout StackPanelLayout = new javax . swing . GroupLayout ( StackPanel ) ; StackPanel . setLayout ( StackPanelLayout ) ; StackPanelLayout . setHorizontalGroup ( StackPanelLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( StackPanelLayout . createSequentialGroup ( ) . addComponent ( StackCheckBox ) . addGap ( 0 , 0 , short . MAX_VALUE ) ) . addGroup ( StackPanelLayout . createSequentialGroup ( ) . addGroup ( StackPanelLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( StackPanelLayout . createSequentialGroup ( ) . addContainerGap ( ) . addGroup ( StackPanelLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addComponent ( StepLabel ) . addComponent ( EndLabel ) . addComponent ( StartLabel ) ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED , javax . swing . GroupLayout . DEFAULT_SIZE , short . MAX_VALUE ) . addGroup ( StackPanelLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( StackPanelLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING , false ) . addGroup ( StackPanelLayout . createSequentialGroup ( ) . addComponent ( StartField , javax . swing . GroupLayout . PREFERRED_SIZE , 70 , javax . swing . GroupLayout . PREFERRED_SIZE ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addComponent ( SetStartButton , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , short . MAX_VALUE ) ) . addGroup ( StackPanelLayout . createSequentialGroup ( ) . addComponent ( EndField , javax . swing . GroupLayout . PREFERRED_SIZE , 70 , javax . swing . GroupLayout . PREFERRED_SIZE ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addComponent ( SetEndButton ) ) ) . addComponent ( StepField , javax . swing . GroupLayout . PREFERRED_SIZE , 70 , javax . swing . GroupLayout . PREFERRED_SIZE ) . addComponent ( StackComboBox , javax . swing . GroupLayout . PREFERRED_SIZE , 100 , javax . swing . GroupLayout . PREFERRED_SIZE ) ) ) . addGroup ( StackPanelLayout . createSequentialGroup ( ) . addGap ( 22 , 22 , 22 ) . addComponent ( ShutterStackCheckBox ) . addGap ( 0 , 0 , short . MAX_VALUE ) ) ) . addContainerGap ( ) ) ) ; StackPanelLayout . setVerticalGroup ( StackPanelLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( StackPanelLayout . createSequentialGroup ( ) . addComponent ( StackCheckBox ) . addGap ( 9 , 9 , 9 ) . addGroup ( StackPanelLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( StackPanelLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . BASELINE ) . addComponent ( StartField , javax . swing . GroupLayout . PREFERRED_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . PREFERRED_SIZE ) . addComponent ( SetStartButton ) ) . addComponent ( StartLabel , javax . swing . GroupLayout . Alignment . TRAILING ) ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addGroup ( StackPanelLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( StackPanelLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . BASELINE ) . addComponent ( EndField , javax . swing . GroupLayout . PREFERRED_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . PREFERRED_SIZE ) . addComponent ( SetEndButton ) ) . addComponent ( EndLabel , javax . swing . GroupLayout . Alignment . TRAILING ) ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . UNRELATED ) . addGroup ( StackPanelLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . BASELINE ) . addComponent ( StepField , javax . swing . GroupLayout . PREFERRED_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . PREFERRED_SIZE ) . addComponent ( StepLabel ) ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . UNRELATED ) . addComponent ( StackComboBox , javax . swing . GroupLayout . PREFERRED_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . PREFERRED_SIZE ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addComponent ( ShutterStackCheckBox ) . addContainerGap ( javax . swing . GroupLayout . DEFAULT_SIZE , short . MAX_VALUE ) ) ) ; RotationPanel = new javax . swing . JPanel ( ) ; RotationSampleLabel = new javax . swing . JLabel ( ) ; RotationComboBox = new javax . swing . JComboBox ( ) ; RotationLabel = new javax . swing . JLabel ( ) ; ShutterRotationCheckBox = new javax . swing . JCheckBox ( ) ; RotationComboBox . setEnabled ( true ) ; RotationLabel . setEnabled ( true ) ; ShutterRotationCheckBox . setEnabled ( true ) ; ShutterRotationCheckBox . setSelected ( false ) ; RotationPanel . setBorder ( javax . swing . BorderFactory . createBevelBorder ( javax . swing . border . BevelBorder . RAISED ) ) ; RotationSampleLabel . setFont ( new java . awt . Font ( "Tahoma" , 1 , 11 ) ) ; RotationSampleLabel . setText ( "Rotation" ) ; RotationLabel . setText ( "Rotation angle" ) ; ShutterRotationCheckBox . setText ( "Use Shutter" ) ; RotationComboBox . setModel ( new javax . swing . DefaultComboBoxModel ( new String [ ] { "0" , "45" , "90" , "180" , "360" , "1.8" , "0.9" , "0.45" , "0.225" } ) ) ; RotationComboBox . setToolTipText ( "Select the rotation angle for the automatic recording" ) ; javax . swing . GroupLayout RotationPanelLayout = new javax . swing . GroupLayout ( RotationPanel ) ; RotationPanel . setLayout ( RotationPanelLayout ) ; RotationPanelLayout . setHorizontalGroup ( RotationPanelLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( RotationPanelLayout . createSequentialGroup ( ) . addGroup ( RotationPanelLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( javax . swing . GroupLayout . Alignment . TRAILING , RotationPanelLayout . createSequentialGroup ( ) . addGap ( 0 , 0 , short . MAX_VALUE ) . addGroup ( RotationPanelLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( RotationPanelLayout . createSequentialGroup ( ) . addGap ( 10 , 10 , 10 ) . addComponent ( ShutterRotationCheckBox ) ) . addGroup ( RotationPanelLayout . createSequentialGroup ( ) . addComponent ( RotationLabel ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addComponent ( RotationComboBox , javax . swing . GroupLayout . PREFERRED_SIZE , 73 , javax . swing . GroupLayout . PREFERRED_SIZE ) ) ) ) . addGroup ( RotationPanelLayout . createSequentialGroup ( ) . addContainerGap ( ) . addComponent ( RotationSampleLabel ) . addGap ( 0 , 0 , short . MAX_VALUE ) ) ) . addContainerGap ( ) ) ) ; RotationPanelLayout . setVerticalGroup ( RotationPanelLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( RotationPanelLayout . createSequentialGroup ( ) . addGap ( 5 , 5 , 5 ) . addComponent ( RotationSampleLabel ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addGroup ( RotationPanelLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . BASELINE ) . addComponent ( RotationComboBox , javax . swing . GroupLayout . PREFERRED_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . PREFERRED_SIZE ) . addComponent ( RotationLabel ) ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED , 9 , short . MAX_VALUE ) . addComponent ( ShutterRotationCheckBox ) ) ) ; SaveImagesPanel = new javax . swing . JPanel ( ) ; SaveCheckBox = new javax . swing . JCheckBox ( ) ; RootDirectoryField = new javax . swing . JTextField ( ) ; RootLabel = new javax . swing . JLabel ( ) ; DirectoryButton = new javax . swing . JButton ( ) ; FileNameField = new javax . swing . JTextField ( ) ; FileLabel = new javax . swing . JLabel ( ) ; fc = new javax . swing . JFileChooser ( ) ; SaveImagesPanel . setBorder ( javax . swing . BorderFactory . createBevelBorder ( javax . swing . border . BevelBorder . RAISED ) ) ; SaveCheckBox . setFont ( new java . awt . Font ( "Tahoma" , 1 , 11 ) ) ; SaveCheckBox . setSelected ( true ) ; SaveCheckBox . setText ( "Save Images" ) ; SaveCheckBox . addActionListener ( new java . awt . event . ActionListener ( ) { public void actionPerformed ( java . awt . event . ActionEvent evt ) { SaveCheckBoxActionPerformed ( evt ) ; } } ) ; DirectoryButton . setText ( "..." ) ; DirectoryButton . setEnabled ( true ) ; DirectoryButton . addActionListener ( new java . awt . event . ActionListener ( ) { public void actionPerformed ( java . awt . event . ActionEvent evt ) { DirectoryButtonActionPerformed ( evt ) ; } } ) ; RootDirectoryField . setText ( "D:\\DSLM_DATA\\SPIM_V10" ) ; RootDirectoryField . setEnabled ( true ) ; RootLabel . setText ( "Root Directory" ) ; RootLabel . setEnabled ( true ) ; FileNameField . setText ( "Sample" ) ; FileNameField . setEnabled ( true ) ; FileLabel . setText ( "File name" ) ; FileLabel . setEnabled ( true ) ; javax . swing . GroupLayout SaveImagesPanelLayout = new javax . swing . GroupLayout ( SaveImagesPanel ) ; SaveImagesPanel . setLayout ( SaveImagesPanelLayout ) ; SaveImagesPanelLayout . setHorizontalGroup ( SaveImagesPanelLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( SaveImagesPanelLayout . createSequentialGroup ( ) . addContainerGap ( ) . addGroup ( SaveImagesPanelLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addComponent ( SaveCheckBox ) . addGroup ( SaveImagesPanelLayout . createSequentialGroup ( ) . addGap ( 12 , 12 , 12 ) . addGroup ( SaveImagesPanelLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addComponent ( RootLabel ) . addComponent ( FileLabel ) ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . UNRELATED ) . addGroup ( SaveImagesPanelLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addComponent ( RootDirectoryField , javax . swing . GroupLayout . DEFAULT_SIZE , 246 , short . MAX_VALUE ) . addComponent ( FileNameField ) ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addComponent ( DirectoryButton ) ) ) . addGap ( 13 , 13 , 13 ) ) ) ; SaveImagesPanelLayout . setVerticalGroup ( SaveImagesPanelLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( SaveImagesPanelLayout . createSequentialGroup ( ) . addComponent ( SaveCheckBox ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addGroup ( SaveImagesPanelLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . BASELINE ) . addComponent ( RootDirectoryField , javax . swing . GroupLayout . PREFERRED_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . PREFERRED_SIZE ) . addComponent ( RootLabel ) . addComponent ( DirectoryButton ) ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addGroup ( SaveImagesPanelLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . BASELINE ) . addComponent ( FileNameField , javax . swing . GroupLayout . PREFERRED_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . PREFERRED_SIZE ) . addComponent ( FileLabel ) ) . addContainerGap ( javax . swing . GroupLayout . DEFAULT_SIZE , short . MAX_VALUE ) ) ) ; Message_Pannel = new javax . swing . JPanel ( ) ; Message_scroll_pane = new javax . swing . JScrollPane ( ) ; MessageTextArea = new javax . swing . JTextArea ( ) ; MessageLabel = new javax . swing . JLabel ( ) ; Message_Pannel . setBorder ( javax . swing . BorderFactory . createBevelBorder ( javax . swing . border . BevelBorder . RAISED ) ) ; Message_Pannel . setFont ( new java . awt . Font ( "Tahoma" , 1 , 11 ) ) ; MessageTextArea . setColumns ( 20 ) ; MessageTextArea . setFont ( new java . awt . Font ( "Tahoma" , 0 , 10 ) ) ; MessageTextArea . setRows ( 2 ) ; Message_scroll_pane . setViewportView ( MessageTextArea ) ; MessageLabel . setFont ( new java . awt . Font ( "Tahoma" , 1 , 11 ) ) ; MessageLabel . setText ( "Messages" ) ; javax . swing . GroupLayout Message_PannelLayout = new javax . swing . GroupLayout ( Message_Pannel ) ; Message_Pannel . setLayout ( Message_PannelLayout ) ; Message_PannelLayout . setHorizontalGroup ( Message_PannelLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( Message_PannelLayout . createSequentialGroup ( ) . addGroup ( Message_PannelLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addComponent ( MessageLabel ) . addComponent ( Message_scroll_pane , javax . swing . GroupLayout . PREFERRED_SIZE , 131 , javax . swing . GroupLayout . PREFERRED_SIZE ) ) . addGap ( 0 , 0 , short . MAX_VALUE ) ) ) ; Message_PannelLayout . setVerticalGroup ( Message_PannelLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( javax . swing . GroupLayout . Alignment . TRAILING , Message_PannelLayout . createSequentialGroup ( ) . addComponent ( MessageLabel ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addComponent ( Message_scroll_pane , javax . swing . GroupLayout . DEFAULT_SIZE , 65 , short . MAX_VALUE ) ) ) ; StageControlPanel = new javax . swing . JPanel ( ) ; UPUPButton = new javax . swing . JButton ( ) ; UPButton = new javax . swing . JButton ( ) ; DownButton = new javax . swing . JButton ( ) ; DownDownButton = new javax . swing . JButton ( ) ; PositionField = new javax . swing . JTextField ( ) ; PositionLabel = new javax . swing . JLabel ( ) ; UpUpField = new javax . swing . JTextField ( ) ; UpField = new javax . swing . JTextField ( ) ; StageControlLabel = new javax . swing . JLabel ( ) ; StageControlPanel . setBorder ( javax . swing . BorderFactory . createBevelBorder ( javax . swing . border . BevelBorder . RAISED ) ) ; PositionLabel . setText ( "Position" ) ; StageControlLabel . setFont ( new java . awt . Font ( "Tahoma" , 1 , 11 ) ) ; StageControlLabel . setText ( "Stage Control" ) ; UPUPButton . setFont ( new java . awt . Font ( "Tahoma" , 1 , 14 ) ) ; UPUPButton . setText ( "\u02C4\u02C4" ) ; UPUPButton . addActionListener ( new java . awt . event . ActionListener ( ) { public void actionPerformed ( java . awt . event . ActionEvent evt ) { UPUPButtonActionPerformed ( evt ) ; } } ) ; UPButton . setFont ( new java . awt . Font ( "Tahoma" , 1 , 14 ) ) ; UPButton . setText ( "\u02C4" ) ; UPButton . addActionListener ( new java . awt . event . ActionListener ( ) { public void actionPerformed ( java . awt . event . ActionEvent evt ) { UPButtonActionPerformed ( evt ) ; } } ) ; DownButton . setFont ( new java . awt . Font ( "Tahoma" , 1 , 14 ) ) ; DownButton . setText ( "\u02C5" ) ; DownButton . addActionListener ( new java . awt . event . ActionListener ( ) { public void actionPerformed ( java . awt . event . ActionEvent evt ) { DownButtonActionPerformed ( evt ) ; } } ) ; DownDownButton . setFont ( new java . awt . Font ( "Tahoma" , 1 , 14 ) ) ; DownDownButton . setText ( "\u02C5\u02C5" ) ; DownDownButton . addActionListener ( new java . awt . event . ActionListener ( ) { public void actionPerformed ( java . awt . event . ActionEvent evt ) { DownDownButtonActionPerformed ( evt ) ; } } ) ; PositionField . setHorizontalAlignment ( javax . swing . JTextField . RIGHT ) ; PositionField . setText ( "0" ) ; PositionField . setText ( StackPosition ) ; PositionField . setEditable ( false ) ; PositionField . setBackground ( new java . awt . Color ( 230 , 230 , 230 ) ) ; UpUpField . setHorizontalAlignment ( javax . swing . JTextField . RIGHT ) ; UpUpField . setText ( "100" ) ; UpField . setHorizontalAlignment ( javax . swing . JTextField . RIGHT ) ; UpField . setText ( "10" ) ; javax . swing . GroupLayout StageControlPanelLayout = new javax . swing . GroupLayout ( StageControlPanel ) ; StageControlPanel . setLayout ( StageControlPanelLayout ) ; StageControlPanelLayout . setHorizontalGroup ( StageControlPanelLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( javax . swing . GroupLayout . Alignment . TRAILING , StageControlPanelLayout . createSequentialGroup ( ) . addContainerGap ( javax . swing . GroupLayout . DEFAULT_SIZE , short . MAX_VALUE ) . addGroup ( StageControlPanelLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addComponent ( StageControlLabel ) . addGroup ( StageControlPanelLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( javax . swing . GroupLayout . Alignment . TRAILING , StageControlPanelLayout . createSequentialGroup ( ) . addComponent ( UpUpField , javax . swing . GroupLayout . PREFERRED_SIZE , 46 , javax . swing . GroupLayout . PREFERRED_SIZE ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addComponent ( UPUPButton ) ) . addGroup ( javax . swing . GroupLayout . Alignment . TRAILING , StageControlPanelLayout . createSequentialGroup ( ) . addComponent ( UpField , javax . swing . GroupLayout . PREFERRED_SIZE , 46 , javax . swing . GroupLayout . PREFERRED_SIZE ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addGroup ( StageControlPanelLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING , false ) . addComponent ( UPButton , javax . swing . GroupLayout . Alignment . TRAILING , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , short . MAX_VALUE ) . addComponent ( DownButton , javax . swing . GroupLayout . Alignment . TRAILING , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , short . MAX_VALUE ) . addComponent ( DownDownButton , javax . swing . GroupLayout . Alignment . TRAILING , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , short . MAX_VALUE ) ) ) . addGroup ( javax . swing . GroupLayout . Alignment . TRAILING , StageControlPanelLayout . createSequentialGroup ( ) . addComponent ( PositionLabel ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addComponent ( PositionField , javax . swing . GroupLayout . PREFERRED_SIZE , 68 , javax . swing . GroupLayout . PREFERRED_SIZE ) ) ) ) . addContainerGap ( ) ) ) ; StageControlPanelLayout . setVerticalGroup ( StageControlPanelLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( StageControlPanelLayout . createSequentialGroup ( ) . addComponent ( StageControlLabel ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addGroup ( StageControlPanelLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . BASELINE ) . addComponent ( UPUPButton ) . addComponent ( UpUpField , javax . swing . GroupLayout . PREFERRED_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . PREFERRED_SIZE ) ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addGroup ( StageControlPanelLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . BASELINE ) . addComponent ( UPButton ) . addComponent ( UpField , javax . swing . GroupLayout . PREFERRED_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . PREFERRED_SIZE ) ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addGroup ( StageControlPanelLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . BASELINE ) . addComponent ( PositionField , javax . swing . GroupLayout . PREFERRED_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . PREFERRED_SIZE ) . addComponent ( PositionLabel ) ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addComponent ( DownButton ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addComponent ( DownDownButton ) . addContainerGap ( 15 , short . MAX_VALUE ) ) ) ; RotationControlPanel = new javax . swing . JPanel ( ) ; RotationControlLabel = new javax . swing . JLabel ( ) ; LeftButton = new javax . swing . JButton ( ) ; RightButton = new javax . swing . JButton ( ) ; AnglePositionField = new javax . swing . JTextField ( ) ; AngleLabel = new javax . swing . JLabel ( ) ; MakeZeroButton = new javax . swing . JButton ( ) ; StepAngleComboBox = new javax . swing . JComboBox ( ) ; StepAngleLabel = new javax . swing . JLabel ( ) ; LineCheckBox = new javax . swing . JCheckBox ( ) ; RotationControlPanel . setBorder ( javax . swing . BorderFactory . createBevelBorder ( javax . swing . border . BevelBorder . RAISED ) ) ; RotationControlLabel . setFont ( new java . awt . Font ( "Tahoma" , 1 , 11 ) ) ; RotationControlLabel . setText ( "Rotation Control" ) ; AnglePositionField . setHorizontalAlignment ( javax . swing . JTextField . RIGHT ) ; AnglePositionField . setText ( "180.000" ) ; AngleLabel . setText ( "Angle" ) ; StepAngleLabel . setText ( "Step" ) ; MakeZeroButton . setText ( "Make Zero" ) ; MakeZeroButton . addActionListener ( new java . awt . event . ActionListener ( ) { public void actionPerformed ( java . awt . event . ActionEvent evt ) { MakeZeroButtonActionPerformed ( evt ) ; } } ) ; LeftButton . setFont ( new java . awt . Font ( "Tahoma" , 1 , 14 ) ) ; LeftButton . setText ( "<" ) ; LeftButton . addActionListener ( new java . awt . event . ActionListener ( ) { public void actionPerformed ( java . awt . event . ActionEvent evt ) { try { LeftButtonActionPerformed ( evt ) ; } catch ( Exception ex ) { Logger . getLogger ( DSLM_controlsDialog . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; MessageTextArea . setText ( "Error in LeftButton" ) ; } } } ) ; RightButton . setFont ( new java . awt . Font ( "Tahoma" , 1 , 14 ) ) ; RightButton . setText ( ">" ) ; RightButton . addActionListener ( new java . awt . event . ActionListener ( ) { public void actionPerformed ( java . awt . event . ActionEvent evt ) { try { RightButtonActionPerformed ( evt ) ; } catch ( Exception ex ) { Logger . getLogger ( DSLM_controlsDialog . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; MessageTextArea . setText ( "Error in RightButton" ) ; } } } ) ; StepAngleComboBox . setModel ( new javax . swing . DefaultComboBoxModel ( new String [ ] { "0" , "45" , "90" , "180" , "360" , "18" , "9" , "1.8" , "0.9" , "0.45" , "0.225" } ) ) ; LineCheckBox . setText ( "Line" ) ; LineCheckBox . setHorizontalTextPosition ( javax . swing . SwingConstants . CENTER ) ; LineCheckBox . setVerticalTextPosition ( javax . swing . SwingConstants . TOP ) ; LineCheckBox . addActionListener ( new java . awt . event . ActionListener ( ) { public void actionPerformed ( java . awt . event . ActionEvent evt ) { LineCheckBoxActionPerformed ( evt ) ; } } ) ; javax . swing . GroupLayout RotationControlPanelLayout = new javax . swing . GroupLayout ( RotationControlPanel ) ; RotationControlPanel . setLayout ( RotationControlPanelLayout ) ; RotationControlPanelLayout . setHorizontalGroup ( RotationControlPanelLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( javax . swing . GroupLayout . Alignment . TRAILING , RotationControlPanelLayout . createSequentialGroup ( ) . addGap ( 0 , 0 , short . MAX_VALUE ) . addComponent ( LeftButton ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addGroup ( RotationControlPanelLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addComponent ( AngleLabel ) . addGroup ( RotationControlPanelLayout . createSequentialGroup ( ) . addComponent ( AnglePositionField , javax . swing . GroupLayout . PREFERRED_SIZE , 46 , javax . swing . GroupLayout . PREFERRED_SIZE ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addComponent ( RightButton ) ) ) . addGap ( 1 , 1 , 1 ) ) . addGroup ( RotationControlPanelLayout . createSequentialGroup ( ) . addContainerGap ( ) . addGroup ( RotationControlPanelLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( RotationControlPanelLayout . createSequentialGroup ( ) . addComponent ( RotationControlLabel ) . addGap ( 0 , 0 , short . MAX_VALUE ) ) . addGroup ( RotationControlPanelLayout . createSequentialGroup ( ) . addGroup ( RotationControlPanelLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( RotationControlPanelLayout . createSequentialGroup ( ) . addGap ( 8 , 8 , 8 ) . addComponent ( StepAngleLabel ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . UNRELATED ) . addComponent ( StepAngleComboBox , javax . swing . GroupLayout . PREFERRED_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . PREFERRED_SIZE ) . addGap ( 0 , 0 , short . MAX_VALUE ) ) . addGroup ( javax . swing . GroupLayout . Alignment . TRAILING , RotationControlPanelLayout . createSequentialGroup ( ) . addGap ( 0 , 0 , short . MAX_VALUE ) . addComponent ( MakeZeroButton ) ) ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . UNRELATED ) . addComponent ( LineCheckBox ) ) ) . addContainerGap ( ) ) ) ; RotationControlPanelLayout . setVerticalGroup ( RotationControlPanelLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( RotationControlPanelLayout . createSequentialGroup ( ) . addGap ( 7 , 7 , 7 ) . addComponent ( RotationControlLabel , javax . swing . GroupLayout . PREFERRED_SIZE , 14 , javax . swing . GroupLayout . PREFERRED_SIZE ) . addGroup ( RotationControlPanelLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( RotationControlPanelLayout . createSequentialGroup ( ) . addGap ( 1 , 1 , 1 ) . addComponent ( AngleLabel ) . addGap ( 0 , 0 , short . MAX_VALUE ) ) . addGroup ( RotationControlPanelLayout . createSequentialGroup ( ) . addGap ( 18 , 18 , 18 ) . addGroup ( RotationControlPanelLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . BASELINE ) . addComponent ( LeftButton ) . addComponent ( AnglePositionField ) . addComponent ( RightButton ) ) ) ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . UNRELATED ) . addGroup ( RotationControlPanelLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . TRAILING ) . addGroup ( RotationControlPanelLayout . createSequentialGroup ( ) . addGroup ( RotationControlPanelLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . BASELINE ) . addComponent ( StepAngleLabel ) . addComponent ( StepAngleComboBox , javax . swing . GroupLayout . PREFERRED_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . PREFERRED_SIZE ) ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addComponent ( MakeZeroButton ) ) . addComponent ( LineCheckBox ) ) ) ) ; GalvoControlPanel = new javax . swing . JPanel ( ) ; GalvoCheckBox = new javax . swing . JCheckBox ( ) ; GAmpTextField = new javax . swing . JTextField ( ) ; GAmpLabel = new javax . swing . JLabel ( ) ; GFreqTextField = new javax . swing . JTextField ( ) ; GFreqLabel = new javax . swing . JLabel ( ) ; GResetButton = new javax . swing . JButton ( ) ; GHomeButton = new javax . swing . JButton ( ) ; ChannelControlPanel = new javax . swing . JPanel ( ) ; GalvoControlPanel . setBorder ( javax . swing . BorderFactory . createBevelBorder ( javax . swing . border . BevelBorder . RAISED ) ) ; GalvoCheckBox . setFont ( new java . awt . Font ( "Tahoma" , 1 , 11 ) ) ; GalvoCheckBox . setText ( "Galvo" ) ; GalvoCheckBox . setSelected ( false ) ; GalvoCheckBox . addActionListener ( new java . awt . event . ActionListener ( ) { public void actionPerformed ( java . awt . event . ActionEvent evt ) { GalvoCheckBoxActionPerformed ( evt ) ; } } ) ; GAmpTextField . setText ( "2" ) ; GAmpTextField . setHorizontalAlignment ( javax . swing . JTextField . RIGHT ) ; GAmpLabel . setText ( " Amp. (V)" ) ; GFreqTextField . setText ( "100" ) ; GFreqTextField . setHorizontalAlignment ( javax . swing . JTextField . RIGHT ) ; GFreqLabel . setText ( "Freq. (Hz)" ) ; GAmpTextField . setEnabled ( false ) ; GAmpLabel . setEnabled ( false ) ; GFreqTextField . setEnabled ( false ) ; GFreqLabel . setEnabled ( false ) ; GResetButton . setText ( "   MOVE   " ) ; GResetButton . setFont ( new java . awt . Font ( "Tahoma" , 1 , 8 ) ) ; GResetButton . setEnabled ( false ) ; GResetButton . addActionListener ( new java . awt . event . ActionListener ( ) { public void actionPerformed ( java . awt . event . ActionEvent evt ) { GResetButtonActionPerformed ( evt ) ; } } ) ; GHomeButton . setText ( "  SET  " ) ; GHomeButton . setFont ( new java . awt . Font ( "Tahoma" , 1 , 8 ) ) ; GHomeButton . setEnabled ( false ) ; GHomeButton . addActionListener ( new java . awt . event . ActionListener ( ) { public void actionPerformed ( java . awt . event . ActionEvent evt ) { GHomeButtonActionPerformed ( evt ) ; } } ) ; javax . swing . GroupLayout GalvoControlPanelLayout = new javax . swing . GroupLayout ( GalvoControlPanel ) ; GalvoControlPanel . setLayout ( GalvoControlPanelLayout ) ; GalvoControlPanelLayout . setHorizontalGroup ( GalvoControlPanelLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( GalvoControlPanelLayout . createSequentialGroup ( ) . addComponent ( GalvoCheckBox ) . addGap ( 0 , 0 , short . MAX_VALUE ) ) . addGroup ( GalvoControlPanelLayout . createSequentialGroup ( ) . addContainerGap ( ) . addGroup ( GalvoControlPanelLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( GalvoControlPanelLayout . createSequentialGroup ( ) . addComponent ( GResetButton , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , short . MAX_VALUE ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addComponent ( GHomeButton , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , short . MAX_VALUE ) ) . addGroup ( GalvoControlPanelLayout . createSequentialGroup ( ) . addGroup ( GalvoControlPanelLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addComponent ( GFreqLabel ) . addComponent ( GAmpLabel ) ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . UNRELATED ) . addGroup ( GalvoControlPanelLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addComponent ( GAmpTextField ) . addComponent ( GFreqTextField ) ) . addContainerGap ( ) ) ) ) ) ; GalvoControlPanelLayout . setVerticalGroup ( GalvoControlPanelLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( GalvoControlPanelLayout . createSequentialGroup ( ) . addComponent ( GalvoCheckBox ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addGroup ( GalvoControlPanelLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . BASELINE ) . addComponent ( GAmpTextField , javax . swing . GroupLayout . PREFERRED_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . PREFERRED_SIZE ) . addComponent ( GAmpLabel ) ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addGroup ( GalvoControlPanelLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . BASELINE ) . addComponent ( GFreqTextField , javax . swing . GroupLayout . PREFERRED_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . PREFERRED_SIZE ) . addComponent ( GFreqLabel ) ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addGroup ( GalvoControlPanelLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . BASELINE ) . addComponent ( GResetButton , javax . swing . GroupLayout . PREFERRED_SIZE , 0 , short . MAX_VALUE ) . addComponent ( GHomeButton , javax . swing . GroupLayout . PREFERRED_SIZE , 18 , javax . swing . GroupLayout . PREFERRED_SIZE ) ) . addGap ( 5 , 5 , 5 ) ) ) ; ChannelControlPanel = new javax . swing . JPanel ( ) ; ChannelControlPanel . setBorder ( javax . swing . BorderFactory . createBevelBorder ( javax . swing . border . BevelBorder . RAISED ) ) ; Channel_CheckBox = new javax . swing . JCheckBox ( ) ; Channel_CheckBox . setFont ( new java . awt . Font ( "Tahoma" , 1 , 11 ) ) ; Channel_CheckBox . setText ( "Channels" ) ; Channel_CheckBox . addActionListener ( new java . awt . event . ActionListener ( ) { public void actionPerformed ( java . awt . event . ActionEvent evt ) { ChannelCheckBoxActionPerformed ( evt ) ; } } ) ; String [ ] Excitation_filters = { "Empty01" , "488/10" , "568/10" , "488/568" , "647/10" , "Empty02" } ; String [ ] Emission_filters = { "535/70" , "580/25" , "620/90" , "640/25" , "SP 700" , "700/75" } ; String Channels [ ] = new String [ 6 ] ; try { String current = System . getProperty ( "user.dir" ) ; File file = new File ( current + "\\mmplugins\\Config_EX_file.txt" ) ; FileReader fr = new FileReader ( file ) ; BufferedReader reader = new BufferedReader ( fr ) ; String line = reader . readLine ( ) ; for ( int nn = 0 ; nn < 6 ; nn ++ ) { line = reader . readLine ( ) ; Excitation_filters [ nn ] = line ; } line = reader . readLine ( ) ; for ( int nn = 0 ; nn < 6 ; nn ++ ) { line = reader . readLine ( ) ; Emission_filters [ nn ] = line ; } line = reader . readLine ( ) ; line = reader . readLine ( ) ; for ( int nn = 0 ; nn < 6 ; nn ++ ) { line = reader . readLine ( ) ; Channels [ nn ] = line ; } } catch ( FileNotFoundException e ) { MessageTextArea . setText ( "Error in Config_Ex_file" ) ; } catch ( IOException e ) { MessageTextArea . setText ( "Error in Config_Ex_file" ) ; } String [ ] CH0 = Channels [ 0 ] . split ( ":" ) ; String [ ] CH1 = Channels [ 1 ] . split ( ":" ) ; String [ ] CH2 = Channels [ 2 ] . split ( ":" ) ; String [ ] CH3 = Channels [ 3 ] . split ( ":" ) ; String [ ] CH4 = Channels [ 4 ] . split ( ":" ) ; String [ ] CH5 = Channels [ 5 ] . split ( ":" ) ; Excitation_ComboBox = new javax . swing . JComboBox ( Excitation_filters ) ; Emission_ComboBox = new javax . swing . JComboBox ( Emission_filters ) ; Excitation_ComboBox2 = new javax . swing . JComboBox ( Excitation_filters ) ; Emission_ComboBox2 = new javax . swing . JComboBox ( Emission_filters ) ; Excitation_label = new javax . swing . JLabel ( ) ; Emission_label = new javax . swing . JLabel ( ) ; ChannelScrollPane = new javax . swing . JScrollPane ( ) ; Channels_table = new javax . swing . JTable ( ) ; ChannelScrollPane . setViewportView ( Channels_table ) ; Channels_table . setEnabled ( false ) ; ChannelScrollPane . setEnabled ( false ) ; Channels_table . setVisible ( false ) ; Emission_ComboBox . addActionListener ( new java . awt . event . ActionListener ( ) { public void actionPerformed ( java . awt . event . ActionEvent evt ) { Emission_ComboBoxActionPerformed ( evt ) ; } } ) ; Excitation_ComboBox . addActionListener ( new java . awt . event . ActionListener ( ) { public void actionPerformed ( java . awt . event . ActionEvent evt ) { Excitation_ComboBoxActionPerformed ( evt ) ; } } ) ; Excitation_label . setFont ( new java . awt . Font ( "Tahoma" , 1 , 11 ) ) ; Excitation_label . setText ( "Excitation" ) ; Emission_label . setFont ( new java . awt . Font ( "Tahoma" , 1 , 11 ) ) ; Emission_label . setText ( "Emission" ) ; Channels_table . setFont ( new java . awt . Font ( "Tahoma" , 0 , 10 ) ) ; Channels_table . setModel ( new javax . swing . table . DefaultTableModel ( new Object [ ] [ ] { { CH0 [ 0 ] , CH0 [ 1 ] , CH0 [ 2 ] , CH0 [ 3 ] , boolean . parseBoolean ( CH0 [ 4 ] ) } , { CH1 [ 0 ] , CH1 [ 1 ] , CH1 [ 2 ] , CH1 [ 3 ] , boolean . parseBoolean ( CH1 [ 4 ] ) } , { CH2 [ 0 ] , CH2 [ 1 ] , CH2 [ 2 ] , CH2 [ 3 ] , boolean . parseBoolean ( CH2 [ 4 ] ) } , { CH3 [ 0 ] , CH3 [ 1 ] , CH3 [ 2 ] , CH3 [ 3 ] , boolean . parseBoolean ( CH3 [ 4 ] ) } , { CH4 [ 0 ] , CH4 [ 1 ] , CH4 [ 2 ] , CH4 [ 3 ] , boolean . parseBoolean ( CH4 [ 4 ] ) } , { CH5 [ 0 ] , CH5 [ 1 ] , CH5 [ 2 ] , CH5 [ 3 ] , boolean . parseBoolean ( CH5 [ 4 ] ) } } , new String [ ] { "Name" , "Excitation" , "Emission" , "Exposure" , "ON/OFF" } ) { class [ ] types = new class [ ] { java . lang . String . class , java . lang . Object . class , java . lang . Object . class , java . lang . String . class , java . lang . boolean . class } ; public class getColumnClass ( int columnIndex ) { return types [ columnIndex ] ; } } ) ; Channels_table . setCursor ( new java . awt . Cursor ( java . awt . Cursor . DEFAULT_CURSOR ) ) ; Channels_table . setRowHeight ( 13 ) ; Channels_table . getColumnModel ( ) . getColumn ( 1 ) . setCellEditor ( new javax . swing . DefaultCellEditor ( Excitation_ComboBox2 ) ) ; Channels_table . getColumnModel ( ) . getColumn ( 2 ) . setCellEditor ( new javax . swing . DefaultCellEditor ( Emission_ComboBox2 ) ) ; javax . swing . GroupLayout ChannelControlPanelLayout = new javax . swing . GroupLayout ( ChannelControlPanel ) ; ChannelControlPanel . setLayout ( ChannelControlPanelLayout ) ; ChannelControlPanelLayout . setHorizontalGroup ( ChannelControlPanelLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( ChannelControlPanelLayout . createSequentialGroup ( ) . addContainerGap ( ) . addComponent ( Channel_CheckBox ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addComponent ( ChannelScrollPane , javax . swing . GroupLayout . PREFERRED_SIZE , 321 , javax . swing . GroupLayout . PREFERRED_SIZE ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . UNRELATED ) . addGroup ( ChannelControlPanelLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( ChannelControlPanelLayout . createSequentialGroup ( ) . addComponent ( Excitation_label ) . addGap ( 18 , 18 , 18 ) . addComponent ( Emission_label ) ) . addGroup ( ChannelControlPanelLayout . createSequentialGroup ( ) . addComponent ( Excitation_ComboBox , javax . swing . GroupLayout . PREFERRED_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . PREFERRED_SIZE ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addComponent ( Emission_ComboBox , javax . swing . GroupLayout . PREFERRED_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . PREFERRED_SIZE ) ) ) . addGap ( 0 , 13 , short . MAX_VALUE ) ) ) ; ChannelControlPanelLayout . setVerticalGroup ( ChannelControlPanelLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addComponent ( ChannelScrollPane , javax . swing . GroupLayout . PREFERRED_SIZE , 0 , short . MAX_VALUE ) . addGroup ( ChannelControlPanelLayout . createSequentialGroup ( ) . addComponent ( Channel_CheckBox ) . addGap ( 0 , 0 , short . MAX_VALUE ) ) . addGroup ( ChannelControlPanelLayout . createSequentialGroup ( ) . addContainerGap ( ) . addGroup ( ChannelControlPanelLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . BASELINE ) . addComponent ( Excitation_label ) . addComponent ( Emission_label ) ) . addGap ( 5 , 5 , 5 ) . addGroup ( ChannelControlPanelLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . BASELINE ) . addComponent ( Excitation_ComboBox , javax . swing . GroupLayout . PREFERRED_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . PREFERRED_SIZE ) . addComponent ( Emission_ComboBox , javax . swing . GroupLayout . PREFERRED_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . PREFERRED_SIZE ) ) . addContainerGap ( 28 , short . MAX_VALUE ) ) ) ; javax . swing . GroupLayout layout = new javax . swing . GroupLayout ( getContentPane ( ) ) ; getContentPane ( ) . setLayout ( layout ) ; layout . setHorizontalGroup ( layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( layout . createSequentialGroup ( ) . addContainerGap ( ) . addGroup ( layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING , false ) . addComponent ( StageControlPanel , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , short . MAX_VALUE ) . addComponent ( RotationControlPanel , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , short . MAX_VALUE ) . addComponent ( ModePanel , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , short . MAX_VALUE ) ) . addGap ( 6 , 6 , 6 ) . addGroup ( layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING , false ) . addGroup ( layout . createSequentialGroup ( ) . addGroup ( layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING , false ) . addComponent ( TimeLapsePanel , javax . swing . GroupLayout . PREFERRED_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . PREFERRED_SIZE ) . addComponent ( RotationPanel , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , short . MAX_VALUE ) ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addComponent ( StackPanel , javax . swing . GroupLayout . PREFERRED_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . PREFERRED_SIZE ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addGroup ( layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . TRAILING , false ) . addComponent ( GalvoControlPanel , javax . swing . GroupLayout . Alignment . LEADING , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , short . MAX_VALUE ) . addComponent ( AcquireButton , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , short . MAX_VALUE ) . addComponent ( ShutterButton , javax . swing . GroupLayout . Alignment . LEADING , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , short . MAX_VALUE ) ) ) . addGroup ( layout . createSequentialGroup ( ) . addComponent ( SaveImagesPanel , javax . swing . GroupLayout . PREFERRED_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . PREFERRED_SIZE ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addComponent ( Message_Pannel , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , short . MAX_VALUE ) ) . addComponent ( ChannelControlPanel , javax . swing . GroupLayout . PREFERRED_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . PREFERRED_SIZE ) ) . addContainerGap ( javax . swing . GroupLayout . DEFAULT_SIZE , short . MAX_VALUE ) ) ) ; layout . setVerticalGroup ( layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( layout . createSequentialGroup ( ) . addGap ( 6 , 6 , 6 ) . addGroup ( layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . TRAILING ) . addComponent ( RotationPanel , javax . swing . GroupLayout . PREFERRED_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . PREFERRED_SIZE ) . addComponent ( StageControlPanel , javax . swing . GroupLayout . PREFERRED_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . PREFERRED_SIZE ) ) . addComponent ( TimeLapsePanel , javax . swing . GroupLayout . PREFERRED_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . PREFERRED_SIZE ) . addGroup ( layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . TRAILING , false ) . addGroup ( javax . swing . GroupLayout . Alignment . LEADING , layout . createSequentialGroup ( ) . addComponent ( AcquireButton , javax . swing . GroupLayout . PREFERRED_SIZE , 35 , javax . swing . GroupLayout . PREFERRED_SIZE ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addComponent ( ShutterButton , javax . swing . GroupLayout . PREFERRED_SIZE , 32 , javax . swing . GroupLayout . PREFERRED_SIZE ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED , javax . swing . GroupLayout . DEFAULT_SIZE , short . MAX_VALUE ) . addComponent ( GalvoControlPanel , javax . swing . GroupLayout . PREFERRED_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . PREFERRED_SIZE ) ) . addComponent ( StackPanel , javax . swing . GroupLayout . Alignment . LEADING , javax . swing . GroupLayout . PREFERRED_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . PREFERRED_SIZE ) ) ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addGroup ( layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING , false ) . addGroup ( layout . createSequentialGroup ( ) . addComponent ( ChannelControlPanel , javax . swing . GroupLayout . PREFERRED_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . PREFERRED_SIZE ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addGroup ( layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addComponent ( SaveImagesPanel , javax . swing . GroupLayout . PREFERRED_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . PREFERRED_SIZE ) . addComponent ( Message_Pannel , javax . swing . GroupLayout . PREFERRED_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . PREFERRED_SIZE ) ) ) . addGroup ( layout . createSequentialGroup ( ) . addComponent ( RotationControlPanel , javax . swing . GroupLayout . PREFERRED_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . PREFERRED_SIZE ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED , javax . swing . GroupLayout . DEFAULT_SIZE , short . MAX_VALUE ) . addComponent ( ModePanel , javax . swing . GroupLayout . PREFERRED_SIZE , 43 , javax . swing . GroupLayout . PREFERRED_SIZE ) ) ) . addContainerGap ( 66 , short . MAX_VALUE ) ) ) ; java . awt . Dimension screenSize = java . awt . Toolkit . getDefaultToolkit ( ) . getScreenSize ( ) ; setBounds ( ( screenSize . width - 1000 ) / 2 , ( screenSize . height - 100 ) / 2 , ( screenSize . width + 0 ) / 2 , ( screenSize . height + 0 ) / 2 ) ; DSLM_controlsDialog . this . setSize ( 738 , 410 ) ; }
tr	7	public boolean isCallableReference ( class clazz ) { if ( this == globalBridge ) { return false ; } if ( ! referencesEnabled ) { return false ; } if ( callableReferenceSet . contains ( clazz ) ) { return true ; } class [ ] interfaces = clazz . getInterfaces ( ) ; for ( int i = 0 ; i < interfaces . length ; i ++ ) { if ( callableReferenceSet . contains ( interfaces [ i ] ) ) { return true ; } } class superClass = clazz . getSuperclass ( ) ; while ( superClass != null ) { if ( callableReferenceSet . contains ( superClass ) ) { return true ; } superClass = superClass . getSuperclass ( ) ; } return globalBridge . isCallableReference ( clazz ) ; }
