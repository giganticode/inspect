va	3	public void printSwitchOption ( int player ) { List < Pokemon > party = new ArrayList < Pokemon > ( ) ; if ( player == OMNIDEXTER ) { party = omnidexter . getParty ( ) ; } else { party = opponent . getParty ( ) ; } if ( party . isEmpty ( ) ) { System . out . println ( "No avaliable switches" ) ; } else { for ( int i = 1 ; i <= party . size ( ) ; i ++ ) { System . out . println ( - i + ")" + party . get ( i - 1 ) + " " + party . get ( i - 1 ) . getCurrHp ( ) + "/" + party . get ( i - 1 ) . getMaxHp ( ) ) ; } } }
va	3	@ Override public String process ( String content ) throws ProcessorException { pipeline = new SimpleAuthenticationPipeline ( ) ; context = new UnAuthorizeContext ( ) ; pipeline . setBasic ( new LogoutEntryValve ( ) ) ; pipeline . addValve ( new DecoderValve ( ) ) ; pipeline . addValve ( new ValidationValve ( ) ) ; pipeline . addValve ( new UnAuthorizeValve ( ) ) ; pipeline . addValve ( new EncodeValve ( ) ) ; pipeline . addValve ( new FlushValve ( ) ) ; pipeline . setContext ( context ) ; try { pipeline . invoke ( context . getRequest ( ) , context . getResponse ( ) , null ) ; } catch ( ValveException e ) { User user = context . getRequest ( ) . getCurrentUser ( ) ; String response = "" ; if ( user == null || user . getUserName ( ) == null ) { response = ExceptionWrapper . toJSON ( 503 , "Internal Error" ) ; } else { response = ExceptionWrapper . toJSON ( user , e . getCode ( ) , e . getMessage ( ) ) ; } return response ; } return context . getResponse ( ) . getResponse ( ) ; }
va	6	public byte [ ] getCameraStatus ( ) throws IOException { byte temp [ ] = new byte [ 8 ] ; byte response [ ] = new byte [ 258 ] ; int len ; temp [ 0 ] = 7F ; temp [ 7 ] = 1A ; out . write ( temp , 0 , temp . length ) ; len = in . read ( temp , 0 , 1 ) ; if ( len != 1 || temp [ 0 ] != KODAK_ACK ) throw new IOException ( "needed ACK" ) ; len = in . read ( response ) ; if ( len != 258 || temp [ 0 ] != KODAK_ACK ) throw new IOException ( "needed status packet" ) ; response [ 0 ] = KODAK_CORRECT ; out . write ( response , 0 , 1 ) ; temp = new byte [ 256 ] ; System . arraycopy ( response , 1 , temp , 0 , 256 ) ; statusTable = temp ; temp = new byte [ 256 ] ; System . arraycopy ( response , 1 , temp , 0 , 256 ) ; len = in . read ( temp , 0 , 1 ) ; if ( len != 1 || temp [ 0 ] != KODAK_COMPLETED ) throw new IOException ( "needed ACK2" ) ; return temp ; }
va	4	@ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; AbstractID3v2FrameData other = ( AbstractID3v2FrameData ) obj ; if ( unsynchronisation != other . unsynchronisation ) return false ; return true ; }
va	3	public void mouseDragged ( MouseEvent e ) { if ( e . getButton ( ) == MouseEvent . BUTTON2 || e . getButton ( ) == MouseEvent . BUTTON3 ) return ; if ( dragStart == null ) return ; Point pt = SwingUtilities . convertPoint ( this , e . getPoint ( ) , getParent ( ) ) ; setLocation ( pt . x - dragStart . x , pt . y - dragStart . y ) ; getParent ( ) . repaint ( ) ; }
va	7	private boolean checkPalacePlacement ( JavaCell [ ] [ ] miniMap , Tile tile ) { TileType [ ] [ ] tileCells = tile . getTileCells ( ) ; if ( tile . getTileCells ( ) [ 1 ] [ 1 ] . toString ( ) . contains ( "palace" ) ) { return true ; } for ( int i = 0 ; i < tileCells . length ; i ++ ) { for ( int j = 0 ; j < tileCells [ i ] . length ; j ++ ) { if ( tileCells [ i ] [ j ] != null ) { if ( miniMap [ i ] [ j ] != null && miniMap [ i ] [ j ] . getCellType ( ) != null && miniMap [ i ] [ j ] . getCellType ( ) . contains ( "palace" ) ) { return false ; } } } } return true ; }
va	5	static < Val > FSet < Object > range ( Object subtree , FSet < Val > initial ) { if ( subtree == null ) return ( FSet < Object > ) initial ; else if ( ! ( subtree instanceof Node ) ) { Object [ ] ary = ( Object [ ] ) subtree ; int nkeys = ary . length >> 1 ; for ( int i = 0 ; i < nkeys ; ++ i ) initial = initial . with ( ( Val ) ary [ nkeys + i ] ) ; return ( FSet < Object > ) initial ; } else { Node node = ( Node ) subtree ; if ( node . key instanceof EquivalentMap ) { ArrayList < Entry > al = ( ( EquivalentMap ) node . key ) . contents ; for ( int i = 0 ; i < al . size ( ) ; ++ i ) initial = initial . with ( ( Val ) al . get ( i ) . value ) ; return ( FSet < Object > ) initial ; } else return ( range ( node . left , initial ) . with ( node . value ) . union ( range ( node . right , initial ) ) ) ; } }
va	2	public void printTree ( ) { System . out . println ( "--[ ]" ) ; ArrayList < State > childs = children ( ) ; int s = childs . size ( ) ; int i = 1 ; for ( State st : childs ) { if ( i < s ) { st . printTree ( "" , "" , false ) ; } else { st . printTree ( "" , "" , true ) ; } ++ i ; } }
va	3	public boolean updateConversationState ( long cvs_id , long msg_id , Set < Integer > mem ) { dao_person_cvs . setParaValue ( PersonConversationDao . PARA_CONVERSATION_ID , cvs_id ) ; dao_person_cvs . setParaValue ( PersonConversationDao . PARA_LAST_MSG , msg_id ) ; boolean flag = true ; if ( mem == null ) { flag = dao_person_cvs . updateAll ( ) ; return flag ; } for ( Iterator < Integer > iter = mem . iterator ( ) ; iter . hasNext ( ) && flag ; ) { dao_person_cvs . setParaValue ( PersonConversationDao . PARA_PERSON_ID , iter . next ( ) ) ; flag = dao_person_cvs . update ( ) ; } return flag ; }
va	4	public Automaton union ( Automaton a ) { if ( ( isSingleton ( ) && a . isSingleton ( ) && singleton . equals ( a . singleton ) ) || a == this ) return clone ( ) ; a = a . cloneExpanded ( ) ; Automaton b = cloneExpanded ( ) ; State s = new State ( ) ; s . addEpsilon ( a . initial ) ; s . addEpsilon ( b . initial ) ; a . initial = s ; a . deterministic = false ; a . checkMinimizeAlways ( ) ; return a ; }
va	0	public ShipShieldAbility ( World world ) { super ( world ) ; length = 4 ; coolDownTime = 10 ; isCooledDown = true ; isCoolingDown = false ; needsLocation = false ; isReady = false ; }
va	1	public static String getNumber ( int driver ) { if ( driver == 0 ) throw new InvalidQueryException ( "Nonexistent driver" ) ; return database . busDatabase . get_string ( "driver" , driver , "number" ) ; }
va	1	public void reciveConfigurationFromLocalArea ( ) { InputStream plik = getClass ( ) . getResourceAsStream ( "/data/params.txt" ) ; InputStreamReader reader = new InputStreamReader ( plik ) ; BufferedReader bufor = new BufferedReader ( reader ) ; this . loadConfiguration ( bufor ) ; try { plik . close ( ) ; System . out . println ( "File close :)" ) ; } catch ( Exception e ) { System . out . println ( "B\u0142\u0105d zamykania pliku." ) ; } }
va	5	private static boolean KawigiEdit_RunTest ( int testNum , String p0 , boolean hasAnswer , int p1 ) { System . out . print ( "Test " + testNum + ": [" + "\"" + p0 + "\"" ) ; System . out . println ( "]" ) ; LeftAndRightHandedDiv2 obj ; int answer ; obj = new LeftAndRightHandedDiv2 ( ) ; long startTime = System . currentTimeMillis ( ) ; answer = obj . count ( p0 ) ; long endTime = System . currentTimeMillis ( ) ; boolean res ; res = true ; System . out . println ( "Time: " + ( endTime - startTime ) / 1000.0 + " seconds" ) ; if ( hasAnswer ) { System . out . println ( "Desired answer:" ) ; System . out . println ( "\t" + p1 ) ; } System . out . println ( "Your answer:" ) ; System . out . println ( "\t" + answer ) ; if ( hasAnswer ) { res = answer == p1 ; } if ( ! res ) { System . out . println ( "DOESN'T MATCH!!!!" ) ; } else if ( ( endTime - startTime ) / 1000.0 >= 2 ) { System . out . println ( "FAIL the timeout" ) ; res = false ; } else if ( hasAnswer ) { System . out . println ( "Match :-)" ) ; } else { System . out . println ( "OK  but is it right?" ) ; } System . out . println ( "" ) ; return res ; }
va	7	@ Override public boolean equals ( Object o ) { if ( this == o ) { return true ; } if ( o == null || getClass ( ) != o . getClass ( ) ) { return false ; } if ( super . equals ( o ) ) { return true ; } orgataxe . entity . Model model = ( orgataxe . entity . Model ) o ; if ( weight != model . weight ) { return false ; } if ( designation != null ? ! designation . equals ( model . designation ) : model . designation != null ) { return false ; } return true ; }
va	8	public static boolean getSemaphoresData ( String pathName ) { DocumentBuilderFactory docBuilderFactory ; DocumentBuilder docBuilder ; Document document = null ; try { docBuilderFactory = DocumentBuilderFactory . newInstance ( ) ; docBuilder = docBuilderFactory . newDocumentBuilder ( ) ; document = docBuilder . parse ( new File ( pathName ) ) ; document . getDocumentElement ( ) . normalize ( ) ; } catch ( ParserConfigurationException e ) { System . err . println ( "XML Format error." ) ; e . printStackTrace ( ) ; return false ; } catch ( IOException e ) { System . err . println ( "Write/Read error." ) ; e . printStackTrace ( ) ; return false ; } catch ( SAXException e ) { System . err . println ( "SAXException." ) ; e . printStackTrace ( ) ; return false ; } NodeList names = document . getElementsByTagName ( "name" ) ; NodeList times = document . getElementsByTagName ( "value" ) ; NodeList coordinates = document . getElementsByTagName ( "coordinates" ) ; ArrayList < String > sNames = new ArrayList < String > ( ) ; ArrayList < String [ ] > sTimes = new ArrayList < String [ ] > ( ) ; ArrayList < String [ ] > sCoordinates = new ArrayList < String [ ] > ( ) ; int j = 0 ; int k = 0 ; for ( int i = 0 ; i < names . getLength ( ) ; i ++ ) { if ( names . item ( i ) . getParentNode ( ) . getNodeName ( ) == "Placemark" || coordinates . item ( i ) . getParentNode ( ) . getNodeName ( ) == "Placemark" ) { sNames . add ( names . item ( i ) . getTextContent ( ) ) ; sCoordinates . add ( coordinates . item ( j ) . getTextContent ( ) . split ( " " ) ) ; sTimes . add ( new String [ ] { times . item ( k ) . getTextContent ( ) , times . item ( ++ k ) . getTextContent ( ) } ) ; if ( sTimes . get ( sTimes . size ( ) - 1 ) [ 0 ] . equals ( "" ) ) { sTimes . get ( sTimes . size ( ) - 1 ) [ 0 ] = "0" ; } if ( sTimes . get ( sTimes . size ( ) - 1 ) [ 1 ] . equals ( "" ) ) { sTimes . get ( sTimes . size ( ) - 1 ) [ 1 ] = "0" ; } k ++ ; j ++ ; } } return IOFiles . writeSemaphoresFile ( "cleanData/semaphoresData.txt" , sNames , sTimes , sCoordinates ) ; }
va	1	public void parseExpressions ( String expressions , Handler handler ) { for ( String expression : expressions . split ( "[\n\r]+" ) ) { parseExpression ( expression , handler ) ; } }
va	0	protected void mapKeyboard ( ) { mapKeystroke ( KeyEvent . VK_UP ) ; mapKeystroke ( KeyEvent . VK_DOWN ) ; mapKeystroke ( KeyEvent . VK_RIGHT ) ; mapKeystroke ( KeyEvent . VK_LEFT ) ; mapKeystroke ( KeyEvent . VK_PAGE_DOWN ) ; mapKeystroke ( KeyEvent . VK_PAGE_UP ) ; mapKeystroke ( KeyEvent . VK_HOME ) ; mapKeystroke ( KeyEvent . VK_END ) ; mapKeystroke ( KeyEvent . VK_NUMPAD0 ) ; mapKeystroke ( KeyEvent . VK_NUMPAD1 ) ; mapKeystroke ( KeyEvent . VK_NUMPAD2 ) ; mapKeystroke ( KeyEvent . VK_NUMPAD3 ) ; mapKeystroke ( KeyEvent . VK_NUMPAD4 ) ; mapKeystroke ( KeyEvent . VK_NUMPAD5 ) ; mapKeystroke ( KeyEvent . VK_NUMPAD6 ) ; mapKeystroke ( KeyEvent . VK_NUMPAD7 ) ; mapKeystroke ( KeyEvent . VK_NUMPAD8 ) ; mapKeystroke ( KeyEvent . VK_NUMPAD9 ) ; mapKeystroke ( KeyEvent . VK_MINUS ) ; mapKeystroke ( KeyEvent . VK_PLUS ) ; mapKeystroke ( KeyEvent . VK_COMMA ) ; mapKeystroke ( KeyEvent . VK_PERIOD ) ; mapKeystroke ( KeyEvent . VK_ENTER ) ; mapKeystroke ( KeyEvent . VK_KP_DOWN ) ; mapKeystroke ( KeyEvent . VK_KP_LEFT ) ; mapKeystroke ( KeyEvent . VK_KP_RIGHT ) ; mapKeystroke ( KeyEvent . VK_KP_UP ) ; mapKeystroke ( KeyEvent . VK_F1 ) ; mapKeystroke ( KeyEvent . VK_F1 , InputEvent . ALT_DOWN_MASK ) ; mapKeystroke ( KeyEvent . VK_F2 ) ; mapKeystroke ( KeyEvent . VK_F2 , InputEvent . ALT_DOWN_MASK ) ; mapKeystroke ( KeyEvent . VK_F3 ) ; mapKeystroke ( KeyEvent . VK_F3 , InputEvent . ALT_DOWN_MASK ) ; mapKeystroke ( KeyEvent . VK_F4 ) ; mapKeystroke ( KeyEvent . VK_F4 , InputEvent . ALT_DOWN_MASK ) ; mapKeystroke ( KeyEvent . VK_F5 ) ; mapKeystroke ( KeyEvent . VK_F6 ) ; mapKeystroke ( KeyEvent . VK_F7 ) ; mapKeystroke ( KeyEvent . VK_F8 ) ; mapKeystroke ( KeyEvent . VK_F9 ) ; mapKeystroke ( KeyEvent . VK_F10 ) ; mapKeystroke ( KeyEvent . VK_F11 ) ; mapKeystroke ( KeyEvent . VK_F12 ) ; }
va	8	@ Override public final void run ( ) { do { try { server = new java . net . ServerSocket ( getServerPort ( ) . getServerPort ( ) ) ; Logger . getLogger ( getClass ( ) ) . info ( "Ready to accept connections..." ) ; do { java . net . Socket socket = server . accept ( ) ; this . socketAccepter . addSocket ( socket ) ; } while ( Thread . currentThread ( ) . isAlive ( ) ) ; } catch ( SocketException e ) { if ( ! ativo ) return ; Logger . getLogger ( getClass ( ) ) . fatal ( e . getMessage ( ) , e ) ; try { Thread . sleep ( 1000 ) ; } catch ( InterruptedException f ) { Logger . getLogger ( getClass ( ) ) . error ( f . getMessage ( ) , f ) ; } } catch ( Exception e ) { Logger . getLogger ( getClass ( ) ) . fatal ( e . getMessage ( ) , e ) ; try { Thread . sleep ( 1000 ) ; } catch ( InterruptedException f ) { Logger . getLogger ( getClass ( ) ) . error ( f . getMessage ( ) , f ) ; } } } while ( Thread . currentThread ( ) . isAlive ( ) && ativo ) ; }
va	5	public void getplaylist_files ( File [ ] file ) { if ( mediaplayer != null ) { getplaylist_files_1 ( file ) ; } else { if ( files == null ) { files = new File [ 500 ] ; } for ( int a = 0 ; a < file . length ; a ++ ) { if ( file [ a ] != null ) { if ( files == null ) { System . out . println ( "null pointer" ) ; } else { files [ a ] = file [ a ] ; } k ++ ; } } allpanels . set_container_for_playlist ( files ) ; } }
va	3	private static int getAppLogLevel ( ) { String logLevel = ApplicationConfig . getStringProp ( "teatime.common.loglevel" ) ; if ( "debug" . equalsIgnoreCase ( logLevel ) ) { return LOG_LEVEL_DEBUG ; } else if ( "info" . equalsIgnoreCase ( logLevel ) ) { return LOG_LEVEL_INFO ; } else if ( "error" . equalsIgnoreCase ( logLevel ) ) { return LOG_LEVEL_ERROR ; } else { return LOG_LEVEL_DEBUG ; } }
va	5	void adjust_assign ( int nvars , int nexps , ExpDesc e ) { FuncState fs = this . fs ; int extra = nvars - nexps ; if ( hasmultret ( e . k ) ) { extra ++ ; if ( extra < 0 ) extra = 0 ; fs . setreturns ( e , extra ) ; if ( extra > 1 ) fs . reserveregs ( extra - 1 ) ; } else { if ( e . k != VVOID ) fs . exp2nextreg ( e ) ; if ( extra > 0 ) { int reg = fs . freereg ; fs . reserveregs ( extra ) ; fs . nil ( reg , extra ) ; } } }
va	9	private static Object equivUnion ( Object elt1 , Object elt2 ) { if ( elt1 == NO_ELEMENT ) return elt2 ; else if ( elt2 == NO_ELEMENT ) return elt1 ; else if ( elt1 instanceof EquivalentSet ) { ArrayList < Object > al1 = ( ( EquivalentSet ) elt1 ) . contents ; if ( elt2 instanceof EquivalentSet ) { ArrayList < Object > al2 = ( ( EquivalentSet ) elt2 ) . contents ; int size2 = al2 . size ( ) ; ArrayList res_al = ( ArrayList ) al1 . clone ( ) ; for ( int i = 0 ; i < size2 ; ++ i ) { Object e2 = al2 . get ( i ) ; if ( ! res_al . contains ( e2 ) ) res_al . add ( e2 ) ; } res_al . trimToSize ( ) ; return new EquivalentSet ( res_al ) ; } else { if ( al1 . contains ( elt2 ) ) return elt1 ; else { ArrayList res_al = ( ArrayList ) al1 . clone ( ) ; res_al . add ( elt2 ) ; res_al . trimToSize ( ) ; return new EquivalentSet ( res_al ) ; } } } else if ( elt2 instanceof EquivalentSet ) { ArrayList < Object > al2 = ( ( EquivalentSet ) elt2 ) . contents ; if ( al2 . contains ( elt1 ) ) return elt2 ; else { ArrayList al = ( ArrayList ) al2 . clone ( ) ; al . add ( elt1 ) ; al . trimToSize ( ) ; return new EquivalentSet ( al ) ; } } else if ( eql ( elt1 , elt2 ) ) return elt1 ; else { ArrayList al = new ArrayList ( 2 ) ; al . add ( elt1 ) ; al . add ( elt2 ) ; return new EquivalentSet ( al ) ; } }
va	6	public Character getPlayerCharacter ( String info ) { String [ ] parsedInstructions = info . split ( " " ) ; if ( parsedInstructions [ 0 ] . compareTo ( "Player" ) != 0 ) { System . out . println ( "Error: Incorrect Player Character creation syntax" ) ; return null ; } Character c ; if ( parsedInstructions . length == 3 ) { switch ( parsedInstructions [ 2 ] ) { case "Rogue" : subFactory = new RogueFactory ( ) ; c = subFactory . getCharacter ( parsedInstructions [ 2 ] ) ; break ; case "Mage" : subFactory = new MageFactory ( ) ; c = subFactory . getCharacter ( parsedInstructions [ 2 ] ) ; break ; case "Cleric" : subFactory = new ClericFactory ( ) ; c = subFactory . getCharacter ( parsedInstructions [ 2 ] ) ; break ; case "Warrior" : subFactory = new WarriorFactory ( ) ; c = subFactory . getCharacter ( parsedInstructions [ 2 ] ) ; break ; default : c = new NullPlayer ( parsedInstructions [ 2 ] ) ; } } else { System . out . println ( "Error: Incorrect number of arguments" ) ; return new NullPlayer ( "Null Character" ) ; } return c ; }
va	8	public ArrayList < ArrayList < Integer >> pathSum ( TreeNode root , int sum , Stack st ) { ArrayList < ArrayList < Integer >> alist = new ArrayList < ArrayList < Integer >> ( ) ; if ( root == null ) return alist ; st . push ( root . val ) ; sum -= root . val ; if ( sum == 0 && root . left == null && root . right == null ) { alist . add ( new ArrayList < Integer > ( st ) ) ; } ArrayList < ArrayList < Integer >> llist = null ; ArrayList < ArrayList < Integer >> rlist = null ; if ( root . left != null ) llist = pathSum ( root . left , sum , st ) ; if ( root . right != null ) rlist = pathSum ( root . right , sum , st ) ; st . pop ( ) ; if ( llist != null ) alist . addAll ( llist ) ; if ( rlist != null ) alist . addAll ( rlist ) ; return alist ; }
va	9	private boolean r_attached_pronoun ( ) { int among_var ; ket = cursor ; if ( find_among_b ( a_1 , 13 ) == 0 ) { return false ; } bra = cursor ; among_var = find_among_b ( a_2 , 11 ) ; if ( among_var == 0 ) { return false ; } if ( ! r_RV ( ) ) { return false ; } switch ( among_var ) { case 0 : return false ; case 1 : bra = cursor ; slice_from ( "iendo" ) ; break ; case 2 : bra = cursor ; slice_from ( "ando" ) ; break ; case 3 : bra = cursor ; slice_from ( "ar" ) ; break ; case 4 : bra = cursor ; slice_from ( "er" ) ; break ; case 5 : bra = cursor ; slice_from ( "ir" ) ; break ; case 6 : slice_del ( ) ; break ; case 7 : if ( ! ( eq_s_b ( 1 , "u" ) ) ) { return false ; } slice_del ( ) ; break ; } return true ; }
va	4	private static void updateMasterStackedStopList ( ) { StackedStopList ssl = StackedStopList . getInstance ( ) ; synchronized ( sStopsMap ) { ArrayList < Integer > ids = new ArrayList < > ( sStopsMap . keySet ( ) ) ; for ( int idKey : ids ) { ArrayList < ArrayList < StopAdapter >> nowStops = sStopsMap . get ( idKey ) ; if ( nowStops != null ) { for ( int o = 0 ; o < nowStops . size ( ) ; o ++ ) { ArrayList < StopAdapter > list = nowStops . get ( o ) ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { ssl . addStop ( list . get ( i ) ) ; } } } } } synchronized ( sMasterSSL ) { sMasterSSL . set ( ssl ) ; ssl . recycle ( ) ; } }
va	8	public static Throwable getCause ( final Throwable exception ) { Throwable cause = null ; if ( exception != null ) { if ( exception instanceof CoreException ) { final CoreException ce = ( CoreException ) exception ; cause = ce . getStatus ( ) . getException ( ) ; } else { try { final Method causeMethod = exception . getClass ( ) . getMethod ( "getCause" , new class [ 0 ] ) ; final Object o = causeMethod . invoke ( exception , new Object [ 0 ] ) ; if ( o instanceof Throwable ) { cause = ( Throwable ) o ; } } catch ( final NoSuchMethodException e ) { } catch ( final IllegalArgumentException e ) { } catch ( final IllegalAccessException e ) { } catch ( final InvocationTargetException e ) { } } if ( cause == null ) { cause = exception ; } } return cause ; }
va	2	private boolean r_mark_DA ( ) { if ( ! r_check_vowel_harmony ( ) ) { return false ; } if ( find_among_b ( a_6 , 4 ) == 0 ) { return false ; } return true ; }
va	0	public BigInteger getOrdernumber ( ) { return ordernumber ; }
va	5	@ Override public int hashCode ( ) { int result = scheme != null ? scheme . hashCode ( ) : 0 ; result = 31 * result + ( host != null ? host . hashCode ( ) : 0 ) ; result = 31 * result + port ; result = 31 * result + ( verb != null ? verb . hashCode ( ) : 0 ) ; result = 31 * result + ( path != null ? path . hashCode ( ) : 0 ) ; result = 31 * result + ( params != null ? params . hashCode ( ) : 0 ) ; return result ; }
va	7	private void processRemove ( WriteBatch batch , DataFile df , LogFile lf ) { if ( df != null && lf != null ) { df . decrement ( batch . removeOPCount ) ; this . enqueueLock . lock ( ) ; try { if ( df . getLength ( ) >= JournalStore . FILE_SIZE && df . isUnUsed ( ) ) { if ( this . journal . dataFile == df ) { this . journal . newDataFile ( ) ; } this . journal . dataFiles . remove ( Integer . valueOf ( df . getNumber ( ) ) ) ; this . journal . logFiles . remove ( Integer . valueOf ( df . getNumber ( ) ) ) ; df . delete ( ) ; lf . delete ( ) ; } } catch ( Exception e ) { if ( e instanceof IOException ) { batch . exception = ( IOException ) e ; } else { batch . exception = new IOException ( e ) ; } } finally { this . enqueueLock . unlock ( ) ; } } }
va	2	public boolean unsetColourPaletteFavourite ( String cpid ) { ClientResponse cresp ; try { cresp = service . path ( "/user" ) . path ( "/" + this . user_id ) . path ( "/favouritecolourpalette" ) . path ( "/" + cpid ) . delete ( ClientResponse . class ) ; } catch ( ClientHandlerException che ) { return false ; } if ( cresp . getStatus ( ) == 204 ) { return true ; } return false ; }
va	0	public List < ErrorData > getError ( ) { return error ; }
va	5	public final void svd ( double scale [ ] , Matrix rotation ) { for ( int i = 0 ; i < 3 ; i ++ ) for ( int j = 0 ; j < 3 ; j ++ ) svdSrc [ 3 * i + j ] = get ( i , j ) ; if ( svdMath == null ) svdMath = new SVD ( ) ; svdMath . compute ( svdSrc , scale , svdRot ) ; for ( int i = 0 ; i < 3 ; i ++ ) for ( int j = 0 ; j < 3 ; j ++ ) rotation . set ( i , j , svdRot [ 3 * i + j ] ) ; rotation . set ( 3 , 3 , 1.0 ) ; }
va	1	public ListNode min ( ) { if ( isEmpty ( ) ) { throw new RuntimeException ( "Heap is empty!" ) ; } return array [ 0 ] ; }
va	2	@ Test ( timeout = TIMEOUT ) public void testSortLargeDescendingOrderKS ( ) { Integer [ ] testArray = new Integer [ 100 ] ; Integer [ ] copyArray = new Integer [ 100 ] ; for ( int i = 99 ; i >= 0 ; i -- ) { testArray [ i ] = i ; } for ( int i = 0 ; i <= 99 ; i ++ ) { copyArray [ i ] = i ; } sorter . topKSort ( testArray , topKComp , testArray . length ) ; assertTrue ( "Testing top k sort for ascending order" , Arrays . equals ( testArray , copyArray ) ) ; }
va	0	@ Test public void ShouldRecognize2AsCircularPrime ( ) { int candidate = 11 ; boolean expected = true ; PrimeFactorizer factorizer = new PrimeFactorizer ( ) ; CircularPrimeFinder finder = new CircularPrimeFinder ( factorizer ) ; boolean result = finder . IsCircularPrime ( candidate ) ; assert . assertEquals ( expected , result ) ; }
va	4	@ Override public BiConsumer < BigDecimalMutableStats , BigDecimal > accumulator ( ) { return ( acc , num ) -> { if ( acc . min == null || acc . min . compareTo ( num ) > 0 ) { acc . min = num ; } if ( acc . max == null || acc . max . compareTo ( num ) < 0 ) { acc . max = num ; } acc . sum = acc . sum . add ( num ) ; acc . count = acc . count . add ( BigInteger . ONE ) ; } ; }
va	4	@ Override public void updateWeapon ( List < Zombie > zombies ) { synchronized ( this . particles ) { if ( ! this . particles . isEmpty ( ) ) { Iterator < Particle > it = this . particles . iterator ( ) ; while ( it . hasNext ( ) ) { Particle p = it . next ( ) ; p . update ( ) ; if ( ! p . isAlive ( ) || p . outOfBounds ( ) ) { it . remove ( ) ; continue ; } } } } this . cool ( ) ; }
va	7	public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; HabitacioId other = ( HabitacioId ) obj ; if ( nomHotel == null ) { if ( other . nomHotel != null ) return false ; } else if ( ! nomHotel . equals ( other . nomHotel ) ) return false ; if ( numero != other . numero ) return false ; return true ; }
va	6	public org . w3c . dom . Node removeChild ( org . w3c . dom . Node oldChild ) throws DOMException { if ( oldChild == null ) return null ; Node ref = this . adaptee . content ; while ( ref != null ) { if ( ref . getAdapter ( ) == oldChild ) break ; ref = ref . next ; } if ( ref == null ) { throw new DOMExceptionImpl ( DOMException . NOT_FOUND_ERR , "refChild not found" ) ; } Node . discardElement ( ref ) ; if ( this . adaptee . content == null && this . adaptee . type == Node . StartTag ) { this . adaptee . setType ( Node . StartEndTag ) ; } return oldChild ; }
va	4	@ Override public boolean equals ( Object obj ) { if ( obj == null ) { return false ; } if ( getClass ( ) != obj . getClass ( ) ) { return false ; } final OsobyHasStaje other = ( OsobyHasStaje ) obj ; if ( this . osoby_osoba_id != other . osoby_osoba_id ) { return false ; } if ( this . staje_staj_id != other . staje_staj_id ) { return false ; } return true ; }
va	0	public boolean isSplitter ( ) { return isSplitter ; }
va	2	public FTreeList < Elt > less ( int index ) { if ( index < 0 || index >= treeSize ( tree ) ) throw new IndexOutOfBoundsException ( ) ; return new FTreeList < Elt > ( less ( tree , index ) , elt_comp ) ; }
va	3	public static boolean findWay ( int [ ] array ) { int c = 0 ; int index = array . length - 1 ; for ( int i = array . length - 1 ; i >= 0 ; i -- ) { if ( array [ i ] >= c ) { index = i ; c = 1 ; continue ; } c ++ ; } if ( index == 0 ) { return true ; } return false ; }
va	3	public void patientList ( Vector < PatientInfo > patient , JTextField tf , DefaultListModel list ) { list . removeAllElements ( ) ; Vector < StringBuffer > t = new Vector ( ) ; for ( int i = 0 ; i < patient . size ( ) ; i ++ ) { if ( patient . get ( i ) . getLname ( ) . toLowerCase ( ) . startsWith ( tf . getText ( ) . toLowerCase ( ) ) ) { StringBuffer tmp = new StringBuffer ( ) ; tmp . append ( patient . get ( i ) . getLname ( ) + "  " ) ; tmp . append ( patient . get ( i ) . getFname ( ) . charAt ( 0 ) + ". (" ) ; tmp . append ( patient . get ( i ) . getBdate ( ) . toString ( ) + ")" ) ; t . add ( tmp ) ; } } for ( int i = 0 ; i < t . size ( ) ; i ++ ) { list . add ( i , t . get ( i ) . toString ( ) ) ; } DB . db . close ( ) ; }
va	5	private TextIDPair readNextDocText ( BufferedReader docIn ) throws IOException { String line = docIn . readLine ( ) ; while ( line != null && ! line . equals ( "<DOC>" ) ) { line = docIn . readLine ( ) ; } if ( line == null ) { return null ; } else { String title = "" ; String url = "" ; line = docIn . readLine ( ) ; title = extractTag ( line , "<TITLE>" , "</TITLE>" ) ; line = docIn . readLine ( ) ; url = extractTag ( line , "<URL>" , "</URL>" ) ; StringBuffer buffer = new StringBuffer ( ) ; line = docIn . readLine ( ) ; while ( line != null && ! line . equals ( "</DOC>" ) ) { buffer . append ( " " + line ) ; line = docIn . readLine ( ) ; } docID ++ ; return new TextIDPair ( buffer . toString ( ) , docID , title , url ) ; } }
va	1	private ButtonGroup getOB_Gender ( ) { if ( OB_Gender == null ) { OB_Gender = new ButtonGroup ( ) ; } return OB_Gender ; }
va	6	private void assignRandomMines ( Field ignoreField ) { int remainingMines = _minefield . getMines ( ) ; while ( remainingMines > 0 ) { int randomRow = ( int ) ( Math . random ( ) * ( _minefield . getSize ( ) . getHeight ( ) ) ) ; int randomCol = ( int ) ( Math . random ( ) * ( _minefield . getSize ( ) . getWidth ( ) ) ) ; Field field = _minefield . getField ( randomRow , randomCol ) ; if ( ! field . getValue ( ) . equals ( FieldValue . MINE ) && field != ignoreField ) { field . setValue ( FieldValue . MINE ) ; for ( int dr = - 1 ; dr <= 1 ; dr ++ ) { for ( int dc = - 1 ; dc <= 1 ; dc ++ ) { if ( inBoard ( randomRow + dr , randomCol + dc ) ) { Field f = _minefield . getField ( randomRow + dr , randomCol + dc ) ; f . setValue ( f . getValue ( ) . nextValue ( ) ) ; } } } remainingMines -- ; } } }
va	3	public void setVoters ( List < ? extends Identifiable > voters ) throws ServerException { votes = new Vote [ voters . size ( ) ] ; for ( int i = 0 ; i < voters . size ( ) ; i ++ ) { if ( voters . get ( i ) == null ) { throw new ServerException ( ) ; } votes [ i ] = new Vote ( voters . get ( i ) ) ; } }
va	7	private void printRange ( T [ ] low , T [ ] high , KdNode < T > t , int level ) { if ( t != null ) { if ( low [ 0 ] . compareTo ( t . data [ 0 ] ) <= 0 && low [ 1 ] . compareTo ( t . data [ 1 ] ) <= 0 && high [ 0 ] . compareTo ( t . data [ 0 ] ) >= 0 && high [ 1 ] . compareTo ( t . data [ 1 ] ) >= 0 ) System . out . println ( "(" + t . data [ 0 ] + " " + t . data [ 1 ] + ")" ) ; if ( low [ level ] . compareTo ( t . data [ level ] ) <= 0 ) printRange ( low , high , t . left , 1 - level ) ; if ( high [ level ] . compareTo ( t . data [ level ] ) >= 0 ) printRange ( low , high , t . right , 1 - level ) ; } }
va	8	protected final void init ( Transition transitions [ ] ) { Map < State , List < Transition >> fromMap = new HashMap < State , List < Transition >> ( ) ; for ( Transition trans : transitions ) { List < Transition > list = fromMap . get ( trans . from ( ) ) ; if ( list == null ) { list = new ArrayList < Transition > ( ) ; fromMap . put ( trans . from ( ) , list ) ; } list . add ( trans ) ; } stateCharMaps = new HashMap < State , StateCharMap > ( ) ; for ( Map . Entry < State , List < Transition >> entry : fromMap . entrySet ( ) ) { int hi = highestChar ( entry . getValue ( ) ) ; Transition ts [ ] = new Transition [ hi + 1 ] ; Transition defaultTrans = null ; Transition eofTrans = null ; for ( Transition t : entry . getValue ( ) ) { if ( t . chars ( ) == null ) { defaultTrans = t ; continue ; } if ( t . chars ( ) . isEmpty ( ) ) { eofTrans = t ; continue ; } for ( int i = 0 ; i < t . chars ( ) . length ( ) ; i ++ ) { Transition old = ts [ t . chars ( ) . charAt ( i ) ] ; if ( old != null ) { throw new IllegalStateException ( "Overwriting transition " + old ) ; } ts [ t . chars ( ) . charAt ( i ) ] = t ; } } StateCharMap scm = new StateCharMap ( entry . getKey ( ) , defaultTrans , eofTrans , ts ) ; stateCharMaps . put ( scm . state , scm ) ; } }
va	1	public void paintFrameInGame ( ) { displayScore ( ) ; if ( lives_img == null ) { drawString ( "Lives " + lives , viewWidth ( ) - status_r_margin , 0 , 1 ) ; } else { drawCount ( lives - 1 , lives_img , viewWidth ( ) - status_r_margin , 0 , - getImageSize ( lives_img ) . x - 2 ) ; } }
va	0	private void txtSalesp1ActionPerformed ( java . awt . event . ActionEvent evt ) { }
va	1	public MessageComponent ( Client client ) { addMouseListener ( new MouseAdapter ( ) { @ Override public void mouseEntered ( MouseEvent arg0 ) { enter ( ) ; } @ Override public void mouseExited ( MouseEvent e ) { exit ( ) ; } } ) ; try { UIManager . setLookAndFeel ( UIManager . getSystemLookAndFeelClassName ( ) ) ; } catch ( Exception e ) { } this . client = client ; setBackground ( Color . WHITE ) ; setBorder ( new MatteBorder ( 0 , 0 , 1 , 0 , ( Color ) Color . LIGHT_GRAY ) ) ; setLayout ( new BorderLayout ( 5 , 10 ) ) ; leftPanel = new JPanel ( ) ; leftPanel . setBackground ( Color . WHITE ) ; add ( leftPanel , BorderLayout . WEST ) ; iconLabel = new JLabel ( "" ) ; iconLabel . setHorizontalAlignment ( SwingConstants . CENTER ) ; iconLabel . setIcon ( new ImageIcon ( "C:\\Users\\Umut\\Desktop\\darth_vader_icon_64x64_by_geo_almighty-d33pmvd.png" ) ) ; leftPanel . add ( iconLabel ) ; centerPanel = new JPanel ( ) ; centerPanel . setBackground ( Color . WHITE ) ; add ( centerPanel , BorderLayout . CENTER ) ; centerPanel . setLayout ( new BoxLayout ( centerPanel , BoxLayout . Y_AXIS ) ) ; panel_3 = new JPanel ( ) ; panel_3 . setBackground ( Color . WHITE ) ; centerPanel . add ( panel_3 ) ; panel_3 . setLayout ( new GridLayout ( 0 , 1 , 0 , 10 ) ) ; userName = new JLabel ( "User Name" ) ; userName . setHorizontalAlignment ( SwingConstants . LEFT ) ; userName . setForeground ( new Color ( 0 , 0 , 0 ) ) ; userName . setBackground ( Color . WHITE ) ; userName . setFont ( new Font ( "Segoe UI" , Font . BOLD , 13 ) ) ; panel_3 . add ( userName ) ; txtrMessagetext = new JTextArea ( ) ; txtrMessagetext . setLineWrap ( true ) ; txtrMessagetext . addMouseListener ( new MouseAdapter ( ) { @ Override public void mouseEntered ( MouseEvent arg0 ) { enter ( ) ; } @ Override public void mouseExited ( MouseEvent e ) { exit ( ) ; } } ) ; txtrMessagetext . setForeground ( Color . DARK_GRAY ) ; txtrMessagetext . setFont ( new Font ( "Segoe UI" , Font . PLAIN , 11 ) ) ; txtrMessagetext . setEditable ( false ) ; txtrMessagetext . setText ( "messageText" ) ; txtrMessagetext . setBorder ( null ) ; centerPanel . add ( txtrMessagetext ) ; txtrReplytext = new JTextArea ( ) ; txtrReplytext . setLineWrap ( true ) ; txtrReplytext . addMouseListener ( new MouseAdapter ( ) { @ Override public void mouseEntered ( MouseEvent arg0 ) { enter ( ) ; } @ Override public void mouseExited ( MouseEvent e ) { exit ( ) ; } } ) ; txtrReplytext . setFont ( new Font ( "Segoe UI" , Font . PLAIN , 11 ) ) ; txtrReplytext . setText ( "replyText" ) ; txtrReplytext . setEditable ( false ) ; txtrReplytext . setForeground ( new Color ( 128 , 0 , 0 ) ) ; txtrReplytext . setVisible ( false ) ; txtrReplytext . setBorder ( null ) ; centerPanel . add ( txtrReplytext ) ; southPanel = new JPanel ( ) ; southPanel . setBackground ( Color . WHITE ) ; add ( southPanel , BorderLayout . SOUTH ) ; southPanel . setLayout ( new BoxLayout ( southPanel , BoxLayout . X_AXIS ) ) ; panel = new JPanel ( ) ; panel . setBackground ( Color . WHITE ) ; FlowLayout flowLayout_1 = ( FlowLayout ) panel . getLayout ( ) ; flowLayout_1 . setAlignment ( FlowLayout . RIGHT ) ; southPanel . add ( panel ) ; panel_1 = new JPanel ( ) ; panel_1 . setBorder ( null ) ; panel_1 . setBackground ( Color . WHITE ) ; FlowLayout flowLayout = ( FlowLayout ) panel_1 . getLayout ( ) ; flowLayout . setHgap ( 20 ) ; flowLayout . setAlignment ( FlowLayout . RIGHT ) ; southPanel . add ( panel_1 ) ; lblNewLabel_1 = new JLabel ( " " ) ; lblNewLabel_1 . setFont ( new Font ( "Tahoma" , Font . PLAIN , 25 ) ) ; panel_1 . add ( lblNewLabel_1 ) ; JLabel lblNewLabel = new JLabel ( " " ) ; lblNewLabel . setFont ( new Font ( "Tahoma" , Font . PLAIN , 22 ) ) ; panel_1 . add ( lblNewLabel ) ; dateLabel = new JLabel ( "10.10.2010" ) ; dateLabel . setVisible ( false ) ; panel_1 . add ( dateLabel ) ; btnNewButton = new JButton ( " Reply" ) ; btnNewButton . setVisible ( false ) ; btnNewButton . addMouseListener ( new MouseAdapter ( ) { @ Override public void mouseClicked ( MouseEvent e ) { replyPost ( ) ; } @ Override public void mouseEntered ( MouseEvent arg0 ) { enter ( ) ; } } ) ; btnNewButton . setIcon ( new ImageIcon ( "C:\\Users\\Umut\\Desktop\\reply_icon.gif" ) ) ; panel_1 . add ( btnNewButton ) ; panel_2 = new JPanel ( ) ; panel_2 . setBackground ( Color . WHITE ) ; add ( panel_2 , BorderLayout . EAST ) ; }
va	9	void drawString ( Graphics g , String str , double x , double y , int align , boolean pf_relative ) { if ( g == null ) return ; if ( str . equals ( "" ) ) return ; x = el . scaleXPos ( x , pf_relative ) ; y = el . scaleYPos ( y , pf_relative ) ; Font font = g . getFont ( ) ; FontRenderContext fontrc = ( ( Graphics2D ) g ) . getFontRenderContext ( ) ; TextLayout layout = new TextLayout ( str , font , fontrc ) ; Rectangle2D strbounds = layout . getBounds ( ) ; int xpos , ypos ; if ( align == - 1 ) { xpos = ( int ) ( x - strbounds . getMinX ( ) ) ; ypos = ( int ) ( y - strbounds . getMinY ( ) ) ; } else if ( align == 0 ) { xpos = ( int ) ( x - strbounds . getCenterX ( ) ) ; ypos = ( int ) ( y - strbounds . getMinY ( ) ) ; } else { xpos = ( int ) ( x - strbounds . getMaxX ( ) ) ; ypos = ( int ) ( y - strbounds . getMinY ( ) ) ; } if ( el . outline_thickness > 0 ) { Color origcol = g . getColor ( ) ; setColor ( el . outline_colour ) ; int real_thickness = Math . max ( el . scaleXPos ( el . outline_thickness , false ) , 1 ) ; for ( int i = - real_thickness ; i <= real_thickness ; i ++ ) { if ( i == 0 ) continue ; g . drawString ( str , xpos + i , ypos ) ; } for ( int i = - real_thickness ; i <= real_thickness ; i ++ ) { if ( i == 0 ) continue ; g . drawString ( str , xpos , ypos + i ) ; } g . setColor ( origcol ) ; } g . drawString ( str , xpos , ypos ) ; }
va	9	public void run ( ) { init ( ) ; state = 3 ; percentage = 5 ; try { loadJarURLs ( ) ; String path = ( String ) AccessController . doPrivileged ( new PrivilegedExceptionAction < Object > ( ) { public Object run ( ) throws Exception { return Util . getWorkingDirectory ( ) + File . separator + "bin" + File . separator ; } } ) ; File dir = new File ( path ) ; if ( ! dir . exists ( ) ) { dir . mkdirs ( ) ; } if ( latestVersion != null ) { File versionFile = new File ( dir , "version" ) ; boolean cacheAvailable = false ; if ( ( ! forceUpdate ) && ( versionFile . exists ( ) ) && ( ( latestVersion . equals ( "-1" ) ) || ( latestVersion . equals ( readVersionFile ( versionFile ) ) ) ) ) { cacheAvailable = true ; percentage = 90 ; } if ( ( forceUpdate ) || ( ! cacheAvailable ) ) { shouldUpdate = true ; if ( ( ! forceUpdate ) && ( versionFile . exists ( ) ) ) { checkShouldUpdate ( ) ; } if ( shouldUpdate ) { writeVersionFile ( versionFile , "" ) ; downloadJars ( path ) ; extractJars ( path ) ; extractNatives ( path ) ; if ( latestVersion != null ) { percentage = 90 ; writeVersionFile ( versionFile , latestVersion ) ; } } else { cacheAvailable = true ; percentage = 90 ; } } } updateClassPath ( dir ) ; state = 10 ; } catch ( AccessControlException ace ) { fatalErrorOccured ( ace . getMessage ( ) , ace ) ; certificateRefused = true ; } catch ( Exception e ) { fatalErrorOccured ( e . getMessage ( ) , e ) ; } finally { loaderThread = null ; } }
va	1	public DOTParserTokenManager ( SimpleCharStream stream ) { if ( SimpleCharStream . staticFlag ) throw new Error ( "ERROR: Cannot use a static CharStream class with a non-static lexical analyzer." ) ; input_stream = stream ; }
va	1	public Histogram ( final double lbd , final double ubd , final int quanta ) { this . lbd = Math . min ( lbd , ubd ) ; this . ubd = Math . max ( lbd , ubd ) ; this . range = this . ubd - this . lbd ; this . irange = ( this . range > 0.0 ) ? ( 1.0 / this . range ) : ( 0.0 ) ; this . quanta = Math . max ( 1 , quanta ) ; this . dquanta = ( ( double ) this . quanta ) - double . MIN_VALUE ; this . accu = new double [ this . quanta ] ; }
va	1	public void finish ( int sum ) throws Exception { for ( Summarizer s : sums ) s . finish ( sum ) ; }
va	9	public static String toString ( JSONArray ja ) throws JSONException { int i ; JSONObject jo ; String key ; Iterator keys ; int length ; Object object ; StringBuffer sb = new StringBuffer ( ) ; String tagName ; String value ; tagName = ja . getString ( 0 ) ; XML . noSpace ( tagName ) ; tagName = XML . escape ( tagName ) ; sb . append ( < ) ; sb . append ( tagName ) ; object = ja . opt ( 1 ) ; if ( object instanceof JSONObject ) { i = 2 ; jo = ( JSONObject ) object ; keys = jo . keys ( ) ; while ( keys . hasNext ( ) ) { key = keys . next ( ) . toString ( ) ; XML . noSpace ( key ) ; value = jo . optString ( key ) ; if ( value != null ) { sb . append (   ) ; sb . append ( XML . escape ( key ) ) ; sb . append ( = ) ; sb . append ( " ) ; sb . append ( XML . escape ( value ) ) ; sb . append ( " ) ; } } } else { i = 1 ; } length = ja . length ( ) ; if ( i >= length ) { sb . append ( / ) ; sb . append ( > ) ; } else { sb . append ( > ) ; do { object = ja . get ( i ) ; i += 1 ; if ( object != null ) { if ( object instanceof String ) { sb . append ( XML . escape ( object . toString ( ) ) ) ; } else if ( object instanceof JSONObject ) { sb . append ( toString ( ( JSONObject ) object ) ) ; } else if ( object instanceof JSONArray ) { sb . append ( toString ( ( JSONArray ) object ) ) ; } } } while ( i < length ) ; sb . append ( < ) ; sb . append ( / ) ; sb . append ( tagName ) ; sb . append ( > ) ; } return sb . toString ( ) ; }
va	7	private void checkFinish ( ) { if ( difficultyLevel != 15 && player . getX ( ) / Map . SQUARE_SIZE == map . getColumns ( ) - 1 && player . getY ( ) / Map . SQUARE_SIZE == map . getRows ( ) - 1 ) { player . addExp ( 50 ) ; createNewLevel ( ) ; } else if ( difficultyLevel == 15 && player . getX ( ) / Map . SQUARE_SIZE == map . getColumns ( ) - 1 && player . getY ( ) / Map . SQUARE_SIZE == map . getRows ( ) - 1 ) displayEndScreen ( ) ; else if ( ! player . isAlive ( ) ) displayDeadScreen ( ) ; }
va	7	public static void main ( String [ ] args ) throws InterruptedException { Runnable r ; Thread [ ] threads = new Thread [ MAX_THREADS ] ; for ( int i = 0 ; i < MAX_THREADS ; i ++ ) { final int ii = i ; r = new Runnable ( ) { public void run ( ) { String id = "" + ii ; while ( true ) { try { print ( "Runnable RUNNING " + id + " isInterrupted: " + Thread . currentThread ( ) . isInterrupted ( ) ) ; for ( int j = 1 ; j < 5000 ; j ++ ) { String [ ] s = new String [ j * 1000 ] ; s [ j ] = "hello" + j ; if ( j % 100 == 0 ) { System . out . print ( "." ) ; if ( Thread . currentThread ( ) . isInterrupted ( ) ) { print ( "isInterrupted" ) ; break ; } } } Thread . sleep ( 500 ) ; } catch ( InterruptedException e ) { print ( "Runnable interrupted" + " isInterrupted: " + Thread . currentThread ( ) . isInterrupted ( ) ) ; return ; } } } } ; threads [ i ] = new Thread ( r ) ; threads [ i ] . setDaemon ( true ) ; threads [ i ] . start ( ) ; print ( "Created runnable " + ii ) ; } Thread . sleep ( 2000 ) ; for ( int i = 0 ; i < MAX_THREADS ; i ++ ) { threads [ i ] . interrupt ( ) ; } Thread . sleep ( 5000 ) ; print ( "main exiting" ) ; }
va	6	public boolean removeValue ( T value , boolean identity ) { T [ ] items = this . items ; if ( identity || value == null ) { for ( int i = 0 , n = size ; i < n ; i ++ ) { if ( items [ i ] == value ) { removeIndex ( i ) ; return true ; } } } else { for ( int i = 0 , n = size ; i < n ; i ++ ) { if ( value . equals ( items [ i ] ) ) { removeIndex ( i ) ; return true ; } } } return false ; }
va	1	public void decCount ( ) { if ( count == 0 ) return ; count -- ; }
va	3	@ After public void close ( ) throws IOException { try { cache . close ( ) ; FileUtil . deleteDirectory ( new File ( TEST_DIR ) ) ; } catch ( IllegalStateException e ) { System . gc ( ) ; try { FileUtil . deleteDirectory ( new File ( TEST_DIR ) ) ; } catch ( IllegalStateException e1 ) { try { Thread . sleep ( 3000 ) ; } catch ( InterruptedException e2 ) { } FileUtil . deleteDirectory ( new File ( TEST_DIR ) ) ; } } }
va	9	@ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; Math other = ( Math ) obj ; if ( apply == null ) { if ( other . apply != null ) return false ; } else if ( ! apply . equals ( other . apply ) ) return false ; if ( xmlns == null ) { if ( other . xmlns != null ) return false ; } else if ( ! xmlns . equals ( other . xmlns ) ) return false ; return true ; }
va	1	@ Override public void print ( ) { System . out . println ( "\n" + this . getName ( ) + "   " + this . getDescription ( ) ) ; System . out . println ( "---------------------------------" ) ; Iterator < MenuComponent > iterator = menuComponents . iterator ( ) ; while ( iterator . hasNext ( ) ) { MenuComponent mentComponent = iterator . next ( ) ; mentComponent . print ( ) ; } }
va	9	@ Override public void verifyText ( VerifyEvent e ) { if ( e . keyCode == 8 || e . keyCode == 127 ) { NewMapDialog . this . setErrorMessage ( null ) ; boolean valid = ( ( Text ) e . widget ) . getText ( ) . length ( ) > 1 || ( e . character > 0 && e . character <= 9 ) ; updateState ( e . widget , valid ) ; return ; } String text = e . text ; char [ ] chars = new char [ text . length ( ) ] ; text . getChars ( 0 , text . length ( ) , chars , 0 ) ; for ( int i = 0 ; i < chars . length ; i ++ ) { if ( chars [ i ] < 0 || chars [ i ] > 9 ) { e . doit = false ; NewMapDialog . this . setErrorMessage ( "Enter only digits between 0 and 9." ) ; return ; } } if ( ( ( ( Text ) e . widget ) . getText ( ) . length ( ) + 1 > 6 ) && ! ( e . keyCode == 8 || e . keyCode == 127 ) ) { e . doit = false ; NewMapDialog . this . setErrorMessage ( "Enter at most 999999  i.e. 0.999999*10^6" ) ; return ; } NewMapDialog . this . setErrorMessage ( null ) ; boolean valid = ( ( Text ) e . widget ) . getText ( ) . length ( ) > 0 || ( e . character > 0 && e . character <= 9 ) ; updateState ( e . widget , valid ) ; }
va	5	public ArrayList < MensajesListas > getMensajesListas ( ) { ArrayList < MensajesListas > list = new ArrayList < MensajesListas > ( ) ; try { String SQL1 = "SELECT * FROM mensajeslistas" ; Statement st1 = getSgd ( ) . createStatement ( ) ; ResultSet rs1 = getSgd ( ) . getResultSet ( SQL1 , st1 ) ; while ( rs1 != null && rs1 . next ( ) ) { MensajesListas bml = new MensajesListas ( client ) ; int idlista = rs1 . getInt ( "id" ) ; bml . setId ( idlista ) ; bml . setNombre ( rs1 . getString ( "nombre" ) ) ; String SQL2 = "SELECT mlp.*  p.nombre FROM mensajeslistasprofesores as mlp INNER JOIN" + " profesores as p ON p.id=mlp.idProfesores WHERE idMensajesListas=" + idlista ; Statement st2 = getSgd ( ) . createStatement ( ) ; ResultSet rs2 = getSgd ( ) . getResultSet ( SQL2 , st2 ) ; while ( rs2 != null && rs2 . next ( ) ) { MensajesListasProfesores listProfes = new MensajesListasProfesores ( client ) ; listProfes . id = rs2 . getInt ( "id" ) ; listProfes . idMensajesListas = rs2 . getInt ( "idMensajesListas" ) ; listProfes . setCodigo ( rs2 . getString ( "idProfesores" ) ) ; listProfes . setNombre ( rs2 . getString ( "nombre" ) ) ; listProfes . setSelected ( true ) ; bml . getListMensajesListasProfesores ( ) . add ( listProfes ) ; } rs2 . close ( ) ; st2 . close ( ) ; list . add ( bml ) ; } rs1 . close ( ) ; st1 . close ( ) ; } catch ( SQLException ex ) { Logger . getLogger ( MensajesListas . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } return list ; }
va	3	@ Override public String execute ( ) throws Exception { String consequence = ERROR ; Map < String , Object > form = new HashMap < String , Object > ( ) ; Map < String , String > error = new HashMap < String , String > ( ) ; try { form . put ( "nome" , input . getString ( "nome" ) ) ; form . put ( "login" , input . getLong ( "login" ) ) ; form . put ( "senha" , input . getString ( "senha" ) ) ; form . put ( "emailCorporativo" , input . getString ( "emailCorporativo" ) ) ; form . put ( "emailPessoal" , input . getString ( "emailPessoal" ) ) ; form . put ( "telCorporativo" , input . getString ( "telefoneCorporativo" ) ) ; form . put ( "telefonePessoal" , input . getString ( "telefonePessoal" ) ) ; form . put ( "tipo" , input . getString ( "tipo" ) ) ; error = ServiceLocator . getUsuarioService ( ) . validateForCreate ( form ) ; } catch ( Exception e ) { error . put ( "login" , "O login deve conter apenas n\u00FAmeros!" ) ; } if ( error == null || error . isEmpty ( ) ) { Usuario usuario = new Usuario ( ) ; usuario . setNome ( ( String ) form . get ( "nome" ) ) ; usuario . setLogin ( ( String ) form . get ( "login" ) ) ; usuario . setSenha ( ( String ) form . get ( "senha" ) ) ; usuario . setCpf ( ( String ) form . get ( "cpf" ) ) ; usuario . setRg ( ( String ) form . get ( "rg" ) ) ; usuario . setEmailCorporativo ( ( String ) form . get ( "emailCorporativo" ) ) ; usuario . setEmailPessoal ( ( String ) form . get ( "emailPessoal" ) ) ; usuario . setTelefonePessoal ( ( String ) form . get ( "telefonePessoal" ) ) ; usuario . setTelefoneCorporativo ( ( String ) form . get ( "telefoneCorporativo" ) ) ; usuario . setTipo ( ( String ) form . get ( "tipo" ) ) ; Empresa empresa = ServiceLocator . getEmpresaService ( ) . readById ( ( long ) form . get ( "empresa.id" ) ) ; usuario . setEmpresa ( empresa ) ; ServiceLocator . getUsuarioService ( ) . create ( usuario ) ; consequence = SUCCESS ; } else { output . setValue ( "error" , error ) ; } return consequence ; }
va	4	public void draw ( int wX , int wY , TexInfo texinfo , int orientation ) { int screenX = wX + iconX ; int screenY = wY + iconY ; TexInfo currentTexInfo = texinfo ; Color4F color = currentTexInfo . getColor4F ( ) ; glColor4f ( 1f , 1f , 1f , 1f ) ; glColor4f ( color . getRed ( ) , color . getGreen ( ) , color . getBlue ( ) , color . getAlpha ( ) ) ; currentTexInfo . setTextureName ( "items" ) ; Boot . getTexHandler ( ) . bindTexture ( currentTexInfo . getTextureName ( ) ) ; float xloc = 0 ; float yloc = 0 ; float top ; float bottom ; float left ; float right ; float rotation = orientation * 90 ; xloc = currentTexInfo . getSpriteSheetX ( ) ; yloc = currentTexInfo . getSpriteSheetY ( ) ; top = ( yloc * Standards . TILE_SIZE_ON_TEX_F ) / Standards . TEX_SIZE_F ; bottom = top + ( Standards . TILE_SIZE_ON_TEX_F / Standards . TEX_SIZE_F ) ; left = ( xloc * Standards . TILE_SIZE_ON_TEX_F ) / Standards . TEX_SIZE_F ; right = left + ( Standards . TILE_SIZE_ON_TEX_F / Standards . TEX_SIZE_F ) ; float rotXOffset = 0 ; float rotYOffset = 0 ; switch ( orientation ) { case Standards . NORTH : break ; case Standards . SOUTH : rotXOffset = Standards . TILE_SIZE ; rotYOffset = Standards . TILE_SIZE ; break ; case Standards . EAST : rotXOffset = Standards . TILE_SIZE ; break ; case Standards . WEST : rotYOffset = Standards . TILE_SIZE ; break ; } glPushMatrix ( ) ; glRotatef ( rotation , 0.0f , 0.0f , 1.0f ) ; glBegin ( GL_QUADS ) ; { glTexCoord2f ( left , top ) ; glVertex2i ( screenX , screenY ) ; glTexCoord2f ( right , top ) ; glVertex2i ( screenX + Standards . TILE_SIZE , screenY ) ; glTexCoord2f ( right , bottom ) ; glVertex2i ( screenX + Standards . TILE_SIZE , screenY + Standards . TILE_SIZE ) ; glTexCoord2f ( left , bottom ) ; glVertex2i ( screenX , screenY + Standards . TILE_SIZE ) ; } glEnd ( ) ; glPopMatrix ( ) ; }
va	5	private void findPhp ( ) { try { int c = reader . read ( ) ; while ( c != - 1 ) { if ( c == < ) { c = reader . read ( ) ; if ( c == ? || c == - 1 ) { break ; } } else { c = reader . read ( ) ; } } } catch ( IOException ex ) { token = null ; } }
va	6	public Header readFrame ( ) throws BitstreamException { Header result = null ; try { result = readNextFrame ( ) ; if ( firstframe == true ) { result . parseVBR ( frame_bytes ) ; firstframe = false ; } } catch ( BitstreamException ex ) { if ( ( ex . getErrorCode ( ) == INVALIDFRAME ) ) { try { closeFrame ( ) ; result = readNextFrame ( ) ; } catch ( BitstreamException e ) { if ( ( e . getErrorCode ( ) != STREAM_EOF ) ) { throw newBitstreamException ( e . getErrorCode ( ) , e ) ; } } } else if ( ( ex . getErrorCode ( ) != STREAM_EOF ) ) { throw newBitstreamException ( ex . getErrorCode ( ) , ex ) ; } } return result ; }
va	3	static byte [ ] toIntegerBytes ( BigInteger bigInt ) { int bitlen = bigInt . bitLength ( ) ; bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ; byte [ ] bigBytes = bigInt . toByteArray ( ) ; if ( ( ( bigInt . bitLength ( ) % 8 ) != 0 ) && ( ( ( bigInt . bitLength ( ) / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { return bigBytes ; } int startSrc = 0 ; int len = bigBytes . length ; if ( ( bigInt . bitLength ( ) % 8 ) == 0 ) { startSrc = 1 ; len -- ; } int startDst = bitlen / 8 - len ; byte [ ] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; }
va	5	private String getExceptParams ( ArrayList < String > alExcept ) { String resultado = "" ; for ( Map . Entry < String , String > entry : this . parameters . entrySet ( ) ) { String key = entry . getKey ( ) ; String value = entry . getValue ( ) ; if ( ! value . equalsIgnoreCase ( "" ) ) { String strParam ; Iterator < String > iterator = alExcept . iterator ( ) ; boolean encontrado = false ; while ( iterator . hasNext ( ) ) { strParam = iterator . next ( ) ; if ( key . equals ( strParam ) ) { encontrado = true ; } } if ( ! encontrado ) { resultado += key + "=" + value + "&" ; } } } return resultado ; }
va	0	public void setClientId ( String clientId ) { String oldValue = this . clientId ; this . clientId = clientId ; buildGrantUrl ( ) ; fireListenerEvent ( new PropertyChangeEvent ( this , CLIENT_ID , oldValue , this . clientId ) ) ; }
va	5	public void scanFill ( final Color [ ] [ ] frameBuffer ) { if ( frameBuffer == null ) { throw new NullPointerException ( "'frameBuffer' must not be 'null'" ) ; } int minX = 0 ; int minY = 0 ; int maxX = 0 ; int maxY = 0 ; for ( int i = 0 ; i < vertices . size ( ) ; ++ i ) { minX = ( int ) Math . min ( minX , vertices . get ( i ) . get ( 0 , 0 ) ) ; minY = ( int ) Math . min ( minY , vertices . get ( i ) . get ( 1 , 0 ) ) ; maxX = ( int ) Math . max ( maxX , vertices . get ( i ) . get ( 0 , 0 ) ) ; maxY = ( int ) Math . max ( maxY , vertices . get ( i ) . get ( 1 , 0 ) ) ; } for ( int x = minX ; x < maxX ; ++ x ) { for ( int y = minY ; y < maxY ; ++ y ) { if ( pointInPolygon ( x , y ) ) { frameBuffer [ x ] [ y ] = Color . white ; } } } }
va	2	private String getSelectedSoundNameFromID ( int selectedSoundID ) { for ( int i = 0 ; i < soundIDs . length ; i ++ ) { int ID = soundIDs [ i ] ; if ( ID == selectedSoundID ) return soundNames [ i ] ; } return "" ; }
va	9	private void method37 ( int j ) { if ( ! lowMem ) { if ( Texture . anIntArray1480 [ 17 ] >= j ) { Background background = Texture . aBackgroundArray1474s [ 17 ] ; int k = background . anInt1452 * background . anInt1453 - 1 ; int j1 = background . anInt1452 * anInt945 * 2 ; byte abyte0 [ ] = background . aByteArray1450 ; byte abyte3 [ ] = aByteArray912 ; for ( int i2 = 0 ; i2 <= k ; i2 ++ ) abyte3 [ i2 ] = abyte0 [ i2 - j1 & k ] ; background . aByteArray1450 = abyte3 ; aByteArray912 = abyte0 ; Texture . method370 ( 17 ) ; anInt854 ++ ; if ( anInt854 > 1235 ) { anInt854 = 0 ; stream . createFrame ( 226 ) ; stream . writeWordBigEndian ( 0 ) ; int l2 = stream . currentOffset ; stream . writeWord ( 58722 ) ; stream . writeWordBigEndian ( 240 ) ; stream . writeWord ( ( int ) ( Math . random ( ) * 65536D ) ) ; stream . writeWordBigEndian ( ( int ) ( Math . random ( ) * 256D ) ) ; if ( ( int ) ( Math . random ( ) * 2D ) == 0 ) stream . writeWord ( 51825 ) ; stream . writeWordBigEndian ( ( int ) ( Math . random ( ) * 256D ) ) ; stream . writeWord ( ( int ) ( Math . random ( ) * 65536D ) ) ; stream . writeWord ( 7130 ) ; stream . writeWord ( ( int ) ( Math . random ( ) * 65536D ) ) ; stream . writeWord ( 61657 ) ; stream . writeBytes ( stream . currentOffset - l2 ) ; } } if ( Texture . anIntArray1480 [ 24 ] >= j ) { Background background_1 = Texture . aBackgroundArray1474s [ 24 ] ; int l = background_1 . anInt1452 * background_1 . anInt1453 - 1 ; int k1 = background_1 . anInt1452 * anInt945 * 2 ; byte abyte1 [ ] = background_1 . aByteArray1450 ; byte abyte4 [ ] = aByteArray912 ; for ( int j2 = 0 ; j2 <= l ; j2 ++ ) abyte4 [ j2 ] = abyte1 [ j2 - k1 & l ] ; background_1 . aByteArray1450 = abyte4 ; aByteArray912 = abyte1 ; Texture . method370 ( 24 ) ; } if ( Texture . anIntArray1480 [ 34 ] >= j ) { Background background_2 = Texture . aBackgroundArray1474s [ 34 ] ; int i1 = background_2 . anInt1452 * background_2 . anInt1453 - 1 ; int l1 = background_2 . anInt1452 * anInt945 * 2 ; byte abyte2 [ ] = background_2 . aByteArray1450 ; byte abyte5 [ ] = aByteArray912 ; for ( int k2 = 0 ; k2 <= i1 ; k2 ++ ) abyte5 [ k2 ] = abyte2 [ k2 - l1 & i1 ] ; background_2 . aByteArray1450 = abyte5 ; aByteArray912 = abyte2 ; Texture . method370 ( 34 ) ; } if ( Texture . anIntArray1480 [ 40 ] >= j ) { Background background_2 = Texture . aBackgroundArray1474s [ 40 ] ; int i1 = background_2 . anInt1452 * background_2 . anInt1453 - 1 ; int l1 = background_2 . anInt1452 * anInt945 * 2 ; byte abyte2 [ ] = background_2 . aByteArray1450 ; byte abyte5 [ ] = aByteArray912 ; for ( int k2 = 0 ; k2 <= i1 ; k2 ++ ) abyte5 [ k2 ] = abyte2 [ k2 - l1 & i1 ] ; background_2 . aByteArray1450 = abyte5 ; aByteArray912 = abyte2 ; Texture . method370 ( 40 ) ; } } }
va	7	private JSONWriter append ( String s ) throws JSONException { if ( s == null ) { throw new JSONException ( "Null pointer" ) ; } if ( this . mode == o || this . mode == a ) { try { if ( this . , && this . mode == a ) { this . writer . write (   ) ; } this . writer . write ( s ) ; } catch ( IOException e ) { throw new JSONException ( e ) ; } if ( this . mode == o ) { this . mode = k ; } this . , = true ; return this ; } throw new JSONException ( "Value out of sequence." ) ; }
va	7	public static boolean hasAnnotations ( class < ? > c , class < ? extends java . lang . annotation . Annotation > annotationClass ) { if ( c . isAnnotationPresent ( annotationClass ) ) { System . out . println ( "c.getAnnotation(): " + c . getAnnotation ( annotationClass ) ) ; System . out . println ( "c.isAnnotationPresent(" + annotationClass . getName ( ) + ")" ) ; } for ( Method method : c . isInterface ( ) ? c . getMethods ( ) : c . getDeclaredMethods ( ) ) { System . out . println ( "method: " + method ) ; if ( method . isAnnotationPresent ( annotationClass ) ) { System . out . println ( "method.isAnnotationPresent(" + annotationClass . getName ( ) + ")" ) ; } for ( Annotation ann : method . getAnnotations ( ) ) { System . out . println ( "Annotation: " + ann ) ; } } return false ; }
va	0	public void close ( ) { running = accepting = false ; }
va	2	private static boolean joinDistinctTest ( ) throws TestNotPassedException { prepareData ( ) ; PojoPerson [ ] resultRecieved = new PojoPerson [ ] { new PojoPerson ( "First" , "Second" , "Last" ) , new PojoPerson ( "First" , "Second" , "Last" , EnumJob . DEVELOPER ) , new PojoPerson ( "First" , null , "Last" ) , new PojoPerson ( "First" , "Second" , "Last" , EnumJob . DIRECTOR ) , new PojoPerson ( "FIRSTt" , "Second" , "Last" , EnumJob . DEVELOPER ) , } ; PojoPerson [ ] re = PojoPersonUtils . joinDistinct ( persons1 , persons2 ) ; if ( ! Arrays . equals ( re , resultRecieved ) ) { errorMessageArr ( "joinDistinctTest test 1" , re , resultRecieved ) ; return false ; } resultRecieved = new PojoPerson [ ] { new PojoPerson ( "First" , null , "Last" ) , new PojoPerson ( "First" , "Second" , "Last" , EnumJob . DIRECTOR ) , new PojoPerson ( "FIRSTt" , "Second" , "Last" , EnumJob . DEVELOPER ) , new PojoPerson ( "First" , "Second" , "Last" , EnumJob . DEVELOPER ) , new PojoPerson ( "First" , "Second" , "Last" ) , } ; re = PojoPersonUtils . joinDistinct ( persons2 , persons1 ) ; if ( ! Arrays . equals ( re , resultRecieved ) ) { errorMessageArr ( "joinDistinctTest test 2" , re , resultRecieved ) ; return false ; } return true ; }
va	7	public QuerySet < T > endsWith ( String query ) { QuerySet < T > querySet = null ; if ( query != null && ! query . isEmpty ( ) ) { querySet = new QuerySet < T > ( ) ; query = query . replace ( "__endswith" , "" ) ; String [ ] queryComponents = query . split ( "=" ) ; String fieldName = queryComponents [ 0 ] ; String fieldValue = queryComponents [ 1 ] ; Field field = null ; try { if ( fieldName . equals ( "id" ) ) { field = this . entity . getSuperclass ( ) . getDeclaredField ( fieldName ) ; } else { field = this . entity . getDeclaredField ( fieldName ) ; } field . setAccessible ( true ) ; String pattern = String . format ( "^.*%s$" , fieldValue . replace ( "'" , "" ) ) ; for ( T model : this ) { if ( field . get ( model ) != null && field . get ( model ) . toString ( ) . matches ( pattern ) ) { querySet . add ( model ) ; } } } catch ( Exception e ) { e . printStackTrace ( ) ; } } return querySet ; }
va	3	private void write ( Symbol symbol , BitWriter bitwriter ) throws JSONException { try { Symbol back = symbol . back ; if ( back != null ) { this . width += 1 ; write ( back , bitwriter ) ; if ( back . zero == symbol ) { bitwriter . zero ( ) ; } else { bitwriter . one ( ) ; } } } catch ( Throwable e ) { throw new JSONException ( e ) ; } }
va	0	public static String truncateText ( String text ) { return truncateText ( text , 60 ) ; }
va	5	public void add ( Component comp , String region , Object constraints ) { if ( region . equals ( NORTH ) ) { northPanel . add ( comp , constraints ) ; } else if ( region . equals ( SOUTH ) ) { southPanel . add ( comp , constraints ) ; } else if ( region . equals ( WEST ) ) { westPanel . add ( comp , constraints ) ; } else if ( region . equals ( EAST ) ) { eastPanel . add ( comp , constraints ) ; } else if ( region . equals ( CENTER ) ) { centerPanel . add ( comp , constraints ) ; } else { throw new ErrorException ( "add: Illegal region " + region ) ; } }
va	1	public final void skipBits ( int n ) throws IOException { if ( bit_pos < n ) get_long ( ) ; bit_pos -= n ; }
va	7	public int read ( int bits ) { int ret ; int m = mask [ bits ] ; bits += endbit ; if ( endbyte + 4 >= storage ) { ret = - 1 ; if ( endbyte + ( bits - 1 ) / 8 >= storage ) { ptr += bits / 8 ; endbyte += bits / 8 ; endbit = bits & 7 ; return ( ret ) ; } } ret = ( ( buffer [ ptr ] ) & ff ) >>> endbit ; if ( bits > 8 ) { ret |= ( ( buffer [ ptr + 1 ] ) & ff ) << ( 8 - endbit ) ; if ( bits > 16 ) { ret |= ( ( buffer [ ptr + 2 ] ) & ff ) << ( 16 - endbit ) ; if ( bits > 24 ) { ret |= ( ( buffer [ ptr + 3 ] ) & ff ) << ( 24 - endbit ) ; if ( bits > 32 && endbit != 0 ) { ret |= ( ( buffer [ ptr + 4 ] ) & ff ) << ( 32 - endbit ) ; } } } } ret &= m ; ptr += bits / 8 ; endbyte += bits / 8 ; endbit = bits & 7 ; return ( ret ) ; }
va	0	public EditorScreen ( ScreenManager sm ) { super ( sm ) ; currentTool = new CreateTool ( this ) ; labels = new Label [ 7 ] ; labels [ 0 ] = new Label ( "R:" , 10 , 100 , 14f ) ; labels [ 1 ] = new Label ( "0" , 295 , 100 , 14f ) ; labels [ 2 ] = new Label ( "G:" , 10 , 120 , 14f ) ; labels [ 3 ] = new Label ( "0" , 295 , 120 , 14f ) ; labels [ 4 ] = new Label ( "B:" , 10 , 140 , 14f ) ; labels [ 5 ] = new Label ( "0" , 295 , 140 , 14f ) ; labels [ 6 ] = new Label ( "Current Color" , 10 , 160 , 14f , Color . darkGray ) ; sliders = new Slider [ 3 ] ; sliders [ 0 ] = new Slider ( ColorIdGenerator . getId ( ) , 28f , 107f , 0 , 255 ) ; sliders [ 0 ] . onChange ( labels [ 1 ] ) ; sliders [ 1 ] = new Slider ( ColorIdGenerator . getId ( ) , 28f , 127f , 0 , 255 ) ; sliders [ 1 ] . onChange ( labels [ 3 ] ) ; sliders [ 2 ] = new Slider ( ColorIdGenerator . getId ( ) , 28f , 147f , 0 , 255 ) ; sliders [ 2 ] . onChange ( labels [ 5 ] ) ; swatch_id = ColorIdGenerator . getId ( ) ; swatches = new ColorSwatches ( swatch_id , 260f , 240f ) ; tbox_id = ColorIdGenerator . getId ( ) ; tbox = new Toolbox ( tbox_id ) ; ColorIdGenerator . getId ( ) ; cs = new ColorSelection ( 20 , 190 ) ; this . updateColor ( Color . white ) ; items . addItem ( new SidePickableSPVoxel ( IdGenerator . getId ( ) , 0.0f , 0.0f , 0.0f , Color . white ) ) ; res = items . getResolution ( ) ; }
va	2	private static int partition ( int [ ] array , int left , int right ) { int i = left - 1 ; int temp ; for ( int j = left ; j < right ; j ++ ) { if ( array [ j ] <= array [ right ] ) { i ++ ; temp = array [ i ] ; array [ i ] = array [ j ] ; array [ j ] = temp ; } } temp = array [ i + 1 ] ; array [ i + 1 ] = array [ right ] ; array [ right ] = temp ; return i + 1 ; }
va	0	@ Override public void setMessage ( final Object message ) { this . setText ( message . toString ( ) ) ; }
va	7	private void loadDefinition ( Buffer stream ) { do { int j = stream . getUnsignedByte ( ) ; if ( j == 0 ) return ; if ( j == 1 ) { configId = stream . getUnsignedLEShort ( ) ; leastSignificantBit = stream . getUnsignedByte ( ) ; mostSignificantBit = stream . getUnsignedByte ( ) ; } else if ( j == 10 ) stream . getString ( ) ; else if ( j == 2 ) aBoolean651 = true ; else if ( j == 3 ) stream . getInt ( ) ; else if ( j == 4 ) stream . getInt ( ) ; else System . out . println ( "Error unrecognised config code: " + j ) ; } while ( true ) ; }
va	5	@ Override public void processCommand ( String ... args ) throws SystemCommandException { Role internshipRole = null ; if ( args . length > 2 ) try { internshipRole = createNewInternshipRole ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } else { Integer advertIndex = Integer . parseInt ( args [ 0 ] ) ; Integer roleIndex = Integer . parseInt ( args [ 1 ] ) ; internshipRole = facade . selectRole ( advertIndex , roleIndex ) ; if ( internshipRole == null ) try { internshipRole = createNewInternshipRole ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } try { String managerName = dialogue . getUserInput ( "Enter manager name." ) ; String managerEmail = dialogue . getUserInput ( "Enter manager's email address." ) ; facade . notifyAcceptedOffer ( internshipRole , managerName , managerEmail ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }
va	8	@ Override @ SuppressWarnings ( "InfiniteLoopStatement" ) public void run ( ) { while ( true ) { for ( Topic topic : topics . values ( ) ) { try { if ( ! topic . lock . writeLock ( ) . tryLock ( 1 , TimeUnit . SECONDS ) ) continue ; } catch ( InterruptedException e ) { continue ; } if ( topic . isBusy ( ) ) { topic . lock . writeLock ( ) . unlock ( ) ; continue ; } long deltaLastHit = DateTime . now ( ) . getMillis ( ) - topic . getLastHit ( ) ; debug ( INFO , "deltaLastHit for " + topic . getNum ( ) + ": " + deltaLastHit ) ; if ( deltaLastHit <= threadRefreshRate ) { topic . lock . writeLock ( ) . unlock ( ) ; continue ; } topic . setBusy ( true ) ; try { newTopics . put ( topic . getNum ( ) ) ; } catch ( InterruptedException e ) { } topic . lock . writeLock ( ) . unlock ( ) ; } try { Thread . sleep ( 1000 ) ; } catch ( InterruptedException e ) { } } }
va	9	protected AUser getPartialUser ( String name ) { boolean unsureOnline = false ; AUser user = null ; String onlineplayer = null ; Player player = plugin . getServer ( ) . getPlayer ( name ) ; if ( player != null ) { onlineplayer = player . getName ( ) ; } if ( onlineplayer != null && User . existUser ( onlineplayer ) ) { user = User . getUser ( onlineplayer ) ; } else if ( User . existUser ( name ) ) { user = User . getUser ( name ) ; } else { Iterator < AUser > iter = User . iter ( ) ; while ( iter . hasNext ( ) ) { AUser user2 = iter . next ( ) ; if ( user2 . getName ( ) . toLowerCase ( ) . contains ( name . toLowerCase ( ) ) ) { if ( user == null ) { user = user2 ; } else { unsureOnline = true ; } } } if ( user == null || unsureOnline ) { ConfigurationSection node = usersConfig . getConfigurationSection ( "users." + name ) ; if ( node != null ) { user = new User ( name , node ) ; User . addUser ( user ) ; } else { Set < String > users = usersConfig . getConfigurationSection ( "users" ) . getKeys ( false ) ; for ( String potentialUser : users ) { if ( potentialUser . toLowerCase ( ) . contains ( name . toLowerCase ( ) ) ) { if ( user == null ) { node = usersConfig . getConfigurationSection ( "users." + potentialUser ) ; user = new User ( potentialUser , node ) ; User . addUser ( user ) ; } else { return null ; } } } } } } if ( user == null ) { return null ; } return user ; }
va	9	private static Object guess ( Object val ) { if ( val instanceof String ) { String s = ( ( String ) val ) . trim ( ) ; if ( s . length ( ) > 0 ) { final char cc = s . charAt ( 0 ) ; if ( cc == # ) return new Color ( s ) ; if ( cc >= 0 && cc <= 9 ) { final boolean % = s . charAt ( s . length ( ) - 1 ) == % ; if ( % ) { s = s . substring ( 0 , s . length ( ) - 1 ) ; } else { try { return new Integer ( s ) ; } catch ( NumberFormatException ex ) { } } if ( % || s . indexOf ( . ) >= 0 ) try { final double d = new double ( s ) ; return % ? d / 100 : d ; } catch ( NumberFormatException ex2 ) { } return new Size ( s ) ; } Color c = Color . getStandardColor ( s ) ; if ( c != null ) return c ; } } return val ; }
va	1	public void setColor ( int color ) { this . color = color ; try { this . colorObj = ColorDP . getOne ( color ) ; } catch ( SQLException ex ) { Logger . getLogger ( RemitoDetalle . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } }
