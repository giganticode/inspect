tr	2	int LzmaLenDecode ( int [ ] paramArrayOfInt , int paramInt1 , int paramInt2 ) throws IOException { if ( BitDecode ( paramArrayOfInt , paramInt1 + 0 ) == 0 ) { return BitTreeDecode ( paramArrayOfInt , paramInt1 + 2 + ( paramInt2 << 3 ) , 3 ) ; } if ( BitDecode ( paramArrayOfInt , paramInt1 + 1 ) == 0 ) { return 8 + BitTreeDecode ( paramArrayOfInt , paramInt1 + 130 + ( paramInt2 << 3 ) , 3 ) ; } return 16 + BitTreeDecode ( paramArrayOfInt , paramInt1 + 258 , 8 ) ; }
tr	6	@ Override public boolean equals ( final Object obj ) { if ( this == obj ) { return true ; } if ( obj == null ) { return false ; } if ( getClass ( ) != obj . getClass ( ) ) { return false ; } final Update other = ( Update ) obj ; if ( version == null ) { if ( other . version != null ) { return false ; } } else if ( ! version . equals ( other . version ) ) { return false ; } return true ; }
tr	9	public void setProperty ( String prop , Object value ) { Map < String , class < ? extends Object >> specialProperties = null ; try { java . lang . reflect . Field f = class . forName ( new Throwable ( ) . fillInStackTrace ( ) . getStackTrace ( ) [ 1 ] . getClassName ( ) ) . getField ( "SPECIAL_PROPERTIES" ) ; if ( f . getType ( ) . getName ( ) . equals ( "java.util.Map" ) ) { specialProperties = ( Map < String , class < ? extends Object >> ) f . get ( null ) ; } } catch ( Exception e ) { } if ( ( Channel . ALLOWED_PROPERTIES . containsKey ( prop ) && value . getClass ( ) . equals ( Channel . ALLOWED_PROPERTIES . get ( prop ) ) ) || ( specialProperties != null && specialProperties . containsKey ( prop ) && value . getClass ( ) . equals ( specialProperties . get ( prop ) ) ) ) { this . properties . put ( prop , value ) ; } else { throw new IllegalArgumentException ( ) ; } }
tr	3	public void updatePerfData ( boolean answerCorrect ) { if ( phrase . core . reverse ) { if ( answerCorrect ) { phrase . perf . revSuccess ++ ; phrase . perf . revLastSuccess = new java . sql . Timestamp ( System . currentTimeMillis ( ) ) ; } else { phrase . perf . revSuccess -- ; phrase . perf . revLastFail = new java . sql . Timestamp ( System . currentTimeMillis ( ) ) ; } phrase . core . success = phrase . perf . revSuccess ; } else { if ( answerCorrect ) { phrase . perf . success ++ ; phrase . perf . lastSuccess = new java . sql . Timestamp ( System . currentTimeMillis ( ) ) ; } else { phrase . perf . success -- ; phrase . perf . lastFail = new java . sql . Timestamp ( System . currentTimeMillis ( ) ) ; } phrase . core . success = phrase . perf . success ; } phrase . perf . saveToDB ( ) ; }
tr	8	@ Override protected void handleInboxItem ( InboxItem inboxItem ) { super . handleInboxItem ( inboxItem ) ; if ( inboxItem . getMessage ( ) instanceof TokenMessage ) { executeTurn ( ) ; } if ( inboxItem . getMessage ( ) instanceof LeaderElectionMessage ) { LeaderElectionMessage message = ( LeaderElectionMessage ) inboxItem . getMessage ( ) ; switch ( message . getLeaderElectionMessageType ( ) ) { case ASK_FOR_ROLL : { doRoll ( inboxItem . getSender ( ) ) ; break ; } case LEADER_ELECTED : { initRound ( ) ; ownPlayer . setActive ( true ) ; if ( message . getValue ( ) == ownEndpoint . getId ( ) ) { isDealer = true ; logger . info ( "New Dealer" ) ; sendToken ( getPreviousPlayer ( ) ) ; } else { logger . info ( "Player " + message . getValue ( ) + " is new dealer." ) ; } break ; } case ROLLED : { gatherRoll ( inboxItem . getSender ( ) , message ) ; break ; } } } if ( inboxItem . getMessage ( ) instanceof StatusMessage ) { handleStatusMessage ( ( StatusMessage ) inboxItem . getMessage ( ) ) ; } if ( inboxItem . getMessage ( ) instanceof DealerMessage ) { handleDealerMessage ( inboxItem . getSender ( ) , ( DealerMessage ) inboxItem . getMessage ( ) ) ; } }
tr	4	public static boolean endsWithIgnoreCase ( String str , String suffix ) { if ( str == null || suffix == null ) { return false ; } if ( str . endsWith ( suffix ) ) { return true ; } if ( str . length ( ) < suffix . length ( ) ) { return false ; } String lcStr = str . substring ( str . length ( ) - suffix . length ( ) ) . toLowerCase ( ) ; String lcSuffix = suffix . toLowerCase ( ) ; return lcStr . equals ( lcSuffix ) ; }
tr	9	public String toUpdateKML ( boolean suppressEnclosingTags ) { if ( ! isDirty ( ) ) { return "" ; } String change = "" ; boolean isPrimDirty = isPrimitiveDirty ( ) ; if ( isPrimDirty && ! suppressEnclosingTags ) { change += "<LatLonAltBox" ; if ( this . id != null ) { change += " id=\"" + this . getId ( ) + "\"" ; } if ( this . targetId != null ) { change += " targetId=\"" + this . getTargetId ( ) + "\"" ; } change += ">\n" ; } change += super . toUpdateKML ( true ) ; if ( this . isMinAltitudeDirty ) { change += "<minAltitude>" + this . minAltitude + "</minAltitude>\n" ; this . isMinAltitudeDirty = false ; } if ( this . isMaxAltitudeDirty ) { change += "<maxAltitude>" + this . maxAltitude + "</maxAltitude>\n" ; this . isMaxAltitudeDirty = false ; } if ( this . altitudeMode != null && this . isAltitudeModeDirty ) { change += "<altitudeMode>" + SpecialCaseFormatter . toKMLString ( this . altitudeMode ) + "</altitudeMode>\n" ; this . isAltitudeModeDirty = false ; } if ( isPrimDirty && ! suppressEnclosingTags ) { change += "</LatLonAltBox>\n" ; } setNotDirty ( ) ; return change ; }
tr	7	private void parseRTimeTVDB ( String name ) { if ( name . equals ( "year" ) ) { scrape . setYear ( strToInt ( currentValue ) ) ; } else if ( name . equals ( "month" ) ) { scrape . setMonth ( strToInt ( currentValue ) ) ; } else if ( name . equals ( "week" ) ) { scrape . setWeek ( strToInt ( currentValue ) ) ; } else if ( name . equals ( "day" ) ) { scrape . setDay ( strToInt ( currentValue ) ) ; } else if ( name . equals ( "hour" ) ) { scrape . setHour ( strToInt ( currentValue ) ) ; } else if ( name . equals ( "minute" ) ) { scrape . setMinute ( strToInt ( currentValue ) ) ; } else if ( name . equals ( "second" ) ) { scrape . setSecond ( strToInt ( currentValue ) ) ; } }
tr	0	public int delete ( int id ) { String SQL1 = "DELETE FROM sig_reserves where id=" + id ; int nup = client . getMysql ( ) . executeUpdate ( SQL1 ) ; return nup ; }
tr	7	public String multiply ( String num1 , String num2 ) { if ( num1 == null || num2 == null || num1 . length ( ) == 0 || num2 . length ( ) == 0 ) { return "" ; } if ( num1 . length ( ) + num2 . length ( ) <= 8 ) { return Integer . toString ( Integer . parseInt ( num1 ) * Integer . parseInt ( num2 ) ) ; } int l1 = num1 . length ( ) ; int l2 = num2 . length ( ) ; String a = num1 . substring ( 0 , l1 >> 1 ) ; String b = num1 . substring ( l1 >> 1 ) ; String c = num2 . substring ( 0 , l2 >> 1 ) ; String d = num2 . substring ( l2 >> 1 ) ; StringBuilder sb1 = new StringBuilder ( ) ; StringBuilder sb2 = new StringBuilder ( ) ; int limit = l1 - ( l1 >> 1 ) ; for ( int i = 0 ; i < limit ; i ++ ) { sb1 . append ( "0" ) ; } limit = l2 - ( l2 >> 1 ) ; for ( int i = 0 ; i < limit ; i ++ ) { sb2 . append ( "0" ) ; } String ac = multiply ( a , c ) + sb1 . toString ( ) + sb2 . toString ( ) ; String ad = multiply ( a , d ) + sb1 . toString ( ) ; String bc = multiply ( b , c ) + sb2 . toString ( ) ; String bd = multiply ( b , d ) ; String result = add ( ac , ad ) ; result = add ( result , bc ) ; result = add ( result , bd ) ; return result ; }
tr	7	private String getDayOfWeek ( int d ) { switch ( d ) { case Calendar . MONDAY : return "lunes" ; case Calendar . TUESDAY : return "martes" ; case Calendar . WEDNESDAY : return "mi\u00E9rcoles" ; case Calendar . THURSDAY : return "jueves" ; case Calendar . FRIDAY : return "viernes" ; case Calendar . SATURDAY : return "sabado" ; case Calendar . SUNDAY : return "domingo" ; } return "ERROR" ; }
tr	7	public List < String > getValidationErrors ( ) { List < String > errors = new ArrayList < String > ( ) ; if ( ! dataConversion . isDate ( transitionDay ) ) { errors . add ( "TransitionDay is not valid" ) ; } for ( String s : price ) { if ( s == null || s . length ( ) == 0 ) { errors . add ( "Prices for all funds are required" ) ; } if ( ! dataConversion . validDoubleMoreThanZero ( s ) ) { errors . add ( "Prices are not valid" ) ; break ; } if ( ! dataConversion . validLessThanMillion ( s ) ) { errors . add ( "Prices are too large  please check it again" ) ; break ; } } if ( fund_id . length != price . length ) { errors . add ( "You have to enter price for each fund" ) ; } return errors ; }
tr	8	public String longestCommonPrefix ( String [ ] strs ) { if ( strs == null || strs . length == 0 ) return "" ; int num = strs . length ; if ( num == 1 ) return strs [ 0 ] ; int len1 = strs [ 0 ] . length ( ) ; String prefix = "" ; for ( int idx = 0 ; idx < len1 ; idx ++ ) { boolean flag = false ; char key = strs [ 0 ] . charAt ( idx ) ; for ( int i = 1 ; i < num ; i ++ ) { if ( strs [ i ] . length ( ) <= idx || strs [ i ] . charAt ( idx ) != key ) { flag = true ; break ; } } if ( flag ) break ; else { prefix += key ; } } return prefix ; }
tr	3	public GameScreen ( ) { statsLayer = new PlayerStatsLayer ( ) ; pausedByFocus = false ; paused = false ; pauseLayer = new PauseLayer ( ) ; level = LevelFactory . getLevelById ( LevelFactory . level2 ) ; cam = Camera . getInstance ( ) . init ( Game . GAME_WIDTH , Game . GAME_HEIGHT ) ; level . init ( ) ; PhysicsEntity player = level . getPlayer ( ) ; player . addObserver ( ( CooldownObserver ) statsLayer ) ; player . addObserver ( this ) ; gameObjects = new ArrayList < GameObject > ( ) ; gameObjects . add ( new ColorLayer ( new Color ( 7AA1FF ) ) ) ; fillBackgounds ( Art . level_bg2 , 0.5 , 0.1 ) ; fillBackgounds ( Art . level_bg1 , 0.8 , 0.1 ) ; fadeOutLayer = new FadeOutLayer ( 30 , new Color ( FF0B0F ) ) ; gameObjects . add ( new DescriptionLayer ( Art . level1_desc ) ) ; gameObjects . add ( level ) ; gameObjects . add ( statsLayer ) ; gameObjects . add ( fadeOutLayer ) ; gameObjects . add ( pauseLayer ) ; Game . getGameInstance ( ) . addFocusListener ( new FocusListener ( ) { @ Override public void focusLost ( FocusEvent arg0 ) { if ( ! paused ) { pauseGame ( ) ; pausedByFocus = true ; } } @ Override public void focusGained ( FocusEvent arg0 ) { if ( paused && pausedByFocus ) { resumeGame ( ) ; pausedByFocus = false ; } } } ) ; }
tr	8	public String longestPrefixOf ( String string ) { if ( string == null ) { throw new IllegalArgumentException ( ) ; } if ( root == null ) { return null ; } int longest = - 1 ; if ( root . value != null ) { longest = 0 ; } Node < V > node = root ; int length = string . length ( ) ; for ( int i = 0 ; i < length && node != null ; ++ i ) { char c = string . charAt ( i ) ; if ( ! valid ( c ) ) { throw new IllegalArgumentException ( ) ; } node = node . next [ c ] ; if ( node . value != null ) { longest = i + 1 ; } } if ( longest == - 1 ) { return null ; } return string . substring ( 0 , longest ) ; }
tr	5	public boolean isWallhugPosition ( int x , int y ) { if ( getFreeCount ( x , y ) != 2 ) return false ; else if ( isEmpty ( moveLeft ( x ) , y ) && isEmpty ( moveRight ( x ) , y ) ) return false ; else if ( isEmpty ( x , moveUp ( y ) ) && isEmpty ( x , moveDown ( y ) ) ) return false ; else return true ; }
tr	3	public int maximum ( Node root ) { int root_val , left_val , right_val , max = Integer . MIN_VALUE ; if ( root != null ) { root_val = root . key ; left_val = maximum ( root . left ) ; right_val = maximum ( root . right ) ; if ( left_val > right_val ) max = left_val ; else max = - right_val ; if ( root_val > max ) max = root_val ; } return max ; }
tr	6	public static void visitDirectoriesRecursively ( FileVisitor visitor , File directory , String pattern , boolean recursively ) { if ( ! directory . isDirectory ( ) ) directory = directory . getParentFile ( ) ; if ( ! directory . getName ( ) . matches ( pattern ) ) return ; visitor . visitDirectory ( directory ) ; final ArrayList < File > childDirectories = new ArrayList < File > ( ) ; for ( File file : directory . listFiles ( ) ) { if ( file . isDirectory ( ) ) { childDirectories . add ( file ) ; } } if ( recursively ) { for ( File childDirectory : childDirectories ) { visitDirectoriesRecursively ( visitor , childDirectory , pattern , recursively ) ; } } }
tr	7	private boolean isRowEmpty ( int rowIndex ) { if ( rowIndex < getRowCount ( ) - 1 ) { return ( ( participantList . get ( rowIndex ) . getFirstName ( ) == null || participantList . get ( rowIndex ) . getFirstName ( ) . trim ( ) . equals ( "" ) ) && ( participantList . get ( rowIndex ) . getLastName ( ) == null || participantList . get ( rowIndex ) . getLastName ( ) . trim ( ) . equals ( "" ) ) ) ; } else { return ( ( lastRow . getFirstName ( ) == null || lastRow . getFirstName ( ) . trim ( ) . equals ( "" ) ) && ( lastRow . getLastName ( ) == null || lastRow . getLastName ( ) . trim ( ) . equals ( "" ) ) ) ; } }
tr	0	@ Override public float getX ( ) { return this . pos . x ; }
tr	3	public List < Pattern > findPatternsEqualTo ( int matchPattern , int matchCount , int [ ] [ ] board ) { List < Pattern > resultPatterns = new ArrayList < Pattern > ( ) ; for ( int i = 0 ; i < board . length ; i ++ ) { for ( int j = 0 ; j < board [ i ] . length ; j ++ ) { List < Pattern > result = checkPiecePatterns ( i , j , matchPattern , matchCount , board ) ; if ( result . size ( ) > 0 ) { resultPatterns . addAll ( result ) ; } } } return resultPatterns ; }
tr	9	public String toString ( ) { NumberFormat nf = NumberFormat . getCurrencyInstance ( Locale . US ) ; StringBuilder buffer = new StringBuilder ( ) ; int caracteres = 50 ; String adorno = ":_-_:" ; for ( int i = 0 ; i < caracteres ; i ++ ) { buffer . append ( adorno ) ; } buffer . append ( "\n\t\tBALANCE DE COMPROBACI\u00D3N\t\t\n" ) ; for ( int i = 0 ; i < caracteres ; i ++ ) { buffer . append ( adorno ) ; } buffer . append ( "\n\n" ) ; while ( balance . size ( ) > 0 ) { buffer . append ( balance . peek ( ) . codigo + "  " + balance . peek ( ) . nombre ) ; CuentaT temp = balance . pollFirst ( ) ; if ( temp . saldo > 0 ) { double debe = temp . saldo ; totalDebe += debe ; if ( temp . nombre . length ( ) > 5 && temp . nombre . length ( ) < 15 ) { buffer . append ( "\t\t" + nf . format ( debe ) ) ; } else if ( temp . nombre . length ( ) > 15 ) { buffer . append ( "\t" + nf . format ( debe ) ) ; } else { buffer . append ( "\t\t\t" + nf . format ( debe ) ) ; } } else { double haber = temp . saldo * - 1 ; totalHaber += haber ; if ( temp . nombre . length ( ) > 5 && temp . nombre . length ( ) < 15 ) { buffer . append ( "\t\t\t\t" + nf . format ( haber ) ) ; } else if ( temp . nombre . length ( ) > 15 && temp . nombre . length ( ) < 25 ) { buffer . append ( "\t\t\t\t" + nf . format ( haber ) ) ; } else if ( temp . nombre . length ( ) >= 25 ) { buffer . append ( "\t\t\t" + nf . format ( haber ) ) ; } else { buffer . append ( "\t\t\t\t\t" + nf . format ( haber ) ) ; } } buffer . append ( "\n" ) ; } for ( int i = 0 ; i < caracteres ; i ++ ) { buffer . append ( "-----" ) ; } buffer . append ( "\n" ) ; buffer . append ( "\t\t\t" + nf . format ( totalDebe ) + "\t" + nf . format ( totalHaber ) ) ; return buffer . toString ( ) ; }
tr	3	public static Matrix4 multiply ( Matrix4 m1 , Matrix4 m2 ) { Matrix4 C = new Matrix4 ( ) ; for ( int i = 0 ; i < 4 ; ++ i ) for ( int j = 0 ; j < 4 ; ++ j ) for ( int k = 0 ; k < 4 ; ++ k ) C . A [ i ] [ j ] += m1 . A [ i ] [ k ] * m2 . A [ k ] [ j ] ; return C ; }
tr	9	public V put ( int key , V value ) { if ( key == 0 ) { V oldValue = zeroValue ; zeroValue = value ; if ( ! hasZeroValue ) { hasZeroValue = true ; size ++ ; } return oldValue ; } int [ ] keyTable = this . keyTable ; int index1 = key & mask ; int key1 = keyTable [ index1 ] ; if ( key1 == key ) { V oldValue = valueTable [ index1 ] ; valueTable [ index1 ] = value ; return oldValue ; } int index2 = hash2 ( key ) ; int key2 = keyTable [ index2 ] ; if ( key2 == key ) { V oldValue = valueTable [ index2 ] ; valueTable [ index2 ] = value ; return oldValue ; } int index3 = hash3 ( key ) ; int key3 = keyTable [ index3 ] ; if ( key3 == key ) { V oldValue = valueTable [ index3 ] ; valueTable [ index3 ] = value ; return oldValue ; } for ( int i = capacity , n = i + stashSize ; i < n ; i ++ ) { if ( keyTable [ i ] == key ) { V oldValue = valueTable [ i ] ; valueTable [ i ] = value ; return oldValue ; } } if ( key1 == EMPTY ) { keyTable [ index1 ] = key ; valueTable [ index1 ] = value ; if ( size ++ >= threshold ) { resize ( capacity << 1 ) ; } return null ; } if ( key2 == EMPTY ) { keyTable [ index2 ] = key ; valueTable [ index2 ] = value ; if ( size ++ >= threshold ) { resize ( capacity << 1 ) ; } return null ; } if ( key3 == EMPTY ) { keyTable [ index3 ] = key ; valueTable [ index3 ] = value ; if ( size ++ >= threshold ) { resize ( capacity << 1 ) ; } return null ; } push ( key , value , index1 , key1 , index2 , key2 , index3 , key3 ) ; return null ; }
tr	6	@ Override public Object getValueAt ( int row , int column ) { Vehicle vehicle = vehicles . elementAt ( row ) ; switch ( column ) { case 0 : return vehicle . getLicencePlate ( ) ; case 1 : return vehicle . getStartDate ( ) ; case 2 : return vehicle . getOwner ( ) . getFirstName ( ) + " " + vehicle . getOwner ( ) . getFamilyName ( ) . toUpperCase ( ) ; case 3 : return vehicle . getModel ( ) . getDesignation ( ) ; case 4 : if ( this . deleteIcon == null ) { return "Supprimer" ; } return this . deleteIcon ; default : break ; } return null ; }
tr	2	public Node expand ( Board board , String mcColor ) { String newColor ; Random generator = new Random ( ) ; int randomIndex = generator . nextInt ( this . untriedMoves . size ( ) ) ; Tuple < Integer , Integer > move = this . untriedMoves . get ( randomIndex ) ; this . untriedMoves . remove ( randomIndex ) ; try { board . makeMove ( move , color ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } if ( this . color . equals ( "w" ) ) { newColor = "b" ; } else { newColor = "w" ; } Node node = new Node ( this , move , newColor , board , this . moveNumber + 1 , mcColor ) ; this . children . add ( node ) ; return node ; }
tr	3	@ Override public void run ( ) { while ( true ) { Socket clientSocket = null ; try { clientSocket = serverSocket . accept ( ) ; } catch ( IOException e ) { System . err . println ( "WSSListener.run(): Error accepting connection" ) ; } if ( clientSocket != null ) { new WSSClientConnection ( clientSocket ) ; } } }
tr	2	public static int getRelayExpansionModulesInstalled ( short rem ) { int qty = 0 ; for ( int i = 7 ; i >= 0 ; i -- ) { if ( ( rem & ( 1 << i ) ) == ( 1 << i ) ) { qty = i + 1 ; break ; } } return qty ; }
tr	6	public void fourth ( ) { someMan = new Man ( ) ; someMan . setBirthplace ( Event . COUNTRY ) ; someMan . putToHand ( new Fish ( Color . YELLOW , Size . LITTLE ) ) ; someMan . setAction ( new Action ( Options . NOTHING , "SHOVE FISH IN EAR" ) ) ; artur = new Artur ( ) ; artur . setFocus ( new CornflakesPacket ( ) ) ; if ( Dentrassi . getInstance ( ) . getUnderwear ( ) != null && getSomeMan ( ) != null && getMatrixes ( ) != null && getSomeMan ( ) . getBirthplace ( ) . equals ( Event . COUNTRY ) ) { for ( Eye eye : getArtur ( ) . getEyes ( ) ) { if ( eye . getFocus ( ) . getClass ( ) == CornflakesPacket . class ) { getArtur ( ) . setState ( State . SURE ) ; break ; } } } }
tr	7	public PixelMap and ( PixelMap rhs ) { int width = pixels . length ; int height = pixels [ 0 ] . length ; int rhsWidth = rhs . pixels . length ; int rhsHeight = rhs . pixels [ 0 ] . length ; int maxWidth = Math . max ( pixels . length , rhs . pixels . length ) ; int maxHeight = Math . max ( pixels [ 0 ] . length , rhs . pixels [ 0 ] . length ) ; boolean [ ] [ ] result = new boolean [ maxWidth ] [ maxHeight ] ; for ( int x = 0 ; x < maxWidth ; ++ x ) { for ( int y = 0 ; y < maxHeight ; ++ y ) { if ( x < width && y < height ) { if ( x < rhsWidth && y < rhsHeight ) { result [ x ] [ y ] = pixels [ x ] [ y ] && rhs . pixels [ x ] [ y ] ; } else { result [ x ] [ y ] = false ; } } else { result [ x ] [ y ] = false ; } } } return new PixelMap ( result ) ; }
tr	1	private void endExpression ( ) { String s = textHandler . end ( ) ; if ( s . length ( ) > 0 ) { container . add ( new Expression ( s , pass2 ) ) ; } }
tr	3	private static Method toIndentedStringMethod ( Object o ) { Method tsm = null ; class < ? > c = o . getClass ( ) ; if ( c != null ) { try { tsm = c . getDeclaredMethod ( "toIndentedString" , new class [ ] { stringClass } ) ; } catch ( NoSuchMethodException e ) { } return tsm ; } else return null ; }
tr	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( CadCurso . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( CadCurso . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( CadCurso . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( CadCurso . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { CadCurso dialog = new CadCurso ( new javax . swing . JFrame ( ) , true ) ; dialog . addWindowListener ( new java . awt . event . WindowAdapter ( ) { @ Override public void windowClosing ( java . awt . event . WindowEvent e ) { System . exit ( 0 ) ; } } ) ; dialog . setVisible ( true ) ; } } ) ; }
tr	0	public MetalLabel ( JLabel timer ) { timer . setFont ( DataManager . loadFont ( "text.ttf" ) . deriveFont ( 25f ) ) ; timer . setForeground ( new Color ( 15 , 120 , 0 ) ) ; bg = DataManager . loadImage ( "blank.png" ) ; setLayout ( new GridBagLayout ( ) ) ; GridBagConstraints gbc = new GridBagConstraints ( ) ; gbc . gridx = 0 ; gbc . gridy = 0 ; gbc . fill = gbc . BOTH ; gbc . anchor = gbc . CENTER ; gbc . insets = new Insets ( 6 , 0 , 0 , 0 ) ; add ( timer , gbc ) ; }
tr	5	public ChannelCipher ( String alg , byte [ ] secret , boolean forEncryption ) throws NoSuchAlgorithmException { int idx = getAlgId ( alg ) ; if ( idx < 0 ) throw new NoSuchAlgorithmException ( alg ) ; int keyLength = keySize [ idx ] ; byte [ ] keyData = new byte [ keyLength ] ; System . arraycopy ( secret , 0 , keyData , 0 , keyLength ) ; try { this . forEncryption = forEncryption ; worker = Cipher . getInstance ( cipherAlgs [ idx ] ) ; key = new SecretKeySpec ( keyData , keyAlgs [ idx ] ) ; AlgorithmParameterSpec spec = null ; if ( cipherAlgs [ idx ] . indexOf ( "CBC" ) != - 1 ) { int size = ivSize [ idx ] ; iv = new byte [ size ] ; for ( int n = 0 ; n < size ; n ++ ) iv [ n ] = secret [ n + keyLength ] ; spec = new IvParameterSpec ( iv ) ; } else iv = null ; int mode = forEncryption ? Cipher . ENCRYPT_MODE : Cipher . DECRYPT_MODE ; worker . init ( mode , key , spec ) ; } catch ( Exception e ) { worker = null ; iv = null ; } }
tr	7	public int longestValidParentheses ( String s ) { Stack < Character > sc = new Stack < Character > ( ) ; Stack < Integer > si = new Stack < Integer > ( ) ; int i = 0 , max = 0 ; for ( i = 0 ; i < s . length ( ) ; i ++ ) { char c = s . charAt ( i ) ; if ( si . isEmpty ( ) || c == ( ) { si . push ( i ) ; sc . push ( c ) ; } else { if ( sc . peek ( ) == ( ) { sc . pop ( ) ; si . pop ( ) ; if ( si . isEmpty ( ) ) { if ( max < i + 1 ) { max = i + 1 ; } } else { if ( max < i - si . peek ( ) ) { max = i - si . peek ( ) ; } } } } } return max ; }
tr	5	public void setup ( ) { setup = true ; if ( recordReplay ) replay = new GameReplay ( players , board ) ; playersAliveCount = players . length ; Player [ ] starters = players . clone ( ) ; int [ ] startPositions = board . getStartPositions ( starters . length ) ; if ( scrambleStartPositions ) { for ( int i = 0 ; i < startPositions . length ; i ++ ) { int randomIndex = random . nextInt ( startPositions . length ) ; int tmp = startPositions [ i ] ; startPositions [ i ] = startPositions [ randomIndex ] ; startPositions [ randomIndex ] = tmp ; } } for ( int i = 0 ; i < players . length ; i ++ ) { players [ i ] . setAlive ( true ) ; players [ i ] . setNumber ( i ) ; players [ i ] . reset ( ) ; int start = startPositions [ i ] ; board . placePlayerWall ( Board . posToX ( start ) , Board . posToY ( start ) , players [ i ] ) ; } if ( recordReplay ) replay . setStartPositions ( startPositions ) ; thread = new Thread ( ) { @ Override public void run ( ) { runGame ( ) ; } } ; }
tr	4	public void creerOuvriere ( String evenementActuel , int nbLarves ) { if ( nbLarves > 1 ) { if ( nbLarves == 2 ) { ajouterFourmi ( 1 ) ; } if ( nbLarves == 4 ) { ajouterFourmi ( 2 ) ; } if ( evenementActuel . equals ( Constantes . EVEN_OUVRIERES ) ) { ajouterFourmi ( 1 ) ; } } }
tr	7	public static void testValidity ( Object o ) throws JSONException { if ( o != null ) { if ( o instanceof double ) { if ( ( ( double ) o ) . isInfinite ( ) || ( ( double ) o ) . isNaN ( ) ) { throw new JSONException ( "JSON does not allow non-finite numbers." ) ; } } else if ( o instanceof float ) { if ( ( ( float ) o ) . isInfinite ( ) || ( ( float ) o ) . isNaN ( ) ) { throw new JSONException ( "JSON does not allow non-finite numbers." ) ; } } } }
tr	3	public static String [ ] readAllStrings ( ) { String [ ] tokens = WHITESPACE_PATTERN . split ( readAll ( ) ) ; if ( tokens . length == 0 || tokens [ 0 ] . length ( ) > 0 ) return tokens ; String [ ] decapitokens = new String [ tokens . length - 1 ] ; for ( int i = 0 ; i < tokens . length - 1 ; i ++ ) decapitokens [ i ] = tokens [ i + 1 ] ; return decapitokens ; }
tr	7	private static void load ( String workloadFile ) throws IOException , ParseException { DateFormat sdf = new SimpleDateFormat ( "d HH:mm:ss" ) ; int currentStep = 0 ; Date lastTimeGrain = null ; double max = 0 ; BufferedReader reader = new BufferedReader ( new InputStreamReader ( WorkloadGenerator . class . getResourceAsStream ( workloadFile ) ) ) ; String line = reader . readLine ( ) ; double tracesHour = 0 ; double currentWorkload = 0 ; while ( line != null && currentStep < basePercentage . length ) { StringTokenizer tokens = new StringTokenizer ( line ) ; tokens . nextToken ( ) ; tracesHour ++ ; currentWorkload += long . parseLong ( tokens . nextToken ( ) ) ; for ( int i = 0 ; i < 3 ; i ++ ) { tokens . nextToken ( ) ; } Date currentTimeGrain = sdf . parse ( tokens . nextToken ( ) + " " + tokens . nextToken ( ) ) ; if ( lastTimeGrain == null ) { lastTimeGrain = currentTimeGrain ; } if ( currentTimeGrain . getTime ( ) - lastTimeGrain . getTime ( ) >= WL_GRANULARITY_MS ) { currentWorkload /= tracesHour ; basePercentage [ currentStep ++ ] = currentWorkload ; if ( currentWorkload > max ) { max = currentWorkload ; } currentWorkload = 0 ; tracesHour = 0 ; lastTimeGrain = currentTimeGrain ; } line = reader . readLine ( ) ; } for ( int i = 0 ; i < basePercentage . length ; i ++ ) { basePercentage [ i ] /= max ; } }
tr	1	private boolean r_R1 ( ) { if ( ! ( I_p1 <= cursor ) ) { return false ; } return true ; }
tr	7	public static List < Object > expand ( Object input , Options opts ) throws JSONLDProcessingError { if ( opts . base == null ) { opts . base = "" ; } if ( opts . keepFreeFloatingNodes == null ) { opts . keepFreeFloatingNodes = false ; } input = JSONLDUtils . clone ( input ) ; JSONLDUtils . resolveContextUrls ( input ) ; final JSONLDProcessor p = new JSONLDProcessor ( opts ) ; Object expanded = p . expand ( new ActiveContext ( opts ) , null , input , false ) ; if ( isObject ( expanded ) && ( ( Map ) expanded ) . containsKey ( "@graph" ) && ( ( Map ) expanded ) . size ( ) == 1 ) { expanded = ( ( Map < String , Object > ) expanded ) . get ( "@graph" ) ; } else if ( expanded == null ) { expanded = new ArrayList < Object > ( ) ; } if ( ! isArray ( expanded ) ) { final List < Object > tmp = new ArrayList < Object > ( ) ; tmp . add ( expanded ) ; expanded = tmp ; } return ( List < Object > ) expanded ; }
tr	6	public void Solve ( ) { int [ ] triangles = new int [ _length + 1 ] ; for ( int i = 1 ; i < Math . sqrt ( _length ) ; i += 2 ) { for ( int j = 2 ; i + j < Math . sqrt ( _length ) ; j += 2 ) { if ( Euler . Gcd ( j , i ) == 1 ) { int sum = Math . abs ( j * j - i * i ) + 2 * i * j + i * i + j * j ; for ( int s = sum ; s <= _length ; s += sum ) { triangles [ s ] += 1 ; } } } } int count = 0 ; for ( int i : triangles ) { if ( i == 1 ) { count ++ ; } } System . out . println ( "Result=" + count ) ; }
tr	6	private String compare ( String leftHandSide , String rightHandSide ) { if ( leftHandSide . equals ( "integer" ) ) { if ( rightHandSide . equals ( "integer" ) ) { return "integer" ; } else if ( rightHandSide . equals ( "real" ) ) { return "real" ; } else { SemanticWarningList . addWarning ( SemanticWarning . makeNewWarning ( "Unknown type for variable '" + rightHandSide + "'. Undeclared variable." ) ) ; } } else if ( leftHandSide . equals ( "real" ) ) { if ( rightHandSide . equals ( "integer" ) || rightHandSide . equals ( "real" ) ) { return "real" ; } } return EMPTY ; }
tr	4	private java . lang . String registerPrefix ( javax . xml . stream . XMLStreamWriter xmlWriter , java . lang . String namespace ) throws javax . xml . stream . XMLStreamException { java . lang . String prefix = xmlWriter . getPrefix ( namespace ) ; if ( prefix == null ) { prefix = generatePrefix ( namespace ) ; javax . xml . namespace . NamespaceContext nsContext = xmlWriter . getNamespaceContext ( ) ; while ( true ) { java . lang . String uri = nsContext . getNamespaceURI ( prefix ) ; if ( uri == null || uri . length ( ) == 0 ) { break ; } prefix = org . apache . axis2 . databinding . utils . BeanUtil . getUniquePrefix ( ) ; } xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } return prefix ; }
tr	4	public static void execute_crop_stmt ( PreparedStatement pstmt , int [ ] indexes , HashSet < Integer > set ) throws SQLException { int cnt = 0 ; for ( int i = 0 ; i < indexes . length ; i ++ ) { if ( ! set . contains ( indexes [ i ] ) ) { pstmt . setInt ( 1 , indexes [ i ] ) ; pstmt . addBatch ( ) ; cnt ++ ; if ( cnt > 5000 ) { pstmt . executeBatch ( ) ; cnt = 0 ; } } } if ( cnt > 0 ) pstmt . executeBatch ( ) ; }
tr	0	public DwarfRequestPacket ( Integer id , DwarfRequest request , Orientation orientation ) { this . id = id ; this . request = request ; this . orientation = orientation ; }
tr	8	public static int search3 ( int [ ] A , int target ) { if ( A . length == 0 ) return - 1 ; int l = 0 ; int r = A . length - 1 ; int m ; while ( l <= r ) { m = ( l + r ) / 2 ; if ( target == A [ m ] ) { return m ; } else if ( A [ l ] <= A [ m ] ) { if ( target < A [ m ] && target >= A [ l ] ) { r = m - 1 ; } else { l = m + 1 ; } } else { if ( target <= A [ r ] && target > A [ m ] ) { l = m + 1 ; } else { r = m - 1 ; } } } return - 1 ; }
tr	7	public boolean collision ( HashMap < Body , Personnage > personnages ) { if ( world == null ) return false ; Personnage persCourant ; CollisionEvent [ ] evenement = world . getContacts ( body ) ; float Normal_x ; for ( int i = 0 ; i < evenement . length ; i ++ ) { Normal_x = evenement [ i ] . getNormal ( ) . getX ( ) ; if ( Normal_x < - 0.5 || Normal_x > 0.5 ) { if ( evenement [ i ] . getBodyB ( ) == body ) { persCourant = personnages . get ( evenement [ i ] . getBodyA ( ) ) ; if ( persCourant != null && cible ( persCourant ) ) persCourant . toucher ( valeurDmg ) ; return true ; } } } return false ; }
tr	1	private static void test4 ( ) throws InterruptedException { ExecutorService executor = Executors . newWorkStealingPool ( ) ; List < Callable < String >> callables = Arrays . asList ( ( ) -> "task1" , ( ) -> "task2" , ( ) -> "task3" ) ; executor . invokeAll ( callables ) . stream ( ) . map ( future -> { try { return future . get ( ) ; } catch ( Exception e ) { throw new IllegalStateException ( e ) ; } } ) . forEach ( System . out COLCOL println ) ; executor . shutdown ( ) ; }
tr	0	public PrimitiveShape ( final PrimitiveShader glShader ) { shader = glShader ; pointBuffer = ByteBuffer . allocateDirect ( maxPoints * STRIDE ) . order ( ByteOrder . nativeOrder ( ) ) . asFloatBuffer ( ) ; linesBuffer = ByteBuffer . allocateDirect ( maxLinesPoints * STRIDE ) . order ( ByteOrder . nativeOrder ( ) ) . asFloatBuffer ( ) ; trianglesBuffer = ByteBuffer . allocateDirect ( maxTrianglesPoints * STRIDE ) . order ( ByteOrder . nativeOrder ( ) ) . asFloatBuffer ( ) ; }
tr	8	public StringBuilder streamOut ( ) { StringBuilder buffer = new StringBuilder ( ) ; for ( int i = 0 ; i < numLines ; i ++ ) { if ( i == 0 || i == numLines - 1 ) { buffer . append ( "2 w\n" ) ; } else if ( i == 1 ) { buffer . append ( "0.5 w\n" ) ; } buffer . append ( horzLines [ i ] . streamOut ( ) ) ; buffer . append ( vertLines [ i ] . streamOut ( ) ) ; } for ( OrdinalPt opt : ordPts ) { buffer . append ( opt . streamOut ( ) ) ; } for ( GoStone stone : goStones ) { buffer . append ( stone . streamOut ( ) ) ; } for ( GoLabel label : labels ) { buffer . append ( label . streamOut ( ) ) ; } for ( Triangle triangle : triangles ) { buffer . append ( triangle . streamOut ( ) ) ; } return buffer ; }
tr	9	private int get_next_page ( Page page , long boundary ) { if ( boundary > 0 ) boundary += offset ; while ( true ) { int more ; if ( boundary > 0 && offset >= boundary ) return OV_FALSE ; more = oy . pageseek ( page ) ; if ( more < 0 ) { offset -= more ; } else { if ( more == 0 ) { if ( boundary == 0 ) return OV_FALSE ; int ret = get_data ( ) ; if ( ret == 0 ) return OV_EOF ; if ( ret < 0 ) return OV_EREAD ; } else { int ret = ( int ) offset ; offset += more ; return ret ; } } } }
tr	7	IndexTable ( byte [ ] record ) { this . record = record ; int offset = 0 ; offset += 4 ; int nameLength = RecordAccess . getU16 ( this . record , offset ) ; offset += 2 ; if ( nameLength > 0 ) { offset += nameLength ; } peerCount = RecordAccess . getU16 ( this . record , offset ) ; offset += 2 ; peerIp = new Vector < InetAddress > ( peerCount ) ; for ( int i = 0 ; i < peerCount ; i ++ ) peerIp . addElement ( null ) ; peerBgp = new long [ peerCount ] ; peerAs = new long [ peerCount ] ; for ( int i = 0 ; i < peerCount ; i ++ ) { int bit0 = 1 ; int bit1 = 2 ; int peerType = RecordAccess . getU8 ( this . record , offset ) ; offset ++ ; int firstBit ; int secondBit ; if ( ( peerType & bit0 ) != 0 ) { firstBit = 16 ; } else firstBit = 4 ; if ( ( peerType & bit1 ) != 0 ) { secondBit = 4 ; } else secondBit = 2 ; long peerBgpId = RecordAccess . getU32 ( this . record , offset ) ; peerBgp [ i ] = peerBgpId ; offset += 4 ; try { takeIp = InetAddress . getByAddress ( RecordAccess . getBytes ( this . record , offset , firstBit ) ) ; } catch ( UnknownHostException e1 ) { e1 . printStackTrace ( ) ; } peerIp . set ( i , takeIp ) ; offset += firstBit ; long takePeerAs ; if ( secondBit == 2 ) takePeerAs = RecordAccess . getU16 ( this . record , offset ) ; else takePeerAs = RecordAccess . getU32 ( this . record , offset ) ; peerAs [ i ] = takePeerAs ; offset += secondBit ; } }
tr	7	@ Override public void actionPerformed ( ActionEvent e ) { String cmd = e . getActionCommand ( ) ; switch ( cmd ) { case CANCELAR : cerrar ( ) ; break ; case BUSCAR_DUENIO : ctrlContrato . buscarDuenio ( ) ; break ; case ELEGIR_DUENIO_BUSCADO : ctrlContrato . elegirDuenio ( CLIENTE_BUSCADO ) ; break ; case ELEGIR_DUENIO_NUEVO : ctrlContrato . elegirDuenio ( CLIENTE_NUEVO ) ; break ; case BUSCAR_RESPONSABLE : ctrlContrato . buscarResponsable ( ) ; break ; case ELEGIR_RESPONSABLE_BUSCADO : ctrlContrato . elegirResponsable ( CLIENTE_BUSCADO ) ; break ; case ELEGIR_RESPONSABLE_NUEVO : ctrlContrato . elegirResponsable ( CLIENTE_NUEVO ) ; break ; } }
tr	7	protected void notifyReceivedAck ( MqttAck ack ) throws MqttException { final String methodName = "notifyReceivedAck" ; this . lastInboundActivity = System . currentTimeMillis ( ) ; log . fine ( className , methodName , "627" , new Object [ ] { new Integer ( ack . getMessageId ( ) ) , ack } ) ; MqttToken token = tokenStore . getToken ( ack ) ; MqttException mex = null ; if ( ack instanceof MqttPubRec ) { MqttPubRel rel = new MqttPubRel ( ( MqttPubRec ) ack ) ; this . send ( rel , token ) ; } else if ( ack instanceof MqttPubAck || ack instanceof MqttPubComp ) { notifyResult ( ack , token , mex ) ; } else if ( ack instanceof MqttPingResp ) { pingOutstanding = false ; notifyResult ( ack , token , mex ) ; tokenStore . removeToken ( ack ) ; } else if ( ack instanceof MqttConnack ) { int rc = ( ( MqttConnack ) ack ) . getReturnCode ( ) ; if ( rc == 0 ) { synchronized ( queueLock ) { if ( cleanSession ) { clearState ( ) ; tokenStore . saveToken ( token , ack ) ; } inFlightPubRels = 0 ; actualInFlight = 0 ; restoreInflightMessages ( ) ; connected ( ) ; } } else { mex = ExceptionHelper . createMqttException ( rc ) ; throw mex ; } clientComms . connectComplete ( ( MqttConnack ) ack , mex ) ; notifyResult ( ack , token , mex ) ; tokenStore . removeToken ( ack ) ; synchronized ( queueLock ) { queueLock . notifyAll ( ) ; } } else { notifyResult ( ack , token , mex ) ; releaseMessageId ( ack . getMessageId ( ) ) ; tokenStore . removeToken ( ack ) ; } checkQuiesceLock ( ) ; }
tr	0	public double getLatitude ( ) { return latitude ; }
tr	2	public JSONArray ( Collection copyFrom ) { this ( ) ; if ( copyFrom != null ) { for ( Iterator it = copyFrom . iterator ( ) ; it . hasNext ( ) ; ) { put ( JSONObject . wrap ( it . next ( ) ) ) ; } } }
tr	9	public static ArrayList < ArrayList < Integer >> fourSum ( int [ ] num , int target ) { ArrayList < ArrayList < Integer >> result = new ArrayList < ArrayList < Integer >> ( ) ; Arrays . sort ( num ) ; for ( int i = 0 ; i <= num . length - 4 ; i ++ ) { if ( i > 0 && num [ i ] == num [ i - 1 ] ) continue ; for ( int j = i + 1 ; j <= num . length - 3 ; j ++ ) { if ( j > i + 1 && num [ j ] == num [ j - 1 ] ) continue ; int l = j + 1 ; int r = num . length - 1 ; while ( l < r ) { int sum = num [ i ] + num [ j ] + num [ l ] + num [ r ] - target ; if ( sum > 0 ) { r -- ; } else if ( sum < 0 ) { l ++ ; } else { ArrayList < Integer > newList = new ArrayList < Integer > ( ) ; newList . add ( num [ i ] ) ; newList . add ( num [ j ] ) ; newList . add ( num [ l ] ) ; newList . add ( num [ r ] ) ; result . add ( newList ) ; l ++ ; r -- ; while ( l < r && num [ l ] == num [ l - 1 ] ) { l ++ ; } while ( l < r && num [ r ] == num [ r + 1 ] ) { r -- ; } } } } } return result ; }
tr	6	@ Override public boolean preHandle ( HttpServletRequest request , HttpServletResponse response , Object handler ) throws Exception { String uri = request . getRequestURI ( ) ; if ( ! uri . endsWith ( "index.htm" ) && ! uri . endsWith ( "login.htm" ) && ! uri . endsWith ( "logout.htm" ) ) { Login userData = ( Login ) request . getSession ( ) . getAttribute ( Login . class . getName ( ) ) ; if ( userData == null || Util . nullOrEmptyOrBlank ( userData . getEmail ( ) ) || ( new Date ( ) . getTime ( ) - userData . getLastAccessed ( ) ) > 30 * 60 * 1000 ) { response . sendRedirect ( "index.htm" ) ; return false ; } else { userData . setLastAccessed ( new Date ( ) . getTime ( ) ) ; } } return true ; }
tr	4	@ Override public void readInternal ( Environment env ) throws IOException , TypeException { readChar ( env ) ; if ( ! ( env . peek ( ) instanceof VChar ) ) { return ; } int ch = ( ( VChar ) env . peek ( ) ) . getChar ( ) ; if ( ch == - 1 ) { env . pop ( ) ; env . pushReader ( "terminator" ) ; env . pushOp ( "read" ) ; return ; } IValue v = env . getBoundObject ( Character . toString ( ( char ) ch ) ) ; if ( v instanceof Quoted ) { env . pop ( ) ; readInternal ( env ) ; } else { env . pushReader ( "symbol" ) ; env . pushOp ( "read" ) ; } env . evaluateStack ( ) ; if ( ! env . isStackEmpty ( ) ) { env . pushOp ( "quote" ) ; } }
tr	5	private boolean isBST ( Node < T > node ) { if ( node == null ) { return true ; } if ( node . left != null ) { if ( ! isBSTMax ( node . left , node . data ) ) { return false ; } } if ( node . right != null ) { if ( ! isBSTMin ( node . right , node . data ) ) { return false ; } } return true ; }
tr	5	private void isaac ( ) { lastResult += ++ counter ; for ( int i = 0 ; i < 256 ; i ++ ) { int j = memory [ i ] ; if ( ( i & 3 ) == 0 ) accumulator ^= accumulator << 13 ; else if ( ( i & 3 ) == 1 ) accumulator ^= accumulator >>> 6 ; else if ( ( i & 3 ) == 2 ) accumulator ^= accumulator << 2 ; else if ( ( i & 3 ) == 3 ) accumulator ^= accumulator >>> 16 ; accumulator += memory [ i + 128 & ff ] ; int k ; memory [ i ] = k = memory [ ( j & 3fc ) >> 2 ] + accumulator + lastResult ; results [ i ] = lastResult = memory [ ( k >> 8 & 3fc ) >> 2 ] + j ; } }
tr	9	public String fillStaffInfo ( String staffPos ) { DB . db . openConnection ( ) ; ResultSet rs = DB . db . staff ( ) ; StringBuffer info = new StringBuffer ( ) ; try { info . append ( "<table>" ) ; while ( rs . next ( ) ) { ResultSet res = DB . db . position ( rs . getInt ( "posid" ) ) ; while ( res . next ( ) ) { if ( res . getString ( "posdesc" ) . equalsIgnoreCase ( staffPos ) ) { if ( staffPos . equalsIgnoreCase ( "gp" ) ) { info . append ( "<tr><td>Dr. <b>" ) ; } else if ( staffPos . equalsIgnoreCase ( "ns" ) ) { info . append ( "<tr><td>R.N. <b>" ) ; } else if ( staffPos . equalsIgnoreCase ( "ma" ) ) { info . append ( "<tr><td>Med.As. <b>" ) ; } info . append ( rs . getString ( "lname" ) ) ; info . append ( "  " + rs . getString ( "fname" ) ) ; info . append ( "</b></td></tr>" ) ; info . append ( "<tr><td>Phone: <b>" ) ; info . append ( rs . getString ( "phone" ) + "</b></td></tr>" ) ; ResultSet ress = DB . db . qualification ( rs . getInt ( "qualid" ) ) ; while ( ress . next ( ) ) { info . append ( "<tr><td>Qualification: <b>" ) ; info . append ( ress . getString ( "qualdesc" ) + "</b></td></tr>" ) ; } ResultSet rss = DB . db . staffSchedule ( rs . getInt ( "id" ) ) ; while ( rss . next ( ) ) { ress = DB . db . hospital ( rss . getInt ( "hospid" ) ) ; while ( ress . next ( ) ) { info . append ( "<tr><td>Hospital: <b>" ) ; info . append ( ress . getString ( "name" ) + "</b></td></tr>" ) ; } } info . append ( "<tr></tr>" ) ; } } } info . append ( "</table>" ) ; DB . db . close ( ) ; } catch ( SQLException ex ) { Logger . getLogger ( StartMedOfficer . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; DB . db . close ( ) ; } return info . toString ( ) ; }
tr	8	public void init ( ) { if ( el . winwidth == 0 ) { el . winwidth = getWidth ( ) ; el . winheight = getHeight ( ) ; } initCanvas ( ) ; if ( ! el . view_initialised ) { exitEngine ( "Canvas settings not initialised  use setCanvasSettings()." ) ; } if ( ! i_am_applet ) { jre . createWindow ( this , jre . win_decoration ) ; } canvas = new JGCanvas ( el . winwidth , el . winheight ) ; jre . canvas = canvas ; el . initPF ( ) ; jre . clearKeymap ( ) ; canvas . addMouseListener ( jre ) ; canvas . addMouseMotionListener ( jre ) ; canvas . addFocusListener ( jre ) ; canvas . setBackground ( getAWTColor ( el . bg_color ) ) ; if ( jre . my_win != null ) jre . my_win . setBackground ( getAWTColor ( el . bg_color ) ) ; el . msg_font = new JGFont ( "Helvetica" , 0 , ( int ) ( 16.0 / ( 640.0 / ( el . tilex * el . nrtilesx ) ) ) ) ; setLayout ( new FlowLayout ( FlowLayout . LEADING , 0 , 0 ) ) ; add ( canvas ) ; if ( ! JGObject . setEngine ( this ) ) { canvas . setInitPainter ( new ListCellRenderer ( ) { public Component getListCellRendererComponent ( JList d1 , Object value , int d2 , boolean initialise , boolean d4 ) { Graphics g = ( Graphics ) value ; setFont ( g , el . msg_font ) ; setColor ( g , el . fg_color ) ; drawString ( g , "JGame is already running in this VM" , el . viewWidth ( ) / 2 , el . viewHeight ( ) / 3 , 0 , false ) ; return null ; } } ) ; return ; } el . is_inited = true ; canvas . setInitPainter ( new ListCellRenderer ( ) { public Component getListCellRendererComponent ( JList d1 , Object value , int d2 , boolean initialise , boolean d4 ) { Graphics g = ( Graphics ) value ; setFont ( g , el . msg_font ) ; setColor ( g , el . fg_color ) ; JGImage splash = el . existsImage ( "splash_image" ) ? el . getImage ( "splash_image" ) : null ; if ( splash != null ) { JGPoint splash_size = getImageSize ( "splash_image" ) ; drawImage ( g , viewWidth ( ) / 2 - splash_size . x / 2 , viewHeight ( ) / 4 - splash_size . y / 2 , "splash_image" , false ) ; } drawString ( g , canvas . progress_message , viewWidth ( ) / 2 , viewHeight ( ) / 2 , 0 , false ) ; setColor ( g , el . bg_color ) ; drawRect ( g , ( int ) ( viewWidth ( ) * ( 0.1 + 0.8 * canvas . progress_bar ) ) , ( int ) ( viewHeight ( ) * 0.6 ) , ( int ) ( viewWidth ( ) * 0.8 * ( 1.0 - canvas . progress_bar ) ) , ( int ) ( viewHeight ( ) * 0.05 ) , true , false , false ) ; setColor ( g , el . fg_color ) ; drawRect ( g , ( int ) ( viewWidth ( ) * 0.1 ) , ( int ) ( viewHeight ( ) * 0.6 ) , ( int ) ( viewWidth ( ) * 0.8 * canvas . progress_bar ) , ( int ) ( viewHeight ( ) * 0.05 ) , true , false , false ) ; drawRect ( g , ( int ) ( viewWidth ( ) * 0.1 ) , ( int ) ( viewHeight ( ) * 0.6 ) , ( int ) ( viewWidth ( ) * 0.8 ) , ( int ) ( viewHeight ( ) * 0.008 ) , true , false , false ) ; drawRect ( g , ( int ) ( viewWidth ( ) * 0.1 ) , ( int ) ( viewHeight ( ) * ( 0.6 + 0.046 ) ) , ( int ) ( viewWidth ( ) * 0.8 ) , ( int ) ( viewHeight ( ) * 0.008 ) , true , false , false ) ; drawString ( g , canvas . author_message , viewWidth ( ) - 16 , viewHeight ( ) - getFontHeight ( g , el . msg_font ) - 10 , 1 , false ) ; return null ; } } ) ; if ( jre . my_win != null ) { jre . my_win . setVisible ( true ) ; jre . my_win . validate ( ) ; jre . setWindowSize ( jre . win_decoration ) ; } canvas . addKeyListener ( jre ) ; canvas . requestFocus ( ) ; thread = new Thread ( new JGEngineThread ( ) ) ; thread . start ( ) ; }
tr	7	private final boolean cons ( int i ) { switch ( b [ i ] ) { case a : case e : case i : case o : case u : return false ; case y : return ( i == 0 ) ? true : ! cons ( i - 1 ) ; default : return true ; } }
tr	1	private Invite [ ] fetchMultiResults ( ResultSet rs ) throws SQLException { Collection resultList = new ArrayList ( ) ; while ( rs . next ( ) ) { Invite dto = new Invite ( ) ; populateDto ( dto , rs ) ; resultList . add ( dto ) ; } Invite ret [ ] = new Invite [ resultList . size ( ) ] ; resultList . toArray ( ret ) ; return ret ; }
tr	6	public void clearPhraseFromScreen ( String phrase ) { if ( savedUpdater != null ) { updater . clear ( ) ; updater = savedUpdater ; savedUpdater . toggleSearch ( ) ; updater . restore ( ) ; savedUpdater = null ; blobIndex = 0 ; this . highlightBlob ( ) ; } if ( phrase != null && ! phrase . equals ( "" ) ) { updater . clear ( ) ; this . savedUpdater = updater ; this . updater = new BlobScreenUpdater ( pane , this ) ; new Thread ( updater ) . start ( ) ; Iterator < TextBlob > it = savedUpdater . iterator ( ) ; while ( it . hasNext ( ) ) { TextBlob blob = it . next ( ) ; String uContents = blob . getMsg ( ) . contents ( ) . toUpperCase ( ) ; String uPhrase = phrase . toUpperCase ( ) ; if ( blob . getMsg ( ) . contents ( ) . toUpperCase ( ) . contains ( phrase . toUpperCase ( ) ) ) { if ( blob . getMsg ( ) instanceof HttpRequest ) { HttpRequest req = ( ( HttpRequest ) blob . getMsg ( ) ) ; addMessage ( req . getURL ( ) + "\n" , req , "\n" ) ; add ( ( ( HttpRequest ) blob . getMsg ( ) ) . getResponse ( ) , "\n\n" ) ; } else { HttpRequest req = ( ( HttpResponse ) blob . getMsg ( ) ) . getRequest ( ) ; String url = req . getURL ( ) ; addMessage ( url + "\n" , req , "\n" ) ; add ( blob . getMsg ( ) , "\n\n" ) ; } } } savedUpdater . toggleSearch ( ) ; blobIndex = 0 ; highlightBlob ( ) ; } }
tr	3	public ArrayList < String > letterCombine ( String digits , int idx ) { ArrayList < String > sList = new ArrayList < String > ( ) ; if ( digits . length ( ) <= idx ) { sList . add ( digits ) ; return sList ; } StringBuilder SB = new StringBuilder ( digits ) ; Character c = digits . charAt ( idx ) ; int num = Character . getNumericValue ( c ) ; if ( digitNum . containsKey ( num ) ) { for ( Character cc : digitNum . get ( new Integer ( num ) ) ) { SB . setCharAt ( idx , cc ) ; sList . addAll ( letterCombine ( SB . toString ( ) , idx + 1 ) ) ; } } else { return letterCombine ( digits , idx + 1 ) ; } return sList ; }
tr	5	void draw ( Graphics g ) { if ( ! knowSize ) { knowSize = true ; calcRects ( ) ; ( ( Input ) inputs . firstElement ( ) ) . move ( 0 , 0 ) ; } g . setColor ( selected ? selectedBgColor : bgColor ) ; g . fillOval ( topLeft . x , topLeft . y , wholeDiameter , wholeDiameter ) ; g . setColor ( selected ? selectedHiColor : hiColor ) ; g . drawArc ( topLeft . x , topLeft . y , wholeDiameter , wholeDiameter , 45 , 180 ) ; g . setColor ( selected ? selectedShadeColor : shadeColor ) ; g . drawArc ( topLeft . x , topLeft . y , wholeDiameter , wholeDiameter , 225 , 180 ) ; g . setColor ( selected ? selectedFgColor : fgColor ) ; g . drawLine ( centerPoint . x , centerPoint . y - plusSize , centerPoint . x , centerPoint . y + plusSize + 1 ) ; g . drawLine ( centerPoint . x + 1 , centerPoint . y - plusSize , centerPoint . x + 1 , centerPoint . y + plusSize + 1 ) ; g . drawLine ( centerPoint . x - plusSize , centerPoint . y , centerPoint . x + plusSize + 1 , centerPoint . y ) ; g . drawLine ( centerPoint . x - plusSize , centerPoint . y + 1 , centerPoint . x + plusSize + 1 , centerPoint . y + 1 ) ; }
tr	8	private void findCodelOnEdge ( CodelArea area ) { DirectionPointer directionPointer = mMachine . getDirectionPointer ( ) ; CodelChoser codelChoser = mMachine . getCodelChoser ( ) ; boolean isLeft = codelChoser . isLeft ( ) ; if ( directionPointer . isRight ( ) ) { if ( isLeft ) { mEdgeCodel . set ( area . maxXMinY ( ) ) ; } else { mEdgeCodel . set ( area . maxXMaxY ( ) ) ; } } else if ( directionPointer . isBottom ( ) ) { if ( isLeft ) { mEdgeCodel . set ( area . maxYMaxX ( ) ) ; } else { mEdgeCodel . set ( area . maxYMinX ( ) ) ; } } else if ( directionPointer . isLeft ( ) ) { if ( isLeft ) { mEdgeCodel . set ( area . minXMaxY ( ) ) ; } else { mEdgeCodel . set ( area . minXMinY ( ) ) ; } } else if ( directionPointer . isTop ( ) ) { if ( isLeft ) { mEdgeCodel . set ( area . minYMinX ( ) ) ; } else { mEdgeCodel . set ( area . minYMaxX ( ) ) ; } } }
tr	2	public void setThresholds ( List < U > thresholds ) throws Exception { if ( thresholds . size ( ) != neurons . size ( ) ) { throw new Exception ( "threshold count doesnt match neuron count in this layer" ) ; } for ( int i = 0 ; i < neurons . size ( ) ; i ++ ) { neurons . get ( i ) . setThreshold ( thresholds . get ( i ) ) ; } }
tr	8	public static BufferedImage generatePicture ( BufferedImage image , double mean , double variance ) { int w = image . getWidth ( ) ; int h = image . getHeight ( ) ; BufferedImage result = new BufferedImage ( w , h , BufferedImage . TYPE_INT_RGB ) ; for ( int x = 0 ; x < w ; ++ x ) for ( int y = 0 ; y < h ; ++ y ) { int rgb = image . getRGB ( x , y ) ; float red = new Color ( rgb ) . getRed ( ) ; float green = new Color ( rgb ) . getGreen ( ) ; float blue = new Color ( rgb ) . getBlue ( ) ; int noise = ( int ) randomGaussian . getGaussian ( mean , variance ) ; red += noise ; green += noise ; blue += noise ; if ( red > 255 ) { red = 255 ; } else if ( red < 0 ) { red = 0 ; } if ( green > 255 ) { green = 255 ; } else if ( green < 0 ) { green = 0 ; } if ( blue > 255 ) { blue = 255 ; } else if ( blue < 0 ) { blue = 0 ; } Color resultColor = new Color ( red / 255 , green / 255 , blue / 255 , 1f ) ; result . setRGB ( x , y , resultColor . getRGB ( ) ) ; } return result ; }
tr	4	@ Override public boolean isPossible ( ) { if ( actor . getSpirit ( ) < ( actor . getSkill ( skillId ) . getModel ( ) . getSpirit ( ) ) ) { return false ; } if ( dobj == null ) { return false ; } if ( actor . getItemInSlot ( ITEM_SLOT_RHAND ) . getType ( ) != ITEM_TYPE_CQ_WEAPON ) { return false ; } if ( ! ( dobj instanceof Entity ) ) { return false ; } return true ; }
tr	8	public boolean isInitial ( int c ) { return Character . isLetter ( c ) || c == * || c == / || c == > || c == < || c == = || c == ? || c == ! || c == . ; }
tr	9	public List < Integer > postorderTraversal ( TreeNode root ) { List < Integer > result = new ArrayList < > ( ) ; Stack < TreeNode > stack = new Stack < > ( ) ; if ( root != null ) stack . add ( root ) ; TreeNode prev = null ; while ( ! stack . isEmpty ( ) ) { root = stack . peek ( ) ; if ( prev == null || prev . left == root || prev . right == root ) { if ( root . left != null ) stack . push ( root . left ) ; else if ( root . right != null ) stack . push ( root . right ) ; } else if ( prev == root . left ) { if ( root . right != null ) stack . push ( root . right ) ; } else { result . add ( root . val ) ; stack . pop ( ) ; } prev = root ; } return result ; }
tr	5	public InventoryFrame ( ) { addWindowListener ( new WindowAdapter ( ) { @ Override public void windowClosed ( WindowEvent e ) { GameFrame . activeFrame . activeInventory = null ; } } ) ; setAlwaysOnTop ( true ) ; setTitle ( "Inventory" ) ; setDefaultCloseOperation ( JFrame . DISPOSE_ON_CLOSE ) ; setBounds ( 100 , 100 , 281 , 421 ) ; contentPane = new JPanel ( ) ; contentPane . setBorder ( new EmptyBorder ( 5 , 5 , 5 , 5 ) ) ; contentPane . setLayout ( new BorderLayout ( 0 , 0 ) ) ; setContentPane ( contentPane ) ; JSplitPane splitPane = new JSplitPane ( ) ; splitPane . setResizeWeight ( 1.0 ) ; splitPane . setOrientation ( JSplitPane . VERTICAL_SPLIT ) ; contentPane . add ( splitPane , BorderLayout . CENTER ) ; JPanel panel = new JPanel ( ) ; splitPane . setRightComponent ( panel ) ; useButton = new JButton ( "Use" ) ; useButton . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { ItemStack i = list . getSelectedValue ( ) . i ; if ( i . getItem ( ) . onUsed ( i , GameInstance . getActiveInstance ( ) . getPlayerEntity ( ) ) ) { if ( i . getAmount ( ) == 1 ) { GameInstance . getActiveInstance ( ) . getPlayerEntity ( ) . getInventory ( ) . removeItem ( i ) ; } else { i . setAmount ( i . getAmount ( ) - 1 ) ; } GameFrame . activeFrame . doTurn ( ) ; GameFrame . activeFrame . render ( ) ; } } } ) ; panel . setLayout ( new FlowLayout ( FlowLayout . CENTER , 5 , 5 ) ) ; useButton . setEnabled ( false ) ; panel . add ( useButton ) ; dropButton = new JButton ( "Drop" ) ; dropButton . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { ItemStack i = list . getSelectedValue ( ) . i ; GameInstance . getActiveWorld ( ) . dropItemStack ( i , GameInstance . getActiveInstance ( ) . getPlayerEntity ( ) . getLocation ( ) ) ; GameInstance . getActiveInstance ( ) . getPlayerEntity ( ) . getInventory ( ) . removeItem ( i ) ; GameFrame . activeFrame . doTurn ( ) ; GameFrame . activeFrame . render ( ) ; } } ) ; dropButton . setEnabled ( false ) ; panel . add ( dropButton ) ; identifyButton = new JButton ( "Identify" ) ; identifyButton . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { ItemStack i = list . getSelectedValue ( ) . i ; if ( i . getItem ( ) instanceof ItemIdentifiable ) { ( ( ItemIdentifiable ) i . getItem ( ) ) . tryIdentify ( GameInstance . getActiveInstance ( ) . getPlayerEntity ( ) ) ; GameFrame . activeFrame . doTurn ( ) ; GameFrame . activeFrame . render ( ) ; } else { GameFrame . activeFrame . logMessage ( "That item cannot be identified!" ) ; } } } ) ; identifyButton . setEnabled ( false ) ; panel . add ( identifyButton ) ; JScrollPane scrollPane = new JScrollPane ( ) ; scrollPane . setVerticalScrollBarPolicy ( ScrollPaneConstants . VERTICAL_SCROLLBAR_ALWAYS ) ; splitPane . setLeftComponent ( scrollPane ) ; list = new JList < InventoryItem > ( ) ; list . addListSelectionListener ( new ListSelectionListener ( ) { @ Override public void valueChanged ( ListSelectionEvent e ) { if ( list . getSelectedIndex ( ) == - 1 ) { useButton . setEnabled ( false ) ; dropButton . setEnabled ( false ) ; identifyButton . setEnabled ( false ) ; } else { useButton . setEnabled ( list . getSelectedValue ( ) . i . getItem ( ) . canUse ( list . getSelectedValue ( ) . i , GameInstance . getActiveInstance ( ) . getPlayerEntity ( ) ) ) ; dropButton . setEnabled ( true ) ; identifyButton . setEnabled ( list . getSelectedValue ( ) . i . getItem ( ) instanceof ItemIdentifiable && ! GameInstance . getActiveInstance ( ) . isItemIdentified ( list . getSelectedValue ( ) . i . getItem ( ) ) ) ; } } } ) ; scrollPane . setViewportView ( list ) ; doUpdate ( ) ; }
tr	7	public void print ( GroupedWriter fout ) { super . print ( fout ) ; label . print ( fout ) ; fout . print ( "coord " ) ; fout . printlnGroup ( x + " " + y ) ; if ( halign != GraphicsUtil . H_LEFT ) { fout . print ( "halign" ) ; switch ( halign ) { case GraphicsUtil . H_RIGHT : fout . printlnGroup ( "right" ) ; break ; case GraphicsUtil . H_CENTER : fout . printlnGroup ( "center" ) ; break ; default : fout . printlnGroup ( "??" ) ; } } if ( valign != GraphicsUtil . V_BASELINE ) { fout . print ( "valign" ) ; switch ( halign ) { case GraphicsUtil . V_BOTTOM : fout . printlnGroup ( "bottom" ) ; break ; case GraphicsUtil . V_CENTER : fout . printlnGroup ( "center" ) ; break ; case GraphicsUtil . V_TOP : fout . printlnGroup ( "top" ) ; break ; default : fout . printlnGroup ( "??" ) ; } } }
tr	7	public Object getServiceObject ( IMyxName arg0 ) { if ( arg0 . equals ( msg_IChat ) ) { return this ; } if ( arg0 . equals ( msg_IHistoryRetrive ) ) { return this ; } if ( arg0 . equals ( msg_ISendFileListener ) ) { return this ; } if ( arg0 . equals ( msg_ISendImage ) ) { return this ; } if ( arg0 . equals ( msg_IGame ) ) { return this ; } if ( arg0 . equals ( msg_ISendTemplet ) ) { return this ; } if ( arg0 . equals ( msg_IToolBar ) ) { return this ; } return null ; }
tr	3	@ Override public void update ( double dt ) { try { integrate ( dt ) ; if ( isNavigating ( ) ) { if ( Point . distance ( x , y , waypointW . getX ( ) , waypointW . getY ( ) ) < dt * max_speed ) { nextWaypoint ( ) ; } } } catch ( Exception e ) { e . printStackTrace ( ) ; } }
tr	0	public static Manifold getManifold ( StaticBody a , StaticBody b ) { MANIFOLD . reset ( a , b ) ; return manifolds . get ( MANIFOLD ) ; }
tr	7	private void clear ( ) { if ( zooKeeper != null ) { if ( leaderOffer != null && zooKeeper . getState ( ) . isAlive ( ) ) { try { zooKeeper . delete ( leaderOffer . getOffer ( ) , - 1 ) ; LOG . debug ( "Removed leader candidate {}" , leaderOffer ) ; } catch ( InterruptedException e ) { failed ( e ) ; } catch ( KeeperException e ) { failed ( e ) ; } if ( leaderElectionAware != null ) { leaderElectionAware . onClosed ( leaderOffer ) ; } leaderOffer = null ; } try { zooKeeper . close ( ) ; } catch ( InterruptedException e ) { failed ( e ) ; } finally { zooKeeper = null ; } } }
tr	5	public Team createBot ( ) { Logger . log ( "Creating Bot." , Logger . GAME ) ; int registeredClients = clientsAtServer . size ( ) ; TestClient tc = new TestClient ( getPort ( ) , "bottt" ) ; tc . start ( ) ; while ( clientsAtServer . size ( ) == registeredClients ) { try { sleep ( 5 ) ; } catch ( InterruptedException ie ) { ie . printStackTrace ( ) ; } } while ( true ) { for ( Team team : clientsAtServer ) { if ( team . getName ( ) . equals ( "bottt" ) ) { team . setOnline ( false ) ; Communication . sendMsg ( team , Communication . GAMEOVER ) ; return team ; } } } }
tr	7	public static String doubleToString ( double d ) { if ( double . isInfinite ( d ) || double . isNaN ( d ) ) { return "null" ; } String string = double . toString ( d ) ; if ( string . indexOf ( . ) > 0 && string . indexOf ( e ) < 0 && string . indexOf ( E ) < 0 ) { while ( string . endsWith ( "0" ) ) { string = string . substring ( 0 , string . length ( ) - 1 ) ; } if ( string . endsWith ( "." ) ) { string = string . substring ( 0 , string . length ( ) - 1 ) ; } } return string ; }
tr	4	public void selectSort ( int [ ] data ) { if ( data == null ) { throw new NullPointerException ( "Input array is null." ) ; } for ( int i = 0 ; i < data . length ; i ++ ) { int small = i , tmp ; for ( int j = i + 1 ; j < data . length ; j ++ ) { if ( data [ small ] > data [ j ] ) { small = j ; } } tmp = data [ i ] ; data [ i ] = data [ small ] ; data [ small ] = tmp ; } }
tr	7	private BufferedImage createCanvas ( ) { _editor . importFromLogic ( _logic ) ; readyImageNode ( ) ; Dimension s = this . getSize ( ) ; int w = ( s . width < _logic . getCanvasWidth ( ) ? _logic . getCanvasWidth ( ) : s . width ) ; int h = ( s . height < _logic . getCanvasHeight ( ) ? _logic . getCanvasHeight ( ) : s . height ) ; this . setPreferredSize ( new Dimension ( w , h ) ) ; _canvasBackground = new BufferedImage ( _logic . getCanvasWidth ( ) , _logic . getCanvasHeight ( ) , BufferedImage . TYPE_INT_RGB ) ; Graphics2D g2d = _canvasBackground . createGraphics ( ) ; _canvasBackground = g2d . getDeviceConfiguration ( ) . createCompatibleImage ( _logic . getCanvasWidth ( ) , _logic . getCanvasHeight ( ) , Transparency . TRANSLUCENT ) ; g2d . dispose ( ) ; g2d = _canvasBackground . createGraphics ( ) ; for ( int i = 0 ; i < _imageList . size ( ) ; i ++ ) { IPLNode < Image > node = _imageList . get ( i ) ; if ( node . getX ( ) >= 0 && node . getY ( ) >= 0 ) { g2d . drawImage ( node . getData ( ) , node . getX ( ) , node . getY ( ) , node . getScaleWidth ( ) , node . getScaleHeight ( ) , this ) ; } } if ( _isToSave == false && _logic . getCanvasCheckerbard ( ) ) { drawCheckerboard ( g2d ) ; } g2d . dispose ( ) ; return _canvasBackground ; }
tr	9	String readLine ( boolean ignoreLF ) throws IOException { StringBuffer s = null ; int startChar ; synchronized ( lock ) { ensureOpen ( ) ; boolean omitLF = ignoreLF || skipLF ; bufferLoop : for ( ; ; ) { if ( nextChar >= nChars ) fill ( ) ; if ( nextChar >= nChars ) { if ( s != null && s . length ( ) > 0 ) return s . toString ( ) ; else return null ; } boolean eol = false ; char c = 0 ; int i ; if ( omitLF && ( cb [ nextChar ] == '' ) ) nextChar ++ ; skipLF = false ; omitLF = false ; charLoop : for ( i = nextChar ; i < nChars ; i ++ ) { c = cb [ i ] ; if ( ( c == '' ) || ( c == '' ) ) { eol = true ; break charLoop ; } } startChar = nextChar ; nextChar = i ; if ( eol ) { String str ; if ( s == null ) { str = new String ( cb , startChar , i - startChar ) ; } else { s . append ( cb , startChar , i - startChar ) ; str = s . toString ( ) ; } nextChar ++ ; if ( c == '' ) { skipLF = true ; } return str ; } if ( s == null ) s = new StringBuffer ( defaultExpectedLineLength ) ; s . append ( cb , startChar , i - startChar ) ; } } }
tr	1	public int [ ] getAction_Per_State_As_Array ( ) { int ret [ ] = new int [ noOfStates ] ; for ( int i = 0 ; i < noOfStates ; i ++ ) { ret [ i ] = action_Per_State . get ( i ) ; } return ret ; }
tr	1	public static GTHome getHome ( ) { if ( home == null ) home = new GTHomeImpl ( ) ; return home ; }
tr	1	public ReportForm ( java . awt . Frame parent , boolean modal , Date df , Date dt , String un , String su ) { super ( parent , modal ) ; dateFrom = df ; dateTo = dt ; unit = un ; subunit = su ; initComponents ( ) ; if ( ! Beans . isDesignTime ( ) ) { entityManager . getTransaction ( ) . begin ( ) ; } masterTable . getColumnModel ( ) . getColumn ( 5 ) . setCellRenderer ( new TableCellRenderDate ( ) ) ; masterTable . getColumnModel ( ) . getColumn ( 6 ) . setCellRenderer ( new TableCellRenderTime ( ) ) ; masterTable . setAutoResizeMode ( JTable . AUTO_RESIZE_OFF ) ; TableColumnAdjuster tca = new TableColumnAdjuster ( masterTable ) ; tca . adjustColumns ( ) ; DefaultTableCellRenderer dtcr = new DefaultTableCellRenderer ( ) ; dtcr . setHorizontalAlignment ( SwingConstants . CENTER ) ; masterTable . getColumnModel ( ) . getColumn ( 0 ) . setCellRenderer ( dtcr ) ; masterTable . getColumnModel ( ) . getColumn ( 1 ) . setCellRenderer ( dtcr ) ; masterTable . getColumnModel ( ) . getColumn ( 4 ) . setCellRenderer ( dtcr ) ; masterTable . getColumnModel ( ) . getColumn ( 7 ) . setCellRenderer ( dtcr ) ; }
tr	8	public void plug ( Context plug ) { context = plug ; config = plug . getConfigurator ( ) ; shell = plug . getShell ( ) ; prompt = plug . getPrompt ( ) ; input = ( input = ( InputStream ) context . getValue ( Context . KEY_INPUT_STREAM ) ) != null ? input : System . in ; output = ( output = ( OutputStream ) context . getValue ( Context . KEY_OUTPUT_STREAM ) ) != null ? output : System . out ; inputHints = new HashMap < String , String [ ] > ( ) ; try { console = new ConsoleReader ( input , new OutputStreamWriter ( output ) ) ; } catch ( IOException ex ) { throw new RuntimeException ( "Unable to initialize the console. " + " Program will stop now." , ex ) ; } controllers = plug . getPluginsByType ( InputController . class ) ; if ( controllers . size ( ) > 0 ) { for ( InputController ctrl : controllers ) { ctrl . plug ( plug ) ; } aggregateExpectedInputs ( ) ; console . setCompletionHandler ( new CandidateListCompletionHandler ( ) ) ; } else { throw new RuntimeException ( "Unable to initialize Clamshell-Cli. " + " No InputController instances found on classpath. Exiting..." ) ; } List < SplashScreen > screens = plug . getPluginsByType ( SplashScreen . class ) ; if ( screens != null && screens . size ( ) > 0 ) { for ( SplashScreen sc : screens ) { sc . plug ( plug ) ; sc . render ( plug ) ; } } consoleThread = createConsoleThread ( ) ; consoleThread . start ( ) ; }
tr	1	@ Override public void visit ( VariableDeclaration node ) { Type symbolType = node . symbol ( ) . getType ( ) ; if ( ! symbolType . isPrimitive ( ) ) reportError ( node . lineNumber ( ) , node . charPosition ( ) , "Variable " + node . symbol ( ) . getName ( ) + " has invalid type " + symbolType + "." ) ; }
tr	8	private void parseRow ( String [ ] header , String [ ] row , int rowNumber ) throws InvalidInput { if ( ! GenotypeHelper . isGenotype ( row [ 0 ] ) ) throw new NotGenotype ( row [ 0 ] , INPUT_AREA , rowNumber , 1 ) ; if ( ! GenotypeHelper . isGenotype ( row [ 1 ] ) ) throw new NotGenotype ( row [ 1 ] , INPUT_AREA , rowNumber , 2 ) ; String mother , father ; if ( GenotypeHelper . isFemale ( row [ 0 ] ) ) { mother = row [ 0 ] ; if ( ! GenotypeHelper . isMale ( row [ 1 ] ) ) throw new WrongParentsPair ( row [ 0 ] , row [ 1 ] , INPUT_AREA , rowNumber , 1 ) ; father = row [ 1 ] ; } else { father = row [ 0 ] ; if ( ! GenotypeHelper . isFemale ( row [ 1 ] ) ) throw new WrongParentsPair ( row [ 0 ] , row [ 1 ] , INPUT_AREA , rowNumber , 1 ) ; mother = row [ 1 ] ; } Map < String , double > composition = new LinkedHashMap < > ( ) ; for ( int i = 2 ; i < row . length ; i ++ ) { double percentage ; try { percentage = double . parseDouble ( row [ i ] ) ; } catch ( NumberFormatException e ) { throw new NotDouble ( row [ i ] , INPUT_AREA , rowNumber , i + 1 ) ; } if ( percentage > 0.0 ) composition . put ( header [ i ] , percentage ) ; } posterity . addCompositionFor ( mother , father , composition ) ; }
tr	9	private void handlePacket ( Command command ) throws ProtocolException { if ( command . getCommand ( ) . equals ( ClientProtocol . GAME ) ) { String arg0 = command . getArgument ( 0 ) ; int arg1 = Integer . parseInt ( command . getArgument ( 1 ) ) ; int arg2 = Integer . parseInt ( command . getArgument ( 2 ) ) ; if ( games . containsKey ( arg0 ) ) { games . remove ( arg0 ) ; } System . out . println ( arg0 + arg1 + arg2 ) ; games . put ( arg0 , new int [ ] { arg1 , arg2 } ) ; LobbyGUI . lobbyGUI . paintList ( ) ; } else if ( command . getCommand ( ) . equals ( ClientProtocol . JOIN_GAME ) ) { if ( command . getArgument ( 0 ) . equals ( currentGame . getCreator ( ) . getUsername ( ) ) ) { currentGame . addPlayer ( user ) ; } } else if ( command . getCommand ( ) . equals ( ClientProtocol . START ) ) { currentGame = new ServerGame ( new HumanPlayer ( command . getArgument ( 0 ) ) ) ; if ( command . getArgumentCount ( ) >= 2 ) { currentGame . addPlayer ( new HumanPlayer ( command . getArgument ( 1 ) ) ) ; } if ( command . getArgumentCount ( ) >= 3 ) { currentGame . addPlayer ( new HumanPlayer ( command . getArgument ( 2 ) ) ) ; } if ( command . getArgumentCount ( ) == 4 ) { currentGame . addPlayer ( new HumanPlayer ( command . getArgument ( 3 ) ) ) ; } currentGame . start ( ) ; LobbyGUI . lobbyGUI . startGame ( ) ; currentGame . online = true ; currentGame . playerType = LobbyGUI . lobbyGUI . playerType ; int timeLimit ; try { timeLimit = Integer . parseInt ( LobbyGUI . lobbyGUI . textField . getText ( ) ) ; } catch ( NumberFormatException e ) { timeLimit = 0 ; } currentGame . timeLimit = timeLimit ; } else if ( command . getCommand ( ) . equals ( ClientProtocol . MOVE_DONE ) ) { currentGame . turn = false ; int x = Integer . parseInt ( command . getArgument ( 1 ) ) , y = Integer . parseInt ( command . getArgument ( 2 ) ) ; currentGame . doMove ( x , y ) ; } else if ( command . getCommand ( ) . equals ( ClientProtocol . MOVE ) ) { synchronized ( currentGame ) { if ( currentGame . playerType . equals ( "Human" ) ) { currentGame . turn = true ; currentGame . gameGameGUI . paintComponents ( currentGame . board , true ) ; } else { currentGame . turnOnlineAI ( ) ; } } } }
tr	5	public void writeRow ( RowDetails rowDetails ) { Util . checkForNotNull ( rowDetails , "rowDetails" ) ; generateRowData ( rowDetails ) ; DataExporterCallback callback = rowDetails . getTable ( ) . getCallback ( ) ; if ( callback != null ) { callback . beforeRow ( rowDetails ) ; } beforeRow ( rowDetails ) ; for ( int columnIndex = 0 ; columnIndex < rowDetails . getTable ( ) . getColumns ( ) . size ( ) ; columnIndex ++ ) { CellDetails cellDetails = new CellDetails ( rowDetails , columnIndex ) ; cellDetails . setCellValue ( rowDetails . getRow ( ) . getCellValue ( cellDetails ) ) ; cellDetails . setCellValue ( rowDetails . getRow ( ) . getCellValue ( cellDetails ) ) ; if ( callback != null ) { callback . beforeCell ( cellDetails ) ; } beforeRowCell ( cellDetails ) ; writeRowCell ( cellDetails ) ; afterRowCell ( cellDetails ) ; if ( callback != null ) { callback . afterCell ( cellDetails ) ; } } afterRow ( rowDetails ) ; if ( callback != null ) { callback . afterRow ( rowDetails ) ; } }
tr	1	public MerchantDeal getMerchantDeal ( int merchantDealId ) { MerchantDeal merchantDeal = null ; try { session = mySessionFactory . getCurrentSession ( ) ; merchantDeal = ( MerchantDeal ) session . get ( MerchantDeal . class , merchantDealId ) ; } catch ( Exception e ) { } return merchantDeal ; }
tr	2	public static int getStats ( ) { if ( found == 0 || all == 0 ) return 0 ; int stats = ( int ) ( ( 100 * found ) / all ) ; return stats ; }
tr	9	public void loadMap ( String filename ) { try { this . maps = new Scanner ( Main . class . getResourceAsStream ( "/ressources/maps/" + filename ) ) ; while ( this . maps . hasNextLine ( ) ) { String text = this . maps . nextLine ( ) ; for ( this . x = 0 ; this . x < text . length ( ) ; this . x ++ ) { this . element = Integer . parseInt ( "" + text . charAt ( this . x ) ) ; if ( this . element == 0 ) { System . out . print ( "0" ) ; } else if ( this . element == 1 ) { this . images = Sprite . load ( "w1.png" , 100 , 100 , BufferedImage . TYPE_INT_RGB ) ; } else if ( this . element == 2 ) { this . images = Sprite . load ( "wall.png" , 100 , 100 , BufferedImage . TYPE_INT_RGB ) ; } else if ( this . element == 3 ) { this . images = Sprite . load ( "bomberman.png" , 55 , 90 , BufferedImage . TYPE_INT_RGB ) ; } else if ( this . element == 4 ) { this . images = Sprite . load ( "finish.png" , 100 , 100 , BufferedImage . TYPE_INT_RGB ) ; } else if ( this . element == 5 ) { } this . draw ( this . g ) ; } this . y ++ ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } }
tr	7	public void createAtom ( ) { int nbSyllabes = rand . nextInt ( 4 ) ; boolean dou = dedouble ( ) ; if ( dou ) { name = name + name . charAt ( name . length ( ) - 1 ) ; createSyllabes ( nbSyllabes ) ; } else { char c = name . charAt ( name . length ( ) - 1 ) ; if ( c == a || c == e || c == i || c == o || c == u || c == y ) { name = name + chooseConsonne ( ) ; createSyllabes ( nbSyllabes ) ; } else { createSyllabes ( nbSyllabes ) ; } } }
