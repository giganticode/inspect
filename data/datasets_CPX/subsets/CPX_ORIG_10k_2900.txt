tr	5	public OtpErlangObject read_compressed ( ) throws OtpErlangDecodeException { final int tag = read1skip_version ( ) ; if ( tag != OtpExternal . compressedTag ) { throw new OtpErlangDecodeException ( "Wrong tag encountered  expected " + OtpExternal . compressedTag + "  got " + tag ) ; } final int size = read4BE ( ) ; final byte [ ] buf = new byte [ size ] ; final java . util . zip . InflaterInputStream is = new java . util . zip . InflaterInputStream ( this , new java . util . zip . Inflater ( ) , size ) ; int curPos = 0 ; try { int curRead ; while ( curPos < size && ( curRead = is . read ( buf , curPos , size - curPos ) ) != - 1 ) { curPos += curRead ; } if ( curPos != size ) { throw new OtpErlangDecodeException ( "Decompression gave " + curPos + " bytes  not " + size ) ; } } catch ( final IOException e ) { throw new OtpErlangDecodeException ( "Cannot read from input stream" ) ; } final OtpInputStream ois = new OtpInputStream ( buf , flags ) ; return ois . read_any ( ) ; }
tr	6	private static int modifyCForward ( int c , int largest , int positionMsd ) { int foundLargestIndex = - 1 ; int positionLsd = 0 ; while ( positionLsd < positionMsd && c > 0 ) { if ( ( c % 10 > largest ) ) { c = swapDigit ( c , positionLsd , positionMsd ) ; return c ; } if ( foundLargestIndex == - 1 && c % 10 == largest ) { foundLargestIndex = positionLsd ; } c = c / 10 ; positionLsd ++ ; } if ( foundLargestIndex != - 1 ) { c = swapDigit ( c , positionMsd , foundLargestIndex ) ; return c ; } else { return - 1 ; } }
tr	9	public final JPoclASTParser . functionCall_return functionCall ( ) throws RecognitionException { JPoclASTParser . functionCall_return retval = new JPoclASTParser . functionCall_return ( ) ; retval . start = input . < ( 1 ) ; TypeTree root_0 = null ; Token ID106 = null ; Token char_literal107 = null ; Token char_literal109 = null ; Token DOT110 = null ; JPoclASTParser . parameters_return parameters108 = null ; JPoclASTParser . qualifiedID_return qualifiedID111 = null ; TypeTree ID106_tree = null ; TypeTree char_literal107_tree = null ; TypeTree char_literal109_tree = null ; TypeTree DOT110_tree = null ; RewriteRuleTokenStream stream_ID = new RewriteRuleTokenStream ( adaptor , "token ID" ) ; RewriteRuleTokenStream stream_DOT = new RewriteRuleTokenStream ( adaptor , "token DOT" ) ; RewriteRuleTokenStream stream_24 = new RewriteRuleTokenStream ( adaptor , "token 24" ) ; RewriteRuleTokenStream stream_25 = new RewriteRuleTokenStream ( adaptor , "token 25" ) ; RewriteRuleSubtreeStream stream_qualifiedID = new RewriteRuleSubtreeStream ( adaptor , "rule qualifiedID" ) ; RewriteRuleSubtreeStream stream_parameters = new RewriteRuleSubtreeStream ( adaptor , "rule parameters" ) ; try { { { ID106 = ( Token ) match ( input , ID , FOLLOW_ID_in_functionCall1091 ) ; stream_ID . add ( ID106 ) ; char_literal107 = ( Token ) match ( input , 24 , FOLLOW_24_in_functionCall1092 ) ; stream_24 . add ( char_literal107 ) ; int alt24 = 2 ; int LA24_0 = input . LA ( 1 ) ; if ( ( LA24_0 == boolean || ( LA24_0 >= ID && LA24_0 <= int ) || LA24_0 == 24 || LA24_0 == 27 || LA24_0 == 29 || LA24_0 == 43 || LA24_0 == 49 ) ) { alt24 = 1 ; } switch ( alt24 ) { case 1 : { pushFollow ( FOLLOW_parameters_in_functionCall1094 ) ; parameters108 = parameters ( ) ; state . _fsp -- ; stream_parameters . add ( parameters108 . getTree ( ) ) ; } break ; } char_literal109 = ( Token ) match ( input , 25 , FOLLOW_25_in_functionCall1097 ) ; stream_25 . add ( char_literal109 ) ; retval . tree = root_0 ; RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream ( adaptor , "rule retval" , retval != null ? retval . tree : null ) ; root_0 = ( TypeTree ) adaptor . nil ( ) ; { { TypeTree root_1 = ( TypeTree ) adaptor . nil ( ) ; root_1 = ( TypeTree ) adaptor . becomeRoot ( ( TypeTree ) adaptor . create ( FUNCCALL , "FUNCCALL" ) , root_1 ) ; adaptor . addChild ( root_1 , stream_ID . nextNode ( ) ) ; if ( stream_parameters . hasNext ( ) ) { adaptor . addChild ( root_1 , stream_parameters . nextTree ( ) ) ; } stream_parameters . reset ( ) ; adaptor . addChild ( root_0 , root_1 ) ; } } retval . tree = root_0 ; } int alt25 = 2 ; int LA25_0 = input . LA ( 1 ) ; if ( ( LA25_0 == . ) ) { alt25 = 1 ; } switch ( alt25 ) { case 1 : { DOT110 = ( Token ) match ( input , . , FOLLOW_DOT_in_functionCall1119 ) ; stream_DOT . add ( DOT110 ) ; pushFollow ( FOLLOW_qualifiedID_in_functionCall1121 ) ; qualifiedID111 = qualifiedID ( ) ; state . _fsp -- ; stream_qualifiedID . add ( qualifiedID111 . getTree ( ) ) ; retval . tree = root_0 ; RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream ( adaptor , "rule retval" , retval != null ? retval . tree : null ) ; root_0 = ( TypeTree ) adaptor . nil ( ) ; { { TypeTree root_1 = ( TypeTree ) adaptor . nil ( ) ; root_1 = ( TypeTree ) adaptor . becomeRoot ( stream_DOT . nextNode ( ) , root_1 ) ; adaptor . addChild ( root_1 , stream_retval . nextTree ( ) ) ; adaptor . addChild ( root_1 , stream_qualifiedID . nextTree ( ) ) ; adaptor . addChild ( root_0 , root_1 ) ; } } retval . tree = root_0 ; } break ; } } retval . stop = input . < ( - 1 ) ; retval . tree = ( TypeTree ) adaptor . rulePostProcessing ( root_0 ) ; adaptor . setTokenBoundaries ( retval . tree , retval . start , retval . stop ) ; } catch ( RecognitionException re ) { reportError ( re ) ; } finally { } return retval ; }
tr	4	static void createSwitchMode ( Panel panel , boolean active , boolean currentIsGoDirectly ) { if ( WebContent . onIpad ) { return ; } HTML item = createHtml ( ) ; panel . add ( item ) ; item . setHTML ( currentIsGoDirectly ? RIGHT_TRIANGLE + "Pearl directly" : RIGHT_TRIANGLE + "Go directly to one of your pearltrees" ) ; if ( active ) { item . addClickHandler ( new ClickHandler ( ) { @ Override public void onClick ( ClickEvent event ) { TreeListUI . onSwichModeClicked ( ) ; } } ) ; } item . addStyleDependentName ( active ? STYLE_LINK : STYLE_INACTIVE ) ; setMarginBottom ( item , 10 ) ; }
tr	5	public String getDescription ( ) { if ( kinds . size ( ) == 0 ) return "Gathering resources" ; String result = "Gathering " ; int i = 0 ; for ( Resource res : kinds ) { if ( i == kinds . size ( ) - 1 && i != 0 ) { result += " and " ; } else if ( i != 0 ) { result += "  " ; } result += res . name ; ++ i ; } return result ; }
tr	2	@ Override public void paintComponent ( Graphics g ) { super . paintComponent ( g ) ; for ( int i = 0 ; i < this . drawAreaLayers . size ( ) ; i ++ ) { if ( this . showLayer [ this . drawAreaLayers . size ( ) - 1 - i ] ) { this . draw ( this . drawAreaLayers . size ( ) - 1 - i , g ) ; } } }
tr	8	public ArrayList < Integer > getAdjacentNeurons ( int neuronNumber ) { ArrayList < Integer > connectedNeurons = new ArrayList < Integer > ( ) ; int top = - 1 , left = - 1 , right = - 1 , bottom = - 1 ; if ( ( neuronNumber < colNumber * rowNumber ) && ( neuronNumber >= 0 ) ) { if ( neuronNumber - colNumber >= 0 ) { top = neuronNumber - colNumber ; connectedNeurons . add ( top ) ; } if ( ( neuronNumber - 1 >= 0 ) && ( ( neuronNumber % colNumber ) != 0 ) ) { left = neuronNumber - 1 ; connectedNeurons . add ( left ) ; } if ( ( neuronNumber + 1 < colNumber * rowNumber ) && ( ( ( neuronNumber + 1 ) % colNumber ) != 0 ) ) { right = neuronNumber + 1 ; connectedNeurons . add ( right ) ; } if ( neuronNumber + colNumber < colNumber * rowNumber ) { bottom = neuronNumber + colNumber ; connectedNeurons . add ( bottom ) ; } } return connectedNeurons ; }
tr	7	public static void main ( String [ ] args ) throws Exception { ApplicationContext context = new ClassPathXmlApplicationContext ( "spring-module.xml" ) ; UserService userservice = ( UserService ) context . getBean ( "userServiceBean" ) ; System . out . println ( "-------- --- USER --- ---------" ) ; User user = userservice . findUserByEmailPassword ( "martinpucheu@udec.cl" , "cresposexy" ) ; System . out . println ( "El usuario encontrado tiene como apellido: " + user . getlastName ( ) ) ; MovieService movieService = ( MovieService ) context . getBean ( "movieServiceBean" ) ; Movie m = new Movie ( "American Hustle" , 2013 , "Pel\u00EDcula de esta estafadores" , "David O. Russell" ) ; movieService . insert ( m ) ; System . out . println ( "-------- --- MOVIES --- ---------" ) ; Movie _movie = movieService . findMovieById ( 3 ) ; System . out . println ( "La pel\u00EDcula encontrada es: " + _movie . getName ( ) ) ; System . out . println ( " -.-.-.-" ) ; List < Movie > _movie2 = movieService . findMovieByTitle ( "Twilight" ) ; for ( int i = 0 ; i < _movie2 . size ( ) ; i ++ ) { System . out . println ( "Econtre la pel\u00EDcula que buscabas  es: " + _movie2 . get ( i ) . getName ( ) + " verdad?" ) ; } ActorService actorService = ( ActorService ) context . getBean ( "actorServiceBean" ) ; System . out . println ( "-------- --- ACTOR --- ---------" ) ; Actor _actor = actorService . findActorById ( 1 ) ; System . out . println ( "El actor encontrado es: " + _actor . getName ( ) + " " + _actor . getLName ( ) ) ; ActorService actsService = ( ActorService ) context . getBean ( "actsServiceBean" ) ; System . out . println ( "-------- --- ACTS --- ---------" ) ; List < Acts > _acts = actsService . findActsByMoiveId ( 1 ) ; for ( int i = 0 ; i < _acts . size ( ) ; i ++ ) System . out . println ( "En la pel\u00EDcula de id:1 actua el actor con id:[" + _acts . get ( i ) . getIda ( ) + "]" ) ; MovieService categoryService = ( MovieService ) context . getBean ( "categoryServiceBean" ) ; System . out . println ( "-------- --- CATEGORY --- ---------" ) ; Category _category = categoryService . findCategoryByGenre ( "Thriller" ) ; System . out . println ( "La categoria encontrada fue: " + _category . getGenre ( ) ) ; UserService doeslikeService = ( UserService ) context . getBean ( "doeslikeServiceBean" ) ; System . out . println ( "-------- --- DOESLIKE--- ---------" ) ; List < DoesLike > _doeslike = doeslikeService . findDoesLikeById ( 1 ) ; for ( int i = 0 ; i < _doeslike . size ( ) ; i ++ ) System . out . println ( "Al usuario 1 le gusta el genero: " + _doeslike . get ( i ) . getGenre ( ) ) ; UserService doesnotlikeService = ( UserService ) context . getBean ( "doesnotlikeServiceBean" ) ; System . out . println ( "-------- --- DOESNOTLIKE--- ---------" ) ; List < DoesNotLike > _doesnotlike = doesnotlikeService . findDoesNotLikeById ( 1 ) ; for ( int i = 0 ; i < _doesnotlike . size ( ) ; i ++ ) System . out . println ( "Al usuario 1 no le gusta el genero: " + _doesnotlike . get ( i ) . getGenre ( ) ) ; MovieService idiomService = ( MovieService ) context . getBean ( "idiomServiceBean" ) ; System . out . println ( "-------- --- IDIOM --- ---------" ) ; Idiom _idiom = idiomService . findIdiomByLanguage ( "Espanol" ) ; System . out . println ( "El idioma encontrado es: " + _idiom . getLanguage ( ) ) ; UserService idiompService = ( UserService ) context . getBean ( "idiompServiceBean" ) ; System . out . println ( "-------- --- IDIOMP --- ---------" ) ; List < Idiomp > _idiomp = idiompService . findByUserId ( 3 ) ; for ( int i = 0 ; i < _idiomp . size ( ) ; i ++ ) System . out . println ( "Al usuario 3 le gustan las peliculas en idioma: " + _idiomp . get ( i ) . getLanguage ( ) ) ; MovieService moviecategoryService = ( MovieService ) context . getBean ( "moviecategoryServiceBean" ) ; System . out . println ( "-------- --- MOVIECATEGORY --- ---------" ) ; List < MovieCategory > _moviecategory = moviecategoryService . findMoviesByGendre ( "Thriller" ) ; for ( int i = 0 ; i < _moviecategory . size ( ) ; i ++ ) System . out . println ( "Los ID de las pel\u00EDculas del genero Thriller son: " + _moviecategory . get ( i ) . getIdp ( ) ) ; MovieService ratingService = ( MovieService ) context . getBean ( "ratingServiceBean" ) ; System . out . println ( "-------- --- RATING --- ---------" ) ; Rating _rating = ratingService . findRatingById ( 1 , 1 ) ; System . out . println ( "La calificaci\u00F3n que le dio el usuario 2 a la pel\u00EDcula 3 es: [" + _rating . getMark ( ) + "]" ) ; MovieService speakService = ( MovieService ) context . getBean ( "speakServiceBean" ) ; Speak _speak2 = new Speak ( 2 , "Frances" ) ; System . out . println ( "-------- --- SPEAK --- ---------" ) ; Speak _speak = speakService . findSpeakByIdp ( 4 ) ; System . out . println ( "EL idioma de la pel\u00EDcula 4 es: " + _speak . getLengua ( ) ) ; UserService wishlistService = ( UserService ) context . getBean ( "wishlistServiceBean" ) ; WishList wishlist = new WishList ( 5 , 1 ) ; System . out . println ( "-------- --- WISHLIST --- ---------" ) ; List < WishList > _wishlist = wishlistService . findWishListById ( 1 ) ; for ( int i = 0 ; i < _wishlist . size ( ) ; i ++ ) System . out . println ( "La pel\u00EDcula con id:" + _wishlist . get ( i ) . getIdp ( ) + " est\u00E1 en la Wishlist del usuario 1 " ) ; }
tr	1	@ Override public void actionPerformed ( ActionEvent arg0 ) { try { portGreen [ port - 1 ] . setVisible ( false ) ; m . sendRelayCommand ( port , Relay . PORT_STATE_AUTO ) ; } catch ( Exception e ) { JOptionPane . showMessageDialog ( StatusApp . statusUI , "Error with Refresh" , "Refresh Error" , JOptionPane . INFORMATION_MESSAGE ) ; } }
tr	8	@ Override public void validate ( Object target , Errors errors ) { if ( ! ( target instanceof RegisteredParticipant ) ) { throw new IllegalArgumentException ( "Target should be of RegisteredParticipant type" ) ; } RegisteredParticipant participant = ( RegisteredParticipant ) target ; ValidationUtils . rejectIfEmptyOrWhitespace ( errors , "participant.name" , "participant.name" ) ; ValidationUtils . rejectIfEmptyOrWhitespace ( errors , "participant.foundation" , "participant.foundation" ) ; if ( participant . getParticipant ( ) . isVip ( ) ) { ValidationUtils . rejectIfEmptyOrWhitespace ( errors , "participant.vipDesc" , "participant.vipDesc" ) ; } ValidationUtils . rejectIfEmptyOrWhitespace ( errors , "eventId" , "eventId" ) ; ValidationUtils . rejectIfEmptyOrWhitespace ( errors , "registration.level" , "registration.level" ) ; if ( participant . getRegistration ( ) . getAmountPayable ( ) == null || participant . getRegistration ( ) . getAmountPayable ( ) <= 0 ) { errors . reject ( "registration.amountPayable" , "registration.amountPayable" ) ; } Login login = Util . getCurrentUser ( ) ; if ( login . getAccess ( ) . isRegVolunteer ( ) && ! ( participant . getRegistration ( ) . getTotalAmountPaid ( ) >= participant . getRegistration ( ) . getAmountPayable ( ) ) ) { errors . reject ( "registration.noAccess" , "registration.noAccess" ) ; } if ( participant . getCurrentPayment ( ) != null && participant . getCurrentPayment ( ) . getAmountPaid ( ) != null ) { ValidationUtils . rejectIfEmptyOrWhitespace ( errors , "currentPayment.receiptInfo" , "currentPayment.receiptInfo" ) ; ValidationUtils . rejectIfEmptyOrWhitespace ( errors , "currentPayment.mode" , "currentPayment.mode" ) ; ValidationUtils . rejectIfEmptyOrWhitespace ( errors , "currentPayment.receiptDate" , "currentPayment.receiptDate" ) ; } }
tr	6	@ Override public void run ( ) { while ( ! super . detener ) { try { if ( ! this . guerreroColaAtaques . isEmpty ( ) ) recibirdaño ( ) ; if ( this . objectivo . x == 0 && this . objectivo . y == 0 ) { this . objectivo = getObjectivo ( ) ; playCompleted = false ; } int segundos = 20 * espera ; if ( this . espacio . equals ( this . refLabel . getLocation ( ) ) ) { atacar ( ) ; play ( IMG . getImage ( "contacto.wav" ) ) ; } else { mover ( ) ; } sleep ( segundos ) ; } catch ( InterruptedException ex ) { } } ImageIcon iconLogo ; iconLogo = new ImageIcon ( IMG . getImage ( "blood.png" ) ) ; this . refLabel . setDisabledIcon ( iconLogo ) ; }
tr	5	public void smokeIntoFire ( ) { for ( int x = 0 ; x < getWidth ( ) ; x ++ ) { for ( int y = 0 ; y < getHeight ( ) ; y ++ ) { Point p = new Point ( x , y ) ; ThreatToken t = fireLayer . getTokenAt ( p ) ; if ( t != null && tokenLocs . get ( t ) == null ) { System . out . println ( "Item is in the fire layer but not tokenlocs: " + p ) ; System . out . println ( "FireLayer:\n" + fireLayer ) ; System . out . println ( "TokenLocs:\n" + tokenLocs ) ; } if ( t instanceof FireToken ) { smokeIntoFire ( ( FireToken ) t ) ; } } } }
tr	6	List < Constraint > removePropagateFrom ( Variable out ) { out . determinedBy = null ; out . walkStrength = WEAKEST ; out . stay = true ; List < Constraint > unsatisfied = new ArrayList < Constraint > ( ) ; List < Variable > todo = new ArrayList < Variable > ( ) ; todo . add ( out ) ; while ( todo . size ( ) > 0 ) { Variable v = todo . remove ( todo . size ( ) - 1 ) ; for ( int i = 0 ; i < v . constraints . size ( ) ; i ++ ) { Constraint c = v . constraints . get ( i ) ; if ( ! c . isSatisfied ( ) ) unsatisfied . add ( c ) ; } Constraint determining = v . determinedBy ; for ( int i = 0 ; i < v . constraints . size ( ) ; i ++ ) { Constraint next = v . constraints . get ( i ) ; if ( next != determining && next . isSatisfied ( ) ) { next . recalculate ( ) ; todo . add ( next . output ( ) ) ; } } } return unsatisfied ; }
tr	1	public void openFile ( ) { try { br = new BufferedReader ( new FileReader ( fileName ) ) ; } catch ( Exception e ) { System . out . println ( "Problem occured while opening a file" ) ; System . exit ( 1 ) ; } }
tr	9	public String fwla_to_fsp ( String name ) { if ( name . indexOf ( . ) == - 1 ) throw new java . lang . Error ( "The supplied string apears not to have the form <object>.<event>" ) ; String object = name . substring ( 0 , name . indexOf ( . ) ) ; String event = name . substring ( name . indexOf ( . ) + 1 ) ; String _res = "" ; if ( object == null || object . isEmpty ( ) ) throw new java . lang . Error ( "The supplied string apears not to have the form <object>.<event>" ) ; if ( event == null || event . isEmpty ( ) ) throw new java . lang . Error ( "The supplied string apears not to have the form <object>.<event>" ) ; String _object = null ; if ( elemsMap . containsKey ( object ) ) { _object = elemsMap . get ( object ) ; } else if ( netsMap . containsKey ( object ) ) { _object = netsMap . get ( object ) ; } else { throw new java . lang . Error ( "No name mapping could be found for " + object ) ; } assert ( _object != null ) ; LinkedList < String > _net_prefix = new LinkedList < String > ( ) ; boolean found = find_object ( _object , this . fsp_spec . root ( ) , _net_prefix ) ; assert ( found ) ; for ( String s : _net_prefix ) _res += s + "." ; if ( renamesMap . containsKey ( _object + "." + event ) ) { _res += renamesMap . get ( _object + "." + event ) ; } else { throw new java . lang . Error ( "No name mapping could be found for " + _object + "." + event ) ; } assert ( _res != null ) ; return _res ; }
tr	6	public int ladderLength ( String start , String end , Set < String > dict ) { if ( null == dict || dict . size ( ) == 0 ) { return 0 ; } char [ ] startArr = start . toCharArray ( ) ; List < String > res = new ArrayList < > ( ) ; for ( char i = a ; i < z ; i ++ ) { for ( int j = 0 ; j < startArr . length ; j ++ ) { String temp = start . substring ( 0 , j ) + i + start . substring ( j + 1 ) ; if ( dict . contains ( temp ) ) { res . add ( temp ) ; dict . remove ( temp ) ; } else { continue ; } if ( temp . equals ( end ) ) { return res . size ( ) ; } } } return 0 ; }
tr	6	public static double [ ] getAlleleTotals ( List < Accession > accessions ) { if ( accessions . size ( ) == 0 ) return null ; Accession a1 = accessions . get ( 0 ) ; int alleleCnt = a1 . numSSRAlleles ( ) ; double alleleTotals [ ] = new double [ alleleCnt ] ; for ( int i = 0 ; i < alleleCnt ; i ++ ) { alleleTotals [ i ] = 0.0 ; } for ( Accession a : accessions ) { ListIterator < List < double >> mItr = a . getSSRValues ( ) . listIterator ( ) ; ListIterator < double > aItr = null ; int i = 0 ; while ( mItr . hasNext ( ) ) { aItr = mItr . next ( ) . listIterator ( ) ; while ( aItr . hasNext ( ) ) { double val = aItr . next ( ) ; if ( val != null ) { double v = val . doubleValue ( ) ; alleleTotals [ i ] += v ; } i ++ ; } } } return alleleTotals ; }
tr	5	private boolean getToBoxDesireCompleted ( Agent a ) { for ( dir d : dir . values ( ) ) { if ( a . desire != null && a . desire . goal == null && a . getAtField ( ) . neighbors [ d . ordinal ( ) ] != null && a . getAtField ( ) . neighbors [ d . ordinal ( ) ] . equals ( a . desire . box . getAtField ( ) ) ) return true ; } return false ; }
tr	7	public void remove ( SigDig oldSigDig ) { if ( isEmpty ( ) ) { System . out . println ( "nothing to remove" ) ; } else if ( ( oldSigDig == mostSig ) && ( oldSigDig . next == null ) ) { mostSig = null ; } else if ( ( oldSigDig . previous != null ) && ( oldSigDig . next != null ) ) { oldSigDig . previous . next = oldSigDig . next ; oldSigDig . next . previous = oldSigDig . previous ; } else if ( oldSigDig . previous == mostSig && ( oldSigDig . next != null ) ) { mostSig = mostSig . next ; mostSig . previous = null ; } else { oldSigDig . previous . next = null ; } }
tr	8	private static ArrayList < EncFSFile > getPath ( String path ) throws IOException { ArrayList < EncFSFile > result = new ArrayList < EncFSFile > ( ) ; EncFSFile curFile ; boolean found ; if ( path . equals ( EncFSVolume . ROOT_PATH ) ) { result . add ( volume . getRootDir ( ) ) ; return result ; } if ( path . startsWith ( EncFSVolume . PATH_SEPARATOR ) ) { curFile = volume . getRootDir ( ) ; } else { curFile = curDir ; } StringTokenizer st = new StringTokenizer ( path , EncFSVolume . PATH_SEPARATOR ) ; while ( st . hasMoreTokens ( ) ) { String pathElement = st . nextToken ( ) ; found = false ; if ( curFile . isDirectory ( ) ) { EncFSFile [ ] files = curFile . listFiles ( ) ; for ( EncFSFile file : files ) { if ( file . getName ( ) . equals ( pathElement ) ) { result . add ( file ) ; curFile = file ; found = true ; } } } else { if ( st . hasMoreTokens ( ) ) { throw new FileNotFoundException ( "'" + pathElement + "' is not a directory!" ) ; } else { result . add ( curFile ) ; found = true ; } } if ( ! found ) { throw new FileNotFoundException ( "Path '" + path + "' not found!" ) ; } } return result ; }
tr	2	@ Override public void execute ( HttpServletRequest request , HttpServletResponse response ) throws DAOException { HttpSession session = request . getSession ( ) ; User user = ( User ) session . getAttribute ( ConstantsJSP . USER ) ; Integer dateId = ( Integer ) session . getAttribute ( ConstantsJSP . DATE_ID ) ; if ( user == null || dateId == null ) { throw new DAOException ( Constants . INTERNAL_ERROR ) ; } ITicketDAO ticketDAO = DAOFactory . getDAO ( ITicketDAO . class ) ; ticketDAO . cancelOrder ( dateId , user ) ; request . setAttribute ( ConstantsJSP . TICKETS_SUMMARIES , ticketDAO . getTicketsSummaries ( dateId , user ) ) ; }
tr	8	private final static boolean isVowel ( String in , int at , int length ) { if ( ( at < 0 ) || ( at >= length ) ) return false ; char it = in . charAt ( at ) ; if ( ( it == A ) || ( it == E ) || ( it == I ) || ( it == O ) || ( it == U ) || ( it == Y ) ) return true ; return false ; }
tr	0	public CheckBox getOnsaleCheckbox ( ) { return onsaleCheckbox ; }
tr	0	public MiniGameEventRelayer ( MiniGame initGame ) { game = initGame ; }
tr	6	int pickMonster ( Card [ ] monsters ) { ArrayList < String > opts = new ArrayList < String > ( ) ; for ( int i = 0 ; i < monsters . length ; i ++ ) if ( monsters [ i ] != null ) opts . add ( Strings . tableauStateDungeonRank + " " + i + ": " + monsters [ i ] . getTitle ( ) ) ; Integer i = currentPlayer . selectOption ( Strings . chooseMonster , opts . toArray ( new String [ 0 ] ) ) ; if ( i == null || i . intValue ( ) < 0 || i . intValue ( ) >= monsters . length || monsters [ i . intValue ( ) ] == null ) return 1 ; return i . intValue ( ) ; }
tr	8	public static float nextAfter ( final float f , final double direction ) { if ( double . isNaN ( f ) || double . isNaN ( direction ) ) { return float . NaN ; } else if ( f == direction ) { return ( float ) direction ; } else if ( float . isInfinite ( f ) ) { return ( f < 0f ) ? - float . MAX_VALUE : float . MAX_VALUE ; } else if ( f == 0f ) { return ( direction < 0 ) ? - float . MIN_VALUE : float . MIN_VALUE ; } final int bits = float . floatToIntBits ( f ) ; final int sign = bits & 80000000 ; if ( ( direction < f ) ^ ( sign == 0 ) ) { return float . intBitsToFloat ( sign | ( ( bits & 7fffffff ) + 1 ) ) ; } else { return float . intBitsToFloat ( sign | ( ( bits & 7fffffff ) - 1 ) ) ; } }
tr	4	public int call ( CallFrame frame , int argCount ) { Coroutine coroutine = frame . getArg ( 0 , Coroutine . class ) ; if ( coroutine . isDead ( ) ) throw new LuaException ( "unable to resume a dead coroutine" ) ; coroutine . resume ( frame . coroutine ) ; CallFrame nextFrame = coroutine . getCurrentFrame ( ) ; boolean isFirst = ( nextFrame . argCount == - 1 ) ; if ( isFirst ) nextFrame . setTop ( 0 ) ; for ( int index = 1 ; index < argCount ; index ++ ) nextFrame . push ( frame . get ( index ) ) ; if ( isFirst ) { nextFrame . argCount = argCount - 1 ; nextFrame . init ( ) ; } frame . getThread ( ) . coroutine = coroutine ; return 0 ; }
tr	8	public static void main ( String [ ] args ) throws Exception { Scanner in = new Scanner ( new File ( "d:\\programDATA\\Dancing With the Googlers\\B-small-practice.in" ) ) ; System . setOut ( new PrintStream ( new File ( "d:\\programDATA\\Dancing With the Googlers\\B-small-practice.out" ) ) ) ; int Numcase = in . nextInt ( ) ; for ( int curr = 1 ; curr <= Numcase ; curr ++ ) { in . nextLine ( ) ; int N = in . nextInt ( ) ; int S = in . nextInt ( ) ; int P = in . nextInt ( ) ; int a [ ] = new int [ N ] ; int y = 0 ; int remainder = 0 ; int quotient = 0 ; for ( int i = 0 ; i < a . length ; i ++ ) { a [ i ] = in . nextInt ( ) ; } for ( int i = 0 ; i < a . length ; i ++ ) { quotient = a [ i ] / 3 ; remainder = a [ i ] % 3 ; if ( quotient >= P ) y ++ ; else if ( quotient + 1 == P ) { if ( remainder == 2 ) { } if ( remainder == 1 ) { } if ( remainder == 0 ) { } } } } }
tr	9	private void parseUserAgent ( ) { final String ua = _request . getHeader ( "user-agent" ) . toLowerCase ( ) ; if ( ua != null ) { Matcher m = _rwebkit . matcher ( ua ) ; if ( m . matches ( ) ) { final double version = getVersion ( m ) ; _vars . put ( "webkit" , version ) ; _vars . put ( "safari" , version ) ; return ; } m = _ropera . matcher ( ua ) ; if ( m . matches ( ) ) { _vars . put ( "opera" , getVersion ( m ) ) ; return ; } m = _rmsie . matcher ( ua ) ; if ( m . matches ( ) ) { final double version = getVersion ( m ) ; _vars . put ( "msie" , version ) ; _vars . put ( "ie" , version ) ; return ; } if ( ua . indexOf ( "compatible" ) < 0 ) { m = _rmozilla . matcher ( ua ) ; if ( m . matches ( ) ) { double version = getVersion ( m ) ; if ( version < 5 ) { int j = ua . indexOf ( "firefox/" ) ; if ( j >= 0 ) { int k = ua . indexOf ( . , j += 8 ) ; if ( k >= 0 ) { for ( int len = ua . length ( ) ; ++ k < len ; ) { final char cc = ua . charAt ( k ) ; if ( cc < 0 || cc > 9 ) { break ; } } try { version = double . parseDouble ( ua . substring ( j , k ) ) ; } catch ( Throwable ex ) { } } } } _vars . put ( "mozilla" , version ) ; _vars . put ( "gecko" , version ) ; _vars . put ( "ff" , version ) ; return ; } } } }
tr	2	private void putConcurrentListenableMap ( int numThreads , int max ) throws InterruptedException { CountDownLatch allDone = new CountDownLatch ( numThreads ) ; ListenableConcurrentMap < String , String > map = new ListenableConcurrentHashMap ( ) ; List < Thread > threads = new ArrayList < > ( numThreads ) ; for ( int i = 0 ; i < numThreads ; i ++ ) threads . add ( new Thread ( listenableConcurrentPutBlock ( map , max , allDone ) ) ) ; long start = System . currentTimeMillis ( ) ; for ( int i = 0 ; i < numThreads ; i ++ ) threads . get ( i ) . start ( ) ; allDone . await ( ) ; System . out . println ( "time for " + numThreads + " threads concurrent: " + ( System . currentTimeMillis ( ) - start ) + " ms" ) ; }
tr	2	public void addToKeyedDuration ( Measures measureId , int key , double value ) { if ( ! serverImpl . getProfilingStatus ( ) ) return ; Measure m = measuresMap . get ( measureId ) ; if ( m != null ) { synchronized ( m ) { MKAveragedMeasureArgs args = new MKAveragedMeasureArgs ( ) ; args . value = value ; args . key = key ; m . addObservation ( args ) ; } } }
tr	5	public TrinaryNode insert ( int i ) { if ( i < val ) { if ( left == null ) left = new TrinaryNode ( i ) ; else left . insert ( i ) ; } else if ( i == val ) { if ( center == null ) center = new TrinaryNode ( i ) ; else center . insert ( i ) ; } else { if ( right == null ) right = new TrinaryNode ( i ) ; else right . insert ( i ) ; } return this ; }
tr	3	int [ ] [ ] allRolls ( ) { int [ ] [ ] ret = new int [ 24 ] [ ] ; int i = 0 ; for ( int k = 0 ; k < 6 ; k ++ ) { for ( int j = 0 ; j < 4 ; j ++ ) { ret [ i ++ ] = id . clone ( ) ; rollZ ( ) ; } if ( k % 2 == 1 ) rollY ( ) ; else rollX ( ) ; } return ret ; }
tr	8	@ Override public void actionPerformed ( ActionEvent e ) { String cmd = e . getActionCommand ( ) ; switch ( cmd ) { case FILTRAR : ctrlInformacion . filtrarContratos ( ) ; break ; case NOTAS_APTO_VER : ctrlInformacion . cargarDialogoVerNotasParticulares ( ) ; break ; case NOTAS_GRAL_VER : ctrlInformacion . cargarDialogoVerNotasGenerales ( ) ; break ; case NOTA_APTO_NUEVO : ctrlInformacion . cargarDialogoNuevaNotaParticular ( ) ; break ; case NOTA_GRAL_NUEVO : ctrlInformacion . cargarDialogoNuevaNotaGeneral ( ) ; break ; case RECARGAR_CONTRATOS : ctrlInformacion . cargarContratos ( ) ; break ; case VER_DATOS_RESPONSABLES : ctrlInformacion . cargarDialogoVerDatosResponsables ( ) ; break ; case VER_TELEFONOS : ctrlInformacion . cargarDialogoVerTelefonos ( ) ; break ; } }
tr	0	public Vector3f getAmbientColor ( ) { return ambientColor ; }
tr	0	@ Override public Object get ( Object key ) { return super . get ( toLowerCase ( key ) ) ; }
tr	4	public static Chromosome [ ] cross ( Chromosome parent1 , Chromosome parent2 , float mutationRate , int crossOverIndex ) { Chromosome p [ ] = new Chromosome [ ] { parent1 , parent2 } ; final int c1 = Math . abs ( rnd . nextInt ( ) ) % 2 ; final int c2 = ( c1 + 1 ) % 2 ; Chromosome c [ ] = new Chromosome [ ] { new Chromosome ( p [ 0 ] . useDivisor ) , new Chromosome ( p [ 0 ] . useDivisor ) } ; c [ c1 ] . score = p [ c1 ] . score * ( double ) crossOverIndex / ( double ) c [ c1 ] . g . length + p [ c2 ] . score * ( double ) ( c [ c1 ] . g . length - crossOverIndex ) / ( double ) c [ c1 ] . g . length ; c [ c2 ] . score = p [ c2 ] . score * ( double ) crossOverIndex / ( double ) c [ c1 ] . g . length + p [ c1 ] . score * ( double ) ( c [ c1 ] . g . length - crossOverIndex ) / ( double ) c [ c1 ] . g . length ; int p1 = c1 , p2 = c2 ; for ( int i = 0 ; i < p [ c1 ] . g . length ; i ++ ) { if ( i == crossOverIndex ) { p1 = c2 ; p2 = c1 ; } if ( rnd . nextFloat ( ) < mutationRate ) { c [ c1 ] . g [ i ] = p [ p1 ] . g [ i ] * ( 1f + ( float ) rnd . nextGaussian ( ) ) ; } else { c [ c1 ] . g [ i ] = p [ p1 ] . g [ i ] ; } if ( rnd . nextFloat ( ) < mutationRate ) { c [ c2 ] . g [ i ] = p [ p2 ] . g [ i ] * ( 1f + ( float ) rnd . nextGaussian ( ) ) ; } else { c [ c2 ] . g [ i ] = p [ p2 ] . g [ i ] ; } } return c ; }
tr	2	public void draw ( ) { while ( ! ( glapi . isCloseRequest ( ) || Keyboard . isKeyDown ( Keyboard . KEY_Q ) ) ) { glapi . defaultMovements ( ) ; glapi . glLoopBegin ( ) ; glapi . glLoopEnd ( ) ; } glapi . destroyDisplay ( ) ; }
tr	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( MenuRelatorios . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( MenuRelatorios . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( MenuRelatorios . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( MenuRelatorios . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { new MenuRelatorios ( ) . setVisible ( true ) ; } } ) ; }
tr	5	public Iterable < Position < E >> findRange ( E minValue , E maxValue ) { List < Position < E >> l = new ArrayList < > ( ) ; List < Position < E >> todas = ( List < Position < E >> ) this . positions ( ) ; for ( Position < E > pos : todas ) { E curValue = pos . element ( ) ; int compMin = findComparator . compare ( curValue , minValue ) ; int compMax = findComparator . compare ( curValue , maxValue ) ; boolean overMin = ( ( compMin == 0 ) || ( compMin == 1 ) ) ; boolean underMax = ( ( compMax == 0 ) || ( compMax == - 1 ) ) ; if ( overMin && underMax ) { l . add ( pos ) ; } } return l ; }
tr	5	@ Override public boolean equals ( Object o ) { if ( o == this ) return true ; if ( o == null || ! ( o instanceof TIPPTool ) ) return false ; TIPPTool t = ( TIPPTool ) o ; return Objects . equals ( name , t . name ) && Objects . equals ( id , t . id ) && Objects . equals ( version , t . version ) ; }
tr	7	public static String singleOccurance ( String s ) { char c [ ] = s . toCharArray ( ) ; int count = 0 ; for ( int i = 0 ; i < c . length ; i ++ ) { if ( c [ i ] !=   ) { for ( int j = i + 1 ; j < c . length ; j ++ ) { if ( c [ i ] == c [ j ] ) { count ++ ; } else { i = j - 1 ; break ; } } } } System . out . println ( count ) ; char c1 [ ] = new char [ c . length - count ] ; for ( int i = 0 , k = 0 ; i < c . length ; i ++ , k ++ ) { c1 [ k ] = c [ i ] ; for ( int j = i ; j < c . length ; j ++ ) { if ( c [ i ] != c [ j ] ) { i = j - 1 ; break ; } } } s = new String ( c1 ) ; return s ; }
tr	5	public T get ( Id idArg ) throws VariavelNaoDeclaradaException { try { T result = null ; Stack < HashMap < Id , T >> auxStack = new Stack < HashMap < Id , T >> ( ) ; while ( result == null && ! pilha . empty ( ) ) { HashMap < Id , T > aux = pilha . pop ( ) ; auxStack . push ( aux ) ; result = aux . get ( idArg ) ; } while ( ! auxStack . empty ( ) ) { pilha . push ( auxStack . pop ( ) ) ; } if ( result == null ) { throw new IdentificadorNaoDeclaradoException ( ) ; } return result ; } catch ( IdentificadorNaoDeclaradoException e ) { throw new VariavelNaoDeclaradaException ( idArg ) ; } }
tr	3	public void setType ( int type ) { if ( getType ( ) == type ) { return ; } switch ( type ) { case DOUBLE_TYPE : imp = new DoubleBenoitNumber ( doubleValue ( ) ) ; break ; case BIG_TYPE : imp = new BigDecimalBenoitNumber ( bigValue ( ) ) ; break ; default : throw new IllegalArgumentException ( "Invalid type" ) ; } }
tr	8	private void drawLoginScreen ( boolean flag ) { resetImageProducers ( ) ; aRSImageProducer_1109 . initDrawingArea ( ) ; aBackground_966 . drawBackground ( 0 , 0 ) ; char c = Ũ ; char c1 = È ; if ( loginScreenState == 0 ) { int i = c1 / 2 + 80 ; smallText . method382 ( 75a9a9 , c / 2 , onDemandFetcher . statusString , i , true ) ; i = c1 / 2 - 20 ; chatTextDrawingArea . method382 ( ffff00 , c / 2 , "Welcome to RuneScape" , i , true ) ; i += 30 ; int l = c / 2 - 80 ; int k1 = c1 / 2 + 20 ; aBackground_967 . drawBackground ( l - 73 , k1 - 20 ) ; chatTextDrawingArea . method382 ( ffffff , l , "New User" , k1 + 5 , true ) ; l = c / 2 + 80 ; aBackground_967 . drawBackground ( l - 73 , k1 - 20 ) ; chatTextDrawingArea . method382 ( ffffff , l , "Existing User" , k1 + 5 , true ) ; } if ( loginScreenState == 2 ) { int j = c1 / 2 - 40 ; if ( loginMessage1 . length ( ) > 0 ) { chatTextDrawingArea . method382 ( ffff00 , c / 2 , loginMessage1 , j - 15 , true ) ; chatTextDrawingArea . method382 ( ffff00 , c / 2 , loginMessage2 , j , true ) ; j += 30 ; } else { chatTextDrawingArea . method382 ( ffff00 , c / 2 , loginMessage2 , j - 7 , true ) ; j += 30 ; } chatTextDrawingArea . method389 ( true , c / 2 - 90 , ffffff , "Username: " + myUsername + ( ( loginScreenCursorPos == 0 ) & ( loopCycle % 40 < 20 ) ? "@yel@|" : "" ) , j ) ; j += 15 ; chatTextDrawingArea . method389 ( true , c / 2 - 88 , ffffff , "Password: " + TextClass . passwordAsterisks ( myPassword ) + ( ( loginScreenCursorPos == 1 ) & ( loopCycle % 40 < 20 ) ? "@yel@|" : "" ) , j ) ; j += 15 ; if ( ! flag ) { int i1 = c / 2 - 80 ; int l1 = c1 / 2 + 50 ; aBackground_967 . drawBackground ( i1 - 73 , l1 - 20 ) ; chatTextDrawingArea . method382 ( ffffff , i1 , "Login" , l1 + 5 , true ) ; i1 = c / 2 + 80 ; aBackground_967 . drawBackground ( i1 - 73 , l1 - 20 ) ; chatTextDrawingArea . method382 ( ffffff , i1 , "Cancel" , l1 + 5 , true ) ; } } if ( loginScreenState == 3 ) { chatTextDrawingArea . method382 ( ffff00 , c / 2 , "Create a free account" , c1 / 2 - 60 , true ) ; int k = c1 / 2 - 35 ; chatTextDrawingArea . method382 ( ffffff , c / 2 , "To create a new account you need to" , k , true ) ; k += 15 ; chatTextDrawingArea . method382 ( ffffff , c / 2 , "go back to the main RuneScape webpage" , k , true ) ; k += 15 ; chatTextDrawingArea . method382 ( ffffff , c / 2 , "and choose the red 'create account'" , k , true ) ; k += 15 ; chatTextDrawingArea . method382 ( ffffff , c / 2 , "button at the top right of that page." , k , true ) ; k += 15 ; int j1 = c / 2 ; int i2 = c1 / 2 + 50 ; aBackground_967 . drawBackground ( j1 - 73 , i2 - 20 ) ; chatTextDrawingArea . method382 ( ffffff , j1 , "Cancel" , i2 + 5 , true ) ; } aRSImageProducer_1109 . drawGraphics ( 171 , super . graphics , 202 ) ; if ( welcomeScreenRaised ) { welcomeScreenRaised = false ; aRSImageProducer_1107 . drawGraphics ( 0 , super . graphics , 128 ) ; aRSImageProducer_1108 . drawGraphics ( 371 , super . graphics , 202 ) ; aRSImageProducer_1112 . drawGraphics ( 265 , super . graphics , 0 ) ; aRSImageProducer_1113 . drawGraphics ( 265 , super . graphics , 562 ) ; aRSImageProducer_1114 . drawGraphics ( 171 , super . graphics , 128 ) ; aRSImageProducer_1115 . drawGraphics ( 171 , super . graphics , 562 ) ; } }
tr	3	public static void noSpace ( String string ) throws JSONException { int i , length = string . length ( ) ; if ( length == 0 ) { throw new JSONException ( "Empty string." ) ; } for ( i = 0 ; i < length ; i += 1 ) { if ( Character . isWhitespace ( string . charAt ( i ) ) ) { throw new JSONException ( "'" + string + "' contains a space character." ) ; } } }
tr	5	public void addListaElevi ( Clasa cl , Node node ) { NodeList childNodes = node . getChildNodes ( ) ; for ( int i = 0 ; i < childNodes . getLength ( ) ; i ++ ) { Node cNode = childNodes . item ( i ) ; if ( cNode instanceof Element ) { String content = cNode . getTextContent ( ) . trim ( ) ; if ( cNode . getNodeName ( ) . equals ( "elev" ) ) { for ( Elev e : elevi ) { if ( e . getCNP ( ) . equals ( content ) ) { cl . addElev ( e ) ; } } } } } }
tr	4	private void close ( ) { try { if ( resultSet != null ) { resultSet . close ( ) ; } if ( statement != null ) { statement . close ( ) ; } if ( connect != null ) { connect . close ( ) ; } } catch ( Exception e ) { } }
tr	5	public int getPerceptIndex ( String percept ) { if ( percept . equals ( SOLVED ) ) { return ( getPerceptsNumber ( ) - 1 ) ; } else { int [ ] values = new int [ 2 ] ; int k = 0 ; try { StreamTokenizer tokenizer = new StreamTokenizer ( new StringReader ( percept ) ) ; while ( k < 2 && tokenizer . nextToken ( ) != StreamTokenizer . TT_EOF ) { if ( tokenizer . ttype == StreamTokenizer . TT_NUMBER ) { values [ k ] = ( int ) ( tokenizer . nval ) ; k ++ ; } } return values [ 0 ] * DIGITS + values [ 1 ] ; } catch ( Exception e ) { return - 1 ; } } }
tr	0	public JPasswordField getPassword ( ) { return password ; }
tr	1	private char peekNextChar ( ) { if ( pos < ( input . length ( ) - 1 ) ) { return input . charAt ( pos + 1 ) ; } else { return 0 ; } }
tr	0	public void serviceRemoved ( ServiceEvent event ) { synchronized ( infos ) { infos . remove ( event . getName ( ) ) ; } }
tr	9	public static String toString ( JSONObject jo ) throws JSONException { Iterator keys = jo . keys ( ) ; String string ; StringBuffer sb = new StringBuffer ( ) ; if ( jo . has ( "Status-Code" ) && jo . has ( "Reason-Phrase" ) ) { sb . append ( jo . getString ( "HTTP-Version" ) ) ; sb . append (   ) ; sb . append ( jo . getString ( "Status-Code" ) ) ; sb . append (   ) ; sb . append ( jo . getString ( "Reason-Phrase" ) ) ; } else if ( jo . has ( "Method" ) && jo . has ( "Request-URI" ) ) { sb . append ( jo . getString ( "Method" ) ) ; sb . append (   ) ; sb . append ( " ) ; sb . append ( jo . getString ( "Request-URI" ) ) ; sb . append ( " ) ; sb . append (   ) ; sb . append ( jo . getString ( "HTTP-Version" ) ) ; } else { throw new JSONException ( "Not enough material for an HTTP header." ) ; } sb . append ( CRLF ) ; while ( keys . hasNext ( ) ) { string = keys . next ( ) . toString ( ) ; if ( ! string . equals ( "HTTP-Version" ) && ! string . equals ( "Status-Code" ) && ! string . equals ( "Reason-Phrase" ) && ! string . equals ( "Method" ) && ! string . equals ( "Request-URI" ) && ! jo . isNull ( string ) ) { sb . append ( string ) ; sb . append ( ": " ) ; sb . append ( jo . getString ( string ) ) ; sb . append ( CRLF ) ; } } sb . append ( CRLF ) ; return sb . toString ( ) ; }
tr	4	private void updateItemsBorrowed ( ) { String attribute = null ; if ( studentJRadioButton . isSelected ( ) ) { attribute = studentJTextField . getText ( ) ; memberId = studentJTextField . getText ( ) ; } else if ( facultyJRadioButton . isSelected ( ) ) { attribute = facultyJTextField . getText ( ) ; memberId = facultyJTextField . getText ( ) ; } String query = "UPDATE members SET ItemsBorrowed=(ItemsBorrowed+1) WHERE MemberId='" + attribute + "' " ; String query2 = "UPDATE books SET IsBorrowed=1 WHERE ((Name='" + title . getTitleName ( ) + "') AND (ItemNo='" + title . getItemNo ( ) + "')) " ; try { pst = connection . prepareStatement ( query ) ; pst = connection . prepareStatement ( query2 ) ; pst . addBatch ( query ) ; pst . addBatch ( query2 ) ; pst . executeBatch ( ) ; JOptionPane . showMessageDialog ( null , "All tables are up-to-date.\nYou can now lend the Item to Member" , "Successful lending" , JOptionPane . INFORMATION_MESSAGE ) ; } catch ( SQLException e ) { JOptionPane . showMessageDialog ( null , e ) ; } finally { try { rs . close ( ) ; pst . close ( ) ; } catch ( Exception e ) { } } }
tr	8	private DataFrame readFrame ( final Tag openTag ) { if ( openTag == null ) { throw new IllegalArgumentException ( "ReadFrame called will null OpenTag" ) ; } Tag currentTag = openTag ; DataFrame retval = null ; DataField field = null ; while ( currentTag != null ) { if ( ! currentTag . isComment ( ) && ! currentTag . isPreamble ( ) ) { if ( currentTag . isOpenTag ( ) ) { if ( currentTag . isEmptyTag ( ) ) { field = new DataField ( currentTag . getName ( ) , null ) ; } else { field = readField ( currentTag ) ; } if ( field != null ) { if ( retval == null ) { retval = new DataFrame ( ) ; } retval . add ( field ) ; } else { throw error ( "Problems reading field: null value" ) ; } currentTag = readTag ( ) ; } else { break ; } } else { currentTag = readTag ( ) ; } } return retval ; }
tr	2	public void setAttributes ( Point leftest , Point rightest ) { if ( leftest != null ) { leftAngle = Tools . round ( src . getDirection ( leftest ) , 10000 ) ; leftDist = src . getDistance ( leftest ) ; } if ( rightest != null ) { rightAngle = Tools . round ( src . getDirection ( rightest ) , 10000 ) ; rightDist = src . getDistance ( rightest ) ; } }
tr	7	private void updateDataTableTimeKeeping ( int n , int month , int year ) { Object [ ] [ ] objData = new Object [ n ] [ ] ; Object [ ] objColumn = new Object [ ] { "Working" , "Date" } ; int day ; String date ; if ( currentEmployee != null ) { Contract correctContract = currentEmployee . searchCorrespondingContract ( year , month ) ; if ( correctContract != null ) { TimeKeepingBook keepBook = correctContract . getTimeKeeping ( ) ; if ( keepBook != null ) { TimeKeepingSheet keepSheet = keepBook . get ( month , year ) ; if ( keepSheet == null ) { for ( int i = 0 ; i < n ; i ++ ) { day = i + 1 ; date = getStringOfDate ( year , month , day ) ; Object [ ] objValue = new Object [ ] { new boolean ( false ) , date } ; objData [ i ] = objValue ; } } else { for ( int i = 0 ; i < keepSheet . size ( ) ; i ++ ) { TimeKeepingDetailInfo infor = keepSheet . get ( i ) ; day = i + 1 ; date = getStringOfDate ( year , month , day ) ; Object [ ] objValue = new Object [ ] { new boolean ( infor . getIsWorking ( ) ) , date } ; objData [ i ] = objValue ; } } } } } else { for ( int i = 0 ; i < n ; i ++ ) { day = i + 1 ; date = getStringOfDate ( year , month , day ) ; Object [ ] objValue = new Object [ ] { new boolean ( false ) , date } ; objData [ i ] = objValue ; } } timeKeepingBookFrame . getTableModelTimeKeeping ( ) . setDataVector ( objData , objColumn ) ; timeKeepingBookFrame . getTableTimeKeeping ( ) . getColumn ( "Working" ) . setCellRenderer ( new MyTableCellRenderer ( ) ) ; timeKeepingBookFrame . getTableTimeKeeping ( ) . getColumn ( "Working" ) . setCellEditor ( new MyTableCellEditor ( ) ) ; }
tr	2	public DistributedFile getFile ( String fileName ) throws FileSystemException { for ( DistributedFile f : files ) if ( f . getFileName ( ) . equals ( fileName ) ) return f ; throw new FileSystemException ( fileName + "File Not Found" ) ; }
tr	3	private int getUnvisitedNode ( int [ ] [ ] adjacency_matrix , int source , int [ ] visited ) { int [ ] myNeighbors = adjacency_matrix [ source ] ; for ( int i = 0 ; i < myNeighbors . length ; i ++ ) { if ( myNeighbors [ i ] == 1 && visited [ i ] == 0 ) { return i ; } } return - 1 ; }
tr	8	@ Override public void onSkeletonFrameEvent ( float [ ] floats , boolean [ ] booleans ) { if ( enabled ) { int count = 0 ; Skeleton [ ] skeletons = new Skeleton [ 2 ] ; for ( int i = 0 ; i < booleans . length ; i ++ ) { if ( booleans [ i ] ) { skeletons [ count ++ ] = Skeleton . getSkeleton ( i , floats , booleans ) ; if ( count == 2 ) { break ; } } } if ( count == 2 ) { if ( ! skeletons [ 0 ] . isTracked ( ) ) { skeletons [ 0 ] . setIsTracked ( true ) ; } if ( ! skeletons [ 1 ] . isTracked ( ) ) { skeletons [ 1 ] . setIsTracked ( true ) ; } if ( skeletons [ 0 ] . get3DJointX ( Skeleton . SHOULDER_CENTER ) < skeletons [ 1 ] . get3DJointX ( Skeleton . SHOULDER_CENTER ) ) { p1 . onSkeletonFrame ( skeletons [ 0 ] ) ; p2 . onSkeletonFrame ( skeletons [ 1 ] ) ; } else { p2 . onSkeletonFrame ( skeletons [ 0 ] ) ; p1 . onSkeletonFrame ( skeletons [ 1 ] ) ; } } } }
tr	0	public short [ ] [ ] action_table ( ) { return _action_table ; }
tr	2	public static BufferedImage getImageFor ( Sexes sex ) { if ( instance == null ) { instance = new PortraitImages ( ) ; } Optional portraitOptional = instance . unusedPortraitList . stream ( ) . filter ( p -> p . getSex ( ) == sex ) . findAny ( ) ; if ( portraitOptional . isPresent ( ) ) { instance . unusedPortraitList . remove ( portraitOptional . get ( ) ) ; instance . usedPortraitList . add ( ( Portrait ) portraitOptional . get ( ) ) ; return ( ( Portrait ) portraitOptional . get ( ) ) . getPortrait ( ) ; } else { throw new RuntimeException ( "No more portaits" ) ; } }
tr	2	public void reset ( ) throws IOException { synchronized ( lock ) { ensureOpen ( ) ; if ( markedChar < 0 ) throw new IOException ( ( markedChar == INVALIDATED ) ? "Mark invalid" : "Stream not marked" ) ; nextChar = markedChar ; skipLF = markedSkipLF ; } }
tr	7	@ Override public void rightMultiply ( Matrix other ) { for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) copy [ i ] [ j ] = 0 ; for ( int i = 0 ; i < 4 ; i ++ ) { for ( int j = 0 ; j < 4 ; j ++ ) { for ( int k = 0 ; k < 4 ; k ++ ) { copy [ i ] [ j ] = copy [ i ] [ j ] + this . get ( k , i ) * other . get ( j , k ) ; } } } for ( int i = 0 ; i < 4 ; i ++ ) { for ( int j = 0 ; j < 4 ; j ++ ) { this . set ( j , i , copy [ i ] [ j ] ) ; } } }
tr	2	public Transition getFor ( char c ) { Transition result = defaultTransition ; if ( transitions . length > c ) { Transition tableValue = transitions [ c ] ; if ( tableValue != null ) result = tableValue ; } return result ; }
tr	5	public Object getValueAt ( int r , int c ) { Player player = history . getLast ( ) . get ( r ) ; switch ( c ) { case COL_RANK : return r + 1 ; case COL_NAME : return player . clone ( ) ; case COL_PRESENT : return player . isPresent ( ) ? Attendance . PRESENT : Attendance . ABSENT ; case COL_BIDS : return new BidCounter ( player . getBids ( ) ) ; default : return null ; } }
tr	1	public MapIconButton ( ) { super ( ) ; this . setFocusable ( false ) ; this . add ( new MapIconPanel ( true ) ) ; this . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { Block block = LevelEditor . editor . getCurrentBlock ( ) ; if ( block != null ) { MapIconConstructWindow icon = new MapIconConstructWindow ( block ) ; icon . setVisible ( true ) ; } } } ) ; }
tr	3	public static void main ( String [ ] args ) { BufferedReader buffer = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int N = 0 ; try { N = Integer . parseInt ( buffer . readLine ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } System . out . println ( "\u5B66\u4E60\u6210\u7EE9\u4E3A\uFF1A" + ( ( N < 60 ) ? "C" : ( N < 90 ) ? "B" : "A" ) ) ; }
tr	1	private void putStash ( int key , V value ) { if ( stashSize == stashCapacity ) { resize ( capacity << 1 ) ; put ( key , value ) ; return ; } int index = capacity + stashSize ; keyTable [ index ] = key ; valueTable [ index ] = value ; stashSize ++ ; size ++ ; }
tr	4	public boolean put ( int key , int value ) { LinkedNode root = this ; if ( root == null ) { return false ; } while ( root . getNext ( ) != null ) { if ( root . getKey ( ) == key ) return false ; root = root . getNext ( ) ; } if ( root . getKey ( ) == key ) return false ; root . setNext ( new LinkedNode ( key , value ) ) ; return true ; }
tr	6	@ Test public void testIsFullOutOfRange ( ) { Percolation p = new Percolation ( 10 ) ; try { p . isFull ( - 5 , 5 ) ; fail ( "Line above should throw exception" ) ; } catch ( IndexOutOfBoundsException e ) { } try { p . isFull ( 0 , 5 ) ; fail ( "Line above should throw exception" ) ; } catch ( IndexOutOfBoundsException e ) { } try { p . isFull ( 5 , - 5 ) ; fail ( "Line above should throw exception" ) ; } catch ( IndexOutOfBoundsException e ) { } try { p . isFull ( 5 , 0 ) ; fail ( "Line above should throw exception" ) ; } catch ( IndexOutOfBoundsException e ) { } try { p . isFull ( 15 , 5 ) ; fail ( "Line above should throw exception" ) ; } catch ( IndexOutOfBoundsException e ) { } try { p . isFull ( 5 , 15 ) ; fail ( "Line above should throw exception" ) ; } catch ( IndexOutOfBoundsException e ) { } }
tr	3	private void compact ( ) { int from = 0 ; int to = 0 ; while ( from < this . capacity ) { Object key = this . list [ from ] ; long usage = age ( this . ticks [ from ] ) ; if ( usage > 0 ) { this . ticks [ to ] = usage ; this . list [ to ] = key ; this . map . put ( key , to ) ; to += 1 ; } else { this . map . remove ( key ) ; } from += 1 ; } if ( to < this . capacity ) { this . length = to ; } else { this . map . clear ( ) ; this . length = 0 ; } this . power = 0 ; }
tr	5	public boolean getRGBPixels ( int x , int y , int width , int height , int [ ] pixels ) { if ( getRGBPixelsMethod != null ) try { if ( getRGBPixelsMethodType == 0 ) getRGBPixelsMethod . invoke ( peer , new Object [ ] { Integer . valueOf ( x ) , Integer . valueOf ( y ) , Integer . valueOf ( width ) , Integer . valueOf ( height ) , pixels } ) ; else if ( getRGBPixelsMethodType == 1 ) getRGBPixelsMethod . invoke ( peer , new Object [ ] { new Rectangle ( x , y , width , height ) , pixels } ) ; else if ( getRGBPixelsMethodType == 2 ) getRGBPixelsMethod . invoke ( peer , new Object [ ] { getRGBPixelsMethodParam , new Rectangle ( x , y , width , height ) , pixels } ) ; else getRGBPixelsMethod . invoke ( peer , new Object [ ] { getRGBPixelsMethodParam , Integer . valueOf ( x ) , Integer . valueOf ( y ) , Integer . valueOf ( width ) , Integer . valueOf ( height ) , pixels } ) ; return true ; } catch ( Exception ex ) { } int [ ] tmp = getRGBPixels ( new Rectangle ( x , y , width , height ) ) ; System . arraycopy ( tmp , 0 , pixels , 0 , width * height ) ; return false ; }
tr	5	public int getIndex ( Point p ) { final int x = p . x ; final int y = p . y ; if ( x < 0 || x >= 1 << order || y < 0 || y >= 1 << order ) return - 1 ; int index = 0 ; int sq = startsquare ; int o = order - 1 ; while ( o >= 0 ) { int i = ( ( ( ( x >> o ) & 1 ) << 1 ) | ( ( y >> o ) & 1 ) ) ; index = ( index << 2 ) | indexes [ sq ] [ i ] ; sq = squares [ sq ] [ i ] ; o -- ; } return index ; }
tr	8	public Playlist ( File file ) throws InvalidFileTypeException { if ( file . getName ( ) . contains ( "." ) ) _name = file . getName ( ) . split ( "\\." ) [ 0 ] ; else _name = file . getName ( ) ; _playlist = new ArrayList < Song > ( ) ; _index = 0 ; try { Scanner in = new Scanner ( file ) ; if ( in . hasNextLine ( ) ) { if ( ! in . nextLine ( ) . matches ( "^\\s*#[E|e][X|x][T|t][M|m]3[U|u]\\s*$" ) ) { throw new InvalidFileTypeException ( "Extended M3U Header Missing or Invalid." ) ; } } while ( in . hasNextLine ( ) ) { String current = in . nextLine ( ) ; if ( ! current . matches ( "^#.+$" ) ) { File path = new File ( current ) ; if ( path . exists ( ) ) { try { _playlist . add ( new Song ( path ) ) ; } catch ( InvalidFileTypeException e ) { } } } } } catch ( FileNotFoundException e ) { } }
tr	2	public Comuna buscarComuna ( String strcomuna ) { for ( Comuna comuna : listacomunas ) { if ( comuna . getCom_nombre ( ) . equals ( strcomuna ) ) { return comuna ; } } return null ; }
tr	5	public Set < String > scan ( ) throws Exception { URL [ ] urls = ClasspathUrlFinder . findClassPaths ( ) ; AnnotationDB db = new AnnotationDB ( ) ; try { db . scanArchives ( urls ) ; if ( this . name != null ) return db . getAnnotationIndex ( ) . get ( this . name ) ; else if ( c != null ) return db . getAnnotationIndex ( ) . get ( c . getName ( ) ) ; else throw new NullPointerException ( "String or Class was null" ) ; } catch ( IOException e ) { throw new Exception ( "IO Error" ) ; } catch ( RuntimeException e ) { if ( e . getMessage ( ) . startsWith ( "File in java.class.path does not exist: " ) ) return null ; else throw new RuntimeException ( e . getMessage ( ) ) ; } }
tr	6	public static String replaceAll ( String origin , String oldPart , String replacement ) { if ( origin == null || replacement == null ) { return origin ; } if ( oldPart == null || oldPart . length ( ) == 0 ) { return origin ; } int index = origin . indexOf ( oldPart ) ; if ( index < 0 ) { return origin ; } StringBuffer sb = new StringBuffer ( origin ) ; do { sb . replace ( index , index + oldPart . length ( ) , replacement ) ; origin = sb . toString ( ) ; index = origin . indexOf ( oldPart ) ; } while ( index != - 1 ) ; return origin ; }
tr	0	@ Override public void eat ( ) { logger . debug ( "Ey! I am a human! I need to EAT!!" ) ; }
tr	8	public boolean areAnagramsCount ( String a , String b ) { if ( a == null && b == null ) return false ; else if ( a == null || b == null ) return false ; else { int [ ] count = new int [ 256 ] ; char [ ] ac = a . toCharArray ( ) ; for ( char c : ac ) { count [ c ] ++ ; } char [ ] bc = b . toCharArray ( ) ; for ( char c : bc ) { count [ c ] -- ; } for ( int i : count ) { if ( i != 0 ) return false ; } } return true ; }
tr	9	public static Graph < Vertex , Edge > convert ( String name , String json ) { Graph < Vertex , Edge > result = new Graph < Vertex , Edge > ( Edge . class ) ; Gson gson = new Gson ( ) ; Wrapper data = gson . fromJson ( json , Wrapper . class ) ; for ( ChildShapes pools : data . childShapes ) { if ( pools . childShapes . size ( ) > 0 ) { createGraph ( result , pools . childShapes , TASK_LEVEL ) ; } else { if ( pools . stencil != null && pools . stencil . id != null && pools . stencil . id . contains ( "Flow" ) ) { for ( Outgoing out : pools . outgoing ) if ( result . vertexIDRef . containsKey ( out . resourceId ) ) { TreeMap < String , Vertex > pair = new TreeMap < String , Vertex > ( ) ; pair . put ( "trg" , result . vertexRef . get ( result . vertexIDRef . get ( out . resourceId ) ) ) ; edges . put ( pools . resourceId , pair ) ; } } } } for ( String key : vedges . keySet ( ) ) { for ( String s : vedges . get ( key ) ) { if ( edges . containsKey ( s ) ) { if ( result . vertexIDRef . containsKey ( key ) ) { edges . get ( s ) . put ( "src" , result . vertexRef . get ( result . vertexIDRef . get ( key ) ) ) ; } } } } for ( String key : edges . keySet ( ) ) { if ( edges . get ( key ) . containsKey ( "src" ) && edges . get ( key ) . containsKey ( "trg" ) ) { Edge e = new Edge ( edges . get ( key ) . get ( "src" ) , edges . get ( key ) . get ( "trg" ) ) ; result . addE ( e ) ; } else { } } return result ; }
tr	2	@ SuppressWarnings ( "unchecked" ) public CaseInsensitiveDictionary ( Dictionary delegate ) { NotNullException . assertValue ( delegate , "delegate" ) ; this . delegate = new Hashtable < String , Object > ( delegate . size ( ) ) ; this . originalKeys = Collections . synchronizedSet ( new HashSet < String > ( ) ) ; Enumeration < String > e = delegate . keys ( ) ; while ( e . hasMoreElements ( ) ) { String key = e . nextElement ( ) ; if ( get ( key ) != null ) throw new IllegalArgumentException ( "Duplicates with varying case for key [" + key + "] : " + delegate ) ; this . delegate . put ( key . toLowerCase ( Locale . ENGLISH ) , delegate . get ( key ) ) ; originalKeys . add ( key ) ; } }
tr	9	private void doTransfer ( ) throws IOException { if ( ressourceInputStream == null ) { if ( sendHeaderInRsp ) { String header = new FileRequestResponseMessage ( ResponseCode . NEVER_TRY_AGAIN , 0 ) . Serialize ( ) ; logger . info ( "send header '" + header + "'" ) ; networkOutputStream . write ( header . getBytes ( ) ) ; } networkOutputStream . close ( ) ; return ; } else { if ( offset > numAvailableData ) { logger . log ( Level . INFO , "Requested offset is not valid: requested " + offset + "  length of file: " + numAvailableData ) ; if ( sendHeaderInRsp ) networkOutputStream . write ( new FileRequestResponseMessage ( ResponseCode . OK , 0 ) . Serialize ( ) . getBytes ( ) ) ; networkOutputStream . close ( ) ; transferState = TransferStatus . Finished ; return ; } if ( offset + expectedTransferVolume > numAvailableData ) { logger . log ( Level . INFO , "Requested length of " + expectedTransferVolume + " was too large  shortened  it to " + expectedTransferVolume ) ; expectedTransferVolume = numAvailableData - offset ; } transferState = TransferStatus . Transfering ; if ( sendHeaderInRsp ) networkOutputStream . write ( ( new FileRequestResponseMessage ( ResponseCode . OK , expectedTransferVolume ) . Serialize ( ) ) . getBytes ( Message . ENCODING ) ) ; if ( bufferSize == - 1 ) { bufferSize = FALLBACK_BUFFER_SIZE ; logger . log ( Level . INFO , "Using fallback buffersize " + bufferSize ) ; } logger . info ( "sending data" ) ; ressourceInputStream . skip ( offset ) ; int bytesRead = 0 ; int bytesToRead = bufferSize ; byte [ ] buffer = new byte [ bufferSize ] ; while ( bytesToRead > 0 && keepTransferAlive && totalTransferedVolume < expectedTransferVolume && ( bytesRead = ressourceInputStream . read ( buffer , 0 , bytesToRead ) ) != - 1 ) { networkOutputStream . write ( buffer , 0 , bytesRead ) ; totalTransferedVolume += bytesRead ; if ( totalTransferedVolume + bytesToRead > expectedTransferVolume ) { bytesToRead = ( int ) ( expectedTransferVolume - totalTransferedVolume ) ; } } networkOutputStream . flush ( ) ; networkOutputStream . close ( ) ; ressourceInputStream . close ( ) ; logger . info ( "finished sending data" ) ; if ( totalTransferedVolume == expectedTransferVolume ) transferState = TransferStatus . Finished ; else { if ( ! keepTransferAlive ) transferState = TransferStatus . Canceled ; else transferState = TransferStatus . LostConnection ; } } }
tr	8	public static double nextAfter ( double d , double direction ) { if ( double . isNaN ( d ) || double . isNaN ( direction ) ) { return double . NaN ; } else if ( d == direction ) { return direction ; } else if ( double . isInfinite ( d ) ) { return ( d < 0 ) ? - double . MAX_VALUE : double . MAX_VALUE ; } else if ( d == 0 ) { return ( direction < 0 ) ? - double . MIN_VALUE : double . MIN_VALUE ; } final long bits = double . doubleToLongBits ( d ) ; final long sign = bits & 8000000000000000 ; if ( ( direction < d ) ^ ( sign == 0 ) ) { return double . longBitsToDouble ( sign | ( ( bits & 7fffffffffffffff ) + 1 ) ) ; } else { return double . longBitsToDouble ( sign | ( ( bits & 7fffffffffffffff ) - 1 ) ) ; } }
tr	4	public void dbReadList ( Connection aconn ) { try { String qstr = "Select " + codefld + " " + mapfld + " From " + tablenm + " Order by " + codefld ; Statement qstmt = aconn . createStatement ( ) ; ResultSet rset = qstmt . executeQuery ( qstr ) ; while ( rset . next ( ) ) { CMapItem myitem = new CMapItem ( ) ; myitem . codeval = rset . getString ( 1 ) ; if ( maptyp == CMapCode . TypeString ) myitem . mapval = rset . getString ( 2 ) ; else if ( maptyp == CMapCode . TypeInteger ) myitem . mapval = Integer . toString ( rset . getInt ( 2 ) ) ; this . addItem ( myitem . codeval , myitem ) ; } rset . close ( ) ; qstmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CMapCode.dbReadList cannot read list. " , ex ) ; } }
tr	3	public void add ( int index , E value ) { if ( ( index < 0 ) || ( index > this . size ) ) { return ; } if ( index == 0 ) { this . addFront ( value ) ; } else { this . addAfter ( this . nodeAtPosition ( index - 1 ) , value ) ; } this . size ++ ; }
tr	9	@ Override public void visitDocument ( String key , Object value ) { paths = DocUtils . split ( key , / ) ; infoList = new ArrayList < GetVisitor . VisitorInfo > ( ) ; String decrPath = "" ; for ( int i = 0 ; i < paths . length ; i ++ ) { decrPath += "/" + paths [ i ] ; } Field f = rootDoc . getSchema ( ) . getField ( paths [ 0 ] ) ; if ( paths . length > 1 ) { decrPath = "" ; for ( int i = 0 ; i < paths . length - 1 ; i ++ ) { decrPath += "/" + paths [ i ] ; } } else { if ( f . isReadOnly ( ) ) { } } GetVisitor visitor = new GetVisitor ( rootDoc ) ; if ( paths . length > 1 ) { visitor . visitDocument ( decrPath ) ; Object sourceObject = visitor . getResult ( ) ; if ( sourceObject == null ) { throw new NullPointerException ( "Null value for key path '" + key + "'" ) ; } if ( visitor . getException ( ) != null ) { throw ( RuntimeException ) visitor . getException ( ) ; } SchemaType st = visitor . getInfo ( ) . getResultSchemaType ( ) ; visitPut ( st , sourceObject , value ) ; } else { Object sourceObject = f . isTail ( ) ? ( ( ObjectDocument ) rootDoc ) . tail : ( ( ObjectDocument ) rootDoc ) . getDataObject ( ) ; SchemaType st = new EmbeddedType ( rootDoc . getSchema ( ) ) ; visitPut ( st , sourceObject , value ) ; } if ( getException ( ) != null ) { RuntimeException re = ( RuntimeException ) getException ( ) ; throw re ; } }
tr	1	public double getTime ( int R , int T , int Vrat , int Vcat ) { double ratDist = Math . min ( Math . PI * R , T * Vrat ) ; if ( Vrat >= Vcat ) return - 1.0 ; else { return ratDist / ( Vcat - Vrat ) ; } }
tr	1	@ Override public void mouseReleased ( MouseEvent e ) { try { onMouseReleased ( e ) ; } catch ( Throwable t ) { throwableGenerated ( "onMouseReleased" , t ) ; } }
tr	5	public void setTextFieldValues ( ) { List < User > theUsers = users . getUsers ( ) ; tasks = new AccessTasks ( ) ; tasks . getTasks ( ) ; theTask = null ; if ( tasks != null && item != null ) { theTask = tasks . getTask ( Integer . parseInt ( item . getText ( ) ) ) ; } if ( theTask != null ) { StaticWindowMethods . populateAssignedToDropDown ( cboxAssignedTo , theUsers ) ; cboxAssignedTo . select ( cboxAssignedTo . indexOf ( theTask . getAssignedTo ( ) . getUserName ( ) ) ) ; if ( StatusCode . values ( ) . length > 0 ) { StaticWindowMethods . populateStatusDropDown ( cboxStatus ) ; theTask . getStatus ( ) ; cboxStatus . select ( cboxStatus . indexOf ( StatusCode . valueOf ( theTask . getStatus ( ) . toString ( ) ) . toString ( ) ) ) ; } if ( PriorityCode . values ( ) . length > 0 ) { StaticWindowMethods . populatePriorityDropDown ( cboxPriority ) ; cboxPriority . select ( cboxPriority . indexOf ( PriorityCode . valueOf ( theTask . getPriority ( ) . toString ( ) ) . toString ( ) ) ) ; } lblCreatedByField . setText ( theTask . getCreator ( ) . getUserName ( ) ) ; lblCreatedDateField . setText ( FormatDate . formatDate ( theTask . getCreatedDate ( ) ) ) ; txtTitle . setText ( theTask . getTitle ( ) ) ; txtTimeEstimate . setText ( "" + theTask . getTimeEstimate ( ) ) ; txtTimeSpent . setText ( "" + theTask . getTimeSpent ( ) ) ; txtDescription . setText ( theTask . getDescription ( ) ) ; txtComments . setText ( theTask . getComments ( ) ) ; dueDate . setDay ( theTask . getDueDate ( ) . get ( Calendar . DAY_OF_MONTH ) ) ; dueDate . setMonth ( theTask . getDueDate ( ) . get ( Calendar . MONTH ) ) ; dueDate . setYear ( theTask . getDueDate ( ) . get ( Calendar . YEAR ) ) ; } }
tr	6	@ Override public void actionPerformed ( ActionEvent e ) { String cmd = e . getActionCommand ( ) ; switch ( cmd ) { case AGREGRA_HABITANTE_BUSCADO : controllerContratos . agregarHabitanteBuscado ( ) ; break ; case AGREGRA_HABITANTE_NUEVO : controllerContratos . agregarHabitanteNuevo ( ) ; break ; case BUSCAR_HABITANTE : controllerContratos . buscarHabitante ( ) ; break ; case CONFIRMAR : controllerContratos . cambiarHabitantes ( ) ; break ; case QUITAR_HABITANTE : controllerContratos . quitarHabitanteSeleccion ( ) ; break ; case CANCELAR : cerrar ( ) ; break ; } }
tr	1	public void buyGem ( Gem gem ) { if ( MagicPower . decrease ( gem ) ) { map . setGem ( gem ) ; } else listener . onError ( TDActionListener . NO_MP ) ; }
tr	1	public static List < String > separateByNullChar ( String toSeparate ) { List < String > result = new ArrayList < String > ( ) ; String [ ] strings = toSeparate . split ( "" +  ) ; for ( int i = 0 ; i < strings . length ; i ++ ) { result . add ( strings [ i ] ) ; } return result ; }
tr	9	private int [ ] getMinPrefMaxSumSize ( boolean isHor ) { int [ ] [ ] sizes = isHor ? colFlowSpecs . sizes : rowFlowSpecs . sizes ; int [ ] retSizes = new int [ 3 ] ; BoundSize sz = isHor ? lc . getWidth ( ) : lc . getHeight ( ) ; for ( int i = 0 ; i < sizes . length ; i ++ ) { if ( sizes [ i ] != null ) { int [ ] size = sizes [ i ] ; for ( int sType = LayoutUtil . MIN ; sType <= LayoutUtil . MAX ; sType ++ ) { if ( sz . getSize ( sType ) != null ) { if ( i == 0 ) retSizes [ sType ] = sz . getSize ( sType ) . getPixels ( getParentSize ( container , isHor ) , container , null ) ; } else { int s = size [ sType ] ; if ( s != LayoutUtil . NOT_SET ) { if ( sType == LayoutUtil . PREF ) { int bnd = size [ LayoutUtil . MAX ] ; if ( bnd != LayoutUtil . NOT_SET && bnd < s ) s = bnd ; bnd = size [ LayoutUtil . MIN ] ; if ( bnd > s ) s = bnd ; } retSizes [ sType ] += s ; } if ( size [ LayoutUtil . MAX ] == LayoutUtil . NOT_SET || retSizes [ LayoutUtil . MAX ] > LayoutUtil . INF ) retSizes [ LayoutUtil . MAX ] = LayoutUtil . INF ; } } } } correctMinMax ( retSizes ) ; return retSizes ; }
tr	9	public ObjectMatch tryUnmarshall ( SerializerState state , class clazz , Object o ) throws UnmarshallException { JSONObject jso = ( JSONObject ) o ; String java_class ; try { java_class = jso . getString ( "javaClass" ) ; } catch ( JSONException e ) { throw new UnmarshallException ( "Could not read javaClass" , e ) ; } if ( java_class == null ) { throw new UnmarshallException ( "no type hint" ) ; } if ( ! ( java_class . equals ( "java.util.Set" ) || java_class . equals ( "java.util.AbstractSet" ) || java_class . equals ( "java.util.LinkedHashSet" ) || java_class . equals ( "java.util.TreeSet" ) || java_class . equals ( "java.util.HashSet" ) ) ) { throw new UnmarshallException ( "not a Set" ) ; } JSONObject jsonset ; try { jsonset = jso . getJSONObject ( "set" ) ; } catch ( JSONException e ) { throw new UnmarshallException ( "set missing" , e ) ; } if ( jsonset == null ) { throw new UnmarshallException ( "set missing" ) ; } ObjectMatch m = new ObjectMatch ( - 1 ) ; state . setSerialized ( o , m ) ; Iterator i = jsonset . keys ( ) ; String key = null ; try { while ( i . hasNext ( ) ) { key = ( String ) i . next ( ) ; m . setMismatch ( ser . tryUnmarshall ( state , null , jsonset . get ( key ) ) . max ( m ) . getMismatch ( ) ) ; } } catch ( UnmarshallException e ) { throw new UnmarshallException ( "key " + key + " " + e . getMessage ( ) , e ) ; } catch ( JSONException e ) { throw new UnmarshallException ( "key " + key + " " + e . getMessage ( ) , e ) ; } return m ; }
tr	9	public void mouseDragged ( MouseEvent e ) { if ( isCtrlDown ( e ) || ( ! editMode && ! ctx . dragging ) ) { if ( panCurr != null ) { Point pt = new Point ( e . getX ( ) , e . getY ( ) ) ; if ( e . getComponent ( ) != null ) { SwingUtilities . convertPointToScreen ( pt , e . getComponent ( ) ) ; } int deltaX = pt . x - panCurr . x ; int deltaY = pt . y - panCurr . y ; prevPanCurr = panCurr ; panCurr = new PointAtTime ( pt . x , pt . y ) ; ctx . getScrollPane ( ) . getHorizontalScrollBar ( ) . setValue ( - deltaX + ctx . getScrollPane ( ) . getHorizontalScrollBar ( ) . getValue ( ) ) ; ctx . getScrollPane ( ) . getVerticalScrollBar ( ) . setValue ( - deltaY + ctx . getScrollPane ( ) . getVerticalScrollBar ( ) . getValue ( ) ) ; } } else { if ( ctx . dragging || ctx . rubberBanding ) { ctx . dragCurr = new Point ( e . getX ( ) , e . getY ( ) ) ; if ( ctx . rubberBanding ) { Point startP = ctx . getXY ( ctx . dragStart . x , ctx . dragStart . y ) ; Point endP = ctx . getXY ( ctx . dragCurr . x , ctx . dragCurr . y ) ; int temp ; if ( startP . x > endP . x ) { temp = startP . x ; startP . x = endP . x ; endP . x = temp ; } if ( startP . y > endP . y ) { temp = startP . y ; startP . y = endP . y ; endP . y = temp ; } ctx . clearSelection ( ) ; for ( CoverDetails cd : ctx . covers ) { if ( cd . getX ( ) >= startP . x && cd . getX ( ) <= endP . x && cd . getY ( ) >= startP . y && cd . getY ( ) <= endP . y ) { ctx . addSelection ( cd ) ; } } } ctx . mainRepaint ( ) ; } } }
tr	7	private void randomPlayerGroup ( int start , int end ) { Game game = new Game ( ) ; RandomPlayer randomPlayer = new RandomPlayer ( ) ; for ( int i = start ; i < end && i < players . size ( ) ; i ++ ) { PlayerEnlist player = players . get ( i ) ; for ( int j = 0 ; j < groupSize - 1 ; j ++ ) { game . startGame ( player . player , randomPlayer ) ; player . newMatch ( ) ; if ( game . colourOfWinner ( ) == Game . FIRST_PLAYER_COLOUR ) { player . newRandomMatchWon ( ) ; } else if ( game . colourOfWinner ( ) == Game . EMPTY_STONE_COLOUR ) { player . newRandomMatchDraw ( ) ; } game . startGame ( randomPlayer , player . player ) ; player . newMatch ( ) ; if ( game . colourOfWinner ( ) == Game . SECOND_PLAYER_COLOUR ) { player . newRandomMatchWon ( ) ; } else if ( game . colourOfWinner ( ) == Game . EMPTY_STONE_COLOUR ) { player . newRandomMatchDraw ( ) ; } } } }
tr	0	public void setNbRows ( int nb ) { rows = nb ; }
tr	8	String classToType ( class cls ) { if ( cls == Point . class ) { return "int2" ; } else if ( cls == Integer . TYPE || cls == Integer . class ) { return "int" ; } else if ( cls == double . TYPE || cls == double . class ) { return "double" ; } else if ( cls == String . class ) { return "String" ; } else if ( cls == boolean . TYPE || cls == boolean . class ) { return "boolean" ; } else { return null ; } }
tr	4	private void getAnswers ( DatabaseConnection db , Connection conn , DefaultMutableTreeNode parentQuestion , int questionID ) { String sql = "SELECT * FROM `ForumComments` WHERE QuestionID = '" + questionID + "'" ; if ( userType == 1 ) { sql += " and (Visibility = 0 or Author='" + userID + "')" ; } ResultSet rs = db . getResults ( conn , sql ) ; try { while ( rs . next ( ) ) { int commentID = rs . getInt ( "CommentID" ) ; int authorID = rs . getInt ( "Author" ) ; String author = HelpFunctions . getAuthor ( authorID ) ; DefaultMutableTreeNode answer = new DefaultMutableTreeNode ( new BookInfo ( author , rs . getString ( "Comment" ) , commentID , 2 ) ) ; parentQuestion . add ( answer ) ; String answerSQL = "Select * from `ForumComments` where ReplyID = '" + commentID + "'" ; ResultSet answerRS = db . getResults ( conn , answerSQL ) ; while ( answerRS . next ( ) ) ; { getComments ( db , conn , answer , commentID ) ; } } } catch ( SQLException ex ) { Logger . getLogger ( LandingForm . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } }
