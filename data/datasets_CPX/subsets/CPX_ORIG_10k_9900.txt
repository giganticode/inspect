te	1	public void mouseMoved ( MouseEvent me ) { if ( hmc . completion >= 1 ) ui . statusBar . setMousePoint ( toWorldSpace ( new Vec ( me . getPoint ( ) ) ) ) ; }
te	0	@ XmlElementDecl ( namespace = "" , name = "fOpen" ) @ XmlJavaTypeAdapter ( CollapsedStringAdapter . class ) public JAXBElement < String > createFOpen ( String value ) { return new JAXBElement < String > ( _FOpen_QNAME , String . class , null , value ) ; }
te	9	private static void uniformCrossoverForRoutes ( Individual child1 , Individual child2 , Individual parent1 , Individual parent2 , ProblemInstance problemInstance ) { int coin ; Individual temp1 , temp2 ; for ( int period = 0 ; period < problemInstance . periodCount ; period ++ ) { coin = Utility . randomIntInclusive ( 1 ) ; if ( coin == 0 ) { temp1 = child1 ; temp2 = child2 ; } else { temp1 = child2 ; temp2 = child1 ; } for ( int vehicle = 0 ; vehicle < problemInstance . vehicleCount ; vehicle ++ ) { ArrayList < Integer > parent1Route = parent1 . routes . get ( period ) . get ( vehicle ) ; ArrayList < Integer > parent2Route = parent2 . routes . get ( period ) . get ( vehicle ) ; ArrayList < Integer > child1Route = temp1 . routes . get ( period ) . get ( vehicle ) ; ArrayList < Integer > child2Route = temp2 . routes . get ( period ) . get ( vehicle ) ; child1Route . clear ( ) ; child2Route . clear ( ) ; for ( int clientIndex = 0 ; clientIndex < parent1Route . size ( ) ; clientIndex ++ ) { int node = parent1Route . get ( clientIndex ) ; if ( temp1 . periodAssignment [ period ] [ node ] ) child1Route . add ( node ) ; } for ( int clientIndex = 0 ; clientIndex < parent2Route . size ( ) ; clientIndex ++ ) { int node = parent2Route . get ( clientIndex ) ; if ( temp2 . periodAssignment [ period ] [ node ] ) child2Route . add ( node ) ; } } for ( int client = 0 ; client < problemInstance . customerCount ; client ++ ) { if ( temp1 . periodAssignment [ period ] [ client ] == true ) { if ( RouteUtilities . doesRouteContainThisClient ( problemInstance , temp1 , period , client ) == false ) { int vehicle = 0 ; temp1 . routes . get ( period ) . get ( vehicle ) . add ( client ) ; } } if ( temp2 . periodAssignment [ period ] [ client ] == true ) { if ( RouteUtilities . doesRouteContainThisClient ( problemInstance , temp2 , period , client ) == false ) { temp2 . routes . get ( period ) . get ( 0 ) . add ( client ) ; } } } } }
te	3	private static void begin ( ) { Scanner sc = new Scanner ( System . in ) ; int count = 0 ; int [ ] [ ] rounds = new int [ NROUNDS ] [ NDICES ] ; while ( sc . hasNext ( ) ) { String input = sc . nextLine ( ) ; int i = 0 ; StringTokenizer st = new StringTokenizer ( input ) ; while ( st . hasMoreTokens ( ) ) { rounds [ count ] [ i ++ ] = Integer . parseInt ( st . nextToken ( ) ) ; } Arrays . sort ( rounds [ count ] ) ; if ( ++ count % NCATEGORIES == 0 ) { solve ( rounds ) ; count = 0 ; } } }
te	3	private void DrawHorizontalLines ( ) { for ( int i = 0 ; i < mNumPointsX ; i ++ ) { if ( i % 4 == 0 ) { mBrightBlue . SetColor ( ) ; } else { mDarkBlue . SetColor ( ) ; } glBegin ( GL_LINE_STRIP ) ; { for ( int j = 0 ; j < mNumPointsY ; j ++ ) { Vector2 position = mGridPoints [ i ] [ j ] . GetPosition ( ) ; glVertex2f ( position . X , position . Y ) ; } } glEnd ( ) ; } }
te	0	public void setTarget ( String target ) { this . target = target ; }
te	3	@ Override public List < Score > getHighscore ( ) { if ( scores != null ) { return scores ; } List < Score > ret = new ArrayList < Score > ( 10 ) ; if ( ! Files . exists ( db ) ) { return ret ; } try { readIntoList ( ret ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } Collections . sort ( ret , Collections . reverseOrder ( ) ) ; scores = ret ; return ret ; }
te	3	@ Override public void iterate ( Imagem imagem , ImageIteratorCallback callback ) { if ( imagem == null ) { return ; } int lim = Math . max ( imagem . getWidth ( ) , imagem . getHeight ( ) ) ; for ( int i = 0 ; i < lim ; i ++ ) { int y = imagem . getHeight ( ) - Math . min ( i , imagem . getHeight ( ) - 1 ) - 1 ; for ( int x = i ; x < imagem . getWidth ( ) ; x ++ ) { callback . callback ( x , y ) ; } } }
te	8	public void run ( ) { boolean eof = false ; byte [ ] buffer = new byte [ 65536 ] ; int timeout = 0 ; while ( ! eof && ! super . killed ( ) ) { int read = 0 ; try { read = in . read ( buffer ) ; } catch ( SocketTimeoutException ste ) { if ( ! super . killed ( ) ) { timeout ++ ; if ( timeout > 225 ) { ptc . printLogMessage ( "Connection timed out" ) ; return ; } continue ; } } catch ( IOException e ) { ptc . printLogMessage ( "Unable to read from socket" ) ; return ; } timeout = 0 ; if ( read == - 1 ) { ptc . printLogMessage ( "Connection reached end" ) ; eof = true ; } else { try { out . write ( buffer , 0 , read ) ; } catch ( IOException e ) { ptc . printLogMessage ( "Error writing to socket" ) ; return ; } } } ptc . interrupt ( ) ; }
te	9	@ Override public void run ( ) { for ( ; ; ) { synchronized ( iter ) { if ( iter . hasNext ( ) ) { currentZipEntry = iter . next ( ) ; } else { wr . getWw ( ) . threadOutMessage ( "Finished" , id , 4 ) ; return ; } } if ( ! config . isForceRun ( ) ) { wr . getWw ( ) . threadOutMessage ( " " + currentZipEntry , id , 4 ) ; } else { wr . getWw ( ) . threadOutMessage ( currentZipEntry + " (forced)" , id , 4 ) ; } if ( 1 != currentZipEntry . getValue ( ) || config . isForceRun ( ) ) { df . load ( currentZipEntry . getKey ( ) ) ; try { synchronized ( db ) { if ( df . valid ) { db . storeForecast ( df . forecast1 ) ; db . storeForecast ( df . forecast3 ) ; db . storePast ( df . past ) ; db . updateZipSuccess ( currentZipEntry . getKey ( ) ) ; } else { db . updateZipFail ( currentZipEntry . getKey ( ) ) ; } db . commit ( ) ; } } catch ( Exception e ) { wr . setFail ( ) ; wr . getWw ( ) . threadOutMessage ( currentZipEntry + " failed" , id , 2 ) ; } if ( Thread . interrupted ( ) || config . isStopProgram ( ) ) { break ; } } } wr . getWw ( ) . threadOutMessage ( "Finished" , id , 3 ) ; }
te	3	public static void main ( String args [ ] ) { javax . swing . SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { try { UIManager . setLookAndFeel ( UIManager . getSystemLookAndFeelClassName ( ) ) ; java . util . Enumeration keys = UIManager . getDefaults ( ) . keys ( ) ; while ( keys . hasMoreElements ( ) ) { Object key = keys . nextElement ( ) ; Object value = UIManager . get ( key ) ; if ( ( ( String ) key ) . endsWith ( "font" ) ) { Font oldFont = UIManager . getDefaults ( ) . getFont ( key ) ; UIManager . put ( key , oldFont . deriveFont ( oldFont . getSize ( ) + 2.0f ) ) ; } } } catch ( Exception e ) { } createAndShowGUI ( ) ; } } ) ; }
te	0	@ Override public String accept ( final NodeVisitor visitor ) { return visitor . visit ( this ) ; }
te	9	@ Override public boolean equals ( Object obj ) { if ( obj == null ) { return false ; } if ( getClass ( ) != obj . getClass ( ) ) { return false ; } final MehMurray other = ( MehMurray ) obj ; if ( ! Objects . equals ( this . name , other . name ) ) { return false ; } if ( this . wins != other . wins ) { return false ; } if ( this . losses != other . losses ) { return false ; } if ( this . ties != other . ties ) { return false ; } if ( ! Objects . equals ( this . letter , other . letter ) ) { return false ; } if ( this . matchSeconds != other . matchSeconds ) { return false ; } if ( this . keepScore != other . keepScore ) { return false ; } if ( this . enableSound != other . enableSound ) { return false ; } if ( this . exitMM != other . exitMM ) { return false ; } return true ; }
te	5	public IntegerRegister getIntRegister ( String regName ) { IntegerRegister intReg = null ; int size = intRegBank . size ( ) ; try { for ( int index = 0 ; index < size ; index ++ ) { try { intReg = intRegBank . get ( index ) ; } catch ( IndexOutOfBoundsException e1 ) { log . error ( "Invalid index specified: " + index ) ; return null ; } if ( intReg != null ) { if ( intReg . getId ( ) . equals ( IntRegC . valueOf ( regName ) ) ) { return intReg ; } } } } catch ( IllegalArgumentException e ) { log . error ( "Invalid Int Register name requested: " + regName ) ; intReg = null ; } return intReg ; }
te	9	protected int countKeysInColumns ( final int [ ] keyColumns ) throws IOException { this . resetReader ( ) ; long lineCount = 0 ; int number = this . keyToId . keySet ( ) . size ( ) ; try { String line = null ; this . parsingComments = true ; while ( ( line = this . readLine ( ) ) != null ) { if ( ( line . isEmpty ( ) && this . skipEmptyLines ) || ! checkLine ( line ) ) continue ; lineCount ++ ; final String [ ] lineSplit = StringExt . split ( line , this . inSplit ) ; final String [ ] keyEntries = this . extractKeyEntries ( lineSplit ) ; for ( final String key : keyEntries ) { if ( key . isEmpty ( ) ) continue ; if ( this . absIdFilePath != null ) { if ( ! this . keyToId . containsKey ( key ) ) { throw new IOException ( "The similarity file contains wrong keys" ) ; } } else { if ( ! this . keyToId . containsKey ( key ) ) { this . keyToId . put ( key , number ) ; this . idToKey . put ( number ++ , key ) ; } } } } } catch ( final IOException e ) { e . printStackTrace ( ) ; } this . setTotalLineCount ( lineCount ) ; return this . keyToId . keySet ( ) . size ( ) ; }
te	2	public static Screen findById ( int id , BaseSetting bs ) { Connection connection = bs . getConnection ( ) ; Screen screen = null ; try { String query = "SELECT * FROM Screen WHERE id_s = ?" ; PreparedStatement p_statement = connection . prepareStatement ( query ) ; p_statement . setInt ( 1 , id ) ; ResultSet rs = p_statement . executeQuery ( ) ; if ( rs . next ( ) ) { int ids = rs . getInt ( "id_s" ) ; String names = rs . getString ( "name_s" ) ; screen = new Screen ( ids , names ) ; } } catch ( SQLException sqle ) { System . out . println ( "ERREUR" ) ; sqle . printStackTrace ( ) ; } return screen ; }
te	4	private void print ( ) { try { final PrinterJob printJob = PrinterJob . getPrinterJob ( ) ; boolean pDialogState = printJob . printDialog ( ) ; if ( ! pDialogState ) return ; Book book = new Book ( ) ; PageFormat pageFormat = printJob . pageDialog ( printJob . defaultPage ( ) ) ; book . append ( FractalShapeMaker . viewer . viewer , pageFormat ) ; printJob . setPageable ( book ) ; printJob . setJobName ( "Fractal Shape Maker" ) ; Thread t = new Thread ( ) { public void run ( ) { try { printJob . print ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } ; } ; t . setName ( "Print thread" ) ; t . start ( ) ; } catch ( java . security . AccessControlException ace ) { String errmsg = "Applet access control exception; to allow " + "access to printer  run policytool and set\n" + "permission for \"queuePrintJob\" in " + "RuntimePermission." ; JOptionPane . showMessageDialog ( this , errmsg , "Printer Access Error" , JOptionPane . ERROR_MESSAGE ) ; } catch ( Exception ex ) { showException ( "Error while printing" , ex ) ; } }
te	4	public static < T extends Comparable < ? super T >> void sort ( T [ ] a ) { boolean swapped = true ; while ( swapped ) { swapped = false ; for ( int i = 1 ; i < a . length ; i ++ ) { if ( isLess ( a [ i ] , a [ i - 1 ] ) ) { exchange ( a , i , i - 1 ) ; swapped = true ; } } } }
te	1	public Object getSpecialSequenceCompanion ( String specSeq ) throws IllegalArgumentException { TokenizerProperty prop = getSpecialSequence ( specSeq ) ; if ( prop != null ) { return prop . getCompanion ( ) ; } else { return null ; } }
te	3	protected int getInt ( final Map < String , String > mapProps , final String strKey , final String strColumnName ) { int iRet = UNAVAILABLE ; if ( mapProps != null && mapProps . containsKey ( strKey ) ) try { iRet = Integer . parseInt ( mapProps . get ( strKey ) ) ; } catch ( final Exception exc ) { LOGGER . warning ( "Header property '" + strKey + "' in column '" + strColumnName + "' is not representing a valid integer value: " + mapProps . get ( strKey ) + " cannot be parsed." ) ; } return iRet ; }
te	2	public SeaFieldPanel ( ) { setLayout ( null ) ; seaButtonMatrix = createSeaField ( ) ; for ( int row = 0 ; row < 10 ; row ++ ) for ( int col = 0 ; col < 10 ; col ++ ) add ( seaButtonMatrix [ row ] [ col ] ) ; }
te	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( VEngineLogo . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( VEngineLogo . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( VEngineLogo . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( VEngineLogo . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { new VEngineLogo ( ) . setVisible ( true ) ; } } ) ; }
te	9	private boolean r_postlude ( ) { int among_var ; int v_1 ; replab0 : while ( true ) { v_1 = cursor ; lab1 : do { bra = cursor ; among_var = find_among ( a_0 , 4 ) ; if ( among_var == 0 ) { break lab1 ; } ket = cursor ; switch ( among_var ) { case 0 : break lab1 ; case 1 : slice_from ( "i" ) ; break ; case 2 : slice_from ( "u" ) ; break ; case 3 : slice_from ( "y" ) ; break ; case 4 : if ( cursor >= limit ) { break lab1 ; } cursor ++ ; break ; } continue replab0 ; } while ( false ) ; cursor = v_1 ; break replab0 ; } return true ; }
te	5	private void listImagenesValueChanged ( javax . swing . event . ListSelectionEvent evt ) { if ( this . listImagenes . getValueIsAdjusting ( ) == false ) { if ( this . listImagenes . getSelectedIndex ( ) >= 0 ) { FileInputStream imgStream = null ; try { String selected = ( String ) this . listImagenes . getSelectedValue ( ) ; File f = new File ( selected ) ; imgStream = new FileInputStream ( selected ) ; BufferedImage myImg = ImageIO . read ( imgStream ) ; ImageIcon preview = new ImageIcon ( myImg ) ; preview = new ImageIcon ( preview . getImage ( ) . getScaledInstance ( 230 , 130 , java . awt . Image . SCALE_SMOOTH ) ) ; this . btnPreview . setIcon ( preview ) ; this . btnPreview . setDisabledIcon ( preview ) ; } catch ( FileNotFoundException ex ) { Logger . getLogger ( FrmRegistrarObra . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( IOException ex ) { Logger . getLogger ( FrmRegistrarObra . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } finally { try { imgStream . close ( ) ; } catch ( IOException ex ) { Logger . getLogger ( FrmRegistrarObra . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } } } } }
te	5	private boolean boardIsFull ( ) { for ( int x = 0 ; x < boardWidth ; x ++ ) { for ( int y = 0 ; y < boardWidth ; y ++ ) { if ( sudokuTextFields [ y ] [ x ] . getText ( ) == null || sudokuTextFields [ y ] [ x ] . getText ( ) . isEmpty ( ) || boardVals [ y ] [ x ] == NULL_VAL ) return false ; } } return true ; }
te	6	@ Override public int insert ( InsertContext ctx , ConnectionHolder conn ) throws SQLException { int result = handleUpdate ( conn , ctx . getSql ( ) , ctx . getParameters ( ) ) ; Object target = ctx . getTarget ( ) ; if ( target != null ) { IdModel idModel = ctx . getTable ( ) . getIdModel ( ) ; if ( idModel != null && idModel . isIdentity ( ) ) { class < ? > idType = idModel . getPropertyType ( ) ; PreparedStatement stmt = null ; ResultSet rs = null ; try { stmt = prepareStatement ( conn . getConnection ( ) , "select @@IDENTITY" ) ; rs = stmt . executeQuery ( ) ; if ( rs . next ( ) ) { Object idValue = RowUtils . autoConvert ( rs , idType ) ; idModel . getProperty ( ) . invokeWrite ( target , idValue ) ; } } catch ( Exception e ) { throw new SQLException ( e ) ; } finally { DbUtils . closeQuietly ( rs ) ; DbUtils . close ( stmt ) ; } } } return result ; }
te	6	private Solver createAnySudoku ( int numberOfClues ) { Grid g = new Grid ( ) ; Random r = new Random ( ) ; while ( true ) { int cnt = 0 ; while ( true ) { if ( cnt >= numberOfClues ) break ; int row = r . nextInt ( 9 ) ; int col = r . nextInt ( 9 ) ; int val = r . nextInt ( 9 ) + 1 ; if ( g . isSet ( row , col ) ) continue ; int row3 = row / 3 ; int block = row3 * 3 + col / 3 ; boolean contained = g . colContains ( col , val ) | g . blockContains ( block , val ) | g . rowContains ( row , val ) ; if ( ! contained ) { g . set ( row , col , val ) ; cnt ++ ; } } Solver s = new Solver ( g ) ; s . setFirstSolutionOnly ( false ) ; s . setQuiet ( true ) ; s . run ( ) ; if ( s . getSolutions ( ) > 0 ) { return s ; } } }
te	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( jfProgressBar . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( jfProgressBar . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( jfProgressBar . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( jfProgressBar . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { jfProgressBar dialog = new jfProgressBar ( new javax . swing . JFrame ( ) , true ) ; dialog . addWindowListener ( new java . awt . event . WindowAdapter ( ) { @ Override public void windowClosing ( java . awt . event . WindowEvent e ) { System . exit ( 0 ) ; } } ) ; dialog . setVisible ( true ) ; } } ) ; }
te	4	public Player getWinner ( ) { Player winner ; if ( moved . contains ( Player . FIRST ) && field . getTotalNumberOfAtomsForPlayer ( Player . FIRST ) == 0 ) { winner = Player . SECOND ; } else if ( moved . contains ( Player . SECOND ) && field . getTotalNumberOfAtomsForPlayer ( Player . SECOND ) == 0 ) { winner = Player . FIRST ; } else { winner = Player . NONE ; } return winner ; }
te	7	@ SuppressWarnings ( "RedundantIfStatement" ) @ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; Pair pair = ( Pair ) o ; if ( first != null ? ! first . equals ( pair . first ) : pair . first != null ) return false ; if ( second != null ? ! second . equals ( pair . second ) : pair . second != null ) return false ; return true ; }
te	0	public static void assertEquals ( final CheckBox expected , final CheckBox actual ) { DatabaseAbstractQuestionTest . assertEquals ( expected , actual ) ; assert . assertEquals ( expected . getQuestionString ( ) , actual . getQuestionString ( ) ) ; assert . assertEquals ( expected . getAnswers ( ) , actual . getAnswers ( ) ) ; assert . assertEquals ( expected . getOptions ( ) , actual . getOptions ( ) ) ; }
te	4	public void addController ( AbstractController controleur ) { for ( int i = 0 ; i < taille ; i ++ ) for ( int j = 0 ; j < taille ; j ++ ) if ( controleur instanceof PlacementController ) cases [ i ] [ j ] . addMouseListener ( ( PlacementController ) controleur ) ; else if ( controleur instanceof JeuController ) cases [ i ] [ j ] . addMouseListener ( ( JeuController ) controleur ) ; }
te	6	public void keyPressed ( KeyEvent e ) { int offset = ( e . getKeyCode ( ) == KeyEvent . VK_UP ) ? ( - 7 ) : ( ( e . getKeyCode ( ) == KeyEvent . VK_DOWN ) ? ( + 7 ) : ( ( e . getKeyCode ( ) == KeyEvent . VK_LEFT ) ? ( - 1 ) : ( ( e . getKeyCode ( ) == KeyEvent . VK_RIGHT ) ? ( + 1 ) : 0 ) ) ) ; int newDay = getDay ( ) + offset ; if ( ( newDay >= 1 ) && ( newDay <= calendar . getMaximum ( Calendar . DAY_OF_MONTH ) ) ) { setDay ( newDay ) ; } }
te	7	@ Test public void invalidBillingAddrCreateProfile ( ) { Address billing = getTestBillingAddress ( ) ; Card card = getTestCard ( ) ; ProfileResponse createdProfile = null ; try { createdProfile = beanstream . profiles ( ) . createProfile ( card , null ) ; assert . fail ( "Fail test because the billing address was empty" ) ; } catch ( BeanstreamApiException ex ) { assert . assertTrue ( "" , ex . getHttpStatusCode ( ) == 400 ) ; } try { billing . setAddressLine1 ( null ) ; createdProfile = beanstream . profiles ( ) . createProfile ( card , billing ) ; assert . fail ( "Fail test because the billing address line 1 was empty" ) ; } catch ( BeanstreamApiException ex ) { assert . assertTrue ( "" , ex . getHttpStatusCode ( ) == 400 ) ; } try { billing . setAddressLine1 ( "12635 NW 98TH ST" ) ; billing . setCity ( null ) ; createdProfile = beanstream . profiles ( ) . createProfile ( card , billing ) ; assert . fail ( "Fail test because the billing address city was empty" ) ; } catch ( BeanstreamApiException ex ) { assert . assertTrue ( "" , ex . getHttpStatusCode ( ) == 400 ) ; } try { billing . setCity ( "Miami" ) ; billing . setCountry ( null ) ; createdProfile = beanstream . profiles ( ) . createProfile ( card , billing ) ; assert . fail ( "Fail test because the billing address country was empty" ) ; } catch ( BeanstreamApiException ex ) { assert . assertTrue ( "" , ex . getHttpStatusCode ( ) == 400 ) ; } try { billing . setCountry ( "US" ) ; billing . setEmailAddress ( null ) ; createdProfile = beanstream . profiles ( ) . createProfile ( card , billing ) ; assert . fail ( "Fail test because the billing address email was empty" ) ; } catch ( BeanstreamApiException ex ) { assert . assertTrue ( "" , ex . getHttpStatusCode ( ) == 400 ) ; } try { billing . setEmailAddress ( "pagarciaortega@gmail.com" ) ; billing . setPhoneNumber ( null ) ; createdProfile = beanstream . profiles ( ) . createProfile ( card , billing ) ; assert . fail ( "Fail test because the billing address phone number was empty" ) ; } catch ( BeanstreamApiException ex ) { assert . assertTrue ( "" , ex . getHttpStatusCode ( ) == 400 ) ; } try { billing . setPhoneNumber ( "786-241-8879" ) ; billing . setProvince ( null ) ; createdProfile = beanstream . profiles ( ) . createProfile ( card , billing ) ; assert . fail ( "Fail test because the billing address province/state was empty" ) ; } catch ( BeanstreamApiException ex ) { assert . assertTrue ( "" , ex . getHttpStatusCode ( ) == 400 ) ; } }
te	7	public static int minCut ( String s ) { if ( s . length ( ) == 0 ) return 0 ; int length = s . length ( ) ; int [ ] dp = new int [ s . length ( ) + 1 ] ; boolean [ ] [ ] palin = new boolean [ s . length ( ) ] [ s . length ( ) ] ; for ( int i = s . length ( ) ; i >= 0 ; i -- ) { dp [ i ] = length - i ; } for ( int i = length - 1 ; i >= 0 ; i -- ) { for ( int j = i ; j < length ; j ++ ) { if ( s . charAt ( i ) == s . charAt ( j ) && ( j - i < 2 || palin [ i + 1 ] [ j - 1 ] ) ) { palin [ i ] [ j ] = true ; dp [ i ] = Math . min ( dp [ j ] , dp [ i ] ) ; } } } return dp [ 0 ] - 1 ; }
te	6	public static ConsumptionModel getConsumptionModelForWaterHeater ( String type ) { if ( ! type . equals ( "p" ) && ! type . equals ( "q" ) ) { System . err . println ( "non-existent consumption model" ) ; System . exit ( 15 ) ; } if ( type . equals ( "p" ) ) { String message = "{\"n\":0 \"params\":[{\"n\":1 \"values\":[{\"p\":4264.666666666667 \"d\":10 \"s\":0}]}]}" ; try { return new ConsumptionModel ( message , "p" ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } else if ( type . equals ( "q" ) ) { String message = "{\"n\":0 \"params\":[{\"n\":1 \"values\":[{\"q\":-559.4066666666666 \"d\":10 \"s\":0}]}]}" ; try { return new ConsumptionModel ( message , "q" ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } return null ; }
te	5	public Set < State > getStates ( ) { expandSingleton ( ) ; Set < State > visited ; if ( isDebug ( ) ) visited = new LinkedHashSet < State > ( ) ; else visited = new HashSet < State > ( ) ; LinkedList < State > worklist = new LinkedList < State > ( ) ; worklist . add ( initial ) ; visited . add ( initial ) ; while ( worklist . size ( ) > 0 ) { State s = worklist . removeFirst ( ) ; Collection < Transition > tr ; if ( isDebug ( ) ) tr = s . getSortedTransitions ( false ) ; else tr = s . transitions ; for ( Transition t : tr ) if ( ! visited . contains ( t . to ) ) { visited . add ( t . to ) ; worklist . add ( t . to ) ; } } return visited ; }
te	7	public void computeDistance ( int binaryCounter ) { this . distance = 0 ; String i1 = Integer . toBinaryString ( binaryCounter ) ; String i2 = Integer . toBinaryString ( this . binaryCounter ) ; while ( i1 . length ( ) < Policy . getInstance ( ) . getBinaryCounterSize ( ) ) { i1 = "0" + i1 ; } while ( i2 . length ( ) < Policy . getInstance ( ) . getBinaryCounterSize ( ) ) { i2 = "0" + i2 ; } for ( int i = 0 ; i < Policy . getInstance ( ) . getBinaryCounterSize ( ) ; i ++ ) { if ( i1 . charAt ( i ) == 0 && i2 . charAt ( i ) == 1 ) { this . distance ++ ; } else if ( i1 . charAt ( i ) == 1 && i2 . charAt ( i ) == 0 ) { this . distance ++ ; this . isNegativeDistance = true ; } } }
te	6	private static void parseRelationEndPoint ( Relationship . EndPoint endPoint , String expr ) { String label = encryptStereotypeDelimiters ( expr ) ; Styles . Decoration decoration = Styles . Decoration . None ; if ( expr . contains ( "<>" ) ) { decoration = Styles . Decoration . Aggregation ; label = label . replace ( "<>" , "" ) ; } else if ( expr . contains ( "++" ) ) { decoration = Styles . Decoration . Composition ; label = label . replace ( "++" , "" ) ; } else if ( expr . contains ( "+" ) ) { decoration = Styles . Decoration . Aggregation ; label = label . replace ( "+" , "" ) ; } else if ( expr . contains ( "<" ) || expr . contains ( ">" ) ) { decoration = Styles . Decoration . -> ; label = label . replace ( "<" , "" ) . replace ( ">" , "" ) ; } else if ( expr . contains ( "^" ) ) { decoration = Styles . Decoration . Inheritance ; label = label . replace ( "^" , "" ) ; } label = decryptStereotypeDelimiters ( label ) ; endPoint . usingDecoration ( decoration ) . usingLabel ( label . trim ( ) ) ; }
te	4	public void updateShadow ( ) { for ( int i = 0 ; i < MAX_SHADOWS ; i ++ ) { if ( shadowCasters [ i ] == - 1 ) return ; Surface surface = ( Surface ) wires . elementAt ( shadowCasters [ i ] ) ; for ( int j = surface . numPoints - 1 ; j >= 0 ; j -- ) { Vector3d p = points . elementAt ( surface . points [ j ] ) ; Vector3d q = points . elementAt ( shadows [ i ] . points [ surface . numPoints - 1 - j ] ) ; q . set ( p ) ; if ( app . landscape != null ) q . z = app . landscape . getHeight ( q . x , q . y ) ; else q . z = 0 ; } } }
te	3	public void run ( ) throws IOException { final Map < String , String > header = telemetryReader . query ( HEADER_PARAMETERS ) ; if ( directory != null ) { final String name = header . get ( "name" ) ; final File file = getUnusedFile ( name ) ; System . out . println ( "Writing telemetry to " + file . getAbsolutePath ( ) ) ; writer = new PrintWriter ( file ) ; } else { writer = null ; } System . out . println ( header ) ; if ( writer != null ) { writer . println ( header ) ; } telemetryReader . start ( ) ; try { Thread . sleep ( 1000000 ) ; } catch ( final InterruptedException e ) { e . printStackTrace ( ) ; } }
te	3	private void executar ( ) { while ( true ) { try { business . enviarAck ( user ) ; } catch ( BusinessException ex ) { Logger . getLogger ( ControllerContatos . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } try { Thread . sleep ( 3000 ) ; } catch ( InterruptedException ex ) { Logger . getLogger ( ControllerContatos . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } } }
te	0	@ Override public void playSound ( ) { }
te	7	public void method360 ( int i , int j , int k ) { for ( int i1 = 0 ; i1 < anIntArray1451 . length ; i1 ++ ) { int j1 = anIntArray1451 [ i1 ] >> 16 & ff ; j1 += i ; if ( j1 < 0 ) j1 = 0 ; else if ( j1 > 255 ) j1 = 255 ; int k1 = anIntArray1451 [ i1 ] >> 8 & ff ; k1 += j ; if ( k1 < 0 ) k1 = 0 ; else if ( k1 > 255 ) k1 = 255 ; int l1 = anIntArray1451 [ i1 ] & ff ; l1 += k ; if ( l1 < 0 ) l1 = 0 ; else if ( l1 > 255 ) l1 = 255 ; anIntArray1451 [ i1 ] = ( j1 << 16 ) + ( k1 << 8 ) + l1 ; } }
te	0	public void execute ( File inputDirectory , String outputFile ) throws IOException { write ( new File ( outputFile ) , parse ( inputDirectory ) ) ; }
te	4	@ Override public boolean equals ( Object olio ) { if ( olio == null ) { return false ; } if ( this . getClass ( ) != olio . getClass ( ) ) { return false ; } Kysymys verrattava = ( Kysymys ) olio ; if ( ! verrattava . kysymys . equals ( this . kysymys ) ) { return false ; } if ( ! verrattava . tyyppi . equals ( this . tyyppi ) ) { return false ; } return true ; }
te	3	public int AppendTriple ( String Index_DIR , ArrayList < KeyValue > keyValues ) { Store store ; int responseCode = 0 ; try { store = new Store ( storeUrl ) ; String turtle = "" ; for ( KeyValue tmpObject : keyValues ) { String s = Index_DIR ; String p = tmpObject . getKey ( ) ; String o = tmpObject . getValue ( ) ; turtle = "<" + graphUri + "/ID#" + s + "> <" + graphUri + "/KEY#" + URLEncoder . encode ( p , "UTF-8" ) + "> \"" + o + "\" .\n" ; String response = store . append ( graphUri , turtle , Store . InputFormat . TURTLE ) ; responseCode = Integer . parseInt ( response . substring ( 0 , 3 ) ) ; } return 1 ; } catch ( MalformedURLException e ) { message = e . getMessage ( ) ; return 0 ; } catch ( IOException e ) { message = e . getMessage ( ) ; return 0 ; } }
te	7	@ Override public HandshakeState acceptHandshakeAsClient ( ClientHandshake request , ServerHandshake response ) { if ( failed ) { return HandshakeState . NOT_MATCHED ; } try { if ( ! response . getFieldValue ( "Sec-WebSocket-Origin" ) . equals ( request . getFieldValue ( "Origin" ) ) || ! basicAccept ( response ) ) { return HandshakeState . NOT_MATCHED ; } byte [ ] content = response . getContent ( ) ; if ( content == null || content . length == 0 ) { throw new IncompleteHandshakeException ( ) ; } if ( Arrays . equals ( content , createChallenge ( request . getFieldValue ( "Sec-WebSocket-Key1" ) , request . getFieldValue ( "Sec-WebSocket-Key2" ) , request . getContent ( ) ) ) ) { return HandshakeState . MATCHED ; } else { return HandshakeState . NOT_MATCHED ; } } catch ( InvalidHandshakeException e ) { throw new RuntimeException ( "bad handshakerequest" , e ) ; } }
te	2	private void initListeners ( ) { labsTree . addTreeSelectionListener ( new TreeSelectionListener ( ) { @ Override public void valueChanged ( TreeSelectionEvent ev ) { int [ ] params = getSelectedLabIndex ( ) ; if ( params == null ) return ; int number = params [ 0 ] ; int index = params [ 1 ] ; description . setText ( labs [ number ] . getDescription ( index ) ) ; } } ) ; executeButton . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent ev ) { int [ ] params = getSelectedLabIndex ( ) ; if ( params == null ) return ; int number = params [ 0 ] ; int index = params [ 1 ] ; labs [ number ] . execute ( index ) ; } } ) ; }
te	3	@ Override protected void setup ( ) { init ( getArguments ( ) ) ; paintLog ( Constants . READY , situated , destination ) ; addBehaviour ( new CyclicBehaviour ( this ) { public void action ( ) { ACLMessage msg = receive ( ) ; if ( msg != null ) { ACLMessage reply = null ; try { reply = chooseAction ( msg ) ; } catch ( UnreadableException | IOException e ) { ExceptionUtils . handleException ( e ) ; } if ( reply != null ) { send ( reply ) ; } } else { block ( ) ; } } } ) ; }
te	2	public static BenoitNumber valueOf ( String s , int type ) { BenoitNumber bn = null ; switch ( type ) { case DOUBLE_TYPE : bn = new BenoitNumber ( double . valueOf ( s ) . doubleValue ( ) ) ; break ; case BIG_TYPE : bn = new BenoitNumber ( new BigDecimal ( s ) ) ; break ; default : throw new IllegalArgumentException ( "Invalid type" ) ; } return bn ; }
te	2	public static boolean isPermutation ( long ... numbers ) { String digits = sortString ( long . toString ( numbers [ 0 ] ) ) ; for ( int i = 1 ; i < numbers . length ; i ++ ) { if ( ! digits . equals ( sortString ( long . toString ( numbers [ i ] ) ) ) ) { return false ; } } return true ; }
te	3	private void displayFreeBedSummary ( ) { try { if ( Data . size ( ) == 0 ) { System . err . println ( "No results found for the input criteria" ) ; return ; } for ( T data : Data ) { @ SuppressWarnings ( "rawtypes" ) SearchBean bean = ( SearchBean ) data ; FreeBedSummaryBean summary = ( FreeBedSummaryBean ) bean . getObjectInfo ( ) ; String hostelName = Hostels . getInstance ( ) . get ( bean . getObjectId ( ) ) . getName ( ) ; System . out . println ( "Hostel : " + hostelName + "  From " + summary . getStartDate ( ) . toString ( ) + " to " + summary . getEndDate ( ) . toString ( ) + ": " + summary . getNoOfBeds ( ) + " beds available between $" + summary . getMinPrice ( ) . toString ( ) + " to $" + summary . getMaxPrice ( ) . toString ( ) ) ; } } catch ( DataBaseReadWriteException | IdentifierNotFoundException | InvalidIdentifierException e ) { e . printStackTrace ( ) ; } }
te	5	@ Override public void draw ( Graphics2D g ) { g . setColor ( Color . WHITE ) ; g . setStroke ( new BasicStroke ( 5 ) ) ; for ( Direction dir : directions ) { switch ( dir ) { case NORTH : g . drawLine ( east , north , west , north ) ; break ; case EAST : g . drawLine ( east , north , east , south ) ; break ; case SOUTH : g . drawLine ( east , south , west , south ) ; break ; case WEST : g . drawLine ( west , north , west , south ) ; break ; default : break ; } } }
te	6	public String nextTo ( char delimiter ) throws JSONException { StringBuffer sb = new StringBuffer ( ) ; for ( ; ; ) { char c = this . next ( ) ; if ( c == delimiter || c == 0 || c == '' || c == '' ) { if ( c != 0 ) { this . back ( ) ; } return sb . toString ( ) . trim ( ) ; } sb . append ( c ) ; } }
te	9	@ Override public void render ( Graphics g ) { if ( w == 0 ) { w = getWidth ( ) ; h = getHeight ( ) ; myX = w / 2 ; myY = h - 10 ; busLength = 100 ; busHeight = 20 ; ballDia = busLength / 2 ; ballRadius = ballDia / 2 ; ballY = 0 ; } g . setColor ( Color . CYAN ) ; g . fillRect ( 0 , 0 , w , h ) ; g . setColor ( Color . GRAY ) ; g . fill3DRect ( w - 100 , 0 , 100 , 50 , ! isMyMouseDown ) ; g . setColor ( Color . WHITE ) ; g . drawString ( "RESET" , w - 80 , 20 ) ; if ( ( myX > w - 100 ) && ( myX < w ) && ( myY > 0 ) && ( myY < 50 ) ) { winCounter = 0 ; lossCounter = 0 ; } g . setColor ( Color . BLUE ) ; g . setFont ( winLoss ) ; g . drawString ( "Wins " + winCounter , 0 , 20 ) ; g . drawString ( "Losses " + lossCounter , 0 , 60 ) ; g . setColor ( Color . RED ) ; g . fill3DRect ( myX - ( busLength / 2 ) , h - ( busHeight / 2 ) , busLength , busHeight , ! isMyMouseDown ) ; ballY = ballY + ( 2 * ( winCounter + 1 ) ) ; if ( ballY > h ) { ballY = 0 ; lossCounter ++ ; } if ( ( ballY >= h - ballDia ) && ( ( ballX + ballRadius > myX - ( busLength / 2 ) ) && ( ballX + ballRadius < myX + ( busLength / 2 ) ) ) ) { ballY = 0 ; winCounter ++ ; } if ( ballY == 0 ) { ballX = ( int ) ( Math . random ( ) * w ) ; if ( ballX >= ( w - ballDia ) ) { ballX = ballX - ballDia ; } } g . setColor ( Color . ORANGE ) ; g . fillOval ( ballX , ballY , ballDia , ballDia ) ; }
te	5	public static boolean isPathSpecial ( int c ) { if ( c == [ || c == ] || c == { || c == } || c == . ) return true ; return false ; }
te	9	private void generateAB ( PopulationVector N , int current_class ) throws InternalErrorException { A . reset ( ) ; B . reset ( ) ; basis . reset_uncomputables ( ) ; int row = - 1 ; int col = 0 ; PopulationChangeVector n ; for ( int i = 0 ; i < MiscFunctions . binomialCoefficient ( M + R - 1 , M ) ; i ++ ) { n = basis . getPopulationChangeVector ( i ) . copy ( ) ; if ( n . sumTail ( current_class - 1 ) > 0 ) { for ( int k = 0 ; k <= M ; k ++ ) { row ++ ; col = basis . indexOf ( n , k ) ; A . write ( row , col , BigRational . ONE ) ; basis . computatble ( col ) ; if ( n . sumTail ( current_class ) > 0 ) { A . write ( row , col , BigRational . ONE ) ; col = basis . indexOf ( n , k ) ; B . write ( row , col , BigRational . ONE ) ; } else { A . write ( row , col , BigRational . ONE ) ; n . minusOne ( current_class ) ; col = basis . indexOf ( n , k ) ; B . write ( row , col , BigRational . ONE ) ; n . restore ( ) ; } } } else { if ( n . sumHead ( current_class - 1 ) < M ) { for ( int k = 1 ; k <= M ; k ++ ) { row ++ ; col = basis . indexOf ( n , k ) ; A . write ( row , col , BigRational . ONE ) ; basis . computatble ( col ) ; col = basis . indexOf ( n , 0 ) ; A . write ( row , col , BigRational . ONE . negate ( ) ) ; basis . computatble ( col ) ; for ( int s = 1 ; s <= current_class - 1 ; s ++ ) { n . plusOne ( s ) ; col = basis . indexOf ( n , k ) ; n . restore ( ) ; A . write ( row , col , qnm . getDemandAsBigRational ( k - 1 , s - 1 ) . negate ( ) ) ; basis . computatble ( col ) ; } col = basis . indexOf ( n , k ) ; B . write ( row , col , qnm . getDemandAsBigRational ( k - 1 , current_class - 1 ) ) ; } for ( int s = 1 ; s < current_class ; s ++ ) { row ++ ; col = basis . indexOf ( n , 0 ) ; A . write ( row , col , N . getAsBigRational ( s - 1 ) . subtract ( n . getAsBigRational ( s - 1 ) ) ) ; basis . computatble ( col ) ; n . plusOne ( s ) ; col = basis . indexOf ( n , 0 ) ; A . write ( row , col , qnm . getDelayAsBigRational ( s - 1 ) . negate ( ) ) ; basis . computatble ( col ) ; for ( int k = 1 ; k <= M ; k ++ ) { col = basis . indexOf ( n , k ) ; A . write ( row , col , qnm . getDemandAsBigRational ( k - 1 , s - 1 ) . negate ( ) ) ; basis . computatble ( col ) ; } n . restore ( ) ; } } } } for ( int i = 0 ; i < MiscFunctions . binomialCoefficient ( M + R - 1 , M ) ; i ++ ) { n = basis . getPopulationChangeVector ( i ) . copy ( ) ; if ( n . sumTail ( current_class - 1 ) <= 0 ) { row ++ ; col = basis . indexOf ( n , 0 ) ; A . write ( row , col , N . getAsBigRational ( current_class - 1 ) ) ; basis . computatble ( col ) ; A . toBeUpdated ( row , col ) ; B . write ( row , col , qnm . getDelayAsBigRational ( current_class - 1 ) ) ; for ( int k = 1 ; k <= M ; k ++ ) { col = basis . indexOf ( n , k ) ; B . write ( row , col , qnm . getDemandAsBigRational ( k - 1 , current_class - 1 ) ) ; } } } }
te	5	@ Override public int hashCode ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + ( ( bedsAvailable == null ) ? 0 : bedsAvailable . hashCode ( ) ) ; result = prime * result + ( ( endDate == null ) ? 0 : endDate . hashCode ( ) ) ; result = prime * result + ( ( maxPrice == null ) ? 0 : maxPrice . hashCode ( ) ) ; result = prime * result + ( ( minPrice == null ) ? 0 : minPrice . hashCode ( ) ) ; result = prime * result + ( ( startDate == null ) ? 0 : startDate . hashCode ( ) ) ; return result ; }
te	3	public static synchronized DataInputStream openurl ( String s ) throws IOException { for ( urlreq = s ; urlreq != null ; ) try { Thread . sleep ( 50 ) ; } catch ( Exception _ex ) { } if ( urlstream == null ) throw new IOException ( "could not open: " + s ) ; else return urlstream ; }
te	3	public void loadRocketSprites ( ) { rocketSprites = new ArrayList ( ) ; ArrayList anims = new ArrayList ( ) ; for ( int i = 0 ; i < rocketImages . size ( ) ; i ++ ) { Animation a = new Animation ( ) ; for ( int j = 0 ; j < rocketImages . get ( i ) . size ( ) ; j ++ ) { a . addFrame ( ( Image ) rocketImages . get ( i ) . get ( j ) , 200 ) ; } Animation [ ] a_array = new Animation [ 360 ] ; for ( int j = 0 ; j < 360 ; j ++ ) { a_array [ j ] = rotateAnimation ( a , Math . toRadians ( j + 1 ) ) ; } Sprite s = new Projectile ( a_array , 0 ) ; rocketSprites . add ( s ) ; } }
te	2	public void RowWiseTraverse ( int width , int height ) { for ( int row = 0 ; row < height ; row ++ ) { for ( int col = 0 ; col < width ; col ++ ) { System . out . printf ( "%d %d " , row , col ) ; } } }
te	4	public void run ( ) { isWaitingToTimeOut = true ; resetTimeout ( ) ; while ( isWaitingToTimeOut ) { long now = System . currentTimeMillis ( ) ; if ( now >= timeOfLastReset + timeout ) { isWaitingToTimeOut = false ; if ( client != null ) client . timeOut ( ) ; } try { Thread . sleep ( Math . max ( 50 , timeout - now + timeOfLastReset ) ) ; } catch ( InterruptedException e ) { } } }
te	3	public void setAxisOrientation ( Orientations orientation ) { if ( axisOrientation == orientation ) return ; axisOrientation = orientation ; switch ( axisOrientation ) { case HORIZONTAL : labelOrientation = Orientations . HORIZONTAL ; reversed = false ; break ; case VERTICAL : labelOrientation = Orientations . VERTICAL ; reversed = true ; break ; } resize ( ) ; repaint ( ) ; }
te	1	public void setGain ( double fGain ) throws BasicPlayerException { if ( hasGainControl ( ) ) { double minGainDB = getMinimumGain ( ) ; double ampGainDB = ( ( 10.0f / 20.0f ) * getMaximumGain ( ) ) - getMinimumGain ( ) ; double cste = Math . log ( 10.0 ) / 20 ; double valueDB = minGainDB + ( 1 / cste ) * Math . log ( 1 + ( Math . exp ( cste * ampGainDB ) - 1 ) * fGain ) ; m_gainControl . setValue ( ( float ) valueDB ) ; notifyEvent ( BasicPlayerEvent . GAIN , getEncodedStreamPosition ( ) , fGain , null ) ; } else throw new BasicPlayerException ( BasicPlayerException . GAINCONTROLNOTSUPPORTED ) ; }
te	7	public boolean equals ( Object obj ) { if ( obj == this ) return true ; else if ( obj instanceof FHashMap ) { FHashMap fhm = ( FHashMap ) obj ; return equals ( tree , fhm . tree ) ; } else if ( obj instanceof FLinkedHashMap ) { FLinkedHashMap plhm = ( FLinkedHashMap ) obj ; return equals ( tree , plhm . map_tree ) ; } else if ( ! ( obj instanceof Map ) ) return false ; else { Map < Object , Object > map = ( Map < Object , Object > ) obj ; if ( size ( ) != map . size ( ) ) return false ; for ( Map . Entry ent : map . entrySet ( ) ) if ( ! contains ( ent ) ) return false ; return true ; } }
te	8	@ Override public void run ( ) { while ( true ) { try { sleep ( 1000 ) ; } catch ( InterruptedException ex ) { Logger . getLogger ( Colony . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } try { synchronized ( depot . getMaterials ( ) ) { if ( depot . getMaterials ( ) . isEmpty ( ) == false ) { for ( Material m : depot . getMaterials ( ) ) { if ( m instanceof ImpermanentMaterial ) { if ( ( ( ImpermanentMaterial ) m ) . isIsBad ( ) == true ) { setAmountOfGold ( getAmountOfGold ( ) + m . getPrice ( ) ) ; depot . setCurrentCapacity ( depot . getCurrentCapacity ( ) - m . getWeight ( ) ) ; depot . getMaterials ( ) . remove ( m ) ; } } } } } } catch ( ConcurrentModificationException ex ) { try { sleep ( 100 ) ; } catch ( InterruptedException ex1 ) { Logger . getLogger ( Colony . class . getName ( ) ) . log ( Level . SEVERE , null , ex1 ) ; } } } }
te	3	private static void checkPrinter ( ) { String queryString = "${^XSET ACTIVERESPONSE 1}$" ; try { PrintService printService = findPrintService ( ) ; System . out . println ( printService . getAttribute ( QueuedJobCount . class ) . getValue ( ) ) ; if ( printService == null ) { System . out . println ( PRINTER_NAME + " jna not found." ) ; return ; } DocPrintJob job = printService . createPrintJob ( ) ; job . addPrintJobListener ( new MyPrintJobListener ( ) ) ; job . addPrintJobAttributeListener ( new MyPrintJobAttributeListener ( ) , null ) ; InputStream is = new ByteArrayInputStream ( queryString2 . getBytes ( ) ) ; DocFlavor flavor = DocFlavor . INPUT_STREAM . AUTOSENSE ; Doc doc = new SimpleDoc ( is , flavor , null ) ; job . print ( doc , null ) ; try { is . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } catch ( PrintException e ) { e . printStackTrace ( ) ; } }
te	7	public Object [ ] [ ] bacaDaftar ( ) { boolean adaKesalahan = false ; Connection cn = null ; Object [ ] [ ] daftarPembeli = new Object [ 0 ] [ 0 ] ; try { class . forName ( Koneksi . driver ) ; } catch ( Exception ex ) { adaKesalahan = true ; JOptionPane . showMessageDialog ( null , "JDBC Driver tidak ditemukan atau rusak\n" + ex , "Kesalahan" , JOptionPane . ERROR_MESSAGE ) ; } if ( ! adaKesalahan ) { try { cn = ( Connection ) DriverManager . getConnection ( Koneksi . database + "?user=" + Koneksi . user + "&password=" + Koneksi . password + "" ) ; } catch ( Exception ex ) { adaKesalahan = true ; JOptionPane . showMessageDialog ( null , "Koneksi ke" + Koneksi . database + " gagal\n" + ex , "Kesalahan" , JOptionPane . ERROR_MESSAGE ) ; } if ( ! adaKesalahan ) { String SQLStatemen ; Statement sta ; ResultSet rset ; try { SQLStatemen = "select no_beli nama from pembeli" ; sta = ( Statement ) cn . createStatement ( ) ; rset = sta . executeQuery ( SQLStatemen ) ; rset . next ( ) ; rset . last ( ) ; daftarPembeli = new Object [ rset . getRow ( ) ] [ 2 ] ; if ( rset . getRow ( ) > 0 ) { rset . first ( ) ; int i = 0 ; do { daftarPembeli [ i ] = new Object [ ] { rset . getString ( "no_beli" ) , rset . getString ( "nama" ) } ; i ++ ; } while ( rset . next ( ) ) ; } sta . close ( ) ; rset . close ( ) ; } catch ( Exception ex ) { JOptionPane . showMessageDialog ( null , "Tidak dapat membuka tabel pembeli\n" + ex , "Kesalahan" , JOptionPane . ERROR_MESSAGE ) ; } } } return daftarPembeli ; }
te	3	@ Override public void show ( ) { System . out . println ( name + "  type in the required information for a new auction item." + "\n" ) ; System . out . println ( "Name of product:" ) ; try { productName = br . readLine ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } System . out . println ( "Description of product:" ) ; try { description = br . readLine ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } System . out . println ( "Price of product:" ) ; try { String stringToInt = br . readLine ( ) ; price = Integer . parseInt ( stringToInt ) ; } catch ( Exception e ) { System . out . println ( "The input wasn't a number or was out of bounds try again." ) ; } int id = as . searches . size ( ) + 1 ; Auction a = new Auction ( id , productName , description , price ) ; as . create ( a ) ; System . out . println ( ) ; System . out . println ( productName + " has been added to the auction." + "\n" ) ; }
te	4	public boolean removePath ( String path ) { log . entry ( path ) ; PathWalker path_walker = new PathWalker ( path ) ; if ( path_walker . numNodes ( ) < 2 || path_walker . getCurrentNodeName ( ) . length ( ) > 0 ) { return false ; } Node parent = root_ ; Node node = root_ ; while ( path_walker . moveDown ( ) ) { if ( node . hasChild ( path_walker . getCurrentNodeName ( ) ) ) { parent = node ; node = node . getChild ( path_walker . getCurrentNodeName ( ) ) ; } else { return false ; } } log . exit ( ) ; return parent . unmount ( node ) ; }
te	4	public Select columns ( String ... columns ) { int counter = 0 ; for ( String column : columns ) { if ( column != null && column . length ( ) != 0 ) { if ( ! column . contains ( "`" ) ) { this . columns . add ( column ) ; } else { db . writeError ( "Column " + column + " in SELECT statement cannot have backticks." , false ) ; } } else { db . writeError ( "Column at position " + counter + " cannot be null or empty in SELECT statement." , false ) ; } counter ++ ; } return this ; }
te	8	@ Override public void run ( ) { timer . start ( ) ; lastFrameTime = currentTime = timer . getTime ( ) ; this . requestFocus ( ) ; final Image image = new BufferedImage ( GAME_WIDTH , GAME_HEIGHT , BufferedImage . TYPE_INT_RGB ) ; Sound . touch ( ) ; while ( this . running ) { Graphics g = image . getGraphics ( ) ; timer . tick ( ) ; delta = timer . getTime ( ) - currentTime ; currentTime = timer . getTime ( ) ; factor = 1 ; try { factor = Math . min ( 1.0 , curFps / 35D ) ; } catch ( Exception e ) { } if ( input . buttons [ Input . + ] && ! input . oldButtons [ Input . + ] ) { Game . setScreenScale ( Game . getScreenScale ( ) + 1 ) ; } if ( input . buttons [ Input . MINUS ] && ! input . oldButtons [ Input . MINUS ] ) { Game . setScreenScale ( Game . getScreenScale ( ) - 1 ) ; } this . screen . tick ( this . input , delta * factor ) ; this . input . tick ( ) ; this . screen . render ( g ) ; Art . drawString ( version , g , 0 , 0 ) ; curFps = ( int ) ( 1 / delta ) ; Art . drawString ( "FPS: " + ( int ) ( curFps / factor ) , g , 0 , 10 ) ; g . dispose ( ) ; try { this . started = true ; g = this . getGraphics ( ) ; g . drawImage ( image , 0 , 0 , GAME_WIDTH * getScreenScale ( ) , GAME_HEIGHT * getScreenScale ( ) , 0 , 0 , GAME_WIDTH , GAME_HEIGHT , null ) ; g . dispose ( ) ; } catch ( final Throwable e ) { } try { Thread . sleep ( 1 ) ; } catch ( final InterruptedException e ) { e . printStackTrace ( ) ; } } }
te	0	public Field fieldAfterLabel ( String label , int skip , int matchNumber ) { return getField ( new FieldIdentifier ( label , skip , matchNumber ) ) ; }
te	0	@ CRRCSimEditorNode ( name = "DataIdle" ) @ XmlElement ( name = "data" ) @ XmlElementWrapper ( name = "data_idle" ) public ArrayList < EngineDataIdle > getDataIdle ( ) { return dataIdle ; }
te	5	public static boolean rayCast ( RaycastHit hit , Vector3f normal , Vector3f from , Vector3f direction , IShape stcShape ) { simplex . clear ( ) ; float s = 0 ; final Vector3f x = hit . getPoint ( ) . set ( from ) ; simplex . setRef ( x ) ; v . setSubtract ( x , stcShape . getPosition ( ) ) ; int i = 0 ; float d_2 = v . . ( ) ; while ( d_2 > EPSILON_2 ) { if ( i > MAX_ITERATIONS ) { return false ; } i ++ ; stcShape . getMaxAlongDirection ( p , v ) ; w . setSubtract ( x , p ) ; final float vdotw = v . . ( w ) ; if ( vdotw > 0 ) { final float vdotdirection = v . . ( direction ) ; if ( vdotdirection >= 0 ) { return false ; } else { s -= vdotw / vdotdirection ; x . setAddScaled ( from , direction , s ) ; normal . set ( v ) ; } } if ( ! simplex . contains ( p ) ) simplex . add ( p ) ; d_2 = closestPointToOrigin ( v , simplex ) ; } hit . setScalar ( s ) ; return true ; }
te	4	public void update ( Vector3f plr ) { chunksLoaded = 0 ; Chunk . updatePlrPos ( plr ) ; playerPos = plr ; for ( int i = ( int ) plr . x / Chunk . size - viewRange ; i < ( int ) plr . x / Chunk . size + viewRange ; i ++ ) for ( int j = ( int ) plr . z / Chunk . size - viewRange ; j < ( int ) plr . z / Chunk . size + viewRange ; j ++ ) if ( withinRange ( plr . x , plr . z , i * Chunk . size , j * Chunk . size ) ) if ( getChunk ( i * Chunk . size , j * Chunk . size ) == null ) loadChunk ( i , j ) ; }
te	5	public static int getMacAddressHash ( ) { String macAddress = "" ; try { for ( NetworkInterface ni : Collections . list ( NetworkInterface . getNetworkInterfaces ( ) ) ) { byte [ ] hardwareAddress = ni . getHardwareAddress ( ) ; if ( hardwareAddress != null ) { for ( int i = 0 ; i < hardwareAddress . length ; i ++ ) { macAddress += String . format ( ( i == 0 ? "" : "-" ) + "%02X" , hardwareAddress [ i ] ) ; } } } return macAddress . hashCode ( ) ; } catch ( SocketException e ) { e . printStackTrace ( ) ; } throw new NumberFormatException ( ) ; }
te	6	@ Override public void processNewSwitchValue ( INDISwitchProperty property , Date timestamp , INDISwitchElementAndValue [ ] elementsAndValues ) { if ( property == sendP ) { if ( elementsAndValues . length > 0 ) { INDISwitchElement el = elementsAndValues [ 0 ] . getElement ( ) ; SwitchStatus s = elementsAndValues [ 0 ] . getValue ( ) ; if ( ( el == sendE ) && ( s == SwitchStatus . ON ) ) { boolean imageLoaded = loadImageFromFile ( ) ; if ( imageLoaded ) { sendP . setState ( PropertyStates . OK ) ; imageP . setState ( PropertyStates . OK ) ; try { updateProperty ( sendP ) ; updateProperty ( imageP ) ; } catch ( INDIException e ) { e . printStackTrace ( ) ; System . exit ( - 1 ) ; } } } } } }
te	8	public static final String getTableName ( String className ) { String tableName = "" ; if ( className != null && ! className . trim ( ) . isEmpty ( ) ) { if ( className . matches ( "([A-Z](\\w+))+" ) ) { String [ ] words = className . split ( "(?=[A-Z])" ) ; if ( words != null ) { if ( words . length == 1 ) { className = String . format ( "%ss" , className ) ; } else if ( words . length >= 2 ) { className = "" ; for ( String word : words ) { if ( ! word . isEmpty ( ) ) { className += String . format ( "%ss" , word ) ; } } } else { } } } className = className . trim ( ) ; className = className . replaceAll ( "([a-z0-9]+)([A-Z])" , "$1_$2" ) ; className = className . toLowerCase ( ) ; tableName = className ; } return tableName ; }
te	7	@ Override public void update ( Player player , List < Zombie > zombies ) { if ( this . getHealth ( ) <= 0 && ! this . exploded ) { this . exploded = true ; this . explosion = new Explosion ( Images . POISON_GAS_SHEET , new Point2D . double ( this . x , this . y ) ) ; Sounds . POISONCLOUD . play ( ) ; } if ( this . exploded ) { if ( collidesWithExplosion ( player ) && ! this . damageDone ) { if ( ! player . hasEffect ( Invulnerability . EFFECT_NAME ) ) { player . addStatusEffect ( 6 , "Poison" , Images . POISON_STATUS_ICON , ( 15 * 1000 ) , PoisonFogZombie . POISON_DAMAGE ) ; this . damageDone = true ; } } if ( this . explosion . getImage ( ) . isActive ( ) ) this . explosion . getImage ( ) . update ( ) ; } }
te	5	protected IClassSerializer getCustomConverter ( class < ? > type ) { IClassSerializer converter = classToDictRegistry . get ( type . getClass ( ) ) ; if ( converter != null ) { return converter ; } for ( Entry < class < ? > , IClassSerializer > x : classToDictRegistry . entrySet ( ) ) { if ( x . getKey ( ) . isAssignableFrom ( type ) ) { return x . getValue ( ) ; } } return null ; }
te	4	private void completeCommand ( Command c , Agent a ) { if ( c != null ) { if ( c . cmd . equals ( "Move" ) ) completeMove ( c , a ) ; else if ( c . cmd . equals ( "Pull" ) ) completePull ( c , a , ( Box ) a . getAtField ( ) . neighbors [ c . dir2 . ordinal ( ) ] . object ) ; else if ( c . cmd . equals ( "Push" ) ) completePush ( c , a , ( Box ) a . getAtField ( ) . neighbors [ c . dir1 . ordinal ( ) ] . object ) ; } }
te	9	public LinkedList < String > applyRules ( LinkedList < String > possibleExtensions , WFF world ) { LinkedList < String > _extensions = new LinkedList < String > ( ) ; for ( String possExtension : possibleExtensions ) { LinkedList < String > _consequences = new LinkedList < String > ( ) ; WFF currentExtension = new WFF ( possExtension ) ; WFF assertion = new WFF ( "(" + world . getFormula ( ) + ") & (" + possExtension + ")" ) ; boolean overall = true ; for ( DefaultRule d : rules ) { WFF preq = new WFF ( d . getPrerequisite ( ) ) ; WFF just = new WFF ( d . getJustificatoin ( ) ) ; WFF cons = new WFF ( d . getConsequence ( ) ) ; boolean prereqisite_fired = assertion . eval ( preq ) ; if ( prereqisite_fired ) { boolean just_consistent = assertion . isConsistent ( just . getFormula ( ) ) ; if ( just_consistent ) { boolean test_consequence_entailed_by_extension = currentExtension . entails ( cons ) ; if ( ! test_consequence_entailed_by_extension ) overall = false ; _consequences . add ( currentExtension . getFormula ( ) ) ; } } else { } } if ( overall ) { for ( DefaultRule d : rules ) { WFF preq = new WFF ( d . getPrerequisite ( ) ) ; WFF cons = new WFF ( d . getConsequence ( ) ) ; boolean prereqisite_fired = assertion . entails ( preq ) ; if ( ! prereqisite_fired ) { WFF preqCon = new WFF ( "(" + d . getPrerequisite ( ) + ") & (" + d . getJustificatoin ( ) + ")" ) ; boolean test_consequence_entailed_by_extension = currentExtension . entails ( cons ) ; if ( test_consequence_entailed_by_extension ) if ( ! preqCon . isConsistent ( currentExtension . getFormula ( ) ) ) { overall = false ; } } } if ( ! overall ) break ; String talliedCons = "" ; for ( String c : _consequences ) { talliedCons = talliedCons + " " + a . e . AND + " " + c ; } if ( talliedCons . length ( ) > 0 ) talliedCons = talliedCons . substring ( ( " " + a . e . AND + " " ) . length ( ) , talliedCons . length ( ) ) ; WFF wffCons = new WFF ( talliedCons ) ; String extString = currentExtension . getClosure ( ) . trim ( ) ; String conString = wffCons . getClosure ( ) . trim ( ) ; if ( extString . compareTo ( conString ) == 0 ) _extensions . add ( possExtension ) ; } } return _extensions ; }
te	2	public Matrix arrayRightDivide ( Matrix B ) { checkMatrixDimensions ( B ) ; Matrix X = new Matrix ( m , n ) ; double [ ] [ ] C = X . getArray ( ) ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { C [ i ] [ j ] = A [ i ] [ j ] / B . A [ i ] [ j ] ; } } return X ; }
te	6	private void jBGravaActionPerformed ( java . awt . event . ActionEvent evt ) { String simNao [ ] = { "Sim" , "N\u00E3o" } ; IKey dado = null ; int salva = JOptionPane . showOptionDialog ( null , "Confirma grava\u00E7\u00E3o dos dados?" , "Gravando..." , JOptionPane . YES_NO_OPTION , JOptionPane . QUESTION_MESSAGE , null , simNao , simNao [ 0 ] ) ; if ( salva == 0 ) { if ( validarCampos ( ) ) { dado = montaDado ( ) ; if ( estado == 3 ) { try { dadosDAO . add ( dado ) ; javax . swing . JOptionPane . showMessageDialog ( null , "Novo registro armazenado com sucesso!" , this . getTitle ( ) , javax . swing . JOptionPane . INFORMATION_MESSAGE ) ; } catch ( SQLException e ) { javax . swing . JOptionPane . showMessageDialog ( null , e . getMessage ( ) , this . getTitle ( ) + " - Aviso" , javax . swing . JOptionPane . ERROR_MESSAGE ) ; } } else if ( estado == 2 ) { try { dadosDAO . edit ( dado ) ; JOptionPane . showMessageDialog ( null , "Altera\u00E7\u00E3o realizada com sucesso!" , this . getTitle ( ) , JOptionPane . INFORMATION_MESSAGE ) ; } catch ( SQLException e ) { JOptionPane . showMessageDialog ( null , e . getMessage ( ) , this . getTitle ( ) , JOptionPane . ERROR_MESSAGE ) ; } } load ( ) ; setEstado ( 1 ) ; corrente = posicaoDado ( dado ) ; limpaCampos ( ) ; exibeDados ( ) ; } } }
te	4	@ Test public void testNaissanceLarves ( ) { SalleLarve testLarve = new SalleLarve ( ) ; SalleNourrice sn = new SalleNourrice ( ) ; Evenements . getInstance ( ) . setEvenementActif ( Constantes . EVEN_DEPLACEMENT ) ; sn . ajouterFourmi ( 3 ) ; testLarve . naissanceLarves ( 2 , sn ) ; assertEquals ( 3 , testLarve . getNbCourantFourmi ( ) ) ; assertEquals ( 1 , sn . getNbCourantFourmi ( ) ) ; try { testLarve . naissanceLarves ( 2 , sn ) ; fail ( "ExceptionNourrices non levee." ) ; } catch ( ExceptionNourrices en ) { } try { testLarve . naissanceLarves ( - 1 , sn ) ; fail ( "IllegalArgumentException non levee." ) ; } catch ( IllegalArgumentException iae ) { } try { testLarve . naissanceLarves ( 0 , sn ) ; fail ( "IllegalArgumentException non levee." ) ; } catch ( IllegalArgumentException iae ) { } try { testLarve . naissanceLarves ( 5 , sn ) ; fail ( "IllegalArgumentException non levee." ) ; } catch ( IllegalArgumentException iae ) { } }
te	7	private int selectSaveFile ( ) { JFileChooser fc = new JFileChooser ( ) ; FileNameExtensionFilter textFilter = new FileNameExtensionFilter ( "GenSim file" , "gsm" ) ; fc . setFileFilter ( textFilter ) ; int chosen ; boolean goodFile ; do { goodFile = true ; chosen = fc . showSaveDialog ( MainWindow . this ) ; if ( chosen == JFileChooser . APPROVE_OPTION ) { currentFile = fc . getSelectedFile ( ) ; try { String fileName = currentFile . getCanonicalPath ( ) ; if ( ! fileName . endsWith ( ".gsm" ) ) { currentFile = new File ( fileName + ".gsm" ) ; } } catch ( IOException ex ) { } } if ( currentFile != null && currentFile . exists ( ) ) { int overwrite = JOptionPane . showConfirmDialog ( MainWindow . this , "This file already exists. Overrite the current file?" , "Warning!" , JOptionPane . OK_CANCEL_OPTION , JOptionPane . QUESTION_MESSAGE ) ; if ( overwrite == JOptionPane . CANCEL_OPTION ) { goodFile = false ; } } } while ( ! goodFile ) ; return chosen ; }
te	0	@ Override public Integer contar ( ) { return null ; }
te	2	private int seeders ( ) { int count = 0 ; for ( TrackedPeer peer : this . peers . values ( ) ) { if ( peer . isCompleted ( ) ) { count ++ ; } } return count ; }
te	6	public void apply ( ) { establishPatrolers ( ) ; establishAttackers ( ) ; claimMinerals ( ) ; patrol ( ) ; switch ( consumeState ) { case MORPH_DRONES : morphToDrones ( ) ; break ; case SPAWN_POOLS : buildSpawingPools ( ) ; break ; default : break ; } switch ( produceState ) { case SPAWN_OVERLORDS : spawnOverlords ( ) ; break ; case SPAWN_ZERGLINS : spawnZerglings ( ) ; break ; default : break ; } switch ( actionState ) { case ATTACK : attack ( ) ; break ; case DEFEND : defend ( ) ; break ; default : break ; } }
te	9	public char [ ] [ ] moveLines ( char [ ] [ ] line , int way ) { char [ ] [ ] res = new char [ 30 ] [ 30 ] ; if ( way == 1 ) { for ( int i = 1 ; i < line . length ; i ++ ) { res [ i - 1 ] = line [ i ] ; } } else if ( way == 2 ) { for ( int i = 0 ; i < line . length - 1 ; i ++ ) { res [ i + 1 ] = line [ i ] ; } } else if ( way == 3 ) { for ( int i = 0 ; i < line . length ; i ++ ) { for ( int j = 1 ; j < line [ i ] . length ; j ++ ) { res [ i ] [ j - 1 ] = line [ i ] [ j ] ; } } } else if ( way == 4 ) { for ( int i = 0 ; i < line . length ; i ++ ) { for ( int j = 0 ; j < line [ i ] . length - 1 ; j ++ ) { res [ i ] [ j + 1 ] = line [ i ] [ j ] ; } } } return res ; }
te	8	@ Override public String toString ( ) { switch ( mission ) { case EU_AUS_OTH : return "Capture Europe  Australia  and one other continent" ; case EU_SA_OTH : return "Capture Europe  South America  and one other continent" ; case NA_AF : return "Capture North America and Africa" ; case NA_AUS : return "Capture North America and Australia" ; case AS_SA : return "Capture Asia and South America" ; case AS_AF : return "Capture Asia and Africa" ; case ANY24 : return "Capture 24 territorries" ; case ANY18W2 : return "Capture 18 territorries and occupy each with two troops" ; } throw new RuntimeException ( "Invalid secret mission" ) ; }
te	7	public static void main ( String [ ] args ) { ObjectInputStream ois = null ; ObjectOutputStream oos = null ; try { File userListFile = new File ( "src/server/bin/userListFile" ) ; if ( userListFile . exists ( ) ) { ois = new ObjectInputStream ( new FileInputStream ( userListFile ) ) ; userList = ( List < User > ) ois . readObject ( ) ; } else { userListFile . createNewFile ( ) ; oos = new ObjectOutputStream ( new FileOutputStream ( userListFile ) ) ; userList = new ArrayList < User > ( ) ; oos . writeObject ( userList ) ; } System . out . println ( "\u7528\u6237\u6570\u91CF:" + userList . size ( ) ) ; for ( int i = 0 ; i < userList . size ( ) ; i ++ ) { User user = userList . get ( i ) ; System . out . println ( user . getUserName ( ) + "  " + user . getPassword ( ) + " \u90AE\u4EF6\u6570\u91CF" + user . getEmailNumber ( ) ) ; } } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } catch ( ClassNotFoundException e ) { e . printStackTrace ( ) ; } finally { if ( ois != null ) { try { ois . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } } }
te	6	public ResultSet update ( final String tableName , final Hashtable < enum < ? > , Object > updateVals , final Hashtable < enum < ? > , Object > compareVals ) { String update = "UPDATE " + tableName + " SET " ; String setToUPdate = "" ; final Enumeration < ? > keys = updateVals . keys ( ) ; final Object [ ] values = updateVals . values ( ) . toArray ( ) ; for ( int x = 0 ; x < values . length ; x ++ ) { setToUPdate += "`" + keys . nextElement ( ) + "`='" + values [ x ] + "'   " ; } setToUPdate = setToUPdate . substring ( 0 , setToUPdate . lastIndexOf ( "   " ) ) ; update += setToUPdate ; String compare = "" ; final Enumeration < ? > compareKeys = compareVals . keys ( ) ; final Object [ ] compareValues = compareVals . values ( ) . toArray ( ) ; for ( int x = 0 ; x < compareValues . length ; x ++ ) { compare += "`" + compareKeys . nextElement ( ) + "`='" + compareValues [ x ] + "' AND " ; } compare = compare . substring ( 0 , compare . lastIndexOf ( "AND " ) ) ; update += " WHERE " + compare + ";" ; return execute ( update ) ; }
te	9	@ Override public AbstractChatResponse parse ( String incoming ) throws ParseException { String from = "" ; String message = "" ; long tstamp = 0 ; int ID = 0 ; String type = "" ; try { DocumentBuilderFactory docBFac = DocumentBuilderFactory . newInstance ( ) ; DocumentBuilder docBuilder = docBFac . newDocumentBuilder ( ) ; Document xml = docBuilder . parse ( new InputSource ( new StringReader ( incoming ) ) ) ; xml . getDocumentElement ( ) . normalize ( ) ; Element lanchat = xml . getDocumentElement ( ) ; NodeList nl ; type = lanchat . getAttribute ( "type" ) ; if ( type . equals ( "message" ) ) { nl = lanchat . getElementsByTagName ( "tstamp" ) ; Node dateNode = nl . item ( 0 ) ; try { tstamp = long . parseLong ( dateNode . getTextContent ( ) ) ; } catch ( NumberFormatException e ) { throw new ParseException ( "invalid input" , 0 ) ; } } if ( type . equals ( "message" ) || type . equals ( "ping" ) ) { nl = lanchat . getElementsByTagName ( "from" ) ; Node fromNode = nl . item ( 0 ) ; from = fromNode . getTextContent ( ) ; } if ( type . equals ( "message" ) ) { nl = lanchat . getElementsByTagName ( "message" ) ; Node messageNode = nl . item ( 0 ) ; message = messageNode . getTextContent ( ) ; } if ( type . equals ( "message" ) || type . equals ( "ping" ) ) { nl = lanchat . getElementsByTagName ( "id" ) ; Node IDNode = nl . item ( 0 ) ; ID = Integer . parseInt ( IDNode . getTextContent ( ) ) ; } } catch ( SAXParseException e ) { throw new ParseException ( "invalid input" , 0 ) ; } catch ( NullPointerException e ) { throw new ParseException ( "invalid input" , 0 ) ; } catch ( SAXException e ) { throw new ParseException ( "invalid input" , 0 ) ; } catch ( IOException e ) { throw new ParseException ( "invalid input" , 0 ) ; } catch ( ParserConfigurationException e ) { throw new ParseException ( "invalid input" , 0 ) ; } if ( type . equals ( "ping" ) ) return new ChatPing ( from , ID ) ; return new ChatMessage ( from , message , new Date ( tstamp ) , ID ) ; }
te	3	@ Override public void actionPerformed ( ActionEvent e ) { if ( e . getSource ( ) . equals ( add ) ) { InfoElev info = getInfoElev ( ) ; admin . removeUtilizator ( Centralizator . getInstance ( ) , selectedElev ) ; admin . addUtilizator ( Centralizator . getInstance ( ) , TipUtilizator . Elev , info ) ; fillUtili ( ) ; JOptionPane . showMessageDialog ( this , "Elev adaugat cu succes!" ) ; } else if ( e . getSource ( ) . equals ( back ) ) { dispose ( ) ; Centralizator cen = Centralizator . getInstance ( ) ; cen . saveCentralizator ( ) ; new EditUtil ( admin ) ; } else if ( e . getSource ( ) . equals ( utili ) ) { findSelectedElev ( ) ; updateFields ( ) ; } }
te	2	static int string2Int ( String s ) { try { return s . isEmpty ( ) ? 0 : Integer . parseInt ( s ) ; } catch ( RuntimeException re ) { throw new RuntimeException ( "s=" + s , re ) ; } }
te	6	public boolean canPlace ( Piece piece , int x , int y ) { for ( Point block : piece . getBody ( ) ) { int putx = x + block . x ; int puty = y + block . y ; if ( putx < 0 || putx >= width || puty < 0 || ( ( puty < height ) && grid [ putx ] [ puty ] ) ) { return false ; } } return true ; }
te	5	public boolean CheckExistName ( String fullName , int idA , boolean create ) { boolean equals = false ; try { StartConnection ( ) ; stmt = conn . createStatement ( ) ; String query = "SELECT Id First_Name Last_Name FROM Employee" ; result = stmt . executeQuery ( query ) ; while ( result . next ( ) ) { int t = result . getInt ( "Id" ) ; if ( create ) { System . out . println ( "create ---" ) ; equals = fullName . equalsIgnoreCase ( result . getString ( "Last_Name" ) + " " + result . getString ( "First_Name" ) ) ; } else { if ( idA != t ) { System . out . println ( "update in admin ---" ) ; equals = fullName . equalsIgnoreCase ( result . getString ( "Last_Name" ) + " " + result . getString ( "First_Name" ) ) ; } } System . out . println ( "id: " + id2 + " " + t + " | database: [" + result . getString ( "Last_Name" ) + " " + result . getString ( "First_Name" ) + "] == new: [" + fullName + "]  " + equals ) ; if ( equals ) break ; } StopConnection ( ) ; } catch ( Exception e ) { JOptionPane . showMessageDialog ( null , "CheckExistName()\n" + e ) ; } return equals ; }
