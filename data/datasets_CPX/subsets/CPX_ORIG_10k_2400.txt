tr	6	private static String just ( String src , int length , String fill , boolean ljust ) throws IOException { if ( isStringNullOrEmpty ( fill ) || length <= src . length ( ) ) { return src ; } else { StringReader sr = new StringReader ( fill ) ; StringBuilder sb = new StringBuilder ( ) ; if ( ljust ) sb . append ( src ) ; int toFillLen = length - src . length ( ) , read = - 1 ; while ( toFillLen -- > 0 ) { if ( ( read = sr . read ( ) ) == - 1 ) { sr . reset ( ) ; read = sr . read ( ) ; } sb . append ( ( char ) read ) ; } if ( ! ljust ) sb . append ( src ) ; return sb . toString ( ) ; } }
tr	2	public void store ( List < StrawEventHandler > handlers ) { if ( handlers == null ) { return ; } for ( StrawEventHandler handler : handlers ) { this . store ( handler ) ; } }
tr	6	public void readFromSocket ( ) throws IOException { SocketChannel channel = ( SocketChannel ) selectionKey . channel ( ) ; ByteBuffer buf = ByteBuffer . allocate ( 1024 ) ; int numBytes = channel . read ( buf ) ; if ( numBytes <= 0 ) { close ( ) ; return ; } buf . flip ( ) ; CharsetDecoder decoder = Charset . defaultCharset ( ) . newDecoder ( ) ; String str = decoder . decode ( buf ) . toString ( ) ; for ( int i = 0 , len = str . length ( ) ; i < len && avatar != null ; ++ i ) { char c = str . charAt ( i ) ; if ( c == '' ) { invokeAvatar ( inputBuilder . toString ( ) ) ; inputBuilder . setLength ( 0 ) ; } else if ( c >= 32 && c <= 127 ) { inputBuilder . append ( c ) ; } } }
tr	1	int step5Status ( ) { if ( event . getSeatsPerTable ( ) . isEmpty ( ) ) return 0 ; else return 1 ; }
tr	8	public void setRecursiveNotDirty ( ) { super . setRecursiveNotDirty ( ) ; this . isAltitudeModeDirty = false ; if ( this . location != null && this . location . isDirty ( ) ) { this . location . setRecursiveNotDirty ( ) ; } if ( this . orientation != null && this . orientation . isDirty ( ) ) { this . orientation . setRecursiveNotDirty ( ) ; } if ( this . scale != null && this . scale . isDirty ( ) ) { this . scale . setRecursiveNotDirty ( ) ; } if ( this . link != null && this . link . isDirty ( ) ) { this . link . setRecursiveNotDirty ( ) ; } }
tr	3	public void setSize ( int n ) { size = n ; elements = new int [ size * size ] ; for ( int i = 0 ; i < elements . length ; i ++ ) { elements [ i ] = ConstraintPuzzle . EMPTY_ELEMENT_VALUE ; } placedElements = new HashSet < Integer > ( ) ; emptyElements = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < elements . length ; i ++ ) { emptyElements . add ( i ) ; } if ( ruleSet != null ) { setRuleset ( ruleSet ) ; } }
tr	3	public static double distributionDistance ( int xmin , double [ ] dist1 , double [ ] dist2 , DISTANCE_TYPE distType , boolean inputCdf ) { if ( ! inputCdf ) { dist1 = Arrays . copyOfRange ( dist1 , xmin , dist1 . length ) ; dist2 = Arrays . copyOfRange ( dist2 , xmin , dist2 . length ) ; dist1 = ArraysExt . scaleBy ( dist1 , ArraysExt . sum ( dist1 ) ) ; dist1 = cdf ( dist1 ) ; dist2 = cdf ( dist2 ) ; } double [ ] diff = ArraysExt . abs ( ArraysExt . subtract ( dist1 , dist2 , true ) ) ; if ( distType . equals ( DISTANCE_TYPE . KS_DISTANCE ) ) return ArraysExt . max ( diff ) ; else if ( distType . equals ( DISTANCE_TYPE . RSS ) ) return ArraysExt . sum ( ArraysExt . pow ( diff , 2.0 ) ) ; else return double . MAX_VALUE ; }
tr	5	public void run ( ) { bf . setVisible ( false ) ; if ( frame != null ) { frame . invalidate ( ) ; frame . validate ( ) ; frame . repaint ( ) ; } }
tr	0	@ Override public String toString ( ) { return "Autonomous Points : " + getPoints ( ) ; }
tr	3	public void loadMap ( String s ) { System . out . println ( "CLASSPATH = " + s ) ; try { final InputStream in = getClass ( ) . getResourceAsStream ( s ) ; final BufferedReader br = new BufferedReader ( new InputStreamReader ( in ) ) ; mapXRows = Integer . parseInt ( br . readLine ( ) ) ; mapYRows = Integer . parseInt ( br . readLine ( ) ) ; map = new int [ mapYRows ] [ mapXRows ] ; mapWidth = mapXRows * tileSize ; mapHeight = mapYRows * tileSize ; xColMin = GamePanel . WIDTH - mapWidth ; xColMax = 0 ; yColMin = GamePanel . HEIGHT - mapHeight ; yColMax = 0 ; final String delims = "\\s+" ; for ( int row = 0 ; row < mapYRows ; row ++ ) { final String line = br . readLine ( ) ; final String [ ] tokens = line . split ( delims ) ; for ( int col = 0 ; col < mapXRows ; col ++ ) map [ row ] [ col ] = Integer . parseInt ( tokens [ col ] ) ; } } catch ( final Exception e ) { e . printStackTrace ( ) ; } }
tr	3	private void connectToLogfile ( ) { int currentLoggingLevel = DEFAULT_LOG_LEVEL ; File errorFile = new File ( ERROR_LOG_FILENAME ) ; File warningFile = new File ( WARNING_LOG_FILENAME ) ; File debugFile = new File ( DEBUG_LOG_FILENAME ) ; if ( errorFile . exists ( ) ) currentLoggingLevel = DDLoggerInterface . LOG_ERROR ; if ( warningFile . exists ( ) ) currentLoggingLevel = DDLoggerInterface . LOG_WARNING ; if ( debugFile . exists ( ) ) currentLoggingLevel = DDLoggerInterface . LOG_DEBUG ; System . err . println ( "Hyde debug file: " + CANON_DEBUG_FILENAME ) ; logger = new DDSimpleLogger ( CANON_DEBUG_FILENAME , currentLoggingLevel , true , true ) ; }
tr	0	@ Override public int hashCode ( ) { return id ; }
tr	2	private synchronized void executeReceive ( ) { try { String data = input . readLine ( ) ; if ( data != null ) notifyNewData ( data ) ; } catch ( IOException e ) { notifyReadFailure ( e ) ; } }
tr	2	public LlvmValue visit ( ClassDeclSimple n ) { classes . put ( n . name . s , new ClassNode ( n . name . s ) ) ; SetClassInUse ( n . name . s ) ; List < LlvmType > listaTipos = new LinkedList < LlvmType > ( ) ; for ( util . List < VarDecl > v = n . varList ; v != null ; v = v . tail ) { LlvmValue field = v . head . accept ( this ) ; GetClassInUse ( ) . AddField ( field . toString ( ) , field . type ) ; listaTipos . add ( field . type ) ; } GetClassInUse ( ) . AddClassType ( new LlvmStructure ( listaTipos ) ) ; for ( util . List < MethodDecl > m = n . methodList ; m != null ; m = m . tail ) { m . head . accept ( this ) ; } classEnv = null ; methodEnv = null ; return null ; }
tr	1	public Object getValue ( ) { if ( coroutine == null ) return value ; return coroutine . stack [ index ] ; }
tr	7	public boolean isValid ( Card c ) { if ( ( maxCost >= 0 ) && ( c . getCost ( ) > maxCost ) ) return false ; if ( ( minCost >= 0 ) && ( c . getCost ( ) < minCost ) ) return false ; for ( String [ ] param : parameters ) { try { if ( ! c . getStr ( param [ 0 ] ) . equals ( param [ 1 ] ) ) return false ; } catch ( Exception e ) { return false ; } } return true ; }
tr	7	@ Override public String execute ( HttpServletRequest request , HttpServletResponse response ) throws Exception { String data ; try { ArrayList < FilterBean > alFilter = new ArrayList < > ( ) ; if ( request . getParameter ( "filter" ) != null ) { if ( request . getParameter ( "filteroperator" ) != null ) { if ( request . getParameter ( "filtervalue" ) != null ) { FilterBean oFilterBean = new FilterBean ( ) ; oFilterBean . setFilter ( request . getParameter ( "filter" ) ) ; oFilterBean . setFilterOperator ( request . getParameter ( "filteroperator" ) ) ; oFilterBean . setFilterValue ( request . getParameter ( "filtervalue" ) ) ; oFilterBean . setFilterOrigin ( "user" ) ; alFilter . add ( oFilterBean ) ; } } } if ( request . getParameter ( "systemfilter" ) != null ) { if ( request . getParameter ( "systemfilteroperator" ) != null ) { if ( request . getParameter ( "systemfiltervalue" ) != null ) { FilterBean oFilterBean = new FilterBean ( ) ; oFilterBean . setFilter ( request . getParameter ( "systemfilter" ) ) ; oFilterBean . setFilterOperator ( request . getParameter ( "systemfilteroperator" ) ) ; oFilterBean . setFilterValue ( request . getParameter ( "systemfiltervalue" ) ) ; oFilterBean . setFilterOrigin ( "system" ) ; alFilter . add ( oFilterBean ) ; } } } TipoproductoDao oTipoproductoDAO = new TipoproductoDao ( ) ; int pages = oTipoproductoDAO . getCount ( alFilter ) ; data = "{\"data\":\"" + Integer . toString ( pages ) + "\"}" ; return data ; } catch ( Exception e ) { throw new ServletException ( "TipoproductoGetregistersJson: View Error: " + e . getMessage ( ) ) ; } }
tr	0	@ Override protected void selectNumber ( ) { System . out . println ( "\u9009\u4E00\u4E2A\u4E2D\u56FD\u8054\u901A\u7535\u8BDD\u53F7" ) ; }
tr	7	Writer write ( Writer writer , int indentFactor , int indent ) throws JSONException { try { boolean commanate = false ; int length = this . length ( ) ; writer . write ( [ ) ; if ( length == 1 ) { JSONObject . writeValue ( writer , this . myArrayList . get ( 0 ) , indentFactor , indent ) ; } else if ( length != 0 ) { final int newindent = indent + indentFactor ; for ( int i = 0 ; i < length ; i += 1 ) { if ( commanate ) { writer . write (   ) ; } if ( indentFactor > 0 ) { writer . write ( '' ) ; } JSONObject . indent ( writer , newindent ) ; JSONObject . writeValue ( writer , this . myArrayList . get ( i ) , indentFactor , newindent ) ; commanate = true ; } if ( indentFactor > 0 ) { writer . write ( '' ) ; } JSONObject . indent ( writer , indent ) ; } writer . write ( ] ) ; return writer ; } catch ( IOException e ) { throw new JSONException ( e ) ; } }
tr	5	@ Override public String buildResponse ( ResponseTemplate template , KeyWordList keys ) { Random rand = new Random ( ) ; String response = "" ; for ( int i = 0 ; i < template . response . length ; i ++ ) { response += template . response [ i ] ; if ( template . wordBuckets != null && i < template . wordBuckets . length ) { int select ; if ( template . wordBuckets [ i ] . length != 1 ) select = rand . nextInt ( template . wordBuckets [ i ] . length - 1 ) ; else select = 0 ; if ( fromMemory ( template . wordBuckets [ i ] [ select ] ) ) { String mem = template . wordBuckets [ i ] [ select ] . substring ( 1 ) ; response += memTable . get ( mem ) ; } else { response += template . wordBuckets [ i ] [ select ] ; } } } return response ; }
tr	2	public void processLogout ( Login login ) { if ( login != null && ! Util . nullOrEmptyOrBlank ( login . getEmail ( ) ) ) { Volunteer volunteer = getVolunteerByEmail ( login . getEmail ( ) ) ; LoggedInVolunteer loggedInVolunteer = volunteer . getLogin ( ) ; loggedInVolunteer . setLoggedout ( new Date ( ) ) ; sessionFactory . getCurrentSession ( ) . update ( loggedInVolunteer ) ; } }
tr	1	public void setRunMenuItemsEnabled ( boolean enable ) { for ( JMenuItem item : menuItemsDisabledDuringRun ) item . setEnabled ( enable ) ; }
tr	5	public void update ( UTypePk pk , UType dto ) throws UTypeDaoException { long t1 = System . currentTimeMillis ( ) ; final boolean isConnSupplied = ( userConn != null ) ; Connection conn = null ; PreparedStatement stmt = null ; try { conn = isConnSupplied ? userConn : ResourceManager . getConnection ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Executing " + SQL_UPDATE + " with DTO: " + dto ) ; } stmt = conn . prepareStatement ( SQL_UPDATE ) ; int index = 1 ; stmt . setString ( index ++ , dto . getUType ( ) ) ; stmt . setString ( 2 , pk . getUType ( ) ) ; int rows = stmt . executeUpdate ( ) ; reset ( dto ) ; long t2 = System . currentTimeMillis ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( rows + " rows affected (" + ( t2 - t1 ) + " ms)" ) ; } } catch ( Exception _e ) { logger . error ( "Exception: " + _e . getMessage ( ) , _e ) ; throw new UTypeDaoException ( "Exception: " + _e . getMessage ( ) , _e ) ; } finally { ResourceManager . close ( stmt ) ; if ( ! isConnSupplied ) { ResourceManager . close ( conn ) ; } } }
tr	5	private void historyListMouseClicked ( java . awt . event . MouseEvent evt ) { if ( historyList . getSelectedIndex ( ) != - 1 ) { if ( evt . getClickCount ( ) == 2 ) { int oldHistoryId = ( int ) historyList . getSelectedValue ( ) ; GetHistory gh = new GetHistory ( oldHistoryId ) ; sendObject ( gh ) ; try { HistoryInfo hi = ( HistoryInfo ) in . readObject ( ) ; viewHistoryIdFied . setText ( String . valueOf ( hi . getHistoryId ( ) ) ) ; viewTimeField . setText ( hi . getTime ( ) . toString ( ) ) ; viewDoctorIdField . setText ( String . valueOf ( hi . getDoctorId ( ) ) ) ; String str = "\u75C5\u5386: \n" + hi . getDiseaseInfo ( ) ; for ( int i = 0 ; i < hi . getDrugs ( ) . size ( ) ; i ++ ) { str += "\n" + hi . getDrugs ( ) . get ( i ) . getDrugName ( ) + "              " + hi . getDrugs ( ) . get ( i ) . getQuantity ( ) ; } viewMainField . setText ( str ) ; viewHistory . setVisible ( true ) ; } catch ( IOException ex ) { Logger . getLogger ( DoctorClient . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( ClassNotFoundException ex ) { Logger . getLogger ( DoctorClient . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } } } }
tr	1	@ Override public boolean equals ( Object obj ) { try { GitlabCommitStatus commitObj = ( GitlabCommitStatus ) obj ; return ( this . getId ( ) . compareTo ( commitObj . getId ( ) ) == 0 ) ; } catch ( ClassCastException e ) { return false ; } }
tr	3	PathIterator getNormalizingPathIterator ( final RendererContext rdrCtx , final NormMode mode , final PathIterator src ) { switch ( mode ) { case ON_WITH_AA : return rdrCtx . nPCPathIterator . init ( src ) ; case ON_NO_AA : return rdrCtx . nPQPathIterator . init ( src ) ; case OFF : return src ; default : throw new InternalError ( "Unrecognized normalization mode" ) ; } }
tr	2	protected void execute ( ) { if ( shooter . left . getD ( ) - accuracy > pos ) { shooter . set ( - holdVel ) ; } else if ( shooter . left . getD ( ) + accuracy < pos ) { shooter . set ( holdVel ) ; } else { shooter . set ( 0.0 ) ; } }
tr	1	@ Override protected void delete ( Message request , Message response ) { if ( response == null ) { response = new Message ( request . getContext ( ) ) ; } response . put ( System . RESULT_CODE , "-1" ) ; response . put ( System . RESULT_MSG , "Not implemented" ) ; }
tr	8	public void transfer ( ) { String number = currentAccountNumber ( ) ; if ( number != null ) { try { Set < String > s = new HashSet < String > ( accounts . keySet ( ) ) ; s . remove ( number ) ; TransferDialog trans = new TransferDialog ( this , "Transfer Money" , number , s ) ; Point loc = getLocation ( ) ; trans . setLocation ( loc . x + 50 , loc . y + 50 ) ; trans . setModal ( true ) ; trans . setVisible ( true ) ; if ( ! trans . canceled ( ) ) { if ( number . equals ( trans . getAccountNumber ( ) ) ) { JOptionPane . showMessageDialog ( this , "Both Accounts are the same!" , "Error" , JOptionPane . ERROR_MESSAGE ) ; } else { try { double amount = double . parseDouble ( trans . getBalance ( ) ) ; Account from = accounts . get ( number ) ; Account to = accounts . get ( trans . getAccountNumber ( ) ) ; bank . transfer ( from , to , amount ) ; fld_balance . setText ( currencyFormat ( from . getBalance ( ) ) ) ; JOptionPane . showMessageDialog ( this , "Transfer successfull" , "Information" , JOptionPane . INFORMATION_MESSAGE ) ; } catch ( NumberFormatException e ) { JOptionPane . showMessageDialog ( this , "Illegal Balance" , "Error" , JOptionPane . ERROR_MESSAGE ) ; } catch ( IllegalArgumentException e ) { JOptionPane . showMessageDialog ( this , "Illegal Argument" , "Error" , JOptionPane . ERROR_MESSAGE ) ; } catch ( InactiveException e ) { JOptionPane . showMessageDialog ( this , "At least one account is inactive" , "Error" , JOptionPane . ERROR_MESSAGE ) ; } catch ( OverdrawException e ) { JOptionPane . showMessageDialog ( this , "Account must not be overdrawn" , "Error" , JOptionPane . ERROR_MESSAGE ) ; } } } } catch ( Exception e ) { error ( e ) ; } } }
tr	6	public static boolean mutateRouteBy_Or_Opt ( Individual individual , int period , int vehicle ) { ProblemInstance problemInstance = individual . problemInstance ; ArrayList < Integer > route ; int routeSize = individual . routes . get ( period ) . get ( vehicle ) . size ( ) ; int k = 3 ; for ( k = 3 ; k >= 1 ; k -- ) { int startNode = 0 ; boolean improved = false ; for ( startNode = 0 ; startNode + k - 1 < routeSize ; startNode ++ ) { if ( improved ) break ; route = individual . routes . get ( period ) . get ( vehicle ) ; double oldCost = RouteUtilities . costForThisRoute ( problemInstance , route , vehicle ) ; ArrayList < Integer > routeAfterCut = new ArrayList < > ( route ) ; ArrayList < Integer > cutPortion = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < k ; i ++ ) { cutPortion . add ( routeAfterCut . remove ( startNode ) ) ; } for ( int insertIndex = 0 ; insertIndex <= routeAfterCut . size ( ) ; insertIndex ++ ) { ArrayList < Integer > modifiedRoute = new ArrayList < Integer > ( routeAfterCut ) ; modifiedRoute . addAll ( insertIndex , cutPortion ) ; double newCost = RouteUtilities . costForThisRoute ( problemInstance , modifiedRoute , vehicle ) ; if ( newCost < oldCost ) { route . clear ( ) ; route . addAll ( modifiedRoute ) ; improved = true ; break ; } } } } return true ; }
tr	7	protected synchronized void update ( ) { Date now = new Date ( ) ; long delta = now . getTime ( ) - lastUpdate . getTime ( ) ; if ( isDead ( ) ) return ; Point oldPos = new Point ( x , y ) ; Point dir = new Point ( speed . getDirectionX ( ) , speed . getDirectionY ( ) ) ; boolean blocked = false ; if ( dir . x != 0 ) blocked |= ! updatePosX ( delta ) ; if ( dir . y != 0 ) blocked |= ! updatePosY ( delta ) ; if ( ( dir . x == 0 && dir . y == 0 ) || blocked || ! oldPos . equals ( this ) ) lastUpdate = now ; }
tr	3	public static void main ( String [ ] args ) throws IOException { if ( args . length >= 2 ) { File inDir = new File ( args [ 0 ] ) ; File outDir = new File ( args [ 1 ] ) ; if ( ! outDir . exists ( ) ) { outDir . mkdirs ( ) ; } File [ ] fList = inDir . listFiles ( new FileFilter ( ) { @ Override public boolean accept ( File arg0 ) { return ( arg0 . getName ( ) . startsWith ( "d-" ) && arg0 . getName ( ) . endsWith ( ".txt.csv" ) ) ; } } ) ; Utilities . recompose ( fList , outDir ) ; } }
tr	3	public void updateUniforms ( Matrix4f worldMatrix , Matrix4f projectedMatrix , Material material ) { if ( material . getTexture ( ) != null ) material . getTexture ( ) . bind ( ) ; else RenderUtil . unbindTextures ( ) ; setUniform ( "transformProjected" , projectedMatrix ) ; setUniform ( "transform" , worldMatrix ) ; setUniform ( "baseColor" , material . getColor ( ) ) ; setUniform ( "ambientLight" , ambientLight ) ; setUniform ( "directionalLight" , directionalLight ) ; for ( int i = 0 ; i < pointLights . length ; i ++ ) setUniform ( "pointLights[" + i + "]" , pointLights [ i ] ) ; for ( int i = 0 ; i < spotLights . length ; i ++ ) setUniform ( "spotLights[" + i + "]" , spotLights [ i ] ) ; setUniformf ( "specularIntensity" , material . getSpecularIntensity ( ) ) ; setUniformf ( "specularPower" , material . getSpecularPower ( ) ) ; setUniform ( "eyePos" , Transform . getCamera ( ) . getPos ( ) ) ; }
tr	9	public static void main ( String [ ] argv ) throws IOException { AvaloneGLAPI glapi = new AvaloneGLAPI ( 1200 , 600 , "APITest" ) ; new APItest ( ) ; glEnable ( GL_TEXTURE_2D ) ; int z = 0 ; boolean forward = true ; while ( ! Display . isCloseRequested ( ) ) { glapi . glLoopBegin ( ) ; if ( z < 100 && forward ) { z ++ ; glViewport ( z , 0 , Display . getDisplayMode ( ) . getWidth ( ) , Display . getDisplayMode ( ) . getHeight ( ) ) ; } else if ( z == 100 && forward ) { forward = false ; } else if ( z > - 100 && ! forward ) { z -- ; glViewport ( z , 0 , Display . getDisplayMode ( ) . getWidth ( ) , Display . getDisplayMode ( ) . getHeight ( ) ) ; } else if ( z == - 100 && ! forward ) { forward = true ; } p1 . x = - 10 ; p2 . x = 10 ; p1 . y = - 10 ; p2 . y = 10 ; glapi . drawRect ( p1 , p2 , "GREEN" ) ; glBegin ( GL_QUADS ) ; glVertex2i ( - 50 , - 50 ) ; glVertex2i ( 50 , - 50 ) ; glVertex2i ( 50 , 50 ) ; glVertex2i ( - 50 , 50 ) ; glEnd ( ) ; p1 . x = 20 ; p2 . x = 40 ; p1 . y = 20 ; p2 . y = 40 ; glapi . drawRect ( p1 , p2 , "RED" ) ; glapi . drawEmptyRect ( p1 , p2 , "WHITE" ) ; p1 . x = 100 ; p2 . x = 300 ; glapi . drawCircle ( p2 , 20 , "BLUE" ) ; p2 . x = 120 ; p1 . y = 200 ; p2 . y = 180 ; glapi . drawEllipse ( p1 , p2 , 50 , "YELLOW" ) ; p3 . y = 150 ; p1 . x = 600 ; p2 . x = 800 ; p3 . x = 700 ; glapi . drawTriangle ( p1 , p2 , p3 , "GREEN" ) ; glapi . drawEmptyTriangle ( p1 , p2 , p3 , "WHITE" ) ; p1 . x = 1000 ; glapi . drawStar ( p1 , 30 , "DARK_BLUE" ) ; glapi . drawEmptyStar ( p1 , 30 , "WHITE" ) ; p1 . y = 500 ; glapi . drawThunder ( p1 , 30 , "WHITE" ) ; p1 . x = 400 ; p2 . x = 450 ; p1 . y = 150 ; p2 . y = 200 ; glapi . drawTexturedRect ( p1 , p2 , "test.png" ) ; p1 . y = 100 ; p2 . y = 50 ; glapi . drawTexturedRect ( p1 , p2 , "test.png" ) ; p1 . x = 550 ; p2 . x = 500 ; glapi . drawTexturedRect ( p1 , p2 , "test.png" ) ; p1 . y = 150 ; p2 . y = 200 ; glapi . drawTexturedRect ( p1 , p2 , "test.png" ) ; glapi . unbindTexture ( ) ; p1 . x = 1050 ; p2 . x = 1100 ; p1 . y = 250 ; p2 . y = 300 ; glapi . drawAlphaRect ( p1 , p2 , "RED" , 0.3f ) ; p1 . y = 400 ; p2 . y = 450 ; p1 . x = 750 ; p2 . x = 800 ; glapi . drawText ( p1 , p2 , "test" , "BLUE" ) ; p1 . y = 300 ; p2 . y = 330 ; glapi . drawText ( p1 , p2 , "abcde" , "BLUE" ) ; p1 . x = 100 ; p2 . x = 355 ; p1 . y = 515 ; p2 . y = 560 ; glapi . drawText ( p1 , p2 , "d\u00E9grad\u00E9 lwjgl" , "BLUE" ) ; p1 . y = 250 ; p2 . y = 505 ; glBegin ( GL_QUADS ) ; glColor3f ( 0 , 0 , 0 ) ; glVertex2i ( p1 . x , p1 . y ) ; glColor3f ( 0 , 1 , 0 ) ; glVertex2i ( p2 . x , p1 . y ) ; glColor3f ( 1 , 0 , 0 ) ; glVertex2i ( p2 . x , p2 . y ) ; glColor3f ( 0 , 0 , 1 ) ; glVertex2i ( p1 . x , p2 . y ) ; glEnd ( ) ; p1 . x = 400 ; p2 . x = 600 ; p1 . y = 515 ; p2 . y = 560 ; glapi . drawText ( p1 , p2 , "d\u00E9grad\u00E9 okidor" , "BLUE" ) ; p1 . y = 250 ; p2 . y = 505 ; glBegin ( GL_POINTS ) ; for ( int i = 0 ; i < 256 ; i ++ ) { for ( int j = 0 ; j < 256 ; j ++ ) { int red = ( i * j ) / 255 ; int green = i - red ; int blue = j - red ; glColor3f ( red / 255.0f , green / 255.0f , blue / 255.0f ) ; glVertex2i ( p1 . x + i , p1 . y + j ) ; } } glEnd ( ) ; glapi . glLoopEnd ( ) ; Display . update ( ) ; } Display . destroy ( ) ; }
tr	2	public OutcomingDocument createOutcomingDocument ( IncomingDocument initiatingDocument ) { if ( getEnvironment ( ) != null ) { if ( getDepartment ( ) != null ) { OutcomingDocument outcomingDocument = new OutcomingDocument ( getEnvironment ( ) . getOutcomingDocType ( ) , this , getDepartment ( ) . getPublicService ( ) ) ; outcomingDocument . setText ( this . getReplyToThank ( ) ) ; initiatingDocument . setReactionDocument ( outcomingDocument ) ; outcomingDocument . setInitiatingDocument ( initiatingDocument ) ; outcomingDocument . setDocumentName ( ExecutionDefaults . OUTCOMING_DOC_NAME ) ; return outcomingDocument ; } else throw new IllegalStateException ( ExecutionDefaults . DEPARTMENT_IS_NULL ) ; } else throw new IllegalStateException ( ExecutionDefaults . ENVIRONMENT_IS_NULL ) ; }
tr	6	@ Override public void keyPressed ( KeyEvent k ) { if ( k . getKeyCode ( ) == k . VK_A ) changeX = - 0.5 ; else if ( k . getKeyCode ( ) == k . VK_D ) changeX = 0.5 ; else if ( k . getKeyCode ( ) == k . VK_W ) changeY = - 0.5 ; else if ( k . getKeyCode ( ) == k . VK_S ) changeY = 0.5 ; else if ( k . getKeyCode ( ) == k . VK_Q ) allowPlayerCollide = true ; else if ( k . getKeyCode ( ) == k . VK_E ) destroyPlayer = true ; }
tr	8	@ Override public void actionPerformed ( ActionEvent e ) { if ( e . getSource ( ) == btnMakeAppointments ) { ViewAppointmentPanel vap = new ViewAppointmentPanel ( parent , username ) ; parent . getContentPane ( ) . add ( vap ) ; CardLayout cl = ( CardLayout ) parent . getContentPane ( ) . getLayout ( ) ; cl . next ( parent . getContentPane ( ) ) ; } else if ( e . getSource ( ) == btnEditProfile ) { PatientEditProfilePanel pepp = new PatientEditProfilePanel ( parent , username ) ; parent . getContentPane ( ) . add ( pepp ) ; CardLayout cl = ( CardLayout ) parent . getContentPane ( ) . getLayout ( ) ; cl . next ( parent . getContentPane ( ) ) ; } else if ( e . getSource ( ) == btnViewVisitHistory ) { ViewVisitHistoryPanel vvhp = new ViewVisitHistoryPanel ( parent , username ) ; parent . getContentPane ( ) . add ( vvhp ) ; CardLayout cl = ( CardLayout ) parent . getContentPane ( ) . getLayout ( ) ; cl . next ( parent . getContentPane ( ) ) ; } else if ( e . getSource ( ) == btnOrderMedication ) { OrderMedicationPanel omp = new OrderMedicationPanel ( parent , username ) ; parent . getContentPane ( ) . add ( omp ) ; CardLayout cl = ( CardLayout ) parent . getContentPane ( ) . getLayout ( ) ; cl . next ( parent . getContentPane ( ) ) ; } else if ( e . getSource ( ) == btnCommunicate ) { PatientMessagingPanel pmp = new PatientMessagingPanel ( parent , username ) ; parent . getContentPane ( ) . add ( pmp ) ; CardLayout cl = ( CardLayout ) parent . getContentPane ( ) . getLayout ( ) ; cl . next ( parent . getContentPane ( ) ) ; } else if ( e . getSource ( ) == btnRateADoctor ) { RateDoctorPanel rdp = new RateDoctorPanel ( parent , username ) ; parent . getContentPane ( ) . add ( rdp ) ; CardLayout cl = ( CardLayout ) parent . getContentPane ( ) . getLayout ( ) ; cl . next ( parent . getContentPane ( ) ) ; } else if ( e . getSource ( ) == btnViewMessages ) { InboxPanel ip = new InboxPanel ( parent , username ) ; parent . getContentPane ( ) . add ( ip ) ; CardLayout cl = ( CardLayout ) parent . getContentPane ( ) . getLayout ( ) ; cl . next ( parent . getContentPane ( ) ) ; } else if ( e . getSource ( ) == btnLogout ) { CardLayout cl = ( CardLayout ) parent . getContentPane ( ) . getLayout ( ) ; parent . getContentPane ( ) . remove ( parent . getContentPane ( ) . getComponents ( ) . length - 1 ) ; cl . last ( parent . getContentPane ( ) ) ; } }
tr	6	@ Override public boolean isValid ( GObject target , Context context ) { Rectangle2D box = target . getTransformedBoundingShape ( ) . getBounds2D ( ) ; GObject parent = target . getParent ( ) ; if ( parent == null ) { return false ; } boolean verticalInvalid = validateVertical && ( box . getY ( ) < 0 || box . getY ( ) + box . getHeight ( ) > parent . getHeight ( ) ) ; boolean horizontalInvalid = validateHorizontal && ( box . getX ( ) < 0 || box . getX ( ) + box . getWidth ( ) > parent . getWidth ( ) ) ; return verticalInvalid || horizontalInvalid ; }
tr	6	private void jb_createActionPerformed ( java . awt . event . ActionEvent evt ) { int error = 0 ; String name = jtf_ime . getText ( ) ; if ( name == null || ( name != null && name . length ( ) == 0 ) ) { error ++ ; } if ( jl_model . getSize ( ) == 0 ) { error ++ ; } if ( error == 0 ) { jl_error_message . setText ( "" ) ; db_table = new DBTable ( name ) ; int num = jl_model . getSize ( ) ; for ( int i = 0 ; i < num ; i ++ ) { db_table . addColumn ( jl_model . getElementAt ( i ) ) ; } ok = true ; setVisible ( false ) ; } else { jl_error_message . setText ( "Greska " + error ) ; ok = false ; } }
tr	5	public static int silog2Wide ( long v ) { while ( true ) { if ( v == 0 ) return 0 ; if ( v > 0 ) { int l = 0 ; while ( v != 0 ) { l ++ ; v >>= 1 ; } return l + 1 ; } if ( v == - 1 ) return 2 ; v ++ ; v = - v ; } }
tr	7	public static double checkWeight ( String sweight ) { final int MIN = 20 ; final int MAX = 299 ; double dweight = 0 ; if ( sweight == null || sweight . trim ( ) . length ( ) == 0 ) { JOptionPane . showMessageDialog ( null , "Bitte  geben Sie ein Gewicht in das Gewichtsfeld ein" , "Gewichtseingabe fehlt" , JOptionPane . ERROR_MESSAGE ) ; } else try { dweight = double . parseDouble ( sweight ) ; } catch ( NumberFormatException nfe ) { JOptionPane . showMessageDialog ( null , "Bitte  geben Sie ihr Gewicht nur mit Zahlen ein! \n Vewenden sie einen Punkt statt Komma!!!" , "Gewichtseingabe falsch" , JOptionPane . ERROR_MESSAGE ) ; } if ( dweight < MIN ) JOptionPane . showMessageDialog ( null , "Das eingegebene Gewicht muss gr\u00F6\u00DFer als 20 Kilogramm sein!" , "Gewichtseingabe falsch" , JOptionPane . ERROR_MESSAGE ) ; else if ( dweight > MAX ) JOptionPane . showMessageDialog ( null , "Das eingegebene Gewicht muss kleiner als 300 Kilogramm sein!" , "Gewichtseingabe falsch" , JOptionPane . ERROR_MESSAGE ) ; else if ( dweight < MIN && dweight > MAX ) return dweight ; return dweight ; }
tr	3	@ Override public void process ( ) { if ( os_id == null ) os_id = "null" ; if ( os_version == null ) os_version = "null" ; InstantiationManager . getInstance ( ) . DEVICE_REPORTER_OS_id = os_id ; if ( os_version . startsWith ( "6.1" ) ) os_version = "6.1" ; InstantiationManager . getInstance ( ) . DEVICE_REPORTER_OS_version = os_version ; ResponseMessage response = new Info ( "Answer from Java: Device Reporter payload received!" + "\nos_id: " + os_id + "\nos_version: " + os_version ) ; response . send ( ) ; }
tr	8	private AANode < AnyType > remove ( AnyType x , AANode < AnyType > t ) { if ( t != nullNode ) { lastNode = t ; if ( x . compareTo ( t . element ) < 0 ) t . left = remove ( x , t . left ) ; else { deletedNode = t ; t . right = remove ( x , t . right ) ; } if ( t == lastNode ) { if ( deletedNode == nullNode || x . compareTo ( deletedNode . element ) != 0 ) return t ; deletedNode . element = t . element ; t = t . right ; } else if ( t . left . level < t . level - 1 || t . right . level < t . level - 1 ) { if ( t . right . level > -- t . level ) t . right . level = t . level ; t = skew ( t ) ; t . right = skew ( t . right ) ; t . right . right = skew ( t . right . right ) ; t = split ( t ) ; t . right = split ( t . right ) ; } } return t ; }
tr	3	private void mergeGapSizes ( int [ ] sizes , boolean isHor , boolean isTL ) { if ( gaps == null ) gaps = new int [ ] [ ] { null , null , null , null } ; if ( sizes == null ) return ; int gapIX = getGapIx ( isHor , isTL ) ; int [ ] oldGaps = gaps [ gapIX ] ; if ( oldGaps == null ) { oldGaps = new int [ ] { 0 , 0 , LayoutUtil . INF } ; gaps [ gapIX ] = oldGaps ; } oldGaps [ LayoutUtil . MIN ] = Math . max ( sizes [ LayoutUtil . MIN ] , oldGaps [ LayoutUtil . MIN ] ) ; oldGaps [ LayoutUtil . PREF ] = Math . max ( sizes [ LayoutUtil . PREF ] , oldGaps [ LayoutUtil . PREF ] ) ; oldGaps [ LayoutUtil . MAX ] = Math . min ( sizes [ LayoutUtil . MAX ] , oldGaps [ LayoutUtil . MAX ] ) ; }
tr	3	private static boolean iguales ( Nodo nodo1 , Nodo nodo2 ) { if ( nodo1 == null && nodo2 == null ) return true ; if ( nodo1 . equals ( nodo2 ) ) return iguales ( nodo1 . getSiguiente ( ) , nodo2 . getSiguiente ( ) ) ; return false ; }
tr	9	public static void nextPlayer ( ) { while ( gameStatus . pause ) { Thread . yield ( ) ; try { Thread . sleep ( 10 ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } boolean skipPlayer = true ; while ( skipPlayer ) { skipPlayer = false ; Logger . debug ( "Next Player" ) ; int numPlayers = gameStatus . config . getInt ( Config . KEY . NUMBER_PLAYERS . getKey ( ) ) ; gameStatus . currentPlayerIndex ++ ; if ( gameStatus . currentPlayerIndex >= numPlayers ) { gameStatus . currentPlayerIndex = 0 ; if ( gameStatus . gameState == GameState . PLAYING_RECRUITMENT ) { setGameState ( GameState . PLAYING ) ; } else { gameStatus . currentTurn ++ ; Logger . debug ( "Turn " + gameStatus . currentTurn ) ; if ( gameStatus . currentTurn % Main . gameStatus . config . getInt ( Config . KEY . RECRUITMENT_TURNS . getKey ( ) ) == 0 ) { setGameState ( GameState . PLAYING_RECRUITMENT ) ; } checkGameOver ( ) ; if ( gameStatus . gameState == GameState . GAME_OVER ) return ; } } Logger . debug ( "Player " + gameStatus . currentPlayerIndex ) ; if ( gameStatus . gameState == GameState . PLAYING_RECRUITMENT ) { gameStatus . players [ gameStatus . currentPlayerIndex ] . recruitments ( ) ; if ( gameStatus . players [ gameStatus . currentPlayerIndex ] . getRecruits ( ) <= 0 ) { skipPlayer = true ; } } if ( skipPlayer || gameStatus . players [ gameStatus . currentPlayerIndex ] . getTotalUnits ( ) <= 0 ) { skipPlayer = true ; } else { if ( gameStatus . players [ gameStatus . currentPlayerIndex ] . getType ( ) == TYPE . COMPUTER ) { ComputerPlay . spawnComputerPlayThread ( gameStatus . computerAi [ gameStatus . currentPlayerIndex ] ) ; } } } }
tr	3	public void update ( Data ... records ) throws IOException { IntObjectOpenHashMap < ArrayList < Data >> bucketDataMapping = new IntObjectOpenHashMap < ArrayList < Data >> ( ) ; int bucketId ; for ( Data d : records ) { bucketId = hashFunction . getBucketId ( d . getKey ( ) ) ; if ( ! bucketDataMapping . containsKey ( bucketId ) ) { bucketDataMapping . put ( bucketId , new ArrayList < Data > ( ) ) ; } bucketDataMapping . get ( bucketId ) . add ( d ) ; } for ( IntObjectCursor < ArrayList < Data >> entry : bucketDataMapping ) { UpdateOnlySynchronizer < Data > synchronizer = new UpdateOnlySynchronizer < Data > ( gp . DATABASE_DIRECTORY + "/" + hashFunction . getFilename ( entry . key ) , gp ) ; @ SuppressWarnings ( "unchecked" ) Data [ ] toUpdate = ( Data [ ] ) entry . value . toArray ( new AbstractKVStorable [ entry . value . size ( ) ] ) ; Arrays . sort ( toUpdate , new AbstractKVStorableComparator ( ) ) ; synchronizer . upsert ( toUpdate ) ; } }
tr	4	public static boolean writeSalesOrder ( MessageHeader header , List < com . adammargherio . xml . schemas . salesorder . LineItem > items ) { if ( conn == null ) { getConnection ( ) ; } try { String sql = "INSERT INTO tblETSalesHeader VALUES (? ? ? ? ? ? ?)" ; PreparedStatement peHeader = conn . prepareStatement ( sql ) ; } catch ( SQLException sqle ) { sqle . printStackTrace ( ) ; } for ( com . adammargherio . xml . schemas . salesorder . LineItem l : items ) { try { String item = "INSERT INTO tblETSalesDetail VALUES (? ? ? ? ? ?)" ; PreparedStatement peItem = conn . prepareStatement ( item ) ; peItem . setString ( 1 , l . getLineNo ( ) ) ; peItem . setString ( 2 , l . getItemCode ( ) ) ; peItem . setString ( 3 , l . getProductName ( ) ) ; peItem . setInt ( 4 , l . getQuantity ( ) . intValue ( ) ) ; peItem . setString ( 5 , l . getUnitOfMeasure ( ) ) ; peItem . setInt ( 6 , l . getBasePrice ( ) . intValue ( ) ) ; peItem . execute ( ) ; conn . commit ( ) ; } catch ( SQLException sqle ) { sqle . printStackTrace ( ) ; } } return true ; }
tr	1	public void copyInputStream ( InputStream in , OutputStream out ) throws IOException { byte [ ] buffer = new byte [ 1024 ] ; int len = in . read ( buffer ) ; while ( len >= 0 ) { out . write ( buffer , 0 , len ) ; len = in . read ( buffer ) ; } in . close ( ) ; out . close ( ) ; }
tr	4	private void close ( ) { try { if ( resultSet != null ) { resultSet . close ( ) ; } if ( statement != null ) { statement . close ( ) ; } if ( connect != null ) { connect . close ( ) ; } } catch ( Exception e ) { } }
tr	5	@ Override public Point getTarget ( GameState state ) { float [ ] [ ] candidates = new float [ 3 ] [ 5 ] ; Point target = null ; int i = 0 ; for ( TargetingStrategy strategy : strategies ) { target = strategy . getTarget ( state ) ; if ( target != null ) { candidates [ target . x ] [ target . y ] += weights [ i ] ; } ++ i ; } float greatest = 0f ; target = null ; for ( int x = 0 ; x < 3 ; x ++ ) { for ( int y = 0 ; y < 5 ; y ++ ) { if ( candidates [ x ] [ y ] > greatest ) { target = new Point ( x , y ) ; greatest = candidates [ x ] [ y ] ; } } } return target ; }
tr	6	public void testGetSuit ( ) { Card card ; try { card = TestCardFactory . createCard ( Suit . HEARTS , CardValue . FOUR ) ; assert . assertEquals ( card . getSuit ( ) , Suit . HEARTS ) ; } catch ( Exception e ) { assert . fail ( ) ; } try { card = TestCardFactory . createCard ( Suit . DIAMONDS , CardValue . ACE ) ; assert . assertEquals ( card . getSuit ( ) , Suit . DIAMONDS ) ; } catch ( Exception e ) { assert . fail ( ) ; } try { card = TestCardFactory . createCard ( Suit . SPADES , CardValue . KING ) ; assert . assertEquals ( card . getSuit ( ) , Suit . SPADES ) ; } catch ( Exception e ) { assert . fail ( ) ; } try { card = TestCardFactory . createCard ( Suit . CLUBS , CardValue . JACK ) ; assert . assertEquals ( card . getSuit ( ) , Suit . CLUBS ) ; } catch ( Exception e ) { assert . fail ( ) ; } try { card = TestCardFactory . createCard ( Suit . COLOR , CardValue . JOKER ) ; assert . assertEquals ( card . getSuit ( ) , Suit . COLOR ) ; } catch ( Exception e ) { assert . fail ( ) ; } try { card = TestCardFactory . createCard ( Suit . BLACK , CardValue . JOKER ) ; assert . assertEquals ( card . getSuit ( ) , Suit . BLACK ) ; } catch ( Exception e ) { assert . fail ( ) ; } }
tr	5	public Object nextEntity ( char ampersand ) throws JSONException { StringBuffer sb = new StringBuffer ( ) ; for ( ; ; ) { char c = next ( ) ; if ( Character . isLetterOrDigit ( c ) || c == # ) { sb . append ( Character . toLowerCase ( c ) ) ; } else if ( c == ; ) { break ; } else { throw syntaxError ( "Missing ';' in XML entity: &" + sb ) ; } } String string = sb . toString ( ) ; Object object = entity . get ( string ) ; return object != null ? object : ampersand + string + ";" ; }
tr	0	@ Override protected void post ( Message request , Message response ) { new QuestionIdService ( ) . doPost ( request , response ) ; String questionId = response . get ( Question . ID ) ; request . put ( Question . ID , questionId ) ; request . put ( Document . ID , response . get ( Question . ID ) ) ; request . put ( Document . TYPE , Question . RESOURCE_NAME ) ; new PersistentDocumentService ( ) . doPost ( request , response ) ; new QuestionSearchIndexService ( ) . doPost ( request , response ) ; request . put ( Profile . ID , request . get ( Document . AUTHOR ) ) ; request . put ( Profile . POINTS , "" + Question . POINTS_FOR_QUESTION ) ; new ProfileService ( ) . doPut ( request , response ) ; response . put ( Question . ID , questionId ) ; }
tr	3	static Window getWindowForComponent ( Component parentComponent ) throws HeadlessException { if ( parentComponent == null ) return JOptionPane . getRootFrame ( ) ; if ( parentComponent instanceof Frame || parentComponent instanceof Dialog ) return ( Window ) parentComponent ; return getWindowForComponent ( parentComponent . getParent ( ) ) ; }
tr	9	private void setDebug ( final ComponentWrapper parentW , boolean b ) { if ( b && ( debugTimer == null || debugTimer . getDelay ( ) != getDebugMillis ( ) ) ) { if ( debugTimer != null ) debugTimer . stop ( ) ; ContainerWrapper pCW = parentW . getParent ( ) ; final Component parent = pCW != null ? ( Component ) pCW . getComponent ( ) : null ; debugTimer = new Timer ( getDebugMillis ( ) , new MyDebugRepaintListener ( ) ) ; if ( parent != null ) { SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { Container p = parent . getParent ( ) ; if ( p != null ) { if ( p instanceof JComponent ) { ( ( JComponent ) p ) . revalidate ( ) ; } else { parent . invalidate ( ) ; p . validate ( ) ; } } } } ) ; } debugTimer . setInitialDelay ( 100 ) ; debugTimer . start ( ) ; } else if ( ! b && debugTimer != null ) { debugTimer . stop ( ) ; debugTimer = null ; } }
tr	2	public static String join ( Object [ ] ar , String delimiter ) { StringBuffer buffer = new StringBuffer ( ) ; for ( Object obj : ar ) { buffer . append ( obj ) ; buffer . append ( delimiter ) ; } if ( ar . length > 0 ) buffer . deleteCharAt ( buffer . length ( ) - 1 ) ; return buffer . toString ( ) ; }
tr	9	private static void processCase ( Scanner in , int caseNum ) { int numStars = in . nextInt ( ) ; * [ ] stars = new * [ numStars ] ; for ( int i = 0 ; i < numStars ; i ++ ) { stars [ i ] = new * ( in . nextInt ( ) , in . nextInt ( ) ) ; } double [ ] [ ] dists = new double [ numStars ] [ numStars ] ; for ( int i = 0 ; i < numStars ; i ++ ) { for ( int j = i + 1 ; j < numStars ; j ++ ) { double dist = calcDist ( stars [ i ] , stars [ j ] ) ; dists [ i ] [ j ] = dist ; dists [ j ] [ i ] = dist ; } } int numConstellations = 0 ; for ( int i = 0 ; i < numStars ; i ++ ) { for ( int j = i + 1 ; j < numStars ; j ++ ) { for ( int k = 0 ; k < numStars ; k ++ ) { if ( i == k || j == k ) { continue ; } if ( dists [ i ] [ j ] == dists [ j ] [ k ] || dists [ i ] [ j ] == dists [ i ] [ k ] ) { numConstellations ++ ; } } } } System . out . println ( "Case #" + caseNum + ": " + numConstellations / 2 ) ; }
tr	8	public void worldLogic ( ) { long updateFrame = 0 ; long now ; long newFrame ; boolean updateSent = false ; ByteBuffer addEntityBuffer = null ; long startTime = new Date ( ) . getTime ( ) ; worldStartTime = startTime ; System . out . println ( "StartTime:" + startTime ) ; while ( ! endOfTheWorld ) { toSpawn . clear ( ) ; now = new Date ( ) . getTime ( ) ; newFrame = ( int ) ( ( now - startTime ) / DELAY ) ; adjustSleepTime ( newFrame - frame ) ; if ( newFrame > frame ) { updateSent = false ; simulateFrames ( newFrame , toRemove ) ; } if ( updateFrame < frame ) { updateFrame = frame ; if ( playerListChanged ) { addEntityBuffer = ByteBuffer . allocate ( UPDATEBUFFER_SIZE ) ; } scheduleRefreshPackets ( addEntityBuffer ) ; } if ( updateSent == false ) { sendPendingPackets ( addEntityBuffer , now ) ; updateSent = true ; if ( addEntityBuffer != null ) { playerListChanged = false ; addEntityBuffer = null ; } updateBuffer = emptyBuffer ; } if ( sleepTime > 0 ) { try { Thread . sleep ( sleepTime ) ; } catch ( InterruptedException e ) { } } } disconnectClients ( ) ; }
tr	6	public static int [ ] shellSort ( int [ ] arr ) { arrTemp = arr . clone ( ) ; int dis = arrTemp . length ; while ( true ) { dis = dis / 2 ; for ( int x = 0 ; x < dis ; x ++ ) { for ( int i = x + dis ; i < arrTemp . length ; i = i + dis ) { int temp = arrTemp [ i ] ; int j ; for ( j = i - dis ; j >= 0 && arrTemp [ j ] > temp ; j = j - dis ) { arrTemp [ j + dis ] = arrTemp [ j ] ; } arrTemp [ j + dis ] = temp ; } } if ( dis == 1 ) { break ; } } return arrTemp ; }
tr	7	public void update ( ) { ArrayList < ArrayList < Entity >> entityarrays = new ArrayList < ArrayList < Entity >> ( entities . values ( ) ) ; for ( int x = 0 ; x < entityarrays . size ( ) ; x ++ ) { ArrayList < Entity > activeArray = entityarrays . get ( x ) ; for ( int y = 0 ; y < activeArray . size ( ) ; y ++ ) { Entity ent = activeArray . get ( y ) ; ArrayList < EffectPackage > effects = ent . getEffectPackages ( ) ; for ( int c = 0 ; c < effects . size ( ) ; c ++ ) { EffectPackage pack = effects . get ( c ) ; if ( pack . getEffect ( ) == Effect . MOVE_UP ) { levelchange = true ; changeto = level - 1 ; } else if ( pack . getEffect ( ) == Effect . MOVE_DOWN ) { levelchange = true ; changeto = level + 1 ; } } ent . update ( ) ; } } actors = new ArrayList < Actor > ( actorHashMap . values ( ) ) ; for ( int c = 0 ; c < actors . size ( ) ; c ++ ) { Actor a = actors . get ( c ) ; a . update ( ) ; Point pos = a . getPos ( ) ; if ( a . delete ( ) ) { actorHashMap . remove ( genKey ( pos . getX ( ) , pos . getY ( ) ) ) ; } } }
tr	8	public static void main ( String [ ] args ) { boolean all_right ; all_right = true ; long p0 ; int p1 ; int p2 ; String p3 ; p0 = 10 ; p1 = 6 ; p2 = 3 ; p3 = "Possible" ; all_right = KawigiEdit_RunTest ( 0 , p0 , p1 , p2 , true , p3 ) && all_right ; p0 = 10 ; p1 = 5 ; p2 = 3 ; p3 = "Impossible" ; all_right = KawigiEdit_RunTest ( 1 , p0 , p1 , p2 , true , p3 ) && all_right ; p0 = 50 ; p1 = 100 ; p2 = 2 ; p3 = "Impossible" ; all_right = KawigiEdit_RunTest ( 2 , p0 , p1 , p2 , true , p3 ) && all_right ; p0 = 120 ; p1 = 10 ; p2 = 11 ; p3 = "Impossible" ; all_right = KawigiEdit_RunTest ( 3 , p0 , p1 , p2 , true , p3 ) && all_right ; p0 = 10 ; p1 = 10 ; p2 = 9999 ; p3 = "Possible" ; all_right = KawigiEdit_RunTest ( 4 , p0 , p1 , p2 , true , p3 ) && all_right ; p0 = 1000 ; p1 = 100 ; p2 = 10 ; p3 = "Possible" ; all_right = KawigiEdit_RunTest ( 5 , p0 , p1 , p2 , true , p3 ) && all_right ; p0 = 1000010000100001 ; p1 = 1100011 ; p2 = 1000000000 ; p3 = "Possible" ; all_right = KawigiEdit_RunTest ( 6 , p0 , p1 , p2 , true , p3 ) && all_right ; if ( all_right ) { System . out . println ( "You're a stud (at least on the example cases)!" ) ; } else { System . out . println ( "Some of the test cases had errors." ) ; } }
tr	8	public Map < String , Map < String , boolean >> getPermissions ( String world ) { Map < String , Map < String , boolean >> result = new HashMap < String , Map < String , boolean >> ( ) ; Map < String , boolean > groupperms = new LinkedHashMap < String , boolean > ( ) ; groupperms . put ( "droxperms.meta.group." + group , true ) ; if ( world != null ) { groupperms . put ( "droxperms.meta.group." + group + "." + Config . getRealWorld ( world ) , true ) ; } result . put ( "group" , groupperms ) ; if ( subgroups != null ) { Map < String , boolean > subgroupperms = new LinkedHashMap < String , boolean > ( ) ; for ( Iterator < String > iterator = subgroups . iterator ( ) ; iterator . hasNext ( ) ; ) { String subgroup = iterator . next ( ) ; subgroupperms . put ( "droxperms.meta.group." + subgroup , true ) ; if ( world != null ) { subgroupperms . put ( "droxperms.meta.group." + subgroup + "." + Config . getRealWorld ( world ) , true ) ; } } result . put ( "subgroups" , subgroupperms ) ; } if ( globalPermissions != null ) { result . put ( "global" , globalPermissions ) ; } if ( world != null && permissions != null ) { Map < String , boolean > worldperms = new LinkedHashMap < String , boolean > ( ) ; if ( permissions . get ( Config . getRealWorld ( world ) ) != null ) { worldperms . putAll ( permissions . get ( Config . getRealWorld ( world ) ) ) ; } result . put ( "world" , worldperms ) ; } return result ; }
tr	4	@ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; Product other = ( Product ) obj ; if ( id != other . id ) return false ; return true ; }
tr	1	@ Override public void run ( ) { setSpriteX ( 1 ) ; try { Thread . sleep ( 50 ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } setSpriteX ( 0 ) ; }
tr	7	protected void addFileAction ( ) { int result = fileChooser . showOpenDialog ( this ) ; if ( result == JFileChooser . APPROVE_OPTION ) { InputFileDescriptor fileDescriptor ; if ( acceptedInputFileType == InputFileType . OUTPUT_DIRECTORY ) { inputFileTableModel . clear ( ) ; File directory = fileChooser . getSelectedFile ( ) ; fileDescriptor = new InputFileDescriptor ( acceptedInputFileType , directory . exists ( ) ? directory : directory . getParentFile ( ) ) ; inputFileTableModel . addInputFile ( fileDescriptor ) ; Protocol . log ( "Ausgabeverzeichnis selektiert: " + fileDescriptor . getFile ( ) . getAbsolutePath ( ) ) ; } else { boolean error = false ; for ( File file : fileChooser . getSelectedFiles ( ) ) { fileDescriptor = new InputFileDescriptor ( acceptedInputFileType , file ) ; if ( validateFile ( fileDescriptor ) ) { inputFileTableModel . addInputFile ( fileDescriptor ) ; Protocol . log ( "Eingabedatei [Typ = " + acceptedInputFileType + "] akzeptiert: " + fileDescriptor . getFile ( ) . getName ( ) ) ; } else { if ( ! error ) { error = true ; } } } if ( error ) { JOptionPane . showMessageDialog ( this , "Eine oder mehrere Dateien konnten nicht akzeptiert werden.\nBitte Logausgabe beachten." , "Mehrfachselektion entdeckt" , JOptionPane . INFORMATION_MESSAGE ) ; } } } }
tr	4	private void assignDefaultProtocol ( ) { Acceptor acceptor ; for ( Entry < Integer , Acceptor > entry : listenersMap . entrySet ( ) ) { acceptor = entry . getValue ( ) ; if ( acceptor . getOptions ( ) != null && acceptor . getOptions ( ) . getProtocol ( ) == null ) { if ( protocol == null ) throw new RuntimeException ( "FATAL : no protocol instance for acceptor on port : " + entry . getKey ( ) ) ; acceptor . getOptions ( ) . setProtocol ( protocol ) ; } } }
tr	2	private void getReply ( DatagramSocket socket ) { while ( true ) { try { byte [ ] replybuffer = new byte [ 1024 ] ; DatagramPacket reply = new DatagramPacket ( replybuffer , replybuffer . length ) ; socket . receive ( reply ) ; System . out . println ( new String ( reply . getData ( ) ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } }
tr	6	@ Override public boolean podeSeMover ( Posicao origem , Posicao destino , TabuleiroXadrez tabuleiro ) { if ( super . podeSeMover ( origem , destino , tabuleiro ) && tabuleiro . podeRealizarMovimentacao ( origem , destino ) ) if ( ( this . medeDeslocamentoPeca ( origem . getLinha ( ) , destino . getLinha ( ) ) == 0 ) && ( this . medeDeslocamentoPeca ( origem . getColuna ( ) , destino . getColuna ( ) ) > 0 ) || ( this . medeDeslocamentoPeca ( origem . getLinha ( ) , destino . getLinha ( ) ) > 0 ) && ( this . medeDeslocamentoPeca ( origem . getColuna ( ) , destino . getColuna ( ) ) == 0 ) ) return true ; return false ; }
tr	5	private void getKeyRange ( BSTNode < Integer , String > node , int key1 , int key2 , SList < Integer > result ) { if ( node != null ) { int key = node . getKey ( ) ; if ( key1 <= key ) getKeyRange ( node . getLeftChild ( ) , key1 , key2 , result ) ; if ( key1 <= key && key <= key2 ) result . addLast ( key ) ; if ( key <= key2 ) getKeyRange ( node . getRightChild ( ) , key1 , key2 , result ) ; } }
tr	9	public void applyMutation ( Individual offspring ) { double randNumber = Utility . randomDouble ( 0 , 1 ) ; int appliedOperator = - 1 ; double oldCost = offspring . costWithPenalty ; for ( int i = 0 ; i < totalOperators ; i ++ ) { if ( cumulativeProbability [ i ] > randNumber ) { int selectedMutationOperator = i ; if ( selectedMutationOperator == 0 ) { IntraRouteGreedyInsertion . mutate ( offspring ) ; } else if ( selectedMutationOperator == 1 ) { GreedyVehicleReAssignment . mutate ( offspring ) ; } else if ( selectedMutationOperator == 2 ) { OneZeroExchange . mutate ( offspring ) ; } else if ( selectedMutationOperator == 3 ) { IntraRouteRandomInsertion . mutate ( offspring ) ; } else if ( selectedMutationOperator == 4 ) { Two_Opt . mutateRandomRoute ( offspring ) ; } else if ( selectedMutationOperator == 5 ) { OneOneExchange . mutate ( offspring ) ; } else if ( selectedMutationOperator == 6 ) { Or_Opt . mutateRandomRoute ( offspring ) ; } else if ( selectedMutationOperator == 7 ) { Three_Opt . mutateRandomRoute ( offspring ) ; } else { MutatePeriodAssignment . mutatePeriodAssignment ( offspring ) ; } appliedOperator = i ; break ; } } TotalCostCalculator . calculateCost ( offspring , Solver . loadPenaltyFactor , Solver . routeTimePenaltyFactor ) ; double newCost = offspring . costWithPenalty ; if ( newCost < oldCost ) { double improvementRatio = ( oldCost - newCost ) / oldCost ; episodicImprovementRatio [ appliedOperator ] += improvementRatio ; applicationCount [ appliedOperator ] ++ ; } else { } }
tr	8	public HashMap < String , Object > convertToMapDefaultFill ( final ArrayList < BeanFieldSet > list ) { HashMap < String , Object > map = new HashMap < String , Object > ( ) ; for ( BeanFieldSet bean : list ) { if ( bean . fieldName == null || bean . fieldName . isEmpty ( ) ) { return map ; } bean . fieldIni = bean . fieldIni == null ? "" : bean . fieldIni ; if ( bean . fieldIni . startsWith ( "$" ) ) { if ( Actuacio . resourceMap != null && Actuacio . resourceMap . containsKey ( bean . fieldIni ) ) { Object obj = Actuacio . resourceMap . get ( bean . fieldIni ) ; if ( obj . getClass ( ) . equals ( String . class ) ) { bean . fieldIni = ( String ) obj ; } } else { bean . fieldIni = "" ; } } map . put ( bean . fieldName , bean . fieldIni ) ; } return map ; }
tr	2	protected void initBuffer ( ) throws IOException { if ( buf != null ) { Util . disposeDirectByteBuffer ( buf ) ; } int size = bufferNumLength << Main . log2DataLength ; assert ( size > 0 ) ; if ( Main . debug ) { System . out . println ( "Allocating direct buffer of " + bufferNumLength + " ints." ) ; } buf = ByteBuffer . allocateDirect ( size ) . order ( Main . byteOrder ) ; buf . clear ( ) ; }
tr	3	public Dimension getRenderedDimension ( Image image , int canvasWidth , int canvasHeight ) { int imageWidth = image . getWidth ( null ) ; int imageHeight = image . getHeight ( null ) ; if ( ! flickrFrame . isFullscreen ( ) ) { canvasWidth -= BORDER_SIZE * 2 ; canvasHeight -= BORDER_SIZE * 2 ; } float imageRatio = ( float ) imageWidth / ( float ) imageHeight ; float thisRatio = ( float ) canvasWidth / ( float ) canvasHeight ; int renderedWidth , renderedHeight ; if ( imageRatio > thisRatio ) { renderedWidth = canvasWidth ; renderedHeight = ( int ) ( canvasWidth / imageRatio ) ; } else if ( imageRatio < thisRatio ) { renderedHeight = canvasHeight ; renderedWidth = ( int ) ( canvasHeight * imageRatio ) ; } else { renderedWidth = canvasWidth ; renderedHeight = canvasHeight ; } return new Dimension ( renderedWidth , renderedHeight ) ; }
tr	1	private static void pagarPlan ( int numero ) { PlanCelular pc = buscar ( numero ) ; if ( pc != null ) { System . out . println ( "cant min: " ) ; int cms = lea . nextInt ( ) ; System . out . println ( "Cant msgs: " ) ; int cmgs = lea . nextInt ( ) ; double monto = pc . pagoMensual ( cms , cmgs ) ; System . out . println ( "Total: " + monto ) ; } }
tr	9	public static void main ( String [ ] args ) throws IOException , ClassNotFoundException , ParseException { Properties properties = new Properties ( ) ; properties . load ( Client . class . getClassLoader ( ) . getResourceAsStream ( "client.properties" ) ) ; Integer serverPort = Integer . valueOf ( properties . getProperty ( "client.server_port" , "1234" ) ) ; String serverAddress = properties . getProperty ( "client.server_address" , "localhost" ) ; ObjectOutputStream toServer = null ; ObjectInputStream fromServer = null ; Socket connectionSocket = null ; try { connectionSocket = new Socket ( serverAddress , serverPort ) ; Scanner scanner = new Scanner ( System . in ) ; toServer = new ObjectOutputStream ( connectionSocket . getOutputStream ( ) ) ; fromServer = new ObjectInputStream ( connectionSocket . getInputStream ( ) ) ; log . info ( "Connection created!" ) ; while ( ! start ( toServer , fromServer , scanner ) ) ; while ( homePage ( toServer , fromServer , scanner ) ) ; } catch ( IOException e ) { log . error ( "Can't connect to server." , e ) ; } catch ( NoSuchElementException e ) { log . error ( "User terminated session" , e ) ; } finally { if ( toServer != null ) { try { toServer . close ( ) ; } catch ( IOException e ) { log . error ( "To server stream closing error" , e ) ; } } if ( fromServer != null ) { try { fromServer . close ( ) ; } catch ( IOException e ) { log . error ( "From server stream closing error" , e ) ; } } if ( connectionSocket != null ) { try { connectionSocket . close ( ) ; } catch ( IOException e ) { log . error ( "Connection socket closing error" , e ) ; } } } }
tr	6	public void Solve ( ) { int count = 0 ; for ( int x1 = 0 ; x1 <= _max ; x1 ++ ) { for ( int y1 = 0 ; y1 <= _max ; y1 ++ ) { for ( int x2 = 0 ; x2 <= _max ; x2 ++ ) { for ( int y2 = 0 ; y2 <= _max ; y2 ++ ) { if ( x1 + y1 + x2 + y2 == 0 ) { continue ; } int length1 = x1 * x1 + y1 * y1 ; int length2 = x2 * x2 + y2 * y2 ; int x3 = Math . abs ( x1 - x2 ) ; int y3 = Math . abs ( y1 - y2 ) ; int length3 = x3 * x3 + y3 * y3 ; if ( length1 + length2 == length3 ) { count ++ ; } } } } } System . out . println ( "Result=" + count / 2 ) ; }
tr	2	public static void writeAttack ( Pokemon poke , int moveChoice , int damage , int teamId ) { if ( ! isSearchMode ) { String statement = "%s" ; if ( teamId == Game . OMNIDEXTER ) { statement = String . format ( statement , "OmniDexter's" ) ; } else { statement = String . format ( statement , "Opponent" ) ; } statement = statement . concat ( " %s uses %s  dealing %d damage!" ) ; String moveName = poke . getMove ( moveChoice ) . getMove ( ) . getName ( ) ; statement = String . format ( statement , poke , moveName , damage ) ; System . out . println ( statement ) ; } }
tr	4	public Main ( ) { lf = new LinkFilter ( ) ; knnc = new KNNControl ( lf ) ; knnc . setVisible ( true ) ; Datasource loggin = new Datasource ( lf , null ) ; int [ ] motes = { 1 , 2 , 3 , 4 , 5 , 6 , 7 } ; for ( int i : motes ) { for ( int j = 0 ; j < 10 ; j ++ ) { loggin . sendConfig ( i , 50 , 31 ) ; } for ( int j : motes ) { if ( i != j ) { addLink ( i , j ) ; } } } }
tr	9	public boolean isPalindrome ( String s ) { if ( s == null ) return false ; if ( s . equals ( "" ) ) return true ; String sLow = s . toLowerCase ( ) ; char [ ] S = sLow . toCharArray ( ) ; int left = 0 , right = s . length ( ) - 1 ; while ( left < right ) { while ( ( S [ left ] < 0 || S [ left ] > 9 ) && ( S [ left ] < a || S [ left ] > z ) && ( left < right ) ) { left ++ ; } while ( ( S [ right ] < 0 || S [ right ] > 9 ) && ( S [ right ] < a || S [ right ] > z ) && ( left < right ) ) { right -- ; } if ( S [ left ++ ] != S [ right -- ] ) return false ; } return true ; }
tr	5	public static List < Employee > load ( InputStream input ) { List < Employee > employees = new ArrayList < Employee > ( ) ; BufferedReader reader = null ; try { reader = new BufferedReader ( new InputStreamReader ( input ) ) ; while ( true ) { String line = reader . readLine ( ) ; if ( line == null ) break ; String [ ] values = line . split ( " " ) ; Employee employee = new Employee ( values [ 0 ] , values [ 1 ] , values [ 2 ] ) ; employees . add ( employee ) ; } return employees ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } finally { if ( reader != null ) { try { reader . close ( ) ; } catch ( IOException e ) { } } } }
tr	1	public static void writeStringToFile ( String content , String filename , boolean append ) { FileWriter fw ; try { fw = new FileWriter ( filename , append ) ; fw . append ( content ) ; fw . flush ( ) ; fw . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }
tr	0	@ Override public void close ( ) throws IOException { in . close ( ) ; }
tr	2	public int getFrameIndexOfTag ( String tag ) { AnimationFrame frame ; for ( int i = 0 ; i < animationFrames . size ( ) ; i ++ ) { frame = animationFrames . get ( i ) ; if ( frame . getTag ( ) . equals ( tag ) ) return i ; } return - 1 ; }
tr	0	public void setMean ( double mean ) { this . mean = mean ; }
tr	2	protected void updateInitCells ( ) { int i ; CellElement tmpCell ; for ( i = 1 ; i < m_s1_size ; ++ i ) { tmpCell = m_dpTable . getCell ( i , i + 1 ) ; tmpCell . setIntVal ( 0 ) ; } for ( i = 0 ; i < m_s1_size ; ++ i ) { tmpCell = m_dpTable . getCell ( i + 1 , i + 1 ) ; tmpCell . setIntVal ( 0 ) ; } }
tr	5	public static CachedFileSystemView getFileSystemView ( ) { if ( File . separatorChar == \ ) { if ( windowsFileSystemView == null ) { windowsFileSystemView = new WindowsCachedFileSystemView ( ) ; } return windowsFileSystemView ; } if ( File . separatorChar == / ) { if ( unixFileSystemView == null ) { unixFileSystemView = new UnixCachedFileSystemView ( ) ; } return unixFileSystemView ; } if ( genericFileSystemView == null ) { genericFileSystemView = new GenericCachedFileSystemView ( ) ; } return genericFileSystemView ; }
tr	1	public TouristDetector ( Listener listener , MetricsDetector . Metrics ... metricses ) { detectors = new MetricsDetector [ metricses . length ] ; for ( int i = 0 ; i < metricses . length ; i ++ ) { detectors [ i ] = new MetricsDetector ( this , metricses [ i ] ) ; } this . listener = listener ; this . tourists = new HashSet < String > ( ) ; this . workers = new HashSet < String > ( ) ; }
tr	2	public Signals ( int x , int y , int h , String data [ ] ) { this . x = x ; this . y = y ; fontHeight = ( h - 2 ) * 2 / 3 ; newFontHeight = fontHeight ; if ( data != null ) for ( int n = 0 ; n < data . length ; n ++ ) addSignal ( data [ n ] ) ; }
tr	4	public Command matchNextSub ( String nextCommand ) { ArrayList < Integer > matchesFound = new ArrayList < Integer > ( ) ; if ( ! isTerminating ) { for ( int i = 0 ; i < nextCommands . size ( ) ; i ++ ) { if ( nextCommands . get ( i ) . getText ( ) . contains ( nextCommand ) ) { matchesFound . add ( i ) ; } } if ( matchesFound . size ( ) < 1 ) { return nextCommands . get ( matchesFound . get ( 0 ) ) ; } } return null ; }
tr	4	@ Override public void run ( ) { try { while ( active ) { synchronized ( messages ) { if ( messages . isEmpty ( ) ) { messages . wait ( 200 ) ; } else { NetworkMessage nm = messages . remove ( 0 ) ; out . write ( nm . getData ( ) ) ; } } } } catch ( InterruptedException ex ) { System . err . println ( ex . getMessage ( ) ) ; } catch ( IOException ex ) { System . err . println ( ex . getMessage ( ) ) ; } }
tr	6	public char next ( ) throws JSONException { int c ; if ( this . usePrevious ) { this . usePrevious = false ; c = this . previous ; } else { try { c = this . reader . read ( ) ; } catch ( IOException exception ) { throw new JSONException ( exception ) ; } if ( c <= 0 ) { this . eof = true ; c = 0 ; } } this . index += 1 ; if ( this . previous == '' ) { this . line += 1 ; this . character = c == '' ? 0 : 1 ; } else if ( c == '' ) { this . line += 1 ; this . character = 0 ; } else { this . character += 1 ; } this . previous = ( char ) c ; return this . previous ; }
tr	0	public MenuRetornarPartida ( ) { super ( "Menu Partida" , new ArrayList < ItemMenu > ( ) { private static final long serialVersionUID = - 2202065529317389240 ; { add ( new ItemMenu ( "REINICIAR" , "Retorna uma partida" ) ) ; add ( new ItemMenu ( "APAGAR" , "Apagar uma partida" ) ) ; add ( new ItemMenu ( "RETORNAR" , "Retornar ao menu principal" ) ) ; } } ) ; }
tr	4	public Problem get ( final AlgorithmType type , final Puzzle puzzle ) { ColumnNode head = PuzzleConvertor . INSTANCE . convertToNetwork ( puzzle ) . head ( ) ; switch ( type ) { case NAIVE : return new NaiveDancingLinks ( head ) ; case BASIC : return new BasicDancingLinks ( head ) ; case MIN_COLUMN : return new MinColumnDancingLinks ( head ) ; case DEGREE : return new DegreeDancingLinks ( head ) ; default : throw new IllegalArgumentException ( "Algorithm type: " + type + " is unsupported." ) ; } }
tr	3	private String getDifficultyName ( ) { if ( numHints < ( boardSegs * boardSegs ) + boardSegs ) return "diablolical" ; if ( numHints < boardWidth * 2 ) return "tough" ; if ( numHints < boardWidth * boardSegs ) return "moderate" ; return "gentle" ; }
tr	0	@ Override public HandlerList getHandlers ( ) { return handlers ; }
tr	2	public void loadExtension ( class < ? > cls ) { try { enableExtension ( this . instantiateExtension ( cls ) ) ; } catch ( ExtensionException e ) { MinePing . staticlogger . log ( Level . SEVERE , "Failed to load Extension: " + e ) ; } }
tr	1	public GitlabBuildVariable updateBuildVariable ( Integer projectId , String key , String newValue ) throws IOException { String tailUrl = GitlabProject . URL + "/" + projectId + GitlabBuildVariable . URL + key ; GitlabHTTPRequestor requestor = retrieve ( ) . method ( "PUT" ) ; if ( newValue != null ) { requestor = requestor . with ( "value" , newValue ) ; } return requestor . to ( tailUrl , GitlabBuildVariable . class ) ; }
tr	2	@ Override public int compareTo ( RequestEvent requestEvent ) { if ( this . time < requestEvent . time ) return - 1 ; else if ( this . time > requestEvent . time ) return 1 ; else return 0 ; }
tr	4	protected static Date parseDate ( String str , String format ) throws WeiboException { if ( str == null || "" . equals ( str ) ) { return null ; } SimpleDateFormat sdf = formatMap . get ( format ) ; if ( null == sdf ) { sdf = new SimpleDateFormat ( format , Locale . ENGLISH ) ; sdf . setTimeZone ( TimeZone . getTimeZone ( "GMT" ) ) ; formatMap . put ( format , sdf ) ; } try { synchronized ( sdf ) { return sdf . parse ( str ) ; } } catch ( ParseException pe ) { throw new WeiboException ( "Unexpected format(" + str + ") returned from sina.com.cn" ) ; } }
