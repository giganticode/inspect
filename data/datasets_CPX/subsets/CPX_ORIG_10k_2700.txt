tr	2	@ Override public String toString ( ) { String str = "" ; if ( min > 0 ) str += min ; str += "*" ; if ( max > 0 ) str += max ; return str ; }
tr	3	static private final int jjMoveStringLiteralDfa14_0 ( long old0 , long active0 ) { if ( ( ( active0 &= old0 ) ) == 0 ) return jjStartNfa_0 ( 12 , old0 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 13 , active0 ) ; return 14 ; } switch ( curChar ) { case 79 : return jjMoveStringLiteralDfa15_0 ( active0 , 10 ) ; default : break ; } return jjStartNfa_0 ( 13 , active0 ) ; }
tr	0	public void clearBooster ( ) { getBooster ( ) . clear ( ) ; }
tr	7	public static int [ ] getAlleleCounts ( List < Accession > accessions ) { if ( accessions . size ( ) == 0 ) return null ; Accession a1 = accessions . get ( 0 ) ; int alleleCnt = a1 . numSSRAlleles ( ) ; int alleleTotals [ ] = new int [ alleleCnt ] ; for ( int i = 0 ; i < alleleCnt ; i ++ ) { alleleTotals [ i ] = 0 ; } for ( Accession a : accessions ) { ListIterator < List < double >> mItr = a . getSSRValues ( ) . listIterator ( ) ; ListIterator < double > aItr = null ; int i = 0 ; while ( mItr . hasNext ( ) ) { aItr = mItr . next ( ) . listIterator ( ) ; while ( aItr . hasNext ( ) ) { double val = aItr . next ( ) ; if ( val != null ) { double v = val . doubleValue ( ) ; if ( v > 0 ) { alleleTotals [ i ] += 1 ; } } i ++ ; } } } return alleleTotals ; }
tr	0	public String getQQ ( ) { return qq ; }
tr	2	public void resetUnits ( ) { for ( Unit u : blueUnits ) { u . reset ( ) ; } for ( Unit u : redUnits ) { u . reset ( ) ; } }
tr	5	private static Collection < Layer > parseLayerArgument ( Model model , String layersarg ) { Collection < Layer > lays ; if ( layersarg . equalsIgnoreCase ( "all" ) ) { lays = model . getLayer ( ) ; } else { String [ ] layersarg1 = layersarg . split ( " " ) ; lays = new ArrayList < Layer > ( ) ; for ( Layer lay1 : model . getLayer ( ) ) { for ( String lan : layersarg1 ) { if ( lan . equals ( String . valueOf ( lay1 . getNumber ( ) ) ) ) { lays . add ( lay1 ) ; } } } } if ( lays . isEmpty ( ) ) { System . err . println ( "No matching layers found." ) ; System . exit ( 1 ) ; } return lays ; }
tr	5	public void resetBoard ( ) { for ( int i = 0 ; i < 8 ; i ++ ) { for ( int j = 0 ; j < 8 ; j ++ ) { m_Pieces [ i ] [ j ] = NONE_PIECE ; } } m_Pieces [ 3 ] [ 3 ] = WHITE_PIECE ; m_Pieces [ 4 ] [ 4 ] = WHITE_PIECE ; m_Pieces [ 3 ] [ 4 ] = BLACK_PIECE ; m_Pieces [ 4 ] [ 3 ] = BLACK_PIECE ; for ( int x = 0 ; x < WIDTH ; x ++ ) { for ( int y = 0 ; y < HEIGHT ; y ++ ) { if ( m_Pieces [ x ] [ y ] == null ) { m_Pieces [ x ] [ y ] = NONE_PIECE ; } } } }
tr	4	public void drawComponents ( BufferedImage canvas , boolean drawCorner ) { if ( _components == null ) findComponents ( ) ; BufferedImage image = new BufferedImage ( _width , _height , BufferedImage . TYPE_INT_RGB ) ; for ( int x = 0 ; x < _width ; x ++ ) for ( int y = 0 ; y < _height ; y ++ ) image . setRGB ( x , y , ffffff ) ; for ( ConnectedComponent cc : _components ) cc . draw ( image , true , drawCorner ) ; canvas . createGraphics ( ) . drawImage ( image , 0 , 0 , null ) ; }
tr	3	public void newDocument ( ) { try { final DocumentFrame doc = new DocumentFrame ( loadOrganizer , null ) ; loadOrganizer . openDocuments . add ( doc ) ; doc . addInternalFrameListener ( new InternalFrameAdapter ( ) { @ Override public void internalFrameClosed ( InternalFrameEvent e ) { loadOrganizer . openDocuments . remove ( doc ) ; } } ) ; loadOrganizer . desktop . add ( doc , LoadOrganizer . DOCLAYER ) ; if ( preferences . isGuiNewWindowMaximize ( ) ) { doc . setMaximum ( true ) ; } doc . setVisible ( true ) ; doc . setSelected ( true ) ; } catch ( DocumentClosedException e ) { } catch ( Throwable e ) { e . printStackTrace ( ) ; System . exit ( - 1 ) ; } }
tr	9	public void startgetShortUrl ( src . com . tinyurl . TinyUrlWebServiceStub . GetShortUrl getShortUrl2 , final src . com . tinyurl . TinyUrlWebServiceCallbackHandler callback ) throws java . rmi . RemoteException { org . apache . axis2 . client . OperationClient _operationClient = _serviceClient . createClient ( _operations [ 1 ] . getName ( ) ) ; _operationClient . getOptions ( ) . setAction ( "urn:getShortUrl" ) ; _operationClient . getOptions ( ) . setExceptionToBeThrownOnSOAPFault ( true ) ; addPropertyToOperationClient ( _operationClient , org . apache . axis2 . description . WSDL2Constants . ATTR_WHTTP_QUERY_PARAMETER_SEPARATOR , "&" ) ; org . apache . axiom . soap . SOAPEnvelope env = null ; final org . apache . axis2 . context . MessageContext _messageContext = new org . apache . axis2 . context . MessageContext ( ) ; env = toEnvelope ( getFactory ( _operationClient . getOptions ( ) . getSoapVersionURI ( ) ) , getShortUrl2 , optimizeContent ( new javax . xml . namespace . QName ( "http://tinyurl.com.src" , "getShortUrl" ) ) , new javax . xml . namespace . QName ( "http://tinyurl.com.src" , "getShortUrl" ) ) ; _serviceClient . addHeadersToEnvelope ( env ) ; _messageContext . setEnvelope ( env ) ; _operationClient . addMessageContext ( _messageContext ) ; _operationClient . setCallback ( new org . apache . axis2 . client . async . AxisCallback ( ) { public void onMessage ( org . apache . axis2 . context . MessageContext resultContext ) { try { org . apache . axiom . soap . SOAPEnvelope resultEnv = resultContext . getEnvelope ( ) ; java . lang . Object object = fromOM ( resultEnv . getBody ( ) . getFirstElement ( ) , src . com . tinyurl . TinyUrlWebServiceStub . GetShortUrlResponse . class , getEnvelopeNamespaces ( resultEnv ) ) ; callback . receiveResultgetShortUrl ( ( src . com . tinyurl . TinyUrlWebServiceStub . GetShortUrlResponse ) object ) ; } catch ( org . apache . axis2 . AxisFault e ) { callback . receiveErrorgetShortUrl ( e ) ; } } public void onError ( java . lang . Exception error ) { if ( error instanceof org . apache . axis2 . AxisFault ) { org . apache . axis2 . AxisFault f = ( org . apache . axis2 . AxisFault ) error ; org . apache . axiom . om . OMElement faultElt = f . getDetail ( ) ; if ( faultElt != null ) { if ( faultExceptionNameMap . containsKey ( new org . apache . axis2 . client . FaultMapKey ( faultElt . getQName ( ) , "getShortUrl" ) ) ) { try { java . lang . String exceptionClassName = ( java . lang . String ) faultExceptionClassNameMap . get ( new org . apache . axis2 . client . FaultMapKey ( faultElt . getQName ( ) , "getShortUrl" ) ) ; java . lang . class exceptionClass = java . lang . class . forName ( exceptionClassName ) ; java . lang . reflect . Constructor constructor = exceptionClass . getConstructor ( String . class ) ; java . lang . Exception ex = ( java . lang . Exception ) constructor . newInstance ( f . getMessage ( ) ) ; java . lang . String messageClassName = ( java . lang . String ) faultMessageMap . get ( new org . apache . axis2 . client . FaultMapKey ( faultElt . getQName ( ) , "getShortUrl" ) ) ; java . lang . class messageClass = java . lang . class . forName ( messageClassName ) ; java . lang . Object messageObject = fromOM ( faultElt , messageClass , null ) ; java . lang . reflect . Method m = exceptionClass . getMethod ( "setFaultMessage" , new java . lang . class [ ] { messageClass } ) ; m . invoke ( ex , new java . lang . Object [ ] { messageObject } ) ; callback . receiveErrorgetShortUrl ( new java . rmi . RemoteException ( ex . getMessage ( ) , ex ) ) ; } catch ( java . lang . ClassCastException e ) { callback . receiveErrorgetShortUrl ( f ) ; } catch ( java . lang . ClassNotFoundException e ) { callback . receiveErrorgetShortUrl ( f ) ; } catch ( java . lang . NoSuchMethodException e ) { callback . receiveErrorgetShortUrl ( f ) ; } catch ( java . lang . reflect . InvocationTargetException e ) { callback . receiveErrorgetShortUrl ( f ) ; } catch ( java . lang . IllegalAccessException e ) { callback . receiveErrorgetShortUrl ( f ) ; } catch ( java . lang . InstantiationException e ) { callback . receiveErrorgetShortUrl ( f ) ; } catch ( org . apache . axis2 . AxisFault e ) { callback . receiveErrorgetShortUrl ( f ) ; } } else { callback . receiveErrorgetShortUrl ( f ) ; } } else { callback . receiveErrorgetShortUrl ( f ) ; } } else { callback . receiveErrorgetShortUrl ( error ) ; } } public void onFault ( org . apache . axis2 . context . MessageContext faultContext ) { org . apache . axis2 . AxisFault fault = org . apache . axis2 . util . Utils . getInboundFaultFromMessageContext ( faultContext ) ; onError ( fault ) ; } public void onComplete ( ) { try { _messageContext . getTransportOut ( ) . getSender ( ) . cleanup ( _messageContext ) ; } catch ( org . apache . axis2 . AxisFault axisFault ) { callback . receiveErrorgetShortUrl ( axisFault ) ; } } } ) ; org . apache . axis2 . util . CallbackReceiver _callbackReceiver = null ; if ( _operations [ 1 ] . getMessageReceiver ( ) == null && _operationClient . getOptions ( ) . isUseSeparateListener ( ) ) { _callbackReceiver = new org . apache . axis2 . util . CallbackReceiver ( ) ; _operations [ 1 ] . setMessageReceiver ( _callbackReceiver ) ; } _operationClient . execute ( false ) ; }
tr	4	private Tag readTag ( ) { Tag retval = null ; String token = null ; try { readTo ( OPEN ) ; } catch ( final Exception e ) { return null ; } try { token = readTo ( CLOSE ) ; if ( token != null ) { token = token . trim ( ) ; if ( token . length ( ) > 0 ) { retval = new Tag ( token ) ; } } } catch ( final IOException e ) { throw error ( "Could not read a complete tag: IO error" ) ; } return retval ; }
tr	6	public void cut ( SimpleFrame panelText ) { panelText . setAction ( false ) ; int cp ; if ( panelText . getText ( ) . getSelectedText ( ) != null ) { copy ( panelText ) ; cp = panelText . getText ( ) . getSelectionStart ( ) ; try { String text = panelText . getText ( ) . getSelectedText ( ) ; int position = panelText . getText ( ) . getSelectionStart ( ) ; ActionsHistoryImpl . action type = ActionsHistoryImpl . action . - ; ActionData data = new ActionData ( panelText . getText ( ) . getCaretPosition ( ) , panelText . getText ( ) . getText ( ) , false ) ; String login = panelText . getLogin ( ) ; data = panelText . getList ( ) . newPutString ( text , position , type , data , login ) ; panelText . getText ( ) . setText ( data . getPanelText ( ) ) ; panelText . getText ( ) . setCaretPosition ( data . getCaretPosition ( ) ) ; panelText . setIsChanged ( data . getChanged ( ) ) ; } catch ( RemoteException e ) { JOptionPane . showMessageDialog ( panelText , "Disconnect from server" ) ; } if ( panelText . getText ( ) . getSelectionStart ( ) == 0 ) { int begin = panelText . getText ( ) . getSelectedText ( ) . length ( ) ; int finish = panelText . getText ( ) . getText ( ) . length ( ) ; String text = panelText . getText ( ) . getText ( ) . substring ( begin , finish ) ; panelText . getText ( ) . setText ( text ) ; panelText . getText ( ) . setCaretPosition ( cp ) ; return ; } if ( panelText . getText ( ) . getSelectionStart ( ) > 0 && panelText . getText ( ) . getSelectionStart ( ) < panelText . getText ( ) . getText ( ) . length ( ) ) { int begin1 = 0 ; int finish1 = panelText . getText ( ) . getSelectionStart ( ) ; String text1 = panelText . getText ( ) . getText ( ) . substring ( begin1 , finish1 ) ; int begin2 = panelText . getText ( ) . getSelectionStart ( ) + panelText . getText ( ) . getSelectedText ( ) . length ( ) ; int finish2 = panelText . getText ( ) . getText ( ) . length ( ) ; String text2 = panelText . getText ( ) . getText ( ) . substring ( begin2 , finish2 ) ; panelText . getText ( ) . setText ( text1 + text2 ) ; panelText . getText ( ) . setCaretPosition ( cp ) ; return ; } if ( panelText . getText ( ) . getSelectionStart ( ) == panelText . getText ( ) . getText ( ) . length ( ) ) { int begin = 0 ; int finish = panelText . getText ( ) . getSelectionStart ( ) ; String text = panelText . getText ( ) . getText ( ) . substring ( begin , finish ) ; panelText . getText ( ) . setText ( text ) ; panelText . getText ( ) . setCaretPosition ( cp ) ; return ; } } panelText . setAction ( true ) ; }
tr	1	private void printAUCPoints ( TreeSet < XYPair > xyData ) { PrintToFile pf = new PrintToFile ( ) ; pf . openFile ( Classify . dataPath + "results" + Classify . / + "auc" + Classify . / + "" + Classify . intToCat . get ( Classify . category ) + Classify . / + "" + Classify . fileName + "_aucPoints.csv" ) ; xyData . add ( new XYPair ( 0 , 0 ) ) ; xyData . add ( new XYPair ( 1 , 1 ) ) ; for ( XYPair pair : xyData ) pf . writeToFile ( pair . getX ( ) + " " + pair . getY ( ) ) ; pf . closeFile ( ) ; }
tr	8	public void checkFiles ( ) { List < LeafNode > leaves = getLeaves ( ) ; if ( leaves != null ) { ListIterator < LeafNode > it = leaves . listIterator ( ) ; while ( it . hasNext ( ) ) { LeafNode node = it . next ( ) ; String filePath = UserPreferences . PREF_DOWNLOAD_TARGET ; String dirs = node . getPathDir ( ) . getDirs ( ) ; if ( dirs != null ) filePath += File . separator + dirs ; filePath += File . separator + node . getItem ( ) . getName ( ) ; File f = new File ( filePath ) ; if ( f . exists ( ) && f . length ( ) == node . getItem ( ) . getSize ( ) ) { node . setDownPerc ( 1.0f ) ; node . setStatus ( "Completed" ) ; continue ; } int i = 0 ; long dlSize = 0 ; while ( true ) { File fPart = new File ( filePath + ".pio" + i ) ; if ( ! fPart . exists ( ) ) break ; else dlSize += fPart . length ( ) ; i ++ ; } if ( i > 0 ) { node . setDownPerc ( ( float ) dlSize / ( float ) node . getItem ( ) . getSize ( ) ) ; node . setStatus ( GuiOperations . getReadableSize ( dlSize ) + " / " + GuiOperations . getReadableSize ( node . getItem ( ) . getSize ( ) ) ) ; } } } repaint ( ) ; }
tr	6	public void doService ( ) { Message message = parser . nextMessage ( ) ; while ( message != null ) { switch ( message . getType ( ) ) { case CONNECT : writer . println ( "ALREADY CONNECTED!" ) ; writer . flush ( ) ; break ; case DISCONNECT : server . broadcaster . remove ( connection ) ; break ; case TEXTMSG_CLIENT : broadcastMessage ( message ) ; break ; case IMAGE_CLIENT : server . setImage ( ImageUtils . decodeImage ( message . getMatcher ( ) . group ( 1 ) ) ) ; broadcastMessage ( message ) ; break ; default : AbstractTool tool = AbstractTool . getTool ( message . getType ( ) ) ; if ( tool != null ) { server . updateImage ( tool , message ) ; broadcastMessage ( message ) ; } break ; } message = parser . nextMessage ( ) ; } }
tr	4	public void execute ( ) { alive = true ; while ( alive ) { try { gameManager . update ( ) ; if ( gameManager . isSwitchGame ( ) ) { final SharedGameData gameData = SharedGameData . getInstance ( ) ; gameData . levelUp ( ) ; gameManager = GameManagerFactory . getNextGame ( ) ; gameManager . init ( ) ; gameManager . setSwitchGame ( false ) ; gameManager . changeGameState ( GameState . INITIALIZING ) ; } if ( changedGame != null ) { changedGame . init ( ) ; gameManager = changedGame ; changedGame = null ; } } catch ( final Exception e ) { e . printStackTrace ( ) ; } } }
tr	7	@ Override public JsonElement serialize ( Criteria criteria , Type type , JsonSerializationContext jsc ) { JsonObject json = new JsonObject ( ) ; json . addProperty ( "field" , criteria . getField ( ) . ordinal ( ) + 1 ) ; try { String operator = criteria . getOperator ( ) . toString ( ) ; if ( operator . equals ( Operators . StartWith . toString ( ) ) ) operator = "START%20WITH" ; else if ( operator . equals ( Operators . Equals . toString ( ) ) ) operator = URLEncoder . encode ( "=" , "UTF-8" ) ; else if ( operator . equals ( Operators . GreaterThan . toString ( ) ) ) operator = URLEncoder . encode ( ">" , "UTF-8" ) ; else if ( operator . equals ( Operators . GreaterThanEqual . toString ( ) ) ) operator = URLEncoder . encode ( ">=" , "UTF-8" ) ; else if ( operator . equals ( Operators . LessThan . toString ( ) ) ) operator = URLEncoder . encode ( "<" , "UTF-8" ) ; else if ( operator . equals ( Operators . LessThanEqual . toString ( ) ) ) operator = URLEncoder . encode ( "<=" , "UTF-8" ) ; json . addProperty ( "operator" , operator ) ; } catch ( UnsupportedEncodingException ex ) { Logger . getLogger ( CriteriaSerializer . class . getName ( ) ) . log ( Level . SEVERE , "Wrong encoding scheme!" , ex ) ; } json . addProperty ( "value" , criteria . getValue ( ) ) ; return json ; }
tr	4	private static File checkDirectory ( String dir ) { final File file = dir == null ? null : new File ( dir ) ; if ( file != null && ( ! file . isDirectory ( ) || ! file . canWrite ( ) ) ) { throw new RuntimeException ( String . format ( "%s is not a writeable directory." , file . getAbsolutePath ( ) ) ) ; } return file ; }
tr	9	public static DatabaseType insertCompany ( JFrame frame ) { JPanel panel = new JPanel ( new BorderLayout ( 5 , 5 ) ) ; JPanel label = new JPanel ( new GridLayout ( 5 , 1 , 2 , 2 ) ) ; label . add ( new JLabel ( "Company market code" , SwingConstants . RIGHT ) ) ; label . add ( new JLabel ( "Brand Name" , SwingConstants . RIGHT ) ) ; label . add ( new JLabel ( "Rating" , SwingConstants . RIGHT ) ) ; label . add ( new JLabel ( "Capital (in B)" , SwingConstants . RIGHT ) ) ; label . add ( new JLabel ( "Currency" , SwingConstants . RIGHT ) ) ; panel . add ( label , BorderLayout . WEST ) ; JPanel controls = new JPanel ( new GridLayout ( 5 , 1 , 2 , 2 ) ) ; JTextField market_codeF = new JTextField ( ) ; market_codeF . setToolTipText ( "Type the market code of the company or bank. Like RT.b" ) ; TextPrompt market_codeP = new TextPrompt ( "RBS.L" , market_codeF ) ; market_codeP . setForeground ( Color . RED ) ; market_codeP . changeAlpha ( 0.5f ) ; market_codeP . changeStyle ( Font . BOLD + Font . ITALIC ) ; controls . add ( market_codeF ) ; JTextField brand_nameF = new JTextField ( ) ; brand_nameF . setToolTipText ( "Insert the brand name of the company." ) ; TextPrompt brand_nameP = new TextPrompt ( "Lloyd LTD" , brand_nameF ) ; brand_nameP . setForeground ( Color . RED ) ; brand_nameP . changeAlpha ( 0.5f ) ; brand_nameP . changeStyle ( Font . BOLD + Font . ITALIC ) ; controls . add ( brand_nameF ) ; JTextField ratingF = new JTextField ( ) ; ratingF . setToolTipText ( "Insert the rating for the Company  which should be an integer between 0 and 10" ) ; TextPrompt ratingP = new TextPrompt ( "7" , ratingF ) ; ratingP . setForeground ( Color . RED ) ; ratingP . changeAlpha ( 0.5f ) ; ratingP . changeStyle ( Font . BOLD + Font . ITALIC ) ; controls . add ( ratingF ) ; JTextField capitalF = new JTextField ( ) ; capitalF . setToolTipText ( "Insert the capital of the company  as a floating point number in  B." ) ; TextPrompt capitalP = new TextPrompt ( "54.56" , capitalF ) ; capitalP . setForeground ( Color . RED ) ; capitalP . changeAlpha ( 0.5f ) ; capitalP . changeStyle ( Font . BOLD + Font . ITALIC ) ; controls . add ( capitalF ) ; JTextField currencyF = new JTextField ( ) ; currencyF . setToolTipText ( "Type the currency of the state you live in." ) ; TextPrompt currencyP = new TextPrompt ( "EUR" , currencyF ) ; currencyP . setForeground ( Color . RED ) ; currencyP . changeAlpha ( 0.5f ) ; currencyP . changeStyle ( Font . BOLD + Font . ITALIC ) ; controls . add ( currencyF ) ; controls . setPreferredSize ( new Dimension ( 300 , 180 ) ) ; panel . add ( controls , BorderLayout . CENTER ) ; while ( JOptionPane . showConfirmDialog ( frame , panel , "Add" , JOptionPane . OK_CANCEL_OPTION ) == 0 ) { String market_code = market_codeF . getText ( ) . toUpperCase ( ) ; String brand = brand_nameF . getText ( ) . toUpperCase ( ) ; String rating = ratingF . getText ( ) . toUpperCase ( ) ; String capital = capitalF . getText ( ) ; String currency = currencyF . getText ( ) . toUpperCase ( ) ; boolean validData = true ; try { int i = Integer . parseInt ( rating ) ; if ( i < 0 || i > 10 ) throw new Exception ( ) ; } catch ( Exception e ) { validData = false ; JOptionPane . showMessageDialog ( frame , "Rating should be integer between 0 and 10!" ) ; } try { double . parseDouble ( capital ) ; } catch ( Exception e ) { validData = false ; JOptionPane . showMessageDialog ( frame , "Balance must be floating point number!" ) ; } if ( market_code . length ( ) > 10 || ! market_code . matches ( "[A-z]+|[A-z]+.[A-z]+" ) ) { JOptionPane . showMessageDialog ( frame , "Market code maximum allowed 10 alphabetical characters + the dot (.) sign!" ) ; validData = false ; } if ( currency . length ( ) > 3 || ! currency . matches ( "[A-z]+" ) ) { JOptionPane . showMessageDialog ( frame , "Currency should be 3 char max. and only literals  such as EUR or GBP!" ) ; validData = false ; } if ( validData ) { return new Company ( market_code , brand , Integer . parseInt ( rating ) , double . parseDouble ( capital ) , currency ) ; } } return null ; }
tr	1	public static void notGreaterThanCheck ( final int a , final int upperBound ) { if ( a > upperBound ) throw new IllegalArgumentException ( "Input argument " + a + " should not be greater than " + upperBound ) ; }
tr	2	@ Override public void actionPerformed ( ActionEvent e ) { if ( e . getActionCommand ( ) . equals ( "Apply" ) ) { this . dispose ( ) ; System . out . println ( "aaaa" ) ; Tuple < String , Tuple < String , Integer >> player1Data = player1 . getPlayerData ( ) ; Tuple < String , Tuple < String , Integer >> player2Data = player2 . getPlayerData ( ) ; int deadFields = this . deadFields . getDeadFieldNumber ( ) ; System . out . println ( deadFields ) ; System . out . println ( "bbb" ) ; Player [ ] players = { new Player ( player1Data . getFirstElement ( ) , player1Data . getSecondElement ( ) . getFirstElement ( ) , "w" , player1Data . getSecondElement ( ) . getSecondElement ( ) ) , new Player ( player2Data . getFirstElement ( ) , player2Data . getSecondElement ( ) . getFirstElement ( ) , "b" , player2Data . getSecondElement ( ) . getSecondElement ( ) ) , } ; System . out . println ( "ccc" ) ; try { masterGui . newGame ( players , deadFields ) ; } catch ( Exception e1 ) { e1 . printStackTrace ( ) ; } System . out . println ( "ddd" ) ; } }
tr	1	public JSONObject optJSONObject ( int index ) { Object o = this . opt ( index ) ; return o instanceof JSONObject ? ( JSONObject ) o : null ; }
tr	7	public static _Fields findByThriftId ( int fieldId ) { switch ( fieldId ) { case 1 : return HEAD_ITEM ; case 2 : return ITEMS ; case 3 : return BYTES ; case 4 : return JOURNAL_BYTES ; case 5 : return AGE ; case 6 : return WAITERS ; case 7 : return OPEN_TRANSACTIONS ; default : return null ; } }
tr	6	public Object tostring ( Object value ) { if ( value == null ) return "nil" ; if ( value instanceof String ) return ( String ) value ; if ( value instanceof boolean || value instanceof double ) return value . toString ( ) ; if ( isCallable ( value ) ) return "function: " + System . identityHashCode ( value ) ; Object meta = getMetaValue ( value , "__tostring" ) ; if ( meta != null ) return call ( meta , value ) ; return value . toString ( ) ; }
tr	0	@ Test ( timeout = TIMEOUT ) public void test_size_after_adding_unique_nums ( ) { int [ ] testArray = { 0 , 1 , 2 , 3 , 4 } ; addAndTestSize ( "Added " + Arrays . toString ( testArray ) , testArray , 5 ) ; }
tr	1	@ Override public String getMessage ( ) { String msg = super . getMessage ( ) ; for ( String name : badValues . keySet ( ) ) { msg += "\n\t" + name + " = " + badValues . get ( name ) ; } return msg ; }
tr	9	public static void main ( String [ ] args ) { Utility . configure ( ) ; jobTrackerComm = new Communication ( Utility . JOBTRACKER . ipAddress , Utility . JOBTRACKER . port ) ; System . out . println ( "Registering on job tracker..." ) ; Message msg = new Message ( Utility . TASKTRACKERREG ) ; jobTrackerComm . sendMessage ( msg ) ; msg = jobTrackerComm . readMessage ( ) ; if ( msg . getMsgType ( ) == Utility . REGACK ) { taskTrackerID = msg . getTaskTrackerID ( ) ; System . out . println ( "Successfully registered." ) ; } while ( isRunning ) { msg = jobTrackerComm . readMessage ( ) ; if ( msg . getMsgType ( ) == Utility . NEWJOB ) { JobContext jobContext = msg . getJobContext ( ) ; String jobID = jobContext . getJobID ( ) . getID ( ) ; System . out . println ( "Receiced new job from job[" + jobID + "] tracker" ) ; if ( ! jobContexts . containsKey ( jobID ) ) { jobContexts . put ( jobID , jobContext ) ; } msg = new Message ( Utility . NEWJOBACK ) ; jobTrackerComm . sendMessage ( msg ) ; } else if ( msg . getMsgType ( ) == Utility . RUNMAPPER ) { System . out . println ( "Received RUNMAPPER command from job tracker." ) ; List < MapBasicContext > mapBasicContexts = msg . getMapContexts ( ) ; if ( mapBasicContexts . size ( ) != 0 ) { String jobID = mapBasicContexts . get ( 0 ) . getJobID ( ) . getID ( ) ; JobContext jobContext = jobContexts . get ( jobID ) ; numMappers = mapBasicContexts . size ( ) ; launchMappers ( jobContext , mapBasicContexts ) ; } } else if ( msg . getMsgType ( ) == Utility . RUNREDUCER ) { System . out . println ( "Received RUNREDUCER command from job tracker." ) ; List < ReduceBasicContext > reduceBasicContexts = msg . getReduceContexts ( ) ; if ( reduceBasicContexts . size ( ) != 0 ) { String jobID = reduceBasicContexts . get ( 0 ) . getJobID ( ) . getID ( ) ; JobContext jobContext = jobContexts . get ( jobID ) ; numReducers = reduceBasicContexts . size ( ) ; launchReducers ( jobContext , reduceBasicContexts ) ; } } else if ( msg . getMsgType ( ) == Utility . CLOSE ) { isRunning = false ; } } jobTrackerComm . close ( ) ; }
tr	9	private static Socket r4_publish ( final OtpLocalNode node ) throws IOException { Socket s = null ; try { final OtpOutputStream obuf = new OtpOutputStream ( ) ; s = new Socket ( ( String ) null , EpmdPort . get ( ) ) ; obuf . write2BE ( node . alive ( ) . length ( ) + 13 ) ; obuf . write1 ( publish4req ) ; obuf . write2BE ( node . port ( ) ) ; obuf . write1 ( node . type ( ) ) ; obuf . write1 ( node . proto ( ) ) ; obuf . write2BE ( node . distHigh ( ) ) ; obuf . write2BE ( node . distLow ( ) ) ; obuf . write2BE ( node . alive ( ) . length ( ) ) ; obuf . writeN ( node . alive ( ) . getBytes ( ) ) ; obuf . write2BE ( 0 ) ; obuf . writeTo ( s . getOutputStream ( ) ) ; if ( traceLevel >= traceThreshold ) { System . out . println ( "-> PUBLISH (r4) " + node + " port=" + node . port ( ) ) ; } final byte [ ] tmpbuf = new byte [ 100 ] ; final int n = s . getInputStream ( ) . read ( tmpbuf ) ; if ( n < 0 ) { if ( s != null ) { s . close ( ) ; } throw new IOException ( "Nameserver not responding on " + node . host ( ) + " when publishing " + node . alive ( ) ) ; } final OtpInputStream ibuf = new OtpInputStream ( tmpbuf , 0 ) ; final int response = ibuf . read1 ( ) ; if ( response == publish4resp ) { final int result = ibuf . read1 ( ) ; if ( result == 0 ) { node . creation = ibuf . read2BE ( ) ; if ( traceLevel >= traceThreshold ) { System . out . println ( "<- OK" ) ; } return s ; } } } catch ( final IOException e ) { if ( s != null ) { s . close ( ) ; } if ( traceLevel >= traceThreshold ) { System . out . println ( "<- (no response)" ) ; } throw new IOException ( "Nameserver not responding on " + node . host ( ) + " when publishing " + node . alive ( ) ) ; } catch ( final OtpErlangDecodeException e ) { if ( s != null ) { s . close ( ) ; } if ( traceLevel >= traceThreshold ) { System . out . println ( "<- (invalid response)" ) ; } throw new IOException ( "Nameserver not responding on " + node . host ( ) + " when publishing " + node . alive ( ) ) ; } if ( s != null ) { s . close ( ) ; } return null ; }
tr	7	private Entity lookupEntity ( String object ) { Entity entity = null ; String specialEntity = vocabulary . getSpecialEntities ( ) . get ( object ) ; if ( specialEntity != null ) { if ( specialEntity . equals ( "thisLocation" ) ) { entity = currentLocation ; } else if ( specialEntity . equals ( "lastLocation" ) ) { entity = previousLocation ; } else if ( specialEntity . equals ( "inventory" ) ) { entity = inventory ; } } else { entity = currentLocation . getEntity ( object ) ; if ( entity == null ) { entity = inventory . getEntity ( object ) ; } if ( entity == null || ! entity . isVisible ( ) ) { console . display ( vocabulary . getMessages ( ) . get ( "cantDo" ) ) ; entity = null ; } } return entity ; }
tr	0	public int [ ] getWarps ( ) { return new int [ ] { 0 , 0 , 0 , 0 } ; }
tr	7	@ Override public DataTypes visitBinOP ( BinOP binOP ) { String op = binOP . getOperation ( ) ; if ( stringOperations . contains ( op ) ) { return DataTypes . STRING ; } if ( numberOperations . contains ( op ) ) { DataTypes typeL = ( DataTypes ) binOP . getChild ( ) . get ( 0 ) . visit ( this ) ; DataTypes typeR = ( DataTypes ) binOP . getChild ( ) . get ( 1 ) . visit ( this ) ; if ( typeL == DataTypes . double || typeR == DataTypes . double ) return DataTypes . double ; if ( typeL != DataTypes . NONE ) { return typeL ; } if ( typeR != DataTypes . NONE ) { return typeR ; } return DataTypes . NONE ; } if ( logicOperations . contains ( op ) ) { return DataTypes . boolean ; } return null ; }
tr	1	@ Override public final Impl transform ( Source transformer ) { try { return transform ( TransformerFactory . newInstance ( ) . newTransformer ( transformer ) ) ; } catch ( TransformerConfigurationException e ) { throw new RuntimeException ( e ) ; } }
tr	6	public static void startDownload ( ) { synchronized ( lock ) { try { lock . wait ( ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } printString ( "====start download================>" ) ; List < HashMap < String , String >> info = readModuleInfo ( ) ; for ( final HashMap < String , String > map : info ) { Thread downloadThread = new Thread ( new Runnable ( ) { @ Override public void run ( ) { printString ( "thread id:" + Thread . currentThread ( ) . getId ( ) + "\nthread name:" + Thread . currentThread ( ) . getName ( ) + "\npriority:" + Thread . currentThread ( ) . getPriority ( ) + "\nstate" + Thread . currentThread ( ) . getState ( ) ) ; Set < String > set = map . keySet ( ) ; int size = set . size ( ) ; int count = 0 ; String moduleBaseURI = "" ; String modulePathKeywords = "" ; Iterator < String > itor = set . iterator ( ) ; for ( int i = 0 ; i < size ; i ++ ) { String key = itor . next ( ) ; if ( key . equals ( MODULE_PAGE_COUNT ) ) { count = Integer . valueOf ( map . get ( key ) ) ; } else { moduleBaseURI = map . get ( key ) ; modulePathKeywords = key ; } printString ( "Key" + key + " " + "map.get(key)" + map . get ( key ) ) ; } printString ( "iterate someone Module page count:" + count ) ; for ( int i = 1 ; i <= count ; i ++ ) { String gridItemUrl ; if ( i == 1 ) { gridItemUrl = moduleBaseURI ; } else { gridItemUrl = moduleBaseURI + modulePathKeywords + String . valueOf ( i ) + ".html" ; } String moduleName = moduleBaseURI ; moduleName = moduleName . replace ( "http://www.mm131.com/" , "" ) ; moduleName = moduleName . replace ( "/" , "" ) ; goIntoMoudleGridItem ( gridItemUrl , i , count , moduleName ) ; } } } ) ; executor . execute ( downloadThread ) ; } } }
tr	3	public int removeIf ( IntPredicate test ) { int removed = 0 ; for ( int i = 0 ; i < num ; i ++ ) { int key = keys [ i ] ; if ( test . test ( key ) ) { removed ++ ; } else if ( removed > 0 ) { keys [ i - removed ] = key ; } } num -= removed ; return removed ; }
tr	4	@ Override public void build ( ) { DataSet oldDataSet = getDataSet ( ) ; bits = new int [ oldDataSet . getAttributes ( ) . size ( ) ] ; Arrays . fill ( bits , 1 ) ; fillFibonacci ( ) ; for ( Pattern instance : oldDataSet ) { double [ ] features = instance . toDoubleVector ( ) ; for ( int i = 0 ; i < features . length ; i ++ ) { double feature = features [ i ] ; int maxBits = fibonacciCode ( feature . longValue ( ) ) . length ( ) ; bits [ i ] = Math . max ( bits [ i ] , maxBits ) ; } } int totalBits = 0 ; for ( int bit : bits ) { totalBits += bit ; } newDataSet = new DataSet ( ) ; newDataSet . setName ( oldDataSet . getName ( ) ) ; newDataSet . setDistribution ( oldDataSet . getDistribution ( ) ) ; newDataSet . setClasses ( oldDataSet . getClasses ( ) ) ; for ( int i = 0 ; i < totalBits ; i ++ ) { newDataSet . addAttribute ( new Attribute ( "bit" + i ) ) ; } }
tr	9	public double calScore ( Query query , Document doc ) { Vector < String > qv = query . _tokens ; Vector < String > docTokens = ( ( DocumentFull ) doc ) . getConvertedTitleTokens ( ) ; docTokens . addAll ( ( ( DocumentFull ) doc ) . getConvertedBodyTokens ( ) ) ; double score = 0.0 ; if ( qv . size ( ) == 1 ) { for ( String queryToken : query . _tokens ) { for ( String docToken : docTokens ) { if ( queryToken . equals ( docToken ) ) score ++ ; } } } else { for ( int i = 0 ; i < qv . size ( ) - 1 ; i ++ ) { if ( docTokens . size ( ) == 1 ) { if ( qv . get ( i ) . equals ( docTokens . get ( 0 ) ) ) score ++ ; } else { for ( int j = 0 ; j < docTokens . size ( ) - 1 ; j ++ ) if ( qv . get ( i ) . equals ( docTokens . get ( j ) ) && qv . get ( i + 1 ) . equals ( docTokens . get ( j + 1 ) ) ) score ++ ; } } } return score ; }
tr	5	protected final ImmutableSet < Position > getMovesTo ( final Board < ? > board , final Direction dir ) { checkNotNull ( board ) ; checkNotNull ( dir ) ; final ImmutableSet . Builder < Position > moves = ImmutableSet . builder ( ) ; Position pos = board . getPositionFor ( this ) . relative ( dir . i ( ) , dir . j ( ) ) ; while ( board . isValidPosition ( pos ) && ( ! board . isPieceAt ( pos ) || isEnemy ( board . getPieceAt ( pos ) ) ) ) { moves . add ( pos ) ; if ( board . isPieceAt ( pos ) ) { break ; } pos = pos . relative ( dir . i ( ) , dir . j ( ) ) ; } return moves . build ( ) ; }
tr	1	public int get_int ( String table , int id , String field_name ) { select ( field_name , table , table + "_id = " + id , "" ) ; if ( move_first ( ) ) return ( Integer ) get_field ( field_name ) ; else return 0 ; }
tr	7	private void drawScore ( Graphics g ) { Dimension size = getSize ( ) ; g . setColor ( Color . black ) ; alterationWidth = scoreLevel . getCurrentTonality ( ) . getAlterationsNumber ( ) * 12 ; int tmpnum = 4 ; if ( selectedGame == RHYTHMREADING ) { tmpnum = rhythmLevel . getTimeSignNumerator ( ) ; } else if ( selectedGame == SCOREREADING ) { tmpnum = scoreLevel . getTimeSignNumerator ( ) ; } int scoreLineWidth = keyWidth + alterationWidth + timeSignWidth ; firstNoteXPos = windowMargin + keyWidth + alterationWidth + timeSignWidth + notesShift ; numberOfMeasures = ( size . width - ( windowMargin * 2 ) - scoreLineWidth ) / ( tmpnum * noteDistance ) ; numberOfRows = ( size . height - scoreYpos - 50 ) / rowsDistance ; int yPos = scoreYpos ; int vXPos = windowMargin + scoreLineWidth + ( tmpnum * noteDistance ) ; scoreLineWidth += windowMargin + ( numberOfMeasures * ( tmpnum * noteDistance ) ) ; for ( int r = 0 ; r < numberOfRows ; r ++ ) { for ( int v = 0 ; v < numberOfMeasures ; v ++ ) { g . drawLine ( vXPos + v * ( tmpnum * noteDistance ) , yPos , vXPos + v * ( tmpnum * noteDistance ) , yPos + 40 ) ; } if ( selectedGame == SCOREREADING ) { for ( int l = 0 ; l < 5 ; l ++ , yPos += 10 ) { g . drawLine ( windowMargin , yPos , scoreLineWidth , yPos ) ; } } else if ( selectedGame == RHYTHMREADING ) { g . drawLine ( windowMargin , yPos + 20 , scoreLineWidth , yPos + 20 ) ; yPos += ( rowsDistance - 50 ) ; } yPos += ( rowsDistance - 50 ) ; } }
tr	0	public void setSManualCashbackStatusDescription ( String manualCashbackStatusDescription ) { sManualCashbackStatusDescription = manualCashbackStatusDescription ; }
tr	0	public WorldMap ( MapBaggage baggage ) { planet = new Planet ( baggage . polarCircumferenceInKilometers ) ; mesh = new IcosahedralMesh ( baggage . meshSize ) ; int numCells = mesh . countCells ( ) ; terrain = Porter . stringsToTerrain ( baggage . terrainStrings , numCells ) ; bonuses = Porter . stringToBits ( baggage . bonusString , numCells ) ; roads = Porter . stringToBits ( baggage . roadString , numCells ) ; railroads = Porter . stringToBits ( baggage . railroadString , numCells ) ; irrigation = Porter . stringToBits ( baggage . irrigationString , numCells ) ; villages = Porter . stringToBits ( baggage . villageString , numCells ) ; cities = Porter . stringToBits ( baggage . cityString , numCells ) ; }
tr	0	public synchronized long getHMillis ( ) { return ( long ) ( p . H * 1000.0 ) ; }
tr	5	@ Override public void render ( GameContainer gc , StateBasedGame sbg , Graphics grphcs ) throws SlickException { background . draw ( 0 , 0 ) ; txtName . render ( gc , grphcs ) ; for ( int i = 0 ; i < areas . length ; i ++ ) { areas [ i ] . render ( gc , grphcs ) ; } for ( StatAllocation stat : stats ) { ttf . drawString ( stat . getPosition ( ) . getX ( ) , stat . getPosition ( ) . getY ( ) , Integer . toString ( stat . getStat ( ) ) ) ; } if ( femaleChose == true ) { ttf . drawString ( 170 , 94 , "X" , Color . white ) ; int x = 94 ; grphcs . scale ( 2 , 2 ) ; for ( PlayerSprite ps : female ) { ps . getAnimation ( ) . draw ( x , 80 ) ; x = x + 36 ; } } else { ttf . drawString ( 360 , 93 , "X" , Color . white ) ; int x = 94 ; grphcs . scale ( 2 , 2 ) ; for ( PlayerSprite ps : male ) { ps . getAnimation ( ) . draw ( x , 80 ) ; x = x + 36 ; } } grphcs . scale ( .5f , .5f ) ; }
tr	9	public static void main ( String [ ] args ) { boolean a , b ; System . out . println ( "a\tb\ta and b\ta or b\tnot a\tnot b \n" ) ; a = 3 > 5 ; b = 12 != 8 ; System . out . print ( "(3>5)\t(12!=8)\t" + ( a && b ) ) ; System . out . print ( "\t" ) ; System . out . print ( a || b ) ; System . out . print ( "\t" ) ; System . out . print ( ! a ) ; System . out . print ( "\t" ) ; System . out . println ( ! b + "\n" ) ; a = 5 >= 6 ; b = 3 != 3 ; System . out . print ( "(5>=6)\t(3!=3)\t" + ( a && b ) ) ; System . out . print ( "\t" ) ; System . out . print ( a || b ) ; System . out . print ( "\t" ) ; System . out . print ( ! a ) ; System . out . print ( "\t" ) ; System . out . println ( ! b + "\n" ) ; a = - 7 == 8 ; System . out . print ( "(-7=8)\t(22)\t" + ( a && b ) ) ; System . out . print ( "\t" ) ; System . out . print ( a || b ) ; System . out . print ( "\t" ) ; System . out . print ( ! a ) ; System . out . print ( "\t" ) ; System . out . println ( ! b + " NO SE PUEDE USAR EL 22\n" ) ; a = 21 != 12 ; b = true ; System . out . print ( "21!=12\t(true)\t" + ( a && b ) ) ; System . out . print ( "\t" ) ; System . out . print ( a || b ) ; System . out . print ( "\t" ) ; System . out . print ( ! a ) ; System . out . print ( "\t" ) ; System . out . println ( ! b + "\n" ) ; a = 4 == 2 ; b = 7 >= - 9 ; System . out . print ( "(4==2)\t(7>=-9)\t" + ( a && b ) ) ; System . out . print ( "\t" ) ; System . out . print ( a || b ) ; System . out . print ( "\t" ) ; System . out . print ( ! a ) ; System . out . print ( "\t" ) ; System . out . println ( ! b + "\n" ) ; }
tr	9	public static String toString ( JSONArray ja ) throws JSONException { int i ; JSONObject jo ; String key ; Iterator keys ; int length ; Object object ; StringBuffer sb = new StringBuffer ( ) ; String tagName ; String value ; tagName = ja . getString ( 0 ) ; XML . noSpace ( tagName ) ; tagName = XML . escape ( tagName ) ; sb . append ( < ) ; sb . append ( tagName ) ; object = ja . opt ( 1 ) ; if ( object instanceof JSONObject ) { i = 2 ; jo = ( JSONObject ) object ; keys = jo . keys ( ) ; while ( keys . hasNext ( ) ) { key = keys . next ( ) . toString ( ) ; XML . noSpace ( key ) ; value = jo . optString ( key ) ; if ( value != null ) { sb . append (   ) ; sb . append ( XML . escape ( key ) ) ; sb . append ( = ) ; sb . append ( " ) ; sb . append ( XML . escape ( value ) ) ; sb . append ( " ) ; } } } else { i = 1 ; } length = ja . length ( ) ; if ( i >= length ) { sb . append ( / ) ; sb . append ( > ) ; } else { sb . append ( > ) ; do { object = ja . get ( i ) ; i += 1 ; if ( object != null ) { if ( object instanceof String ) { sb . append ( XML . escape ( object . toString ( ) ) ) ; } else if ( object instanceof JSONObject ) { sb . append ( toString ( ( JSONObject ) object ) ) ; } else if ( object instanceof JSONArray ) { sb . append ( toString ( ( JSONArray ) object ) ) ; } } } while ( i < length ) ; sb . append ( < ) ; sb . append ( / ) ; sb . append ( tagName ) ; sb . append ( > ) ; } return sb . toString ( ) ; }
tr	8	static public void msDur ( StringBuilder sb , int ms ) { if ( ms < 0 ) { sb . append ( "-" ) ; msDur ( sb , - ms ) ; } else if ( ms < 1000 ) { sb . append ( ms ) ; sb . append ( "ms" ) ; } else if ( ms < 10000 ) { tenths ( sb , ms , 1000 ) ; sb . append ( s ) ; } else if ( ms < 60000 ) { sb . append ( ms / 1000 ) ; sb . append ( s ) ; } else if ( ms < 600000 ) { tenths ( sb , ms , 60000 ) ; sb . append ( m ) ; } else if ( ms < 3600000 ) { sb . append ( ms / 60000 ) ; sb . append ( m ) ; } else if ( ms < 36000000 ) { tenths ( sb , ms , 3600000 ) ; sb . append ( h ) ; } else if ( ms < 86400000 ) { sb . append ( ms / 3600000 ) ; sb . append ( h ) ; } else { tenths ( sb , ms , 86400000 ) ; sb . append ( d ) ; } }
tr	6	@ Override public boolean isValidTrip ( Collection < Trip > allTrips , Set < Trip > uniqueTrips , Trip trip , StopsList s ) { int frequency = Collections . frequency ( allTrips , trip ) ; if ( s . getStopsTime ( ) . get ( new long ( 1 ) ) == null ) return false ; else if ( frequency <= 1 ) { System . err . println ( "GTTPlugin: Ignoring trip " + trip . getTripID ( ) + " found only one  may not be a valid route" ) ; return false ; } else if ( frequency <= 4 && ( s . getStopsTime ( ) . get ( new long ( 1 ) ) . startsWith ( "04" ) || s . getStopsTime ( ) . get ( new long ( 1 ) ) . startsWith ( "05" ) || s . getStopsTime ( ) . get ( new long ( 1 ) ) . startsWith ( "06" ) ) ) { System . err . println ( "GTTPlugin: Ignoring trip " + trip . getTripID ( ) + " found only four times in early morning  may be a warmup route" ) ; return false ; } return true ; }
tr	8	public static int [ ] [ ] readIntMatrix ( ) { while ( true ) { String [ ] lineTokens = readString ( ) . split ( "/" ) ; if ( lineTokens . length > 1 ) { String [ ] [ ] tokens = new String [ lineTokens . length ] [ ] ; int columns = 0 ; for ( int line = 0 ; line < lineTokens . length ; line ++ ) { tokens [ line ] = lineTokens [ line ] . split ( " " ) ; if ( tokens [ line ] . length > columns ) { columns = tokens [ line ] . length ; } } if ( columns > 0 ) { int [ ] [ ] array = new int [ lineTokens . length ] [ columns ] ; try { for ( int line = 0 ; line < tokens . length ; line ++ ) { for ( int column = 0 ; column < tokens [ line ] . length ; column ++ ) { array [ line ] [ column ] = Integer . parseInt ( tokens [ line ] [ column ] ) ; } } return array ; } catch ( NumberFormatException e ) { System . err . println ( ERROR_INVALID_INT ) ; } } else { System . out . println ( ERROR_EMPTY_LINE ) ; } } else { System . out . println ( ERROR_ONE_LINE_ARRAY ) ; } } }
tr	1	public Dimension minimumLayoutSize ( Container target ) { if ( target . getComponentCount ( ) == 0 ) return new Dimension ( 0 , 0 ) ; return processLayout ( target , MINIMUM_LAYOUT_SIZE_MODE ) ; }
tr	1	public void removeAll ( ) { for ( int i = getRowCount ( ) - 1 ; i >= 0 ; i -- ) { removeRow ( i ) ; } }
tr	0	private PlayerPanel buildSecondPlayerPanel ( ) { return new ComputerPlayerPanel ( controller , PlayerSide . RIGHT ) ; }
tr	8	public void actionPerformed ( ActionEvent e ) { if ( e . getSource ( ) == left ) { halign = Alignment . LEFT ; return ; } if ( e . getSource ( ) == center ) { halign = Alignment . CENTER ; return ; } if ( e . getSource ( ) == right ) { halign = Alignment . RIGHT ; return ; } if ( e . getSource ( ) == top ) { valign = Alignment . TOP ; return ; } if ( e . getSource ( ) == middle ) { valign = Alignment . MIDDLE ; return ; } if ( e . getSource ( ) == bottom ) { valign = Alignment . BOTTOM ; return ; } if ( e . getSource ( ) == fButton ) { Font newFont = FontDialog . getFont ( font ) ; if ( newFont == null ) return ; font = newFont ; fButton . setFont ( font ) ; } }
tr	3	static String stripLeadingHyphens ( String str ) { if ( str == null ) { return null ; } if ( str . startsWith ( "--" ) ) { return str . substring ( 2 , str . length ( ) ) ; } else if ( str . startsWith ( "-" ) ) { return str . substring ( 1 , str . length ( ) ) ; } return str ; }
tr	7	public static Field randomReachableField ( Field from , HashMap < Field , ArrayList < Object >> conflictingHashMap , ArrayList < Field > shouldGetCleared ) { LinkedList < Field > frontier = new LinkedList < Field > ( ) ; frontier . add ( from ) ; ArrayList < Field > closedSet = new ArrayList < Field > ( ) ; Field currentField = frontier . poll ( ) ; closedSet . add ( currentField ) ; while ( currentField != null ) { for ( Field neighbour : currentField . neighbors ) { if ( neighbour != null && ! closedSet . contains ( neighbour ) && ( ! conflictingHashMap . containsKey ( neighbour ) || ( conflictingHashMap . containsKey ( neighbour ) && conflictingHashMap . get ( neighbour ) . contains ( from ) ) ) ) { frontier . add ( neighbour ) ; closedSet . add ( neighbour ) ; } } currentField = frontier . poll ( ) ; } Random rand = new Random ( ) ; return closedSet . get ( rand . nextInt ( closedSet . size ( ) ) ) ; }
tr	3	private void displayURL ( URL url ) { try { if ( url != null ) { htmlPane . setPage ( url ) ; } else { htmlPane . setText ( "File Not Found" ) ; if ( DEBUG ) { System . out . println ( "Attempted to display a null URL." ) ; } } } catch ( IOException e ) { System . err . println ( "Attempted to read a bad URL: " + url ) ; } }
tr	3	private String getDataFrom ( String address ) { InputStream inputStream = null ; try { URL url = new URL ( address ) ; inputStream = url . openStream ( ) ; return convertStreamToString ( inputStream ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { if ( inputStream != null ) { try { inputStream . close ( ) ; } catch ( IOException e ) { } } } return null ; }
tr	5	public static boolean isValidWeekInMonthCode ( final int code ) { switch ( code ) { case FIRST_WEEK_IN_MONTH : case SECOND_WEEK_IN_MONTH : case THIRD_WEEK_IN_MONTH : case FOURTH_WEEK_IN_MONTH : case LAST_WEEK_IN_MONTH : return true ; default : return false ; } }
tr	0	public PackedWorld ( PackedWorld prev ) { super ( prev ) ; cells = 0 ; }
tr	8	private AffineTransform findTranslation ( AffineTransform transform , float angle ) { Point2D point_in = null , point_out = null ; if ( angle > 0 && angle <= 90 ) { point_in = new Point2D . double ( 0 , 0 ) ; } else if ( angle >= 270 && angle < 360 ) { point_in = new Point2D . double ( myImage . getWidth ( ) , 0 ) ; } point_out = transform . transform ( point_in , null ) ; double ytrans = point_out . getY ( ) ; if ( angle > 0 && angle <= 90 ) { point_in = new Point2D . double ( 0 , myImage . getHeight ( ) ) ; } else if ( angle >= 270 && angle < 360 ) { point_in = new Point2D . double ( 0 , 0 ) ; } point_out = transform . transform ( point_in , null ) ; double xtrans = point_out . getX ( ) ; AffineTransform tat = new AffineTransform ( ) ; tat . translate ( - xtrans , - ytrans ) ; return tat ; }
tr	2	@ Override protected boolean isConsumed ( KeyboardEvent e ) { boolean rc = false ; if ( e . getKey ( ) == Keyboard . KEY_UP || e . getKey ( ) == Keyboard . KEY_DOWN ) { rc = true ; } return rc ; }
tr	8	public HashMap < Integer , Integer > getSgd2iesdhcmap ( ) { if ( sgd2iesdhcmap != null ) { return sgd2iesdhcmap ; } sgd2iesdhcmap = new HashMap < Integer , Integer > ( ) ; String SQL1 = "SELECT id  TIME_FORMAT(inicio '%H:%i') AS inicio  TIME_FORMAT(fin '%H:%i') AS fin FROM horascentro" ; try { Statement st = getSgd ( ) . createStatement ( ) ; ResultSet rs1 = getSgd ( ) . getResultSet ( SQL1 , st ) ; while ( rs1 != null && rs1 . next ( ) ) { int id = rs1 . getInt ( "id" ) ; String inicio = rs1 . getString ( "inicio" ) ; String fin = rs1 . getString ( "fin" ) ; String SQL2 = "SELECT codigo from sig_hores_classe WHERE inicio='" + inicio + "' AND fin='" + fin + "'" ; Statement st2 = getMysql ( ) . createStatement ( ) ; ResultSet rs2 = getMysql ( ) . getResultSet ( SQL2 , st2 ) ; if ( rs2 != null && rs2 . next ( ) ) { sgd2iesdhcmap . put ( id , rs2 . getInt ( 1 ) ) ; } if ( rs2 != null ) { rs2 . close ( ) ; st2 . close ( ) ; } } if ( rs1 != null ) { rs1 . close ( ) ; st . close ( ) ; } } catch ( SQLException ex ) { Logger . getLogger ( HoraCentro . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } return sgd2iesdhcmap ; }
tr	0	@ Override public String getParams ( ) { StringBuilder parmas = new StringBuilder ( ) ; parmas . append ( pppUserName ) . append ( CTConstant . VALUE_ACCOUNT ) . append ( pppPassword ) ; return parmas . toString ( ) ; }
tr	9	public static char traverse ( int x , int y ) { if ( grid [ x ] [ y ] !=   ) return grid [ x ] [ y ] ; int [ ] coord = { - 1 , - 1 } ; int min = Integer . MAX_VALUE ; if ( ( x - 1 ) >= 0 && alt [ x - 1 ] [ y ] < alt [ x ] [ y ] && alt [ x - 1 ] [ y ] < min ) { coord [ 0 ] = x - 1 ; coord [ 1 ] = y ; min = alt [ x - 1 ] [ y ] ; } if ( ( y - 1 ) >= 0 && alt [ x ] [ y - 1 ] < alt [ x ] [ y ] && alt [ x ] [ y - 1 ] < min ) { coord [ 0 ] = x ; coord [ 1 ] = y - 1 ; min = alt [ x ] [ y - 1 ] ; } if ( ( y + 1 ) < W && alt [ x ] [ y + 1 ] < alt [ x ] [ y ] && alt [ x ] [ y + 1 ] < min ) { coord [ 0 ] = x ; coord [ 1 ] = y + 1 ; min = alt [ x ] [ y + 1 ] ; } if ( ( x + 1 ) < H && alt [ x + 1 ] [ y ] < alt [ x ] [ y ] && alt [ x + 1 ] [ y ] < min ) { coord [ 0 ] = x + 1 ; coord [ 1 ] = y ; min = alt [ x + 1 ] [ y ] ; } if ( min == Integer . MAX_VALUE ) { currBas ++ ; return grid [ x ] [ y ] = ( char ) ( currBas + a ) ; } return grid [ x ] [ y ] = traverse ( coord [ 0 ] , coord [ 1 ] ) ; }
tr	8	void repairCutValues ( Edge edge ) { spanningTree . remove ( edge ) ; Node n = getTreeTail ( edge ) ; int cutvalue = 0 ; int multiplier = ( edge . target == n ) ? 1 : - 1 ; EdgeList list ; list = n . outgoing ; Edge e ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { e = list . getEdge ( i ) ; if ( e . tree && e != edge ) cutvalue += ( e . cut - e . weight ) * multiplier ; else cutvalue -= e . weight * multiplier ; } list = n . incoming ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { e = list . getEdge ( i ) ; if ( e . tree && e != edge ) cutvalue -= ( e . cut - e . weight ) * multiplier ; else cutvalue += e . weight * multiplier ; } edge . cut = cutvalue ; if ( cutvalue < 0 ) spanningTree . add ( edge ) ; }
tr	2	public NewSplashScreen ( int maximumValue , Locale locMe ) { maxVal = maximumValue ; Logger log = LoggerFactory . getLogger ( "mars.mars.gui.NewSplashScreen" ) ; MarsResourceBundle mrbSplash = new MarsResourceBundle ( locMe ) ; textVal = mrbSplash . getRBString ( "mars.gui.splash.load" , "Loading..." ) ; log . finest ( "Splash Screen created for JSE 1.6 or higher  attempting to obtain the SplashScreen class." ) ; splash = SplashScreen . getSplashScreen ( ) ; if ( splash == null ) { log . finest ( "SplashScreen couldn't be obtained  must be running on pre 1.6." ) ; System . err . println ( mrbSplash . getRBString ( "mars.errors.SplashScreenNotCompatible" , "Splash screen is null. May be running on JSE 1.5 or earlier." ) ) ; configured = false ; return ; } g = ( Graphics2D ) splash . createGraphics ( ) ; if ( g == null ) { log . finest ( "Graphics2D class could not be obtained  currently null." ) ; System . err . println ( mrbSplash . getRBString ( "mars.errors.Graphics2DNotFound" , "Cannot obtain the Splash screen graphics2D class. It is currently null." ) ) ; configured = false ; return ; } }
tr	5	private void handleFailed ( ) { uncompletedCount = 0 ; completedCount = 0 ; for ( OnDemandData onDemandData = ( OnDemandData ) requested . peekLast ( ) ; onDemandData != null ; onDemandData = ( OnDemandData ) requested . reverseGetNext ( ) ) if ( onDemandData . incomplete ) uncompletedCount ++ ; else completedCount ++ ; while ( uncompletedCount < 10 ) { OnDemandData onDemandData_1 = ( OnDemandData ) aClass19_1368 . popHead ( ) ; if ( onDemandData_1 == null ) break ; if ( filePriorities [ onDemandData_1 . dataType ] [ onDemandData_1 . id ] != 0 ) filesLoaded ++ ; filePriorities [ onDemandData_1 . dataType ] [ onDemandData_1 . id ] = 0 ; requested . insertHead ( onDemandData_1 ) ; uncompletedCount ++ ; closeRequest ( onDemandData_1 ) ; waiting = true ; } }
tr	4	@ Override public boolean equals ( Object other ) { if ( other == null ) { return false ; } if ( other == this ) { return true ; } if ( other . getClass ( ) . equals ( this . getClass ( ) ) ) { DayMonthInYear otherDayOfMonth = ( DayMonthInYear ) other ; return this . day == otherDayOfMonth . day && this . month == otherDayOfMonth . month ; } return false ; }
tr	5	public static void main ( String [ ] arg ) { String s = arg [ 0 ] . toUpperCase ( ) ; char grade = s . charAt ( 0 ) ; switch ( grade ) { case H : System . out . println ( "Your score is between 85-100." ) ; break ; case D : System . out . println ( "Your score is between 75-84." ) ; break ; case C : System . out . println ( "Your score is between 65-74." ) ; break ; case P : System . out . println ( "Your score is between 50-64." ) ; break ; case F : System . out . println ( "Your score is between 0-49." ) ; break ; default : break ; } }
tr	5	public void packTag ( byte [ ] bytes ) { Arrays . fill ( bytes , ( byte ) 0 ) ; try { BufferTools . stringIntoByteBuffer ( TAG , 0 , 3 , bytes , 0 ) ; } catch ( UnsupportedEncodingException e ) { } packField ( bytes , title , TITLE_LENGTH , TITLE_OFFSET ) ; packField ( bytes , artist , ARTIST_LENGTH , ARTIST_OFFSET ) ; packField ( bytes , album , ALBUM_LENGTH , ALBUM_OFFSET ) ; packField ( bytes , year , YEAR_LENGTH , YEAR_OFFSET ) ; if ( genre < 128 ) { bytes [ GENRE_OFFSET ] = ( byte ) genre ; } else { bytes [ GENRE_OFFSET ] = ( byte ) ( genre - 256 ) ; } if ( track == null ) { packField ( bytes , comment , COMMENT_LENGTH_V1_0 , COMMENT_OFFSET ) ; } else { packField ( bytes , comment , COMMENT_LENGTH_V1_1 , COMMENT_OFFSET ) ; String trackTemp = numericsOnly ( track ) ; if ( trackTemp . length ( ) > 0 ) { int trackInt = Integer . parseInt ( trackTemp ) ; if ( trackInt < 128 ) { bytes [ TRACK_OFFSET ] = ( byte ) trackInt ; } else { bytes [ TRACK_OFFSET ] = ( byte ) ( trackInt - 256 ) ; } } } }
tr	3	@ EventHandler ( priority = EventPriority . MONITOR ) public void join ( PlayerJoinEvent event ) { String name = event . getPlayer ( ) . getName ( ) ; if ( qm . getQuestLog ( name ) == null ) { PlayerQuestLog log = new PlayerQuestLog ( name ) ; qm . addQuestLog ( log ) ; for ( Quest q : qm . getQuests ( ) ) { if ( q . isFirstAssigned ( ) ) log . assign ( q ) ; } } }
tr	6	private int buildHistory ( ColumnSet set , JPanel panel ) { NumberFormat formatter = new DecimalFormat ( "##.##" ) ; int numRows = getNumRows ( set ) ; int numChildren = getNumChildren ( set ) ; for ( int r = 0 ; r < numRows ; r ++ ) { Color backColor ; if ( r % 2 == 0 ) backColor = darkColor ; else backColor = lightColor ; int index = 0 ; for ( int p = 0 ; p < set . getNumParents ( ) ; p ++ ) { ColumnParent parent = set . getParent ( p ) ; for ( int c = 0 ; c < parent . getNumChildren ( ) ; c ++ ) { JPanel columnPanel = new JPanel ( ) ; JLabel columnLabel = new JLabel ( ) ; ColumnChild child = parent . getChild ( c ) ; String data = "" ; if ( r >= child . getNumData ( ) || child . getData ( r ) == null ) data = "" ; else data = child . getData ( r ) ; columnLabel . setText ( data ) ; columnLabel . setForeground ( Color . black ) ; columnLabel . setHorizontalAlignment ( SwingConstants . CENTER ) ; columnPanel . add ( columnLabel ) ; columnPanel . setBackground ( backColor ) ; GridBagConstraints constraints = getChildConstraints ( index == ( numChildren - 1 ) ) ; gridbag . setConstraints ( columnPanel , constraints ) ; panel . add ( columnPanel ) ; index ++ ; } } } return numRows ; }
tr	5	public boolean commit ( Connection conn ) throws SQLException { boolean status = true ; try { conn . setAutoCommit ( false ) ; BookingMapper bm = new BookingMapper ( ) ; status = status && bm . addNewBooking ( newBooking , conn ) ; status = status && bm . updateBooking ( modifiedBooking , conn ) ; status = status && bm . deleteBooking ( deleteBooking , conn ) ; if ( ! status ) { throw new Exception ( "Business Transaction aborted" ) ; } conn . commit ( ) ; } catch ( Exception e ) { System . out . println ( "fail in UnitOfWork - commit()" ) ; System . err . println ( e ) ; conn . rollback ( ) ; status = false ; } return status ; }
tr	0	public static void main ( String [ ] args ) { }
tr	7	public static void domNodeToTree ( Node domNode , TreeDomNode parentTreeNode , boolean displayNodeValue ) { if ( domNode instanceof Text ) return ; TreeDomNode treeNode = new TreeDomNode ( domNode , displayNodeValue ) ; parentTreeNode . add ( treeNode ) ; NamedNodeMap attributeNodes = domNode . getAttributes ( ) ; if ( ( attributeNodes != null ) && ( attributeNodes . getLength ( ) > 0 ) ) { for ( int i = 0 ; i < attributeNodes . getLength ( ) ; i ++ ) { treeNode . add ( new TreeDomNode ( attributeNodes . item ( i ) , displayNodeValue ) ) ; } } NodeList childNodes = domNode . getChildNodes ( ) ; if ( ( childNodes != null ) && ( childNodes . getLength ( ) > 0 ) ) { for ( int i = 0 ; i < childNodes . getLength ( ) ; i ++ ) domNodeToTree ( childNodes . item ( i ) , treeNode , displayNodeValue ) ; } }
tr	3	public DeliverType getDeliverTypeById ( long deliverTypeId ) { Session session = null ; DeliverType deliverType = null ; try { session = HibernateUtil . getSessionFactory ( ) . openSession ( ) ; deliverType = ( DeliverType ) session . load ( DeliverType . class , deliverTypeId ) ; } catch ( Exception e ) { System . err . println ( "\u041E\u0448\u0438\u0431\u043A\u0430 'findById'" + e . getMessage ( ) ) ; } finally { if ( session != null && session . isOpen ( ) ) { session . close ( ) ; } } return deliverType ; }
tr	0	public String getCourseNumber ( ) { return courseNumber ; }
tr	7	public TelaEnfermeiro ( String nome , ArrayList < String > pacientes , String permissao ) { localNome = nome ; typeUser = permissao ; localNome = nome ; temConsulta = false ; initComponents ( ) ; modelLista1 = new DefaultListModel < > ( ) ; for ( String paciente : pacientes ) { modelLista1 . addElement ( paciente ) ; } listaPacientes . setModel ( modelLista1 ) ; listaPacientes . setSelectedIndex ( 0 ) ; System . out . println ( "Lendo consultas de " + nome ) ; model = new DefaultListModel < > ( ) ; CSVAcesso ler = new CSVAcesso ( "agenda.csv" , "true" ) ; ler . parse ( ) ; agendaTotal = ler . retornarTudo ( ) ; model . addElement ( "Consultas M\u00E9dicas marcadas" ) ; for ( ArrayList < String > agendaPaciente1 : agendaTotal ) { for ( int j = 0 ; j < agendaPaciente1 . size ( ) ; j ++ ) { if ( agendaPaciente1 . get ( 3 ) . equals ( listaPacientes . getSelectedValue ( ) . toString ( ) ) ) { if ( j == 0 && temConsulta == false ) { model . addElement ( "Tem consultas marcadas" ) ; temConsulta = true ; break ; } } } } if ( temConsulta == false ) { model . addElement ( "Paciente n\u00E3o Tem consultas marcadas" ) ; } listaConsultas . setModel ( model ) ; btnSalvar . setVisible ( temConsulta ) ; }
tr	4	public String getNomByAbrev ( String abrev ) { String nom = "" ; String SQL1 = "Select nombre from sig_professorat where abrev='" + abrev + "'" ; try { Statement st = client . getMysql ( ) . createStatement ( ) ; ResultSet rs1 = client . getMysql ( ) . getResultSet ( SQL1 , st ) ; if ( rs1 != null && rs1 . next ( ) ) { nom = rs1 . getString ( "nombre" ) ; } if ( rs1 != null ) { rs1 . close ( ) ; st . close ( ) ; } } catch ( SQLException ex ) { Logger . getLogger ( ProfessoratData . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } return nom ; }
tr	6	public RegisteredEventListener ( Method listenerMethod , Listener listener ) { EventListener listenerAnnotation = listenerMethod . getAnnotation ( EventListener . class ) ; if ( listenerAnnotation == null ) { throw new IllegalArgumentException ( "Listener method does not have an EventListener annotation." ) ; } priority = listenerAnnotation . priority ( ) ; ignoresCancelled = listenerAnnotation . ignoreCancelled ( ) ; class < ? > [ ] listenerMethodParameters = listenerMethod . getParameterTypes ( ) ; if ( listenerMethodParameters . length != 1 || ! Event . class . isAssignableFrom ( listenerMethodParameters [ 0 ] ) ) { throw new IllegalArgumentException ( "Listener method signature invalid. Does not have a single Event subclass parameter." ) ; } eventType = ( class < ? extends Event > ) listenerMethodParameters [ 0 ] ; this . listenerMethod = listenerMethod ; if ( ! listenerMethod . isAccessible ( ) ) { listenerMethod . setAccessible ( true ) ; } this . listener = listener ; }
tr	6	public double pow ( double x , int n ) { double pow = 1 ; if ( x == 0 ) return x ; boolean isNegative = ( n < 0 ) ? true : false ; n = ( n < 0 ) ? - n : n ; while ( n > 0 ) { if ( n % 2 == 1 ) { pow = pow * x ; } x *= x ; n /= 2 ; System . out . println ( pow ) ; } return isNegative ? 1 / pow : pow ; }
tr	6	private JavaCell [ ] [ ] createTestMap ( int xC , int yC ) { JavaCell [ ] [ ] testingMap = new JavaCell [ 3 ] [ 3 ] ; for ( int i = 0 , x = xC - 1 ; i < 3 ; i ++ , x ++ ) { for ( int j = 0 , y = yC - 1 ; j < 3 ; j ++ , y ++ ) { if ( ( x >= 0 && x < map . length ) && ( y >= 0 ) && ( y < map [ 0 ] . length ) ) { testingMap [ i ] [ j ] = map [ x ] [ y ] ; } } } return testingMap ; }
tr	2	@ Override public double calculateCostOfProductsBySupplier ( int supplierID ) throws Exception { double totalCost = 0.00 ; try { Result < ProductGateway > result = null ; result = ProductGateway . getProductsBySupplier ( supplierID ) ; Iterator < ProductGateway > iter = result . Items . iterator ( ) ; while ( iter . hasNext ( ) ) { ProductGateway item = iter . next ( ) ; totalCost += item . Price ; } } catch ( Exception e ) { throw e ; } return totalCost ; }
tr	2	@ Override public boolean getFeature ( String name ) throws SAXNotRecognizedException , SAXNotSupportedException { if ( name . equals ( NAMESPACES_FEATURE ) || name . equals ( NAMESPACE_PREFIXES_FEATURE ) ) { return true ; } else { throw new SAXNotRecognizedException ( "Feature Not Supported: " + name ) ; } }
tr	6	public void mouseClicked ( MouseEvent me ) { try { if ( me . getSource ( ) == jb_connexion ) { login = jtf_login . getText ( ) ; password = String . valueOf ( jpf_password . getPassword ( ) ) ; System . out . println ( "Email : " + login ) ; System . out . println ( "MotDePasse : " + password ) ; User u = null ; Connection co = bs . getConnection ( ) ; System . out . println ( "avant IF" ) ; if ( User . checkPresence ( bs , login , password ) ) { System . out . println ( "debut IF" ) ; u = User . findByLogs ( login , password , bs ) ; groupe = UserType . findById ( u . getId_ut ( ) , bs ) . getName_ut ( ) ; System . out . println ( "OK : " + groupe ) ; afficherMenuPrincipal ( ) ; setResizable ( true ) ; setExtendedState ( MAXIMIZED_BOTH ) ; } else { System . out . println ( "NON OK" ) ; } } if ( me . getSource ( ) == jb_mdp_oublie ) { if ( SwingUtilities . isLeftMouseButton ( me ) ) { } if ( SwingUtilities . isRightMouseButton ( me ) ) { } } } catch ( Exception e ) { System . out . println ( "Exception" ) ; e . printStackTrace ( ) ; } }
tr	3	public static void filledCircle ( double x , double y , double r ) { if ( r < 0 ) throw new IllegalArgumentException ( "circle radius must be nonnegative" ) ; double xs = scaleX ( x ) ; double ys = scaleY ( y ) ; double ws = factorX ( 2 * r ) ; double hs = factorY ( 2 * r ) ; if ( ws <= 1 && hs <= 1 ) pixel ( x , y ) ; else offscreen . fill ( new Ellipse2D . double ( xs - ws / 2 , ys - hs / 2 , ws , hs ) ) ; draw ( ) ; }
tr	6	public void run ( ) { String message ; LinkedList < Stockage . Machine > servers = Donnees . getAllServeurs ( ) ; servers . add ( Global . MYSELF ) ; boolean continuer = true ; while ( continuer ) { message = new String ( ) ; while ( message . length ( ) < Global . BUFFER_LENGTH / 4 && ! servers . isEmpty ( ) ) { Machine m = servers . pop ( ) ; message += Message . BEGIN + " " + m . ipAdresse + " " + m . port + " " ; } if ( servers . isEmpty ( ) ) { message += Message . END_ENVOI + " " ; continuer = false ; } try { s . write ( Utilitaires . stringToBuffer ( message ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } try { s . close ( ) ; } catch ( IOException e ) { } RelationsPubliques . BroadcastAll . broadcastTCP ( Message . NEW_SERVER + " " + s . socket ( ) . getInetAddress ( ) . getHostAddress ( ) + " " + ( s . socket ( ) . getPort ( ) - 3 ) + " #" , Donnees . getAllServeurs ( ) ) ; Donnees . putServer ( new Machine ( s . socket ( ) . getInetAddress ( ) . getHostAddress ( ) , s . socket ( ) . getPort ( ) - 3 ) ) ; Donnees . printServerList ( ) ; }
tr	2	private static void loadConfig ( ) { VMConfiguration . config = new VMConfiguration ( ) ; InputStream conf_file ; try { conf_file = new FileInputStream ( new File ( CONF_FILE ) ) ; Properties props = new Properties ( ) ; props . load ( conf_file ) ; config . weightNumber = Integer . parseInt ( props . getProperty ( Constants . WEIGHT_NUMBER ) ) ; config . learnFileName = props . getProperty ( Constants . LEARN_FILE_NAME ) ; config . topologyModelType = props . getProperty ( Constants . TOPOLOGY_MODEL ) ; config . rows = Integer . parseInt ( props . getProperty ( Constants . ROWS ) ) ; config . cols = Integer . parseInt ( props . getProperty ( Constants . COLS ) ) ; config . radius = Integer . parseInt ( props . getProperty ( Constants . RADIUS ) ) ; config . numberofWeights = Integer . parseInt ( props . getProperty ( Constants . NUMBER_OF_WEIGHTS ) ) ; config . maxWeight = Integer . parseInt ( props . getProperty ( Constants . MAX_WEIGHT ) ) ; config . maxIteration = Integer . parseInt ( props . getProperty ( Constants . MAX_ITERATION ) ) ; config . trainMetricType = props . getProperty ( Constants . TRAIN_METRIC_TYPE ) ; config . predictMetricType = props . getProperty ( Constants . PREDICT_METRIC_TYPE ) ; config . learningFactor = Integer . parseInt ( props . getProperty ( Constants . LEARN_FACTOR ) ) ; config . neighbourFactor = double . parseDouble ( props . getProperty ( Constants . NEIGHBOUR_FACTOR ) ) ; config . kFoldValue = Integer . parseInt ( props . getProperty ( Constants . K_FOLD_VALUE ) ) ; config . delimiter = props . getProperty ( Constants . DELIMITER ) ; config . pythonFileLocation = props . getProperty ( Constants . PYTHON_FILE ) ; config . normalizedFileName = props . getProperty ( Constants . NORMALIZED_FILE ) ; config . normalNeurons = Integer . parseInt ( props . getProperty ( Constants . NORMAL_NEURONS ) ) ; config . predictDataFile = props . getProperty ( Constants . PREDICT_DATA_FILE ) ; config . lookAheadSize = Integer . parseInt ( props . getProperty ( Constants . LOOK_AHEAD_SIZE ) ) ; config . predictAheadStep = Integer . parseInt ( props . getProperty ( Constants . PREDICT_AHEAD_STEP ) ) ; config . gaussianHeight = Integer . parseInt ( props . getProperty ( Constants . GAUSSIAN_HEIGHT ) ) ; config . mem_log_file = props . getProperty ( Constants . MEM_LOG_FILE ) ; config . metric_log_file = props . getProperty ( Constants . METRIC_LOG_FILE ) ; config . train_mem_log_file = props . getProperty ( Constants . TRAIN_MEM_LOG_FILE ) ; config . train_metric_log_file = props . getProperty ( Constants . TRAIN_METRIC_LOG_FILE ) ; config . dotest = Integer . parseInt ( props . getProperty ( Constants . DO_TEST ) ) ; config . vm_name = props . getProperty ( Constants . VM_NAME ) ; config . predictFile = props . getProperty ( Constants . PREDICT_FILE ) ; config . annotateFile = props . getProperty ( Constants . ANN_FILE ) ; config . faultInterval = Integer . parseInt ( props . getProperty ( Constants . FAULT ) ) ; } catch ( FileNotFoundException e ) { logger . error ( "Error while opening configuration file" ) ; } catch ( IOException e ) { logger . error ( "Error while loading configuration file" ) ; } }
tr	6	private static int maxProduct ( int [ ] array ) { if ( array . length == 1 ) { return array [ 0 ] ; } int negativeCount = 0 ; int largestNegative = 0 ; int max = 1 ; for ( int i = 0 ; i < array . length ; i ++ ) { if ( array [ i ] == 0 ) { continue ; } if ( array [ i ] < 0 ) { negativeCount ++ ; if ( largestNegative == 0 ) { largestNegative = array [ i ] ; } else { largestNegative = Math . max ( array [ i ] , largestNegative ) ; } } max *= array [ i ] ; } if ( negativeCount % 2 != 0 ) { max /= largestNegative ; } return max ; }
tr	7	public static void validateMetadata ( OSGiMetaData metadata ) throws BundleException { NotNullException . assertValue ( metadata , "metadata" ) ; try { int manifestVersion = getBundleManifestVersion ( metadata ) ; if ( manifestVersion < 0 ) throw new BundleException ( "Cannot determine Bundle-ManifestVersion" ) ; if ( manifestVersion > 2 ) throw new BundleException ( "Unsupported Bundle-ManifestVersion: " + manifestVersion ) ; String symbolicName = metadata . getBundleSymbolicName ( ) ; if ( manifestVersion == 1 && symbolicName != null ) throw new BundleException ( "Invalid Bundle-ManifestVersion for: " + symbolicName ) ; if ( manifestVersion == 2 && symbolicName == null ) throw new BundleException ( "Cannot obtain Bundle-SymbolicName" ) ; } catch ( RuntimeException ex ) { throw new BundleException ( "Invalid OSGi metadata" , ex ) ; } }
tr	5	public void run ( ) { while ( m_bKeepRunning ) { if ( ! m_bMpegPlaying ) { try { new Thread ( ) { public void run ( ) { m_mpegControl . start ( ) ; } } . start ( ) ; m_bMpegPlaying = true ; } catch ( MpegDecodeException e ) { showDialog ( ERROR , e . getMessage ( ) ) ; } } else { try { sleep ( 100 ) ; } catch ( InterruptedException e ) { } } } try { m_mpegControl . stopPlaying ( ) ; } catch ( MpegDecodeException e ) { showDialog ( WARNING , e . getMessage ( ) ) ; } }
tr	6	public String nextString ( char quote ) throws JSONException { StringBuilder builder = null ; int start = pos ; while ( pos < in . length ( ) ) { int c = in . charAt ( pos ++ ) ; if ( c == quote ) { if ( builder == null ) { return new String ( in . substring ( start , pos - 1 ) ) ; } else { builder . append ( in , start , pos - 1 ) ; return builder . toString ( ) ; } } if ( c == \ ) { if ( pos == in . length ( ) ) { throw syntaxError ( "Unterminated escape sequence" ) ; } if ( builder == null ) { builder = new StringBuilder ( ) ; } builder . append ( in , start , pos - 1 ) ; builder . append ( readEscapeCharacter ( ) ) ; start = pos ; } } throw syntaxError ( "Unterminated string" ) ; }
tr	0	public void actionPerformed ( ActionEvent event ) { Main . newSet ( ) ; }
tr	0	public static void main ( String [ ] args ) { float x = 1.3f ; float y = 1.8f ; System . out . println ( ( int ) ( x + y ) ) ; System . out . println ( ( int ) x + ( int ) y ) ; }
tr	2	public static String getUserMessage ( int statusCode ) { if ( statusCode == Response . SC_SERVICE_UNAVAILABLE ) { return "Pearltrees is currently unavailable. Please retry later." ; } if ( statusCode == Response . SC_SEE_OTHER ) { return "Please enable cookies to use the bookmarklet." ; } return "Pearltrees is currently unreachable. Please check your internet connection or retry later." ; }
tr	3	private void clickedChangeType ( ) { if ( cmbType . getSelectedItem ( ) . equals ( "simple" ) ) type = Phrase . Type . simple ; else if ( cmbType . getSelectedItem ( ) . equals ( "conjugation" ) ) type = Phrase . Type . conjugation ; else if ( cmbType . getSelectedItem ( ) . equals ( "number" ) ) type = Phrase . Type . number ; updateLayout ( ) ; }
tr	4	private Mappable convertMappable ( Properties props , Map map , int i ) throws NoSuchMethodException , ClassNotFoundException , InstantiationException , IllegalAccessException , InvocationTargetException { String objPrefix = MAPOBJECT_PREFIX + SEP + i + SEP ; String className = props . getProperty ( objPrefix + ConfigurableProperties . class ) ; int x = getPropAsInt ( props , objPrefix + POS_X , 100 ) ; int y = getPropAsInt ( props , objPrefix + POS_Y , 100 ) ; String id = props . getProperty ( objPrefix + ID ) ; double angle = getPropAsDouble ( props , objPrefix + POS_ANGLE , 0.0 ) ; Constructor < ? > constructor = class . forName ( className ) . getConstructor ( MAPOBJ_PARAMS ) ; Mappable mappable = ( Mappable ) constructor . newInstance ( new Object [ ] { map , new Integer ( x ) , new Integer ( y ) } ) ; mappable . setAngle ( angle ) ; if ( id != null ) { mappable . setId ( id ) ; } List < ConfigurableProperties > list = mappable . getConfigurableProperties ( ) ; for ( ConfigurableProperties key : list ) { String val = props . getProperty ( objPrefix + key ) ; val = addHomeDir ( val ) ; if ( val != null ) { mappable . setConfiguredValue ( key , val ) ; } } return mappable ; }
tr	5	public void updateItem ( PosListaPrecio itemOracle , int idPos ) { if ( itemOracle . getPcaIdElemento ( ) != null ) { PhpposItemsEntity itemPos = getItemPos ( itemOracle . getPcaIdElemento ( ) ) ; if ( itemPos != null ) { Session hbSession = getSession ( ) ; Transaction ts = hbSession . beginTransaction ( ) ; itemPos . setName ( itemOracle . getPcaDescripcion ( ) ) ; itemPos . setDescription ( itemOracle . getPcaDescripcion ( ) ) ; itemPos . setQuantity ( itemPos . getQuantity ( ) + itemOracle . getPcaCantidad ( ) ) ; itemPos . setCostPrice ( itemOracle . getPcaPrecioVenta ( ) ) ; itemPos . setUnitPrice ( itemOracle . getPcaPrecioVenta ( ) ) ; getHibernateTemplate ( ) . update ( itemPos ) ; boolean successMySQL = false ; boolean successOracle = false ; try { successOracle = facOracleDAO . updatePosListaPrecioCeroA ( itemOracle ) ; successMySQL = true ; } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { if ( successMySQL && successOracle ) { ts . commit ( ) ; hbSession . flush ( ) ; hbSession . close ( ) ; saveLogEntrada ( itemOracle , "U" , idPos ) ; logger . info ( " " ) ; logger . info ( " ========  ITEM ACTUALIZADO  =========================== " ) ; logger . info ( "itemPos.getItemId() = " + itemPos . getItemId ( ) ) ; logger . info ( "itemPos.getDescription() = " + itemPos . getDescription ( ) ) ; logger . info ( "itemPos.getUnitPrice() = " + itemPos . getUnitPrice ( ) ) ; logger . info ( "itemPos.getQuantity() = " + itemPos . getQuantity ( ) ) ; logger . info ( " ======================================================= " ) ; logger . info ( " " ) ; } else { ts . rollback ( ) ; hbSession . flush ( ) ; hbSession . close ( ) ; } } } else { logger . info ( " ========  ITEM CON PROBLEMAS DE UPDATE  =============== " ) ; logger . info ( " ========  NO EXISTE ITEM EN EL POS CON: =============== " ) ; logger . info ( "itemOracle.getPcaIdElemento() = " + itemOracle . getPcaIdElemento ( ) ) ; logger . info ( "itemOracle.getPcaDescripcion() = " + itemOracle . getPcaDescripcion ( ) ) ; logger . info ( "itemOracle.getPcaPosId() = " + itemOracle . getPcaPosId ( ) ) ; logger . info ( "idPos = " + idPos ) ; logger . info ( " ======================================================= " ) ; } } else { logger . info ( " ========  ITEM CON getPcaIdElemento NULL  ============= " ) ; logger . info ( "itemOracle.getPcaIdElemento() = " + itemOracle . getPcaIdElemento ( ) ) ; logger . info ( "itemOracle.getPcaDescripcion() = " + itemOracle . getPcaDescripcion ( ) ) ; logger . info ( "itemOracle.getPcaPosId() = " + itemOracle . getPcaPosId ( ) ) ; logger . info ( "idPos = " + idPos ) ; logger . info ( " ======================================================= " ) ; } }
tr	2	private byte getFlags ( ) { byte b = 0 ; if ( isRoot ) { b |= 01 ; } if ( isOrdered ) { b |= 02 ; } return b ; }
tr	9	public Matrix solve ( Matrix B ) { if ( B . getRowDimension ( ) != m ) { throw new IllegalArgumentException ( "Matrix row dimensions must agree." ) ; } if ( ! this . isNonsingular ( ) ) { throw new RuntimeException ( "Matrix is singular." ) ; } int nx = B . getColumnDimension ( ) ; Matrix Xmat = B . getMatrix ( piv , 0 , nx - 1 ) ; double [ ] [ ] X = Xmat . getArray ( ) ; for ( int k = 0 ; k < n ; k ++ ) { for ( int i = k + 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < nx ; j ++ ) { X [ i ] [ j ] -= X [ k ] [ j ] * LU [ i ] [ k ] ; } } } for ( int k = n - 1 ; k >= 0 ; k -- ) { for ( int j = 0 ; j < nx ; j ++ ) { X [ k ] [ j ] /= LU [ k ] [ k ] ; } for ( int i = 0 ; i < k ; i ++ ) { for ( int j = 0 ; j < nx ; j ++ ) { X [ i ] [ j ] -= X [ k ] [ j ] * LU [ i ] [ k ] ; } } } return Xmat ; }
