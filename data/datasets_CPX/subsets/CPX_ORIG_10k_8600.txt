te	9	private String getText ( HttpURLConnection conn , boolean is_head_method ) throws IOException { String text = "" ; _file_type = null ; InputStream is = null ; InputStreamReader sr = null ; BufferedReader br = null ; try { if ( conn . getResponseCode ( ) >= 400 ) { is = conn . getErrorStream ( ) ; } else { is = conn . getInputStream ( ) ; } if ( ! is_head_method ) { sr = new InputStreamReader ( is ) ; br = new BufferedReader ( sr ) ; String line = br . readLine ( ) ; while ( line != null ) { text += "\n" + line ; line = br . readLine ( ) ; } } if ( conn . getResponseCode ( ) == 200 && conn . getHeaderField ( "x-upyun-width" ) != null ) { _iwidth = conn . getHeaderField ( "x-upyun-width" ) ; _iheight = conn . getHeaderField ( "x-upyun-height" ) ; _iframes = conn . getHeaderField ( "x-upyun-frames" ) ; _itype = conn . getHeaderField ( "x-upyun-file-type" ) ; } else { _iwidth = null ; _iheight = null ; _iframes = null ; _itype = null ; } if ( conn . getResponseCode ( ) == 200 && conn . getHeaderField ( "x-upyun-file-type" ) != null ) { _file_type = conn . getHeaderField ( "x-upyun-file-type" ) ; _file_size = conn . getHeaderField ( "x-upyun-file-size" ) ; _file_date = conn . getHeaderField ( "x-upyun-file-date" ) ; } else { _file_type = null ; _file_size = null ; _file_date = null ; } } finally { if ( br != null ) { br . close ( ) ; } if ( sr != null ) { sr . close ( ) ; } if ( is != null ) { is . close ( ) ; } } if ( is_head_method ) { if ( conn . getResponseCode ( ) >= 400 ) return null ; return "" ; } if ( conn . getResponseCode ( ) >= 400 ) throw new IOException ( text ) ; return text ; }
te	2	public static boolean isUserLevelMethod ( Method method ) { assert . notNull ( method , "Method must not be null" ) ; return ( method . isBridge ( ) || ( ! method . isSynthetic ( ) && ! isGroovyObjectMethod ( method ) ) ) ; }
te	7	@ Override public boolean put ( K key , V value ) { if ( key == null ) { throw new IllegalArgumentException ( "key was null" ) ; } if ( value == null ) { throw new IllegalArgumentException ( "value was null" ) ; } int offset = offset ( key ) ; int reprobes = 0 ; while ( keys [ offset ] != null && keys [ offset ] != Tombstone ) { if ( keys [ offset ] . equals ( key ) ) { if ( values [ offset ] == value ) { return false ; } else { values [ offset ] = value ; return true ; } } offset = nextHop ( offset ) ; if ( offset == offset ( key ) ) { return false ; } reprobes ++ ; } increaseSize ( ) ; keys [ offset ] = key ; values [ offset ] = value ; checkResize ( reprobes ) ; return true ; }
te	6	@ Override public String toString ( ) { String ret = image ; if ( tics > 1 ) ret += " (tics: " + tics + ")" ; if ( ! tag . isEmpty ( ) ) ret += " (tag: " + tag + ")" ; if ( ! next . isEmpty ( ) ) ret += " (next: " + next + ")" ; if ( offsetX != 0 ) ret += " (offsetX: " + offsetX + ")" ; if ( offsetY != 0 ) ret += " (offsetY: " + offsetY + ")" ; if ( ! event . isEmpty ( ) ) ret += " (event: " + event + ")" ; return ret ; }
te	9	public void draw ( Graphics2D g , Rectangle2D rect , boolean highlight ) { Random rnd = new Random ( hashCode ( ) ) ; double radius = rect . getWidth ( ) / getSize ( ) / 10 ; int coins = fWorth / 4 ; for ( int index = 0 ; index != coins ; ++ index ) { double x = ( rnd . nextDouble ( ) * rect . getWidth ( ) ) + rect . getX ( ) - radius ; double y = ( rnd . nextDouble ( ) * rect . getHeight ( ) ) + rect . getY ( ) - radius ; Ellipse2D coin_rect = new Ellipse2D . double ( x , y , radius * 2 , radius * 2 ) ; Color c = null ; int n = rnd . nextInt ( 10 ) ; switch ( n ) { case 0 : case 1 : case 2 : case 3 : case 4 : case 5 : case 6 : c = Color . YELLOW ; break ; case 7 : case 8 : c = Color . LIGHT_GRAY ; break ; case 9 : c = Color . ORANGE . darker ( ) ; break ; } g . setColor ( c ) ; g . fill ( coin_rect ) ; g . setColor ( c . darker ( ) ) ; g . draw ( coin_rect ) ; } }
te	1	public void tick ( ) { if ( absorbs < presses ) { absorbs ++ ; clicked = true ; } else { clicked = false ; } }
te	5	private void registerPermissions ( ) { this . getServer ( ) . getScheduler ( ) . scheduleSyncDelayedTask ( this , new Runnable ( ) { public void run ( ) { PluginManager pm = instance . getServer ( ) . getPluginManager ( ) ; Map < String , boolean > children = new HashMap < String , boolean > ( ) ; Map < Spell . Type , Permission > types = new HashMap < Spell . Type , Permission > ( ) ; Map < Spell . Type , Map < String , boolean >> typeChildren = new HashMap < Spell . Type , Map < String , boolean >> ( ) ; for ( Spell spell : Spell . values ( ) ) { Map < String , boolean > spellTypeChildren = typeChildren . get ( spell . getType ( ) ) ; if ( spellTypeChildren == null ) { typeChildren . put ( spell . getType ( ) , spellTypeChildren = new HashMap < String , boolean > ( ) ) ; } pm . addPermission ( new Permission ( spell . getPermission ( ) , spell . getDescription ( ) ) ) ; spellTypeChildren . put ( spell . getPermission ( ) , true ) ; } for ( Spell . Type type : Spell . Type . values ( ) ) { String permName = "merlin.cast." + type . toString ( ) . toLowerCase ( ) + ".*" ; Permission perm = new Permission ( permName , "Gives access to all " + type . getName ( ) + " spells" , typeChildren . get ( type ) ) ; types . put ( type , perm ) ; pm . addPermission ( perm ) ; children . put ( permName , true ) ; } pm . addPermission ( new Permission ( "merlin.cast.*" , "Gives access to all spells" , children ) ) ; Permission standard = null ; for ( Permission perm : instance . getDescription ( ) . getPermissions ( ) ) { if ( perm . getName ( ) . equals ( "merlin.standard" ) ) { standard = perm ; break ; } } standard . getChildren ( ) . put ( "merlin.cast.*" , true ) ; standard . recalculatePermissibles ( ) ; pm . removePermission ( standard ) ; pm . addPermission ( standard ) ; } } ) ; }
te	4	public int compareTo ( final Object o ) { if ( ! ( o instanceof OtpErlangPid ) ) { return - 1 ; } final OtpErlangPid pid = ( OtpErlangPid ) o ; if ( creation == pid . creation ) { if ( serial == pid . serial ) { if ( id == pid . id ) { return node . compareTo ( pid . node ) ; } else { return id - pid . id ; } } else { return serial - pid . serial ; } } else { return creation - pid . creation ; } }
te	6	public static Building get_building ( String symbol , Board board , Player owner , Position position ) { switch ( symbol ) { case "AP" : return new Airport ( board , owner , position ) ; case "BS" : return new Base ( board , owner , position ) ; case "PT" : return new Port ( board , owner , position ) ; case "CT" : return new City ( board , owner , position ) ; case "HQ" : return new Headquarter ( board , owner , position ) ; case "--" : return null ; default : throw new IllegalArgumentException ( "[Building.get_building] unable to parse symbol input (" + symbol + ")" ) ; } }
te	9	public boolean passParent ( Point p1 , Point p2 ) { Component e = getParent ( ) ; int x = e . getX ( ) - e . getHeight ( ) / 4 ; int y = e . getY ( ) - e . getHeight ( ) / 4 ; int width = e . getWidth ( ) + e . getHeight ( ) / 2 ; int height = e . getHeight ( ) + e . getHeight ( ) / 2 ; if ( p1 . x == p2 . x ) { int miny = Math . min ( p1 . y , p2 . y ) ; int maxy = Math . max ( p1 . y , p2 . y ) ; return ( p1 . x > x && p1 . x < x + width ) && ( miny < y && maxy > y + height || miny > y && miny < y + height || maxy >= y && maxy < y + height ) ; } else { int minx = Math . min ( p1 . x , p2 . x ) ; int maxx = Math . max ( p1 . x , p2 . x ) ; return ( p1 . y > y && p1 . y < y + height ) && ( minx < x && maxx > x + width || minx > x && minx < x + width || maxx > x && maxx < x + width ) ; } }
te	8	@ Override public double [ ] GetDiscreteFunction ( double [ ] x , double [ ] paramsMF ) { if ( this . paramsMF . length == paramsMF . length ) this . paramsMF = paramsMF ; else return null ; int n = x . length ; double [ ] func = new double [ n ] ; double a = paramsMF [ 0 ] , b = paramsMF [ 1 ] , c = paramsMF [ 2 ] , d = paramsMF [ 3 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( x [ i ] < a ) { func [ i ] = new double ( 0 ) ; } else if ( x [ i ] < ( ( a + b ) / 2.0 ) ) { func [ i ] = 2.0 * Math . pow ( ( x [ i ] - a ) / ( b - a ) , 2 ) ; } else if ( x [ i ] < b ) { func [ i ] = 1 - 2.0 * Math . pow ( ( x [ i ] - b ) / ( b - a ) , 2 ) ; } else if ( x [ i ] < c ) { func [ i ] = new double ( 1 ) ; } else if ( x [ i ] < ( c + d ) / 2.0 ) { func [ i ] = 1 - 2.0 * Math . pow ( ( x [ i ] - c ) / ( d - c ) , 2 ) ; } else if ( x [ i ] < d ) { func [ i ] = 2.0 * Math . pow ( ( x [ i ] - d ) / ( d - c ) , 2 ) ; } else func [ i ] = new double ( 0 ) ; } return func ; }
te	5	private void createNodes ( DefaultMutableTreeNode top ) { DefaultMutableTreeNode generalForums = null ; DefaultMutableTreeNode category = null ; DefaultMutableTreeNode subCategory = null ; DefaultMutableTreeNode question = null ; generalForums = new DefaultMutableTreeNode ( "General Forums" ) ; top . add ( generalForums ) ; DatabaseConnection db = new DatabaseConnection ( ) ; Connection conn = db . connectToDB ( ) ; String sql = "SELECT * FROM `ForumCategories`" ; ResultSet rs = db . getResults ( conn , sql ) ; int categoryID = 0 ; int subCategoryID = 0 ; try { while ( rs . next ( ) ) { category = new DefaultMutableTreeNode ( rs . getString ( "Name" ) ) ; generalForums . add ( category ) ; categoryID = rs . getInt ( "CategoryID" ) ; String subSQL = "SELECT * FROM `ForumSubCategories` WHERE CategoryID = '" + categoryID + "'" ; ResultSet subRS = db . getResults ( conn , subSQL ) ; while ( subRS . next ( ) ) { subCategory = new DefaultMutableTreeNode ( subRS . getString ( "Name" ) ) ; category . add ( subCategory ) ; subCategoryID = subRS . getInt ( "SubCategoryID" ) ; String questionSQL = "SELECT * FROM `ForumQuestions` " + "WHERE SubCategoryID = '" + subCategoryID + "'" ; if ( userType == 1 ) { questionSQL += " and (Visibility = 0 or Author='" + userID + "')" ; } ResultSet questionRS = db . getResults ( conn , questionSQL ) ; while ( questionRS . next ( ) ) { String questionTitle = questionRS . getString ( "QuestionTitle" ) ; String questionContent = questionRS . getString ( "Question" ) ; int questionID = questionRS . getInt ( "QuestionID" ) ; question = new DefaultMutableTreeNode ( new BookInfo ( questionTitle , questionContent , questionID , 1 ) ) ; subCategory . add ( question ) ; getAnswers ( db , conn , question , questionID ) ; } } } } catch ( SQLException ex ) { Logger . getLogger ( HelpDeskMainFrame . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } }
te	8	public void update ( ) { int num = buttonSelected ( ) ; if ( scrollUp != null && scrollUp . getIndex ( ) == num ) scrollUp ( ) ; if ( scrollDown != null && scrollDown . getIndex ( ) == num ) scrollDown ( ) ; if ( accept != null && accept . getIndex ( ) == num ) add ( ) ; if ( reject != null && reject . getIndex ( ) == num ) remove ( ) ; }
te	3	CachedCombinationFactory ( long mod , int n ) { assert mod > n ; this . mod = mod ; this . n = n ; comb = new long [ n ] [ n ] ; comb [ 0 ] [ 0 ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) { comb [ i ] [ 0 ] = 1 ; } for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 1 ; j <= i ; j ++ ) { comb [ i ] [ j ] = ( comb [ i - 1 ] [ j - 1 ] + comb [ i - 1 ] [ j ] ) % mod ; } } }
te	9	private Address createAddress ( Element address ) { NodeList streetList = address . getElementsByTagName ( "street" ) ; NodeList cityList = address . getElementsByTagName ( "city" ) ; NodeList stateList = address . getElementsByTagName ( "state" ) ; NodeList postal_codeList = address . getElementsByTagName ( "postal_code" ) ; NodeList countryList = address . getElementsByTagName ( "country" ) ; if ( streetList == null || streetList . getLength ( ) != 1 || cityList == null || cityList . getLength ( ) != 1 || stateList == null || stateList . getLength ( ) != 1 || postal_codeList == null || postal_codeList . getLength ( ) != 1 || countryList == null || countryList . getLength ( ) != 1 ) { return null ; } Node streetNode = streetList . item ( 0 ) ; Node cityNode = cityList . item ( 0 ) ; Node stateNode = stateList . item ( 0 ) ; Node postal_codeNode = postal_codeList . item ( 0 ) ; Node countryNode = countryList . item ( 0 ) ; if ( streetNode . getNodeType ( ) != Node . ELEMENT_NODE || cityNode . getNodeType ( ) != Node . ELEMENT_NODE || stateNode . getNodeType ( ) != Node . ELEMENT_NODE || postal_codeNode . getNodeType ( ) != Node . ELEMENT_NODE || countryNode . getNodeType ( ) != Node . ELEMENT_NODE ) { return null ; } Element street = ( Element ) streetNode ; Element city = ( Element ) cityNode ; Element state = ( Element ) stateNode ; Element postal_code = ( Element ) postal_codeNode ; Element country = ( Element ) countryNode ; return new Address ( street . getTextContent ( ) , city . getTextContent ( ) , state . getTextContent ( ) , country . getTextContent ( ) , postal_code . getTextContent ( ) ) ; }
te	9	public void run ( ) { label . setIcon ( new ImageIcon ( image ) ) ; }
te	2	public void displayBoard ( ) { for ( int i = 0 ; i < getBoard ( ) . length ; i ++ ) { System . out . println ( ) ; for ( int j = 0 ; j < getBoard ( ) . length ; j ++ ) { System . out . print ( getBoard ( ) [ i ] [ j ] ) ; } } }
te	1	@ BeforeClass public static void setUpBeforeClass ( ) throws Exception { helper = JedisHelper . getInstance ( ) ; for ( int i = 0 ; i < POSTLIST . length ; i ++ ) { POSTLIST [ i ] = String . valueOf ( i + 1 ) ; } }
te	9	private void SystemSanitisation ( ) throws InconsistentLinearSystemException { rowsToSkip = new HashSet < Integer > ( ) ; columnsToSkip = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( b [ i ] . isUndefined ( ) ) { rowsToSkip . add ( i ) ; } } for ( Integer i : rowsToSkip ) { for ( int j = 0 ; j < N ; j ++ ) { if ( ! columnsToSkip . contains ( j ) ) { if ( ! A [ i ] [ j ] . isZero ( ) ) { BigRational sum = BigRational . ZERO ; for ( int k = 0 ; k < N ; k ++ ) { if ( ! rowsToSkip . contains ( k ) && k != j ) { sum = sum . add ( A [ k ] [ j ] . abs ( ) ) ; } } if ( sum . isZero ( ) ) { columnsToSkip . add ( j ) ; } } } } } columnsToSkip . addAll ( uncomputables ) ; if ( rowsToSkip . size ( ) > columnsToSkip . size ( ) ) { throw new InconsistentLinearSystemException ( "Singular system. Cannot proceed." ) ; } }
te	9	public void yVerif ( boolean left , boolean right , boolean current , boolean add ) { if ( mouse . y < 0 ) { if ( current ) { cAround [ 7 ] . choose ( mouse . x / tailleCase , ( mouse . y + 608 ) / tailleCase , inv , add ) ; } else if ( left ) { cAround [ 6 ] . choose ( ( mouse . x + 1200 ) / tailleCase , ( mouse . y + 608 ) / tailleCase , inv , add ) ; } else if ( right ) { cAround [ 8 ] . choose ( ( mouse . x - 1200 ) / tailleCase , ( mouse . y + 608 ) / tailleCase , inv , add ) ; } else { System . out . println ( "error when verifying height" ) ; } } else if ( mouse . y / tailleCase >= const . tailleChunkY ) { if ( current ) { cAround [ 1 ] . choose ( mouse . x / tailleCase , ( mouse . y - 608 ) / tailleCase , inv , add ) ; } else if ( left ) { cAround [ 0 ] . choose ( ( mouse . x + 1200 ) / tailleCase , ( mouse . y - 608 ) / tailleCase , inv , add ) ; } else if ( right ) { cAround [ 2 ] . choose ( ( mouse . x - 1200 ) / tailleCase , ( mouse . y - 608 ) / tailleCase , inv , add ) ; } else { System . out . println ( "error when verifying height" ) ; } } else { if ( current ) { currentChunk . choose ( mouse . x / tailleCase , mouse . y / tailleCase , inv , add ) ; } else if ( left ) { cAround [ 3 ] . choose ( ( mouse . x + 1200 ) / tailleCase , mouse . y / tailleCase , inv , add ) ; } else if ( right ) { cAround [ 5 ] . choose ( ( mouse . x - 1200 ) / tailleCase , mouse . y / tailleCase , inv , add ) ; } else { System . out . println ( "error when verifying height" ) ; } } }
te	4	private void terminar_ActionPerformed ( ) { if ( detalleVentaTableItemList . size ( ) == 0 ) { JOptionPane . showMessageDialog ( FramePrincipalControl . getInstance ( ) . getFramePrincipal ( ) , "Cuando termine de agregar m\u00E1s productos  podra terminar esta venta" , "Terminar Venta" , JOptionPane . WARNING_MESSAGE ) ; panelVenta . getCodigoBuscar ( ) . requestFocus ( ) ; return ; } try { final Venta venta = new Venta ( 0 , new Date ( ) ) ; final List < DetalleVenta > detalleVentaList = new ArrayList < DetalleVenta > ( ) ; for ( DetalleVentaTableItem dvil : detalleVentaTableItemList ) { detalleVentaList . add ( new DetalleVenta ( 0 , 0 , dvil . getCodigo ( ) , dvil . getCantidad ( ) , dvil . getPrecioVenta ( ) ) ) ; } ventaDAO . persist ( venta , detalleVentaList ) ; JOptionPane . showMessageDialog ( FramePrincipalControl . getInstance ( ) . getFramePrincipal ( ) , "Se guardo Correctamente  ...Imprimiendo ticket" , "Venta" , JOptionPane . INFORMATION_MESSAGE ) ; if ( ApplicationLogic . getInstance ( ) . isPrintingEnabled ( ) ) { new Thread ( ) { @ Override public void run ( ) { imprimirTicket ( venta , detalleVentaList ) ; } } . start ( ) ; } estadoInicial ( ) ; } catch ( EntidadExistenteException ex ) { ex . printStackTrace ( System . err ) ; JOptionPane . showMessageDialog ( FramePrincipalControl . getInstance ( ) . getFramePrincipal ( ) , ex . getMessage ( ) , "Venta" , JOptionPane . ERROR_MESSAGE ) ; } finally { panelVenta . getCodigoBuscar ( ) . requestFocus ( ) ; } }
te	4	@ Override public String toString ( ) { String s = "" ; for ( AbstractNode c : con ) { s += c . toString ( ) + "\n" ; } for ( AbstractNode c : type ) { s += c . toString ( ) + "\n" ; } for ( AbstractNode c : var ) { s += c . toString ( ) + "\n" ; } for ( AbstractNode c : proc ) { s += c . toString ( ) + "\n" ; } return indent ( ) + "DeclarationsNode\n" + s + unindent ( ) ; }
te	9	private static void buildTypeVariableMap ( ParameterizedType type , Map < TypeVariable < ? > , Type > typeVariableMap ) { if ( type . getRawType ( ) instanceof class ) { TypeVariable < ? > [ ] typeVariables = ( ( class < ? > ) type . getRawType ( ) ) . getTypeParameters ( ) ; Type [ ] typeArguments = type . getActualTypeArguments ( ) ; for ( int i = 0 ; i < typeArguments . length ; i ++ ) { TypeVariable < ? > variable = typeVariables [ i ] ; Type typeArgument = typeArguments [ i ] ; if ( typeArgument instanceof class ) { typeVariableMap . put ( variable , typeArgument ) ; } else if ( typeArgument instanceof GenericArrayType ) { typeVariableMap . put ( variable , typeArgument ) ; } else if ( typeArgument instanceof ParameterizedType ) { typeVariableMap . put ( variable , typeArgument ) ; } else if ( typeArgument instanceof TypeVariable ) { TypeVariable < ? > typeVariableArgument = ( TypeVariable < ? > ) typeArgument ; Type resolvedType = typeVariableMap . get ( typeVariableArgument ) ; if ( resolvedType == null ) resolvedType = resolveBound ( typeVariableArgument ) ; typeVariableMap . put ( variable , resolvedType ) ; } } } }
te	4	public GameVector GetRandomVector ( BufferedImage Image ) { byte xIndex = ( byte ) ( this . xVectorMinimum - 1 ) ; byte yIndex = ( byte ) ( this . xVectorMinimum - 1 ) ; while ( xIndex < this . xVectorMinimum || xIndex > this . xVectorMaximum ) xIndex = ( byte ) ( new Random ( ) . nextInt ( this . xVectorMaximum ) + 1 ) ; while ( yIndex < this . yVectorMinimum || yIndex > this . yVectorMaximum ) yIndex = ( byte ) ( new Random ( ) . nextInt ( this . yVectorMaximum ) + 1 ) ; return new GameVector ( xIndex , yIndex , Image ) ; }
te	5	private void merge ( ) { ClusterPair toMerge = mergeQueue . poll ( ) ; Iterator < ClusterPair > it = mergeQueue . iterator ( ) ; ClusterPair pair ; while ( it . hasNext ( ) ) { pair = it . next ( ) ; if ( pair . getID1 ( ) == toMerge . getID1 ( ) || pair . getID1 ( ) == toMerge . getID2 ( ) || pair . getID2 ( ) == toMerge . getID1 ( ) || pair . getID2 ( ) == toMerge . getID2 ( ) ) { it . remove ( ) ; } } AccessionCluster merged = clusters . remove ( toMerge . getID1 ( ) ) ; AccessionCluster clust2 = clusters . remove ( toMerge . getID2 ( ) ) ; merged . merge ( clust2 ) ; updateMergeQueue ( merged ) ; clusters . put ( merged . id ( ) , merged ) ; }
te	8	private void registerEventAndStatement ( Map < String , Object > input , final Output < Map < String , Object >> mapOutput ) { Properties type = new Properties ( ) ; for ( Map . Entry < String , Object > entry : input . entrySet ( ) ) { type . put ( entry . getKey ( ) , entry . getValue ( ) . getClass ( ) . getName ( ) ) ; } provider . getEPAdministrator ( ) . getConfiguration ( ) . addEventType ( "S" , type ) ; provider . getEPAdministrator ( ) . getConfiguration ( ) . addImport ( Elf . class . getPackage ( ) . getName ( ) + ".*" ) ; stmtModel = provider . getEPAdministrator ( ) . compileEPL ( query ) ; statement = provider . getEPAdministrator ( ) . create ( stmtModel ) ; statement . addListener ( new UpdateListener ( ) { public void update ( EventBean [ ] inserts , EventBean [ ] removes ) { try { if ( first > 0 ) { int max = Math . min ( first , inserts . length ) ; for ( int i = 0 ; i < max ; i ++ ) { mapOutput . output ( toMap ( inserts [ i ] ) ) ; } } else if ( last > 0 ) { int min = Math . max ( 0 , inserts . length - last ) ; for ( int i = min ; i < inserts . length ; i ++ ) { mapOutput . output ( toMap ( inserts [ i ] ) ) ; } } else { for ( EventBean insert : inserts ) { mapOutput . output ( toMap ( insert ) ) ; } } if ( update ) { outputWrapper . flush ( ) ; } } catch ( IOException e ) { e . printStackTrace ( ) ; } } } ) ; extractGroupBy ( ) ; }
te	3	public static String toStringInteger ( String buffer ) { String returnValue = buffer ; int i = returnValue . length ( ) - 1 ; while ( ( i >= 0 ) && ( returnValue . charAt ( i ) != . ) ) { i -- ; } if ( i > 0 ) returnValue = returnValue . substring ( 0 , i ) ; return returnValue ; }
te	2	public void run ( ) { try { mServerSocket = new DatagramSocket ( mServerPort ) ; new Thread ( new MessageSanitizer ( ) ) . start ( ) ; new Thread ( new ClientDisconnector ( ) ) . start ( ) ; byte [ ] buffer ; DatagramPacket p ; while ( ! mServerDisconnected ) { buffer = new byte [ 256 ] ; p = new DatagramPacket ( buffer , buffer . length ) ; mServerSocket . receive ( p ) ; AddMessage ( new String ( buffer ) , p . getAddress ( ) , p . getPort ( ) , mUnsanitizedMessages ) ; } } catch ( Exception e ) { mServerDisconnected = true ; } mServerSocket . close ( ) ; }
te	6	private List < String > concatQuestionsInclass ( List < QuestionInfo > questions , String queryType , boolean isSubType ) { List < String > terms = new ArrayList < String > ( ) ; for ( QuestionInfo question : questions ) { boolean concat = false ; if ( isSubType ) { if ( question . getQuerySubType ( ) . toString ( ) . equals ( queryType ) ) { concat = true ; } } else { if ( question . getQueryType ( ) . toString ( ) . equals ( queryType ) ) { concat = true ; } } if ( concat ) { for ( QueryTerm term : question . getQuestionTerms ( ) ) { terms . add ( term . getText ( ) ) ; } } } return terms ; }
te	9	@ Override public void onPaint ( DrawingInterface g , int width , int height ) { if ( ! visible ) return ; int img ; if ( active == 1 ) img = Comm . R_ARR_L_ON ; else img = Comm . R_ARR_L_OFF ; if ( enabled ) g . gStretchAlignBitmap ( getX ( ) , getY ( ) , Dim . W ( 0.1 * w ) , Dim . H ( h ) , Dim . W ( 0.09 * w ) , Dim . H ( h * 0.95 ) , CrossRes . GUI [ img ] , Comm . STRETCH_V_PROP , Comm . ALIGN_VCENTER ) ; if ( active == 2 ) img = Comm . R_ARR_R_ON ; else img = Comm . R_ARR_R_OFF ; if ( enabled ) g . gStretchAlignBitmap ( getX ( ) + Dim . W ( 0.9 * w ) , getY ( ) , Dim . W ( 0.1 * w ) , Dim . H ( h ) , Dim . W ( 0.09 * w ) , Dim . H ( h * 0.95 ) , CrossRes . GUI [ img ] , Comm . STRETCH_V_PROP , Comm . ALIGN_RIGHT | Comm . ALIGN_VCENTER ) ; g . gSetFontName ( Skin . FONT ) ; if ( active != 0 ) { g . gSetColor ( Skin . BUTTON_ON ) ; } else g . gSetColor ( Skin . BCG_L_TEXT ) ; String text ; if ( selected < 0 || selected >= options . size ( ) ) { text = Str . get ( Str . LIST_CHOOSE ) ; if ( active == 0 ) g . gSetColor ( Colors . RGB ( 180 , 180 , 180 ) ) ; } else { if ( langable ) text = Str . get ( options . get ( selected ) ) ; else text = options . get ( selected ) [ 0 ] ; } if ( maxCharacters > 0 ) { if ( text . length ( ) > maxCharacters ) { text = text . substring ( 0 , text . length ( ) - 3 ) ; text = text + "..." ; } } g . gSetFontSize ( text , Dim . W ( w * 0.7 ) , Dim . H ( h ) ) ; if ( ! enabled ) g . gSetColor ( g . gGetColor ( ) , 80 ) ; g . gDrawText ( getX ( ) + Dim . W ( 0.1 * w ) , getY ( ) , Dim . W ( w * 0.8 , minX ) , Dim . H ( h , minY ) , text , Comm . ALIGN_CENTER | Comm . ALIGN_VCENTER ) ; if ( showProgress ) { g . gSetColor ( Skin . BCG_D ) ; g . gDrawLine ( getX ( ) + Dim . W ( 0.1 * w ) , getY ( ) + Dim . H ( h , minY ) , getX ( ) + Dim . W ( 0.9 * w ) , getY ( ) + Dim . H ( h , minY ) ) ; g . gSetColor ( Skin . BUTTON_ON ) ; g . gDrawLine ( getX ( ) + Dim . W ( 0.1 * w ) , getY ( ) + Dim . H ( h , minY ) , getX ( ) + Dim . W ( 0.1 * w ) + Dim . W ( 0.8 * w * ( double ) ( selected + 1 ) / options . size ( ) ) , getY ( ) + Dim . H ( h , minY ) ) ; g . gSetColor ( Skin . BCG_L ) ; for ( int i = 1 ; i < options . size ( ) ; i ++ ) g . gFillRectangle ( getX ( ) + Dim . W ( 0.1 * w ) + Dim . W ( 0.8 * w * ( double ) ( i ) / options . size ( ) ) - 1 , getY ( ) + Dim . H ( h , minY ) , 2 , 1 ) ; } }
te	1	public ServerStartDialog ( RiskFrame frame ) { super ( frame , "Start new server..." , true ) ; try { serverName = InetAddress . getLocalHost ( ) . getHostName ( ) ; serverAddress = InetAddress . getLocalHost ( ) . getHostAddress ( ) ; } catch ( UnknownHostException e ) { Logger . logexception ( e , "ServerStartDialog couldn't get the local host's address and name" ) ; } setResizable ( false ) ; setDefaultCloseOperation ( DISPOSE_ON_CLOSE ) ; setBounds ( 100 , 100 , 300 , 150 ) ; setLocationRelativeTo ( frame ) ; getContentPane ( ) . setLayout ( new BorderLayout ( ) ) ; contentPanel . setBorder ( new EmptyBorder ( 5 , 5 , 5 , 5 ) ) ; getContentPane ( ) . add ( contentPanel , BorderLayout . CENTER ) ; contentPanel . setLayout ( new GridLayout ( 3 , 2 , 0 , 0 ) ) ; { JLabel lblServerName = new JLabel ( "Server name:" ) ; contentPanel . add ( lblServerName ) ; } { serverNameTextField = new JTextField ( ) ; serverNameTextField . setEditable ( false ) ; serverNameTextField . setText ( serverName ) ; contentPanel . add ( serverNameTextField ) ; serverNameTextField . setColumns ( 10 ) ; } { JLabel lblServerIpAddress = new JLabel ( "Server IP address:" ) ; contentPanel . add ( lblServerIpAddress ) ; } { serverIPTextField = new JTextField ( ) ; serverIPTextField . setEditable ( false ) ; serverIPTextField . setText ( serverAddress ) ; contentPanel . add ( serverIPTextField ) ; serverIPTextField . setColumns ( 10 ) ; } { JLabel lblPort = new JLabel ( "Listening port:" ) ; contentPanel . add ( lblPort ) ; } { txtPort = new JTextField ( ) ; txtPort . setText ( Settings . getInstance ( ) . getServerListenPort ( ) + "" ) ; contentPanel . add ( txtPort ) ; txtPort . setColumns ( 10 ) ; } { JPanel buttonPane = new JPanel ( ) ; buttonPane . setLayout ( new FlowLayout ( FlowLayout . RIGHT ) ) ; getContentPane ( ) . add ( buttonPane , BorderLayout . SOUTH ) ; { JButton okButton = new JButton ( "OK" ) ; okButton . setAction ( action ) ; okButton . setActionCommand ( "OK" ) ; buttonPane . add ( okButton ) ; getRootPane ( ) . setDefaultButton ( okButton ) ; } { JButton cancelButton = new JButton ( "Cancel" ) ; cancelButton . setAction ( action_1 ) ; cancelButton . setActionCommand ( "Cancel" ) ; buttonPane . add ( cancelButton ) ; } } setVisible ( true ) ; }
te	0	public int getPatas ( ) { return patas ; }
te	8	public static void keyReleased ( KeyEvent keyEvent ) { Iterator < PComponent > it = components . iterator ( ) ; while ( it . hasNext ( ) ) { PComponent comp = it . next ( ) ; if ( comp == null ) continue ; if ( shouldHandleKeys ) { if ( comp . shouldHandleKeys ( ) ) comp . keyReleased ( keyEvent ) ; } else { if ( comp instanceof PFrame ) { for ( PComponent component : ( ( PFrame ) comp ) . getComponents ( ) ) if ( component . forceKeys ( ) ) component . keyReleased ( keyEvent ) ; } else if ( comp . forceKeys ( ) ) comp . keyReleased ( keyEvent ) ; } } }
te	1	public void keyPressed ( int key , char c ) { super . keyPressed ( key , c ) ; switch ( key ) { case Input . KEY_ESCAPE : paused = false ; break ; } }
te	1	public boolean isConnected ( ) { if ( socket == null ) { return false ; } return ! getSocket ( ) . isClosed ( ) ; }
te	6	public void actionPerformed ( ActionEvent arg0 ) { if ( arg0 . getSource ( ) == cancel ) { setVisible ( false ) ; clear ( ) ; } else if ( arg0 . getSource ( ) == save ) { if ( parent == util . quest . sp ) { if ( loaded == null ) { util . quest . slist . getSelectedValue ( ) . addAction ( create ( ) ) ; util . quest . sp . delete . setEnabled ( true ) ; } else edit ( ) ; util . quest . sp . loadData ( util . quest . slist . getSelectedValue ( ) ) ; setVisible ( false ) ; clear ( ) ; } else if ( parent == util . quest . op . rewards ) { if ( loaded == null ) { util . quest . op . rwcp . addAction ( create ( ) ) ; util . quest . op . rewards . delete . setEnabled ( true ) ; } else edit ( ) ; util . quest . op . rewards . loadData ( util . quest . op . rewards . loaded ) ; setVisible ( false ) ; clear ( ) ; } util . markFileChanged ( ) ; } }
te	0	public Scanner ( int adresse , int timeoutMS ) { this . adresse = adresse ; this . HWaccess = HWSimulation . getInstance ( ) ; workerThread = new ParallelWarteClass ( 1000 ) ; }
te	7	public void migrate ( ) throws Exception { try { if ( ! newDir . exists ( ) ) { newDir . mkdirs ( ) ; } SAXBuilder builder = new SAXBuilder ( ) ; Document d = builder . build ( oldFile ) ; Element snipSnapDumpRoot = d . getRootElement ( ) ; Element jumChild = null ; int i = 0 ; XMLOutputter outputter = new XMLOutputter ( ) ; for ( Element child : ( List < Element > ) snipSnapDumpRoot . getChildren ( ) ) { String name = child . getName ( ) ; String fileName = "" + i ++ ; if ( name . equals ( "snip" ) ) { fileName = child . getChildText ( "name" ) ; } if ( name . equals ( "user" ) ) { fileName = child . getChildText ( "login" ) ; } File output = new File ( new File ( newDir , name ) , fileName + ".html" ) ; if ( ! output . getParentFile ( ) . exists ( ) ) { output . getParentFile ( ) . mkdirs ( ) ; } outputter . output ( child , new FileWriter ( output ) ) ; } d . getRootElement ( ) . removeContent ( jumChild ) ; } catch ( JDOMException ex ) { ex . printStackTrace ( ) ; } catch ( IOException ex ) { ex . printStackTrace ( ) ; } }
te	9	public int getArrayIndex ( int ... ind ) { if ( ind . length == indexDim ) { if ( ind . length == 1 ) { return ind [ 0 ] ; } if ( ind . length == 2 ) { if ( this . checkIndex ( 0 , ind [ 0 ] ) == false || this . checkIndex ( 1 , ind [ 1 ] ) == false ) { return - 1 ; } return ind [ 0 ] + ind [ 1 ] * dimSizes [ 0 ] ; } if ( ind . length == 3 ) { if ( this . checkIndex ( 0 , ind [ 0 ] ) == false || this . checkIndex ( 1 , ind [ 1 ] ) == false || this . checkIndex ( 2 , ind [ 2 ] ) == false ) { return - 1 ; } return ( ind [ 2 ] * dimSizes [ 1 ] * dimSizes [ 0 ] ) + ( ind [ 1 ] * dimSizes [ 0 ] ) + ind [ 0 ] ; } } return - 1 ; }
te	4	public void render ( Graphics g , Dimension screenSize , Point translation , Point position ) { BufferedImage image = getImage ( ) ; int x = getPointOnScreen ( position ) . x ; int y = getPointOnScreen ( position ) . y ; if ( ( x + image . getWidth ( ) + translation . x ) < 0 || ( y + image . getHeight ( ) + translation . y ) < 0 ) return ; if ( ( x + translation . x ) > screenSize . width || ( y + translation . y ) > screenSize . height ) return ; g . setColor ( Color . BLACK ) ; g . drawImage ( image , x , y , null ) ; }
te	9	private void initializeTail ( MyList . Container < Element < T >> first , MyList . Container < Element < T >> last , MyList < Element < T >> newSingletonElements , MyList < Superelement < T >> newSingletonSuperelements , MyList < SplitFindminStructureGabow < Superelement < T >>> newSublists ) { MyList . Container < Element < T >> current = first ; int size = 0 ; while ( current != last . successor ) { size ++ ; current = current . successor ; } current = first ; int processedElements = 0 ; int superelementsInCurrentSublist = 0 ; Superelement < T > mostRecentSuperelement = null ; Superelement < T > currentSuperelement = null ; SplitFindminStructureGabow < Superelement < T >> currentLevelSublist = new SplitFindminStructureGabow < Superelement < T >> ( ackermann , i - 1 ) ; while ( size - processedElements > 3 ) { int level = ackermann . getInverse ( i , size - processedElements ) ; currentSuperelement = new Superelement < T > ( level ) ; currentSuperelement . cost = double . POSITIVE_INFINITY ; int numberOfElements = 2 * ackermann . getValue ( i , level ) ; currentSuperelement . first = current . item ; for ( int k = 0 ; k < numberOfElements ; k ++ ) { current . item . superelement = currentSuperelement ; currentSuperelement . cost = Math . min ( currentSuperelement . cost , current . item . cost ) ; current = current . successor ; } currentSuperelement . last = current . predecessor . item ; if ( mostRecentSuperelement != null && mostRecentSuperelement . level != level ) { if ( superelementsInCurrentSublist > 1 ) { MyList . Container < SplitFindminStructureGabow < Superelement < T >>> container = newSublists . add ( currentLevelSublist ) ; currentLevelSublist . containingContainerSublists = container ; currentLevelSublist . containingList = this ; } else { MyList . Container < Superelement < T >> container = newSingletonSuperelements . add ( mostRecentSuperelement ) ; mostRecentSuperelement . containingContainerSingletonSuperelements = container ; mostRecentSuperelement . containingList = this ; mostRecentSuperelement . elementInSublist = null ; mostRecentSuperelement . containingSublist = null ; } currentLevelSublist = new SplitFindminStructureGabow < Superelement < T >> ( ackermann , i - 1 ) ; superelementsInCurrentSublist = 0 ; } Element < Superelement < T >> e = currentLevelSublist . add ( currentSuperelement , currentSuperelement . cost ) ; currentSuperelement . elementInSublist = e ; currentSuperelement . containingSublist = currentLevelSublist ; superelementsInCurrentSublist ++ ; processedElements += numberOfElements ; mostRecentSuperelement = currentSuperelement ; } if ( superelementsInCurrentSublist > 1 ) { MyList . Container < SplitFindminStructureGabow < Superelement < T >>> container = newSublists . add ( currentLevelSublist ) ; currentLevelSublist . containingContainerSublists = container ; currentLevelSublist . containingList = this ; } else { if ( mostRecentSuperelement != null ) { MyList . Container < Superelement < T >> container = newSingletonSuperelements . add ( mostRecentSuperelement ) ; mostRecentSuperelement . containingContainerSingletonSuperelements = container ; mostRecentSuperelement . containingList = this ; mostRecentSuperelement . elementInSublist = null ; mostRecentSuperelement . containingSublist = null ; } } while ( current != last . successor ) { MyList . Container < Element < T >> container = newSingletonElements . add ( current . item ) ; current . item . containingContainerSingletonElements = container ; current . item . containingList = this ; current . item . superelement = null ; current = current . successor ; } for ( SplitFindminStructureGabow < Superelement < T >> sublist : newSublists ) { sublist . initializeTail ( ) ; } }
te	9	@ Override public Object getValueAt ( int rowIndex , int columnIndex ) { if ( _Vessels . size ( ) <= rowIndex ) return "" ; Vessel v = _Vessels . get ( rowIndex ) ; switch ( columnIndex ) { case 0 : return v . getId ( ) ; case 1 : return v . getType ( ) ; case 2 : return v . getCoord ( Calendar . getInstance ( ) ) . x ( ) ; case 3 : return v . getCoord ( Calendar . getInstance ( ) ) . y ( ) ; case 4 : return v . getSpeed ( Calendar . getInstance ( ) ) ; case 5 : return v . getCourseInDegrees ( Calendar . getInstance ( ) ) ; case 6 : return v . getDistance ( Calendar . getInstance ( ) ) ; case 7 : return v . getLastTimestamp ( ) . getTime ( ) ; case 8 : return getWorstAlert ( v ) . toString ( ) ; } return "Unknown" ; }
te	6	public String nextCDATA ( ) throws JSONException { char c ; int i ; StringBuilder sb = new StringBuilder ( ) ; for ( ; ; ) { c = next ( ) ; if ( end ( ) ) { throw syntaxError ( "Unclosed CDATA" ) ; } sb . append ( c ) ; i = sb . length ( ) - 3 ; if ( i >= 0 && sb . charAt ( i ) == ] && sb . charAt ( i + 1 ) == ] && sb . charAt ( i + 2 ) == > ) { sb . setLength ( i ) ; return sb . toString ( ) ; } } }
te	4	void refactor ( ) { System . out . println ( head . name + "" + tail . name ) ; double x1 = line . x1 , x2 = line . x2 , y1 = line . y1 , y2 = line . y2 ; Point t = new Point ( ( int ) x2 , ( int ) y2 ) ; double tan = ( y2 - y1 ) / ( x2 - x1 ) ; while ( head . contains ( t ) ) { if ( x2 > x1 ) { t . setLocation ( t . getX ( ) - 1 , t . getY ( ) - tan ) ; } else { t . setLocation ( t . getX ( ) + 1 , t . getY ( ) + tan ) ; } } line . setLine ( line . getP1 ( ) , t ) ; t . setLocation ( x1 , y1 ) ; while ( tail . contains ( t ) ) { if ( x2 > x1 ) { t . setLocation ( t . getX ( ) + 1 , t . getY ( ) + tan ) ; } else { t . setLocation ( t . getX ( ) - 1 , t . getY ( ) - tan ) ; } } line . setLine ( t , line . getP2 ( ) ) ; }
te	8	@ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; PersistentSet < ? > other = ( PersistentSet < ? > ) obj ; if ( set == null ) { if ( other . set != null ) return false ; } else if ( ! set . equals ( other . set ) ) return false ; return true ; }
te	3	public JSONObject ( Map map ) { this . map = new HashMap ( ) ; if ( map != null ) { Iterator i = map . entrySet ( ) . iterator ( ) ; while ( i . hasNext ( ) ) { Map . Entry e = ( Map . Entry ) i . next ( ) ; Object value = e . getValue ( ) ; if ( value != null ) { this . map . put ( e . getKey ( ) , wrap ( value ) ) ; } } } }
te	4	private boolean loadFromClasspath ( class < ? > contextClass , String resourceName ) throws IOException { Enumeration < URL > e = contextClass . getClassLoader ( ) . getResources ( resourceName ) ; if ( e == null || ! e . hasMoreElements ( ) ) { return false ; } while ( e . hasMoreElements ( ) ) { loadProperties ( resourceName , e . nextElement ( ) . openStream ( ) ) ; } return true ; }
te	2	@ Override public int compare ( RtpPacket o1 , RtpPacket o2 ) { if ( o1 . compareTo ( o2 ) < 0 ) { return - 1 ; } if ( o1 . compareTo ( o2 ) > 0 ) { return 1 ; } return 0 ; }
te	4	public SequenceNumberReplacerImpl ( Map < AttributeKey , Object > attributes ) { super ( attributes ) ; if ( attributes . get ( AttributeKey . INITIAL_NO_FOR_START ) != null ) { initialNoForStart = ( Integer ) attributes . get ( AttributeKey . INITIAL_NO_FOR_START ) ; startFlag = true ; } if ( attributes . get ( AttributeKey . INITIAL_NO_FOR_END ) != null ) { initialNoForEnd = ( Integer ) attributes . get ( AttributeKey . INITIAL_NO_FOR_END ) ; endFlag = true ; } if ( attributes . get ( AttributeKey . INITIAL_NO_FOR_INDEX ) != null ) { initialNoForIndex = ( Integer ) attributes . get ( AttributeKey . INITIAL_NO_FOR_INDEX ) ; if ( attributes . get ( AttributeKey . INDEX_NO ) == null ) { throw new FileRenamerException ( "The " + AttributeKey . INDEX_NO + " key can't be found" ) ; } indexNo = ( Integer ) attributes . get ( AttributeKey . INDEX_NO ) ; indexFlag = true ; } }
te	2	@ Override public ArrayList < RaavareBatchDTO > getRaavareBatchList ( ) throws DALException { ArrayList < RaavareBatchDTO > list = new ArrayList < RaavareBatchDTO > ( ) ; ResultSet rs = Connector . doQuery ( "SELECT r.* rb.* FROM raavare r  raavarebatch rb WHERE r.raavare_id=rb.raavare_id ORDER BY r.raavare_navn ASC" ) ; try { while ( rs . next ( ) ) { RaavareDTO raavare = new RaavareDTO ( rs . getInt ( 1 ) , rs . getString ( 2 ) ) ; list . add ( new RaavareBatchDTO ( rs . getInt ( 3 ) , raavare , rs . getDouble ( 5 ) , rs . getTimestamp ( 6 ) , rs . getString ( 7 ) ) ) ; } } catch ( SQLException e ) { throw new DALException ( e ) ; } return list ; }
te	9	JFilePanel ( ) { setLayout ( new BoxLayout ( this , BoxLayout . Y_AXIS ) ) ; setBorder ( BorderFactory . createLineBorder ( Color . BLUE , 4 ) ) ; infilePanel = new JPanel ( new FlowLayout ( ) ) ; add ( infilePanel ) ; infilePanel . add ( new JLabel ( "Input File:" ) ) ; JButton jInfileButton = new JButton ( "Select File" ) ; infilePanel . add ( jInfileButton ) ; jInfileButton . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { catchKeyboard = false ; JFileChooser fileChooser = new JFileChooser ( lastfile ) ; fileChooser . setFileSelectionMode ( JFileChooser . FILES_ONLY ) ; int rVal = fileChooser . showOpenDialog ( null ) ; if ( rVal == JFileChooser . APPROVE_OPTION ) { jInfile . setText ( fileChooser . getSelectedFile ( ) . toString ( ) ) ; lastfile = new String ( jInfile . getText ( ) ) ; File infile = new File ( lastfile ) ; try { midiIn = MidiSystem . getSequence ( infile ) ; } catch ( Exception ea ) { displayerror ( "Error opening midi file " + lastfile + " for reading" ) ; return ; } endSequence ( true ) ; } catchKeyboard = true ; } } ) ; jInfile . addFocusListener ( blockKeysFocusListener ) ; infilePanel . add ( jInfile ) ; infilePanel . add ( Box . createRigidArea ( new Dimension ( 30 , 1 ) ) ) ; infilePanel . add ( new JLabel ( "Tempo: (%)" ) ) ; jTempo = new JSlider ( JSlider . HORIZONTAL , 50 , 150 , 100 ) ; jTempo . setMajorTickSpacing ( 25 ) ; jTempo . setMinorTickSpacing ( 5 ) ; jTempo . setPaintTicks ( true ) ; jTempo . setPaintLabels ( true ) ; Font tempoFont = new Font ( "Dialog" , Font . PLAIN , 8 ) ; jTempo . setFont ( tempoFont ) ; jTempo . addChangeListener ( new ChangeListener ( ) { public void stateChanged ( ChangeEvent e ) { setTempo ( ) ; } } ) ; infilePanel . add ( jTempo ) ; fileadvancedSuperPanel = new JPanel ( new FlowLayout ( ) ) ; JPanel fileadvancedPanel = new JPanel ( ) ; fileadvancedPanel . setLayout ( new BoxLayout ( fileadvancedPanel , BoxLayout . Y_AXIS ) ) ; fileadvancedPanel . setBorder ( advancedSettingsBorder ) ; fileadvancedSuperPanel . add ( fileadvancedPanel ) ; JPanel bendrangeSubPanel = new JPanel ( new FlowLayout ( ) ) ; fileadvancedPanel . add ( bendrangeSubPanel ) ; bendrangeSubPanel . add ( new JLabel ( "Assumed Maximum Bend" ) ) ; jBendRange = new JComboBox < Integer > ( ) ; jBendRange . setFont ( dropdownFont ) ; for ( int i = 1 ; i < 12 ; i ++ ) { jBendRange . addItem ( i ) ; } jBendRange . setSelectedIndex ( 1 ) ; jBendRange . addFocusListener ( blockKeysFocusListener ) ; bendrangeSubPanel . add ( jBendRange ) ; jBendRangeCommand . setSelected ( true ) ; bendrangeSubPanel . add ( jBendRangeCommand ) ; JPanel chooseFileProgramPanel = new JPanel ( new FlowLayout ( ) ) ; chooseFileProgramPanel . add ( new JLabel ( "Instrument for Saved File / Playback" ) ) ; jChooseFileProgram = new JComboBox < String > ( ) ; jChooseFileProgram . setFont ( dropdownFont ) ; jChooseFileProgram . addFocusListener ( blockKeysFocusListener ) ; for ( int i = 0 ; i < progChangeText . length ; i ++ ) { jChooseFileProgram . addItem ( progChangeText [ i ] ) ; } jChooseFileProgram . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { changeLiveTuning ( ) ; } } ) ; chooseFileProgramPanel . add ( jChooseFileProgram ) ; fileadvancedPanel . add ( chooseFileProgramPanel ) ; JPanel jTransposePanel = new JPanel ( new FlowLayout ( ) ) ; jTransposePanel . add ( new JLabel ( "Transpose by (semitones):" ) ) ; jTransposeAmount = new JComboBox < Integer > ( ) ; jTransposeAmount . setFont ( dropdownFont ) ; for ( int i = - 12 ; i < 13 ; i ++ ) { jTransposeAmount . addItem ( i ) ; } jTransposeAmount . setSelectedItem ( 0 ) ; jTransposeAmount . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { changeLiveTuning ( ) ; kbPanel . repaint ( ) ; } } ) ; jTransposePanel . add ( jTransposeAmount ) ; jTransposePanel . add ( Box . createRigidArea ( new Dimension ( 30 , 1 ) ) ) ; jGetCuePoint = new JButton ( "Get CuePoint (alt-g)" ) ; jTransposePanel . add ( jGetCuePoint ) ; NumberFormat doubleFormat = NumberFormat . getNumberInstance ( ) ; final JFormattedTextField jCuePoint = new JFormattedTextField ( doubleFormat ) ; jCuePoint . addFocusListener ( blockKeysFocusListener ) ; jCuePoint . setValue ( new double ( 0.00000 ) ) ; jCuePoint . setColumns ( 8 ) ; jGetCuePoint . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { jCuePoint . setValue ( ( ( ( double ) theSequencer . getMicrosecondPosition ( ) ) / ( ( double ) 1.0e6 ) ) ) ; } } ) ; jTransposePanel . add ( jCuePoint ) ; jGoCuePoint = new JButton ( "Goto CuePoint (alt-c)" ) ; jGoCuePoint . setEnabled ( false ) ; jGoCuePoint . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { double cuepoint = ( ( Number ) jCuePoint . getValue ( ) ) . doubleValue ( ) * 1.0e6 ; Sequence theSequence = theSequencer . getSequence ( ) ; if ( theSequence == null ) { return ; } double usectotick = ( ( double ) theSequence . getTickLength ( ) ) / ( ( double ) theSequence . getMicrosecondLength ( ) ) ; startSequence ( ( long ) ( cuepoint * usectotick ) ) ; } } ) ; jTransposePanel . add ( jGoCuePoint ) ; fileadvancedPanel . add ( jTransposePanel ) ; JPanel goPanel = new JPanel ( ) ; goPanel . setLayout ( new BoxLayout ( goPanel , BoxLayout . X_AXIS ) ) ; add ( goPanel ) ; goPanel . add ( Box . createRigidArea ( new Dimension ( 20 , 20 ) ) ) ; JButton jGoButton = new JButton ( "Generate and save re-tuned midi file" ) ; goPanel . add ( jGoButton ) ; goPanel . add ( Box . createRigidArea ( new Dimension ( 30 , 10 ) ) ) ; jGoButton . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { catchKeyboard = false ; JFileChooser fileChooser = new JFileChooser ( lastfile ) ; String suggestedfilename = jInfile . getText ( ) ; int lastslash = suggestedfilename . lastIndexOf ( / ) ; if ( lastslash >= 0 ) { suggestedfilename = suggestedfilename . substring ( lastslash + 1 ) ; } lastslash = suggestedfilename . lastIndexOf ( \ ) ; if ( lastslash >= 0 ) { suggestedfilename = suggestedfilename . substring ( lastslash + 1 ) ; } suggestedfilename = getSuggestedFilename ( suggestedfilename , ( String ) jTunings . getSelectedItem ( ) , jNotes . getSelectedIndex ( ) , jTuningAdvancedPanel . getRootNote ( ) , jTuningAdvancedPanel . getFrequency ( ) ) ; fileChooser . setSelectedFile ( new File ( suggestedfilename ) ) ; fileChooser . setFileSelectionMode ( JFileChooser . FILES_ONLY ) ; int rVal = fileChooser . showSaveDialog ( null ) ; if ( rVal == JFileChooser . APPROVE_OPTION ) { try { lastfile = new String ( fileChooser . getSelectedFile ( ) . toString ( ) ) ; if ( ! ( ( lastfile . toLowerCase ( ) . endsWith ( ".mid" ) ) || ( lastfile . toLowerCase ( ) . endsWith ( ".midi" ) ) ) ) { lastfile = new String ( lastfile + ".mid" ) ; } int theInstrument = progChangeCodes [ jChooseFileProgram . getSelectedIndex ( ) ] ; if ( theInstrument < - 2 ) { theInstrument = jProgram . getSelectedIndex ( ) ; } makethefile ( jInfile . getText ( ) , lastfile , jNotes . getSelectedIndex ( ) , jTunings . getSelectedItem ( ) . toString ( ) , 1.0 * ( ( Integer ) jBendRange . getSelectedItem ( ) ) , jBendRangeCommand . isSelected ( ) , theInstrument , jTuningAdvancedPanel . getRootNote ( ) , jTuningAdvancedPanel . getFrequency ( ) , ( Integer ) jTransposeAmount . getSelectedItem ( ) , false ) ; } catch ( Exception ee ) { } } catchKeyboard = true ; } } ) ; jMidiProgress = new JProgressBar ( 0 , 1 ) ; jMidiProgress . addMouseMotionListener ( new MouseMotionListener ( ) { public void mouseMoved ( MouseEvent e ) { int x = e . getX ( ) ; int W = jMidiProgress . getWidth ( ) ; double t = ( ( ( double ) theSequencer . getMicrosecondLength ( ) ) / ( double ) 1.0e6 ) ; DecimalFormat df = new DecimalFormat ( "#.00" ) ; jMidiProgress . setToolTipText ( df . format ( ( double ) ( t * x ) / ( ( double ) W ) ) + "s" ) ; } public void mouseDragged ( MouseEvent e ) { } } ) ; jMidiProgress . addMouseListener ( new MouseListener ( ) { public void mouseClicked ( MouseEvent e ) { int x = e . getX ( ) ; int W = jMidiProgress . getWidth ( ) ; jMidiProgress . setValue ( ( jMidiProgress . getMaximum ( ) * x ) / W ) ; startSequence ( theSequencer . getTickLength ( ) * x / W ) ; } public void mousePressed ( MouseEvent e ) { } public void mouseReleased ( MouseEvent e ) { } public void mouseEntered ( MouseEvent e ) { } public void mouseExited ( MouseEvent e ) { } } ) ; ActionListener updateMidiProgress = new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { jMidiProgress . setValue ( ( int ) ( ( 100.0 * ( double ) theSequencer . getMicrosecondPosition ( ) ) / 1.0e6 ) ) ; jMidiProgress . repaint ( ) ; } } ; progressTimer = new Timer ( 40 , updateMidiProgress ) ; jPause = new PauseButton ( pausestring , continuestring ) ; jPlay . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { if ( midiIn != null ) { if ( jPlay . getText ( ) == playstring ) { startSequence ( 0 ) ; } else { endSequence ( false ) ; } } } } ) ; goPanel . add ( jPlay ) ; jPause . setEnabled ( false ) ; goPanel . add ( jPause ) ; goPanel . add ( jMidiProgress ) ; goPanel . add ( Box . createRigidArea ( new Dimension ( 20 , 20 ) ) ) ; add ( Box . createRigidArea ( new Dimension ( 20 , 10 ) ) ) ; }
te	8	private static String escapeStringLiteral ( String value ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( "\"" ) ; char [ ] chars = value . toCharArray ( ) ; for ( int i = 0 , size = chars . length ; i < size ; i ++ ) { char ch = chars [ i ] ; switch ( ch ) { case '' : sb . append ( "\\n" ) ; break ; case '' : sb . append ( "\\r" ) ; break ; case  : sb . append ( "\\b" ) ; break ; case  : sb . append ( "\\f" ) ; break ; case 	 : sb . append ( "\\t" ) ; break ; case " : sb . append ( "\\\"" ) ; break ; case \ : sb . append ( "\\\\" ) ; break ; default : sb . append ( ch ) ; } } sb . append ( "\"" ) ; return sb . toString ( ) ; }
te	8	private boolean r_perfective_gerund ( ) { int among_var ; int v_1 ; ket = cursor ; among_var = find_among_b ( a_0 , 9 ) ; if ( among_var == 0 ) { return false ; } bra = cursor ; switch ( among_var ) { case 0 : return false ; case 1 : lab0 : do { v_1 = limit - cursor ; lab1 : do { if ( ! ( eq_s_b ( 1 , "\u0430" ) ) ) { break lab1 ; } break lab0 ; } while ( false ) ; cursor = limit - v_1 ; if ( ! ( eq_s_b ( 1 , "\u044F" ) ) ) { return false ; } } while ( false ) ; slice_del ( ) ; break ; case 2 : slice_del ( ) ; break ; } return true ; }
te	0	public ExpressionList arguments ( ) { return args ; }
te	1	@ Override public int getFirstSlotLocationX ( ) { return currentContainer == 2 ? centerX - 51 : GamePanel . WIDTH / 2 - 150 / 2 + 48 ; }
te	5	public ArrayList < Integer > getRow ( int rowIndex ) { ArrayList < Integer > row = new ArrayList < Integer > ( ) ; if ( rowIndex < 0 ) return row ; row . add ( 1 ) ; if ( rowIndex == 0 ) return row ; row . add ( 1 ) ; if ( rowIndex == 1 ) return row ; for ( int level = 2 ; level <= rowIndex ; level ++ ) { int last = row . get ( 1 ) ; row . set ( 1 , 1 + last ) ; for ( int i = 2 ; i < level ; i ++ ) { int pre = row . get ( i ) ; row . set ( i , last + row . get ( i ) ) ; last = pre ; } row . add ( 1 ) ; } return row ; }
te	9	public void loadNodesAttached ( ) { ArrayList < Object > nodesAttached ; Point2D . double startPoint ; Point2D . double finalPoint ; Point2D . double position ; for ( Road road : roads ) { nodesAttached = new ArrayList < Object > ( ) ; startPoint = road . getStartPoint ( ) ; finalPoint = road . getFinalPoint ( ) ; for ( Station station : stations ) { position = station . getPosition ( ) ; if ( UtilCalc . comparePoints ( startPoint , position ) ) { nodesAttached . add ( 0 , station ) ; } else { if ( UtilCalc . comparePoints ( finalPoint , position ) ) { if ( nodesAttached . size ( ) > 0 ) { nodesAttached . add ( 1 , station ) ; } else { nodesAttached . add ( 0 , station ) ; } } } } for ( Semaphore semaphore : semaphores ) { position = semaphore . getPosition ( ) ; if ( UtilCalc . comparePoints ( startPoint , position ) ) { nodesAttached . add ( 0 , semaphore ) ; } else { if ( UtilCalc . comparePoints ( finalPoint , position ) ) { if ( nodesAttached . size ( ) > 0 ) { nodesAttached . add ( 1 , semaphore ) ; } else { nodesAttached . add ( 0 , semaphore ) ; } } } } road . addNodesAttached ( nodesAttached ) ; if ( nodesAttached . size ( ) < 2 ) { System . out . println ( road . getName ( ) + " --> " + road . getNodesAttached ( ) ) ; } } }
te	5	@ Override public boolean equals ( Object object ) { if ( ! ( object instanceof UserProjectActivity ) ) { return false ; } UserProjectActivity other = ( UserProjectActivity ) object ; if ( ( this . id == null && other . id != null ) || ( this . id != null && ! this . id . equals ( other . id ) ) ) { return false ; } return true ; }
te	1	public List < Entry > getPiecesForFile ( Path file ) { if ( file == null ) { throw new NullPointerException ( ) ; } return filesToPieces . get ( file ) ; }
te	0	public int getScore ( ) { return scroe ; }
te	4	void Louer ( ) { int idCarte = Integer . parseInt ( JOptionPane . showInputDialog ( "Num\u00E9ro carte abonn\u00E9e ?" ) ) ; Utilisateur user = null ; for ( Utilisateur s : ConfigGlobale . utilisateurs ) { if ( s . getFk_id_carte ( ) == idCarte ) { user = s ; break ; } } if ( user != null && user . getFk_id_velo ( ) == - 1 ) { LabelCarte . setForeground ( Color . green ) ; ctrlLV . locationVelo ( user ) ; LabelRecupVelo . setForeground ( Color . green ) ; LabelRemerciement . setForeground ( Color . green ) ; } else { LabelCarte . setForeground ( Color . red ) ; } }
te	8	public Object decode ( byte [ ] value ) { Object [ ] retval = EMPTY_ARRAY ; ArrayList < Object > elements = new ArrayList < Object > ( ) ; short type = 0 ; byte [ ] data = null ; FieldType datatype = null ; if ( value != null ) { try { final ByteArrayInputStream bais = new ByteArrayInputStream ( value ) ; final DataInputStream dis = new DataInputStream ( bais ) ; while ( dis . available ( ) > 0 ) { type = dis . readByte ( ) ; try { datatype = DataField . getDataType ( type ) ; } catch ( Throwable ball ) { throw new IOException ( "non supported type: '" + type + "'" ) ; } if ( datatype . getSize ( ) < 0 ) { final int length = dis . readUnsignedShort ( ) ; if ( length < 0 ) { throw new IOException ( "read length bad value: length = " + length + " type = " + type ) ; } int i = dis . available ( ) ; if ( i < length ) { throw new IOException ( "value underflow: length specified as " + length + " but only " + i + " octets are available" ) ; } data = new byte [ length ] ; if ( length > 0 ) { dis . read ( data , 0 , length ) ; } } else { data = new byte [ datatype . getSize ( ) ] ; dis . read ( data ) ; } elements . add ( datatype . decode ( data ) ) ; } retval = elements . toArray ( ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( "Could not decode value" , e ) ; } } return retval ; }
te	7	public Operator greedyChoose ( ) { double r ; synchronized ( rng ) { r = rng . nextDouble ( ) ; } if ( r < EPS ) { synchronized ( rng ) { choosen = rng . nextInt ( operators . size ( ) ) ; } return operators . get ( choosen ) ; } double qMax = q . get ( 0 ) ; int count = 1 ; for ( int i = 1 ; i < q . size ( ) ; ++ i ) { if ( q . get ( i ) == qMax ) { ++ count ; } else if ( q . get ( i ) > qMax ) { count = 1 ; qMax = q . get ( i ) ; } } int number ; synchronized ( rng ) { number = rng . nextInt ( count ) ; } for ( int i = 0 ; i < q . size ( ) ; ++ i ) { if ( q . get ( i ) == qMax ) { if ( number == 0 ) { choosen = i ; break ; } else { -- number ; } } } return operators . get ( choosen ) ; }
te	5	@ Override public Rectangle getBounds ( ) { float lowX , highX , lowY , highY , width , height ; FloatCartesian each = get ( 0 ) ; lowX = each . x ; highX = each . x ; lowY = each . y ; highY = each . y ; for ( int i = 1 ; i < size ( ) ; i ++ ) { each = get ( i ) ; if ( each . x < lowX ) { lowX = each . x ; } else if ( each . x > highX ) { highX = each . x ; } if ( each . y < lowY ) { lowY = each . y ; } else if ( each . y > highY ) { highY = each . y ; } } width = highX - lowX ; height = highY - lowY ; return new Rectangle ( ( int ) Math . floor ( lowX ) , ( int ) Math . floor ( lowY ) , ( int ) Math . ceil ( width ) , ( int ) Math . ceil ( height ) ) ; }
te	2	@ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( "OAuth 2.0 Error: " ) ; sb . append ( type . toString ( ) ) ; if ( description != null ) { sb . append ( " - " ) ; sb . append ( description ) ; } if ( uri != null ) { sb . append ( "\n" ) ; sb . append ( uri ) ; } return sb . toString ( ) ; }
te	4	private int getFirstAvailableColumn ( int [ ] unfinishedSpans ) { if ( useStrictGridBagModel && unfinishedSpans != null ) { for ( int column = unfinishedSpans . length ; column > 0 ; column -- ) { if ( unfinishedSpans [ column - 1 ] > 0 ) return column ; } } return 0 ; }
te	2	public Program ( String program ) { programString = program ; commands = new ArrayList < String > ( ) ; String [ ] data = program . split ( "\n" ) ; for ( String tmp : data ) if ( ! tmp . isEmpty ( ) ) commands . add ( tmp . trim ( ) ) ; }
te	2	private boolean isMatchFromPosition ( int i , List < Term > phrase ) { for ( int j = 0 ; j < phrase . size ( ) ; j ++ ) { Integer termId1 = bodyTokens . get ( i + j ) ; Integer termId2 = phrase . get ( j ) . getId ( ) ; if ( ! termId1 . equals ( termId2 ) ) { return false ; } } return true ; }
te	2	private static int minRunLength ( int n ) { if ( DEBUG ) { assert n >= 0 ; } int r = 0 ; while ( n >= MIN_MERGE ) { r |= ( n & 1 ) ; n >>= 1 ; } return n + r ; }
te	7	public void interact ( ThePlayer p ) { if ( given == false ) { p . getFFCharacter ( ) . giveItem ( containedItem ) ; System . out . println ( "Thou hast obtained ye " + containedItem . toString ( ) ) ; given = true ; if ( containedItem instanceof Weapon ) { Weapon contWeapon = ( Weapon ) containedItem ; if ( p . getFFCharacter ( ) . getWeapon ( ) == null || p . getFFCharacter ( ) . getWeapon ( ) . getPower ( ) < contWeapon . getPower ( ) ) { p . getFFCharacter ( ) . wield ( contWeapon ) ; } } else if ( containedItem instanceof Armor ) { Armor contArmor = ( Armor ) containedItem ; if ( p . getFFCharacter ( ) . getArmor ( ) == null || p . getFFCharacter ( ) . getArmor ( ) . getStrength ( ) < contArmor . getStrength ( ) ) { p . getFFCharacter ( ) . wear ( contArmor ) ; } } } }
te	1	public void update ( CourseRoles instance ) { log . debug ( "updating " + entitySimpleName + " instance" ) ; try { super . update ( instance ) ; log . debug ( entitySimpleName + " update successful" ) ; } catch ( RuntimeException re ) { log . error ( entitySimpleName + " update failed" , re ) ; throw re ; } }
te	2	public void paint ( Graphics g ) { for ( int i = 0 ; i < pixels . length ; i ++ ) { for ( int j = 0 ; j < pixels [ i ] . length ; j ++ ) { g . setColor ( getGrayscaleColor ( getNewShade ( pixels [ i ] [ j ] ) ) ) ; g . fillRect ( j * SCALE , i * SCALE , SCALE , SCALE ) ; } } }
te	8	public int getScore ( int [ ] faceValues ) throws IllegalArgumentException { int score = 0 ; int [ ] compareArray = new int [ 6 ] ; for ( int i = 0 ; i < faceValues . length ; i ++ ) { if ( faceValues [ i ] < 1 || faceValues [ i ] > 6 ) { throw new IllegalArgumentException ( "FaceValues have to be between 1 and 6." ) ; } compareArray [ faceValues [ i ] - 1 ] += 1 ; } for ( int j = 0 ; j < compareArray . length ; j ++ ) { if ( compareArray [ j ] > 2 ) { for ( int k = 0 ; k < compareArray . length ; k ++ ) { if ( compareArray [ k ] > 1 && k != j ) { score = 25 ; } } } } return score ; }
te	2	public int playersInScourge ( ) { int c = 0 ; for ( int i : scourge ) { if ( i != 0 ) c ++ ; } return c ; }
te	7	public void clusterDocument ( Document doc ) throws Exception { Transaction tx = graphDb . beginTx ( ) ; try { ArrayList < Sentence > sentencesList = doc . getSentences ( ) ; Hashtable < String , double > documentSimilairtyTableForWords = new Hashtable < String , double > ( ) ; Hashtable < String , double > documentSimilairtyTableForEdges = new Hashtable < String , double > ( ) ; double documentMagnitude = 0.0 ; double edgesMagnitude = 0.0 ; int numberOfEgdesOfDocument = 0 ; for ( int sentenceIndex = 0 ; sentenceIndex < sentencesList . size ( ) ; sentenceIndex ++ ) { Sentence currentSentence = sentencesList . get ( sentenceIndex ) ; ArrayList < Word > currentSentenceWords = currentSentence . getWords ( ) ; Word previousWord = null ; Word currentWord = null ; Node previousNodeInTheGraph = null ; Node currentNodeInGraph = null ; for ( int wordIndex = 0 ; wordIndex < currentSentenceWords . size ( ) ; wordIndex ++ ) { currentWord = currentSentenceWords . get ( wordIndex ) ; currentNodeInGraph = nodeIndex . get ( Neo4jNode . WORD_PROPERTY , currentWord . getContent ( ) ) . getSingle ( ) ; double wordValueForTheDocument = calculateWordValue ( doc , currentWord ) ; documentMagnitude += Math . pow ( wordValueForTheDocument , 2 ) ; if ( currentNodeInGraph != null ) { updateDocumentImportanceTable ( documentSimilairtyTableForWords , currentNodeInGraph , wordValueForTheDocument ) ; } else { currentNodeInGraph = createNewWord ( currentWord ) ; } if ( ( previousNodeInTheGraph != null ) && ( currentNodeInGraph != null ) ) { numberOfEgdesOfDocument ++ ; edgesMagnitude ++ ; String edgeID = previousWord . getContent ( ) + "_" + currentWord . getContent ( ) ; Relationship edge = edgesIndex . get ( "edge" , edgeID ) . getSingle ( ) ; if ( edge != null ) { updateEdgesDocumentImportanceTable ( documentSimilairtyTableForEdges , edge , 1 ) ; } else { createNewEdge ( previousNodeInTheGraph , currentNodeInGraph , edgeID ) ; } } previousNodeInTheGraph = currentNodeInGraph ; previousWord = currentWord ; } } String closestCluster = getClosestCluster ( doc , documentMagnitude , numberOfEgdesOfDocument , documentSimilairtyTableForWords , documentSimilairtyTableForEdges ) ; if ( closestCluster . equalsIgnoreCase ( "" ) ) { closestCluster = String . valueOf ( clusterCounter ) ; Neo4jCluster c = new Neo4jCluster ( closestCluster ) ; c . incrementMagnitude ( documentMagnitude ) ; c . incrementEdgesMagnitude ( edgesMagnitude ) ; this . clustersList . put ( c . getId ( ) , c ) ; c . addDcoument ( doc . getId ( ) ) ; this . clusterCounter ++ ; updateTheGraph ( doc ) ; } else { Neo4jCluster c = this . clustersList . get ( closestCluster ) ; c . incrementMagnitude ( documentMagnitude ) ; c . incrementEdgesMagnitude ( edgesMagnitude ) ; c . addDcoument ( doc . getId ( ) ) ; updateTheGraph ( doc ) ; } tx . success ( ) ; } finally { tx . finish ( ) ; } }
te	5	@ Test public void testPartialQuery ( ) throws Exception { final String INDEX_NAME = "partialQuery" ; IndexManager indexManager = new IndexManager ( TEST_UTIL . getConfiguration ( ) ) ; IndexDefinition indexDef = new IndexDefinition ( INDEX_NAME , INDEX_NAME ) ; indexDef . addStringField ( "field1" ) ; indexDef . addIntegerField ( "field2" ) ; indexDef . addStringField ( "field3" ) ; indexManager . createIndex ( indexDef ) ; Index index = indexManager . getIndex ( INDEX_NAME , INDEX_NAME ) ; for ( int i = 0 ; i < 3 ; i ++ ) { IndexEntry entry = new IndexEntry ( ) ; entry . addField ( "field1" , "value A " + i ) ; entry . addField ( "field2" , 10 + i ) ; entry . addField ( "field3" , "value B " + i ) ; index . addEntry ( entry , Bytes . toBytes ( "key" + i ) ) ; } { Query query = new Query ( ) ; query . addEqualsCondition ( "field1" , "value A 0" ) ; QueryResult result = index . performQuery ( query ) ; assertResultIds ( result , "key0" ) ; } { Query query = new Query ( ) ; query . addEqualsCondition ( "field1" , "value A 0" ) ; query . addEqualsCondition ( "field2" , 10 ) ; QueryResult result = index . performQuery ( query ) ; assertResultIds ( result , "key0" ) ; } { Query query = new Query ( ) ; query . addEqualsCondition ( "field1" , "value A 0" ) ; query . setRangeCondition ( "field2" , 9 , 11 ) ; QueryResult result = index . performQuery ( query ) ; assertResultIds ( result , "key0" ) ; } { Query query = new Query ( ) ; query . addEqualsCondition ( "field2" , 10 ) ; try { index . performQuery ( query ) ; fail ( "Exception expected" ) ; } catch ( MalformedQueryException e ) { } } { Query query = new Query ( ) ; query . setRangeCondition ( "field2" , 9 , 11 ) ; try { index . performQuery ( query ) ; fail ( "Exception expected" ) ; } catch ( MalformedQueryException e ) { } } { Query query = new Query ( ) ; query . addEqualsCondition ( "field1" , "value A 0" ) ; query . addEqualsCondition ( "field3" , "value B 0" ) ; try { index . performQuery ( query ) ; fail ( "Exception expected" ) ; } catch ( MalformedQueryException e ) { } } { Query query = new Query ( ) ; query . addEqualsCondition ( "field1" , "value A 0" ) ; query . setRangeCondition ( "field3" , "a" , "b" ) ; try { index . performQuery ( query ) ; fail ( "Exception expected" ) ; } catch ( MalformedQueryException e ) { } } }
te	9	private String filenameToTitle ( String filename ) { StringBuilder titleBuilder = new StringBuilder ( ) ; if ( filename . indexOf ( . ) > 0 ) filename = filename . substring ( 0 , filename . lastIndexOf ( . ) ) ; char c ; boolean lastCharacterWasDigit = false ; boolean lastCharacterWasSpace = false ; for ( int i = 0 , count = filename . length ( ) ; i < count ; i ++ ) { c = filename . charAt ( i ) ; if ( Character . isAlphabetic ( c ) ) { if ( i > 0 && ! lastCharacterWasSpace && Character . isUpperCase ( c ) ) { titleBuilder . append (   ) ; } if ( Character . isDigit ( c ) ) { if ( i > 0 && ! lastCharacterWasSpace && ! lastCharacterWasDigit ) { titleBuilder . append (   ) ; } lastCharacterWasDigit = true ; } else { lastCharacterWasDigit = false ; } lastCharacterWasSpace = false ; titleBuilder . append ( c ) ; } else { if ( ! lastCharacterWasSpace ) { titleBuilder . append (   ) ; lastCharacterWasDigit = false ; lastCharacterWasSpace = true ; } } } return titleBuilder . toString ( ) ; }
te	4	public JSONWriter key ( String string ) throws JSONException { if ( string == null ) { throw new JSONException ( "Null key." ) ; } if ( this . mode == k ) { try { this . stack [ this . top - 1 ] . putOnce ( string , boolean . true ) ; if ( this . , ) { this . writer . write (   ) ; } this . writer . write ( JSONObject . quote ( string ) ) ; this . writer . write ( : ) ; this . , = false ; this . mode = o ; return this ; } catch ( IOException e ) { throw new JSONException ( e ) ; } } throw new JSONException ( "Misplaced key." ) ; }
te	2	public static void main ( String [ ] a ) { Settings . init ( ) ; bookkeeper . init ( ) ; for ( String destPath : Settings . getInstance ( ) . getDestFolders ( ) ) { File destFolder = new File ( destPath ) ; if ( ! destFolder . exists ( ) ) { destFolder . mkdir ( ) ; } } bookkeeper . getInstance ( ) . updateBooks ( ) ; }
te	7	private void populateQueues ( ) { String sgeRoot = Configuration . getConfig ( Configuration . CONFIG_SGE_ROOT ) ; String arch = "" ; Process p = null ; try { p = Runtime . getRuntime ( ) . exec ( sgeRoot + "/util/arch" ) ; InputStream is = p . getInputStream ( ) ; byte [ ] buff = new byte [ 256 ] ; if ( is . read ( buff ) > 0 ) { arch = new String ( buff ) . trim ( ) ; } } catch ( Exception ex ) { ex . printStackTrace ( ) ; } finally { NativeCalls . releaseProcess ( p ) ; } StringBuilder cmd = new StringBuilder ( sgeRoot ) ; cmd . append ( File . separator ) ; cmd . append ( "bin" ) ; cmd . append ( File . separator ) ; cmd . append ( arch ) ; cmd . append ( File . separator ) ; cmd . append ( "qstat -g c" ) ; List < String > queues = new LinkedList < String > ( ) ; try { p = Runtime . getRuntime ( ) . exec ( cmd . toString ( ) ) ; BufferedReader stdInput = new BufferedReader ( new InputStreamReader ( p . getInputStream ( ) ) ) ; String s = null ; int lineNo = 0 ; while ( ( s = stdInput . readLine ( ) ) != null ) { lineNo ++ ; if ( lineNo <= 2 ) continue ; String [ ] tokens = s . split ( " " ) ; queues . add ( tokens [ 0 ] ) ; } } catch ( Exception ex ) { ex . printStackTrace ( ) ; } finally { if ( p != null ) NativeCalls . releaseProcess ( p ) ; } queueComboBox . removeAllItems ( ) ; queueComboBox . addItem ( " Select One " ) ; for ( String q : queues ) queueComboBox . addItem ( q ) ; }
te	6	protected void solve ( ) { if ( graph . nodes . size ( ) == 0 ) return ; NodeList unranked = new NodeList ( graph . nodes ) ; NodeList rankMe = new NodeList ( ) ; Node node ; int i ; while ( ! unranked . isEmpty ( ) ) { rankMe . clear ( ) ; for ( i = 0 ; i < unranked . size ( ) ; ) { node = unranked . getNode ( i ) ; if ( node . incoming . isCompletelyFlagged ( ) ) { rankMe . add ( node ) ; unranked . remove ( i ) ; } else i ++ ; } if ( rankMe . size ( ) == 0 ) throw new RuntimeException ( "Cycle detected in graph" ) ; for ( i = 0 ; i < rankMe . size ( ) ; i ++ ) { node = rankMe . getNode ( i ) ; assignMinimumRank ( node ) ; node . outgoing . setFlags ( true ) ; } } connectForest ( ) ; }
te	7	public static double checkSize ( String ssize ) { final int MIN = 100 ; final int MAX = 299 ; double dsize = 0 ; if ( ssize == null || ssize . trim ( ) . length ( ) == 0 ) JOptionPane . showMessageDialog ( null , "Bitte  geben Sie eine Gr\u00F6\u00DFe in Zentimetern ein:" , "Gewichtseingabe falsch" , JOptionPane . ERROR_MESSAGE ) ; else try { dsize = double . parseDouble ( ssize ) ; } catch ( NumberFormatException nfe ) { JOptionPane . showMessageDialog ( null , "Bitte geben Sie Ihre Gr\u00F6\u00DFe nur mit Zahlen ein! \n Vewenden sie einen Punkt statt Komma!!!" , "Gewichtseingabe falsch" , JOptionPane . ERROR_MESSAGE ) ; } if ( dsize < MIN ) JOptionPane . showMessageDialog ( null , "Bitte geben Sie eine Gr\u00F6\u00DFe  gr\u00F6\u00DFer als 100 Zentimeter ein" , "Gewichtseingabe falsch" , JOptionPane . ERROR_MESSAGE ) ; else if ( dsize > MAX ) JOptionPane . showMessageDialog ( null , "Bitte geben Sie eine Gr\u00F6\u00DFe  kleiner als 300 Zentimeter ein" , "Gewichtseingabe falsch" , JOptionPane . ERROR_MESSAGE ) ; else if ( dsize < MIN || dsize > MAX ) return dsize = 0 ; return dsize ; }
te	3	private Value expression ( ) throws Exception { Value previous , rval ; previous = rval = term ( ) ; while ( scan . sym == Token . add || scan . sym == Token . - ) { Token op = scan . sym ; scan . next ( ) ; previous = rval ; Value next = term ( ) ; Instruction ins ; if ( op == Token . add ) { ins = new Add ( previous , next ) ; } else { ins = new - ( previous , next ) ; } currentBB . addInstruction ( ins ) ; rval = ins ; } return rval ; }
te	8	public Object nextValue ( ) throws JSONException { char c = nextClean ( ) ; String s ; switch ( c ) { case " : case ' : return nextString ( c ) ; case { : back ( ) ; return new JSONObject ( this ) ; case [ : case ( : back ( ) ; return new JSONArray ( this ) ; } StringBuffer sb = new StringBuffer ( ) ; while ( c >=   && " :]}/\\\"[{;=#" . indexOf ( c ) < 0 ) { sb . append ( c ) ; c = next ( ) ; } back ( ) ; s = sb . toString ( ) . trim ( ) ; if ( s . equals ( "" ) ) { throw syntaxError ( "Missing value" ) ; } return JSONObject . stringToValue ( s ) ; }
te	5	public static void decompressInternal ( String fileName , String outFileName , int skip ) { long nb = - 1 ; long start = System . currentTimeMillis ( ) ; try { BufferedInputStream in = new BufferedInputStream ( new FileInputStream ( fileName ) ) ; info ( "Skipping " + in . read ( new byte [ skip ] ) + " bytes." ) ; if ( in != null ) { CBZip2InputStream doc = new CBZip2InputStream ( in ) ; byte [ ] buffer = new byte [ BUFFER_SIZE ] ; int nbBytes = 0 ; nbBytes = doc . read ( buffer ) ; while ( nbBytes > 0 ) { nb ++ ; nbBytes = doc . read ( buffer ) ; if ( nb % 10 == 0 ) { info ( "time = " + ( System . currentTimeMillis ( ) - start ) + " ms" ) ; start = System . currentTimeMillis ( ) ; } } in . close ( ) ; } } catch ( FileNotFoundException e ) { error ( e . getMessage ( ) ) ; } catch ( IOException e ) { error ( e . getMessage ( ) ) ; } }
te	3	public Vector < Happening > createHappeningsInRange ( Calendar from , Calendar to ) { Vector < Happening > happeningsInRange = new Vector < Happening > ( ) ; try { Calendar date = getMilestone ( from ) ; double amount = getMilestone ( from ) . getValue ( ) ; happeningsInRange . addElement ( new Happening ( date , amount , "Milstolpe" ) ) ; } catch ( IllegalArgumentException iae ) { } Happening happening ; for ( int i = 0 ; i < happenings . size ( ) ; i ++ ) { happening = happenings . elementAt ( i ) ; if ( CalendarUtil . isOnOrBetween ( happening . getDate ( ) , from , to ) ) { GregorianCalendar interestCountDate = new GregorianCalendar ( ) ; interestCountDate . setTimeInMillis ( happening . getDate ( ) . getTimeInMillis ( ) ) ; happeningsInRange . addElement ( new Happening ( interestCountDate , happening . getAmount ( ) , happening . getKommentar ( ) ) ) ; } } return happeningsInRange ; }
te	7	private String createID ( ) throws RemoteException { Statement stmt = null ; ResultSet rs = null ; try { String tableName = getTableName ( ) ; String idField = getIDField ( ) ; if ( this . upper ) { tableName = tableName . toUpperCase ( ) ; idField = idField . toUpperCase ( ) ; } stmt = getConnection ( ) . createStatement ( ) ; rs = stmt . executeQuery ( "select (max(" + idField + ") + 1) from " + tableName ) ; if ( ! rs . next ( ) ) throw new SQLException ( "select max(id) returned empty resultset" ) ; return rs . getString ( 1 ) ; } catch ( SQLException e ) { throw new RemoteException ( "unable to create new insert id" , e ) ; } finally { if ( rs != null ) { try { rs . close ( ) ; } catch ( SQLException se ) { } } if ( stmt != null ) { try { stmt . close ( ) ; } catch ( SQLException se ) { } } } }
te	6	public void mouseClicked ( MouseEvent e ) { if ( game . isGameIsOver ( ) ) return ; if ( game . getGameMode ( ) == 1 ) { handleMPClick ( e ) ; return ; } else { if ( game . getTurn ( ) == 1 ) { handleSPHumanClick ( e ) ; } else { if ( game . getGameMode ( ) == 2 ) { makeEasyAIMove ( ) ; } else if ( game . getGameMode ( ) == 3 ) { makeNormalAIMove ( ) ; } else if ( game . getGameMode ( ) == 4 ) { makeAdvancedAIMove ( ) ; } } } display . updateTurnPanel ( ) ; }
te	8	public int hashCode ( ) { int _hashCode = 0 ; if ( idMsg != null ) { _hashCode = 29 * _hashCode + idMsg . hashCode ( ) ; } if ( mailer != null ) { _hashCode = 29 * _hashCode + mailer . hashCode ( ) ; } if ( recipient != null ) { _hashCode = 29 * _hashCode + recipient . hashCode ( ) ; } if ( headMsg != null ) { _hashCode = 29 * _hashCode + headMsg . hashCode ( ) ; } if ( bodyMsg != null ) { _hashCode = 29 * _hashCode + bodyMsg . hashCode ( ) ; } if ( statusMsg != null ) { _hashCode = 29 * _hashCode + statusMsg . hashCode ( ) ; } if ( typeMsg != null ) { _hashCode = 29 * _hashCode + typeMsg . hashCode ( ) ; } if ( sendOffDate != null ) { _hashCode = 29 * _hashCode + sendOffDate . hashCode ( ) ; } return _hashCode ; }
te	9	public boolean findOutIfPairEliminatesValues ( int bC1 , int bC2 , int bC3 , int bC4 , int bC5 , int bC6 , int sE ) { boolean isValida = this . isValidValueForElementWithNumber ( bC1 , sE ) ; boolean isValidb = this . isValidValueForElementWithNumber ( bC2 , sE ) ; boolean isValidc = this . isValidValueForElementWithNumber ( bC3 , sE ) ; boolean isValidd = this . isValidValueForElementWithNumber ( bC4 , sE ) ; boolean isValide = this . isValidValueForElementWithNumber ( bC5 , sE ) ; boolean isValidf = this . isValidValueForElementWithNumber ( bC6 , sE ) ; if ( ! this . elementWithNumberIsEmpty ( bC1 ) ) { isValida = false ; } if ( ! this . elementWithNumberIsEmpty ( bC2 ) ) { isValidb = false ; } if ( ! this . elementWithNumberIsEmpty ( bC3 ) ) { isValidc = false ; } if ( ! this . elementWithNumberIsEmpty ( bC4 ) ) { isValidd = false ; } if ( ! this . elementWithNumberIsEmpty ( bC5 ) ) { isValide = false ; } if ( ! this . elementWithNumberIsEmpty ( bC6 ) ) { isValidf = false ; } if ( isValida || isValidb || isValidc || isValidd || isValide || isValidf ) { this . removeValueForElementWithNumber ( bC1 , sE ) ; this . removeValueForElementWithNumber ( bC2 , sE ) ; this . removeValueForElementWithNumber ( bC3 , sE ) ; this . removeValueForElementWithNumber ( bC4 , sE ) ; this . removeValueForElementWithNumber ( bC5 , sE ) ; this . removeValueForElementWithNumber ( bC6 , sE ) ; return true ; } return false ; }
te	6	public void printBoard ( boolean [ ] [ ] b , Tuple < Integer , Integer > currentLight ) { for ( int i = 0 ; i < 100 ; i ++ ) { for ( int j = 0 ; j < 100 ; j ++ ) { if ( currentLight != null && currentLight . y == i && currentLight . x == j ) { System . err . print ( "*" ) ; } else { if ( b [ j ] [ i ] ) { System . err . print ( "." ) ; } else { System . err . print ( "#" ) ; } } } System . err . println ( ) ; } }
te	1	public DeltaRule setLearningRate ( double learningRate ) { if ( learningRate <= 0 ) throw new IllegalArgumentException ( "Must be greater than 0" ) ; this . learningRate = learningRate ; return this ; }
te	5	@ Override protected void paintComponent ( Graphics g ) { super . paintComponent ( g ) ; Graphics2D g2d = DrawingTools . setupGraphics ( g ) ; Integer radius = DEFAULT_RADIUS ; switch ( mark . getType ( ) ) { case normal : radius = NORMAL_RADIUS ; g2d . setColor ( NORMAL_COLOR ) ; break ; case boat : radius = BOAT_RADIUS ; g2d . setColor ( BOAT_COLOR ) ; break ; case city : radius = CITY_RADIUS ; g2d . setColor ( RING_COLOR ) ; g2d . fillOval ( ( SIZE / 2 ) - radius , ( SIZE / 2 ) - radius , 2 * radius , 2 * radius ) ; radius = CITY_RADIUS - 2 ; g2d . setColor ( CITY_COLOR ) ; break ; case start : radius = START_RADIUS ; g2d . setColor ( START_COLOR ) ; break ; default : g2d . setColor ( DEFAULT_COLOR ) ; break ; } g2d . fillOval ( ( SIZE / 2 ) - radius , ( SIZE / 2 ) - radius , 2 * radius , 2 * radius ) ; if ( mark . isSelected ( ) ) { g2d . setStroke ( new BasicStroke ( 3 ) ) ; g2d . setColor ( SELECT_COLOR ) ; g2d . drawOval ( 0 , 0 , SIZE , SIZE ) ; } }
te	4	AtomChar ( String value ) { if ( value . startsWith ( "#\\" ) ) { value = value . substring ( 2 ) ; } if ( value . equals ( SPACE ) ) { this . value =   ; } else if ( value . equals ( TAB ) ) { this . value = 	 ; } else if ( value . equals ( NEWLINE ) ) { this . value = '' ; } else { this . value = value . charAt ( 0 ) ; } }
te	1	public void stop ( ) { if ( timer != null ) { timer . purge ( ) ; timer . cancel ( ) ; timer = null ; } }
te	7	private boolean isValido ( ) { if ( ( ! tfHost . getText ( ) . equals ( "" ) ) && ( ! tfUsuario . getText ( ) . equals ( "" ) ) && ( pfSenha . getPassword ( ) . length != 0 ) && ( ! snPorta . getValue ( ) . equals ( "" ) ) ) { return true ; } else { lbCampos . setText ( "Os campos em vermelho s\u00E3o obrigat\u00F3rios!" ) ; lbCampos . setVisible ( true ) ; if ( tfHost . getText ( ) . equals ( "" ) ) { tfHost . setBorder ( new LineBorder ( new Color ( 255 , 0 , 0 ) , 1 , true ) ) ; } if ( tfUsuario . getText ( ) . equals ( "" ) ) { tfUsuario . setBorder ( new LineBorder ( new Color ( 255 , 0 , 0 ) , 1 , true ) ) ; } if ( pfSenha . getPassword ( ) . length == 0 ) { pfSenha . setBorder ( new LineBorder ( new Color ( 255 , 0 , 0 ) , 1 , true ) ) ; } return false ; } }
te	4	@ Override public int compare ( Point point1 , Point point2 ) { if ( point1 . y < point2 . y ) { return - 1 ; } else if ( point1 . y > point2 . y ) { return 1 ; } else if ( point1 . x < point2 . x ) { return - 1 ; } else if ( point1 . x > point2 . x ) { return 1 ; } return 0 ; }
te	9	public void method305 ( int i , int k , int i1 ) { int j = 64 ; int l = 768 ; int j1 = ( int ) Math . sqrt ( k * k + i * i + i1 * i1 ) ; int k1 = l * j1 >> 8 ; for ( int l1 = 0 ; l1 < anInt437 ; l1 ++ ) { for ( int i2 = 0 ; i2 < anInt438 ; i2 ++ ) { for ( int j2 = 0 ; j2 < anInt439 ; j2 ++ ) { Ground class30_sub3 = groundArray [ l1 ] [ i2 ] [ j2 ] ; if ( class30_sub3 != null ) { Object1 class10 = class30_sub3 . obj1 ; if ( class10 != null && class10 . aClass30_Sub2_Sub4_278 != null && class10 . aClass30_Sub2_Sub4_278 . aClass33Array1425 != null ) { method307 ( l1 , 1 , 1 , i2 , j2 , ( Model ) class10 . aClass30_Sub2_Sub4_278 ) ; if ( class10 . aClass30_Sub2_Sub4_279 != null && class10 . aClass30_Sub2_Sub4_279 . aClass33Array1425 != null ) { method307 ( l1 , 1 , 1 , i2 , j2 , ( Model ) class10 . aClass30_Sub2_Sub4_279 ) ; method308 ( ( Model ) class10 . aClass30_Sub2_Sub4_278 , ( Model ) class10 . aClass30_Sub2_Sub4_279 , 0 , 0 , 0 , false ) ; ( ( Model ) class10 . aClass30_Sub2_Sub4_279 ) . method480 ( j , k1 , k , i , i1 ) ; } ( ( Model ) class10 . aClass30_Sub2_Sub4_278 ) . method480 ( j , k1 , k , i , i1 ) ; } for ( int k2 = 0 ; k2 < class30_sub3 . anInt1317 ; k2 ++ ) { Object5 class28 = class30_sub3 . obj5Array [ k2 ] ; if ( class28 != null && class28 . aClass30_Sub2_Sub4_521 != null && class28 . aClass30_Sub2_Sub4_521 . aClass33Array1425 != null ) { method307 ( l1 , ( class28 . anInt524 - class28 . anInt523 ) + 1 , ( class28 . anInt526 - class28 . anInt525 ) + 1 , i2 , j2 , ( Model ) class28 . aClass30_Sub2_Sub4_521 ) ; ( ( Model ) class28 . aClass30_Sub2_Sub4_521 ) . method480 ( j , k1 , k , i , i1 ) ; } } Object3 class49 = class30_sub3 . obj3 ; if ( class49 != null && class49 . aClass30_Sub2_Sub4_814 . aClass33Array1425 != null ) { method306 ( i2 , l1 , ( Model ) class49 . aClass30_Sub2_Sub4_814 , j2 ) ; ( ( Model ) class49 . aClass30_Sub2_Sub4_814 ) . method480 ( j , k1 , k , i , i1 ) ; } } } } } }
te	8	private int getSize ( BoundSize uvs , int sizeType , boolean isHor , int sizeHint ) { if ( uvs == null || uvs . getSize ( sizeType ) == null ) { switch ( sizeType ) { case LayoutUtil . MIN : return isHor ? comp . getMinimumWidth ( sizeHint ) : comp . getMinimumHeight ( sizeHint ) ; case LayoutUtil . PREF : return isHor ? comp . getPreferredWidth ( sizeHint ) : comp . getPreferredHeight ( sizeHint ) ; default : return isHor ? comp . getMaximumWidth ( sizeHint ) : comp . getMaximumHeight ( sizeHint ) ; } } ContainerWrapper par = comp . getParent ( ) ; return uvs . getSize ( sizeType ) . getPixels ( isHor ? par . getWidth ( ) : par . getHeight ( ) , par , comp ) ; }
te	8	public int trap ( int [ ] A ) { int sum = 0 ; if ( A == null || A . length == 0 ) { return 0 ; } int [ ] leftHigh = new int [ A . length ] ; int [ ] rightHigh = new int [ A . length ] ; int currentHeigh = A [ 0 ] ; for ( int i = 1 ; i < A . length ; i ++ ) { leftHigh [ i ] = currentHeigh ; if ( A [ i ] > currentHeigh ) { currentHeigh = A [ i ] ; } } currentHeigh = A [ A . length - 1 ] ; for ( int i = A . length - 2 ; i >= 0 ; i -- ) { rightHigh [ i ] = currentHeigh ; if ( A [ i ] > currentHeigh ) { currentHeigh = A [ i ] ; } } for ( int i = 0 ; i < A . length ; i ++ ) { int fillHeightAvailable = Math . min ( leftHigh [ i ] , rightHigh [ i ] ) ; if ( fillHeightAvailable > A [ i ] ) { sum += fillHeightAvailable - A [ i ] ; } } return sum ; }
