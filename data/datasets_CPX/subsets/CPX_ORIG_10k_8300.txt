te	6	String toString ( int indentFactor , int indent ) throws JSONException { int len = length ( ) ; if ( len == 0 ) { return "[]" ; } int i ; StringBuffer sb = new StringBuffer ( "[" ) ; if ( len == 1 ) { sb . append ( JSONObject . valueToString ( this . myArrayList . get ( 0 ) , indentFactor , indent ) ) ; } else { int newindent = indent + indentFactor ; sb . append ( '' ) ; for ( i = 0 ; i < len ; i += 1 ) { if ( i > 0 ) { sb . append ( " \n" ) ; } for ( int j = 0 ; j < newindent ; j += 1 ) { sb . append (   ) ; } sb . append ( JSONObject . valueToString ( this . myArrayList . get ( i ) , indentFactor , newindent ) ) ; } sb . append ( '' ) ; for ( i = 0 ; i < indent ; i += 1 ) { sb . append (   ) ; } } sb . append ( ] ) ; return sb . toString ( ) ; }
te	5	void button_load_clicked ( ) { FileDialog dialog = new FileDialog ( new Frame ( ) , "Load" , FileDialog . LOAD ) ; dialog . setVisible ( true ) ; String filename = dialog . getDirectory ( ) + dialog . getFile ( ) ; if ( filename == null ) return ; clear_all ( ) ; try { BufferedReader fp = new BufferedReader ( new FileReader ( filename ) ) ; String line ; while ( ( line = fp . readLine ( ) ) != null ) { StringTokenizer st = new StringTokenizer ( line , " \t\n\r\f:" ) ; if ( st . countTokens ( ) == 5 ) { byte value = ( byte ) atoi ( st . nextToken ( ) ) ; st . nextToken ( ) ; double x = atof ( st . nextToken ( ) ) ; st . nextToken ( ) ; double y = atof ( st . nextToken ( ) ) ; point_list . addElement ( new point ( x , y , value ) ) ; } else if ( st . countTokens ( ) == 3 ) { double y = atof ( st . nextToken ( ) ) ; st . nextToken ( ) ; double x = atof ( st . nextToken ( ) ) ; point_list . addElement ( new point ( x , y , current_value ) ) ; } else break ; } fp . close ( ) ; } catch ( IOException e ) { System . err . print ( e ) ; } draw_all_points ( ) ; }
te	6	@ Override public void setToNative ( long i , Object o ) { if ( o == null ) { stringLengths . setShort ( i , ( short ) - 1 ) ; } else { if ( ! ( o instanceof String ) ) { throw new IllegalArgumentException ( o + " is not a string." ) ; } String s = ( String ) o ; if ( s . length ( ) > maxStringLength ) { throw new IllegalArgumentException ( "String  " + s + " is too long." ) ; } byte [ ] tmp ; try { tmp = s . getBytes ( CHARSET ) ; } catch ( UnsupportedEncodingException ex ) { return ; } int strLen = tmp . length ; if ( strLen > short . MAX_VALUE ) { throw new IllegalArgumentException ( "String  " + s + " is too long." ) ; } stringLengths . setShort ( i , ( short ) strLen ) ; long offset = sizeof * i * maxStringLength * CHARSET_SIZE ; for ( int j = 0 ; j < strLen ; j ++ ) { Utilities . UNSAFE . putByte ( ptr + offset + sizeof * j , tmp [ j ] ) ; } } }
te	7	public void animateMining ( World world , Point2 targetLocation ) { int currentFrame = sprite . currentFrame ; switch ( entity . orientation ) { case NORTH : sprite . animate ( 36 , 4 , Constants . DWARF_ANIMATION_SPEED / 2 ) ; break ; default : sprite . animate ( 32 , 4 , Constants . DWARF_ANIMATION_SPEED / 2 ) ; break ; } if ( sprite . currentFrame != currentFrame && sprite . currentFrame % 8 % 3 == 0 ) { if ( entity . playerId . intValue ( ) == GameCore . playerId ) GameLoop . soundBank . playSound ( SoundBank . pickaxeSound , true ) ; if ( random . nextDouble ( ) < .3 ) { Point2 miningLocation = new Point2 ( location . x , location . y ) ; miningLocation . move ( entity . orientation ) ; if ( ( world . temporaryAnimatedSprites . size ( ) < 100 ) || ( entity . playerId . intValue ( ) == GameCore . playerId ) ) { world . temporaryAnimatedSprites . add ( new SolitaryAnimatedSprite ( 20 , 4 , 5 , miningLocation . x * Constants . TILE_BASE_WIDTH + random . nextInt ( 24 ) - 12 , miningLocation . y * Constants . TILE_BASE_HEIGHT - 32 + random . nextInt ( 24 ) - 12 ) ) ; } } } }
te	4	private Answer handleQuery ( Query query ) { Answer result ; switch ( query . type ( ) ) { case PUT : table . put ( Bytes . wrap ( query . key ( ) ) , Bytes . wrap ( query . value ( ) ) ) ; result = new Answer ( Status . OK ) ; break ; case GET : Nullable < Entry > entry = get ( Bytes . wrap ( query . key ( ) ) ) ; if ( ! entry . isNull ( ) ) { result = new Answer ( Status . OK , entry . data ( ) . value ( ) . getBytes ( ) ) ; } else { result = new Answer ( Status . OK , Node . NOTHING_MARK . getBytes ( ) ) ; } break ; case DELETE : table . put ( Bytes . wrap ( query . key ( ) ) , Bytes . wrap ( Node . TOMBSTONE ) ) ; default : result = new Answer ( Status . OK ) ; } return result ; }
te	7	private void downloadSW ( String url ) { String fileSizeString = "" ; long fileSize = 1 ; _percent = 0 ; try { _builder = new ProcessBuilder ( _downloadcmd , "-c" , "--progress=bar" , url ) ; _builder = _builder . redirectErrorStream ( true ) ; _process = _builder . start ( ) ; InputStream stdout = _process . getInputStream ( ) ; BufferedReader stdoutBuffered = new BufferedReader ( new InputStreamReader ( stdout ) ) ; String line = null ; boolean calculatePercentage = false ; while ( ( line = stdoutBuffered . readLine ( ) ) != null ) { if ( line . startsWith ( "Length:" ) ) { int k = 8 ; while ( line . charAt ( k ) !=   ) { k ++ ; } fileSizeString = line . substring ( 8 , k ) ; fileSize = Integer . parseInt ( fileSizeString ) ; calculatePercentage = true ; } if ( calculatePercentage == true ) { File urlFile = new File ( url ) ; File file = new File ( urlFile . getName ( ) ) ; _percent = ( int ) ( ( file . length ( ) * 100 ) / fileSize ) ; } } if ( calculatePercentage == false ) { _percent = 100 ; } _result = _process . waitFor ( ) ; _process . destroy ( ) ; } catch ( IOException | InterruptedException e ) { if ( e . getMessage ( ) == "Stream closed" ) { } else { e . printStackTrace ( ) ; } } }
te	3	public static final String titleCase ( String in ) { String s = in . toLowerCase ( ) ; StringBuilder titlecase = new StringBuilder ( ) ; boolean nextTitleCase = true ; for ( char c : s . toCharArray ( ) ) { if ( Character . isSpaceChar ( c ) ) { nextTitleCase = true ; } else if ( nextTitleCase ) { c = Character . toTitleCase ( c ) ; nextTitleCase = false ; } titlecase . append ( c ) ; } return titlecase . toString ( ) ; }
te	8	static float lpc_from_data ( float [ ] data , float [ ] lpc , int n , int m ) { float [ ] aut = new float [ m + 1 ] ; float error ; int i , j ; j = m + 1 ; while ( j -- != 0 ) { float d = 0 ; for ( i = j ; i < n ; i ++ ) d += data [ i ] * data [ i - j ] ; aut [ j ] = d ; } error = aut [ 0 ] ; for ( i = 0 ; i < m ; i ++ ) { float r = - aut [ i + 1 ] ; if ( error == 0 ) { for ( int k = 0 ; k < m ; k ++ ) lpc [ k ] = 0.0f ; return 0 ; } for ( j = 0 ; j < i ; j ++ ) r -= lpc [ j ] * aut [ i - j ] ; r /= error ; lpc [ i ] = r ; for ( j = 0 ; j < i / 2 ; j ++ ) { float tmp = lpc [ j ] ; lpc [ j ] += r * lpc [ i - 1 - j ] ; lpc [ i - 1 - j ] += r * tmp ; } if ( i % 2 != 0 ) lpc [ j ] += lpc [ j ] * r ; error *= 1.0 - r * r ; } return error ; }
te	7	@ Override public void call ( VGame vg , VObject vo , String ... args ) { if ( args [ 0 ] . equals ( "move" ) ) { if ( vg . player == vo . gi ( "ow" ) ) { vo . s ( "!tx" , args [ 1 ] ) ; vo . s ( "!ty" , args [ 2 ] ) ; vo . s ( "!ax" , args [ 1 ] ) ; vo . s ( "!ay" , args [ 2 ] ) ; vo . s ( "!atk" , "no" ) ; } } if ( args [ 0 ] . equals ( "hit" ) ) { vo . s ( "hp" , vo . gi ( "hp" ) - Integer . valueOf ( args [ 1 ] ) ) ; } if ( args [ 0 ] . equals ( "attack" ) ) { if ( vg . player == vo . gi ( "ow" ) ) { vo . s ( "!ax" , args [ 1 ] ) ; vo . s ( "!ay" , args [ 2 ] ) ; vo . s ( "!atk" , "yep" ) ; } } if ( args [ 0 ] . equals ( "buildunit" ) ) { if ( vg . player == vo . gi ( "ow" ) ) { vo . s ( "!cst" , args [ 1 ] ) ; vo . s ( "!std" , vg . type ( args [ 1 ] ) . gi ( "ptime" ) ) ; } } }
te	5	@ Override public void modifyElevFromClasa ( Clasa c , Elev elev_vechi , Elev elev_nou ) { ArrayList < Elev > list = c . getElevi ( ) ; boolean ok = false ; int index = 0 ; for ( Iterator < Elev > it = list . iterator ( ) ; it . hasNext ( ) ; ) { Elev elev = it . next ( ) ; if ( elev . getCNP ( ) . equals ( elev_vechi . getCNP ( ) ) ) { index = list . indexOf ( elev ) ; it . remove ( ) ; ok = true ; break ; } } if ( ! ok ) { String nume_prenume = elev_vechi . getNume ( ) + " " + elev_vechi . getPrenume ( ) ; for ( Iterator < Elev > it = list . iterator ( ) ; it . hasNext ( ) ; ) { Elev elev = it . next ( ) ; if ( nume_prenume . equals ( elev_nou . getNume ( ) + " " + elev_nou . getPrenume ( ) ) ) { index = list . indexOf ( elev ) ; it . remove ( ) ; ok = true ; break ; } } } list . add ( index , elev_nou ) ; c . setElevi ( list ) ; }
te	0	public void setPane ( GravityPane gp ) { }
te	0	@ Override public Map < Name , String > getMainAttributes ( ) { return Collections . unmodifiableMap ( attributes ) ; }
te	7	public void show ( ) { Scanner scan = new Scanner ( System . in ) ; int choice = 0 ; while ( choice != 4 ) { System . out . println ( "==============" ) ; System . out . println ( "  Movie Menu  " ) ; System . out . println ( "==============" ) ; System . out . println ( "1) Create Movie" ) ; System . out . println ( "2) Update Movie" ) ; System . out . println ( "3) Remove Movie" ) ; System . out . println ( "4) Back" ) ; System . out . print ( "Please enter your choice : " ) ; choice = scan . nextInt ( ) ; if ( choice > 4 || choice < 1 ) { System . out . println ( "Invalid choice" ) ; continue ; } switch ( choice ) { case 1 : createMovie ( ) ; break ; case 2 : updateMovie ( ) ; break ; case 3 : removeMovie ( ) ; break ; case 4 : return ; } } }
te	4	private static List < Integer > binomialCongruenceSolve ( final int n , final int a , final int m , final int maxSolutions ) { final List < Integer > result = new ArrayList < > ( ) ; for ( int i = 0 ; i < m ; ++ i ) { if ( modPow ( i , n , m ) == a ) { result . add ( i ) ; if ( result . size ( ) == maxSolutions ) break ; } } if ( ! result . isEmpty ( ) ) result . add ( m ) ; return binomialCongruenceRuleOut ( result ) ; }
te	8	@ Override public void render ( Graphics g , Visibility visibility , float x , float y , float scale ) { if ( visibility == Visibility . VISIBLE ) { boolean hasSomeEntities = occupying . size ( ) > 0 ; boolean hasSomeEntering = entering . size ( ) > 0 ; boolean hasSomeLeaving = leaving . size ( ) > 0 ; if ( hasSomeEntities ) { if ( hasSomeEntering && hasSomeLeaving ) g . setColor ( new Color ( 255 , 150 , 255 ) ) ; else if ( hasSomeEntering ) g . setColor ( new Color ( 100 , 255 , 255 ) ) ; else if ( hasSomeLeaving ) g . setColor ( new Color ( 255 , 100 , 100 ) ) ; else g . setColor ( new Color ( 255 , 255 , 255 ) ) ; } else if ( hasSomeEntering ) { g . setColor ( new Color ( 0 , 85 , 85 ) ) ; } else if ( hasSomeLeaving ) { g . setColor ( new Color ( 85 , 0 , 0 ) ) ; } else { g . setColor ( new Color ( 0 , 0 , 0 ) ) ; } g . fillRect ( x - level . getTileWidth ( ) / 2 * scale , y - level . getTileHeight ( ) / 2 * scale , level . getTileWidth ( ) * scale , level . getTileHeight ( ) * scale ) ; g . setColor ( Color . gray ) ; g . setLineWidth ( 1 ) ; g . drawRect ( x - level . getTileWidth ( ) / 2 * scale , y - level . getTileHeight ( ) / 2 * scale , level . getTileWidth ( ) * scale , level . getTileHeight ( ) * scale ) ; } }
te	2	public void addLinearRing ( LinearRing value ) { if ( this . geometry != null ) { markDeletedNode ( this . geometry ) ; } this . geometry = value ; if ( value != null ) { value . setParent ( this ) ; markCreatedNode ( value ) ; } }
te	3	private ContainerWrapper checkParent ( Container parent ) { if ( parent == null ) return null ; if ( cacheParentW == null || cacheParentW . getComponent ( ) != parent ) cacheParentW = new SwingContainerWrapper ( parent ) ; return cacheParentW ; }
te	7	private static boolean KawigiEdit_RunTest ( int testNum , String [ ] p0 , int p1 , boolean hasAnswer , int p2 ) { System . out . print ( "Test " + testNum + ": [" + "{" ) ; for ( int i = 0 ; p0 . length > i ; ++ i ) { if ( i > 0 ) { System . out . print ( " " ) ; } System . out . print ( "\"" + p0 [ i ] + "\"" ) ; } System . out . print ( "}" + " " + p1 ) ; System . out . println ( "]" ) ; BuildingRoutes obj ; int answer ; obj = new BuildingRoutes ( ) ; long startTime = System . currentTimeMillis ( ) ; answer = obj . build ( p0 , p1 ) ; long endTime = System . currentTimeMillis ( ) ; boolean res ; res = true ; System . out . println ( "Time: " + ( endTime - startTime ) / 1000.0 + " seconds" ) ; if ( hasAnswer ) { System . out . println ( "Desired answer:" ) ; System . out . println ( "\t" + p2 ) ; } System . out . println ( "Your answer:" ) ; System . out . println ( "\t" + answer ) ; if ( hasAnswer ) { res = answer == p2 ; } if ( ! res ) { System . out . println ( "DOESN'T MATCH!!!!" ) ; } else if ( ( endTime - startTime ) / 1000.0 >= 2 ) { System . out . println ( "FAIL the timeout" ) ; res = false ; } else if ( hasAnswer ) { System . out . println ( "Match :-)" ) ; } else { System . out . println ( "OK  but is it right?" ) ; } System . out . println ( "" ) ; return res ; }
te	7	private static void test7 ( ) throws FileNotFoundException { String input = "new\n" + "pick up key\n" + "wait\n" + "unlock door with key\n" + "go through cell door\n" + "quit\n" + "y\n" ; HashMap < Integer , String > output = new HashMap < Integer , String > ( ) ; boolean passed = true ; try { in = new ByteArrayInputStream ( input . getBytes ( ) ) ; System . setIn ( in ) ; out = new PrintStream ( "testing.txt" ) ; System . setOut ( out ) ; Game . main ( null ) ; } catch ( ExitException se ) { } catch ( Exception e ) { System . setOut ( stdout ) ; System . out . println ( "Error: " ) ; e . printStackTrace ( ) ; passed = false ; } finally { System . setOut ( stdout ) ; @ SuppressWarnings ( "resource" ) Scanner sc = new Scanner ( new File ( "testing.txt" ) ) ; ArrayList < String > testOutput = new ArrayList < String > ( ) ; while ( sc . hasNextLine ( ) ) { testOutput . add ( sc . nextLine ( ) ) ; } output . put ( 13 , "The guard walks toward your cell." ) ; output . put ( 14 , ">> Some time goes by." ) ; output . put ( 15 , "The guard peers into the cell  checking that the door is secured  then continues on." ) ; output . put ( 18 , ">> You walk through the cell door." ) ; output . put ( 21 , "The guard walks away from your cell." ) ; output . put ( 22 , "You escape silently into the shadows." ) ; output . put ( 23 , "YOU WON!" ) ; output . put ( testOutput . size ( ) - 1 , ">>" ) ; if ( passed ) { for ( Map . Entry < Integer , String > entry : output . entrySet ( ) ) { if ( ! testOutput . get ( entry . getKey ( ) ) . equals ( entry . getValue ( ) ) ) { passed = false ; System . out . println ( "test7 failed: Line " + entry . getKey ( ) ) ; System . out . println ( "\tExpected: " + entry . getValue ( ) ) ; System . out . println ( "\tReceived: " + testOutput . get ( entry . getKey ( ) ) ) ; } } if ( passed ) { System . out . println ( "test7 passed" ) ; } } else { System . out . println ( "test7 failed: error" ) ; } } }
te	0	public void setCampaignId ( long campaignId ) { this . campaignId = campaignId ; }
te	2	public boolean onCommand ( CommandSender sender , Command command , String label , String [ ] args ) { if ( ! plugin . hasPerm ( sender , "broadcast" , true ) ) { sender . sendMessage ( ChatColor . YELLOW + "You do not have permission to use /" + label ) ; return true ; } if ( args . length == 0 ) return false ; String msg = plugin . message ( args ) ; plugin . getServer ( ) . broadcastMessage ( ChatColor . RED + "[Broadcast] " + ChatColor . YELLOW + plugin . colorizeText ( msg ) ) ; return true ; }
te	5	private synchronized void start ( ) throws Exception { BufferedReader readMe = new BufferedReader ( new FileReader ( "rels2" ) ) ; InputIterable < String > iterable = new CSVInputIterable ( readMe ) ; Hasher hasher = new TrainableTwoStreamHasher ( iterable ) ; WrappedString . setHasher ( hasher ) ; readMe = new BufferedReader ( new FileReader ( "rels2" ) ) ; iterable = new CSVInputIterable ( readMe ) ; ArrayHashMapOptionFactory fac = new ArrayHashMapOptionFactory ( new File ( "target/testRun" ) ) ; LeastRecentlyUsed < WrappedString > strategy = new LeastRecentlyUsed < WrappedString > ( ) ; store = new PartitionedHashMap ( fac , strategy ) ; tracker . launch ( ) ; long line = 0 ; for ( ParseResult < String > result : iterable ) { if ( line % 25000 == 0 ) { System . out . println ( "line is " + line ) ; } synchronized ( store ) { if ( store . get ( result . getFirstNode ( ) ) == null ) { store . put ( result . getFirstNode ( ) , line ) ; } if ( store . get ( result . getSecondNode ( ) ) == null ) { store . put ( result . getSecondNode ( ) , line ) ; } } line ++ ; if ( line > 2500000 ) break ; } }
te	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( frmPrincipal21 . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( frmPrincipal21 . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( frmPrincipal21 . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( frmPrincipal21 . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { new frmPrincipal21 ( ) . setVisible ( true ) ; } } ) ; }
te	4	public Event [ ] getEventsForDate ( Calendar date ) { Vector < Event > temp = new Vector < Event > ( ) ; for ( Event e : events ) { if ( JSDateUtil . isSameDate ( e . date , date ) ) { temp . add ( e ) ; } } if ( temp . size ( ) > 0 ) { Event [ ] array = new Event [ temp . size ( ) ] ; for ( int i = 0 ; i < temp . size ( ) ; i ++ ) { array [ i ] = temp . get ( i ) ; } return array ; } else return null ; }
te	2	public Teacher getTeacher ( int id ) { Teacher teacher = null ; try { PreparedStatement ps = con . prepareStatement ( "SELECT * FROM teacher WHERE id=?" ) ; ps . setInt ( 1 , id ) ; ResultSet rs = ps . executeQuery ( ) ; if ( rs . next ( ) ) { teacher = getTeacherFromRS ( rs ) ; } ps . close ( ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; } return teacher ; }
te	7	public Path < DirectedGraphNode > search ( final DirectedGraphNode source , final DirectedGraphNode target , final WeightFunction < DirectedGraphNode > w ) { OPEN . clear ( ) ; GSCORE . clear ( ) ; PARENT . clear ( ) ; OPEN . add ( source , 0.0 ) ; GSCORE . put ( source , 0.0 ) ; PARENT . put ( source , null ) ; CLOSED . clear ( ) ; final int TARGET_REGION_NUMBER = regionMap . get ( target ) ; while ( OPEN . isEmpty ( ) == false ) { final DirectedGraphNode current = OPEN . extractMinimum ( ) ; if ( current . equals ( target ) ) { return PathFinder . < DirectedGraphNode > constructPath ( target , PARENT ) ; } CLOSED . add ( current ) ; for ( final DirectedGraphNode child : current ) { if ( CLOSED . contains ( child ) ) { continue ; } if ( ! arcFlags . get ( current , child ) . get ( TARGET_REGION_NUMBER ) ) { continue ; } double tmpg = GSCORE . get ( current ) + w . get ( current , child ) ; if ( GSCORE . containsKey ( child ) == false ) { GSCORE . put ( child , tmpg ) ; PARENT . put ( child , current ) ; OPEN . add ( child , tmpg ) ; } else if ( GSCORE . get ( child ) > tmpg ) { GSCORE . put ( child , tmpg ) ; PARENT . put ( child , current ) ; OPEN . decreasePriority ( child , tmpg ) ; } } } return Path . NO_PATH ; }
te	3	private void expect ( String what ) throws ParserException { Token next = nextToken ( ) ; if ( next == null || next . getType ( ) == ExpressionLexer . EOF ) { throw new ParserException ( "Expected " + what + " but EOF" ) ; } if ( ! what . equals ( next . getVal ( ) ) ) { throw new ParserException ( "Expected " + what + " but found " + next . getVal ( ) ) ; } }
te	3	public void actionPerformed ( ActionEvent arg0 ) { if ( arg0 . getSource ( ) == view . getBoutonJouer ( ) ) { fenetre . changerVue ( new ChoixModeView ( ) ) ; } else if ( arg0 . getSource ( ) == view . getBoutonOptions ( ) ) { fenetre . changerVue ( new OptionsView ( ) ) ; } else if ( arg0 . getSource ( ) == view . getBoutonCredits ( ) ) { fenetre . changerVue ( new CreditsView ( ) ) ; } }
te	4	public int getTileByColor ( int col ) { switch ( col ) { case Tile . GRASS_COL : return 1 ; case Tile . WALL_COL : return 2 ; case Tile . WATER_COL : return 4 ; case Tile . SPAWN_COL : return 10 ; default : return 0 ; } }
te	7	private User getUser ( CommandLine cmd ) { User user = null ; Address address = getAddress ( cmd ) ; Contact contact = getContact ( cmd ) ; if ( cmd . hasOption ( "first_name" ) || cmd . hasOption ( "last_name" ) || cmd . hasOption ( "cc_number" ) || cmd . hasOption ( "expiration_date" ) || cmd . hasOption ( "security_code" ) || contact != null || address != null ) { user = new User ( ) ; user . setAddress ( address ) ; user . setContact ( contact ) ; user . setCcCode ( cmd . getOptionValue ( "cc_number" ) ) ; user . setExpirationDate ( GenericUtility . getDate ( cmd . getOptionValue ( "expiration_date" ) ) ) ; user . setFirstName ( cmd . getOptionValue ( "first_name" ) ) ; user . setLastName ( cmd . getOptionValue ( "last_name" ) ) ; user . setSecurityCode ( cmd . getOptionValue ( "security_code" ) ) ; } return user ; }
te	0	public int getApCost ( ) { return apCost ; }
te	1	public String toString ( ) { return getValue ( ) ? "true" : "false" ; }
te	2	synchronized static void clearTemporaryBounds ( Object layout ) { for ( int i = LAYOUTS . size ( ) - 1 ; i >= 0 ; i -- ) { Object l = LAYOUTS . get ( i ) . get ( ) ; if ( l == layout ) { VALUES_TEMP . get ( i ) . clear ( ) ; return ; } } }
te	0	public void draw ( float x , float y ) { GL11 . glTranslatef ( x , y , 0 ) ; GL13 . glActiveTexture ( GL13 . GL_TEXTURE0 ) ; GL11 . glEnable ( GL11 . GL_TEXTURE_2D ) ; GL11 . glBindTexture ( GL11 . GL_TEXTURE_2D , tex1 . getTextureID ( ) ) ; GL13 . glActiveTexture ( GL13 . GL_TEXTURE1 ) ; GL11 . glEnable ( GL11 . GL_TEXTURE_2D ) ; GL11 . glBindTexture ( GL11 . GL_TEXTURE_2D , tex2 . getTextureID ( ) ) ; GL11 . glBegin ( SGL . GL_QUADS ) ; drawEmbedded ( 0 , 0 , tex1 . getImageWidth ( ) , tex1 . getImageHeight ( ) ) ; GL11 . glEnd ( ) ; GL11 . glTranslatef ( - x , - y , 0 ) ; GL13 . glActiveTexture ( GL13 . GL_TEXTURE1 ) ; GL11 . glDisable ( GL11 . GL_TEXTURE_2D ) ; GL13 . glActiveTexture ( GL13 . GL_TEXTURE0 ) ; GL11 . glDisable ( GL11 . GL_TEXTURE_2D ) ; GL11 . glEnable ( GL11 . GL_TEXTURE_2D ) ; }
te	4	public static double sum ( boolean removeNA , double [ ] array ) { double [ ] withoutNA = removeNA ? removeNA ( array ) : array ; double result = 0.0 ; for ( double d : withoutNA ) if ( ! removeNA || d != double . NaN ) result += d ; return result ; }
te	1	public static String deserializeString ( File file ) throws IOException { int len ; char [ ] chr = new char [ 4096 ] ; final StringBuffer buffer = new StringBuffer ( ) ; final InputStreamReader reader = new InputStreamReader ( new FileInputStream ( file ) , "UTF-8" ) ; try { while ( ( len = reader . read ( chr ) ) > 0 ) { buffer . append ( chr , 0 , len ) ; } } finally { reader . close ( ) ; } return buffer . toString ( ) ; }
te	6	public boolean validateNewData ( int x , int y , int width , int height , int iWidth , int iHeight ) { if ( x < 0 || y < 0 || width < 0 || height < 0 ) { return false ; } if ( x + width > iWidth || y + height > iHeight ) { return false ; } return true ; }
te	0	public Song getSong ( ) { return song ; }
te	0	public void setEmprunts ( LinkedList < Emprunt > emprunts ) { _emprunts = emprunts ; }
te	4	public final boolean canUseCommand ( final CommandSender sender , final String command , final boolean checkPlayer , final boolean checkPermissions ) { final IUser user = AllAdmin . getUser ( sender . getName ( ) ) ; if ( checkPermissions && ! user . canUseCommand ( command ) ) { user . sendCommandFaliure ( command , "noPermissions" ) ; return false ; } if ( checkPlayer && ! ( sender instanceof Player ) ) { user . sendCommandFaliure ( command , "mustBePlayer" ) ; return false ; } return true ; }
te	0	@ Override public void setView ( CardCreateView view ) { this . view = view ; }
te	2	public int getNumberOfSell ( ) { int count = 0 ; for ( GeneratedSignal gs : genSigList ) { if ( gs . getType ( ) . equals ( "sell" ) ) { count ++ ; } } return count ; }
te	1	public LoginPanel ( ) { lblStatus = new JLabel ( "   " ) ; lblStatus . setForeground ( Color . RED ) ; lblStatus . setFont ( new Font ( lblStatus . getFont ( ) . getName ( ) , lblStatus . getFont ( ) . getStyle ( ) , 11 ) ) ; JLabel lblUsername = new JLabel ( "Brukernavn:" ) , lblPassword = new JLabel ( "Passord:" ) ; txtUsername = new JTextField ( "" , 20 ) ; txtPassword = new JPasswordField ( "" , 20 ) ; loginButton = new JButton ( "Logg inn" ) ; loginButton . setMinimumSize ( new Dimension ( txtPassword . getPreferredSize ( ) . width , loginButton . getMinimumSize ( ) . height ) ) ; GroupLayout layout = new GroupLayout ( this ) ; this . setLayout ( layout ) ; layout . setAutoCreateGaps ( true ) ; layout . setAutoCreateContainerGaps ( true ) ; layout . setHorizontalGroup ( layout . createSequentialGroup ( ) . addGroup ( layout . createParallelGroup ( GroupLayout . Alignment . LEADING ) . addComponent ( lblUsername ) . addComponent ( lblPassword ) ) . addGroup ( layout . createParallelGroup ( GroupLayout . Alignment . LEADING ) . addComponent ( lblStatus ) . addComponent ( txtUsername ) . addComponent ( txtPassword ) . addComponent ( loginButton ) ) ) ; layout . setVerticalGroup ( layout . createSequentialGroup ( ) . addComponent ( lblStatus ) . addGroup ( layout . createParallelGroup ( GroupLayout . Alignment . LEADING ) . addComponent ( lblUsername ) . addComponent ( txtUsername ) ) . addGroup ( layout . createParallelGroup ( GroupLayout . Alignment . LEADING ) . addComponent ( lblPassword ) . addComponent ( txtPassword ) ) . addComponent ( loginButton ) ) ; try { Properties p = new Properties ( ) ; p . load ( new FileReader ( new File ( "src/defaultlogin.local" ) ) ) ; txtUsername . setText ( p . getProperty ( "username" ) ) ; txtPassword . setText ( p . getProperty ( "password" ) ) ; } catch ( IOException e ) { } txtUsername . addActionListener ( this ) ; txtPassword . addActionListener ( this ) ; loginButton . addActionListener ( this ) ; }
te	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( ErroreGroup . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( ErroreGroup . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( ErroreGroup . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( ErroreGroup . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { Dimension dim = Toolkit . getDefaultToolkit ( ) . getScreenSize ( ) ; int w = err . getSize ( ) . width ; int h = err . getSize ( ) . height ; int x = ( dim . width - w ) / 2 ; int y = ( dim . height - h ) / 2 ; err . setLocation ( x , y ) ; err . setVisible ( true ) ; } } ) ; }
te	2	public void draw ( ) { if ( mode == RECTANGLE ) { Engine . renderRectangle ( rec , color ) ; } else if ( mode == STRING ) { Engine . renderString ( message , x , y , this . color ) ; } else { Engine . render ( rec , img ) ; } }
te	9	public static void main ( String [ ] args ) { final ArrayList < Integer > nominators = new ArrayList < Integer > ( ) ; final ArrayList < Integer > denominators = new ArrayList < Integer > ( ) ; for ( int i = 10 ; i < 100 ; i ++ ) { final int [ ] digits1 = getDigits ( i ) ; for ( int j = i + 1 ; j < 100 ; j ++ ) { final int [ ] digits2 = getDigits ( j ) ; final String result1 = divide ( i , j ) ; int k = - 1 ; int l = - 1 ; if ( digits1 [ 0 ] == digits2 [ 0 ] ) { k = digits1 [ 1 ] ; l = digits2 [ 1 ] ; } else if ( digits1 [ 0 ] == digits2 [ 1 ] ) { k = digits1 [ 1 ] ; l = digits2 [ 0 ] ; } else if ( digits1 [ 1 ] == digits2 [ 0 ] ) { k = digits1 [ 0 ] ; l = digits2 [ 1 ] ; } else if ( digits1 [ 1 ] == digits2 [ 0 ] ) { k = digits1 [ 0 ] ; l = digits2 [ 0 ] ; } if ( k > 0 && l > 0 ) { final String result2 = divide ( k , l ) ; if ( result1 . equals ( result2 ) ) { System . out . println ( "# magic numbers found; " + i + " / " + j + " = " + k + " / " + l ) ; nominators . add ( k ) ; denominators . add ( l ) ; } } } } int p1 = 1 ; int p2 = 2 ; for ( int i = 0 ; i < nominators . size ( ) ; i ++ ) { p1 *= nominators . get ( i ) ; p2 *= denominators . get ( i ) ; } System . out . println ( "# n = " + nominators . size ( ) + "; p1 = " + p1 + "; p2 = " + p2 ) ; }
te	1	public static < T > NodeWithParent < T > findParent ( NodeWithParent < T > n ) { NodeWithParent < T > curr = n ; while ( curr != null ) { curr = curr . parent ; } return curr ; }
te	8	private Map < TexFontBuilder , String > doBuildTypefacePackage ( File dir , String packageName ) throws IOException { if ( packageName == null ) packageName = mFamilyName ; dir . mkdirs ( ) ; Map < TexFontBuilder , String > nameMap = new HashMap < TexFontBuilder , String > ( ) ; StringBuilder shapeString = new StringBuilder ( ) ; StringBuilder mapString = new StringBuilder ( ) ; FileGarbage garbage = new FileGarbage ( ) ; for ( Map . Entry < Type , TexFontBuilder > e : mFontMap . entrySet ( ) ) { Type type = e . getKey ( ) ; TexFontBuilder fb = e . getValue ( ) ; String name = nameMap . get ( fb ) ; if ( name == null ) { name = String . format ( "%s_%s_%s" , mFamilyName , type . mSeries , type . mShape ) ; nameMap . put ( fb , name ) ; List < File > files = fb . buildFont ( name , garbage ) ; for ( File f : files ) { if ( Files . suffix ( f ) == "map" ) { appendMapFile ( f , mapString ) ; } else { File outFile = new File ( dir , f . getName ( ) ) ; NativeFiles . copy ( f , outFile ) ; } } } } PrintWriter out ; File mapFile = new File ( dir , packageName + ".map" ) ; out = new PrintWriter ( mapFile ) ; out . print ( mapString . toString ( ) ) ; out . close ( ) ; File styleFile = new File ( dir , packageName + ".sty" ) ; out = new PrintWriter ( styleFile ) ; out . println ( "\\NeedsTeXFormat{LaTeX2e}" ) ; out . format ( "\\ProvidesPackage{%s}[%s Package for loading font family %s]\n" , packageName , new SimpleDateFormat ( "yyyy/MM/dd" ) . format ( new Date ( ) ) , mFamilyName ) ; out . println ( "\\RequirePackage[T1]{fontenc}" ) ; out . println ( "\\RequirePackage[utf8]{inputenc}\n" ) ; out . format ( "\\pdfmapfile{+%s}\n" , mapFile . getName ( ) ) ; out . format ( "\\DeclareFontFamily{T1}{%s}{}\n" , mFamilyName ) ; for ( Map . Entry < Type , TexFontBuilder > e : mFontMap . entrySet ( ) ) { out . format ( "\\DeclareFontShape{T1}{%s}{%s}{%s}{ <-> %s }{}\n" , mFamilyName , e . getKey ( ) . mSeries , e . getKey ( ) . mShape , nameMap . get ( e . getValue ( ) ) ) ; } out . println ( ) ; if ( ! mDefaultSet . isEmpty ( ) ) { for ( TexFamily fam : mDefaultSet ) { out . format ( "\\renewcommand*{\\%s}{%s}\n" , fam . defaultVariable ( ) , mFamilyName ) ; } out . println ( ) ; } out . println ( "\\endinput" ) ; out . close ( ) ; garbage . empty ( ) ; return nameMap ; }
te	6	public Individual run ( ) { int selectedParent1 , selectedParent2 ; int i ; Individual parent1 , parent2 , offspring ; initialisePopulation ( ) ; TotalCostCalculator . calculateCostofPopulation ( population , 0 , POPULATION_SIZE , loadPenaltyFactor , routeTimePenaltyFactor ) ; Utility . sort ( population ) ; for ( i = 0 ; i < POPULATION_SIZE ; i ++ ) System . out . print ( population [ i ] . costWithPenalty + " " ) ; System . out . print ( "\n" ) ; for ( i = 0 ; i < POPULATION_SIZE ; i ++ ) System . out . print ( population [ i ] . distance + " " ) ; System . out . print ( "\n" ) ; SelectionOperator so = new FUSS ( ) ; so . setProblemInsctance ( problemInstance ) ; for ( int generation = 0 ; generation < 1 ; generation ++ ) { double [ ] cst = new double [ NUMBER_OF_OFFSPRING ] ; so . initialise ( population , true ) ; for ( i = 0 ; i < POPULATION_SIZE ; i ++ ) System . out . print ( population [ i ] . costWithPenalty + " " ) ; System . out . print ( "\n" ) ; for ( i = 0 ; i < POPULATION_SIZE ; i ++ ) System . out . print ( population [ i ] . distance + " " ) ; System . out . print ( "\n" ) ; for ( i = 0 ; i < NUMBER_OF_OFFSPRING ; i ++ ) { System . out . println ( "dis : " + so . getIndividual ( population ) . distance ) ; } } return population [ 0 ] ; }
te	6	public static void main ( String [ ] args ) { if ( args . length != 1 ) { System . err . println ( "A INDIDriver class name must be supplied" ) ; System . exit ( - 1 ) ; } INDIDriver driver = null ; try { class theClass = class . forName ( args [ 0 ] ) ; Constructor c = theClass . getConstructor ( InputStream . class , OutputStream . class ) ; driver = ( INDIDriver ) c . newInstance ( System . in , System . out ) ; } catch ( ClassNotFoundException ex ) { System . err . println ( ex + " class must be in class path." ) ; System . exit ( - 1 ) ; } catch ( InstantiationException ex ) { System . err . println ( ex + " class must be concrete." ) ; System . exit ( - 1 ) ; } catch ( IllegalAccessException ex ) { System . err . println ( ex + " class must have a no-arg constructor." ) ; System . exit ( - 1 ) ; } catch ( NoSuchMethodException ex ) { System . err . println ( ex + " class must have a InputStream  OutputStream constructor." ) ; System . exit ( - 1 ) ; } catch ( InvocationTargetException ex ) { System . err . println ( ex + " invocation target exception." ) ; System . exit ( - 1 ) ; } driver . startListening ( ) ; }
te	1	protected void writeImpl ( short [ ] samples , int offs , int len ) throws JavaLayerException { if ( source == null ) createSource ( ) ; byte [ ] b = toByteArray ( samples , offs , len ) ; source . write ( b , 0 , len * 2 ) ; }
te	6	private RenderableObject generateShape ( Scanner inFile ) { Point loc = null ; RenderableShape rs = new RenderableShape ( loc ) ; String current = inFile . next ( ) ; while ( inFile . hasNext ( ) && ! ( isCloseTag ( current ) && parseTag ( current ) == LegalTag . Object ) ) { if ( isOpenTag ( current ) ) { switch ( parseTag ( current ) ) { case Location : loc = new Point ( inFile . nextInt ( ) , inFile . nextInt ( ) ) ; rs . setLocation ( loc ) ; break ; case Line : rs . add ( generateLine ( inFile ) ) ; break ; default : break ; } } current = inFile . next ( ) ; } return rs ; }
te	0	public Builder withAvailableGestures ( Gesture ... gestures ) { this . availableGestures = gestures ; return this ; }
te	1	public HomeWindow ( House house ) { this . house = house ; initialize ( ) ; for ( Human h : house . getHuman ( ) ) { addHuman ( h ) ; } }
te	5	private static void readFromKeyboard ( final IDisplay display ) { final IGameController controller = display . getController ( ) ; try ( final Scanner sc = new Scanner ( System . in ) ) { while ( sc . hasNextLine ( ) ) { final String commands = sc . nextLine ( ) . toUpperCase ( ) ; for ( final char cmd : commands . toCharArray ( ) ) { controller . execute ( cmd ) ; if ( controller . getState ( ) != GameState . GAME_STATE_RUNNING ) { return ; } else if ( display . getDisplayType ( ) != IDisplay . Type . NONE ) { try { Thread . sleep ( DELAY ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } } } } }
te	6	boolean match ( String s ) { boolean alone = s . endsWith ( " " ) ; s = s . trim ( ) ; if ( ! text . startsWith ( s ) ) { return false ; } if ( alone && text . length ( ) > s . length ( ) ) { char n = text . charAt ( s . length ( ) ) ; if ( n != # && ! Character . isWhitespace ( n ) ) { return false ; } } for ( char c : s . toCharArray ( ) ) { skip ( ) ; } trim ( ) ; return true ; }
te	4	@ Override public void closePath ( ) { if ( prev != DRAWING_OP_TO ) { if ( prev == CLOSE ) { return ; } emitMoveTo ( cx0 , cy0 - lineWidth2 ) ; this . cmx = this . smx = 0 ; this . cmy = this . smy = - lineWidth2 ; this . cdx = this . sdx = 1 ; this . cdy = this . sdy = 0 ; finish ( ) ; return ; } if ( cx0 != sx0 || cy0 != sy0 ) { lineTo ( sx0 , sy0 ) ; } drawJoin ( cdx , cdy , cx0 , cy0 , sdx , sdy , cmx , cmy , smx , smy ) ; emitLineTo ( sx0 + smx , sy0 + smy ) ; emitMoveTo ( sx0 - smx , sy0 - smy ) ; emitReverse ( ) ; this . prev = CLOSE ; emitClose ( ) ; }
te	1	public void testFetchAllKeys ( ) { String [ ] s = caa . fetchAllKeys ( ) ; for ( int i = 2 ; i < s . length ; i -- ) { assertTrue ( s [ i ] . equals ( testAttributes [ i ] . getKey ( ) ) ) ; } }
te	0	public String resultingJson ( JSONArray input ) { String jSONArray = input . toString ( ) ; return resultingJson ( jSONArray ) ; }
te	3	public void formCatalog ( Clasa cl , Node node ) { Catalog cat = new Catalog ( ) ; Elev currentKey = null ; HashMap < Materie , SituatieMaterieBaza > value ; NodeList childNodes = node . getChildNodes ( ) ; for ( int i = 0 ; i < childNodes . getLength ( ) ; i ++ ) { Node cNode = childNodes . item ( i ) ; if ( cNode instanceof Element ) { String content = cNode . getLastChild ( ) . getTextContent ( ) . trim ( ) ; if ( cNode . getNodeName ( ) . equals ( "RubricaElev" ) ) { addEntry ( cat , cNode ) ; } } } cl . setCatalog ( cat ) ; }
te	7	private static void test1_3 ( ) throws FileNotFoundException { String test1 = "rawr\n" + "quit\n" + "yes\n" ; HashMap < Integer , String > output = new HashMap < Integer , String > ( ) ; boolean passed = true ; try { in = new ByteArrayInputStream ( test1 . getBytes ( ) ) ; System . setIn ( in ) ; out = new PrintStream ( "testing.txt" ) ; System . setOut ( out ) ; Game . main ( null ) ; } catch ( ExitException se ) { } catch ( Exception e ) { System . setOut ( stdout ) ; System . out . println ( "Error: " ) ; e . printStackTrace ( ) ; passed = false ; } finally { System . setOut ( stdout ) ; @ SuppressWarnings ( "resource" ) Scanner sc = new Scanner ( new File ( "testing.txt" ) ) ; ArrayList < String > testOutput = new ArrayList < String > ( ) ; while ( sc . hasNextLine ( ) ) { testOutput . add ( sc . nextLine ( ) ) ; } output . put ( testOutput . size ( ) - 2 , ">> >> Are you sure you want to quit? (y/n)" ) ; output . put ( testOutput . size ( ) - 1 , ">>" ) ; if ( passed ) { for ( Map . Entry < Integer , String > entry : output . entrySet ( ) ) { if ( ! testOutput . get ( entry . getKey ( ) ) . equals ( entry . getValue ( ) ) ) { passed = false ; System . out . println ( "test1_3 failed: Line " + entry . getKey ( ) ) ; System . out . println ( "\tExpected: " + entry . getValue ( ) ) ; System . out . println ( "\tReceived: " + testOutput . get ( entry . getKey ( ) ) ) ; } } if ( passed ) { System . out . println ( "test1_3 passed" ) ; } } else { System . out . println ( "test1_3 failed: error" ) ; } } }
te	1	public Filter ( String searchString ) { try { searchPosition = Position . valueOf ( searchString . toUpperCase ( ) ) ; } catch ( IllegalArgumentException e ) { } this . searchString = searchString . toLowerCase ( ) ; }
te	5	int startPlugins ( ) { StringBuilder sb = new StringBuilder ( "Loaded plugins: " ) ; int count = 0 ; for ( PluginsLoader pl : pluginsLoaders ) { for ( class < ? extends Plugin > clazz : pl . getAllPlugins ( ) ) { if ( pluginClasses . containsKey ( clazz . getCanonicalName ( ) ) ) { continue ; } if ( addPlugin ( clazz ) ) { sb . append ( clazz . getCanonicalName ( ) ) ; sb . append ( "  " ) ; count ++ ; } } } sb . delete ( sb . length ( ) - 2 , sb . length ( ) ) ; logger . info ( sb . toString ( ) ) ; initCorePlugins ( ) ; return count ; }
te	5	@ Override public File download ( Files request , String localPath ) throws IOException { int bytesRead = 0 ; byte [ ] buf = new byte [ 10240 ] ; connectToHDFS ( ) ; request . setSessionKey ( this . sessionKey ) ; String streamPath ; File workingDir = new File ( "." ) ; if ( ! workingDir . exists ( ) ) workingDir . mkdirs ( ) ; String workingPath = workingDir . getCanonicalPath ( ) ; streamPath = workingPath + "/tmp/" + "p/" ; File tmpFile = new File ( streamPath + request . getFileName ( ) + "._private" ) ; BufferedOutputStream bos = new BufferedOutputStream ( new FileOutputStream ( tmpFile ) ) ; System . out . println ( "sending Request" ) ; objOutput . writeObject ( request ) ; objOutput . flush ( ) ; try { recievFile = ( Files ) objInput . readObject ( ) ; } catch ( ClassNotFoundException e ) { System . out . println ( "WTF??" ) ; } if ( recievFile . getOptionNum ( ) == - 1 ) { System . out . println ( "HDFS download fail" ) ; return null ; } else if ( recievFile . getOptionNum ( ) == 2 ) { System . out . println ( "session auth fail" ) ; return null ; } System . out . println ( "download Start " ) ; int totalByteRead = 0 ; while ( - 1 != ( bytesRead = reader . read ( buf , 0 , buf . length ) ) ) { totalByteRead += bytesRead ; bos . write ( buf , 0 , bytesRead ) ; ClientLauncher . getTaskMgr ( ) . getRunningTask ( ) . setCur ( ClientLauncher . getTaskMgr ( ) . getRunningTask ( ) . getCur ( ) + totalByteRead ) ; } System . out . println ( "HDFS complete" ) ; bos . flush ( ) ; return tmpFile ; }
te	6	public void getSetUp ( ) { if ( setUp == false ) { if ( P1character . equals ( "White" ) ) { getWorld ( ) . addObject ( whiteKnight , 100 , 400 ) ; } else if ( P1character . equals ( "Bond" ) ) { getWorld ( ) . addObject ( jamesBond , 100 , 400 ) ; } else if ( P1character . equals ( "Ninja" ) ) { getWorld ( ) . addObject ( redNinja , 100 , 400 ) ; } else if ( P1character . equals ( "Mage" ) ) { getWorld ( ) . addObject ( purpleMage , 100 , 400 ) ; } else if ( P1character . equals ( "Ringer" ) ) { getWorld ( ) . addObject ( markGreen , 100 , 400 ) ; } setUp = true ; } }
te	2	protected URL resolveURL ( ) { if ( this . clazz != null ) { return this . clazz . getResource ( this . path ) ; } else if ( this . classLoader != null ) { return this . classLoader . getResource ( this . path ) ; } else { return ClassLoader . getSystemResource ( this . path ) ; } }
te	0	public void setInformer ( Activity informer ) { _informer = informer ; }
te	1	public Node deleteWithRecursion ( Object dataToDelete , Node node ) { if ( node . getData ( ) . equals ( dataToDelete ) ) { return node . getNextNode ( ) ; } else { node . setNext ( deleteWithRecursion ( dataToDelete , node . getNextNode ( ) ) ) ; return node ; } }
te	1	public T categories ( List < Integer > categories ) { if ( categories != null ) { this . categories . addAll ( categories ) ; } return self ( ) ; }
te	2	public static void normalize ( float [ ] a ) { float total = sum ( a ) ; if ( total == 0.0 || double . isNaN ( total ) ) { throw new RuntimeException ( "Can't normalize an array with sum 0.0 or NaN" ) ; } multiplyInPlace ( a , 1.0 / total ) ; }
te	5	public void distribuerMessage ( Message message ) throws RemoteException { Registry registry ; try { registry = LocateRegistry . getRegistry ( REGISTRY_PORT ) ; for ( Client c : getUtilisateursConnectes ( ) ) { try { Remote rem = registry . lookup ( c . getUtilisateur ( ) . getLogin ( ) ) ; ( ( InterfaceClientRmi ) rem ) . recevoirMessage ( message ) ; } catch ( AccessException e ) { e . printStackTrace ( ) ; } catch ( RemoteException e ) { e . printStackTrace ( ) ; } catch ( NotBoundException e ) { e . printStackTrace ( ) ; } } } catch ( RemoteException e1 ) { e1 . printStackTrace ( ) ; } }
te	0	@ Test public void testFilter ( ) { assertEquals ( 0 , $ . filter ( "asdf" ) . size ( ) ) ; assertEquals ( 1 , $ . filter ( "document" ) . size ( ) ) ; assertEquals ( 3 , $ . find ( ) . filter ( "actor" ) . size ( ) ) ; assertEquals ( 3 , $ . find ( ) . filter ( "actor" ) . filter ( JOOX . all ( ) ) . size ( ) ) ; assertEquals ( 2 , $ . find ( ) . filter ( "actor" ) . filter ( JOOX . even ( ) ) . size ( ) ) ; assertEquals ( 1 , $ . find ( ) . filter ( "actor" ) . filter ( JOOX . odd ( ) ) . size ( ) ) ; }
te	7	public boolean peekPrimaryExpression ( ) { return peek ( kIdentifier ) || peek ( kNumberLiteral ) || peek ( kTrue ) || peek ( kYes ) || peek ( kFalse ) || peek ( kNo ) || peek ( kStringLiteral ) || peek ( kThis ) ; }
te	4	public static int countArrayDimensions ( class < ? > arrayClazz ) { if ( arrayClazz . isArray ( ) ) { int d = 0 ; for ( char ch : arrayClazz . toString ( ) . toCharArray ( ) ) { d += ( ch == [ ) ? 1 : 0 ; } return d ; } else { throw new IllegalArgumentException ( "Not an array  class :" + arrayClazz ) ; } }
te	1	public static boolean isSuccessful ( CommandLine commandLine ) { return commandLine . stderr ( ) . trim ( ) . isEmpty ( ) && commandLine . exitCode ( ) == 0 ; }
te	7	private JDialog buildMidiOptionsDialog ( ) { soundOnCheckBox = new JCheckBox ( "" , true ) ; instrumentsComboBox = new JComboBox ( ) ; if ( instruments != null ) { for ( int i = 0 ; i < 20 ; i ++ ) { instrumentsComboBox . addItem ( instruments [ i ] . getName ( ) ) ; } } else { instrumentsComboBox . addItem ( "No instrument available" ) ; System . out . println ( "No soundbank file : http://java.sun.com/products/java-media/sound/soundbanks.html" ) ; } instrumentsComboBox . addItemListener ( this ) ; JPanel soundPanel = new JPanel ( ) ; localizables . add ( new Localizable . NamedGroup ( soundPanel , "_sound" ) ) ; keyboardsoundCheckBox = new JCheckBox ( "" , false ) ; JPanel keyboardSoundPanel = new JPanel ( ) ; keyboardSoundPanel . add ( soundOnCheckBox ) ; keyboardSoundPanel . add ( keyboardsoundCheckBox ) ; keyboardSoundPanel . add ( instrumentsComboBox ) ; soundPanel . setLayout ( new BorderLayout ( ) ) ; soundPanel . add ( keyboardSoundPanel , BorderLayout . CENTER ) ; JPanel latencyPanel = new JPanel ( ) ; latencyPanel . add ( latencySlider ) ; latencySlider . setMajorTickSpacing ( 50 ) ; latencySlider . setMinorTickSpacing ( 10 ) ; latencySlider . setPaintTicks ( true ) ; latencySlider . setPaintLabels ( true ) ; try { latencySlider . setValue ( Integer . parseInt ( settings . getProperty ( "latency" ) ) ) ; } catch ( Exception e ) { System . out . println ( e ) ; } localizables . add ( new Localizable . NamedGroup ( latencyPanel , "_latency" ) ) ; midiInComboBoxModel . addElement ( pasclavier ) ; midiOutComboBoxModel . addElement ( pasclavier ) ; MidiDevice . Info [ ] aInfos = MidiSystem . getMidiDeviceInfo ( ) ; for ( int i = 0 ; i < aInfos . length ; i ++ ) { try { MidiDevice device = MidiSystem . getMidiDevice ( aInfos [ i ] ) ; boolean bAllowsInput = ( device . getMaxTransmitters ( ) != 0 ) ; boolean bAllowsOutput = ( device . getMaxReceivers ( ) != 0 ) ; if ( bAllowsInput ) { midiInComboBoxModel . addElement ( aInfos [ i ] . getName ( ) ) ; } if ( bAllowsOutput ) { midiOutComboBoxModel . addElement ( aInfos [ i ] . getName ( ) ) ; } } catch ( MidiUnavailableException e ) { } } midiInComboBox = new JComboBox ( ) ; midiInComboBox . setModel ( midiInComboBoxModel ) ; midiInComboBox . addItemListener ( this ) ; midiOutComboBox = new JComboBox ( ) ; midiOutComboBox . setModel ( midiOutComboBoxModel ) ; midiOutComboBox . addItemListener ( this ) ; keyboardLengthComboBox = new JComboBox ( ) ; keyboardLengthComboBox . addItemListener ( this ) ; Integer current = new Integer ( 0 ) ; Integer min = new Integer ( - 24 ) ; Integer max = new Integer ( 24 ) ; Integer step = new Integer ( 1 ) ; m_numberSpinnerModel = new SpinnerNumberModel ( current , min , max , step ) ; transpositionSpinner = new JSpinner ( m_numberSpinnerModel ) ; transpositionSpinner . setSize ( 40 , 40 ) ; transpositionLabel . setText ( "Tansposition" ) ; JPanel keyboardPanel = new JPanel ( ) ; keyboardPanel . add ( keyboardLengthComboBox ) ; keyboardPanel . add ( transpositionLabel ) ; keyboardPanel . add ( transpositionSpinner ) ; JPanel midiInPanel = new JPanel ( ) ; localizables . add ( new Localizable . NamedGroup ( midiInPanel , "_midiclavier" ) ) ; midiInPanel . setLayout ( new BorderLayout ( ) ) ; midiInPanel . add ( midiInComboBox , BorderLayout . NORTH ) ; midiInPanel . add ( keyboardPanel , BorderLayout . CENTER ) ; JPanel midiOutPanel = new JPanel ( ) ; midiOutPanel . setName ( "Midi out" ) ; localizables . add ( new Localizable . NamedGroup ( midiOutPanel , "_midiout" ) ) ; midiOutPanel . setLayout ( new BorderLayout ( ) ) ; midiOutPanel . add ( midiOutComboBox , BorderLayout . NORTH ) ; JButton okButton = new JButton ( ) ; localizables . add ( new Localizable . Button ( okButton , "_buttonok" ) ) ; okButton . setIcon ( new ImageIcon ( getClass ( ) . getResource ( "/images/ok.png" ) ) ) ; okButton . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { handleMidiOptionsOkClicked ( ) ; } } ) ; JButton cancelButton = new JButton ( ) ; localizables . add ( new Localizable . Button ( cancelButton , "_buttoncancel" ) ) ; cancelButton . setIcon ( new ImageIcon ( getClass ( ) . getResource ( "/images/cancel.png" ) ) ) ; cancelButton . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { handleMidiOptionsCancelClicked ( ) ; } } ) ; JPanel buttonPanel = new JPanel ( ) ; buttonPanel . add ( okButton ) ; buttonPanel . add ( cancelButton ) ; JPanel contentPanel = new JPanel ( ) ; contentPanel . setLayout ( new GridLayout ( 5 , 1 , 4 , 4 ) ) ; contentPanel . add ( soundPanel ) ; contentPanel . add ( midiInPanel ) ; contentPanel . add ( midiOutPanel ) ; contentPanel . add ( latencyPanel ) ; contentPanel . add ( buttonPanel ) ; JDialog dialog = new JDialog ( this , true ) ; localizables . add ( new Localizable . Dialog ( dialog , "_menuMidi" ) ) ; dialog . setContentPane ( contentPanel ) ; dialog . setSize ( 450 , 550 ) ; return dialog ; }
te	8	private void sort ( int [ ] tree ) { for ( boolean found = true ; found == true ; ) { found = false ; for ( int i = 1 ; ! found && i < tree . length ; i ++ ) { if ( tree [ i - 1 ] > tree [ i ] ) { found = true ; swap ( tree , i - 1 , i ) ; } } for ( int i = tree . length - 2 ; ! found && i >= 0 ; i -- ) { if ( tree [ i ] == tree [ i + 1 ] && compare ( tree , i , i + 1 ) > 0 ) { found = true ; swap ( tree , i , i + 1 ) ; } } } }
te	6	public static int dehexchar ( char c ) { if ( c >= 0 && c <= 9 ) { return c - 0 ; } if ( c >= A && c <= F ) { return c - ( A - 10 ) ; } if ( c >= a && c <= f ) { return c - ( a - 10 ) ; } return - 1 ; }
te	1	synchronized public boolean onSuccess ( ) { if ( done ) return false ; done = true ; success = true ; onAction ( ) ; return true ; }
te	2	@ HandlesEvent ( "AddToCart" ) public Resolution addToCart ( ) { TransactionPolicy policyGraph = ( TransactionPolicy ) this . ctx . getServletContext ( ) . getAttribute ( CartAppActionBeanContext . policyAttribute ) ; UnitOfWork updateCart = UnitOfWork . create ( business . UpdateCart . class , policyGraph ) . with ( ctx . getUser ( ) ) . using ( new ICallBackDelegate ( ) { @ Override public void execute ( ) { Product p ; try { p = new dao . ProductDAO ( ) . getProductByProductID ( itemId ) ; ctx . getUser ( ) . getUserCart ( ) . getItems ( ) . add ( new CartItem ( p , quantity ) ) ; } catch ( SQLException | NamingException e ) { e . printStackTrace ( ) ; } } } ) ; try { updateCart . Go ( ) ; } catch ( PolicyException e ) { e . printStackTrace ( ) ; } return new ForwardResolution ( "/cart.jsp" ) ; }
te	9	public void genTwoStep ( GameState initial_position , MoveList move_list , long p_start_bb , long p_dest_bb ) { p_start_bb &= initial_position . colour_bb [ initial_position . player ] ; long bad_trap_bb = getBadTrapSquares ( initial_position ) ; long temp_dest_bb = p_dest_bb & ~ bad_trap_bb ; if ( use_debug ) { print_bitboard ( p_start_bb , "Start" ) ; print_bitboard ( temp_dest_bb , "Case 1 Dest" ) ; } move_list . clear ( ) ; initial_position . genAllMoves ( move_list , p_start_bb , temp_dest_bb , temp_dest_bb , FULL_BB ) ; long dest2_bb = p_dest_bb & initial_position . empty_bb ; long inbetween_bb = touching_bb ( p_start_bb ) & touching_bb ( dest2_bb ) & ~ bad_trap_bb ; long temp_start_bb = touching_bb ( inbetween_bb ) & p_start_bb ; if ( use_debug ) { System . out . println ( "Case 2: Unassisted 2 step slide" ) ; print_bitboard ( dest2_bb , "dest2_bb" ) ; print_bitboard ( inbetween_bb , "inbetween" ) ; print_bitboard ( temp_start_bb , "temp_start_bb" ) ; } move_list_stack [ 0 ] . clear ( ) ; initial_position . genSlideMoves ( move_list_stack [ 0 ] , temp_start_bb , inbetween_bb ) ; for ( ArimaaMove move : move_list_stack [ 0 ] ) { gs_stack [ 0 ] . play ( move , initial_position ) ; long new_start_bb = move . getSetBits ( ) & inbetween_bb ; long illegal_dest_bb = move . getSetBits ( ) & p_start_bb ; long bad_trap_bb2 = getBadTrapSquares ( gs_stack [ 0 ] ) ; long td_bb = dest2_bb & ~ illegal_dest_bb & ~ bad_trap_bb2 ; if ( use_debug ) { System . out . println ( move ) ; print_bitboard ( new_start_bb , "new_start_bb" ) ; print_bitboard ( td_bb , "td_bb" ) ; } move_list_stack [ 1 ] . clear ( ) ; gs_stack [ 0 ] . genSlideMoves ( move_list_stack [ 1 ] , new_start_bb , td_bb ) ; for ( ArimaaMove move2 : move_list_stack [ 1 ] ) { move_list . getMove ( ) . add ( move , move2 ) ; } } long temp_dest2_bb = touching_bb ( p_start_bb ) & p_dest_bb ; long temp_start2_bb = touching_bb ( p_dest_bb ) & p_start_bb ; if ( use_debug ) { print_bitboard ( temp_start2_bb , "Start 3" ) ; print_bitboard ( temp_dest2_bb , "Dest 3" ) ; } initial_position . compute_tertiary_bitboards ( ) ; move_list_stack [ 0 ] . clear ( ) ; initial_position . genSlideMoves ( move_list_stack [ 0 ] , temp_dest2_bb , FULL_BB ) ; for ( ArimaaMove move : move_list_stack [ 0 ] ) { gs_stack [ 0 ] . play ( move , initial_position ) ; long new_dest_bb = move . getSetBits ( ) & ~ initial_position . empty_bb ; long new_start_bb = touching_bb ( new_dest_bb ) & p_start_bb ; move_list_stack [ 1 ] . clear ( ) ; gs_stack [ 0 ] . genSlideMoves ( move_list_stack [ 1 ] , new_start_bb , new_dest_bb ) ; for ( ArimaaMove move2 : move_list_stack [ 1 ] ) { move_list . getMove ( ) . add ( move , move2 ) ; } } long supportable_trap_bb = bad_trap_bb & temp_dest2_bb ; long temp_dest3_bb = touching_bb ( supportable_trap_bb ) ; move_list_stack [ 0 ] . clear ( ) ; initial_position . genSlideMoves ( move_list_stack [ 0 ] , FULL_BB , temp_dest3_bb ) ; for ( ArimaaMove move : move_list_stack [ 0 ] ) { gs_stack [ 0 ] . play ( move , initial_position ) ; long temp7_bb = move . getSetBits ( ) & initial_position . empty_bb ; long new_dest_bb = touching_bb ( temp7_bb ) & TRAP_SQUARES ; long new_start_bb = touching_bb ( new_dest_bb ) & p_start_bb ; move_list_stack [ 1 ] . clear ( ) ; gs_stack [ 0 ] . genSlideMoves ( move_list_stack [ 1 ] , new_start_bb , new_dest_bb ) ; for ( ArimaaMove move2 : move_list_stack [ 1 ] ) { move_list . getMove ( ) . add ( move , move2 ) ; } } long temp_dest4_bb = p_dest_bb & initial_position . empty_bb ; long temp_start4_bb = p_start_bb & touching_bb ( temp_dest4_bb ) ; long frozen_bb = temp_start2_bb & initial_position . frozen_pieces_bb ; long support_dest_bb = touching_bb ( frozen_bb ) & initial_position . empty_bb ; move_list_stack [ 0 ] . clear ( ) ; initial_position . genSlideMoves ( move_list_stack [ 0 ] , FULL_BB , support_dest_bb ) ; for ( ArimaaMove move : move_list_stack [ 0 ] ) { gs_stack [ 0 ] . play ( move , initial_position ) ; long temp7_bb = move . getSetBits ( ) & initial_position . empty_bb ; long new_start_bb = touching_bb ( temp7_bb ) & frozen_bb ; long new_dest_bb = p_dest_bb ; move_list_stack [ 1 ] . clear ( ) ; gs_stack [ 0 ] . genSlideMoves ( move_list_stack [ 1 ] , new_start_bb , new_dest_bb ) ; for ( ArimaaMove move2 : move_list_stack [ 1 ] ) { move_list . getMove ( ) . add ( move , move2 ) ; } } }
te	6	public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; ClasspathImageSource other = ( ClasspathImageSource ) obj ; if ( resourceName == null ) { if ( other . resourceName != null ) return false ; } else if ( ! resourceName . equals ( other . resourceName ) ) return false ; return true ; }
te	3	@ Override public int storePlatform ( Platform platform ) { Connection conn = null ; StringBuffer query = new StringBuffer ( ) ; int newPlatformId = 0 ; try { conn = getConnection ( ) ; query . append ( "INSERT INTO " ) . append ( super . getPrimaryTableName ( ) ) . append ( " (platform_name  platform_type)" ) . append ( " VALUES " ) . append ( "('" + platform . getName ( ) + "'  '" + platform . getType ( ) + "')" ) ; ResultSet rs = executeUpdateGetKeys ( conn , query . toString ( ) ) ; if ( rs . next ( ) ) { newPlatformId = rs . getInt ( 1 ) ; } rs . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { if ( conn != null ) { close ( conn ) ; } } return newPlatformId ; }
te	8	@ Override public Object getValueAt ( int rowIndex , int columnIndex ) { final Producto dvti = detalleProductoList . get ( rowIndex ) ; if ( columnIndex == 0 ) return dvti . getCodigo ( ) ; else if ( columnIndex == 1 ) return dvti . getNombre ( ) ; else if ( columnIndex == 2 ) return dvti . getLinea ( ) ; else if ( columnIndex == 3 ) return dvti . getMarca ( ) ; else if ( columnIndex == 4 ) return dvti . getCosto ( ) ; else if ( columnIndex == 5 ) return dvti . getPrecioVenta ( ) ; else if ( columnIndex == 6 ) return dvti . getExistencia ( ) ; else if ( columnIndex == 7 ) return dvti . getPiezasXCaja ( ) ; else throw new IndexOutOfBoundsException ( "for column:" + columnIndex ) ; }
te	0	@ Test public void testFishIsWink ( ) { assertTrue ( event . isWinkFish ( ) ) ; }
te	4	public long getUserTryes ( long questId , long groupId ) { PreparedStatement statement = null ; ResultSet rs = null ; Connection connection = null ; long count = 0 ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Obtendo user tries do grupo " + groupId + "..." ) ; } try { if ( logger . isDebugEnabled ( ) ) { logger . debug ( USERS_TRYED ) ; } connection = Connector . getConnection ( ) ; statement = connection . prepareStatement ( USERS_TRYED ) ; statement . setLong ( 1 , questId ) ; statement . setLong ( 2 , groupId ) ; rs = statement . executeQuery ( ) ; if ( rs . next ( ) ) { count = rs . getLong ( "try_count" ) ; } } catch ( SQLException e ) { logger . error ( e . getMessage ( ) , e ) ; } finally { ResourcesUtil . release ( null , statement , connection ) ; } return count ; }
te	7	void removeDev ( DeviceImpl dev ) { synchronized ( devices ) { DeviceImpl d = ( DeviceImpl ) getDevice ( dev . getAddress ( ) ) ; int i ; if ( d == null || d != dev ) return ; i = d . getAddress ( ) - 1 ; devices [ i ] = null ; if ( root == i ) { root = - 1 ; if ( MacOSX . trace ) System . err . println ( "bus root hub removed!" ) ; if ( MacOSX . debug ) { for ( i = 0 ; i < 127 ; i ++ ) { if ( devices [ i ] != null ) System . err . println ( "? addr " + ( i + 1 ) + " present with no root ?" ) ; } } } } }
te	3	public Geometry subdivide ( int I , int J , int m , int n ) { double data [ ] = new double [ 48 ] ; for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) for ( int k = 0 ; k < 3 ; k ++ ) data [ 12 * i + 3 * j + k ] = vertices [ ( J + j ) * ( _m + 1 ) + ( I + i ) ] [ k ] ; faces [ J * ( _m - 2 ) + I ] = null ; Geometry p = ( new Geometry ( ) ) . patch ( m , n , Geometry . CatmullRom , data ) ; add ( p ) ; return p ; }
te	7	public boolean onCommand ( CommandSender sender , Command command , String label , String [ ] args ) { if ( ! plugin . hasPerm ( sender , "who" , true ) ) { sender . sendMessage ( ChatColor . YELLOW + "You do not have permission to use /" + label ) ; return true ; } if ( args . length == 1 ) { UserTable ut = plugin . getDatabase ( ) . find ( UserTable . class ) . where ( ) . ieq ( "displyName" , args [ 0 ] ) . findUnique ( ) ; if ( ut != null ) { Player p = plugin . getServer ( ) . getPlayer ( ut . getUserName ( ) ) ; String mute ; if ( ut . isMuted ( ) ) { mute = "yes" ; } else { mute = "no" ; } String afk ; if ( ut . isAfk ( ) ) { afk = "yes" ; } else { afk = "no" ; } sender . sendMessage ( ChatColor . YELLOW + "-------- " + ChatColor . RED + "Stats" + ChatColor . YELLOW + " ---------" ) ; sender . sendMessage ( ChatColor . YELLOW + "Account Name: " + ut . getUserName ( ) ) ; sender . sendMessage ( ChatColor . YELLOW + "Display Name: " + ut . getDisplyName ( ) ) ; sender . sendMessage ( ChatColor . YELLOW + "Health: " + p . getHealth ( ) + "/20" ) ; sender . sendMessage ( ChatColor . YELLOW + "Hunger: " + p . getFoodLevel ( ) + "/20" ) ; sender . sendMessage ( ChatColor . YELLOW + "IP: " + p . getAddress ( ) . getHostName ( ) ) ; sender . sendMessage ( ChatColor . YELLOW + "Logins: " + ut . getLogins ( ) ) ; sender . sendMessage ( ChatColor . YELLOW + "AFK: " + afk ) ; sender . sendMessage ( ChatColor . YELLOW + "Muted: " + mute ) ; } else { sender . sendMessage ( CraftEssence . premessage + "Player not found." ) ; } return true ; } else { UserTable ut1 = plugin . getDatabase ( ) . find ( UserTable . class ) . where ( ) . ieq ( "displyName" , sender . getName ( ) ) . findUnique ( ) ; Player p = plugin . getServer ( ) . getPlayer ( ut1 . getUserName ( ) ) ; String mute ; if ( ut1 . isMuted ( ) ) { mute = "yes" ; } else { mute = "no" ; } String afk ; if ( ut1 . isAfk ( ) ) { afk = "yes" ; } else { afk = "no" ; } sender . sendMessage ( ChatColor . YELLOW + "-------- " + ChatColor . RED + "Stats" + ChatColor . YELLOW + " ---------" ) ; sender . sendMessage ( ChatColor . YELLOW + "Account Name: " + ut1 . getUserName ( ) ) ; sender . sendMessage ( ChatColor . YELLOW + "Display Name: " + ut1 . getDisplyName ( ) ) ; sender . sendMessage ( ChatColor . YELLOW + "Health: " + p . getHealth ( ) + "/20" ) ; sender . sendMessage ( ChatColor . YELLOW + "Hunger: " + p . getFoodLevel ( ) + "/20" ) ; sender . sendMessage ( ChatColor . YELLOW + "IP: " + p . getAddress ( ) . getHostName ( ) ) ; sender . sendMessage ( ChatColor . YELLOW + "Logins: " + ut1 . getLogins ( ) ) ; sender . sendMessage ( ChatColor . YELLOW + "AFK: " + afk ) ; sender . sendMessage ( ChatColor . YELLOW + "Muted: " + mute ) ; return true ; } }
te	5	@ Override public void run ( ) { System . out . println ( "Thread started" ) ; while ( running && duration > 0 ) { duration -- ; javax . swing . SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { bf . blinkOff ( ) ; } } ) ; try { Thread . sleep ( intervall ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } javax . swing . SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { bf . blinkOn ( ) ; } } ) ; try { Thread . sleep ( intervall ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } System . out . println ( "Thread finished" ) ; javax . swing . SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { bf . setVisible ( false ) ; if ( frame != null ) { frame . invalidate ( ) ; frame . validate ( ) ; frame . repaint ( ) ; } } } ) ; }
te	0	public PropertyValidationException ( String message ) { super ( message ) ; }
te	2	public int similitud ( double [ ] a , double b [ ] ) { int sim = 0 ; for ( int i = 0 ; i < a . length ; i ++ ) { if ( a [ i ] . equals ( b [ i ] ) ) { sim ++ ; } } return sim ; }
te	8	public static void main ( String [ ] args ) { boolean validar = true ; char continuar ; int opcion ; double monto ; Scanner teclado = new Scanner ( System . in ) ; Account oAccount = new Account ( ) ; while ( validar ) { System . out . println ( "Digite 1 si quiere realizar un deposito y 2 " + "si quiere realizar un retiro" ) ; opcion = Integer . parseInt ( teclado . nextLine ( ) ) ; if ( opcion == 1 ) { System . out . println ( "Digite el monto a depositar" ) ; monto = double . parseDouble ( teclado . nextLine ( ) ) ; oAccount . Deposito ( monto ) ; } else if ( opcion == 2 ) { System . out . println ( "Digite el monto a retirar" ) ; monto = double . parseDouble ( teclado . nextLine ( ) ) ; oAccount . Retiro ( monto ) ; if ( oAccount . isHayError ( ) ) { System . out . println ( "El monto a retirar  no puede ser " + "retirardo" ) ; oAccount . setHayError ( false ) ; } } System . out . println ( "El saldo final es de " + oAccount . getSaldoInicial ( ) ) ; System . out . println ( "Desea continuar con otra transaccion? S/N" ) ; continuar = teclado . nextLine ( ) . charAt ( 0 ) ; if ( ( continuar == S ) || ( continuar == s ) ) validar = true ; else if ( ( continuar == N ) || ( continuar == n ) ) validar = false ; } }
te	0	private void updateVertex ( ) { Point p = ( Point ) this . getLeftTopVertex ( ) ; int X = p . x ; int Y = p . y ; int W = getPixelWidth ( ) ; int H = getPixelHeight ( ) ; this . setSecondVertex ( X + W , Y ) ; this . setThirdVertex ( X + W , Y + H ) ; this . setFourthVertex ( X , Y + H ) ; }
te	7	public static void writeFile ( String data , String targetFilePath ) { OutputStreamWriter osw = null ; BufferedWriter output = null ; FileOutputStream fos = null ; String encoding = "utf-8" ; try { File file = new File ( targetFilePath ) ; if ( file . exists ( ) ) { System . out . println ( "Utils.writeFile--\u6587\u4EF6\u5B58\u5728\uFF0C\u8FFD\u52A0\u5185\u5BB9" ) ; fos = new FileOutputStream ( file , true ) ; osw = new OutputStreamWriter ( fos , encoding ) ; output = new BufferedWriter ( osw ) ; output . write ( data + "\r\n" ) ; } else { System . out . println ( "Utils.writeFile--\u6587\u4EF6\u4E0D\u5B58\u5728--\u5DF2\u521B\u5EFA" ) ; File parentOfFile = file . getParentFile ( ) ; if ( ! parentOfFile . exists ( ) ) { parentOfFile . mkdirs ( ) ; System . out . println ( "Utils--writeFile--\u5B58\u50A8\u6587\u4EF6\u7236\u8DEF\u5F84-->" + parentOfFile . getPath ( ) ) ; } file . createNewFile ( ) ; fos = new FileOutputStream ( file , true ) ; osw = new OutputStreamWriter ( fos , encoding ) ; output = new BufferedWriter ( osw ) ; output . write ( data + "\r\n" ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { try { if ( output != null ) { output . close ( ) ; output = null ; } if ( osw != null ) { osw . close ( ) ; osw = null ; } if ( fos != null ) { fos . close ( ) ; fos = null ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } }
te	4	public static String toBase64 ( final byte [ ] data ) { final int i = data . length / 3 ; final int j = data . length % 3 ; final byte barray [ ] = new byte [ ( ( j == 0 ) ? i : i + 1 ) * 4 ] ; int k = 0 ; int l = 0 ; for ( int i1 = 0 ; i1 < i ; i1 ++ ) { barray [ k ++ ] = ByteUtil . toBase64 ( ( byte ) ( data [ l ] >> 2 & 3f ) ) ; barray [ k ++ ] = ByteUtil . toBase64 ( ( byte ) ( ( data [ l ] & 3 ) << 4 | ( data [ l + 1 ] & f0 ) >> 4 & f ) ) ; barray [ k ++ ] = ByteUtil . toBase64 ( ( byte ) ( ( data [ l + 1 ] & f ) << 2 | ( data [ l + 2 ] & c0 ) >> 6 & 3 ) ) ; barray [ k ++ ] = ByteUtil . toBase64 ( ( byte ) ( data [ l + 2 ] & 3f ) ) ; l += 3 ; } if ( j == 1 ) { barray [ k ++ ] = ByteUtil . toBase64 ( ( byte ) ( data [ l ] >> 2 & 3f ) ) ; barray [ k ++ ] = ByteUtil . toBase64 ( ( byte ) ( ( data [ l ] & 3 ) << 4 ) ) ; barray [ k ++ ] = 61 ; barray [ k ++ ] = 61 ; } else { if ( j == 2 ) { barray [ k ++ ] = ByteUtil . toBase64 ( ( byte ) ( data [ l ] >> 2 & 3f ) ) ; barray [ k ++ ] = ByteUtil . toBase64 ( ( byte ) ( ( data [ l ] & 3 ) << 4 | ( data [ l + 1 ] & f0 ) >> 4 & f ) ) ; barray [ k ++ ] = ByteUtil . toBase64 ( ( byte ) ( ( data [ l + 1 ] & f ) << 2 ) ) ; barray [ k ++ ] = 61 ; } } return new String ( barray ) ; }
te	8	private void shift ( ) { if ( LocationManager . getLoc ( cursor ) . isEmpty ( ) ) { JOptionPane . showMessageDialog ( gui , "No Unit Present" ) ; return ; } if ( LocationManager . getLoc ( cursor ) . getUnit ( ) . getTeam ( ) != turn ) { JOptionPane . showMessageDialog ( gui , "Cannot Control this unit" ) ; return ; } if ( LocationManager . getLoc ( cursor ) . getUnit ( ) . isShiftDone ( ) ) { JOptionPane . showMessageDialog ( gui , "Unit alread moved this turn" ) ; return ; } shifting = true ; buttonCursor . y = - 1 ; unitLoc = new Point ( cursor . x , cursor . y ) ; int movesLeftAtPoint [ ] [ ] = new int [ LocationManager . getSize ( ) . x ] [ LocationManager . getSize ( ) . y ] ; for ( int i = 0 ; i < movesLeftAtPoint . length ; i ++ ) { for ( int j = 0 ; j < movesLeftAtPoint [ 0 ] . length ; j ++ ) { movesLeftAtPoint [ i ] [ j ] = - 1 ; } } Unit unit = LocationManager . getLoc ( cursor ) . getUnit ( ) ; movesLeftAtPoint [ cursor . x ] [ cursor . y ] = LocationManager . getLoc ( cursor ) . getUnit ( ) . getShift ( ) ; movesRecur ( cursor , movesLeftAtPoint , unit ) ; selectLocs . clear ( ) ; for ( int i = 0 ; i < movesLeftAtPoint . length ; i ++ ) { for ( int j = 0 ; j < movesLeftAtPoint [ 0 ] . length ; j ++ ) { if ( movesLeftAtPoint [ i ] [ j ] > - 1 ) { selectLocs . add ( new Point ( i , j ) ) ; } } } }
te	4	protected static void ensureRootNodeNameIs ( String [ ] rootNames , Element elem ) throws WeiboException { String actualRootName = elem . getNodeName ( ) ; for ( String rootName : rootNames ) { if ( rootName . equals ( actualRootName ) ) { return ; } } String expected = "" ; for ( int i = 0 ; i < rootNames . length ; i ++ ) { if ( i != 0 ) { expected += " or " ; } expected += rootNames [ i ] ; } throw new WeiboException ( "Unexpected root node name:" + elem . getNodeName ( ) + ". Expected:" + expected + ". Check the availability of the Weibo API at http://open.t.sina.com.cn/." ) ; }
te	7	public Object getValueAt ( int rowIndex , int columnIndex ) { Record record = records . getRecordNumber ( rowIndex , true ) ; switch ( columnIndex ) { case 0 : return "" + record . getOrder ( ) ; case 1 : return record . getPinyinAsUnicode ( ) ; case 2 : return record . getChars ( ) ; case 3 : return record . getTrad ( ) ; case 4 : return record . getEnglish ( ) ; case 5 : return record . getBook ( ) ; case 6 : return record . getChapter ( ) ; default : return "" ; } }
te	4	public static NeuralNetwork readNetwork ( String fileName , GameState ref ) { NeuralNetwork net = new NeuralNetwork ( ) ; net . getNeurons ( ) . clear ( ) ; net . getConnections ( ) . clear ( ) ; net . getInputs ( ) . clear ( ) ; net . getOutputs ( ) . clear ( ) ; try { Scanner scanner = new Scanner ( new File ( fileName ) ) ; while ( scanner . hasNextInt ( ) ) { int num = scanner . nextInt ( ) ; if ( num == 10000001 ) net . getNeurons ( ) . add ( readNeuron ( scanner , ref ) ) ; if ( num == 90000009 ) net . getConnections ( ) . add ( readConnection ( scanner , net . getNeurons ( ) ) ) ; } } catch ( IOException e ) { System . out . println ( "Could not read file :: NetReader" ) ; } return net ; }
