tr	6	public static final int method481 ( int i , int j , int k ) { if ( i == 65535 ) return 0 ; if ( ( k & 2 ) == 2 ) { if ( j < 0 ) j = 0 ; else if ( j > 127 ) j = 127 ; j = 127 - j ; return j ; } j = j * ( i & 7f ) >> 7 ; if ( j < 2 ) j = 2 ; else if ( j > 126 ) j = 126 ; return ( i & ff80 ) + j ; }
tr	7	public Object nextValue ( ) throws JSONException { char c = this . nextClean ( ) ; String string ; switch ( c ) { case " : case ' : return this . nextString ( c ) ; case { : this . back ( ) ; return new JSONObject ( this ) ; case [ : this . back ( ) ; return new JSONArray ( this ) ; } StringBuffer sb = new StringBuffer ( ) ; while ( c >=   && " :]}/\\\"[{;=#" . indexOf ( c ) < 0 ) { sb . append ( c ) ; c = this . next ( ) ; } this . back ( ) ; string = sb . toString ( ) . trim ( ) ; if ( "" . equals ( string ) ) { throw this . syntaxError ( "Missing value" ) ; } return JSONObject . stringToValue ( string ) ; }
tr	9	public void blendDraw ( Bitmap b , int xp , int yp , int col ) { xp += xOffs ; yp += yOffs ; int x0 = xp ; int x1 = xp + b . w ; int y0 = yp ; int y1 = yp + b . h ; if ( x0 < 0 ) x0 = 0 ; if ( y0 < 0 ) y0 = 0 ; if ( x1 > w ) x1 = w ; if ( y1 > h ) y1 = h ; if ( xFlip ) { for ( int y = y0 ; y < y1 ; y ++ ) { int sp = ( y - yp ) * b . w + xp + b . w - 1 ; int dp = ( y ) * w ; for ( int x = x0 ; x < x1 ; x ++ ) { int c = b . pixels [ sp - x ] ; if ( c < 0 ) pixels [ dp + x ] = ( ( b . pixels [ sp - x ] & fefefefe ) + ( col & fefefefe ) ) >> 1 ; } } } else { for ( int y = y0 ; y < y1 ; y ++ ) { int sp = ( y - yp ) * b . w - xp ; int dp = ( y ) * w ; for ( int x = x0 ; x < x1 ; x ++ ) { int c = b . pixels [ sp + x ] ; if ( c < 0 ) pixels [ dp + x ] = ( ( b . pixels [ sp + x ] & fefefefe ) + ( col & fefefefe ) ) >> 1 ; } } } }
tr	0	@ Override protected void drawComponentBody ( Graphics2D g ) { int [ ] xx = { x , x + width / 6 , x + width - width / 6 , x + width , x + width , x + width - width / 6 , x + width / 6 , x } ; int [ ] yy = { y + height / 6 , y , y , y + height / 6 , y + height - height / 6 , y + height , y + height , y + height - height / 6 } ; g . drawPolygon ( xx , yy , xx . length ) ; Stroke strokeSave = g . getStroke ( ) ; g . setStroke ( new BasicStroke ( 0.5f ) ) ; g . drawPolygon ( new int [ ] { x , x + width , x + width , x } , new int [ ] { y , y , y + height , y + height } , 4 ) ; g . setStroke ( strokeSave ) ; }
tr	5	private void pack ( ) throws IOException { if ( ( buf [ curPos + 4 ] & f0 ) == 20 ) { if ( ! needBytes ( 12 ) ) return ; if ( this . duration == 0 ) { int mux_rate = ( buf [ curPos + 9 ] & 7f ) << 16 ; mux_rate |= ( buf [ curPos + 10 ] & ff ) << 8 ; mux_rate |= buf [ curPos + 11 ] & ff ; mux_rate >>= 1 ; this . duration = ( int ) ( raf . length ( ) / mux_rate / 50 ) ; System . out . printf ( "duration: %ds\n" , duration ) ; } mpegVersion = 1 ; skip ( 12 ) ; } else if ( ( buf [ curPos + 4 ] & f0 ) == 40 ) { if ( ! needBytes ( 14 ) ) return ; mpegVersion = 2 ; skip ( 14 + ( buf [ curPos + 13 ] & 7 ) ) ; } }
tr	3	@ Override public Pattern process ( Pattern instance ) throws FilterException { Pattern filtered = new Pattern ( ) ; filtered . setDataSet ( newDataSet ) ; filtered . setClassIndex ( instance . getClassIndex ( ) ) ; double [ ] features = instance . toDoubleVector ( ) ; for ( int i = 0 ; i < features . length ; i ++ ) { int feature = features [ i ] . intValue ( ) ; for ( int j = 0 ; j < bits [ i ] ; j ++ ) { filtered . add ( j == feature ? 1d : 0d ) ; } } return filtered ; }
tr	3	public String toString ( ) { Nodo node = this . raiz ; if ( node == null ) return "" ; StringBuilder sb = new StringBuilder ( ) ; while ( node != null ) { sb . append ( node . elem ) ; if ( node . sig != null ) sb . append (   ) ; node = node . sig ; } return sb . toString ( ) ; }
tr	6	public byte [ ] readControl ( byte type , byte request , short value , short index , short length ) throws IOException { byte data [ ] = new byte [ length & ffff ] ; long status ; if ( length >= MAX_CONTROL_LENGTH || ( type & ControlMessage . DIR_TO_HOST ) == 0 ) throw new IllegalArgumentException ( ) ; if ( fd < 0 ) { throw new USBException ( "Dev.readControl aborted" , - USBException . IO_NotOpen ) ; } if ( MacOSX . trace ) System . out . println ( path + ": Dev.readControl  rqt 0x" + Integer . toHexString ( ff & type ) + "  req 0x" + Integer . toHexString ( ff & request ) + "  value 0x" + Integer . toHexString ( ffff & value ) + "  index 0x" + Integer . toHexString ( ffff & index ) + "  len " + Integer . toString ( ffff & length ) ) ; status = controlMsg ( fd , type , request , value , index , data , 0 , ( short ) data . length ) ; if ( status >= 0 ) { int length_when_done = ( int ) status ; if ( length_when_done != data . length ) { byte temp [ ] = new byte [ length_when_done ] ; System . arraycopy ( data , 0 , temp , 0 , length_when_done ) ; data = temp ; } return data ; } else throw new USBException ( "control read error" , ( int ) ( - status ) ) ; }
tr	7	private int partitionHoare ( int p , int r ) { int i = p ; int j = r ; int pivot = data [ p ] ; while ( i != j ) { while ( i < j && data [ j ] > pivot ) j -- ; if ( i < j ) { data [ i ] = data [ j ] ; i ++ ; } while ( i < j && data [ i ] < pivot ) i ++ ; if ( i < j ) { data [ j ] = data [ i ] ; j -- ; } } data [ i ] = pivot ; return i ; }
tr	6	@ Override @ Transactional public List getFilterValuesforReview ( String merchantName , String userName , String reviewStatus ) throws Exception { List filterValuesList = new ArrayList ( ) ; try { if ( merchantName != null ) { Query getMerchant = sessionFactory . getCurrentSession ( ) . createQuery ( "select merchantReview.oMerchant from MerchantReview merchantReview" ) ; filterValuesList = getMerchant . list ( ) ; System . out . println ( "merchant size..." + filterValuesList . size ( ) ) ; Iterator iterator = filterValuesList . iterator ( ) ; while ( iterator . hasNext ( ) ) { Merchant merchant = ( Merchant ) iterator . next ( ) ; System . out . println ( "merchant-------->" + merchant ) ; } } else if ( userName != null ) { Query getCashBackuser = sessionFactory . getCurrentSession ( ) . createQuery ( "select merchantReview.oCashBackUser from MerchantReview merchantReview" ) ; filterValuesList = getCashBackuser . list ( ) ; System . out . println ( "user size..." + filterValuesList . size ( ) ) ; Iterator iterator = filterValuesList . iterator ( ) ; while ( iterator . hasNext ( ) ) { CashBackUser cashBackUser = ( CashBackUser ) iterator . next ( ) ; System . out . println ( "user-------->" + cashBackUser ) ; } } else { Query getReview = sessionFactory . getCurrentSession ( ) . createQuery ( "select merchantReview.oStatus from MerchantReview merchantReview" ) ; filterValuesList = getReview . list ( ) ; System . out . println ( "review status size..." + filterValuesList . size ( ) ) ; Iterator iterator = filterValuesList . iterator ( ) ; while ( iterator . hasNext ( ) ) { MerchantReviewStatus MerchantreviewStatus = ( MerchantReviewStatus ) iterator . next ( ) ; System . out . println ( "reviewStatus-------->" + MerchantreviewStatus ) ; } } } catch ( Exception exception ) { throw exception ; } return filterValuesList ; }
tr	4	public Geometry cylinderMesh ( int N ) { if ( type . equals ( "cylinderMesh" ) && vertices . length == 4 * N + 2 ) return this ; type = "cylinderMesh" ; vertices = new double [ 4 * N + 2 ] [ 6 ] ; setVertex ( 0 , 0 , 0 , - 1 , 0 , 0 , - 1 ) ; setVertex ( 4 * N + 1 , 0 , 0 , 1 , 0 , 0 , 1 ) ; for ( int i = 1 ; i <= N ; i ++ ) { double theta = 2 * Math . PI * i / N ; double s = Math . sin ( theta ) ; double c = Math . cos ( theta ) ; setVertex ( i , s , c , - 1 , 0 , 0 , - 1 ) ; setVertex ( N + i , s , c , - 1 , s , c , 0 ) ; setVertex ( 2 * N + i , s , c , 1 , s , c , 0 ) ; setVertex ( 3 * N + i , s , c , 1 , 0 , 0 , 1 ) ; } faces = new int [ 3 * N ] [ ] ; for ( int i = 0 ; i < N ; i ++ ) { int i0 = i + 1 , i1 = ( i + 1 ) % N + 1 ; createFace ( i , 0 , i0 , i1 ) ; createFace ( i + N , N + i1 , N + i0 , 2 * N + i0 , 2 * N + i1 ) ; createFace ( i + 2 * N , 3 * N + i1 , 3 * N + i0 , 4 * N + 1 ) ; } return this ; }
tr	6	public Result ValidarEdicionRol ( Rol pRol ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( ( Common . IsMinorOrEqualsZero ( pRol . getCodigoRol ( ) ) ) ? ".C\u00F3digo inv\u00E1lido\n" : "" ) ; sb . append ( ( Common . IsNullOrEmpty ( pRol . getNombreRol ( ) ) ) ? ".Nombre inv\u00E1lido\n" : "" ) ; sb . append ( ( Common . IsNullOrEmpty ( pRol . getDescripcionRol ( ) ) ) ? ".Descripci\u00F3n inv\u00E1lida\n" : "" ) ; sb . append ( ( pRol . getModulos ( ) == null || Common . IsMinorOrEqualsZero ( pRol . getModulos ( ) . size ( ) ) ) ? ".El rol no tiene m\u00F3dulos asignados\n" : "" ) ; if ( ! Common . IsMinorOrEqualsZero ( sb . length ( ) ) ) return new Result ( ResultType . Error , "Valide los campos antes de modificar." , sb . toString ( ) ) ; else return new Result ( ResultType . Ok , "La validaci\u00F3n pas\u00F3 sin errores." , null ) ; }
tr	4	private ArrayList < String > RemoveStopWords ( ArrayList < String > textSnippets ) { String regex = "" , regexCaps = "" ; ArrayList < String > rem ; String path = System . getProperty ( "user.dir" ) ; File f = new File ( path , Settings . get ( "STOPWORD_LIST_PATH_SEARCH" ) ) ; try { BufferedReader br = new BufferedReader ( new FileReader ( f ) ) ; String line = "" ; line = br . readLine ( ) ; while ( line != null ) { regexCaps = line . substring ( 0 , 1 ) . toUpperCase ( ) + line . substring ( 1 ) ; regex = " " + line + " | " + regexCaps + " " ; rem = new ArrayList < String > ( ) ; for ( String temp : textSnippets ) { temp = " " + temp + " " ; temp = temp . replaceAll ( regex , " " ) ; rem . add ( temp . trim ( ) ) ; } textSnippets = rem ; line = br . readLine ( ) ; } br . close ( ) ; } catch ( FileNotFoundException e ) { ApplicationHelper . printError ( STOP_WORDS_FILE_ERROR ) ; } catch ( IOException e ) { ApplicationHelper . printError ( STOP_WORDS_FILE_ERROR ) ; } return textSnippets ; }
tr	3	protected byte [ ] decryptConcrete ( EncFSVolume volume , byte [ ] encFileName , byte [ ] fileIv ) throws EncFSCorruptDataException { try { return BlockCrypto . blockDecrypt ( volume , fileIv , encFileName ) ; } catch ( InvalidAlgorithmParameterException e ) { throw new EncFSCorruptDataException ( e ) ; } catch ( IllegalBlockSizeException e ) { throw new EncFSCorruptDataException ( e ) ; } catch ( BadPaddingException e ) { throw new EncFSCorruptDataException ( e ) ; } }
tr	1	public boolean contains ( Object element ) { int my_element = ( Integer ) element ; if ( Arrays . binarySearch ( tablica , my_element ) < 0 ) return false ; return true ; }
tr	8	public void menuAction ( JMenu selectMenu ) { MainFrame mainFrame = MainFrame . getInstance ( ) ; AttdFrame workingFrame = mainFrame . getCurrentFrame ( ) ; workingFrame . setVisible ( false ) ; for ( int i = 0 ; i < menu . length ; i ++ ) { if ( menu [ i ] . equals ( selectMenu ) ) { switch ( i ) { case 0 : mainFrame . setCurrentFrameEditCourse ( ) ; break ; case 1 : mainFrame . setCurrentFrameEditStudent ( ) ; break ; case 2 : mainFrame . setCurrentFrameCourseEnroll ( ) ; break ; case 3 : mainFrame . setCurrentFrameAttendance ( ) ; break ; case 4 : mainFrame . setCurrentFrameShowClassAR ( ) ; break ; case 5 : mainFrame . setCurrentFrameShowClassRP ( ) ; break ; default : break ; } break ; } } workingFrame = mainFrame . getCurrentFrame ( ) ; workingFrame . display ( ) ; }
tr	3	private instruccionMapeo BuscarNodo ( String Nombre ) { instruccionMapeo instrucciones = null ; for ( int i = 0 ; i < listaXML . getLength ( ) ; i ++ ) { Node nodo = listaXML . item ( i ) ; if ( nodo . getNodeType ( ) == Node . ELEMENT_NODE ) { Element eElement = ( Element ) nodo ; if ( eElement . getAttribute ( "tabla" ) . equals ( Nombre ) ) { instrucciones = divideCadenaDeInstrucciones ( eElement , Integer . parseInt ( eElement . getAttribute ( "size" ) ) ) ; break ; } } } return instrucciones ; }
tr	8	@ Override public String perform ( HttpServletRequest request ) { List < String > errors = new ArrayList < String > ( ) ; request . setAttribute ( "errors" , errors ) ; try { SearchCustomerName form = formBeanFactory . create ( request ) ; request . setAttribute ( "form" , form ) ; if ( ! form . isPresent ( ) ) { return "e_customermanage.jsp" ; } errors . addAll ( form . getValidationErrors ( ) ) ; if ( errors . size ( ) != 0 ) { return "e_customermanage.jsp" ; } Transaction . begin ( ) ; CustomerBean [ ] cbs = customerDAO . getRelateCustomers ( form . getUsername ( ) ) ; System . out . println ( cbs . length ) ; for ( CustomerBean c : cbs ) { System . out . println ( c . getFirstname ( ) ) ; } if ( cbs . length == 0 ) { errors . add ( "No related user" ) ; return "e_customermanage.jsp" ; } request . setAttribute ( "users" , cbs ) ; Transaction . commit ( ) ; return "e_customermanage.jsp" ; } catch ( RollbackException e ) { errors . add ( e . toString ( ) ) ; return "e_customermanage.jsp" ; } catch ( FormBeanException e ) { errors . add ( e . getMessage ( ) ) ; return "e_customermanage.jsp" ; } catch ( Exception e ) { errors . add ( e . getMessage ( ) ) ; return "e_customermanage.jsp" ; } finally { if ( Transaction . isActive ( ) ) Transaction . rollback ( ) ; } }
tr	1	public static float distanceBetween ( Creature t , Creature o2 ) { float x1 , x2 , y1 , y2 ; x1 = t . getX ( ) ; y1 = t . getY ( ) ; if ( o2 instanceof Ship ) { Ship s = ( Ship ) o2 ; x2 = s . getX ( ) ; y2 = s . getY ( ) ; } else { Sprite s = ( Sprite ) o2 ; x2 = s . getX ( ) ; y2 = s . getY ( ) ; } return distanceBetween ( x1 , y1 , x2 , y2 ) ; }
tr	2	@ Override public int compareTo ( Match o ) { if ( this . gameStartMs > o . gameStartMs ) return 1 ; else if ( this . gameStartMs < o . gameStartMs ) return - 1 ; return 0 ; }
tr	8	@ Override public byte [ ] toBytes ( Object value ) { Date date = ( Date ) value ; Calendar calendar = new GregorianCalendar ( ) ; calendar . setTime ( date ) ; long result ; switch ( precision ) { case DATETIME : result = calendar . getTimeInMillis ( ) ; break ; case DATETIME_NOMILLIS : calendar . set ( Calendar . MILLISECOND , 0 ) ; result = calendar . getTimeInMillis ( ) ; break ; case DATE : calendar . set ( Calendar . HOUR_OF_DAY , 0 ) ; calendar . set ( Calendar . MINUTE , 0 ) ; calendar . set ( Calendar . SECOND , 0 ) ; calendar . set ( Calendar . MILLISECOND , 0 ) ; result = calendar . getTimeInMillis ( ) ; break ; case TIME : case TIME_NOMILLIS : int hours = calendar . get ( Calendar . HOUR_OF_DAY ) ; int minutes = calendar . get ( Calendar . MINUTE ) ; int seconds = calendar . get ( Calendar . SECOND ) ; int millis = precision == Precision . TIME ? calendar . get ( Calendar . MILLISECOND ) : 0 ; result = ( hours * 60 * 60 * 1000 ) + ( minutes * 60 * 1000 ) + ( seconds * 1000 ) + millis ; break ; default : throw new RuntimeException ( "Unexpected precision: " + precision ) ; } byte [ ] bytes = new byte [ getLength ( ) ] ; switch ( precision ) { case TIME : case TIME_NOMILLIS : Bytes . putInt ( bytes , 0 , ( int ) result ) ; break ; default : Bytes . putLong ( bytes , 0 , result ) ; } bytes [ 0 ] = ( byte ) ( bytes [ 0 ] ^ 80 ) ; return bytes ; }
tr	4	public List < Integer > getRow ( int rowIndex ) { List < Integer > result = new ArrayList < Integer > ( ) ; List < Integer > temp = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i <= rowIndex ; i ++ ) { temp = new ArrayList < Integer > ( result ) ; result . clear ( ) ; for ( int j = 0 ; j <= i ; j ++ ) { if ( j == 0 || j == i ) result . add ( 1 ) ; else { result . add ( temp . get ( j - 1 ) + temp . get ( j ) ) ; } } } return result ; }
tr	6	private void layoutHorizontal ( int top , int bottom , int left , int right ) { int leftX = paddingLeft ; int height = bottom - top ; int childBottom = height - paddingBottom ; int availableHeight = height - paddingTop - paddingBottom ; for ( int i = 0 ; i < getChildCount ( ) ; i ++ ) { View child = getChildAt ( i ) ; if ( ! child . getVisibility ( ) . equals ( Visibility . GONE ) ) { int topY = 0 ; int childWidth = child . getMeasuredWidth ( ) ; int childHeight = child . getMeasuredHeight ( ) ; LayoutParameters params = ( LayoutParameters ) child . getLayoutParameters ( ) ; int rawAlignment = params . getAlignment ( ) ; Alignment alignment = Alignment . getHorizontalAlignment ( rawAlignment ) ; switch ( alignment ) { case TOP : topY = paddingTop + params . getTopMargin ( ) ; break ; case CENTER_VERTICAL : topY = paddingTop + ( ( availableHeight - childHeight ) / 2 ) + params . getTopMargin ( ) - params . getBottomMargin ( ) ; if ( params . centered ) { int width = right - left ; int availableWidth = width - paddingLeft - paddingRight ; leftX = paddingLeft + ( ( availableWidth - childWidth ) / 2 ) ; } break ; case BOTTOM : topY = childBottom - childHeight - params . getBottomMargin ( ) ; break ; default : topY = paddingTop ; } leftX += params . getLeftMargin ( ) ; setChildLayout ( child , leftX , topY , childWidth , childHeight ) ; leftX += childWidth + params . getRightMargin ( ) ; } } }
tr	0	public int getRadius ( ) { return radius ; }
tr	8	private static List < Integer > quadraticCongruenceSimpleSolve ( int a , final int m ) { a = normalizeIntModulo ( a , m ) ; int testA = a ; int testM = m ; if ( isPowerOf2 ( m ) ) testM = m / 2 ; final List < Integer > result = new ArrayList < > ( ) ; for ( int i = 0 ; i < testM ; ++ i ) { if ( isPerfectSquare ( testA ) ) { final int x1 = ( int ) Math . sqrt ( testA ) ; if ( modPow ( x1 , 2 , m ) == a ) quadraticCongruenceSimpleFillSolution ( result , x1 , testM ) ; if ( result . size ( ) == 4 ) break ; } testA += testM ; } if ( ! result . isEmpty ( ) ) { Collections . sort ( result ) ; result . add ( testM ) ; if ( ( result . size ( ) == 5 ) && ( m % 2 == 0 ) ) return binomialCongruenceRuleOut ( result ) ; } return result ; }
tr	5	static void transfer ( Account acc1 , Account acc2 , int amount ) throws InsufficientResourcesException { final int WAIT_SEC = 2 ; if ( acc1 . getBalance ( ) < amount ) throw new InsufficientResourcesException ( ) ; try { if ( acc1 . getLock ( ) . tryLock ( WAIT_SEC , TimeUnit . SECONDS ) ) { try { if ( acc2 . getLock ( ) . tryLock ( WAIT_SEC , TimeUnit . SECONDS ) ) try { acc1 . withdraw ( amount ) ; acc2 . deposit ( amount ) ; } finally { acc2 . getLock ( ) . unlock ( ) ; } } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } finally { acc1 . getLock ( ) . unlock ( ) ; } } else { System . out . println ( "transfer: tranfer of " + amount + " ERROR waiting lock!" ) ; } } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } }
tr	1	public void addNewElementsToHAC ( ArrayList < CommentEntityDS > neCommentDSArray , String articleId ) throws Exception { DocFactory documentFactory = new DocFactory ( ) ; DocDO document = documentFactory . get ( articleId ) ; ArrayList < MapCell > mappingArray = DatabaseOperations . getArticleMapping ( articleId ) ; ArrayOfCommentsFactory commentsArrayFactory = new ArrayOfCommentsFactory ( ) ; ArrayOfCommentsDO arrayOfCommentsDO = null ; arrayOfCommentsDO = commentsArrayFactory . get ( articleId ) ; ArrayList < Comment > neArray = Comment . convertCommentsDStoCommentsArrayList ( neCommentDSArray ) ; double [ ] vector = new double [ DatabaseOperations . getWordsCountForArticle ( articleId ) + 1 ] ; for ( Comment ne : neArray ) { Comment . nomalizeCommentVector ( ne ) ; addNewElementToHAC ( ne , articleId , vector , document , mappingArray , arrayOfCommentsDO . arrayOfComment ) ; arrayOfCommentsDO . arrayOfComment . add ( ne ) ; commentsArrayFactory . save ( arrayOfCommentsDO ) ; } DOMImplementationLS domImplementation = ( DOMImplementationLS ) document . doc . getImplementation ( ) ; DatabaseOperations . setXmlRepresentation ( articleId , domImplementation . createLSSerializer ( ) . writeToString ( document . doc ) ) ; DatabaseOperations . setArticleMapping ( articleId , mappingArray ) ; documentFactory . save ( document ) ; DatabaseOperations . setComments ( articleId , neCommentDSArray ) ; }
tr	9	@ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; PersistentEntry < ? , ? > other = ( PersistentEntry < ? , ? > ) obj ; if ( entry == null ) { if ( other . entry != null ) return false ; } else if ( ! entry . equals ( other . entry ) ) return false ; return true ; }
tr	4	@ Override protected void drawComponent ( Graphics2D g ) { if ( visInfo . hasNodes ( ) ) { g . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; g . setRenderingHint ( RenderingHints . KEY_TEXT_ANTIALIASING , RenderingHints . VALUE_TEXT_ANTIALIAS_ON ) ; g . setColor ( visInfo . getNodeColor ( ) ) ; AffineTransform at = visInfo . getTranformation ( ) ; Point2D from ; for ( Node node : visInfo . getNodes ( ) ) { from = node . getPoint ( ) ; at . setToIdentity ( ) ; at . translate ( from . getX ( ) - visInfo . getCircleDiam ( ) , from . getY ( ) - visInfo . getCircleDiam ( ) ) ; g . drawImage ( buffCircle , at , null ) ; for ( Edge edge : node . getEdges ( ) ) { if ( edge . getFromId ( ) < edge . getToId ( ) ) { NodeImpl nodeTo = ( NodeImpl ) visInfo . getNode ( edge . getToId ( ) ) ; line = new Line2D . double ( from , nodeTo . getPoint ( ) ) ; g . draw ( line ) ; } } } } }
tr	8	public GetDataBySubjectPanel ( JFrame frame , QueryDefinition query ) throws Exception { super ( frame , query , new GetDataBySubject ( query . getDocument ( ) ) ) ; JTabbedPane panel = new JTabbedPane ( ) ; ItemSet < SubjectID > subItems = new ItemSet < SubjectID > ( ) { @ Override public void add ( SubjectID item ) { GetDataBySubjectPanel . this . getRequest ( ) . addSubject ( item ) ; stateChanged ( new GetDatabySubjectPanelChangeEvent ( GetDataBySubjectPanel . this ) ) ; } @ Override public void remove ( SubjectID item ) { GetDataBySubjectPanel . this . getRequest ( ) . removeSubject ( item ) ; stateChanged ( new GetDatabySubjectPanelChangeEvent ( GetDataBySubjectPanel . this ) ) ; } @ Override public int size ( ) { return GetDataBySubjectPanel . this . getRequest ( ) . getSubjectCount ( ) ; } @ Override public SubjectID get ( int index ) { return GetDataBySubjectPanel . this . getRequest ( ) . getSubject ( index ) ; } @ Override public void set ( int index , String name , Object value ) { SubjectID id = this . get ( index ) ; if ( name . equals ( "Contributor" ) ) { id . setContributor ( ( Contributor ) value ) ; } else if ( name . equals ( "Value" ) ) { id . setValue ( ( String ) value ) ; } GetDataBySubjectPanel . this . getRequest ( ) . notifyChange ( ) ; stateChanged ( new GetDatabySubjectPanelChangeEvent ( GetDataBySubjectPanel . this ) ) ; } } ; ItemTablePanel < SubjectID > subjectsPanel = new ItemTablePanel < SubjectID > ( SubjectID . class , subItems ) ; panel . add ( "Subject IDs" , subjectsPanel ) ; ItemSet < Parameter > paramItems = new ItemSet < Parameter > ( ) { @ Override public void add ( Parameter item ) { GetDataBySubjectPanel . this . getRequest ( ) . addParameter ( item ) ; stateChanged ( new GetDatabySubjectPanelChangeEvent ( GetDataBySubjectPanel . this ) ) ; } @ Override public void remove ( Parameter item ) { GetDataBySubjectPanel . this . getRequest ( ) . removeParameters ( item ) ; stateChanged ( new GetDatabySubjectPanelChangeEvent ( GetDataBySubjectPanel . this ) ) ; } @ Override public int size ( ) { return GetDataBySubjectPanel . this . getRequest ( ) . getParameterCount ( ) ; } @ Override public Parameter get ( int index ) { return GetDataBySubjectPanel . this . getRequest ( ) . getParameter ( index ) ; } @ Override public void set ( int index , String name , Object value ) { Parameter id = this . get ( index ) ; if ( name . equals ( "Name" ) ) { id . setName ( ( String ) value ) ; } else if ( name . equals ( "Value" ) ) { id . setValue ( ( String ) value ) ; } GetDataBySubjectPanel . this . getRequest ( ) . notifyChange ( ) ; stateChanged ( new GetDatabySubjectPanelChangeEvent ( GetDataBySubjectPanel . this ) ) ; } } ; ItemTablePanel < Parameter > paramsPanel = new ItemTablePanel < Parameter > ( Parameter . class , paramItems ) ; panel . add ( "Parameters" , paramsPanel ) ; ItemSet < LogEntry > logItems = new ItemSet < LogEntry > ( ) { @ Override public void add ( LogEntry item ) { GetDataBySubjectPanel . this . getRequest ( ) . addLog ( item ) ; stateChanged ( new GetDatabySubjectPanelChangeEvent ( GetDataBySubjectPanel . this ) ) ; } @ Override public void remove ( LogEntry item ) { GetDataBySubjectPanel . this . getRequest ( ) . removeLog ( item ) ; stateChanged ( new GetDatabySubjectPanelChangeEvent ( GetDataBySubjectPanel . this ) ) ; } @ Override public int size ( ) { return GetDataBySubjectPanel . this . getRequest ( ) . getLogCount ( ) ; } @ Override public LogEntry get ( int index ) { return GetDataBySubjectPanel . this . getRequest ( ) . getLog ( index ) ; } @ Override public void set ( int index , String name , Object value ) { LogEntry id = this . get ( index ) ; if ( name . equals ( "Value" ) ) { id . setValue ( ( String ) value ) ; } GetDataBySubjectPanel . this . getRequest ( ) . notifyChange ( ) ; stateChanged ( new GetDatabySubjectPanelChangeEvent ( GetDataBySubjectPanel . this ) ) ; } } ; ItemTablePanel < LogEntry > logPanel = new ItemTablePanel < LogEntry > ( LogEntry . class , logItems ) ; panel . add ( "Logs" , logPanel ) ; JPanel otherPanel = new JPanel ( ) ; otherPanel . setLayout ( new GridBagLayout ( ) ) ; GridBagConstraints cMain = new GridBagConstraints ( ) ; cMain . fill = GridBagConstraints . HORIZONTAL ; cMain . anchor = GridBagConstraints . PAGE_START ; cMain . gridx = 0 ; cMain . gridy = 0 ; JPanel trxIdPanel = new JPanel ( ) ; GridBagConstraints c = new GridBagConstraints ( ) ; trxIdPanel . setLayout ( new GridBagLayout ( ) ) ; otherPanel . add ( trxIdPanel , cMain ) ; panel . add ( "Other" , otherPanel ) ; trxIdPanel . setBorder ( BorderFactory . createTitledBorder ( "Transaction ID" ) ) ; this . btnGroup = new ButtonGroup ( ) ; ActionListener btnActions = new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent arg0 ) { if ( GetDataBySubjectPanel . this . rdoBtnStatic . isSelected ( ) ) { GetDataBySubjectPanel . this . trxIdTextField . setEditable ( true ) ; GetDataBySubjectPanel . this . trxIdTextField . grabFocus ( ) ; GetDataBySubjectPanel . this . getRequest ( ) . setTransactionIDMode ( TransactionMode . static ) ; } else if ( GetDataBySubjectPanel . this . rdoBtnRandom . isSelected ( ) ) { GetDataBySubjectPanel . this . trxIdTextField . setEditable ( false ) ; GetDataBySubjectPanel . this . getRequest ( ) . setTransactionIDMode ( TransactionMode . Random ) ; } else if ( GetDataBySubjectPanel . this . rdoBtnNone . isSelected ( ) ) { GetDataBySubjectPanel . this . trxIdTextField . setEditable ( false ) ; GetDataBySubjectPanel . this . getRequest ( ) . setTransactionIDMode ( TransactionMode . None ) ; } } } ; this . rdoBtnNone = new JRadioButton ( "None" , true ) ; this . rdoBtnNone . addActionListener ( btnActions ) ; this . btnGroup . add ( this . rdoBtnNone ) ; c . fill = GridBagConstraints . HORIZONTAL ; c . anchor = GridBagConstraints . NORTHWEST ; c . gridx = 0 ; c . gridy = 0 ; trxIdPanel . add ( this . rdoBtnNone , c ) ; this . rdoBtnRandom = new JRadioButton ( "Random" ) ; this . rdoBtnRandom . addActionListener ( btnActions ) ; this . btnGroup . add ( this . rdoBtnRandom ) ; c . gridx = 0 ; c . gridy = 1 ; trxIdPanel . add ( this . rdoBtnRandom , c ) ; this . rdoBtnStatic = new JRadioButton ( "Static" ) ; this . rdoBtnStatic . addActionListener ( btnActions ) ; this . btnGroup . add ( this . rdoBtnStatic ) ; c . gridx = 0 ; c . gridy = 2 ; trxIdPanel . add ( this . rdoBtnStatic , c ) ; this . trxIdTextField = new JTextField ( ) ; this . trxIdTextField . addActionListener ( this ) ; this . trxIdTextField . setEditable ( false ) ; c . fill = GridBagConstraints . HORIZONTAL ; c . weightx = 0.5 ; c . gridx = 1 ; c . gridy = 2 ; trxIdPanel . add ( this . trxIdTextField , c ) ; JPanel bufferPanel = new JPanel ( ) ; cMain . gridx = 0 ; cMain . gridy = 1 ; cMain . weightx = 1 ; cMain . weighty = 1 ; otherPanel . add ( bufferPanel , cMain ) ; this . trxIdTextField . getDocument ( ) . addDocumentListener ( new DocumentListener ( ) { @ Override public void changedUpdate ( DocumentEvent arg0 ) { String text = GetDataBySubjectPanel . this . trxIdTextField . getText ( ) ; GetDataBySubjectPanel . this . getRequest ( ) . setTransactionId ( text ) ; stateChanged ( null ) ; } @ Override public void insertUpdate ( DocumentEvent arg0 ) { this . changedUpdate ( arg0 ) ; } @ Override public void removeUpdate ( DocumentEvent arg0 ) { this . changedUpdate ( arg0 ) ; } } ) ; this . addFirstTab ( "Fields" , panel ) ; }
tr	7	private void editButtonActionPerformed ( java . awt . event . ActionEvent evt ) { RBGoodsController . Row row = controller . getRow ( goodsTable . getSelectedRow ( ) ) ; if ( row == null ) { return ; } if ( row . rowtype == RBGoodsController . ROWTYPE . CATEGORY ) { CategoryPanel panel = new CategoryPanel ( row . category ) ; ValidationPanel validationPanel = new ValidationPanel ( panel . getValidationGroup ( ) ) ; validationPanel . setInnerComponent ( panel ) ; if ( validationPanel . showOkCancelDialog ( "\u0420\u0435\u0434\u0430\u043A\u0442\u0438\u0440\u043E\u0432\u0430\u043D\u0438\u0435 \u043A\u0430\u0442\u0435\u0433\u043E\u0440\u0438\u0438" ) ) { try { row . category = panel . getCategory ( ) ; controller . updateRow ( row ) ; } catch ( SQLException ex ) { Exceptions . printStackTrace ( ex ) ; } } } else if ( row . article != null ) { try { ArticlePanel panel = new ArticlePanel ( row . article ) ; ValidationPanel validationPanel = new ValidationPanel ( panel . getValidationGroup ( ) ) ; validationPanel . setInnerComponent ( panel ) ; if ( validationPanel . showOkCancelDialog ( "\u0420\u0435\u0434\u0430\u043A\u0442\u0438\u0440\u043E\u0432\u0430\u043D\u0438\u0435 \u0430\u0440\u0442\u0438\u043A\u0443\u043B\u0430" ) ) { row . article = panel . getArticle ( ) ; controller . updateRow ( row ) ; } } catch ( SQLException ex ) { Exceptions . printStackTrace ( ex ) ; } } }
tr	7	public static void polcof ( final double [ ] xa , final double [ ] ya , final double [ ] cof ) { int k , j , i , n = xa . length ; double xmin ; double [ ] x = new double [ n ] ; double [ ] y = new double [ n ] ; for ( j = 0 ; j < n ; j ++ ) { x [ j ] = xa [ j ] ; y [ j ] = ya [ j ] ; } for ( j = 0 ; j < n ; j ++ ) { double [ ] x_t = new double [ n - j ] ; double [ ] y_t = new double [ n - j ] ; for ( k = 0 ; k < n - j ; k ++ ) { x_t [ k ] = x [ k ] ; y_t [ k ] = y [ k ] ; } Poly_interp interp = new Poly_interp ( x , y , n - j ) ; cof [ j ] = interp . rawinterp ( 0 , 0. ) ; xmin = 1.0e99 ; k = - 1 ; for ( i = 0 ; i < n - j ; i ++ ) { if ( abs ( x [ i ] ) < xmin ) { xmin = abs ( x [ i ] ) ; k = i ; } if ( x [ i ] != 0.0 ) y [ i ] = ( y [ i ] - cof [ j ] ) / x [ i ] ; } for ( i = k + 1 ; i < n - j ; i ++ ) { y [ i - 1 ] = y [ i ] ; x [ i - 1 ] = x [ i ] ; } } }
tr	8	private boolean r_perfective_gerund ( ) { int among_var ; int v_1 ; ket = cursor ; among_var = find_among_b ( a_0 , 9 ) ; if ( among_var == 0 ) { return false ; } bra = cursor ; switch ( among_var ) { case 0 : return false ; case 1 : lab0 : do { v_1 = limit - cursor ; lab1 : do { if ( ! ( eq_s_b ( 1 , "\u0430" ) ) ) { break lab1 ; } break lab0 ; } while ( false ) ; cursor = limit - v_1 ; if ( ! ( eq_s_b ( 1 , "\u044F" ) ) ) { return false ; } } while ( false ) ; slice_del ( ) ; break ; case 2 : slice_del ( ) ; break ; } return true ; }
tr	2	public void morpToDrones ( Set < Unit > larvae ) { if ( larvae == null ) { return ; } for ( Unit larva : larvae ) { ExecuteOrders . instance . morphToDrone ( larva ) ; } }
tr	6	@ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; RecordTypeNode other = ( RecordTypeNode ) obj ; if ( fieldLists == null ) { if ( other . fieldLists != null ) return false ; } else if ( ! fieldLists . equals ( other . fieldLists ) ) return false ; return true ; }
tr	1	private void haeButtonActionPerformed ( java . awt . event . ActionEvent evt ) { if ( otaTalteen ( ) ) { hae ( ) ; tyhjenna ( ) ; } }
tr	5	protected Alternation alternation ( ) throws IOException , MatchException { Alternation alternation = new Alternation ( ) ; alternation . addConcatenation ( concatenation ( ) ) ; while ( match ( is . peek ( ) , new int [ ] { 20 , ; , / } ) ) { while ( match ( is . peek ( ) , 20 ) || match ( is . peek ( ) , ; ) ) { c_wsp ( ) ; } assertMatch ( is . peek ( ) , / ) ; is . read ( ) ; while ( match ( is . peek ( ) , 20 ) || match ( is . peek ( ) , ; ) ) { c_wsp ( ) ; } alternation . addConcatenation ( concatenation ( ) ) ; } return alternation ; }
tr	6	@ Override public void run ( ) { if ( getLocation ( ) . distance ( bankerTile ) <= 10 ) { goHome ( ) ; } Time . sleep ( rand . nextInt ( 2000 ) ) ; if ( getLocation ( ) . equals ( new Tile ( 3262 , 3322 , 0 ) ) || getLocation ( ) . equals ( new Tile ( 3262 , 3323 , 0 ) ) ) { Walking . walk ( Field ) ; Time . sleep ( 5000 ) ; } SceneObject Gate = SceneEntities . getNearest ( new Filter < SceneObject > ( ) { public boolean accept ( SceneObject entity ) { return entity . getId ( ) == 45206 ; } } ) ; if ( getLocation ( ) . distance ( Gate ) <= 5 ) { Gate . interact ( "Open" ) ; Time . sleep ( 3000 ) ; } if ( getLocation ( ) . distance ( Gate ) <= 5 && ! Gate . isOnScreen ( ) ) { Camera . turnTo ( Gate ) ; Time . sleep ( 3000 ) ; } }
tr	1	public long readLong ( ) { byte [ ] b = new byte [ 8 ] ; for ( int index = 0 ; index < 8 ; index ++ ) b [ index ] = payload . get ( index + pointer ) ; pointer += 8 ; return ByteBuffer . wrap ( b ) . order ( ByteOrder . BIG_ENDIAN ) . getLong ( ) ; }
tr	3	public static Sha1Hash forValue ( Value < ? > value ) { MessageDigest md = null ; try { md = MessageDigest . getInstance ( "SHA1" ) ; } catch ( NoSuchAlgorithmException e ) { return null ; } BencodeOutputStream bout = new BencodeOutputStream ( new DigestOutputStream ( new VoidOutputStream ( ) , md ) ) ; try { bout . writeValue ( value ) ; } catch ( IOException e ) { return null ; } finally { bout . close ( ) ; } return new Sha1Hash ( md . digest ( ) ) ; }
tr	6	@ Test public void testConstructor ( ) { String nulltag = null ; Object nullval = null ; DataField field = new DataField ( "" ) ; field . getValue ( ) ; field = new DataField ( nullval ) ; field = new DataField ( new long ( 0 ) ) ; field = new DataField ( new String ( ) , new String ( ) ) ; new DataField ( nulltag , nullval ) ; field = new DataField ( 0 ) ; field = new DataField ( new String ( ) , 0 ) ; field = new DataField ( nulltag , 0 ) ; field = new DataField ( 0 ) ; field = new DataField ( new String ( ) , 0 ) ; field = new DataField ( nulltag , 0 ) ; field = new DataField ( ( short ) 0 ) ; field = new DataField ( new String ( ) , ( short ) 0 ) ; field = new DataField ( nulltag , ( short ) 0 ) ; field = new DataField ( new byte [ 0 ] ) ; field = new DataField ( new String ( ) , new byte [ 0 ] ) ; field = new DataField ( nulltag , new byte [ 0 ] ) ; field = new DataField ( ( byte [ ] ) null ) ; field = new DataField ( nulltag , ( byte [ ] ) null ) ; field = new DataField ( 0f ) ; field = new DataField ( new String ( ) , 0f ) ; field = new DataField ( nulltag , 0f ) ; field = new DataField ( 0d ) ; field = new DataField ( new String ( ) , 0d ) ; field = new DataField ( nulltag , 0d ) ; field = new DataField ( true ) ; field = new DataField ( new String ( ) , true ) ; field = new DataField ( nulltag , true ) ; field = new DataField ( new Date ( ) ) ; field = new DataField ( new String ( ) , new Date ( ) ) ; field = new DataField ( null , new Date ( ) ) ; try { field = new DataField ( new URI ( "" ) ) ; } catch ( IllegalArgumentException e ) { fail ( e . getMessage ( ) ) ; } catch ( URISyntaxException e ) { fail ( e . getMessage ( ) ) ; } try { field = new DataField ( new String ( ) , new URI ( "" ) ) ; } catch ( IllegalArgumentException e ) { fail ( e . getMessage ( ) ) ; } catch ( URISyntaxException e ) { fail ( e . getMessage ( ) ) ; } try { field = new DataField ( nulltag , new URI ( "" ) ) ; } catch ( IllegalArgumentException e ) { fail ( e . getMessage ( ) ) ; } catch ( URISyntaxException e ) { fail ( e . getMessage ( ) ) ; } }
tr	0	private static String trad4 ( TreeNode tree ) { return tree . getStringValue ( ) ; }
tr	4	public void mouseDragged ( MouseEvent e ) { if ( e . getX ( ) < 0 || e . getY ( ) < 0 || e . getX ( ) > this . getWidth ( ) || e . getY ( ) > this . getHeight ( ) ) return ; previousMouseCoords = currentMouseCoords ; currentMouseCoords = convertMouseToCoords ( e . getX ( ) , e . getY ( ) ) ; double xPos , yPos ; xPos = center . x ( ) - ( currentMouseCoords . x ( ) - previousMouseCoords . x ( ) ) ; yPos = center . y ( ) - ( currentMouseCoords . y ( ) - previousMouseCoords . y ( ) ) ; center = correctOutOfBounds ( new Coord ( xPos , yPos ) ) ; currentMouseCoords = convertMouseToCoords ( e . getX ( ) , e . getY ( ) ) ; updateObservers ( center , currentMouseCoords , RANGE , MAX_RANGE , this . getWidth ( ) , this . getHeight ( ) ) ; this . repaint ( ) ; }
tr	7	public boolean postMortem ( PostMortem pm ) { boolean result = true ; Symbol that = ( Symbol ) pm ; if ( this . integer != that . integer || this . weight != that . weight ) { return false ; } if ( ( this . back == null ) != ( that . back == null ) ) { return false ; } Symbol zero = this . zero ; Symbol one = this . one ; if ( zero == null ) { if ( that . zero != null ) { return false ; } } else { result = zero . postMortem ( that . zero ) ; } if ( one == null ) { if ( that . one != null ) { return false ; } } else { result = one . postMortem ( that . one ) ; } return result ; }
tr	6	public boolean configure ( int timeOutMillis ) { long startTime = System . currentTimeMillis ( ) ; synchronized ( this ) { if ( player instanceof Processor ) ( ( Processor ) player ) . configure ( ) ; else if ( player instanceof Player ) ( ( Processor ) player ) . configure ( ) ; else return false ; while ( ! configured && ! failed ) { try { wait ( timeOutMillis ) ; } catch ( InterruptedException ie ) { } if ( System . currentTimeMillis ( ) - startTime > timeOutMillis ) break ; } } return configured ; }
tr	8	public void die ( ) { xDeathPos = ( int ) x ; yDeathPos = ( int ) y ; world . paused = true ; deathTime = 1 ; Art . stopMusic ( ) ; world . sound . play ( Art . samples [ Art . SAMPLE_MARIO_DEATH ] , this , 1 , 1 , 1 ) ; if ( world . recorder != null ) { if ( running ) world . recorder . endRunningRecord ( ) ; if ( large && ! fire ) { world . recorder . endLargeRecord ( ) ; } if ( fire ) { world . recorder . endFireRecord ( ) ; } if ( ! large && ! fire ) world . recorder . endLittleRecord ( ) ; if ( ducking ) world . recorder . endDuckRecord ( ) ; world . recorder . endTime ( ) ; world . recorder . recordJumpLand ( ) ; } large = false ; fire = false ; }
tr	3	public static boolean matches ( List < ? > list ) { if ( ! list . isEmpty ( ) ) { Object value = list . get ( 0 ) ; if ( value instanceof boolean ) { return ( boolean ) value ; } else { return true ; } } return false ; }
tr	6	public T getEdge ( int i , int j ) throws IllegalArgumentException { if ( i < 0 || i >= numberOfVertices || j < 0 || j >= numberOfVertices ) { String errorMessage = "Allows vertex indizes are 0.." + ( numberOfVertices - 1 ) + "." ; throw new IllegalArgumentException ( errorMessage ) ; } for ( T e : adjacencyList [ i ] ) { if ( e . getTarget ( ) == j ) { return e ; } } return null ; }
tr	4	@ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( ! ( o instanceof Coordinates ) ) return false ; Coordinates that = ( Coordinates ) o ; if ( ! latitude . equals ( that . latitude ) ) return false ; if ( ! longitude . equals ( that . longitude ) ) return false ; return true ; }
tr	5	protected String getNestedUsage ( String [ ] args , int level , Method method , T player ) throws CommandException { StringBuilder command = new StringBuilder ( ) ; command . append ( "/" ) ; for ( int i = 0 ; i <= level ; ++ i ) { command . append ( args [ i ] + " " ) ; } Map < String , Method > map = commands . get ( method ) ; boolean found = false ; command . append ( "<" ) ; Set < String > allowedCommands = new HashSet < String > ( ) ; for ( Map . Entry < String , Method > entry : map . entrySet ( ) ) { Method childMethod = entry . getValue ( ) ; found = true ; if ( hasPermission ( childMethod , player ) ) { Command childCmd = childMethod . getAnnotation ( Command . class ) ; allowedCommands . add ( childCmd . aliases ( ) [ 0 ] ) ; } } if ( allowedCommands . size ( ) > 0 ) { command . append ( StringUtil . joinString ( allowedCommands , "|" , 0 ) ) ; } else { if ( ! found ) { command . append ( "?" ) ; } else { throw new CommandPermissionsException ( ) ; } } command . append ( ">" ) ; return command . toString ( ) ; }
tr	1	public static boolean isNull ( byte [ ] key ) { if ( key == null ) { return true ; } return isNull ( key , key . length ) ; }
tr	2	@ Override public void actionPerformed ( ActionEvent Event ) { if ( Event . getSource ( ) == this . ButtonStoryPlayer ) { if ( ! Arrays . asList ( this . PanelStoryPlayer . getComponents ( ) ) . contains ( this . StoryArea ) ) { this . SneekGame = new StorySneek ( "Sneek (Story Mode)" , new GameSettings ( ImageHelper . GetStoryFace ( ) , ImageHelper . GetCookie ( ) ) ) ; this . PanelStoryPlayer . add ( this . StoryArea ) ; this . PanelStoryPlayer . repaint ( ) ; } else { this . SneekGame . LaunchGame ( ) ; this . SneekGame = null ; this . PanelStoryPlayer . remove ( this . StoryArea ) ; this . PanelStoryPlayer . repaint ( ) ; } } }
tr	9	public String toKML ( boolean suppressEnclosingTags ) { String kml = "" ; if ( ! suppressEnclosingTags ) { kml += "<LookAt" ; if ( this . id != null ) { kml += " id=\"" + this . getId ( ) + "\"" ; } if ( this . targetId != null ) { kml += " targetId=\"" + this . getTargetId ( ) + "\"" ; } kml += ">\n" ; } kml += super . toKML ( true ) ; if ( this . longitude != DEFAULT_LONGITUDE ) { kml += "<longitude>" + this . longitude + "</longitude>\n" ; } if ( this . latitude != DEFAULT_LATITUDE ) { kml += "<latitude>" + this . latitude + "</latitude>\n" ; } if ( this . altitude != DEFAULT_ALTITUDE ) { kml += "<altitude>" + this . altitude + "</altitude>\n" ; } kml += "<range>" + this . range + "</range>\n" ; if ( this . tilt != DEFAULT_TILT ) { kml += "<tilt>" + this . tilt + "</tilt>\n" ; } if ( this . heading != DEFAULT_HEADING ) { kml += "<heading>" + this . heading + "</heading>\n" ; } if ( this . altitudeMode != null ) { kml += "<altitudeMode>" + SpecialCaseFormatter . toKMLString ( this . altitudeMode ) + "</altitudeMode>\n" ; } if ( ! suppressEnclosingTags ) { kml += "</LookAt>\n" ; } return kml ; }
tr	6	private RenderableObject generateObject ( String next , Scanner inFile ) { RenderableObject ro = null ; switch ( next ) { case "Ellipse" : ro = generateElipse ( inFile ) ; break ; case "Rectangle" : ro = generateRectangle ( inFile ) ; break ; case "Text" : ro = generateText ( inFile ) ; break ; case "Shape" : ro = generateShape ( inFile ) ; break ; case "Image" : ro = generateImage ( inFile ) ; break ; case "Latex" : ro = generateLatex ( inFile ) ; break ; default : System . out . println ( "Error In File" ) ; System . exit ( 1 ) ; } return ro ; }
tr	1	public Hora ( String cadena ) { String literal1 = cadena . substring ( 0 , cadena . indexOf ( ":" ) ) ; String literal2 = cadena . substring ( cadena . indexOf ( ":" ) + 1 , cadena . length ( ) ) ; if ( cadena . contains ( ":" ) ) { this . cadena = cadena ; this . hora = Integer . parseInt ( literal1 ) ; this . minutos = Integer . parseInt ( literal2 ) ; } }
tr	2	public void newfile ( ) { final String title = "Create New List" ; final String message = "Enter list name:" ; String name = JOptionPane . showInputDialog ( null , message , title , JOptionPane . PLAIN_MESSAGE ) ; if ( name == null ) return ; if ( ! closeFile ( ) ) return ; current_file = null ; getListManager ( ) . setList ( new SKList ( name ) ) ; getListManager ( ) . clearHistory ( ) ; dirty = false ; console . verbose ( "Created new list (" + Console . italics ( name ) + ")" ) ; refreshTitle ( ) ; }
tr	3	@ Override public void delete ( TypeAttribute typeAttribute ) { Session session = null ; try { session = HibernateUtil . getSessionFactory ( ) . openSession ( ) ; session . beginTransaction ( ) ; session . delete ( typeAttribute ) ; session . getTransaction ( ) . commit ( ) ; } catch ( Exception e ) { System . err . println ( "\u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u0443\u0434\u0430\u043B\u0435\u043D\u0438\u0438" + e . getMessage ( ) ) ; } finally { if ( session != null && session . isOpen ( ) ) { session . close ( ) ; } } }
tr	3	public int getAverageScore ( boolean noCurrentScore ) { int averageScore = gameStatus . players [ playerIndex ] . getScore ( ) ; int scoreCount = 1 ; if ( noCurrentScore ) { averageScore = 0 ; scoreCount = 0 ; } if ( previousScores != null ) { for ( int score : previousScores ) { averageScore += score ; scoreCount ++ ; } averageScore /= scoreCount ; } return averageScore ; }
tr	4	@ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; SMValue smValue = ( SMValue ) o ; return value == null ? smValue . value == null : value . equals ( smValue . value ) ; }
tr	6	public static class walkResources ( class clazz , class < ? extends java . lang . annotation . Annotation > annotationClass ) { System . out . println ( "ENTER getSubResourceClass" ) ; for ( class < ? > actualClass = clazz ; keepLookingForTopClass ( actualClass ) ; actualClass = actualClass . getSuperclass ( ) ) { if ( hasAnnotations ( actualClass , annotationClass ) ) { System . out . println ( "FOUND: " + actualClass ) ; } } for ( class intf : clazz . getInterfaces ( ) ) { if ( hasAnnotations ( intf , annotationClass ) ) { System . out . println ( "FOUND interfacef: " + intf ) ; } } System . out . println ( "LEAVE getSubResourceClass" ) ; return null ; }
tr	3	public int [ ] getActions ( Game game , long timeDue ) { int [ ] directions = new int [ Game . NUM_GHOSTS ] ; for ( int i = 0 ; i < directions . length ; i ++ ) if ( game . ghostRequiresAction ( i ) ) { if ( Game . rnd . nextFloat ( ) < CONSISTENCY ) directions [ i ] = game . getNextGhostDir ( i , game . getCurPacManLoc ( ) , attract , Game . DM . PATH ) ; else { int [ ] possibleDirs = game . getPossibleGhostDirs ( i ) ; directions [ i ] = possibleDirs [ G . rnd . nextInt ( possibleDirs . length ) ] ; } } return directions ; }
tr	6	@ Override public int hashCode ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + ( ( album == null ) ? 0 : album . hashCode ( ) ) ; result = prime * result + ( ( artist == null ) ? 0 : artist . hashCode ( ) ) ; result = prime * result + ( ( comment == null ) ? 0 : comment . hashCode ( ) ) ; result = prime * result + genre ; result = prime * result + ( ( title == null ) ? 0 : title . hashCode ( ) ) ; result = prime * result + ( ( track == null ) ? 0 : track . hashCode ( ) ) ; result = prime * result + ( ( year == null ) ? 0 : year . hashCode ( ) ) ; return result ; }
tr	7	private static Object traverse ( Object origin , JSONArray refs , boolean fixup ) throws JSONException { try { JSONArray arr = null ; JSONObject obj = null ; if ( origin instanceof JSONArray ) { arr = ( JSONArray ) origin ; } else { obj = ( JSONObject ) origin ; } int stop = refs . length ( ) ; if ( fixup ) { stop -- ; } for ( int i = 0 ; i < stop ; i ++ ) { Object next ; if ( arr == null ) { next = next ( obj , refs . optString ( i , null ) ) ; } else { next = next ( arr , refs . optInt ( i , - 1 ) ) ; } if ( next instanceof JSONObject ) { obj = ( JSONObject ) next ; arr = null ; } else { obj = null ; arr = ( JSONArray ) next ; } } if ( arr == null ) { return obj ; } return arr ; } catch ( Exception e ) { log . error ( "unexpected exception" , e ) ; throw new JSONException ( "unexpected exception" ) ; } }
tr	1	@ Override public boolean equals ( Object obj ) { System . out . println ( toString ( ) + " == " + ( ( Paciente ) obj ) . toString ( ) ) ; return this . getNome ( ) . equals ( ( ( Paciente ) obj ) . getNome ( ) ) && this . getCpf ( ) == ( ( Paciente ) obj ) . getCpf ( ) ; }
tr	6	private AbstractNode expression ( ) { AbstractNode res = simpleExp ( ) ; if ( test ( = ) ) { read ( = , "=" ) ; res = new BinOpNode ( = , res , simpleExp ( ) ) ; } if ( test ( NEQ ) ) { read ( NEQ , "#" ) ; res = new BinOpNode ( NEQ , res , simpleExp ( ) ) ; } if ( test ( LO ) ) { read ( LO , "<" ) ; res = new BinOpNode ( LO , res , simpleExp ( ) ) ; } if ( test ( LOEQ ) ) { read ( LOEQ , "<=" ) ; res = new BinOpNode ( LOEQ , res , simpleExp ( ) ) ; } if ( test ( HI ) ) { read ( HI , ">" ) ; res = new BinOpNode ( HI , res , simpleExp ( ) ) ; } if ( test ( HIEQ ) ) { read ( HIEQ , ">=" ) ; res = new BinOpNode ( HIEQ , res , simpleExp ( ) ) ; } return res ; }
tr	8	public void decode ( InputStream stream , int length , CharBuffer buffer ) throws IllegalArgumentException , IOException { if ( stream == null ) throw new IllegalArgumentException ( "stream cannot be null" ) ; if ( length < 0 ) throw new IllegalArgumentException ( "length [" + length + "] must be >= 0." ) ; if ( buffer == null ) throw new IllegalArgumentException ( "buffer cannot be null and must be a CharBuffer with a large enough capacity to hold at least 'length' (" + length + ") characters." ) ; if ( length > buffer . capacity ( ) ) throw new IllegalArgumentException ( "length [" + length + "] is larger than the capacity [" + buffer . capacity ( ) + "] of the given buffer; the CharBuffer must be big enough to contain all the characters decoded from the given InputStream." ) ; if ( length == 0 ) buffer . clear ( ) ; else { bBuffer . clear ( ) ; buffer . clear ( ) ; decoder . reset ( ) ; int read = 0 ; while ( length > 0 && ( read = stream . read ( rBuffer , 0 , length ) ) != - 1 ) { length -= read ; bBuffer . position ( 0 ) ; bBuffer . limit ( read ) ; decoder . decode ( bBuffer , buffer , ( length == 0 ) ) ; } if ( length > 0 ) throw new IOException ( "End of Stream encountered before all requested bytes [" + ( length + read ) + "] could be read. Unable to read the last " + length + " remaining bytes." ) ; decoder . flush ( buffer ) ; } }
tr	3	public double getPrecio ( ) { if ( tipo == TipoConsola . XBOX ) { return 299 ; } else if ( tipo == TipoConsola . WII ) { return 199 ; } else if ( tipo == TipoConsola . PS3 ) { return 320 ; } else { return - 1 ; } }
tr	0	public double getPickUpPuckBaseChance ( ) { return pickUpPuckBaseChance ; }
tr	8	@ Test public void test ( ) { long [ ] arr = new long [ 100 ] ; int nElems = 0 ; int j ; long searchKey ; arr [ 0 ] = 77 ; arr [ 1 ] = 99 ; arr [ 2 ] = 44 ; arr [ 3 ] = 55 ; arr [ 4 ] = 22 ; arr [ 5 ] = 88 ; arr [ 6 ] = 00 ; arr [ 7 ] = 66 ; arr [ 8 ] = 33 ; arr [ 9 ] = 10 ; nElems = 10 ; for ( j = 0 ; j < nElems ; j ++ ) { System . out . print ( arr [ j ] + " " ) ; } System . out . println ( "" ) ; searchKey = 27 ; for ( j = 0 ; j < nElems ; j ++ ) { if ( arr [ j ] == searchKey ) { break ; } } if ( j == nElems ) { System . out . println ( "Can't find " + searchKey ) ; } else { System . out . println ( "Found " + searchKey ) ; } searchKey = 55 ; for ( j = 0 ; j < nElems ; j ++ ) { if ( arr [ j ] == searchKey ) { break ; } } for ( int k = j ; k < nElems ; k ++ ) { arr [ k ] = arr [ k + 1 ] ; } nElems -- ; for ( j = 0 ; j < nElems ; j ++ ) { System . out . print ( arr [ j ] + " " ) ; } System . out . println ( " " ) ; }
tr	5	public void setPause ( boolean pause ) { if ( ogg != null ) { if ( pause ) { ogg . pause ( ) ; } else { ogg . resume ( ) ; } } if ( clip != null ) { try { if ( clip . isControlSupported ( BooleanControl . Type . MUTE ) ) { BooleanControl muteControl = ( BooleanControl ) clip . getControl ( BooleanControl . Type . MUTE ) ; muteControl . setValue ( pause ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } }
tr	8	public static String query ( int table_id , String str , int start_index , int max_fetch ) throws Exception { JSONObject result = new JSONObject ( ) ; JSONArray entry_list = new JSONArray ( ) ; Map temp = new LinkedHashMap ( ) ; int max_count , count ; int maxCount [ ] = new int [ 6 ] ; Connection Con = global . getConnection ( ) ; switch ( table_id ) { case 0 : { entry_list . clear ( ) ; start_index /= 6 ; max_fetch /= 6 ; maxCount [ 0 ] = Course . getResultCount ( Con , str ) ; maxCount [ 1 ] = Student . getResultCount ( Con , str ) ; maxCount [ 2 ] = Instructor . getResultCount ( Con , str ) ; maxCount [ 3 ] = Work . getResultCount ( Con , str ) ; maxCount [ 4 ] = Project . getResultCount ( Con , str ) ; maxCount [ 5 ] = Post . getResultCount ( Con , str ) ; max_count = 0 ; SortedSet < Pair > set = new TreeSet < Pair > ( ) ; for ( int ii = 0 ; ii < 6 ; ii ++ ) { set . add ( new Pair ( ii , maxCount [ ii ] ) ) ; max_count += maxCount [ ii ] ; } addResults ( entry_list , set , Con , str , start_index , max_fetch ) ; break ; } case 1 : { entry_list = Course . Query ( Con , str , start_index , max_fetch ) ; max_count = Course . getResultCount ( Con , str ) ; break ; } case 2 : { entry_list = Student . Query ( Con , str , start_index , max_fetch ) ; max_count = Student . getResultCount ( Con , str ) ; break ; } case 3 : { entry_list = Instructor . Query ( Con , str , start_index , max_fetch ) ; max_count = Instructor . getResultCount ( Con , str ) ; break ; } case 4 : { entry_list = Project . Query ( Con , str , start_index , max_fetch ) ; max_count = Project . getResultCount ( Con , str ) ; break ; } case 5 : { entry_list = Work . Query ( Con , str , start_index , max_fetch ) ; max_count = Work . getResultCount ( Con , str ) ; break ; } case 6 : { entry_list = Post . Query ( Con , str , start_index , max_fetch ) ; max_count = Post . getResultCount ( Con , str ) ; break ; } default : { max_count = 0 ; break ; } } count = entry_list . size ( ) ; temp . put ( "max_count" , max_count ) ; temp . put ( "count" , count ) ; temp . put ( "entries" , entry_list ) ; result . put ( "results" , temp ) ; Con . close ( ) ; return result . toJSONString ( ) ; }
tr	2	public Object getValueAt ( int row , int col ) { Object [ ] entries = meterReadings . keySet ( ) . toArray ( ) ; Date entry = ( Date ) entries [ row ] ; if ( col == 0 ) return meterReadings . get ( entry ) . getReadingDate ( ) ; else if ( col == 1 ) { return meterReadings . get ( entry ) . getReading ( ) ; } else throw new IndexOutOfBoundsException ( "MeterReadingViewTableModel provides a 4-column table  column-index " + col + " is illegal." ) ; }
tr	2	private boolean allCons ( int i , int n , String word ) { int startIndex = i - n ; int endIndex = i ; for ( int j = startIndex ; j < endIndex ; j ++ ) { if ( vowels . contains ( word . charAt ( j ) ) ) { return false ; } } return true ; }
tr	9	@ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( obj instanceof GetAccountPolicyResult == false ) return false ; GetAccountPolicyResult other = ( GetAccountPolicyResult ) obj ; if ( other . getAccountName ( ) == null ^ this . getAccountName ( ) == null ) return false ; if ( other . getAccountName ( ) != null && other . getAccountName ( ) . equals ( this . getAccountName ( ) ) == false ) return false ; if ( other . getPolicyName ( ) == null ^ this . getPolicyName ( ) == null ) return false ; if ( other . getPolicyName ( ) != null && other . getPolicyName ( ) . equals ( this . getPolicyName ( ) ) == false ) return false ; if ( other . getPolicyDocument ( ) == null ^ this . getPolicyDocument ( ) == null ) return false ; if ( other . getPolicyDocument ( ) != null && other . getPolicyDocument ( ) . equals ( this . getPolicyDocument ( ) ) == false ) return false ; return true ; }
tr	9	@ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; Demo other = ( Demo ) obj ; if ( ! getOuterType ( ) . equals ( other . getOuterType ( ) ) ) return false ; if ( method == null ) { if ( other . method != null ) return false ; } else if ( ! method . equals ( other . method ) ) return false ; if ( name == null ) { if ( other . name != null ) return false ; } else if ( ! name . equals ( other . name ) ) return false ; return true ; }
tr	2	public void printInfo ( ) { System . out . println ( "Arithmos Xeirourgiwn :" + NumberOrSyrgeries ) ; for ( int i = 0 ; i <= tepRooms . size ( ) ; i ++ ) System . out . println ( "Dwmatio :" + tepRooms . get ( i ) ) ; for ( int i = 0 ; i <= tepSurgeries . size ( ) ; i ++ ) System . out . println ( "Xeirourgio :" + tepSurgeries . get ( i ) ) ; }
tr	4	private static boolean [ ] getComponentGapPush ( ArrayList < CompWrap > compWraps , boolean isHor ) { boolean [ ] barr = new boolean [ compWraps . size ( ) + 1 ] ; for ( int i = 0 ; i < barr . length ; i ++ ) { boolean push = i > 0 && compWraps . get ( i - 1 ) . isPushGap ( isHor , false ) ; if ( push == false && i < ( barr . length - 1 ) ) push = compWraps . get ( i ) . isPushGap ( isHor , true ) ; barr [ i ] = push ; } return barr ; }
tr	1	public double timesRestart ( Character c ) { if ( restart . containsKey ( c ) ) { return restart . getValue ( c ) ; } else { return 0 ; } }
tr	4	protected void setMoveLocations ( Location [ ] newMoves ) { if ( this . moveLocations != null ) for ( Location loc : this . moveLocations ) { this . pieces . get ( loc ) . resetColor ( ) ; } this . moveLocations = newMoves ; if ( this . moveLocations != null ) for ( Location loc : this . moveLocations ) { this . pieces . get ( loc ) . setCurColor ( BoardColor . MOVES ) ; } }
tr	6	private static byte [ ] encode3to4 ( byte [ ] source , int srcOffset , int numSigBytes , byte [ ] destination , int destOffset , int options ) { byte [ ] ALPHABET = getAlphabet ( options ) ; int inBuff = ( numSigBytes > 0 ? ( ( source [ srcOffset ] << 24 ) >>> 8 ) : 0 ) | ( numSigBytes > 1 ? ( ( source [ srcOffset + 1 ] << 24 ) >>> 16 ) : 0 ) | ( numSigBytes > 2 ? ( ( source [ srcOffset + 2 ] << 24 ) >>> 24 ) : 0 ) ; switch ( numSigBytes ) { case 3 : destination [ destOffset ] = ALPHABET [ ( inBuff >>> 18 ) ] ; destination [ destOffset + 1 ] = ALPHABET [ ( inBuff >>> 12 ) & 3f ] ; destination [ destOffset + 2 ] = ALPHABET [ ( inBuff >>> 6 ) & 3f ] ; destination [ destOffset + 3 ] = ALPHABET [ ( inBuff ) & 3f ] ; return destination ; case 2 : destination [ destOffset ] = ALPHABET [ ( inBuff >>> 18 ) ] ; destination [ destOffset + 1 ] = ALPHABET [ ( inBuff >>> 12 ) & 3f ] ; destination [ destOffset + 2 ] = ALPHABET [ ( inBuff >>> 6 ) & 3f ] ; destination [ destOffset + 3 ] = EQUALS_SIGN ; return destination ; case 1 : destination [ destOffset ] = ALPHABET [ ( inBuff >>> 18 ) ] ; destination [ destOffset + 1 ] = ALPHABET [ ( inBuff >>> 12 ) & 3f ] ; destination [ destOffset + 2 ] = EQUALS_SIGN ; destination [ destOffset + 3 ] = EQUALS_SIGN ; return destination ; default : return destination ; } }
tr	8	public void loadSimulationFromFile ( File f ) throws IOException { BufferedReader in = new BufferedReader ( new FileReader ( f ) ) ; HashMap < String , Element > elements = new HashMap < String , Element > ( ) ; snapshots . clear ( ) ; elements . clear ( ) ; time = 0 ; Snapshot current = null ; String heightMapName = in . readLine ( ) ; if ( heightMapName . equals ( "-1" ) || ! new File ( heightMapName ) . exists ( ) ) hm = new HeightMap ( ) ; else hm = new HeightMap ( new File ( heightMapName ) ) ; while ( in . ready ( ) ) { String line = in . readLine ( ) ; if ( line . equals ( "{" ) ) current = new Snapshot ( 0 , Integer . parseInt ( in . readLine ( ) ) ) ; else if ( line . equals ( "}" ) && current != null ) snapshots . add ( current ) ; else if ( current != null ) current . add ( RenderObject . fromString ( line , elements ) ) ; } if ( snapshots . size ( ) > 0 ) { totalTime = snapshots . get ( snapshots . size ( ) - 1 ) . timeTaken ; apply ( 0 ) ; } else totalTime = 0 ; in . close ( ) ; }
tr	5	public int Evaluate ( GameState gs , boolean createText ) { gs . compute_tertiary_bitboards ( ) ; this . createText = createText ; eval_calls ++ ; int score = 0 ; if ( createText ) { eval_text = "Position Evaluation Results\n" ; eval_text += "Side to Move: " + gs . player + " \n" ; } score += getPieceLocationEvaluation ( gs ) ; score -= score_offset ; if ( score >= 29990 ) { score = + 29990 ; } if ( score <= - 29990 ) { score = - 29990 ; } if ( createText ) { eval_text += "Score: " + score + " (White's POV)\n" ; } return ( gs . player == PL_WHITE ) ? score : - score ; }
tr	1	public static void main ( String [ ] args ) { try { AppGameContainer app = new AppGameContainer ( new Application ( ) ) ; app . setDisplayMode ( SCREEN_WIDTH , SCREEN_HEIGHT , false ) ; app . start ( ) ; } catch ( SlickException e ) { e . printStackTrace ( ) ; } }
tr	7	@ Override public User getUser ( String login , String password ) throws DAOException { final String filename = Constants . ResourcePath + ConstantsXML . USERS_FILE_NAME ; final String CSV_SPLITTER = ";" ; Scanner sc = null ; synchronized ( CSVUserDAO . class ) { try { boolean found = false ; sc = new Scanner ( new FileReader ( filename ) ) ; Role role = null ; String [ ] str = null ; while ( sc . hasNext ( ) ) { str = sc . nextLine ( ) . split ( CSV_SPLITTER ) ; if ( str [ LOGIN_NUM ] . equals ( login ) && str [ PASSWORD_NUM ] . equals ( password ) ) { role = Role . valueOf ( str [ ROLE_NUM ] . toUpperCase ( ) ) ; found = true ; break ; } } if ( ! found ) { throw new DAOException ( Constants . INVALID_NAME_OR_PASSWORD ) ; } return new User ( login , password , str [ EMAIL_NUM ] , str [ PHONE_NUM ] , role , Integer . parseInt ( str [ ID_NUM ] ) ) ; } catch ( DAOException e ) { throw new DAOException ( e ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; throw new DAOException ( Constants . INTERNAL_ERROR ) ; } finally { if ( sc != null ) { sc . close ( ) ; } } } }
tr	7	private void openAddMeterPanel ( ) { boolean failure = false ; String options [ ] = { "Create" , "Cancel" } ; int result = JOptionPane . showOptionDialog ( null , addMeterPanel , "Add Meter to Account " + getSelectedAccountID ( ) , JOptionPane . DEFAULT_OPTION , JOptionPane . PLAIN_MESSAGE , null , options , options [ 0 ] ) ; if ( result == 0 ) { Meter m = getMeterFromAddMeterPanel ( ) ; Account temp = getSelectedAccount ( ) ; if ( m != null ) { if ( temp instanceof ResidentialAccount ) { ResidentialAccount resAcc = ( ResidentialAccount ) temp ; if ( resAcc . getMeter ( ) != null ) { boolean overWrite = confirmResidentialAccountConflict ( ) ; if ( ! overWrite ) return ; } } else if ( temp . hasMeter ( m . getMeterID ( ) ) ) { failure = true ; } } else { failure = true ; } if ( ! failure ) { temp . addMeter ( m ) ; System . out . println ( m . getMeterID ( ) ) ; showMetersInMeterTable ( temp ) ; } else { failToCreateMeterDialog ( ) ; } } }
tr	0	@ EventHandler ( priority = EventPriority . LOWEST ) public void paintingPlaceblock ( PaintingPlaceEvent event ) { prevent ( event , event . getPlayer ( ) , "placeblock." + Material . PAINTING . getId ( ) + " build." + Material . PAINTING . getId ( ) ) ; }
tr	8	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( DeliverClient . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( DeliverClient . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( DeliverClient . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( DeliverClient . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { try { new DeliverClient ( ) . setVisible ( true ) ; } catch ( UnknownHostException ex ) { Logger . getLogger ( DeliverClient . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( IOException ex ) { Logger . getLogger ( DeliverClient . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } } } ) ; }
tr	0	@ Override public Collection < Cursor < C >> getCursors ( ) { return Collections . unmodifiableCollection ( Arrays . asList ( _cursors ) ) ; }
tr	4	private static int toIndex ( Direction dir ) { switch ( dir ) { case SOUTH : return 0 ; case NORTH : return 1 ; case WEST : return 2 ; case EAST : return 3 ; } return 0 ; }
tr	8	public void run ( ) { ParallelWarteClass paraWait = new ParallelWarteClass ( 10000 ) ; paraWait . start ( ) ; while ( ! ( HWaccess . readInt ( Adressen . LaufbandAusgang . ordinal ( ) ) == 1 ) && paraWait . isAlive ( ) ) { try { Thread . sleep ( 150 ) ; } catch ( InterruptedException e ) { interrupt ( ) ; } } if ( ! paraWait . isAlive ( ) ) { interrupt ( ) ; return ; } else { paraWait . interrupt ( ) ; } paraWait = new ParallelWarteClass ( 10000 ) ; paraWait . start ( ) ; while ( ! ( HWaccess . readInt ( Adressen . LaufbandAusgang . ordinal ( ) ) == 0 ) && paraWait . isAlive ( ) ) { try { Thread . sleep ( 150 ) ; } catch ( InterruptedException e ) { this . interrupt ( ) ; } } if ( ! paraWait . isAlive ( ) ) { interrupt ( ) ; } else { paraWait . interrupt ( ) ; } result = true ; }
tr	1	public void demote ( Instance instance ) { super . demote ( instance ) ; double rate = - ( double ) time * demotionRate ; s . add ( FeatureVector . staticScale ( rate , instance ) ) ; if ( bias ) sBiasValue += rate ; }
tr	9	public void update ( ) { for ( int i = 0 ; i < waternodes . size ( ) ; i ++ ) { float x = waternodes . get ( i ) . physrect . getX ( ) ; float y = waternodes . get ( i ) . physrect . getY ( ) ; float width = waternodes . get ( i ) . physrect . getWidth ( ) ; float height = waternodes . get ( i ) . physrect . getHeight ( ) ; Node leaf = getLeaf ( x , y + height ) ; if ( leaf != null ) { if ( leaf . type == Block . EMPTY ) { fillCell ( x , y + height , Block . WATER ) ; emptyCell ( x , y ) ; continue ; } } leaf = getLeaf ( x + width , y ) ; if ( leaf != null ) { if ( leaf . type == Block . EMPTY ) { fillCell ( x + width , y , Block . WATER ) ; emptyCell ( x , y ) ; continue ; } } leaf = getLeaf ( x - width , y ) ; if ( leaf != null ) { if ( leaf . type == Block . EMPTY ) { fillCell ( x - width , y , Block . WATER ) ; emptyCell ( x , y ) ; continue ; } } } for ( int i = 0 ; i < acidnodes . size ( ) ; i ++ ) { float x = acidnodes . get ( i ) . physrect . getX ( ) ; float y = acidnodes . get ( i ) . physrect . getY ( ) ; float width = acidnodes . get ( i ) . physrect . getWidth ( ) ; float height = acidnodes . get ( i ) . physrect . getHeight ( ) ; Node leaf = getLeaf ( x , y + height ) ; if ( leaf != null ) { if ( leaf . type == Block . EMPTY ) { fillCell ( x , y + height , Block . ACID ) ; emptyCell ( x , y ) ; continue ; } } leaf = getLeaf ( x + width , y ) ; if ( leaf != null ) { if ( leaf . type == Block . EMPTY ) { fillCell ( x + width , y , Block . ACID ) ; emptyCell ( x , y ) ; continue ; } } leaf = getLeaf ( x - width , y ) ; if ( leaf != null ) { if ( leaf . type == Block . EMPTY ) { fillCell ( x - width , y , Block . ACID ) ; emptyCell ( x , y ) ; continue ; } } } }
tr	7	public void paint ( Graphics g ) { int x = ( int ) p . getX ( ) ; int y = ( int ) p . getY ( ) ; FontMetrics metrics = g . getFontMetrics ( font ) ; int w = metrics . stringWidth ( text ) ; int h = metrics . getHeight ( ) ; if ( halign == OptionComponent . TextOptions . Alignment . CENTER ) x -= w / 2 ; else if ( halign == OptionComponent . TextOptions . Alignment . RIGHT ) x -= w ; if ( valign == OptionComponent . TextOptions . Alignment . MIDDLE ) y += h / 2 ; else if ( valign == OptionComponent . TextOptions . Alignment . TOP ) y += h ; g . setFont ( font ) ; g . setColor ( color ) ; if ( canvas . renderMode != RenderMode . TILED ) g . drawString ( text , x , y ) ; else { Dimension img = canvas . getImageSize ( ) ; for ( int dx = 0 ; x + w - dx >= 0 ; dx += img . width ) for ( int dy = 0 ; y + h - dy >= 0 ; dy += img . height ) g . drawString ( text , x - dx , y - dy ) ; } }
tr	7	public static double tanh ( double x ) { boolean negate = false ; if ( x != x ) { return x ; } if ( x > 20.0 ) { return 1.0 ; } if ( x < - 20 ) { return - 1.0 ; } if ( x == 0 ) { return x ; } if ( x < 0.0 ) { x = - x ; negate = true ; } double result ; if ( x >= 0.5 ) { double hiPrec [ ] = new double [ 2 ] ; exp ( x * 2.0 , 0.0 , hiPrec ) ; double ya = hiPrec [ 0 ] + hiPrec [ 1 ] ; double yb = - ( ya - hiPrec [ 0 ] - hiPrec [ 1 ] ) ; double na = - 1.0 + ya ; double nb = - ( na + 1.0 - ya ) ; double temp = na + yb ; nb += - ( temp - na - yb ) ; na = temp ; double da = 1.0 + ya ; double db = - ( da - 1.0 - ya ) ; temp = da + yb ; db += - ( temp - da - yb ) ; da = temp ; temp = da * HEX_40000000 ; double daa = da + temp - temp ; double dab = da - daa ; double ratio = na / da ; temp = ratio * HEX_40000000 ; double ratioa = ratio + temp - temp ; double ratiob = ratio - ratioa ; ratiob += ( na - daa * ratioa - daa * ratiob - dab * ratioa - dab * ratiob ) / da ; ratiob += nb / da ; ratiob += - db * na / da / da ; result = ratioa + ratiob ; } else { double hiPrec [ ] = new double [ 2 ] ; expm1 ( x * 2.0 , hiPrec ) ; double ya = hiPrec [ 0 ] + hiPrec [ 1 ] ; double yb = - ( ya - hiPrec [ 0 ] - hiPrec [ 1 ] ) ; double na = ya ; double nb = yb ; double da = 2.0 + ya ; double db = - ( da - 2.0 - ya ) ; double temp = da + yb ; db += - ( temp - da - yb ) ; da = temp ; temp = da * HEX_40000000 ; double daa = da + temp - temp ; double dab = da - daa ; double ratio = na / da ; temp = ratio * HEX_40000000 ; double ratioa = ratio + temp - temp ; double ratiob = ratio - ratioa ; ratiob += ( na - daa * ratioa - daa * ratiob - dab * ratioa - dab * ratiob ) / da ; ratiob += nb / da ; ratiob += - db * na / da / da ; result = ratioa + ratiob ; } if ( negate ) { result = - result ; } return result ; }
tr	7	public static double doDefAbilityBasePowerMod ( ActivePokemon defender , Move move , double damage ) { if ( defender . hasAbility ( Ability . THICK_FAT ) && ( move . isType ( Type . ICE ) || move . isType ( Type . FIRE ) ) ) { damage *= 0.5 ; } else if ( defender . hasAbility ( Ability . HEATPROOF ) && move . isType ( Type . FIRE ) ) { damage *= 0.5 ; } else if ( defender . hasAbility ( Ability . DRY_SKIN ) && move . isType ( Type . FIRE ) ) { damage *= 1.25 ; } damage = ( int ) damage ; return damage ; }
tr	5	public void piirraVierusLiitokset ( Graphics g , ArrayList < int [ ] > muoto , int x , int y ) { for ( int i = 0 ; i < muoto . size ( ) ; i ++ ) { int [ ] piste = muoto . get ( i ) ; int pisteXPos = x + piste [ 0 ] ; int pisteYPos = y + piste [ 1 ] ; if ( vierusPiste ( muoto , i , 1 , 0 ) ) { g . fillRect ( pisteXPos * sivu + sisennys , pisteYPos * sivu + sisennys , sivu * 2 - sisennys * 2 , sivu - sisennys * 2 ) ; } if ( vierusPiste ( muoto , i , - 1 , 0 ) ) { g . fillRect ( ( pisteXPos - 1 ) * sivu , pisteYPos * sivu + sisennys , sivu * 2 - sisennys * 2 , sivu - sisennys * 2 ) ; } if ( vierusPiste ( muoto , i , 0 , 1 ) ) { g . fillRect ( pisteXPos * sivu + sisennys , pisteYPos * sivu + sisennys , sivu - sisennys * 2 , sivu * 2 - sisennys * 2 ) ; } if ( vierusPiste ( muoto , i , 0 , - 1 ) ) { g . fillRect ( pisteXPos * sivu + sisennys , ( pisteYPos - 1 ) * sivu , sivu - sisennys * 2 , sivu - sisennys * 2 ) ; } } }
tr	1	public void drawLine ( Graphics g , String text , int xPos , int yPos ) { int x = 0 ; for ( int i = 0 ; i < text . length ( ) ; i ++ ) { char currentChar = chars [ ( int ) text . charAt ( i ) ] ; currentChar . render ( g , xPos + x , yPos ) ; x += currentChar . getWidth ( ) ; } }
tr	4	public static FastFilter tag ( final String tagName , final boolean ignoreNamespace ) { if ( tagName == null || tagName . equals ( "" ) ) { return none ( ) ; } else if ( "*" . equals ( tagName ) ) { return all ( ) ; } else { return new FastFilter ( ) { @ Override public boolean filter ( Context context ) { String localName = context . element ( ) . getTagName ( ) ; if ( ignoreNamespace ) { localName = Util . stripNamespace ( localName ) ; } return tagName . equals ( localName ) ; } } ; } }
tr	8	@ Override public synchronized Object getValueAt ( int rowIndex , int columnIndex ) { Utente utente = getRow ( rowIndex ) ; switch ( columnIndex ) { case 0 : return utente . getId ( ) ; case 1 : return utente . nome ; case 2 : return utente . cognome ; case 3 : return utente . userName ; case 4 : { if ( utente . getUserType ( ) == Utente . ADMIN ) return "Admin" ; if ( utente . getUserType ( ) == Utente . CLIENTE ) return "Cliente" ; if ( utente . getUserType ( ) == Utente . OPERATORE ) return "Operatore" ; } default : return null ; } }
tr	2	@ Override public Rectangular getPosition ( Area a ) { if ( a . getParentArea ( ) == area && a instanceof DefaultArea ) return ( ( DefaultArea ) a ) . getGridPosition ( ) ; else return null ; }
