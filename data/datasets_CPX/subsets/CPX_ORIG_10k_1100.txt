tr	0	public ValueListener ( Event1 returnValue ) { this . returnValue = returnValue ; }
tr	4	@ Override public void update ( ) { int width = Game . getInstance ( ) . getWindow ( ) . getWidth ( ) ; int height = Game . getInstance ( ) . getWindow ( ) . getHeight ( ) ; this . header . verticalAlignCenter ( 0 , width ) ; this . btnCollection . verticalAlignCenter ( 0 , width ) ; this . btnCollection . horizontalAlignCenter ( 0 , height ) ; int counter = 0 ; this . btnCollection . update ( ) ; for ( TEView view : this . btnCollection . getCollection ( ) ) { TEButton btn = ( TEButton ) view ; if ( btn . isClicked ( ) ) { switch ( counter ) { case 0 : Game . getInstance ( ) . loadScene ( Scene . SCENE_SETTINGS ) ; return ; case 1 : Game . getInstance ( ) . loadScene ( SCENE_CREDITS ) ; return ; } } counter ++ ; } }
tr	6	private static int outcode ( double pX , double pY , double rectX , double rectY , double rectWidth , double rectHeight ) { int out = 0 ; if ( rectWidth <= 0 ) { out |= OUT_LEFT | OUT_RIGHT ; } else if ( pX < rectX ) { out |= OUT_LEFT ; } else if ( pX > rectX + rectWidth ) { out |= OUT_RIGHT ; } if ( rectHeight <= 0 ) { out |= OUT_TOP | OUT_BOTTOM ; } else if ( pY < rectY ) { out |= OUT_TOP ; } else if ( pY > rectY + rectHeight ) { out |= OUT_BOTTOM ; } return out ; }
tr	2	private char getPlayerSymbol ( int symbolNum ) { switch ( symbolNum ) { case 0 : return - ; case 1 : return X ; default : return O ; } }
tr	2	public void convert ( Ticket ticket ) { for ( de . robert_heim . unfuddle2bitbucket . model . unfuddle . Comment unfuddleComment : ticket . getComments ( ) ) { String username = null ; Person p = provider . getPeopleConverter ( ) . findPersonById ( unfuddleComment . getAuthorId ( ) ) ; if ( null == p ) { System . out . println ( "Warning: the comment-author with id '" + unfuddleComment . getAuthorId ( ) + "' could not be found in the input file. Using 'null'." ) ; } else { username = p . getName ( ) ; } Comment comment = new Comment ( unfuddleComment . getBody ( ) , unfuddleComment . getCreatedAt ( ) . toGregorianCalendar ( ) . getTime ( ) , getUniqueCommentId ( ) , ticket . getId ( ) , ticket . getUpdatedAt ( ) . toGregorianCalendar ( ) . getTime ( ) , username ) ; comments . add ( comment ) ; } }
tr	5	public static MinimumCostInsertionInfo minimumCostInsertionPosition ( ProblemInstance problemInstance , int vehicle , int client , ArrayList < Integer > route ) { double min = 99999999 ; int chosenInsertPosition = - 1 ; double cost ; double [ ] [ ] costMatrix = problemInstance . costMatrix ; int depotCount = problemInstance . depotCount ; int depot = problemInstance . depotAllocation [ vehicle ] ; if ( route . size ( ) == 0 ) { MinimumCostInsertionInfo info = new MinimumCostInsertionInfo ( ) ; info . cost = costMatrix [ depot ] [ depotCount + client ] + costMatrix [ depotCount + client ] [ depot ] ; info . insertPosition = 0 ; info . loadViolation = - 1 ; info . vehicle = vehicle ; return info ; } cost = 0 ; cost = costMatrix [ depot ] [ depotCount + client ] + costMatrix [ depotCount + client ] [ depotCount + route . get ( 0 ) ] ; cost -= ( costMatrix [ depot ] [ depotCount + route . get ( 0 ) ] ) ; if ( cost < min ) { min = cost ; chosenInsertPosition = 0 ; } for ( int insertPosition = 1 ; insertPosition < route . size ( ) ; insertPosition ++ ) { cost = costMatrix [ depotCount + route . get ( insertPosition - 1 ) ] [ depotCount + client ] + costMatrix [ depotCount + client ] [ depotCount + route . get ( insertPosition ) ] ; cost -= ( costMatrix [ depotCount + route . get ( insertPosition - 1 ) ] [ depotCount + route . get ( insertPosition ) ] ) ; if ( cost < min ) { min = cost ; chosenInsertPosition = insertPosition ; } } cost = costMatrix [ depotCount + route . get ( route . size ( ) - 1 ) ] [ depotCount + client ] + costMatrix [ depotCount + client ] [ depot ] ; cost -= ( costMatrix [ depotCount + route . get ( route . size ( ) - 1 ) ] [ depot ] ) ; if ( cost < min ) { min = cost ; chosenInsertPosition = route . size ( ) ; } MinimumCostInsertionInfo info = new MinimumCostInsertionInfo ( ) ; info . cost = min ; info . insertPosition = chosenInsertPosition ; info . loadViolation = - 1 ; info . vehicle = vehicle ; return info ; }
tr	3	int pack ( Buffer opb ) { byte [ ] temp = "Xiphophorus libVorbis I 20000508" . getBytes ( ) ; opb . write ( 03 , 8 ) ; opb . write ( _vorbis ) ; opb . write ( temp . length , 32 ) ; opb . write ( temp ) ; opb . write ( comments , 32 ) ; if ( comments != 0 ) { for ( int i = 0 ; i < comments ; i ++ ) { if ( user_comments [ i ] != null ) { opb . write ( comment_lengths [ i ] , 32 ) ; opb . write ( user_comments [ i ] ) ; } else { opb . write ( 0 , 32 ) ; } } } opb . write ( 1 , 1 ) ; return ( 0 ) ; }
tr	7	public void updateLyricsPane ( final Track t ) { if ( ! currentTrack . equals ( t ) ) { currentTrack = t ; new Thread ( ) { @ Override public void run ( ) { String artist = t . get ( "artist" ) ; String title = t . get ( "title" ) ; String lyrics ; if ( artist . equals ( "DOOOOOM" ) && title . equals ( "Please Give Us All An A" ) ) { lyrics = "Professor Bhola  give us all A's\n" ; lyrics += "Because we need to graduate!\n" ; lyrics += "[awesome guitar solo]\n" ; lyrics += "Professor Bhola  give us all A's\n" ; lyrics += "Because we need to graduate!\n" ; } else { if ( artist != null && ! artist . isEmpty ( ) && title != null && ! title . isEmpty ( ) ) { System . out . println ( "." ) ; lyrics = LyricsFetcher . fetchLyrics ( t . get ( "artist" ) , t . get ( "title" ) ) ; } else { lyrics = "[lyrics unavailable]" ; } } Platform . runLater ( new Runnable ( ) { String lyrics ; @ Override public void run ( ) { lyrics_text . setText ( lyrics ) ; } public Runnable init ( String lyrics ) { this . lyrics = lyrics ; return this ; } } . init ( lyrics ) ) ; } } . start ( ) ; } }
tr	1	public int take ( int index ) { if ( register . get ( index ) ) { lastappend . remove ( index ) ; stack . add ( index ) ; } lastappend . add ( index ) ; register . set ( index , true ) ; return index ; }
tr	9	@ Override public int build ( int start , int length , int floor , MyLevel level ) { this . tubeHeight = floor - MyLevel . random . nextInt ( 2 ) - 2 ; int xTube = start + 1 + MyLevel . random . nextInt ( 4 ) ; for ( int x = start ; x < start + length ; x ++ ) { if ( x > xTube + 1 ) { xTube += 3 + MyLevel . random . nextInt ( 4 ) ; this . tubeHeight = floor - MyLevel . random . nextInt ( 2 ) - 2 ; } if ( xTube >= start + length - 2 ) xTube += 10 ; if ( x == xTube && MyLevel . random . nextInt ( 11 ) < level . difficulty + 1 ) { level . setSpriteTemplate ( x , this . tubeHeight , new SpriteTemplate ( Enemy . ENEMY_FLOWER , false ) ) ; level . ENEMIES ++ ; } for ( int y = 0 ; y < level . height ; y ++ ) { if ( y >= floor ) { level . setBlock ( x , y , MyLevel . GROUND ) ; } else { if ( ( x == xTube || x == xTube + 1 ) && y >= this . tubeHeight ) { int xPic = 10 + x - xTube ; if ( y == this . tubeHeight ) { level . setBlock ( x , y , ( byte ) ( xPic + 0 * 16 ) ) ; } else { level . setBlock ( x , y , ( byte ) ( xPic + 1 * 16 ) ) ; } } } } } return length ; }
tr	3	@ Override public WidgetChild getChild ( ) { WidgetChild main = Widgets . get ( BOOK_WIDGET , MAIN_CHILD ) ; if ( main == null ) return null ; WidgetChild ret = main . getChild ( bookChild ) ; if ( ret == null || ret . getTextureId ( ) != bookTexture ) return null ; return ret ; }
tr	5	public static void main ( String [ ] args ) { Genejector . setInstanceRole ( Genejector . InstanceRole . RISEN ) ; StreamConsumerThread . dispatch ( new StreamConsumerThread ( System . in , null , true ) ) ; messenger . writeMessage ( new ReadyMessage ( ) ) ; Settings . setSettings ( ( ( SettingsMessage ) messenger . readMessage ( ) ) . getSettings ( ) ) ; try { class < ? > clazz = class . forName ( Settings . getSettings ( ) . getProjectMain ( ) ) ; Method mainMethod = clazz . getMethod ( "main" , String [ ] . class ) ; String [ ] params = null ; mainMethod . invoke ( null , ( Object ) params ) ; } catch ( ClassNotFoundException ex ) { throw new ReflectionException ( ex ) ; } catch ( NoSuchMethodException ex ) { throw new ReflectionException ( ex ) ; } catch ( IllegalAccessException ex ) { throw new ReflectionException ( ex ) ; } catch ( InvocationTargetException ex ) { throw new ProjectExecutionException ( ex . getCause ( ) ) ; } }
tr	9	public static boolean edgeTest ( double [ ] [ ] a , double [ ] [ ] b ) { double tmpPoint [ ] ; if ( a [ 0 ] [ X ] > a [ 1 ] [ X ] ) { tmpPoint = a [ 0 ] ; a [ 0 ] = a [ 1 ] ; a [ 1 ] = tmpPoint ; } if ( b [ 0 ] [ X ] > b [ 1 ] [ X ] ) { tmpPoint = b [ 0 ] ; b [ 0 ] = b [ 1 ] ; b [ 1 ] = tmpPoint ; } if ( a [ 0 ] [ Y ] == a [ 1 ] [ Y ] && b [ 0 ] [ Y ] == b [ 1 ] [ Y ] ) { if ( ( a [ 0 ] [ Y ] == b [ 0 ] [ Y ] ) && ( between ( b , a [ 0 ] [ X ] , X ) || between ( b , a [ 1 ] [ X ] , X ) ) ) { return true ; } return false ; } if ( a [ 0 ] [ X ] == a [ 1 ] [ X ] ) { if ( b [ 0 ] [ X ] == b [ 1 ] [ X ] ) { if ( ( a [ 0 ] [ X ] == b [ 0 ] [ X ] ) && ( between ( b , a [ 0 ] [ Y ] , Y ) || between ( b , a [ 1 ] [ Y ] , Y ) ) ) { return true ; } return false ; } return wallTest ( b , a ) ; } else if ( b [ 0 ] [ X ] == b [ 1 ] [ X ] ) return wallTest ( a , b ) ; return segmentTest ( a , b ) ; }
tr	3	public ManaAltar getClosestManaAltar ( Point point ) { ManaAltar closestManaAltar = null ; double distance = double . POSITIVE_INFINITY ; for ( Building building : buildings ) { if ( building instanceof ManaAltar ) { Point manaAltarPos = new Point ( building . getIntX ( ) , building . getIntY ( ) ) ; if ( distance > Geometry . squareDistance ( manaAltarPos , point ) ) { distance = Geometry . squareDistance ( manaAltarPos , point ) ; closestManaAltar = ( ManaAltar ) building ; } } } return closestManaAltar ; }
tr	3	public long getAverageGameduration ( Game g ) { long result = 0 ; int games = 0 ; for ( Match m : allMatches ) { if ( m . getGame ( ) . equals ( g ) ) { result += m . getDuration ( ) ; games ++ ; } } if ( games != 0 ) { return result / games ; } else { return - 1 ; } }
tr	5	private Nodo borrarElemento ( V elemento , Nodo nodo ) { if ( nodo == null ) return null ; int cmp = elemento . compareTo ( nodo . elemento ) ; if ( cmp < 0 ) nodo . izquierda = borrarElemento ( elemento , nodo . izquierda ) ; else if ( cmp > 0 ) nodo . derecha = borrarElemento ( elemento , nodo . derecha ) ; else { if ( nodo . derecha == null ) return nodo . izquierda ; if ( nodo . izquierda == null ) return nodo . derecha ; Nodo t = nodo ; nodo = min ( t . derecha ) ; nodo . derecha = borrarMinimo ( t . derecha ) ; nodo . izquierda = t . izquierda ; } return nodo ; }
tr	5	public void Editar ( Produto produto ) throws Exception { if ( produto == null ) { throw new Exception ( "Selecione um produto" ) ; } if ( produto . getIdProduto ( ) . equals ( "" ) ) { throw new Exception ( "Favor inserir o id do produto." ) ; } if ( produto . getNomeProduto ( ) . isEmpty ( ) ) { throw new Exception ( "Favor inserir o nome do produto." ) ; } if ( produto . getTipoProduto ( ) . isEmpty ( ) ) { throw new Exception ( "Favor inserir tipo do produto." ) ; } if ( produto . getValorProduto ( ) . equals ( "" ) ) { throw new Exception ( "Favor inserir o valor unit\u00E1rio do produto." ) ; } ProdutoController . obterInstancia ( ) . Editar ( produto ) ; }
tr	4	protected String getJarName ( URL url ) { String fileName = url . getFile ( ) ; if ( fileName . contains ( "?" ) ) { fileName = fileName . substring ( 0 , fileName . indexOf ( "?" ) ) ; } if ( fileName . endsWith ( ".pack.lzma" ) ) fileName = fileName . replaceAll ( ".pack.lzma" , "" ) ; else if ( fileName . endsWith ( ".pack" ) ) fileName = fileName . replaceAll ( ".pack" , "" ) ; else if ( fileName . endsWith ( ".lzma" ) ) { fileName = fileName . replaceAll ( ".lzma" , "" ) ; } return fileName . substring ( fileName . lastIndexOf ( / ) + 1 ) ; }
tr	9	private void paint ( Display display , GC gc ) { Color white = colors . getWhite ( ) ; Color black = colors . getBlack ( ) ; Color grey30 = colors . getGrey30 ( ) ; Color grey50 = colors . getGrey50 ( ) ; Color grey80 = colors . getGrey80 ( ) ; Color grey120 = colors . getGrey120 ( ) ; int clientWidth = nWhiteKeys * keyWidth + 10 ; int leftMargin = ( getWidget ( ) . getBounds ( ) . width - clientWidth - 20 ) / 2 + 5 ; Pitch pitch ; pitch = new Pitch ( "a0" ) ; gc . setBackground ( grey30 ) ; gc . fillRectangle ( leftMargin - borderWidth , topMargin - borderWidth - 1 , nWhiteKeys * keyWidth + borderWidth * 2 + 1 , keyHeight + borderWidth + 2 ) ; gc . setBackground ( grey30 ) ; gc . setForeground ( grey120 ) ; gc . fillGradientRectangle ( leftMargin - borderWidth + 1 , topMargin - borderWidth , nWhiteKeys * keyWidth + borderWidth * 2 - 1 , topMargin , true ) ; for ( int x = 0 ; x < nWhiteKeys ; x ++ ) { Color selected = getSelectedColor ( pitch ) ; gc . setForeground ( black ) ; gc . setBackground ( ( selected != null ) ? selected : white ) ; gc . fillRectangle ( leftMargin + keyWidth * x , topMargin , keyWidth , keyHeight ) ; gc . drawRectangle ( leftMargin + keyWidth * x , topMargin , keyWidth , keyHeight ) ; pitch = pitch . nextSemitone ( ) ; if ( x % 7 != 1 && x % 7 != 4 ) { pitch = pitch . nextSemitone ( ) ; } } pitch = new Pitch ( "a#0" ) ; for ( int x = 0 ; x < nWhiteKeys - 1 ; x ++ ) { if ( x % 7 == 1 || x % 7 == 4 ) { pitch = pitch . nextSemitone ( ) ; continue ; } Color selected = getSelectedColor ( pitch ) ; int left = leftMargin + keyWidth * x + keyWidth / 2 + blackMargin ; int width = keyWidth - blackMargin * 2 + 1 ; gc . setForeground ( black ) ; gc . setBackground ( ( selected != null ) ? selected : black ) ; gc . fillRectangle ( left , topMargin , width , blackKeyHeight ) ; gc . drawRectangle ( left , topMargin , width , blackKeyHeight ) ; if ( selected == null ) { gc . setBackground ( grey50 ) ; gc . fillRectangle ( left + 1 , topMargin + blackKeyHeight - 5 , width - 1 , 5 ) ; gc . setForeground ( grey80 ) ; gc . drawLine ( left + 1 , topMargin + blackKeyHeight - 5 , left + width - 1 , topMargin + blackKeyHeight - 5 ) ; } pitch = pitch . nextSemitone ( ) ; pitch = pitch . nextSemitone ( ) ; } }
tr	4	public static boolean isEqual ( SegmentPosition a , SegmentPosition b ) { if ( a == b ) return true ; if ( a == null ) return false ; if ( b == null ) return false ; return ( a . polygon == b . polygon && a . position == b . position ) ; }
tr	7	@ Override public synchronized int registerClient ( String client_name , String first_tag , String second_tag ) { try { final NameComponent [ ] clientName = { new NameComponent ( client_name , "Object" ) } ; final Client client = ClientHelper . narrow ( namingContext . resolve ( clientName ) ) ; if ( first_tag . equals ( "T" ) || second_tag . equals ( "T" ) ) { clientUpdater . appendTemperatureClient ( client ) ; } if ( first_tag . equals ( "P" ) || second_tag . equals ( "P" ) ) { clientUpdater . appendPressureClient ( client ) ; } if ( first_tag . equals ( "H" ) || second_tag . equals ( "H" ) ) { clientUpdater . appendHumidityClient ( client ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } return 0 ; }
tr	9	public static boolean isPalindrome2 ( String s ) { if ( s == "" ) return true ; if ( s == null ) return false ; if ( allSpace ( s ) ) return true ; s = s . toUpperCase ( ) ; int begin = 0 ; StringBuilder sb = new StringBuilder ( ) ; while ( begin < s . length ( ) ) { if ( isAtoZor1To10 ( s . substring ( begin , begin + 1 ) ) ) { sb . append ( s . substring ( begin , begin + 1 ) ) ; } begin ++ ; } begin = 0 ; String newS = sb . toString ( ) ; char [ ] arr = newS . toCharArray ( ) ; if ( arr . length == 0 ) return true ; int end = newS . length ( ) - 1 ; char l = arr [ begin ] ; char r = arr [ end ] ; while ( begin <= end && begin < end && end > 0 ) { if ( l != r ) return false ; begin ++ ; end -- ; l = arr [ begin ] ; r = arr [ end ] ; } return true ; }
tr	9	@ Override public double [ ] getDoubleData ( double [ ] a , long startPos , long endPos , long step ) { if ( startPos < 0 || startPos >= length ) { throw new ArrayIndexOutOfBoundsException ( "startPos < 0 || startPos >= length" ) ; } if ( endPos < 0 || endPos > length || endPos < startPos ) { throw new ArrayIndexOutOfBoundsException ( "endPos < 0 || endPos > length || endPos < startPos" ) ; } if ( step < 1 ) { throw new IllegalArgumentException ( "step < 1" ) ; } long len = ( long ) Math . ceil ( ( endPos - startPos ) / ( double ) step ) ; if ( len > getMaxSizeOf32bitArray ( ) ) { return null ; } else { double [ ] out ; if ( a != null && a . length >= len ) { out = a ; } else { out = new double [ ( int ) len ] ; } int idx = 0 ; if ( ptr != 0 ) { for ( long i = startPos ; i < endPos ; i += step ) { out [ idx ++ ] = ( double ) Utilities . UNSAFE . getShort ( ptr + sizeof * i ) ; } } else { if ( isConstant ( ) ) { for ( long i = startPos ; i < endPos ; i += step ) { out [ idx ++ ] = ( double ) data [ 0 ] ; } } else { for ( long i = startPos ; i < endPos ; i += step ) { out [ idx ++ ] = ( double ) data [ ( int ) i ] ; } } } return out ; } }
tr	6	@ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; PosListaPrecioEntityPK that = ( PosListaPrecioEntityPK ) o ; if ( pcaIdElemento != that . pcaIdElemento ) return false ; if ( pcaPosId != null ? ! pcaPosId . equals ( that . pcaPosId ) : that . pcaPosId != null ) return false ; return true ; }
tr	4	@ SuppressWarnings ( { "unchecked" , "rawtypes" } ) @ Override public Object instantiate ( ObjectBinder context , Object value , Type targetType , class targetClass ) { if ( value instanceof Map && targetClass == URLList . class ) { Map < String , ? > map = ( Map < String , ? > ) value ; URLList u = new URLList ( ) ; context . use ( URL . class , new URL ( ) ) ; context . bindIntoObject ( ( Map ) map . get ( "items" ) , u , targetClass ) ; return u ; } throw context . cannotConvertValueToTargetType ( value , targetClass ) ; }
tr	5	public HashMap < Material , Integer > countBlocks ( Location start , Location end ) { HashMap < Material , Integer > blocks = new HashMap < Material , Integer > ( ) ; final World world = start . getWorld ( ) ; if ( world != end . getWorld ( ) ) { return blocks ; } final int startX = Math . max ( start . getBlockX ( ) , end . getBlockX ( ) ) ; final int startY = Math . max ( start . getBlockY ( ) , end . getBlockY ( ) ) ; final int startZ = Math . max ( start . getBlockZ ( ) , end . getBlockZ ( ) ) ; final int endX = Math . min ( start . getBlockX ( ) , end . getBlockX ( ) ) ; final int endY = Math . min ( start . getBlockY ( ) , end . getBlockY ( ) ) ; final int endZ = Math . min ( start . getBlockZ ( ) , end . getBlockZ ( ) ) ; for ( int x = startX ; x < endX ; x ++ ) { for ( int y = startY ; x < endY ; y ++ ) { for ( int z = startZ ; x < endZ ; z ++ ) { Material currentBlock = world . getBlockAt ( x , y , z ) . getType ( ) ; int lastAmmount = blocks . containsKey ( currentBlock ) ? blocks . get ( currentBlock ) : 0 ; blocks . put ( currentBlock , lastAmmount ) ; } } } return blocks ; }
tr	4	public synchronized void updatedTTL ( ShareAvailability file ) { int row = 0 ; for ( String [ ] col : shares ) { if ( col [ 5 ] . equals ( file . getFile ( ) . getHash ( ) ) && col [ 4 ] . equals ( file . getHost ( ) . getAddress ( ) . getHostAddress ( ) ) ) { col [ 6 ] = String . valueOf ( file . getTtl ( ) ) ; } row ++ ; if ( shares . size ( ) > row ) { this . fireTableCellUpdated ( row , 6 ) ; } else { this . fireTableStructureChanged ( ) ; } } }
tr	6	public void run ( ) { for ( int i = 0 ; i <= wdh ; i ++ ) { if ( isInterrupted ( ) ) { i = 0 ; break ; } aktor . einschalten ( ) ; try { sleep ( pulse_ein ) ; } catch ( InterruptedException ie ) { interrupt ( ) ; } if ( isInterrupted ( ) ) { i = 0 ; break ; } aktor . ausschalten ( ) ; try { sleep ( pulse_aus ) ; } catch ( InterruptedException ie ) { interrupt ( ) ; } } if ( endbehavior ) { aktor . einschalten ( ) ; } else { aktor . ausschalten ( ) ; } }
tr	4	@ Test public void testDoCreaRazza ( ) { aggiungiDueUtenti ( ) ; try { assertTrue ( logicaTest . doCreaRazza ( testingToken , "miaRazza1" , c ) ) ; assertFalse ( logicaTest . doCreaRazza ( testingToken , "mbc" , e ) ) ; assertFalse ( logicaTest . doCreaRazza ( testingToken2 , "miaRazza1" , e ) ) ; } catch ( NomeRazzaOccupatoException e ) { System . out . println ( "[testDoCreaRazza] Eccezione NomeRazzaOccupato gestita correttamente." ) ; } catch ( InvalidTokenException e ) { fail ( ) ; } try { assertTrue ( logicaTest . doCreaRazza ( "298375892735" , "bbb" , d ) ) ; } catch ( NomeRazzaOccupatoException e ) { fail ( ) ; } catch ( InvalidTokenException e ) { System . out . println ( "[testDoCreaRazza] Eccezione InvalidToken gestita correttamente." ) ; } }
tr	1	@ Override public Log getLogger ( ) { if ( client == null ) { return new Log ( ) ; } else { return client . getLogger ( ) ; } }
tr	9	private void readImpl ( InputStream in , SwingBoxDocument doc , int pos ) throws IOException , BadLocationException { if ( component == null ) throw new IllegalStateException ( "Component is null  editor kit is probably deinstalled from a JEditorPane." ) ; if ( pos > doc . getLength ( ) || pos < 0 ) { BadLocationException e = new BadLocationException ( "Invalid location" , pos ) ; readError ( null , e ) ; throw e ; } ContentReader rdr = new ContentReader ( ) ; URL url = ( URL ) doc . getProperty ( Document . StreamDescriptionProperty ) ; CSSBoxAnalyzer analyzer = getCSSBoxAnalyzer ( ) ; Container parent = component . getParent ( ) ; Dimension dim ; if ( parent != null && parent instanceof JViewport ) { dim = ( ( JViewport ) parent ) . getExtentSize ( ) ; } else { dim = component . getBounds ( ) . getSize ( ) ; } if ( dim . width <= 10 ) { Dimension tmp = Toolkit . getDefaultToolkit ( ) . getScreenSize ( ) ; dim . setSize ( tmp . width / 2.5 , tmp . height / 2.5 ) ; } List < ElementSpec > elements ; try { String ctype = null ; Object ct = doc . getProperty ( "Content-Type" ) ; if ( ct != null ) { if ( ct instanceof List ) ctype = ( String ) ( ( List < ? > ) ct ) . get ( 0 ) ; else ctype = ct . toString ( ) ; } DocumentSource docSource = new StreamDocumentSource ( in , url , ctype ) ; elements = rdr . read ( docSource , analyzer , dim ) ; String title = analyzer . getDocumentTitle ( ) ; if ( title == null ) title = "No title" ; doc . putProperty ( Document . TitleProperty , title ) ; } catch ( IOException e ) { readError ( url , e ) ; throw e ; } ElementSpec elementsArray [ ] = elements . toArray ( new ElementSpec [ 0 ] ) ; doc . create ( elementsArray ) ; readFinish ( url ) ; }
tr	2	public static BookSection fromJson ( JsonElement elem ) { JsonObject obj = elem . getAsJsonObject ( ) ; String header = obj . has ( HEADER ) ? obj . getAsJsonPrimitive ( HEADER ) . getAsString ( ) : null ; LinkedList < String > names = new LinkedList < String > ( ) ; for ( JsonElement probElem : obj . get ( PROBLEMS ) . getAsJsonArray ( ) ) { names . add ( probElem . getAsString ( ) ) ; } return new BookSection ( header , names ) ; }
tr	5	@ Test public void testlimitNunberOfItems ( ) throws IOException { block = new StorageBlock ( testDir , 2 , StorageManager . DEFAULT_CAPACITY_PER_BLOCK , storageMode ) ; int limit = 1000 ; String testString = "Test String" ; byte [ ] testBytes = testString . getBytes ( ) ; assertTrue ( StorageManager . DEFAULT_CAPACITY_PER_BLOCK == block . getCapacity ( ) ) ; assertTrue ( 0 == block . getDirty ( ) ) ; assertTrue ( block . getDirtyRatio ( ) <= 1e-6 ) ; assertTrue ( 2 == block . getIndex ( ) ) ; Pointer [ ] pointers = new Pointer [ limit ] ; for ( int i = 0 ; i < limit ; i ++ ) { Pointer pointer = block . store ( testBytes ) ; pointers [ i ] = pointer ; assertTrue ( 0 == block . getDirty ( ) ) ; assertTrue ( block . getDirtyRatio ( ) <= 1e-6 ) ; assertTrue ( i * ( testBytes . length ) == pointer . getPosition ( ) ) ; assertTrue ( testBytes . length == pointer . getLength ( ) ) ; assertTrue ( testBytes . length * ( i + 1 ) == block . getUsed ( ) ) ; } for ( int i = 0 ; i < limit ; i ++ ) { byte [ ] resultBytes = block . retrieve ( pointers [ i ] ) ; assertEquals ( testString , new String ( resultBytes ) ) ; assertTrue ( 0 == block . getDirty ( ) ) ; assertTrue ( block . getDirtyRatio ( ) <= 1e-6 ) ; assertTrue ( i * ( testBytes . length ) == pointers [ i ] . getPosition ( ) ) ; assertTrue ( testBytes . length == pointers [ i ] . getLength ( ) ) ; assertTrue ( testBytes . length * limit == block . getUsed ( ) ) ; } String smallTestString = "Test Str" ; byte [ ] smallTestBytes = smallTestString . getBytes ( ) ; for ( int i = 0 ; i < limit ; i ++ ) { pointers [ i ] = block . update ( pointers [ i ] , smallTestBytes ) ; assertTrue ( ( i + 1 ) * ( testBytes . length - smallTestBytes . length ) == block . getDirty ( ) ) ; double expectedRatio = ( i + 1 ) * ( testBytes . length - smallTestBytes . length ) * 1.0 / StorageManager . DEFAULT_CAPACITY_PER_BLOCK ; assertTrue ( Math . abs ( expectedRatio - block . getDirtyRatio ( ) ) <= 1e-6 ) ; assertTrue ( i * ( testBytes . length ) == pointers [ i ] . getPosition ( ) ) ; assertTrue ( smallTestBytes . length == pointers [ i ] . getLength ( ) ) ; assertTrue ( testBytes . length * limit - ( testBytes . length - smallTestBytes . length ) * ( i + 1 ) == block . getUsed ( ) ) ; } for ( int i = 0 ; i < limit ; i ++ ) { pointers [ i ] = block . update ( pointers [ i ] , testBytes ) ; assertTrue ( ( ( testBytes . length - smallTestBytes . length ) * ( limit - i - 1 ) ) + ( i + 1 ) * testBytes . length == block . getDirty ( ) ) ; double expectedRatio = ( ( ( testBytes . length - smallTestBytes . length ) * ( limit - i - 1 ) ) + ( i + 1 ) * testBytes . length ) * 1.0 / StorageManager . DEFAULT_CAPACITY_PER_BLOCK ; assertTrue ( Math . abs ( expectedRatio - block . getDirtyRatio ( ) ) <= 1e-6 ) ; assertTrue ( ( limit + i ) * testBytes . length == pointers [ i ] . getPosition ( ) ) ; assertTrue ( testBytes . length == pointers [ i ] . getLength ( ) ) ; } assertTrue ( testBytes . length * limit == block . getUsed ( ) ) ; for ( int i = 0 ; i < limit ; i ++ ) { byte [ ] resultBytes = block . remove ( pointers [ i ] ) ; assertEquals ( testString , new String ( resultBytes ) ) ; double expectedRatio = ( testBytes . length * limit + testBytes . length * ( i + 1 ) ) * 1.0 / StorageManager . DEFAULT_CAPACITY_PER_BLOCK ; assertTrue ( Math . abs ( expectedRatio - block . getDirtyRatio ( ) ) <= 1e-6 ) ; } assertTrue ( 0 == block . getUsed ( ) ) ; block . free ( ) ; assertTrue ( StorageManager . DEFAULT_CAPACITY_PER_BLOCK == block . getCapacity ( ) ) ; assertTrue ( 0 == block . getDirty ( ) ) ; assertTrue ( block . getDirtyRatio ( ) <= 1e-6 ) ; assertTrue ( 2 == block . getIndex ( ) ) ; }
tr	6	public void openDefaultWindows ( ) { try { if ( activeInventory == null ) { activeInventory = new InventoryFrame ( ) ; activeInventory . setVisible ( true ) ; } else { activeInventory . requestFocus ( ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } try { if ( activeStats == null ) { activeStats = new StatsFrame ( ) ; activeStats . setVisible ( true ) ; } else { activeStats . requestFocus ( ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } try { if ( activeLog == null ) { activeLog = new TextLogFrame ( ) ; activeLog . logTextBox . setText ( loggedMessages ) ; activeLog . setVisible ( true ) ; } else { activeLog . requestFocus ( ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } }
tr	5	private static int decode ( String rgb , int start , int end ) { try { final int len = rgb . length ( ) ; if ( start >= len ) return 0 ; if ( end >= len ) end = len ; final int v = Integer . parseInt ( rgb . substring ( start , end ) , 16 ) ; return v > 255 ? 255 : v < 0 ? 0 : v ; } catch ( NumberFormatException ex ) { return 0 ; } }
tr	0	private void buttonOkMouseEntered ( java . awt . event . MouseEvent evt ) { buttonOk . setIcon ( new javax . swing . ImageIcon ( getClass ( ) . getResource ( "/app/images/buttonOkHover_Popup.png" ) ) ) ; }
tr	6	@ Override public void rule ( Context context ) throws PolicyException { policy . Policy polInfo = super . getPolicyInfo ( ) ; double rate = 0.0 ; double premiumRate = 0.0 ; int premiumMinOrder = Integer . MAX_VALUE ; for ( policy . Parameter parm : polInfo . getParameter ( ) ) { switch ( parm . getId ( ) ) { case "Rate" : rate = double . parseDouble ( parm . getValue ( ) ) ; break ; case "PremiumRate" : premiumRate = double . parseDouble ( parm . getValue ( ) ) ; break ; case "PremiumMinOrders" : premiumMinOrder = Integer . parseInt ( parm . getValue ( ) ) ; default : break ; } } User user = ( User ) context . get ( User . class ) ; dao . OrderDAO o ; try { o = new dao . OrderDAO ( ) ; isPremium = o . getOrdersByUserID ( user . getUserID ( ) ) . size ( ) >= premiumMinOrder ; } catch ( NamingException | SQLException e ) { e . printStackTrace ( ) ; } double shipping = user . getUserCart ( ) . getCartTotal ( ) * ( isPremium ? premiumRate : rate ) ; user . getUserCart ( ) . setShippingCost ( shipping ) ; }
tr	1	@ Override public Iterator < E > iterator ( ) { int length = elements . length ; ArrayList < E > arrayList = new ArrayList < E > ( length ) ; for ( int i = 0 , j = first ; i < length ; ++ i , j = ( j + 1 ) % length ) { arrayList . add ( elements [ j ] ) ; } return arrayList . iterator ( ) ; }
tr	8	private void readBuffer ( long timeout , long startTime , SelectionKey readKey , ByteBuffer buffer ) throws IOException { boolean firstTime = true ; while ( currentTime ( ) - startTime < timeout && buffer . position ( ) != buffer . capacity ( ) ) { if ( ! firstTime ) { long waitDuration = startTime + timeout - currentTime ( ) ; if ( waitDuration > 0 ) { selector . select ( waitDuration ) ; } } if ( firstTime || selector . selectedKeys ( ) . size ( ) > 0 ) { int read ; do { read = socketChannel . read ( buffer ) ; } while ( read > 0 ) ; if ( firstTime ) { firstTime = false ; } else { selector . selectedKeys ( ) . remove ( readKey ) ; } } } }
tr	1	@ Override public void error ( String message ) { String destination = ApplicationConstants . APP_NAME + LoggerConstants . ERROR + CALENDAR . get ( Calendar . YEAR ) + CALENDAR . get ( Calendar . MONTH ) + CALENDAR . get ( Calendar . DATE ) ; try { FetchFileCmd . fetchTextFile ( destination ) . write ( "[" + className + "] " + new Date ( ) + " [" + message + "]\r\n" ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; } }
tr	9	public List < String > processMethods ( ) { final List < String > methods = new ArrayList < String > ( ) ; final int length = this . source . length ( ) ; int methodCount = 0 ; int openBrackets = 0 ; int closeBrackets = 0 ; final boolean methodStarted = false ; final List < Integer > bracketIndices = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < length ; i ++ ) { final char c = this . source . charAt ( i ) ; if ( c == { ) { bracketIndices . add ( i ) ; } if ( c == } ) { bracketIndices . add ( - i ) ; } } int currentMethodStart = 0 ; int currentMethodEnd = - 1 ; for ( int i = 0 ; i < bracketIndices . size ( ) ; i ++ ) { final int bracketIndex = bracketIndices . get ( i ) ; if ( ( bracketIndex > 0 ) && ( openBrackets == closeBrackets ) ) { final String substring = this . source . substring ( currentMethodEnd + 1 , bracketIndex ) ; if ( methodPrt . matcher ( substring ) . matches ( ) ) { if ( methodCount > 0 ) { methods . add ( this . source . substring ( currentMethodStart , currentMethodEnd + 1 ) . trim ( ) ) ; currentMethodStart = currentMethodEnd + 1 ; } methodCount ++ ; } } if ( bracketIndex < 0 ) { currentMethodEnd = - 1 * bracketIndex ; } if ( bracketIndex > 0 ) { openBrackets ++ ; } if ( bracketIndex < 0 ) { closeBrackets ++ ; } } if ( methodCount > 0 ) { methods . add ( this . source . substring ( currentMethodStart , currentMethodEnd + 1 ) . trim ( ) ) ; } else { final String method = "public void test" + ( methodCount + 1 ) + "()\n{\n" + this . source + "\n}" ; methods . add ( method ) ; } return methods ; }
tr	2	public int kontrolle ( ) { if ( a < 0 && b < 0 ) return 1 ; else return 0 ; }
tr	5	public void serialize ( final javax . xml . namespace . QName parentQName , javax . xml . stream . XMLStreamWriter xmlWriter , boolean serializeType ) throws javax . xml . stream . XMLStreamException , org . apache . axis2 . databinding . ADBException { java . lang . String prefix = null ; java . lang . String namespace = null ; prefix = parentQName . getPrefix ( ) ; namespace = parentQName . getNamespaceURI ( ) ; writeStartElement ( prefix , namespace , parentQName . getLocalPart ( ) , xmlWriter ) ; if ( serializeType ) { java . lang . String namespacePrefix = registerPrefix ( xmlWriter , "http://tinyurl.com.src" ) ; if ( ( namespacePrefix != null ) && ( namespacePrefix . trim ( ) . length ( ) > 0 ) ) { writeAttribute ( "xsi" , "http://www.w3.org/2001/XMLSchema-instance" , "type" , namespacePrefix + ":getLongUrl" , xmlWriter ) ; } else { writeAttribute ( "xsi" , "http://www.w3.org/2001/XMLSchema-instance" , "type" , "getLongUrl" , xmlWriter ) ; } } if ( localShortUrlTracker ) { namespace = "http://tinyurl.com.src" ; writeStartElement ( null , namespace , "shortUrl" , xmlWriter ) ; if ( localShortUrl == null ) { writeAttribute ( "xsi" , "http://www.w3.org/2001/XMLSchema-instance" , "nil" , "1" , xmlWriter ) ; } else { xmlWriter . writeCharacters ( localShortUrl ) ; } xmlWriter . writeEndElement ( ) ; } xmlWriter . writeEndElement ( ) ; }
tr	0	public Tela_Usuario_Cadastro ( ) { initComponents ( ) ; }
tr	5	private static int findLongestSubsequence ( String firstString , String secondString , int i , int j ) { if ( firstString == null || secondString == null ) return 0 ; if ( i == firstString . length ( ) || j == secondString . length ( ) ) return 0 ; if ( firstString . charAt ( i ) == secondString . charAt ( j ) ) { return 1 + findLongestSubsequence ( firstString , secondString , i + 1 , j + 1 ) ; } else { return Math . max ( findLongestSubsequence ( firstString , secondString , i + 1 , j ) , findLongestSubsequence ( firstString , secondString , i , j + 1 ) ) ; } }
tr	6	public MarketDataPusher ( String product , int timeframe , String start , String end , File historyFile ) { this . product = product ; this . timeframe = timeframe ; SimpleDateFormat ft = new SimpleDateFormat ( "yyyy-MM-dd HH:mm:ss" ) ; try { this . start = ft . parse ( start ) ; } catch ( ParseException e ) { System . out . println ( "Unable to parse start time " + start ) ; } try { this . end = ft . parse ( end ) ; } catch ( ParseException e ) { System . out . println ( "Unable to parse end time " + end ) ; } if ( this . start . compareTo ( this . end ) > 0 ) { throw new EndEarlierThanStart ( ) ; } this . askBuffer = new ArrayList < MarketData > ( ) ; this . bidBuffer = new ArrayList < MarketData > ( ) ; String sTimeframe = String . format ( "m%d" , timeframe ) ; HashMap < String , ArrayList < MarketData >> hm = readMarketData ( product , historyFile ) ; for ( int i = 0 ; i < hm . get ( "ask" ) . size ( ) ; i ++ ) { Date date = hm . get ( "ask" ) . get ( i ) . getStartDate ( ) ; if ( date . compareTo ( this . start ) >= 0 && date . compareTo ( this . end ) < 0 ) { this . askBuffer . add ( hm . get ( "ask" ) . get ( i ) ) ; this . bidBuffer . add ( hm . get ( "bid" ) . get ( i ) ) ; } } this . strategies = new ArrayList < Subscriber > ( ) ; this . orders = new ArrayList < Subscriber > ( ) ; curr = 0 ; }
tr	3	public boolean intersects ( Rect2 rect ) { return ! ( x - w / 2 > rect . x + rect . w / 2 || x + w / 2 < rect . x - rect . w / 2 || y + h / 2 < rect . y - rect . h / 2 || y - h / 2 > rect . y + rect . h / 2 ) ; }
tr	2	@ Override public void actualizarEstado ( Subasta subasta ) { Calendar fechaActual = Calendar . getInstance ( ) ; if ( subasta . getPeriodoActivo ( ) . incluyeA ( fechaActual ) ) { Activa activa = new Activa ( ) ; subasta . setEstado ( activa ) ; } else { if ( fechaActual . before ( subasta . getPeriodoActivo ( ) . getFechaInicio ( ) ) ) { EnPromocion enPromocion = new EnPromocion ( ) ; subasta . setEstado ( enPromocion ) ; } } }
tr	7	public void actionPerformed ( ActionEvent ae ) { ADocument aDoc = ( ADocument ) textPane . getDocument ( ) ; Clipboard clipboard = Toolkit . getDefaultToolkit ( ) . getSystemClipboard ( ) ; ^ ^ = textPane . getCaret ( ) ; int . = ^ . getDot ( ) ; int mark = ^ . getMark ( ) ; if ( . != mark ) return ; ADocumentFragment fragment = null ; try { Transferable tr = clipboard . getContents ( this ) ; DataFlavor flavor = new DataFlavor ( ADocumentFragment . MIME_TYPE ) ; if ( tr . isDataFlavorSupported ( flavor ) ) fragment = ( ADocumentFragment ) tr . getTransferData ( flavor ) ; else { flavor = new DataFlavor ( "application/x-java-serialized-object; class=java.lang.String" ) ; if ( tr . isDataFlavorSupported ( flavor ) ) { String s = new String ( ( ( ( String ) tr . getTransferData ( flavor ) ) ) ) ; fragment = new ADocumentFragment ( s , null , null ) ; } } } catch ( UnsupportedFlavorException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } catch ( ClassNotFoundException e ) { e . printStackTrace ( ) ; } if ( fragment == null ) return ; aDoc . startCompoundEdit ( ) ; ADocument . pasteADocFragment ( aDoc , . , fragment ) ; aDoc . endCompoundEdit ( null ) ; aDoc . fireADocumentChanged ( ) ; }
tr	4	private String toString ( Object obj ) { if ( null == obj ) { return "" ; } if ( obj . getClass ( ) . isArray ( ) ) { return Utils . join ( ( Object [ ] ) obj ) ; } if ( obj instanceof Collection ) { return Utils . join ( ( Collection < ? > ) obj ) ; } return obj . toString ( ) ; }
tr	0	public void unsetName ( ) { this . name = null ; }
tr	8	public Holdable removeStackedItem ( Character itemID , int count ) throws InvalidKeyException { Holdable item ; Holdable returnItem ; if ( weapons . containsKey ( itemID ) ) { item = weapons . get ( itemID ) ; returnItem = item . reduceStack ( count ) ; if ( item . stackSize ( ) == 0 ) { weapons . remove ( itemID ) ; size -- ; } } else if ( armours . containsKey ( itemID ) ) { item = armours . get ( itemID ) ; returnItem = item . reduceStack ( count ) ; if ( item . stackSize ( ) == 0 ) { armours . remove ( itemID ) ; size -- ; } } else if ( foods . containsKey ( itemID ) ) { item = foods . get ( itemID ) ; returnItem = item . reduceStack ( count ) ; if ( item . stackSize ( ) == 0 ) { foods . remove ( itemID ) ; size -- ; } } else if ( misc . containsKey ( itemID ) ) { item = misc . get ( itemID ) ; returnItem = item . reduceStack ( count ) ; if ( item . stackSize ( ) == 0 ) { misc . remove ( itemID ) ; size -- ; } } else { throw new InvalidKeyException ( ) ; } return returnItem ; }
tr	1	public List < Match > getMatch ( ) { if ( match == null ) { match = new ArrayList < Match > ( ) ; } return this . match ; }
tr	7	public static File getWorkingDirectory ( String applicationName ) { String userHome = System . getProperty ( "user.home" , "." ) ; File workingDirectory ; switch ( getPlatform ( ) . ordinal ( ) ) { case 0 : case 1 : workingDirectory = new File ( userHome , . + applicationName + / ) ; break ; case 2 : String applicationData = System . getenv ( "APPDATA" ) ; if ( applicationData != null ) workingDirectory = new File ( applicationData , "." + applicationName + / ) ; else workingDirectory = new File ( userHome , . + applicationName + / ) ; break ; case 3 : workingDirectory = new File ( userHome , "Library/Application Support/" + applicationName ) ; break ; default : workingDirectory = new File ( userHome , applicationName + / ) ; } if ( ( ! workingDirectory . exists ( ) ) && ( ! workingDirectory . mkdirs ( ) ) ) throw new RuntimeException ( "The working directory could not be created: " + workingDirectory ) ; return workingDirectory ; }
tr	5	public List < String > generateParenthesis ( int n ) { List < String > result = new ArrayList < String > ( ) ; if ( n == 0 ) { result . add ( "" ) ; return result ; } if ( n == 1 ) { result . add ( "()" ) ; return result ; } result = generateParenthesis ( n - 1 ) ; ArrayList < String > returnList = new ArrayList < String > ( ) ; int tempSize = result . size ( ) ; for ( int j = 0 ; j < tempSize ; j ++ ) { String tempStr = result . get ( j ) ; StringBuffer sb = new StringBuffer ( tempStr ) ; int size = sb . length ( ) ; for ( int i = 0 ; i < size ; ++ i ) { String str = sb . insert ( i , "()" ) . toString ( ) ; sb = new StringBuffer ( tempStr ) ; if ( ! returnList . contains ( str ) ) { returnList . add ( str ) ; } } } return returnList ; }
tr	5	public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; char grade = in . next ( ) . charAt ( 0 ) ; switch ( grade ) { case A : System . out . println ( "Excellent" ) ; break ; case B : System . out . println ( "Good" ) ; break ; case C : System . out . println ( "So so" ) ; break ; case D : System . out . println ( "Fails" ) ; break ; case F : System . out . println ( "Get lost" ) ; break ; default : System . out . println ( "Invalid" ) ; break ; } }
tr	2	private static List < Identifier > trad65 ( TreeNode tree ) { int r = tree . getRule ( ) ; switch ( r ) { case 0 : { List < Identifier > ids = new LinkedList < Identifier > ( ) ; Identifier x0 = trad48 ( tree . getChild ( 0 ) ) ; ids . add ( x0 ) ; List < Identifier > x1 = trad66 ( tree . getChild ( 1 ) ) ; if ( x1 != null ) ids . addAll ( x1 ) ; return ids ; } default : return null ; } }
tr	9	public static class < ? extends Tag > getTypeClass ( int type ) { switch ( type ) { case NBTConstants . TYPE_END : return EndTag . class ; case NBTConstants . TYPE_BYTE : return ByteTag . class ; case NBTConstants . TYPE_SHORT : return ShortTag . class ; case NBTConstants . TYPE_INT : return IntTag . class ; case NBTConstants . TYPE_LONG : return LongTag . class ; case NBTConstants . TYPE_FLOAT : return FloatTag . class ; case NBTConstants . TYPE_DOUBLE : return DoubleTag . class ; case NBTConstants . TYPE_BYTE_ARRAY : return ByteArrayTag . class ; case NBTConstants . TYPE_STRING : return StringTag . class ; case NBTConstants . TYPE_LIST : return ListTag . class ; case NBTConstants . TYPE_COMPOUND : return CompoundTag . class ; case NBTConstants . TYPE_INT_ARRAY : return IntArrayTag . class ; case NBTConstants . TYPE_LISTSTRING_ARRAY : return ListStringArrayTag . class ; case NBTConstants . TYPE_LISTITEMSTACK_ARRAY : return ListItemStackArrayTag . class ; default : throw new IllegalArgumentException ( "Invalid tag type : " + type + "." ) ; } }
tr	4	public void removeDeadTransitions ( ) { clearHashCode ( ) ; if ( isSingleton ( ) ) return ; Set < State > states = getStates ( ) ; Set < State > live = getLiveStates ( states ) ; for ( State s : states ) { Set < Transition > st = s . transitions ; s . resetTransitions ( ) ; for ( Transition t : st ) if ( live . contains ( t . to ) ) s . transitions . add ( t ) ; } reduce ( ) ; }
tr	1	public void skipPast ( String to ) { this . myIndex = this . mySource . indexOf ( to , this . myIndex ) ; if ( this . myIndex < 0 ) { this . myIndex = this . mySource . length ( ) ; } else { this . myIndex += to . length ( ) ; } }
tr	3	@ Override public int hashCode ( ) { int result ; long temp ; result = consignmentId ; result = 31 * result + ( logTime != null ? logTime . hashCode ( ) : 0 ) ; temp = amount != + 0.0d ? double . doubleToLongBits ( amount ) : 0 ; result = 31 * result + ( int ) ( temp ^ ( temp >>> 32 ) ) ; result = 31 * result + employeeId ; result = 31 * result + ( comment != null ? comment . hashCode ( ) : 0 ) ; return result ; }
tr	0	public int getRadialCols ( ) { return radialCols ; }
tr	0	public Paivitettava getPaivitettava ( ) { return this . piirto ; }
tr	3	public static boolean hasSubmitParameter ( ServletRequest request , String name ) { assert . notNull ( request , "Request must not be null" ) ; if ( request . getParameter ( name ) != null ) { return true ; } for ( String suffix : SUBMIT_IMAGE_SUFFIXES ) { if ( request . getParameter ( name + suffix ) != null ) { return true ; } } return false ; }
tr	2	public Object opt ( int index ) { return ( index < 0 || index >= length ( ) ) ? null : this . myArrayList . get ( index ) ; }
tr	0	public void setPassword ( String password ) { this . password = password ; }
tr	3	public BinaryTree < K , V > next ( ) { if ( queue . isEmpty ( ) ) { throw new NoSuchElementException ( ) ; } BinaryTree < K , V > tree = queue . poll ( ) ; if ( tree . lhs != null ) { queue . add ( tree . lhs ) ; } if ( tree . rhs != null ) { queue . add ( tree . rhs ) ; } return tree ; }
tr	3	public static String getPalindrome ( String s , int l , int r ) { char [ ] arr = s . toCharArray ( ) ; while ( l >= 0 && r < arr . length ) { if ( arr [ l ] != arr [ r ] ) break ; l -- ; r ++ ; } return s . substring ( l + 1 , r ) ; }
tr	6	public void start ( String args [ ] ) { try { this . host = args [ 0 ] ; this . tcpPort = Integer . parseInt ( args [ 1 ] ) ; this . analyticServerRef = args [ 2 ] ; } catch ( NumberFormatException e ) { logger . error ( "Seconds argument has to be an integer" ) ; } catch ( ArrayIndexOutOfBoundsException e ) { logger . error ( "Too few arguments" ) ; } PropertyConfigurator . configure ( "src/log4j.properties" ) ; readProperties ( ) ; managementClient = new ManagementClient ( analyticServerRef ) ; managementClient . start ( ) ; managementClient . processInput ( "!subscribe .*" ) ; for ( int i = 0 ; i < clients ; i ++ ) { LoadTestClient client = new LoadTestClient ( host , tcpPort ) ; testClients . add ( client ) ; if ( auctionsPerMin > 0 ) client . createAuctions ( auctionsPerMin , auctionDuration ) ; if ( bidsPerMin > 0 ) client . bidAuctions ( bidsPerMin ) ; executorService . execute ( client ) ; } LoadTestClient updater = new LoadTestClient ( host , tcpPort ) ; testClients . add ( updater ) ; updater . updateList ( updateIntervalSec ) ; executorService . execute ( updater ) ; BufferedReader input = new BufferedReader ( new InputStreamReader ( System . in ) ) ; try { input . readLine ( ) ; input . close ( ) ; } catch ( IOException ex ) { logger . error ( "IO Exception on System Standard Input" ) ; } shutdown ( ) ; }
tr	4	private static String readLine ( int lineNumber ) { BufferedReader reader = null ; String line = "" ; try { reader = new BufferedReader ( new FileReader ( file ) ) ; int i = 0 ; for ( String curLine ; ( curLine = reader . readLine ( ) ) != null ; i ++ ) { if ( i == lineNumber ) line = curLine ; } } catch ( IOException e ) { } finally { try { reader . close ( ) ; } catch ( Exception e ) { } } return line ; }
tr	4	public void testFetchGroupsForUser ( ) { Group [ ] groups = ga . fetchGroupsForUser ( 1 , false ) ; for ( int i = 0 ; i < groups . length ; i ++ ) { assertTrue ( groups [ i ] . getId ( ) == ( i + 1 ) ) ; assertTrue ( groups [ i ] . getName ( ) . equals ( testgroups [ i ] . getName ( ) ) ) ; assertTrue ( groups [ i ] . isIsactive ( ) == testgroups [ i ] . isIsactive ( ) ) ; } groups = ga . fetchGroupsForUser ( 2 , false ) ; for ( int i = 0 ; i < groups . length ; i ++ ) { assertTrue ( groups [ i ] . getId ( ) == ( i + 1 ) ) ; assertTrue ( groups [ i ] . getName ( ) . equals ( testgroups [ i ] . getName ( ) ) ) ; assertTrue ( groups [ i ] . isIsactive ( ) == testgroups [ i ] . isIsactive ( ) ) ; } groups = ga . fetchGroupsForUser ( 3 , false ) ; for ( int i = 0 ; i < groups . length ; i ++ ) { assertTrue ( groups [ i ] . getId ( ) == ( i + 1 + 1 ) ) ; assertTrue ( groups [ i ] . getName ( ) . equals ( testgroups [ i + 1 ] . getName ( ) ) ) ; assertTrue ( groups [ i ] . isIsactive ( ) == testgroups [ i + 1 ] . isIsactive ( ) ) ; } groups = ga . fetchGroupsForUser ( 5 , false ) ; for ( int i = 0 ; i < groups . length ; i ++ ) { assertTrue ( groups [ i ] . getId ( ) == ( i + 2 + 1 ) ) ; assertTrue ( groups [ i ] . getName ( ) . equals ( testgroups [ i + 2 ] . getName ( ) ) ) ; assertTrue ( groups [ i ] . isIsactive ( ) == testgroups [ i + 2 ] . isIsactive ( ) ) ; } }
tr	1	private void milisecondwaitnumstartOnOff ( java . awt . event . MouseEvent evt ) { if ( ckwaitnummillbefkernel . isSelected ( ) ) { boot_delay_ms . setEnabled ( true ) ; } else boot_delay_ms . setEnabled ( false ) ; boot_delay_ms . repaint ( ) ; }
tr	5	public Component getTableCellRendererComponent ( JTable table , Object val , boolean sel , boolean foc , int r , int c ) { JLabel label ; if ( val == Attendance . PRESENT ) label = new JLabel ( new ImageIcon ( check_icon ) ) ; else if ( val == Attendance . ABSENT ) label = new JLabel ( "-" , SwingConstants . CENTER ) ; else if ( val instanceof BidCounter ) label = new BidLabel ( ( BidCounter ) val ) ; else if ( val instanceof Player ) label = new JLabel ( val . toString ( ) , SwingConstants . LEFT ) ; else label = new JLabel ( val . toString ( ) , SwingConstants . CENTER ) ; label . setFont ( table . getFont ( ) ) ; if ( sel ) { label . setOpaque ( true ) ; label . setBackground ( SystemColor . textHighlight ) ; label . setForeground ( SystemColor . textHighlightText ) ; } return label ; }
tr	8	private void waitForAndConnectClients ( ) { boolean afterFirstPlayer ; try { ServerSocket serverSocket = new ServerSocket ( PORT ) ; Socket clientSocket = new Socket ( ) ; acceptConnections ( serverSocket , clientSocket ) ; } catch ( SocketTimeoutException ste ) { System . out . println ( "SocketTimeoutException occured in Server" ) ; boolean exitLoop = false ; if ( Server . numOfClients >= 2 ) { this . startupPG . broadcastMessage ( "sBegin" ) ; while ( exitLoop == false ) { if ( this . startupPG . arePlayersReadyToPlay ( ) == true ) { cGame45 . beginRound ( ) ; exitLoop = true ; } else { try { Thread . sleep ( 1000 ) ; } catch ( InterruptedException ie ) { System . err . println ( "Server interupted while waiting on all remote players to set up their screens" ) ; } } } } else { System . out . println ( "Timeout exception occured and there was not enough players to begin playing" ) ; } } catch ( IOException ioe ) { System . out . println ( "IO Exception occured in Server" ) ; } catch ( SecurityException sc ) { System . out . println ( "SecurityExceptionException occured in Server" ) ; } catch ( IllegalBlockingModeException ibme ) { System . out . println ( "IllegalBlockingModeException occured in Server" ) ; } }
tr	9	public static boolean method189 ( int i , byte [ ] is , int i_250_ ) { boolean bool = true ; Stream stream = new Stream ( is ) ; int i_252_ = - 1 ; for ( ; ; ) { int i_253_ = stream . method422 ( ) ; if ( i_253_ == 0 ) break ; i_252_ += i_253_ ; int i_254_ = 0 ; boolean bool_255_ = false ; for ( ; ; ) { if ( bool_255_ ) { int i_256_ = stream . method422 ( ) ; if ( i_256_ == 0 ) break ; stream . readUnsignedByte ( ) ; } else { int i_257_ = stream . method422 ( ) ; if ( i_257_ == 0 ) break ; i_254_ += i_257_ - 1 ; int i_258_ = i_254_ & 3f ; int i_259_ = i_254_ >> 6 & 3f ; int i_260_ = stream . readUnsignedByte ( ) >> 2 ; int i_261_ = i_259_ + i ; int i_262_ = i_258_ + i_250_ ; if ( i_261_ > 0 && i_262_ > 0 && i_261_ < 103 && i_262_ < 103 ) { ObjectDef class46 = ObjectDef . forID ( i_252_ ) ; if ( i_260_ != 22 || ! lowMem || class46 . hasActions || class46 . aBoolean736 ) { bool &= class46 . method579 ( ) ; bool_255_ = true ; } } } } } return bool ; }
tr	5	private void startClientMonitor ( ) { while ( noStopRequested ) { try { if ( this . timeOut > 0 ) { Iterator < Object > it = clients . keySet ( ) . iterator ( ) ; while ( it . hasNext ( ) ) { Object key = it . next ( ) ; Client client = clients . get ( key ) ; if ( ! client . isReadDataFlag ( ) ) { client . close ( ) ; clients . remove ( key ) ; } else { client . setReadDataFlag ( false ) ; } } this . clientMonitor . sleep ( this . timeOut * 60 * 1000 ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } }
tr	7	static final public void term ( ) throws ParseException { unary ( ) ; label_2 : while ( true ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case MULTIPLY : case DIVIDE : ; break ; default : jj_la1 [ 3 ] = jj_gen ; break label_2 ; } switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case MULTIPLY : jj_consume_token ( MULTIPLY ) ; break ; case DIVIDE : jj_consume_token ( DIVIDE ) ; break ; default : jj_la1 [ 4 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } unary ( ) ; } }
tr	9	private void spawnGroundItem ( int i , int j ) { NodeList class19 = groundArray [ plane ] [ i ] [ j ] ; if ( class19 == null ) { worldController . method295 ( plane , i , j ) ; return ; } int k = fa0a1f01 ; Object obj = null ; for ( Item item = ( Item ) class19 . reverseGetFirst ( ) ; item != null ; item = ( Item ) class19 . reverseGetNext ( ) ) { ItemDef itemDef = ItemDef . forID ( item . ID ) ; int l = itemDef . value ; if ( itemDef . stackable ) l *= item . anInt1559 + 1 ; if ( l > k ) { k = l ; obj = item ; } } class19 . insertTail ( ( ( Node ) ( obj ) ) ) ; Object obj1 = null ; Object obj2 = null ; for ( Item class30_sub2_sub4_sub2_1 = ( Item ) class19 . reverseGetFirst ( ) ; class30_sub2_sub4_sub2_1 != null ; class30_sub2_sub4_sub2_1 = ( Item ) class19 . reverseGetNext ( ) ) { if ( class30_sub2_sub4_sub2_1 . ID != ( ( Item ) ( obj ) ) . ID && obj1 == null ) obj1 = class30_sub2_sub4_sub2_1 ; if ( class30_sub2_sub4_sub2_1 . ID != ( ( Item ) ( obj ) ) . ID && class30_sub2_sub4_sub2_1 . ID != ( ( Item ) ( obj1 ) ) . ID && obj2 == null ) obj2 = class30_sub2_sub4_sub2_1 ; } int i1 = i + ( j << 7 ) + 60000000 ; worldController . method281 ( i , i1 , ( ( Animable ) ( obj1 ) ) , method42 ( plane , j * 128 + 64 , i * 128 + 64 ) , ( ( Animable ) ( obj2 ) ) , ( ( Animable ) ( obj ) ) , plane , j ) ; }
tr	4	@ Override public boolean isEmpty ( ) { for ( MapSegment < K , V > mapSegment : mapSegments ) { mapSegment . lock . readLock ( ) . lock ( ) ; } try { for ( MapSegment < K , V > mapSegment : mapSegments ) { if ( ! mapSegment . isEmpty ( ) ) return false ; } return true ; } finally { for ( MapSegment < K , V > mapSegment : mapSegments ) { mapSegment . lock . readLock ( ) . unlock ( ) ; } } }
tr	7	void updateGui ( String fieldname ) { Object fieldval = fieldvalues . get ( fieldname ) ; Object fieldcom = fieldcomponents . get ( fieldname ) ; String fieldtype = ( String ) fieldtypes . get ( fieldname ) ; if ( fieldcom instanceof JCheckBox ) { ( ( JCheckBox ) fieldcom ) . setSelected ( ( ( boolean ) fieldval ) . booleanValue ( ) ) ; } else if ( fieldcom instanceof JColorChooser ) { JColorChooser jcc = ( JColorChooser ) fieldcom ; jcc . setColor ( ( Color ) fieldval ) ; } else if ( fieldcom instanceof KeyField ) { ( ( KeyField ) fieldcom ) . setValue ( ( ( Integer ) fieldval ) . intValue ( ) ) ; } else if ( fieldcom instanceof JTextField ) { JTextField textfield = ( JTextField ) fieldcom ; if ( fieldtype . equals ( "int" ) || fieldtype . equals ( "double" ) ) { textfield . setText ( "" + fieldval ) ; } else if ( fieldtype . equals ( "String" ) ) { textfield . setText ( "" + fieldval ) ; } } }
tr	4	RendererContext ( final String name ) { if ( LOG_CREATE_CONTEXT ) { MarlinUtils . logInfo ( "new RendererContext = " + name ) ; } this . name = name ; nPCPathIterator = new NormalizingPathIterator . NearestPixelCenter ( float6 ) ; nPQPathIterator = new NormalizingPathIterator . NearestPixelQuarter ( float6 ) ; transformerPC2D = new TransformingPathConsumer2D ( ) ; cache = new MarlinCache ( this ) ; renderer = new Renderer ( this ) ; ptg = new MarlinTileGenerator ( renderer ) ; stroker = new Stroker ( this ) ; dasher = new Dasher ( this ) ; switch ( MarlinRenderingEngine . REF_TYPE ) { default : case MarlinRenderingEngine . REF_HARD : reference = this ; break ; case MarlinRenderingEngine . REF_SOFT : reference = new SoftReference < RendererContext > ( this ) ; break ; case MarlinRenderingEngine . REF_WEAK : reference = new WeakReference < RendererContext > ( this ) ; break ; } }
tr	6	private int compare ( Object x , Object y ) { if ( x == null ) return ( y == null ? 0 : - 1 ) ; else if ( y == null ) return 1 ; else { if ( x instanceof EquivalentSet ) x = ( ( EquivalentSet ) x ) . contents . get ( 0 ) ; if ( y instanceof EquivalentSet ) y = ( ( EquivalentSet ) y ) . contents . get ( 0 ) ; if ( comp != null ) return comp . compare ( ( Elt ) x , ( Elt ) y ) ; else { Comparable cx = ( Comparable ) x ; Comparable cy = ( Comparable ) y ; return cx . compareTo ( cy ) ; } } }
tr	8	@ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; Route route = ( Route ) o ; if ( double . compare ( route . coeffDate , coeffDate ) != 0 ) return false ; if ( double . compare ( route . coeffSeats , coeffSeats ) != 0 ) return false ; if ( id != route . id ) return false ; if ( name != null ? ! name . equals ( route . name ) : route . name != null ) return false ; return true ; }
tr	6	String toString ( int indentFactor , int indent ) throws JSONException { int len = length ( ) ; if ( len == 0 ) { return "[]" ; } int i ; StringBuffer sb = new StringBuffer ( "[" ) ; if ( len == 1 ) { sb . append ( JSONObject . valueToString ( this . myArrayList . get ( 0 ) , indentFactor , indent ) ) ; } else { int newindent = indent + indentFactor ; sb . append ( '' ) ; for ( i = 0 ; i < len ; i += 1 ) { if ( i > 0 ) { sb . append ( " \n" ) ; } for ( int j = 0 ; j < newindent ; j += 1 ) { sb . append (   ) ; } sb . append ( JSONObject . valueToString ( this . myArrayList . get ( i ) , indentFactor , newindent ) ) ; } sb . append ( '' ) ; for ( i = 0 ; i < indent ; i += 1 ) { sb . append (   ) ; } } sb . append ( ] ) ; return sb . toString ( ) ; }
tr	1	public LinearRing getLinearRing ( ) { if ( this . objectNode instanceof LinearRing ) { return ( LinearRing ) this . objectNode ; } return null ; }
tr	5	private void mergeCollapse ( ) { while ( stackSize > 1 ) { int n = stackSize - 2 ; if ( n > 0 && runLen [ n - 1 ] <= runLen [ n ] + runLen [ n + 1 ] ) { if ( runLen [ n - 1 ] < runLen [ n + 1 ] ) { n -- ; } mergeAt ( n ) ; } else if ( runLen [ n ] <= runLen [ n + 1 ] ) { mergeAt ( n ) ; } else { break ; } } }
tr	5	@ Override public boolean equals ( Object obj ) { if ( obj != null && obj instanceof MarketPreviewOrder ) { MarketPreviewOrder other = ( MarketPreviewOrder ) obj ; for ( Entry < OrderPreviewField , String > ent : map . entrySet ( ) ) { if ( ! other . hasField ( ent . getKey ( ) ) && ! other . getField ( ent . getKey ( ) ) . equals ( ent . getValue ( ) ) ) { return false ; } } return true ; } return false ; }
tr	9	public static boolean useSlot ( final int slot ) { if ( ! checkIndex ( slot ) || ! setExpanded ( true ) || ! isReady ( slot ) ) return false ; WidgetChild main = getMainChild ( slot ) ; Ability thisAbility = getAbilityInSlot ( slot ) ; if ( thisAbility != null && ! thisAbility . available ( ) ) return false ; final Completion ret = ( thisAbility == null ) ? Completion . true : thisAbility . getChange ( ) ; int key = getKeyBind ( slot ) ; boolean keyed = false ; if ( key != - 1 && clearKeyboard ( ) ) { Keyboard . sendKey ( ( char ) key ) ; keyed = true ; } return ( keyed || main . visible ( ) && main . click ( true ) ) && new TimedCondition ( 2000 ) { @ Override public boolean isDone ( ) { return ( ret == null ) ? ! isReady ( slot ) : ret . isDone ( ) ; } } . waitStop ( ) ; }
tr	9	private Objective loadObjective ( TagCompound tag ) { try { TagBase tbname = tag . getTag ( "name" ) ; if ( ! ( tbname instanceof TagString ) ) return null ; TagBase tbtarget = tag . getTag ( "target" ) ; if ( ! ( tbtarget instanceof TagString ) ) return null ; TagBase tbtypes = tag . getTag ( "type" ) ; if ( ! ( tbtypes instanceof TagString ) ) return null ; ObjectiveType t = QuestManager . getInstance ( ) . getRegisteredObjectiveType ( ( ( TagString ) tbtypes ) . data ) ; if ( t == null ) return null ; Objective o = new Objective ( tag . getName ( ) , ( ( TagString ) tbname ) . data , t , ( ( TagString ) tbtarget ) . data ) ; TagBase tbicoid = tag . getTag ( "iconid" ) ; if ( tbicoid instanceof TagInt ) o . setItemIconId ( ( ( TagInt ) tbicoid ) . data ) ; TagBase tbopt = tag . getTag ( "optional" ) ; if ( tbopt instanceof TagByte ) o . setOptional ( ( ( TagByte ) tbopt ) . data == 1 ) ; TagBase tbvis = tag . getTag ( "visible" ) ; if ( tbvis instanceof TagByte ) o . setVisible ( ( ( TagByte ) tbvis ) . data == 1 ) ; TagBase rewards = tag . getTag ( "rewards" ) ; if ( rewards instanceof TagList ) { for ( TagBase b : ( ( TagList ) rewards ) . get ( ) ) { if ( b instanceof TagCompound ) { QuestAction a = loadAction ( ( TagCompound ) b ) ; if ( a != null ) o . addReward ( a ) ; } } } TagBase desc = tag . getTag ( "description" ) ; ArrayList < String > dsc = new ArrayList < String > ( ) ; if ( desc instanceof TagList ) { for ( TagBase b : ( ( TagList ) desc ) . get ( ) ) { if ( b instanceof TagString ) { dsc . add ( ( ( TagString ) b ) . data ) ; } } } o . setDescription ( dsc ) ; return o ; } catch ( IllegalArgumentException iae ) { return null ; } }
tr	9	@ Override public void actionPerformed ( ActionEvent event ) { if ( event . getSource ( ) == btn [ 0 ] ) { changeSettingPanel ( ) ; } if ( event . getSource ( ) == btn [ 1 ] ) { ip = textField [ 0 ] . getText ( ) ; port = textField [ 1 ] . getText ( ) ; pwd = pwdField . getText ( ) ; if ( ip . equals ( "" ) || port . equals ( "" ) || pwd . equals ( "" ) ) { JOptionPane . showMessageDialog ( null , "Input text" ) ; } else { ClientLauncher . getFrame ( ) . getConnectionPanel ( ) . setPrivate ( ip ) ; connection = ClientLauncher . getHybrid ( ) . auth ( Constants . hadoop , ip , port , pwd ) ; if ( connection ) { changeStatusPanel ( ) ; ClientLauncher . getFrame ( ) . getConnectionPanel ( ) . setP_ip ( ip ) ; ClientLauncher . getFrame ( ) . getConnectionPanel ( ) . setP_portNum ( 15000 ) ; } else { JOptionPane . showMessageDialog ( null , "Connect Error" ) ; } if ( isConnection ( ) && ClientLauncher . getFrame ( ) . getConnectionPanel ( ) . getPublicPanel ( ) . isConnection ( ) ) { String id = ClientLauncher . getFrame ( ) . getLoginPanel ( ) . getId ( ) ; String private_cloud = ClientLauncher . getFrame ( ) . getConnectionPanel ( ) . getPrivate ( ) ; String public_cloud = ClientLauncher . getFrame ( ) . getConnectionPanel ( ) . getPublic ( ) ; String data = id + "\t" + private_cloud + "\t" + public_cloud ; int type = Constants . PacketType . DirectoryListRequest . getType ( ) ; int length = data . length ( ) ; ClientLauncher . getFrame ( ) . changePanel ( ClientLauncher . getFrame ( ) . getDirectoryListPanel ( ) ) ; ClientLauncher . getConnector ( ) . sendPacket ( type , 0 , length , data ) ; } } } if ( event . getSource ( ) == btn [ 2 ] ) { changeStatusPanel ( ) ; } }
tr	8	public void update ( GameContainer gc , StateBasedGame sbg , int delta ) throws SlickException { this . inputCounter -= delta ; Input input = gc . getInput ( ) ; mouse . x = input . getMouseX ( ) ; mouse . y = input . getMouseY ( ) ; boolean click = input . isMouseButtonDown ( Input . MOUSE_LEFT_BUTTON ) ; if ( inputCounter < 0 ) { this . etatEditor = GestionClavier . gererClavier ( input , coordCarte , etatEditor , map , sbg ) ; switch ( etatEditor ) { case EDITOR : effetsCarteME . selection ( mouse , click , map , coordCarte , selec ) ; break ; case BLOCKS : etatEditor = listeBlocksME . selection ( mouse , click , effetsCarteME , etatEditor , selec ) ; break ; case OBJETS : etatEditor = listeObjetsME . selection ( mouse , click , effetsCarteME , etatEditor , selec ) ; break ; } if ( coordCarte . x > tailleMap . x || coordCarte . y < - tailleMap . x ) coordCarte . x = MathPerso . mod ( coordCarte . x , tailleMap . x ) ; if ( coordCarte . y > tailleMap . y || coordCarte . y < - tailleMap . y ) coordCarte . y = MathPerso . mod ( coordCarte . y , tailleMap . y ) ; inputCounter = 70 ; } }
tr	8	@ SuppressWarnings ( "unchecked" ) public static Iterator < Object > createIterator ( Object value , String delimiter ) { if ( value == null ) { return Collections . emptyList ( ) . iterator ( ) ; } else if ( value instanceof Iterator ) { return ( Iterator ) value ; } else if ( value instanceof Collection ) { Collection collection = ( Collection ) value ; return collection . iterator ( ) ; } else if ( value . getClass ( ) . isArray ( ) ) { List < Object > list = Arrays . asList ( ( Object [ ] ) value ) ; return list . iterator ( ) ; } else if ( value instanceof NodeList ) { final NodeList nodeList = ( NodeList ) value ; return CastUtils . cast ( new Iterator < Node > ( ) { int idx = - 1 ; public boolean hasNext ( ) { return ( idx + 1 ) < nodeList . getLength ( ) ; } public Node next ( ) { idx ++ ; return nodeList . item ( idx ) ; } public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ) ; } else if ( value instanceof String ) { final String s = ( String ) value ; if ( s . contains ( delimiter ) ) { Scanner scanner = new Scanner ( ( String ) value ) ; scanner . useDelimiter ( delimiter ) ; return CastUtils . cast ( scanner ) ; } else { return CastUtils . cast ( new Iterator < String > ( ) { int idx = - 1 ; public boolean hasNext ( ) { return idx + 1 == 0 && ObjectHelper . isNotEmpty ( s ) ; } public String next ( ) { idx ++ ; return s ; } public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ) ; } } else { return Collections . singletonList ( value ) . iterator ( ) ; } }
tr	6	private static Method getLongAddMethod ( class < ? > valueClass ) throws NoSuchMethodException , SecurityException { if ( valueClass . equals ( boolean . class ) ) return CMDLineParser . class . getMethod ( "addBooleanOption" , char . class , String . class ) ; if ( valueClass . equals ( Integer . class ) ) return CMDLineParser . class . getMethod ( "addIntegerOption" , char . class , String . class ) ; if ( valueClass . equals ( double . class ) ) return CMDLineParser . class . getMethod ( "addDoubleOption" , char . class , String . class ) ; if ( valueClass . equals ( String . class ) ) return CMDLineParser . class . getMethod ( "addStringOption" , char . class , String . class ) ; if ( valueClass . equals ( Range . class ) ) return CMDLineParser . class . getMethod ( "addRangeOption" , char . class , String . class ) ; return null ; }
tr	5	public boolean equals ( Object _other ) { if ( _other == null ) { return false ; } if ( _other == this ) { return true ; } if ( ! ( _other instanceof MsgType ) ) { return false ; } final MsgType _cast = ( MsgType ) _other ; if ( msgType == null ? _cast . msgType != msgType : ! msgType . equals ( _cast . msgType ) ) { return false ; } return true ; }
tr	1	private void DirectoryButtonActionPerformed ( java . awt . event . ActionEvent evt ) { String Rootname = acq_ . getRootName ( ) ; RootDirectoryField . setText ( Rootname ) ; fc . setFileSelectionMode ( JFileChooser . DIRECTORIES_ONLY ) ; int returnVal = fc . showOpenDialog ( this ) ; if ( returnVal == JFileChooser . APPROVE_OPTION ) { File file = fc . getSelectedFile ( ) ; Rootname = file . getPath ( ) ; RootDirectoryField . setText ( Rootname ) ; acq_ . setRootName ( Rootname ) ; } }
tr	1	public void loadData ( DadesHotel hotel ) { TitledBorder leftBorder = BorderFactory . createTitledBorder ( hotel . nom ) ; leftBorder . setTitleJustification ( TitledBorder . LEFT ) ; this . setBorder ( leftBorder ) ; nomHotel = hotel . nom ; hotelDescriptionLabel . setText ( hotel . desc ) ; DefaultListModel model = new DefaultListModel ( ) ; for ( DadesHabitacio hab : hotel . habs ) { String dada = hab . tipusHab + " (" + hab . preu + "\u20AC) - " + hab . numeroDisp + " disponibles" ; model . addElement ( dada ) ; nomsTipus . add ( hab . tipusHab ) ; } tipusHabitacionsList . setModel ( model ) ; }
tr	8	public static AccessionCollection exhaustiveSearch ( AccessionCollection ac , PseudoMeasure pm , int sampleMin , int sampleMax , boolean output ) { if ( sampleMin != sampleMax ) { System . err . println ( "\nError: minimum and maximum sample size should be equal for exhaustive search.\n" ) ; System . exit ( 1 ) ; } int coreSize = sampleMin ; AccessionCollection temp = null , core = null ; double score , bestScore = - double . MAX_VALUE ; int progress = 0 , newProgress ; String cacheID = PseudoMeasure . getUniqueId ( ) ; ThreadMXBean tb = ManagementFactory . getThreadMXBean ( ) ; double sTime = tb . getCurrentThreadCpuTime ( ) ; KSubsetGenerator ksub = new KSubsetGenerator ( coreSize , ac . size ( ) ) ; long nr = ksub . getNrOfKSubsets ( ) ; if ( output ) System . out . println ( "Nr of possible core sets: " + nr + "\n-------------" ) ; Integer [ ] icore = ksub . first ( ) ; for ( long i = 1 ; i <= nr ; i ++ ) { newProgress = ( int ) ( ( ( double ) i ) / ( ( double ) nr ) * 100 ) ; if ( newProgress > progress ) { if ( output ) System . out . println ( "### Progress: " + newProgress + "%" ) ; progress = newProgress ; } temp = ac . subset ( icore ) ; score = pm . calculate ( temp . getAccessions ( ) , cacheID ) ; if ( score > bestScore ) { core = temp ; bestScore = score ; if ( output ) System . out . println ( "best score: " + bestScore + "\tsize: " + core . size ( ) + "\ttime: " + ( tb . getCurrentThreadCpuTime ( ) - sTime ) / 1000000000 ) ; } ksub . successor ( icore ) ; } if ( output ) System . out . println ( "### End time: " + ( tb . getCurrentThreadCpuTime ( ) - sTime ) / 1000000000 ) ; return core ; }
tr	7	public static ChannelList parseClone ( File cloneFile ) { MainMethods . updateStatusBar ( "Parsing clone file..." ) ; ChannelList channelList = new ChannelList ( Channel . TYPE_CLONE , CloneChannel . class ) ; byte [ ] rawData ; try { rawData = getFileContentsAsBytes ( cloneFile ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; return null ; } int size = convertEndianess ( rawData [ 169f2 ] , rawData [ 169f1 ] ) ; for ( int i = 0 ; i < size ; i ++ ) { MainMethods . updateStatusProgress ( ( int ) ( i / ( float ) size * 100 ) ) ; int offset = 1342 + i * 81 ; if ( ( rawData [ offset + 73 ] & CloneChannel . FLAG_INACTIVE ) == CloneChannel . FLAG_INACTIVE ) continue ; CloneChannel cloneChannel = new CloneChannel ( ) ; for ( int j = 0 ; j < 81 ; j ++ ) cloneChannel . rawData [ j ] = rawData [ offset + j ] ; String channelName = "" ; for ( int j = 0 ; j < 50 ; j ++ ) { int c = rawData [ offset + j ] ; if ( c == 00 ) break ; if ( c < 0 ) c += 256 ; channelName += ( char ) c ; } cloneChannel . setProperty ( "name" , channelName ) ; cloneChannel . setProperty ( "num" , convertEndianess ( rawData [ offset + 51 ] , rawData [ offset + 50 ] ) ) ; cloneChannel . setProperty ( "vpid" , convertEndianess ( rawData [ offset + 53 ] , rawData [ offset + 52 ] ) ) ; cloneChannel . setProperty ( "mpid" , convertEndianess ( rawData [ offset + 55 ] , rawData [ offset + 54 ] ) ) ; cloneChannel . setProperty ( "freq" , rawData [ offset + 56 ] ) ; cloneChannel . setProperty ( "fav" , rawData [ offset + 57 ] ) ; cloneChannel . setProperty ( "nid" , convertEndianess ( rawData [ offset + 60 ] , rawData [ offset + 59 ] ) ) ; cloneChannel . setProperty ( "tsid" , convertEndianess ( rawData [ offset + 62 ] , rawData [ offset + 61 ] ) ) ; cloneChannel . setProperty ( "onid" , convertEndianess ( rawData [ offset + 64 ] , rawData [ offset + 63 ] ) ) ; cloneChannel . setProperty ( "sid" , convertEndianess ( rawData [ offset + 66 ] , rawData [ offset + 65 ] ) ) ; cloneChannel . setProperty ( "stype" , rawData [ offset + 71 ] ) ; cloneChannel . setProperty ( "enc" , rawData [ offset + 73 ] ) ; channelList . put ( ( Integer ) cloneChannel . getProperty ( "num" ) , cloneChannel ) ; } MainMethods . updateStatusBar ( "Parsed " + size + " channels in clone file." , 2 ) ; MainMethods . resetStatusProgress ( ) ; return channelList ; }
tr	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( Agregar . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( Agregar . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( Agregar . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( Agregar . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { new Agregar ( ) . setVisible ( true ) ; } } ) ; }
tr	6	@ Override protected void doReload ( ) { String doc = web . getDoc ( url , ref ) ; if ( doc == null ) { status = web . getStatus ( ) ; return ; } final String linkPrefix = "http://www.tv3play.lt/kategorijos/" ; final String linkBegin = "href=\"" + linkPrefix ; final String linkEnd = "\"" ; final String titleBegin = "<h3 class=\"clip-title\">" ; final String titleEnd = "</h3>" ; String link = web . findFirst ( linkBegin , linkEnd ) ; while ( link != null && link . length ( ) > 0 ) { web . skipLastPostfix ( ) ; String title = web . findNext ( titleBegin , titleEnd ) ; if ( title == null || title . length ( ) == 0 ) break ; if ( ! ids . contains ( title ) ) { add ( new Category ( model , linkPrefix + link , title ) ) ; ids . add ( title ) ; } web . skipLastPostfix ( ) ; link = web . findNext ( linkBegin , linkEnd ) ; } status = null ; }
