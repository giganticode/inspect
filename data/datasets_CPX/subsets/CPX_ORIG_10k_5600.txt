tr	0	public void setCodTipoPagamento ( Integer codTipoPagamento ) { this . codTipoPagamento = codTipoPagamento ; }
tr	1	boolean isGapAfterPush ( ) { return gapAfter != null && gapAfter . getGapPush ( ) ; }
tr	9	public Prototype load ( ) throws IOException { Prototype proto = new Prototype ( ) ; proto . source = readLuaString ( ) ; stream . skipBytes ( 8 ) ; proto . numUpvalues = read ( ) ; proto . numParams = read ( ) ; proto . isVararg = ( read ( ) & 2 ) != 0 ; proto . maxStacksize = read ( ) ; int length = 0 ; length = readInt ( ) ; int [ ] code = new int [ length ] ; for ( int index = 0 ; index < length ; index ++ ) code [ index ] = readInt ( ) ; length = readInt ( ) ; Object [ ] constants = new Object [ length ] ; for ( int index = 0 ; index < length ; index ++ ) { Object value = null ; int type = read ( ) ; switch ( type ) { case TYPE_NIL : break ; case TYPE_BOOLEAN : value = read ( ) != 0 ? boolean . true : boolean . false ; break ; case TYPE_NUMBER : value = double . longBitsToDouble ( readLong ( ) ) ; break ; case TYPE_STRING : value = readLuaString ( ) ; break ; default : throw new LuaException ( "Unknown constant type: " + type ) ; } constants [ index ] = value ; } length = readInt ( ) ; Prototype [ ] protos = new Prototype [ length ] ; for ( int index = 0 ; index < length ; index ++ ) protos [ index ] = load ( ) ; length = readInt ( ) ; int [ ] lines = new int [ length ] ; for ( int index = 0 ; index < length ; index ++ ) lines [ index ] = readInt ( ) ; length = readInt ( ) ; LocalVar [ ] locals = new LocalVar [ length ] ; for ( int index = 0 ; index < length ; index ++ ) locals [ index ] = new LocalVar ( readLuaString ( ) , readInt ( ) , readInt ( ) ) ; length = readInt ( ) ; String [ ] upvalues = new String [ length ] ; for ( int index = 0 ; index < length ; index ++ ) upvalues [ index ] = readLuaString ( ) ; proto . code = code ; proto . constants = constants ; proto . prototypes = protos ; proto . lines = lines ; proto . locals = locals ; proto . upvalues = upvalues ; return proto ; }
tr	6	public Menu ( ) { for ( int i = 0 ; i < strmenus . length ; i ++ ) { menus [ i ] = new JMenu ( strmenus [ i ] ) ; menus [ i ] . setMnemonic ( strmenus [ i ] . charAt ( 0 ) ) ; this . add ( menus [ i ] ) ; } for ( int i = 0 ; i < strmenuitems . length ; i ++ ) { menuitems [ i ] = new JMenuItem ( strmenuitems [ i ] ) ; menuitems [ i ] . setMnemonic ( strmenuitems [ i ] . charAt ( 0 ) ) ; menuitems [ i ] . addActionListener ( new MenuListener ( ) ) ; if ( i == 0 ) menus [ 0 ] . add ( menuitems [ i ] ) ; else if ( i == 1 || i == 2 ) menus [ 1 ] . add ( menuitems [ i ] ) ; else if ( i == 3 ) menus [ 2 ] . add ( menuitems [ i ] ) ; } }
tr	3	void readFromZip ( String fileName ) throws SAXException , TransformerConfigurationException , XMLStreamException , IOException { try { zipIn = new ZipFile ( fileName ) ; } catch ( FileNotFoundException e1 ) { e1 . printStackTrace ( ) ; } if ( zipIn != null ) { while ( visuPages . getTabCount ( ) > 0 ) visuPages . removeTabAt ( 0 ) ; hardwareOptDlg . dispose ( ) ; hardwareOptDlg = new HardwarePropertiesDialog ( this ) ; hardwareOptDlg . setLocation ( 220 , 120 ) ; pictures . clearArchive ( ) ; pictures . loadLibraryFromArchive ( zipIn ) ; sounds . clearArchive ( ) ; sounds . loadLibraryFromArchive ( zipIn ) ; ZipEntry visuZipObj = zipIn . getEntry ( "Visu.xml" ) ; InputStream zipInStream = zipIn . getInputStream ( visuZipObj ) ; parseXMLStream ( zipInStream ) ; zipIn . close ( ) ; } }
tr	2	public synchronized static Result < ProductGateway > getProductsBySupplier ( int supplierID ) throws SQLException { Result < ProductGateway > result = new Result < ProductGateway > ( ) ; Connection connection = null ; PreparedStatement prepStmt = null ; try { connection = DB . getConnection ( ) ; connection . setAutoCommit ( true ) ; prepStmt = connection . prepareStatement ( "SELECT * FROM Product WHERE SupplierID = ?;" ) ; prepStmt . setInt ( 1 , supplierID ) ; prepStmt . setMaxRows ( 1 ) ; ResultSet rs = prepStmt . executeQuery ( ) ; while ( rs . next ( ) ) { ProductGateway product = new ProductGateway ( ) ; product . ProductID = rs . getInt ( "ProductID" ) ; product . SupplierID = rs . getInt ( "SupplierID" ) ; product . Price = rs . getDouble ( "Price" ) ; product . ProductName = rs . getString ( "ProductName" ) ; product . ProductDescription = rs . getString ( "ProductDescription" ) ; product . InStock = rs . getBoolean ( "InStock" ) ; result . Items . add ( product ) ; } rs . close ( ) ; prepStmt . close ( ) ; DB . closeConnection ( ) ; return result ; } catch ( Exception e ) { throw e ; } }
tr	1	public int length ( ) { LinkedListNode iter = this ; int acc = 0 ; while ( iter != null ) { acc ++ ; iter = iter . next ; } return acc ; }
tr	5	@ SuppressWarnings ( { "unchecked" , "unused" } ) @ ApiMethod ( name = "listMessages" ) public CollectionResponse < MessageData > listMessages ( @ Nullable @ Named ( "cursor" ) String cursorString , @ Nullable @ Named ( "limit" ) Integer limit ) { EntityManager mgr = null ; Cursor cursor = null ; List < MessageData > execute = null ; try { mgr = getEntityManager ( ) ; Query query = mgr . createQuery ( "select from MessageData as MessageData order by timestamp desc" ) ; if ( cursorString != null && cursorString != "" ) { cursor = Cursor . fromWebSafeString ( cursorString ) ; query . setHint ( JPACursorHelper . CURSOR_HINT , cursor ) ; } if ( limit != null ) { query . setFirstResult ( 0 ) ; query . setMaxResults ( limit ) ; } execute = ( List < MessageData > ) query . getResultList ( ) ; cursor = JPACursorHelper . getCursor ( execute ) ; if ( cursor != null ) cursorString = cursor . toWebSafeString ( ) ; for ( MessageData obj : execute ) { ; } } finally { mgr . close ( ) ; } return CollectionResponse . < MessageData > builder ( ) . setItems ( execute ) . setNextPageToken ( cursorString ) . build ( ) ; }
tr	5	private boolean zzRefill ( ) throws java . io . IOException { if ( zzStartRead > 0 ) { System . arraycopy ( zzBuffer , zzStartRead , zzBuffer , 0 , zzEndRead - zzStartRead ) ; zzEndRead -= zzStartRead ; zzCurrentPos -= zzStartRead ; zzMarkedPos -= zzStartRead ; zzStartRead = 0 ; } if ( zzCurrentPos >= zzBuffer . length ) { char newBuffer [ ] = new char [ zzCurrentPos * 2 ] ; System . arraycopy ( zzBuffer , 0 , newBuffer , 0 , zzBuffer . length ) ; zzBuffer = newBuffer ; } int numRead = zzReader . read ( zzBuffer , zzEndRead , zzBuffer . length - zzEndRead ) ; if ( numRead > 0 ) { zzEndRead += numRead ; return false ; } if ( numRead == 0 ) { int c = zzReader . read ( ) ; if ( c == - 1 ) { return true ; } else { zzBuffer [ zzEndRead ++ ] = ( char ) c ; return false ; } } return true ; }
tr	9	@ Override protected void handleKeyboard ( ) { if ( keyPoller . isKeyDown ( KeyEvent . VK_LEFT ) ) { player1 . Direction ( - bLevel . getTileDim ( ) / player1 . getStepsize ( ) , 0 ) ; stepCount ++ ; } else if ( keyPoller . isKeyDown ( KeyEvent . VK_RIGHT ) ) { player1 . Direction ( bLevel . getTileDim ( ) / player1 . getStepsize ( ) , 0 ) ; stepCount ++ ; } if ( keyPoller . isKeyDown ( KeyEvent . VK_UP ) ) { player1 . Direction ( 0 , - bLevel . getTileDim ( ) / player1 . getStepsize ( ) ) ; stepCount ++ ; } else if ( keyPoller . isKeyDown ( KeyEvent . VK_DOWN ) ) { player1 . Direction ( 0 , bLevel . getTileDim ( ) / player1 . getStepsize ( ) ) ; stepCount ++ ; } else if ( keyPoller . isKeyDown ( KeyEvent . VK_SPACE ) ) { playAudio . playSound ( "Put" ) ; int posX = player1 . getPosXForBomb ( ) ; int posY = player1 . getPosYForBomb ( ) ; if ( ! bLevel . hasBombByPixel ( posX , posY ) && player1 . bombplantable ( ) ) { bombsP1 . add ( new Bomben ( ( posX / bLevel . getTileDim ( ) ) * bLevel . getTileDim ( ) , ( posY / bLevel . getTileDim ( ) ) * bLevel . getTileDim ( ) , player1 . maxradius ( ) , player1 , bLevel ) ) ; sendBomb ( posX , posY , player1 . maxradius ( ) ) ; player1 . addcurrentbombs ( ) ; } } if ( keyReceiver . isKeyDown ( KeyEvent . VK_LEFT ) ) { player2 . Direction ( - bLevel . getTileDim ( ) / player2 . getStepsize ( ) , 0 ) ; stepCount ++ ; } else if ( keyReceiver . isKeyDown ( KeyEvent . VK_RIGHT ) ) { player2 . Direction ( bLevel . getTileDim ( ) / player2 . getStepsize ( ) , 0 ) ; stepCount ++ ; } if ( keyReceiver . isKeyDown ( KeyEvent . VK_UP ) ) { player2 . Direction ( 0 , - bLevel . getTileDim ( ) / player2 . getStepsize ( ) ) ; stepCount ++ ; } else if ( keyReceiver . isKeyDown ( KeyEvent . VK_DOWN ) ) { player2 . Direction ( 0 , bLevel . getTileDim ( ) / player2 . getStepsize ( ) ) ; stepCount ++ ; } else if ( keyReceiver . isKeyDown ( KeyEvent . VK_SPACE ) ) { playAudio . playSound ( "Put" ) ; int posX = player2 . getPosXForBomb ( ) ; int posY = player2 . getPosYForBomb ( ) ; if ( ! bLevel . hasBombByPixel ( posX , posY ) && player2 . bombplantable ( ) ) { bombsP2 . add ( new Bomben ( ( posX / bLevel . getTileDim ( ) ) * bLevel . getTileDim ( ) , ( posY / bLevel . getTileDim ( ) ) * bLevel . getTileDim ( ) , player2 . maxradius ( ) , player2 , bLevel ) ) ; sendBomb ( posX , posY , player2 . maxradius ( ) ) ; player2 . addcurrentbombs ( ) ; } } }
tr	7	public void mousePress ( MouseEvent e , Canvas canvas , Palette p ) { if ( active != null ) { if ( e . getButton ( ) == button ) finish ( canvas , p ) ; else cancel ( canvas ) ; return ; } if ( ! isValid ( e , canvas , p ) ) return ; button = e . getButton ( ) ; mouseTime = e . getWhen ( ) ; Color c1 = p . getLeft ( ) ; Color c2 = p . getRight ( ) ; if ( button != MouseEvent . BUTTON1 ) { c1 = c2 ; c2 = p . getLeft ( ) ; } switch ( type ) { case OUTLINE : canvas . active = active = new OvalAction ( canvas , e . getPoint ( ) , c1 , null ) ; break ; case BOTH : canvas . active = active = new OvalAction ( canvas , e . getPoint ( ) , c1 , c2 ) ; break ; case FILL : canvas . active = active = new OvalAction ( canvas , e . getPoint ( ) , c1 , c1 ) ; break ; } canvas . repaint ( ) ; }
tr	3	public static boolean isOnFromOrBetween ( Calendar date , Calendar from , Calendar to ) { boolean afterFrom = isAfter ( date , from ) ; boolean beforeTo = isBefore ( date , to ) ; boolean onFrom = isSameDay ( date , from ) ; if ( ( afterFrom && beforeTo ) || onFrom ) { return true ; } else { return false ; } }
tr	4	@ Override public void input ( Controls . Input type , boolean pressed ) { if ( type == Controls . Input . DEBUG && pressed && states [ type . ordinal ( ) ] == false ) { for ( int i = 0 ; i < states . length ; i ++ ) { System . out . print ( states [ i ] + " " ) ; } System . out . println ( ) ; } states [ type . ordinal ( ) ] = pressed ; }
tr	2	@ Override public ScoredDocument runquery ( Query query , Document doc ) { Vector < String > tokens = query . getTokens ( ) ; double score = 0.0 ; for ( String token : tokens ) { if ( super . corpus . containsToken ( token ) ) { Term term = super . corpus . getTerm ( token ) ; score += ql_score ( doc , term ) ; } } return new ScoredDocument ( doc , score ) ; }
tr	5	public static void print ( java . lang . String format , int amount , boolean vertical , Object ... objects ) { if ( objects != null ) { java . lang . String [ ] formats = null ; if ( format != null && ! format . isEmpty ( ) ) { formats = format . split ( " " ) ; } if ( formats . length == objects . length ) { for ( int i = 0 ; i < objects . length ; i ++ ) { $ . print ( formats [ i ] , objects [ i ] , 1 , vertical ) ; } } } }
tr	8	@ SuppressWarnings ( "unchecked" ) public static Collection reject ( Collection source , OclContext context , String iteratorName , OclExpression body ) throws OclEvaluationException { CascadingOclContext innerContext = new CascadingOclContext ( context ) ; if ( source instanceof Set ) { Set set = new HashSet ( ) ; for ( Object object : source ) { innerContext . setVariable ( iteratorName , object ) ; if ( ! ( boolean ) body . eval ( innerContext ) ) set . add ( object ) ; } return set ; } else if ( source instanceof SortedSet ) { SortedSet set = new TreeSet ( ) ; for ( Object object : source ) { innerContext . setVariable ( iteratorName , object ) ; if ( ! ( boolean ) body . eval ( innerContext ) ) set . add ( object ) ; } return set ; } else { List list = new ArrayList ( ) ; for ( Object object : source ) { innerContext . setVariable ( iteratorName , object ) ; if ( ! ( boolean ) body . eval ( innerContext ) ) list . add ( object ) ; } return list ; } }
tr	3	public static void refresh ( ) throws Exception { Collection < String > paths = SystemSetting . getInstance ( ) . getPaths ( ) . values ( ) ; for ( String path : paths ) { System . out . println ( "Scanning path:" + path ) ; List < Album > as = scanPath ( path ) ; if ( as == null ) continue ; System . out . println ( "Persisting albums:" + as . size ( ) ) ; AlbumDAO . deleteByPathHash ( path . hashCode ( ) ) ; for ( Album a : as ) { AlbumDAO . insertAlbum ( a ) ; } } }
tr	9	public void addStaffInfo ( Vector < StaffInfo > staff , JTextField [ ] staffTF , JList positionList , JList qualificationList , String hospitalList , JTable table ) { DB . db . openConnection ( ) ; try { int posid = - 1 ; int qualid = - 1 ; int hospId = - 1 ; String [ ] tmp = new String [ staffTF . length ] ; for ( int i = 0 ; i < staffTF . length ; i ++ ) { tmp [ i ] = staffTF [ i ] . getText ( ) ; } if ( positionList == null || qualificationList == null ) { throw new Exception ( ) ; } String login = JOptionPane . showInputDialog ( "Enter desired login" ) ; String password = null ; JPasswordField passwordField = new JPasswordField ( ) ; passwordField . setEchoChar ( * ) ; Object [ ] obj = { "Please enter the password:\n\n" , passwordField } ; Object stringArray [ ] = { "OK" , "Cancel" } ; if ( JOptionPane . showOptionDialog ( null , obj , "Desired password" , JOptionPane . YES_NO_OPTION , JOptionPane . QUESTION_MESSAGE , null , stringArray , obj ) == JOptionPane . YES_OPTION ) { password = new String ( passwordField . getPassword ( ) ) ; } ResultSet rs = DB . db . position ( positionList . getSelectedValue ( ) . toString ( ) ) ; while ( rs . next ( ) ) { posid = rs . getInt ( "id" ) ; } rs = DB . db . qualification ( qualificationList . getSelectedValue ( ) . toString ( ) ) ; while ( rs . next ( ) ) { qualid = rs . getInt ( "id" ) ; } Auth t = new Auth ( login , password ) ; DB . db . addStaff ( tmp , qualid , posid , t . getLogin ( ) , t . getPasswHash ( ) ) ; DB . db . close ( ) ; staff . removeAllElements ( ) ; this . fillStaff ( ( Vector < T > ) staff ) ; rs = ( ResultSet ) DB . db . hospital ( hospitalList ) ; while ( rs . next ( ) ) { hospId = rs . getInt ( "id" ) ; } for ( int i = 0 ; i < 7 ; i ++ ) { DB . db . editStaffHospitalSchedual ( staff . lastElement ( ) . getId ( ) , hospId , table . getValueAt ( i , 0 ) , table . getValueAt ( i , 1 ) , table . getValueAt ( i , 2 ) ) ; } DB . db . close ( ) ; } catch ( Exception ex ) { Logger . getLogger ( Func . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; DB . db . close ( ) ; } }
tr	6	private static < AnyType extends Comparable < ? super AnyType >> void quicksort ( AnyType [ ] a , int left , int right ) { if ( left + CUTOFF <= right ) { AnyType pivot = median3 ( a , left , right ) ; int i = left , j = right - 1 ; for ( ; ; ) { while ( a [ ++ i ] . compareTo ( pivot ) < 0 ) { } while ( a [ -- j ] . compareTo ( pivot ) > 0 ) { } if ( i < j ) swapReferences ( a , i , j ) ; else break ; } swapReferences ( a , i , right - 1 ) ; quicksort ( a , left , i - 1 ) ; quicksort ( a , i + 1 , right ) ; } else insertionSort ( a , left , right ) ; }
tr	1	public void setCached ( boolean cached ) { this . cached = cached ; if ( this . cached = false ) this . cache = null ; }
tr	3	public String getCoordinates ( ) { String coordStr = "" ; for ( int i = 0 ; i < this . coordinates . length ; i ++ ) { coordStr += this . coordinates [ i ] ; if ( i < ( this . coordinates . length - 1 ) ) { if ( i % 3 == 2 ) { coordStr += " " ; } else { coordStr += " " ; } } } return coordStr ; }
tr	5	Entry removeMapping ( final Object o ) { if ( ! ( o instanceof Entry ) ) { return null ; } final Entry entry = ( Entry ) o ; final long key = entry . getKey ( ) ; final int hash = Entry . keyHashCode ( key ) ; final int i = hash & this . tableSizeMinusOne ; Entry prev = this . table [ i ] ; Entry e = prev ; while ( e != null ) { final Entry next = e . next ; if ( e . hash == hash && e . equals ( entry ) ) { -- this . size ; if ( prev == e ) { this . table [ i ] = next ; } else { prev . next = next ; } return e ; } prev = e ; e = next ; } return e ; }
tr	8	public void run ( ) { HttpRequest hq = null ; try { boolean successfull = false ; if ( inbound == null || inbound . isClosed ( ) ) { isDead = true ; return ; } hq = HttpRequest . createRequest ( ) ; successfull = hq . readRequest ( inbound ) ; if ( hq . passthroughssl ( ) ) { new Thread ( new ShortCircuitSSLProxy ( hq ) ) . start ( ) ; } if ( ! GizmoView . getView ( ) . intercepting ( ) || ! GizmoView . getView ( ) . matchRequest ( hq . contents ( ) ) ) { hq . fetchResponse ( false ) ; if ( hq . passthroughssl ( ) ) { new Thread ( new ShortCircuitSSLProxy ( hq ) ) . start ( ) ; } GizmoView . getView ( ) . setStatus ( "" ) ; hq . sendDataToClient ( ) ; hq . closeClientConnection ( ) ; } else { } if ( successfull ) { handlerhandler . addMessage ( hq ) ; synchronized ( lock ) { lock . notifyAll ( ) ; } } else { inbound . close ( ) ; } return ; } catch ( IOException e ) { System . out . println ( e ) ; } }
tr	4	public static void normalize ( final SampleSet set , final double [ ] mean , final double [ ] stddev , final int ... idxs ) { if ( set . size ( ) == 0 ) return ; final int inputsize = set . get ( 0 ) . getInputSize ( ) ; for ( Sample sample : set ) { final double [ ] input = sample . getInput ( ) ; int offset = 0 ; for ( int s = 0 ; s < sample . getInputLength ( ) ; s ++ ) { for ( int i = 0 ; i < idxs . length ; i ++ ) { final int idx = idxs [ i ] ; final double x = input [ offset + idx ] ; input [ offset + idx ] = ( ( x - mean [ idx ] ) / stddev [ idx ] ) ; } offset += inputsize ; } } }
tr	3	public int getPort ( ) { String num = getString ( "Port" ) ; if ( num == null || num . equals ( "" ) ) { return DEFAULT_PORT ; } try { return Integer . parseInt ( num , 10 ) ; } catch ( NumberFormatException ex ) { logger . warning ( "Bad value for listening port (" + num + ")" ) ; throw new IllegalStateException ( "Bad value for listening port (" + num + ")" , ex ) ; } }
tr	3	@ Override public int search ( E data ) { int centerint , left , right ; left = 0 ; right = _lenght - 1 ; E center ; while ( left <= right ) { centerint = ( left + right ) / 2 ; center = get ( centerint ) ; if ( _comparator . isHigher ( center , data ) ) { right = centerint - 1 ; } else if ( _comparator . isLess ( center , data ) ) { left = centerint + 1 ; } else { return ( left + right ) / 2 ; } } return - 1 ; }
tr	2	public String pedidoPorCliente ( Cliente cliente ) { String retorno = "" ; for ( Pedido p : lista ) { if ( p . getCliente ( ) . getCodigo ( ) == cliente . getCodigo ( ) ) retorno += p . toString ( ) ; } return retorno ; }
tr	4	public void sortColors ( int [ ] A ) { int index0 = 0 , index1 = 0 , index2 = 0 ; for ( int i = 0 ; i < A . length ; i ++ ) { if ( A [ i ] == 0 ) { A [ index2 ] = 2 ; index2 ++ ; A [ index1 ] = 1 ; index1 ++ ; A [ index0 ] = 0 ; index0 ++ ; } else if ( A [ i ] == 1 ) { A [ index2 ] = 2 ; index2 ++ ; A [ index1 ] = 1 ; index1 ++ ; } else if ( A [ i ] == 2 ) { A [ index2 ] = 2 ; index2 ++ ; } } }
tr	9	public void setCurrentVar ( int mag_idx ) { assert ( mag_idx >= - 1 && mag_idx < PaneData . magnetList . size ( ) ) ; setVisible ( false ) ; this . removeAll ( ) ; this . mag_idx = mag_idx ; if ( mag_idx == - 1 ) { log . severe ( "Magnet Pane - Magnet unselected." ) ; setVisible ( true ) ; return ; } Magnet mag = ( Magnet ) PaneData . magnetList . get ( mag_idx ) ; String mag_name = mag . getMagnetName ( ) ; for ( int i = 0 ; i < PaneData . var_names . size ( ) ; i ++ ) { String var_name = ( String ) PaneData . var_names . get ( i ) ; if ( var_name . equalsIgnoreCase ( mag_name ) ) { this . var_idx = i ; break ; } } log . severe ( "Magnet Pane - [" + PaneData . var_names . get ( var_idx ) + "] is selected." ) ; GridBagConstraints constraints = new GridBagConstraints ( ) ; setLayout ( new GridBagLayout ( ) ) ; constraints . fill = GridBagConstraints . BOTH ; strMeasure = ( String ) PaneData . var_measures . get ( var_idx ) ; strType = ( String ) PaneData . var_types . get ( var_idx ) ; if ( strType . equals ( "S" ) && strMeasure . equals ( "O" ) ) { JLabel label1 = new JLabel ( "Magnitude" ) ; constraints . weightx = 1.0 ; constraints . weighty = 0.1 ; constraints . gridx = 0 ; constraints . gridy = 0 ; add ( label1 , constraints ) ; sliderMag = new JSlider ( JSlider . HORIZONTAL , 0 , 20 , mag . getMagnitude ( ) ) ; sliderMag . setMinorTickSpacing ( 1 ) ; sliderMag . setMajorTickSpacing ( 5 ) ; sliderMag . setPaintTicks ( true ) ; sliderMag . setPaintLabels ( true ) ; sliderMag . addChangeListener ( new ChangeListener ( ) { public void stateChanged ( ChangeEvent e ) { JSlider slider = ( JSlider ) e . getSource ( ) ; PaneMagnetSelect pms = ( PaneMagnetSelect ) slider . getParent ( ) ; pms . apply ( ) ; log . severe ( "Magnet Pane - Magnitude [" + PaneData . var_names . get ( pms . var_idx ) + "] is changed to [" + slider . getValue ( ) + "]" ) ; } } ) ; constraints . weightx = 1.0 ; constraints . weighty = 0.2 ; constraints . gridx = 0 ; constraints . gridy = 1 ; add ( sliderMag , constraints ) ; JLabel label2 = new JLabel ( "Repellent" ) ; constraints . weightx = 1.0 ; constraints . weighty = 0.1 ; constraints . gridx = 0 ; constraints . gridy = 2 ; add ( label2 , constraints ) ; assert PaneData . values_min . get ( var_idx ) instanceof Integer ; assert PaneData . values_max . get ( var_idx ) instanceof Integer ; int min = ( ( Integer ) PaneData . values_min . get ( var_idx ) ) . intValue ( ) ; int max = ( ( Integer ) PaneData . values_max . get ( var_idx ) ) . intValue ( ) ; chkboxList = new JCheckBox [ max - min + 1 ] ; ArrayList repelList = mag . getRepelList ( ) ; for ( int i = 0 ; i <= max - min ; i ++ ) { DataLabel label = ( DataLabel ) PaneData . var_labels . get ( var_idx ) ; chkboxList [ i ] = new JCheckBox ( label . get ( min + i ) + " (" + Integer . toString ( min + i ) + ")" ) ; if ( repelList == null ) chkboxList [ i ] . setSelected ( false ) ; else chkboxList [ i ] . setSelected ( ( ( boolean ) repelList . get ( i ) ) . booleanValue ( ) ) ; constraints . weightx = 1.0 ; constraints . weighty = 0.05 ; constraints . gridx = 0 ; constraints . gridy = 3 + i ; add ( chkboxList [ i ] , constraints ) ; } } else if ( strMeasure . equals ( "Q" ) ) { JLabel label1 = new JLabel ( "Magnitude" ) ; constraints . weightx = 1.0 ; constraints . weighty = 0.1 ; constraints . gridx = 0 ; constraints . gridy = 0 ; add ( label1 , constraints ) ; sliderMag = new JSlider ( JSlider . HORIZONTAL , 0 , 20 , mag . getMagnitude ( ) ) ; sliderMag . setMinorTickSpacing ( 1 ) ; sliderMag . setMajorTickSpacing ( 5 ) ; sliderMag . setPaintTicks ( true ) ; sliderMag . setPaintLabels ( true ) ; sliderMag . addChangeListener ( new ChangeListener ( ) { public void stateChanged ( ChangeEvent e ) { JSlider slider = ( JSlider ) e . getSource ( ) ; PaneMagnetSelect pms = ( PaneMagnetSelect ) slider . getParent ( ) ; pms . apply ( ) ; log . severe ( "Magnet Pane - Magnitude [" + PaneData . var_names . get ( pms . var_idx ) + "] is changed to [" + slider . getValue ( ) + "]" ) ; } } ) ; constraints . weightx = 1.0 ; constraints . weighty = 0.2 ; constraints . gridx = 0 ; constraints . gridy = 1 ; add ( sliderMag , constraints ) ; JLabel label2 = new JLabel ( "Repellent" ) ; constraints . weightx = 1.0 ; constraints . weighty = 0.1 ; constraints . gridx = 0 ; constraints . gridy = 2 ; add ( label2 , constraints ) ; double threshold = new double ( mag . getThreshold ( ) ) ; if ( strType . equals ( "I" ) ) { int min , max ; min = ( ( Integer ) PaneData . values_min . get ( var_idx ) ) . intValue ( ) ; max = ( ( Integer ) PaneData . values_max . get ( var_idx ) ) . intValue ( ) ; sliderRepel = new JSlider2 ( JSlider . HORIZONTAL , min , max , threshold . intValue ( ) ) ; sliderRepel . setMinorTickSpacing ( ( max - min ) / 10 ) ; sliderRepel . setMajorTickSpacing ( ( max - min ) / 2 ) ; sliderRepel . setPaintTicks ( true ) ; sliderRepel . setPaintLabels ( true ) ; sliderRepel . addChangeListener ( new ChangeListener ( ) { public void stateChanged ( ChangeEvent e ) { JSlider2 slider = ( JSlider2 ) e . getSource ( ) ; PaneMagnetSelect pms = ( PaneMagnetSelect ) slider . getParent ( ) ; pms . apply ( ) ; log . severe ( "Magnet Pane - Repellent [" + PaneData . var_names . get ( pms . var_idx ) + "] is changed to [" + slider . getValue ( ) + "]" ) ; } } ) ; } else if ( strType . equals ( "D" ) ) { double dmin , dmax ; dmin = ( ( double ) PaneData . values_min . get ( var_idx ) ) . doubleValue ( ) ; dmax = ( ( double ) PaneData . values_max . get ( var_idx ) ) . doubleValue ( ) ; sliderRepel = new JSlider2 ( JSlider . HORIZONTAL , dmin , dmax , threshold . doubleValue ( ) , 1 ) ; sliderRepel . setMinorTickSpacing ( ( dmax - dmin ) / 10 ) ; sliderRepel . setMajorTickSpacing ( ( dmax - dmin ) / 2 ) ; sliderRepel . setPaintTicks ( true ) ; sliderRepel . setPaintLabels ( true ) ; sliderRepel . addChangeListener ( new ChangeListener ( ) { public void stateChanged ( ChangeEvent e ) { JSlider2 slider = ( JSlider2 ) e . getSource ( ) ; PaneMagnetSelect pms = ( PaneMagnetSelect ) slider . getParent ( ) ; pms . apply ( ) ; log . severe ( "Magnet Pane - Repellent [" + PaneData . var_names . get ( pms . var_idx ) + "] is changed to [" + slider . getDoubleValue ( ) + "]" ) ; } } ) ; } else { assert false ; } constraints . weightx = 1.0 ; constraints . weighty = 0.2 ; constraints . gridx = 0 ; constraints . gridy = 3 ; add ( sliderRepel , constraints ) ; } else assert false ; this . setVisible ( true ) ; }
tr	3	private boolean r_Step_5b ( ) { ket = cursor ; if ( ! ( eq_s_b ( 1 , "l" ) ) ) { return false ; } bra = cursor ; if ( ! r_R2 ( ) ) { return false ; } if ( ! ( eq_s_b ( 1 , "l" ) ) ) { return false ; } slice_del ( ) ; return true ; }
tr	7	private void AreaDFS ( AreaNode n ) { ArrayList < Goal > neighborGoals = new ArrayList < Goal > ( ) ; Queue < Field > queue = new LinkedList < Field > ( ) ; queue . add ( n . fields . get ( 0 ) ) ; while ( queue . size ( ) > 0 ) { Field t = queue . poll ( ) ; for ( Field field : t . neighbors ) { if ( field == null ) continue ; if ( field instanceof Goal ) { neighborGoals . add ( ( Goal ) field ) ; } else if ( field . node == null ) { queue . add ( field ) ; fields . add ( field ) ; field . td = this ; n . addField ( field ) ; } } } for ( Goal g : neighborGoals ) { if ( g . node == null ) { goals . add ( g ) ; g . td = this ; GoalNode m = new GoalNode ( g ) ; graph . add ( m ) ; GoalDFS ( m ) ; } else { g . node . neighbors . add ( n ) ; n . neighbors . add ( g . node ) ; } } }
tr	1	public static long factorial ( long n ) { long f = 1 ; for ( long i = 1 ; i <= n ; i ++ ) { f *= i ; } return f ; }
tr	8	private static int [ ] [ ] LCS_length ( String X , String Y ) { int a [ ] [ ] = new int [ X . length ( ) + 1 ] [ Y . length ( ) + 1 ] ; char b [ ] [ ] = new char [ X . length ( ) ] [ Y . length ( ) ] ; for ( int i = 0 ; i < X . length ( ) ; i ++ ) { a [ i ] [ 0 ] = 0 ; } for ( int j = 0 ; j < Y . length ( ) ; j ++ ) { a [ 0 ] [ j ] = 0 ; } for ( int i = 1 ; i < X . length ( ) + 1 ; i ++ ) { for ( int j = 1 ; j < Y . length ( ) + 1 ; j ++ ) { if ( X . charAt ( i - 1 ) == Y . charAt ( j - 1 ) ) { a [ i ] [ j ] = a [ i - 1 ] [ j - 1 ] + 1 ; b [ i - 1 ] [ j - 1 ] = ↖ ; } else { if ( a [ i - 1 ] [ j ] >= a [ i ] [ j - 1 ] ) { a [ i ] [ j ] = a [ i - 1 ] [ j ] ; b [ i - 1 ] [ j - 1 ] = ↑ ; } else { a [ i ] [ j ] = a [ i ] [ j - 1 ] ; b [ i - 1 ] [ j - 1 ] = ← ; } } } } for ( int i = 0 ; i < b . length ; i ++ ) { System . out . println ( Arrays . toString ( b [ i ] ) ) ; } for ( int i = 0 ; i < a . length ; i ++ ) { System . out . println ( Arrays . toString ( a [ i ] ) ) ; } return a ; }
tr	6	public boolean getBoolean ( int index ) throws JSONException { Object object = this . get ( index ) ; if ( object . equals ( boolean . false ) || ( object instanceof String && ( ( String ) object ) . equalsIgnoreCase ( "false" ) ) ) { return false ; } else if ( object . equals ( boolean . true ) || ( object instanceof String && ( ( String ) object ) . equalsIgnoreCase ( "true" ) ) ) { return true ; } throw new JSONException ( "JSONArray[" + index + "] is not a boolean." ) ; }
tr	0	protected Logger getLogger ( ) { return this . logger ; }
tr	3	public static Polynomial createFromBytes ( byte [ ] bytes ) { TreeSet < BigInteger > dgrs = createDegreesCollection ( ) ; int degree = 0 ; for ( int i = bytes . length - 1 ; i >= 0 ; i -- ) { for ( int j = 0 ; j < 8 ; j ++ ) { if ( ( ( ( bytes [ i ] >> j ) & 1 ) == 1 ) ) { dgrs . add ( BigInteger . valueOf ( degree ) ) ; } degree ++ ; } } return new Polynomial ( dgrs ) ; }
tr	6	public static Object fromRDF ( Object input , Options options , RDFParser parser ) throws JSONLDProcessingError { if ( options . useRdfType == null ) { options . useRdfType = false ; } if ( options . useNativeTypes == null ) { options . useNativeTypes = true ; } final RDFDataset dataset = parser . parse ( input ) ; final Object rval = new JSONLDProcessor ( options ) . fromRDF ( dataset ) ; if ( options . outputForm != null ) { if ( "expanded" . equals ( options . outputForm ) ) { return rval ; } else if ( "compacted" . equals ( options . outputForm ) ) { return compact ( rval , dataset . getContext ( ) , options ) ; } else if ( "flattened" . equals ( options . outputForm ) ) { return flatten ( rval , dataset . getContext ( ) , options ) ; } else { throw new JSONLDProcessingError ( "Unknown value for output form" ) . setType ( Error . INVALID_INPUT ) . setDetail ( "outputForm" , options . outputForm ) ; } } return rval ; }
tr	9	public void convert ( IDChanger UI , HashMap < BlockUID , BlockUID > translations , PluginLoader pluginLoader ) { Status status = UI . status ; status . changedChest = 0 ; status . changedPlaced = 0 ; status . changedPlayer = 0 ; int count_file = 0 ; long beginTime = System . currentTimeMillis ( ) ; status . pb_file . setMaximum ( playerFiles . size ( ) - 1 ) ; ArrayList < ConverterPlugin > regionPlugins = pluginLoader . getPluginsOfType ( PluginType . REGION ) ; ArrayList < ConverterPlugin > playerPlugins = pluginLoader . getPluginsOfType ( PluginType . PLAYER ) ; for ( PlayerFile playerFile : playerFiles ) { status . pb_file . setValue ( count_file ++ ) ; status . lb_file . setText ( "Current File: " + playerFile . getName ( ) ) ; DataInputStream dis = null ; DataOutputStream dos = null ; try { dis = new DataInputStream ( new BufferedInputStream ( new GZIPInputStream ( new FileInputStream ( playerFile ) ) ) ) ; CompoundTag root = NbtIo . read ( dis ) ; for ( ConverterPlugin plugin : playerPlugins ) { plugin . convert ( status , root , translations ) ; } dos = new DataOutputStream ( new BufferedOutputStream ( new FileOutputStream ( playerFile ) ) ) ; NbtIo . writeCompressed ( root , dos ) ; } catch ( IOException e ) { logger . log ( Level . SEVERE , "Unable to convert player inventories" , e ) ; return ; } finally { if ( dos != null ) { try { dos . close ( ) ; } catch ( IOException e ) { logger . log ( Level . WARNING , "Unable to close output stream" , e ) ; } } if ( dis != null ) { try { dis . close ( ) ; } catch ( IOException e ) { logger . log ( Level . WARNING , "Unable to close input stream" , e ) ; } } } } count_file = 0 ; if ( regionFiles == null ) { return ; } status . pb_file . setValue ( 0 ) ; status . pb_file . setMaximum ( regionFiles . size ( ) - 1 ) ; for ( RegionFileExtended r : regionFiles ) { status . lb_file . setText ( "Current File: " + r . fileName . getName ( ) ) ; status . pb_file . setMaximum ( regionFiles . size ( ) - 1 ) ; status . pb_file . setValue ( count_file ++ ) ; try { r . convert ( status , translations , regionPlugins ) ; } catch ( IOException e ) { logger . log ( Level . SEVERE , "Unable to convert placed blocks" , e ) ; return ; } finally { if ( r != null ) { try { r . close ( ) ; } catch ( IOException e ) { logger . log ( Level . WARNING , "Unable to close region file" , e ) ; } } } } long duration = System . currentTimeMillis ( ) - beginTime ; JOptionPane . showMessageDialog ( UI , "Done in " + duration + "ms" + System . getProperty ( "line.separator" ) + status . changedPlaced + " placed blocks changed." + System . getProperty ( "line.separator" ) + status . changedPlayer + " blocks in player inventories changed." + System . getProperty ( "line.separator" ) + status . changedChest + " blocks in entity inventories changed." , "Information" , JOptionPane . INFORMATION_MESSAGE ) ; }
tr	1	public List < MessageVO > getMessageVOs ( ) { if ( messageVOs == null ) { messageVOs = new ArrayList < MessageVO > ( ) ; } return this . messageVOs ; }
tr	6	public String toNVPString ( String prefix ) throws UnsupportedEncodingException { StringBuilder sb = new StringBuilder ( ) ; if ( this . role != null ) { sb . append ( prefix ) . append ( "role=" ) . append ( this . role . getValue ( ) ) ; sb . append ( "&" ) ; } if ( this . name != null ) { String newPrefix = prefix + "name." ; sb . append ( this . name . toNVPString ( newPrefix ) ) ; } if ( this . fullLegalName != null ) { sb . append ( prefix ) . append ( "fullLegalName=" ) . append ( NVPUtil . encodeUrl ( this . fullLegalName ) ) ; sb . append ( "&" ) ; } if ( this . address != null ) { String newPrefix = prefix + "address." ; sb . append ( this . address . toNVPString ( newPrefix ) ) ; } if ( this . dateOfBirth != null ) { sb . append ( prefix ) . append ( "dateOfBirth=" ) . append ( NVPUtil . encodeUrl ( this . dateOfBirth ) ) ; sb . append ( "&" ) ; } if ( this . occupation != null ) { sb . append ( prefix ) . append ( "occupation=" ) . append ( NVPUtil . encodeUrl ( this . occupation ) ) ; sb . append ( "&" ) ; } return sb . toString ( ) ; }
tr	6	private void createUnits ( ) { ArrayList < Building > buildings = g . map . getPlayersBuildings ( this ) ; boolean hasMoney = true ; while ( hasMoney ) { for ( Building building : buildings ) { if ( building instanceof Factory ) { ( ( Factory ) building ) . recruitTank ( g . map , building . getCell ( ) , true ) ; } if ( building instanceof Barracks ) { ( ( Barracks ) building ) . recruitMarine ( g . map , building . getCell ( ) , true ) ; } } if ( buildings . contains ( Barracks . class ) ) { hasMoney = this . getMoney ( ) >= Marine . cost ; } else if ( buildings . contains ( Factory . class ) ) { hasMoney = this . getMoney ( ) >= Tank . cost ; } else { hasMoney = false ; } } }
tr	0	public String getciudad ( ) { return ciudad ; }
tr	9	private void distributePoints ( int mouseX , int mouseY ) { if ( pointsRequested && id != - 1 && requestedPointsLeft != - 1 ) { if ( requestedPointsLeft > 0 && id != - 2 ) { for ( int x = 0 ; x < windowslist . size ( ) ; x ++ ) { if ( windowslist . get ( x ) . getID ( ) == id ) { if ( Mouse . isButtonDown ( 0 ) ) { if ( windowslist . get ( x ) . getPoint ( mouseX , mouseY ) ) { requestedPointsLeft -- ; } } } } } else if ( requestedPointsLeft > 0 && id == - 2 ) { if ( Mouse . isButtonDown ( 0 ) ) { if ( activePane . getPoint ( mouseX , mouseY ) ) { requestedPointsLeft -- ; } } } else { id = - 1 ; pointsRequested = false ; requestedPointsLeft = - 1 ; } } }
tr	5	private void drawNode ( Node n , Graphics g , int x , int y ) { if ( n == null ) return ; g . setColor ( n . isRed ? Color . red : Color . GRAY ) ; if ( n . parent == null ) g . setColor ( Color . DARK_GRAY ) ; g . fillOval ( x , y * 64 , 32 , 32 ) ; g . setColor ( Color . BLACK ) ; if ( n . left != null ) g . drawLine ( x + 16 , y * 64 + 16 , x - 128 / y + 16 , ( y + 1 ) * 64 + 16 ) ; if ( n . right != null ) g . drawLine ( x + 16 , y * 64 + 16 , x + 128 / y + 16 , ( y + 1 ) * 64 + 16 ) ; g . setFont ( new Font ( "Serif" , Font . BOLD , 32 ) ) ; g . drawString ( n . key . toString ( ) , x , y * 64 ) ; drawNode ( n . left , g , x - 128 / y , y + 1 ) ; drawNode ( n . right , g , x + 128 / y , y + 1 ) ; }
tr	4	public static void run ( class < ? extends Window > clazz , class < ? > [ ] args , Object [ ] param ) { try { executeInstance ( ( Window ) clazz . getConstructor ( args ) . newInstance ( param ) ) ; } catch ( InstantiationException e ) { e . printStackTrace ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } }
tr	1	public void processPCM ( ByteData pcm ) { try { wav . writePCM ( pcm ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }
tr	1	public UserInfo byEmail ( String email ) { try { return users . byEmail ( email ) . getInfo ( ) ; } catch ( NoEmailException e ) { return null ; } }
tr	7	void removeDev ( DeviceImpl dev ) { synchronized ( devices ) { DeviceImpl d = devices [ dev . getAddress ( ) - 1 ] ; int i ; if ( d == null || d != dev ) return ; i = d . getAddress ( ) - 1 ; devices [ i ] = null ; if ( root == i ) { root = - 1 ; if ( Linux . trace ) System . err . println ( "bus root hub removed!" ) ; if ( Linux . debug ) { for ( i = 0 ; i < 127 ; i ++ ) { if ( devices [ i ] != null ) System . err . println ( "? addr " + ( i + 1 ) + " present with no root ?" ) ; } } } } }
tr	0	public NoSuchColumnException ( String message , Throwable cause ) { super ( message , cause ) ; }
tr	2	void InsertQuestions ( ) throws SQLException { Statement selectStmt = myConnection . createStatement ( ) ; ResultSet rs = selectStmt . executeQuery ( "select quesId from mcq order by quesId desc" ) ; if ( rs . next ( ) ) quesNo = Integer . parseInt ( rs . getString ( 1 ) ) ; quesNo ++ ; String textAreaContents = quesTextArea . getText ( ) ; int correctOption = comboCorrect . getSelectedIndex ( ) + 1 ; String query = "insert into mcq values ('" + textAreaContents + "' '" + opt1 . getText ( ) + "' '" + opt2 . getText ( ) + "' '" + opt3 . getText ( ) + "' '" + opt4 . getText ( ) + "' " + quesNo + " " + correctOption + ")" ; System . out . println ( query ) ; if ( selectStmt . executeUpdate ( query ) != 0 ) { System . out . println ( "Question Entered Successfully" ) ; } }
tr	3	public void run ( ) { try { InputStream inStream = client . getInputStream ( ) ; BufferedReader inputLine = new BufferedReader ( new InputStreamReader ( inStream ) ) ; while ( true ) { String stringFromClient = inputLine . readLine ( ) ; if ( stringFromClient . equals ( "exit" ) ) { break ; } } client . close ( ) ; VServerSide . numberOfOnline -- ; System . out . println ( "Now there are " + VServerSide . numberOfOnline + " clients online" ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }
tr	0	@ Test public void shouldChoosePresentTwoObtain200InPoints ( ) { player . chooseGift ( 2 ) ; assertThat ( player . getPoints ( ) , is ( 200 ) ) ; }
tr	2	public long getSetBits ( int player ) { assert ( player == 0 || player == 1 ) ; long result = 0 ; for ( int i = player ; i < 12 ; i += 2 ) { result |= piece_bb [ i ] ; } return result ; }
tr	1	public static RoleDAO getRoleDAO ( ) { if ( roleDAO == null ) { roleDAO = new RoleDAOImpl ( ) ; } return roleDAO ; }
tr	5	private String assemblaBufferCellaSingolaPerVistaLocale ( String buffer , Cella miaCella ) { Character tipoCella = miaCella . toString ( ) . toLowerCase ( ) . charAt ( 0 ) ; if ( tipoCella . equals ( t ) || tipoCella . equals ( a ) ) return aggiungiCellaSingolaSenzaInfoAddizionali ( buffer , tipoCella ) ; else if ( tipoCella . equals ( v ) || tipoCella . equals ( c ) ) return aggiungiCellaSingolaConInfoAddizionali ( buffer , tipoCella , miaCella . getValoreAttuale ( ) ) ; else if ( tipoCella . equals ( d ) ) return aggiungiCellaSingolaConInfoAddizionali ( buffer , tipoCella , miaCella . getIdDelDinosauro ( ) ) ; return null ; }
tr	1	public static boolean isInteger ( String s ) { try { Integer . parseInt ( s ) ; } catch ( NumberFormatException e ) { return false ; } return true ; }
tr	0	public static byte [ ] GenerateAuthenticatorServer ( int status , byte [ ] authenticatorClient , String sharekey ) throws NoSuchAlgorithmException { byte [ ] keybyte = sharekey . getBytes ( ) ; byte [ ] buf = new byte [ authenticatorClient . length + 4 + keybyte . length ] ; TypeConvert . int2byte ( status , buf , 0 ) ; System . arraycopy ( authenticatorClient , 0 , buf , 4 , authenticatorClient . length ) ; System . arraycopy ( keybyte , 0 , buf , 4 + authenticatorClient . length , keybyte . length ) ; return MD5 ( buf ) ; }
tr	4	protected void createBuffers ( SSLSession session ) { int appBufferMax = session . getApplicationBufferSize ( ) ; int netBufferMax = session . getPacketBufferSize ( ) ; if ( inData == null ) { inData = ByteBuffer . allocate ( appBufferMax ) ; outCrypt = ByteBuffer . allocate ( netBufferMax ) ; inCrypt = ByteBuffer . allocate ( netBufferMax ) ; } else { if ( inData . capacity ( ) != appBufferMax ) inData = ByteBuffer . allocate ( appBufferMax ) ; if ( outCrypt . capacity ( ) != netBufferMax ) outCrypt = ByteBuffer . allocate ( netBufferMax ) ; if ( inCrypt . capacity ( ) != netBufferMax ) inCrypt = ByteBuffer . allocate ( netBufferMax ) ; } inData . rewind ( ) ; inData . flip ( ) ; inCrypt . rewind ( ) ; inCrypt . flip ( ) ; outCrypt . rewind ( ) ; outCrypt . flip ( ) ; bufferallocations ++ ; }
tr	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( FramePrincipal . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( FramePrincipal . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( FramePrincipal . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( FramePrincipal . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { new FramePrincipal ( ) . setVisible ( true ) ; } } ) ; }
tr	8	private boolean r_postlude ( ) { int among_var ; int v_1 ; replab0 : while ( true ) { v_1 = cursor ; lab1 : do { bra = cursor ; among_var = find_among ( a_1 , 3 ) ; if ( among_var == 0 ) { break lab1 ; } ket = cursor ; switch ( among_var ) { case 0 : break lab1 ; case 1 : slice_from ( "i" ) ; break ; case 2 : slice_from ( "u" ) ; break ; case 3 : if ( cursor >= limit ) { break lab1 ; } cursor ++ ; break ; } continue replab0 ; } while ( false ) ; cursor = v_1 ; break replab0 ; } return true ; }
tr	8	public void start ( ) { if ( this . isRunning || this . simulationResult != null ) { return ; } this . latch = new CountDownLatch ( this . nrOfWorkers ) ; int roundsPerWorker = getNrOfRoundsPerWorker ( this . nrOfWorkers ) ; this . executor = Executors . newFixedThreadPool ( this . nrOfWorkers ) ; int workerUpdateInterval = getUpdateInterval ( this . nrOfWorkers ) ; for ( int i = 0 ; i < this . nrOfWorkers ; i ++ ) { SimulationWorker worker ; WorkerBuilder builder ; if ( this . gameType == PokerType . TEXAS_HOLDEM ) { builder = TexasHoldemWorker . builder ( ) ; } else if ( this . gameType == PokerType . OMAHA ) { builder = OmahaWorker . builder ( ) ; } else if ( this . gameType == PokerType . OMAHA_HILO ) { builder = OmahaHiLoWorker . builder ( ) ; } else if ( this . gameType == PokerType . FOMAHA ) { builder = FiveCardOmahaWorker . builder ( ) ; } else { builder = FiveCardOmahaHiLoWorker . builder ( ) ; } builder . setCommunityCards ( this . communityCards ) . setNotifier ( this ) . setRounds ( roundsPerWorker ) . setUpdateInterval ( workerUpdateInterval ) ; for ( PlayerProfile profile : this . profiles ) { builder . addPlayer ( profile ) ; } worker = builder . build ( ) ; this . executor . execute ( worker ) ; this . workers . add ( worker ) ; } this . startTime = System . currentTimeMillis ( ) ; this . isRunning = true ; Thread masterThread = new Thread ( new Supervisor ( ) ) ; masterThread . setDaemon ( true ) ; masterThread . start ( ) ; SimulationEvent event = new SimulationEvent ( SimulationEvent . EVENT_SIM_STARTED , this . nrOfWorkers ) ; this . notifiable . onSimulationStart ( event ) ; }
tr	3	private void reverseGraph ( ) { for ( int i = 0 ; i < n ; i ++ ) { graphT . add ( new ArrayList < Integer > ( ) ) ; } for ( int i = 0 ; i < n ; i ++ ) { ArrayList < Integer > list = graph . get ( i ) ; for ( int j = 0 ; j < list . size ( ) ; j ++ ) { int vertex = list . get ( j ) ; graphT . get ( vertex ) . add ( i ) ; } } }
tr	5	public static String parseAndRep ( String [ ] args ) { if ( args . length != 2 ) { return "Error: insufficient arguments" ; } try { int rep = Integer . parseInt ( args [ 1 ] ) ; if ( rep < 1 ) { return "Error: second argument is not a positive integer" ; } String repeated = "" ; for ( int i = 0 ; i < rep ; i ++ ) { if ( i == rep - 1 ) { repeated += args [ 0 ] ; } else { repeated += ( args [ 0 ] + " " ) ; } } return repeated ; } catch ( NumberFormatException error ) { return "Error: second argument is not a positive integer" ; } }
tr	1	private JTextField getIterationsTxt ( ) { if ( iterationsTxt == null ) { iterationsTxt = new JTextField ( ) ; iterationsTxt . setText ( "500" ) ; iterationsTxt . setBounds ( 167 , 66 , 90 , 22 ) ; iterationsTxt . setEditable ( false ) ; iterationsTxt . setEnabled ( false ) ; } return iterationsTxt ; }
tr	9	protected void serialize_primitive ( Object obj , PrintWriter p , int level ) { if ( obj instanceof boolean || obj . getClass ( ) == boolean . TYPE ) { p . print ( obj . equals ( boolean . true ) ? "True" : "False" ) ; } else if ( obj instanceof float || obj . getClass ( ) == float . TYPE ) { float f = ( float ) obj ; serialize_primitive ( f . doubleValue ( ) , p , level ) ; } else if ( obj instanceof double || obj . getClass ( ) == double . TYPE ) { double d = ( double ) obj ; if ( d . isInfinite ( ) ) { if ( d > 0.0 ) { p . print ( "1e30000" ) ; } else { p . print ( "-1e30000" ) ; } } else if ( d . isNaN ( ) ) { p . print ( "{'__class__':'float' 'value':'nan'}" ) ; } else { p . print ( d ) ; } } else { p . print ( obj ) ; } }
tr	4	@ Override public < T extends AggregateRoot < ? >> T loadOneBy ( final class < T > aggregateRoot , final Specification < T > specification ) { @ SuppressWarnings ( "unchecked" ) final DomainRepositoryDriver < T , ? > driver = ( DomainRepositoryDriver < T , ? > ) drivers . get ( aggregateRoot ) ; if ( driver == null ) { throw new RuntimeException ( "Can't find any driver for the given aggregate: " + aggregateRoot ) ; } return driver . loadOneBySpecification ( specification ) ; }
tr	0	public TextOutputPanelObservable ( ) { this . addObserver ( TextOutputPanel . getTextOutputPanel ( ) ) ; }
tr	2	public void addPrefix ( String s ) { if ( prefix != null ) { this . prefix = s + this . prefix ; } else { for ( HuffmanNode n : children ) { n . addPrefix ( s ) ; } } }
tr	5	@ Override public void mousePressed ( MouseEvent me ) { int w = gridRenderer . getWidth ( ) / gridColumns ; int col = me . getX ( ) / w ; int h = gridRenderer . getHeight ( ) / gridRows ; int row = me . getY ( ) / h ; int value = grid [ col ] [ row ] ; if ( me . getButton ( ) == MouseEvent . BUTTON1 ) { if ( tilesRemaining > 0 ) { value ++ ; tilesRemaining -- ; } if ( tilesRemaining == 0 ) { saveAsButton . setEnabled ( true ) ; } } else if ( me . getButton ( ) == MouseEvent . BUTTON3 ) { if ( value > 0 ) { value -- ; tilesRemaining ++ ; saveAsButton . setEnabled ( false ) ; } } grid [ col ] [ row ] = value ; updateTilesRemainingLabel ( ) ; gridRenderer . repaint ( ) ; }
tr	7	static boolean authenticate ( String username , String hashString , PassthroughConnection ptc ) { try { String encodedUsername = URLEncoder . encode ( username , "UTF-8" ) ; String encodedHashString = URLEncoder . encode ( hashString , "UTF-8" ) ; String authURLString = new String ( "http://www.minecraft.net/game/checkserver.jsp?user=" + encodedUsername + "&serverId=" + encodedHashString ) ; if ( ! Globals . isQuiet ( ) ) { ptc . printLogMessage ( "Authing with " + authURLString ) ; } URL minecraft = new URL ( authURLString ) ; URLConnection minecraftConnection = minecraft . openConnection ( ) ; BufferedReader in = new BufferedReader ( new InputStreamReader ( minecraftConnection . getInputStream ( ) ) ) ; String reply = in . readLine ( ) ; if ( Globals . isInfo ( ) ) { ptc . printLogMessage ( "Server Response: " + reply ) ; } in . close ( ) ; if ( reply != null && reply . equals ( "YES" ) ) { if ( ! Globals . isQuiet ( ) ) { ptc . printLogMessage ( "Auth successful" ) ; } return true ; } } catch ( MalformedURLException mue ) { ptc . printLogMessage ( "Auth URL error" ) ; } catch ( IOException ioe ) { ptc . printLogMessage ( "Problem connecting to auth server" ) ; } return false ; }
tr	2	public ArrayList < Identifier > getFreeBeds ( Identifier hostelId , Date checkIn , Date checkOut ) throws DataBaseReadWriteException , IdentifierNotFoundException , InvalidIdentifierException , InvalidParameterException { ArrayList < Identifier > freeBedIds = new ArrayList < Identifier > ( ) ; Hostel hostelInfo = Hostels . getInstance ( ) . get ( hostelId ) ; Iterator < Identifier > bedItr = hostelInfo . getBeds ( ) . iterator ( ) ; while ( bedItr . hasNext ( ) ) { Identifier bedId = bedItr . next ( ) ; if ( Beds . getInstance ( ) . isBedAvailable ( bedId , checkIn , checkOut , false ) ) { freeBedIds . add ( bedId ) ; } } return freeBedIds ; }
tr	3	public int getPieceCount ( DraughtsState gs ) { int [ ] pieces = gs . getPieces ( ) ; int count = 0 ; for ( int f = 1 ; f < pieces . length ; f = f + 1 ) { int piece = pieces [ f ] ; if ( Draughts . isWhite ( piece ) || Draughts . isBlack ( piece ) ) { count ++ ; } } return count ; }
tr	0	public SocketNaoConectado ( String string ) { super ( string ) ; }
tr	8	public static void main ( String [ ] args ) { BufferedReader reader = new BufferedReader ( new InputStreamReader ( System . in ) ) ; ArrayList < Integer > datos = new ArrayList < Integer > ( 100 ) ; int mayor = 0 ; System . out . println ( "Introduzca hasta 100 n\u00FAmeros ('q' para salir):" ) ; boolean fin = false ; while ( datos . size ( ) < 100 && ! fin ) { System . out . print ( ( datos . size ( ) + 1 ) + ": " ) ; String entrada = null ; try { entrada = reader . readLine ( ) ; } catch ( IOException ex ) { entrada = "q" ; } if ( entrada . equals ( "q" ) ) { fin = true ; } else { try { int num = Integer . parseInt ( entrada ) ; datos . add ( num ) ; if ( datos . size ( ) == 1 || num > mayor ) mayor = num ; } catch ( NumberFormatException ex ) { } } } System . out . println ( ) ; if ( datos . size ( ) == 0 ) System . out . println ( "\u00A1No ha introducido ning\u00FAn n\u00FAmero!" ) ; else System . out . println ( "El n\u00FAmero mayor es: " + mayor ) ; }
tr	4	@ Override public boolean equals ( Object obj ) { if ( obj == null || ! ( obj instanceof Counter ) ) return false ; Counter < ? > c = ( Counter < ? > ) obj ; return _counts . equals ( c . _counts ) ; }
tr	9	public static LinkedList < String > generateAttackPlans ( AttackModel attack_model ) throws IOException , ScriptException { String attack_file = InfoEnum . current_directory + "/dlv/attack/attack_model.dl" ; Inference . writeFile ( attack_file , attack_model . generateFormalExpression ( InfoEnum . ALL_MODELS ) , false ) ; for ( Element e : attack_model . getElements ( ) ) { RequirementElement re = ( RequirementElement ) e ; if ( re . getType ( ) . equals ( InfoEnum . RequirementElementType . NEW_ANTI_GOAL . name ( ) ) ) { if ( re . getOutLinks ( ) . size ( ) == 0 ) { Inference . writeFile ( attack_file , "satisfied(" + re . getId ( ) + ")." , true ) ; break ; } } } String dlv_command = InfoEnum . current_directory + "/dlv/dlv -silent -nofacts " + InfoEnum . current_directory + "/dlv/attack/find_alternative_attacks.rule " + attack_file ; Runtime rt = Runtime . getRuntime ( ) ; Process pr = rt . exec ( dlv_command ) ; BufferedReader input = new BufferedReader ( new InputStreamReader ( pr . getInputStream ( ) ) ) ; String line = null ; LinkedList < LinkedList < String >> all_alternatives = new LinkedList < LinkedList < String >> ( ) ; LinkedList < String > alternative_description = new LinkedList < String > ( ) ; while ( ( line = input . readLine ( ) ) != null ) { LinkedList < String > one_alternative = new LinkedList < String > ( ) ; line = line . substring ( 1 , line . length ( ) - 1 ) ; String [ ] result = line . split ( "  " ) ; boolean validity = false ; for ( String s : result ) { if ( s . startsWith ( "result" ) ) { String id = s . substring ( s . indexOf ( "(" ) + 1 , s . indexOf ( " " ) ) ; String target = s . substring ( s . indexOf ( " " ) + 1 , s . indexOf ( ")" ) ) . replace ( "_" , " " ) ; Element node = attack_model . findElementById ( id ) ; if ( node != null ) { if ( node . getType ( ) . equals ( InfoEnum . RequirementElementType . TASK . name ( ) ) ) { one_alternative . add ( "perform " + node . getName ( ) + " to " + target ) ; validity = true ; } } else { System . out . println ( "result elements cannot be found." ) ; } } else if ( s . startsWith ( "unachievable" ) ) { validity = false ; break ; } } if ( validity ) { all_alternatives . add ( one_alternative ) ; } } int number = 0 ; for ( LinkedList < String > list : all_alternatives ) { number ++ ; String temp = "Attack alterntive " + number + "(" + list . size ( ) + " attack)" + ":{" ; String attacks = "" ; for ( String attack : list ) { attacks += attack + "  " ; } temp += attacks . substring ( 0 , attacks . length ( ) - 2 ) ; temp += "}" ; alternative_description . add ( temp ) ; } return alternative_description ; }
tr	7	public void act ( List < Actor > newActor ) { refresh ++ ; if ( refresh < 20 ) return ; refresh = 0 ; int modifier = maximumGrass - ( countRabbits ( ) / dependencies ) ; modifier = ( modifier < minimumGrass ) ? minimumGrass : modifier ; if ( amountGrass < modifier || ( countRabbits ( ) < 1000 && amountGrass < maximumGrass ) || amountGrass < minimumGrass ) { Location l = field . freeAdjacentLocation ( location ) ; if ( l != null ) { newActor . add ( new Grass ( field , l ) ) ; increase ( ) ; } } else { reduce ( ) ; this . isActive ( false ) ; } }
tr	5	static synchronized void setFilename ( String filename ) { if ( writer != null ) { try { writer . close ( ) ; writer = null ; } catch ( IOException e ) { System . out . println ( "Unable to close log file" ) ; } } if ( filename == null ) { writer = null ; return ; } FileWriter out = null ; try { out = new FileWriter ( filename ) ; } catch ( IOException e ) { System . out . println ( "Unable to open log file: " + filename ) ; writer = null ; return ; } if ( out != null ) { writer = new BufferedWriter ( out ) ; } }
tr	4	public void loadAbrev ( final MyDatabase mysql ) { String SQL1 = "SELECT abrev FROM sig_professorat where idSGD='" + this . idProfesor + "' " ; try { Statement st = mysql . createStatement ( ) ; ResultSet rs1 = mysql . getResultSet ( SQL1 , st ) ; while ( rs1 != null && rs1 . next ( ) ) { this . abrev = rs1 . getString ( "abrev" ) ; } if ( rs1 != null ) { rs1 . close ( ) ; st . close ( ) ; } } catch ( SQLException ex ) { Logger . getLogger ( Profesores . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } }
tr	5	public static void main ( String [ ] args ) { RedBlackTree < Integer > t = new RedBlackTree < > ( ) ; final int NUMS = 400000 ; final int GAP = 35461 ; System . out . println ( "Checking... (no more output means success)" ) ; for ( int i = GAP ; i != 0 ; i = ( i + GAP ) % NUMS ) t . insert ( i ) ; if ( t . findMin ( ) != 1 || t . findMax ( ) != NUMS - 1 ) System . out . println ( "FindMin or FindMax error!" ) ; for ( int i = 1 ; i < NUMS ; i ++ ) if ( ! t . contains ( i ) ) System . out . println ( "Find error1!" ) ; }
tr	7	public static char [ ] [ ] build_trans_block ( int [ ] key_num , String key ) { int col = key_num . length ; int row = 26 / col ; if ( row * col != 26 ) { row += 1 ; } char [ ] [ ] result = new char [ row ] [ col ] ; boolean [ ] filled = new boolean [ 26 ] ; int cur_row = 0 ; int cur_col = 0 ; for ( int i = 0 ; i < key . length ( ) ; i ++ ) { char cur_c = key . toUpperCase ( ) . charAt ( i ) ; int pos = cur_c - A ; if ( filled [ pos ] ) continue ; result [ cur_row ] [ cur_col ] = cur_c ; filled [ pos ] = true ; if ( cur_col == col - 1 ) { cur_row ++ ; cur_col = 0 ; } else { cur_col ++ ; } } for ( int i = 0 ; i < 26 ; i ++ ) { if ( ! filled [ i ] ) { result [ cur_row ] [ cur_col ] = ( char ) ( A + i ) ; filled [ i ] = true ; if ( cur_col == col - 1 ) { cur_col = 0 ; cur_row ++ ; } else { cur_col ++ ; } } } return result ; }
tr	4	@ Override public final Move call ( ) { Move move = this . getMove ( ) ; boolean promotion = move . promotesPiece ( ) ; if ( ! promotion && game . canDeclareStalemate ( ) && checkStalemate ( ) ) game . declareStalemate ( ) ; this . game . executeMove ( move ) ; if ( promotion ) game . promote ( getPromotion ( ) ) ; return move ; }
tr	6	@ Override public void run ( ) { if ( i_nbDifferentCalcWay > 0 ) { while ( listWayToBrowse . size ( ) > 0 && ( listWayWithPointStop . size ( ) > 0 || listWayToBrowse . size ( ) < i_nbDifferentCalcWay ) ) { findNextPoint ( ) ; } if ( listWayToBrowse . size ( ) == 0 ) { threadManager . setHasTerminatedFirstThread ( true ) ; } } else { while ( listWayToBrowse . size ( ) > 0 ) { findNextPoint ( ) ; } } threadManager . addListWayPointStop ( listWayWithPointStop ) ; }
tr	2	private void select ( String s ) { int index = Integer . parseInt ( s ) ; for ( RenderableObject o : ( ( MainFrame ) frame ) . getObjects ( ) ) { if ( o . getID ( ) == index ) { selectItem ( index ) ; } } clearIdentities ( ) ; }
tr	3	@ Override public void keyPressed ( KeyEvent e ) { int code = e . getKeyCode ( ) ; if ( acceptNewShortcut ) { currentShortcutLength = 0 ; Arrays . fill ( this . currentShortcut , 0 ) ; } if ( ! isDelete ( code ) ) { acceptNewShortcut = false ; if ( ArrayUtil . indexOf ( code , currentShortcut ) >= 0 ) { return ; } currentShortcut [ currentShortcutLength ] = code ; currentShortcutLength ++ ; } setShortcutText ( ) ; }
tr	4	protected String getPresentationName ( ) { if ( countDifferences ( oldValue , newValue ) == 1 ) { for ( Features feature : Features . values ( ) ) { if ( feature . isChosen ( oldValue ) != feature . isChosen ( newValue ) ) { if ( feature . isChosen ( newValue ) ) { return "set cell " + feature . toString ( ) ; } else { return "unset cell " + feature . toString ( ) ; } } } } return "change cell features" ; }
tr	8	public void placeElement ( Element toAdd ) { Vec v = toAdd . getPosition ( ) ; double xloc = Math . round ( ( v . x / 10 ) ) * 10 ; double yloc = Math . round ( v . y / 10 ) * 10 ; toAdd . setPosition ( new Vec ( xloc , yloc ) ) ; boolean validLocation = true ; synchronized ( sim . elements ) { for ( Element e : sim . elements ) if ( ( e instanceof Prey || e instanceof Predator ) && e . getPosition ( ) . equals ( new Vec ( xloc , yloc ) ) ) validLocation = false ; } if ( validLocation ) { sim . elements . add ( toAdd ) ; if ( toAdd instanceof Waypoint ) { if ( previousWaypoint != null && previousWaypoint . getTarget ( ) == null ) previousWaypoint . setTarget ( ( Waypoint ) toAdd ) ; previousWaypoint = toAdd ; } } canv . repaint ( ) ; }
tr	3	public static JSONObject toJSONObject ( java . util . Properties properties ) throws JSONException { JSONObject jo = new JSONObject ( ) ; if ( properties != null && ! properties . isEmpty ( ) ) { Enumeration enumProperties = properties . propertyNames ( ) ; while ( enumProperties . hasMoreElements ( ) ) { String name = ( String ) enumProperties . nextElement ( ) ; jo . put ( name , properties . getProperty ( name ) ) ; } } return jo ; }
tr	7	private static boolean KawigiEdit_RunTest ( int testNum , String [ ] p0 , boolean hasAnswer , int p1 ) { System . out . print ( "Test " + testNum + ": [" + "{" ) ; for ( int i = 0 ; p0 . length > i ; ++ i ) { if ( i > 0 ) { System . out . print ( " " ) ; } System . out . print ( "\"" + p0 [ i ] + "\"" ) ; } System . out . print ( "}" ) ; System . out . println ( "]" ) ; FoxAndWord obj ; int answer ; obj = new FoxAndWord ( ) ; long startTime = System . currentTimeMillis ( ) ; answer = obj . howManyPairs ( p0 ) ; long endTime = System . currentTimeMillis ( ) ; boolean res ; res = true ; System . out . println ( "Time: " + ( endTime - startTime ) / 1000.0 + " seconds" ) ; if ( hasAnswer ) { System . out . println ( "Desired answer:" ) ; System . out . println ( "\t" + p1 ) ; } System . out . println ( "Your answer:" ) ; System . out . println ( "\t" + answer ) ; if ( hasAnswer ) { res = answer == p1 ; } if ( ! res ) { System . out . println ( "DOESN'T MATCH!!!!" ) ; } else if ( ( endTime - startTime ) / 1000.0 >= 2 ) { System . out . println ( "FAIL the timeout" ) ; res = false ; } else if ( hasAnswer ) { System . out . println ( "Match :-)" ) ; } else { System . out . println ( "OK  but is it right?" ) ; } System . out . println ( "" ) ; return res ; }
tr	5	public Node b2dllUtil ( Node root ) { if ( root == null ) return root ; if ( root . left != null ) { Node left = b2dllUtil ( root . left ) ; for ( ; left . right != null ; left = left . right ) ; left . right = root ; root . left = left ; } if ( root . right != null ) { Node right = b2dllUtil ( root . right ) ; for ( ; right . left != null ; right = right . left ) ; right . left = root ; root . right = right ; } return root ; }
tr	4	private void doActions ( Action [ ] actions , int startIndex , int endIndex , boolean wait , boolean draw ) { for ( int x = startIndex ; x < endIndex ; ++ x ) { if ( wait ) { try { Thread . sleep ( 1000 ) ; } catch ( InterruptedException e ) { } } actions [ x ] . doAction ( currentGame ) ; if ( draw ) { shared . updateSharedPanel ( ) ; players . updatePlayerPanel ( currentGame . getPlayerIndex ( ) ) ; } else { board . setRedraw ( false ) ; } board . updateBoardPanel ( actions [ x ] , currentGame ) ; board . setRedraw ( true ) ; } }
tr	7	static boolean isProxy ( class < ? > clazz ) { if ( NOT_PROXY . contains ( clazz ) ) { return false ; } for ( Method m : PROXY_TESTERS ) { try { if ( ( boolean ) m . invoke ( null , clazz ) ) { return true ; } } catch ( Exception e ) { } } if ( SPRING_PROXY != null && SPRING_PROXY . isAssignableFrom ( clazz ) ) { return true ; } NOT_PROXY . add ( clazz ) ; return false ; }
tr	2	@ Override public boolean addEntity ( int level , Entity < ? extends Engine > entity ) { if ( entity != null ) { addRenderable ( level , entity ) ; addLogicable ( entity ) ; entity . setStage ( this ) ; return true ; } return false ; }
tr	2	public static Connection getSimpleConnection ( ) { String DB_CONN_STRING = "jdbc:mysql://ichhd.dyndns.org:3309/tikTakToe" ; String DRIVER_CLASS_NAME = "com.mysql.jdbc.Driver" ; String USER_NAME = "subhash" ; String PASSWORD = "subhash" ; Connection result = null ; try { class . forName ( DRIVER_CLASS_NAME ) . newInstance ( ) ; } catch ( Exception ex ) { log ( "Check classpath. Cannot load db driver: " + DRIVER_CLASS_NAME ) ; } try { result = DriverManager . getConnection ( DB_CONN_STRING , USER_NAME , PASSWORD ) ; } catch ( SQLException e ) { log ( "Driver loaded  but cannot connect to db: " + DB_CONN_STRING ) ; } return result ; }
tr	8	public void Solve ( ) { List < Integer > primes = Euler . GetPrimes ( _max ) ; for ( Iterator < Integer > it = primes . iterator ( ) ; it . hasNext ( ) ; ) { Integer prime = it . next ( ) ; String primeString = prime . toString ( ) ; for ( int numberOfDigits = 1 ; numberOfDigits < primeString . length ( ) ; numberOfDigits ++ ) { List < String > enumeration = Enumerate ( primeString , "" , 0 , numberOfDigits ) ; for ( Iterator < String > it1 = enumeration . iterator ( ) ; it1 . hasNext ( ) ; ) { String candidate = it1 . next ( ) ; String output = "" ; int primeCount = 0 ; for ( int digit = 0 ; digit < 10 ; digit ++ ) { if ( candidate . startsWith ( "x" ) && digit == 0 ) { continue ; } int primeCandidate = Integer . parseInt ( candidate . replaceAll ( "x" , Integer . toString ( digit ) ) ) ; if ( 0 <= Collections . binarySearch ( primes , primeCandidate ) ) { primeCount ++ ; output += primeCandidate + "  " ; } } if ( primeCount == _familyCount ) { System . out . println ( "Result=" + output ) ; return ; } } } } }
tr	9	public static Object [ ] commandsForAgentAndBoxToField ( Level l , Agent agent , Box box , Field agentFromField , ArrayList < Node > nodesAgentCanEndIn , Field boxToField , ArrayList < Box > boxesToIgnore , DockTask taskDock ) { if ( boxesToIgnore == null ) { boxesToIgnore = new ArrayList < Box > ( ) ; boxesToIgnore . add ( box ) ; } ArrayList < Field > pathToGuideBoxAlong = new ArrayList < Field > ( taskDock . path ) ; Collections . reverse ( pathToGuideBoxAlong ) ; Field boxFromField = box . atField ; dir boxDir = null ; GoalSequenceNode root = new GoalSequenceNode ( boxFromField , agentFromField , null ) ; root . g = 0 ; root . w = 0 ; root . h = pathToGuideBoxAlong . size ( ) - 1 ; root . f = root . g + root . w + root . h ; Queue < GoalSequenceNode > queue = new PriorityQueue < GoalSequenceNode > ( ) ; HashMap < Field , ArrayList < Field >> closedSet = new HashMap < Field , ArrayList < Field >> ( ) ; ArrayList < Field > tempList = new ArrayList < Field > ( ) ; tempList . add ( boxFromField ) ; closedSet . put ( agentFromField , tempList ) ; queue . add ( root ) ; GoalSequenceNode currentNode = queue . poll ( ) ; while ( currentNode != null ) { if ( currentNode . boxLocation == boxToField ) { if ( nodesAgentCanEndIn == null || nodesAgentCanEndIn . contains ( currentNode . agentLocation ) ) { break ; } } boxDir = Agent . getBoxDirection ( currentNode . agentLocation , currentNode . boxLocation ) ; ArrayList < Command > possibleBoxCommands = possibleBoxCommandsForDirection ( boxDir , currentNode . agentLocation , currentNode . boxLocation , boxesToIgnore ) ; for ( Command command : possibleBoxCommands ) { Field boxLocation = null ; Field agentLocation = null ; if ( command . cmd . equals ( "Push" ) ) { agentLocation = currentNode . boxLocation ; boxLocation = currentNode . boxLocation . neighbors [ command . dir2 . ordinal ( ) ] ; } else { boxLocation = currentNode . agentLocation ; agentLocation = currentNode . agentLocation . neighbors [ command . dir1 . ordinal ( ) ] ; } if ( closedSet . containsKey ( agentLocation ) ) { if ( closedSet . get ( agentLocation ) . contains ( boxLocation ) ) { continue ; } else { closedSet . get ( agentLocation ) . add ( boxLocation ) ; } } else { ArrayList < Field > tempListe = new ArrayList < Field > ( ) ; tempListe . add ( boxLocation ) ; closedSet . put ( agentLocation , tempListe ) ; } GoalSequenceNode node = new GoalSequenceNode ( boxLocation , agentLocation , command ) ; node . parent = currentNode ; node . g = node . parent . g + 1 ; node . w = ( command . weight ) ? 15 : 0 ; if ( node . parent . h - 1 >= 0 && pathToGuideBoxAlong . get ( node . parent . h - 1 ) == node . boxLocation ) { node . h = node . parent . h - 1 ; } else { node . h = node . parent . h ; } node . f = node . g + node . w + node . h ; queue . add ( node ) ; } if ( queue . isEmpty ( ) ) { System . err . println ( "CRY" ) ; return null ; } currentNode = queue . poll ( ) ; } Field agentMoveTo = currentNode . agentLocation ; LinkedList < Command > commands = new LinkedList < Command > ( ) ; LinkedList < Field > fieldsUsed = new LinkedList < Field > ( ) ; while ( currentNode . parent != null ) { commands . add ( currentNode . action ) ; fieldsUsed . add ( currentNode . agentLocation ) ; fieldsUsed . add ( currentNode . boxLocation ) ; currentNode = currentNode . parent ; } Collections . reverse ( commands ) ; Collections . reverse ( fieldsUsed ) ; LinkedHashSet < Field > fieldsUsedSet = new LinkedHashSet < Field > ( fieldsUsed ) ; ArrayList < Field > fieldsUsedList = new ArrayList < Field > ( fieldsUsedSet ) ; return new Object [ ] { commands , fieldsUsedList , agentMoveTo } ; }
tr	4	public boolean equals ( Object o ) { if ( o == null ) return false ; if ( o == this ) return true ; if ( o instanceof ASPathLimit ) { ASPathLimit a = ( ASPathLimit ) o ; return this . limit == a . limit && this . origAS . equals ( a . origAS ) ; } return false ; }
tr	7	public void updateDepSpan ( int m , int oldH , int newH , int [ ] heads ) { if ( oldH == newH ) return ; int tmpH = newH ; while ( tmpH != - 1 ) { left [ tmpH ] = Math . min ( left [ tmpH ] , left [ m ] ) ; right [ tmpH ] = Math . max ( right [ tmpH ] , right [ m ] ) ; tmpH = heads [ tmpH ] ; } tmpH = oldH ; while ( tmpH != - 1 ) { if ( left [ tmpH ] == left [ m ] ) { left [ tmpH ] = tmpH ; int start = startIndex ( tmpH ) ; int end = endIndex ( tmpH ) ; for ( int i = start ; i < end ; ++ i ) left [ tmpH ] = Math . min ( left [ tmpH ] , left [ edges [ i ] ] ) ; } if ( right [ tmpH ] == right [ m ] ) { right [ tmpH ] = tmpH + 1 ; int start = startIndex ( tmpH ) ; int end = endIndex ( tmpH ) ; for ( int i = start ; i < end ; ++ i ) right [ tmpH ] = Math . max ( right [ tmpH ] , right [ edges [ i ] ] ) ; } tmpH = heads [ tmpH ] ; } }
tr	4	@ Override public Node compile ( ) { boolean fc = first instanceof Comment ; boolean sc = second instanceof Comment ; if ( fc && sc ) return new Comment ( "Cannot compile this." ) ; if ( fc ) return second . compile ( ) ; if ( sc ) return first . compile ( ) ; return new Block ( first . compile ( ) , second . compile ( ) ) ; }
tr	5	private final ImmutableSet < ChessMovement > getPossibleMovements ( final ChessBoard board , final ChessColor turn ) { final ImmutableSet . Builder < ChessMovement > moves = ImmutableSet . builder ( ) ; for ( final ChessPiece piece : board . getAllPieces ( ) ) { if ( ! currentTurn . equals ( piece . getColor ( ) ) ) continue ; final Position from = board . getPositionFor ( piece ) ; if ( piece instanceof ChessBishop ) { for ( final Position to : ( ( ChessBishop ) piece ) . getMiniMoves ( board ) ) { moves . add ( checkMovement ( from , to ) ) ; } } else { for ( final Position to : piece . getStandardMoves ( board ) ) { moves . add ( checkMovement ( from , to ) ) ; } } } return moves . build ( ) ; }
