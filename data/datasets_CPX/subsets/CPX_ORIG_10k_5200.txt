tr	1	public static boolean downloadReqFiles ( String folder , String address ) { try { URL url = new URL ( address ) ; File out = new File ( folder + "\\temp.zip" ) ; Downloader . downloadFile ( url , out , System . out ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; return false ; } return true ; }
tr	7	public void keyPressed ( KeyEvent keyEvent ) { Iterator < PComponent > it = components . iterator ( ) ; while ( it . hasNext ( ) ) { PComponent comp = it . next ( ) ; if ( shouldHandleKeys ) { if ( comp . shouldHandleKeys ( ) ) comp . keyPressed ( keyEvent ) ; } else { if ( comp instanceof PFrame ) { for ( PComponent component : ( ( PFrame ) comp ) . getComponents ( ) ) if ( component . forceKeys ( ) ) component . keyPressed ( keyEvent ) ; } else if ( comp . forceKeys ( ) ) comp . keyPressed ( keyEvent ) ; } } }
tr	1	public void saveProperties ( ) { File propertiesFile = new File ( this . pathToJar + File . separatorChar + CONFIG_NAME ) ; try { try ( FileOutputStream propertiesOut = new FileOutputStream ( propertiesFile ) ) { properties . store ( propertiesOut , null ) ; } } catch ( IOException e ) { e . printStackTrace ( ) ; } }
tr	1	public static RepositoryContato getInstance ( ) { if ( instance == null ) { instance = new RepositoryContato ( ) ; } return instance ; }
tr	4	private void initTextArea ( ) { List < float > times = this . gradientFunction . getLcTimes ( ) ; List < float > bs = this . gradientFunction . getPercB ( ) ; List < String > text = new ArrayList < String > ( ) ; String newline = System . getProperty ( "line.separator" ) ; char [ ] chars = new char [ this . decimals ] ; Arrays . fill ( chars , 0 ) ; DecimalFormat df = new DecimalFormat ( "#." + new String ( chars ) ) ; char [ ] charsTime = new char [ this . nTimeDecimals ] ; Arrays . fill ( charsTime , 0 ) ; DecimalFormat dfTime = new DecimalFormat ( "#." + new String ( charsTime ) ) ; float tmp ; String line ; String b , prevB = "" ; this . optBs . clear ( ) ; this . optRTs . clear ( ) ; if ( times . size ( ) != bs . size ( ) ) { text . add ( "Error when calculating the optimzed gradient." ) ; } else { text . add ( "Time(LC-time)\t%B" + newline ) ; for ( int i = 0 ; i < times . size ( ) ; ++ i ) { b = df . format ( bs . get ( i ) ) ; if ( this . decimals == 0 ) { b = "" + Math . round ( bs . get ( i ) ) ; } if ( ! b . equals ( prevB ) ) { tmp = times . get ( i ) ; line = this . textBeforeTime + dfTime . format ( tmp ) + this . separator + b + this . textAfterB + newline ; this . optBs . add ( float . parseFloat ( b ) ) ; this . optRTs . add ( tmp ) ; text . add ( line ) ; } prevB = b ; } } this . gradientTextArea . setText ( concatenateArrayList ( text ) ) ; }
tr	1	@ SuppressWarnings ( "unchecked" ) public static String enumToString ( enum _enum ) { if ( _enum . toString ( ) . startsWith ( "_" ) ) { return _enum . toString ( ) . substring ( 1 ) ; } else { return _enum . toString ( ) ; } }
tr	0	public void validate ( ) throws org . apache . thrift7 . TException { }
tr	2	public DefaultNeuron ( int weightNumber , double [ ] maxWeight , ActivationFunctionModel activationFunction ) { if ( weightNumber == maxWeight . length ) { Random rand = new Random ( ) ; weight = new double [ weightNumber ] ; for ( int i = 0 ; i < weightNumber ; i ++ ) { weight [ i ] = rand . nextDouble ( ) * maxWeight [ i ] ; } } this . activationFunction = activationFunction ; }
tr	2	private Activity getActivity ( String edgeType ) throws ProvBuildException { if ( _current == null || ! ( _current instanceof Activity ) ) { throw new ProvBuildException ( edgeType + " only applies to activities" ) ; } return ( Activity ) _current ; }
tr	1	public void addNode ( Node node ) { if ( ! nodeAlreadyExists ( node ) ) nodes . add ( node ) ; }
tr	9	public void gameStarted ( ) { try { allies . clear ( ) ; allyIDs . clear ( ) ; enemies . clear ( ) ; enemyIDs . clear ( ) ; players . clear ( ) ; int [ ] playerData = getPlayerInfo ( ) ; for ( int index = 0 ; index < playerData . length ; index += Player . numAttributes ) { Player player = new Player ( playerData , index ) ; players . put ( player . getID ( ) , player ) ; if ( player . isSelf ( ) ) { self = player ; } else if ( player . isAlly ( ) ) { allies . add ( player ) ; allyIDs . add ( player . getID ( ) ) ; } else if ( player . isEnemy ( ) ) { enemies . add ( player ) ; enemyIDs . add ( player . getID ( ) ) ; } } units . clear ( ) ; playerUnits . clear ( ) ; alliedUnits . clear ( ) ; enemyUnits . clear ( ) ; neutralUnits . clear ( ) ; int [ ] unitData = getUnits ( ) ; for ( int index = 0 ; index < unitData . length ; index += Unit . numAttributes ) { int id = unitData [ index ] ; Unit unit = new Unit ( id ) ; unit . update ( unitData , index ) ; units . put ( id , unit ) ; if ( self != null ) { if ( unit . getPlayerID ( ) == self . getID ( ) ) { playerUnits . add ( unit ) ; } else if ( allyIDs . contains ( unit . getPlayerID ( ) ) ) { alliedUnits . add ( unit ) ; } else if ( enemyIDs . contains ( unit . getPlayerID ( ) ) ) { enemyUnits . add ( unit ) ; } else { neutralUnits . add ( unit ) ; } } else if ( allyIDs . contains ( unit . getPlayerID ( ) ) ) { alliedUnits . add ( unit ) ; } else if ( enemyIDs . contains ( unit . getPlayerID ( ) ) ) { enemyUnits . add ( unit ) ; } else { neutralUnits . add ( unit ) ; } } listener . gameStarted ( ) ; } catch ( Error e ) { e . printStackTrace ( ) ; } }
tr	9	public void createFitxaCurs ( int nexp , String cursAcademic ) { DataCtrl cd = new DataCtrl ( ) ; String datacreacio = cd . getDataSQL ( ) + " " + cd . getHora ( ) ; String SQL1 = "Select Exp_FK_ID from `" + ICoreData . core_mysqlDBPrefix + "`.fitxa_alumne_curs where Exp_FK_ID='" + nexp + "' " + " AND Any_academic='" + cursAcademic + "'" ; try { Statement st = client . getMysql ( ) . createStatement ( ) ; ResultSet rs1 = client . getMysql ( ) . getResultSet ( SQL1 , st ) ; if ( rs1 != null && rs1 . next ( ) ) { return ; } if ( rs1 != null ) { rs1 . close ( ) ; st . close ( ) ; } } catch ( SQLException ex ) { Logger . getLogger ( BeanDadesPersonals . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } int cursId = Integer . parseInt ( StringUtils . BeforeLast ( cursAcademic , "-" ) ) ; String SQL2 = "Select * from `" + ICoreData . core_mysqlDBPrefix + "`.xes_alumne_historic where AnyAcademic='" + cursId + "' AND Exp2=" + nexp ; SQL1 = "INSERT INTO `" + ICoreData . core_mysqlDBPrefix + "`.fitxa_alumne_curs " + "(Exp_FK_ID  " + "IdCurs_FK_ID " + " Estudis  " + "Grup  " + "Any_academic  " + "Ensenyament " + " Professor  " + "Observacions  " + "DerivatORI  " + "MotiuDerivacioORI  " + "NumMateriesSuspJuny  " + "NotaMitjaFinal  " + "NumAL_1rTRI  " + "NumAL_2nTRI  " + "NumAL_3rTRI  " + "NumAG_1rTRI " + " NumAG_2nTRI  " + "NumAG_3rTRI  " + "Sancions  " + "Programes  " + "DataCreacio " + " Modificat  " + "DataModificacio) " + " VALUES( ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?) " ; Object [ ] values = null ; try { Statement st2 = client . getMysql ( ) . createStatement ( ) ; ResultSet rs2 = client . getMysql ( ) . getResultSet ( SQL2 , st2 ) ; if ( rs2 != null && rs2 . next ( ) ) { String lensenyament = rs2 . getString ( "Ensenyament" ) ; String lestudis = rs2 . getString ( "Estudis" ) ; String lgrupo = rs2 . getString ( "Grup" ) ; String lprofe = rs2 . getString ( "ProfTutor" ) ; Grup grup = new Grup ( Grup . XESTIB , lensenyament , lestudis , lgrupo , client ) ; values = new Object [ ] { nexp , cursId , grup . getXEstudis ( ) , grup . getXGrup ( ) , cursAcademic , grup . getXEnsenyament ( ) , lprofe , "" , 0 , "" , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , "" , "" , datacreacio , "" , "" } ; } else { String nivell = "" ; String grup = "" ; String profe = "" ; if ( StringUtils . anyAcademic ( ) . equals ( cursAcademic ) ) { String abrev = client . getFitxesClient ( ) . getFitxesUtils ( ) . getTutor ( nexp , cursId ) ; profe = StringUtils . noNull ( client . getProfessoratData ( ) . getMapAbrev ( ) . get ( abrev ) ) ; } Grup grupo = new Grup ( client ) . getGrup ( nexp , cursId ) ; grupo . print ( ) ; values = new Object [ ] { nexp , cursId , grupo . getXEstudis ( ) , grupo . getXGrup ( ) , cursAcademic , grupo . getXEnsenyament ( ) , profe , "" , 0 , "" , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , "" , "" , datacreacio , "" , "" } ; } if ( rs2 != null ) { rs2 . close ( ) ; st2 . close ( ) ; } } catch ( SQLException ex ) { Logger . getLogger ( BeanDadesPersonals . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } int nup = client . getMysql ( ) . preparedUpdate ( SQL1 , values ) ; }
tr	5	@ Override public synchronized void onPlayerMove ( final Board b , int playerNr , int move ) { if ( playerNr == getNumber ( ) ) return ; if ( root . children . isEmpty ( ) ) throw new IllegalStateException ( "root has no children" ) ; for ( int i = 0 ; i < root . children . size ( ) ; i ++ ) { Node child = root . children . get ( i ) ; if ( child . move == move ) { child . parent . apply ( rootBoard ) ; child . parent = null ; root = child ; child . apply ( rootBoard ) ; if ( ! rootBoard . equals ( b ) ) { rootBoard . print ( ) ; b . print ( ) ; throw new IllegalStateException ( "boards do not match" ) ; } return ; } } throw new IllegalStateException ( "cannot move to the correct state" ) ; }
tr	2	public static HashMap < String , boolean > restoreOptions ( File optionSaveFile ) { Type hashType = new TypeToken < HashMap < String , boolean >> ( ) { } . getType ( ) ; Gson myGson = new Gson ( ) ; HashMap < String , boolean > tempHash = new HashMap < String , boolean > ( ) ; try { Scanner reader = new Scanner ( new BufferedReader ( new FileReader ( optionSaveFile ) ) ) ; if ( reader . hasNext ( ) ) { tempHash = myGson . fromJson ( reader . next ( ) , hashType ) ; } reader . close ( ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } return tempHash ; }
tr	0	protected void addPositionalPointer ( CellElement e , int wantedPos ) { PointerCell pCell = new PointerCell ( e , wantedPos ) ; this . m_pointers . add ( pCell ) ; }
tr	1	@ Test public void testIdentifierOptionalPresentButNull ( ) throws TemplateException { Identifier variable = new Identifier ( "$variable?" , new Cursor ( "-:l1:c1" ) ) ; populateModel ( "variable" , null ) ; try { variable . writeObject ( null , model , null ) ; fail ( "An exception must be raised." ) ; } catch ( TemplateIgnoreRenderingException e ) { assertEquals ( "Ignore rendering because key 'variable' is not present or has null value in the model map at position '-:l1:c1'." , e . getMessage ( ) ) ; } }
tr	5	public int solution ( String input ) { final Deque < Character > stack = new LinkedList < Character > ( ) ; final int nbChars = input . length ( ) ; for ( int i = 0 ; i < nbChars ; i ++ ) { final char c = input . charAt ( i ) ; if ( c == ( ) { stack . push ( c ) ; } else if ( c == ) ) { if ( stack . isEmpty ( ) ) { return 0 ; } else { stack . pop ( ) ; } } } return stack . isEmpty ( ) ? 1 : 0 ; }
tr	5	public static void execute ( ICommand command ) throws FogBugzException { if ( getPage ( ) == null && ! checkingApi ) { checkApi ( ) ; } if ( ! checkingApi && ! loggedIn ) { logger . info ( "Token was not set. Trying to login." ) ; login ( ) ; if ( getToken ( ) . getToken ( ) != null ) { logger . info ( "Login was successful: " + getToken ( ) . getToken ( ) ) ; } else { logger . warn ( "Login failed." ) ; } } URLFetcher . setCommand ( command ) ; URLFetcher . setConnection ( getConnection ( ) ) ; URLFetcher . setToken ( getToken ( ) ) ; URLFetcher . setRequestPage ( getPage ( ) ) ; String uri = URLFetcher . generateRequest ( ) ; logger . info ( "Using URL for request: " + uri ) ; command . addListener ( Processor . getInstance ( ) ) ; command . execute ( uri ) ; }
tr	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( SettingsFrame . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( SettingsFrame . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( SettingsFrame . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( SettingsFrame . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { new SettingsFrame ( ) . setVisible ( true ) ; } } ) ; }
tr	1	@ Test public void testSplitLeafs ( ) { StringBuilder expected = new StringBuilder ( ) ; for ( int i = 0 ; i < 7 ; i ++ ) { bpTree . put ( i , i ) ; expected . append ( "<put>" ) . append ( "<not-contain-key>" ) . append ( "<get>" ) . append ( "<not-contain>" ) . append ( "<leaf-put>" ) . append ( "<new-key>" ) ; } expected . append ( "<create-new-root>" ) ; assertThat ( bpTree . getWay ( ) , is ( expected . toString ( ) ) ) ; }
tr	1	@ Override public void paint ( Graphics g ) { Graphics2D g2d = ( Graphics2D ) g ; if ( image != null ) { synchronized ( image ) { g2d . setRenderingHint ( RenderingHints . KEY_RENDERING , RenderingHints . VALUE_RENDER_SPEED ) ; g2d . drawImage ( image , 0 , 0 , null ) ; } } else { super . paint ( g2d ) ; } }
tr	9	protected static final String addEscapes ( String str ) { StringBuffer retval = new StringBuffer ( ) ; char ch ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { switch ( str . charAt ( i ) ) { case 0 : continue ; case  : retval . append ( "\\b" ) ; continue ; case 	 : retval . append ( "\\t" ) ; continue ; case '' : retval . append ( "\\n" ) ; continue ; case  : retval . append ( "\\f" ) ; continue ; case '' : retval . append ( "\\r" ) ; continue ; case " : retval . append ( "\\\"" ) ; continue ; case ' : retval . append ( "\\'" ) ; continue ; case \ : retval . append ( "\\\\" ) ; continue ; default : if ( ( ch = str . charAt ( i ) ) < 20 || ch > 7e ) { String s = "0000" + Integer . toString ( ch , 16 ) ; retval . append ( "\\u" + s . substring ( s . length ( ) - 4 , s . length ( ) ) ) ; } else { retval . append ( ch ) ; } continue ; } } return retval . toString ( ) ; }
tr	3	public boolean isFuture ( AppointmentSpecification appointmentSpecification ) { AppointmentDate appDate = appointmentSpecification . getDate ( ) ; boolean isDateInFuture = isDateInFuture ( appDate ) ; boolean isToday = isDateToday ( appDate ) ; boolean isTimeSlotOver = isTimeSlotOverTime ( appointmentSpecification ) ; boolean areWeInsideTimeSlot = isInsideTimeSlotTime ( appointmentSpecification ) ; return isDateInFuture || ( isToday && ! isTimeSlotOver && ! areWeInsideTimeSlot ) ; }
tr	9	public void outDem ( String s , int color , boolean bold ) { String sortie = "" ; sortie += "\u001B[" ; if ( bold ) sortie += "1;" ; switch ( color ) { case 0 : sortie += "30" ; break ; case 1 : sortie += "31" ; break ; case 2 : sortie += "32" ; break ; case 3 : sortie += "33" ; break ; case 4 : sortie += "34" ; break ; case 5 : sortie += "35" ; break ; case 6 : sortie += "36" ; break ; case 7 : sortie += "37" ; break ; } sortie += "mServeur " + Global . TCP_PORT + " : " + s + "\u001B[0m\n" ; try { Thread . sleep ( ( int ) Math . abs ( Math . random ( ) * 20 ) ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } System . out . print ( sortie ) ; }
tr	5	public Writer write ( Writer writer ) throws JSONException { try { boolean b = false ; int len = length ( ) ; writer . write ( [ ) ; for ( int i = 0 ; i < len ; i += 1 ) { if ( b ) { writer . write (   ) ; } Object v = this . myArrayList . get ( i ) ; if ( v instanceof JSONObject ) { ( ( JSONObject ) v ) . write ( writer ) ; } else if ( v instanceof JSONArray ) { ( ( JSONArray ) v ) . write ( writer ) ; } else { writer . write ( JSONObject . valueToString ( v ) ) ; } b = true ; } writer . write ( ] ) ; return writer ; } catch ( IOException e ) { throw new JSONException ( e ) ; } }
tr	6	@ Override public byte [ ] post ( HttpExchange he ) { if ( ! this . getContext ( ) . getSessionManager ( ) . isAuthorised ( he ) ) { return new byte [ 0 ] ; } WebUser wu = this . getContext ( ) . getSessionManager ( ) . getWebUser ( he . getRemoteAddress ( ) . getAddress ( ) ) ; OfflinePlayer offlinePlayer = this . getContext ( ) . getPlugin ( ) . getServer ( ) . getOfflinePlayer ( wu . getUsername ( ) ) ; if ( offlinePlayer == null || ( ! ( offlinePlayer . isOp ( ) ) ) ) { return new byte [ 0 ] ; } String postParams ; try ( InputStreamReader inStream = new InputStreamReader ( he . getRequestBody ( ) ) ) { try ( BufferedReader bufferedReader = new BufferedReader ( inStream ) ) { postParams = bufferedReader . readLine ( ) ; } } catch ( IOException ex ) { Logger . getLogger ( RequestHandler . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; return new byte [ 0 ] ; } Map < String , String > vars = parsePostResponse ( postParams ) ; String add = vars . get ( "addPlayers" ) ; String rem = vars . get ( "removePlayers" ) ; if ( add != null ) { return addToWhitelist ( add ) ; } if ( rem != null ) { return removeFromWhitelist ( rem ) ; } return new byte [ 0 ] ; }
tr	3	public JSONArray toJSONArray ( JSONArray names ) throws JSONException { if ( names == null || names . length ( ) == 0 ) { return null ; } JSONArray ja = new JSONArray ( ) ; for ( int i = 0 ; i < names . length ( ) ; i += 1 ) { ja . put ( this . opt ( names . getString ( i ) ) ) ; } return ja ; }
tr	0	public static SelectParameter Select ( String parameterName ) { return new SelectParameter ( parameterName ) ; }
tr	2	public List < ComboRating > getTopList ( ) throws SQLException { Statement st = null ; List < ComboRating > topList = new ArrayList < ComboRating > ( ) ; try { st = conn . createStatement ( ) ; ResultSet rs = st . executeQuery ( "SELECT ((total_rating * 1.0)/times_rated) AS rating  flavor_1  flavor_2  times_rated  total_rating FROM flavor_combo_ratings ORDER BY rating DESC LIMIT 10" ) ; while ( rs . next ( ) ) { topList . add ( new ComboRating ( rs . getInt ( "flavor_1" ) , rs . getInt ( "flavor_2" ) , rs . getInt ( "total_rating" ) , rs . getInt ( "times_rated" ) ) ) ; } } finally { if ( st != null ) st . close ( ) ; } return topList ; }
tr	9	private boolean newlineIsWhitespace ( String set ) { int len = ( set != null ) ? set . length ( ) : 0 ; char start , end , setChar ; boolean crFound = false ; boolean lfFound = false ; for ( int ii = 0 ; ii < len ; ++ ii ) { switch ( setChar = set . charAt ( ii ) ) { case - : start = ( ii > 0 ) ? set . charAt ( ii - 1 ) : 0 ; end = ( ii < len - 1 ) ? set . charAt ( ii + 1 ) : FFFF ; if ( '' >= start && '' <= end ) { lfFound = true ; } if ( '' >= start && '' <= end ) { crFound = true ; } ii += 2 ; break ; case '' : crFound = true ; break ; case '' : lfFound = true ; break ; case \ : ii ++ ; break ; } if ( crFound && lfFound ) { return true ; } } return false ; }
tr	8	private void filterButtonActionPerformed ( ActionEvent evt ) { String keyword = searchTextField . getText ( ) . toLowerCase ( ) ; Date from = ( Date ) dateFromSpinner . getValue ( ) ; Date to = ( Date ) dateToSpinner . getValue ( ) ; if ( from . after ( to ) ) { Date temp = to ; to = from ; from = temp ; } Vector < NotePad > vector = new Vector < > ( ) ; for ( NotePad notePad : NotePadManager . getInstance ( ) . getNotepads ( ) ) { boolean isFilterSuccess = false ; if ( ! keyword . isEmpty ( ) ) { if ( notePad . getDescription ( ) . toLowerCase ( ) . indexOf ( keyword ) >= 0 ) { isFilterSuccess = true ; } if ( notePad . getName ( ) . toLowerCase ( ) . indexOf ( keyword ) >= 0 ) { isFilterSuccess = true ; } } Date current = notePad . getDate ( ) ; if ( from . before ( current ) && to . after ( current ) ) { isFilterSuccess = true ; } if ( isFilterSuccess ) vector . add ( notePad ) ; } noteList . setListData ( vector ) ; }
tr	4	@ Override public File createNewFolder ( File containingDir ) throws IOException { if ( containingDir == null ) { throw new IOException ( "Containing directory is null:" ) ; } File newFolder = createFileObject ( containingDir , newFolderString ) ; int i = 2 ; while ( newFolder . exists ( ) && i < 100 ) { newFolder = createFileObject ( containingDir , MessageFormat . format ( newFolderNextString , new Integer ( i ) ) ) ; i ++ ; } if ( newFolder . exists ( ) ) { throw new IOException ( "Directory already exists:" + newFolder . getAbsolutePath ( ) ) ; } else { newFolder . mkdirs ( ) ; } return newFolder ; }
tr	0	@ Override public Object visit ( ASTVisitor v , Object arg ) throws Exception { return v . visitBinaryExpr ( this , arg ) ; }
tr	2	private boolean isKColorable ( int k ) { for ( HashSet < Value > edges : adjacencyList . values ( ) ) { if ( edges . size ( ) >= k ) { return false ; } } return true ; }
tr	6	public boolean canPlayOffline ( ) { try { String path = ( String ) AccessController . doPrivileged ( new PrivilegedExceptionAction < Object > ( ) { public Object run ( ) throws Exception { return Util . getWorkingDirectory ( ) + File . separator + "bin" + File . separator ; } } ) ; File dir = new File ( path ) ; if ( ! dir . exists ( ) ) return false ; dir = new File ( dir , "version" ) ; if ( ! dir . exists ( ) ) return false ; if ( dir . exists ( ) ) { String version = readVersionFile ( dir ) ; if ( ( version != null ) && ( version . length ( ) > 0 ) ) return true ; } } catch ( Exception e ) { e . printStackTrace ( ) ; return false ; } return false ; }
tr	7	void modElement ( String [ ] args ) throws Exception { if ( args . length < 3 ) { System . err . println ( "Usage: mod <config_file> <indexID>" ) ; System . exit ( 1 ) ; } myVsl = new vsl ( args [ 1 ] ) ; vslRecKey prev = new vslRecKey ( ) ; vslID id = new vslID ( ) ; id . setID ( args [ 2 ] ) ; vslIndex index = myVsl . getIndex ( id , true ) ; Vector < vslElKey > allKeys = showAllElements ( index ) ; vslElKey elKey = null ; while ( ( elKey = promptForChoice ( "element to update" , allKeys ) ) != null ) { vslIndexElement el = index . getElement ( elKey ) ; Vector < vslRecKey > allRec = new Vector < vslRecKey > ( ) ; recurseVersionPrint ( el . getFirst ( ) , 1 , allRec ) ; while ( ( prev = promptForChoice ( "previous record to update" , allRec ) ) != null ) { Vector prevVec = new Vector ( ) ; prevVec . add ( prev ) ; vslIndexDataType < String > elData = null ; String input = null ; do { System . out . print ( "Update/Detele [u/d]:" ) ; input = FileChunkingTest . getLine ( ) ; } while ( input != null && ! ( input . equals ( "u" ) || input . equals ( "d" ) ) ) ; if ( input . equals ( "u" ) ) { System . out . print ( "Update data:" ) ; input = FileChunkingTest . getLine ( ) ; elData = new vslIndexDataType < String > ( input ) ; index . updateElement ( elKey , elData , prevVec ) ; } else { index . deleteElement ( elKey , prevVec ) ; } myVsl . updateIndex ( index ) ; allRec = new Vector < vslRecKey > ( ) ; recurseVersionPrint ( el . getFirst ( ) , 1 , allRec ) ; } allKeys = showAllElements ( index ) ; } myVsl . save ( ) ; }
tr	8	@ Override public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( obj == null ) { return false ; } if ( getClass ( ) != obj . getClass ( ) ) { return false ; } AbstractFeatureDefinition < ? > other = ( AbstractFeatureDefinition < ? > ) obj ; if ( name == null ) { if ( other . name != null ) { return false ; } } else if ( ! name . equals ( other . name ) ) { return false ; } return true ; }
tr	2	public double getSLAFulfillmentRate ( ) { double dd = duration ; if ( violationDuration < dd * MRT ) { return 1 ; } else if ( violationDuration > dd * MPT ) { return 0 ; } else { return 1 - ( ( ( double ) violationDuration ) - dd * MRT ) / ( dd * ( MPT - MRT ) ) ; } }
tr	5	private static Dictionary < String , String > createDictionary ( ChoiseImpl implementation ) { switch ( implementation ) { case SORTED_ARRAY_IMPL : return new SortedArrayDictionary < String , String > ( ) ; case HASH_IMPL : return new HashDictionary < String , String > ( ) ; case MAP_HASHMAP_IMPL : return new MapDictionary < String , String > ( new HashMap < String , String > ( ) ) ; case MAP_TREEMAP_IMPL : return new MapDictionary < String , String > ( new TreeMap < String , String > ( ) ) ; case TREE_IMPL : return new TreeDictionary < String , String > ( ) ; } return null ; }
tr	3	public static ArrayList < Compte > getAllCompte ( ) { Statement stat ; ArrayList < Compte > comptes = new ArrayList < > ( ) ; try { stat = ConnexionDB . getConnection ( ) . createStatement ( ) ; stat . executeUpdate ( "use nemovelo" ) ; ResultSet res = stat . executeQuery ( "select * from compte" ) ; Compte compte ; int id_compte , fk_id_utilisateur ; double solde ; String typeCompte , dateCreation ; while ( res . next ( ) ) { id_compte = res . getInt ( "id_compte" ) ; typeCompte = res . getString ( "typeCompte" ) ; solde = res . getDouble ( "solde" ) ; dateCreation = res . getString ( "dateCreation" ) ; fk_id_utilisateur = res . getInt ( "fk_id_utilisateur" ) ; compte = new Compte ( id_compte , typeCompte , solde , dateCreation , fk_id_utilisateur ) ; comptes . add ( compte ) ; } } catch ( SQLException e ) { while ( e != null ) { System . out . println ( e . getErrorCode ( ) ) ; System . out . println ( e . getMessage ( ) ) ; System . out . println ( e . getSQLState ( ) ) ; e . printStackTrace ( ) ; e = e . getNextException ( ) ; } } return comptes ; }
tr	4	@ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; Rectangular that = ( Rectangular ) o ; if ( length != that . length ) return false ; return width == that . width ; }
tr	4	@ Override public String toString ( ) { StringBuffer tmp = new StringBuffer ( ) ; tmp . append ( type ) ; tmp . append ( " " ) ; tmp . append ( payLoadType ) ; tmp . append ( " " ) ; tmp . append ( httpMethod ) ; tmp . append ( " " ) ; tmp . append ( template . toUri ( ) ) ; tmp . append ( " path-params[" ) ; boolean first = true ; for ( Parameter param : pathParameters ) { if ( first ) { first = false ; } else { tmp . append ( " " ) ; } tmp . append ( param ) ; } tmp . append ( "]" ) ; tmp . append ( " query-params[" ) ; first = true ; for ( Parameter param : queryParameters ) { if ( first ) { first = false ; } else { tmp . append ( " " ) ; } tmp . append ( param ) ; } tmp . append ( "]" ) ; return tmp . toString ( ) ; }
tr	5	private void getGeoInfo ( String geo ) { StringBuffer value = new StringBuffer ( ) ; for ( char c : geo . toCharArray ( ) ) { if ( c > 45 && c < 58 ) { value . append ( c ) ; } if ( c == 44 ) { if ( value . length ( ) > 0 ) { latitude = double . parseDouble ( value . toString ( ) ) ; value . delete ( 0 , value . length ( ) ) ; } } } longitude = double . parseDouble ( value . toString ( ) ) ; }
tr	9	public void setAttributes ( NamedNodeMap attributes ) { if ( attributes == null ) { return ; } String target = attributes . getNamedItem ( "target" ) . getNodeValue ( ) ; if ( target == null || target . isEmpty ( ) ) { return ; } if ( target . equalsIgnoreCase ( "iesdigital" ) ) { this . registerIesDigital = true ; } if ( target . equalsIgnoreCase ( "sgd" ) ) { this . registerSGD = true ; } for ( int i = 0 ; i < attributes . getLength ( ) ; i ++ ) { Node item = attributes . item ( i ) ; if ( item . getNodeName ( ) . equals ( "dates" ) ) { this . dates = item . getNodeValue ( ) ; } else if ( item . getNodeName ( ) . equals ( "dates" ) ) { this . dates = item . getNodeValue ( ) ; } else if ( item . getNodeName ( ) . equals ( "type" ) ) { this . tipus = item . getNodeValue ( ) ; } else if ( item . getNodeName ( ) . equals ( "simbol" ) ) { this . simboloIncidencia = item . getNodeValue ( ) ; } else if ( item . getNodeName ( ) . equals ( "description" ) ) { this . observaciones = item . getNodeValue ( ) . replaceAll ( "<" , "(" ) . replaceAll ( ">" , ")" ) ; } else if ( item . getNodeName ( ) . equals ( "incpersession" ) ) { this . incidenciasSesion = Integer . parseInt ( item . getNodeValue ( ) ) ; } else if ( item . getNodeName ( ) . equals ( "allDay" ) ) { this . todoElDia = item . getNodeValue ( ) . equals ( "yes" ) ; } } }
tr	4	@ Override public int attachSoundEffect ( SoundEffect effect , int channel ) { if ( channel > chEffects . size ( ) ) throw new IndexOutOfBoundsException ( "Channel must be in range!" ) ; effect = effect . clone ( ) ; if ( channel < 0 ) { if ( effect . getChannelCount ( ) != channelCount ) throw new IllegalArgumentException ( "The effects channel count must be same as this mixers channel count!" ) ; mEffects . add ( effect ) ; return mEffects . size ( ) - 1 ; } else { if ( effect . getChannelCount ( ) != getInputChannelOutputChannelCount ( channel ) ) throw new IllegalArgumentException ( "The effects channel count must be the same as input channels channel count!" ) ; ArrayList < SoundEffect > e = chEffects . get ( channel ) ; e . add ( effect ) ; return e . size ( ) - 1 ; } }
tr	9	private boolean EsDireccionCorrecta ( String entrada_Direccion ) { char Letra ; boolean DireccionCorrecta = true ; boolean DireccionIncorrecta = false ; if ( entrada_Direccion . equals ( "" ) ) { return DireccionIncorrecta ; } else { for ( int Indice = 0 ; Indice < entrada_Direccion . length ( ) ; Indice ++ ) { Letra = entrada_Direccion . charAt ( Indice ) ; if ( ! ( ( Letra >= 0 && Letra <= 9 ) || ( Letra >= a & Letra <= z ) || ( Letra >= A && Letra <= Z ) || ( Letra ==   || Letra == # ) ) ) { return DireccionIncorrecta ; } } } return DireccionCorrecta ; }
tr	5	void totalize ( ) { State s = new State ( ) ; s . transitions . add ( new Transition ( Character . MIN_VALUE , Character . MAX_VALUE , s ) ) ; for ( State p : getStates ( ) ) { int maxi = Character . MIN_VALUE ; for ( Transition t : p . getSortedTransitions ( false ) ) { if ( t . min > maxi ) p . transitions . add ( new Transition ( ( char ) maxi , ( char ) ( t . min - 1 ) , s ) ) ; if ( t . max + 1 > maxi ) maxi = t . max + 1 ; } if ( maxi <= Character . MAX_VALUE ) p . transitions . add ( new Transition ( ( char ) maxi , Character . MAX_VALUE , s ) ) ; } }
tr	6	public List < double > classifyInstance ( Datum attributesDatum ) { List < double > attributesList = attributesDatum . getAttributes ( ) ; for ( int i = 0 ; i < nodeLevelNumber . get ( NetworkLevel . Input ) ; i ++ ) { neuralMap . get ( NetworkLevel . Input ) . get ( i ) . setNodeValue ( attributesList . get ( i ) ) ; } for ( int i = 0 ; i < nodeLevelNumber . get ( NetworkLevel . Hidden ) ; i ++ ) { double totalHiddenInput = 0 ; for ( int j = 0 ; j < nodeLevelNumber . get ( NetworkLevel . Input ) ; j ++ ) { double inputNodeValue = neuralMap . get ( NetworkLevel . Input ) . get ( j ) . getNodeValue ( ) ; double inputNodeWeight = neuralMap . get ( NetworkLevel . Input ) . get ( j ) . getOutputWeightAt ( i ) ; totalHiddenInput += inputNodeValue * inputNodeWeight ; } totalHiddenInput += biasNode . getOutputWeightAt ( i ) * biasNode . getNodeValue ( ) ; double hiddenNodeValue = 1.0 / ( 1 + Math . pow ( Math . E , - totalHiddenInput ) ) ; neuralMap . get ( NetworkLevel . Hidden ) . get ( i ) . setNodeValue ( hiddenNodeValue ) ; } ArrayList < double > intermediateValues = new ArrayList < double > ( ) ; double simpleTotal = 0 ; for ( int i = 0 ; i < nodeLevelNumber . get ( NetworkLevel . Output ) ; i ++ ) { double totalOutputInput = 0 ; for ( int j = 0 ; j < nodeLevelNumber . get ( NetworkLevel . Hidden ) ; j ++ ) { double hiddenNodeValue = neuralMap . get ( NetworkLevel . Hidden ) . get ( j ) . getNodeValue ( ) ; double hiddenNodeWeight = neuralMap . get ( NetworkLevel . Hidden ) . get ( j ) . getOutputWeightAt ( i ) ; totalOutputInput += hiddenNodeValue * hiddenNodeWeight ; } totalOutputInput += biasNode . getOutputWeightAt ( i + nodeLevelNumber . get ( NetworkLevel . Hidden ) ) * biasNode . getNodeValue ( ) ; intermediateValues . add ( totalOutputInput ) ; simpleTotal += Math . pow ( Math . E , totalOutputInput ) ; } ArrayList < double > finalValues = new ArrayList < double > ( ) ; for ( int i = 0 ; i < nodeLevelNumber . get ( NetworkLevel . Output ) ; i ++ ) { double trueOutputValue ; trueOutputValue = Math . pow ( Math . E , intermediateValues . get ( i ) ) / simpleTotal ; neuralMap . get ( NetworkLevel . Output ) . get ( i ) . setNodeValue ( trueOutputValue ) ; finalValues . add ( trueOutputValue ) ; } return finalValues ; }
tr	2	private String getKey ( String keyword ) { Set < String > set = nTimesGivenDay . keySet ( ) ; Iterator < String > iter = set . iterator ( ) ; while ( iter . hasNext ( ) ) { String key = iter . next ( ) ; if ( key . contains ( keyword ) ) { return key ; } } return new String ( ) ; }
tr	9	public void actionPerformed ( ActionEvent e ) { String act = e . getActionCommand ( ) ; if ( act . equals ( "BLUR" ) ) { Integer integer = IntegerDialog . getInteger ( Resources . getString ( "EffectsMenu.BLUR_AMOUNT" ) , 1 , 9 , 3 , 3 ) ; if ( integer != null ) applyAction ( new Blur ( integer ) ) ; return ; } if ( act . equals ( "SATURATION" ) ) { Integer integer = IntegerDialog . getInteger ( Resources . getString ( "EffectsMenu.SATURATION_AMOUNT" ) , 0 , 200 , 100 , 50 ) ; if ( integer != null ) applyAction ( new Saturation ( integer ) ) ; return ; } if ( act . equalsIgnoreCase ( "VALUE" ) ) { Integer integer = IntegerDialog . getInteger ( Resources . getString ( "EffectsMenu.VALUE_AMOUNT" ) , - 10 , 10 , 0 , 5 ) ; if ( integer != null ) applyAction ( new Value ( ( integer + 10 ) / 10.0f ) ) ; return ; } if ( act . equals ( "INVERT" ) ) { applyAction ( new Invert ( ) ) ; return ; } if ( act . equals ( "FADE" ) ) { Integer integer = IntegerDialog . getInteger ( Resources . getString ( "EffectsMenu.FADE_AMOUNT" ) , 0 , 256 , 128 , 64 ) ; if ( integer != null ) applyAction ( new Fade ( Color . BLACK , ( ( float ) integer ) / 256.0f ) ) ; return ; } }
tr	9	public void initNetwork ( int n , double p , int type ) { if ( network != null ) { network . clear ( ) ; } switch ( type ) { case 0 : if ( Math . abs ( p + 1 ) < 0.0001 ) { p = ( 2 * Math . log ( ( double ) n ) ) / ( double ) n ; } network = netGen . generateConnectedER ( n , p ) ; break ; case 1 : int m = - 1 ; if ( Math . abs ( p + 1 ) < 0.0001 ) { m = ( int ) ( ( double ) ( n - 1 ) * Math . log ( n ) / ( double ) n ) ; } else { m = ( int ) p ; } System . out . println ( "N: " + n + " m: " + m ) ; network = netGen . generatePA ( n , m ) ; break ; case 2 : network = netGen . generateGrid ( n , ( int ) p ) ; break ; case 3 : network = netGen . generatePath ( n ) ; break ; case 4 : network = netGen . readFromAdjacencyMatrix ( "d:/4ntest.txt" ) ; break ; case 5 : network = netGen . generateStar ( n - 1 , 1 ) ; break ; case 6 : network = netGen . generateDoubleStart ( n , ( int ) p ) ; break ; case 7 : network = netGen . generateCompleteGraph ( n ) ; break ; case 8 : network = netGen . generateRGG ( n , p ) ; break ; case 9 : network = netGen . generateRing ( n ) ; break ; case 10 : network = netGen . generateER ( n , p ) ; break ; case 11 : network = netGen . generateConnectedERFixedAvDegree ( n , p ) ; break ; default : System . out . println ( "network type unknown" ) ; break ; } Runtime . getRuntime ( ) . gc ( ) ; }
tr	9	private void exportaTXT ( ) throws SQLException { String query = "" ; String query_contador = "" ; String linea ; ResultSet respuesta ; boolean band = false ; String ruta_escritorio = System . getProperty ( "user.home" ) + "\\Desktop\\" ; try { BufferedWriter escribir_archivo = new BufferedWriter ( new FileWriter ( new File ( ruta_escritorio + this . NombreArchivo ) ) ) ; if ( this . caso . equals ( "todos" ) ) { query_contador = "SELECT COUNT(`correo`) FROM `" + NombreTablas . CORREOS . getValue ( ) + "` WHERE `habilitado` = 'true'" ; respuesta = this . conexion . executeQuery ( query_contador ) ; respuesta . next ( ) ; total_correos = respuesta . getInt ( 1 ) ; query = "SELECT `correo` FROM `" + NombreTablas . CORREOS . getValue ( ) + "` WHERE `habilitado` = 'true'" ; respuesta = this . conexion . executeQuery ( query ) ; while ( respuesta . next ( ) ) { cont_escritos ++ ; linea = respuesta . getNString ( "correo" ) ; escribir_archivo . write ( linea ) ; if ( cont_escritos < total_correos ) { escribir_archivo . write ( "\r\n" ) ; } int porcentaje = ( cont_escritos * 100 ) / total_correos ; vistaLoading . lblInfo . setText ( "Exportando " + cont_escritos + " de " + total_correos ) ; vistaLoading . pbProgreso . setValue ( porcentaje ) ; vistaLoading . lblCompletado . setText ( porcentaje + "% completado..." ) ; } escribir_archivo . close ( ) ; band = true ; } else if ( this . caso . equals ( "origen-grupo" ) ) { if ( origen != null && grupo != null ) { query_contador = "SELECT COUNT(`correo`) FROM `" + NombreTablas . CORREOS . getValue ( ) + "` WHERE `habilitado` = 'true' AND `id_origen` = " + origen . getId ( ) + " AND `id_grupo` = " + grupo . getId ( ) ; query = "SELECT `correo` FROM `" + NombreTablas . CORREOS . getValue ( ) + "` WHERE `habilitado` = 'true' AND `id_origen` = " + origen . getId ( ) + " AND `id_grupo` = " + grupo . getId ( ) ; } else if ( origen != null && grupo == null ) { query_contador = "SELECT COUNT(`correo`) FROM `" + NombreTablas . CORREOS . getValue ( ) + "` WHERE `habilitado` = 'true' AND `id_origen` = " + origen . getId ( ) ; query = "SELECT `correo` FROM `" + NombreTablas . CORREOS . getValue ( ) + "` WHERE `habilitado` = 'true' AND `id_origen` = " + origen . getId ( ) ; } else if ( origen == null && grupo != null ) { query_contador = "SELECT COUNT(`correo`) FROM `" + NombreTablas . CORREOS . getValue ( ) + "` WHERE `habilitado` = 'true' AND `id_grupo` = " + grupo . getId ( ) ; query = "SELECT `correo` FROM `" + NombreTablas . CORREOS . getValue ( ) + "` WHERE `habilitado` = 'true' AND `id_grupo` = " + grupo . getId ( ) ; } respuesta = this . conexion . executeQuery ( query_contador ) ; respuesta . next ( ) ; total_correos = respuesta . getInt ( 1 ) ; respuesta = this . conexion . executeQuery ( query ) ; while ( respuesta . next ( ) ) { cont_escritos ++ ; linea = respuesta . getNString ( "correo" ) ; escribir_archivo . write ( linea ) ; if ( cont_escritos < total_correos ) { escribir_archivo . write ( "\r\n" ) ; } int porcentaje = ( cont_escritos * 100 ) / total_correos ; vistaLoading . lblInfo . setText ( "Exportando " + cont_escritos + " de " + total_correos ) ; vistaLoading . pbProgreso . setValue ( porcentaje ) ; vistaLoading . lblCompletado . setText ( porcentaje + "% completado..." ) ; } escribir_archivo . close ( ) ; band = true ; } vistaLoading . dispose ( ) ; if ( band == true ) { JOptionPane . showMessageDialog ( vistaLoading , "Exportaci\u00F3n finalizada  nuevo documento : \r\n" + ruta_escritorio + NombreArchivo , "Fin del proceso" , JOptionPane . INFORMATION_MESSAGE ) ; } } catch ( HeadlessException | IOException | SQLException e ) { JOptionPane . showMessageDialog ( null , "ERROR: " + e + "." , "Error" , JOptionPane . ERROR_MESSAGE ) ; } }
tr	4	@ Override public void notifySample ( Sample s ) { switch ( mode ) { case CLASSIFYING : System . out . println ( "add sample to classify" ) ; Gesture g = classifier . classifySample ( s ) ; gui . showClassifiedGesture ( g ) ; break ; case IDLE : System . out . println ( "Idle Sample" ) ; break ; case RECORDING : break ; case TRAINING : System . out . println ( "add Training Sample" ) ; Gesture currentGesture = gui . getCurrentGesture ( ) ; trainer . addSample ( s , currentGesture ) ; break ; default : break ; } }
tr	0	public EvaluationUtilityTest ( ) { }
tr	5	public void actionPerformed ( ActionEvent ae ) { GenericTable gtFrom = ( GenericTable ) tblFrom . getModel ( ) ; GenericTable gtTo = ( GenericTable ) tblTo . getModel ( ) ; if ( moveAll ) { Vector rows = gtFrom . getRows ( ) ; int offset = 0 ; int rowSize = rows . size ( ) ; for ( int i = 0 ; i < rowSize ; i ++ ) { int j = i + offset ; Object [ ] objTemp = ( Object [ ] ) rows . get ( 0 + offset ) ; if ( ( ( boolean ) objTemp [ 4 ] ) . booleanValue ( ) ) { gtTo . addRow ( objTemp ) ; gtFrom . removeRow ( 0 + offset ) ; } else { offset ++ ; } } } else { int [ ] rowsToMove = tblFrom . getSelectedRows ( ) ; for ( int i = 0 ; i < rowsToMove . length ; i ++ ) { int adjustedPosition = rowsToMove [ i ] - i ; Object [ ] objTemp = gtFrom . getRow ( adjustedPosition ) ; if ( ( ( boolean ) objTemp [ 4 ] ) . booleanValue ( ) ) { gtTo . addRow ( objTemp ) ; gtFrom . removeRow ( adjustedPosition ) ; } else { JOptionPane . showMessageDialog ( mars . mars . gui . MarsClient . getDesktopPane ( ) , "Cannot add this attribute as it is an incompatible type:\nAttribute Name: \t" . concat ( ( ( String ) objTemp [ 1 ] ) ) . concat ( "\nSQL Type: \t" ) . concat ( ( String ) objTemp [ 2 ] ) ) ; } } } }
tr	3	public ForcesWindow ( Node n ) { initComponents ( ) ; this . setLocationRelativeTo ( null ) ; this . setModal ( true ) ; this . setTitle ( "Node " + n . getNumber ( ) ) ; resultList = new DefaultListModel ( ) ; jListForces . setModel ( resultList ) ; for ( Force f : n . getForces ( ) ) { resultList . addElement ( f ) ; } if ( ! n . getForces ( ) . isEmpty ( ) ) { jListForces . setSelectedIndex ( 0 ) ; } if ( jListForces . getSelectedValue ( ) != null ) { Force f = ( Force ) jListForces . getSelectedValue ( ) ; jComboForceAxis . setSelectedItem ( f . getAxis ( ) ) ; } listNodes . add ( n ) ; this . setVisible ( true ) ; }
tr	8	private final static long from64 ( byte [ ] encoded , int idx , int size ) { long res = 0 ; int f = 0 ; while ( size > 0 ) { size -- ; long r = 0 ; byte d = encoded [ idx ++ ] ; if ( d == / ) { r = 1 ; } if ( d >= 0 && d <= 9 ) { r = 2 + d - 0 ; } if ( d >= A && d <= Z ) { r = 12 + d - A ; } if ( d >= a && d <= z ) { r = 38 + d - a ; } res = res + ( ( long ) r << f ) ; f += 6 ; } return res ; }
tr	1	public void hide ( ) { object . setHidden ( ) ; for ( ObjectController oc : controllers ) { oc . hide ( ) ; } }
tr	2	private void program ( BlockNode root ) { Token t = in . next ( ) ; while ( t != null ) { if ( t . type == TokenType . END ) throw new ParserException ( "extra ']' without matching '['" ) ; else operation ( root , t ) ; t = in . next ( ) ; } }
tr	1	protected void registerPlayer ( Player player ) { permissions . remove ( player ) ; registerPlayer ( player , player . getWorld ( ) ) ; String displayName = getPrefix ( player . getName ( ) ) + player . getDisplayName ( ) ; if ( displayName . length ( ) > 16 ) { displayName = displayName . substring ( 0 , 16 ) ; } player . setPlayerListName ( displayName ) ; }
tr	1	void removeAll ( ) { for ( int i = 0 ; i < MAX_TILES ; i ++ ) { removeTile ( i , true ) ; } }
tr	2	public < T > boolean checkExpect ( T actual , T expected , String testname ) { this . testname = testname ; return this . report ( this . inspector . exactTest ( ) && this . inspector . isSame ( actual , expected ) && ! this . inspector . inexactViolation ( ) , testname , "actual:                                 expected:\n" + Printer . combineActualExpected ( Printer . produceString ( actual ) , Printer . produceString ( expected ) ) + "\n" ) ; }
tr	7	public Object nextContent ( ) throws JSONException { char c ; StringBuffer sb ; do { c = next ( ) ; } while ( Character . isWhitespace ( c ) ) ; if ( c == 0 ) { return null ; } if ( c == < ) { return XML . < ; } sb = new StringBuffer ( ) ; for ( ; ; ) { if ( c == < || c == 0 ) { back ( ) ; return sb . toString ( ) . trim ( ) ; } if ( c == & ) { sb . append ( nextEntity ( c ) ) ; } else { sb . append ( c ) ; } c = next ( ) ; } }
tr	7	public static String [ ] delimitedListToStringArray ( String str , String delimiter , String charsToDelete ) { if ( str == null ) { return new String [ 0 ] ; } if ( delimiter == null ) { return new String [ ] { str } ; } List < String > result = new ArrayList < String > ( ) ; if ( "" . equals ( delimiter ) ) { for ( int i = 0 ; i < str . length ( ) ; i ++ ) { result . add ( deleteAny ( str . substring ( i , i + 1 ) , charsToDelete ) ) ; } } else { int pos = 0 ; int delPos ; while ( ( delPos = str . indexOf ( delimiter , pos ) ) != - 1 ) { result . add ( deleteAny ( str . substring ( pos , delPos ) , charsToDelete ) ) ; pos = delPos + delimiter . length ( ) ; } if ( str . length ( ) > 0 && pos <= str . length ( ) ) { result . add ( deleteAny ( str . substring ( pos ) , charsToDelete ) ) ; } } return toStringArray ( result ) ; }
tr	2	public double getDouble ( int index ) throws JSONException { Object object = this . get ( index ) ; try { return object instanceof Number ? ( ( Number ) object ) . doubleValue ( ) : double . parseDouble ( ( String ) object ) ; } catch ( Exception e ) { throw new JSONException ( "JSONArray[" + index + "] is not a number." ) ; } }
tr	5	private void howMany ( int [ ] [ ] paper , int n1 , int n2 , int m1 , int m2 ) { if ( counter . contains ( Arrays . asList ( n1 , n2 , m1 , m2 ) ) ) return ; counter . add ( Arrays . asList ( n1 , n2 , m1 , m2 ) ) ; for ( int d = m1 ; d <= m2 - 1 ; d ++ ) { if ( foldsVertically ( paper , n1 , n2 , m1 , m2 , d ) ) { if ( d <= ( m1 + m2 - 1 ) / 2 ) { howMany ( paper , n1 , n2 , d + 1 , m2 ) ; } if ( d >= ( m1 + m2 - 1 ) / 2 ) { howMany ( paper , n1 , n2 , m1 , d ) ; } } } }
tr	9	public String toUpdateKML ( boolean suppressEnclosingTags ) { if ( ! isDirty ( ) ) { return "" ; } String change = "" ; boolean isPrimDirty = isPrimitiveDirty ( ) ; if ( isPrimDirty && ! suppressEnclosingTags ) { change += "<Placemark" ; if ( this . id != null ) { change += " id=\"" + this . getId ( ) + "\"" ; } if ( this . targetId != null ) { change += " targetId=\"" + this . getTargetId ( ) + "\"" ; } change += ">\n" ; } change += super . toUpdateKML ( true ) ; if ( this . geometry != null && this . geometry . isDirty ( ) ) { change += this . geometry . toUpdateKML ( ) ; } if ( isPrimDirty && ! suppressEnclosingTags ) { change += "</Placemark>\n" ; } setNotDirty ( ) ; return change ; }
tr	8	@ Override public boolean isNonRotatableComponentOnBoard ( int x , int y ) { if ( ( y > 1 && y < 12 ) && ( x > 1 && x < 12 ) ) { System . out . println ( "if false. (x y): " + x + " " + y ) ; return false ; } else if ( x < 0 || x > 13 ) { return false ; } else if ( y < 0 || y > 13 ) { return false ; } else { System . out . println ( "(In SelPlaDev) component on board valid" ) ; return true ; } }
tr	5	public boolean crearLink ( String nombre , String usuario , String password , String host , String port , String serviceName ) throws GlobalException , NoDataException , SQLException { boolean exito = false ; try { conectar ( user , pass , ip , port , db ) ; } catch ( ClassNotFoundException ex ) { exito = false ; } ResultSet rs = null ; PreparedStatement stmt = null ; try { String query = "CREATE DATABASE LINK " + nombre + " CONNECT TO " + usuario + " IDENTIFIED BY " + password + " USING '(DESCRIPTION = (ADDRESS = (PROTOCOL = TCP)(HOST = " + host + " )(PORT = " + port + " ))(CONNECT_DATA =(SERVER = DEDICATED)(SERVICE_NAME = " + serviceName + " )))'" ; stmt = conexion . prepareStatement ( query ) ; System . out . println ( query ) ; stmt . executeQuery ( ) ; exito = true ; } catch ( SQLException e ) { exito = false ; e . printStackTrace ( ) ; throw new GlobalException ( "Sentencia no valida" ) ; } finally { try { if ( rs != null ) { rs . close ( ) ; } if ( stmt != null ) { stmt . close ( ) ; } desconectar ( ) ; } catch ( SQLException e ) { throw new GlobalException ( "Estatutos invalidos o nulos" ) ; } } return exito ; }
tr	7	private double findMax ( Cut cut , int offset , double max ) { if ( cut . getSubCut ( ) == null ) { int last = cut . getEnd ( ) + offset ; for ( int i = cut . getStart ( ) + offset ; i < last ; i += cut . getStepSize ( ) ) { int j = getRealPosition ( i ) ; if ( values . getDouble ( j ) != double . NEGATIVE_INFINITY && Math . abs ( values . getDouble ( j ) ) > Math . abs ( max ) ) { max = values . getDouble ( j ) ; } } } else { Cut c = cut . getSubCut ( ) ; for ( int i = 0 ; i < cut . getLength ( ) ; i += cut . getSubtreeStepsize ( ) ) { double pot = findMax ( c , offset + i , max ) ; if ( pot != double . NEGATIVE_INFINITY && Math . abs ( pot ) > Math . abs ( max ) ) { max = pot ; } } } return max ; }
tr	0	public Client ( String dni , String nom , String cognoms , String email ) { this . dni = dni ; this . nom = nom ; this . cognoms = cognoms ; this . email = email ; }
tr	2	public long getLong ( int index ) throws JSONException { Object object = this . get ( index ) ; try { return object instanceof Number ? ( ( Number ) object ) . longValue ( ) : long . parseLong ( ( String ) object ) ; } catch ( Exception e ) { throw new JSONException ( "JSONArray[" + index + "] is not a number." ) ; } }
tr	3	@ Override protected final String [ ] getParameters ( String tcpMessage ) { String [ ] s = new String [ 0 ] ; int i = tcpMessage . indexOf ( "(" ) ; int f = tcpMessage . indexOf ( ")" ) ; if ( i > 0 && f > 0 && f - i > 1 ) { String - = tcpMessage . substring ( i + 1 , f ) ; s = - . split ( ";" ) ; } return s ; }
tr	9	public void dumpCSV ( String fName , String sep , HackFilter ... filters ) throws IOException { LinkedHashSet < String > patterns = new LinkedHashSet < > ( ) ; LinkedHashSet < String > rares = new LinkedHashSet < > ( ) ; outerloop1 : for ( HackResult hackResult : allHacks ) { for ( HackFilter fi : filters ) if ( ! fi . accept ( hackResult ) ) continue outerloop1 ; String pat = smallPattern ( hackResult ) ; patterns . add ( pat ) ; List < String > items = rareItems ( hackResult ) ; rares . addAll ( items ) ; } PrintWriter pw = new PrintWriter ( new FileWriter ( new File ( fName ) ) ) ; pw . print ( "# " ) ; for ( HackFilter f : filters ) pw . print ( " " + f . toString ( ) ) ; pw . println ( ) ; pw . print ( "# " ) ; for ( String s : patterns ) pw . print ( " " + s ) ; pw . print ( "  " ) ; for ( String s : rares ) pw . print ( " " + s ) ; pw . println ( ) ; outerloop2 : for ( HackResult hackResult : allHacks ) { for ( HackFilter fi : filters ) if ( ! fi . accept ( hackResult ) ) continue outerloop2 ; String pat = smallPattern ( hackResult ) ; List < String > items = rareItems ( hackResult ) ; pw . print ( String . format ( "%10.0f" , hackResult . timestamp ) ) ; for ( String s : patterns ) { pw . print ( sep ) ; pw . print ( pat . equals ( s ) ? 1 : 0 ) ; } pw . print ( "  " ) ; for ( String s : rares ) { pw . print ( sep ) ; pw . print ( items . contains ( s ) ? 1 : 0 ) ; } pw . println ( ) ; } pw . close ( ) ; L . info ( "Finished <" + fName + ">." ) ; }
tr	5	public void iniciar ( ) { JPanel panel = new JPanel ( ) ; getContentPane ( ) . add ( panel ) ; panel . setLayout ( null ) ; JLabel vermelho = new JLabel ( "Vermelho:" ) ; vermelho . setBounds ( 5 , 0 , 80 , 30 ) ; vermelho . setFont ( new Font ( "Arial" , 1 , 14 ) ) ; JLabel amarelo = new JLabel ( "Laranja:" ) ; amarelo . setBounds ( 5 , 80 , 80 , 30 ) ; amarelo . setFont ( new Font ( "Arial" , 1 , 14 ) ) ; JLabel verde = new JLabel ( "Verde: " ) ; verde . setBounds ( 5 , 160 , 80 , 30 ) ; verde . setFont ( new Font ( "Arial" , 1 , 14 ) ) ; panel . add ( vermelho ) ; panel . add ( amarelo ) ; panel . add ( verde ) ; final JLabel vermelho1 = new JLabel ( "0" ) ; vermelho1 . setBounds ( 80 , 0 , 80 , 30 ) ; vermelho1 . setFont ( new Font ( "Arial" , 1 , 14 ) ) ; final JLabel amarelo1 = new JLabel ( "0" ) ; amarelo1 . setBounds ( 80 , 80 , 80 , 30 ) ; amarelo1 . setFont ( new Font ( "Arial" , 1 , 14 ) ) ; final JLabel verde1 = new JLabel ( "0" ) ; verde1 . setBounds ( 80 , 160 , 80 , 30 ) ; verde1 . setFont ( new Font ( "Arial" , 1 , 14 ) ) ; panel . add ( vermelho1 ) ; panel . add ( amarelo1 ) ; panel . add ( verde1 ) ; final JLabel vermelho2 = new JLabel ( "0" ) ; vermelho2 . setBounds ( 120 , 0 , 80 , 30 ) ; vermelho2 . setFont ( new Font ( "Arial" , 1 , 14 ) ) ; final JLabel amarelo2 = new JLabel ( "0" ) ; amarelo2 . setBounds ( 120 , 80 , 80 , 30 ) ; amarelo2 . setFont ( new Font ( "Arial" , 1 , 14 ) ) ; final JLabel verde2 = new JLabel ( "0" ) ; verde2 . setBounds ( 120 , 160 , 80 , 30 ) ; verde2 . setFont ( new Font ( "Arial" , 1 , 14 ) ) ; panel . add ( vermelho2 ) ; panel . add ( amarelo2 ) ; panel . add ( verde2 ) ; final JLabel vermelho3 = new JLabel ( "0" ) ; vermelho3 . setBounds ( 160 , 0 , 80 , 30 ) ; vermelho3 . setFont ( new Font ( "Arial" , 1 , 14 ) ) ; final JLabel amarelo3 = new JLabel ( "0" ) ; amarelo3 . setBounds ( 160 , 80 , 80 , 30 ) ; amarelo3 . setFont ( new Font ( "Arial" , 1 , 14 ) ) ; final JLabel verde3 = new JLabel ( "0" ) ; verde3 . setBounds ( 160 , 160 , 80 , 30 ) ; verde3 . setFont ( new Font ( "Arial" , 1 , 14 ) ) ; panel . add ( vermelho3 ) ; panel . add ( amarelo3 ) ; panel . add ( verde3 ) ; final JLabel vermelho4 = new JLabel ( "0" ) ; vermelho4 . setBounds ( 200 , 0 , 80 , 30 ) ; vermelho4 . setFont ( new Font ( "Arial" , 1 , 14 ) ) ; final JLabel amarelo4 = new JLabel ( "0" ) ; amarelo4 . setBounds ( 200 , 80 , 80 , 30 ) ; amarelo4 . setFont ( new Font ( "Arial" , 1 , 14 ) ) ; final JLabel verde4 = new JLabel ( "0" ) ; verde4 . setBounds ( 200 , 160 , 80 , 30 ) ; verde4 . setFont ( new Font ( "Arial" , 1 , 14 ) ) ; panel . add ( vermelho4 ) ; panel . add ( amarelo4 ) ; panel . add ( verde4 ) ; setTitle ( "Semaforos" ) ; setSize ( 400 , 400 ) ; setLocationRelativeTo ( null ) ; setDefaultCloseOperation ( EXIT_ON_CLOSE ) ; Semaforo semaforo1 = new Semaforo ( ) ; semaforo1 . setRedText ( vermelho1 ) ; semaforo1 . setOrangeText ( amarelo1 ) ; semaforo1 . setGreenText ( verde1 ) ; semaforo1 . setStatus ( 0 ) ; semaforo1 . start ( ) ; Semaforo semaforo2 = new Semaforo ( ) ; semaforo2 . setRedText ( vermelho2 ) ; semaforo2 . setOrangeText ( amarelo2 ) ; semaforo2 . setGreenText ( verde2 ) ; semaforo2 . setStatus ( 0 ) ; semaforo2 . start ( ) ; Semaforo semaforo3 = new Semaforo ( ) ; semaforo3 . setRedText ( vermelho3 ) ; semaforo3 . setOrangeText ( amarelo3 ) ; semaforo3 . setGreenText ( verde3 ) ; semaforo3 . setStatus ( 2 ) ; semaforo3 . start ( ) ; Semaforo semaforo4 = new Semaforo ( ) ; semaforo4 . setRedText ( vermelho4 ) ; semaforo4 . setOrangeText ( amarelo4 ) ; semaforo4 . setGreenText ( verde4 ) ; semaforo4 . setStatus ( 2 ) ; semaforo4 . start ( ) ; long secondLast = 0 ; int currentSign = 1 ; while ( true ) { long secondNow = System . currentTimeMillis ( ) / 1000 ; if ( secondNow - secondLast >= 10 ) { switch ( currentSign ) { case 1 : semaforo3 . change ( ) ; semaforo4 . change ( ) ; semaforo1 . change ( ) ; semaforo2 . change ( ) ; break ; case 2 : semaforo1 . change ( ) ; semaforo2 . change ( ) ; semaforo3 . change ( ) ; semaforo4 . change ( ) ; break ; default : break ; } secondLast = secondNow ; currentSign ++ ; if ( currentSign == 3 ) currentSign = 1 ; } } }
tr	6	public E fromXmlValue ( String xmlValue ) { if ( xmlValue == null ) { return null ; } for ( E enumValue : this . enumClass . getEnumConstants ( ) ) { XmlEnumValue xmlEnumValue = getXmlEnumValueAnnotation ( enumValue ) ; if ( xmlEnumValue == null && enumValue . name ( ) . equals ( xmlValue ) ) { return enumValue ; } else if ( xmlEnumValue != null && xmlEnumValue . value ( ) . equals ( xmlValue ) ) { return enumValue ; } } throw new IllegalArgumentException ( "No Enum value found with an XML value of " + xmlValue ) ; }
tr	8	private void populateDeclaredFields ( class < ? > modelClass , HashMap < String , Field > modelFields , ArrayList < Field > idField ) { if ( null != modelClass ) { populateDeclaredFields ( modelClass . getSuperclass ( ) , modelFields , idField ) ; for ( Field f : modelClass . getDeclaredFields ( ) ) { String annotationValue = null ; if ( f . isAnnotationPresent ( ModelId . class ) ) { annotationValue = f . getAnnotation ( ModelId . class ) . value ( ) ; assert idField . isEmpty ( ) : "You have more than one ModelId annotation in your model. That's incorrect." ; if ( idField . size ( ) > 0 ) { idField . remove ( 0 ) ; } idField . add ( f ) ; } else if ( f . isAnnotationPresent ( ModelField . class ) ) { annotationValue = f . getAnnotation ( ModelField . class ) . value ( ) ; } else { continue ; } String name = ( null == annotationValue || annotationValue . isEmpty ( ) ) ? f . getName ( ) : annotationValue ; assert ! modelFields . containsKey ( name ) : "This modelField name it's been overridden" ; modelFields . put ( name , f ) ; } } }
tr	4	public void Connect ( ) { try { mServerAddress = InetAddress . getByName ( mServerName ) ; mSocket = new DatagramSocket ( mPort + 2 , mServerAddress ) ; new Thread ( mTimer ) . start ( ) ; new Thread ( new ConnectionListener ( ) ) . start ( ) ; while ( ! mConnected && ! mDisconnected ) { Send ( "connect" ) ; try { Thread . sleep ( 250 ) ; } catch ( Exception e ) { } } } catch ( Exception e ) { e . printStackTrace ( ) ; System . out . println ( "failed to connect" ) ; mDisconnected = true ; } }
tr	0	public void setEngine ( PresidentialRescue game ) { this . game = game ; }
tr	2	private boolean run ( String path ) { try { List < Token > data = Lexer . analyze ( read ( path ) ) ; if ( ! Parser . parse ( data ) ) return false ; return Checker . parse ( data ) ; } catch ( RuntimeException e ) { e . printStackTrace ( ) ; return false ; } }
tr	3	@ Test public void testGetAudioInputStreamWithUnbufferedFlacStream ( ) throws IOException , UnsupportedAudioFileException { final FlacAudioFileReader flacAudioFileReader = new FlacAudioFileReader ( ) ; final File flacTestFile = getFlacTestFile ( "cymbals.flac" ) ; InputStream in = null ; try { in = new FileInputStream ( flacTestFile ) ; assertFalse ( "For this test the stream MUST NOT support mark()" , in . markSupported ( ) ) ; flacAudioFileReader . getAudioInputStream ( in ) ; fail ( "Expected an IOException  because the stream didn't support mark. See AudioSystem#getAudioInputStream(InputStream stream) javadocs for contract" ) ; } catch ( IOException e ) { } finally { if ( in != null ) { try { in . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } } }
tr	1	public static PrivateKey readPrivateKeyFromDER ( String fileName ) { try { InputStream fl = fullStream ( fileName ) ; byte [ ] key = new byte [ fl . available ( ) ] ; KeyFactory kf = KeyFactory . getInstance ( "RSA" ) ; fl . read ( key , 0 , fl . available ( ) ) ; fl . close ( ) ; PKCS8EncodedKeySpec keysp = new PKCS8EncodedKeySpec ( key ) ; PrivateKey privK = kf . generatePrivate ( keysp ) ; return privK ; } catch ( Exception e ) { e . printStackTrace ( ) ; return null ; } }
tr	8	public ArrayList < ArrayList < JavaPlayer >> getPalaceRanks ( JavaCell palace , LinkedList < Developer > gameDevelopers ) { ArrayList < JavaCell > city = getCityFromRootCell ( palace , visitedVillages ) ; HashMap < JavaPlayer , Integer > scores = new HashMap < JavaPlayer , Integer > ( ) ; for ( JavaCell c : city ) { if ( getDeveloperOnCell ( c , gameDevelopers ) != null ) { Developer d = getDeveloperOnCell ( c , gameDevelopers ) ; JavaPlayer p = d . getOwner ( ) ; int rank = c . getElevation ( ) ; if ( ! scores . containsKey ( p ) ) { scores . put ( p , rank ) ; } else { int newRank = c . getElevation ( ) ; if ( newRank > rank ) scores . put ( p , newRank ) ; } } } ArrayList < Integer > values = new ArrayList < Integer > ( ) ; for ( Integer i : scores . values ( ) ) values . add ( i ) ; Collections . sort ( values ) ; Collections . reverse ( values ) ; ArrayList < ArrayList < JavaPlayer >> players = new ArrayList < ArrayList < JavaPlayer >> ( ) ; for ( Integer i : values ) { ArrayList < JavaPlayer > rank = new ArrayList < JavaPlayer > ( ) ; for ( JavaPlayer p : scores . keySet ( ) ) { if ( scores . get ( p ) == i ) rank . add ( p ) ; } players . add ( rank ) ; } return players ; }
tr	7	@ Deprecated static List < Object > graphToRDF ( Map < String , Object > graph , UniqueNamer namer ) { final List < Object > rval = new ArrayList < Object > ( ) ; for ( final String id : graph . keySet ( ) ) { final Map < String , Object > node = ( Map < String , Object > ) graph . get ( id ) ; final List < String > properties = new ArrayList < String > ( node . keySet ( ) ) ; Collections . sort ( properties ) ; for ( String property : properties ) { final Object items = node . get ( property ) ; if ( "@type" . equals ( property ) ) { property = RDF_TYPE ; } else if ( isKeyword ( property ) ) { continue ; } for ( final Object item : ( List < Object > ) items ) { final Map < String , Object > subject = new LinkedHashMap < String , Object > ( ) ; if ( id . indexOf ( "_:" ) == 0 ) { subject . put ( "type" , "blank node" ) ; subject . put ( "value" , namer . getName ( id ) ) ; } else { subject . put ( "type" , "IRI" ) ; subject . put ( "value" , id ) ; } final Map < String , Object > predicate = new LinkedHashMap < String , Object > ( ) ; predicate . put ( "type" , "IRI" ) ; predicate . put ( "value" , property ) ; if ( isList ( item ) ) { listToRDF ( ( List < Object > ) ( ( Map < String , Object > ) item ) . get ( "@list" ) , namer , subject , predicate , rval ) ; } else { final Object object = objectToRDF ( item , namer ) ; final Map < String , Object > tmp = new LinkedHashMap < String , Object > ( ) ; tmp . put ( "subject" , subject ) ; tmp . put ( "predicate" , predicate ) ; tmp . put ( "object" , object ) ; rval . add ( tmp ) ; } } } } return rval ; }
tr	4	@ Override public long read ( DataInputStream in , PassthroughConnection ptc , KillableThread thread , boolean serverToClient , DownlinkState linkState ) { while ( true ) { try { value = in . readLong ( ) ; } catch ( SocketTimeoutException toe ) { if ( timedOut ( thread ) ) { continue ; } return null ; } catch ( IOException e ) { return null ; } super . timeout = 0 ; return value ; } }
tr	3	private void processNumber ( Object value ) { double doubleValue = ( ( Number ) value ) . doubleValue ( ) ; if ( double . isNaN ( average ) ) { average = doubleValue ; min = doubleValue ; max = doubleValue ; sum = doubleValue ; } else { if ( doubleValue < min ) { min = doubleValue ; } if ( doubleValue > max ) { max = doubleValue ; } sum += doubleValue ; average = average + ( doubleValue - average ) / count ; } }
tr	0	@ Override public void setDim ( int dim ) { reset ( ) ; }
tr	7	public boolean setValueAt ( int value , int row , int column ) { if ( ( column >= 0 ) && ( column < this . tableModel . getColumnCount ( ) ) && ( row >= 0 ) && ( row < this . tableModel . getRowCount ( ) ) ) { class < ? extends Object > cell = this . table . getValueAt ( row , column ) . getClass ( ) ; if ( cell . isInstance ( new Integer ( 0 ) ) ) { this . table . setValueAt ( new Integer ( value ) , row , column ) ; return true ; } String classType = cell . toString ( ) ; try { throw new JSTableDataClassException ( "Error assigning value at cell " + row + "  " + column + ". " + "Trying to assign an Integer value of " + value + " to a cell with class " + classType . substring ( 16 , classType . length ( ) ) + "." ) ; } catch ( JSTableDataClassException e ) { e . printStackTrace ( ) ; } } return false ; }
tr	0	public int getIdp ( ) { return this . idp ; }
tr	8	public void sortLabs ( ) { ArrayList < Timeslot > overfilledLabs ; for ( Student s : students ) { if ( ! s . getFlaggedForLabs ( ) ) { s . setAssignedLab ( s . getCombinedLabs ( ) . get ( 0 ) ) ; s . getCombinedLabs ( ) . get ( 0 ) . addStudent ( s ) ; } } Student currentStudent ; overfilledLabs = overFilledLabs ( ) ; while ( ! overfilledLabs . isEmpty ( ) ) { for ( Timeslot t : overfilledLabs ) { for ( int i = t . getPreferredMax ( ) ; i < t . getAssigned ( ) . size ( ) ; i ++ ) { currentStudent = t . getAssigned ( ) . get ( i ) ; if ( currentStudent . getCurrentIndexLabs ( ) + 1 < currentStudent . getCombinedLabs ( ) . size ( ) ) { currentStudent . getCurrentLab ( ) . removeStudent ( currentStudent ) ; currentStudent . incrementIndexLabs ( ) ; currentStudent . getCurrentLab ( ) . addStudent ( currentStudent ) ; currentStudent . setAssignedLab ( currentStudent . getCurrentLab ( ) ) ; } else { if ( currentStudent . getAssignedLab ( ) != null ) { currentStudent . getAssignedLab ( ) . removeStudent ( currentStudent ) ; currentStudent . setAssignedLab ( null ) ; } currentStudent . setFlaggedForLabs ( true ) ; if ( ! flagged . contains ( currentStudent ) ) { flagged . add ( currentStudent ) ; } } } overfilledLabs = overFilledLabs ( ) ; } } }
tr	3	protected void skipComment ( ) throws EOFException { while ( true ) { if ( nextChar ( ) == * ) { if ( nextChar ( ) == / ) { return ; } putBack ( ) ; } } }
tr	2	public static synchronized Singleton getInstance ( ) { if ( uniqueInstance == null ) { synchronized ( Singleton . class ) { if ( uniqueInstance == null ) { uniqueInstance = new Singleton ( ) ; } } } return uniqueInstance ; }
tr	5	public void addNodes ( ArrayList < BusLabel > busesLabel , ArrayList < StationLabel > stationsLabel , ArrayList < SemaphoreLabel > semaphoresLabel , int num ) { int iconHeightMid = 0 ; int iconWidthMid = 0 ; int iconHeight = 0 ; int iconWidth = 0 ; if ( num == 1 ) { removeAll ( ) ; } for ( BusLabel busLabel : busesLabel ) { iconHeight = busLabel . getIcon ( ) . getIconHeight ( ) ; iconWidth = busLabel . getIcon ( ) . getIconWidth ( ) ; iconHeightMid = iconHeight / 2 ; iconWidthMid = iconWidth / 2 ; busLabel . setBounds ( busLabel . getX ( ) - iconWidthMid , BUSES_HEIGTH - iconHeightMid , iconWidth , iconHeight ) ; add ( busLabel ) ; } for ( SemaphoreLabel semaphoreLabel : semaphoresLabel ) { iconHeight = semaphoreLabel . getIcon ( ) . getIconHeight ( ) ; iconWidth = semaphoreLabel . getIcon ( ) . getIconWidth ( ) ; iconHeightMid = iconHeight / 2 ; iconWidthMid = iconWidth / 2 ; if ( semaphoreLabel . getBounds ( ) . y > 100 ) { System . out . println ( semaphoreLabel . getSemaphore ( ) . getId ( ) ) ; } semaphoreLabel . setBounds ( semaphoreLabel . getX ( ) - iconWidthMid , SEMAPHORES_HEIGTH - iconHeightMid , iconWidth , iconHeight ) ; add ( semaphoreLabel ) ; } for ( StationLabel stationLabel : stationsLabel ) { iconHeight = stationLabel . getIcon ( ) . getIconHeight ( ) ; iconWidth = stationLabel . getIcon ( ) . getIconWidth ( ) ; iconHeightMid = iconHeight / 2 ; iconWidthMid = iconWidth / 2 ; stationLabel . setBounds ( stationLabel . getX ( ) - iconWidthMid , STATIONS_HEIGTH - iconHeightMid , iconWidth , iconHeight ) ; add ( stationLabel ) ; } repaint ( ) ; }
tr	2	public void printGlossary ( ) { String title = String . format ( "\nGlossary\n" ) ; logger . write ( title ) ; String body = null ; for ( int i = 0 ; i < allComponents . size ( ) ; i ++ ) { if ( null != allComponents . get ( i ) ) body = String . format ( "\t" + allComponents . get ( i ) . getGlossary ( ) + "\n" ) ; logger . write ( body ) ; } }
tr	2	public String toString ( ) { String s = "{" ; for ( Location loc : getOccupiedLocations ( ) ) { if ( s . length ( ) > 1 ) s += "  " ; s += loc + "=" + get ( loc ) ; } return s + "}" ; }
tr	5	private void loadConfig ( ) { if ( ! ( new File ( this . getDataFolder ( ) , "plugin.yml" ) ) . exists ( ) ) { for ( String [ ] defaultSet : this . defaultConfigValues ) { if ( isInteger ( defaultSet [ 1 ] ) ) this . getConfig ( ) . set ( defaultSet [ 0 ] , Integer . parseInt ( defaultSet [ 1 ] ) ) ; else this . getConfig ( ) . set ( defaultSet [ 0 ] , defaultSet [ 1 ] ) ; } this . saveConfig ( ) ; } if ( ( ! this . getConfig ( ) . contains ( "general.save-interval" ) ) || this . getConfig ( ) . getInt ( "general.save-interval" ) < 60 ) this . getConfig ( ) . set ( "general.save-interval" , 300 ) ; this . saveConfig ( ) ; }
tr	8	public void updateGameLists ( boolean simple , int maxDuration , int numberOfPlayers ) { if ( simple ) { simpleResultgames . clear ( ) ; simpleResultgames . addAll ( allGames ) ; for ( Game game : allGames ) { if ( game . getMin ( ) > numberOfPlayers ) { simpleResultgames . remove ( game ) ; } if ( game . getMax ( ) < numberOfPlayers ) { simpleResultgames . remove ( game ) ; } if ( game . getTime ( ) > maxDuration ) { simpleResultgames . remove ( game ) ; } } } else { complexResultgames . clear ( ) ; for ( Game game : allGames ) { if ( ( game . getMin ( ) <= activePlayers . size ( ) ) && ( game . getMax ( ) >= activePlayers . size ( ) ) ) { complexResultgames . put ( game , getGameScore ( game ) ) ; } } } }
tr	4	private Map fitnessCalculations ( List < Individual > individuals ) { Map statistics = new HashMap ( ) ; double countFitness = 0 ; double maxFitness = 0.0 ; double minFitness = 10.0 ; for ( Individual i : individuals ) { try { countFitness += i . fitness ( ) ; if ( i . fitness ( ) > maxFitness ) { maxFitness = i . fitness ( ) ; statistics . put ( "maxFitness" , maxFitness ) ; statistics . put ( "bestIndividual" , i ) ; } if ( i . fitness ( ) < minFitness ) { minFitness = i . fitness ( ) ; statistics . put ( "minFitness" , minFitness ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } statistics . put ( "avgFitness" , countFitness / individuals . size ( ) ) ; return statistics ; }
tr	9	public boolean tryMove ( double dx , double dy ) { byte ret = this . level . getPhysicHandler ( ) . checkCollision ( level , this , dx , dy ) ; if ( ( ret == WorldPhysicHandler . entityDies ) ) { this . die ( ) ; return false ; } boolean moveUp = false ; if ( ( ret & WorldPhysicHandler . allowedMovementHorizontally ) == 0 ) { this . y -= 1 ; moveUp = ( WorldPhysicHandler . allowedMovementHorizontally & level . getPhysicHandler ( ) . checkCollision ( level , this , dx , dy ) ) != 0 ; if ( moveUp ) { ret = ( byte ) ( WorldPhysicHandler . allowedMovementHorizontally | ret ) ; this . ya -= 35 ; } else { this . y += 1 ; } } boolean vertical = true ; this . onGround = false ; if ( ( ret & WorldPhysicHandler . allowedMovementVertically ) != 0 ) { this . y += dy ; } else { if ( ya >= 0 ) { this . onGround = true ; if ( Math . abs ( ya ) < 3 ) { ya = 0 ; } } this . ya = - this . ya * bounce ; this . y -= dy * bounce ; vertical = false ; } if ( this . y + this . h > this . level . getHeight ( ) ) { this . ya = 0 ; this . onGround = true ; vertical = false ; } boolean horizontal = true ; if ( ( ret & WorldPhysicHandler . allowedMovementHorizontally ) != 0 ) { this . x += dx ; } else { this . xa = - this . xa * bounce ; this . x -= dx * bounce ; horizontal = false ; } return vertical && horizontal ; }
tr	4	public String translate ( String text ) { StringBuilder translated = new StringBuilder ( ) ; for ( int i = 0 ; i < text . length ( ) ; i ++ ) { int pos = text . indexOf ( " " , i ) ; String word ; if ( pos >= 0 ) { word = text . substring ( i , pos ) ; if ( word . equals ( "ZEE" ) ) word = "ZED" ; translated . append ( word ) ; translated . append ( " " ) ; i = pos ; } else { word = text . substring ( i ) ; if ( word . equals ( "ZEE" ) ) word = "ZED" ; translated . append ( word ) ; break ; } } return translated . toString ( ) ; }
