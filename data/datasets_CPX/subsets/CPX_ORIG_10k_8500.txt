te	9	protected static void readRLE ( int width , int height , int colorTable [ ] , int bitCount , int pixels [ ] , DataInputStream in , int imageSize , int pixelSize ) throws IOException { int x = 0 ; int y = height - 1 ; for ( int i = 0 ; i < imageSize ; i ++ ) { int byte1 = in . read ( ) ; int byte2 = in . read ( ) ; i += 2 ; if ( byte1 == 0 ) { if ( byte2 == 0 ) { x = 0 ; y -- ; } else if ( byte2 == 1 ) { return ; } else if ( byte2 == 2 ) { int xoff = ( char ) intelShort ( in . readUnsignedShort ( ) ) ; i += 2 ; int yoff = ( char ) intelShort ( in . readUnsignedShort ( ) ) ; i += 2 ; x += xoff ; y -= yoff ; } else { int whichBit = 0 ; int currByte = in . read ( ) ; i ++ ; for ( int j = 0 ; j < byte2 ; j ++ ) { if ( pixelSize == 4 ) { if ( whichBit == 0 ) { pixels [ y * width + x ] = colorTable [ ( currByte >> 4 ) & f ] ; } else { pixels [ y * width + x ] = colorTable [ currByte & f ] ; currByte = in . read ( ) ; i ++ ; } } else { pixels [ y * width + x ] = colorTable [ currByte ] ; currByte = in . read ( ) ; i ++ ; } x ++ ; if ( x >= width ) { x = 0 ; y -- ; } } if ( ( byte2 & 1 ) == 1 ) { in . read ( ) ; i ++ ; } } } else { for ( int j = 0 ; j < byte1 ; j ++ ) { if ( pixelSize == 4 ) { if ( ( j & 1 ) == 0 ) { pixels [ y * width + x ] = colorTable [ ( byte2 >> 4 ) & f ] ; } else { pixels [ y * width + x + 1 ] = colorTable [ byte2 & f ] ; } } else { pixels [ y * width + x + 1 ] = colorTable [ byte2 ] ; } x ++ ; if ( x >= width ) { x = 0 ; y -- ; } } } } }
te	9	public static void configure ( ) { try { FileInputStream in = new FileInputStream ( "configuration.txt" ) ; BufferedReader bufferIn = new BufferedReader ( new InputStreamReader ( in ) ) ; int beginIndex = 0 ; int endIndex = 0 ; String temp = "" ; String tempIP = "" ; int tempPort = 0 ; int tempQuantity = 0 ; int tempInt = 0 ; ArrayList < Integer > overallPortList = new ArrayList < Integer > ( 4 ) ; tempIP = bufferIn . readLine ( ) ; endIndex = tempIP . indexOf (   , beginIndex ) ; tempIP = tempIP . substring ( beginIndex , endIndex ) ; tempIP . trim ( ) ; temp = bufferIn . readLine ( ) ; endIndex = temp . indexOf (   , beginIndex ) ; temp = temp . substring ( beginIndex , endIndex ) ; temp . trim ( ) ; tempPort = Integer . parseInt ( temp ) ; NAMENODE = new Machine ( InetAddress . getByName ( tempIP ) , tempPort ) ; overallPortList . add ( NAMENODE . port ) ; System . out . println ( "NAMENODE IP is " + NAMENODE . ipAddress + " port is " + NAMENODE . port ) ; temp = bufferIn . readLine ( ) ; endIndex = temp . indexOf (   , beginIndex ) ; temp = temp . substring ( beginIndex , endIndex ) ; temp . trim ( ) ; tempQuantity = Integer . parseInt ( temp ) ; System . out . println ( "DataNode quantity is " + tempQuantity ) ; DATANODES = new ArrayList < Machine > ( ) ; ArrayList < Integer > dataNodePortList = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < tempQuantity ; i ++ ) { tempIP = bufferIn . readLine ( ) ; endIndex = tempIP . indexOf (   , beginIndex ) ; tempIP = tempIP . substring ( beginIndex , endIndex ) ; tempIP . trim ( ) ; temp = bufferIn . readLine ( ) ; endIndex = temp . indexOf (   , beginIndex ) ; temp = temp . substring ( beginIndex , endIndex ) ; temp . trim ( ) ; tempPort = Integer . parseInt ( temp ) ; dataNodePortList . add ( tempPort ) ; Machine machine = new Machine ( InetAddress . getByName ( tempIP ) , tempPort ) ; DATANODES . add ( machine ) ; if ( i == 0 ) { overallPortList . add ( machine . port ) ; } System . out . println ( "DataNode IP is " + machine . ipAddress + " port is " + machine . port ) ; } tempInt = dataNodePortList . get ( 0 ) ; for ( int i = 0 ; i < dataNodePortList . size ( ) ; i ++ ) { if ( tempInt != dataNodePortList . get ( i ) ) { System . out . println ( "Port number of DataNodes must be the same with each other " + " please change configuration file." ) ; System . exit ( 1 ) ; } } tempIP = bufferIn . readLine ( ) ; endIndex = tempIP . indexOf (   , beginIndex ) ; tempIP = tempIP . substring ( beginIndex , endIndex ) ; tempIP . trim ( ) ; temp = bufferIn . readLine ( ) ; endIndex = temp . indexOf (   , beginIndex ) ; temp = temp . substring ( beginIndex , endIndex ) ; temp . trim ( ) ; tempPort = Integer . parseInt ( temp ) ; JOBTRACKER = new Machine ( InetAddress . getByName ( tempIP ) , tempPort ) ; overallPortList . add ( JOBTRACKER . port ) ; System . out . println ( "JOBTRACKER IP is " + JOBTRACKER . ipAddress + " port is " + JOBTRACKER . port ) ; temp = bufferIn . readLine ( ) ; endIndex = temp . indexOf (   , beginIndex ) ; temp = temp . substring ( beginIndex , endIndex ) ; temp . trim ( ) ; tempQuantity = Integer . parseInt ( temp ) ; System . out . println ( "participant node quantity is " + tempQuantity ) ; TASKTRACKERS = new ArrayList < Machine > ( ) ; ArrayList < Integer > participantNodePortList = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < tempQuantity ; i ++ ) { tempIP = bufferIn . readLine ( ) ; endIndex = tempIP . indexOf (   , beginIndex ) ; tempIP = tempIP . substring ( beginIndex , endIndex ) ; tempIP . trim ( ) ; temp = bufferIn . readLine ( ) ; endIndex = temp . indexOf (   , beginIndex ) ; temp = temp . substring ( beginIndex , endIndex ) ; temp . trim ( ) ; tempPort = Integer . parseInt ( temp ) ; participantNodePortList . add ( tempPort ) ; Machine machine = new Machine ( InetAddress . getByName ( tempIP ) , tempPort ) ; TASKTRACKERS . add ( machine ) ; if ( i == 0 ) { overallPortList . add ( machine . port ) ; if ( overallPortList . get ( 0 ) . equals ( overallPortList . get ( 1 ) ) || overallPortList . get ( 0 ) . equals ( overallPortList . get ( 2 ) ) || overallPortList . get ( 0 ) . equals ( overallPortList . get ( 3 ) ) || overallPortList . get ( 1 ) . equals ( overallPortList . get ( 2 ) ) || overallPortList . get ( 1 ) . equals ( overallPortList . get ( 3 ) ) || overallPortList . get ( 2 ) . equals ( overallPortList . get ( 3 ) ) ) { System . out . println ( "Port number of master node  participant node  NameNode and DataNode must be different from each other " + " please change configuration file." ) ; System . exit ( 2 ) ; } } System . out . println ( "TASKTRACKER IP is " + machine . ipAddress + " port is " + machine . port ) ; } tempInt = participantNodePortList . get ( 0 ) ; for ( int i = 0 ; i < participantNodePortList . size ( ) ; i ++ ) { if ( tempInt != participantNodePortList . get ( i ) ) { System . out . println ( "Port number of participant nodes must be the same with each other " + " please change configuration file." ) ; System . exit ( 1 ) ; } } bufferIn . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }
te	2	static public CommandTypes getType ( String command ) { for ( CommandTypes commandType : CommandTypes . values ( ) ) { if ( commandType . getValue ( ) . equals ( command ) ) { return commandType ; } } throw new RuntimeException ( "unknown type" ) ; }
te	1	static void drawThoughtStem ( Graphics g , int x , int y , int w , int h , int tx , int ty ) { for ( int i = 7 ; i > 0 ; i -= 2 ) { int b = border / 2 * ( 16 - i ) / 16 ; int X = x + w / 2 + i * i * ( tx - ( x + w / 2 ) ) / 8 / 8 ; int Y = y + h + ( int ) ( Math . pow ( i / 8. , .8 ) * ( ty - ( y + h ) ) ) ; g . setColor ( Color . white ) ; g . fillOval ( X - b , Y - b , 2 * b , 2 * b ) ; g . setColor ( Color . black ) ; g . drawOval ( X - b , Y - b , 2 * b , 2 * b ) ; } }
te	9	protected static Method findSetter ( String name , class < ? > type , class < ? > self ) { if ( name == null || name . trim ( ) . isEmpty ( ) ) { return null ; } Method [ ] methods = self . getDeclaredMethods ( ) ; for ( Method method : methods ) { if ( ! method . getName ( ) . equals ( name ) ) { continue ; } class < ? > [ ] parameters = method . getParameterTypes ( ) ; if ( parameters . length != 1 ) { continue ; } if ( ClassUtils . isAssignable ( parameters [ 0 ] , type ) ) { return method ; } } return null ; }
te	3	public StringDeconstructor resultant ( ) { String tail = this . tail ; int beginIndex = tail . indexOf ( delimiter ) ; while ( beginIndex == 0 ) { tail = tail . substring ( delimiter . length ( ) ) ; beginIndex = tail . indexOf ( delimiter ) ; } if ( tail . equals ( "" ) ) return null ; if ( beginIndex == - 1 ) return new StringDeconstructor ( tail , "" , delimiter ) ; return new StringDeconstructor ( tail . substring ( 0 , beginIndex ) , tail . substring ( beginIndex ) , delimiter ) ; }
te	8	public static Ranker getRankerByArguments ( CgiArguments arguments , Options options , Indexer indexer ) { switch ( arguments . _rankerType ) { case FULLSCAN : return new RankerFullScan ( options , arguments , indexer ) ; case CONJUNCTIVE : return new RankerConjunctive ( options , arguments , indexer ) ; case FAVORITE : return new RankerFavorite ( options , arguments , indexer ) ; case COSINE : return new RankerCosine ( options , arguments , indexer ) ; case QL : return new RankerQL ( options , arguments , indexer ) ; case PHRASE : return new RankerPhrase ( options , arguments , indexer ) ; case LINEAR : return new RankerLinear ( options , arguments , indexer ) ; case NONE : default : } return null ; }
te	0	public FormFuncionario ( ) { initComponents ( ) ; }
te	1	public double removeKey ( E key ) { double d = entries . remove ( key ) ; return ( d == null ? 0.0 : d ) ; }
te	0	public boolean isCloakable ( ) { return cloakable ; }
te	5	private DefaultMutableTreeNode populateTree ( DefaultMutableTreeNode curNode , File dir ) { if ( dir != null && dir . isDirectory ( ) ) { String [ ] paths = dir . list ( ) ; Arrays . sort ( paths , String . CASE_INSENSITIVE_ORDER ) ; List < DefaultMutableTreeNode > directoryList = new ArrayList < DefaultMutableTreeNode > ( ) ; List < DefaultMutableTreeNode > fileList = new ArrayList < DefaultMutableTreeNode > ( ) ; for ( String fileName : paths ) { File nextFile = new File ( dir . getAbsolutePath ( ) + File . separator + fileName ) ; if ( nextFile . isDirectory ( ) ) { NodeItem nodeItem = new NodeItem ( nextFile ) ; directoryList . add ( populateTree ( new DefaultMutableTreeNode ( nodeItem ) , nextFile ) ) ; } else { if ( fileName . endsWith ( ".sm" ) ) { NodeItem nodeItem = new NodeItem ( nextFile ) ; fileList . add ( populateTree ( new DefaultMutableTreeNode ( nodeItem ) , nextFile ) ) ; } } } addAll ( curNode , directoryList ) ; addAll ( curNode , fileList ) ; } return curNode ; }
te	7	public List < Entity > getEntities ( int x1 , int y1 , int x2 , int y2 ) { int temp ; if ( x1 > x2 ) { temp = x1 ; x1 = x2 ; x2 = temp ; } if ( y1 > y2 ) { temp = y1 ; y1 = y2 ; y2 = temp ; } ArrayList < Entity > presentEntities = new ArrayList < Entity > ( ) ; for ( Entry < Integer , Entity > e : entities . entrySet ( ) ) { WorldLocation l = e . getValue ( ) . getLocation ( ) ; if ( l . x >= x1 && l . x <= x2 && l . y >= y1 && l . y <= y2 ) { presentEntities . add ( e . getValue ( ) ) ; } } Collections . sort ( presentEntities ) ; return presentEntities ; }
te	7	public boolean tarkistaYhtenaisyys ( Palikka palikka ) { ArrayList < int [ ] > muoto = palikka . getMuoto ( ) ; if ( muoto . isEmpty ( ) ) { return true ; } int i = 0 ; while ( i < muoto . size ( ) ) { int [ ] piste1 = muoto . get ( i ) ; boolean vieruksia = false ; int j = 0 ; while ( j < muoto . size ( ) ) { if ( j != i ) { int [ ] piste2 = muoto . get ( j ) ; if ( onkoVierusPiste ( piste1 , piste2 ) ) { vieruksia = true ; } } if ( vieruksia ) { break ; } j ++ ; } if ( ! vieruksia ) { jaaOsiin ( palikka , i ) ; return false ; } i ++ ; } return true ; }
te	0	public void setEndereco ( Endereco endereco ) { this . endereco = endereco ; }
te	9	public static int Compare ( MessageNumber a , MessageNumber b ) { int result = 0 ; if ( a != b ) { if ( ( ( Object ) a == null ) && ( ( Object ) b != null ) ) { result = - 1 ; } else if ( ( ( Object ) a != null ) && ( ( Object ) b == null ) ) { result = 1 ; } else { if ( a . getProcessID ( ) < b . getProcessID ( ) ) { result = - 1 ; } else if ( a . getProcessID ( ) > b . getProcessID ( ) ) { result = 1 ; } else if ( a . getSequenceNumber ( ) < b . getSequenceNumber ( ) ) { result = - 1 ; } else if ( a . getSequenceNumber ( ) > b . getSequenceNumber ( ) ) { result = 1 ; } } } return result ; }
te	5	public void setUp ( ) { for ( int k = 0 ; k < 4 ; k ++ ) { for ( int i = 0 ; i < 3 ; i ++ ) { for ( int j = 0 ; j < 4 ; j ++ ) { if ( Game . data [ i ] [ j ] == 0 && Game . data [ i + 1 ] [ j ] != 0 ) { Game . data [ i ] [ j ] = Game . data [ i + 1 ] [ j ] ; Game . data [ i + 1 ] [ j ] = 0 ; count = 1 ; } } } } }
te	8	@ SuppressWarnings ( "unchecked" ) private Map < MarketQuotesResponseField , String > getMarketQuotePaths ( Document doc ) throws UtilityException { Map < MarketQuotesResponseField , String > toReturn = new HashMap < MarketQuotesResponseField , String > ( ) ; for ( MarketQuotesResponseField f : MarketQuotesResponseField . values ( ) ) { String [ ] paths = f . getPaths ( ) ; if ( f . equals ( MarketQuotesResponseField . ERROR ) ) { if ( paths != null ) { for ( String path : paths ) { List < DefaultElement > list = doc . selectNodes ( path ) ; for ( Iterator < DefaultElement > iter = list . iterator ( ) ; iter . hasNext ( ) ; ) { DefaultElement attribute = iter . next ( ) ; String url = attribute . getText ( ) ; throw new UtilityException ( url ) ; } } } } if ( paths != null ) { for ( String path : paths ) { List < DefaultElement > list = doc . selectNodes ( path ) ; for ( Iterator < DefaultElement > iter = list . iterator ( ) ; iter . hasNext ( ) ; ) { DefaultElement attribute = iter . next ( ) ; String url = attribute . getText ( ) ; toReturn . put ( f , url ) ; } } } } return toReturn ; }
te	3	@ Override public void mouseDragged ( MouseEvent evt ) { if ( ( evt . getModifiers ( ) & 16 ) == 0 ) { return ; } updateGridCoords ( ) ; fgx = evt . getX ( ) ; fgy = evt . getY ( ) ; moveView ( fgx , fgy ) ; int fx = ( sgx < fgx ) ? sgx : fgx ; int fy = ( sgy < fgy ) ? sgy : fgy ; int w = Math . abs ( sgx - fgx ) ; int h = Math . abs ( sgy - fgy ) ; static . viewport . selectUnits ( getWorldArea ( fx , fy , w , h ) ) ; }
te	3	@ Override public void run ( ) { try { for ( int i = 0 ; i < 20 ; i ++ ) { synchronized ( StaticVariableSyn . class ) { staticInt ++ ; if ( staticInt == 10 ) { Thread . sleep ( 5000 ) ; } System . err . println ( "[" + Thread . currentThread ( ) . getId ( ) + "]\u5F53i=" + i + "\u83B7\u53D6staticInt \u7684\u503C:" + staticInt ) ; } } } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } }
te	8	@ Override public ContainerRequest filter ( ContainerRequest containerRequest ) { String method = containerRequest . getMethod ( ) ; String path = containerRequest . getPath ( true ) ; String UUID = containerRequest . getQueryParameters ( ) . getFirst ( "UUID" ) ; System . out . println ( "Auth-method: " + method ) ; System . out . println ( "Auth-path: " + path ) ; System . out . println ( "Auth-UUID: " + UUID ) ; if ( path . equals ( "application.wadl" ) || path . equals ( "application.wadl/xsd0.xsd" ) || path . equals ( "Login" ) || path . contains ( "Registro" ) ) { System . out . println ( "Auth:Public" ) ; return containerRequest ; } else if ( UUID == null ) { System . out . println ( "Auth:UUID Null" ) ; throw new WebApplicationException ( Status . UNAUTHORIZED ) ; } UsuarioModel user = BasicAuth . getUser ( UUID ) ; if ( user == null ) { System . out . println ( "Auth:User Null" ) ; throw new WebApplicationException ( Status . UNAUTHORIZED ) ; } else if ( path . contains ( "Generos" ) && user . getRole ( ) != UsuarioModel . ADMIN_ROLE ) { System . out . println ( "Auth:Role !=" ) ; throw new WebApplicationException ( Status . UNAUTHORIZED ) ; } System . out . println ( "Auth:Pass" ) ; return containerRequest ; }
te	7	private FeatureVector getdW2 ( int k , SRLFeatureData sfd , DependencyInstance gold , DependencyInstance pred ) { double [ ] [ ] wpU = sfd . wpU , wpV = sfd . wpV , ppW = sfd . ppW , cpX = sfd . cpX ; FeatureVector dW2 = new FeatureVector ( D2 ) ; int F = pred . numframes , N = pred . length , L = sfd . L ; for ( int i = 0 ; i < F ; ++ i ) { SemanticFrame frame = gold . frames [ i ] ; SemanticFrame frame2 = pred . frames [ i ] ; int p = frame . predid ; for ( int a = 0 ; a < N ; ++ a ) { if ( frame . arglbids [ a ] == frame2 . arglbids [ a ] ) continue ; boolean isValid = ! sfd . isPruned ( p , a ) ; { int r = frame . arglbids [ a ] ; if ( isValid && r >= 0 ) { int id = i * N * L + a * L + r ; double . = wpU [ p ] [ k ] * wpV [ a ] [ k ] * cpX [ id ] [ k ] ; dW2 . addEntries ( sfd . pathFvs [ id ] , . ) ; } } { int r = frame2 . arglbids [ a ] ; if ( isValid && r >= 0 ) { int id = i * N * L + a * L + r ; double . = wpU [ p ] [ k ] * wpV [ a ] [ k ] * cpX [ id ] [ k ] ; dW2 . addEntries ( sfd . pathFvs [ id ] , - . ) ; } } } } return dW2 ; }
te	6	@ Override public void refresh ( RefreshEvent event ) { LocalGameRefreshEvent ev = ( LocalGameRefreshEvent ) event ; WorldModel wm = ( WorldModel ) ev . getSource ( ) ; int i = ev . getX ( ) ; int j = ev . getY ( ) ; AbstractState s = wm . getState ( i , j ) ; if ( s . getFlag ( ) == AbstractState . HOLLOW_FLAG ) { System . out . printf ( CellView . HOLLOW_FLAG + " " ) ; } else if ( s . getFlag ( ) == AbstractState . MINE_FLAG ) { System . out . printf ( CellView . MINE_FLAG + " " ) ; } else if ( s . getFlag ( ) == AbstractState . TEMP_FLAG ) { System . out . printf ( CellView . TEMP_FLAG + " " ) ; } else if ( s . getValue ( ) == AbstractState . MINE_VALUE ) { System . out . printf ( CellView . MINE_SYMBOL + " " ) ; } else if ( s . getValue ( ) == AbstractState . EMPTY_CELL_VALUE ) { int neighborMineCount = s . getNeighborMineCount ( ) ; if ( neighborMineCount > 0 ) { System . out . printf ( Integer . toString ( neighborMineCount ) + " " ) ; } else { System . out . printf ( CellView . EMPTY_CELL_SYMBOL + " " ) ; } } }
te	5	public void paintComponent ( Graphics g ) { requestFocus ( ) ; this . g2 = ( Graphics2D ) g ; setPreferredSize ( new Dimension ( i_nbCaseWidth * i_sizeSquare , i_nbCaseHeight * i_sizeSquare ) ) ; g2 . setColor ( new Color ( 238 , 238 , 238 ) ) ; g2 . fillRect ( 0 , 0 , this . getWidth ( ) , this . getHeight ( ) ) ; createBackGround ( ) ; drawBackground ( ) ; if ( hasMooved && ctrl . getPolygonMouse ( ) != null ) { createTabPoints ( ctrl . getPolygonMouse ( ) ) ; drawPolygon ( g2 , ctrl . getPolygonMouse ( ) , Color . ORANGE , true ) ; } if ( ctrl . getPolygonBegin ( ) != null ) { createTabPoints ( ctrl . getPolygonBegin ( ) ) ; drawPolygon ( g2 , ctrl . getPolygonBegin ( ) , Color . GREEN , true ) ; } if ( ctrl . getPolygonEnd ( ) != null ) { createTabPoints ( ctrl . getPolygonEnd ( ) ) ; drawPolygon ( g2 , ctrl . getPolygonEnd ( ) , Color . RED , true ) ; } if ( ctrl . getListPointToDraw ( ) != null ) { drawWay ( ) ; } }
te	6	private void goRoom ( Command command ) { if ( ! command . hasSecondWord ( ) ) { setChanged ( ) ; notifyObservers ( "Go where?" ) ; return ; } String direction = command . getSecondWord ( ) ; if ( direction . equals ( "straight" ) ) { direction = player1 . getLookingDirection ( ) ; } Room nextRoom = player1 . getCurrentPlayerRoom ( ) . getExit ( direction ) ; if ( nextRoom == null ) { setChanged ( ) ; notifyObservers ( "There is no door!" ) ; } else if ( player1 . getCurrentPlayerRoom ( ) . getWall ( direction ) . getMonster ( ) != null && player1 . getCurrentPlayerRoom ( ) . getWall ( direction ) . getMonster ( ) . isAlive ( ) && ! player1 . hasPogoStick ( ) ) { setChanged ( ) ; notifyObservers ( "Cannot go through that door! There is a monster in the way" ) ; } else { player1 . setCurrentRoom ( nextRoom ) ; nextRoom . visit ( ) ; } }
te	7	private HashMap < Integer , Set < Guard >> combineGuards ( HashMap < Integer , Set < Guard >> guard1 , HashMap < Integer , Set < Guard >> guard2 , int size ) { HashMap < Integer , Set < Guard >> newGuard = new HashMap < Integer , Set < Guard >> ( ) ; for ( int i = 0 ; i < size ; i ++ ) { if ( guard1 != null && guard1 . containsKey ( i ) ) { if ( guard2 != null && guard2 . containsKey ( i ) ) { Set < Guard > g = guard1 . get ( i ) ; g . addAll ( guard2 . get ( i ) ) ; newGuard . put ( i , g ) ; } else { newGuard . put ( i , guard1 . get ( i ) ) ; } } else if ( guard2 != null && guard2 . containsKey ( i ) ) { newGuard . put ( i , guard2 . get ( i ) ) ; } } return newGuard ; }
te	4	public boolean blocks ( Entity e ) { if ( e == owner ) return false ; if ( e instanceof Bullet ) return false ; if ( e instanceof Mob && ( ( Mob ) e ) . team == owner . team ) return false ; return true ; }
te	5	private boolean isBeginMeasure ( int i ) { double d = 0 ; int id = 0 ; for ( int j = 0 ; j < i ; j ++ ) { d += rhythms . get ( j ) . getDuration ( ) ; } id = ( int ) Math . round ( d ) ; int tmpnum = 4 ; if ( selectedGame == RHYTHMREADING ) { tmpnum = rhythmLevel . getTimeSignNumerator ( ) ; rhythmLevel . getTimeSignDenominator ( ) ; rhythmLevel . getTimeDivision ( ) ; } else if ( selectedGame == SCOREREADING ) { tmpnum = scoreLevel . getTimeSignNumerator ( ) ; scoreLevel . getTimeSignDenominator ( ) ; scoreLevel . getTimeDivision ( ) ; } boolean reponse = false ; for ( int k = 1 ; k < tmpnum * 2 ; k ++ ) { if ( id == tmpnum * k ) { reponse = true ; } } return reponse ; }
te	5	@ Override public synchronized void fireSound ( SoundEvent s ) { Integer id = s . getEventMark ( ) ; String d = s . getDescription ( ) ; if ( d == null ) { if ( factories . containsKey ( id ) ) playing = factories . get ( id ) . getSoundSourceInstance ( ) ; else playing = null ; } else try { playing = factories . get ( id ) . getSoundSourceInstance ( d ) ; } catch ( UnsupportedOperationException e ) { playing = factories . get ( id ) . getSoundSourceInstance ( ) ; } if ( playing != null && playing . getChannelCount ( ) != channelCount ) playing = null ; }
te	4	void print ( Node t , int n , boolean p ) { if ( ! p ) System . out . print ( "(" ) ; System . out . print ( "if " ) ; if ( t . getCdr ( ) != null ) { t . getCdr ( ) . getCar ( ) . print ( n + 4 , false ) ; System . out . println ( ) ; if ( t . getCdr ( ) . getCdr ( ) != null ) printElements ( ( Cons ) t . getCdr ( ) . getCdr ( ) , n + 4 , false ) ; } for ( int i = 0 ; i < n ; i ++ ) System . out . print ( " " ) ; System . out . print ( ")" ) ; }
te	5	private int getAsignadaTotal ( final Collection < Integer > idactividades ) { int total = 0 ; if ( idactividades . isEmpty ( ) ) { return 0 ; } String txt = idactividades . toString ( ) ; txt = StringUtils . AfterFirst ( txt , "[" ) ; txt = StringUtils . BeforeLast ( txt , "]" ) ; String SQL1 = "SELECT COUNT(idActividades) AS total FROM actividadesalumno " + " WHERE idActividades IN (" + txt + ") GROUP BY matriculado" ; try { Statement st = getSgd ( ) . createStatement ( ) ; ResultSet rs1 = getSgd ( ) . getResultSet ( SQL1 , st ) ; while ( rs1 != null && rs1 . next ( ) ) { total = rs1 . getInt ( "total" ) ; } if ( rs1 != null ) { rs1 . close ( ) ; st . close ( ) ; } } catch ( SQLException ex ) { Logger . getLogger ( ActividadesCollection . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } return total ; }
te	5	public static Integer [ ] [ ] min ( Integer [ ] [ ] ... matrices ) { int r = matrices [ 0 ] . length ; int c = matrices [ 0 ] [ 0 ] . length ; Integer [ ] [ ] maxMatrix = new Integer [ r ] [ c ] ; for ( int i = 0 ; i < r ; i ++ ) { for ( int j = 0 ; j < c ; j ++ ) { Integer _min = Integer . MAX_VALUE ; for ( Integer [ ] [ ] matrix : matrices ) { try { _min = matrix [ i ] [ j ] < _min ? matrix [ i ] [ j ] : _min ; } catch ( ArrayIndexOutOfBoundsException e ) { e . printStackTrace ( ) ; } } maxMatrix [ i ] [ j ] = _min ; } } return maxMatrix ; }
te	4	@ Override public AmbienteExecucao executar ( AmbienteExecucao ambiente ) throws IdentificadorJaDeclaradoException , IdentificadorNaoDeclaradoException { if ( expressaoLoop . avaliar ( ambiente ) instanceof ValorBooleano ) { while ( ( ( ValorBooleano ) expressaoLoop . avaliar ( ambiente ) ) . valor ( ) ) { ambiente = comandoExecucao . executar ( ambiente ) ; } } else if ( expressaoLoop . avaliar ( ambiente ) instanceof ValorInteiro ) { for ( int i = 0 ; i < ( ( ValorInteiro ) expressaoLoop . avaliar ( ambiente ) ) . valor ( ) ; i ++ ) { ambiente = comandoExecucao . executar ( ambiente ) ; } } return ambiente ; }
te	7	private static String removeAreas ( final String str , final String start , final String end ) { final StringBuilder sbRet = new StringBuilder ( ) ; if ( str != null ) { int iOffset = 0 ; int iStart = str . indexOf ( start , iOffset ) ; int iEnd = - 1 ; while ( iStart != - 1 ) { if ( iOffset == iStart && sbRet . length ( ) > 0 && ! Character . isWhitespace ( sbRet . charAt ( sbRet . length ( ) - 1 ) ) ) { sbRet . append (   ) ; } sbRet . append ( str . substring ( iOffset , iStart ) ) ; iEnd = str . indexOf ( end , iStart + start . length ( ) ) ; if ( iEnd != - 1 ) { iOffset = iEnd + end . length ( ) ; iStart = str . indexOf ( start , iOffset ) ; } else { iOffset = str . length ( ) ; iStart = - 1 ; } } sbRet . append ( str . substring ( iOffset ) ) ; } return ( str == null ? null : sbRet . toString ( ) ) ; }
te	9	public static void keyPressed ( KeyEvent e ) { int key = e . getKeyCode ( ) ; if ( key == KeyEvent . VK_LEFT ) { dx = - 1 ; direction = 1 ; } if ( key == KeyEvent . VK_RIGHT ) { dx = 1 ; direction = 2 ; } if ( key == KeyEvent . VK_UP ) { dy = - 1 ; direction = 3 ; } if ( key == KeyEvent . VK_DOWN ) { dy = 1 ; direction = 0 ; } if ( key == KeyEvent . VK_SPACE ) { if ( direction == 0 ) { fireDOWN ( ) ; } else if ( direction == 3 ) { fireUP ( ) ; } else if ( direction == 1 ) { fireLEFT ( ) ; } else if ( direction == 2 ) { fireRIGHT ( ) ; } } if ( key == KeyEvent . VK_ALT && specialweapon == true ) { specialweapon = false ; } else if ( key == KeyEvent . VK_ALT ) { specialweapon = true ; } if ( key == KeyEvent . VK_ENTER ) { SpawnEnemys ( ) ; } }
te	7	@ Override public Object invoke ( Object proxy , Method method , Object [ ] args ) throws Throwable { validate ( proxy , method , args ) ; CacheResult cacheResult = method . getAnnotation ( CacheResult . class ) ; if ( cacheResult != null ) { Map < String , Object > cache = getCache ( cacheResult . cacheName ( ) ) ; String key = getCacheKey ( args ) ; Object result = cache . get ( key ) ; if ( result != null ) { return result ; } result = invokeSql ( proxy , method , args ) ; if ( result != null ) { cache . put ( key , result ) ; } return result ; } Object result = invokeSql ( proxy , method , args ) ; CacheRemoveEntry cacheRemoveEntry = method . getAnnotation ( CacheRemoveEntry . class ) ; if ( cacheRemoveEntry != null ) { String cacheNames = cacheRemoveEntry . cacheName ( ) ; for ( String cacheName : COMMA_PATTERN . split ( cacheNames ) ) { Map < String , Object > cache = getCache ( cacheName ) ; String key = getCacheKey ( args ) ; cache . remove ( key ) ; } } else { CachePut cachePut = method . getAnnotation ( CachePut . class ) ; if ( cachePut != null ) { String cacheNames = cachePut . cacheName ( ) ; for ( String cacheName : COMMA_PATTERN . split ( cacheNames ) ) { Map < String , Object > cache = getCache ( cacheName ) ; String key = getCacheKey ( args ) ; cache . remove ( key ) ; } } } return result ; }
te	8	public static Message Deserialize ( String raw ) { logger . info ( "deserialize '" + raw + "'" ) ; int typeSeperator = - 1 ; typeSeperator = raw . indexOf ( Message . FIELD_SEPERATOR ) ; if ( typeSeperator == - 1 ) typeSeperator = raw . indexOf ( Message . MESSAGE_SPERATOR ) ; if ( typeSeperator == - 1 ) { logger . warning ( "Can't deserialize raw message '" + raw + "'" ) ; return null ; } String typeField = raw . substring ( 0 , typeSeperator ) ; switch ( typeField . toUpperCase ( ) ) { case PeerDiscoveryMessage . TYPE_FIELD_HI : return DeserializePeerDiscoveryMessage ( PeerDiscoveryMessage . DiscoveryMessageType . HI , raw . substring ( typeSeperator + 1 ) ) ; case ByeMessage . TYPE_FIELD : return new ByeMessage ( ) ; case PeerDiscoveryMessage . TYPE_FIELD_YO : return DeserializePeerDiscoveryMessage ( PeerDiscoveryMessage . DiscoveryMessageType . YO , raw . substring ( typeSeperator + 1 ) ) ; case FileAnnouncementMessage . TYPE_FIELD : return DeserializeFileMessage ( raw . substring ( typeSeperator + 1 ) ) ; case GetFileMessage . TYPE_FIELD : return DeserializeGetFileMessage ( raw . substring ( typeSeperator + 1 ) ) ; case GetFilelistMessage . TYPE_FIELD : return new GetFilelistMessage ( ) ; default : logger . warning ( "I don't unterstand the following message: '" + raw + "' :(" ) ; return null ; } }
te	2	void removeNullValues ( int firstidx ) { for ( int i = firstidx ; i < size ; i ++ ) { if ( values [ i ] != null ) { keys [ firstidx ] = keys [ i ] ; values [ firstidx ++ ] = values [ i ] ; } } clear ( firstidx ) ; }
te	4	public boolean [ ] [ ] getUDgraph ( ) { try { int n = Integer . parseInt ( in . readLine ( ) ) ; boolean [ ] [ ] adjacencyMatrix = new boolean [ n ] [ n ] ; String adjacentrow ; for ( int i = 0 ; i < n ; i ++ ) { adjacentrow = in . readLine ( ) ; for ( int j = 0 ; j < n ; j ++ ) if ( adjacentrow . charAt ( j ) == 1 ) adjacencyMatrix [ i ] [ j ] = true ; } return adjacencyMatrix ; } catch ( Exception e ) { System . err . println ( "getUDgraph ERROR:\n" + e ) ; return null ; } }
te	5	public static int dp ( int n ) { if ( n == 0 ) return 0 ; if ( n == 1 ) return 1 ; if ( n == 2 ) return 2 ; if ( n == 3 ) return 4 ; int p = 1 ; int q = 2 ; int r = 4 ; for ( int i = 4 ; i <= n ; i ++ ) { int temp = p + q + r ; p = q ; q = r ; r = temp ; } return r ; }
te	3	public Result EliminarUsuario ( Usuario pusuario ) { ArrayList < Usuario > list = new ArrayList < Usuario > ( ) ; list . add ( new Usuario ( 1 , "MSantiago" ) ) ; list . add ( new Usuario ( 2 , "RMarquezma" ) ) ; list . add ( new Usuario ( 3 , "LupeGonzales" ) ) ; int indexItem = - 1 ; for ( int index = 0 ; index < list . size ( ) ; index ++ ) { if ( list . get ( index ) . getCodigo ( ) == list . get ( index ) . getCodigo ( ) ) { indexItem = index ; } } if ( indexItem > - 1 ) { list . remove ( indexItem ) ; return new Result ( ResultType . Ok , "Usuario eliminado correctamente." , null ) ; } else { return new Result ( ResultType . Ok , "No se encuentra el usuario." , null ) ; } }
te	7	private boolean checkBST ( Node < K , V > node ) { if ( node == null ) return true ; Stack < Node < K , V >> stackLeft = new Stack < Node < K , V >> ( ) ; Stack < Node < K , V >> stackRight = new Stack < Node < K , V >> ( ) ; stackLeft . push ( node ) ; while ( ! stackLeft . isEmpty ( ) ) { Node < K , V > aNode = stackLeft . pop ( ) ; if ( aNode . left != null ) if ( ! ( aNode . key . compareTo ( aNode . left . key ) > 0 ) ) { return false ; } else { stackLeft . push ( aNode . left ) ; } } stackRight . push ( node ) ; while ( ! stackRight . isEmpty ( ) ) { Node < K , V > aNode = stackRight . pop ( ) ; if ( aNode . right != null ) if ( ! ( aNode . key . compareTo ( aNode . right . key ) < 0 ) ) { return false ; } else { stackRight . push ( aNode . right ) ; } } return true ; }
te	8	private void setupData ( int numFiles , int [ ] widths ) { int [ ] inFiles = this . dataFactor . getNumberOfStageInFiles ( numFiles , widths ) ; int inCount = 0 ; for ( int i = 0 ; i < widths . length ; i ++ ) { if ( inFiles [ i ] > 0 ) { List < Job > level = ( List < Job > ) this . levels . get ( i ) ; List < Job > dataIn = new LinkedList < Job > ( ) ; for ( int j = 0 ; j < inFiles [ i ] ; j ++ ) { Job job = new Job ( "dummy" , "In" , "1.0" , String . format ( "%05d" , inCount ) ) ; dataIn . add ( job ) ; inCount ++ ; } connectLevels ( dataIn , level , true ) ; } } int [ ] outFiles = this . dataFactor . getNumberOfStageOutFiles ( numFiles , widths ) ; int outCount = 0 ; for ( int i = 0 ; i < widths . length ; i ++ ) { if ( outFiles [ i ] > 0 ) { List < Job > level = ( List < Job > ) levels . get ( i ) ; int outPerJob = outFiles [ i ] / level . size ( ) ; for ( int j = 0 ; j < level . size ( ) ; j ++ ) { Job job = ( Job ) level . get ( j ) ; for ( int k = 0 ; k < outPerJob ; k ++ ) { job . addUses ( new Filename ( "Out" + String . format ( "%05d" , outCount ) , LFN . OUTPUT ) ) ; outCount ++ ; } } int remaining = outFiles [ i ] - ( outPerJob * level . size ( ) ) ; for ( int j = 0 ; j < remaining ; j ++ ) { int index = ( ( level . size ( ) - remaining ) / 2 ) + j ; Job job = ( Job ) level . get ( index ) ; job . addUses ( new Filename ( "Out" + String . format ( "%05d" , outCount ) , LFN . OUTPUT ) ) ; outCount ++ ; } } } }
te	0	@ Override public IInventory getInventory ( ) { return this ; }
te	3	public static File GetFile ( File Filename , boolean IsFolder ) { try { while ( ! Filename . exists ( ) ) if ( IsFolder ) Filename . mkdir ( ) ; else Filename . createNewFile ( ) ; return Filename ; } catch ( IOException e ) { new SPopup ( new SPopupData ( e ) ) ; return null ; } }
te	7	@ Override public Map < String , Money > getBestCustomer ( DateRange range ) throws Exception { Map < String , Money > all = new HashMap < String , Money > ( ) ; if ( orders . isEmpty ( ) ) throw new NoOrdersException ( ) ; for ( Order o : orders ) { if ( o . getEndTime ( ) != null ) { Money m = new Money ( o . getClosingTotal ( ) ) ; if ( all . containsKey ( o . getCustomerId ( ) ) ) { m . add ( all . get ( o . getCustomerId ( ) ) ) ; } if ( range == null || range . inRange ( o . getEndTime ( ) ) ) { all . put ( o . getCustomerId ( ) , m ) ; } } } if ( all . isEmpty ( ) ) throw new NoOrdersException ( ) ; return getBestFromMap ( all ) ; }
te	1	public final int getCount ( ) { int ret = 0 ; String count = get ( "count_all_games" ) ; if ( count != null ) { ret = Integer . parseInt ( count ) ; } return ret ; }
te	2	public static String getFileContent ( File file ) { try { return FileUtils . readFileToString ( file ) ; } catch ( FileNotFoundException e ) { logger . error ( e . getMessage ( ) , e ) ; return null ; } catch ( IOException e ) { logger . error ( e . getMessage ( ) , e ) ; return null ; } }
te	9	public int spendPoint ( int id , int currentLevel ) { if ( id == Player . MAX_HEALTH_ID ) { if ( this . skillPoints >= ( currentLevel + 1 ) ) { if ( currentLevel < 5 ) { this . skillPoints -= ( currentLevel + 1 ) ; this . maxHealth += Player . MAX_HEALTH_INC ; this . addHealth ( Player . MAX_HEALTH_INC ) ; synchronized ( Globals . GAME_MESSAGES ) { Globals . GAME_MESSAGES . add ( new Message ( "Max Health increased!" , 5000 ) ) ; } return 1 ; } } } else if ( id == Player . DAMAGE_ID ) { if ( this . skillPoints >= ( currentLevel + 1 ) ) { if ( currentLevel < 5 ) { this . skillPoints -= ( currentLevel + 1 ) ; this . damageBonus += Player . DAMAGE_INC ; synchronized ( Globals . GAME_MESSAGES ) { Globals . GAME_MESSAGES . add ( new Message ( "Damage increased!" , 5000 ) ) ; } return 1 ; } } } else if ( id == Player . SPEED_ID ) { if ( this . skillPoints >= ( currentLevel + 1 ) ) { if ( currentLevel < 5 ) { this . skillPoints -= ( currentLevel + 1 ) ; this . speedBonus += Player . SPEED_INC ; synchronized ( Globals . GAME_MESSAGES ) { Globals . GAME_MESSAGES . add ( new Message ( "Speed increased!" , 5000 ) ) ; } return 1 ; } } } return 0 ; }
te	6	public String getUserID ( String username ) { if ( this . user_id > 0 ) return String . valueOf ( this . user_id ) ; else { if ( username != null && username . length ( ) > 0 ) { ClientResponse cresp = service . path ( "/users" ) . queryParam ( "username" , username ) . type ( MediaType . APPLICATION_XML ) . get ( ClientResponse . class ) ; if ( cresp . getStatus ( ) == 200 ) { UserList users_list = cresp . getEntity ( UserList . class ) ; if ( users_list . getUser ( ) . size ( ) == 1 ) { ClientResponse sub_cresp = service . path ( users_list . getUser ( ) . get ( 0 ) . getRef ( ) ) . type ( MediaType . APPLICATION_XML ) . get ( ClientResponse . class ) ; if ( sub_cresp . getStatus ( ) == 200 ) { User user_record = sub_cresp . getEntity ( User . class ) ; user_id = user_record . getId ( ) . intValue ( ) ; return String . valueOf ( this . user_id ) ; } } } } } return null ; }
te	2	protected synchronized void evaluate ( int calculated , int correct ) { if ( calculated == - 1 ) { calculated = correct + 1 ; if ( calculated >= confusionMatrix . getMatrix ( ) . length ) { calculated = correct - 1 ; } } confusionMatrix . add ( correct , calculated , 1 ) ; }
te	7	public void handle ( Input input , Robot robot ) { float moveForce = 50 ; if ( input . isKeyDown ( get_key ( ) ) && robot . getEnergie ( ) > 0 && ! robot . getPlusEnergie ( ) ) { robot . setEnMouvement ( true ) ; robot . applyForce ( moveForce , 0 ) ; } if ( ! input . isKeyDown ( Input . KEY_W ) && robot . getEnergie ( ) > 0 && ! robot . getPlusEnergie ( ) ) { if ( robot . getSaut ( ) ) { robot . setVelocity ( robot . getVelX ( ) , robot . getVelY ( ) * 0.99f ) ; } } }
te	0	public void setStateVector ( StateVector stateVector ) { this . stateVector = stateVector ; }
te	8	private void initRefPanel ( Composite mainPanel ) { refPanel = new Composite ( mainPanel , SWT . NONE ) ; refPanel . setLayout ( new MigLayout ( ) ) ; Label label = new Label ( refPanel , SWT . NONE ) ; label . setText ( "Table: " ) ; refTableNameCombo = new Combo ( refPanel , SWT . DROP_DOWN | SWT . READ_ONLY ) ; TableDef [ ] tableDefs = parentDlg . getMainApp ( ) . getTableDefs ( ) ; refTableNameCombo . setData ( tableDefs ) ; for ( int i = 0 ; i < tableDefs . length ; i ++ ) { refTableNameCombo . add ( tableDefs [ i ] . getName ( ) ) ; } refTableNameCombo . addSelectionListener ( new SelectionAdapter ( ) { public void widgetSelected ( SelectionEvent ev ) { refFieldNameCombo . removeAll ( ) ; TableDef td = ( ( TableDef [ ] ) refTableNameCombo . getData ( ) ) [ refTableNameCombo . getSelectionIndex ( ) ] ; FieldDef [ ] fieldDefs = td . getFields ( ) ; refFieldNameCombo . setData ( fieldDefs ) ; for ( int i = 0 ; i < fieldDefs . length ; i ++ ) { refFieldNameCombo . add ( fieldDefs [ i ] . getName ( ) ) ; } } } ) ; refTableNameCombo . setLayoutData ( "wrap" ) ; label = new Label ( refPanel , SWT . NONE ) ; label . setText ( "Field: " ) ; refFieldNameCombo = new Combo ( refPanel , SWT . DROP_DOWN | SWT . READ_ONLY ) ; ; if ( fieldDef . getContentDef ( ) instanceof ReferenceContentDef ) { ReferenceContentDef cd = ( ReferenceContentDef ) fieldDef . getContentDef ( ) ; TableDef td = cd . getTableDef ( ) ; FieldDef fd = cd . getFieldDef ( ) ; for ( int i = 0 , size = refTableNameCombo . getItemCount ( ) ; i < size ; i ++ ) { if ( refTableNameCombo . getItem ( i ) . equals ( td . getName ( ) ) ) { refTableNameCombo . select ( i ) ; break ; } } refFieldNameCombo . removeAll ( ) ; FieldDef [ ] fieldDefs = td . getFields ( ) ; refFieldNameCombo . setData ( fieldDefs ) ; for ( int i = 0 ; i < fieldDefs . length ; i ++ ) { refFieldNameCombo . add ( fieldDefs [ i ] . getName ( ) ) ; } for ( int i = 0 , size = refFieldNameCombo . getItemCount ( ) ; i < size ; i ++ ) { if ( refFieldNameCombo . getItem ( i ) . equals ( fd . getName ( ) ) ) { refFieldNameCombo . select ( i ) ; break ; } } refPanel . setVisible ( true ) ; } else refPanel . setVisible ( false ) ; }
te	7	@ EventHandler ( priority = EventPriority . NORMAL ) public void onProjectileLaunch ( ProjectileLaunchEvent event ) { Projectile projectile = event . getEntity ( ) ; if ( projectile . getType ( ) != EntityType . THROWN_EXP_BOTTLE || ! ( projectile . getShooter ( ) instanceof Player ) ) return ; Player player = ( Player ) projectile . getShooter ( ) ; ItemStack item = player . getInventory ( ) . getItemInHand ( ) ; if ( item . getType ( ) != Material . EXP_BOTTLE ) return ; ItemMeta meta = item . getItemMeta ( ) ; if ( ! meta . hasLore ( ) ) return ; for ( String s : meta . getLore ( ) ) { if ( s == null ) return ; if ( s . startsWith ( "Level " ) ) { projectile . setMetadata ( "expbottlelevel" , new LevelMetadata ( Integer . parseInt ( s . substring ( s . indexOf (   ) + 1 ) ) ) ) ; } } }
te	3	@ Override public Identifier addBed ( Bed info ) throws DataBaseReadWriteException , IdentifierAlreadyExistsException , InvalidParameterException { Identifier id ; if ( info == null ) { throw new InvalidParameterException ( "input is null" ) ; } String bedId = getUniqueIdForBed ( info ) ; if ( bedId == null ) { throw new InvalidParameterException ( "Invalid Hostel Id or Bed number" ) ; } id = new Identifier ( bedId ) ; if ( Beds . containsKey ( id ) == false ) { Beds . put ( id , new Bed ( info ) ) ; write ( BEDS ) ; return id ; } else { throw new IdentifierAlreadyExistsException ( "Bed Already Exists" ) ; } }
te	9	public boolean simpan ( ) { boolean adaKesalahan = false ; java . sql . Connection cn = null ; try { class . forName ( Koneksi . driver ) ; } catch ( Exception ex ) { adaKesalahan = true ; JOptionPane . showMessageDialog ( null , "JDBC Driver tidak ditemukan atau rusak\n" + ex , "Kesalahan" , JOptionPane . ERROR_MESSAGE ) ; } if ( ! adaKesalahan ) { try { cn = DriverManager . getConnection ( Koneksi . database + "?user=" + Koneksi . user + "&password=" + Koneksi . password + "" ) ; } catch ( Exception ex ) { adaKesalahan = true ; JOptionPane . showMessageDialog ( null , "Koneksi ke " + Koneksi . database + " gagal\n" + ex , "Kesalahan" , JOptionPane . ERROR_MESSAGE ) ; } if ( ! adaKesalahan ) { int jumlahSimpan = 0 ; boolean simpan = false ; try { String SQLStatemen = "select * from buku where kode_buku='" + kodeBuku + "'" ; java . sql . Statement sta = cn . createStatement ( ) ; ResultSet rset = sta . executeQuery ( SQLStatemen ) ; rset . next ( ) ; if ( rset . getRow ( ) > 0 ) { sta . close ( ) ; rset . close ( ) ; Object [ ] arrOpsi = { "Ya" , "Tidak" } ; int pilih = JOptionPane . showOptionDialog ( null , "Kode Buku sudah ada\nApakah data diupdate?" , "Konfirmasi" , JOptionPane . YES_NO_OPTION , JOptionPane . QUESTION_MESSAGE , null , arrOpsi , arrOpsi [ 0 ] ) ; if ( pilih == 0 ) { simpan = true ; SQLStatemen = "update buku set judul_buku='" + judulBuku + "'  penerbit='" + Penerbit + "' where kode_buku='" + kodeBuku + "'" ; sta = cn . createStatement ( ) ; jumlahSimpan = sta . executeUpdate ( SQLStatemen ) ; } } else { sta . close ( ) ; rset . close ( ) ; simpan = true ; SQLStatemen = "insert into buku(kode_buku  judul_buku  penerbit) values ('" + kodeBuku + "' '" + judulBuku + "' '" + Penerbit + "')" ; sta = cn . createStatement ( ) ; jumlahSimpan = sta . executeUpdate ( SQLStatemen ) ; } if ( simpan ) { if ( jumlahSimpan > 0 ) { JOptionPane . showMessageDialog ( null , "Data buku sudah tersimpan" , "Informasi" , JOptionPane . INFORMATION_MESSAGE ) ; } else { adaKesalahan = true ; JOptionPane . showMessageDialog ( null , "Gagal menyimpan data buku" , "Kesalahan" , JOptionPane . ERROR_MESSAGE ) ; } } } catch ( Exception ex ) { adaKesalahan = true ; JOptionPane . showMessageDialog ( null , "Tidak dapat membuka tabel buku\n" + ex , "Kesalahan" , JOptionPane . ERROR_MESSAGE ) ; } } } return ! adaKesalahan ; }
te	6	public static int [ ] sortTwoSortedArrays ( int [ ] a , int [ ] b ) { int [ ] c = new int [ a . length + b . length ] ; int aInd = 0 ; int bInd = 0 ; int cInd = 0 ; while ( cInd < a . length + b . length ) { if ( ( aInd < a . length && bInd < b . length && a [ aInd ] <= b [ bInd ] ) || ( aInd < a . length && bInd >= b . length ) ) { c [ cInd ] = a [ aInd ] ; aInd ++ ; } else { c [ cInd ] = b [ bInd ] ; bInd ++ ; } cInd ++ ; } return c ; }
te	3	public String getUsers ( String username ) { UserList users_arr = new UserList ( ) ; for ( ColourConnection . Users . User curr_user : cc_base . getUsers ( ) . getUser ( ) ) { if ( username == null || curr_user . getUsername ( ) . equalsIgnoreCase ( username ) ) { Ref new_user_ref = new Ref ( ) ; new_user_ref . setId ( curr_user . getId ( ) ) ; new_user_ref . setRef ( "/user/" + curr_user . getId ( ) . toString ( ) ) ; users_arr . getUser ( ) . add ( new_user_ref ) ; } } return marshall ( users_arr ) ; }
te	3	public static < T > T getKeyForMax ( Map < T , ? extends Number > c ) { double max = - double . MAX_VALUE ; T maxKey = null ; for ( T key : c . keySet ( ) ) { Number v = c . get ( key ) ; if ( v . doubleValue ( ) > max ) { max = v . doubleValue ( ) ; maxKey = key ; } } return maxKey ; }
te	7	public synchronized boolean removeDirectory ( String dirname ) throws IOException , ConnectionException { cwd ( dirname ) ; ArrayList < FTPFile > list = list ( ) ; ArrayList < FTPFile > directoriesList = new ArrayList < FTPFile > ( ) ; for ( FTPFile f : list ) { if ( f . isDirectory ( ) ) directoriesList . add ( f ) ; else removeFile ( f . getFilename ( ) ) ; } for ( FTPFile directory : directoriesList ) { if ( ! ( directory . getFilename ( ) . equals ( ".." ) ) ) removeDirectory ( directory . getFilename ( ) ) ; } list = list ( ) ; directoriesList . clear ( ) ; for ( FTPFile f : list ) { if ( f . isDirectory ( ) ) directoriesList . add ( f ) ; else removeFile ( f . getFilename ( ) ) ; } if ( directoriesList . size ( ) == 1 ) { cwd ( ".." ) ; sendLine ( "RMD " + dirname ) ; String response = getAllResponses ( "250" , read . readLine ( ) ) ; return response . startsWith ( "250 " ) ; } return true ; }
te	9	private void calculateUpperTotal ( ) { int upperSupTotal = 0 ; for ( ScoreCardCategories d : ScoreCardCategories . values ( ) ) { if ( d == ScoreCardCategories . ONES || d == ScoreCardCategories . TWOS || d == ScoreCardCategories . THREES || d == ScoreCardCategories . FOURS || d == ScoreCardCategories . FIVES || d == ScoreCardCategories . SIXES ) { if ( scoreCard . get ( d . toString ( ) ) >= 0 ) { upperSupTotal += scoreCard . get ( d . toString ( ) ) ; } } } scoreCard . put ( "UPPERSUBTOTAL" , upperSupTotal ) ; if ( upperSupTotal >= 63 ) { scoreCard . put ( "BONUS" , 35 ) ; scoreCard . put ( "UPPERTOTAL" , 35 + upperSupTotal ) ; } else { scoreCard . put ( "UPPERTOTAL" , upperSupTotal ) ; } }
te	8	public static URL getWebUrl ( Map < String , String [ ] > parameterMap ) throws MalformedURLException { StringBuffer uriSearch = new StringBuffer ( URI_JSON_WEB ) ; for ( String key : parameterMap . keySet ( ) ) { if ( key != null ) { if ( key . equalsIgnoreCase ( PARAM_QUERY ) ) { uriSearch . append ( URI_PARAM_SEP ) . append ( parameterMap . get ( key ) [ 0 ] ) ; } else if ( key . equalsIgnoreCase ( PARAM_USER_IP ) ) { uriSearch . append ( URI_PARAM_SEP ) . append ( parameterMap . get ( key ) [ 0 ] ) ; } else if ( key . equalsIgnoreCase ( PARAM_CONTENT_FILTER ) ) { uriSearch . append ( URI_PARAM_SEP ) . append ( parameterMap . get ( key ) [ 0 ] ) ; } else if ( key . equalsIgnoreCase ( PARAM_LANGUAGE ) ) { uriSearch . append ( URI_PARAM_SEP ) . append ( parameterMap . get ( key ) [ 0 ] ) ; } else if ( key . equalsIgnoreCase ( PARAM_INDEX ) ) { uriSearch . append ( URI_PARAM_SEP ) . append ( parameterMap . get ( key ) [ 0 ] ) ; } else if ( key . equalsIgnoreCase ( PARAM_CUSTOM_FILTER ) ) { uriSearch . append ( URI_PARAM_SEP ) . append ( parameterMap . get ( key ) [ 0 ] ) ; } } } return new URL ( uriSearch . toString ( ) ) ; }
te	3	private boolean promptShiftLeft ( ) { String spriteTypeName = null ; String selectedState = null ; PoseurGUI gui = Poseur . getPoseur ( ) . getGUI ( ) ; AnimatedSpriteViewer view = gui . getAnimametedViewerPanel ( ) ; try { spriteTypeName = view . getJlist ( ) . getSelectedValue ( ) . toString ( ) ; selectedState = view . getCombo ( ) . getSelectedItem ( ) . toString ( ) ; if ( view . getCombo ( ) . getSelectedItem ( ) . toString ( ) . equals ( "NULL" ) || view . getCombo ( ) . getSelectedItem ( ) . toString ( ) . equals ( "Select Animation State" ) ) { throw new NullPointerException ( ) ; } } catch ( NullPointerException e ) { JOptionPane . showMessageDialog ( view , "You did not select either state or sprite type" ) ; return false ; } currentSpriteName = spriteTypeName ; currentFileName = spriteTypeName + SPRITE_FILE_EXTENSION ; currentFile = new File ( SPRITES_PATH + currentFileName ) ; String path = "./data/sprite_types/" + spriteTypeName ; File currentFile3 = new File ( path + "/" + currentFileName ) ; spriteIO . poseShiftLeft ( gui . getID ( ) ) ; saved = true ; String appName = gui . getAppName ( ) ; gui . setTitle ( appName + APP_NAME_FILE_NAME_SEPARATOR + currentFile ) ; Poseur singleton = Poseur . getPoseur ( ) ; return false ; }
te	5	public static void outputAllPairs_hashmap ( List < Stock > stocks , int target ) { Map < Integer , List < Stock >> map = new HashMap < > ( ) ; for ( int i = 0 ; i < stocks . size ( ) ; i ++ ) { Stock si = stocks . get ( i ) ; if ( ! map . containsKey ( si . getValue ( ) ) ) { map . put ( si . getValue ( ) , new ArrayList < > ( ) ) ; } map . get ( si . getValue ( ) ) . add ( si ) ; } for ( int i = 0 ; i < stocks . size ( ) ; i ++ ) { Stock si = stocks . get ( i ) ; int another = target - si . getValue ( ) ; List < Stock > ss = map . get ( another ) ; for ( Stock s : ss ) { if ( ! s . getSymbol ( ) . equals ( si . getSymbol ( ) ) ) { System . out . println ( si . getSymbol ( ) + s . getSymbol ( ) ) ; } } } }
te	6	private void initWindowMenu ( ) { windowMenu = new JMenu ( "Window" ) ; windowMenu . setEnabled ( false ) ; mainMenu . add ( windowMenu ) ; windowInventoryButton = new JMenuItem ( "Inventory" ) ; windowMenu . add ( windowInventoryButton ) ; windowStatsButton = new JMenuItem ( "Stats" ) ; windowMenu . add ( windowStatsButton ) ; windowTextLogButton = new JMenuItem ( "Text Log" ) ; windowMenu . add ( windowTextLogButton ) ; windowInventoryButton . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { EventQueue . invokeLater ( new Runnable ( ) { @ Override public void run ( ) { try { if ( activeInventory == null ) { activeInventory = new InventoryFrame ( ) ; activeInventory . setVisible ( true ) ; } else { activeInventory . requestFocus ( ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } } ) ; } } ) ; windowStatsButton . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { EventQueue . invokeLater ( new Runnable ( ) { @ Override public void run ( ) { try { if ( activeStats == null ) { activeStats = new StatsFrame ( ) ; activeStats . setVisible ( true ) ; } else { activeStats . requestFocus ( ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } } ) ; } } ) ; windowTextLogButton . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { EventQueue . invokeLater ( new Runnable ( ) { @ Override public void run ( ) { try { if ( activeLog == null ) { activeLog = new TextLogFrame ( ) ; activeLog . logTextBox . setText ( loggedMessages ) ; activeLog . setVisible ( true ) ; } else { activeLog . requestFocus ( ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } } ) ; } } ) ; }
te	9	public boolean step ( ) { CodelColor currentColor = mModel . getValue ( mCurrentCodel ) ; boolean whiteCrossed = ( currentColor == CodelColor . WHITE ) ; if ( currentColor == CodelColor . BLACK ) { PolicyStorage . getInstance ( ) . getLogger ( ) . error ( "We are on black hole :)" ) ; return false ; } int weight = 0 ; CodelArea area ; mEdgeCodel . set ( mCurrentCodel ) ; CodelChoser codelChoser = mMachine . getCodelChoser ( ) ; DirectionPointer directionPointer = mMachine . getDirectionPointer ( ) ; for ( int attempt = 0 ; attempt < 8 ; ++ attempt ) { if ( currentColor == CodelColor . WHITE ) { if ( attempt == 0 ) { debugTrace ( "special case: we at a white codel" ) ; } weight = 1 ; } else { area = findCodelArea ( mCurrentCodel ) ; findCodelOnEdge ( area ) ; weight = area . size ; } findNextCodel ( mEdgeCodel ) ; CodelColor nextColor = null ; if ( isValid ( mNextCodel ) ) { nextColor = mModel . getValue ( mNextCodel ) ; } if ( nextColor == CodelColor . WHITE ) { while ( nextColor == CodelColor . WHITE ) { findNextCodel ( mNextCodel ) ; if ( mModel . isValid ( mNextCodel ) == false ) { break ; } nextColor = mModel . getValue ( mNextCodel ) ; } if ( isValid ( mNextCodel ) ) { whiteCrossed = true ; } else { whiteCrossed = true ; nextColor = CodelColor . WHITE ; findPreviousCodel ( mNextCodel ) ; } } if ( isValid ( mNextCodel ) == false ) { if ( currentColor == CodelColor . WHITE ) { codelChoser . switchState ( ) ; directionPointer . rollClockWise ( ) ; debugTrace ( "we in white codel turn dp and cc both" ) ; } else { if ( ( attempt % 2 ) == 0 ) { codelChoser . switchState ( ) ; } else { directionPointer . rollClockWise ( ) ; } } } else { debugTrace ( "step %d current %d %d" , mStepNumber , mCurrentCodel . x , mCurrentCodel . y ) ; mStepNumber ++ ; if ( ! whiteCrossed ) { executeCommand ( mCurrentCodel , mNextCodel , weight ) ; } else { } mCurrentCodel . set ( mNextCodel ) ; return true ; } } return false ; }
te	3	public JSONWriter object ( ) throws JSONException { if ( this . mode == i ) { this . mode = o ; } if ( this . mode == o || this . mode == a ) { this . append ( "{" ) ; this . push ( new JSONObject ( ) ) ; this . , = false ; return this ; } throw new JSONException ( "Misplaced object." ) ; }
te	5	public JSONObject increment ( String key ) throws JSONException { Object value = this . opt ( key ) ; if ( value == null ) { this . put ( key , 1 ) ; } else if ( value instanceof Integer ) { this . put ( key , ( ( Integer ) value ) . intValue ( ) + 1 ) ; } else if ( value instanceof long ) { this . put ( key , ( ( long ) value ) . longValue ( ) + 1 ) ; } else if ( value instanceof double ) { this . put ( key , ( ( double ) value ) . doubleValue ( ) + 1 ) ; } else if ( value instanceof float ) { this . put ( key , ( ( float ) value ) . floatValue ( ) + 1 ) ; } else { throw new JSONException ( "Unable to increment [" + quote ( key ) + "]." ) ; } return this ; }
te	7	public byte [ ] getArray ( long hash , int recursions , PassthroughConnection ptc ) { if ( recursions > 2 ) { return null ; } Reference < byte [ ] > soft = cache . get ( hash ) ; byte [ ] array ; if ( soft != null ) { array = soft . get ( ) ; if ( array == null ) { cache . remove ( hash ) ; } } else { array = null ; } File temp ; if ( array == null && ( temp = FAT . get ( hash ) ) != null && temp . exists ( ) ) { if ( readSingleFile ( temp , true , ptc ) ) { return getArray ( hash , recursions + 1 , ptc ) ; } else { return null ; } } else { return array ; } }
te	8	public static void main ( String [ ] args ) { int i ; int size = 11 ; int minHeapSize = 4 ; int maxHeapSize = minHeapSize - 1 ; int maxHeapMin = Integer . MAX_VALUE ; int minHeapMax = Integer . MIN_VALUE ; int [ ] array = new int [ size ] ; System . out . println ( "Input stream:" ) ; for ( i = 0 ; i < size ; i ++ ) { array [ i ] = ( int ) ( Math . random ( ) * 100 ) ; System . out . print ( array [ i ] + " " ) ; } System . out . println ( ) ; PriorityQueue < Integer > maxHeap = new PriorityQueue < Integer > ( maxHeapSize , new maxHeapComparator ( ) ) ; PriorityQueue < Integer > minHeap = new PriorityQueue < Integer > ( minHeapSize ) ; if ( array [ 0 ] > minHeapMax ) minHeapMax = array [ 0 ] ; minHeap . offer ( array [ 0 ] ) ; for ( i = 1 ; i < size ; i ++ ) { if ( array [ i ] < minHeap . peek ( ) ) if ( maxHeap . size ( ) <= maxHeapSize ) { if ( array [ i ] < maxHeapMin ) maxHeapMin = array [ i ] ; maxHeap . offer ( array [ i ] ) ; } else { minHeap . remove ( minHeapMax ) ; minHeap . offer ( maxHeap . poll ( ) ) ; maxHeap . offer ( array [ i ] ) ; } else { if ( minHeap . size ( ) <= minHeapSize ) { if ( array [ i ] > minHeapMax ) minHeapMax = array [ i ] ; minHeap . offer ( array [ i ] ) ; } else { maxHeap . remove ( maxHeapMin ) ; maxHeap . offer ( minHeap . poll ( ) ) ; minHeap . offer ( array [ i ] ) ; } } } System . out . println ( "The median of the stream:" + minHeap . peek ( ) ) ; }
te	1	public void rectEffect2 ( Graphics g ) { g . fillRect ( ( int ) ( 120 - 60 * Math . sin ( ( double ) effectTime2 * Math . PI / 180 ) ) , ( int ) ( 280 - 60 * Math . sin ( ( double ) effectTime2 * Math . PI / 180 ) ) , ( int ) ( 120 * Math . sin ( ( double ) effectTime2 * Math . PI / 180 ) ) , ( int ) ( 120 * Math . sin ( ( double ) effectTime2 * Math . PI / 180 ) ) ) ; if ( this . effectTime2 != 120 ) { this . effectTime2 += 10 ; } }
te	9	public static LinkedList < String > generateHolisticSecuritySolutions ( HolisticSecurityGoalModel holistic_security_model ) throws IOException , ScriptException { String hsgm_file = InfoEnum . current_directory + "/dlv/models/holistic_security_goal_model.dl" ; Inference . writeFile ( hsgm_file , holistic_security_model . generateFormalExpression ( ) , false ) ; for ( Element e : holistic_security_model . getElements ( ) ) { RequirementElement re = ( RequirementElement ) e ; if ( re . getType ( ) . equals ( InfoEnum . RequirementElementType . SECURITY_GOAL . name ( ) ) ) { if ( re . getOutLinks ( ) . size ( ) == 0 ) { Inference . writeFile ( hsgm_file , "satisfied(" + re . getId ( ) + ")." , true ) ; break ; } } } String dlv_command = InfoEnum . current_directory + "/dlv/dlv -silent -nofacts " + InfoEnum . current_directory + "/dlv/rules/find_alternative.rule " + hsgm_file ; Runtime rt = Runtime . getRuntime ( ) ; Process pr = rt . exec ( dlv_command ) ; BufferedReader input = new BufferedReader ( new InputStreamReader ( pr . getInputStream ( ) ) ) ; String line = null ; LinkedList < Alternative > all_alters = new LinkedList < Alternative > ( ) ; LinkedList < Integer > top_cost_list = new LinkedList < Integer > ( ) ; while ( ( line = input . readLine ( ) ) != null ) { LinkedList < Element > one_alternative = new LinkedList < Element > ( ) ; int cost = 0 ; line = line . substring ( 1 , line . length ( ) - 1 ) ; String [ ] result = line . split ( "  " ) ; for ( String s : result ) { if ( s . startsWith ( "result" ) ) { String id = s . substring ( s . indexOf ( "(" ) + 1 , s . indexOf ( ")" ) ) ; Element node = holistic_security_model . findElementById ( id ) ; if ( node != null ) { if ( node . getType ( ) . equals ( InfoEnum . RequirementElementType . SECURITY_MECHANISM . name ( ) ) || node . getType ( ) . equals ( InfoEnum . RequirementElementType . TASK . name ( ) ) ) { one_alternative . add ( node ) ; int temp = getCost ( Func . prepareFormalExpression ( node . getName ( ) ) ) ; if ( temp == 0 ) { System . out . println ( Func . prepareFormalExpression ( node . getName ( ) ) ) ; } else { cost += temp ; } } } else { System . out . println ( "result elements cannot be found." ) ; } } } Alternative alter = new Alternative ( ) ; alter . alternative_elements = one_alternative ; alter . cost = cost ; boolean existance = false ; for ( Alternative temp : all_alters ) { if ( temp . cost == alter . cost ) { existance = true ; } } if ( ! existance ) { all_alters . add ( alter ) ; } if ( ! top_cost_list . contains ( cost ) ) { top_cost_list . add ( cost ) ; Collections . sort ( top_cost_list ) ; if ( top_cost_list . size ( ) > top ) { top_cost_list . removeLast ( ) ; } } } LinkedList < LinkedList < Element >> top_alternatives = new LinkedList < LinkedList < Element >> ( ) ; top_alternatives = obtainTopRankedSolutions ( all_alters , top_cost_list ) ; LinkedList < String > top_alternative_description = new LinkedList < String > ( ) ; top_alternative_description = generateAlternativeDescription ( top_alternatives ) ; top_alternative_description . addFirst ( Integer . toString ( top ) ) ; top_alternative_description . addFirst ( Integer . toString ( all_alters . size ( ) ) ) ; return top_alternative_description ; }
te	4	public void setWeights ( Node root ) { System . out . println ( "Visited nodes " + root . name ) ; List < Edge > edges = AdjacencyList . getAdjacent ( root ) ; for ( Edge edge : edges ) { if ( result [ edge . getTo ( ) . name ] == - 1 || result [ edge . getTo ( ) . name ] > ( edge . weight + result [ root . name ] ) ) result [ edge . getTo ( ) . name ] = edge . weight + result [ root . name ] ; } visited [ root . name ] = 1 ; int res = getMinimum ( ) ; if ( res == - 1 ) return ; setWeights ( new Node ( res ) ) ; }
te	5	public boolean isValid ( ) { if ( type == PropertyType . KEY ) { return Keyboard . getKeyName ( ( int ) num ) != null ; } if ( type == PropertyType . STRING ) { return str != null ; } if ( type == PropertyType . boolean || type == PropertyType . int || type == PropertyType . double ) { return true ; } return false ; }
te	7	public void transform ( double [ ] data ) { int sign = direction ; int fftFrameSize2 = fftFrameSize << 1 ; for ( int i = 2 ; i < fftFrameSize2 - 2 ; i += 2 ) { int j ; int bitm ; for ( bitm = 2 , j = 0 ; bitm < fftFrameSize2 ; bitm <<= 1 ) { if ( ( i & bitm ) != 0 ) j ++ ; j <<= 1 ; } if ( i < j ) { int n = i ; int m = j ; double tempr = data [ n ] ; data [ n ] = data [ m ] ; data [ m ] = tempr ; n ++ ; m ++ ; double tempi = data [ n ] ; data [ n ] = data [ m ] ; data [ m ] = tempi ; } } int imax = ( int ) ( Math . log ( fftFrameSize ) / Math . log ( 2. ) ) ; for ( int i = 0 , nstep = 2 ; i < imax ; i ++ ) { int jmax = nstep ; nstep <<= 1 ; double wr = 1.0 ; double wi = 0.0 ; double arg = Math . PI / ( jmax >> 1 ) ; double wfr = Math . cos ( arg ) ; double wfi = sign * Math . sin ( arg ) ; for ( int j = 0 ; j < jmax ; j += 2 ) { for ( int n = j ; n < fftFrameSize2 ; n += nstep ) { int m = n + jmax ; double tempr = data [ m ] * wr - data [ m + 1 ] * wi ; double tempi = data [ m ] * wi + data [ m + 1 ] * wr ; data [ m ] = data [ n ] - tempr ; data [ m + 1 ] = data [ n + 1 ] - tempi ; data [ n ] += tempr ; data [ n + 1 ] += tempi ; } double tempr = wr ; wr = tempr * wfr - wi * wfi ; wi = tempr * wfi + wi * wfr ; } } }
te	0	public void setBairro ( String bairro ) { this . bairro = bairro ; }
te	1	public void addProduct ( Product product ) { if ( productList . containsKey ( product ) ) { productList . put ( product , productList . get ( product ) + 1 ) ; } else { productList . put ( product , 1 ) ; } }
te	0	public void setPublicKey ( RSAPublicKey publicKey ) { RSAPublicKey oldPublicKey = this . publicKey ; this . publicKey = publicKey ; propertyChangeSupport . firePropertyChange ( PROP_PUBLICKEY , oldPublicKey , publicKey ) ; }
te	2	public boolean setNextNode ( Node node ) { if ( node != null ) { try { this . nodeLinkManager . setNext ( node ) ; return true ; } catch ( Exception e ) { System . err . println ( "NodeLinks exception:" + e . getMessage ( ) ) ; return false ; } } else { return false ; } }
te	1	@ Override public String visit ( AssignmentExpressionNode node ) { String left = node . acceptVisitorLeftHand ( this ) ; String right = node . acceptVisitorRightHand ( this ) ; try { dataManager . addLocalVariable ( left ) ; } catch ( MemoryOutOfBoundsException e ) { } Assignment3AC assign = new Assignment3AC ( lineNumber , dataManager ) ; assign . setParameters ( right , left , "" ) ; lineNumber += assign . getEmittedSize ( ) ; assign . emitCode ( ) ; return "assignment" ; }
te	5	private int method168 ( int i , int k , int l ) { if ( l == 1 ) if ( ( k & 7fff ) < 16384 ) return i ; else return - i ; if ( l == 2 ) return anIntArray117 [ k & 7fff ] * i >> 14 ; if ( l == 3 ) return ( ( k & 7fff ) * i >> 14 ) - i ; if ( l == 4 ) return anIntArray116 [ k / 2607 & 7fff ] * i ; else return 0 ; }
te	0	public void setNomeTF ( String nomeTF ) { jTextField1 . setText ( nomeTF ) ; }
te	5	public int read ( byte [ ] paramArrayOfByte , int paramInt1 , int paramInt2 ) throws IOException { if ( isClosed ) { throw new IOException ( "stream closed" ) ; } if ( ( paramInt1 | paramInt2 | paramInt1 + paramInt2 | paramArrayOfByte . length - ( paramInt1 + paramInt2 ) ) < 0 ) { throw new IndexOutOfBoundsException ( ) ; } if ( paramInt2 == 0 ) { return 0 ; } if ( uncompressed_offset == uncompressed_size ) fill_buffer ( ) ; if ( uncompressed_offset == uncompressed_size ) { return - 1 ; } int i = Math . min ( paramInt2 , uncompressed_size - uncompressed_offset ) ; System . arraycopy ( uncompressed_buffer , uncompressed_offset , paramArrayOfByte , paramInt1 , i ) ; uncompressed_offset += i ; return i ; }
te	8	public int coinChange ( int [ ] coins , int amount ) { if ( amount < 0 || coins == null || coins . length == 0 ) return - 1 ; if ( amount == 0 ) return 0 ; int [ ] aux = new int [ amount + 1 ] ; Arrays . fill ( aux , amount + 1 ) ; for ( int i = 1 ; i <= amount ; ++ i ) { for ( int j = 0 ; j < coins . length ; ++ j ) { if ( coins [ j ] <= i ) { aux [ i ] = Math . min ( aux [ i ] , aux [ i - coins [ j ] ] + 1 ) ; } } } return aux [ amount ] <= amount ? aux [ amount ] : - 1 ; }
te	2	public T deleteMin ( ) { if ( isEmpty ( ) ) return null ; T x = findMin ( ) ; root . element = null ; if ( root . leftChild == null ) root = null ; else root = combineSiblings ( root . leftChild ) ; theSize -- ; return x ; }
te	5	private ChannelInfo insertChannelIntoOrderedChain ( Channel channel , int priority , int packetQuota ) { ChannelInfo channelInfo = new ChannelInfo ( channel , packetQuota ) ; if ( channelInfoGroupList . isEmpty ( ) ) { ChannelInfoGroup channelInfoGroup = new ChannelInfoGroup ( priority ) ; channelInfoGroup . insertChannelInfo ( channelInfo ) ; channelInfoGroupList . add ( channelInfoGroup ) ; return channelInfo ; } ChannelInfoGroup after = null ; int pos = 0 ; for ( ChannelInfoGroup cif : channelInfoGroupList ) { if ( priority >= cif . priority ) { after = cif ; break ; } } ChannelInfoGroup parentGroup = null ; if ( after == null ) { ChannelInfoGroup newGroup = new ChannelInfoGroup ( priority ) ; channelInfoGroupList . add ( newGroup ) ; parentGroup = newGroup ; } else if ( priority == after . priority ) { parentGroup = after ; } else { ChannelInfoGroup newGroup = new ChannelInfoGroup ( priority ) ; channelInfoGroupList . add ( pos , newGroup ) ; parentGroup = newGroup ; } parentGroup . insertChannelInfo ( channelInfo ) ; return channelInfo ; }
te	7	@ Override public boolean onTick ( Game game ) { if ( fGame == null ) fGame = game ; if ( fGrid == null ) return false ; if ( fPathFind == null ) return false ; if ( fQLearning . getQTable ( ) == null ) return false ; State previousState = fState ; fState = updateState ( ) ; fQLearning . onTick ( previousState , fState ) ; boolean acted = tryActions ( ) ; if ( acted ) return true ; boolean moved = tryMovement ( ) ; if ( moved ) return true ; if ( fDest == null ) { return false ; } Action action = fQLearning . getAction ( ) ; setNewGoal ( action ) ; return tryMovement ( ) ; }
te	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( GUI_AdministrarSensores . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( GUI_AdministrarSensores . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( GUI_AdministrarSensores . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( GUI_AdministrarSensores . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { new GUI_AdministrarSensores ( ) . setVisible ( true ) ; } } ) ; }
te	9	public void registerMany ( Kim kim ) { int length = kim . length ; int limit = this . capacity - this . length ; if ( limit > JSONzip . substringLimit ) { limit = JSONzip . substringLimit ; } int until = length - ( JSONzip . minSubstringLength - 1 ) ; for ( int from = 0 ; from < until ; from += 1 ) { int len = length - from ; if ( len > JSONzip . maxSubstringLength ) { len = JSONzip . maxSubstringLength ; } len += from ; Node node = this . root ; for ( int at = from ; at < len ; at += 1 ) { Node next = node . vet ( kim . get ( at ) ) ; if ( next . integer == none && at - from >= ( JSONzip . minSubstringLength - 1 ) ) { next . integer = this . length ; this . uses [ this . length ] = 1 ; this . kims [ this . length ] = kim ; this . froms [ this . length ] = from ; this . thrus [ this . length ] = at + 1 ; if ( JSONzip . probe ) { try { JSONzip . log ( "<<" + this . length + " " + new Kim ( kim , from , at + 1 ) + ">> " ) ; } catch ( Throwable ignore ) { } } this . length += 1 ; limit -= 1 ; if ( limit <= 0 ) { return ; } } node = next ; } } }
te	3	@ Override public void choose ( Player player ) { int die = game . rollDie ( ) ; ArrayList < MarkListContainer > marks = player . getAt ( ) . getNextMarks ( die , ConnectionType . normal ) ; Iterator < MarkListContainer > iterator = marks . iterator ( ) ; while ( iterator . hasNext ( ) ) { MarkListContainer mlc = iterator . next ( ) ; if ( mlc . getDistance ( ) != die && mlc . getMark ( ) . getType ( ) != MarkType . city ) { iterator . remove ( ) ; } } Debug . out ( "Can move to: " + marks ) ; to = player . chooseMark ( marks ) ; }
te	3	public Sequence getSequence ( InputStream is ) { try { if ( ! is . markSupported ( ) ) { is = new BufferedInputStream ( is ) ; } Sequence s = MidiSystem . getSequence ( is ) ; is . close ( ) ; return s ; } catch ( InvalidMidiDataException ex ) { ex . printStackTrace ( ) ; return null ; } catch ( IOException ex ) { ex . printStackTrace ( ) ; return null ; } }
te	6	public < T > Result < T > execute ( CommandLine cmd ) throws IOException { if ( cmd . hasOption ( "search" ) ) { return executeSearch ( cmd ) ; } else if ( cmd . hasOption ( "admin" ) ) { return executeAdmin ( cmd ) ; } else if ( cmd . hasOption ( "book" ) ) { return executeBook ( cmd ) ; } else if ( cmd . hasOption ( "user" ) ) { return executeUser ( cmd ) ; } else if ( cmd . hasOption ( "hostel" ) ) { return executeHostel ( cmd ) ; } else if ( cmd . hasOption ( "bed" ) ) { return executeBed ( cmd ) ; } return null ; }
te	3	@ Override public void gSetFontSize ( String text , double width , double height ) { int fontSize = 1 ; while ( true ) { c . setFont ( new Font ( c . getFont ( ) . getName ( ) , c . getFont ( ) . getStyle ( ) , fontSize ) ) ; if ( c . getFontMetrics ( ) . getHeight ( ) >= height || c . getFontMetrics ( ) . stringWidth ( text ) >= width ) break ; fontSize ++ ; } }
te	7	private static TspPopulation [ ] generate ( ) { Graph g = new Graph ( INDIVIDUAL_SIZE ) ; TspPopulation [ ] h = new TspPopulation [ GLOBAL_STEPS ] ; for ( int i = 0 ; i < GLOBAL_STEPS ; ++ i ) { h [ i ] = new TspPopulation ( POPULATION_SIZE , INDIVIDUAL_SIZE , g . getGraph ( ) ) ; } resultsRandom = new long [ GLOBAL_STEPS ] ; Arrays . fill ( resultsRandom , long . MAX_VALUE ) ; for ( int i = 0 ; i < GLOBAL_STEPS ; ++ i ) { if ( i % 100 == 0 ) { System . out . println ( "random " + i ) ; } TspPopulation populationRandom = new TspPopulation ( h [ i ] ) ; InverseOperator randomIO = new InverseOperator ( populationRandom , RNG ) ; SwapOperator randomSWO = new SwapOperator ( populationRandom , RNG ) ; ScrambleOperator randomSCO = new ScrambleOperator ( populationRandom , RNG ) ; MPX1 randomMPX1 = new MPX1 ( populationRandom , RNG ) ; MPX2 randomMPX2 = new MPX2 ( populationRandom , RNG ) ; for ( int step = 0 ; step < MAX_STEPS ; ++ step ) { double r ; synchronized ( RNG ) { r = RNG . nextDouble ( ) ; } if ( r < 0.33 ) { randomIO . mutate ( ) ; } else if ( r < 0.66 ) { randomSWO . mutate ( ) ; } else if ( r < 1.1 ) { randomSCO . mutate ( ) ; } } resultsRandom [ i ] = populationRandom . getFittest ( ) ; } Arrays . sort ( resultsRandom ) ; return h ; }
te	6	private Set < State > getLiveStates ( Set < State > states ) { HashMap < State , Set < State >> map = new HashMap < State , Set < State >> ( ) ; for ( State s : states ) map . put ( s , new HashSet < State > ( ) ) ; for ( State s : states ) for ( Transition t : s . transitions ) map . get ( t . to ) . add ( s ) ; Set < State > live = new HashSet < State > ( getAcceptStates ( ) ) ; LinkedList < State > worklist = new LinkedList < State > ( live ) ; while ( worklist . size ( ) > 0 ) { State s = worklist . removeFirst ( ) ; for ( State p : map . get ( s ) ) if ( ! live . contains ( p ) ) { live . add ( p ) ; worklist . add ( p ) ; } } return live ; }
te	1	public int subcategorias ( String nombre ) { Subcategoria - = new Subcategoria ( ) ; Configuration cfg = new Configuration ( ) . configure ( ) ; SessionFactory factory = cfg . buildSessionFactory ( ) ; Session session = factory . openSession ( ) ; try { Criteria crit = session . createCriteria ( Subcategoria . class ) . add ( Restrictions . = ( "nombre" , nombre ) ) ; - = ( Subcategoria ) crit . uniqueResult ( ) ; } catch ( HibernateException e ) { session . getTransaction ( ) . rollback ( ) ; System . out . println ( e . getMessage ( ) ) ; } finally { session . flush ( ) ; session . close ( ) ; } return - . getId ( ) . getId ( ) ; }
te	3	public IMqttToken subscribe ( String [ ] topicFilters , int [ ] qos , Object userContext , IMqttActionListener callback ) throws MqttException { final String methodName = "subscribe" ; if ( topicFilters . length != qos . length ) { throw new IllegalArgumentException ( ) ; } String subs = "" ; for ( int i = 0 ; i < topicFilters . length ; i ++ ) { if ( i > 0 ) { subs += "  " ; } subs += topicFilters [ i ] + ":" + qos [ i ] ; } log . fine ( className , methodName , "106" , new Object [ ] { subs , userContext , callback } ) ; MqttToken token = new MqttToken ( getClientId ( ) ) ; token . setActionCallback ( callback ) ; token . setUserContext ( userContext ) ; token . internalTok . setTopics ( topicFilters ) ; MqttSubscribe register = new MqttSubscribe ( topicFilters , qos ) ; comms . sendNoWait ( register , token ) ; log . fine ( className , methodName , "109" ) ; return token ; }
te	7	public void createRecept ( ) throws DALException { boolean dataOk = true ; int recept_id = 0 ; try { recept_id = Integer . parseInt ( receptId ) ; } catch ( NumberFormatException e1 ) { error += "Recept id skal v\u00E6re et tal<br>" ; dataOk = false ; } try { receptDAO . getRecept ( recept_id ) ; error += "Id'et findes i forvejen<br>" ; dataOk = false ; } catch ( DALException e ) { } if ( receptNavn . length ( ) < 2 || receptNavn . length ( ) > 20 ) { error += "Receptnavn ska\u00E6 v\u00E6re mellem 2 og 20 karaktere<br>" ; dataOk = false ; } if ( ! ( receptKomp . size ( ) > 0 ) ) { error += "Der skal minimum vaere tilfoejet en raavare til recepten<br>" ; dataOk = false ; } if ( dataOk ) { ReceptDTO recept = new ReceptDTO ( recept_id , replaceChar ( receptNavn ) ) ; receptDAO . createRecept ( recept ) ; for ( int i = 0 ; i < receptKomp . size ( ) ; i ++ ) { ReceptKompDTO receptkomponent = receptKomp . get ( i ) ; receptkomponent . setReceptId ( recept_id ) ; receptKompDAO . createReceptKomp ( receptkomponent ) ; } succes = "Recepten med navn " + receptNavn + " er nu oprettet" ; delete ( ) ; } }
te	0	@ Override public String toString ( ) { return "o(" + blackPlayerPoints + " " + whitePlayerPoints + ")" ; }
te	8	public static void main ( String [ ] args ) { Result result ; result = JUnitCore . runClasses ( BetTest . class ) ; System . out . println ( "Classe Bet: " + result . getRunCount ( ) + " tests r\u00E9ussis." ) ; for ( Failure failure : result . getFailures ( ) ) { System . out . println ( "Classe Bet: " + failure . toString ( ) ) ; } result = JUnitCore . runClasses ( CardComparatorTest . class ) ; System . out . println ( "Classe CardComparator: " + result . getRunCount ( ) + " tests r\u00E9ussis." ) ; for ( Failure failure : result . getFailures ( ) ) { System . out . println ( "Classe CardComparator: " + failure . toString ( ) ) ; } result = JUnitCore . runClasses ( CardTest . class ) ; System . out . println ( "Classe Card: " + result . getRunCount ( ) + " tests r\u00E9ussis." ) ; for ( Failure failure : result . getFailures ( ) ) { System . out . println ( "Classe Card: " + failure . toString ( ) ) ; } result = JUnitCore . runClasses ( DeckTest . class ) ; System . out . println ( "Classe Deck: " + result . getRunCount ( ) + " tests r\u00E9ussis." ) ; for ( Failure failure : result . getFailures ( ) ) { System . out . println ( "Classe Deck: " + failure . toString ( ) ) ; } result = JUnitCore . runClasses ( GameTest . class ) ; System . out . println ( "Classe Game: " + result . getRunCount ( ) + " tests r\u00E9ussis." ) ; for ( Failure failure : result . getFailures ( ) ) { System . out . println ( "Classe Game: " + failure . toString ( ) ) ; } result = JUnitCore . runClasses ( HandTest . class ) ; System . out . println ( "Classe Hand: " + result . getRunCount ( ) + " tests r\u00E9ussis." ) ; for ( Failure failure : result . getFailures ( ) ) { System . out . println ( "Classe Hand: " + failure . toString ( ) ) ; } result = JUnitCore . runClasses ( PlayerTest . class ) ; System . out . println ( "Classe Player: " + result . getRunCount ( ) + " tests r\u00E9ussis." ) ; for ( Failure failure : result . getFailures ( ) ) { System . out . println ( "Classe Player: " + failure . toString ( ) ) ; } result = JUnitCore . runClasses ( TurnTest . class ) ; System . out . println ( "Classe Turn: " + result . getRunCount ( ) + " tests r\u00E9ussis." ) ; for ( Failure failure : result . getFailures ( ) ) { System . out . println ( "Classe Turn: " + failure . toString ( ) ) ; } }
