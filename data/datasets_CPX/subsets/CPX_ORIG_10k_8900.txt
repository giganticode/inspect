te	6	private static void unzip ( RandomAccessFile in , int inLen , int outLen , byte [ ] inBuf , byte [ ] outBuf , RandomAccessFile out ) throws IOException { int inLeft = inLen ; int written = 0 ; Inflater inflater = new Inflater ( ) ; while ( inLeft > 0 ) { int n = in . read ( inBuf , 0 , Math . min ( inLeft , inBuf . length ) ) ; if ( n <= 0 ) { throw new IOException ( "Read failed." ) ; } inLeft -= n ; inflater . setInput ( inBuf , 0 , n ) ; while ( ! inflater . needsInput ( ) ) { try { int m = inflater . inflate ( outBuf ) ; written += m ; if ( written > outLen ) { throw new IOException ( "Decompression failed." ) ; } out . write ( outBuf , 0 , m ) ; } catch ( DataFormatException ex ) { throw new IOException ( "Decompression failed." ) ; } } } inflater . end ( ) ; if ( written != outLen ) { throw new IOException ( "Decompression failed." ) ; } }
te	1	private final void bsW ( int n , int v ) throws IOException { while ( bsLive >= 8 ) { int ch = ( bsBuff >> 24 ) ; bsBuff <<= 8 ; bsLive -= 8 ; bytesOut ++ ; } bsBuff |= ( v << ( 32 - bsLive - n ) ) ; bsLive += n ; }
te	2	public static void setAreas ( ) { if ( ! created ) { database . openBusDatabase ( ) ; areasCombo . removeAllItems ( ) ; int [ ] areas = BusStopInfo . getAreas ( ) ; for ( int i = 0 ; i < areas . length ; i ++ ) areasCombo . addItem ( BusStopInfo . getAreaName ( areas [ i ] ) ) ; created = true ; } }
te	8	public static boolean isValidGCode ( String codeline ) { if ( codeline == null || codeline . isEmpty ( ) ) return false ; if ( codeline . charAt ( 0 ) == G || codeline . charAt ( 0 ) == g ) return true ; if ( codeline . charAt ( 0 ) == M || codeline . charAt ( 0 ) == m ) return true ; if ( codeline . charAt ( 0 ) == T || codeline . charAt ( 0 ) == t ) return true ; return false ; }
te	7	public int patientInfoByItem ( Vector < PatientInfo > patient , String toMatch , JTextField [ ] tf , JTextPane tp , JTextPane [ ] patientTP ) { DB . db . openConnection ( ) ; int id = 0 ; StringBuffer info = new StringBuffer ( ) ; try { int ind = - 1 ; String lName = toMatch . substring ( 0 , toMatch . indexOf ( " " ) ) ; String dBirth = toMatch . substring ( toMatch . indexOf ( "(" ) + 1 , toMatch . indexOf ( ")" ) ) ; for ( int i = 0 ; i < patient . size ( ) ; i ++ ) { if ( patient . get ( i ) . getLname ( ) . equalsIgnoreCase ( lName ) && patient . get ( i ) . getBdate ( ) . toString ( ) . equalsIgnoreCase ( dBirth ) ) { ind = i ; } } ResultSet res = DB . db . patient ( patient . get ( ind ) . getLname ( ) , patient . get ( ind ) . getBdate ( ) ) ; info . append ( "<table>" ) ; while ( res . next ( ) ) { info . append ( "<tr><td>Patient: <b>" ) ; info . append ( res . getString ( "lname" ) ) ; info . append ( "  " + res . getString ( "fname" ) ) ; info . append ( "</b></td></tr>" ) ; info . append ( "<tr><td>Phone: <b>" ) ; info . append ( res . getString ( "phone" ) + "</b></td></tr>" ) ; info . append ( "<tr><td>Address: <b>" ) ; info . append ( res . getString ( "address" ) + "  " + res . getString ( "zip" ) + "</b></td></tr>" ) ; info . append ( "<tr><td>Med card: <b>" ) ; info . append ( res . getString ( "medcard" ) + "</b></td></tr>" ) ; info . append ( "<tr><td>Insurance: <b>" ) ; info . append ( res . getString ( "insurrance" ) + "</b></td></tr>" ) ; info . append ( "<tr><td>SSN: <b>" ) ; info . append ( res . getString ( "ssn" ) + "</b></td></tr>" ) ; info . append ( "<tr><td>E-mail: <b>" ) ; info . append ( res . getString ( "email" ) + "</b></td></tr>" ) ; id = res . getInt ( "id" ) ; tf [ 0 ] . setText ( res . getString ( "fname" ) ) ; tf [ 1 ] . setText ( res . getString ( "lname" ) ) ; tf [ 2 ] . setText ( res . getDate ( "bdate" ) . toString ( ) ) ; tf [ 3 ] . setText ( res . getString ( "ssn" ) ) ; tf [ 4 ] . setText ( res . getString ( "email" ) ) ; tf [ 5 ] . setText ( res . getString ( "address" ) ) ; tf [ 6 ] . setText ( res . getString ( "zip" ) ) ; tf [ 7 ] . setText ( res . getString ( "phone" ) ) ; tf [ 8 ] . setText ( res . getString ( "insurrance" ) ) ; tf [ 9 ] . setText ( res . getString ( "medcard" ) ) ; if ( patientTP == null ) { ResultSet rres = DB . db . prescription ( id ) ; while ( rres . next ( ) ) { tp . setText ( rres . getString ( "prescription" ) ) ; } } } DB . db . close ( ) ; } catch ( SQLException ex ) { Logger . getLogger ( Func . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; DB . db . close ( ) ; } return id ; }
te	0	public Importlog ( long id ) { this . id = id ; }
te	3	public void endLine ( ) { if ( columnCount != - 1 && currentColumnCount != columnCount ) throw new RuntimeException ( "Not enough columns for one line." ) ; out . println ( ) ; if ( columnCount == - 1 ) columnCount = currentColumnCount ; currentColumnCount = 0 ; }
te	4	public static double stop ( String key , long dataAmount ) { if ( key == null ) throw new RuntimeException ( "ElapsedTime key can't be null" ) ; TransferRateInterval entry = mSampleSetManager . get ( key ) ; if ( entry == null || entry . mStartTime < 0 ) throw new RuntimeException ( "stop(" + key + ") called but there was no matching start" ) ; double timeSample = ( System . nanoTime ( ) - entry . mStartTime ) * MSEC_SCALE ; entry . mStartTime = - 1 ; entry . addSample ( timeSample , dataAmount ) ; return timeSample > 0.0 ? dataAmount / timeSample : double . MAX_VALUE ; }
te	4	final public BinaryExp AddOp_postfix ( ) throws ParseException { Token op ; Exp right ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case SYM_PLUS : jj_consume_token ( SYM_PLUS ) ; break ; case SYM_MINUS : jj_consume_token ( SYM_MINUS ) ; break ; default : jj_la1 [ 27 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } op = token ; Exp . appendToGlobalExpString ( token . image ) ; right = MulOp ( ) ; { if ( true ) return new BinaryExp ( null , op , right ) ; } throw new Error ( "Missing return statement in function" ) ; }
te	8	public void readMsg ( ) { if ( nUpdateRectsLeft == 0 ) { int type = is . readU8 ( ) ; switch ( type ) { case MsgTypes . framebufferUpdate : readFramebufferUpdate ( ) ; break ; case MsgTypes . setColourMapEntries : readSetColourMapEntries ( ) ; break ; case MsgTypes . bell : readBell ( ) ; break ; case MsgTypes . serverCutText : readServerCutText ( ) ; break ; default : vlog . error ( "unknown message type " + type ) ; throw new Exception ( "unknown message type" ) ; } } else { int x = is . readU16 ( ) ; int y = is . readU16 ( ) ; int w = is . readU16 ( ) ; int h = is . readU16 ( ) ; int encoding = is . readU32 ( ) ; switch ( encoding ) { case Encodings . pseudoEncodingDesktopSize : handler . setDesktopSize ( w , h ) ; break ; case Encodings . pseudoEncodingCursor : readSetCursor ( x , y , w , h ) ; break ; default : readRect ( x , y , w , h , encoding ) ; break ; } nUpdateRectsLeft -- ; if ( nUpdateRectsLeft == 0 ) handler . framebufferUpdateEnd ( ) ; } }
te	6	@ SuppressWarnings ( "unchecked" ) public static double min ( Function w , HashSet < Integer > id , boolean inclusion ) { double result = double . POSITIVE_INFINITY ; for ( Feature f : ( LinearFunction < Feature , FeatureVector > ) w ) { if ( ( ( inclusion && id . contains ( f . identifier ( ) ) ) || ( ! inclusion && ! id . contains ( f . identifier ( ) ) ) ) && ( f . strength ( ) < result ) ) result = f . strength ( ) ; } return result ; }
te	4	private boolean procButtonKey ( char c ) { boolean processed = true ; do { if ( postScriptEnabled ) { if ( c == 126 ) { System . out . println ( "Generating postscript version of panel" ) ; this . postScript ( null ) ; break ; } } Button b = myButton . keyButton ( c , buttons , theButtonList ) ; if ( b != null ) { processButtonPress ( b ) ; break ; } processed = false ; } while ( false ) ; return processed ; }
te	7	public boolean equals ( Object o ) { if ( o == null ) return false ; if ( o == this ) return true ; if ( o instanceof Attributes ) { for ( int i = 0 ; i < MRTConstants . ATTRIBUTE_TOTAL ; i ++ ) { Attribute a1 = this . attributes . elementAt ( i ) , a2 = ( ( Attributes ) o ) . attributes . elementAt ( i ) ; if ( a1 == null ) { if ( a2 != null ) return false ; continue ; } if ( ! a1 . equals ( a2 ) ) return false ; } return true ; } return false ; }
te	0	public ZippedDocumentTemplate ( InputStream inputStream ) throws IOException { archive = OpenDocumentIO . readZip ( inputStream ) ; }
te	5	public final ListQuery < T > filter ( FilterBlock < T > block ) { if ( isEmpty ( ) || block == null ) { return this ; } List < T > result = jvQuery . list ( ) ; for ( T t : list ) { boolean is = block . call ( t ) ; if ( is != null && is ) { result . add ( t ) ; } } return jvQuery ( result ) ; }
te	3	private void modificarInfo ( String correo ) { ControlVentanas . configArchivoPerfil ( correo ) ; ControlVentanas . crearRandom ( ) ; try { ControlVentanas . registros . seek ( 0 ) ; String n = ControlVentanas . registros . readUTF ( ) ; char c = ( this . cmbGenero . getSelectedIndex ( ) == 0 ? M : F ) ; ControlVentanas . registros . writeChar ( c ) ; Calendar cal = Calendar . getInstance ( ) ; cal . set ( ( Integer ) this . cmbAÃ±o . getSelectedItem ( ) , this . cmbMes . getSelectedIndex ( ) , ( Integer ) this . cmbDia . getSelectedItem ( ) ) ; ControlVentanas . registros . writeLong ( cal . getTimeInMillis ( ) ) ; ControlVentanas . registros . readUTF ( ) ; ControlVentanas . registros . readLong ( ) ; int tel = Integer . valueOf ( this . txtTelefono . getText ( ) ) ; ControlVentanas . registros . writeInt ( tel ) ; ControlVentanas . registros . close ( ) ; boolean b = desactivarCuenta ( correo ) ; if ( b ) { ControlVentanas . face . setDatosPerfil ( n , c , cal . getTimeInMillis ( ) , tel ) ; } } catch ( IOException ex ) { ex . printStackTrace ( ) ; } }
te	6	@ Override public void moveColumn ( int columnIndex , int newIndex ) { if ( ( columnIndex < 0 ) || ( columnIndex >= getColumnCount ( ) ) || ( newIndex < 0 ) || ( newIndex >= getColumnCount ( ) ) ) { throw new IllegalArgumentException ( "moveColumn() - Index out of range" ) ; } if ( columnIndex != 0 && newIndex != 0 ) { TableColumn temp = tableColumns . remove ( columnIndex ) ; tableColumns . add ( newIndex , temp ) ; } fireColumnMoved ( new TableColumnModelEvent ( this , columnIndex , newIndex ) ) ; }
te	5	public void removeAttribute ( String name ) throws DOMException { if ( this . adaptee == null ) return ; AttVal att = this . adaptee . attributes ; AttVal pre = null ; while ( att != null ) { if ( att . attribute . equals ( name ) ) break ; pre = att ; att = att . next ; } if ( att != null ) { if ( pre == null ) { this . adaptee . attributes = att . next ; } else { pre . next = att . next ; } } }
te	1	@ Override public void afterIteration ( int iteration , I reference ) { final int width1 = 20 ; final int width2 = 8 ; final int width3 = 30 ; final double error = reference . getError ( ) ; String imprec = "(-)" ; if ( error < this . best ) { this . best = error ; imprec = "(+)" ; } System . out . print ( paddingBack ( "iteration: " + iteration , width1 ) ) ; System . out . print ( paddingBack ( imprec , width2 ) ) ; System . out . print ( paddingBack ( "error: " + DoubleTools . asString ( error , 10 ) , width3 ) ) ; System . out . print ( "best error: " + DoubleTools . asString ( this . best , 10 ) ) ; System . out . println ( ) ; }
te	2	@ Override public String format ( LogRecord rec ) { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( dateFormatter . format ( new Date ( ) ) ) ; buffer . append ( " [" ) ; buffer . append ( rec . getLevel ( ) . getName ( ) ) ; buffer . append ( "] " ) ; buffer . append ( rec . getMessage ( ) ) ; buffer . append ( "\r\n" ) ; Throwable throwable = rec . getThrown ( ) ; if ( throwable != null ) { buffer . append ( throwable . toString ( ) ) ; buffer . append ( "\r\n" ) ; for ( StackTraceElement element : throwable . getStackTrace ( ) ) { buffer . append ( "\t" ) ; buffer . append ( element ) ; buffer . append ( "\r\n" ) ; } } return buffer . toString ( ) ; }
te	1	public static void setMaxLitterSize ( int max_litter_size ) { if ( max_litter_size >= 1 ) Grass . max_litter_size = max_litter_size ; }
te	3	private void popHistory ( boolean restoreGUI ) { FractCalcerResultData h = AppManager . getInstance ( ) . popHistory ( ) ; if ( restoreGUI && h != null ) { MainFrame . this . setFractParam ( h . fractParam ) ; MainFrame . this . updateOutput ( h ) ; MainFrame . this . actualFractCalcerResult = h ; } if ( AppManager . getInstance ( ) . getHistoryCount ( ) == 0 ) { btnBack . setEnabled ( false ) ; } }
te	5	public void update ( int pos , int keyweights , List lengthDist , PriorityQueue q ) throws IllegalArgumentException { ArrayList EtSedges = ( ArrayList ) EtS . get ( keyweights ) ; Iterator k = EtSedges . iterator ( ) ; if ( ! k . hasNext ( ) ) { return ; } WeightedEdge we = ( WeightedEdge ) k . next ( ) ; int i = we . getSource ( ) ; int j = we . getTarget ( ) ; if ( colors [ j ] != 2 ) { int ft = distances [ i ] + keyweights ; q . insert ( keyweights , ft ) ; return ; } while ( colors [ j ] == 2 ) { k . remove ( ) ; if ( k . hasNext ( ) ) { we = ( WeightedEdge ) k . next ( ) ; j = we . getTarget ( ) ; } else { break ; } } if ( colors [ j ] != 2 ) { i = we . getSource ( ) ; int ft = distances [ i ] + keyweights ; q . insert ( keyweights , ft ) ; } }
te	2	private boolean r_i_plural ( ) { int v_1 ; int v_2 ; v_1 = limit - cursor ; if ( cursor < I_p1 ) { return false ; } cursor = I_p1 ; v_2 = limit_backward ; limit_backward = cursor ; cursor = limit - v_1 ; ket = cursor ; if ( find_among_b ( a_8 , 2 ) == 0 ) { limit_backward = v_2 ; return false ; } bra = cursor ; limit_backward = v_2 ; slice_del ( ) ; return true ; }
te	0	protected PropertyAdaptorImpl ( FODriverImpl driver ) { super ( driver , TYPE ) ; }
te	3	private TowerDef getTowerDef ( ArrayList < TowerDef > list , int level ) { if ( ( level < 0 ) || ( list == null ) || ( level >= list . size ( ) ) ) return null ; return list . get ( level - 1 ) ; }
te	0	public static Direction getDirection ( String direction ) { return Direction . valueOf ( direction . toUpperCase ( ) ) ; }
te	4	void load ( final int chunkX , final int chunkZ ) { final long hash = ChunkCoordinates . hash ( chunkX , chunkZ ) ; for ( final Region region : this . regions ) if ( region . isDefined ( ) && region . within ( chunkX , chunkZ ) && region . active ) this . cache ( hash , region ) ; }
te	2	@ Test public void whenEmptyAllDisconnected ( ) throws Exception { int N = 10 ; QuickfindUF qf = new QuickfindUF ( N ) ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { assertFalse ( qf . connected ( i , j ) ) ; } } }
te	1	public void setAdditionalStatusInfoText ( String additionalStatusInfoText ) { if ( additionalStatusInfoText == null ) { this . additionalStatusInfoText . setText ( "" ) ; } else { this . additionalStatusInfoText . setText ( additionalStatusInfoText ) ; } }
te	2	public void broadcast ( RoomEvent event ) { for ( MemberEntry member : members . values ( ) ) { try { member . send ( event ) ; } catch ( Connection . Error e ) { e . printStackTrace ( ) ; } } }
te	0	public String getBrightpointOrderNumber ( ) { return brightpointOrderNumber ; }
te	6	private void btnBuscarActionPerformed ( java . awt . event . ActionEvent evt ) { String textoCorreo = tfIdCorreo . getText ( ) . trim ( ) ; if ( ! textoCorreo . equals ( "" ) ) { try { if ( rbtnCorreo . isSelected ( ) ) { correoActual = new RegistraCorreo ( ) . getCorreoByNombre ( textoCorreo ) ; } else if ( rbtnId . isSelected ( ) ) { Pattern patron = Pattern . compile ( "[0-9]+" ) ; if ( patron . matcher ( textoCorreo ) . matches ( ) ) { correoActual = new RegistraCorreo ( ) . getCorreoByID ( textoCorreo ) ; } else { JOptionPane . showMessageDialog ( this , "Solo se aceptan d\u00EDgitos como ID" , "Escribe n\u00FAmeros" , JOptionPane . WARNING_MESSAGE ) ; } } if ( correoActual != null ) { this . habilitarEdicion ( ) ; tfCorreo . setText ( correoActual . getNombre ( ) ) ; selectOrigen . setSelectedItem ( correoActual . getOrigen ( ) . getNombre ( ) ) ; selectGrupo . setSelectedItem ( correoActual . getGrupo ( ) . getNombre ( ) ) ; cbxHabilitado . setSelected ( correoActual . isHabilitado ( ) ) ; } else { JOptionPane . showMessageDialog ( this , "No se encontraron resulados" , "No existe correo" , JOptionPane . WARNING_MESSAGE ) ; } } catch ( SQLException | ClassNotFoundException | InstantiationException | IllegalAccessException ex ) { Logger . getLogger ( VistaEditar . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; JOptionPane . showMessageDialog ( this , "Error: " + ex , "Error" , JOptionPane . ERROR_MESSAGE ) ; } } else { JOptionPane . showMessageDialog ( this , "Escriba un ID o correo" , "Campo vac\u00EDo" , JOptionPane . ERROR_MESSAGE ) ; } }
te	4	protected MapMatrix transMatrix ( MapMatrix matrix ) { System . out . println ( "Translate matrix" ) ; MapMatrix result = new MapMatrix ( ) ; File folder = new File ( _options . _corpusPrefix ) ; int totalDocs = documents . size ( ) ; for ( int curDocid = 0 ; curDocid < totalDocs ; curDocid ++ ) { Map < Integer , float > rows = new HashMap < Integer , float > ( ) ; for ( Integer targetDocid : corpusGraph . keySet ( ) ) { Map < Integer , float > targetDoc = corpusGraph . get ( targetDocid ) ; if ( targetDoc . containsKey ( curDocid ) ) { rows . put ( targetDocid , targetDoc . get ( curDocid ) ) ; } } if ( ! rows . isEmpty ( ) ) result . put ( curDocid , rows ) ; } return result ; }
te	4	public boolean isVisible ( final Render rend , final short x , final short y ) { final short dist = 32 * 32 ; if ( rend . isVisible ( x , y ) ) { return true ; } if ( rend . isVisible ( ( short ) ( x + dist ) , ( short ) ( y + dist ) ) ) { return true ; } if ( rend . isVisible ( ( short ) ( x + dist ) , y ) ) { return true ; } if ( rend . isVisible ( ( short ) ( x + ( dist / 2 ) ) , ( short ) ( y + ( dist / 2 ) ) ) ) { return true ; } return ( rend . isVisible ( x , ( short ) ( y + dist ) ) ) ; }
te	5	private void insertIterative ( K key , V value ) { BinaryTreeNode < K , V > x = this ; while ( true ) { int cmp = x . getKey ( ) . compareTo ( key ) ; if ( cmp == 0 ) { x . setValue ( value ) ; return ; } else if ( cmp < 0 ) { if ( x . getRight ( ) != null ) { x = x . getRight ( ) ; } else { x . setRight ( new BinaryTreeNode < > ( x , key , value ) ) ; return ; } } else { if ( x . getLeft ( ) != null ) { x = x . getLeft ( ) ; } else { x . setLeft ( new BinaryTreeNode < > ( x , key , value ) ) ; return ; } } } }
te	0	public int getT1_slider_position ( ) { return t1_slider_position ; }
te	7	private final void step6 ( ) { j = k ; if ( b [ k ] == e ) { int a = m ( ) ; if ( a > 1 || a == 1 && ! cvc ( k - 1 ) ) k -- ; } if ( b [ k ] == l && doublec ( k ) && m ( ) > 1 ) k -- ; }
te	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( LibrarianLogin . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( LibrarianLogin . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( LibrarianLogin . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( LibrarianLogin . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { new LibrarianLogin ( ) . setVisible ( true ) ; } } ) ; }
te	8	public String [ ] getItemTexts ( ) { String [ ] itemText = new String [ weapons . size ( ) + armours . size ( ) + foods . size ( ) + misc . size ( ) ] ; int itemCount = 0 ; if ( weapons . size ( ) > 0 ) { Iterator < Entry < Character , Weapon >> iter = weapons . entrySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { Map . Entry < Character , Weapon > entry = ( Map . Entry < Character , Weapon > ) iter . next ( ) ; itemText [ itemCount ] = entry . getKey ( ) + " - " + entry . getValue ( ) . inventoryName ( ) ; itemCount ++ ; } } if ( armours . size ( ) > 0 ) { Iterator < Entry < Character , Armour >> iter = armours . entrySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { Map . Entry < Character , Armour > entry = ( Map . Entry < Character , Armour > ) iter . next ( ) ; itemText [ itemCount ] = entry . getKey ( ) + " - " + entry . getValue ( ) . inventoryName ( ) ; itemCount ++ ; } } if ( foods . size ( ) > 0 ) { Iterator < Entry < Character , Food >> iter = foods . entrySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { Map . Entry < Character , Food > entry = ( Map . Entry < Character , Food > ) iter . next ( ) ; itemText [ itemCount ] = entry . getKey ( ) + " - " + entry . getValue ( ) . properName ( ) ; itemCount ++ ; } } if ( misc . size ( ) > 0 ) { Iterator < Entry < Character , Holdable >> iter = misc . entrySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { Map . Entry < Character , Holdable > entry = ( Map . Entry < Character , Holdable > ) iter . next ( ) ; itemText [ itemCount ] = entry . getKey ( ) + " - " + entry . getValue ( ) . properName ( ) ; itemCount ++ ; } } return itemText ; }
te	7	public boolean mouseDown ( Event event , int x , int y ) { dragStart = new Point ( x , y ) ; dragged = false ; if ( selectionAllowed && wave != null ) { if ( ( event . modifiers & Event . META_MASK ) != 0 || ( event . modifiers & Event . ALT_MASK ) != 0 || ( event . modifiers & Event . CTRL_MASK ) != 0 ) { selectNone ( ) ; repaint ( ) ; } else if ( event . clickCount == 2 ) { select ( viewStart , viewEnd ) ; repaint ( ) ; } else if ( event . clickCount == 3 ) { selectAll ( ) ; repaint ( ) ; } else { rubberBand = new BoxStretchRubberBand ( x , 1 , size ( ) . height - 2 ) ; selectingFlag = true ; } } else return super . mouseDown ( event , x , y ) ; return true ; }
te	9	protected org . apache . axis . client . Call createCall ( ) throws java . rmi . RemoteException { try { org . apache . axis . client . Call _call = super . _createCall ( ) ; if ( super . maintainSessionSet ) { _call . setMaintainSession ( super . maintainSession ) ; } if ( super . cachedUsername != null ) { _call . setUsername ( super . cachedUsername ) ; } if ( super . cachedPassword != null ) { _call . setPassword ( super . cachedPassword ) ; } if ( super . cachedEndpoint != null ) { _call . setTargetEndpointAddress ( super . cachedEndpoint ) ; } if ( super . cachedTimeout != null ) { _call . setTimeout ( super . cachedTimeout ) ; } if ( super . cachedPortName != null ) { _call . setPortName ( super . cachedPortName ) ; } java . util . Enumeration keys = super . cachedProperties . keys ( ) ; while ( keys . hasMoreElements ( ) ) { java . lang . String key = ( java . lang . String ) keys . nextElement ( ) ; _call . setProperty ( key , super . cachedProperties . get ( key ) ) ; } synchronized ( this ) { if ( firstCall ( ) ) { _call . setEncodingStyle ( null ) ; for ( int i = 0 ; i < cachedSerFactories . size ( ) ; ++ i ) { java . lang . class cls = ( java . lang . class ) cachedSerClasses . get ( i ) ; javax . xml . namespace . QName qName = ( javax . xml . namespace . QName ) cachedSerQNames . get ( i ) ; java . lang . Object x = cachedSerFactories . get ( i ) ; if ( x instanceof class ) { java . lang . class sf = ( java . lang . class ) cachedSerFactories . get ( i ) ; java . lang . class df = ( java . lang . class ) cachedDeserFactories . get ( i ) ; _call . registerTypeMapping ( cls , qName , sf , df , false ) ; } else if ( x instanceof javax . xml . rpc . encoding . SerializerFactory ) { org . apache . axis . encoding . SerializerFactory sf = ( org . apache . axis . encoding . SerializerFactory ) cachedSerFactories . get ( i ) ; org . apache . axis . encoding . DeserializerFactory df = ( org . apache . axis . encoding . DeserializerFactory ) cachedDeserFactories . get ( i ) ; _call . registerTypeMapping ( cls , qName , sf , df , false ) ; } } } } return _call ; } catch ( java . lang . Throwable _t ) { throw new org . apache . axis . AxisFault ( "Failure trying to get the Call object" , _t ) ; } }
te	9	private void runSql ( Connection conn , String query ) throws SQLException , IOException { if ( StringUtils . isEmpty ( query ) ) { throw new IllegalArgumentException ( "empty query" ) ; } Statement stmt = conn . createStatement ( ) ; ResultSet rs = null ; Output < Map < String , Object >> output = null ; try { rs = stmt . executeQuery ( query ) ; output = JsonOutput . createOutput ( getOutputStream ( ) , outputFormat , columnOrder ) ; Column [ ] columns = null ; int columnCount = 0 ; while ( rs . next ( ) ) { if ( columns == null ) { columnCount = rs . getMetaData ( ) . getColumnCount ( ) ; columns = new Column [ columnCount ] ; for ( int j = 1 ; j <= columnCount ; j ++ ) { columns [ j - 1 ] = new Column ( j , rs . getMetaData ( ) . getColumnName ( j ) , rs . getMetaData ( ) . getColumnType ( j ) ) ; } } Map < String , Object > json = new HashMap < String , Object > ( ) ; for ( int j = 0 ; j < columnCount ; j ++ ) { json . put ( columns [ j ] . name , getObject ( rs , columns [ j ] . index , columns [ j ] . sqltype ) ) ; } output . output ( json ) ; } } catch ( SQLException e ) { throw e ; } finally { try { if ( stmt != null ) { stmt . close ( ) ; } } catch ( Exception e ) { } try { if ( rs != null ) { rs . close ( ) ; } } catch ( Exception e ) { } try { if ( output != null ) { output . close ( ) ; } } catch ( Exception e ) { } } }
te	1	@ Test public void doTest ( ) { adjMatrix = new int [ ] [ ] { { 0 , 7 , 9 , 0 , 0 , 14 } , { 7 , 0 , 10 , 15 , 0 , 0 } , { 9 , 10 , 0 , 11 , 0 , 2 } , { 0 , 15 , 11 , 0 , 6 , 0 } , { 0 , 0 , 0 , 6 , 0 , 9 } , { 14 , 0 , 2 , 0 , 9 , 0 } } ; countPaths ( ) ; for ( int aResult : result ) { System . out . println ( aResult ) ; } }
te	6	private void newinterval ( ) { stopSound ( ) ; icourant . copy ( intervalchoice ( ) ) ; if ( noteLevel . isNormalgame ( ) || noteLevel . isLearninggame ( ) ) { posnote = 0 ; ncourante = icourant . getNote ( posnote ) ; if ( soundOnCheckBox . isSelected ( ) ) { synthNote ( ncourante . getPitch ( ) , 80 , noteDuration ) ; } } else if ( noteLevel . isInlinegame ( ) ) { if ( position < ligne . length - 1 ) { position += 1 ; icourant . copy ( ligneint [ position ] ) ; posnote = 0 ; ncourante = icourant . getNote ( posnote ) ; if ( soundOnCheckBox . isSelected ( ) ) { synthNote ( ncourante . getPitch ( ) , 80 , noteDuration ) ; } } } }
te	0	@ Test ( timeout = TIMEOUT ) public void test_size_after_adding_many_same_num ( ) { addAndTestSize ( "" + dcClass + " should have size 1 after adding multiple 5" , new int [ ] { 5 , 5 , 5 } , 1 ) ; }
te	9	public void send ( MqttWireMessage message , MqttToken token ) throws MqttException { final String methodName = "send" ; if ( message . isMessageIdRequired ( ) && ( message . getMessageId ( ) == 0 ) ) { message . setMessageId ( getNextMessageId ( ) ) ; } if ( token != null ) { try { token . internalTok . setMessageID ( message . getMessageId ( ) ) ; } catch ( Exception e ) { } } if ( message instanceof MqttPublish ) { synchronized ( queueLock ) { if ( actualInFlight >= this . maxInflight ) { log . fine ( className , methodName , "613" , new Object [ ] { new Integer ( actualInFlight ) } ) ; throw new MqttException ( MqttException . REASON_CODE_MAX_INFLIGHT ) ; } MqttMessage innerMessage = ( ( MqttPublish ) message ) . getMessage ( ) ; log . fine ( className , methodName , "628" , new Object [ ] { new Integer ( message . getMessageId ( ) ) , new Integer ( innerMessage . getQos ( ) ) , message } ) ; switch ( innerMessage . getQos ( ) ) { case 2 : outboundQoS2 . put ( new Integer ( message . getMessageId ( ) ) , message ) ; persistence . put ( getSendPersistenceKey ( message ) , ( MqttPublish ) message ) ; break ; case 1 : outboundQoS1 . put ( new Integer ( message . getMessageId ( ) ) , message ) ; persistence . put ( getSendPersistenceKey ( message ) , ( MqttPublish ) message ) ; break ; } tokenStore . saveToken ( token , message ) ; pendingMessages . addElement ( message ) ; queueLock . notifyAll ( ) ; } } else { log . fine ( className , methodName , "615" , new Object [ ] { new Integer ( message . getMessageId ( ) ) , message } ) ; if ( message instanceof MqttConnect ) { synchronized ( queueLock ) { tokenStore . saveToken ( token , message ) ; pendingFlows . insertElementAt ( message , 0 ) ; queueLock . notifyAll ( ) ; } } else { if ( message instanceof MqttPingReq ) { this . pingCommand = message ; } else if ( message instanceof MqttPubRel ) { outboundQoS2 . put ( new Integer ( message . getMessageId ( ) ) , message ) ; persistence . put ( getSendConfirmPersistenceKey ( message ) , ( MqttPubRel ) message ) ; } else if ( message instanceof MqttPubComp ) { persistence . remove ( getReceivedPersistenceKey ( message ) ) ; } synchronized ( queueLock ) { if ( ! ( message instanceof MqttAck ) ) { tokenStore . saveToken ( token , message ) ; } pendingFlows . addElement ( message ) ; queueLock . notifyAll ( ) ; } } } }
te	4	public void Recycle ( int RcmId , String itemFromUser , String PaymentType , double weight ) { r [ RcmId ] = new Recycler ( ) ; ArrayList < item > acceptableList = ( ( recycleMachine ) r [ RcmId ] ) . getAcceptableItems ( ) ; for ( item acceptableItem : acceptableList ) { if ( acceptableItem . getName ( ) . equalsIgnoreCase ( itemFromUser ) ) { try { ( ( Recycler ) r [ RcmId ] ) . recycleItem ( new item ( acceptableItem . getName ( ) , acceptableItem . getItemId ( ) , acceptableItem . getRate ( ) , weight ) , PaymentType ) ; java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { try { mainWindow f = new mainWindow ( ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; } } } ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; } } } }
te	8	public int spaceUniform ( ) throws IOException , SyntaxException { int i = 0 ; if ( savedSpaces != 0 ) { i = savedSpaces ; savedSpaces = 0 ; return i ; } int c = read ( ) , d ; if ( c != 9 && c != 32 ) { unread ( ) ; return 0 ; } i ++ ; while ( ( d = read ( ) ) == c ) i ++ ; if ( ( c == 9 && d == 32 ) || ( c == 32 && d == 9 ) ) throw new SyntaxException ( "Tabs and spaces mixed" ) ; unread ( ) ; return i ; }
te	6	protected void print ( Attribute [ ] attributes ) { for ( int i = 0 ; i < values . length ; ++ i ) { Attribute attribute = attributes [ i ] ; int printWidth = attribute . getPrintWidth ( ) ; Object value = values [ i ] ; switch ( attribute . getType ( ) ) { case int : System . out . format ( "%" + printWidth + "d" , ( int ) value ) ; break ; case DECIMAL : String doubleString = String . format ( "%" + printWidth + ".4f" , ( double ) value ) ; if ( doubleString . length ( ) > printWidth ) System . out . format ( "%" + printWidth + ".3e" , ( double ) value ) ; else System . out . print ( doubleString ) ; break ; case char : System . out . format ( "%-" + printWidth + "s" , ( String ) value ) ; break ; } if ( i != values . length - 1 ) System . out . print ( " " ) ; } System . out . println ( "" ) ; }
te	9	public static void build_diagonal_block ( char [ ] [ ] result , String p , boolean alter ) { int row = result . length ; int col = result [ 0 ] . length ; int cur_pos = 0 ; for ( int i = 0 ; i < row + col ; i ++ ) { if ( cur_pos >= p . length ( ) ) break ; if ( alter ) { if ( i % 2 == 0 ) { int j = i < row ? i : row - 1 ; int k = i - j ; while ( j >= 0 && k < col ) { result [ j -- ] [ k ++ ] = p . charAt ( cur_pos ) ; cur_pos ++ ; if ( cur_pos >= p . length ( ) ) break ; } } else { int j = i < col ? i : col - 1 ; int k = i - j ; while ( k < row && j >= 0 ) { result [ k ++ ] [ j -- ] = p . charAt ( cur_pos ) ; cur_pos ++ ; if ( cur_pos >= p . length ( ) ) break ; } } } else { int j = i < col ? i : col - 1 ; int k = i - j ; while ( k < row && j >= 0 ) { result [ k ++ ] [ j -- ] = p . charAt ( cur_pos ) ; cur_pos ++ ; } } } }
te	8	public static boolean registerInstance ( ) { boolean returnValueOnError = true ; try { final ServerSocket socket = new ServerSocket ( SINGLE_INSTANCE_NETWORK_SOCKET , 10 , InetAddress . getLocalHost ( ) ) ; log . info ( "Listening for application instances on socket " + SINGLE_INSTANCE_NETWORK_SOCKET ) ; Thread instanceListenerThread = new Thread ( new Runnable ( ) { public void run ( ) { boolean socketClosed = false ; while ( ! socketClosed ) { if ( socket . isClosed ( ) ) { socketClosed = true ; } else { try { Socket client = socket . accept ( ) ; BufferedReader in = new BufferedReader ( new InputStreamReader ( client . getInputStream ( ) ) ) ; String message = in . readLine ( ) ; if ( SINGLE_INSTANCE_SHARED_KEY . trim ( ) . equals ( message . trim ( ) ) ) { log . info ( "Shared key matched - new application instance found" ) ; fireNewInstance ( ) ; } in . close ( ) ; client . close ( ) ; } catch ( IOException e ) { socketClosed = true ; } } } } } ) ; instanceListenerThread . start ( ) ; } catch ( UnknownHostException e ) { log . error ( "Error" , e ) ; return returnValueOnError ; } catch ( IOException e ) { log . info ( "Port is already taken.  Notifying first instance." ) ; try { Socket clientSocket = new Socket ( InetAddress . getLocalHost ( ) , SINGLE_INSTANCE_NETWORK_SOCKET ) ; OutputStream out = clientSocket . getOutputStream ( ) ; out . write ( SINGLE_INSTANCE_SHARED_KEY . getBytes ( ) ) ; out . close ( ) ; clientSocket . close ( ) ; log . info ( "Successfully notified first instance." ) ; return false ; } catch ( UnknownHostException e1 ) { log . error ( "Error" , e ) ; return returnValueOnError ; } catch ( IOException e1 ) { log . error ( "Error connecting to local port for single instance notification" , e ) ; return returnValueOnError ; } } return true ; }
te	1	public void createNewLooseSnakePiece ( ) { Random random = new Random ( ) ; int randomX = 0 ; int randomY = 0 ; do { randomX = random . nextInt ( width + 1 ) ; randomY = random . nextInt ( height + 1 ) ; } while ( ! coordinatesAreFree ( randomX , randomY ) ) ; SnakePiece snakePiece = new SnakePiece ( randomX , randomY , SnakePieceType . LOOSE ) ; addLooseSnakePiece ( snakePiece ) ; }
te	9	@ SuppressWarnings ( { "unchecked" } ) public static < K , V > Map < K , V > generateMapField ( class < K > keyType , class < V > valueType ) { Random random = new Random ( 987654321 ) ; Map < K , V > map = new HashMap < K , V > ( ) ; for ( int i = 0 ; i < 20 ; i ++ ) { K key = null ; if ( keyType == String . class ) { key = ( K ) String . valueOf ( random . nextInt ( ) ) ; } else if ( keyType == Integer . class ) { key = ( K ) Integer . valueOf ( random . nextInt ( ) ) ; } else if ( keyType == long . class ) { key = ( K ) long . valueOf ( random . nextLong ( ) ) ; } V value = null ; if ( valueType == String . class ) { value = ( V ) String . valueOf ( random . nextInt ( ) ) ; } else if ( valueType == Integer . class ) { value = ( V ) Integer . valueOf ( random . nextInt ( ) ) ; } else if ( valueType == long . class ) { value = ( V ) long . valueOf ( random . nextLong ( ) ) ; } else if ( valueType == double . class ) { value = ( V ) double . valueOf ( random . nextDouble ( ) ) ; } else if ( valueType == byte [ ] . class ) { byte [ ] bytes = Bytes . toBytes ( random . nextInt ( ) ) ; value = ( V ) bytes ; } map . put ( key , value ) ; } return map ; }
te	8	public Entity findTarget ( ) { double r = weapon . maxRange ; List < Entity > es = level . getEntities ( x - r , y - r , z - r , x + r , y + r , z + r ) ; Entity closest = null ; for ( int i = 0 ; i < es . size ( ) ; i ++ ) { Entity e = es . get ( i ) ; if ( e instanceof Mob && e != this ) { Mob u = ( Mob ) e ; if ( u . isAlive ( ) && u . distanceToSqr ( this ) < r * r && isLegalTarget ( u ) ) { if ( closest == null ) { closest = e ; } else if ( e . distanceToSqr ( this ) < closest . distanceToSqr ( this ) ) { closest = e ; } } } } return closest ; }
te	5	private static List < ImageFile > loadImagesFromFiles ( File [ ] files ) { if ( files == null ) return null ; List < ImageFile > imgs = new ArrayList < > ( ) ; if ( loadProgress != null ) { loadProgress . visible = true ; loadProgress . max = files . length ; loadProgress . set ( 0 ) ; } for ( File file : files ) { CrossBitmap img = loadImg ( file ) ; if ( img != null ) { imgs . add ( new ImageFile ( img , getFileName ( file . getAbsolutePath ( ) ) ) ) ; } if ( loadProgress != null ) { loadProgress . set ( loadProgress . value + 1 ) ; Main . main . canvas . paint ( ) ; } } return imgs ; }
te	6	public void keyPressed ( KeyEvent e ) { if ( e . getKeyCode ( ) == e . VK_ENTER && patientTA [ 0 ] . isFocusOwner ( ) == true ) { patientTA [ 0 ] . append ( "." ) ; st = patientTA [ 0 ] . getText ( ) ; } if ( e . getKeyCode ( ) == e . VK_ENTER && patientTA [ 1 ] . isFocusOwner ( ) == true ) { patientTA [ 1 ] . append ( "." ) ; st1 = patientTA [ 1 ] . getText ( ) ; } else if ( e . getKeyCode ( ) == e . VK_ENTER && patientTA [ 2 ] . isFocusOwner ( ) == true ) { patientTA [ 2 ] . append ( "." ) ; st2 = patientTA [ 2 ] . getText ( ) ; } }
te	7	public static String doubleToString ( double d ) { if ( double . isInfinite ( d ) || double . isNaN ( d ) ) { return "null" ; } String string = double . toString ( d ) ; if ( string . indexOf ( . ) > 0 && string . indexOf ( e ) < 0 && string . indexOf ( E ) < 0 ) { while ( string . endsWith ( "0" ) ) { string = string . substring ( 0 , string . length ( ) - 1 ) ; } if ( string . endsWith ( "." ) ) { string = string . substring ( 0 , string . length ( ) - 1 ) ; } } return string ; }
te	2	public static void main ( String [ ] args ) { double firstOprand , secondOperand ; String operatorString ; @ SuppressWarnings ( "resource" ) Scanner stdin = new Scanner ( System . in ) ; System . out . println ( "Input A" ) ; firstOprand = stdin . nextDouble ( ) ; do { System . out . println ( "Input operator(+-*/)" ) ; operatorString = stdin . next ( ) ; if ( operatorString . matches ( "[+-/|\\u002a]" ) ) break ; } while ( true ) ; System . out . println ( "Input B" ) ; secondOperand = stdin . nextDouble ( ) ; DoubleOperation2 operation = OperationFactory . createOperation ( operatorString ) ; System . out . println ( operation . getResult ( new double [ ] { firstOprand , secondOperand } ) ) ; }
te	1	private static void pokazInicjalizacje ( int [ ] liczby ) { for ( int index = 0 ; index < liczby . length ; index ++ ) { System . out . println ( "liczby[" + index + "]=" + liczby [ index ] ) ; } }
te	6	protected void processRequest ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException , ClassNotFoundException , SQLException { Authenticator auth = new Authenticator ( request ) ; response . setContentType ( "text/html;charset=UTF-8" ) ; PrintWriter out = response . getWriter ( ) ; try { if ( ! auth . Login ( ) ) { response . sendRedirect ( "login.jsp" ) ; } int table_id ; String str ; int start_index ; int max_fetch ; if ( request . getParameter ( "table_no" ) != null && request . getParameter ( "query" ) != null && request . getParameter ( "starting_index" ) != null && request . getParameter ( "max_results" ) != null ) { table_id = Integer . parseInt ( request . getParameter ( "table_no" ) ) ; str = request . getParameter ( "query" ) ; start_index = Integer . parseInt ( request . getParameter ( "starting_index" ) ) ; max_fetch = Integer . parseInt ( request . getParameter ( "max_results" ) ) ; try { out . println ( mainSearch . query ( table_id , str , start_index , max_fetch ) ) ; } catch ( Exception ex ) { Logger . getLogger ( Search . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } } } finally { out . close ( ) ; } }
te	4	static int straightFlush ( int [ ] player ) { if ( player [ 0 ] == player [ 1 ] - 4 && player [ 1 ] == player [ 2 ] - 4 && player [ 2 ] == player [ 3 ] - 4 && player [ 3 ] == player [ 4 ] - 4 ) return player [ 0 ] / 4 ; else return - 1 ; }
te	7	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( Vista . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( Vista . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( Vista . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( Vista . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } try { setDefaultLookAndFeelDecorated ( true ) ; JDialog . setDefaultLookAndFeelDecorated ( true ) ; UIManager . setLookAndFeel ( UIManager . getSystemLookAndFeelClassName ( ) ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { new Vista ( ) . setVisible ( true ) ; } } ) ; }
te	8	private boolean r_Step_1c ( ) { int v_1 ; ket = cursor ; lab0 : do { v_1 = limit - cursor ; lab1 : do { if ( ! ( eq_s_b ( 1 , "y" ) ) ) { break lab1 ; } break lab0 ; } while ( false ) ; cursor = limit - v_1 ; if ( ! ( eq_s_b ( 1 , "Y" ) ) ) { return false ; } } while ( false ) ; bra = cursor ; golab2 : while ( true ) { lab3 : do { if ( ! ( in_grouping_b ( g_v , 97 , 121 ) ) ) { break lab3 ; } break golab2 ; } while ( false ) ; if ( cursor <= limit_backward ) { return false ; } cursor -- ; } slice_from ( "i" ) ; return true ; }
te	3	public String generateQueryFromOWL ( ) { String category = "Tablet" ; String mobileInternetFilter = "" ; double priceLowerFilter = 0 ; double priceUpperFilter = Integer . MAX_VALUE ; String performance = scenario . getPerformance ( ) ; String performanceFilter = "" ; if ( ! performance . isEmpty ( ) ) performanceFilter = " AND Kategorie LIKE \"%" + performance + "%\"" ; String os = scenario . getOperatingSystemName ( ) ; String osFilter = "" ; String mobileInternet = "" ; if ( ! scenario . getIsMobileInternetRequested ( ) ) { mobileInternet = "Wifi" ; } else { mobileInternet = "Wifi +%" ; } if ( ! os . isEmpty ( ) ) osFilter = " AND betriebssystem LIKE '%" + os + "%'" ; mobileInternetFilter = " AND connectionType LIKE '" + mobileInternet + "'" ; String [ ] bereich = OntologyRequest . getBudgetForCategory ( scenario . getBudgetOntologie ( ) , category ) ; category = category . toLowerCase ( ) ; priceLowerFilter = double . valueOf ( bereich [ 2 ] ) ; priceUpperFilter = double . valueOf ( bereich [ 4 ] ) ; String query = "SELECT * FROM " + category + " WHERE preis >= " + priceLowerFilter + " AND preis <= " + priceUpperFilter + mobileInternetFilter + osFilter + performanceFilter ; return query ; }
te	6	public void importRecord ( String exportFileLocation ) throws IOException { String exportedRecordFileName = exportFileLocation + "records.xml" ; String siteFileName = exportFileLocation + "site.xml" ; StatResultSet resultSetRecord = parser . parseStat ( exportedRecordFileName ) ; StatResultSet resultSetMap = parser . parseStat ( siteFileName ) ; Map < String , String > siteMap = siteMapper . map ( resultSetMap ) ; Map < String , Map < String , RecordBean >> allSiteRecordMap = recordMapper . map ( resultSetRecord , siteMap ) ; List < SiteModel > sites = siteDao . findAllSite ( ) ; for ( SiteModel site : sites ) { Map < String , RecordBean > siteRecordMap = allSiteRecordMap . get ( site . getCode ( ) ) ; if ( siteRecordMap == null ) { log . debug ( "Not found export for site {}" , site . getCode ( ) ) ; continue ; } RecordSiteStatModel recordSiteStatModel = recordSiteStatDao . findBySiteId ( site . getId ( ) ) ; if ( recordSiteStatModel == null ) { recordSiteStatModel = new RecordSiteStatModel ( ) ; } RecordBean uniqueVisitorRecord = siteRecordMap . get ( "unique_visitors_total" ) ; if ( uniqueVisitorRecord . getNumber ( ) > recordSiteStatModel . getUniqueVisitor ( ) ) { recordSiteStatModel . setUniqueVisitor ( uniqueVisitorRecord . getNumber ( ) ) ; recordSiteStatModel . setUniqueVisitorDate ( DateTimeFormatUtil . parseDateTime ( uniqueVisitorRecord . getDate ( ) ) ) ; } RecordBean pageViewRecord = siteRecordMap . get ( "page_views_total" ) ; if ( pageViewRecord . getNumber ( ) > recordSiteStatModel . getPageView ( ) ) { recordSiteStatModel . setPageView ( pageViewRecord . getNumber ( ) ) ; recordSiteStatModel . setPageViewDate ( DateTimeFormatUtil . parseDateTime ( pageViewRecord . getDate ( ) ) ) ; } RecordBean visitRecord = siteRecordMap . get ( "sessions_total" ) ; if ( visitRecord . getNumber ( ) > recordSiteStatModel . getVisit ( ) ) { recordSiteStatModel . setVisit ( visitRecord . getNumber ( ) ) ; recordSiteStatModel . setVisitDate ( DateTimeFormatUtil . parseDateTime ( visitRecord . getDate ( ) ) ) ; } recordSiteStatModel . setSite ( site ) ; recordSiteStatDao . save ( recordSiteStatModel ) ; } }
te	4	private int findFirstUnescaped ( String search , char find ) { int pos = 0 ; while ( true ) { pos = search . indexOf ( find , pos ) ; if ( pos < 0 ) return - 1 ; if ( pos == 0 || search . charAt ( pos - 1 ) != \ ) return pos ; ++ pos ; } }
te	2	public Morpha ( java . io . Reader in ) { options = new int [ 4 ] ; for ( int j = 0 ; j < options . length ; j ++ ) { options [ j ] = 1 ; } options [ 0 ] = 0 ; verbStemSet = loadVerbStemSet ( verbStems ) ; if ( noTags ) { yybegin ( any ) ; } else { yybegin ( scan ) ; } this . zzReader = in ; }
te	8	boolean parseMessage ( Message request ) { clientIdToServer = new String ( request . contents . getAttributes ( ) . getNamedItem ( "id" ) . getNodeValue ( ) ) ; Node child = request . contents . getFirstChild ( ) ; if ( child . getAttributes ( ) . getNamedItem ( "type" ) . getNodeValue ( ) . equals ( "open" ) ) myType = EventType . OPEN ; else if ( child . getAttributes ( ) . getNamedItem ( "type" ) . getNodeValue ( ) . equals ( "closed" ) ) myType = EventType . CLOSED ; else myType = EventType . ERROR ; if ( child . getAttributes ( ) . getNamedItem ( "behavior" ) . getNodeValue ( ) . equals ( "roundRobin" ) ) myBehavior = Behavior . ROUNDROBIN ; else if ( child . getAttributes ( ) . getNamedItem ( "behavior" ) . getNodeValue ( ) . equals ( "asynchronous" ) ) myBehavior = Behavior . ASYNCHRONOUS ; else myBehavior = Behavior . ERROR ; myQuestion = new String ( child . getAttributes ( ) . getNamedItem ( "question" ) . getNodeValue ( ) ) ; numOfChoices = Integer . parseInt ( child . getAttributes ( ) . getNamedItem ( "numChoices" ) . getNodeValue ( ) ) ; numOfRounds = Integer . parseInt ( child . getAttributes ( ) . getNamedItem ( "numRounds" ) . getNodeValue ( ) ) ; NodeList myList = child . getChildNodes ( ) ; for ( int i = 0 ; i < myList . getLength ( ) ; i ++ ) { if ( myList . item ( i ) . getNodeName ( ) . equals ( "choice" ) ) { String choiceName = new String ( "" ) ; int indexOf = - 1 ; choiceName = myList . item ( i ) . getAttributes ( ) . getNamedItem ( "value" ) . getNodeValue ( ) ; indexOf = Integer . parseInt ( myList . item ( i ) . getAttributes ( ) . getNamedItem ( "index" ) . getNodeValue ( ) ) ; Choice newChoice = new Choice ( choiceName , indexOf , - 1 ) ; myChoices . add ( newChoice ) ; } else if ( myList . item ( i ) . getNodeName ( ) . equals ( "user" ) ) { moderator = myList . item ( i ) . getAttributes ( ) . getNamedItem ( "name" ) . getNodeValue ( ) ; if ( myList . item ( i ) . getAttributes ( ) . getNamedItem ( "password" ) != null ) moderatorPassword = myList . item ( i ) . getAttributes ( ) . getNamedItem ( "password" ) . getNodeValue ( ) ; else moderatorPassword = new String ( "" ) ; } } return true ; }
te	9	public Tree parseClass ( final int flags ) { if ( 0 == flags ) { return internalError ( ) ; } if ( ! poll ( kClass ) ) { return expected ( kClass ) ; } final Name name = parseName ( ) ; final class klass = init ( new class ( name ) ) ; if ( peek ( kLBrac ) ) { final Optional < Tree > error = parseTypeParameterList ( klass . typeParameters ) ; if ( error . isPresent ( ) ) { return error . get ( ) ; } } if ( poll ( kLParen ) ) { if ( ! poll ( kRParen ) ) { return expected ( kRParen ) ; } } if ( poll ( kColon ) ) { do { klass . bases . add ( parseType ( ) ) ; } while ( poll ( kComma ) ) ; } if ( poll ( kLBrace ) ) { if ( ! poll ( kNewLine ) ) { return expected ( kNewLine ) ; } final List < Tree > members = klass . members ; while ( ! poll ( kRBrace ) ) { pollAllNewLine ( ) ; final Tree declaration = parseDeclarationOpt ( ) ; if ( null != declaration ) { members . add ( declaration ) ; } if ( ! poll ( kNewLine ) ) { return expected ( kNewLine ) ; } } } return klass . withFlags ( flags ) ; }
te	8	private String getNotificationText ( NotificationModel model ) { String text = "" ; SimpleDateFormat time = new SimpleDateFormat ( "HH:mm" ) ; SimpleDateFormat date = new SimpleDateFormat ( "dd/MM" ) ; if ( model . getType ( ) == NotificationType . A_CANCELED ) { text = model . getRegardsUser ( ) . getFullName ( ) + " har avlyst m" + oe + "tet" ; if ( model . getRegardsMeeting ( ) . getName ( ) != null ) text += " med navn '" + model . getRegardsMeeting ( ) . getName ( ) + "'" ; text += " kl " + time . format ( model . getRegardsMeeting ( ) . getTimeFrom ( ) . getTime ( ) ) ; text += " den " + date . format ( model . getRegardsMeeting ( ) . getTimeFrom ( ) . getTime ( ) ) ; } else if ( model . getType ( ) == NotificationType . A_EDITED ) { text = model . getRegardsUser ( ) . getFullName ( ) + " har redigert detaljer i" ; if ( model . getRegardsMeeting ( ) . getName ( ) != null ) text += " m" + oe + "tet med navn '" + model . getRegardsMeeting ( ) . getName ( ) + "'" ; else text += " et m" + oe + "te dere har " ; text += " kl " + time . format ( model . getRegardsMeeting ( ) . getTimeFrom ( ) . getTime ( ) ) ; text += " den " + date . format ( model . getRegardsMeeting ( ) . getTimeFrom ( ) . getTime ( ) ) ; text += ". Dobbeltklikk for " + aa + " se detaljer." ; } else if ( model . getType ( ) == NotificationType . A_INVITATION ) { text = model . getRegardsUser ( ) . getFullName ( ) + " har invitert deg til et m" + oe + "te" ; if ( model . getRegardsMeeting ( ) . getName ( ) != null ) text += " med navn '" + model . getRegardsMeeting ( ) . getName ( ) + "'" ; text += " fra kl " + time . format ( model . getRegardsMeeting ( ) . getTimeFrom ( ) . getTime ( ) ) + " til kl " + time . format ( model . getRegardsMeeting ( ) . getTimeTo ( ) . getTime ( ) ) + " den " + date . format ( model . getRegardsMeeting ( ) . getTimeFrom ( ) . getTime ( ) ) + ". Dobbeltklikk for " + aa + " se detaljer." ; } else if ( model . getType ( ) == NotificationType . A_USER_DENIED ) { text += model . getRegardsUser ( ) . getFullName ( ) + " har avsl" + aa + "tt invitasjon til" ; if ( model . getRegardsMeeting ( ) . getName ( ) != null ) text += " m" + oe + "tet med navn '" + model . getRegardsMeeting ( ) . getName ( ) + "'" ; else text += " et m" + oe + "te dere har " ; text += " kl " + time . format ( model . getRegardsMeeting ( ) . getTimeFrom ( ) . getTime ( ) ) ; text += " den " + date . format ( model . getRegardsMeeting ( ) . getTimeFrom ( ) . getTime ( ) ) ; text += ". Dobbeltklikk for " + aa + " redigere m" + oe + "tedetaljer." ; } return text ; }
te	9	public void convertEventsOfTicket ( Issue issue , Ticket ticket ) { for ( Event e : ticket . getEvents ( ) ) { Person p = provider . getPeopleConverter ( ) . findPersonById ( e . getPersonId ( ) ) ; String username = null ; if ( null != p ) { username = p . getName ( ) ; } boolean eventSupported = false ; String changedTo = "" ; String field = "" ; Log l = new Log ( ) ; switch ( e . getEvent ( ) ) { case "create" : eventSupported = true ; changedTo = Status . new . getName ( ) ; field = "status" ; break ; case "accept" : case "reassign" : case "reopen" : eventSupported = true ; changedTo = Status . OPEN . getName ( ) ; field = "status" ; break ; case "close" : case "resolve" : eventSupported = true ; changedTo = Status . RESOLVED . getName ( ) ; field = "status" ; break ; case "update" : eventSupported = false ; break ; default : eventSupported = false ; break ; } if ( eventSupported ) { Date createdOn = e . getCreatedAt ( ) . toGregorianCalendar ( ) . getTime ( ) ; Comment comment = new Comment ( e . getDescription ( ) , createdOn , provider . getCommentsConverter ( ) . getUniqueCommentId ( ) , ticket . getId ( ) , createdOn , username ) ; provider . getCommentsConverter ( ) . add ( comment ) ; l . setChangedTo ( changedTo ) ; l . setCommentId ( comment . getId ( ) ) ; l . setCreatedOn ( createdOn ) ; l . setField ( field ) ; l . setIssue ( issue . getId ( ) ) ; l . setUser ( username ) ; logs . add ( l ) ; } } }
te	8	@ Override public void onCommand ( POP3Session session , String argument1 , String argument2 ) throws POP3Exception { if ( session . getState ( ) != POP3State . TRANSACTION ) { throw new POP3Exception ( "-ERR auth first" ) ; } if ( argument1 == null || argument2 != null ) { throw new POP3Exception ( "-ERR syntax error" ) ; } int emailNum = - 1 ; try { emailNum = Integer . parseInt ( argument1 ) ; } catch ( NumberFormatException e ) { throw new POP3Exception ( "-ERR syntax error" ) ; } User user = session . getUser ( ) ; if ( emailNum <= 0 || emailNum > user . getEmailNumber ( ) ) { throw new POP3Exception ( "-ERR no such message  only " + user . getEmailNumber ( ) + " messages in maildrop" ) ; } Email email = session . getUser ( ) . getEmailList ( ) . get ( emailNum - 1 ) ; if ( email . isDeleted ( ) == true ) { throw new POP3Exception ( "-ERR message already deleted" ) ; } session . sendResponse ( "+OK " + EmailUtil . getEmailSize ( email ) + " octets" ) ; String content = email . getContent ( ) ; String temp [ ] = content . split ( "\n" ) ; for ( String t : temp ) { session . sendResponse ( t ) ; } session . sendResponse ( "." ) ; }
te	3	@ Override protected void updateBeliefs ( ) { for ( int i = 0 ; i < sampleCount ; i ++ ) { Map < BayesNode , String > sample = sampler . sample ( ) ; boolean isConsistentWithEvidence = isConsistenWithEvidence ( sample ) ; if ( ! isConsistentWithEvidence ) { i -- ; continue ; } for ( BayesNode e : sample . keySet ( ) ) { beliefs [ e . getId ( ) ] [ e . getOutcomeIndex ( sample . get ( e ) ) ] ++ ; } } normalizeBeliefs ( ) ; }
te	3	public static void main ( String [ ] args ) throws Exception { if ( ! updatedToday ( ) ) { try { DBStore db = new DBStore ( ) ; String [ ] zips = scanZips ( "zips.txt" ) ; System . out . println ( "1" ) ; WeatherData [ ] wd = grabData ( zips ) ; System . out . println ( "2" ) ; db . open ( ) ; recordFiles ( wd , db ) ; db . close ( ) ; System . out . println ( "3" ) ; SimpleDateFormat format = getYMDFormatter ( ) ; FileWriter fileWriter ; fileWriter = new FileWriter ( LOG_NAME , false ) ; PrintWriter out = new PrintWriter ( fileWriter , true ) ; out . print ( "ok " + format . format ( new Date ( ) ) ) ; out . close ( ) ; } catch ( Exception e ) { FileWriter fileWriter ; try { fileWriter = new FileWriter ( LOG_NAME , false ) ; PrintWriter out = new PrintWriter ( fileWriter , true ) ; SimpleDateFormat format = getDateFormatter ( ) ; out . print ( "error " + format . format ( new Date ( ) ) ) ; out . close ( ) ; printError ( e , "" ) ; } catch ( IOException e1 ) { e1 . printStackTrace ( ) ; } } } }
te	4	@ Override public void actionPerformed ( ActionEvent e ) { switch ( e . getActionCommand ( ) ) { case "Cargar mapa" : this . modelosjtoolbaropciones . loadMapa ( ) ; break ; case "Guardar mapa" : this . modelosjtoolbaropciones . saveMapa ( ) ; break ; case "Iniciar" : this . modelosjtoolbaropciones . start ( ) ; if ( JPanelJuego . getInstance ( null ) . getEnemigos ( ) != null ) JPanelJuego . getInstance ( null ) . activarInteligencias ( ) ; break ; } }
te	1	public double getMinLon ( ) { if ( _minLon == null ) calcExtremes ( ) ; return _minLon ; }
te	1	public void setType ( String type ) { if ( type . toLowerCase ( ) . equals ( "digital" ) ) { isDigital = true ; } else { isDigital = false ; } }
te	5	private void createNodes ( DistinguishedName dn , Map < String , String > entries ) { Stack < DistinguishedNameNode > items = new Stack < DistinguishedNameNode > ( ) ; Set < Map . Entry < String , String >> elements = entries . entrySet ( ) ; for ( Map . Entry < String , String > entry : elements ) { if ( entry . getKey ( ) . equalsIgnoreCase ( DistinguishedNameNodeType . DC . getCode ( ) ) ) { DistinguishedNameNode node = new DistinguishedNameNode ( DistinguishedNameNodeType . DC , entry . getValue ( ) ) ; items . push ( node ) ; } else if ( entry . getKey ( ) . equalsIgnoreCase ( DistinguishedNameNodeType . CN . getCode ( ) ) ) { DistinguishedNameNode node = new DistinguishedNameNode ( DistinguishedNameNodeType . CN , entry . getValue ( ) ) ; items . push ( node ) ; } else if ( entry . getKey ( ) . equalsIgnoreCase ( DistinguishedNameNodeType . OU . getCode ( ) ) ) { DistinguishedNameNode node = new DistinguishedNameNode ( DistinguishedNameNodeType . OU , entry . getValue ( ) ) ; items . push ( node ) ; } } while ( ! items . empty ( ) ) { dn . push ( items . pop ( ) ) ; } }
te	6	@ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; Host other = ( Host ) obj ; if ( hostId == null ) { if ( other . hostId != null ) return false ; } else if ( ! hostId . equals ( other . hostId ) ) return false ; return true ; }
te	8	public static Object decodeToObject ( String encodedObject , int options , final ClassLoader loader ) throws java . io . IOException , java . lang . ClassNotFoundException { byte [ ] objBytes = decode ( encodedObject , options ) ; java . io . ByteArrayInputStream bais = null ; java . io . ObjectInputStream ois = null ; Object obj = null ; try { bais = new java . io . ByteArrayInputStream ( objBytes ) ; if ( loader == null ) { ois = new java . io . ObjectInputStream ( bais ) ; } else { ois = new java . io . ObjectInputStream ( bais ) { @ Override public class < ? > resolveClass ( java . io . ObjectStreamClass streamClass ) throws java . io . IOException , ClassNotFoundException { class < ? > c = class . forName ( streamClass . getName ( ) , false , loader ) ; if ( c == null ) { return super . resolveClass ( streamClass ) ; } else { return c ; } } } ; } obj = ois . readObject ( ) ; } catch ( java . io . IOException e ) { throw e ; } catch ( java . lang . ClassNotFoundException e ) { throw e ; } finally { try { bais . close ( ) ; } catch ( Exception e ) { } try { ois . close ( ) ; } catch ( Exception e ) { } } return obj ; }
te	9	@ Override public ChunkInfo write ( DataOutputStream out , PassthroughConnection ptc , KillableThread thread , boolean serverToClient ) { while ( true ) { try { out . writeInt ( value . x ) ; } catch ( SocketTimeoutException toe ) { if ( timedOut ( thread ) ) { continue ; } return null ; } catch ( IOException e ) { return null ; } try { out . writeInt ( value . z ) ; } catch ( SocketTimeoutException toe ) { if ( timedOut ( thread ) ) { continue ; } return null ; } catch ( IOException e ) { return null ; } try { out . writeBoolean ( value . mode ) ; } catch ( SocketTimeoutException toe ) { if ( timedOut ( thread ) ) { continue ; } return null ; } catch ( IOException e ) { return null ; } incrementCounter ( serverToClient , 9 , ptc ) ; super . timeout = 0 ; return value ; } }
te	2	private void setPlayersScore ( ) { for ( Control control : this . score_group . getChildren ( ) ) { control . dispose ( ) ; } Label scores = new Label ( this . score_group , 0 ) ; scores . setText ( "Players&Scores" ) ; for ( int i = 0 ; i < this . players_label . length ; i ++ ) { this . players_label [ i ] = new Label ( this . score_group , 0 ) ; this . players_label [ i ] . setText ( this . players [ i ] + ": " + this . game . getPlayerNameAndScore ( ) . get ( this . players [ i ] ) ) ; } this . gameInformation . layout ( ) ; this . score_group . layout ( ) ; }
te	2	private void fileProcess ( File file ) throws InterruptedException { if ( file . getName ( ) . equals ( fileName ) ) { System . out . printf ( "%s : %s\n" , Thread . currentThread ( ) . getName ( ) , file . getAbsolutePath ( ) ) ; } if ( Thread . interrupted ( ) ) { throw new InterruptedException ( ) ; } }
te	9	@ Override public void validarSemantica ( ) { if ( InfSemantica . getInstancia ( ) . tablaGlobal . containsKey ( nombre ) && TablaIds . getInstancia ( ) . getVariableNumber ( nombre ) == - 1 ) { try { throw new Exception ( "Error Semantico--- Ya existe una variable con ese nombre" ) ; } catch ( Exception ex ) { Logger . getLogger ( TipoDeclaracion . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } } else { if ( tipo instanceof TipoRecord ) { TipoRecord tmp = ( ( TipoRecord ) tipo ) ; Declaracion tmp1 = tmp . getDecl ( ) ; VarDeclaracion var = null ; String name = null ; Tipo tip = null ; tmp . nombre = nombre ; while ( tmp1 instanceof VarDeclaracion ) { var = ( ( VarDeclaracion ) tmp1 ) ; for ( int i = 0 ; i < var . nombre . size ( ) ; i ++ ) { try { name = var . nombre . get ( i ) ; tip = var . getTipo ( ) ; if ( tip instanceof TipoId ) { TipoId tid = ( ( TipoId ) tip ) ; if ( InfSemantica . getInstancia ( ) . tablaGlobal . containsKey ( tid . getNombre ( ) ) ) { Tipo t = InfSemantica . getInstancia ( ) . tablaGlobal . get ( tid . getNombre ( ) ) ; tmp . tbsimbolo . addVariable ( name , t ) ; } else { throw new Exception ( "Error Semantico -- El tipo " + name + " no a sido declarado" ) ; } } else if ( tip instanceof TipoArray ) { TipoArray tarrray = ( ( TipoArray ) tip ) ; if ( tarrray . getT ( ) instanceof TipoId ) { TipoId tid = ( ( TipoId ) tarrray . getT ( ) ) ; if ( InfSemantica . getInstancia ( ) . tablaGlobal . containsKey ( tid . getNombre ( ) ) ) { Tipo t = InfSemantica . getInstancia ( ) . tablaGlobal . get ( tid . getNombre ( ) ) ; tarrray . setT ( t ) ; tmp . tbsimbolo . addVariable ( name , tarrray ) ; } else { throw new Exception ( "Error Semantico -- El tipo " + name + " no a sido declarado" ) ; } } } else { tmp . tbsimbolo . addVariable ( name , tip ) ; } } catch ( Exception ex ) { Logger . getLogger ( TipoDeclaracion . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } } tmp1 = tmp1 . getSiguiente ( ) ; } InfSemantica . getInstancia ( ) . tablaGlobal . put ( nombre , tmp ) ; } else { InfSemantica . getInstancia ( ) . tablaGlobal . put ( nombre , tipo ) ; TablaIds . getInstancia ( ) . addVariable ( nombre , tipo . toString ( ) ) ; } } }
te	8	public ListNode mergeKLists ( ArrayList < ListNode > lists ) { if ( lists == null || lists . size ( ) == 0 ) return null ; ListNode dummy = new ListNode ( 0 ) ; ListNode pre = dummy ; int k = lists . size ( ) ; PriorityQueue < ListNode > minHeap = new PriorityQueue < ListNode > ( k , new Comparator < ListNode > ( ) { public int compare ( ListNode node1 , ListNode node2 ) { int val1 = node1 . val ; int val2 = node2 . val ; if ( val1 < val2 ) return - 1 ; else if ( val1 > val2 ) return 1 ; else return 0 ; } } ) ; for ( ListNode node : lists ) { if ( node != null ) minHeap . add ( node ) ; } while ( ! minHeap . isEmpty ( ) ) { ListNode node = minHeap . poll ( ) ; pre . next = node ; pre = pre . next ; if ( node . next != null ) minHeap . add ( node . next ) ; } return dummy . next ; }
te	6	@ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; KineticLaw other = ( KineticLaw ) obj ; if ( math == null ) { if ( other . math != null ) return false ; } else if ( ! math . equals ( other . math ) ) return false ; return true ; }
te	8	public WorkerSetup ( ArrayList < Worker > workers ) { this . setPreferredSize ( new Dimension ( 425 , 450 ) ) ; this . workerTabs = new ArrayList < JPanel > ( ) ; initComponents ( ) ; for ( int c = 0 ; c < workers . size ( ) ; c ++ ) { this . addWorker ( ) ; } for ( int c = 0 ; c < workers . size ( ) ; c ++ ) { JTextField nameArea = ( JTextField ) this . workerTabs . get ( c ) . getComponent ( 2 ) ; nameArea . setText ( workers . get ( c ) . getName ( ) ) ; JTabbedPane daysPane = ( JTabbedPane ) this . workerTabs . get ( c ) . getComponents ( ) [ 0 ] ; for ( int i = 0 ; i < daysPane . getTabCount ( ) ; i ++ ) { for ( int n = 0 ; n < workers . get ( c ) . getDays ( ) . size ( ) ; n ++ ) { if ( daysPane . getTitleAt ( i ) . equals ( workers . get ( c ) . getDays ( ) . get ( n ) . getNameOfDay ( ) ) ) { JPanel day = ( JPanel ) daysPane . getComponent ( i ) ; JScrollPane pane = ( JScrollPane ) day . getComponent ( 0 ) ; JViewport view = ( JViewport ) pane . getComponent ( 0 ) ; JPanel p = ( JPanel ) view . getComponent ( 0 ) ; for ( Component job : p . getComponents ( ) ) { for ( String workerJob : workers . get ( c ) . getDays ( ) . get ( n ) . getJobs ( ) ) { if ( ( ( JCheckBox ) job ) . getText ( ) . equals ( workerJob ) ) { ( ( JCheckBox ) job ) . setSelected ( true ) ; } } } } } } } }
te	4	public Circle ( final IColumnVector < float > p , final Map < String , Object > attributesP , final float r , final Map < String , Object > attributesR ) { if ( p == null ) { throw new IllegalArgumentException ( "The paraneter 'p' must not be 'null'!" ) ; } if ( attributesP == null ) { throw new IllegalArgumentException ( "The paraneter 'attributesP' mut not be 'null'!" ) ; } if ( r <= 0f ) { throw new IllegalArgumentException ( "The paraneter 'r' must be larger than 0!" ) ; } if ( attributesR == null ) { throw new IllegalArgumentException ( "The paraneter 'attributesR' mut not be 'null'!" ) ; } this . p = p ; this . attributesP = attributesP ; this . r = r ; this . attributesR = attributesR ; }
te	6	protected boolean pointInPolygon ( final int pX , final int pY ) { int i , j = vertices . size ( ) - 1 ; boolean oddNodes = false ; for ( i = 0 ; i < vertices . size ( ) ; i ++ ) { if ( vertices . get ( i ) . get ( 1 , 0 ) < pY && vertices . get ( j ) . get ( 1 , 0 ) >= pY || vertices . get ( j ) . get ( 1 , 0 ) < pY && vertices . get ( i ) . get ( 1 , 0 ) >= pY ) { if ( vertices . get ( i ) . get ( 0 , 0 ) + ( pY - vertices . get ( i ) . get ( 1 , 0 ) ) / ( vertices . get ( j ) . get ( 1 , 0 ) - vertices . get ( i ) . get ( 1 , 0 ) ) * ( vertices . get ( j ) . get ( 0 , 0 ) - vertices . get ( i ) . get ( 0 , 0 ) ) < pX ) { oddNodes = ! oddNodes ; } } j = i ; } return oddNodes ; }
te	7	public static String doubleToString ( double d ) { if ( double . isInfinite ( d ) || double . isNaN ( d ) ) { return "null" ; } String string = double . toString ( d ) ; if ( string . indexOf ( . ) > 0 && string . indexOf ( e ) < 0 && string . indexOf ( E ) < 0 ) { while ( string . endsWith ( "0" ) ) { string = string . substring ( 0 , string . length ( ) - 1 ) ; } if ( string . endsWith ( "." ) ) { string = string . substring ( 0 , string . length ( ) - 1 ) ; } } return string ; }
te	3	public Link find ( String bookName ) { Link theLink = firstLink ; if ( ! isEmpty ( ) ) { while ( theLink . bookName != bookName ) { if ( theLink . next == null ) { return null ; } else { theLink = theLink . next ; } } } else { System . out . println ( "Empty LinkedList" ) ; } return theLink ; }
te	2	private void travelTree ( TreeNode node , List < Integer > result ) { TreeNode left = node . left ; TreeNode right = node . right ; if ( null != left ) travelTree ( left , result ) ; result . add ( node . val ) ; if ( null != right ) travelTree ( right , result ) ; }
te	8	public int getCollision ( int index ) { if ( index == - 1 ) return COLLISION_NONE ; switch ( map [ index ] ) { case 1 : return COLLISION_SOLID ; case 2 : return COLLISION_PLATFORM ; case 3 : return COLLISION_DAMAGE ; case 4 : return COLLISION_DESTRUCTIBLE | COLLISION_SOLID ; case 5 : return COLLISION_CLIMB ; case 6 : return COLLISION_CLIMB | COLLISION_PLATFORM ; case 7 : return COLLISION_HIDDEN ; default : return COLLISION_NONE ; } }
te	6	private static void generateSingleRelevantPatternHierarchy ( RequirementElement anti_goal , String target_pattern_id , LinkedList < String > relevant_attack_patterns , LinkedList < String > processed_pattern_ids ) { AttackPattern ap = findAttackPatternById ( target_pattern_id ) ; if ( ap != null ) { RequirementElement anti_task = new RequirementElement ( ap . name , InfoEnum . RequirementElementType . TASK . name ( ) , "none" ) ; ap . graphical_id = AppleScript . drawRequirementElement ( anti_task , anti_goal , "down" ) ; anti_task . setId ( ap . graphical_id ) ; processed_pattern_ids . add ( ap . id ) ; if ( ap . parents . size ( ) != 0 ) { boolean drawn = false ; for ( String parent_id : ap . parents ) { if ( ! relevant_attack_patterns . contains ( parent_id ) ) { } else { AttackPattern parent = findAttackPatternById ( parent_id ) ; if ( processed_pattern_ids . contains ( parent_id ) ) { AppleScript . drawArbitraryRequirementLink ( "Model" , "none" , parent . graphical_id , anti_task . getId ( ) , "SharpArrow" , "0" , "none" , "none" ) ; drawn = true ; } else { generateSingleRelevantPatternHierarchy ( anti_goal , parent_id , relevant_attack_patterns , processed_pattern_ids ) ; AppleScript . drawArbitraryRequirementLink ( "Model" , "none" , parent . graphical_id , anti_task . getId ( ) , "SharpArrow" , "0" , "none" , "none" ) ; drawn = true ; } } } if ( ! drawn ) { AppleScript . drawArbitraryRequirementLink ( "Model" , "none" , anti_goal . getId ( ) , anti_task . getId ( ) , "Arrow" , "0" , "none" , "none" ) ; } } else { AppleScript . drawArbitraryRequirementLink ( "Model" , "none" , anti_goal . getId ( ) , anti_task . getId ( ) , "Arrow" , "0" , "none" , "none" ) ; } } }
te	5	@ Override public boolean redo ( GameModel game ) { for ( JavaPlayer player : game . getPlayers ( ) ) { if ( famePointsWonPerPerson . get ( player ) != null ) { player . changeFamePoints ( famePointsWonPerPerson . get ( player ) ) ; } } for ( JavaPlayer player : game . getPlayers ( ) ) { if ( cardsToDiscardPerPerson . get ( player ) != null ) { ArrayList < PalaceCard > cardsToDiscard = cardsToDiscardPerPerson . get ( player ) ; for ( PalaceCard card : cardsToDiscard ) { player . removePalaceCard ( card ) ; game . getShared ( ) . discardCard ( card ) ; } } } game . getShared ( ) . discardCard ( festivalCard ) ; return false ; }
te	5	protected Connection getConnection ( ) { final ExampleDBInfoProvider provider = new ExampleDBInfoProvider ( ) ; final String driverName = provider . getJdbcDriverClassName ( ) ; try { DriverManager . registerDriver ( ( Driver ) class . forName ( driverName ) . newInstance ( ) ) ; } catch ( ClassNotFoundException e ) { handleDriverException ( driverName , e ) ; } catch ( SQLException e ) { handleDriverException ( driverName , e ) ; } catch ( InstantiationException e ) { handleDriverException ( driverName , e ) ; } catch ( IllegalAccessException e ) { handleDriverException ( driverName , e ) ; } final String url = provider . getUrl ( ) ; Connection conn = null ; try { log ( "DriverManager.getConnection(url  usr  pwd): url=" + url ) ; String user = provider . getUser ( ) ; String password = provider . getPassword ( ) ; conn = DriverManager . getConnection ( url , user , password ) ; } catch ( SQLException e ) { String msg = "DriverManager.getConnection(url  usr  pwd) threw the exception:" ; msg = msg + " url=" + url ; throw new RuntimeException ( msg , e ) ; } return conn ; }
te	2	private void grahamScan ( ) { convexHull . push ( pointsQueue . poll ( ) ) ; convexHull . push ( pointsQueue . poll ( ) ) ; while ( ! pointsQueue . isEmpty ( ) ) { Point pt2 = convexHull . pop ( ) ; Point pt1 = convexHull . peek ( ) ; convexHull . push ( pt2 ) ; Point pt3 = pointsQueue . poll ( ) ; if ( turnsLeft ( pt1 , pt2 , pt3 ) ) { convexHull . push ( pt3 ) ; } else { pointsQueue . add ( pt3 ) ; convexHull . pop ( ) ; } } }
te	1	public synchronized void writeWithException ( final String text ) throws Exception { bufferLines = bufferLines . concat ( text ) ; if ( bufferLines . length ( ) > bufferLimit ) { saveToDiskWithException ( bufferLines ) ; bufferLines = "" ; } }
te	0	@ Test public void testAsciiOneArgs ( ) { Object expression = "W" ; Integer expected = 87 ; Object actual = mFnc . $ascii ( expression ) ; assertEquals ( "Fail on convert with one arguments." , expected , actual ) ; }
