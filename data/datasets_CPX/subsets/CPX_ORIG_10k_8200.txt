te	3	@ Override public boolean checkSemantics ( List < Pin > pins ) { if ( pins . size ( ) < 1 ) { throw new RuntimeException ( ) ; } else { Iterator < Pin > it = pins . iterator ( ) ; while ( it . hasNext ( ) ) { Pin pin = it . next ( ) ; if ( pin . netsSize ( ) < 1 ) { throw new RuntimeException ( ) ; } else { pin . setAsInput ( ) ; } } } return true ; }
te	3	public Support getSupport ( Point p ) { for ( Node n : nodes ) { if ( isInside ( n , p ) ) { if ( n instanceof Support ) { return ( Support ) n ; } } } return null ; }
te	1	@ BeforeTest protected void setUp ( ) throws Exception { try { assert true == false ; throw new RuntimeException ( "Please enable assertions." ) ; } catch ( AssertionError e ) { } }
te	8	private void updateLocalPlayerMovement ( Buffer stream ) { stream . initBitAccess ( ) ; int currentlyUpdating = stream . readBits ( 1 ) ; if ( currentlyUpdating == 0 ) return ; int movementUpdateType = stream . readBits ( 2 ) ; if ( movementUpdateType == 0 ) { playersObserved [ playersObservedCount ++ ] = LOCAL_PLAYER_ID ; return ; } if ( movementUpdateType == 1 ) { int direction = stream . readBits ( 3 ) ; localPlayer . move ( false , direction ) ; int furtherUpdateRequired = stream . readBits ( 1 ) ; if ( furtherUpdateRequired == 1 ) playersObserved [ playersObservedCount ++ ] = LOCAL_PLAYER_ID ; return ; } if ( movementUpdateType == 2 ) { int lastDirection = stream . readBits ( 3 ) ; localPlayer . move ( true , lastDirection ) ; int currentDirection = stream . readBits ( 3 ) ; localPlayer . move ( true , currentDirection ) ; int updateRequired = stream . readBits ( 1 ) ; if ( updateRequired == 1 ) playersObserved [ playersObservedCount ++ ] = LOCAL_PLAYER_ID ; return ; } if ( movementUpdateType == 3 ) { plane = stream . readBits ( 2 ) ; int clearWaypointQueue = stream . readBits ( 1 ) ; int updateRequired = stream . readBits ( 1 ) ; if ( updateRequired == 1 ) playersObserved [ playersObservedCount ++ ] = LOCAL_PLAYER_ID ; int x = stream . readBits ( 7 ) ; int y = stream . readBits ( 7 ) ; localPlayer . setPos ( y , x , clearWaypointQueue == 1 ) ; } }
te	6	private String getInsilicoFile ( ) throws ValidationException { String text = this . inSilicoTextField . getText ( ) . trim ( ) ; if ( text . trim ( ) . length ( ) > 0 ) { Path path = Paths . get ( text ) ; File f = path . toFile ( ) ; if ( f . exists ( ) && f . isFile ( ) ) { return path . toString ( ) ; } else { throw new ValidationException ( "Incorrect filename for " + "in silico peptides" , "" ) ; } } else { File fastaFile = getProteinFile ( ) ; try { int minLen = getMinLen ( ) ; int maxLen = getMaxLen ( ) ; List < String > peptides = Protein . digestProteinsFasta ( fastaFile , true , minLen , maxLen ) ; if ( peptides . isEmpty ( ) ) { throw new ValidationException ( "The in silico digestion resulted in no peptides. " + "Please make sure all the parameters for digestion are set correctly." , "" ) ; } String tmpDir = System . getProperty ( "java.io.tmpdir" ) ; String fname = "insilico-peptides.txt" ; File outFile = new File ( tmpDir , fname ) ; Protein . writeLinesToFile ( peptides , outFile ) ; System . out . println ( "In silico digest written to: " + outFile . getAbsolutePath ( ) ) ; return outFile . getAbsolutePath ( ) ; } catch ( ValidationException e ) { throw e ; } catch ( Exception e ) { throw new ValidationException ( "Incorrect fasta file  unable to perform digestion." , "" ) ; } } }
te	9	public void startgetLongUrl ( src . com . tinyurl . TinyUrlWebServiceStub . GetLongUrl getLongUrl0 , final src . com . tinyurl . TinyUrlWebServiceCallbackHandler callback ) throws java . rmi . RemoteException { org . apache . axis2 . client . OperationClient _operationClient = _serviceClient . createClient ( _operations [ 0 ] . getName ( ) ) ; _operationClient . getOptions ( ) . setAction ( "urn:getLongUrl" ) ; _operationClient . getOptions ( ) . setExceptionToBeThrownOnSOAPFault ( true ) ; addPropertyToOperationClient ( _operationClient , org . apache . axis2 . description . WSDL2Constants . ATTR_WHTTP_QUERY_PARAMETER_SEPARATOR , "&" ) ; org . apache . axiom . soap . SOAPEnvelope env = null ; final org . apache . axis2 . context . MessageContext _messageContext = new org . apache . axis2 . context . MessageContext ( ) ; env = toEnvelope ( getFactory ( _operationClient . getOptions ( ) . getSoapVersionURI ( ) ) , getLongUrl0 , optimizeContent ( new javax . xml . namespace . QName ( "http://tinyurl.com.src" , "getLongUrl" ) ) , new javax . xml . namespace . QName ( "http://tinyurl.com.src" , "getLongUrl" ) ) ; _serviceClient . addHeadersToEnvelope ( env ) ; _messageContext . setEnvelope ( env ) ; _operationClient . addMessageContext ( _messageContext ) ; _operationClient . setCallback ( new org . apache . axis2 . client . async . AxisCallback ( ) { public void onMessage ( org . apache . axis2 . context . MessageContext resultContext ) { try { org . apache . axiom . soap . SOAPEnvelope resultEnv = resultContext . getEnvelope ( ) ; java . lang . Object object = fromOM ( resultEnv . getBody ( ) . getFirstElement ( ) , src . com . tinyurl . TinyUrlWebServiceStub . GetLongUrlResponse . class , getEnvelopeNamespaces ( resultEnv ) ) ; callback . receiveResultgetLongUrl ( ( src . com . tinyurl . TinyUrlWebServiceStub . GetLongUrlResponse ) object ) ; } catch ( org . apache . axis2 . AxisFault e ) { callback . receiveErrorgetLongUrl ( e ) ; } } public void onError ( java . lang . Exception error ) { if ( error instanceof org . apache . axis2 . AxisFault ) { org . apache . axis2 . AxisFault f = ( org . apache . axis2 . AxisFault ) error ; org . apache . axiom . om . OMElement faultElt = f . getDetail ( ) ; if ( faultElt != null ) { if ( faultExceptionNameMap . containsKey ( new org . apache . axis2 . client . FaultMapKey ( faultElt . getQName ( ) , "getLongUrl" ) ) ) { try { java . lang . String exceptionClassName = ( java . lang . String ) faultExceptionClassNameMap . get ( new org . apache . axis2 . client . FaultMapKey ( faultElt . getQName ( ) , "getLongUrl" ) ) ; java . lang . class exceptionClass = java . lang . class . forName ( exceptionClassName ) ; java . lang . reflect . Constructor constructor = exceptionClass . getConstructor ( String . class ) ; java . lang . Exception ex = ( java . lang . Exception ) constructor . newInstance ( f . getMessage ( ) ) ; java . lang . String messageClassName = ( java . lang . String ) faultMessageMap . get ( new org . apache . axis2 . client . FaultMapKey ( faultElt . getQName ( ) , "getLongUrl" ) ) ; java . lang . class messageClass = java . lang . class . forName ( messageClassName ) ; java . lang . Object messageObject = fromOM ( faultElt , messageClass , null ) ; java . lang . reflect . Method m = exceptionClass . getMethod ( "setFaultMessage" , new java . lang . class [ ] { messageClass } ) ; m . invoke ( ex , new java . lang . Object [ ] { messageObject } ) ; callback . receiveErrorgetLongUrl ( new java . rmi . RemoteException ( ex . getMessage ( ) , ex ) ) ; } catch ( java . lang . ClassCastException e ) { callback . receiveErrorgetLongUrl ( f ) ; } catch ( java . lang . ClassNotFoundException e ) { callback . receiveErrorgetLongUrl ( f ) ; } catch ( java . lang . NoSuchMethodException e ) { callback . receiveErrorgetLongUrl ( f ) ; } catch ( java . lang . reflect . InvocationTargetException e ) { callback . receiveErrorgetLongUrl ( f ) ; } catch ( java . lang . IllegalAccessException e ) { callback . receiveErrorgetLongUrl ( f ) ; } catch ( java . lang . InstantiationException e ) { callback . receiveErrorgetLongUrl ( f ) ; } catch ( org . apache . axis2 . AxisFault e ) { callback . receiveErrorgetLongUrl ( f ) ; } } else { callback . receiveErrorgetLongUrl ( f ) ; } } else { callback . receiveErrorgetLongUrl ( f ) ; } } else { callback . receiveErrorgetLongUrl ( error ) ; } } public void onFault ( org . apache . axis2 . context . MessageContext faultContext ) { org . apache . axis2 . AxisFault fault = org . apache . axis2 . util . Utils . getInboundFaultFromMessageContext ( faultContext ) ; onError ( fault ) ; } public void onComplete ( ) { try { _messageContext . getTransportOut ( ) . getSender ( ) . cleanup ( _messageContext ) ; } catch ( org . apache . axis2 . AxisFault axisFault ) { callback . receiveErrorgetLongUrl ( axisFault ) ; } } } ) ; org . apache . axis2 . util . CallbackReceiver _callbackReceiver = null ; if ( _operations [ 0 ] . getMessageReceiver ( ) == null && _operationClient . getOptions ( ) . isUseSeparateListener ( ) ) { _callbackReceiver = new org . apache . axis2 . util . CallbackReceiver ( ) ; _operations [ 0 ] . setMessageReceiver ( _callbackReceiver ) ; } _operationClient . execute ( false ) ; }
te	5	void store ( String [ ] args ) throws vslException { String base = "hey " ; int nChunks = 5 ; myVsl = new vsl ( args [ 1 ] ) ; if ( args . length > 2 ) { base = args [ 2 ] ; } if ( args . length > 3 ) { try { nChunks = new Integer ( args [ 3 ] ) ; } catch ( NumberFormatException nfe ) { System . err . println ( "Last argument to store must be a positive integer: " + args [ 3 ] ) ; System . exit ( 1 ) ; } if ( nChunks < 0 ) { System . err . println ( "Last argument to store must be a positive integer: " + args [ 3 ] ) ; System . exit ( 1 ) ; } } vslDataType < testChunk > data = new vslDataType < testChunk > ( ) ; for ( int x = 0 ; x < nChunks ; x ++ ) { String inString = new String ( base + new Integer ( x ) ) ; testChunk chunk = new testChunk ( inString ) ; testDataExtra extra = new testDataExtra ( new String ( "extra " + new Integer ( x ) ) ) ; chunk . setDataExtra ( extra ) ; data . addNewChunk ( chunk ) ; } myVsl . addEntry ( data ) ; myVsl . debugShow ( ) ; myVsl . save ( ) ; }
te	5	@ Override public void initTreeTraversal ( ) { try { if ( memory != null ) { memory . rewind ( ) ; return ; } if ( in != null ) { in . close ( ) ; } in = new BufferedInputStream ( new FileInputStream ( file ) ) ; b = new byte [ 3 ] ; in . read ( b ) ; type = b [ 0 ] ; b = new byte [ b [ 2 ] ] ; if ( fromMemory ) { File F = new File ( file ) ; int fs = ( int ) ( F . length ( ) - 3 ) ; System . out . println ( "allocating byte buffer of size: " + fs ) ; memory = ByteBuffer . allocateDirect ( fs ) ; System . out . println ( "Reading file contents" ) ; while ( in . read ( b ) == b . length ) { memory . put ( b ) ; } System . out . println ( "Done" ) ; memory . rewind ( ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } }
te	8	public void addNoise ( Matrix mat , double freq , double ampl ) { if ( child != null ) { for ( int i = 0 ; i < child . length ; i ++ ) if ( child [ i ] != null ) { Matrix tmp = new Matrix ( ) ; tmp . copy ( mat ) ; tmp . preMultiply ( child [ i ] . matrix ) ; child [ i ] . addNoise ( tmp , freq , ampl ) ; } return ; } double v [ ] [ ] = vertices , x , y , z ; if ( matn == null ) matn = new Matrix ( ) ; matn . copy ( mat ) ; matn . set ( 0 , 3 , 0 ) ; matn . set ( 1 , 3 , 0 ) ; matn . set ( 2 , 3 , 0 ) ; if ( inv == null ) inv = new Matrix ( ) ; inv . invert ( mat ) ; for ( int k = 0 ; k < v . length ; k ++ ) { transform ( v [ k ] , mat , w ) ; for ( int j = 0 ; j < 3 ; j ++ ) vn [ j ] = v [ k ] [ 3 + j ] ; transform ( vn , matn , wn ) ; x = freq * w [ 0 ] ; y = freq * w [ 1 ] ; z = freq * w [ 2 ] + 100 ; double t = ampl * Noise . noise ( x , y , z ) ; for ( int j = 0 ; j < 3 ; j ++ ) w [ j ] += t * wn [ j ] ; transform ( w , inv , v [ k ] ) ; } computedMeshNormals = false ; }
te	7	protected void createLine ( ) throws LineUnavailableException { if ( m_line == null ) { AudioFormat sourceFormat = m_audioInputStream . getFormat ( ) ; int nSampleSizeInBits = sourceFormat . getSampleSizeInBits ( ) ; if ( nSampleSizeInBits <= 0 ) nSampleSizeInBits = 16 ; if ( ( sourceFormat . getEncoding ( ) == AudioFormat . Encoding . ULAW ) || ( sourceFormat . getEncoding ( ) == AudioFormat . Encoding . ALAW ) ) nSampleSizeInBits = 16 ; if ( nSampleSizeInBits != 8 ) nSampleSizeInBits = 16 ; AudioFormat targetFormat = new AudioFormat ( AudioFormat . Encoding . PCM_SIGNED , sourceFormat . getSampleRate ( ) , nSampleSizeInBits , sourceFormat . getChannels ( ) , sourceFormat . getChannels ( ) * ( nSampleSizeInBits / 8 ) , sourceFormat . getSampleRate ( ) , false ) ; m_encodedaudioInputStream = m_audioInputStream ; try { encodedLength = m_encodedaudioInputStream . available ( ) ; } catch ( IOException e ) { } m_audioInputStream = AudioSystem . getAudioInputStream ( targetFormat , m_audioInputStream ) ; AudioFormat audioFormat = m_audioInputStream . getFormat ( ) ; DataLine . Info info = new DataLine . Info ( SourceDataLine . class , audioFormat , AudioSystem . NOT_SPECIFIED ) ; Mixer mixer = getMixer ( m_mixerName ) ; if ( mixer != null ) { m_line = ( SourceDataLine ) mixer . getLine ( info ) ; } else { m_line = ( SourceDataLine ) AudioSystem . getLine ( info ) ; m_mixerName = null ; } } }
te	1	public DBSaveRestore ( ) { try { this . services = new DBConnectionFactory ( ) ; } catch ( ServiceLocatorException e ) { e . printStackTrace ( ) ; } this . hostelDAOImpl = new HostelDAOImpl ( services ) ; this . bedDAO = new BedDAOImpl ( services ) ; this . contactDAO = new ContactDAOImpl ( services ) ; this . addressDAO = new AddressDAOImpl ( services ) ; this . policyDAO = new PolicyDAOImpl ( services ) ; this . searchDAO = new SearchDAOImpl ( services ) ; this . userDAO = new UserDAOImpl ( services ) ; this . bookingDAO = new BookingDAOImpl ( services ) ; }
te	2	@ Override public boolean solve ( Situation situation , Solution solution ) { int betSize = solution . getSolutionSize ( ) ; Player hero = situation . getActivePlayer ( ) ; int takenFromStack = hero . removeFromStack ( betSize ) ; situation . addToPot ( takenFromStack ) ; if ( hero . getStack ( ) == 0 && situation . getPlayerCount ( ) <= 2 ) { situation . setStreet ( Telesina . STREET_COUNT - 1 ) ; } situation . decreasePlayersLeft ( ) ; return true ; }
te	0	public ErrorResult ( String id , String message ) { this . code = id ; this . message = message ; }
te	8	protected byte getIndex ( final AABB pBounds ) { if ( children != null ) { final Vector3f p = pBounds . getPosition ( ) ; if ( p . x != position . x && p . y != position . y && p . z != position . z ) { final byte index = ( byte ) ( ( p . x < position . x ? 0 : 1 ) + ( p . y > position . y ? 0 : 4 ) + ( p . z < position . z ? 0 : 2 ) ) ; if ( children [ index ] . contains ( p , pBounds . getHalfsize ( ) ) ) { return index ; } } } return - 1 ; }
te	2	public Descriptor compile ( SymbolTable symbolTable ) { exp1 . compile ( symbolTable ) ; write ( "BF  " + labelCount ) ; stateSeq1 . compile ( symbolTable ) ; int end = ( AbstractNode . labelCount + getCountOfElse ( ) ) ; write ( "JMP  " + end ) ; if ( elseIfs != null ) { write ( "LABEL  " + AbstractNode . getNextLabelNumber ( ) ) ; ( ( IfStatementNode ) elseIfs ) . compileElseIf ( symbolTable , end ) ; } if ( stateSeq2 != null ) { write ( "LABEL  " + AbstractNode . getNextLabelNumber ( ) ) ; stateSeq2 . compile ( symbolTable ) ; } write ( "LABEL  " + AbstractNode . getNextLabelNumber ( ) ) ; return null ; }
te	0	public void setContext ( Object context ) { this . context = context ; }
te	3	public int addSound ( int soundID , SoundLibrary soundLib ) { if ( soundID == SoundLibrary . SOUND_ID_BEEP ) return SOUND_BEEP ; if ( soundID == SoundLibrary . SOUND_ID_SILENT ) return SOUND_SILENT ; if ( containedSounds . containsKey ( soundID ) ) { return containedSounds . get ( soundID ) ; } int newSound = addSound ( soundLib . getSoundAsWave ( soundID ) ) ; containedSounds . put ( soundID , newSound ) ; return newSound ; }
te	2	public static int [ ] rotate ( int [ ] a , int n ) { int [ ] b = new int [ a . length ] ; for ( int i = 0 ; i < b . length ; i ++ ) { if ( n == b . length ) n = 0 ; b [ i ] = a [ n ++ ] ; } return b ; }
te	2	@ Override protected boolean podeSeMover ( Posicao origem , Posicao destino , TabuleiroXadrez tabuleiro ) { if ( super . podeSeMover ( origem , destino , tabuleiro ) ) if ( this . medeDeslocamentoPeca ( origem . getLinha ( ) , destino . getLinha ( ) ) == 1 & this . medeDeslocamentoPeca ( origem . getColuna ( ) , destino . getColuna ( ) ) == 2 | this . medeDeslocamentoPeca ( origem . getLinha ( ) , destino . getLinha ( ) ) == 2 & this . medeDeslocamentoPeca ( origem . getColuna ( ) , destino . getColuna ( ) ) == 1 ) return true ; return false ; }
te	0	public boolean isOrganic ( ) { return organic ; }
te	0	public boolean isInErrorState ( ) { return errorState ; }
te	5	public static void parseAndDownloadImg ( String baseUrl , HashMap < String , String > imgNameUrl , Iterator < String > iterator ) throws IOException { while ( iterator . hasNext ( ) ) { String imgName = iterator . next ( ) ; String imgUrl = imgNameUrl . get ( imgName ) ; Document aImgdocument = Jsoup . connect ( imgUrl ) . get ( ) ; Elements lists = aImgdocument . select ( "img[src]" ) ; for ( int i = 1 ; i < lists . size ( ) ; i ++ ) { Element imgElement = lists . get ( i ) ; String uri = imgElement . attr ( "src" ) ; Date date = new Date ( ) ; SimpleDateFormat dateFormat = new SimpleDateFormat ( "YYYY_MM_dd_kk_mm_" , Locale . CHINA ) ; String appedDateInfo = dateFormat . format ( date ) ; String imgFileName = appedDateInfo + count + "_" + uri . substring ( uri . lastIndexOf ( "/" ) + 1 ) ; if ( uri . contains ( "http" ) ) { saveUrlAs ( uri , "C:/Img/" + imgFileName ) ; count ++ ; } else { if ( baseUrl . endsWith ( "/" ) ) baseUrl = baseUrl . substring ( 0 , baseUrl . lastIndexOf ( "/" ) ) ; if ( imgFileName . endsWith ( "fengexian.gif" ) ) continue ; else { saveUrlAs ( baseUrl + uri , "C:/Img/" + imgFileName ) ; count ++ ; } } } } }
te	8	public Zone extraMPlus ( Map < String , Clock > clockMapping ) { Zone zone = new Zone ( ) ; int zoneDataStruct [ ] [ ] [ ] = new int [ clockCount + 1 ] [ clockCount + 1 ] [ 2 ] ; for ( int i = 0 ; i <= clockCount ; i ++ ) { for ( int j = 0 ; j <= clockCount ; j ++ ) { if ( this . zoneDataStruct [ i ] [ j ] [ 0 ] > clockMapping . get ( i ) . getMaxBound ( ) ) { zoneDataStruct [ i ] [ j ] [ 0 ] = Integer . MAX_VALUE ; zoneDataStruct [ i ] [ j ] [ 1 ] = 1 ; } else if ( ( - 1 * this . zoneDataStruct [ 0 ] [ i ] [ 0 ] ) > clockMapping . get ( i ) . getMaxBound ( ) ) { zoneDataStruct [ i ] [ j ] [ 0 ] = Integer . MAX_VALUE ; zoneDataStruct [ i ] [ j ] [ 1 ] = 1 ; } else if ( ( - 1 * this . zoneDataStruct [ 0 ] [ j ] [ 0 ] ) > clockMapping . get ( j ) . getMaxBound ( ) && ( i != 0 ) ) { zoneDataStruct [ i ] [ j ] [ 0 ] = Integer . MAX_VALUE ; zoneDataStruct [ i ] [ j ] [ 1 ] = 1 ; } else if ( ( - 1 * this . zoneDataStruct [ i ] [ j ] [ 0 ] ) > clockMapping . get ( j ) . getMaxBound ( ) && ( i == 0 ) ) { zoneDataStruct [ i ] [ j ] [ 0 ] = - 1 * clockMapping . get ( j ) . getMaxBound ( ) ; zoneDataStruct [ i ] [ j ] [ 1 ] = 0 ; } else { zoneDataStruct [ i ] [ j ] [ 0 ] = this . zoneDataStruct [ i ] [ j ] [ 0 ] ; zoneDataStruct [ i ] [ j ] [ 1 ] = this . zoneDataStruct [ i ] [ j ] [ 1 ] ; } } } zone . setZoneDataStruct ( zoneDataStruct ) ; zone . setClockCount ( clockCount ) ; return zone ; }
te	8	public void addAccount ( ) { AddAccountDialog addaccount = new AddAccountDialog ( this , "Add Account" ) ; Point loc = getLocation ( ) ; addaccount . setLocation ( loc . x + 50 , loc . y + 50 ) ; addaccount . setModal ( true ) ; addaccount . setVisible ( true ) ; if ( ! addaccount . canceled ( ) ) { String number = null ; try { number = bank . createAccount ( addaccount . getOwnerName ( ) ) ; } catch ( Exception e ) { error ( e ) ; } if ( number == null ) { JOptionPane . showMessageDialog ( this , "Account could not be created" , "Error" , JOptionPane . ERROR_MESSAGE ) ; } else { try { Account acc = bank . getAccount ( number ) ; accounts . put ( number , acc ) ; String str = addaccount . getBalance ( ) . trim ( ) ; double amount ; if ( str . equals ( "" ) ) amount = 0 ; else amount = double . parseDouble ( str ) ; acc . deposit ( amount ) ; } catch ( NumberFormatException e ) { JOptionPane . showMessageDialog ( this , "Illegal Format" , "Error" , JOptionPane . ERROR_MESSAGE ) ; } catch ( IllegalArgumentException e ) { JOptionPane . showMessageDialog ( this , "Illegal Argument" , "Error" , JOptionPane . ERROR_MESSAGE ) ; } catch ( InactiveException e ) { JOptionPane . showMessageDialog ( this , "Account is inactive" , "Error" , JOptionPane . ERROR_MESSAGE ) ; } catch ( Exception e ) { error ( e ) ; } ignoreItemChanges = true ; accountcombo . addItem ( number ) ; accountcombo . setSelectedItem ( number ) ; ignoreItemChanges = false ; refreshDialog ( ) ; } } }
te	7	public void setDuration ( final int duration ) { this . duration = duration ; if ( delayThread != null ) delayThread . interrupt ( ) ; if ( duration > 0 ) { if ( ! hasTimeLeft ) { setHasTimeLeft ( true ) ; } hasTimeLeft = true ; final AbstractCountdownObject obj = this ; delayThread = new Thread ( new Runnable ( ) { public void run ( ) { try { Thread . sleep ( duration ) ; } catch ( InterruptedException e ) { return ; } setHasTimeLeft ( false ) ; hasTimeLeft = false ; if ( listener != null ) listener . statusChanged ( obj ) ; } } ) ; delayThread . start ( ) ; startTime = System . currentTimeMillis ( ) ; } else { if ( hasTimeLeft ) { setHasTimeLeft ( false ) ; } hasTimeLeft = false ; } if ( listener != null ) listener . statusChanged ( this ) ; }
te	1	public String concatenarEstatus ( ) { String ret = "#inactivo\n" ; if ( isEstatus ( ) ) { ret = "#activo\n" ; } return ret ; }
te	8	private JTreeNode < T > convertList ( JTreeNode < T > current , boolean isLeft ) { if ( current == null ) { return null ; } JTreeNode < T > left = convertList ( current . getLeftNode ( ) , true ) ; JTreeNode < T > right = convertList ( current . getRightNode ( ) , false ) ; if ( left != null && right == null ) { left . setRightNode ( current ) ; current . setLeftNode ( left ) ; return current ; } if ( left == null && right != null ) { current . setRightNode ( right ) ; right . setLeftNode ( current ) ; return current ; } if ( left != null && right != null ) { left . setRightNode ( current ) ; current . setLeftNode ( left ) ; current . setRightNode ( right ) ; right . setLeftNode ( current ) ; if ( isLeft ) { return right ; } return left ; } return current ; }
te	0	public void setMappings ( List < Mapping > mappings ) { this . mappings = mappings ; }
te	9	@ Override public void run ( ) { try { int pos = 0 ; StringTokenizer st1 = new StringTokenizer ( text , "{" , true ) ; while ( st1 . hasMoreTokens ( ) ) { String s1 = st1 . nextToken ( ) ; if ( s1 . equals ( "{" ) ) { jTextPane2 . insertIcon ( new ImageIcon ( getClass ( ) . getResource ( "/picture/1.jpg" ) ) ) ; pos += 7 ; if ( pos > 60 ) { jTextPane2 . getDocument ( ) . insertString ( jTextPane2 . getDocument ( ) . getLength ( ) , "\r\n" , null ) ; pos = 0 ; } } else { StringTokenizer st2 = new StringTokenizer ( s1 , "}" , true ) ; while ( st2 . hasMoreTokens ( ) ) { String s2 = st2 . nextToken ( ) ; if ( s2 . equals ( "}" ) ) { jTextPane2 . insertIcon ( new ImageIcon ( getClass ( ) . getResource ( "/picture/2.jpg" ) ) ) ; pos += 7 ; if ( pos > 60 ) { jTextPane2 . getDocument ( ) . insertString ( jTextPane2 . getDocument ( ) . getLength ( ) , "\r\n" , null ) ; pos = 0 ; } } else { StringTokenizer st3 = new StringTokenizer ( s2 , "|" , true ) ; while ( st3 . hasMoreTokens ( ) ) { String s3 = st3 . nextToken ( ) ; if ( s3 . equals ( "|" ) ) { jTextPane2 . insertIcon ( new ImageIcon ( getClass ( ) . getResource ( "/picture/3.jpg" ) ) ) ; pos += 7 ; if ( pos > 60 ) { jTextPane2 . getDocument ( ) . insertString ( jTextPane2 . getDocument ( ) . getLength ( ) , "\r\n" , null ) ; pos = 0 ; } } else { pos += s3 . length ( ) ; if ( pos > 60 ) { int len = s3 . length ( ) ; int line = 60 + s3 . length ( ) - pos ; jTextPane2 . getDocument ( ) . insertString ( jTextPane2 . getDocument ( ) . getLength ( ) , s3 . substring ( 0 , line ) , null ) ; jTextPane2 . getDocument ( ) . insertString ( jTextPane2 . getDocument ( ) . getLength ( ) , "\r\n" , null ) ; len -= line ; while ( len > 60 ) { jTextPane2 . getDocument ( ) . insertString ( jTextPane2 . getDocument ( ) . getLength ( ) , s3 . substring ( line , line + 60 ) , null ) ; jTextPane2 . getDocument ( ) . insertString ( jTextPane2 . getDocument ( ) . getLength ( ) , "\r\n" , null ) ; line += 60 ; len -= 60 ; } jTextPane2 . getDocument ( ) . insertString ( jTextPane2 . getDocument ( ) . getLength ( ) , s3 . substring ( line , line + len ) , null ) ; pos = len ; } else { jTextPane2 . getDocument ( ) . insertString ( jTextPane2 . getDocument ( ) . getLength ( ) , s3 , null ) ; } } } } } } } jTextPane2 . getDocument ( ) . insertString ( jTextPane2 . getDocument ( ) . getLength ( ) , "\r\n" , null ) ; pos = 0 ; chatRoom . setVisible ( true ) ; } catch ( BadLocationException e ) { } }
te	2	private static < L > void appendPreTerminalYield ( Tree < L > tree , List < L > yield ) { if ( tree . isPreTerminal ( ) ) { yield . add ( tree . getLabel ( ) ) ; return ; } for ( Tree < L > child : tree . getChildren ( ) ) { appendPreTerminalYield ( child , yield ) ; } }
te	4	private void assertEquals ( String text , Object expected , Object result ) { boolean equal ; if ( expected == null ) { equal = result == null ; } else { equal = result != null && expected . equals ( result ) ; } if ( ! equal ) { if ( ! isPrinted ) { System . out . println ( "    Test: " + description ) ; isPrinted = true ; } System . out . println ( "        " + text ) ; System . out . println ( "            Expected:  " + expected ) ; System . out . println ( "            Result: " + result ) ; errors ++ ; } }
te	2	void freeSource ( int sourceID ) { if ( noDevice ) { return ; } alSourceStop ( sourceID ) ; alSourcei ( sourceID , AL_BUFFER , 0 ) ; if ( sourceToSoundId . containsKey ( sourceID ) ) { long soundId = sourceToSoundId . remove ( sourceID ) ; soundIdToSource . remove ( soundId ) ; } idleSources . add ( sourceID ) ; }
te	1	public ClasesCollection getClasesCollection ( ) { if ( clasesCollection == null ) { clasesCollection = new ClasesCollection ( ( IClient ) this ) ; } return clasesCollection ; }
te	4	@ Override public int hashCode ( ) { int result = prpPosId != null ? prpPosId . hashCode ( ) : 0 ; result = 31 * result + ( prpMoaTipo != null ? prpMoaTipo . hashCode ( ) : 0 ) ; result = 31 * result + ( prpMoaConsec != null ? prpMoaConsec . hashCode ( ) : 0 ) ; result = 31 * result + ( prpIdElemento != null ? prpIdElemento . hashCode ( ) : 0 ) ; return result ; }
te	9	public static File transformCollection ( Target target , Collection < Type > types ) throws TransformException { String condition = target . getCondition ( ) ; if ( ! StringUtils . isBlank ( condition ) ) { Condition c = Context . getCondition ( condition ) ; if ( c == null ) { throw new TransformException ( "Condition [" + condition + "] does not exist!" ) ; } Collection < Type > result = new HashSet < Type > ( ) ; for ( Type type : types ) { if ( ExpressionEvaluator . evaluateExpression ( c . getExpression ( ) , type ) ) { result . add ( type ) ; } } types = result ; } if ( types . size ( ) == 0 ) return null ; File outputFile = null ; FileWriter fw = null ; Template template = null ; try { outputFile = OutputFileManager . getOutputFile ( target ) ; fw = new FileWriter ( outputFile , false ) ; VelocityContext vc = new VelocityContext ( ) ; vc . put ( "context" , Context . instance ( ) ) ; vc . put ( "target" , target ) ; vc . put ( "types" , types ) ; addUtilities ( vc ) ; template = Context . getTemplateManager ( ) . getTemplate ( target ) ; template . merge ( vc , fw ) ; fw . close ( ) ; } catch ( ResourceNotFoundException ex ) { Logger . getLogger ( TemplateManager . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; throw new TransformException ( "Template [" + template . getName ( ) + "] not found" , ex ) ; } catch ( ParseErrorException ex ) { Logger . getLogger ( TemplateManager . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; throw new TransformException ( "Unable to parse template [" + template . getName ( ) + "]" , ex ) ; } catch ( MethodInvocationException ex ) { Logger . getLogger ( TemplateManager . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; throw new TransformException ( "Unknown problem with template [" + template . getName ( ) + "]" , ex ) ; } catch ( IOException ex ) { Logger . getLogger ( TypeTransformer . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; throw new TransformException ( "Unable to write to file [" + outputFile . getName ( ) + "]" , ex ) ; } catch ( OverwriteException ex ) { Logger . getLogger ( TypeTransformer . class . getName ( ) ) . log ( Level . INFO , "Output file [" + ex . getOutputFileName ( ) + "] already exists" ) ; } catch ( Exception ex ) { Logger . getLogger ( TypeTransformer . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; throw new TransformException ( "Unable to write to file [" + outputFile . getName ( ) + "]" , ex ) ; } return outputFile ; }
te	7	public boolean createServer ( ) { print ( "Creating a server..." ) ; serverSocket = null ; hostSocket = null ; out = null ; in = null ; String fromPlayer = null ; String fromHost = null ; try { serverSocket = new ServerSocket ( port ) ; hostSocket = serverSocket . accept ( ) ; uiBridge . fireClientconnected ( ) ; out = new PrintWriter ( hostSocket . getOutputStream ( ) , true ) ; in = new BufferedReader ( new InputStreamReader ( hostSocket . getInputStream ( ) ) ) ; } catch ( IOException e ) { print ( "There was an IOException..." + e ) ; } print ( "socket accepted. printing hello" ) ; out . println ( "hello" ) ; try { while ( ( fromPlayer = in . readLine ( ) ) != null ) { if ( ! turnSet || gamePlayMessages ( fromPlayer ) ) { print ( "From player: " + fromPlayer ) ; fromHost = processMessage ( fromPlayer , in , out , hostSocket ) ; print ( "From host: " + fromHost ) ; out . println ( fromHost ) ; } if ( fromPlayer . equals ( "bye" ) || fromHost . equals ( "bye" ) ) { break ; } } print ( "closing all the connections.." ) ; serverSocket . close ( ) ; hostSocket . close ( ) ; in . close ( ) ; out . close ( ) ; } catch ( IOException e ) { destroyConnection ( ) ; uiBridge . gameTerminated ( ) ; print ( "There was an IOException..." + e ) ; } return true ; }
te	5	private void loadSpriteType ( String path , String spriteTypeName , HashMap < String , SpriteType > spriteTypes ) { String spriteTypeXMLFile = path + spriteTypeName + "/" + spriteTypeName + ".xml" ; String spriteTypeXSDFile = path + SPRITE_TYPE_NODE_NAME + ".xsd" ; WhitespaceFreeXMLDoc cleanDoc ; try { cleanDoc = loadXMLDocument ( spriteTypeXMLFile , spriteTypeXSDFile ) ; } catch ( InvalidXMLFileFormatException ixffe ) { System . out . println ( "NOT GOOD look at AbunatedSpriteXMLLoader line 252" ) ; return ; } WhitespaceFreeXMLNode spriteTypeNode = cleanDoc . getRoot ( ) ; WhitespaceFreeXMLNode widthNode = spriteTypeNode . getChildOfType ( WIDTH_NODE_NAME ) ; String widthAsText = widthNode . getData ( ) ; int width = Integer . parseInt ( widthAsText ) ; WhitespaceFreeXMLNode heightNode = spriteTypeNode . getChildOfType ( HEIGHT_NODE_NAME ) ; String heightAsText = heightNode . getData ( ) ; int height = Integer . parseInt ( heightAsText ) ; SpriteType spriteTypeToLoad = new SpriteType ( width , height ) ; WhitespaceFreeXMLNode imageListNode = spriteTypeNode . getChildOfType ( IMAGES_LIST_NODE_NAME ) ; ArrayList < WhitespaceFreeXMLNode > imageFileNodes = imageListNode . getChildrenOfType ( IMAGE_FILE_NODE_NAME ) ; MediaTracker tracker = new MediaTracker ( view ) ; Toolkit tk = Toolkit . getDefaultToolkit ( ) ; for ( WhitespaceFreeXMLNode imageFileNode : imageFileNodes ) { String idAsText = imageFileNode . getAttributeValue ( ID_ATTRIBUTE_NAME ) ; int id = Integer . parseInt ( idAsText ) ; String fileName = imageFileNode . getAttributeValue ( FILE_NAME_ATTRIBUTE_NAME ) ; String imageFileNameAndPath = path + spriteTypeName + "/" + fileName ; Image loadedImage = tk . getImage ( imageFileNameAndPath ) ; tracker . addImage ( loadedImage , id ) ; spriteTypeToLoad . addImage ( id , loadedImage ) ; } try { tracker . waitForAll ( ) ; } catch ( InterruptedException ie ) { ie . printStackTrace ( ) ; } WhitespaceFreeXMLNode animationListNode = spriteTypeNode . getChildOfType ( ANIMATIONS_LIST_NODE_NAME ) ; ArrayList < WhitespaceFreeXMLNode > animationStateNodes = animationListNode . getChildrenOfType ( ANIMATION_STATE_NODE_NAME ) ; for ( WhitespaceFreeXMLNode animationState : animationStateNodes ) { WhitespaceFreeXMLNode stateNode = animationState . getChildOfType ( STATE_NODE_NAME ) ; String state = stateNode . getData ( ) ; PoseList poseList = spriteTypeToLoad . addPoseList ( state ) ; WhitespaceFreeXMLNode animationSequenceNode = animationState . getChildOfType ( ANIMATION_SEQUENCE_NODE_NAME ) ; ArrayList < WhitespaceFreeXMLNode > poseNodes = animationSequenceNode . getChildrenOfType ( POSE_NODE_NAME ) ; for ( WhitespaceFreeXMLNode poseNode : poseNodes ) { String imageIDText = poseNode . getAttributeValue ( IMAGE_ID_ATTRIBUTE_NAME ) ; int imageID = Integer . parseInt ( imageIDText ) ; String durationText = poseNode . getAttributeValue ( DURATION_ATTRIBUTE_NAME ) ; int duration = Integer . parseInt ( durationText ) ; poseList . addPose ( imageID , duration ) ; } } spriteTypes . put ( spriteTypeName , spriteTypeToLoad ) ; }
te	9	private void balanceClusters ( ) { findAllClusters ( ) ; step = 0 ; boolean somethingMoved = false ; for ( int i = 0 ; i < allClusters . size ( ) ; ) { NodeCluster c = ( NodeCluster ) allClusters . get ( i ) ; int delta = c . getPull ( ) ; if ( delta < 0 ) { if ( c . leftFreedom > 0 ) { c . adjustRank ( Math . max ( delta , - c . leftFreedom ) , dirtyClusters ) ; refreshDirtyClusters ( ) ; moveClusterForward ( i , c ) ; somethingMoved = true ; step ++ ; } else if ( clusterset . build ( c ) ) { step ++ ; moveClusterForward ( i , c ) ; somethingMoved = true ; } } else if ( delta > 0 ) { if ( c . rightFreedom > 0 ) { c . adjustRank ( Math . min ( delta , c . rightFreedom ) , dirtyClusters ) ; refreshDirtyClusters ( ) ; moveClusterForward ( i , c ) ; somethingMoved = true ; step ++ ; } else if ( clusterset . build ( c ) ) { step ++ ; moveClusterForward ( i , c ) ; somethingMoved = true ; } } i ++ ; if ( i == allClusters . size ( ) && somethingMoved ) { i = 0 ; somethingMoved = false ; } } }
te	1	public Score GetLeastTopScore ( ) throws SQLException { Score tempscore = new Score ( "A" , 0 ) ; Vector topTenScores = this . GetTopScores ( 10 ) ; if ( topTenScores . size ( ) < 10 ) return tempscore ; else return ( Score ) topTenScores . elementAt ( topTenScores . size ( ) - 1 ) ; }
te	4	public Matrix multiply ( Matrix other ) { int [ ] [ ] matrixA = matrix ; int [ ] [ ] matrixB = other . matrix ; int rowsA = matrixA . length ; int columnsA = matrixA [ 0 ] . length ; int columnsB = matrixB . length ; if ( columnsB != columnsA ) { throw new RuntimeException ( "\u0420\u0430\u0437\u043C\u0435\u0440\u044B \u043C\u0430\u0442\u0440\u0438\u0446 \u043D\u0435 \u0441\u043E\u0432\u043F\u0430\u0434\u0430\u044E\u0442" ) ; } int [ ] [ ] matrixC = new int [ rowsA ] [ columnsB ] ; for ( int i = 0 ; i < rowsA ; i ++ ) { for ( int j = 0 ; j < columnsB ; j ++ ) { for ( int k = 0 ; k < columnsA ; k ++ ) { matrixC [ i ] [ j ] += matrixA [ i ] [ k ] * matrixB [ k ] [ j ] ; } } } return new Matrix ( matrixC ) ; }
te	0	public boolean isVegetarian ( ) { return vegetarian ; }
te	5	@ SuppressWarnings ( "unchecked" ) public void loadScoreFile ( ) { try { inputStream = new ObjectInputStream ( new FileInputStream ( HIGHSCORE_FILE ) ) ; scores = ( ArrayList < Score > ) inputStream . readObject ( ) ; } catch ( FileNotFoundException e ) { System . out . println ( e . getMessage ( ) ) ; } catch ( IOException e ) { System . out . println ( e . getMessage ( ) ) ; } catch ( ClassNotFoundException e ) { System . out . println ( e . getMessage ( ) ) ; } finally { try { if ( outputStream != null ) { outputStream . flush ( ) ; outputStream . close ( ) ; } } catch ( IOException e ) { System . out . println ( e . getMessage ( ) ) ; } } }
te	7	@ Override public int hashCode ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + ( ( compile == null ) ? 0 : compile . hashCode ( ) ) ; result = prime * result + ( ( compileParams == null ) ? 0 : compileParams . hashCode ( ) ) ; result = prime * result + ( ( execParams == null ) ? 0 : execParams . hashCode ( ) ) ; result = prime * result + ( ( extension == null ) ? 0 : extension . hashCode ( ) ) ; result = prime * result + ( int ) ( id ^ ( id >>> 32 ) ) ; result = prime * result + ( ( name == null ) ? 0 : name . hashCode ( ) ) ; result = prime * result + ( ( plagConfig == null ) ? 0 : plagConfig . hashCode ( ) ) ; result = prime * result + ( ( script == null ) ? 0 : script . hashCode ( ) ) ; result = prime * result + ( int ) ( version ^ ( version >>> 32 ) ) ; return result ; }
te	2	private static File getOutputDir ( ) { File file = new File ( properties . getProperty ( "usecase.outputdir" ) + "/class" ) ; if ( ! file . mkdirs ( ) && ! file . exists ( ) ) { throw new RuntimeException ( "Fail to create output directory at " + file ) ; } return file ; }
te	5	private void downloadApplication ( final UpdateApplicationListener ual ) { URL url = null ; BufferedReader br = null ; InputStream is = null ; HttpURLConnection conn = null ; try { url = new URL ( ULR_APP_PACKAGE ) ; conn = ( HttpURLConnection ) url . openConnection ( ) ; int length = conn . getContentLength ( ) ; is = conn . getInputStream ( ) ; FileOutputStream fos = new FileOutputStream ( FILE_APP_PACKAGE ) ; byte [ ] buffer = new byte [ 1024 * 16 ] ; int r = - 1 ; int t = 0 ; keepDownlaod = true ; while ( ( r = is . read ( buffer , 0 , buffer . length ) ) != - 1 ) { if ( ! keepDownlaod ) { int resp = JOptionPane . showConfirmDialog ( null , "\u00BFDesea cancelar la descarga ?" , "Cancelar" , JOptionPane . YES_NO_OPTION , JOptionPane . QUESTION_MESSAGE ) ; if ( resp == JOptionPane . YES_OPTION ) { break ; } else { keepDownlaod = true ; } } t += r ; fos . write ( buffer , 0 , r ) ; fos . flush ( ) ; int advance = ( 100 * t ) / length ; System . err . print ( "Downloaded:\t" + advance + " % \r" ) ; ual . updateProgress ( advance ) ; } System . err . println ( "" ) ; System . err . println ( "finished" ) ; is . close ( ) ; fos . close ( ) ; if ( ! keepDownlaod ) { throw new IllegalStateException ( "Update Canceled" ) ; } else { extractFolder ( FILE_APP_PACKAGE ) ; JOptionPane . showMessageDialog ( null , "Se ha actualizado la Aplicaci\u00F3n  \nReinicie por favor." , "Actualizaci\u00F3n" , JOptionPane . INFORMATION_MESSAGE ) ; } } catch ( IOException ex ) { throw new IllegalStateException ( "Can't download UPDATE data package:" + ex . getMessage ( ) ) ; } }
te	2	public final < T > Mapping < T > map ( String property , Mapper < ? super S , ? extends T > extractor ) { return this . < T > map ( property ) . from ( extractor ) ; }
te	4	private static Coord bottomCoord ( FlowChartSymbol s ) { Coord c = new Coord ( ) ; if ( s . getType ( ) . equals ( Symbol . START ) || s . getType ( ) . equals ( Symbol . STOP ) ) { c . setX ( GRID_WIDTH / 2 ) ; c . setY ( GRID_HEIGHT - OVAL_Y_OFFSET ) ; } else if ( s . getType ( ) . equals ( Symbol . WALL_TEST ) || s . getType ( ) . equals ( Symbol . CTR_TEST ) ) { c . setX ( GRID_WIDTH / 2 ) ; c . setY ( GRID_HEIGHT - DIAMOND_Y_OFFSET ) ; } else { c . setX ( GRID_WIDTH / 2 ) ; c . setY ( GRID_HEIGHT - RECT_Y_OFFSET ) ; } return c ; }
te	7	static boolean place_item ( Item item , Tile tile , Game game , Random rnd ) { int max_attempts = 1000 ; Rectangle2D bounds = ( tile != null ) ? tile . getArea ( ) : game . getMap ( ) . getBounds ( 0 ) ; int attempts = 0 ; while ( attempts != max_attempts ) { attempts += 1 ; double x = ( rnd . nextDouble ( ) * bounds . getWidth ( ) ) + bounds . getX ( ) ; double y = ( rnd . nextDouble ( ) * bounds . getHeight ( ) ) + bounds . getY ( ) ; x = round_value ( x ) ; y = round_value ( y ) ; Point2D pt = new Point2D . double ( x , y ) ; Tile t = game . getMap ( ) . getTileAt ( pt ) ; if ( ( CollisionDetection . canOccupy ( game , item , pt ) && ( t instanceof Floor ) ) ) { item . placeAt ( pt , game ) ; if ( item instanceof Creature ) game . getCreatures ( ) . add ( ( Creature ) item ) ; if ( item instanceof Treasure ) game . getTreasure ( ) . add ( ( Treasure ) item ) ; if ( item instanceof Hero ) game . setHero ( ( Hero ) item ) ; return true ; } } return false ; }
te	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( DaftarPembeli . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( DaftarPembeli . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( DaftarPembeli . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( DaftarPembeli . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { DaftarPembeli dialog = new DaftarPembeli ( new javax . swing . JFrame ( ) , true ) ; dialog . addWindowListener ( new java . awt . event . WindowAdapter ( ) { @ Override public void windowClosing ( java . awt . event . WindowEvent e ) { System . exit ( 0 ) ; } } ) ; dialog . setVisible ( true ) ; } } ) ; }
te	1	public double getAbsoluteValue ( double val ) { return ( val < 0 ) ? - val : val ; }
te	1	public void endCDATA ( ) throws SAXException { if ( lh != null ) lh . endCDATA ( ) ; }
te	2	@ Override public void visualize ( ) { for ( XY xy : map . keySet ( ) ) { BoardButton button = map . get ( xy ) ; MyObject obj = model . getBoard ( ) . get ( xy ) ; Image image ; LineBorder border ; if ( obj == null ) { image = null ; border = new LineBorder ( Color . DARK_GRAY , 1 ) ; } else { image = obj . getImage ( ) ; border = new LineBorder ( Color . DARK_GRAY , 1 ) ; } button . setImage ( image ) ; button . setBorder ( border ) ; button . repaint ( ) ; button . revalidate ( ) ; } }
te	8	public static void main ( String [ ] args ) { PairingHeap < Integer > h = new PairingHeap < > ( ) ; int numItems = 10000 ; int i = 37 ; int j ; System . out . println ( "Checking; no bad output is good" ) ; for ( i = 37 ; i != 0 ; i = ( i + 37 ) % numItems ) h . insert ( i ) ; for ( i = 1 ; i < numItems ; i ++ ) if ( h . deleteMin ( ) != i ) System . out . println ( "Oops! " + i ) ; ArrayList < PairingHeap . Position < Integer >> p = new ArrayList < > ( ) ; for ( i = 0 ; i < numItems ; i ++ ) p . add ( null ) ; for ( i = 0 , j = numItems / 2 ; i < numItems ; i ++ , j = ( j + 71 ) % numItems ) p . set ( j , h . insert ( j + numItems ) ) ; for ( i = 0 , j = numItems / 2 ; i < numItems ; i ++ , j = ( j + 53 ) % numItems ) h . decreaseKey ( p . get ( j ) , p . get ( j ) . getValue ( ) - numItems ) ; i = - 1 ; while ( ! h . isEmpty ( ) ) if ( h . deleteMin ( ) != ++ i ) System . out . println ( "Oops! " + i + " " ) ; System . out . println ( "Check completed" ) ; }
te	5	@ Override public void each ( String input , Output < String > output ) throws IOException { String c [ ] = new String [ cmd . length ] ; for ( int i = 0 ; i < cmd . length ; i ++ ) { if ( StringUtils . contains ( cmd [ i ] , token ) || StringUtils . contains ( cmd [ i ] , "{}" ) ) { c [ i ] = cmd [ i ] . replaceAll ( token , input ) ; } else { c [ i ] = cmd [ i ] ; } } if ( c . length > 0 ) { try { exec ( null , c , true , output ) ; } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; } } }
te	0	public EndGameException ( String string ) { super ( string ) ; }
te	3	public static void addTask ( int q , String descript ) { if ( firsttime ) { showMessage ( descript ) ; try { Thread . sleep ( 500 ) ; } catch ( InterruptedException ex ) { } firsttime = false ; } if ( ! poppedUp ) { loadingFrame . setVisible ( true ) ; poppedUp = true ; } tasks . add ( q ) ; description . add ( descript ) ; }
te	3	@ SuppressWarnings ( "static-access" ) public static void gameover ( ) { world . dispose ( ) ; int option = JOptionPane . showConfirmDialog ( null , "Oh dear  you died! Thanks for Playing!\nScore: " + human . getExp ( ) + "\nSubmit score?" , "GAMEOVER!" , JOptionPane . YES_NO_OPTION ) ; if ( option == JOptionPane . YES_OPTION ) { String playerName = JOptionPane . showInputDialog ( "Please enter your name: " ) ; try { while ( playerName . length ( ) < 1 ) { playerName = JOptionPane . showInputDialog ( "Invalid name. Please enter your name: " ) ; } manager . addScore ( playerName , human . getExp ( ) ) ; showHighscores ( ) ; } catch ( NullPointerException e ) { System . exit ( 0 ) ; } } else { System . exit ( 0 ) ; } }
te	6	private boolean r_main_suffix ( ) { int among_var ; int v_1 ; int v_2 ; v_1 = limit - cursor ; if ( cursor < I_p1 ) { return false ; } cursor = I_p1 ; v_2 = limit_backward ; limit_backward = cursor ; cursor = limit - v_1 ; ket = cursor ; among_var = find_among_b ( a_0 , 37 ) ; if ( among_var == 0 ) { limit_backward = v_2 ; return false ; } bra = cursor ; limit_backward = v_2 ; switch ( among_var ) { case 0 : return false ; case 1 : slice_del ( ) ; break ; case 2 : if ( ! ( in_grouping_b ( g_s_ending , 98 , 121 ) ) ) { return false ; } slice_del ( ) ; break ; } return true ; }
te	4	@ Test public void testFooCollectionTurnovers ( ) { List < ITimeSeries > allSeries = instance . getAvailableSeries ( ) ; boolean found = false ; for ( ITimeSeries series : allSeries ) { if ( series . getName ( ) . contains ( "Foo" ) && series . getName ( ) . contains ( "Vol" ) ) { found = true ; double actual = series . getValue ( 1 ) ; assertEquals ( 0.7 , actual , 0 ) ; break ; } } if ( ! found ) { assert . fail ( ) ; } }
te	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( NewShema . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( NewShema . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( NewShema . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( NewShema . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { NewShema dialog = new NewShema ( new javax . swing . JFrame ( ) , true ) ; dialog . addWindowListener ( new java . awt . event . WindowAdapter ( ) { @ Override public void windowClosing ( java . awt . event . WindowEvent e ) { System . exit ( 0 ) ; } } ) ; dialog . setVisible ( true ) ; } } ) ; }
te	8	public static void main ( String [ ] args ) throws IOException , InterruptedException { try { ChatClient client = wireClient ( ) ; System . out . println ( "Starting ChatClient..." ) ; CLI cli = new CLI ( client ) ; int val ; cli . displayMenu ( ) ; while ( ( val = cli . readInt ( "CLI: >" ) ) != 4 ) { switch ( val ) { default : System . out . println ( "Please enter a valid option!" ) ; break ; case 1 : if ( cli . login ( ) ) if ( ! cli . lobby ( ) ) break ; break ; case 2 : cli . register ( ) ; break ; case 3 : cli . displayMenu ( ) ; break ; } } System . out . println ( "Exiting..." ) ; System . exit ( 0 ) ; } catch ( JMSException e ) { e . printStackTrace ( ) ; } catch ( URISyntaxException e ) { e . printStackTrace ( ) ; } }
te	5	public SimulationEvent ( int eventType , Object eventData ) { if ( eventType != EVENT_SIM_STARTED && eventType != EVENT_SIM_DONE && eventType != EVENT_SIM_CANCELLED && eventType != EVENT_SIM_ERROR && eventType != EVENT_SIM_PROGRESS ) { throw new IllegalArgumentException ( "Invalid event type" ) ; } this . eventType = eventType ; this . eventData = eventData ; }
te	2	@ Override public void onCommandResult ( long commandId , int responseCode , String responseMessage ) { synchronized ( mListeners ) { for ( CommandListener listener : mListeners ) { try { listener . onCommandResult ( commandId , responseCode , responseMessage ) ; } catch ( RuntimeException e ) { System . err . println ( "Error notifying listeners! " + e . getMessage ( ) ) ; e . printStackTrace ( ) ; } } } }
te	8	@ Override public void run ( ) { long oldTime ; long newTime ; if ( button . getText ( ) . equals ( "Campaign" ) ) { double i = 0 ; newTime = System . currentTimeMillis ( ) ; oldTime = newTime ; while ( campaignPulse ) { newTime = System . currentTimeMillis ( ) ; long difference = newTime - oldTime ; i += difference / 250.0 ; Font newFont = new Font ( "Livewired" , Font . PLAIN , ( int ) ( ( getWidth ( ) / 38.4 * Math . abs ( Math . sin ( i ) ) ) + getWidth ( ) / 38.4 ) ) ; button . setFont ( newFont ) ; oldTime = newTime ; } Font oldFont = new Font ( "Livewired" , Font . PLAIN , ( int ) ( getWidth ( ) / 38.4 ) ) ; button . setFont ( oldFont ) ; } else if ( button . getText ( ) . equals ( "Multiplayer" ) ) { double i = 0 ; newTime = System . currentTimeMillis ( ) ; oldTime = newTime ; while ( multiplayerPulse ) { newTime = System . currentTimeMillis ( ) ; long difference = newTime - oldTime ; i += difference / 250.0 ; Font newFont = new Font ( "Livewired" , Font . PLAIN , ( int ) ( ( getWidth ( ) / 38.4 * Math . abs ( Math . sin ( i ) ) ) + getWidth ( ) / 38.4 ) ) ; button . setFont ( newFont ) ; oldTime = newTime ; } Font oldFont = new Font ( "Livewired" , Font . PLAIN , ( int ) ( getWidth ( ) / 38.4 ) ) ; button . setFont ( oldFont ) ; } else if ( button . getText ( ) . equals ( "Options" ) ) { double i = 0 ; newTime = System . currentTimeMillis ( ) ; oldTime = newTime ; while ( optionsPulse ) { newTime = System . currentTimeMillis ( ) ; long difference = newTime - oldTime ; i += difference / 250.0 ; Font newFont = new Font ( "Livewired" , Font . PLAIN , ( int ) ( ( getWidth ( ) / 38.4 * Math . abs ( Math . sin ( i ) ) ) + getWidth ( ) / 38.4 ) ) ; button . setFont ( newFont ) ; oldTime = newTime ; } Font oldFont = new Font ( "Livewired" , Font . PLAIN , ( int ) ( getWidth ( ) / 38.4 ) ) ; button . setFont ( oldFont ) ; } else if ( button . getText ( ) . equals ( "Exit Game" ) ) { double i = 0 ; newTime = System . currentTimeMillis ( ) ; oldTime = newTime ; while ( exitPulse ) { newTime = System . currentTimeMillis ( ) ; long difference = newTime - oldTime ; i += difference / 250.0 ; Font newFont = new Font ( "Livewired" , Font . PLAIN , ( int ) ( ( getWidth ( ) / 38.4 * Math . abs ( Math . sin ( i ) ) ) + getWidth ( ) / 38.4 ) ) ; button . setFont ( newFont ) ; oldTime = newTime ; } Font oldFont = new Font ( "Livewired" , Font . PLAIN , ( int ) ( getWidth ( ) / 38.4 ) ) ; button . setFont ( oldFont ) ; } }
te	1	public static void clear ( ) { int i = width * height ; for ( int j = 0 ; j < i ; j ++ ) pixels [ j ] = 0 ; }
te	3	public JSONArray put ( int index , Object value ) throws JSONException { JSONObject . testValidity ( value ) ; if ( index < 0 ) { throw new JSONException ( "JSONArray[" + index + "] not found." ) ; } if ( index < this . length ( ) ) { this . myArrayList . set ( index , value ) ; } else { while ( index != this . length ( ) ) { this . put ( JSONObject . null ) ; } this . put ( value ) ; } return this ; }
te	2	@ Override public void characters ( char [ ] ch , int start , int length ) throws SAXException { String value = new String ( ch , start , length ) . trim ( ) ; if ( lastFieldName != null ) { logger . info ( String . format ( Messages . getString ( "parsing_field" ) , lastFieldName , value ) ) ; if ( currentParser . parseField ( lastFieldName , value ) ) { lastFieldName = null ; } else { throw new SAXException ( String . format ( Messages . getString ( "unable_to_parse_field" ) , lastFieldName ) ) ; } } }
te	1	@ Override public void consume ( String str ) { System . out . println ( this . getClass ( ) . getSimpleName ( ) + " Consume" ) ; if ( clientNickName == null ) { clientNickName = new String ( str ) ; consumer . consume ( str + " Joined the chat" ) ; } else { consumer . consume ( new String ( "<" + clientNickName + ">" + str ) ) ; } }
te	4	private void valider ( ) { EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { boolean select = true ; int selectionCorrige = 0 ; int selection = tableau . getSelectedRow ( ) ; try { selectionCorrige = listeAchats . getTableau ( ) . getRowSorter ( ) . convertRowIndexToModel ( selection ) ; } catch ( Exception e ) { select = false ; JOptionPane . showMessageDialog ( new JFrame ( ) , Langue . getTraduction ( "error_no_ticket_selected" ) , Langue . getTraduction ( "warning" ) , JOptionPane . INFORMATION_MESSAGE ) ; } if ( select ) { try { Achat achat = ( Achat ) listeAchats . getObjetByIndex ( selectionCorrige ) ; if ( ! achat . getDonne ( ) ) { achat . setDonner ( true ) ; } else { JOptionPane . showMessageDialog ( new JFrame ( ) , Langue . getTraduction ( "ticket_already_given" ) , Langue . getTraduction ( "warning" ) , JOptionPane . INFORMATION_MESSAGE ) ; } } catch ( Exception e1 ) { Constantes . afficherException ( e1 ) ; } } } } ) ; }
te	5	private boolean insertActivity ( Activity activity ) { String activityName = activity . getName ( ) ; boolean saved = false ; try { Connection conn = Dao . getConnection ( ) ; if ( ! "" . equals ( activityName ) ) { if ( ! activityDao . nameExists ( conn , activityName ) ) { int insertActivity = activityDao . insertActivity ( conn , activity ) ; if ( insertActivity > 0 ) saved = true ; } else { AlertMessages . activityNameExists ( activityDialog , activityName ) ; } } else { AlertMessages . emptyActivityFields ( activityDialog ) ; } } catch ( SQLException ex ) { ErrorMessages . sqlExceptionError ( "insertActivity()" , ex ) ; } catch ( ClassNotFoundException ex ) { ErrorMessages . classNotFoundError ( "insertActivity()" , ex ) ; } return saved ; }
te	9	public AttackPattern getAttackInfo ( String id ) { String query = query_pre + "for $ap in $attacks//capec:Attack_Pattern " + "where $ap/@ID = '" + id + "' " + "let $em := \"empty\" " + "let $sep := '$' " + "let $subsep := '\u20AC' " + "let $subsubsep := '\u2211' " + "return (" + "if(exists($ap/@Name)) then data($ap/@Name) else $em  " + "$sep " + "if(exists($ap/capec:Typical_Severity)) then data($ap/capec:Typical_Severity) else $em  " + "$sep " + "if(exists($ap/capec:Typical_Likelihood_of_Exploit)) then data($ap/capec:Typical_Likelihood_of_Exploit/capec:Likelihood) else $em  " + "$sep " + "if(exists($ap/capec:Related_Weaknesses)) then data(string-join($ap/capec:Related_Weaknesses//capec:CWE_ID  $subsep) ) else $em  " + "$sep " + "if(exists($ap/capec:Attack_Prerequisites)) then data(string-join($ap/capec:Attack_Prerequisites//capec:Text  $subsep) ) else $em  " + "$sep " + "if(exists($ap/capec:Technical_Context)) then " + "(data($ap/capec:Technical_Context//capec:Architectural_Paradigm) $subsep " + "data($ap/capec:Technical_Context//capec:Framework) $subsep " + "data($ap/capec:Technical_Context//capec:Platform) $subsep " + "data($ap/capec:Technical_Context//capec:Languages)) " + "else $em  " + "$sep " + "if(exists($ap/capec:Solutions_and_Mitigations)) then data(string-join($ap/capec:Solutions_and_Mitigations//capec:Text  $subsep) ) else $em  " + "$sep " + "if(exists($ap/capec:Relevant_Security_Requirements)) then data(string-join($ap/capec:Relevant_Security_Requirements//capec:Text  $subsep) ) else $em  " + "$sep " + "if(exists($ap/capec:Methods_of_Attack)) then data(string-join($ap//capec:Method_of_Attack  $subsep) ) else $em  " + "$sep " + "if(exists($ap/capec:Attack_Motivation-Consequences)) then " + "for $ap_consequence in $ap//capec:Attack_Motivation-Consequence " + " return ( data(string-join($ap_consequence/capec:Consequence_Scope  ' '))  $subsubsep  " + "  \t\tdata(string-join($ap_consequence/capec:Consequence_Technical_Impact  ' '))  $subsep)" + "else $em  " + "$sep " + "if(exists($ap/capec:Description/capec:Summary)) then data($ap/capec:Description/capec:Summary//capec:Text) else $em " + ")" ; String result = "" ; try { result = session . execute ( query ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } AttackPattern ap = new AttackPattern ( ) ; String [ ] attributes = result . split ( "\\$" ) ; ap . id = id ; ap . name = attributes [ 0 ] . trim ( ) ; ap . severity = attributes [ 1 ] . trim ( ) ; ap . likelihood = attributes [ 2 ] . trim ( ) ; String [ ] temp = attributes [ 3 ] . split ( "\u20AC" ) ; for ( String weakness : temp ) { ap . weaknesses . add ( weakness . trim ( ) ) ; } temp = attributes [ 4 ] . split ( "\u20AC" ) ; for ( String prerequisite : temp ) { ap . prerequisites . add ( prerequisite . trim ( ) ) ; } temp = attributes [ 5 ] . split ( "\u20AC" ) ; if ( ! temp [ 0 ] . contains ( "empty" ) ) { ap . contexts . addLast ( "Architectural Paradigm: " + temp [ 0 ] . trim ( ) ) ; ap . contexts . addLast ( "Framework: " + temp [ 1 ] . trim ( ) ) ; ap . contexts . addLast ( "Platform: " + temp [ 2 ] . trim ( ) ) ; ap . contexts . addLast ( "Language: " + temp [ 3 ] . trim ( ) ) ; } else { ap . contexts . addLast ( temp [ 0 ] ) ; } temp = attributes [ 6 ] . split ( "\u20AC" ) ; for ( String solution : temp ) { ap . solutions . add ( solution . trim ( ) ) ; } temp = attributes [ 7 ] . split ( "\u20AC" ) ; for ( String requirement : temp ) { ap . requirements . add ( requirement . trim ( ) ) ; } temp = attributes [ 8 ] . split ( "\u20AC" ) ; for ( String method : temp ) { ap . methods . add ( method . trim ( ) ) ; } temp = attributes [ 9 ] . split ( "\u20AC" ) ; for ( String consequence : temp ) { if ( ! consequence . contains ( "empty" ) ) { String [ ] new_temp = consequence . split ( "\u2211" ) ; if ( new_temp . length >= 2 ) { ap . consequences . add ( "Scope: " + new_temp [ 0 ] + "\n" + "Impact(Motivation): " + new_temp [ 1 ] ) ; } } else { ap . consequences . add ( consequence ) ; } } ap . description = attributes [ 10 ] . trim ( ) ; return ap ; }
te	6	public ArrayList < Point > findTrajectory ( ) { if ( _sling == null ) return null ; ArrayList < ConnectedComponent > traj = _seg . findTrajectory ( ) ; ArrayList < Point > pts = new ArrayList < Point > ( ) ; final int THRESHOLD = 30 ; final int TAP_SIZE = 20 ; final int MAX_ERROR = 3 ; Point prev = _ref ; for ( ConnectedComponent c : traj ) { int bound [ ] = c . boundingBox ( ) ; if ( Math . abs ( ( bound [ 2 ] - bound [ 0 ] ) - ( bound [ 3 ] - bound [ 1 ] ) ) > MAX_ERROR ) continue ; Point np = new Point ( ( bound [ 0 ] + bound [ 2 ] ) / 2 , ( bound [ 1 ] + bound [ 3 ] ) / 2 ) ; if ( np . x > _sling . x && distance ( prev , np ) < THRESHOLD ) { pts . add ( np ) ; prev = np ; _draw . add ( c ) ; _drawShape . add ( c . getBody ( ) ) ; if ( c . getArea ( ) > TAP_SIZE ) break ; } } return pts ; }
te	0	public TelePoint ( int points ) { super ( "+" + points ) ; this . points = points ; setBackground ( teleColor ) ; setFont ( buttonFont ) ; addActionListener ( new AddPoints ( ) ) ; }
te	0	public DataTicket ( FileChannel newChannel ) { this . finished = false ; this . channel = newChannel ; }
te	9	private static Object equivIntersect ( Object elt1 , Object elt2 ) { if ( elt1 == NO_ELEMENT || elt2 == NO_ELEMENT ) return NO_ELEMENT ; else if ( elt1 instanceof EquivalentSet ) { ArrayList < Object > al1 = ( ( EquivalentSet ) elt1 ) . contents ; if ( elt2 instanceof EquivalentSet ) { ArrayList < Object > al2 = ( ( EquivalentSet ) elt2 ) . contents ; ArrayList < Object > al = new ArrayList < Object > ( ) ; int size1 = al1 . size ( ) ; for ( int i = 0 ; i < size1 ; ++ i ) { Object e1 = al1 . get ( i ) ; if ( al2 . contains ( e1 ) ) al . add ( e1 ) ; } if ( al . size ( ) == 0 ) return NO_ELEMENT ; else if ( al . size ( ) == 1 ) return al . get ( 0 ) ; else { al . trimToSize ( ) ; return new EquivalentSet ( al ) ; } } else { if ( al1 . contains ( elt2 ) ) return elt2 ; else return NO_ELEMENT ; } } else if ( elt2 instanceof EquivalentSet ) { ArrayList < Object > al2 = ( ( EquivalentSet ) elt2 ) . contents ; if ( al2 . contains ( elt1 ) ) return elt1 ; else return NO_ELEMENT ; } else if ( eql ( elt1 , elt2 ) ) return elt1 ; else return NO_ELEMENT ; }
te	3	public void markSquare ( int xPos , int yPos ) { if ( state . equals ( GameState . PLAYING ) ) { if ( xPos < 0 || yPos < 0 ) throw new IllegalArgumentException ( ) ; getBoard ( ) . markSquare ( xPos , yPos ) ; this . setChanged ( ) ; this . notifyObservers ( ) ; } }
te	3	@ Override public boolean equals ( Object object ) { if ( object == this ) { return true ; } if ( object == null || object . getClass ( ) != this . getClass ( ) ) { return false ; } ISBN smth = ( ISBN ) object ; return isbn == smth . isbn ; }
te	7	public String GetWW ( ) { currenDay = localCalendar . get ( Calendar . DAY_OF_WEEK ) ; String ww = "" ; switch ( currenDay ) { case 1 : ww = "Sunday" ; break ; case 2 : ww = "Monday" ; break ; case 3 : ww = "Tuesday" ; break ; case 4 : ww = "Wednesday" ; break ; case 5 : ww = "Thursday" ; break ; case 6 : ww = "Friday" ; break ; case 7 : ww = "Saturday" ; break ; } return ww ; }
te	0	public void setHeight ( int height ) { this . height = height ; }
te	8	@ Override public TexasHoldemWorker build ( ) { if ( super . getRounds ( ) <= 0 ) { throw new IllegalStateException ( "The number of rounds must be a strictly positive number" ) ; } else if ( super . getProfiles ( ) == null || super . getProfiles ( ) . size ( ) < 2 ) { throw new IllegalStateException ( "There need to be at least 2 players in every simulation." ) ; } else if ( super . getUpdateInterval ( ) <= 0 || 100 % super . getUpdateInterval ( ) != 0 ) { throw new IllegalStateException ( "Invalid update interval value" ) ; } else if ( super . getNotifiable ( ) == null ) { throw new IllegalStateException ( "There needs to be a notifiable for this worker" ) ; } for ( PlayerProfile profile : super . getProfiles ( ) ) { if ( profile == null ) { throw new NullPointerException ( ) ; } } return new TexasHoldemWorker ( this ) ; }
te	4	public PuzzleReader getPuzzleReader ( final PuzzleType type ) { switch ( type ) { case SUDOKU : return SUDOKU_READER ; case POLYMINO : return POLYMINO_READER ; case COVER : return EXACT_COVER_READER ; case QUEENS : return QUEENS_READER ; default : throw new IllegalArgumentException ( "The puzzle type " + type + " is unsupported for reading." ) ; } }
te	9	public void separateModifierTag ( DataHolder dataholderHandler ) { PropertyConfigurator . configure ( "conf/log4j.properties" ) ; Logger myLogger = Logger . getLogger ( "learn.separateModifierTag" ) ; List < SentenceStructure > sentences = dataholderHandler . getSentencesByTagPattern ( "^.* .*$" ) ; for ( SentenceStructure sentenceItem : sentences ) { int sentenceID = sentenceItem . getID ( ) ; String sentence = sentenceItem . getSentence ( ) ; String tag = sentenceItem . getTag ( ) ; myLogger . trace ( "ID: " + sentenceID ) ; myLogger . trace ( "Sentence: " + sentence ) ; myLogger . trace ( "Tag: " + tag ) ; String tagBackup = "" + tag ; if ( StringUtility . isMatchedNullSafe ( tagBackup , "\\w+" ) ) { myLogger . trace ( "Case 1" ) ; if ( ! StringUtility . isMatchedNullSafe ( tagBackup , String . format ( "\\b(%s)\\b" , this . myLearnerUtility . getConstant ( ) . STOP ) ) ) { List < String > words = new LinkedList < String > ( ) ; words . addAll ( Arrays . asList ( tagBackup . split ( "\\s+" ) ) ) ; tag = words . get ( words . size ( ) - 1 ) ; String modifier = "" ; if ( words . size ( ) > 1 ) { modifier = StringUtils . join ( StringUtility . stringArraySplice ( words , 0 , words . size ( ) - 1 ) , " " ) ; } if ( sentenceID == 22 ) { System . out . println ( ) ; } if ( StringUtility . isMatchedNullSafe ( tag , "\\w" ) ) { myLogger . trace ( "Case 1.1" ) ; dataholderHandler . tagSentenceWithMT ( sentenceID , sentence , modifier , tag , "separatemodifiertag" ) ; } else { myLogger . trace ( "Case 1.2" ) ; myLogger . trace ( sentenceID ) ; dataholderHandler . tagSentenceWithMT ( sentenceID , sentence , null , tag , "separatemodifiertag" ) ; } } } else { myLogger . trace ( "Case 2" ) ; if ( ( StringUtility . isMatchedNullSafe ( tagBackup , "^in" ) ) && ( StringUtility . isMatchedNullSafe ( tagBackup , "\\b(with|without)\\b" ) ) ) { myLogger . trace ( "Case 2.1" ) ; dataholderHandler . tagSentenceWithMT ( sentenceID , sentence , "" , null , "separtemodifiertag" ) ; } else { myLogger . trace ( "Case 2.2" ) ; String tagWithStopWordsReplaced = "" + tagBackup ; if ( tagWithStopWordsReplaced != null ) { Pattern p = Pattern . compile ( "@ ([^@]+)$" ) ; Matcher m = p . matcher ( tagWithStopWordsReplaced ) ; if ( m . find ( ) ) { String tg = m . group ( 1 ) ; ArrayList < String > tagWords = new ArrayList < String > ( ) ; tagWords . addAll ( Arrays . asList ( tg . split ( "\\s+" ) ) ) ; tag = tagWords . get ( tagWords . size ( ) - 1 ) ; String modifier = "" ; if ( tagWords . size ( ) > 1 ) { modifier = StringUtils . join ( StringUtility . stringArraySplice ( tagWords , 0 , tagWords . size ( ) ) , " " ) ; } if ( StringUtility . isMatchedNullSafe ( tag , "\\w" ) ) { myLogger . trace ( "Case 2.2.1" ) ; dataholderHandler . tagSentenceWithMT ( sentenceID , sentence , modifier , tag , "separatemodifiertag" ) ; } else { myLogger . trace ( "Case 2.2.2" ) ; dataholderHandler . tagSentenceWithMT ( sentenceID , sentence , "" , null , "separatemodifiertag" ) ; } } } } } } }
te	8	public Decision decide ( RobotView controlledRobot , RobotEnvironmentView environmentView ) { if ( controlledRobot . getCache ( ) . isEmpty ( ) ) { logger . level2 ( "Kieszen pusta" ) ; for ( DeskView desk : environmentView . getDeskViews ( ) ) { for ( Integer isbn : desk . getWishList ( ) ) { logger . level2 ( "Jedziemy do polki po ksiazke do wypozyczenia: " + isbn ) ; return new Decision ( DecisionType . TAKE_FROM_BOOKSHELF , isbn ) ; } } for ( DeskView desk : environmentView . getDeskViews ( ) ) { for ( Book bookToReturn : desk . getBooksToReturn ( ) ) { logger . level2 ( "Jedziemy po ksiazke do oddania do bourka: " + desk ) ; return new Decision ( DecisionType . TAKE_FROM_DESK , desk . getNumber ( ) , bookToReturn . getIsbn ( ) ) ; } } return new Decision ( DecisionType . WAIT ) ; } else { Book bookInCache = controlledRobot . getCache ( ) . get ( 0 ) ; logger . level2 ( "Mamy w kieszeni ksiazke: " + bookInCache ) ; for ( DeskView desk : environmentView . getDeskViews ( ) ) { for ( Integer isbn : desk . getWishList ( ) ) { if ( bookInCache . getIsbn ( ) == isbn ) { logger . level2 ( "Jedziemy dostarczyc ksiazke do bourka: " + desk ) ; return new Decision ( DecisionType . DELIVER_TO_DESK , desk . getNumber ( ) , bookInCache . getIsbn ( ) ) ; } } } logger . level2 ( "Jedziemy odlozyc ksiazke na polke" ) ; return new Decision ( DecisionType . DELIVER_TO_BOOKSHELF , bookInCache . getIsbn ( ) ) ; } }
te	7	public boolean isIrrigable ( ) { switch ( value ) { case 3 : case 8 : case 9 : case 12 : case 13 : case 14 : case 15 : return false ; default : return true ; } }
te	7	public boolean setProps ( BlockPoint bp , PropsType type , boolean history ) { MapBlock mb = getMapBlock ( bp ) ; Props p = mb . getProps ( ) ; Block b = mb . block ; if ( b . getType ( ) != BlockType . FLOOR ) { return false ; } if ( p . getType ( ) == type ) { return true ; } if ( type == PropsType . CABLE ) { if ( isInPigRange ( bp ) ) { return false ; } } if ( p . allow ( ) ) { if ( CableBattle . propsBar . use ( type ) ) { CableBattle . propsBar . recyle ( p . getType ( ) ) ; if ( history ) { historyList . add ( new History ( bp , p . getType ( ) , type ) ) ; } p . setType ( type ) ; checkPropsState ( bp , true ) ; return true ; } } return false ; }
te	6	@ Override public boolean update ( Object event ) { if ( event == m_lic ) { m_disp . update ( m_domain ) ; return true ; } else if ( event == m_field ) { updateVectorField ( ) ; return true ; } else if ( event == m_flowRotate ) { updateVectorField ( ) ; return true ; } else if ( event == m_domain . getDescr ( ) ) { m_lic . setGeometry ( m_domain ) ; m_lic . update ( m_lic ) ; updateVectorField ( ) ; return true ; } else if ( event == m_steps ) { updateVectorField ( ) ; } else if ( event == m_stepSize ) { updateVectorField ( ) ; } return false ; }
te	6	@ Override public Set < EVDistribution > getInitialCollection ( IRestrictionsModel restrictionsModel ) { Set < EVDistribution > initialCollection = new HashSet < > ( ) ; int maxEVs = restrictionsModel . getMaxEVs ( ) ; int minEVs = restrictionsModel . getMinEVs ( ) ; for ( Nature nature : restrictionsModel . getAllowedNatures ( ) ) { for ( int h = 0 ; h <= MAX_STAT_EVS ; h += EV_STEP ) { for ( int d = 0 ; d <= MAX_STAT_EVS ; d += EV_STEP ) { for ( int s = 0 ; s <= MAX_STAT_EVS ; s += EV_STEP ) { int sum = h + d + s ; if ( sum >= minEVs && sum <= maxEVs ) { initialCollection . add ( new EVDistribution ( h , d , s , nature ) ) ; } } } } } return initialCollection ; }
te	8	public boolean sendParamsToController ( String viewName , String viewMethodName , Object [ ] params , ApplicationView av , Usuario user ) { if ( ! hasPermission ( user , viewMethodName ) ) { return false ; } String controllerName = getControllerName ( viewName , viewMethodName ) ; ApplicationController controller = instanceController ( controllerName ) ; try { try { boolean response = false ; if ( params . length == 0 ) { response = ( boolean ) controller . getClass ( ) . getMethod ( getControllerMethod ( viewName , viewMethodName ) ) . invoke ( controller ) ; } else { controller . setParams ( params ) ; response = ( boolean ) controller . getClass ( ) . getMethod ( getControllerMethod ( viewName , viewMethodName ) ) . invoke ( controller ) ; } if ( response ) { av . setReturnedVariable ( controller . getreturnedVariable ( ) ) ; } return response ; } catch ( IllegalAccessException ex ) { Logger . getLogger ( Config . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( IllegalArgumentException ex ) { Logger . getLogger ( Config . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( InvocationTargetException ex ) { Logger . getLogger ( Config . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } } catch ( NoSuchMethodException ex ) { Logger . getLogger ( Config . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( SecurityException ex ) { Logger . getLogger ( Config . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } return false ; }
te	5	public static int evalRPN ( String [ ] tokens ) { int value = 0 ; int temp = 0 ; Stack < Integer > stack = new Stack < Integer > ( ) ; for ( String str : tokens ) { switch ( str ) { case "+" : value = stack . pop ( ) + stack . pop ( ) ; break ; case "-" : temp = stack . pop ( ) ; value = stack . pop ( ) - temp ; break ; case "*" : value = stack . pop ( ) * stack . pop ( ) ; break ; case "/" : temp = stack . pop ( ) ; value = stack . pop ( ) / temp ; break ; default : value = Integer . parseInt ( str ) ; break ; } stack . push ( value ) ; } return stack . pop ( ) ; }
te	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( MainWindow . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( MainWindow . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( MainWindow . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( MainWindow . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { @ Override public void run ( ) { new MainWindow ( ) . setVisible ( true ) ; } } ) ; }
te	4	static Object [ ] boxArgs ( class < ? > [ ] params , Object [ ] args ) { if ( params . length == 0 ) return null ; Object [ ] ret = new Object [ params . length ] ; for ( int i = 0 ; i < params . length ; i ++ ) { Object arg = args [ i ] ; class < ? > paramType = params [ i ] ; ret [ i ] = boxArg ( paramType , arg ) ; } return ret ; }
te	3	public static ArrayList < IPCourseInfo > getIPCourseInfo ( String i_id ) { try { Connection conn = global . getConnection ( ) ; PreparedStatement pStmt = conn . prepareStatement ( "select course_id  name  department  credits  year  semester  offering_id  from offering natural join course where offering_id in (select offering_id from teaches where instructor_id = ?)" ) ; pStmt . setString ( 1 , i_id ) ; PreparedStatement pStmt2 = conn . prepareStatement ( "select rating from teaches where offering_id = ?" ) ; ArrayList < IPCourseInfo > result = new ArrayList < IPCourseInfo > ( ) ; IPCourseInfo tuple = new IPCourseInfo ( ) ; ResultSet rs = pStmt . executeQuery ( ) ; while ( rs . next ( ) ) { tuple . course_id = rs . getString ( 1 ) ; tuple . name = rs . getString ( 2 ) ; tuple . department = rs . getString ( 3 ) ; tuple . credits = rs . getInt ( 4 ) ; tuple . year = rs . getInt ( 5 ) ; tuple . semester = rs . getString ( 6 ) ; tuple . offering_id = rs . getInt ( 7 ) ; pStmt2 . setInt ( 1 , tuple . offering_id ) ; ResultSet rs2 = pStmt2 . executeQuery ( ) ; rs2 . next ( ) ; tuple . rating2 = ( int ) Math . round ( 100 * rs2 . getDouble ( 1 ) ) ; result . add ( tuple ) ; tuple = new IPCourseInfo ( ) ; } return result ; } catch ( ClassNotFoundException cnfe ) { System . err . println ( "IPCourseInfo CNFE: " + cnfe . toString ( ) ) ; return null ; } catch ( SQLException sqle ) { System . err . println ( "IPCourseInfo SQLE: " + sqle . toString ( ) ) ; return null ; } }
te	5	@ Override public void actionPerformed ( ActionEvent e ) { if ( e . getSource ( ) . equals ( prof ) ) { dispose ( ) ; new AddProf ( admin ) ; } else if ( e . getSource ( ) . equals ( administrator ) ) { dispose ( ) ; new AddAdmin ( admin ) ; } else if ( e . getSource ( ) . equals ( elev ) ) { dispose ( ) ; new AddElev ( admin ) ; } else if ( e . getSource ( ) . equals ( secretar ) ) { dispose ( ) ; new AddSecretar ( admin ) ; } if ( e . getSource ( ) . equals ( back ) ) { dispose ( ) ; Centralizator cen = Centralizator . getInstance ( ) ; cen . saveCentralizator ( ) ; new UtilizatoriAdmin ( admin ) ; } }
te	1	private void firePeerReady ( ) { for ( PeerActivityListener listener : this . listeners ) { listener . handlePeerReady ( this ) ; } }
te	4	private static void sort ( File [ ] f ) { for ( int i = 0 ; i < f . length - 1 ; i ++ ) { for ( int j = i + 1 ; j < f . length ; j ++ ) { if ( f [ i ] . isDirectory ( ) && f [ j ] . isFile ( ) ) { File temp = f [ i ] ; f [ i ] = f [ j ] ; f [ j ] = temp ; } } } }
te	3	@ Override public Property [ ] fetchAllProperties ( ) { Connection conn = null ; StringBuffer query = new StringBuffer ( ) ; Property property = null ; ArrayList < Property > propertyContainer = new ArrayList < Property > ( ) ; Property [ ] properties = null ; try { conn = getConnection ( ) ; query . append ( "SELECT " ) . append ( super . columnsToString ( columns ( ) ) ) . append ( " FROM " ) . append ( super . getPrimaryTableName ( ) ) . append ( " ORDER BY property_id ASC" ) ; ResultSet rs = executeQuery ( conn , query . toString ( ) ) ; Object o ; while ( ( o = createObject ( rs ) ) != null ) { property = ( Property ) o ; propertyContainer . add ( property ) ; } rs . close ( ) ; properties = new Property [ propertyContainer . size ( ) ] ; propertyContainer . toArray ( properties ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { if ( conn != null ) { close ( conn ) ; } } return properties ; }
te	2	public double run ( ) { double pointsForEffort = 0 ; double rounds = VFO . getYPosition ( ) ; while ( VFO . getYPosition ( ) > 0 ) { boolean [ ] sv = getShadowVector ( ) ; int move = tracker . updatePosition ( sv ) ; if ( ea != null ) pointsForEffort += ea . pointsForEffort ( sv , move ) ; VFO . step ( ) ; } boolean [ ] sv = getShadowVector ( ) ; int hitPoint = pa . awardPoints ( sv , VFO . getSize ( ) ) ; return ( ( double ) pointsForEffort / rounds ) + hitPoint ; }
te	9	public boolean searchMatrix ( int [ ] [ ] matrix , int target ) { if ( matrix == null || matrix . length == 0 ) return false ; int low = 0 , high = matrix . length - 1 ; while ( low < high ) { int mid = ( low + high ) / 2 ; if ( matrix [ mid ] [ 0 ] == target ) { return true ; } else if ( matrix [ mid ] [ 0 ] > target ) { high = mid - 1 ; } else if ( matrix [ mid + 1 ] [ 0 ] > target ) { low = mid ; break ; } else { low = mid + 1 ; } } int row = low ; low = 0 ; high = matrix [ 0 ] . length - 1 ; while ( low <= high ) { int mid = ( low + high ) / 2 ; if ( matrix [ row ] [ mid ] == target ) return true ; else if ( matrix [ row ] [ mid ] > target ) { high = mid - 1 ; } else { low = mid + 1 ; } } return false ; }
te	6	private void init ( PipedWriter inputStart ) throws IOException { logger . info ( "init pipe" ) ; if ( ! stages . isEmpty ( ) ) { stages . removeAll ( stages ) ; } stages . add ( new Filter ( new PipedReader ( inputStart ) , new PipedWriter ( ) ) ) ; stages . add ( new CaseFolding ( new PipedReader ( stages . get ( stages . size ( ) - 1 ) . getOut ( ) ) , new PipedWriter ( ) ) ) ; if ( ApplicationSetup . getInstance ( ) . getUseStopwords ( ) ) { stages . add ( new StopWordRemoval ( new PipedReader ( stages . get ( stages . size ( ) - 1 ) . getOut ( ) ) , new PipedWriter ( ) ) ) ; } if ( ApplicationSetup . getInstance ( ) . getUseStemmer ( ) ) { stages . add ( new Stemming ( new PipedReader ( stages . get ( stages . size ( ) - 1 ) . getOut ( ) ) , new PipedWriter ( ) ) ) ; } if ( ApplicationSetup . getInstance ( ) . getUseBigrams ( ) ) { stages . add ( new BigramBufferStage ( new PipedReader ( stages . get ( stages . size ( ) - 1 ) . getOut ( ) ) , new PipedWriter ( ) ) ) ; } QueryLookStage query = new QueryLookStage ( new PipedReader ( stages . get ( stages . size ( ) - 1 ) . getOut ( ) ) , new PipedWriter ( ) ) ; stages . add ( query ) ; querystage = query ; pool = Executors . newFixedThreadPool ( stages . size ( ) + 1 ) ; AbstractPipeStage stage ; for ( int i = 0 ; i < stages . size ( ) ; i ++ ) { stage = stages . get ( i ) ; if ( i == 0 ) { stage . setWaitingFor ( stages . get ( stages . size ( ) - 1 ) ) ; } else { stage . setWaitingFor ( stages . get ( i - 1 ) ) ; } pool . execute ( stage ) ; } }
te	0	public void activateTerminal ( ) { new Thread ( terminalReader ) . start ( ) ; }
