tr	7	private int compute_qr ( double [ ] s , double [ ] e , double [ ] u , double [ ] v ) { int k ; boolean converged ; double shift , r ; double utemp , vtemp ; double f , g ; final int MAX_INTERATIONS = 10 ; final double CONVERGE_TOL = 4.89E-15 ; double c_b48 = 1. ; int first ; converged = false ; first = 1 ; if ( Math . abs ( e [ 1 ] ) < CONVERGE_TOL || Math . abs ( e [ 0 ] ) < CONVERGE_TOL ) converged = true ; for ( k = 0 ; k < MAX_INTERATIONS && ! converged ; k ++ ) { shift = compute_shift ( s [ 1 ] , e [ 1 ] , s [ 2 ] ) ; f = ( Math . abs ( s [ 0 ] ) - shift ) * ( d_sign ( c_b48 , s [ 0 ] ) + shift / s [ 0 ] ) ; g = e [ 0 ] ; r = compute_rot ( f , g , sinr , cosr , 0 , first ) ; f = cosr [ 0 ] * s [ 0 ] + sinr [ 0 ] * e [ 0 ] ; e [ 0 ] = cosr [ 0 ] * e [ 0 ] - sinr [ 0 ] * s [ 0 ] ; g = sinr [ 0 ] * s [ 1 ] ; s [ 1 ] = cosr [ 0 ] * s [ 1 ] ; r = compute_rot ( f , g , sinl , cosl , 0 , first ) ; first = 0 ; s [ 0 ] = r ; f = cosl [ 0 ] * e [ 0 ] + sinl [ 0 ] * s [ 1 ] ; s [ 1 ] = cosl [ 0 ] * s [ 1 ] - sinl [ 0 ] * e [ 0 ] ; g = sinl [ 0 ] * e [ 1 ] ; e [ 1 ] = cosl [ 0 ] * e [ 1 ] ; r = compute_rot ( f , g , sinr , cosr , 1 , first ) ; e [ 0 ] = r ; f = cosr [ 1 ] * s [ 1 ] + sinr [ 1 ] * e [ 1 ] ; e [ 1 ] = cosr [ 1 ] * e [ 1 ] - sinr [ 1 ] * s [ 1 ] ; g = sinr [ 1 ] * s [ 2 ] ; s [ 2 ] = cosr [ 1 ] * s [ 2 ] ; r = compute_rot ( f , g , sinl , cosl , 1 , first ) ; s [ 1 ] = r ; f = cosl [ 1 ] * e [ 1 ] + sinl [ 1 ] * s [ 2 ] ; s [ 2 ] = cosl [ 1 ] * s [ 2 ] - sinl [ 1 ] * e [ 1 ] ; e [ 1 ] = f ; utemp = u [ 0 ] ; u [ 0 ] = cosl [ 0 ] * utemp + sinl [ 0 ] * u [ 3 ] ; u [ 3 ] = - sinl [ 0 ] * utemp + cosl [ 0 ] * u [ 3 ] ; utemp = u [ 1 ] ; u [ 1 ] = cosl [ 0 ] * utemp + sinl [ 0 ] * u [ 4 ] ; u [ 4 ] = - sinl [ 0 ] * utemp + cosl [ 0 ] * u [ 4 ] ; utemp = u [ 2 ] ; u [ 2 ] = cosl [ 0 ] * utemp + sinl [ 0 ] * u [ 5 ] ; u [ 5 ] = - sinl [ 0 ] * utemp + cosl [ 0 ] * u [ 5 ] ; utemp = u [ 3 ] ; u [ 3 ] = cosl [ 1 ] * utemp + sinl [ 1 ] * u [ 6 ] ; u [ 6 ] = - sinl [ 1 ] * utemp + cosl [ 1 ] * u [ 6 ] ; utemp = u [ 4 ] ; u [ 4 ] = cosl [ 1 ] * utemp + sinl [ 1 ] * u [ 7 ] ; u [ 7 ] = - sinl [ 1 ] * utemp + cosl [ 1 ] * u [ 7 ] ; utemp = u [ 5 ] ; u [ 5 ] = cosl [ 1 ] * utemp + sinl [ 1 ] * u [ 8 ] ; u [ 8 ] = - sinl [ 1 ] * utemp + cosl [ 1 ] * u [ 8 ] ; vtemp = v [ 0 ] ; v [ 0 ] = cosr [ 0 ] * vtemp + sinr [ 0 ] * v [ 1 ] ; v [ 1 ] = - sinr [ 0 ] * vtemp + cosr [ 0 ] * v [ 1 ] ; vtemp = v [ 3 ] ; v [ 3 ] = cosr [ 0 ] * vtemp + sinr [ 0 ] * v [ 4 ] ; v [ 4 ] = - sinr [ 0 ] * vtemp + cosr [ 0 ] * v [ 4 ] ; vtemp = v [ 6 ] ; v [ 6 ] = cosr [ 0 ] * vtemp + sinr [ 0 ] * v [ 7 ] ; v [ 7 ] = - sinr [ 0 ] * vtemp + cosr [ 0 ] * v [ 7 ] ; vtemp = v [ 1 ] ; v [ 1 ] = cosr [ 1 ] * vtemp + sinr [ 1 ] * v [ 2 ] ; v [ 2 ] = - sinr [ 1 ] * vtemp + cosr [ 1 ] * v [ 2 ] ; vtemp = v [ 4 ] ; v [ 4 ] = cosr [ 1 ] * vtemp + sinr [ 1 ] * v [ 5 ] ; v [ 5 ] = - sinr [ 1 ] * vtemp + cosr [ 1 ] * v [ 5 ] ; vtemp = v [ 7 ] ; v [ 7 ] = cosr [ 1 ] * vtemp + sinr [ 1 ] * v [ 8 ] ; v [ 8 ] = - sinr [ 1 ] * vtemp + cosr [ 1 ] * v [ 8 ] ; m [ 0 ] = s [ 0 ] ; m [ 1 ] = e [ 0 ] ; m [ 2 ] = 0.0 ; m [ 3 ] = 0.0 ; m [ 4 ] = s [ 1 ] ; m [ 5 ] = e [ 1 ] ; m [ 6 ] = 0.0 ; m [ 7 ] = 0.0 ; m [ 8 ] = s [ 2 ] ; if ( Math . abs ( e [ 1 ] ) < CONVERGE_TOL || Math . abs ( e [ 0 ] ) < CONVERGE_TOL ) converged = true ; } if ( Math . abs ( e [ 1 ] ) < CONVERGE_TOL ) { compute_2X2 ( s [ 0 ] , e [ 0 ] , s [ 1 ] , s , sinl , cosl , sinr , cosr , 0 ) ; utemp = u [ 0 ] ; u [ 0 ] = cosl [ 0 ] * utemp + sinl [ 0 ] * u [ 3 ] ; u [ 3 ] = - sinl [ 0 ] * utemp + cosl [ 0 ] * u [ 3 ] ; utemp = u [ 1 ] ; u [ 1 ] = cosl [ 0 ] * utemp + sinl [ 0 ] * u [ 4 ] ; u [ 4 ] = - sinl [ 0 ] * utemp + cosl [ 0 ] * u [ 4 ] ; utemp = u [ 2 ] ; u [ 2 ] = cosl [ 0 ] * utemp + sinl [ 0 ] * u [ 5 ] ; u [ 5 ] = - sinl [ 0 ] * utemp + cosl [ 0 ] * u [ 5 ] ; vtemp = v [ 0 ] ; v [ 0 ] = cosr [ 0 ] * vtemp + sinr [ 0 ] * v [ 1 ] ; v [ 1 ] = - sinr [ 0 ] * vtemp + cosr [ 0 ] * v [ 1 ] ; vtemp = v [ 3 ] ; v [ 3 ] = cosr [ 0 ] * vtemp + sinr [ 0 ] * v [ 4 ] ; v [ 4 ] = - sinr [ 0 ] * vtemp + cosr [ 0 ] * v [ 4 ] ; vtemp = v [ 6 ] ; v [ 6 ] = cosr [ 0 ] * vtemp + sinr [ 0 ] * v [ 7 ] ; v [ 7 ] = - sinr [ 0 ] * vtemp + cosr [ 0 ] * v [ 7 ] ; } else { compute_2X2 ( s [ 1 ] , e [ 1 ] , s [ 2 ] , s , sinl , cosl , sinr , cosr , 1 ) ; utemp = u [ 3 ] ; u [ 3 ] = cosl [ 0 ] * utemp + sinl [ 0 ] * u [ 6 ] ; u [ 6 ] = - sinl [ 0 ] * utemp + cosl [ 0 ] * u [ 6 ] ; utemp = u [ 4 ] ; u [ 4 ] = cosl [ 0 ] * utemp + sinl [ 0 ] * u [ 7 ] ; u [ 7 ] = - sinl [ 0 ] * utemp + cosl [ 0 ] * u [ 7 ] ; utemp = u [ 5 ] ; u [ 5 ] = cosl [ 0 ] * utemp + sinl [ 0 ] * u [ 8 ] ; u [ 8 ] = - sinl [ 0 ] * utemp + cosl [ 0 ] * u [ 8 ] ; vtemp = v [ 1 ] ; v [ 1 ] = cosr [ 0 ] * vtemp + sinr [ 0 ] * v [ 2 ] ; v [ 2 ] = - sinr [ 0 ] * vtemp + cosr [ 0 ] * v [ 2 ] ; vtemp = v [ 4 ] ; v [ 4 ] = cosr [ 0 ] * vtemp + sinr [ 0 ] * v [ 5 ] ; v [ 5 ] = - sinr [ 0 ] * vtemp + cosr [ 0 ] * v [ 5 ] ; vtemp = v [ 7 ] ; v [ 7 ] = cosr [ 0 ] * vtemp + sinr [ 0 ] * v [ 8 ] ; v [ 8 ] = - sinr [ 0 ] * vtemp + cosr [ 0 ] * v [ 8 ] ; } return ( 0 ) ; }
tr	1	public void sendPacket ( byte [ ] packet ) { if ( SAMPCA . ENABLE_ENCRYPTION_OF_PACKETS ) { packet = this . crypto . encryptData ( packet ) ; } DatagramPacket sendPacket = new DatagramPacket ( packet , packet . length , this . group , this . port ) ; this . send ( sendPacket ) ; }
tr	4	public static void main ( String [ ] args ) { System . out . println ( "Inicia el Main" ) ; try { MiClase mc = new MiClase ( ) ; mc . A ( ) ; } catch ( InputMismatchException e ) { System . out . println ( "Escribi bien" ) ; } catch ( ArithmeticException e ) { System . out . println ( "Error Matematico: " + e . getMessage ( ) ) ; } catch ( NullPointerException e ) { System . out . println ( "Instancialo primero" ) ; } catch ( Exception e ) { System . out . println ( "Error " + e . getClass ( ) + " : " + e . getMessage ( ) ) ; } finally { System . out . println ( "Este codigo siempre se ejecuta" ) ; } System . out . println ( "Finaliza el main" ) ; }
tr	0	public void setMaxMwt ( float value ) { this . maxMwt = value ; }
tr	3	private List < Variable > var_definition ( ) { if ( whenToken ( TokenType . SVAR ) ) { List < Variable > ret = new ArrayList < Variable > ( ) ; do { List < String > names = var_names ( ) ; expectToken ( TokenType . SCOLON ) ; Type type = type ( ) ; expectToken ( TokenType . SSEMICOLON ) ; for ( String name : names ) { ret . add ( new Variable ( name , type ) ) ; } } while ( testToken ( TokenType . SIDENTIFIER ) ) ; return ret ; } else { return new LinkedList < Variable > ( ) ; } }
tr	2	@ Override public void handlePeerDisconnected ( SharingPeer peer ) { if ( this . connected . remove ( peer . hasPeerId ( ) ? peer . getHexPeerId ( ) : peer . getHostIdentifier ( ) ) != null ) { logger . debug ( "Peer " + peer + " disconnected  [" + this . connected . size ( ) + "/" + this . peers . size ( ) + "]." ) ; } peer . reset ( ) ; }
tr	6	public Lock lockAndGet ( LockType lockType , Object ... objects ) throws InterruptedException { if ( objects . length == 0 ) return new CompositeLock ( Collections . emptyList ( ) , lockType , this ) ; List < ReentrantReadWriteLock > locks = new ArrayList < > ( objects . length ) ; for ( Object o : objects ) { if ( o != null ) { locks . add ( forObject ( o ) ) ; } } Waiter w = null ; queueLock . lock ( ) ; try { int r = tryAllLocks ( locks , lockType ) ; if ( r > 0 ) return new CompositeLock ( locks , lockType , this ) ; else { w = new Waiter ( ) ; waiters . add ( w ) ; } } finally { queueLock . unlock ( ) ; } for ( ; ; ) { w . semIn . acquire ( ) ; int r = tryAllLocks ( locks , lockType ) ; if ( r > 0 ) { w . acquired = true ; w . semOut . release ( ) ; return new CompositeLock ( locks , lockType , this ) ; } else w . semOut . release ( ) ; } }
tr	1	@ Test public void test ( ) { Processor proc = new PipelineProcessor ( ) ; proc . configure ( DefaultProperties . defaultEnglishProperties ( "tokenize  ssplit  pos  lemma" ) ) ; String doc = "#TEST Sample tweet @romenesko (shares short excerpts from his online column): Josh Prager resigns from WSJ after 13 years; says he and the paper are no longer a good fit." ; Document document = Preprocessor . create ( null , doc , Splitter . DefaultSplitter . instance ( ) ) ; for ( Sentence sentence : document ) { proc . process ( sentence ) ; } String content = Persister . persist ( document ) ; System . out . println ( content ) ; }
tr	8	@ Override public void actionPerformed ( ActionEvent e ) { if ( e . getSource ( ) == btnReproducir ) { reproducirMedio ( ) ; } else if ( e . getSource ( ) == btnSiguiente ) { siguiente ( ) ; } else if ( e . getSource ( ) == btnAnterior ) { anterior ( ) ; } else if ( e . getSource ( ) == btnDetener ) { detener ( ) ; } else if ( e . getSource ( ) == btnRandom ) { if ( btnRandom . isSelected ( ) ) aleatorio = true ; else aleatorio = false ; } if ( e . getSource ( ) == btnMute ) { mute = ! mute ; if ( ! mute ) { establecerVolumen ( ) ; } else { btnMute . setIcon ( new ImageIcon ( this . getClass ( ) . getResource ( IMG_VOLUMEN_MUTE_30 ) ) ) ; hiloReproduccion . cambiarVolumen ( 0 ) ; } } }
tr	7	static final public void sum ( ) throws ParseException { term ( ) ; label_1 : while ( true ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case + : case MINUS : ; break ; default : jj_la1 [ 1 ] = jj_gen ; break label_1 ; } switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case + : jj_consume_token ( + ) ; break ; case MINUS : jj_consume_token ( MINUS ) ; break ; default : jj_la1 [ 2 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } term ( ) ; } }
tr	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( MenuUsuario . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( MenuUsuario . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( MenuUsuario . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( MenuUsuario . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { MenuUsuario dialog = new MenuUsuario ( new javax . swing . JFrame ( ) , true ) ; dialog . addWindowListener ( new java . awt . event . WindowAdapter ( ) { @ Override public void windowClosing ( java . awt . event . WindowEvent e ) { System . exit ( 0 ) ; } } ) ; dialog . setVisible ( true ) ; } } ) ; }
tr	7	public boolean isBipartite ( ) { boolean isBipartite = true ; for ( Vertex v : vertexMap . values ( ) ) { if ( ! v . visited ) { Queue < Vertex > q = new LinkedList < Vertex > ( ) ; v . color = 1 ; v . visited = true ; q . add ( v ) ; while ( ! q . isEmpty ( ) ) { v = q . poll ( ) ; for ( Edge e : v . adj ) { Vertex w = e . dest ; if ( v . color == w . color ) { return false ; } if ( ! w . visited ) { w . visited = true ; if ( v . color == 1 ) { w . color = 2 ; } else { w . color = 1 ; } q . add ( w ) ; } } } } } return isBipartite ; }
tr	3	protected void transform ( Geometry s , Matrix camera ) { if ( s . child != null ) { Matrix cam = new Matrix ( ) ; cam . copy ( camera ) ; Matrix mat = new Matrix ( ) ; mat . copy ( s . globalMatrix ) ; for ( int i = 0 ; i < s . child . length && s . child [ i ] != null ; i ++ ) { s . child [ i ] . globalMatrix . copy ( mat ) ; s . child [ i ] . globalMatrix . preMultiply ( s . child [ i ] . matrix ) ; transform ( s . child [ i ] , cam ) ; } } }
tr	8	public GetAccessTokenResult unmarshall ( StaxUnmarshallerContext context ) throws Exception { GetAccessTokenResult getAccessTokenResult = new GetAccessTokenResult ( ) ; int originalDepth = context . getCurrentDepth ( ) ; int targetDepth = originalDepth + 1 ; if ( context . isStartOfDocument ( ) ) targetDepth += 2 ; while ( true ) { XMLEvent xmlEvent = context . nextEvent ( ) ; if ( xmlEvent . isEndDocument ( ) ) return getAccessTokenResult ; if ( xmlEvent . isAttribute ( ) || xmlEvent . isStartElement ( ) ) { if ( context . testExpression ( "Credentials" , targetDepth ) ) { getAccessTokenResult . setCredentials ( CredentialsStaxUnmarshaller . getInstance ( ) . unmarshall ( context ) ) ; continue ; } } else if ( xmlEvent . isEndElement ( ) ) { if ( context . getCurrentDepth ( ) < originalDepth ) { return getAccessTokenResult ; } } } }
tr	3	@ Override public final Impl before ( Element ... content ) { final int size = size ( ) ; List < Element > result = new ArrayList < Element > ( ) ; List < Element > detached = Util . importOrDetach ( document , content ) ; for ( int i = 0 ; i < size ; i ++ ) { Element element = get ( i ) ; Node parent = element . getParentNode ( ) ; for ( Element e : detached ) { if ( i == 0 ) { result . add ( ( Element ) parent . insertBefore ( e , element ) ) ; } else { result . add ( ( Element ) parent . insertBefore ( e . cloneNode ( true ) , element ) ) ; } } result . add ( element ) ; } elements . clear ( ) ; elements . addAll ( result ) ; return this ; }
tr	4	@ Override public String toString ( ) { boolean isActive = player . isActive ( ) ; StringBuilder b = new StringBuilder ( ) ; b . append ( "<html>" ) ; if ( isPlaying ) b . append ( "<b>" ) ; if ( ! isActive ) b . append ( "<strike>" ) ; b . append ( player . toString ( ) ) ; if ( ! isActive ) b . append ( "</strike>" ) ; if ( isPlaying ) b . append ( "</b>" ) ; b . append ( "</html>" ) ; return b . toString ( ) ; }
tr	5	public void setGoalRandom ( ) { if ( this . goals . isEmpty ( ) ) { this . goal = null ; return ; } if ( this . randomGoals . isEmpty ( ) ) { this . randomGoals . addAll ( this . goals ) ; Collections . shuffle ( this . randomGoals , RANDOM ) ; } this . goal = this . randomGoals . remove ( 0 ) ; if ( this . goal . robotNumber >= this . robots . length ) { this . setGoalRandom ( ) ; } if ( this . isSolution01 ( ) && ( this . randomGoals . size ( ) > 0 ) ) { final Goal goal01 = this . goal ; this . setGoalRandom ( ) ; this . randomGoals . add ( goal01 ) ; } }
tr	7	private List < Layer > makeLayersHierarchy ( List < Layer > layers ) { LinkedList < LinkedList < Layer >> layersStack = new LinkedList < LinkedList < Layer >> ( ) ; ArrayList < Layer > rootLayers = new ArrayList < Layer > ( ) ; for ( Layer layer : layers ) { switch ( layer . getType ( ) ) { case HIDDEN : { layersStack . addFirst ( new LinkedList < Layer > ( ) ) ; break ; } case FOLDER : { assert ( layersStack . isEmpty ( ) != true ) ; if ( ! layersStack . isEmpty ( ) ) { LinkedList < Layer > folderLayers = layersStack . removeFirst ( ) ; for ( Layer l : folderLayers ) { layer . addLayer ( l ) ; } } } case NORMAL : { if ( layersStack . isEmpty ( ) ) { rootLayers . add ( layer ) ; } else { layersStack . getFirst ( ) . add ( layer ) ; } break ; } default : assert false ; } } return rootLayers ; }
tr	1	public List < Frequencia > getFrequenciaFuncionario2 ( Integer mes , Integer ano , Integer dia , Integer ultimodia , Integer idFuncionario ) throws SQLException { List < Frequencia > frequencia = new ArrayList < Frequencia > ( ) ; con = cp . getconection ( ) ; String sql = "SELECT * FROM frequencia WHERE idfuncionario = ? and data between ? and ?" ; PreparedStatement ps = con . prepareStatement ( sql , ResultSet . TYPE_SCROLL_SENSITIVE , ResultSet . CONCUR_UPDATABLE ) ; ps . setInt ( 1 , idFuncionario ) ; Calendar c = Calendar . getInstance ( ) ; c . set ( ano , ( mes ) , dia ) ; ps . setDate ( 2 , new Date ( c . getTimeInMillis ( ) ) ) ; c = Calendar . getInstance ( ) ; c . set ( ano , ( mes ) , ultimodia ) ; ps . setDate ( 3 , new Date ( c . getTimeInMillis ( ) ) ) ; Frequencia f ; ResultSet rs = ps . executeQuery ( ) ; while ( rs . next ( ) ) { f = new Frequencia ( ) ; f . setId ( rs . getInt ( "idfrequencia" ) ) ; f . setData ( rs . getDate ( "data" ) ) ; f . setPresenca ( rs . getBoolean ( "presenca" ) ) ; f . setFuncionario ( new FuncionarioDao ( ) . getfuncionario ( rs . getInt ( "idFuncionario" ) ) ) ; f . setHoraSaida ( rs . getTimestamp ( "hora_saida" ) ) ; f . setTurno ( rs . getString ( "turno" ) ) ; frequencia . add ( f ) ; } return frequencia ; }
tr	0	private void jButton1ActionPerformed ( java . awt . event . ActionEvent evt ) { this . dispose ( ) ; }
tr	9	public void run ( ) { while ( this . isRunning ) { if ( fetchStage . execute ( ) != 0 ) { log . error ( "FETCH stage failed. Please check" ) ; } if ( issueStage . execute ( ) != 0 ) { log . error ( "ISSUE stage failed. Please check" ) ; this . isRunning = false ; break ; } if ( readStage . execute ( ) != 0 ) { log . error ( "READ stage failed. Please check" ) ; this . isRunning = false ; break ; } if ( execStage . execute ( ) != 0 ) { log . error ( "EXEC stage failed. Please check" ) ; this . isRunning = false ; break ; } if ( writeStage . execute ( ) != 0 ) { log . error ( "WRITE stage failed. Please check" ) ; this . isRunning = false ; break ; } if ( this . isEmpty ( ) ) { log . debug ( "Pipeline is now empty  stopping program execution." ) ; this . isRunning = false ; break ; } else { log . debug ( "Pipeline still running." ) ; } try { if ( ++ cnt == 4 ) { cnt = 0 ; log . info ( "Ticking at 1sec" ) ; } PipeLine . sleep ( 250 ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } log . debug ( "This is clock tick: " + clock ++ ) ; System . out . println ( "" ) ; } }
tr	9	protected void defineCommands ( ) { commands . put ( "quit" , new Command ( ) { public void run ( String [ ] args ) throws Exception { close ( ) ; } } ) ; commands . put ( "create" , new Command ( ) { public void run ( String [ ] args ) throws Exception { if ( args . length < 2 ) { gui . addNotice ( "create <pokoj> <haslo>" ) ; return ; } String roomName = args [ 0 ] ; String password = args [ 1 ] ; if ( client != null ) client . createRoom ( roomName , password ) ; } } ) ; commands . put ( "join" , new Command ( ) { public void run ( String [ ] args ) throws Exception { if ( args . length < 3 ) { gui . addNotice ( "join <nick> <pokoj> <haslo>" ) ; return ; } String nickname = args [ 0 ] ; String roomName = args [ 1 ] ; String password = args [ 2 ] ; if ( client != null ) { if ( currentRoom != null ) { handleCommand ( "leave" ) ; } client . joinRoom ( roomName , password , nickname ) ; currentRoom = new CurrentRoom ( roomName , nickname ) ; } } } ) ; commands . put ( "leave" , new Command ( ) { public void run ( String [ ] args ) throws Exception { if ( currentRoom == null ) { gui . addError ( "Nie jeste\u015B obecnie w \u017Cadnym pokoju" ) ; return ; } if ( client != null ) { String currentRoomName = currentRoom . roomName ; String currentRoomNickname = currentRoom . nickname ; client . leaveRoom ( currentRoom . roomName , currentRoom . nickname ) ; currentRoom = null ; gui . addNotice ( String . format ( "%s opu\u015Bci\u0142(a) pok\u00F3j %s" , currentRoomNickname , currentRoomName ) ) ; gui . setStatus ( "" ) ; } } } ) ; commands . put ( "msgs" , new Command ( ) { private final String SENT_FORMAT = "dd.MM.yyyy" ; public void run ( String [ ] args ) throws Exception { if ( currentRoom == null ) { gui . addError ( "Nie jeste\u015B obecnie w \u017Cadnym pokoju" ) ; return ; } if ( client != null ) { String sentArg = args . length > 0 ? args [ 0 ] : null ; Date sent = null ; if ( sentArg != null ) { SimpleDateFormat df = new SimpleDateFormat ( SENT_FORMAT ) ; try { sent = df . parse ( sentArg ) ; } catch ( ParseException e ) { gui . addNotice ( String . format ( "msgs: Data powinna byc w formacie `%s'" , SENT_FORMAT ) ) ; return ; } } client . showMessages ( currentRoom . roomName , sent ) ; } } } ) ; }
tr	9	public String buildUrl ( ) { StringBuilder urlBuilder = new StringBuilder ( ) ; StringBuilder placeHolderBuilder = new StringBuilder ( ) ; boolean placeHolderFlag = false ; for ( int i = 0 ; i < urlFormat . length ( ) ; i ++ ) { if ( urlFormat . charAt ( i ) == API_URLS_PLACEHOLDER_START ) { placeHolderBuilder = new StringBuilder ( ) ; placeHolderFlag = true ; } else if ( placeHolderFlag && urlFormat . charAt ( i ) == API_URLS_PLACEHOLDER_END ) { String placeHolder = placeHolderBuilder . toString ( ) ; if ( PROTOCOL_PLACEHOLDER . equals ( placeHolder ) ) { urlBuilder . append ( API_PROTOCOL ) ; } else if ( QUERY_PARAMETERS_PLACEHOLDER . equals ( placeHolder ) ) { StringBuilder builder = new StringBuilder ( ) ; if ( ! parametersMap . isEmpty ( ) ) { Iterator < String > iter = parametersMap . keySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { String name = iter . next ( ) ; String value = parametersMap . get ( name ) ; builder . append ( name ) ; builder . append ( "=" ) ; builder . append ( value ) ; if ( iter . hasNext ( ) ) { builder . append ( "&" ) ; } } } urlBuilder . append ( builder . toString ( ) ) ; } else { urlBuilder . append ( API_URLS_PLACEHOLDER_START ) ; urlBuilder . append ( placeHolder ) ; urlBuilder . append ( API_URLS_PLACEHOLDER_END ) ; } placeHolderFlag = false ; } else if ( placeHolderFlag ) { placeHolderBuilder . append ( urlFormat . charAt ( i ) ) ; } else { urlBuilder . append ( urlFormat . charAt ( i ) ) ; } } return urlBuilder . toString ( ) ; }
tr	4	public static void assertCollisionException ( String input , Tester tester , int expectedPos , int expectedLine ) { AbnfParser parser = AbnfParser . newInstance ( input ) ; try { tester . test ( parser ) ; assert . fail ( ) ; } catch ( MatchException me ) { assert . fail ( ) ; } catch ( IOException e ) { assert . fail ( ) ; } catch ( CollisionException ce ) { assert . assertEquals ( expectedPos , parser . getInputStream ( ) . getPos ( ) ) ; assert . assertEquals ( expectedLine , parser . getInputStream ( ) . getLine ( ) ) ; } catch ( IllegalAbnfException iae ) { assert . fail ( ) ; } }
tr	8	public void run ( File subjectSortedInput , File indexOutput ) { try { IndexWriter indexWriter = new IndexWriter ( indexOutput ) ; NQuadParser parserIn = new NQuadParser ( subjectSortedInput ) ; PrintStream out = new PrintStream ( indexOutput ) ; while ( parserIn . hasNext ( ) ) { NQuad nq = parserIn . next ( ) ; if ( ( nq . object . startsWith ( "\"" ) ) && ( nq . object . length ( ) > 2 ) ) { String in = nq . object . substring ( 1 , nq . object . length ( ) - 2 ) ; if ( in . length ( ) > 0 ) { BreakIterator wordIterator = BreakIterator . getWordInstance ( Locale . ENGLISH ) ; wordIterator . setText ( in ) ; int wordBoundary = wordIterator . first ( ) ; int wordPrev = wordBoundary ; while ( wordBoundary != BreakIterator . DONE ) { wordPrev = wordBoundary ; wordBoundary = wordIterator . next ( ) ; if ( wordBoundary != BreakIterator . DONE ) { String word = this . prepWord ( in . substring ( wordPrev , wordBoundary ) ) ; if ( word . length ( ) > 0 ) { TreeSet < String > terms = new TreeSet < String > ( ) ; terms . add ( word ) ; indexWriter . addToIndex ( nq . subject , terms ) ; } } } } } } out . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }
tr	4	private String makeBetween ( LangFileElement lfe ) { if ( lfe . isNewElement ( ) ) { switch ( betweenType ) { case BETWEEN_ALIGNEMENT : int len = lfe . getPrefix ( ) . length ( ) + 9 + lfe . getLine ( ) . length ( ) ; String between = " " ; for ( int i = len ; i < betweenPadding ; i ++ ) { between += " " ; } return between ; case BETWEEN_STRING : default : return betweenString ; } } else { return lfe . getBetween ( ) ; } }
tr	4	private static int method515 ( char ac [ ] , int i ) { for ( int k = i ; k < ac . length && k >= 0 ; k ++ ) if ( ac [ k ] >= 0 && ac [ k ] <= 9 ) return k ; return - 1 ; }
tr	2	@ Override public boolean equals ( Object other ) { boolean result = false ; if ( other instanceof Tuple ) { Tuple that = ( Tuple ) other ; result = ( this . source . equals ( that . source ) && this . target . equals ( that . target ) ) ; } return result ; }
tr	4	public static int gcd ( int a , int b ) { if ( a < 0 ) return gcd ( - a , b ) ; if ( b < 0 ) return gcd ( a , - b ) ; if ( a < b ) return gcd ( b , a ) ; while ( b > 0 ) { int r = a % b ; a = b ; b = r ; } return a ; }
tr	7	private void handleActionComplete ( MqttToken token ) throws MqttException { final String methodName = "handleActionComplete" ; synchronized ( token ) { log . fine ( className , methodName , "705" , new Object [ ] { token . internalTok . getKey ( ) } ) ; token . internalTok . notifyComplete ( ) ; if ( ! token . internalTok . isNotified ( ) ) { if ( mqttCallback != null && token instanceof MqttDeliveryToken && token . isComplete ( ) ) { mqttCallback . deliveryComplete ( ( MqttDeliveryToken ) token ) ; } fireActionEvent ( token ) ; } if ( token instanceof MqttDeliveryToken && token . isComplete ( ) ) { token . internalTok . setNotified ( true ) ; } if ( token . isComplete ( ) ) { clientState . notifyComplete ( token ) ; } } }
tr	5	private void train ( InputIterable < String > trainData ) { int firstHash = 1 ; int secondHash = - 1 ; int firstInsertCount = 0 ; int secondInsertCount = 0 ; WrappedObject first , second ; for ( ParseResult < String > row : trainData ) { first = new WrappedObject ( row . getFirstNode ( ) ) ; second = new WrappedObject ( row . getSecondNode ( ) ) ; if ( ! hash . containsKey ( first ) ) { if ( firstInsertCount > 10000 ) { firstInsertCount = 0 ; firstHash ++ ; } else { firstInsertCount ++ ; } hash . put ( first , firstHash ) ; } if ( ! hash . containsKey ( second ) ) { if ( secondInsertCount > 10000 ) { secondInsertCount = 0 ; secondHash -- ; } else { secondInsertCount ++ ; } hash . put ( second , secondHash ) ; } } }
tr	3	@ Test public void testDBit ( ) throws Exception { final File dir = File . createTempFile ( "SQLScrewdriverJUnitTest_" , ".db" ) ; dir . delete ( ) ; dir . mkdir ( ) ; final String dbName = new File ( dir , "H2DB" ) . getAbsolutePath ( ) ; final String comment = "JunitTestDB" ; final String dbUserName = "JunitTestDB" ; final String dbPassword = "JunitTestDB" ; final String dbURL = "jdbc:h2:" + dbName ; final String driver = "org.h2.Driver" ; final String colQuote = "\"" ; final boolean readOnly = false ; final DBHandle dbhandle = DBUtil . buildConnection ( comment , dbUserName , dbPassword , dbURL , driver , readOnly , colQuote ) ; Exception ex = null ; try { final Statement stmt = dbhandle . conn . createStatement ( ) ; stmt . executeUpdate ( "CREATE TABLE TESTTAB (IARG INT  SARG VARCHAR(128)  BIARG NUMERIC(30)  BNARG NUMERIC(30 20)  DARG DOUBLE PRECISION)" ) ; final PreparedStatement pstmt = dbhandle . conn . prepareStatement ( "INSERT INTO TESTTAB (IARG  SARG  BIARG  BNARG  DARG) VALUES (?  ?  ?  ?  ?)" ) ; pstmt . setInt ( 1 , 7 ) ; pstmt . setString ( 2 , "hi there" ) ; pstmt . setBigDecimal ( 3 , new BigDecimal ( BigInteger . TEN ) ) ; pstmt . setBigDecimal ( 4 , new BigDecimal ( new BigInteger ( "123" ) , 2 ) ) ; pstmt . setDouble ( 5 , 1.7 ) ; pstmt . executeUpdate ( ) ; pstmt . close ( ) ; final DBIterable it = new DBIterable ( stmt , "SELECT * FROM TESTTAB" ) ; long n = 0 ; for ( final BurstMap row : it ) { final long vIARG = row . getAsLong ( "IARG" ) ; final String vSARG = row . getAsString ( "SARG" ) ; final long vBIARG = row . getAsLong ( "BIARG" ) ; final double vBNARG = row . getAsDouble ( "BNARG" ) ; final double vDARG = row . getAsDouble ( "DARG" ) ; assertEquals ( 7 , vIARG ) ; assertEquals ( "hi there" , vSARG ) ; assertEquals ( 10 , vBIARG ) ; assertTrue ( Math . abs ( 1.23 - vBNARG ) < 1.0e-10 ) ; assertTrue ( Math . abs ( 1.7 - vDARG ) < 1.0e-10 ) ; ++ n ; } assertEquals ( 1 , n ) ; stmt . close ( ) ; } catch ( Exception e ) { ex = e ; } finally { dbhandle . conn . close ( ) ; rmDir ( dir ) ; } if ( null != ex ) { throw ex ; } }
tr	6	public void sortBy ( String order ) { DefaultMutableTreeNode tmpNode = null ; DefaultMutableTreeNode curNodeCopy = null ; SortTreeModel treeModelTmp = null ; DefaultMutableTreeNode rootTmp = new DefaultMutableTreeNode ( rootNodeTxt ) ; if ( order . equals ( "name" ) ) { treeModelTmp = new SortTreeModel ( rootTmp , new TreeStringComparatorName ( ) ) ; sortedByName = true ; } else { treeModelTmp = new SortTreeModel ( rootTmp , new TreeStringComparatorDate ( ) ) ; sortedByName = false ; } sortByNameMenuItem . setEnabled ( ! sortedByName ) ; sortByDateMenuItem . setEnabled ( sortedByName ) ; for ( @ SuppressWarnings ( "rawtypes" ) Enumeration e = ( ( DefaultMutableTreeNode ) treeModel . getRoot ( ) ) . breadthFirstEnumeration ( ) ; e . hasMoreElements ( ) ; ) { DefaultMutableTreeNode curNode = ( DefaultMutableTreeNode ) e . nextElement ( ) ; Object obj = curNode . getUserObject ( ) ; if ( obj instanceof Item ) { Item currentItem = ( Item ) obj ; if ( currentItem . isDir ( ) ) curNodeCopy = new FolderNode ( currentItem ) ; else curNodeCopy = new LeafNode ( currentItem , ( ( LeafNode ) curNode ) . getDownPerc ( ) , ( ( LeafNode ) curNode ) . getStatus ( ) ) ; Object objPar = ( ( DefaultMutableTreeNode ) curNode . getParent ( ) ) . getUserObject ( ) ; if ( objPar instanceof Item ) { if ( ( tmpNode = getItemInTree ( ( Item ) objPar , treeModelTmp ) ) != null ) { treeModelTmp . insertNodeInto ( curNodeCopy , tmpNode ) ; } } else { treeModelTmp . insertNodeInto ( curNodeCopy , rootTmp ) ; } } } rootNode = rootTmp ; treeModel = treeModelTmp ; tree . setModel ( treeModel ) ; }
tr	9	@ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; ConstDeclarationNode other = ( ConstDeclarationNode ) obj ; if ( expression == null ) { if ( other . expression != null ) return false ; } else if ( ! expression . equals ( other . expression ) ) return false ; if ( ident == null ) { if ( other . ident != null ) return false ; } else if ( ! ident . equals ( other . ident ) ) return false ; return true ; }
tr	5	public void modifyPairings ( ) { String moveKey = "" ; ArrayList < Type > all = new ArrayList < Type > ( ) ; Bug bug = new Bug ( ) ; all . add ( bug ) ; all . add ( new Dark ( ) ) ; all . add ( new Dragon ( ) ) ; all . add ( new Electric ( ) ) ; all . add ( new Fighting ( ) ) ; all . add ( new Fire ( ) ) ; all . add ( new Flying ( ) ) ; all . add ( new Ghost ( ) ) ; all . add ( new Grass ( ) ) ; all . add ( new Ground ( ) ) ; all . add ( new Ice ( ) ) ; all . add ( new Normal ( ) ) ; all . add ( new Poison ( ) ) ; all . add ( new Psychic ( ) ) ; all . add ( new Rock ( ) ) ; all . add ( new Steel ( ) ) ; all . add ( new Water ( ) ) ; None none = new None ( ) ; for ( int i = 0 ; i < 6 ; i ++ ) { Pokemon sampleMember = team . get ( i ) ; for ( int x = 0 ; x < 4 ; x ++ ) { moveKey = sampleMember . getCircumvent ( ) . get ( x ) ; for ( int y = 0 ; y < all . size ( ) ; y ++ ) { Type comparedTo1 = all . get ( y ) ; Type comparedTo2 = none ; if ( sampleMember . getMove ( moveKey ) instanceof SpecifiedPhysical ) { SpecifiedPhysical popMove = ( SpecifiedPhysical ) sampleMember . getMove ( moveKey ) ; int popMoveR = popMove . getType ( ) . resistedCounter ( comparedTo1 , comparedTo2 ) ; int popMoveSE = popMove . getType ( ) . superEffectiveCounter ( comparedTo1 , comparedTo2 ) ; int popMoveI = popMove . getType ( ) . immuneCounter ( comparedTo1 , comparedTo2 ) ; moveSuperEffectives += popMoveSE ; moveResistances += popMoveR ; moveImmunities += popMoveI ; } if ( sampleMember . getMove ( moveKey ) instanceof SpecifiedSpecial ) { SpecifiedSpecial popMove = ( SpecifiedSpecial ) sampleMember . getMove ( moveKey ) ; int popMoveR = popMove . getType ( ) . resistedCounter ( comparedTo1 , comparedTo2 ) ; int popMoveSE = popMove . getType ( ) . superEffectiveCounter ( comparedTo1 , comparedTo2 ) ; int popMoveI = popMove . getType ( ) . immuneCounter ( comparedTo1 , comparedTo2 ) ; moveSuperEffectives += popMoveSE ; moveResistances += popMoveR ; moveImmunities += popMoveI ; } } } } }
tr	8	public static int firstGreaterK ( int [ ] arr , int left , int right , int k , int minGreaterK , int minI ) { int N = right - left + 1 ; if ( N <= 0 ) { return minI ; } if ( N == 1 ) { if ( arr [ left ] <= minGreaterK && left < minI ) { return left ; } return minI ; } int mid = left + ( right - left ) / 2 ; if ( arr [ mid ] <= k ) { return firstGreaterK ( arr , mid + 1 , right , k , minGreaterK , minI ) ; } if ( arr [ mid ] < minGreaterK ) { minGreaterK = arr [ mid ] ; minI = mid ; } else if ( arr [ mid ] == minGreaterK && mid < minI ) { minI = mid ; } return firstGreaterK ( arr , left , mid - 1 , k , minGreaterK , minI ) ; }
tr	7	public void SendPinMsg ( ) { message = msgs . getText ( ) ; subject = subj . getText ( ) ; HTTPClient hc = new HTTPClient ( ) ; hc . getConnectionString ( ) ; if ( ! AppFunctions . ntwkCon ) { UiApplication . getUiApplication ( ) . invokeLater ( new Runnable ( ) { public void run ( ) { Dialog . inform ( "Please check your network  Pin Broadcast requires BIS or Wifi" ) ; info . setText ( "Check your network connection" ) ; } } ) ; } else if ( AppFunctions . trialCount < 1 ) { UiApplication . getUiApplication ( ) . invokeLater ( new Runnable ( ) { public void run ( ) { Dialog . inform ( "You have exceeded the number of messages you can send. You have " + AppFunctions . trialCount + " left. Please Buy more messages by selecting the 'Buy Pin Message' menu for information on subscription. Select 'Verify Account' on the menu after subscription to send more messages." ) ; info . setText ( "Message number exceeded." ) ; } } ) ; } else if ( ContactArray . size ( ) > AppFunctions . trialCount ) { UiApplication . getUiApplication ( ) . invokeLater ( new Runnable ( ) { public void run ( ) { Dialog . inform ( "The contacts in your message exceeds what you have left (" + AppFunctions . formatNumber ( AppFunctions . trialCount , 0 , " " ) + "). Please subscribe and select 'Verify Account' on the menu for unlimited contacts or reduce the number of your contacts to " + AppFunctions . formatNumber ( AppFunctions . trialCount , 0 , " " ) ) ; } } ) ; } else { if ( message . length ( ) < 5 || subject . length ( ) < 3 || from . getText ( ) . length ( ) < 2 || FileSel == null ) { UiApplication . getUiApplication ( ) . invokeLater ( new Runnable ( ) { public void run ( ) { Dialog . inform ( "Please verify that From  Subject  Message and your Contact File has been entered properly before sending this message." ) ; info . setText ( "Error in message  please check again." ) ; } } ) ; } else { new Thread ( sndmsg ) . start ( ) ; } } }
tr	8	public RightClickMenu ( ) { super ( ) ; JMenuItem addObject = new JMenuItem ( "add object" ) ; addObject . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent actionEvent ) { PipedReader pipedReader = new PipedReader ( ) ; ObjectTypeSelectorWindow getObjectType = new ObjectTypeSelectorWindow ( pipedReader ) ; int type = 0 ; try { type = pipedReader . read ( ) ; pipedReader . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } switch ( type ) { case OfficeObject . OFFICE_OBJECT_PC : curRoom . addObject ( new PC ( ) ) ; break ; case OfficeObject . OFFICE_OBJECT_LAPTOP : curRoom . addObject ( new Laptop ( ) ) ; break ; case OfficeObject . OFFICE_OBJECT_PRINTER : curRoom . addObject ( new Printer ( ) ) ; break ; case OfficeObject . OFFICE_OBJECT_ROUTER : curRoom . addObject ( new Router ( ) ) ; break ; case OfficeObject . OFFICE_OBJECT_MONITOR : curRoom . addObject ( new Monitor ( ) ) ; break ; } parentComponent . repaint ( ) ; if ( curRoom != null || parentComponent != null ) { setLocation ( curRoom . getX ( ) + 300 , curRoom . getY ( ) + 300 ) ; setVisible ( false ) ; } else setVisible ( false ) ; } } ) ; add ( addObject ) ; }
tr	0	@ Override public void imprimirFormaDePago ( ) { this . imprimirDatos ( ) ; }
tr	3	synchronized public int getPlayerIndex ( String ip , int port ) { for ( int i = 0 ; i < playersArr . length ; i ++ ) { if ( ( playersArr [ i ] != null ) && ( playersArr [ i ] . matches ( ip , port ) ) ) return i ; } return - 1 ; }
tr	9	public ProgrammerAction ( String title , String tooltip , char mnemonic , String smallIcon , String largeIcon , KeyStroke accelerator ) { super ( ) ; if ( title != null && title . length ( ) > 0 ) putValue ( NAME , title ) ; if ( tooltip != null && tooltip . length ( ) > 0 ) putValue ( SHORT_DESCRIPTION , tooltip ) ; if ( smallIcon != null && smallIcon . length ( ) > 0 ) putValue ( SMALL_ICON , new ImageIcon ( getClass ( ) . getResource ( "icons/16/" + smallIcon ) ) ) ; if ( largeIcon != null && largeIcon . length ( ) > 0 ) putValue ( LARGE_ICON_KEY , new ImageIcon ( getClass ( ) . getResource ( "icons/32/" + largeIcon ) ) ) ; if ( mnemonic > 0 ) putValue ( MNEMONIC_KEY , KeyEvent . getExtendedKeyCodeForChar ( mnemonic ) ) ; if ( accelerator != null ) putValue ( ACCELERATOR_KEY , accelerator ) ; }
tr	5	public JSONObject increment ( String key ) throws JSONException { Object value = this . opt ( key ) ; if ( value == null ) { this . put ( key , 1 ) ; } else if ( value instanceof Integer ) { this . put ( key , ( ( Integer ) value ) . intValue ( ) + 1 ) ; } else if ( value instanceof long ) { this . put ( key , ( ( long ) value ) . longValue ( ) + 1 ) ; } else if ( value instanceof double ) { this . put ( key , ( ( double ) value ) . doubleValue ( ) + 1 ) ; } else if ( value instanceof float ) { this . put ( key , ( ( float ) value ) . floatValue ( ) + 1 ) ; } else { throw new JSONException ( "Unable to increment [" + quote ( key ) + "]." ) ; } return this ; }
tr	4	public static void main ( String [ ] args ) { Scanner cin = new Scanner ( System . in ) ; int index = 0 ; int count ; String str ; while ( cin . hasNext ( ) ) { index ++ ; count = cin . nextInt ( ) ; str = cin . next ( ) ; next ( str ) ; System . out . println ( "Test case #" + index ) ; for ( int i = 2 ; i <= count ; i ++ ) { if ( i % ( i - next [ i - 1 ] ) == 0 && next [ i - 1 ] != 0 ) System . out . println ( i + " " + i / ( i - next [ i - 1 ] ) ) ; } System . out . println ( ) ; } }
tr	5	@ Override public float [ ] getFloatData ( ) { if ( ptr != 0 ) { return null ; } else { if ( isConstant ( ) ) { if ( length > getMaxSizeOf32bitArray ( ) ) return null ; float [ ] out = new float [ ( int ) length ] ; for ( int i = 0 ; i < length ; i ++ ) { out [ i ] = data [ 0 ] ; } return out ; } else { float [ ] out = new float [ ( int ) length ] ; for ( int i = 0 ; i < length ; i ++ ) { out [ i ] = ( float ) data [ i ] ; } return out ; } } }
tr	7	public int read ( int width ) throws IOException { if ( width == 0 ) { return 0 ; } if ( width < 0 || width > 32 ) { throw new IOException ( "Bad read width." ) ; } int result = 0 ; while ( width > 0 ) { if ( this . available == 0 ) { this . unread = this . in . read ( ) ; if ( this . unread < 0 ) { throw new IOException ( "Attempt to read past end." ) ; } this . available = 8 ; } int take = width ; if ( take > this . available ) { take = this . available ; } result |= ( ( this . unread >>> ( this . available - take ) ) & mask [ take ] ) << ( width - take ) ; this . nrBits += take ; this . available -= take ; width -= take ; } return result ; }
tr	4	public int update ( int [ ] sig , double [ ] variances ) { int onset = Integer . MAX_VALUE ; for ( int i = 0 ; i < sig . length ; i ++ ) { signals . get ( i ) . add ( sig [ i ] ) ; } if ( isFilled ( ) ) { System . out . print ( ( check ? "window filled\n" : "" ) ) ; check = false ; for ( int i = 0 ; i < sig . length ; i ++ ) { signals . get ( i ) . poll ( ) ; } onset = applyBonatoTest ( variances ) ; } return onset ; }
tr	4	private void getFaceIndices ( int [ ] indices , Face face , int flags ) { boolean ccw = ( ( flags & CLOCKWISE ) == 0 ) ; boolean indexedFromOne = ( ( flags & INDEXED_FROM_ONE ) != 0 ) ; boolean pointRelative = ( ( flags & POINT_RELATIVE ) != 0 ) ; HalfEdge hedge = face . he0 ; int k = 0 ; do { int idx = hedge . head ( ) . index ; if ( pointRelative ) { idx = vertexPointIndices [ idx ] ; } if ( indexedFromOne ) { idx ++ ; } indices [ k ++ ] = idx ; hedge = ( ccw ? hedge . next : hedge . prev ) ; } while ( hedge != face . he0 ) ; }
tr	8	private boolean InputScreen ( ) { m_ComboPlayer1Type = new JComboBox ( m_PlayerTypes ) ; m_ComboPlayer1Type . setSelectedIndex ( 0 ) ; m_ComboPlayer2Type = new JComboBox ( m_PlayerTypes ) ; m_ComboPlayer2Type . setSelectedIndex ( 0 ) ; m_ComboPlayer1Colour = new JComboBox ( ) ; m_ComboPlayer2Colour = new JComboBox ( ) ; m_ComboPlayer1Colour . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { if ( "Red" . equals ( m_ComboPlayer1Colour . getSelectedItem ( ) ) ) { m_ComboPlayer2Colour . setSelectedItem ( "Yellow" ) ; } else if ( "Yellow" . equals ( m_ComboPlayer1Colour . getSelectedItem ( ) ) ) { m_ComboPlayer2Colour . setSelectedItem ( "Red" ) ; } else if ( "Black" . equals ( m_ComboPlayer1Colour . getSelectedItem ( ) ) ) { m_ComboPlayer2Colour . setSelectedItem ( "White" ) ; } else if ( "White" . equals ( m_ComboPlayer1Colour . getSelectedItem ( ) ) ) { m_ComboPlayer2Colour . setSelectedItem ( "Black" ) ; } } } ) ; m_ComboPlayer2Colour . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { if ( "Red" . equals ( m_ComboPlayer2Colour . getSelectedItem ( ) ) ) { m_ComboPlayer1Colour . setSelectedItem ( "Yellow" ) ; } else if ( "Yellow" . equals ( m_ComboPlayer2Colour . getSelectedItem ( ) ) ) { m_ComboPlayer1Colour . setSelectedItem ( "Red" ) ; } else if ( "Black" . equals ( m_ComboPlayer2Colour . getSelectedItem ( ) ) ) { m_ComboPlayer1Colour . setSelectedItem ( "White" ) ; } else if ( "White" . equals ( m_ComboPlayer2Colour . getSelectedItem ( ) ) ) { m_ComboPlayer1Colour . setSelectedItem ( "Black" ) ; } } } ) ; m_InputScreen = new JPanel ( new GridBagLayout ( ) ) ; m_InputLabel = new JLabel ( "Player Setup" ) ; m_InputLabel . setFont ( new Font ( "SansSerif" , Font . PLAIN , SECONDHEAD_FONTSIZE ) ) ; m_Player1Label = new JLabel ( "Player 1 details" ) ; m_Player1Label . setFont ( new Font ( "SansSerif" , Font . ITALIC , SMALLHEADING_FONTSIZE ) ) ; m_Player2Label = new JLabel ( "Player 2 details" ) ; m_Player2Label . setFont ( new Font ( "SansSerif" , Font . ITALIC , SMALLHEADING_FONTSIZE ) ) ; m_Player1TypeLabel = new JLabel ( "Player type:" ) ; m_Player2TypeLabel = new JLabel ( "Player type:" ) ; m_Player1ColourLabel = new JLabel ( "Player's colour:" ) ; m_Player2ColourLabel = new JLabel ( "Player's colour:" ) ; m_PlayerOK = new JButton ( "OK" ) ; m_PlayerBack = new JButton ( "Cancel" ) ; m_LoadButton = new JButton ( "Load Previous Game" ) ; m_PlayInputOne = new JTextField ( "Player One" , TEXTFIELD_COLUMNS ) ; m_PlayInputOne . setFont ( new Font ( "SansSerif" , Font . PLAIN , SUBHEADING_FONTSIZE ) ) ; m_PlayInputTwo = new JTextField ( "Player Two" , TEXTFIELD_COLUMNS ) ; m_PlayInputTwo . setFont ( new Font ( "SansSerif" , Font . PLAIN , SUBHEADING_FONTSIZE ) ) ; GridBagConstraints MainPanel = new GridBagConstraints ( ) ; GUIEventHandler handler = new GUIEventHandler ( ) ; InputEventHandler check = new InputEventHandler ( ) ; JPanel inputPanel = new JPanel ( new GridBagLayout ( ) ) ; GridBagConstraints input = new GridBagConstraints ( ) ; input . fill = GridBagConstraints . HORIZONTAL ; input . gridx = COLUMN_ONE ; input . gridy = ROW_ONE ; input . insets = new Insets ( GAP_TWENTY , GAP_TWENTY , NO_GAP , GAP_SIXTY ) ; inputPanel . add ( m_InputLabel , input ) ; input . fill = GridBagConstraints . HORIZONTAL ; input . gridx = COLUMN_TWO ; input . gridy = ROW_ONE ; input . insets = new Insets ( GAP_TWENTY , NO_GAP , NO_GAP , GAP_ONE_HUNDRED_TWENTY ) ; inputPanel . add ( m_LoadButton , input ) ; input . fill = GridBagConstraints . HORIZONTAL ; input . gridx = COLUMN_ONE ; input . gridy = ROW_TWO ; input . insets = new Insets ( GAP_TWENTY , GAP_TWENTY , NO_GAP , GAP_SIXTY ) ; inputPanel . add ( m_Player1Label , input ) ; input . fill = GridBagConstraints . HORIZONTAL ; input . gridx = COLUMN_TWO ; input . gridy = ROW_TWO ; input . insets = new Insets ( GAP_TWENTY , GAP_TEN , NO_GAP , GAP_SIXTY ) ; inputPanel . add ( m_Player2Label , input ) ; input . fill = GridBagConstraints . HORIZONTAL ; input . gridx = COLUMN_ONE ; input . gridy = ROW_FOUR ; input . insets = new Insets ( GAP_FIFTY , GAP_TWENTY , NO_GAP , GAP_ONE_HUNDRED_TWENTY ) ; inputPanel . add ( m_ComboPlayer1Type , input ) ; input . fill = GridBagConstraints . HORIZONTAL ; input . gridx = COLUMN_ONE ; input . gridy = ROW_FOUR ; input . insets = new Insets ( NO_GAP , GAP_TWENTY , NO_GAP , GAP_ONE_HUNDRED_TWENTY ) ; inputPanel . add ( m_Player1TypeLabel , input ) ; input . fill = GridBagConstraints . HORIZONTAL ; input . gridx = COLUMN_TWO ; input . gridy = ROW_FOUR ; input . insets = new Insets ( GAP_FIFTY , GAP_TEN , NO_GAP , GAP_ONE_HUNDRED_TWENTY ) ; inputPanel . add ( m_ComboPlayer2Type , input ) ; input . fill = GridBagConstraints . HORIZONTAL ; input . gridx = COLUMN_TWO ; input . gridy = ROW_FOUR ; input . insets = new Insets ( NO_GAP , GAP_TEN , NO_GAP , GAP_ONE_HUNDRED_TWENTY ) ; inputPanel . add ( m_Player2TypeLabel , input ) ; input . fill = GridBagConstraints . HORIZONTAL ; input . gridx = COLUMN_ONE ; input . gridy = ROW_THREE ; input . insets = new Insets ( GAP_TWENTY , GAP_TWENTY , NO_GAP , GAP_ONE_HUNDRED ) ; inputPanel . add ( m_PlayInputOne , input ) ; input . fill = GridBagConstraints . HORIZONTAL ; input . gridx = COLUMN_TWO ; input . gridy = ROW_THREE ; input . insets = new Insets ( GAP_TWENTY , GAP_TEN , NO_GAP , GAP_ONE_HUNDRED ) ; inputPanel . add ( m_PlayInputTwo , input ) ; input . fill = GridBagConstraints . HORIZONTAL ; input . gridx = COLUMN_ONE ; input . gridy = ROW_FIVE ; input . insets = new Insets ( GAP_FIFTY , GAP_TWENTY , NO_GAP , GAP_ONE_HUNDRED_TWENTY ) ; inputPanel . add ( m_ComboPlayer1Colour , input ) ; input . fill = GridBagConstraints . HORIZONTAL ; input . gridx = COLUMN_ONE ; input . gridy = ROW_FIVE ; input . insets = new Insets ( NO_GAP , GAP_TWENTY , NO_GAP , GAP_ONE_HUNDRED_TWENTY ) ; inputPanel . add ( m_Player1ColourLabel , input ) ; input . fill = GridBagConstraints . HORIZONTAL ; input . gridx = COLUMN_TWO ; input . gridy = ROW_FIVE ; input . insets = new Insets ( GAP_FIFTY , GAP_TEN , NO_GAP , GAP_ONE_HUNDRED_TWENTY ) ; inputPanel . add ( m_ComboPlayer2Colour , input ) ; input . fill = GridBagConstraints . HORIZONTAL ; input . gridx = COLUMN_TWO ; input . gridy = ROW_FIVE ; input . insets = new Insets ( NO_GAP , GAP_TEN , NO_GAP , GAP_ONE_HUNDRED_TWENTY ) ; inputPanel . add ( m_Player2ColourLabel , input ) ; JPanel confirmPanel = new JPanel ( new GridBagLayout ( ) ) ; GridBagConstraints confirm = new GridBagConstraints ( ) ; confirm . fill = GridBagConstraints . HORIZONTAL ; confirm . gridx = COLUMN_ONE ; confirm . gridy = ROW_ONE ; confirm . insets = new Insets ( GAP_FIFTEEN , NO_GAP , NO_GAP , GAP_TWENTY ) ; confirmPanel . add ( m_PlayerBack , confirm ) ; confirm . fill = GridBagConstraints . HORIZONTAL ; confirm . gridx = COLUMN_TWO ; confirm . gridy = ROW_ONE ; confirm . insets = new Insets ( GAP_FIFTEEN , NO_GAP , NO_GAP , NO_GAP ) ; confirmPanel . add ( m_PlayerOK , confirm ) ; MainPanel . insets = new Insets ( GAP_TEN , NO_GAP , NO_GAP , NO_GAP ) ; MainPanel . gridx = COLUMN_ONE ; MainPanel . gridy = ROW_ONE ; m_InputScreen . add ( inputPanel , MainPanel ) ; MainPanel . gridx = COLUMN_ONE ; MainPanel . gridy = ROW_TWO ; m_InputScreen . add ( confirmPanel , MainPanel ) ; m_PlayerOK . addActionListener ( handler ) ; m_PlayerBack . addActionListener ( handler ) ; m_LoadButton . addActionListener ( handler ) ; m_PlayInputOne . addKeyListener ( check ) ; m_PlayInputTwo . addKeyListener ( check ) ; return true ; }
tr	6	protected void sendRequest ( StatesOfClient state ) { resetState ( ) ; setState ( state ) ; pmfc . printWhichStateIsTesting ( ) ; try { if ( CURL_HTTP_PORT != 443 ) { client = vertx . createHttpClient ( ) . setPort ( CURL_HTTP_PORT ) . setHost ( CURL_HTTP_HOST ) ; } else { client = vertx . createHttpClient ( ) . setSSL ( true ) . setTrustAll ( true ) . setPort ( CURL_HTTP_PORT ) . setHost ( CURL_HTTP_HOST ) ; } mCurlCommandsSetter = mCurlCommandsSetterFactory . createSetter ( getState ( ) ) ; mCurlCommandsSetter . execute ( state ) ; pmfc . printCurrentRequestAndPathInCurlCommand ( ) ; requestSendFromClienttoServer = client . request ( BehaviorOfCurlCommandsSetter . currentRequest , BehaviorOfCurlCommandsSetter . currentPath , new Handler < HttpClientResponse > ( ) { @ Override public void handle ( HttpClientResponse responseRecievedAtClientFromServer ) { statusCode = responseRecievedAtClientFromServer . statusCode ( ) ; responseRecievedAtClientFromServer . bodyHandler ( new Handler < Buffer > ( ) { @ Override public void handle ( Buffer body ) { try { try { pmfc . printMessageFromServer ( body ) ; currentServerResponseInJsonFormat = new JsonObject ( body . toString ( ) ) ; getDataFromDB ( ) ; } catch ( Exception e ) { } mAssertionChecker = mAssertionCheckerFactory . createChecker ( getState ( ) ) ; mAssertionChecker . execute ( getState ( ) ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { pmfc . printEnd ( ) ; testComplete ( ) ; } } } ) ; } } ) . exceptionHandler ( new Handler < Throwable > ( ) { @ Override public void handle ( Throwable t ) { t . printStackTrace ( ) ; } } ) ; try { headersSetUp ( ) ; jsonBodySetUp ( ) ; } catch ( Exception e ) { } } catch ( Exception e ) { fail ( e . getMessage ( ) ) ; } finally { if ( client != null ) { client . close ( ) ; } } }
tr	4	private Node < V > addNextLessGreater ( Node < V > node , char c ) { while ( node . letter != c ) { if ( c < node . letter ) { if ( node . less == null ) { node . less = new Node < V > ( c ) ; return node . less ; } node = node . less ; } else { if ( node . greater == null ) { node . greater = new Node < V > ( c ) ; return node . greater ; } node = node . greater ; } } return node ; }
tr	0	private static void writeFile ( File destFile , String content ) throws IOException { BufferedWriter writer = new BufferedWriter ( new FileWriter ( destFile ) ) ; writer . write ( content ) ; writer . flush ( ) ; writer . close ( ) ; writer = null ; }
tr	7	public static int commonAuto ( MatchData match ) { int two , four , six ; two = four = six = 0 ; for ( Points p : match . getPoints ( ) ) { if ( p instanceof TwoPointAuto ) { two ++ ; } else if ( p instanceof FourPointAuto ) { four ++ ; } else if ( p instanceof SixPointAuto ) { six ++ ; } } int max = Math . max ( two , Math . max ( four , six ) ) ; return max == six ? 6 : ( max == four ? 4 : ( max == two ? 2 : 0 ) ) ; }
tr	6	public MainFrame ( ) { initComponents ( ) ; preferences = Preferences . userRoot ( ) . node ( this . getClass ( ) . getName ( ) ) ; final String pathToPDFLaTeXFile = preferences . get ( "pathToPDFLaTeXFile" , null ) ; final String pathToPDFExportFolder = preferences . get ( "pathToPDFExportFolder" , null ) ; if ( ( pathToPDFLaTeXFile == null ) || ( pathToPDFExportFolder == null ) ) Config . initPreferences ( preferences ) ; if ( ( pathToPDFLaTeXFile != null ) && ( ! pathToPDFLaTeXFile . equals ( Config . default ) ) ) Config . setPDFLaTeXFile ( new File ( pathToPDFLaTeXFile ) ) ; if ( ( pathToPDFExportFolder != null ) && ( ! pathToPDFExportFolder . equals ( Config . default ) ) ) Config . setPDFExportFolder ( new File ( pathToPDFExportFolder ) ) ; parameterLabelArray = new javax . swing . JLabel [ ] { parameter1Label , parameter2Label , parameter3Label , parameter4Label } ; parameterArray = new javax . swing . JTextField [ ] { parameter1 , parameter2 , parameter3 , parameter4 } ; problemPartComponentsArray = new JComponent [ ] { userAnswerField , checkButton , showSolutionLaTeXButton , showSolutionPlaintextButton , copyToClipboardButton , exportToPDFButton , resetButton } ; }
tr	3	private void phyRxInvActionPerformed ( java . awt . event . ActionEvent evt ) { try { int value ; if ( phyRxInv . isSelected ( ) ) { value = 1 ; } else { value = 0 ; } snmp . snmpSetInteger ( "250" , value ) ; } catch ( Exception ex ) { } try { phyRxInv . setSelected ( snmp . snmpGetInteger ( "250" ) == 1 ) ; } catch ( Exception ex ) { Logger . getLogger ( UP4DAR_Configurator . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } }
tr	5	ComplexNumberNode parseComplex ( SeekableStringReader sr ) { if ( sr . peek ( ) == ( ) { sr . read ( ) ; String numberstr ; if ( sr . peek ( ) == - || sr . peek ( ) == + ) { numberstr = sr . read ( 1 ) + sr . readUntil ( "+-" ) ; } else numberstr = sr . readUntil ( "+-" ) ; double real ; try { real = double . parseDouble ( numberstr ) ; } catch ( NumberFormatException x ) { throw new ParseException ( "invalid float format" , x ) ; } sr . rewind ( 1 ) ; double imaginarypart = parseImaginaryPart ( sr ) ; if ( sr . read ( ) != ) ) throw new ParseException ( "expected ) to end a complex number" ) ; ComplexNumberNode c = new ComplexNumberNode ( ) ; c . real = real ; c . imaginary = imaginarypart ; return c ; } else { double imag = parseImaginaryPart ( sr ) ; ComplexNumberNode c = new ComplexNumberNode ( ) ; c . real = 0 ; c . imaginary = imag ; return c ; } }
tr	7	public void handleDeletedFiles ( ) { Iterator < Path > itrd = deletedFiles . iterator ( ) ; Iterator < Path > itrc = null ; Iterator < Path > itrm = null ; Iterator < RenamedFile > itrr = null ; RenamedFile toRename ; Path pathm , pathc , pathd ; logger . debug ( "Handle Deleted Files has started." ) ; while ( itrd . hasNext ( ) ) { pathd = itrd . next ( ) ; itrc = createdFiles . iterator ( ) ; itrm = modifiedFiles . iterator ( ) ; itrr = renamedFiles . iterator ( ) ; while ( itrc . hasNext ( ) ) { pathc = itrc . next ( ) ; if ( pathd . equals ( pathc ) ) { itrc . remove ( ) ; } } while ( itrm . hasNext ( ) ) { pathm = itrm . next ( ) ; if ( pathd . equals ( pathm ) ) { itrm . remove ( ) ; } } while ( itrr . hasNext ( ) ) { toRename = itrr . next ( ) ; if ( pathd . equals ( toRename . oldName ) ) { itrr . remove ( ) ; } } itrd . remove ( ) ; } }
tr	6	public Map < String , String > readAdjNounSent ( ) { PropertyConfigurator . configure ( "conf/log4j.properties" ) ; Logger myLogger = Logger . getLogger ( "unsupervisedClauseMarkup.readAdjNounSent" ) ; if ( this . myDataHolder == null ) { return null ; } Map < String , String > myAdjNounSent = new HashMap < String , String > ( ) ; Iterator < SentenceStructure > iter = this . myDataHolder . getSentenceHolder ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { SentenceStructure sentenceObject = iter . next ( ) ; String modifier = sentenceObject . getModifier ( ) ; String tag = sentenceObject . getTag ( ) ; myLogger . trace ( "tag: " + tag ) ; if ( ( modifier != null ) && ( tag != null ) ) { if ( ( ! ( modifier . equals ( "" ) ) ) && ( tag . matches ( "^\\[.*$" ) ) ) { modifier = modifier . replaceAll ( "\\[.*?\\]" , "" ) . trim ( ) ; myAdjNounSent . put ( tag , modifier ) ; } } } return myAdjNounSent ; }
tr	8	public static String encode ( String value ) { String encoded = null ; try { encoded = URLEncoder . encode ( value , "UTF-8" ) ; } catch ( UnsupportedEncodingException ignore ) { } StringBuffer buf = new StringBuffer ( encoded . length ( ) ) ; char focus ; for ( int i = 0 ; i < encoded . length ( ) ; i ++ ) { focus = encoded . charAt ( i ) ; if ( focus == * ) { buf . append ( "%2A" ) ; } else if ( focus == + ) { buf . append ( "%20" ) ; } else if ( focus == % && ( i + 1 ) < encoded . length ( ) && encoded . charAt ( i + 1 ) == 7 && encoded . charAt ( i + 2 ) == E ) { buf . append ( ~ ) ; i += 2 ; } else { buf . append ( focus ) ; } } return buf . toString ( ) ; }
tr	6	public int [ ] getClosestClusters ( ) { int [ ] arr = new int [ 2 ] ; arr [ 0 ] = 0 ; arr [ 1 ] = 0 ; double largestSimilarity = - 100 ; for ( int i = 0 ; i < numberOfDocuments ; i ++ ) { for ( int j = 0 ; j < numberOfDocuments ; j ++ ) { if ( i >= j || ! clustersExists . get ( i ) || ! clustersExists . get ( j ) ) continue ; if ( similairtyMatrix [ i ] [ j ] > largestSimilarity ) { arr [ 0 ] = i ; arr [ 1 ] = j ; largestSimilarity = similairtyMatrix [ i ] [ j ] ; } } } return arr ; }
tr	3	public String [ ] adjudicate ( final int lineNumber , final String orig , final String [ ] hdr , final String [ ] flds ) { final int n = hdr . length ; String [ ] res = new String [ n ] ; for ( int i = 0 ; ( i < flds . length ) && ( i < n ) ; ++ i ) { res [ i ] = flds [ i ] ; } for ( int i = flds . length ; i < n ; ++ i ) { res [ i ] = "" ; } return res ; }
tr	0	public int getHeight ( int layer ) { return layers . get ( layer ) . getHeight ( ) ; }
tr	6	public OptionsPanel getOptionsPanel ( ) { if ( mediaPanel . hasFinished ( ) ) createMedia ( ) ; if ( type . equals ( "plain" ) ) { HashMap < String , String > text = new HashMap < String , String > ( ) ; text . put ( "frage" , title ) ; optionsPanel = new OptionsPanel ( text , mediaPanel ) ; } else if ( type . equals ( "mchoice" ) || type . equals ( "mchoice-img" ) || type . equals ( "mchoice_img" ) ) { String [ ] split = answers . split ( ";" ) ; MultipleChoicePanel panel = new MultipleChoicePanel ( split , mcfont ) ; HashMap < String , String > text = new HashMap < String , String > ( ) ; text . put ( "frage" , title ) ; optionsPanel = new OptionsPanel ( text , panel , mediaPanel ) ; } else if ( type . equals ( "list" ) ) { HashMap < String , String > text = new HashMap < String , String > ( ) ; text . put ( "frage" , title ) ; String [ ] valueArray = values . split ( ";" ) ; String [ ] answerArray = answers . split ( ";" ) ; System . out . println ( "Create Optionspanel list" ) ; optionsPanel = new OptionsPanel ( text , answerArray , valueArray ) ; } else { System . out . println ( "failed to read file" ) ; System . exit ( 0 ) ; } return optionsPanel ; }
tr	2	private void buildPanel ( ) { this . setBorder ( new EmptyBorder ( this . innerMargin , this . innerMargin , this . innerMargin , this . innerMargin ) ) ; this . setLayout ( new BorderLayout ( ) ) ; if ( label != null && ! label . isEmpty ( ) ) { JPanel labelPanel = new JPanel ( ) ; labelPanel . setLayout ( new FlowLayout ( ) ) ; labelPanel . add ( new JLabel ( label ) ) ; this . add ( labelPanel , BorderLayout . NORTH ) ; } this . listModel = new DefaultListModel < String > ( ) ; this . addNamesToList ( this . names ) ; this . namesListBox = new JList < String > ( this . listModel ) ; this . namesListBox . setSelectionMode ( ListSelectionModel . MULTIPLE_INTERVAL_SELECTION ) ; this . namesListBox . setLayoutOrientation ( JList . VERTICAL ) ; JScrollPane listScroller = new JScrollPane ( this . namesListBox ) ; listScroller . setPreferredSize ( new Dimension ( 200 , 200 ) ) ; this . add ( listScroller , BorderLayout . CENTER ) ; }
tr	5	public int hitTest ( int x , int y ) { if ( y > SPACE && y < SPACE + ITEM_HEIGHT ) { int t = x - startLeft ; if ( t > 0 && ( t % ( ITEM_WIDTH + SPACE_WIDTH ) < ITEM_WIDTH ) ) { int index = t / ( ITEM_WIDTH + SPACE_WIDTH ) ; if ( index < CableBattle . propsBar . list . size ( ) ) { return index ; } } } return - 1 ; }
tr	2	static List < VcsCommit > parseCommits ( String xml ) { try { CommitReadingHandler commitReadingHandler = new CommitReadingHandler ( ) ; SAXParserFactory parserFactory = SAXParserFactory . newInstance ( ) ; XMLReader xmlReader = parserFactory . newSAXParser ( ) . getXMLReader ( ) ; xmlReader . setContentHandler ( commitReadingHandler ) ; xmlReader . parse ( new InputSource ( new StringReader ( xml ) ) ) ; return commitReadingHandler . commits ; } catch ( SAXException e ) { throw new RuntimeException ( "Failed to parse xml: " + xml , e ) ; } catch ( ParserConfigurationException | IOException e ) { throw new RuntimeException ( e ) ; } }
tr	4	public String getColumnName ( int c ) { switch ( c ) { case COL_RANK : return "#" ; case COL_NAME : return "Name" ; case COL_PRESENT : return "Present" ; case COL_BIDS : return "Bids" ; default : return "" ; } }
tr	8	public static List < String > getAlbumsImages ( String link ) { List < String > dataSets = new ArrayList < String > ( ) ; link = link . replace ( "http://tu.duowan.com/g/" , "" ) . replace ( ".html" , "" ) . replace ( "/" , "" ) ; int num = - 1 ; try { num = Integer . parseInt ( link , 16 ) ; } catch ( Exception e ) { } if ( num == - 1 ) { return dataSets ; } String srollUrl = "http://tu.duowan.com/scroll/" + num + ".html" ; Document doc = ConnUtil . getHtmlDocument ( srollUrl ) ; if ( doc == null ) { return dataSets ; } loadPage ( doc , dataSets ) ; Elements pages = doc . select ( "div.mod-page" ) ; if ( pages != null && pages . size ( ) > 0 ) { showMsg ( pages . toString ( ) ) ; for ( Element el : pages ) { Elements pageLinks = el . select ( "a" ) ; for ( int i = 1 ; i < pageLinks . size ( ) ; i ++ ) { String pageUrl = pageLinks . get ( i ) . attr ( "href" ) ; srollUrl = "http://tu.duowan.com/" + pageUrl ; Document pagedoc = ConnUtil . getHtmlDocument ( srollUrl ) ; if ( pagedoc != null ) { loadPage ( pagedoc , dataSets ) ; } } } } showMsg ( "size" + dataSets . size ( ) ) ; return dataSets ; }
tr	0	public Browser ( TreeBrowser br , int x , int y ) { super ( "CLASBrowser" ) ; this . setSize ( 1000 , 700 ) ; this . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; this . initComponents ( x , y ) ; this . setTreeBrowser ( br ) ; this . pack ( ) ; this . setVisible ( true ) ; }
tr	1	public int getInt ( String propertyName , int defaultValue ) { CcsProperty property = getProperty ( propertyName ) ; int result = property == null ? defaultValue : Integer . parseInt ( property . getValue ( ) ) ; return result ; }
tr	7	private Object getValeur ( int index , String nom ) throws Exception { Object res ; JComponent champ = listeChamps . get ( nom ) ; int type = listeAttributs . get ( index ) . getType ( ) ; try { switch ( type ) { case Constantes . INTEGER : res = strToInt ( ( ( JTextField ) champ ) . getText ( ) ) ; break ; case Constantes . double : res = strToDouble ( ( ( JTextField ) champ ) . getText ( ) ) ; break ; case Constantes . STRING : res = strToStr ( ( ( JTextField ) champ ) . getText ( ) ) ; break ; case Constantes . boolean : res = ( ( JCheckBox ) champ ) . isSelected ( ) ; break ; default : res = null ; } } catch ( Exception e ) { e . printStackTrace ( ) ; throw new Exception ( Langue . getTraduction ( "fields_not_filled" ) ) ; } if ( res instanceof String && res . equals ( "" ) ) { throw new Exception ( Langue . getTraduction ( "fields_not_filled" ) ) ; } return res ; }
tr	9	@ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; SchoolYear other = ( SchoolYear ) obj ; if ( end == null ) { if ( other . end != null ) return false ; } else if ( ! end . equals ( other . end ) ) return false ; if ( name == null ) { if ( other . name != null ) return false ; } else if ( ! name . equals ( other . name ) ) return false ; if ( start == null ) { if ( other . start != null ) return false ; } else if ( ! start . equals ( other . start ) ) return false ; return true ; }
tr	9	private String internalReadChunkedString ( int length ) throws IOException { StringBuffer buf = internalReadString ( length ) ; boolean done = false ; while ( ! done ) { int code = readNextCode ( ) ; switch ( code ) { case Codes . STRING_PACKED_LENGTH_START + 0 : case Codes . STRING_PACKED_LENGTH_START + 1 : case Codes . STRING_PACKED_LENGTH_START + 2 : case Codes . STRING_PACKED_LENGTH_START + 3 : case Codes . STRING_PACKED_LENGTH_START + 4 : case Codes . STRING_PACKED_LENGTH_START + 5 : case Codes . STRING_PACKED_LENGTH_START + 6 : case Codes . STRING_PACKED_LENGTH_START + 7 : internalReadStringBuffer ( buf , code - Codes . STRING_PACKED_LENGTH_START ) . toString ( ) ; done = true ; break ; case Codes . STRING : internalReadStringBuffer ( buf , readCount ( ) ) ; done = true ; break ; case Codes . STRING_CHUNK : internalReadStringBuffer ( buf , readCount ( ) ) ; break ; default : throw expected ( "chunked string" , code ) ; } } return buf . toString ( ) ; }
tr	7	public boolean isSolid ( int x , int y ) { if ( x < 0 || y < 0 || x >= surface . length || y >= surface . length ) return true ; if ( surface [ x ] [ y ] . isSolid ( ) ) return true ; for ( Entity e : entities ) { if ( e . isSolid ( x , y ) ) return true ; } return false ; }
tr	5	@ Override public boolean equals ( Object object ) { if ( ! ( object instanceof ProjectUser ) ) { return false ; } ProjectUser other = ( ProjectUser ) object ; if ( ( this . projectUserPK == null && other . projectUserPK != null ) || ( this . projectUserPK != null && ! this . projectUserPK . equals ( other . projectUserPK ) ) ) { return false ; } return true ; }
tr	9	@ Override public void train ( ) { int N = getTrainSet ( ) . getDistribution ( ) . length ; memories = new Memory [ N ] ; Map < Integer , Set < Pattern >> classes = new HashMap < Integer , Set < Pattern >> ( ) ; for ( Pattern instance : getTrainSet ( ) ) { Set < Pattern > partition = classes . containsKey ( instance . getClassIndex ( ) ) ? classes . get ( instance . getClassIndex ( ) ) : new HashSet < Pattern > ( ) ; partition . add ( instance ) ; classes . put ( instance . getClassIndex ( ) , partition ) ; } for ( Integer clazz : classes . keySet ( ) ) { Set < Pattern > partition = classes . get ( clazz ) ; int R = getTrainSet ( ) . getAttributes ( ) . size ( ) ; double M [ ] [ ] = new double [ R ] [ R ] ; int index = 0 ; for ( Pattern pattern : partition ) { if ( index == 0 ) { M [ index ++ ] = pattern . toDoubleVector ( ) ; } else { if ( index < R ) { boolean si = true ; for ( int j = 0 ; j < index ; j ++ ) { if ( similitud ( M [ j ] , pattern . toDoubleVector ( ) ) > 7 ) si = false ; } if ( si ) M [ index ++ ] = pattern . toDoubleVector ( ) ; } } } memories [ clazz ] = new Memory ( clazz , Matrix . trans ( M ) ) ; } for ( Memory memory : memories ) { Matrix . print ( memory . getM ( ) ) ; } }
tr	4	public void meta ( MetaMessage event ) { if ( event . getType ( ) == END_OF_TRACK_MESSAGE ) { if ( sequencer != null && sequencer . isOpen ( ) && loop ) { sequencer . setTickPosition ( 0 ) ; sequencer . start ( ) ; } } }
tr	9	public void handleData ( int [ ] data ) { if ( data . length == 0 ) { return ; } for ( int i = 0 ; i < data . length ; i ++ ) { if ( data [ i ] == START_UPDATE_MOVEABLE ) { for ( int j = i ; j < data . length ; j ++ ) { if ( data [ j ] == END_UPDATE_MOVEABLE ) { int length = j - i ; if ( length != 3 ) { throw new RuntimeException ( "Invalid formatted data. Update moveable data not correct" ) ; } else { updateMoveable ( data [ i + 1 ] , data [ i + 2 ] ) ; } i = j ; break ; } } } else if ( data [ i ] == START_DROP_BOMB ) { for ( int j = i ; j < data . length ; j ++ ) { if ( data [ j ] == END_DROP_BOMB ) { int length = j - i ; if ( length != 5 ) { throw new RuntimeException ( "Invalid formatted data. Drop bomb data not correct: " + length ) ; } else { addBomb ( data [ i + 1 ] , data [ i + 2 ] , data [ i + 3 ] , data [ i + 4 ] ) ; } i = j ; break ; } } } } }
tr	4	@ Override public void collidedWith ( Entity other ) { if ( other instanceof UnbreakableEntity ) { setHorizontalSpeedMovement ( 0 ) ; setVerticalSpeedMovement ( 0 ) ; } else if ( other instanceof BreakableEntity ) { setHorizontalSpeedMovement ( 0 ) ; setVerticalSpeedMovement ( 0 ) ; } else if ( other instanceof BombeEntity ) { setHorizontalSpeedMovement ( 0 ) ; setVerticalSpeedMovement ( 0 ) ; } else if ( other instanceof ExplosionEntity ) { this . state = STATE . DEAD ; } else { this . setHorizontalSpeedMovement ( 1 ) ; this . setVerticalSpeedMovement ( 1 ) ; } }
tr	2	private static int getNumUniqueValues ( ) { String [ ] values = new String [ strs . length ] ; int count = 0 ; for ( int j = 0 ; j < strs . length ; j ++ ) { if ( ! containsValue ( values , strs [ j ] ) ) values [ count ++ ] = strs [ j ] ; } return count ; }
tr	2	public JSONArray ( Object array ) throws JSONException { this ( ) ; if ( array . getClass ( ) . isArray ( ) ) { int length = Array . getLength ( array ) ; for ( int i = 0 ; i < length ; i += 1 ) { this . put ( JSONObject . wrap ( Array . get ( array , i ) ) ) ; } } else { throw new JSONException ( "JSONArray initial value should be a string or collection or array." ) ; } }
tr	6	private boolean dijkstra ( V s , V g ) { if ( s == null ) { return false ; } initTable ( ) ; List < V > candidates = new ArrayList < V > ( ) ; distance . put ( s , 0.0 ) ; candidates . add ( s ) ; while ( ! candidates . isEmpty ( ) ) { V v = getMinVertex ( candidates ) ; candidates . remove ( v ) ; if ( v == g ) { return true ; } for ( V w : graph . getAdjacentVertexList ( v ) ) { if ( double . isInfinite ( distance . get ( w ) ) ) { candidates . add ( w ) ; } if ( ( distance . get ( v ) + graph . getWeight ( v , w ) ) < distance . get ( w ) . doubleValue ( ) ) { prevVertex . put ( w , v ) ; distance . put ( w , distance . get ( v ) + graph . getWeight ( v , w ) ) ; } } } startVertex = s ; return true ; }
tr	3	public int signum ( ) { if ( bigVal != null ) { return bigVal . signum ( ) ; } else { return val > 0 ? 1 : val < 0 ? - 1 : 0 ; } }
tr	8	@ Test public void drawLineVerticalWidth ( ) { Whiteboard wb = new Whiteboard ( ) ; Color newColor = new Color ( 100 , 2 , 50 ) ; Color white = new Color ( ) ; ArrayList < Point > expectedPoints = new ArrayList < Point > ( ) ; for ( int i = 299 ; i < 302 ; i ++ ) { for ( int j = 199 ; j < 502 ; j ++ ) { expectedPoints . add ( new Point ( i , j ) ) ; } } ArrayList < Point > modifiedPoints = new ArrayList < Point > ( wb . drawLine ( new Point ( 300 , 200 ) , new Point ( 300 , 500 ) , newColor , 3 ) ) ; for ( int i = 0 ; i < Whiteboard . WIDTH ; i ++ ) { for ( int j = 0 ; j < Whiteboard . HEIGHT ; j ++ ) { Point p = new Point ( i , j ) ; if ( ( i >= 299 && i <= 301 ) && j >= 199 && j <= 501 ) { assertEquals ( true , wb . getPixel ( p ) . equals ( newColor ) ) ; } else { assertEquals ( true , wb . getPixel ( p ) . equals ( white ) ) ; } } } testArraysEqual ( expectedPoints , modifiedPoints ) ; }
tr	7	void removeDev ( DeviceImpl dev ) { synchronized ( devices ) { DeviceImpl d = devices [ dev . getAddress ( ) - 1 ] ; int i ; if ( d == null || d != dev ) return ; i = d . getAddress ( ) - 1 ; devices [ i ] = null ; if ( root == i ) { root = - 1 ; if ( Windows . trace ) System . err . println ( "bus root hub removed!" ) ; if ( Windows . debug ) { for ( i = 0 ; i < 127 ; i ++ ) { if ( devices [ i ] != null ) System . err . println ( "? addr " + ( i + 1 ) + " present with no root ?" ) ; } } } } }
tr	1	public void saveLang ( ) { try { lang . save ( langFile ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }
tr	8	private void updateFacingDirection ( Entity entity ) { if ( entity . tickEnd == tick || entity . animation == - 1 || entity . animationDelay != 0 || entity . currentAnimationDuration + 1 > AnimationSequence . animations [ entity . animation ] . getFrameLength ( entity . currentAnimationFrame ) ) { int duration = entity . tickEnd - entity . tickStart ; int timePassed = tick - entity . tickStart ; int differenceStartX = entity . startX * 128 + entity . boundaryDimension * 64 ; int differenceStartY = entity . startY * 128 + entity . boundaryDimension * 64 ; int differenceEndX = entity . endX * 128 + entity . boundaryDimension * 64 ; int differenceEndY = entity . endY * 128 + entity . boundaryDimension * 64 ; entity . x = ( differenceStartX * ( duration - timePassed ) + differenceEndX * timePassed ) / duration ; entity . y = ( differenceStartY * ( duration - timePassed ) + differenceEndY * timePassed ) / duration ; } entity . stepsDelayed = 0 ; if ( entity . direction == 0 ) entity . turnDirection = 1024 ; if ( entity . direction == 1 ) entity . turnDirection = 1536 ; if ( entity . direction == 2 ) entity . turnDirection = 0 ; if ( entity . direction == 3 ) entity . turnDirection = 512 ; entity . currentRotation = entity . turnDirection ; }
tr	2	@ Override public int hashCode ( ) { int result = action != null ? action . hashCode ( ) : 0 ; result = 31 * result + ( state != null ? state . hashCode ( ) : 0 ) ; return result ; }
tr	8	protected void encodeDocumentType ( DocumentType documentType ) throws IOException { alignToOctet ( ) ; current_octet |= FastInfosetConstants . DOCUMENT_TYPE_IDENTIFICATION ; boolean encodesystemid = ( documentType . systemIdentifier != null ) && ! documentType . systemIdentifier . isEmpty ( ) ; boolean encodepublicid = ( documentType . publicIdentifier != null ) && ! documentType . publicIdentifier . isEmpty ( ) ; if ( encodesystemid ) { current_octet |= FastInfosetConstants . DOCUMENT_TYPE_SYSTEMID_PRESENCE ; } if ( encodepublicid ) { current_octet |= FastInfosetConstants . DOCUMENT_TYPE_PUBLICID_PRESENCE ; } flush_currentoctet ( ) ; if ( encodesystemid ) { encodeIdentifyingStringOrIndex ( documentType . systemIdentifier , vocabulary . other_uris ) ; } if ( encodepublicid ) { encodeIdentifyingStringOrIndex ( documentType . publicIdentifier , vocabulary . other_uris ) ; } if ( documentType . instructions != null ) { for ( fastinfoset . Document . ProcessingInstruction instruction : documentType . instructions ) { encodeProcessingInstruction ( instruction . target , instruction . content ) ; } } current_octet |= FastInfosetConstants . TERMINATION_PATTERN << 4 ; }
tr	8	public static void main ( String [ ] args ) { MyStore < Integer > a = new MyStore < Integer > ( ) ; a . add ( 1 ) ; a . add ( 2 ) ; a . add ( 3 ) ; a . add ( 4 ) ; a . add ( 5 ) ; System . out . println ( "a" + a ) ; MyStore < Integer > b = new MyStore < Integer > ( ) ; b . add ( 2 ) ; b . add ( 6 ) ; System . out . println ( "b" + b ) ; int res = b . moveToMe ( a ) ; System . out . println ( "a" + a ) ; System . out . println ( "b" + b ) ; System . out . println ( res ) ; a . add ( 3 ) ; a . add ( 6 ) ; a . add ( 7 ) ; b . add ( 9 ) ; System . out . println ( "a" + a ) ; System . out . println ( "b" + b ) ; MyStore < Integer > result = b . removeAllMatching ( a ) ; System . out . println ( "a" + a ) ; System . out . println ( "b" + b ) ; System . out . println ( "res" + result ) ; MyStore < Integer > c = new MyStore < Integer > ( ) ; c . moveToMe ( b ) ; System . out . println ( "c" + c ) ; System . out . println ( "b" + b ) ; c . moveToMe ( b ) ; System . out . println ( "c" + c ) ; System . out . println ( "b" + b ) ; MyStore < Integer > d = new MyStore < Integer > ( ) ; d . add ( 1 ) ; d . add ( 2 ) ; d . add ( 3 ) ; d . add ( 4 ) ; d . add ( 5 ) ; Iterator < Integer > it = d . iterator ( ) ; while ( it . hasNext ( ) ) { if ( it . next ( ) == 3 ) { it . remove ( ) ; } } System . out . println ( "d" + d ) ; it = d . iterator ( ) ; while ( it . hasNext ( ) ) { Integer val = it . next ( ) ; if ( val == 1 ) { it . remove ( ) ; } if ( val == 2 ) { it . remove ( ) ; } if ( val == 5 ) { it . remove ( ) ; } } System . out . println ( "d" + d ) ; it = d . iterator ( ) ; while ( it . hasNext ( ) ) { if ( it . next ( ) == 4 ) { it . remove ( ) ; } } System . out . println ( "d" + d ) ; RunnableWithArgs funct = new RunnableWithArgs ( ) { @ Override public void run ( Object args ) { } } ; res = d . addAll ( c , funct ) ; System . out . println ( "d" + d ) ; System . out . println ( res ) ; res = d . addAll ( a , funct ) ; System . out . println ( "d" + d ) ; System . out . println ( res ) ; res = d . addAll ( a , funct ) ; System . out . println ( "d" + d ) ; System . out . println ( res ) ; }
tr	4	public void run ( Source user , String [ ] args ) { if ( user instanceof User && args . length >= 1 && Server . getServer ( ) . getChannelHandler ( ) . getChannel ( args [ 0 ] ) != null && Server . getServer ( ) . getChannelHandler ( ) . getChannel ( args [ 0 ] ) . getUserList ( ) . containsKey ( user ) ) { Server . getServer ( ) . getChannelHandler ( ) . getChannel ( args [ 0 ] ) . removeUser ( ( User ) user , ChannelQuitReasons . PART ) ; } }
tr	7	public void setDefaultValue ( Object defaultValue ) { if ( VALUE_NONE == ( VALUE_NONE & mode ) && null != defaultValue ) { throw new LogicException ( "Cannot set a default value when using Option.VALUE_NONE mode." ) ; } if ( isArray ( ) ) { if ( null == defaultValue ) { defaultValue = new ArrayList < Object > ( ) ; } else if ( ! ( defaultValue instanceof List || defaultValue instanceof Map ) ) { throw new LogicException ( "A default value for an array option must be an array." ) ; } } this . defaultValue = acceptValue ( ) ? defaultValue : false ; }
tr	3	public int getFibonacci ( int n ) { int i = 0 ; int j = 1 ; int fib = 0 ; while ( fib < n ) { fib = i + j ; i = j ; j = fib ; } if ( ! isPrime ( fib ) ) { while ( ! isPrime ( fib ) ) { fib = i + j ; i = j ; j = fib ; } } return fib ; }
tr	2	public void runServer ( ) throws NetworkException { try { listener = new ServerSocket ( port ) ; while ( server . isRunning ( ) ) { System . out . println ( "Waiting for clients to chat..." ) ; waitForConnection ( ) ; } } catch ( IOException e ) { throw new NetworkException ( e . getMessage ( ) ) ; } System . out . println ( "Terminando de escuchar por clientes" ) ; }
tr	8	@ Override public void paintComponent ( Graphics g ) { super . paintComponent ( g ) ; if ( yFood != null ) { { for ( int i = 0 ; i < yFood . length ; i ++ ) { drawTile ( xFood [ i ] * TILE_SIZE , yFood [ i ] * TILE_SIZE , null , g , null ) ; } } { for ( int i = 0 ; i < xpos . length ; i ++ ) { int [ ] aSnakeXPos = xpos [ i ] ; int [ ] aSnakeYPos = ypos [ i ] ; String aSnakeCol = snakeCols [ i ] ; for ( int j = 0 ; ( j < aSnakeXPos . length ) ; j ++ ) { int xPos = aSnakeXPos [ j ] ; int yPos = aSnakeYPos [ j ] ; if ( xPos == - 2 || yPos == - 2 ) { break ; } drawTile ( xPos * TILE_SIZE , yPos * TILE_SIZE , null , g , aSnakeCol ) ; } } } } g . setColor ( Color . WHITE ) ; g . drawRect ( 0 , 0 , getWidth ( ) - 1 , getHeight ( ) - 1 ) ; for ( int x = 0 ; x < COL_COUNT ; x ++ ) { for ( int y = 0 ; y < ROW_COUNT ; y ++ ) { g . drawLine ( x * TILE_SIZE , 0 , x * TILE_SIZE , getHeight ( ) ) ; g . drawLine ( 0 , y * TILE_SIZE , getWidth ( ) , y * TILE_SIZE ) ; } } }
tr	5	private List < View > getFocusableSiblings ( ) { List < View > focusableSiblings = new ArrayList < View > ( ) ; int level = viewCollection . getLevel ( focusedView ) ; View parent = focusedView . getParent ( ) ; Collection < View > viewsAtLevel = viewCollection . getViewsAtLevel ( level ) ; for ( View levelView : viewsAtLevel ) { if ( levelView . isFocusable ( ) ) { View levelViewParent = levelView . getParent ( ) ; if ( parent == null ) { if ( levelViewParent == null ) { focusableSiblings . add ( levelView ) ; } } else { if ( parent . getId ( ) . equals ( levelViewParent . getId ( ) ) ) { focusableSiblings . add ( levelView ) ; } } } } return focusableSiblings ; }
tr	6	public long bindMortal ( MortalMessage mortal ) { if ( proc != null ) { try { messenger . readReadyMessage ( ) ; } catch ( ProcessCommunicationException ex ) { close ( ) ; } } if ( proc == null ) { messenger = new Messenger ( Settings . COMMUNICATIONS_PORT ) ; ProcessBuilder pb = new ProcessBuilder ( "java" , "-cp" , System . getProperty ( "java.class.path" ) , "genejector.risen.RisenInstanceManager" ) ; try { proc = pb . start ( ) ; } catch ( IOException ex ) { throw new RuntimeException ( ex ) ; } StreamConsumerThread . dispatch ( new StreamConsumerThread ( proc . getInputStream ( ) , System . out , false ) ) ; StreamConsumerThread . dispatch ( new StreamConsumerThread ( proc . getErrorStream ( ) , System . err , false ) ) ; messenger . readReadyMessage ( ) ; messenger . writeMessage ( new SettingsMessage ( Settings . getSettings ( ) ) ) ; messenger . readReadyMessage ( ) ; } try { messenger . writeMessage ( mortal ) ; long score = ( ( ScoreMessage ) messenger . readMessage ( ) ) . getScore ( ) ; if ( score == - 1 ) { throw new GenejectedExecutionException ( "Score -1 received from risen JVM" ) ; } return score ; } catch ( ProcessCommunicationException ex ) { close ( ) ; throw new ProjectExecutionException ( "Risen realm died while scoring mortal" ) ; } }
tr	5	public ArimaaMove ( String move_text ) { clear ( ) ; this . steps = 4 ; int stepNumber = 0 ; StringTokenizer tokenizer = new StringTokenizer ( move_text ) ; while ( tokenizer . hasMoreTokens ( ) ) { String move = tokenizer . nextToken ( ) ; if ( move . equals ( "pass" ) ) { break ; } int piece_type = piece_type_from_text ( move . substring ( 0 , 1 ) ) ; assert ( piece_type >= 0 && piece_type <= 11 ) ; String col_text = "abcdefgh" ; int col = col_text . indexOf ( move . substring ( 1 , 2 ) ) ; int row = Integer . parseInt ( move . substring ( 2 , 3 ) ) - 1 ; String dir_text = "nsewx" ; int direction = dir_text . indexOf ( move . substring ( 3 , 4 ) ) ; if ( direction == 4 ) { int index = row * 8 + col ; this . piece_bb [ piece_type ] ^= 1 << index ; } if ( direction != 4 ) { int from_index = row * 8 + col ; int dir_offset [ ] = { 8 , - 8 , 1 , - 1 , 0 } ; int to_index = from_index + dir_offset [ direction ] ; this . piece_bb [ piece_type ] ^= 1 << from_index ; this . piece_bb [ piece_type ] ^= 1 << to_index ; stepSources [ stepNumber ++ ] = ( byte ) from_index ; } } }
tr	2	public void executeMacro ( VMacro macro ) throws TypeException { ArrayList < IValue > macroQueue = new ArrayList < IValue > ( ) ; for ( Object o : macro . getStackList ( ) ) { VQuote q = ( VQuote ) o ; macroQueue . add ( 0 , q . getInner ( ) ) ; } for ( IValue val : macroQueue ) { push ( val ) ; evaluateStack ( ) ; } }
tr	7	public static int getInteger ( Object o , Integer def ) { try { if ( o == null ) return def ; if ( o instanceof String ) return ( int ) Math . round ( double . parseDouble ( ( String ) o ) ) ; if ( o instanceof Number ) return ( ( Number ) o ) . intValue ( ) ; if ( o instanceof Range ) return ( ( Range ) o ) . randInt ( ) ; if ( o instanceof boolean ) return ( ( boolean ) o ) ? 1 : 0 ; } catch ( NumberFormatException e ) { } Log . w ( "Object cast error - cannot cast " + o + " to Integer." ) ; return def ; }
tr	6	@ SuppressWarnings ( "rawtypes" ) public static List < String > getClassNamesImplementingInterface ( class interf , String basePackage ) { List < String > classNames = new ArrayList < String > ( ) ; try { class [ ] result = getClasses ( basePackage ) ; for ( class c : result ) { if ( ! Modifier . isAbstract ( c . getModifiers ( ) ) ) { for ( class implementingInterface : c . getInterfaces ( ) ) { if ( implementingInterface . getName ( ) . equals ( interf . getName ( ) ) ) { classNames . add ( c . getCanonicalName ( ) ) ; } } } } } catch ( ClassNotFoundException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return classNames ; }
