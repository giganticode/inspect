te	2	private void unsubscribeAll ( ) { synchronized ( client_subscribed_uris_ ) { Uri [ ] topic_uris = client_subscribed_uris_ . toArray ( new Uri [ ] { } ) ; for ( Uri uri : topic_uris ) { unsubscribe ( uri ) ; } client_subscribed_uris_ . clear ( ) ; } synchronized ( server_subscribed_paths_ ) { for ( String path : server_subscribed_paths_ ) { Directory . Instance . removeHandler ( path , relayHandlerName ( path ) ) ; } server_subscribed_paths_ . clear ( ) ; } }
te	0	public int getId ( ) { return id ; }
te	5	public static void main ( String [ ] args ) throws Exception { List < HolisticManager > servers = new LinkedList < HolisticManager > ( ) ; servers . add ( new HolisticManager ( "riskMin_Reactive" , HolisticManager . Objective . RISK_MIN , "." , FaultToleranceEngine . Mode . REACTIVE ) ) ; servers . add ( new HolisticManager ( "riskMin_ProactiveLow" , HolisticManager . Objective . RISK_MIN , "." , FaultToleranceEngine . Mode . PROACTIVE_LOWRISK ) ) ; servers . add ( new HolisticManager ( "riskMin_ProactiveMed" , HolisticManager . Objective . RISK_MIN , "." , FaultToleranceEngine . Mode . PROACTIVE_MEDIUMRISK ) ) ; servers . add ( new HolisticManager ( "riskMin_Proactive" , HolisticManager . Objective . RISK_MIN , "." , FaultToleranceEngine . Mode . PROACTIVE_HIGHRISK ) ) ; servers . add ( new HolisticManager ( "ecoMax_Reactive" , HolisticManager . Objective . ECO_MAX , "." , FaultToleranceEngine . Mode . REACTIVE ) ) ; servers . add ( new HolisticManager ( "ecoMax_ProactiveLow" , HolisticManager . Objective . ECO_MAX , "." , FaultToleranceEngine . Mode . PROACTIVE_LOWRISK ) ) ; servers . add ( new HolisticManager ( "ecoMax_ProactiveMed" , HolisticManager . Objective . ECO_MAX , "." , FaultToleranceEngine . Mode . PROACTIVE_MEDIUMRISK ) ) ; servers . add ( new HolisticManager ( "ecoMax_Proactive" , HolisticManager . Objective . ECO_MAX , "." , FaultToleranceEngine . Mode . PROACTIVE_HIGHRISK ) ) ; int serviceNum = 0 ; for ( HolisticManager server : servers ) { for ( int time = 0 ; time < SIMULATION_DURATION ; time ++ ) { int averageDeployFrequency = MIN_DEPLOY_AVG_FREQUENCY - ( int ) ( Math . sin ( ( Math . PI * ( double ) time ) / ( double ) SIMULATION_DURATION ) * ( double ) ( MIN_DEPLOY_AVG_FREQUENCY - MAX_DEPLOY_AVG_FREQUENCY ) ) ; Service service = null ; if ( MathUtils . RND . nextInt ( averageDeployFrequency ) == 0 ) { int duration = MathUtils . getNormal ( MIN_VM_DURATION , VM_DURATION_STDEV , MAX_VM_DURATION ) ; assert duration >= MIN_VM_DURATION && duration <= MAX_VM_DURATION ; service = new Service ( server . getId ( ) + "_" + String . valueOf ( serviceNum ) , MathUtils . getNormal ( 1 , 3 , Service . MAX_VMS_PER_SERVICE ) , time , time + duration ) ; serviceNum ++ ; } server . step ( time , service ) ; } for ( PhysicalNode pn : server . getVMM ( ) . getDRP ( ) . getAllNodes ( ) ) { } server . stop ( ) ; } }
te	2	public long getLong ( int index ) throws JSONException { Object object = this . get ( index ) ; try { return object instanceof Number ? ( ( Number ) object ) . longValue ( ) : long . parseLong ( ( String ) object ) ; } catch ( Exception e ) { throw new JSONException ( "JSONArray[" + index + "] is not a number." ) ; } }
te	5	@ Override public void leftTrigger ( double value ) { if ( enabled ) { if ( value > 0 ) { adj = true ; } else { adj = false ; adj2 = false ; if ( ses2 != null ) { setFlagsFalse ( ) ; if ( future != null ) { future . cancel ( true ) ; } } dllProc . dll_keyRealesed ( container . xgetCurrentPreset ( ) . xgetLTAssignedKeyCode ( ) ) ; } ltAction ( ) ; } else { if ( future != null ) { future . cancel ( true ) ; } dllProc . dll_keyRealesed ( container . xgetCurrentPreset ( ) . xgetLTAssignedKeyCode ( ) ) ; } }
te	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( ManutencaoEventoUI . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( ManutencaoEventoUI . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( ManutencaoEventoUI . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( ManutencaoEventoUI . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { new ManutencaoEventoUI ( ) . setVisible ( true ) ; } } ) ; }
te	1	private void maybeShowPopup ( MouseEvent e ) { if ( e . isPopupTrigger ( ) ) { popup . show ( e . getComponent ( ) , e . getX ( ) , e . getY ( ) ) ; } }
te	4	public FileBrowser ( ClientInfo requestedClient , WindowAdapter windowEventClose ) { super ( APP_TITLE ) ; System . out . println ( "WE ALL GOTTA CHILL BRUTHA" ) ; try { this . commandOut = requestedClient . getSubSocketInfo ( "fileManagerCommand" ) . getSocket ( ) . getOutputStream ( ) ; this . dataIn = requestedClient . getSubSocketInfo ( "fileManagerData" ) . getSocket ( ) . getInputStream ( ) ; this . dataOut = requestedClient . getSubSocketInfo ( "fileManagerData" ) . getSocket ( ) . getOutputStream ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } try { UIManager . setLookAndFeel ( UIManager . getSystemLookAndFeelClassName ( ) ) ; } catch ( Exception weTried ) { } addWindowListener ( windowEventClose ) ; setDefaultCloseOperation ( JFrame . DISPOSE_ON_CLOSE ) ; setLocation ( 0 , 500 ) ; setContentPane ( getGui ( ) ) ; System . out . println ( "home homes HOMES HOMES " ) ; try { URL urlBig = this . getClass ( ) . getResource ( "fb-icon-32x32.png" ) ; URL urlSmall = this . getClass ( ) . getResource ( "fb-icon-16x16.png" ) ; ArrayList < Image > images = new ArrayList < Image > ( ) ; images . add ( ImageIO . read ( urlBig ) ) ; images . add ( ImageIO . read ( urlSmall ) ) ; setIconImages ( images ) ; } catch ( Exception weTried ) { } pack ( ) ; try { setLocationByPlatform ( true ) ; } catch ( Exception e ) { System . out . println ( "HUEHUEHUE !" ) ; e . printStackTrace ( ) ; } showRootFile ( ) ; System . out . println ( "THERE GOES THE WIND!" ) ; }
te	4	public boolean fill ( int size , Data data ) { if ( size <= array . size ( ) ) return false ; if ( data . type ( ) != this . type ( ) && this . type ( ) != DataTypes . UNDEFINED ) return false ; int number = size - array . size ( ) ; for ( int i = 0 ; i < number ; i ++ ) array . add ( data . clone ( ) ) ; return true ; }
te	8	@ Override public Object convertValue ( Object value ) { if ( value == null ) { return null ; } if ( value . getClass ( ) . isArray ( ) ) { if ( value . getClass ( ) . getComponentType ( ) == byte . TYPE ) { ByteArrayInputStream bis = new ByteArrayInputStream ( ( byte [ ] ) value ) ; ObjectInputStream ois = null ; try { ois = new ObjectInputStream ( bis ) ; value = ois . readObject ( ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( "Could not deserialize object" , e ) ; } finally { try { if ( ois != null ) { ois . close ( ) ; } } catch ( IOException e ) { } try { if ( bis != null ) { bis . close ( ) ; } } catch ( IOException e ) { } } } else ; } return value ; }
te	7	static void testValidity ( Object o ) throws JSONException { if ( o != null ) { if ( o instanceof double ) { if ( ( ( double ) o ) . isInfinite ( ) || ( ( double ) o ) . isNaN ( ) ) { throw new JSONException ( "JSON does not allow non-finite numbers." ) ; } } else if ( o instanceof float ) { if ( ( ( float ) o ) . isInfinite ( ) || ( ( float ) o ) . isNaN ( ) ) { throw new JSONException ( "JSON does not allow non-finite numbers." ) ; } } } }
te	2	public static < TSource > TSource firstOrNull ( Iterable < TSource > iterable , Func1 < boolean , TSource > predicate ) { for ( TSource tSource : iterable ) { if ( predicate . call ( tSource ) ) return tSource ; } return null ; }
te	5	private static String getGrpName ( String grpId ) { boolean done = false ; String grpName = null ; try { RandomAccessFile grpList = new RandomAccessFile ( User . grpListPath , "r" ) ; String buffer ; while ( ( buffer = grpList . readLine ( ) ) != null && ! done ) { String [ ] splitBuffer = buffer . split ( "\t" ) ; if ( splitBuffer [ 1 ] . compareTo ( grpId ) == 0 ) { grpName = splitBuffer [ 0 ] ; done = true ; } } grpList . close ( ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return grpName ; }
te	7	private JSONWriter append ( String string ) throws JSONException { if ( string == null ) { throw new JSONException ( "Null pointer" ) ; } if ( this . mode == o || this . mode == a ) { try { if ( this . , && this . mode == a ) { this . writer . write (   ) ; } this . writer . write ( string ) ; } catch ( IOException e ) { throw new JSONException ( e ) ; } if ( this . mode == o ) { this . mode = k ; } this . , = true ; return this ; } throw new JSONException ( "Value out of sequence." ) ; }
te	7	private void drawCheckers ( Graphics g , Space [ ] [ ] spaces ) { for ( int y = 0 ; y < spaces . length ; y ++ ) { for ( int x = 0 ; x < spaces . length ; x ++ ) { Checker checker = spaces [ x ] [ y ] . getChecker ( ) ; if ( checker == null ) continue ; if ( checker instanceof BlackCheckerPiece ) g . drawImage ( checkerBlack , x * spaceWidth , y * spaceWidth , null ) ; else if ( checker instanceof RedCheckerPiece ) g . drawImage ( checkerRed , x * spaceWidth , y * spaceWidth , null ) ; else if ( checker instanceof BlackKingChecker ) g . drawImage ( checkerKingBlack , x * spaceWidth , y * spaceWidth , null ) ; else if ( checker instanceof RedKingChecker ) g . drawImage ( checkerKingRed , x * spaceWidth , y * spaceWidth , null ) ; } } }
te	0	public K getKey ( V value ) { return valueToKey . get ( value ) ; }
te	4	private void normalizeAdjacentTextSequences ( ) { if ( this . tokenizedTemplate . size ( ) < 2 ) { return ; } for ( int i = this . tokenizedTemplate . size ( ) - 2 ; i > - 1 ; i -- ) { final Templatable current = this . tokenizedTemplate . get ( i ) ; final Templatable next = this . tokenizedTemplate . get ( i + 1 ) ; if ( current instanceof TextSequence && next instanceof TextSequence ) { mergeTokenizedItems ( i , i + 1 ) ; } } }
te	9	public boolean canBecomeWhite ( Point p ) { if ( outOfBounds ( p ) ) return false ; else if ( inTheCorner ( p ) ) return false ; else if ( onTheEdge ( p ) ) { if ( exitFound ) return false ; else if ( outOfBounds ( p . left ( ) ) || outOfBounds ( p . right ( ) ) ) return false ; else return isBlack ( p . left ( ) ) && isBlack ( p . right ( ) ) ; } else { int cnt = 0 ; if ( isWhite ( p . up ( ) ) ) cnt ++ ; if ( isWhite ( p . down ( ) ) ) cnt ++ ; if ( isWhite ( p . left ( ) ) ) cnt ++ ; if ( isWhite ( p . right ( ) ) ) cnt ++ ; return cnt == 1 ; } }
te	1	private void $reloadPlayers ( ) { if ( this . $playersFile == null ) this . $playersFile = new File ( ClashOfBlocks . getInstance ( ) . getDataFolder ( ) , "players.yml" ) ; this . $players = YamlConfiguration . loadConfiguration ( this . $playersFile ) ; }
te	7	public XmlPullParser newPullParser ( ) throws XmlPullParserException { if ( parserClasses == null ) throw new XmlPullParserException ( "Factory initialization was incomplete - has not tried " + classNamesLocation ) ; if ( parserClasses . size ( ) == 0 ) throw new XmlPullParserException ( "No valid parser classes found in " + classNamesLocation ) ; final StringBuffer issues = new StringBuffer ( ) ; for ( int i = 0 ; i < parserClasses . size ( ) ; i ++ ) { final class ppClass = ( class ) parserClasses . elementAt ( i ) ; try { final XmlPullParser pp = ( XmlPullParser ) ppClass . newInstance ( ) ; for ( Enumeration e = features . keys ( ) ; e . hasMoreElements ( ) ; ) { final String key = ( String ) e . nextElement ( ) ; final boolean value = ( boolean ) features . get ( key ) ; if ( value != null && value . booleanValue ( ) ) { pp . setFeature ( key , true ) ; } } return pp ; } catch ( Exception ex ) { issues . append ( ppClass . getName ( ) + ": " + ex . toString ( ) + "; " ) ; } } throw new XmlPullParserException ( "could not create parser: " + issues ) ; }
te	2	public static void main ( String [ ] args ) { CVLoader . load ( ) ; VideoCapture video = new VideoCapture ( 0 ) ; ImgWindow window = ImgWindow . newWindow ( ) ; if ( video . isOpened ( ) ) { Mat mat = new Mat ( ) ; while ( ! window . closed ) { loop ( mat , window , video ) ; } } video . release ( ) ; }
te	3	void generateCounts ( Field field ) { reset ( ) ; for ( int row = 0 ; row < field . getDepth ( ) ; row ++ ) { for ( int col = 0 ; col < field . getWidth ( ) ; col ++ ) { Object animal = field . getObjectAt ( row , col ) ; if ( animal != null ) { incrementCount ( animal . getClass ( ) ) ; } } } countsValid = true ; }
te	7	public int put ( final String name , final Object obj ) { if ( ( obj != null ) || ( name != null ) ) { if ( name != null ) { for ( int i = 0 ; i < fields . size ( ) ; i ++ ) { final DataField field = fields . get ( i ) ; if ( ( field . name != null ) && field . name . equals ( name ) ) { if ( obj != null ) { field . type = DataField . getType ( obj ) ; field . value = DataField . encode ( obj ) ; } else { fields . remove ( i ) ; } modified = true ; return i ; } } return add ( name , obj ) ; } else { return add ( obj ) ; } } return - 1 ; }
te	9	private void Ok ( ) { if ( list == null ) { setList ( ) ; } if ( loginTextField . getText ( ) . length ( ) == 0 ) { JOptionPane . showMessageDialog ( f , "Enter login" ) ; return ; } if ( passTextField . getText ( ) . length ( ) == 0 ) { JOptionPane . showMessageDialog ( f , "Enter password" ) ; return ; } try { ConnectMethods . LogInfo info = list . Authenticate ( loginTextField . getText ( ) , passTextField . getText ( ) ) ; if ( info == ConnectMethods . LogInfo . INCORRECT_LOGGIN ) { JOptionPane . showMessageDialog ( f , "Login was not found in database  check your login" ) ; passTextField . setText ( "" ) ; loginTextField . setText ( "" ) ; } if ( info == ConnectMethods . LogInfo . INCORRECT_PASS ) { JOptionPane . showMessageDialog ( f , "Incorrecn password  check your password" ) ; passTextField . setText ( "" ) ; } if ( info == ConnectMethods . LogInfo . ALREADY_LOGGED ) { JOptionPane . showMessageDialog ( f , "User is already logged" ) ; passTextField . setText ( "" ) ; } if ( info == ConnectMethods . LogInfo . CORRECT_DATA ) { f . dispose ( ) ; OpenProjFrame OPFrame = new OpenProjFrame ( list , loginTextField . getText ( ) ) ; OPFrame . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; OPFrame . setVisible ( true ) ; } } catch ( RemoteException e1 ) { JOptionPane . showMessageDialog ( f , "Disconnect from server" ) ; return ; } catch ( NullPointerException e1 ) { this . dispose ( ) ; LoginFrame log = new LoginFrame ( ) ; log . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; log . setVisible ( true ) ; } }
te	8	public int characterAt ( int at ) throws JSONException { int c = get ( at ) ; if ( ( c & 80 ) == 0 ) { return c ; } int character ; int c1 = get ( at + 1 ) ; if ( ( c1 & 80 ) == 0 ) { character = ( ( c & 7F ) << 7 ) | c1 ; if ( character > 7F ) { return character ; } } else { int c2 = get ( at + 2 ) ; character = ( ( c & 7F ) << 14 ) | ( ( c1 & 7F ) << 7 ) | c2 ; if ( ( c2 & 80 ) == 0 && character > 3FFF && character <= 10FFFF && ( character < D800 || character > DFFF ) ) { return character ; } } throw new JSONException ( "Bad character at " + at ) ; }
te	3	protected void lossCheck ( int buttonNum ) { placeInSequence ++ ; boolean didWeLose = false ; System . out . println ( "current button: " + currentButton ) ; System . out . println ( "button number: " + buttonNum ) ; System . out . println ( "place in sequence: " + placeInSequence ) ; System . out . println ( "size of computerButtonPresses: " + computerButtonPresses . size ( ) ) ; if ( currentButton != buttonNum ) { didWeLose = true ; this . endRound ( didWeLose ) ; } else if ( placeInSequence >= computerButtonPresses . size ( ) ) { didWeLose = false ; this . endRound ( didWeLose ) ; } else if ( currentButton == buttonNum ) { currentButton = computerButtonPresses . get ( placeInSequence ) ; } }
te	0	public void setLastItem ( String lastItem ) { this . lastItem = lastItem ; }
te	7	public boolean markupByPatternHelper ( SentenceStructure sentence ) { PropertyConfigurator . configure ( "conf/log4j.properties" ) ; Logger myLogger = Logger . getLogger ( "markupByPattern" ) ; if ( sentence . getOriginalSentence ( ) . matches ( "^x=.*" ) ) { myLogger . trace ( "Case 1" ) ; sentence . setTag ( "chromosome" ) ; sentence . setModifier ( "" ) ; return true ; } else if ( sentence . getOriginalSentence ( ) . matches ( "^2n=.*" ) ) { myLogger . trace ( "Case 2" ) ; sentence . setTag ( "chromosome" ) ; sentence . setModifier ( "" ) ; return true ; } else if ( sentence . getOriginalSentence ( ) . matches ( "^x .*" ) ) { myLogger . trace ( "Case 3" ) ; sentence . setTag ( "chromosome" ) ; sentence . setModifier ( "" ) ; return true ; } else if ( sentence . getOriginalSentence ( ) . matches ( "^2n .*" ) ) { myLogger . trace ( "Case 4" ) ; sentence . setTag ( "chromosome" ) ; sentence . setModifier ( "" ) ; return true ; } else if ( sentence . getOriginalSentence ( ) . matches ( "^2 n.*" ) ) { myLogger . trace ( "Case 5" ) ; sentence . setTag ( "chromosome" ) ; sentence . setModifier ( "" ) ; return true ; } else if ( sentence . getOriginalSentence ( ) . matches ( "^fl.*" ) ) { myLogger . trace ( "Case 6" ) ; sentence . setTag ( "flowerTime" ) ; sentence . setModifier ( "" ) ; return true ; } else if ( sentence . getOriginalSentence ( ) . matches ( "^fr.*" ) ) { myLogger . trace ( "Case 7" ) ; sentence . setTag ( "fruitTime" ) ; sentence . setModifier ( "" ) ; return true ; } return false ; }
te	2	public synchronized HashMap < String , String > startTestLocal ( String userKey , String testId ) { HashMap < String , String > res = new HashMap < String , String > ( ) ; String url = this . urlManager . testStartLocal ( Constants . APP_KEY , userKey , testId ) ; String responseCode = null ; String errorMessage = null ; String callBackUrl = null ; try { JSONObject jsonObject = getJson ( Methods . POST , url , null ) ; responseCode = jsonObject . get ( "response_code" ) . toString ( ) ; errorMessage = jsonObject . get ( "error" ) . toString ( ) ; callBackUrl = jsonObject . get ( "submit" ) . toString ( ) ; } catch ( JSONException je ) { BmLog . error ( "Error during processing JSON request: " , je ) ; } if ( ! responseCode . equals ( "200" ) ) { res . put ( "error" , errorMessage ) ; } else { res . put ( Constants . CALLBACK_URL , callBackUrl ) ; } return res ; }
te	0	public void setY ( double y ) { this . y = y ; }
te	1	@ Override public String toString ( ) { String output = "" ; int i = 0 ; for ( P problem : map . keySet ( ) ) { output += ( "[" + i + "]:" + problem + " => " + map . get ( problem ) + System . getProperty ( "line.separator" ) ) ; i ++ ; } return output ; }
te	5	public static List < String > retriveJavaScriptResources ( Chart < ? > chart ) { List < String > resources = new ArrayList < String > ( ) ; class < ? > clazz = chart . getClass ( ) ; if ( clazz . isAnnotationPresent ( JqPlotPlugin . class ) ) { JqPlotResources [ ] jqPlotResourceses = clazz . getAnnotation ( JqPlotPlugin . class ) . values ( ) ; for ( JqPlotResources jqPlotResources : jqPlotResourceses ) { resources . add ( jqPlotResources . getResource ( ) ) ; } } if ( chart . getChartConfiguration ( ) . getHighlighter ( ) != null ) { resources . add ( JqPlotResources . Highlighter . getResource ( ) ) ; } return resources ; }
te	1	public static _Fields findByThriftId ( int fieldId ) { switch ( fieldId ) { case 0 : return SUCCESS ; default : return null ; } }
te	2	private static int zzUnpackAttribute ( String packed , int offset , int [ ] result ) { int i = 0 ; int j = offset ; int l = packed . length ( ) ; while ( i < l ) { int count = packed . charAt ( i ++ ) ; int value = packed . charAt ( i ++ ) ; do result [ j ++ ] = value ; while ( -- count > 0 ) ; } return j ; }
te	9	public static FaceBundle submit ( double [ ] [ ] face_v , int width , int height , String [ ] id , boolean debug ) { int length = width * height ; int nrfaces = face_v . length ; int i , j , col , rows , pix , image ; double temp = 0.0 ; double [ ] [ ] faces = new double [ nrfaces ] [ length ] ; ImageFileViewer simple = new ImageFileViewer ( ) ; simple . setImage ( face_v [ 0 ] , width , height ) ; double [ ] avgF = new double [ length ] ; for ( pix = 0 ; pix < length ; pix ++ ) { temp = 0 ; for ( image = 0 ; image < nrfaces ; image ++ ) { temp += face_v [ image ] [ pix ] ; } avgF [ pix ] = temp / nrfaces ; } simple . setImage ( avgF , width , height ) ; for ( image = 0 ; image < nrfaces ; image ++ ) { for ( pix = 0 ; pix < length ; pix ++ ) { face_v [ image ] [ pix ] = face_v [ image ] [ pix ] - avgF [ pix ] ; } } System . arraycopy ( face_v , 0 , faces , 0 , face_v . length ) ; simple . setImage ( face_v [ 0 ] , width , height ) ; Matrix faceM = new Matrix ( face_v , nrfaces , length ) ; Matrix faceM_transpose = faceM . transpose ( ) ; Matrix covarM = faceM . times ( faceM_transpose ) ; EigenvalueDecomposition E = covarM . eig ( ) ; double [ ] eigValue = diag ( E . getD ( ) . getArray ( ) ) ; double [ ] [ ] eigVector = E . getV ( ) . getArray ( ) ; int [ ] index = new int [ nrfaces ] ; double [ ] [ ] tempVector = new double [ nrfaces ] [ nrfaces ] ; for ( i = 0 ; i < nrfaces ; i ++ ) index [ i ] = i ; doubleQuickSort ( eigValue , index , 0 , nrfaces - 1 ) ; int [ ] tempV = new int [ nrfaces ] ; for ( j = 0 ; j < nrfaces ; j ++ ) tempV [ nrfaces - 1 - j ] = index [ j ] ; index = tempV ; for ( col = nrfaces - 1 ; col >= 0 ; col -- ) { for ( rows = 0 ; rows < nrfaces ; rows ++ ) { tempVector [ rows ] [ col ] = eigVector [ rows ] [ index [ col ] ] ; } } eigVector = tempVector ; tempVector = null ; eigValue = null ; Matrix eigVectorM = new Matrix ( eigVector , nrfaces , nrfaces ) ; eigVector = eigVectorM . times ( faceM ) . getArray ( ) ; for ( image = 0 ; image < nrfaces ; image ++ ) { temp = max ( eigVector [ image ] ) ; for ( pix = 0 ; pix < eigVector [ 0 ] . length ; pix ++ ) eigVector [ image ] [ pix ] = Math . abs ( eigVector [ image ] [ pix ] / temp ) ; } double [ ] [ ] wk = new double [ nrfaces ] [ MAGIC_NR ] ; for ( image = 0 ; image < nrfaces ; image ++ ) { for ( j = 0 ; j < MAGIC_NR ; j ++ ) { temp = 0.0 ; for ( pix = 0 ; pix < length ; pix ++ ) temp += eigVector [ j ] [ pix ] * faces [ image ] [ pix ] ; wk [ image ] [ j ] = Math . abs ( temp ) ; } } FaceBundle b = new FaceBundle ( avgF , wk , eigVector , id ) ; return b ; }
te	7	@ Override public void run ( ) { try { if ( this . c_model . equals ( "Customer" ) ) { Thread t = new Thread ( fa . getCustomerTable ( ) ) ; t . start ( ) ; t . join ( 400 ) ; } if ( this . e_model . equals ( "Employee" ) ) { Thread t = new Thread ( fa . getEmployeeTable ( ) ) ; t . start ( ) ; t . join ( 400 ) ; } if ( this . f_model . equals ( "Fullticket" ) ) { fa . getFullticketTable ( ) . setStatus ( "" ) ; Thread t = new Thread ( fa . getFullticketTable ( ) ) ; t . start ( ) ; t . join ( 400 ) ; } if ( this . h_model . equals ( "History" ) ) { Thread t = new Thread ( fa . getHistoryTable ( ) ) ; t . start ( ) ; t . join ( 400 ) ; } if ( this . p_model . equals ( "Product" ) ) { Thread t = new Thread ( fa . getProductTable ( ) ) ; t . start ( ) ; t . join ( 400 ) ; } if ( _view != null ) { Thread t = new Thread ( fa . CounterRun ( _view ) ) ; t . start ( ) ; t . join ( 400 ) ; } } catch ( InterruptedException e ) { Error_Frame . Error ( e . toString ( ) ) ; } }
te	3	public void printNFromEnd ( int n ) { InputReader in = new InputReader ( getClass ( ) . getResourceAsStream ( "/list.txt" ) ) ; SingleLinkedList list = new SingleLinkedList ( ) ; Stack < Integer > stack = new Stack < Integer > ( ) ; int numOfElems = in . readInt ( ) ; for ( int i = 0 ; i < numOfElems ; i ++ ) { list . insert ( in . readInt ( ) ) ; } SNode cur = list . getHEADER ( ) ; while ( cur != null ) { stack . push ( list . delete ( ) ) ; cur = cur . next ; } for ( int i = 0 ; i < n ; i ++ ) System . out . print ( stack . pop ( ) ) ; }
te	6	private boolean r_main_suffix ( ) { int among_var ; int v_1 ; int v_2 ; v_1 = limit - cursor ; if ( cursor < I_p1 ) { return false ; } cursor = I_p1 ; v_2 = limit_backward ; limit_backward = cursor ; cursor = limit - v_1 ; ket = cursor ; among_var = find_among_b ( a_0 , 37 ) ; if ( among_var == 0 ) { limit_backward = v_2 ; return false ; } bra = cursor ; limit_backward = v_2 ; switch ( among_var ) { case 0 : return false ; case 1 : slice_del ( ) ; break ; case 2 : if ( ! ( in_grouping_b ( g_s_ending , 98 , 121 ) ) ) { return false ; } slice_del ( ) ; break ; } return true ; }
te	1	public int delete ( ) { String SQL1 = "DELETE FROM actividadesalumno where id=" + this . id ; int nup = getSgd ( ) . executeUpdate ( SQL1 ) ; if ( nup > 0 ) { Log log = getLogger ( ) ; log . setTabla ( "ActividadesAlumno" ) ; log . setDatos ( "id=" + this . id + ";" ) ; log . setTipo ( org . iesapp . clients . sgd7 . logger . Log . DELETE ) ; log . setSentenciaSQL ( org . iesapp . clients . sgd7 . logger . Log . normalizeSQL ( SQL1 ) ) ; log . postLog ( ) ; log = null ; } return nup ; }
te	4	public static PathPlanner create ( String algorithm , float carWidth , float cellWidth ) { if ( algorithm . equals ( "VisibilityGraph" ) ) return new VisibilityGraph ( carWidth , cellWidth ) ; if ( algorithm . equals ( "Voronoi" ) ) return new Voronoi ( ) ; if ( algorithm . equals ( "Quadtree" ) ) return new Quadtree ( carWidth , cellWidth ) ; if ( algorithm . equals ( "Wavefront" ) ) return new WaveFront ( ) ; return null ; }
te	8	public int numDecodings ( String s ) { if ( s == null || s . length ( ) == 0 ) return 0 ; int n = s . length ( ) ; int [ ] dp = new int [ n + 1 ] ; dp [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { int c1 = 0 , c2 = 0 ; if ( s . charAt ( i - 1 ) != 0 ) c1 = dp [ i - 1 ] ; if ( i >= 2 && ( s . charAt ( i - 2 ) == 1 || ( s . charAt ( i - 2 ) == 2 && s . charAt ( i - 1 ) <= 6 ) ) ) c2 = dp [ i - 2 ] ; dp [ i ] = c1 + c2 ; } return dp [ n ] ; }
te	5	@ Override public void caretUpdate ( CaretEvent e ) { String selection = repl . getSelection ( ) ; if ( selection != null && selection . length ( ) > 0 ) { repl . removeAllBackgroundHighlights ( ) ; selection = selection . trim ( ) ; if ( isWord ( selection ) ) { String result = repl . getResult ( ) ; Pattern p = Pattern . compile ( "\\W" + selection + "\\W" ) ; Matcher matcher = p . matcher ( result ) ; int index = 0 ; while ( matcher . find ( index ) ) { repl . addBackgroundHighlight ( matcher . start ( ) + 1 , matcher . end ( ) - matcher . start ( ) - 2 ) ; index = matcher . end ( ) - 1 ; } isDrawn = true ; } } else if ( isDrawn ) { isDrawn = false ; repl . removeAllBackgroundHighlights ( ) ; } }
te	7	private boolean r_case_other ( ) { int among_var ; ket = cursor ; among_var = find_among_b ( a_6 , 6 ) ; if ( among_var == 0 ) { return false ; } bra = cursor ; if ( ! r_R1 ( ) ) { return false ; } switch ( among_var ) { case 0 : return false ; case 1 : slice_del ( ) ; break ; case 2 : slice_del ( ) ; break ; case 3 : slice_from ( "a" ) ; break ; case 4 : slice_from ( "e" ) ; break ; } return true ; }
te	1	@ After public void tearDown ( ) throws Exception { busch . stop ( ) ; if ( tcpNet != null ) tcpNet . close ( ) ; }
te	8	public boolean hit ( Ray ray ) { double ox = ray . getOrigin ( ) . getX ( ) ; double oy = ray . getOrigin ( ) . getY ( ) ; double oz = ray . getOrigin ( ) . getZ ( ) ; double dx = ray . getDirection ( ) . getX ( ) ; double dy = ray . getDirection ( ) . getY ( ) ; double dz = ray . getDirection ( ) . getZ ( ) ; double tx_min , ty_min , tz_min ; double tx_max , ty_max , tz_max ; double a = 1.0 / dx ; if ( a >= 0 ) { tx_min = ( x0 - ox ) * a ; tx_max = ( x1 - ox ) * a ; } else { tx_min = ( x1 - ox ) * a ; tx_max = ( x0 - ox ) * a ; } double b = 1.0 / dy ; if ( b >= 0 ) { ty_min = ( y0 - oy ) * b ; ty_max = ( y1 - oy ) * b ; } else { ty_min = ( y1 - oy ) * b ; ty_max = ( y0 - oy ) * b ; } double c = 1.0 / dz ; if ( c >= 0 ) { tz_min = ( z0 - oz ) * c ; tz_max = ( z1 - oz ) * c ; } else { tz_min = ( z1 - oz ) * c ; tz_max = ( z0 - oz ) * c ; } double t0 , t1 ; if ( tx_min > ty_min ) t0 = tx_min ; else t0 = ty_min ; if ( tz_min > t0 ) t0 = tz_min ; if ( tx_max < ty_max ) t1 = tx_max ; else t1 = ty_max ; if ( tz_max < t1 ) t1 = tz_max ; return ( t0 < t1 && t1 > GeometricObject . K_EPSILON ) ; }
te	0	public void setPFWrap ( boolean wrapx , boolean wrapy , int shiftx , int shifty ) { el . setPFWrap ( wrapx , wrapy , shiftx , shifty ) ; }
te	0	public Page ( ) { super . setLayoutEngine ( pageLayoutEngine ) ; setRequestedBounds ( new Rectangle < Integer > ( 0 , 0 , Configuration . WINDOW_WIDTH , Configuration . WINDOW_HEIGTH ) ) ; }
te	7	public int candy ( int [ ] ratings ) { if ( ratings == null || ratings . length == 0 ) return 0 ; int [ ] left_scan = new int [ ratings . length ] ; left_scan [ 0 ] = 1 ; for ( int i = 1 ; i < ratings . length ; i ++ ) { if ( ratings [ i ] > ratings [ i - 1 ] ) left_scan [ i ] = left_scan [ i - 1 ] + 1 ; else left_scan [ i ] = 1 ; } int [ ] right_scan = new int [ ratings . length ] ; right_scan [ ratings . length - 1 ] = 1 ; for ( int i = ratings . length - 2 ; i >= 0 ; i -- ) { if ( ratings [ i ] > ratings [ i + 1 ] ) right_scan [ i ] = right_scan [ i + 1 ] + 1 ; else right_scan [ i ] = 1 ; } int result = 0 ; for ( int i = 0 ; i < ratings . length ; i ++ ) { result += Math . max ( left_scan [ i ] , right_scan [ i ] ) ; } return result ; }
te	1	@ Override public String execute ( HttpServletRequest request , HttpServletResponse response ) throws Exception { ArrayList < String > alColumns = null ; try { RecompensaDao oRecompensaDAO = new RecompensaDao ( Conexion . getConection ( ) ) ; alColumns = oRecompensaDAO . getColumnsNames ( ) ; String data = new Gson ( ) . toJson ( alColumns ) ; data = "{\"data\":" + data + "}" ; return data ; } catch ( Exception e ) { throw new ServletException ( "RecompensaGetcolumnsJson: View Error: " + e . getMessage ( ) ) ; } }
te	5	public static void save ( Frame parent , String [ ] name , String [ ] [ ] datas ) { FileDialog filedialog_save = new FileDialog ( parent , "\u4FDD\u5B58\u6587\u4EF6" ) ; filedialog_save . setFile ( ".xls" ) ; filedialog_save . setMode ( FileDialog . SAVE ) ; filedialog_save . setVisible ( true ) ; filesave = filedialog_save . getDirectory ( ) ; filesavename = filedialog_save . getFile ( ) ; boolean flag = false ; if ( filesave != null && filesavename != null ) { try { File file = new File ( filesave + filesavename + ".xls" ) ; if ( file . exists ( ) ) { file . delete ( ) ; } flag = ExcelUtil . createExcel ( new FileOutputStream ( file ) , name , datas ) ; } catch ( Exception e ) { flag = false ; } } if ( ! flag ) { return ; } else { JOptionPane . showMessageDialog ( null , "\u5BFC\u51FA\u6210\u529F" ) ; } }
te	6	public void train ( Input input , Label prediction ) { super . train ( input , prediction ) ; Instance instance = ( Instance ) input ; if ( instance . label ( ) . isPositive ( ) != prediction . isPositive ( ) ) { if ( instance . label ( ) . isPositive ( ) ) promote ( instance ) ; else demote ( instance ) ; } else if ( instance . label ( ) . isPositive ( ) && ( prediction . strength ( ) < pThickness ) ) promote ( instance ) ; else if ( ! instance . label ( ) . isPositive ( ) && ( prediction . strength ( ) < nThickness ) ) demote ( instance ) ; }
te	7	public boolean isOnPF ( int marginx , int marginy ) { if ( ! getTileBBox ( temp_bbox_copy ) ) { temp_bbox_copy . x = ( int ) x ; temp_bbox_copy . y = ( int ) y ; temp_bbox_copy . width = 0 ; temp_bbox_copy . height = 0 ; } if ( ! pfwrapx ) { if ( temp_bbox_copy . x + temp_bbox_copy . width < - marginx ) return false ; if ( temp_bbox_copy . x > pfwidth + marginx ) return false ; } if ( ! pfwrapy ) { if ( temp_bbox_copy . y + temp_bbox_copy . height < - marginy ) return false ; if ( temp_bbox_copy . y > pfheight + marginy ) return false ; } return true ; }
te	9	public static Pipe fromExpression ( String expression , StructInput [ ] inParams , boolean isInput , int lineN ) { expression = expression . trim ( ) ; int colonPos = expression . indexOf ( : ) ; ParseError . validate ( colonPos > 0 , lineN , "Expected (label):(type)" ) ; String label = expression . substring ( 0 , colonPos ) . trim ( ) ; String datatypeS = expression . substring ( colonPos + 1 ) . trim ( ) ; int equalPos = datatypeS . indexOf ( = ) ; if ( equalPos != - 1 ) { String defaultExp = datatypeS . substring ( equalPos + 1 ) . trim ( ) ; datatypeS = datatypeS . substring ( 0 , equalPos ) . trim ( ) ; Pipe constantPipe = Constants . matchConstant ( defaultExp , lineN ) ; ParseError . validate ( constantPipe . type ( ) . toString ( ) . equals ( datatypeS ) , lineN , "Default value type does not match definition" ) ; constantPipe . label = label ; return constantPipe ; } if ( datatypeS . equals ( "Double" ) ) { return new DoublePipe ( label ) ; } else if ( datatypeS . equals ( "Single" ) ) { return new SinglePipe ( label ) ; } else if ( datatypeS . equals ( "I64" ) ) { return new I64Pipe ( label ) ; } else if ( datatypeS . equals ( "I32" ) ) { return new I32Pipe ( label ) ; } else if ( datatypeS . equals ( "I16" ) ) { return new I16Pipe ( label ) ; } else if ( datatypeS . equals ( "I8" ) ) { return new I8Pipe ( label ) ; } else if ( datatypeS . equals ( "Bool" ) ) { return new BoolPipe ( label ) ; } else if ( datatypeS . equals ( "String" ) ) { return new StringPipe ( label ) ; } else if ( datatypeS . equals ( "Anything" ) ) { return new UndefinedPipe ( label , Datatype . Anything ) ; } else if ( datatypeS . equals ( "Numeric" ) ) { return new UndefinedPipe ( label , Datatype . Numeric ) ; } else if ( datatypeS . startsWith ( "typeof " ) ) { ParseError . validate ( inParams != null , lineN , "typeof is not allowed in this context" ) ; ParseError . validate ( equalPos == - 1 , lineN , "Defaults cannot be defined for implicit types" ) ; String implicitPipe = datatypeS . substring ( 7 ) . trim ( ) ; ParseError . validate ( ! implicitPipe . isEmpty ( ) , lineN , "typeof requires a referenced pipe" ) ; for ( int i = 0 ; i < inParams . length ; i ++ ) { String testPipe = inParams [ i ] . getLabel ( ) ; if ( testPipe . trim ( ) . equals ( implicitPipe . trim ( ) ) ) return new UndefinedPipe ( label , i , inParams [ i ] . type ( ) ) ; } ParseError . validate ( false , lineN , "typeof expression could not be evaluated for " + implicitPipe ) ; } else { ParseError . throwIf ( ! isInput , lineN , "Abstract types are not allowed in outputs; use typeof when possible:" ) ; ParseError . validate ( equalPos == - 1 , lineN , "Defaults cannot be defined for abstract types" ) ; } ParseError . validate ( false , lineN , "Could not evaluate Datatype expression " + datatypeS ) ; return null ; }
te	8	public void minMatrix ( int i , int j ) { int currentValue = getValue ( i , j ) ; int minI = i ; int minJ = j ; if ( isEmpty ( ) || elementSize == 1 ) { return ; } if ( i < m - 1 && getValue ( i + 1 , j ) < currentValue ) { minI = i + 1 ; minJ = j ; } if ( j < n - 1 && getValue ( i , j + 1 ) < getValue ( minI , minJ ) ) { minI = i ; minJ = j + 1 ; } if ( minI != i || minJ != j ) { setValue ( i , j , getValue ( minI , minJ ) ) ; setValue ( minI , minJ , currentValue ) ; } else { return ; } minMatrix ( minI , minJ ) ; }
te	2	private String getSelectedWord ( ) { final Set < Cell > cells = new TreeSet < Cell > ( COMPARATOR ) ; for ( final LetterElement element : selectedElements ) { cells . add ( lookupCell ( element ) ) ; } final char [ ] data = new char [ selectedElements . size ( ) ] ; int n = 0 ; for ( final Cell cell : cells ) { data [ n ++ ] = cell . data ; } return String . valueOf ( data ) ; }
te	7	public List < Integer > inorderTraversal ( TreeNode root ) { Stack < TreeNode > first = new Stack < TreeNode > ( ) ; Stack < TreeNode > second = new Stack < TreeNode > ( ) ; List < Integer > result = new ArrayList < Integer > ( ) ; if ( root == null ) return result ; first . add ( root ) ; while ( ! first . isEmpty ( ) || ! second . isEmpty ( ) ) { System . out . print ( first . isEmpty ( ) ) ; System . out . println ( second . isEmpty ( ) ) ; if ( ! first . isEmpty ( ) ) { root = first . pop ( ) ; if ( root . left != null ) { first . add ( root . left ) ; } second . add ( root ) ; } else if ( ! second . isEmpty ( ) ) { root = second . pop ( ) ; result . add ( root . val ) ; dbg ( root . val ) ; if ( root . right != null ) first . add ( root . right ) ; } } return result ; }
te	2	public void mouseReleased ( final MouseEvent event ) { if ( movingElement != null ) { updateMovingElement ( event ) ; final int mx = event . getX ( ) ; final int my = event . getY ( ) ; final LetterElement elemB = board . getElementAt ( mx , my ) ; if ( elemB != null ) { board . swapSelectedElements ( movingElement , elemB ) ; } movingElement . setAnchor ( null ) ; movingElement = null ; } }
te	9	protected ASTNode internalParse ( ILexer lexer ) throws ParseException { final int startOffset = lexer . currentParseOffset ( ) ; ASTNode lastAddedNode = null ; final Stack < OperatorNode > operatorStack = new Stack < OperatorNode > ( ) ; final Stack < ASTNode > valueStack = new Stack < ASTNode > ( ) ; do { final Token tok = lexer . peek ( ) ; if ( tok . hasType ( TokenType . IDENTIFIER ) ) { lastAddedNode = pushToStack ( operatorStack , valueStack , new IdentifierNode ( ) . parse ( lexer ) , lastAddedNode ) ; } else if ( tok . hasType ( TokenType . true ) ) { lastAddedNode = pushToStack ( operatorStack , valueStack , new TrueNode ( ) . parse ( lexer ) , lastAddedNode ) ; } else if ( tok . hasType ( TokenType . false ) ) { lastAddedNode = pushToStack ( operatorStack , valueStack , new FalseNode ( ) . parse ( lexer ) , lastAddedNode ) ; } else if ( tok . hasType ( TokenType . AND ) || tok . hasType ( TokenType . NOT ) || tok . hasType ( TokenType . OR ) ) { lastAddedNode = pushToStack ( operatorStack , valueStack , new OperatorNode ( ) . parse ( lexer ) , lastAddedNode ) ; } else if ( tok . hasType ( TokenType . PARENS_OPEN ) ) { lexer . read ( TokenType . PARENS_OPEN ) ; ASTNode parsed = new TermNode ( ) . internalParse ( lexer ) ; lastAddedNode = pushToStack ( operatorStack , valueStack , parsed , lastAddedNode ) ; lexer . read ( TokenType . PARENS_CLOSE ) ; } else { break ; } } while ( ! lexer . eof ( ) ) ; clearStacks ( operatorStack , valueStack , lastAddedNode ) ; if ( ! operatorStack . isEmpty ( ) ) { throw new ParseException ( "Term stack not empty: " + operatorStack , startOffset ) ; } assertNoEmptyTerms ( startOffset ) ; return this ; }
te	3	public LoginView ( final CrazybizApplication crazybizApplication ) { setSpacing ( true ) ; loginPanel = new Panel ( "CrazyBiz Login" ) ; loginForm = new LoginForm ( ) ; loginForm . setUsernameCaption ( "Username" ) ; loginForm . setPasswordCaption ( "Password" ) ; loginForm . setLoginButtonCaption ( "Login" ) ; loginForm . addListener ( new LoginListener ( ) { @ Override public void onLogin ( LoginEvent event ) { try { DBactions . connect ( ) ; if ( DBactions . isValidLogin ( event . getLoginParameter ( "username" ) , event . getLoginParameter ( "password" ) ) ) { String username = event . getLoginParameter ( "username" ) ; crazybizApplication . getWindow ( ) . removeAllComponents ( ) ; crazybizApplication . setHome ( new Homepage ( crazybizApplication , username ) ) ; crazybizApplication . getWindow ( ) . addComponent ( crazybizApplication . getHome ( ) ) ; } } catch ( SQLException e ) { e . printStackTrace ( ) ; } catch ( ClassNotFoundException e ) { e . printStackTrace ( ) ; } } } ) ; loginPanel . setWidth ( Sizeable . SIZE_UNDEFINED , 0 ) ; loginPanel . addComponent ( loginForm ) ; this . addComponent ( loginPanel ) ; this . setComponentAlignment ( loginPanel , Alignment . MIDDLE_CENTER ) ; }
te	3	@ Override public Collection getAll ( ) { Session session = null ; List orderStatuses = new ArrayList < OrderStatus > ( ) ; try { session = HibernateUtil . getSessionFactory ( ) . openSession ( ) ; orderStatuses = session . createCriteria ( OrderStatus . class ) . list ( ) ; } catch ( Exception e ) { System . err . println ( "\u041E\u0448\u0438\u0431\u043A\u0430 'getAll'" + e . getMessage ( ) ) ; } finally { if ( session != null && session . isOpen ( ) ) { session . close ( ) ; } } return orderStatuses ; }
te	2	@ Override public String toString ( String identation ) { StringBuffer tmp = new StringBuffer ( ) ; tmp . append ( identation ) ; tmp . append ( uriResource ) ; if ( jaxrsResources . size ( ) > 0 ) { tmp . append ( "  [" ) ; boolean first = true ; for ( JaxrsResource jaxrsesource : jaxrsResources ) { first = StringUtils . addIfFalse ( first , tmp , "  " ) ; tmp . append ( jaxrsesource . getHttpMethod ( ) ) ; tmp . append ( " " ) ; tmp . append ( jaxrsesource . getTemplate ( ) ) ; } tmp . append ( "]" ) ; } return tmp . toString ( ) ; }
te	4	public List < ClientClass > getAllClients ( ) { ResultSet result ; boolean result2 = false ; List < ClientClass > allClients = new ArrayList < ClientClass > ( ) ; result = clientDB . getAllClients ( ) ; if ( result == null ) return null ; try { while ( result . next ( ) ) { String fName = result . getString ( "firstName" ) ; String lName = result . getString ( "lastName" ) ; String company = result . getString ( "company" ) ; String email = result . getString ( "email" ) ; String phoneNum = result . getString ( "phoneNum" ) ; String address = result . getString ( "address" ) ; ClientClass newElement = new ClientClass ( fName , lName , email , company , phoneNum , address ) ; newElement . setClientId ( result . getInt ( "client_id" ) ) ; result2 = allClients . add ( newElement ) ; if ( ! result2 ) return null ; } } catch ( SQLException e ) { e . printStackTrace ( ) ; return null ; } return allClients ; }
te	0	public String getLevels ( ) { return levels ; }
te	6	static RPCMessage unmarshall ( String jsonFormatString ) throws IOException { if ( jsonFormatString == null ) throw new IOException ( "RPCMessage.stringToMessage was passed null" ) ; try { JSONObject jsonObj = new JSONObject ( jsonFormatString ) ; String type = jsonObj . getString ( "type" ) ; if ( type . equalsIgnoreCase ( "control" ) ) return new RPCControlMessage ( jsonObj ) ; if ( type . equalsIgnoreCase ( "invoke" ) ) return new RPCInvokeMessage ( jsonObj ) ; if ( type . equalsIgnoreCase ( "OK" ) ) return new RPCNormalResponseMessage ( jsonObj ) ; if ( type . equalsIgnoreCase ( "ERROR" ) ) return new RPCErrorResponseMessage ( jsonObj ) ; String msg = "Got unrecognized type in message: " + type + " [" + jsonFormatString + "]" ; Log . e ( TAG , msg ) ; throw new IOException ( msg ) ; } catch ( JSONException je ) { throw new IOException ( "Unparsable message: '" + jsonFormatString + "'" ) ; } }
te	2	public void setPropertyValue ( int index , Object instance , Object value ) { Property prop = properties . get ( index ) ; if ( value instanceof AbstractInstanciator ) ( ( AbstractInstanciator < ? > ) value ) . addReferer ( instance , prop ) ; else prop . setProperty ( instance , value ) ; }
te	4	public void method357 ( ) { if ( anInt1452 == anInt1456 && anInt1453 == anInt1457 ) return ; byte abyte0 [ ] = new byte [ anInt1456 * anInt1457 ] ; int i = 0 ; for ( int j = 0 ; j < anInt1453 ; j ++ ) { for ( int k = 0 ; k < anInt1452 ; k ++ ) abyte0 [ k + anInt1454 + ( j + anInt1455 ) * anInt1456 ] = aByteArray1450 [ i ++ ] ; } aByteArray1450 = abyte0 ; anInt1452 = anInt1456 ; anInt1453 = anInt1457 ; anInt1454 = 0 ; anInt1455 = 0 ; }
te	8	public void mousePressed ( MouseEvent e ) { Mappable mappable = map . getMapObjectAt ( e . getX ( ) , e . getY ( ) ) ; setSelected ( mappable ) ; boolean ctrlDown = ( e . getModifiersEx ( ) & InputEvent . CTRL_DOWN_MASK ) != 0 ; boolean altDown = ( e . getModifiersEx ( ) & InputEvent . ALT_DOWN_MASK ) != 0 ; if ( mappable != null && SwingUtilities . isRightMouseButton ( e ) ) { popupMenu . show ( this , e . getX ( ) , e . getY ( ) ) ; } else if ( selected != null && ctrlDown ) { eventProc = eventProcessors . get ( "rotate" ) ; } else if ( selected != null && altDown ) { eventProc = eventProcessors . get ( "face" ) ; } else if ( selected != null ) { eventProc = eventProcessors . get ( "move" ) ; } else if ( SwingUtilities . isRightMouseButton ( e ) ) { eventProc = eventProcessors . get ( "measure" ) ; } else { eventProc = eventProcessors . get ( "select" ) ; } eventProc . mousePressed ( e ) ; }
te	0	public void stop ( ) { timer . cancel ( ) ; }
te	2	public void setHideMode ( int mode ) { if ( mode < - 1 || mode > 3 ) throw new IllegalArgumentException ( "Wrong hideMode: " + mode ) ; hideMode = mode ; }
te	9	public static void submitFeedback ( String s_id , String i_id , int o_id , int cr , int ir , int dr , float aww ) { try { Connection conn = global . getConnection ( ) ; PreparedStatement pStmt = conn . prepareStatement ( "insert into feedback values(?  ?  ?  ?  ?  ?  ?  ?)" ) ; pStmt . setString ( 1 , s_id ) ; pStmt . setInt ( 2 , o_id ) ; pStmt . setString ( 3 , i_id ) ; Timestamp t = new Timestamp ( Calendar . getInstance ( ) . getTime ( ) . getTime ( ) ) ; pStmt . setTimestamp ( 4 , t ) ; pStmt . setInt ( 5 , cr ) ; pStmt . setInt ( 6 , ir ) ; pStmt . setInt ( 7 , dr ) ; pStmt . setFloat ( 8 , aww ) ; pStmt . executeUpdate ( ) ; pStmt . close ( ) ; pStmt = conn . prepareStatement ( "select avg(course_rating)  avg(instructor_rating)  avg(difficulty_rating)  stddev(course_rating)  stddev(instructor_rating)  stddev(difficulty_rating) from feedback where student_id = ?" ) ; pStmt . setString ( 1 , s_id ) ; ResultSet rs = pStmt . executeQuery ( ) ; rs . next ( ) ; float cr_mean = rs . getFloat ( 1 ) ; float ir_mean = rs . getFloat ( 2 ) ; float dr_mean = rs . getFloat ( 3 ) ; float cr_var = rs . getFloat ( 4 ) ; float ir_var = rs . getFloat ( 5 ) ; float dr_var = rs . getFloat ( 6 ) ; pStmt . close ( ) ; pStmt = conn . prepareStatement ( "update student set cr_mean = ? and cr_var = ? and ir_mean = ? and ir_var = ? and dr_mean = ? and dr_var = ? where student_id = ?" ) ; pStmt . setFloat ( 1 , cr_mean ) ; pStmt . setFloat ( 2 , cr_var ) ; pStmt . setFloat ( 3 , ir_mean ) ; pStmt . setFloat ( 4 , ir_var ) ; pStmt . setFloat ( 5 , dr_mean ) ; pStmt . setFloat ( 6 , dr_var ) ; pStmt . setString ( 7 , s_id ) ; pStmt . executeUpdate ( ) ; pStmt . close ( ) ; pStmt = conn . prepareStatement ( "select distinct offering_id  instructor_id from feedback where student_id = ?" ) ; pStmt . setString ( 1 , s_id ) ; rs = pStmt . executeQuery ( ) ; ArrayList < Integer > offs = new ArrayList < Integer > ( ) ; ArrayList < String > instrs = new ArrayList < String > ( ) ; while ( rs . next ( ) ) { offs . add ( rs . getInt ( 1 ) ) ; instrs . add ( rs . getString ( 2 ) ) ; } pStmt . close ( ) ; pStmt = conn . prepareStatement ( "select student_id  avg(instructor_rating)  count(instructor_rating)  avg(avg_workload)  avg(course_rating)  avg(difficulty_rating) from feedback where offering_id = ? and instructor_id = ? group by student_id" ) ; PreparedStatement pStmt2 = conn . prepareStatement ( "select ir_mean  ir_var  cr_mean  cr_var  dr_mean  dr_var from student where student_id = ?" ) ; PreparedStatement pStmt3 = conn . prepareStatement ( "update teaches set instructor_rating = ?  aww = ?  course_rating = ?  difficulty_rating = ? where offering_id = ? and instructor_id = ?" ) ; for ( int i = 0 ; i < offs . size ( ) ; i ++ ) { pStmt . setInt ( 1 , offs . get ( i ) ) ; pStmt . setString ( 2 , instrs . get ( i ) ) ; rs = pStmt . executeQuery ( ) ; float instr_rating = 0.0f ; float course_rating = 0.0f ; float difficulty_rating = 0.0f ; float avgworkload = 0.0f ; int count = 0 ; while ( rs . next ( ) ) { pStmt2 . setString ( 1 , rs . getString ( 1 ) ) ; ResultSet rs2 = pStmt2 . executeQuery ( ) ; rs2 . next ( ) ; instr_rating += rs . getInt ( 3 ) * ( ( rs . getFloat ( 2 ) - rs2 . getFloat ( 1 ) ) / ( rs2 . getFloat ( 2 ) == 0 ? 1 : rs2 . getFloat ( 2 ) ) ) ; course_rating += rs . getInt ( 3 ) * ( ( rs . getFloat ( 5 ) - rs2 . getFloat ( 3 ) ) / ( rs2 . getFloat ( 4 ) == 0 ? 1 : rs2 . getFloat ( 4 ) ) ) ; difficulty_rating += rs . getInt ( 3 ) * ( ( rs . getFloat ( 6 ) - rs2 . getFloat ( 5 ) ) / ( rs2 . getFloat ( 6 ) == 0 ? 1 : rs2 . getFloat ( 6 ) ) ) ; avgworkload += rs . getInt ( 3 ) * rs . getFloat ( 4 ) ; count += rs . getInt ( 3 ) ; } instr_rating /= ( count == 0 ? 1 : count ) ; course_rating /= ( count == 0 ? 1 : count ) ; difficulty_rating /= ( count == 0 ? 1 : count ) ; avgworkload /= count ; pStmt3 . setFloat ( 1 , instr_rating ) ; pStmt3 . setFloat ( 2 , avgworkload ) ; pStmt3 . setFloat ( 3 , course_rating ) ; pStmt3 . setFloat ( 4 , difficulty_rating ) ; pStmt3 . setInt ( 5 , offs . get ( i ) ) ; pStmt3 . setString ( 6 , instrs . get ( i ) ) ; pStmt3 . executeUpdate ( ) ; } pStmt . close ( ) ; pStmt2 . close ( ) ; pStmt3 . close ( ) ; conn . close ( ) ; } catch ( SQLException sqle ) { System . err . println ( "SQLE: " + sqle . toString ( ) ) ; } catch ( ClassNotFoundException cnfe ) { System . err . println ( "CNFE: " + cnfe . toString ( ) ) ; } System . out . println ( "Feedback: Student = " + s_id + " Instructor = " + i_id + " Offering = " + o_id ) ; }
te	1	private static int numElements ( double [ ] [ ] arr ) { int count = 0 ; for ( int i = 0 ; i < arr . length ; ++ i ) count += arr [ i ] . length ; return count ; }
te	2	public void updateDB ( String timestamp ) throws ClassNotFoundException , SQLException { String query ; if ( ( high == null | precip == null ) | ( high . equals ( "" ) | precip . equals ( "" ) ) ) { query = "INSERT INTO weather.dbo.daily_forecast (zip collected_time collected_date forecast_date high precip_chance) VALUES ('" + zip + "' '" + timestamp + "' '" + todayDate + "' '" + predictionDate + "' null null)" ; } else { query = "INSERT INTO weather.dbo.daily_forecast (zip collected_time collected_date forecast_date high precip_chance) VALUES ('" + zip + "' '" + timestamp + "' '" + todayDate + "' '" + predictionDate + "' '" + high + "' '" + precip + "')" ; } class . forName ( "com.microsoft.sqlserver.jdbc.SQLServerDriver" ) ; String connectionURL = "jdbc:sqlserver://MARCUSHANPC\\SQLEXPRESS;integratedSecurity=true;databaseName=weather;" ; Connection con = DriverManager . getConnection ( connectionURL ) ; Statement findDupStmt = con . createStatement ( ResultSet . TYPE_FORWARD_ONLY , ResultSet . CONCUR_UPDATABLE ) ; try { findDupStmt . executeUpdate ( query ) ; } catch ( Exception e ) { } findDupStmt . close ( ) ; con . close ( ) ; }
te	0	public boolean IsValid ( ) { return this . Settings != null ; }
te	2	@ Override public Object execute ( HttpServletRequest request , HttpServletResponse response ) throws Exception { Contexto oContexto = ( Contexto ) request . getAttribute ( "contexto" ) ; oContexto . setVista ( "jsp/profesor/list.jsp" ) ; try { ProfesorDao oProfesorDao = new ProfesorDao ( oContexto . getEnumTipoConexion ( ) ) ; Integer intPages = oProfesorDao . getPages ( oContexto . getNrpp ( ) , oContexto . getAlFilter ( ) , oContexto . getHmOrder ( ) ) ; if ( oContexto . getPage ( ) >= intPages ) { oContexto . setPage ( intPages ) ; } ArrayList < ProfesorBean > listado = ( ArrayList < ProfesorBean > ) oProfesorDao . getPage ( oContexto . getNrpp ( ) , oContexto . getPage ( ) , oContexto . getAlFilter ( ) , oContexto . getHmOrder ( ) ) ; String strUrl = "<a href=\"Controller?" + oContexto . getSerializedParamsExceptPage ( ) + "&page=" ; ArrayList < String > botonera = Pagination . getButtonPad ( strUrl , oContexto . getPage ( ) , intPages , 2 ) ; ArrayList < Object > a = new ArrayList < > ( ) ; a . add ( listado ) ; a . add ( botonera ) ; return a ; } catch ( Exception e ) { throw new ServletException ( "ProfesorList1: View Error: " + e . getMessage ( ) ) ; } }
te	5	protected List < Object > retrieveWithParent ( List < Object > returnObjects , final Vector3f pPosition , final Vector3f pHalfsize ) { if ( enabled && AABB . intersects ( position , halfsize , pPosition , pHalfsize ) ) { Node parentNode = parent ; while ( parentNode != null ) { returnObjects . addAll ( parentNode . objects . values ( ) ) ; parentNode = parentNode . parent ; } if ( children != null ) { for ( byte i = 0 ; i < SUBDIVISIONS ; i ++ ) { children [ i ] . retrieve ( returnObjects , pPosition , pHalfsize ) ; } } returnObjects . addAll ( objects . values ( ) ) ; } return returnObjects ; }
te	5	public void work ( ) { switch ( type ) { case DEVELOPER : logger . debug ( "I'm " + name + "! I'm a DEVELOPER! My job is to develop! I'm developing..." ) ; break ; case ANALYST : logger . debug ( "I'm " + name + "! I'm an ANALYST! My job is to analyze! I'm analizing..." ) ; break ; case ARCHITECT : logger . debug ( "I'm " + name + "! I'm an ARCHITECT! My job is to design! I'm designing..." ) ; break ; case TESTER : logger . debug ( "I'm " + name + "! I'm an TESTER! My job is to test! I'm testing..." ) ; break ; case PROJECT_MANAGER : logger . debug ( "I'm " + name + "! I'm a MANAGER! My job is to manage! I'm managing..." ) ; break ; } }
te	6	private boolean r_case_special ( ) { int among_var ; ket = cursor ; among_var = find_among_b ( a_5 , 3 ) ; if ( among_var == 0 ) { return false ; } bra = cursor ; if ( ! r_R1 ( ) ) { return false ; } switch ( among_var ) { case 0 : return false ; case 1 : slice_from ( "e" ) ; break ; case 2 : slice_from ( "a" ) ; break ; case 3 : slice_from ( "a" ) ; break ; } return true ; }
te	0	public Patient ( ) { super ( "" , "" , "" ) ; }
te	4	protected static void setTextLabelValues ( TextLabel textLabel , String textValue , Font font , Integer textWidth , Integer textHeight ) { if ( null != textValue ) { textLabel . setValue ( textValue ) ; } if ( null != font ) { textLabel . setFont ( font ) ; } if ( null != textWidth ) { textLabel . setTextWidth ( textWidth ) ; } if ( null != textHeight ) { textLabel . setTextHeight ( textHeight ) ; } }
te	7	private int buildStraight ( int xo , int maxLength , boolean safe ) { int length = random . nextInt ( 10 ) + 2 ; if ( safe ) length = 10 + random . nextInt ( 5 ) ; if ( length > maxLength ) length = maxLength ; int floor = height - 1 - random . nextInt ( 4 ) ; for ( int x = xo ; x < xo + length ; x ++ ) { for ( int y = 0 ; y < height ; y ++ ) { if ( y >= floor ) { setBlock ( x , y , GROUND ) ; } } } if ( ! safe ) { if ( length > 5 ) { decorate ( xo , xo + length , floor ) ; } } return length ; }
te	1	public void hideProperties ( ) { if ( propertiesDialog != null ) { propertiesDialog . hide ( ) ; propertiesDialog . dispose ( ) ; propertiesDialog = null ; } }
te	9	public static String toString ( JSONObject jo ) throws JSONException { StringBuffer sb = new StringBuffer ( ) ; int i ; JSONArray ja ; String key ; Iterator keys ; int length ; Object object ; String tagName ; String value ; tagName = jo . optString ( "tagName" ) ; if ( tagName == null ) { return XML . escape ( jo . toString ( ) ) ; } XML . noSpace ( tagName ) ; tagName = XML . escape ( tagName ) ; sb . append ( < ) ; sb . append ( tagName ) ; keys = jo . keys ( ) ; while ( keys . hasNext ( ) ) { key = keys . next ( ) . toString ( ) ; if ( ! "tagName" . equals ( key ) && ! "childNodes" . equals ( key ) ) { XML . noSpace ( key ) ; value = jo . optString ( key ) ; if ( value != null ) { sb . append (   ) ; sb . append ( XML . escape ( key ) ) ; sb . append ( = ) ; sb . append ( " ) ; sb . append ( XML . escape ( value ) ) ; sb . append ( " ) ; } } } ja = jo . optJSONArray ( "childNodes" ) ; if ( ja == null ) { sb . append ( / ) ; sb . append ( > ) ; } else { sb . append ( > ) ; length = ja . length ( ) ; for ( i = 0 ; i < length ; i += 1 ) { object = ja . get ( i ) ; if ( object != null ) { if ( object instanceof String ) { sb . append ( XML . escape ( object . toString ( ) ) ) ; } else if ( object instanceof JSONObject ) { sb . append ( toString ( ( JSONObject ) object ) ) ; } else if ( object instanceof JSONArray ) { sb . append ( toString ( ( JSONArray ) object ) ) ; } else { sb . append ( object . toString ( ) ) ; } } } sb . append ( < ) ; sb . append ( / ) ; sb . append ( tagName ) ; sb . append ( > ) ; } return sb . toString ( ) ; }
te	3	public static float [ ] [ ] rotateX ( Vector3d v ) { float r , r_ ; float [ ] [ ] m1 = identity ( ) ; float [ ] [ ] m2 = identity ( ) ; float [ ] [ ] m3 = identity ( ) ; float [ ] [ ] m4 = identity ( ) ; float [ ] [ ] m5 = identity ( ) ; r_ = ( float ) Math . sqrt ( v . y * v . y + v . x * v . x ) ; if ( r_ != 0 ) { m1 [ 0 ] [ 0 ] = v . x / r_ ; m1 [ 0 ] [ 1 ] = v . y / r_ ; m1 [ 1 ] [ 0 ] = - m1 [ 0 ] [ 1 ] ; m1 [ 1 ] [ 1 ] = m1 [ 0 ] [ 0 ] ; } r = v . length ( ) ; if ( r_ != 0 ) { m2 [ 0 ] [ 0 ] = r_ / r ; m2 [ 0 ] [ 2 ] = v . z / r ; m2 [ 2 ] [ 0 ] = - m2 [ 0 ] [ 2 ] ; m2 [ 2 ] [ 2 ] = m2 [ 0 ] [ 0 ] ; } Vector3d up = new Vector3d ( 0 , 0 , 1 ) ; applyTo ( m1 , up , up ) ; applyTo ( m2 , up , up ) ; r_ = ( float ) Math . sqrt ( v . y * v . y + v . z * v . z ) ; if ( r_ != 0 ) { m4 [ 1 ] [ 1 ] = up . z / r_ ; m4 [ 1 ] [ 2 ] = up . y / r_ ; m4 [ 2 ] [ 1 ] = - m4 [ 1 ] [ 2 ] ; m4 [ 2 ] [ 2 ] = m4 [ 1 ] [ 1 ] ; } m3 = applyTo ( m2 , m1 ) ; m5 = applyTo ( m4 , m3 ) ; return m3 ; }
te	1	public boolean hasPrev ( ) throws NullPointerException { if ( actual == null ) { throw new NullPointerException ( "Error: El dato actual es nulo!" ) ; } return actual . hasPrev ( ) ; }
te	7	public void saveMod ( Path path , Mod mod ) throws IOException { Path dir = path == null ? mod . getSourceFolder ( ) : path ; if ( dir == null ) throw new IllegalArgumentException ( "No path was provided" ) ; if ( Files . notExists ( path ) ) Files . createDirectory ( dir ) ; ModInfo info = mod . getInfo ( ) ; Util . writeJsonToFile ( info . getObject ( ) , dir . resolve ( info . getName ( ) + ".modinfo" ) ) ; Path assetPath = mod . getAssetFolder ( ) ; for ( Asset a : mod . getAssets ( ) ) { if ( a . getClass ( ) != Asset . class ) { if ( ! a . isLoaded ( ) ) a . load ( ) ; a . saveWithSource ( assetPath ) ; } else if ( a . getSource ( ) != null ) { Path n = assetPath . resolve ( a . getPath ( ) ) ; Files . createDirectories ( n . getParent ( ) ) ; Files . copy ( a . getSource ( ) , n ) ; } } ModToolkit . log . info ( "Mod saved: " + path . toAbsolutePath ( ) . toString ( ) ) ; }
te	4	public boolean contains ( final IShape shape ) { if ( hasChanged || shape . hasChanged ( ) ) { for ( final Vector4f p : planes ) { shape . getMinAlongDirection ( temp , p ) ; if ( p . x * temp . x + p . y * temp . y + p . z * temp . z < p . w ) { shape . setFrustumType ( NONE ) ; return false ; } } shape . setFrustumType ( CONTAINS ) ; return true ; } return shape . getFrustumType ( ) == CONTAINS ; }
te	7	public static boolean isSupport ( ABObject o2 , ABObject o1 ) { if ( o2 . x == o1 . x && o2 . y == o1 . y && o2 . width == o1 . width && o2 . height == o1 . height ) return false ; int ex_o1 = o1 . x + o1 . width ; int ex_o2 = o2 . x + o2 . width ; int ey_o2 = o2 . y + o2 . height ; if ( ( Math . abs ( ey_o2 - o1 . y ) < gap ) && ! ( o2 . x - ex_o1 > gap || o1 . x - ex_o2 > gap ) ) return true ; return false ; }
te	9	@ Override public void marshal ( Element e , Document doc ) { super . marshal ( e , doc ) ; String xns = NS . XLINK . ns ( ) ; if ( this . xlinkType != null ) { Attr xtype = doc . createAttributeNS ( xns , "xlink:type" ) ; xtype . setNodeValue ( this . xlinkType . value ( ) ) ; e . setAttributeNode ( xtype ) ; } if ( this . xlinkHREF != null ) { Attr xhref = doc . createAttributeNS ( xns , "xlink:href" ) ; xhref . setNodeValue ( this . xlinkHREF ) ; e . setAttributeNode ( xhref ) ; } if ( this . xlinkRole != null ) { Attr xrole = doc . createAttributeNS ( xns , "xlink:role" ) ; xrole . setNodeValue ( this . xlinkRole ) ; e . setAttributeNode ( xrole ) ; } if ( this . xlinkArcRole != null ) { Attr xArcRole = doc . createAttributeNS ( xns , "xlink:arcrole" ) ; xArcRole . setNodeValue ( this . xlinkArcRole ) ; e . setAttributeNode ( xArcRole ) ; } if ( this . xlinkTitle != null ) { Attr xtitle = doc . createAttributeNS ( xns , "xlink:title" ) ; xtitle . setNodeValue ( this . xlinkTitle ) ; e . setAttributeNode ( xtitle ) ; } if ( this . otherloctype != null ) e . setAttribute ( "OTHERLOCTYPE" , this . otherloctype ) ; if ( this . xlinkShow != null ) { Attr show = doc . createAttributeNS ( xns , "xlink:show" ) ; show . setNodeValue ( this . xlinkShow . value ( ) ) ; e . setAttributeNode ( show ) ; } if ( this . xlinkActuate != null ) { Attr actuate = doc . createAttributeNS ( xns , "xlink:actuate" ) ; actuate . setNodeValue ( this . xlinkActuate . value ( ) ) ; e . setAttributeNode ( actuate ) ; } if ( this . loctype != null ) e . setAttribute ( "LOCTYPE" , this . loctype . value ( ) ) ; }
te	4	private static void createVirtualNetworkRequests ( String baseDir ) { new File ( baseDir ) . mkdir ( ) ; int numberOfVirtualNetworkRequests = 40 ; ArrayList < Request > requests = new VirtualNetworksGenerator ( ) . generateVirtualNetworks ( numberOfVirtualNetworkRequests ) ; Random random = new Random ( ) ; for ( int i = 0 ; i < numberOfVirtualNetworkRequests ; i ++ ) { String requestFilename = baseDir + String . format ( "req%s.txt" , i ) ; try { PrintWriter writer = new PrintWriter ( requestFilename ) ; Request request = requests . get ( i ) ; writer . println ( request . getAmountNodes ( ) + " " + request . getAmountLinks ( ) + " 0 " + request . getCreationTime ( ) + " " + request . getLifeTime ( ) + " 0 200" ) ; for ( VirtualNode node : request . getVirtualNodes ( ) . values ( ) ) { int x = random . nextInt ( 100 ) ; int y = random . nextInt ( 100 ) ; writer . println ( x + " " + y + " " + node . getCapacity ( ) ) ; } for ( VirtualLink link : request . getVirtualLinks ( ) . values ( ) ) { writer . println ( link . getSourceNode ( ) . getId ( ) + " " + link . getDestinyNode ( ) . getId ( ) + " " + link . getBandwidthCapacity ( ) + " " + link . getDelay ( ) ) ; } writer . close ( ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } } }
te	6	private long obtainValuePosition ( String key , int block ) throws IOException { long position = blockSize * block + index . offset ( block ) ; String currentKey = channelReader . readString ( fileChannel , position ) ; position += 4 + currentKey . getBytes ( Node . CHARSET ) . length ; if ( block == index . countBlocks ( ) - 1 ) { while ( ! key . equals ( currentKey ) && currentKey . compareTo ( index . maxKey ( ) ) < 0 ) { int length = channelReader . readInt ( fileChannel , position ) ; position += 4 + length ; currentKey = channelReader . readString ( fileChannel , position ) ; position += 4 + currentKey . getBytes ( Node . CHARSET ) . length ; } } else { while ( ! key . equals ( currentKey ) && position < blockSize * ( block + 1 ) ) { int length = channelReader . readInt ( fileChannel , position ) ; position += 4 + length ; currentKey = channelReader . readString ( fileChannel , position ) ; position += 4 + currentKey . getBytes ( Node . CHARSET ) . length ; } } if ( ! key . equals ( currentKey ) ) { return - 1 ; } else { return position ; } }
te	8	public boolean stem ( ) { int v_1 ; int v_2 ; int v_3 ; int v_4 ; v_1 = cursor ; lab0 : do { if ( ! r_mark_regions ( ) ) { break lab0 ; } } while ( false ) ; cursor = v_1 ; limit_backward = cursor ; cursor = limit ; v_2 = limit - cursor ; lab1 : do { if ( ! r_main_suffix ( ) ) { break lab1 ; } } while ( false ) ; cursor = limit - v_2 ; v_3 = limit - cursor ; lab2 : do { if ( ! r_consonant_pair ( ) ) { break lab2 ; } } while ( false ) ; cursor = limit - v_3 ; v_4 = limit - cursor ; lab3 : do { if ( ! r_other_suffix ( ) ) { break lab3 ; } } while ( false ) ; cursor = limit - v_4 ; cursor = limit_backward ; return true ; }
te	4	@ Override public String toString ( ) { StringBuilder b = new StringBuilder ( ) ; for ( int i = 0 ; i < this . answers . size ( ) ; i ++ ) { b . append ( this . answers . get ( i ) ) ; if ( i == this . correctAnswer ) b . append ( " {correct}" ) ; if ( i == this . selectedAnswer ) b . append ( "{selected}" ) ; if ( i < this . answers . size ( ) - 1 ) b . append ( "\n" ) ; } return b . toString ( ) ; }
te	1	public String getParametersSignature ( String packageDst ) { String parametersSignature = "" ; for ( Type type : getParameters ( ) ) { parametersSignature += type . getObjectType ( packageDst ) ; } return parametersSignature ; }
te	6	@ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( obj instanceof DescribeServiceCertificatesResult == false ) return false ; DescribeServiceCertificatesResult other = ( DescribeServiceCertificatesResult ) obj ; if ( other . getServiceCertificates ( ) == null ^ this . getServiceCertificates ( ) == null ) return false ; if ( other . getServiceCertificates ( ) != null && other . getServiceCertificates ( ) . equals ( this . getServiceCertificates ( ) ) == false ) return false ; return true ; }
te	1	public int hashCode ( ) { int _hashCode = 0 ; if ( msgType != null ) { _hashCode = 29 * _hashCode + msgType . hashCode ( ) ; } return _hashCode ; }
te	8	public boolean preValidate ( ) { final Map < String , Integer > neededKeys = Maps . newHashMap ( ) ; final Map < String , Integer > availableKeys = Maps . newHashMap ( ) ; for ( String key : startKeys ) { if ( ! availableKeys . containsKey ( key ) ) { availableKeys . put ( key , 0 ) ; } availableKeys . put ( key , availableKeys . get ( key ) + 1 ) ; } for ( Chest chest : chests ) { if ( ! neededKeys . containsKey ( chest . getOpenKey ( ) ) ) { neededKeys . put ( chest . getOpenKey ( ) , 0 ) ; } neededKeys . put ( chest . getOpenKey ( ) , neededKeys . get ( chest . getOpenKey ( ) ) + 1 ) ; for ( String key : chest . getContainedKeys ( ) ) { if ( ! availableKeys . containsKey ( key ) ) { availableKeys . put ( key , 0 ) ; } availableKeys . put ( key , availableKeys . get ( key ) + 1 ) ; } } for ( Map . Entry < String , Integer > needed : neededKeys . entrySet ( ) ) { final int available = availableKeys . get ( needed . getKey ( ) ) ; if ( available < needed . getValue ( ) ) { return false ; } } return true ; }
te	9	@ Override protected boolean perform ( final CommandSender sender , final Command command , final String label , final List < String > args , final Region region ) { if ( region == null ) { Main . courier . send ( sender , "requires-working-region" ) ; return true ; } if ( args . size ( ) >= 1 ) { Main . courier . send ( sender , "farewell-previous" , ( region . farewell != null ? region . farewell : "\u00A7onull\u00A7r" ) ) ; if ( args . get ( 0 ) . equals ( "default" ) ) { region . farewell = null ; } else { region . farewell = Executor . join ( args , " " ) ; if ( sender . hasPermission ( "simpleregions.message.color" ) ) region . farewell = ChatColor . translateAlternateColorCodes ( & , region . farewell ) ; } this . catalog . repository . saveRegion ( region , false ) ; Main . courier . send ( sender , "farewell" ) ; } Main . courier . send ( sender , "farewell-existing" , ( region . farewell != null ? region . farewell : "\u00A7onull\u00A7r" ) ) ; Main . courier . send ( sender , "farewell-example" ) ; if ( region . farewell == null ) { Main . courier . send ( sender , "farewell-default" , region . name , region . hasAccess ( sender ) ? 1 : 0 ) ; } else if ( region . farewell . length ( ) > 0 ) { Main . courier . send ( sender , "farewell-custom" , region . name , region . hasAccess ( sender ) ? 1 : 0 , region . farewell ) ; } return true ; }
te	5	public Object getValue ( Object value ) { if ( value == null ) return null ; String str = value . toString ( ) ; switch ( this ) { case boolean : return boolean . parseBoolean ( str ) ; case INTEGER : return Integer . parseInt ( str ) ; case STRING : return str ; case float : return float . parseFloat ( str ) ; } return value ; }
te	6	public void findAllChildrenByName ( ArrayList < Tag > result , String name , boolean recursive ) { if ( result == null ) { result = new ArrayList < Tag > ( ) ; } if ( tags . values ( ) != null ) { for ( Tag t : tags . values ( ) ) { if ( t . getName ( ) != null ) { if ( t . getName ( ) . equals ( name ) ) { result . add ( t ) ; } } if ( recursive ) { t . findAllChildrenByName ( result , name , true ) ; } } } }
te	6	@ Override public void propertyChange ( PropertyChangeEvent evt ) { if ( programExit ) if ( evt . getPropertyName ( ) . equals ( "state" ) && ( evt . getNewValue ( ) ) . toString ( ) . equals ( "DONE" ) ) { System . exit ( 0 ) ; } if ( makeNewDocument ) if ( evt . getPropertyName ( ) . equals ( "state" ) && ( evt . getNewValue ( ) ) . toString ( ) . equals ( "DONE" ) ) { initNewDocument ( ) ; } }
