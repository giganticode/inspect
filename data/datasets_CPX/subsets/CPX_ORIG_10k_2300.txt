tr	2	public String getHeader ( String key ) { for ( Header h : headers ) { if ( h . getName ( ) . equals ( key ) ) { return h . getValue ( ) ; } } return null ; }
tr	7	public String getOrder ( String first , String second ) { List < Character > ordered = new ArrayList < Character > ( ) ; int i = 0 ; int j = 0 ; while ( i < first . length ( ) && j < second . length ( ) ) { char f = first . charAt ( i ) ; char s = second . charAt ( j ) ; if ( f == s ) { ordered . add ( f ) ; i ++ ; } else { if ( f == W ) { ordered . add ( f ) ; i ++ ; } else { ordered . add ( s ) ; j ++ ; } } } while ( i < first . length ( ) ) { ordered . add ( first . charAt ( i ) ) ; i ++ ; } while ( j < second . length ( ) ) { ordered . add ( second . charAt ( j ) ) ; j ++ ; } StringBuilder stringBuilder = new StringBuilder ( ordered . size ( ) ) ; for ( int k = 0 ; k < ordered . size ( ) ; k ++ ) { stringBuilder . append ( ordered . get ( k ) ) ; } return stringBuilder . toString ( ) ; }
tr	9	protected TextIDPair readNextDocText ( BufferedReader docIn ) throws IOException { String line = docIn . readLine ( ) ; while ( line != null && ! line . startsWith ( ".I" ) ) { line = docIn . readLine ( ) ; } if ( line == null ) { return null ; } else { String [ ] parts = line . split ( "\\s+" ) ; if ( parts . length != 2 ) { throw new RuntimeException ( "CranfieldReader::Problems finding docID: " + line ) ; } int docID = Integer . parseInt ( parts [ 1 ] ) ; line = docIn . readLine ( ) ; while ( line != null && ! line . startsWith ( ".W" ) ) { line = docIn . readLine ( ) ; } if ( line == null ) { return null ; } else { StringBuffer buffer = new StringBuffer ( ) ; line = docIn . readLine ( ) ; while ( line != null && ! line . equals ( "<END_DOC>" ) ) { buffer . append ( " " + line ) ; line = docIn . readLine ( ) ; } return new TextIDPair ( buffer . toString ( ) , docID ) ; } } }
tr	6	@ Override public Object eval ( OclContext context ) throws OclEvaluationException { if ( "String" . equals ( this . referredType ) ) { return String . class ; } else if ( "Boolean" . equals ( this . referredType ) ) { return boolean . class ; } else if ( "Integer" . equals ( this . referredType ) ) { return Integer . class ; } else if ( "Real" . equals ( this . referredType ) ) { return double . class ; } else if ( "OclVoid" . equals ( this . referredType ) ) { return void . class ; } else if ( "OclAny" . equals ( this . referredType ) ) { return Object . class ; } else { return context . getType ( this . referredType ) ; } }
tr	1	@ Test public void basicNewBoard ( ) throws Exception { Thread t1 = new Thread ( new Runnable ( ) { public void run ( ) { Server server ; try { server = new Server ( 4444 ) ; server . serve ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } } ) ; t1 . start ( ) ; Client client = new Client ( "localhost" , 4444 ) ; ClientReceiveProtocol protocol = client . getClientReceiveProtocol ( ) ; String input = "newBoard board true" ; protocol . testHandleRequest ( input ) ; assertTrue ( client . getBoardSuccessful ( ) . containsKey ( "board" ) ) ; assertTrue ( client . getBoardSuccessful ( ) . get ( "board" ) . getValue ( ) == true ) ; }
tr	5	@ Override public void run ( ) { while ( true ) { try { for ( BlockLocationPair p : deletionQueue ) { String nodeLocation = p . nodeLocation ; String blockName = p . blockName ; String [ ] ipPort ; try { ipPort = AddressToIPPort . addressToIPPort ( nodeLocation ) ; Message inputMessage = new Message ( "remove" ) ; inputMessage . fileName = blockName ; Communicator . sendMessage ( ipPort [ 0 ] , Integer . parseInt ( ipPort [ 1 ] ) , inputMessage ) ; } catch ( NumberFormatException | IOException e ) { e . printStackTrace ( ) ; throw new IOException ( "Could not delete distributed file block " + blockName + "\n " + e . getMessage ( ) ) ; } } } catch ( Exception e ) { Logger . log ( "Error encountered while deleting distributed file: " + e . getMessage ( ) ) ; e . printStackTrace ( ) ; } try { Thread . sleep ( 3000 ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } }
tr	2	@ Override public V get ( K key ) { if ( key == null ) { throw new IllegalArgumentException ( ) ; } int index = index ( key ) ; return table [ index ] == null ? null : table [ index ] . get ( key ) ; }
tr	6	public List < CommitDiff > getDiffTreeFromFirstCommit ( String fileID , String commitID ) { try { List < CommitDiff > CommitList = new ArrayList < CommitDiff > ( ) ; String sql = "SELECT file_id  new_commit_id  old_commit_id  diff_text  char_start  char_end  diff_type from commits natural join file_diffs where " + "file_id=? and " + "(branch_id=? or branch_id is NULL) and commit_date<= " + "(select commit_date from commits where commit_id=? and " + "(branch_id=? OR branch_id is NULL) limit 1) AND new_commit_id= commit_id ORDER BY old_commit_id  new_commit_id" ; ISetter [ ] parms = { new StringSetter ( 1 , fileID ) , new StringSetter ( 2 , this . branchID ) , new StringSetter ( 3 , commitID ) , new StringSetter ( 4 , this . branchID ) } ; PreparedStatementExecutionItem ei = new PreparedStatementExecutionItem ( sql , parms ) ; addExecutionItem ( ei ) ; ei . waitUntilExecuted ( ) ; ResultSet rs = ei . getResult ( ) ; if ( ! rs . next ( ) ) return CommitList ; String currentNewCommitId = rs . getString ( "new_commit_id" ) ; String currentOldCommitId = rs . getString ( "old_commit_id" ) ; String currentFileId = rs . getString ( "file_id" ) ; String currentDiffTxt = rs . getString ( "diff_text" ) ; String currentDiffType = rs . getString ( "diff_type" ) ; int currentCharStart = rs . getInt ( "char_start" ) ; int currentCharEnd = rs . getInt ( "char_end" ) ; List < FileDiff > currentFileDiffList = new ArrayList < FileDiff > ( ) ; CommitDiff currentCommitDiff = new CommitDiff ( currentNewCommitId , currentOldCommitId , currentFileDiffList ) ; DiffEntry de = new DiffEntry ( currentFileId , currentNewCommitId , currentOldCommitId , currentDiffTxt , currentCharStart , currentCharEnd , currentDiffType ) ; FileDiff currentFileDiff = new FileDiff ( currentFileId , new ArrayList < DiffEntry > ( ) ) ; currentFileDiff . addDiffEntry ( de ) ; while ( rs . next ( ) ) { String newCommitId = rs . getString ( "new_commit_id" ) ; String oldCommitId = rs . getString ( "old_commit_id" ) ; String fileId = rs . getString ( "file_id" ) ; String diffTxt = rs . getString ( "diff_text" ) ; String diffType = rs . getString ( "diff_type" ) ; int charStart = rs . getInt ( "char_start" ) ; int charEnd = rs . getInt ( "char_end" ) ; if ( newCommitId . equals ( currentNewCommitId ) && oldCommitId . equals ( currentOldCommitId ) ) { if ( fileId . equals ( currentFileId ) ) { currentFileDiff . addDiffEntry ( new DiffEntry ( fileId , newCommitId , oldCommitId , diffTxt , charStart , charEnd , diffType ) ) ; } else { currentCommitDiff . addFileDiff ( currentFileDiff ) ; currentFileDiff = new FileDiff ( fileId , new ArrayList < DiffEntry > ( ) ) ; currentFileId = fileId ; } } else { currentCommitDiff . addFileDiff ( currentFileDiff ) ; CommitList . add ( currentCommitDiff ) ; currentCommitDiff = new CommitDiff ( newCommitId , oldCommitId , new ArrayList < FileDiff > ( ) ) ; currentNewCommitId = newCommitId ; currentOldCommitId = oldCommitId ; currentFileDiff = new FileDiff ( fileId , new ArrayList < DiffEntry > ( ) ) ; currentFileId = fileId ; currentFileDiff . addDiffEntry ( new DiffEntry ( fileId , newCommitId , oldCommitId , diffTxt , charStart , charEnd , diffType ) ) ; } } currentCommitDiff . addFileDiff ( currentFileDiff ) ; CommitList . add ( currentCommitDiff ) ; return CommitList ; } catch ( SQLException e ) { e . printStackTrace ( ) ; return null ; } }
tr	9	public static void arraycopy ( final float [ ] src , final int srcPos , final FloatLargeArray dest , final long destPos , final long length ) { if ( srcPos < 0 || srcPos >= src . length ) { throw new ArrayIndexOutOfBoundsException ( "srcPos < 0 || srcPos >= src.length" ) ; } if ( destPos < 0 || destPos >= dest . length ( ) ) { throw new ArrayIndexOutOfBoundsException ( "destPos < 0 || destPos >= dest.length()" ) ; } if ( length < 0 ) { throw new IllegalArgumentException ( "length < 0" ) ; } if ( dest . isConstant ( ) ) { throw new IllegalArgumentException ( "Constant arrays cannot be modified." ) ; } int i = srcPos ; int nthreads = ( int ) Math . min ( length , Runtime . getRuntime ( ) . availableProcessors ( ) ) ; if ( nthreads < 2 || length < 100000 ) { for ( long j = destPos ; j < destPos + length ; j ++ ) { dest . setFloat ( j , src [ i ++ ] ) ; } } else { long k = length / nthreads ; Thread [ ] threads = new Thread [ nthreads ] ; for ( int j = 0 ; j < nthreads ; j ++ ) { final long firstIdx = j * k ; final long lastIdx = ( j == nthreads - 1 ) ? length : firstIdx + k ; threads [ j ] = new Thread ( new Runnable ( ) { @ Override public void run ( ) { for ( long k = firstIdx ; k < lastIdx ; k ++ ) { dest . setFloat ( destPos + k , src [ srcPos + ( int ) k ] ) ; } } } ) ; threads [ j ] . start ( ) ; } try { for ( int j = 0 ; j < nthreads ; j ++ ) { threads [ j ] . join ( ) ; threads [ j ] = null ; } } catch ( InterruptedException ex ) { for ( long j = destPos ; j < destPos + length ; j ++ ) { dest . setFloat ( j , src [ i ++ ] ) ; } } } }
tr	9	public static String getDescription ( short value ) { String description = "Undefined" ; switch ( value ) { case FVB : description = "FVB" ; break ; case RVB : description = "RVB" ; break ; case RPB : description = "RPB" ; break ; case FPB : description = "FPB" ; break ; case FVW : description = "FVW" ; break ; case RVW : description = "RVW" ; break ; case RPW : description = "RPW" ; break ; case FPW : description = "FPW" ; break ; case static : description = "Static" ; break ; case OTHER : description = "Other" ; break ; } return description ; }
tr	5	public static < E , C extends Collection < E >> C removeAll ( final C subject , final Collection < ? > elements ) { Iterator < ? > it = subject . iterator ( ) ; while ( it . hasNext ( ) ) { if ( elements . contains ( it . next ( ) ) ) { it . remove ( ) ; } } try { subject . removeAll ( elements ) ; } catch ( final ClassCastException | NullPointerException ignored ) { } return subject ; }
tr	0	public String getObservacoes ( ) { return observacoes ; }
tr	7	@ Override protected boolean evaluteBids ( ) { final List < BidData > bids = getAgent ( ) . getNewBids ( ) ; if ( bids . size ( ) == 0 ) { return false ; } else if ( bids . size ( ) == 1 ) { BidData bidData = bids . get ( 0 ) ; if ( bidData . getAmount ( ) == getAuctionData ( ) . getAmount ( ) ) { PerstDatabase . INSTANCE ( ) . getDB ( ) . beginTransaction ( ) ; getAuctionData ( ) . setAmount ( 0 ) ; getAuctionData ( ) . store ( ) ; PerstDatabase . INSTANCE ( ) . getDB ( ) . commitTransaction ( ) ; getAgent ( ) . setWon ( bidData ) ; return true ; } else if ( bidData . getAmount ( ) < getAuctionData ( ) . getAmount ( ) ) { PerstDatabase . INSTANCE ( ) . getDB ( ) . beginTransaction ( ) ; getAuctionData ( ) . setAmount ( getAuctionData ( ) . getAmount ( ) - bidData . getAmount ( ) ) ; getAuctionData ( ) . store ( ) ; PerstDatabase . INSTANCE ( ) . getDB ( ) . commitTransaction ( ) ; getAgent ( ) . setWon ( bidData ) ; } else { LOG . info ( "Amount too big" ) ; } getAgent ( ) . setEvaluated ( bidData ) ; return false ; } else { for ( BidData bidData : bids ) { if ( bidData . getAmount ( ) == getAuctionData ( ) . getAmount ( ) ) { getAuctionData ( ) . setAmount ( 0 ) ; getAgent ( ) . setWon ( bidData ) ; return true ; } else if ( bidData . getAmount ( ) < getAuctionData ( ) . getAmount ( ) ) { getAuctionData ( ) . setAmount ( getAuctionData ( ) . getAmount ( ) - bidData . getAmount ( ) ) ; getAgent ( ) . setWon ( bidData ) ; } else { LOG . info ( "Amount too big" ) ; } getAgent ( ) . setEvaluated ( bidData ) ; } PerstDatabase . INSTANCE ( ) . getDB ( ) . beginTransaction ( ) ; getAuctionData ( ) . store ( ) ; PerstDatabase . INSTANCE ( ) . getDB ( ) . commitTransaction ( ) ; return false ; } }
tr	7	@ Override public List < Predicat > createPredicats ( Request request , List < Predicat > predicats ) throws Exception { DataSetApplication dsApplication = ( DataSetApplication ) getContext ( ) . getAttributes ( ) . get ( "DataSetApplication" ) ; DataSet ds = dsApplication . getDataSet ( ) ; Form params = request . getResourceRef ( ) . getQueryAsForm ( ) ; boolean filterExists = true ; int i = 0 ; while ( filterExists ) { String index = TEMPLATE_PARAM . replace ( "#" , Integer . toString ( i ++ ) ) ; String formParam = params . getFirstValue ( index ) ; if ( formParam != null ) { String [ ] parameters = formParam . split ( "\\|" ) ; TYPE_COMPONENT [ ] types = TYPE_COMPONENT . values ( ) ; boolean trouve = false ; for ( TYPE_COMPONENT typeCmp : types ) { if ( typeCmp . name ( ) . equals ( parameters [ TYPE ] ) ) { trouve = true ; } } if ( trouve ) { if ( checkValues ( parameters ) ) { String varClassSeek = null ; double probValue = null ; try { varClassSeek = SQLUtils . escapeString ( values [ 0 ] ) ; probValue = double . valueOf ( values [ 1 ] ) ; } catch ( SitoolsException e ) { e . printStackTrace ( ) ; LOGGER . log ( Level . SEVERE , "Probleme lors de la r\u00E9cup\u00E9ration des valeurs dans le NThreeVariability  message d'erreur : " + e . getMessage ( ) ) ; } Predicat predicat = new Predicat ( ) ; predicat . setStringDefinition ( " AND (" + doubleQuote + tableName + doubleQuote + "." + varClass1 + " = " + "'" + varClassSeek + "'" + " AND " + doubleQuote + tableName + doubleQuote + "." + probClass1Col + " >= " + probValue + ") OR " + "(" + doubleQuote + tableName + doubleQuote + "." + varClass2 + " = " + "'" + varClassSeek + "'" + " AND " + doubleQuote + tableName + doubleQuote + "." + probClass2Col + " >= " + probValue + ") OR (" + doubleQuote + tableName + doubleQuote + "." + varClass3 + " = " + "'" + varClassSeek + "'" + " AND " + doubleQuote + tableName + doubleQuote + "." + probClass3Col + " >= " + probValue + ")" ) ; predicats . add ( predicat ) ; } } } else { filterExists = false ; } } return predicats ; }
tr	4	private List regenerateChildPaths ( Path path , List children , int currentSize , int newSize ) { if ( currentSize == 1 ) { workingPaths . remove ( path ) ; currentSize = 0 ; children = new ArrayList ( newSize ) ; pathsToChildPaths . put ( path , children ) ; } else if ( newSize == 1 ) { workingPaths . removeAll ( children ) ; workingPaths . add ( path ) ; pathsToChildPaths . remove ( path ) ; return Collections . EMPTY_LIST ; } while ( currentSize < newSize ) { Path child = new Path ( ) ; workingPaths . add ( child ) ; children . add ( child ) ; currentSize ++ ; } while ( currentSize > newSize ) { Path child = ( Path ) children . remove ( children . size ( ) - 1 ) ; workingPaths . remove ( child ) ; currentSize -- ; } return children ; }
tr	2	private void style2Rule ( Lexer lexer , Node node ) { AttVal styleattr , classattr ; String classname ; styleattr = node . getAttrByName ( "style" ) ; if ( styleattr != null ) { classname = findStyle ( lexer , node . element , styleattr . value ) ; classattr = node . getAttrByName ( "class" ) ; if ( classattr != null ) { classattr . value = classattr . value + " " + classname ; node . removeAttribute ( styleattr ) ; } else { styleattr . attribute = "class" ; styleattr . value = classname ; } } }
tr	6	private JsonSchema parse ( JsonNode rawSchema , URL currentSchemaLocation ) { if ( ! rawSchema . isObject ( ) ) { throw new IllegalArgumentException ( "A valid json schema must be an object" ) ; } JsonNode ref = rawSchema . get ( "$ref" ) ; if ( ref != null ) { URL referencedSchemaLocation ; try { referencedSchemaLocation = new URL ( currentSchemaLocation , ref . textValue ( ) ) ; } catch ( MalformedURLException e ) { throw new IllegalArgumentException ( "The schema reference is malformed" , e ) ; } scheduleSchemaForProcessing ( referencedSchemaLocation ) ; return new SchemaReference ( cache , referencedSchemaLocation ) ; } String type = rawSchema . get ( "type" ) . asText ( ) ; if ( isSimpleTypeSchema ( type ) ) { return parseSimpleTypeSchema ( rawSchema ) ; } else if ( isObjectSchema ( type ) ) { return parseObjectSchema ( rawSchema , currentSchemaLocation ) ; } else if ( isArraySchema ( type ) ) { return parseArraySchema ( rawSchema , currentSchemaLocation ) ; } throw new IllegalArgumentException ( "Illegal schema type " + type ) ; }
tr	4	public int numCoreArgs ( ) { int cnt = 0 ; for ( int i = 0 , n = arglbids . length ; i < n ; ++ i ) if ( arglbids [ i ] >= 0 && arglbs [ i ] . length ( ) < 3 && arglbs [ i ] . startsWith ( "A" ) ) ++ cnt ; return cnt ; }
tr	5	private void bendPaths ( ) { for ( int i = 0 ; i < orderedPaths . size ( ) ; i ++ ) { Path path = ( Path ) orderedPaths . get ( i ) ; Segment segment = null ; path . points . addPoint ( new Point ( path . start . x , path . start . y ) ) ; for ( int v = 0 ; v < path . grownSegments . size ( ) ; v ++ ) { segment = ( Segment ) path . grownSegments . get ( v ) ; Vertex vertex = segment . end ; if ( vertex != null && v < path . grownSegments . size ( ) - 1 ) { if ( vertex . type == Vertex . INNIE ) { vertex . count ++ ; path . points . addPoint ( vertex . bend ( vertex . count ) ) ; } else { path . points . addPoint ( vertex . bend ( vertex . totalCount ) ) ; vertex . totalCount -- ; } } } path . points . addPoint ( new Point ( path . end . x , path . end . y ) ) ; } }
tr	7	public static List < Integer > parse ( final JTextField inputField , final MainFrame mainFrame , final int count ) { try { final String input = inputField . getText ( ) ; String [ ] tokens = removeWhiteSpace ( input ) . split ( " " ) ; if ( tokens . length != count ) { tokens = input . split ( "\\s+" ) ; if ( tokens . length != count ) throw new IllegalArgumentException ( "Invalid number of arguments." ) ; } final List < Integer > result = new ArrayList < > ( ) ; for ( int i = 0 ; i < count ; ++ i ) { final int number = Integer . parseInt ( tokens [ i ] ) ; result . add ( number ) ; if ( ( number < Config . MIN_INT ) || ( number > Config . MAX_INT ) ) throw new NumberFormatException ( "Invalid range." ) ; } inputField . setBackground ( Color . white ) ; return result ; } catch ( IllegalArgumentException ex ) { String msg ; if ( count == 0 ) msg = "P\u0159\u00EDklad nem\u00E1 \u0159e\u0161en\u00ED." ; else msg = "Pros\u00EDm zadejte " + count + " celo\u010D\u00EDseln\u00E9 koeficienty odd\u011Blen\u00E9 mezerou." ; error ( inputField , mainFrame , msg . toString ( ) ) ; return new ArrayList < > ( ) ; } }
tr	7	@ Override public void mouseClicked ( MouseEvent e ) { JEditorPane editor = ( JEditorPane ) e . getSource ( ) ; if ( ! editor . isEditable ( ) && SwingUtilities . isLeftMouseButton ( e ) ) { Bias [ ] bias = new Bias [ 1 ] ; Point pt = new Point ( e . getX ( ) , e . getY ( ) ) ; int pos = editor . getUI ( ) . viewToModel ( editor , pt , bias ) ; if ( bias [ 0 ] == Position . Bias . Backward && pos > 0 ) pos -- ; if ( pos >= 0 ) { Element el = ( ( SwingBoxDocument ) editor . getDocument ( ) ) . getCharacterElement ( pos ) ; AttributeSet attr = el . getAttributes ( ) ; Anchor anchor = ( Anchor ) attr . getAttribute ( Constants . ATTRIBUTE_ANCHOR_REFERENCE ) ; if ( anchor != null && anchor . isActive ( ) ) createHyperLinkEvent ( editor , el , anchor , EventType . ACTIVATED ) ; } } }
tr	3	public Code getCodeByDescription ( String description ) { for ( Code code : codes ) { Map < String , String > localizedStrings = code . getDescription ( ) . getLocalizedStrings ( ) ; for ( String key : localizedStrings . keySet ( ) ) { if ( localizedStrings . get ( key ) . equalsIgnoreCase ( description ) ) { return code ; } } } return null ; }
tr	5	@ Override public int classify ( Pattern instance ) { double [ ] [ ] xM = Matrix . trans ( new double [ ] [ ] { Matrix . res ( instance . toDoubleVector ( ) , mean ) } ) ; double [ ] [ ] yM = Matrix . mult ( M , xM ) ; double [ ] [ ] yMCopy = new double [ yM . length ] [ 1 ] ; for ( int ix = 0 ; ix < yM . length ; ix ++ ) System . arraycopy ( yM [ ix ] , 0 , yMCopy [ ix ] , 0 , yM [ ix ] . length ) ; double max = - double . MAX_VALUE ; for ( int i = 0 ; i < yM . length ; i ++ ) { if ( yM [ i ] [ 0 ] > max ) { max = yM [ i ] [ 0 ] ; } } int result = - 1 ; for ( int j = 0 ; j < yM . length ; j ++ ) { if ( yM [ j ] [ 0 ] == max ) { yM [ j ] [ 0 ] = 1d ; result = j ; } else { yM [ j ] [ 0 ] = 0d ; } } return result ; }
tr	1	@ Override protected void put ( Message request , Message response ) { request . put ( Document . ID , request . get ( Vote . ID ) ) ; Message origVote = new Message ( request . getContext ( ) ) ; new PersistentDocumentService ( ) . doGet ( request , origVote ) ; Message updateReq = new Message ( request . getContext ( ) ) ; updateReq . putAllFields ( origVote . getFields ( ) ) ; updateReq . putAllReferences ( origVote . getReferences ( ) ) ; updateReq . put ( Vote . VOTE , request . get ( Vote . VOTE ) ) ; new PersistentDocumentService ( ) . doPut ( updateReq , response ) ; new AnswerService ( ) . doPut ( request , response ) ; if ( request . get ( Vote . VOTE ) . equals ( Vote . VOTE_UP ) ) { Message answerResponse = new Message ( request . getContext ( ) ) ; new AnswerService ( ) . doGet ( request , answerResponse ) ; request . put ( Profile . ID , answerResponse . get ( Document . AUTHOR ) ) ; request . put ( Profile . POINTS , "" + Vote . POINTS_FOR_VOTE_UP ) ; new ProfileService ( ) . doPut ( request , response ) ; } }
tr	7	private void setBtnAlta ( ) { btnAlta . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent ae ) { try { if ( "" . equals ( txtNom . getText ( ) ) ) { throw new NullPointerException ( ) ; } boolean tp = true ; if ( rbMens . isSelected ( ) ) { tp = false ; } else if ( rbTick . isSelected ( ) ) { tp = true ; } objFI . altaConvenio ( Integer . parseInt ( txtTipo . getText ( ) ) , txtNom . getText ( ) , Utilitaria . ConvertirCalendar ( calendarIni . getCalendar ( ) ) , Integer . parseInt ( txtValor . getText ( ) ) , tp ) ; JOptionPane . showMessageDialog ( rootPane , "Operaci\u00F3n Exitosa" ) ; setTableConvenios ( ) ; } catch ( NombreRepetidoException ex ) { JOptionPane . showMessageDialog ( rootPane , ex . getMessage ( ) ) ; } catch ( ParseException ex ) { Logger . getLogger ( MantenimientoConvenio . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( NumberFormatException ex ) { JOptionPane . showMessageDialog ( rootPane , "Uno o mas de los datos requeridos no ha sido ingresado." ) ; } catch ( NullPointerException ex ) { JOptionPane . showMessageDialog ( rootPane , "Uno o mas de los datos requeridos no ha sido ingresado." ) ; } } } ) ; }
tr	7	public boolean postMortem ( PostMortem pm ) { boolean result = true ; Symbol that = ( Symbol ) pm ; if ( this . integer != that . integer || this . weight != that . weight ) { return false ; } if ( ( this . back != null ) != ( that . back != null ) ) { return false ; } Symbol zero = this . zero ; Symbol one = this . one ; if ( zero == null ) { if ( that . zero != null ) { return false ; } } else { result = zero . postMortem ( that . zero ) ; } if ( one == null ) { if ( that . one != null ) { return false ; } } else { result = one . postMortem ( that . one ) ; } return result ; }
tr	8	public static void main ( String [ ] args ) { ConsistentGlobalProblemSetInitialisation starter = new ConsistentGlobalProblemSetInitialisation ( ) ; starter . initLanguage ( new char [ ] { 0 , 1 } , 10 , "(0|101|11(01)*(1|00)1|(100|11(01)*(1|00)0)(1|0(01)*(1|00)0)*0(01)*(1|00)1)*" ) ; int solutionFoundCounter = 0 ; int noSolutionFound = 0 ; List < long > cycleCount = new LinkedList < long > ( ) ; long tmpCycle ; long timeStamp ; int [ ] problemCount = new int [ 5 ] ; int [ ] candidatesCount = new int [ 5 ] ; int [ ] noCycles = new int [ 2 ] ; problemCount [ 0 ] = 10 ; problemCount [ 1 ] = 20 ; problemCount [ 2 ] = 30 ; problemCount [ 3 ] = 40 ; problemCount [ 4 ] = 50 ; candidatesCount [ 0 ] = 50 ; candidatesCount [ 1 ] = 100 ; candidatesCount [ 2 ] = 150 ; candidatesCount [ 3 ] = 200 ; candidatesCount [ 4 ] = 250 ; noCycles [ 0 ] = 250 ; noCycles [ 1 ] = 500 ; int pc = 0 ; int cc = 0 ; int nc = 0 ; for ( int x = 0 ; x < 10 ; x ++ ) { System . out . println ( "x:" + x ) ; for ( int n = 0 ; n < 25 ; n ++ ) { DateFormat df = new SimpleDateFormat ( "yyyy-MM-dd_HH_mm_ss" ) ; Logger l = new Logger ( "C_G_" + df . format ( new Date ( ) ) + ".log" , true ) ; pc = problemCount [ n % 5 ] ; cc = candidatesCount [ ( int ) Math . floor ( n / 5 ) ] ; nc = noCycles [ 1 ] ; l . log ( "Problem Count: " + pc ) ; l . log ( "CandidatesCount: " + cc ) ; l . log ( "Max Cycles: " + nc ) ; solutionFoundCounter = 0 ; noSolutionFound = 0 ; cycleCount = new LinkedList < long > ( ) ; for ( int i = 0 ; i < 100 ; i ++ ) { timeStamp = System . currentTimeMillis ( ) ; starter . initProblems ( pc ) ; starter . initCandidates ( cc ) ; tmpCycle = starter . startEvolution ( nc ) ; l . log ( i + ": finished (" + ( System . currentTimeMillis ( ) - timeStamp ) + "ms  " + tmpCycle + "cycles)" ) ; if ( starter . getWinner ( ) != null ) { GraphvizRenderer . renderGraph ( starter . getWinner ( ) . getObj ( ) , "winner.svg" ) ; solutionFoundCounter ++ ; cycleCount . add ( tmpCycle ) ; l . log ( i + ": Solution found." ) ; } else { noSolutionFound ++ ; l . log ( i + ": No solution found." ) ; } } long max = 0 ; long min = 10000 ; long sum = 0 ; for ( long no : cycleCount ) { sum += no ; max = ( no > max ? no : max ) ; min = ( no < min ? no : min ) ; } l . log ( "Solution Found: " + solutionFoundCounter ) ; l . log ( "Avg cycles: " + ( cycleCount . size ( ) > 0 ? sum / cycleCount . size ( ) : 0 ) ) ; l . log ( "Max cycles: " + max ) ; l . log ( "Min cycles: " + min ) ; l . log ( "No solution found: " + noSolutionFound ) ; l . finish ( ) ; } } }
tr	0	@ Override public Line getFirstLine ( ) { return this . getTitle ( ) . getLine ( ) ; }
tr	6	public Object convertFromJAXB ( Object value ) throws Exception { if ( value instanceof JAXBDict ) { value = dictAdapter . unmarshal ( ( JAXBDict ) value ) ; } else if ( value instanceof JAXBArray ) { value = arrayAdapter . unmarshal ( ( JAXBArray ) value ) ; } else if ( value instanceof JAXBTrue ) { value = boolean . true ; } else if ( value instanceof JAXBFalse ) { value = boolean . false ; } else if ( value instanceof JAXBDate ) { JAXBDate date = ( JAXBDate ) value ; value = DatatypeConverter . parseDateTime ( date . getValue ( ) ) . getTime ( ) ; } else if ( value instanceof JAXBData ) { JAXBData data = ( JAXBData ) value ; value = DatatypeConverter . parseBase64Binary ( data . getValue ( ) ) ; } return value ; }
tr	2	protected MemoryEfficientString subSequence ( int start , int end ) { if ( start < 0 || end > ( data . length ) ) { throw new IllegalArgumentException ( "Illegal range " + start + "-" + end + " for sequence of length " + data . length ) ; } byte [ ] newdata = new byte [ end - start ] ; System . arraycopy ( data , start , newdata , 0 , end - start ) ; return new MemoryEfficientString ( newdata ) ; }
tr	5	@ Override public boolean equals ( Object o ) { return o != null && o . getClass ( ) . equals ( this . getClass ( ) ) && ( ( ( ( EduAVLTree ) o ) . root == null && this . root == null ) || ( this . root != null && this . root . equals ( ( ( EduAVLTree ) o ) . root ) ) ) ; }
tr	5	public void decay ( ) { entities . clear ( ) ; for ( int b = 0 ; b < parts . size ( ) ; b ++ ) { if ( parts . get ( b ) . isContainer ( ) ) { entities . addAll ( parts . get ( b ) . getEntities ( ) ) ; } } if ( entities . size ( ) > 0 ) { for ( int e = 0 ; e < entities . size ( ) ; e ++ ) { if ( entities . get ( e ) . getBodyPart ( ) != null ) { entities . get ( e ) . getBodyPart ( ) . decay ( ) ; } } } }
tr	5	public static void main ( String [ ] args ) { r1 = new Thread ( ) { public void run ( ) { while ( i < 100 ) { if ( i % 10 == 0 ) { if ( r2 . isAlive ( ) ) r2 . notify ( ) ; else r2 . run ( ) ; } i ++ ; } r1 . interrupt ( ) ; r2 . interrupt ( ) ; } } ; r2 = new Thread ( ) { public void run ( ) { System . out . println ( i ) ; try { if ( r2 . isAlive ( ) ) { r2 . wait ( ) ; r1 . notify ( ) ; } } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } } ; r1 . run ( ) ; }
tr	5	@ Override public Map < StatsType , LongSummaryStatistics > call ( ) throws IOException { final LongSummaryStatistics initTimeStats = new LongSummaryStatistics ( ) ; final LongSummaryStatistics symbolTimeStats = new LongSummaryStatistics ( ) ; final LongSummaryStatistics decTimeStats = new LongSummaryStatistics ( ) ; final LongSummaryStatistics totalDecsStats = new LongSummaryStatistics ( ) ; final LongSummaryStatistics numDecFailsStats = new LongSummaryStatistics ( totalDecsStats ) ; final LongSummaryStatistics decFailTimeStats = new LongSummaryStatistics ( ) ; final ByteBuffer dataHeaderBuf = DataHeader . allocateNewBuffer ( ) ; final ByteBuffer symbolHeaderBuf = SymbolHeader . allocateNewBuffer ( ) ; for ( int n = 0 ; n < numIterations ; n ++ ) { dataHeaderBuf . clear ( ) ; readBytes ( dataHeaderBuf ) ; final DataHeader dataHeader = DataHeader . parseDataHeader ( dataHeaderBuf ) ; final FECParameters fecParams = dataHeader . getFECParams ( ) ; final int extraSymbols = dataHeader . getExtraSymbols ( ) ; final ByteBuffer symbolBuf = ByteBuffer . allocate ( fecParams . symbolSize ( ) ) ; final ArrayDataDecoder dataDec = initDataDecoder ( fecParams , extraSymbols , initTimeStats ) ; final int Z = dataDec . numberOfSourceBlocks ( ) ; for ( int sbn = 0 ; sbn < Z ; sbn ++ ) { final SourceBlockDecoder srcBlockDec = dataDec . decoderForSourceBlock ( sbn ) ; final int totalSymbols = srcBlockDec . numberOfSourceSymbols ( ) + extraSymbols ; for ( int i = 0 ; i < totalSymbols ; ) { symbolHeaderBuf . clear ( ) ; readBytes ( symbolHeaderBuf ) ; final SymbolHeader symbolHeader = SymbolHeader . parseSymbolHeader ( symbolHeaderBuf , fecParams , sbn ) ; final int firstESI = symbolHeader . getFECPayloadID ( ) . encodingSymbolID ( ) ; final int numSymbolsInPacket = symbolHeader . getNumSymbols ( ) ; for ( int s = 0 ; s < numSymbolsInPacket ; s ++ ) { symbolBuf . clear ( ) ; readBytes ( symbolBuf ) ; putSymbol ( srcBlockDec , firstESI + s , symbolBuf , symbolTimeStats , decTimeStats , decFailTimeStats , totalDecsStats , numDecFailsStats ) ; } i += numSymbolsInPacket ; } } checkData ( dataDec ) ; } final EnumMap < StatsType , LongSummaryStatistics > map = new EnumMap < > ( StatsType . class ) ; map . put ( StatsType . DECODER_INIT_TIME , initTimeStats ) ; map . put ( StatsType . SYMBOL_INPUT_TIME , symbolTimeStats ) ; map . put ( StatsType . DECODING_TIME , decTimeStats ) ; map . put ( StatsType . NUM_DECODING_FAILURES , numDecFailsStats ) ; if ( numDecFailsStats . getCount ( ) > 0 ) { map . put ( StatsType . DECODING_FAILURE_TIME , decFailTimeStats ) ; } return map ; }
tr	9	public JSONObject ( JSONTokener x ) throws JSONException { this ( ) ; char c ; String key ; if ( x . nextClean ( ) != { ) { throw x . syntaxError ( "A JSONObject text must begin with '{'" ) ; } for ( ; ; ) { c = x . nextClean ( ) ; switch ( c ) { case 0 : throw x . syntaxError ( "A JSONObject text must end with '}'" ) ; case } : return ; default : x . back ( ) ; key = x . nextValue ( ) . toString ( ) ; } c = x . nextClean ( ) ; if ( c != : ) { throw x . syntaxError ( "Expected a ':' after a key" ) ; } this . putOnce ( key , x . nextValue ( ) ) ; switch ( x . nextClean ( ) ) { case ; : case   : if ( x . nextClean ( ) == } ) { return ; } x . back ( ) ; break ; case } : return ; default : throw x . syntaxError ( "Expected a ' ' or '}'" ) ; } } }
tr	7	public static void lockInstance ( int port ) { if ( lockserver == null ) { try { lockserver = new ServerSocket ( port ) ; new Thread ( ) { @ Override public void run ( ) { while ( true ) { try { Socket socket = lockserver . accept ( ) ; ObjectInputStream in = new ObjectInputStream ( socket . getInputStream ( ) ) ; if ( window != null && in . readBoolean ( ) ) { window . setVisible ( true ) ; SwingUtilities . invokeLater ( new Runnable ( ) { @ Override public void run ( ) { window . setVisible ( true ) ; window . toFront ( ) ; window . requestFocus ( ) ; } } ) ; } in . close ( ) ; socket . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } } } . start ( ) ; } catch ( IOException e ) { try { Socket socket = new Socket ( Strings . getString ( InstanceLock . class , "0" ) , port ) ; ObjectOutputStream out = new ObjectOutputStream ( socket . getOutputStream ( ) ) ; out . writeBoolean ( true ) ; out . close ( ) ; socket . close ( ) ; } catch ( Exception e1 ) { } System . exit ( 0 ) ; } } }
tr	8	private LogItemParser parseComplexParser ( ) throws XMLStreamException { int event = reader . next ( ) ; LogItemParser parser = null ; LogParserBuilder builder = new LogParserBuilder ( ) ; while ( ! foundItemEnd ( event , "complex" ) ) { if ( event == XMLStreamConstants . START_ELEMENT ) { String elemName = reader . getLocalName ( ) ; if ( "simplesplittokenizer" . equals ( elemName ) ) { String splitStr = reader . getAttributeValue ( null , "splitStr" ) ; String start = reader . getAttributeValue ( null , "start" ) ; String stop = reader . getAttributeValue ( null , "stop" ) ; if ( splitStr != null ) { builder . withSimpleSplitTokenizer ( splitStr ) ; } else { builder . withSimpleSplitTokenizer ( start , stop ) ; } } else if ( "dateindexfinder" . equals ( elemName ) ) { String pattern = reader . getAttributeValue ( null , "pattern" ) ; String pos = reader . getAttributeValue ( null , "position" ) ; if ( pos != null ) { builder . withDateFinder ( pattern , Integer . parseInt ( pos ) ) ; } else { builder . withDateFinder ( pattern ) ; } } else if ( "maplinebuilder" . equals ( elemName ) ) { List < String > keys = parseKeys ( ) ; builder . withDateMapBuilder ( keys ) ; } } event = reader . next ( ) ; } parser = builder . build ( ) ; logItemClass = MapLogLine . class ; if ( parser == null ) { throw new XMLStreamException ( "Did not find a complete complex parser element" ) ; } return parser ; }
tr	5	@ Override protected void paintTabBackground ( Graphics g , int tabPlacement , int tabIndex , int x , int y , int w , int h , boolean isSelected ) { Graphics2D g2D = ( Graphics2D ) g ; GradientPaint gradientSel = new GradientPaint ( 0 , 0 , new Color ( 242 , 249 , 242 ) , 0 , y + h / 2 , new Color ( 217 , 237 , 246 ) ) ; GradientPaint gradientUnsel = new GradientPaint ( 0 , 0 , new Color ( 232 , 232 , 232 ) , 0 , y + h / 2 , new Color ( 205 , 205 , 205 ) ) ; switch ( tabPlacement ) { case LEFT : case RIGHT : case BOTTOM : break ; case TOP : default : xp = new int [ ] { x , x , x + 4 , x + w + 5 , x + w + 5 , x + w , x + w , x } ; yp = new int [ ] { y + h , y + 4 , y , y , y + 5 , y + 10 , y + h , y + h } ; break ; } shape = new Polygon ( xp , yp , xp . length ) ; if ( isSelected ) { g2D . setPaint ( gradientSel ) ; } else { g2D . setPaint ( gradientUnsel ) ; } g2D . fill ( shape ) ; }
tr	1	public static double rawToNumber ( Object value ) { if ( value instanceof double ) return ( double ) value ; return null ; }
tr	5	public static void main ( final String [ ] argv ) throws IOException { if ( argv . length == 0 ) { printInfoAndExit ( ) ; } else if ( "-index" . equals ( argv [ 0 ] ) && argv . length >= 4 ) { final int length = argv . length - 4 ; final String [ ] arrPKsToIgnore = new String [ length ] ; System . arraycopy ( argv , 4 , arrPKsToIgnore , 0 , length ) ; index ( argv [ 1 ] , argv [ 2 ] , argv [ 3 ] , arrPKsToIgnore ) ; } else if ( "-benchmark" . equals ( argv [ 0 ] ) && argv . length >= 3 ) { final int length = argv . length - 2 ; final String [ ] arrConfigFiles = new String [ length ] ; System . arraycopy ( argv , 2 , arrConfigFiles , 0 , length ) ; benchmark ( argv [ 1 ] , arrConfigFiles ) ; } else { printInfoAndExit ( ) ; } }
tr	8	public String getInput ( ) { String newName = null ; Scanner in = new Scanner ( System . in ) ; boolean valid = false ; while ( ! valid ) { newName = in . nextLine ( ) ; if ( newName == null || newName . length ( ) < 1 ) { continue ; } newName = newName . toUpperCase ( ) ; if ( newName . equals ( "Q" ) ) { return null ; } try { if ( newName . length ( ) < 3 ) { throw new PlayerException ( ErrorType . Error301 . getMessage ( ) ) ; } } catch ( PlayerException ex ) { ErrorType . displayErrorMsg ( ex . getMessage ( ) ) ; continue ; } try { if ( newName . length ( ) > 12 ) { throw new PlayerException ( ErrorType . Error302 . getMessage ( ) ) ; } } catch ( PlayerException ex ) { ErrorType . displayErrorMsg ( ex . getMessage ( ) ) ; continue ; } valid = true ; } return newName ; }
tr	6	public int longestConsecutive ( int [ ] num ) { int max = 0 ; if ( num == null ) return max ; Set < Integer > set = new HashSet < > ( ) ; for ( int i : num ) { set . add ( i ) ; } for ( int i : num ) { if ( set . contains ( i ) ) { set . remove ( i ) ; int start = i - 1 ; while ( set . contains ( start ) ) { set . remove ( start ) ; start -- ; } int end = i + 1 ; while ( set . contains ( end ) ) { set . remove ( end ) ; end ++ ; } max = Math . max ( max , end - start - 1 ) ; } } return max ; }
tr	6	public static String encodeParameters ( List < PostParameter > postParams , String splitter , boolean quot ) { StringBuffer buf = new StringBuffer ( ) ; for ( PostParameter param : postParams ) { if ( buf . length ( ) != 0 ) { if ( quot ) { buf . append ( "\"" ) ; } buf . append ( splitter ) ; } buf . append ( encode ( param . name ) ) . append ( "=" ) ; if ( quot ) { buf . append ( "\"" ) ; } buf . append ( encode ( param . value ) ) ; } if ( buf . length ( ) != 0 ) { if ( quot ) { buf . append ( "\"" ) ; } } return buf . toString ( ) ; }
tr	5	public static void tag ( Lexer lexer , Node tag ) { if ( tag != null ) { if ( tag . type == Node . StartTag ) tidyPrint ( lexer . errout , "<" + tag . element + ">" ) ; else if ( tag . type == Node . EndTag ) tidyPrint ( lexer . errout , "</" + tag . element + ">" ) ; else if ( tag . type == Node . DocTypeTag ) tidyPrint ( lexer . errout , "<!DOCTYPE>" ) ; else if ( tag . type == Node . TextNode ) tidyPrint ( lexer . errout , "plain text" ) ; else tidyPrint ( lexer . errout , tag . element ) ; } }
tr	6	private void process_interpage_shared_properties ( ) throws Exception { Set < String > unique_urls = inter_webpage_shared_tags . keySet ( ) ; for ( String url_1 : unique_urls ) { for ( String url_2 : unique_urls ) { if ( url_1 . equals ( url_2 ) == false ) { System . out . println ( "\n\n^^^^^^^^^ " + url_1 + " : " + url_2 + "\n" ) ; float url_similarity = score_mapset ( inter_webpage_shared_tags . get ( url_1 ) , inter_webpage_shared_tags . get ( url_2 ) ) ; if ( url_similarity > 12f ) { out . println ( "<" + url_1 + "> <http://knowledgebooks.com/rdf/high_similarity> <" + url_2 + "> ." ) ; } else if ( url_similarity > 5f ) { out . println ( "<" + url_1 + "> <http://knowledgebooks.com/rdf/medium_similarity> <" + url_2 + "> ." ) ; } else if ( url_similarity > 5f ) { out . println ( "<" + url_1 + "> <http://knowledgebooks.com/rdf/low_similarity> <" + url_2 + "> ." ) ; } } } } }
tr	8	@ Override public void execute ( Map < String , Object > map , MainFrame frame ) { System . out . println ( "Receive Confirm Msg" + map ) ; String origin = ( String ) map . get ( "Origin" ) ; Map < String , Object > reply = ( Map < String , Object > ) Utilities . deserialize ( ( byte [ ] ) map . get ( "Content" ) ) ; boolean isConfirmed = ( boolean ) reply . get ( "Reply" ) ; Integer event = ( Integer ) reply . get ( "Event" ) ; switch ( event ) { case Event . INVITATION : case Event . INVITATION_RO : Set < String > invitee = LocalInfo . getInviteeCandidate ( ) ; String ip = ( String ) reply . get ( "IP" ) ; Integer port = ( Integer ) reply . get ( "Port" ) ; if ( invitee . contains ( ip + ":" + port ) && isConfirmed ) { invitee . remove ( ip + ":" + port ) ; LocalInfo . addPeer ( origin , new Peer ( ip , port ) ) ; } break ; case Event . KICKOUT_REQEUST : String target = ( String ) reply . get ( "Target" ) ; VoteTool . vote ( origin ) ; if ( VoteTool . isComplete ( ) ) { LocalSender . sendKickoutCommandMsg ( target . getBytes ( ) ) ; } break ; case Event . LOCK_REQUEST : VoteTool . vote ( origin ) ; if ( VoteTool . isComplete ( ) ) { LocalSender . sendLockCommandMsg ( ) ; } break ; } }
tr	4	@ Override public Object getValueAt ( int rowIndex , int columnIndex ) { if ( columnIndex == 0 ) { return paginas . get ( rowIndex ) . getNombre ( ) ; } if ( columnIndex == 1 ) { return paginas . get ( rowIndex ) . getPeso ( ) ; } if ( columnIndex == 2 ) { return paginas . get ( rowIndex ) . getLineas ( ) ; } if ( columnIndex == 3 ) { return paginas . get ( rowIndex ) . getBody ( ) . replaceAll ( "<[^>]*>" , "" ) ; } return null ; }
tr	6	@ Override public void run ( ) { Player [ ] players = plugin . getServer ( ) . getOnlinePlayers ( ) ; Player player ; long configTime = plugin . getConfig ( ) . getInt ( "KICK_TIMER" ) * 60 * 1000 ; for ( int i = 0 ; ( players . length - 1 ) >= i ; i ++ ) { long lastMoved = 0 ; player = players [ i ] ; UserTable ut = plugin . getDatabase ( ) . find ( UserTable . class ) . where ( ) . ieq ( "userName" , player . getName ( ) ) . = ( "afk" , true ) . findUnique ( ) ; if ( ut == null ) { return ; } lastMoved = System . currentTimeMillis ( ) - ut . getAfkTime ( ) ; if ( player . isOp ( ) ) { if ( plugin . getConfig ( ) . getBoolean ( "KICK_OP" ) ) { if ( lastMoved > configTime ) { player . kickPlayer ( "Auto-Kick: You were afk too long..." ) ; } } } else { if ( lastMoved > configTime ) { player . kickPlayer ( "Auto-Kick: You were afk too long..." ) ; } } } }
tr	9	private boolean r_Step_1a ( ) { int among_var ; int v_1 ; ket = cursor ; among_var = find_among_b ( a_1 , 6 ) ; if ( among_var == 0 ) { return false ; } bra = cursor ; switch ( among_var ) { case 0 : return false ; case 1 : slice_from ( "ss" ) ; break ; case 2 : lab0 : do { v_1 = limit - cursor ; lab1 : do { if ( cursor <= limit_backward ) { break lab1 ; } cursor -- ; if ( cursor > limit_backward ) { break lab1 ; } slice_from ( "ie" ) ; break lab0 ; } while ( false ) ; cursor = limit - v_1 ; slice_from ( "i" ) ; } while ( false ) ; break ; case 3 : if ( cursor <= limit_backward ) { return false ; } cursor -- ; golab2 : while ( true ) { lab3 : do { if ( ! ( in_grouping_b ( g_v , 97 , 121 ) ) ) { break lab3 ; } break golab2 ; } while ( false ) ; if ( cursor <= limit_backward ) { return false ; } cursor -- ; } slice_del ( ) ; break ; } return true ; }
tr	4	public Descriptor compile ( SymbolTable table ) { Descriptor d = null ; if ( type instanceof IdentNode ) { String s = ( ( IdentNode ) type ) . getIdentName ( ) ; if ( s . equals ( "integer" ) ) { d = new SimpleTypeDescriptor ( Type . INTEGER ) ; } else if ( s . equals ( "boolean" ) ) { d = new SimpleTypeDescriptor ( Type . boolean ) ; } else if ( s . equals ( "string" ) ) { d = new SimpleTypeDescriptor ( Type . STRING ) ; } else { d = table . descriptorFor ( s ) ; } } else { d = type . compile ( table ) ; } IdentListNode n = ( IdentListNode ) node ; n . compileParams ( table , d ) ; typeOfSection = d ; return null ; }
tr	0	@ XmlElementDecl ( namespace = "" , name = "ship-request-date" ) public JAXBElement < String > createShipRequestDate ( String value ) { return new JAXBElement < String > ( _ShipRequestDate_QNAME , String . class , null , value ) ; }
tr	3	private void writeQNameAttribute ( java . lang . String namespace , java . lang . String attName , javax . xml . namespace . QName qname , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { java . lang . String attributeNamespace = qname . getNamespaceURI ( ) ; java . lang . String attributePrefix = xmlWriter . getPrefix ( attributeNamespace ) ; if ( attributePrefix == null ) { attributePrefix = registerPrefix ( xmlWriter , attributeNamespace ) ; } java . lang . String attributeValue ; if ( attributePrefix . trim ( ) . length ( ) > 0 ) { attributeValue = attributePrefix + ":" + qname . getLocalPart ( ) ; } else { attributeValue = qname . getLocalPart ( ) ; } if ( namespace . equals ( "" ) ) { xmlWriter . writeAttribute ( attName , attributeValue ) ; } else { registerPrefix ( xmlWriter , namespace ) ; xmlWriter . writeAttribute ( namespace , attName , attributeValue ) ; } }
tr	7	@ Override public int storeConfig ( ConfigData cd ) { Connection conn = null ; StringBuffer query = new StringBuffer ( ) ; int newConfigId = 0 ; try { conn = getConnection ( ) ; query . append ( "INSERT INTO config" ) . append ( "(user_id  " + "name ) " ) . append ( " VALUES " ) . append ( "('" + cd . getUserId ( ) + "'  '" + cd . getName ( ) + "')" ) ; ResultSet rs = executeUpdateGetKeys ( conn , query . toString ( ) ) ; if ( rs . next ( ) ) { newConfigId = rs . getInt ( 1 ) ; } rs . close ( ) ; TrackConfigAdaptor tca = driver . getTrackConfigAdaptor ( ) ; for ( int i = 0 ; i < cd . getTracks ( ) . length ; i ++ ) { cd . getTracks ( ) [ i ] . setConfigId ( newConfigId ) ; tca . storeTrackConfig ( cd . getTracks ( ) [ i ] ) ; } ConfigAttributeAdaptor caa = driver . getConfigAttributeAdaptor ( ) ; Attribute a ; int attribId = 0 ; Map < String , String [ ] > map = cd . getStrArrays ( ) ; for ( Map . Entry < String , String [ ] > entry : map . entrySet ( ) ) { String key = entry . getKey ( ) ; String [ ] val = entry . getValue ( ) ; for ( int j = 0 ; j < val . length ; j ++ ) { if ( ( a = caa . fetchAttribute ( key , val [ j ] ) ) == null ) { attribId = caa . storeAttribute ( key , val [ j ] ) ; } else { attribId = a . getId ( ) ; } caa . addAttributeToConfig ( attribId , newConfigId , true ) ; } } } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { if ( conn != null ) { close ( conn ) ; } } return newConfigId ; }
tr	5	private Entry findEquiv ( Object subtree , Object key ) { if ( subtree == null ) return null ; else if ( ! ( subtree instanceof Node ) ) { Object [ ] ary = ( Object [ ] ) subtree ; int bin_srch_res = binarySearch ( ary , key ) ; int found = bin_srch_res & BIN_SEARCH_FOUND_MASK ; int idx = bin_srch_res >> BIN_SEARCH_INDEX_SHIFT ; if ( found == BIN_SEARCH_FOUND ) return new Entry ( ary [ idx ] , ary [ idx + ( ary . length >> 1 ) ] ) ; else return null ; } else { Node node = ( Node ) subtree ; Object nkey = node . key ; int comp_res = compare ( key , nkey ) ; if ( comp_res == 0 ) return node ; else if ( comp_res < 0 ) return findEquiv ( node . left , key ) ; else return findEquiv ( node . right , key ) ; } }
tr	7	public BreakH ( GenericTreeNode < LayoutParserTreeElement > element , Direction dir , int x , int y , int height , int width ) { GenericTreeNode < LayoutParserTreeElement > parent = element . getParent ( ) ; LayoutParserTreeElement newElementData = new LayoutParserTreeElement ( ) ; int newLeft = element . getData ( ) . left ; int newRight = element . getData ( ) . right ; int newTop = y ; int newBottom = element . getData ( ) . bottom ; if ( dir == Direction . ASCENDING ) { newTop = height - y ; } newElementData . left = newLeft ; newElementData . right = newRight ; newElementData . top = newTop ; newElementData . bottom = newBottom ; newElementData . elementType = element . getData ( ) . elementType ; GenericTreeNode < LayoutParserTreeElement > newElement = new GenericTreeNode < LayoutParserTreeElement > ( ) ; newElement . setData ( newElementData ) ; parent . addChild ( newElement ) ; element . getData ( ) . bottom = newElementData . top ; List < GenericTreeNode < LayoutParserTreeElement >> children = element . getChildren ( ) ; for ( int i = children . size ( ) - 1 ; i >= 0 ; i -- ) { if ( dir == Direction . DESCENDING ) { if ( children . get ( i ) . getData ( ) . top < newElementData . bottom && children . get ( i ) . getData ( ) . top > newElementData . top ) { GenericTreeNode < LayoutParserTreeElement > rElement = children . get ( i ) ; element . removeChildAt ( i ) ; newElement . addChild ( rElement ) ; } } else { if ( children . get ( i ) . getData ( ) . top < element . getData ( ) . bottom && children . get ( i ) . getData ( ) . top > element . getData ( ) . top ) { GenericTreeNode < LayoutParserTreeElement > rElement = children . get ( i ) ; element . removeChildAt ( i ) ; newElement . addChild ( rElement ) ; } } } }
tr	5	@ SuppressWarnings ( "CallToThreadDumpStack" ) private void pegaCaminhoArquivoXML ( ) { try { File xml = new File ( "config.xml" ) ; boolean x = false ; while ( x != true ) { if ( xml . isFile ( ) && xml . exists ( ) ) { txtCaminhoArquivoXML . setBackground ( new java . awt . Color ( 50 , 255 , 50 ) ) ; txtCaminhoArquivoXML . setText ( xml . getAbsolutePath ( ) ) ; FileReader fileR = new FileReader ( xml ) ; try ( BufferedReader buffR = new BufferedReader ( fileR ) ) { String ip = buffR . readLine ( ) ; txtIPServidor . setText ( ip . substring ( ( ip . indexOf ( "<ipServidor>" ) + 12 ) , ip . lastIndexOf ( "</ipServidor>" ) ) ) ; String banco = buffR . readLine ( ) ; txtCaminhoBanco . setText ( banco . substring ( ( banco . lastIndexOf ( "<caminhoBanco>" ) + 14 ) , banco . lastIndexOf ( "</caminhoBanco>" ) ) ) ; } x = true ; } else if ( JOptionPane . showConfirmDialog ( null , "Arquivo de configura\u00E7\u00E3o n\u00E3o encontrado!\nDeseja criar?" , "Aten\u00E7\u00E3o!" , JOptionPane . YES_NO_OPTION ) == 0 ) { criaXML ( "[IP DO SERVIDOR]" , "[CAMINHO DO BANCO DE DADOS]" ) ; } else { txtCaminhoArquivoXML . setBackground ( new java . awt . Color ( 255 , 40 , 40 ) ) ; txtCaminhoArquivoXML . setText ( "O arquivo de configura\u00E7\u00E3o ainda n\u00E3o foi criado!" ) ; x = true ; } } } catch ( IOException | HeadlessException e ) { e . printStackTrace ( ) ; } }
tr	0	public void setIndId ( Integer indId ) { this . indId = indId ; }
tr	3	public char skipTo ( char to ) throws JSONException { char c ; try { long startIndex = this . index ; long startCharacter = this . character ; long startLine = this . line ; this . reader . mark ( 1000000 ) ; do { c = this . next ( ) ; if ( c == 0 ) { this . reader . reset ( ) ; this . index = startIndex ; this . character = startCharacter ; this . line = startLine ; return c ; } } while ( c != to ) ; } catch ( IOException exc ) { throw new JSONException ( exc ) ; } this . back ( ) ; return c ; }
tr	5	private void readFile ( String file ) { Employees = new BinarySearchTree < Employee > ( ) ; String line = "" ; Employee temp ; try ( BufferedReader reader = new BufferedReader ( new FileReader ( file ) ) ; ) { while ( ( line = reader . readLine ( ) ) != null ) { if ( ! line . trim ( ) . equals ( "" ) && ! line . trim ( ) . equals ( null ) ) { temp = parseEmployee ( line ) ; Employees . insert ( temp ) ; } } line = null ; reader . close ( ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }
tr	9	@ Override public Collection < ApiLocation > getLocationsWithMinerals ( ApiAuth < ? > character ) throws ApiException { Set < long > result = new TreeSet < long > ( ) ; api . setAuth ( character ) ; ApiConnector connector = EveApi . getConnector ( ) ; AssetListResponse response = connector . execute ( new ApiRequest ( ApiPath . CHARACTER , ApiPage . ASSET_LIST , 2 , character ) , new AssetListHandler ( ) , AssetListResponse . class ) ; Stack < EveAsset < ? >> assets = new Stack < EveAsset < ? >> ( ) ; assets . addAll ( response . getAll ( ) ) ; while ( ! assets . isEmpty ( ) ) { EveAsset < ? > asset = assets . pop ( ) ; if ( asset . getAssets ( ) != null ) { assets . addAll ( asset . getAssets ( ) ) ; } if ( isMineral ( asset ) && asset . getLocationID ( ) != null ) { result . add ( asset . getLocationID ( ) ) ; } } long [ ] objects = result . toArray ( new long [ 0 ] ) ; long [ ] ids = new long [ objects . length ] ; for ( int i = 0 ; i < ids . length ; i ++ ) { ids [ i ] = objects [ i ] ; } String join = StringUtils . join ( " " , ids ) ; Map < String , String > params = Collections . singletonMap ( "IDs" , join ) ; LocationsResponse locationsResponse = connector . execute ( new ApiRequest ( ApiPath . CHARACTER , ApiPage . LOCATIONS , 2 , character , params ) , new LocationsHandler ( ) , LocationsResponse . class ) ; return locationsResponse . getAll ( ) ; }
tr	4	private boolean sameDigits ( int n ) { String s1 = sortedNumber ( n ) ; String s2 = sortedNumber ( n * 2 ) ; String s3 = sortedNumber ( n * 3 ) ; String s4 = sortedNumber ( n * 4 ) ; String s5 = sortedNumber ( n * 5 ) ; String s6 = sortedNumber ( n * 6 ) ; return s1 . equals ( s2 ) && s1 . equals ( s3 ) && s1 . equals ( s4 ) && s1 . equals ( s5 ) && s1 . equals ( s6 ) ; }
tr	5	public static BigInteger check ( ) { for ( BigInteger a : primes ) { for ( BigInteger b : primes ) { for ( int i = 0 ; i < 80 ; i ++ ) { int sum = i * i + a . intValue ( ) * i + b . intValue ( ) ; BigInteger test = new BigInteger ( String . valueOf ( sum ) ) ; if ( ! sprimes . contains ( test ) ) { if ( i > max ) { max = i ; result = a . multiply ( b ) ; System . out . println ( max ) ; } break ; } } } } return result ; }
tr	4	@ Override @ Transactional public void revokeClassAccess ( class < ? > onWhat , ACLRights whatToDo , User fromWhom ) { ClassAce ace = aceDao . getClassAce ( fromWhom . getId ( ) , onWhat . getCanonicalName ( ) ) ; if ( ace != null ) { switch ( whatToDo ) { case READ : aceDao . deleteClassAce ( ace ) ; break ; case WRITE : ace . setRightsType ( ACLRights . READ ) ; break ; } } }
tr	8	private static int findTowerHeight ( Measurement [ ] guys ) { if ( guys == null || guys . length == 0 ) { return 0 ; } if ( guys . length == 1 ) { return 1 ; } MeasurementComp measureComparator = new MeasurementComp ( ) ; Arrays . sort ( guys , measureComparator ) ; int maxSeq = 1 ; int currentSeq = 1 ; for ( int i = 1 ; i < guys . length ; i ++ ) { if ( guys [ i - 1 ] . x >= guys [ i ] . x || guys [ i - 1 ] . y >= guys [ i ] . y ) { if ( maxSeq < currentSeq ) { maxSeq = currentSeq ; } currentSeq = 0 ; } currentSeq ++ ; } if ( maxSeq < currentSeq ) { maxSeq = currentSeq ; } return maxSeq ; }
tr	4	private static int mergeSizes ( int oldValue , int newValue , boolean toMax ) { if ( oldValue == LayoutUtil . NOT_SET || oldValue == newValue ) return newValue ; if ( newValue == LayoutUtil . NOT_SET ) return oldValue ; return toMax != oldValue > newValue ? newValue : oldValue ; }
tr	2	String buildFromPattern ( String pattern , String main , String alt ) { StringBuffer sb = new StringBuffer ( ) ; char first = pattern . charAt ( 0 ) ; for ( char c : pattern . toCharArray ( ) ) { if ( c == first ) { sb . append ( main ) ; } else { sb . append ( alt ) ; } } return sb . toString ( ) ; }
tr	7	@ Override public String filterInsertedString ( FilterBypass fb , int offs , String str , AttributeSet a ) { String result = new String ( ) ; if ( negative && offs == 0 && str . charAt ( 0 ) == - ) { result = "-" ; } try { Document doc = fb . getDocument ( ) ; int firstDecimal = str . indexOf ( . ) ; if ( decimal && firstDecimal != - 1 && doc . getText ( 0 , doc . getLength ( ) ) . indexOf ( . ) == - 1 ) { result += str . substring ( 0 , firstDecimal ) . replaceAll ( "\\D" , "" ) ; result += . ; result += str . substring ( firstDecimal + 1 ) . replaceAll ( "\\D" , "" ) ; } else { result += str . replaceAll ( "\\D" , "" ) ; } } catch ( BadLocationException e ) { e . printStackTrace ( ) ; } return result ; }
tr	7	public static void habilitaCampos ( Container container ) { for ( Component component : container . getComponents ( ) ) { if ( component instanceof JTextComponent ) habilitaTextField ( ( JTextComponent ) component ) ; else if ( component instanceof JComboBox ) habilitaComponent ( component ) ; else if ( component instanceof JCheckBox ) habilitaComponent ( component ) ; else if ( component instanceof JRadioButton ) habilitaComponent ( component ) ; else if ( component instanceof JPanel ) habilitaCampos ( ( JPanel ) component ) ; else if ( component instanceof JScrollPane ) habilitaComponent ( ( JScrollPane ) component ) ; } }
tr	2	private Color toColor ( String s ) { if ( s == null ) { return null ; } else { Color col = ( Color ) COLOR_MAP . get ( s . toLowerCase ( ) ) ; if ( col != null ) { return col ; } else { int rgb = ( int ) long . parseLong ( s , 16 ) ; return new Color ( rgb , s . length ( ) == 8 ) ; } } }
tr	7	public void method464 ( Model model , boolean flag ) { anInt1626 = model . anInt1626 ; anInt1630 = model . anInt1630 ; anInt1642 = model . anInt1642 ; if ( anIntArray1622 . length < anInt1626 ) { anIntArray1622 = new int [ anInt1626 + 10000 ] ; anIntArray1623 = new int [ anInt1626 + 10000 ] ; anIntArray1624 = new int [ anInt1626 + 10000 ] ; } anIntArray1627 = anIntArray1622 ; anIntArray1628 = anIntArray1623 ; anIntArray1629 = anIntArray1624 ; for ( int k = 0 ; k < anInt1626 ; k ++ ) { anIntArray1627 [ k ] = model . anIntArray1627 [ k ] ; anIntArray1628 [ k ] = model . anIntArray1628 [ k ] ; anIntArray1629 [ k ] = model . anIntArray1629 [ k ] ; } if ( flag ) { anIntArray1639 = model . anIntArray1639 ; } else { if ( anIntArray1625 . length < anInt1630 ) anIntArray1625 = new int [ anInt1630 + 100 ] ; anIntArray1639 = anIntArray1625 ; if ( model . anIntArray1639 == null ) { for ( int l = 0 ; l < anInt1630 ; l ++ ) anIntArray1639 [ l ] = 0 ; } else { for ( int i1 = 0 ; i1 < anInt1630 ; i1 ++ ) anIntArray1639 [ i1 ] = model . anIntArray1639 [ i1 ] ; } } anIntArray1637 = model . anIntArray1637 ; anIntArray1640 = model . anIntArray1640 ; anIntArray1638 = model . anIntArray1638 ; anInt1641 = model . anInt1641 ; anIntArrayArray1658 = model . anIntArrayArray1658 ; anIntArrayArray1657 = model . anIntArrayArray1657 ; anIntArray1631 = model . anIntArray1631 ; anIntArray1632 = model . anIntArray1632 ; anIntArray1633 = model . anIntArray1633 ; anIntArray1634 = model . anIntArray1634 ; anIntArray1635 = model . anIntArray1635 ; anIntArray1636 = model . anIntArray1636 ; anIntArray1643 = model . anIntArray1643 ; anIntArray1644 = model . anIntArray1644 ; anIntArray1645 = model . anIntArray1645 ; }
tr	2	AnnotatedOption ( class clazz , Field field , Param param ) { this . clazz = clazz ; this . field = field ; this . param = param ; if ( param . option ( ) . isEmpty ( ) ) { opt = field . getName ( ) . substring ( 0 , 1 ) . toLowerCase ( ) ; } else { opt = param . option ( ) ; } if ( param . name ( ) . isEmpty ( ) ) { name = field . getName ( ) . toLowerCase ( ) ; } else { name = param . name ( ) ; } }
tr	9	public void renderTile ( int plane , int x , int y , int clippingPath , int clippingPathRotation , int textureId , int vertexHeightSW , int vertexHeightSE , int vertexHeightNE , int vertexHeightNW , int k2 , int l2 , int i3 , int j3 , int k3 , int l3 , int i4 , int j4 , int k4 , int l4 ) { if ( clippingPath == 0 ) { PlainTile tile = new PlainTile ( k2 , l2 , j3 , i3 , k4 , - 1 , false ) ; for ( int _z = plane ; _z >= 0 ; _z -- ) if ( groundArray [ _z ] [ x ] [ y ] == null ) groundArray [ _z ] [ x ] [ y ] = new Ground ( _z , x , y ) ; groundArray [ plane ] [ x ] [ y ] . plainTile = tile ; return ; } if ( clippingPath == 1 ) { PlainTile tile = new PlainTile ( k3 , l3 , j4 , i4 , l4 , textureId , vertexHeightSW == vertexHeightSE && vertexHeightSW == vertexHeightNE && vertexHeightSW == vertexHeightNW ) ; for ( int _z = plane ; _z >= 0 ; _z -- ) if ( groundArray [ _z ] [ x ] [ y ] == null ) groundArray [ _z ] [ x ] [ y ] = new Ground ( _z , x , y ) ; groundArray [ plane ] [ x ] [ y ] . plainTile = tile ; return ; } ShapedTile tile = new ShapedTile ( x , vertexHeightSW , vertexHeightSE , vertexHeightNW , vertexHeightNE , y , clippingPathRotation , textureId , clippingPath , k2 , k3 , l2 , l3 , j3 , j4 , i3 , i4 , l4 , k4 ) ; for ( int _z = plane ; _z >= 0 ; _z -- ) if ( groundArray [ _z ] [ x ] [ y ] == null ) groundArray [ _z ] [ x ] [ y ] = new Ground ( _z , x , y ) ; groundArray [ plane ] [ x ] [ y ] . shapedTile = tile ; }
tr	7	protected void encodeEntityReference ( String entityreference ) throws IOException { alignToOctet ( ) ; current_octet |= FastInfosetConstants . UNEXPANDED_ENTITY_IDENTIFICATION ; String systemid = null ; String publicid = null ; UnparsedEntity entity = UnParsedEntites . get ( entityreference ) ; if ( entity != null ) { systemid = entity . systemIdentifier ; publicid = entity . publicIdentifier ; } boolean encodesystemid = ( systemid != null ) && ! systemid . isEmpty ( ) ; boolean encodepublicid = ( publicid != null ) && ! publicid . isEmpty ( ) ; if ( encodesystemid ) { current_octet |= FastInfosetConstants . DOCUMENT_TYPE_SYSTEMID_PRESENCE ; } if ( encodepublicid ) { current_octet |= FastInfosetConstants . DOCUMENT_TYPE_PUBLICID_PRESENCE ; } flush_currentoctet ( ) ; encodeIdentifyingStringOrIndex ( entityreference , vocabulary . other_ncnames ) ; if ( encodesystemid ) { encodeIdentifyingStringOrIndex ( systemid , vocabulary . other_uris ) ; } if ( encodepublicid ) { encodeIdentifyingStringOrIndex ( publicid , vocabulary . other_uris ) ; } }
tr	0	public void run ( ) { txtComponent . select ( pos , pos2 ) ; }
tr	3	public synchronized void newShareAvailable ( ShareAvailability file ) { String hash = file . getFile ( ) . getHash ( ) ; System . out . println ( "new share available: " + hash ) ; if ( ! downloaded . contains ( hash ) && ! downloading . contains ( hash ) && ! queue . contains ( hash ) ) queue . add ( hash ) ; }
tr	5	private boolean isOk ( ) { if ( jTextField1 . toString ( ) . isEmpty ( ) ) { JOptionPane . showMessageDialog ( this , Constant . NAME_ERROR_MSG , "Error" , JOptionPane . ERROR_MESSAGE ) ; jTextField1 . grabFocus ( ) ; return false ; } if ( jComboBox3 . getSelectedIndex ( ) == 0 ) { JOptionPane . showMessageDialog ( this , Constant . TYPE_ERROR_MSG , "Error" , JOptionPane . ERROR_MESSAGE ) ; return false ; } if ( jFormattedTextField1 . toString ( ) . isEmpty ( ) ) { JOptionPane . showMessageDialog ( this , Constant . VALUE_ERROR_MSG , "Error" , JOptionPane . ERROR_MESSAGE ) ; jFormattedTextField1 . grabFocus ( ) ; return false ; } if ( jComboBox2 . getSelectedIndex ( ) == 0 ) { if ( process == 2 ) { JOptionPane . showMessageDialog ( this , Constant . PRIORITY_ERROR_MSG , "Error" , JOptionPane . ERROR_MESSAGE ) ; return false ; } } return true ; }
tr	9	public void check ( Lexer lexer , Node node , AttVal attval ) { String value ; value = attval . value ; if ( value == null ) Report . attrError ( lexer , node , attval . attribute , Report . MISSING_ATTR_VALUE ) ; else if ( Lexer . wstrcasecmp ( value , "top" ) == 0 || Lexer . wstrcasecmp ( value , "middle" ) == 0 || Lexer . wstrcasecmp ( value , "bottom" ) == 0 || Lexer . wstrcasecmp ( value , "baseline" ) == 0 ) { } else if ( Lexer . wstrcasecmp ( value , "left" ) == 0 || Lexer . wstrcasecmp ( value , "right" ) == 0 ) { if ( ! ( node . tag != null && ( ( node . tag . model & Dict . CM_IMG ) != 0 ) ) ) Report . attrError ( lexer , node , value , Report . BAD_ATTRIBUTE_VALUE ) ; } else if ( Lexer . wstrcasecmp ( value , "texttop" ) == 0 || Lexer . wstrcasecmp ( value , "absmiddle" ) == 0 || Lexer . wstrcasecmp ( value , "absbottom" ) == 0 || Lexer . wstrcasecmp ( value , "textbottom" ) == 0 ) { lexer . versions &= Dict . VERS_PROPRIETARY ; Report . attrError ( lexer , node , value , Report . PROPRIETARY_ATTR_VALUE ) ; } else Report . attrError ( lexer , node , value , Report . BAD_ATTRIBUTE_VALUE ) ; }
tr	6	@ Override public void inputProcess ( ) { if ( Key . UP . getPressingFrameCount ( ) % INPUT_INTERVAL == 0 ) { speedScale ++ ; } if ( Key . DOWN . getPressingFrameCount ( ) % INPUT_INTERVAL == 0 ) { speedScale -- ; } if ( Key . LEFT . getPressingFrameCount ( ) % INPUT_INTERVAL == 0 ) { speedScale -= 10 ; } if ( Key . RIGHT . getPressingFrameCount ( ) % INPUT_INTERVAL == 0 ) { speedScale += 10 ; } if ( Key . SPACE . isPressed ( ) ) { speedScale = 0 ; } if ( Key . S . isPressed ( ) ) { add ( new ShootingStarCharacter ( ) ) ; } }
tr	7	@ Override public Rectangle < Integer > calculateBounds ( Component comp ) { Rectangle < Integer > rc = new Rectangle < Integer > ( comp . getRequestedBounds ( ) ) ; if ( comp . getParent ( ) != null ) { Rectangle < Integer > parentBounds = comp . getParent ( ) . getActualBounds ( ) ; switch ( comp . getHorizontalAlignment ( ) ) { case LEFT : rc . setX1 ( rc . getX1 ( ) + parentBounds . getX1 ( ) ) ; rc . setX2 ( rc . getX2 ( ) + parentBounds . getX1 ( ) ) ; break ; case CENTER : rc . setX1 ( rc . getX1 ( ) + parentBounds . getX1 ( ) + ( parentBounds . getX2 ( ) - parentBounds . getX1 ( ) ) / 2 ) ; rc . setX2 ( rc . getX2 ( ) + parentBounds . getX1 ( ) + ( parentBounds . getX2 ( ) - parentBounds . getX1 ( ) ) / 2 ) ; break ; case RIGHT : rc . setX1 ( rc . getX1 ( ) + parentBounds . getX2 ( ) ) ; rc . setX2 ( rc . getX2 ( ) + parentBounds . getX2 ( ) ) ; break ; default : rc . setX1 ( rc . getX1 ( ) + parentBounds . getX1 ( ) ) ; rc . setX2 ( rc . getX2 ( ) + parentBounds . getX1 ( ) ) ; break ; } switch ( comp . getVerticalAlignment ( ) ) { case TOP : rc . setY1 ( rc . getY1 ( ) + parentBounds . getY2 ( ) ) ; rc . setY2 ( rc . getY2 ( ) + parentBounds . getY2 ( ) ) ; break ; case CENTER : rc . setY1 ( rc . getY1 ( ) + parentBounds . getY1 ( ) + ( parentBounds . getY2 ( ) - parentBounds . getY1 ( ) ) / 2 ) ; rc . setY2 ( rc . getY2 ( ) + parentBounds . getY1 ( ) + ( parentBounds . getY2 ( ) - parentBounds . getY1 ( ) ) / 2 ) ; break ; case BOTTOM : rc . setY1 ( rc . getY1 ( ) + parentBounds . getY1 ( ) ) ; rc . setY2 ( rc . getY2 ( ) + parentBounds . getY1 ( ) ) ; break ; default : rc . setY1 ( rc . getY1 ( ) + parentBounds . getY2 ( ) ) ; rc . setY2 ( rc . getY2 ( ) + parentBounds . getY2 ( ) ) ; break ; } } return rc ; }
tr	3	private boolean isConvex ( Point p1 , Point p2 , Point p3 ) { Point v = new Point ( p2 . x - p1 . x , p2 . y - p1 . y ) ; int res = p3 . x * v . y - p3 . y * v . x + v . x * p1 . y - v . y * p1 . x ; return ! ( ( res > 0 && isCw ) || ( res <= 0 && ! isCw ) ) ; }
tr	0	public Iterator < TextBlob > iterator ( int ii ) { return blobs . listIterator ( ii ) ; }
tr	5	public void send ( final String name , final String node , final OtpErlangObject msg ) { try { final String currentNode = home . node ( ) ; if ( node . equals ( currentNode ) ) { send ( name , msg ) ; } else if ( node . indexOf ( @ , 0 ) < 0 && node . equals ( currentNode . substring ( 0 , currentNode . indexOf ( @ , 0 ) ) ) ) { send ( name , msg ) ; } else { final OtpCookedConnection conn = home . getConnection ( node ) ; if ( conn == null ) { return ; } conn . send ( self , name , msg ) ; } } catch ( final Exception e ) { } }
tr	9	public ServiceId unmarshall ( final StaxUnmarshallerContext context ) throws Exception { ServiceId serviceId = new ServiceId ( ) ; int originalDepth = context . getCurrentDepth ( ) ; int targetDepth = originalDepth + 1 ; if ( context . isStartOfDocument ( ) ) targetDepth += 1 ; while ( true ) { XMLEvent xmlEvent = context . nextEvent ( ) ; if ( xmlEvent . isEndDocument ( ) ) return serviceId ; if ( xmlEvent . isAttribute ( ) || xmlEvent . isStartElement ( ) ) { if ( context . testExpression ( "partition" , targetDepth ) ) { serviceId . setPartition ( SimpleTypeStaxUnmarshallers . StringStaxUnmarshaller . getInstance ( ) . unmarshall ( context ) ) ; continue ; } if ( context . testExpression ( "name" , targetDepth ) ) { serviceId . setName ( SimpleTypeStaxUnmarshallers . StringStaxUnmarshaller . getInstance ( ) . unmarshall ( context ) ) ; continue ; } if ( context . testExpression ( "type" , targetDepth ) ) { serviceId . setType ( SimpleTypeStaxUnmarshallers . StringStaxUnmarshaller . getInstance ( ) . unmarshall ( context ) ) ; continue ; } if ( context . testExpression ( "fullName" , targetDepth ) ) { serviceId . setFullName ( SimpleTypeStaxUnmarshallers . StringStaxUnmarshaller . getInstance ( ) . unmarshall ( context ) ) ; continue ; } if ( context . testExpression ( "uri" , targetDepth ) ) { serviceId . setUri ( SimpleTypeStaxUnmarshallers . StringStaxUnmarshaller . getInstance ( ) . unmarshall ( context ) ) ; continue ; } } else if ( xmlEvent . isEndElement ( ) ) { if ( context . getCurrentDepth ( ) < originalDepth ) { return serviceId ; } } } }
tr	5	@ Override public void handMoved ( Skeleton s , long timeStamp ) { double [ ] shoulder = s . get3DJoint ( Skeleton . SHOULDER_RIGHT ) ; double [ ] hand = s . get3DJoint ( Skeleton . HAND_RIGHT ) ; double [ ] head = s . get3DJoint ( Skeleton . HEAD ) ; if ( ! waveStarted ) { if ( hand [ 0 ] > shoulder [ 0 ] && hand [ 1 ] > shoulder [ 1 ] && hand [ 1 ] < head [ 1 ] ) { waveStarted = true ; startTimeStamp = timeStamp ; currentTimeStamp = timeStamp ; waveStartCoordinate = hand ; waveEndCoordinate = hand ; } } else { if ( hand [ 1 ] < shoulder [ 1 ] ) { waveStarted = false ; } else { currentTimeStamp = timeStamp ; waveEndCoordinate = hand ; } } }
tr	3	private synchronized void connectTransport ( ) { if ( getState ( ) == STATE_INVALID ) return ; setState ( STATE_CONNECTING ) ; if ( protocols . contains ( WebsocketTransport . TRANSPORT_NAME ) ) transport = WebsocketTransport . create ( url , this ) ; else if ( protocols . contains ( XhrTransport . TRANSPORT_NAME ) ) transport = XhrTransport . create ( url , this ) ; else { error ( new SocketIOException ( "Server supports no available transports. You should reconfigure the server to support a available transport" ) ) ; return ; } transport . connect ( ) ; }
tr	1	public static long sum ( long ... values ) { long sum = 0 ; for ( long l : values ) { sum += l ; } return sum ; }
tr	8	public JSONArray ( JSONTokener x ) throws JSONException { this ( ) ; if ( x . nextClean ( ) != [ ) { throw x . syntaxError ( "A JSONArray text must start with '['" ) ; } if ( x . nextClean ( ) != ] ) { x . back ( ) ; for ( ; ; ) { if ( x . nextClean ( ) ==   ) { x . back ( ) ; this . myArrayList . add ( JSONObject . null ) ; } else { x . back ( ) ; this . myArrayList . add ( x . nextValue ( ) ) ; } switch ( x . nextClean ( ) ) { case ; : case   : if ( x . nextClean ( ) == ] ) { return ; } x . back ( ) ; break ; case ] : return ; default : throw x . syntaxError ( "Expected a ' ' or ']'" ) ; } } } }
tr	0	@ Test ( expected = TypeException . class ) public void structValue_MismatchFieldSize ( ) throws RecognitionException , IOException { addStructProgetto ( textLines ) ; textLines . add ( "p = struct progetto{999  true  struct data {false}}" ) ; testTypeChecking ( ) ; }
tr	1	static Point [ ] makePoints ( String representation ) { Point [ ] points = new Point [ representation . length ( ) ] ; Scanner sc = new Scanner ( representation ) ; int i = 0 ; while ( sc . hasNextDouble ( ) ) { points [ i ++ ] = p ( sc . nextDouble ( ) , sc . nextDouble ( ) ) ; } return Arrays . copyOf ( points , i ) ; }
tr	2	@ Override public String toString ( ) { final StringBuilder sb = new StringBuilder ( 2048 ) ; super . toString ( sb ) . append ( " { " ) ; for ( int i = 0 ; i < MAX ; i ++ ) { if ( stats [ i ] . count != 0 ) { sb . append ( "\n        " ) . append ( stats [ i ] . toString ( ) ) ; } } return sb . append ( " }" ) . toString ( ) ; }
tr	1	public int setRib ( String rib ) { if ( rib . length ( ) > ConfigGlobale . longueurRIB ) { return - 1 ; } else { this . rib = rib ; return 0 ; } }
tr	6	@ Override public Tipo validarSemantica ( ) throws Exception { Tipo izq , der ; izq = izquierdo . validarSemantica ( ) ; der = derecho . validarSemantica ( ) ; if ( izq instanceof TipoInt ) { if ( der instanceof TipoInt || der instanceof TipoFloat ) { return izq ; } else { throw new Exception ( "Error Semantico no se puede dividir un Tipo Int con un Tipo " + der . toString ( ) ) ; } } else if ( izq instanceof TipoFloat ) { if ( der instanceof TipoFloat || der instanceof TipoInt ) { return izq ; } else { throw new Exception ( "Error Semantico no se puede dividir un Tipo Float con un Tipo " + der . toString ( ) ) ; } } else { throw new Exception ( "Error Semantico no se puede dividir Tipo " + izq . toString ( ) + " con Tipo " + der . toString ( ) ) ; } }
tr	9	private static boolean isUnreserved ( char c ) { return ( c >= a && c <= z ) || ( c >= A && c <= Z ) || ( c >= 0 && c <= 9 ) || c == . || c == - || c == _ || c == ~ ; }
tr	6	public void addEdge ( int vi , int vj ) { Vertex vFrom = null ; Vertex vTo = null ; for ( Vertex v : vs ) { if ( v . vertex == vi ) { vFrom = v ; } if ( v . vertex == vj ) { vTo = v ; } } if ( vFrom == null ) { vFrom = new Vertex ( vi ) ; vs . add ( vFrom ) ; } if ( vi != vj ) { if ( vTo == null ) { vTo = new Vertex ( vj ) ; vs . add ( vTo ) ; } vFrom . adjacent . add ( vTo ) ; vTo . adjacent . add ( vFrom ) ; } else { vFrom . adjacent . add ( vFrom ) ; } }
tr	0	@ XmlElementDecl ( namespace = "com/firstdata/Merchant/gmfV3.10" , name = "OfferPubID" ) public JAXBElement < String > createOfferPubID ( String value ) { return new JAXBElement < String > ( _OfferPubID_QNAME , String . class , null , value ) ; }
tr	3	public NotebookJTableModel ( NotebookDao dbSource , String query ) { if ( dbSource == null ) { throw new IllegalArgumentException ( "Notebook table model ben\u00F6tigt eine Datenbankquelle != null" ) ; } this . dbSource = dbSource ; if ( query == null || query . trim ( ) . isEmpty ( ) ) { throw new IllegalArgumentException ( "Notebook table model query String darf nicht null oder leer sein!" ) ; } this . query = query ; this . getDBContents ( ) ; }
tr	5	private Stmt stmt ( ) throws SyntaxException { Stmt toBeReturned = null ; if ( isKind ( currentToken , IDENT ) ) { toBeReturned = assignStmt ( ) ; } else if ( isKind ( currentToken , pause ) ) { toBeReturned = pauseStmt ( ) ; } else if ( isKind ( currentToken , _while ) ) { toBeReturned = iterationStmt ( ) ; } else if ( isKind ( currentToken , _if ) ) { toBeReturned = alternativeStmt ( ) ; } else if ( isKind ( currentToken , ; ) ) { consume ( ) ; } else { throw new SyntaxException ( currentToken , "Either of " + Arrays . asList ( ; , IDENT , pause , _while , _if ) + " was expected here." ) ; } return toBeReturned ; }
tr	7	public static void main ( String [ ] args ) { String pathinput = "C:/Users/lin/Desktop/train_weibo_balanced.arff" ; String pathoutput = "C:/Users/lin/Desktop/train_weibo_balanced(chongxinbianUniqueID).arff" ; File file = new File ( pathinput ) ; BufferedReader reader = null ; try { reader = new BufferedReader ( new FileReader ( file ) ) ; String tempString = null ; OutputStreamWriter writer = new OutputStreamWriter ( new FileOutputStream ( pathoutput ) , "UTF-8" ) ; int num = 0 ; while ( ( tempString = reader . readLine ( ) ) != null ) { if ( tempString . contains ( " {0 " ) ) { String t = tempString . substring ( 4 , 5 ) ; for ( int i = 1 ; i < 7 ; i ++ ) { String begin = "  " + i + " " ; String end = "  " + ( i + 1 ) + " " ; t += " " + tempString . substring ( tempString . indexOf ( begin ) + begin . length ( ) , tempString . indexOf ( end ) ) ; } t += " " + num ++ ; for ( int i = 8 ; i < 207 ; i ++ ) { String begin = "  " + i + " " ; String end = "  " + ( i + 1 ) + " " ; t += " " + tempString . substring ( tempString . indexOf ( begin ) + begin . length ( ) , tempString . indexOf ( end ) ) ; } t += " " + tempString . substring ( tempString . indexOf ( "  207 " ) + 6 , tempString . indexOf ( " }" ) ) ; writer . write ( t + "\r\n" ) ; } else { writer . write ( tempString + "\r\n" ) ; } } reader . close ( ) ; writer . flush ( ) ; writer . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { if ( reader != null ) { try { reader . close ( ) ; } catch ( IOException e1 ) { } } } }
tr	5	public static BufferedImage getImage ( String fileName ) { BufferedImage i = null ; String path = "../images/" ; File f = null ; try { f = new File ( ResourceLoader . class . getResource ( path + fileName ) . getPath ( ) ) ; } catch ( NullPointerException e ) { Console . log ( "file + " + fileName + " is not there" , in . ERROR ) ; e . printStackTrace ( ) ; } if ( f != null && f . exists ( ) && ! f . isDirectory ( ) ) { try { i = ImageIO . read ( r . getClass ( ) . getClassLoader ( ) . getResource ( "images/" + fileName ) ) ; } catch ( Exception e ) { Console . log ( "image= " + fileName + " is not located here" , Console . in . ERROR ) ; e . printStackTrace ( ) ; } } return i ; }
tr	7	@ SuppressWarnings ( "unchecked" ) private static int countRunAndMakeAscending ( Object [ ] a , int lo , int hi ) { if ( DEBUG ) { assert lo < hi ; } int runHi = lo + 1 ; if ( runHi == hi ) { return 1 ; } if ( ( ( Comparable ) a [ runHi ++ ] ) . compareTo ( a [ lo ] ) < 0 ) { while ( runHi < hi && ( ( Comparable ) a [ runHi ] ) . compareTo ( a [ runHi - 1 ] ) < 0 ) { runHi ++ ; } reverseRange ( a , lo , runHi ) ; } else { while ( runHi < hi && ( ( Comparable ) a [ runHi ] ) . compareTo ( a [ runHi - 1 ] ) >= 0 ) { runHi ++ ; } } return runHi - lo ; }
