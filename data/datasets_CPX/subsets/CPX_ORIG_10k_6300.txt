va	9	public static boolean isXingzuo ( String str ) { if ( str . contains ( "\u661F\u5EA7" ) || str . contains ( "\u53CC\u9C7C" ) || str . contains ( "\u767D\u7F8A" ) || str . contains ( "\u91D1\u725B" ) || str . contains ( "\u53CC\u5B50" ) || str . contains ( "\u5DE8\u87F9" ) || str . contains ( "\u72EE\u5B50" ) || str . contains ( "\u5904\u5973" ) || str . contains ( "\u5929\u79E4" ) || str . contains ( "\u5929\u874E" ) || str . contains ( "\u5C04\u624B" ) || str . contains ( "\u6469\u7FAF" ) || str . contains ( "\u6C34\u74F6" ) ) return true ; return false ; }
va	5	public ShopConfigurationPanel ( ) { super ( ) ; setLayout ( new BorderLayout ( ) ) ; contents = new ShopData ( ) ; PropertySet ps = new PropertySet ( ) ; final FileProperty fpShopBackground = new FileProperty ( "Shop background image (160 \u00D7 120)" , null ) ; final FileProperty fpShopButtonImage = new FileProperty ( "Shop button up image (64 \u00D7 64)" , null ) ; final FileProperty fpShopButtonHover = new FileProperty ( "Shop button hover image" , null ) ; final FileProperty fpShopButtonPressed = new FileProperty ( "Button pressed image" , null ) ; final TextProperty tpUpgrade = new TextProperty ( "Upgrade text" , null ) ; final TextProperty tpNotEnoughMoney = new TextProperty ( "Not enough money text" , null ) ; final FileProperty fpPurchaseSound = new FileProperty ( "Purchase sound" , null ) ; final FileProperty fpInvalidPurchaseSound = new FileProperty ( "Invalid purchase sound" , null ) ; ps . add ( fpShopBackground ) ; ps . add ( null ) ; ps . add ( fpShopButtonImage ) ; ps . add ( fpShopButtonHover ) ; ps . add ( fpShopButtonPressed ) ; ps . add ( null ) ; ps . add ( tpUpgrade ) ; ps . add ( tpNotEnoughMoney ) ; ps . add ( null ) ; ps . add ( fpPurchaseSound ) ; ps . add ( fpInvalidPurchaseSound ) ; FileProperty [ ] images = { fpShopBackground , fpShopButtonImage , fpShopButtonHover , fpShopButtonPressed } ; for ( FileProperty imageProperty : images ) { imageProperty . setFilter ( ffImage ) ; } fpPurchaseSound . setFilter ( ffSoundWav ) ; fpInvalidPurchaseSound . setFilter ( ffSoundWav ) ; fpShopBackground . setDescription ( "The background image for the shop." ) ; fpShopButtonImage . setDescription ( "This is the button used for the background of shop items. It need not be optimized for nine-slice scaling." ) ; fpShopButtonHover . setDescription ( "This image will be displayed when the user's mouse pointer is over a shop button." ) ; fpShopButtonPressed . setDescription ( "This image will be displayed when the user is pressing a shop button." ) ; tpUpgrade . setDescription ( "The text to display on the \"purchase upgrade\" button." ) ; tpNotEnoughMoney . setDescription ( "The text to display on the \"purchase upgrade\" button when the user cannot afford the upgrade." ) ; fpPurchaseSound . setDescription ( "The sound played on a purchase or upgrade." ) ; fpInvalidPurchaseSound . setDescription ( "The sound played when the user cannot afford a purchase." ) ; ChangeListener cl = new ChangeListener ( ) { @ Override public void stateChanged ( ChangeEvent ce ) { if ( ! isUpdating ( ) ) { contents . shopBackground = fpShopBackground . getValue ( ) ; contents . shopButtonImage = fpShopButtonImage . getValue ( ) ; contents . shopButtonImageHover = fpShopButtonHover . getValue ( ) ; contents . shopButtonImagePressed = fpShopButtonPressed . getValue ( ) ; contents . doUpgrade = tpUpgrade . getValue ( ) ; contents . notEnoughMoney = tpNotEnoughMoney . getValue ( ) ; contents . purchaseSound = fpPurchaseSound . getValue ( ) ; contents . invalidPurchaseSound = fpInvalidPurchaseSound . getValue ( ) ; } } } ; for ( AbstractProperty < ? > p : ps ) { if ( p != null ) { p . addChangeListener ( cl ) ; } } rUpdate = new Runnable ( ) { @ Override public void run ( ) { fpShopBackground . setValue ( contents . shopBackground ) ; fpShopButtonImage . setValue ( contents . shopButtonImage ) ; fpShopButtonHover . setValue ( contents . shopButtonImageHover ) ; fpShopButtonPressed . setValue ( contents . shopButtonImagePressed ) ; tpUpgrade . setValue ( contents . doUpgrade ) ; tpNotEnoughMoney . setValue ( contents . notEnoughMoney ) ; fpPurchaseSound . setValue ( contents . purchaseSound ) ; fpInvalidPurchaseSound . setValue ( contents . invalidPurchaseSound ) ; } } ; add ( new PropertyPanel ( ps , true , false ) , BorderLayout . CENTER ) ; }
va	5	public static void decompress ( File in , File out ) throws Exception { File inFile = in ; File outFile = out ; BufferedInputStream inStream = new BufferedInputStream ( new FileInputStream ( inFile ) ) ; BufferedOutputStream outStream = new BufferedOutputStream ( new FileOutputStream ( outFile ) ) ; int propertiesSize = 5 ; byte [ ] properties = new byte [ propertiesSize ] ; if ( inStream . read ( properties , 0 , propertiesSize ) != propertiesSize ) { throw new Exception ( "input .lzma file is too short" ) ; } Decoder decoder = new Decoder ( ) ; if ( ! decoder . SetDecoderProperties ( properties ) ) { throw new Exception ( "Incorrect stream properties" ) ; } long outSize = 0 ; for ( int i = 0 ; i < 8 ; i ++ ) { int v = inStream . read ( ) ; if ( v < 0 ) { throw new Exception ( "Can't read stream size" ) ; } outSize |= v << 8 * i ; } if ( ! decoder . Code ( inStream , outStream , outSize ) ) { throw new Exception ( "Error in data stream" ) ; } outStream . flush ( ) ; outStream . close ( ) ; inStream . close ( ) ; }
va	8	double getIntegralValue ( Range boundaries ) { List < Range > valueRanges = new ArrayList < Range > ( ) ; for ( Range range : ranges ) { if ( range . includes ( boundaries . getLeft ( ) ) || range . includes ( boundaries . getRight ( ) ) || boundaries . includes ( range . getLeft ( ) ) || boundaries . includes ( range . getRight ( ) ) ) { valueRanges . add ( range ) ; } } double value = 0d ; for ( Range range : valueRanges ) { long rangeValue = data . get ( range ) ; if ( rangeValue == null ) { continue ; } if ( boundaries . includes ( range ) ) { value += rangeValue ; } else { value += getPartialValue ( range , rangeValue , boundaries ) ; } } return value ; }
va	5	public void run ( String demoName ) throws InstantiationException , IllegalAccessException , IllegalArgumentException , InvocationTargetException { Demo demo = demos . getDemo ( demoName ) ; if ( demo == null ) { throw new IllegalArgumentException ( "Demo: " + demoName + " does not exist!" ) ; } Method method = demo . getMethod ( ) ; class < ? > cls = method . getDeclaringClass ( ) ; Object obj = cls . newInstance ( ) ; class < ? > paramsTypes [ ] = method . getParameterTypes ( ) ; Object params [ ] = new Object [ paramsTypes . length ] ; int i = 0 ; for ( class < ? > pType : paramsTypes ) { Object param = pType . newInstance ( ) ; params [ i ] = param ; i ++ ; } method . invoke ( obj , params ) ; }
va	6	@ Override public void run ( ) { while ( shouldRun ) { try { Thread . sleep ( sleep ) ; game . next ( ) ; int eaten = game . checkFood ( ) ; if ( eaten > 0 ) { game . addEatables ( eaten ) ; } List < Snake > colliders = game . getColliders ( ) ; List < Snake > violators = game . getBoundaryViolators ( ) ; List < Snake > fullList = new Vector < Snake > ( ) ; fullList . addAll ( colliders ) ; fullList . addAll ( violators ) ; if ( fullList . size ( ) > 0 ) { game . removeSnakes ( fullList . toArray ( new Snake [ 0 ] ) ) ; game . updateClientRemoved ( fullList . toArray ( new Snake [ 0 ] ) ) ; } if ( game . getSnakeCount ( ) < 1 ) { System . out . println ( "Game " + gameID + ": No snake left in game  aborting ..." ) ; Snake winner = game . getWinner ( ) ; if ( winner != null ) { commIF . bcastWinner ( winner . getID ( ) , winner . getNick ( ) , winner . getScore ( ) ) ; System . out . println ( "Game " + gameID + ": Winner snake: " + game . getWinner ( ) + "!" ) ; } else { System . out . println ( "Game " + gameID + ": No winner snake!" ) ; } shouldRun = false ; } game . updateClientPositions ( ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } }
va	7	public static boolean checkFile ( int type , final String s ) { Matcher matcher = getMatcher ( type ) ; boolean res = true ; LineNumberReader lineReader = null ; InputStreamReader isr ; try { if ( s . equals ( "" ) ) { System . out . println ( "Reading from standard input." ) ; isr = new InputStreamReader ( System . in ) ; } else { System . out . println ( "Reading file " + s . toString ( ) ) ; isr = new FileReader ( new File ( s ) ) ; } lineReader = new LineNumberReader ( isr ) ; String line = null ; while ( ( line = lineReader . readLine ( ) ) != null ) { matcher . reset ( line ) ; if ( ! matcher . find ( ) ) { String msg = "Line " + lineReader . getLineNumber ( ) + " is bad: " + line ; res = false ; System . out . println ( msg ) ; } } } catch ( FileNotFoundException ex ) { ex . printStackTrace ( ) ; } catch ( IOException ex ) { ex . printStackTrace ( ) ; } finally { try { if ( lineReader != null ) lineReader . close ( ) ; } catch ( IOException ex ) { ex . printStackTrace ( ) ; } } return res ; }
va	7	@ Override public boolean step ( Entity intersectingEntity ) { if ( currentDir >= getDirectionList ( ) . size ( ) - 1 && power == distance || stopNextStep ) { setCreated ( true ) ; return false ; } if ( intersectingEntity instanceof DestructibleBlock || intersectingEntity instanceof Tower ) { stopNextStep = true ; } else if ( intersectingEntity instanceof Block ) { if ( currentDir == getDirectionList ( ) . size ( ) - 1 ) { setCreated ( true ) ; } else { currentDir ++ ; distance = 0 ; } return false ; } return true ; }
va	7	public static void makethefile ( String infile , String outfile , int rootnote , String temperamentstring , double maxpitchbend , boolean writemaxpitchbend , int selectProgram , int tuningroot , double tuningfrequency , int transposeamt , boolean overwrite ) throws MidiUnavailableException , InvalidMidiDataException , IOException { Sequence midiIn = null ; try { midiIn = MidiSystem . getSequence ( new File ( infile ) ) ; } catch ( Exception e ) { displayerror ( "Error opening midi file " + infile + " for reading" ) ; return ; } Sequence newMidi = RetuneMIDI . retunedSequence ( midiIn , rootnote , temperamentstring , maxpitchbend , writemaxpitchbend , selectProgram , false , tuningroot , tuningfrequency , transposeamt , 0 ) ; if ( newMidi == null ) { displayerror ( "Error generating new midi sequence" ) ; return ; } try { File f = new File ( outfile ) ; if ( ! overwrite ) { if ( f . exists ( ) && ! f . isDirectory ( ) ) { if ( ! getYesNo ( "File " + outfile + " exists.  Overwrite it?" ) ) { displayerror ( "No file written" ) ; return ; } } } MidiSystem . write ( newMidi , 1 , f ) ; } catch ( IOException e ) { displayerror ( "Problem writing to file " + outfile ) ; return ; } displaymessage ( "Done!  New midi file written to " + outfile ) ; }
va	6	public void render ( GameObject object , AbstractList < PostProgressEffect > postProgressEffects ) { renderToFrameBuffer ( object ) ; if ( ! postProgressEffects . isEmpty ( ) ) { boolean firstBuffer = false ; for ( int i = postProgressEffects . size ( ) - 1 ; i > 0 ; i -- ) { frameBuffer [ firstBuffer ? 0 : 1 ] . bind ( ) ; GL11 . glClear ( GL11 . GL_COLOR_BUFFER_BIT | GL11 . GL_DEPTH_BUFFER_BIT ) ; postProgressEffects . get ( i ) . renderFrameBuffer ( frameBuffer [ firstBuffer ? 1 : 0 ] ) ; frameBuffer [ firstBuffer ? 0 : 1 ] . unbind ( ) ; firstBuffer = ! firstBuffer ; } GL11 . glClear ( GL11 . GL_COLOR_BUFFER_BIT | GL11 . GL_DEPTH_BUFFER_BIT ) ; postProgressEffects . get ( 0 ) . renderFrameBuffer ( frameBuffer [ firstBuffer ? 1 : 0 ] ) ; } else { GL11 . glClear ( GL11 . GL_COLOR_BUFFER_BIT | GL11 . GL_DEPTH_BUFFER_BIT ) ; fallBack . renderFrameBuffer ( frameBuffer [ 0 ] ) ; } }
va	8	protected boolean handleOutgoingEvent ( ChannelEvent event ) throws Exception { if ( ! ( event instanceof ChannelStateEvent ) ) return false ; ChannelStateEvent stateEvent = ( ChannelStateEvent ) event ; switch ( stateEvent . getState ( ) ) { case CLOSE : close0 ( ) ; break ; case CONNECT : if ( stateEvent . getValue ( ) instanceof SocketAddress ) connect0 ( ( SocketAddress ) stateEvent . getValue ( ) ) ; break ; case DISCONNECT : disconnect ( ) ; break ; case BIND : if ( stateEvent . getValue ( ) instanceof SocketAddress ) bind0 ( ( SocketAddress ) stateEvent . getValue ( ) ) ; break ; case UNBIND : unbind0 ( ) ; break ; } event . getFuture ( ) . onSuccess ( ) ; return true ; }
va	9	public double pow ( double x , int n ) { if ( x == 0 && n == 0 ) { return Integer . MIN_VALUE ; } if ( x == 0 ) { return 0 ; } if ( n == 0 ) { return 1 ; } if ( n == 1 ) { return x ; } boolean aMinus = x < 0 ? true : false ; boolean bMinus = n < 0 ? true : false ; int bAbs = Math . abs ( n ) ; double aAbs = Math . abs ( x ) ; double tempAnswer ; if ( ( n & 1 ) != 0 ) { tempAnswer = pow ( aAbs , bAbs - 1 ) * aAbs ; } else { tempAnswer = pow ( aAbs * aAbs , bAbs / 2 ) ; } if ( bMinus ) { tempAnswer = 1.0 / tempAnswer ; } if ( aMinus && ( n & 1 ) != 0 ) { tempAnswer *= - 1 ; } return tempAnswer ; }
va	8	@ Override public void run ( ) { isRunning = true ; long start = System . currentTimeMillis ( ) ; ApplicationStatus . getInstance ( ) . clear ( ) ; PipedWriter inputFileWriter = null ; BufferedReader br = null ; try { inputFileWriter = new PipedWriter ( ) ; init ( inputFileWriter ) ; String line ; String [ ] tokens ; boolean firstBlankLineFound = false ; String pathString = ApplicationSetup . getInstance ( ) . getTopicFilePath ( ) + "/topic" + topic ; File file = new File ( pathString ) ; br = new BufferedReader ( new FileReader ( file ) ) ; firstBlankLineFound = false ; while ( ( line = br . readLine ( ) ) != null ) { tokens = line . split ( "\\s" ) ; for ( int i = 0 ; i < tokens . length ; i ++ ) { inputFileWriter . write ( tokens [ i ] + "\n" ) ; inputFileWriter . flush ( ) ; } } } catch ( Exception e ) { System . out . println ( e . getMessage ( ) ) ; } finally { try { if ( br != null ) { br . close ( ) ; } if ( inputFileWriter != null ) inputFileWriter . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } long end = System . currentTimeMillis ( ) ; System . out . println ( "reading files DONE in " ) ; System . out . println ( ( end - start ) / 1000 + " seconds" ) ; try { Thread . sleep ( 200 ) ; } catch ( InterruptedException e1 ) { e1 . printStackTrace ( ) ; } ApplicationStatus . getInstance ( ) . doRanking ( ) ; System . out . println ( "ranking computation complete!" ) ; ApplicationStatus . getInstance ( ) . printResults ( ) ; isRunning = false ; try { pool . awaitTermination ( 2000 , TimeUnit . MILLISECONDS ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } }
va	9	protected static boolean isWrapperClass ( String name ) { return name . equals ( "java.lang.Integer" ) || name . equals ( "java.lang.Long" ) || name . equals ( "java.lang.Short" ) || name . equals ( "java.math.BigInteger" ) || name . equals ( "java.math.BigDecimal" ) || name . equals ( "java.lang.Float" ) || name . equals ( "java.lang.Double" ) || name . equals ( "java.lang.Byte" ) || name . equals ( "java.lang.Boolean" ) || name . equals ( "java.lang.Character" ) ; }
va	1	private void overvoltagesdramOnOff ( java . awt . event . MouseEvent evt ) { if ( ckover_voltage_sdram . isSelected ( ) ) { over_voltage_sdram . setEnabled ( true ) ; } else over_voltage_sdram . setEnabled ( false ) ; over_voltage_sdram . repaint ( ) ; }
va	9	public void loadFromObject ( ) { try { if ( cls == null ) return ; for ( int i = 0 ; i < fields . size ( ) ; i ++ ) { String fieldname = ( String ) fields . get ( i ) ; String fieldtype = ( String ) fieldtypes . get ( fieldname ) ; if ( fieldtype . equals ( "key" ) || fieldtype . equals ( "int" ) || fieldtype . equals ( "double" ) || fieldtype . equals ( "boolean" ) || fieldtype . equals ( "String" ) ) { Field field = cls . getField ( fieldname ) ; fieldvalues . put ( fieldname , field . get ( obj ) ) ; } else { System . out . println ( "not implemented!" ) ; } } } catch ( NoSuchFieldException e ) { throw new JGameError ( "Field not found." ) ; } catch ( IllegalAccessException e ) { throw new JGameError ( "Field cannot be accessed." ) ; } }
va	5	@ SuppressWarnings ( "unchecked" ) private void menuItemOpenActionPerformed ( ActionEvent evt ) { JFileChooser fc = new JFileChooser ( ) ; fc . setAcceptAllFileFilterUsed ( false ) ; fc . setFileFilter ( new FileFilter ( ) { public boolean accept ( File f ) { return f . isDirectory ( ) || f . getName ( ) . toLowerCase ( ) . endsWith ( ".ser" ) ; } public String getDescription ( ) { return "Datei" + " (*.ser)" ; } } ) ; int result = fc . showOpenDialog ( drawComponent1 ) ; if ( result == JFileChooser . APPROVE_OPTION ) { File file = fc . getSelectedFile ( ) ; path = file . getPath ( ) ; InputStream fis = null ; ObjectInputStream oip = null ; if ( file . exists ( ) ) { try { fis = new FileInputStream ( file ) ; oip = new ObjectInputStream ( fis ) ; drawComponent1 . setObjectList ( ( ArrayList < DrawObject > ) oip . readObject ( ) ) ; drawComponent2 . setObjectList ( ( ArrayList < DrawObject > ) oip . readObject ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } catch ( ClassNotFoundException e ) { e . printStackTrace ( ) ; } } } repaintAll ( ) ; }
va	4	static void entrance ( ) { int max = 37197 ; aux [ max ] = true ; aux [ max - 1 ] = true ; for ( int i = max - 2 ; i >= 0 ; -- i ) { if ( ! aux [ i + 1 ] ) { aux [ i ] = true ; continue ; } int nextMonthDay = ( int ) nextMonthDay ( i ) ; if ( nextMonthDay > 0 && nextMonthDay <= max ) { aux [ i ] = ! aux [ nextMonthDay ] ; } } }
va	1	public boolean ChoqueArriba ( String a , int n ) { return ( ( Mapa . getInstance ( ) . getObjetoMapa ( getPosicionY ( y + imagen . getAltoEscalado ( ) - vary ) - n , getPosicionX ( x + 2 * varx ) ) == a ) || ( Mapa . getInstance ( ) . getObjetoMapa ( getPosicionY ( y + imagen . getAltoEscalado ( ) - vary ) - n , getPosicionX ( x + imagen . getAnchoEscalado ( ) - 2 * varx ) ) == a ) ) ; }
va	1	public boolean esSolapa ( Date dIni , Date dFi ) { return dIni . before ( dataFi ) && dFi . after ( dataInici ) ; }
va	0	protected void addReference ( AddressBook theContainer ) { containerRefAddressBook = theContainer ; }
va	9	@ Override public String execute ( HttpServletRequest request , HttpServletResponse response ) throws Exception { String data ; try { int rpp ; if ( request . getParameter ( "rpp" ) == null ) { rpp = 10 ; } else { rpp = Integer . parseInt ( request . getParameter ( "rpp" ) ) ; } ArrayList < FilterBean > alFilter = new ArrayList < > ( ) ; if ( request . getParameter ( "filter" ) != null ) { if ( request . getParameter ( "filteroperator" ) != null ) { if ( request . getParameter ( "filtervalue" ) != null ) { FilterBean oFilterBean = new FilterBean ( ) ; oFilterBean . setFilter ( request . getParameter ( "filter" ) ) ; oFilterBean . setFilterOperator ( request . getParameter ( "filteroperator" ) ) ; oFilterBean . setFilterValue ( request . getParameter ( "filtervalue" ) ) ; oFilterBean . setFilterOrigin ( "user" ) ; alFilter . add ( oFilterBean ) ; } } } if ( request . getParameter ( "systemfilter" ) != null ) { if ( request . getParameter ( "systemfilteroperator" ) != null ) { if ( request . getParameter ( "systemfiltervalue" ) != null ) { FilterBean oFilterBean = new FilterBean ( ) ; oFilterBean . setFilter ( request . getParameter ( "systemfilter" ) ) ; oFilterBean . setFilterOperator ( request . getParameter ( "systemfilteroperator" ) ) ; oFilterBean . setFilterValue ( request . getParameter ( "systemfiltervalue" ) ) ; oFilterBean . setFilterOrigin ( "system" ) ; alFilter . add ( oFilterBean ) ; } } } HashMap < String , String > hmOrder = new HashMap < > ( ) ; if ( request . getParameter ( "order" ) != null ) { if ( request . getParameter ( "ordervalue" ) != null ) { hmOrder . put ( request . getParameter ( "order" ) , request . getParameter ( "ordervalue" ) ) ; } else { hmOrder = null ; } } else { hmOrder = null ; } CargoDao oCargoDAO = new CargoDao ( Conexion . getConection ( ) ) ; int pages = oCargoDAO . getPages ( rpp , alFilter , hmOrder ) ; data = "{\"data\":\"" + Integer . toString ( pages ) + "\"}" ; return data ; } catch ( Exception e ) { throw new ServletException ( "CargoGetpagesJson: View Error: " + e . getMessage ( ) ) ; } }
va	6	public void solve ( final double [ ] [ ] b , final double [ ] [ ] x ) { int i , j , m = b [ 0 ] . length ; if ( b . length != n || x . length != n || b [ 0 ] . length != x [ 0 ] . length ) throw new IllegalArgumentException ( "solve bad sizes" ) ; double [ ] xx = new double [ n ] ; for ( j = 0 ; j < m ; j ++ ) { for ( i = 0 ; i < n ; i ++ ) xx [ i ] = b [ i ] [ j ] ; solve ( xx , xx ) ; for ( i = 0 ; i < n ; i ++ ) x [ i ] [ j ] = xx [ i ] ; } }
va	0	public void setClose ( java . math . BigDecimal close ) { this . close = close ; }
va	3	private Comparator chooseComparator ( IGame game ) { Comparator cmp = null ; int gameType = game . getGameType ( ) ; switch ( gameType ) { case IGame . TYPE_SOCCER : cmp = new SoccerSkillComparator ( ) ; break ; case IGame . TYPE_VOLLEYBALL : cmp = new VolleyballSkillComparator ( ) ; break ; case IGame . TYPE_HANDBALL : cmp = new HandballSkillComparator ( ) ; break ; } return cmp ; }
va	1	private static LinkedList < Integer > setupList ( int n ) { LinkedList < Integer > lista = new LinkedList < Integer > ( ) ; for ( int i = 1 ; i <= n ; i ++ ) { lista . add ( Integer . valueOf ( i ) ) ; } return lista ; }
va	0	public void addDocument ( int docid , String grade ) { relevances . put ( docid , convertToBinaryRelevance ( grade ) ) ; }
va	8	public static void main ( String [ ] args ) { ConsistentGlobalProblemSetInitialisation starter = new ConsistentGlobalProblemSetInitialisation ( ) ; starter . initLanguage ( new char [ ] { 0 , 1 } , 10 , "(1(01*0)*1|0)*" ) ; int solutionFoundCounter = 0 ; int noSolutionFound = 0 ; List < long > cycleCount = new LinkedList < long > ( ) ; long tmpCycle ; long timeStamp ; int [ ] problemCount = new int [ 5 ] ; int [ ] candidatesCount = new int [ 5 ] ; int [ ] noCycles = new int [ 2 ] ; problemCount [ 0 ] = 10 ; problemCount [ 1 ] = 20 ; problemCount [ 2 ] = 30 ; problemCount [ 3 ] = 40 ; problemCount [ 4 ] = 50 ; candidatesCount [ 0 ] = 10 ; candidatesCount [ 1 ] = 20 ; candidatesCount [ 2 ] = 30 ; candidatesCount [ 3 ] = 40 ; candidatesCount [ 4 ] = 50 ; noCycles [ 0 ] = 250 ; noCycles [ 1 ] = 500 ; int pc = 0 ; int cc = 0 ; int nc = 0 ; for ( int x = 0 ; x < 1 ; x ++ ) { System . out . println ( "x:" + x ) ; for ( int n = 0 ; n < 25 ; n ++ ) { DateFormat df = new SimpleDateFormat ( "yyyy-MM-dd_HH_mm_ss" ) ; Logger l = new Logger ( "C_G_" + df . format ( new Date ( ) ) + ".log" , true ) ; pc = problemCount [ n % 5 ] ; cc = candidatesCount [ ( int ) Math . floor ( n / 5 ) ] ; nc = noCycles [ 1 ] ; l . log ( "Problem Count: " + pc ) ; l . log ( "CandidatesCount: " + cc ) ; l . log ( "Max Cycles: " + nc ) ; solutionFoundCounter = 0 ; noSolutionFound = 0 ; cycleCount = new LinkedList < long > ( ) ; for ( int i = 0 ; i < 100 ; i ++ ) { timeStamp = System . currentTimeMillis ( ) ; starter . initProblems ( pc ) ; starter . initCandidates ( cc ) ; tmpCycle = starter . startEvolution ( nc ) ; l . log ( i + ": finished (" + ( System . currentTimeMillis ( ) - timeStamp ) + "ms  " + tmpCycle + "cycles)" ) ; if ( starter . getWinner ( ) != null ) { solutionFoundCounter ++ ; cycleCount . add ( tmpCycle ) ; l . log ( i + ": Solution found." ) ; } else { noSolutionFound ++ ; l . log ( i + ": No solution found." ) ; } } long max = 0 ; long min = 10000 ; long sum = 0 ; for ( long no : cycleCount ) { sum += no ; max = ( no > max ? no : max ) ; min = ( no < min ? no : min ) ; } l . log ( "Solution Found: " + solutionFoundCounter ) ; l . log ( "Avg cycles: " + ( cycleCount . size ( ) > 0 ? sum / cycleCount . size ( ) : 0 ) ) ; l . log ( "Max cycles: " + max ) ; l . log ( "Min cycles: " + min ) ; l . log ( "No solution found: " + noSolutionFound ) ; l . finish ( ) ; } } }
va	7	private JPanel createInputPanel ( ) { JPanel inputPanel = new SpacedPanel ( new Dimension ( 5 , 5 ) ) ; inputPanel . setLayout ( new BoxLayout ( inputPanel , BoxLayout . Y_AXIS ) ) ; Event e = model . peek ( ) ; String name = e == null ? "Enter event name..." : e . getName ( ) ; String loc = e == null ? "Enter event location..." : e . getLocation ( ) ; String desc = ( e == null ? "Enter event description..." : e . getDescription ( ) ) ; String largest = name . length ( ) > loc . length ( ) ? name : loc ; largest = largest . length ( ) > desc . length ( ) ? largest : desc ; nameField = new JEventField ( name , largest . length ( ) ) ; locField = new JEventField ( loc , largest . length ( ) ) ; descArea = new JTextArea ( desc , 4 , largest . length ( ) ) ; descArea . setBorder ( BorderFactory . createLineBorder ( Color . BLACK , 1 ) ) ; startDateField = new JEventField ( "Enter event start date..." , largest . length ( ) ) ; endDateField = new JEventField ( "Enter event end date..." , largest . length ( ) ) ; textMap . put ( nameField , "Enter event name..." ) ; textMap . put ( locField , "Enter event location..." ) ; textMap . put ( descArea , "Enter event description..." ) ; FocusListener focusListener = new FocusListener ( ) { public void focusGained ( FocusEvent e ) { JTextComponent source = ( JTextComponent ) e . getSource ( ) ; if ( textMap . get ( source ) . equals ( source . getText ( ) ) ) { source . setText ( null ) ; } } public void focusLost ( FocusEvent e ) { JTextComponent source = ( JTextComponent ) e . getSource ( ) ; if ( source . getText ( ) . equals ( "" ) ) source . setText ( textMap . get ( source ) ) ; } } ; nameField . addFocusListener ( focusListener ) ; locField . addFocusListener ( focusListener ) ; descArea . addFocusListener ( focusListener ) ; inputPanel . add ( nameField ) ; inputPanel . add ( createDatePanel ( startDateField , startDateDialog ) ) ; inputPanel . add ( createDatePanel ( endDateField , endDateDialog ) ) ; inputPanel . add ( locField ) ; inputPanel . add ( descArea ) ; inputPanel . setBorder ( BorderFactory . createEmptyBorder ( 10 , 10 , 10 , 10 ) ) ; return inputPanel ; }
va	9	@ Override public boolean equals ( Object obj ) { if ( obj == null ) { return false ; } if ( getClass ( ) != obj . getClass ( ) ) { return false ; } final User other = ( User ) obj ; if ( ! Objects . equals ( this . userIn , other . userIn ) ) { return false ; } if ( ! Objects . equals ( this . user , other . user ) ) { return false ; } if ( this . enabled != other . enabled ) { return false ; } if ( ! Objects . equals ( this . errMsg , other . errMsg ) ) { return false ; } if ( this . intErr != other . intErr ) { return false ; } if ( this . intExit != other . intExit ) { return false ; } if ( ! Objects . equals ( this . retVal , other . retVal ) ) { return false ; } return true ; }
va	5	public static void apply ( Op op ) { Document doc = textArea . getDocument ( ) ; int pos = textArea . getCaretPosition ( ) ; if ( op == null ) return ; try { if ( op . getOpType ( ) == OpType . INSERT_CHAR ) { Insertion insertion = ( Insertion ) op ; doc . insertString ( insertion . getPos ( ) , "" + insertion . getC ( ) , null ) ; if ( insertion . getPos ( ) <= pos ) { textArea . setCaretPosition ( pos + 1 ) ; } } else { Deletion deletion = ( Deletion ) op ; char c = textArea . getText ( ) . charAt ( deletion . getPos ( ) ) ; deletion . setC ( c ) ; doc . remove ( deletion . getPos ( ) , 1 ) ; if ( deletion . getPos ( ) < pos ) textArea . setCaretPosition ( pos - 1 ) ; } } catch ( Exception e ) { System . out . println ( e ) ; } }
va	7	public boolean start ( ) { synchronized ( optOutLock ) { if ( isOptOut ( ) ) { return false ; } if ( task != null ) { return true ; } task = plugin . getServer ( ) . getScheduler ( ) . runTaskTimerAsynchronously ( plugin , new Runnable ( ) { private boolean firstPost = true ; public void run ( ) { try { synchronized ( optOutLock ) { if ( isOptOut ( ) && task != null ) { task . cancel ( ) ; task = null ; for ( Graph graph : graphs ) { graph . onOptOut ( ) ; } } } postPlugin ( ! firstPost ) ; firstPost = false ; } catch ( IOException e ) { if ( debug ) { Bukkit . getLogger ( ) . log ( Level . INFO , "[Metrics] " + e . getMessage ( ) ) ; } } } } , 0 , PING_INTERVAL * 1200 ) ; return true ; } }
va	7	public boolean remove ( Object obj ) { if ( ! ( obj instanceof Entry < ? , ? > ) ) { return false ; } Entry < ? , ? > entry = ( Entry < ? , ? > ) obj ; return map . remove ( entry . getKey ( ) , entry . getValue ( ) ) ; }
va	6	private static void dropDB ( String dbName , String username , String password ) { Connection conn = null ; Statement stmt = null ; String dbURL = "jdbc:mysql://localhost" ; try { class . forName ( "com.mysql.jdbc.Driver" ) ; System . out . println ( "Connecting to a selected database..." ) ; conn = DriverManager . getConnection ( dbURL , username , password ) ; System . out . println ( "Connected database successfully..." ) ; System . out . println ( "Deleting database " + dbName + "..." ) ; stmt = conn . createStatement ( ) ; String sql = "DROP DATABASE " + dbName ; stmt . executeUpdate ( sql ) ; System . out . println ( "Database deleted successfully..." ) ; } catch ( SQLException se ) { se . printStackTrace ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { try { if ( stmt != null ) conn . close ( ) ; } catch ( SQLException se ) { } try { if ( conn != null ) conn . close ( ) ; } catch ( SQLException se ) { se . printStackTrace ( ) ; } } System . out . println ( "Finished!" ) ; System . out . println ( "========================================================================" ) ; }
va	3	public static boolean Verify ( PublicKey publicKey , byte [ ] signature , byte [ ] data ) { Signature instance = null ; try { instance = Signature . getInstance ( "SHA1withRSA" ) ; instance . initVerify ( publicKey ) ; instance . update ( data ) ; return instance . verify ( signature ) ; } catch ( NoSuchAlgorithmException e ) { e . printStackTrace ( ) ; } catch ( InvalidKeyException e ) { e . printStackTrace ( ) ; } catch ( SignatureException e ) { e . printStackTrace ( ) ; } return false ; }
va	9	public void setMode ( int mode ) { this . mode = mode ; loadContext ( null ) ; editBtn . setSelected ( false ) ; objectBtn . setSelected ( false ) ; itemBtn . setSelected ( false ) ; startBtn . setSelected ( false ) ; endBtn . setSelected ( false ) ; resetObjectBtn . setSelected ( false ) ; wallBtn . setSelected ( false ) ; pathBtn . setSelected ( false ) ; proxBombBtn . setSelected ( false ) ; warpWallBtn . setSelected ( false ) ; turretBtn . setSelected ( false ) ; if ( mode == EDIT_MODE ) editBtn . setSelected ( true ) ; else if ( mode == OBJECT_MODE ) objectBtn . setSelected ( true ) ; else if ( mode == ITEM_MODE ) itemBtn . setSelected ( true ) ; else if ( mode == START_MODE ) startBtn . setSelected ( true ) ; else if ( mode == END_MODE ) endBtn . setSelected ( true ) ; else if ( mode == RESET_MODE ) resetObjectBtn . setSelected ( true ) ; else if ( mode == WALL_MODE ) wallBtn . setSelected ( true ) ; else if ( mode == PATH_MODE ) pathBtn . setSelected ( true ) ; else if ( mode == PROX_MODE ) proxBombBtn . setSelected ( true ) ; else if ( mode == WARP_WALL_MODE ) warpWallBtn . setSelected ( true ) ; else if ( mode == TURRET_MODE ) turretBtn . setSelected ( true ) ; }
va	7	public boolean inTheCorner ( Point p ) { return ( p . x == 0 && p . y == 0 ) || ( p . x == 0 && p . y == arr . sizeY - 1 ) || ( p . x == arr . sizeX - 1 && p . y == 0 ) || ( p . x == arr . sizeX - 1 && p . y == arr . sizeY - 1 ) ; }
va	1	@ Override public int getPages ( int intRegsPerPag , ArrayList < FilterBean > hmFilter , HashMap < String , String > hmOrder ) throws Exception { int pages ; try { oMysql . conexion ( enumTipoConexion ) ; pages = oMysql . getPages ( strTabla , intRegsPerPag , hmFilter , hmOrder ) ; oMysql . desconexion ( ) ; return pages ; } catch ( Exception e ) { throw new Exception ( "GenericDao.getPages: Error: " + e . getMessage ( ) ) ; } }
va	1	public static void main ( String [ ] args ) throws InterruptedException { XBeeSniffer sniffer = new XBeeSniffer ( ) ; JCommander commander = new JCommander ( sniffer , args ) ; commander . setProgramName ( "xbee-sniffer" ) ; if ( sniffer . serialPorts . size ( ) == 0 ) { commander . usage ( ) ; return ; } System . setProperty ( "gnu.io.rxtx.SerialPorts" , sniffer . serialPorts . get ( 0 ) ) ; sniffer . start ( ) ; }
va	6	@ Test public final void testInitialize ( ) { try { assertTrue ( "The diffbot API URL is not accessible" , ping ( diffbotAPIURL , 30000 ) ) ; assertTrue ( "The article test URL is not accessible" , ping ( articleTestURL , 30000 ) ) ; assertTrue ( "The frontpage test URL is not accessible" , ping ( frontpageTestURL , 30000 ) ) ; assertTrue ( "The image test URL is not accessible" , ping ( imageTestURL , 30000 ) ) ; assertTrue ( "The product test URL is not accessible" , ping ( productTestURL , 30000 ) ) ; } catch ( IOException e ) { fail ( "One of the accessible test URL is not accessible." ) ; } try { ping ( nonExixtingTestURL , 30000 ) ; fail ( "The non existing test URL is accessible." ) ; } catch ( UnknownHostException expectedException ) { } catch ( MalformedURLException e ) { fail ( "The non existing test URL is malformed." ) ; } catch ( IOException e ) { fail ( "Accessing the non existing test URL doesn't throw an UnknownHostException." ) ; } try { ping ( malFormedTestURL , 30000 ) ; fail ( "The malformed test URL is accessible." ) ; } catch ( MalformedURLException expectedException ) { } catch ( IOException e ) { fail ( "The wrongly formatted test URL is not wrongly formatted." ) ; } }
va	7	public static int maxProfit ( int [ ] prices ) { if ( prices . length == 0 ) { return 0 ; } if ( prices . length == 1 ) { return 0 ; } int low = prices [ 0 ] ; int high = prices [ 0 ] ; int lowPos = 0 ; int highPos = 0 ; int max = 0 ; for ( int i = 1 ; i < prices . length ; i ++ ) { if ( prices [ i ] > high ) { high = prices [ i ] ; if ( high - low > max ) { max = high - low ; } } if ( prices [ i ] < low ) { low = prices [ i ] ; high = 0 ; } } if ( max <= 0 ) { return 0 ; } return max ; }
va	3	@ Override public void run ( ) { WebSocketImpl ws = null ; try { while ( true ) { ByteBuffer buf = null ; ws = iqueue . take ( ) ; buf = ws . inQueue . poll ( ) ; assert ( buf != null ) ; try { ws . decode ( buf ) ; } finally { pushBuffer ( buf ) ; } } } catch ( InterruptedException e ) { } catch ( RuntimeException e ) { handleFatal ( ws , e ) ; } }
va	2	public static void freeInts ( ) { if ( ! unusedInts . isEmpty ( ) ) { unusedInts . clear ( ) ; } if ( ! unusedBigInts . isEmpty ( ) ) { unusedBigInts . clear ( ) ; } unusedInts . addAll ( usedInts ) ; unusedBigInts . addAll ( usedBigInts ) ; usedInts . clear ( ) ; usedBigInts . clear ( ) ; }
va	2	public static void main ( String [ ] args ) { try { System . out . println ( "[ JNanoBoard version: " + VERSION + "]" ) ; RulesManager . getInstance ( ) . loadRules ( RULES_DIR ) ; config = new Properties ( ) ; try { config . load ( new FileInputStream ( CONFIG_FILE ) ) ; } catch ( IOException e ) { ( new File ( CONFIG_FILE ) ) . createNewFile ( ) ; e . printStackTrace ( ) ; } setLookAndFeel ( ) ; mainFrame = new NBFrame ( ) ; mainFrame . setVisible ( true ) ; } catch ( Exception ex ) { Logger . getLogger ( MainClass . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } }
va	3	public void update ( UserStatus userStatus ) { Session session = null ; try { session = HibernateUtil . getSessionFactory ( ) . openSession ( ) ; session . beginTransaction ( ) ; session . update ( userStatus ) ; session . getTransaction ( ) . commit ( ) ; } catch ( Exception e ) { System . err . println ( "\u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u0432\u0441\u0442\u0430\u0432\u043A\u0435" + e . getMessage ( ) ) ; } finally { if ( session != null && session . isOpen ( ) ) { session . close ( ) ; } } }
va	7	@ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; Token other = ( Token ) obj ; if ( type != other . type ) return false ; if ( value == null ) { if ( other . value != null ) return false ; } else if ( ! value . equals ( other . value ) ) return false ; return true ; }
va	3	public void setFill ( int i ) { constr . fill = i ; if ( i == GridBagConstraints . HORIZONTAL ) { setWeight ( 100 , 0 ) ; } else if ( i == GridBagConstraints . VERTICAL ) { setWeight ( 0 , 100 ) ; } else if ( i == GridBagConstraints . BOTH ) { setWeight ( 100 , 100 ) ; } else { setWeight ( 0 , 0 ) ; } }
va	3	public static void updateVelo ( Velo velo ) { PreparedStatement stat ; try { stat = ConnexionDB . getConnection ( ) . prepareStatement ( "select * from velo where id_velo=?" , ResultSet . TYPE_SCROLL_INSENSITIVE , ResultSet . CONCUR_UPDATABLE ) ; stat . setInt ( 1 , velo . getId_velo ( ) ) ; ResultSet res = stat . executeQuery ( ) ; if ( res . next ( ) ) { res . updateString ( "serialNumber" , velo . getSerialNumber ( ) ) ; res . updateString ( "dateMiseEnService" , velo . getDateMiseEnService ( ) ) ; res . updateDouble ( "kmParcourus" , velo . getKmParcourus ( ) ) ; res . updateString ( "etat" , velo . getEtat ( ) ) ; res . updateInt ( "fk_id_borne" , velo . getFk_id_borne ( ) ) ; res . updateRow ( ) ; } } catch ( SQLException e ) { while ( e != null ) { System . out . println ( e . getErrorCode ( ) ) ; System . out . println ( e . getMessage ( ) ) ; System . out . println ( e . getSQLState ( ) ) ; e . printStackTrace ( ) ; e = e . getNextException ( ) ; } } }
va	1	@ ApiMethod ( name = "sendMessage" ) public void sendMessage ( @ Named ( "message" ) String message ) throws IOException { Sender sender = new Sender ( API_KEY ) ; MessageData messageObj = new MessageData ( ) ; messageObj . setMessage ( message ) ; messageObj . setTimestamp ( System . currentTimeMillis ( ) ) ; EntityManager mgr = getEntityManager ( ) ; try { mgr . persist ( messageObj ) ; } finally { mgr . close ( ) ; } CollectionResponse < DeviceInfo > response = endpoint . listDeviceInfo ( null , 10 ) ; for ( DeviceInfo deviceInfo : response . getItems ( ) ) { doSendViaGcm ( message , sender , deviceInfo ) ; } }
va	7	public void rotate3 ( final int [ ] nums , int k ) { final int n = nums . length ; if ( n <= 1 ) { return ; } while ( n < k ) { k = k % n ; } if ( n == k ) { return ; } k = n - k ; int j ; int d ; int tmp ; for ( int i = 0 ; i < gcd ( n , k ) ; i ++ ) { tmp = nums [ i ] ; j = i ; while ( true ) { d = j + k ; if ( d >= n ) { d = d - n ; } if ( d == i ) { break ; } nums [ j ] = nums [ d ] ; j = d ; } nums [ j ] = tmp ; } }
va	8	public void updateVelocity ( ) { int cap = this . getCart ( ) . getCurrentCapacity ( ) ; if ( cap >= 0 && cap < 50 ) this . setVelocity ( 170 ) ; else if ( cap >= 50 && cap < 100 ) this . setVelocity ( 150 ) ; else if ( cap >= 100 && cap < 150 ) this . setVelocity ( 120 ) ; else if ( cap >= 150 && cap <= 200 ) this . setVelocity ( 100 ) ; }
va	4	protected void putWordUnique ( String word ) { String code = getCode ( word ) ; Vector list = ( Vector ) mainDictionary . get ( code ) ; if ( list != null ) { boolean isAlready = false ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { if ( word . equalsIgnoreCase ( ( String ) list . elementAt ( i ) ) ) { isAlready = true ; break ; } } if ( ! isAlready ) list . addElement ( word ) ; } else { list = new Vector ( ) ; list . addElement ( word ) ; mainDictionary . put ( code , list ) ; } }
va	6	public static String trimPrefix ( String expression , Collection < String > possiblePrefixes , boolean allowUnprefixedExpressions ) { if ( expression == null ) { return null ; } String realExpr = null ; for ( String prefix : possiblePrefixes ) { if ( expression . startsWith ( prefix ) ) { realExpr = expression . substring ( prefix . length ( ) ) ; if ( realExpr . startsWith ( "." ) ) { realExpr = realExpr . substring ( 1 ) ; } break ; } } if ( realExpr == null && allowUnprefixedExpressions ) { realExpr = expression ; } return realExpr ; }
va	9	public long fillTables ( ) { Iterator it = tables . listIterator ( ) ; String srctable = "" ; long rowcount = 0 ; queryStr = queryStr . replaceAll ( "databaseID" , "" + databaseID ) ; while ( it . hasNext ( ) ) { try { srctable = ( String ) it . next ( ) ; rowcount += sourceDB . executeUpdate ( "INSERT IGNORE INTO " + tmpTable + " " + queryStr . replaceAll ( "#srctable#" , srctable ) ) ; } catch ( SQLException e ) { output += "Error while filling temporary database from source table " + srctable + "!" ; output += "<p>" + e . getMessage ( ) + "<p>" ; success = false ; return 0 ; } } if ( ! dbIdentical ) try { String os = System . getProperty ( "os.name" ) . toLowerCase ( ) ; Runtime rt = Runtime . getRuntime ( ) ; String [ ] command = { "" , "" , "" } ; if ( os . indexOf ( "windows" ) > - 1 ) { command [ 0 ] = "cmd.exe" ; command [ 1 ] = "/c" ; } else { command [ 0 ] = "/bin/sh" ; command [ 1 ] = "-c" ; } String sourceHost = "" ; String sourcePort = "" ; if ( sourceInfo . getHost ( ) . indexOf ( ":" ) > - 1 ) { sourceHost = sourceInfo . getHost ( ) . split ( ":" ) [ 0 ] ; sourcePort = "--port=" + sourceInfo . getHost ( ) . split ( ":" ) [ 1 ] ; } else sourceHost = sourceInfo . getHost ( ) ; String destHost = "" ; String destPort = "" ; if ( destInfo . getHost ( ) . indexOf ( ":" ) > - 1 ) { destHost = destInfo . getHost ( ) . split ( ":" ) [ 0 ] ; destPort = "--port=" + destInfo . getHost ( ) . split ( ":" ) [ 1 ] ; } else destHost = destInfo . getHost ( ) ; if ( sourceInfo . isUseSSH ( ) ) { command [ 2 ] = "ssh -q " + sourceHost + " mysqldump " + sourcePort + " --user=" + sourceInfo . getUser ( ) + " --password=" + sourceInfo . getPassword ( ) + " -t --compact --lock-tables=FALSE " + sourceInfo . getName ( ) + " " + tmpTable ; } else { command [ 2 ] = "mysqldump --host=" + sourceHost + " " + sourcePort + " --user=" + sourceInfo . getUser ( ) + " --password=" + sourceInfo . getPassword ( ) + " -t --compact --compress --lock-tables=FALSE " + sourceInfo . getName ( ) + " " + tmpTable ; } if ( destInfo . isUseSSH ( ) ) { command [ 2 ] += " | ssh -q " + destHost + " mysql " + destPort + " --user=" + destInfo . getUser ( ) + " --password=" + destInfo . getPassword ( ) + " -C " + destInfo . getName ( ) ; } else { command [ 2 ] += " | mysql --host=" + destHost + " " + destPort + " --user=" + destInfo . getUser ( ) + " --password=" + destInfo . getPassword ( ) + " " + destInfo . getName ( ) ; } Process proc = rt . exec ( command ) ; Thread . yield ( ) ; proc . waitFor ( ) ; } catch ( Exception e ) { output += "Error while filling temporary database from source table " + srctable + " with mysqldump!" ; output += "<p>" + e . getMessage ( ) + "<p>" ; success = false ; return 0 ; } return rowcount ; }
va	4	@ Override public void create ( Article article ) { if ( find ( article . getId ( ) ) == null ) { String sql = "INSERT INTO T_ARTICLE (quantite fk_id_client fk_id_stock) VALUES (? ? ?)" ; PreparedStatement preparedStatement = null ; try { preparedStatement = connection . prepareStatement ( sql ) ; preparedStatement . setInt ( 1 , article . getQuantite ( ) ) ; preparedStatement . setInt ( 2 , article . getClient ( ) . getCin ( ) ) ; preparedStatement . setInt ( 3 , article . getStock ( ) . getId ( ) ) ; preparedStatement . executeUpdate ( ) ; System . out . println ( sql ) ; } catch ( SQLException ex ) { Logger . getLogger ( ArticleDAO . class . getName ( ) ) . log ( Level . SEVERE , "insert failed" , ex ) ; } finally { try { if ( preparedStatement != null ) { preparedStatement . close ( ) ; } } catch ( SQLException ex ) { Logger . getLogger ( ArticleDAO . class . getName ( ) ) . log ( Level . SEVERE , "free resourses failed" , ex ) ; } } } }
va	5	private Object union ( Object subtree1 , Object subtree2 , Object lo , Object hi ) { if ( subtree1 == subtree2 || subtree2 == null ) return split ( subtree1 , lo , hi ) ; else if ( subtree1 == null ) return split ( subtree2 , lo , hi ) ; else if ( ! ( subtree1 instanceof Node ) ) { if ( ! ( subtree2 instanceof Node ) ) return union ( ( Object [ ] ) subtree1 , ( Object [ ] ) subtree2 , lo , hi ) ; else return union ( subtree2 , subtree1 , lo , hi ) ; } else { Node n1 = ( Node ) subtree1 ; Object elt1 = n1 . element ; Object elt2 = findEquiv ( subtree2 , elt1 ) ; return concat ( equivUnion ( elt1 , elt2 ) , union ( trim ( n1 . left , lo , elt1 ) , trim ( subtree2 , lo , elt1 ) , lo , elt1 ) , union ( trim ( n1 . right , elt1 , hi ) , trim ( subtree2 , elt1 , hi ) , elt1 , hi ) ) ; } }
va	3	protected EntityManager ( ) { SAXReader reader = new SAXReader ( ) ; try { document = reader . read ( EntityManager . class . getResource ( "/data/entities.xml" ) ) ; } catch ( DocumentException e ) { throw new RuntimeException ( e ) ; } Element root = document . getRootElement ( ) ; for ( Iterator i = root . elementIterator ( ) ; i . hasNext ( ) ; ) { Element element = ( Element ) i . next ( ) ; String name = element . attributeValue ( "name" ) ; if ( entityNames . contains ( name ) ) { throw new RuntimeException ( "Duplicate entity name " + name ) ; } else { entityNames . add ( name ) ; } } }
va	1	@ Override public String toString ( ) { if ( 0 == tableClass ) { return getPart ( ) . name ( ) + " ID: " + id + " DC table" ; } return getPart ( ) . name ( ) + " ID: " + id + " AC table" ; }
va	0	public SpriteSelectOverlay ( final float positionX , final float positionY , final float width , final float height , final Texture texture ) { super ( ) ; this . positionX = positionX ; this . positionY = positionY ; hwidth = width / 2 ; hheight = height / 2 ; mesh = new Mesh ( Mesh . MeshType . OVERLAY , false , new FloatBuffer ( 4 * 12 * 100 ) , new ShortBuffer ( 4 * 100 ) ) ; mesh . setTexture ( texture ) ; }
va	5	public boolean equals ( Object o ) { if ( ! ( o instanceof AddressImpl ) ) { return false ; } else { AddressImpl address = ( AddressImpl ) o ; if ( street . equals ( address . street ) && city . equals ( address . city ) && state . equals ( address . state ) && zipCode . equals ( address . zipCode ) ) { return true ; } return false ; } }
va	3	public static String [ ] getNames ( Object object ) { if ( object == null ) { return null ; } class klass = object . getClass ( ) ; Field [ ] fields = klass . getFields ( ) ; int length = fields . length ; if ( length == 0 ) { return null ; } String [ ] names = new String [ length ] ; for ( int i = 0 ; i < length ; i += 1 ) { names [ i ] = fields [ i ] . getName ( ) ; } return names ; }
va	6	public boolean onLine ( int x , int y ) { Debug . println ( "Checking Point " + x + ":" + y ) ; Debug . println ( "Starting Point " + startingPoint . getX ( ) + "  " + startingPoint . getY ( ) ) ; Debug . println ( "Ending Point " + endingPoint . getX ( ) + "  " + endingPoint . getY ( ) ) ; Debug . println ( "UndefinedSlope = " + undefinedSlope ) ; Debug . println ( "Slope = " + slope ) ; if ( x < Math . min ( startingPoint . getX ( ) , endingPoint . getX ( ) ) - DELTA ) return false ; if ( x > Math . max ( startingPoint . getX ( ) , endingPoint . getX ( ) ) + DELTA ) return false ; if ( y < Math . min ( startingPoint . getY ( ) , endingPoint . getY ( ) ) - DELTA ) return false ; if ( y > Math . max ( startingPoint . getY ( ) , endingPoint . getY ( ) ) + DELTA ) return false ; if ( ! undefinedSlope ) { double yInt = MathFormulas . yIntercept ( slope , startingPoint . getX ( ) , startingPoint . getY ( ) ) ; double value = slope * x + yInt ; Debug . println ( "yInt = " + yInt ) ; Debug . println ( "Checking point " + x + "  " + y ) ; Debug . println ( "value = " + value + " checking aginst y = " + y ) ; double low = value - DELTA ; double high = value + DELTA ; Debug . println ( "low = " + low + " high = " + high ) ; return ( value >= low && value <= high ) ; } else { return true ; } }
va	0	@ Test public void testGetBaseType ( ) { System . out . println ( "ArrayType: getBaseType()" ) ; class type = String [ ] [ ] . class ; ArrayType instance = new ArrayType ( type ) ; Object expType = String . class ; assertEquals ( expType , instance . getBaseType ( ) ) ; type = Integer [ ] . class ; instance = new ArrayType ( type ) ; assertEquals ( Integer . class , instance . getBaseType ( ) ) ; type = Person [ ] . class ; instance = new ArrayType ( type ) ; assertEquals ( Person . class , instance . getBaseType ( ) ) ; instance = new ArrayType ( ) ; assertEquals ( Object . class , instance . getBaseType ( ) ) ; }
va	8	public void setPieces ( ) { OthelloPiece [ ] [ ] piecesToBeSaved = OthelloBoard . getPieces ( ) ; for ( int j = 0 ; j < piecesToBeSaved [ 0 ] . length ; j ++ ) { for ( int i = 0 ; i < piecesToBeSaved . length ; i ++ ) { if ( piecesToBeSaved [ i ] [ j ] . getPieceColour ( ) == Piece . OthelloPieceColour . BLACK ) { Element newBlackPiece ; if ( Game . getPlayer ( 0 ) . getColour ( ) . equals ( "Black" ) ) { newBlackPiece = getDoc ( ) . createElement ( "piece1" ) ; } else { newBlackPiece = getDoc ( ) . createElement ( "piece2" ) ; } Element x = getDoc ( ) . createElement ( "x" ) ; x . appendChild ( getDoc ( ) . createTextNode ( i + "" ) ) ; Element y = getDoc ( ) . createElement ( "y" ) ; y . appendChild ( getDoc ( ) . createTextNode ( j + "" ) ) ; newBlackPiece . appendChild ( x ) ; newBlackPiece . appendChild ( y ) ; if ( Game . getPlayer ( 0 ) . getColour ( ) . equals ( "Black" ) ) { getPlayers ( 0 ) . appendChild ( newBlackPiece ) ; } else { getPlayers ( 1 ) . appendChild ( newBlackPiece ) ; } } else if ( piecesToBeSaved [ i ] [ j ] . getPieceColour ( ) == Piece . OthelloPieceColour . WHITE ) { Element newWhitePiece ; if ( Game . getPlayer ( 1 ) . getColour ( ) . equals ( "Black" ) ) { newWhitePiece = getDoc ( ) . createElement ( "piece1" ) ; } else { newWhitePiece = getDoc ( ) . createElement ( "piece2" ) ; } Element x = getDoc ( ) . createElement ( "x" ) ; x . appendChild ( getDoc ( ) . createTextNode ( i + "" ) ) ; Element y = getDoc ( ) . createElement ( "y" ) ; y . appendChild ( getDoc ( ) . createTextNode ( j + "" ) ) ; newWhitePiece . appendChild ( x ) ; newWhitePiece . appendChild ( y ) ; if ( Game . getPlayer ( 1 ) . getColour ( ) . equals ( "Black" ) ) { getPlayers ( 0 ) . appendChild ( newWhitePiece ) ; } else { getPlayers ( 1 ) . appendChild ( newWhitePiece ) ; } } else { } } } }
va	8	public void paste ( SimpleFrame panelText ) { panelText . setAction ( false ) ; String clipboardText = null ; Transferable trans = Toolkit . getDefaultToolkit ( ) . getSystemClipboard ( ) . getContents ( null ) ; if ( trans != null && trans . isDataFlavorSupported ( DataFlavor . stringFlavor ) ) { try { clipboardText = ( String ) trans . getTransferData ( DataFlavor . stringFlavor ) ; int position = panelText . getText ( ) . getCaretPosition ( ) ; ActionsHistoryImpl . action type = ActionsHistoryImpl . action . ADD ; ActionData data = new ActionData ( panelText . getText ( ) . getCaretPosition ( ) , panelText . getText ( ) . getText ( ) , false ) ; String login = panelText . getLogin ( ) ; data = panelText . getList ( ) . newPutString ( clipboardText , position , type , data , login ) ; panelText . getText ( ) . setText ( data . getPanelText ( ) ) ; panelText . getText ( ) . setCaretPosition ( data . getCaretPosition ( ) ) ; panelText . setIsChanged ( data . getChanged ( ) ) ; } catch ( UnsupportedFlavorException e ) { JOptionPane . showMessageDialog ( panelText , "Pasting error" ) ; } catch ( IOException e ) { JOptionPane . showMessageDialog ( panelText , "Disconect from server" ) ; } } if ( panelText . getText ( ) . getCaretPosition ( ) == 0 ) { panelText . getText ( ) . setText ( clipboardText + panelText . getText ( ) . getText ( ) ) ; panelText . setAction ( true ) ; return ; } if ( panelText . getText ( ) . getCaretPosition ( ) > 0 && panelText . getText ( ) . getCaretPosition ( ) < panelText . getText ( ) . getText ( ) . length ( ) ) { int begin1 = 0 ; int finish1 = panelText . getText ( ) . getCaretPosition ( ) ; String text1 = panelText . getText ( ) . getText ( ) . substring ( begin1 , finish1 ) ; int begin2 = panelText . getText ( ) . getCaretPosition ( ) ; int finish2 = panelText . getText ( ) . getText ( ) . length ( ) ; String text2 = panelText . getText ( ) . getText ( ) . substring ( begin2 , finish2 ) ; panelText . getText ( ) . setText ( text1 + clipboardText + text2 ) ; panelText . setAction ( true ) ; return ; } if ( panelText . getText ( ) . getCaretPosition ( ) == panelText . getText ( ) . getText ( ) . length ( ) ) { panelText . getText ( ) . setText ( panelText . getText ( ) . getText ( ) + clipboardText ) ; panelText . setAction ( true ) ; return ; } }
va	7	public boolean updateDocument ( Update update ) { if ( ( update == null ) || ( update . getDocId ( ) == null ) || ( update . getDocId ( ) . equals ( "" ) ) ) { return false ; } String url = null ; String [ ] elements = update . getName ( ) . split ( "/" ) ; url = this . name + "/" + ( ( elements . length < 2 ) ? elements [ 0 ] : DESIGN + elements [ 0 ] + UPDATE + elements [ 1 ] ) + "/" + update . getDocId ( ) ; if ( update . getMethodPOST ( ) ) { try { CouchResponse resp = session . post ( url , "application/x-www-form-urlencoded" , update . getURLFormEncodedString ( ) , null ) ; return resp . isOk ( ) ; } catch ( Exception e ) { return false ; } } else { try { CouchResponse resp = session . put ( url , null , null , update . getQueryString ( ) ) ; return resp . isOk ( ) ; } catch ( Exception e ) { return false ; } } }
va	9	private JComponent createComponent ( final SimulationParameter p ) { final ValueConverter converter = new ValueConverter ( p ) ; final JComponent result ; if ( p . isNumericParameter ( ) && ! p . getHints ( SliderHint . class ) . isEmpty ( ) ) { result = createNumericInput ( converter , p . getHints ( SliderHint . class ) . get ( 0 ) ) ; } else if ( p . getType ( ) == Color . class ) { final JButton tmp = new JButton ( "    " ) ; tmp . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { Color result = JColorChooser . showDialog ( null , p . getName ( ) , ( Color ) p . getValue ( ) ) ; if ( result != null ) { p . setValue ( result ) ; tmp . setForeground ( result ) ; tmp . setBackground ( result ) ; } } } ) ; final Color c = ( Color ) p . getValue ( ) ; tmp . setForeground ( c ) ; tmp . setBackground ( c ) ; result = tmp ; } else if ( p . getType ( ) == boolean . class || p . getType ( ) == boolean . TYPE ) { if ( p . isWriteOnly ( ) ) { final JButton tmp = new JButton ( "Trigger" ) ; result = tmp ; } else { final JCheckBox tmp = new JCheckBox ( ) ; tmp . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { converter . apply ( tmp . isSelected ( ) ) ; } } ) ; final Object value = p . getValue ( ) ; tmp . setSelected ( value == null ? false : ( boolean ) value ) ; if ( p . isReadOnly ( ) ) { tmp . setEnabled ( false ) ; } result = tmp ; } } else { final JTextField tmp = new JTextField ( ) ; tmp . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { converter . apply ( tmp . getText ( ) ) ; } } ) ; tmp . addFocusListener ( new FocusListener ( ) { @ Override public void focusLost ( FocusEvent e ) { converter . apply ( tmp . getText ( ) ) ; } @ Override public void focusGained ( FocusEvent e ) { } } ) ; final Object value = p . getValue ( ) ; tmp . setText ( value == null ? "" : value . toString ( ) ) ; if ( p . isReadOnly ( ) ) { tmp . setEditable ( false ) ; tmp . setEnabled ( false ) ; } result = tmp ; } return result ; }
va	4	public static String getDescription ( int value ) { String description = "Undefined" ; switch ( value ) { case ENGINE_SMOKE_AND_SMOKE_PLUME : description = "Entity emitting engine smoke and smoke plume is rising from the entity" ; break ; case ENGINE_SMOKE : description = "Entity is emitting engine smoke" ; break ; case SMOKE_PLUME : description = "Smoke plume is rising from the entity" ; break ; case NOT_SMOKING : description = "Not Smoking" ; break ; } return description ; }
va	5	private PairNode < T > combineSiblings ( PairNode < T > firstSibling ) { if ( firstSibling . nextSibling == null ) return firstSibling ; int numSiblings = 0 ; for ( ; firstSibling != null ; numSiblings ++ ) { treeArray = doubleIfFull ( treeArray , numSiblings ) ; treeArray [ numSiblings ] = firstSibling ; firstSibling . prev . nextSibling = null ; firstSibling = firstSibling . nextSibling ; } treeArray = doubleIfFull ( treeArray , numSiblings ) ; treeArray [ numSiblings ] = null ; int i = 0 ; for ( ; i + 1 < numSiblings ; i += 2 ) treeArray [ i ] = compareAndLink ( treeArray [ i ] , treeArray [ i + 1 ] ) ; int j = i - 2 ; if ( j == numSiblings - 3 ) treeArray [ j ] = compareAndLink ( treeArray [ j ] , treeArray [ j + 2 ] ) ; for ( ; j >= 2 ; j -= 2 ) treeArray [ j - 2 ] = compareAndLink ( treeArray [ j - 2 ] , treeArray [ j ] ) ; return ( PairNode < T > ) treeArray [ 0 ] ; }
va	1	private static int productOfDigits ( String digits ) { int product = 1 ; for ( int position = 0 ; position < digits . length ( ) ; position ++ ) { product *= Integer . parseInt ( "" + digits . charAt ( position ) ) ; } return product ; }
va	6	public void stateChanged ( ChangeEvent e ) { SpinnerNumberModel model = ( SpinnerNumberModel ) ( ( JSpinner ) e . getSource ( ) ) . getModel ( ) ; int value = model . getNumber ( ) . intValue ( ) ; boolean increase = ( value > oldSpinnerValue ) ? true : false ; oldSpinnerValue = value ; int month = getMonth ( ) ; if ( increase ) { month += 1 ; if ( month == 12 ) { month = 0 ; if ( yearChooser != null ) { int year = yearChooser . getYear ( ) ; year += 1 ; yearChooser . setYear ( year ) ; } } } else { month -= 1 ; if ( month == - 1 ) { month = 11 ; if ( yearChooser != null ) { int year = yearChooser . getYear ( ) ; year -= 1 ; yearChooser . setYear ( year ) ; } } } setMonth ( month ) ; }
va	3	@ Override protected void parse ( ) { for ( Entry < String , String > parameter : parameters . entrySet ( ) ) { if ( parameter . getKey ( ) . startsWith ( "--" ) ) { addLongOption ( parameter . getKey ( ) . substring ( 2 ) , parameter . getValue ( ) ) ; } else if ( - == parameter . getKey ( ) . charAt ( 0 ) ) { addShortOption ( parameter . getKey ( ) . substring ( 1 ) , parameter . getValue ( ) ) ; } else { addArgument ( parameter . getKey ( ) , parameter . getValue ( ) ) ; } } }
va	1	public void addModel ( Model value ) { if ( value != null ) { value . setParent ( this ) ; this . geometry . add ( value ) ; markCreatedNode ( value ) ; } }
va	1	public void NotifyServerStatusChanged ( ) { for ( IServerStatusChangedNotification sscn : serverStatusChangedNotificationListeners ) { sscn . onServerStatusChanged ( ) ; } }
va	2	public JSONArray names ( ) { JSONArray ja = new JSONArray ( ) ; Iterator keys = keys ( ) ; while ( keys . hasNext ( ) ) { ja . put ( keys . next ( ) ) ; } return ja . length ( ) == 0 ? null : ja ; }
va	3	@ Override public void run ( ) { Board b = model . getBoard ( ) ; if ( b . isWhiteTurn ( ) ) { whiteTime -- ; if ( whiteTime <= 0 ) { model . gameExpired ( ) ; } } else { blackTime -- ; if ( blackTime <= 0 ) { model . gameExpired ( ) ; } } b . updateBlackTime ( blackTime ) ; b . updateWhiteTime ( whiteTime ) ; model . updateBoard ( b , false ) ; }
va	4	@ Override public void run ( ) { PrintWriter out = null ; BufferedReader in = null ; try { out = new PrintWriter ( clientSocket . getOutputStream ( ) , true ) ; in = new BufferedReader ( new InputStreamReader ( clientSocket . getInputStream ( ) ) ) ; out . println ( "Hello  you are successfully connected" ) ; String fromClient ; while ( ( fromClient = in . readLine ( ) ) != null ) { System . out . println ( "Client_" + thisId + ": " + fromClient ) ; if ( fromClient . equals ( "exit" ) ) { break ; } out . println ( "OK" ) ; } } catch ( IOException e ) { e . printStackTrace ( ) ; } finally { out . close ( ) ; try { in . close ( ) ; clientSocket . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } }
va	4	private static void cal ( String inputStr , String str2 , int [ ] array , int p_len , int s_len , int print_arr_num , int p_start_num , int s_start_num ) { int pStartnum = p_start_num ; int sStartnum = s_start_num ; int printNum = print_arr_num ; if ( printNum == s_len ) { count ++ ; } for ( int i = pStartnum ; i < p_len ; i ++ ) { for ( int j = sStartnum ; j < s_len ; j ++ ) { if ( inputStr . charAt ( i ) == str . charAt ( j ) ) { array [ printNum ] = i ; pStartnum = i ; sStartnum = j ; cal ( inputStr , str , array , p_len , s_len , printNum + 1 , pStartnum + 1 , sStartnum + 1 ) ; } } } }
va	9	private void modifyPanelInit ( ) { modifyPanel = new JPanel ( ) ; modifyPanel . setLayout ( new BoxLayout ( modifyPanel , BoxLayout . Y_AXIS ) ) ; generator . createRigidSpace ( modifyPanel , 5 ) ; final JTable allEmployees = new JTable ( allEmployeesModel . getTableModel ( 1 ) ) ; allEmployees . removeColumn ( allEmployees . getColumn ( "ID Number" ) ) ; allEmployees . setPreferredScrollableViewportSize ( new Dimension ( 450 , 70 ) ) ; allEmployees . setFillsViewportHeight ( true ) ; allEmployees . setSelectionMode ( ListSelectionModel . SINGLE_SELECTION ) ; JScrollPane scroll = new JScrollPane ( allEmployees ) ; scroll . setMaximumSize ( new Dimension ( TableWidth , 300 ) ) ; modifyPanel . add ( scroll ) ; allEmployees . getColumnModel ( ) . getColumn ( 4 ) . setPreferredWidth ( 10 ) ; allEmployees . getColumnModel ( ) . getColumn ( 6 ) . setPreferredWidth ( 10 ) ; JLabel idLabel = generator . createLabel ( modifyPanel , "Please choose a row" , "" ) ; JLabel fNameLabel = generator . createLabel ( modifyPanel , "First Name" ) ; final JTextField fNameInput = generator . createTextField ( modifyPanel , "" ) ; JLabel lNameLabel = generator . createLabel ( modifyPanel , "Last Name" ) ; final JTextField lNameInput = generator . createTextField ( modifyPanel , "" ) ; JLabel phoneLabel = generator . createLabel ( modifyPanel , "Phone Number (xxx-xxx-xxxx)" ) ; final JTextField phoneInput = generator . createTextField ( modifyPanel , "" ) ; JLabel wageLabel = generator . createLabel ( modifyPanel , "Wage" ) ; final JTextField wageInput = generator . createTextField ( modifyPanel , "" ) ; JLabel addressLabel = generator . createLabel ( modifyPanel , "Address" ) ; final JTextField addressInput = generator . createTextField ( modifyPanel , "" ) ; JLabel positionLabel = generator . createLabel ( modifyPanel , "Position" ) ; final JTextField positionInput = generator . createTextField ( modifyPanel , "" ) ; JLabel dateOfBirthLabel = generator . createLabel ( modifyPanel , "Date of Birth (yyyy-mm-dd)" ) ; final JTextField dateofBirthInput = generator . createTextField ( modifyPanel , "" ) ; final JLabel resultLabel = generator . createLabel ( modifyPanel , "" ) ; JButton updateButton = generator . createButton ( modifyPanel , "Update" , 10 ) ; JButton backButton = generator . createButton ( modifyPanel , "Back" , mainViewName , 5 ) ; updateButton . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { boolean result = false ; EmployeeClass modifiedEmployee ; double wage = 0 ; if ( fNameInput . getText ( ) . matches ( "" ) || lNameInput . getText ( ) . matches ( "" ) || phoneInput . getText ( ) . matches ( "" ) || addressInput . getText ( ) . matches ( "" ) || dateofBirthInput . getText ( ) . matches ( "" ) || positionInput . getText ( ) . matches ( "" ) || wageInput . getText ( ) . matches ( "" ) ) { resultLabel . setText ( "Please fill out the empty fields" ) ; return ; } if ( allEmployees . getSelectedRow ( ) == - 1 ) { resultLabel . setText ( "Please select a row  Please try again..." ) ; return ; } try { wage = double . parseDouble ( wageInput . getText ( ) ) ; } catch ( NumberFormatException e1 ) { resultLabel . setText ( "Error wage MUST a number" ) ; return ; } modifiedEmployee = new EmployeeClass ( fNameInput . getText ( ) , lNameInput . getText ( ) , phoneInput . getText ( ) , addressInput . getText ( ) , dateofBirthInput . getText ( ) , positionInput . getText ( ) , wage ) ; result = modifiedEmployee . verifyInput ( ) ; if ( ! result ) { resultLabel . setText ( "Employee didn't update correctly  please try again" ) ; return ; } result = EmployeeControllerClass . getInstance ( ) . modifyEmployee ( modifiedEmployee ) ; if ( ! result ) { resultLabel . setText ( "Employee didn't update correctly  please try again" ) ; } else { resultLabel . setText ( "Employee successfully updated!" ) ; Object [ ] modifiedRow = { modifiedEmployee . getEmployeeId ( ) , modifiedEmployee . getFirstName ( ) , modifiedEmployee . getLastName ( ) , modifiedEmployee . getAddress ( ) , modifiedEmployee . getPhone ( ) , modifiedEmployee . getBirthDate ( ) , modifiedEmployee . getPosition ( ) , modifiedEmployee . getWage ( ) } ; allEmployeesModel . modifyData ( modifiedRow , allEmployees . getSelectedRow ( ) ) ; fNameInput . setText ( "" ) ; lNameInput . setText ( "" ) ; phoneInput . setText ( "" ) ; wageInput . setText ( "" ) ; addressInput . setText ( "" ) ; positionInput . setText ( "" ) ; dateofBirthInput . setText ( "" ) ; } } } ) ; ListSelectionModel rowSM = allEmployees . getSelectionModel ( ) ; rowSM . addListSelectionListener ( new ListSelectionListener ( ) { @ Override public void valueChanged ( ListSelectionEvent arg0 ) { Object [ ] data = allEmployeesModel . getData ( allEmployees . getSelectedRow ( ) ) ; fNameInput . setText ( ( String ) data [ 1 ] ) ; lNameInput . setText ( ( String ) data [ 2 ] ) ; addressInput . setText ( ( String ) data [ 3 ] ) ; phoneInput . setText ( ( String ) data [ 4 ] ) ; dateofBirthInput . setText ( ( String ) data [ 5 ] ) ; positionInput . setText ( ( String ) data [ 6 ] ) ; wageInput . setText ( String . valueOf ( ( double ) data [ 7 ] ) ) ; } } ) ; }
va	8	public AbstractEntity getEntity ( String name ) { if ( ! entityCache . containsKey ( name ) ) { boolean isSolid = true ; int buyValue = - 1 ; int sellValue = - 1 ; Element root = document . getRootElement ( ) ; for ( Iterator i = root . elementIterator ( ) ; i . hasNext ( ) ; ) { Element element = ( Element ) i . next ( ) ; if ( name . equals ( element . attributeValue ( "name" ) ) ) { for ( Iterator j = element . attributeIterator ( ) ; j . hasNext ( ) ; ) { Attribute attribute = ( Attribute ) j . next ( ) ; if ( "solid" . equals ( attribute . getName ( ) ) ) { if ( "false" . equals ( attribute . getStringValue ( ) ) ) { isSolid = false ; } } else if ( "buyValue" . equals ( attribute . getName ( ) ) ) { buyValue = Integer . parseInt ( attribute . getStringValue ( ) ) ; } else if ( "sellValue" . equals ( attribute . getName ( ) ) ) { sellValue = Integer . parseInt ( attribute . getStringValue ( ) ) ; } } } } AbstractEntity entitiy = new EntityInstance ( name , isSolid , buyValue , sellValue ) ; entityCache . put ( name , entitiy ) ; } return entityCache . get ( name ) ; }
va	5	int binarySearch ( int [ ] A , int target , int start , int end ) { if ( end < start ) return - 1 ; int mid = ( start + end ) / 2 ; if ( A [ mid ] == target ) return mid ; if ( target < A [ start ] || target > A [ end ] ) return - 1 ; if ( target < A [ mid ] ) { return binarySearch ( A , target , start , mid - 1 ) ; } else { return binarySearch ( A , target , mid + 1 , end ) ; } }
va	3	private static void = ( int n , String [ ] a , String [ ] b ) { if ( a . length != b . length ) { System . err . println ( "Case " + n + " failed: returned " + a . length + " elements; expected " + b . length + " elements." ) ; return ; } for ( int i = 0 ; i < a . length ; i ++ ) if ( ! a [ i ] . equals ( b [ i ] ) ) { System . err . println ( "Case " + n + " failed. Expected and returned array differ in position " + i ) ; print ( b ) ; print ( a ) ; return ; } System . err . println ( "Case " + n + " passed." ) ; }
va	9	public Environment ( int width , int height , Collection < Element > elements ) { this . width = width ; this . height = height ; for ( Element element : elements ) { switch ( element . getElementType ( ) ) { case BOOKSHELF : this . bookshelfs . add ( ( Bookshelf ) element ) ; break ; case DESK : this . desks . add ( ( Desk ) element ) ; break ; case OBSTRUCTION : this . obstructions . add ( ( Obstruction ) element ) ; break ; case ROBOT : this . robots . add ( ( Robot ) element ) ; break ; case ROBOT_AREA : case ROBOT_START_POINT : case STUDENT_AREA : case STUDENT_ENTRY : case STUDENT_EXIT : this . markers . add ( ( Marker ) element ) ; break ; default : throw new EnvinronmentException ( "Element srodowiska: " + element + "nie powinien sie tu znalezc" ) ; } } }
va	7	@ Override protected boolean canFigureAtack ( Point x , Point Abs ) { if ( x . x == 0 && x . y != 0 || x . y == 0 && x . x != 0 ) if ( inLineOfSight ( x , Abs ) && C . isFigure ( Abs ) && C . getFigure ( Abs ) . isEnemyOf ( isWhite ) ) return true ; return false ; }
va	0	public void setCurrentPlayer ( final String playeName ) { playerName . setText ( "Current Player: " + playeName ) ; playerName . setForeground ( Teams . getTeamColor ( Teams . getTeamOfPlayer ( playeName ) ) ) ; playerName . repaint ( ) ; }
va	0	@ XmlElementDecl ( namespace = "com/firstdata/Merchant/gmfV3.10" , name = "FeeAmt" ) public JAXBElement < String > createFeeAmt ( String value ) { return new JAXBElement < String > ( _FeeAmt_QNAME , String . class , null , value ) ; }
va	1	public void winActions ( ) { if ( recorder != null ) recorder . fillGamePlayMetrics ( ( RandomLevel ) level ) ; marioComponent . win ( ) ; }
va	6	public boolean equals ( confirm_result that ) { if ( that == null ) return false ; boolean this_present_success = true ; boolean that_present_success = true ; if ( this_present_success || that_present_success ) { if ( ! ( this_present_success && that_present_success ) ) return false ; if ( this . success != that . success ) return false ; } return true ; }
va	1	public static CacheManager getInstance ( ) { if ( instance == null ) instance = new CacheManager ( ) ; return instance ; }
va	8	public ArrayList < Train > getListeParDepartArrive ( String depart , String arrive ) throws IOException { ArrayList < Train > trains = new ArrayList < Train > ( ) ; String nameGareDepart = depart ; String nameGareArrivee = arrive ; String disp = "/formGares.jsp" ; if ( nameGareDepart . length ( ) > 0 && nameGareArrivee . length ( ) > 0 ) { String classeNameDriver = "org.postgresql.Driver" ; String user = "panqahwnbgypyh" ; String mdp = "IAU5rcF7i8sNF3nP_xaWzW_vhJ" ; String jdbc_DB = "jdbc:postgresql://ec2-54-83-204-85.compute-1.amazonaws.com:5432/d56j3th66kubkh" ; String dataBaseName = "PostGres" ; Connection connection = null ; BddUtility bu = new BddUtility ( classeNameDriver , user , mdp , jdbc_DB , dataBaseName , connection ) ; bu . initConnection ( ) ; connection = bu . getConnection ( ) ; GareDAO dao = new GareDAO ( ) ; ArrayList < Gare > gares = new ArrayList < Gare > ( ) ; ResultSet rsDepart = null ; ResultSet rsArrivee = null ; try { rsDepart = dao . getGare ( connection , nameGareDepart ) ; rsArrivee = dao . getGare ( connection , nameGareArrivee ) ; while ( rsDepart . next ( ) ) { Gare g = new Gare ( rsDepart ) ; gares . add ( g ) ; } while ( rsArrivee . next ( ) ) { Gare g = new Gare ( rsArrivee ) ; gares . add ( g ) ; } } catch ( SQLException e2 ) { e2 . printStackTrace ( ) ; } if ( gares . size ( ) == 2 ) { String numGareDepart = "" + gares . get ( 0 ) . getCode_uic ( ) ; String numGareArrivee = "" + gares . get ( 1 ) . getCode_uic ( ) ; URLConnection yc = connectTo ( "http://api.transilien.com/gare/" + numGareDepart + "/depart/" + numGareArrivee + "/" ) ; Document doc ; yc . connect ( ) ; try { doc = parseXML ( yc . getInputStream ( ) ) ; NodeList descNodesNum = doc . getElementsByTagName ( "num" ) ; NodeList descNodesDateDepart = doc . getElementsByTagName ( "date" ) ; NodeList descNodesMiss = doc . getElementsByTagName ( "miss" ) ; NodeList descNodesTerm = doc . getElementsByTagName ( "term" ) ; for ( int i = 0 ; i < descNodesNum . getLength ( ) ; i ++ ) { Train train = new Train ( ) ; train . setNumero ( descNodesNum . item ( i ) . getTextContent ( ) ) ; train . setDateDepart ( descNodesDateDepart . item ( i ) . getTextContent ( ) ) ; train . setMiss ( descNodesMiss . item ( i ) . getTextContent ( ) ) ; train . setTerm ( descNodesTerm . item ( i ) . getTextContent ( ) ) ; trains . add ( train ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } } return trains ; }
va	0	@ Override public Controller getController ( ) { return ctrl ; }
va	5	private void configIncludeAndNonInclude ( ) { try { StringBuilder includeSB = new StringBuilder ( ) ; int i = 0 ; for ( String include : FileUtils . getIncludeProperties ( ) ) { if ( i == 0 ) { includeSB . append ( include ) ; } else { includeSB . append ( SEPERATED_SYMBOL ) . append ( include ) ; } i ++ ; } includeTextField . setText ( includeSB . toString ( ) ) ; StringBuilder nonIncludeSB = new StringBuilder ( ) ; int j = 0 ; for ( String nonInclude : FileUtils . getNonIncludeProperties ( ) ) { if ( j == 0 ) { nonIncludeSB . append ( nonInclude ) ; } else { nonIncludeSB . append ( SEPERATED_SYMBOL ) . append ( nonInclude ) ; } j ++ ; } nonIncludeTextField . setText ( nonIncludeSB . toString ( ) ) ; } catch ( DocumentException e1 ) { UISupport . showMessage ( "Include and Non-include configuration error!" ) ; } }
va	3	@ Override public boolean rotateRight ( Token [ ] [ ] tokens , int [ ] [ ] currentTokens , int rotateCount ) { if ( rotateCount % 4 == 0 ) { x0 = currentTokens [ 0 ] [ 0 ] ; y0 = currentTokens [ 0 ] [ 1 ] + 2 ; x1 = currentTokens [ 1 ] [ 0 ] + 1 ; y1 = currentTokens [ 1 ] [ 1 ] - 1 ; x2 = currentTokens [ 2 ] [ 0 ] ; y2 = currentTokens [ 2 ] [ 1 ] ; x3 = currentTokens [ 3 ] [ 0 ] - 1 ; y3 = currentTokens [ 3 ] [ 1 ] + 1 ; } else if ( rotateCount % 4 == 1 ) { x0 = currentTokens [ 0 ] [ 0 ] - 2 ; y0 = currentTokens [ 0 ] [ 1 ] ; x1 = currentTokens [ 1 ] [ 0 ] + 1 ; y1 = currentTokens [ 1 ] [ 1 ] + 1 ; x2 = currentTokens [ 2 ] [ 0 ] ; y2 = currentTokens [ 2 ] [ 1 ] ; x3 = currentTokens [ 3 ] [ 0 ] - 1 ; y3 = currentTokens [ 3 ] [ 1 ] - 1 ; } else if ( rotateCount % 4 == 2 ) { x0 = currentTokens [ 0 ] [ 0 ] ; y0 = currentTokens [ 0 ] [ 1 ] - 2 ; x1 = currentTokens [ 1 ] [ 0 ] - 1 ; y1 = currentTokens [ 1 ] [ 1 ] + 1 ; x2 = currentTokens [ 2 ] [ 0 ] ; y2 = currentTokens [ 2 ] [ 1 ] ; x3 = currentTokens [ 3 ] [ 0 ] + 1 ; y3 = currentTokens [ 3 ] [ 1 ] - 1 ; } else { x0 = currentTokens [ 0 ] [ 0 ] + 2 ; y0 = currentTokens [ 0 ] [ 1 ] ; x1 = currentTokens [ 1 ] [ 0 ] - 1 ; y1 = currentTokens [ 1 ] [ 1 ] - 1 ; x2 = currentTokens [ 2 ] [ 0 ] ; y2 = currentTokens [ 2 ] [ 1 ] ; x3 = currentTokens [ 3 ] [ 0 ] + 1 ; y3 = currentTokens [ 3 ] [ 1 ] + 1 ; } return setCurrentTokens ( currentTokens ) ; }
va	2	public RawMaterialPost ( JSONObject json ) throws JSONException { super ( "" , "" ) ; name = json . getString ( "name" ) ; value = json . getDouble ( "value" ) ; groupName = json . getString ( "groupName" ) ; JSONArray jHappenings = json . getJSONArray ( "happenings" ) ; for ( int i = 0 ; i < jHappenings . length ( ) ; i ++ ) { happenings . add ( new Happening ( jHappenings . getJSONObject ( i ) ) ) ; } lastUppdateDate = CalendarUtil . parseMillis ( json . getLong ( "lastUpdateDate" ) ) ; JSONArray jMilestones = json . getJSONArray ( "milestones" ) ; for ( int i = 0 ; i < jMilestones . length ( ) ; i ++ ) { mMilestones . add ( new MileStone ( jMilestones . getJSONObject ( i ) ) ) ; } weight = json . getDouble ( "weight" ) ; price = json . getDouble ( "price" ) ; }
va	7	public final LDAPConnection getConnection ( final LDAPResource resource ) throws LDAPException , InvalidBindPasswordException , InvalidBindUserException , InvalidGroupBaseDNException , InvalidInitialContextFactoryException , InvalidPortException , InvalidResourceException , InvalidSearchScopeException , InvalidSearchTimeoutException , InvalidSecurityAuthenticationException , InvalidServerException , InvalidServerVendorException , InvalidEncryptionMethodException , InvalidUserBaseDNException { LDAPConnection connection = null ; try { Hashtable < String , String > env = new Hashtable < String , String > ( ) ; env . put ( Context . INITIAL_CONTEXT_FACTORY , resource . getInitialContextFactory ( ) ) ; env . put ( Context . PROVIDER_URL , this . getURL ( resource ) ) ; env . put ( Context . SECURITY_AUTHENTICATION , resource . getSecurityAuthentication ( ) ) ; env . put ( Context . SECURITY_PRINCIPAL , resource . getBindUser ( ) ) ; env . put ( Context . SECURITY_CREDENTIALS , resource . getPassword ( ) ) ; if ( SSL_CONNECTION . equals ( resource . getEncryption ( ) ) ) { env . put ( Context . SECURITY_PROTOCOL , SSL_CONNECTION ) ; } LdapContext ctx = new InitialLdapContext ( env , null ) ; if ( TLS_CONNECTION . equals ( resource . getEncryption ( ) ) ) { StartTlsResponse response = ( StartTlsResponse ) ctx . extendedOperation ( new StartTlsRequest ( ) ) ; response . setHostnameVerifier ( new TLSHostnameVerifies ( ) ) ; response . negotiate ( ( SSLSocketFactory ) SSLSocketFactory . getDefault ( ) ) ; } connection = new LDAPConnection ( ctx ) ; String scope = resource . getSearchScope ( ) ; SearchScope searchScope = SearchScope . SUBTREE ; if ( scope . equals ( "subtree" ) ) { searchScope = SearchScope . SUBTREE ; } else if ( scope . equals ( "object" ) ) { searchScope = SearchScope . OBJECT ; } else if ( scope . equals ( "onelevel" ) ) { searchScope = SearchScope . ONE_LEVEL ; } int searchTimeout = Integer . parseInt ( resource . getSearchTimeout ( ) ) ; String secAuth = resource . getSecurityAuthentication ( ) ; connection . setSearchScope ( searchScope ) ; connection . setSearchTimeout ( searchTimeout ) ; connection . setSecurityAuthentication ( secAuth ) ; } catch ( NamingException namingExc ) { throw new LDAPException ( "Error during connection establishment" , namingExc ) ; } catch ( IOException ioExc ) { throw new LDAPException ( "Error during SSL/TLS connection establishment" , ioExc ) ; } return connection ; }
va	9	public static Type widerType ( Type lh , Type rh ) { int cmp = rh . compare ( lh ) ; if ( cmp > 0 ) { if ( lh == Type . nullType && rh instanceof PrimType ) { return ( ( PrimType ) rh ) . boxedType ( ) ; } else { return rh ; } } else if ( cmp == 0 ) { if ( rh instanceof ClassType ) { return rh ; } return lh ; } else if ( cmp == - 1 ) { if ( rh == Type . nullType && lh instanceof PrimType ) { return ( ( PrimType ) lh ) . boxedType ( ) ; } else { return lh ; } } else { Type ret = Type . lowestCommonSuperType ( lh , rh ) ; if ( ret != null ) { return ret ; } return Type . objectType ; } }
va	6	@ Override public AIMove move ( ) { AIMove m = attack . move ( ) ; if ( m . isValid ( ) ) { return m ; } AIHockeyist h = manager . getTeammate ( hockeyistId ) ; AINet net = manager . getHisNet ( ) ; m = new AIMove ( ) ; for ( int i = 1 ; i < 20 ; ++ i ) { AIHockeyist hAfter = AIHockeyist . hockeyistAfterTicks ( h , i ) ; double angle = net . bestScoreAngle ( hAfter . getLocation ( ) , 0.7 * hAfter . getPuckAngleDeviation ( ) ) ; double turnAngle = hAfter . angleTo ( angle ) ; if ( abs ( turnAngle ) / h . getMaxTurnPerTick ( ) <= i ) { AIHockeyist hTurn = AIHockeyist . hockeyistAfterTurnTicks ( h , i , turnAngle ) ; if ( net . canScoreStrike ( hTurn ) ) { m . setTurn ( turnAngle ) ; return m ; } } hAfter = AIHockeyist . hockeyistAfterTicks ( h , i + 10 ) ; angle = net . bestScoreAngle ( hAfter . getLocation ( ) , 0.7 * hAfter . getPuckAngleDeviation ( ) ) ; turnAngle = hAfter . angleTo ( angle ) ; if ( abs ( turnAngle ) / h . getMaxTurnPerTick ( ) <= i ) { AIHockeyist hTurn = AIHockeyist . hockeyistAfterTurnTicks ( h , i , turnAngle ) ; AIHockeyist hSwing = AIHockeyist . hockeyistAfterSwingTicks ( hTurn , 10 ) ; if ( net . canScoreStrike ( hSwing ) ) { m . setTurn ( turnAngle ) ; return m ; } } } m . setValid ( false ) ; return m ; }
va	4	public String second_auth_header ( ) { String val = "" ; String WWW_AUTHENTICATE = "WWW-AUTHENTICATE" ; int endlendl = contents ( ) . indexOf ( "\r\n\r\n" ) ; String upper_contents = contents ( ) . substring ( 0 , endlendl ) . toUpperCase ( ) ; int first = upper_contents . indexOf ( WWW_AUTHENTICATE ) ; int first_eol = upper_contents . indexOf ( "\r\n" , first ) ; if ( first == - 1 ) { return "" ; } String first_header = upper_contents . substring ( first , first_eol ) . split ( ":" ) [ 1 ] . trim ( ) ; String second_header = "" ; if ( first != - 1 ) { int second = upper_contents . indexOf ( WWW_AUTHENTICATE , first + WWW_AUTHENTICATE . length ( ) ) ; if ( second == - 1 ) { return "" ; } int eol = upper_contents . indexOf ( "\r\n" , second ) ; String line = upper_contents . substring ( second , eol ) ; String bits [ ] = line . split ( ":" ) ; second_header = bits [ 1 ] . trim ( ) ; } if ( first_header . equalsIgnoreCase ( "NEGOTIATE" ) ) { val = second_header ; } else { val = first_header ; } return val ; }
va	5	@ Override public int compareTo ( final Version other ) { if ( this == ALL || other == ALL ) { return 0 ; } int c = modifier . compareTo ( other . modifier ) ; if ( c != 0 ) { return c ; } c = major - other . major ; if ( c != 0 ) { return c ; } c = minor - other . minor ; if ( c != 0 ) { return c ; } return revision - other . revision ; }
va	6	HashMap < Character , Integer > generate_map ( String k , int [ ] num ) { int cur_num = 0 ; HashMap < Character , Integer > m = new HashMap < Character , Integer > ( ) ; boolean [ ] filled = new boolean [ 26 ] ; for ( int i = 0 ; i < k . length ( ) ; i ++ ) { char cur_char = k . charAt ( i ) ; int pos = cur_char - A ; if ( ! filled [ pos ] ) { m . put ( Character . valueOf ( cur_char ) , Integer . valueOf ( num [ cur_num ] ) ) ; filled [ pos ] = true ; } else { continue ; } if ( cur_num == 8 ) { cur_num = 0 ; } else { cur_num ++ ; } } for ( int i = 0 ; i < 26 ; i ++ ) { char cur_char = ( char ) ( A + i ) ; if ( ! filled [ i ] ) { m . put ( Character . valueOf ( cur_char ) , Integer . valueOf ( num [ cur_num ] ) ) ; filled [ i ] = true ; } else { continue ; } if ( cur_num == 8 ) { cur_num = 0 ; } else { cur_num ++ ; } } m . put (   , Integer . valueOf ( num [ 9 ] ) ) ; return m ; }
