tr	1	public void startRepairGUI ( ) { EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { try { frame = new RepairGUI ( ) ; frame . setVisible ( true ) ; result = query . query ( nameTBL , 1 , nameID ) ; maxID = query . getLastID ( nameTBL , nameID ) ; insertValues ( result ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } } ) ; }
tr	0	public final String getUserName ( ) { return bukkitPlayer . getName ( ) ; }
tr	1	public void addShutDownHook ( ) { Runtime . getRuntime ( ) . addShutdownHook ( new Thread ( ) { public void run ( ) { try { shutDown ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } } ) ; }
tr	1	@ Override public E actual ( ) { if ( actual == null ) { throw new NullPointerException ( "Error: no se puede acceder el dato actual!" ) ; } return actual . getDato ( ) ; }
tr	5	private long removeRefAskData ( long lIndex ) { AskData refActualElement = GetAskData ( lIndex ) ; if ( refActualElement == null ) return lIndex ; for ( int intIndex = 0 ; intIndex < elementList . size ( ) ; intIndex ++ ) { Object theObject = elementList . get ( intIndex ) ; if ( ( theObject == null ) || ! ( theObject instanceof AskData ) ) continue ; AskData tempRef = ( AskData ) ( theObject ) ; if ( ( AskData . getCPtr ( tempRef ) == AskData . getCPtr ( refActualElement ) ) ) { elementList . remove ( tempRef ) ; break ; } } return lIndex ; }
tr	0	public TasquesPendents ( String any , IClient client ) { this . client = client ; this . any = any ; initialize ( ) ; }
tr	2	public static void main ( final String args [ ] ) { if ( args . length != 0 ) { String name = args [ 0 ] ; try { QueryDefinition query = Settings . getInstance ( ) . getQuery ( name ) ; Response response = query . execute ( ) ; System . out . print ( response . getRawValue ( ) ) ; } catch ( Exception e ) { System . err . print ( e . getMessage ( ) ) ; } } else { invokeLater ( new Runnable ( ) { public void run ( ) { new MainForm ( args ) . setVisible ( true ) ; } } ) ; } }
tr	9	private void cargarTable ( ) { try { if ( tipoLista . equals ( LISTA_CLIENTES ) ) { jButton2 . setText ( "Ver Programas" ) ; jButton2 . setVisible ( true ) ; model = new ClienteTableModel ( Factory . getClienteDAO ( ) . getAll ( ) ) ; } if ( tipoLista . equals ( LISTA_TOP_PESADOS ) ) { model = new ProgramaTableModel ( Factory . getProgramaDAO ( ) . getTop10MasPesados ( ) ) ; } if ( tipoLista . equals ( LISTA_TOP_PAGINAS ) ) { model = new ProgramaTableModel ( Factory . getProgramaDAO ( ) . getTop10MasPaginas ( ) ) ; } if ( tipoLista . equals ( LISTA_PROGRAMAS ) || tipoLista . equals ( LISTA_PROGRAMAS_GEN_HTML ) || tipoLista . equals ( LISTA_PROGRAMAS_GEN_PDF ) ) { model = new ProgramaTableModel ( Factory . getProgramaDAO ( ) . getAll ( ) ) ; jButton2 . setVisible ( true ) ; } if ( tipoLista . equals ( LISTA_PROGRAMAS ) ) { jButton2 . setVisible ( true ) ; jButton2 . setText ( "Ver Paginas" ) ; } } catch ( DatosPaooException ex ) { mostrarException ( "Inicializar ventana" , "Ocurrio un problema al inicializar lista de objetos" ) ; } jTable1 . setModel ( model ) ; if ( model . getRowCount ( ) > 0 ) { jTable1 . getSelectionModel ( ) . setSelectionInterval ( 0 , 0 ) ; } else { jButton2 . setVisible ( false ) ; resultado = new Resultado ( "No hay datos para mostrar" ) ; resultado . setTipo ( Resultado . TIPO_RESULTADO . ERROR ) ; DisplayResultado . showResultado ( getFrame ( ) , "Inicializar ventana" , resultado ) ; } }
tr	9	static private final int jjMoveStringLiteralDfa4_0 ( long old0 , long active0 ) { if ( ( ( active0 &= old0 ) ) == 0 ) return jjStartNfa_0 ( 2 , old0 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 3 , active0 ) ; return 4 ; } switch ( curChar ) { case 71 : return jjMoveStringLiteralDfa5_0 ( active0 , 20 ) ; case 95 : return jjMoveStringLiteralDfa5_0 ( active0 , 1000 ) ; case 97 : return jjMoveStringLiteralDfa5_0 ( active0 , 880 ) ; case 98 : return jjMoveStringLiteralDfa5_0 ( active0 , 40 ) ; case 101 : return jjMoveStringLiteralDfa5_0 ( active0 , 100 ) ; case 111 : return jjMoveStringLiteralDfa5_0 ( active0 , 200 ) ; case 115 : return jjMoveStringLiteralDfa5_0 ( active0 , 2400 ) ; default : break ; } return jjStartNfa_0 ( 3 , active0 ) ; }
tr	8	private boolean r_postlude ( ) { int among_var ; int v_1 ; replab0 : while ( true ) { v_1 = cursor ; lab1 : do { bra = cursor ; among_var = find_among ( a_1 , 3 ) ; if ( among_var == 0 ) { break lab1 ; } ket = cursor ; switch ( among_var ) { case 0 : break lab1 ; case 1 : slice_from ( "\u00E3" ) ; break ; case 2 : slice_from ( "\u00F5" ) ; break ; case 3 : if ( cursor >= limit ) { break lab1 ; } cursor ++ ; break ; } continue replab0 ; } while ( false ) ; cursor = v_1 ; break replab0 ; } return true ; }
tr	7	public Hashtable < String , Neo4jCluster > perform ( DatasetLoader datasetHandler , Neo4jHandler neo4jHandler , double similairtyThreshold , int softClusteringThreshold ) throws Exception { Hashtable < String , Neo4jCluster > clustersList = new Hashtable < String , Neo4jCluster > ( ) ; Hashtable < String , Document > docsHash = datasetHandler . loadDocuments ( ) ; DDSimIF similarityCalculator = new DDSimilairty ( ) ; Enumeration e = docsHash . keys ( ) ; int numberOfClusters = 0 ; while ( e . hasMoreElements ( ) ) { Hashtable < String , double > candidateClustersHash = new Hashtable < String , double > ( ) ; String documentID = ( String ) e . nextElement ( ) ; System . out . println ( "Processing document " + documentID ) ; Document document = docsHash . get ( documentID ) ; Neo4jDocument neo4jDocument = neo4jHandler . loadDocument ( document ) ; boolean clusteredYet = false ; ArrayList < Neo4jDocument > similarDocuments = getSimilarDocuments ( neo4jDocument , neo4jHandler , datasetHandler ) ; for ( Iterator iterator = similarDocuments . iterator ( ) ; iterator . hasNext ( ) ; ) { Neo4jDocument neo4jSimilarDocument = ( Neo4jDocument ) iterator . next ( ) ; if ( neo4jSimilarDocument . getClustersHash ( ) . isEmpty ( ) ) continue ; if ( similarityCalculator . calculateSimilarity ( neo4jDocument , neo4jSimilarDocument , datasetHandler . numberOfDocuments ( ) ) > similairtyThreshold ) { ArrayList < String > candidateDocumentClustersIDs = neo4jSimilarDocument . getClusterIDsList ( ) ; for ( Iterator iterator2 = candidateDocumentClustersIDs . iterator ( ) ; iterator2 . hasNext ( ) ; ) { String candidateClusterID = ( String ) iterator2 . next ( ) ; Neo4jCluster candidateNeo4jCluster = clustersList . get ( candidateClusterID ) ; double averageSimilairtyToCluster = calculateAvgSimilairtyToCluster ( neo4jDocument , candidateNeo4jCluster , datasetHandler , neo4jHandler ) ; if ( averageSimilairtyToCluster > similairtyThreshold ) { clusteredYet = true ; candidateClustersHash . put ( candidateClusterID , averageSimilairtyToCluster ) ; } } } } if ( ! clusteredYet ) { numberOfClusters ++ ; Neo4jCluster newCluster = new Neo4jCluster ( String . valueOf ( numberOfClusters ) ) ; newCluster . addDcoument ( documentID ) ; neo4jDocument . addCluster ( newCluster . getId ( ) , 1 ) ; clustersList . put ( newCluster . getId ( ) , newCluster ) ; } else { String nearestClusterID = getNearestCluster ( candidateClustersHash ) ; Neo4jCluster cluster = clustersList . get ( nearestClusterID ) ; cluster . addDcoument ( neo4jDocument . getDocumentID ( ) ) ; neo4jDocument . addCluster ( nearestClusterID , 1 ) ; } } return clustersList ; }
tr	6	@ Test public void testDefaultVol ( ) throws Exception { String pathname = "test/encfs_samples/testvol-default" ; EncFSFile rootDir = getVolumeRootDir ( pathname , "test" ) ; EncFSFile [ ] files = rootDir . listFiles ( ) ; assertEquals ( 3 , files . length ) ; int numMatches = 0 ; for ( EncFSFile encFSFile : files ) { if ( encFSFile . getName ( ) . equals ( "longfile.txt" ) ) { numMatches ++ ; assert . assertFalse ( encFSFile . isDirectory ( ) ) ; String contents = readInputStreamAsString ( encFSFile ) ; assertEquals ( contents . length ( ) , 6000 ) ; for ( int i = 0 ; i < contents . length ( ) ; i ++ ) { assertTrue ( contents . charAt ( i ) == a ) ; } } else if ( encFSFile . getName ( ) . equals ( "zerofile.bin" ) ) { numMatches ++ ; assert . assertFalse ( encFSFile . isDirectory ( ) ) ; byte zeroBytes [ ] = readInputStreamAsByteArray ( encFSFile ) ; assertEquals ( zeroBytes . length , 10000 ) ; for ( byte zeroByte : zeroBytes ) { assertTrue ( zeroByte == 0 ) ; } } else if ( encFSFile . getName ( ) . equals ( "test.txt" ) ) { numMatches ++ ; assert . assertFalse ( encFSFile . isDirectory ( ) ) ; String contents = readInputStreamAsString ( encFSFile ) ; assertEquals ( "This is a test file.\n" , contents ) ; } } assertEquals ( numMatches , 3 ) ; assertFinalTests ( rootDir ) ; }
tr	0	public HexValidator ( ) { pattern = Pattern . compile ( HEX_PATTERN ) ; }
tr	9	public void testXmlRoundtrip ( ) throws Exception { XmlPullParser xpp = factory . newPullParser ( ) ; assertEquals ( true , xpp . getFeature ( XmlPullParser . FEATURE_PROCESS_NAMESPACES ) ) ; xpp . setInput ( null ) ; try { xpp . setFeature ( FEATURE_XML_ROUNDTRIP , true ) ; } catch ( Exception ex ) { } boolean roundtripSupported = xpp . getFeature ( FEATURE_XML_ROUNDTRIP ) ; if ( ! roundtripSupported ) { return ; } PackageTests . addNote ( "* optional feature  " + FEATURE_XML_ROUNDTRIP + " is supported\n" ) ; StringWriter sw = new StringWriter ( ) ; String s ; xpp . setInput ( new StringReader ( MISC_XML ) ) ; int [ ] holderForStartAndLength = new int [ 2 ] ; char [ ] buf ; while ( xpp . nextToken ( ) != XmlPullParser . END_DOCUMENT ) { switch ( xpp . getEventType ( ) ) { case XmlPullParser . START_TAG : buf = xpp . getTextCharacters ( holderForStartAndLength ) ; s = new String ( buf , holderForStartAndLength [ 0 ] , holderForStartAndLength [ 1 ] ) ; assertEquals ( "roundtrip START_TAG" , xpp . getText ( ) , s ) ; sw . write ( s ) ; break ; case XmlPullParser . END_TAG : buf = xpp . getTextCharacters ( holderForStartAndLength ) ; s = new String ( buf , holderForStartAndLength [ 0 ] , holderForStartAndLength [ 1 ] ) ; assertEquals ( "roundtrip END_TAG" , xpp . getText ( ) , s ) ; sw . write ( s ) ; break ; case XmlPullParser . TEXT : buf = xpp . getTextCharacters ( holderForStartAndLength ) ; s = new String ( buf , holderForStartAndLength [ 0 ] , holderForStartAndLength [ 1 ] ) ; assertEquals ( "roundtrip TEXT" , xpp . getText ( ) , s ) ; sw . write ( s ) ; break ; case XmlPullParser . IGNORABLE_WHITESPACE : buf = xpp . getTextCharacters ( holderForStartAndLength ) ; s = new String ( buf , holderForStartAndLength [ 0 ] , holderForStartAndLength [ 1 ] ) ; assertEquals ( "roundtrip IGNORABLE_WHITESPACE" , xpp . getText ( ) , s ) ; sw . write ( s ) ; break ; case XmlPullParser . CDSECT : sw . write ( "<![CDATA[" ) ; buf = xpp . getTextCharacters ( holderForStartAndLength ) ; s = new String ( buf , holderForStartAndLength [ 0 ] , holderForStartAndLength [ 1 ] ) ; assertEquals ( "roundtrip CDSECT" , xpp . getText ( ) , s ) ; sw . write ( s ) ; sw . write ( "]]>" ) ; break ; case XmlPullParser . PROCESSING_INSTRUCTION : sw . write ( "<?" ) ; buf = xpp . getTextCharacters ( holderForStartAndLength ) ; s = new String ( buf , holderForStartAndLength [ 0 ] , holderForStartAndLength [ 1 ] ) ; assertEquals ( "roundtrip PROCESSING_INSTRUCTION" , xpp . getText ( ) , s ) ; sw . write ( s ) ; sw . write ( "?>" ) ; break ; case XmlPullParser . COMMENT : sw . write ( "<!--" ) ; buf = xpp . getTextCharacters ( holderForStartAndLength ) ; s = new String ( buf , holderForStartAndLength [ 0 ] , holderForStartAndLength [ 1 ] ) ; assertEquals ( "roundtrip COMMENT" , xpp . getText ( ) , s ) ; sw . write ( s ) ; sw . write ( "-->" ) ; break ; case XmlPullParser . ENTITY_REF : sw . write ( "&" ) ; buf = xpp . getTextCharacters ( holderForStartAndLength ) ; s = new String ( buf , holderForStartAndLength [ 0 ] , holderForStartAndLength [ 1 ] ) ; assertEquals ( "roundtrip ENTITY_REF" , xpp . getName ( ) , s ) ; sw . write ( s ) ; sw . write ( ";" ) ; break ; case XmlPullParser . DOCDECL : sw . write ( "<!DOCTYPE" ) ; buf = xpp . getTextCharacters ( holderForStartAndLength ) ; s = new String ( buf , holderForStartAndLength [ 0 ] , holderForStartAndLength [ 1 ] ) ; assertEquals ( "roundtrip DOCDECL" , xpp . getText ( ) , s ) ; sw . write ( s ) ; sw . write ( ">" ) ; break ; default : throw new RuntimeException ( "unknown token type" ) ; } } sw . close ( ) ; String RESULT_XML_BUF = sw . toString ( ) ; assertEquals ( "rountrip XML" , printable ( MISC_XML ) , printable ( RESULT_XML_BUF ) ) ; }
tr	9	@ Override public int [ ] getIntData ( int [ ] a , long startPos , long endPos , long step ) { if ( startPos < 0 || startPos >= length ) { throw new ArrayIndexOutOfBoundsException ( "startPos < 0 || startPos >= length" ) ; } if ( endPos < 0 || endPos > length || endPos < startPos ) { throw new ArrayIndexOutOfBoundsException ( "endPos < 0 || endPos > length || endPos < startPos" ) ; } if ( step < 1 ) { throw new IllegalArgumentException ( "step < 1" ) ; } long len = ( long ) Math . ceil ( ( endPos - startPos ) / ( double ) step ) ; if ( len > getMaxSizeOf32bitArray ( ) ) { return null ; } else { int [ ] out ; if ( a != null && a . length >= len ) { out = a ; } else { out = new int [ ( int ) len ] ; } int idx = 0 ; if ( ptr != 0 ) { for ( long i = startPos ; i < endPos ; i += step ) { out [ idx ++ ] = ( int ) Utilities . UNSAFE . getByte ( ptr + i ) ; } } else { if ( isConstant ( ) ) { for ( long i = startPos ; i < endPos ; i += step ) { out [ idx ++ ] = data [ 0 ] ; } } else { for ( long i = startPos ; i < endPos ; i += step ) { out [ idx ++ ] = ( int ) data [ ( int ) i ] ; } } } return out ; } }
tr	4	private String unquoteString ( String value ) { if ( value . startsWith ( "\"\"\"" ) || value . startsWith ( "'''" ) ) { return value . substring ( 3 , value . length ( ) - 3 ) ; } else if ( value . startsWith ( "\"" ) || value . startsWith ( "'" ) ) { return value . substring ( 1 , value . length ( ) - 1 ) ; } return value ; }
tr	7	private int getCantidadFecha ( Correo correo , Date fecha ) { if ( correo . getIzquierda ( ) == null && correo . getDerecha ( ) == null ) { if ( correo . getFecha ( ) . equals ( fecha ) ) { return 1 ; } else { return 0 ; } } int n = 0 , m = 0 ; if ( correo . getDerecha ( ) != null ) { if ( correo . getDerecha ( ) . getFecha ( ) . equals ( fecha ) ) n ++ ; getCantidadFecha ( correo . getDerecha ( ) , fecha ) ; } if ( correo . getIzquierda ( ) != null ) { if ( correo . getIzquierda ( ) . getFecha ( ) . equals ( fecha ) ) m ++ ; getCantidadFecha ( correo . getIzquierda ( ) , fecha ) ; } return n + m ; }
tr	6	@ Override public V add ( String key , V value ) { if ( key == null || value == null || key . length ( ) == 0 ) { throw new IllegalArgumentException ( ) ; } char c = key . charAt ( 0 ) ; if ( root == null ) { root = new Node < V > ( c ) ; } Node < V > node = addNextHere ( root , c ) ; int length = key . length ( ) ; for ( int i = 1 ; i < length ; ++ i ) { c = key . charAt ( i ) ; node = addNextNotHere ( node , c ) ; } V old = node . value ; node . value = value ; if ( old == null ) { ++ size ; } return old ; }
tr	8	public static void changeProtocolMetadataFile ( String tmpMetadataFile , String identifier ) { String newMetadataFile = "/tmp/PRO" + System . currentTimeMillis ( ) + ".xml" ; FileWriter fichero = null ; PrintWriter pw = null ; File archivo = new File ( tmpMetadataFile ) ; try { fichero = new FileWriter ( newMetadataFile ) ; BufferedReader in = new BufferedReader ( new FileReader ( archivo ) ) ; pw = new PrintWriter ( fichero ) ; String data = "" ; data = in . readLine ( ) ; String spaces = "" ; boolean secId = false ; while ( data != null ) { if ( data . indexOf ( "<identifier>" ) != - 1 ) { secId = true ; } int s = data . indexOf ( "<entry>" ) ; if ( s != - 1 && secId ) { secId = false ; for ( int i = 0 ; i < s ; i ++ ) spaces += " " ; data = spaces + "<entry>" + identifier + "</entry>" ; } pw . println ( data ) ; data = in . readLine ( ) ; } in . close ( ) ; } catch ( IOException e ) { System . out . println ( "unable to find file" ) ; } finally { try { if ( null != fichero ) { fichero . close ( ) ; Process proc = Runtime . getRuntime ( ) . exec ( "cp " + newMetadataFile + " " + tmpMetadataFile ) ; } } catch ( Exception e2 ) { e2 . printStackTrace ( ) ; } } }
tr	8	public String testFile ( CmdOptions parser , Option opt , boolean force , boolean read , boolean oblig ) { String ret = ( String ) parser . getOptionValue ( opt ) ; if ( ret . equalsIgnoreCase ( "-" ) ) return ret ; if ( ret == null ) { if ( oblig ) { System . err . println ( "BAD USAGE. file must be defined: {-f | --file} file" ) ; System . exit ( 0 ) ; } else { return null ; } } boolean cpok = true ; File cpfile = new File ( ret ) ; if ( ! cpfile . exists ( ) ) { cpok = false ; } if ( read ) { if ( ! cpok ) { System . err . println ( "BAD USAGE. file must be an existing file [" + ret + "]" ) ; System . exit ( 0 ) ; } } else { if ( cpok && ! force ) { ret = null ; } } return ret ; }
tr	6	public void upsert ( Data [ ] toUpdate ) throws IOException { try { int actualChunkIdx = 0 , lastChunkIdx = - 1 ; long actualChunkOffset = 0 , oldChunkOffset = - 1 ; int indexInChunk = 0 ; for ( int i = 0 ; i < toUpdate . length ; i ++ ) { actualChunkIdx = header . getChunkId ( toUpdate [ i ] . getKey ( ) ) ; actualChunkOffset = header . getStartOffsetOfChunk ( actualChunkIdx ) ; if ( actualChunkOffset > dataFile . getFilledUpFromContentStart ( ) ) { log . warn ( "Element with key {} was not found. Chunk {} does not exist." , actualChunkIdx , toUpdate [ i ] . getKey ( ) ) ; continue ; } if ( actualChunkIdx != lastChunkIdx ) { if ( oldChunkOffset > - 1 ) { dataFile . write ( oldChunkOffset , workingBuffer ) ; indexInChunk = 0 ; } dataFile . read ( actualChunkOffset , workingBuffer ) ; } int oldIndexInChunk = indexInChunk ; indexInChunk = updateElementInReadBuffer ( toUpdate [ i ] , indexInChunk ) ; if ( indexInChunk == - 1 ) { log . warn ( "Element with key {} was not found and therefore not updated. File: {}  Chunk: {}  Index for searching in buffer: {}  Index after update: {}" , new Object [ ] { toUpdate [ i ] . getKey ( ) , this . dataFilename , actualChunkIdx , oldIndexInChunk , indexInChunk } ) ; indexInChunk = 0 ; } lastChunkIdx = actualChunkIdx ; oldChunkOffset = actualChunkOffset ; } if ( oldChunkOffset > - 1 ) { dataFile . write ( oldChunkOffset , workingBuffer ) ; } } finally { dataFile . close ( ) ; } }
tr	4	protected boolean in_grouping_b ( char [ ] s , int min , int max ) { if ( cursor <= limit_backward ) return false ; char ch = current . charAt ( cursor - 1 ) ; if ( ch > max || ch < min ) return false ; ch -= min ; if ( ( s [ ch >> 3 ] & ( 1 << ( ch & 7 ) ) ) == 0 ) return false ; cursor -- ; return true ; }
tr	0	@ Override public void reset ( ) { graphics = img . getGraphics ( ) ; graphics . setColor ( Color . RED ) ; graphics . fillRect ( 0 , 0 , width , height ) ; }
tr	9	private void generateRandomBreakables ( ) { for ( int i = 3 ; i < 12 ; i ++ ) { if ( this . randomNumber ( 0 , 1 ) == 1 ) { this . addBreakable ( i , 1 ) ; } } for ( int i = 3 ; i <= 13 ; i += 2 ) { if ( this . randomNumber ( 0 , 1 ) == 1 ) { this . addBreakable ( i , 2 ) ; } } for ( int i = 3 ; i <= 9 ; i ++ ) { for ( int j = 1 ; j <= 13 ; j += 2 ) { if ( this . randomNumber ( 0 , 1 ) == 1 ) { this . addBreakable ( j , i ) ; } } } for ( int i = 1 ; i <= 11 ; i += 2 ) { if ( this . randomNumber ( 0 , 1 ) == 1 ) { this . addBreakable ( i , 10 ) ; } } for ( int i = 1 ; i <= 11 ; i ++ ) { if ( this . randomNumber ( 0 , 1 ) == 1 ) { this . addBreakable ( i , 11 ) ; } } }
tr	3	@ Override public boolean addItem ( Item item ) { if ( connection == null || item == null ) { return false ; } boolean result = false ; try ( PreparedStatement stmt = connection . prepareStatement ( INSERT_ITEM_SQL ) ) { stmt . setString ( 1 , item . getName ( ) ) ; stmt . setDouble ( 2 , item . getInitialPrice ( ) ) ; stmt . executeUpdate ( ) ; result = true ; } catch ( SQLException ex ) { logger . error ( "Error while adding an item" , ex ) ; } return result ; }
tr	5	private void dumpBuffer ( String string ) throws IOException { if ( UtpAlgConfiguration . DEBUG ) { log . debug ( "dumping buffer" ) ; RandomAccessFile aFile = new RandomAccessFile ( "testData/auto/bufferdump.txt" , "rw" ) ; FileChannel inChannel = aFile . getChannel ( ) ; inChannel . truncate ( 0 ) ; ByteBuffer bbuffer = ByteBuffer . allocate ( 100000 ) ; bbuffer . put ( ( new SimpleDateFormat ( "dd_MM_hh_mm_ss" ) ) . format ( new Date ( ) ) . getBytes ( ) ) ; bbuffer . put ( ( string + "\n" ) . getBytes ( ) ) ; bbuffer . put ( ( "SIZE: " + Integer . toString ( SIZE ) + "\n" ) . getBytes ( ) ) ; bbuffer . put ( ( "count: " + Integer . toString ( elementCount ) + "\n" ) . getBytes ( ) ) ; bbuffer . put ( ( "expect: " + Integer . toString ( expectedSequenceNumber ) + "\n" ) . getBytes ( ) ) ; bbuffer . put ( ( "lastSeq: " + Integer . toString ( debug_lastSeqNumber ) + "\n" ) . getBytes ( ) ) ; bbuffer . put ( ( "lastPos: " + Integer . toString ( debug_lastPosition ) + "\n" ) . getBytes ( ) ) ; for ( int i = 0 ; i < SIZE ; i ++ ) { String seq ; if ( buffer [ i ] == null ) { seq = "_; " ; } else { seq = Integer . toString ( ( buffer [ i ] . utpPacket ( ) . getSequenceNumber ( ) & FFFF ) ) + "; " ; } bbuffer . put ( ( Integer . toString ( i ) + " -> " + seq ) . getBytes ( ) ) ; if ( i % 50 == 0 ) { bbuffer . put ( "\n" . getBytes ( ) ) ; } } log . debug ( bbuffer . position ( ) + " " + bbuffer . limit ( ) ) ; bbuffer . flip ( ) ; while ( bbuffer . hasRemaining ( ) ) { inChannel . write ( bbuffer ) ; } aFile . close ( ) ; inChannel . close ( ) ; } }
tr	0	public Integer getNum ( ) { return num ; }
tr	6	public static void main ( String [ ] args ) { Rectangle rec = new Rectangle ( new MyPoint ( 2 , 4 ) , new MyPoint ( 4 , 6 ) , new MyPoint ( 2 , 4 ) , new MyPoint ( 4 , 8 ) ) ; class recClass = rec . getClass ( ) ; Field [ ] recFields = recClass . getDeclaredFields ( ) ; Method [ ] recMethods = recClass . getDeclaredMethods ( ) ; System . out . println ( "Class Fields" ) ; for ( Field currField : recFields ) { System . out . println ( currField . getName ( ) ) ; } System . out . println ( "Class Methods" ) ; for ( Method method : recMethods ) { System . out . println ( method . getName ( ) ) ; } class recSuperClass = recClass . getSuperclass ( ) ; if ( recSuperClass == null ) { System . out . println ( String . format ( "The class %s dose not have a super class" , recClass . getSimpleName ( ) ) ) ; } else { System . out . println ( "the super class name is: " + recSuperClass . getSimpleName ( ) ) ; System . out . println ( "Look for constructors" ) ; Constructor [ ] constructors = recSuperClass . getConstructors ( ) ; for ( Constructor constructor : constructors ) { System . out . println ( "Ctor name: " + constructor . getName ( ) ) ; } System . out . println ( "The class " + recSuperClass . getSimpleName ( ) + "" + "is from package " + recSuperClass . getPackage ( ) ) ; } try { class anotherClass = class . forName ( "il.ac.shenkar.point.MyPoint" ) ; Constructor [ ] constructors = anotherClass . getConstructors ( ) ; System . out . println ( "Constructors for: " + anotherClass . getSimpleName ( ) ) ; for ( Constructor constructor : constructors ) { System . out . println ( constructor ) ; } } catch ( ClassNotFoundException e ) { e . printStackTrace ( ) ; } }
tr	9	public void setBaudRate ( int baudrate ) throws MtxCommException { byte data = 0 ; switch ( baudrate ) { case 460800 : data = 0 ; break ; case 230400 : data = 1 ; break ; case 115200 : data = 2 ; break ; case 75800 : data = 3 ; break ; case 57600 : data = 4 ; break ; case 38400 : data = 5 ; break ; case 28800 : data = 6 ; break ; case 19200 : data = 7 ; break ; case 14400 : data = 8 ; break ; case 9600 : data = 9 ; break ; case 921600 : data = - 128 ; break ; default : data = ( byte ) baudrate ; break ; } sendConfigMessage ( new MtxPacket ( MtxPacket . XSENS_REQBAUDRATE , new byte [ ] { data } ) ) ; }
tr	0	public ShareItem ( ) { }
tr	1	public String password ( char [ ] pass ) { String result = "" ; for ( int i = 0 ; i < pass . length ; i ++ ) { result += Character . toString ( pass [ i ] ) ; } return result ; }
tr	0	@ Override public void onFXThreadSuccess ( Backup backup ) { mBackup = backup ; mStage . close ( ) ; }
tr	8	private void init ( ) { int run_server = JOptionPane . showConfirmDialog ( null , "Run the server ? " ) ; if ( run_server == 0 ) { server = new Server ( this ) ; client = new Client ( this , "localhost" ) ; client . start ( ) ; } else if ( run_server == 1 ) { try { client = new Client ( this , JOptionPane . showInputDialog ( null , "Enter IP: " ) ) ; client . start ( ) ; } catch ( HeadlessException e ) { e . printStackTrace ( ) ; } catch ( NumberFormatException e ) { e . printStackTrace ( ) ; } } else if ( run_server == 2 ) { System . out . println ( "Exiting at 0." ) ; System . exit ( 0 ) ; } String username = JOptionPane . showInputDialog ( null , "Enter Username:" ) ; if ( username == null ) { System . out . println ( "Exiting at 1." ) ; System . exit ( 1 ) ; } if ( username . trim ( ) . equals ( "" ) ) { username = "Player" ; } String info = "" + "<html>" + "<h3>SETTINGS:</h3>" + "<table border=1>" + "<tr>" + "<td>Walk:</td>" + "<td style='color: green'>WASD or ARROWS KEYS</td>" + "</tr>" + "<tr>" + "<td>Shoot:</td>" + "<td style='color: green'>LEFT CLICK</td>" + "</tr>" + "<tr>" + "<td>1st Weapon:</td>" + "<td style='color: green'>1</td>" + "</tr>" + "<tr>" + "<td>2nd Weapon:</td>" + "<td style='color: green'>2</td>" + "</tr>" + "<tr>" + "<td>Speed Boost:</td>" + "<td style='color: green'>SHIFT</td>" + "</tr>" + "<tr>" + "<td>Toggle invisible:</td>" + "<td style='color: green'>I</td>" + "</tr>" + "</table>" + "<h4>Good Luck !!!</h3>" + "</html>" ; JOptionPane . showMessageDialog ( null , info ) ; player = new PlayerMP ( 10 , 10 , username , key , mouse , null , - 1 , true ) ; level . addEntity ( player ) ; Packet00Login packet = new Packet00Login ( player . getUsername ( ) , player . getX ( ) , player . getY ( ) , player . getHP ( ) , player . getUniqueID ( ) ) ; packet . writeData ( client ) ; if ( server != null ) { server . addConnections ( ( PlayerMP ) player , packet ) ; server . start ( ) ; Tonny tonny = new Tonny ( 100 , 100 , 100 ) ; Packet05AddNPC packetNPC = new Packet05AddNPC ( ( int ) tonny . getX ( ) , ( int ) tonny . getY ( ) , tonny . getHP ( ) , tonny . getUniqueID ( ) , MobType . TONNY . getID ( ) ) ; packetNPC . writeData ( client ) ; BadTonny bad_tonny = new BadTonny ( 170 , 20 , 20 ) ; packetNPC = new Packet05AddNPC ( ( int ) bad_tonny . getX ( ) , ( int ) bad_tonny . getY ( ) , bad_tonny . getHP ( ) , bad_tonny . getUniqueID ( ) , MobType . BAD_TONNY . getID ( ) ) ; packetNPC . writeData ( client ) ; bad_tonny = new BadTonny ( 200 , 300 , 100 ) ; packetNPC = new Packet05AddNPC ( ( int ) bad_tonny . getX ( ) , ( int ) bad_tonny . getY ( ) , bad_tonny . getHP ( ) , bad_tonny . getUniqueID ( ) , MobType . BAD_TONNY . getID ( ) ) ; packetNPC . writeData ( client ) ; bad_tonny = new BadTonny ( 250 , 300 , 100 ) ; packetNPC = new Packet05AddNPC ( ( int ) bad_tonny . getX ( ) , ( int ) bad_tonny . getY ( ) , bad_tonny . getHP ( ) , bad_tonny . getUniqueID ( ) , MobType . BAD_TONNY . getID ( ) ) ; packetNPC . writeData ( client ) ; } }
tr	3	public static void insertTrainingStatus ( TrainingStatus status , Student student ) { boolean assigned = status . getAssigned ( ) ; String assignedDate = null ; if ( assigned == true ) assignedDate = status . getAssignedDate ( ) ; String supervisor = status . getSupervisor ( ) ; String thesis = status . getThesisTopic ( ) ; boolean plan = status . getIndividualPlan ( ) ; String approvalDate = status . getApprovalDate ( ) ; long studentId = student . getStudentId ( ) ; String insertSQL = "insert into Monitoring " + "(Date) " + "values (?)" ; try { SqlActions . initJDBC ( ) ; dbConn = SqlActions . getDBConn ( ) ; if ( dbConn == null ) throw new SQLException ( "TrainingStatus not inserted" ) ; dbPrepStmnt = dbConn . prepareStatement ( "use phdStudent;" ) ; dbPrepStmnt . executeUpdate ( ) ; dbPrepStmnt = dbConn . prepareStatement ( insertSQL , Statement . RETURN_GENERATED_KEYS ) ; dbPrepStmnt . setString ( 1 , status . getMonitoring ( ) . getMonitoringDate ( ) ) ; dbPrepStmnt . executeUpdate ( ) ; dbRset = dbPrepStmnt . getGeneratedKeys ( ) ; dbRset . next ( ) ; status . getMonitoring ( ) . setMonitoringId ( dbRset . getLong ( 1 ) ) ; insertSQL = "insert into TrainingStatus " + "(studentId  assigned  assignedDate  supervisor  thesis " + "individualPlan  approvalDate  monitoringId) " + "values (?  ?  ?  ?  ?  ?  ?  ?)" ; dbPrepStmnt = dbConn . prepareStatement ( insertSQL , Statement . RETURN_GENERATED_KEYS ) ; dbPrepStmnt . setLong ( 1 , studentId ) ; dbPrepStmnt . setBoolean ( 2 , assigned ) ; dbPrepStmnt . setString ( 3 , assignedDate ) ; dbPrepStmnt . setString ( 4 , supervisor ) ; dbPrepStmnt . setString ( 5 , thesis ) ; dbPrepStmnt . setBoolean ( 6 , plan ) ; dbPrepStmnt . setString ( 7 , approvalDate ) ; dbPrepStmnt . setLong ( 8 , status . getMonitoring ( ) . getMonitoringId ( ) ) ; dbPrepStmnt . executeUpdate ( ) ; dbRset = dbPrepStmnt . getGeneratedKeys ( ) ; dbRset . next ( ) ; status . setTrainingStatusId ( dbRset . getLong ( 1 ) ) ; } catch ( SQLException ex ) { SqlActions . handleEx ( ex ) ; } finally { SqlActions . closeConnections ( dbConn , dbStmnt , dbRs , dbRset ) ; } }
tr	6	public String next ( int n ) throws JSONException { if ( n == 0 ) { return "" ; } char [ ] buffer = new char [ n ] ; int pos = 0 ; if ( this . useLastChar ) { this . useLastChar = false ; buffer [ 0 ] = this . lastChar ; pos = 1 ; } try { int len ; while ( ( pos < n ) && ( ( len = reader . read ( buffer , pos , n - pos ) ) != - 1 ) ) { pos += len ; } } catch ( IOException exc ) { throw new JSONException ( exc ) ; } this . index += pos ; if ( pos < n ) { throw syntaxError ( "Substring bounds error" ) ; } this . lastChar = buffer [ n - 1 ] ; return new String ( buffer ) ; }
tr	1	public static void main ( String [ ] args ) { try { = ( 0 , ( new DropCoins ( ) ) . getMinimum ( new String [ ] { ".o.." , "oooo" , "..o." } , 3 ) , 2 ) ; = ( 1 , ( new DropCoins ( ) ) . getMinimum ( new String [ ] { ".....o" , "......" , "oooooo" , "oooooo" , "......" , "o....." } , 12 ) , 3 ) ; = ( 2 , ( new DropCoins ( ) ) . getMinimum ( new String [ ] { "...." , ".oo." , ".oo." , "...." } , 3 ) , - 1 ) ; = ( 3 , ( new DropCoins ( ) ) . getMinimum ( new String [ ] { "......." , "..ooo.." , "ooooooo" , ".oo.oo." , "oo...oo" } , 12 ) , 4 ) ; = ( 4 , ( new DropCoins ( ) ) . getMinimum ( new String [ ] { "................." , ".ooooooo...oooo.." , ".ooooooo..oooooo." , ".oo.......oo..oo." , ".oo.......oo..oo." , ".ooooo.....oooo.." , ".ooooooo...oooo.." , ".....ooo..oo..oo." , "......oo..oo..oo." , ".ooooooo..oooooo." , ".oooooo....oooo.." , "................." } , 58 ) , 6 ) ; } catch ( Exception exx ) { System . err . println ( exx ) ; exx . printStackTrace ( System . err ) ; } }
tr	1	public void divide ( int ncol , int nrow ) { canvasPads . setSize ( this . getSize ( ) . width , this . getSize ( ) . height , ncol , nrow ) ; int ncharts = canvasPads . getNPads ( ) ; series . clear ( ) ; for ( int loop = 0 ; loop < ncharts ; loop ++ ) { ScGroupSeries chart = new ScGroupSeries ( new ScRegion ( canvasPads . getX ( loop ) , canvasPads . getY ( loop ) , canvasPads . getWidth ( loop ) , canvasPads . getHeight ( loop ) ) ) ; series . add ( chart ) ; } }
tr	0	public String getMateria ( ) { return materia ; }
tr	9	public double evaluate ( FunctionArguments args ) throws IllegalArgumentException , MalformedFunctionException { if ( ( args == null && variables != 0 ) || ( args != null && args . getArgCount ( ) != variables ) ) { throw new IllegalArgumentException ( "Wrong argument count" ) ; } ArrayList < double > stack = new ArrayList < double > ( ) ; Iterator < Token > iter = tokens . iterator ( ) ; do { Token next = iter . next ( ) ; if ( next instanceof ConstantToken ) { stack . add ( ( ( ConstantToken ) next ) . getValue ( ) ) ; } else if ( next instanceof VariableToken ) { stack . add ( args . getArg ( ( ( VariableToken ) next ) . getID ( ) ) ) ; } else if ( next instanceof FunctionToken ) { Function f = ( ( FunctionToken ) next ) . getFunction ( ) ; if ( stack . size ( ) < f . getArgCount ( ) ) { throw new MalformedFunctionException ( "Improper argument count" ) ; } double [ ] d = new double [ f . getArgCount ( ) ] ; for ( int i = 0 ; i < f . getArgCount ( ) ; i ++ ) { d [ d . length - i - 1 ] = stack . remove ( stack . size ( ) - 1 ) ; } stack . add ( f . evaluate ( new FunctionArguments ( d ) ) ) ; } else { throw new MalformedFunctionException ( "Unkown token type" ) ; } } while ( iter . hasNext ( ) ) ; if ( stack . size ( ) != 1 ) { throw new MalformedFunctionException ( "Function was not properly formed" ) ; } return stack . get ( 0 ) ; }
tr	3	public static Node findCycle ( List list ) { if ( list == null ) return null ; Node current = list . getHead ( ) ; Map < Node , boolean > seen = new HashMap < Node , boolean > ( ) ; while ( current != null ) { if ( seen . get ( current ) != null ) { return current ; } seen . put ( current , true ) ; current = current . getNext ( ) ; } return null ; }
tr	6	void trace ( PgPolygonSet output , PdVector seed , int steps , double stepSize ) { output . addVertex ( seed ) ; PdVector cur = seed ; for ( int s = 1 ; s <= steps ; ++ s ) { PdVector last = cur ; cur = next ( cur , stepSize ) ; if ( cur == null ) { break ; } int vertex = output . addVertex ( cur ) ; output . addPolygon ( new PiVector ( vertex - 1 , vertex ) ) ; if ( PdVector . dist ( last , cur ) < ( stepSize / 10d ) ) { break ; } boolean stop = false ; for ( PdVector v : m_stops ) { if ( PdVector . dist ( v , cur ) < ( stepSize / 10d ) ) { stop = true ; break ; } } if ( stop ) { break ; } } }
tr	7	private Object evalFunctionValue ( Scope scope , FunctionValue fv , Object [ ] args ) { final Object o = scope . getVariable ( fv . getName ( ) , true ) ; final int lineno = fv . getLine ( ) ; if ( o instanceof MixinDefinition ) { throw error ( "Mixin not allowed  " + o , lineno ) ; } if ( o instanceof FunctionDefinition ) { return evalDefinition ( scope , ( FunctionDefinition ) o , args , lineno ) ; } if ( o != null ) { return o != null ? o : null ; } final String name = fv . getName ( ) ; final Callable < Object > mtd = getMethod ( name , args ) ; if ( mtd == null ) { if ( fv . isVariableLook ( ) ) { return null ; } throw error ( "Function not found: " + name , lineno ) ; } try { return mtd . call ( ) ; } catch ( Exception ex ) { throw error ( "Unable to invoke " + mtd , lineno , ex ) ; } }
tr	3	public NodeUnion ( Link [ ] links ) { if ( links == null || links . length < 2 || links . length > 4 ) { throw new IllegalArgumentException ( "Links size must be >=2 and <=4" ) ; } this . links = links ; }
tr	2	private static int getPort ( ) throws Exception { if ( port != null ) { return port ; } if ( ! env . containsKey ( "BEANSTALKD_PORT" ) ) { throw new Exception ( "BEANSTALKD_PORT not set" ) ; } port = Integer . parseInt ( ( String ) env . get ( "BEANSTALKD_PORT" ) ) ; return port ; }
tr	1	int BitTreeDecode ( int [ ] paramArrayOfInt , int paramInt1 , int paramInt2 ) throws IOException { int i = 1 ; for ( int j = paramInt2 ; j > 0 ; j -- ) { i = i + i + BitDecode ( paramArrayOfInt , paramInt1 + i ) ; } return i - ( 1 << paramInt2 ) ; }
tr	8	public static boolean overlaps ( Rectangle r1 , Rectangle r2 ) { if ( r1 . contains ( r2 . getLocation ( ) ) ) { return true ; } else if ( r1 . contains ( new Point ( r2 . x + r2 . width , r2 . y ) ) ) { return true ; } else if ( r1 . contains ( new Point ( r2 . x , r2 . y + r2 . height ) ) ) { return true ; } else if ( r1 . contains ( new Point ( r2 . x + r2 . width , r2 . y + r2 . height ) ) ) { return true ; } if ( r2 . contains ( r1 . getLocation ( ) ) ) { return true ; } else if ( r2 . contains ( new Point ( r1 . x + r1 . width , r1 . y ) ) ) { return true ; } else if ( r2 . contains ( new Point ( r1 . x , r1 . y + r1 . height ) ) ) { return true ; } else if ( r2 . contains ( new Point ( r1 . x + r1 . width , r1 . y + r1 . height ) ) ) { return true ; } return false ; }
tr	6	public Builder mergeFrom ( com . google . protobuf . CodedInputStream input , com . google . protobuf . ExtensionRegistryLite extensionRegistry ) throws java . io . IOException { com . google . protobuf . UnknownFieldSet . Builder unknownFields = com . google . protobuf . UnknownFieldSet . newBuilder ( this . getUnknownFields ( ) ) ; while ( true ) { int tag = input . readTag ( ) ; switch ( tag ) { case 0 : this . setUnknownFields ( unknownFields . build ( ) ) ; onChanged ( ) ; return this ; default : { if ( ! parseUnknownField ( input , unknownFields , extensionRegistry , tag ) ) { this . setUnknownFields ( unknownFields . build ( ) ) ; onChanged ( ) ; return this ; } break ; } case 10 : { bitField0_ |= 00000001 ; type_ = input . readBytes ( ) ; break ; } case 16 : { bitField0_ |= 00000002 ; gov_ = input . readInt32 ( ) ; break ; } case 24 : { bitField0_ |= 00000004 ; dep_ = input . readInt32 ( ) ; break ; } } } }
tr	9	public Geometry extrusion ( double [ ] [ ] O , double [ ] [ ] P ) { int m = O . length - 1 ; int n = P . length - 1 ; newRectangularMesh ( m , n ) ; boolean loop = same ( P [ 0 ] , P [ n ] ) ; int N = 0 ; for ( int j = 0 ; j <= n ; j ++ ) { for ( int k = 0 ; k < 3 ; k ++ ) { U [ k ] = P [ j ] [ k + 3 ] ; W [ k ] = j < n ? P [ j + 1 ] [ k ] - P [ j ] [ k ] : loop ? P [ 1 ] [ k ] - P [ 0 ] [ k ] : P [ n ] [ k ] - P [ n - 1 ] [ k ] ; } double radius = Vec . norm ( U ) ; computeCrossVectors ( U , W , V ) ; for ( int i = 0 ; i <= m ; i ++ ) { double x = O [ i ] [ 0 ] ; double y = O [ i ] [ 1 ] ; double z = O [ i ] [ 2 ] ; for ( int k = 0 ; k < 3 ; k ++ ) vertices [ N ] [ k ] = ( P [ j ] [ k ] + radius * ( x * U [ k ] - y * V [ k ] + z * W [ k ] ) ) ; N ++ ; } } if ( loop ) for ( int i = 0 ; i <= nVertices ( ) ; i ++ ) for ( int k = 0 ; k < 3 ; k ++ ) if ( indx ( m , n , i , n ) < nVertices ( ) ) vertices [ indx ( m , n , i , n ) ] [ k ] = vertices [ indx ( m , n , i , 0 ) ] [ k ] ; return this ; }
tr	4	public boolean testRule ( WFF ext , WFF _world , DefaultRule d ) { WFF prec = new WFF ( d . getPrerequisite ( ) ) ; WFF world = new WFF ( _world . getFormula ( ) + " & " + ext . getFormula ( ) ) ; if ( world . entails ( prec ) ) { WFF just = new WFF ( d . getJustificatoin ( ) ) ; if ( just . eval ( ext ) ) { WFF cons = new WFF ( d . getConsequence ( ) ) ; if ( ext . isConsistent ( cons . getFormula ( ) ) ) { if ( ext . entails ( cons ) ) { return true ; } } } } else { } return false ; }
tr	8	private boolean r_shortv ( ) { int v_1 ; lab0 : do { v_1 = limit - cursor ; lab1 : do { if ( ! ( out_grouping_b ( g_v_WXY , 89 , 121 ) ) ) { break lab1 ; } if ( ! ( in_grouping_b ( g_v , 97 , 121 ) ) ) { break lab1 ; } if ( ! ( out_grouping_b ( g_v , 97 , 121 ) ) ) { break lab1 ; } break lab0 ; } while ( false ) ; cursor = limit - v_1 ; if ( ! ( out_grouping_b ( g_v , 97 , 121 ) ) ) { return false ; } if ( ! ( in_grouping_b ( g_v , 97 , 121 ) ) ) { return false ; } if ( cursor > limit_backward ) { return false ; } } while ( false ) ; return true ; }
tr	5	private boolean validateData ( ) { StringBuilder sb = new StringBuilder ( ) ; if ( useIpFilterBox . isSelected ( ) ) { if ( ipField . getText ( ) . isEmpty ( ) ) { sb . append ( "Neplatn\u00FD IP filtr." ) . append ( "\n" ) ; } } if ( usePasswordBox . isSelected ( ) ) { if ( passwordField . getPassword ( ) . length < 3 ) { sb . append ( "P\u0159\u00EDli\u0161 kr\u00E1tk\u00E9 heslo." ) . append ( "\n" ) ; } } if ( sb . length ( ) == 0 ) { return true ; } else { JOptionPane . showMessageDialog ( this , sb . toString ( ) , "Chybn\u00E1 data" , JOptionPane . ERROR_MESSAGE ) ; return false ; } }
tr	7	public static void main ( String [ ] args ) { Connection conn = null ; Statement stmt = null ; try { class . forName ( "com.mysql.jdbc.Driver" ) ; conn = DriverManager . getConnection ( DB_URL , USER , PASS ) ; stmt = conn . createStatement ( ) ; String sql ; sql = "SELECT * FROM Transport" ; ResultSet rs = stmt . executeQuery ( sql ) ; while ( rs . next ( ) ) { int id = rs . getInt ( "ID" ) ; System . out . print ( "ID: " + id ) ; } rs . close ( ) ; stmt . close ( ) ; conn . close ( ) ; } catch ( SQLException se ) { se . printStackTrace ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { try { if ( stmt != null ) stmt . close ( ) ; } catch ( SQLException se2 ) { } try { if ( conn != null ) conn . close ( ) ; } catch ( SQLException se ) { se . printStackTrace ( ) ; } } }
tr	7	public static String doubleToString ( double d ) { if ( double . isInfinite ( d ) || double . isNaN ( d ) ) { return "null" ; } String string = double . toString ( d ) ; if ( string . indexOf ( . ) > 0 && string . indexOf ( e ) < 0 && string . indexOf ( E ) < 0 ) { while ( string . endsWith ( "0" ) ) { string = string . substring ( 0 , string . length ( ) - 1 ) ; } if ( string . endsWith ( "." ) ) { string = string . substring ( 0 , string . length ( ) - 1 ) ; } } return string ; }
tr	6	@ Override public boolean equals ( Object obj ) { if ( null == obj ) { return false ; } if ( this == obj ) { return true ; } if ( obj instanceof PostParameter ) { PostParameter that = ( PostParameter ) obj ; if ( file != null ? ! file . equals ( that . file ) : that . file != null ) return false ; return this . name . equals ( that . name ) && this . value . equals ( that . value ) ; } return false ; }
tr	3	public int tomar_n ( int n ) { if ( this . largo ( ) >= n ) { int cont = 1 ; Nodo nodo = this . nodoInicial ; while ( nodo != null ) { if ( cont == n ) return nodo . getDato ( ) ; nodo = nodo . getSiguiente ( ) ; cont ++ ; } } else throw new ArrayIndexOutOfBoundsException ( ) ; return - 1 ; }
tr	9	@ Override public JSONObject main ( Map < String , String > params , Session session ) throws Exception { JSONObject rtn = new JSONObject ( ) ; long targetUserId = long . parseLong ( params . get ( "id" ) ) ; User targetUser = User . findById ( targetUserId ) ; if ( targetUser == null ) { rtn . put ( "rtnCode" , this . getRtnCode ( 406 ) ) ; } long activeUserId = session . getActiveUserId ( ) ; User activeUser = User . findById ( activeUserId ) ; if ( targetUserId != activeUserId && ! activeUser . isAdmin ) { rtn . put ( "rtnCode" , this . getRtnCode ( 405 ) ) ; return rtn ; } if ( params . containsKey ( "username" ) && ! params . get ( "username" ) . equals ( targetUser . username ) ) { if ( User . findOne ( "username" , params . get ( "username" ) ) != null ) { rtn . put ( "rtnCode" , this . getRtnCode ( 201 ) ) ; return rtn ; } targetUser . username = params . get ( "username" ) ; } if ( params . containsKey ( "fullName" ) ) { targetUser . fullName = params . get ( "fullName" ) ; } if ( params . containsKey ( "email" ) ) { targetUser . email = params . get ( "email" ) ; } if ( params . containsKey ( "password" ) ) { targetUser . setPassword ( params . get ( "password" ) ) ; } targetUser . save ( ) ; rtn . put ( "rtnCode" , this . getRtnCode ( 200 ) ) ; rtn . put ( "user" , targetUser . toJson ( ) ) ; return rtn ; }
tr	9	private boolean r_mark_suffix_with_optional_n_consonant ( ) { int v_1 ; int v_2 ; int v_3 ; int v_4 ; int v_5 ; int v_6 ; int v_7 ; lab0 : do { v_1 = limit - cursor ; lab1 : do { v_2 = limit - cursor ; if ( ! ( eq_s_b ( 1 , "n" ) ) ) { break lab1 ; } cursor = limit - v_2 ; if ( cursor <= limit_backward ) { break lab1 ; } cursor -- ; v_3 = limit - cursor ; if ( ! ( in_grouping_b ( g_vowel , 97 , 305 ) ) ) { break lab1 ; } cursor = limit - v_3 ; break lab0 ; } while ( false ) ; cursor = limit - v_1 ; { v_4 = limit - cursor ; lab2 : do { v_5 = limit - cursor ; if ( ! ( eq_s_b ( 1 , "n" ) ) ) { break lab2 ; } cursor = limit - v_5 ; return false ; } while ( false ) ; cursor = limit - v_4 ; } v_6 = limit - cursor ; if ( cursor <= limit_backward ) { return false ; } cursor -- ; v_7 = limit - cursor ; if ( ! ( in_grouping_b ( g_vowel , 97 , 305 ) ) ) { return false ; } cursor = limit - v_7 ; cursor = limit - v_6 ; } while ( false ) ; return true ; }
tr	0	public String getFieldName ( ) { return _fieldName ; }
tr	0	public InvalidParameterException ( final String message , final Throwable exception ) { super ( message , exception ) ; }
tr	0	@ Override public void setPopulation ( TspPopulation p ) { population = p ; }
tr	0	public void setRespGrp ( RespGrp value ) { this . respGrp = value ; }
tr	4	public Questionnaire getQuestionnaireById ( long id ) { PreparedStatement statement = null ; ResultSet rs = null ; Connection connection = null ; Questionnaire questionnaire = null ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Retrieving questionnaire " + id + "..." ) ; } try { if ( logger . isDebugEnabled ( ) ) { logger . debug ( SELECT_QUESTIONNAIRE ) ; } connection = Connector . getConnection ( ) ; statement = connection . prepareStatement ( SELECT_QUESTIONNAIRE ) ; statement . setLong ( 1 , id ) ; rs = statement . executeQuery ( ) ; if ( rs . next ( ) ) { questionnaire = fillQuestionnaire ( rs ) ; } } catch ( SQLException e ) { logger . error ( e . getMessage ( ) , e ) ; } finally { ResourcesUtil . release ( rs , statement , connection ) ; } return questionnaire ; }
tr	8	public void executeSearch ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { response . setContentType ( "text/xml" ) ; Writer writer = response . getWriter ( ) ; String [ ] ownerIds = request . getParameterValues ( OWNERID ) ; if ( ownerIds == null || ownerIds . length != 1 ) { logger . debug ( "User didn't supply an ownerId" ) ; System . err . println ( ownerIds ) ; String error = "You must supply an ownerId" ; response . setStatus ( 400 ) ; writer . write ( CreateShortReturn . createShortResponse ( error , true ) ) ; return ; } String ownerId = ownerIds [ 0 ] ; String [ ] filterParamss = request . getParameterValues ( FILTERPARAMS ) ; if ( filterParamss == null || filterParamss . length != 1 ) { logger . debug ( "User didn't supply any filterParams" ) ; String error = "You must supply one set of filterParams" ; response . setStatus ( 400 ) ; writer . write ( CreateShortReturn . createShortResponse ( error , true ) ) ; return ; } String filterParams = filterParamss [ 0 ] ; FilterParams filterParamsObj = new FilterParams ( ) ; try { JAXBContext context = JAXBContext . newInstance ( FilterParams . class ) ; Unmarshaller um = context . createUnmarshaller ( ) ; filterParamsObj = ( FilterParams ) um . unmarshal ( new StringReader ( filterParams ) ) ; } catch ( JAXBException jbe ) { logger . warn ( "user supplied badly formed filterParams" ) ; String error = "Please make sure the filterParams is well formatted" ; response . setStatus ( 400 ) ; writer . write ( CreateShortReturn . createShortResponse ( error , true ) ) ; return ; } try { DetermineWorkToDo work = new DetermineWorkToDo ( null , ownerId , filterParamsObj ) ; Integer jobSize = work . FilterCompoundsInDatabase ( ) . size ( ) ; response . setStatus ( 200 ) ; writer . write ( CreateShortReturn . createShortResponse ( jobSize . toString ( ) , false ) ) ; } catch ( AmazonServiceException ase ) { logger . error ( ase ) ; String error = "Error in AWS please try again later." ; response . setStatus ( 500 ) ; writer . write ( CreateShortReturn . createShortResponse ( error , true ) ) ; return ; } catch ( AmazonClientException ace ) { logger . error ( ace ) ; String error = "Internal error please try again" ; response . setStatus ( 500 ) ; writer . write ( CreateShortReturn . createShortResponse ( error , true ) ) ; return ; } catch ( SQLException sqle ) { logger . error ( sqle ) ; String error = "Error connecting to SQL please try again later" ; response . setStatus ( 500 ) ; writer . write ( CreateShortReturn . createShortResponse ( error , true ) ) ; return ; } }
tr	3	void actionVerifyCert ( int num ) { X509Certificate c = certificates [ num ] ; X509Certificate cacert = certificates [ caCertsPane . getCACertNum ( ) ] ; if ( cacert == null ) { userCertsPane . clearVerified ( num ) ; apduLog . log ( "No loaded CA certificate selected." ) ; return ; } try { c . verify ( cacert . getPublicKey ( ) ) ; userCertsPane . setVerified ( num , true ) ; } catch ( SignatureException se ) { userCertsPane . setVerified ( num , false ) ; } catch ( Exception ex ) { userCertsPane . clearVerified ( num ) ; apduLog . log ( "Verification of signature failed." ) ; } }
tr	0	public int getSize ( ) { return size ; }
tr	5	public void edit ( Expending expending ) throws NonexistentEntityException { EntityManager em = null ; try { em = getEntityManager ( ) ; em . getTransaction ( ) . begin ( ) ; expending = em . merge ( expending ) ; em . getTransaction ( ) . commit ( ) ; } catch ( Exception ex ) { String msg = ex . getLocalizedMessage ( ) ; if ( msg == null || msg . length ( ) == 0 ) { Integer id = expending . getId ( ) ; if ( findExpending ( id ) == null ) { throw new NonexistentEntityException ( Constant . NON_EXISTS_ERROR_MSG ) ; } } throw ex ; } finally { if ( em != null ) { em . close ( ) ; } } }
tr	7	public boolean mouseUp ( Event event , int x , int y ) { if ( menus . mouseUp ( x , y ) ) { damage ( ) ; return true ; } Renderer . setDragging ( false ) ; if ( x < 35 && y < 35 ) { } if ( x > W - 35 && y < 35 ) { } if ( x > W - 35 && y > H - 35 ) { } return true ; }
tr	9	String formatOption ( OptionMetadata metadata , CommandLineConfiguration config ) { String formattedOption = null ; if ( metadata . isParameterAccepted ( ) ) { boolean isParamRequired = ( metadata . getParameterMetadata ( ) != null && metadata . getParameterMetadata ( ) . isRequired ( ) ) ; String paramDelim = StringUtil . formatDelimValue ( config . getCommandLineProperties ( ) . getOptionParameterDelim ( ) ) ; String paramUsageStr = "" ; if ( metadata . getParameterMetadata ( ) != null && metadata . getParameterMetadata ( ) . getParameterType ( ) != ParameterType . NONE ) { String paramName = "" ; if ( metadata . getParameterMetadata ( ) . getParameterType ( ) == ParameterType . CUSTOM ) { paramName = metadata . getParameterMetadata ( ) . getIdentifier ( ) ; } else { paramName = metadata . getParameterMetadata ( ) . getParameterType ( ) . name ( ) ; } paramUsageStr = String . format ( ( isParamRequired ) ? "%s<%s>" : "[%s<%s>]" , paramDelim , paramName ) ; if ( metadata . isMultiValued ( ) ) { paramUsageStr += "..." ; } } String longIdentifier = metadata . getIdentifier ( IdentifierType . long ) ; if ( longIdentifier != null && ! longIdentifier . isEmpty ( ) ) { formattedOption = String . format ( "%s%s  %s%s%s" , config . getCommandLineProperties ( ) . getOptionPrefix ( ) , metadata . getIdentifier ( ) , config . getCommandLineProperties ( ) . getOptionLongPrefix ( ) , metadata . getIdentifier ( IdentifierType . long ) , paramUsageStr ) ; } else { formattedOption = String . format ( "%s%s%s" , config . getCommandLineProperties ( ) . getOptionPrefix ( ) , metadata . getIdentifier ( ) , paramUsageStr ) ; } } else { String longIdentifier = metadata . getIdentifier ( IdentifierType . long ) ; if ( longIdentifier != null && ! longIdentifier . isEmpty ( ) ) { formattedOption = String . format ( "%s%s  %s%s" , config . getCommandLineProperties ( ) . getOptionPrefix ( ) , metadata . getIdentifier ( ) , config . getCommandLineProperties ( ) . getOptionLongPrefix ( ) , metadata . getIdentifier ( IdentifierType . long ) ) ; } else { formattedOption = String . format ( "%s%s" , config . getCommandLineProperties ( ) . getOptionPrefix ( ) , metadata . getIdentifier ( ) ) ; } } return formattedOption ; }
tr	5	private static String extractFollowingParaContaining ( String document , String containing , int begin ) { Matcher paragraph = Pattern . compile ( "<p[\\s\\S]*?</p>" ) . matcher ( document ) ; int start = begin ; int first = 0 ; int last = start ; while ( paragraph . find ( start ) ) { start = paragraph . end ( ) ; if ( paragraph . group ( ) . matches ( "<p[^>]*>[\\s\u00A0]*</p>" ) ) { continue ; } if ( ! paragraph . group ( ) . matches ( containing ) ) { break ; } if ( first == 0 ) { first = paragraph . start ( ) ; } last = paragraph . end ( ) ; } return first != 0 ? document . substring ( first , last ) : null ; }
tr	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( SpikeTester . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( SpikeTester . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( SpikeTester . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( SpikeTester . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { new SpikeTester ( ) . setVisible ( true ) ; } } ) ; }
tr	6	public boolean shiftUp ( ) { boolean empty = true ; for ( int j = 0 ; j < PIECE_SIZE ; ++ j ) { if ( currentShape [ 0 ] [ j ] ) empty = false ; } if ( empty ) { for ( int i = 1 ; i < PIECE_SIZE ; ++ i ) { for ( int j = 0 ; j < PIECE_SIZE ; ++ j ) { currentShape [ i - 1 ] [ j ] = currentShape [ i ] [ j ] ; } } for ( int j = 0 ; j < PIECE_SIZE ; ++ j ) { currentShape [ PIECE_SIZE - 1 ] [ j ] = false ; } } return empty ; }
tr	9	public static String rowToString ( JSONArray ja ) { StringBuffer sb = new StringBuffer ( ) ; for ( int i = 0 ; i < ja . length ( ) ; i += 1 ) { if ( i > 0 ) { sb . append (   ) ; } Object object = ja . opt ( i ) ; if ( object != null ) { String string = object . toString ( ) ; if ( string . length ( ) > 0 && ( string . indexOf (   ) >= 0 || string . indexOf ( '' ) >= 0 || string . indexOf ( '' ) >= 0 || string . indexOf ( 0 ) >= 0 || string . charAt ( 0 ) == " ) ) { sb . append ( " ) ; int length = string . length ( ) ; for ( int j = 0 ; j < length ; j += 1 ) { char c = string . charAt ( j ) ; if ( c >=   && c != " ) { sb . append ( c ) ; } } sb . append ( " ) ; } else { sb . append ( string ) ; } } } sb . append ( '' ) ; return sb . toString ( ) ; }
tr	5	public void compute_default ( ) { int i , prod , max_prod , max_red ; if ( reduction_count == null ) reduction_count = new int [ production . number ( ) ] ; for ( i = 0 ; i < production . number ( ) ; i ++ ) reduction_count [ i ] = 0 ; max_prod = - 1 ; max_red = 0 ; for ( i = 0 ; i < size ( ) ; i ++ ) if ( under_term [ i ] . kind ( ) == parse_action . REDUCE ) { prod = ( ( reduce_action ) under_term [ i ] ) . reduce_with ( ) . index ( ) ; reduction_count [ prod ] ++ ; if ( reduction_count [ prod ] > max_red ) { max_red = reduction_count [ prod ] ; max_prod = prod ; } } default_reduce = max_prod ; }
tr	5	final private void callEvalFile ( File file ) { try { BufferedReader br = null ; try { br = new BufferedReader ( new InputStreamReader ( new FileInputStream ( file ) , "UTF-8" ) ) ; StringBuilder sb = new StringBuilder ( ) ; String line ; while ( ( line = br . readLine ( ) ) != null ) { sb . append ( line ) . append ( "\n" ) ; } evals ( sb . toString ( ) ) ; } finally { if ( br != null ) { br . close ( ) ; } } } catch ( FunctionException ex ) { Logger . getLogger ( MyLisp . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( MyLispPerser . ParseException ex ) { Logger . getLogger ( MyLisp . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( IOException ex ) { Logger . getLogger ( MyLisp . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } }
tr	3	public void xf ( Matrix m , double x , double y , double z , double w , double v [ ] ) { if ( w == 0 ) for ( int j = 0 ; j < 3 ; j ++ ) v [ j ] = m . get ( j , 0 ) * x + m . get ( j , 1 ) * y + m . get ( j , 2 ) * z ; else for ( int j = 0 ; j < 3 ; j ++ ) v [ j ] = m . get ( j , 0 ) * x + m . get ( j , 1 ) * y + m . get ( j , 2 ) * z + m . get ( j , 3 ) ; double W = m . get ( 3 , 0 ) * x + m . get ( 3 , 1 ) * y + m . get ( 3 , 2 ) * z + m . get ( 3 , 3 ) ; v [ 0 ] /= W ; v [ 1 ] /= W ; v [ 2 ] /= W ; }
tr	5	public void enregisterLecteur ( String nom , String prenom , String adresse , String tel ) { if ( prenom . isEmpty ( ) || nom . isEmpty ( ) || adresse . isEmpty ( ) || tel . isEmpty ( ) ) { Message dialog = new Message ( "Veuillez rentrer tous les champs" ) ; } else if ( tel . length ( ) != 10 ) { Message dialog = new Message ( "Le num\u00E9ro doit comporter 10 chiffres" ) ; } else { Lecteur lect = new Lecteur ( lastLecteur , nom , prenom , adresse , tel ) ; _lecteurs . put ( lastLecteur , lect ) ; Message dialog = new Message ( "Lecteur enregistrer. Num\u00E9ro: " + lastLecteur ) ; fermerVue ( getVue ( ) ) ; lastLecteur ++ ; } }
tr	1	public boolean isEmpty ( ) { return ( id == null ) && ( name == null ) ; }
tr	8	public void testMONAChatToCharSet ( ) { char [ ] oneChar = new char [ 8 ] ; for ( int i = 0 ; i < 7 ; i ++ ) oneChar [ i ] = 0 ; oneChar [ 7 ] = 1 ; char [ ] result = visitor . MONACharToCharSet ( oneChar , 0 ) ; assertEquals ( result . length , 1 ) ; assertEquals ( result [ 0 ] , ( char ) 1 ) ; oneChar = new char [ 8 ] ; for ( int i = 0 ; i < 7 ; i ++ ) oneChar [ i ] = 0 ; oneChar [ 7 ] = x ; result = visitor . MONACharToCharSet ( oneChar , 0 ) ; assertEquals ( result . length , 2 ) ; assertEquals ( result [ 0 ] , 0 ) ; assertEquals ( result [ 1 ] , ( char ) 1 ) ; oneChar = new char [ 8 ] ; for ( int i = 1 ; i < 8 ; i ++ ) oneChar [ i ] = 0 ; oneChar [ 0 ] = x ; result = visitor . MONACharToCharSet ( oneChar , 0 ) ; assertEquals ( result . length , 2 ) ; assertEquals ( result [ 0 ] , ( char ) 0 ) ; assertEquals ( result [ 1 ] , ( char ) 128 ) ; oneChar = new char [ 8 ] ; for ( int i = 1 ; i < 4 ; i ++ ) oneChar [ i ] = 0 ; for ( int i = 5 ; i < 8 ; i ++ ) oneChar [ i ] = 0 ; oneChar [ 0 ] = x ; oneChar [ 4 ] = x ; result = visitor . MONACharToCharSet ( oneChar , 0 ) ; assertEquals ( result . length , 4 ) ; assertEquals ( result [ 0 ] , ( char ) 0 ) ; assertEquals ( result [ 1 ] , ( char ) 8 ) ; assertEquals ( result [ 2 ] , ( char ) 128 ) ; assertEquals ( result [ 3 ] , ( char ) 136 ) ; oneChar = new char [ 8 ] ; for ( int i = 1 ; i < 4 ; i ++ ) oneChar [ i ] = 0 ; for ( int i = 5 ; i < 8 ; i ++ ) oneChar [ i ] = 1 ; oneChar [ 0 ] = x ; oneChar [ 4 ] = x ; result = visitor . MONACharToCharSet ( oneChar , 0 ) ; assertEquals ( result . length , 4 ) ; assertEquals ( result [ 0 ] , ( char ) 7 ) ; assertEquals ( result [ 1 ] , ( char ) 15 ) ; assertEquals ( result [ 2 ] , ( char ) 135 ) ; assertEquals ( result [ 3 ] , ( char ) 143 ) ; oneChar = new char [ 8 ] ; for ( int i = 0 ; i < 8 ; i ++ ) oneChar [ i ] = x ; result = visitor . MONACharToCharSet ( oneChar , 0 ) ; assertEquals ( result . length , 256 ) ; assertEquals ( result [ 0 ] , ( char ) 0 ) ; assertEquals ( result [ 1 ] , ( char ) 1 ) ; assertEquals ( result [ 128 ] , ( char ) 128 ) ; assertEquals ( result [ 255 ] , ( char ) 255 ) ; assertEquals ( result [ 87 ] , W ) ; }
tr	8	private void updateClaim ( boolean choice1 ) { switch ( claim . getStatus ( ) ) { case UnRanked : claim . rank ( choice1 ? Claim . Rank . Complex : Claim . Rank . Simple ) ; JOptionPane . showMessageDialog ( form , "The claim has been ranked " + ( choice1 ? Claim . Rank . Complex : Claim . Rank . Simple ) ) ; break ; case Ranked : claim . setStatus ( choice1 ? Claim . Status . Confirmed : Claim . Status . Declined ) ; if ( choice1 ) { String billingInfo = AutomaticCustomerEmulator . sendForm ( ) ; storage . addPayment ( claim . getCustomerId ( ) , claim . getId ( ) , claim . getDamageCost ( ) , billingInfo ) ; } else AutomaticCustomerEmulator . sendMail ( "Your claim was denied" ) ; JOptionPane . showMessageDialog ( form , "The claim has been " + ( choice1 ? "confirmed" : "declined" ) ) ; break ; default : return ; } storage . updateClaim ( claim ) ; if ( listener != null ) { listener . actionPerformed ( new ActionEvent ( this , 0 , null ) ) ; } }
tr	7	public static boolean binSearch ( int [ ] sortedArr , int val ) { boolean found = false ; if ( sortedArr == null || sortedArr . length == 0 || val < sortedArr [ 0 ] || val > sortedArr [ sortedArr . length - 1 ] ) return found ; int lo = 0 ; int hi = sortedArr . length ; while ( lo <= hi ) { int mid = lo + ( hi - lo ) / 2 ; if ( val > sortedArr [ mid ] ) { lo = mid + 1 ; } else if ( val < sortedArr [ mid ] ) { hi = mid - 1 ; } else { found = true ; break ; } } return found ; }
tr	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( crearCuenta . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( crearCuenta . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( crearCuenta . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( crearCuenta . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { new crearCuenta ( ) . setVisible ( true ) ; } } ) ; }
tr	1	public void minusElixir ( String player , int amount ) { if ( elixir . containsKey ( player ) ) elixir . put ( player , elixir . get ( player ) - amount ) ; COBAPI . updateStats ( player ) ; }
tr	0	public double optDouble ( int index ) { return this . optDouble ( index , double . NaN ) ; }
tr	4	public static String getDescription ( int value ) { String description = "Large" ; switch ( value ) { case LARGE : description = "Large" ; break ; case MEDIUM : description = "Medium" ; break ; case SMALL : description = "Small" ; break ; case NONE : description = "None" ; break ; } return description ; }
tr	6	public void incCount ( E data ) { if ( overallRoot == null ) { overallRoot = new BSTNode ( data ) ; return ; } BSTNode currentNode = overallRoot ; while ( true ) { int cmp = comparator . compare ( data , currentNode . data ) ; if ( cmp == 0 ) { currentNode . count ++ ; return ; } else if ( cmp < 0 ) { if ( currentNode . left == null ) { currentNode . left = new BSTNode ( data ) ; return ; } currentNode = currentNode . left ; } else { if ( currentNode . right == null ) { currentNode . right = new BSTNode ( data ) ; return ; } currentNode = currentNode . right ; } } }
tr	9	@ Override public byte [ ] getByteData ( byte [ ] a , long startPos , long endPos , long step ) { if ( startPos < 0 || startPos >= length ) { throw new ArrayIndexOutOfBoundsException ( "startPos < 0 || startPos >= length" ) ; } if ( endPos < 0 || endPos > length || endPos < startPos ) { throw new ArrayIndexOutOfBoundsException ( "endPos < 0 || endPos > length || endPos < startPos" ) ; } if ( step < 1 ) { throw new IllegalArgumentException ( "step < 1" ) ; } long len = ( long ) Math . ceil ( ( endPos - startPos ) / ( double ) step ) ; if ( len > getMaxSizeOf32bitArray ( ) ) { return null ; } else { byte [ ] out ; if ( a != null && a . length >= len ) { out = a ; } else { out = new byte [ ( int ) len ] ; } int idx = 0 ; if ( ptr != 0 ) { for ( long i = startPos ; i < endPos ; i += step ) { out [ idx ++ ] = ( byte ) Utilities . UNSAFE . getLong ( ptr + sizeof * i ) ; } } else { if ( isConstant ( ) ) { for ( long i = startPos ; i < endPos ; i += step ) { out [ idx ++ ] = ( byte ) data [ 0 ] ; } } else { for ( long i = startPos ; i < endPos ; i += step ) { out [ idx ++ ] = ( byte ) data [ ( int ) i ] ; } } } return out ; } }
tr	2	@ Override public void onRobotUpdate ( RobotUpdateEvent e ) { if ( missile == null ) { missile = setFireMissile ( e . getPosition ( ) . - ( getPosition ( ) ) ) ; target = e . getName ( ) ; } else if ( e . getName ( ) . equals ( target ) ) { missile . setThrust ( e . getPosition ( ) . - ( missile . getPosition ( ) ) ) ; } }
tr	1	public static byte [ ] decompress ( byte [ ] data ) throws IOException , DataFormatException { Inflater inflater = new Inflater ( ) ; inflater . setInput ( data ) ; inflater . finished ( ) ; ByteArrayOutputStream outputStream = new ByteArrayOutputStream ( data . length ) ; byte [ ] buffer = new byte [ 1024 ] ; while ( ! inflater . finished ( ) ) { int count = inflater . inflate ( buffer ) ; outputStream . write ( buffer , 0 , count ) ; } outputStream . close ( ) ; byte [ ] output = outputStream . toByteArray ( ) ; inflater . end ( ) ; return output ; }
tr	1	public Sonido getNewSonido ( int nombreSonido ) { return nombreSonido < sonidos . size ( ) ? sonidos . get ( nombreSonido ) . clonar ( ) : null ; }
tr	6	public void run ( ) { isRunning = true ; int frames = 0 ; double frameCounter = 0 ; game . init ( ) ; double lastTime = Time . getTime ( ) ; double unprocessedTime = 0 ; while ( isRunning ) { boolean render = false ; double startTime = Time . getTime ( ) ; double passedTime = startTime - lastTime ; lastTime = startTime ; unprocessedTime += passedTime ; frameCounter += passedTime ; while ( unprocessedTime > frameTime ) { render = true ; unprocessedTime -= frameTime ; if ( Window . isCloseRequested ( ) ) stop ( ) ; game . input ( ( float ) frameTime ) ; Input . update ( ) ; game . update ( ( float ) frameTime ) ; if ( frameCounter >= 1 ) { frames = 0 ; frameCounter = 0 ; } } if ( render ) { game . render ( renderingEngine ) ; Window . render ( ) ; frames ++ ; } else { try { Thread . sleep ( 1 ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } } cleanup ( ) ; }
tr	0	@ Test public void testMaxPriorityQueueWithSmallSetOfInts ( ) { MaxPriorityQueue < Integer > pq = new MaxPriorityQueue < Integer > ( 20 ) ; pq . insert ( 9 ) ; pq . insert ( 11 ) ; pq . insert ( 2 ) ; pq . insert ( 9 ) ; pq . insert ( 19 ) ; pq . insert ( 2 ) ; assertThat ( pq . delAndGetMaximum ( ) , is ( equalTo ( 19 ) ) ) ; assertThat ( pq . delAndGetMaximum ( ) , is ( equalTo ( 11 ) ) ) ; assertThat ( pq . delAndGetMaximum ( ) , is ( equalTo ( 9 ) ) ) ; }
tr	6	public Object put ( Object key , Object value ) { Object retval = null ; if ( key != null ) { if ( key instanceof String ) { String name = ( String ) key ; for ( int i = 0 ; i < fields . size ( ) ; i ++ ) { final DataField field = fields . get ( i ) ; if ( ( field . name != null ) && field . name . equals ( name ) ) { if ( value != null ) { retval = field . getObjectValue ( ) ; field . type = DataField . getType ( value ) ; field . value = DataField . encode ( value ) ; } else { retval = fields . remove ( i ) ; } modified = true ; return retval ; } } return add ( name , value ) ; } else { throw new IllegalArgumentException ( "DataFrame keys must be of type String" ) ; } } else { add ( value ) ; } return retval ; }
tr	8	@ Override public FiveCardOmahaWorker build ( ) { if ( super . getRounds ( ) <= 0 ) { throw new IllegalStateException ( "The number of rounds must be a strictly positive number" ) ; } else if ( super . getProfiles ( ) == null || super . getProfiles ( ) . size ( ) < 2 ) { throw new IllegalStateException ( "There need to be at least 2 players in every simulation." ) ; } else if ( super . getUpdateInterval ( ) <= 0 || 100 % super . getUpdateInterval ( ) != 0 ) { throw new IllegalStateException ( "Invalid update interval value" ) ; } else if ( super . getNotifiable ( ) == null ) { throw new IllegalStateException ( "There needs to be a notifiable for this worker" ) ; } for ( PlayerProfile profile : super . getProfiles ( ) ) { if ( profile == null ) { throw new NullPointerException ( ) ; } } return new FiveCardOmahaWorker ( this ) ; }
tr	5	public Node findBody ( TagTable tt ) { Node node ; node = this . content ; while ( node != null && node . tag != tt . tagHtml ) node = node . next ; if ( node == null ) return null ; node = node . content ; while ( node != null && node . tag != tt . tagBody ) node = node . next ; return node ; }
tr	2	public int getKey ( Instrument instr ) { Set < Integer > k = bank . keySet ( ) ; for ( Integer i : k ) if ( bank . get ( i ) . equals ( instr ) ) return i ; return - 1 ; }
tr	3	@ Override public int resolve ( ) throws Exception { Room room = getMyRoom ( ) ; if ( getMyString ( ) . equals ( CommandConstants . COMMAND_NAME_PENDOWN ) ) { room . getTurtle ( ) . setPenStatus ( true ) ; return CommandConstants . COMMAND_RETURN_TRUE ; } else if ( getMyString ( ) . equals ( CommandConstants . COMMAND_NAME_PENUP ) ) { room . getTurtle ( ) . setPenStatus ( false ) ; return CommandConstants . COMMAND_RETURN_FALSE ; } else { if ( room . getTurtle ( ) . getPenStatus ( ) ) { return CommandConstants . COMMAND_RETURN_TRUE ; } else { return CommandConstants . COMMAND_RETURN_FALSE ; } } }
tr	4	public void hurt ( double amount , Entity entity ) { if ( entity instanceof Player ) { Player player = ( Player ) entity ; player . lives -= amount ; if ( player . lives <= 0 ) { player . die ( ) ; } } else if ( entity instanceof Mob ) { Mob mob = ( Mob ) entity ; mob . lives -= amount ; if ( mob . lives - amount <= 0 ) die ( mob ) ; } }
tr	1	protected void addToStoredClassDescriptors ( ActionScriptClassDescriptor desc ) { if ( debug ) debug ( "addToStoredClassDescriptors(desc=" , desc , ") at index=" , String . valueOf ( storedClassDescriptors . size ( ) ) ) ; storedClassDescriptors . add ( desc ) ; }
tr	1	public Labels getLabels ( ) { if ( labels == null ) { labels = new Labels ( ) ; } return labels ; }
tr	2	void destroyMe ( boolean really ) { destroyMe ( ) ; if ( ! really ) return ; for ( int i = 0 ; i < clouds . size ( ) ; i ++ ) { Cloud cloud = clouds . elementAt ( i ) ; cloud . age = cloud . t_nose + cloud . t_mature + cloud . t_tail ; } }
