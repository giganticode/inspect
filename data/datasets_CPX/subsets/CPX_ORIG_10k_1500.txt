tr	4	public boolean saveFile ( byte [ ] data , String fileLocation ) { FileOutputStream f = null ; try { f = new FileOutputStream ( fileLocation ) ; f . write ( data ) ; f . close ( ) ; return true ; } catch ( FileNotFoundException e ) { System . err . println ( "File not found: " + e ) ; e . printStackTrace ( ) ; } catch ( IOException e ) { System . err . println ( "IO: " + e ) ; e . printStackTrace ( ) ; } finally { if ( f != null ) { try { f . close ( ) ; } catch ( IOException e ) { System . err . println ( "IO: " + e ) ; e . printStackTrace ( ) ; } } } return false ; }
tr	1	private String getEncodedSecret ( OAuthToken consumer , OAuthToken token ) { StringBuilder secret = new StringBuilder ( ) ; secret . append ( IOUtil . urlEncode ( new String ( consumer . getSecret ( ) ) ) ) ; secret . append ( "&" ) ; if ( token != null ) secret . append ( IOUtil . urlEncode ( new String ( token . getSecret ( ) ) ) ) ; return secret . toString ( ) ; }
tr	1	public Integer getIntData ( Document doc , String tagName ) { String data = getTextData ( doc , tagName ) ; if ( data == null ) { return null ; } else { return Integer . parseInt ( data ) ; } }
tr	0	public void setMaxDesolvApolar ( float value ) { this . maxDesolvApolar = value ; }
tr	5	public double readDouble ( String prompt , double low , double high ) { String msg = null ; while ( true ) { String line = readLine ( prompt ) ; try { double d = double . valueOf ( line ) . doubleValue ( ) ; if ( d >= low && d <= high ) return d ; msg = "Value is outside the range [" + low + ":" + high + "]" ; } catch ( NumberFormatException ex ) { msg = "Illegal numeric format" ; } showErrorMessage ( msg ) ; if ( prompt == null ) prompt = "Retry: " ; } }
tr	0	private void show ( String prefix , String text ) { System . out . println ( prefix + text ) ; }
tr	0	public FIXMLBuilder ( Account a ) { id = a . getId ( ) ; }
tr	5	public void transform ( String originalFile , String thumbnailFile , int thumbWidth , int thumbHeight , int quality ) throws Exception { Image image = javax . imageio . ImageIO . read ( new File ( originalFile ) ) ; double thumbRatio = ( double ) thumbWidth / ( double ) thumbHeight ; int imageWidth = image . getWidth ( null ) ; int imageHeight = image . getHeight ( null ) ; double imageRatio = ( double ) imageWidth / ( double ) imageHeight ; if ( thumbRatio < imageRatio ) { thumbHeight = ( int ) ( thumbWidth / imageRatio ) ; } else { thumbWidth = ( int ) ( thumbHeight * imageRatio ) ; } if ( imageWidth < thumbWidth && imageHeight < thumbHeight ) { thumbWidth = imageWidth ; thumbHeight = imageHeight ; } else if ( imageWidth < thumbWidth ) thumbWidth = imageWidth ; else if ( imageHeight < thumbHeight ) thumbHeight = imageHeight ; BufferedImage thumbImage = new BufferedImage ( thumbWidth , thumbHeight , BufferedImage . TYPE_INT_RGB ) ; Graphics2D graphics2D = thumbImage . createGraphics ( ) ; graphics2D . setBackground ( Color . WHITE ) ; graphics2D . setPaint ( Color . WHITE ) ; graphics2D . fillRect ( 0 , 0 , thumbWidth , thumbHeight ) ; graphics2D . setRenderingHint ( RenderingHints . KEY_INTERPOLATION , RenderingHints . VALUE_INTERPOLATION_BILINEAR ) ; graphics2D . drawImage ( image , 0 , 0 , thumbWidth , thumbHeight , null ) ; javax . imageio . ImageIO . write ( thumbImage , "JPG" , new File ( thumbnailFile ) ) ; }
tr	2	@ Override public BSTNode < T > search ( T element ) { BSTNode < T > node = search ( element , root ) ; if ( ! node . isEmpty ( ) ) { splay ( node ) ; } else { if ( ! node . equals ( root ) ) { splay ( ( BSTNode < T > ) node . getParent ( ) ) ; } } return node ; }
tr	9	private Location createLocation ( IPLocation ipLoc ) { Location location = new Location ( ) ; String city = ipLoc . getArea ( ) ; String country = ipLoc . getCountry ( ) ; if ( ( city == null ) || ( city . indexOf ( "CZ88.NET" ) > - 1 ) ) { city = "" ; } location . setCountry ( country ) ; location . setProvince ( city ) ; location . setCity ( city ) ; location . setAddress ( country + city ) ; if ( ! MyStringUtil . isBlank ( location . getAddress ( ) ) ) { int provinclen = Provinces . length ; for ( int l = 0 ; l < provinclen ; l ++ ) { String province = Provinces [ l ] ; if ( location . getAddress ( ) . indexOf ( province ) != - 1 ) { location . setCountry ( "\u4E2D\u56FD" ) ; location . setProvince ( province ) ; System . out . println ( province ) ; String [ ] citys = ProvinceCityMap . get ( province ) ; if ( citys != null ) { int citylen = citys . length ; for ( int k = 0 ; k < citylen ; k ++ ) { city = citys [ k ] ; if ( location . getAddress ( ) . indexOf ( city ) != - 1 ) { location . setCity ( city ) ; break ; } } } else { location . setProvince ( "\u5176\u4ED6" ) ; location . setCity ( "\u5176\u4ED6" ) ; } break ; } } int isplen = ISPs . length ; for ( int l = 0 ; l < isplen ; l ++ ) { String isp = ISPs [ l ] ; if ( location . getAddress ( ) . indexOf ( isp ) != - 1 ) { location . setISP ( isp ) ; break ; } } } if ( MyStringUtil . isBlank ( location . getCountry ( ) ) ) { location . setCountry ( "\u5176\u4ED6" ) ; } if ( MyStringUtil . isBlank ( location . getProvince ( ) ) ) { location . setProvince ( "\u5176\u4ED6" ) ; } if ( MyStringUtil . isBlank ( location . getCity ( ) ) ) { location . setCity ( "\u5176\u4ED6" ) ; } return location ; }
tr	4	private void init ( ) { int n = mapInfo . getMapSize ( ) ; visited = new boolean [ n ] [ n ] ; for ( int column = 0 ; column < n ; column ++ ) visited [ 0 ] [ column ] = visited [ n - 1 ] [ column ] = true ; for ( int row = 0 ; row < n ; row ++ ) visited [ row ] [ 0 ] = visited [ row ] [ n - 1 ] = true ; for ( int column = 0 ; column < n ; column ++ ) for ( int row = 0 ; row < n ; row ++ ) mapInfo . setCell ( row , column , new Cell ( true , true , true , true ) ) ; }
tr	1	@ Override public void mouseExited ( MouseEvent e ) { try { setImg ( ImageIO . read ( new File ( "img/button/button.png" ) ) ) ; } catch ( IOException ex ) { ex . printStackTrace ( ) ; } }
tr	3	public void updateScoreWithEmptyProbList ( long submissionId , long questId ) { PreparedStatement statement = null ; Connection connection = null ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Updating the score of an user in a questionnaire: " + questId ) ; } try { if ( logger . isDebugEnabled ( ) ) { logger . debug ( UPDATE_QUEST_SCORE_WITH_EMPTY_PROBLEM_LIST ) ; } connection = Connector . getConnection ( ) ; statement = connection . prepareStatement ( UPDATE_QUEST_SCORE_WITH_EMPTY_PROBLEM_LIST ) ; statement . setLong ( 1 , submissionId ) ; statement . setLong ( 2 , questId ) ; DeadLockHandler . executeUpdate ( statement ) ; } catch ( SQLException e ) { logger . error ( e . getMessage ( ) , e ) ; } finally { ResourcesUtil . release ( null , statement , connection ) ; } }
tr	7	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( TestTimer . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( TestTimer . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( TestTimer . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( TestTimer . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { try { new TestTimer ( ) . setVisible ( true ) ; } catch ( InterruptedException ex ) { Logger . getLogger ( TestTimer . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } } } ) ; }
tr	0	private void setElements ( ) { exitJB = new JButton ( "Exit" ) ; showBusesJB = new JButton ( "Show Buses" ) ; showGraphicSystemJB = new JButton ( "Show Graphic System" ) ; add ( showBusesJB ) ; add ( showGraphicSystemJB ) ; add ( exitJB ) ; }
tr	9	@ Override public int hashCode ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + ( compression ? 1231 : 1237 ) ; result = prime * result + Arrays . hashCode ( data ) ; result = prime * result + dataLength ; result = prime * result + ( dataLengthIndicator ? 1231 : 1237 ) ; result = prime * result + ( encryption ? 1231 : 1237 ) ; result = prime * result + ( group ? 1231 : 1237 ) ; result = prime * result + ( ( id == null ) ? 0 : id . hashCode ( ) ) ; result = prime * result + ( preserveFile ? 1231 : 1237 ) ; result = prime * result + ( preserveTag ? 1231 : 1237 ) ; result = prime * result + ( readOnly ? 1231 : 1237 ) ; result = prime * result + ( unsynchronisation ? 1231 : 1237 ) ; return result ; }
tr	8	public void testPieceSetup ( ) { OthelloPiece [ ] [ ] test = OthelloBoard . getPieces ( ) ; for ( int k = 0 ; k < getP1PiecesX ( ) . size ( ) ; k ++ ) { if ( getM_playerOneColour ( ) . equals ( "Black" ) ) { if ( test [ getP1PiecesX ( ) . get ( k ) ] [ getP1PiecesY ( ) . get ( k ) ] . getPieceColour ( ) . equals ( Piece . OthelloPieceColour . BLACK ) ) { System . out . println ( "Right" ) ; System . out . println ( getP1PiecesX ( ) . get ( k ) + " " + getP1PiecesY ( ) . get ( k ) ) ; } } else { if ( test [ getP1PiecesX ( ) . get ( k ) ] [ getP1PiecesY ( ) . get ( k ) ] . getPieceColour ( ) . equals ( Piece . OthelloPieceColour . WHITE ) ) { System . out . println ( "Right" ) ; System . out . println ( getP1PiecesX ( ) . get ( k ) + " " + getP1PiecesY ( ) . get ( k ) ) ; } } } System . out . println ( "PieceCount: " + getP1PiecesX ( ) . size ( ) ) ; for ( int k2 = 0 ; k2 < getP2PiecesX ( ) . size ( ) ; k2 ++ ) { if ( getM_playerTwoColour ( ) . equals ( "Black" ) ) { if ( test [ getP2PiecesX ( ) . get ( k2 ) ] [ getP2PiecesY ( ) . get ( k2 ) ] . getPieceColour ( ) . equals ( Piece . OthelloPieceColour . BLACK ) ) { System . out . println ( "Right" ) ; System . out . println ( getP2PiecesX ( ) . get ( k2 ) + " " + getP2PiecesY ( ) . get ( k2 ) ) ; } } else { if ( test [ getP2PiecesX ( ) . get ( k2 ) ] [ getP2PiecesY ( ) . get ( k2 ) ] . getPieceColour ( ) . equals ( Piece . OthelloPieceColour . WHITE ) ) { System . out . println ( "Right" ) ; System . out . println ( getP2PiecesX ( ) . get ( k2 ) + " " + getP2PiecesY ( ) . get ( k2 ) ) ; } } } System . out . println ( "PieceCount2: " + getP2PiecesX ( ) . size ( ) ) ; }
tr	1	public static void main ( String [ ] args ) { System . out . println ( "Testing binary Max Heap\n" ) ; MaxHeap heap = new MaxHeap ( ) ; int [ ] inputs = { 10 , 20 , 30 , 40 , 100 , 50 , 60 , 70 , 80 , 90 , 190 } ; for ( int i = 0 ; i < inputs . length ; i ++ ) heap . insert ( inputs [ i ] ) ; heap . print ( ) ; System . out . println ( "Heap size is now " + ( heap . size ) + "\n" ) ; System . out . println ( "Extract max returns " + heap . extractMax ( ) ) ; heap . print ( ) ; System . out . println ( "Heap size is now " + ( heap . size ) + "\n" ) ; System . out . println ( "Inserting 3" ) ; heap . insert ( 3 ) ; heap . print ( ) ; System . out . println ( "Heap size is now " + ( heap . size ) + "\n" ) ; System . out . println ( "Extract max returns " + heap . extractMax ( ) ) ; heap . print ( ) ; }
tr	6	public String nextTo ( String delimiters ) throws JSONException { char c ; StringBuilder sb = new StringBuilder ( ) ; for ( ; ; ) { c = this . next ( ) ; if ( delimiters . indexOf ( c ) >= 0 || c == 0 || c == '' || c == '' ) { if ( c != 0 ) { this . back ( ) ; } return sb . toString ( ) . trim ( ) ; } sb . append ( c ) ; } }
tr	5	private String getSigningString ( String customer_id ) { String stringToSign = post ? "POST\n" : "GET\n" ; String content_type = post ? "application/x-www-form-urlencoded\n" : "\n" ; stringToSign += content_type ; if ( ts_date ) { stringToSign += "\n" ; } else { Date now = new Date ( ) ; SimpleDateFormat rfc2616 = new SimpleDateFormat ( "EEE  dd MMM yyyy HH:mm:ss ZZZZ" , Locale . US ) ; String date = rfc2616 . format ( now ) ; addHeader ( "Date" , date ) ; stringToSign += date + "\n" ; } Set < String > orderedKeys = ts_headers . keySet ( ) ; for ( String key : orderedKeys ) { stringToSign += key . toLowerCase ( ) + ":" + ts_headers . get ( key ) + "\n" ; } if ( post ) { stringToSign += body + "\n" ; } stringToSign += resource ; return stringToSign ; }
tr	5	public void disconnected ( int id ) { String name = null ; for ( int i = 0 ; i < clients . size ( ) ; i ++ ) { if ( clients . get ( i ) . getID ( ) == id ) { name = clients . get ( i ) . getName ( ) + " (" + id + ")" ; clients . remove ( i ) ; break ; } } if ( name == null ) { System . out . println ( "Client was not removed" ) ; return ; } for ( int i = 0 ; i < clientListModel . getSize ( ) ; i ++ ) { if ( clientListModel . elementAt ( i ) . equals ( name ) ) { clientListModel . remove ( i ) ; break ; } } }
tr	2	public void keyReleased ( KeyEvent e ) { switch ( e . getKeyCode ( ) ) { case KeyEvent . VK_SHIFT : if ( this . editMode == EditMode . MODE_TILE_SELECTION ) { this . editMode = EditMode . MODE_TILE_EDIT ; } break ; default : break ; } }
tr	5	@ Test public void testPacketSending ( ) throws SocketException { MicroSecondsTimeStamp stamper = mock ( MicroSecondsTimeStamp . class ) ; when ( stamper . timeStamp ( ) ) . thenReturn ( 0 ) ; UtpAlgorithm algorithm = new UtpAlgorithm ( stamper , new InetSocketAddress ( 51235 ) ) ; UtpAlgConfiguration . SEND_IN_BURST = true ; UtpAlgConfiguration . MAX_BURST_SEND = 3 ; int packetLength = 1000 ; algorithm . setMaxWindow ( packetLength * 10 ) ; UtpTimestampedPacketDTO pkt5 = createPacket ( 5 , packetLength ) ; UtpTimestampedPacketDTO pkt6 = createPacket ( 6 , packetLength ) ; UtpTimestampedPacketDTO pkt7 = createPacket ( 7 , packetLength ) ; UtpTimestampedPacketDTO pkt8 = createPacket ( 8 , packetLength ) ; UtpTimestampedPacketDTO pkt9 = createPacket ( 9 , packetLength ) ; algorithm . markPacketOnfly ( pkt5 . utpPacket ( ) , pkt5 . dataGram ( ) ) ; algorithm . markPacketOnfly ( pkt6 . utpPacket ( ) , pkt6 . dataGram ( ) ) ; algorithm . markPacketOnfly ( pkt7 . utpPacket ( ) , pkt7 . dataGram ( ) ) ; algorithm . markPacketOnfly ( pkt8 . utpPacket ( ) , pkt8 . dataGram ( ) ) ; algorithm . markPacketOnfly ( pkt9 . utpPacket ( ) , pkt9 . dataGram ( ) ) ; assertEquals ( 5 * ( UtpPacketUtils . DEF_HEADER_LENGTH + packetLength ) , algorithm . getCurrentWindow ( ) ) ; for ( int i = 0 ; i < UtpAlgConfiguration . MAX_BURST_SEND ; i ++ ) { assertEquals ( true , algorithm . canSendNextPacket ( ) ) ; } assertEquals ( false , algorithm . canSendNextPacket ( ) ) ; for ( int i = 0 ; i < UtpAlgConfiguration . MAX_BURST_SEND ; i ++ ) { assertEquals ( true , algorithm . canSendNextPacket ( ) ) ; } assertEquals ( false , algorithm . canSendNextPacket ( ) ) ; algorithm . setMaxWindow ( packetLength * 4 ) ; for ( int i = 0 ; i < UtpAlgConfiguration . MAX_BURST_SEND ; i ++ ) { assertEquals ( false , algorithm . canSendNextPacket ( ) ) ; } for ( int i = 0 ; i < UtpAlgConfiguration . MAX_BURST_SEND ; i ++ ) { assertEquals ( false , algorithm . canSendNextPacket ( ) ) ; } algorithm . setMaxWindow ( 10 * packetLength ) ; for ( int i = 0 ; i < UtpAlgConfiguration . MAX_BURST_SEND ; i ++ ) { assertEquals ( true , algorithm . canSendNextPacket ( ) ) ; } assertEquals ( false , algorithm . canSendNextPacket ( ) ) ; }
tr	4	@ Override public int hashCode ( ) { int result = nameFirst != null ? nameFirst . hashCode ( ) : 0 ; result = 31 * result + ( nameMiddle != null ? nameMiddle . hashCode ( ) : 0 ) ; result = 31 * result + ( nameLast != null ? nameLast . hashCode ( ) : 0 ) ; result = 31 * result + ( job != null ? job . hashCode ( ) : 0 ) ; return result ; }
tr	8	public static Object decodeToObject ( String encodedObject , int options , final ClassLoader loader ) throws java . io . IOException , java . lang . ClassNotFoundException { byte [ ] objBytes = decode ( encodedObject , options ) ; java . io . ByteArrayInputStream bais = null ; java . io . ObjectInputStream ois = null ; Object obj = null ; try { bais = new java . io . ByteArrayInputStream ( objBytes ) ; if ( loader == null ) { ois = new java . io . ObjectInputStream ( bais ) ; } else { ois = new java . io . ObjectInputStream ( bais ) { @ Override public class < ? > resolveClass ( java . io . ObjectStreamClass streamClass ) throws java . io . IOException , ClassNotFoundException { class < ? > c = class . forName ( streamClass . getName ( ) , false , loader ) ; if ( c == null ) { return super . resolveClass ( streamClass ) ; } else { return c ; } } } ; } obj = ois . readObject ( ) ; } catch ( java . io . IOException e ) { throw e ; } catch ( java . lang . ClassNotFoundException e ) { throw e ; } finally { try { bais . close ( ) ; } catch ( Exception e ) { } try { ois . close ( ) ; } catch ( Exception e ) { } } return obj ; }
tr	8	public boolean showEventMessage ( final List < CalendarEventData > calendarEventList ) { if ( SwingUtilities . isEventDispatchThread ( ) ) { StringBuilder message = new StringBuilder ( ) ; boolean warning = false ; for ( CalendarEventData calendarEvent : calendarEventList ) { message . append ( calendarEvent . getTitle ( ) ) ; if ( calendarEvent . getLocation ( ) . length ( ) != 0 ) { message . append ( "@" ) ; message . append ( calendarEvent . getLocation ( ) ) ; } message . append ( "\u304C\n" ) ; message . append ( TIME_FORMAT . format ( calendarEvent . getStartDate ( ) ) ) ; message . append ( "\u306B\u958B\u59CB\u3067\u3059\u3002" ) ; if ( calendarEvent . isWarning ( ) ) { message . append ( "\n" ) ; message . append ( "\u3059\u3067\u306B\u958B\u59CB\u6642\u523B\u3092\u904E\u304E\u3066\u3044\u307E\u3059\uFF01" ) ; warning = true ; } } if ( warning ) { trayIcon . displayMessage ( null , message . toString ( ) , TrayIcon . MessageType . WARNING ) ; System . out . println ( "\u30A2\u30A4\u30B3\u30F3\u30E1\u30C3\u30BB\u30FC\u30B8\u8868\u793A" ) ; } else { trayIcon . displayMessage ( null , message . toString ( ) , TrayIcon . MessageType . INFO ) ; System . out . println ( "\u30A2\u30A4\u30B3\u30F3\u30E1\u30C3\u30BB\u30FC\u30B8\u8868\u793A" ) ; } boolean ret = super . showEventMessage ( calendarEventList ) ; return ret ; } else { final List < boolean > result = new ArrayList < boolean > ( ) ; try { SwingUtilities . invokeAndWait ( new Runnable ( ) { @ Override public void run ( ) { result . add ( showEventMessage ( calendarEventList ) ) ; } } ) ; } catch ( InterruptedException e ) { } catch ( InvocationTargetException e ) { } if ( result . size ( ) != 0 ) { return result . get ( 0 ) ; } return true ; } }
tr	5	public static String getPlainTextFromWikiXml ( String wikiXml ) { Matcher m = revPtn . matcher ( wikiXml ) ; String result = "" ; if ( m . find ( ) ) { result = m . group ( 1 ) ; StringBuffer buf = new StringBuffer ( ) ; int stackCnt = 0 ; for ( int i = 0 ; i < result . length ( ) ; i ++ ) { char c = result . charAt ( i ) ; if ( c == { ) stackCnt ++ ; else if ( c == } ) stackCnt -- ; else if ( stackCnt <= 0 ) buf . append ( c ) ; } result = buf . toString ( ) ; result = result . replaceAll ( "&lt;ref&gt;.*&lt;/ref&gt;" , "" ) ; } return result ; }
tr	3	public String currentImage ( ) throws TokenizerException { Token token = currentToken ( ) ; if ( token . getType ( ) == Token . EOF ) { return null ; } else if ( ! isFlagSet ( Flags . F_TOKEN_POS_ONLY ) || token . getImage ( ) != null ) { return token . getImage ( ) ; } else { return getText ( token . getStartPosition ( ) , token . getLength ( ) ) ; } }
tr	7	@ Deprecated public < T > T toObject ( String input ) { final XmlPullParser xpp ; try { xpp = xmlPullParserFactory . newPullParser ( ) ; } catch ( XmlPullParserException e ) { throw new RuntimeException ( e . toString ( ) , e ) ; } final State state = stateFactory . get ( exceptionHandler ) ; try { xpp . setInput ( new StringReader ( input ) ) ; int eventType = xpp . getEventType ( ) ; do { if ( eventType == XmlPullParser . START_DOCUMENT ) { state . begin ( ) ; } else if ( eventType == XmlPullParser . START_TAG ) { state . processStartElement ( xpp , this ) ; } else if ( eventType == XmlPullParser . END_TAG ) { state . processEndElement ( ) ; } else if ( eventType == XmlPullParser . TEXT ) { state . processText ( xpp , this ) ; } eventType = xpp . next ( ) ; } while ( eventType != XmlPullParser . END_DOCUMENT ) ; state . end ( ) ; } catch ( Exception e ) { exceptionHandler . handle ( e ) ; } return ( T ) state . getObject ( ) ; }
tr	6	private synchronized void setNewSoundSource ( SoundSource newSource ) { switch ( state ) { case PLAYING : resetFadeOut ( ) ; state = State . CHANGING ; case STOPPING : case CHANGING : nextSound = newSource ; break ; case EMPTY : case STOPPED : state = newSource == null ? State . EMPTY : State . STOPPED ; currentSound = newSource ; break ; default : break ; } }
tr	5	private void init ( PipedWriter inputStart ) throws IOException { logger . info ( "init pipe" ) ; if ( ! stages . isEmpty ( ) ) { stages . removeAll ( stages ) ; } stages . add ( new Filter ( new PipedReader ( inputStart ) , new PipedWriter ( ) ) ) ; stages . add ( new CaseFolding ( new PipedReader ( stages . get ( stages . size ( ) - 1 ) . getOut ( ) ) , new PipedWriter ( ) ) ) ; if ( ApplicationSetup . getInstance ( ) . getUseStopwords ( ) ) { stages . add ( new StopWordRemoval ( new PipedReader ( stages . get ( stages . size ( ) - 1 ) . getOut ( ) ) , new PipedWriter ( ) ) ) ; } if ( ApplicationSetup . getInstance ( ) . getUseStemmer ( ) ) { stages . add ( new Stemming ( new PipedReader ( stages . get ( stages . size ( ) - 1 ) . getOut ( ) ) , new PipedWriter ( ) ) ) ; } pool = Executors . newFixedThreadPool ( stages . size ( ) + 1 ) ; AbstractPipeStage stage ; for ( int i = 0 ; i < stages . size ( ) ; i ++ ) { stage = stages . get ( i ) ; if ( i == 0 ) { stage . setWaitingFor ( stages . get ( stages . size ( ) - 1 ) ) ; } else { stage . setWaitingFor ( stages . get ( i - 1 ) ) ; } pool . execute ( stage ) ; } }
tr	0	public Object getNextPanelDescriptor ( ) { return LHC_Analysis_Panel4_Descriptor . IDENTIFIER ; }
tr	2	public String consumeResponse ( HttpResponse response ) { printStatus ( getResponseStatus ( ) ) ; printHeaders ( getResponseHeaders ( ) ) ; printCookies ( getCookies ( ) ) ; printSeparatorLine ( ) ; String content = null ; try { content = consumeResponseContent ( response ) ; } catch ( IllegalStateException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } printSeparatorLine ( ) ; return content ; }
tr	5	private long checkClientTimeouts ( int timeout ) { Set < Integer > disconnectedClientIds = new HashSet < Integer > ( ) ; long oldestClientCommunicationTime = - 1 ; synchronized ( CONNECTION_LOCK ) { if ( ! isRunning ) return - 1 ; long now = System . currentTimeMillis ( ) ; oldestClientCommunicationTime = now ; for ( Iterator < Integer > iter = clients . keySet ( ) . iterator ( ) ; iter . hasNext ( ) ; ) { int clientId = iter . next ( ) ; ClientInfo client = clients . get ( clientId ) ; if ( client . getTimeOfLastCommunication ( ) + timeout <= now ) { iter . remove ( ) ; disconnectedClientIds . add ( clientId ) ; } else if ( client . getTimeOfLastCommunication ( ) < oldestClientCommunicationTime ) oldestClientCommunicationTime = client . getTimeOfLastCommunication ( ) ; } } for ( int clientId : disconnectedClientIds ) { logger . fine ( "Client " + clientId + " timed out" ) ; onClientDisconnected ( clientId , Server . CLIENT_TIMED_OUT ) ; } return oldestClientCommunicationTime ; }
tr	4	public void fill ( final Color [ ] [ ] frameBuffer ) { if ( frameBuffer == null ) { throw new NullPointerException ( "'frameBuffer' must not be 'null'" ) ; } Color c = ( getAttributes ( ) . containsKey ( "color" ) ) ? ( Color ) getAttributes ( ) . get ( "color" ) : Color . white ; for ( int i = getP ( ) . get ( 0 , 0 ) . intValue ( ) ; i < getP ( ) . get ( 0 , 0 ) . intValue ( ) + getD ( ) . get ( 0 , 0 ) . intValue ( ) ; ++ i ) { for ( int j = getP ( ) . get ( 1 , 0 ) . intValue ( ) ; j < getP ( ) . get ( 1 , 0 ) + getD ( ) . get ( 1 , 0 ) ; ++ j ) { frameBuffer [ i ] [ j ] = c ; } } }
tr	9	void checkConsistency ( ) { HalfEdge hedge = he0 ; double maxd = 0 ; int numv = 0 ; if ( numVerts < 3 ) { throw new InternalErrorException ( "degenerate face: " + getVertexString ( ) ) ; } do { HalfEdge hedgeOpp = hedge . getOpposite ( ) ; if ( hedgeOpp == null ) { throw new InternalErrorException ( "face " + getVertexString ( ) + ": " + "unreflected half edge " + hedge . getVertexString ( ) ) ; } else if ( hedgeOpp . getOpposite ( ) != hedge ) { throw new InternalErrorException ( "face " + getVertexString ( ) + ": " + "opposite half edge " + hedgeOpp . getVertexString ( ) + " has opposite " + hedgeOpp . getOpposite ( ) . getVertexString ( ) ) ; } if ( hedgeOpp . head ( ) != hedge . tail ( ) || hedge . head ( ) != hedgeOpp . tail ( ) ) { throw new InternalErrorException ( "face " + getVertexString ( ) + ": " + "half edge " + hedge . getVertexString ( ) + " reflected by " + hedgeOpp . getVertexString ( ) ) ; } Face oppFace = hedgeOpp . face ; if ( oppFace == null ) { throw new InternalErrorException ( "face " + getVertexString ( ) + ": " + "no face on half edge " + hedgeOpp . getVertexString ( ) ) ; } else if ( oppFace . mark == DELETED ) { throw new InternalErrorException ( "face " + getVertexString ( ) + ": " + "opposite face " + oppFace . getVertexString ( ) + " not on hull" ) ; } double d = Math . abs ( distanceToPlane ( hedge . head ( ) . pnt ) ) ; if ( d > maxd ) { maxd = d ; } numv ++ ; hedge = hedge . next ; } while ( hedge != he0 ) ; if ( numv != numVerts ) { throw new InternalErrorException ( "face " + getVertexString ( ) + " numVerts=" + numVerts + " should be " + numv ) ; } }
tr	1	public int getComponetType ( boolean disregardScrollPane ) { if ( compType == TYPE_UNSET ) compType = checkType ( disregardScrollPane ) ; return compType ; }
tr	2	@ Override public boolean disconnect ( String a , String b ) { Vertex < E > vertex1 = new Vertex < E > ( null , a ) ; int index1 ; index1 = _vertexs . search ( vertex1 ) ; if ( _vertexs . getLenght ( ) > 0 && index1 >= 0 ) { Vertex < E > vertex = _vertexs . get ( index1 ) ; return vertex . disconnectX ( b ) ; } return false ; }
tr	7	@ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; ProcDescriptor other = ( ProcDescriptor ) obj ; if ( labelInAssembler != other . labelInAssembler ) return false ; if ( lokal == null ) { if ( other . lokal != null ) return false ; } else if ( ! lokal . equals ( other . lokal ) ) return false ; return true ; }
tr	4	@ Override public Animal breed ( Animal a ) { if ( a instanceof Chicken ) { Chicken mate = ( Chicken ) a ; if ( isMale ( ) == ! mate . isMale ( ) ) { String [ ] child = new String [ geneCount ] ; do { char [ ] a1 = getRandomAlleles ( ) ; char [ ] a2 = ( ( Chicken ) mate ) . getRandomAlleles ( ) ; for ( int i = 0 ; i < geneCount ; i ++ ) { child [ i ] = "" + a1 [ i ] + a2 [ i ] ; } } while ( child [ 4 ] . equals ( "CC" ) ) ; Chicken chick = new Chicken ( child ) ; chick . parents [ 0 ] = this ; chick . parents [ 1 ] = mate ; return chick ; } else { return null ; } } else { return null ; } }
tr	4	private static void printLine ( String s , int level ) { if ( level >= logLevel ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( new Date ( ) . toString ( ) ) ; sb . append ( ": " ) ; switch ( level ) { case 0 : sb . append ( "INFO" ) ; break ; case 1 : sb . append ( "WARNING" ) ; break ; case 2 : sb . append ( "CRITICAL" ) ; break ; } sb . append ( ": " ) ; sb . append ( s ) ; System . out . println ( sb . toString ( ) ) ; out . println ( sb . toString ( ) ) ; out . flush ( ) ; } }
tr	9	public void storePast ( PastData past ) { if ( past . zip . equalsIgnoreCase ( "denver co" ) ) past . zip = "80201" ; String prefix = past . zip + " " + timeFormat . format ( past . date ) + " " + past . today + " " + past . occurredDate ; if ( past . overallPast . high != null || past . overallPast . precip != null ) { String str = prefix ; str = str + " " ; if ( past . overallPast . high != null ) str = str + past . overallPast . high . toString ( ) ; str = str + " " ; if ( past . overallPast . precip != null ) str = str + past . overallPast . precip . toString ( ) ; str = str + " " ; DAout . println ( str ) ; } if ( past . hourlyPast . length != 0 ) { for ( int i = 0 ; i < past . hourlyPast . length ; i ++ ) { String str = prefix ; str = str + " " + past . hourlyPast [ i ] . hour ; str = str + " " ; if ( past . hourlyPast [ i ] . temp != null ) str = str + past . hourlyPast [ i ] . temp . toString ( ) ; str = str + " " ; if ( past . hourlyPast [ i ] . conditions != null ) str = str + past . hourlyPast [ i ] . conditions ; str = str + " " ; if ( past . hourlyPast [ i ] . precip != null ) str = str + past . hourlyPast [ i ] . precip . toString ( ) ; str = str + " " ; HAout . println ( str ) ; } } }
tr	8	public boolean postMortem ( PostMortem pm ) { Node that = ( Node ) pm ; if ( that == null ) { JSONzip . log ( "\nMisalign" ) ; return false ; } if ( this . integer != that . integer ) { JSONzip . log ( "\nInteger " + this . integer + " <> " + that . integer ) ; return false ; } if ( this . next == null ) { if ( that . next == null ) { return true ; } JSONzip . log ( "\nNext is null " + this . integer ) ; return false ; } for ( int i = 0 ; i < 256 ; i += 1 ) { Node node = this . next [ i ] ; if ( node != null ) { if ( ! node . postMortem ( that . next [ i ] ) ) { return false ; } } else if ( that . next [ i ] != null ) { JSONzip . log ( "\nMisalign " + i ) ; return false ; } } return true ; }
tr	6	private static RubixPermutation parseMove ( char m ) { switch ( m ) { case F : return RubixPermutation . FRONT ; case B : return RubixPermutation . BACK ; case L : return RubixPermutation . LEFT ; case R : return RubixPermutation . RIGHT ; case U : return RubixPermutation . UP ; case D : return RubixPermutation . DOWN ; default : return RubixPermutation . IDENTITY ; } }
tr	5	private void initiateMalesAndFemales ( Habitat habitat ) { numberOfLonelyFemales = 0 ; males . clear ( ) ; lonelyFemales . clear ( ) ; for ( IndividualsGroupState group : habitat . getGroupsStates ( ) . values ( ) ) { if ( group . isMatureMale ( ) && group . strength > 0 ) males . add ( group ) ; else if ( group . isMatureFemale ( ) && group . getNotMultipliedst ( ) > 0 ) { lonelyFemales . add ( group ) ; numberOfLonelyFemales += group . getNotMultipliedst ( ) ; } } }
tr	5	public final void setDefaultValue ( Object defaultValue ) { if ( REQUIRED == mode && null != defaultValue ) { throw new LogicException ( "Cannot set a default value except for Parameter.OPTIONAL mode." ) ; } if ( isArray ( ) ) { if ( null == defaultValue ) { defaultValue = new ArrayList < Object > ( ) ; } else if ( ! ( defaultValue instanceof List ) ) { throw new LogicException ( "A default value for an array argument must be an array." ) ; } } this . defaultValue = defaultValue ; }
tr	9	@ Override protected void operationExecute ( ) throws MultiCloudException { try { if ( jsonBody != null ) { ObjectMapper mapper = json . getMapper ( ) ; body = mapper . writeValueAsString ( jsonBody ) ; } if ( body != null ) { synchronized ( lock ) { request = prepareRequest ( new StringEntity ( doPropertyMapping ( body , false ) ) ) ; } } else { synchronized ( lock ) { request = prepareRequest ( null ) ; } } } catch ( UnsupportedEncodingException | JsonProcessingException e1 ) { throw new MultiCloudException ( "Failed to prepare request." ) ; } try { setResult ( executeRequest ( request , new ResponseProcessor < FileInfo > ( ) { @ Override public FileInfo processResponse ( HttpResponse response ) { FileInfo info = null ; try { if ( response . getStatusLine ( ) . getStatusCode ( ) >= 400 ) { parseOperationError ( response ) ; } else { JsonNode tree = parseJsonResponse ( response ) ; if ( tree != null ) { info = json . getMapper ( ) . treeToValue ( tree , FileInfo . class ) ; info . fillMissing ( ) ; for ( FileInfo content : info . getContent ( ) ) { content . fillMissing ( ) ; } } else { info = new FileInfo ( ) ; info . setName ( name ) ; info . setFileType ( type ) ; } } } catch ( IllegalStateException | IOException e ) { } return info ; } } ) ) ; } catch ( IOException e ) { synchronized ( lock ) { if ( ! isAborted ) { throw new MultiCloudException ( "Failed to rename the specified file or folder." ) ; } } } synchronized ( lock ) { request = null ; } }
tr	6	@ Override public void actionPerformed ( ActionEvent e ) { if ( e . getActionCommand ( ) . equals ( "Save" ) ) { finish ( ) ; } else if ( e . getActionCommand ( ) . equals ( "Undo" ) ) { undoredo ( e . getActionCommand ( ) ) ; setFocusOnTxtArea ( ) ; } else if ( e . getActionCommand ( ) . equals ( "Redo" ) ) { undoredo ( e . getActionCommand ( ) ) ; setFocusOnTxtArea ( ) ; } else if ( e . getActionCommand ( ) . equals ( "Next" ) ) { wasLastInsertNext = true ; moveInsert ( 1 ) ; setFocusOnTxtArea ( ) ; } else if ( e . getActionCommand ( ) . equals ( "Prev" ) ) { wasLastInsertNext = false ; moveInsert ( 0 ) ; setFocusOnTxtArea ( ) ; } else if ( e . getActionCommand ( ) . contains ( "Append" ) ) { } }
tr	7	public void generateCrowdForOneDay ( ) { int oneHour = 3600 ; int requests ; int bufetRand = 5 ; int bufetOff = 2 ; requests = ( int ) ( Math . random ( ) * bufetRand ) + bufetOff ; for ( int i = 0 ; i < requests ; i ++ ) { generatePeopleGroupAgent ( stationMap . get ( "bufet" ) , stationMap . get ( "dormi" ) , ( int ) ( 1.5 * oneHour ) , ( int ) ( oneHour ) ) ; } int dormiRand = 15 ; int dormiOff = 10 ; requests = ( int ) ( Math . random ( ) * dormiRand ) + dormiOff ; for ( int i = 0 ; i < requests ; i ++ ) { generatePeopleGroupAgent ( stationMap . get ( "dormi" ) , stationMap . get ( "predavalnica" ) , ( int ) ( 6 * oneHour ) , ( int ) ( 2 * oneHour ) ) ; } int predavalnice1Rand = 15 ; int predavalnice1Off = 15 ; requests = ( int ) ( Math . random ( ) * predavalnice1Rand ) + predavalnice1Off ; for ( int i = 0 ; i < requests ; i ++ ) { generatePeopleGroupAgent ( stationMap . get ( "predavalnica" ) , stationMap . get ( "menza" ) , ( int ) ( 11 * oneHour ) , ( int ) ( 2 * oneHour ) ) ; } int menza1Rand = 10 ; int menza1Off = 6 ; requests = ( int ) ( Math . random ( ) * menza1Rand ) + menza1Off ; for ( int i = 0 ; i < requests ; i ++ ) { generatePeopleGroupAgent ( stationMap . get ( "menza" ) , stationMap . get ( "predavalnica" ) , ( int ) ( 12 * oneHour ) , ( int ) ( 2 * oneHour ) ) ; } int menza2Rand = 10 ; int menza2Off = 4 ; requests = ( int ) ( Math . random ( ) * menza2Rand ) + menza2Off ; for ( int i = 0 ; i < requests ; i ++ ) { generatePeopleGroupAgent ( stationMap . get ( "menza" ) , stationMap . get ( "dormi" ) , ( int ) ( 12 * oneHour ) , ( int ) ( 2 * oneHour ) ) ; } int menza3Rand = 3 ; int menza3Off = 2 ; requests = ( int ) ( Math . random ( ) * menza3Rand ) + menza3Off ; for ( int i = 0 ; i < requests ; i ++ ) { generatePeopleGroupAgent ( stationMap . get ( "menza" ) , stationMap . get ( "postaja" ) , ( int ) ( 12 * oneHour ) , ( int ) ( 2 * oneHour ) ) ; } int predavalnica3Rand = 3 ; int predavalnica3Off = 2 ; requests = ( int ) ( Math . random ( ) * predavalnica3Rand ) + predavalnica3Off ; for ( int i = 0 ; i < requests ; i ++ ) { generatePeopleGroupAgent ( stationMap . get ( "predavalnica" ) , stationMap . get ( "dormi" ) , ( int ) ( 16 * oneHour ) , ( int ) ( 6 * oneHour ) ) ; } }
tr	9	public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; int n = scan . nextInt ( ) ; int m = scan . nextInt ( ) ; long c = scan . nextLong ( ) ; boolean blown = false ; int act = 0 ; int max = 0 ; int cont = 1 ; while ( m != 0 && n != 0 && c != 0 ) { boolean [ ] aprs = new boolean [ n ] ; long [ ] aprscons = new long [ n ] ; int [ ] ops = new int [ m ] ; for ( int i = 0 ; i < n ; i ++ ) aprscons [ i ] = scan . nextLong ( ) ; for ( int i = 0 ; i < m ; i ++ ) ops [ i ] = scan . nextInt ( ) ; for ( int op : ops ) if ( aprs [ op - 1 ] == false ) { act += aprscons [ op - 1 ] ; aprs [ op - 1 ] = true ; if ( act > c ) { System . out . println ( "Sequence " + cont ) ; System . out . println ( "Fuse was blown." ) ; blown = true ; break ; } else if ( act > max ) max = act ; } else { act -= aprscons [ op - 1 ] ; aprs [ op - 1 ] = false ; } if ( blown == false ) { System . out . println ( "Sequence " + cont ) ; System . out . println ( "Fuse was not blown." ) ; System . out . println ( "Maximal power consumption was " + max + " amperes." ) ; } n = scan . nextInt ( ) ; m = scan . nextInt ( ) ; c = scan . nextLong ( ) ; cont ++ ; max = 0 ; act = 0 ; blown = false ; System . out . println ( ) ; } }
tr	8	public boolean equals ( peek_args that ) { if ( that == null ) return false ; boolean this_present_queue_name = true && this . is_set_queue_name ( ) ; boolean that_present_queue_name = true && that . is_set_queue_name ( ) ; if ( this_present_queue_name || that_present_queue_name ) { if ( ! ( this_present_queue_name && that_present_queue_name ) ) return false ; if ( ! this . queue_name . equals ( that . queue_name ) ) return false ; } return true ; }
tr	1	public MovieGoer createMovieGoer ( String name , String email , String mobileNo , Date dateOfBirth ) { MovieGoer movieGoer = movieGoerDAO . getMovieGoerByMobileNo ( mobileNo ) ; if ( movieGoer == null ) { movieGoer = new MovieGoer ( name , mobileNo , email , dateOfBirth ) ; movieGoerDAO . createMovieGoer ( movieGoer ) ; } return movieGoer ; }
tr	2	public static void runReports ( boolean full , boolean printall , Object ... objs ) { Tester t = new Tester ( ) ; if ( objs != null ) { for ( Object obj : objs ) { t . runAnyTests ( obj , full , printall ) ; } } }
tr	5	private Chunk loadChunk ( String [ ] [ ] s , Renderer rend ) { Point p1 = new Point ( Integer . decode ( s [ 0 ] [ 0 ] ) , Integer . decode ( s [ 0 ] [ 1 ] ) ) ; loaded . add ( p1 ) ; Chunk c ; const . debug ( "(SaveHandler:loadChunk): p1:" + p1 . x + "  " + p1 . y ) ; if ( p1 . x == 0 && p1 . y == 0 ) { const . debug ( "(SaveHandler:loadChunk): spawn will be loaded" ) ; c = new SpawnChunk ( map , p1 , true , rend , false ) ; } else if ( p1 . y < 0 ) { const . debug ( "(SaveHandler:loadChunk): underground will be loaded" ) ; c = new UndergroundChunk ( map , p1 , true , rend ) ; } else if ( p1 . y > 0 ) { const . debug ( "(SaveHandler:loadChunk): sky will be loaded" ) ; c = new SkyChunk ( map , p1 , true , rend ) ; } else { const . debug ( "(SaveHandler:loadChunk): surface will be loaded" ) ; c = new SurfaceChunk ( map , p1 , true , rend , false ) ; ( ( SurfaceChunk ) c ) . biome = Integer . decode ( s [ 0 ] [ 2 ] ) ; if ( p1 . x == 0 ) { System . err . println ( "error while loading chunk  wrong selection" ) ; System . exit ( 1 ) ; } } cl . add ( c . pos . x , c . pos . y , c ) ; return c ; }
tr	1	public static String encodeBytes ( byte [ ] source ) { String encoded = null ; try { encoded = encodeBytes ( source , 0 , source . length , NO_OPTIONS ) ; } catch ( java . io . IOException ex ) { assert false : ex . getMessage ( ) ; } assert encoded != null ; return encoded ; }
tr	1	@ Test public void InsertToAttachmentTest ( ) { AttachmentModel attachmentModel = new AttachmentModel ( ) ; File file = new File ( "F:\\updata.txt" ) ; byte [ ] bFile = new byte [ ( int ) file . length ( ) ] ; try { FileInputStream fis = new FileInputStream ( file ) ; fis . read ( bFile ) ; fis . close ( ) ; attachmentModel . setATTACHMENT_DATA ( bFile ) ; } catch ( Exception e ) { System . out . println ( e . getMessage ( ) ) ; } attachmentModel . setATTACHMENT_TYPE ( "\u56FE\u7247" ) ; attachmentManageService . InsertToAttachment ( attachmentModel ) ; }
tr	1	public Game ( Dimension boardDimension ) { board = new Board ( boardDimension , this ) ; windowFavoriteSize = new Dimension ( 800 , 600 ) ; playerList = new ArrayList < Player > ( ) ; bufferPlayers = new ArrayList < Player > ( ) ; try { bufferBoard = board . clone ( ) ; } catch ( CloneNotSupportedException e ) { e . printStackTrace ( ) ; } }
tr	4	public static final byte product ( byte u , byte v ) { if ( u == 0 || v == 0 ) return 0 ; if ( u == 1 ) return v ; if ( v == 1 ) return u ; else { byte product = getExp ( UNSIGN ( getLog ( u - 1 ) ) + UNSIGN ( getLog ( v - 1 ) ) ) ; return product ; } }
tr	2	public void buildExampleTexProject ( File dir , String packageName ) throws IOException { if ( packageName == null ) packageName = mFamilyName ; Map < TexFontBuilder , String > nameMap = doBuildTypefacePackage ( dir , packageName ) ; File texFile = new File ( dir , "example.tex" ) ; PrintWriter out = new PrintWriter ( texFile ) ; out . println ( "\\documentclass[12pt]{article}" ) ; out . println ( ) ; out . format ( "\\usepackage{%s}\n" , packageName ) ; out . println ( ) ; out . println ( "\\usepackage{fonttable}" ) ; out . println ( ) ; out . println ( "\\title{Gulliver's Travels}" ) ; out . println ( "\\author{Jonathan Swift}" ) ; out . println ( "\\begin{document}" ) ; out . println ( ) ; out . println ( "\\maketitle" ) ; out . println ( ) ; out . println ( "The first request I made  after I had obtained my liberty  was  that I might have license " + "to see Mildendo  the metropolis; which the emperor easily granted me  but with a special " + "charge to do no hurt either to the inhabitants or their houses. The people had notice  by " + "proclamation  of my design to visit the town. The wall which encompassed it is two feet and a " + "half high  and at least eleven inches broad  so that a coach and horses may be driven very safely " + "round it; and it is flanked with strong towers at ten feet distance. I stepped over the great " + "western gate  and passed very gently  and sidling  through the two principal streets  only in " + "my short waistcoat  for fear of damaging the roofs and eaves of the houses with the skirts of my " + "coat. I walked with the utmost circumspection  to avoid treading on any stragglers who might remain " + "in the streets  although the orders were very strict  that all people should keep in their houses  at " + "their own peril. The garret windows and tops of houses were so crowded with spectators  that I thought " + "in all my travels I had not seen a more populous place. The city is an exact square  each side of the " + "wall being five hundred feet long. The two great streets  which run across and divide it into four " + "quarters  are five feet wide. The lanes and alleys  which I could not enter  but only view them as " + "I passed  are from twelve to eighteen inches. The town is capable of holding five hundred thousand " + "souls: the houses are from three to five stories: the shops and markets well provided." ) ; out . println ( ) ; out . println ( "\\textbf{The emperor's palace is in the centre} " + "\\textit{of the city where the two great streets meet.}" + " It is " + "enclosed by a wall of two feet high  and twenty feet distance from the buildings. I had " + "his majesty's permission to step over this wall; and  the space being so wide between that " + "and the palace  I could easily view it on every side. The outward court is a square of forty " + "feet  and includes two other courts: in the inmost are the royal apartments  which I was very " + "desirous to see  but found it extremely difficult; for the great gates  from one square into " + "another  were but eighteen inches high  and seven inches wide. Now the buildings of the outer " + "court were at least five feet high  and it was impossible for me to stride over them without " + "infinite damage to the pile  though the walls were strongly built of hewn stone  and four inches " + "thick. At the same time the emperor had a great desire that I should see the magnificence of his " + "palace; but this I was not able to do till three days after  which I spent in cutting down with my " + "knife some of the largest trees in the royal park  about a hundred yards distant from the city. " + "Of these trees I made two stools  each about three feet high  and strong enough to bear my weight. " + "The people having received notice a second time  I went again through the city to the palace with " + "my two stools in my hands. When I came to the side of the outer court  I stood upon one stool  and " + "took the other in my hand; this I lifted over the roof  and gently set it down on the space between " + "the first and second court  which was eight feet wide. I then stept over the building very " + "conveniently from one stool to the other  and drew up the first after me with a hooked stick. " + "By this contrivance I got into the inmost court; and  lying down upon my side  I applied my " + "face to the windows of the middle stories  which were left open on purpose  and discovered the " + "most splendid apartments that can be imagined. There I saw the empress and the young princes  in " + "their several lodgings  with their chief attendants about them. Her imperial majesty was pleased " + "to smile very graciously upon me  and gave me out of the window her hand to kiss." ) ; out . println ( ) ; out . println ( "\\clearpage" ) ; for ( String name : nameMap . values ( ) ) { out . format ( "\\fonttable{%s}\n" , name ) ; } out . println ( ) ; out . println ( "\\end{document}" ) ; out . close ( ) ; }
tr	5	@ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; ComplexNumber that = ( ComplexNumber ) o ; if ( double . compare ( that . im , im ) != 0 ) return false ; if ( double . compare ( that . re , re ) != 0 ) return false ; return true ; }
tr	4	@ Override public void printRow2 ( int row ) { int row_to_print = row - position . row ; if ( row_to_print >= 0 && row_to_print < size . row ) { for ( int i = cols_printed ; i < position . col ; i ++ ) { System . out . format ( "%2s " , " " ) ; cols_printed ++ ; } for ( int col = 0 ; col < size . col ; col ++ ) { System . out . format ( "%2s " , array [ row_to_print ] [ col ] . toString ( ) ) ; cols_printed ++ ; } } }
tr	2	public List < Review > getReviews ( ) { final List < Review > reviews = new ArrayList < Review > ( ) ; for ( final Solution solution : solutions ) { if ( solution . isCorrected ( ) ) { reviews . add ( solution . getReview ( ) ) ; } } return reviews ; }
tr	6	public ListNode reverseBetween ( ListNode head , int m , int n ) { if ( m == n ) return head ; ListNode dumy = new ListNode ( 0 ) ; dumy . next = head ; ListNode pre = dumy ; ListNode cur = head ; ListNode tail = null ; ListNode start = null ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i == m ) { tail = cur ; start = pre ; start . next = cur . next ; pre = cur ; cur = cur . next ; } else if ( i > m && i < n ) { start . next = cur . next ; cur . next = pre ; pre = cur ; cur = start . next ; } else if ( i == n ) { tail . next = cur . next ; cur . next = pre ; } else { pre = cur ; cur = cur . next ; } } return dumy . next ; }
tr	7	public static void makeCompactGrid ( Container parent , int rows , int cols , int initialX , int initialY , int xPad , int yPad ) { SpringLayout layout ; try { layout = ( SpringLayout ) parent . getLayout ( ) ; } catch ( ClassCastException exc ) { System . err . println ( "The first argument to makeCompactGrid must use SpringLayout." ) ; return ; } Spring x = Spring . constant ( initialX ) ; for ( int c = 0 ; c < cols ; c ++ ) { Spring width = Spring . constant ( 0 ) ; for ( int r = 0 ; r < rows ; r ++ ) { width = Spring . max ( width , getConstraintsForCell ( r , c , parent , cols ) . getWidth ( ) ) ; } for ( int r = 0 ; r < rows ; r ++ ) { SpringLayout . Constraints constraints = getConstraintsForCell ( r , c , parent , cols ) ; constraints . setX ( x ) ; constraints . setWidth ( width ) ; } x = Spring . sum ( x , Spring . sum ( width , Spring . constant ( xPad ) ) ) ; } Spring y = Spring . constant ( initialY ) ; for ( int r = 0 ; r < rows ; r ++ ) { Spring height = Spring . constant ( 0 ) ; for ( int c = 0 ; c < cols ; c ++ ) { height = Spring . max ( height , getConstraintsForCell ( r , c , parent , cols ) . getHeight ( ) ) ; } for ( int c = 0 ; c < cols ; c ++ ) { SpringLayout . Constraints constraints = getConstraintsForCell ( r , c , parent , cols ) ; constraints . setY ( y ) ; constraints . setHeight ( height ) ; } y = Spring . sum ( y , Spring . sum ( height , Spring . constant ( yPad ) ) ) ; } SpringLayout . Constraints pCons = layout . getConstraints ( parent ) ; pCons . setConstraint ( SpringLayout . SOUTH , y ) ; pCons . setConstraint ( SpringLayout . EAST , x ) ; }
tr	7	protected void merge ( int begin , int middle , int end ) { int firstHalf ; int secondHalf ; int count ; firstHalf = count = begin ; secondHalf = middle + 1 ; while ( ( firstHalf <= middle ) && ( secondHalf <= end ) ) { if ( this . compareElementsAt ( secondHalf , firstHalf ) < 0 ) { swapSpace [ count ++ ] = toSort [ secondHalf ++ ] ; } else { swapSpace [ count ++ ] = toSort [ firstHalf ++ ] ; } } if ( firstHalf <= middle ) { while ( firstHalf <= middle ) { swapSpace [ count ++ ] = toSort [ firstHalf ++ ] ; } } else { while ( secondHalf <= end ) { swapSpace [ count ++ ] = toSort [ secondHalf ++ ] ; } } for ( count = begin ; count <= end ; count ++ ) { toSort [ count ] = swapSpace [ count ] ; } }
tr	9	protected void downloadJars ( String path ) throws Exception { File versionFile = new File ( path , "md5s" ) ; Properties md5s = new Properties ( ) ; if ( versionFile . exists ( ) ) { try { FileInputStream fis = new FileInputStream ( versionFile ) ; md5s . load ( fis ) ; fis . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } state = 4 ; int [ ] fileSizes = new int [ urlList . length ] ; boolean [ ] skip = new boolean [ urlList . length ] ; for ( int i = 0 ; i < urlList . length ; i ++ ) { URLConnection urlconnection = urlList [ i ] . openConnection ( ) ; urlconnection . setDefaultUseCaches ( false ) ; skip [ i ] = false ; if ( ( urlconnection instanceof HttpURLConnection ) ) { ( ( HttpURLConnection ) urlconnection ) . setRequestMethod ( "HEAD" ) ; int code = ( ( HttpURLConnection ) urlconnection ) . getResponseCode ( ) ; if ( code / 100 == 3 ) { skip [ i ] = true ; } } fileSizes [ i ] = urlconnection . getContentLength ( ) ; totalSizeDownload += fileSizes [ i ] ; } int initialPercentage = this . percentage = 10 ; byte [ ] buffer = new byte [ 65536 ] ; for ( int i = 0 ; i < urlList . length ; i ++ ) { if ( skip [ i ] != false ) { percentage = ( initialPercentage + fileSizes [ i ] * 45 / totalSizeDownload ) ; } boolean downloadFile = true ; while ( downloadFile ) { downloadFile = false ; URLConnection urlconnection = urlList [ i ] . openConnection ( ) ; String etag = "" ; if ( ( urlconnection instanceof HttpURLConnection ) ) { urlconnection . setRequestProperty ( "Cache-Control" , "no-cache" ) ; urlconnection . connect ( ) ; etag = urlconnection . getHeaderField ( "ETag" ) ; } String currentFile = getFileName ( urlList [ i ] ) ; InputStream inputstream = getJarInputStream ( currentFile , urlconnection ) ; FileOutputStream fos = new FileOutputStream ( path + currentFile ) ; long downloadStartTime = System . currentTimeMillis ( ) ; int downloadedAmount = 0 ; int fileSize = 0 ; String downloadSpeedMessage = "" ; MessageDigest m = MessageDigest . getInstance ( "MD5" ) ; int bufferSize ; while ( ( bufferSize = inputstream . read ( buffer , 0 , buffer . length ) ) != - 1 ) { fos . write ( buffer , 0 , bufferSize ) ; m . update ( buffer , 0 , bufferSize ) ; currentSizeDownload += bufferSize ; fileSize += bufferSize ; percentage = ( initialPercentage + currentSizeDownload * 45 / totalSizeDownload ) ; subtaskMessage = ( "\u0417\u0430\u0433\u0440\u0443\u0437\u043A\u0430: " + currentFile + " " + currentSizeDownload * 100 / totalSizeDownload + "%" ) ; downloadedAmount += bufferSize ; long timeLapse = System . currentTimeMillis ( ) - downloadStartTime ; if ( timeLapse >= 1000 ) { float downloadSpeed = downloadedAmount / ( float ) timeLapse ; downloadSpeed = ( int ) ( downloadSpeed * 100.0F ) / 100.0F ; downloadSpeedMessage = " @ " + downloadSpeed + " KB/sec" ; downloadedAmount = 0 ; downloadStartTime += 1000 ; } subtaskMessage += downloadSpeedMessage ; } inputstream . close ( ) ; fos . close ( ) ; } } }
tr	0	@ Override public void execute ( ) { light . on ( ) ; }
tr	1	public final void startup ( ) { if ( ! running ) { running = true ; doStartup ( ) ; } }
tr	3	@ Test public void superThreadSafe ( ) { final SimpleMath math = new SimpleMath ( ) ; final Map < Integer , Integer > results = new ConcurrentHashMap < Integer , Integer > ( ) ; final CountDownLatch latch = new CountDownLatch ( 1000 ) ; final CountDownLatch allDone = new CountDownLatch ( 1000 ) ; for ( int i = 0 ; i < 1000 ; i ++ ) { final int copy = i ; new Thread ( ) { public void run ( ) { try { latch . countDown ( ) ; latch . await ( ) ; int result = math . doubleAndIncrement ( copy ) ; results . put ( copy , result ) ; allDone . countDown ( ) ; } catch ( Exception e ) { } } } . start ( ) ; } try { allDone . await ( ) ; } catch ( Exception e ) { } assertEquals ( new Integer ( 45 ) , results . get ( 22 ) ) ; }
tr	7	public Sound ( OpenALAudio audio , FileHandle file ) { super ( audio ) ; if ( audio . noDevice ) { return ; } ByteArrayOutputStream output = new ByteArrayOutputStream ( 4096 ) ; Bitstream bitstream = new Bitstream ( file . read ( ) ) ; MP3Decoder decoder = new MP3Decoder ( ) ; try { OutputBuffer outputBuffer = null ; int sampleRate = - 1 , channels = - 1 ; while ( true ) { Header header = bitstream . readFrame ( ) ; if ( header == null ) { break ; } if ( outputBuffer == null ) { channels = header . mode ( ) == Header . SINGLE_CHANNEL ? 1 : 2 ; outputBuffer = new OutputBuffer ( channels , false ) ; decoder . setOutputBuffer ( outputBuffer ) ; sampleRate = header . getSampleRate ( ) ; } try { decoder . decodeFrame ( header , bitstream ) ; } catch ( Exception ignored ) { } bitstream . closeFrame ( ) ; output . write ( outputBuffer . getBuffer ( ) , 0 , outputBuffer . reset ( ) ) ; } bitstream . close ( ) ; setup ( output . toByteArray ( ) , channels , sampleRate ) ; } catch ( Throwable ex ) { throw new GdxRuntimeException ( "Error reading audio data." , ex ) ; } }
tr	1	public Response getCloudInstanceInfo ( Integer timezone , String type , Integer instanceId , OutputType output ) throws MonitisException { HashMap < String , Object > params = new HashMap < String , Object > ( ) ; params . put ( "output" , output ) ; if ( timezone != null ) params . put ( "timezone" , timezone ) ; params . put ( "type" , type ) ; params . put ( "instanceId" , instanceId ) ; Response resp = makeGetRequest ( CloudAction . cloudInstanceInfo , params ) ; return resp ; }
tr	0	public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; System . out . println ( "Enter the value of n" ) ; int n = sc . nextInt ( ) ; System . out . println ( "Enter the vaue of k" ) ; int k = sc . nextInt ( ) ; System . out . println ( "The result is " + findCombination ( n , k ) ) ; }
tr	0	public int intensity_stereo_bound ( ) { return h_intensity_stereo_bound ; }
tr	6	private void addLongOption ( String name , String value ) throws IllegalArgumentException { if ( ! definition . hasOption ( name ) ) { throw new IllegalArgumentException ( String . format ( "The \"--%s\" option does not exist." , name ) ) ; } InputOption option = definition . getOption ( name ) ; if ( null == value ) { if ( option . isValueRequired ( ) ) { throw new IllegalArgumentException ( String . format ( "The \"--%s\" option requires a value." , name ) ) ; } value = option . isValueOptional ( ) ? String . valueOf ( option . getDefaultValue ( ) ) : "true" ; } Object parsedValue = "true" . equalsIgnoreCase ( value ) ? true : "false" . equalsIgnoreCase ( value ) ? false : value ; options . put ( name , parsedValue ) ; }
tr	8	protected FileRequestResponseMessage handleResponse ( InputStream in ) throws UnsupportedEncodingException { FileRequestResponseMessage try_again = new FileRequestResponseMessage ( FileRequestResponseMessage . ResponseCode . TRY_AGAIN_LATER , 0 ) ; int probe_len = FileRequestResponseMessage . TYPE_FIELD . length ( ) + 4 ; byte [ ] buffer = new byte [ probe_len ] ; try { in . read ( buffer , 0 , probe_len ) ; } catch ( IOException e ) { logger . log ( Level . SEVERE , "Could not read response stream: '" + e . getMessage ( ) + "' - assuming 'NEVER TRY AGAIN'" ) ; return try_again ; } String responseHeader = new String ( buffer , Message . ENCODING ) . trim ( ) ; switch ( responseHeader . toUpperCase ( ) ) { case FileRequestResponseMessage . TYPE_FIELD + Message . FIELD_SEPERATOR + "OK" : String str_expectedTransferVolume = "" ; int next ; try { while ( ( next = in . read ( ) ) != Message . MESSAGE_SPERATOR ) if ( next == - 1 ) { Thread . sleep ( 500 ) ; } else { str_expectedTransferVolume += new String ( new byte [ ] { ( byte ) next } , Message . ENCODING ) ; } } catch ( IOException | InterruptedException e ) { logger . log ( Level . SEVERE , "Could not understand response header" ) ; transferState = TransferStatus . LostConnection ; closeSocket ( ) ; return null ; } try { long expectedTransferVolume = long . valueOf ( str_expectedTransferVolume ) ; return new FileRequestResponseMessage ( FileRequestResponseMessage . ResponseCode . OK , expectedTransferVolume ) ; } catch ( NumberFormatException ex ) { logger . log ( Level . SEVERE , "Response contained invalid 'expected transfer volume' - assuming 'TRY AGAIN LATER'" ) ; return try_again ; } case FileRequestResponseMessage . TYPE_FIELD + Message . FIELD_SEPERATOR + "TRY" : logger . log ( Level . INFO , "Received 'try again later from host'" ) ; return try_again ; case FileRequestResponseMessage . TYPE_FIELD + Message . FIELD_SEPERATOR + "NEV" : logger . log ( Level . INFO , "Received 'never try agiain from host'" ) ; return new FileRequestResponseMessage ( FileRequestResponseMessage . ResponseCode . NEVER_TRY_AGAIN , 0 ) ; default : logger . log ( Level . INFO , "Received garbage: '" + responseHeader + "'" ) ; return try_again ; } }
tr	2	private ArrayList < AtomExecutableCommand > populateExecutableCommandList ( String serverId , ArrayList < AtomExecutableCommand > commandList ) { AtomExecutableCommand _commandDet ; ArrayList < AtomExecutableCommand > _commandList ; int index = 0 ; int _countExecutables ; _commandList = new ArrayList < AtomExecutableCommand > ( ) ; _countExecutables = commandList . size ( ) ; while ( _countExecutables > index ) { _commandDet = commandList . get ( index ) ; if ( serverId . equals ( _commandDet . getServerID ( ) ) ) { _commandList . add ( _commandDet ) ; } index ++ ; } return _commandList ; }
tr	1	public static StroopTest createOneColourTest ( int wordSize ) { List < Word > words = new ArrayList < Word > ( wordSize ) ; for ( int i = 0 ; i < wordSize ; i ++ ) { words . add ( WordFactory . createRandomColourWord ( ) ) ; } return new StroopTest ( words , TestType . TEST_WORD ) ; }
tr	4	public static Point2 getPositionAfterMovement ( Entity entity ) { switch ( entity . orientation ) { case NORTH : return new Point2 ( entity . position . x , entity . position . y - 1 ) ; case EAST : return new Point2 ( entity . position . x + 1 , entity . position . y ) ; case SOUTH : return new Point2 ( entity . position . x , entity . position . y + 1 ) ; case WEST : return new Point2 ( entity . position . x - 1 , entity . position . y ) ; default : return new Point2 ( entity . position . x , entity . position . y ) ; } }
tr	2	@ Override public void emitCode ( ) { Address address = null ; if ( isDigit ( secondParam . charAt ( 0 ) ) ) { System . out . println ( lineNumber ++ + ":   LDC  0 " + secondParam + ZERO_REGISTER ) ; } else { address = manager . getAddressOfVar ( secondParam ) ; System . out . println ( lineNumber ++ + ":    LD  0 " + address . getOffset ( ) + address . getRegisterValue ( ) ) ; } if ( isDigit ( thirdParam . charAt ( 0 ) ) ) { System . out . println ( lineNumber ++ + ":   LDC  1 " + thirdParam + ZERO_REGISTER ) ; } else { address = manager . getAddressOfVar ( thirdParam ) ; System . out . println ( lineNumber ++ + ":    LD  1 " + address . getOffset ( ) + address . getRegisterValue ( ) ) ; } System . out . println ( lineNumber ++ + ":   ADD  0 0 1" ) ; address = manager . getAddressOfVar ( firstParam ) ; System . out . println ( lineNumber + ":    ST  0 " + address . getOffset ( ) + address . getRegisterValue ( ) ) ; }
tr	6	void copyBGToBuf ( Graphics bufg , int sx1 , int sy1 , int sx2 , int sy2 , int dx1 , int dy1 ) { if ( sx2 <= sx1 || sy2 <= sy1 ) return ; int barrelx = el . scaleXPos ( el . moduloFloor ( el . xofs , el . tilex ) , false ) ; int barrely = el . scaleYPos ( el . moduloFloor ( el . yofs , el . tiley ) , false ) ; int barreldx = ( sx1 == 0 ) ? barrelx : 0 ; int barreldy = ( sy1 == 0 ) ? barrely : 0 ; barrelx = ( sx1 == 0 ) ? 0 : barrelx ; barrely = ( sy1 == 0 ) ? 0 : barrely ; int dx2 = dx1 + sx2 - sx1 ; int dy2 = dy1 + sy2 - sy1 ; bufg . drawImage ( background , dx1 * el . scaledtilex - barreldx , dy1 * el . scaledtiley - barreldy , dx2 * el . scaledtilex - barreldx , dy2 * el . scaledtiley - barreldy , barrelx + sx1 * el . scaledtilex , barrely + sy1 * el . scaledtiley , barrelx + sx2 * el . scaledtilex , barrely + sy2 * el . scaledtiley , this ) ; }
tr	9	public String to_simple_string ( ) throws internal_error { String result ; production_part part ; if ( _the_production . lhs ( ) != null && _the_production . lhs ( ) . the_symbol ( ) != null && _the_production . lhs ( ) . the_symbol ( ) . name ( ) != null ) result = _the_production . lhs ( ) . the_symbol ( ) . name ( ) ; else result = "$$NULL$$" ; result += " ::= " ; for ( int i = 0 ; i < _the_production . rhs_length ( ) ; i ++ ) { if ( i == _dot_pos ) result += "(*) " ; if ( _the_production . rhs ( i ) == null ) { result += "$$NULL$$ " ; } else { part = _the_production . rhs ( i ) ; if ( part == null ) result += "$$NULL$$ " ; else if ( part . is_action ( ) ) result += "{ACTION} " ; else if ( ( ( symbol_part ) part ) . the_symbol ( ) != null && ( ( symbol_part ) part ) . the_symbol ( ) . name ( ) != null ) result += ( ( symbol_part ) part ) . the_symbol ( ) . name ( ) + " " ; else result += "$$NULL$$ " ; } } if ( _dot_pos == _the_production . rhs_length ( ) ) result += "(*) " ; return result ; }
tr	6	static private final int jjMoveStringLiteralDfa9_0 ( long old0 , long active0 ) { if ( ( ( active0 &= old0 ) ) == 0 ) return jjStartNfa_0 ( 7 , old0 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 8 , active0 ) ; return 9 ; } switch ( curChar ) { case 73 : return jjMoveStringLiteralDfa10_0 ( active0 , 20 ) ; case 105 : return jjMoveStringLiteralDfa10_0 ( active0 , 1000 ) ; case 108 : return jjMoveStringLiteralDfa10_0 ( active0 , 2000 ) ; case 114 : return jjMoveStringLiteralDfa10_0 ( active0 , 40 ) ; default : break ; } return jjStartNfa_0 ( 8 , active0 ) ; }
tr	7	public SimFileParser ( final String absFilePath , final SIM_FILE_FORMAT simFileFormat , final String absIdFilePath , final ID_FILE_FORMAT idFileFormat , final String outputFile , final OUTPUT_MODE outputMode , final SIM_FILE_FORMAT outputFormat ) throws IOException { super ( absFilePath , null , null , outputFile , outputMode ) ; this . simFileFormat = simFileFormat ; this . outputFormat = outputFormat ; this . keyToId = new HashMap < String , Integer > ( ) ; this . idToKey = new HashMap < Integer , String > ( ) ; if ( absIdFilePath != null ) { this . absIdFilePath = absIdFilePath ; this . idFileFormat = idFileFormat ; this . parseIdFile ( ) ; } if ( this . simFileFormat . equals ( SIM_FILE_FORMAT . ID_ID_SIM ) || this . simFileFormat . equals ( SIM_FILE_FORMAT . BLAST ) ) { this . keyColumns = new int [ ] { 0 , 1 } ; this . valueColumns = new int [ ] { 2 } ; log . trace ( "Counting ids of similarity file..." ) ; this . sequenceCount = this . countKeysInColumns ( this . keyColumns ) ; log . trace ( "Similarity file contains " + this . sequenceCount + " lines" ) ; if ( this . getTotalLineCount ( ) != ( long ) Math . pow ( this . sequenceCount , 2 ) ) { log . warn ( "WARNING: The number of lines in the similarity file (" + ( this . getTotalLineCount ( ) ) + ") does not match the expected number (" + ( this . sequenceCount * this . sequenceCount ) + ")" ) ; } } else if ( this . simFileFormat . equals ( SIM_FILE_FORMAT . SIM ) ) { this . sequenceCount = ( int ) Math . sqrt ( this . getTotalLineCount ( ) ) ; } else if ( this . simFileFormat . equals ( SIM_FILE_FORMAT . MATRIX ) ) { this . keyColumns = new int [ 0 ] ; this . valueColumns = new int [ 0 ] ; this . sequenceCount = this . getColumnsInFile ( ) ; } else if ( this . simFileFormat . equals ( SIM_FILE_FORMAT . MATRIX_HEADER ) ) { this . keyColumns = new int [ ] { 0 } ; this . valueColumns = ArraysExt . range ( 1 , this . getColumnsInFile ( ) ) ; this . sequenceCount = this . getColumnsInFile ( ) - 1 ; } }
tr	8	@ Override protected void process ( ) { StringTokenizer t = new StringTokenizer ( fileL . getListString ( true ) , "\n" ) ; int files = 0 , total = 0 ; for ( ; t . hasMoreTokens ( ) ; files ++ ) { String s = t . nextToken ( ) ; String title = Print . titleString ( "--" , s ) ; if ( showAllFiles ) { Print . ln ( title ) ; title = null ; } int i = 0 ; try ( BufferedReader in = new BufferedReader ( new FileReader ( s ) ) ) { for ( int line = 1 ; ( s = in . readLine ( ) ) != null ; line ++ ) if ( fnameFilter . accept ( s ) ) { if ( title != null ) { Print . ln ( title ) ; title = null ; } Print . f ( "%3d: %s\n" , line , s ) ; i ++ ; } } catch ( IOException ioe ) { Sys . warning ( ioe . toString ( ) ) ; } if ( i > 0 || showAllFiles ) { Print . ln ( "   " + i + " occurrence(s)" ) ; } total += i ; } Print . ln ( Print . separator ( "==========================" ) ) ; Print . ln ( "Totally " + total + " occurrence(s) in " + files + " file(s).\n" ) ; }
tr	2	private Object lessMin ( Object subtree ) { if ( ! ( subtree instanceof Node ) ) { Object [ ] ary = ( Object [ ] ) subtree ; return subseq ( ary , 1 , ary . length ) ; } else { Node node = ( Node ) subtree ; if ( node . left == null ) return node . right ; else return concat ( node . element , lessMin ( node . left ) , node . right ) ; } }
tr	7	public void calculateSalary ( double [ ] salary ) { if ( salary == null || salary . length <= 0 ) { return ; } double afterTaxTotal = 0 , totalTax = 0 ; double [ ] afterTaxSalary = new double [ salary . length ] ; for ( int i = 0 ; i < salary . length ; i ++ ) { if ( salary [ i ] < 4000 && salary [ i ] >= 0 ) { afterTaxSalary [ i ] = salary [ i ] - ( salary [ i ] - 800 ) * 0.2 ; } else if ( salary [ i ] >= 4000 ) { afterTaxSalary [ i ] = salary [ i ] - ( salary [ i ] * 0.16 ) ; } } for ( int i = 0 ; i < salary . length ; i ++ ) { System . out . println ( "mouth : " + ( i + 1 ) + " salary : " + salary [ i ] + "   " + "afterTaxSalary : " + afterTaxSalary [ i ] + "  " + " tax :" + ( salary [ i ] - afterTaxSalary [ i ] ) ) ; afterTaxTotal += afterTaxSalary [ i ] ; totalTax += ( salary [ i ] - afterTaxSalary [ i ] ) ; } System . out . println ( "total after tax salary : " + afterTaxTotal + "  " + "total tax:" + totalTax ) ; }
tr	2	public static void main ( String [ ] args ) throws Exception { rd = new BufferedReader ( new FileReader ( "d:\\programDATA\\Numbers\\C-large-practice.in" ) ) ; wr = new PrintWriter ( new FileWriter ( "d:\\programDATA\\Numbers\\C-large-practice.out" ) ) ; int num ; String line = rd . readLine ( ) ; while ( true ) { line = rd . readLine ( ) ; if ( line == null ) break ; else wr . print ( "Case #" + count ++ + ": " ) ; num = Integer . parseInt ( line ) ; calc ( num ) ; } rd . close ( ) ; wr . close ( ) ; }
tr	5	private ActionListener createInviteListener ( ) { return new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { PeerStatus status = LocalInfo . getPeerStatus ( ) ; if ( ! ( status == PeerStatus . STARTER || status == PeerStatus . INVITEE ) ) { JOptionPane . showMessageDialog ( frame , "You have no authority to do that" ) ; return ; } String ipPort = JOptionPane . showInputDialog ( "Please input ip:port" ) ; if ( ipPort == null ) return ; String [ ] strs = ipPort . split ( ":" ) ; if ( strs . length != 2 ) { JOptionPane . showMessageDialog ( null , "Invalid Format of Ip and Port" , "Error!" , JOptionPane . ERROR_MESSAGE ) ; return ; } try { LocalSender . sendInvitationMsg ( strs [ 0 ] , Integer . parseInt ( strs [ 1 ] ) , Event . INVITATION ) ; System . out . println ( "Invite server to network: " + strs [ 0 ] + ":" + strs [ 1 ] ) ; } catch ( Exception exception ) { exception . printStackTrace ( ) ; } } } ; }
tr	9	public boolean isModifier ( DataHolder dataholderHandler , String word , String modifier , String tag ) { if ( this . checkedModifiers . containsKey ( word ) ) { if ( this . checkedModifiers . get ( word ) ) { return true ; } else { return false ; } } Set < String > nouns = new HashSet < String > ( Arrays . asList ( "s p n" . split ( " " ) ) ) ; List < Entry < WordPOSKey , WordPOSValue >> entries = dataholderHandler . getWordPOSEntriesByWordPOS ( word , nouns ) ; if ( entries . size ( ) > 0 ) { this . checkedModifiers . put ( word , true ) ; return true ; } Set < String > bPOS = new HashSet < String > ( ) ; bPOS . add ( "b" ) ; List < Entry < WordPOSKey , WordPOSValue >> boundaries = dataholderHandler . getWordPOSEntriesByWordPOS ( word , bPOS ) ; boolean c1 = ( boundaries . size ( ) > 0 ) ; boolean c2 = dataholderHandler . getModifierHolder ( ) . containsKey ( word ) ; if ( c1 && ! c2 ) { this . checkedModifiers . put ( word , false ) ; return false ; } if ( ! c1 && c2 ) { this . checkedModifiers . put ( word , true ) ; return true ; } int mCount = this . getMCount ( dataholderHandler , word ) ; String wCopy = "" + word ; if ( StringUtility . isMatchedNullSafe ( word , "_" ) ) { wCopy = wCopy . replaceAll ( "_" , " - " ) ; } int tCount = 0 ; String pattern = "(^| )" + wCopy + " " ; for ( SentenceStructure sentenceItem : dataholderHandler . getSentenceHolder ( ) ) { String oSentence = sentenceItem . getOriginalSentence ( ) ; if ( StringUtility . isMatchedNullSafe ( oSentence , pattern ) ) { tCount ++ ; } } if ( tCount == 0 || tCount > 0.25 * mCount ) { this . checkedModifiers . put ( word , false ) ; return false ; } else { this . checkedModifiers . put ( word , true ) ; return true ; } }
tr	2	private void AddNewUpdateTime ( float newTime ) { float addTime = newTime ; if ( addTime > 50 ) { addTime = 50 ; } if ( updateTimes . size ( ) >= NUM_UPDATE_TIMES ) { updateTimes . remove ( 0 ) ; } updateTimes . add ( newTime ) ; runTime += newTime ; }
tr	6	public void actionPerformed ( ActionEvent arg0 ) { if ( arg0 . getSource ( ) == view . getBoutonJouer ( ) ) { if ( modifierOptions ( ) ) fenetre . changerVue ( new ChoixModeView ( ) ) ; else fenetre . changerVue ( new MessageView ( "Impossible de valider les options." , view , true ) ) ; } else if ( arg0 . getSource ( ) == view . getBoutonRetour ( ) ) { choix = fenetre . afficherChoixMessage ( "Sauvegarder les modifications ?" , "Attention" ) ; if ( choix == JOptionPane . YES_OPTION ) if ( modifierOptions ( ) ) fenetre . changerVue ( new AccueilView ( ) ) ; else fenetre . changerVue ( new MessageView ( "Impossible de valider les options." , view , true ) ) ; else if ( choix == JOptionPane . NO_OPTION ) fenetre . changerVue ( new AccueilView ( ) ) ; } }
tr	9	public static String getTypeName ( class < ? extends Tag > clazz ) { if ( clazz . equals ( ByteArrayTag . class ) ) { return "TAG_Byte_Array" ; } else if ( clazz . equals ( ByteTag . class ) ) { return "TAG_Byte" ; } else if ( clazz . equals ( CompoundTag . class ) ) { return "TAG_Compound" ; } else if ( clazz . equals ( DoubleTag . class ) ) { return "TAG_Double" ; } else if ( clazz . equals ( EndTag . class ) ) { return "TAG_End" ; } else if ( clazz . equals ( FloatTag . class ) ) { return "TAG_Float" ; } else if ( clazz . equals ( IntArrayTag . class ) ) { return "TAG_Int_Array" ; } else if ( clazz . equals ( IntTag . class ) ) { return "TAG_Int" ; } else if ( clazz . equals ( ListTag . class ) ) { return "TAG_List" ; } else if ( clazz . equals ( LongTag . class ) ) { return "TAG_Long" ; } else if ( clazz . equals ( ShortTag . class ) ) { return "TAG_Short" ; } else if ( clazz . equals ( StringTag . class ) ) { return "TAG_String" ; } else if ( clazz . equals ( ListStringArrayTag . class ) ) { return "TAG_ListString_Array" ; } else if ( clazz . equals ( ListItemStackArrayTag . class ) ) { return "TAG_ListItemStack_Array" ; } else { throw new IllegalArgumentException ( "Invalid tag classs (" + clazz . getName ( ) + ")." ) ; } }
tr	2	protected void markCreatedNode ( Node newNode ) { if ( ! ( newNode instanceof ObjectNode ) ) return ; if ( ! containsAncestor ( createdNodes , newNode ) ) { Node . createdNodes . add ( newNode ) ; } }
tr	9	public void viterbi ( ) { int t = 0 ; HashMap < String , Node > ppaths = new HashMap < String , Node > ( ) ; for ( String state : states ) { ppaths . put ( state , new Node ( state , null , initial_probability . get ( state ) ) ) ; } for ( String e : observations ) { HashMap < String , Node > nppaths = new HashMap < String , Node > ( ) ; for ( String tostate : states ) { double myprob = 1d ; Node nn = new Node ( null , null , 0d ) ; for ( Node fromstate : ppaths . values ( ) ) { myprob = fromstate . probability ; double predict = transitionModel . get ( fromstate . state ) . get ( tostate ) ; double update = sensorModel . get ( tostate ) . get ( e ) ; if ( t == 0 ) predict = 1d ; double both = predict * update ; myprob *= both ; nn . updateMax ( tostate , fromstate , myprob ) ; if ( t == 0 ) nn . parent = null ; } nppaths . put ( tostate , nn ) ; } if ( t == 0 ) normalize ( nppaths ) ; System . out . println ( nppaths ) ; ppaths = nppaths ; t ++ ; } if ( t == observations . length ) { System . out . println ( "most probable sequence:" ) ; Node max = new Node ( null , null , 0d ) ; for ( String state : states ) { Node from = ppaths . get ( state ) ; max . updateMax ( from . state , from . parent , from . probability ) ; } System . out . println ( max ) ; } }
tr	4	public static void fileOpen ( ) { final FileReader fr = new FileReader ( ) ; fr . openFile ( ) ; if ( fr . getFile ( ) == null && ! fr . isScmFile ( ) ) return ; MainMethods . updateTreeView ( fr ) ; if ( fr . getFile ( ) != null ) { Thread fileParser = new Thread ( new Runnable ( ) { public void run ( ) { ChannelList channelList = fr . parseFile ( ) ; if ( channelList != null ) { MainMethods . updateChannelTable ( channelList ) ; } else System . out . println ( "Chlist is null" ) ; } } ) ; fileParser . start ( ) ; } MainMethods . openFile = fr ; }
tr	5	@ Override public Map < Object , double > calculateProbabilityForClassifications ( double [ ] x ) { Map < Object , double > probs = new HashMap < Object , double > ( ) ; for ( int i = 0 ; i < x . length ; i ++ ) { for ( Object c : this . classCount . keySet ( ) ) { double prob = this . probability ( x [ i ] , c , i ) ; if ( ! probs . containsKey ( c ) ) probs . put ( c , prob ) ; else probs . put ( c , probs . get ( c ) + prob ) ; } } for ( int i = 0 ; i < x . length ; i ++ ) { for ( Object o : probs . keySet ( ) ) { double estimatedProb = this . ke . get ( o ) . get ( i ) . probability ( x [ i ] ) ; probs . put ( o , estimatedProb * probs . get ( o ) ) ; } } Utils . percentify ( probs ) ; return probs ; }
tr	1	public int getKills ( String progress ) { if ( ! isValid ( progress ) ) throw new IllegalArgumentException ( "progress is not valid" ) ; return Integer . parseInt ( progress . split ( " " ) [ 0 ] ) ; }
tr	4	public void minHeapify ( int index ) { for ( int left = leftChild ( index ) ; left < heap . size ( ) ; index = left ) { if ( left + 1 < heap . size ( ) && heap . get ( left + 1 ) . key < heap . get ( left ) . key ) { left ++ ; } if ( heap . get ( left ) . key < heap . get ( index ) . key ) { swap ( left , index ) ; } else { break ; } } }
tr	6	private void updateDisplay ( final XMLHandler h ) { SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { String req = h . getRequestType ( ) ; if ( req . equals ( Globals . requestStatus ) ) { StatusApp . statusUI . tabStatus . setControllerInformation ( h . getRa ( ) ) ; } else if ( req . startsWith ( Globals . requestDateTime ) ) { if ( writeValue ) { StatusApp . statusUI . tabCommands . setDateTimeText ( h . getDateTimeUpdateStatus ( ) ) ; } else { StatusApp . statusUI . tabCommands . setDateTimeText ( h . getDateTime ( ) ) ; } } else if ( req . equals ( Globals . requestVersion ) ) { StatusApp . statusUI . tabCommands . setVersionText ( h . getVersion ( ) ) ; } else if ( req . startsWith ( Globals . requestMemoryByte . substring ( 0 , 2 ) ) ) { if ( writeValue ) { StatusApp . statusUI . tabMemory . setWriteStatus ( h . getMemoryResponse ( ) ) ; } else { StatusApp . statusUI . tabMemory . setReadValue ( h . getMemoryResponse ( ) ) ; } } } } ) ; }
tr	0	public UnidadHerida ( Integer saludMaxima ) { this . establecerSaludMaxima ( saludMaxima ) ; this . recibirGolpe ( saludMaxima / 2 ) ; }
