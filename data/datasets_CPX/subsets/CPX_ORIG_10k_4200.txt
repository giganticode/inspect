tr	4	public void actionPerformed ( ActionEvent e ) { String login = principal . getLogin ( ) ; String senha = principal . getSenha ( ) ; LoginInterface loginInterface = new LoginInterface ( ) ; Funcionario funcionario = null ; try { funcionario = loginInterface . logarUsuario ( login , senha ) ; } catch ( SQLException ex ) { Logger . getLogger ( ButtonHandlerLogin . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } String respostaUsuario = "" ; if ( funcionario != null ) { if ( funcionario . getNivelAcesso ( ) ) { try { UsuarioLogado usuarioLogado = UsuarioLogado . getInstancia ( ) ; usuarioLogado . setUsuarioLogado ( funcionario ) ; OperacaoLog log = new OperacaoLog ( ) ; log . setData ( new Timestamp ( System . currentTimeMillis ( ) ) ) ; log . setDescricao ( "Logon de Administrador: " + funcionario . getNome ( ) ) ; log . setFuncionario ( UsuarioLogado . getInstancia ( ) . getUsuarioLogado ( ) ) ; log . setOperacao ( "Logon de Administrador" ) ; OperacaoLogDao operacaoLogDao = new OperacaoLogDao ( ) ; operacaoLogDao . persiste ( log ) ; } catch ( SQLException ex ) { Logger . getLogger ( ButtonHandlerLogin . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } principal . dispose ( ) ; Administrador . main ( null ) ; } else { respostaUsuario = "Erro  acesso n\u00E3o permitido!" ; JOptionPane . showMessageDialog ( null , respostaUsuario ) ; } } else { respostaUsuario = "Erro  Credenciais inv\u00E1lidas!" ; JOptionPane . showMessageDialog ( null , respostaUsuario ) ; } e . getActionCommand ( ) ; }
tr	3	@ Override public void setLength ( int length ) { if ( isEnd && this . length > length ) { isEnd = false ; findEnd ( ) ; } this . length = length ; if ( start + length > totalLength ) { totalLength = start + length ; isEnd = true ; } }
tr	2	private String message ( String token ) { StringBuffer sb = new StringBuffer ( ) ; sb . append ( "No method " ) ; sb . append ( token ) ; sb . append ( ( ) ; for ( int i = 0 ; i < nargs ; i ++ ) { if ( i > 0 ) sb . append (   ) ; sb . append ( argClass [ i ] . getName ( ) ) ; } sb . append ( ") found in class " ) ; sb . append ( c . getName ( ) ) ; return sb . toString ( ) ; }
tr	9	@ Override public void run ( ) { listener . started ( ) ; try { for ( String s : cmd ) System . out . print ( s + " " ) ; System . out . println ( ) ; downloader = Runtime . getRuntime ( ) . exec ( cmd ) ; BufferedReader reader = new BufferedReader ( new InputStreamReader ( downloader . getErrorStream ( ) ) ) ; String line = reader . readLine ( ) ; while ( line != null ) { line = line . trim ( ) ; if ( line . length ( ) > 0 ) { listener . update ( line ) ; if ( line . startsWith ( "INFO:" ) ) { System . out . println ( line ) ; int i = line . indexOf ( "filesize" ) ; if ( i >= 0 ) { int size = Integer . parseInt ( line . substring ( i + 8 ) . trim ( ) ) ; listener . updateSize ( size ) ; break ; } } else break ; } line = reader . readLine ( ) ; } while ( line != null ) { line = line . trim ( ) ; if ( line . length ( ) > 0 ) listener . update ( line ) ; line = reader . readLine ( ) ; } int c = downloader . waitFor ( ) ; downloader = null ; if ( c != 0 ) { listener . incomplete ( line + " {" + c + "}" ) ; } else { listener . finished ( ) ; } } catch ( InterruptedException | IOException | NumberFormatException ex ) { if ( downloading ) listener . incomplete ( ex . getMessage ( ) ) ; else listener . incomplete ( "Cancelled" ) ; Logger . getLogger ( RTMPTool . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } synchronized ( this ) { downloading = false ; } }
tr	3	synchronized public boolean removePlayer ( String ip , int port ) { for ( int i = 0 ; i < playersArr . length ; i ++ ) { if ( ( playersArr [ i ] != null ) && ( playersArr [ i ] . matches ( ip , port ) ) ) { numOfPlayers -- ; playersArr [ i ] = null ; return true ; } } return false ; }
tr	7	private String convertContinentToName ( String continent ) { switch ( continent ) { case "AF" : return "Africa" ; case "AS" : return "Asia" ; case "NA" : return "North America" ; case "SA" : return "South America" ; case "OC" : return "Oceania" ; case "AN" : return "Antarctica" ; case "EU" : return "Europe" ; default : return continent ; } }
tr	5	@ Override public String toString ( ) { switch ( this ) { case uneEtoile : return "\u2605" ; case deuxEtoiles : return "\u2605\u2605" ; case troisEtoiles : return "\u2605\u2605\u2605" ; case quatreEtoiles : return "\u2605\u2605\u2605\u2605" ; case cinqEtoiles : return "\u2605\u2605\u2605\u2605\u2605" ; } return null ; }
tr	0	public int getTick ( ) { return tick ; }
tr	4	public List < String > getFilesAdded ( String commitID ) { try { LinkedList < String > files = new LinkedList < String > ( ) ; String sql = "SELECT file_id  diff_type FROM file_diffs " + "WHERE new_commit_id=?" ; ISetter [ ] params = { new StringSetter ( 1 , commitID ) } ; PreparedStatementExecutionItem ei = new PreparedStatementExecutionItem ( sql , params ) ; addExecutionItem ( ei ) ; ei . waitUntilExecuted ( ) ; ResultSet rs = ei . getResult ( ) ; while ( rs . next ( ) ) { if ( rs . getString ( "diff_type" ) . equals ( "DIFF_ADD" ) && ! files . contains ( rs . getString ( "file_id" ) ) ) files . add ( rs . getString ( "file_id" ) ) ; } return files ; } catch ( SQLException e ) { e . printStackTrace ( ) ; return null ; } }
tr	8	public final float getPixelUnitFactor ( boolean isHor ) { switch ( PlatformDefaults . getLogicalPixelBase ( ) ) { case PlatformDefaults . BASE_FONT_SIZE : Font font = c . getFont ( ) ; FontMetrics fm = c . getFontMetrics ( font != null ? font : SUBST_FONT ) ; Point . float p = FM_MAP . get ( fm ) ; if ( p == null ) { Rectangle2D r = fm . getStringBounds ( "X" , c . getGraphics ( ) ) ; p = new Point . float ( ( ( float ) r . getWidth ( ) ) / 6f , ( ( float ) r . getHeight ( ) ) / 13.27734375f ) ; FM_MAP . put ( fm , p ) ; } return isHor ? p . x : p . y ; case PlatformDefaults . BASE_SCALE_FACTOR : float s = isHor ? PlatformDefaults . getHorizontalScaleFactor ( ) : PlatformDefaults . getVerticalScaleFactor ( ) ; if ( s != null ) return s ; return ( isHor ? getHorizontalScreenDPI ( ) : getVerticalScreenDPI ( ) ) / ( float ) PlatformDefaults . getDefaultDPI ( ) ; default : return 1f ; } }
tr	2	public ArrayList < User > getFriends ( int id ) { DBConnection connection = DBConnection . sharedInstance ( ) ; ArrayList < User > users = new ArrayList < User > ( ) ; ResultSet rs = connection . performQuery ( " SELECT * FROM friends_join WHERE friend1ID = " + id ) ; try { while ( rs . next ( ) ) { User user = getUserFromID ( rs . getInt ( "friend2ID" ) ) ; users . add ( user ) ; } } catch ( SQLException e ) { e . printStackTrace ( ) ; } return users ; }
tr	5	private boolean complexStroke ( ChineseStroke p ) { boolean b = false ; if ( p . size ( ) >= 2 ) { for ( int i = 0 ; i < ( p . size ( ) - 2 ) ; i ++ ) { ChineseLine cl1 = new ChineseLine ( p . get ( i ) [ 0 ] , p . get ( i + 1 ) [ 0 ] , p . get ( i + 1 ) [ 1 ] , p . get ( i ) [ 1 ] ) ; ChineseLine cl2 = new ChineseLine ( p . get ( i + 1 ) [ 0 ] , p . get ( i + 2 ) [ 0 ] , p . get ( i + 2 ) [ 1 ] , p . get ( i + 1 ) [ 1 ] ) ; if ( Math . abs ( cl1 . totaldegrees - cl2 . totaldegrees ) > 70 && ( cl1 . totaldegrees > 80 || cl2 . totaldegrees > 80 ) ) { b = true ; } } } return b ; }
tr	3	MapCell getCell ( Position pos ) { Preconditions . checkArgument ( pos . getX ( ) < mapWidth && pos . getX ( ) >= 0 && pos . getY ( ) < mapHeight && pos . getY ( ) >= 0 ) ; return map [ pos . getX ( ) ] [ pos . getY ( ) ] ; }
tr	9	public PaymentDialog ( Member member , ClassType ct , String message , int flag ) { messageTextArea . setText ( message ) ; globalMember = member ; globalClassType = ct ; globalFlag = flag ; makePaymentButton = new JButton ( "Make Payment" ) ; makePaymentButton . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent arg0 ) { Common . makePayment ( paymentTypeList . getSelectedValue ( ) , globalMember , ( Date ) utilDateModel . getValue ( ) , getPaymentAmount ( ) ) ; updatePaymentStatus ( globalMember , globalClassType ) ; dispose ( ) ; new PaymentDialog ( globalMember , globalClassType , "Payment made for " + globalMember . getName ( ) + "\n of " + getPaymentAmount ( ) + " for " + paymentTypeList . getSelectedValue ( ) . getPaymentTypeName ( ) + "\n up to date: " + ( ( Date ) utilDateModel . getValue ( ) ) . toString ( ) , globalFlag ) ; } } ) ; makePaymentButton . setEnabled ( false ) ; exitButton = new JButton ( "Exit" ) ; exitButton . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { dispose ( ) ; if ( globalFlag == 0 ) new MemberCheckInInterface ( globalClassType ) ; } } ) ; BufferedImage tkdIcon = CommonUI . getTkdIcon ( ) ; BufferedImage skyIcon = CommonUI . getSkyIcon ( ) ; BufferedImage kickIcon = CommonUI . getKickIcon ( ) ; Image img = null ; switch ( ct ) { case TAEKWONDO : img = new ImageIcon ( tkdIcon ) . getImage ( ) ; break ; case SKYBOXING : img = new ImageIcon ( skyIcon ) . getImage ( ) ; break ; case KICKBOXING : img = new ImageIcon ( kickIcon ) . getImage ( ) ; break ; case OTHER : img = new ImageIcon ( tkdIcon ) . getImage ( ) ; default : img = new ImageIcon ( tkdIcon ) . getImage ( ) ; } setIconImage ( img ) ; this . setTitle ( "Enter Payment for " + member . getName ( ) ) ; utilDateModel . addChangeListener ( new ChangeListener ( ) { @ Override public void stateChanged ( ChangeEvent arg0 ) { System . out . println ( "DateModel changed" ) ; setDateSelected ( ) ; if ( paymentAmountSelected && dateSelected ) { makePaymentButton . setEnabled ( true ) ; } } } ) ; panel . add ( paymentToPanel , BorderLayout . CENTER ) ; paymentTypeList . setListData ( Common . getPaymentTypes ( ct ) . toArray ( new PaymentType [ 1 ] ) ) ; paymentTypeList . addListSelectionListener ( new ListSelectionListener ( ) { @ Override public void valueChanged ( ListSelectionEvent arg0 ) { JList < PaymentType > tempList = ( JList < PaymentType > ) arg0 . getSource ( ) ; PaymentType pt = tempList . getSelectedValue ( ) ; paymentAmountTextField . setText ( String . format ( "%9.2f" , pt . getPaymentAmount ( ) ) ) ; setPaymentAmountFieldSelected ( ) ; if ( paymentAmountSelected && dateSelected ) { makePaymentButton . setEnabled ( true ) ; } } } ) ; listPanel . add ( paymentTypeList ) ; panel . add ( listPanel , BorderLayout . WEST ) ; paymentAmountPanel . add ( paymentAmountLabel ) ; paymentAmountPanel . add ( paymentAmountTextField ) ; buttonPanel . add ( paymentAmountPanel , BorderLayout . NORTH ) ; buttonPanel . add ( makePaymentButton , BorderLayout . WEST ) ; buttonPanel . add ( exitButton , BorderLayout . SOUTH ) ; panel . add ( buttonPanel , BorderLayout . SOUTH ) ; paymentStatusPanel . add ( paymentStatusTextArea , BorderLayout . NORTH ) ; paymentStatusPanel . add ( messageTextArea , BorderLayout . SOUTH ) ; updatePaymentStatus ( member , ct ) ; panel . add ( paymentStatusPanel , BorderLayout . EAST ) ; this . getContentPane ( ) . add ( panel ) ; this . setSize ( CommonUI . FULLSCREEN ) ; this . setVisible ( true ) ; }
tr	1	public MainMenuView ( Checkmate c ) { super ( c ) ; JLabel titleLabel = new JLabel ( "Checkmate 3000 Network AI Edition" ) ; titleLabel . setForeground ( Color . WHITE ) ; titleLabel . setFont ( new Font ( Font . SANS_SERIF , Font . PLAIN , 42 ) ) ; titleLabel . setSize ( 680 , 50 ) ; titleLabel . setLocation ( c . getWidth ( ) / 2 - titleLabel . getWidth ( ) / 2 , ( int ) ( c . getHeight ( ) * 0.200 ) ) ; add ( titleLabel ) ; JButton localButton = new JButton ( "Local Game" ) ; localButton . setSize ( 150 , 35 ) ; localButton . setLocation ( c . getWidth ( ) / 2 - localButton . getWidth ( ) / 2 , ( int ) ( c . getHeight ( ) * 0.480 ) ) ; localButton . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent ae ) { myCheckmate . setView ( Checkmate . LOCAL ) ; } } ) ; add ( localButton ) ; JButton hostButton = new JButton ( "Host Game" ) ; hostButton . setSize ( 150 , 35 ) ; hostButton . setLocation ( c . getWidth ( ) / 2 - hostButton . getWidth ( ) / 2 , ( int ) ( c . getHeight ( ) * 0.555 ) ) ; hostButton . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent ae ) { myCheckmate . setView ( Checkmate . HOST ) ; } } ) ; add ( hostButton ) ; JButton joinButton = new JButton ( "Join Game" ) ; joinButton . setSize ( 150 , 35 ) ; joinButton . setLocation ( c . getWidth ( ) / 2 - joinButton . getWidth ( ) / 2 , ( int ) ( c . getHeight ( ) * 0.630 ) ) ; joinButton . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent ae ) { myCheckmate . setView ( Checkmate . JOIN ) ; } } ) ; add ( joinButton ) ; JButton logButton = new JButton ( "View Logged Game" ) ; logButton . setSize ( 150 , 35 ) ; logButton . setLocation ( c . getWidth ( ) / 2 - logButton . getWidth ( ) / 2 , ( int ) ( c . getHeight ( ) * 0.705 ) ) ; logButton . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent ae ) { myCheckmate . setView ( Checkmate . LOG ) ; } } ) ; add ( logButton ) ; JButton quitButton = new JButton ( "Quit Game" ) ; quitButton . setSize ( 150 , 35 ) ; quitButton . setLocation ( c . getWidth ( ) / 2 - quitButton . getWidth ( ) / 2 , ( int ) ( c . getHeight ( ) * 0.780 ) ) ; quitButton . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent ae ) { int wantsExit = JOptionPane . showConfirmDialog ( myCheckmate , "Are you sure you want to exit the program?" , "Exit Program?" , JOptionPane . YES_NO_OPTION ) ; if ( wantsExit == JOptionPane . YES_OPTION ) { System . exit ( 0 ) ; } } } ) ; add ( quitButton ) ; }
tr	0	public static void sort ( Comparable [ ] array ) { }
tr	3	@ Override public ElapsedTimeInterval ping ( JSONObject header , String hostIP , int port , int timeout , int nTrials ) throws Exception { for ( int i = 0 ; i < nTrials ; i ++ ) { try { ElapsedTime . start ( "PingRPCTotal" ) ; doRcpPing ( header , hostIP , port , timeout ) ; ElapsedTime . stop ( "PingRPCTotal" ) ; } catch ( SocketTimeoutException e ) { ElapsedTime . abort ( "PingRPCTotal" ) ; System . out . println ( "PingRPCTotal timed out: " + e . getMessage ( ) ) ; } catch ( Exception e ) { ElapsedTime . abort ( "PingRPCTotal" ) ; System . out . println ( "PingRPCTotal Exception: " + e . getMessage ( ) ) ; } } return ElapsedTime . get ( "PingRPCTotal" ) ; }
tr	2	public Client ( InetAddress address , SharedTorrent torrent , boolean force , boolean disable ) throws UnknownHostException , IOException { this . torrent = torrent ; this . state = ClientState . WAITING ; this . disableObfuscation = disable ; if ( this . disableObfuscation ) { this . forceObfuscation = false ; this . id = ( Client . BITTORRENT_ID_PREFIX + UUID . randomUUID ( ) . toString ( ) . split ( "-" ) [ 4 ] ) . getBytes ( ) ; while ( Peer . isMagicPeerId ( this . id ) ) { this . id = ( Client . BITTORRENT_ID_PREFIX + UUID . randomUUID ( ) . toString ( ) . split ( "-" ) [ 4 ] ) . getBytes ( ) ; } } else { this . forceObfuscation = force ; this . id = Peer . generateMagicPeerId ( ) ; } this . hexId = Torrent . byteArrayToHexString ( this . id ) ; this . service = new ConnectionHandler ( this . torrent , this . id , address , this . forceObfuscation ) ; this . service . register ( this ) ; this . address = this . service . getSocketAddress ( ) ; this . announce = new Announce ( this . torrent , this . id , this . address ) ; this . announce . register ( this ) ; logger . info ( "BitTorrent client [" + this . hexId + " / " + Peer . isMagicPeerId ( this . id ) + "] for " + this . torrent . getName ( ) + " started and " + "listening at " + this . address . getAddress ( ) . getHostAddress ( ) + ":" + this . address . getPort ( ) + "..." ) ; this . peers = new ConcurrentHashMap < String , SharingPeer > ( ) ; this . connected = new ConcurrentHashMap < String , SharingPeer > ( ) ; this . random = new Random ( System . currentTimeMillis ( ) ) ; }
tr	9	private Set < Player > scanDiagonals ( Player [ ] [ ] board ) { HashSet < Player > winners = new HashSet < > ( ) ; int sameInRow = 0 ; int m = Board . NUM_ROWS ; int n = Board . NUM_COLUMNS ; for ( int slice = 0 ; slice < m + n - 1 ; ++ slice ) { Player previousPlayer = null ; sameInRow = 0 ; System . out . println ( String . format ( "Slice %d: " , slice ) ) ; int z1 = slice < n ? 0 : slice - n + 1 ; int z2 = slice < m ? 0 : slice - m + 1 ; for ( int j = slice - z2 ; j >= z1 ; -- j ) { Player currentPlayer = board [ slice - j ] [ j ] ; if ( currentPlayer != null ) { if ( currentPlayer == previousPlayer ) { sameInRow ++ ; System . out . println ( " (same as previous)" ) ; if ( sameInRow == 4 ) { winners . add ( currentPlayer ) ; } } else { sameInRow = 1 ; previousPlayer = currentPlayer ; } } else { sameInRow = 0 ; previousPlayer = null ; } System . out . println ( String . format ( "%d %d " , slice - j , j ) ) ; } System . out . println ( "\n" ) ; } for ( int slice = m + n - 1 ; slice > 0 ; -- slice ) { Player previousPlayer = null ; sameInRow = 0 ; System . out . println ( String . format ( "Slice %d: " , slice ) ) ; int z1 = slice < n ? 0 : slice - n + 1 ; int z2 = slice < m ? 0 : slice - m + 1 ; for ( int j = z1 ; j <= slice - z2 ; ++ j ) { Player currentPlayer = board [ slice - j ] [ m - j - 1 ] ; if ( currentPlayer != null ) { if ( currentPlayer == previousPlayer ) { sameInRow ++ ; System . out . println ( " (same as previous)" ) ; if ( sameInRow == 4 ) { winners . add ( currentPlayer ) ; } } else { sameInRow = 1 ; previousPlayer = currentPlayer ; } } else { sameInRow = 0 ; previousPlayer = null ; } System . out . println ( String . format ( "%d %d " , slice - j , j ) ) ; } System . out . println ( "\n" ) ; } return winners ; }
tr	2	public static int waysRunUp ( int n ) { if ( n < 0 ) { return 0 ; } else if ( n == 0 ) { return 1 ; } return waysRunUp ( n - 1 ) + waysRunUp ( n - 2 ) + waysRunUp ( n - 3 ) ; }
tr	7	private Point findSpawnLocation ( LayeredMap map ) { for ( int y = 3 ; y < map . getHeight ( ) ; y ++ ) { for ( int x = 3 ; x < map . getWidth ( ) ; x ++ ) { boolean ok = true ; for ( int j = 0 ; j < 4 ; j ++ ) { for ( int i = 0 ; i < 4 ; i ++ ) { int ground = map . get ( 0 , x + i , y + j ) & FFFF ; int feat = map . get ( 1 , x + i , y + j ) & FFFF ; if ( ground != . || feat != 0 ) { ok = false ; } } } if ( ok ) { return new Point ( x , y ) ; } } } return new Point ( 10 , 10 ) ; }
tr	8	public void setTriArrows ( CellElement current , boolean showNotChoosen ) { m_arrowList . clear ( ) ; int cCol , cRow ; cCol = current . getColumn ( ) ; cRow = current . getRow ( ) ; this . setGridCircle ( cCol , cRow ) ; if ( ( ( NussinovCellElement ) current ) . isEndCell ( ) ) { return ; } CellElement leftCell = this . getCell ( cCol - 1 , cRow ) ; CellElement bottomCell = this . getCell ( cCol , cRow + 1 ) ; CellElement bottomLeftCell = this . getCell ( cCol - 1 , cRow + 1 ) ; if ( current . isPointer ( leftCell ) ) { this . addArrow ( current , leftCell , Color . black ) ; } else { if ( showNotChoosen ) { this . addArrow ( current , leftCell , Color . lightGray ) ; } } if ( current . isPointer ( bottomCell ) ) { this . addArrow ( current , bottomCell , Color . black ) ; } else { if ( showNotChoosen ) { this . addArrow ( current , bottomCell , Color . lightGray ) ; } } if ( current . isPointer ( bottomLeftCell ) ) { this . addArrow ( current , bottomLeftCell , Color . black ) ; } else { if ( showNotChoosen ) { this . addArrow ( current , bottomLeftCell , Color . lightGray ) ; } } NCellPair cellPair ; ListIterator a = ( ( NussinovCellElement ) current ) . getBifPointers ( ) . listIterator ( ) ; while ( a . hasNext ( ) ) { cellPair = ( NCellPair ) a . next ( ) ; this . addArrow ( current , cellPair . getCellOne ( ) , Color . black ) ; this . addArrow ( current , cellPair . getCellTwo ( ) , Color . black ) ; } }
tr	1	synchronized public String getString ( ) { try { wait ( ) ; } catch ( InterruptedException e ) { } return napis ; }
tr	9	private void setAirtimes ( PrintWriter out , int day , int startHour , int endHour , int startMinute , int endMinute , String startValue , String endValue ) { if ( startValue . equals ( "PM" ) && startHour != 12 ) { startHour += 12 ; } if ( startValue . equals ( "AM" ) && startHour == 12 ) { startHour = 0 ; } if ( endValue . equals ( "PM" ) && endHour != 12 ) { endHour += 12 ; } if ( endValue . equals ( "AM" ) && endHour == 12 ) { endHour = 0 ; } int mins = 0 ; if ( endHour >= startHour ) { mins = ( ( endHour - startHour ) * 60 + endMinute ) - startMinute ; } else if ( endHour == 0 ) { mins = ( 24 - startHour ) * 60 + ( endMinute - startMinute ) ; } else { mins = endHour * 60 + endMinute + ( 24 - startHour ) * 60 - startMinute ; } out . println ( mins ) ; out . println ( "* " + startMinute + " " + startHour + " ? * " + day ) ; }
tr	2	private PreparedStatement addToBatch ( PreparedStatement statement ) throws SQLException { statement . addBatch ( ) ; if ( params != null ) { for ( ISetter s : params ) { s . set ( statement ) ; } } return statement ; }
tr	3	public static MarketBuilder getQuotes ( ResponseFormat format , String [ ] symbols , MarketQuotesResponseField [ ] fields ) { StringBuilder sb = new StringBuilder ( ) ; for ( String sym : symbols ) { sb . append ( sym + " " ) ; } StringBuilder fids = new StringBuilder ( ) ; for ( MarketQuotesResponseField f : fields ) { fids . append ( f . toString ( ) + " " ) ; } MarketBuilder b = new MarketBuilder ( Verb . POST ) ; b . params . put ( MarketQuotesField . SYMBOLS . toString ( ) , sb . toString ( ) . trim ( ) . replace ( " " , " " ) ) ; b . resourceURL = APICall . getQuote ( ResponseFormat . XML ) ; if ( ! fids . toString ( ) . isEmpty ( ) ) { b . params . put ( MarketQuotesField . FIDS . toString ( ) , fids . toString ( ) . trim ( ) . replace ( " " , " " ) ) ; } return b ; }
tr	3	public void setPop ( Population p ) { pop = p ; nCells = p . getGenomeLength ( ) / 2 ; popSize = p . getPopSize ( ) ; vertical = nCells > popSize ; int w = DEF_WIDTH , h = DEF_HEIGHT ; if ( vertical ) { int t = w ; w = h ; h = t ; } int w2 = w / nCells ; int h2 = h / popSize - 1 ; pixelSize = math . clamp ( Math . min ( w2 , h2 ) , 1 , 3 ) ; genSep = ( pixelSize > 1 ) ? 1 : 0 ; drawnCells = math . clamp ( w / pixelSize , 0 , nCells ) ; drawnPop = math . clamp ( h / ( pixelSize + genSep ) , 0 , popSize ) ; plotSize = vertical ? new Point ( drawnPop * ( pixelSize + genSep ) , drawnCells * pixelSize ) : new Point ( drawnCells * pixelSize , drawnPop * ( pixelSize + genSep ) ) ; }
tr	0	public void updatePositionWithStep ( int step ) { position = PositionUpdate . getCurrentPositionWithDistance ( position , step ) ; }
tr	5	public void run ( ) { try { while ( running ) { byte id = in . readByte ( ) ; Packet packet ; try { if ( ! ( PacketManager . containsID ( id ) ) ) { Logger . getLogger ( MinecraftProxyServerClient . class . getName ( ) ) . log ( Level . SEVERE , "Packet " + id + " doesn't exist!" ) ; continue ; } packet = PacketManager . read ( id , in ) ; packet . toServer = false ; String name = packet . toString ( ) ; that . log ( Level . INFO , "Server -> Client -> " + name ) ; } catch ( UnknownPacketException ex ) { Logger . getLogger ( MinecraftProxyServerClient . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; sock . close ( ) ; break ; } parent . handleIncoming ( packet ) ; } } catch ( EOFException e ) { } catch ( IOException e ) { } }
tr	6	public ScenarioTreeStepTwoOptions ( String name , ScenarioTreeStep first , String firstText , ScenarioTreeStep second , String secondText , String help ) { super ( name , help ) ; if ( first == null || second == null ) { throw new IllegalArgumentException ( "ScenarioTreeStepTwoOptions: Beide Schritte m\u00FCssen gesetzt sein!" ) ; } if ( firstText == null || firstText . trim ( ) . isEmpty ( ) || secondText == null || secondText == null ) { throw new IllegalArgumentException ( "ScenarioTreeStepTwoOptions: Beide Texte m\u00FCssen gesetzt und nicht leer sein!" ) ; } this . addFollowUpStep ( first , firstText ) ; this . addFollowUpStep ( second , secondText ) ; }
tr	5	protected int countNeighbours ( int col , int row ) { int c = 0 ; for ( int i = - 1 ; i < 2 ; i ++ ) { for ( int j = - 1 ; j < 2 ; j ++ ) { if ( ! ( i == 0 && j == 0 ) && getCell ( j + col , i + row ) ) { c ++ ; } } } return c ; }
tr	1	public static boolean isUnix ( ) { return isLinux ( ) || isMac ( ) ; }
tr	5	public void editar ( Categoria categoria ) throws NoExisteEntidadException , Exception { EntityManager em = null ; try { em = getEntityManager ( ) ; em . getTransaction ( ) . begin ( ) ; categoria = em . merge ( categoria ) ; em . getTransaction ( ) . commit ( ) ; } catch ( Exception ex ) { String msg = ex . getLocalizedMessage ( ) ; if ( msg == null || msg . length ( ) == 0 ) { long id = categoria . getId ( ) ; if ( encontrarCategoria ( id ) == null ) { throw new NoExisteEntidadException ( "No existe el categoria con id " + id ) ; } } throw ex ; } finally { if ( em != null ) { em . close ( ) ; } } }
tr	4	public void repairGeneTree ( Abaddon abaddon ) { while ( ! uncheckedGenes . isEmpty ( ) ) { GeneTrait currentGene = uncheckedGenes . remove ( 0 ) ; if ( currentGene instanceof ParentTrait ) { ParentTrait currentParent = ( ParentTrait ) currentGene ; for ( int i = 0 ; i < currentParent . getChildCount ( ) ; i ++ ) { GeneTrait currentChild = currentParent . getChild ( i ) ; if ( ! genes . contains ( currentChild ) ) { abaddon . growChild ( this , currentParent , i ) ; } } } } }
tr	0	public void setBankSwiftNo ( String bankSwiftNo ) { this . bankSwiftNo = bankSwiftNo ; }
tr	2	@ Override public String toString ( ) { StringBuffer tempSpot = new StringBuffer ( "" ) ; for ( int counter = 1 , maxCounter = getPathCount ( ) ; counter < maxCounter ; counter ++ ) { if ( counter > 1 ) tempSpot . append ( File . separator ) ; tempSpot . append ( getPathComponent ( counter ) ) ; } return tempSpot . toString ( ) ; }
tr	8	public static void main ( String [ ] args ) { if ( args . length < 1 ) { System . err . println ( "Usage: newsgroups newsserver [pattern]" ) ; return ; } NNTPClient client = new NNTPClient ( ) ; String pattern = args . length >= 2 ? args [ 1 ] : "" ; try { client . connect ( args [ 0 ] ) ; int j = 0 ; try { for ( String s : client . iterateNewsgroupListing ( pattern ) ) { j ++ ; System . out . println ( s ) ; } } catch ( IOException e1 ) { e1 . printStackTrace ( ) ; } System . out . println ( j ) ; j = 0 ; for ( NewsgroupInfo n : client . iterateNewsgroups ( pattern ) ) { j ++ ; System . out . println ( n . getNewsgroup ( ) ) ; } System . out . println ( j ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } finally { try { if ( client . isConnected ( ) ) { client . disconnect ( ) ; } } catch ( IOException e ) { System . err . println ( "Error disconnecting from server." ) ; e . printStackTrace ( ) ; System . exit ( 1 ) ; } } }
tr	4	public static boolean setLocked ( final boolean locked ) { if ( isLocked ( ) == locked ) return true ; if ( ! setExpanded ( true ) ) return false ; WidgetChild tc = getLockButton ( ) ; return tc . visible ( ) && tc . click ( true ) && new TimedCondition ( 1500 ) { @ Override public boolean isDone ( ) { return isLocked ( ) == locked ; } } . waitStop ( ) ; }
tr	3	@ Override public HandshakeState acceptHandshakeAsClient ( Handshakedata request , Handshakedata response ) throws Exception { if ( ! request . hasFieldValue ( "Sec-WebSocket-Key" ) || ! response . hasFieldValue ( "Sec-WebSocket-Accept" ) ) return HandshakeState . NOT_MATCHED ; String seckey_answere = response . getFieldValue ( "Sec-WebSocket-Accept" ) ; String seckey_challenge = request . getFieldValue ( "Sec-WebSocket-Key" ) ; seckey_challenge = generateFinalKey ( seckey_challenge ) ; if ( seckey_challenge . equals ( seckey_answere ) ) return HandshakeState . MATCHED ; return HandshakeState . NOT_MATCHED ; }
tr	6	public static String truncateWhenUTF8 ( final String s , final int maxBytes ) { int b = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { final char c = s . charAt ( i ) ; int skip = 0 ; int more ; if ( c <= 007f ) { more = 1 ; } else if ( c <= 07FF ) { more = 2 ; } else if ( c <= d7ff ) { more = 3 ; } else if ( c <= DFFF ) { more = 4 ; skip = 1 ; } else { more = 3 ; } if ( b + more > maxBytes ) { return s . substring ( 0 , i ) ; } b += more ; i += skip ; } return s ; }
tr	1	public static void main ( String [ ] args ) throws IOException , InterruptedException { Webcam webcam = Webcam . getDefault ( ) ; webcam . setViewSize ( new Dimension ( 640 , 480 ) ) ; webcam . open ( ) ; JFrame troll = new JFrame ( ) ; JLabel boy = new JLabel ( ) ; troll . add ( boy ) ; boy . setPreferredSize ( new Dimension ( 640 , 480 ) ) ; troll . pack ( ) ; troll . setResizable ( false ) ; troll . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; troll . setVisible ( true ) ; while ( true ) { boy . setIcon ( new ImageIcon ( webcam . getImage ( ) ) ) ; } }
tr	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( Renomear . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( Renomear . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( Renomear . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( Renomear . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { Renomear dialog = new Renomear ( new javax . swing . JFrame ( ) , true ) ; dialog . addWindowListener ( new java . awt . event . WindowAdapter ( ) { @ Override public void windowClosing ( java . awt . event . WindowEvent e ) { System . exit ( 0 ) ; } } ) ; dialog . setVisible ( true ) ; } } ) ; }
tr	8	public String convert ( String s , int numRows ) { if ( s . isEmpty ( ) ) { return "" ; } if ( s . length ( ) <= numRows ) { return s ; } if ( numRows == 1 ) { return s ; } StringBuilder sb = new StringBuilder ( s . length ( ) ) ; for ( int i = 0 ; i < numRows ; i ++ ) { int j = i ; while ( j < s . length ( ) ) { sb . append ( s . charAt ( j ) ) ; int nextJ = j + numRows + ( numRows - 2 ) ; int mid = nextJ - ( i + 1 ) - ( i - 1 ) ; if ( mid < s . length ( ) && mid > j && mid < nextJ ) { sb . append ( s . charAt ( mid ) ) ; } j = nextJ ; } } return sb . toString ( ) ; }
tr	6	public void initializeFromReference ( ) { for ( int i = 0 ; i < reference . getInts ( ) . size ( ) ; i ++ ) addIntForKey ( 0 , reference . getInts ( ) . get ( i ) ) ; for ( int i = 0 ; i < reference . getDoubles ( ) . size ( ) ; i ++ ) addDoubleForKey ( 0.0 , reference . getDoubles ( ) . get ( i ) ) ; for ( int i = 0 ; i < reference . getBooleans ( ) . size ( ) ; i ++ ) addBooleanForKey ( false , reference . getBooleans ( ) . get ( i ) ) ; for ( int i = 0 ; i < reference . getBytes ( ) . size ( ) ; i ++ ) addByteForKey ( ( byte ) 0 , reference . getBytes ( ) . get ( i ) ) ; for ( int i = 0 ; i < reference . getStrings ( ) . size ( ) ; i ++ ) addStringForKey ( "" , reference . getBytes ( ) . get ( i ) ) ; for ( int i = 0 ; i < reference . getColors ( ) . size ( ) ; i ++ ) addColorForKey ( Color . black , reference . getColors ( ) . get ( i ) ) ; }
tr	8	public void unobfuscateProject ( ) { String obfuscatedContent ; int totalSizeTransfert = 0 ; int numberOfFiles = 0 ; int fileSizeTransfert ; createDestinationDirectories ( ) ; List < File > codeFiles = new ArrayList < File > ( ) ; for ( File file : projectFiles ) { String fileExtension = McbcFileUtils . getFilenameExtension ( file . getName ( ) ) ; if ( Constants . PHP_EXTENSION_TABLE . contains ( fileExtension ) || fileExtension . equals ( Constants . JAVA_FILE_EXTENSION ) ) { codeFiles . add ( file ) ; } } for ( FileObfuscationStructure structure : projectFileObfuscationStructureList ) { File obfuscatedFile = new File ( destinationDir + "\\" + structure . getFileName ( ) ) ; obfuscatedContent = handler . replaceVariables ( structure , commentRemover , whiteSpacesRemover ) ; fileSizeTransfert = McbcFileUtils . putFileContent ( obfuscatedFile , obfuscatedContent ) ; totalSizeTransfert += fileSizeTransfert ; numberOfFiles ++ ; } if ( ! copyOnlySource ) { for ( File file : projectFiles ) { String fileExtension = McbcFileUtils . getFilenameExtension ( file . getName ( ) ) ; if ( ! Constants . PHP_EXTENSION_TABLE . contains ( fileExtension ) && file . isFile ( ) ) { File newFile = new File ( destinationDir + "\\" + file . getAbsolutePath ( ) . substring ( sourceDir . length ( ) ) ) ; fileSizeTransfert = McbcFileUtils . copyFile ( file , newFile ) ; numberOfFiles ++ ; totalSizeTransfert += fileSizeTransfert ; } } } }
tr	3	public BattleshipServer ( int port , GameManager manager ) { if ( manager == null || port < 0 ) throw new IllegalArgumentException ( ) ; this . manager = manager ; try { socket = new ServerSocket ( port ) ; this . start ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }
tr	7	@ Override public void actionPerformed ( ActionEvent e ) { if ( e . getSource ( ) . equals ( back ) ) { Window . current . toPane ( Window . current . menuPane ) ; } else if ( e . getSource ( ) . equals ( soundToggle ) ) { SettingsManager . put ( "sound" , new boolean ( soundToggle . getText ( ) . equals ( "Off" ) ) . toString ( ) ) ; soundToggle . setText ( soundToggle . getText ( ) . equals ( "Off" ) ? "On" : "Off" ) ; } else if ( e . getSource ( ) . equals ( fsToggle ) ) { SettingsManager . put ( "fullscreen" , new boolean ( fsToggle . getText ( ) . equals ( "Off" ) ) . toString ( ) ) ; fsToggle . setText ( fsToggle . getText ( ) . equals ( "Off" ) ? "On" : "Off" ) ; Window . current . setFullscreen ( SettingsManager . get ( "fullscreen" ) . equals ( "true" ) ) ; } else if ( e . getSource ( ) . equals ( beginToggle ) ) { SettingsManager . put ( "beginner" , new boolean ( beginToggle . getText ( ) . equals ( "Off" ) ) . toString ( ) ) ; beginToggle . setText ( beginToggle . getText ( ) . equals ( "Off" ) ? "On" : "Off" ) ; } }
tr	8	private void findShows ( String doc ) { String durBegin = "<span class=\"time\">&nbsp;" ; String durFinish = "&nbsp;" ; String linkBegin = "<a class=\"title\" href=\"" ; String linkFinish = "\">" ; String nameFinish = "</a>" ; int i = doc . indexOf ( durBegin ) ; while ( i > 0 ) { int durStart = i + durBegin . length ( ) ; int durEnd = doc . indexOf ( durFinish , durStart ) ; if ( durEnd < 0 ) break ; String duration = doc . substring ( durStart , durEnd ) ; i = doc . indexOf ( linkBegin , durEnd + durFinish . length ( ) ) ; if ( i < 0 ) break ; int linkStart = i + linkBegin . length ( ) ; int linkEnd = doc . indexOf ( linkFinish , linkStart ) ; if ( linkEnd < 0 ) break ; String page = ZebraList . site + doc . substring ( linkStart , linkEnd ) ; int nameStart = linkEnd + linkFinish . length ( ) ; int nameEnd = doc . indexOf ( nameFinish , nameStart ) ; if ( nameEnd < 0 ) break ; String name = doc . substring ( nameStart , nameEnd ) ; if ( ! ids . contains ( page ) ) { add ( new Show ( model , name + " " + duration , page , web . getCookie ( ) ) ) ; ids . add ( page ) ; } i = doc . indexOf ( durBegin , nameEnd + nameFinish . length ( ) ) ; } if ( defaultUrl . equals ( url ) && ! extra ) { extra = true ; add ( new Channel ( model , "Populiariausi" , link , web . getCookie ( ) , "http://zebra.15min.lt/lt/video/kanalai//populiariausi" ) ) ; add ( new Channel ( model , "Geriausi" , link , web . getCookie ( ) , "http://zebra.15min.lt/lt/video/kanalai//geriausi" ) ) ; } }
tr	5	@ Override public double [ ] GetDiscreteFunction ( double [ ] x , double [ ] paramsMF ) { if ( this . paramsMF . length == paramsMF . length ) this . paramsMF = paramsMF ; else return null ; int n = x . length ; double [ ] func = new double [ n ] ; double a = paramsMF [ 0 ] , b = paramsMF [ 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( x [ i ] < a ) { func [ i ] = 1.0 ; } else if ( x [ i ] < ( a + b ) / 2.0 ) { func [ i ] = 1 - 2.0 * Math . pow ( ( x [ i ] - a ) / ( b - a ) , 2 ) ; } else if ( x [ i ] < b ) { func [ i ] = 2.0 * Math . pow ( ( x [ i ] - b ) / ( b - a ) , 2 ) ; } else func [ i ] = 0.0 ; } return func ; }
tr	3	private void initComponents ( ) { JPanel input = new JPanel ( ) ; input . setLayout ( new FlowLayout ( FlowLayout . CENTER ) ) ; JLabel yearLabel = new JLabel ( "Year: " ) ; input . add ( yearLabel ) ; final JTextField yearField = new JTextField ( ) ; input . add ( yearField ) ; yearField . setPreferredSize ( new Dimension ( TEXT_BOX_WIDTH , TEXT_BOX_HEIGHT ) ) ; JLabel numLabel = new JLabel ( "Top number of books: " ) ; input . add ( numLabel ) ; final JTextField numField = new JTextField ( ) ; input . add ( numField ) ; numField . setPreferredSize ( new Dimension ( TEXT_BOX_WIDTH , TEXT_BOX_HEIGHT ) ) ; JButton searchButton = new JButton ( ) ; input . add ( searchButton ) ; searchButton . setText ( "Generate Report" ) ; this . add ( input ) ; final JPanel listViewer = new JPanel ( ) ; final DefaultTableModel books = new DefaultTableModel ( ) ; books . addColumn ( "Call Number" ) ; books . addColumn ( "ISBN" ) ; books . addColumn ( "Title" ) ; books . addColumn ( "Main Author" ) ; books . addColumn ( "Publisher" ) ; books . addColumn ( "Year" ) ; books . addColumn ( "Borrowed Count" ) ; JTable items = new JTable ( books ) ; items . getColumn ( "Title" ) . setPreferredWidth ( 100 ) ; items . getColumn ( "Borrowed Count" ) . setPreferredWidth ( 100 ) ; items . setEnabled ( false ) ; items . setAutoCreateRowSorter ( false ) ; items . setSelectionMode ( ListSelectionModel . MULTIPLE_INTERVAL_SELECTION ) ; items . setSize ( new Dimension ( 250 , 200 ) ) ; JScrollPane listScroller = new JScrollPane ( items ) ; listScroller . setPreferredSize ( new Dimension ( 600 , 300 ) ) ; listViewer . add ( listScroller ) ; this . add ( listViewer ) ; searchButton . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent arg0 ) { try { int searchParameters = Integer . parseInt ( numField . getText ( ) ) ; Integer . parseInt ( yearField . getText ( ) ) ; if ( yearField . getText ( ) . length ( ) != 4 ) { new NotificationDialog ( null , "ERROR" , "Please ensure the year is entered in a YYYY format." ) ; return ; } books . setRowCount ( 0 ) ; String searchTerms = yearField . getText ( ) . toString ( ) ; Vector < Object [ ] > books2 = MainLibrary . databaseHandler . getBooks ( searchTerms , searchParameters , DatabaseHandler . MOST_POPULAR_REPORT ) ; for ( int j = 0 ; j < books2 . size ( ) ; j ++ ) { books . addRow ( books2 . get ( j ) ) ; } return ; } catch ( NumberFormatException e ) { new NotificationDialog ( null , "ERROR" , "The year field and number field requires only numbers to be entered." ) ; } } } ) ; }
tr	2	public Color getRandomColor ( int minColor , int maxColor , Map colors , int threshold , Random rand ) { int rNum = maxColor - minColor ; int index = rand . nextInt ( rNum ) + minColor ; Color color = ( Color ) colors . get ( new Integer ( index ) ) ; int revenue = color . getRevenue ( ) ; boolean colorSurveyed = wasSurveyed ( color ) ; while ( revenue > threshold || colorSurveyed ) { index = rand . nextInt ( rNum ) + minColor ; color = ( Color ) colors . get ( new Integer ( index ) ) ; colorSurveyed = wasSurveyed ( color ) ; revenue = color . getRevenue ( ) ; } addSurveyedColor ( color ) ; return color ; }
tr	8	public void run ( ) { try { in = new BufferedReader ( new InputStreamReader ( socket . getInputStream ( ) ) ) ; output = new DataOutputStream ( socket . getOutputStream ( ) ) ; String line , path = root ; int method = 0 ; while ( ( line = in . readLine ( ) ) != null ) { String temp = line . toUpperCase ( ) ; if ( temp . startsWith ( "GET" ) ) { method = 1 ; String p = line . split ( " " ) [ 1 ] ; path = root + ( root . endsWith ( "/" ) ? p . substring ( 1 ) : p ) ; } else if ( temp . startsWith ( "HEAD" ) ) method = 2 ; if ( method == 0 ) { onError ( this , 501 ) ; return ; } File file = new File ( clean ( path ) ) ; String [ ] f = file . getName ( ) . split ( "\\." ) ; if ( ! file . exists ( ) ) { onError ( this , 404 ) ; return ; } if ( method == 1 ) { setHeader ( 200 , "." + f [ f . length - 1 ] ) ; writeFile ( file ) ; } return ; } } catch ( Exception ex ) { ex . printStackTrace ( ) ; } }
tr	2	private JPanel pnlCrear ( ) { lblNuevoId = new JLabel ( "Identificaci\u00F3n" ) ; lblNuevoNombre = new JLabel ( "Nombre" ) ; lblNuevoApellido = new JLabel ( "Apellido" ) ; lblNuevoTelefono = new JLabel ( "Tel\u00E9fono" ) ; lblNuevoParentesco = new JLabel ( "Parentesco" ) ; txtNuevoId = new JTextField ( ) ; txtNuevoNombre = new JTextField ( ) ; txtNuevoApellido = new JTextField ( ) ; txtNuevoTelefono = new JTextField ( ) ; txtNuevoParentesco = new JTextField ( ) ; btnNuevoElegir = new JButton ( "Elegir" ) ; btnNuevoElegir . addActionListener ( this ) ; switch ( tipo ) { case SELECCIONAR_DUENIO : btnNuevoElegir . setActionCommand ( ELEGIR_DUENIO_NUEVO ) ; break ; case SELECCIONAR_RESPONSABLE : btnNuevoElegir . setActionCommand ( ELEGIR_RESPONSABLE_NUEVO ) ; break ; } ImageIcon iconElegir = new ImageIcon ( getClass ( ) . getResource ( "/conjunto/views/icons/check.png" ) ) ; Image imgElegir = iconElegir . getImage ( ) . getScaledInstance ( - 1 , 22 , Image . SCALE_SMOOTH ) ; iconElegir . setImage ( imgElegir ) ; btnNuevoElegir . setIcon ( iconElegir ) ; Dimension cmps = new Dimension ( 180 , 27 ) ; lblNuevoId . setPreferredSize ( cmps ) ; lblNuevoNombre . setPreferredSize ( cmps ) ; lblNuevoApellido . setPreferredSize ( cmps ) ; lblNuevoTelefono . setPreferredSize ( cmps ) ; lblNuevoParentesco . setPreferredSize ( cmps ) ; txtNuevoId . setPreferredSize ( cmps ) ; txtNuevoNombre . setPreferredSize ( cmps ) ; txtNuevoApellido . setPreferredSize ( cmps ) ; txtNuevoTelefono . setPreferredSize ( cmps ) ; txtNuevoParentesco . setPreferredSize ( cmps ) ; btnNuevoElegir . setPreferredSize ( new Dimension ( 150 , 30 ) ) ; JPanel pnl = new JPanel ( new FlowLayout ( ) ) ; pnl . setBorder ( BorderFactory . createTitledBorder ( "Crear uno nuevo" ) ) ; pnl . setPreferredSize ( new Dimension ( 200 , - 1 ) ) ; pnl . add ( lblNuevoId ) ; pnl . add ( txtNuevoId ) ; pnl . add ( lblNuevoNombre ) ; pnl . add ( txtNuevoNombre ) ; pnl . add ( lblNuevoApellido ) ; pnl . add ( txtNuevoApellido ) ; pnl . add ( lblNuevoTelefono ) ; pnl . add ( txtNuevoTelefono ) ; pnl . add ( lblNuevoParentesco ) ; pnl . add ( txtNuevoParentesco ) ; pnl . add ( btnNuevoElegir ) ; return pnl ; }
tr	9	@ Override public ASTNode evaluate ( IExpressionContext context ) { switch ( getType ( ) ) { case OR : case AND : ASTNode leftChild = child ( 0 ) . evaluate ( context ) ; ASTNode rightChild = child ( 1 ) . evaluate ( context ) ; if ( leftChild != null && rightChild != null && leftChild . hasLiteralValue ( context ) && rightChild . hasLiteralValue ( context ) ) { switch ( getType ( ) ) { case OR : return toNode ( leftChild . getLiteralValue ( context ) | rightChild . getLiteralValue ( context ) ) ; case AND : return toNode ( leftChild . getLiteralValue ( context ) & rightChild . getLiteralValue ( context ) ) ; default : throw new RuntimeException ( "Unhandled type " + getType ( ) ) ; } } break ; case NOT : ASTNode value = child ( 0 ) . evaluate ( context ) ; if ( value != null && value . isLiteralValue ( ) ) { return value . getLiteralValue ( context ) ? new FalseNode ( ) : new TrueNode ( ) ; } break ; default : throw new RuntimeException ( "Unhandled type " + getType ( ) ) ; } return this ; }
tr	8	public void map ( Object key , Text value , Context context ) throws IOException , InterruptedException { Vector3d u01 = new Vector3d ( ) ; Vector3d diff02 = new Vector3d ( ) ; Vector3d nrml = new Vector3d ( ) ; Vector3d xprod = new Vector3d ( ) ; Vertex vtx0 = new Vertex ( ) ; Vertex vtx1 = new Vertex ( ) ; Vertex vtx2 = new Vertex ( ) ; double maxSqr = 0 ; Configuration conf = context . getConfiguration ( ) ; String [ ] u01S = conf . get ( "u01S" ) . split ( " " ) ; String [ ] vtx0S = conf . get ( "vtx0S" ) . split ( " " ) ; String [ ] vtx1S = conf . get ( "vtx1S" ) . split ( " " ) ; u01 . x = double . valueOf ( u01S [ 0 ] ) ; u01 . y = double . valueOf ( u01S [ 1 ] ) ; u01 . z = double . valueOf ( u01S [ 2 ] ) ; vtx0 . pnt . x = double . valueOf ( vtx0S [ 0 ] ) ; vtx0 . pnt . y = double . valueOf ( vtx0S [ 1 ] ) ; vtx0 . pnt . z = double . valueOf ( vtx0S [ 2 ] ) ; vtx1 . pnt . x = double . valueOf ( vtx1S [ 0 ] ) ; vtx1 . pnt . y = double . valueOf ( vtx1S [ 1 ] ) ; vtx1 . pnt . z = double . valueOf ( vtx1S [ 2 ] ) ; ArrayList < Vertex > PointsArr = new ArrayList < Vertex > ( ) ; String line = value . toString ( ) ; if ( line . length ( ) > 1 ) { String [ ] linesArr = line . split ( "\n" ) ; for ( int i = 0 ; i < linesArr . length ; i ++ ) { String [ ] S = linesArr [ i ] . split ( " " ) ; if ( S . length >= 3 ) { Vertex TVertex = new Vertex ( ) ; TVertex . pnt . x = double . valueOf ( S [ 0 ] ) ; TVertex . pnt . y = double . valueOf ( S [ 1 ] ) ; TVertex . pnt . z = double . valueOf ( S [ 2 ] ) ; PointsArr . add ( TVertex ) ; } } } if ( PointsArr . size ( ) > 1 ) { for ( int i = 0 ; i < PointsArr . size ( ) ; i ++ ) { diff02 . - ( PointsArr . get ( i ) . pnt , vtx0 . pnt ) ; xprod . cross ( u01 , diff02 ) ; double lenSqr = xprod . normSquared ( ) ; if ( lenSqr > maxSqr && PointsArr . get ( i ) != vtx0 && PointsArr . get ( i ) != vtx1 ) { maxSqr = lenSqr ; vtx2 = PointsArr . get ( i ) ; nrml . set ( xprod ) ; } } TKey . set ( "Reducer1" ) ; context . write ( TKey , new Text ( vtx2 . pnt . x + " " + vtx2 . pnt . y + " " + vtx2 . pnt . z ) ) ; } else { context . write ( TKey , new Text ( PointsArr . get ( 0 ) . pnt . toString ( ) ) ) ; } }
tr	0	@ Override public void handleEvent ( MatchEndedEvent domainEvent ) { PlayerReport playerReport = accountReportRepository . findById ( domainEvent . getAggregateId ( ) ) ; List < MatchReport > gamesStatistic = new ArrayList < MatchReport > ( ) ; gamesStatistic . addAll ( playerReport . getGamesStatistic ( ) ) ; gamesStatistic . add ( new MatchReport ( domainEvent . getAggregateId ( ) , domainEvent . getMatchResult ( ) ) ) ; accountReportRepository . add ( new PlayerReport ( domainEvent . getAggregateId ( ) , gamesStatistic , playerReport . getPlayerName ( ) ) ) ; }
tr	2	public int lastChannelNum ( ) { int highestNum = 0 ; for ( int i = this . channelArray . length - 1 ; i >= 0 ; i -- ) { if ( this . channelArray [ i ] != null ) { highestNum = i ; break ; } } return highestNum ; }
tr	1	private class < ? > findClass ( byte [ ] b ) throws ClassNotFoundException { return defineClass ( null , b , 0 , b . length ) ; }
tr	7	public static List < String > getPermutations2 ( String str ) { if ( str == null || str . isEmpty ( ) ) { return new ArrayList < > ( ) ; } List < String > permutations = new ArrayList < > ( ) ; if ( str . length ( ) == 1 ) { permutations . add ( str ) ; return permutations ; } for ( int i = 0 ; i < str . length ( ) ; i ++ ) { char c = str . charAt ( i ) ; String shorterString = str . substring ( 0 , i ) + ( ( i != str . length ( ) - 1 ) ? str . substring ( i + 1 , str . length ( ) ) : "" ) ; List < String > shorterPermutations = getPermutations2 ( shorterString ) ; for ( String s : shorterPermutations ) { for ( int j = 0 ; j < s . length ( ) ; j ++ ) { permutations . add ( s . substring ( 0 , j ) + c + s . substring ( j , s . length ( ) ) ) ; } } } return permutations ; }
tr	4	private void tryNext ( ) { if ( _indexI < _readings . size ( ) && _indexJ < _readings . size ( ) ) { _next = Tuples . pair ( _readings . get ( _indexI ) , _readings . get ( _indexJ ) ) ; _indexJ ++ ; if ( _indexJ >= _readings . size ( ) ) { _indexI ++ ; _indexJ = _includeReflexive ? _indexI : _indexI + 1 ; } } else { _next = null ; } }
tr	2	public static Kind find ( String lowerCase ) { for ( Kind k : Kind . values ( ) ) { if ( k . name . equalsIgnoreCase ( lowerCase ) ) { return k ; } } return null ; }
tr	8	public T resolve ( String name , Predicate < T > filter ) { name = name . trim ( ) ; T temp = map . get ( name ) ; if ( temp != null ) { return temp ; } name = name . toLowerCase ( ) ; while ( name . length ( ) > 0 ) { SortedMap < String , T > - = map . subMap ( name , name + "z" ) ; if ( - . isEmpty ( ) ) { break ; } Iterator < T > iter = - . values ( ) . iterator ( ) ; T first = null ; fail : { while ( iter . hasNext ( ) ) { T next = iter . next ( ) ; if ( ! filter . test ( next ) ) { continue ; } if ( first == null ) { first = next ; } else if ( first != next ) { break fail ; } } return first ; } if ( first == null ) { break ; } name = name . substring ( 0 , name . length ( ) - 1 ) ; } return null ; }
tr	9	public boolean stem ( ) { int v_1 ; int v_2 ; int v_3 ; int v_4 ; int v_5 ; v_1 = cursor ; lab0 : do { if ( ! r_mark_regions ( ) ) { break lab0 ; } } while ( false ) ; cursor = v_1 ; limit_backward = cursor ; cursor = limit ; v_2 = limit - cursor ; lab1 : do { if ( ! r_main_suffix ( ) ) { break lab1 ; } } while ( false ) ; cursor = limit - v_2 ; v_3 = limit - cursor ; lab2 : do { if ( ! r_consonant_pair ( ) ) { break lab2 ; } } while ( false ) ; cursor = limit - v_3 ; v_4 = limit - cursor ; lab3 : do { if ( ! r_other_suffix ( ) ) { break lab3 ; } } while ( false ) ; cursor = limit - v_4 ; v_5 = limit - cursor ; lab4 : do { if ( ! r_undouble ( ) ) { break lab4 ; } } while ( false ) ; cursor = limit - v_5 ; cursor = limit_backward ; return true ; }
tr	4	public boolean remove ( Object x ) { outprint += "boolean remove Object x\n" ; int h = x . hashCode ( ) ; if ( h < 0 ) { h = - h ; } h = h % buckets . length ; Node current = buckets [ h ] ; Node previous = null ; while ( current != null ) { if ( current . data . equals ( x ) ) { if ( previous == null ) { buckets [ h ] = current . next ; } else { previous . next = current . next ; } currentSize -- ; return true ; } previous = current ; current = current . next ; } return false ; }
tr	3	public void connect ( Tile t ) { if ( isStranded ( ) || isFullyConnected ( ) ) { throw new UnsupportedOperationException ( "Nowhere to connect" ) ; } if ( tile1 == null ) { tile1 = t ; } else { tile2 = t ; } }
tr	8	public static boolean isVisible ( int rowIndex , int columnIndex ) { rowIndex += 1 ; columnIndex += 1 ; if ( ( rowIndex > 9 ) && ( rowIndex < 13 ) ) { if ( ( columnIndex < 7 ) || ( columnIndex > 15 ) ) { return false ; } } if ( ( columnIndex > 9 ) && ( columnIndex < 13 ) ) { if ( ( rowIndex < 7 ) || ( rowIndex > 15 ) ) { return false ; } } return true ; }
tr	1	public int getRowCount ( ) { if ( datos == null ) System . out . println ( "Es nulo" ) ; return datos . size ( ) ; }
tr	3	public String getPinyinColorized ( ) { StringBuilder ankiPinyin = new StringBuilder ( ) ; String [ ] syllables = PinyinUtil . getSyllables ( pinyin ) ; int curTone ; for ( int i = 0 ; i < syllables . length ; i ++ ) { if ( i > 0 ) { ankiPinyin . append ( " " ) ; } curTone = getTone ( syllables [ i ] ) ; if ( curTone == 0 ) { ankiPinyin . append ( syllables [ i ] ) ; } else { ankiPinyin . append ( "<span style = \"color:" ) ; ankiPinyin . append ( toneColor [ curTone ] ) ; ankiPinyin . append ( "\">" ) ; ankiPinyin . append ( PinyinUtil . toUnicode ( syllables [ i ] ) ) ; ankiPinyin . append ( "</span>" ) ; } } return ankiPinyin . toString ( ) ; }
tr	4	private void newGame ( int mines , int height , int width ) { if ( mines < 0 || width < 0 || height < 0 ) throw new IllegalArgumentException ( ) ; if ( level == 1 ) { setGameTimer ( new GameTimer ( 120 ) ) ; } gameState = State . PLAYING ; setBoard ( new GameBoard ( mines , height , width ) ) ; this . setChanged ( ) ; this . notifyObservers ( ) ; }
tr	5	public static void main ( String [ ] args ) { List < Integer > primes = new LinkedList < Integer > ( ) ; primes . add ( 2 ) ; while ( primes . size ( ) < 10002 ) { for ( Integer i = primes . get ( primes . size ( ) - 1 ) + 1 ; ; i ++ ) { boolean flag = true ; for ( Integer r : primes ) { if ( i % r == 0 ) { flag = false ; } } if ( flag ) { primes . add ( i ) ; System . out . println ( i ) ; break ; } } } System . out . println ( "result" + primes . get ( 10000 ) ) ; }
tr	5	public void wc ( MainClass mc , Encounter e ) { int x = mc . getXPos ( ) ; int y = mc . getYPos ( ) ; int k = e . getKeyPress ( ) ; if ( x >= 300 && x <= 450 ) { if ( y >= 40 && y <= 140 ) { e . win = false ; MainClass . getPlayer ( ) . addXP ( e . m . calculateXP ( ) ) ; MainClass . getPlayer ( ) . addGold ( e . m . getGold ( ) ) ; MainClass . getPlayer ( ) . setCurrentHP ( e . p . getCurrentHP ( ) ) ; mc . getMapHandler ( ) . getTheMap ( ) . getTile ( e . m . getCurTileX ( ) , e . m . getCurTileY ( ) ) . clearChar1 ( ) ; mc . getMapHandler ( ) . checkXP = true ; mc . setScreen ( "Map" ) ; } } else if ( k == 10 ) { e . win = false ; e . setKeyPress ( 0 ) ; MainClass . getPlayer ( ) . addXP ( e . m . calculateXP ( ) ) ; MainClass . getPlayer ( ) . addGold ( e . m . getGold ( ) ) ; MainClass . getPlayer ( ) . setCurrentHP ( e . p . getCurrentHP ( ) ) ; mc . getMapHandler ( ) . getTheMap ( ) . getTile ( e . m . getCurTileX ( ) , e . m . getCurTileY ( ) ) . clearChar1 ( ) ; mc . getMapHandler ( ) . checkXP = true ; mc . setScreen ( "Map" ) ; } }
tr	4	public static void loadTexture ( BufferedImage image , int id ) { if ( image == null || id < 0 ) { return ; } int [ ] pixels = new int [ image . getWidth ( ) * image . getHeight ( ) ] ; image . getRGB ( 0 , 0 , image . getWidth ( ) , image . getHeight ( ) , pixels , 0 , image . getWidth ( ) ) ; ByteBuffer buffer = BufferUtils . createByteBuffer ( image . getWidth ( ) * image . getHeight ( ) * 4 ) ; for ( int y = 0 ; y < image . getHeight ( ) ; y ++ ) { for ( int x = 0 ; x < image . getWidth ( ) ; x ++ ) { int pixel = pixels [ y * image . getWidth ( ) + x ] ; buffer . put ( ( byte ) ( ( pixel >> 16 ) & FF ) ) ; buffer . put ( ( byte ) ( ( pixel >> 8 ) & FF ) ) ; buffer . put ( ( byte ) ( pixel & FF ) ) ; buffer . put ( ( byte ) ( ( pixel >> 24 ) & FF ) ) ; } } buffer . flip ( ) ; GL11 . glBindTexture ( GL11 . GL_TEXTURE_2D , id ) ; GL11 . glTexParameteri ( GL11 . GL_TEXTURE_2D , GL11 . GL_TEXTURE_WRAP_S , GL12 . GL_CLAMP_TO_EDGE ) ; GL11 . glTexParameteri ( GL11 . GL_TEXTURE_2D , GL11 . GL_TEXTURE_WRAP_T , GL12 . GL_CLAMP_TO_EDGE ) ; GL11 . glTexParameteri ( GL11 . GL_TEXTURE_2D , GL11 . GL_TEXTURE_MIN_FILTER , GL11 . GL_NEAREST ) ; GL11 . glTexParameteri ( GL11 . GL_TEXTURE_2D , GL11 . GL_TEXTURE_MAG_FILTER , GL11 . GL_NEAREST ) ; GL11 . glTexImage2D ( GL11 . GL_TEXTURE_2D , 0 , GL11 . GL_RGBA8 , image . getWidth ( ) , image . getHeight ( ) , 0 , GL11 . GL_RGBA , GL11 . GL_UNSIGNED_BYTE , buffer ) ; }
tr	7	@ Override protected void doReload ( ) { String doc = web . getDoc ( url , referer ) ; if ( doc == null ) { status = web . getStatus ( ) ; return ; } int count = 0 ; String link = web . findFirst ( linkBegin , linkEnd ) ; while ( link != null ) { web . skipLastPostfix ( ) ; link = urlPrefix + link ; String name = web . findNext ( ">" , "<" ) ; if ( name == null ) break ; web . skipLastPostfix ( ) ; if ( name . length ( ) > 0 ) { name = name . replaceAll ( "&nbsp;" , " " ) . trim ( ) ; if ( ! ids . contains ( link ) ) { add ( new Show ( model , name , link , url ) ) ; ids . add ( link ) ; count ++ ; } } link = web . findNext ( linkBegin , linkEnd ) ; } if ( count == 9 ) { int i = url . indexOf ( "page=" ) + 5 ; int j = url . indexOf ( & , i ) ; int page = Integer . parseInt ( url . substring ( i , j ) ) + 1 ; link = url . substring ( 0 , url . indexOf ( ? ) ) + "?page=" + page + "&orderBy=created" ; if ( ! ids . contains ( link ) ) { add ( new Category ( model , "Page " + page , link , url ) ) ; ids . add ( link ) ; } } status = null ; }
tr	0	@ Override public void excuteCommand ( ) { barbecuer . BakeMutton ( ) ; }
tr	5	public FileChain ( String path , boolean singleNode , File ... node ) throws FileException { super ( path ) ; this . singleNode = singleNode ; if ( singleNode ) { if ( node . length != 1 ) { throw FileException . NODE_AND_NODEARY_MISMATCH ; } pNodes = null ; pNode = node [ 0 ] ; } else { pNode = null ; pNodes = node ; } if ( pNodes != null ) { for ( int i = 0 ; i < pNodes . length ; i ++ ) { if ( this == pNodes [ i ] ) { thisIndex = i ; currentIndex = i ; } } } else { currentIndex = - 1 ; thisIndex = - 1 ; } }
tr	5	public ArrayList < Pair < double >> PrecisionRecall ( ) { ArrayList < Pair < double >> result = new ArrayList < Pair < double >> ( this . size ( ) ) ; Collections . sort ( this ) ; int total_pos = 0 ; for ( PredictionResult r : this ) { if ( r . label . isPositive ( ) ) total_pos ++ ; } int true_pos = 0 ; int total = 0 ; for ( PredictionResult r : this ) { total ++ ; if ( r . label . isPositive ( ) ) true_pos ++ ; result . add ( new Pair < double > ( ( double ) true_pos / total_pos , ( double ) true_pos / total ) ) ; if ( true_pos == total_pos ) break ; } return result ; }
tr	6	private String getIndexText ( int index , int colour ) { assert ( colour == PL_WHITE || colour == PL_BLACK ) ; assert ( index >= 0 && index <= 15 ) ; String result = "" ; result += col_text [ index % 8 ] ; if ( colour == PL_WHITE ) { result += ( index <= 7 ) ? "2" : "1" ; } if ( colour == PL_BLACK ) { result += ( index <= 7 ) ? "7" : "8" ; } return result ; }
tr	6	private static boolean checkCircularity ( Node node ) { Node firstPointer = node ; Node secondPointer = node != null ? node . getNext ( ) : null ; if ( firstPointer == null || secondPointer == null ) return false ; while ( firstPointer != null && secondPointer != null ) { if ( firstPointer . equals ( secondPointer ) ) return true ; firstPointer = firstPointer . getNext ( ) ; secondPointer = secondPointer . getNext ( ) . getNext ( ) ; } return false ; }
tr	0	public static void quadRectOutset ( Rect rect , double border , RGB fill , boolean inset ) { quadCoordOutset ( rect . getMin ( ) , rect . getMax ( ) , border , fill , inset ) ; }
tr	0	public Edge getEdge ( int index ) { return edges [ index ] ; }
tr	8	public void pondre ( ) { int naissances = 0 ; if ( this . getFourmiliere ( ) . getFecondite ( ) > 0 ) { naissances = new Random ( ) . nextInt ( this . getFourmiliere ( ) . getFecondite ( ) ) ; } if ( ConfigurationLoader . LIMIT_FOURMIS_NUMBER && this . getFourmiliere ( ) . getTotalFourmis ( ) + naissances >= this . getFourmiliere ( ) . getTaille_max ( ) ) { naissances = this . getFourmiliere ( ) . getTaille_max ( ) - this . getFourmiliere ( ) . getTotalFourmis ( ) ; } for ( int i = 0 ; i < naissances ; i ++ ) { int rand = new Random ( ) . nextInt ( 100 ) ; if ( rand >= this . getFourmiliere ( ) . get_tauxEclaireuses ( ) ) { new Ouvriere ( this . getFourmiliere ( ) ) ; } else { new Eclaireuse ( this . getFourmiliere ( ) ) ; } } if ( this . getFourmiliere ( ) . getTotalFourmis ( ) >= this . getFourmiliere ( ) . getTaille_max ( ) && ( ConfigurationLoader . MAX_FOURMILIERES > this . getFourmiliere ( ) . getMonde ( ) . getFourmilieres ( ) . size ( ) ) ) { if ( new Random ( ) . nextInt ( 100 ) < ConfigurationLoader . CHANCES_NAISSANCE_REINES ) { new Reine ( this . getFourmiliere ( ) ) . setEtat ( States . RECHERCHE_EMPLACEMENT ) ; } } }
tr	1	@ Override public boolean deleteGame ( IGame game ) { if ( fakeGames . contains ( game ) ) { System . out . println ( "Deleting " + game . getURIToString ( ) ) ; fakeGames . remove ( game ) ; return true ; } else { System . err . println ( "Game not in list" + game . getURIToString ( ) ) ; return false ; } }
tr	3	public int maxProfit ( final int length ) { int profit = ( length <= prices . size ( ) ) ? prices . get ( length - 1 ) : 0 ; for ( int i = 1 ; i < length ; i ++ ) { int priceWhenCut = maxProfit ( i ) + maxProfit ( length - i ) ; if ( profit < priceWhenCut ) { profit = priceWhenCut ; } } return profit ; }
tr	8	public void scaleCPU ( int scaleToVal ) { String vmname = config . getvm_name ( ) ; int currentCPUCap , scaleToCPUCap ; ProcessBuilder p = new ProcessBuilder ( "/bin/bash" , "-c" , "xm sched-credit" ) ; Process proc ; try { proc = p . start ( ) ; BufferedReader output = new BufferedReader ( new InputStreamReader ( proc . getInputStream ( ) ) ) ; BufferedReader error = new BufferedReader ( new InputStreamReader ( proc . getErrorStream ( ) ) ) ; String line = "" ; while ( ( line = output . readLine ( ) ) != null ) { String parts [ ] = line . split ( "\\s+" ) ; if ( vmname . equals ( parts [ 0 ] ) ) { currentCPUCap = Integer . parseInt ( parts [ 2 ] ) ; if ( scaleToVal > 0 && scaleToVal <= 10 ) scaleToCPUCap = currentCPUCap - 64 ; else if ( scaleToVal > 85 ) scaleToCPUCap = currentCPUCap + 256 ; else scaleToCPUCap = currentCPUCap + 64 ; logger . info ( "Elastically Scaling CPU value : " + scaleToCPUCap ) ; p = new ProcessBuilder ( "/bin/bash" , "-c" , "xm sched-credit -d " + vmname + " -w " + scaleToCPUCap ) ; proc = p . start ( ) ; BufferedReader innerOutput = new BufferedReader ( new InputStreamReader ( proc . getInputStream ( ) ) ) ; BufferedReader innerError = new BufferedReader ( new InputStreamReader ( proc . getErrorStream ( ) ) ) ; while ( ( line = innerError . readLine ( ) ) != null ) { parts = line . split ( ":" ) ; if ( "Error" . equals ( parts [ 0 ] ) ) { logger . error ( "Command didn't execute successfully: xm sched-credit -d " + vmname + " -w " + scaleToCPUCap ) ; break ; } } break ; } } } catch ( Exception e ) { logger . error ( e . getMessage ( ) ) ; } }
tr	6	public Text parse ( String pathToFile ) { Text text = null ; try { FileInputStream fstream = new FileInputStream ( pathToFile ) ; BufferedReader br = new BufferedReader ( new InputStreamReader ( fstream ) ) ; ResourceBundle bundle ; bundle = ResourceBundle . getBundle ( ApplicationValue . BUNDLE_LOCATION ) ; String textLine ; text = new Text ( ) ; while ( ( textLine = br . readLine ( ) ) != null ) { if ( ( textLine . matches ( bundle . getString ( ApplicationValue . HEADER ) ) || ( textLine . trim ( ) . matches ( bundle . getString ( ApplicationValue . OUTPUT ) ) ) ) ) { text . add ( splitSentenceByWordsAndPunctuation ( textLine ) ) ; } else { if ( isCode ( textLine ) ) { text . add ( new Listing ( textLine ) ) ; } else { Pattern sentencePattern = Pattern . compile ( bundle . getString ( ApplicationValue . SENTENCE ) ) ; Matcher sentenceMatcher = sentencePattern . matcher ( textLine ) ; while ( sentenceMatcher . find ( ) ) { String sentenceString = sentenceMatcher . group ( ) ; text . add ( splitSentenceByWordsAndPunctuation ( sentenceString ) ) ; } } } } } catch ( IOException e ) { log . error ( e ) ; } return text ; }
tr	1	public static void main ( String [ ] args ) { Set < Integer > s = new HashSet < > ( Arrays . asList ( 1 , 2 , 3 , 4 , 5 ) ) ; Set < ? > s0 = allSubSet ( s ) ; System . out . println ( s0 ) ; System . out . println ( s0 . size ( ) ) ; }
tr	5	public String toKML ( boolean suppressEnclosingTags ) { String kml = "" ; if ( ! suppressEnclosingTags ) { kml += "<StyleMap" ; if ( this . id != null ) { kml += " id=\"" + this . getId ( ) + "\"" ; } if ( this . targetId != null ) { kml += " targetId=\"" + this . getTargetId ( ) + "\"" ; } kml += ">\n" ; } kml += super . toKML ( true ) ; for ( Iterator iter = this . pair . iterator ( ) ; iter . hasNext ( ) ; ) { StyleMapPair cur = ( StyleMapPair ) iter . next ( ) ; kml += cur . toKML ( ) ; } if ( ! suppressEnclosingTags ) { kml += "</StyleMap>\n" ; } return kml ; }
tr	9	public static Sequence parse ( File file ) throws SequenceParserException { String sequenceName = null ; String sequenceDescription = null ; BufferedReader reader = null ; try { reader = new BufferedReader ( new InputStreamReader ( new FileInputStream ( file ) ) ) ; StringBuffer buffer = new StringBuffer ( ) ; String line = reader . readLine ( ) ; if ( line . startsWith ( ">" ) ) { line = line . substring ( 1 ) . trim ( ) ; int index = 0 ; for ( int i = 0 ; i < line . length ( ) && line . charAt ( i ) !=   && line . charAt ( i ) != 	 ; i ++ , index ++ ) { } sequenceName = line . substring ( 0 , index ) ; StringTokenizer stringTokenizer = new StringTokenizer ( sequenceName , "|" ) ; while ( stringTokenizer . hasMoreTokens ( ) ) { sequenceName = stringTokenizer . nextToken ( ) ; } sequenceDescription = index + 1 > line . length ( ) ? "" : line . substring ( index + 1 ) ; } else { buffer . append ( prepare ( line ) ) ; } while ( ( line = reader . readLine ( ) ) != null ) { buffer . append ( prepare ( line ) ) ; } reader . close ( ) ; Sequence s = new Sequence ( buffer . toString ( ) , sequenceName , sequenceDescription , Sequence . PROTEIN ) ; return s ; } catch ( Exception e ) { throw new SequenceParserException ( e . getMessage ( ) ) ; } finally { if ( reader != null ) { try { reader . close ( ) ; } catch ( Exception silent ) { logger . log ( Level . WARNING , "Failed closing reader: " + silent . getMessage ( ) , silent ) ; } } } }
tr	0	public int getEffectiveness ( ) { return effectiveness ; }
tr	1	public void test_SimpleDateFormat_parse_minusYyyy ( ) { final String target = "-2007-04-05 00:00:00" ; final SimpleDateFormat format = new SimpleDateFormat ( "yyyy-MM-dd HH:mm:ss" ) ; Date date ; try { date = format . parse ( target ) ; } catch ( ParseException e ) { throw new RuntimeException ( "Failed to parse the string: " + target , e ) ; } String actual = toString ( date , "GGGyyyy-MM-dd HH:mm:ss.SSS" ) ; log ( actual ) ; assertEquals ( "\u7D00\u5143\u524D2008-04-05 00:00:00.000" , actual ) ; assertNotNull ( date ) ; }
tr	8	public List < Tuple < Integer , Integer >> aStar ( Tuple < Integer , Integer > start , Tuple < Integer , Integer > goal ) { HashSet < Tuple < Integer , Integer >> closedSet = new HashSet < Tuple < Integer , Integer >> ( ) ; HashSet < Tuple < Integer , Integer >> openSet = new HashSet < Tuple < Integer , Integer >> ( ) ; openSet . add ( start ) ; HashMap < Tuple < Integer , Integer > , Tuple < Integer , Integer >> cameFrom = new HashMap < Tuple < Integer , Integer > , Tuple < Integer , Integer >> ( ) ; HashMap < Tuple < Integer , Integer > , Integer > g_score = new HashMap < Tuple < Integer , Integer > , Integer > ( ) ; g_score . put ( start , 0 ) ; HashMap < Tuple < Integer , Integer > , Integer > f_score = new HashMap < Tuple < Integer , Integer > , Integer > ( ) ; f_score . put ( start , g_score . get ( start ) + heuristicCostEstimate ( start , goal ) ) ; while ( ! openSet . isEmpty ( ) ) { int lowestF = Integer . MAX_VALUE ; Tuple < Integer , Integer > current = null ; for ( Tuple < Integer , Integer > node : openSet ) { if ( f_score . get ( node ) < lowestF ) { lowestF = f_score . get ( node ) ; current = node ; } } if ( current . equals ( goal ) ) { return reconstructPath ( cameFrom , goal ) ; } openSet . remove ( current ) ; closedSet . add ( current ) ; HashSet < Tuple < Integer , Integer >> neighbor_nodes = getNeighborNodes ( current ) ; for ( Tuple < Integer , Integer > neighbor : neighbor_nodes ) { if ( closedSet . contains ( neighbor ) ) continue ; int tentative_g_score = g_score . get ( current ) + 1 ; if ( ! openSet . contains ( neighbor ) || tentative_g_score < g_score . get ( neighbor ) ) { openSet . add ( neighbor ) ; cameFrom . put ( neighbor , current ) ; g_score . put ( neighbor , tentative_g_score ) ; f_score . put ( neighbor , g_score . get ( neighbor ) + heuristicCostEstimate ( neighbor , goal ) ) ; } } } log . error ( "A* is returning null! This should never happen!" ) ; return null ; }
tr	4	public boolean checkVideoFile ( String loc ) { boolean returnValue = false ; try { _builder = new ProcessBuilder ( "/bin/bash" , "-c" , "echo $(file '" + loc + "')" ) ; _builder = _builder . redirectErrorStream ( true ) ; _process = _builder . start ( ) ; InputStream stdout = _process . getInputStream ( ) ; BufferedReader stdoutBuffered = new BufferedReader ( new InputStreamReader ( stdout ) ) ; String line = null ; while ( ( line = stdoutBuffered . readLine ( ) ) != null ) { if ( line . contains ( "Video" ) || line . contains ( "video" ) ) { returnValue = true ; } } _process . waitFor ( ) ; _process . destroy ( ) ; } catch ( IOException | InterruptedException e ) { e . printStackTrace ( ) ; } return returnValue ; }
tr	8	private boolean applyLawOfAbsorption ( final IExpressionContext context , ASTNode result ) { final MutatingNodeVisitor visitor6 = new MutatingNodeVisitor ( context ) { @ Override public void visit ( ASTNode node , IExpressionContext context , IIterationContext it ) { final ASTNode unwrapped = unwrap ( node ) ; if ( unwrapped . hasParent ( ) && ( unwrapped . isOR ( ) || unwrapped . isAND ( ) ) ) { final ASTNode leftChild = unwrap ( unwrapped . child ( 0 ) ) ; final ASTNode rightChild = unwrap ( unwrapped . child ( 1 ) ) ; if ( ( ( unwrapped . isOR ( ) && rightChild . isAND ( ) ) || ( unwrapped . isAND ( ) && rightChild . isOR ( ) ) ) ) { ASTNode subTerm = unwrap ( rightChild . child ( 0 ) ) ; if ( subTerm . isEquals ( leftChild ) ) { debugPrintln ( "ABSORPTION: Replacing " + unwrapped . toString ( false ) + " -> " + leftChild ) ; unwrapped . replaceWith ( leftChild ) ; it . astMutated ( ) ; } } } } } ; return applyInOrder ( result , visitor6 ) ; }
tr	7	private void menuNumericActionPerformed ( java . awt . event . ActionEvent evt ) { if ( ! menuNumeric . isSelected ( ) ) return ; int [ ] selectedCols = getSelectedColumns ( ) ; if ( selectedCols . length == 0 ) throw new IllegalArgumentException ( "Empty column selection." ) ; boolean areColumnContertible = true ; for ( int i = 0 ; i < selectedCols . length ; i ++ ) if ( table . getColumnType ( selectedCols [ i ] ) != DataTypes . NUMERIC ) areColumnContertible &= table . isColumnConvertible ( selectedCols [ i ] , DataTypes . NUMERIC ) ; if ( ! areColumnContertible ) { int result = JOptionPane . showConfirmDialog ( this , "Data loss will occur " + "upon convertion. \nDo you want to force convertion?" , "Data integrity" , JOptionPane . YES_NO_OPTION , JOptionPane . WARNING_MESSAGE ) ; if ( result == JOptionPane . NO_OPTION ) return ; } for ( int i = 0 ; i < selectedCols . length ; i ++ ) table . convertColumn ( selectedCols [ i ] , DataTypes . NUMERIC ) ; listColumns . updateUI ( ) ; scrollPane . updateUI ( ) ; }
tr	3	public JSONArray toJSONArray ( JSONArray names ) throws JSONException { if ( names == null || names . length ( ) == 0 ) { return null ; } JSONArray ja = new JSONArray ( ) ; for ( int i = 0 ; i < names . length ( ) ; i += 1 ) { ja . put ( this . opt ( names . getString ( i ) ) ) ; } return ja ; }
tr	4	public int [ ] select ( Population pop , int toSelect ) { double minimal = pop . people [ 0 ] . fitness ( ) ; if ( minimal * pop . getBest ( ) . fitness ( ) >= 0 ) minimal = 0 ; int selected [ ] = new int [ toSelect ] ; for ( int creature = 0 ; creature < toSelect ; creature ++ ) { double acc = Math . abs ( Math . random ( ) * pop . average ( ) - minimal ) * pop . people . length ; int s = pop . people . length ; while ( acc >= 0 && s > 0 ) acc -= Math . abs ( pop . people [ -- s ] . fitness ( ) - minimal ) ; selected [ creature ] = s ; } return selected ; }
tr	3	public Command getCmdFromIdent ( String ident , CommandSender sender ) { if ( this . identifiers . get ( ident . toLowerCase ( ) ) == null ) { for ( Command cmd : this . commands . values ( ) ) { if ( cmd . isIdentifier ( sender , ident ) ) { return cmd ; } } } return ( Command ) this . identifiers . get ( ident . toLowerCase ( ) ) ; }
tr	6	boolean isaContact ( Game game , Tile tile , double x , double y ) { Point2D pt = new Point2D . double ( x , y ) ; boolean touched = false ; for ( Tile tl : game . getMap ( ) . getTiles ( ) ) { if ( ! tl . equals ( tile ) ) { if ( tl . getArea ( ) . getMinX ( ) <= x && x <= tl . getArea ( ) . getMaxX ( ) && tl . getArea ( ) . getMinY ( ) <= y && y <= tl . getArea ( ) . getMaxY ( ) ) { touched = true ; break ; } } } return touched ; }
tr	2	public void close ( ) { try { stream . close ( ) ; input . close ( ) ; } catch ( IOException e ) { Log . x ( e . getMessage ( ) ) ; if ( Log . debug ) e . printStackTrace ( ) ; } }
tr	5	private static Number appropriateParseFor ( String text , class < ? extends Number > numberFormat ) throws NumberFormatException { if ( numberFormat == long . class ) { return long . parseLong ( text ) ; } else if ( numberFormat == Integer . class ) { return Integer . parseInt ( text ) ; } else if ( numberFormat == double . class ) { return double . parseDouble ( text ) ; } else if ( numberFormat == float . class ) { return float . parseFloat ( text ) ; } else { throw new RuntimeException ( "cant figure out appropriate number format" ) ; } }
