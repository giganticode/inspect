tr	9	public byte detectMapType ( ) { if ( this . file == null ) return new byte ( null ) . byteValue ( ) ; String fileName = this . file . getName ( ) ; ArrayList < byte > possiblities = new ArrayList < byte > ( ) ; if ( fileName . indexOf ( "map-AirD" ) > - 1 ) possiblities . add ( Channel . TYPE_AIR ) ; if ( fileName . indexOf ( "map-CableD" ) > - 1 ) possiblities . add ( Channel . TYPE_CABLE ) ; if ( fileName . indexOf ( "map-SateD" ) > - 1 ) possiblities . add ( Channel . TYPE_SAT ) ; if ( fileName . endsWith ( "clone.bin" ) ) possiblities . add ( Channel . TYPE_CLONE ) ; if ( possiblities . size ( ) == 1 ) return possiblities . get ( 0 ) . byteValue ( ) ; if ( possiblities . size ( ) == 0 ) { possiblities . add ( Channel . TYPE_AIR ) ; possiblities . add ( Channel . TYPE_CABLE ) ; possiblities . add ( Channel . TYPE_SAT ) ; possiblities . add ( Channel . TYPE_CLONE ) ; } HashMap < byte , String > captions = new HashMap < byte , String > ( 4 ) ; captions . put ( Channel . TYPE_AIR , "Air" ) ; captions . put ( Channel . TYPE_CABLE , "Cable" ) ; captions . put ( Channel . TYPE_SAT , "Satellite" ) ; captions . put ( Channel . TYPE_CLONE , "Clone File" ) ; String [ ] choices = new String [ possiblities . size ( ) ] ; for ( byte b : possiblities ) { choices [ possiblities . indexOf ( b ) ] = captions . get ( b ) ; } String chosenType = ( String ) JOptionPane . showInputDialog ( null , "Could not detect correct file type. Please choose the right one:" , "File Type" , JOptionPane . WARNING_MESSAGE , null , choices , choices [ 0 ] ) ; if ( chosenType != null && chosenType . length ( ) > 0 ) { for ( Map . Entry < byte , String > entry : captions . entrySet ( ) ) { if ( entry . getValue ( ) . equals ( chosenType ) ) return ( ( byte ) entry . getKey ( ) ) . byteValue ( ) ; } } return new byte ( null ) . byteValue ( ) ; }
tr	3	public static String StrFill ( String fillStr , String oldStr , int length , String place ) { StringBuffer sb = new StringBuffer ( ) ; if ( "right" . equals ( place ) ) { sb . append ( oldStr ) ; } for ( int i = 0 ; i < ( length - oldStr . length ( ) ) ; i ++ ) { sb . append ( fillStr ) ; } if ( "left" . equals ( place ) ) { sb . append ( oldStr ) ; } return sb . toString ( ) ; }
tr	8	@ Override public boolean equals ( Object cidades ) { if ( cidades == null ) { return false ; } if ( getClass ( ) != cidades . getClass ( ) ) { return false ; } final Cidades other = ( Cidades ) cidades ; if ( ( this . nome == null ) ? ( other . nome != null ) : ! this . nome . equals ( other . nome ) ) { return false ; } if ( ( this . uf == null ) ? ( other . uf != null ) : ! this . uf . equals ( other . uf ) ) { return false ; } if ( ( this . ddd == null ) ? ( other . ddd != null ) : ! this . ddd . equals ( other . ddd ) ) { return false ; } return true ; }
tr	5	private int tierToMaxCost ( int tier ) { switch ( tier ) { case 1 : return 49 ; case 2 : return 99 ; case 3 : return 499 ; case 4 : return 1000 ; case 5 : return 5000 ; } return 0 ; }
tr	7	private void createNewKey ( BigInteger value ) { if ( this . keyMode == KeyMode . MULTI_KEY ) { MultiKey temp = new MultiKey ( value ) ; if ( ! this . allMultiKeys . add ( temp ) ) throw new RuntimeException ( "MultiKey was in treeset!" ) ; for ( Key key : temp . values ) if ( ! this . allKeys . add ( key ) ) throw new RuntimeException ( "Key was in treeset!" ) ; } else if ( this . keyMode == KeyMode . COMPLEX_KEY ) { if ( ! this . allKeys . add ( new ComplexKey ( value ) ) ) throw new RuntimeException ( "Key was in treeset!" ) ; } else { if ( ! this . allKeys . add ( new CountableKey ( value ) ) ) throw new RuntimeException ( "Key was in treeset!" ) ; } }
tr	5	public static void main ( String [ ] args ) { Comparable [ ] arrayChar = { S , H , E , L , L , S , O , R , T , E , X , A , M , P , L , E } ; int length = arrayChar . length ; int h = 1 ; while ( h < length / 3 ) { h = h * 3 + 1 ; System . out . println ( "top==>" + h ) ; } while ( h >= 1 ) { for ( int i = h ; i < length ; i ++ ) { for ( int j = i ; j >= h && less ( arrayChar [ j ] , arrayChar [ j - h ] ) ; j -= h ) { exchange ( arrayChar , j , j - h ) ; } } h = h / 3 ; System . out . println ( h ) ; } show ( arrayChar ) ; }
tr	5	public Divider ( Poly num , Poly den ) { double tp = den . p [ 0 ] ; if ( Math . abs ( tp ) < epsilon ) throw new RuntimeException ( "Divide Poly by Zero!" ) ; if ( den . p . length > num . p . length ) { quo = new Poly ( ) ; rem = den ; } else { double [ ] quo = new double [ num . p . length - den . p . length + 1 ] ; Poly tmp = num ; int idx = tmp . p . length - den . p . length ; do { double v = tmp . p [ 0 ] / den . p [ 0 ] ; quo [ quo . length - idx - 1 ] = v ; double [ ] qq = new double [ tmp . p . length - 1 ] ; for ( int i = 0 ; i < qq . length ; i ++ ) qq [ i ] = tmp . p [ i + 1 ] ; for ( int i = 1 ; i < den . p . length ; i ++ ) qq [ i - 1 ] -= v * den . p [ i ] ; tmp = new Poly ( qq ) ; idx = tmp . p . length - den . p . length ; } while ( idx >= 0 ) ; this . quo = new Poly ( quo ) ; rem = tmp ; } }
tr	1	public void render ( Renderable p ) { if ( p . getState ( ) != null ) { Status s = ( Status ) p . getState ( ) ; Map < String , List < String >> usercommandlist = new HashMap < String , List < String >> ( ) ; usercommandlist = s . getUserCommands ( ) ; display ( usercommandlist ) ; } }
tr	5	public void runKong ( boolean stepbystep , int pausetime ) { if ( points . size ( ) <= 3 ) return ; triangles . clear ( ) ; int index = 1 ; while ( points . size ( ) > 3 ) { if ( stepbystep ) { drawPanel . drawPolygon ( points ) ; drawPanel . drawTriangles ( triangles , Color . BLUE ) ; drawPanel . drawTriangleFromPoints ( points . get ( getIndex ( index , - 1 ) ) , points . get ( index ) , points . get ( getIndex ( index , 1 ) ) , Color . RED ) ; try { Thread . sleep ( pausetime ) ; } catch ( Exception ex ) { System . out . println ( ex . toString ( ) ) ; } } if ( isEar ( points . get ( getIndex ( index , - 1 ) ) , points . get ( index ) , points . get ( getIndex ( index , 1 ) ) ) ) { triangles . add ( new Triangle ( points . get ( getIndex ( index , - 1 ) ) , points . get ( index ) , points . get ( getIndex ( index , 1 ) ) ) ) ; points . remove ( points . get ( index ) ) ; index = getIndex ( index , - 1 ) ; } else { index = getIndex ( index , 1 ) ; } } triangles . add ( new Triangle ( points . get ( 0 ) , points . get ( 1 ) , points . get ( 2 ) ) ) ; }
tr	4	public Direction getRightDirection ( ) { switch ( this ) { case NORTH : return EAST ; case SOUTH : return WEST ; case WEST : return NORTH ; case EAST : return SOUTH ; default : return this ; } }
tr	2	public boolean weakensSEHits ( ) { switch ( this ) { case FILTER : case SOLID_ROCK : return true ; default : return false ; } }
tr	2	@ Override public String filterReplacedString ( FilterBypass fb , int offset , int length , String str , AttributeSet attrs ) { if ( str == null ) return "" ; int remaining = limit - fb . getDocument ( ) . getLength ( ) + length ; if ( remaining > str . length ( ) ) { return str ; } else { return str . substring ( 0 , remaining ) ; } }
tr	4	public static int matchGenreDescription ( String description ) { if ( description != null && description . length ( ) > 0 ) { for ( int i = 0 ; i < ID3v1Genres . GENRES . length ; i ++ ) { if ( ID3v1Genres . GENRES [ i ] . equalsIgnoreCase ( description ) ) { return i ; } } } return - 1 ; }
tr	1	@ Override public BigDecimal evaluate ( String mathExpression ) throws EvaluationException { EvaluationContext context = new EvaluationContext ( mathExpression ) ; try { return run ( context ) ; } catch ( Exception ex ) { throw new EvaluationException ( ex . getMessage ( ) , context . getCurrentPosition ( ) ) ; } }
tr	8	public static int countPath3 ( int m , int n ) { if ( m < 0 || n < 0 ) { return 0 ; } if ( m == 0 && n == 0 ) { return 1 ; } if ( m == 0 && n != 0 ) { return 1 ; } if ( n == 0 && m != 0 ) { return 1 ; } return countPath3 ( m - 1 , n ) + countPath3 ( m , n - 1 ) ; }
tr	9	private static void writeFrame ( final DataFrame frame , final JsonWriter writer ) throws IOException { if ( frame == null || writer == null ) { return ; } if ( frame . size ( ) > 0 ) { boolean isArray = frame . isArray ( ) ; if ( isArray ) writer . writeArrayOpen ( ) ; else writer . writeObjectOpen ( ) ; DataField field = null ; for ( int i = 0 ; i < frame . size ( ) ; i ++ ) { field = frame . getField ( i ) ; if ( ! isArray ) { if ( field . getName ( ) != null ) { writer . writeString ( field . getName ( ) ) ; } else { writer . writeString ( "" ) ; } writer . writeMemberSeparator ( ) ; } if ( field . getType ( ) == DataField . UDEF ) { writer . writeLiteral ( null ) ; } else if ( field . getType ( ) == DataField . BOOLEANTYPE ) { if ( true . equalsIgnoreCase ( field . getStringValue ( ) ) ) { writer . writeLiteral ( true ) ; } else { writer . writeLiteral ( false ) ; } } else if ( field . isNumeric ( ) ) { writer . writeNumber ( field . getStringValue ( ) ) ; } else if ( field . getType ( ) == DataField . FRAMETYPE ) { writeFrame ( ( DataFrame ) field . getObjectValue ( ) , writer ) ; } else { Object obj = field . getObjectValue ( ) ; if ( obj != null ) { writer . writeString ( obj . toString ( ) ) ; } else { writer . writeLiteral ( null ) ; } } if ( i + 1 < frame . size ( ) ) { writer . writeObjectSeparator ( ) ; } } if ( isArray ) writer . writeArrayClose ( ) ; else writer . writeObjectClose ( ) ; } else { writer . writeObjectOpen ( ) ; writer . writeObjectClose ( ) ; } return ; }
tr	1	@ Override public AIMove move ( ) { AIManager manager = AIManager . getInstance ( ) ; AIHockeyist hockeyist = manager . getTeammate ( hockeyistId ) ; AIPuck puck = manager . getPuck ( ) ; AIMove move = AIGo . to ( hockeyist , puck ) ; if ( hockeyist . isInStickRange ( puck ) ) { move . setAction ( ActionType . TAKE_PUCK ) ; } return move ; }
tr	2	private void readUsername ( ) { try { File lastLogin = new File ( Util . getWorkingDirectory ( ) , "lastlogin" ) ; Cipher cipher = getCipher ( 2 , "passwordfile" ) ; DataInputStream dis ; if ( cipher != null ) dis = new DataInputStream ( new CipherInputStream ( new FileInputStream ( lastLogin ) , cipher ) ) ; else { dis = new DataInputStream ( new FileInputStream ( lastLogin ) ) ; } userName . setText ( dis . readUTF ( ) ) ; password . setText ( dis . readUTF ( ) ) ; rememberBox . setSelected ( password . getPassword ( ) . length > 0 ) ; dis . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } }
tr	0	public LogLevel getLogLevel ( ) { return logLevel ; }
tr	1	protected static long getCPtr ( SWIGTYPE_p_uint32_t obj ) { return ( obj == null ) ? 0 : obj . swigCPtr ; }
tr	8	public Model getRotatedModel ( ) { Model model = aSpotAnim_1568 . getModel ( ) ; if ( model == null ) return null ; int j = aSpotAnim_1568 . aAnimation_407 . anIntArray353 [ anInt1569 ] ; Model model_1 = new Model ( true , Class36 . method532 ( j ) , false , model ) ; if ( ! aBoolean1567 ) { model_1 . method469 ( ) ; model_1 . method470 ( j ) ; model_1 . anIntArrayArray1658 = null ; model_1 . anIntArrayArray1657 = null ; } if ( aSpotAnim_1568 . anInt410 != 128 || aSpotAnim_1568 . anInt411 != 128 ) model_1 . method478 ( aSpotAnim_1568 . anInt410 , aSpotAnim_1568 . anInt410 , aSpotAnim_1568 . anInt411 ) ; if ( aSpotAnim_1568 . anInt412 != 0 ) { if ( aSpotAnim_1568 . anInt412 == 90 ) model_1 . method473 ( ) ; if ( aSpotAnim_1568 . anInt412 == 180 ) { model_1 . method473 ( ) ; model_1 . method473 ( ) ; } if ( aSpotAnim_1568 . anInt412 == 270 ) { model_1 . method473 ( ) ; model_1 . method473 ( ) ; model_1 . method473 ( ) ; } } model_1 . method479 ( 64 + aSpotAnim_1568 . anInt413 , 850 + aSpotAnim_1568 . anInt414 , - 30 , - 50 , - 30 , true ) ; return model_1 ; }
tr	0	public void setPassword ( String password ) { this . password = password ; }
tr	2	public void test_GetRevisionInfo ( ) { FileHistory fileHist = new FileHistory ( path . resolve ( "README.txt" ) ) ; fileHist . storeRevision ( path . resolve ( "README.txt" ) , null , 100 , 200 ) ; fileHist . storeRevision ( path . resolve ( "license.txt" ) , null , 300 , 400 ) ; fileHist . storeRevision ( path . resolve ( "authors.txt" ) , null , 500 , 600 ) ; DataRetriever dataRetriever = new DataRetriever ( path . resolve ( "README.txt" ) ) ; Vector < Vector < String >> tableData = dataRetriever . getRevisionInfoTable ( ) ; System . out . println ( "Please check time-depend result:" ) ; for ( Vector < String > rows : tableData ) { for ( String data : rows ) { System . out . println ( data ) ; } } }
tr	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( Config . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( Config . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( Config . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( Config . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { @ Override public void run ( ) { new Config ( ) . setVisible ( true ) ; } } ) ; }
tr	8	public void update ( ) { if ( gameState != GameState . PLAYING ) { camera . renderScene ( this , world ) ; } switch ( gameState ) { case INITIALIZING : handleGameInitializing ( ) ; break ; case STARTING : handleGameStarting ( ) ; break ; case PLAYING : handleGamePlaying ( ) ; break ; case LEVEL_CHANGE : handleLevelChange ( ) ; break ; case LEVEL_RESET : handleLevelReset ( ) ; break ; case OUT_OF_BOUNDS : handleBallOutOfBounds ( ) ; break ; case GAME_OVER : handleGameOver ( ) ; break ; } }
tr	0	public SandTopSlab ( CustomSlabs plugin , Texture texture ) { super ( plugin , plugin . getConfig ( ) . getString ( "sand.name.top" , "Sand TopSlab" ) , 44 , 8 , new GenericCuboidBlockDesign ( plugin , texture , new int [ ] { 1 , 0 , 0 , 0 , 0 , 1 } , 0.0F , 0.5F , 0.0F , 1.0F , 1.0F , 1.0F ) ) ; this . setStepSound ( MaterialData . sand . getStepSound ( ) ) ; this . setHardness ( MaterialData . sand . getHardness ( ) ) ; this . setFriction ( MaterialData . sand . getFriction ( ) ) ; this . setLightLevel ( MaterialData . sand . getLightLevel ( ) ) ; this . setItemDrop ( new SpoutItemStack ( plugin . SandSlab ) ) ; }
tr	2	public static void main ( String [ ] args ) { Pattern pattern ; if ( args . length < 1 ) { pattern = Pattern . compile ( ".*" ) ; } else { pattern = Pattern . compile ( args [ 0 ] ) ; } Collection < String > list = ResourceList . getResources ( pattern ) ; for ( String name : list ) { System . out . println ( name ) ; } }
tr	2	private void buttonColoredAction1ActionPerformed ( java . awt . event . ActionEvent evt ) { DefaultTableModel model = new DefaultTableModel ( ) ; this . jTable1 . setModel ( model ) ; model . setColumnIdentifiers ( new Object [ ] { "Id" , "Descripcion" , "Usuario" , "Estado" , "Proyecto" } ) ; Tarea tarea = new Tarea ( ) ; tarea . setIdProyecto ( Integer . parseInt ( txtIdProyecto . getText ( ) ) ) ; try { ResultSet res = QATracker . tareaBus . consultaProyecto ( tarea ) ; while ( res . next ( ) ) { model . addRow ( new Object [ ] { res . getString ( 1 ) , res . getString ( 2 ) , res . getString ( 3 ) , res . getString ( 4 ) , res . getString ( 5 ) } ) ; } } catch ( SQLException ex ) { System . out . println ( ex . getMessage ( ) ) ; } }
tr	1	@ Override protected String extractProviderUserId ( final AccessGrant accessGrant ) { if ( ! ( accessGrant instanceof ForcedotcomAccessGrant ) ) { throw new IllegalStateException ( "accessGrant has to be of type ForcedotcomAccessGrant" ) ; } return ( ( ForcedotcomAccessGrant ) accessGrant ) . getId ( ) ; }
tr	1	public final ProgramaContext programa ( ) throws RecognitionException { ProgramaContext _localctx = new ProgramaContext ( _ctx , getState ( ) ) ; enterRule ( _localctx , 0 , RULE_programa ) ; try { enterOuterAlt ( _localctx , 1 ) ; { setState ( 10 ) ; seqComando ( ) ; } } catch ( RecognitionException re ) { _localctx . exception = re ; _errHandler . reportError ( this , re ) ; _errHandler . recover ( this , re ) ; } finally { exitRule ( ) ; } return _localctx ; }
tr	0	private void jButton11ActionPerformed ( java . awt . event . ActionEvent evt ) { jButton9 . setEnabled ( true ) ; jButton10 . setEnabled ( false ) ; jButton11 . setEnabled ( false ) ; jButton12 . setEnabled ( false ) ; Music . Stop ( ) ; }
tr	6	private int processBNEInst ( BNE bne ) { String opCode = bne . getOpcode ( ) . name ( ) ; int instOrder = bne . getOrder ( ) ; String src1n = "" ; String src2n = "" ; if ( bne . getState ( ) . equals ( State . ISSUE_COMP ) ) { boolean src1 = ! dataHaz . checkRAWHazard ( bne . getReg1 ( ) , bne ) ; boolean src2 = ! dataHaz . checkRAWHazard ( bne . getReg2 ( ) , bne ) ; if ( src1 && src2 ) { long src1v = regMem . getRegValue ( bne . getReg1 ( ) . getId ( ) ) ; long src2v = regMem . getRegValue ( bne . getReg2 ( ) . getId ( ) ) ; bne . getReg1 ( ) . setValue ( src1v . intValue ( ) ) ; bne . getReg2 ( ) . setValue ( src2v . intValue ( ) ) ; log . debug ( "opCode " + "[" + instOrder + "]" + " instruction read from Register Memory." ) ; log . debug ( "Source1 value is: " + opCode + "[" + instOrder + "]" + src1v . intValue ( ) + " Register: " + bne . getReg1 ( ) . getId ( ) . name ( ) ) ; log . debug ( "Source2 value is: " + opCode + "[" + instOrder + "]" + src1v . intValue ( ) + " Register: " + bne . getReg2 ( ) . getId ( ) . name ( ) ) ; bne . clearRawHazard ( ) ; bne . setState ( State . READ ) ; if ( src1v . intValue ( ) != src2v . intValue ( ) ) { bne . setResult ( 5 ) ; } } else { bne . setRawHazard ( ) ; ResultMgr . getInstance ( ) . setRawHazard ( bne . getRawInst ( ) ) ; if ( ! src1 ) { src1n = bne . getReg1 ( ) . getName ( ) ; log . debug ( opCode + "[" + instOrder + "]" + " Source registers " + src1n + " is already busy. RAW hazard detected." ) ; } if ( ! src2 ) { src2n = bne . getReg2 ( ) . getName ( ) ; log . debug ( opCode + "[" + instOrder + "]" + " Source registers " + src2n + " is already busy. RAW hazard detected." ) ; } } } return 0 ; }
tr	3	@ Override public void addFirstLevel ( final ILevel myFirstLevel ) { if ( myFirstLevel != null ) { if ( levelStage != null ) { myFirstLevel . setLevelStage ( levelStage ) ; } else if ( myFirstLevel . getLevelStage ( ) != null ) { setLevelStage ( myFirstLevel . getLevelStage ( ) ) ; } myFirstLevel . setLevelPack ( this ) ; getFirstLevels ( ) . add ( myFirstLevel ) ; } }
tr	9	public void parseSetting ( String arg ) { if ( arg . equals ( "-h" ) || arg . equals ( "--help" ) ) { System . out . println ( "Usage: RubixToDIMACS -r=RANDOMS [-verbose] [n=MAXMOVES] [e=ENCODING] [OUTPUT] [MAPPING]" ) ; System . out . println ( "   or: RubixToDIMACS -m=SEQUENCE [-verbose] [n=MAXMOVES] [e=ENCODING] [OUTPUT] [MAPPING]" ) ; System . out . println ( "   or: RubixToDIMACS [OUTPUT]" ) ; System . out . println ( "\nWrite the DIMACS encoding of a rubix cube " ) ; System . out . println ( "specified either by a sequence of moves or" ) ; System . out . println ( "an amount of random moves  to OUTPUT or stdout." ) ; System . out . println ( "\nThe arguments are:" ) ; System . out . println ( "-r=RANDOMS \t\tset the amount of random moves" ) ; System . out . println ( "-m=SEQUENCE\t\ta sequence of characters describing rubix cube moves:" ) ; System . out . println ( "           \t\tF = Clockwise Front Turn  F2 = Double Front Turn " ) ; System . out . println ( "           \t\tF' = Counter-clockwise Front Turn" ) ; System . out . println ( "           \t\tSimilar: B(ack)  L(eft)  R(ight)  U(p) and D(own)" ) ; System . out . println ( "           \t\tExample: The `sune` move would have the sequence:" ) ; System . out . println ( "           \t\t      -m=L'U'RULU'R'U" ) ; System . out . println ( "-verbose   \t\tIf set  print the move sequence to stderr" ) ; System . out . println ( "-n=MAXMOVES\t\tset the limit of moves to MAXMOVES" ) ; System . out . println ( "           \t\tThe default value is 50" ) ; System . out . println ( "-e=ENCODING\t\tDefines the class file that is used to encode the cube" ) ; System . out . println ( "           \t\tThe default is rubix.RubixSAT" ) ; System . out . println ( "OUTPUT     \t\tSpecifies the output file" ) ; System . out . println ( "MAPPING    \t\tSpecifies the mapping file" ) ; System . exit ( 0 ) ; } else if ( arg . startsWith ( "-r=" ) && moves . equals ( "" ) ) { random = Integer . parseInt ( arg . substring ( 3 ) ) ; } else if ( arg . startsWith ( "-m=" ) && random == - 1 ) { moves = arg . substring ( 3 ) ; } else if ( arg . startsWith ( "-e=" ) ) { encoding = arg . substring ( 3 ) ; } else if ( arg . charAt ( 0 ) != - && output . length ( ) == 0 ) { output = arg ; } else if ( arg . charAt ( 0 ) != - ) { mapping = arg ; } else if ( arg . startsWith ( "-n=" ) ) { max = Integer . parseInt ( arg . substring ( 3 ) ) ; } else if ( arg . equals ( "-verbose" ) ) { verbose = true ; } else { System . err . println ( "Illegal argument: " + arg ) ; System . exit ( 0 ) ; } }
tr	2	public void open ( URL location , String referer ) throws IOException { String host = location . getHost ( ) ; if ( referer == null ) referer = "http://" + host + "/" ; String path = location . getPath ( ) + "?" + location . getQuery ( ) ; int port = location . getPort ( ) ; if ( port == - 1 ) port = 80 ; socket . setSoTimeout ( 5000 ) ; socket . connect ( new InetSocketAddress ( host , port ) , 5000 ) ; PrintWriter pw = new PrintWriter ( socket . getOutputStream ( ) , true ) ; pw . println ( "GET " + path + " HTTP/1.1" ) ; pw . println ( "Host: " + host ) ; pw . println ( "Referer: " + referer ) ; pw . println ( "Accept: */*" ) ; pw . println ( "User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)" ) ; pw . println ( "Connection: Keep-Alive" ) ; pw . println ( ) ; instream = socket . getInputStream ( ) ; getResponse ( ) ; }
tr	4	private static void doSort ( OffHeapStructCollection a , long left , long right , int keyOffset , byte [ ] pi , byte [ ] pj , byte [ ] pe1 , byte [ ] pe2 , byte [ ] pe3 , byte [ ] pe4 , byte [ ] pe5 ) { if ( right - left + 1 < INSERTION_SORT_THRESHOLD ) { for ( long i = left + 1 ; i <= right ; i ++ ) { long ai = a . getInt ( i , keyOffset ) ; a . get ( i , pi ) ; long j ; for ( j = i - 1 ; j >= left && ai < a . getInt ( j , keyOffset ) ; j -- ) { a . get ( j , pj ) ; a . set ( j + 1 , pj ) ; } a . set ( j + 1 , pi ) ; } } else { dualPivotQuicksort ( a , left , right , keyOffset , pi , pj , pe1 , pe2 , pe3 , pe4 , pe5 ) ; } }
tr	2	public void insert ( Object value , int index ) { int space = index ; while ( rawget ( space ) != null ) space ++ ; while ( space != index ) rawset ( space , rawget ( -- space ) ) ; rawset ( space , value ) ; }
tr	7	@ Override public void actionPerformed ( ActionEvent e ) { if ( e . getSource ( ) == btnBorrarBusqueda ) { txtBuscar . setText ( "" ) ; filtrarMedio ( txtBuscar . getText ( ) , raizNegativa , raizArbol , false ) ; modeloArbol . reload ( ) ; } if ( e . getSource ( ) == btnActualizar ) { cargarMedios ( ) ; modeloArbol . reload ( ) ; } if ( e . getSource ( ) == btnExpandir ) { expandido = ! expandido ; if ( ! expandido ) btnExpandir . setIcon ( new ImageIcon ( this . getClass ( ) . getResource ( IMG_EXPANDIR_16 ) ) ) ; else btnExpandir . setIcon ( new ImageIcon ( this . getClass ( ) . getResource ( IMG_COLAPSAR_16 ) ) ) ; expandirTodo ( arbolPrincipal , expandido ) ; if ( ! expandido ) modeloArbol . reload ( ) ; } if ( e . getSource ( ) == btnConfigurar ) personalizarBusqueda = new DialogoPersonalizarBusqueda ( ) ; if ( e . getSource ( ) == itmAgregar ) ; }
tr	2	public String toString ( ) { if ( clusterId != null ) return clusterId ; clusterId = String . format ( "%d" , rcid [ 0 ] ) ; for ( int i = 1 ; i < rcid . length ; i ++ ) { clusterId = clusterId . concat ( String . format ( ":%d" , rcid [ i ] ) ) ; } return clusterId ; }
tr	1	public boolean action ( Event event , Object arg ) { if ( event . target == cancelButton ) { whatToCancel . cancel ( ) ; return true ; } else return super . action ( event , arg ) ; }
tr	5	static public void LU_ver ( double a [ ] [ ] ) { int n = a . length ; int i , j , k ; double suma ; for ( i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j <= i - 1 ; j ++ ) { ver ( i , j , 0 ) ; System . out . print ( "(" ) ; ver ( i , j , 1 ) ; suma = 0 ; for ( k = 0 ; k <= j - 1 ; k ++ ) { ver ( i , k , 3 ) ; ver ( k , j , 2 ) ; suma += a [ i ] [ k ] * a [ k ] [ j ] ; } a [ i ] [ j ] = ( a [ i ] [ j ] - suma ) / a [ j ] [ j ] ; ver ( j , j , 4 ) ; System . out . println ( ) ; } for ( j = i ; j < n ; j ++ ) { suma = 0 ; ver ( i , j , 0 ) ; ver ( i , j , 1 ) ; for ( k = 0 ; k <= i - 1 ; k ++ ) { ver ( i , k , 3 ) ; ver ( k , j , 2 ) ; suma += a [ i ] [ k ] * a [ k ] [ j ] ; } a [ i ] [ j ] = a [ i ] [ j ] - suma ; System . out . println ( ) ; } } }
tr	1	private List < BudgetUser > findUserEntities ( boolean all , int maxResults , int firstResult ) { EntityManager em = getEntityManager ( ) ; try { CriteriaQuery cq = em . getCriteriaBuilder ( ) . createQuery ( ) ; cq . select ( cq . from ( BudgetUser . class ) ) ; Query q = em . createQuery ( cq ) ; if ( ! all ) { q . setMaxResults ( maxResults ) ; q . setFirstResult ( firstResult ) ; } return q . getResultList ( ) ; } finally { em . close ( ) ; } }
tr	7	public static boolean line_circle ( double x0 , double y0 , double x1 , double y1 , double cx , double cy , double r ) { double f = ( x1 - x0 ) ; double g = ( y1 - y0 ) ; double fSQ = f * f ; double gSQ = g * g ; double fgSQ = fSQ + gSQ ; double rSQ = r * r ; double xc0 = cx - x0 ; double yc0 = cy - y0 ; double xc1 = cx - x1 ; double yc1 = cy - y1 ; boolean lineInside = xc0 * xc0 + yc0 * yc0 < rSQ && xc1 * xc1 + yc1 * yc1 < rSQ ; double fygx = f * yc0 - g * xc0 ; double root = r * r * fgSQ - fygx * fygx ; if ( root > ACCY && ! lineInside ) { double fxgy = f * xc0 + g * yc0 ; double t = fxgy / fgSQ ; if ( t >= 0 && t <= 1 ) return true ; if ( ( xc0 * xc0 + yc0 * yc0 < rSQ ) || ( xc1 * xc1 + yc1 * yc1 < rSQ ) ) return true ; } return false ; }
tr	3	public List < ScheduleDTO > getScheduleForStation ( ScheduleDTO userRequirements ) throws GetScheduleException { log . debug ( "Start: getScheduleForStation()" ) ; EntityManager entityManager = entityManagerFactory . createEntityManager ( ) ; entityManager . getTransaction ( ) . begin ( ) ; List < Station > stationBuf = entityManager . createQuery ( "select s from Station s where s.name = ?1" ) . setParameter ( 1 , userRequirements . getFromStation ( ) ) . getResultList ( ) ; if ( stationBuf . isEmpty ( ) ) { log . warn ( "given station is absent in DB" ) ; throw new GetScheduleException ( "\u0412\u044B\u0431\u0440\u0430\u043D\u043D\u0430\u044F \u0441\u0442\u0430\u043D\u0446\u0438\u044F \u043E\u0442\u0441\u0443\u0442\u0441\u0442\u0432\u0443\u0435\u0442 \u0432 \u0431\u0430\u0437\u0435 \u0434\u0430\u043D\u043D\u044B\u0445" ) ; } List < Object [ ] > resultList = entityManager . createQuery ( "select sir1.train.number  sir1.station.name  sir2.station.name  " + "       sir3.departureTime  sir3.arrivalTime  sir1.train.vacancies " + "from StationInRoute sir1  StationInRoute sir2  StationInRoute sir3 " + "where sir1.train.id = sir2.train.id and sir1.train.id = sir3.train.id and " + "      sir1.departureTime = (select min(sir4.departureTime) " + "                            from StationInRoute sir4 " + "                            where sir4.train.id = sir1.train.id) and " + "      sir2.arrivalTime = (select max(sir5.arrivalTime) " + "                          from StationInRoute sir5 " + "                          where sir5.train.id = sir2.train.id) and " + "      sir3.station.name = ?1" ) . setParameter ( 1 , userRequirements . getFromStation ( ) ) . getResultList ( ) ; int size = resultList . size ( ) ; if ( size == 0 ) { log . warn ( "No schedule for requested station" ) ; throw new GetScheduleException ( "\u0414\u043B\u044F \u0437\u0430\u043F\u0440\u043E\u0448\u0435\u043D\u043D\u043E\u0439 \u0441\u0442\u0430\u043D\u0446\u0438\u0438 \u043D\u0435\u0442 \u0440\u0430\u0441\u043F\u0438\u0441\u0430\u043D\u0438\u044F" ) ; } ArrayList < ScheduleDTO > scheduleList = new ArrayList < ScheduleDTO > ( size ) ; for ( int i = 0 ; i < size ; i ++ ) { Object [ ] arr = resultList . get ( i ) ; scheduleList . add ( new ScheduleDTO ( ( Integer ) arr [ 0 ] , ( String ) arr [ 1 ] , ( String ) arr [ 2 ] , ( Time ) arr [ 3 ] , ( Time ) arr [ 4 ] , ( Integer ) arr [ 5 ] ) ) ; } return scheduleList ; }
tr	5	public NewLevelSetup ( String caption , Menu newMenu ) { this . setTitle ( caption ) ; this . setDefaultCloseOperation ( DISPOSE_ON_CLOSE ) ; this . setModalityType ( Dialog . ModalityType . DOCUMENT_MODAL ) ; this . menu = newMenu ; this . fieldSizeX = new JFormattedTextField ( this . menu . getSizeX ( ) ) ; this . fieldSizeY = new JFormattedTextField ( this . menu . getSizeY ( ) ) ; this . fieldSizeX . setColumns ( 3 ) ; this . fieldSizeY . setColumns ( 3 ) ; this . labelSize . setHorizontalAlignment ( JLabel . CENTER ) ; this . labelSizeX . setHorizontalAlignment ( JLabel . CENTER ) ; this . labelSizeY . setHorizontalAlignment ( JLabel . CENTER ) ; String [ ] tilesetList = Data . getTilesetList ( new File ( Data . getDataDirectory ( ) + "/data/gfx/tileset" ) ) ; if ( tilesetList != null ) this . comboTileset = new JComboBox < String > ( tilesetList ) ; else this . comboTileset = new JComboBox < String > ( ) ; fieldSizeX . addPropertyChangeListener ( new PropertyChangeListener ( ) { public void propertyChange ( PropertyChangeEvent e ) { int value = ( ( Number ) fieldSizeX . getValue ( ) ) . intValue ( ) ; if ( value < 20 ) { value = 20 ; fieldSizeX . setValue ( value ) ; } else if ( value > 500 ) { value = 500 ; fieldSizeX . setValue ( value ) ; } } } ) ; fieldSizeY . addPropertyChangeListener ( new PropertyChangeListener ( ) { public void propertyChange ( PropertyChangeEvent e ) { int value = ( ( Number ) fieldSizeY . getValue ( ) ) . intValue ( ) ; if ( value < 20 ) { value = 20 ; fieldSizeY . setValue ( value ) ; } else if ( value > 500 ) { value = 500 ; fieldSizeY . setValue ( value ) ; } } } ) ; buttonCancel . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { choice = false ; setVisible ( false ) ; dispose ( ) ; } } ) ; buttonCreate . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { menu . setSizeX ( ( ( Number ) fieldSizeX . getValue ( ) ) . intValue ( ) ) ; menu . setSizeY ( ( ( Number ) fieldSizeY . getValue ( ) ) . intValue ( ) ) ; menu . setTilesetName ( String . valueOf ( comboTileset . getSelectedItem ( ) ) ) ; choice = true ; setVisible ( false ) ; dispose ( ) ; } } ) ; fieldContainer . add ( labelSizeX ) ; fieldContainer . add ( fieldSizeX ) ; fieldContainer . add ( labelSizeY ) ; fieldContainer . add ( fieldSizeY ) ; buttonContainer . add ( buttonCancel ) ; buttonContainer . add ( buttonCreate ) ; windowLayout . setVgap ( 5 ) ; windowContainer . add ( labelSize ) ; windowContainer . add ( fieldContainer ) ; windowContainer . add ( comboTileset ) ; windowContainer . add ( buttonContainer ) ; this . add ( windowContainer ) ; }
tr	5	@ Override public boolean onRequest ( HttpRequest request , HttpResponse response ) throws Exception { String filePath = request . getRequestedFilePath ( ) ; if ( urlToMapTo != null ) { if ( ! filePath . startsWith ( urlToMapTo ) ) return false ; filePath = filePath . substring ( urlToMapTo . length ( ) ) ; } File file = new File ( directory , filePath ) ; if ( ! file . isFile ( ) || ! file . canRead ( ) || ! file . getAbsolutePath ( ) . startsWith ( directory . getAbsolutePath ( ) ) ) return false ; IOFileChannelInputBuffer buffer = new IOFileChannelInputBuffer ( new FileInputStream ( file ) . getChannel ( ) ) ; response . setHeader ( "content-type" , mimeNameMap . getContentTypeFor ( file . getAbsolutePath ( ) ) ) ; response . setBodyBuffer ( buffer ) ; buffer . free ( ) ; return true ; }
tr	1	public JGObject ( String name , boolean unique_id , double x , double y , int collisionid , String gfxname , double xspeed , double yspeed , int expiry ) { setPos ( x , y ) ; initObject ( default_engine , name + ( unique_id ? "" + ( next_id ++ ) : "" ) , collisionid ) ; setGraphic ( gfxname ) ; setSpeedAbs ( xspeed , yspeed ) ; this . expiry = expiry ; }
tr	3	@ Override public int hashCode ( ) { int result = super . hashCode ( ) ; result = 31 * result + ( firstName != null ? firstName . hashCode ( ) : 0 ) ; result = 31 * result + ( familyName != null ? familyName . hashCode ( ) : 0 ) ; result = 31 * result + ( address != null ? address . hashCode ( ) : 0 ) ; return result ; }
tr	4	@ Override protected void done ( ) { String errorMsg = "" ; final SolverTask st = solverTask ; if ( this == st ) { solverTask = null ; try { setSolution ( this . get ( ) ) ; } catch ( CancellationException e ) { System . err . println ( e . toString ( ) ) ; } catch ( Exception e ) { errorMsg = e . toString ( ) ; e . printStackTrace ( ) ; } } if ( ! errorMsg . isEmpty ( ) ) { appendSolutionText ( "error:\n" + errorMsg + "\n" , null ) ; } }
tr	9	private void huffman_decode ( int ch , int gr ) { x [ 0 ] = 0 ; y [ 0 ] = 0 ; v [ 0 ] = 0 ; w [ 0 ] = 0 ; int part2_3_end = part2_start + si . ch [ ch ] . gr [ gr ] . part2_3_length ; int num_bits ; int region1Start ; int region2Start ; int index ; int buf , buf1 ; huffcodetab h ; if ( ( ( si . ch [ ch ] . gr [ gr ] . window_switching_flag ) != 0 ) && ( si . ch [ ch ] . gr [ gr ] . block_type == 2 ) ) { region1Start = ( sfreq == 8 ) ? 72 : 36 ; region2Start = 576 ; } else { buf = si . ch [ ch ] . gr [ gr ] . region0_count + 1 ; buf1 = buf + si . ch [ ch ] . gr [ gr ] . region1_count + 1 ; if ( buf1 > sfBandIndex [ sfreq ] . l . length - 1 ) buf1 = sfBandIndex [ sfreq ] . l . length - 1 ; region1Start = sfBandIndex [ sfreq ] . l [ buf ] ; region2Start = sfBandIndex [ sfreq ] . l [ buf1 ] ; } index = 0 ; for ( int i = 0 ; i < ( si . ch [ ch ] . gr [ gr ] . big_values << 1 ) ; i += 2 ) { if ( i < region1Start ) h = huffcodetab . ht [ si . ch [ ch ] . gr [ gr ] . table_select [ 0 ] ] ; else if ( i < region2Start ) h = huffcodetab . ht [ si . ch [ ch ] . gr [ gr ] . table_select [ 1 ] ] ; else h = huffcodetab . ht [ si . ch [ ch ] . gr [ gr ] . table_select [ 2 ] ] ; huffcodetab . huffman_decoder ( h , x , y , v , w , br ) ; is_1d [ index ++ ] = x [ 0 ] ; is_1d [ index ++ ] = y [ 0 ] ; CheckSumHuff = CheckSumHuff + x [ 0 ] + y [ 0 ] ; } h = huffcodetab . ht [ si . ch [ ch ] . gr [ gr ] . count1table_select + 32 ] ; num_bits = br . hsstell ( ) ; while ( ( num_bits < part2_3_end ) && ( index < 576 ) ) { huffcodetab . huffman_decoder ( h , x , y , v , w , br ) ; is_1d [ index ++ ] = v [ 0 ] ; is_1d [ index ++ ] = w [ 0 ] ; is_1d [ index ++ ] = x [ 0 ] ; is_1d [ index ++ ] = y [ 0 ] ; CheckSumHuff = CheckSumHuff + v [ 0 ] + w [ 0 ] + x [ 0 ] + y [ 0 ] ; num_bits = br . hsstell ( ) ; } if ( num_bits > part2_3_end ) { br . rewindNbits ( num_bits - part2_3_end ) ; index -= 4 ; } num_bits = br . hsstell ( ) ; if ( num_bits < part2_3_end ) br . hgetbits ( part2_3_end - num_bits ) ; if ( index < 576 ) nonzero [ ch ] = index ; else nonzero [ ch ] = 576 ; if ( index < 0 ) index = 0 ; for ( ; index < 576 ; index ++ ) is_1d [ index ] = 0 ; }
tr	7	public static boolean logIn ( String username , String password , JFrame frame ) { try { System . out . println ( "Checking username and password with my boss..." ) ; if ( username . equals ( "" ) || username . contains ( " " ) ) { JOptionPane . showMessageDialog ( frame , "The username is invalid  please try an other one." , "Invalid Username" , JOptionPane . ERROR_MESSAGE ) ; return false ; } if ( password . equals ( "" ) || password . contains ( " " ) ) { JOptionPane . showMessageDialog ( frame , "The password is invalid  please try an other one." , "Invalid Password" , JOptionPane . ERROR_MESSAGE ) ; return false ; } if ( ! getReturnString ( "req=existsPlayer&name=" + username ) ) { JOptionPane . showMessageDialog ( frame , "The player does not exits." + "Please try an other username." , "Player does not exist" , JOptionPane . ERROR_MESSAGE ) ; return false ; } if ( ! getReturnString ( "req=login&name=" + username + "&pass=" + password ) ) { JOptionPane . showMessageDialog ( frame , "The combination of username and passowrd is incorrect." + System . lineSeparator ( ) + "Please try again.'" + System . lineSeparator ( ) + "If you have forgotten your password  visit sinius15.com." , "Invalid login" , JOptionPane . ERROR_MESSAGE ) ; return false ; } } catch ( IOException e ) { e . printStackTrace ( ) ; JOptionPane . showMessageDialog ( frame , "There seems to be a problem with the connection to the server" + System . lineSeparator ( ) + "You can start the game in offline mode if you still want to play." + System . lineSeparator ( ) + "We are verry sorry for the inconvenience caused." , "Problem" , JOptionPane . ERROR_MESSAGE ) ; return false ; } return true ; }
tr	6	public void connect ( String address , int port ) throws CouldNotConnectException { logger . fine ( "Connecting to " + address + ":" + port + "..." ) ; boolean disconnected = false ; try { synchronized ( CONNECTION_LOCK ) { if ( isConnected ) { logger . fine ( "Disconnecting from " + serverAddress + ":" + serverPort + " so client can connect to " + address + ":" + port ) ; disconnectQuietly ( ) ; disconnected = true ; } else if ( isAttemptingToConnect ) { logger . fine ( "Cancelling connect request to " + serverAddress + ":" + serverPort + " so client can connect to " + address + ":" + port ) ; closeConnection ( ) ; } isAttemptingToConnect = true ; serverAddress = address ; serverInetAddress = InetAddress . getByName ( serverAddress ) ; serverPort = port ; socket = new DatagramSocket ( ) ; receivePacketThread = new ReceivePacketThread ( this , socket ) ; receivePacketThread . start ( ) ; timeoutThread = new TimeoutThread ( this , ClientConnection . CONNECT_REQUEST_TIMEOUT ) ; timeoutThread . start ( ) ; logger . finer ( "Sending connect request packet" ) ; sendPacket ( Packet . createConnectRequestPacket ( ) ) ; } } catch ( UnknownHostException e ) { closeConnection ( ) ; logger . fine ( "Could not connect due to UnknownHostException: " + e . getMessage ( ) ) ; throw new ServerNotFoundException ( address , port ) ; } catch ( SocketException e ) { closeConnection ( ) ; logger . fine ( "Could not connect due to SocketException: " + e . getMessage ( ) ) ; throw new CouldNotOpenSocketToServerException ( e ) ; } catch ( CouldNotSendPacketException e ) { closeConnection ( ) ; logger . fine ( "Could not connect due to CouldNotSendPacketException while sending connect request: " + e . getMessage ( ) ) ; throw new CouldNotSendConnectRequestException ( e ) ; } finally { if ( disconnected ) { onDisconnected ( ClientConnection . DISCONNECTED_BY_CLIENT ) ; } } }
tr	1	private BigInteger selfPowers ( int n ) { Preconditions . checkArgument ( n > 0 ) ; BigInteger acc = BigInteger . ZERO ; for ( int i = 1 ; i <= n ; i ++ ) { acc = acc . add ( BigInteger . valueOf ( i ) . pow ( i ) ) ; } return acc ; }
tr	4	@ Override public void caretUpdate ( CaretEvent e ) { Document3 doc = ( ( EditorTextArea3 ) e . getSource ( ) ) . getOmDocument ( ) ; if ( doc != null ) { if ( ( ( EditorController ) Core . getEditor ( ) ) . getCurrentTranslation ( ) != null ) { int start_trans = doc . getTranslationStart ( ) ; int end_trans = start_trans + Core . getEditor ( ) . getCurrentTranslation ( ) . length ( ) ; if ( e . getDot ( ) >= start_trans && e . getDot ( ) <= end_trans ) { sessionlog . GetLog ( ) . CaretUpdate ( e . getMark ( ) + 1 , e . getDot ( ) + 1 ) ; } } } }
tr	0	public Object getTree ( ) { return tree ; }
tr	3	void selectMoreRow ( ContainerComponent containerComponent ) { if ( libraryTable == null ) return ; for ( int i = 0 ; i < libraryTable . getRowCount ( ) ; i ++ ) { Container rowData = ( Container ) libraryTable . getValueAt ( i , - 1 ) ; if ( rowData == containerComponent . container ) { libraryTable . addRowSelectionInterval ( i , i ) ; Rectangle rect = libraryTable . getCellRect ( i , 0 , true ) ; libraryTable . scrollRectToVisible ( rect ) ; break ; } } }
tr	4	public static void main ( String args [ ] ) { try { javax . swing . UIManager . setLookAndFeel ( javax . swing . UIManager . getSystemLookAndFeelClassName ( ) ) ; } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( MainFrame . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( MainFrame . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( MainFrame . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( MainFrame . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { new MainFrame ( ) . setVisible ( true ) ; } } ) ; }
tr	8	public ImageIcon getSystemIcon ( File f , boolean large , boolean force ) { if ( f == null ) { return null ; } if ( f instanceof VirtuaDirectory ) { VirtuaDirectory vd = ( VirtuaDirectory ) f ; ImageIcon icon = vd . getIcon ( ) ; if ( icon != null ) { return icon ; } } ShellFolder sf ; try { sf = this . getShellFolder ( f ) ; } catch ( FileNotFoundException e ) { return OSUtil . getOsIcons ( ) . getDocumentIcon ( ) ; } BufferedImage img = ( BufferedImage ) sf . getIcon ( large ) ; ImageIcon icon ; if ( img != null ) { int [ ] data = ( ( DataBufferInt ) img . getData ( ) . getDataBuffer ( ) ) . getData ( ) ; int hash = Arrays . hashCode ( data ) ; if ( cache . containsKey ( hash ) && force == false ) { icon = cache . get ( hash ) ; } else { icon = new ImageIcon ( img , sf . getFolderType ( ) ) ; cache . put ( hash , icon ) ; } } else { icon = getSimpleIcon ( f ) ; } if ( icon == null ) { icon = OSUtil . getOsIcons ( ) . getDocumentIcon ( ) ; } return icon ; }
tr	6	protected String getValue ( File file , String key ) { FileInputStream fstream = null ; try { fstream = new FileInputStream ( file ) ; } catch ( FileNotFoundException e1 ) { e1 . printStackTrace ( ) ; } DataInputStream in = new DataInputStream ( fstream ) ; BufferedReader br = new BufferedReader ( new InputStreamReader ( in ) ) ; String line = null ; try { while ( ( line = br . readLine ( ) ) != null ) { String [ ] tokens = line . split ( "=" ) ; if ( tokens [ 0 ] . equalsIgnoreCase ( key ) ) { fstream . close ( ) ; if ( tokens . length > 1 ) { return tokens [ 1 ] ; } else { return "" ; } } } } catch ( IOException e ) { e . printStackTrace ( ) ; } try { fstream . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return "0" ; }
tr	1	@ Test public void testDate2 ( ) { String str = "2013-12-23 12:15:39" ; try { System . out . println ( dateObj . formart2Date ( str ) ) ; } catch ( ParseException e ) { e . printStackTrace ( ) ; } }
tr	1	private Dimension getMinimumComponentSize ( Component comp ) { if ( isScrollbar ( comp ) ) return getMinimumScrollbarSize ( comp ) ; return comp . getMinimumSize ( ) ; }
tr	2	public void update ( ) { super . update ( ) ; if ( this . isClicked ( ) && ( Timer . getTime ( ) - this . lastClick ) > 200 ) { this . state = ! this . state ; this . lastClick = Timer . getTime ( ) ; } }
tr	8	public static Object newProxyInstance ( class < ? > superclass , class < ? > [ ] interfaces , InvocationHandler h ) throws ExportException { HandlerAdapter ha = new HandlerAdapter ( h , superclass , interfaces ) ; if ( interfaces != null ) { class < ? > [ ] source = interfaces ; interfaces = new class < ? > [ source . length + 1 ] ; System . arraycopy ( source , 0 , interfaces , 1 , source . length ) ; } else { interfaces = new class < ? > [ 1 ] ; } interfaces [ 0 ] = CGILibSerializableProxy . class ; try { superclass . getDeclaredConstructor ( new class < ? > [ ] { } ) ; } catch ( NoSuchMethodException nsme ) { throw new ExportException ( "Can't export " + superclass . getName ( ) + " because it doesn't define a no arg constructor. Try exporting with specified service interfaces" , nsme ) ; } Enhancer e = new Enhancer ( ) ; e . setClassLoader ( JMSRemoteSystem . INSTANCE . getUserClassLoader ( ha ) ) ; e . setSuperclass ( superclass ) ; e . setInterfaces ( interfaces ) ; e . setCallback ( ha ) ; Object obj = e . create ( ) ; generatedClasses . put ( obj . getClass ( ) , null ) ; return obj ; }
tr	7	public void connect2 ( TreeLinkNode root ) { if ( root == null ) return ; if ( root . left == null && root . right == null ) return ; TreeLinkNode cur = root ; TreeLinkNode sibling ; TreeLinkNode next = null ; while ( cur != null && cur . left != null ) { next = cur . left ; while ( cur != null ) { if ( cur . next != null ) sibling = cur . next . left ; else sibling = null ; cur . left . next = cur . right ; cur . right . next = sibling ; cur = cur . next ; } cur = next ; } }
tr	2	public static boolean isBitMarked ( byte bitmask , int number ) { if ( number < 2 || number > 9 ) { return false ; } else { boolean returnvalue = ( BITMAP [ number - 2 ] & bitmask ) == BITMAP [ number - 2 ] ; return returnvalue ; } }
tr	5	public final boolean isValidRate ( final String rate ) { final String methodName = "isValidRate" ; DatabaseLogger . entering ( CLASS_NAME , methodName , rate ) ; boolean validRate = true ; if ( isEmptyValue ( rate ) ) { validRate = false ; } else if ( ! rate . startsWith ( "$" ) ) { validRate = false ; } else { try { final String rateAmount = rate . substring ( 1 ) ; double rateDouble = double . parseDouble ( rateAmount ) ; if ( ( rateDouble <= 0 ) || ( rateDouble > DatabaseConstants . MAX_RATE_VALUE ) ) { validRate = false ; } } catch ( NumberFormatException e ) { validRate = false ; } } DatabaseLogger . exiting ( CLASS_NAME , methodName , validRate ) ; return validRate ; }
tr	5	private void showPlayerInfo ( ArrayList < PokerPlayer > pokerPlayers , boolean showCards ) { for ( int i = 0 ; i < pokerPlayers . size ( ) ; i ++ ) { PokerPlayer player = pokerPlayers . get ( i ) ; if ( i == 0 ) { this . setPlayerInfo ( player , lblPlayer1 , imgPlayer1FirstCard , imgPlayer1SecondCard , showCards ) ; } if ( i == 1 ) { this . setPlayerInfo ( player , lblPlayer2 , imgPlayer2FirstCard , imgPlayer2SecondCard , showCards ) ; } if ( i == 2 ) { this . setPlayerInfo ( player , lblPlayer3 , imgPlayer3FirstCard , imgPlayer3SecondCard , showCards ) ; } if ( i == 3 ) { this . setPlayerInfo ( player , lblPlayer4 , imgPlayer4FirstCard , imgPlayer4SecondCard , showCards ) ; } } }
tr	4	private boolean transferBounds ( boolean checkPrefChange ) { comp . setBounds ( x , y , w , h ) ; if ( checkPrefChange && w != horSizes [ LayoutUtil . PREF ] ) { BoundSize vSz = cc . getVertical ( ) . getSize ( ) ; if ( vSz . getPreferred ( ) == null ) { if ( comp . getPreferredHeight ( - 1 ) != verSizes [ LayoutUtil . PREF ] ) return true ; } } return false ; }
tr	0	@ BeforeMethod public void setUp ( ) throws Exception { MockitoAnnotations . initMocks ( this ) ; crudService = Mockito . mock ( CelebPlannerCrudService . class ) ; }
tr	7	public void put ( String key , MqttPersistable message ) throws MqttPersistenceException { checkIsOpen ( ) ; File file = new File ( clientDir , key + MESSAGE_FILE_EXTENSION ) ; File backupFile = new File ( clientDir , key + MESSAGE_FILE_EXTENSION + MESSAGE_BACKUP_FILE_EXTENSION ) ; if ( file . exists ( ) ) { boolean result = file . renameTo ( backupFile ) ; if ( ! result ) { backupFile . delete ( ) ; file . renameTo ( backupFile ) ; } } try { FileOutputStream fos = new FileOutputStream ( file ) ; fos . write ( message . getHeaderBytes ( ) , message . getHeaderOffset ( ) , message . getHeaderLength ( ) ) ; if ( message . getPayloadBytes ( ) != null ) { fos . write ( message . getPayloadBytes ( ) , message . getPayloadOffset ( ) , message . getPayloadLength ( ) ) ; } fos . getFD ( ) . sync ( ) ; fos . close ( ) ; if ( backupFile . exists ( ) ) { backupFile . delete ( ) ; } } catch ( IOException ex ) { throw new MqttPersistenceException ( ex ) ; } finally { if ( backupFile . exists ( ) ) { boolean result = backupFile . renameTo ( file ) ; if ( ! result ) { file . delete ( ) ; backupFile . renameTo ( file ) ; } } } }
tr	6	public void setMarker ( int marker ) { if ( marker != MARKER_HIDE && marker != MARKER_FULL_CIRCLE && marker != MARKER_HOLLOW_CIRCLE && marker != MARKER_FULL_SQUARE && marker != MARKER_HOLLOW_SQUARE ) return ; if ( marker == this . marker ) return ; this . marker = marker ; this . icon = generateImageIcon ( ) ; }
tr	7	@ Override public boolean validateData ( ) { code = textFieldCode . getText ( ) . trim ( ) ; names = textFieldNames . getText ( ) . trim ( ) ; birthday = dateChooserBirthday . getDate ( ) ; email = textFieldEmail . getText ( ) . trim ( ) ; String key ; if ( code . length ( ) == 0 ) { key = "app.warning.teacher.code.empty" ; log . warn ( key ) ; Toast . makeText ( this , resourceBundleHelper . getString ( key ) , Toast . Style . WARNING ) . display ( ) ; selectTextField ( textFieldCode ) ; return false ; } if ( DialogAction . INSERT . equals ( dialogAction ) ) { if ( teacherController . existsCode ( code ) ) { key = "app.warning.teacher.code.already.exists" ; log . warn ( key ) ; Toast . makeText ( this , resourceBundleHelper . getString ( key ) , Toast . Style . WARNING ) . display ( ) ; selectTextField ( textFieldCode ) ; return false ; } } if ( names . length ( ) == 0 ) { key = "app.warning.teacher.name.empty" ; log . warn ( key ) ; Toast . makeText ( this , resourceBundleHelper . getString ( key ) , Toast . Style . WARNING ) . display ( ) ; selectTextField ( textFieldNames ) ; return false ; } if ( birthday == null ) { key = "app.warning.teacher.birthday.empty" ; log . warn ( key ) ; Toast . makeText ( this , resourceBundleHelper . getString ( key ) , Toast . Style . WARNING ) . display ( ) ; dateChooserBirthday . requestFocusInWindow ( ) ; return false ; } if ( email . length ( ) == 0 ) { key = "app.warning.teacher.email.empty" ; log . warn ( key ) ; Toast . makeText ( this , resourceBundleHelper . getString ( key ) , Toast . Style . WARNING ) . display ( ) ; selectTextField ( textFieldEmail ) ; return false ; } if ( ! isCorrectEmailFormat ( email ) ) { key = "app.warning.teacher.email.wrong.format" ; log . warn ( key ) ; Toast . makeText ( this , resourceBundleHelper . getString ( key ) , Toast . Style . WARNING ) . display ( ) ; selectTextField ( textFieldEmail ) ; return false ; } return true ; }
tr	5	public void changeSupplier ( String id , String newSupplier ) { String oldSupplier = getSupplierName ( id ) ; if ( oldSupplier == newSupplier ) { return ; } if ( oldSupplier == null ) { addItem ( id , newSupplier ) ; } if ( suppliers . indexOf ( oldSupplier ) > - 1 ) { int oindex = suppliers . indexOf ( oldSupplier ) ; if ( supplierItems . get ( oindex ) . indexOf ( id ) > - 1 ) { int nindex = supplierItems . get ( oindex ) . indexOf ( id ) ; int addIndex = suppliers . indexOf ( newSupplier ) ; supplierItems . get ( oindex ) . remove ( nindex ) ; if ( addIndex > - 1 ) { supplierItems . get ( addIndex ) . add ( id ) ; } } } }
tr	2	public void actualizarSolicitudes ( LinkedList < solicitud > lista , usuario usuario , String username ) { String contenido = "<solicitudes>\n" ; contenido += "<solicitud>\n<usuario>" + usuario . usuario + "</usuario>\n<nombre>" + usuario . nombre + "</nombre>\n</solicitud>\n" ; if ( lista != null ) { Iterator < solicitud > itC = lista . iterator ( ) ; while ( itC . hasNext ( ) ) { solicitud listaC = itC . next ( ) ; contenido += "<solicitud>\n<usuario>" + listaC . getUsuario ( ) + "</usuario>\n<nombre>" + listaC . getNombre ( ) + "</nombre>\n</solicitud>\n" ; } } contenido += "</solicitudes>" ; System . out . println ( "update lista: " + contenido ) ; escribirArchivo ( dir_solicitudes + username + ".xml" , contenido ) ; }
tr	2	private void appendException ( Throwable e , StringBuilder sb ) { sb . append ( "    Exception: " ) ; sb . append ( e . toString ( ) ) ; sb . append ( endLine ) ; sb . append ( "    Stack trace:" + endLine ) ; StackTraceElement [ ] stkElements = e . getStackTrace ( ) ; for ( StackTraceElement stkFrame : stkElements ) { sb . append ( "        in " + stkFrame . getClassName ( ) + "." + stkFrame . getMethodName ( ) + " " ) ; sb . append ( "at " + stkFrame . getFileName ( ) + ":" + stkFrame . getLineNumber ( ) ) ; sb . append ( endLine ) ; } if ( e . getCause ( ) != null ) { appendException ( e . getCause ( ) , sb ) ; } }
tr	0	public void setI ( float i ) { this . i = i ; }
tr	1	public Session ( String user , String docName , boolean start ) { this . requestQueue = new LinkedList < Request > ( ) ; this . requestLog = new HashMap < String , List < Request >> ( ) ; this . docMod = new HashSet < Request > ( ) ; this . docName = docName ; this . currentState = new StateVector ( ) ; this . userName = user ; this . docText = "" ; running = false ; listeners = new Vector < ChangeListener > ( ) ; sessionThread = new Thread ( this ) ; if ( start ) start ( ) ; }
tr	3	public void switchFullscreen ( ) { if ( fullscreen == false ) { throw new IllegalStateException ( "This window not supports fullscreen mode!" ) ; } if ( state == WindowState . WINDOW ) { Rectangle rc = this . getBounds ( ) ; boolean resizable = this . isResizable ( ) ; this . properties = new FrameProperties ( getX ( ) , getY ( ) , ( int ) rc . getWidth ( ) , ( int ) rc . getHeight ( ) , resizable ) ; } if ( device . getFullScreenWindow ( ) == null ) { FrameProperties properties = new FrameProperties ( 0 , 0 , getFullWidth ( ) , getFullHeight ( ) , false ) ; this . setExtendedState ( JFrame . MAXIMIZED_BOTH ) ; this . state = WindowState . FULLSCREEN ; properties . append ( this ) ; device . setFullScreenWindow ( this ) ; updateDisplay ( ) ; return ; } device . setFullScreenWindow ( null ) ; this . setExtendedState ( JFrame . NORMAL ) ; this . state = WindowState . WINDOW ; properties . append ( this ) ; updateDisplay ( ) ; }
tr	7	public boolean searchMatrix2 ( int [ ] [ ] matrix , int target ) { if ( matrix == null || matrix . length == 0 || matrix [ 0 ] . length == 0 ) return false ; int row = matrix . length ; int col = matrix [ 0 ] . length ; int x = 0 ; int y = col - 1 ; while ( x <= row - 1 && y >= 0 ) { if ( matrix [ x ] [ y ] == target ) return true ; else if ( matrix [ x ] [ y ] < target ) { x ++ ; } else { y -- ; } } return false ; }
tr	5	private boolean r_i_verb_suffix ( ) { int among_var ; int v_1 ; int v_2 ; v_1 = limit - cursor ; if ( cursor < I_pV ) { return false ; } cursor = I_pV ; v_2 = limit_backward ; limit_backward = cursor ; cursor = limit - v_1 ; ket = cursor ; among_var = find_among_b ( a_5 , 35 ) ; if ( among_var == 0 ) { limit_backward = v_2 ; return false ; } bra = cursor ; switch ( among_var ) { case 0 : limit_backward = v_2 ; return false ; case 1 : if ( ! ( out_grouping_b ( g_v , 97 , 251 ) ) ) { limit_backward = v_2 ; return false ; } slice_del ( ) ; break ; } limit_backward = v_2 ; return true ; }
tr	0	protected void start ( ) { start ( null ) ; }
tr	7	@ Override public long [ ] getLongData ( ) { if ( ptr != 0 ) { return null ; } else { if ( isConstant ( ) ) { if ( length > getMaxSizeOf32bitArray ( ) ) return null ; long [ ] out = new long [ ( int ) length ] ; long elem = ( long ) ( data [ 0 ] != null ? data [ 0 ] . length ( ) : 0 ) ; for ( int i = 0 ; i < length ; i ++ ) { out [ i ] = elem ; } return out ; } else { long [ ] res = new long [ ( int ) length ] ; for ( int i = 0 ; i < length ; i ++ ) { res [ i ] = ( long ) ( data [ i ] != null ? data [ i ] . length ( ) : 0 ) ; } return res ; } } }
tr	2	public void makeTDs ( ) { ArrayList < Goal > levelGoals = level . goals ; for ( int i = 0 ; i < levelGoals . size ( ) ; i ++ ) { Goal goal = levelGoals . get ( i ) ; if ( goal . td == null ) { TaskDispenser td = new TaskDispenser ( goal , level ) ; taskDispensers . add ( td ) ; } } }
tr	7	@ Override public void itemStateChanged ( ItemEvent e ) { Object source = e . getSource ( ) ; if ( source == m_add ) { m_tensorPanel . setTypeChangeEnabled ( true ) ; m_disp . setMajorMode ( PvDisplayIf . MODE_INITIAL_PICK ) ; System . out . println ( "click into the display to add a feature" ) ; } else if ( source == m_remove ) { m_tensorPanel . setTypeChangeEnabled ( false ) ; m_disp . setMajorMode ( PvDisplayIf . MODE_PICK ) ; System . out . println ( "click near a feature to remove it" ) ; } else if ( source == m_select ) { m_tensorPanel . setTypeChangeEnabled ( false ) ; m_disp . setMajorMode ( PvDisplayIf . MODE_PICK ) ; System . out . println ( "click near a feature to select it" ) ; } else if ( source == m_flowReflect ) { updateVectorField ( ) ; } else if ( source == m_showSeparatrices ) { if ( m_showSeparatrices . getState ( ) ) { m_disp . addGeometry ( m_separatrices ) ; } else { m_disp . removeGeometry ( m_separatrices ) ; } m_disp . update ( m_separatrices ) ; } else if ( source == m_direction ) { updateVectorField ( ) ; } else { assert false : "Unhandled item changed: " + source ; } }
tr	5	public boolean switchProposal ( boolean forward ) { if ( forward ) { this . myCurrentProposalRR = BootstrapRRList . getInstance ( ) . getNextRR ( ) ; } else { this . myCurrentProposalRR = BootstrapRRList . getInstance ( ) . getPreviousRR ( ) ; } if ( this . myCurrentProposalRR == null ) { return false ; } String i1 = Integer . toBinaryString ( this . myCurrentProposalRR . getBinaryCounter ( ) ) ; while ( i1 . length ( ) < this . getBinaryCounterSize ( ) ) { i1 = "0" + i1 ; } for ( int i = 0 ; i < this . getBinaryCounterSize ( ) ; i ++ ) { boolean propose = i1 . charAt ( i ) == 1 ? true : false ; Policy . getInstance ( ) . getDataColumnByIndex ( i ) . setIsPropose ( propose ) ; } return true ; }
tr	2	public static List < InputNeuron > getInputNeurons ( ILayer layer ) { List < InputNeuron > neurons = new ArrayList < InputNeuron > ( ) ; for ( INeuron neuron : layer . getNeurons ( ) ) { if ( neuron instanceof InputNeuron ) neurons . add ( ( InputNeuron ) neuron ) ; } return neurons ; }
tr	1	private void quickSort ( int [ ] data , int low , int high , int order , Random random ) { if ( low < high ) { int sentry = partition ( data , low , high , order , random ) ; quickSort ( data , low , sentry - 1 , order , random ) ; quickSort ( data , sentry + 1 , high , order , random ) ; } }
tr	2	public BacklogBean loadId ( BacklogBean oBacklog ) throws ServletException { try { if ( request . getParameter ( "id" ) != null ) { oBacklog . setId ( Integer . parseInt ( request . getParameter ( "id" ) ) ) ; } else { oBacklog . setId ( 0 ) ; } } catch ( NumberFormatException e ) { throw new ServletException ( "Controller: Error: loadId: Formato de datos en par\u00E1metros incorrecto " + e . getMessage ( ) ) ; } return oBacklog ; }
tr	3	public void initPanel ( ) { this . removeAll ( ) ; texte_options . setForeground ( Color . BLACK ) ; texte_options . setFont ( new Font ( "Droid Serif" , Font . ITALIC | Font . BOLD , 40 ) ) ; texte_options . setBounds ( 360 , 20 , 500 , 50 ) ; texte . setFont ( new Font ( "Droid Serif" , Font . ITALIC | Font . BOLD , 15 ) ) ; texte2 . setFont ( new Font ( "Droid Serif" , Font . ITALIC | Font . BOLD , 15 ) ) ; texte3 . setFont ( new Font ( "Droid Serif" , Font . ITALIC | Font . BOLD , 15 ) ) ; spinner . setModel ( new SpinnerNumberModel ( fenetre . getModele ( ) . getOptions ( ) . getTailleGrille ( ) , 10 , 20 , 1 ) ) ; switch ( fenetre . getModele ( ) . getOptions ( ) . getNiveauIA ( ) ) { case FACILE : rb_facile . setSelected ( true ) ; break ; case MOYEN : rb_moyen . setSelected ( true ) ; break ; case DIFFICILE : rb_difficile . setSelected ( true ) ; break ; } pan . setLayout ( new GridLayout ( 6 , 1 ) ) ; pan . setBounds ( 50 , 110 , 400 , 410 ) ; pan2 . setLayout ( null ) ; pan2 . setBounds ( 480 , 110 , 360 , 150 ) ; pan3 . setLayout ( null ) ; pan3 . setBounds ( 480 , 300 , 360 , 220 ) ; texte2 . setBounds ( 10 , 10 , 400 , 20 ) ; spinner . setBounds ( 150 , 50 , 60 , 40 ) ; texte3 . setBounds ( 10 , 10 , 300 , 20 ) ; rb_facile . setBounds ( 20 , 50 , 100 , 20 ) ; rb_facile . setBackground ( null ) ; rb_moyen . setBounds ( 20 , 100 , 100 , 20 ) ; rb_moyen . setBackground ( null ) ; rb_difficile . setBounds ( 20 , 150 , 100 , 20 ) ; rb_difficile . setBackground ( null ) ; b_retour . setBounds ( 10 , 550 , 100 , 50 ) ; b_jouer . setBounds ( 780 , 550 , 100 , 50 ) ; bg . add ( rb_facile ) ; bg . add ( rb_moyen ) ; bg . add ( rb_difficile ) ; check1 . setFocusable ( false ) ; check2 . setFocusable ( false ) ; check3 . setFocusable ( false ) ; check4 . setFocusable ( false ) ; check5 . setFocusable ( false ) ; getCoches ( ) ; check1 . setState ( coches [ 0 ] ) ; check2 . setState ( coches [ 1 ] ) ; check3 . setState ( coches [ 2 ] ) ; check4 . setState ( coches [ 3 ] ) ; check5 . setState ( coches [ 4 ] ) ; pan . add ( texte ) ; pan . add ( check1 ) ; pan . add ( check2 ) ; pan . add ( check3 ) ; pan . add ( check4 ) ; pan . add ( check5 ) ; pan2 . add ( texte2 ) ; pan2 . add ( spinner ) ; pan3 . add ( texte3 ) ; pan3 . add ( rb_facile ) ; pan3 . add ( rb_moyen ) ; pan3 . add ( rb_difficile ) ; this . add ( texte_options ) ; this . add ( pan ) ; this . add ( pan2 ) ; this . add ( pan3 ) ; this . add ( b_jouer ) ; this . add ( b_retour ) ; }
tr	0	public void initUI ( ) { connect ( new Window . DeleteEvent ( ) { public boolean onDeleteEvent ( Widget source , Event event ) { mode = const . QUIT_MODE ; Gtk . mainQuit ( ) ; return false ; } } ) ; initButtons ( ) ; initLabels ( ) ; initEntries ( ) ; initImages ( ) ; }
tr	3	@ Override public void update ( Observable o , Object o1 ) { if ( o . getClass ( ) == FachadaInterfaz . class && o1 . equals ( "Convenio" ) ) { try { setTableConvenios ( ) ; } catch ( ParseException ex ) { Logger . getLogger ( MantenimientoConvenio . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } } }
tr	3	private void setField ( String propertyName , Object value , Object target ) throws IllegalAccessException { final class targetClass = target . getClass ( ) ; final Field field = getField ( targetClass , propertyName ) ; if ( null != field ) { if ( field . getType ( ) . isAssignableFrom ( value . getClass ( ) ) ) { field . setAccessible ( true ) ; field . set ( target , value ) ; } } else { log . debug ( "field '{}' does not exist on {}" , new Object [ ] { propertyName , targetClass } ) ; if ( Collection . class . isAssignableFrom ( targetClass ) ) { log . debug ( "{} is a Collection" , targetClass ) ; ( ( Collection ) target ) . add ( value ) ; } else { log . debug ( "{} NOT is a Collection" , targetClass ) ; } } }
tr	0	private byte [ ] toBytes ( String s ) { return s . getBytes ( ) ; }
tr	2	private void setSelected ( Component e ) { if ( selected != null ) selected . setSelected ( false ) ; selected = e ; if ( selected != null ) selected . setSelected ( true ) ; repaint ( ) ; }
tr	0	public void setGame ( Game game ) { this . game = game ; }
tr	3	public void set ( ProfesorBean oProfesorBean ) throws Exception { try { oMysql . conexion ( enumTipoConexion ) ; oMysql . initTrans ( ) ; if ( oProfesorBean . getId ( ) == 0 ) { oProfesorBean . setId ( oMysql . insertOne ( "profesor" ) ) ; } oMysql . updateOne ( oProfesorBean . getId ( ) , "profesor" , "id_usuario" , Integer . toString ( oProfesorBean . getId_usuario ( ) ) ) ; oMysql . updateOne ( oProfesorBean . getId ( ) , "profesor" , "dni" , oProfesorBean . getDni ( ) ) ; oMysql . updateOne ( oProfesorBean . getId ( ) , "profesor" , "nombre" , oProfesorBean . getNombre ( ) ) ; oMysql . updateOne ( oProfesorBean . getId ( ) , "profesor" , "ape1" , oProfesorBean . getApe1 ( ) ) ; oMysql . updateOne ( oProfesorBean . getId ( ) , "profesor" , "ape2" , oProfesorBean . getApe2 ( ) ) ; oMysql . updateOne ( oProfesorBean . getId ( ) , "profesor" , "sexo" , oProfesorBean . getSexo ( ) ) ; oMysql . updateOne ( oProfesorBean . getId ( ) , "profesor" , "telefono" , oProfesorBean . getTelefono ( ) ) ; oMysql . updateOne ( oProfesorBean . getId ( ) , "profesor" , "email" , oProfesorBean . getEmail ( ) ) ; if ( oProfesorBean . getId_usuario ( ) > 0 ) { oMysql . updateOne ( oProfesorBean . getId_usuario ( ) , "usuario" , "password" , oProfesorBean . getPassword ( ) ) ; oMysql . updateOne ( oProfesorBean . getId_usuario ( ) , "usuario" , "login" , oProfesorBean . getLogin ( ) ) ; } else { oMysql . setNull ( oProfesorBean . getId_usuario ( ) , "usuario" , "password" ) ; oMysql . setNull ( oProfesorBean . getId_usuario ( ) , "usuario" , "login" ) ; } oMysql . commitTrans ( ) ; } catch ( Exception e ) { oMysql . rollbackTrans ( ) ; throw new Exception ( "ProfesorDao.setProfesor: Error: " + e . getMessage ( ) ) ; } finally { oMysql . desconexion ( ) ; } }
tr	8	public void run ( ) { ParallelWarteClass paraWait = new ParallelWarteClass ( 10000 ) ; paraWait . start ( ) ; while ( ! ( HWaccess . readInt ( Adressen . LaufbandAusgang . ordinal ( ) ) == 1 ) && paraWait . isAlive ( ) ) { try { Thread . sleep ( 150 ) ; } catch ( InterruptedException e ) { interrupt ( ) ; } } if ( ! paraWait . isAlive ( ) ) { interrupt ( ) ; return ; } else { paraWait . interrupt ( ) ; } paraWait = new ParallelWarteClass ( 10000 ) ; paraWait . start ( ) ; while ( ! ( HWaccess . readInt ( Adressen . LaufbandAusgang . ordinal ( ) ) == 0 ) && paraWait . isAlive ( ) ) { try { Thread . sleep ( 150 ) ; } catch ( InterruptedException e ) { this . interrupt ( ) ; } } if ( ! paraWait . isAlive ( ) ) { interrupt ( ) ; } else { paraWait . interrupt ( ) ; } result = true ; }
tr	1	public synchronized Date getDateObjectStored ( String key ) { IRecord rec = objects . get ( key ) ; return rec == null ? null : rec . getDate ( ) ; }
tr	9	public void distribuerMessageConversation ( MessageConversation message ) throws RemoteException { try { ArrayList < Groupe > groupes = message . getGroupesParticipants ( ) ; ArrayList < String > utilisateursDistribues = new ArrayList < String > ( ) ; if ( groupes != null ) { for ( Groupe g : groupes ) { ArrayList < Utilisateur > utilisateurs = g . getUtilisateurs ( ) ; for ( Utilisateur u : utilisateurs ) { if ( ! utilisateursDistribues . contains ( u . getLogin ( ) ) ) { Client client = getClientConnecte ( u . getLogin ( ) ) ; if ( client != null ) { client . recevoirMessage ( message ) ; } else { if ( getConversationsUtilisateurAbsent ( u . getLogin ( ) ) == null ) { getConversationsUtilisateursAbsents ( ) . put ( u . getLogin ( ) , new ArrayList < Conversation > ( ) ) ; } if ( getConversation ( u . getLogin ( ) , message . getIdConversation ( ) ) == null ) { ArrayList < Conversation > conversations = getConversationsUtilisateurAbsent ( u . getLogin ( ) ) ; conversations . add ( getConversations ( ) . get ( message . getIdConversation ( ) ) ) ; } Conversation c = getConversation ( u . getLogin ( ) , message . getIdConversation ( ) ) ; c . getListeMessages ( ) . add ( message ) ; } utilisateursDistribues . add ( u . getLogin ( ) ) ; } } } } ArrayList < Utilisateur > utilisateurs = message . getParticipants ( ) ; if ( utilisateurs != null ) { for ( Utilisateur u : utilisateurs ) { if ( ! utilisateursDistribues . contains ( u . getLogin ( ) ) ) { Client client = getClientConnecte ( u . getLogin ( ) ) ; if ( client != null ) { client . recevoirMessage ( message ) ; } else { if ( getConversationsUtilisateurAbsent ( u . getLogin ( ) ) == null ) { getConversationsUtilisateursAbsents ( ) . put ( u . getLogin ( ) , new ArrayList < Conversation > ( ) ) ; } if ( getConversation ( u . getLogin ( ) , message . getIdConversation ( ) ) == null ) { ArrayList < Conversation > conversations = getConversationsUtilisateurAbsent ( u . getLogin ( ) ) ; conversations . add ( new Conversation ( message . getIdConversation ( ) , message . getParticipants ( ) , message . getGroupesParticipants ( ) ) ) ; } Conversation c = getConversation ( u . getLogin ( ) , message . getIdConversation ( ) ) ; c . getListeMessages ( ) . add ( message ) ; } utilisateursDistribues . add ( u . getLogin ( ) ) ; } } } } catch ( RemoteException e1 ) { e1 . printStackTrace ( ) ; } }
tr	4	private String readURL ( String url ) { URL myuri ; try { myuri = new URL ( url ) ; } catch ( MalformedURLException e ) { e . printStackTrace ( ) ; return null ; } BufferedReader in ; try { in = new BufferedReader ( new InputStreamReader ( myuri . openStream ( ) ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; return null ; } String inputLine ; String acc = "" ; try { while ( ( inputLine = in . readLine ( ) ) != null ) acc += inputLine + "\n" ; in . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; return null ; } return acc ; }
