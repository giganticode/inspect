va	2	public static void main ( String [ ] args ) { double a ; Scanner input = new Scanner ( System . in ) ; int T = input . nextInt ( ) ; for ( int i = 0 ; i < T ; i ++ ) { a = input . nextDouble ( ) ; for ( int j = 0 ; j < a ; j ++ ) input . nextInt ( ) ; System . out . println ( a * ( a - 1 ) / 2 ) ; } }
va	9	@ Override public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( obj == null ) { return false ; } if ( getClass ( ) != obj . getClass ( ) ) { return false ; } CreateCommandEvent other = ( CreateCommandEvent ) obj ; if ( name == null ) { if ( other . name != null ) { return false ; } } else if ( ! name . equals ( other . name ) ) { return false ; } if ( opcode == null ) { if ( other . opcode != null ) { return false ; } } else if ( ! opcode . equals ( other . opcode ) ) { return false ; } return true ; }
va	1	private void incrementAge ( ) { age ++ ; if ( age > MAX_AGE ) { setDead ( ) ; } }
va	6	double getRow ( double latitudeInDegrees ) { double sine = Math . sin ( latitudeInDegrees * Math . PI / 180.0 ) ; if ( sine <= - 1.0 ) { return 0 ; } if ( sine <= - 0.8 ) { return n * Math . sqrt ( 5 * ( 1 + sine ) ) ; } if ( sine <= - 0.3 ) { return n * ( - 1.0 + 3.0 * Math . sqrt ( 10.0 / 9.0 * ( 1.2 + sine ) ) ) ; } if ( sine <= 0.3 ) { return n * ( 2.5 + 0.5 * sine / 0.3 ) ; } if ( sine <= 0.8 ) { return n * ( 6.0 - 3.0 * Math . sqrt ( 10.0 / 9.0 * ( 1.2 - sine ) ) ) ; } if ( sine <= 1.0 ) { return n * ( 5.0 - Math . sqrt ( 5 * ( 1 - sine ) ) ) ; } return 5 * n ; }
va	7	private TimeSerieRange findBiggestTimeSerieRange ( ) { if ( this . timeSeriesConfigs != null ) { TimeSerieRange result = new TimeSerieRange ( ) ; if ( this . timeSeriesConfigs . size ( ) >= 1 ) { TimeSerieRange tscRange = this . timeSeriesConfigs . get ( 0 ) . getTimeSerie ( ) . getRange ( ) ; result . setMinX ( tscRange . getMinX ( ) ) ; result . setMaxX ( tscRange . getMaxX ( ) ) ; result . setMinY ( tscRange . getMinY ( ) ) ; result . setMaxY ( tscRange . getMaxY ( ) ) ; } for ( TimeSerieConfig tsc : this . timeSeriesConfigs ) { TimeSerieRange tscRange = tsc . getTimeSerie ( ) . getRange ( ) ; if ( tscRange . getMinX ( ) < result . getMinX ( ) ) { result . setMinX ( tscRange . getMinX ( ) ) ; } if ( tscRange . getMinY ( ) < result . getMinY ( ) ) { result . setMinY ( tscRange . getMinY ( ) ) ; } if ( tscRange . getMaxX ( ) > result . getMaxX ( ) ) { result . setMaxX ( tscRange . getMaxX ( ) ) ; } if ( tscRange . getMaxY ( ) > result . getMaxY ( ) ) { result . setMaxY ( tscRange . getMaxY ( ) ) ; } } return result ; } return null ; }
va	5	@ Test public void returnsLinkedList ( ) { for ( int i = 0 ; i < 2048 ; i ++ ) tree . add ( i ) ; LinkedList < Integer > list = tree . toLinkedList ( ) ; boolean test = true ; for ( int i = 0 ; i < 2048 ; i ++ ) { test = false ; list . reset ( ) ; while ( list . hasNext ( ) ) { int j = list . getNext ( ) ; if ( j == i ) { test = true ; break ; } } if ( ! test ) break ; } assertTrue ( test ) ; }
va	4	@ Command ( aliases = { "global" , "g" } , usage = "[port] <true/false>" , flags = "" , desc = "Sets whether this port uses the global configuration." , help = "Should this use the global config?" , min = 1 , max = 2 ) @ CommandPermissions ( "jumpports.admin.global" ) @ Console public static void global ( CommandContext args , CommandSender sender ) throws CommandException { if ( JumpPorts . getPort ( args . getString ( 0 ) ) != null ) { JumpPort port = JumpPorts . getPort ( args . getString ( 0 ) ) ; if ( args . argsLength ( ) == 1 ) { if ( port . isUseGlobalConfig ( ) ) { port . setUseGlobalConfig ( false ) ; sender . sendMessage ( Lang . get ( "commands.useGlobalConfig.disabled" ) . replaceAll ( "%N" , port . getName ( ) ) ) ; } else { port . setUseGlobalConfig ( true ) ; sender . sendMessage ( Lang . get ( "commands.useGlobalConfig.enabled" ) . replaceAll ( "%N" , port . getName ( ) ) ) ; } } else { if ( args . getString ( 1 ) . startsWith ( "t" ) ) { port . setUseGlobalConfig ( true ) ; sender . sendMessage ( Lang . get ( "commands.useGlobalConfig.enabled" ) . replaceAll ( "%N" , port . getName ( ) ) ) ; } else { port . setUseGlobalConfig ( false ) ; sender . sendMessage ( Lang . get ( "commands.useGlobalConfig.disabled" ) . replaceAll ( "%N" , port . getName ( ) ) ) ; } } } else { sender . sendMessage ( Lang . get ( "exceptions.portDoesntExist" ) . replaceAll ( "%N" , args . getString ( 0 ) ) ) ; } }
va	5	static boolean isConvex ( Point [ ] [ ] polyhedron ) { for ( Point [ ] face : polyhedron ) { Point normal = getNormal ( face ) ; for ( Point [ ] otherface : polyhedron ) { if ( face != otherface ) for ( Point p : otherface ) { double d = p . subtract ( face [ 0 ] ) . . ( normal ) ; if ( d > EPS ) return false ; } } } return true ; }
va	9	public static void main ( String args [ ] ) { planes = new ArrayList < PlanCliente > ( ) ; lea = new Scanner ( System . in ) ; int op ; do { System . out . println ( "MENU PRINCIPAL PARA " + PlanCliente . COMPANIA_TELEFONICA ) ; System . out . println ( "1-Agregar Plan" ) ; System . out . println ( "2-Buscar Cliente" ) ; System . out . println ( "3-Cobros" ) ; System . out . println ( "4-Agregar Amigo" ) ; System . out . println ( "5-Imprimir todo" ) ; System . out . println ( "6-Salir" ) ; System . out . println ( "\nEscoja Opcion: " ) ; op = lea . nextInt ( ) ; switch ( op ) { case 1 : System . out . println ( "Ingrese Nombre plan (AMIGOS) o (BLACKBERRY): " ) ; String plan = lea . next ( ) ; if ( plan . equalsIgnoreCase ( "AMIGOS" ) ) agregarPlan ( TipoPlan . AMIGOS ) ; else if ( plan . equalsIgnoreCase ( "BLACKBERRY" ) ) agregarPlan ( TipoPlan . BLACKBERRY ) ; else System . out . println ( "PLAN INCORRECTO" ) ; break ; case 2 : System . out . println ( "CLiente: " ) ; String c = lea . next ( ) ; if ( buscarCliente ( c ) ) System . out . println ( "Si EXISTE" ) ; else System . out . println ( "NO EXISTE" ) ; break ; case 3 : cobros ( ) ; break ; case 4 : System . out . print ( "Numero Celular del cliente: " ) ; int nc = lea . nextInt ( ) ; System . out . print ( "Numero Celular de Amigo: " ) ; int amigo = lea . nextInt ( ) ; if ( agregarAmigo ( nc , amigo ) ) System . out . println ( "Se agrego amigo" ) ; else System . out . println ( "NO SE PUDO agregar amigo" ) ; break ; case 5 : imprimir ( ) ; break ; } } while ( op != 6 ) ; }
va	8	private static String maximumSequence ( int [ ] dist , int [ ] prof , int k ) { int n = dist . length ; int [ ] maxes = new int [ n ] ; ArrayList < ArrayList < Integer >> arrayMaxes = new ArrayList < ArrayList < Integer >> ( ) ; for ( int i = 0 ; i < n ; i ++ ) { arrayMaxes . add ( new ArrayList < Integer > ( ) ) ; } for ( int i = n - 1 ; i >= 0 ; i -- ) { ArrayList < Integer > listaAct = new ArrayList < Integer > ( ) ; listaAct . add ( dist [ i ] ) ; int maxAct = prof [ i ] ; for ( int j = i ; j < maxes . length ; j ++ ) { if ( Math . abs ( dist [ i ] - dist [ j ] ) >= k ) if ( maxAct < prof [ i ] + maxes [ j ] ) { maxAct = maxes [ j ] + prof [ i ] ; listaAct . clear ( ) ; listaAct . add ( dist [ i ] ) ; listaAct . addAll ( arrayMaxes . get ( j ) ) ; } } maxes [ i ] = maxAct ; arrayMaxes . set ( i , listaAct ) ; } int res = 0 ; ArrayList < Integer > maxArray = new ArrayList ( ) ; for ( int i = 0 ; i < maxes . length ; i ++ ) { if ( res < maxes [ i ] ) { res = maxes [ i ] ; maxArray = arrayMaxes . get ( i ) ; } } String finalRes = "La ganancia maxima es: " + res + "\ncon las tiendas:\n" ; for ( int i = 0 ; i < maxArray . size ( ) ; i ++ ) { finalRes += maxArray . get ( i ) + " " ; } return finalRes ; }
va	3	@ Override public void mousePressed ( MouseEvent e ) { if ( e . getButton ( ) == RIGHTCLICK ) { if ( view . isItemContains ( e . getPoint ( ) ) ) kdtCC . execPickup ( ) ; else if ( view . isFloorContains ( e . getPoint ( ) ) ) kdtCC . execDrop ( ) ; } }
va	6	private static byte [ ] encode3to4 ( byte [ ] source , int srcOffset , int numSigBytes , byte [ ] destination , int destOffset , int options ) { byte [ ] ALPHABET = getAlphabet ( options ) ; int inBuff = ( numSigBytes > 0 ? ( ( source [ srcOffset ] << 24 ) >>> 8 ) : 0 ) | ( numSigBytes > 1 ? ( ( source [ srcOffset + 1 ] << 24 ) >>> 16 ) : 0 ) | ( numSigBytes > 2 ? ( ( source [ srcOffset + 2 ] << 24 ) >>> 24 ) : 0 ) ; switch ( numSigBytes ) { case 3 : destination [ destOffset ] = ALPHABET [ ( inBuff >>> 18 ) ] ; destination [ destOffset + 1 ] = ALPHABET [ ( inBuff >>> 12 ) & 3f ] ; destination [ destOffset + 2 ] = ALPHABET [ ( inBuff >>> 6 ) & 3f ] ; destination [ destOffset + 3 ] = ALPHABET [ ( inBuff ) & 3f ] ; return destination ; case 2 : destination [ destOffset ] = ALPHABET [ ( inBuff >>> 18 ) ] ; destination [ destOffset + 1 ] = ALPHABET [ ( inBuff >>> 12 ) & 3f ] ; destination [ destOffset + 2 ] = ALPHABET [ ( inBuff >>> 6 ) & 3f ] ; destination [ destOffset + 3 ] = EQUALS_SIGN ; return destination ; case 1 : destination [ destOffset ] = ALPHABET [ ( inBuff >>> 18 ) ] ; destination [ destOffset + 1 ] = ALPHABET [ ( inBuff >>> 12 ) & 3f ] ; destination [ destOffset + 2 ] = EQUALS_SIGN ; destination [ destOffset + 3 ] = EQUALS_SIGN ; return destination ; default : return destination ; } }
va	3	private int binarySearch ( float af [ ] , int i , int j , float f ) { do { if ( af [ i ] > f ) { return i ; } int k = ( i + j ) / 2 ; if ( f < af [ k ] ) { j = k ; } else { i = k + 1 ; } } while ( true ) ; }
va	9	private static boolean KawigiEdit_RunTest ( int testNum , int [ ] p0 , int [ ] p1 , boolean hasAnswer , int p2 ) { System . out . print ( "Test " + testNum + ": [" + "{" ) ; for ( int i = 0 ; p0 . length > i ; ++ i ) { if ( i > 0 ) { System . out . print ( " " ) ; } System . out . print ( p0 [ i ] ) ; } System . out . print ( "}" + " " + "{" ) ; for ( int i = 0 ; p1 . length > i ; ++ i ) { if ( i > 0 ) { System . out . print ( " " ) ; } System . out . print ( p1 [ i ] ) ; } System . out . print ( "}" ) ; System . out . println ( "]" ) ; GoodCompanyDivTwo obj ; int answer ; obj = new GoodCompanyDivTwo ( ) ; long startTime = System . currentTimeMillis ( ) ; answer = obj . countGood ( p0 , p1 ) ; long endTime = System . currentTimeMillis ( ) ; boolean res ; res = true ; System . out . println ( "Time: " + ( endTime - startTime ) / 1000.0 + " seconds" ) ; if ( hasAnswer ) { System . out . println ( "Desired answer:" ) ; System . out . println ( "\t" + p2 ) ; } System . out . println ( "Your answer:" ) ; System . out . println ( "\t" + answer ) ; if ( hasAnswer ) { res = answer == p2 ; } if ( ! res ) { System . out . println ( "DOESN'T MATCH!!!!" ) ; } else if ( ( endTime - startTime ) / 1000.0 >= 2 ) { System . out . println ( "FAIL the timeout" ) ; res = false ; } else if ( hasAnswer ) { System . out . println ( "Match :-)" ) ; } else { System . out . println ( "OK  but is it right?" ) ; } System . out . println ( "" ) ; return res ; }
va	1	public ASPath getASPath ( ) { if ( this . updateAttr != null ) return this . updateAttr . getASPath ( ) ; return null ; }
va	1	public void setAllClickable ( ) { int len = selectable . length ; for ( int i = 0 ; i < len ; i ++ ) { selectable [ i ] = true ; } }
va	9	public void paint ( Graphics g ) { if ( buffer == null ) buffer = new BufferedImage ( getWidth ( ) , getHeight ( ) , BufferedImage . TYPE_INT_ARGB ) ; Graphics gBuffer = buffer . getGraphics ( ) ; gBuffer . setColor ( Color . white ) ; gBuffer . fillRect ( 0 , 0 , getWidth ( ) , getHeight ( ) ) ; gBuffer . setColor ( Color . black ) ; for ( int i = 0 ; i < points . length ; i ++ ) { int x = ( int ) ( getWidth ( ) / 2 + ( xCam + points [ i ] [ 0 ] ) * zoom ) ; int y = ( int ) ( getHeight ( ) / 2 + ( yCam + points [ i ] [ 1 ] ) * zoom ) ; if ( itemNumero . isSelected ( ) ) { gBuffer . drawString ( Integer . toString ( classes [ i ] ) , x , y ) ; } else { if ( itemCouleur . isSelected ( ) ) { Color couleur = Color . black ; if ( itemDegradees . isSelected ( ) ) { if ( itemCoulLarge . isSelected ( ) ) { Iterator < Classe > iter = vectClasses . iterator ( ) ; while ( iter . hasNext ( ) ) { Classe next = iter . next ( ) ; if ( next . estColoriee ) couleur = Outils . melangeCouleurs ( next . couleur , couleur , N [ i ] [ next . index ] ) ; } } else { Iterator < Classe > iter = vectClasses . iterator ( ) ; while ( iter . hasNext ( ) ) { Classe next = iter . next ( ) ; if ( next . estColoriee ) couleur = Outils . melangeCouleurs ( next . couleur , couleur , M [ i ] [ next . index ] ) ; } } } else couleur = vectClasses . elementAt ( classes [ i ] ) . couleur ; symboleCase . dessine ( gBuffer , x , y , symbolSize , couleur ) ; } else vectClasses . elementAt ( classes [ i ] ) . symbole . dessine ( gBuffer , x , y , symbolSize ) ; } } if ( dessine && enveloppe > 0 ) { Iterator < Classe > iter = vectClasses . iterator ( ) ; while ( iter . hasNext ( ) ) { Classe next = iter . next ( ) ; if ( itemCouleurEnv . isSelected ( ) ) gBuffer . setColor ( next . couleur ) ; else gBuffer . setColor ( Color . black ) ; next . convexe . dessine ( gBuffer , zoom , xCam , yCam , getWidth ( ) , getHeight ( ) ) ; } } g . drawImage ( buffer , 0 , 0 , null ) ; }
va	5	public byte [ ] merge ( byte [ ] left , byte [ ] right ) { byte [ ] temp = new byte [ left . length + right . length ] ; int lefti = 0 , righti = 0 , tempi = 0 ; while ( lefti < left . length && righti < right . length ) { if ( left [ lefti ] < right [ righti ] ) { temp [ tempi ] = left [ lefti ] ; currentSteps . ensureCapacity ( currentSteps . size ( ) + 1 ) ; currentSteps . add ( new MergeStep ( mergeStepHelper ( temp , 0 , tempi ) , tempi , mergeStepHelper ( left , lefti , left . length ) , mergeStepHelper ( right , righti , right . length ) ) ) ; lefti ++ ; } else { temp [ tempi ] = right [ righti ] ; currentSteps . ensureCapacity ( currentSteps . size ( ) + 1 ) ; currentSteps . add ( new MergeStep ( mergeStepHelper ( temp , 0 , tempi ) , tempi , mergeStepHelper ( left , lefti , left . length ) , mergeStepHelper ( right , righti , right . length ) ) ) ; righti ++ ; } tempi ++ ; } byte [ ] rest ; int resti ; if ( lefti >= left . length ) { rest = right ; resti = righti ; } else { rest = left ; resti = lefti ; } for ( int i = resti ; i < rest . length ; i ++ ) { temp [ tempi ] = rest [ i ] ; tempi ++ ; } currentSteps . ensureCapacity ( currentSteps . size ( ) + 1 ) ; currentSteps . add ( new MergeStep ( temp , temp . length , null , null ) ) ; return temp ; }
va	6	public static String escape ( String string ) { StringBuilder sb = new StringBuilder ( string . length ( ) ) ; for ( int i = 0 , length = string . length ( ) ; i < length ; i ++ ) { char c = string . charAt ( i ) ; switch ( c ) { case & : sb . append ( "&amp;" ) ; break ; case < : sb . append ( "&lt;" ) ; break ; case > : sb . append ( "&gt;" ) ; break ; case " : sb . append ( "&quot;" ) ; break ; case ' : sb . append ( "&apos;" ) ; break ; default : sb . append ( c ) ; } } return sb . toString ( ) ; }
va	2	public void drawPoly ( final Graphics g , Polygon p ) { int depth = p . getDepth ( ) ; int intes = 0 + 128 * depth ; if ( intes > 240 ) intes = 240 ; g . setColor ( new Color ( intes , intes , intes ) ) ; for ( Segment seg : p . getSegments ( ) ) { drawSegment ( g , seg ) ; drawPoint ( g , seg . getPointA ( ) ) ; } }
va	7	@ Override public Object getValueAt ( int row , int col ) { Auction auction = auctions . get ( row ) ; if ( auction == null ) { return "" ; } switch ( col ) { case 0 : return auction . getName ( ) ; case 1 : return auction . getAmount ( ) ; case 2 : return auction . getPrice ( ) * auction . getAmount ( ) ; case 3 : return auction . getType ( ) . equals ( Types . AuctionType . DUTCH ) ? "Dutch" : "Reverse Dutch" ; case 4 : return auction . getEndTime ( ) ; default : return "" ; } }
va	5	private int [ ] think ( Field f , Player playerAI , Player playerOpposing ) { Random r = new Random ( ) ; int opposingAtoms = util . countOwnedAtoms ( f , playerOpposing ) ; int score = Integer . MIN_VALUE ; int [ ] coords = new int [ 2 ] ; for ( int x = 0 ; x < f . getWidth ( ) ; ++ x ) { for ( int y = 0 ; y < f . getHeight ( ) ; ++ y ) { int cellvalue = calculateCellValue ( f , x , y , playerAI , playerOpposing , opposingAtoms ) ; if ( cellvalue > score || ( r . nextBoolean ( ) && cellvalue >= score ) ) { score = cellvalue ; coords [ 0 ] = x ; coords [ 1 ] = y ; } } } return coords ; }
va	3	public void start0 ( Stage stage ) throws Throwable { instance = this ; this . stage = stage ; modPropDiag = new ModCreateDialog ( this ) ; fileChooser = new FileChooser ( ) ; dirChooser = new DirectoryChooser ( ) ; modman = new ModManager ( ) ; data = new DataFiles ( ) ; stage . setTitle ( "Starbound Mod Toolkit" ) ; BorderPane root = new BorderPane ( ) ; root . setTop ( ( menu = new ModToolkitMenu ( this ) ) ) ; tabs = new TabPane ( ) ; tabs . setTabClosingPolicy ( TabClosingPolicy . UNAVAILABLE ) ; Tab home = new Tab ( "Home" ) ; home . setContent ( new HomePane ( ) ) ; Tab mods = new Tab ( "Mods" ) ; this . mods = new ModsPane ( this ) ; mods . setContent ( this . mods ) ; tabs . getTabs ( ) . addAll ( home , mods ) ; root . setCenter ( tabs ) ; Screen screen = Screen . getPrimary ( ) ; Rectangle2D bounds = screen . getVisualBounds ( ) ; Scene scene = new Scene ( root ) ; stage . setScene ( scene ) ; stage . setX ( bounds . getMinX ( ) ) ; stage . setY ( bounds . getMinY ( ) ) ; stage . setWidth ( bounds . getWidth ( ) ) ; stage . setHeight ( bounds . getHeight ( ) ) ; stage . centerOnScreen ( ) ; log . info ( "Loading files" ) ; try { data . loadFiles ( ) ; } catch ( IOException e ) { log . log ( Level . SEVERE , "Failed to load application data" , e ) ; MessageDialog . showErrorDialog ( stage , "An error was " + "encountered while loading application data: " + Util . diagLogException ( e ) , "Starbound Mod Toolkit - Error" , e ) ; } Path r = data . getMostRecentFile ( ) ; if ( r != null ) dirChooser . setInitialDirectory ( r . getParent ( ) . toFile ( ) ) ; File f = data . getLastExportPath ( ) ; if ( f != null ) menu . exportDialog . setInitialDirectory ( f . getParentFile ( ) ) ; stage . show ( ) ; stage . setOnCloseRequest ( this ) ; log . info ( "Starbound Mod Toolkit started" ) ; }
va	0	public boolean hasCommand ( ) { return hascmd ; }
va	6	private void loadQuranFonts ( ) { for ( QuranicFonts qf : QuranicFonts . values ( ) ) { InputStream is = null ; is = Loader . class . getResourceAsStream ( qf . getResourcePath ( ) ) ; if ( is != null ) { Font f = null ; try { f = Font . createFont ( Font . TRUETYPE_FONT , is ) ; } catch ( FontFormatException e ) { System . out . println ( "Error Creating Font: " + e . getMessage ( ) ) ; } catch ( IOException e ) { System . out . println ( "Error Creating Font: " + e . getMessage ( ) ) ; } if ( f != null ) { this . quranicFonts . put ( qf , f . deriveFont ( qf . getDefaultSize ( ) ) ) ; GraphicsEnvironment . getLocalGraphicsEnvironment ( ) . registerFont ( f ) ; } try { is . close ( ) ; } catch ( IOException e ) { System . err . println ( "Error closing InputStream for font resources: " + e . getMessage ( ) ) ; } } else { System . err . println ( "Unable to acquire InputStream for font resource: " + qf . getResourcePath ( ) ) ; } } }
va	1	@ Override public IndexWriterConfig createIndexWriterConfig ( final Analyzer analyzer ) { return new IndexWriterConfig ( Version . LUCENE_36 , m_analyzerFactory == null ? new StandardAnalyzerFactory ( ) . createAnalyzer ( ) : m_analyzerFactory . createAnalyzer ( ) ) ; }
va	9	@ Override public long [ ] getLongData ( long [ ] a , long startPos , long endPos , long step ) { if ( startPos < 0 || startPos >= length ) { throw new ArrayIndexOutOfBoundsException ( "startPos < 0 || startPos >= length" ) ; } if ( endPos < 0 || endPos > length || endPos < startPos ) { throw new ArrayIndexOutOfBoundsException ( "endPos < 0 || endPos > length || endPos < startPos" ) ; } if ( step < 1 ) { throw new IllegalArgumentException ( "step < 1" ) ; } long len = ( long ) Math . ceil ( ( endPos - startPos ) / ( double ) step ) ; if ( len > getMaxSizeOf32bitArray ( ) ) { return null ; } else { long [ ] out ; if ( a != null && a . length >= len ) { out = a ; } else { out = new long [ ( int ) len ] ; } int idx = 0 ; if ( ptr != 0 ) { for ( long i = startPos ; i < endPos ; i += step ) { out [ idx ++ ] = ( long ) Utilities . UNSAFE . getByte ( ptr + i ) ; } } else { if ( isConstant ( ) ) { for ( long i = startPos ; i < endPos ; i += step ) { out [ idx ++ ] = data [ 0 ] ; } } else { for ( long i = startPos ; i < endPos ; i += step ) { out [ idx ++ ] = ( long ) data [ ( int ) i ] ; } } } return out ; } }
va	6	private boolean r_other_endings ( ) { int among_var ; int v_1 ; int v_2 ; int v_3 ; v_1 = limit - cursor ; if ( cursor < I_p2 ) { return false ; } cursor = I_p2 ; v_2 = limit_backward ; limit_backward = cursor ; cursor = limit - v_1 ; ket = cursor ; among_var = find_among_b ( a_7 , 14 ) ; if ( among_var == 0 ) { limit_backward = v_2 ; return false ; } bra = cursor ; limit_backward = v_2 ; switch ( among_var ) { case 0 : return false ; case 1 : { v_3 = limit - cursor ; lab0 : do { if ( ! ( eq_s_b ( 2 , "po" ) ) ) { break lab0 ; } return false ; } while ( false ) ; cursor = limit - v_3 ; } break ; } slice_del ( ) ; return true ; }
va	7	public static boolean isAnagram ( String a , String b ) { if ( a == null || b == null ) return false ; if ( a . length ( ) != b . length ( ) ) return false ; int [ ] charSet = new int [ 256 ] ; for ( int i = 0 ; i < a . length ( ) ; i ++ ) { charSet [ a . charAt ( i ) ] ++ ; } for ( int j = 0 ; j < b . length ( ) ; j ++ ) { charSet [ b . charAt ( j ) ] -- ; } for ( int k = 0 ; k < charSet . length ; k ++ ) { if ( charSet [ k ] != 0 ) return false ; } return true ; }
va	2	private void addType ( final int index , final Types type ) { if ( index >= types . length ) { return ; } if ( types [ index ] != Types . NONE ) { types [ index ] = type ; } }
va	5	public TreeNode buildTree ( int [ ] preorder , int [ ] inorder ) { if ( preorder == null || inorder == null || preorder . length == 0 || inorder . length == 0 || preorder . length != inorder . length ) return null ; return bldTree ( preorder , 0 , preorder . length - 1 , inorder , 0 , inorder . length - 1 ) ; }
va	2	public static Apples fromByteArray ( byte [ ] array ) { try { ByteArrayInputStream bis = new ByteArrayInputStream ( array ) ; ObjectInput in = null ; in = new ObjectInputStream ( bis ) ; Object o = in . readObject ( ) ; try { bis . close ( ) ; in . close ( ) ; } catch ( Exception e ) { System . out . println ( "A Memory Leak Has Happened!" ) ; e . printStackTrace ( ) ; } return ( Apples ) o ; } catch ( Exception e ) { } return null ; }
va	2	private String getWordStem ( String word ) { String wordInProcess = word ; String stem = "" ; if ( wordInProcess . contains ( GlobalConstHelper . NOT_WORD_KEY ) ) { stem += GlobalConstHelper . NOT_WORD_KEY ; wordInProcess = wordInProcess . substring ( 3 ) ; } if ( StemmMap . stemms . containsKey ( wordInProcess ) ) { stem += StemmMap . stemms . get ( wordInProcess ) ; } else stem += wordInProcess ; return stem ; }
va	5	public static boolean testRiffle ( int [ ] shuffledDeck , int shuffledDeckIndex , int [ ] half1 , int half1Index , int [ ] half2 , int half2Index ) { if ( shuffledDeckIndex == shuffledDeck . length ) { return true ; } if ( half1Index < half1 . length && shuffledDeck [ shuffledDeckIndex ] == half1 [ half1Index ] ) { return testRiffle ( shuffledDeck , shuffledDeckIndex ++ , half1 , half1Index ++ , half2 , half2Index ) ; } else if ( half2Index < half2 . length && shuffledDeck [ shuffledDeckIndex ] == half2 [ half2Index ] ) { return testRiffle ( shuffledDeck , shuffledDeckIndex ++ , half1 , half1Index ++ , half2 , half2Index ) ; } else { return false ; } }
va	4	public static int computeJ ( String [ ] t , String [ ] et ) { int cost = 0 ; String [ ] observedTrace = new String [ 100 ] ; String [ ] [ ] distanceMatrixForTrace = new String [ t . length ] [ observedTrace . length ] ; for ( int m = 0 ; m < t . length ; m ++ ) { distanceMatrixForTrace [ m ] [ 0 ] = t [ m ] ; } for ( int n = 0 ; n < t . length ; n ++ ) { distanceMatrixForTrace [ 0 ] [ n ] = observedTrace [ n ] ; } for ( int i = 1 ; i < t . length ; i ++ ) { for ( int j = 1 ; j < observedTrace . length ; j ++ ) { distanceMatrixForTrace [ i ] [ j ] = Integer . toString ( getDistance ( distanceMatrixForTrace [ i ] [ 0 ] , distanceMatrixForTrace [ 0 ] [ j ] ) ) ; } } return cost ; }
va	4	public BigInt mult ( BigInt other ) { int [ ] newdigits = new int [ this . digits . length + other . digits . length ] ; boolean sign = this . isNegative ^ other . isNegative ; for ( int ii = 0 ; ii < digits . length ; ii ++ ) { int carry = 0 ; for ( int jj = 0 ; jj < other . digits . length || carry > 0 ; jj ++ ) { int otherDigit = jj >= other . digits . length ? 0 : other . digits [ jj ] ; int val = this . digits [ ii ] * otherDigit + carry ; newdigits [ ii + jj ] += val % 10 ; carry = val / 10 ; } } return new BigInt ( newdigits , sign ) ; }
va	6	public JSONObject sendAndReceive ( JSONObject message ) { try { if ( log . isDebugEnabled ( ) ) { log . debug ( "Sending: " + message . toString ( 2 ) ) ; } PostMethod postMethod = new PostMethod ( uri . toString ( ) ) ; postMethod . setRequestHeader ( "Content-Type" , "text/plain" ) ; RequestEntity requestEntity = new StringRequestEntity ( message . toString ( ) , JSON_CONTENT_TYPE , null ) ; postMethod . setRequestEntity ( requestEntity ) ; http ( ) . executeMethod ( null , postMethod , state ) ; int statusCode = postMethod . getStatusCode ( ) ; if ( statusCode != HttpStatus . SC_OK ) throw new ClientError ( "HTTP Status - " + HttpStatus . getStatusText ( statusCode ) + " (" + statusCode + ")" ) ; JSONTokener tokener = new JSONTokener ( postMethod . getResponseBodyAsString ( ) ) ; Object rawResponseMessage = tokener . nextValue ( ) ; JSONObject responseMessage = ( JSONObject ) rawResponseMessage ; if ( responseMessage == null ) throw new ClientError ( "Invalid response type - " + rawResponseMessage . getClass ( ) ) ; return responseMessage ; } catch ( HttpException e ) { throw new ClientError ( e ) ; } catch ( IOException e ) { throw new ClientError ( e ) ; } catch ( JSONException e ) { throw new ClientError ( e ) ; } }
va	7	@ Override public UnitItemStack [ ] write ( DataOutputStream out , PassthroughConnection ptc , KillableThread thread , boolean serverToClient ) { if ( length == null || value == null ) { return null ; } length = lengthUnit . write ( out , ptc , thread , serverToClient ) ; if ( length == null ) { return null ; } if ( length > FFFF ) { ptc . printLogMessage ( "To many item window updates in one packet - breaking connection" ) ; return null ; } ItemStack temp = null ; for ( int cnt = 0 ; cnt < length ; cnt ++ ) { if ( value [ cnt ] == null ) { return null ; } temp = value [ cnt ] . write ( out , ptc , thread , serverToClient ) ; if ( temp == null ) { return null ; } } return value ; }
va	0	public Integer getProvinceID ( ) { return provinceID ; }
va	8	public String doTrans ( ) { for ( int j = 0 ; j < input . length ( ) ; j ++ ) { char ch = input . charAt ( j ) ; switch ( ch ) { case + : case - : gotOper ( ch , 1 ) ; break ; case * : case / : gotOper ( ch , 2 ) ; break ; case ( : stack . push ( ch ) ; break ; case ) : gotParen ( ch ) ; break ; default : output = output + ch ; break ; } } while ( ! stack . isEmpty ( ) ) { output = output + stack . pop ( ) ; } return output ; }
va	7	@ Override public Set < EvaluatedDecision > evaluateDecisions ( Set < Decision > ds , State s ) { initializeCaches ( s ) ; outOfTime = false ; Timer t = new Timer ( ) ; t . schedule ( new TimerTask ( ) { public void run ( ) { outOfTime = true ; } } , decision_time ) ; Set < EvaluatedDecision > edsbest = null ; int depth = 0 ; try { for ( depth = 0 ; depth <= max_depth ; depth ++ ) { Set < EvaluatedDecision > eds = new HashSet < EvaluatedDecision > ( ds . size ( ) ) ; int ply = 0 ; boolean [ ] coalition = selectCoalition ( s ) ; for ( Decision d : ds ) { double u = 0 ; Object [ ] outcomes = d . outcomeDesignators ( s ) ; for ( int i = 0 ; i < outcomes . length ; i ++ ) { AppliedDecision ad = d . apply ( s , outcomes [ i ] , true ) ; try { updateCaches ( s , d , ad ) ; int newply = ply ; if ( s . currentPlayer ( ) != d . player ) newply ++ ; u += d . outcomeLikelihood ( s , outcomes [ i ] ) * minimax ( s , depth , newply , double . NEGATIVE_INFINITY , double . POSITIVE_INFINITY , coalition ) . utility ; } finally { ad . undo ( ) ; downdateCaches ( s , d , ad ) ; } } eds . add ( new EvaluatedDecision ( d , u ) ) ; } edsbest = eds ; } } catch ( OutOfTimeException e ) { if ( verbose ) System . out . println ( "out of time" ) ; } finally { total_depth += depth ; total_depth_nterms ++ ; } if ( ! outOfTime ) t . cancel ( ) ; total_ndecisions ++ ; return edsbest ; }
va	8	@ Override public void run ( ) { byte [ ] b = new byte [ 100 ] ; DatagramPacket p = new DatagramPacket ( b , 100 ) ; if ( ( state & 00001000 ) != 0 ) return ; try { socket . receive ( p ) ; String str = new String ( p . getData ( ) ) ; String [ ] strs = str . trim ( ) . split ( "-" ) ; if ( strs . length < 5 ) return ; if ( ! strs [ 0 ] . equals ( "JavaClockRemote" ) ) return ; if ( ! strs [ 1 ] . equals ( "v001" ) ) return ; if ( ( state & 00000010 ) != 0 ) return ; if ( Integer . parseInt ( strs [ 4 ] ) != 0 ) state |= 1 ; else state &= FE ; state &= 11111011 ; missedCounter = 0 ; } catch ( Exception e ) { missedCounter ++ ; if ( missedCounter > missedThresh ) { missedCounter = missedThresh ; state |= 00000100 ; } } updateButton ( ) ; }
va	1	public DbAnonymizerJAX_RS_Impl ( DBA_factory dba_factory ) { this . dba_factory = dba_factory ; MySQLQueryFactory sqlFactory = new MySQLQueryFactory ( ) ; if ( ! sqlFactory . checkDBExistence ( ) ) { MyLogger . getInstance ( ) . writeLog ( Level . SEVERE , "***** DB not correctly configured *****" ) ; dba_factory = null ; return ; } }
va	0	public boolean checkTower ( ) { return false ; }
va	2	public boolean contains ( long value ) { int i = size - 1 ; long [ ] items = this . items ; while ( i >= 0 ) { if ( items [ i -- ] == value ) { return true ; } } return false ; }
va	7	private List < Mapping > buildMappingList ( class cls ) { List < Mapping > mappings = new ArrayList < Mapping > ( ) ; List < Field > fields = ReflectionUtil . getAllFields ( cls ) ; for ( Field field : fields ) { if ( ! hasAnnotations ( field ) ) { continue ; } Mapping mapping = null ; if ( getBindAnnotation ( field ) != null ) { Segment segment = field . getAnnotation ( Segment . class ) ; if ( segment == null ) { segment = BindAnnotation . class . getAnnotation ( Segment . class ) ; } mapping = new SegmentMapping ( segment , field , createSegmentAdapter ( segment . adapter ( ) , ReflectionUtil . typeExtractor ( field ) , field ) ) ; } else if ( field . getAnnotation ( Segment . class ) != null ) { Segment segment = field . getAnnotation ( Segment . class ) ; mapping = new SegmentMapping ( segment , field , createSegmentAdapter ( segment . adapter ( ) , ReflectionUtil . typeExtractor ( field ) , field ) ) ; } else if ( field . getAnnotation ( Group . class ) != null ) { Group group = field . getAnnotation ( Group . class ) ; mapping = createGroupMapping ( field ) ; } else { throw new ParserBuildException ( String . format ( "MessageParser build: Filed[%s] of class[%s] not annoted with @Segement or @Group" , field . getName ( ) , field . getDeclaringClass ( ) . getSimpleName ( ) ) ) ; } Separator separator = field . getAnnotation ( Separator . class ) ; if ( separator != null ) { SeparatorImpl separatorImpl = new SeparatorImpl ( separator ) ; mapping . setSeparator ( separatorImpl ) ; } mappings . add ( mapping ) ; } Collections . sort ( mappings ) ; return mappings ; }
va	8	Value optimizeValue ( Value s ) { if ( s instanceof ConstantValue ) { } else if ( s instanceof VariableAssign ) { } else if ( s instanceof Expression ) { Expression exp = ( Expression ) s ; if ( exp . value . equals ( "+" ) ) { List < Value > opr = new LinkedList < Value > ( ) ; boolean firstConst = false ; for ( int i = 0 ; i < exp . operands . size ( ) ; i ++ ) { exp . operands . set ( i , optimizeValue ( exp . operands . get ( i ) ) ) ; } for ( Value v : exp . operands ) { if ( v instanceof ConstantValue ) { if ( firstConst ) { int value = Integer . valueOf ( v . value ) + Integer . valueOf ( opr . get ( 0 ) . value ) ; opr . set ( 0 , new ConstantValue ( Integer . toString ( value ) , v . type ) ) ; firstConst = true ; } else { opr . add ( 0 , v ) ; } } else { } } } } return s ; }
va	5	public void printInstallationInfo ( ) { System . out . println ( "Installation name: " + this . getName ( ) ) ; System . out . println ( "... contains appliances:" ) ; for ( Appliance app : this . getAppliances ( ) ) System . out . println ( "\tAppliance name: " + app . getName ( ) ) ; System . out . println ( "... contains persons:" ) ; for ( Person p : this . getPersons ( ) ) { System . out . println ( "\tPerson name: " + p . getName ( ) ) ; System . out . println ( "\t... contains activities:" ) ; for ( Activity a : p . getActivities ( ) ) { System . out . println ( "\t\tActivity name: " + a . getName ( ) ) ; System . out . println ( "\t\t... contains activity models for:" ) ; for ( String key : a . getProbDuration ( ) . keySet ( ) ) { System . out . print ( "\t\t\t " + key + ": " ) ; for ( Appliance temp : a . getAppliances ( ) . get ( key ) ) System . out . print ( temp . getName ( ) + "  \t" ) ; System . out . println ( ) ; } } } }
va	3	private void populateDto ( Invite dto , ResultSet rs ) throws SQLException { dto . setIdInvite ( new Integer ( rs . getInt ( COLUMN_ID_INVITE ) ) ) ; try { dto . setInviter ( new UserDaoImpl ( ) . findByPrimaryKey ( rs . getString ( COLUMN_INVITER ) ) ) ; } catch ( UserDaoException e2 ) { e2 . printStackTrace ( ) ; } try { dto . setInvitee ( new UserDaoImpl ( ) . findByPrimaryKey ( rs . getString ( COLUMN_INVITEE ) ) ) ; } catch ( UserDaoException e1 ) { e1 . printStackTrace ( ) ; } try { dto . setRes ( new InviteResDaoImpl ( ) . findByPrimaryKey ( rs . getString ( COLUMN_RES ) ) ) ; } catch ( InviteResDaoException e ) { e . printStackTrace ( ) ; } dto . setInviteDate ( rs . getTimestamp ( COLUMN_INVITE_DATE ) ) ; }
va	7	public void add ( double value ) { totalCount ++ ; if ( value < start || value > end ) { others ++ ; return ; } recentlyAdded = value ; int low = 0 ; int high = rangeCount - 1 ; while ( low <= high ) { int mid = ( high + low ) >>> 1 ; if ( value <= ranges [ mid ] ) { if ( mid > 0 && value < ranges [ mid - 1 ] ) { high = mid - 1 ; } else { counts [ mid ] ++ ; return ; } } else if ( value > ranges [ mid ] ) { low = mid + 1 ; } } }
va	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( frmListadoPerfilesPorColor . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( frmListadoPerfilesPorColor . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( frmListadoPerfilesPorColor . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( frmListadoPerfilesPorColor . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { @ Override public void run ( ) { new frmListadoPerfilesPorColor ( null ) . setVisible ( true ) ; } } ) ; }
va	6	@ Override public Vector < Archivo > getTodosArchivos ( String tipo ) { String consulta = "SELECT * FROM archivo " ; if ( tipo . equals ( EXTENSIONES_AUDIO ) ) consulta += "ORDER BY artista ASC" ; if ( tipo . equals ( EXTENSIONES_IMAGEN ) ) consulta += "ORDER BY nombre ASC" ; Vector < Archivo > archivos = new Vector < Archivo > ( ) ; Archivo temp = null ; int contador = 0 ; try { resultados = instruccion . executeQuery ( consulta ) ; while ( resultados . next ( ) ) { temp = new Archivo ( resultados ) ; if ( temp . esTipo ( tipo ) ) archivos . add ( temp ) ; contador ++ ; } } catch ( SQLException e ) { System . err . println ( "Error SQL: " + consulta ) ; if ( DEBUG ) e . printStackTrace ( ) ; } return archivos ; }
va	7	public void load ( Node node ) { HashMap < String , class < ? extends Treasure >> classes = new HashMap < String , class < ? extends Treasure >> ( ) ; classes . put ( "Gold" , Gold . class ) ; classes . put ( "Key" , Key . class ) ; classes . put ( "Potion" , Potion . class ) ; clear ( ) ; Node base = XMLHelper . findChild ( node , "Vector" ) ; if ( base == null ) return ; int count = base . getChildNodes ( ) . getLength ( ) ; for ( int a = 0 ; a != count ; ++ a ) { try { Node first_node = base . getChildNodes ( ) . item ( 0 ) ; String classname = first_node . getNodeName ( ) ; class < ? extends Treasure > c = classes . get ( classname ) ; if ( c != null ) { Treasure obj = c . newInstance ( ) ; XMLHelper . loadObject ( base , classname , obj ) ; add ( obj ) ; } } catch ( Exception ex ) { System . err . println ( ex ) ; } Node child = base . getChildNodes ( ) . item ( 0 ) ; base . removeChild ( child ) ; } }
va	7	private static double getDoubleImpl ( Object o , double def ) { try { if ( o == null ) return def ; if ( o instanceof String ) return double . parseDouble ( ( String ) o ) ; if ( o instanceof Number ) return ( ( Number ) o ) . doubleValue ( ) ; if ( o instanceof Range ) return ( ( Range ) o ) . randDouble ( ) ; if ( o instanceof boolean ) return ( ( boolean ) o ) ? 1 : 0 ; } catch ( NumberFormatException e ) { } Log . w ( "Object cast error - cannot cast " + o + " to Double." ) ; return def ; }
va	2	public static < T extends Comparable < T >> T max ( Set < T > set ) { Iterator < T > i = set . iterator ( ) ; T result = i . next ( ) ; for ( T e : set ) { if ( e . compareTo ( result ) > 0 ) { result = e ; } } return result ; }
va	8	public static long hash ( BufferedImage image ) { BufferedImage scaled = new BufferedImage ( size , size , BufferedImage . TYPE_BYTE_GRAY ) ; Graphics g = scaled . getGraphics ( ) ; g . drawImage ( image , 0 , 0 , size , size , null ) ; g . dispose ( ) ; Raster raster = scaled . getRaster ( ) ; double [ ] [ ] pixels = new double [ size ] [ size ] ; for ( int i = 0 ; i < size ; ++ i ) { for ( int j = 0 ; j < size ; ++ j ) { pixels [ i ] [ j ] = raster . getSampleDouble ( i , j , 0 ) ; } } int [ ] [ ] trans = copy ( mult ( dctt2 , pixels , null ) , lowSize , lowSize ) ; int sum = 0 ; for ( int i = 0 ; i < lowSize ; ++ i ) { for ( int j = 0 ; j < lowSize ; ++ j ) { if ( ( i | j ) != 0 ) sum += trans [ i ] [ j ] ; } } long hash = 0 ; int average = sum / ( lowSize * lowSize - 1 ) ; long bit = 1 ; for ( int i = 0 ; i < lowSize ; ++ i ) { for ( int j = 0 ; j < lowSize ; ++ j , bit <<= 1 ) { if ( trans [ i ] [ j ] >= average ) hash |= bit ; } } return hash ; }
va	5	protected static ArrayList < CoordenadasHomogeneas > criarMesh ( ArrayList < CoordenadasHomogeneas > listCoord , ArrayList < SemiPonto > listaCamposDeCoordenadas ) { for ( SemiPonto semiPonto : listaCamposDeCoordenadas ) { listCoord . add ( new CoordenadasNorm ( double . parseDouble ( semiPonto . gettFx ( ) . getText ( ) ) , double . parseDouble ( semiPonto . gettFy ( ) . getText ( ) ) , 1.0 ) ) ; } double [ ] [ ] m = new double [ 4 ] [ 3 ] ; Matrix matrizGeo = new Matrix ( m ) ; double [ ] f0 = new double [ 3 ] ; double [ ] deltaF0 = new double [ 3 ] ; double [ ] delta2F0 = new double [ 3 ] ; double [ ] delta3F0 = new double [ 3 ] ; FabricaMatriz ma = new FabricaMatriz ( ) ; Matrix gbs = ma . matrizGBS ( ) ; ArrayList < CoordenadasHomogeneas > ptsCurva = new ArrayList < CoordenadasHomogeneas > ( ) ; for ( int i = 0 ; i < listCoord . size ( ) - 3 ; i ++ ) { for ( int j = 0 ; j < matrizGeo . getRowDimension ( ) ; j ++ ) { matrizGeo . set ( j , 0 , listCoord . get ( j + i ) . getXD ( ) ) ; matrizGeo . set ( j , 1 , listCoord . get ( j + i ) . getYD ( ) ) ; matrizGeo . set ( j , 2 , listCoord . get ( j + i ) . getZD ( ) ) ; } Matrix coef = gbs . times ( matrizGeo ) ; double delta = ( 1.0 / DIVISOES ) ; for ( int k = 0 ; k < 3 ; k ++ ) { f0 [ k ] = coef . get ( 3 , k ) ; deltaF0 [ k ] = coef . get ( 0 , k ) * ( Math . pow ( delta , 3 ) ) + coef . get ( 1 , k ) * ( Math . pow ( delta , 2 ) ) + coef . get ( 2 , k ) * delta ; delta2F0 [ k ] = 6 * coef . get ( 0 , k ) * ( Math . pow ( delta , 3 ) ) + 2 * coef . get ( 1 , k ) * ( Math . pow ( delta , 2 ) ) ; delta3F0 [ k ] = 6 * coef . get ( 0 , k ) * ( Math . pow ( delta , 3 ) ) ; } CoordenadasHomogeneas p = listCoord . get ( i ) ; ArrayList < CoordenadasHomogeneas > ptsSegCurva = forwardDiferencies ( p , f0 , deltaF0 , delta2F0 , delta3F0 ) ; for ( CoordenadasHomogeneas c : ptsSegCurva ) { ptsCurva . add ( c ) ; } } return ptsCurva ; }
va	3	public static String getPropertyPermissionAsString ( PropertyPermissions permission ) { if ( permission == PropertyPermissions . RO ) { return "ro" ; } else if ( permission == PropertyPermissions . RW ) { return "rw" ; } else if ( permission == PropertyPermissions . WO ) { return "wo" ; } return "" ; }
va	1	private void updatePortionsLabel ( ) { if ( portions == 1 ) { portionsLabel . setText ( "1 portion" ) ; } else { portionsLabel . setText ( portions + " portions" ) ; } }
va	6	private int getFirstIdenticalVertexId ( Model model , int vertex ) { int vertexId = - 1 ; int x = model . verticesX [ vertex ] ; int y = model . verticesY [ vertex ] ; int z = model . verticesZ [ vertex ] ; for ( int v = 0 ; v < vertexCount ; v ++ ) { if ( x != verticesX [ v ] || y != verticesY [ v ] || z != verticesZ [ v ] ) continue ; vertexId = v ; break ; } if ( vertexId == - 1 ) { verticesX [ vertexCount ] = x ; verticesY [ vertexCount ] = y ; verticesZ [ vertexCount ] = z ; if ( model . vertexSkins != null ) vertexSkins [ vertexCount ] = model . vertexSkins [ vertex ] ; vertexId = vertexCount ++ ; } return vertexId ; }
va	5	public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; char grade = in . next ( ) . charAt ( 0 ) ; switch ( grade ) { case A : System . out . println ( "Excellent" ) ; case B : System . out . println ( "Good" ) ; case C : System . out . println ( "So so" ) ; case D : System . out . println ( "Fails" ) ; case F : System . out . println ( "Get lost" ) ; default : System . out . println ( "Invalid" ) ; } }
va	5	private boolean impendingBow ( Friend bower ) { boolean myLock = false ; boolean otherLock = false ; try { myLock = lock . tryLock ( ) ; otherLock = bower . lock . tryLock ( ) ; } finally { if ( ! ( myLock && otherLock ) ) { if ( myLock ) lock . unlock ( ) ; if ( otherLock ) bower . lock . unlock ( ) ; } } return myLock && otherLock ; }
va	5	private void faerdig ( int pbId ) throws IOException { String response = "" ; try { produktBatchDB . updateProduktBatch ( new ProduktBatchDTO ( pbId , produktBatchDB . getProduktBatch ( pbId ) . getRecept ( ) , 2 , produktBatchDB . getProduktBatch ( pbId ) . getDatoStart ( ) , new Timestamp ( System . currentTimeMillis ( ) ) , produktBatchDB . getProduktBatch ( pbId ) . getOpr ( ) ) ) ; } catch ( DALException e ) { } for ( int i = 0 ; i < 3 ; i ++ ) { weightConnection . sendToServer ( "M12 2" ) ; System . out . println ( "Modtager svar fra M12: \n" + weightConnection . recieveFromServer ( ) . toUpperCase ( ) ) ; } weightConnection . sendToServer ( "K 1 " ) ; System . out . println ( "Modtager svar fra K 1: \n" + weightConnection . recieveFromServer ( ) . toUpperCase ( ) ) ; weightConnection . sendToServer ( "RM20 8 \"Faerdig\" \" \" \" \" " ) ; System . out . println ( "Modtager svar fra RM20: \n" + weightConnection . recieveFromServer ( ) . toUpperCase ( ) ) ; while ( true ) { response = weightConnection . recieveFromServer ( ) . toUpperCase ( ) ; System . out . println ( response ) ; if ( response . startsWith ( "RM20" ) ) { if ( response . startsWith ( "RM20 A" ) ) { weightConnection . sendToServer ( "Z " ) ; sekvens ( ) ; break ; } else { weightConnection . sendToServer ( "RM20 8 \"Faerdig\" \" \" \" \" " ) ; System . out . println ( "Modtager svar fra RM20: \n" + weightConnection . recieveFromServer ( ) . toUpperCase ( ) ) ; } } else { weightConnection . sendToServer ( "RM20 8 \"Faerdig\" \" \" \" \" " ) ; System . out . println ( "Modtager svar fra RM20: \n" + weightConnection . recieveFromServer ( ) . toUpperCase ( ) ) ; } } }
va	2	public void startTransfer ( String serviceName , String otherUser ) { HashMap < String , String > serviceHashMap = this . matchingUsers . get ( serviceName ) ; for ( String user : serviceHashMap . keySet ( ) ) { if ( user . equals ( otherUser ) ) { serviceHashMap . put ( user , StatusMessages . offerAccepted ) ; transfersInfo . put ( serviceName , new UserTransferStatus ( otherUser , StatusMessages . transferStarted ) ) ; } else { serviceHashMap . put ( user , StatusMessages . offerRefused ) ; } } }
va	4	public CustomListRenderer ( final JList list ) { super ( ) ; renderer = new CustomLabel ( ) ; list . addMouseListener ( new MouseAdapter ( ) { @ Override public void mouseReleased ( MouseEvent e ) { if ( SwingUtilities . isLeftMouseButton ( e ) ) { int index = list . locationToIndex ( e . getPoint ( ) ) ; if ( index != - 1 && list . isSelectedIndex ( index ) ) { Rectangle rect = list . getCellBounds ( index , index ) ; Point pointWithinCell = new Point ( e . getX ( ) - rect . x , e . getY ( ) - rect . y ) ; Rectangle crossRect = new Rectangle ( rect . width - 9 - 5 - crossIcon . getIconWidth ( ) / 2 , rect . height / 2 - crossIcon . getIconHeight ( ) / 2 , crossIcon . getIconWidth ( ) , crossIcon . getIconHeight ( ) ) ; if ( crossRect . contains ( pointWithinCell ) ) { DefaultListModel model = ( DefaultListModel ) list . getModel ( ) ; model . remove ( index ) ; } } } } } ) ; }
va	9	@ Override public double [ ] getDoubleData ( double [ ] a , long startPos , long endPos , long step ) { if ( startPos < 0 || startPos >= length ) { throw new ArrayIndexOutOfBoundsException ( "startPos < 0 || startPos >= length" ) ; } if ( endPos < 0 || endPos > length || endPos < startPos ) { throw new ArrayIndexOutOfBoundsException ( "endPos < 0 || endPos > length || endPos < startPos" ) ; } if ( step < 1 ) { throw new IllegalArgumentException ( "step < 1" ) ; } long len = ( long ) Math . ceil ( ( endPos - startPos ) / ( double ) step ) ; if ( len > getMaxSizeOf32bitArray ( ) ) { return null ; } else { double [ ] out ; if ( a != null && a . length >= len ) { out = a ; } else { out = new double [ ( int ) len ] ; } int idx = 0 ; if ( ptr != 0 ) { for ( long i = startPos ; i < endPos ; i += step ) { out [ idx ++ ] = ( double ) Utilities . UNSAFE . getByte ( ptr + i ) ; } } else { if ( isConstant ( ) ) { for ( long i = startPos ; i < endPos ; i += step ) { out [ idx ++ ] = data [ 0 ] ; } } else { for ( long i = startPos ; i < endPos ; i += step ) { out [ idx ++ ] = ( double ) data [ ( int ) i ] ; } } } return out ; } }
va	0	@ Test public void testSaveObjects ( ) { String fileName = "testSaveObjects.ser" ; Object inputObject1 = new PojoPerson ( "First1" , "Middle1" , "Last1" ) ; Object inputObject2 = new PojoPerson ( "First2" , "Middle2" , "Last2" ) ; boolean resultSave = PojoPersonUtils3 . saveObjects ( fileName , inputObject1 , inputObject2 ) ; assertThat ( resultSave , is ( true ) ) ; cleanup ( fileName ) ; }
va	8	public ImagePanel ( ) { setOpaque ( false ) ; addComponentListener ( new ComponentAdapter ( ) { public void componentResized ( ComponentEvent e ) { if ( scale > 0.0 ) { if ( isFullImageInPanel ( ) ) { centerImage ( ) ; } else if ( isImageEdgeInPanel ( ) ) { scaleOrigin ( ) ; } if ( isNavigationImageEnabled ( ) ) { createNavigationImage ( ) ; } repaint ( ) ; } previousPanelSize = getSize ( ) ; } } ) ; addMouseListener ( new MouseAdapter ( ) { public void mousePressed ( MouseEvent e ) { if ( SwingUtilities . isLeftMouseButton ( e ) ) { if ( isInNavigationImage ( e . getPoint ( ) ) ) { Point p = e . getPoint ( ) ; displayImageAt ( p ) ; } } } } ) ; addMouseMotionListener ( new MouseMotionListener ( ) { public void mouseDragged ( MouseEvent e ) { if ( SwingUtilities . isLeftMouseButton ( e ) && ! isInNavigationImage ( e . getPoint ( ) ) ) { Point p = e . getPoint ( ) ; moveImage ( p ) ; } } public void mouseMoved ( MouseEvent e ) { mousePosition = e . getPoint ( ) ; } } ) ; setZoomDevice ( ZoomDevice . MOUSE_WHEEL ) ; }
va	4	public void update ( GameContainer gc ) { if ( gc . getInput ( ) . isMouseButtonDown ( Input . MOUSE_LEFT_BUTTON ) ) { int mouseX = gc . getInput ( ) . getMouseX ( ) ; int mouseY = gc . getInput ( ) . getMouseY ( ) ; if ( mouseX >= 732 && mouseX <= 760 && mouseY < 60 ) { setOpenMemento ( true ) ; } } }
va	1	public boolean equals ( Auction auction ) { if ( this . id == auction . id ) { return true ; } else { return false ; } }
va	9	private void updatedTabbedPane ( ) { JPanel chosen = ( JPanel ) tabbedPane . getComponentAt ( tabbedPane . getSelectedIndex ( ) ) ; colour_view . setVisible ( false ) ; for ( int i = 0 ; i < colourpalette_view . length ; i ++ ) { colourpalette_view [ i ] . setVisible ( false ) ; } outColourCreator . setText ( "" ) ; outColourCreated . setText ( "" ) ; new_colourpalettes . clearSelection ( ) ; all_colours . clearSelection ( ) ; all_colourpalettes . clearSelection ( ) ; all_favcolours . clearSelection ( ) ; all_favcolourpalettes . clearSelection ( ) ; boolean overview_mode = false ; boolean colour_mode = false ; boolean favourite_mode = false ; if ( chosen . equals ( p_overview ) ) { mode = "overview" ; colour_mode = false ; favourite_mode = false ; newNotificationsNum = 0 ; String overview_name = tabbedPane . getTitleAt ( tabbedPane . getSelectedIndex ( ) ) ; int index = overview_name . indexOf ( "(" ) ; if ( index > 0 ) { overview_name = overview_name . substring ( 0 , index - 1 ) ; } tabbedPane . setTitleAt ( 0 , overview_name ) ; overview_mode = true ; } else if ( chosen . equals ( p_explore ) ) { mode = "explore" ; colour_mode = true ; favourite_mode = false ; } else if ( chosen . equals ( p_favourites ) ) { mode = "favourites" ; colour_mode = false ; favourite_mode = true ; } else if ( chosen . equals ( p_follower ) ) { mode = "follower" ; lblBenutzername . setVisible ( true ) ; outBenutzername . setVisible ( true ) ; lblBenutzerRegistriertAm . setVisible ( true ) ; outBenutzerRegistiertAm . setVisible ( true ) ; } else if ( chosen . equals ( p_creations ) ) { mode = "creations" ; colour_mode = true ; favourite_mode = false ; } btnFavResource . setVisible ( colour_mode ) ; btnFollowUser . setVisible ( colour_mode ) ; btnUnFavResource . setVisible ( favourite_mode ) ; btnUnFollowUser . setVisible ( favourite_mode ) ; lblErzeuger . setVisible ( overview_mode || colour_mode || favourite_mode ) ; lblErstelltAm . setVisible ( overview_mode || colour_mode || favourite_mode ) ; }
va	4	private void initMessageCount ( ) { int initCount = 0 ; Iterator < byte [ ] > messageId = null ; try { messageId = this . getIterator ( ) ; while ( messageId . hasNext ( ) ) { MessageInStore msg = this . getMessageInStore4j ( messageId . next ( ) ) ; if ( null != msg && msg . isEnabledSend ( ) ) { initCount ++ ; } } } catch ( IOException e ) { logger . error ( "" , e ) ; } finally { this . remainCommitMessageCount . set ( initCount ) ; this . messageTotalCount . set ( initCount ) ; } }
va	5	private void initPanels ( BoardPanel board , PlayerPanel [ ] players , SharedComponentPanel shared ) { add ( shared , BorderLayout . NORTH ) ; add ( board , BorderLayout . CENTER ) ; JPanel leftColumn = new JPanel ( ) ; leftColumn . setLayout ( new BorderLayout ( ) ) ; leftColumn . setPreferredSize ( new Dimension ( 240 , 700 ) ) ; leftColumn . setBorder ( BorderFactory . createEmptyBorder ( 0 , 0 , 0 , 10 ) ) ; add ( leftColumn , BorderLayout . WEST ) ; JPanel rightColumn = new JPanel ( ) ; rightColumn . setLayout ( new BorderLayout ( ) ) ; rightColumn . setPreferredSize ( new Dimension ( 240 , 700 ) ) ; rightColumn . setBorder ( BorderFactory . createEmptyBorder ( 0 , 10 , 0 , 0 ) ) ; add ( rightColumn , BorderLayout . EAST ) ; for ( int i = 0 ; i < players . length ; i ++ ) { switch ( i ) { case 0 : leftColumn . add ( players [ i ] , BorderLayout . NORTH ) ; break ; case 1 : rightColumn . add ( players [ i ] , BorderLayout . NORTH ) ; break ; case 2 : leftColumn . add ( players [ i ] , BorderLayout . SOUTH ) ; break ; case 3 : rightColumn . add ( players [ i ] , BorderLayout . SOUTH ) ; break ; } } }
va	7	public UserdataUpdater ( ) { plPort = Configuration . getConfig ( Configuration . CONFIG_PIPELINE_PORT ) ; plUser = Configuration . getConfig ( Configuration . CONFIG_PIPELINE_USER ) ; String pipeHome = Constants . pipelineHome ( plUser , plPort ) ; userdataFile = new File ( pipeHome + "userdata.xml" ) ; if ( userdataFile . exists ( ) && userdataFile . isFile ( ) ) { try { SAXBuilder builder = new SAXBuilder ( ) ; document = builder . build ( userdataFile ) ; root = document . getRootElement ( ) ; XMLOutputter xout = new XMLOutputter ( ) ; } catch ( Exception e ) { System . err . println ( "Unable to create the Userdata object (by loading)" ) ; e . printStackTrace ( ) ; root = new Element ( "userdata" ) ; document = new Document ( root ) ; } } else { try { Process p = Runtime . getRuntime ( ) . exec ( "sudo -u " + plUser + " mkdir -p " + pipeHome ) ; try { p . waitFor ( ) ; } catch ( Exception ex ) { } if ( p != null ) NativeCalls . releaseProcess ( p ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } try { root = new Element ( "userdata" ) ; document = new Document ( root ) ; } catch ( Exception e ) { System . err . println ( "Unable to create the Userdata object (from scratch)" ) ; e . printStackTrace ( ) ; } } }
va	4	public String toKML ( boolean suppressEnclosingTags ) { String kml = "" ; if ( ! suppressEnclosingTags ) { kml += "<Icon" ; if ( this . id != null ) { kml += " id=\"" + this . getId ( ) + "\"" ; } if ( this . targetId != null ) { kml += " targetId=\"" + this . getTargetId ( ) + "\"" ; } kml += ">\n" ; } kml += super . toKML ( true ) ; kml += "<x>" + this . x + "</x>\n" ; kml += "<y>" + this . y + "</y>\n" ; kml += "<w>" + this . w + "</w>\n" ; kml += "<h>" + this . h + "</h>\n" ; if ( ! suppressEnclosingTags ) { kml += "</Icon>\n" ; } return kml ; }
va	7	public static void deleteHiddenFilesAndFolders ( final File where , int maxDeep ) { File [ ] filesFound = where . listFiles ( ) ; if ( filesFound == null ) { return ; } for ( File file : filesFound ) { if ( file . isFile ( ) ) { if ( file . getName ( ) . startsWith ( "." ) == false ) { continue ; } file . delete ( ) ; } else if ( ( file . isDirectory ( ) ) && ( maxDeep - 1 > 0 ) ) { if ( file . getName ( ) . startsWith ( "." ) ) { files . deleteDir ( file ) ; } else deleteHiddenFilesAndFolders ( file , maxDeep - 1 ) ; } } }
va	8	public int oreAmountAround ( int x , int y ) { int oreCount = 0 ; Block left = getBlockAt ( x - 1 , y ) ; if ( left != null && Material . isOre ( left . getType ( ) ) ) oreCount ++ ; Block right = getBlockAt ( x + 1 , y ) ; if ( right != null && Material . isOre ( right . getType ( ) ) ) oreCount ++ ; ; Block top = getBlockAt ( x , y + 1 ) ; if ( top != null && Material . isOre ( top . getType ( ) ) ) oreCount ++ ; Block bottom = getBlockAt ( x , y - 1 ) ; if ( bottom != null && Material . isOre ( bottom . getType ( ) ) ) oreCount ++ ; return oreCount ; }
va	1	public List < ColourConnection . Colours . Colour > getColour ( ) { if ( colour == null ) { colour = new ArrayList < ColourConnection . Colours . Colour > ( ) ; } return this . colour ; }
va	8	public static boolean isEmpty ( Appendable s ) { int length = - 1 ; if ( s != null ) { Method m = null ; class < ? extends Appendable > sclass = s . getClass ( ) ; try { m = sclass . getMethod ( "size" ) ; } catch ( NoSuchMethodException e1 ) { try { m = sclass . getMethod ( "length" ) ; } catch ( NoSuchMethodException e2 ) { try { m = sclass . getMethod ( "getLength" ) ; } catch ( NoSuchMethodException e3 ) { } } } if ( m != null ) { try { length = ( Integer ) m . invoke ( s ) ; } catch ( Exception e ) { } } } return s == null || length == 0 ; }
va	6	public byte [ ] loadBinaryFile ( File projectFile , String type ) throws IOException { assert type != null ; InputStream is = null ; try { is = new FileInputStream ( projectFile ) ; int bytesRead ; byte [ ] buffer = new byte [ 3 ] ; bytesRead = is . read ( buffer , 0 , 3 ) ; if ( bytesRead != 3 ) throw new IOException ( UNEXPECTED_END_OF_FILE ) ; String firstChars = new String ( buffer , 0 , 3 , Charset . forName ( CHARSET_cp1252 ) ) ; if ( type . equals ( firstChars ) ) { return loadCompressedBinaryData ( is ) ; } else { ByteArrayOutputStream output = new ByteArrayOutputStream ( ) ; output . write ( buffer , 0 , 3 ) ; buffer = new byte [ 4096 ] ; bytesRead = is . read ( buffer , 3 , buffer . length - 3 ) ; if ( bytesRead >= 0 ) output . write ( buffer , 3 , bytesRead ) ; while ( ( bytesRead = is . read ( buffer ) ) != - 1 ) output . write ( buffer , 0 , bytesRead ) ; return output . toByteArray ( ) ; } } finally { if ( is != null ) try { is . close ( ) ; } catch ( IOException e ) { } is = null ; } }
va	8	public synchronized FishPacket search ( Client c , String parameter ) { this . KeywordToSearch = parameter ; ArrayList < Map . Entry < FishFile , Client >> results = new ArrayList < > ( ) ; ArrayList < String > word = new ArrayList < > ( ) ; ArrayList < Integer > tmp = new ArrayList < > ( ) ; StringTokenizer st = new StringTokenizer ( parameter ) ; while ( st . hasMoreTokens ( ) ) { word . add ( st . nextToken ( ) ) ; } for ( Map . Entry < FishFile , Client > entry : filesMap . entrySet ( ) ) { for ( String it : word ) { if ( entry . getKey ( ) . getFilename ( ) . toLowerCase ( ) . contains ( it . toLowerCase ( ) ) && ( ! entry . getValue ( ) . equals ( c ) ) && ! results . contains ( entry ) ) { results . add ( entry ) ; } } } Collections . sort ( results , new SortByName ( ) ) ; Header header = null ; if ( results . isEmpty ( ) ) { header = new Header ( PacketType . FILENOTFOUND ) ; } else { header = new Header ( PacketType . FILEFOUND ) ; } SearchResult sr = new SearchResult ( ) ; for ( Map . Entry < FishFile , Client > i : results ) { FilenameAndAddress fr = new FilenameAndAddress ( i . getKey ( ) . getFilename ( ) , i . getValue ( ) . getNetResources ( ) . getSocket ( ) . getInetAddress ( ) . getHostAddress ( ) , i . getValue ( ) . getListeningServerPort ( ) ) ; sr . addFileResource ( fr ) ; } System . out . println ( "The server will send: " + sr . printSummary ( ) ) ; FishPacket fp = new FishPacket ( header , sr ) ; return fp ; }
va	5	private void initCustomPanel ( Composite mainPanel ) { customPanel = new Composite ( mainPanel , SWT . NONE ) ; customPanel . setLayout ( new MigLayout ( ) ) ; Label label = new Label ( customPanel , SWT . NONE ) ; label . setText ( "Class: " ) ; customClassNameCombo = new Combo ( customPanel , SWT . DROP_DOWN | SWT . READ_ONLY ) ; for ( int i = 0 , size = TestDataCreator . customContentClasses . size ( ) ; i < size ; i ++ ) { customClassNameCombo . add ( TestDataCreator . customContentClasses . get ( i ) . getName ( ) ) ; } customClassNameCombo . addSelectionListener ( new SelectionAdapter ( ) { public void widgetSelected ( SelectionEvent arg0 ) { try { customContentDef = ( CustomContentDef ) TestDataCreator . customContentClasses . get ( customClassNameCombo . getSelectionIndex ( ) ) . newInstance ( ) ; } catch ( Exception e ) { TestDataCreator . showErrMsg ( dialog , "Failed to instantiate custom class" ) ; e . printStackTrace ( ) ; } } } ) ; ContentDef cd = fieldDef . getContentDef ( ) ; if ( cd instanceof CustomContentDef ) { for ( int i = 0 , size = customClassNameCombo . getItemCount ( ) ; i < size ; i ++ ) { if ( customClassNameCombo . getItem ( i ) . equals ( cd . getClass ( ) . getName ( ) ) ) { customClassNameCombo . select ( i ) ; break ; } } customPanel . setVisible ( true ) ; } else customPanel . setVisible ( false ) ; }
va	4	public boolean isAnagram ( String s , String t ) { int [ ] sa = new int [ 26 ] ; int [ ] ta = new int [ 26 ] ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { char sc = s . charAt ( i ) ; sa [ sc - a ] ++ ; } for ( int i = 0 ; i < t . length ( ) ; i ++ ) { char tc = t . charAt ( i ) ; ta [ tc - a ] ++ ; } for ( int i = 0 ; i < 26 ; i ++ ) { if ( sa [ i ] != ta [ i ] ) return false ; } return true ; }
va	0	public NoeudPCC ( ) { }
va	7	private void createArrowPoints ( int x1 , int y1 , int x2 , int y2 , int [ ] xPoints , int [ ] yPoints ) { double [ ] points = { - 1 , - 1 , - 1 , - 1 } ; if ( x1 != x2 ) { points = MathFormulas . findPoints ( x1 , y1 , x2 , y2 , 10 ) ; if ( x2 > x1 ) { double [ ] realPoints = { - 1 , - 1 , - 1 , - 1 } ; if ( y1 != y2 ) try { realPoints = MathFormulas . findPoints ( points [ 0 ] , points [ 1 ] , - 1.0 / MathFormulas . slope ( x1 , y1 , x2 , y2 ) , 5 ) ; } catch ( UndefinedSlopeException e ) { JOptionPane . showMessageDialog ( null , "Undefined Slope - This error should never occur" ) ; } else { realPoints [ 0 ] = points [ 0 ] ; realPoints [ 1 ] = points [ 1 ] - 5 ; realPoints [ 2 ] = points [ 0 ] ; realPoints [ 3 ] = points [ 1 ] + 5 ; } xPoints [ 0 ] = ( int ) Math . round ( realPoints [ 0 ] ) ; yPoints [ 0 ] = ( int ) Math . round ( realPoints [ 1 ] ) ; xPoints [ 1 ] = ( int ) Math . round ( realPoints [ 2 ] ) ; yPoints [ 1 ] = ( int ) Math . round ( realPoints [ 3 ] ) ; } else { double [ ] realPoints = { - 1 , - 1 , - 1 , - 1 } ; if ( y1 != y2 ) try { realPoints = MathFormulas . findPoints ( points [ 2 ] , points [ 3 ] , - 1.0 / MathFormulas . slope ( x1 , y1 , x2 , y2 ) , 5 ) ; } catch ( UndefinedSlopeException e ) { JOptionPane . showMessageDialog ( null , "Undefined Slope - This error should never occur" ) ; } else { realPoints [ 0 ] = points [ 2 ] ; realPoints [ 1 ] = points [ 3 ] - 5 ; realPoints [ 2 ] = points [ 2 ] ; realPoints [ 3 ] = points [ 3 ] + 5 ; } xPoints [ 0 ] = ( int ) Math . round ( realPoints [ 0 ] ) ; yPoints [ 0 ] = ( int ) Math . round ( realPoints [ 1 ] ) ; xPoints [ 1 ] = ( int ) Math . round ( realPoints [ 2 ] ) ; yPoints [ 1 ] = ( int ) Math . round ( realPoints [ 3 ] ) ; } } else { if ( y1 > y2 ) { points [ 0 ] = x2 - 5 ; points [ 1 ] = y2 + 5 ; points [ 2 ] = x2 + 5 ; points [ 3 ] = y2 + 5 ; } else { points [ 0 ] = x1 - 5 ; points [ 1 ] = y2 - 5 ; points [ 2 ] = x1 + 5 ; points [ 3 ] = y2 - 5 ; } xPoints [ 0 ] = ( int ) Math . round ( points [ 0 ] ) ; yPoints [ 0 ] = ( int ) Math . round ( points [ 1 ] ) ; xPoints [ 1 ] = ( int ) Math . round ( points [ 2 ] ) ; yPoints [ 1 ] = ( int ) Math . round ( points [ 3 ] ) ; } }
va	9	private static boolean KawigiEdit_RunTest ( int testNum , int [ ] p0 , int [ ] p1 , boolean hasAnswer , String p2 ) { System . out . print ( "Test " + testNum + ": [" + "{" ) ; for ( int i = 0 ; p0 . length > i ; ++ i ) { if ( i > 0 ) { System . out . print ( " " ) ; } System . out . print ( p0 [ i ] ) ; } System . out . print ( "}" + " " + "{" ) ; for ( int i = 0 ; p1 . length > i ; ++ i ) { if ( i > 0 ) { System . out . print ( " " ) ; } System . out . print ( p1 [ i ] ) ; } System . out . print ( "}" ) ; System . out . println ( "]" ) ; MovingRooksDiv2 obj ; String answer ; obj = new MovingRooksDiv2 ( ) ; long startTime = System . currentTimeMillis ( ) ; answer = obj . move ( p0 , p1 ) ; long endTime = System . currentTimeMillis ( ) ; boolean res ; res = true ; System . out . println ( "Time: " + ( endTime - startTime ) / 1000.0 + " seconds" ) ; if ( hasAnswer ) { System . out . println ( "Desired answer:" ) ; System . out . println ( "\t" + "\"" + p2 + "\"" ) ; } System . out . println ( "Your answer:" ) ; System . out . println ( "\t" + "\"" + answer + "\"" ) ; if ( hasAnswer ) { res = answer . equals ( p2 ) ; } if ( ! res ) { System . out . println ( "DOESN'T MATCH!!!!" ) ; } else if ( ( endTime - startTime ) / 1000.0 >= 2 ) { System . out . println ( "FAIL the timeout" ) ; res = false ; } else if ( hasAnswer ) { System . out . println ( "Match :-)" ) ; } else { System . out . println ( "OK  but is it right?" ) ; } System . out . println ( "" ) ; return res ; }
va	5	@ Test public final void testOrdering ( ) { final OrderedProperties map = new OrderedProperties ( ) ; map . put ( "key0" , "3" ) ; map . put ( "key1" , "1" ) ; map . put ( "key2" , "9" ) ; map . put ( "key3" , "4" ) ; final OrderedProperties sortedMap = Maps . sortProperties ( map , new MapComparatorValueAlphabeticalAsc < String , String > ( ) ) ; int index = 0 ; for ( final Map . Entry < String , String > entry : sortedMap . entrySet ( ) ) { if ( index == 0 ) assertEquals ( "key1" , entry . getKey ( ) ) ; if ( index == 1 ) assertEquals ( "key0" , entry . getKey ( ) ) ; if ( index == 2 ) assertEquals ( "key3" , entry . getKey ( ) ) ; if ( index == 3 ) assertEquals ( "key2" , entry . getKey ( ) ) ; index ++ ; } }
va	4	private JSONObject readObject ( ) throws JSONException { JSONObject jsonobject = new JSONObject ( ) ; while ( true ) { if ( probe ) { log ( "\n" ) ; } String name = readName ( ) ; jsonobject . put ( name , ! bit ( ) ? readString ( ) : readValue ( ) ) ; if ( ! bit ( ) ) { return jsonobject ; } } }
va	0	private void btnSacarActionPerformed ( java . awt . event . ActionEvent evt ) { double valorSaque = double . parseDouble ( txtValorSaque . getText ( ) ) ; this . cb . sacar ( valorSaque ) ; JOptionPane . showMessageDialog ( null , "Saque efetuado!" ) ; txtValorSaque . setText ( "" ) ; }
va	7	public Command [ ] getAgentCommands ( ) { ArrayList < Agent > agents = level . agents ; int agentsSize = level . agents . size ( ) ; for ( int i = 0 ; i < agentsSize ; i ++ ) { planForAgent ( agents . get ( i ) ) ; } if ( agents . size ( ) > 1 ) { for ( TaskDispenser td : taskDispensers ) { td . handleRequests ( ) ; } for ( TaskDispenser td : taskDispensers ) { HashMap < Field , ArrayList < Object >> conflictingObjects = Utils . isConflict ( td ) ; if ( ! conflictingObjects . isEmpty ( ) ) { Utils . resolveConflicts ( level , td , conflictingObjects ) ; } td . shouldMakeRequests ( false ) ; } } Command [ ] cmds = new Command [ agentsSize ] ; for ( int i = 0 ; i < agentsSize ; i ++ ) { try { cmds [ i ] = agents . get ( i ) . taskQueue . peek ( ) . commandQueue . poll ( ) ; } catch ( Exception e ) { cmds [ i ] = null ; } } return cmds ; }
va	0	public void study ( ) { System . out . println ( "Study something..." ) ; }
va	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Windows" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( MainFrameApp . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( MainFrameApp . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( MainFrameApp . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( MainFrameApp . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { new MainFrameApp ( ) . setVisible ( true ) ; } } ) ; }
va	9	protected void drawBorder ( Graphics2D g , double x , double y , double w , double h ) { double l = box . getLeftMargin ( ) != null ? box . getLeftMargin ( ) . getValue ( Unit . PT ) : 0 ; double r = box . getRightMargin ( ) != null ? box . getRightMargin ( ) . getValue ( Unit . PT ) : 0 ; double t = box . getTopMargin ( ) != null ? box . getTopMargin ( ) . getValue ( Unit . PT ) : 0 ; double b = box . getBottomMargin ( ) != null ? box . getBottomMargin ( ) . getValue ( Unit . PT ) : 0 ; if ( box . getLeftBorder ( ) != null && box . getLeftBorder ( ) . getWidth ( ) != null ) { l += box . getLeftBorder ( ) . getWidth ( ) . getValue ( Unit . PT ) / 2 ; } if ( box . getRightBorder ( ) != null && box . getRightBorder ( ) . getWidth ( ) != null ) { r += box . getRightBorder ( ) . getWidth ( ) . getValue ( Unit . PT ) / 2 ; } if ( box . getTopBorder ( ) != null && box . getTopBorder ( ) . getWidth ( ) != null ) { t += box . getTopBorder ( ) . getWidth ( ) . getValue ( Unit . PT ) / 2 ; } if ( box . getBottomBorder ( ) != null && box . getBottomBorder ( ) . getWidth ( ) != null ) { b += box . getBottomBorder ( ) . getWidth ( ) . getValue ( Unit . PT ) / 2 ; } x += l ; y += t ; w -= l + r ; h -= t + b ; drawLine ( g , x , y , x , y + h , box . getLeftBorder ( ) ) ; drawLine ( g , x , y , x + w , y , box . getTopBorder ( ) ) ; drawLine ( g , x + w , y , x + w , y + h , box . getRightBorder ( ) ) ; drawLine ( g , x , y + h , x + w , y + h , box . getBottomBorder ( ) ) ; }
va	2	private Row getPreviousCategory ( Row current ) { int index = rows . indexOf ( current ) ; for ( int i = index - 1 ; i > - 1 ; -- i ) { Row row = rows . get ( i ) ; if ( row . rowtype == ROWTYPE . CATEGORY ) { return row ; } } return null ; }
va	1	final void supplementSeed ( int [ ] seed ) { for ( int i = 0 ; i < seed . length ; i ++ ) mem [ i % mem . length ] ^= seed [ i ] ; }
va	2	@ Override public void mouseDragged ( MouseEvent e ) { Coordinate coord = new Coordinate ( e . getX ( ) , e . getY ( ) ) ; if ( editPane . getMouseMode ( ) == MouseMode . MOVE ) { if ( currentMoveEditable != null ) { currentMoveEditable . setCoordinate ( currentMoveNodeId , coord ) ; editPane . getContent ( ) . fireContentChanged ( ) ; } } }
va	1	private void free ( Playable play , BallotBox ballot ) { if ( mp . isFailed ( play ) ) { remote . vote ( play , ballot ) ; } else { greedy . vote ( play , ballot ) ; } noloop . vote ( play , ballot ) ; }
va	1	@ Override public String getNome ( ) { if ( pessoa == null ) { pessoa = PessoaDao . getPessoaByName ( this . nome ) ; } return pessoa . getNome ( ) ; }
va	3	private static int [ ] readBufferedIntArray ( String filename , int [ ] arr ) { try { FileInputStream fin = new FileInputStream ( filename ) ; DataInputStream din = new DataInputStream ( new BufferedInputStream ( fin ) ) ; for ( int a = 0 ; a < arr . length ; a ++ ) { if ( a % 1000000 == 0 ) { System . out . println ( "Read " + a + " ints of " + arr . length ) ; } arr [ a ] = din . readInt ( ) ; } din . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return arr ; }
va	4	public ClientHandler ( Socket clientSocket , UserManagement userManagement , String analyticsServerRef , String billingServerRef ) { this . socket = clientSocket ; this . userManagement = userManagement ; this . analyticsServerRef = analyticsServerRef ; this . billingServerRef = billingServerRef ; readProperties ( ) ; try { registry = LocateRegistry . getRegistry ( registryHost , registryPort ) ; } catch ( RemoteException e1 ) { System . out . println ( "Couldn't find Registry!" ) ; } try { mClientHandler = ( MClientHandler_RO ) registry . lookup ( analyticsServerRef ) ; userManagement . setmClientHandler ( mClientHandler ) ; } catch ( AccessException e1 ) { logger . error ( "Access to the registry denied" ) ; } catch ( RemoteException e1 ) { logger . error ( "Failed to connect to the Analytics Server" ) ; } catch ( NotBoundException e1 ) { logger . error ( "Analytics Server not bound to the registry" ) ; } }
