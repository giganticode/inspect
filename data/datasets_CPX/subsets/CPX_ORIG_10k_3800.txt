tr	6	private int method185 ( int i , int j ) { if ( i == - 2 ) return bc614e ; if ( i == - 1 ) { if ( j < 0 ) j = 0 ; else if ( j > 127 ) j = 127 ; j = 127 - j ; return j ; } j = ( j * ( i & 7f ) ) / 128 ; if ( j < 2 ) j = 2 ; else if ( j > 126 ) j = 126 ; return ( i & ff80 ) + j ; }
tr	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( ListaObjetos . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( ListaObjetos . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( ListaObjetos . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( ListaObjetos . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { ListaObjetos dialog = new ListaObjetos ( new javax . swing . JFrame ( ) , true ) ; dialog . addWindowListener ( new java . awt . event . WindowAdapter ( ) { @ Override public void windowClosing ( java . awt . event . WindowEvent e ) { System . exit ( 0 ) ; } } ) ; dialog . setVisible ( true ) ; } } ) ; }
tr	0	public boolean targetsAir ( ) { return targetsAir_native ( pointer ) ; }
tr	0	private void doActionExit ( ) { saveChanges ( ) ; }
tr	5	@ Override public int compare ( Course course1 , Course course2 ) { if ( sortOrder == SortOrder . ASCENDING ) { if ( course1 . getStudents ( ) < course2 . getStudents ( ) ) { return - 1 ; } else if ( course1 . getStudents ( ) == course2 . getStudents ( ) ) { return 0 ; } else { return 1 ; } } else { if ( course1 . getStudents ( ) < course2 . getStudents ( ) ) { return 1 ; } else if ( course1 . getStudents ( ) == course2 . getStudents ( ) ) { return 0 ; } else { return - 1 ; } } }
tr	8	public double getMin ( ) { if ( type == 0 ) { for ( int i = 0 ; i < valueCount && i < values . length ; i ++ ) { if ( values [ i ] < min ) { min = values [ i ] ; } } if ( lable != null ) { lable . setMin ( min ) ; } } if ( type == 1 ) { for ( int i = 0 ; i < graphValues . length ; i ++ ) { if ( graphValues [ i ] . getMin ( ) < min ) { max = graphValues [ i ] . getMin ( ) ; } } return min ; } return min ; }
tr	3	AbstractNode type ( ) { AbstractNode node = null ; if ( test ( IDENT ) ) { node = constIdent ( ) ; } else if ( test ( ARRAY ) ) { node = arrayType ( ) ; } else if ( test ( RECORD ) ) { node = recordType ( ) ; } else { failExpectation ( "type" ) ; } return node ; }
tr	3	public String getHealthText ( ) { double health = getHealth ( ) ; if ( health > 0.75 ) { return "excellently" ; } else if ( health > 0.50 ) { return "well" ; } else if ( health > 0.25 ) { return "decently" ; } else { return "poorly" ; } }
tr	1	@ Override public InetSocketAddress getLocalSocketAddress ( WebSocket conn ) { if ( socket != null ) return ( InetSocketAddress ) socket . getLocalSocketAddress ( ) ; return null ; }
tr	5	private LinkedList < String > extractKeywords ( String filename ) { LinkedList < String > keywords = new LinkedList < String > ( ) ; int posOfDot = filename . lastIndexOf ( . ) ; if ( posOfDot != - 1 ) { keywords . add ( filename . substring ( posOfDot ) ) ; filename = filename . substring ( 0 , posOfDot ) ; } filename = filename . replaceAll ( "[0-9]+" , " " ) . trim ( ) ; String [ ] splitCamelAndDelim = filename . split ( "((?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])|[ |.|_|\\-|\\(|\\)])" ) ; keywords . addAll ( Arrays . asList ( splitCamelAndDelim ) ) ; for ( Iterator < String > iter = keywords . iterator ( ) ; iter . hasNext ( ) ; ) { String item = iter . next ( ) . trim ( ) ; if ( item . length ( ) < 4 && ! ( item . length ( ) == 3 && item . equals ( item . toUpperCase ( ) ) ) ) iter . remove ( ) ; } return keywords ; }
tr	7	public void saveCollection ( ConstraintPuzzleCollection p ) { Element currentCollections = workingDocument . getRootElement ( ) . element ( "PuzzleCollections" ) ; Element puzzleCollectionsElement = null ; for ( Object collectionObject : currentCollections . elements ( "PuzzleCollection" ) ) { Element collection = ( Element ) collectionObject ; if ( collection . attributeValue ( "name" ) . equals ( p . getName ( ) ) ) { puzzleCollectionsElement = collection ; break ; } } Element puzzlesElement ; if ( puzzleCollectionsElement == null ) { puzzleCollectionsElement = currentCollections . addElement ( "PuzzleCollection" ) ; puzzleCollectionsElement . addAttribute ( "name" , p . getName ( ) ) ; puzzleCollectionsElement . addAttribute ( "classname" , p . getPuzzleClass ( ) . getName ( ) ) ; Element rulesElement = puzzleCollectionsElement . addElement ( "Rules" ) ; for ( Rule r : p . getRuleset ( ) . getRules ( ) ) { Element ruleElement = rulesElement . addElement ( "Rule" ) ; ruleElement . setText ( r . getClass ( ) . getName ( ) ) ; } } else { puzzleCollectionsElement . remove ( puzzleCollectionsElement . element ( "Puzzles" ) ) ; } puzzlesElement = puzzleCollectionsElement . addElement ( "Puzzles" ) ; for ( ConstraintPuzzle cp : p . getPuzzles ( ) ) { Element puzzleElement = puzzlesElement . addElement ( "Puzzle" ) ; Element puzzleDataElement = puzzleElement . addElement ( "PuzzleData" ) ; StringBuffer dataStringBuffer = new StringBuffer ( ) ; for ( int i = 0 ; i < cp . getNumberOfElements ( ) ; i ++ ) { int elementValue = cp . getElementWithNumber ( i ) ; if ( i > 0 ) { dataStringBuffer . append (   ) ; } dataStringBuffer . append ( elementValue ) ; } puzzleDataElement . setText ( dataStringBuffer . toString ( ) ) ; } save ( ) ; }
tr	7	public static void remove ( final String opt_ , final SETTING_TYPE settingType ) { if ( settingType . equals ( SETTING_TYPE . BOOL ) ) { booleanOptions . remove ( opt_ ) ; } else if ( settingType . equals ( SETTING_TYPE . int ) ) { integerOptions . remove ( opt_ ) ; } else if ( settingType . equals ( SETTING_TYPE . long ) ) { longOptions . remove ( opt_ ) ; } else if ( settingType . equals ( SETTING_TYPE . float ) ) { floatOptions . remove ( opt_ ) ; } else if ( settingType . equals ( SETTING_TYPE . double ) ) { doubleOptions . remove ( opt_ ) ; } else if ( settingType . equals ( SETTING_TYPE . STRING ) ) { stringOptions . remove ( opt_ ) ; } else if ( settingType . equals ( SETTING_TYPE . PATH ) ) { pathOptions . remove ( opt_ ) ; } }
tr	3	public static String toString ( char what ) { switch ( what ) { case EPSILON : return "eps" ; case else : return "else" ; case BLANK : return "blank" ; default : return "" + what ; } }
tr	7	public boolean validarEntradaRegistro ( ) { if ( this . txtNombre . getText ( ) . equals ( "" ) || this . txtEmail . getText ( ) . equals ( "" ) || this . txtContraseña . getText ( ) . equals ( "" ) || this . txtRepetirContraseña . getText ( ) . equals ( "" ) ) { JOptionPane . showMessageDialog ( null , "Debe completar todos los campos llave (*)" , "Campos Incompletos" , JOptionPane . INFORMATION_MESSAGE ) ; return false ; } else if ( ! txtContraseña . getText ( ) . equals ( this . txtRepetirContraseña . getText ( ) ) ) { JOptionPane . showMessageDialog ( null , "Las contrase\u00F1as no coinciden" , "Error Contrase\u00F1a" , JOptionPane . INFORMATION_MESSAGE ) ; txtContraseña . requestFocus ( ) ; txtContraseña . selectAll ( ) ; txtRepetirContraseña . setText ( "" ) ; return false ; } else if ( ! this . jCheckBox1 . isSelected ( ) ) { JOptionPane . showMessageDialog ( null , "Debe Aceptar los terminos y condiciones" , "Terminos y Condiciones" , JOptionPane . INFORMATION_MESSAGE ) ; return false ; } else if ( this . txtTelefono . getText ( ) . length ( ) > 10 ) { JOptionPane . showMessageDialog ( null , "El n\u00FAmero telef\u00F3nico no puede tener m\u00E1s de 10 n\u00FAmeros" , "N\u00FAmero inv\u00E1lido" , JOptionPane . INFORMATION_MESSAGE ) ; this . txtTelefono . requestFocus ( ) ; } return crearEntradaRegistro ( ) ; }
tr	0	public IOutputtedNeuron [ ] getOutputNeurons ( ) { return this . outputNeurons ; }
tr	9	public List < Tuple < Integer , Integer >> leastEncumbered ( int [ ] [ ] mosqBoard ) { List < Tuple < Integer , Integer >> rank = new ArrayList < Tuple < Integer , Integer >> ( ) ; boolean [ ] [ ] board = getValidBoard ( mosqBoard , 0 ) ; int [ ] [ ] quadrantCount = new int [ 2 ] [ 2 ] ; for ( int i = 0 ; i < 2 ; i ++ ) { for ( int j = 0 ; j < 2 ; j ++ ) { int wallCount = 0 ; for ( int x = i * 50 ; x < 50 * ( i + 1 ) ; x ++ ) { for ( int y = j * 50 ; y < 50 * ( j + 1 ) ; y ++ ) { if ( ! board [ x ] [ y ] ) { wallCount ++ ; } } } quadrantCount [ i ] [ j ] = wallCount ; } } for ( int q = 0 ; q < 4 ; q ++ ) { int smallest = Integer . MAX_VALUE ; Tuple < Integer , Integer > smallestQ = null ; for ( int i = 0 ; i < 2 ; i ++ ) { for ( int j = 0 ; j < 2 ; j ++ ) { log . debug ( "i" + i + "j" + j + " count " + quadrantCount [ i ] [ j ] ) ; if ( quadrantCount [ i ] [ j ] < smallest ) { smallestQ = new Tuple < Integer , Integer > ( i , j ) ; smallest = quadrantCount [ i ] [ j ] ; } } } int x , y ; if ( smallestQ . x == 0 ) x = 20 + ( smallestQ . x ) * 50 ; else x = 30 + ( smallestQ . x ) * 50 ; if ( smallestQ . y == 0 ) y = 20 + ( smallestQ . y ) * 50 ; else y = 30 + ( smallestQ . y ) * 50 ; rank . add ( new Tuple < Integer , Integer > ( x , y ) ) ; quadrantCount [ smallestQ . x ] [ smallestQ . y ] = Integer . MAX_VALUE ; } return rank ; }
tr	4	@ Override public int compareTo ( Card o ) { if ( rank . getValue ( ) < o . rank . getValue ( ) ) { return - 1 ; } else if ( rank . getValue ( ) > o . rank . getValue ( ) ) { return 1 ; } return suit . getValue ( ) < o . suit . getValue ( ) ? - 1 : suit . getValue ( ) == o . suit . getValue ( ) ? 0 : 1 ; }
tr	2	private float [ ] splitToVertex ( final String line , final char split , final float [ ] vector ) { int start = 0 ; int end = line . indexOf ( split , start ) ; int i = 0 ; while ( end != - 1 && i < vector . length ) { vector [ i ++ ] = Utils . parseFloat ( line , start , end ) ; start = end + 1 ; end = line . indexOf ( split , start ) ; } end = line . length ( ) ; vector [ i ] = Utils . parseFloat ( line , start , end ) ; return vector ; }
tr	9	private static String readLastLine ( File file , String charset ) throws IOException { if ( ! file . exists ( ) || file . isDirectory ( ) || ! file . canRead ( ) ) { return null ; } RandomAccessFile raf = null ; try { raf = new RandomAccessFile ( file , "r" ) ; long len = raf . length ( ) ; if ( len == 0 ) { return "" ; } else { long pos = len - 1 ; while ( pos > 0 ) { pos -- ; raf . seek ( pos ) ; if ( raf . readByte ( ) == '' ) { break ; } } if ( pos == 0 ) { raf . seek ( 0 ) ; } byte [ ] bytes = new byte [ ( int ) ( len - pos ) ] ; raf . read ( bytes ) ; if ( charset == null ) { return new String ( bytes ) ; } else { return new String ( bytes , charset ) ; } } } catch ( FileNotFoundException e ) { } finally { if ( raf != null ) { try { raf . close ( ) ; } catch ( Exception e2 ) { } } } return null ; }
tr	4	public boolean isUniqueChars ( String a ) { if ( a == null ) return true ; if ( a . length ( ) < 2 ) return true ; boolean [ ] char_set = new boolean [ 256 ] ; for ( int i = 0 ; i < a . length ( ) ; i ++ ) { int val = a . charAt ( i ) ; if ( char_set [ val ] ) return false ; char_set [ val ] = true ; } return true ; }
tr	6	public void render ( VPoint cm , VGame vg , VGraphics g ) { if ( l > 0 ) { l -- ; } if ( l <= 0 ) { return ; } VPoint v = new VPoint ( s . x - cm . x , s . y - cm . y , s . z ) ; VPoint osv = VConvert . to2DPoint ( v . x , v . y , v . z ) ; switch ( i ) { case 1 : g . setTexture ( "eft/smoke.png" ) ; g . setColor ( new Color ( 255 , 255 , 255 , l * 2 ) ) ; g . drawRect ( ( int ) osv . x , ( int ) osv . y , 32 , 32 , a ) ; s . x += ( r . nextInt ( 6 ) - 2 ) ; s . y -= 1 ; s . z += ( l ) / 34 ; break ; case 2 : g . setTexture ( "eft/smoke.png" ) ; g . setColor ( new Color ( 255 , 255 , 255 , l * 8 ) ) ; g . drawRect ( ( int ) osv . x , ( int ) osv . y , 16 , 16 , a ) ; s . x += ( r . nextInt ( 6 ) - 2 ) ; s . y -= 1 ; s . z += ( l ) / 34 ; break ; case 3 : g . setColor ( new Color ( 255 , 255 , 255 , 255 ) ) ; Sprite . render ( "bullet" , g , 7 - l , v ) ; break ; case 4 : g . setColor ( new Color ( 255 , 255 , 255 , 255 ) ) ; Sprite . render ( "gauss_bullet" , g , 5 - l , v ) ; break ; default : } }
tr	4	private void setUsersState ( int state ) { final int columnId = 0 ; if ( tableUsers . getSelectedRow ( ) != - 1 ) { int userId = ( Integer ) tableUsers . getValueAt ( tableUsers . getSelectedRow ( ) , columnId ) ; Statement statement = null ; ResultSet result = null ; try { statement = usersDAO . getConnection ( ) . createStatement ( ResultSet . TYPE_SCROLL_SENSITIVE , ResultSet . CONCUR_UPDATABLE ) ; result = statement . executeQuery ( usersDAO . getAllQuery ( ) ) ; while ( result . next ( ) ) { if ( result . getInt ( "ID" ) == userId ) { break ; } } result . updateInt ( "USERSTATE" , state ) ; result . updateRow ( ) ; usersDAO = new UsersDAO ( ) ; usersDAO . initTableModel ( tableUsers , usersDAO . listAll ( ) ) ; } catch ( SQLException exc ) { JOptionPane . showMessageDialog ( this , "\u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u043E\u0431\u043D\u043E\u0432\u043B\u0435\u043D\u0438\u0438 \u0434\u0430\u043D\u043D\u044B\u0445" ) ; } } else { JOptionPane . showMessageDialog ( this , "\u041D\u0435 \u0432\u044B\u0431\u0440\u0430\u043D \u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u0435\u043B\u044C \u0432 \u0442\u0430\u0431\u043B\u0438\u0446\u0435!" ) ; return ; } }
tr	7	public Object nextValue ( ) throws JSONException { char c = this . nextClean ( ) ; String string ; switch ( c ) { case " : case ' : return this . nextString ( c ) ; case { : this . back ( ) ; return new JSONObject ( this ) ; case [ : this . back ( ) ; return new JSONArray ( this ) ; } StringBuffer sb = new StringBuffer ( ) ; while ( c >=   && " :]}/\\\"[{;=#" . indexOf ( c ) < 0 ) { sb . append ( c ) ; c = this . next ( ) ; } this . back ( ) ; string = sb . toString ( ) . trim ( ) ; if ( "" . equals ( string ) ) { throw this . syntaxError ( "Missing value" ) ; } return JSONObject . stringToValue ( string ) ; }
tr	9	@ Override public void characters ( char [ ] c , int start , int length ) { if ( length > 0 ) { boolean wr = true ; try { if ( inNote && ! showNote ) { wr = false ; } if ( inHeader && ! showHeader ) { wr = false ; } if ( inForeign ) { } if ( inDocEdition ) { wr = false ; } if ( inAbbr && wr ) { if ( abbrContent == null ) { abbrContent = new StringBuilder ( ) ; } abbrContent . append ( c , start , length ) ; wr = false ; } if ( wr ) { buffer . append ( c , start , length ) ; } } catch ( java . nio . BufferOverflowException x ) { System . err . println ( "Insufficient text buffer size" ) ; System . exit ( 1 ) ; } } }
tr	5	public void delete ( UTypePk pk ) throws UTypeDaoException { long t1 = System . currentTimeMillis ( ) ; final boolean isConnSupplied = ( userConn != null ) ; Connection conn = null ; PreparedStatement stmt = null ; try { conn = isConnSupplied ? userConn : ResourceManager . getConnection ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Executing " + SQL_DELETE + " with PK: " + pk ) ; } stmt = conn . prepareStatement ( SQL_DELETE ) ; stmt . setString ( 1 , pk . getUType ( ) ) ; int rows = stmt . executeUpdate ( ) ; long t2 = System . currentTimeMillis ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( rows + " rows affected (" + ( t2 - t1 ) + " ms)" ) ; } } catch ( Exception _e ) { logger . error ( "Exception: " + _e . getMessage ( ) , _e ) ; throw new UTypeDaoException ( "Exception: " + _e . getMessage ( ) , _e ) ; } finally { ResourceManager . close ( stmt ) ; if ( ! isConnSupplied ) { ResourceManager . close ( conn ) ; } } }
tr	7	public static List < String > getProperties ( Object bean ) throws RemoteException { List < String > result = new ArrayList < String > ( ) ; if ( bean == null ) return result ; if ( bean instanceof GenericObject ) { GenericObject o = ( GenericObject ) bean ; result . addAll ( Arrays . asList ( o . getAttributeNames ( ) ) ) ; return result ; } Method [ ] methods = bean . getClass ( ) . getMethods ( ) ; if ( methods == null || methods . length == 0 ) return result ; for ( Method m : methods ) { String name = m . getName ( ) ; if ( name . startsWith ( "get" ) && name . length ( ) > 3 ) result . add ( toProperty ( name ) ) ; } return result ; }
tr	8	private boolean r_Step_1c ( ) { int v_1 ; ket = cursor ; lab0 : do { v_1 = limit - cursor ; lab1 : do { if ( ! ( eq_s_b ( 1 , "y" ) ) ) { break lab1 ; } break lab0 ; } while ( false ) ; cursor = limit - v_1 ; if ( ! ( eq_s_b ( 1 , "Y" ) ) ) { return false ; } } while ( false ) ; bra = cursor ; golab2 : while ( true ) { lab3 : do { if ( ! ( in_grouping_b ( g_v , 97 , 121 ) ) ) { break lab3 ; } break golab2 ; } while ( false ) ; if ( cursor <= limit_backward ) { return false ; } cursor -- ; } slice_from ( "i" ) ; return true ; }
tr	7	public int firstMissingPositive ( int [ ] A ) { int length = A . length ; int i = 0 ; while ( i < length ) { if ( A [ i ] > 0 && A [ i ] <= length && A [ i ] != i + 1 && A [ A [ i ] - 1 ] != A [ i ] ) { int tmp = A [ A [ i ] - 1 ] ; A [ A [ i ] - 1 ] = A [ i ] ; A [ i ] = tmp ; } else i ++ ; } for ( i = 0 ; i < length ; i ++ ) { if ( A [ i ] != i + 1 ) return i + 1 ; } return length + 1 ; }
tr	4	public void testLineSeriesChart ( ) { LineSeriesChart < Number , Number > chart = new LineSeriesChart < Number , Number > ( "Curves" , "X" , "Y" ) ; Collection < LineSeriesItem < Number , Number >> linhaSin = new ArrayList < LineSeriesItem < Number , Number >> ( ) ; for ( double i = 0 ; i <= 6 ; i += 0.01 ) { linhaSin . add ( new LineSeriesItem < Number , Number > ( i , Math . sin ( i ) + 4 ) ) ; } chart . addValue ( linhaSin ) ; Collection < LineSeriesItem < Number , Number >> linhaCos = new ArrayList < LineSeriesItem < Number , Number >> ( ) ; for ( double i = 0 ; i <= 6 ; i += 0.01 ) { linhaCos . add ( new LineSeriesItem < Number , Number > ( i , Math . cos ( i ) ) ) ; } chart . addValue ( linhaCos ) ; Collection < LineSeriesItem < Number , Number >> linhaExp = new ArrayList < LineSeriesItem < Number , Number >> ( ) ; for ( double i = 0 ; i <= 2 ; i += 0.01 ) { linhaExp . add ( new LineSeriesItem < Number , Number > ( i , Math . exp ( i ) + 1 ) ) ; } chart . addValue ( linhaExp ) ; Collection < LineSeriesItem < Number , Number >> linhaReta = new ArrayList < LineSeriesItem < Number , Number >> ( ) ; for ( double i = 0 ; i <= 6 ; i += 0.01 ) { linhaReta . add ( new LineSeriesItem < Number , Number > ( i , i ) ) ; } chart . addValue ( linhaReta ) ; Highlighter highlighter = criarHighlighter ( ) ; chart . getChartConfiguration ( ) . setHighlighter ( highlighter ) ; chart . addSerie ( criarSerie ( "Seno" , "#489104" ) ) ; chart . addSerie ( criarSerie ( "Coseno" , "#c91212" ) ) ; chart . addSerie ( criarSerie ( "Exponensial" , "#7D02B2" ) ) ; chart . addSerie ( criarSerie ( "Reta" , "#066FA7" ) ) ; Legend legend = new Legend ( true , Location . ne ) ; legend . setPlacement ( "outsideGrid" ) ; chart . setLegend ( legend ) ; Axis < String > axis = new AxisString ( ) ; axis . setLabelRenderer ( JqPlotResources . CanvasAxisLabelRenderer ) ; chart . setAxesDefaults ( axis ) ; Axes axes = chart . getAxes ( ) ; XAxis xaxis = axes . getXaxis ( ) ; TickOptions tickOptions = new TickOptions ( ) ; tickOptions . setAngle ( 270 ) ; tickOptions . setLabelPosition ( "end" ) ; xaxis . setTickOptions ( tickOptions ) ; xaxis . setTickRenderer ( JqPlotResources . CanvasAxisTickRenderer ) ; xaxis . setTickInterval ( 1 ) ; axes . getYaxis ( ) . setTickInterval ( 0.50 ) ; axes . getYaxis ( ) . setMax ( 8.50 ) ; axes . getYaxis ( ) . setMin ( - 1.50 ) ; TickOptions tickOptionsY = new TickOptions ( ) ; tickOptionsY . setFormatString ( "%.2f" ) ; axes . getYaxis ( ) . setTickOptions ( tickOptionsY ) ; Grid grid = new Grid ( ) ; grid . setBackground ( "#ffffff" ) ; grid . setGridLineColer ( "#a0a0a0" ) ; chart . getChartConfiguration ( ) . setGrid ( grid ) ; Cursor cursor = new Cursor ( ) ; cursor . setZoom ( true ) ; cursor . setClickReset ( true ) ; chart . getChartConfiguration ( ) . setCursor ( cursor ) ; String json = JqPlotUtils . createJquery ( chart , "div3" ) ; json = json . replaceAll ( "\\$" , "jQuery" ) ; System . out . println ( json ) ; }
tr	6	public void update ( ) { for ( ModelObject o : objects ) o . update ( ) ; for ( ModelObject o : removelist ) o . dispose ( ) ; objects . removeAll ( removelist ) ; removelist . clear ( ) ; objects . addAll ( addlist ) ; addlist . clear ( ) ; if ( seaObject . controller . addlist . size ( ) > 0 || seaObject . controller . removelist . size ( ) > 0 ) { seaObject . controller . controllers . removeAll ( seaObject . controller . removelist ) ; seaObject . controller . controllers . addAll ( seaObject . controller . addlist ) ; seaObject . controller . removelist . clear ( ) ; seaObject . controller . addlist . clear ( ) ; } if ( radarObject . controller . addlist . size ( ) > 0 || radarObject . controller . removelist . size ( ) > 0 ) { radarObject . controller . controllers . removeAll ( radarObject . controller . removelist ) ; radarObject . controller . controllers . addAll ( radarObject . controller . addlist ) ; radarObject . controller . removelist . clear ( ) ; radarObject . controller . addlist . clear ( ) ; } }
tr	9	public int moveToMe ( MyStore < T > other ) { if ( other . size == 0 ) return 0 ; if ( this . size == 0 ) { this . moveAll ( other . size , other . head , this . tail , other ) ; assert ( other . size != 0 || other . head . next == null ) ; assert ( this . size != 0 || this . head . next == null ) ; assert ( this . tail . next == null ) ; assert ( other . tail . next == null ) ; return this . size ; } int initialMySize = this . size ; int initialOtherSize = other . size ; Container < T > thisOld = this . head ; Container < T > otherOld = other . head ; Container < T > thisCurrent = this . head . next ; Container < T > otherCurrent = other . head . next ; int otherRemaining = other . size ; int moved = 0 ; boolean done = false ; while ( true ) { int result = this . compare ( thisCurrent . el , otherCurrent . el ) ; if ( result == 0 ) { if ( otherCurrent . next != null ) { otherOld = otherCurrent ; otherCurrent = otherCurrent . next ; otherRemaining -- ; } else { done = true ; break ; } if ( thisCurrent . next != null ) { thisOld = thisCurrent ; thisCurrent = thisCurrent . next ; } else { break ; } } else if ( result > 0 ) { otherOld . next = otherCurrent . next ; other . size -- ; thisOld . next = otherCurrent ; otherCurrent . next = thisCurrent ; this . size ++ ; moved ++ ; thisOld = otherCurrent ; if ( other . tail == otherCurrent ) { other . tail = otherOld ; } if ( otherOld . next != null ) { otherCurrent = otherOld . next ; otherRemaining -- ; } else { done = true ; break ; } } else { if ( thisCurrent . next != null ) { thisOld = thisCurrent ; thisCurrent = thisCurrent . next ; } else { break ; } } } if ( ! done ) { this . moveAll ( otherRemaining , otherOld , thisCurrent , other ) ; moved += otherRemaining ; } assert ( this . size == initialMySize + moved ) ; assert ( other . size == initialOtherSize - moved ) ; assert ( other . size != 0 || other . head . next == null ) ; assert ( this . size != 0 || this . head . next == null ) ; assert ( this . tail . next == null ) ; assert ( other . tail . next == null ) ; return moved ; }
tr	5	public static Node addTwoNumbers ( Node num1 , Node num2 ) { Node num3 = null ; Node head = null ; int updigit = 0 ; while ( num1 != null && num2 != null ) { int digit1 = num1 . value ; int digit2 = num2 . value ; int newdigit = ( digit1 + digit2 + updigit ) % 10 ; updigit = ( digit1 + digit2 ) / 10 ; Node numNode = new Node ( null , newdigit ) ; if ( num3 == null ) { num3 = numNode ; head = num3 ; } else { num3 . next = numNode ; num3 = numNode ; } num1 = num1 . next ; num2 = num2 . next ; } if ( num1 != null ) { num3 . next = num1 ; } if ( num2 != null ) { num3 . next = num2 ; } return head ; }
tr	0	@ Override public MyDatabase getMysql ( ) { return mysql ; }
tr	1	public List < String > getADMID ( ) { if ( admid == null ) { admid = new ArrayList < String > ( ) ; } return this . admid ; }
tr	0	@ Override public String toString ( ) { return String . format ( "(%d %d)" , getX ( ) , getY ( ) ) ; }
tr	4	public void run ( ) { useful = true ; UiApplication . getUiApplication ( ) . invokeLater ( new Runnable ( ) { public void run ( ) { UiApplication . getUiApplication ( ) . pushScreen ( popup ) ; } } ) ; int iterations = 0 ; while ( useful ) { try { Thread . sleep ( timeout ) ; } catch ( Exception e ) { } if ( ++ iterations > maximum ) iterations = 1 ; gaugeField . setValue ( iterations ) ; } if ( popup . isDisplayed ( ) ) { UiApplication . getUiApplication ( ) . invokeLater ( new Runnable ( ) { public void run ( ) { UiApplication . getUiApplication ( ) . popScreen ( popup ) ; } } ) ; } }
tr	8	private boolean r_verb_suffix ( ) { int among_var ; int v_1 ; int v_2 ; int v_3 ; int v_4 ; v_1 = limit - cursor ; if ( cursor < I_pV ) { return false ; } cursor = I_pV ; v_2 = limit_backward ; limit_backward = cursor ; cursor = limit - v_1 ; ket = cursor ; among_var = find_among_b ( a_8 , 96 ) ; if ( among_var == 0 ) { limit_backward = v_2 ; return false ; } bra = cursor ; limit_backward = v_2 ; switch ( among_var ) { case 0 : return false ; case 1 : v_3 = limit - cursor ; lab0 : do { if ( ! ( eq_s_b ( 1 , "u" ) ) ) { cursor = limit - v_3 ; break lab0 ; } v_4 = limit - cursor ; if ( ! ( eq_s_b ( 1 , "g" ) ) ) { cursor = limit - v_3 ; break lab0 ; } cursor = limit - v_4 ; } while ( false ) ; bra = cursor ; slice_del ( ) ; break ; case 2 : slice_del ( ) ; break ; } return true ; }
tr	6	public static void assertIteratorsEqual ( Iterator < ? > actual , Iterator < ? > expected ) { int count = 0 ; while ( actual . hasNext ( ) ) { count ++ ; if ( ! expected . hasNext ( ) ) { throw new AssertionError ( "Actual has more elements than expected - at least " + count ) ; } Object actObj = actual . next ( ) ; Object expObj = expected . next ( ) ; if ( ! Objects . equals ( actObj , expObj ) ) { throw new AssertionError ( "Expected [" + expObj + "] at position " + count + " but found [" + actObj + "]" ) ; } } if ( expected . hasNext ( ) ) { throw new AssertionError ( "Actual has fewer elements than expected - only " + count ) ; } }
tr	6	public void relatedTexts ( SaploGroup saploGroup , SaploCollection collection , int wait , int limit ) throws SaploClientException { verifyId ( saploGroup ) ; List < SaploText > relatedTextsList = new ArrayList < SaploText > ( ) ; JSONObject params = new JSONObject ( ) ; try { params . put ( "group_id" , saploGroup . getId ( ) ) ; if ( collection != null ) { params . put ( "collection_scope" , collection . getId ( ) ) ; } else { throw new SaploClientException ( MSG_CLIENT_FIELD , CODE_CLIENT_FIELD , "collection_scope" ) ; } if ( wait >= 0 ) params . put ( "wait" , wait ) ; if ( limit > 0 ) params . put ( "limit" , limit ) ; } catch ( JSONException je ) { throw new SaploClientException ( CODE_JSON_EXCEPTION , je ) ; } JSONRPCRequestObject request = new JSONRPCRequestObject ( client . getNextId ( ) , "group.relatedTexts" , params ) ; JSONObject rawResult = ( JSONObject ) client . sendAndReceiveAndParseResponse ( request ) ; try { JSONArray texts = rawResult . getJSONArray ( "related_texts" ) ; for ( int i = 0 ; i < texts . length ( ) ; i ++ ) { JSONObject textJson = texts . getJSONObject ( i ) ; SaploText relText = SaploText . convertFromJSONToText ( textJson ) ; relText . setRelatedToGroup ( saploGroup ) ; relatedTextsList . add ( relText ) ; } } catch ( JSONException je ) { throw new SaploClientException ( CODE_JSON_EXCEPTION , je ) ; } saploGroup . setRelatedTexts ( relatedTextsList ) ; }
tr	2	@ Override public double calculateMedieGeneralaClasa ( Clasa c ) { Catalog cat = c . getCatalog ( ) ; double medieTotala = 0.0 ; int nrElevi = cat . getSituatieClasa ( ) . size ( ) ; for ( Map . Entry < Elev , HashMap < Materie , SituatieMaterieBaza >> entry : cat . getSituatieClasa ( ) . entrySet ( ) ) { double medie = 0.0 ; int size = entry . getValue ( ) . size ( ) ; for ( SituatieMaterieBaza sit : entry . getValue ( ) . values ( ) ) { medie += sit . getMedieAn ( ) ; } medie /= size ; medieTotala += medie ; } medieTotala /= nrElevi ; return medieTotala ; }
tr	0	@ Override public void deleteExam ( Exam exam ) { examDAO . delete ( exam ) ; }
tr	5	public boolean equalsStops ( StopsList o ) { if ( stops . size ( ) != o . stops . size ( ) ) return false ; for ( long key : o . stops . keySet ( ) ) { Stop a = stops . get ( key ) ; Stop b = o . stops . get ( key ) ; if ( a == null || b == null || ! a . equals ( b ) ) return false ; } return true ; }
tr	1	public void updateMapObject ( Mappable templateObj , Object source ) { Mappable mappable = mapObjectMap . get ( templateObj . getId ( ) ) ; List < ConfigurableProperties > configurableProperties = mappable . getConfigurableProperties ( ) ; for ( ConfigurableProperties key : configurableProperties ) { mappable . setConfiguredValue ( key , templateObj . getConfiguredValue ( key ) ) ; } }
tr	6	public String nextTo ( char delimiter ) throws JSONException { StringBuilder sb = new StringBuilder ( ) ; for ( ; ; ) { char c = this . next ( ) ; if ( c == delimiter || c == 0 || c == '' || c == '' ) { if ( c != 0 ) { this . back ( ) ; } return sb . toString ( ) . trim ( ) ; } sb . append ( c ) ; } }
tr	9	static List < String > digestProtein ( String sequence , int minLen , int maxLen ) { List < String > peptides = new ArrayList < String > ( ) ; String peptide ; int i = 0 , idx ; while ( i < sequence . length ( ) ) { idx = i ; while ( ( idx < sequence . length ( ) - 1 ) && ( ( ( sequence . charAt ( idx ) == K || sequence . charAt ( idx ) == R ) && sequence . charAt ( idx + 1 ) == P ) || ( sequence . charAt ( idx ) != K && sequence . charAt ( idx ) != R ) ) ) { idx += 1 ; } peptide = sequence . substring ( i , idx + 1 ) ; if ( ( peptide . length ( ) >= minLen ) && ( peptide . length ( ) <= maxLen ) ) { peptides . add ( peptide ) ; } i = idx + 1 ; } return peptides ; }
tr	1	public static _Fields findByThriftIdOrThrow ( int fieldId ) { _Fields fields = findByThriftId ( fieldId ) ; if ( fields == null ) throw new IllegalArgumentException ( "Field " + fieldId + " doesn't exist!" ) ; return fields ; }
tr	1	public static SoundManager create ( class < ? > clazz ) throws IllegalArgumentException { return create ( clazz , new String ( ) ) ; }
tr	0	public boolean get ( int value ) { assertValue ( value ) ; return ( bitset & 1 << value ) > 0 ; }
tr	1	private Node begin ( Node expr , ReferenceFrame ref ) { Node curr = expr . getCdr ( ) , result = null ; while ( curr != null ) { result = eval ( curr . getCar ( ) , ref ) ; curr = curr . getCdr ( ) ; } return result ; }
tr	4	public static void fileSaveAsSCM ( File target ) { if ( MainMethods . openFile == null ) { updateStatusBar ( "Nothing to save ... please open a file first!" , 2 ) ; return ; } if ( ! MainMethods . openFile . isScmFile ( ) ) { updateStatusBar ( "You must open a SCM File to save as an SCM file" , 2 ) ; return ; } File outputFile = target ; if ( outputFile == null ) outputFile = MainMethods . getFileToSaveIn ( ) ; MapParser . write ( MainMethods . openFile . getChannelList ( ) , MainMethods . openFile . getFile ( ) ) ; int compressedFiles = ZipHandler . compress ( outputFile . getAbsolutePath ( ) , MainMethods . openFile . scmExtractedTo ( ) . getAbsolutePath ( ) ) ; if ( compressedFiles < 0 ) { MainMethods . updateStatusBar ( "Packaging SCM file failed!" , 2 ) ; return ; } updateStatusBar ( "Saved SCM file as \"" + outputFile . getAbsolutePath ( ) + "\"" , 2 ) ; }
tr	8	@ Override public void addItem ( ItemsEvent event , String type ) { Map < Object , Object > valueMap = new HashMap < Object , Object > ( ) ; DAOFactory factory = DAOFactory . getFactory ( DAOFactory . MYSQL ) ; String table = event . getTable ( ) ; String value = event . getName ( ) ; if ( type . equals ( "normal" ) ) { String field = "nazwa" ; String field2 = "id_firmy" ; String field3 = "id_kategoria" ; valueMap . put ( field , value ) ; valueMap . put ( field2 , event . getIdCompany ( ) ) ; valueMap . put ( field3 , event . getIdCategory ( ) ) ; } else if ( type . equals ( "box" ) ) { String field1 = "id_kategoria" ; String field2 = "id_firmy" ; valueMap . put ( field1 , event . getIdCategory ( ) ) ; valueMap . put ( field2 , event . getIdCompany ( ) ) ; } else if ( type . equals ( "box_category" ) ) { String field1 = "id_kategoria" ; valueMap . put ( field1 , event . getIdCategory ( ) ) ; } else if ( type . equals ( "box_company" ) ) { String field1 = "id_firmy" ; valueMap . put ( field1 , event . getIdCompany ( ) ) ; } try { if ( event . getAction ( ) . equals ( "add" ) ) { factory . question ( "insert" , valueMap , table , 0 ) ; } else if ( event . getAction ( ) . equals ( "update" ) ) { factory . question ( "update" , valueMap , table , event . getId ( ) ) ; } } catch ( SQLException e ) { JOptionPane . showMessageDialog ( Controller . this , "B\u0142\u0105d przy operacji na produktach  spr\u00F3buj ponownie" , "Error" , JOptionPane . WARNING_MESSAGE ) ; e . printStackTrace ( ) ; } try { model . loadItem ( view ) ; } catch ( Exception e ) { JOptionPane . showMessageDialog ( Controller . this , "B\u0142\u0105d przy \u0142adowaniu produkt\u00F3w  spr\u00F3buj ponownie" , "Error" , JOptionPane . WARNING_MESSAGE ) ; e . printStackTrace ( ) ; } }
tr	3	public static int [ ] swaps ( int k , int [ ] array ) { int maxSoFar = 0 ; int maxEndingHere = 0 ; int indexStart = 0 ; int indexEnd = 0 ; int maxIndexStart = 0 ; for ( int i = 0 ; i < array . length ; i ++ ) { if ( maxEndingHere < array [ i ] + maxEndingHere ) { maxEndingHere = array [ i ] + maxEndingHere ; if ( maxSoFar < maxEndingHere ) { maxSoFar = maxEndingHere ; indexEnd = i ; maxIndexStart = indexStart ; } } else { maxEndingHere = 0 ; indexStart = i + 1 ; } } int [ ] newArray = new int [ 3 ] ; newArray [ 0 ] = maxIndexStart ; newArray [ 1 ] = indexEnd ; newArray [ 2 ] = maxSoFar ; return newArray ; }
tr	2	public Grille ( int taille , Joueur joueur , boolean afficher_bateaux ) { this . taille_case = 320 / taille ; this . taille = taille ; this . cases = new case [ taille ] [ taille ] ; this . joueur = joueur ; this . afficher_bateaux = afficher_bateaux ; this . setBackground ( new Color ( 0 , 0 , 0 ) ) ; this . setLayout ( new GridLayout ( taille , taille , 0 , 0 ) ) ; for ( int i = 0 ; i < taille ; i ++ ) for ( int j = 0 ; j < taille ; j ++ ) cases [ i ] [ j ] = new case ( i + 1 , j + 1 , taille_case ) ; initialiserCases ( ) ; }
tr	4	public ChemEquation ( Element [ ] elems , boolean full ) { first = new ArrayList < > ( ) ; second = new ArrayList < > ( ) ; this . full = full ; if ( full ) { boolean onReactants = false ; for ( Element elem : elems ) { if ( elem == null ) { onReactants = true ; } if ( onReactants ) { second . add ( elem ) ; } else { first . add ( elem ) ; } } } else { first . addAll ( Arrays . asList ( elems ) ) ; } }
tr	6	public List < Document > sorting ( Map < String , Document > temp , int mode ) { List < Document > sortedList = new LinkedList < Document > ( temp . values ( ) ) ; if ( mode == 0 ) { Collections . sort ( sortedList , new Comparator < Document > ( ) { @ Override public int compare ( Document o1 , Document o2 ) { if ( o1 . getPageRank ( ) - o2 . getPageRank ( ) == 0 ) { return o1 . getTitle ( ) . compareTo ( o2 . getTitle ( ) ) ; } else { return ( o1 . getPageRank ( ) - o2 . getPageRank ( ) < 0 ) ? 1 : - 1 ; } } } ) ; } else if ( mode == 1 ) { Collections . sort ( sortedList , new Comparator < Document > ( ) { @ Override public int compare ( Document o1 , Document o2 ) { if ( o1 . getNumViews ( ) - o2 . getNumViews ( ) == 0 ) { return o1 . getTitle ( ) . compareTo ( o2 . getTitle ( ) ) ; } else { return ( o1 . getNumViews ( ) - o2 . getNumViews ( ) < 0 ) ? 1 : - 1 ; } } } ) ; } return sortedList ; }
tr	6	LocalSocket ( Socket socket , PassthroughConnection ptc ) { this . ptc = ptc ; this . socket = socket ; DataInputStream inLocal = null ; DataOutputStream outLocal = null ; try { inLocal = new DataInputStream ( socket . getInputStream ( ) ) ; } catch ( IOException e ) { ptc . printLogMessage ( "Unable to open data stream to client" ) ; if ( inLocal != null ) { try { inLocal . close ( ) ; socket . close ( ) ; } catch ( IOException e1 ) { ptc . printLogMessage ( "Unable to close data stream to client" ) ; } } in = null ; out = null ; success = false ; return ; } try { outLocal = new DataOutputStream ( socket . getOutputStream ( ) ) ; } catch ( IOException e ) { ptc . printLogMessage ( "Unable to open data stream from client" ) ; if ( outLocal != null ) { try { outLocal . close ( ) ; socket . close ( ) ; } catch ( IOException e1 ) { ptc . printLogMessage ( "Unable to close data stream from client" ) ; } } in = null ; out = null ; success = false ; return ; } in = inLocal ; out = outLocal ; success = true ; }
tr	3	private static void player1DoSwapPieces ( OthelloPiece piecesToSwap [ ] [ ] ) { for ( int i = 0 ; i < TOTALWIDTH ; i ++ ) { for ( int j = 0 ; j < TOTALHEIGHT ; j ++ ) { if ( piecesToSwap [ i ] [ j ] == null ) { } else { player1SwapPieces ( i , j ) ; } } } }
tr	5	private void method45 ( ) { aBoolean1031 = true ; for ( int j = 0 ; j < 7 ; j ++ ) { anIntArray1065 [ j ] = - 1 ; for ( int k = 0 ; k < IDK . length ; k ++ ) { if ( IDK . cache [ k ] . aBoolean662 || IDK . cache [ k ] . anInt657 != j + ( aBoolean1047 ? 0 : 7 ) ) continue ; anIntArray1065 [ j ] = k ; break ; } } }
tr	3	static < K extends Comparable < K > , E > boolean containsElement ( BSTNode < K , E > node , E element ) { if ( node == null ) { return false ; } else { return element . equals ( node . getElement ( ) ) || containsElement ( node . leftChild , element ) || containsElement ( node . rightChild , element ) ; } }
tr	3	@ Override public Component getListCellRendererComponent ( JList < ? extends Type > list , Type type , int index , boolean isSelected , boolean cellHasFocus ) { URL resource = getClass ( ) . getClassLoader ( ) . getResource ( "icon/mark.png" ) ; setIcon ( new ImageIcon ( resource ) ) ; if ( type . getCacheItemCount ( ) == - 1 ) { setText ( type . getName ( ) ) ; } else { setText ( type . getName ( ) + " (" + type . getCacheItemCount ( ) + ) ) ; } if ( isSelected ) { setBackground ( list . getSelectionBackground ( ) ) ; setForeground ( list . getSelectionForeground ( ) ) ; } else { setBackground ( list . getBackground ( ) ) ; setForeground ( list . getForeground ( ) ) ; } setFont ( list . getFont ( ) ) ; setOpaque ( true ) ; return this ; }
tr	8	public boolean hasAdjacentEmptyTile ( JavaCell cell ) { int x = cell . getX ( ) ; int y = cell . getY ( ) ; if ( x + 1 == 13 ) { if ( map [ 13 ] [ y ] . getCellType ( ) . equals ( "blank" ) ) return true ; } if ( x - 1 == 0 ) { if ( map [ 0 ] [ y ] . getCellType ( ) . equals ( "blank" ) ) return true ; } if ( y + 1 == 13 ) { if ( map [ x ] [ 13 ] . getCellType ( ) . equals ( "blank" ) ) return true ; } if ( y - 1 == 0 ) { if ( map [ x ] [ 0 ] . getCellType ( ) . equals ( "blank" ) ) return true ; } return false ; }
tr	1	@ Override public Object [ ] [ ] getAll ( ) { DAOFactory factory = DAOFactory . getDAOFactory ( ) ; TeacherDAO dao = factory . getTeacherDAO ( ) ; List < Teacher > teachers = dao . selectAll ( ) ; Object [ ] [ ] rowData = new Object [ teachers . size ( ) ] [ 4 ] ; for ( int i = 0 ; i < teachers . size ( ) ; i ++ ) { Teacher teacher = teachers . get ( i ) ; rowData [ i ] [ 0 ] = teacher . getCode ( ) ; rowData [ i ] [ 1 ] = teacher . getNames ( ) ; rowData [ i ] [ 2 ] = dateFormatHelper . format ( teacher . getBirthday ( ) ) ; rowData [ i ] [ 3 ] = teacher . getEmail ( ) ; } return rowData ; }
tr	9	public void Show ( boolean enabled , String uname ) { ASCII_Sound beep = new ASCII_Sound ( false ) ; ASCII_Art welcome = new ASCII_Art ( ) ; Options o = new Options ( ) ; MainMenu m = new MainMenu ( ) ; PlayMenu p = new PlayMenu ( ) ; HelpMenu h = new HelpMenu ( ) ; if ( enabled == true ) { for ( OptionsEnum options : OptionsEnum . values ( ) ) { if ( options . getMenuChoice ( ) != 0 ) { System . out . printf ( "%s. %s\n" , options . getMenuChoice ( ) , options . getMessage ( ) ) ; } } } User u = new User ( ) ; switch ( u . getUserInt ( "Select an option.\n (Enter a #)" ) ) { case 1 : setScoreOptions ( true ) ; System . out . println ( "Keep Score: " + score ) ; break ; case 2 : setScoreOptions ( false ) ; System . out . println ( "Keep Score: " + score ) ; break ; case 3 : setSoundOptions ( true ) ; System . out . println ( "Soundtrack: " + sound ) ; break ; case 4 : setSoundOptions ( false ) ; System . out . println ( "Soundtrack: " + sound ) ; break ; case 5 : matchSeconds = u . getUserInt ( "How many seconds?\n [3-10]" ) ; System . out . println ( "Timeout: " + matchSeconds ) ; break ; case 6 : tilePairs = u . getUserInt ( "How many match pairs?\n [4]" ) ; System . out . println ( "Match Pairs: " + tilePairs ) ; break ; case 7 : printOptions ( ) ; break ; case 8 : m . setEnabled ( true ) ; m . Show ( uname ) ; break ; case 99 : System . out . println ( "Invalid selection." ) ; o . Show ( enabled , uname ) ; break ; default : System . out . println ( "Invalid selection." ) ; o . Show ( enabled , uname ) ; break ; } Exit answerExit = new Exit ( ) ; do { Show ( enabled , u . user ) ; } while ( answerExit . getExit ( ) == false ) ; }
tr	4	public JSONObject toJSONObject ( JSONArray names ) throws JSONException { if ( names == null || names . length ( ) == 0 || this . length ( ) == 0 ) { return null ; } JSONObject jo = new JSONObject ( ) ; for ( int i = 0 ; i < names . length ( ) ; i += 1 ) { jo . put ( names . getString ( i ) , this . opt ( i ) ) ; } return jo ; }
tr	0	MARKET ( String ... urlStrings ) { this . urlStrings = urlStrings ; }
tr	4	private static void init_perm ( long [ ] [ ] perm , byte [ ] p , int chars_in , int chars_out ) { for ( int k = 0 ; k < chars_out * 8 ; k ++ ) { int l = p [ k ] - 1 ; if ( l < 0 ) continue ; int i = l >> 2 ; l = 1 << ( l & 03 ) ; for ( int j = 0 ; j < 16 ; j ++ ) { int s = ( ( k & 07 ) + ( ( 7 - ( k >> 3 ) ) << 3 ) ) ; if ( ( j & l ) != 00 ) perm [ i ] [ j ] |= ( 1 << s ) ; } } }
tr	5	@ Override public void tick ( ) { lastPosition = new Vector2f ( position ) ; position = new Vector2f ( org . lwjgl . input . Mouse . getX ( ) , org . lwjgl . input . Mouse . getY ( ) ) ; statesMouse = new ArrayList < StateMouse > ( ) ; org . lwjgl . input . Mouse . poll ( ) ; while ( org . lwjgl . input . Mouse . next ( ) ) { StateMouse stateMouse = null ; if ( org . lwjgl . input . Mouse . getDWheel ( ) == 0 ) { if ( org . lwjgl . input . Mouse . getEventButtonState ( ) ) { stateMouse = new StateMouse ( org . lwjgl . input . Mouse . getEventButton ( ) , StateMouse . DOWN_PRESSED , new Vector2f ( org . lwjgl . input . Mouse . getEventX ( ) , org . lwjgl . input . Mouse . getEventY ( ) ) ) ; } else { stateMouse = new StateMouse ( org . lwjgl . input . Mouse . getEventButton ( ) , StateMouse . UP_RELEASED , new Vector2f ( org . lwjgl . input . Mouse . getEventX ( ) , org . lwjgl . input . Mouse . getEventY ( ) ) ) ; } } else { stateMouse = new StateMouse ( org . lwjgl . input . Mouse . getDWheel ( ) , new Vector2f ( org . lwjgl . input . Mouse . getX ( ) , org . lwjgl . input . Mouse . getY ( ) ) ) ; } statesMouse . add ( stateMouse ) ; } StateMouse stateMouse ; for ( int i = 0 ; i < 5 ; i ++ ) { stateMouse = null ; if ( org . lwjgl . input . Mouse . isButtonDown ( i ) ) { stateMouse = new StateMouse ( i , StateMouse . DOWN , new Vector2f ( org . lwjgl . input . Mouse . getX ( ) , org . lwjgl . input . Mouse . getY ( ) ) ) ; } else { stateMouse = new StateMouse ( i , StateMouse . UP , new Vector2f ( org . lwjgl . input . Mouse . getX ( ) , org . lwjgl . input . Mouse . getY ( ) ) ) ; } statesMouse . add ( stateMouse ) ; } }
tr	4	public void act ( List < Actor > newGorrilas ) { incrementAge ( ) ; incrementHunger ( ) ; if ( isActive ( ) ) { giveBirth ( newGorrilas ) ; Location location = getLocation ( ) ; Location newLocation = findFood ( location ) ; if ( newLocation == null ) { newLocation = getField ( ) . freeAdjacentLocation ( location ) ; } if ( newLocation != null ) { setLocation ( newLocation ) ; } else if ( walkOverGrass ( ) ) { } else { setDead ( ) ; } } }
tr	4	private void jsonObjectTableMouseClicked ( java . awt . event . MouseEvent evt ) { int targetRow = jsonObjectTable . getSelectedRow ( ) ; if ( evt . getClickCount ( ) == 2 && evt . getButton ( ) == MouseEvent . BUTTON1 ) { if ( targetRow >= 0 ) { int selectedRow = jsonObjectTable . convertRowIndexToModel ( targetRow ) ; String key = ( String ) jsonObjectTable . getModel ( ) . getValueAt ( selectedRow , 0 ) ; Object object = workingJSONObject . keyValues . get ( key ) ; JSONValueEditDialog . JSONValueDialogResponse returnValue = ( new JSONValueEditDialog ( JSONToolWindow . this , key , object ) ) . getReturnValue ( ) ; if ( returnValue . dialogResponse == JSONValueEditDialog . ReturnValue . SAVE ) { String newKey = returnValue . key ; Object newValue = returnValue . value ; workingJSONObject . keyValues . remove ( key ) ; putKeyValueAndRebuild ( newKey , newValue ) ; } } } }
tr	6	public String nextTo ( char delimiter ) throws JSONException { StringBuffer sb = new StringBuffer ( ) ; for ( ; ; ) { char c = this . next ( ) ; if ( c == delimiter || c == 0 || c == '' || c == '' ) { if ( c != 0 ) { this . back ( ) ; } return sb . toString ( ) . trim ( ) ; } sb . append ( c ) ; } }
tr	3	@ Override public void paintComponent ( Graphics g ) { super . paintComponent ( g ) ; FontMetrics fontMetrics = component . getFontMetrics ( component . getFont ( ) ) ; Insets insets = getInsets ( ) ; int availableWidth = getSize ( ) . width - insets . left - insets . right ; Rectangle clip = g . getClipBounds ( ) ; int rowStartOffset = component . viewToModel ( new Point ( 0 , clip . y ) ) ; int endOffset = component . viewToModel ( new Point ( 0 , clip . y + clip . height ) ) ; while ( rowStartOffset <= endOffset ) { try { if ( isCurrentLine ( rowStartOffset ) ) g . setColor ( getCurrentLineForeground ( ) ) ; else g . setColor ( getForeground ( ) ) ; String lineNumber = getTextLineNumber ( rowStartOffset ) ; int stringWidth = fontMetrics . stringWidth ( lineNumber ) ; int x = getOffsetX ( availableWidth , stringWidth ) + insets . left ; int y = getOffsetY ( rowStartOffset , fontMetrics ) ; g . drawString ( lineNumber , x , y ) ; rowStartOffset = Utilities . getRowEnd ( component , rowStartOffset ) + 1 ; } catch ( Exception e ) { } } }
tr	5	@ SuppressWarnings ( { "unchecked" } ) public static < T > boolean equalsLists ( List < T > left , List < T > right , class < T > valueType ) { if ( left . size ( ) != right . size ( ) ) { return false ; } boolean equals = true ; if ( valueType . isArray ( ) && valueType . getComponentType ( ) == byte . TYPE ) { for ( int i = 0 ; i < left . size ( ) ; i ++ ) { if ( Arrays . equals ( ( byte [ ] ) right . get ( i ) , ( byte [ ] ) left . get ( i ) ) == false ) { equals = false ; break ; } } } else { equals = left . equals ( right ) ; } return equals ; }
tr	8	public static void main ( String [ ] args ) { String filename = "SimpleDynamicScenario.txt" ; String outputPath = "./" ; if ( args . length >= 2 ) { filename = args [ 0 ] ; outputPath = args [ 1 ] ; } if ( args . length > 2 ) System . err . println ( "WARNING: Only two arguments required. Ignoring arguments after the first two." ) ; if ( args . length <= 1 ) { System . err . println ( "WARNING: Two arguments required <setup_file_name> <ouput_dir_path>. Running simulation with default values \"properties.txt\" and \"./\"." ) ; } sfp = new SetupFileParser ( ) ; sfp . parseFileForProperties ( filename ) ; StandAloneSimulation sas = new StandAloneSimulation ( outputPath , "RunFrom" + ( new File ( filename ) ) . getName ( ) . replace ( "." , "_" ) + System . currentTimeMillis ( ) , sfp . generalProps . getProperty ( "seed" ) != null ? Integer . parseInt ( sfp . generalProps . getProperty ( "seed" ) ) : 0 , sfp . generalProps . getProperty ( "useDerby" ) != null ? boolean . parseBoolean ( sfp . generalProps . getProperty ( "useDerby" ) ) : true ) ; try { sas . setup ( false ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } sas . runSimulation ( ) ; boolean printKPIs = sfp . generalProps . getProperty ( "printKPIs" ) != null ? boolean . parseBoolean ( sfp . generalProps . getProperty ( "printKPIs" ) ) : false ; if ( printKPIs ) sas . printKPIs ( ) ; }
tr	6	@ Override public void visitList ( SchemaType schemaType , Object sourceObject , Object newValue ) { GetVisitor . VisitorInfo info = new GetVisitor . VisitorInfo ( schemaType , sourceObject ) ; infoList . add ( info ) ; int idx = infoList . size ( ) - 1 ; int index ; String path = "" ; for ( int i = 0 ; i <= idx ; i ++ ) { path += "/" + paths [ i ] ; } try { index = Integer . parseInt ( paths [ idx ] ) ; } catch ( NumberFormatException e ) { info . setException ( new NumberFormatException ( "Path '" + path + "' for ArrayType index requies integer type. " + e . getMessage ( ) ) ) ; return ; } try { if ( sourceObject . getClass ( ) . isArray ( ) ) { Array . set ( sourceObject , index , newValue ) ; info . setResult ( Array . get ( sourceObject , index ) ) ; } else { List l = ( List ) sourceObject ; if ( index >= l . size ( ) ) { l . add ( newValue ) ; index = l . size ( ) - 1 ; } else { l . set ( index , newValue ) ; } info . setResult ( ( ( List ) sourceObject ) . get ( index ) ) ; } } catch ( NullPointerException e ) { info . setException ( new NullPointerException ( "Path '" + path + "'. index==" + index + ". " + e . getMessage ( ) ) ) ; } catch ( ArrayIndexOutOfBoundsException e ) { info . setException ( new ArrayIndexOutOfBoundsException ( "Path '" + path + "'. index==" + index + ". " + e . getMessage ( ) ) ) ; } }
tr	1	public void tick ( ) { pollInput ( ) ; for ( int i = 0 ; i < keys . size ( ) ; i ++ ) { keys . get ( i ) . tick ( ) ; } }
tr	9	@ Override public Object instantiate ( class < ? > clazz , CreationMode mode ) { Objects . requireNonNull ( clazz ) ; switch ( clazz . toString ( ) ) { case "byte" : return ( byte ) ( RND . nextInt ( byte . MAX_VALUE ) & FF ) ; case "short" : return ( short ) ( RND . nextInt ( short . MAX_VALUE ) & FFFF ) ; case "int" : return RND . nextInt ( MAX_INT ) ; case "long" : return RND . nextLong ( ) ; case "float" : return RND . nextFloat ( ) ; case "double" : return RND . nextDouble ( ) ; case "char" : char ch = 0 ; do { ch = ( char ) ( A + RND . nextInt ( z - A + 1 ) ) ; } while ( ch > Z && ch < a ) ; return ch ; case "boolean" : return RND . nextBoolean ( ) ; default : System . err . println ( "Unknown primitive type. Please check" ) ; return null ; } }
tr	1	private void checkLevel ( ) { if ( Console . getDebugMode ( ) ) setLevel ( Level . ALL ) ; else setLevel ( Level . INFO ) ; }
tr	9	public void updateRender ( ) { GridSquare [ ] [ ] gridData = controller . getGrid ( ) ; for ( int col = 0 ; col < gridData . length ; col ++ ) { for ( int row = 0 ; row < gridData [ col ] . length ; row ++ ) { String text = "" ; if ( gridData [ col ] [ row ] . player == EPlayer . None ) text += "-" ; else if ( gridData [ col ] [ row ] . player == EPlayer . P1 ) text += "o" ; else text += "x" ; if ( gridData [ col ] [ row ] . turnNumber >= 0 ) text += gridData [ col ] [ row ] . turnNumber . toString ( ) ; if ( gridData [ col ] [ row ] . undefinedTurns . size ( ) > 0 ) { text += "(" ; for ( Integer it : gridData [ col ] [ row ] . undefinedTurns . keySet ( ) ) { if ( gridData [ col ] [ row ] . undefinedTurns . get ( it ) == EPlayer . None ) text += "-" ; else if ( gridData [ col ] [ row ] . undefinedTurns . get ( it ) == EPlayer . P1 ) text += "o" ; else text += "x" ; if ( it >= 0 ) text += it . toString ( ) ; } text += ")" ; } gridBtn [ col ] [ row ] . setText ( text ) ; } } }
tr	2	public void addToRender ( int entity_id , RenderNode node ) { if ( nodes . containsKey ( entity_id ) || temps . containsKey ( entity_id ) ) { return ; } temps . put ( entity_id , node ) ; }
tr	4	public void construct2DMatrixFromStringSet ( int currentRow , int startIndex , int numRows , int numColumns , List < String > rawData ) { String sCurrentLine = "" ; String _convertedPattern = "" ; int trackNumberOfRows = 0 ; int sIndex = 0 ; _pattern = new String [ numRows ] ; while ( true ) { sCurrentLine = rawData . get ( currentRow ) . substring ( startIndex , startIndex + numColumns ) ; sIndex = 0 ; if ( trackNumberOfRows == numRows ) break ; _convertedPattern = "" ; while ( sIndex < sCurrentLine . length ( ) ) { _convertedPattern += ( sCurrentLine . charAt ( sIndex ) == + ? 1 : 0 ) ; sIndex ++ ; } _pattern [ trackNumberOfRows ] = String . valueOf ( binaryToDecimal ( _convertedPattern ) ) ; trackNumberOfRows ++ ; } }
tr	0	private void createAroundVertex ( Point p ) { addVertex ( p , getRandomName ( ) ) ; Point p1 = new Point ( p . x - 1 , p . y - 1 ) ; Point p2 = new Point ( p . x , p . y - 1 ) ; Point p3 = new Point ( p . x + 1 , p . y - 1 ) ; Point p4 = new Point ( p . x + 1 , p . y ) ; Point p5 = new Point ( p . x - 1 , p . y ) ; Point p6 = new Point ( p . x , p . y + 1 ) ; Point p7 = new Point ( p . x + 1 , p . y + 1 ) ; Point p8 = new Point ( p . x - 1 , p . y + 1 ) ; addVertex ( p1 , getRandomName ( ) ) ; addVertex ( p2 , getRandomName ( ) ) ; addVertex ( p3 , getRandomName ( ) ) ; addVertex ( p4 , getRandomName ( ) ) ; addVertex ( p5 , getRandomName ( ) ) ; addVertex ( p6 , getRandomName ( ) ) ; addVertex ( p7 , getRandomName ( ) ) ; addVertex ( p8 , getRandomName ( ) ) ; addEdge ( p , p1 , 1 ) ; addEdge ( p , p2 , 1 ) ; addEdge ( p , p3 , 1 ) ; addEdge ( p , p4 , 1 ) ; addEdge ( p , p5 , 1 ) ; addEdge ( p , p6 , 1 ) ; addEdge ( p , p7 , 1 ) ; addEdge ( p , p8 , 1 ) ; }
tr	4	@ Override public short [ ] next ( ) { short [ ] retVal = new short [ channelCount ] ; Iterator < Sound > it = getAliveSounds ( frame ) ; while ( it . hasNext ( ) ) { short [ ] r = ( ( SimpleSound ) it . next ( ) ) . play ( 1 ) ; for ( int i = 0 ; i < channelCount ; i ++ ) { if ( ( int ) retVal [ i ] + ( int ) r [ i ] > short . MAX_VALUE ) retVal [ i ] = short . MAX_VALUE ; else if ( ( int ) retVal [ i ] + ( int ) r [ i ] < - short . MAX_VALUE ) retVal [ i ] = - short . MAX_VALUE ; else retVal [ i ] += r [ i ] ; } } frame ++ ; return retVal ; }
tr	6	public void testAttribUniq ( ) throws IOException , XmlPullParserException { final String attribsOk = "<m:test xmlns:m='Some-Namespace-URI' xmlns:n='Some-Namespace-URI'" + " a='a' b='b' m:a='c' n:b='d' n:x='e'" + "/>\n" + "" ; final String duplicateAttribs = "<m:test xmlns:m='Some-Namespace-URI' xmlns:n='Some-Namespace-URI'" + " a='a' b='b' m:a='a' n:b='b' a='x'" + "/>\n" + "" ; final String duplicateNsAttribs = "<m:test xmlns:m='Some-Namespace-URI' xmlns:n='Some-Namespace-URI'" + " a='a' b='b' m:a='a' n:b='b' n:a='a'" + "/>\n" + "" ; final String duplicateXmlns = "<m:test xmlns:m='Some-Namespace-URI' xmlns:m='Some-Namespace-URI'" + "" + "/>\n" + "" ; final String duplicateAttribXmlnsDefault = "<m:test xmlns='Some-Namespace-URI' xmlns:m='Some-Namespace-URI'" + " a='a' b='b' m:b='b' m:a='x'" + "/>\n" + "" ; XmlPullParser pp = factory . newPullParser ( ) ; parseOneElement ( pp , attribsOk , false ) ; assertEquals ( "a" , pp . getAttributeValue ( null , "a" ) ) ; assertEquals ( "b" , pp . getAttributeValue ( null , "b" ) ) ; assertEquals ( "c" , pp . getAttributeValue ( null , "m:a" ) ) ; assertEquals ( "d" , pp . getAttributeValue ( null , "n:b" ) ) ; assertEquals ( "e" , pp . getAttributeValue ( null , "n:x" ) ) ; parseOneElement ( pp , attribsOk , true ) ; assertEquals ( "a" , pp . getAttributeValue ( "" , "a" ) ) ; assertEquals ( "b" , pp . getAttributeValue ( "" , "b" ) ) ; assertEquals ( null , pp . getAttributeValue ( "" , "m:a" ) ) ; assertEquals ( null , pp . getAttributeValue ( "" , "n:b" ) ) ; assertEquals ( null , pp . getAttributeValue ( "" , "n:x" ) ) ; assertEquals ( "c" , pp . getAttributeValue ( "Some-Namespace-URI" , "a" ) ) ; assertEquals ( "d" , pp . getAttributeValue ( "Some-Namespace-URI" , "b" ) ) ; assertEquals ( "e" , pp . getAttributeValue ( "Some-Namespace-URI" , "x" ) ) ; parseOneElement ( pp , duplicateNsAttribs , false ) ; parseOneElement ( pp , duplicateAttribXmlnsDefault , false ) ; parseOneElement ( pp , duplicateAttribXmlnsDefault , true ) ; Exception ex ; ex = null ; try { parseOneElement ( pp , duplicateAttribs , false ) ; } catch ( XmlPullParserException rex ) { ex = rex ; } assertNotNull ( ex ) ; ex = null ; try { parseOneElement ( pp , duplicateAttribs , true ) ; } catch ( XmlPullParserException rex ) { ex = rex ; } assertNotNull ( ex ) ; ex = null ; try { parseOneElement ( pp , duplicateXmlns , false ) ; } catch ( XmlPullParserException rex ) { ex = rex ; } assertNotNull ( ex ) ; ex = null ; try { parseOneElement ( pp , duplicateXmlns , true ) ; } catch ( XmlPullParserException rex ) { ex = rex ; } assertNotNull ( ex ) ; ex = null ; try { parseOneElement ( pp , duplicateNsAttribs , true ) ; } catch ( XmlPullParserException rex ) { ex = rex ; } assertNotNull ( ex ) ; final String declaringDefaultEmptyNs = "<m:test xmlns='' xmlns:m='uri'/>" ; parseOneElement ( pp , declaringDefaultEmptyNs , false ) ; parseOneElement ( pp , declaringDefaultEmptyNs , true ) ; final String declaringPrefixedEmptyNs = "<m:test xmlns:m='' />" ; parseOneElement ( pp , declaringPrefixedEmptyNs , false ) ; ex = null ; try { parseOneElement ( pp , declaringPrefixedEmptyNs , true ) ; } catch ( XmlPullParserException rex ) { ex = rex ; } assertNotNull ( ex ) ; }
tr	1	public static void main ( String [ ] args ) { if ( args . length != 1 ) { System . out . println ( "Argument Error." ) ; System . out . println ( "Using method: java -Xmx2048m -jar prince.jar ./input/config.txt" ) ; System . exit ( - 1 ) ; } InputArgument input = new InputArgument ( args [ 0 ] ) ; PrinceCrossValidation validation = new PrinceCrossValidation ( input . getPpiFilepath ( ) , input . getDiseaseSimilarityFilepath ( ) , input . getGeneDiseaseAssociationFilepath ( ) , input . getDiseaseFilepath ( ) , input . getOutputDir ( ) ) ; System . out . println ( "Prince Validation starting..." ) ; validation . batch_run ( ) ; System . out . println ( "Prince Validation finished..." ) ; }
tr	8	public SolutionType [ ] decodeSolution ( String str ) throws DecodeException { SolutionType [ ] res ; int i = 0 ; int beginning = i ; while ( str . charAt ( i ) != > ) { i ++ ; } String type = str . substring ( beginning , i ) ; i ++ ; beginning = i ; if ( str . charAt ( i ) == < ) { i ++ ; while ( i < str . length ( ) ) { i ++ ; } String [ ] tab = str . substring ( beginning + 1 , i ) . split ( ":" ) ; res = ( SolutionType [ ] ) new Object [ tab . length ] ; for ( int x = 0 ; x < tab . length ; x ++ ) { switch ( type ) { case "int" : res [ x ] = ( SolutionType ) Integer . valueOf ( tab [ x ] ) ; break ; case "dbl" : res [ x ] = ( SolutionType ) double . valueOf ( tab [ x ] ) ; break ; case "str" : res [ x ] = ( SolutionType ) tab [ x ] ; break ; case "chr" : res [ x ] = ( SolutionType ) ( ( Character ) tab [ x ] . charAt ( 0 ) ) ; break ; default : throw new DecodeException ( "non recognized type" ) ; } } } else { res = null ; throw new DecodeException ( ) ; } return res ; }
tr	8	private static Map < class < ? extends Entity > , Integer > getEntitiesConf ( List < AnimalQuantite > animalsList2 ) { Map < class < ? extends Entity > , Integer > entitiesConf = new HashMap < > ( ) ; for ( AnimalQuantite animalQuantite : animalsList2 ) { class < ? extends Entity > entityClass = null ; switch ( animalQuantite . getName ( ) ) { case CTHULI : entityClass = Cthuli . class ; break ; case SPIDER : entityClass = Spider . class ; break ; case ANT : entityClass = Ant . class ; break ; case HUMAN : entityClass = Human . class ; break ; } entitiesConf . put ( entityClass , animalQuantite . getNum ( ) ) ; } return entitiesConf ; }
tr	7	public List < class < ? >> getHandlerList ( ) { List < class < ? >> handlerList = new ArrayList < class < ? >> ( ) ; for ( int i = 1 ; ; i ++ ) { String className = getProperty ( CONFIG_PROPERTY_APP_HANDLER_LIST + "." + i , "" ) . trim ( ) ; if ( className == null || className . isEmpty ( ) ) { break ; } try { handlerList . add ( class . forName ( className ) ) ; } catch ( ClassNotFoundException e ) { LOGGER . log ( Level . WARNING , "Handler class " + className + " not found in classpath" , e ) ; } } this . handlerCount = handlerList . size ( ) ; return handlerList ; }
tr	7	@ Override protected String [ ] validateRecord ( int rowNumber , String recordLine ) throws InputFileReaderException { final String delimiter = ";" ; String [ ] record = recordLine . split ( delimiter ) ; if ( record . length != 5 && record . length != 6 && record . length != 7 ) { throw new InputFileReaderException ( "Ung\u00FCltige Spaltenanzahl f\u00FCr Datensatz. Erwartet: 5  6 oder 7  Ist: " + record . length , null , recordLine , rowNumber ) ; } InputValidator . validateInteger ( "KursID" , record [ 0 ] , recordLine , rowNumber ) ; InputValidator . validateEmpty ( "Kursname" , record [ 1 ] , recordLine , rowNumber ) ; InputValidator . validateStardEndsWithBraces ( "Kursname" , record [ 1 ] , recordLine , rowNumber ) ; InputValidator . validateEmpty ( "Kurstyp" , record [ 2 ] , recordLine , rowNumber ) ; InputValidator . validateStardEndsWithBraces ( "Kurstyp" , record [ 2 ] , recordLine , rowNumber ) ; InputValidator . validateEmpty ( "Dozent" , record [ 3 ] , recordLine , rowNumber ) ; InputValidator . validateStardEndsWithBraces ( "Dozent" , record [ 3 ] , recordLine , rowNumber ) ; InputValidator . validateEmpty ( "Teilnehmerzahl" , record [ 4 ] , recordLine , rowNumber ) ; InputValidator . validateInteger ( "Teilnehmerzahl" , record [ 4 ] , recordLine , rowNumber ) ; if ( record . length == 6 ) { if ( record [ 5 ] != null && record [ 5 ] . length ( ) > 2 ) { InputValidator . validateEquipment ( "Austattung" , record [ 5 ] , recordLine , rowNumber ) ; } } if ( record . length == 7 ) { InputValidator . validateEmpty ( "Frequenz" , record [ 6 ] , recordLine , rowNumber ) ; InputValidator . validateStardEndsWithBraces ( "Frequenz" , record [ 6 ] , recordLine , rowNumber ) ; } return record ; }
tr	4	private SlimAlbum findAlbum ( CoverDetails cover ) { Collection < SlimAlbum > albums = db . getAlbums ( ) ; for ( SlimAlbum album : albums ) { if ( cover . getAlbum ( ) . equals ( album . getTitle ( ) ) ) { String artist = SlimCoverSource . getArtistForAlbum ( db , album ) ; if ( cover . isVariousArtists ( ) || cover . getArtist ( ) . equals ( artist ) ) { return album ; } } } return null ; }
tr	2	public boolean intersects ( AABB aabb ) { final Vector3f h1 = getHalfsize ( ) ; final Vector3f h2 = aabb . getHalfsize ( ) ; final Vector3f p1 = getPosition ( ) ; final Vector3f p2 = aabb . getPosition ( ) ; return Math . abs ( p2 . x - p1 . x ) < h2 . x + h1 . x && Math . abs ( p2 . y - p1 . y ) < h2 . y + h1 . y && Math . abs ( p2 . z - p1 . z ) < h2 . z + h1 . z ; }
tr	5	@ SuppressWarnings ( "rawtypes" ) public boolean survivalInstinct ( ) { int foxCount = 0 ; int rabbitCount = 0 ; int wolfCount = 0 ; HashMap < class , Counter > classStats = MainProgram . getSimulator ( ) . getSimulatorView ( ) . getStats ( ) . getPopulation ( ) ; for ( class c : classStats . keySet ( ) ) { Counter info = classStats . get ( c ) ; if ( info . getName ( ) . equals ( "bin.model.Wolf" ) ) { wolfCount = info . getCount ( ) ; } if ( info . getName ( ) . equals ( "bin.model.Fox" ) ) { foxCount = info . getCount ( ) ; } if ( info . getName ( ) . equals ( "bin.model.Rabbit" ) ) { rabbitCount = info . getCount ( ) ; } } if ( 1.5 * ( wolfCount + ( wolfCount * getBreedingProbability ( ) * getMaxLitterSize ( ) ) ) >= 0.5 * rabbitCount + foxCount ) { return false ; } return true ; }
tr	1	public void save ( ) { if ( this . id > 0 ) { update ( ) ; } else { insert ( ) ; } }
tr	4	public static void isAssignable ( class < ? > superType , class < ? > subType , String message ) { notNull ( superType , "Type to check against must not be null" ) ; if ( subType == null || ! superType . isAssignableFrom ( subType ) ) { throw new IllegalArgumentException ( message + subType + " is not assignable to " + superType ) ; } }
tr	0	Partido ( Manager [ ] managers ) { this . managers = managers ; }
tr	6	public static void LoadReviewsFromSQL ( ) { DBUtil db1 = new DBUtil ( ) ; Logger . getInstance ( ) . getElapseTime ( true ) ; String sql = "select * from sentences" ; ResultSet rs1 = db1 . executeQuerySQL ( sql ) ; try { while ( rs1 . next ( ) ) { String filename = TextUtil . decode ( rs1 . getString ( "filename" ) ) ; int curSentIndex = rs1 . getInt ( "sent_index" ) ; if ( ! dataHash . containsKey ( filename ) ) { RestaurantEntry tmp = new RestaurantEntry ( ) ; tmp . StartSentIndex = curSentIndex ; dataHash . put ( filename , tmp ) ; } else { dataHash . get ( filename ) . EndSentIndex = curSentIndex ; } int revIndex = rs1 . getInt ( "revindex" ) ; double rating = rs1 . getDouble ( "revrating" ) ; if ( dataHash . get ( filename ) . ReviewMap . get ( revIndex ) == null ) { ReviewEntry tmp = new ReviewEntry ( ) ; tmp . setStartSentIndex ( curSentIndex ) ; tmp . setRating ( rating ) ; dataHash . get ( filename ) . ReviewMap . put ( revIndex , tmp ) ; } else { dataHash . get ( filename ) . ReviewMap . get ( revIndex ) . setEndSentIndex ( curSentIndex ) ; } } } catch ( SQLException e ) { e . printStackTrace ( ) ; } Logger . getInstance ( ) . getElapseTime ( true ) ; sql = "select * from extractions" ; rs1 = db1 . executeQuerySQL ( sql ) ; try { while ( rs1 . next ( ) ) { int sentIndex = rs1 . getInt ( "sentindex" ) ; String attr = rs1 . getString ( "attr" ) ; String value = rs1 . getString ( "value" ) ; Extraction tmp = new Extraction ( value , attr , 0 ) ; tmp . setSentIndex ( sentIndex ) ; insertIntoHash ( tmp , sentIndex ) ; } } catch ( SQLException e ) { e . printStackTrace ( ) ; } Logger . getInstance ( ) . getElapseTime ( true ) ; db1 . rundown ( ) ; }
tr	6	public static boolean isValidShuffleDynamicProgramming ( String str1 , String str2 , String str3 ) { if ( str1 == null || str2 == null || str3 == null ) { return false ; } if ( str1 . length ( ) + str2 . length ( ) != str3 . length ( ) ) { return false ; } if ( str1 . isEmpty ( ) ) { return str2 . equals ( str3 ) ; } if ( str2 . isEmpty ( ) ) { return str1 . equals ( str3 ) ; } return isValidShuffleRecursiveDynamicProgramming ( str1 , str2 , str3 , 0 , 0 , 0 , new HashSet < > ( ) ) ; }
tr	2	@ Override public void close ( final String guiName ) { if ( ! guiThreads . get ( guiName ) . isAlive ( ) ) { return ; } running = false ; try { guiThreads . get ( guiName ) . join ( ) ; } catch ( Exception e ) { GameLog . warn ( e ) ; } }
tr	2	public coreImageFolderChooser ( ) { chooser = new DirectoryChooser ( ) ; String userDirectoryString = System . getProperty ( "user.home" ) ; File userDirectory = new File ( userDirectoryString ) ; if ( ! userDirectory . canRead ( ) ) { userDirectory = new File ( "c:/" ) ; } chooser . setInitialDirectory ( userDirectory ) ; File chosenFile = chooser . showDialog ( nicon . NiconDesktop . main . stageDesktop ) ; if ( chosenFile != null ) { path = chosenFile . getPath ( ) ; } else { path = null ; } }
tr	2	@ Override public String process ( HttpServletRequest request ) throws MissingRequiredParameter { String nombre = request . getParameter ( "nombre" ) ; try { connection = dataSource . getConnection ( ) ; statement = connection . createStatement ( ) ; ResultSet resultSet = null ; String query = "SELECT * FROM farmacias WHERE nombre='" + nombre + "'" ; resultSet = statement . executeQuery ( query ) ; resultSet . next ( ) ; int idfarmacia = resultSet . getInt ( "id_farmacia" ) ; if ( idfarmacia != 0 ) { statement . execute ( "delete from farmacias where id_farmacia ='" + idfarmacia + "';" ) ; } } catch ( SQLException e ) { return "{\"status\":\"KO\"  \"result\": \"Error en el acceso a la base de datos.\"}" ; } String result = "{\"status\":\"OK\"  \"result\": \"Farmacia eliminada correctamente.\"}" ; return result ; }
tr	0	public double getPriceLevel3 ( ) { return priceLevel3 ; }
