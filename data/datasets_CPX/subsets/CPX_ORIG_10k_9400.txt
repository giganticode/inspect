te	4	public void replaceWord ( String newWord ) { AttributeSet attr = null ; if ( currentWordPos != - 1 ) { try { if ( document instanceof StyledDocument ) attr = ( ( StyledDocument ) document ) . getCharacterElement ( currentWordPos ) . getAttributes ( ) ; document . remove ( currentWordPos , currentWordEnd - currentWordPos ) ; document . insertString ( currentWordPos , newWord , null ) ; document . getText ( 0 , document . getLength ( ) , text ) ; } catch ( BadLocationException ex ) { throw new RuntimeException ( ex . getMessage ( ) ) ; } first = true ; currentWordPos = getNextWordStart ( text , currentWordPos + newWord . length ( ) ) ; if ( currentWordPos != - 1 ) { currentWordEnd = getNextWordEnd ( text , currentWordPos ) ; nextWordPos = getNextWordStart ( text , currentWordEnd ) ; sentenceIterator . setText ( text ) ; sentenceIterator . following ( currentWordPos ) ; } else moreTokens = false ; } }
te	9	private static Object equivIntersect ( Object elt1 , Object elt2 ) { if ( elt1 == NO_ELEMENT || elt2 == NO_ELEMENT ) return NO_ELEMENT ; else if ( elt1 instanceof EquivalentSet ) { ArrayList < Object > al1 = ( ( EquivalentSet ) elt1 ) . contents ; if ( elt2 instanceof EquivalentSet ) { ArrayList < Object > al2 = ( ( EquivalentSet ) elt2 ) . contents ; ArrayList < Object > al = new ArrayList < Object > ( ) ; int size1 = al1 . size ( ) ; for ( int i = 0 ; i < size1 ; ++ i ) { Object e1 = al1 . get ( i ) ; if ( al2 . contains ( e1 ) ) al . add ( e1 ) ; } if ( al . size ( ) == 0 ) return NO_ELEMENT ; else if ( al . size ( ) == 1 ) return al . get ( 0 ) ; else { al . trimToSize ( ) ; return new EquivalentSet ( al ) ; } } else { if ( al1 . contains ( elt2 ) ) return elt2 ; else return NO_ELEMENT ; } } else if ( elt2 instanceof EquivalentSet ) { ArrayList < Object > al2 = ( ( EquivalentSet ) elt2 ) . contents ; if ( al2 . contains ( elt1 ) ) return elt1 ; else return NO_ELEMENT ; } else if ( eql ( elt1 , elt2 ) ) return elt1 ; else return NO_ELEMENT ; }
te	8	public List getSuggestions ( String word , int threshold ) { if ( this . threshold != threshold && cache != null ) { this . threshold = threshold ; cache . clear ( ) ; } ArrayList suggestions = null ; if ( cache != null ) suggestions = ( ArrayList ) cache . get ( word ) ; if ( suggestions == null ) { suggestions = new ArrayList ( 50 ) ; for ( Enumeration e = dictionaries . elements ( ) ; e . hasMoreElements ( ) ; ) { SpellDictionary dictionary = ( SpellDictionary ) e . nextElement ( ) ; if ( dictionary != userdictionary ) VectorUtility . addAll ( suggestions , dictionary . getSuggestions ( word , threshold ) , false ) ; } if ( cache != null && cache . size ( ) < cacheSize ) cache . put ( word , suggestions ) ; } VectorUtility . addAll ( suggestions , userdictionary . getSuggestions ( word , threshold ) , false ) ; suggestions . trimToSize ( ) ; return suggestions ; }
te	9	public static void readUTF8Chars ( StringBuffer dest , byte [ ] source , int offset , int length ) { for ( int pos = offset ; pos < length ; ) { int ch = ( int ) source [ pos ++ ] & ff ; switch ( ch >> 4 ) { case 0 : case 1 : case 2 : case 3 : case 4 : case 5 : case 6 : case 7 : dest . append ( ( char ) ch ) ; break ; case 12 : case 13 : { int ch1 = source [ pos ++ ] ; dest . append ( ( char ) ( ( ch & 1f ) << 6 | ch1 & 3f ) ) ; } break ; case 14 : { int ch1 = source [ pos ++ ] ; int ch2 = source [ pos ++ ] ; dest . append ( ( char ) ( ( ch & 0f ) << 12 | ( ch1 & 3f ) << 6 | ch2 & 3f ) ) ; } break ; default : throw new RuntimeException ( String . format ( "Invalid UTF-8: %X" , ch ) ) ; } } }
te	1	public static SSLContext clientContext ( ) { try { InputStream stream = ClassLoader . getSystemResourceAsStream ( CLIENT_STORE ) ; SSLContext context = Utilities . newSSLContext ( stream , CLIENT_PASSWD , "PKCS12" , "sunx509" ) ; context . init ( null , new TrustManager [ ] { new X509TrustManagerTrustAll ( ) } , new SecureRandom ( ) ) ; return context ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } }
te	9	@ Override public void actionPerformed ( ActionEvent e ) { Object o = e . getSource ( ) ; if ( e . getSource ( ) . equals ( clasa ) ) { fillBoxElev ( ) ; fillBoxMaterii ( ) ; } else if ( o instanceof JButton ) { if ( ( ( JButton ) o ) . equals ( note ) ) { String s_materie = materie . getSelectedItem ( ) . toString ( ) ; for ( Materie m : Centralizator . getInstance ( ) . getMaterii ( ) ) { if ( s_materie . equals ( m . getNume ( ) ) ) { ( ( Administrator ) profesor ) . setMaterie ( m ) ; break ; } } String nume_prenume = elev . getSelectedItem ( ) . toString ( ) ; String cl = clasa . getSelectedItem ( ) . toString ( ) ; dispose ( ) ; new AdminAdaugaNote ( profesor , nume_prenume , cl ) ; } else if ( ( ( JButton ) o ) . equals ( absente ) ) { String s_materie = materie . getSelectedItem ( ) . toString ( ) ; for ( Materie m : Centralizator . getInstance ( ) . getMaterii ( ) ) { if ( s_materie . equals ( m . getNume ( ) ) ) { ( ( Administrator ) profesor ) . setMaterie ( m ) ; break ; } } String nume_prenume = elev . getSelectedItem ( ) . toString ( ) ; String cl = clasa . getSelectedItem ( ) . toString ( ) ; dispose ( ) ; new AdminAdModAbsente ( profesor , nume_prenume , cl ) ; } else if ( ( ( JButton ) o ) . equals ( incheie ) ) { String s_materie = materie . getSelectedItem ( ) . toString ( ) ; for ( Materie m : Centralizator . getInstance ( ) . getMaterii ( ) ) { if ( s_materie . equals ( m . getNume ( ) ) ) { ( ( Administrator ) profesor ) . setMaterie ( m ) ; break ; } } String nume_prenume = elev . getSelectedItem ( ) . toString ( ) ; String cl = clasa . getSelectedItem ( ) . toString ( ) ; dispose ( ) ; new AdminIncheieSituatie ( profesor , nume_prenume , cl ) ; } else if ( e . getSource ( ) . equals ( back ) ) { dispose ( ) ; Centralizator cen2 = Centralizator . getInstance ( ) ; cen2 . saveCentralizator ( ) ; new ClaseAdmin ( profesor ) ; } } }
te	7	@ SuppressWarnings ( "unchecked" ) public static void isAnnotationPresent ( class < ? > clazz , String methodName , class annotation ) throws IllegalArgumentException , JStrykerException { if ( clazz == null ) { throw new IllegalArgumentException ( "Class cannot be null." ) ; } if ( annotation == null ) { throw new IllegalArgumentException ( "Annotation cannot be null." ) ; } if ( methodName == null ) { throw new IllegalArgumentException ( "Method name cannot be null." ) ; } try { if ( ! clazz . getMethod ( methodName ) . isAnnotationPresent ( annotation ) ) { String message = String . format ( "Annotation %s is not present in method %s on %s class." , annotation . getName ( ) , methodName , clazz . getName ( ) ) ; throw new AssertionError ( message ) ; } } catch ( SecurityException e ) { throw new JStrykerException ( e . getMessage ( ) , e ) ; } catch ( NoSuchMethodException e ) { String message = String . format ( "Method name %s does not exist in %s class." , methodName , clazz . getName ( ) ) ; throw new JStrykerException ( message , e ) ; } }
te	7	@ Override public List < Set < DirectedGraphNode >> partition ( Collection < DirectedGraphNode > nodeSet ) { if ( nodeSet . isEmpty ( ) ) { return Collections . < Set < DirectedGraphNode >> emptyList ( ) ; } nodeSetBelongsToGraph ( nodeSet ) ; this . nodes = new Node [ nodeSet . size ( ) ] ; List < Set < DirectedGraphNode >> partition = new ArrayList < > ( ) ; int i = 0 ; for ( final DirectedGraphNode node : nodeSet ) { this . nodes [ i ++ ] = node ; } Deque < Range > stack = new LinkedList < > ( ) ; List < Range > resultRanges = new ArrayList < > ( ) ; stack . add ( new Range ( 0 , nodes . length - 1 , X ) ) ; while ( stack . isEmpty ( ) == false ) { Range r = stack . removeFirst ( ) ; if ( r . length ( ) > this . maxNodesPerRegion ) { Arrays . sort ( nodes , r . from , r . to + 1 , ( r . axis == X ? xcmp : ycmp ) ) ; Range [ ] children = r . split ( ) ; stack . addLast ( children [ 0 ] ) ; stack . addLast ( children [ 1 ] ) ; } else { resultRanges . add ( r ) ; } } for ( final Range range : resultRanges ) { Set < DirectedGraphNode > region = new HashSet < > ( range . length ( ) ) ; for ( final int index : range ) { region . add ( ( DirectedGraphNode ) nodes [ index ] ) ; } partition . add ( region ) ; } return partition ; }
te	2	public static String getSwitchStatusAsString ( SwitchStatus switchStatus ) { if ( switchStatus == SwitchStatus . ON ) { return "On" ; } else if ( switchStatus == SwitchStatus . OFF ) { return "Off" ; } return "" ; }
te	0	public void setFilename ( String filename ) { this . filename = filename ; }
te	7	public void keyReleased ( KeyEvent e ) { if ( this . PFPanel . getSelectedIndex ( ) == 0 && ( ( e . getKeyChar ( ) >= 65 && e . getKeyChar ( ) <= 90 ) || ( e . getKeyChar ( ) >= 97 && e . getKeyChar ( ) <= 122 ) || ( ! patientTF [ 0 ] . getText ( ) . isEmpty ( ) && ( e . getKeyCode ( ) == KeyEvent . VK_BACK_SPACE ) ) ) ) { function . patientList ( patient , patientTF [ 0 ] , listMode ) ; } }
te	2	public boolean contains ( E query ) { Node < E > node = this . head ; boolean contained = false ; while ( node != null ) { if ( node . item . equals ( query ) ) { contained = true ; } node = node . next ; } return contained ; }
te	4	public static String readTextFromReader ( final Reader reader ) { StringBuffer sb = new StringBuffer ( ) ; char [ ] buf = new char [ 1024 * 4 ] ; int readLen ; try { while ( - 1 != ( readLen = reader . read ( buf ) ) ) { sb . append ( buf , 0 , readLen ) ; } } catch ( IOException e ) { e . printStackTrace ( ) ; } finally { if ( null != reader ) { try { reader . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } } return sb . toString ( ) ; }
te	3	public static Sensor narrow ( org . omg . CORBA . Object obj ) { if ( obj == null ) return null ; else if ( obj instanceof Sensor ) return ( Sensor ) obj ; else if ( ! obj . _is_a ( id ( ) ) ) throw new org . omg . CORBA . BAD_PARAM ( ) ; else { org . omg . CORBA . portable . Delegate delegate = ( ( org . omg . CORBA . portable . ObjectImpl ) obj ) . _get_delegate ( ) ; _SensorStub stub = new _SensorStub ( ) ; stub . _set_delegate ( delegate ) ; return stub ; } }
te	4	private SDOShape createShape ( int [ ] elmInfo , int [ ] ordinates ) { if ( ShapeType . isCompoundShape ( elmInfo ) ) { CompoundSDO compoundShape = new CompoundSDO ( ) ; int numSegments = elmInfo . length / 3 ; int segCounter = 0 ; logger . info ( "Creating shape from " + numSegments + " segments." ) ; for ( int segmentOffset = 0 ; segCounter < numSegments ; segmentOffset += 3 ) { SDOShape shape = new SDOShape ( ) ; int startIndex = elmInfo [ segmentOffset + 0 ] ; int eType = elmInfo [ segmentOffset + 1 ] ; int interpretation = elmInfo [ segmentOffset + 2 ] ; logger . debug ( "SEGMENT: " + segmentOffset + " Offset: " + startIndex + " E-Type: " + eType + " Interpretation: " + interpretation ) ; shape . setShapeType ( ShapeType . getShapeType ( eType , interpretation ) ) ; shape . setEType ( eType ) ; shape . setInterpretation ( interpretation ) ; int endIndex = ordinates . length ; if ( numSegments > 1 && segmentOffset < ( numSegments - 1 ) ) { endIndex = elmInfo [ segmentOffset + 3 ] ; } setCoordinates ( shape , startIndex , endIndex , ordinates ) ; compoundShape . addShape ( shape ) ; segCounter ++ ; } compoundShape . setX ( getX ( ordinates ) ) ; compoundShape . setY ( getY ( ordinates ) ) ; return compoundShape ; } else { SDOShape shape = new SDOShape ( ) ; int startIndex = elmInfo [ 0 ] ; int eType = elmInfo [ 1 ] ; int interpretation = elmInfo [ 2 ] ; int endIndex = ordinates . length ; logger . debug ( "Offset: " + startIndex + " E-Type: " + eType + " Interpretation: " + interpretation ) ; shape . setShapeType ( ShapeType . getShapeType ( eType , interpretation ) ) ; shape . setEType ( eType ) ; shape . setInterpretation ( interpretation ) ; setCoordinates ( shape , startIndex , endIndex , ordinates ) ; return shape ; } }
te	0	USB ( String parent , String file , int num , Vector l , Host h ) throws IOException { windriverNameBusID = file ; busnum = num ; listeners = l ; host = h ; root = 1 ; devices [ root ] = new DeviceImpl ( this , parent + file , 1 ) ; added ( devices [ root ] ) ; }
te	3	private void leftForkAvailableInternal ( String fork ) { if ( hasLeftTable . get ( ) ) return ; System . out . println ( LogLineCount . incrementAndGet ( ) + " - philosopher " + id + ": left fork " + fork + " available" ) ; if ( availableForks . size ( ) == 1 ) { System . out . println ( LogLineCount . incrementAndGet ( ) + " - philosopher " + id + ": only 1 fork left  not picking it up to prevent deadlock from happening" ) ; getLeftPhilosopher ( ) . rightForkAvailable ( fork ) ; return ; } ImmutableList < String > forks = availableForks . remove ( fork ) ; if ( forks == null ) { System . out . println ( LogLineCount . incrementAndGet ( ) + " - philosopher " + id + ": somebody else obtained " + fork ) ; return ; } System . out . println ( LogLineCount . incrementAndGet ( ) + " - philosopher " + id + ": obtained my left fork " + fork ) ; hasLeftFork = true ; rightForkAvailableInternal ( getRightForkName ( ) ) ; }
te	5	private Room getFollowRoom ( int x , int y ) { for ( Room curRoom : roomList ) if ( x > curRoom . getX ( ) && x < curRoom . getX ( ) + Room . getImageWidth ( ) && y > curRoom . getY ( ) && y < curRoom . getY ( ) + Room . getImageHeight ( ) ) return curRoom ; return null ; }
te	8	public static ItemStack [ ] getRecipe ( int i ) { ItemStack [ ] is = new ItemStack [ 10 ] ; switch ( i ) { case Sticks : is [ 0 ] = new ItemStack ( Items . log , 1 ) ; break ; case CraftTable : is [ 0 ] = new ItemStack ( Items . stick , 12 ) ; is [ 1 ] = new ItemStack ( Items . log , 4 ) ; break ; case Pickaxe : is [ 0 ] = new ItemStack ( Items . stick , 2 ) ; is [ 1 ] = new ItemStack ( Items . rock , 6 ) ; break ; case CampFire : is [ 0 ] = new ItemStack ( Items . log , 5 ) ; is [ 1 ] = new ItemStack ( Items . rock , 12 ) ; is [ 2 ] = new ItemStack ( Items . stick , 4 ) ; break ; case Sword : is [ 0 ] = new ItemStack ( Items . stick , 2 ) ; is [ 1 ] = new ItemStack ( Items . log , 1 ) ; is [ 2 ] = new ItemStack ( Items . rock , 8 ) ; break ; case Axe : is [ 0 ] = new ItemStack ( Items . stick , 2 ) ; is [ 1 ] = new ItemStack ( Items . rock , 3 ) ; break ; case Oven : is [ 0 ] = new ItemStack ( Items . rock , 20 ) ; break ; case Lantern : is [ 0 ] = new ItemStack ( Items . ingot , 10 ) ; break ; } return is ; }
te	6	public String getAnswer ( String S ) { int [ ] alphabet = new int [ 26 ] ; for ( int i = 0 ; i < S . length ( ) ; i ++ ) { alphabet [ S . charAt ( i ) - A ] ++ ; } if ( alphabet [ C - A ] == 1 && alphabet [ A - A ] == 1 && alphabet [ T - A ] == 1 ) { int cIndex = S . indexOf ( C ) ; int aIndex = S . indexOf ( A ) ; int tIndex = S . indexOf ( T ) ; if ( cIndex < aIndex && aIndex < tIndex ) return "Possible" ; } return "Impossible" ; }
te	2	public void showPrevious ( ) { if ( photos != null && currentIndex > 0 ) { showPhoto ( currentIndex - 1 ) ; } }
te	1	public Fuentes ( ) { try { calibri = Font . createFont ( Font . TRUETYPE_FONT , this . getClass ( ) . getResourceAsStream ( "/Fuentes/calibri.ttf" ) ) ; joystixMonospacce = Font . createFont ( Font . TRUETYPE_FONT , this . getClass ( ) . getResourceAsStream ( "/Fuentes/joystix_monospace.otf" ) ) ; } catch ( FontFormatException | IOException ex ) { System . out . println ( "Error al cargar fuente" ) ; } }
te	9	public static void tick ( ) { if ( ! Game . keys [ KeyEvent . VK_BACK_SPACE ] ) { if ( Game . keychar != "|" . charAt ( 0 ) ) { if ( Game . keyDown ) { input += Game . keychar ; Game . keyDown = false ; } } } if ( Game . keys [ KeyEvent . VK_BACK_SPACE ] ) { if ( input . length ( ) > 0 ) { if ( Game . keyDown ) { input = input . substring ( 0 , input . length ( ) - 1 ) ; Game . keys [ KeyEvent . VK_BACK_SPACE ] = false ; Game . keyDown = false ; } } } if ( Game . keys [ KeyEvent . VK_ENTER ] ) { if ( input . length ( ) > 0 ) { history . add ( ">" + input ) ; show = CommandReader . read ( input ) ; input = "" ; } Game . keys [ KeyEvent . VK_ENTER ] = false ; } if ( Game . keys [ KeyEvent . VK_UP ] ) { if ( history . size ( ) > 0 ) { input = history . get ( history . size ( ) - 1 ) . replace ( ">" , "" ) ; Game . keys [ KeyEvent . VK_UP ] = false ; } } }
te	6	public String toPrettyString ( ) { PaddingStringBuilder output = new PaddingStringBuilder ( ) ; PaddingStringBuilder . PaddingSection settingsSection = new PaddingStringBuilder . PaddingSection ( true ) ; output . append ( " | " ) . append ( settingsSection , "Score limit: " ) . append ( scoreLimit ) . append ( "\n | " ) . append ( settingsSection , "Population size: " ) . append ( populationSize ) . append ( "\n | " ) . append ( settingsSection , "Generation limit: " ) . append ( generationLimit ) . append ( "\n | " ) . append ( settingsSection , "Execution timeout: " ) . append ( String . format ( "% d" , executionTimeout ) ) . append ( " (ms)" ) . append ( "\n | " ) . append ( settingsSection , "Status interval: " ) . append ( String . format ( "% d" , statusInterval ) ) . append ( " (ms)" ) . append ( "\n | " ) . append ( settingsSection , "Random seed: " ) . append ( randomSeed ) . append ( "\n | " ) . append ( settingsSection , "Project main class: " ) . append ( projectMain ) . append ( "\n | " ) . append ( settingsSection , "Project problem class: " ) . append ( problemClassName ) ; DecimalFormat oneDotTwoFormat = new DecimalFormat ( "0.00" ) ; double totalWeight = 0D ; for ( BreedingOperatorSetup opSetup : breedingOperators ) { totalWeight += opSetup . weight ; } output . append ( "\n | Breeding operators:" ) ; PaddingStringBuilder . PaddingSection breedOpWeights = new PaddingStringBuilder . PaddingSection ( false ) ; PaddingStringBuilder . PaddingSection breedOpPercent = new PaddingStringBuilder . PaddingSection ( false ) ; for ( BreedingOperatorSetup opSetup : breedingOperators ) { output . append ( "\n | | " ) . append ( breedOpWeights , oneDotTwoFormat . format ( opSetup . weight ) ) . append ( " -> " ) . append ( breedOpPercent , Math . round ( opSetup . weight / totalWeight * 100 ) ) . append ( "%: " ) . append ( opSetup . breedingOperator ) ; } output . append ( "\n | Approved breeding classes:" ) ; StringBuilder classesWith = new StringBuilder ( ) ; StringBuilder classesWithout = new StringBuilder ( ) ; for ( BreedingClassSetup classSetup : breedingClasses ) { if ( classSetup . instantiable ) { classesWith . append ( "\n | | | " ) . append ( classSetup . className ) ; } else { classesWithout . append ( "\n | | | " ) . append ( classSetup . className ) ; } } if ( classesWith . length ( ) > 0 ) { output . append ( "\n | | With instantiation:" ) . append ( classesWith ) ; } if ( classesWithout . length ( ) > 0 ) { output . append ( "\n | | Without instantiation:" ) . append ( classesWithout ) ; } return output . toString ( ) ; }
te	9	private void paint ( Graphics g , BHexColorChooserWidget c ) { if ( g instanceof Graphics2D ) { ( ( Graphics2D ) g ) . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; } int [ ] selectedColorIndex = getIndex ( c . getSelectedColor ( ) ) ; int maxSizeWidth = ( int ) Math . floor ( ( ( c . getWidth ( ) - borderSize ) / ( double ) numberOfHex ) / ( Math . sqrt ( 3 ) / 2.0 ) ) ; int maxSizeHeight = ( int ) Math . floor ( ( ( c . getHeight ( ) - borderSize ) / ( double ) numberOfHex ) * ( 1.25 ) ) ; int sizeOfOneHex = Math . min ( maxSizeHeight , maxSizeWidth ) ; int sizeIOfOneHex = ( int ) ( sizeOfOneHex * ( Math . sqrt ( 3 ) / 2 ) ) ; int radiusOfOneHex = ( int ) Math . ceil ( sizeOfOneHex / 2.0 ) ; int radiusIOfOneHex = ( int ) ( radiusOfOneHex * ( Math . sqrt ( 3 ) / 2 ) ) ; int pivotX = c . getWidth ( ) / 2 ; int pivotY = c . getHeight ( ) / 2 ; int startX = ( pivotX - ( numberOfHex / 2 ) * sizeIOfOneHex ) + ( ( numberOfHex / 2 ) * radiusIOfOneHex ) ; int startY = ( int ) ( pivotY - ( 1.5 * radiusOfOneHex ) * ( numberOfHex / 2 ) ) ; int rowWidth = numberOfHex - ( numberOfHex / 2 ) ; for ( int y = 0 ; y < numberOfHex ; y ++ ) { for ( int x = 0 ; x < rowWidth ; x ++ ) { if ( y == 0 || y == numberOfHex - 1 || x == 0 || x == rowWidth - 1 ) { BGraphics2D . fillHexagon ( g , c . getBackground ( ) , startX + x * sizeIOfOneHex , startY , radiusOfOneHex + borderSize , 0 ) ; } } startY += radiusOfOneHex * 1.5 ; startX -= ( y < numberOfHex / 2 ) ? radiusIOfOneHex : - radiusIOfOneHex ; rowWidth += ( y < numberOfHex / 2 ) ? 1 : - 1 ; } startX = ( pivotX - ( numberOfHex / 2 ) * sizeIOfOneHex ) + ( ( numberOfHex / 2 ) * radiusIOfOneHex ) ; startY = ( int ) ( pivotY - ( 1.5 * radiusOfOneHex ) * ( numberOfHex / 2 ) ) ; rowWidth = numberOfHex - ( numberOfHex / 2 ) ; for ( int y = 0 ; y < numberOfHex ; y ++ ) { for ( int x = 0 ; x < rowWidth ; x ++ ) { g . setColor ( getColor ( x , y ) ) ; if ( x == selectedColorIndex [ 0 ] && y == selectedColorIndex [ 1 ] ) { BGraphics2D . fillHexagon ( g , g . getColor ( ) , startX + x * sizeIOfOneHex , startY , radiusOfOneHex , 0 ) ; BGraphics2D . fillHexagon ( g , negate ( g . getColor ( ) ) , startX + x * sizeIOfOneHex , startY , radiusOfOneHex - 3 , 0 ) ; BGraphics2D . fillHexagon ( g , g . getColor ( ) , startX + x * sizeIOfOneHex , startY , radiusOfOneHex - 5 , 0 ) ; } else { BGraphics2D . fillHexagon ( g , g . getColor ( ) , startX + x * sizeIOfOneHex , startY , radiusOfOneHex , 0 ) ; } } startY += radiusOfOneHex * 1.5 ; startX -= ( y < numberOfHex / 2 ) ? radiusIOfOneHex : - radiusIOfOneHex ; rowWidth += ( y < numberOfHex / 2 ) ? 1 : - 1 ; } }
te	3	private void EjecutarBotonActionPerformed ( java . awt . event . ActionEvent evt ) { try { lexicoAnalizador ( ) ; Sintactico sintactico = new Sintactico ( archivo . getName ( ) ) ; sintactico . analizadorSintactico ( ) ; arbolSintactico . setModel ( sintactico . getTree ( ) ) ; arbolSemantico . setModel ( sintactico . getTreeSem ( ) ) ; tablaPanel . setModel ( sintactico . getTabla ( ) . getModel ( ) ) ; CodigoP codigo = new CodigoP ( sintactico . getRaiz ( ) ) ; codigo . muestraCodigoPenArea ( areaCodigoP ) ; ArrayList < String > as = sintactico . getErrores ( ) ; Iterator e = as . iterator ( ) ; String err = "" ; while ( e . hasNext ( ) ) { err = ( String ) e . next ( ) ; errores . setText ( errores . getText ( ) + err ) ; } if ( "" . equals ( err ) ) { errores . append ( "Ningun Error Sint\u00E1ctico detectado" ) ; } else { errores . append ( err ) ; } } catch ( Exception e ) { } }
te	2	private void initialize ( String [ ] values ) { if ( hasTooLessEntries ( values ) ) { values = fillMissingFields ( values ) ; } for ( Type t : Type . values ( ) ) { setField ( t , values [ t . ordinal ( ) ] ) ; } }
te	0	public Make ( Model model ) { super ( model ) ; }
te	6	public String getReturnDesc ( ) throws MqttUnknowReturnCodeException { switch ( this . returnCode ) { case MqttProtocalVariableHeader . CONNECT_RETURN_CODE_ACCEPTED : return MqttProtocalVariableHeader . CONNECT_RETURN_STRING_ACCEPTED ; case MqttProtocalVariableHeader . CONNECT_RETURN_CODE_ID_REJECTED : return MqttProtocalVariableHeader . CONNECT_RETURN_STRING_ID_REJECTED ; case MqttProtocalVariableHeader . CONNECT_RETURN_CODE_SERVER_UNAVAILABLE : return MqttProtocalVariableHeader . CONNECT_RETURN_STRING_SERVER_UNAVAILABLE ; case MqttProtocalVariableHeader . CONNECT_RETURN_CODE_UNACCEPTABLE_PROTOCOL_VERSION : return MqttProtocalVariableHeader . CONNECT_RETURN_STRING_UNACCEPTABLE_PROTOCOL_VERSION ; case MqttProtocalVariableHeader . CONNECT_RETURN_CODE_UNAUTHENTICATED : return MqttProtocalVariableHeader . CONNECT_RETURN_STRING_UNAUTHENTICATED ; case MqttProtocalVariableHeader . CONNECT_RETURN_CODE_UNAUTHORIZED : return MqttProtocalVariableHeader . CONNECT_RETURN_STRING_UNAUTHORIZED ; default : throw new MqttUnknowReturnCodeException ( MqttUnknowReturnCodeException . description ) ; } }
te	8	public Node < V > remove ( V val ) { if ( ( val == null ) ? ( this . value == null ) : ( val . compareTo ( this . value ) == 0 ) ) { if ( this . left == null ) { return this . right ; } if ( this . right == null ) { return this . left ; } this . right . add ( this . left ) ; return this . right ; } else { if ( ( val == null ) || ( val . compareTo ( this . value ) < 0 ) ) { if ( this . left != null ) { this . left = this . left . remove ( val ) ; } } else { if ( this . right != null ) { this . right = this . right . remove ( val ) ; } } return this ; } }
te	5	private void flagField ( MouseEvent e ) { FieldButton fieldButton = ( ( FieldButton ) e . getSource ( ) ) ; if ( fieldButton . isEnabled ( ) ) { if ( fieldButton . isUnflagged ( ) && _minefield . getFlags ( ) > 0 ) { fieldButton . flag ( ) ; _minefield . decrementFlags ( ) ; SoundPlayer . playFlagSound ( ) ; if ( fieldButton . getField ( ) . getValue ( ) . equals ( FieldValue . MINE ) ) { _minefield . incrementCorrectFlags ( ) ; } } else if ( fieldButton . isFlagged ( ) ) { fieldButton . unflag ( ) ; _minefield . incrementFlags ( ) ; SoundPlayer . playUnflagSound ( ) ; } } _gameView . setFlags ( _minefield . getFlags ( ) ) ; }
te	5	@ Override public void train ( ) { dists . clear ( ) ; means . clear ( ) ; Map < Integer , Set < Pattern >> classes = new HashMap < Integer , Set < Pattern >> ( ) ; for ( Pattern instance : getTrainSet ( ) ) { Set < Pattern > partition = classes . containsKey ( instance . getClassIndex ( ) ) ? classes . get ( instance . getClassIndex ( ) ) : new HashSet < Pattern > ( ) ; partition . add ( instance ) ; classes . put ( instance . getClassIndex ( ) , partition ) ; } for ( Integer clazz : classes . keySet ( ) ) { Set < Pattern > partition = classes . get ( clazz ) ; double [ ] mean = mean ( partition ) ; double [ ] dist = new double [ mean . length ] ; Arrays . fill ( dist , 0d ) ; for ( Pattern instance : partition ) { double [ ] vector = instance . toDoubleVector ( ) ; for ( int i = 0 ; i < vector . length ; i ++ ) { dist [ i ] += Math . abs ( vector [ i ] - mean [ i ] ) / ( double ) partition . size ( ) ; } } dists . put ( clazz , dist ) ; means . put ( clazz , mean ) ; } }
te	1	public Currency getCurrency ( ) { if ( ! isA ( VariantCurrency ) ) illegal ( "getCurrency" , "VariantCurrency" ) ; return ( Currency ) value ; }
te	0	@ Override public void resume ( ) { }
te	4	@ Override public void actionPerformed ( ActionEvent e ) { if ( e . getClass ( ) != null && e . getSource ( ) instanceof ItemButton ) { ItemButton ib = ( ItemButton ) e . getSource ( ) ; if ( ( e . getModifiers ( ) & e . SHIFT_MASK ) != 0 ) { logView . addString ( "Used item: " + ib . getItem ( ) . toString ( ) ) ; System . out . println ( "SHIFT_INVENTORY_CLICK" ) ; } else if ( ( e . getModifiers ( ) & e . CTRL_MASK ) != 0 ) { GameModel . getLocalPlayer ( ) . getInventory ( ) . remove ( ib . getItem ( ) ) ; System . out . println ( "CTRL_INV_CLICK" ) ; } else { gameGui . setItemToPaint ( ib . getItem ( ) ) ; System . out . println ( "INV CLICK" ) ; } inventoryView . updateView ( ) ; inventoryView . validate ( ) ; } }
te	2	public static TIPPResponseCode fromSchemaValue ( String value ) { for ( TIPPResponseCode msg : values ( ) ) { if ( msg . value . equals ( value ) ) { return msg ; } } return null ; }
te	9	@ Test public void testTorbenAlgorithm ( ) { int count = 0 ; boolean warmUp = true ; for ( int nRanges = 2 ; nRanges <= 2 ; nRanges += ( nRanges >= 30 ? 5 : 1 ) ) { System . out . println ( "testTorbenAlgorithm (nRanges = " + nRanges + ")" ) ; if ( warmUp ) { System . out . println ( "Warming up JVM..." ) ; } System . out . println ( "n\tmedian\tloops\tops\ttime\tcomps" ) ; Random rand = new Random ( 42 ) ; for ( int n = 2 ; n <= 2 ; n += 1 ) { double m [ ] = new double [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { m [ i ] = rand . nextDouble ( ) ; } long startTime = System . currentTimeMillis ( ) ; double torbenMedian = MedianFinder . torben ( m ) ; long endTime = System . currentTimeMillis ( ) ; Arrays . sort ( m ) ; double median = n % 2 == 0 ? m [ n / 2 - 1 ] : m [ n / 2 ] ; assert . assertEquals ( median , torbenMedian , 0.000000001 ) ; if ( n > 500 && MedianFinder . getLoopCount ( ) < 4 ) { count ++ ; } if ( ! warmUp ) { System . out . println ( n + "\t" + torbenMedian + "\t" + MedianFinder . getLoopCount ( ) + "\t" + MedianFinder . getOpCount ( ) + "\t" + ( endTime - startTime ) + "\t" + MedianFinder . getCompCount ( ) ) ; } } if ( warmUp ) { nRanges = 1 ; warmUp = false ; } } System . out . println ( count ) ; }
te	2	public int calculateScore ( String peptide ) { int score = 0 ; List < Integer > cycling = gTS . getCyclingCyclospectrum ( peptide ) ; List < Integer > alreadyCounted = new ArrayList ( ) ; for ( Integer i : cycling ) { if ( ! existsInList ( i , alreadyCounted ) ) { int count = countInList ( i , cycling ) ; int countSpectrum = countInList ( i , this . spectrumList ) ; score = score + score ( count , countSpectrum ) ; alreadyCounted . add ( i ) ; } } return score ; }
te	9	private int getIndexTochange ( int [ ] indices , int [ ] dataBlock , int codelength , int code_n , JPEGComponent comp ) { int values [ ] = new int [ codelength ] ; for ( int i = 0 ; i < codelength ; i ++ ) { int coeffindex = indices [ i ] % 64 ; int blockIndex = indices [ i ] / 64 ; short [ ] currentBlock = ( short [ ] ) comp . data . get ( blockIndex ) ; int number = ( int ) currentBlock [ coeffindex ] ; if ( number == - 1 ) { values [ i ] = 0 ; } else if ( number == 1 ) { values [ i ] = 1 ; } else if ( number % 2 == 0 ) { values [ i ] = 0 ; } else { values [ i ] = 1 ; } } int cols = ( int ) Math . pow ( 2 , code_n - 1 ) ; int rows = code_n ; int temp [ ] = new int [ code_n ] ; for ( int i = 0 ; i < rows ; i ++ ) { int dynamicHammingCode [ ] = generateCode ( i , cols ) ; for ( int j = 0 ; j < cols ; j ++ ) { temp [ i ] += values [ dynamicHammingCode [ j ] - 1 ] ; } if ( temp [ i ] % 2 != 0 ) { temp [ i ] = 1 ; } else { temp [ i ] = 1 ; } } for ( int i = 0 ; i < code_n ; i ++ ) { int a = dataBlock [ i ] + temp [ i ] ; if ( a == 1 ) { temp [ i ] = 1 ; } else { temp [ i ] = 0 ; } } int pos = Utility . changeBitsToValue ( temp , code_n ) ; if ( pos == 0 ) { return - 1 ; } else { return indices [ pos - 1 ] ; } }
te	6	public ArrayList < BeanIncidencias > getIncidencias ( final int idAlumno , final int idGrupAsig , final String idProfesor , final String desde , final String hasta ) { ArrayList < BeanIncidencias > listInc = new ArrayList < BeanIncidencias > ( ) ; StringBuilder tmp = new StringBuilder ( "SELECT fa.*  ti.simbolo  ti.descripcion FROM faltasalumnos AS fa INNER JOIN tipoincidencias AS ti ON " ) ; tmp . append ( " fa.idTipoIncidencias=ti.id WHERE idAlumnos=" ) . append ( idAlumno ) . append ( " AND " ) ; tmp . append ( " idProfesores='" ) . append ( idProfesor ) . append ( "' AND idGrupAsig=" ) . append ( idGrupAsig ) . append ( " AND dia>='" ) . append ( desde ) . append ( "' " ) ; tmp . append ( " AND dia<='" ) . append ( hasta ) . append ( "'" ) ; String SQL1 = tmp . toString ( ) ; try { Statement st = getSgd ( ) . createStatement ( ) ; ResultSet rs1 = getSgd ( ) . getResultSet ( SQL1 , st ) ; while ( rs1 != null && rs1 . next ( ) ) { BeanIncidencias bh = new BeanIncidencias ( ) ; bh . setId ( rs1 . getInt ( "id" ) ) ; bh . setIdProfesores ( rs1 . getString ( "idProfesores" ) ) ; bh . setIdAlumnos ( rs1 . getInt ( "idAlumnos" ) ) ; bh . setIdTipoIncidencias ( rs1 . getInt ( "idTipoIncidencias" ) ) ; bh . setIdHorasCentro ( rs1 . getInt ( "idHorasCentro" ) ) ; bh . setIdGrupAsig ( rs1 . getInt ( "idGrupAsig" ) ) ; bh . setIdTipoObservaciones ( rs1 . getInt ( "idTipoObservaciones" ) ) ; bh . setDia ( rs1 . getDate ( "dia" ) ) ; bh . setHora ( rs1 . getString ( "hora" ) ) ; bh . setObservaciones ( rs1 . getString ( "comentarios" ) ) ; bh . setFechaModificado ( rs1 . getTimestamp ( "fechaModificado" ) ) ; bh . setDescripcion ( rs1 . getString ( "descripcion" ) ) ; String simbolo = normalizeSimbol ( rs1 . getString ( "simbolo" ) ) ; bh . setSimbolo ( simbolo ) ; bh . setEditable ( true ) ; if ( simbolo . equalsIgnoreCase ( "ALH" ) || simbolo . equalsIgnoreCase ( "EX" ) ) { bh . setEditable ( false ) ; } listInc . add ( bh ) ; } if ( rs1 != null ) { rs1 . close ( ) ; st . close ( ) ; } } catch ( SQLException ex ) { Logger . getLogger ( IncidenciasCollection . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } return listInc ; }
te	3	@ Override public < T > T accept ( ParseTreeVisitor < ? extends T > visitor ) { if ( visitor instanceof SSTVisitor ) return ( ( SSTVisitor < ? extends T > ) visitor ) . visitAssignmentvalue ( this ) ; else return visitor . visitChildren ( this ) ; }
te	9	public static void arraycopy ( final String [ ] src , final int srcPos , final StringLargeArray dest , final long destPos , final long length ) { if ( srcPos < 0 || srcPos >= src . length ) { throw new ArrayIndexOutOfBoundsException ( "srcPos < 0 || srcPos >= src.length" ) ; } if ( destPos < 0 || destPos >= dest . length ( ) ) { throw new ArrayIndexOutOfBoundsException ( "destPos < 0 || destPos >= dest.length()" ) ; } if ( length < 0 ) { throw new IllegalArgumentException ( "length < 0" ) ; } if ( dest . isConstant ( ) ) { throw new IllegalArgumentException ( "Constant arrays cannot be modified." ) ; } int i = srcPos ; int nthreads = ( int ) Math . min ( length , Runtime . getRuntime ( ) . availableProcessors ( ) ) ; if ( nthreads < 2 || length < 100000 ) { for ( long j = destPos ; j < destPos + length ; j ++ ) { dest . set ( j , src [ i ++ ] ) ; } } else { long k = length / nthreads ; Thread [ ] threads = new Thread [ nthreads ] ; for ( int j = 0 ; j < nthreads ; j ++ ) { final long firstIdx = j * k ; final long lastIdx = ( j == nthreads - 1 ) ? length : firstIdx + k ; threads [ j ] = new Thread ( new Runnable ( ) { @ Override public void run ( ) { for ( long k = firstIdx ; k < lastIdx ; k ++ ) { dest . set ( destPos + k , src [ srcPos + ( int ) k ] ) ; } } } ) ; threads [ j ] . start ( ) ; } try { for ( int j = 0 ; j < nthreads ; j ++ ) { threads [ j ] . join ( ) ; threads [ j ] = null ; } } catch ( InterruptedException ex ) { for ( long j = destPos ; j < destPos + length ; j ++ ) { dest . set ( j , src [ i ++ ] ) ; } } } }
te	3	public void actionPerformed ( ActionEvent e ) { if ( e . getSource ( ) == unfulfilledRequestButton ) { String unfulfilledData = DataIO . GetUnfulfilledRequestReport ( courseAssignment . getCourses ( ) , courseAssignment . getInstructors ( ) ) ; PrintWindow printWindow = new PrintWindow ( unfulfilledData ) ; printWindow . setVisible ( true ) ; ReportSelectionWindow . this . dispose ( ) ; } else if ( e . getSource ( ) == assignedCourseButton ) { String courseData = DataIO . GetCourseReport ( courseAssignment . getCourses ( ) , true ) ; PrintWindow printWindow = new PrintWindow ( courseData ) ; printWindow . setVisible ( true ) ; ReportSelectionWindow . this . dispose ( ) ; } else if ( e . getSource ( ) == unassignedCourseButton ) { String courseData = DataIO . GetCourseReport ( courseAssignment . getCourses ( ) , false ) ; PrintWindow printWindow = new PrintWindow ( courseData ) ; printWindow . setVisible ( true ) ; ReportSelectionWindow . this . dispose ( ) ; } }
te	6	public void shellDB ( ) { logger . debug ( "shellDB: --------------" ) ; Connection connectionForInit = getExistDB ( ) ; if ( connectionForInit == null ) { logger . debug ( "shellDB:The DB does'nt exist -> installDBfromScratch !" ) ; connectionForInit = getInstallDBfromScratch ( ) ; } try { logger . debug ( "shellDB:OK  the DB exist !!" ) ; logger . debug ( "shellDB:OK  connected." ) ; logger . debug ( "shellDB:Ready  Now read from stdin." ) ; executeScriptFrom ( System . in , connectionForInit , true ) ; logger . debug ( "-> EOF stdin  end" ) ; } catch ( IOException ex ) { logger . error ( "Something with the reading script:" + ex . getLocalizedMessage ( ) , ex ) ; } catch ( IllegalStateException ex ) { logger . error ( "Something with the Classpath and JDBC Driver:" + ex . getLocalizedMessage ( ) , ex ) ; } catch ( SQLException ex ) { logger . error ( "Something with the JDBC Connection:" + ex . getLocalizedMessage ( ) , ex ) ; } finally { try { if ( connectionForInit != null ) { connectionForInit . close ( ) ; } } catch ( SQLException ex1 ) { logger . error ( ex1 . getLocalizedMessage ( ) , ex1 ) ; } } }
te	8	public void run ( ) { String input = null ; String intermediateResult = null ; try { BufferedReader reader = new BufferedReader ( in ) ; while ( ( input = reader . readLine ( ) ) != null ) { intermediateResult = process ( input ) ; if ( intermediateResult != null ) { if ( intermediateResult . length ( ) > 0 ) { out . write ( intermediateResult + "\n" ) ; out . flush ( ) ; } } } isDone = true ; } catch ( IOException e ) { logger . error ( e . getMessage ( ) ) ; e . printStackTrace ( ) ; } finally { success ( ) ; while ( ! waitingFor . isDone ( ) ) { try { sleep ( 100 ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } backup ( ) ; try { if ( out != null ) { out . close ( ) ; } } catch ( IOException e ) { e . printStackTrace ( ) ; } } }
te	0	public void setLongBoneName ( String longBoneName ) { this . longBoneName = longBoneName ; }
te	4	private JsonObject getJsonFromBinding ( JsonObjectBinding a , boolean create ) { JsonObject base = asset . getObject ( ) ; String [ ] keys = a . base ( ) ; for ( String s : keys ) { JsonValue val = base . get ( s ) ; if ( val == null ) { if ( create ) base = base . set ( s , new JsonObject ( ) ) ; else return null ; } else if ( ! val . isObject ( ) ) throw new IllegalArgumentException ( "Expected JsonObject; got " + val . getClass ( ) . getSimpleName ( ) ) ; else base = ( JsonObject ) val ; } return base ; }
te	7	public void mixPalette ( int red , int green , int blue ) { for ( int i = 0 ; i < palette . length ; i ++ ) { int r = palette [ i ] >> 16 & ff ; r += red ; if ( r < 0 ) r = 0 ; else if ( r > 255 ) r = 255 ; int g = palette [ i ] >> 8 & ff ; g += green ; if ( g < 0 ) g = 0 ; else if ( g > 255 ) g = 255 ; int b = palette [ i ] & ff ; b += blue ; if ( b < 0 ) b = 0 ; else if ( b > 255 ) b = 255 ; palette [ i ] = ( r << 16 ) + ( g << 8 ) + b ; } }
te	9	public void launchSSSEditor ( ) { if ( ! new File ( "SSSEditor.exe" ) . isFile ( ) ) { JOptionPane . showMessageDialog ( null , "SSSEditor.exe not found.\nYou can get it from: http://www.lakora.us/brawl/ssseditor" ) ; } else { String gctpath = gctFile . getAbsolutePath ( ) ; File dir = gctFile . getParentFile ( ) ; while ( dir != null ) { try { if ( new File ( dir + File . separator + "private" ) . isDirectory ( ) || new File ( dir + File . separator + "projectm" ) . isDirectory ( ) || new File ( dir + File . separator + "minsuery" ) . isDirectory ( ) ) { break ; } dir = dir . getParentFile ( ) ; } catch ( Exception e ) { dir = null ; } } int r = edited [ 0 ] ? JOptionPane . showConfirmDialog ( null , "Close GCT Editor and open SSS Editor?\nAny unsaved changes you have made in GCT Editor will be lost." , "Confirm" , JOptionPane . OK_CANCEL_OPTION ) : JOptionPane . OK_OPTION ; if ( r == JOptionPane . OK_OPTION ) { ProcessBuilder pb = new ProcessBuilder ( "SSSEditor.exe" , gctpath ) ; if ( dir != null ) pb . directory ( dir ) ; try { pb . start ( ) ; System . exit ( 0 ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } } }
te	3	@ Override public void paintNode ( Graphics2D g2d , ScRegion region ) { g2d . setStroke ( this . getLineStroke ( ) ) ; g2d . setColor ( this . getStrokeColor ( ) ) ; if ( seriesType == 1 ) { this . paintNodeLine ( g2d , region ) ; } if ( seriesType == 2 ) { this . paintNodePoints ( g2d , region ) ; } if ( seriesType == 4 ) { this . paintNodeHistogram ( g2d , region ) ; } }
te	0	public JUMP ( String jmpLabel ) { super ( Opcode . J , 0 , "" ) ; JmpLabel = jmpLabel ; }
te	5	public static List < String > getLocalIPs ( ) { Enumeration < NetworkInterface > interfaces ; try { interfaces = NetworkInterface . getNetworkInterfaces ( ) ; } catch ( SocketException e ) { return null ; } List < String > ips = new ArrayList < String > ( ) ; while ( interfaces . hasMoreElements ( ) ) { NetworkInterface current = interfaces . nextElement ( ) ; if ( current != null ) { Enumeration < InetAddress > addresses = current . getInetAddresses ( ) ; while ( addresses . hasMoreElements ( ) ) { InetAddress addr = addresses . nextElement ( ) ; if ( addr != null ) { ips . add ( addr . getHostAddress ( ) ) ; } } } } return ips ; }
te	4	public String reverseWords ( String input ) { charArray = input . toCharArray ( ) ; reverseString ( 0 , charArray . length - 1 ) ; int current = 0 , start = 0 , end = 0 ; while ( current < charArray . length ) { if ( charArray [ current ] ==   || current == charArray . length - 1 ) { if ( current == charArray . length - 1 ) { end = current ; } else { end = current - 1 ; } reverseString ( start , end ) ; current ++ ; start = current ; } else { current ++ ; } } return new String ( charArray ) ; }
te	3	private static String argSignature ( AccessibleObject accessibleObject ) { class [ ] param ; if ( accessibleObject instanceof Method ) { param = ( ( Method ) accessibleObject ) . getParameterTypes ( ) ; } else { param = ( ( Constructor ) accessibleObject ) . getParameterTypes ( ) ; } StringBuffer buf = new StringBuffer ( ) ; for ( int i = 0 ; i < param . length ; i ++ ) { if ( i > 0 ) { buf . append ( " " ) ; } buf . append ( param [ i ] . getName ( ) ) ; } return buf . toString ( ) ; }
te	3	public final Object getMetaValue ( Object obj , String index ) { if ( obj == null ) return null ; if ( obj instanceof LuaTable ) { LuaTable meta = ( ( LuaTable ) obj ) . getMetatable ( ) ; if ( meta == null ) return getClassMetavalue ( LuaTable . class , index ) ; return meta . rawget ( index ) ; } return getClassMetavalue ( obj . getClass ( ) , index ) ; }
te	4	@ Test public void testProfileCrudUsingToken ( ) throws BeanstreamApiException { String profileId = null ; try { HttpsConnector connector = new HttpsConnector ( 300200578 , "4BaD82D9197b4cc4b70a221911eE9f70" ) ; Address billing = getTestCardValidAddress ( ) ; LegatoTokenResponse tokenResponse = tokenizeCard ( connector , "5100000010001004" , "123" , 12 , 19 ) ; Token token = new Token ( "John Doe" , tokenResponse . getToken ( ) ) ; ProfileResponse createdProfile = beanstream . profiles ( ) . createProfile ( token , billing ) ; profileId = createdProfile . getId ( ) ; assert . assertNotNull ( "Test failed because it should create the profile and return a valid id" , profileId ) ; PaymentProfile paymentProfile = beanstream . profiles ( ) . getProfileById ( profileId ) ; assert . assertEquals ( "billing address assinged does not matches with the one sent at creation time" , paymentProfile . getBilling ( ) , billing ) ; assert . assertNotNull ( "Credit card was not in the response" , paymentProfile . getCard ( ) ) ; assert . assertTrue ( "The default lenguage should be english" , "en" . equals ( paymentProfile . getLanguage ( ) ) ) ; paymentProfile . setLanguage ( "fr" ) ; paymentProfile . setComments ( "test updating profile sending billing info only" ) ; beanstream . profiles ( ) . updateProfile ( paymentProfile ) ; paymentProfile = beanstream . profiles ( ) . getProfileById ( profileId ) ; assert . assertEquals ( "Language was updated to Francais" , paymentProfile . getLanguage ( ) , "fr" ) ; beanstream . profiles ( ) . deleteProfileById ( profileId ) ; try { beanstream . profiles ( ) . getProfileById ( profileId ) ; assert . fail ( "This profile was deleted  therefore should throw an exception" ) ; } catch ( BeanstreamApiException e ) { profileId = null ; } } catch ( BeanstreamApiException ex ) { assert . fail ( "Test can not continue  " + ex . getMessage ( ) ) ; } catch ( Exception ex ) { assert . fail ( "unexpected exception occur  test can not continue" ) ; } finally { if ( profileId != null ) { ProfileResponse response = beanstream . profiles ( ) . deleteProfileById ( profileId ) ; } } }
te	2	public String dbgExceptionToString ( Throwable e ) { ByteArrayOutputStream st = new ByteArrayOutputStream ( ) ; e . printStackTrace ( new PrintStream ( st ) ) ; if ( ( debugflags & FULLSTACKTRACE_DEBUG ) != 0 ) { return st . toString ( ) ; } else { StringTokenizer toker = new StringTokenizer ( st . toString ( ) , "\n" ) ; String ret = toker . nextToken ( ) + "\n" ; ret += toker . nextToken ( ) + "\n" ; if ( toker . hasMoreTokens ( ) ) ret += toker . nextToken ( ) ; return ret ; } }
te	1	private void btnEditActionPerformed ( java . awt . event . ActionEvent evt ) { Time selectedTime = null ; int selectedRow = tblTimes . getSelectedRow ( ) ; previousRow = selectedRow ; if ( selectedRow != - 1 ) { selectedTime = timeListModel . getTimeAt ( selectedRow ) ; } Controller . showEditTimeWindow ( selectedTime ) ; }
te	6	private static void populateSheet ( Workbook workbook , CellStyle dateCellStyle , CellStyle bodyCellStyle , int counter , Object form , Report . ReportSheet sheet , List < String > fieldPaths ) { Sheet workingSheet = workbook . getSheet ( sheet . getSheetName ( ) ) ; if ( workingSheet == null ) { return ; } Row regRow = workingSheet . createRow ( ( short ) counter ) ; int colIndex = 0 ; for ( String dottedFieldPath : fieldPaths ) { Cell cell = regRow . createCell ( colIndex ) ; Object obj = Util . getDottedFieldValue ( dottedFieldPath , form ) ; if ( obj instanceof boolean ) { cell . setCellValue ( String . valueOf ( obj ) ) ; cell . setCellType ( Cell . CELL_TYPE_BOOLEAN ) ; cell . setCellStyle ( bodyCellStyle ) ; } else if ( obj instanceof long ) { cell . setCellType ( Cell . CELL_TYPE_NUMERIC ) ; cell . setCellValue ( double . valueOf ( String . valueOf ( obj ) ) ) ; cell . setCellStyle ( bodyCellStyle ) ; } else if ( obj instanceof Date ) { cell . setCellValue ( ( Date ) obj ) ; cell . setCellStyle ( dateCellStyle ) ; } else { if ( obj != null ) { cell . setCellValue ( String . valueOf ( obj ) ) ; cell . setCellStyle ( bodyCellStyle ) ; } else { cell . setCellValue ( "" ) ; cell . setCellStyle ( bodyCellStyle ) ; } } colIndex ++ ; } }
te	3	public void AddTlv ( int tag , String value ) { if ( tag == TlvId . LinkID ) { this . LinkID = value ; } else if ( tag == TlvId . Mserviceid ) { this . ProductID = value ; } else { if ( this . OtherTlvArray == null ) { Tlv [ ] tmp = new Tlv [ 1 ] ; tmp [ 0 ] = new Tlv ( tag , value ) ; this . OtherTlvArray = tmp ; } else { Tlv [ ] tmp = new Tlv [ OtherTlvArray . length + 1 ] ; System . arraycopy ( OtherTlvArray , 0 , tmp , 0 , OtherTlvArray . length ) ; tmp [ OtherTlvArray . length ] = new Tlv ( tag , value ) ; this . OtherTlvArray = tmp ; } } }
te	0	public ShippedPanel ( ) { company = new TextField ( "Shipping Company" ) ; tracking = new TextField ( "Tracking" ) ; recipient = new TextField ( "To" ) ; addComponent ( company ) ; addComponent ( tracking ) ; addComponent ( recipient ) ; }
te	8	private Expression times ( List < Expression > args , String caller ) { boolean ints = true ; boolean intsOrDecimals = true ; if ( args . size ( ) < 2 ) { System . err . println ( "* expected at least two arguments and got " + args . size ( ) ) ; return new void ( ) ; } for ( int i = 0 ; i < args . size ( ) ; ++ i ) { if ( args . get ( i ) . eval ( defSubst , caller ) . getType ( ) . compareTo ( "integer" ) != 0 ) { ints = false ; if ( args . get ( i ) . eval ( defSubst , caller ) . getType ( ) . compareTo ( "decimal" ) != 0 ) { intsOrDecimals = false ; } } } if ( ints ) { long result = new long ( 1 ) ; for ( int i = 0 ; i < args . size ( ) ; i ++ ) { result = result * new long ( args . get ( i ) . show ( defSubst , caller ) ) ; } return new Value ( result . toString ( ) ) ; } else if ( intsOrDecimals ) { double result = new double ( 1.0 ) ; for ( int i = 0 ; i < args . size ( ) ; ++ i ) { result = result * new double ( args . get ( i ) . show ( defSubst , caller ) ) ; } return new Value ( result . toString ( ) ) ; } else { System . err . println ( "* expected only numbers as arguments" ) ; return new void ( ) ; } }
te	7	static final public int totalDiff ( final String hash1 , final String hash2 , final boolean lenDiff ) { int diff = 0 ; int [ ] iHash1 = fromHex ( hash1 ) ; int [ ] iHash2 = fromHex ( hash2 ) ; if ( lenDiff ) { int ldiff = modDiff ( iHash1 [ TLSH_CHECKSUM_LEN ] , iHash2 [ TLSH_CHECKSUM_LEN ] , RANGE_LVALUE ) ; if ( ldiff == 0 ) diff = 0 ; else if ( ldiff == 1 ) diff = 1 ; else diff += ldiff * 12 ; } int q1diff = modDiff ( iHash1 [ TLSH_CHECKSUM_LEN + 1 ] & f , iHash2 [ TLSH_CHECKSUM_LEN + 1 ] & f , RANGE_QRATIO ) ; if ( q1diff <= 1 ) diff += q1diff ; else diff += ( q1diff - 1 ) * 12 ; int q2diff = modDiff ( iHash1 [ TLSH_CHECKSUM_LEN + 1 ] >> 4 , iHash2 [ TLSH_CHECKSUM_LEN + 1 ] >> 4 , RANGE_QRATIO ) ; if ( q2diff <= 1 ) diff += q2diff ; else diff += ( q2diff - 1 ) * 12 ; for ( int k = 0 ; k < TLSH_CHECKSUM_LEN ; k ++ ) { if ( iHash1 [ k ] != iHash2 [ k ] ) { diff ++ ; break ; } } diff += hDistance ( Arrays . copyOfRange ( iHash1 , TLSH_CHECKSUM_LEN + 2 , iHash1 . length ) , Arrays . copyOfRange ( iHash2 , TLSH_CHECKSUM_LEN + 2 , iHash2 . length ) ) ; return diff ; }
te	3	public static void triangle3 ( String s ) { char c [ ] = s . toCharArray ( ) ; for ( int i = 0 ; i < c . length ; i ++ ) { System . out . println ( ) ; for ( int j = 0 ; j < c . length ; j ++ ) { if ( i < j ) { System . out . print ( " " ) ; } else { System . out . print ( c [ j ] ) ; } } } }
te	3	protected Field findFieldWithValue ( Object fieldValue ) { for ( Field f : this . sampleDeclaredFields ) { try { if ( f . get ( this . sample ) . equals ( fieldValue ) ) return f ; } catch ( IllegalAccessException e ) { System . out . println ( "findFieldWithValue cannot access the field " + f . getName ( ) + " of the class " + this . sampleClass . getName ( ) + "\n   message: " + e . getMessage ( ) ) ; } } return null ; }
te	2	@ Override public synchronized void onDartMissedPressed ( ) { for ( GameStatusUpdateListener g : listeners ) { try { g . onDartMissedPressed ( ) ; } catch ( RuntimeException e ) { logger . warn ( e . getMessage ( ) , e ) ; } } }
te	6	@ Override public void update ( ) { if ( KeyBinding . isDown ( Bindings . exit ) ) { MainGame . gotoGui ( Guis . mainMenu ) ; } byte speed = 1 ; if ( KeyBinding . isDown ( Bindings . speed ) ) { speed ++ ; } if ( KeyBinding . isDown ( Bindings . moveUp ) ) { MainGame . moveOffsets ( ( short ) 0 , ( short ) ( - speed ) ) ; } if ( KeyBinding . isDown ( Bindings . moveDown ) ) { MainGame . moveOffsets ( ( short ) 0 , speed ) ; } if ( KeyBinding . isDown ( Bindings . moveLeft ) ) { MainGame . moveOffsets ( ( short ) - speed , ( short ) 0 ) ; } if ( KeyBinding . isDown ( Bindings . moveRight ) ) { MainGame . moveOffsets ( speed , ( short ) 0 ) ; } }
te	1	private Box drawButtonBestScores ( ) { KulButton ok1 = new KulButton ( "Ok" ) ; ok1 . setPreferredSize ( new Dimension ( 125 , 40 ) ) ; ok1 . setMaximumSize ( new Dimension ( 125 , 40 ) ) ; ok1 . setForeground ( Color . WHITE ) ; ok1 . setFont ( f . deriveFont ( 26f ) ) ; Box buttonBox = new Box ( BoxLayout . X_AXIS ) ; buttonBox . add ( Box . createHorizontalGlue ( ) ) ; buttonBox . add ( ok1 ) ; buttonBox . add ( Box . createHorizontalGlue ( ) ) ; ok1 . addMouseListener ( new MouseAdapter ( ) { @ Override public void mouseClicked ( MouseEvent e ) { if ( SwingUtilities . isLeftMouseButton ( e ) ) { slideUp ( ) ; } } } ) ; return buttonBox ; }
te	5	public void updateActive ( ) { activeCommands [ REVIVE ] = inputCommands [ REVIVE ] ; if ( isAlive ( ) ) { activeCommands [ MOVE_FORWARD ] = inputCommands [ MOVE_FORWARD ] && ! inputCommands [ MOVE_BACKWARD ] ; activeCommands [ MOVE_BACKWARD ] = ! inputCommands [ MOVE_FORWARD ] && inputCommands [ MOVE_BACKWARD ] ; activeCommands [ TURN_CLOCKWISE ] = inputCommands [ TURN_CLOCKWISE ] && ! inputCommands [ TURN_ANTICLOCKWISE ] ; activeCommands [ TURN_ANTICLOCKWISE ] = ! inputCommands [ TURN_CLOCKWISE ] && inputCommands [ TURN_ANTICLOCKWISE ] ; activeCommands [ FIRE_BULLET ] = inputCommands [ FIRE_BULLET ] ; activeCommands [ KILL ] = inputCommands [ KILL ] ; } else { activeCommands [ KILL ] = false ; activeCommands [ MOVE_FORWARD ] = false ; activeCommands [ MOVE_BACKWARD ] = false ; activeCommands [ TURN_CLOCKWISE ] = false ; activeCommands [ TURN_ANTICLOCKWISE ] = false ; activeCommands [ FIRE_BULLET ] = false ; } return ; }
te	8	private void draw ( Graphics g ) { g . setColor ( this . getBackground ( ) ) ; g . fillRect ( 0 , 0 , Game . GAME_WIDTH , Game . GAME_HEIGHT ) ; if ( ( this . oldBackgroundElems != Game . staticBackground . size ( ) ) || ( Game . background == null ) ) { Game . background = new BufferedImage ( Game . GAME_WIDTH , Game . GAME_HEIGHT , BufferedImage . TYPE_INT_ARGB ) ; for ( Entity e : Game . staticBackground ) { e . draw ( Game . background . getGraphics ( ) ) ; } this . oldBackgroundElems = Game . staticBackground . size ( ) ; } g . drawImage ( Game . background , 0 , 0 , null ) ; for ( Entity e : Game . entities ) { if ( ( e instanceof Player ) == false ) { if ( e . removed == false ) { e . draw ( g ) ; } } } for ( int i = 0 ; i < Game . players . size ( ) ; i ++ ) { Game . players . get ( i ) . draw ( g ) ; } g . setColor ( Color . WHITE ) ; for ( int i = 0 ; i < Game . players . size ( ) ; i ++ ) { Player drawPoints = ( Player ) Game . players . get ( i ) ; g . drawString ( "Spieler " + ( i + 1 ) + ":" + drawPoints . pm . getPoints ( ) , 100 * ( i + 1 ) , 10 ) ; } g . drawString ( "FPS: " + this . fps_static , 0 , 10 ) ; }
te	5	private int [ ] [ ] getSetInfo ( ) { if ( cdata == null ) return null ; int numMatches = cdata . getNumMatches ( ) ; int numSets = 0 ; Vector prevTitles = new Vector ( ) ; Vector firstMatches = new Vector ( ) ; Vector lastMatches = new Vector ( ) ; boolean firstMatch = true ; for ( int i = 0 ; i < numMatches ; i ++ ) { Vector columns = cdata . getColumnData ( i ) ; Vector titles = getTitles ( columns ) ; if ( ! titles . equals ( prevTitles ) ) { firstMatches . add ( new Integer ( i ) ) ; if ( ! firstMatch ) lastMatches . add ( new Integer ( i ) ) ; firstMatch = false ; numSets ++ ; } prevTitles = titles ; } lastMatches . add ( new Integer ( numMatches ) ) ; int [ ] [ ] setInfo = new int [ numSets ] [ 2 ] ; for ( int i = 0 ; i < setInfo . length ; i ++ ) { setInfo [ i ] [ 0 ] = ( ( Integer ) firstMatches . get ( i ) ) . intValue ( ) ; setInfo [ i ] [ 1 ] = ( ( Integer ) lastMatches . get ( i ) ) . intValue ( ) ; } return setInfo ; }
te	6	public Hashtable < String , List < String >> getPropertyNamesAndValues ( String text ) throws MalformedURLException , IOException { Hashtable < String , List < String >> ret = new Hashtable < String , List < String >> ( ) ; String licenseID = System . getenv ( "OPEN_CALAIS_KEY" ) ; if ( licenseID == null || licenseID . length ( ) < 5 ) { System . out . println ( "Error: must have environment variable OPEN_CALAIS_KEY set" ) ; System . exit ( 1 ) ; } String result = "" ; try { String content = text ; System . out . println ( "\n\n****** content sent to Open Calais:\n\n" + content + "\n\n" ) ; String paramsXML = "<c:params xmlns:c=\"http://s.opencalais.com/1/pred/\" xmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\"><c:processingDirectives c:contentType=\"text/txt\" c:outputFormat=\"xml/rdf\"></c:processingDirectives><c:userDirectives c:allowDistribution=\"true\" c:allowSearch=\"true\" c:externalID=\"17cabs901\" c:submitter=\"ABC\"></c:userDirectives><c:externalMetadata></c:externalMetadata></c:params>" ; StringBuilder sb = new StringBuilder ( content . length ( ) + 512 ) ; sb . append ( "licenseID=" ) . append ( licenseID ) ; sb . append ( "&content=" ) . append ( content ) ; sb . append ( "&paramsXML=" ) . append ( paramsXML ) ; String payload = sb . toString ( ) ; URLConnection connection = new URL ( "http://api.opencalais.com/enlighten/calais.asmx/Enlighten" ) . openConnection ( ) ; connection . addRequestProperty ( "Content-Type" , "application/x-www-form-urlencoded" ) ; connection . addRequestProperty ( "Content-Length" , String . valueOf ( payload . length ( ) ) ) ; connection . setDoOutput ( true ) ; OutputStream out = connection . getOutputStream ( ) ; OutputStreamWriter writer = new OutputStreamWriter ( out ) ; writer . write ( payload ) ; writer . flush ( ) ; result = new Scanner ( connection . getInputStream ( ) ) . useDelimiter ( "\\Z" ) . next ( ) ; result = result . replaceAll ( "&lt;" , "<" ) . replaceAll ( "&gt;" , ">" ) ; int index1 = result . indexOf ( "terms of service.-->" ) ; index1 = result . indexOf ( "<!--" , index1 ) ; int index2 = result . indexOf ( "-->" , index1 ) ; result = result . substring ( index1 + 4 , index2 - 1 + 1 ) ; String [ ] lines = result . split ( "\\n" ) ; for ( String line : lines ) { int index = line . indexOf ( ":" ) ; if ( index > - 1 ) { String relation = line . substring ( 0 , index ) . trim ( ) ; String [ ] entities = line . substring ( index + 1 ) . trim ( ) . split ( " " ) ; for ( int i = 0 , size = entities . length ; i < size ; i ++ ) { entities [ i ] = entities [ i ] . trim ( ) ; } ret . put ( relation , Arrays . asList ( entities ) ) ; } } } catch ( Exception ex ) { System . err . println ( "\nERROR USING OPEN CALAIS: " + ex + "\nresult string: " + result + "\n" ) ; ex . printStackTrace ( ) ; } return ret ; }
te	1	public static Paquet createPaquetFromBuffer ( SocketChannel socket ) throws IOException { String [ ] t = new String [ 1 ] ; t [ 0 ] = Message . END_ENVOI ; String msg = "" ; msg = Utilitaires . getAFullMessage ( t , socket ) ; Scanner scan = new Scanner ( msg ) ; int id = scan . nextInt ( ) ; String IpAdresse = scan . next ( ) ; int port = scan . nextInt ( ) ; Machine owner = new Machine ( IpAdresse , port ) ; ArrayList < Machine > hosts = new ArrayList < Machine > ( Global . NOMBRESOUSPAQUETS ) ; for ( int i = 0 ; i < Global . NOMBRESOUSPAQUETS ; i ++ ) { String ip = scan . next ( ) ; int p = scan . nextInt ( ) ; hosts . add ( i , new Machine ( ip , p ) ) ; } Paquet paq = new Paquet ( id , owner ) ; paq . putOtherHosts ( hosts ) ; scan . close ( ) ; return paq ; }
te	1	@ Override Land getLandUnit ( class < ? extends Land > clazz ) { return null ; }
te	2	public List < Solution > getSolutionsByStudent ( final Student student ) { final List < Solution > solutions = new ArrayList < Solution > ( ) ; for ( final Task task : tasks ) { final Option < Solution > solution = task . findSolution ( student ) ; if ( solution . isDefined ( ) ) { solutions . add ( solution . get ( ) ) ; } } return solutions ; }
te	6	@ Override public Staff find ( int id ) { Staff found = null ; PreparedStatement pst = null ; ResultSet rs = null ; try { pst = this . connect ( ) . prepareStatement ( "select * from Staff where id= ?" ) ; pst . setInt ( 1 , id ) ; rs = pst . executeQuery ( ) ; System . out . println ( "recherche individuelle r\u00E9ussie" ) ; if ( rs . next ( ) ) { found = new Staff ( rs . getInt ( "id" ) , rs . getString ( "fonction" ) , rs . getString ( "nom" ) , rs . getString ( "prenom" ) , rs . getInt ( "age" ) ) ; } } catch ( SQLException ex ) { Logger . getLogger ( StaffDao . class . getName ( ) ) . log ( Level . SEVERE , "recherche individuelle echou\u00E9" , ex ) ; } finally { try { if ( rs != null ) rs . close ( ) ; } catch ( SQLException ex ) { Logger . getLogger ( StaffDao . class . getName ( ) ) . log ( Level . SEVERE , "liberation result set echou\u00E9" , ex ) ; } try { if ( pst != null ) pst . close ( ) ; } catch ( SQLException ex ) { Logger . getLogger ( StaffDao . class . getName ( ) ) . log ( Level . SEVERE , "liberation prepared statement echou\u00E9" , ex ) ; } } return found ; }
te	6	private void readValues ( Stream stream ) { anInt406 = stream . readUnsignedWord ( ) ; anInt405 = stream . readUnsignedWord ( ) ; if ( Animation . anims != null && anInt406 != 65535 && anInt406 != - 1 ) aAnimation_407 = Animation . anims [ anInt406 ] ; anInt410 = stream . readUnsignedByte ( ) ; anInt411 = stream . readUnsignedByte ( ) ; int j = stream . readUnsignedWord ( ) ; if ( j != 65535 ) { for ( int k = 0 ; k < j ; k ++ ) anIntArray409 [ k ] = stream . readUnsignedWord ( ) ; for ( int k = 0 ; k < j ; k ++ ) anIntArray408 [ k ] = stream . readUnsignedWord ( ) ; } }
te	7	@ Override public void rightMultiply ( IMatrix other ) { for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) copy [ i ] [ j ] = 0 ; for ( int i = 0 ; i < 4 ; i ++ ) { for ( int j = 0 ; j < 4 ; j ++ ) { for ( int k = 0 ; k < 4 ; k ++ ) { copy [ i ] [ j ] = copy [ i ] [ j ] + this . get ( k , i ) * other . get ( j , k ) ; } } } for ( int i = 0 ; i < 4 ; i ++ ) { for ( int j = 0 ; j < 4 ; j ++ ) { this . set ( j , i , copy [ i ] [ j ] ) ; } } }
te	8	public int maximalRectangle ( char [ ] [ ] matrix ) { int m = matrix . length ; if ( m == 0 ) return 0 ; int n = matrix [ 0 ] . length ; if ( n == 0 ) return 0 ; int [ ] [ ] h = new int [ m ] [ n ] ; int [ ] [ ] v = new int [ m ] [ n ] ; int result = 0 ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( matrix [ i ] [ j ] == 1 ) { h [ i ] [ j ] = ( j > 0 ) ? h [ i ] [ j - 1 ] + 1 : 1 ; v [ i ] [ j ] = ( i > 0 ) ? v [ i - 1 ] [ j ] + 1 : 1 ; } int minHeight = Integer . MAX_VALUE ; for ( int jj = j ; j - jj + 1 <= h [ i ] [ j ] ; jj -- ) { minHeight = Math . min ( minHeight , v [ i ] [ jj ] ) ; result = Math . max ( result , minHeight * ( j - jj + 1 ) ) ; } } } return result ; }
te	4	public int getTile ( int x , int y ) { if ( x < 0 ) return - 1 ; if ( y < 0 ) return - 1 ; if ( x > getWidth ( ) - 1 ) return - 1 ; if ( y > getHeight ( ) - 1 ) return - 1 ; return tiles . getElement ( y , x ) ; }
te	0	public static List < ResponseSubsystem > getDefaultSubsystems ( String root , int port ) { List < ResponseSubsystem > subsystems = new ArrayList < ResponseSubsystem > ( ) ; subsystems . add ( new FormRequestSubsystem ( ) ) ; subsystems . add ( new PingSubsystem ( ) ) ; subsystems . add ( new FileServerSubsystem ( new FileBrowserImpl ( root ) , port ) ) ; return subsystems ; }
te	6	public static void removeDuplicateChars ( char [ ] string ) { for ( int i = 0 ; i < string . length - 1 ; i ++ ) { if ( string [ i ] ==   ) { continue ; } for ( int j = i + 1 ; j < string . length ; j ++ ) { if ( string [ i ] == string [ j ] ) { string [ j ] =   ; } } } for ( int i = 1 ; i < string . length - 1 ; i ++ ) { if ( string [ i ] ==   ) { string [ i ] = string [ i + 1 ] ; string [ i + 1 ] =   ; } } System . out . println ( string ) ; }
te	3	private static boolean sameAttrs ( Set keys , Map attrs1 , Map attrs2 ) { if ( attrs1 != attrs2 ) { for ( Iterator it = keys . iterator ( ) ; it . hasNext ( ) ; ) { Object key = it . next ( ) ; if ( ! same ( attrs1 . get ( key ) , attrs2 . get ( key ) ) ) { return false ; } } } return true ; }
te	8	@ Override public synchronized Message process ( ClientState state , Message request ) { String xmlString ; Model model = Model . getInstance ( ) ; Message response = null ; Node child = request . contents . getFirstChild ( ) ; String myKey = child . getAttributes ( ) . getNamedItem ( "key" ) . getNodeValue ( ) ; if ( ! model . checkKey ( myKey ) ) { xmlString = new String ( Message . responseHeader ( request . id ( ) , "Invalid key" ) + "<forceResponse numberAffected='0'/></response>" ) ; } else if ( child . getAttributes ( ) . getNamedItem ( "id" ) != null ) { String eventID = new String ( child . getAttributes ( ) . getNamedItem ( "id" ) . getNodeValue ( ) ) ; DecisionLineEvent dle = model . getDecisionLineEvent ( eventID ) ; if ( dle == null ) { dle = DatabaseSubsystem . readDecisionLineEvent ( eventID ) ; if ( dle != null ) { model . getDecisionLineEvents ( ) . add ( dle ) ; } } if ( dle != null ) { dle . setType ( EventType . FINISHED ) ; dle . getFinalOrder ( ) ; DatabaseSubsystem . writeDecisionLineEvent ( dle ) ; xmlString = new String ( Message . responseHeader ( request . id ( ) ) + "<forceResponse numberAffected='1'/></response>" ) ; } else { xmlString = new String ( Message . responseHeader ( request . id ( ) , "Invalid Event Id" ) + "<forceResponse numberAffected='0'/></response>" ) ; } } else { int daysOld = new Integer ( child . getAttributes ( ) . getNamedItem ( "daysOld" ) . getNodeValue ( ) ) ; int count = 0 ; Date currentDate = new java . util . Date ( ) ; Date deleteByDate = new java . util . Date ( currentDate . getTime ( ) - 1000 * 3600 * 24 * daysOld ) ; ArrayList < DecisionLineEvent > dles = model . getDecisionLineEvents ( ) ; for ( DecisionLineEvent dle : dles ) { if ( dle . getDate ( ) . before ( deleteByDate ) ) { if ( ! dle . getEventType ( ) . equals ( EventType . FINISHED ) ) { dle . setType ( EventType . FINISHED ) ; dle . getFinalOrder ( ) ; DatabaseSubsystem . writeDecisionLineEvent ( dle ) ; count ++ ; } } } DatabaseSubsystem . finishDLEBasedOnDate ( deleteByDate ) ; xmlString = new String ( Message . responseHeader ( request . id ( ) ) + "<forceResponse numberAffected='" + count + "'/></response>" ) ; } response = new Message ( xmlString ) ; return response ; }
te	6	public BigRational subtract ( BigRational b ) { BigRational a = this ; if ( b . isZero ( ) ) { return this ; } else if ( this . isZero ( ) ) { return b . negate ( ) ; } else if ( this . equals ( b ) ) { return BigRational . ZERO ; } else if ( this . den == b . den ) { return new BigRational ( this . num . subtract ( b . num ) , this . den ) ; } else if ( this . den . equals ( BigInteger . ONE ) ) { return new BigRational ( this . num . multiply ( b . den ) . subtract ( b . num ) , b . den ) ; } else if ( b . den . equals ( BigInteger . ONE ) ) { return new BigRational ( this . num . subtract ( this . den . multiply ( b . num ) ) , this . den ) ; } else { BigInteger numerator = a . num . multiply ( b . den ) . subtract ( b . num . multiply ( a . den ) ) ; BigInteger denominator = a . den . multiply ( b . den ) ; return new BigRational ( numerator , denominator ) ; } }
te	3	public boolean createCRecord ( String badgeId , String firstName , String lastName , String description , String status ) { if ( ! isOfficerAuthorized ( badgeId ) ) { log . error ( badgeId + " is not a authorized user to perform createCRecord" ) ; return false ; } log . debug ( badgeId + " initiated createCRecord" ) ; if ( CriminalStatus . valueOf ( status ) == null ) { log . error ( "Invalid status" ) ; return false ; } if ( hasLastName ( lastName ) ) { newRecordsList ( lastName ) ; final Record record = new CriminalRecord ( newRecordId ( RecordType . CRIMINAL ) , firstName , lastName , description , CriminalStatus . valueOf ( status ) ) ; insertNewRecord ( lastName , record ) ; } else { log . error ( "LastName is required" ) ; return false ; } log . debug ( this . stationType . getStationCode ( ) + ":Successfully created Criminal Record" ) ; System . out . println ( this . stationType . getStationCode ( ) + ":Successfully created Criminal Record" ) ; return true ; }
te	9	private boolean verifyAVL ( AVLNode n ) { if ( n == null ) { return true ; } if ( n . left != null ) { if ( n . right != null ) { if ( heightFactor ( n ) >= 2 || heightFactor ( n ) <= - 2 ) { return false ; } else { return verifyAVL ( ( AVLNode ) n . left ) && verifyAVL ( ( AVLNode ) n . right ) ; } } else { if ( n . height != 1 ) { return false ; } else { return verifyAVL ( ( AVLNode ) n . left ) ; } } } else if ( n . right != null ) { if ( n . height != 1 ) { return false ; } return verifyAVL ( ( AVLNode ) n . right ) ; } return n . height == 0 && n . right == null && n . left == null ; }
te	9	@ Test public void testRun ( ) { comm1 = new Communicator ( comm1PortNumber ) ; comm2 = new Communicator ( comm2PortNumber ) ; toComm1Address = new InetSocketAddress ( "127.0.0.1" , comm1PortNumber ) ; toComm2Address = new InetSocketAddress ( "127.0.0.1" , comm2PortNumber ) ; toComm1Message = new RegisterRequest ( this . playerName ) ; toComm2Message = new RegisterRequest ( this . playerName ) ; toComm1Envelope = Envelope . createOutgoingEnvelope ( toComm1Message , toComm1Address ) ; toComm2Envelope = Envelope . createOutgoingEnvelope ( toComm2Message , toComm2Address ) ; if ( comm1 == null || comm2 == null ) { this . getLogger ( ) . error ( "CommunicatorTest testRun:\n\t a comm is null" ) ; fail ( ) ; } if ( toComm1Envelope == null || toComm2Envelope == null ) { this . getLogger ( ) . error ( "CommunicatorTest testRun:\n\t an envelope is null" ) ; fail ( ) ; } if ( toComm1Envelope . getMessage ( ) == null || toComm2Envelope . getMessage ( ) == null ) { this . getLogger ( ) . error ( "CommunicatorTest testRun:\n\t an envelope's message is null" ) ; fail ( ) ; } comm1 . start ( ) ; comm2 . start ( ) ; comm1 . addToOutputQueue ( toComm2Envelope ) ; comm2 . addToOutputQueue ( toComm1Envelope ) ; try { Thread . sleep ( 500 ) ; } catch ( InterruptedException e ) { this . getLogger ( ) . error ( "CommunicatorTest testRun:\n\t an envelope is null" ) ; System . out . println ( "couldn't sleep" ) ; } Envelope received1 = comm2 . getFromInputQueue ( ) ; Envelope received2 = comm1 . getFromInputQueue ( ) ; if ( received1 == null ) { this . getLogger ( ) . error ( "CommunicatorTest testRun:\n\t comm2 received no message from comm1" ) ; fail ( ) ; } if ( received2 == null ) { this . getLogger ( ) . error ( "CommunicatorTest testRun:\n\t comm1 received no message from comm2" ) ; fail ( ) ; } RegisterRequest request1 = ( RegisterRequest ) received1 . getMessage ( ) ; RegisterRequest request2 = ( RegisterRequest ) received1 . getMessage ( ) ; assertEquals ( request1 . getConversationID ( ) . getProcessID ( ) , request2 . getConversationID ( ) . getProcessID ( ) ) ; assertEquals ( request1 . getConversationID ( ) . getSequenceNumber ( ) , request2 . getConversationID ( ) . getSequenceNumber ( ) ) ; assertEquals ( request1 . getMessageID ( ) . getProcessID ( ) , request2 . getMessageID ( ) . getProcessID ( ) ) ; assertEquals ( request1 . getMessageID ( ) . getSequenceNumber ( ) , request2 . getMessageID ( ) . getSequenceNumber ( ) ) ; assertEquals ( request1 . getRequestType ( ) , request2 . getRequestType ( ) ) ; assertEquals ( request1 . getPlayerName ( ) , request2 . getPlayerName ( ) ) ; }
te	9	public String toNVPString ( String prefix ) throws UnsupportedEncodingException { StringBuilder sb = new StringBuilder ( ) ; if ( this . thirdPartyType != null ) { sb . append ( prefix ) . append ( "thirdPartyType=" ) . append ( NVPUtil . encodeUrl ( this . thirdPartyType ) ) ; sb . append ( "&" ) ; } if ( this . name != null ) { String newPrefix = prefix + "name." ; sb . append ( this . name . toNVPString ( newPrefix ) ) ; } if ( this . dateOfBirth != null ) { sb . append ( prefix ) . append ( "dateOfBirth=" ) . append ( NVPUtil . encodeUrl ( this . dateOfBirth ) ) ; sb . append ( "&" ) ; } if ( this . address != null ) { String newPrefix = prefix + "address." ; sb . append ( this . address . toNVPString ( newPrefix ) ) ; } if ( this . profession != null ) { sb . append ( prefix ) . append ( "profession=" ) . append ( NVPUtil . encodeUrl ( this . profession ) ) ; sb . append ( "&" ) ; } if ( this . relationshipWithThirdParty != null ) { sb . append ( prefix ) . append ( "relationshipWithThirdParty=" ) . append ( NVPUtil . encodeUrl ( this . relationshipWithThirdParty ) ) ; sb . append ( "&" ) ; } if ( this . natureOfBusiness != null ) { sb . append ( prefix ) . append ( "natureOfBusiness=" ) . append ( NVPUtil . encodeUrl ( this . natureOfBusiness ) ) ; sb . append ( "&" ) ; } if ( this . nameOfBusiness != null ) { sb . append ( prefix ) . append ( "nameOfBusiness=" ) . append ( NVPUtil . encodeUrl ( this . nameOfBusiness ) ) ; sb . append ( "&" ) ; } if ( this . businessType != null ) { sb . append ( prefix ) . append ( "businessType=" ) . append ( NVPUtil . encodeUrl ( this . businessType ) ) ; sb . append ( "&" ) ; } if ( this . incorporationId != null ) { sb . append ( prefix ) . append ( "incorporationId=" ) . append ( NVPUtil . encodeUrl ( this . incorporationId ) ) ; sb . append ( "&" ) ; } if ( this . incorporationCountry != null ) { sb . append ( prefix ) . append ( "incorporationCountry=" ) . append ( NVPUtil . encodeUrl ( this . incorporationCountry ) ) ; sb . append ( "&" ) ; } if ( this . incorporationState != null ) { sb . append ( prefix ) . append ( "incorporationState=" ) . append ( NVPUtil . encodeUrl ( this . incorporationState ) ) ; sb . append ( "&" ) ; } return sb . toString ( ) ; }
te	3	public void show ( int messageNumber ) { if ( messageNumber < 0 || messageNumber >= last_error ) show ( "Internal error: unidentified error number" ) ; else { if ( messageNumber == semicolon_expected ) show ( strError [ messageNumber ] , true ) ; else show ( strError [ messageNumber ] , false ) ; } }
te	8	public void remove ( Object inputData ) { ListNode currentNode = this . firstNode ; if ( this . size == 0 ) { return ; } boolean wasDeleted = false ; if ( inputData . equals ( currentNode . getData ( ) ) ) { if ( currentNode . getNext ( ) == null ) { this . firstNode . setData ( null ) ; this . firstNode = new ListNode ( ) ; this . lastNode = this . firstNode ; this . size -- ; return ; } currentNode . setData ( null ) ; currentNode = currentNode . getNext ( ) ; this . firstNode = currentNode ; this . size -- ; return ; } while ( true ) { if ( currentNode == null ) { wasDeleted = false ; break ; } ListNode nextNode = currentNode . getNext ( ) ; if ( nextNode != null ) { if ( inputData . equals ( nextNode . getData ( ) ) ) { ListNode nextNextNode = nextNode . getNext ( ) ; currentNode . setNext ( nextNextNode ) ; nextNode = null ; wasDeleted = true ; break ; } } currentNode = currentNode . getNext ( ) ; } if ( wasDeleted ) { this . size -- ; } }
te	7	@ Override public void load ( PermissionType type , String name ) throws DataLoadFailedException { switch ( type ) { case USER : loadUser ( name ) ; break ; case GROUP : loadGroup ( name ) ; break ; case WORLD : loadWorld ( name ) ; break ; case ENTITY : loadEntity ( name ) ; break ; case OP : loadOp ( ) ; break ; case RCON : loadRcon ( ) ; break ; case CONSOLE : loadConsole ( ) ; break ; } }
te	7	private JSONWriter append ( String string ) throws JSONException { if ( string == null ) { throw new JSONException ( "Null pointer" ) ; } if ( this . mode == o || this . mode == a ) { try { if ( this . , && this . mode == a ) { this . writer . write (   ) ; } this . writer . write ( string ) ; } catch ( IOException e ) { throw new JSONException ( e ) ; } if ( this . mode == o ) { this . mode = k ; } this . , = true ; return this ; } throw new JSONException ( "Value out of sequence." ) ; }
te	5	public static JSONArray toJSONArray ( JSONArray names , JSONTokener x ) throws JSONException { if ( names == null || names . length ( ) == 0 ) { return null ; } JSONArray ja = new JSONArray ( ) ; for ( ; ; ) { JSONObject jo = rowToJSONObject ( names , x ) ; if ( jo == null ) { break ; } ja . put ( jo ) ; } if ( ja . length ( ) == 0 ) { return null ; } return ja ; }
te	4	public void insertarPerfil ( Perfil perfil ) { try { DBConnectionFactory DBC = new DBConnectionFactory ( ) ; DBConnection conn = DBC . createConnection ( ) ; String query = "INSERT INTO " + TABLA_PERFILES + " (Nombre) VALUES (" + "'" + perfil . getNombre ( ) + "')" ; ResultSet rs = conn . executeUpdate ( query , Statement . RETURN_GENERATED_KEYS ) ; if ( perfil . getListaAcciones ( ) != null && rs != null && rs . next ( ) ) { int idPerfil = rs . getInt ( 1 ) ; insertarAccionesPerfil ( idPerfil , perfil . getListaAcciones ( ) ) ; } } catch ( SQLException e ) { e . printStackTrace ( ) ; } }
te	6	private void loadCards ( ) { InputStream xmlStream = this . getClass ( ) . getResourceAsStream ( "cards.xml" ) ; DocumentBuilderFactory dbFactory = DocumentBuilderFactory . newInstance ( ) ; DocumentBuilder dBuilder ; try { dBuilder = dbFactory . newDocumentBuilder ( ) ; } catch ( ParserConfigurationException e ) { e . printStackTrace ( ) ; return ; } Document doc ; try { doc = dBuilder . parse ( xmlStream ) ; } catch ( SAXException e ) { e . printStackTrace ( ) ; return ; } catch ( IOException e ) { e . printStackTrace ( ) ; return ; } Element root = doc . getDocumentElement ( ) ; root . normalize ( ) ; String rootname = root . getNodeName ( ) ; if ( ! rootname . equals ( "cards" ) ) return ; set = root . getAttribute ( "set" ) ; for ( Element e : XMLUtils . getElementListByTagName ( root , "card" ) ) makeCard ( e ) ; for ( Element e : XMLUtils . getElementListByTagName ( root , "cardgroup" ) ) groups . add ( new CardGroup ( e , this ) ) ; }
te	0	public void setNext ( Node nextNode ) { this . nextNode = nextNode ; }
te	4	public JFrame getInstance ( String classe ) { if ( classe . equals ( "produto" ) ) { ProdutoIDE Produto = new ProdutoIDE ( ) ; return Produto ; } else if ( classe . equals ( "estoque" ) ) { EstoqueIDE Estoque = new EstoqueIDE ( ) ; return Estoque ; } else if ( classe . equals ( "prateleira" ) ) { PrateleiraIDE Prateleira = new PrateleiraIDE ( ) ; return Prateleira ; } else if ( classe . equals ( "venda" ) ) { VendaIDE Venda = new VendaIDE ( ) ; return Venda ; } else { MenuPrincipal Menu = new MenuPrincipal ( ) ; return Menu ; } }
te	2	public void act ( List < Actor > newHunters ) { Location newLocation = findAnimal ( ) ; if ( newLocation == null ) { newLocation = getField ( ) . freeAdjacentLocation ( getLocation ( ) ) ; } if ( newLocation != null ) { setLocation ( newLocation ) ; } else { setDead ( ) ; } }
te	9	public static void main ( String [ ] args ) { BinarySearchTree t = new BinarySearchTree ( ) ; final int NUMS = 4000 ; final int GAP = 37 ; System . out . println ( "Checking... (no more output means success)" ) ; for ( int i = GAP ; i != 0 ; i = ( i + GAP ) % NUMS ) t . insert ( new MyInteger ( i ) ) ; for ( int i = 1 ; i < NUMS ; i += 2 ) t . remove ( new MyInteger ( i ) ) ; if ( NUMS < 40 ) t . printTree ( ) ; if ( ( ( MyInteger ) ( t . findMin ( ) ) ) . intValue ( ) != 2 || ( ( MyInteger ) ( t . findMax ( ) ) ) . intValue ( ) != NUMS - 2 ) System . out . println ( "FindMin or FindMax error!" ) ; for ( int i = 2 ; i < NUMS ; i += 2 ) if ( ( ( MyInteger ) ( t . find ( new MyInteger ( i ) ) ) ) . intValue ( ) != i ) System . out . println ( "Find error1!" ) ; for ( int i = 1 ; i < NUMS ; i += 2 ) { if ( t . find ( new MyInteger ( i ) ) != null ) System . out . println ( "Find error2!" ) ; } t . printTree ( t . root ) ; }
