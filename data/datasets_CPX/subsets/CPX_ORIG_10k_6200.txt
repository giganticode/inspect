va	4	private void validateManifest ( Manifest manifest ) { TIPPTaskType taskType = manifest . getTask ( ) . getTaskType ( ) ; for ( TIPPSection section : manifest . getSections ( ) ) { checkSectionForDuplicateSequence ( section ) ; if ( taskType != null && ! ( taskType instanceof CustomTaskType ) && ! taskType . getSupportedSectionTypes ( ) . contains ( section . getType ( ) ) ) { errorHandler . reportError ( TIPPErrorType . INVALID_SECTION_FOR_TASK , "Invalid section for task type: " + section . getType ( ) , null ) ; } } }
va	4	private void scruffPolyline ( Element element ) { StringBuilder modified = new StringBuilder ( ) ; List < Point2D > points = Point2D . parsePoints ( element . getAttribute ( "points" ) ) ; for ( int i = 0 , n = points . size ( ) - 1 ; i < n ; i ++ ) { Point2D pn0Orig = points . get ( i ) ; Point2D pn0 = pn0Orig ; Point2D pn1 = points . get ( i + 1 ) ; double hMax = 0.02 * pn0Orig . lengthTo ( pn1 ) ; modified . append ( pn0 . asString ( ) ) . append (   ) ; double distance ; while ( ( distance = pn0 . lengthTo ( pn1 ) ) > 20 ) { double radius = distance * 0.02 ; if ( radius > 5 ) radius = 5 ; Point2D interm ; do { interm = pn0 . split ( pn1 , distance * random . nextDouble ( ) ) . angularMove ( radius , 2 * Math . PI * random . nextDouble ( ) ) ; } while ( pointToLineDistance ( pn0Orig , pn1 , interm ) > hMax ) ; modified . append ( interm . asString ( ) ) . append (   ) ; pn0 = interm ; } } modified . append ( points . get ( points . size ( ) - 1 ) . asString ( ) ) ; element . setAttribute ( "points" , modified . toString ( ) ) ; }
va	4	public RList ( Collection contents , String [ ] names ) { this ( contents ) ; if ( names != null && names . length > 0 ) { this . names = new Vector ( names . length ) ; int i = 0 ; while ( i < names . length ) this . names . add ( names [ i ++ ] ) ; while ( this . names . size ( ) < size ( ) ) this . names . add ( null ) ; } }
va	0	public Wrapper ( ) { sum = Integer . MIN_VALUE ; }
va	9	private void writeValue ( Object value ) throws JSONException { if ( value instanceof Number ) { String string = JSONObject . numberToString ( ( Number ) value ) ; int integer = this . values . find ( string ) ; if ( integer != none ) { write ( 2 , 2 ) ; writeAndTick ( integer , this . values ) ; return ; } if ( value instanceof Integer || value instanceof long ) { long longer = ( ( Number ) value ) . longValue ( ) ; if ( longer >= 0 && longer < int14 ) { write ( 0 , 2 ) ; if ( longer < int4 ) { zero ( ) ; write ( ( int ) longer , 4 ) ; return ; } one ( ) ; if ( longer < int7 ) { zero ( ) ; write ( ( int ) longer , 7 ) ; return ; } one ( ) ; write ( ( int ) longer , 14 ) ; return ; } } write ( 1 , 2 ) ; for ( int i = 0 ; i < string . length ( ) ; i += 1 ) { write ( bcd ( string . charAt ( i ) ) , 4 ) ; } write ( endOfNumber , 4 ) ; this . values . register ( string ) ; } else { write ( 3 , 2 ) ; writeJSON ( value ) ; } }
va	5	@ Override public boolean equals ( Object object ) { if ( ! ( object instanceof Customer ) ) { return false ; } Customer other = ( Customer ) object ; if ( ( this . id == null && other . id != null ) || ( this . id != null && ! this . id . equals ( other . id ) ) ) { return false ; } return true ; }
va	3	public static String dictate ( int token ) { try { String tokenName ; Field [ ] allTokens = ITerminalSymbols . class . getFields ( ) ; for ( int i = 0 ; i < allTokens . length ; i ++ ) { Field aField = allTokens [ i ] ; int fieldValue = ( ( Integer ) aField . get ( null ) ) . intValue ( ) ; if ( token == fieldValue ) { return aField . getName ( ) ; } } } catch ( Exception e ) { e . printStackTrace ( ) ; } return "<NO TOKEN!>" ; }
va	3	public int getPositionFromMove ( int x , int y , int m ) { if ( m < 0 ) { if ( m == Board . MOVE_LEFT ) { return xyToPos ( moveLeft ( x ) , y ) ; } else return xyToPos ( x , moveUp ( y ) ) ; } else { if ( m == Board . MOVE_RIGHT ) { return xyToPos ( moveRight ( x ) , y ) ; } else return xyToPos ( x , moveDown ( y ) ) ; } }
va	7	private void computeColumns ( double width ) { if ( band . getLeftMargin ( ) != null ) { double left = band . getLeftMargin ( ) . getValue ( Unit . PT ) ; columnStart [ 0 ] = left ; width -= left ; } else { columnStart [ 0 ] = 0 ; } if ( band . getRightMargin ( ) != null ) { width -= band . getRightMargin ( ) . getValue ( Unit . PT ) ; } int unsizedCols = 0 ; for ( int i = 0 ; i < band . getColumnCount ( ) ; ++ i ) { Column col = band . getColumn ( i ) ; if ( col . getWidth ( ) != null ) { width -= col . getWidth ( ) . getValue ( Unit . PT ) ; } else { ++ unsizedCols ; } } double unsizedWidth = 0 ; if ( unsizedCols > 0 ) { unsizedWidth = width / unsizedCols ; } for ( int i = 0 ; i < band . getColumnCount ( ) ; ++ i ) { Column col = band . getColumn ( i ) ; double w = col . getWidth ( ) == null ? unsizedWidth : col . getWidth ( ) . getValue ( Unit . PT ) ; columnStart [ i + 1 ] = columnStart [ i ] + w ; } }
va	2	@ Override public void setDouble ( long i , double value ) { if ( ptr != 0 ) { Utilities . UNSAFE . putFloat ( ptr + sizeof * i , ( float ) value ) ; } else { if ( isConstant ( ) ) { throw new IllegalAccessError ( "Constant arrays cannot be modified." ) ; } data [ ( int ) i ] = ( float ) value ; } }
va	0	@ JsonProperty ( "PreLRMSWaitingJobs" ) public void setPreLRMSWaitingJobs ( long PreLRMSWaitingJobs ) { this . PreLRMSWaitingJobs = PreLRMSWaitingJobs ; }
va	8	public Vector < ArrayList < String >> getStrongestPaths ( double threshold ) { Vector < ArrayList < String >> paths = new Vector < ArrayList < String >> ( ) ; srcDij . shortestPaths ( srcGraph , 0 , false ) ; destDij . shortestPaths ( destGraph , 0 , false ) ; ArrayList < IdValuePair > nodeValues = new ArrayList < IdValuePair > ( ) ; double t ; for ( int i = 0 ; i < srcDij . result . size ( ) ; i ++ ) { t = srcDij . result . get ( i ) ; t += destDij . result . get ( i ) ; nodeValues . add ( new IdValuePair ( i , t ) ) ; } Collections . sort ( nodeValues , new Comparator < IdValuePair > ( ) { @ Override public int compare ( IdValuePair o1 , IdValuePair o2 ) { if ( o1 . value < o2 . value ) return - 1 ; else if ( o1 . value > o2 . value ) return 1 ; else return 0 ; } } ) ; ArrayList < Integer > pathToSrc ; ArrayList < Integer > pathToDst ; ArrayList < String > tempPath ; double min = nodeValues . get ( 1 ) . value ; for ( IdValuePair p : nodeValues ) { if ( p . value - min <= threshold ) { pathToSrc = srcDij . getPath ( p . id ) ; pathToDst = destDij . getPath ( p . id ) ; tempPath = new ArrayList < String > ( ) ; for ( int i = 0 ; i < pathToSrc . size ( ) ; i ++ ) { tempPath . add ( pathToSrc . get ( i ) . toString ( ) ) ; } pathToDst . remove ( pathToDst . size ( ) - 1 ) ; if ( pathToDst . size ( ) >= 1 ) { pathToDst . remove ( 0 ) ; Collections . reverse ( pathToDst ) ; for ( int i = 0 ; i < pathToDst . size ( ) ; i ++ ) { tempPath . add ( pathToDst . get ( i ) . toString ( ) ) ; } } paths . add ( tempPath ) ; } } return paths ; }
va	2	public User loadUserByLogin ( String login ) { log . debug ( "Start loadUserByLogin select" ) ; List results = em . createQuery ( "from User where login=?" ) . setParameter ( 1 , login ) . getResultList ( ) ; return results == null || results . isEmpty ( ) ? null : ( User ) results . get ( 0 ) ; }
va	9	public static String toString ( JSONObject jo ) throws JSONException { StringBuffer sb = new StringBuffer ( ) ; Object e ; int i ; JSONArray ja ; String k ; Iterator keys ; int len ; String tagName ; String v ; tagName = jo . optString ( "tagName" ) ; if ( tagName == null ) { return XML . escape ( jo . toString ( ) ) ; } XML . noSpace ( tagName ) ; tagName = XML . escape ( tagName ) ; sb . append ( < ) ; sb . append ( tagName ) ; keys = jo . keys ( ) ; while ( keys . hasNext ( ) ) { k = keys . next ( ) . toString ( ) ; if ( ! k . equals ( "tagName" ) && ! k . equals ( "childNodes" ) ) { XML . noSpace ( k ) ; v = jo . optString ( k ) ; if ( v != null ) { sb . append (   ) ; sb . append ( XML . escape ( k ) ) ; sb . append ( = ) ; sb . append ( " ) ; sb . append ( XML . escape ( v ) ) ; sb . append ( " ) ; } } } ja = jo . optJSONArray ( "childNodes" ) ; if ( ja == null ) { sb . append ( / ) ; sb . append ( > ) ; } else { sb . append ( > ) ; len = ja . length ( ) ; for ( i = 0 ; i < len ; i += 1 ) { e = ja . get ( i ) ; if ( e != null ) { if ( e instanceof String ) { sb . append ( XML . escape ( e . toString ( ) ) ) ; } else if ( e instanceof JSONObject ) { sb . append ( toString ( ( JSONObject ) e ) ) ; } else if ( e instanceof JSONArray ) { sb . append ( toString ( ( JSONArray ) e ) ) ; } } } sb . append ( < ) ; sb . append ( / ) ; sb . append ( tagName ) ; sb . append ( > ) ; } return sb . toString ( ) ; }
va	0	private FingerprintType ( final String strName ) { m_strName = strName ; }
va	0	public void sendMessage ( HttpExchange he , int statusCode , String message ) throws IOException { send ( he , statusCode , message . getBytes ( ) ) ; }
va	7	public void actionPerformed ( ActionEvent ae ) { if ( ! model . isReloading ( ) ) { timer . stop ( ) ; if ( reloadRow != - 1 ) { generateChangeEvent ( reloadRow ) ; } reloadRow = - 1 ; reloadPath = null ; } else { TreePath newPath = model . getPathLoading ( ) ; if ( newPath == null ) { if ( reloadRow != - 1 ) { generateChangeEvent ( reloadRow ) ; } reloadRow = - 1 ; reloadPath = null ; } else { int newRow = treeTable . getTree ( ) . getRowForPath ( newPath ) ; if ( newPath . equals ( reloadPath ) ) { reloadCounter = ( reloadCounter + 1 ) % 8 ; if ( newRow != reloadRow ) { int lastRow = reloadRow ; reloadRow = newRow ; generateChangeEvent ( lastRow ) ; } generateChangeEvent ( reloadRow ) ; } else { int lastRow = reloadRow ; reloadCounter = 0 ; reloadRow = newRow ; reloadPath = newPath ; if ( lastRow != reloadRow ) { generateChangeEvent ( lastRow ) ; } generateChangeEvent ( reloadRow ) ; } } } updateStatusLabel ( ) ; }
va	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( GUIInfoPartidoJugado . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( GUIInfoPartidoJugado . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( GUIInfoPartidoJugado . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( GUIInfoPartidoJugado . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { new GUIInfoPartidoJugado ( ) . setVisible ( true ) ; } } ) ; }
va	6	public static int dehexchar ( char c ) { if ( c >= 0 && c <= 9 ) { return c - 0 ; } if ( c >= A && c <= F ) { return c - ( A - 10 ) ; } if ( c >= a && c <= f ) { return c - ( a - 10 ) ; } return - 1 ; }
va	4	public String toString ( ) { return new StringBuilder ( super . toString ( ) ) . append ( " [" ) . append ( ( this . choked ? "C" : "c" ) ) . append ( ( this . interested ? "I" : "i" ) ) . append ( "|" ) . append ( ( this . choking ? "C" : "c" ) ) . append ( ( this . interesting ? "I" : "i" ) ) . append ( "]" ) . toString ( ) ; }
va	0	@ Test public void testSQuotedAttr ( ) throws ParserConfigurationException , SAXException , IOException { PartRecorder rec = PartRecorder . parse ( "<html hello='you'>" ) ; List < Part > seenParts = rec . getParts ( ) ; List < Part > expectedParts = new ArrayList < Part > ( ) ; expectedParts . add ( new StartDocumentPart ( ) ) ; AttributesImpl attrs = new AttributesImpl ( ) ; attrs . addAttribute ( "" , "" , "hello" , "" , "you" ) ; expectedParts . add ( new StartElementPart ( "html" , attrs ) ) ; expectedParts . add ( new EndDocumentPart ( ) ) ; assertEquals ( expectedParts , seenParts ) ; }
va	6	public boolean getBoolean ( String key ) throws JSONException { Object object = this . get ( key ) ; if ( object . equals ( boolean . false ) || ( object instanceof String && ( ( String ) object ) . equalsIgnoreCase ( "false" ) ) ) { return false ; } else if ( object . equals ( boolean . true ) || ( object instanceof String && ( ( String ) object ) . equalsIgnoreCase ( "true" ) ) ) { return true ; } throw new JSONException ( "JSONObject[" + quote ( key ) + "] is not a Boolean." ) ; }
va	6	private void dfs ( AdjGraph g , int v ) { order [ v ] = lowlink [ v ] = curOrder ++ ; vStack . add ( v ) ; inS [ v ] = true ; for ( Edge e : g . edges [ v ] ) { if ( order [ e . to ] == - 1 ) { dfs ( g , e . to ) ; lowlink [ v ] = Math . min ( lowlink [ v ] , lowlink [ e . to ] ) ; } else if ( inS [ e . to ] ) { lowlink [ v ] = Math . min ( lowlink [ v ] , order [ e . to ] ) ; } } if ( order [ v ] == lowlink [ v ] ) { ArrayList < Integer > cs = new ArrayList < Integer > ( ) ; while ( true ) { int u = vStack . remove ( vStack . size ( ) - 1 ) ; cs . add ( u ) ; inS [ u ] = false ; if ( v == u ) break ; } components . add ( cs ) ; } }
va	5	void addHistoryItem ( Choice choiceHistory , String historyFile , String newItem ) { boolean alreadyInHistory = false ; try { String line = new String ( ) ; BufferedReader history = new BufferedReader ( new FileReader ( historyFile ) ) ; while ( ( line = history . readLine ( ) ) != null ) { if ( line . equals ( newItem ) ) alreadyInHistory = true ; } history . close ( ) ; } catch ( IOException ex ) { System . out . println ( "FNF Error: " + ex ) ; client . log ( "FNF Error: " + ex ) ; } if ( ! alreadyInHistory ) { try { BufferedWriter fw = new BufferedWriter ( new FileWriter ( historyFile , true ) ) ; fw . write ( newItem + "\n" ) ; fw . close ( ) ; choiceHistory . addItem ( newItem ) ; System . out . println ( "History.addItem:" + newItem ) ; client . log ( "History.addItem:" + newItem ) ; } catch ( IOException exe ) { System . out . println ( "FNF Error: " + exe ) ; client . log ( "FNF Error: " + exe ) ; } } }
va	6	@ Override public void keyPressed ( KeyEvent e ) { switch ( e . getKeyCode ( ) ) { case KeyEvent . VK_UP : direction = Direction . N ; break ; case KeyEvent . VK_DOWN : direction = Direction . S ; break ; case KeyEvent . VK_LEFT : direction = Direction . W ; break ; case KeyEvent . VK_RIGHT : direction = Direction . E ; break ; } if ( e . getKeyCode ( ) == KeyEvent . VK_ENTER && lost ) { lost = false ; reset ( ) ; } }
va	5	private Day parseDay ( String day ) { if ( day . contains ( "Monday" ) ) return Day . Monday ; else if ( day . contains ( "Tuesday" ) ) return Day . Tuesday ; else if ( day . contains ( "Wednesday" ) ) return Day . Wednesday ; else if ( day . contains ( "Thursday" ) ) return Day . Thursday ; else if ( day . contains ( "Friday" ) ) return Day . Friday ; else return null ; }
va	2	private void removeFolder ( String filename , boolean store ) { if ( ! folders . containsKey ( filename ) ) return ; LessFolder removed = folders . get ( filename ) ; if ( logger . isDebugEnabled ( ) ) logger . debug ( "Removing LessFolder({}) - store: {}" , filename , store ) ; folders . remove ( filename ) ; eventBus . post ( new RemoveFolderEvent ( removed , store ) ) ; }
va	0	public boolean isDebug ( ) { return debug ; }
va	3	@ Override public int hashCode ( ) { int hash = 7 ; hash = 29 * hash + ( this . type != null ? this . type . hashCode ( ) : 0 ) ; hash = 29 * hash + ( int ) ( this . length ^ ( this . length >>> 32 ) ) ; hash = 29 * hash + ( int ) ( this . sizeof ^ ( this . sizeof >>> 32 ) ) ; hash = 29 * hash + ( this . isConstant ? 1 : 0 ) ; hash = 29 * hash + ( this . parent != null ? this . parent . hashCode ( ) : 0 ) ; hash = 29 * hash + ( int ) ( this . ptr ^ ( this . ptr >>> 32 ) ) ; return hash ; }
va	0	public String getAlbum ( ) { return this . Album ; }
va	6	public static boolean deleteFolderAndcontent ( File dir ) { File [ ] children = dir . listFiles ( ) ; boolean childrenDeleted = true ; for ( int i = 0 ; children != null && i < children . length ; i ++ ) { File child = children [ i ] ; if ( child . isDirectory ( ) ) { childrenDeleted = Misc . deleteFolderAndcontent ( child ) && childrenDeleted ; } if ( child . exists ( ) ) { childrenDeleted = child . delete ( ) && childrenDeleted ; } } dir . delete ( ) ; return childrenDeleted ; }
va	1	private static < E > void mergeSort ( E [ ] array , E [ ] temp , int begin , int end , Comparator < E > comparator ) { if ( begin - end < 0 ) { int middle = ( begin + end ) / 2 ; mergeSort ( array , temp , begin , middle , comparator ) ; mergeSort ( array , temp , middle + 1 , end , comparator ) ; merge ( array , temp , begin , end , comparator ) ; } }
va	3	@ Override public void hud ( ) { if ( model_name != null ) { hud . addInfo ( "Model Name: " + model_name ) ; } hud . draw ( ) ; fontRenderer . write ( new Label ( "Current Tool: " + currentTool . getName ( ) , ( int ) Display . getWidth ( ) / 2 - 45 , Display . getHeight ( ) - 22 , 14.0f , Color . green ) ) ; int length = labels . length ; for ( int i = 0 ; i < length ; i ++ ) { labels [ i ] . draw ( ) ; } length = sliders . length ; GLLoader . enterOrtho ( ) ; for ( int i = 0 ; i < length ; i ++ ) { sliders [ i ] . draw ( ) ; } cs . draw ( ) ; swatches . draw ( ) ; tbox . draw ( ) ; GLLoader . exitOrtho ( ) ; fontRenderer . tick ( ) ; }
va	4	public Collection reviewReservations ( ) { Connection conn = null ; Collection reservations = null ; try { String query = "select first_name  last_name  num_adults  num_child  num_days " + "from park_reservation" ; DataSource ds = ( DataSource ) new InitialContext ( ) . lookup ( "jdbc/acmeworld" ) ; conn = ds . getConnection ( ) ; PreparedStatement stmt = conn . prepareStatement ( query ) ; ResultSet rs = stmt . executeQuery ( ) ; int resNumber = 1 ; while ( rs . next ( ) ) { String firstName = rs . getString ( "first_name" ) ; String lastName = rs . getString ( "last_name" ) ; int numAdults = rs . getInt ( "num_adults" ) ; int numChild = rs . getInt ( "num_child" ) ; int numDays = rs . getInt ( "num_days" ) ; System . out . println ( "Reservation: " + resNumber ) ; System . out . println ( firstName + " " + lastName + " - Adults: " + numAdults + " Children: " + numChild + " Days: " + numDays ) ; resNumber ++ ; } } catch ( SQLException | NamingException ex ) { System . out . println ( "Exception: " + ex ) ; } finally { if ( conn != null ) { try { conn . close ( ) ; } catch ( SQLException ex ) { Logger . getLogger ( ReservationAlerter . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } } } return reservations ; }
va	9	public static boolean [ ] solve2Sat ( List < Integer > [ ] graph ) { int n = graph . length ; boolean [ ] used = new boolean [ n ] ; List < Integer > order = new ArrayList < > ( ) ; for ( int i = 0 ; i < n ; ++ i ) { if ( ! used [ i ] ) { dfs1 ( graph , used , order , i ) ; } } List < Integer > [ ] reverseGraph = new List [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { reverseGraph [ i ] = new ArrayList < > ( ) ; } for ( int i = 0 ; i < n ; i ++ ) { for ( int j : graph [ i ] ) { reverseGraph [ j ] . add ( i ) ; } } int [ ] comp = new int [ n ] ; Arrays . fill ( comp , - 1 ) ; for ( int i = 0 , color = 0 ; i < n ; ++ i ) { int u = order . get ( n - i - 1 ) ; if ( comp [ u ] == - 1 ) { dfs2 ( reverseGraph , comp , u , color ++ ) ; } } for ( int i = 0 ; i < n ; ++ i ) { if ( comp [ i ] == comp [ i ^ 1 ] ) { return null ; } } boolean [ ] res = new boolean [ n / 2 ] ; for ( int i = 0 ; i < n ; i += 2 ) { res [ i / 2 ] = comp [ i ] > comp [ i ^ 1 ] ; } return res ; }
va	8	private void composeDemos ( Index index , ClassLoader cl ) throws ClassNotFoundException , NoSuchMethodException , SecurityException { List < AnnotationInstance > demoAnnoInstances = index . getAnnotations ( DotName . createSimple ( org . jboss . demos . Demo . class . getName ( ) ) ) ; for ( AnnotationInstance ai : demoAnnoInstances ) { AnnotationTarget target = ai . target ( ) ; if ( target instanceof MethodInfo ) { MethodInfo m = ( MethodInfo ) target ; String methodName = m . name ( ) ; String declaringClassName = m . declaringClass ( ) . name ( ) . toString ( ) ; List < String > parameterTypes = new ArrayList < String > ( m . args ( ) . length ) ; for ( Type type : m . args ( ) ) { parameterTypes . add ( type . toString ( ) ) ; } class < ? > clazz = cl . loadClass ( declaringClassName ) ; class < ? > [ ] params = new class < ? > [ parameterTypes . size ( ) ] ; int i = 0 ; for ( String paramClazz : parameterTypes ) { params [ i ] = cl . loadClass ( paramClazz ) ; i ++ ; } Method method = clazz . getDeclaredMethod ( methodName , params ) ; org . jboss . demos . Demo demoAnnotation = method . getAnnotation ( org . jboss . demos . Demo . class ) ; Demo demo = new Demo ( ) ; demo . name = demoAnnotation . name ( ) ; demo . desp = demoAnnotation . description ( ) ; demo . method = method ; if ( ! this . demos . contains ( demo ) ) { demos . add ( demo ) ; } } } }
va	4	public Set < String > getNounsRule4 ( String oSent ) { Set < String > nouns = new HashSet < String > ( ) ; String copy = oSent ; String regex = "(.*?)\\s(\\w+)\\s+\\d+(.*)" ; while ( true ) { if ( copy == null ) { break ; } Matcher m = Pattern . compile ( regex ) . matcher ( copy ) ; if ( m . lookingAt ( ) ) { String t = m . group ( 2 ) ; copy = m . group ( 3 ) ; String regex2 = "\\b(" + this . myLearnerUtility . getConstant ( ) . PREPOSITION + "|" + this . myLearnerUtility . getConstant ( ) . STOP + ")\\b" ; if ( ! t . matches ( regex2 ) ) { t = t . toLowerCase ( ) ; nouns . add ( t ) ; } } else { break ; } } return nouns ; }
va	4	private void close ( ) { try { if ( resultSet != null ) { resultSet . close ( ) ; } if ( statement != null ) { statement . close ( ) ; } if ( connect != null ) { connect . close ( ) ; } } catch ( Exception e ) { } }
va	8	@ Override public byte [ ] post ( HttpExchange he ) { if ( ! this . getContext ( ) . getSessionManager ( ) . isAuthorised ( he ) ) { return new byte [ 0 ] ; } String postParams ; try ( InputStreamReader inStream = new InputStreamReader ( he . getRequestBody ( ) ) ) { try ( BufferedReader bufferedReader = new BufferedReader ( inStream ) ) { postParams = bufferedReader . readLine ( ) ; } } catch ( IOException ex ) { Logger . getLogger ( RequestHandler . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; return new byte [ 0 ] ; } Map < String , String > vars = parsePostResponse ( postParams ) ; WebUser wu = this . getContext ( ) . getSessionManager ( ) . getWebUser ( he . getRemoteAddress ( ) . getAddress ( ) ) ; Player player = this . getContext ( ) . getPlugin ( ) . getServer ( ) . getPlayerExact ( wu . getUsername ( ) ) ; String useConsole = vars . get ( "asConsole" ) ; String cmd ; try { cmd = URLDecoder . decode ( vars . get ( "consoleText" ) , "UTF-8" ) ; } catch ( UnsupportedEncodingException ex ) { Logger . getLogger ( RequestHandler . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; return new byte [ 0 ] ; } boolean executeAsConsole = ( useConsole != null && useConsole . equalsIgnoreCase ( "on" ) ) ; if ( ! executeAsConsole ) { if ( player == null ) { this . getContext ( ) . getPlugin ( ) . getLogger ( ) . log ( Level . WARNING , "Player {0} tried to issue a command whilst not logged in!" , wu . getUsername ( ) ) ; return new byte [ 0 ] ; } else { player . chat ( cmd ) ; return "OK" . getBytes ( ) ; } } else { boolean isOperator = ( player != null ) ? player . isOp ( ) : this . getContext ( ) . getConsole ( ) . getServer ( ) . getOfflinePlayer ( wu . getUsername ( ) ) . isOp ( ) ; if ( ! isOperator ) { this . getContext ( ) . getPlugin ( ) . getLogger ( ) . log ( Level . WARNING , "Player {0} tried to issue a command as console without required permission." , wu . getUsername ( ) ) ; return "Attempted console command refused." . getBytes ( ) ; } else { this . getContext ( ) . getPlugin ( ) . getLogger ( ) . log ( Level . INFO , "Player {0} issued command from console: {1}" , new Object [ ] { wu . getUsername ( ) , cmd } ) ; this . getContext ( ) . getPlugin ( ) . getServer ( ) . dispatchCommand ( this . getContext ( ) . getPlugin ( ) . getServer ( ) . getConsoleSender ( ) , cmd ) ; return "OK" . getBytes ( ) ; } } }
va	3	public void updateEnabledState ( ) { if ( activeTextControl != null && ! activeTextControl . isDisposed ( ) ) { setEnabled ( activeTextControl . getSelectionCount ( ) > 0 ) ; return ; } if ( deleteAction != null ) { setEnabled ( deleteAction . isEnabled ( ) ) ; return ; } setEnabled ( false ) ; }
va	4	public void run ( ) { while ( true ) { if ( c == false ) { processmsg . setText ( "" ) ; processmsg . repaint ( ) ; try { Thread . sleep ( 2 ) ; } catch ( InterruptedException ex ) { ex . printStackTrace ( ) ; } break ; } processmsg . setText ( "Processing......" ) ; processmsg . repaint ( ) ; try { Thread . sleep ( 100 ) ; } catch ( InterruptedException ex ) { ex . printStackTrace ( ) ; } } }
va	3	public void sort ( ) { for ( int i = 0 ; i < population . size ( ) - 1 ; i ++ ) { int min = i ; for ( int x = i + 1 ; x < population . size ( ) ; x ++ ) { if ( population . get ( x ) . getFitness ( ) < population . get ( min ) . getFitness ( ) ) { PokemonTeam temp = population . get ( i ) ; population . set ( i , population . get ( x ) ) ; population . set ( x , temp ) ; } } } }
va	4	public static void main ( String [ ] args ) { try { UIManager . setLookAndFeel ( UIManager . getSystemLookAndFeelClassName ( ) ) ; } catch ( ClassNotFoundException e ) { } catch ( InstantiationException e ) { } catch ( IllegalAccessException e ) { } catch ( UnsupportedLookAndFeelException e ) { } javax . swing . SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { ReservarHabitacioController . getInstance ( ) ; } } ) ; }
va	7	private JButton createButton ( ) { JButton but = new JButton ( "     " ) ; but . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { cell . open ( ) ; } } ) ; but . addMouseListener ( new MouseListener ( ) { private boolean pressed = false ; @ Override public void mouseClicked ( MouseEvent e ) { } @ Override public void mousePressed ( MouseEvent e ) { if ( SwingUtilities . isRightMouseButton ( e ) ) { if ( ! cell . mark ( ) ) { marked = false ; button . setIcon ( null ) ; image = null ; } } else { pressed = true ; Action act = factory . createAction ( "CellViewerSelected" ) ; if ( act != null ) act . execute ( ) ; } } @ Override public void mouseReleased ( MouseEvent e ) { pressed = false ; Action act = factory . createAction ( "CellViewerUnselected" ) ; if ( act != null ) act . execute ( ) ; } @ Override public void mouseEntered ( MouseEvent e ) { Action act = null ; if ( pressed ) act = factory . createAction ( "CellViewerSelected" ) ; if ( act != null ) act . execute ( ) ; } @ Override public void mouseExited ( MouseEvent e ) { Action act = factory . createAction ( "CellViewerUnselected" ) ; if ( act != null ) act . execute ( ) ; } } ) ; return but ; }
va	0	@ Override public String toString ( ) { return name ; }
va	1	public void close ( ) { setState ( State . DISCONNECTED ) ; sendQ . clear ( ) ; try { conn . close ( ) ; } catch ( Exception e ) { } }
va	3	private static void testSearch ( ) { ConcurrentHashMap < String , String > map = new ConcurrentHashMap < > ( ) ; map . putIfAbsent ( "foo" , "bar" ) ; map . putIfAbsent ( "han" , "solo" ) ; map . putIfAbsent ( "r2" , "d2" ) ; map . putIfAbsent ( "c3" , "p0" ) ; System . out . println ( "\nsearch()\n" ) ; String result1 = map . search ( 1 , ( key , value ) -> { System . out . println ( Thread . currentThread ( ) . getName ( ) ) ; if ( key . equals ( "foo" ) && value . equals ( "bar" ) ) { return "foobar" ; } return null ; } ) ; System . out . println ( result1 ) ; System . out . println ( "\nsearchValues()\n" ) ; String result2 = map . searchValues ( 1 , value -> { System . out . println ( Thread . currentThread ( ) . getName ( ) ) ; if ( value . length ( ) > 3 ) { return value ; } return null ; } ) ; System . out . println ( result2 ) ; }
va	1	public Glyph find ( int x , int y ) { if ( intersects ( new Point ( x , y ) ) ) { return this ; } else { return null ; } }
va	6	@ Override public boolean isPossible ( ) { if ( actor . getSpirit ( ) < ( actor . getSkill ( skillId ) . getModel ( ) . getSpirit ( ) ) ) { return false ; } if ( actor . getItemInSlot ( ITEM_SLOT_LHAND ) == null ) { return false ; } if ( actor . getItemInSlot ( ITEM_SLOT_RHAND ) . getType ( ) != ITEM_TYPE_INSTRUMENT && actor . getItemInSlot ( ITEM_SLOT_LHAND ) . getType ( ) != ITEM_TYPE_INSTRUMENT ) { return false ; } if ( ! ( dobj instanceof Entity ) && ! ( dobj instanceof Party ) ) { return false ; } return true ; }
va	4	public static class getGenericListClass ( Type type ) { if ( type instanceof class ) { return ( class ) type ; } else if ( type instanceof ParameterizedType ) { Type [ ] typeArgs = ( ( ParameterizedType ) type ) . getActualTypeArguments ( ) ; if ( typeArgs == null || typeArgs . length == 0 ) { throw new RuntimeException ( "Unable to get generic type info (1)." ) ; } return getGenericListClass ( typeArgs [ 0 ] ) ; } throw new RuntimeException ( "Unable to get generic type info (2)." ) ; }
va	0	public String getJarFileName ( ) { return jarFileName ; }
va	8	private void jButton2ActionPerformed ( java . awt . event . ActionEvent evt ) { final String nomb = ( String ) model . getValueAt ( jTable1 . getSelectedRow ( ) , 0 ) ; if ( tipoLista . equals ( LISTA_CLIENTES ) ) { List < Programa > lista = null ; try { String idCli = Factory . getClienteDAO ( ) . getByPK ( nomb ) . getId ( ) . toString ( ) ; lista = NegocioFacade . programasSolicitadosCliente ( idCli ) ; ListaObjetos lo = new ListaObjetos ( getFrame ( ) , true , lista , LISTA_PROGRAMAS_CLIENTE ) ; lo . setVisible ( true ) ; } catch ( NegocioPaooException | DatosPaooException ex ) { mostrarException ( "Programas Solicitados Cliente" , "Ocurrio un problema al obtener los programas" ) ; } } if ( tipoLista . equals ( LISTA_PROGRAMAS_GEN_HTML ) ) { worker . execute ( ) ; Thread t = new Thread ( ) { @ Override public void run ( ) { try { NegocioFacade . generarHTML ( nomb ) ; worker . done ( ) ; JOptionPane . showMessageDialog ( getFrame ( ) , "html generado" , "Finalizo" , 1 ) ; cargarTable ( ) ; } catch ( NegocioPaooException ex ) { mostrarException ( "Generar html" , "Ocurrio un problema al generar html" ) ; } } } ; t . start ( ) ; } if ( tipoLista . equals ( LISTA_PROGRAMAS_GEN_PDF ) ) { worker . execute ( ) ; Thread t = new Thread ( ) { @ Override public void run ( ) { try { NegocioFacade . generarPDF ( nomb ) ; worker . done ( ) ; JOptionPane . showMessageDialog ( getFrame ( ) , "pdf generado" , "Finalizo" , 1 ) ; } catch ( NegocioPaooException ex ) { mostrarException ( "Generar pdf" , "Ocurrio un problema al generar pdf" ) ; } } } ; t . start ( ) ; } if ( tipoLista . equals ( LISTA_PROGRAMAS ) ) { List < Pagina > lista = null ; try { long idProg = Factory . getProgramaDAO ( ) . getByPK ( nomb ) . getId ( ) ; lista = Factory . getProgramaDAO ( ) . getPaginasPrograma ( idProg ) ; ListaObjetos lo = new ListaObjetos ( getFrame ( ) , true , lista , LISTA_PAGINAS ) ; lo . setVisible ( true ) ; } catch ( DatosPaooException ex ) { mostrarException ( "Paginas Programa" , "Ocurrio un problema al obtener las paginas" ) ; } } }
va	7	public static void helper ( List < List < Integer >> results , List < Integer > result , int target , int index , int [ ] num , boolean [ ] visited ) { if ( target == 0 ) { results . add ( new ArrayList < Integer > ( result ) ) ; return ; } if ( index == num . length ) return ; for ( int i = index ; i < num . length ; i ++ ) { if ( i > 0 && num [ i ] == num [ i - 1 ] && ! visited [ i - 1 ] ) { continue ; } else { int cur = num [ i ] ; if ( cur > target ) return ; result . add ( cur ) ; visited [ i ] = true ; helper ( results , result , target - cur , i + 1 , num , visited ) ; visited [ i ] = false ; result . remove ( result . size ( ) - 1 ) ; } } }
va	7	@ Override public void reflect ( State s ) { state = s ; if ( s . gameOver ( ) ) { JFrame f = new JFrame ( ) ; int [ ] players = s . players ( ) ; f . setLayout ( new GridLayout ( 0 , players . length ) ) ; for ( int y = 0 ; y < 3 ; y ++ ) { for ( int handle : players ) { final PlayerState ps = s . playerState ( handle ) ; Component c = null ; switch ( y ) { case 0 : c = new JLabel ( ps . name ) ; break ; case 1 : c = new JLabel ( "" + ps . finalScore ( ) ) ; break ; case 2 : JList l = new JList ( ps . missions . toArray ( ) ) ; l . setCellRenderer ( new ListCellRenderer ( ) { @ Override public Component getListCellRendererComponent ( JList l , Object o , int i , boolean isSelected , boolean hasFocus ) { Mission m = ( Mission ) o ; JLabel c = new JLabel ( m . value + " " + m . source + " - " + m . destination ) ; c . setBackground ( ps . missionCompleted ( m ) ? new java . awt . Color ( 0.5f , 0.5f , 1f ) : new java . awt . Color ( 1f , 0.5f , 0.5f ) ) ; c . setOpaque ( true ) ; return c ; } } ) ; c = l ; break ; } f . add ( c ) ; } } f . setDefaultCloseOperation ( JFrame . DISPOSE_ON_CLOSE ) ; f . pack ( ) ; f . setVisible ( true ) ; } else { players . reflect ( s ) ; decks . reflect ( s ) ; map . reflect ( s ) ; missions . reflect ( s ) ; hand . reflect ( s ) ; } }
va	2	public void setSelectedClasa ( ) { String selected = box_clase . getSelectedItem ( ) . toString ( ) ; for ( Clasa c : Centralizator . getInstance ( ) . getClasa ( ) ) { if ( c . getIdClasa ( ) . equals ( selected ) ) { selectedClasa = c ; break ; } } }
va	9	public String [ ] getForecastTimes ( ) throws Exception { String [ ] times = new String [ 8 ] ; try { layers ++ ; BufferedReader br = new BufferedReader ( new InputStreamReader ( new URL ( MakeURL . hourlyURL ( zip , plusDays ) ) . openStream ( ) ) ) ; int numHours = 0 ; String line = "" ; line = br . readLine ( ) ; int index = 0 ; int i = 0 ; boolean prevLineWasHour = false ; while ( true ) { times [ i ] = "" ; if ( line . contains ( "<th class=\"taC\">" ) ) { prevLineWasHour = true ; index = line . indexOf ( "<th class=\"taC\">" ) + 16 ; while ( Character . isDigit ( line . charAt ( index ) ) ) { times [ i ] = times [ i ] + line . charAt ( index ) ; index ++ ; } i ++ ; if ( i > 7 ) { break ; } } else if ( prevLineWasHour ) { numHours = i ; break ; } else if ( line . contains ( "<h1>There has been an error!</h1>" ) ) { numHours = 0 ; break ; } line = br . readLine ( ) ; } numHours = i ; wundergroundHours = numHours ; String [ ] ret = new String [ numHours ] ; for ( int j = 0 ; j < numHours ; j ++ ) { ret [ j ] = times [ j ] ; } wundergroundTimes = ret ; layers = 0 ; return ret ; } catch ( Exception e ) { if ( layers > 5 ) { return times ; } else { Thread . sleep ( 2000 ) ; return getHourlyForecastTemps ( ) ; } } }
va	1	private Token require ( Token . Kind kind ) throws RequiredTokenException { if ( reader . kind ( ) . equals ( kind ) ) { Token token = reader . token ( ) ; reader . advance ( ) ; return token ; } else throw new RequiredTokenException ( kind , reader . token ( ) ) ; }
va	9	public static State getFromStr ( String name ) { if ( name . equals ( "MOVE_UP" ) ) { return MOVE_UP ; } else if ( name . equals ( "MOVE_DOWN" ) ) { return MOVE_DOWN ; } else if ( name . equals ( "MOVE_LEFT" ) ) { return MOVE_LEFT ; } else if ( name . equals ( "MOVE_RIGHT" ) ) { return MOVE_RIGHT ; } else if ( name . equals ( "PERFORMING_ACTION" ) ) { return PERFORMING_ACTION ; } else if ( name . equals ( "STOPPED_UP" ) ) { return STOPPED_UP ; } else if ( name . equals ( "STOPPED_DOWN" ) ) { return STOPPED_DOWN ; } else if ( name . equals ( "STOPPED_LEFT" ) ) { return STOPPED_LEFT ; } else if ( name . equals ( "STOPPED_RIGHT" ) ) { return STOPPED_RIGHT ; } else if ( name . equals ( "STOPPED" ) ) { return STOPPED ; } else if ( name . equals ( "DEAD" ) ) { return DEAD ; } else if ( name . equals ( "DESTROYED" ) ) { return DESTROYED ; } else if ( name . equals ( "CASTING" ) ) { return CASTING ; } return null ; }
va	5	private static void exportAnimation ( ExportDiagnoser d , Animation animation ) { d . printSection ( animation . getName ( ) ) ; d . printKeyValue ( "DefaultKeyDuration" , "" + animation . getDefaultKeyDuration ( ) ) ; Frame [ ] frames = animation . getFrames ( ) ; for ( int fi = 0 ; fi < frames . length ; fi ++ ) { Frame f = frames [ fi ] ; d . printKeyValue ( "KeyData" + ( fi + 1 ) , f . getName ( ) ) ; if ( f . getKeyDuration ( ) > 0 ) d . printKeyValue ( "KeyDuration" + ( fi + 1 ) , "" + f . getKeyDuration ( ) ) ; } for ( int fi = 0 ; fi < frames . length ; fi ++ ) { Frame f = frames [ fi ] ; Point offset = f . getOffset ( ) ; if ( offset . x != 0 || offset . y != 0 ) { d . printKeyValue ( "KeyEventName" + ( fi + 1 ) , "__" + fi ) ; d . printKeyValue ( "__" + fi , "(" + offset . x + " " + offset . y + " 0)" ) ; } } }
va	0	public Builder age ( int value ) { age = value ; return this ; }
va	3	private static void checkAndAdd ( Board b , ArrayList < Tuple > movesToBlockOrAdd , int xIndex , int yIndex , int weight ) { if ( yIndex != Board . numRows - 1 && b . getGameGridCircle ( xIndex , yIndex + 1 ) . getState ( ) != 0 ) { IntPair location = new IntPair ( xIndex , yIndex ) ; movesToBlockOrAdd . add ( new Tuple ( location , weight ) ) ; } if ( yIndex == Board . numRows - 1 ) { IntPair location = new IntPair ( xIndex , yIndex ) ; movesToBlockOrAdd . add ( new Tuple ( location , weight ) ) ; } }
va	7	public static void main ( String [ ] args ) { final long startTime = System . currentTimeMillis ( ) ; DataCounter < String > counter = null ; if ( args [ 0 ] . equals ( "-b" ) ) { counter = new BinarySearchTree < String > ( new StringComparator ( ) ) ; } else if ( args [ 0 ] . equals ( "-a" ) ) { counter = new AVLTree < String > ( new StringComparator ( ) ) ; } else if ( args [ 0 ] . equals ( "-m" ) ) { counter = new MoveToFrontList < String > ( new StringComparator ( ) ) ; } else if ( args [ 0 ] . equals ( "-h" ) ) { counter = new HashTable < String > ( new StringComparator ( ) , new StringHasher ( ) ) ; } else { System . err . println ( "Must use -b (BinarySearchTree)  -a (AVLTree)  -m (MoveToFrontList)  " + "or -h (HashTable) for argument 1." ) ; System . exit ( 1 ) ; } countWords ( args [ 3 ] , counter ) ; DataCount < String > [ ] counts = getCountsArray ( counter ) ; if ( args . length == 4 ) { if ( args [ 1 ] . matches ( "-k" ) ) { Sorter . topKSort ( counts , new InverseDataComparator ( ) , java . lang . Integer . parseInt ( args [ 2 ] ) ) ; } else if ( args [ 1 ] . equals ( "-hs" ) ) { Sorter . heapSort ( counts , new DataCountStringComparator ( ) ) ; } } else { System . err . println ( "Must use -is (Insertion sort)  -hs (Heap sort)  -os (Other sort) " + " or -k <number> (K-Sort) for argument 2." ) ; System . exit ( 1 ) ; } if ( args [ 1 ] . matches ( "-k" ) ) { } else { } printDataCountk ( counts , java . lang . Integer . parseInt ( args [ 2 ] ) ) ; final long endTime = System . currentTimeMillis ( ) ; System . out . println ( "Total execution time: " + ( endTime - startTime ) ) ; }
va	4	public void setConfiguration ( int index ) throws USBException { long status ; if ( index < 0 || index > descriptor . getNumConfigurations ( ) ) throw new IllegalArgumentException ( ) ; synchronized ( lock ) { if ( ( status = setConfiguration ( fd , index ) ) < 0 ) throw new USBException ( "can't set configuration" , ( int ) - status ) ; if ( selectedConfig != index ) { selectedConfig = index ; currentConfig = null ; } } }
va	1	public String getId ( ) { if ( StringUtils . isNotBlank ( object . optString ( "_id" ) ) ) { return object . optString ( "_id" ) ; } else { return object . optString ( "id" ) ; } }
va	1	public StatesBar ( boolean direction ) { if ( direction ) { this . getImage ( ) . mirrorHorizontally ( ) ; } }
va	3	@ Override public boolean equals ( Object obj ) { if ( obj == null ) { return false ; } if ( getClass ( ) != obj . getClass ( ) ) { return false ; } final Produto other = ( Produto ) obj ; if ( this . estoque != other . estoque ) { return false ; } return true ; }
va	8	public boolean equals ( Object o ) { if ( this == o ) return true ; if ( ! ( o instanceof BinaryRule ) ) return false ; final BinaryRule binaryRule = ( BinaryRule ) o ; if ( leftChild != null ? ! leftChild . equals ( binaryRule . leftChild ) : binaryRule . leftChild != null ) return false ; if ( parent != null ? ! parent . equals ( binaryRule . parent ) : binaryRule . parent != null ) return false ; if ( rightChild != null ? ! rightChild . equals ( binaryRule . rightChild ) : binaryRule . rightChild != null ) return false ; return true ; }
va	2	public BD ( ) throws SQLException { try { class . forName ( "com.mysql.jdbc.Driver" ) ; conexao = DriverManager . getConnection ( "jdbc:mysql://localhost:3306/vendas" , "root" , "" ) ; conexao . setAutoCommit ( false ) ; } catch ( ClassNotFoundException ex ) { Logger . getLogger ( BD . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( SQLException ex ) { Logger . getLogger ( BD . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } }
va	0	public int portNumber ( ) { return this . portNumber ; }
va	9	private void writeRow ( Point point , Integer experiment , Integer year , IterationSubStep justFinishedSubStep ) throws IOException , InterruptedException { row [ 0 ] = Integer . toString ( HPS . get ( ) . getCurrentPointNumber ( ) ) ; row [ 1 ] = Integer . toString ( experiment ) ; row [ 2 ] = Integer . toString ( year ) ; row [ 3 ] = justFinishedSubStep . toString ( ) ; int columnNumber = 4 ; for ( Column column : columns . get ( "" ) ) row [ columnNumber ++ ] = pointValues . get ( column . dynamicValueName ) ; if ( settings . onlyGenotypes ) for ( Entry < String , List < Column >> entry : columns . entrySet ( ) ) { if ( ! entry . getKey ( ) . equals ( "" ) ) { Habitat habitat = point . getNamedHabitats ( ) . get ( entry . getKey ( ) ) ; for ( Column column : entry . getValue ( ) ) row [ columnNumber ++ ] = Integer . toString ( getGenotypeStrength ( habitat , column . genotype ) ) ; } } else for ( Entry < String , List < Column >> entry : columns . entrySet ( ) ) { if ( ! entry . getKey ( ) . equals ( "" ) ) { int sumOfGenotype = 0 ; Habitat habitat = point . getNamedHabitats ( ) . get ( entry . getKey ( ) ) ; for ( Column column : entry . getValue ( ) ) { if ( column . genotype == null ) { IndividualsGroupState groupState = habitat . getGroupsStates ( ) . get ( column . genotypeWithAge ) ; int strength = groupState != null ? groupState . strength : 0 ; row [ columnNumber ++ ] = Integer . toString ( strength ) ; sumOfGenotype += strength ; } else { row [ columnNumber ++ ] = Integer . toString ( sumOfGenotype ) ; sumOfGenotype = 0 ; } } } } currentPointWriter . write ( ( String . join ( ";" , row ) + "\n" ) . getBytes ( ) ) ; }
va	6	private void recalculateCellSize ( int minSize ) { if ( numRows == 0 || numCols == 0 ) { cellSize = 0 ; } else { JViewport vp = getEnclosingViewport ( ) ; Dimension viewableSize = ( vp != null ) ? vp . getSize ( ) : getSize ( ) ; int desiredCellSize = Math . min ( ( viewableSize . height - extraHeight ( ) ) / numRows , ( viewableSize . width - extraWidth ( ) ) / numCols ) - 1 ; cellSize = DEFAULT_CELL_SIZE ; if ( cellSize <= desiredCellSize ) while ( 2 * cellSize <= desiredCellSize ) cellSize *= 2 ; else while ( cellSize / 2 >= Math . max ( desiredCellSize , MIN_CELL_SIZE ) ) cellSize /= 2 ; } revalidate ( ) ; }
va	6	void avoidHills ( ) { if ( moveManager . joinedCircuit ( ) ) return ; if ( app . landscape == null ) return ; Vector3d p_ = p . + ( v ) ; float h = p . z - app . landscape . getHeight ( p . x , p . y ) ; float h_ = p . z - app . landscape . getHeight ( p_ . x , p_ . y ) ; float dh = h_ - h ; if ( h < 0 ) return ; if ( dh < 0 && h < my_turn_radius ) { Vector3d w = v . crossed ( new Vector3d ( 0 , 0 , 1 ) ) . scaleBy ( ds / my_turn_radius ) ; Vector3d p__ = p_ . + ( w ) ; float h__ = p . z - app . landscape . getHeight ( p__ . x , p__ . y ) ; if ( h__ >= h_ ) { makeTurn ( 1 ) ; } else { makeTurn ( - 1 ) ; } } }
va	8	public void update ( ) { if ( isOpen ) { if ( Mouse . clicked ( MouseEvent . BUTTON1 ) || Mouse . clicked ( MouseEvent . BUTTON3 ) ) { int [ ] selected = getSelectedBox ( ) ; if ( selected [ 0 ] != - 1 ) { Item [ ] handled = EntityInventory . handleSlot ( getAt ( selected [ 0 ] , selected [ 1 ] ) , onMouse ) ; setAt ( selected [ 0 ] , selected [ 1 ] , handled [ 0 ] ) ; onMouse = handled [ 1 ] ; } else if ( getSelectedSlot ( ) != null ) { Slot s = getSelectedSlot ( ) ; Item [ ] handled = EntityInventory . handleSlot ( s . getContent ( ) , onMouse ) ; s . setContent ( handled [ 0 ] ) ; onMouse = handled [ 1 ] ; updateCrafting ( ) ; } else if ( outputSlot . getBounds ( ) . contains ( Mouse . getPoint ( ) ) ) { if ( onMouse == null ) { if ( outputSlot . getContent ( ) != null ) { onMouse = outputSlot . getContent ( ) ; clearCraftingAreaFromRecipe ( ) ; } } } } } }
va	2	protected void drawAllGrids ( Graphics g ) { g . setColor ( this . getBackground ( ) ) ; g . fillRect ( 0 , 0 , m_areaSize . width , m_areaSize . height ) ; int verticalBlocSize = m_nGridSideCells * CELL_SIZE + INFRAGRID_SIZE ; int startBloc = m_vScroll / verticalBlocSize ; ListIterator tmpLstIt = m_keysList . listIterator ( m_firstGrid + startBloc ) ; int verticalPos = - m_vScroll % verticalBlocSize + INFRAGRID_SIZE ; int endBloc = m_areaSize . height / verticalBlocSize + 2 ; for ( int i = 0 ; ( i < endBloc ) && ( tmpLstIt . hasNext ( ) ) ; ++ i ) { RBFParams tmpKey = ( RBFParams ) tmpLstIt . next ( ) ; MinimalistMatrix m = ( MinimalistMatrix ) m_ht . get ( tmpKey ) ; this . drawGrid ( g , m , verticalPos ) ; this . drawValues ( g , m , tmpKey , verticalPos , "Bloc: " + ( m_firstGrid + startBloc + i ) ) ; this . drawTitleStrings ( g , tmpKey , verticalPos ) ; verticalPos += verticalBlocSize ; } }
va	0	@ Override public String toCharacter ( ) { return null ; }
va	9	@ Override protected void fillComponentsInEditorPanel ( int rowSelected ) { numberSpinner . setValue ( getValueAt ( rowSelected , 1 ) ) ; timeStartSpinner . setValue ( getTimeValue ( rowSelected , 2 ) ) ; timeEndSpinner . setValue ( getTimeValue ( rowSelected , 3 ) ) ; String day = getValueAt ( rowSelected , 4 ) . toString ( ) ; int index = 0 ; for ( int i = 0 ; i < PairModel . DAY_NAMES . length ; i ++ ) { if ( day . endsWith ( PairModel . DAY_NAMES [ i ] ) ) { index = i ; } } dayComboBox . setSelectedIndex ( index ) ; String week = getValueAt ( rowSelected , 5 ) . toString ( ) ; index = 0 ; for ( int i = 0 ; i < PairModel . WEEK_NAMES . length ; i ++ ) { if ( week . endsWith ( PairModel . WEEK_NAMES [ i ] ) ) { index = i ; } } weekComboBox . setSelectedIndex ( index ) ; String audience = getValueAt ( rowSelected , 6 ) . toString ( ) ; index = 0 ; for ( int i = 0 ; i < audiences . length ; i ++ ) { if ( audience . endsWith ( audiences [ i ] . getFullNumber ( ) ) ) { index = i ; } } audienceComboBox . setSelectedIndex ( index ) ; String subject = getValueAt ( rowSelected , 7 ) . toString ( ) ; index = 0 ; for ( int i = 0 ; i < subjects . length ; i ++ ) { if ( subject . endsWith ( subjects [ i ] . getAbbreviation ( ) ) ) { index = i ; } } subjectComboBox . setSelectedIndex ( index ) ; String professor = getValueAt ( rowSelected , 8 ) . toString ( ) ; index = 0 ; for ( int i = 0 ; i < professors . length ; i ++ ) { if ( professor . endsWith ( professors [ i ] . getName ( ) ) ) { index = i ; } } professorComboBox . setSelectedIndex ( index ) ; String group = getValueAt ( rowSelected , 9 ) . toString ( ) ; index = 0 ; for ( int i = 0 ; i < groups . length ; i ++ ) { if ( group . endsWith ( groups [ i ] . getName ( ) ) ) { index = i ; } } groupComboBox . setSelectedIndex ( index ) ; }
va	9	public static Object stringToValue ( String string ) { if ( string . equals ( "" ) ) { return string ; } if ( string . equalsIgnoreCase ( "true" ) ) { return boolean . true ; } if ( string . equalsIgnoreCase ( "false" ) ) { return boolean . false ; } if ( string . equalsIgnoreCase ( "null" ) ) { return JSONObject . null ; } try { char initial = string . charAt ( 0 ) ; boolean negative = false ; if ( initial == - ) { initial = string . charAt ( 1 ) ; negative = true ; } if ( initial == 0 && string . charAt ( negative ? 2 : 1 ) == 0 ) { return string ; } if ( ( initial >= 0 && initial <= 9 ) ) { if ( string . indexOf ( . ) >= 0 ) { return double . valueOf ( string ) ; } else if ( string . indexOf ( e ) < 0 && string . indexOf ( E ) < 0 ) { long myLong = new long ( string ) ; if ( myLong . longValue ( ) == myLong . intValue ( ) ) { return new Integer ( myLong . intValue ( ) ) ; } else { return myLong ; } } } } catch ( Exception ignore ) { } return string ; }
va	1	@ Override public void doNotify ( ) { Iterator < IWeatherObserver > it = weatherObservers . iterator ( ) ; while ( it . hasNext ( ) ) { IWeatherObserver weatherObserver = it . next ( ) ; weatherObserver . doUpdate ( temperature ) ; } }
va	3	@ Override public boolean rotateLeft ( Token [ ] [ ] tokens , int [ ] [ ] currentTokens , int rotateCount ) { if ( rotateCount % 4 == 1 ) { x0 = currentTokens [ 0 ] [ 0 ] - 2 ; y0 = currentTokens [ 0 ] [ 1 ] ; x1 = currentTokens [ 1 ] [ 0 ] - 1 ; y1 = currentTokens [ 1 ] [ 1 ] + 1 ; x2 = currentTokens [ 2 ] [ 0 ] ; y2 = currentTokens [ 2 ] [ 1 ] ; x3 = currentTokens [ 3 ] [ 0 ] + 1 ; y3 = currentTokens [ 3 ] [ 1 ] - 1 ; } else if ( rotateCount % 4 == 2 ) { x0 = currentTokens [ 0 ] [ 0 ] ; y0 = currentTokens [ 0 ] [ 1 ] - 2 ; x1 = currentTokens [ 1 ] [ 0 ] - 1 ; y1 = currentTokens [ 1 ] [ 1 ] - 1 ; x2 = currentTokens [ 2 ] [ 0 ] ; y2 = currentTokens [ 2 ] [ 1 ] ; x3 = currentTokens [ 3 ] [ 0 ] + 1 ; y3 = currentTokens [ 3 ] [ 1 ] + 1 ; } else if ( rotateCount % 4 == 3 ) { x0 = currentTokens [ 0 ] [ 0 ] + 2 ; y0 = currentTokens [ 0 ] [ 1 ] ; x1 = currentTokens [ 1 ] [ 0 ] + 1 ; y1 = currentTokens [ 1 ] [ 1 ] - 1 ; x2 = currentTokens [ 2 ] [ 0 ] ; y2 = currentTokens [ 2 ] [ 1 ] ; x3 = currentTokens [ 3 ] [ 0 ] - 1 ; y3 = currentTokens [ 3 ] [ 1 ] + 1 ; } else { x0 = currentTokens [ 0 ] [ 0 ] ; y0 = currentTokens [ 0 ] [ 1 ] + 2 ; x1 = currentTokens [ 1 ] [ 0 ] + 1 ; y1 = currentTokens [ 1 ] [ 1 ] + 1 ; x2 = currentTokens [ 2 ] [ 0 ] ; y2 = currentTokens [ 2 ] [ 1 ] ; x3 = currentTokens [ 3 ] [ 0 ] - 1 ; y3 = currentTokens [ 3 ] [ 1 ] - 1 ; } return setCurrentTokens ( currentTokens ) ; }
va	2	public static int convertIndexToBaseBlockIndex ( byte index ) { switch ( index ) { case GOLD : case IRON : return 1 ; default : return index ; } }
va	6	@ Test public void callSync ( ) { final String kHomePath = "/remote_method/sync" ; final String kMethod = "/method" ; final String kUserAccount = "sync_user" ; Directory directory = Directory . Instance ; assert . assertTrue ( directory . createPath ( kHomePath + kMethod ) ) ; try { assert . assertTrue ( directory . addHandler ( kHomePath + kMethod , new MethodHandler ( kMethod , false , null , getClass ( ) . getDeclaredMethod ( "method" , int . class , int . class , double . class , String . class ) ) ) ) ; } catch ( NoSuchMethodException e ) { assert . fail ( e . toString ( ) ) ; } Uri uri = new Uri ( "ws" , kHostname , "/remote_method_test" ) ; WampConnectionTest . TestSender client_sender = new WampConnectionTest . TestSender ( ) ; WampConnectionTest . TestSender server_sender = new WampConnectionTest . TestSender ( ) ; WampConnection client = new WampConnection ( uri , kUserAccount , "" , client_sender ) ; WampConnection server = new WampConnection ( uri , kUserAccount , kHomePath , server_sender ) ; server . welcome ( "test-session-" + kUserAccount ) ; client . process ( server_sender . getOutput ( ) ) ; RemoteMethod < TestBean > remote_method = new RemoteMethod < TestBean > ( client , kMethod , TestBean . class ) ; CallProcessor processor = new CallProcessor ( client , client_sender , server , server_sender ) ; CallThread call_thread = new CallThread ( remote_method , true , 100 , 123 , - 3.14159 , "sync" ) ; processor . start ( ) ; call_thread . start ( ) ; synchronized ( call_thread ) { while ( call_thread . isAlive ( ) ) { try { call_thread . wait ( ) ; } catch ( InterruptedException e ) { } } } synchronized ( processor ) { while ( processor . isAlive ( ) ) { try { processor . wait ( ) ; } catch ( InterruptedException e ) { } } } TestBean result = call_thread . getResult ( ) ; assert . assertNotNull ( result ) ; assertThat ( result . getNumber ( ) , is ( 123 ) ) ; assertThat ( result . getReal ( ) , is ( - 3.14159 ) ) ; assertThat ( result . getText ( ) , is ( "sync" ) ) ; if ( call_thread . getThreadCompletionTimeMillis ( ) < processor . getThreadCompletionTimeMillis ( ) ) { assert . fail ( "Call thread completion time: " + call_thread . getThreadCompletionTimeMillis ( ) + "  Processor thread completion time: " + processor . getThreadCompletionTimeMillis ( ) ) ; } client . close ( ) ; server . close ( ) ; }
va	2	public String toString ( String hdr , String other ) { return hdr + "[" + getType ( type ) + " " + getClazz ( clazz ) + ( unique ? "-unique " : " " ) + name + ( ( other != null ) ? " " + other + "]" : "]" ) ; }
va	4	private void jBEntrarActionPerformed ( java . awt . event . ActionEvent evt ) { String username = jTFUsuario . getText ( ) . trim ( ) ; String password = new String ( jPFSenha . getPassword ( ) ) . trim ( ) ; if ( ! username . isEmpty ( ) ) { if ( ! password . isEmpty ( ) ) { try { ConnectionManager . conecta ( username , password ) ; if ( username . equals ( "coord" ) ) { dispose ( ) ; TelaCoordenador tc = new TelaCoordenador ( ) ; tc . setVisible ( true ) ; } else { dispose ( ) ; TelaTecnico tt = new TelaTecnico ( ) ; tt . setVisible ( true ) ; } } catch ( SQLException ex ) { JOptionPane . showMessageDialog ( null , "Falha na conexao!!!\n" + ex . getMessage ( ) , "Autenticacao do Usuario" , JOptionPane . ERROR_MESSAGE ) ; } } else { JOptionPane . showMessageDialog ( this , "Password nao pode ficar vazia" , "Aviso" , JOptionPane . WARNING_MESSAGE ) ; jPFSenha . setText ( null ) ; jPFSenha . requestFocusInWindow ( ) ; } } else { JOptionPane . showMessageDialog ( this , "Usuario nao pode ficar vazio" , "Aviso" , JOptionPane . WARNING_MESSAGE ) ; jTFUsuario . requestFocusInWindow ( ) ; } }
va	5	public ArrayList < long > getQuestUserList ( long id ) { PreparedStatement statement = null ; ResultSet rs = null ; Connection connection = null ; ArrayList < long > questList = null ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Questionnarios de usuario do questionario: " + id + "..." ) ; } try { if ( logger . isDebugEnabled ( ) ) { logger . debug ( GET_QUEST_USER ) ; } connection = Connector . getConnection ( ) ; statement = connection . prepareStatement ( GET_QUEST_USER ) ; statement . setLong ( 1 , id ) ; rs = statement . executeQuery ( ) ; while ( rs . next ( ) ) { if ( questList == null ) { questList = new ArrayList < long > ( ) ; } questList . add ( rs . getLong ( "quest_user_id" ) ) ; } } catch ( SQLException e ) { logger . error ( e . getMessage ( ) , e ) ; } finally { ResourcesUtil . release ( rs , statement , connection ) ; } return questList ; }
va	9	private void removeInputMappings ( ) { InputManager inputManager = app . getInputManager ( ) ; if ( inputManager . hasMapping ( "Change Vehicle Camera View" ) ) { inputManager . deleteMapping ( "Change Vehicle Camera View" ) ; } if ( inputManager . hasMapping ( "Lefts" ) ) { inputManager . deleteMapping ( "Lefts" ) ; } if ( inputManager . hasMapping ( "Rights" ) ) { inputManager . deleteMapping ( "Rights" ) ; } if ( inputManager . hasMapping ( "Space" ) ) { inputManager . deleteMapping ( "Space" ) ; } if ( inputManager . hasMapping ( "Reset" ) ) { inputManager . deleteMapping ( "Reset" ) ; } if ( inputManager . hasMapping ( "Steer Left" ) ) { inputManager . deleteMapping ( "Steer Left" ) ; } if ( inputManager . hasMapping ( "Steer Right" ) ) { inputManager . deleteMapping ( "Steer Right" ) ; } if ( inputManager . hasMapping ( "Accelerate Vehicle" ) ) { inputManager . deleteMapping ( "Accelerate Vehicle" ) ; } if ( inputManager . hasMapping ( "Brake Vehicle" ) ) { inputManager . deleteMapping ( "Brake Vehicle" ) ; } if ( inputManager . hasMapping ( "Gear Up" ) ) { inputManager . deleteMapping ( "Gear Up" ) ; } if ( inputManager . hasMapping ( "Gear Down" ) ) { inputManager . deleteMapping ( "Gear Down" ) ; } inputManager . removeListener ( this ) ; }
va	9	private static ArrayList < FixedFieldDef > notCoveredBySingles ( ArrayList < FixedFieldDef > defs ) { final ArrayList < FixedFieldDef > r = new ArrayList < FixedFieldDef > ( ) ; final int defsSize = defs . size ( ) ; final BitSet take = new BitSet ( defsSize ) ; final BitSet covered = new BitSet ( ) ; for ( int i = 0 ; i < defsSize ; ++ i ) { final FixedFieldDef di = defs . get ( i ) ; if ( di . r == di . l + 1 ) { if ( ! covered . get ( di . l ) ) { covered . set ( di . l ) ; take . set ( i ) ; } } } for ( int i = 0 ; i < defsSize ; ++ i ) { final FixedFieldDef di = defs . get ( i ) ; if ( di . r > di . l + 1 ) { boolean mis = false ; for ( int j = di . l ; ( ! mis ) && ( j < di . r ) ; ++ j ) { if ( ! covered . get ( j ) ) { mis = true ; } } if ( mis ) { take . set ( i ) ; } } } for ( int i = 0 ; i < defsSize ; ++ i ) { if ( take . get ( i ) ) { final FixedFieldDef di = defs . get ( i ) ; r . add ( di ) ; } } return r ; }
va	9	protected void processRequest ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { HttpSession session = request . getSession ( false ) ; if ( session == null ) { RequestDispatcher rd = request . getRequestDispatcher ( manapp . CAppConsts . LinkLoginPage + ".jsp" ) ; rd . forward ( request , response ) ; return ; } CUserItem myuser = ( CUserItem ) session . getAttribute ( "UserItem" ) ; if ( myuser == null ) { session . invalidate ( ) ; RequestDispatcher rd = request . getRequestDispatcher ( manapp . CAppConsts . LinkLoginPage + ".jsp" ) ; rd . forward ( request , response ) ; return ; } String btntxt = request . getParameter ( "BtnAct" ) ; if ( btntxt != null && btntxt . equals ( "Cancel" ) ) { String tmp = ( String ) session . getAttribute ( "PwChange" ) ; session . removeAttribute ( "PwChange" ) ; if ( tmp != null && CValidUser . PwChangeOptional . equals ( tmp ) ) { session . setAttribute ( "CurrAct" , manapp . CAppConsts . LinkLoginSuccess ) ; RequestDispatcher rd = request . getRequestDispatcher ( manapp . CAppConsts . LinkCentral ) ; rd . forward ( request , response ) ; return ; } else { session . invalidate ( ) ; RequestDispatcher rd = request . getRequestDispatcher ( manapp . CAppConsts . LinkLoginPage + ".jsp" ) ; rd . forward ( request , response ) ; return ; } } if ( btntxt != null && btntxt . equals ( "Save" ) ) { String savemsg = "" ; String oldpass = request . getParameter ( "OldPass" ) ; if ( oldpass == null ) savemsg = "Enter old password.  " ; String newpass = request . getParameter ( "NewPass" ) ; if ( newpass == null ) savemsg = savemsg + "Enter new password.  " ; String confpass = request . getParameter ( "ConfPass" ) ; if ( confpass == null ) savemsg = savemsg + "Confirm new password." ; if ( savemsg . length ( ) > 0 ) { session . setAttribute ( "SaveMsg" , savemsg ) ; session . setAttribute ( "CurrAct" , manapp . CAppConsts . LinkPassChange ) ; RequestDispatcher rd = request . getRequestDispatcher ( manapp . CAppConsts . LinkCentral ) ; rd . forward ( request , response ) ; return ; } ServletContext scontext = this . getServletContext ( ) ; CDbConnMan dbconnman = ( CDbConnMan ) scontext . getAttribute ( "DbConnMan" ) ; Connection conn = dbconnman . getConnection ( ) ; savemsg = CPassWd . savePassWord ( conn , myuser . getUserId ( ) , oldpass , newpass , confpass ) ; dbconnman . returnConnection ( conn ) ; if ( savemsg . length ( ) > 0 ) { session . setAttribute ( "SaveMsg" , savemsg ) ; session . setAttribute ( "CurrAct" , manapp . CAppConsts . LinkPassChange ) ; RequestDispatcher rd = request . getRequestDispatcher ( manapp . CAppConsts . LinkCentral ) ; rd . forward ( request , response ) ; return ; } session . removeAttribute ( "PwChange" ) ; session . setAttribute ( "CurrAct" , manapp . CAppConsts . LinkLoginSuccess ) ; RequestDispatcher rd = request . getRequestDispatcher ( manapp . CAppConsts . LinkCentral ) ; rd . forward ( request , response ) ; return ; } session . removeAttribute ( "DbConn" ) ; session . removeAttribute ( "UserItem" ) ; session . removeAttribute ( "SaveMsg" ) ; session . removeAttribute ( "CurrAct" ) ; session . removeAttribute ( "PwChange" ) ; session . invalidate ( ) ; RequestDispatcher rd = request . getRequestDispatcher ( manapp . CAppConsts . LinkLoginPage + ".jsp" ) ; rd . forward ( request , response ) ; return ; }
va	3	public void action ( ) { DFAgentDescription template = new DFAgentDescription ( ) ; ServiceDescription sd = new ServiceDescription ( ) ; sd . setType ( "order" ) ; template . addServices ( sd ) ; System . out . println ( "------------------------------------" ) ; try { DFAgentDescription [ ] orders = DFService . search ( myAgent , template ) ; System . out . println ( myAgent . getLocalName ( ) + " [searching orders]." ) ; System . out . println ( "Found the following orders:" ) ; activeAgent = new AID [ orders . length ] ; if ( orders . length == 0 ) { System . out . println ( "  > No available orders." ) ; } else { for ( int i = 0 ; i < orders . length ; ++ i ) { activeAgent [ i ] = orders [ i ] . getName ( ) ; System . out . println ( "  > " + activeAgent [ i ] . getName ( ) ) ; } System . out . println ( "------------------------------------\n" ) ; ACLMessage assign = new ACLMessage ( ACLMessage . REQUEST ) ; assign . addReceiver ( orders [ orders . length - 1 ] . getName ( ) ) ; assign . setOntology ( "assignment" ) ; myAgent . send ( assign ) ; System . out . println ( getLocalName ( ) + ": Requested " + orders [ orders . length - 1 ] . getName ( ) . getLocalName ( ) + "." ) ; } } catch ( FIPAException fe ) { System . err . println ( myAgent . getLocalName ( ) + ": Error sending the message." ) ; } }
va	0	public Usuario ( long user_id , String user_nome , String user_sobrenome , String user_cpf , String user_numendereco , String user_login , String user_senha , String user_complemento ) { this . user_id = user_id ; this . user_nome = user_nome ; this . user_sobrenome = user_sobrenome ; this . user_cpf = user_cpf ; this . user_numendereco = user_numendereco ; this . user_login = user_login ; this . user_senha = user_senha ; }
va	6	public int getTileCid ( int xidx , int yidx ) { if ( pf_wrapx ) { xidx = moduloFloor ( xidx , nrtilesx ) ; } else { if ( xidx < 0 || xidx >= nrtilesx ) return out_of_bounds_cid ; } if ( pf_wrapy ) { yidx = moduloFloor ( yidx , nrtilesy ) ; } else { if ( yidx < 0 || yidx >= nrtilesy ) return out_of_bounds_cid ; } return tilecidmap [ xidx ] [ yidx ] ; }
va	7	public void defaultMovements ( ) { time = System . nanoTime ( ) ; dt = ( time - lastTime ) / 1000000000.0f ; lastTime = time ; dx = Mouse . getDX ( ) ; dy = Mouse . getDY ( ) ; camera . yaw ( dx * mouseSensitivity ) ; camera . pitch ( dy * mouseSensitivity ) ; if ( Keyboard . isKeyDown ( Keyboard . KEY_UP ) ) { camera . walkForward ( movementSpeed * dt ) ; } if ( Keyboard . isKeyDown ( Keyboard . KEY_DOWN ) ) { camera . walkBackwards ( movementSpeed * dt ) ; } if ( Keyboard . isKeyDown ( Keyboard . KEY_LEFT ) ) { camera . strafeLeft ( movementSpeed * dt ) ; } if ( Keyboard . isKeyDown ( Keyboard . KEY_RIGHT ) ) { camera . strafeRight ( movementSpeed * dt ) ; } while ( Keyboard . next ( ) ) { if ( Keyboard . getEventKeyState ( ) ) { if ( Keyboard . getEventKey ( ) == Keyboard . KEY_ESCAPE ) { grab = ! grab ; Mouse . setGrabbed ( grab ) ; } } } }
va	8	@ Override public Iterator < K > iterator ( ) { return new Iterator < K > ( ) { private int bucket = 0 ; private Iterator < Element < K , V >> itr = null ; private Iterator < Element < K , V >> previtr = null ; private boolean findNextBucket ( ) { for ( ; bucket < data . length ; bucket ++ ) { if ( data [ bucket ] . size ( ) > 0 ) { itr = data [ bucket ] . iterator ( ) ; return true ; } } itr = null ; return false ; } @ Override public boolean hasNext ( ) { if ( itr != null ) { return itr . hasNext ( ) ; } return findNextBucket ( ) ; } @ Override public K next ( ) { if ( itr == null ) { if ( ! hasNext ( ) ) { return null ; } } Element < K , V > elt = itr . next ( ) ; previtr = itr ; if ( ! itr . hasNext ( ) ) { bucket ++ ; findNextBucket ( ) ; } if ( elt == null ) { return null ; } return elt . getKey ( ) ; } @ Override public void remove ( ) { if ( previtr != null ) { previtr . remove ( ) ; } } } ; }
va	4	public Impresion ( java . awt . Frame parent , boolean modal ) { initComponents ( ) ; tablaMovDefault = ( DefaultTableModel ) tablaGastos . getModel ( ) ; abrirBase ( ) ; LazyList < Categoria > categoriasBase = Categoria . findAll ( ) ; Iterator < Categoria > it = categoriasBase . iterator ( ) ; categorias . addItem ( "Todos" ) ; while ( it . hasNext ( ) ) { Categoria cate = it . next ( ) ; categorias . addItem ( cate . get ( "nombre" ) ) ; } categorias . setSelectedItem ( "Todos" ) ; Calendar cal = Calendar . getInstance ( ) ; Date date = cal . getTime ( ) ; date . setDate ( cal . getActualMinimum ( Calendar . DAY_OF_MONTH ) ) ; ; desde . setDate ( date ) ; Date dateH = cal . getTime ( ) ; dateH . setDate ( cal . getActualMaximum ( Calendar . DAY_OF_MONTH ) ) ; hasta . setDate ( dateH ) ; try { reporte = new ControladorJReport ( ( "contadora.jasper" ) ) ; } catch ( JRException ex ) { Logger . getLogger ( Impresion . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( ClassNotFoundException ex ) { Logger . getLogger ( Impresion . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( SQLException ex ) { Logger . getLogger ( Impresion . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } }
va	8	@ Override public OmahaWorker build ( ) { if ( super . getRounds ( ) <= 0 ) { throw new IllegalStateException ( "The number of rounds must be a strictly positive number" ) ; } else if ( super . getProfiles ( ) == null || super . getProfiles ( ) . size ( ) < 2 ) { throw new IllegalStateException ( "There need to be at least 2 players in every simulation." ) ; } else if ( super . getUpdateInterval ( ) <= 0 || 100 % super . getUpdateInterval ( ) != 0 ) { throw new IllegalStateException ( "Invalid update interval value" ) ; } else if ( super . getNotifiable ( ) == null ) { throw new IllegalStateException ( "There needs to be a notifiable for this worker" ) ; } for ( PlayerProfile profile : super . getProfiles ( ) ) { if ( profile == null ) { throw new NullPointerException ( ) ; } } return new OmahaWorker ( this ) ; }
va	4	public void updateStats ( String userName , int score , boolean winner ) { try { Statement statement = conn . createStatement ( ) ; statement . setQueryTimeout ( 30 ) ; ResultSet res = statement . executeQuery ( "SELECT UserId  Wins  Losses  AverageScore " + "FROM PlayerInfo " + "WHERE UserName = '" + userName + "';" ) ; if ( res . next ( ) ) { int wins = res . getInt ( "Wins" ) , losses = res . getInt ( "Losses" ) ; double oldAvg = res . getInt ( "AverageScore" ) , totalScore = ( wins + losses ) * oldAvg + score ; double newAvg = totalScore / ( wins + losses + 1 ) ; if ( winner ) wins ++ ; else losses ++ ; String update = "UPDATE PlayerInfo SET Wins=" + wins + "  Losses=" + losses + "  AverageScore=" + newAvg + " WHERE UserId = " + res . getInt ( "UserId" ) + ";" ; PreparedStatement ps = conn . prepareStatement ( update ) ; boolean good = ps . execute ( ) ; if ( ! good ) { } } else out . println ( "ERROR: No such user " + userName ) ; } catch ( SQLException sqlEx ) { out . println ( "Got a SQLException 4" ) ; out . println ( sqlEx . getMessage ( ) ) ; } }
va	9	protected static boolean isSuperior ( Method A , Method B ) { class < ? > aReturn = A . getReturnType ( ) ; class < ? > bReturn = B . getReturnType ( ) ; if ( ! aReturn . equals ( bReturn ) ) { if ( aReturn . isAssignableFrom ( bReturn ) ) return false ; if ( bReturn . isAssignableFrom ( aReturn ) ) return true ; } class < ? > aOwner = A . getDeclaringClass ( ) ; class < ? > bOwner = B . getDeclaringClass ( ) ; if ( aOwner . isAssignableFrom ( bOwner ) ) return false ; if ( bOwner . isAssignableFrom ( aOwner ) ) return true ; throw new IllegalArgumentException ( "A  and B are equal!" ) ; }
va	3	@ Override public void onEvent ( EventDispatcher dispatcher , Event event ) { if ( event . getBubble ( ) ) { if ( hasListeners ( ) ) { for ( EventListener listener : listeners ) { listener . onEvent ( dispatcher , event ) ; } } } }
va	0	private String decimalAsString ( String decimal ) { return decimal . substring ( decimal . indexOf ( . ) + 1 ) ; }
va	1	public static Piece [ ] getPieces ( ) { if ( pieces == null ) { pieces = new Piece [ ] { pieceRow ( new Piece ( parsePoints ( "0 0\t0 1\t0 2\t0 3" ) ) ) , pieceRow ( new Piece ( parsePoints ( "0 0\t0 1\t0 2\t1 0" ) ) ) , pieceRow ( new Piece ( parsePoints ( "0 0\t1 0\t1 1\t1 2" ) ) ) , pieceRow ( new Piece ( parsePoints ( "0 0\t1 0\t1 1\t2 1" ) ) ) , pieceRow ( new Piece ( parsePoints ( "0 1\t1 1\t1 0\t2 0" ) ) ) , pieceRow ( new Piece ( parsePoints ( "0 0\t0 1\t1 0\t1 1" ) ) ) , pieceRow ( new Piece ( parsePoints ( "0 0\t1 0\t1 1\t2 0" ) ) ) , } ; } return ( pieces ) ; }
va	0	public String getUrl ( ) { return url ; }
