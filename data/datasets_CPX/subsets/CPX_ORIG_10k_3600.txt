tr	8	public static void main ( String args [ ] ) { int op = 0 ; do { try { System . out . println ( "1- Agregar Cliente" ) ; System . out . println ( "2- Generar Revision" ) ; System . out . println ( "3- Actualizar Monto" ) ; System . out . println ( "4- Historial Cliente" ) ; System . out . println ( "5- Cliente Estrella" ) ; System . out . println ( "6- Backup" ) ; System . out . println ( "7- Salir" ) ; System . out . println ( "Escoja opcion: " ) ; op = lea . nextInt ( ) ; switch ( op ) { case 1 : agregarCliente ( ) ; break ; case 2 : generar ( ) ; break ; case 3 : actualizar ( ) ; break ; case 4 : historial ( ) ; break ; case 5 : estrella ( ) ; break ; case 6 : backup ( ) ; break ; } } catch ( IOException ex ) { System . out . println ( "ERROR: " + ex . getMessage ( ) ) ; } } while ( op != 7 ) ; }
tr	7	public static boolean checkStr ( String str1 , String str2 ) { int i = 0 ; List < Character > uni1 = new ArrayList < Character > ( ) ; List < Character > uni2 = new ArrayList < Character > ( ) ; uni1 . add ( z ) ; uni2 . add ( z ) ; if ( str1 . length ( ) != str2 . length ( ) ) return false ; else { System . out . println ( "im here" ) ; for ( i = 0 ; i < str1 . length ( ) ; i ++ ) { for ( int j = 0 ; j <= uni1 . size ( ) ; j ++ ) { System . out . println ( "uni1 " + uni1 . toString ( ) ) ; if ( uni1 . get ( j ) != str1 . charAt ( i ) ) { System . out . println ( "uni1 at : " + uni1 . get ( j ) ) ; uni1 . add ( ( str1 . charAt ( i ) ) ) ; } } for ( int k = 0 ; k <= uni2 . size ( ) ; k ++ ) { System . out . println ( "uni2 " + uni2 . toString ( ) ) ; if ( uni2 . get ( k ) != str2 . charAt ( i ) ) { System . out . println ( "uni2 at : " + uni2 . get ( k ) ) ; uni2 . add ( ( str2 . charAt ( i ) ) ) ; } } } if ( uni1 . size ( ) != uni2 . size ( ) ) return false ; } return true ; }
tr	8	public Tree parseModule ( ) { if ( ! poll ( kModule ) ) { return expected ( kModule ) ; } final Name name = parseName ( ) ; if ( ! poll ( kLBrace ) ) { return expected ( kLBrace ) ; } if ( ! poll ( kNewLine ) ) { return expected ( kNewLine ) ; } final Module module = init ( new Module ( name ) ) ; final List < Tree > dependencies = module . dependencies ; final List < Tree > declarations = module . declarations ; do { if ( peek ( kRequire ) ) { dependencies . add ( parseModuleDependency ( ) ) ; } else { final Tree declaration = parseDeclarationOpt ( ) ; if ( declaration == null ) { declarations . add ( parseExpression ( ) ) ; } else { declarations . add ( declaration ) ; } } if ( ! poll ( kNewLine ) ) { return expected ( kNewLine ) ; } } while ( ! peek ( kRBrace ) ) ; if ( ! poll ( kRBrace ) ) { return expected ( kRBrace ) ; } return module ; }
tr	5	@ Override public List < Article > findAll ( ) { List < Article > list = new ArrayList < Article > ( ) ; String sql = "SELECT * FROM T_ARTICLE" ; Statement statement = null ; ResultSet resultSet = null ; try { statement = connection . createStatement ( ) ; resultSet = statement . executeQuery ( sql ) ; System . out . println ( sql ) ; while ( resultSet . next ( ) ) { Article found = new Article ( ) ; found . setId ( resultSet . getInt ( "ID" ) ) ; found . setQuantite ( resultSet . getInt ( "quantite" ) ) ; found . setClient ( new ClientDAO ( ) . find ( resultSet . getInt ( "FK_ID_CLIENT" ) ) ) ; found . setStock ( new StockDAO ( ) . find ( resultSet . getInt ( "FK_ID_STOCK" ) ) ) ; list . add ( found ) ; } } catch ( SQLException ex ) { Logger . getLogger ( ArticleDAO . class . getName ( ) ) . log ( Level . SEVERE , "find all articles failed" , ex ) ; } finally { try { if ( resultSet != null ) { resultSet . close ( ) ; } if ( statement != null ) { statement . close ( ) ; } } catch ( SQLException ex ) { Logger . getLogger ( ArticleDAO . class . getName ( ) ) . log ( Level . SEVERE , "free resourses failed" , ex ) ; } } return list ; }
tr	7	@ Override public boolean nextKeyValue ( ) throws IOException , InterruptedException { if ( key == null ) { key = new LongWritable ( ) ; } key . set ( pos ) ; if ( value == null ) { value = new Text ( ) ; } value . clear ( ) ; final Text endline = new Text ( "\n" ) ; int newSize = 0 ; for ( int i = 0 ; i < NLINESTOPROCESS ; i ++ ) { Text v = new Text ( ) ; while ( pos < end ) { newSize = in . readLine ( v , maxLineLength , Math . max ( ( int ) Math . min ( Integer . MAX_VALUE , end - pos ) , maxLineLength ) ) ; value . append ( v . getBytes ( ) , 0 , v . getLength ( ) ) ; value . append ( endline . getBytes ( ) , 0 , endline . getLength ( ) ) ; if ( newSize == 0 ) { break ; } pos += newSize ; if ( newSize < maxLineLength ) { break ; } } } if ( newSize == 0 ) { key = null ; value = null ; return false ; } else { return true ; } }
tr	0	public StatTracker ( int health , int will , int power , int afinity , int clarity ) { super ( ) ; initialiseComponants ( health , will , afinity , power , clarity ) ; update ( ) ; }
tr	0	@ XmlElementDecl ( namespace = "com/firstdata/Merchant/gmfV3.10" , name = "OfferProvName" ) public JAXBElement < String > createOfferProvName ( String value ) { return new JAXBElement < String > ( _OfferProvName_QNAME , String . class , null , value ) ; }
tr	4	public static Value < ? > convertMessageToBencode ( Message msg ) { Objects . requireNonNull ( msg ) ; if ( msg instanceof ErrorMessage ) { return convertErrorMessage ( ( ErrorMessage ) msg ) ; } else if ( msg instanceof QueryMessage ) { return convertQueryMessage ( ( QueryMessage ) msg ) ; } else if ( msg instanceof ResponseMessage ) { return convertResponseMessage ( ( ResponseMessage ) msg ) ; } else { throw new IllegalArgumentException ( ) ; } }
tr	8	private static byte [ ] constructorHelperValues ( byte [ ] values , byte [ ] left , byte [ ] right ) { int llength ; int rlength ; if ( left == null ) { llength = 0 ; } else { llength = left . length ; } if ( right == null ) { rlength = 0 ; } else { rlength = right . length ; } byte value [ ] = new byte [ values . length + llength + rlength ] ; int lefti = 0 ; int righti = 0 ; for ( int i = 0 ; i < value . length ; i ++ ) { if ( i < values . length ) { value [ i ] = values [ i ] ; } if ( i >= values . length && i < ( values . length + llength ) ) { value [ i ] = left [ lefti ] ; lefti ++ ; } if ( i >= ( values . length + llength ) && i < ( values . length + left . length + rlength ) ) { value [ i ] = right [ righti ] ; righti ++ ; } } return value ; }
tr	0	public void setTopicsService ( TopicsService topicsService ) { this . topicsService = topicsService ; }
tr	8	@ Override public void visit ( CannyEvent cannyEvent ) { try { if ( model . getCurrentImagePath ( ) == null || model . getCurrentImagePath ( ) . isEmpty ( ) ) { throw new Exception ( "Brak pliku wej\u015Bciowego!" ) ; } String low_treshold_str = defaultViewChanger . showCannyParametersDialog ( true ) ; float low_treshold = 0.0f ; try { if ( low_treshold_str == null ) throw new NumberFormatException ( ) ; low_treshold = new float ( low_treshold_str ) ; } catch ( NumberFormatException e ) { System . out . println ( "Przyjmuje warto\u015B\u0107 domy\u015Bln\u0105 low_treshold: " + 0.5f ) ; errorDialog . showErrorDialog ( "B\u0142\u0119dnie wpisania warto\u015B\u0107! Przyjmuje warto\u015B\u0107 domy\u015Bln\u0105 low_treshold: " + 0.5f ) ; low_treshold = 0.5f ; } String high_treshold_str = defaultViewChanger . showCannyParametersDialog ( false ) ; float high_treshold = 1.0f ; try { if ( high_treshold_str == null ) throw new NumberFormatException ( ) ; high_treshold = new float ( high_treshold_str ) ; } catch ( NumberFormatException e ) { System . out . println ( "Przyjmuje warto\u015B\u0107 domy\u015Bln\u0105 high_treshold: " + 1.0f ) ; errorDialog . showErrorDialog ( "B\u0142\u0119dnie wpisania warto\u015B\u0107! Przyjmuje warto\u015B\u0107 domy\u015Bln\u0105 high_treshold: " + 1.0f ) ; high_treshold = 1.0f ; } Canny canny = new Canny ( low_treshold , high_treshold ) ; BufferedImage source ; System . out . println ( "Wczytuje plik \u017Ar\u00F3d\u0142owy..." ) ; source = ImageIO . read ( new File ( model . getCurrentImagePath ( ) ) ) ; System . out . println ( "Uruchamiam algorytm..." ) ; BufferedImage canny_image = canny . process ( source ) ; String output_name = "output/canny.png" ; saveImageToFile ( output_name , canny_image ) ; System . out . println ( "Wy\u015Bwietlam zdj\u0119cie..." ) ; defaultViewChanger . showModImage ( output_name ) ; } catch ( Exception e ) { if ( defaultViewChanger != null ) defaultViewChanger . showInformationDialog ( e . getMessage ( ) , "B\u0142\u0105d" , JOptionPane . ERROR_MESSAGE ) ; e . printStackTrace ( ) ; } }
tr	5	public Player getWinner ( ) { if ( getBoard ( ) != null ) { Player [ ] [ ] board = getBoard ( ) . getBoard ( ) ; HashSet < Player > winners = new HashSet < > ( ) ; winners . addAll ( scanRows ( board ) ) ; winners . addAll ( scanColumns ( board ) ) ; winners . addAll ( scanDiagonals ( board ) ) ; if ( winners . size ( ) == 1 ) { return winners . contains ( challenger ) ? challenger : opponent ; } else if ( winners . size ( ) == 2 ) { return opponent . hasToken ( ) ? challenger : opponent ; } else { return null ; } } return null ; }
tr	2	private int getCameraPlaneCutscene ( ) { int terrainDrawHeight = getFloorDrawHeight ( plane , cameraPositionY , cameraPositionX ) ; if ( terrainDrawHeight - cameraPositionZ < 800 && ( tileFlags [ plane ] [ cameraPositionX >> 7 ] [ cameraPositionY >> 7 ] & 4 ) != 0 ) return plane ; else return 3 ; }
tr	1	private static void withGenerics ( ) { GenericContainer < String , Integer > c = new GenericContainer < > ( ) ; c . setInternal ( "str" ) ; String str = c . getInternal ( ) ; System . out . println ( str ) ; if ( c instanceof GenericContainer ) { } String [ ] arr = new String [ 10 ] ; double [ ] arr2 = new double [ 10 ] ; String middle = GenericContainer . getMiddle ( arr ) ; GenericContainer . getMiddle ( arr2 ) ; }
tr	5	public QPixmap fetchMinimap ( String mapName ) { String url ; URLConnection connection ; InputStream response ; ByteArrayOutputStream bb ; byte [ ] bbuf ; int ava ; QPixmap img ; int cnt ; File file ; url = String . format ( "http://zero-k.info/Resources/%s.minimap.jpg" , mapName ) ; try { connection = new URL ( url ) . openConnection ( ) ; connection . setDoOutput ( false ) ; response = connection . getInputStream ( ) ; bb = new ByteArrayOutputStream ( ) ; bbuf = new byte [ 1024 ] ; while ( ( cnt = response . read ( bbuf ) ) > - 1 ) { bb . write ( bbuf , 0 , cnt ) ; } file = new File ( "~/qsl/miniMapCache/" ) ; if ( ! file . exists ( ) ) { file . mkdirs ( ) ; } RandomAccessFile raf ; file = new File ( String . format ( "~/qsl/miniMapCache/%s.jpg" , mapName ) ) ; if ( file . exists ( ) ) { file . delete ( ) ; } bbuf = bb . toByteArray ( ) ; raf = new RandomAccessFile ( file , "rw" ) ; raf . write ( bbuf ) ; raf . close ( ) ; img = new QPixmap ( ) ; img . loadFromData ( bbuf ) ; return img ; } catch ( MalformedURLException ex ) { return null ; } catch ( IOException ex ) { return null ; } }
tr	5	@ Override public void run ( ) { while ( true ) { try { int tempFreeProcesses = 0 ; for ( int i = 0 ; i < this . taskRunnerManager . length ; i ++ ) { if ( taskRunnerManager [ i ] . isReady && ! taskRunnerManager [ i ] . isRunning ) tempFreeProcesses ++ ; } synchronized ( lock ) { freeProcesses = tempFreeProcesses ; } Thread . sleep ( 1000 ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } }
tr	8	public void actionPerformed ( ActionEvent arg0 ) { if ( arg0 . getActionCommand ( ) . equals ( "tower" ) ) clickState = ClickState . tower ; else if ( arg0 . getActionCommand ( ) . equals ( "swamp" ) ) clickState = ClickState . swamp ; else if ( arg0 . getActionCommand ( ) . equals ( "elfrune" ) ) clickState = ClickState . elf ; else if ( arg0 . getActionCommand ( ) . equals ( "manrune" ) ) { clickState = ClickState . man ; } else if ( arg0 . getActionCommand ( ) . equals ( "dwarfrune" ) ) clickState = ClickState . dwarf ; else if ( arg0 . getActionCommand ( ) . equals ( "hobbitrune" ) ) clickState = ClickState . hobbit ; else if ( arg0 . getActionCommand ( ) . equals ( "reloadrune" ) ) clickState = ClickState . reload ; else if ( arg0 . getActionCommand ( ) . equals ( "rangerune" ) ) clickState = ClickState . range ; }
tr	5	public JSONRPCResponseObject sendAndReceive ( JSONRPCRequestObject message ) throws SaploClientException { RestClient client = new RestClient ( ) ; if ( clientProxy != null ) { ClientConfig config = new ClientConfig ( ) ; config . proxyHost ( clientProxy . getHost ( ) ) ; config . proxyPort ( clientProxy . getPort ( ) ) ; if ( clientProxy . isSecure ( ) ) { } client = new RestClient ( config ) ; } Resource resource = client . resource ( uri + "?" + params ) ; ClientResponse response = resource . post ( message . toString ( ) ) ; String responseString = response . getEntity ( String . class ) ; int statusCode = response . getStatusCode ( ) ; if ( statusCode != HttpStatus . SC_OK ) throw new SaploClientException ( ResponseCodes . MSG_API_DOWN_EXCEPTION , ResponseCodes . CODE_API_DOWN_EXCEPTION , statusCode ) ; JSONTokener tokener = new JSONTokener ( responseString ) ; Object rawResponseMessage ; try { rawResponseMessage = tokener . nextValue ( ) ; } catch ( JSONException e ) { throw new SaploClientException ( ResponseCodes . MSG_MALFORMED_RESPONSE , ResponseCodes . CODE_MALFORMED_RESPONSE ) ; } JSONObject responseMessage = ( JSONObject ) rawResponseMessage ; if ( responseMessage == null ) throw new ClientError ( "Invalid response type - " + rawResponseMessage ) ; return new JSONRPCResponseObject ( responseMessage ) ; }
tr	9	private void updateEntity ( Entity entity ) { if ( entity . x < 128 || entity . y < 128 || entity . x >= 13184 || entity . y >= 13184 ) { entity . animation = - 1 ; entity . graphicId = - 1 ; entity . tickStart = 0 ; entity . tickEnd = 0 ; entity . x = entity . waypointX [ 0 ] * 128 + entity . boundaryDimension * 64 ; entity . y = entity . waypointY [ 0 ] * 128 + entity . boundaryDimension * 64 ; entity . resetPath ( ) ; } if ( entity == localPlayer && ( entity . x < 1536 || entity . y < 1536 || entity . x >= 11776 || entity . y >= 11776 ) ) { entity . animation = - 1 ; entity . graphicId = - 1 ; entity . tickStart = 0 ; entity . tickEnd = 0 ; entity . x = entity . waypointX [ 0 ] * 128 + entity . boundaryDimension * 64 ; entity . y = entity . waypointY [ 0 ] * 128 + entity . boundaryDimension * 64 ; entity . resetPath ( ) ; } if ( entity . tickStart > tick ) updatePosition ( entity ) ; else if ( entity . tickEnd >= tick ) updateFacingDirection ( entity ) ; else processWalkingStep ( entity ) ; appendFocusDestination ( entity ) ; appendAnimation ( entity ) ; }
tr	0	public void delete ( ) { Dispatch . call ( this , "Delete" ) ; }
tr	0	@ Override public PLType getType ( ) { return PLType . PLNull ; }
tr	2	public long getLong_safe ( final long i ) { if ( i < 0 || i >= length ) { throw new ArrayIndexOutOfBoundsException ( long . toString ( i ) ) ; } return getLong ( i ) ; }
tr	8	@ Override public Iterable < MatchResult < T >> matchFromStart ( final CharSequence string ) { return new Iterable < MatchResult < T >> ( ) { public Iterator < MatchResult < T >> iterator ( ) { return new Iterator < MatchResult < T >> ( ) { TailMatchIterator tailSequence = new TailMatchIterator ( 0 , string ) ; List < MatchResult < ? >> next = null ; boolean returnNull = getMin ( ) == 0 ; public boolean hasNext ( ) { if ( returnNull ) return true ; updateNext ( ) ; return null != next ; } public MatchResult < T > next ( ) { if ( returnNull ) { returnNull = false ; return new MatchResult < T > ( ChainGrammar . this , string , 0 , 0 , getNullResult ( ) ) ; } updateNext ( ) ; T result = getResult ( next ) ; int startIndex = 0 ; int endIndex = 0 ; for ( MatchResult < ? > r : next ) { assert ( 0 == r . start ) ; endIndex += r . end ; } MatchResult < T > matchResult = new MatchResult < T > ( ChainGrammar . this , string , startIndex , endIndex , result ) ; next = null ; return matchResult ; } private void updateNext ( ) { while ( null == next || next . size ( ) < getMin ( ) ) { if ( ! tailSequence . hasNext ( ) ) { next = null ; break ; } next = tailSequence . next ( ) ; } } public void remove ( ) { throw new RuntimeException ( "Operation not supported" ) ; } } ; } } ; }
tr	6	public boolean overlaps ( PriceStep other ) { if ( this . getEndPrice ( ) == 0 && other . getEndPrice ( ) == 0 ) { return true ; } if ( ( this . getEndPrice ( ) != 0 && other . getStartPrice ( ) >= this . getEndPrice ( ) ) || ( other . getEndPrice ( ) != 0 && other . getEndPrice ( ) <= this . getStartPrice ( ) ) ) { return false ; } else { return true ; } }
tr	7	@ SuppressWarnings ( "unchecked" ) @ Override public boolean equals ( Object obj ) { if ( obj instanceof ObjectWrapper == false ) { return false ; } ObjectWrapper < T > ow = ( ObjectWrapper < T > ) obj ; if ( this . obj == null && ow . obj == null ) { return true ; } else if ( this . obj != null && ow . obj == null ) { return false ; } else if ( this . obj == null && ow . obj != null ) { return false ; } else { return this . obj . equals ( ow . obj ) ; } }
tr	4	public static PLDictionary decodePLDictionary ( XMLFile xml ) { if ( "dict" . equals ( xml . getMe ( ) . getNodeName ( ) ) ) { PLDictionary dict = new PLDictionary ( ) ; XMLFile [ ] keys = xml . gets ( "key" ) ; if ( keys . length > 0 ) { for ( int i = 0 ; i < keys . length ; i ++ ) { XMLFile key = keys [ i ] ; Node value = ( Node ) key . getMe ( ) . getNextSibling ( ) ; if ( null == value ) { continue ; } dict . put ( key . getText ( ) , PListDecoder . decode ( new XMLFile ( ( Element ) value ) ) ) ; } return dict ; } } return null ; }
tr	5	private static int copyRefs ( ArrayList < String > target , Pattern pattern1 , Pattern pattern2 ) { if ( pattern1 . refs == null && pattern2 . refs == null ) return 0 ; int offset = 0 ; if ( pattern1 . refs != null ) { offset = pattern1 . refs . size ( ) ; target . addAll ( pattern1 . refs ) ; if ( pattern2 . refs == null || pattern2 . refs . equals ( pattern1 . refs ) ) return 0 ; } target . addAll ( pattern2 . refs ) ; return offset ; }
tr	5	public static String rowToString ( JSONArray ja ) { StringBuffer sb = new StringBuffer ( ) ; for ( int i = 0 ; i < ja . length ( ) ; i += 1 ) { if ( i > 0 ) { sb . append (   ) ; } Object o = ja . opt ( i ) ; if ( o != null ) { String s = o . toString ( ) ; if ( s . indexOf (   ) >= 0 ) { if ( s . indexOf ( " ) >= 0 ) { sb . append ( ' ) ; sb . append ( s ) ; sb . append ( ' ) ; } else { sb . append ( " ) ; sb . append ( s ) ; sb . append ( " ) ; } } else { sb . append ( s ) ; } } } sb . append ( '' ) ; return sb . toString ( ) ; }
tr	5	public String toString ( boolean printHeaderRow , String additionalColumnHeader , String additionalColumnValue ) { final List < Identifier > keys = new ArrayList < Identifier > ( variables . keySet ( ) ) ; Collections . sort ( keys , new Comparator < Identifier > ( ) { @ Override public int compare ( Identifier o1 , Identifier o2 ) { final int result = o1 . getValue ( ) . compareTo ( o2 . getValue ( ) ) ; if ( o1 . getValue ( ) . length ( ) < o2 . getValue ( ) . length ( ) ) { return - 1 ; } return result ; } } ) ; final List < String > columns = new ArrayList < > ( ) ; final List < String > values = new ArrayList < > ( ) ; final List < Integer > columnWidths = new ArrayList < > ( ) ; for ( Identifier id : keys ) { columns . add ( id . getValue ( ) ) ; values . add ( variables . get ( id ) != null ? variables . get ( id ) . toString ( true ) : null ) ; columnWidths . add ( width ( id . getValue ( ) ) ) ; } final boolean hasAdditionalColumn = StringUtils . isNotBlank ( additionalColumnHeader ) ; if ( hasAdditionalColumn ) { columns . add ( additionalColumnHeader ) ; values . add ( additionalColumnValue ) ; columnWidths . add ( width ( additionalColumnHeader ) ) ; } StringBuilder buffer = new StringBuilder ( ) ; if ( printHeaderRow ) { printHeaderLine ( buffer , columns , columnWidths , hasAdditionalColumn ) ; buffer . append ( "\n" ) ; } printSeparatorLine ( buffer , columns , columnWidths , hasAdditionalColumn ) ; buffer . append ( "\n" ) ; printValues ( buffer , values , columnWidths , hasAdditionalColumn ) ; return buffer . toString ( ) ; }
tr	7	public static void testByteDLL ( String [ ] args ) throws Exception { if ( args == null || args . length < 1 ) { System . out . println ( "Must provide equal length strings to build ByteDLL.\n" ) ; System . out . println ( "   testByte str1 str2 str3 ...\n" ) ; System . out . println ( "NOTE: unequal length strings will give inconsistent results." ) ; System . exit ( - 1 ) ; } ByteHashSpeedTest tester = new ByteHashSpeedTest ( ) ; Vector < String > strings = new Vector < String > ( ) ; for ( String str : args ) { strings . add ( str ) ; } ByteDLL head = ByteDLL . fromStrings ( strings ) ; head . printOut ( ) ; System . out . println ( ) ; String searchStr = null ; BufferedReader terminal = new BufferedReader ( new InputStreamReader ( System . in ) ) ; while ( searchStr == null || ! searchStr . equals ( ":q" ) ) { System . out . print ( "String to search for (^c or \":q\" to quit): " ) ; System . out . flush ( ) ; int inp = 0 ; searchStr = terminal . readLine ( ) ; List < byte [ ] > matches = head . matches ( searchStr . getBytes ( ) , 0 , searchStr . getBytes ( ) . length ) ; if ( matches != null ) { System . out . print ( "Found [" + matches . size ( ) + "] matches: " ) ; for ( byte [ ] word : matches ) { System . out . print ( new String ( word ) + " " ) ; } System . out . println ( ) ; } } }
tr	0	@ Override public boolean isList ( ) { return false ; }
tr	9	private boolean inspectClazz ( class < ? > clazz ) { boolean success = false ; logger . info ( "Inspecting Class: " + clazz . getCanonicalName ( ) ) ; Method [ ] declMethods = clazz . getDeclaredMethods ( ) ; if ( declMethods != null && declMethods . length > 0 ) { for ( Method m : declMethods ) { String methodName = m . getName ( ) ; class < ? > [ ] params = m . getParameterTypes ( ) ; if ( methodName . startsWith ( "set" ) ) { if ( params . length == 1 && params [ 0 ] == String . class ) { logger . trace ( "Updating Cache. Setter / Getter: " + methodName ) ; cache . updateCache ( clazz , methodName , m ) ; } else if ( params . length == 2 && params [ 0 ] == String . class && params [ 1 ] == String . class ) { logger . trace ( "Updating Cache. Setter / Getter: " + methodName ) ; cache . updateCache ( clazz , methodName , m ) ; } else { logger . trace ( "Rejecting method " + methodName ) ; } } else if ( methodName . startsWith ( "get" ) ) { if ( params . length <= 1 ) { logger . trace ( "Updating Cache. Setter / Getter: " + methodName ) ; cache . updateCache ( clazz , methodName , m ) ; } else { logger . trace ( "Rejecting method " + methodName ) ; } } else if ( methodName . startsWith ( "is" ) ) { logger . trace ( "Updating Cache. Setter / Getter: " + methodName ) ; cache . updateCache ( clazz , methodName , m ) ; } } success = true ; } else { logger . trace ( "No declared methods found." ) ; } return success ; }
tr	8	public static boolean checkSudokuSolution ( int [ ] [ ] grid , int subSquareSize ) { final int size = grid . length ; if ( ! checkValues ( grid , 1 , size ) ) { return false ; } for ( int row = 0 ; row < size ; ++ row ) { if ( ! checkRow ( grid , row ) ) { return false ; } } for ( int col = 0 ; col < size ; ++ col ) { if ( ! checkColumn ( grid , col ) ) { return false ; } } for ( int baseRow = 0 ; baseRow < size ; baseRow += subSquareSize ) { for ( int baseCol = 0 ; baseCol < size ; baseCol += subSquareSize ) { if ( ! checkSquare ( grid , baseRow , baseCol , subSquareSize ) ) { return false ; } } } return true ; }
tr	8	private static void exportFrame ( ExportDiagnoser d , Frame f , File baseDirectory ) { Rectangle rect = f . properRectangle ( ) ; Point pivot = f . getPivot ( ) ; d . printSection ( f . getName ( ) ) ; RelativeFile relativeImageFile = f . getImageFile ( ) ; if ( relativeImageFile != null ) { File imageFile = relativeImageFile . getAbsoluteFile ( ) ; File imagePath = new File ( "" ) ; try { imagePath = getRelativeFile ( imageFile , baseDirectory ) ; d . printKeyValue ( "Texture" , imagePath . toString ( ) ) ; } catch ( IOException e ) { d . reportExternalError ( "There was a problem while exporting the texture of " + f . getName ( ) ) ; e . printStackTrace ( ) ; } } else d . reportExternalError ( f . getName ( ) + " has no texture" ) ; if ( rect != null ) { d . printKeyValue ( "TextureCorner" , "(" + rect . x + "  " + rect . y + "  0)" ) ; d . printKeyValue ( "TextureSize" , "(" + rect . width + "  " + rect . height + "  0)" ) ; } else d . reportExternalError ( f . getName ( ) + " does not have a rectangle defined" ) ; if ( pivot != null ) { pivot . x -= rect . x ; pivot . y -= rect . y ; d . printKeyValue ( "Pivot" , "(" + pivot . x + "  " + pivot . y + "  0)" ) ; } else d . reportExternalError ( f . getName ( ) + " does not have a pivot defined" ) ; if ( f . getFlipX ( ) || f . getFlipY ( ) ) { String flip = "" ; if ( f . getFlipX ( ) ) flip += "x" ; if ( f . getFlipY ( ) ) flip += "y" ; d . printKeyValue ( "Flip" , flip ) ; } }
tr	2	public void deleteShowTime ( Date time , Movie movie ) { for ( ShowTime showTime : showTimeDAO . getShowTimes ( movie ) ) { if ( time == showTime . getTime ( ) ) { showTimeDAO . deleteShowTime ( showTime ) ; } } }
tr	9	@ Override public void run ( ) { while ( true ) { WatchKey watchKey ; try { watchKey = service . take ( ) ; } catch ( InterruptedException e ) { throw new RuntimeException ( e ) ; } if ( watchKey != null ) { for ( WatchEvent < ? > p : watchKey . pollEvents ( ) ) { System . out . println ( p . context ( ) + " -> " + p . kind ( ) ) ; Path path = ( Path ) p . context ( ) ; if ( watchKey . watchable ( ) instanceof Path ) { System . out . println ( "DEBUG: watchKey.watchable = " + watchKey . watchable ( ) ) ; } Path modifiedItem = Paths . get ( watchKey . watchable ( ) . toString ( ) , path . toString ( ) ) ; System . out . println ( "DEBUG: modifiedItem = " + modifiedItem ) ; if ( Files . isDirectory ( modifiedItem ) ) { if ( p . kind ( ) == StandardWatchEventKinds . ENTRY_CREATE ) { model . addDirectory ( modifiedItem ) ; try { modifiedItem . register ( service ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } handler . handleDirectory ( model , modifiedItem , toType ( p . kind ( ) ) ) ; } else if ( Files . isRegularFile ( modifiedItem ) ) { handler . handleFile ( model , modifiedItem , toType ( p . kind ( ) ) ) ; } else { if ( Files . exists ( modifiedItem ) ) { System . err . println ( "Could not handle: " + modifiedItem . toAbsolutePath ( ) . toString ( ) ) ; try { BasicFileAttributes bfa = Files . readAttributes ( modifiedItem . toAbsolutePath ( ) , BasicFileAttributes . class ) ; System . out . println ( "    is regular " + bfa . isRegularFile ( ) ) ; System . out . println ( "    is directory " + bfa . isDirectory ( ) ) ; System . out . println ( "    is other " + bfa . isOther ( ) ) ; System . out . println ( "    is link " + bfa . isSymbolicLink ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } } } watchKey . reset ( ) ; } } }
tr	7	public void sight ( ) { for ( int e = 0 ; e < eyes . size ( ) ; e ++ ) { eyes . get ( e ) . getSightOrganisms ( ) . clear ( ) ; for ( int o = 0 ; o < environment . getOrganisms ( ) . size ( ) ; o ++ ) { if ( environment . getOrganisms ( ) . get ( o ) != this ) { if ( sight . contains ( environment . getOrganisms ( ) . get ( o ) . getX ( ) , environment . getOrganisms ( ) . get ( o ) . getY ( ) ) ) { eyes . get ( e ) . getSightOrganisms ( ) . add ( environment . getOrganisms ( ) . get ( o ) ) ; } } } } for ( int e = 0 ; e < eyes . size ( ) ; e ++ ) { eyes . get ( e ) . getSightEntities ( ) . clear ( ) ; for ( int en = 0 ; en < environment . getEntities ( ) . size ( ) ; en ++ ) { if ( sight . contains ( environment . getEntities ( ) . get ( en ) . getX ( ) , environment . getEntities ( ) . get ( en ) . getY ( ) ) ) { eyes . get ( e ) . getSightEntities ( ) . add ( environment . getEntities ( ) . get ( en ) ) ; } } } }
tr	9	public void run ( ) { synchronized ( taskList ) { while ( true ) { long time = System . currentTimeMillis ( ) ; if ( nextTime <= time ) { nextTask . getTask ( ) . runWatchdogTask ( time ) ; nextTask . setLastExecMillis ( time ) ; updateNextTask ( ) ; } if ( nextTask != null && taskList . size ( ) > 0 ) { time = System . currentTimeMillis ( ) ; long timeToSleep = nextTime - time ; if ( timeToSleep > 0 ) { try { taskList . wait ( timeToSleep ) ; } catch ( InterruptedException e ) { } continue ; } else if ( timeToSleep == 0 || nextTime == 0 ) continue ; } try { taskList . wait ( ) ; } catch ( InterruptedException e ) { } } } }
tr	8	public void enterElement ( String name , Attributes attrs ) throws Exception { if ( customParser != null ) { customParser . enterElement ( name , attrs ) ; return ; } if ( name . equals ( "Keyring" ) ) { done = false ; return ; } if ( name . equals ( "Protocols" ) ) { return ; } if ( name . equals ( "Protocol" ) ) { String type = attrs . getValue ( "type" ) ; String clName = attrs . getValue ( "class" ) ; try { class < ? > cl = class . forName ( clName ) ; AP_Generic . registerHandler ( type , cl . asSubclass ( AP_Generic . class ) ) ; } catch ( Exception e ) { throw new SAXException ( "Unknown authentication protocol class: " + clName ) ; } return ; } if ( name . equals ( "Identity" ) ) { proto = attrs . getValue ( "proto" ) ; domain = attrs . getValue ( "domain" ) ; AP_Generic parser = AP_Generic . getInstance ( proto ) ; if ( parser == null ) throw new SAXException ( "Unknown authentication protocol: " + proto ) ; parser . initParse ( attrs ) ; customParser = parser ; return ; } }
tr	3	public void act ( List < Actor > newFoxes ) { incrementAge ( ) ; incrementHunger ( ) ; if ( isAlive ( ) ) { giveBirth ( newFoxes ) ; Location newLocation = findFood ( ) ; if ( newLocation == null ) { newLocation = getField ( ) . freeAdjacentLocation ( getLocation ( ) ) ; } if ( newLocation != null ) { setLocation ( newLocation ) ; } else { setDead ( ) ; } } }
tr	3	public JSONObject ( Map map ) { this . map = new HashMap ( ) ; if ( map != null ) { Iterator i = map . entrySet ( ) . iterator ( ) ; while ( i . hasNext ( ) ) { Map . Entry e = ( Map . Entry ) i . next ( ) ; Object value = e . getValue ( ) ; if ( value != null ) { this . map . put ( e . getKey ( ) , wrap ( value ) ) ; } } } }
tr	4	private static void sort ( int [ ] a , int lo , int hi , PIVOT_STRATEGY ps ) { if ( hi <= lo ) { return ; } switch ( ps ) { case FIRST : break ; case LAST : ArrayUtils . swap ( a , lo , hi ) ; break ; case MEDIAN : int med_ind = findMedian ( a , lo , hi ) ; ArrayUtils . swap ( a , lo , med_ind ) ; break ; default : } count += ( hi - lo ) ; int pivot_pos = partition ( a , lo , hi ) ; sort ( a , lo , pivot_pos - 1 , ps ) ; sort ( a , pivot_pos + 1 , hi , ps ) ; }
tr	1	public double sum ( ) { double sum = 0.0 ; for ( int i = 0 ; i < n ; i ++ ) sum += x [ i ] ; return sum ; }
tr	1	public int GetSumOfAlphabeticalValuesTimesAlphabeticalOrdering ( ) { Sort ( ) ; int toReturn = 0 ; for ( int i = 0 ; i < NameList . size ( ) ; i ++ ) { toReturn += GetAlphabeticalValue ( NameList . get ( i ) ) * ( i + 1 ) ; } return toReturn ; }
tr	7	public String searchBuilding ( String s_name , boolean isPerson ) { int i_nbRow = 0 ; int i_nbRowFiltered = 0 ; model . clearTabModelBuilding ( ) ; List < String > listNamePerson = new ArrayList < String > ( ) ; if ( isPerson ) { listNamePerson . add ( s_name ) ; } else { } for ( String s_namePerson : listNamePerson ) { for ( Person person : model . getListPerson ( ) ) { if ( person . getS_nameWithoutSmiley ( ) . equals ( s_namePerson ) ) { List < String > listString_RowToAdd = new ArrayList < String > ( ) ; for ( Building building : person . getListBuilding ( ) ) { i_nbRow ++ ; listString_RowToAdd . add ( String . valueOf ( building . getI_level ( ) ) ) ; listString_RowToAdd . add ( building . getS_type ( ) ) ; listString_RowToAdd . add ( createUrlKI ( building . getCity ( ) . getI_id ( ) , building . getI_id ( ) , 2 ) ) ; listString_RowToAdd . add ( building . getS_name ( ) ) ; listString_RowToAdd . add ( transformToCase ( building . getI_x ( ) + 1 , building . getI_y ( ) + 1 ) ) ; listString_RowToAdd . add ( createUrlKI ( building . getCity ( ) . getDistrict ( ) . getI_id ( ) , building . getCity ( ) . getI_id ( ) , 1 ) ) ; listString_RowToAdd . add ( building . getCity ( ) . getS_name ( ) ) ; listString_RowToAdd . add ( createUrlKI ( building . getCity ( ) . getDistrict ( ) . getI_id ( ) , 0 , 0 ) ) ; listString_RowToAdd . add ( building . getCity ( ) . getDistrict ( ) . getS_name ( ) ) ; listString_RowToAdd . add ( building . getOwner ( ) . getS_nameHtml ( ) ) ; listString_RowToAdd . add ( building . getOwner ( ) . getS_nameWithoutSmiley ( ) ) ; listString_RowToAdd . add ( "" ) ; listString_RowToAdd . add ( String . valueOf ( building . getI_value ( ) ) ) ; if ( model . addRowTabModelBuilding ( listString_RowToAdd ) ) { i_nbRowFiltered ++ ; } listString_RowToAdd . clear ( ) ; } } } } if ( i_nbRow == 0 ) { return "Aucun r\u00E9sultat" ; } else { return i_nbRowFiltered + "/" + i_nbRow + " R\u00E9sultat(s) filtr\u00E9(s)" ; } }
tr	2	private Player getPreviousPlayer ( ) { if ( players . size ( ) < 2 ) { logger . info ( "No more other players left! Finishing too!" ) ; ownPlayer . setActive ( false ) ; return null ; } else { int ownIndex = players . indexOf ( ownPlayer ) ; if ( ownIndex == 0 ) { return players . getLast ( ) ; } else { return players . get ( ownIndex - 1 ) ; } } }
tr	6	private boolean r_other_endings ( ) { int among_var ; int v_1 ; int v_2 ; int v_3 ; v_1 = limit - cursor ; if ( cursor < I_p2 ) { return false ; } cursor = I_p2 ; v_2 = limit_backward ; limit_backward = cursor ; cursor = limit - v_1 ; ket = cursor ; among_var = find_among_b ( a_7 , 14 ) ; if ( among_var == 0 ) { limit_backward = v_2 ; return false ; } bra = cursor ; limit_backward = v_2 ; switch ( among_var ) { case 0 : return false ; case 1 : { v_3 = limit - cursor ; lab0 : do { if ( ! ( eq_s_b ( 2 , "po" ) ) ) { break lab0 ; } return false ; } while ( false ) ; cursor = limit - v_3 ; } break ; } slice_del ( ) ; return true ; }
tr	5	public void initArrayElementChildren ( ) { Object userObj = this . userObject ; if ( userObj != null ) { if ( null == this . children ) { this . children = new Vector < AbstractBeanTreeNode > ( ) ; } int length = Array . getLength ( userObj ) ; for ( int i = 0 ; i < length ; i ++ ) { Object arrayElement = Array . get ( userObj , i ) ; class < ? > componentType = this . getObjType ( ) . getComponentType ( ) ; Object arrayElementDefaultValue = this . getObjectDefaultValueInstance ( componentType ) ; AbstractBeanTreeNode arrayChildNode = new BeanObjectTreeNode ( this , componentType . getSimpleName ( ) , componentType , arrayElement , arrayElementDefaultValue , null ) ; if ( componentType . isArray ( ) ) { arrayChildNode . initArrayElementChildren ( ) ; } else { arrayChildNode . initChildren ( ) ; } this . children . add ( arrayChildNode ) ; } } }
tr	8	@ Test public void advancedDiff ( ) { System . out . println ( "[UNITTEST] ***** TEST: Complex hierarchies Diff test *****" ) ; IOntologyBackend oro = new OpenRobotsOntology ( conf ) ; Set < Set < String >> diff1 = null ; Set < Set < String >> diff2 = null ; Set < Set < String >> diff3 = null ; Set < Set < String >> diff4 = null ; Set < String > sim1 = null ; Set < String > sim2 = null ; Set < String > sim3 = null ; Set < String > sim4 = null ; CategorizationModule categorizationModule = new CategorizationModule ( oro ) ; long totalTimeDiff = 0 ; long totalTimeSim = 0 ; long startTime = System . currentTimeMillis ( ) ; try { diff1 = categorizationModule . getDifferences ( "f" , "j" ) ; diff2 = categorizationModule . getDifferences ( "f" , "k" ) ; diff3 = categorizationModule . getDifferences ( "f" , "e" ) ; diff4 = categorizationModule . getDifferences ( "f" , "f" ) ; totalTimeDiff = ( System . currentTimeMillis ( ) - startTime ) ; sim1 = categorizationModule . getSimilarities ( "f" , "j" ) ; sim2 = categorizationModule . getSimilarities ( "f" , "k" ) ; sim3 = categorizationModule . getSimilarities ( "f" , "e" ) ; sim4 = categorizationModule . getSimilarities ( "f" , "f" ) ; totalTimeSim = ( System . currentTimeMillis ( ) - startTime - totalTimeDiff ) ; } catch ( NotFoundException e ) { e . printStackTrace ( ) ; fail ( e . getMessage ( ) ) ; } catch ( NotComparableException e ) { fail ( ) ; } assertTrue ( "" , diff1 . size ( ) == 2 ) ; assertTrue ( "" , diff2 . size ( ) == 2 ) ; assertTrue ( "" , diff3 . size ( ) == 1 ) ; assertTrue ( "" , diff4 . isEmpty ( ) ) ; assertTrue ( "" , sim1 . size ( ) == 2 && sim1 . contains ( "? rdf:type B" ) && sim1 . contains ( "? rdf:type D" ) ) ; assertTrue ( "" , sim2 . size ( ) == 2 && sim2 . contains ( "? rdf:type B" ) && sim2 . contains ( "? rdf:type D" ) ) ; assertTrue ( "" , sim3 . size ( ) == 1 && sim3 . contains ( "? rdf:type E" ) ) ; assertTrue ( "" , sim4 . size ( ) == 1 && sim4 . contains ( "? rdf:type F" ) ) ; System . out . println ( "[UNITTEST] ***** Average time per differences comparison:" + totalTimeDiff / 4 + "ms" ) ; System . out . println ( "[UNITTEST] ***** Average time per similarities comparison:" + totalTimeSim / 4 + "ms" ) ; System . out . println ( "[UNITTEST] ***** Test successful *****" ) ; }
tr	4	public static java . util . Date toUtilDateFromStrDateByFormat ( String p_strDate , String p_format ) throws ParseException { java . util . Date l_date = null ; java . text . DateFormat df = new java . text . SimpleDateFormat ( p_format ) ; if ( p_strDate != null && ( ! "" . equals ( p_strDate ) ) && p_format != null && ( ! "" . equals ( p_format ) ) ) { l_date = df . parse ( p_strDate ) ; } return l_date ; }
tr	2	public void initRandom ( Random random , int maxValue ) { for ( int y = 0 ; y < getHeight ( ) ; y ++ ) { for ( int x = 0 ; x < getWidth ( ) ; x ++ ) { int v = random . nextInt ( maxValue + 1 ) ; setValue ( x , y , v ) ; } } }
tr	9	private static void begin ( ) { Scanner sc = new Scanner ( System . in ) ; while ( sc . hasNextLine ( ) ) { StringTokenizer st = new StringTokenizer ( sc . nextLine ( ) ) ; int nbrInts = Integer . parseInt ( st . nextToken ( ) ) ; if ( nbrInts <= 0 ) { System . out . println ( "Not jolly" ) ; continue ; } else if ( nbrInts == 1 ) { System . out . println ( "Jolly" ) ; continue ; } boolean [ ] data = new boolean [ nbrInts - 1 ] ; int prev = Integer . parseInt ( st . nextToken ( ) ) ; while ( st . hasMoreTokens ( ) ) { int curr = Integer . parseInt ( st . nextToken ( ) ) ; int absDiff = Math . abs ( prev - curr ) ; if ( absDiff > 0 && absDiff <= nbrInts - 1 ) { data [ absDiff - 1 ] = true ; } prev = curr ; } boolean isJolly = true ; for ( boolean b : data ) { if ( ! b ) { isJolly = false ; break ; } } if ( isJolly ) { System . out . println ( "Jolly" ) ; } else { System . out . println ( "Not jolly" ) ; } } }
tr	3	private GenericTree < LayoutParserTreeElement > parseXML ( String layoutXML ) { GenericTree < LayoutParserTreeElement > newTree = new GenericTree < LayoutParserTreeElement > ( ) ; Document result = null ; DocumentBuilderFactory factory = DocumentBuilderFactory . newInstance ( ) ; InputSource source = new InputSource ( new StringReader ( layoutXML ) ) ; try { result = factory . newDocumentBuilder ( ) . parse ( source ) ; } catch ( SAXException e ) { ErrorMessage . show ( "Eroare SAX" , false ) ; e . printStackTrace ( ) ; } catch ( IOException e ) { ErrorMessage . show ( "Eroare IOException" , false ) ; e . printStackTrace ( ) ; } catch ( ParserConfigurationException e ) { ErrorMessage . show ( "Eroare ParserConfigurationException" , false ) ; e . printStackTrace ( ) ; } Match documentRoot = $ ( result ) . first ( ) ; saveImageFromXML ( documentRoot ) ; GenericTreeNode < LayoutParserTreeElement > rootDocument = parseXMLRow ( documentRoot ) ; newTree . setRoot ( rootDocument ) ; return newTree ; }
tr	5	@ Override public int read ( ) throws IOException { ensureOpen ( ) ; for ( ; ; ) { if ( nextChar >= nChars ) { fill ( ) ; if ( nextChar >= nChars ) return - 1 ; } if ( skipLF ) { skipLF = false ; if ( cb [ nextChar ] == '' ) { nextChar ++ ; continue ; } } return cb [ nextChar ++ ] ; } }
tr	1	public static void main ( String [ ] argv ) { final int regulPriority = 8 ; final int refGenPriority = 6 ; final int plotterPriority = 7 ; ReferenceGenerator refgen = new ReferenceGenerator ( refGenPriority ) ; Regul regul = new Regul ( regulPriority ) ; final OpCom opcom = new OpCom ( plotterPriority ) ; regul . setOpCom ( opcom ) ; regul . setRefGen ( refgen ) ; opcom . setRegul ( regul ) ; Runnable initializeGUI = new Runnable ( ) { public void run ( ) { opcom . initializeGUI ( ) ; opcom . start ( ) ; } } ; try { SwingUtilities . invokeAndWait ( initializeGUI ) ; } catch ( Exception e ) { return ; } refgen . start ( ) ; regul . start ( ) ; }
tr	2	public void setFieldValue ( _Fields field , Object value ) { switch ( field ) { case SUCCESS : if ( value == null ) { unset_success ( ) ; } else { set_success ( ( QueueInfo ) value ) ; } break ; } }
tr	3	public static JsonObjectBuilder rewriteJson ( JsonObjectBuilder copyInto , JsonValue tree , String key ) { switch ( tree . getValueType ( ) ) { case OBJECT : JsonObject obj = ( JsonObject ) tree ; for ( String name : obj . keySet ( ) ) { copyInto = rewriteJson ( copyInto , obj . get ( name ) , name ) ; } break ; case STRING : JsonString st = ( JsonString ) tree ; copyInto . add ( key , st . getString ( ) ) ; break ; default : break ; } return copyInto ; }
tr	3	private void checkInvariants ( ) { assert ( wordsInUse == 0 || words [ wordsInUse - 1 ] != 0 ) ; assert ( wordsInUse >= 0 && wordsInUse <= words . length ) ; assert ( wordsInUse == words . length || words [ wordsInUse ] == 0 ) ; }
tr	4	public static void fixMultiDiscAlbums ( List < CoverDetails > covers ) { for ( CoverDetails cover : covers ) { if ( cover . getDiscNumber ( ) > 1 ) { for ( CoverDetails parent : covers ) { if ( parent . addExtraDisc ( cover ) ) { break ; } } } } }
tr	4	@ Override public void run ( GameManager gameManager , Game ata , MessageInfo msgInfo , List < Message > responses ) { responses . add ( MSG ( msgInfo . ROOM , msgInfo . NICK + " has been marked as away.  Use !back to rejoin." ) ) ; Name name = gameManager . m_nickToNameMap . get ( msgInfo . NICK ) ; ata . m_activePlayers . remove ( name ) ; if ( ata . m_activePlayers . size ( ) < 3 ) { ata . m_state = State . LOCK ; responses . add ( MSG ( gameManager . getName ( ) , "!botendgame " + msgInfo . ROOM ) ) ; } if ( ata . m_judge . equals ( msgInfo . NICK ) ) { ata . m_state = State . LOCK ; responses . add ( MSG ( gameManager . getName ( ) , "!botcleanup " + msgInfo . ROOM ) ) ; } else if ( ata . m_state == State . PLAY ) { ata . m_waiting . remove ( name ) ; if ( ata . m_waiting . size ( ) == 0 ) { ata . m_waiting . remove ( name ) ; responses . add ( MSG ( gameManager . getName ( ) , "!botchoose " + msgInfo . ROOM ) ) ; } } }
tr	2	private static Bullet get ( long pointer ) { if ( pointer == 0 ) { return null ; } Bullet instance = instances . get ( pointer ) ; if ( instance == null ) { instance = new Bullet ( pointer ) ; instances . put ( pointer , instance ) ; } return instance ; }
tr	3	public void connect ( Message m ) { String message = m . getMessage ( ) ; if ( message . startsWith ( Protocol . CONNECT ) ) { message = message . replace ( Protocol . CONNECT , "" ) ; if ( ! message . equals ( "" ) ) { if ( ! users . containsValue ( m . getIClient ( ) ) ) { m . getIClient ( ) . setName ( message ) ; registrerClients ( message , m . getIClient ( ) ) ; notifyUsers ( Protocol . ONLINE + getUsers ( ) ) ; } else { notifyReciever ( Protocol . SERVER_ONLINE_RESPONSE , m . getIClient ( ) ) ; System . out . println ( "shiiit" ) ; } } } }
tr	2	public static int nextPosition ( int startPosition , ArrayList < short > list ) { int offset = 1 ; int tempP = startPosition ; for ( ; tempP < list . size ( ) ; tempP ++ ) { if ( ( list . get ( tempP ) & 00000080 ) == 0 ) { offset ++ ; } else { break ; } } return startPosition + offset ; }
tr	6	@ Override public int loginUsuario ( String login , String password ) throws RemoteException { int result = - 1 ; ArrayList < UsuarioInt > usuarios = obtenerUsuarios ( ) ; for ( UsuarioInt usuario : usuarios ) { if ( login . compareTo ( usuario . getLogin ( ) ) == 0 && password . compareTo ( usuario . getPassword ( ) ) == 0 ) { if ( usuario . getAdmin ( ) ) { result = 2 ; } else { result = 1 ; } } else if ( login . compareTo ( usuario . getLogin ( ) ) == 0 || password . compareTo ( usuario . getPassword ( ) ) == 0 ) { result = 0 ; } } return result ; }
tr	1	public void paintComponent ( Graphics comp ) { super . paintComponent ( comp ) ; Graphics2D comp2D = ( Graphics2D ) comp ; int h = getHeight ( ) - 5 ; int w = getWidth ( ) - 5 ; if ( ! hasValidDrafter ( map , comp2D , hexSideInPixels ) ) { int leftMarginInPixels = 0 ; int topMarginInPixels = 0 ; Rectangle margins = new Rectangle ( leftMarginInPixels , topMarginInPixels , w , h ) ; drafter = new CanvasDrafter ( map , comp2D , hexSideInPixels , textDisplayer , margins ) ; loupe . setMargins ( margins ) ; } drafter . drawMap ( w , h , centerCellId ) ; }
tr	5	public static Platform getPlatform ( String platform ) { if ( isLinux ( platform ) ) { return LINUX ; } else if ( isWindows ( platform ) ) { return WINDOWS ; } else if ( isSolaris ( platform ) ) { return OPENSOLARIS ; } else if ( isFreeBSD ( platform ) ) { return FREEBSD ; } else if ( isMac ( platform ) ) { return MAC ; } return null ; }
tr	0	public String getPassword ( ) { return password ; }
tr	4	private void mnuSaveAsTemplateActionPerformed ( java . awt . event . ActionEvent evt ) { JFileChooser jfc = new JFileChooser ( ) ; jfc . setFileFilter ( new FileNameExtensionFilter ( "xml Datei" , "xml" ) ) ; if ( jfc . showSaveDialog ( this ) == JFileChooser . APPROVE_OPTION ) { File f = jfc . getSelectedFile ( ) ; if ( ! f . getName ( ) . endsWith ( ".xml" ) ) f = new File ( f . getAbsolutePath ( ) + ".xml" ) ; try { SemesterLoader . saveAsTemplate ( f , semesterList ) ; } catch ( JDOMException ex ) { Logger . getLogger ( MainFrame . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( IOException ex ) { Logger . getLogger ( MainFrame . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } } }
tr	3	public static double test ( double [ ] [ ] A , double [ ] b ) { GaussJordanElimination gaussian = new GaussJordanElimination ( A , b ) ; System . out . print ( "\nOriginal: " ) ; for ( double aDouble : b ) { System . out . print ( aDouble + " " ) ; } System . out . println ( ) ; if ( gaussian . isFeasible ( ) ) { double suma = 0.0 ; double [ ] x = gaussian . primal ( ) ; for ( int i = 0 ; i < x . length ; i ++ ) { System . out . printf ( "%9.2f\t" , x [ i ] ) ; suma += Math . abs ( x [ i ] ) ; } System . out . printf ( "\n\t(%6.2f)\n" , varianza ( x ) ) ; return suma ; } else { System . out . println ( "no hay solucion" ) ; System . out . println ( ) ; } return double . MAX_VALUE ; }
tr	2	private void closeSocket ( ) { try { if ( socket != null ) { socket . close ( ) ; socket = null ; } } catch ( IOException e ) { logger . log ( Level . SEVERE , "Could not close network socket: " + e . getMessage ( ) ) ; } socket = null ; }
tr	7	public void processMouseDragged ( int x , int y ) { Rectangle2D . double poseArea = zoomableCanvasState . getPoseArea ( ) ; int incX = x - lastMouseDraggedX ; int incY = y - lastMouseDraggedY ; lastMouseDraggedX = x ; lastMouseDraggedY = y ; if ( state == PoseurState . DRAG_SHAPE_STATE ) { if ( poseArea . contains ( x , y ) ) { float zoomLevel = zoomableCanvasState . getZoomLevel ( ) ; incX /= zoomLevel ; incY /= zoomLevel ; Rectangle2D . double truePoseArea = trueCanvasState . getPoseArea ( ) ; selectedShape . moveShape ( incX , incY , truePoseArea ) ; repaintCanvases ( ) ; } else { setState ( PoseurState . SHAPE_SELECTED_STATE ) ; } } else if ( state == PoseurState . COMPLETE_SHAPE_STATE ) { float zoomLevel = zoomableCanvasState . getZoomLevel ( ) ; int poseSpaceX = ( int ) ( ( x - poseArea . getX ( ) ) / zoomLevel ) ; int poseSpaceY = ( int ) ( ( y - poseArea . getY ( ) ) / zoomLevel ) ; if ( ( poseSpaceX < 0 ) || ( poseSpaceY < 0 ) || ( poseSpaceX >= poseArea . getWidth ( ) ) || ( poseSpaceY >= poseArea . getHeight ( ) ) ) { setState ( PoseurState . CREATE_SHAPE_STATE ) ; shapeInProgress = null ; return ; } shapeInProgress . updateShapeInProgress ( poseSpaceX , poseSpaceY ) ; repaintCanvases ( ) ; } }
tr	4	public static String toString ( JSONArray names , JSONArray ja ) throws JSONException { if ( names == null || names . length ( ) == 0 ) { return null ; } StringBuffer sb = new StringBuffer ( ) ; for ( int i = 0 ; i < ja . length ( ) ; i += 1 ) { JSONObject jo = ja . optJSONObject ( i ) ; if ( jo != null ) { sb . append ( rowToString ( jo . toJSONArray ( names ) ) ) ; } } return sb . toString ( ) ; }
tr	4	@ Test public void doPriorityQueue ( ) { init ( ) ; int count = 0 ; while ( true ) { Point x = prQueue . poll ( ) ; squares . add ( x ) ; Point [ ] ppp = getPotentialPoints ( x , getCrossPoint ( x ) ) ; prQueue . add ( ppp [ 0 ] ) ; prQueue . add ( ppp [ 1 ] ) ; if ( count > 800000 ) break ; count ++ ; if ( x . hx == 3 && x . hy == 3 ) System . out . println ( "RESULT " + squares . size ( ) ) ; } System . out . println ( squares . get ( 49 ) . hx + " " + squares . get ( 49 ) . hy ) ; }
tr	5	private Object parseVarValue ( String _content ) { Object _result ; System . out . println ( _content ) ; if ( _content == null ) { _result = "" ; } else if ( _content . length ( ) == 0 ) { _result = _content ; } else if ( _content . charAt ( 0 ) == " ) { _result = _content . replaceAll ( "\"(.*)\"" , "$1" ) . replaceAll ( "\"\"" , "\"" ) ; } else if ( _content . matches ( "[\\+\\-]?[\\d\\.]+(.*)" ) ) { _result = _content . replaceAll ( "([\\+\\-]?[\\d\\.]+)(.*)" , "$1" ) ; } else { _result = var ( parseVarSubs ( _content ) ) . get ( ) ; } return ( ( _result == null ) ? "" : _result ) ; }
tr	2	private void sendResultToJobClient ( ) { try { String slaveName = SystemConstants . getConfig ( SystemConstants . NAMENODE_SLAVE_SERVICE ) ; String hostName = getJobTrackerServiceProvider ( ) . getJobOriginHostNamebyTaskID ( taskID ) ; String lookup_name = "rmi://" + hostName + ":" + 1099 + "/" + slaveName + "_" + hostName ; System . out . println ( "Building a look up make for the Slave  : " + lookup_name ) ; NameNodeSlave originSlave = ( NameNodeSlave ) Naming . lookup ( lookup_name ) ; System . out . println ( "NameNodeSlave has been looked up." ) ; for ( String filename : getCreatedFiles ( ) ) { String data = this . nameNodeSlaveReference . retrieveFromLocalDataNode ( filename ) ; originSlave . saveFileToLocalDataNode ( filename , data ) ; } } catch ( Exception e ) { System . out . println ( "Manager: Exception thrown looking up " + "NameNodeSlave" ) ; } }
tr	7	private List < Organisation > processAgencies ( StartElement se , XMLEventReader eventReader ) throws XMLStreamException , ExternalRefrenceNotFoundException { List < Organisation > agencies = new ArrayList < Organisation > ( ) ; boolean endTagReached = false ; while ( ! endTagReached ) { XMLEvent event = eventReader . nextTag ( ) ; if ( event . isStartElement ( ) ) { se = event . asStartElement ( ) ; if ( se . getName ( ) . getLocalPart ( ) . equalsIgnoreCase ( "Agency" ) && se . getName ( ) . getNamespaceURI ( ) . equalsIgnoreCase ( Constants . STRUCTURE_NAMESPACE ) ) { Organisation o = processOrganisation ( se , eventReader , "Agency" ) ; agencies . add ( o ) ; } } else if ( event . isEndElement ( ) ) { EndElement ee = event . asEndElement ( ) ; if ( ee . getName ( ) . getLocalPart ( ) . equalsIgnoreCase ( "Agencies" ) && ee . getName ( ) . getNamespaceURI ( ) . equalsIgnoreCase ( Constants . STRUCTURE_NAMESPACE ) ) { endTagReached = true ; } } } return agencies ; }
tr	7	void smbFft ( float [ ] fftBuffer , int fftFrameSize , int sign ) { float wr , wi , arg , temp ; float tr , ti , ur , ui ; int i , bitm , j , le , le2 , k ; int p1 , p2 , p1r , p1i , p2r , p2i ; for ( i = 2 ; i < 2 * fftFrameSize - 2 ; i += 2 ) { for ( bitm = 2 , j = 0 ; bitm < 2 * fftFrameSize ; bitm <<= 1 ) { if ( ( i & bitm ) != 0 ) j ++ ; j <<= 1 ; } if ( i < j ) { p1 = i ; p2 = j ; temp = fftBuffer [ p1 ] ; fftBuffer [ p1 ++ ] = fftBuffer [ p2 ] ; fftBuffer [ p2 ++ ] = temp ; temp = fftBuffer [ p1 ] ; fftBuffer [ p1 ] = fftBuffer [ p2 ] ; fftBuffer [ p2 ] = temp ; } } for ( k = 0 , le = 2 ; k < ( long ) ( Math . log ( fftFrameSize ) / Math . log ( 2. ) + .5 ) ; k ++ ) { le <<= 1 ; le2 = le >> 1 ; ur = 1.0f ; ui = 0.0f ; arg = ( float ) ( M_PI / ( le2 >> 1 ) ) ; wr = ( float ) Math . cos ( arg ) ; wi = ( float ) ( sign * Math . sin ( arg ) ) ; for ( j = 0 ; j < le2 ; j += 2 ) { p1r = j ; p1i = p1r + 1 ; p2r = p1r + le2 ; p2i = p2r + 1 ; for ( i = j ; i < 2 * fftFrameSize ; i += le ) { tr = fftBuffer [ p2r ] * ur - fftBuffer [ p2i ] * ui ; ti = fftBuffer [ p2r ] * ui + fftBuffer [ p2i ] * ur ; fftBuffer [ p2r ] = fftBuffer [ p1r ] - tr ; fftBuffer [ p2i ] = fftBuffer [ p1i ] - ti ; fftBuffer [ p1r ] += tr ; fftBuffer [ p1i ] += ti ; p1r += le ; p1i += le ; p2r += le ; p2i += le ; } tr = ur * wr - ui * wi ; ui = ur * wi + ui * wr ; ur = tr ; } } }
tr	8	private int jjMoveStringLiteralDfa6_0 ( long old0 , long active0 ) { if ( ( ( active0 &= old0 ) ) == 0 ) return jjMoveNfa_0 ( 0 , 5 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { return jjMoveNfa_0 ( 0 , 5 ) ; } switch ( curChar ) { case 72 : if ( ( active0 & 800 ) != 0 ) { jjmatchedKind = 11 ; jjmatchedPos = 6 ; } break ; case 80 : return jjMoveStringLiteralDfa7_0 ( active0 , 10000 ) ; case 104 : if ( ( active0 & 800 ) != 0 ) { jjmatchedKind = 11 ; jjmatchedPos = 6 ; } break ; case 112 : return jjMoveStringLiteralDfa7_0 ( active0 , 10000 ) ; default : break ; } return jjMoveNfa_0 ( 0 , 6 ) ; }
tr	8	@ Override public void visit ( FunctionDefinition node ) { subStatementListsWithoutReturns . push ( 0 ) ; currentFunctionSymbol = node . function ( ) ; node . body ( ) . accept ( this ) ; currentFunctionSymbol = null ; if ( ! ( ( FuncType ) node . function ( ) . getType ( ) ) . returnType ( ) . equivalent ( new VoidType ( ) ) && subStatementListsWithoutReturns . pop ( ) > 0 ) reportError ( node . lineNumber ( ) , node . charPosition ( ) , "Not all paths in function " + node . function ( ) . getName ( ) + " have a return." ) ; VoidType type = new VoidType ( ) ; for ( int i = 0 ; i < node . arguments ( ) . size ( ) ; i ++ ) { Symbol arg = node . arguments ( ) . get ( i ) ; if ( type . equivalent ( arg . getType ( ) ) ) reportError ( node . lineNumber ( ) , node . charPosition ( ) , "Function " + node . function ( ) . getName ( ) + " has a void argument in position " + i + "." ) ; else if ( arg . getType ( ) instanceof ErrorType ) reportError ( node . lineNumber ( ) , node . charPosition ( ) , "Function " + node . function ( ) . getName ( ) + " has an error in argument in position " + i + ": " + ( ( ErrorType ) arg . getType ( ) ) . getMessage ( ) ) ; } if ( node . function ( ) . getName ( ) . equals ( "main" ) && ( node . arguments ( ) . size ( ) > 0 || ! ( ( FuncType ) node . function ( ) . getType ( ) ) . returnType ( ) . equivalent ( new VoidType ( ) ) ) ) { reportError ( node . lineNumber ( ) , node . charPosition ( ) , "Function main has invalid signature." ) ; } }
tr	1	public long getTimeRunning ( class < ? extends Event > type ) { return this . timeRunning . get ( type ) ; }
tr	3	public void update ( User user ) { Session session = null ; try { session = HibernateUtil . getSessionFactory ( ) . openSession ( ) ; session . beginTransaction ( ) ; session . update ( user ) ; session . getTransaction ( ) . commit ( ) ; } catch ( Exception e ) { System . err . println ( "\u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u0432\u0441\u0442\u0430\u0432\u043A\u0435" + e . getMessage ( ) ) ; } finally { if ( session != null && session . isOpen ( ) ) { session . close ( ) ; } } }
tr	0	@ Override public String visit ( AssignmentExpressionNode node ) { return EMPTY ; }
tr	7	public SplitSample < T > contains ( Set < Integer > ids , boolean negate ) { ListSample < T > result = new ListSample < T > ( ) ; for ( T item : this ) { Integer id = membership . get ( item . identifier ( ) ) ; if ( id == null ) { if ( ids . contains ( SplitSample . undefined ) ) result . add ( item ) ; } else if ( ( ! negate && ids . contains ( id ) ) || ( negate && ! ids . contains ( id ) ) ) result . add ( item ) ; } return result ; }
tr	0	public BaseInformation ( ) { this . ecrireInformations ( ) ; }
tr	5	protected void doNext ( ) { doStop ( ) ; runButton . setEnabled ( false ) ; stopButton . setEnabled ( true ) ; logArea . setText ( "" ) ; logArea . setCaretPosition ( 0 ) ; int selectedIndex = demosBox . getSelectedIndex ( ) ; if ( selectedIndex >= 0 ) { selectedIndex ++ ; setTitle ( ( String ) demosBox . getSelectedItem ( ) ) ; final String args = selectedIndex < demosBox . getItemCount ( ) - 1 ? reduceName ( DefaultActorTest . getTestNames ( ) [ selectedIndex ] ) : "*" ; Thread t = new Thread ( new Runnable ( ) { @ Override public void run ( ) { try { if ( "*" . equals ( args ) ) { for ( String name : DefaultActorTest . getTestNames ( ) ) { doStart ( ) ; setTitle ( name ) ; runTest ( reduceName ( name ) ) ; doStop ( ) ; try { Thread . sleep ( 10 * 1000 ) ; } catch ( InterruptedException e ) { break ; } } } else { doStart ( ) ; runTest ( args ) ; doStop ( ) ; } } finally { SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { stopButton . setEnabled ( false ) ; runButton . setEnabled ( true ) ; messageLine . setText ( "Done" ) ; } } ) ; } } } ) ; t . setDaemon ( true ) ; t . start ( ) ; } }
tr	7	private JPanel createFillInTheBlanksQuestion ( ) { _questionLabel . setText ( _fillInTheBlanks . getAnswer ( ) ) ; final SpringLayout springLayout = new SpringLayout ( ) ; final JPanel jPanel = new JPanel ( springLayout ) ; _optionsStrings = _fillInTheBlanks . getBlanks ( ) ; final int [ ] randomList = MathUtilities . generateRandomArray ( _optionsStrings . size ( ) ) ; _answers = new ArrayList < String > ( ) ; for ( int x = 0 ; x < _optionsStrings . size ( ) ; x ++ ) { final String value = _optionsStrings . get ( randomList [ x ] ) ; _answers . add ( _optionsStrings . get ( _optionsStrings . indexOf ( value ) ) ) ; } _optionComboBoxes = new ArrayList < JComboBox > ( ) ; for ( int x = 0 ; x < _optionsStrings . size ( ) ; x ++ ) { final JLabel label = new JLabel ( "Choose #" ) ; final String choice = _optionsStrings . get ( randomList [ x ] ) . toLowerCase ( ) ; springLayout . putConstraint ( SpringLayout . WEST , label , 15 , SpringLayout . WEST , jPanel ) ; springLayout . putConstraint ( SpringLayout . NORTH , label , 45 + x * 35 , SpringLayout . NORTH , jPanel ) ; jPanel . add ( label ) ; Object [ ] choices = new Object [ _optionsStrings . size ( ) + 1 ] ; choices [ 0 ] = "--" ; for ( int y = 0 ; y < choices . length - 1 ; y ++ ) { choices [ y + 1 ] = "[" + y + "]" ; } final JComboBox combobox = new JComboBox ( choices ) ; springLayout . putConstraint ( SpringLayout . WEST , combobox , 10 , SpringLayout . EAST , label ) ; springLayout . putConstraint ( SpringLayout . NORTH , combobox , - 20 , SpringLayout . SOUTH , label ) ; _optionComboBoxes . add ( combobox ) ; combobox . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( final ActionEvent arg0 ) { String question = "" ; if ( _choicesMade . containsKey ( choice ) ) { _choicesMade . remove ( choice ) ; } String begin = "Question #" + new Integer ( _questionData . getQuestionNumber ( ) ) . toString ( ) + ": " ; question = begin + _questionData . getQuestionString ( ) ; final Set < String > keys = _choicesMade . keySet ( ) ; for ( final String key : keys ) { question = replace ( _choicesMade . get ( key ) , question , key ) ; } final int indexToLookFor = combobox . getSelectedIndex ( ) - 1 ; if ( indexToLookFor >= 0 ) { _choicesMade . put ( choice , "[" + indexToLookFor + "]" ) ; question = replace ( "[" + indexToLookFor + "]" , question , choice ) ; } _beginLabel . setText ( question ) ; } private String replace ( final String needle , final String haystack , final String newNeedle ) { String result = haystack ; while ( result . indexOf ( needle ) != - 1 ) { result = result . replace ( needle , newNeedle ) ; } return result ; } } ) ; jPanel . add ( combobox ) ; final JLabel option = new JLabel ( choice ) ; springLayout . putConstraint ( SpringLayout . WEST , option , 10 , SpringLayout . EAST , combobox ) ; springLayout . putConstraint ( SpringLayout . NORTH , option , 1 , SpringLayout . NORTH , combobox ) ; jPanel . add ( option ) ; } final JLabel temp = new JLabel ( ) ; springLayout . putConstraint ( SpringLayout . EAST , jPanel , 600 , SpringLayout . WEST , temp ) ; springLayout . putConstraint ( SpringLayout . SOUTH , jPanel , 250 , SpringLayout . SOUTH , temp ) ; jPanel . setOpaque ( true ) ; return jPanel ; }
tr	8	boolean classHasGlobalMarker ( class < ? > type ) { if ( hasGlobalMarker ( type ) ) return true ; for ( class < ? > in : type . getInterfaces ( ) ) { if ( classHasGlobalMarker ( in ) ) return true ; } for ( class < ? > c = type . getSuperclass ( ) ; c != null ; c = c . getSuperclass ( ) ) { if ( hasGlobalMarker ( c ) ) return true ; } return false ; }
tr	4	protected Tile getTile ( Tile t , Direction step ) { Point location = t . getLocation ( ) ; switch ( step ) { case EAST : return getTile ( new Point ( location . x + 1 , location . y ) ) ; case NORTH : return getTile ( new Point ( location . x , location . y - 1 ) ) ; case SOUTH : return getTile ( new Point ( location . x , location . y + 1 ) ) ; case WEST : return getTile ( new Point ( location . x - 1 , location . y ) ) ; default : return null ; } }
tr	8	public boolean postMortem ( PostMortem pm ) { Node that = ( Node ) pm ; if ( that == null ) { JSONzip . log ( "\nMisalign" ) ; return false ; } if ( this . integer != that . integer ) { JSONzip . log ( "\nInteger " + this . integer + " <> " + that . integer ) ; return false ; } if ( this . next == null ) { if ( that . next == null ) { return true ; } JSONzip . log ( "\nNext is null " + this . integer ) ; return false ; } for ( int i = 0 ; i < 256 ; i += 1 ) { Node node = this . next [ i ] ; if ( node != null ) { if ( ! node . postMortem ( that . next [ i ] ) ) { return false ; } } else if ( that . next [ i ] != null ) { JSONzip . log ( "\nMisalign " + i ) ; return false ; } } return true ; }
tr	9	@ Override public boolean equals ( Object obj ) { if ( obj == this ) { return true ; } if ( obj == null || obj . getClass ( ) != this . getClass ( ) ) { return false ; } DataHolder myDataHolder = ( DataHolder ) obj ; return ( ( this . discountedTable . equals ( myDataHolder . discountedTable ) ) && ( this . heuristicNounTable . equals ( myDataHolder . heuristicNounTable ) ) && ( this . modifierTable . equals ( myDataHolder . modifierTable ) ) && ( this . sentenceTable . equals ( myDataHolder . sentenceTable ) ) && ( this . singularPluralTable . equals ( myDataHolder . singularPluralTable ) ) && ( this . unknownWordTable . equals ( myDataHolder . unknownWordTable ) ) && ( this . wordPOSTable . equals ( myDataHolder . wordPOSTable ) ) && ( this . allWords . equals ( myDataHolder . allWords ) ) ) ; }
tr	5	public void moveLine ( boolean down ) { if ( down ) { if ( ! history . shiftDown ( ) ) { textField . restoreInput ( ) ; } } else if ( history . getText ( ) . contains ( "=" ) ) { history . shiftUp ( ) ; String toInsert = history . getUpperFront ( ) ; if ( toInsert . length ( ) > 0 && toInsert . contains ( "=" ) ) { textField . setText ( toInsert . substring ( 0 , toInsert . indexOf ( "=" ) - 1 ) ) ; } } }
tr	3	public static boolean onOneLine ( XY xy , XY xy2 ) { if ( xy2 . getX ( ) == xy . getX ( ) ) { return true ; } if ( xy2 . getY ( ) == xy . getY ( ) ) { return true ; } int dx = Math . abs ( xy2 . getX ( ) - xy . getX ( ) ) ; int dy = Math . abs ( xy2 . getY ( ) - xy . getY ( ) ) ; if ( dx == dy ) { return true ; } return false ; }
tr	2	private AvlNode findMax ( AvlNode t ) { if ( t == null ) return t ; while ( t . right != null ) t = t . right ; return t ; }
tr	5	@ Override public boolean equals ( Object other ) { if ( other == this ) return true ; if ( other instanceof EntityCoordinate ) { EntityCoordinate asEntityCoordinate = ( EntityCoordinate ) other ; if ( FloatingPointUtils . floatEqual ( asEntityCoordinate . x , this . x ) && FloatingPointUtils . floatEqual ( asEntityCoordinate . y , this . y ) && FloatingPointUtils . floatEqual ( asEntityCoordinate . z , this . z ) ) { return true ; } } return false ; }
tr	4	@ Override public boolean equals ( Object o ) { if ( o == this ) { return true ; } if ( o == null || getClass ( ) != o . getClass ( ) ) { return false ; } Branch other = ( Branch ) o ; return ( repository . equals ( other . repository ) && reference . equals ( other . reference ) ) ; }
tr	8	public int characterAt ( int at ) throws JSONException { int c = get ( at ) ; if ( ( c & 80 ) == 0 ) { return c ; } int character ; int c1 = get ( at + 1 ) ; if ( ( c1 & 80 ) == 0 ) { character = ( ( c & 7F ) << 7 ) | c1 ; if ( character > 7F ) { return character ; } } else { int c2 = get ( at + 2 ) ; character = ( ( c & 7F ) << 14 ) | ( ( c1 & 7F ) << 7 ) | c2 ; if ( ( c2 & 80 ) == 0 && character > 3FFF && character <= 10FFFF && ( character < D800 || character > DFFF ) ) { return character ; } } throw new JSONException ( "Bad character at " + at ) ; }
tr	4	public void immune ( Type primary , Type secondary ) { if ( immuneTypes . length == 0 ) { return ; } for ( int i = 0 ; i < resistantTypes . length ; i ++ ) { if ( immuneTypes [ i ] . equalsTo ( primary . showType ( ) ) || immuneTypes [ i ] . equalsTo ( secondary . showType ( ) ) ) { typeModifier = 0.0 ; } } }
tr	8	public String evaluatePolicy_innerMethod ( TransferredFile policyFileToTransfer , TransferredFile dbSQLDumpFileToTransfer , Context initialContext , long gid ) { logger . writeLog ( Level . ALL , "Method evaluatePolicy_innerMethod  gid:" + gid + "  thread number:" + Thread . currentThread ( ) . getId ( ) ) ; logger . writeLog ( Level . ALL , ( "DBA_utils-Instance #" + this . toString ( ) ) ) ; this . gid = gid ; DataHandler dbDumpFileDataHandler ; try { dbDumpFileDataHandler = convertZipFile ( dbSQLDumpFileToTransfer , dbSQLDumpFileToTransfer . getFileName ( ) ) ; } catch ( ZipException e2 ) { e2 . printStackTrace ( ) ; return "-1  Error: The given file is not a Zip file" ; } catch ( FileNotFoundException e2 ) { e2 . printStackTrace ( ) ; return "-2  Error: Impossible to find the specified file" ; } catch ( IOException e2 ) { e2 . printStackTrace ( ) ; return "-3  I/O Error" ; } Context initContext = null ; if ( initialContext == null ) { try { initContext = new InitialContext ( ) ; } catch ( NamingException e1 ) { e1 . printStackTrace ( ) ; } } else { initContext = initialContext ; } if ( initContext == null ) { return "-4  Error: Null context" ; } MySQLQueryFactory mySQLFactory = null ; try { mySQLFactory = setupAndApplyDBDump ( initContext , dbDumpFileDataHandler . getInputStream ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; return "-5  Problem with input DB dump" ; } if ( mySQLFactory == null ) { return "-5  Problem with input DB dump" ; } String result = policyRiskEvaluator ( policyFileToTransfer , "" , "" , true ) ; mySQLFactory . dropWorkingViews ( gid ) ; mySQLFactory . dropWorkingTable ( gid ) ; MySQLResultsManager rs = new MySQLResultsManager ( ) ; rs . storeResult ( gid , result ) ; return result ; }
tr	5	byte [ ] expandChunkData ( byte [ ] input , int inputLength , byte [ ] buffer , PassthroughConnection ptc ) { if ( buffer . length < inputDataBufferSize + outputDataBufferSize + expandedBufferSize + 320 || inputLength > inputDataBufferSize ) { return null ; } ptc . inflate . reset ( ) ; ptc . inflate . setInput ( input , 0 , inputLength ) ; int outputOffset = inputDataBufferSize + outputDataBufferSize ; int outputLength = expandedBufferSize ; int expandedLength = - 1 ; try { expandedLength = ptc . inflate . inflate ( buffer , outputOffset , outputLength ) ; } catch ( DataFormatException e ) { return null ; } if ( expandedLength != 81920 && expandedLength != 81920 + 320 ) { return null ; } return buffer ; }
tr	3	public void loadFile ( ) { JFileChooser chooser = new JFileChooser ( executableDir ) ; FileNameExtensionFilter filter = new FileNameExtensionFilter ( "Pippin Executable Files" , "pipe" ) ; chooser . setFileFilter ( filter ) ; int openOK = chooser . showOpenDialog ( null ) ; if ( openOK == JFileChooser . APPROVE_OPTION ) { currentlyExecutingFile = chooser . getSelectedFile ( ) ; } if ( currentlyExecutingFile . exists ( ) ) { executableDir = currentlyExecutingFile . getAbsolutePath ( ) ; executableDir = executableDir . replace ( \ , / ) ; int lastSlash = executableDir . lastIndexOf ( / ) ; executableDir = executableDir . substring ( 0 , lastSlash + 1 ) ; try { properties . setProperty ( "SourceDirectory" , sourceDir ) ; properties . setProperty ( "ExecutableDirectory" , executableDir ) ; properties . store ( new FileOutputStream ( "propertyfile.txt" ) , "File locations" ) ; } catch ( Exception e ) { System . out . println ( "Error writing properties file" ) ; } } finalLoad_ReloadStep ( ) ; setChanged ( ) ; notifyObservers ( ) ; }
